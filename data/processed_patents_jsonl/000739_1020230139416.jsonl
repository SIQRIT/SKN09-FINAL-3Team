{"patent_id": "10-2023-0139416", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0055808", "출원번호": "10-2023-0139416", "발명의 명칭": "DNA 서열 파싱을 위한 토크나이저 및 이의 동작 방법", "출원인": "한국과학기술원", "발명자": "김준모"}}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "DNA 서열 파싱을 위한 토크나이저의 동작 방법에 있어서, 4개의 염기(nucleotide)들 중 적어도 하나를 앵커 염기로 설정하는 단계;k번째 앵커 염기와 k+1번째 앵커 염기 사이에 포함된 나머지 염기들 분포에 기초하여 k번째 토큰을 생성하는 단계; 및상기 생성된 토큰을 이용하여 학습을 수행하는 단계를 포함하는 토크나이저의 동작 방법."}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 토큰을 생성하는 단계는염기 서열 상에서 상기 앵커 염기가 있는 k번째 지점을 확인하고, k번째 지점과 k+1번째 지점 사이의 나머지 염기들의 개수 혹은 비율을 검출하는, 토크나이저의 동작 방법."}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 토큰을 생성하는 단계는A, T, G, C의 염기들 순서에 기초하여 k번째 지점과 k+1번째 지점 사이에서 상기 앵커 염기를 제외한 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k번째 토큰으로 생성하는, 토크나이저의 동작 방법."}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "DNA 서열 파싱을 위한 토크나이저의 동작 방법에 있어서, 4개의 염기(nucleotide)들 중 n개의 염기서열을 조합하여 적어도 하나를 앵커 염기서열로 설정하는 단계;k번째 앵커 염기서열과 k+1번째 앵커 염기서열 사이에 포함된 4-n개의 나머지 염기들 분포에 기초하여 k번째 토큰을 생성하는 단계; 및상기 생성된 토큰을 이용하여 학습을 수행하는 단계를 포함하는 토크나이저의 동작 방법."}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 앵커 염기서열로 설정하는 단계는A, T, G, C의 염기들 중에서 n개로 염기서열을 조합하고, 조합된 염기서열들 중에서 적어도 하나의 염기서열을상기 앵커 염기서열로 설정하는, 토크나이저의 동작 방법."}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 조합된 염기서열은공개특허 10-2025-0055808-3-A, T, G, C의 염기들 중 중복된 염기서열을 포함하는 것을 특징으로 하는, 토크나이저의 동작 방법."}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제5항에 있어서,상기 토큰을 생성하는 단계는A, T, G, C의 염기들 순서에 기초하여 k번째 앵커 염기서열과 k+1번째 앵커 염기서열 사이에서 상기 앵커 염기서열을 제외한 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k번째 토큰으로 생성하는, 토크나이저의동작 방법."}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "DNA 서열 파싱을 위한 토크나이저의 동작 방법에 있어서, 4개의 염기(nucleotide)들 중 적어도 하나를 제1 앵커 염기로 설정하는 단계;k번째 제1 앵커 염기와 k+1번째 제1 앵커 염기 사이에 포함된 나머지 염기들 중 적어도 하나를 제2 앵커 염기로설정하는 단계;k번째 제1 앵커 염기와 k+1번째 제1 앵커 염기 사이에 위치한 i번째 제2 앵커 염기와 i+1번째 제2 앵커 염기 사이에 포함된 나머지 염기들 분포에 기초하여 토큰을 생성하는 단계; 및 상기 생성된 토큰을 이용하여 학습을 수행하는 단계를 포함하는 토크나이저의 동작 방법."}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 제2 앵커 염기로 설정하는 단계는k번째 제1 앵커 염기와 k+1번째 제1 앵커 염기 사이에 포함된 적어도 두 개 이상의 염기들 중에서 하나를 상기제2 앵커 염기로 설정하는, 토크나이저의 동작 방법."}
{"patent_id": "10-2023-0139416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 토큰을 생성하는 단계는A, T, G, C의 염기들 순서에 기초하여 k번째 제1 앵커 염기와 i번째 제2 앵커 염기 사이에 포함된 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k번째 토큰으로 생성하고, i번째 제2 앵커 염기와 i+1번째 제2 앵커염기 사이에 포함된 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k+1번째 토큰으로 생성하며, i+1번째 제2 앵커 염기와 k+1번째 제1 앵커 염기 사이에 포함된 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k+1번째 토큰으로 생성하는, 토크나이저의 동작 방법."}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 A, T, G, C의 염기(nucleotide)들 중에서 앵커 염기 또는 앵커 염기서열을 설정하여 생성된 토큰을 이 용하여 학습을 수행하는 DNA 서열 파싱을 위한 토크나이저 및 이의 동작 방법에 관한 것으로서, 4개의 염기 (nucleotide)들 중 적어도 하나를 앵커 염기로 설정하는 단계, k번째 앵커 염기와 k+1번째 앵커 염기 사이에 포 함된 나머지 염기들 분포에 기초하여 k번째 토큰을 생성하는 단계 및 상기 생성된 토큰을 이용하여 학습을 수행 하는 단계를 포함한다."}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 DNA 서열 파싱을 위한 토크나이저 및 이의 동작 방법에 관한 것으로서, 보다 상세하게는 A, T, G, C 의 염기(nucleotide)들 중에서 앵커 염기 또는 앵커 염기서열을 설정하여 생성된 토큰을 이용하여 학습을 수행 하는 기술에 관한 것이다."}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "DNA 서열 파싱을 위한 기존의 토크나이저는 K-mer, Gapped K-mer (gkm), Byte Pair Encoding (BPE) 등이 있다. K-mer에서 K는 토큰에 쓰이는 총 염기 서열의 개수를 의미한다. 예를 들어 K=2인 경우는 {AA, AT, AG, AC, TA,TT, TG, TC, GA, GT, GG, GC, CA, CT, CG, CC}와 같이 16개의 토큰이 생성된다. 이 때, 총 가능한 염기 서열 의 종류가 A, T, G, C의 네 가지이기 때문에 K-mer의 어휘는 총 4K개의 토큰으로 이루어진다. 만약, K가 커지 면 토큰의 종류는 기하급수적으로 늘어나며 DNA를 파싱하고 난 다음의 토큰 서열의 길이는 선형적으로 감소하게 된다. 이에, K가 커질수록 똑같은 길이의 염기 서열을 더 효율적으로 표현할 수 있는 (더 적은 토큰으로 표현 할 수 있는) 장점이 있지만 어휘가 다양해져서 결국 필요 없는 토큰이 생길 수도 있다. 전술한 바와 같이, K가 커질수록 불필요하게 커지는 토큰의 규모(dimension)를 줄이고, 희소(sparse)한 토큰으 로부터 오버피팅(overfitting)되는 것을 방지하기 위해 제안된 방법이 Gapped K-mer (gkm)이다. Gapped K-mer 는 K-mer에서 어느 정도 mismatch (or gap)를 허용하는 토크나이저인데 예를 들어 길이 l 짜리 K-mer에서 k개만 남겨두고 나머지 l-k개를 gap으로써 허용한다면 어휘는 총 lCk·4k개의 토큰으로 구성될 것이다. 더 직접적인 예시를 들자면 3-mer에 해당하는 ACG는 gap이 1인 경우 AC*, A*G, *CG 이렇게 3개의 gkm으로 구성될 것이다. 기존에는 이런 방식을 통해 표현을 더 효율적으로 만들고 누락된 토큰을 방지하였다. 또한, BPE의 경우는 앞서 말했던 방식과 조금 다르게 통신 분야에서 주로 쓰이던 방식으로, 빈번하게 등장하는 두 개의 인접한 문자를 순차적으로 한 문자로 치환해 나가는 방식이다. 예를 들어 abcabc라고 하면 ab가 2개 등장하므로 ab를 Z로 치환하면 ZcZc가 되고 Zc가 또 두 번 등장하므로 Zc를 Y로 치환하면 YY가 되는 방식이다. 이는 실제로 주어진 염기서열에 따라서 문자 치환이 달라질 수 있기 때문에 훈련이 끝나고 테스트 시 일반화가 잘 될지에 대해서는 보장된 바가 없다."}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명의 목적은 동일 길이의 유전체 정보를 토크나이즈(tokenize)할 때 결과물의 토큰(token) 개수를 줄여 입 력 차원이 더 작은 효율적인 인공지능 모델을 개발하거나, 같은 크기의 모델로 더 많은 양의 유전체 정보를 처 리할 수 있도록 하고자 한다. 다만, 본 발명이 해결하고자 하는 기술적 과제들은 상기 과제로 한정되는 것은 아니며, 본 발명의 기술적 사상 및 영역으로부터 벗어나지 않은 범위에서 다양하게 확장될 수 있다."}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 일 실시예에 따른 DNA 서열 파싱을 위한 토크나이저의 동작 방법에 있어서, 4개의 염기(nucleotide) 들 중 적어도 하나를 앵커 염기로 설정하는 단계, k번째 앵커 염기와 k+1번째 앵커 염기 사이에 포함된 나머지 염기들 분포에 기초하여 k번째 토큰을 생성하는 단계 및 상기 생성된 토큰을 이용하여 학습을 수행하는 단계를 포함한다. 본 발명의 다른 실시예에 따른 DNA 서열 파싱을 위한 토크나이저의 동작 방법에 있어서, 4개의 염기 (nucleotide)들 중 n개의 염기서열을 조합하여 적어도 하나를 앵커 염기서열로 설정하는 단계, k번째 앵커 염기 서열과 k+1번째 앵커 염기서열 사이에 포함된 4-n개의 나머지 염기들 분포에 기초하여 k번째 토큰을 생성하는 단계 및 상기 생성된 토큰을 이용하여 학습을 수행하는 단계를 포함한다. 본 발명의 또 다른 실시예에 따른 DNA 서열 파싱을 위한 토크나이저의 동작 방법에 있어서, 4개의 염기 (nucleotide)들 중 적어도 하나를 제1 앵커 염기로 설정하는 단계, k번째 제1 앵커 염기와 k+1번째 제1 앵커 염 기 사이에 포함된 나머지 염기들 중 적어도 하나를 제2 앵커 염기로 설정하는 단계, k번째 제1 앵커 염기와 k+1 번째 제1 앵커 염기 사이에 위치한 i번째 제2 앵커 염기와 i+1번째 제2 앵커 염기 사이에 포함된 나머지 염기들 분포에 기초하여 토큰을 생성하는 단계 및 상기 생성된 토큰을 이용하여 학습을 수행하는 단계를 포함한다."}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 실시예에 따르면, 기준선 내의 앵커 염기 또는 앵커 염기서열을 사용하여 특정 염기의 개수로 벡터화 하기 때문에 한 토큰의 길이를 효율적으로 줄일 수 있고, 염기 서열 내 기준선을 정할 때 이용한 앵커 염기의 개수만큼 토큰이 발생하기 때문에 염기 서열을 표현하는 데 사용되는 총 토큰의 크기가 염기 서열 길이에 바운 드(bound)됨으로써, 효율적인 파싱을 가능케 할 수 있다."}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 2, "content": "다만, 본 발명의 효과는 상기 효과들로 한정되는 것은 아니며, 본 발명의 기술적 사상 및 영역으로부터 벗어나 지 않는 범위에서 다양하게 확장될 수 있다."}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 발명의 이점 및 특징, 그리고 그것들을 달성하는 방법은 첨부되는 도면과 함께 상세하게 후술되어 있는 실시 예들을 참조하면 명확해질 것이다. 그러나, 본 발명은 이하에서 개시되는 실시예들에 한정되는 것이 아니라 서 로 다른 다양한 형태로 구현될 것이며, 단지 본 실시예들은 본 발명의 개시가 완전하도록 하며, 본 발명이 속하"}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "는 기술분야에서 통상의 지식을 가진 자에게 발명의 범주를 완전하게 알려주기 위해 제공되는 것이며, 본 발명 은 청구항의 범주에 의해 정의될 뿐이다. 본 명세서에서 사용된 용어는 실시예들을 설명하기 위한 것이며, 본 발명을 제한하고자 하는 것은 아니다. 본 명세서에서, 단수형은 문구에서 특별히 언급하지 않는 한 복수형도 포함한다. 명세서에서 사용되는 \"포함한다 (comprises)\" 및/또는 \"포함하는(comprising)\"은 언급된 구성요소, 단계, 동작 및/또는 소자는 하나 이상의 다 른 구성요소, 단계, 동작 및/또는 소자의 존재 또는 추가를 배제하지 않는다. 다른 정의가 없다면, 본 명세서에서 사용되는 모든 용어(기술 및 과학적 용어를 포함)는 본 발명이 속하는 기술 분야에서 통상의 지식을 가진 자에게 공통적으로 이해될 수 있는 의미로 사용될 수 있을 것이다. 또한, 일반적 으로 사용되는 사전에 정의되어 있는 용어들은 명백하게 특별히 정의되어 있지 않는 한 이상적으로 또는 과도하 게 해석되지 않는다. 이하, 첨부한 도면들을 참조하여, 본 발명의 바람직한 실시예들을 보다 상세하게 설명하고자 한다. 도면 상의 동일한 구성요소에 대해서는 동일한 참조 부호를 사용하고 동일한 구성요소에 대해서 중복된 설명은 생략한다. 본 발명은 A, T, G, C의 염기(nucleotide)들 중에서 앵커 염기 또는 앵커 염기서열을 설정하여 생성된 토큰을 이용하여 학습을 수행하는 것을 그 요지로 한다. 본 발명은 일 실시예에 따라서 염기들 중에서 하나를 앵커 염기로 설정하거나, 다른 실시예에 따라서 n개의 염 기서열을 조합하여 하나를 앵커 염기서열로 설정하거나, 또 다른 실시예에 따라서 제1 앵커 염기 및 제2 앵커 염기로 설정함으로써, 효율적인 DNA 서열 파싱을 위해서 어떤 기준선 내에 있는 염기 서열의 개수로 토크나이징 하는 방식을 제안하는 것을 특징으로 한다. 이하에서는 도 1 내지 도 5를 참조하여 본 발명에 대해 상세히 설명한다. 도 1은 본 발명의 일 실시예에 따른 토크나이저의 동작 방법의 동작 흐름도를 도시한 것이고, 도 2는 본 발명의 다른 실시예에 따른 토크나이저의 동작 방법의 동작 흐름도를 도시한 것이며, 도 3은 본 발명의 또 다른 실시예 에 따른 토크나이저의 동작 방법의 동작 흐름도를 도시한 것이다. 또한, 도 4는 본 발명의 실시예에 따른 DNA 서열 파싱을 위한 토크나이저의 동작을 설명하기 위해 도시한 것이다. 도 1 내지 도 3에 도시된 본 발명의 실시예에 따른 토크나이저의 동작 방법은 도 5에 도시된 본 발명의 실시예 에 따른 토크나이저 또는 토크나이저 시스템에 의해 수행된다. 도 1을 참조하면, 단계 S110에서, 4개의 염기(nucleotide)들 중 적어도 하나를 앵커 염기로 설정한다. 단계 S110은 A, T, G, C의 염기들 중에서 적어도 하나를 앵커 염기로 설정하여 기준선을 결정할 수 있다. 보다 구체 적으로, 4개의 염기들 중에서 A 염기를 앵커 염기로 설정한다면, 주어진 DNA 서열에서 A 염기가 등장하는 곳을 기점으로 기준선이 정해진다고 생각하면 된다. 예를 들어, j번째 A와 j+1번째 A 사이의 기준선을 생각하면 기준선 내에는 A 염기가 없고 오로지 T, G, C 염기들로만 이루어졌거나, 아무것도 없을 것이다. 단계 S120에서, k번째 앵커 염기와 k+1번째 앵커 염기 사이에 포함된 나머지 염기들 분포에 기초하여 k번째 토 큰을 생성한다. 단계 S120은 염기 서열 상에서 앵커 염기가 있는 k번째 지점을 확인하고, k번째 지점과 k+1번째 지점 사이의 나 머지 염기들의 개수 혹은 비율을 검출할 수 있다. 또한, 단계 S120은 A, T, G, C의 염기들 순서에 기초하여 k 번째 지점과 k+1번째 지점 사이에서 앵커 염기를 제외한 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k번째 토큰으로 생성할 수 있다. 보다 구체적으로, 단계 S110에서 결정된 기준선에 대해서, T, G, C의 개수를 입력해 벡터화하면 토큰이 생성될 수 있다. 예를 들어, DNA 서열이 ATTCGA라고 하면 앵커 염기가 A이므로, A 염기 사이에 위치하는 T가 2개, G가 1개, C가 1개이므로, {2, 1, 1} 토큰이 생성된다. 이 때, A로 앵커 염기를 설정하지 않고, T, G, C 전부 다 앵커 염기로 설정할 수 있으므로, 경우에 따라서 네 가지 선택지 중 가장 적합 한 방법이 선택될 수 있다. 도 4를 참조하여 보다 상세히 설명하자면, AGTCCTAGGTACTTCTGT의 DNA 염기 서열이 주어진 경우에 단계 S110에서 4개의 염기들 중 T 염기를 앵커 염기로 설정한 것으로 가정하면, 염기 서열 상에서 T 염기가 있 는 지점을 확인하며, k번째 앵커 염기와 k+1번째 앵커 염기 사이에 포함된 나머지 염기들이 위치한다. 이 에, 단계 S120은 k번째 앵커 염기와 k+1번째 앵커 염기 사이에 포함된 나머지 염기들의 개수 혹은 비율로 k번째 토큰을 생성한다. 예를 들어, 3번째 앵커 염기와 4번째 앵커 염기 사이에 A가 1개, G가 2개, C가 0개인 염기들이 위치하며, 염기들의 개수를 차례대로 입력한 {1, 2, 0}의 3차원 벡터를 3번 째 토큰으로 생성할 수 있다. 다시 도 1을 참조하면, 단계 S130에서, 생성된 토큰을 이용하여 학습을 수행한다. 단계 S130은 단계 S120에서 생성된 토큰 서열을 트랜스포머 학습에 이용할 수 있다. 여기서, 트랜스포머(Transformer)는 기존의 seq2seq의 구조인 인코더-디코더를 따르면서도 어텐션(Attention)만으로 구현한 모델로, RNN을 사용하지 않고, 인코더-디 코더 구조를 설계하였음에도 번역 성능에서도 RNN보다 우수한 성능을 보여주는 모델이다. 이러한 트랜스포머를"}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "학습하는 구성은 관련 기술분야에서 널리 사용되고 있는 것이므로, 상세한 설명은 생략한다. 도 2를 참조하면, 단계 S210에서, 4개의 염기(nucleotide)들 중 n개의 염기서열을 조합하여 적어도 하나를 앵커 염기서열로 설정한다. 단계 S210은 A, T, G, C의 염기들 중에서 n개로 염기서열을 조합하고, 조합된 염기서열들 중에서 적어도 하나의 염기서열을 앵커 염기서열로 설정할 수 있다. 이 때, 조합된 염기서열은 A, T, G, C의 염기들 중 중복된 염기 서열을 포함할 수 있다. 보다 구체적으로, 단계 S210은 일반적인 n개의 염기서열의 조합 중 하나를 기준선으로 결정할 수 있다. 예를 들어, n=2인 경우, A, T, G, C의 4개의 염기들로 만들 수 있는 두 개의 염기서열 조합 중 하나를 앵커 염기서열로 설정할 수 있으며, 이 때, 중복으로 들어가는 AA, TT, GG, CC의 경우도 앵커 염기서 열로 설정이 가능하다. 이렇게 일반적인 n에 대해 파싱을 할 때는 앵커 염기서열 사이의 부분 서열을 2n가지의 조합에 대해서 각 조합이 얼마나 나오는지 숫자로 표현할 수 있다. 단계 S220에서, k번째 앵커 염기서열과 k+1번째 앵커 염기서열 사이에 포함된 4-n개의 나머지 염기들 분포에 기 초하여 k번째 토큰을 생성한다. 단계 S220은 A, T, G, C의 염기들 순서에 기초하여 k번째 앵커 염기서열과 k+1 번째 앵커 염기서열 사이에서 앵커 염기서열을 제외한 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k 번째 토큰으로 생성할 수 있다. 도 4를 참조하여 예를 들면, AGTCCTAGGTACTTCTGT의 DNA 염기 서열이 주어 진 경우에, 단계 S210에서 4개의 염기들 중에서 TA를 앵커 염기서열로 설정한 것으로 가정하면, 3번째 앵커 염 기와 오른쪽에 A 염기가 결합된 TA를 1번째 앵커 염기서열로 설정하고, 4번째 앵커 염기와 오른쪽에 A 염기가 결합된 TA를 2번째 앵커 염기서열로 설정할 수 있다. 이에, 1번째 앵커 염기서열과 2번째 앵커 염기 서열 사이에 G가 2개, C가 0개인 염기들이 위치하며, 단계 S220은 염기의 개수를 차례대로 입력한 {2, 0}의 3차 원 벡터를 토큰으로 생성할 수 있다. 다시 도 2를 참조하면, 단계 S230에서, 생성된 토큰을 이용하여 학습을 수행한다. 단계 S230은 단계 S120에서 생성된 토큰 서열을 트랜스포머 학습에 이용할 수 있다. 도 1에서 기준선 사이의 부분 서열을 코딩할 때 염기서열의 개수로 코딩하는 것은 같은 코딩 값을 가지는 서로 다른 부분 서열이 존재한다. 예를 들어, AT, TA는 서로 다른 서열이지만 A의 개수, T의 개수로 보면 {1, 1}로 동일하다. 이러한 정보 손실을 최소화하기 위해서 도 3에서 본 발명은 기준선 사이의 부분 서열을 코딩할 때, 다시 한번 기준선을 정해서 재귀적으로 코딩을 취해주는 방식을 제안한다. 도 3을 참조하면, 단계 S310에서, 4개의 염기(nucleotide)들 중 적어도 하나를 제1 앵커 염기로 설정한다. 단 계 S310은 A, T, G, C의 염기들 중에서 적어도 하나를 제1 앵커 염기로 설정하여 기준선을 결정할 수 있다. 보 다 구체적으로, 4개의 염기들 중에서 A 염기를 앵커 염기로 설정한다면, 주어진 DNA 서열에서 A 염기가 등장하 는 곳을 기점으로 기준선이 정해진다고 생각하면 된다. 예를 들어, j번째 A와 j+1번째 A 사이의 기준선을 생각 하면 기준선 내에는 A 염기가 없고 오로지 T, G, C 염기들로만 이루어졌거나, 아무것도 없을 것이다. 단계 S320에서, k번째 제1 앵커 염기와 k+1번째 제1 앵커 염기 사이에 포함된 나머지 염기들 중 적어도 하나를 제2 앵커 염기로 설정한다. 단계 S320은 제1 앵커 염기를 제외한 3개의 염기들 중에서 k번째 제1 앵커 염기와 k+1번째 제1 앵커 염기 사이에 포함된 나머지 염기들 중 적어도 하나를 제2 앵커 염기로 설정할 수 있다. 보다 구체적으로, 4개의 염기들 중에서 A 염기를 앵커 염기로 설정한다면, k번째 A 염기와 k+1번째 A 염기 사이에 위 치하는 T, G, C 염기들 중에서 어느 하나를 제2 앵커 염기로 설정할 수 있다. 예를 들어, i번째 G와 i+1번째 G 사이의 기준선을 생각하면 기준선 내에는 A 및 G 염기가 없고 오로지 T, C 염기들로만 이루어졌거나, 아무것도 없을 것이다. 단계 S330에서, k번째 제1 앵커 염기와 k+1번째 제1 앵커 염기 사이에 위치한 i번째 제2 앵커 염기와 i+1번째 제2 앵커 염기 사이에 포함된 나머지 염기들 분포에 기초하여 토큰을 생성한다. 단계 S330은 A, T, G, C의 염기들 순서에 기초하여 k번째 제1 앵커 염기와 i번째 제2 앵커 염기 사이에 포함된 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k번째 토큰으로 생성하고, i번째 제2 앵커 염기와 i+1번 째 제2 앵커 염기 사이에 포함된 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k+1번째 토큰으로 생성 하며, i+1번째 제2 앵커 염기와 k+1번째 제1 앵커 염기 사이에 포함된 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k+1번째 토큰으로 생성할 수 있다. 도 4를 참조하여 보다 상세히 설명하자면, AGTCCTAGGTACTTCTGT의 DNA 염기 서열이 주어진 경우에 단계 S310에서 4개의 염기들 중 T 염기를 제1 앵커 염기로 설정하고, G 염기를 제2 앵커로 설정한 것으로 가정하면, 3번째 제1 앵커 염기와 4번째 제1 앵커 염기 사이에 2번째 제2 앵커 염기 및 3번째 제2 앵커 염 기가 위치할 수 있다. 이에, 3번째 제1 앵커 염기와 2번째 제2 앵커 염기 사이에 A가 1개, C가 0개인 염기들이 위치하며, 염기들의 개수를 차례대로 입력한 {1, 0}의 3차원 벡터를 토큰으로 생성할 수 있다. 다만, 2번째 제2 앵커 염기와 3번째 제2 앵커 염기 사이, 및 3번째 제2 앵커 염기와 4번째 제1 앵커 염기 사이에는 염기가 아무것도 없으므로, 토큰화하지 않는다. 다시 도 3을 참조하면, 단계 S340에서, 생성된 토큰을 이용하여 학습을 수행한다. 단계 S340은 단계 S330에서 생성된 토큰 서열을 트랜스포머 학습에 이용할 수 있다. 기존에 많이 쓰였던 토크나이저 방식인 K-mer 방식은 길이 N짜리 염기 서열을 표현하는데 N개의 토큰이 사용된 다. 반면에, 본 발명의 실시예에 따른 토크나이저의 동작 방법은 평균적으로 N/4만큼 토큰이 사용되는데 이는 다음과 같이 증명될 수 있다. 본 발명의 실시예에 따른 토크나이저의 동작 방법에서 제안하는 방식에 따르면, 길이 N의 염기서열에 대해서 평 균적으로 N/4 + 1개의 토큰이 발생한다. 이는, 본 발명에서 제안하는 방식을 적용하면 토큰의 개수가 T의 개수 + 1이므로, T의 개수의 평균을 구하면 된다. 이하의 [수학식 1]을 통해 확률 변수 Xi를 정의한다. [수학식 1] 이로 인해, T의 총 개수에 대한 확률 변수는 가 된다. 그리고, i번째 base가 T일 확률은 1/4이기 때문 에, T의 총 개수의 평균은 가 된다. 이러한 이유로 기존에 많이 사용되던 K-mer에 비해 본 발명은 토큰의 개수를 평균적으로 거의 25%로 줄일 수 있 기 때문에 효율적인 토큰화가 가능하다. BPE의 경우에는 어휘의 크기(총 단어의 종류 수)에 따라 토큰의 개수 가 달라지기 때문에 이와의 비교는 실험을 통해 진행하였다. 또한, 부수적인 효과로 토큰 하나에 대해서도 효 율적인 표현력을 가질 수 있는데 만약, T를 기점으로 A, G, C의 개수로 토큰을 생성하기 때문에 길이 3의 벡터 로 더 효율적인 표현력을 나타낼 수 있다. 전술한 내용은 도 1에 도시된 본 발명의 일 실시예에 따른 구성을 나타낸다. 도 2에 도시된 본 발명의 다른 실시예에 따른 구성은 k에 대해서 평균적인 길이를 N/2k까지 줄일 수 있다. 또한, 도 3에 도시된 본 발명의 또 다른 실시예에 따른 구성은 도 1에 도시된 본 발명의 일 실시예에 따 른 구성에 대해서 재귀를 적용한 횟수만큼 비례해 길이가 증가한다. 도 5는 본 발명의 실시예에 따른 토크나이저의 세부 구성을 블록도로 도시한 것이다. 도 5의 본 발명의 실시예에 따른 토크나이저는 A, T, G, C의 염기(nucleotide)들 중에서 앵커 염기 또는 앵커 염기서열을 설정하여 생성된 토큰을 이용하여 학습을 수행한다. 이를 위해, 본 발명의 실시예에 따른 토크나이저는 설정부, 토큰 생성부 및 수행부를 포함 한다. 설정부는 4개의 염기(nucleotide)들 중에서 앵커 염기를 설정한다. 일 실시예로, 설정부는 4개의 염기(nucleotide)들 중 적어도 하나를 앵커 염기로 설정할 수 있다. 설정부 는 A, T, G, C의 염기들 중에서 적어도 하나를 앵커 염기로 설정하여 기준선을 결정할 수 있다. 보다 구 체적으로, 4개의 염기들 중에서 A 염기를 앵커 염기로 설정한다면, 주어진 DNA 서열에서 A 염기가 등장하는 곳 을 기점으로 기준선이 정해진다고 생각하면 된다. 예를 들어, j번째 A와 j+1번째 A 사이의 기준선을 생각하면 기준선 내에는 A 염기가 없고 오로지 T, G, C 염기들로만 이루어졌거나, 아무것도 없을 것이다. 다른 실시예로, 설정부는 A, T, G, C의 염기들 중에서 n개로 염기서열을 조합하고, 조합된 염기서열들 중 에서 적어도 하나의 염기서열을 앵커 염기서열로 설정할 수 있다. 이 때, 조합된 염기서열은 A, T, G, C의 염 기들 중 중복된 염기서열을 포함할 수 있다. 보다 구체적으로, 설정부는 일반적인 n개의 염기서열의 조합 중 하나를 기준선으로 결정할 수 있다. 예를 들어, n=2인 경우, A, T, G, C의 4개의 염기들로 만들 수 있는 두 개의 염기서열 조합 중 하나를 앵커 염기서열로 설정할 수 있으며, 이 때, 중복으로 들어가는 AA, TT, GG, CC의 경우도 앵커 염기서열로 설정이 가능하다. 이렇게 일반적인 n에 대해 파싱을 할 때는 앵커 염기서열 사이의 부 분 서열을 2n가지의 조합에 대해서 각 조합이 얼마나 나오는지 숫자로 표현할 수 있다. 또 다른 실시예로, 설정부는 4개의 염기(nucleotide)들 중 적어도 하나를 제1 앵커 염기로 설정한다. 설 정부는 A, T, G, C의 염기들 중에서 적어도 하나를 제1 앵커 염기로 설정하여 기준선을 결정할 수 있다. 보다 구체적으로, 4개의 염기들 중에서 A 염기를 앵커 염기로 설정한다면, 주어진 DNA 서열에서 A 염기가 등장 하는 곳을 기점으로 기준선이 정해진다고 생각하면 된다. 예를 들어, j번째 A와 j+1번째 A 사이의 기준선을 생 각하면 기준선 내에는 A 염기가 없고 오로지 T, G, C 염기들로만 이루어졌거나, 아무것도 없을 것이다. 또한, 설정부는 k번째 제1 앵커 염기와 k+1번째 제1 앵커 염기 사이에 포함된 나머지 염기들 중 적어도 하 나를 제2 앵커 염기로 설정할 수 있다. 설정부는 제1 앵커 염기를 제외한 3개의 염기들 중에서 k번째 제1 앵커 염기와 k+1번째 제1 앵커 염기 사이에 포함된 나머지 염기들 중 적어도 하나를 제2 앵커 염기로 설정할 수 있다. 보다 구체적으로, 4개의 염기들 중에서 A 염기를 앵커 염기로 설정한다면, k번째 A 염기와 k+1번째 A 염 기 사이에 위치하는 T, G, C 염기들 중에서 어느 하나를 제2 앵커 염기로 설정할 수 있다. 예를 들어, i번째 G 와 i+1번째 G 사이의 기준선을 생각하면 기준선 내에는 A 및 G 염기가 없고 오로지 T, C 염기들로만 이루어졌거 나, 아무것도 없을 것이다. 토큰 생성부는 앵커 염기 사이에 포함된 나머지 염기들 분포에 기초하여 k번째 토큰을 생성한다. 일 실시예로, 토큰 생성부는 염기 서열 상에서 앵커 염기가 있는 k번째 지점을 확인하고, k번째 지점과 k+1번째 지점 사이의 나머지 염기들의 개수 혹은 비율을 검출할 수 있다. 또한, 토큰 생성부는 A, T, G, C의 염기들 순서에 기초하여 k번째 지점과 k+1번째 지점 사이에서 앵커 염기를 제외한 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k번째 토큰으로 생성할 수 있다. 보다 구체적으로, 설정부에서 결정된 기 준선에 대해서, T, G, C의 개수를 입력해 벡터화하면 토큰이 생성될 수 있다. 예를 들어, DNA 서열이 ATTCGA라 고 하면 앵커 염기가 A이므로, A 염기 사이에 위치하는 T가 2개, G가 1개, C가 1개이므로, {2, 1, 1} 토큰이 생 성된다. 이 때, A로 앵커 염기를 설정하지 않고, T, G, C 전무 다 앵커 염기로 설정할 수 있으므로, 경우에 따 라서 네 가지 선택지 중 가장 적합한 방법이 선택될 수 있다. 다른 실시예로, 토큰 생성부는 k번째 앵커 염기서열과 k+1번째 앵커 염기서열 사이에 포함된 4-n개의 나머 지 염기들 분포에 기초하여 k번째 토큰을 생성한다. 토큰 생성부는 A, T, G, C의 염기들 순서에 기초하여 k번째 앵커 염기서열과 k+1번째 앵커 염기서열 사이에서 앵커 염기서열을 제외한 나머지 염기들의 개수를 차례 대로 입력한 3차원 벡터를 k번째 토큰으로 생성할 수 있다. 예를 들면, AGTCCTAGGTACTTCTGT의 DNA 염기 서열이 주어진 경우에, 4개의 염기들 중에서 TA를 앵커 염기서열로 설정한 것으로 가정하면, 1번째 앵커 염기서열과 2 번째 앵커 염기서열 사이에 G가 2개, C가 0개인 염기들이 위치하며, 토큰 생성부는 염기의 개수를 차례대 로 입력한 {2, 0}의 3차원 벡터를 토큰으로 생성할 수 있다. 또 다른 실시예로, 토큰 생성부는 k번째 제1 앵커 염기와 k+1번째 제1 앵커 염기 사이에 위치한 i번째 제2 앵커 염기와 i+1번째 제2 앵커 염기 사이에 포함된 나머지 염기들 분포에 기초하여 토큰을 생성한다. 토큰 생성부는 A, T, G, C의 염기들 순서에 기초하여 k번째 제1 앵커 염기와 i번째 제2 앵커 염기 사이에 포함된 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k번째 토큰으로 생성하고, i번째 제2 앵커 염기 와 i+1번째 제2 앵커 염기 사이에 포함된 나머지 염기들의 개수를 차례대로 입력한 3차원 벡터를 k+1번째 토큰 으로 생성하며, i+1번째 제2 앵커 염기와 k+1번째 제1 앵커 염기 사이에 포함된 나머지 염기들의 개수를 차례대 로 입력한 3차원 벡터를 k+1번째 토큰으로 생성할 수 있다. 예를 들면, AGTCCTAGGTACTTCTGT의 DNA 염기 서열이 주어진 경우에 설정부에서 4개의 염기들 중 T 염기를 제1 앵커 염기로 설정하고, G 염기를 제2 앵커로 설 정한 것으로 가정하면, 3번째 제1 앵커 염기와 4번째 제1 앵커 염기 사이에 2번째 제2 앵커 염기 및 3번째 제2 앵커 염기가 위치할 수 있다. 이에, 3번째 제1 앵커 염기와 2번째 제2 앵커 염기 사이에 A가 1개, C가 0개인 염기들이 위치하며, 염기들의 개수를 차례대로 입력한 {1, 0}의 3차원 벡터를 토큰으로 생성할 수 있다. 다만, 2번째 제2 앵커 염기와 3번째 제2 앵커 염기 사이, 및 3번째 제2 앵커 염기와 4번째 제1 앵커 염기 사이에는 염 기가 아무것도 없으므로, 토큰화하지 않는다. 수행부는 생성된 토큰을 이용하여 학습을 수행한다. 수행부는 토큰 생성부에서 생성된 토큰 서 열을 트랜스포머 학습에 이용할 수 있다. 여기서, 트랜스포머(Transformer)는 기존의 seq2seq의 구조인 인코더 -디코더를 따르면서도 어텐션(Attention)만으로 구현한 모델로, RNN을 사용하지 않고, 인코더-디코더 구조를 설 계하였음에도 번역 성능에서도 RNN보다 우수한 성능을 보여주는 모델이다. 이러한 트랜스포머를 학습하는 구성"}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "은 관련 기술분야에서 널리 사용되고 있는 것이므로, 상세한 설명은 생략한다. 비록, 도 5의 시스템에서 그 설명이 생략되었더라도, 도 5를 구성하는 각 구성 수단은 도 1 내지 도 4에서 설명 한 모든 내용을 포함할 수 있으며, 이는 이 기술 분야에 종사하는 당업자에게 있어서 자명하다. 이상에서 설명된 시스템 또는 장치는 하드웨어 구성요소, 소프트웨어 구성요소, 및/또는 하드웨어 구성요소 및 소프트웨어 구성요소의 조합으로 구현될 수 있다. 예를 들어, 실시예들에서 설명된 장치 및 구성요소는, 예를 들어, 프로세서, 콘트롤러, ALU(arithmetic logic unit), 디지털 신호 프로세서(digital signal processor), 마이크로컴퓨터, FPGA(Field Programmable Gate Array), PLU(programmable logic unit), 마이크로프로세서, 또 는 명령(instruction)을 실행하고 응답할 수 있는 다른 어떠한 장치와 같이, 하나 이상의 범용 컴퓨터 또는 특 수 목적 컴퓨터를 이용하여 구현될 수 있다. 처리 장치는 운영 체제(OS) 및 상기 운영 체제 상에서 수행되는 하나 이상의 소프트웨어 어플리케이션을 수행할 수 있다. 또한, 처리 장치는 소프트웨어의 실행에 응답하여, 데이터를 접근, 저장, 조작, 처리 및 생성할 수도 있다. 이해의 편의를 위하여, 처리 장치는 하나가 사용되는"}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "것으로 설명된 경우도 있지만, 해당 기술분야에서 통상의 지식을 가진 자는, 처리 장치가 복수 개의 처리 요소 (processing element) 및/또는 복수 유형의 처리 요소를 포함할 수 있음을 알 수 있다. 예를 들어, 처리 장치는 복수 개의 프로세서 또는 하나의 프로세서 및 하나의 콘트롤러를 포함할 수 있다. 또한, 병렬 프로세서 (parallel processor)와 같은, 다른 처리 구성(processing configuration)도 가능하다. 소프트웨어는 컴퓨터 프로그램(computer program), 코드(code), 명령(instruction), 또는 이들 중 하나 이상의 조합을 포함할 수 있으며, 원하는 대로 동작하도록 처리 장치를 구성하거나 독립적으로 또는 결합적으로 (collectively) 처리 장치를 명령할 수 있다. 소프트웨어 및/또는 데이터는, 처리 장치에 의하여 해석되거나 처리 장치에 명령 또는 데이터를 제공하기 위하여, 어떤 유형의 기계, 구성요소(component), 물리적 장치, 가상 장치(virtual equipment), 컴퓨터 저장 매체 또는 장치, 또는 전송되는 신호 파(signal wave)에 영구적으로, 또는 일시적으로 구체화(embody)될 수 있다. 소프트웨어는 네트워크로 연결된 컴퓨터 시스템 상에 분산되어서, 분산된 방법으로 저장되거나 실행될 수도 있다. 소프트웨어 및 데이터는 하나 이상의 컴퓨터 판독 가능 기록 매체에 저장될 수 있다. 실시예에 따른 방법은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 상기 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등 을 단독으로 또는 조합하여 포함할 수 있다. 상기 매체에 기록되는 프로그램 명령은 실시예를 위하여 특별히 설계되고 구성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판 독 가능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD-ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체 (magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도 록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다. 상기된 하드웨어 장치는 실시예의 동작을 수행하기 위해 하나 이상의 소프트웨어 모듈로서 작동하도 록 구성될 수 있으며, 그 역도 마찬가지이다."}
{"patent_id": "10-2023-0139416", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "이상과 같이 실시예들이 비록 한정된 실시예와 도면에 의해 설명되었으나, 해당 기술분야에서 통상의 지식을 가 진 자라면 상기의 기재로부터 다양한 수정 및 변형이 가능하다. 예를 들어, 설명된 기술들이 설명된 방법과 다 른 순서로 수행되거나, 및/또는 설명된 시스템, 구조, 장치, 회로 등의 구성요소들이 설명된 방법과 다른 형태 로 결합 또는 조합되거나, 다른 구성요소 또는 균등물에 의하여 대치되거나 치환되더라도 적절한 결과가 달성될 수 있다. 그러므로, 다른 구현들, 다른 실시예들 및 특허청구범위와 균등한 것들도 후술하는 특허청구범위의 범위에 속한 다.도면 도면1 도면2 도면3 도면4 도면5"}
{"patent_id": "10-2023-0139416", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 일 실시예에 따른 토크나이저의 동작 방법의 동작 흐름도를 도시한 것이다. 도 2는 본 발명의 다른 실시예에 따른 토크나이저의 동작 방법의 동작 흐름도를 도시한 것이다. 도 3은 본 발명의 또 다른 실시예에 따른 토크나이저의 동작 방법의 동작 흐름도를 도시한 것이다. 도 4는 본 발명의 실시예에 따른 DNA 서열 파싱을 위한 토크나이저의 동작을 설명하기 위해 도시한 것이다. 도 5는 본 발명의 실시예에 따른 토크나이저의 세부 구성을 블록도로 도시한 것이다."}
