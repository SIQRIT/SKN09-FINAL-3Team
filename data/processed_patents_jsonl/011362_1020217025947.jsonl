{"patent_id": "10-2021-7025947", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0115004", "출원번호": "10-2021-7025947", "발명의 명칭": "객체 점프 제어 방법 및 장치, 그리고 컴퓨터 디바이스 및 저장 매체", "출원인": "텐센트 테크놀로지", "발명자": "리 하이타오"}}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨터 디바이스에 의해 수행되는 객체 점프 제어(object jump control) 방법으로서,가상 장면 내의 제1 가상 객체가 목적지로 이동하는 프로세스에서, 상기 제1 가상 객체의 현재 포지션이 점프조건을 충족할 때 상기 목적지의 포지션에 따라 상기 제1 가상 객체의 타깃 랜딩 지점(target landing point)을결정하는 단계;상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라, 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하는 상기 제1 가상 객체의 점프 궤적을 결정하는 단계; 및상기 점프 궤적에 따라 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하도록 상기 제1 가상 객체를 제어하는 단계를 포함하는,객체 점프 제어 방법."}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 제1 가상 객체의 현재 포지션이 점프 조건을 충족할 때 상기 목적지의 포지션에 따라 상기 제1 가상 객체의 타깃 랜딩 지점을 결정하는 단계는:상기 목적지의 보행 구역(walking region)에 기초하여, 상기 현재 포지션이 상기 점프 조건을 충족할 때 상기보행 구역에 위치된 타깃 랜딩 지점을 결정하는 단계 ― 상기 보행 구역 내의 임의의 포지션과 상기 목적지 사이에는 보행 경로가 존재함 ―;상기 현재 포지션이 상기 점프 조건을 충족할 때 상기 가상 장면에서 상기 목적지에 가장 가까운 포지션을 상기타깃 랜딩 지점으로서 결정하는 단계;상기 현재 포지션이 상기 점프 조건을 충족할 때 상기 가상 장면에서 상기 목적지의 인접한 포지션을 상기 타깃랜딩 지점으로서 결정하는 단계; 또는상기 현재 포지션이 점프 조건을 충족할 때 상기 목적지를 상기 타깃 랜딩 지점으로서 결정하는 단계중 임의의 단계를 포함하는,객체 점프 제어 방법."}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 목적지의 보행 구역에 기초하여, 상기 보행 구역에 위치된 타깃 랜딩 지점을 결정하는 단계는:상기 제1 가상 객체의 최대 점프 속도에 따라, 상기 보행 구역에서 상기 최대 점프 속도에 대응하는 타깃 랜딩지점을 획득하는 단계; 또는상기 보행 구역에서 선택된 포지션을 획득하고, 상기 선택된 포지션을 상기 타깃 랜딩 지점으로서 결정하는 단계중 임의의 단계를 포함하는,객체 점프 제어 방법."}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,공개특허 10-2021-0115004-3-상기 목적지는 상기 가상 장면 내의 타깃 가상 객체의 현재 포지션 또는 상기 가상 장면 내의 선택된 포지션을참조하는,객체 점프 제어 방법."}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,상기 점프 조건은: 상기 현재 포지션과 상기 목적지 사이에 어떠한 보행 경로도 존재하지 않는 것, 또는 상기현재 포지션과 상기 목적지 간의 최단 경로의 방향으로 상기 현재 포지션의 전방에 장애물이 존재하는 것을 포함하는,객체 점프 제어 방법."}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라, 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하는 상기 제1 가상 객체의 점프 궤적을 결정하는 단계는:상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라 상기 현재 포지션에서의 상기 제1 가상 객체의 점프 속도를결정하는 단계; 및상기 점프 속도에 따라 상기 현재 포지션으로부터 상기 타깃 랜딩 지점까지의 상기 제1 가상 객체의 점프 궤적을 결정하는 단계를 포함하는,객체 점프 제어 방법."}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라, 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하는 상기 제1 가상 객체의 점프 궤적을 결정하는 단계 전에, 상기 방법은:상기 현재 포지션과 상기 목적지 사이에 점프 장애물이 있을 때 상기 제1 가상 객체를 이동시키고, 상기 이동이후 상기 제1 가상 객체의 현재 포지션을 획득하는 단계를 더 포함하며,상기 이동 이후 상기 제1 가상 객체와 상기 타깃 랜딩 지점 간의 거리는 상기 이동 전의 상기 제1 가상 객체와상기 타깃 랜딩 지점 간의 거리보다 더 먼,객체 점프 제어 방법."}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 점프 궤적에 따라 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하도록 상기 제1 가상 객체를 제어하는 단계는:상기 점프 궤적에 따라, 상기 현재 포지션을 떠난 후 그리고 상기 타깃 랜딩 지점에 도달하기 전에 상기 제1 가상 객체의 복수의 공중 포지션들을 획득하는 단계;상기 복수의 공중 포지션들에 기초하여 상기 제1 가상 객체의 복수의 중간 이미지들을 획득하는 단계 ― 각각의중간 이미지는 공중 포지션에 위치된 상기 제1 가상 객체를 디스플레이하는 데 사용됨 ―; 및상기 복수의 중간 이미지들의 플레이 시퀀스(play sequence)에 기초하여 상기 복수의 중간 이미지들을 플레이하는 단계를 포함하는,객체 점프 제어 방법.공개특허 10-2021-0115004-4-청구항 9 객체 점프 제어 장치로서,가상 장면 내의 제1 가상 객체가 목적지로 이동하는 프로세스에서, 상기 제1 가상 객체의 현재 포지션이 점프조건을 충족할 때 상기 목적지의 포지션에 따라 상기 제1 가상 객체의 타깃 랜딩 지점을 결정하도록 구성된 결정 모듈;― 상기 결정 모듈은 상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라, 상기 현재 포지션에서 상기 타깃 랜딩지점으로 점프하는 상기 제1 가상 객체의 점프 궤적을 결정하도록 추가로 구성됨 ―; 및상기 점프 궤적에 따라 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하도록 상기 제1 가상 객체를 제어하도록 구성된 점프 제어 모듈을 포함하는,객체 점프 제어 장치."}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "메모리 및 프로세서를 포함하는 컴퓨터 디바이스로서,상기 메모리는 컴퓨터 판독 가능 명령들을 저장하고,상기 컴퓨터 판독 가능 명령들은 상기 프로세서에 의해 실행될 때, 상기 프로세서로 하여금 제1항 내지 제8항중 어느 한 항에 따른 방법의 동작들을 수행하게 하는,컴퓨터 디바이스."}
{"patent_id": "10-2021-7025947", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "컴퓨터 판독 가능 명령들을 저장하는 하나 이상의 비휘발성 저장 매체들로서,상기 컴퓨터 판독 가능 명령들은 하나 이상의 프로세서들에 의해 실행될 때, 상기 하나 이상의 프로세서들로 하여금 제1항 내지 제8항 중 어느 한 항에 따른 방법의 동작들을 수행하게 하는,하나 이상의 비휘발성 저장 매체들."}
{"patent_id": "10-2021-7025947", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "네트워크들의"}
{"patent_id": "10-2021-7025947", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "와 관련된 객체 점프 제어 방법 및 장치, 그리고 컴퓨터 디바이스 및 저장 매체가 제공된 다. 이 방법은: 제1 가상 객체가 가상 장면에서 목적지로 이동하는 프로세스에서, 제1 가상 객체의 현재 포지션 이 점프 조건을 충족할 때, 목적지의 포지션에 따라 제1 가상 객체의 타깃 랜딩 지점을 결정하는 단계; 현재 포 지션 및 타깃 랜딩 지점에 따라, 제1 가상 객체가 현재 포지션에서 타깃 랜딩 지점으로 점프하는 점프 궤적을 결 정하는 단계; 및 점프 궤적에 따라 현재 포지션에서 타깃 랜딩 지점으로 점프하도록 제1 가상 객체를 제어하는 단계를 포함한다. 대 표 도 - 도3"}
{"patent_id": "10-2021-7025947", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 2, "content": "공개특허10-2021-0115004 CPC특허분류 A63F 13/56 (2015.01)명 세 서 청구범위 청구항 1 컴퓨터 디바이스에 의해 수행되는 객체 점프 제어(object jump control) 방법으로서, 가상 장면 내의 제1 가상 객체가 목적지로 이동하는 프로세스에서, 상기 제1 가상 객체의 현재 포지션이 점프 조건을 충족할 때 상기 목적지의 포지션에 따라 상기 제1 가상 객체의 타깃 랜딩 지점(target landing point)을 결정하는 단계; 상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라, 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하는 상 기 제1 가상 객체의 점프 궤적을 결정하는 단계; 및 상기 점프 궤적에 따라 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하도록 상기 제1 가상 객체를 제어 하는 단계를 포함하는, 객체 점프 제어 방법. 청구항 2 제1항에 있어서, 상기 제1 가상 객체의 현재 포지션이 점프 조건을 충족할 때 상기 목적지의 포지션에 따라 상기 제1 가상 객체 의 타깃 랜딩 지점을 결정하는 단계는: 상기 목적지의 보행 구역(walking region)에 기초하여, 상기 현재 포지션이 상기 점프 조건을 충족할 때 상기 보행 구역에 위치된 타깃 랜딩 지점을 결정하는 단계 ― 상기 보행 구역 내의 임의의 포지션과 상기 목적지 사 이에는 보행 경로가 존재함 ―; 상기 현재 포지션이 상기 점프 조건을 충족할 때 상기 가상 장면에서 상기 목적지에 가장 가까운 포지션을 상기 타깃 랜딩 지점으로서 결정하는 단계; 상기 현재 포지션이 상기 점프 조건을 충족할 때 상기 가상 장면에서 상기 목적지의 인접한 포지션을 상기 타깃 랜딩 지점으로서 결정하는 단계; 또는 상기 현재 포지션이 점프 조건을 충족할 때 상기 목적지를 상기 타깃 랜딩 지점으로서 결정하는 단계 중 임의의 단계를 포함하는, 객체 점프 제어 방법. 청구항 3 제2항에 있어서, 상기 목적지의 보행 구역에 기초하여, 상기 보행 구역에 위치된 타깃 랜딩 지점을 결정하는 단계는: 상기 제1 가상 객체의 최대 점프 속도에 따라, 상기 보행 구역에서 상기 최대 점프 속도에 대응하는 타깃 랜딩 지점을 획득하는 단계; 또는 상기 보행 구역에서 선택된 포지션을 획득하고, 상기 선택된 포지션을 상기 타깃 랜딩 지점으로서 결정하는 단 계 중 임의의 단계를 포함하는, 객체 점프 제어 방법. 청구항 4 제1항에 있어서,상기 목적지는 상기 가상 장면 내의 타깃 가상 객체의 현재 포지션 또는 상기 가상 장면 내의 선택된 포지션을 참조하는, 객체 점프 제어 방법. 청구항 5 제1항에 있어서, 상기 점프 조건은: 상기 현재 포지션과 상기 목적지 사이에 어떠한 보행 경로도 존재하지 않는 것, 또는 상기 현재 포지션과 상기 목적지 간의 최단 경로의 방향으로 상기 현재 포지션의 전방에 장애물이 존재하는 것을 포 함하는, 객체 점프 제어 방법. 청구항 6 제1항에 있어서, 상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라, 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하는 상 기 제1 가상 객체의 점프 궤적을 결정하는 단계는: 상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라 상기 현재 포지션에서의 상기 제1 가상 객체의 점프 속도를 결정하는 단계; 및 상기 점프 속도에 따라 상기 현재 포지션으로부터 상기 타깃 랜딩 지점까지의 상기 제1 가상 객체의 점프 궤적 을 결정하는 단계를 포함하는, 객체 점프 제어 방법. 청구항 7 제1항에 있어서, 상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라, 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하는 상 기 제1 가상 객체의 점프 궤적을 결정하는 단계 전에, 상기 방법은: 상기 현재 포지션과 상기 목적지 사이에 점프 장애물이 있을 때 상기 제1 가상 객체를 이동시키고, 상기 이동 이후 상기 제1 가상 객체의 현재 포지션을 획득하는 단계를 더 포함하며, 상기 이동 이후 상기 제1 가상 객체와 상기 타깃 랜딩 지점 간의 거리는 상기 이동 전의 상기 제1 가상 객체와 상기 타깃 랜딩 지점 간의 거리보다 더 먼, 객체 점프 제어 방법. 청구항 8 제1항에 있어서, 상기 점프 궤적에 따라 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하도록 상기 제1 가상 객체를 제어 하는 단계는: 상기 점프 궤적에 따라, 상기 현재 포지션을 떠난 후 그리고 상기 타깃 랜딩 지점에 도달하기 전에 상기 제1 가 상 객체의 복수의 공중 포지션들을 획득하는 단계; 상기 복수의 공중 포지션들에 기초하여 상기 제1 가상 객체의 복수의 중간 이미지들을 획득하는 단계 ― 각각의 중간 이미지는 공중 포지션에 위치된 상기 제1 가상 객체를 디스플레이하는 데 사용됨 ―; 및 상기 복수의 중간 이미지들의 플레이 시퀀스(play sequence)에 기초하여 상기 복수의 중간 이미지들을 플레이하 는 단계를 포함하는, 객체 점프 제어 방법.청구항 9 객체 점프 제어 장치로서, 가상 장면 내의 제1 가상 객체가 목적지로 이동하는 프로세스에서, 상기 제1 가상 객체의 현재 포지션이 점프 조건을 충족할 때 상기 목적지의 포지션에 따라 상기 제1 가상 객체의 타깃 랜딩 지점을 결정하도록 구성된 결 정 모듈; ― 상기 결정 모듈은 상기 현재 포지션 및 상기 타깃 랜딩 지점에 따라, 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하는 상기 제1 가상 객체의 점프 궤적을 결정하도록 추가로 구성됨 ―; 및 상기 점프 궤적에 따라 상기 현재 포지션에서 상기 타깃 랜딩 지점으로 점프하도록 상기 제1 가상 객체를 제어 하도록 구성된 점프 제어 모듈을 포함하는, 객체 점프 제어 장치. 청구항 10 메모리 및 프로세서를 포함하는 컴퓨터 디바이스로서, 상기 메모리는 컴퓨터 판독 가능 명령들을 저장하고, 상기 컴퓨터 판독 가능 명령들은 상기 프로세서에 의해 실행될 때, 상기 프로세서로 하여금 제1항 내지 제8항 중 어느 한 항에 따른 방법의 동작들을 수행하게 하는, 컴퓨터 디바이스. 청구항 11 컴퓨터 판독 가능 명령들을 저장하는 하나 이상의 비휘발성 저장 매체들로서, 상기 컴퓨터 판독 가능 명령들은 하나 이상의 프로세서들에 의해 실행될 때, 상기 하나 이상의 프로세서들로 하 여금 제1항 내지 제8항 중 어느 한 항에 따른 방법의 동작들을 수행하게 하는, 하나 이상의 비휘발성 저장 매체들. 발명의 설명 기 술 분 야 본 출원은 \"OBJECT JUMP CONTROL METHOD AND APPARATUS, COMPUTER DEVICE, AND STORAGE MEDIUM\"이라는 명칭으 로 중국 국가지식산권국에 2019년 5월 23일자 출원된 중국 특허출원 제201910436562.3호에 대한 우선권을 주장 하며, 이 특허출원은 그 전체가 인용에 의해 본 명세서에 포함된다. 본 출원의 실시예들은 네트워크 기술들의 분야에 관한 것으로, 특히 객체 점프 제어(object jump control) 방법 및 장치, 컴퓨터 디바이스 및 저장 매체에 관한 것이다."}
{"patent_id": "10-2021-7025947", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "현재, 많은 게임들에는 가상 사용자 객체들과 싸우는 적대적인(adversarial) 가상 객체들이 제공된다. 예를 들 어, 게임 장면에서, 좀비 형태의 적대적인 가상 객체가 가상 사용자 객체를 공격하기 위해 가상 사용자 객체에 가까이 이동할 수 있다. 적대적인 가상 객체가 이동할 때, 적대적인 가상 객체가 보행 불가능(non-walkable) 구 역으로 이동한다면, 서버는 예를 들어, 보행 불가능 구역의 일 단부로부터 그 구역의 다른 단부로 점프하도록 적대적인 가상 객체를 제어할 수 있다. 관련 기술에서, 객체 점프 제어 프로세스는: 서버가 사용자에 의해 선택된 점프 지점들에 기반하여 각각의 보행 불가능 구역에서 링크 브리지(link bridge)를 수동으로 구성하는 것을 포함할 수 있으며, 여기서 링크 브리지는 사용자에 의해 선택된 2개의 점프 지점들을 포함한다. 서버는 하나의 점프 지점으로부터 다른 점프 지점으로 점 프하도록 적대적인 가상 객체를 제어할 수 있다. 앞서 말한 방법에서는 각각의 보행 불가능 구역에 링크 브리지가 수동으로 구성될 필요가 있다. 그러나 게임 장 면은 일반적으로 많은 보행 불가능 구역들을 포함한다. 따라서 많은 링크 브리지들이 수동으로 구성될 필요가 있고, 서버의 많은 내부 메모리가 점유된다. 그 결과, 노동력 및 내부 메모리와 같은 많은 자원들이 소비되고 비용들이 높아, 자원들의 비교적 낮은 이용으로 이어진다. 본 출원의 실시예들은 객체 점프 제어 방법 및 장치, 컴퓨터 디바이스 및 저장 매체를 제공한다. 일 양상에 따르면, 컴퓨터 디바이스에 의해 수행되는 객체 점프 제어 방법이 제공되며, 이 방법은: 가상 장면 내의 제1 가상 객체가 목적지로 이동하는 프로세스에서, 제1 가상 객체의 현재 포지션이 점프 조건을 충족할 때 목적지의 포지션에 따라 제1 가상 객체의 타깃 랜딩 지점(target landing point)을 결정하는 단계; 현재 포지션 및 타깃 랜딩 지점에 따라, 현재 포지션에서 타깃 랜딩 지점으로 점프하는 제1 가상 객체의 점프 궤적을 결정하는 단계; 및 점프 궤적에 따라 현재 포지션에서 타깃 랜딩 지점으로 점프하도록 제1 가상 객체를 제어하는 단계를 포함한다. 다른 양상에 따르면, 객체 점프 제어 장치가 제공되며, 이 장치는: 가상 장면 내의 제1 가상 객체가 목적지로 이동하는 프로세스에서, 제1 가상 객체의 현재 포지션이 점프 조건을 충족할 때 목적지의 포지션에 따라 제1 가상 객체의 타깃 랜딩 지점을 결정하도록 구성된 결정 모듈; ― 결정 모듈은 현재 포지션 및 타깃 랜딩 지점에 따라, 현재 포지션에서 타깃 랜딩 지점으로 점프하는 제1 가 상 객체의 점프 궤적을 결정하도록 추가로 구성됨 ―; 및 점프 궤적에 따라 현재 포지션에서 타깃 랜딩 지점으로 점프하도록 제1 가상 객체를 제어하도록 구성된 점프 제 어 모듈을 포함한다. 일 실시예에서, 목적지는 가상 장면 내의 타깃 가상 객체의 현재 포지션 또는 가상 장면 내의 선택된 포지션을 참조한다. 일 실시예에서, 점프 조건은: 현재 포지션과 목적지 사이에 어떠한 보행 경로도 존재하지 않는 것, 또는 현재 포지션과 목적지 간의 최단 경로의 방향으로 현재 포지션의 전방에 장애물이 존재하는 것을 포함한다. 일 실시예에서, 결정 모듈은 현재 포지션 및 타깃 랜딩 지점에 따라 현재 포지션에서의 제1 가상 객체의 점프 속도를 결정하고; 그리고 점프 속도에 따라 현재 포지션으로부터 타깃 랜딩 지점까지의 제1 가상 객체의 점프 궤적을 결정하도록 추가로 구성된다. 다른 양상에 따르면, 메모리 및 프로세서를 포함하는 컴퓨터 디바이스가 제공되며, 메모리는 컴퓨터 판독 가능 명령들을 저장하고, 컴퓨터 판독 가능 명령들은 프로세서에 의해 실행될 때, 프로세서로 하여금 앞서 말한 객체 점프 제어 방법의 동작들을 수행하게 한다. 다른 양상에 따르면, 컴퓨터 판독 가능 명령들을 저장하는 하나 이상의 비휘발성 저장 매체들이 제공되며, 컴퓨 터 판독 가능 명령들은 하나 이상의 프로세서들에 의해 실행될 때, 하나 이상의 프로세서들로 하여금 앞서 말한 객체 점프 제어 방법의 동작들을 수행하게 한다. 본 출원의 하나 이상의 실시예들의 세부사항들은 아래 첨부 도면들 및 설명들에서 제공된다. 본 출원의 다른 특 징들, 목적들 및 이점들은 본 명세서, 도면들 및 청구항들로부터 명백해진다."}
{"patent_id": "10-2021-7025947", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "다음은 본 출원의 실시예들에서 첨부 도면들을 참조로 본 출원의 실시예들에서의 기술적 솔루션들을 명확하고 완전하게 설명한다. 명백하게, 설명되는 실시예들은 본 출원의 모든 실시예들이 아닌 일부이다. 창의적인 노력"}
{"patent_id": "10-2021-7025947", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "들 없이 본 출원의 실시예들에 기초하여 당해 기술분야에서 통상의 지식을 가진 자에 의해 획득된 다른 모든 실 시예들이 본 출원의 보호 범위 내에 속할 것이다. 본 출원의 실시예들은 비디오 게임 장면에 관한 것이며, 여기서 비디오 게임 장면은 가상 장면 및 가상 객체를 포함한다. 가상 객체는 가상 장면에서 다양한 액션들, 예를 들어 점프, 걷기 또는 달리기 중 적어도 하나의 액 션을 완료할 수 있는 객체를 의미한다. 가상 객체는 사용자를 표현하기 위한 가상 사용자 객체일 수 있거나; 가 상 객체는 게임에서 미리 구성된 적대적인 가상 객체를 표현하고 가상 사용자 객체와 싸우기 위해 사용될 수 있 다. 예를 들어, 좀비 형태의 적대적인 가상 객체는 가상 사용자 객체를 공격할 수 있다. 가상 객체는 대안으로, 가상 장면에서 가상 사용자 객체와 연관 관계를 갖는 사용자 연관 가상 객체, 예를 들어 가상 장면에서 가상 사 용자 객체에 의해 소유된 소품(prop) 또는 가상 반려동물 또는 가상 사용자 객체가 타는 차량을 표현하기 위해 사용될 수 있다. 가상 객체는 임의의 형태, 예를 들어 사람, 동물 또는 임의의 가상화된 형상, 이를테면 좀비 형태의 적대적인 가상 객체일 수 있다. 일 실시예에서, 적대적인 가상 객체는 가상 사용자 객체의 방향을 향해 이동할 수 있고, 적대적인 가상 객체는 가상 사용자 객체에 가깝게 이동하고, 가상 사용자 객체를 공격한다. 사용자는 또한, 적대적인 가상 객체의 공 격을 피하기 위해 이동하도록 가상 사용자 객체를 제어할 수 있거나, 사용자는 적대적인 가상 객체와 싸우도록 가상 사용자 객체를 제어할 수 있는데, 예를 들어 가상 소품을 사용함으로써 적대적인 가상 객체와 싸우도록 가 상 사용자 객체를 제어할 수 있다. 적대적인 가상 객체가 가상 사용자 객체로 이동하는 프로세스에서, 적대적인 가상 객체는 또한 점프 액션을 수행하여 가상 사용자 객체의 방향을 향해 점프할 수 있다. 예를 들어, 도 1에 도시된 바와 같이, 가상 사용자 객체가 집의 지붕 위에 위치되고 적대적인 가상 객체가 지면 상에 위치된다면, 적대적인 가상 객체가 지붕으로 점프할 수 있다. 도 2에 도시된 바와 같이, 도 2는 도 1의 실제 장면 인터페이 스의 개략도이고, 도 1에 대응하는 가상 장면은 도 2로부터 보다 명확하게 알려질 수 있다. 다른 실시예에서, 사용자는 또한 가상 장면에서 목적지를 사전에 선택할 수 있고, 가상 사용자 객체는 목적지의 방향을 향해 이동할 수 있다. 이동 프로세스에서, 가상 사용자 객체는 또한 점프 액션을 수행할 수 있다. 예를 들어, 가상 사용자 객체가 최단 경로를 따라 달리는 프로세스에서 강과 같은 장애물을 만난다면, 가상 사용자 객체는 또한 강의 다른 측으로 점프할 수 있다. 다른 실시예에서, 사용자 연관 가상 객체는 또한 실시간으로 가상 사용자 객체와 함께 이동할 수 있고, 실시간 후속 이동 프로세스에서, 사용자 연관 가상 객체는 또한 점프 액션을 수행할 수 있다. 예를 들어, 가상 사용자 객체가 가상 계단들 상에서 신속하게 전진할 때, 가상 사용자 객체가 현재 위치된 계단으로 가상 사용자 객체의 가상 반려견이 또한 점프할 수 있다. 가상 장면은 실세계의 시뮬레이션된 장면일 수 있거나, 반-시뮬레이션된(semi-simulated) 반-허구의(semi- fictional) 장면일 수 있거나, 완전히 허구의 장면일 수 있다. 예를 들어, 가상 장면은 하늘, 육지 및 바다 중 적어도 하나를 포함할 수 있고, 육지는 적어도 하나의 환경 엘리먼트, 이를테면 사막 또는 도시를 포함할 수 있 다. 가상 객체는 가상 장면에서 이동할 수 있다. 일례로 슈팅(shooting) 게임을 사용함으로써, 가상 객체는 가상 장면의 하늘에서 자유 낙하하거나, 활공하거나, 낙하산을 열어 떨어지는 등, 또는 지상에서 달리거나, 점프 하거나, 기거나, 몸을 구부리는 등, 또는 바다에서 수영하거나, 부유하거나, 잠수하는 등을 한다. 확실히, 가상 객체는 대안으로 차량을 운전하여 가상 장면에서 이동할 수 있다. 본 명세서에, 앞서 말한 장면은 단지 설명을 위한 일례로서 사용될 뿐이며, 이는 본 출원의 실시예들에서 구체적으로 제한되지 않는다. 본 출원의 실시예들에서, 컴퓨터 디바이스는 게임 애플리케이션의 게임 구성 파일을 사전에 획득할 수 있고, 게 임 구성 파일은 비디오 게임의 애플리케이션 프로그램, 페이지 디스플레이 데이터, 가상 장면 데이터 등을 포함 할 수 있으므로, 컴퓨터 디바이스가 비디오 게임을 시작하면서 게임 구성 파일을 호출하여 비디오 게임의 페이 지를 렌더링(render)하고 디스플레이할 수 있다. 게임 구성 파일은 가상 객체의 액션 로직을 더 포함할 수 있고, 컴퓨터 디바이스는 액션 로직에 기반하여 가상 객체의 점프 액션을 제어할 수 있다. 컴퓨터 디바이스는 단말일 수 있고, 단말은 가상 객체의 액션 로직에 기반하여 점프하도록 가상 객체를 제어하고, 점프 프로세스에 기반하여 점프 프로세스에 대응하는 게임 데이터를 결정하고, 게임 데이터를 실시간으로 렌더링 및 디스플레이 한다. 게임 데이터는 가상 장면 데이터, 가상 장면 내 가상 객체의 액션 데이터 등을 포함할 수 있다. 컴퓨터 디바이스는 대안으로 서버일 수 있다. 서버는 게임 애플리케이션의 백엔드(backend) 서버일 수 있고, 서버가 가 상 객체의 액션 로직, 예를 들어 랜딩 지점, 점프 속도, 또는 점프 동안의 점프 궤적 중 적어도 하나에 기반하 여, 가상 객체의 점프 정보를 실시간으로 단말에 전송할 수 있어, 단말이 점프 정보에 기초하여 점프 프로세스 에 대응하는 게임 데이터를 결정하고 게임 데이터를 렌더링 및 디스플레이한다. 단말은 애플리케이션 프로그램이 설치되는 임의의 단말일 수 있다. 이는 본 출원의 실시예들에서 구체적으로 제 한되지 않는다. 예를 들어, 단말은 임의의 디바이스, 이를테면 비디오 게임이 설치되는 휴대 전화 단말, 휴대용 안드로이드 디바이스(PAD: portable Android device) 단말 또는 컴퓨터 단말일 수 있다. 도 3은 본 출원의 실시예에 따른 동작 제어 방법의 흐름도이다. 본 개시내용의 이러한 실시예를 실행하는 엔티 티는 컴퓨터 디바이스이다. 도 3을 참조하면, 이 방법은 다음을 포함한다: 301. 컴퓨터 디바이스가 제1 가상 객체의 목적지를 획득하고, 목적지를 향해 이동하도록 제1 가상 객체를 제어 한다. 본 출원의 실시예들에서, 제1 가상 객체는 가상 사용자 객체, 가상 사용자 객체와 싸우는 적대적인 가상 객체, 가상 사용자 객체의 사용자 연관 가상 객체, 적대적인 가상 객체의 부수적인 가상 객체 등일 수 있다. 목적지는 가상 장면 내의 타깃 가상 객체의 현재 포지션 또는 가상 장면 내의 선택된 포지션을 참조한다. 타깃 가상 객체 는 또한 가상 사용자 객체, 가상 사용자 객체와 싸우는 적대적인 가상 객체, 가상 사용자 객체의 사용자 연관 가상 객체, 적대적인 가상 객체의 부수적인 가상 객체 등 중 임의의 객체일 수 있다. 일부 구현 장면들에서, 제1 가상 객체는 타깃 가상 객체와 함께 이동할 수 있다. 일 실시예에서, 적대적인 가상 객체가 가상 사용자 객체를 추적하고 공격하는데, 예를 들어 좀비 가상 객체가 타깃 장면 범위 내에서 가상 사 용자 객체를 추적하고 공격한다. 다른 예에서, 사용자 연관 가상 객체는 가상 사용자 객체와 함께 실시간으로 이동하는데, 예를 들어 가상 반려동물이 가상 사용자 객체와 함께 실시간으로 이동한다. 다른 예에서, 적대적인 가상 객체의 부수적인 가상 객체는 적대적인 가상 객체와 함께 실시간으로 이동하는데, 예를 들어 작은 좀비 가 상 객체가 큰 좀비 가상 객체와 함께 실시간으로 이동하거나, 가상 병사가 가상 캡틴과 함께 이동한다. 다른 예 에서는, 제1 가상 객체의 작업 협력 객체가 또한 실시간으로 제1 가상 객체를 따를 수 있다. 앞서 말한 예들은 설명을 위해 본 출원의 실시예들에서 제공되며, 타깃 가상 객체 및 제1 가상 객체의 특정 표현 형태들은 본 출 원의 실시예들에서 구체적으로 제한되지 않는다. 일 실시예에서, 타깃 가상 객체는 제1 가상 객체의 타깃 장면 범위 내의 제2 가상 객체, 제1 가상 객체와 적대 적인 연관 관계를 갖는 제3 가상 객체, 또는 제1 가상 객체의 작업 협력 객체를 포함할 수 있지만, 이에 제한되 는 것은 아니다. 이 단계에서, 컴퓨터 디바이스는 다음의 4개의 방법들 중 임의의 방법에 기반하여 제1 가상 객 체의 목적지를 결정할 수 있다. 제1 방법: 제2 가상 객체가 제1 가상 객체에 대응하는 타깃 장면 범위에 포함될 때, 컴퓨터 디바이스는 제2 가 상 객체를 타깃 가상 객체로서 결정하고, 타깃 가상 객체의 현재 포지션을 획득하고, 타깃 가상 객체의 현재 포 지션을 목적지로서 결정한다. 일 실시예에서, 타깃 가상 객체는 가상 사용자 객체일 수 있고, 제1 가상 객체는 가상 사용자 객체의 적대적인 가상 객체일 수 있다. 컴퓨터 디바이스는 특정 장면 범위 내에 하나 이상의 적대적인 가상 객체들을 구성할 수 있으며, 각각의 적대적인 가상 객체는 하나의 타깃 장면 범위에 대응하고, 컴퓨터 디바이스가 적대적인 가상 객체에 대응하는 타깃 장면 범위에 가상 사용자 객체가 포함됨을 검출하면, 컴퓨터 디바이스는 가상 사용자 객체 의 현재 포지션을 목적지로서 사용하며, 가상 사용자 객체를 추적하고 공격하도록 적대적인 가상 객체를 제어한 다. 다른 예에서, 타깃 가상 객체 및 제1 가상 객체는 가상 사용자 객체들일 수 있다. 예를 들어, 타깃 가상 객체 및 제1 가상 객체는 동일한 팀에 있을 수 있으며; 제1 가상 객체의 자동 추적 모드가 인에이블 상태에 있고 제1 가상 객체의 타깃 장면 범위가 동일한 팀에 있는 팀 동료 가상 객체를 포함할 때, 컴퓨터 디바이스는 팀 동료 가상 객체의 현재 포지션을 목적지로서 사용하고, 팀 동료 가상 객체와 함께 실시간으로 이동하도록 제1 가상 객체를 제어한다. 제2 방법: 컴퓨터 디바이스는 제1 가상 객체와 적대적인 연관 관계를 갖는 제3 가상 객체를 타깃 가상 객체로서 결정하고, 타깃 가상 객체의 현재 포지션을 획득하며, 타깃 가상 객체의 현재 포지션을 목적지로서 결정한다. 일 실시예에서, 타깃 가상 객체는 가상 사용자 객체일 수 있고, 제1 가상 객체는 가상 사용자 객체의 적대적인 가상 객체일 수 있다. 컴퓨터 디바이스는 제1 가상 객체와 제3 가상 객체 간의 적대적인 연관 관계를 저장할 수 있다. 예를 들어, 적대적인 가상 객체 A가 실시간으로 가상 사용자 객체 B를 추적하고 공격한다면, 적대적인 가 상 객체 A의 목적지는 가상 사용자 객체 B의 현재 포지션이다. 제3 방법: 컴퓨터 디바이스는 제1 가상 객체의 작업 협력 객체를 타깃 가상 객체로서 결정하고, 타깃 가상 객체 의 현재 포지션을 획득하며, 타깃 가상 객체의 현재 포지션을 목적지로서 결정한다. 일 실시예에서, 제1 가상 객체는 가상 사용자 객체 또는 적대적인 가상 객체일 수 있으며, 제1 가상 객체의 작 업 협력 객체는 가상 의존 관계를 갖는 가상 객체 또는 제1 가상 객체와 동일한 팀에 있는 팀 동료 가상 객체, 예를 들어 가상 반려동물, 가상 캡틴의 가상 병사 객체, 또는 작은 좀비 가상 객체일 수 있다. 예를 들어, 가상 사용자 객체의 가상 반려동물은 가상 사용자 객체와 함께 실시간으로 이동할 수 있다. 제4 방법: 컴퓨터 디바이스는 가상 장면 내의 선택된 포지션을 획득하고, 타깃 가상 객체의 현재 포지션을 목적 지로서 결정한다. 일 실시예에서, 목적지는 사전에 선택된 장면 포지션일 수 있다. 예를 들어, 산 정상 또는 무기고(armory)의 문 앞과 같은 목적지가 사전에 선택되고, 복수의 가상 객체들이 목적지를 신속하게 점령한다. 컴퓨터 디바이스는 타깃 가상 객체의 현재 포지션을 목적지로서 사용할 수 있거나, 사용자에 의해 선택된 포지 션을 목적지로서 사용할 수 있고, 제1 가상 객체를 이동하도록 제어할 수 있으며, 여기서 타깃 가상 객체는 제1 가상 객체와 적대 관계 또는 작업 협력 관계를 가짐으로써, 객체 점프 제어 방법의 적용 가능성을 강화할 수 있 다. 302. 가상 장면 내의 제1 가상 객체가 목적지로 이동하는 프로세스에서, 컴퓨터 디바이스는 제1 가상 객체의 현 재 포지션에 따라 제1 가상 객체의 현재 포지션이 점프 조건을 충족하는지 여부를 검출한다. 본 출원의 실시예들에서, 컴퓨터 디바이스는 제1 가상 객체의 현재 포지션을 획득하고, 제1 가상 객체의 현재 포지션 및 목적지에 따라 현재 포지션이 점프 조건을 충족하는지 여부를 검출할 수 있다. 일 실시예에서, 점프 조건은: 현재 포지션과 목적지 사이에 어떠한 보행 경로도 존재하지 않는 것일 수 있다. 보행 경로는 보행 이동을 위한 경로를 의미한다. 이 단계에서, 컴퓨터 디바이스는 현재 포지션에 따라 현재 포 지션과 목적지 사이에 보행 경로가 존재하는지 여부를 검출할 수 있고, 현재 포지션과 목적지 사이에 어떠한 보 행 경로도 존재하지 않을 때, 컴퓨터 디바이스는 제1 가상 객체의 현재 포지션이 점프 조건을 충족한다고 결정 한다. 일 실시예에서, 컴퓨터 디바이스는 내비게이션 메시(navigation mesh)를 사용하여 가상 장면 내의 장면 객체들 및 가상 객체들의 포지션들, 이를테면 집들, 강들, 컨테이너들 또는 차량들의 포지션들을 표현할 수 있 다. 내비게이션 메시는 복수의 다각형 셀들을 포함하고, 각각의 다각형 셀은 가상 장면에서 포지션 노드를 표현 하는 데 사용되며, 컴퓨터 디바이스는 내비게이션 메시에 기반하여 현재 포지션과 목적지 사이의 보행 경로를 추가로 결정할 수 있다. 이 단계에서, 컴퓨터 디바이스는, 현재 포지션이 위치되는 포지션 노드에 따라 타깃 경 로 찾기(pathfinding) 알고리즘을 사용함으로써, 현재 포지션이 위치되는 포지션 노드로부터 목적지가 위치되는 포지션 노드까지의 보행 경로를 찾고, 현재 포지션이 위치되는 포지션 노드로부터 목적지가 위치되는 포지션 노 드까지의 어떠한 보행 경로도 발견되지 않는다면, 현재 포지션이 점프 조건을 충족한다고 결정할 수 있고; 그렇 지 않으면, 컴퓨터 디바이스는 현재 포지션이 점프 조건을 충족하지 않는다고 결정한다. 일 실시예에서, 타깃 경로 찾기 알고리즘은 요구되는 대로 설정될 수 있으며, 이는 본 출원의 실시예들에서 제 한되지 않는다. 예를 들어, 타깃 경로 찾기 알고리즘은 A*(A-스타(A-Star), 휴리스틱 탐색) 알고리즘일 수 있다. 내비게이션 메시는 Nav Mesh일 수 있다. 복수의 인접한 다각형들이 각각의 다각형 셀을 둘러싸고, 인접한 다각형 셀들이 통신하게 된다. 가상 객체가 다각형 셀로부터 인접한 다각형 셀로 걸어갈 수 있다. 인접한 다각 형 셀은, 다각형 셀 근처에 있고 다각형 셀과 공통 측면을 갖는 다각형 셀을 의미한다. 보행 경로 찾기 프로세 스는: 컴퓨터 디바이스가 현재 포지션이 위치되는 다각형 셀을 시작점으로서 사용하고, 목적지가 위치되는 다각 형 셀을 종료점으로서 사용하는 것; 컴퓨터 디바이스가 A* 알고리즘을 사용하여 경로를 찾음으로써 시작점으로 부터 종료점까지의 복수의 중간 노드들을 발견하고, 경로가 발견되지 않으면, 이는 두 지점들이 서로 도달할 수 없음을 표시하는 것을 포함할 수 있다. 컴퓨터 디바이스가 경로 찾기 동안 중간 노드를 발견하면, 컴퓨터 디바이스는 종료점에 도달할 때까지 현재 중 간 노드 및 종료점에 기초하여 계속 다음 중간 노드를 발견할 수 있다. 컴퓨터 디바이스는 발견되는 복수의 중 간 노드들을 저장할 필요가 없으며, 단지 현재 포지션과 목적지 사이에 보행 경로가 존재하는지 여부만을 결정 할 필요가 있다. 특정 보행 경로에 포함된 중간 노드들을 획득하는 것은 불필요하다. 따라서 저장 시간이 절약 되고, 경로 찾기 결과가 신속하게 결정될 수 있으며, 이로써 프로세싱 효율을 개선할 수 있다. 일 실시예에서, 점프 조건은 대안으로: 현재 포지션과 목적지 간의 최단 경로의 방향으로 현재 포지션의 전방에 장애물이 존재하는 것일 수 있다. 이 단계에서, 컴퓨터 디바이스는 현재 포지션과 목적지 간의 최단 경로를 결 정할 수 있고, 최단 경로는 현재 포지션으로부터 목적지까지의 직선 방향일 수 있다. 제1 가상 객체가 목적지를 향해 이동하는 프로세스에서, 컴퓨터 디바이스는 최단 경로를 따라 이동하도록 제1 가상 객체를 제어할 수 있다. 컴퓨터 디바이스는 최단 경로의 방향으로 현재 포지션 전방의 제1 타깃 범위 내에 장애물이 있는지 여부 를 검출할 수 있다. 현재 포지션 전방의 제1 타깃 범위 내에 장애물이 있을 때, 컴퓨터 디바이스는 현재 포지션 이 점프 조건을 충족한다고 결정한다(이 단계에서 타깃 범위는 제1 타깃 범위로 지칭되며, 이는 단계에서 의 제2 타깃 범위와 구별됨). 제1 타깃 범위는 요구되는 대로 설정될 수 있는데, 예를 들어 제1 타깃 범위는 제 1 가상 객체의 전방 1미터 또는 2미터 내의 범위를 의미한다. 장애물은 제1 가상 객체가 걷는 것을 차단하는 물 리적 객체, 예를 들어 강, 돌 또는 난간 중 적어도 하나를 의미한다. 본 출원의 실시예들에서, 컴퓨터 디바이스는 단계의 프로세스를 주기적으로 수행할 수 있고, 현재 포지션 이 점프 조건을 충족할 때, 후속 단계들(303 내지 306)의 프로세스, 즉 객체 점프 프로세스를 수행할 수 있다. 일 실시예에서, 제1 가상 객체는 게임에서 미리 구성되는 인공 지능(AI: artificial intelligence) 객체일 수 있다. AI 객체는 가상 사용자 객체와 싸우는 데 사용될 수 있다. 예를 들어, AI 객체는 좀비 형태의 적대적인 가상 객체이다. AI 객체는 미리 구성된 액션 트리에 기반하여 점프 프로세스를 수행할 수 있으며, 여기서 액션 트리는 AI 객체의 액션 노드들에 의해 형성되고 AI 객체의 액션 로직을 지시하는 데 사용되는 트리 구조를 의미 하고, 액션 노드의 실행은 부모 노드에 의해 영향을 받고 제어된다. 이 단계는 대안으로: 제1 가상 객체가 AI 객체일 때, 컴퓨터 디바이스는 제1 가상 객체의 액션 트리에 제1 노드를 추가할 수 있는 것일 수 있으며, 여기 서 제1 노드는 타깃 사이클에 따라 단계의 검출 프로세스를 수행함으로써 현재 포지션의 검출 상태를 주기 적으로 업데이트하도록 명령하는 데 사용된다. 컴퓨터 디바이스는 액션 트리에 제2 노드를 더 추가할 수 있으며, 여기서 제2 노드는 현재 포지션이 점프 조건을 충족할 때 단계의 프로세스를 수행하도록 명령하는 데 사용된다. 도 4에 도시된 바와 같이, AI 객체의 현재 포지션이 점프 조건을 충족할 때, 예를 들어 AI 객체가 가상 사용자 객체로 걸어갈 수 없을 때, 후속 단계들(303 내지 306)의 점프 프로세스가 수행되고; AI 객체의 현 재 포지션이 점프 조건을 충족하지 않을 때, AI 객체의 정상 경로 찾기 및 공격 로직이 수행되는데, 즉 AI 객체 는 가상 사용자 객체로 걸어가고 가상 사용자 객체를 공격하도록 제어된다. 일 실시예에서, 제1 노드는 서비스 노드일 수 있고, 제2 노드는 작업 노드, 예를 들어 데코레이터(decorator) 노드일 수 있다. 도 5에 도시된 바와 같이, 서비스 노드를 일례로 사용함으로써 설명이 이루어진다. 서비스 노 드는 현재 포지션이 점프 조건을 충족하는지 여부, 예를 들어 AI 객체가 가상 사용자 객체로 걸어갈 수 있는지 여부를 결정하기 위해 단계의 프로세스를 초당 1회 수행하도록 설정될 수 있다. AI 객체가 가상 사용자 객 체로 걸어갈 수 없을 때, 컴퓨터 디바이스는 AI 객체의 상태를 도달 범위 외 상태(out-of-reach state)로 설정 하고; 그렇지 않으면, 컴퓨터 디바이스는 상태를 도달 범위 내 상태(within-reach state)로 설정한다. AI 객체 의 상태가 도달 범위 외 상태인 것으로 검출되면, 후속 단계들(302 내지 305)의 점프 프로세스가 수행된다. 303. 제1 가상 객체의 현재 포지션이 점프 조건을 충족할 때, 컴퓨터 디바이스가 목적지의 포지션에 따라 제1 가상 객체의 타깃 랜딩 지점을 결정한다. 타깃 랜딩 지점은 점프 액션을 수행한 후 제1 가상 객체가 도달하는 포지션을 의미한다. 본 출원의 실시예들에 서, 컴퓨터 디바이스는 목적지의 보행 구역(walking region) 내의 하나의 지점을 타깃 랜딩 지점으로서 선택할 수 있다. 컴퓨터 디바이스는 대안으로, 목적지에 비교적 가까운 포인트를 타깃 랜딩 지점으로서 선택할 수 있거 나, 컴퓨터 디바이스는 목적지를 타깃 랜딩 지점으로서 직접 사용할 수 있다. 대응하여, 이 단계는 다음의 4개 의 구현들 중 임의의 구현을 포함할 수 있다. 제1 구현: 현재 포지션이 점프 조건을 충족할 때, 컴퓨터 디바이스는 목적지의 보행 구역에 기반하여 보행 구역 내의 타깃 랜딩 지점을 결정한다. 보행 구역 내의 임의의 포지션과 목적지 사이에 보행 경로가 존재하는데, 즉 보행 구역 내의 임의의 포지션 상 의 제1 가상 객체가 목적지까지 걸어갈 수 있다. 이 단계에서, 목적지는 가상 장면 내의 타깃 가상 객체의 현재 포지션일 수 있다. 본 출원의 실시예들에서, 가상 장면은 복수의 보행 구역들을 포함하고, 컴퓨터 디바이스는 목적지의 포지션에 따라 목적지를 포함하는 보행 구역을 목적지의 보행 구역으로서 결정할 수 있다. 일 실시예에서, 컴퓨터 디바이 스는 대안으로, 목적지가 위치되는 보행 구역 내의 비교적 작은 구역을 목적지의 보행 구역으로서 선택할 수 있 다. 프로세스는: 컴퓨터 디바이스가 목적지의 포지션에 따라 목적지를 포함하는 타깃 범위 내의 보행 구역을 목 적지의 보행 구역으로서 결정하는 것을 포함할 수 있다. 예를 들어, 컴퓨터 디바이스는 목적지까지의 거리가 제 1 타깃 거리를 초과하지 않는 보행 구역을 획득하기 위한 중심점으로서 목적지를 사용할 수 있다. 컴퓨터 디바이스는 목적지의 포지션에 따라 목적지가 위치되는 보행 구역을 획득하고, 컴퓨터 디바이스는 원형 구역을 계속해서 획득할 수 있으며, 이는 목적지를 중심점으로서 그리고 제1 타깃 거리를 목적지의 보행 구역인 반경으로서 사용한다. 예를 들어, 5미터의 반경을 갖는 원형 보행 구역이 획득된다. 일 실시예에서, 컴퓨터 디바이스는 제1 가상 객체의 점프 속도, 즉 다음의 단계 a의 프로세스에 기초하여 타깃 랜딩 지점을 선택할 수 있다. 다른 실시예에서, 컴퓨터 디바이스는 대안으로, 사용자 선택, 즉 다음의 단계 b의 프로세스에 기초하여 타깃 랜딩 지점을 선택할 수 있다. 단계 a. 컴퓨터 디바이스는 제1 가상 객체의 최대 점프 속도에 따라, 보행 구역에서 최대 점프 속도에 대응하는 타깃 랜딩 지점을 획득한다. 본 출원의 실시예들에서, 제1 가상 객체의 점프 속도 범위는 제한되며, 컴퓨터 디바이스는 제1 가상 객체의 최 대 점프 속도에 따라 제1 가상 객체가 가장 멀리 점프하게 하는 지점을 타깃 랜딩 지점으로서 획득할 수 있다. 일 실시예에서, 컴퓨터 디바이스는 제1 가상 객체의 최대 점프 속도를 획득하고, 최대 점프 속도에 따라 제1 가 상 객체의 최대 점프 거리를 결정할 수 있다. 컴퓨터 디바이스는 최대 점프 거리 및 현재 포지션에 따라 보행 구역에서의 최대 점프 거리에 대응하는 타깃 랜딩 지점을 획득한다. 일 실시예에서, 제1 가상 객체의 목적지 및 현재 포지션이 동일한 수평면에 위치될 때, 컴퓨터 디바이스는 제1 가상 객체의 최대 점프 속도에 따라 수평면에서 제1 가상 객체의 가장 먼 점프 거리를 결정할 수 있다. 컴퓨터 디바이스는 가장 먼 점프 거리에 따라 제1 가상 객체의 보행 구역에서 가장 먼 점프 거리에 대응하는 타깃 랜딩 지점을 결정한다. 일 실시예에서, 제1 가상 객체의 목적지 및 현재 포지션이 상이한 레벨들에 위치될 때, 컴퓨터 디바이스는 제1 가상 객체의 최대 점프 속도에 따라 각각 수평면 및 수직면에서 제1 가상 객체의 가장 먼 점프 거리들을 결정할 수 있다. 컴퓨터 디바이스는 수평면 및 수직면에서 제1 가상 객체의 가장 먼 점프 거리들에 따라 제1 가상 객체 의 보행 구역에서 가장 먼 점프 거리에 대응하는 타깃 랜딩 지점을 결정한다. 단계 b. 컴퓨터 디바이스는 보행 구역에서 선택된 포지션을 획득하고, 선택된 포지션을 타깃 랜딩 지점으로서 결정한다. 이 단계에서, 제1 가상 객체는 가상 사용자 객체일 수 있고, 목적지는 타깃 가상 객체의 현재 포지션 또는 가상 장면에서의 선택된 포지션일 수 있다. 컴퓨터 디바이스가 단말일 때, 컴퓨터 디바이스는 애플리케이션 인터페이스에 목적지의 보행 구역을 디스플레이 할 수 있고, 사용자는 보행 구역에서 제1 가상 객체의 타깃 랜딩 지점을 선택할 수 있다. 컴퓨터 디바이스는 사 용자에 의해 선택된 타깃 랜딩 지점을 획득한다. 일 실시예에서, 컴퓨터 디바이스는 사용자에 의해 선택된 타깃 랜딩 지점을 획득한 후에, 사용자에 의해 선택된 타깃 랜딩 지점을 서버에 추가로 전송할 수 있다. 컴퓨터 디바이스가 서버일 때, 사용자가 위치되는 단말은 목적지의 보행 구역을 디스플레이할 수 있고, 단말은 사용자에 의해 선택된 타깃 랜딩 지점을 컴퓨터 디바이스에 전송한다. 제1 가상 객체의 점프 속도는 제한된다. 따라서 제1 가상 객체의 점프 거리가 제한된다. 컴퓨터 디바이스는, 제 1 가상 객체가 1회 점프를 통해 가능한 한 멀리 점프할 수 있도록, 보행 구역에서 제1 가상 객체의 최대 점프 속도에 따라 타깃 랜딩 지점으로서 최대 점프 속도의 도달 범위 내의 지점을 선택할 수 있으며, 이로써 비교적 짧은 점프 거리로 인해 가상 객체가 달리는 것을 방지한다. 제1 가상 객체가 가상 사용자 객체라면, 가상 사용 자 객체는 너무 많은 히트(hit) 지점들을 잃는 것이 또한 방지될 수 있으며, 이로써 게임에서 제1 가상 객체의 가상화 능력을 최대화할 수 있다. 추가로, 컴퓨터 디바이스는 사용자가 사용자에 의해 선택된 지점을 타깃 랜딩 지점으로서 사용하기 위한 선택 엔트리를 추가로 제공할 수 있으며, 이로써 사용자 요건들을 더 잘 충족하고 사 용자 경험을 개선할 수 있다. 제2 방법: 현재 포지션이 점프 조건을 충족할 때, 컴퓨터 디바이스는 가상 장면에서 목적지에 가장 가까운 포지 션을 타깃 랜딩 지점으로서 결정한다. 이 단계에서, 목적지는 가상 장면 내의 타깃 가상 객체의 현재 포지션일 수 있다. 컴퓨터 디바이스는 목적지의 포지션에 따라 목적지를 중심으로서 사용함으로써 목적지의 복수의 인접한 포지션들을 획득할 수 있다. 컴퓨터 디바이스는 각각의 인접한 포지션과 목적지 간의 거리를 획득하고, 복수의 거리들에 따라, 복수의 인접한 포지 션들로부터 목적지에 가장 가까운 포지션을 타깃 랜딩 지점으로서 선택한다. 일 실시예에서, 컴퓨터 디바이스가 내비게이션 메시를 사용하여 가상 장면에서 객체들의 포지션들을 표현한다면, 컴퓨터 디바이스는 목적지가 위치되는 다각형 셀에 따라, 목적지가 위치되는 다각형 셀의 복수의 인접한 다각형 셀들을 획득할 수 있고, 목적지가 위치되는 다각형 셀과 각각의 인접한 다각형 셀 간의 거리를 순차적으로 계산하여, 목적지가 위치되는 다각형 셀에 가장 가까운 인접한 다각형 셀을 결정할 수 있으며, 인접 한 다각형 셀에 대응하는 포지션 노드를 타깃 랜딩 지점으로서 사용할 수 있다. 제3 방법: 현재 포지션이 점프 조건을 충족할 때, 컴퓨터 디바이스는 가상 장면에서 목적지의 인접 포지션을 타 깃 랜딩 지점으로서 결정한다. 이 단계에서, 목적지는 가상 장면 내의 타깃 가상 객체의 현재 포지션일 수 있다. 일 실시예에서, 컴퓨터 디바 이스가 내비게이션 메시를 사용하여 가상 장면에서 객체들의 포지션들을 표현한다면, 컴퓨터 디바이스는 목적지 가 위치되는 다각형 셀에 따라, 목적지가 위치되는 다각형 셀의 임의의 인접한 다각형 셀을 획득할 수 있으며, 인접한 다각형 셀에 대응하는 포지션 노드를 타깃 랜딩 지점으로서 사용할 수 있다. 제4 방법: 현재 포지션이 점프 조건을 충족할 때, 컴퓨터 디바이스는 목적지를 타깃 랜딩 지점으로서 결정한다. 이 단계에서, 목적지는 가상 장면 내의 선택된 포지션일 수 있다. 컴퓨터 디바이스는 추가로, 내비게이션 메시 에서 목적지가 위치되는 다각형 셀을 획득하고, 목적지가 위치되는 다각형 셀에 대응하는 포지션 노드를 제1 가 상 객체의 타깃 랜딩 지점으로서 사용할 수 있다. 제1 가상 객체는 목적지로 직접 점프할 수 있다. 목적지가 타깃 가상 객체의 현재 포지션일 때, 컴퓨터 디바이스는 앞서 말한 제1 방법 내지 제3 방법에 기초하 여, 보행 구역에서 목적지의 포지션, 인접 포지션 또는 가장 가까운 포지션에 기초하여 타깃 랜딩 지점을 결정 할 수 있으며, 이로써 제1 가상 객체 및 타깃 가상 객체가 서로 충돌하는 것을 방지할 수 있다. 목적지가 사전 에 선택되는 포지션인 경우, 컴퓨터 디바이스는 앞서 말한 제4 방법에 따라 목적지를 타깃 랜딩 지점으로서 직 접 사용함으로써, 계산 시간을 절약하고 객체 점프 제어 방법의 적용 가능성을 향상시킬 수 있다. 304. 컴퓨터 디바이스가 현재 포지션과 목적지 사이에 점프 장애물이 있는지 여부를 검출하고, 현재 포지션과 목적지 사이에 점프 장애물이 있을 때 제1 가상 객체를 이동시키고, 이동 후에 제1 가상 객체의 현재 포지션을 획득한다. 점프 장애물은 점프 후 그리고 타깃 랜딩 지점에 도달하기 전에 공중에서 제1 가상 객체가 만나는 객체를 의미 한다. 현재 포지션과 목적지 사이에 점프 장애물이 없는 경우, 컴퓨터 디바이스는 단계를 직접 수행한다. 이 단계에서, 컴퓨터 디바이스는 현재 포지션과 목적지 간의 거리에 기초하여 현재 포지션의 제2 타깃 범위 내 에 점프 장애물이 있는지 여부를 검출할 수 있다. 제2 타깃 범위 내에 점프 장애물이 있을 때, 컴퓨터 디바이스 는 점프 장애물로부터 멀어지는 방향으로 타깃 이동 거리만큼 이동하도록 제1 가상 객체를 제어하는데, 즉 타깃 이동 거리만큼 후퇴하도록 제1 가상 객체를 제어한다. 컴퓨터 디바이스는 이동 후에 현재 포지션을 획득한다. 일 실시예에서, 컴퓨터 디바이스는 제2 타깃 범위 내에서 점프 장애물의 높이를 추가로 검출할 수 있으며, 점프 장애물의 높이가 타깃 높이를 초과할 때 점프 장애물로부터 멀어지는 방향으로 타깃 이동 거리만큼 이동하도록제1 가상 객체를 제어할 수 있다. 제2 타깃 범위는 현재 포지션까지의 거리가 목적지를 향한 방향으로 제2 타깃 거리를 초과하지 않는 범위일 수 있다. 제2 타깃 거리, 타깃 높이 및 타깃 이동 거리는 요건들에 기반하여 설정 될 수 있는데, 이는 본 출원의 실시예들에서 구체적으로 제한되지 않는다. 예를 들어, 제2 타깃 거리는 2미터 또는 3미터일 수 있다. 타깃 높이는 10미터 또는 8미터일 수 있다. 타깃 이동 거리는 3미터 또는 1미터일 수 있 다. 일 실시예에서, 컴퓨터 디바이스는 점프 장애물의 복수의 높이들과 복수의 이동 거리들 간의 대응을 저장할 수 있다. 컴퓨터 디바이스는 제2 타깃 범위 내의 점프 장애물의 높이를 획득하고, 복수의 높이들과 이동 거리들 간의 대응에 따라 점프 장애물의 높이에 대응하는 타깃 이동을 획득하고, 점프 장애물로부터 멀어지는 방향으로 타깃 이동 거리만큼 이동하도록 제1 가상 객체를 제어한다. 예를 들어, 점프 장애물의 높이가 10미터일 때, 제1 가상 객체는 대응하게 3미터만큼 후퇴하고; 점프 장애물의 높이가 15미터일 때, 제1 가상 객체는 대응하게 5미 터만큼 후퇴한다. 도 6에 도시된 바와 같이, 제1 가상 객체의 전방에 비교적 높은 컨테이너가 있을 때, 제1 가상 객체는 점프 후 그리고 타깃 랜딩 지점에 도달하기 전에 공중에서 컨테이너를 만날 수 있다는 것이 예측된 가능한 점프 궤적에 기초하여 학습될 수 있으며, 컨테이너는 제1 가상 객체의 점프 장애물이다. 컴퓨터 디바이스는 특정 거리만큼 후퇴한 다음 점프하도록 제1 가상 객체를 제어할 수 있다. 도 7에 도시된 바와 같이, 도 7은 도 6에 도시된 가 상 장면의 실제 장면 인터페이스의 개략도이고, 가상 장면의 실제 형태는 도 7로부터 보다 명확하게 이해될 수 있다. 305. 컴퓨터 디바이스는 현재 포지션 및 타깃 랜딩 지점에 따라, 현재 포지션에서 타깃 랜딩 지점으로 점프하는 제1 가상 객체의 점프 궤적을 결정한다. 본 출원의 실시예들에서, 컴퓨터 디바이스는 먼저 현재 포지션으로부터 타깃 랜딩 지점으로의 점프의 점프 속도 를 결정하고, 그 다음, 점프 속도에 기초하여 점프 궤적을 결정할 수 있다. 이 단계는: 컴퓨터 디바이스가 현재 포지션 및 타깃 랜딩 지점에 따라 현재 포지션에서의 제1 가상 객체의 점프 속도를 결정할 수 있고, 컴퓨터 디 바이스가 점프 속도에 따라 현재 포지션으로부터 타깃 랜딩 지점까지의 제1 가상 객체의 점프 궤적을 결정하는 것을 포함할 수 있다. 점프 속도는 점프 속도의 속도 값 및 속도 방향을 포함한다. 일 실시예에서, 점프 궤적은 포물선 궤적일 수 있고, 컴퓨터 디바이스는 현재 포지션 및 타깃 랜딩 지점에 따라 다음의 공식 1을 사용함으로써 제1 가상 객체의 점프 속도를 결정할 수 있으며: 공식 1:"}
{"patent_id": "10-2021-7025947", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "여기서 x는 현재 포지션으로부터 타깃 랜딩 지점까지의 수평 변위를 표현하는 데 사용되고, y는 현재 포지션으 로부터 타깃 랜딩 지점까지 수평면에 수직인 수직 변위를 표현하는 데 사용되며, v0은 점프 속도의 속도 값을 표 현하는 데 사용되고, θ는 점프 속도의 속도 방향을 표현하는 데 사용되며, g는 중력 가속도를 표현한다. 본 출원의 실시예들에서, θ는 속도 방향과 수평면 간의 각도일 수 있고, θ는 공식 2: 로 도시된다. 컴퓨터 디바이스는 제1 가상 객체의 속도 범위를 획득하고, 속도 범위에 포함된 복수의 속도 값들에 기초하여, 공식 1을 충족하는 속도 값 및 속도 방향을 획득 할 수 있다. 예를 들어, 컴퓨터 디바이스는 속도 범위 내의 속도 값들의 최소 값(vmin)으로부터 시작하여, 공식 1에 속도 값들을 대입하여, 공식 1이 충족되는지 여부를 결정할 수 있다. 공식이 충족되지 않는다면, 최소 값은 타깃 임계치만큼 vmin+△v로 증가되고, 공식 1을 충족하는 점프 속도가 획득될 때까지 공식 1에 값을 대입한다. 일 실시예에서, 도 8에 도시된 바와 같이, 컴퓨터 디바이스는 공식 1에 기초하여 2개의 점프 궤적들을 결정하며, 여기서 도 8의 좌측 도면은 바로 아래로 점프하는 것에 대응하는 제1 점프 궤적이고, 도 8의 우측 도 면은 먼저 위로 점프한 다음 랜딩하는 것에 대응하는 제2 점프 궤적이다. 도 8에서, 2개의 좌표계들에서, 수평 좌표는 수평 방향의 거리이고, 수직 좌표는 수직 방향의 거리이다. 현재 포지션은 (0, 200)이고, 타깃 랜딩 지 점은(200, 0)이며, 단위는 미터일 수 있다. 컴퓨터 디바이스는 먼저 위로 점프한 다음 랜딩하는 것에 대응하는 제2 점프 궤적을 선택할 수 있다. 다른 실시예에서, 컴퓨터 디바이스는 대안으로, 현재 포지션과 타깃 랜딩 지 점 간의 상대적인 높이에 기초하여 점프 궤적을 결정할 수 있다. 현재 포지션의 높이가 타깃 랜딩 지점의 높이보다 더 높을 때, 컴퓨터 디바이스는 또한 바로 아래로 점프하는 것에 대응하는 제1 점프 궤적을 선택할 수 있 고; 현재 포지션의 높이가 타깃 랜딩 지점의 높이보다 낮을 때, 컴퓨터 디바이스는 먼저 위로 점프한 다음 랜딩 하는 것에 대응하는 제2 점프 궤적을 선택할 수 있다. 제1 가상 객체가 AI 객체라면, 컴퓨터 디바이스는 가상 객체의 점프 프로세스를 제어하도록, AI 객체의 액션 트 리에 노드들을 추가하는 방법을 사용함으로써 단계들(302 내지 305)의 프로세스를 구현할 수 있다. 일 실시예에 서, 컴퓨터 디바이스는 제1 노드에서 단계의 검출 로직을 구성하고, 제2 노드에서 단계들(303 내지 305)의 점프 로직을 구성하고, 제1 노드 및 제2 노드를 액션 트리에 추가하여 가상 객체의 점프 제어 프로세스를 구현 할 수 있다. AI 객체의 액션 트리가 수정될 때, AI 객체의 기본 경로 찾기 및 공격 로직과 같은 원래의 AI 로직 은 수정될 필요가 없으며, 액션 트리의 노드들은 언제든지 추가되거나 삭제될 수 있으므로, 본 출원의 실시예들 의 방법은 더 편리하게 구현될 수 있다. 추가로, 내비게이션 메시에서 많은 링크 브리지들을 구성할 필요가 없 으며, 이로써 객체 점프 제어 방법의 적용 가능성을 향상시킨다. 306. 컴퓨터 디바이스는 점프 궤적에 따라 현재 포지션에서 타깃 랜딩 지점으로 점프하도록 제1 가상 객체를 제 어한다. 컴퓨터 디바이스는 점프 궤적에 따라 제1 이미지와 제2 이미지 사이에 점프 프로세스에 대응하는 복수의 중간 이미지들을 삽입하고 디스플레이할 수 있다. 이 단계에서, 컴퓨터 디바이스는 점프 궤적에 따라, 현재 포지션을 떠난 후 그리고 타깃 랜딩 지점에 도달하기 전에 제1 가상 객체의 복수의 공중 포지션들을 획득할 수 있다. 컴 퓨터 디바이스는 복수의 공중 포지션들에 기초하여 제1 가상 객체의 복수의 중간 이미지들을 획득하며, 각각의 중간 이미지는 공중 포지션에 위치된 제1 가상 객체를 디스플레이하는 데 사용된다. 컴퓨터 디바이스는 복수의 중간 이미지들의 플레이 시퀀스(play sequence)에 기초하여 복수의 중간 이미지들을 플레이한다. 컴퓨터 디바이스가 단말이라면, 제1 가상 객체가 현재 포지션에서 타깃 랜딩 지점으로 점프하는 프로세스가 앞 서 말한 단계들에 기반하여 디스플레이된다. 컴퓨터 디바이스가 서버라면, 컴퓨터 디바이스는 복수의 공중 포지 션들을 획득하고, 복수의 공중 포지션들을 단말에 전송할 수 있다. 단말은 복수의 중간 이미지들을 획득하고, 중간 이미지들의 플레이 시퀀스에 기초하여 복수의 중간 이미지들을 플레이한다. 일 실시예에서, 현재 포지션에 대응하는 점프 시작 시간에서부터 시작하여, 컴퓨터 디바이스는 점프 궤적에 따 라, 타깃 시간 기간의 간격들로 제1 가상 객체의 하나의 중간 포지션을 획득하고, 타깃 랜딩 지점에 대응하는 점프 종료 시간에 도달할 때까지 획득을 중단하여, 복수의 중간 포지션들을 획득할 수 있다. 컴퓨터 디바이스는 제1 가상 객체의 객체 디스플레이 데이터 및 각각의 중간 포지션에 따라, 각각의 중간 이미지에서 대응하는 중 간 포지션에 위치된 제1 가상 객체를 렌더링하고 디스플레이한다. 일 실시예에서, 목적지는 타깃 가상 객체의 현재 포지션이고, 제1 가상 객체는 AI 객체일 수 있으며, 타깃 가상 객체는 가상 사용자 객체일 수 있다. 컴퓨터 디바이스가 타깃 랜딩 지점으로 점프하도록 제1 가상 객체를 제어 할 때, 컴퓨터 디바이스는 AI 객체의 경로 찾기 및 공격 로직에 기반하여, AI 객체가 타깃 가상 객체를 공격하 는 프로세스를 추가로 디스플레이할 수 있다. 본 출원의 실시예들의 프로세스를 보다 명확하게 설명하기 위해, 앞서 말한 단계들(301 내지 306)이 도 9에 도 시된 흐름도를 사용함으로써 아래에서 설명된다. AI 객체가 일례로 사용된다. AI 객체가 가상 사용자 객체로 걸 어갈 수 없다는 것을 컴퓨터 디바이스가 검출하면, 가상 사용자 객체 주위의 타깃 랜딩 지점, 예를 들어 가상 사용자 객체의 보행 구역에 위치된 지점이 선택된다. 컴퓨터 디바이스는 단계에서 AI 객체의 속도 범위 및 공식 1에 기초하여, 속도 범위 내의 최소 값을 공식 1에 대입함으로써 계산을 시작한다. 계산이 실패한다면, 최 소값이 증가되고, 이어서 공식 1을 충족하는 점프 속도가 결정될 때까지 다시 계산을 위해 공식 1에 대입된다. 컴퓨터 디바이스는 점프 속도로 타깃 랜딩 지점으로 점프하여 가상 사용자 객체를 공격하도록 제1 가상 객체를 제어한다. 본 출원의 실시예들에서, 컴퓨터 디바이스는 목적지의 포지션에 기초하여 타깃 랜딩 지점을 획득하고, 점프 궤 적을 결정하며, 미리 구성된 점프 지점들에 따라 점프하지 않고 현재 포지션에서 타깃 랜딩 지점으로 점프하도 록 제1 가상 객체를 제어할 수 있다. 따라서 보행 불가능 구역들에 많은 링크 브리지들을 구성하는 프로세스가 생략되고, 객체 점프 제어의 비용들이 감소되며, 자원 이용이 개선된다. 본 출원의 실시예들에서의 단계들이 반드시 단계 번호들로 표시된 시퀀스에 따라 수행되는 것은 아니라고 이해 되어야 한다. 본 출원에 달리 명시적으로 지정되지 않는 한, 단계들의 실행은 엄격하게 제한되지 않으며, 단계 들은 다른 순서들로 수행될 수 있다. 더욱이, 각각의 실시예의 단계들 중 적어도 일부는 복수의 하위 단계들 또는 복수의 스테이지들을 포함할 수 있다. 하위 단계들 또는 스테이지들은 반드시 동일한 순간에 수행되는 것이 아니라 서로 다른 순간들에 수행될 수도 있다. 하위 단계들 또는 스테이지들은 반드시 순차적으로 수행되는 것 이 아니라, 다른 단계 또는 다른 단계의 하위 단계들 또는 스테이지들의 적어도 일부와 교대로 또는 차례로 수 행될 수 있다. 도 10은 본 출원의 실시예에 따른 객체 점프 제어 장치의 개략적인 구조도이다. 도 10을 참조하면, 이 장치는: 가상 장면 내의 제1 가상 객체가 목적지로 이동하는 프로세스에서, 제1 가상 객체의 현재 포지션이 점프 조건을 충족할 때 목적지의 포지션에 따라 제1 가상 객체의 타깃 랜딩 지점을 결정하도록 구성된 결정 모듈; ― 결정 모듈은 현재 포지션 및 타깃 랜딩 지점에 따라, 현재 포지션에서 타깃 랜딩 지점으로 점프하는 제1 가상 객체의 점프 궤적을 결정하도록 추가로 구성됨 ―; 및 점프 궤적에 따라 현재 포지션에서 타깃 랜딩 지점으로 점프하도록 제1 가상 객체를 제어하도록 구성된 점프 제 어 모듈을 포함한다. 일 실시예에서, 결정 모듈은 다음 중 임의의 하나를 수행하도록 추가로 구성된다: 목적지의 보행 구역에 기초하여, 현재 포지션이 점프 조건을 충족할 때 보행 구역에 위치된 타깃 랜딩 지점을 결정하는 것 ― 보행 구역 내의 임의의 포지션과 목적지 사이에는 보행 경로가 존재함 ―; 현재 포지션이 점프 조건을 충족할 때 가상 장면에서 목적지에 가장 가까운 포지션을 타깃 랜딩 지점으로서 결 정하는 것; 현재 포지션이 점프 조건을 충족할 때 가상 장면에서 목적지의 인접한 포지션을 타깃 랜딩 지점으로서 결정하는 것; 또는 현재 포지션이 점프 조건을 충족할 때 목적지를 타깃 랜딩 지점으로서 결정하는 것. 일 실시예에서, 결정 모듈은 다음 중 임의의 하나를 수행하도록 추가로 구성된다: 제1 가상 객체의 최대 점프 속도에 따라, 보행 구역에서 최대 점프 속도에 대응하는 타깃 랜딩 지점을 획득하는 것; 또는 보행 구역에서 선택된 포지션을 획득하고, 선택된 포지션을 타깃 랜딩 지점으로서 결정하는 것. 일 실시예에서, 목적지는 가상 장면 내의 타깃 가상 객체의 현재 포지션 또는 가상 장면 내의 선택된 포지션을 참조한다. 일 실시예에서, 점프 조건은: 현재 포지션과 목적지 사이에 어떠한 보행 경로도 존재하지 않는 것, 또는 현재 포지션과 목적지 간의 최단 경로의 방향으로 현재 포지션의 전방에 장애물이 존재하는 것을 포함한다. 일 실시예에서, 결정 모듈은 현재 포지션 및 타깃 랜딩 지점에 따라 현재 포지션에서의 제1 가상 객체의 점프 속도를 결정하고; 그리고 점프 속도에 따라 현재 포지션으로부터 타깃 랜딩 지점까지의 제1 가상 객체의 점프 궤적을 결정하도록 추가로 구성된다. 일 실시예에서, 장치는: 현재 포지션과 목적지 사이에 점프 장애물이 있을 때 제1 가상 객체를 이동시키고, 그리고 이동 이후 제1 가상 객체의 현재 포지션을 획득하도록 구성된 획득 모듈을 더 포함하며, 이동 이후 제1 가상 객체와 타깃 랜딩 지점 간의 거리는 이동 전의 제1 가상 객체와 타깃 랜딩 지점 간의 거리보다 더 멀다. 일 실시예에서, 점프 제어 모듈은 점프 궤적에 따라, 현재 포지션을 떠난 후 그리고 타깃 랜딩 지점에 도 달하기 전에 제1 가상 객체의 복수의 공중 포지션들을 획득하고; 복수의 공중 포지션들에 기초하여 제1 가상 객 체의 복수의 중간 이미지들을 획득하며 ― 각각의 중간 이미지는 공중 포지션에 위치된 제1 가상 객체를 디스플 레이하는 데 사용됨 ―; 그리고 복수의 중간 이미지들의 플레이 시퀀스에 기초하여 복수의 중간 이미지들을 플 레이하도록 추가로 구성된다. 본 출원의 실시예들에서, 컴퓨터 디바이스는 목적지의 포지션에 기초하여 타깃 랜딩 지점을 획득하고, 점프 궤 적을 결정하며, 미리 구성된 점프 지점에 따라 점프하지 않고 현재 포지션에서 타깃 랜딩 지점으로 점프하도록 제1 가상 객체를 제어할 수 있다. 따라서 보행 불가능 구역들에 많은 링크 브리지들을 구성하는 프로세스가 생 략되고, 객체 점프 제어의 비용들이 감소되며, 자원 이용이 개선된다.앞서 말한 기술적 솔루션들의 임의의 조합이 본 개시내용의 실시예를 형성하는 데 사용될 수 있다. 세부사항들 은 여기서 다시 설명되지 않는다. 앞서 말한 실시예들에서 제공된 객체 점프 제어 장치를 사용함으로써 객체가 점프하도록 제어될 때, 앞서 말한 기능 모듈들의 분할의 일례로 설명이 이루어진다. 실제 적용 중에, 기능들은 요건들에 따라 상이한 기능 모듈들 에 할당되고 상이한 기능 모듈들에 의해 완료될 수 있는데, 즉 컴퓨터 디바이스의 내부 구조는 위에서 설명된 기능들 전부 또는 그 일부를 구현하도록 상이한 기능 모듈들로 분할된다. 추가로, 앞서 말한 실시예에서 제공된 객체 점프 제어 장치는 객체 점프 제어 방법의 실시예와 동일한 개념에 속한다. 특정 구현 프로세스에 대해서는 방법 실시예들에 대한 참조가 이루어질 수 있으며, 세부사항들은 본 명세서에서 다시 설명되지 않는다. 도 11은 본 출원의 실시예에 따른 단말의 개략적인 구조도이다. 단말은 스마트폰, 태블릿 컴퓨터, 동화상 전문가 그룹 계층 Ⅲ(MP3: Moving Picture Experts Group Audio Layer Ⅲ) 플레이어, 동화상 전문가 그룹 계층 Ⅳ(MP4: Moving Picture Experts Group Audio Layer Ⅳ) 플레이어, 노트북 컴퓨터 또는 데스크톱 컴퓨터일 수 있다. 단말은 또한, 사용자 장비, 휴대용 단말, 랩톱 단말 또는 데스크톱 단말과 같은 다른 명칭으로 지 칭될 수도 있다. 일반적으로, 단말은 프로세서 및 메모리를 포함한다. 프로세서는 하나 이상의 프로세싱 코어들, 예를 들어 4-코어 프로세서 또는 8-코어 프로세서를 포함할 수 있다. 프로세서는 디지털 신호 프로세서(DSP: digital signal processor), 필드 프로그래밍 가능 게이트 어레이(FPGA: field-programmable gate array) 및 프로그래밍 가능 로직 어레이(PLA: programmable logic array) 중 적어도 하나의 하드웨어 형태로 구현될 수 있다. 프로세서는 또한 메인 프로세서 및 보조 프로 세서를 포함할 수 있다. 메인 프로세서는 어웨이크(awake) 상태에서 데이터를 처리하도록 구성된 프로세서이며, 중앙 처리 유닛(CPU: central processing unit)으로도 또한 지칭된다. 보조 프로세서는 대기 상태에서 데이터를 처리하도록 구성된 저전력 소비 프로세서이다. 일부 실시예들에서, 프로세서는 그래픽 처리 유닛(GPU: graphics processing unit)과 통합될 수 있다. GPU는 디스플레이 스크린 상에 디스플레이될 필요가 있는 콘텐츠 를 렌더링 및 드로잉(draw)하도록 구성된다. 일부 실시예들에서, 프로세서는 인공 지능(AI) 프로세서를 더 포함할 수 있다. AI 프로세서는 머신 러닝과 관련된 컴퓨팅 동작들을 처리하도록 구성된다. 메모리는 하나 이상의 컴퓨터 판독 가능 저장 매체를 포함할 수 있다. 컴퓨터 판독 가능 저장 매체는 비- 일시적일 수 있다. 메모리는 고속 랜덤 액세스 메모리 및 비휘발성 메모리, 예를 들어 하나 이상의 디스 크 저장 디바이스들 또는 플래시 저장 디바이스들을 더 포함할 수 있다. 일부 실시예들에서, 메모리 내의 비-일시적 컴퓨터 판독 가능 저장 매체는 적어도 하나의 명령을 저장하도록 구성되며, 적어도 하나의 명령은 본 출원의 방법 실시예들에서 제공되는 객체 점프 제어 방법을 구현하도록 프로세서에 의해 실행되도록 구성 된다. 일부 실시예들에서, 단말은: 주변 디바이스 인터페이스 및 적어도 하나의 주변 디바이스를 포함할 수 있다. 프로세서, 메모리 및 주변 디바이스 인터페이스는 버스 또는 신호 케이블을 사용함 으로써 연결될 수 있다. 각각의 주변 디바이스는 버스, 신호 케이블 또는 회로 보드를 사용함으로써 주변 디바 이스 인터페이스에 연결될 수 있다. 구체적으로, 주변 디바이스는: 무선 주파수(RF: radio frequency) 회 로, 디스플레이 스크린, 카메라 컴포넌트, 오디오 회로, 포지셔닝 컴포넌트 및 전력 공급부 중 적어도 하나를 포함한다. 주변 디바이스 인터페이스는 입력/출력(I/O: input/output)과 관련된 적어도 하나의 주변 기기를 프로세 서 및 메모리에 연결하도록 구성될 수 있다. 일부 실시예들에서, 프로세서, 메모리 및 주변 디바이스 인터페이스는 동일한 칩 또는 회로 보드 상에 통합된다. 다른 일부 실시예들에서, 프로세 서, 메모리 및 주변 디바이스 인터페이스 중 임의의 하나 또는 2개는 단일 칩 또는 회로 보 드 상에 구현될 수 있다. 이는 이 실시예에서 제한되지 않는다. RF 회로는 전자기 신호로도 또한 지칭되는 RF 신호를 수신 및 전송하도록 구성된다. RF 회로는 전 자기 신호를 통해 통신 네트워크 및 다른 통신 디바이스들과 통신한다. RF 회로는 전기 신호를 전송을 위 한 전자기 신호로 변환하거나, 수신된 전자기 신호를 전기 신호로 변환한다. 일부 실시예들에서, RF 회로(110 4)는: 안테나 시스템, RF 트랜시버, 하나 이상의 증폭기들, 튜너, 오실레이터, 디지털 신호 프로세서, 코덱 칩 세트, 가입자 식별 모듈 카드 등을 포함한다. RF 회로는 적어도 하나의 무선 통신 프로토콜을 사용함으로 써 다른 단말과 통신할 수 있다. 무선 통신 프로토콜은 도시권 네트워크(metropolitan area network), 상이한세대들의 모바일 통신 네트워크들(2G, 3G, 4G, 5G), 무선 근거리 네트워크(wireless local area network) 및/ 또는 무선 충실도(Wi-Fi: wireless fidelity) 네트워크를 포함하지만 이에 제한되지는 않는다. 일부 실시예들에 서, RF 회로는 NFC와 관련된 회로를 더 포함할 수 있으며, 이는 본 출원에서 제한되지 않는다. 디스플레이 스크린은 사용자 인터페이스(UI: user interface)를 디스플레이하도록 구성된다. UI는 그래프, 텍스트, 아이콘, 비디오, 및 이들의 임의의 조합을 포함할 수 있다. 디스플레이 스크린이 터치 디스플레이 스크린일 때, 디스플레이 스크린은 추가로, 디스플레이 스크린의 표면 상에서 또는 그 표면 위에서 터치 신호들을 수집할 수 있다. 터치 신호는 처리를 위한 제어 신호로서 프로세서에 입력될 수 있다. 이러한 경우, 디스플레이 스크린은 소프트 버튼 및/또는 소프트 키보드로도 또한 지칭되는 가상 버튼 및/또는 가상 키보드를 제공하도록 추가로 구성될 수 있다. 일부 실시예들에서, 단말의 전면 패널 상에 배치된 하나의 디스플레이 스크린이 존재할 수 있다. 다른 일부 실시예들에서, 단말의 상이한 표면들 상에 각각 배치되거나 또는 접을 수 있는 형상으로 설계된 적어도 2개의 디스플레이 스크린들이 존재할 수 있다. 또 다른 일부 실시예들에서, 디스플레이 스크린은 단말의 만곡된 표면 또는 접힌 표면 상에 배치된 가요성 디스플레이 스크린일 수 있다. 심지어, 디스플레이 스크린은 직사각형이 아닌 불규칙한 패턴, 즉 특수 형상 스크린으로 추가로 설정될 수 있다. 디스플레이 스크린은 액정 디스플레이 (LCD: liquid crystal display), 유기 발광 다이오드(OLED: organic light-emitting diode) 등과 같은 재료들 을 사용함으로써 준비될 수 있다. 카메라 컴포넌트는 이미지들 또는 비디오들을 수집하도록 구성된다. 일부 실시예들에서, 카메라 컴포넌트 는 전면 카메라 및 후면 카메라를 포함한다. 일반적으로, 전면 카메라는 단말의 전면 패널 상에 배치되고, 후면 카메라는 단말의 후면 상에 배치된다. 일부 실시예들에서, 각각 메인 카메라, 피사계 심도 (depth-of-field) 카메라, 광각 카메라 및 망원 카메라 중 임의의 카메라인 적어도 2개의 후방 카메라들이 존재 하여, 메인 카메라와 피사계 심도 카메라의 융합을 통한 배경 블러(blur), 메인 카메라와 광각 카메라의 융합을 통한 파노라마 촬영(panoramic photographing) 및 가상 현실(VR: virtual reality) 촬영, 또는 다른 융합 촬영 기능들을 달성한다. 일부 실시예들에서, 카메라 컴포넌트는 플래시를 더 포함할 수 있다. 플래시는 단색 온도 플래시일 수 있거나, 이중 색 온도 플래시일 수 있다. 이중 색 온도 플래시는 따뜻한 광 플래시와 차가운 광 플래시의 조합을 의미하며, 상이한 색 온도들 하에서 광 보상을 위해 사용될 수 있다. 오디오 회로는 마이크로폰 및 스피커를 포함할 수 있다. 마이크로폰은 사용자 및 환경의 음파들을 수집하 고, 음파들을 전기 신호로 변환하여, 처리를 위해 프로세서에 입력하거나 음성 통신을 구현하기 위해 RF 회로에 입력하도록 구성된다. 스테레오 사운드 포착 또는 잡음 감소의 목적으로, 단말의 상이한 부 분들에 각각 배치된 복수의 마이크로폰들이 존재할 수 있다. 마이크로폰은 추가로, 어레이 마이크로폰 또는 무 지향성 수집 타입 마이크로폰일 수 있다. 스피커는 프로세서 또는 RF 회로로부터의 전기 신호들을 음파들로 변환하도록 구성된다. 스피커는 종래의 필름 스피커일 수 있거나, 압전 세라믹 스피커일 수 있다. 스 피커가 압전 세라믹 스피커인 경우, 스피커는 전기 신호를 인간이 들을 수 있는 음향파들로 변환할 수 있을 뿐 만 아니라, 거리 측정(ranging) 및 다른 목적들로 전기 신호를 인간이 들을 수 없는 음향파들로 변환할 수 있다. 일부 실시예들에서, 오디오 회로는 또한 이어폰 잭(earphone jack)을 포함할 수 있다. 포지셔닝 컴포넌트는 단말의 현재 지리적 위치를 결정하여 내비게이션 또는 위치 기반 서비스(LB S)를 구현하도록 구성된다. 포지셔닝 컴포넌트는 미국의 글로벌 포지셔닝 시스템(GPS: Global Positioning System), 중국의 BeiDou 시스템, 러시아의 GLONASS 시스템, 또는 유럽 연합의 GALILEO 시스템에 기반한 포지셔닝 컴포넌트일 수 있다. 전력 공급부는 단말 내의 컴포넌트들에 전력을 공급하도록 구성된다. 전력 공급부는 교류 전 력 공급부, 직류 전력 공급부, 일회용 배터리 또는 재충전 가능 배터리일 수 있다. 전력 공급부가 재충전 가능 배터리를 포함하는 경우, 재충전 가능 배터리는 유선 충전 또는 무선 충전을 지원할 수 있다. 재충전 가능 배터리는 고속 충전 기술을 지원하도록 추가로 구성될 수 있다. 일부 실시예들에서, 단말은 하나 이상의 센서들을 더 포함한다. 하나 이상의 센서들은: 가속 도 센서, 자이로스코프 센서, 압력 센서, 지문 센서, 광 센서 및 근접도 센서 를 포함하지만 이에 제한되지는 않는다. 가속도 센서는 단말에 의해 설정된 좌표계의 3개의 좌표 축들 상에서 가속도를 검출할 수 있다. 예 를 들어, 가속도 센서는 3개의 좌표 축들 상에서 중력 가속도의 컴포넌트들을 검출하도록 구성될 수 있다. 프로세서는 가속도 센서에 의해 획득된 중력 가속도 신호에 따라, UI를 가로 뷰(landscapeview) 또는 세로 뷰(portrait view)로 디스플레이하도록 터치 디스플레이 스크린을 제어할 수 있다. 가속 도 센서는 게임 또는 사용자의 모션 데이터를 획득하도록 추가로 구성될 수 있다. 자이로스코프 센서는 단말의 바디 방향 및 회전 각도를 검출할 수 있다. 자이로스코프 센서 는 가속도 센서와 협력하여 단말 상에서 사용자에 의한 3D 액션을 수집할 수 있다. 프로세서(110 1)는 자이로스코프 센서에 의해 획득된 데이터에 따라 다음의 기능들: 모션 감지(예컨대, 사용자의 기울 기(tilt) 동작에 따라 UI가 변경됨), 슈팅 중의 이미지 안정화, 게임 컨트롤(game control) 및 관성 내비게이션 을 구현할 수 있다. 압력 센서는 단말의 측면 프레임 및/또는 터치 디스플레이 스크린의 하부 층에 배치될 수 있 다. 압력 센서가 단말의 측면 프레임에 배치될 때, 단말에 대한 사용자의 홀딩 신호가 검출 될 수 있다. 프로세서는 압력 센서에 의해 수집된 홀딩 신호에 따라 왼손 및 오른손 인식 또는 빠 른 동작을 수행한다. 압력 센서가 터치 디스플레이 스크린의 하부 층에 배치될 때, 프로세서(110 1)는 터치 디스플레이 스크린 상의 사용자의 가압 동작에 따라, UI 상의 동작 가능한 컨트롤을 제어한다. 동작 가능한 컨트롤은 버튼 컨트롤, 스크롤바 컨트롤, 아이콘 컨트롤 및 메뉴 컨트롤 중 적어도 하나를 포함한 다. 지문 센서는 사용자의 지문을 수집하도록 구성되고, 프로세서는 지문 센서에 의해 수집된 지 문에 따라 사용자의 아이덴티티를 식별하거나, 지문 센서는 수집된 지문에 따라 사용자의 아이덴티티를 식별한다. 사용자의 아이덴티티가 신뢰할 수 있는 아이덴티티임을 식별하면, 프로세서는 관련된 민감한 동작들을 수행하도록 사용자에게 권한을 부여한다. 민감한 동작들은: 스크린 잠금 해제, 암호화된 정보 보기, 소프트웨어 다운로드, 지불, 설정 변경 등을 포함한다. 지문 센서는 단말의 전면, 후면 또는 측면 상에 배치될 수 있다. 물리적 버튼 또는 벤더 로고가 단말 상에 배치되면, 지문이 물리적 버튼 또 는 벤더 로고와 통합될 수 있다. 광 센서는 주변 광 세기를 수집하도록 구성된다. 실시예에서, 프로세서는 광 센서에 의해 수 집된 주변 광 세기에 따라 터치 디스플레이 스크린의 디스플레이 밝기를 제어할 수 있다. 구체적으로, 주 변 광 세기가 비교적 높을 때, 터치 디스플레이 스크린의 디스플레이 밝기가 높아진다. 주변 광 세기가 비교적 낮으면, 터치 디스플레이 스크린의 디스플레이 밝기가 낮아진다. 다른 실시예에서, 프로세서 는 광 센서에 의해 수집된 주변 광 세기에 따라 카메라 컴포넌트의 카메라 파라미터를 동적 으로 추가 조정할 수 있다. 거리 센서로도 또한 지칭되는 근접도 센서는 대개 단말의 전면 패널 상에 배치된다. 근접도 센서 는 사용자와 단말의 전면 간의 거리를 수집하도록 구성된다. 실시예에서, 근접도 센서가 사 용자와 단말의 전면 간의 거리가 점진적으로 더 작아지는 것을 검출하면, 터치 디스플레이 스크린 은 스크린-온(screen-on) 상태에서 스크린-오프(screen-off) 상태로 스위칭하도록 프로세서에 의해 제어 된다. 근접도 센서가 사용자와 단말의 전면 간의 거리가 점진적으로 더 커지는 것을 검출하면, 터 치 디스플레이 스크린은 스크린-오프 상태에서 스크린-온 상태로 스위칭하도록 프로세서에 의해 제 어된다."}
{"patent_id": "10-2021-7025947", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "당해 기술분야에서 통상의 지식을 가진 자는, 도 11에 도시된 구조가 단말에 대한 어떠한 제한도 구성하 지 않으며, 단말이 도면에 도시된 것들보다 더 많은 또는 더 적은 컴포넌트들을 포함할 수 있거나, 일부 컴포넌 트들이 조합될 수 있거나, 상이한 컴포넌트 배치가 사용될 수 있다고 이해할 수 있다. 도 12는 본 출원의 실시예에 따른 서버의 개략적인 구조도이다. 서버는 서로 다른 구성들 또는 성능으로 인해 크게 달라질 수 있으며, 하나 이상의 중앙 처리 유닛(CPU)들 및 하나 이상의 메모리들을 포함 할 수 있다. 메모리는 적어도 하나의 명령을 저장하며, 적어도 하나의 명령은 앞서 말한 방법 실시예들에 서 제공된 객체 점프 제어 방법을 구현하도록 프로세서에 의해 로딩되어 실행된다. 확실히, 서버는 유선 또는 무선 네트워크 인터페이스, 키보드, I/O 인터페이스, 및 I/O를 가능하게 하기 위한 다른 컴포넌트들을 더 가질 수 있다. 서버는 디바이스 기능들을 구현하기 위한 다른 컴포넌트들을 더 포함할 수 있다. 세부사항들은 여기서 다시 설명되지 않는다. 예시적인 실시예에서, 컴퓨터 판독 가능 저장 매체, 예를 들어 명령들을 포함하는 메모리가 추가로 제공된다. 명령들은 앞서 말한 실시예들에서의 객체 점프 제어 방법을 완료하도록 컴퓨터 디바이스의 프로세서에 의해 실 행될 수 있다. 예를 들어, 컴퓨터 판독 가능 저장 매체는 판독 전용 메모리(ROM: read-only memory), 랜덤 액세스 메모리(RAM: random access memory), 콤팩트 디스크 판독 전용 메모리(CD-ROM: compact disc read-only memory), 자기 테이프, 플로피 디스크, 광학 데이터 저장 디바이스 등일 수 있다. 당해 분야에서 통상의 지식을 가진 자는 앞서 말한 실시예들의 단계들의 전부 또는 일부가 하드웨어에 의해 구 현될 수 있거나, 관련 하드웨어에 명령하는 프로그램에 의해 구현될 수 있다고 이해할 수 있다. 프로그램은 컴 퓨터 판독 가능 저장 매체에 저장될 수 있다. 위에서 언급한 저장 매체는: ROM, 자기 디스크 또는 광 디스크일 수 있다. 앞서 말한 설명들은 단지 본 출원의 바람직한 실시예들일 뿐이지만, 본 개시내용을 제한하는 것으로 의도되는 것은 아니다. 본 출원의 사상 및 원리 내에서 이루어진 임의의 수정, 동등한 대체, 개선 등은 본 출원의 보호 범위 내에 속할 것이다."}
{"patent_id": "10-2021-7025947", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 출원의 실시예들의 기술적 솔루션들을 보다 명확하게 설명하기 위해, 다음은 실시예들을 설명하는 데 필요한 첨부 도면들을 간략히 소개한다. 명백히, 다음 설명의 첨부 도면들은 본 출원의 단지 일부 실시예들만을 도시하"}
{"patent_id": "10-2021-7025947", "section": "도면", "subsection": "도면설명", "item": 2, "content": "고, 당해 기술분야에서 통상의 지식을 가진 자는 창의적인 노력들 없이 여전히 이러한 첨부 도면들로부터 다른 도면들을 도출할 수 있다. 도 1은 본 출원의 실시예에 따른 객체 점프 제어 방법의 장면의 개략도이다. 도 2는 본 출원의 실시예에 따른 객체 점프 제어 방법의 장면 인터페이스의 개략도이다. 도 3은 본 출원의 실시예에 따른 객체 점프 제어 방법의 흐름도이다.도 4는 본 출원의 실시예에 따른 객체 상태 검출의 흐름도이다. 도 5는 본 출원의 실시예에 따른 객체 상태 검출의 흐름도이다. 도 6은 본 출원의 실시예에 따른 점프 장애물의 개략도이다. 도 7은 본 출원의 실시예에 따른 점프 장애물의 인터페이스의 개략도이다. 도 8은 본 출원의 실시예에 따른 점프 궤적들의 개략도이다. 도 9는 본 출원의 실시예에 따른 객체 점프 제어의 흐름도이다. 도 10은 본 출원의 실시예에 따른 객체 점프 제어 장치의 개략적인 구조도이다. 도 11은 본 출원의 실시예에 따른 단말의 개략적인 구조도이다. 도 12는 본 출원의 실시예에 따른 서버의 개략적인 구조도이다."}
