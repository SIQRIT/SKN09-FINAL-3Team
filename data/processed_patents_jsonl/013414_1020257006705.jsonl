{"patent_id": "10-2025-7006705", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0051683", "출원번호": "10-2025-7006705", "발명의 명칭": "멀티 테넌트 인식 데이터 프로세싱 유닛", "출원인": "자일링크스 인코포레이티드", "발명자": "다스티다르 자이디프"}}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "멀티 테넌트 인식 데이터 프로세싱 유닛(data processing unit; DPU)으로서,호스트에 연결되도록 구성되는 제1 태그 게이트웨이;네트워크에 연결되도록 구성되는 제2 태그 게이트웨이 - 상기 제1 및 제2 태그 게이트웨이들은 서로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태그들을 할당하도록 구성됨 -; 및상기 수신된 데이터를 프로세싱할 때, 상기 서로 다른 태그들에 기초하여, 서로 다른 태그 정책들을 적용하도록구성되는 복수의 데이터 프로세싱 엔진(data processing engine; DPE)들을 포함하는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 태그들은 스푸핑 가능하지 않고 상기 복수의 DPE들에 의해 변경될 수 없으며, 상기 태그들의 제1 부분은 상기 복수의 DPE들에 의한 트러스티드 태그(trusted tag)들이고, 상기 태그들의 제2 부분은 상기 복수의 DPE들에 의한 언트러스티드 태그(untrusted tag)들인, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,(i) 수신된 데이터에 태그들을 할당하는 데 사용되는 상기 제1 및 제2 태그 게이트웨이들에서 태그 바인딩(tagbinding)들을 설정하고, (ii) 상기 복수의 DPE들 각각에서 상기 서로 다른 태그 정책들을 구성하도록 구성되는트러스티드 엔티티(trusted entity)를 더 포함하는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서, 상기 복수의 DPE들은 상기 서로 다른 태그 정책들을 적용하는 각각의 래퍼(wrapper)들을 포함하는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서, 상기 서로 다른 태그 정책들은 제1 테넌트가 제2 테넌트보다 상기 복수의 DPE들 중 제1 DPE에서 하드웨어 자원들의 더 큰 최대 공유를 할당받는다는 것을 나타내는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 서로 다른 태그 정책들은 제1 테넌트가 제2 테넌트보다 상기 복수의 DPE들 중 더 많은 수의 전용 DPE들을 할당받는다는 것을 나타내는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서, 상기 DPU는 스마트 네트워크 인터페이스 컨트롤러(Smart Network Interface Controller;SmartNIC)로서 구현되는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "멀티 테넌트 인식 데이터 프로세싱 유닛(DPU)으로서,상기 DPU의 로컬 인터페이스에 연결되는 제1 태그 게이트웨이;상기 DPU의 원격 인터페이스에 연결되는 제2 태그 게이트웨이 - 상기 제1 및 제2 태그 게이트웨이들은 상기 DPU에서 서로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태그들을 할당하도록 구성됨 -; 및(i) 서로 다른 테넌트들로부터 수신된 데이터를 격리하고 (ii) 상기 테넌트들에 대한 성능 표준들이 충족되는공개특허 10-2025-0051683-3-것을 보장하기 위해, 상기 수신된 데이터를 프로세싱할 때, 상기 서로 다른 태그들에 기초하여, 서로 다른 태그정책들을 적용하도록 구성되는 복수의 데이터 프로세싱 엔진(DPE)들을 포함하는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항 또는 제8항에 있어서, 상기 데이터는 상기 제2 태그 게이트웨이에서 수신된 데이터에 의해 사용되는 제2통신 프로토콜과 상이한 제1 통신 프로토콜을 사용하여 상기 제1 태그 게이트웨이에서 수신되는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제12항에 있어서, 상기 제1 태그 게이트웨이는 상기 태그들을 할당할 때 상기 제1 통신 프로토콜과 연관된 제1속성을 평가하도록 구성되고, 상기 제2 태그 게이트웨이는 상기 태그들을 할당할 때 상기 제2 통신 프로토콜과연관된 제2 속성을 평가하도록 구성되며, 상기 제1 속성의 제1 값 및 상기 제2 속성의 제2 값은 동일한 태그와연관됨으로써 상기 제1 및 제2 값들이 동일한 테넌트와 연관됨을 나타내는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제1항 또는 제8항에 있어서, 상기 태그들은 상기 DPU를 통해 엔드-투-엔드 바인딩(end-to-end binding)을 제공함으로써, 특정 태그에 대해, 상기 복수의 DPE들이 동일한 태그 정책을 적용하도록 하는, DPU."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "방법으로서,데이터 프로세싱 유닛(DPU)의 제1 태그 게이트웨이에서 복수의 테넌트들로부터 데이터를 수신하는 단계;상기 복수의 테넌트들 중 서로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태그들을 할당하는 단계; 및상기 복수의 테넌트들로부터의 태깅된 데이터가 상기 DPU 내의 데이터 프로세싱 엔진(DPE)들에 의해 프로세싱될때 서로 다른 태그 정책들을 적용하는 단계를 포함하는, 방법."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서,상기 DPU의 제2 태그 게이트웨이에서 상기 복수의 테넌트들로부터 데이터를 수신하는 단계; 및상기 제2 태그 게이트웨이를 사용하여 상기 복수의 테넌트들 중 서로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태그들을 할당하는 단계 - 상기 데이터는 상기 제2 태그 게이트웨이에서 수신된 데이터에 의해 사용되는 제2 통신 프로토콜과 상이한 제1 통신 프로토콜을 사용하여 상기 제1 태그 게이트웨이에서 수신됨 - 를 더포함하는, 방법."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제12항에 있어서, 상기 태그들은 상기 DPU를 통해 엔드-투-엔드 바인딩을 제공함으로써, 특정 태그에 대해, 상기 DPE들이 동일한 태그 정책을 적용하도록 하며, 상기 태그들은 스푸핑 가능하지 않고 상기 DPE들에 의해 변경될 수 없는, 방법."}
{"patent_id": "10-2025-7006705", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제15항에 있어서,트러스티드 엔티티를 사용하여, 상기 수신된 데이터에 태그들을 할당하는 데 사용되는 상기 제1 태그 게이트웨이에서의 태그 바인딩들을 설정하는 단계; 및상기 트러스티드 엔티티를 사용하여, 상기 DPE들 각각에서 서로 다른 태그 정책들을 구성하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2025-7006705", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 명세서의 실시예들은 SmartNIC, 인공 지능 유닛, 네트워크 저장 유닛, 데이터베이스 가속 유닛 등과 같은 데 이터 프로세싱 유닛(DPU)을 사용하여 상이한 테넌트들에 대응하는 데이터에 태그들을 할당하는데 사용될 수 있는 태그 바인딩들을 생성하는 것을 설명한다. 일 실시예에서, DPU들은 테넌트들에 대응하는 데이터를 인식하고 태 깅하는 호스트와 네트워크 요소(예를 들어, 스위치) 사이의 인터페이스에 태그 게이트웨이들을 포함한다. 이러 한 태그들은 AI 엔진, 암호화 엔진, 엔크립션 엔진, 직접 메모리 액세스(Direct Memory Access; DMA) 엔진 등과 같은 DPU 내의 데이터 프로세싱 엔진(DPE)들에 의해 인식된다. 이러한 DPE들은 테넌트들 사이의 보안 격리 및 성능 격리를 제공하는 태그 정책들을 수행하도록 구성될 수 있다."}
{"patent_id": "10-2025-7006705", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시의 예들은 일반적으로, 데이터 프로세싱 유닛(data processing unit; DPU)을 사용하여 서로 다른 테넌트 (tenant)들에 서로 다른 태그들을 할당하는 DPU에 관한 것이다. DPU는, 예를 들어, 테넌트 격리를 보장하고(노 이지 이웃(nosy neighbor)들을 방지) 성능 요건들을 만족시키기 위해(노이지 이웃들을 방지), 태그들에 기초하 여 상이한 정책들을 적용할 수 있는 다수의 데이터 프로세싱 엔진(data processing engine; DPE)들을 포함할 수 있다."}
{"patent_id": "10-2025-7006705", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "스마트 네트워크 인터페이스 카드/컨트롤러(SmartNIC)들과 같은 현재 가속 디바이스들은 I/O 게이트웨이들, 프 로세서 서브시스템들, 네트워크 온 칩(network on chip; NoC)들, 스토리지 및 데이터 가속기들, 데이터 프로세 싱 엔진들, 프로그래밍 가능 로직(PL)과 같은 다양한 컴포넌트들을 포함한다. 이전 기술들에서, 가속 디바이스 들의 이러한 다양한 컴포넌트들은 다음 컴포넌트로 포워딩하기 전에 단순히 작업을 전달하거나 데이터를 변환하 는 별도의 모놀리식 컴포넌트들로서 취급된다. 기껏해야, 이러한 컴포넌트들은 AXI(Advanced eXtensible Interface)와 같은 공통 버스 프로토콜을 통해 서로 인터페이싱하거나, PCIe와 같은 하나의 컴포넌트의 프로토 콜을 AXI와 같은 다른 컴포넌트의 프로토콜로 변환하는 프로토콜 브리징 기능을 갖는다. 하나의 컴포넌트에서 다음 컴포넌트로 데이터를 송신할 때, 하나의 컴포넌트에 고유하거나, 그 테넌트에 대한 기능을 서비스하는 테넌트에 고유한 데이터의 특성들 또는 속성들은, 2개의 컴포넌트들이 동일한 테넌트를 서비 스하는 특정 기능들을 수행할 수 있더라도, 둘 모두의 컴포넌트들이 서로 불투명하도록 다음 컴포넌트로 전파되 지 않는다. 달리 말하면, 동일한 가속기 디바이스의 상이한 컴포넌트들은 상호 관련된 동작들을 수행할 수 있 더라도 서로 독립적으로 동작한다. 일부 기존 기술들은 하나의 컴포넌트가 다른 컴포넌트로부터 작업이나 데이 터를 수신할 때마다 수신 컴포넌트가 중재 소프트웨어를 통해 테넌트의 특성들을 다시 취득할 수 있도록 다양한 컴포넌트들(브리지가 불투명한 경계를 생성할 수 있음)에 걸쳐 테넌트에 고유한 속성들을 되찾기 위한 소프트웨 어 중재(예를 들어, 하이퍼바이저 또는 컴포넌트 펌웨어)를 포함한다. 그러나, 이러한 소프트웨어 중재는 특히 다수의 테넌트 기능들을 위해 컴포넌트들에 걸쳐 서비스들을 인에이블하는 경우, 오버헤드를 생성한다. 게다가, 일부 테넌트들은 자신을 대신하여 중재하는 하이퍼바이저들이나 다른 소프트웨어 엔티티들(베어 메탈 배포(bare-metal deployment)들의 경우)을 신뢰하지 않는다. 일 실시예는 호스트에 연결되도록 구성되는 제1 태그 게이트웨이, 네트워크에 연결되도록 구성되는 제2 태그 게 이트웨이 - 제1 및 제2 태그 게이트웨이들은 서로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태그들을 할 당하도록 구성됨 -, 및 수신된 데이터를 프로세싱할 때, 서로 다른 태그들에 기초하여, 서로 다른 태그 정책들 을 적용하도록 구성되는 복수의 DPE들을 포함하는, 멀티 테넌트 인식 DPU를 설명한다. 본 명세서에 설명되는 다른 실시예는 DPU의 로컬 인터페이스에 연결되는 제1 태그 게이트웨이, DPU의 원격 인터 페이스에 연결되는 제2 태그 게이트웨이 - 제1 및 제2 태그 게이트웨이들은 DPU에서 서로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태그들을 할당하도록 구성됨 -, 및 (i) 서로 다른 테넌트들로부터 수신된 데이터를 격리하고 (ii) 테넌트들에 대한 성능 표준들이 충족되는 것을 보장하기 위해, 수신된 데이터를 프로세싱할 때, 서로 다른 태그들에 기초하여, 서로 다른 태그 정책들을 적용하도록 구성되는 복수의 데이터 프로세싱 엔진 (DPE)들을 포함하는, 멀티 테넌트 인식 DPU이다. 본 명세서에 설명되는 다른 실시예는 데이터 프로세싱 유닛(DPU)의 제1 태그 게이트웨이에서 복수의 테넌트들로 부터 데이터를 수신하는 단계, 복수의 테넌트들 중 서로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태그 들을 할당하는 단계, 및 복수의 테넌트들로부터의 태깅된 데이터가 DPU 내의 데이터 프로세싱 엔진(DPE)에 의해 프로세싱될 때 서로 다른 태그 정책들을 적용하는 단계를 포함하는 방법이다."}
{"patent_id": "10-2025-7006705", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "다양한 특징들이 이하 도면들을 참조하여 설명된다. 도면들은 축척대로 도시되거나 도시되지 않을 수 있으며 유사한 구조들 또는 기능들의 요소들은 도면 전체에 걸쳐 동일한 참조 번호들로 표시된다는 점에 유의해야 한다. 도면들은 특징들의 설명을 용이하게 하기 위한 것일 뿐임에 유의해야 한다. 도면들은 특징들에 대한 포 괄적인 설명이나 청구항의 범위에 대한 제한으로 의도된 것은 아니다. 또한, 예시된 예는 나타낸 모든 양태 또 는 이점을 가질 필요는 없다. 특정 예와 관련하여 설명된 양태 또는 이점은 반드시 해당 예에 한정되지 않으며, 예시되지 않았거나 명시적으로 설명되지 않았더라도 임의의 다른 예에서 실시될 수 있다. 본 명세서의 실시예들은 SmartNIC, 인공 지능 유닛, 네트워크 저장 유닛, 데이터베이스 가속 유닛 등과 같은 데 이터 프로세싱 유닛(DPU)을 사용하여 상이한 테넌트들에 대응하는 데이터에 태그들을 할당하는데 사용될 수 있 는 태그 바인딩들을 생성하는 것을 설명한다. 일 실시예에서, DPU들은 테넌트들에 대응하는 데이터를 인식하고 태깅하는 호스트와 네트워크 요소(예를 들어, 스위치) 사이의 인터페이스에 태그 게이트웨이들을 포함한다. 이 러한 태그들은 AI 엔진, 암호화 엔진, 엔크립션 엔진, 직접 메모리 액세스(Direct Memory Access; DMA) 엔진 등 과 같은 DPU 내의 데이터 프로세싱 엔진(DPE)들에 의해 인식된다. 이러한 DPE들은 테넌트들 사이의 보안 격리 및 성능 격리를 제공하는 태그 정책들을 수행하도록 구성될 수 있다. 예를 들어, 테넌트들 중 하나는 다른 테 넌트에 대한 데이터에 액세스할 수 없거나(예를 들어, 노이지 이웃을 방지), 또는 DPE 내의 리소스들에 대한 자 신의 할당량 이상을 취할 수 없다(예를 들어, 노이지 이웃을 방지). 이러한 방식으로, 태그 바인딩들은 DPU를 통해 엔드-투-엔드 바인딩을 생성할 수 있으며, 여기서 DPU 내의 상이한 DPE들은 특정 테넌트에 대해 조정된 태 그 정책을 적용한다. 도 1은 일 실시예에 따른, 멀티 테넌트 인식 DPU를 포함하는 시스템을 예시한다. 구체적으로, 시스 템은 DPU를 호스트 및 네트워크에 연결하는 것을 예시한다. 예를 들어, 호스트는 임 의의 수의 PCIe 연결부들을 사용하여 DPU와 통신하는 하나 이상의 프로세서들(예를 들어, 프로세서 컴플렉스) 및 메모리를 포함할 수 있다. 네트워크는 이더넷 연결부들에 의해 DPU에 연결되는 임의의 수의 네트워크 요소들(예를 들어, 하나 이상의 스위치들)을 포함할 수 있다. 일 실시예에서, DPU는 SmartNIC일 수 있으며, 여기서 호스트 는 원래는 호스트 상의 프로세서들에 의해 수행되었을 데이터 프로세싱 태스크들을 수행하기 위해 DPU 내의 DPE들을 사용한다. DPU는 AI 또는 기계 학습 태스크들을 수행하는 AI 가속기 유닛, 호스트와 네트워크 사이에서 전송된 데이터를 암호화 및 복호화하는 암호화 유닛, 네트워크 저장 유 닛, 클라우드 컴퓨팅 환경을 위한 데이터베이스 가속 유닛 등일 수 있다. 일 실시예에서, DPU와 호스트 사이의 연결은 로컬 인터페이스인 반면, DPU와 네트워크 사 이의 연결은 원격 인터페이스이다. 이러한 상이한 인터페이스들은 상이한 통신 프로토콜들을 사용할 수 있다. 예를 들어, 호스트와 DPU 사이의 로컬 인터페이스는 PCIe, 컴퓨트 익스프레스 링크(Compute Express Link; CXL), 또는 가속기를 위한 캐시 코히런트 상호 연결(Cache Coherent Interconnect for Accelerator; CCIX)을 사용할 수 있다. DPU와 네트워크 사이의 인터페이스는 인피니밴드(Infiniband) 또는 이더넷 (Ethernet)을 사용할 수 있다. DPU는 DPU를 공유하는 상이한 테넌트들에 의해 생성된 데이터를 태깅하는 태그 게이트웨이들을 포함한다. 예를 들어, 다수의 호스트들은 상이한 물리적 포트들에서 DPU에 부착될 수 있으며, 여기 서 각각의 호스트는 상이한 테넌트이다. 다른 실시예에서, 특정 호스트는 각각 상이한 테넌트들로서 취급되는(예를 들어, 클라우드 컴퓨팅 환경 또는 데이터센터에서 상이한 애플리케이션들을 실행하거나 상이한 고객들과 연관된) 다수의 VM들을 가질 수 있다. 따라서, 테넌트는 물리적 컴퓨팅 시스템(예를 들어, 호스트 ), 가상 머신 또는 컨테이너, 특정 애플리케이션, 또는 데이터 센터 환경의 고객일 수 있다. 이와 같이,테넌트들은 물리적 컴포넌트들(예를 들어, 상이한 포트들)에 대응할 수 있거나 또는 논리적 구성들(예를 들어, 동일한 가상 머신 또는 동일한 호스트를 사용하는 상이한 고객들)일 수 있다. 태그 게이트웨이(115A)는 호스트로부터 데이터를 수신하고, 데이터 내의 속성들을 사용하여 데이터를 태깅 한다. 달리 말하면, 태그 게이트웨이(115A)는 수신된 데이터 내의 식별 속성들을 사용하여, 데이터가 특정 테 넌트로부터 온 것지를 결정한 다음, 식별된 테넌트에 대응하는 해당 데이터에 태그를 할당할 수 있다. 예를 들 어, 게이트웨이는 데이터 내의 ID를 사용하여 테넌트를 식별하고 태그를 제공할 수 있다. 다른 실시예에 서, 게이트웨이는 데이터의 소스(예를 들어, 데이터를 전송한 호스트 또는 VM, 애플리케이션 ID, 데이터가 수신된 포트 등)를 평가하여 테넌트를 식별하고 태그를 제공할 수 있다. 또 다른 실시예에서, 게이트웨이(11 5)는 데이터의 목적지 또는 어드레스 범위를 평가하여 테넌트를 식별하고 데이터를 태깅할 수 있다. 본 실시예에서, DPU는 태그 게이트웨이(115A)를 구성하는 것이 허용되는 DPU 내의 유일한 엔티티일 수 있는 트러스티드 엔티티(trusted entity)를 포함한다. DPU는 트러스티드 엔티티만이 태그 게이트웨이(115A)를 구성하여 데이터 내의 속성들(예를 들어, ID, 소스 정보, 목적지 정보 등)을 특정 태그에 링크하는 태그 바인딩들을 생성할 수 있게 보장하는 방화벽들을 포함할 수 있다. 따라서, 악의적인 외부 행위 자들은 태그 바인딩들을 변경하거나 또는 스푸핑하기 위해 태그 게이트웨이에 대한 액세스를 얻을 수 없다. 즉, 태그들은 스푸핑 가능하지 않으며 변경될 수 없다. 일 실시예에서, DPU는 태그 게이트웨이들에 의해 할당된 태그들이 신뢰되도록 전체 하드웨어 방화벽 을 포함한다. 즉, 태그 게이트웨이들에 의해 태그들이 일단 설정되고 나면 이 태그들을 DPU 내의 다 른 하드웨어, 펌웨어 또는 소프트웨어 엔티티가 변경할 수 없다. 그러나, 다른 실시예에서는, DPU가 트러 스티드 태그(trusted tag) 및 언트러스티드 태그(untrusted tag)를 지원할 수 있다. DPU 내의 다운스트 림 하드웨어 컴포넌트들(예를 들어, DPE들) 각각은 트러스티드 태그와 언트러스티드 태그를 구별할 수 있 다. 일 실시예에서, 언트러스티드 태그들은 더 낮은 수준의 서비스(예를 들어, 더 낮은 비용 또는 무료)를 수용하고 또한 노이지 이웃(noisy neighbor) 또는 노지 이웃(nosey neighbor) 효과들을 받게 되는 것을 수용하는 테넌트 들에게 할당된다. 예를 들어, 클라우드 서비스 프로바이더는 교육 기관에 매우 낮은 수준의 서비스나 무료 수 준의 서비스를 제공할 수 있다. 이러한 교육 기관들은 학생들이 연구 애플리케이션들을 실행할 수 있도록 하기 위한 계산, 저장 및 네트워킹 리소스들을 제공받는다. 교육 기관 테넌트에는 최선의 노력을 제공하지만(또는 계산 능력을 남겨두지만) 테넌트들이 할당했던 트러스티드 태그들과 동일한 데이터 격리 수준을 갖지 못하는 언 트러스티드 태그가 할당된다. 다른 예에서, 언트러스티드 태그는 또한 암호화 엔진들/가속기들을 우회함으로써 이러한 서비스들을 교육 기관 테넌트에 제공하는데 있어서 클라우드 서비스 프로바이더 전력 및 비용을 절약하 기 위해 DPU에서 사용될 수 있다. 태깅되고 나면, 데이터는 복수의 DPE들을 포함하는 파이프라인에 제공된다. DPE들은 AI 엔진들 /가속기들, 데이터베이스 엔진들/가속기들, 암호화 엔진들/가속기들, 압축 엔진들/가속기들 등일 수 있다. DPE 들은 강화된 회로부, 프로그래밍 가능 로직(programmable logic; PL), 또는 이들 모두의 조합으로 형성될 수 있다. 일 실시예에서, DPU 내의 DPE들은 모두 동일한 타입의 엔진 또는 가속기일 수 있다. 예를 들어, DPU는 호스트와 네트워크 사이에서 전송되는 데이터와 연관된 AI 태스크들을 가속화하도록 설계 될 수 있다. 이 경우, 모든 DPE들은 AI 엔진들일 수 있다. 즉, DPE들은 동질적일 수 있다. 대안적 으로는, DPE들이 이질적일 수도 있으며, 여기서 DPE(120A)는 DMA 엔진일 수 있고, DPE(120B)는 암호화 엔 진일 수도 있는 등으로 구성된다. 도 1에서, DPE들은 데이터가 다수의 DPE들에 의해 순차적으로 프로세싱될 수 있도록 파이프라인 내에 배열되지만, 이것은 단지 하나의 예일뿐이다. 예를 들어, 하나의 테넌트에 대한 데이터는 DPE(120A 및 120B)를 통과할 수 있는 반면, 다른 테넌트에 대한 데이터는 DPE(120A)에 의해서만 프로세싱되고, DPE(120B)에 의해서는 프로세싱되지 않을 수 있다. 일반적으로, DPU는 임의의 수의 DPE들을 가질 수 있으며, 여 기서 특정 테넌트는 DPE들의 데이터가 DPU를 통해 전송될 때 DPE들의 모두를 사용하거나, 그 서 브세트를 사용하거나, 또는 그 어느 것도 사용하지 않을 수 있다. DPE들은 상이하게 태깅된 데이터가 DPE에 의해 어떻게 프로세싱되어야 하는지를 정의하는 태그 정책 들을 포함한다. 달리 말하면, 태그 정책들은 DPE가 DPU를 사용할 수 있는 테넌트들 각각에 대한 데이터를 어떻게 프로세싱해야 하는지를 나타낸다. 예를 들어, 태그 정책(125A)은 테넌트 A에 대해 태 깅된 데이터가 DPE(120A) 내의 하드웨어 리소스들의 최대 25%를 사용할 수 있어야 함을 나타낼 수 있다. 따라 서, DPE(120A)가 테넌트 A로부터 트래픽 버스트를 수신하는 경우, 이것이 이용 가능한 미사용 리소스들을 갖고 있더라도, 태그 정책(125A)은 DPE가 테넌트 A의 트래픽을 프로세싱하기 위해 리소스들의 25%를 초과하여 제공하는 것을 방지한다. 이에 따라, 짧은 시간 후에 DPE(120A)가 DPE(120A)의 리소스들의 최대 75%까지 제공 되어야 하는 테넌트 B로부터의 트래픽 버스트를 수신하는 경우, 그러한 리소스들이 테넌트 B에 즉시 이용 가능 하다. 이 예에서, 태그들 및 태그 정책들은 노이지 이웃(예를 들어, 테넌트 A)이 테넌트 B에 대해 사용되 어야 하는 리소스들을 사용하는 것을 방지한다. 또한, 태그 정책들은 테넌트들이 서로의 데이터에 액세스할 수 없는 테넌트 격리를 제공할 수 있다. 예를 들어, DPU는 테넌트들의 데이터를 저장하는 메모리(도시되지 않음)를 포함할 수 있다. 테넌트 B에 대한 데이터를 프로세싱하는 동안, DPE가 테넌트 A에 대한 데이터에 액세스하려고 시도하면, 태그 정책은 그 시 도를 중지시킬 수 있다. 이것은 하나의 테넌트가 공유 리소스(DPU 또는 DPU 내의 하드웨어 컴포넌트 들) 상의 다른 테넌트에 대한 데이터에 액세스하려고 시도할 수 있는 노이지 이웃 상황을 방지한다. 그러나, 태그 정책들은 일부 테넌트들이 다른 테넌트들에 대한 데이터에 액세스할 수 있음을 나타낼 수도 있다. 예를 들어, 테넌트들 A 및 B는 동일한 고객에 의해 사용되는 가상 머신일 수 있는 반면, 테넌트 C는 상이한 고 객에 대한 가상 머신일 수 있다. 태그 정책들은 테넌트들 A 및 B가 서로 데이터를 공유하는 것을 허용할 수 있지만, 테넌트들 A 및 B가 테넌트 C의 데이터에 액세스하는 것을 허용하지 않을 수 있으며, 그 반대도 가능 하다. DPE들에 대한 태그 정책들은 동일하거나 상이할 수 있다. 예를 들어, DPE(120A)에 대한 태그 정책 (125A)은 DPE(120B)에 대한 태그 정책(125B)과 상이할 수 있다. 예를 들어, 태그 정책들은 테넌트 A에게 DPE(120B)보다 더 큰 DPE(120A)에서의 하드웨어 리소스들의 공유를 제공할 수 있다. 트러스티드 엔티티는 또한 태그 정책들을 구성하는 임무를 가질 수도 있다. 일 실시예에서, 오직 트 러스티드 엔티티만이 태그 정책들을 구성 및 변경할 수 있다. 이것은 악의적인 행위자가 태그 정책 들에 의해 설정된 보안 및 성능 격리를 변경하는 것을 방지한다. 또한, 도 1이 DPU의 일부로서 트러 스티드 엔티티를 예시하고 있지만, 다른 실시예들에서는, 트러스티드 엔티티가 DPU의 외부에 있 을 수도 있으며, 위에서 설명된 기능들을 수행하기 위해 DPU에 대한 검증된 통신 경로를 가질 수 있다. DPU의 원격 인터페이스는 네트워크로부터 수신된 데이터를 태깅하는 태그 게이트웨이(115B)를 포함한 다. 로컬 인터페이스 및 태그 게이트웨이(115A)와 마찬가지로, 게이트웨이(115B)는 물리적 속성들을 사용하여 테넌트들을 식별하고, 데이터가 수신된 포트와 같은 데이터를 태깅할 수 있다. 대안적으로 또는 추가적으로, 게이트웨이(115B)는 수신된 데이터를 태깅하기 위해, IP 어드레스들, 소스/목적지 정보, 트래픽 흐름 식별자들 등과 같은 데이터 내의 속성들을 사용할 수 있다. 따라서, 게이트웨이(115B)는 동일한 포트 상에서 수신된 상 이한 트래픽 흐름들이 상이한 테넌트들로서 식별될 수 있는 논리적 태깅을 수행할 수 있다. 일반적으로, 게이트웨이들 및 태그 정책들에 의해 수행되는 태깅은 데이터가 호스트로부터 네트 워크로 그리고 네트워크로부터 호스트로 흐를 때 각각의 테넌트에 대한 엔드-투-엔드 바인딩을 생성한다. 또한, 반대 방향들로 이동하는 데이터가 동일한 테넌트와 연관될 수도 있으며, 따라서 DPU에 대한 인터페이스들이 서로 다른 프로토콜들을 사용하더라도, 동일한 태그가 할당될 수 있다. 예를 들어, 네트 워크로부터 DPU에서 수신된 특정 트래픽 흐름은 호스트로부터 DPU에서 수신된 데이터와 동 일한 테넌트의 일부일 수 있다. 태그 바인딩들은 동일한 태그에 대하여 서로 다른 속성들을 링크시킬 수 있다. 예를 들어, 태그 게이트웨이(115A)는 PCIe 프로토콜에 의해 정의된 특정 ID를 가진 모든 데이터를 태그 A로 태 깅할 수 있는 반면, 게이트웨이(115B)는 특정 IP 어드레스를 가진 모든 데이터를 태그 A로 태깅한다. 따라서, 동일한 테넌트에 대한 데이터가 서로 다른 통신 프로토콜들을 사용하여 DPU에 통신될 수 있지만, 태그 게 이트웨이들 내의 태그 바인딩들은 그럼에도 불구하고 데이터에 동일한 태그를 할당함으로써, 데이터가 동 일한 테넌트에 대한 것임을 나타내기 위해 서로 다른 속성들을 사용할 수 있다. 따라서, 동일한 테넌트에 대한 데이터는 DPU를 통해 데이터가 어느 방향으로 흐르는지에 관계없이 동일한 태그를 할당받을 수 있다. 도 2는 일 실시예에 따른, 시스템 온 칩(SoC)으로서 구현되는 DPU를 예시한다. SoC(예를 들어, 집적 회로(IC))는 태그 게이트웨이들, DPE들, 및 트러스티드 엔티티를 포함할 수 있다. 또한, 도 2 는 트러스티드 엔티티에 의해 생성될 수 있는 태그 게이트웨이들 내의 태그 바인딩들을 예시한 다. 위에서 논의된 바와 같이, 태그 바인딩들은 SoC에 의해 호스트 또는 네트워크로부터 수신된 데이터 내의 속성들을 특정 태그에 연관시키거나 링크시킬 수 있다. 예를 들어, 태그 게이트웨이는 ID, 소 스, 목적지, 어드레스 공간, IP 어드레스 등을 식별할 수 있으며, 이 속성을 사용하여 바인딩들에 인덱싱 함으로써 데이터에 대한 태그를 식별하도록 할 수 있다. 일 실시예에서, 각각의 테넌트는 서로 다른 태그를 할 당받을 수 있지만, 서로 다른 트래픽 흐름들은 이들 흐름들이 동일한 테넌트의 일부인 경우 동일한 태그를 할당 받을 수 있다. 게이트웨이들(115A 및 115B)에 의해 사용되는 인터페이스들이 서로 다른 통신 프로토콜들(예를 들어, 게이트웨 이(115A)에 대한 PCIe, CXL 또는 CCIX 및 게이트웨이(115B)에 대한 이더넷)을 사용할 수 있기 때문에 태그 바인 딩들(205A)은 태그 바인딩들(205B)과 다른 속성들을 포함할 수 있다. 이 예에서, DPE들은 태그 정책들을 적용하는 래퍼(wrapper)들(예를 들어, 하드웨어 회로들)을 포함한다. 예를 들어, DPE에서 수신된 데이터를 프로세싱하기 전에, 데이터는 대응하는 래퍼를 먼저 통과한다. 그런 다음, 래퍼는 DPE가 상이하게 태깅된 데이터에 액세스하지 않는 것을 보장하거나, 또는 DPE가 데이터를 프로세싱하기 위해 필요한 것보다 더 많은 리소스들을 할당하지 않는 것을 보장하는 것과 같은, 태깅된 데이터에 대한 정책을 적용할 수 있다. 예를 들어, DPE가 수신된 태깅 데이터를 프로 세싱하도록 허용된 것보다 더 많은 리소스들을 소모할 것이라고 래퍼가 결정하는 경우(예를 들어, 래퍼 가 특정 테넌트로부터 데이터 버스트를 수신하는 경우), 래퍼는 DPE가 태그 정책들에 따라 데이 터를 프로세싱하기 위해 필요한 것보다 더 많은 리소스들을 소모하지 않도록 데이터의 일부를 차단할 수 있다 (또는 데이터를 스로틀링). 그러나, 태그 정책들을 적용하기 위해 랩퍼들을 사용하는 것은 단지 일 예일뿐이다. 다른 실시예들에서, DPE들은 태그 정책들을 저장하는 테이블들을 포함할 수 있다. DPE들은 태그들을 사용하여 테이 블들에 인덱싱함으로써 해당 태그에 대한 특정 정책을 식별하도록 할 수 있다. 또 다른 실시예에서, 트러스티드 엔티티는 DPE들을 특정 테넌트들에 정적으로 할당할 수 있다. 예를 들어, 테넌트 A에는 2개의 DPE가 할당되는 반면, 테넌트 B에는 4개의 DPE가 할당될 수 있다. 태그들은 테넌트 A의 데이터만 그것의 할당된 2개의 DPE로 라우팅하는 반면 테넌트 B의 데이터만이 그것의 4개의 DPE로 라우팅되 도록 하는 데 사용될 수 있다. 다른 예에서, SoC는 DPE들의 다수의 병렬 파이프라인들을 포함할 수 있으 며, 여기서 각각의 파이프라인은 특정 테넌트에 정적으로 할당될 수 있다 - 예를 들어, 테넌트 A의 데이터는 제 1 파이프라인에 의해서만 프로세싱되고, 테넌트 B의 데이터는 제2 파이프라인에 의해서만 프로세싱되며, 또한 테넌트 C의 데이터는 제3 및 제4 파이프라인에 의해서만 프로세싱된다. SoC는 또한 게이트웨이들과 DPE들 사이 및 DPE들 사이의 통신을 용이하게 하는 네트워크 온 칩(network on chip; NoC)을 포함한다. 도시되지는 않았지만, NoC는 데이터 격리를 제공하고 태 깅된 테넌트 데이터에 대한 성능 요건들을 만족시키기 위한 태그 정책을 포함할 수 있다. 그러나, NoC는 선택 사항이다. 도 2가 단일 IC를 포함할 수 있는 DPU의 SoC 구현예를 예시하고 있지만, 다른 실시예들에서, DPU는 다수의 IC들 을 사용하여 구현될 수도 있다. 예를 들어, DPU는 도 2에 예시된 하드웨어 컴포넌트들 중 일부뿐만 아니라 나 머지 하드웨어 컴포넌트들을 포함하는 칩렛들을 포함하는 앵커 다이(anchor die)를 포함할 수 있다. 도 3은 일 실시예에 따른, DPU에서 엔드-투-엔드 바인딩들을 설정하기 위한 방법의 흐름도이다. 블록 에서, 트러스티드 엔티티(예를 들어, 도 1의 트러스티드 엔티티)는 통신 프로토콜의 외부 속성들에 대한 태그 바인딩들을 설정한다. 위에서 언급된 바와 같이, DPU는 호스트와 통신하기 위해 제1 통신 프로토콜 (예를 들어, PCIe 또는 CXL)을 사용하는 로컬 인터페이스 및 스위치와 같은 네트워크 디바이스와 통신하기 위해 제2 통신 프로토콜(예를 들어, TCP/IP 또는 UDP)을 사용하는 원격 인터페이스를 가질 수 있다. 상이한 통신 프로토콜들 때문에, 트러스티드 엔티티는 상이한 속성들에 의존하는 상이한 태그 바인딩들을 생성 할 수 있다. 따라서, 태그 바인딩들은 배포될 인터페이스들에 따라 맞춤화될 수 있다. 블록에서, 트러스티드 엔티티는 DPU의 태그 게이트웨이들에서 태그 바인딩들을 저장한다. 블록에서, 트러스티드 엔티티는 태그들에 대한 태그 정책들을 설정한다. 트러스트된 엔티티는 테넌트 데 이터를 프로세싱할 DPU 내의 모든 하드웨어 컴포넌트에 대한 태그 정책들을 생성할 수 있다. 태그 정책들은 각 각의 태그(즉, 각각의 테넌트)에 대한 데이터 격리 요건들을 설정할 수 있다. 격리 요건들은 테넌트들 간의 보 안 격리 및/또는 테넌트들 간의 성능 격리를 가능하게 할 수 있다.블록에서, 트러스티드 엔티티는 태그 정책들을 적용하도록 DPE들을 구성한다. 이것은 래퍼들, 테이블들을 이용하거나 또는 특정 태깅된 데이터에 특정 DPE들을 정적으로 할당하는 것과 같은 다양한 방식으로 행해질 수 있다. 또한, 본 명세서의 실시예들은 DPE들에 태그 정책들을 제공하는 것에 한정되지 않지만, DPU 내의 NoC들 또는 메모리 컨트롤러들도 또한 제공될 수 있다. 도 4는 일 실시예에 따른, 테넌트들에 태그들을 할당하고 DPU의 DPE들에서 데이터를 프로세싱하기 위해 이들 태 그들을 사용하기 위한 방법의 흐름도이다. 블록에서, DPU는 다수의 테넌트들로부터 데이터를 수신한 다. 일 실시예에서, 데이터는 데이터 패킷들을 포함하지만, 이것은 통신 프로토콜에 의존할 수 있다. 일 실시예에서, DPU는 2개의 상이한 인터페이스들 상에서 패킷들을 수신한다. 하나의 인터페이스는 하나 이상 의 호스트 컴퓨팅 시스템들(예를 들어, 도 1의 호스트)에 연결된 로컬 인터페이스일 수 있다. 다른 인터 페이스는 네트워크(예를 들어, 네트워크)의 하나 이상의 네트워크 디바이스들 부분에 연결된 원격 인터페 이스일 수 있다. 네트워크는 클라우드 서비스 프로바이더(CSP)의 데이터센터 네트워크와 같은 로컬 에어리어 네트워크(LAN) 또는 인터넷과 같은 와이드 에어리어 네트워크(WAN)일 수 있다. 일 실시예에서, 인터페이스들은 PCIe 또는 이더넷과 같은 서로 다른 통신 프로토콜들을 사용한다. 블록에서, DPU는 DPU에 데이터를 전송하는 테넌트들 각각에 대하여 서로 다른 태그를 할당한다. 예를 들 어, DPU 내의 태그 게이트웨이들은 수신된 데이터 내의 속성들을 평가하여 어느 테넌트가 데이터를 전송했는지 를 식별할 수 있다. 위에서 언급된 바와 같이, 테넌트는 물리적 컴퓨팅 시스템, 가상 머신 또는 컨테이너, 특 정 애플리케이션, 또는 데이터 센터 환경의 고객일 수 있다. 이와 같이, 테넌트들은 물리적 컴포넌트들(예를 들어, 상이한 포트들)에 대응할 수 있거나 또는 논리적 구성들(예를 들어, 동일한 가상 머신 또는 동일한 호스 트를 사용하는 상이한 고객들)일 수 있다. 데이터는 태그 게이트웨이가 데이터를 전송하는 테넌트에 대응하는 데이터에 대한 특정 태그를 식별하기 위해 사용할 수 있는, ID들, 소스/목적지 어드레스들, 포트 번호들, 메모 리 어드레스들 등과 같은 속성들을 포함할 수 있다. 그런 다음 태그 게이트웨이는 태그를 데이터에 추가할 수 있다. DPU는 다양한 서로 다른 통신 프로토콜들을 사 용하여 내부적으로 데이터를 전송할 수 있다. 프로토콜에 관계없이, DPU는 DPE들, DMA 컨트롤러, 메모리 컨트 롤러들, NoC 등과 같은 내부 하드웨어 컴포넌트들이 태그들을 식별하고, 데이터와 함께 제공된 태그에 기초하여 데이터에 대한 일부 동작을 수행할 수 있도록 태그가 데이터와 함께 유지되는 것을 보장할 수 있다. 블록에서, DPU 내의 하드웨어 컴포넌트들(예를 들어, DPE들)은 다수의 테넌트들에 대한 데이터가 프로세싱 될 때 상이한 태그 정책들을 적용한다. 예를 들어, DPE들은 블록에서 할당된 태그를 사용하여 대응하는 태그 정책을 적용하는 래퍼들 또는 정책 테이블들을 포함할 수 있다. 일 실시예에서, 태그 정책은 노지 및 노 이지 이웃들(즉, 테넌트들)을 방지하기 위해 정의될 수 있다. 블록은 노지 및 노이지 이웃들을 방지하기 위해 2개의 서브-블록들을 포함할 수 있다. 블록에서, DPE들은 테넌트들에 대한 데이터를 격리한다. 즉, 테넌트 A에 대한 데이터를 프로세싱할 때, 태그 정책은 DPE 가 다른 테넌트에 대한 데이터에 액세스하는 것을 방지할 수 있다. 또는, 태그 정책은 테넌트 A가 테넌트 B에 대한 데이터에 액세스할 수 있지만 테넌트 C에 대한 데이터에는 액세스할 수 없음을 나타낼 수도 있다. 블록에서, DPE들은 테넌트들에 대한 성능 표준들이 충족되는 것을 보장한다. 예를 들어, DPE들은, DPE에 현재 미사용된 하드웨어 리소스들이 있더라도, 테넌트 A가 자신의 하드웨어 리소스들의 33%보다 많이 사용하는 것을 방지할 수 있다. 이러한 방식으로, DPE가 상이한 테넌트에 대한 데이터를 수신하는 경우, DPE는 이용 가 능한 하드웨어 리소스들을 갖는다. 노지 및 노이지 이웃들을 처리하기 위한 다양한 전략들이 도 5 및 도 6에서 논의된다. 도 5 및 도 6은 여러 실시예들에 따른, 태그들을 사용하여 테넌트들 간의 리소스들을 공유하는 것을 예시한다. 도 5는 DPE들이 테넌트들에 대한 원하는 성능 표준들을 충족시킬 수 있도록 보장하기 위해 태그 정책들을 사용 하는 DPE들의 파이프라인을 예시한다. 파이프라인은 각각의 하드웨어 리소스들(505A-C)을 갖는 DPE 들(120A-C)을 포함한다. DPE(120A)는 테넌트 A가 자신의 하드웨어 리소스들(505A)의 최대 66%에서 액세스할 수 있는 반면 테넌트 B는 하드웨어 리소스들(505A)의 최대 34%에서 액세스할 수 있는 것을 보장한다. DPE(120B)는 테넌트 A가 자신의 하드웨어 리소스들(505B)의 최대 66%에서 액세스할 수 있는 반면 테넌트 B는 하드웨어 리소 스들(505B)의 최대 34%에서 액세스할 수 있는 것을 보장한다. DPE(120C)는 테넌트 A가 자신의 하드웨어 리소스 들(505C)의 최대 50%에서 액세스할 수 있는 반면 테넌트 B는 하드웨어 리소스들(505C)의 최대 50%에서 액세스할 수 있는 것을 보장한다. 이러한 하드웨어 할당들은 태그 정책들에 의해 설정될 수 있다. 특히, DPE(120C)는테넌트 A 및 B에 대하여 DPE들(120A 및 120B)과 다르게 자신의 하드웨어 리소스들(505C)을 할당하기 때문에, DPE들 각각에 대한 태그 정책들은 동일할 필요가 없다. 테넌트가 DPE에서 리소스들의 최대 할당을 초과할 수 없도록 보장하는 것을 통해, 하나의 테넌트가 DPE에서 리 소스들의 대부분 또는 전부를 사용한 다음 다른 테넌트에 대한 데이터가 DPE에 도착할 때에, 어떠한 이용 가능 한 하드웨어 리소스도 갖지 않게 됨으로써, 해당 테넌트가 더 높은 우선 순위 데이터를 가질 수 있음에도 불구 하고 그 테넌트의 데이터가 대기하도록 강제하게 되는 노이지 이웃 문제를 방지한다. 그러나, 테넌트 데이터를 식별하기 위해 태그들을 사용함으로써, 하드웨어 리소스들이 우선 순위에 따라 파티셔닝될 수 있으며, 이 에 의해 DPE들이 상이한 테넌트들에 대한 이용 가능한 리소스들을 갖는 것을 보장할 수 있다. 도시되지는 않았지만, 노지 이웃은 테넌트 A 데이터를 프로세싱하는 하드웨어 리소스들이 테넌트 B의 데이터에 액세스하는 것을 방지하며 그 반대의 경우도 가능한 방화벽들 또는 제어 정책들을 갖는 DPE들에 의해 해결 될 수 있다. 도 6은 각각의 DPE들을 갖는 다수의 DPE 파이프라인들(600A-C)을 예시한다. 즉, 파이프라인(600A)은 DPE들 (120D-F)을 포함하고, 파이프라인(600B)은 DPE들(120G-I)을 포함하며, 또한 파이프라인(600C)은 DPE들(120J- L)을 포함한다. 일 실시예에서, 파이프라인들 내의 DPE들은 동일하며, 이에 따라 파이프라인들은 동 일한 태스크(예를 들어, 디지털 신호 프로세싱 태스크 또는 기계 학습 태스크)를 수행할 수 있다. 즉, 각각의 파이프라인은 동일한 3개의 DPE들(3개의 동일한 타입의 DPE 또는 상이한 타입들의 DPE들의 조합일 수 있음)을 포함할 수 있다. DPE들 내의 하드웨어 리소스들을 분할하는 대신에, 이 실시예에서는, 트러스티드 엔티티가 각각의 파이프라인 을 각각의 테넌트에 할당할 수 있다. 즉, 테넌트 A에 대한 데이터는 파이프라인(600A)에 의해서만 프로세 싱되는 반면, 테넌트 B에 대한 데이터는 파이프라인들(600B 및 600C)에 의해서만 프로세싱된다. 따라서, 테넌 트 B에 대한 데이터는 테넌트 A에 대한 데이터보다 2배의 프로세싱 대역폭을 갖는다. 이러한 방식으로, 각각의 DPE는 하나의 테넌트에 전용되거나 할당될 수 있다. 그렇게 함으로써, 각각의 파이프라인이 단일 테 넌트로 제한되기 때문에 노이지 및 노지 이웃 문제들이 해결된다. 또한, 하나의 테넌트는 더 높은 우선 순위 테넌트(이 예에서는 테넌트 B)에 더 많은 파이프라인들을 할당함으로써 다른 테넌트보다 우선 순위화될 수 있다. 상술한 내용에서, 본 개시에서 제시된 실시예들을 참조한다. 그러나, 본 개시의 범위는 특정의 설명된 실시예 에 한정되지 않는다. 대신, 설명된 특징 및 요소의 임의의 조합은 상이한 실시예와 관련이 있든 없든 고려된 실시예를 구현하고 실시하기 위해 고려된다. 또한, 본 명세서에 개시된 실시예가 다른 가능한 해결책이나 종래 기술에 비해 이점을 달성할 수 있지만, 주어진 실시예에 의해 특정 이점이 달성되는지 여부는 본 개시의 범위를 한정하지 않는다. 따라서, 상술한 양태, 특징, 실시예 및 이점은 단지 예시적인 것일 뿐, 청구항(들)에 명확히 인용된 경우를 제외하고는 첨부된 청구항의 요소 또는 제한으로 간주되지 않는다. 당업자에 의해 이해되는 바와 같이, 본 명세서에 개시된 실시예는 시스템, 방법 또는 컴퓨터 프로그램 제품으로 구현될 수 있다. 따라서, 양태는 전적으로 하드웨어 구현, 전적으로 소프트웨어 구현(펌웨어, 상주 소프트웨어, 마이크로-코드 등을 포함) 또는 소프트웨어 및 하드웨어 양태를 조합한 구현의 형태를 취할 수 있 으며, 이는 모두 본 명세서에서 일반적으로 \"회로\", \"모듈\" 또는 \"시스템\"으로 지칭될 수 있다. 또한, 양태는 컴퓨터 판독 가능 프로그램 코드가 구현된 하나 이상의 컴퓨터 판독 가능 매체(들)에 구현된 컴퓨터 프로그램 제품의 형태를 취할 수 있다. 하나 이상의 컴퓨터 판독 가능 매체(들)의 임의의 조합이 이용될 수 있다. 컴퓨터 판독 가능 매체는 컴퓨터 판 독 가능 신호 매체 또는 컴퓨터 판독 가능 저장 매체일 수 있다. 컴퓨터 판독 가능 저장 매체는 예를 들어 전 자, 자기, 광학, 전자기, 적외선 또는 반도체 시스템, 장치 또는 디바이스 또는 이들의 임의의 적절한 조합일 수 있지만 이에 한정되지 않는다. 컴퓨터 판독 가능 저장 매체의 보다 구체적인 예(비포괄적인 목록)는 다음을 포함할 것이다: 하나 이상의 와이어를 갖는 전기 연결, 휴대용 컴퓨터 디스켓, 하드 디스크, 랜덤 액세스 메모 리(RAM: random access memory), 판독-전용 메모리(ROM: read-only memory), 소거 가능 프로그래밍 가능 판독- 전용 메모리(EPROM 또는 플래시 메모리), 광섬유, 휴대용 컴팩트 디스크 판독-전용 메모리(CD-ROM), 광학 저장 디바이스, 자기 저장 디바이스 또는 이들의 임의의 적절한 조합. 본 명세서의 맥락에서, 컴퓨터 판독 가능 저 장 매체는 명령 실행 시스템, 장치 또는 디바이스에 의해 사용되거나 이와 관련하여 사용하기 위한 프로그램을 포함하거나 저장할 수 있는 임의의 유형(tangible)의 매체이다.컴퓨터 판독 가능 신호 매체는 예를 들어, 기저 대역에서 또는 캐리어 파의 일부로서 내부에 구현된 컴퓨터 판 독 가능 프로그램 코드를 갖는 전파된 데이터 신호를 포함할 수 있다. 이러한 전파된 신호는 전자기, 광학 또 는 이들의 임의의 적절한 조합을 포함하되 이에 한정되지 않는 임의의 다양한 형태를 취할 수 있다. 컴퓨터 판 독 가능 신호 매체는 컴퓨터 판독 가능 저장 매체가 아니고 명령 실행 시스템, 장치 또는 디바이스에 의해 사용 되거나 이와 관련하여 사용하기 위한 프로그램을 통신, 전파 또는 전송할 수 있는 임의의 컴퓨터 판독 가능 매 체일 수 있다. 컴퓨터 판독 가능 매체 상에 구현된 프로그램 코드는 무선, 유선, 광섬유 케이블, RF 등 또는 이들의 임의의 적 절한 조합을 포함하되 이에 한정되지 않는 임의의 적절한 매체를 사용하여 전송될 수 있다. 본 개시의 양태에 대한 연산을 수행하기 위한 컴퓨터 프로그램 코드는 Java, Smalltalk, C++ 등과 같은 객체 지 향 프로그래밍 언어와 \"C\" 프로그래밍 언어 또는 유사한 프로그래밍 언어와 같은 통상의 절차적 프로그래밍 언 어를 포함하여 하나 이상의 프로그래밍 언어의 임의의 조합으로 쓰여질 수 있다. 프로그램 코드는 전적으로 사 용자의 컴퓨터 상에서, 부분적으로 사용자의 컴퓨터 상에서, 독립형 소프트웨어 패키지로서, 부분적으로 사용자 의 컴퓨터 상에서 그리고 부분적으로 원격 컴퓨터 상에서 또는 전적으로 원격 컴퓨터 또는 서버 상에서 실행될 수 있다. 후자의 시나리오에서, 원격 컴퓨터는 로컬 에어리어 네트워크(local area network; LAN) 또는 와이드 에어리어 네트워크(wide area network; WAN)를 포함하여 임의의 타입의 네트워크를 통해 사용자의 컴퓨터에 연 결될 수 있거나, (예를 들어, 인터넷 서비스 프로바이더를 사용하는 인터넷을 통해) 외부 컴퓨터에 연결될 수 있다. 본 개시의 양태는 이러한 개시에 제시된 실시예에 따른 방법, 장치(시스템) 및 컴퓨터 프로그램 제품의 흐름도 예시 및/또는 블록도를 참조하여 아래에서 설명된다. 흐름도 예시 및/또는 블록도의 각각의 블록과 흐름도 예 시 및/또는 블록도의 블록의 조합은 컴퓨터 프로그램 명령에 의해 구현될 수 있음을 이해할 것이다. 이러한 컴 퓨터 프로그램 명령은 범용 컴퓨터, 특수 목적 컴퓨터 또는 다른 프로그래밍 가능 데이터 프로세싱 장치의 프로 세서에 제공되어 기계를 생성할 수 있어, 컴퓨터 또는 다른 프로그래밍 가능 데이터 프로세싱 장치의 프로세서 를 통해 실행되는 명령은 흐름도 및/또는 블록도 블록 또는 블록들에 특정된 기능/동작을 구현하기 위한 수단을 생성한다. 이러한 컴퓨터 프로그램 명령은 또한 컴퓨터, 다른 프로그래밍 가능 데이터 프로세싱 장치 또는 다른 디바이스 가 특정 방식으로 기능하도록 지시할 수 있는 컴퓨터 판독 가능 매체에 저장될 수 있어, 컴퓨터 판독 가능 매체 에 저장된 명령은 흐름도 및/또는 블록도의 블록 또는 블록들에 특정된 기능/동작을 구현하는 명령을 포함하는 제조품을 생성한다. 컴퓨터 프로그램 명령은 또한 컴퓨터, 다른 프로그래밍 가능 데이터 프로세싱 장치 또는 다른 디바이스에 로딩 되어 컴퓨터, 다른 프로그래밍 가능 장치 또는 다른 디바이스 상에서 일련의 연산 단계가 수행되게 하여 컴퓨터 구현 프로세스를 생성하도록 할 수 있어, 컴퓨터 또는 다른 프로그래밍 가능 장치 상에서 실행되는 명령은 흐름 도 및/또는 블록도의 블록 또는 블록들에 특정된 기능/동작을 구현하기 위한 프로세스를 제공한다. 도면의 흐름도 및 블록도는 본 발명의 다양한 예에 따른 시스템, 방법 및 컴퓨터 프로그램 제품의 가능한 구현 의 아키텍처, 기능 및 연산을 예시한다. 이와 관련하여, 흐름도 또는 블록도의 각각의 블록은 특정된 논리적 기능(들)을 구현하기 위한 하나 이상의 실행 가능한 명령을 포함하는 모듈, 세그먼트 또는 명령의 일부를 나타 낼 수 있다. 일부 대안적인 구현예에서, 블록에 표기된 기능은 도면에 표기된 순서와 다르게 일어날 수 있다. 예를 들어, 연속적으로 도시된 두 개의 블록들은 실제로 실질적으로 동시에 실행될 수 있거나, 블록은 관련 기 능에 따라 때로는 역순으로 실행될 수 있다. 또한, 블록도 및/또는 흐름도 예시의 각각의 블록과 블록도 및/또 는 흐름도 예시의 블록의 조합은 특정된 기능 또는 동작을 수행하거나 특수 목적 하드웨어와 컴퓨터 명령의 조 합을 수행하는 특수 목적 하드웨어-기반 시스템에 의해 구현될 수 있다는 점에 유의한다. 위에 개시된 기술은 다음의 비제한적인 예들로 표현될 수 있다. 예 1. 멀티 테넌트 인식 데이터 프로세싱 유닛(DPU)으로서, 호스트에 연결되도록 구성되는 제1 태그 게이트웨이; 네트워크에 연결되도록 구성되는 제2 태그 게이트웨이 - 제1 및 제2 태그 게이트웨이들은 서로 다 른 테넌트들로부터 수신된 데이터에 서로 다른 태그들을 할당하도록 구성됨 -, 및 수신된 데이터를 프로세싱할 때, 서로 다른 태그들에 기초하여, 서로 다른 태그 정책들을 적용하도록 구성되는 복수의 DPE들을 포함하는, 멀 티 테넌트 인식 DPU. 예 2. 예 1에 있어서, 데이터는 제2 태그 게이트웨이에서 수신된 데이터에 의해 사용되는 제2 통신 프로토콜과 상이한 제1 통신 프로토콜을 사용하여 제1 태그 게이트웨이에서 수신되는, DPU. 예 3. 예 2에 있어서, 제1 태그 게이트웨이는 태그들을 할당할 때 제1 통신 프로토콜과 연관된 제1 속성을 평가 하도록 구성되고, 제2 태그 게이트웨이는 태그들을 할당할 때 제2 통신 프로토콜과 연관된 제2 속성을 평가하도 록 구성되며, 제1 속성의 제1 값 및 제2 속성의 제2 값은 동일한 태그와 연관됨으로써 제1 및 제2 값들이 동일 한 테넌트와 연관됨을 나타내는, DPU. 예 4. 예 1에 있어서, 태그들은 DPU를 통해 엔드-투-엔드 바인딩을 제공함으로써, 특정 태그에 대해, 복수의 DPE들이 동일한 태그 정책을 적용하도록 하는, DPU. 예 5. 예 1에 있어서, 태그들은 스푸핑 가능하지 않고 복수의 DPE들에 의해 변경될 수 없으며, 태그들의 제1 부 분은 복수의 DPE들에 의한 트러스티드 태그들이고, 태그들의 제2 부분은 복수의 DPE들에 의한 언트러스티드 태 그들인, DPU. 예 6. 예 1에 있어서, (i) 수신된 데이터에 태그들을 할당하는 데 사용되는 제1 및 제2 태그 게이트웨이들에서 태그 바인딩들을 설정하고, (ii) 복수의 DPE들 각각에서 서로 다른 태그 정책들을 구성하도록 구성되는 트러스 티드 엔티티를 더 포함하는, DPU. 예 7. 예 1에 있어서, 복수의 DPE들은 서로 다른 태그 정책들을 적용하는 각각의 래퍼들을 포함하는, DPU. 예 8. 예 1에 있어서, 서로 다른 태그 정책들은 제1 테넌트가 제2 테넌트보다 복수의 DPE들 중 제1 DPE에서 하 드웨어 자원들의 더 큰 최대 공유를 할당받는다는 것을 나타내는, DPU. 예 9. 예 1에 있어서, 서로 다른 태그 정책들은 제1 테넌트가 제2 테넌트보다 복수의 DPE들 중 더 많은 수의 전 용 DPE들을 할당받는다는 것을 나타내는, DPU. 예 10. 예 1에 있어서, DPU는 스마트 네트워크 인터페이스 컨트롤러(SmartNIC)로서 구현되는, DPU. 예 11. 멀티 테넌트 인식 데이터 프로세싱 유닛(DPU)으로서, DPU의 로컬 인터페이스에 연결되는 제1 태그 게이 트웨이; DPU의 원격 인터페이스에 연결되는 제2 태그 게이트웨이 - 제1 및 제2 태그 게이트웨이들은 DPU에서 서 로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태그들을 할당하도록 구성됨 -; 및 (i) 서로 다른 테넌트들 로부터 수신된 데이터를 격리하고 (ii) 테넌트들에 대한 성능 표준들이 충족되는 것을 보장하기 위해, 수신된 데이터를 프로세싱할 때, 서로 다른 태그들에 기초하여, 서로 다른 태그 정책들을 적용하도록 구성되는 복수의 데이터 프로세싱 엔진(DPE)들을 포함하는, DPU. 예 12. 예 11에 있어서, 데이터는 제2 태그 게이트웨이에서 수신된 데이터에 의해 사용되는 제2 통신 프로토콜 과 상이한 제1 통신 프로토콜을 사용하여 제1 태그 게이트웨이에서 수신되는, DPU. 예 13. 예 12에 있어서, 제1 태그 게이트웨이는 태그들을 할당할 때 제1 통신 프로토콜과 연관된 제1 속성을 평 가하도록 구성되고, 제2 태그 게이트웨이는 태그들을 할당할 때 제2 통신 프로토콜과 연관된 제2 속성을 평가하 도록 구성되며, 제1 속성의 제1 값 및 제2 속성의 제2 값은 동일한 태그와 연관됨으로써 제1 및 제2 값들이 동 일한 테넌트와 연관됨을 나타내는, DPU. 예 14. 예 11에 있어서, 태그들은 DPU를 통해 엔드-투-엔드 바인딩을 제공함으로써, 특정 태그에 대해, 복수의 DPE들이 동일한 태그 정책을 적용하도록 하는, DPU. 예 15. 방법으로서, 데이터 프로세싱 유닛(DPU)의 제1 태그 게이트웨이에서 복수의 테넌트들로부터 데이터를 수 신하는 단계; 복수의 테넌트들 중 서로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태그들을 할당하는 단 계; 및 복수의 테넌트들로부터의 태깅된 데이터가 DPU 내의 데이터 프로세싱 엔진(DPE)들에 의해 프로세싱될 때 서로 다른 태그 정책들을 적용하는 단계를 포함하는, 방법. 예 16. 예 15에 있어서, DPU의 제2 태그 게이트웨이에서 상기 복수의 테넌트들로부터 데이터를 수신하는 단계; 제2 태그 게이트웨이를 사용하여 복수의 테넌트들 중 서로 다른 테넌트들로부터 수신된 데이터에 서로 다른 태 그들을 할당하는 단계 - 데이터는 제2 태그 게이트웨이에서 수신된 데이터에 의해 사용되는 제2 통신 프로토콜 과 상이한 제1 통신 프로토콜을 사용하여 제1 태그 게이트웨이에서 수신됨 - 를 더 포함하는, 방법. 예 17. 예 16에 있어서, 제1 태그 게이트웨이는 태그들을 할당할 때 제1 통신 프로토콜과 연관된 제1 속성을 평 가하고, 제2 태그 게이트웨이는 태그들을 할당할 때 제2 통신 프로토콜과 연관된 제2 속성을 평가하며, 제1 속 성의 제1 값 및 제2 속성의 제2 값은 동일한 태그와 연관됨으로써 제1 및 제2 값들이 동일한 테넌트와 연관됨을나타내는, 방법. 예 18. 예 15에 있어서, 태그들은 DPU를 통해 엔드-투-엔드 바인딩을 제공함으로써, 특정 태그에 대해, DPE들이 동일한 태그 정책을 적용하도록 하는, 방법. 예 19. 예 15에 있어서, 태그들은 스푸핑 가능하지 않으며, DPE들에 의해 변경될 수 없는, 방법. 예 20. 예 15에 있어서, 트러스티드 엔티티를 사용하여, 수신된 데이터에 태그들을 할당하는 데 사용되는 제1 태그 게이트웨이에서의 태그 바인딩들을 설정하는 단계; 및 트러스티드 엔티티를 사용하여, DPE들 각각에서 서 로 다른 태그 정책들을 구성하는 단계를 더 포함하는, 방법. 상술한 내용은 특정 예에 대한 것이지만, 그 기본 범위를 벗어나지 않고 다른 추가 예가 고안될 수 있으며, 그 범위는 후속하는 청구항에 의해 결정된다."}
{"patent_id": "10-2025-7006705", "section": "도면", "subsection": "도면설명", "item": 1, "content": "위에 인용된 특징이 상세히 이해될 수 있는 방식으로 위에 간략하게 요약된 보다 구체적인 설명이 예시적인 구 현예를 참조하여 제공될 수 있으며, 그 중 일부는 첨부 도면에 예시된다. 그러나, 첨부된 도면은 통상적이고 예시적인 구현예만을 예시하므로, 그 범위를 제한하는 것으로 간주되어서는 안 된다는 것에 유의해야 한다. 도 1은 일 실시예에 따른, 멀티 테넌트 인식 DPU를 포함하는 시스템을 예시한다. 도 2는 일 실시예에 따른, 시스템 온 칩(system on a chip)으로서 구현되는 DPU를 예시한다.도 3은 일 실시예에 따른, DPU에서 엔드-투-엔드 바인딩들을 설정하기 위한 흐름도이다. 도 4는 일 실시예에 따른, 테넌트들에 태그들을 할당하고 DPU 내의 DPE들에서 데이터를 프로세싱하기 위해 이들 태그들을 사용하기 위한 흐름도이다. 도 5 및 도 6은 여러 실시예들에 따른, 태그들을 사용하여 테넌트들 간에 리소스들을 공유하는 것을 예시한다. 이해를 용이하게 하기 위해, 가능한 경우 도면들에 공통된 동일한 요소들을 지정하기 위해 동일한 참조 번호들 이 사용되었다. 하나의 예의 요소들이 다른 예들에 유익하게 통합될 수 있는 것으로 고려된다."}
