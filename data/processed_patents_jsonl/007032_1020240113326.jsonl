{"patent_id": "10-2024-0113326", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0032986", "출원번호": "10-2024-0113326", "발명의 명칭": "클러스터 관리 방법 및 장치, 전자 디바이스 및 저장 매체", "출원인": "베이징 볼케이노 엔진 테크놀로지 씨오., 엘티디.", "발명자": "차오, 강"}}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "클러스터 관리 방법에 있어서,메타 클러스터에 의해, 워크 클러스터에 대한 추가 및 삭제 작업을 개시하는 단계, 및 상기 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 대응하는 클러스터 배치 또는 제거를 구현하기 위해 지정된 워크 클러스터를 제어하는 단계를 포함하고, 상기 워크 클러스터에 대한 상기 추가 및 삭제 작업은, 상기 지정된 워크 클러스터를 상기 클러스터 시스템에 추가하도록 명령하거나 상기 지정된 워크 클러스터를 상기 클러스터 시스템에서 삭제하도록 명령하는 데 사용되고, 상기 클러스터 시스템은, 적어도 하나의 클러스터를 포함하고, 상기 적어도 하나의 클러스터는, 상기 메타 클러스터 및 적어도 하나의 워크 클러스터를 포함하고, 상기 메타 클러스터는, 상기 클러스터 시스템의 운영 및 유지 관리 제어를 실행하도록 구성되고, 상기 운영 및 유지 관리 제어는, 워크 클러스터의 추가 및 삭제 처리를 포함하고, 상기 적어도 하나의 워크 클러스터 각각은, 비즈니스 작업을 수행하기 위해 비즈니스 컨테이너를 운반하는, 방법."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 메타 클러스터를 배치하기 위한 부트스트랩 환경을 초기화하는 단계, 클러스터-간 도메인 이름을 저장하기 위한 데이터베이스를 배치하고, 클러스터-간 도메인 이름 확인 서비스 제공하기 위한 도메인 이름 확인 서버를 배치하고, 및 자동화된 운영 및유지관리 도구와 원격 실행 엔진을 배치하는 단계, 및 상기 메타 클러스터의 부트스트랩 배치를 수행하는 단계를 더 포함하는, 공개특허 10-2025-0032986-3-방법."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 추가 및 삭제 작업의 명령 정보는, 클러스터 추가 명령 정보를 포함하고, 상기 클러스터 추가 명령 정보는, 제1 워크 클러스터를 새로 추가하도록 명령하는 데 사용되고, 및 상기 추가 및 삭제 작업의 명령 정보에 따라 상기 클러스터 시스템에서 대응하는 클러스터 배치 또는 제거를 구현하기 위해 상기 지정된 워크 클러스터를 제어하는 단계는, 상기 클러스터 추가 명령 정보에 따라 상기 제1 워크 클러스터와 상기 메타 클러스터 간에 비밀번호 없이 상호통신을 구현하기 위해 사전 배치 운영을 수행하는 단계, 상기 제1 워크 클러스터를 기반으로 후속 원격 운영 및 유지 관리를 위한 원격 실행 엔진을 구축하는 단계, 및 상기 제1 워크 클러스터의 부트스트랩 배치를 수행하는 단계를 포함하는, 방법."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 추가 및 삭제 작업의 명령 정보는, 클러스터 삭제 명령 정보를 포함하고, 상기 클러스터 삭제 명령 정보는, 제2 워크 클러스터를 제거하도록 명령하는 데 사용되고, 및 상기 추가 및 삭제 작업의 명령 정보에 따라 상기 클러스터 시스템에서 대응하는 클러스터 배치 또는 제거를 구현하기 위해 상기 지정된 워크 클러스터를 제어하는 단계는, 상기 클러스터 삭제 명령 정보에 따라 정리 프로그램을 원격으로 실행하여 상기 제2 워크 클러스터의 모든 컴포넌트를 정리하는 단계, 상기 모든 컴포넌트의 정리가 완료되는 것에 응답하여, 상기 제2 워크 클러스터에 의해 정리 결과 피드백 정보를 생성하고, 및 상기 정리 결과 피드백 정보를 상기 메타 클러스터로 전송하는 단계, 및 상기 정리 결과 피드백 정보를 기반으로 상기 메타 클러스터에서 상기 제2 워크 클러스터의 메타 정보를 삭제하기 위해 상기 메타 클러스터를 제어하는 단계를 포함하는, 방법."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "공개특허 10-2025-0032986-4-제1항에 있어서,각 클러스터는, 복수의 노드를 포함하고, 상기 클러스터 관리 방법은, 각 클러스터의 경우, 상기 클러스터 내 각 노드가 수행하는 비즈니스 작업의 유형에 따라 상기 복수의 노드를적어도 하나의 노드 풀로 분할하는 단계를 더 포함하고, 각 노드 풀은, 적어도 하나의 노드를 포함하는, 방법."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 메타 클러스터에 의해, 노드 추가 작업을 개시하는 단계, 및 상기 노드 추가 작업의 명령 정보에 따라, 사전 검사, 사전 배치, 자동화된 운영 및 유지 관리, 원격 실행 엔진확장을 수행하기 위해 상기 제1 타겟 워크 클러스터를 제어하고, 및 상기 제1 타겟 워크 클러스터의 상기 제1워크 노드의 배치를 구현하기 위해 클러스터 확장을 제어하는 단계를 더 포함하고, 상기 노드 추가 작업은, 제1 타겟 워크 클러스터에 상기 클러스터 시스템의 제1 워크 노드를 추가하도록 명령하는 데 사용되고, 방법."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 메타 클러스터에 의해 노드 삭제 작업을 개시하는 단계, 및 상기 노드 삭제 작업의 명령 정보에 따라, 사전 검사를 수행하고, 자동화된 운영 및 유지 관리와 원격 실행 엔진 워크 노드를 줄이고, 제2 워크 노드를 줄이기 위해 상기 제2 타겟 워크 클러스터를 제어하는 단계를 더 포함하고, 상기 노드 삭제 작업은, 제2 타겟 워크 클러스터에 상기 클러스터 시스템의 제2 워크 노드를 삭제하도록 명령하는 데 사용되는, 방법."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제2항에 있어서,공개특허 10-2025-0032986-5-상기 메타 클러스터에 의해, 임의의 워크 클러스터로부터 송신된 도메인 이름 확인 요청을 수신하는 단계, 배치된 상기 도메인 이름 확인 서버를 기반으로 상기 도메인 이름 확인 요청과 일치하는 확인 워크 클러스터에대해 검색하도록 상기 메타 클러스터를 제어하고, 및 상기 도메인 이름 확인 요청을 상기 확인 워크 클러스터로전달하는 단계, 및 대응하는 도메인 이름 확인 결과를 생성하기 위해 상기 도메인 이름 확인 요청을 확인하기 위해 상기 확인 워크클러스터를 제어하고, 및 상기 메타 클러스터에 의해 상기 도메인 이름 확인 결과를 상기 임의의 워크 클러스터로 전송하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "클러스터 관리 장치에 있어서,메타 클러스터에 의해, 워크 클러스터에 대한 추가 및 삭제 작업을 개시하도록 구성된, 작업 개시 모듈, 및 상기 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 대응하는 클러스터 배치 또는 제거를 구현하기 위해 지정된 워크 클러스터를 제어하도록 구성된, 클러스터 추가 및 삭제 모듈을 포함하고, 상기 워크 클러스터에 대한 상기 추가 및 삭제 작업은, 상기 지정된 워크 클러스터를 상기 클러스터 시스템에 추가하도록 명령하거나 상기 클러스터 시스템에서 상기지정된 워크 클러스터를 삭제하도록 명령하는 데 사용되고, 상기 클러스터 시스템은, 적어도 하나의 클러스터를 포함하고, 상기 적어도 하나의 클러스터는, 상기 메타 클러스터 및 적어도 하나의 워크 클러스터를 포함하고, 상기 메타 클러스터는, 상기 클러스터 시스템의 운영 및 유지 관리 제어를 실행하도록 구성되고, 상기 운영 및 유지 관리 제어는, 워크 클러스터의 추가 및 삭제 처리를 포함하고, 상기 적어도 하나의 워크 클러스터 각각은, 비즈니스 작업을 수행하기 위한 비즈니스 컨테이너를 운반하는, 장치."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "전자 디바이스에 있어서,프로세서, 메모리, 및 버스공개특허 10-2025-0032986-6-를 포함하고, 상기 메모리는, 상기 프로세서에 의해 실행 가능한 기계 판독가능 명령들을 저장하고, 상기 전자 디바이스가 실행 중일 때, 상기 프로세서는, 상기 버스를 통해 상기 메모리와 통신하고, 및 상기 기계 판독가능 명령들은, 상기 프로세서에 의해 실행될 때, 제1항 내지 제8항 중 어느 한 항에 따른 상기 클러스터 관리 방법을 수행하게 하는, 전자 디바이스."}
{"patent_id": "10-2024-0113326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "컴퓨터 프로그램이 저장된 컴퓨터 판독 가능 매체에 있어서,상기 프로그램이 프로세서에 의해 실행될 때, 제1항 내지 제8항 중 어느 한 항에 따른 클러스터 관리 방법을 수행하게 하는, 컴퓨터 판독가능 저장 매체."}
{"patent_id": "10-2024-0113326", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 공개는 클러스터 관리 방법, 장치, 전자 디바이스 및 저장 매체를 제공한다. 클러스터 관리 방법은; 메타 클 러스터에 의해 워크 클러스터에 대한 추가 및 삭제 작업을 개시하는 단계 - 여기서 워크 클러스터에 대한 추가 및 삭제 작업은 지정된 워크 클러스터를 클러스터 시스템에 추가하도록 명령하거나 지정된 워크 클러스터를 클러 스터 시스템에서 삭제하도록 명령하는 데 사용됨 -; 및 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템 에서 대응하는 클러스터 배치 또는 제거를 구현하기 위해 지정된 워크 클러스터를 제어하는 단계를 포함한다."}
{"patent_id": "10-2024-0113326", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 공개는 컴퓨터의 기술 분야, 특히 클러스터 관리 방법(cluster management method) 및 장치(apparatus), 전 자 디바이스(electronic device) 및 저장 매체(storage medium)에 관한 것이다. 본 출원은 2023년 8월 29일에 출원된 중국 특허 출원 제202311103293.1호의 우선권과 이익을 주장한다. 위에 언 급된 특허 출원은 본원에서 전체적으로 참조로 포함된다."}
{"patent_id": "10-2024-0113326", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "쿠버네티스(Kubernetes)(K8s라고도 함)는 컨테이너화된 워크로드(workloads)와 서비스를 관리하기 위한 이식성, 확장가능한 컨테이너 오케스트레이션 플랫폼(extensible container orchestration platform)이다. 쿠버네티스 (Kubernetes)에서 비즈니스의 컨테이너화된 변환(transformation) 및 배치(deployment)를 통해 비즈니스 애플 리케이션의 빠른 배치 및 오류 자체 복구(fault self-recovery)와 같은 기능이 실현될 수 있다. 한편, 쿠버네티 스의 오케스트레이션 및 스케줄링 기능을 이용하면 비즈니스 서비스를 자동으로 확장하여 다양한 부하에 따른 비즈니스 압박에 대처할 수 있다. 일반적으로, 하나의 쿠버네티스(Kubernetes) 클러스터는 관리 제어 노드(management control node)(마스터 노 드(master node)라고도 함)와 워크 노드(work node)로 분할된다. 관리 제어 노드는 전체 클러스터의 메타 데이 터(meta data), 컨테이너 스케줄링(container scheduling) 및 오케스트레이션(orchestration) 등을 관리하도록 구성된다. 그러나, 단일 쿠버네티스 클러스터(Kubernetes cluster)의 제한적인 관리 제어 효율 및 부하 용량으 로 인해, 단일 클러스터 내에서 관리되는 워크 노드 수가 제한되며, 이는 쿠버네티스 클러스터의 사용 경험에"}
{"patent_id": "10-2024-0113326", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "영향을 미친다. 발명의 내용"}
{"patent_id": "10-2024-0113326", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 공개의 실시예는 클러스터 관리 방법(cluster management method)을 제공하며, 이는: 메타 클러스터(meta cluster)에 의해, 워크 클러스터(work cluster)에 대한 추가(addition) 및 삭제 작업 (deletion task)을 개시하는 단계 - 여기서 워크 클러스터에 대한 추가(addition) 및 삭제 작업(deletion task)은 지정된 워크 클러스터를 클러스터 시스템(cluster system)에 추가하도록 명령하거나 지정된 워크 클러 스터를 클러스터 시스템에서 삭제하도록 명령하는 데 사용되고, 여기서 클러스터 시스템은 적어도 하나의 클러 스터를 포함하고; 적어도 하나의 클러스터는 메타 클러스터 및 적어도 하나의 워크 클러스터를 포함하고, 메타 클러스터는 클러스터 시스템의 운영 및 유지 관리 제어를 위해 구성되고, 운영 및 유지 관리 제어는 워크 클러 스터의 추가 및 삭제 처리를 포함하고, 적어도 하나의 워크 클러스터 각각은 비즈니스 작업(business task)을 수행하기 위한 비즈니스 컨테이너(business container)를 운반함 -; 및 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 대응하는 클러스터 배치 또는 제거를 구현하기 위 해 지정된 워크 클러스터를 제어하는(controllig) 단계를 포함한다. 가능한 구현에서, 이 방법은: 또한: 메타 클러스터 배치를 위한 부트스트랩 환경(bootstrap environment)을 초기화하는(initializing) 단계; 클러스터-간 도메인 이름(cross-cluster domain name)을 저장하기 위한 데이터베이스를 배치하고, 클러스터-간 도메인 이름 확인 서비스 제공하기 위한 도메인 이름 확인 서버(domain name resolution server)를 배치하고, 및 자동화된 운영 및 유지관리 도구(maintenance tool)와 원격 실행 엔진(remote execution engine)을 배치하 는(deploying) 단계; 및 메타 클러스터의 부트스트랩 배치(bootstrap deployment)를 수행하는(performing) 단계를 포함한다. 가능한 구현에서, 추가 및 삭제 작업의 명령 정보는 클러스터 추가 명령 정보(cluster addition instruction information)를 포함하고, 클러스터 추가 명령 정보는 제1 워크 클러스터(first work cluster)를 새로 추가하도 록 명령하는 데 사용되고; 및 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 대응하는 클러스터 배치 또는 제거를 구현하기 위해 지정된 워크 클러스터를 제어하는(controlling) 단계는: 클러스터 추가 명령 정보에 따라 제1 워크 클러스터와 메타 클러스터 간에 비밀번호(password) 없이 상호통신 (intercommunication)을 구현하기 위해 사전 배치 운영(pre-deployment operation)을 수행하는(performing) 단 계; 제1 워크 클러스터를 기반으로 후속 원격 운영 및 유지 관리를 위한 원격 실행 엔진을 구축하는(building) 단계; 및 제1 워크 클러스터의 부트스트랩 배치(bootstrap deployment)를 수행하는 단계를 포함한다. 가능한 구현에서, 추가 및 삭제 작업의 명령 정보는 클러스터 삭제 명령 정보를 포함하고, 클러스터 삭제 명령 정보는 제2 워크 클러스터(second work cluster)를 삭제하도록 명령하는 데 사용되고; 및 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 대응하는 클러스터 배치 또는 제거를 구현하기 위해 지정된 워크 클러스 터를 제어하는(controlling) 단계는: 클러스터 삭제 명령 정보에 따라 정리 프로그램(cleanup program)을 원격으로 실행하여 제2 워크 클러스터의 모 든 컴포넌트를 정리하는(cleaning up) 단계; 모든 컴포넌트(component)의 정리가 완료되는 것에 응답하여, 제2 워크 클러스터에 의해 정리 결과 피드백 정보 (cleanup result feedback information)를 생성하고(generating), 정리 결과 피드백 정보를 메타 클러스터로 전송하는(sending) 단계; 및 정리 결과 피드백 정보를 기반으로 메타 클러스터에서 제2 워크 클러스터의 메타 정보를 삭제하기 위해 메타 클 러스터를 제어하는(controlling) 단계를 포함한다. 가능한 구현에서, 각 클러스터가 복수의 노드를 포함하는 경우, 클러스터 관리 방법(cluster management method)은: 각 클러스터의 경우, 클러스터 내 각 노드가 수행하는 비즈니스 작업의 유형에 따라 다수의 노드를 적어도 하나 의 노드 풀로 분할하는(dividing) 단계를 더 포함하고, 각 노드 풀(node pool)은 적어도 하나의 노드를 포함한 다. 가능한 구현에서, 이 방법은: 메타 클러스터에 의해 노드 추가 작업을 개시하는(initiating) 단계 - 여기서 노드 추가 작업은 제1 타겟 워크 클러스터(first target work cluster)에 클러스터 시스템의 제1 워크 노드를 추가하도록 명령하는 데 사용됨 -; 노드 추가 작업의 명령 정보에 따라, 사전 검사, 사전 배치, 자동화된 운영 및 유지 관리, 원격 실행 엔진 확장 을 수행하기 위해 제1 타겟 워크 클러스터를 제어하고, 및 제1 타겟 워크 클러스터의 제1 워크 노드의 배치를 구현하기 위해 클러스터 확장을 제어하는(controlling) 단계를 더 포함한다. 가능한 구현에서, 이 방법은: 메타 클러스터에 의해 노드 삭제 작업을 개시하는(initiating) 단계 - 여기서 노드 삭제 작업은 제2 타겟 워크 클러스터(second target work cluster)에 클러스터 시스템의 제2 워크 노드를 삭제하도록 명령하는 데 사용됨 -; 및 노드 삭제 작업의 명령 정보(instruction information)에 따라, 사전 검사를 수행하고, 자동화된 운영 및 유지 관리와 원격 실행 엔진 워크 노드를 줄이고, 제2 워크 노드를 줄이기 위해 제2 타겟 워크 클러스터를 제어하는 (controlling) 단계를 더 포함한다. 가능한 구현에서, 이 방법은: 메타 클러스터에 의해, 임의의 워크 클러스터에 의해 전송된 도메인 이름 확인 요청(domain name resolution request)을 수신하는(receiving) 단계; 배치된 도메인 이름 확인 서버를 기반으로 도메인 이름 확인 요청과 일치하는 확인 워크 클러스터에 대해 검색 하도록 메타 클러스터를 제어하고(controlling), 도메인 이름 확인 요청을 확인 워크 클러스터로 전달하는 (forwarding) 단계; 및 대응하는 도메인 이름 확인 결과를 생성하기 위해 도메인 이름 확인 요청을 확인하기 위해 확인 워크 클러스터 를 제어하고(controlling), 메타 클러스터에 의해 도메인 이름 확인 결과를 임의의 워크 클러스터로 전송하는 (sending) 단계를 더 포함한다. 본 공개는 클러스터 관리 장치(cluster management apparatus)를 제공하며, 이는: 메타 클러스터에 의해, 워크 클러스터에 대한 추가 및 삭제 작업을 개시하도록 구성된, 작업 개시 모듈(task initiation module) - 여기서 워크 클러스터에 대한 추가(addition) 및 삭제 작업(deletion task)은 지정된 워 크 클러스터를 클러스터 시스템(cluster system)에 추가하도록 명령하거나 지정된 워크 클러스터를 클러스터 시 스템에서 삭제하도록 명령하는 데 사용되고, 여기서 클러스터 시스템은 적어도 하나의 클러스터를 포함하고; 적 어도 하나의 클러스터는 메타 클러스터와 적어도 하나의 워크 클러스터를 포함하며, 메타 클러스터는 클러스터 시스템의 운영 및 유지 관리 제어를 운반하며(carries); 운영 및 유지 관리 제어는 워크 클러스터의 추가 및 삭 제 처리를 포함하며; 적어도 하나의 워크 클러스터 각각은 비즈니스 작업을 수행하기 위해 비즈니스 컨테이너를 운반함 -; 및 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 대응하는 클러스터 배치 또는 제거를 구현하기 위 해 지정된 워크 클러스터를 제어하도록 구성된, 클러스터 추가 및 삭제 모듈(cluster addition and deletion module)을 포함한다. 가능한 구현에서 클러스터 추가 및 삭제 모듈은 다음을 위해 추가로 사용된다: 메타 클러스터 배치를 위한 부트스트랩 환경(bootstrap environment)을 초기화하는(initializing) 것; 클러스터-간 도메인 이름(cross-cluster domain name)을 저장하기 위한 데이터베이스를 배치하고, 클러스터-간 도메인 이름 확인 서비스 제공하기 위한 도메인 이름 확인 서버(domain name resolution server)를 배치하고, 및 자동화된 운영 및 유지관리 도구(maintenance tool)와 원격 실행 엔진(remote execution engine)을 배치하는(deploying) 것; 및 메타 클러스터의 부트스트랩 배치(bootstrap deployment)를 수행하는(performing) 것. 가능한 구현에서, 추가 및 삭제 작업의 명령 정보는 클러스터 추가 명령 정보를 포함하고, 클러스터 추가 명령 정보는 제1 워크 클러스터를 새로 추가하도록 명령하는 데 사용되고; 및 클러스터 추가 및 삭제 모듈은 다음을 위해 추가로 사용된다: 클러스터 추가 명령 정보에 따라 제1 워크 클러스터와 메타 클러스터 간에 비밀번호(password) 없이 상호통신 (intercommunication)을 구현하기 위해 사전 배치 운영(pre-deployment operation)을 수행하는(performing) 것; 제1 워크 클러스터를 기반으로 후속 원격 운영 및 유지 관리를 위한 원격 실행 엔진을 구축하는(building) 것; 및 제1 워크 클러스터의 부트스트랩 배치(bootstrap deployment)를 수행하는 것. 가능한 구현에서, 추가 및 삭제 작업의 명령 정보는 클러스터 삭제 명령 정보를 포함하고, 클러스터 삭제 명령 정보는 제2 워크 클러스터를 삭제하도록 명령하는 데 사용되고; 및 클러스터 추가 및 삭제 모듈은 다음을 위해 추가로 사용된다: 클러스터 삭제 명령 정보에 따라 정리 프로그램(cleanup program)을 원격으로 실행하여 제2 워크 클러스터의 모 든 컴포넌트를 정리하는(cleaning up) 것; 모든 컴포넌트(component)의 정리가 완료되는 것에 응답하여, 제2 워크 클러스터에 의해 정리 결과 피드백 정보 (cleanup result feedback information)를 생성하고(generating), 정리 결과 피드백 정보를 메타 클러스터로 전송하는(sending) 단계; 및 정리 결과 피드백 정보를 기반으로 메타 클러스터에서 제2 워크 클러스터의 메타 정보를 삭제하기 위해 메타 클 러스터를 제어하는(controlling) 것. 가능한 구현에서, 각 클러스터가 복수의 노드를 포함하는 경우, 장치는: 각 클러스터에 사용되는 경우, 클러스터 내 각 노드가 수행하는 비즈니스 작업의 유형에 따라 다수의 노드를 적 어도 하나의 노드 풀로 분할하는 노드 처리 모듈(node processing module)을 더 포함하고, 각 노드 풀은 적어도 하나의 노드를 포함한다. 가능한 구현에서, 작업 개시 모듈(task initiation module)은; 메타 클러스터에 의해 노드 추가 작업을 개시하는(initiating) 것을 위해 추가로 사용되며, 여기서 노드 추가 작업은 제1 타겟 워크 클러스터(first target work cluster)에 클러스터 시스템의 제1 워크 노드를 추가하도록 명령하는 데 사용된다. 노드 처리 모듈(node processing module)은: 노드 추가 작업의 명령 정보에 따라, 사전 검사, 사전 배치, 자동화된 운영 및 유지 관리, 원격 실행 엔진 확장 을 수행하기 위해 제1 타겟 워크 클러스터를 제어하고, 및 제1 타겟 워크 클러스터의 제1 워크 노드의 배치를 구현하기 위해 클러스터 확장을 제어하는(controlling) 것을 위해 추가로 사용된다. 가능한 구현에서, 작업 개시 모듈(task initiation module)은; 메타 클러스터에 의해 노드 삭제 작업을 개시하는(initiating) 것에 추가로 사용되며, 여기서 노드 삭제 작업은 제2 타겟 워크 클러스터(second target work cluster)에 클러스터 시스템의 제2 워크 노드를 삭제하도록 명령하 는 데 사용되고; 및 노드 처리 모듈(node processing module)은: 노드 삭제 작업의 명령 정보(instruction information)에 따라, 사전 검사를 수행하고, 자동화된 운영 및 유지 관리와 원격 실행 엔진 워크 노드를 줄이고, 제2 워크 노드를 줄이기 위해 제2 타겟 워크 클러스터를 제어하는 (controlling) 것에 추가로 사용된다. 가능한 구현에서, 본 장치는 또한 도메인 이름 처리 모듈을 더 포함하고, 도메인 이름 처리 모듈은 다음을 위해 사용된다: 메타 클러스터에 의해, 임의의 워크 클러스터에 의해 전송된 도메인 이름 확인 요청(domain name resolution request)을 수신하는(receiving) 것; 배치된 도메인 이름 확인 서버를 기반으로 도메인 이름 확인 요청과 일치하는 확인 워크 클러스터에 대해 검색 하도록 메타 클러스터를 제어하고(controlling), 도메인 이름 확인 요청을 확인 워크 클러스터로 전달하는 (forwarding) 것; 및 해당 도메인 이름 확인 결과를 생성하기 위해 도메인 이름 확인 요청을 확인하기 위해 확인 워크 클러스터를 제 어하고(controlling), 메타 클러스터에 의해 도메인 이름 확인 결과를 임의의 워크 클러스터로 전송하는 (sending) 것. 본 공개의 실시예는 전자 디바이스(electronic device)를 제공하고, 이는 프로세서(processor), 메모리 (memory) 및 버스(bus)를 포함하고, 여기서 메모리는 프로세서에 의해 실행 가능한 기계 판독가능 명령들 (machine-readable instructions)을 저장하고, 전자 디바이스가 실행 중일 때, 프로세서는 버스를 통해 메모리 와 통신하고, 기계 판독가능 명령들은, 프로세서에 의해 실행될 때, 위의 구현의 임의의 하나에 따라 클러스터 관리 방법을 구현하도록 한다. 본 공개의 실시예는 컴퓨터 프로그램(computer program)이 저장된 컴퓨터 판독가능 저장 매체(computer- readable storage medium)를 제공하며, 여기서 컴퓨터 프로그램이 프로세서에 의해 실행되면, 위의 구현예 중 하나에 따른 클러스터 관리 방법이 수행된다. 본 공개의 위의 언급된 목적, 특징 및 이점을 더욱 명확하고 이해하기 쉽게 하기 위하여, 바람직한 실시예를 아 래에 구체적으로 인용하고 첨부 도면을 참조하여 상세히 설명한다."}
{"patent_id": "10-2024-0113326", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 공개의 실시예의 목적, 기술적 해결책 및 이점을 보다 명확하게 하기 위해, 본 공개의 실시예의 기술적 해결 책은 본 공개의 실시예에서 도면을 참조하여 아래에 명확하고 완전하게 기술될 것이다. 명백하게, 기술된 실시 예들은 단지 일부일 뿐이지, 본 공개의 모든 실시예는 아니다. 일반적으로, 도면에 기술되고 도시된 본 공개의 실시예의 구성요소는 다양한 방식으로 배치되고 설계될 수 있다. 따라서, 첨부된 도면에 관련된 본 공개의 실시 예에 대한 이하의 상세한 설명은 본 공개의 보호 범위를 제한하려는 것이 아니라, 단지 본 공개의 선택된 실시"}
{"patent_id": "10-2024-0113326", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "예를 표현하기 위한 것이다. 창의적인 노력 없이 이 기술분야에서 통상의 지식을 가진 자에 의해 본 공개의 실 시예로부터 유도된 모든 다른 실시예는 본 공개의 보호 범위에 속한다. 아래 도면에서 유사한 참조 기호와 문자는 유사한 항목을 나타낸다는 점에 유의하세요. 따라서, 어떤 항목이 한 도면에 정의되면 후속 도면에서 추가로 정의하거나 설명할 필요가 없다. 본 문서에서 사용된 \"및/또는\"이라는 용어는 단순히 연관 관계를 설명하는 것이며, 세 가지 유형의 관계가 존재 할 수 있음을 나타낸다. 예를 들어, A 및/또는 B는 A가 혼자 존재하거나, A와 B가 공존하거나, B가 혼자 존재한 다는 것을 나타낼 수 있다. 또한, 본 명세서에서 사용되는 용어 \"적어도 하나\"는 복수의 사물 중 하나 또는 복 수의 사물 중 적어도 두 가지의 조합을 나타낸다. 예를 들어, A, B, C 중 적어도 하나는 A, B, C로 구성된 집합 에서 선택된 하나 이상의 요소를 나타낼 수 있다. 본 공개의 다양한 실시예에서 공개된 기술적 방안을 이용하기 전에, 사용자는 관련 법률 및 규정에 따라 적절한 방식으로 본 공개에 포함되는 개인정보의 종류, 이용범위, 이용 시나리오 등을 통지받고, 이에 대한 사용자의 승인을 받아야 함을 이해하여야 한다. 연구에 따르면 쿠버네티스(Kubernetes) 클러스터는 일반적으로 관리 제어 노드와 워크 노드를 포함하는 것으로 나타났다. 관리 제어 노드는 전체 클러스터의 메타 데이터(meta data), 컨테이너 스케줄링(container scheduling) 및 오케스트레이션(orchestration) 등을 관리하도록 구성된다. 구체적으로, 노드 프록시 프로그램 (node proxy program)(예: 구벨렛(kubelet))과 서비스 프록시 프로그램(service proxy program)(예: 쿠배-프록 시(kube-proxy))이 각 노드에 배치된다. 노드 프록시 프로그램은 관리 제어 컴포넌트(management control component)와 통신하도록 구성되며, 컨테이너 추가/삭제/수정 등을 포함하여 컨테이너 애플리케이션의 전체 수 명 주기를 담당한다. 서비스 프록시 프로그램은 프록시 클러스터 서비스에 맞게 구성되어 있다. 클라이언트 (client)는 서비스 도메인 이름을 통해 컨테이너와 통신할 수 있다. 따라서, 기본 컨테이너 리소스 아키텍처(예: 컨테이너 수, 컨테이너 배치 위치)가 보호될 수 있다. 그러나, 단일 쿠버네티스 클러스터(single Kubernetes cluster)의 관리 제어 효율성과 부하 용량이 제한적이기 때문에, 단일 클러스터 내에서 관리되는 워크 노드 수가 제한되며(예: 일반적으로 5000개를 초과할 수 없음), 이로 인해 쿠버네티스(Kubernetes) 사용 시나리오에 제약을 부과하게 된다. 예를 들어, 쿠버네티스는 요구 사항 이 매우 높은 대규모 기업에는 적용할 수 없다. 위의 연구에 기초하여, 본 공개의 실시예는 클러스터 관리 방법을 제공한다. 워크 클러스터에 대한 추가 및 삭 제 작업은 메타 클러스터에 의해 개시될 수 있으며, 워크 클러스터에 대한 추가 및 삭제 작업은 지정된 워크 클 러스터를 클러스터 시스템에 추가하도록 명령하거나 클러스터 시스템에서 지정된 워크 클러스터를 삭제하도록 명령하는 데 사용되며, 클러스터 시스템은 적어도 하나의 클러스터를 포함하고, 적어도 하나의 클러스터는 메타 클러스터와 적어도 하나의 워크 클러스터를 포함하고, 메타 클러스터는 클러스터 시스템의 운영 및 유지 관리 제어를 수행하도록 구성되고, 운영 및 유지 관리 제어는 워크 클러스터의 추가 및 삭제 처리를 포함하고, 적어 도 하나의 워크 클러스터 각각은 비즈니스 작업을 수행하기 위한 비즈니스 컨테이너를 운반한다. 클러스터 시스 템에서 지정된 워크 클러스터의 대응하는 클러스터 배치 또는 제거는 추가 및 삭제 작업의 명령 정보에 따라 제 어된다. 이런 방식으로, 많은 수의 노드가 필요한 경우에도, 대응하는 클러스터 추가 작업은 대응하는 워크 클러스터의 수를 증가시키기 위해 실제 요구사항구사에 따라 메타 클러스터에 의해 개시될 수 있다. 더욱이, 클러스터를 축 소해야 하는 경우, 클러스터 축소 작업(cluster scaling-down task)은 대응하는 워크 클러스터를 축소하기 위해 메타 클러스터에 의해 개시된다. 따라서, 이는 클러스터 시스템의 관리 제어 효율성 및 클러스터 시스템의 적용 성을 향상하는 데 도움이 된다. 본 공개의 실시예는 적어도 클러스터 관리 방법 및 장치, 전자 디바이스 및 저장 매체를 제공한다. 클러스터 추 가 및 삭제 작업은 실제 필요에 따라 메타 클러스터를 통해 개시될 수 있으며, 클러스터 시스템을 확장하거나 축소할 수 있어 클러스터 시스템의 적용성을 향상하는 데 도움이 된다.본 실시예를 보다 잘 이해하기 위해, 본 공개의 실시예에서 제공하는 클러스터 관리 방법에 대한 실행 주제 (execution subject)를 먼저 자세히 설명한다. 본 공개의 실시예에서 제공하는 클러스터 관리 방법에 대한 실행 주체는 전자 디바이스이다. 본 공개의 실시예에서, 전자 디바이스는 서버(server)이다. 서버는 독립적인 물리적 서버일 수도 있고, 복수의 물리적 서버로 구성된 서버 클러스터 또는 분산 시스템일 수도 있으며, 클라우드 서 비스, 클라우드 데이터베이스, 클라우드 컴퓨팅, 클라우드 스토리지, 빅데이터, 인공지능 플랫폼 등 기본적인 클라우드 컴퓨팅 서비스를 제공하는 클라우드 서버일 수도 있다. 다른 실시예에서, 전자 디바이스는 단말 디바이스일 수도 있다. 단말 디바이스는 모바일 장치, 컴퓨팅 장치, 차 량 장치, 웨어러블 장치 등을 포함한다. 더욱이, 클러스터 관리 방법은 메모리에 저장된 컴퓨터가 판독가능 명 령들을 호출하는 프로세서에 의해서도 구현될 수 있다. 본 공개의 실시예에서 제공하는 클러스터 관리 방법은 도면을 참조하여 아래에 자세히 설명된다. 도 1을 참조하 여, 본 공개의 실시예에서 제공하는 클러스터 관리 방법의 흐름도가 도시되어 있다. 클러스터 관리 방법은 다음 의 단계 S101 내지 S102를 포함한다. S101에서, 워크 클러스터에 대한 추가 및 삭제 작업은 메타 클러스터에 의해 개시되고, 여기서 워크 클러스터에 대한 추가(addition) 및 삭제 작업(deletion task)은 지정된 워크 클러스터를 클러스터 시스템(cluster system)에 추가하도록 명령하거나 지정된 워크 클러스터를 클러스터 시스템에서 삭제하도록 명령하는 데 사용되 고, 여기서 클러스터 시스템은 적어도 하나의 클러스터를 포함하고; 적어도 하나의 클러스터는 메타 클러스터와 적어도 하나의 워크 클러스터를 포함하며, 메타 클러스터는 클러스터 시스템의 운영 및 유지 관리 제어를 실행 하도록 구성되며; 운영 및 유지 관리 제어는 워크 클러스터의 추가 및 삭제 처리를 포함하고, 적어도 하나의 워 크 클러스터 각각은 비즈니스 작업(business task)을 수행하기 위한 비즈니스 컨테이너(business container)를 운반한다. 도 2를 참조하면, 도 2는 본 공개의 실시예에 의해 제공되는 클러스터 시스템의 아키텍처의 개략도이다. 도 2에 도시된 바와 같이, 클러스터 시스템(cluster system)은 메타 클러스터(meta cluster)와 적어도 하 나의 워크 클러스터(work cluster)를 포함한다. 메타 클러스터는 클러스터 시스템의 운영 및 유지 관리 제어를 위해 구성된다. 구체적으로, 운영 및 유지 관리 제어는 지정된 워크 클러스터의 추가 및 삭제, 워크 클러스터 내 노드의 추가 및 삭제, 비즈니스 컴포넌트의 설치 및 배치 등을 포함하지만, 이에 국한 되지는 않는다. 각 워크 클러스터는 대응하는 비즈니스 작업을 수행하기 위해 특정 비즈니스 컨테이너를 운반하 도록 구성된다. 본 공개의 실시예에서의 클러스터는 쿠버네티스 클러스터, 일반적으로 K8s 클러스터로 알려져 있다. 각 클러스 터에는 적어도 하나의 마스터 노드(master node)(마스터(Master))와, 각 마스터 노드 마스터와 통신 연결된 적 어도 하나의 워크 노드(work node)(워커(Worker))를 포함한다. 메타 클러스터가 비즈니스 컨테이너를 포함할 수도 있다는 점을 이해해야 한다. 일부 실시예에서는, 소수의 노 드가 필요한 시나리오에서, 클러스터 시스템은 메타 클러스터만을 포함할 수도 있다. 이 경우, 메타 클러 스터는 메타 클러스터와 워크 클러스터의 역할을 한다. 도 2에 도시된 클러스터 시스템의 아키텍처에서, 메타 클러스터는 전체 클러스터 시스템의 글로벌 정보(global information)를 포함한다. 따라서, 메타 클러스터의 부트스트랩(bootstrap) 역시 중요하다. 메타 클러스터의 부트스트랩 프로세스(bootstrap process)는 아래에서 자세히 설명된다. 도 3을 참조하면, 본 공개의 실시예에서 제공하는 메타 클러스터의 부트스트랩 방법의 흐름도가 도시되어 있다. 부트스트랩 방법은 다음의 S301~S303 단계를 포함한다. S301에서, 메타 클러스터를 배치하기 위한 부트스트랩 환경이 초기화된다. 메타 클러스터를 배치하기 위한 부트스트랩 환경을 초기화하는 프로세스, 즉 부트스트랩 환경의 표준 초기화 (InitEnv)는 구체적으로; 설치 패키지(바이너리) 다운로드, 가상 표준 운영 환경 초기화, 노드 간에 비밀번호 사용 안 함, 앤서블 자동화 운영(ansible automated operation) 및 유지관리 도구 배치 등을 포함한다. 재해 허 용 요구사항(disaster tolerance)을 고려할 때, 부트스트랩 환경은 일반적으로 다수의 물리적 노드를 의미한다. 따라서, 복수의 노드 간에는 비밀번호가 없는 구성이 제공되어야 한다. 본 공개의 실시예에서, 비밀번호 없이 로그인하는 것은 비밀번호로 로그인하는 방법과 단일 사인 로그인(Single Sign On)(SSO)의 두 가지 방법으로 실현될 수 있다. 비밀번호로 로그인한다는 것은 구성 파일에 컴퓨터 로그인비밀번호를 미리 설정하는 것을 말한다. OpenSSH 도구는 노드 간에 비밀번호 없이 로그인할 수 있도록 구성하는 데 사용된다. SSO는 인증 센터(authentication center)에서 미리 적용한 인증서로 부트스트랩 환경을 비밀번호 없이 구현하는 것을 의미한다. S302에서, 클러스터-간 도메인 이름을 저장하기 위한 데이터베이스가 배치되며; 클러스터-간 도메인 이름 확인 서비스를 제공하기 위한 도메인 이름 확인 서버가 배치되며; 또한 자동화된 운영 및 유지관리 도구와 원격 실행 엔진이 배치된다. 클러스터-간 도메인 이름을 저장하기 위한 데이터베이스의 배치는 Region Etcd로 배치될 수 있다. Region Etcd 는 클러스터-간 도메인 이름을 저장하고 클러스터 전체에서 도메인 이름을 확인하기(resolving) 위한 분산형 K- V 데이터베이스이다. 도메인 이름 확인 서버의 배치는 지역 도메인 이름 시스템( Region domain name system)(DNS) 배치일 수 있다. 구체적으로, Region Etcd는 전체 네트워크에 클러스터-간 도메인 이름 확인 서비스를 제공하기 위한 기본 저장 소(underlying storage)로 사용될 수 있다. 자동화된 운영 및 유지관리 도구와 원격 실행 엔진의 배치는 솔트스택(SaltStack) 배치일 수 있으며, 여기서 솔 트스택(SaltStack)은 C/S 아키텍처의 대규모 자동화된 운영 및 유지관리 도구이자 원격 실행 엔진이며; 및 앤서 블(Ansible)과 달리, 해당 서버(솔트-마스터(salt-master))는, 원격 호스트(솔트-미니온(salt-minion))으로부 터 인증 공개 키(authentication public key)를 받은 후, 다시 머신 관련 권한 또는 SSO 권한을 신청할 필요없 이 공개 키(public key)를 이용하여 후속 원격 운영 및 유지관리를 수행할 수 있다. S303에서, 메타 클러스터의 부트스트랩 배치가 수행된다. 구체적으로, 메타 클러스터의 부트스트랩 배치에는 kubelet, kubectl, kubeadm과 같은 컴포넌트를 배치하는 것 을 포함한다. K8s 클러스터의 노드 프록시인 Kubelet은 노드에서 Pod를 유지 관리하고 컨테이너의 정상적인 기 능을 보장하는 역할을 한다. 각 노드에는 하나의 kubelet 프로세스가 실행된다. Kubectl은 K8s 클러스터의 커맨 드 줄 도구이며 K8s의 마스터 노드에 설치된다. Kubeadm은 K8s 배치 도구(deployment tool)이다. 본 공개의 실시예에서, 클러스터-간 도메인 이름을 저장하기 위한 데이터베이스를 배치함으로써, 클러스터-간 도메인 이름 확인 서비스, 자동화된 운영 및 유지관리 도구, 원격 실행 엔진, 다른 클러스터의 클러스터 간 관 리 및 클러스터-간 도메인 이름 확인을 제공하는 도메인 이름 확인 서버는 메타 클러스터를 통해 달성될 수 있 으며, 이는 운영 및 유지관리 제어 효율성과 성능을 개선하는 데 도움이 된다. 일부 실시예에서는 다른 배치도 수행될 수 있으며, 예를 들어, K8s 배치를 기반으로 하는 기본 서비스(컨테이너 네트워크 인터페이스(CNI), 주키퍼(Zookeeper), MySQL 및 인프라 서비스 프로그램(infrastructure service programs) 등)가 있으나 여기서는 구체적으로 정의하지 않는다. 도 4를 참조하면, 본 공개의 실시예에서 제공하는 메타 클러스터 부트스트랩 이후의 노드의 배치 상태에 대한 개략도가 도시되어 있다. 클러스터 시스템에서, 모든 부트스트랩 노드(bootstrap nodes)는 클러스터의 고가용성 을 보장하기 위해 클러스터 마스터 노드(cluster master node)(K8S-master)가 된다. 각 클러스터 마스터 노드는 솔트스택(saltstack) 원격 실행 엔진의 원격 관리 노드(remote management node)(마스터)이며 클러스터의 모든 노드를 관리하도록 구성된다. 각 클러스터 마스터 노드는 솔트스택 원격 실행 엔진(saltstack remote execution engine)의 원격 실행 노드(remote execution node)(미니언(minion))이며 원격 관리 노드에 의해 원격으로 관리 될 수 있다. 이 클러스터는 역할(마스터(master) 또는 워커(worker))에 따라 나중에 추가된 노드에 의해 확장된 다. 이후 추가된 노드가 클러스터 워커 노드인 경우, 그 노드는 솔트-미니온(salt-minion)이며; 및 이후 추가된 노드가 클러스터 마스터 노드인 경우, 그 노드는 솔트-미니온(salt-minion)이자 솔트-마스터(salt-master)이기 도 한다. S102에서, 지정된 워크 클러스터는 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 대응하는 클러 스터 배치 또는 제거를 구현하기 위해 제어된다. 구체적으로, 추가 및 삭제 작업의 명령 정보는 클러스터 추가 명령 정보를 포함하고, 클러스터 추가 명령 정보 는 제1 워크 클러스터를 새로 추가하도록 명령하는 데 사용된다. 예시적으로, 클러스터 추가 명령 정보는 메타 클러스터의 마스터 노드에 의해 생성되며, 여기서 제1 워크 클러스터를 새로 추가하는 프로세스는 베어 컴퓨터 (bare computer)에 실행 중인 컴포넌트를 배치하는 프로세스이다. 이 구현에서, 제1 워크 클러스터를 새로 추가하는 프로세스는 메타 클러스터의 부트스트랩 프로세스와 유사하다. 워크 클러스터의 배치는 pre_install(사전 배치(pre-deployment), 바이너리 전달(binary transfer)), 솔트스택(saltstack) 설치, 클러스터 설치와 같은 단계를 통해 완료될 수 있다. 따라서, 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 지정된 워크 클러스터의 대응하는 클러스 터 배치 또는 제거를 제어하는 것은 다음 단계 (a) ~ (c)를 포함할 수 있다: (a) 클러스터 추가 명령 정보에 따라 제1 워크 클러스터와 메타 클러스터 간에 비밀번호(password) 없이 상호통 신(intercommunication)을 구현하기 위해 사전 배치 운영(pre-deployment operation)을 수행하는(performing) 단계; (b) 제1 워크 클러스터를 기반으로 후속 원격 운영 및 유지 관리를 위한 원격 실행 엔진을 구축하는(building) 단계; 및 (c) 제1 워크 클러스터의 부트스트랩 배치(bootstrap deployment)를 수행하는 단계. 본 공개의 실시예에서, 사전 배치 운영을 통해 제1 워크 클러스터와 메타 클러스터 간에 비밀번호 없이 상호통 신을 실현할 수 있어, 이는 이후의 자동 배치에 유리하다. 또한, 원격 실행 엔진을 구축함으로써, 메타 클러스 터가 제1 워크 클러스터를 제어하는 것이 편리한다. 구체적으로, 바이너리 설치 패키지는 메타 클러스터에서 획득될 수 있다. 즉, 설치 패키지는 메타 클러스터에 의해 제1 워크 클러스터의 배치될 노드로 전달될 수 있다. 물론, 설치 패키지를 다시 다운로드해야 할 수도 있 는데, 이는 구체적으로 정의되지 않는다. 사전 배치의 주요 기능은 메타 클러스터와 설치될 제1 워크 클러스터 노드 간에 비밀번호 없이 상호통신을 달성하여, 앤서블(Ansible)의 자동 배치를 용이하게 하는 것이다. 그런 다 음, 후속 원격 운영 및 유지 관리를 위해 배치될 노드를 기반으로, 완전한 솔트스택 원격 실행 엔진(complete saltstack remote execution engine)이 구축된다. 선택적으로, 제1 워크 클러스터는, 배치된 후, 메타 클러스터로 자체 도메인 이름을 등록할 수도 있다. 이런 방 식으로, 도메인 이름이 이후 여러 클러스터에서 확인되면, 메타 클러스터는 도메인 이름을 대응하는 워크 클러 스터로 정확하게 라우팅하여 확인할 수 있다. 가능한 구현에서, 추가 및 삭제 작업의 명령 정보는 클러스터 삭제 명령 정보를 포함하고, 클러스터 삭제 명령 정보는 제2 워크 클러스터를 삭제하도록 명령하는 데 사용된다. 제2 워크 클러스터는 클러스터 시스템에 임의의 지정된 워크 클러스터일 수 있다. 따라서, 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 대응하 는 클러스터 배치 또는 제거를 구현하기 위해 지정된 워크 클러스터를 제어하는 것은 구체적으로 다음 단계 ~ 을 포함할 수 있다: 클러스터 삭제 명령 정보에 따라 정리 프로그램(cleanup program)을 원격으로 실행하여 제2 워크 클러스터 의 모든 컴포넌트를 정리하는(cleaning up) 것; 모든 컴포넌트(component)의 정리가 완료되는 것에 응답하여, 제2 워크 클러스터에 의해 정리 결과 피드백 정보(cleanup result feedback information)를 생성하고(generating), 정리 결과 피드백 정보를 메타 클러스터 로 전송하는(sending) 것; 및 정리 결과 피드백 정보를 기반으로 메타 클러스터에서 제2 워크 클러스터의 메타 정보를 삭제하기 위해 메 타 클러스터를 제어하는(controlling) 것. 비밀번호 없이 미리 배치된 상호통신을 통해 워크 클러스터를 추가하는 것과 달리, 워크 클러스터를 삭제하는 것도 메타 클러스터에서 개시된다는 점을 알 수 있다. 제2 워크 클러스터의 모든 컴포넌트는 정리 프로그램 (SSH)을 원격으로 실행하여 정리되고, 그 결과는 나중에 메타 정보를 정리하도록 명령하기 위해 메타 클러스터 로 피드백된다. 본 공개의 실시예에서, 제2 워크 클러스터의 모든 컴포넌트를 원격으로 정리 프로그램을 실행함으로써 정리되어, 컴포넌트 정리 효율성을 개선할 수 있다. 더욱이, 메타 클러스터가 제2 워크 클러스터로부터 피드백 받은 정리 결과 피드백 정보를 기반으로 제2 워크 클러스터의 메타 정보를 메타 클러스터에서 추가로 삭제함으 로써, 메타 클러스터 내의 관리 정보가 즉시 업데이트된다. 이는 시스템 관리의 정확성을 향상시키는 데 도움이 된다. 워크 클러스터가 새로 추가되면 도메인 이름이 메타 클러스터로 등록되므로, 워크 클러스터가 삭제되면, 제2 워 크 클러스터의 메타 정보를 메타 클러스터에서 삭제하는 것 외에도, 제2 워크 클러스터의 도메인 이름도 메타클러스터에서 취소해야 함을 알 수 있다. 도 5를 참조하여 가능한 구현에 따르면, 각 클러스터의 경우, 복수의 노드는 클러스터의 각 노드가 수행하는 비 즈니스 작업의 유형에 따라 적어도 하나의 노드 풀로 나뉠 수도 있으며, 각 노드 풀은 적어도 하나의 노드를 포 함한다. 본 공개의 실시예에서, 클러스터 내 각 노드가 수행하는 비즈니스 작업의 종류에 따라 복수의 노드가 적어도 하 나의 노드 풀로 나뉘어지므로, 클러스터 관리 및 제어 노드를 공유할 때 서로 다른 비즈니스 간의 효과적인 자 원 분리 및 배치를 편리하게 달성할 수 있다. 구체적으로, 각 워크 클러스터의 경우, 서로 다른 노드를 워크 클러스터 내의 서로 다른 노드 풀로 논리적으로 나눌 수 있다. 예를 들어, 노드가 새로 추가되면, 대응하는 노드 식별자(node identifier)가 노드에 대해 구성 될 수 있다. 이런 방식으로, 동일한 노드 식별자를 갖는 노드는 동일한 노드 풀로 지정된다. 더욱이, 메타 클러 스터는 워크 클러스터이므로, 클러스터 내의 노드도 여러 노드 풀로 나뉠 수 있다(도 4 참조). 이러한 구현에서, 클러스터 내의 노드는 다양한 비즈니스 논리 유형(business logic types)에 따라 서로 다른 노드 풀로 나뉘므로, 다양한 비즈니스 컨테이너의 혼합 배치와 격리가 충족될 수 있을 뿐만 아니라, 서로 다른 비즈니스가 리소스를 놓고 경쟁하지 않고도 동일한 클러스터 관리 제어 노드 세트를 공유하도록 실현할 수 있다. 더욱이, 각 노드 풀에 대한, 노드 풀 정보는 메타 클러스터의 메타 데이터베이스에도 저장될 수 있다. 노 드 풀 정보는 노드 풀이 속한 클러스터, 노드 풀에 포함된 노드 수, 노드 풀과 연관된 비즈니스 유형, 사용 가 능한 지역, 생성 시간 등을 포함한다. 비즈니스 유형은, 구체적으로 정의되지 않은, 저장 서비스, 데이터베이스 서비스, 미들웨어 등을 포함할 수 있다. 클러스터 시스템의 적용성을 향상시키기 위해, 지정된 워크 클러스터를 추가, 삭제하는 것 외에도, 각 워크 클 러스터 내의 워크 노드가 노드 확장, 축소를 구현하기 위해 새로 추가되고 및 삭제될 수 있다는 것을 알 수 있 다. 따라서, 일부 실시예에서, 클러스터 관리 방법은 또한 다음의 단계 (I) 내지 (II)를 포함한다: (I) 메타 클러스터에 의해 노드 추가 작업을 개시하는(initiating) 단계, 여기서 노드 추가 작업은 제1 타겟 워 크 클러스터(first target work cluster)에 클러스터 시스템의 제1 워크 노드를 추가하도록 명령하는 데 사용되 고; 및 (II) 노드 추가 작업의 명령 정보에 따라, 사전 검사, 사전 배치, 자동화된 운영 및 유지 관리, 원격 실행 엔진 확장을 수행하기 위해 제1 타겟 워크 클러스터를 제어하고, 및 제1 타겟 워크 클러스터의 제1 워크 노드의 배치 를 구현하기 위해 클러스터 확장을 제어하는(controlling) 단계. 본 공개의 실시예에서, 각 워크 클러스터의 노드가 메타 클러스터에 의해 증가될 수 있으며, 이는 클러스터 시 스템의 적용성을 더욱 개선하는 데 도움이 된다. 제1 타겟 워크 클러스터는 클러스터 시스템 내의 모든 워크 클러스터가 될 수 있다. 구체적으로, 도 6을 참조하 면, 노드 추가 작업은 메타 클러스터 내의 인프라 서비스(infrastructure service)(예: 메타 클러스터 내의 관 리 제어 서비스)에 의해 개시될 수 있다. 새로 노드 풀을 추가하는 대응하는 운영이 수행되고, 솔트-api(salt- api) 명령이 제1 타겟 워크 클러스터의 원격 관리 노드 솔트-마스터(salt-master)로 전송된다. 그런 다음, 사전 확인, 사전 배치, 솔트스택(saltstack) 확장, K8s 확장과 같은 프로세스가 노드 추가를 완료하기 위해 제1 타겟 워크 클러스터에서 수행된다. 사전 검사는 머신에 설치 여부 확인, 커널 버전이 올바른지 확인, 운영 체제 구성 확인 등을 포함한다. 사전 배 치(pre-deployment)는 새로 추가된 노드에 대한 설치 패키지 다운로드, 앤서블(Ansible)에 대한 비밀번호 없이 상호통신 활성화, 파이톤 가상 환경(python virtual environment) 준비 등을 포함한다. 선택적으로, 클러스터 관리 방법은 또한 다음 단계(m) 내지 (n)을 포함할 수 있다: (m) 메타 클러스터에 의해 노드 삭제 작업을 개시하는(initiating) 단계이며, 그리고 노드 삭제 작업은 제2 타 겟 워크 클러스터(second target work cluster)에 클러스터 시스템의 제2 워크 노드를 삭제하도록 명령하는 데 사용되며; 및 (n) 노드 삭제 작업의 명령 정보(instruction information)에 따라, 사전 검사를 수행하고, 자동화된 운영 및 유지 관리와 원격 실행 엔진 워크 노드를 줄이고, 제2 워커 노드(second worker node)를 줄이기 위해 제2 타겟 워크 클러스터를 제어하는(controlling) 것에 추가로 사용된다.제2 타겟 워크 클러스터는 클러스터 시스템 내의 모든 워크 클러스터가 될 수 있다. 구체적으로, 도 7을 참조하 면, 노드 추가와 유사하게 노드 삭제 작업은 메타 클러스터 내의 인프라 서비스에 의해 개시될 수 있다. 노드 풀을 삭제하는 대응하는 운영이 수행되고, 솔트-api(salt-api) 명령은 사전 배치된 솔트스택(saltstack) 아키텍 처에 의해 제2 타겟 워크 클러스터의 원격 관리 노드 솔트-마스터(salt-master)로 전송된다. 축소 운영 (reduction operation)이 제2 타겟 워크 클러스터에서 수행된다. 축소 운영은 사전 확인, 비즈니스 모듈 제거 (제공된 경우), 솔트스택(saltstack) 워크 노드와 클러스터 노드 축소 등의 단계를 포함한다. 이런 방식으로, 각 워크 클러스터의 노드가 메타 클러스터에 의해 삭제될 수 있다. 따라서, 비즈니스가 축소되 면 클러스터 시스템의 노드도 그에 따라 줄어들 수 있다. 이는 자원 활용률을 높이는 데 도움이 된다. 메타 클러스터는 부트스트랩 시 도메인 이름 확인 서버와 함께 배치된다는 점을 이해해야 한다. 워크 클러스터 가 새로 추가되면, 각 워크 클러스터는 도메인 이름 등록을 구현하기 위해 자체 도메인 이름을 메타 클러스터로 전송하여 할 수 있다. 따라서, 클러스터 시스템의 아키텍처에 따라, 어느 워크 클러스터 내에서도 도메인 이름 확인을 실현할 수 없는 경우, 도메인 이름 확인 요청이 생성되고, 이 요청은 메타 클러스터에 의해 도메인 이름 확인을 실현하기 위해 메타 클러스터로 전송된다. 따라서, 도 8에 도시된 바와 같이, 본 실시예에서는 클러스터 관리 방법은 다음의 단계 S801 내지 S803을 더 포함한다. S801은, 메타 클러스터에 의해, 임의의 워크 클러스터에 의해 전송된 도메인 이름 확인 요청(domain name resolution request)을 수신하는(receiving) 단계이고; S802는, 배치된 도메인 이름 확인 서버를 기반으로 도메인 이름 확인 요청과 일치하는 확인 워크 클러스터에 대 해 검색하도록 메타 클러스터를 제어하고(controlling), 도메인 이름 확인 요청을 확인 워크 클러스터로 전달하 는(forwarding) 단계이고; 및 S803은, 해당 도메인 이름 확인 결과를 생성하기 위해 도메인 이름 확인 요청을 확인하기 위해 확인 워크 클러 스터를 제어하고(controlling), 메타 클러스터에 의해 도메인 이름 확인 결과를 임의의 워크 클러스터로 전송하 는(sending) 단계이다. 본 공개의 실시예에서, 임의의 워크 클러스터 내에서도 도메인 이름 확인이 실현될 수 없는 경우, 도메인 이름 확인 요청이 생성되고, 메타 클러스터에 의해 대응하는 확인 워크 클러스터로 전송될 수 있다. 도메인 이름 확 인 요청이 확인 워크 클러스터에 의해 확인되면, 대응하는 도메인 이름 확인 결과가 생성되고 메타 클러스터에 의해 임의의 워크 클러스터로 전송된다. 이와 같이, 클러스터-간 도메인 이름 확인이 실현되고, 이후 클러스터 간 액세스가 가능해진다. 구체적으로, 도 9를 참조하면, 현재 도메인 이름 확인 요청이 워크 클러스터 a에 의해 확인되는 경우, 도메인 이름 확인 요청은 워크 클러스터 a에 대해 배치된 DNS에 의해 메타 클러스터의 DNS로 전송된다. 즉, 임의의 워 크 클러스터에 의해 전송된 도메인 이름 확인 요청은 메타 클러스터에서 수신될 수 있다. 그런 다음 메타 클러 스터는 도메인 이름 확인 서버를 기반으로 도메인 이름 확인 요청과 일치하는 확인 워크 클러스터 b(resolution work cluster b)를 찾을 수 있고, 도메인 이름 확인 요청을 확인 워크 클러스터 b로 전달할 수 있다. 다음으로, 확인 워크 클러스터 b는 도메인 이름 확인 요청에 따라 대응하는 도메인 이름 확인 결과를 생성하고, 대응하는 도메인 이름 확인 결과를 메타 클러스터로 전송할 수 있다. 마지막으로, 도메인 이름 확인 결과는 메타 클러스 터에서 워크 클러스터 a로 전달되고, 그런 다음 도메인 이름 확인이 구현된다. 이런 방식으로, 메타 클러스터의 지역 DNS와 지역 ETCD의 배치 아키텍처를 기반으로 전체 네트워크의 모든 K8s 클러스터에 대한 도메인 이름 확인이 실현될 수 있다. 클러스터의 내부 도메인 이름만 부분적으로 해결될 수 있 는 문제가 해결된다. 위에 설명된 클러스터 관리 방법에서 단계를 작성하는 순서는 엄격한 수행 순서를 의미하지 않으며, 구현 과정 에 어떠한 제한도 가하지 않는다는 점을 해당 기술 분야 종사자라면 이해할 수 있을 것이다. 각 단계를 수행하 는 구체적인 순서는 해당 단계의 기능과 가능한 내부 논리에 따라 결정되어야 한다. 동일한 기술적 개념에 기초하여, 본 공개의 실시예는 또한 클러스터 관리 방법에 대응하는 클러스터 관리 장치 (cluster management apparatus)를 제공한다. 본 공개의 실시예에서, 문제를 해결하기 위한 클러스터 관리 장치 의 원리는 본 공개의 실시예에서 상술한 클러스터 관리 방법과 유사하므로, 클러스터 관리 장치를 구현하기 위 해서는 클러스터 관리 방법의 구현을 참조할 수 있으며, 중복된 설명은 더 이상 하지 않는다. 도 10을 참조하면, 본 공개의 실시예에 의해 제공되는 클러스터 관리 장치(cluster management apparatus)의 개략도가 도시되어 있다. 클러스터 관리 장치는 다음을 포함한다: 메타 클러스터에 의해, 워크 클러스터에 대한 추가 및 삭제 작업은 개시하도록 구성된, 작업 개시 모듈(task initiation module) - 워크 클러스터에 대한 추가 및 삭제 작업은 지정된 워크 클러스터를 클러스터 시스 템에 추가하도록 명령하거나 클러스터 시스템에서 지정된 워크 클러스터를 삭제하도록 명령하는 데 사용되며, 클러스터 시스템은 적어도 하나의 클러스터를 포함하고, 적어도 하나의 클러스터는 하나의 메타 클러스터와 적 어도 하나의 워크 클러스터를 포함하고, 메타 클러스터는 클러스터 시스템의 운영 및 유지 관리 제어를 실행하 도록 구성되고; 운영 및 유지 관리 제어는 워크 클러스터의 추가 및 삭제 처리를 포함하고, 적어도 하나의 워크 클러스터 각각은 비즈니스 작업을 수행하기 위한 비즈니스 컨테이너를 운반함 -; 및 추가 및 삭제 작업의 명령 정보에 따라 클러스터 시스템에서 대응하는 클러스터 배치 또는 제거를 구현하기 위 해 지정된 워크 클러스터를 제어하도록 구성된, 클러스터 추가 및 삭제 모듈(cluster addition and deletion module)을 포함한다. 가능한 구현에서, 클러스터 추가 및 삭제 모듈은: 메타 클러스터를 배치하기 위한 부트스트랩 환경을 초기화하고; 클러스터-간 도메인 이름(cross-cluster domain name)을 저장하기 위한 데이터베이스를 배치하고, 클러스터-간 도메인 이름 확인 서비스 제공하기 위한 도메인 이름 확인 서버(domain name resolution server)를 배치하고, 및 자동화된 운영 및 유지관리 도구(maintenance tool)와 원격 실행 엔진(remote execution engine)을 배치하 고; 및 메타 클러스터의 부트스트랩 배치를 수행하도록 추가로 구성된다. 가능한 구현에서, 추가 및 삭제 작업의 명령 정보는 클러스터 추가 명령 정보를 포함하고, 클러스터 추가 명령 정보는 제1 워크 클러스터를 새로 추가하도록 명령하는 데 사용된다. 클러스터 추가 및 삭제 모듈는 구체 적으로: 클러스터 추가 명령 정보에 따라 제1 워크 클러스터와 메타 클러스터 간에 비밀번호(password) 없이 상호통신 (intercommunication)을 구현하기 위해 사전 배치 운영(pre-deployment operation)을 수행하고; 제1 워크 클러스터를 기반으로 후속 원격 운영 및 유지 관리를 위한 원격 실행 엔진을 구축하고; 및 제1 워크 클러스터의 부트스트랩 배치를 수행하도록 구성된다. 가능한 구현에서, 추가 및 삭제 작업의 명령 정보는 클러스터 삭제 명령 정보를 포함하고, 삭제 명령 정보는 제 2 워크 클러스터를 삭제하도록 명령하는 데 사용된다. 클러스터 추가 및 삭제 모듈는 구체적으로: 클러스터 삭제 명령 정보에 따라 정리 프로그램(cleanup program)을 원격으로 실행하여 제2 워크 클러스터의 모 든 컴포넌트를 정리하고; 모든 컴포넌트의 정리가 완료되는 것에 응답하여, 제2 워크 클러스터에 의해 정리 결과 피드백 정보를 생성하고, 정리 결과 피드백 정보를 메타 클러스터로 전송하고; 및 정리 결과 피드백 정보를 기반으로 메타 클러스터에서 제2 워크 클러스터의 메타 정보를 삭제하도록 메타 클러 스터를 제어하도록 구성된다. 가능한 구현에서, 각 클러스터는 복수의 노드를 포함한다. 도 11을 참조하면, 클러스터 관리 장치는: 각 클러스터에 사용되는 경우, 클러스터 내 각 노드가 수행하는 비즈니스 작업의 유형에 따라 다수의 노드를 적 어도 하나의 노드 풀로 분할하도록 구성된, 노드 처리 모듈(node processing module)을 더 포함하고, 각 노드 풀은 적어도 하나의 노드를 포함한다. 가능한 구현에서, 작업 개시 모듈(task initiation module)은: 메타 클러스터에 의해, 노드 추가 작업을 개시하도록 추가로 구성되고, 및 노드 추가 작업은 클러스터 시스템에 서 제1 타겟 워크 클러스터에 제1 워크 노드를 추가하도록 명령하는 데 사용된다. 노드 처리 모듈은: 노드 추가 작업의 명령 정보에 따라, 사전 검사, 사전 배치, 자동화된 운영 및 유지 관리, 원격 실행 엔진 확장 을 수행하기 위해 제1 타겟 워크 클러스터를 제어하고, 및 제1 타겟 워크 클러스터의 제1 워크 노드의 배치를 구현하기 위해 클러스터 확장을 제어하도록 추가로 구성된다. 가능한 구현에서, 작업 개시 모듈(task initiation module)은: 메타 클러스터에 의해 노드 삭제 작업을 개시하도록 추가로 구성되며, 그리고 노드 삭제 작업은 제2 타겟 워크 클러스터에 클러스터 시스템의 제2 워크 노드를 삭제하도록 명령하는 데 사용된다. 노드 처리 모듈은: 노드 삭제 작업의 명령 정보에 따라, 사전 검사를 수행하고, 자동화된 운영 및 유지 관리와 원격 실행 엔진 워 크 노드를 줄이고, 제2 워크 노드를 줄이기 위해 제2 타겟 워크 클러스터를 제어하도록 추가로 구성된다. 가능한 구현에 따르면, 클러스터 관리 장치는 또한 도메인 이름 처리 모듈(domain name processing module)을 추가로 포함한다. 도메인 이름 처리 모듈은: 메타 클러스터에 의해, 임의의 워크 클러스터에 의해 전송된 도메인 이름 확인 요청(domain name resolution request)을 수신하고; 배치된 도메인 이름 확인 서버를 기반으로 도메인 이름 확인 요청과 일치하는 확인 워크 클러스터에 대해 검색 하도록 메타 클러스터를 제어하고, 도메인 이름 확인 요청을 확인 워크 클러스터로 전달하고; 및 해당 도메인 이름 확인 결과를 생성하기 위해 도메인 이름 확인 요청을 확인하기 위해 확인 워크 클러스터를 제 어하고, 메타 클러스터에 의해 도메인 이름 확인 결과를 임의의 워크 클러스터로 전송하도록 구성된다. 장치 내 각 모듈의 처리 흐름 및 모듈 간의 상호작용 흐름에 대한 설명에 대하여, 위의 방법 실시예에서 관련된 설명을 참조할 수 있으므로, 여기서는 자세히 설명하지 않는다. 동일한 발명적 개념에 기초하여, 본 공개의 실시예는 또한 전자 디바이스를 제공한다. 도 12를 참조하면, 본 공 개의 실시예에 의해 제공되는 전자 디바이스(electronic device)의 구조적 개략도가 도시되어 있으며, 이 는 프로세서(processor), 메모리(memory) 및 버스(bus)를 포함한다. 메모리는 실행 가능한 명령들을 저장하도록 구성되어 있으며, 내부 저장소(internal storage)와 외부 메모리(external memory)를 포함한다. 여기에 언급된 내부 저장소는 프로세서 내부의 운영 데이터와 하드 디 스크 등의 외부 메모리와 교환되는 데이터를 일시적으로 저장하기 위한 내부 메모리(internal memory)라 고도 한다. 프로세서는 내부 저장소를 통해 외부 메모리와 데이터를 교환한다. 본 공개의 실시예에서, 메모리은 프로세서에 의해 제어되고 실행되는 본 공개의 솔루션을 수행하기 위한 애플리케이션 코드(application code)를 저장하도록 구체적으로 구성된다. 즉, 전자 디바이스가 실 행 중일 때, 프로세서는 버스을 통해 메모리와 통신하여 프로세서가 메모리에 저장된 애플리케이션 코드를 실행하게 하고, 그런 다음 앞서 설명한 실시예에 기술된 클러스터 관리 방법을 수 행한다. 메모리는 랜덤 액세스 메모리(RAM), 읽기 전용 메모리(ROM), 프로그래밍 가능 읽기 전용 메모리 (programmable read-only memory)(PROM), 지울 수 있는 프로그래밍 가능 읽기 전용 메모리(erasable programmable read-only memory)(EPROM), 전기적으로 지울 수 있는 프로그래밍 가능 읽기 전용 메모리 (electric erasable programmable read-only memory)(EEPROM) 등일 수 있지만, 이에 국한되지는 않다. 프로세서는 신호 처리가 가능한 집적 회로 칩일 수 있다. 프로세서는 중앙 처리 장치(CPU), 네트워크 프 로세서(NP) 또는 이와 유사한 범용 프로세서일 수 있으며; 또는 디지털 신호 프로세서(digital signal processor)(DSP), 애플리케이션별 집적 회로(application-specific integrated circuit)(ASIC), 필드 프로그래 밍가능 게이트 어레이(field-programmable gate array)(FPGA) 또는 다른 프로그래밍 가능 논리 장치, 개별 게 이트, 트랜지스터 논리 장치 또는 개별 하드웨어 컴포넌트일 수 있다. 프로세서는 본 공개의 예에서 공개된 방 법, 단계 및 논리적 블록 다이어그램을 구현하거나 실행할 수 있다. 범용 프로세서는 마이크로프로세서이거나 기존의 프로세서일 수 있다. 본 공개의 실시예에 도시된 구조는 전자 디바이스에 특별한 제한을 가하지 않는다는 점을 이해할 수 있다. 본 공개의 다른 일부 실시예에서, 전자 디바이스은 도면에 도시된 것보다 더 많거나 적은 컴포넌트 를 포함할 수 있으며, 일부 컴포넌트가 결합되거나, 일부 컴포넌트가 분할되거나, 서로 다른 컴포넌트 배치가 사용될 수 있다. 도면으로 표시된 컴포넌트는 하드웨어, 소프트웨어 또는 소프트웨어와 하드웨어의 조합으로 구현될 수 있다. 본 공개의 실시예는 컴퓨터 판독가능 저장 매체(computer-readable storage medium)를 더 제공한다. 컴퓨터 판 독가능 저장 매체는 컴퓨터 프로그램(computer program)을 저장하고, 컴퓨터 프로그램이 프로세서에 의해 실행 될 때, 앞서 설명한 방법 실시예에서의 클러스터 관리 방법의 단계들이 수행되게 한다. 저장 매체(storage medium)는 휘발성 또는 비휘발성 컴퓨터 판독가능 저장 매체일 수 있다. 본 공개의 실시예는 또한 컴퓨터 프로그램 제품(computer program product)을 제공한다. 컴퓨터 프로그램 제품 에는 프로그램 코드(program code)가 들어 있다. 프로그램 코드에 포함된 명령들(Instructions)은 앞서 설명한 방법 실시예에서 클러스터 관리 방법의 단계를 수행하는 데 사용될 수 있다. 자세한 내용은 앞서 설명한 방법 실시예에서 설명한 바와 같으므로 여기서는 중복해서 설명하지 않는다. 컴퓨터 프로그램 제품은 하드웨어, 소프트웨어 또는 이들의 조합으로 구현될 수 있다. 한 가지 선택적 실시예에 서, 컴퓨터 프로그램 제품은 컴퓨터 저장 매체(computer storage medium)로 구체화된다. 또 다른 선택적 실시예 에서, 컴퓨터 프로그램 제품은 소프트웨어 제품, 예를 들어 소프트웨어 개발 키트(software development kit)(SDK) 등으로 구체화된다. 본 기술 분야에 숙련된 사람이라면 설명의 편의와 간결성을 위해 앞서 설명한 시스템 및 장치의 구체적인 워크 과정에 대한 상기 방법 실시예에서 언급한 대응하는 과정을 참조할 수 있으며, 여기서는 중복해서 설명하지 않 을 것임을 명확히 이해할 수 있을 것이다. 본 공개에 의해 제공되는 여러 실시예에서, 개시된 시스템, 장치 및 방법은 다른 방식으로 구현될 수 있음을 이해해야 한다. 위에 기술한 장치 실시예는 단지 예시일 뿐이다. 예를 들어, 유닛 분할(unit division)은 단지 논리적인 기능 분할일 뿐이며, 실제 구현에서는 다른 분할이 될 수 있 다. 또 다른 예로, 다수의 유닛 또는 컴포넌트가 다른 시스템으로 결합되거나 통합될 수도 있고, 일부 기능은 무시되거나 수행되지 않을 수도 있다. 또한, 표시되거나 논의된 상호 결합이나 직접 결합 또는 통신 연결은 일 부 통신 인터페이스를 통해 구현될 수 있다. 장치나 유닛 간의 간접 결합이나 통신 연결은 전기적, 기계적 또는 기타 형태로 구현될 수 있다. 별도의 부분으로 설명된 유닛은 물리적으로 분리되어 있을 수도 있고 그렇지 않을 수도 있다. 유닛으로 표시된 부분은 물리적인 단위일 수도 있고 아닐 수도 있으며, 한 위치에 위치할 수도 있고, 여러 개의 네트워크 단위에 분산되어 있을 수도 있다. 일부 또는 모든 유닛은 실시예의 솔루션 목적을 달성하기 위한 실제 요구 사항에 따 라 선택될 수 있다. 또한, 본 공개의 실시예에서의 기능 유닛은 하나의 처리 유닛으로 통합될 수도 있고, 또는 각 유닛이 물리적으 로 단독으로 존재할 수도 있으며, 또는 두 개 이상의 유닛이 하나의 유닛으로 통합될 수도 있다. 소프트웨어 기능 단위 형태로 구현되어 독립형 제품으로 판매되거나 사용되는 경우, 해당 기능은 프로세서가 실 행할 수 있는 비휘발성 컴퓨터 판독가능 저장 매체(nonvolatile computer-readable storage medium)에 저장될 수 있다. 이러한 이해에 기초하여, 본 공개의 기술적 솔루션은 본질적으로 또는 기존 기술에 기여하는 부분, 또 는 기술적 솔루션의 일부가 소프트웨어 제품의 형태로 구현될 수 있다. 컴퓨터 소프트웨어 제품은 저장 매체에 저장되며, 컴퓨터 장치(개인용 컴퓨터, 서버, 네트워크 장치 등일 수 있음)가 본 공개의 실시예에 설명된 방법 의 모든 단계 또는 일부 단계를 수행하도록 하기 위한 여러 가지 명령들을 포함한다. 앞서 언급한 저장 매체에 는 USB 플래시 드라이브, 이동식 하드 디스크, 읽기 전용 메모리, 램, 자기 디스크 또는 광 디스크와 같이 프로 그램 코드를 저장할 수 있는 모든 매체가 포함된다. 마지막으로, 위의 실시예는 본 발명의 구체적인 구현예일뿐이며, 본 발명의 기술적 방안을 제한하기보다는 설명 하기 위해 사용된다는 점에 유의해야 한다. 본 공개의 보호 범위는 이러한 측면으로 제한되지 않는다. 본 공개 는 위의 실시예를 참조하여 상세히 설명되었지만, 당해 기술 분야의 통상의 지식을 가진 자라면 위의 실시예에 기술된 기술적 해결책에 대한 수정을 가하거나 쉽게 변경을 알아낼 수 있고, 그 안의 일부 기술적 특징에 대해 동등한 대체안을 만들 수 있다는 것을 이해해야 한다. 이러한 수정, 변경 또는 대체는 대응하는 기술 솔루션의 본질이 본 공개의 실시예의 기술 솔루션의 정신 및 범위에서 벗어나지 않도록 하며, 모두 본 공개의 보호 범위 에 속한다. 따라서, 본 공개의 보호범위는 청구범위의 보호범위에 근거하여야 한다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12"}
{"patent_id": "10-2024-0113326", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 공개의 실시예의 기술적 해결책을 보다 명확하게 설명하기 위해, 실시예에서 사용하는 데 필요한 도면에 대 한 간략한 소개는 다음과 같다. 여기에 있는 도면은 명세서에 포함되며 명세서의 일부를 구성한다. 이들 도면은 본 공개와 일치하는 실시예를 설명하며 본 공개의 기술적 솔루션을 설명하기 위해 명세서와 함께 사용된다. 다 음 도면은 본 공개의 특정 실시예만을 도시하며, 범위를 제한하는 것으로 간주되어서는 안 된다는 것을 이해해 야 한다. 이 분야의 일반 기술자는 창의적인 워크 없이도 이러한 도면을 바탕으로 다른 관련 도면을 얻을 수 있 다. 도 1은 본 공개의 일부 실시예에서 제공하는 클러스터 관리 방법의 흐름도를 도시한다; 도 2는 본 공개의 일부 실시예에서 제공하는 클러스터 시스템의 아키텍처에 대한 개략도를 도시한다; 도 3은 본 공개의 실시예에서 제공하는 메타 클러스터의 부트스트랩 방법의 흐름도를 도시한다; 도 4는 본 공개의 실시예에서 제공하는 메타 클러스터 부트스트랩 이후의 노드 배치 상태에 대한 개략도를 도시 한다; 도 5는 본 공개의 일부 실시예에서 제공하는 클러스터의 노드 풀에 대한 개략도를 도시한다; 도 6은 본 공개의 일부 실시예에서 제공하는 노드를 추가하는 과정의 개략도를 도시한다; 도 7은 본 공개의 일부 실시예에서 제공하는 노드 삭제 프로세스의 개략도를 도시한다; 도 8은 본 공개의 일부 실시예에서 제공하는 도메인 이름 처리 방법의 흐름도를 도시한다; 도 9는 본 공개의 일부 실시예에 따른 도메인 이름 확인 프로세스의 개략도를 도시한다; 도 10은 본 공개의 일부 실시예에서 제공하는 클러스터 관리 장치의 구조적 개략도를 도시한다; 도 11은 본 공개의 일부 실시예에 의해 제공되는 또 다른 클러스터 관리 장치의 구조적 개략도를 도시한다; 도 12는 본 공개의 일부 실시예에 의해 제공되는 전자 디바이스의 개략도를 도시한다."}
