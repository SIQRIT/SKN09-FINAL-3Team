{"patent_id": "10-2023-7043224", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0175329", "출원번호": "10-2023-7043224", "발명의 명칭": "히스토리 기반 모션 벡터 예측을 기반으로 비디오 신호를 처리하기 위한 방법 및 장치", "출원인": "엘지전자 주식회사", "발명자": "조제인"}}
{"patent_id": "10-2023-7043224", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "영상 복호화 장치에 의해 수행되는 영상 복호화 방법에 있어서,현재 블록에 대한 공간적 주변 블록 및 시간적 주변 블록에 기반하여 머지 후보 리스트(merge candidate list)를 구성하는 단계;상기 현재 블록의 HMVP(history-based motion vector predictor) 후보들을 저장하는 HMVP 후보 리스트에 포함된 HMVP 후보를 상기 머지 후보 리스트에 추가하는 단계; 및상기 머지 후보 리스트 내의 머지 후보의 모션 정보에 기반하여, 상기 현재 블록의 예측 샘플을 생성하는 단계- 상기 머지 후보는 머지 인덱스에 의해 지시됨 -를 포함하되,상기 HMVP 후보는, 상기 HMVP 후보의 모션 정보를 상기 머지 후보 리스트에 포함된 머지 후보들 중에서 미리 결정된 공간적 머지 후보들의 모션 정보와 비교한 결과에 기반하여, 상기 머지 후보 리스트에 추가되고,상기 미리 결정된 공간적 머지 후보들은 오직 상기 현재 블록의 좌측 이웃 공간적 머지 후보 및 상측 이웃 공간적 머지 후보만을 포함하고, 상기 좌측 및 상측 이웃 공간적 머지 후보들은 상기 머지 후보 리스트 내 최초 2개의 머지 후보들인영상 복호화 방법."}
{"patent_id": "10-2023-7043224", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "영상 부호화 장치에 의해 수행되는 영상 부호화 방법에 있어서,현재 블록에 대한 공간적 주변 블록 및 시간적 주변 블록에 기반하여 머지 후보 리스트(merge candidate list)를 구성하는 단계;상기 현재 블록의 HMVP(history-based motion vector predictor) 후보들을 저장하는 HMVP 후보 리스트에 포함된 HMVP 후보를 상기 머지 후보 리스트에 추가하는 단계; 상기 머지 후보 리스트 내의 머지 후보의 모션 정보에 기반하여, 상기 현재 블록의 예측 샘플을 생성하는 단계;및상기 예측 샘플의 생성에 이용된 머지 후보를 나타내는 머지 인덱스를 비트스트림에 부호화하는 단계를 포함하되,상기 HMVP 후보는, 상기 HMVP 후보의 모션 정보를 상기 머지 후보 리스트에 포함된 머지 후보들 중에서 미리 결정된 공간적 머지 후보들의 모션 정보와 비교한 결과에 기반하여, 상기 머지 후보 리스트에 추가되고,상기 미리 결정된 공간적 머지 후보들은 오직 상기 현재 블록의 좌측 이웃 공간적 머지 후보 및 상측 이웃 공간적 머지 후보만을 포함하고, 상기 좌측 및 상측 이웃 공간적 머지 후보들은 상기 머지 후보 리스트 내 최초 2개의 머지 후보들인영상 부호화 방법."}
{"patent_id": "10-2023-7043224", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항의 영상 부호화 방법에 의해 생성된 비트스트림을 저장하는 컴퓨터 판독가능한 저장 매체."}
{"patent_id": "10-2023-7043224", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "영상 부호화 방법에 의해 생성된 비트스트림을 전송하는 방법에 있어서, 상기 영상 부호화 방법은,현재 블록에 대한 공간적 주변 블록 및 시간적 주변 블록에 기반하여 머지 후보 리스트(merge candidate list)를 구성하는 단계;공개특허 10-2023-0175329-3-상기 현재 블록의 HMVP(history based merge candidate) 후보들을 저장하는 HMVP 후보 리스트에 포함된 HMVP후보를 상기 머지 후보 리스트에 추가하는 단계;상기 머지 후보 리스트 내의 머지 후보의 모션 정보에 기반하여, 상기 현재 블록의 예측 샘플을 생성하는 단계;및상기 예측 샘플의 생성에 이용된 머지 후보를 나타내는 머지 인덱스를 상기 비트스트림에 부호화하는 단계를 포함하되,상기 HMVP 후보는, 상기 HMVP 후보의 모션 정보를 상기 머지 후보 리스트에 포함된 머지 후보들 중에서 미리 결정된 공간적 머지 후보들의 모션 정보와 비교한 결과에 기반하여, 상기 머지 후보 리스트에 추가되고,상기 미리 결정된 공간적 머지 후보들은 오직 상기 현재 블록의 좌측 이웃 공간적 머지 후보 및 상측 이웃 공간적 머지 후보만을 포함하고, 상기 좌측 및 상측 이웃 공간적 머지 후보들은 상기 머지 후보 리스트 내 최초 2개의 머지 후보들인전송 방법."}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명에서는 비디오 신호를 처리하는 방법 및 이를 위한 장치가 개시된다. 구체적으로, 인터 예측을 기반으로 비디오 신호를 처리하는 방법에 있어서, 현재 블록의 공간 및 시간 이웃 블록에 기초하여 머지 후보 리스트 를 구성하는 단계; 상기 현재 블록의 히스토리 기반 머지 후보를 상기 머지 후보 리스트에 추가하는 단계; 상기 머 지 후보 리스트 내에서 상기 현재 블록의 인터 예측에 이용되는 머지 후보를 지시하는 머지 인덱스를 획득하는 단계; 상기 머지 인덱스에 의해 지시되는 머지 후보의 모션 정보에 기초하여 상기 현재 블록의 예측 샘플을 생성 하는 단계; 및 상기 모션 정보에 기초하여 히스토리 기반 머지 후보 리스트를 업데이트 하는 단계를 포함하되, 상기 히스토리 기반 머지 후보는 상기 머지 후보 리스트에 포함된 머지 후보들 중에서 미리 정의된 머지 후보와 중복되지 않는 모션 정보를 갖는 경우, 상기 머지 후보 리스트에 추가될 수 있다."}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 명세서의 실시예는 인터 예측(inter prediction)을 기반으로 비디오 신호를 처리하기 위한 방법 및 장치에 관한 것으로서, 특히 히스토리 기반 모션 벡터 예측(history-based motion vector prediction)를 이용하여 인 터 예측을 수행하기 위한 위한 방법 및 장치에 관한 것이다."}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "압축 부호화란 디지털화한 정보를 통신 회선을 통해 전송하거나, 저장 매체에 적합한 형태로 저장하기 위한 일 련의 신호 처리 기술을 의미한다. 영상, 이미지, 음성 등의 미디어가 압축 부호화의 대상이 될 수 있으며, 특히 영상을 대상으로 압축 부호화를 수행하는 기술을 비디오 영상 압축이라고 일컫는다. 차세대 비디오 컨텐츠는 고해상도(high spatial resolution), 고프레임율(high frame rate) 및 영상 표현의 고 차원화(high dimensionality of scene representation)라는 특징을 갖게 될 것이다. 그러한 컨텐츠를 처리하기 위해서는 메모리 저장(memory storage), 메모리 액세스율(memory access rate) 및 처리 전력(processing power) 측면에서 엄청난 증가를 가져올 것이다. 따라서, 차세대 비디오 컨텐츠를 보다 효율적으로 처리하기 위한 코딩 툴을 디자인할 필요가 있다."}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 명세서의 실시예의 목적은, HMVP 후보를 머지 후보 리스트(또는 AMVP 후보 리스트)에 추가함에 있어서, 예측 효율을 높이기 위한 중복성 체크에 대한 제한을 제안한다. 또한, 본 명세서의 실시예의 목적은, HMVP 후보를 머지 모드(또는 AMVP 모드)에 효과적으로 적용하기 위하여, HMVP 테이블의 크기를 정의하는 방법을 제안한다. 본 명세서의 실시예에서 이루고자 하는 기술적 과제들은 이상에서 언급한 기술적 과제들로 제한되지 않으며, 언"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 2, "content": "급하지 않은 또 다른 기술적 과제들은 아래의 기재로부터 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 명세서의 실시예의 일 양상은, 현재 블록의 공간(spatial) 및 시간(temporal) 이웃 블록에 기초하여 머지 후보 리스트(merge candidate list)를 구성하는 단계; 상기 현재 블록의 히스토리 기반 머지 후보(history based merge candidate)를 상기 머지 후보 리스트에 추가하는 단계; 상기 머지 후보 리스트 내에서 상기 현재 블록의 인터 예측에 이용되는 머지 후보를 지시하는 머지 인덱스(merge index)를 획득하는 단계; 상기 머지 인덱스에 의해 지시되는 머지 후보의 모션 정보에 기초하여 상기 현재 블록의 예측 샘플을 생성하는 단계; 및 상 기 모션 정보에 기초하여 히스토리 기반 머지 후보 리스트(history based merge candidate list)를 업데이트 하는 단계를 포함하되, 상기 히스토리 기반 머지 후보는 상기 머지 후보 리스트에 포함된 머지 후보들 중에서 미리 정의된 머지 후보와 중복되지 않는 모션 정보를 갖는 경우, 상기 머지 후보 리스트에 추가될 수 있다. 바람직하게, 상기 히스토리 기반 머지 후보 리스트는 상기 머지 후보 리스트의 최대 머지 후보 개수에 기초하여 결정되는 크기를 갖도록 정의될 수 있다. 바람직하게, 상기 히스토리 기반 머지 후보 리스트는 상기 머지 후보 리스트의 최대 머지 후보 개수에서 1을 감 산한 값의 크기를 갖도록 정의될 수 있다. 바람직하게, 상기 히스토리 기반 머지 후보 리스트의 크기는 5로 정의될 수 있다. 바람직하게, 상기 히스토리 기반 머지 후보는 상기 머지 후보 리스트에 포함된 머지 후보들 중에서 미리 정의된 특정 개수의 머지 후보들과 중복되지 않는 모션 정보를 갖는 경우, 상기 머지 후보 리스트에 추가될 수 있다. 바람직하게, 상기 히스토리 기반 머지 후보는 상기 머지 후보 리스트에 포함된 특정 공간 머지 후보와 중복되지 않는 모션 정보를 갖는 경우, 상기 머지 후보 리스트에 추가될 수 있다. 바람직하게, 상기 히스토리 기반 머지 후보는 상기 히스토리 기반 머지 후보 리스트 내에서 미리 정의된 특정 개수의 후보들로부터 유도될 수 있다. 본 명세서의 실시예의 다른 일 양상은, 인터 예측을 기반으로 비디오 신호를 처리하는 장치에 있어서, 상기 비 디오 신호를 저장하는 메모리; 및 상기 메모리와 결합된 프로세서를 포함하고, 상기 프로세서는, 현재 블록의 공간(spatial) 및 시간(temporal) 이웃 블록에 기초하여 머지 후보 리스트(merge candidate list)를 구성하고, 상기 현재 블록의 히스토리 기반 머지 후보(history based merge candidate)를 상기 머지 후보 리스트에 추가하 고, 상기 머지 후보 리스트 내에서 상기 현재 블록의 인터 예측에 이용되는 머지 후보를 지시하는 머지 인덱스 (merge index)를 획득하고, 상기 머지 인덱스에 의해 지시되는 머지 후보의 모션 정보에 기초하여 상기 현재 블 록의 예측 샘플을 생성하고, 상기 모션 정보에 기초하여 히스토리 기반 머지 후보 리스트(history based merge candidate list)를 업데이트 하되, 상기 히스토리 기반 머지 후보는 상기 머지 후보 리스트에 포함된 머지 후보 들 중에서 미리 정의된 머지 후보와 중복되지 않는 모션 정보를 갖는 경우, 상기 머지 후보 리스트에 추가될 수 있다."}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 명세서의 실시예에 따르면, 머지 후보 리스트(또는 AMVP 후보 리스트)에 추가하기 위한 중복성 체크를 제한 함으로써, 중복성 체크에 따른 복잡도를 개선하고 이를 통해 압축 성능을 향상시킬 수 있다. 또한, 본 명세서의 실시예에 따르면, HMVP 테이블의 크기를 정의함으로써, HMVP 테이블 저장에 따른 메모리 부 담을 줄일 수 있다. 본 발명에서 얻을 수 있는 효과는 이상에서 언급한 효과로 제한되지 않으며, 언급하지 않은 또 다른 효과들은"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 2, "content": "아래의 기재로부터 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 본 명세서에 따른 바람직한 실시 형태를 첨부된 도면을 참조하여 상세하게 설명한다. 첨부된 도면과 함께 이하에 개시될 상세한 설명은 본 명세서의 예시적인 실시형태를 설명하고자 하는 것이며, 본 명세서가 실시될 수 있는 유일한 실시형태를 나타내고자 하는 것이 아니다. 이하의 상세한 설명은 본 명세서의 완전한 이해를 제 공하기 위해서 구체적 세부사항을 포함한다. 그러나, 당업자는 본 명세서가 이러한 구체적 세부사항 없이도 실 시될 수 있음을 안다. 몇몇 경우, 본 명세서의 개념이 모호해지는 것을 피하기 위하여 공지의 구조 및 장치는 생략되거나, 각 구조 및 장치의 핵심기능을 중심으로 한 블록도 형식으로 도시될 수 있다. 아울러, 본 명세서에서 사용되는 용어는 가능한 한 현재 널리 사용되는 일반적인 용어를 선택하였으나, 특정한 경우는 출원인이 임의로 선정한 용어를 사용하여 설명한다. 그러한 경우에는 해당 부분의 상세 설명에서 그 의 미를 명확히 기재하므로, 본 명세서의 설명에서 사용된 용어의 명칭만으로 단순 해석되어서는 안 될 것이며 그 해당 용어의 의미까지 파악하여 해석되어야 함을 밝혀두고자 한다. 이하의 설명에서 사용되는 특정 용어들은 본 명세서의 이해를 돕기 위해서 제공된 것이며, 이러한 특정 용어의 사용은 본 명세서의 기술적 사상을 벗어나지 않는 범위에서 다른 형태로 변경될 수 있다. 예를 들어, 신호, 데 이터, 샘플, 픽처, 슬라이스, 타일, 프레임, 블록의 경우 각 코딩 과정에서 적절하게 대체되어 해석될 수 있을 것이다. 이하 본 명세서에서 '처리 유닛'은 예측, 변환 및/또는 양자화 등과 같은 인코딩/디코딩의 처리 과정이 수행되 는 단위를 의미한다. 또한, 처리 유닛은 휘도(luma) 성분에 대한 단위와 색차(chroma) 성분에 대한 단위를 포함 하는 의미로 해석될 수 있다. 예를 들어, 처리 유닛은 블록(block), 코딩 유닛(coding unit, CU), 예측 유닛 (prediction unit, PU) 또는 변환 블록(transform unit, TU)에 해당될 수 있다. 또한, 처리 유닛은 휘도 성분에 대한 단위 또는 색차 성분에 대한 단위로 해석될 수 있다. 예를 들어, 처리 유 닛은 휘도 성분에 대한 CTB(coding tree block), CB(coding block), PU 또는 TB(transform block)에 해당될 수 있다. 또는, 처리 유닛은 색차 성분에 대한 CTB, CB, PU 또는 TB에 해당할 수 있다. 또한, 이에 한정되는 것은 아니며 처리 유닛은 휘도 성분에 대한 단위와 색차 성분에 대한 단위를 포함하는 의미로 해석될 수도 있다. 또한, 처리 유닛은 반드시 정사각형의 블록으로 한정되는 것은 아니며, 3개 이상의 꼭지점을 가지는 다각형 형 태로 구성될 수도 있다. 또한, 이하 본 명세서에서 픽셀, 화소, 또는 계수(변환 계수 또는 1차 변환을 거친 변환 계수)는 샘플로 통칭된 다. 그리고, 샘플을 이용한다는 것은 픽셀 값, 화소 값, 또는 계수(변환 계수 또는 1차 변환을 거친 변환 계수) 등을 이용한다는 것을 의미할 수 있다. 도 1은 본 명세서의 실시예에 따른 비디오 코딩 시스템의 예를 도시한다. 비디오 코딩 시스템은 소스 디바이스 및 수신 디바이스를 포함할 수 있다. 소스 디바이스는 인코딩 된 비디오/영상 정보 또는 데이터를 파일 또는 스트리밍 형태로 디지털 저장매체 또는 네트워크를 통하여 수신디바이스로 전달할 수 있다. 소스 디바이스는 비디오 소스, 인코딩 장치, 송신기를 포함할 수 있다. 수신 디바이스는 수신기, 디코딩 장치 및 렌더러를 포함할 수 있다. 인코딩 장치는 비디오/영상 인코딩 장치라 고 불릴 수 있고, 디코딩 장치는 비디오/영상 디코딩 장치라고 불릴 수 있다. 송신기는 인코딩 장치 에 포함될 수 있다. 수신기는 디코딩 장치에 포함될 수 있다. 렌더러는 디스플레이부를 포함할 수도 있고, 디스플레이부는 별개의 디바이스 또는 외부 컴포넌트로 구성될 수도 있다. 비디오 소스는 비디오/영상의 캡쳐, 합성 또는 생성 과정 등을 통하여 비디오/영상을 획득할 수 있다. 비디오 소스는 비디오/영상 캡쳐 디바이스 및/또는 비디오/영상 생성 디바이스를 포함할 수 있다. 비디오/영상 캡쳐 디 바이스는 예를 들어, 하나 이상의 카메라, 이전에 캡쳐된 비디오/영상을 포함하는 비디오/영상 아카이브 등을 포함할 수 있다. 비디오/영상 생성 디바이스는 예를 들어 컴퓨터, 태블렛 및 스마트폰 등을 포함할 수 있으며 (전자적으로) 비디오/영상을 생성할 수 있다. 예를 들어, 컴퓨터 등을 통하여 가상의 비디오/영상이 생성될 수 있으며, 이 경우 관련 데이터가 생성되는 과정으로 비디오/영상 캡쳐 과정이 갈음될 수 있다. 인코딩 장치는 입력 비디오/영상을 인코딩할 수 있다. 인코딩 장치는 압축 및 코딩 효율을 위하여 예측, 변환, 양자화 등 일련의 절차를 수행할 수 있다. 인코딩된 데이터(인코딩된 비디오/영상 정보)는 비트스 트림(bitstream) 형태로 출력될 수 있다. 전송부는 비트스트림 형태로 출력된 인코딩된 비디오/영상 정보 또는 데이터를 파일 또는 스트리밍 형태로 디지털 저장매체 또는 네트워크를 통하여 수신 디바이스의 수신부로 전달할 수 있다. 디지털 저장 매체는 USB(universal serial bus), SD(secure digital), CD(compact disk), DVD(digital video disk), 블루레이 (bluray), HDD(hard disk drive), SSD(solid state drive)와 같은 다양한 저장 매체를 포함할 수 있다. 전송부 는 미리 정해진 파일 포멧을 통하여 미디어 파일을 생성하기 위한 엘레먼트를 포함할 수 있고, 방송/통신 네트워크를 통한 전송을 위한 엘레멘트를 포함할 수 있다. 수신기는 비트스트림을 추출하여 디코딩 장치 로 전달할 수 있다. 디코딩 장치는 인코딩 장치의 동작에 대응하는 역양자화, 역변환, 예측 등 일련의 절차를 수행하여 비 디오/영상을 디코딩할 수 있다. 렌더러는 디코딩된 비디오/영상을 렌더링할 수 있다. 렌더링된 비디오/영상은 디스플레이부를 통하여 디스 플레이될 수 있다. 도 2는 본 명세서의 실시예에 따른 비디오/이미지 신호의 인코딩을 위한 인코딩 장치의 개략적인 블록도를 나타 낸다. 도 2를 참조하면, 인코딩 장치는 영상 분할부, 감산부, 변환부, 양자화부, 역양자화 부, 역변환부, 가산부, 필터링부, 메모리, 인터 예측부, 인트라 예측부 및 엔트로피 인코딩부를 포함할 수 있다. 인터 예측부 및 인트라 예측부는 예측부로 통칭될 수 있다. 즉, 예측부는 인터 예측부 및 인트라 예측부를 포함할 수 있다. 변환부, 양자화부, 역양자화부, 역변환부는 레지듀얼(residual) 처리부에 포함될 수 있다. 레지듀얼 처리부는 감산부 를 더 포함할 수도 있다. 상술한 영상 분할부, 감산부, 변환부, 양자화부, 역양자화 부, 역변환부, 가산부, 필터링부, 인터 예측부, 인트라 예측부 및 엔트로피 인 코딩부는 실시예에 따라 하나의 하드웨어 컴포넌트(예를 들어 인코더 또는 프로세서)에 의하여 구성될 수 있다. 또한 메모리는 실시예에 따라 하나의 하드웨어 컴포넌트(예를 들어 메모리 또는 디지털 저장 매체) 에 의하여 구성될 수 있고, 메모리는 DPB(decoded picture buff-er)를 포함할 수 있다. 영상 분할부는 인코딩 장치에 입력된 입력 영상(또는, 픽쳐, 프레임)를 하나 이상의 처리 유닛 (processing unit)으로 분할할 수 있다. 일 예로, 처리 유닛은 코딩 유닛(CU)이라고 불릴 수 있다. 이 경우 코 딩 유닛은 코딩 트리 유닛(coding tree unit, CTU) 또는 최대 코딩 유닛(largest coding unit, LCU)으로부터 QTBT(Quad-tree binary-tree) 구조에 따라 재귀적으로(recursively) 분할될 수 있다. 예를 들어, 하나의 코딩 유닛은 쿼드 트리 구조 및/또는 바이너리 트리 구조를 기반으로 하위(deeper) 뎁스의 복수의 코딩 유닛들로 분 할될 수 있다. 이 경우 예를 들어 쿼드 트리 구조가 먼저 적용되고 바이너리 트리 구조가 나중에 적용될 수 있 다. 또는 바이너리 트리 구조가 먼저 적용될 수도 있다. 더 이상 분할되지 않는 최종 코딩 유닛을 기반으로 본 명세서에 따른 코딩 절차가 수행될 수 있다. 이 경우 영상 특성에 따른 코딩 효율 등을 기반으로, 최대 코딩 유 닛이 바로 최종 코딩 유닛으로 사용될 수 있고, 또는 필요에 따라 코딩 유닛은 재귀적으로(recursively) 보다하위 뎁스의 코딩 유닛들로 분할되어 최적의 사이즈의 코딩 유닛이 최종 코딩 유닛으로 사용될 수 있다. 여기서 코딩 절차라 함은 후술하는 예측, 변환, 및 복원 등의 절차를 포함할 수 있다. 다른 예로, 처리 유닛은 예측 유 닛(PU) 또는 변환 유닛(TU)을 더 포함할 수 있다. 이 경우 예측 유닛 및 변환 유닛은 각각 상술한 최종 코딩 유 닛으로부터 분할 또는 파티셔닝될 수 있다. 상기 예측 유닛은 샘플 예측의 단위일 수 있고, 상기 변환 유닛은 변환 계수를 유도하는 단위 및/또는 변환 계수로부터 레지듀얼 신호(residual signal)를 유도하는 단위일 수 있 다. 유닛은 경우에 따라서 블록(block) 또는 영역(area) 등의 용어와 혼용하여 사용될 수 있다. 일반적인 경우, MxN 블록은 M개의 열과 N개의 행으로 이루어진 샘플들 또는 변환 계수(transform coefficient)들의 집합을 나타낼 수 있다. 샘플은 일반적으로 픽셀 또는 픽셀의 값을 나타낼 수 있으며, 휘도(luma) 성분의 픽셀/픽셀값만을 나 타낼 수도 있고, 채도(chroma) 성분의 픽셀/픽셀 값만을 나타낼 수도 있다. 샘플은 하나의 픽처(또는 영상)을 픽셀(pixel) 또는 펠(pel)에 대응하는 용어로서 사용될 수 있다. 인코딩 장치는 입력 영상 신호(원본 블록, 원본 샘플 어레이)에서 인터 예측부 또는 인트라 예측부 로부터 출력된 예측 신호(예측된 블록, 예측 샘플 어레이)를 감산하여 레지듀얼 신호(잔여 블록, 잔여 샘 플 어레이)를 생성할 수 있고, 생성된 레지듀얼 신호는 변환부로 전송된다. 이 경우 도시된 바와 같이 인 코딩 장치 내에서 입력 영상 신호(원본 블록, 원본 샘플 어레이)에서 예측 신호(예측 블록, 예측 샘플 어 레이)를 감산하는 유닛은 감산부라고 불릴 수 있다. 예측부는 처리 대상 블록(이하, 현재 블록이라 함)에 대한 예측을 수행하고, 현재 블록에 대한 예측 샘플들을 포함하는 예측된 블록(predicted block)을 생성할 수 있다. 예측부는 블록 또는 CU 단위로 인트라 예측이 적용되는지 또는 인터 예측이 적용되는지 결정할 수 있다. 예측부는 각 예측 모드에 대한 설명에서 후술하는 바와 같이 예측 모드 정보와 같이 예측에 관한 다양한 정보를 생성하여 엔트로피 인코딩부로 전달할 수 있다. 예측에 관한 정보는 엔트로피 인코딩부에서 인코딩되 어 비트스트림 형태로 출력될 수 있다. 인트라 예측부는 현재 픽처 내의 샘플들을 참조하여 현재 블록을 예측할 수 있다. 참조되는 샘플들은 예측 모드에 따라 상기 현재 블록의 주변(neighbor)에 위치할 수 있고, 또는 떨어져서 위치할 수도 있다. 인트라 예 측에서 예측 모드들은 복수의 비방향성 모드와 복수의 방향성 모드를 포함할 수 있다. 비방향성 모드는 예를 들 어 DC 모드 및 플래너 모드(planar 모드)를 포함할 수 있다. 방향성 모드는 예측 방향의 세밀한 정도에 따라 예 를 들어 33개의 방향성 예측 모드 또는 65개의 방향성 예측 모드를 포함할 수 있다. 다만, 이는 예시로서 설정 에 따라 그 이상 또는 그 이하의 개수의 방향성 예측 모드들이 사용될 수 있다. 인트라 예측부는 주변 블 록에 적용된 예측 모드를 이용하여, 현재 블록에 적용되는 예측 모드를 결정할 수도 있다. 인터 예측부는 참조 픽처 상에서 움직임 벡터에 의해 특정되는 참조 블록(참조 샘플 어레이)을 기반으로, 현재 블록에 대한 예측된 블록을 유도할 수 있다. 이때, 인터 예측 모드에서 전송되는 움직임 정보의 양을 줄이 기 위해 주변 블록과 현재 블록 간의 움직임 정보의 상관성에 기초하여 움직임 정보를 블록, 서브블록 또는 샘 플 단위로 예측할 수 있다. 움직임 정보는 움직임 벡터 및 참조 픽처 인덱스를 포함할 수 있다. 움직임 정보는 인터 예측 방향(L0 예측, L1 예측, Bi 예측 등) 정보를 더 포함할 수 있다. 인터 예측의 경우, 주변 블록은 현 재 픽처 내에 존재하는 공간적 주변 블록(spatial neighboring block)과 참조 픽처에 존재하는 시간적 주변 블 록(temporal neighboring block)을 포함할 수 있다. 참조 블록을 포함하는 참조 픽처와 시간적 주변 블록을 포 함하는 참조 픽처는 동일할 수도 있고, 다를 수도 있다. 시간적 주변 블록은 동일 위치 참조 블록(collocated reference block), 동일 위치 CU(colCU) 등의 이름으로 불릴 수 있으며, 시간적 주변 블록을 포함하는 참조 픽 처는 동일 위치 픽처(collocated picture, colPic)라고 불릴 수도 있다. 예를 들어, 인터 예측부는 주변 블록들을 기반으로 움직임 정보 후보 리스트를 구성하고, 현재 블록의 움직임 벡터 및/또는 참조 픽처 인덱스를 도출하기 위하여 어떤 후보가 사용되는지를 지시하는 정보를 생성할 수 있다. 다양한 예측 모드를 기반으로 인 터 예측이 수행될 수 있으며, 예를 들어 스킵 모드와 머지 모드의 경우에, 인터 예측부는 주변 블록의 움 직임 정보를 현재 블록의 움직임 정보로 이용할 수 있다. 스킵 모드의 경우, 머지 모드와 달리 레지듀얼 신호가 전송되지 않을 수 있다. 움직임 정보 예측(motion vector prediction, MVP) 모드의 경우, 주변 블록의 움직임 벡터를 움직임 벡터 예측자(motion vector predictor)로 이용하고, 움직임 벡터 차분(motion vector difference)을 시그널링함으로써 현재 블록의 움직임 벡터를 지시할 수 있다. 인터 예측부 또는 인트라 예측부를 통해 생성된 예측 신호는 복원 신호를 생성하기 위해 이용되거나 레지듀얼 신호를 생성하기 위해 이용될 수 있다. 변환부는 레지듀얼 신호에 변환 기법을 적용하여 변환 계수들(transform coefficients)를 생성할 수 있다. 예를 들어, 변환 기법은 DCT(discrete cosine transform), DST(discrete sine transform), KLT(Karhunen- Loeve transform), GBT(graph-based transform), 또는 CNT(conditionally non-linear transform) 중 적어도 하나를 포함할 수 있다. 여기서, GBT는 픽셀 간의 관계 정보를 그래프로 표현한다고 할 때 이 그래프로부터 얻 어진 변환을 의미한다. CNT는 이전에 복원된 모든 픽셀(all previously reconstructed pixel)를 이용하여 예측 신호를 생성하고 그에 기초하여 획득되는 변환을 의미한다. 또한, 변환 과정은 정사각형의 동일한 크기를 갖는 픽셀 블록에 적용될 수도 있고, 정사각형이 아닌 가변 크기의 블록에도 적용될 수 있다. 양자화부는 변환 계수들을 양자화하여 엔트로피 인코딩부로 전송되고, 엔트로피 인코딩부는 양 자화된 신호(양자화된 변환 계수들에 관한 정보)를 인코딩하여 비트스트림으로 출력할 수 있다. 양자화된 변환 계수들에 관한 정보는 레지듀얼 정보라고 불릴 수 있다. 양자화부는 계수 스캔 순서(scan order)를 기반으 로 블록 형태의 양자화된 변환 계수들을 1차원 벡터 형태로 재정렬할 수 있고, 1차원 벡터 형태의 양자화된 변 환 계수들을 기반으로 상기 양자화된 변환 계수들에 관한 정보를 생성할 수도 있다. 엔트로피 인코딩부는 예를 들어 지수 골롬(exponential Golomb), CAVLC(context-adaptive variable length coding), CABAC(context-adaptive binary arithmetic coding)과 같은 다양한 인코딩 방법을 수행할 수 있다. 엔트로피 인코딩부는 양자화된 변환 계수들 외 비디오/이미지 복원에 필요한 정보들(예컨대 신택스 요소들(syntax elements)의 값 등)을 함께 또는 별도로 인코딩할 수도 있다. 인코딩된 정보(예: 비디오/영상 정보)는 비트스트 림 형태로 NAL(network abstraction layer) 유닛 단위로 전송 또는 저장될 수 있다. 비트스트림은 네트워크를 통하여 전송될 수 있고, 또는 디지털 저장매체에 저장될 수 있다. 여기서 네트워크는 방송망 및/또는 통신망 등 을 포함할 수 있고, 디지털 저장매체는 USB, SD, CD, DVD, 블루레이, HDD, SSD 등 다양한 저장매체를 포함할 수 있다. 엔트로피 인코딩부로부터 출력된 신호는 전송하는 전송부(미도시) 및/또는 저장하는 저장부(미도 시)가 인코딩 장치의 내/외부 엘리먼트로서 구성될 수 있고, 또는 전송부는 엔트로피 인코딩부의 구 성요소일 수도 있다. 양자화부로부터 출력된 양자화된 변환 계수들은 예측 신호를 생성하기 위해 이용될 수 있다. 예를 들어, 양자화된 변환 계수들에 대하여 루프 내의 역양자화부 및 역변환부를 통해 역양자화 및 역변환을 적 용함으로써 레지듀얼 신호가 복원될 수 있다. 가산부는 복원된 레지듀얼 신호를 인터 예측부 또는 인 트라 예측부로부터 출력된 예측 신호에 더함으로써 복원(reconstructed) 신호(복원 픽처, 복원 블록, 복원 샘플 어레이)가 생성될 수 있다. 스킵 모드가 적용된 경우와 같이 처리 대상 블록에 대한 레지듀얼이 없는 경우, 예측된 블록이 복원 블록으로 사용될 수 있다. 가산부는 복원부 또는 복원 블록 생성부로 지칭될 수 있다. 복원 신호는 현재 픽처 내 다음 처리 대상 블록의 인트라 예측을 위하여 사용될 수 있고, 후술하는 바와 같이 필터링을 거쳐서 다음 픽처의 인터 예측을 위하여 사용될 수도 있다. 필터링부는 복원 신호에 필터링을 적용하여 주관적/객관적 화질을 향상시킬 수 있다. 예를 들어 필터링부 는 복원 픽처에 다양한 필터링 방법을 적용하여 수정된(modified) 복원 픽처를 생성할 수 있고, 수정된 복 원 픽처를 복호 픽처 버퍼에 전송할 수 있다. 다양한 필터링 방법은 예를 들어, 디블록킹 필터링, 샘플 적 응적 오프셋(sample adaptive offset), 적응적 루프 필터(adaptive loop fil-ter), 양방향 필터(bilateral filter)를 포함할 수 있다. 필터링부는 각 필터링 방법에 대한 설명에서 후술하는 바와 같이 필터링에 관 한 다양한 정보를 생성하여 엔트로피 인코딩부로 전달할 수 있다. 필터링 관한 정보는 엔트로피 인코딩부 에서 인코딩되어 비트스트림 형태로 출력될 수 있다. 복호 픽처 버퍼에 전송된 수정된 복원 픽처는 인터 예측부에서 참조 픽처로 사용될 수 있다. 인코딩 장치는 이를 통하여 인터 예측이 적용되는 경우, 인코딩 장치와 디코딩 장치에서의 예측 미스매 치를 피할 수 있고, 부호화 효율도 향상시킬 수 있다. 복호 픽처 버퍼는 수정된 복원 픽처를 인터 예측부에서의 참조 픽처로 사용하기 위해 저장할 수 있다. *도 3은 본 명세서의 실시예로서, 영상 신호의 디코딩을 위한 디코딩 장치의 개략적인 블록도를 나타낸다. 도 3을 참조하면, 디코딩 장치는 엔트로피 디코딩부, 역양자화부, 역변환부, 가산부, 필터링부, 메모리, 인터 예측부 및 인트라 예측부를 포함하여 구성될 수 있다. 인터 예측 부 및 인트라 예측부는 예측부로 통칭될 수 있다. 즉, 예측부는 인터 예측부 및 인트라 예측부 를 포함할 수 있다. 역양자화부와 역변환부는 레지듀얼 처리부로 통칭될 수 있다. 즉, 레지듀얼 처리부는 역양자화부와 역변환부을 포함할 수 있다. 엔트로피 디코딩부, 역양자화부, 역변환부, 가산부, 필터링부, 인터 예측부 및 인트라 예측부는 실시예에 따라 하나의 하드웨어 컴포넌트(예를 들어 디코더 또는 프로세서)에 의하여 구성될 수 있다. 또한 복호 픽처 버퍼은 실 시예에 따라 하나의 하드웨어 컴포넌트(예를 들어 메모리 또는 디지털 저장 매체)에 의하여 구현될 수 있다. 또 한, 메모리는 DPB를 포함할 수 있고, 디지털 저장 매체에 의해 구성될 수도 있다. 비디오/이미지 정보를 포함하는 비트스트림이 입력되면, 디코딩 장치는 도 2의 인코딩 장치에서 비디 오/이미지 정보가 처리된 프로세스에 대응하여 영상을 복원할 수 있다. 예를 들어, 디코딩 장치는 인코딩 장치에서 적용된 처리 유닛을 이용하여 디코딩을 수행할 수 있다. 따라서 디코딩시 처리 유닛은, 예를 들 어, 코딩 유닛일 수 있고, 코딩 유닛은 코딩 트리 유닛 또는 최대 코딩 유닛으로부터 쿼드 트리 구조 및/또는 바이너리 트리 구조에 따라 분할될 수 있다. 그리고, 디코딩 장치를 통해 디코딩 및 출력된 복원 영상 신 호는 재생 장치를 통해 재생될 수 있다. 디코딩 장치는 도 2의 인코딩 장치로부터 출력된 신호를 비트스트림 형태로 수신할 수 있고, 수신된 신호는 엔트로피 디코딩부를 통해 디코딩될 수 있다. 예를 들어, 엔트로피 디코딩부는 비트스트림을 파싱하여 영상 복원(또는 픽처 복원)에 필요한 정보(예: 비디오/영상 정보)를 도출할 수 있다. 예컨대, 엔트로 피 디코딩부는 지수 골롬 부호화, CAVLC 또는 CABAC 등의 코딩 방법을 기초로 비트스트림 내 정보를 디코 딩하고, 영상 복원에 필요한 신택스 엘리먼트의 값, 레지듀얼에 관한 변환 계수의 양자화된 값 들을 출력할 수 있다. 보다 상세하게, CABAC 엔트로피 디코딩 방법은, 비트스트림에서 각 구문 요소에 해당하는 빈(bin)을 수신 하고, 디코딩 대상 구문 요소 정보와 주변 및 디코딩 대상 블록의 디코딩 정보 혹은 이전 단계에서 디코딩된 심 볼/빈의 정보를 이용하여 문맥(context) 모델을 결정하고, 결정된 문맥 모델에 따라 빈의 발생 확률을 예측하여 빈의 산술 디코딩(arithmetic decoding)를 수행하여 각 구문 요소의 값에 해당하는 심볼을 생성할 수 있다. 이 때, CABAC 엔트로피 디코딩 방법은 문맥 모델 결정 후 다음 심볼/빈의 문맥 모델을 위해 디코딩된 심볼/빈의 정 보를 이용하여 문맥 모델을 업데이트할 수 있다. 엔트로피 디코딩부에서 디코딩된 정보 중 예측에 관한 정 보는 예측부(인터 예측부 및 인트라 예측부)로 제공되고, 엔트로피 디코딩부에서 엔트로피 디코 딩이 수행된 레지듀얼 값, 즉 양자화된 변환 계수들 및 관련 파라미터 정보는 역양자화부로 입력될 수 있 다. 또한, 엔트로피 디코딩부에서 디코딩된 정보 중 필터링에 관한 정보는 필터링부로 제공될 수 있 다. 한편, 인코딩 장치로부터 출력된 신호를 수신하는 수신부(미도시)가 디코딩 장치의 내/외부 엘리 먼트로서 더 구성될 수 있고, 또는 수신부는 엔트로피 디코딩부의 구성요소일 수도 있다. 역양자화부에서는 양자화된 변환 계수들을 역양자화함으로써 변환 계수들을 출력할 수 있다. 역양자화부 는 양자화된 변환 계수들을 2차원의 블록 형태로 재정렬할 수 있다. 이 경우 인코딩 장치에서 수행된 계수 스캔 순서에 기반하여 재정렬이 수행될 수 있다. 역양자화부는 양자화 파라미터(예를 들어, 양자화 스텝 사이즈 정보)를 이용하여 양자화된 변환 계수들에 대한 역양자화를 수행하고, 변환 계수(transform coefficient)를 획득할 수 있다. 역변환부는 변환 계수에 대한 역변환을 적용함으로써 레지듀얼 신호(레지듀얼 블록, 레지듀얼 샘플 어레이)를 출력할 수 있다. 예측부는 현재 블록에 대한 예측을 수행하고, 현재 블록에 대한 예측 샘플들을 포함하는 예측된 블록(predicted block)을 생성할 수 있다. 예측부는 엔트로피 디코딩부로부터 출력된 예측에 관한 정보에 기반하여 현재 블록에 인트라 예측이 적용되는지 또는 인터 예측이 적용되는지 결정할 수 있고, 구체적인 인트라/인터 예측 모 드를 결정할 수 있다. 인트라 예측부는 현재 픽처 내의 샘플들을 참조함으로써 현재 블록을 예측할 수 있다. 참조되는 샘플들은 예측 모드에 따라 현재 블록의 주변(neighbor)에 위치할 수 있고, 또는 이격되어 위치할 수도 있다. 인트라 예 측에서 예측 모드들은 복수의 비방향성 모드와 복수의 방향성 모드를 포함할 수 있다. 인트라 예측부는 주 변 블록에 적용된 예측 모드를 이용하여, 현재 블록에 적용되는 예측 모드를 결정할 수도 있다. 인터 예측부는 참조 픽처 상에서 움직임 벡터에 의해 특정되는 참조 블록(참조 샘플 어레이)을 기반으로, 현재 블록에 대한 예측된 블록을 유도할 수 있다. 이때, 인터 예측 모드에서 전송되는 움직임 정보의 양을 줄이 기 위해 주변 블록과 현재 블록 간의 움직임 정보의 상관성에 기초하여 움직임 정보를 블록, 서브블록, 또는 샘 플 단위로 예측할 수 있다. 움직임 정보는 움직임 벡터 및 참조 픽처 인덱스를 포함할 수 있다. 움직임 정보는 인터 예측 방향(L0 예측, L1 예측, Bi 예측 등)에 대한 정보를 더 포함할 수 있다. 인터 예측의 경우, 주변 블 록은 현재 픽처 내에 존재하는 공간적 주변 블록(spatial neighboring block)과 참조 픽처에 존재하는 시간적주변 블록(temporal neighboring block)을 포함할 수 있다. 예를 들어, 인터 예측부는 주변 블록들을 기 반으로 움직임 정보 후보 리스트를 구성하고, 수신된 후보 선택 정보를 기반으로 현재 블록의 움직임 벡터 및/ 또는 참조 픽처 인덱스를 도출할 수 있다. 다양한 예측 모드를 기반으로 인터 예측이 수행될 수 있으며, 예측에 관한 정보는 현재 블록에 대한 인터 예측의 모드를 지시하는 정보를 포함할 수 있다. 가산부는 획득된 레지듀얼 신호를 인터 예측부 또는 인트라 예측부로부터 출력된 예측 신호(예 측된 블록, 예측 샘플 어레이)에 더함으로써 복원 신호(복원 픽처, 복원 블록, 복원 샘플 어레이)를 생성할 수 있다. 스킵 모드가 적용된 경우와 같이 처리 대상 블록에 대한 레지듀얼이 없는 경우, 예측된 블록이 복원 블록 으로 사용될 수 있다. 가산부는 복원부 또는 복원 블록 생성부라고 불릴 수 있다. 생성된 복원 신호는 현재 픽처 내 다음 처리 대상 블록의 인트라 예측을 위하여 사용될 수 있고, 후술하는 바와 같이 필터링을 거쳐서 다음 픽처의 인터 예 측을 위하여 사용될 수도 있다. 필터링부는 복원 신호에 필터링을 적용함으로써 주관적/객관적 화질을 향상시킬 수 있다. 예를 들어 필터 링부는 복원 픽처에 다양한 필터링 방법을 적용하여 수정된(modified) 복원 픽처를 생성할 수 있고, 수정 된 복원 픽처를 복호 픽처 버퍼에 전송할 수 있다. 다양한 필터링 방법은 예를 들어, 디블록킹 필터링, 샘 플 적응적 오프셋(sample adaptive offset, SAO), 적응적 루프 필터(adaptive loop filter, ALF), 양방향 필터 (bilateral filter) 등을 포함할 수 있다. 복호 픽쳐 버퍼에 전송된 수정된 복원 픽처는 인터 예측부에 의해 참조 픽쳐로 사용될 수 있다. 본 명세서에서, 인코딩 장치의 필터링부, 인터 예측부 및 인트라 예측부에서 설명된 실시 예들은 각각 디코딩 장치의 필터링부, 인터 예측부 및 인트라 예측부에도 동일 또는 대응되도록 적용될 수 있다. 도 4는 본 명세서의 실시예에 따른 컨텐츠 스트리밍 시스템의 구조도의 예를 도시한다. 본 명세서가 적용되는 컨텐츠 스트리밍 시스템은 크게 인코딩 서버, 스트리밍 서버, 웹 서버, 미디어 저장소, 사용자 장치 및 멀티미디어 입력 장치를 포함할 수 있다. 인코딩 서버는 스마트폰, 카메라, 캠코더 등과 같은 멀티미디어 입력 장치들로부터 입력된 컨텐츠를 디지 털 데이터로 압축하여 비트스트림을 생성하고 이를 스트리밍 서버로 전송할 수 있다. 다른 예로, 스마트폰, 카메라, 캠코더 등과 같은 멀티미디어 입력 장치들이 비트스트림을 직접 생성하는 경우, 인코딩 서버는 생략될 수 있다. 비트스트림은 본 명세서가 적용되는 인코딩 방법 또는 비트스트림 생성 방법에 의해 생성될 수 있고, 스트리밍 서버는 비트스트림을 전송 또는 수신하는 과정에서 일시적으로 비트스트림을 저장할 수 있다. 스트리밍 서버는 웹 서버를 통한 사용자 요청에 기초하여 멀티미디어 데이터를 사용자 장치에 전송하고, 웹 서버는 사용자에게 어떠한 서비스가 있는지를 알려주는 매개체 역할을 한다. 사용자가 웹 서 버에 원하는 서비스를 요청하면, 웹 서버는 이를 스트리밍 서버에 전달하고, 스트리밍 서버 는 사용자에게 멀티미디어 데이터를 전송한다. 이때, 컨텐츠 스트리밍 시스템은 별도의 제어 서버를 포함 할 수 있고, 이 경우 제어 서버는 컨텐츠 스트리밍 시스템 내 각 장치 간 명령/응답을 제어하는 역할을 한다. 스트리밍 서버는 미디어 저장소 및/또는 인코딩 서버로부터 컨텐츠를 수신할 수 있다. 예를 들 어, 스트리밍 서버는 인코딩 서버로부터 컨텐츠를 실시간으로 수신할 수 있다. 이 경우, 원활한 스트 리밍 서비스를 제공하기 위하여 스트리밍 서버는 비트스트림을 일정 시간동안 저장할 수 있다. 예를 들어, 사용자 장치는, 휴대폰, 스마트 폰(smart phone), 노트북 컴퓨터(laptop computer), 디지털방 송용 단말기, PDA(personal digital assistants), PMP(portable multimedia player), 네비게이션, 슬레이트 PC(slate PC), 태블릿 PC(tablet PC), 울트라북(ultrabook), 웨어러블 디바이스(wearable device, 예를 들어, 워치형 단말기(smartwatch), 글래스형 단말기(smart glass), HMD(head mounted display), 디지털 TV, 데스크탑 컴퓨터, 디지털 사이니지를 포함할 수 있다. 컨텐츠 스트리밍 시스템 내 각 서버들은 분산 서버로 운영될 수 있으며, 이 경우 각 서버에서 수신하는 데이터 는 분산 처리될 수 있다.*도 5는 본 명세서의 실시예에 따른 비디오 신호를 처리하기 위한 장치의 블록도의 예를 도시한다. 도 5의 비디 오 신호 처리 장치는 도 2의 인코딩 장치 또는 도 3의 디코딩 장치에 해당할 수 있다. 본 명세서의 실시예에 따른 비디오 신호 처리 장치는, 비디오 신호를 저장하는 메모리와, 상기 메모 리와 결합되면서 비디오 신호를 처리하는 프로세서를 포함할 수 있다. 본 명세서의 실시예에 따른 프로세서는 비디오 신호의 처리를 위한 적어도 하나의 프로세싱 회로로 구성될 수 있으며, 비디오 신호를 인코딩 또는 디코딩을 위한 명령어들을 실행함으로써 영상 신호를 처리할 수 있다. 즉, 프로세서는 이하 설명되는 인코딩 또는 디코딩 방법들을 실행함으로써 원본 비디오 신호를 인코딩하거 나 인코딩된 비디오 신호를 디코딩할 수 있다. 도 6은 본 명세서의 실시예에 따른 블록 분할 구조의 예로서, 도 6a는 QT(quad tree, 이하 'QT'로 지칭됨), 도 3b는 BT(binary tree, 이하 'BT'로 지칭됨), 도 3c는 TT(ternary tree, 이하 'TT'로 지칭됨) 도 3d는 AT(asymmetric tree, 이하 'TT'로 지칭됨)에 의한 블록 분할 구조들의 예를 도시한다. 비디오 코딩에서 하나의 블록은 QT 기반으로 분할될 수 있다. 또한, QT에 의해서 분할된 하나의 서브 블록(sub block)은 QT를 사용하여 재귀적으로 더 분할될 수 있다. 더 이상 QT 분할되지 않는 리프 블록(leaf block)은 BT, TT또는 AT 중 적어도 하나의 방식에 의해서 분할될 수 있다. BT는 horizontal BT (2NxN, 2NxN)과 vertical BT (Nx2N, Nx2N)의 두 가지 형태의 분할을 가질 수 있다. TT는 horizontal TT (2Nx1/2N, 2NxN, 2Nx1/2N)와 vertical TT (1/2Nx2N, Nx2N, 1/2Nx2N)의 두 가지 형태의 분할을 가질 수 있다. AT는 horizontal-up AT (2Nx1/2N, 2Nx3/2N), horizontal-down AT (2Nx3/2N, 2Nx1/2N), vertical-left AT (1/2Nx2N, 3/2Nx2N), vertical-right AT (3/2Nx2N, 1/2Nx2N)의 네 가지 형태의 분할을 가질 수 있다. 각각의 BT, TT, AT는 BT, TT, AT를 사용하여 재귀적으로 더 분할될 수 있다. 도 6a는 QT 분할의 예를 보여준다. 블록 A는 QT에 의해서 4개의 서브 블록 (A0, A1, A2, A3)으로 분할될 수 있 다. 서브 블록 A1은 다시 QT에 의해서 4개의 서브 블록 (B0, B1, B2, B3)로 분할될 수 있다. 도 6b는 BT 분할의 예를 보여준다. QT에 의해서 더 이상 분할되지 않는 블록 B3은 vertical BT (C0, C1) 또는 horizontal BT (D0, D1)으로 분할될 수 있다. 블록 C0와 같이 각각의 서브 블록은 horizontal BT (E0, E1) 또 는 vertical BT (F0, F1)의 형태와 같이 재귀적으로 더 분할될 수 있다. 도 6c는 TT 분할의 예를 보여준다. QT에 의해서 더 이상 분할되지 않는 블록 B3은 vertical TT (C0, C1, C2) 또는 horizontal TT (D0, D1, D2)으로 분할될 수 있다. 블록 C1와 같이 각각의 서브 블록은 horizontal TT (E0, E1, E2) 또는 vertical TT (F0, F1, F2)의 형태와 같이 재귀적으로 더 분할될 수 있다. 도 6d는 AT 분할의 예를 보여준다. QT에 의해서 더 이상 분할되지 않는 블록 B3은 vertical AT (C0, C1) 또는 horizontal AT (D0, D1)으로 분할 될 수 있다. 블록 C1와 같이 각각의 서브 블록은 horizontal AT (E0, E1) 또 는 vertical TT (F0, F1)의 형태와 같이 재귀적으로 더 분할 될 수 있다. 한편, BT, TT, AT 분할은 결합될 수 있다. 예를 들어, BT에 의해 분할된 서브 블록은 TT 또는 AT에 의한 분할이 가능하다. 또한, TT에 의해 분할된 서브 블록은 BT 또는 AT에 의한 분할이 가능하다. AT에 의해 분할된 서브 블 록은 BT 또는 TT에 의한 분할이 가능하다. 예를 들어, horizontal BT 분할 이후, 각각의 서브 블록이 verti-cal BT로 분할될 수 있고, 또는 vertical BT 분할 이후, 각각의 서브 블록이 horizontal BT로 분할될 수도 있다. 상 기 두 종류의 분할 방법은 분할 순서는 다르지만 최종적으로 분할되는 모양은 동일하다. 또한, 블록이 분할되면 블록을 탐색하는 순서가 다양하게 정의될 수 있다. 일반적으로, 좌측에서 우측으로, 상 단에서 하단으로 탐색을 수행하며, 블록을 탐색한다는 것은 각 분할된 서브 블록의 추가적인 블록 분할 여부를 결정하는 순서를 의미하거나, 블록이 더 이상 분할되지 않을 경우 각 서브 블록의 부호화 순서를 의미하거나, 또는 서브 블록에서 다른 이웃 블록의 정보를 참조할 때의 탐색 순서를 의미할 수 있다. 도 7 및 도 8은 인터 예측에 기반한 비디오/영상 인코딩 절차 및 인코딩 장치 내 인터 예측부를 도시한다. 인코딩 장치는 현재 블록에 대한 인터 예측을 수행한다(S710). 인코딩 장치는 현재 블록의 인터 예측 모드 및 움직임 정보를 도출하고, 현재 블록의 예측 샘플들을 생성할 수 있다. 여기서 인터 예측 모드 결정, 움 직임 정보 도출 및 예측 샘플들 생성 절차는 동시에 수행될 수도 있고, 어느 한 절차가 다른 절차보다 먼저 수 행될 수도 있다. 예를 들어, 인코딩 장치의 인터 예측부는 예측 모드 결정부, 움직임 정보 도출 부, 예측 샘플 도출부를 포함할 수 있으며, 예측 모드 결정부에서 현재 블록에 대한 예측 모드 를 결정하고, 움직임 정보 도출부에서 현재 블록의 움직임 정보를 도출하고, 예측 샘플 도출부에서현재 블록의 예측 샘플들을 도출할 수 있다. 예를 들어, 인코딩 장치의 인터 예측부는 움직임 추정 (motion estimation)을 통하여 참조 픽처들의 일정 영역(서치 영역) 내에서 상기 현재 블록과 유사한 블록을 서 치하고, 현재 블록과의 차이가 최소 또는 일정 기준 이하인 참조 블록을 도출할 수 있다. 이를 기반으로 상기 참조 블록이 위치하는 참조 픽처를 가리키는 참조 픽처 인덱스를 도출하고, 참조 블록과 현재 블록의 위치 차이 를 기반으로 움직임 벡터를 도출할 수 있다. 인코딩 장치는 다양한 예측 모드들 중 현재 블록에 대하여 적 용되는 모드를 결정할 수 있다. 인코딩 장치는 다양한 예측 모드들에 대한 RD 비용(cost)을 비교하고 현재 블록에 대한 최적의 예측 모드를 결정할 수 있다. 예를 들어, 인코딩 장치는 현재 블록에 스킵 모드 또는 머지 모드가 적용되는 경우, 후술하는 머지 후보 리스트를 구성하고, 머지 후보 리스트에 포함된 머지 후보들이 가리키는 참조 블록들 중 현재 블록과 중 현재 블록과의 차이가 최소 또는 일정 기준 이하인 참조 블록을 도출할 수 있다. 이 경우 도출된 참조 블록과 연관된 머지 후보가 선택되며, 선택된 머지 후보를 가리키는 머지 인덱스 정보가 생성되어 디코딩 장치로 시그널 링될 수 있다. 선택된 머지 후보의 움직임 정보를 이용하여 현재 블록의 움직임 정보가 도출될 수 있다. 다른 예로, 인코딩 장치는 현재 블록에 (A)MVP 모드가 적용되는 경우, 후술하는 (A)MVP 후보 리스트를 구 성하고, (A)MVP 후보 리스트에 포함된 MVP(motion vector predictor) 후보들 중 선택된 MVP 후보의 움직임 벡 터를 현재 블록의 MVP로 이용할 수 있다. 이 경우, 예를 들어, 상술한 움직임 추정에 의하여 도출된 참조 블록 을 가리키는 움직임 벡터가 현재 블록의 움직임 벡터로 이용될 수 있으며, MVP 후보들 중 현재 블록의 움직임 벡터와의 차이가 가장 작은 움직임 벡터를 갖는 MVP 후보가 선택된 MVP 후보가 될 있다. 현재 블록의 움직임 벡 터에서 MVP를 뺀 차분인 MVD(motion vector difference)가 도출될 수 있다. 이 경우 MVD에 관한 정보가 디코딩 장치로 시그널링될 수 있다. 또한, (A)MVP 모드가 적용되는 경우, 참조 픽처 인덱스의 값은 참조 픽처 인 덱스 정보 구성되어 별도로 디코딩 장치로 시그널링될 수 있다. 인코딩 장치는 예측 샘플들을 기반으로 레지듀얼 샘플들을 도출할 수 있다(S720). 인코딩 장치는 현 재 블록의 원본 샘플들과 예측 샘플들의 비교를 통하여 레지듀얼 샘플들을 도출할 수 있다. 인코딩 장치는 예측 정보 및 레지듀얼 정보를 포함하는 영상 정보를 인코딩한다(S730). 인코딩 장치 는 인코딩된 영상 정보를 비트스트림 형태로 출력할 수 있다. 예측 정보는 예측 절차에 관련된 정보들로서 예측 모드 정보(예: skip flag, merge flag, 또는 mode index) 및 움직임 정보를 포함할 수 있다. 움직임 정보는 움 직임 벡터를 도출하기 위한 정보인 후보 선택 정보(예: merge index, mvp flag, 또는 mvp index)를 포함할 수 있다. 또한 움직임 정보는 상술한 MVD에 관한 정보 및/또는 참조 픽처 인덱스 정보를 포함할 수 있다. 또한 움 직임 정보는 L0 예측, L1 예측, 또는 쌍(bi) 예측이 적용되는지 여부를 나타내는 정보를 포함할 수 있다. 레지 듀얼 정보는 레지듀얼 샘플들에 관한 정보이다. 레지듀얼 정보는 레지듀얼 샘플들에 대한 양자화된 변환 계수들 에 관한 정보를 포함할 수 있다. 출력된 비트스트림은 (디지털) 저장매체에 저장되어 디코딩 장치로 전달될 수 있고, 또는 네트워크를 통하여 디 코딩 장치로 전달될 수도 있다. 한편, 상술한 바와 같이 인코딩 장치는 상기 참조 샘플들 및 상기 레지듀얼 샘플들을 기반으로 복원 픽처(복원 샘플들 및 복원 블록 포함)를 생성할 수 있다. 이는 디코딩 장치에서 수행되는 것과 동일한 예측 결과를 인코딩 장치에서 도출하기 위함이며, 이를 통하여 코딩 효율을 높일 수 있기 때문이다. 따라서, 인코딩 장 치는 복원 픽처(또는 복원 샘플들, 복원 블록)을 메모리에 저장하고, 인터 예측을 위한 참조 픽처로 활용 할 수 있다. 복원 픽처에 인루프 필터링 절차 등이 더 적용될 수 있음은 상술한 바와 같다. 도 9 및 도 10은 인터 예측에 기반한 비디오/영상 디코딩 절차 및 디코딩 장치 내 인터 예측부를 도시한다. 디코딩 장치는 인코딩 장치에서 수행된 동작과 대응되는 동작을 수행할 수 있다. 디코딩 장치는 수신된 예측 정보를 기반으로 현재 블록에 예측을 수행하고 예측 샘플들을 도출할 수 있다. 구체적으로 디코딩 장치는 수신된 예측 정보를 기반으로 현재 블록에 대한 예측 모드를 결정할 수 있다 (S910). 디코딩 장치는 예측 정보 내의 예측 모드 정보를 기반으로 현재 블록에 어떤 인터 예측 모드가 적 용되는지 결정할 수 있다. 예를 들어, 디코딩 장치는 머지 플래그(merge flag)를 기반으로 현재 블록에 머지 모드가 적용되지 또는 (A)MVP 모드가 결정되는지 여부를 결정할 수 있다. 또는 디코딩 장치는 모드 인덱스(mode index)를 기반으 로 다양한 인터 예측 모드 후보들 중 하나를 선택할 수 있다. 인터 예측 모드 후보들은 스킵 모드, 머지 모드및/또는 (A)MVP 모드를 포함할 수 있고, 또는 후술하는 다양한 인터 예측 모드들을 포함할 수 있다. 디코딩 장치는 결정된 인터 예측 모드를 기반으로 현재 블록의 움직임 정보를 도출한다(S920). 예를 들어, 디코딩 장치는 현재 블록에 스킵 모드 또는 머지 모드가 적용되는 경우, 후술하는 머지 후보 리스트를 구 성하고, 머지 후보 리스트에 포함된 머지 후보들이 중 하나의 머지 후보를 선택할 수 있다. 머지 후보의 선택은 머지 인덱스(merge index)를 기반으로 수행될 수 있다. 선택된 머지 후보의 움직임 정보로부터 현재 블록의 움 직임 정보가 도출할 수 있다. 선택된 머지 후보의 움직임 정보가 현재 블록의 움직임 정보로 이용될 수 있다. 다른 예로, 디코딩 장치는, 현재 블록에 (A)MVP 모드가 적용되는 경우, 후술하는 (A)MVP 후보 리스트를 구 성하고, (A)MVP 후보 리스트에 포함된 MVP 후보들 중 선택된 MVP 후보의 움직임 벡터를 현재 블록의 MVP로 이용 할 수 있다. MVP의 선택은 상술한 선택 정보(MVP 플래그 또는 MVP 인덱스)를 기반으로 수행될 수 있다. 이 경우 디코딩 장치는 MVD에 관한 정보를 기반으로 상기 현재 블록의 MVD를 도출할 수 있으며, 현재 블록의 MVP와 MVD를 기반으로 현재 블록의 움직임 벡터를 도출할 수 있다. 또한, 디코딩 장치는 참조 픽처 인덱스 정보 를 기반으로 현재 블록의 참조 픽처 인덱스를 도출할 수 있다. 현재 블록에 관한 참조 픽처 리스트 내에서 참조 픽처 인덱스가 가리키는 픽처가 현재 블록의 인터 예측을 위하여 참조되는 참조 픽처로 도출될 수 있다. 한편, 후술하는 바와 같이 후보 리스트 구성 없이 상기 현재 블록의 움직임 정보가 도출될 수 있으며, 이 경우 후술하는 예측 모드에서 개시된 절차에 따라 현재 블록의 움직임 정보가 도출될 수 있다. 이 경우 상술한 바와 같은 후보 리스트 구성은 생략될 수 있다. 디코딩 장치는 현재 블록의 움직임 정보를 기반으로 현재 블록에 대한 예측 샘플들을 생성할 수 있다 (S930). 이 경우 디코딩 장치는 현재 블록의 참조 픽처 인덱스를 기반으로 참조 픽처를 도출하고, 현재 블 록의 움직임 벡터가 참조 픽처 상에서 가리키는 참조 블록의 샘플들을 이용하여 현재 블록의 예측 샘플들을 도 출할 수 있다. 이 경우 후술하는 바와 같이 경우에 따라 현재 블록의 예측 샘플들 중 전부 또는 일부에 대한 예 측 샘플 필터링 절차가 더 수행될 수 있다. 예를 들어, 디코딩 장치의 인터 예측부는 예측 모드 결정부, 움직임 정보 도출부, 예측 샘 플 도출부를 포함할 수 있으며, 예측 모드 결정부에서 수신된 예측 모드 정보를 기반으로 상기 현재 블록에 대한 예측 모드를 결정하고, 움직임 정보 도출부에서 수신된 움직임 정보에 관한 정보를 기반으로 상기 현재 블록의 움직임 정보(움직임 벡터 및/또는 참조 픽처 인덱스 등)를 도출하고, 예측 샘플 도출부 에서 상기 현재 블록의 예측 샘플들을 도출할 수 있다. 디코딩 장치는 수신된 레지듀얼 정보를 기반으로 상기 현재 블록에 대한 레지듀얼 샘플들을 생성한다 (S940). 디코딩 장치는 예측 샘플들 및 레지듀얼 샘플들을 기반으로 현재 블록에 대한 복원 샘플들을 생성 하고, 이를 기반으로 복원 픽처를 생성할 수 있다. (S950). 이후 상기 복원 픽처에 인루프 필터링 절차 등이 더 적용될 수 있음은 상술한 바와 같다. 상술한 바와 같이 인터 예측 절차는 인터 예측 모드 결정 단계, 결정된 예측 모드에 따른 움직임 정보 도출 단 계, 도출된 움직임 정보에 기반한 예측 수행(예측 샘플 생성) 단계를 포함할 수 있다. 인터 예측 모드 결정(Determination of inter prediction mode) 픽처 내 현재 블록의 예측을 위하여 다양한 인터 예측 모드가 사용될 수 있다. 예를 들어, 머지 모드, 스킵 모 드, MVP 모드, 어파인(Affine) 모드 등 다양한 모드가 사용될 수 있다. DMVR(decoder side motion vector refinement) 모드, AMVR(adaptive motion vector resolution) 모드 등이 부수적인 모드로 더 사용될 수 있다. 어파인 모드는 어파인 움직임 예측(affine motion prediction) 모드라고 불릴 수도 있다. MVP 모드는 AMVP(advanced motion vector prediction) 모드라고 불릴 수도 있다. 현재 블록의 인터 예측 모드를 가리키는 예측 모드 정보가 인코딩 장치로부터 디코딩 장치로 시그널링될 수 있다. 예측 모드 정보는 비트스트림에 포함되어 디코딩 장치에서 수신될 수 있다. 예측 모드 정보는 다 수의 후보 모드들 중 하나를 지시하는 인덱스 정보를 포함할 수 있다. 또는, 플래그 정보의 계층적 시그널링을 통하여 인터 예측 모드를 지시할 수도 있다. 이 경우 예측 모드 정보는 하나 이상의 플래그들을 포함할 수 있다. 예를 들어, 인코딩 장치는 스킵 플래그를 시그널링하여 스킵 모드 적용 여부를 지시하고, 스킵 모드 가 적용 안되는 경우에 머지 플래그를 시그널링하여 머지 모드 적용 여부를 지시하고, 머지 모드가 적용 안되는 경우에 MVP 모드 적용되는 것으로 지시하거나 추가적인 구분을 위한 플래그를 더 시그널링할 수도 있다. 어파인 모드는 독립적인 모드로 시그널링될 수도 있고, 또는 머지 모드 또는 MVP 모드 등에 종속적인 모드로 시그널링 될 수도 있다. 예를 들어, 어파인 모드는 후술하는 바와 같이 머지 후보 리스트 또는 MVP 후보 리스트의 하나의후보로 구성될 수도 있다. 인터 예측 모드에 따른 움직임 정보의 유도(Derivation of motion information according to inter prediction mode) 인코딩 장치 또는 디코딩 장치는 현재 블록의 움직임 정보를 이용하여 인터 예측을 수행할 수 있다. 인코딩 장치는 움직임 추정(motion esti-mation) 절차를 통하여 현재 블록에 대한 최적의 움직임 정보를 도출할 수 있다. 예를 들어, 인코딩 장치는 현재 블록에 대한 원본 픽처 내 원본 블록을 이용하여 상관성 이 높은 유사한 참조 블록을 참조 픽처 내의 정해진 탐색 범위 내에서 분수 픽셀 단위로 탐색할 수 있고, 이를 통하여 움직임 정보를 도출할 수 있다. 블록의 유사성은 위상(phase) 기반 샘플 값들의 차를 기반으로 도출될 수 있다. 예를 들어, 블록의 유사성은 현재 블록(또는 현재 블록의 템플릿)과 참조 블록(또는 참조 블록의 템플 릿) 간 SAD(sum of absolute difference)를 기반으로 계산될 수 있다. 이 경우 탐색 영역 내 SAD가 가장 작은 참조 블록을 기반으로 움직임 정보를 도출할 수 있다. 도출된 움직임 정보는 인터 예측 모드 기반으로 여러 방 법에 따라 디코딩 장치로 시그널링될 수 있다. 머지 모드 및 스킵 모드 머지 모드(merge mode)가 적용되는 경우, 현재 예측 블록의 움직임 정보가 직접적으로 전송되지 않고, 주변 예 측 블록의 움직임 정보를 이용하여 현재 예측 블록의 움직임 정보를 유도하게 된다. 따라서, 인코딩 장치 는 머지 모드를 이용하였음을 알려주는 플래그 정보 및 주변의 어떤 예측 블록을 이용하였는지를 알려주는 머지 인덱스를 전송함으로써 현재 예측 블록의 움직임 정보를 지시할 수 있다. 인코딩 장치는 머지 모드를 수행하기 위해서 현재 예측 블록의 움직임 정보를 유도하기 위해 이용되는 머 지 후보 블록(merge candidate block)을 서치하여야 한다. 예를 들어, 머지 후보 블록은 최대 5개까지 이용될 수 있으나, 본 명세서는 이에 한정되지 않는다. 그리고, 머지 후보 블록의 최대 개수는 슬라이스 헤더에서 전송 될 수 있으며, 본 명세서는 이에 한정되지 않는다. 머지 후보 블록들을 찾은 후, 인코딩 장치는 머지 후보 리스트를 생성할 수 있고, 이들 중 가장 작은 비용을 갖는 머지 후보 블록을 최종 머지 후보 블록으로 선택할 수 있다. 본 명세서는 머지 후보 리스트를 구성하는 머지 후보 블록에 대한 다양한 실시예를 제공한다. 머지 후보 리스트는 예를 들어 5개의 머지 후보 블록을 이용할 수 있다. 예를 들어, 4개의 공간적 머지 후보 (spatial merge candidate)와 1개의 시간적 머지 후보(temporal merge candidate)를 이용할 수 있다. 도 11은 현재 블록에 대한 공간적 머지 후보 구성의 예를 도시한다. 도 11을 참조하면, 현재 블록의 예측을 위하여 좌측 이웃 블록(A1), 좌하측(bottom-left) 이웃 블록(A2), 우상 측(top-right) 이웃 블록(B0), 상측 이웃 블록(B1), 좌상측(top-left) 이웃 블록(B2) 중 적어도 하나가 사용될 수 있다. 현재 블록에 대한 머지 후보 리스트는 도 12과 같은 절차를 기반으로 구성될 수 있다. 도 12는 본 명세서의 실시예에 따른 머지 후보 리스트 구성을 위한 흐름도의 예를 도시한다. 코딩 장치(인코딩 장치 또는 디코딩 장치)는 현재 블록의 공간적 주변 블록들을 탐색하여 도출된 공 간적 머지 후보들을 머지 후보 리스트에 삽입한다(S1210). 예를 들어, 공간적 주변 블록들은 현재 블록의 좌하 측 코너 주변 블록, 좌측 주변 블록, 우상측 코너 주변 블록, 상측 주변 블록, 좌상측 코너 주변 블록들을 포함 할 수 있다. 다만, 이는 예시로서 상술한 공간적 주변 블록들 이외에도 우측 주변 블록, 하측 주변 블록, 우하 측 주변 블록 등 추가적인 주변 블록들이 더 상기 공간적 주변 블록들로 사용될 수 있다. 코딩 장치는 공간적 주변 블록들을 우선순위를 기반으로 탐색하여 가용한 블록들을 검출하고, 검출된 블록들의 움직임 정보를 공간 적 머지 후보들로 도출할 수 있다. 예를 들어, 인코딩 장치 또는 디코딩 장치는 도 11에 도시된 5개 의 블록들을 A1, B1, B0, A0, B2의 순서대로 탐색하여, 가용한 후보들을 순차적으로 인덱싱하여 머지 후보 리스 트로 구성할 수 있다. 코딩 장치는 현재 블록의 시간적 주변 블록을 탐색하여 도출된 시간적 머지 후보를 상기 머지 후보 리스트에 삽 입한다(S1220). 시간적 주변 블록은 현재 블록이 위치하는 현재 픽처와 다른 픽처인 참조 픽처 상에 위치할 수 있다. 시간적 주변 블록이 위치하는 참조 픽처는 동일 위치 픽처(collocated picture) 또는 콜 픽처(col pic- ture)라고 불릴 수 있다. 시간적 주변 블록은 콜 픽처 상에서의 현재 블록에 대한 동일 위치 블록(co-located block)의 우하측 코너 주변 블록 및 우하측 센터 블록의 순서로 탐색될 수 있다. 한편, 움직임 데이터 압축 (motion data compression)이 적용되는 경우, 콜 픽처에 일정 저장 단위마다 특정 움직임 정보를 대표 움직임정보로 저장할 수 있다. 이 경우 상기 일정 저장 단위 내의 모든 블록에 대한 움직임 정보를 저장할 필요가 없 으며 이를 통하여 움직임 데이터 압축 효과를 얻을 수 있다. 이 경우, 일정 저장 단위는 예를 들어 16x16 샘플 단위, 또는 8x8 샘플 단위 등으로 미리 정해질 수도 있고, 또는 인코딩 장치로부터 디코딩 장치로 일 정 저장 단위에 대한 사이즈 정보가 시그널링될 수도 있다. 움직임 데이터 압축이 적용되는 경우 시간적 주변 블록의 움직임 정보는 시간적 주변 블록이 위치하는 일정 저장 단위의 대표 움직임 정보로 대체될 수 있다. 즉, 이 경우 구현 측면에서 보면, 시간적 주변 블록의 좌표에 위치하는 예측 블록이 아닌, 시간적 주변 블록의 좌표 (좌상단 샘플 포지션)를 기반으로 일정 값만큼 산술적 우측 시프트 후 산술적 좌측 시프트 한 위치를 커버하는 예측 블록의 움직임 정보를 기반으로 시간적 머지 후보가 도출될 수 있다. 예를 들어, 일정 저장 단위가 2nx2n 샘플 단위인 경우, 시간적 주변 블록의 좌표가 (xTnb, yTnb)라 하면, 수정된 위치인 ((xTnb >> n) << n), (yTnb >> n) << n))에 위치하는 예측 블록의 움직임 정보가 시간적 머지 후보를 위하여 사용될 수 있다. 구체적 으로 예를 들어, 일정 저장 단위가 16x16 샘플 단위인 경우, 시간적 주변 블록의 좌표가 (xTnb, yTnb)라 하면, 수정된 위치인 ((xTnb >> 4) << 4), (yTnb >> 4) << 4))에 위치하는 예측 블록의 움직임 정보가 시간적 머지 후보를 위하여 사용될 수 있다. 또는 예를 들어, 일정 저장 단위가 8x8 샘플 단위인 경우, 시간적 주변 블록의 좌표가 (xTnb, yTnb)라 하면, 수정된 위치인 ((xTnb >> 3) << 3), (yTnb >> 3) << 3))에 위치하는 예측 블록의 움직임 정보가 시간적 머지 후보를 위하여 사용될 수 있다. 코딩 장치는 현재 머지 후보들의 개수가 최대 머지 후보들의 개수보다 작은지 여부를 확인할 수 있다(S1230). 최대 머지 후보들의 개수는 미리 정의되거나 인코딩 장치에서 디코딩 장치로 시그널링될 수 있다. 예 를 들어, 인코딩 장치는 최대 머지 후보들의 개수에 관한 정보를 생성하고, 인코딩하여 비트스트림 형태로 디코딩 장치로 전달할 수 있다. 최대 머지 후보들의 개수가 다 채워지면 이후의 후보 추가 과정은 진행하 지 않을 수 있다. 확인 결과 현재 머지 후보들의 개수가 상기 최대 머지 후보들의 개수보다 작은 경우, 코딩 장치는 추가 머지 후 보를 머지 후보 리스트에 삽입한다(S1240). 추가 머지 후보는 예를 들어 ATMVP(adaptive temporal motion vector prediction), 결합된 양방향 예측(combined bi-predictive) 머지 후보(현재 슬라이스의 슬라이스 타입 이 B 타입인 경우) 및/또는 영 벡터(zero vector) 머지 후보를 포함할 수 있다. 도 13은 예측 후보 리스트(MVP 후보 리스트)를 구성하기 위한 흐름도의 예를 도시한다. MVP(motion vector prediction) 모드가 적용되는 경우, 복원된 공간적 주변 블록(예를 들어, 도 11의 주변 블 록)의 움직임 벡터 및/또는 시간적 주변 블록(또는 Col 블록)에 대응하는 움직임 벡터를 이용하여, 움직임 벡터 예측자(motion vector pre-dictor, MVP) 후보 리스트가 생성될 수 있다. 즉, 복원된 공간적 주변 블록의 움직임 벡터 및/또는 시간적 주변 블록에 대응하는 움직임 벡터는 움직임 벡터 예측자 후보로 사용될 수 있다. 상기 예 측에 관한 정보는 상기 리스트에 포함된 움직임 벡터 예측자 후보들 중에서 선택된 최적의 움직임 벡터 예측자 후보를 지시하는 선택 정보(예: MVP 플래그 또는 MVP 인덱스)를 포함할 수 있다. 이 때, 예측부는 상기 선택 정 보를 이용하여, 움직임 벡터 후보 리스트에 포함된 움직임 벡터 예측자 후보들 중에서, 현재 블록의 움직임 벡 터 예측자를 선택할 수 있다. 인코딩 장치의 예측부는 현재 블록의 움직임 벡터와 움직임 벡터 예측자 간 의 움직임 벡터 차분(MVD)을 구할 수 있고, 이를 인코딩하여 비트스트림 형태로 출력할 수 있다. 즉, MVD는 현 재 블록의 움직임 벡터에서 상기 움직임 벡터 예측자를 뺀 값으로 구해질 수 있다. 이 때, 디코딩 장치의 예측 부는 상기 예측에 관한 정보에 포함된 움직임 벡터 차분을 획득하고, 상기 움직임 벡터 차분과 상기 움직임 벡 터 예측자의 가산을 통해 현재 블록의 상기 움직임 벡터를 도출할 수 있다. 디코딩 장치의 예측부는 참조 픽처 를 지시하는 참조 픽처 인덱스 등을 상기 예측에 관한 정보로부터 획득 또는 유도할 수 있다. 예를 들어, 움직 임 벡터 예측자 후보 리스트는 도 13과 같이 구성될 수 있다. 도 13을 참조하면, 코딩 장치는 움직임 벡터 예측을 위한 공간적 후보 블록을 탐색하여 예측 후보 리스트에 삽 입한다(S1310). 예를 들어, 코딩 장치는 정해진 탐색 순서에 따라 주변 블록들에 대한 탐색을 수행하고, 공간적 후보 블록에 대한 조건을 만족하는 주변 블록의 정보를 예측 후보 리스트(MVP 후보 리스트)에 추가할 수 있다. 공간적 후보 블록 리스트를 구성한 후, 코딩 장치는 예측 후보 리스트에 포함된 공간적 후보 리스트의 개수와 기 설정된 기준 개수(예: 2)를 비교한다(S1320). 예측 후보 리스트에 포함된 공간적 후보 리스트의 개수가 기준 개수(예: 2)보다 크거나 같은 경우, 코딩 장치는 예측 후보 리스트의 구성을 종료할 수 있다. 그러나, 예측 후보 리스트에 포함된 공간적 후보 리스트의 개수가 기준 개수(예: 2)보다 작은 경우, 코딩 장치 는 시간적 후보 블록을 탐색하여 예측 후보 리스트에 추가 삽입하고(S1330), 시간적 후보 블록이 사용 불가능한 경우, 제로 움직임 벡터를 예측 후보 리스트에 추가한다(S1340).예측 샘플 생성(Generation of prediction sample) 예측 모드에 따라 도출된 움직임 정보를 기반으로 현재 블록에 대한 예측된 블록이 도출될 수 있다. 예측된 블 록은 현재 블록의 예측 샘플들(예측 샘플 어레이)을 포함할 수 있다. 현재 블록의 움직임 벡터가 분수 샘플 단 위를 가리키는 경우, 보간(interpolation) 절차가 수행될 수 있으며, 이를 통하여 참조 픽처 내에서 분수 샘플 단위의 참조 샘플들을 기반으로 상기 현재 블록의 예측 샘플들이 도출될 수 있다. 현재 블록에 어파인(affine) 인터 예측이 적용되는 경우, 샘플/서브블록 단위 움직임 벡터(motion vector)에 기반하여 예측 샘플들이 생성될 수 있다. 양방향(bi-direction) 예측이 적용되는 경우, 제1 방향 예측(예: L0 예측)을 기반으로 도출된 예측 샘 플들과 제2 방향 예측(예: L1 예측)을 기반으로 도출된 예측 샘플들의 (위상에 따른) 가중합을 통하여 최종 예 측 샘플들이 도출될 수 있다. 도출된 예측 샘플들을 기반으로 복원 샘플들 및 복원 픽처가 생성될 수 있고, 이 후 인루프 필터링 등의 절차가 수행될 수 있음은 전술한 바와 같다. 어파인 모션 예측(Affine motion prediction) 도 14는 본 발명의 실시예에 따른 모션 모델들(motion models)의 예를 도시한다. 종래의 영상 압축 기술(예컨대, HEVC(high efficiency video coding))은 부호화 블록의 모션(motion)을 표현하 기 위해 하나의 모션 벡터(motion vector)를 사용한다. 비록 블록 마다 하나의 모션 벡터를 사용하는 방식이 블 록 단위의 최적 모션을 표현했을 수 있지만, 실제 각 화소의 최적의 모션은 아닐 수 있다. 따라서, 화소 단위에 서 최적의 모션 벡터를 결정할 수 있다면 부호화 효율을 높일 수 있을 것이다. 그리하여, 본 발명의 실시예는 다수의 모션 모델(multi motion model)을 사용하여 비디오 신호를 부호화 또는 복호화하는 모션 예측(motion prediction) 방법에 대하여 설명한다. 특히, 2개 내지 4개의 제어점의 모션 벡터를 이용하여 블록의 각 화소 단 위 또는 서브 블록 단위에서 모션 벡터를 표현할 수 있으며, 이러한 복수의 제어점의 모션 벡터를 사용한 예측 기법은 어파인 모션 예측(affine motion prediction), 어파인 예측(affine prediction) 등으로 지칭될 수 있다. 본 발명의 실시예에 따른 어파인 모션 모델(affine motion model)은 도 14에 도시된 바와 같은 4개의 모션 모델 을 표현할 수 있다. Affine motion model이 표현할 수 있는 motion 중 3가지 motion(translation, scale, rotate)dmf 표현하는 affine motion model을 similarity(or simplified) affine motion model이라고 지칭하며, 본 발명의 실시예들을 설명함에 있어서, 설명의 편의를 위해 similarity(or simplified) affine motion model 을 기준으로 설명하나, 본 발명이 이에 한정되지는 않는다. 도 15는 본 발명의 실시예에 따른 어파인 모션 예측을 위한 제어점 모션 벡터의 예를 도시한다. 도 15와 같이 어파인 모션 예측은 2개의 제어점 모션 벡터(control point motion vector, CPMV) 쌍(pair), v_0 및 v_1을 이용하여 블록이 포함하는 화소 위치(또는 서브 블록)의 모션 벡터를 결정할 수 있다. 이때 모션 벡터 들의 집합은 어파인 모션 벡터 필드(motion vector field, MVF)로 지칭될 수 있다. 이때, 어파인 모션 벡터 필 드는 아래의 수학식 1이 이용하여 결정될 수 있다. 수학식 1"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "수학식 1에서, v_0(v_0={v_0x,v_0y})는 현재 블록의 좌상측 위치의 제1 제어점의 모션 벡터(CPMV0)를 나 타내고, v_1(v_1={v_1x,v_1y})은 현재 블록의 우상측 위치의 제2 제어점의 모션 벡터(CPMV1)를 나타낸다. 그리고, w는 현재 블록의 너비(width)를 나타낸다. v(v={v_x,v_y})는 {x,y} 위치에서의 모션 벡터를 나타낸다. 서브 블록(또는 화소) 단위의 모션 벡터는 상기 수학식 1을 이용하여 유도될 수 있다. 일 실 시예에서 모션 벡터 정밀도는 1/16 정밀도로 라운딩될 수 있다. 도 16은 본 발명의 실시예에 따른 어파인 모션 예측이 적용된 블록의 각 서브 블록 별 모션 벡터의 예를 도시한 다.도 16을 참조하면, 부호화 또는 복호화 과정에서 어파인 모션 벡터 필드(MVF)는 화소 단위 혹은 블록 단위에서 결정될 수 있다. 즉, 어파인 움직임 예측에서 현재 블록의 움직임 벡터는 화소 단위 또는 서브 블록 단위로 유 도될 수 있다. 화소 단위로 어파인 모션 벡터 필드가 결정되는 경우 각 화소값을 기준으로 모션 벡터가 얻어지고, 블록 단위의 경우 블록의 중앙 화소값을 기준으로 해당 블록의 모션 벡터가 얻어질 수 있다. 본 문서에서, 도 16과 같이 어 파인 모션 벡터 필드(MVF)가 4*4 블록 단위에서 결정되는 경우가 가정된다. 다만, 이것은 설명의 편의를 위한 것이지 본 발명의 실시예가 한정되는 것은 아니다. 도 16은 부호화 블록이 16*16개의 샘플로 구성되고, 4*4 사 이즈의 블록 단위로 어파인 모션 벡터 필드(MVF)가 결정되는 경우의 예를 도시한다. 어파인 모션 예측(affine motion prediction)은 어파인 머지 모드(affine merge mode 또는 AF_MERGE)와 어파인 인터 모드(affine inter mode 또는 AF_INTER)를 포함할 수 있다. AF_INTER 모드는 4개의 파라미터 기반 모션 모델을 이용하는 AF_4_INTER 모드와 6개의 파라미터 기반 모션 모델을 이용하는 AF_6_INTER 모드를 포함할 수 있다. 어파인 머지 모드(Affine merge mode) AF_MERGE는 어파인 움직임 예측으로서 코딩된 주변 블록의 어파인 움직임 모델에 따라 제어점 모션 벡터 (Control Point Motion Vector: CPMV)를 결정한다. 검색 순서에서 어파인 코딩된 주변 블록은 AF_MERGE를 위해 사용될 수 있다. 하나 이상의 인접 블록이 어파인 움직임 예측으로서 코딩될 때, 현재 블록은 AF_MERGE로서 코 딩될 수 있다. 즉, 어파인 머지 모드가 적용되는 경우, 주변 블록의 CPMV들을 이용하여 현재 블록의 CPMV들을 도출될 수 있다. 이 경우 주변 블록의 CPMV들이 그대로 현재 블록의 CPMV들로 사용될 수도 있고, 주변 블록의 CPMV들이 상기 주 변 블록의 사이즈 및 상기 현재 블록의 사이즈 등을 기반으로 수정되어 현재 블록의 CPMV들로 사용될 수 있다. 도 17은 본 발명의 실시예에 따른 어파인 머지 모드(affine merge mode)에서 어파인 모션 예측에 사용되는 주변 블록의 예를 도시한다. 어파인 머지(AF_MERGE) 모드에서, 인코더는 아래와 같은 과정과 같이 부호화를 수행할 수 있다. 스텝-1: 현재 부호화 블록의 주변 블록 A 내지 E(1710, 1720, 1730, 1740, 1750)를 알파벳 순서대로 스 캐닝(scanning)하고, 스캐닝 순서 기준 첫 번째로 어파인 예측 모드로 부호화된 블록을 어파인 머지(AF_MERGE) 의 후보 블록으로 결정 스텝-2: 결정된 후보 블록의 제어점 모션 벡터(CPMV)를 이용하여 어파인 모션 모델을 결정 스텝-3: 후보 블록의 어파인 모션 모델에 따라 현재 블록의 제어점 모션 벡터(CPMV)가 결정되고, 현재 블 록의 MVF 결정 도 18은 본 발명의 실시예에 따른 어파인 모션 예측이 적용된 주변 블록을 사용하여 어파인 모션 예측이 수행되 는 블록의 예를 도시한다. 예를 들어, 도 18과 같이 블록 A가 어파인 모드(affine mode)로 부호화된 경우, 블록 A을 후보 블 록으로 결정한 후 블록 A의 제어점 모션 벡터(CPMV)들(예컨대, v2 및 v3)를 이용하여 어파인 모션 모델 (affine motion model)을 유도한 후 현재 블록의 제어점 모션 벡터(CPMV) v0 및 v1을 결정할 수 있다. 현재 블록의 제어점 모션 벡터(CPMV)를 기반으로 하여 현재 블록의 어파인 모션 벡터 필드(MVF)가 결정되고, 부호화가 수행될 수 있다. 도 19는 본 발명의 실시예에 따른 주변 어파인 부호화 블록을 이용하여 머지 후보 리스트를 생성하는 방법을 설 명하기 위한 도면이다. 도 19를 참조하면, 어파인 머지 후보를 이용하여 CPMV 쌍을 결정하는 경우, 도 19에 도시된 바와 같은 후보가 사용될 수 있다. 도 19에서, 후보리스트의 스캔 순서는 A, B, C, D, E로 설정된 경우를 가정한다. 다만, 본 발 명이 이에 한정되는 것은 아니며, 다양한 순서로 미리 설정될 수 있다. 실시예로서, 만약, 주변 블록(즉, A, B, C, D, E)에서 이용 가능한 어파인 모드(또는 어파인 예측)로 부호화된 후보(이하, 어파인 후보로 지칭될 수 있다)의 수가 0일 때, 현재 블록의 어파인 머지 모드는 스킵될 수 있다. 만약, 이용 가능한 어파인 후보의 수가 하나인 경우(예를 들어, A), 해당 후보의 움직임 모델이 현재 블록의 제어점 모션 벡터(CPMV_0 및 CPMV_1)를 유도하는데 이용될 수 있다. 이 경우, 해당 후보를 지시하는 인덱스가 요 구(또는 코딩)되지 않을 수 있다. 만약, 이용 가능한 어파인 후보의 수가 둘 이상인 경우, 스캐닝 순서 상 2개 의 후보가 AF_MERGE에 대한 후보 리스트로 구성될 수 있다. 이 경우, 후보 리스트 내에서 선택된 후보를 지시하 는 인덱스와 같은 후보 선택 정보가 시그널링될 수 있다. 상기 선택 정보는 플래그 또는 인덱스 정보일 수 있으 며, AF_MERGE_flag, AF_merge_idx 등으로 지칭될 수 있다. 본 발명의 실시예에서, 현재 블록에 대한 움직임 보상은 서브 블록의 크기를 기반으로 수행될 수 있다. 이 경우, 어파인 블록(즉, 현재 블록)의 서브 블록 크기가 유도된다. 만약 서브 블록의 폭과 높이가 모두 4개의 루 마 샘플들보다 크면, 각 서브 블록에 대한 움직임 벡터가 도출되고, DCT-IF 기반 움직임 보상(휘도에 대한 1/16 펠 및 색차에 대한 1/32)이 서브 블록에 대해서 수행될 수 있다. 그렇지 않으면, 향상된 이중 선형 보간 필터 기반 움직임 보상(enhanced bi-linear interpolation filter based motion compensation)이 전체 어파인 블록 에 대해서 수행될 수 있다. 본 발명의 실시예에서, 머지/스킵 플래그(merge/skip flag)가 참이고 CU에 대한 폭과 높이 둘다가 8보다 크거나 동일할 때, CU 레벨에서 어파인 플래그는 어파인 머지 모드가 사용되는지를 지시하는 비트스트림(bitstream)을 통해 시그널링된다. CU가 AF_MERGE 로서 코딩될 때, 최대값 ‘5’를 갖는 머지 후보 인덱스는 어파인 머지 후보 리스트에서 움직임 정보 후보가 CU를 위해서 사용되는 것을 지정하기 위해서 시그널링된다. 도 20 및 도 21은 본 발명의 실시예에 따른 어파인 예측으로 부호화된 주변 블록을 사용하여 어파인 머지 후보 리스트를 구성하는 방법을 설명하기 위한 도면이다. 도 20을 참조하면, 어파인 머지 후보 리스트는 다음의 단계들로서 구성된다. 1) 모델 기반 어파인 후보들 삽입 모델 기반 어파인 후보는 후보가 어파인 모드로 코딩된 유효한 주변 재구성된 블록으로부터 도출된다는 것을 의 미한다. 도 20에 도시된 바와 같이, 후보 블록에 대한 스캔 순서는 좌측(A), 상측(b), 우상측(C) 및 좌하측(D) 으로부터 좌상측(E)이다. 주변 좌하측 블록(A)가 6-파라미터 어파인 모드에서 코딩되면, 블록(A)를 포함하는 CU의 좌상측 코너, 우상측 코너, 및 좌하측 코너의 움직임 벡터들(v_4, v_5, v_6)을 얻게 된다. 현재 블록 상의 좌상측 코너의 움직임 벡 터들(v_0, v_1, v_2)은 6-파라미터 어파인 모델에 의한 움직임 벡터들(v_4, v_5, and v_6)에 따라서 계산된다. 주변 좌하측 블록(A)가 4-파라미터 어파인 모드에서 코딩되면, 블록(A)를 포함하는 CU의 좌상측 코너와 우상측 코너의 움직임 벡터들(v_4, v_5)을 얻게 된다. 현재 블록 상의 좌상측 코너의 움직임 벡터들(v_0, v_1)은 4-파 라미터 어파인 모델에 의한 움직임 벡터들(v_4, v_5)에 따라서 계산된다. 2) 제어점 기반 어파인 후보들 삽입 도 20을 참조하면, 제어점 기반 후보는 각 제어점의 주변 움직임 정보를 결합하여 후보가 구성되는 것을 의미한 다. 제어점들에 대한 움직임 정보는 먼저 도 20에 도시된 지정된 공간 이웃 블록들과 시간 이웃 블록으로부터 도출 된다. CP_k (k=1, 2, 3, 4)는 k번째 제어점을 나타낸다. 또한, A, B, C, D, E, F 및 G는 CP_k (k=1, 2, 3)를 예측하기 위한 공간 위치이고, H는 CP4를 예측하기 위한 시간 위치이다. CP_1, CP_2, CP_3 및 CP_4의 좌표들은 각각 (0, 0), (W, 0), (H, 0) 및 (W, H)이고, 여기에서 W 및 H는 현재 블록의 폭과 높이이다. 각 제어점의 움직임 정보는 다음 우선 순위에 따라서 얻어진다. CP_1에 대해서, 체킹 우선 순위는 A→B→C 이고, A가 이용가능하면 A가 사용된다. 그렇지 않고, B가 이용가능하 면 B가 사용된다. A와 B 둘다 이용가능하지 않으면, C가 사용된다. 만약에 3개의 후보들 모두가 이용가능하지 않으면, CP1의 움직임 정보는 얻을 수 없다. CP_2 에 대해서, 체킹 우선 순위는 E→D 이다. CP_3에 대해서, 체킹 우선 순위는 G→F 이다. CP_4에 대해서, H가 사용된다. 두 번째로, 제어점의 조합들이 움직임 모델을 구성하는데 사용된다. 2개의 제어점의 움직임 벡터들은 4-파라미터 어파인 모델에서 변환 파라미터들을 산출하는데 필요하다. 2개의 제어점은 다음 6개의 조합들({CP_1, CP_4}, {CP_2, CP_3}, {CP_1, CP_2}, {CP_2, CP_4}, {CP_1, CP_3}, {CP_3, CP_4}) 중의 하나로부터 선택될 수 있다. 예를 들어, 4-파라미터 어파인 움직임 모델을 구성하는데 CP_1 및 CP_2 제어점들을 사용하는 것은 “Affine (CP_1, CP_2)”으로 표기된다. 3개의 제어점의 움직임 벡터들은 6-파라미터 어파인 모델에서 변환 파라미터들을 산출하는데 필요하다. 3개의 제어점은 다음 4개의 조합들({CP_1, CP_2, CP_4}, {CP_1, CP_2, CP_3}, {CP_2, CP_3, CP_4}, {CP_1, CP_3, CP_4}) 중의 하나로부터 선택될 수 있다. 예를 들어, 6-파라미터 어파인 움직임 모델을 구성하는데 CP_1, CP_2 및 CPv3 제어점들을 사용하는 것은 “Affine (CP_1, CP_2, CP_3)”으로 표기된다. 또한, 본 발명의 실시예에서, 어파인 머지 모드에서, 어파인 머지 후보가 존재하면, 그것은 언제나 6-파라미터 어파인 모드로서 고려될 수 있다. 어파인 인터 모드(affine inter mode) 도 22는 본 발명이 실시예에 따른 어파인 인터 모드(affine inter mode)에서 어파인 모션 예측에 사용되는 주변 블록의 예를 도시한다. 도 22를 참조하면, 어파인 모션 예측(affine motion prediction)은 어파인 머지 모드(affine merge mode 또는 AF_MERGE)와 어파인 인터 모드(affine inter mode 또는 AF_INTER)를 포함할 수 있다. 어파인 인터 모드 (AF_INTER)에서, 2개의 제어점 모션 벡터 예측(control point motion vector prediction, CPMVP)와 CPMV를 결 정한 후 차이에 해당하는 제어점 모션 벡터 차분 값(control point motion vector difference, CPMVD)이 인코 더로부터 디코더로 전송될 수 있다. 구체적인 어파인 인터 모드(AF_INTER)의 부호화 과정은 아래와 같을 수 있 다. 스텝-1: 2개의 CPMVP 쌍(pair) 후보(candidate) 결정 스텝-1.1: 최대 12개의 CPMVP 후보 조합 결정 (아래의 수학식 2 참조) 수학식 2"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "수학식 2에서, v_0는 현재 블록의 좌상측 제어점에서의 모션 벡터(CPMV0), v_1은 현재 블록(220 0)의 우상측 제어점에서의 모션 벡터(CPMV1), v_2는 현재 블록의 좌하측 제어점에서의 모션 벡터(CPMV2)이고, v_A는 현재 블록의 좌상측 제어점의 좌상측에 인접한 주변 블록 A의 모션 벡터, v_B는 현재 블록의 좌상측 제어점의 상측에 인접한 주변 블록 B의 모션 벡터, vC는 현 재 블록의 좌상측 제어점의 좌측에 인접한 주변 블록 C의 모션 벡터, v_D는 현재 블록(220 0)의 우상측 제어점의 상측에 인접한 주변 블록 D의 모션 벡터, v_E는 현재 블록의 우상측 제어점의 우상측에 인접한 주변 블록 E의 모션 벡터, v_F는 현재 블록의 좌하측 제어점 의 좌측에 인접한 주변 블록 F의 모션 벡터, v_G는 현재 블록의 좌하측 제어점의 좌측 에 인접한 주변 블록 G의 모션 벡터를 나타낸다. 스텝-1.2: CPMVP 후보 조합 중 차이값(difference value, DV)이 작은 값 기준으로 정렬(sorting)하여 상위 2개 의 후보 사용 (아래의 수학식 3 참조) 수학식 3"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "v_0x는 현재 블록의 좌상측 제어점의 모션 벡터(V0 또는 CPMV0)의 x축 엘레먼트, v_1x는 현재 블록 의 우상측 제어점의 모션 벡터(V1 또는 CPMV1)의 x축 엘레먼트, v_2x는 현재 블록의 좌하측 제어점의 모션 벡터(V_2 또는 CPMV_2)의 x축 엘레먼트, v_0y는 현재 블록의 좌상측 제어점 의 모션 벡터(V_0 또는 CPMV_0)의 y축 엘레먼트, v_1y는 현재 블록의 우상측 제어점의 모션 벡터 (V_1 또는 CPMV_1)의 y축 엘레먼트, v_2y는 현재 블록의 좌하측 제어점의 모션 벡터(V_2 또는 CPMV_2)의 y축 엘레먼트, w는 현재 블록의 폭(width), h는 현재 블록의 높이(height)를 나타낸다. 스텝-2: 제어점 모션 벡터 예측자(CPMVP) 쌍 후보가 2 보다 작은 경우 AMVP 후보 리스트를 사용 스텝-3: 2개의 후보들 각각에 대해 제어점 모션 벡터 예측자(CPMVP)를 결정하고 RD cost를 비교하여 작은 값을 갖는 후보와 CPMV를 최적으로 선택 스텝-4: 최적의 후보에 해당하는 인덱스와 제어점 모션 벡터 차분값(control point motion vector difference, CPMVD) 전송 본 발명의 실시예에서, AF_INTER에서, CPMVP 후보의 구성 과정이 제공된다. AMVP와 동일하게, 후보 개수는 2이 고, 후보 리스트의 위치를 지시하는 인덱스가 시그널링된다. CPMVP 후보 리스트의 구성 과정은 다음과 같다. 1) 주변 블록들을 스캔하여 이것이 어파인 움직임 예측으로서 코딩되는지를 체크한다. 스캔된 블록이 어파인 예 측으로서 코딩되면, 후보 개수가 2가 될 때까지 스캔된 주변 블록의 어파인 움직임 모델로부터 현재 블록의 움 직임 벡터쌍을 도출한다. 2) 후보 개수가 2보다 작으면, 후보 구성 과정을 수행한다. 또한, 본 발명의 실시예에서, 4-파라미터(2-제어점) 어파인 인터 모드가 줌-인/아웃(zoom-in/out) 및 회전의 움직임 모델과 콘텐츠를 예측하는데 사용된다. 도 15에 도시된 바와 같이, 블록의 어파인 움직임 필드(field)는 2개의 제어점 움직임 벡터들에 의해 기술된다. 블록의 모션 벡터 필드(motion vector field: MVF)는 앞에서 기술된 식 1에 의해 기술된다. 종래 기술에서, AMVP(advanced motion vector prediction) 모드는 MVP (motion vector prediction) 인덱스와 MVDs (motion vector differences)를 시그널링하는데 필요하다. AMVP 모드가 본 발명에 적용될 때, 어파인_플 래그(affine_flag)는 어파인 예측이 사용되는지를 지시하도록 시그널링된다. 어파인 예측이 적용되면, inter_dir, ref_idx, mvp_index, 및 2개의 MVDs (mvd_x 및 mvd_y)의 신택스가 시그널링된다. 2개의 어파인 MVP 쌍을 포함하는 어파인 MVP 쌍 후보 리스트가 생성된다. 시그널링된 mvp_index는 이들 중 하나를 선택하는데 사 용된다. 어파인 MVP 쌍은 두 종류의 어파인 MVP 후보들에 의해 생성된다. 하나는 공간적 계승 어파인 후보 (spatial inherited affine candidate)이고, 다른 하나는 코너 도출된 어파인 후보(corner derived affine candidate)이다. 주변 CU들이 어파인 모드로 코딩되면, 공간적 계승 어파인 후보들이 생성될 수 있다. 주변 어 파인 코딩된 블록의 어파인 움직임 모델은 2-제어점 MVP 쌍(two-control-point MVP pair)의 움직임 벡터들을 생 성하기 사용된다. 공간적 계승 어파인 후보의 2-제어점 MVP 쌍의 MV들은 다음의 식들을 사용함으로써 도출된다. 수학식 4"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "수학식 5"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "V_B0, V_B1, 및 V_B2가 어떤 참조/주변 CU의 좌상측 MV, 우상측 MV, 및 좌하측 MV로 대체될 수 있는 경우, (posCurCU_X, posCurCU_Y)는 프레임의 좌상측 샘플에 대한 현재 CU의 좌상측 샘플의 위치이고, (posRefCU_X,posRefCU_Y)는 프레임의 좌상측 샘플에 대한 참조/주변 CU의 좌상측 샘플의 위치이다. 수학식 6"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "수학식 7"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 8, "content": "도 23은 본 발명이 실시예에 따른 어파인 인터 모드(affine inter mode)에서 어파인 모션 예측에 사용되는 주변 블록의 예를 도시한다. 도 23을 참조하면, MVP 쌍의 개수가 2보다 작으면, 코너 도출된 어파인 후보가 사용된다. 주변 움직임 백터들은 도 23에 도시된 바와 같이 어파인 MVP 쌍을 도출하는데 사용된다. 제 1 코너 도출된 어파인 후보에 대해서, 세 트 A (A0, A1 및 A2)에서 제 1 이용가능한 MV와 세트 B (B0 및 B1)에서 제 1 이용가능한 MV는 제 1 MVP 쌍을 구성하는데 사용된다. 제 2 코너 도출된 어파인 후보에 대해서, 세트 A에서 제 1 이용가능한 MV와 세트 C (C0 및 C1)에서 제 1 이용가능한 MV는 우상측 제어점의 MV를 계산하는데 사용된다. 세트 A에서 제 1 이용가능한 MV 와 계산된 우상측 제어점 MV는 제 2 MVP 쌍이다. 본 발명의 실시예에서, 2개(3개)의 후보들{mv_0, mv_1} ({mv_0, mv_1, mv_2) 을 포함하는 2개의 후보 세트는 어파인 움직임 모델의 2개(3개) 제어점을 예측하는데 사용된다. 주어진 모션 벡터 차분들(mvd_0, mvd_1, mvd_ 2)과 제어점들은 다음 식들을 사용함으로써 계산된다. 수학식 8"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 9, "content": "도 24 및 도 25는 본 발명이 실시예에 따른 어파인 인터 모드(affine inter mode)에서 주변 블록의 모션 정보를 이용하여 모션 벡터 후보를 유도하는 방법을 예시하는 도면이다. 상기 어파인 후보 리스트는 어파인 움직임을 공간적 이웃 블록들(외삽된 어파인 후보들)로로부터 연장하고 공간 적 이웃 블록들(가상의 어파인 후보들)로부터의 모션 벡터들의 조합에 의해 첨부된다(appended). 후보 집합들은 아래와 같이 설정된다: 1. 최대 2개의 다른 어파인 MV 예측자 집합들이 인접 블록들의 어파인 움직임으로부터 유도된다. 인접 블록들 A0, A1, B0, B1, 및 B2가 도 24에 도시된 것처럼 확인된다. 만약 인접 블록이 어파인 움직임 모델에 의해 부호 화되고 그 참조 프레임이 현재 블록의 참조 프레임과 동일하면, 현재 블록의 (4-파라미터 어파인 모델에 대한) 2개 또는 (6-파라미터 어파인 모델에 대한) 3개의 제어점들이 인접 블록들의 어파인 모델로부터 유도된다. 2. 도 25는 가상의 어파인 후보 집합을 생성하기 위해 사용되는 인접 블록들을 도시한다. 인접 MV들은 3개의 그 룹들로 분할된다: S_0={mv_A, mv_B, mv_C}, S_1={mv_D, mv_E}, S_2={mv_F, mv_G}. mv_0는 S0에서 현재 블록과 동일한 참조 픽처를 참조하는 첫번째 MV이다. mv_2는 S1에서 현재 블록과 동일한 참조 픽처를 참조하는 첫번째 MV이다. 만약 mv_0와 mv_1이 주어지면, mv_2는 아래의 수학식 9에 의해 유도될 수 있다. 수학식 9"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 10, "content": "수학식 9에서, 현재 블록 사이즈는 WxH이다. 만약 mv_0과 mv_2만이 주어지면, mv_1은 아래의 수학식 10에 의해 유도될 수 있다. 수학식 10"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 11, "content": "본 발명의 일 실시예에서, 어파인 인터 예측은 아래의 시퀀스(sequence)에 따라 수행될 수 있다. 입력: 어파인 움직임 파라미터들, 참조 픽처 샘플들 출력: CU의 예측 블록 프로세스 - 어파인 블록의 서브-블록 사이즈를 유도 - 서브-블록의 폭과 너비 모드 4 루마 샘플들(luma samples)보다 크면, - 각각의 서브 블록에 대해 - 서브-블록의 움직임 벡터를 유도 - DCT-IF 기반의 움직임 보상(루마에 대해 1/16 펠, 색차에 대해 1/32 펠)이 서브-블록들에 대해 수행(invoked) - 그렇지 않으면, 향상된 바이-리니어 보간 필터(enhenced bi-linear interpolation filter) 기반의 보상이 전 체 어파인 블록에 대해 수행됨(invoked) 또한, 본 발명의 일 실시예에서, 머지/스킵 플래그가 거짓(false)이고 CU에 대한 폭과 너비가 8보다 크거나 같 으면, CU 레벨에서 어파인 플래그가 어파인 인터 모드가 사용될 지 여부를 지시하기 위해 시그널링 된다. CU가 어파인 인터 모드로서 코딩되면, 모델 플래그가 4-파라미터 또는 6-파라미터 어파인 모델이 상기 CU에 대해 적 용되는지 여부를 지시하기 위해 시그널링된다. 만약 모델 플래그가 참(true)인 경우, AF_6_INTER mode(6-파라미 터 어파인 모델)이 적용되고 3개의 MVD들이 파싱되고, 그렇지 않으면, AF_4_INTER mode(4-파라미터 어파인 모델)이 적용되고 2개의 MVD들이 파싱된다. AF_4_INTER 모드에서, 어파인 머지 모드와 유사하게, 어파인 어파인 모드에 의해 코딩된 인접 블록들로부터 외 삽된 움직임 벡터 쌍들이 생성되고 첫번째로 후보 리스트에 삽입된다. 이후, 만약 후보 리스트의 사이즈가 4보다 작으면, 움직임 벡터 쌍 {(v_0,v_1)|v0={v_A,v_B,v_c},v_1={v_D, v_E}}을 갖는 후보들이 인접 블록들을 사용함으로써 생성된다. 도 25에 도시된 것과 같이, v_0는 블록 A, B, C 의 움직임 벡터들로부터 선택된다. 인접 블록으로부터의 움직임 벡터는 참조 리스트와 인접 블록에 대한 참조의 POC 현재 CU에 대한 참조의 POC 및 현재 CU의 사이의 관계에 따라 스케일된다. 그리고 인접 블록 D와 E로부터 v_1을 선택하는 접근 방식은 유사하다. 후보 리스트가 4보다 크면, 후보들은 (후보 쌍에서 2개의 모션 벡터들과 유사하게) 인접 움직임 벡터들의 일관성(consistency)에 따라 우선적으로 정렬되고 첫번째 4개의 후보들이 보존 된다. 만약 후보 리스트의 개수가 4보다 작은 경우, 리스트는 각 AMVP 후보들을 복제함으로써 모션 벡터 쌍에 의해 패 딩된다(padded). AF_6_INTER 모드에서, 어파인 머지 모드와 유사하게, 어파인 어파인 모드로 코딩된 인접 블록들로부터 외삽된 움직임 벡터 트리플들(affine motion vector triples)이 생성되고 후보 리스트에 우선적으로 삽입된다.이후, 후보 리스트의 사이즈가 4보다 작으면, 모션 벡터 트리플들 {(v_0, v_1, v_2)| v0={v_A, v_B, v_c}, v1={v_D, v_E}, v2={v_G, v_H}}을 포함하는 후보들이 인접 블록들을 사용하여 생성된다. 도 25에서 도시된 것과 같이, v_0는 블록들 A, B, 또는, C의 움직임 벡터들로부터 선택된다. 인접 블록으로부터의 움직임 벡터는 참조 리스트와 인접 블록에 대한 참조의 POC, 현재 CU에 대한 참조의 POC, 그리고 현재 CU의 POC의 관계에 따라 스케 일된다. 그리고 인접 블록 D와 E로부터 v_1을 선택하기 위한 접근과 F와 G로부터 v_2를 선택은 유사하다. 후보 리스트가 4보다 크면, 후보들은 (3개의 후보에서 2개의 움직임 벡터들과 유사하게 )인접 움직임 벡터들의 일관 성에 따라 정렬되고, 첫번째 4개의 후보들이 보존된다. 후보 리스트의 개수가 4보다 작으면, 리스트는 각 AMVP 후보들을 복제함으로써(duplicating) 구성되는 움직임 벡터 트리플에 의해 패딩될 수 있다. 현재 CU의 CPMV가 유도된 이후, 어파인 파라미터들의 개수에 따라, 현재 CU의 MVF가 4-파라미터 어파인 모델에 대한 아래의 수학식 11에 따라 생성되고, 6-파라미터 어파인 모델에 대한 아래의 수학식 12에 따라 생성된다. 수학식 11"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 12, "content": "수학식 12"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 13, "content": "여기서, 서브-블록 사이즈 MxN은 아래의 수학식 13에서 유도되고, MvPre는 움직임 벡터 부분 정확도 (1/16)이다. 수학식 13"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 14, "content": "수학식 12에 의해 유도된 이후, M과 N은 w와 h의 분모(divisor)로 만들기 위해 필요하다면 하향조정되어야 한다. M 또는 N이 8보다 작으면, WIF가 적용되고, 그렇지 않으면, 서브-블록 기반의 어파인 움직임 보상이 적용 된다. 도 26은 본 발명의 실시예에 따른 서브 블록 단위의 어파인 모션 벡터 필드를 유도하는 방법의 일 예를 도시한 다. 도 26을 참조하면, 각 MxN 서브-블록의 움직임 벡터를 유도하기 위하여, 도 26에 도시된 것과 같은 각 서브-블 록의 중앙 샘플의 움직임 벡터는 수학식 11 또는 수학식 12에 따라 계산되고, 1/16 부분 정확도로 라운딩된다 (rounded). SHVC 상향 샘플링 보간 필터들이 유도된 움직임 벡터를 사용하여 각 서브-블록의 예측을 생성하기위해 적용된다. HEVC 움직임 보상 보간 필터들과 동일한 필터 길이 및 정규화 인자를 갖는 SHVC 상향 샘플링 보간 필터들은 추 가적인 부분 펠 위치들(additional fractional pel positions)에 대한 움직임 보상 보간 필터들로서 사용될 수 있다. 크로마 성분 움직임 벡터 정확도는 1/32 샘플이고, 1/32 펠 부분 위치들의 추가적인 보간 필터들은 2개의 인접한 1/16 펠 부분 위치들의 필터들의 평균들 사용함으로써 유도된다. AF_MERGE 모드는 통상적인 머지 모드 선택이 수행되는 것과 동일한 방식으로 인코더 측에서 선택될 수 있다. 후 보 리스트가 우선적으로 생성되고, 후보들에서 최소의 RD-비용이 다른 인터 모드들의 RD-비용과 비교하기 위해 선택된다. 비교의 결과는 AF_MERGE가 적용되느냐 아니냐에 대한 결정이다. AF_4_INTER 모드를 위하여, RD 비용 확인은 어느 움직임 벡터 쌍 후보가 현재 CU의 제어점 움직임 벡터 예측 (control point motion vector prediction, CPMVP)로서 선택되는지를 결정하기 위해 사용된다. 현재 어파인 CU 의 CPMVP가 결정된 이후, 어파인 움직임 추정이 적용되고 제어점 움직임 벡터(control point motion vector, CPMV)가 획득된다. 그러면 CPMV와 CPMVP의 차이가 결정된다. 인코더 측에서, AF_MERGE 또는 AF_4_INTER 모드가 이전의 모드 선택 스테이지에서 최적의 모드로서 결정될 때만 AF_6_INTER 모드가 확인된다. 본 발명의 일 실시예에서, 어파인 인터(어파인 AMVP) 모드는 아래와 같이 수행될 수 있다: 1) AFFINE_MERGE_IMPROVE: 어파인 모드인 첫번째 이웃 블록을 탐색하는 대신, 개선점(improvement)은 최대의 코딩 유닛 사이즈를 갖는 이웃 블록을 어파인 머지 후보로서 탐색하고자 한다. 2) AFFINE_AMVL_IMPROVE: 어파인 모드인 이웃 블록들을 통상적인 AMVP 절차와 유사하게 어파인 AMVP 후보 리스 트에 추가한다. 상세한 어파인 AMVP 후보 리스트 생성 과정은 아래와 같다. 첫째로, 좌측 아래의 인접 블록이 어파인 움직임 모델을 사용하고 현재 참조 인덱스와 동일한 참조 인덱스를 갖 는지 여부가 확인된다. 만약 존재하지 않으면, 좌측 인접 블록이 동일한 방법으로 확인된다. 만약 존재하지 않 으면, 좌측 아래 인접 블록이 어파인 움직임 모델을 사용하고 상이한 참조 인덱스를 갖는지 여부가 확인된다. 만약 존재하면, 스케일된 어파인 움직임 벡터가 참조 픽처 리스트에 추가된다. 만약 존재하지 않으면, 좌측 인 접 블록이 동일한 방식으로 확인된다. 둘째로, 우측 상부 인접 블록, 상부 인접 블록, 그리고 좌측 상부 인접 블록이 동일한 방식으로 확인된다. 상술한 과정들 이후 2개의 후보들을 탐색하면, 어파인 AMVP 후보 리스트를 생성하는 동작을 종료한다. 2개의 후 보들을 탐색하지 못하면, JEM 소프트웨어 내 원래의 동작이 어파인 AMVP 후보 리스트들을 생성하기 위해 수행된 다. 3) AFFINE_SIX_PARAM: 4-파라미터 어파인 움직임 모델 이외에, 6-파라미터 어파인 움직임 모딜이 추가적인 모델 로서 추가된다. 6-파라미터 어파인 움직임 모델이 아래의 수학식 14를 통해 유도된다. 수학식 14"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 15, "content": "상술한 움직임 모델에 6-파라미터들이 존재하므로, 좌측 상부 위치 MV_0, 우측 상부 위치 MV_1, 그리고 좌측 하 부 위치 MV_2에서의 3개의 움직임 벡터들이 모델을 결정하기 위해 요구된다. 3개의 움직임 벡터들이 4-파라미터 어파인 움직임 모델에서 2개의 모션 벡터와 유사한 방식으로 결정될 수 있다. 어파인 모델 머지는 언제나 6-파 라미터 어파인 움직임 모델로서 설정된다. 4) AFFINE_CLIP_REMOVE: 모든 어파인 움직임 벡터들에 대한 움직임 벡터 제약들(constraints)을 제거한다. 움 직임 보상 과정들이 움직임 벡터 제약들 자체를 제어하도록 한다. 어파인 모션 모델(Affine motion model) 상술한 바와 같이 Affine inter prediction에서 다양한 affine motion model이 사용 또는 고려될 수 있다. 예 를 들어, Affine motion model 은 상술한 도 14와 같이 4가지 motion 을 표현할 수 있다. Affine motion model 이 표현할 수 있는 motion 중 3가지 motion (translation, scale, rotate) 를 표현하는 affine motion model 을 similarity (or simplified) affine motion model 이라고 할 수 있다. 상기 affine motion model들 중 어떤 모델을 사용하는지에 따라 도출되는 CPMV들의 개수 및/또는 현재 블록의 샘플/서브블록 단위 MV 도출 방법이 달 라질 수 있다. 본 발명의 일 실시예에서, 적응적인 4개 및 6개 파라미터 움직임 모델이 사용된다. AF_INTER에서, 6-파라미터 움직임 모델이 JEM에서 존재하는 4-파라미터 움직임 모델에 더하여 제안된다. 6-파라미터 어파인 움직임 모델이 아래의 수학식 15와 같이 설명된다. 수학식 15"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 16, "content": "여기서, 계수들 a, b, c, d e, 및 f는 어파인 움직임 파라미터들이고, (x,y)와 (x',y')는 어파인 움직임 모델의 변환 이전과 이후의 픽셀 위치의 좌표들이다. 비디오 코딩에서 어파인 움직임 모델을 사용하기 위해, 만약 CPMV0, CPMV1, 그리고 CPMV2가 CP0(좌상측), CP1(우상측), 그리고 CP2(좌하측)에 대한 MV라면 수학식 16이 아 래와 같이 설명될 수 있다. 수학식 16"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 17, "content": "여기서, CPMV_0={v_0x,v_0y}, CPMV_1={v_1x,v_1y}, CPMV_2={v_2x,v_2y}, 그리고 w와 h는 각각 코딩 블록의 폭 (width)와 높이(height)이다. 수학식 16은 블록의 움직임 벡터 필드(motion vector field, MVF)이다. 플래그가 인접 블록들이 어파인 예측으로 코딩되었을때 4-파라미터 또는 6-파라미터 어파인 움직임 모델이 사용 되는지 여부를 지시하기 위해 CU 레벨에서 파싱된다. 어파인 예측으로 코딩된 인접 블록이 없으면, 플래그는 생 략되고 4-파라미터 모델이 어파인 예측을 위해 사용된다. 다시 말해, 6-파라미터 모델이 하나 또는 그 이상의 인접 블록들이 어파인 움직임 모델로 코딩되는 조건에서 고려된다. CPMVD의 개수와 관련하여, 2개 및 3개의 CPMVD들이 4-파라미터 및 6-파라미터 어파인 움직임 모델에 대하여 각각 시그널링된다. 또한, 본 발명의 일 실시예에서, 패턴-매칭된 움직임 벡터 가공(pattern-matched motion vector refinement)이 사용될 수 있다. JEM의 패턴-매칭된 움직임 벡터 유도(JEM 인코더 설명에서 이름하여 PMMVD, 이하 PMVD로 약칭 됨)에 있어서, 디코더는 CU-레벨 탐색을 위해 시작 MV 후보를 결정하기 위해 몇몇 움직임 벡터(motion vector, MV)를 평가할 필요가 있다. 서브-CU-레벨 탐색에서, 최적의 CU-레벨 MV에 더하여, 몇몇 MV 후보들이 추가된다. 디코더는 최적의 MV를 탐색하기 위하여 이러한 MV 후보들을 평가할 필요가 있으며, 이는 많은 메모리 대역을 요 구한다. 제안된 패턴-캐칭된 움직임 벡터 정제(pattern-matched motion vector refinement, PMVR)에서, JEM에 서 PMVD에서의 템플릿 매칭(template matching)과 양쪽 매칭(bilateral matching)의 컨셉들이 채택된다. PMVR 이 사용가능한지 아닌지를 지시하기 위해 스킵 모드 또는 머지 모드가 선택되었을 때 하나의 PMVR_flag가 시그 널링된다. PMVD와 비교하여 의미있게 메모리 대역폭 요구를 감소시키기 위하여, MV 후보 리스트가 생성되고, 만 약 PMVR이 적용되면 시작 MV 후보 인덱스가 명시적으로 시그널링된다.머지 후보 리스트 생성 프로세스를 사용함으로써 후보 리스트가 생성되지만, 서브-CU 머지 후보들, 예를 들어, 어파인 후보들과 ATMVP 후보들은 제외된다. 양방향 매칭(bilateral matching)을 위해, 오직 단방향-예측(uni- prediction) MV 후보만이 포함된다. 양방향-예측(bu-prediction) MV 후보는 2개의 단방향-예측 MV 후보들로 분 할된다. 또한, (MV 차이들이 미리 정의된 임계치보다 적은) 유사한 MV 후보들이 또한 제거된다. CU-레벨 탐색을 위하여, 다이아몬드 탐색 MV 정제(diamond search MV refinement)가 시그널링된 MV 후보로부터 시작하여 수행된 다. 서브-CU-레벨 탐색은 오직 양쪽 매칭 머지 모드(bilateral matching merge mode)에서만 사용 가능하다. 모든 서브-CU들에 대한 서브-CU-레벨 탐색의 탐색 윈도우는 CU-레벨 탐색의 탐색 윈도우와 동일하다. 따라서, 추가적 인 대역폭이 서브-CU-레벨 탐색에 있어 요구되지 않는다. 모드에서 MVP를 정제하기 위하여 템플릿 매칭도 사용된다. AMVP 모드에서, 2개의 MVP들이 HEVC MVP 생성 프로세 스를 사용함으로써 생성된고, 하나의 MVP 인덱스가 그들 중 하나를 선택하기 위해 시그널링된다. 선택된 MVP는 PMVR에서 템플릿 매칭을 사용함으로써 더 정제된다. 적응적 움직임 벡터 해상도(adaptive motion vector resolution, AMVR)이 적용되면, 템플릿 매칭 정제 이전에 MVP는 해당하는 정확도로 라운딩된다(rounded). 이러 한 정제 과정은 매턴-매칭된 움직임 벡터 예측자 정제(pattern-matched motion vector predictor refinement, PMVPR)로 명명된다. 본 문서의 나머지에서, 특별히 정의하지 않는다면, PMVR은 템플릿 매칭 PMVR, 양방향 매칭 PMVR, 그리고 PMVPR을 포함한다. 메모리 대역폭 요구를 감소시키기 위하여, PMVR은 4x4, 4x8, 그리고 8x4 CU들에 대해 사용 불가능하게 된다. 추 가적인 메모리 대역폭 요구량 감소를 위하여, 64와 동일한 CU 영역에 대한 {템플릿 매칭, 양방향 매칭}의 탐색 범위가 {±2, ±4}로 축소될수 있고, 64보다 큰 CU 영역에 대한 {템플릿 매칭, 양방향 매칭}의 탐색 범위가 {± 6, ±8}로 축소될수 있다. 본 문서의 PMVR 섹션에서 설명된 상술한 모든 방법들을 사용함으로써, HEVC에서의 최 악의 경우와 비교하여 요구되는 메모리 대역폭이 JEM-7.0의 PMVD에서 45.9x로부터 PMVR에서 3.1x로 감소되었다. HMVP(History-based Motion Vector Prediction) 일반 일반적으로 영상 압축 기술은 2 가지 주요한 기법으로서 공간적 및 시간적 중첩성(redundancy)에 대한 탐색 (exploiting)을 이용한다. 예를 들어, HEVC(High Efficiency Video Coding, HEVC) 및 VVC는 모두 인터 코딩 (inter coding)의 기저로 2가지 움직임 압축 기법들을 사용한다. 하나는 머지(merge) 움직임이고, 나머지 하나 는 AMVP(advanced motion vector prediction)이다. 이러한 2가지 예측 모드에 대한 개선을 위하여, 다양한 변 경들(modifications)이 논의되고 있다. 이들은 후보들의 개수를 증가시키는 것부터 시작하여 보다 공간적으로 확장되는 후보들에 대한 탐색 및 비-관습적인(non-traditional) 위치들에서의 시간적 후보들을 검사하는 것 등 을 포함한다. 이러한 2가지 기법들은 일차적으로 가능한 후보들로 리스트를 구성하고, RD(rate distortion) 비 용을 최소화하고 비트스트림에서 선택된 후보를 시그널링한다. 특히, 최근의 영상 압축 기술에서는, 이전에 코딩된 블록의 모션 정보를 저장하고, 저장된 모션 정보를 이후에 코딩되는 블록의 모션 예측에 이용하는 HMVP(History-based Motion Vector Prediction)가 논의된다. 이러한 HMVP는 머지 리스트(또는 머지 후보 리스트) 또는 AMVP 리스트(또는 AMVP 후보 리스트)에 추가될 수 있다. 디코더는 HMVP를 위하여 FIFO(first in first out) 시스템(또는 방식)에서 동작하는 LUT(look-up table)을 유 지한다. 본 명세서에서, LUT는 그 명칭에 제한되지 않으며, 테이블, HMVP 테이블, HMVP 후보 테이블, 버퍼, HMVP 버퍼, HMVP 후보 버퍼, HMVP 리스트, HMVP 후보 리스트 등으로 지칭될 수 있다. 구체적으로, 비-어파인 (non-affine) PU(prediction unit)(또는 CU(coding unit))가 디코딩될 때, 그 움직임 정보는 LUT에 저장되고 디코더는 다음 PU에 대한 디코딩을 진행한다. 이때, 저장되는 움직임 정보는 x(수평) 및 y(수직) 방향의 움직임 벡터들, 참조 인덱스 정보 및 모드 정보 등을 포함할 수 있다. 디코더는 점진적으로(progressively) 디코딩된 비-어파인 후보의 움직임 정보가 저장되는 LUT를 유지할 수 있다. LUT의 사이즈는 미리 정의된 S개의 후보들로 제한될 수 있다. 일 실시예로서, LUT는 슬라이스의 시작, CTU 행의 시작 또는 CTU의 시작에서 리셋(reset)될 수 있다. HMVP는 머지 모드 및 AMVP 모드 모두에서 적용될 수 있다. 머지 리스트는 B개의 후보들을 가질 수 있고, AMVP 리스트는 2개의 후보들을 가질 수 있다. 종래의 영상 압축 기술에서, 머지 리스트는 다음의 후보들로 구성된다: i) 공간 후보, ii) 시간 후보, iii) 양방향 예측(Bi-Pred) 후보, iv) 제로 움직임 후보(zero motion candidate). 최근, ATMVP(advanced motion vector prediction)가 추가적으로 후보로서 고려되는 방법이 논의된 다. 일 예로서, ATMVP 후보는 시간 후보 이전에 머지 리스트에 삽입될 수 있다. 머지 리스트의 후보들은 최대의머지 리스트 사이즈에 도달할 때까지 머지 리스트에 추가된다. 중복 후보(duplicate candidate)는 머지 리스트 에 추가되지 않을 수 있다. AMVP 리스트는 2개의 후보들이 삽입될 수 있다. 일 예로서, 2개의 후보들 중 하나는 사용 가능한 공간 후보들로부터 선택되고 두번째 후보는 시간 후보로부터 선택될 수 있고, 리스트가 채워지지 않는 경우, 제로 움직임 벡터 후보가 추가될 수 있다. HMVP는 LUT에서 후보들이 투입된 순서와 동일하게 테이블에서 빠져나가는 FIFO 기반으로 적용된다. 일 실시예에서, HMVP가 머지 리스트 구성에 적용될 때, HMVP 후보는 아래와 같이 리스트의 3번째 위치에 삽입 (또는 추가)될 수 있다: 1. 공간 후보(Spatial Candidate) 2. 시간 후보(Temporal Candidate) 3. LUT에 대한 최대 S개의 HMVP 후보(Up to S HMVP Candidates for a LUT) 4. 결합된 양방향 예측 후보(Combined Bi-Pred Candidate) 5. 제로 움직임 벡터 후보(Zero Motion Vector Candidate) 일 실시예에서, HMVP가 AMVP 리스트 구성에 적용될 때, HMVP는 아래와 같이 시간 후보 이후 3번째 위치에 삽입 될 수 있다: 1. 공간적 후보 (Spatial Candidate) 2. 시간적 후보 (Temporal Candidate) 3. 최대 K개의 HMVP 후보들 (Up to K HMVP Candidates) 4. 제로 움직임 벡터 후보 (ero Motion Vector Candidate) 도 27은 본 명세서의 실시예에 따른 HMVP를 저장하는 방법을 설명하기 위한 흐름도이다. 도 27을 참조하면, 디코더는 현재 PU(또는 CU)를 디코딩한다(S2701). 디코더는 현재 PU가 비-어파인 모드로 코딩된 블록인지 확인한다(S2702). HMVP 후보들의 사용을 용이하게 하기 위하여, 만약 현재 PU가 어파인 모드로 코딩된 블록인 경우, 디코더는 현재 PU의 모션 정보를 테이블에 저장하 지 않는다. 현재 PU가 비-어파인 모드로 코딩된 블록인 경우, 디코더는 현재 PU의 모션 정보를 테이블에 저장(또는 업데이 트)한다(S2703). 본 명세서의 실시예에서, HMVP 테이블은 2가지 방법, 즉, i) 비제한적 FIFO(unconstrained FIFO) ii) 제한적 FIFO(constraint FIFO) 방법으로 업데이트될 수 있다. 전자에서, 중복된 모션 정보가 존재할 수 있으나, 프루닝 프로세스는 적용되지 않는다. 이는 전반적인 프로세스의 복잡도를 저감시키는데 기여한다. 한편, 후자에서, 프 루닝 프로세스가 적용되며, HMVP 테이블 내 중복된 모션 정보가 존재하지 않는다. 아래의 도면을 참조하여 설명 한다. 도 28은 본 명세서의 실시예에 따른 비제한적 FIFO 방식으로 동작하는 HMVP 테이블을 설명하기 위한 도면이다. 도 28을 참조하면, 테이블에 추가되는 후보는 테이블의 끝단(우측)에 추가된다. 반면에, FIFO 방식에 따라 테이 블에서 배출되는 후보는 테이블의 앞단(좌측, 가장 오래된 후보)에 위치한다. 만약 인덱스 L-1(즉, 끝단)에서 테이블이 미리-정의된 최대 개수의 후보들로 완전히 채워지지 않으면, 제거되는 후보 없이 새로운 후보들이 추가된다. 반면에, 테이블이 이미 완전히 채워진 경우, 즉, 테이블의 최대 개수를 만족하는 경우, 테이블에서 가장 오래된 앞단에 위치한 후보가 제거되고 새로운 후보가 추가된다. 도 29는 본 명세서의 실시예에 따른 제한적 FIFO 방식으로 동작하는 HMVP 테이블을 설명하기 위한 도면이다. 도 29를 참조하면, 제한적 FIFO가 사용되는 경우, 새로운 후보를 추가하는 것이 어떠한 중복을 야기하는 경우 (즉, 새로운 후보가 중복된 모션 정보를 갖는 경우) 프루닝이 수행된다. 실시예로서, 중복된 모션 정보를 갖는 후보가 테이블에 존재하면, 테이블 내 중복된 후보는 제거되고 현재 후보의 모션 정보가 추가될 수 있다. HMVP 후보들에 대하여, 많은 경우들에서 가장 최근의 히스토리 MV들이 공간 후보(또는 공간 이웃 후보)의 모션 정보와 중복될 수 있다. 따라서, 본 실시예에서는, HMVP 후보를 AMVP 또는 머지 리스트에 추가할 때, 후보들의 추가 순서를 HMVP LUT 인덱스 순서와 다르게 설정하는 방법을 제안한다. 본 명세서의 실시예에 따르면, HMVP 후보를 적응적으로 조절함으로써 후보 리스트를 효율적으로 구성할 수 있고, 이를 통해 이진화(binarization)에 사용되는 시그널링 빈들의 개수를 감소시키고 코딩 효율을 높일 수 있 다. 즉, 머지 리스트 또는 AMVP 리스트에 추가되는 HMVP 후보는 HMVP 리스트 내 인덱스에 의해 제한되지 않을 수 있다. 일 실시예로서, 다음의 표 1은 AMVP 또는 머지 리스트에 HMVP 후보를 추가하는 순서를 변경하는 방법 을 예시한다. 표 1"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 18, "content": "표 1을 참조하면, 전술한 바와 같이, 가장 최근에 삽입된 HMVP 후보는 공간 후보의 모션 정보와 동일할 가능성 이 높기 때문에, 이를 고려하여 HMVP 후보의 추가 순서를 HMVP 인덱스와 무관하게 미리 정의할 수 있다. 또한, 일 실시예에서, 인코더/디코더는 HMVP 리스트 내에서 n번째 후보부터 시작하는 HMVP 후보부터 머지 리스 트 또는 AMVP 리스트에 추가할 수 있다. 다음의 표 2는 AMVP 또는 머지 리스트로 후보를 추가하는 변경된 순서 를 예시한다. 표 2"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 19, "content": "표 2를 참조하면, HMVP 후보는 2번째 인덱스부터 머지 리스트 또는 AMVP 리스트에 추가될 수 있다. 일 실시예에서, 테이블(LUT) 내에서의 HMVP 후보의 추가 순서에 관한 정보는 인코더에서 디코더로 시그널링될 수 있다. 예를 들어, 이러한 순서 정보는 상위 레벨 신택스(high level syntax, HLS)를 통해 전송될 수 있다. 상기 상위 레벨 신택스는, 예를 들어, 시퀀스 파라미터 세트(sequence parameter set), 픽처 파라미터 세트 (picture parameter set), 슬라이스 헤더(slice header), 코딩 트리 유닛(coding tree unit), 코딩 유닛 (coding unit) 및/또는 다른 적절한 신택스 데이터 헤더일 수 있다. 아래의 표 3은 본 명세서에서 제안하는 방법이 적용될 수 있는 상위 레벨 신택스 구조를 예시한다. 표 3"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 20, "content": "표 3을 참조하면, set_HMVP_order_flag가 1임은 set_HMVP_order_flag가 CVS에서 비-IDR(non-IDR) 픽처들 내 슬 라이스 헤더에서 존재함을 지시한다. set_HMVP_order_flag가 0임은 set_HMVP_order_flag가 슬라이스 헤더들에 서 존재하지 않고 VCS에서 적응적 HMVP가 사용되지 않음을 지시한다. 아래의 표 4는 본 명세서에서 제안하는 방법이 적용될 수 있는 슬라이스 세그먼트 헤더 신택스 구조를 예시한다. 표 4"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 21, "content": "표 4를 참조하면, slice_HMVP_idx는 사용되는 후보들의 순서에 대한 인덱스를 의미한다. 예를 들어, slice_HMVP_idx가 0임은 0, 1, 2, 3 등의 기본 HMVP 순서를 표현할 수 있다. 유사하게, 1의 인덱스 값은 3, 2, 1, 0의 HMVP 순서를 표현하기 위하여 사용될 수 있다. 또한, 본 명세서의 일 실시예에서, HMVP LUT에 더하여 롱 텀 리스트(long term list)를 모션예 예측을 위해 사 용하는 방법을 제안한다. 이를 통해, 유지되는 HMVP 후보들의 개수를 증가시킬 수 있다. 실시예로서, 2-HMVP 테 이블들을 고려할 수 있으며, 여기서 하나는 일반 HMVP 후보들을 보관하고, 다른 하나는 유지가 더 필요한 후보 들을 더 보관하는 롱 텀(long term) 리스트로 사용할 수 있다. 다음은 롱 텀 리스트(또는 롱 텀 HMVP 리스트)를 초기화하고 구성하는 방법들을 예시한다. - CTU 행의 첫 번째 CTU를 디코딩한 이후, 이후의 CTU의 하나 또는 그 이상의 히스토리 MV들이 롱 텀 HMVP LUT 에 추가될 수 있다. 이러한 롱 텀 HMVP LUT는 다음 CTU 행까지 사용되거나 업데이트되지 않을 수 있다. - 다음 CTU 행의 시작에서, 롱 텀 HMVP LUT가 통상의 HMVP LUT를 초기화하기 위하여 사용될 수 있다. 그 이유는, CTU 행의 시작에서 CTU의 HMVP 후보들이 이전의 CTU 행의 끝에서의 히스토리 MV보다 더욱 상호 연관 (co-relate)될 수 있기 때문이다. - 상술한 프로세스는 반복될 수 있다. 도 30은 본 명세서의 실시예에 따른 HMVP LUT 및 롱 텀 HMVP LUT를 예시하는 도면이다. 도 30를 참조하면, 인코더/디코더는 HMVP 후보들을 저장하기 위한 2개의 LUT들을 포함할 수 있다. 이 중 하나는 HMVP LUT(또는 일반 HMVP LUT, 숏 텀 HMVP LUT)이고 다른 하나는 롱 텀 HMVP LUT일 수 있다. HMVP 후보는 머지또는 AMVP 리스트에 모두 추가될 때, 도 30에서 도시된 것과 같이 HMVP LUT 또는 롱 텀 LUT로부터 추가될 수 있 다. 상술한 롱 텀 LUT의 사용은 새로운 신택스 엘레먼트를 이용하여 시그널링 될 수 있다. 실시예로서, 상기 신택스 엘리먼트는 상위 레벨 신택스를 통해 시그널링될 수 있다. 예를 들어, 신택스 엘레먼트는 시퀀스 파라미터 세트 (sequence parameter set), 픽처 파라미터 세트(picture parameter set), 슬라이스 헤더(slice header), 코딩 트리 유닛(coding tree unit), 코딩 유닛(coding unit) 및/또는 다른 신택스 데이터 헤더에 존재할 수 있다. 또한, 본 명세서의 일 실시예에서, HMVP 후보를 HMVP LUT에 추가함에 있어서, 디코딩을 위한 유연성 (flexibility)을 고려하는 방법을 제안한다. 인코더/디코더는 HMVP 후보를 테이블에 추가함에 있어서 PU(또는 CU)의 하나 또는 그 이상의 특성들에 대한 결정(decision) 기준을 고려할 수 있다. 실시예로서, 인코더/디코더는 HMVP 후보를 테이블에 추가함에 있어서 다음과 같은 사항을 고려할 수 있다. 인코 더/디코더는 PU의 모드(예컨대, 머지 모드, 어파인 모드, AMVP 모드 등) 및/또는 블록의 사이즈와 같은 특성들 을 개별적으로 또는 조합하여 고려하여 후보로서 추가할 수 있다. 일 실시예에서, 이외에 다른 추가적인 특성들 이 고려될 수도 있다. 예를 들어, HMVP LUT 업데이트를 고려하는 머지 타입(예컨대, 공간 후보 또는 시간 후 보), 서브 PU인지 여부 등이 후보 선택 기준으로 고려될 수 있다. 상술한 선택 기준은 이전 히스토리(또는 이전 HMVP)와의 중복을 감소시키기 위해 결정될 수 있다. 예를 들어, PU가 머지 모드로 코딩되고 머지 타입이 공간 머지인 경우, 디코더는 해당 PU의 모션 정보를 HMVP LUT에 업데이트하지 않을 수 있다. 도 31은 본 명세서의 실시예에 따른 HMVP LUT를 업데이트하는 방법의 일 예를 나타내는 도면이다. 도 31을 참조하면, 인코더/디코더는 코딩된 후보의 모션 정보를 획득한다(S3101). 인코더/디코더는 상기 후보의 모션 정보를 LUT에 업데이트할지 여부를 미리 정의된 결정 기준에 따라 평가한다 (S3102). 전술한 바와 같이, 상기 결정 기준은 상기 후보의 모드(예컨대, 머지 모드, 어파인 모드, AMVP 모드 등), 상기 후보의 블록 사이즈 및/또는 상기 후보의 머지 타입 중 적어도 하나에 관한 특성을 포함할 수 있다. 인코더/디코더는 상기 결정 기준에 기초하여 LUT 를 업데이트한다(S4303). 즉, 상기 후보가 미리 정의된 결정 기준을 만족하는 경우, 인코더/디코더는 상기 후보의 모션 정보를 LUT에 추가할 수 있다. 또한, 본 명세서의 일 실시예에서, HMVP 후보를 머지 리스트(또는 AMVP 리스트)에 추가하기 위한 중복성 체크에 대한 제한을 제안한다. 중복성 체크에 대한 제한은 다양한 여러 방법으로 정의(또는 구현)될 수 있다. 일 실시예에서, 인코더/디코더는 머지 리스트 내 처음 특정 개수의 후보들에 대한 프루닝 체크의 수를 제한할 수 있다. 실시예로서, 인코더/디코더는 머지 리스트의 첫 번째 후보부터 특정 개수 번째 후보까지의 후보들에 대한 프루닝 체크의 수를 제한할 수 있다. 예를 들어, 인코더/디코더는 머저 리스트의 첫 번째 후보부터 특정 개수 번째 후보까지의 후보들에 대한 프루닝 프로세스를 수행할 수 있다. 그리고, 프루닝 체크의 대상이 되는 HMVP 후보는 미리 정의된 개수로 제한될 수 있다. 또한, 일 실시예에서, 인코더/디코더는 프루닝 체크를 머지 리스트 내 머지 후보의 특정 타입에 대하여 수행함 으로써 프루닝 체크를 제한할 수 있다. 예를 들어, 인코더/디코더는 HMVP 후보를 추가함에 있어서 머지 리스트 의 공간 후보에 대해서만 프루닝 체크를 수행할 수 있다. 또는, 예를 들어, 인코더/디코더는 HMVP 후보를 추가 함에 있어서 머지 리스트의 공간 후보의 일부에 대해서만 프루닝 체크를 수행할 수 있다. 상기 공간 후보의 일 부는 미리 정의될 수 있다. 예컨대, 상기 미리 정의되는 공간 후보의 일부는 좌측 이웃 공간 후보 및/또는 상측 이웃 공간 후보 중 적어도 하나일 수 있다. 또는, 예를 들어, 인코더/디코더는 HMVP 후보를 추가함에 있어서 머 지 리스트의 공간 후보의 일부에 대해서만 프루닝 체크를 수행할 수 있고, 상기 공간 후보의 일부는 좌측 및 상 측으로 미리 정의될 수 있다. 상술한 예시들에 의해 본 명세서의 실시예가 이에 제한되는 것은 아니며 여러 타 양한 타입의 머지 후보가 조합되어 프루닝 체크의 대상으로 제한될 수 있다. 도 32는 본 명세서의 실시예에 따른 프루닝 체크의 대상이 되는 HMVP 후보의 수를 제한하는 방법을 예시하는 도 면이다. 도 32를 참조하면, 본 명세서의 일 실시예에서, 프루닝 체크의 대상이 되는 HMVP 후보의 수는 M개로 제한될 수 있다. 인코더/디코더는 HMVP 후보를 이용하여 머지 리스트를 구성함에 있어서, HMVP LUT 내 M개의 후보들과 상 기 머지 리스트의 머지 후보들간 모션 정보의 중복성 여부를 체크할 수 있다. 또는, 인코더/디코더는 현재 디코딩된 처리 블록(예컨대, PU)의 모션 정보를 HMVP LUT에 추가함에 있어서, HMVP LUT 내 M개의 후보들과 상기 디코딩된 PU의 모션 정보간 중복성 여부를 체크할 수 있다. 도 33은 본 명세서의 실시예에 따른 프루닝 체크 수행 방법의 일 예를 나타내는 흐름도이다. 도 33을 참조하면, 인코더/디코더는 디코딩된 후보의 모션 정보를 획득하고, 프루닝 체크의 수를 결정(또는 해 독)한다(S3301, S3302). 상기 프루닝 체크의 수는 앞서 설명한(예컨대, 도 32에서 설명한) 방법에 따라 인코더/ 디코더에 미리 정의될 수 있다. 인코더/디코더는 결정된 프루닝 체크의 수를 기반으로 프루닝 체크를 수행한다 (S4503). 일 실시예에서, 앞서 표 3 및 표 4와 마찬가지 방법으로 프루닝 체크에 관련된 정보는 상위 레벨 신택스를 통해 시그널링될 수 있다. 이때, 인코더로부터 디코더로 전송되는 신택스 엘리먼트는 프루닝 체크의 수를 지시하기 위하여 특정 상위 레벨 신택스를 통해 시그널링될 수 있다. 상기 상위 레벨 신택스는, 예를 들어, 시퀀스 파라 미터 세트(sequence parameter set), 픽처 파라미터 세트(picture parameter set), 슬라이스 헤더(slice header), 코딩 트리 유닛(coding tree unit), 코딩 유닛(coding unit) 및/또는 다른 신택스 데이터 헤더에 포 함될 수 있다. 본 명세서의 일 실시예에서, HMVP 후보를 선택하는 효율적인 방법을 제안한다. 히스토리 모션 벡터 후보(즉, HMVP 후보)를 머지 리스트(또는 AMVP 리스트)에 삽입할 때, HMVP 후보는 기존의 머지 리스트와 중복되지 않도록 하기 위해 프루닝 체크가 수행될 수 있다. 이때, M 크기의 머지 리스트와 N 크기의 히스토리 LUT간 전체 중복 체크를 수행하려면 (M-1)xN 회의 체크를 필요로 한다. 따라서, 본 명세서의 실시예에서, HMVP 후보의 수는 머지 후보에 의존할 수 있다. 예를 들어, HMVP 후보의 수는 머지 리스트에 존재하는 공간 후보의 수에 의존할 수 있다. 또는, 예를 들어, HMVP 후보의 수는 머지 리스트에 존재하는 공간 후보 및 시간 후보의 수에 의존할 수 있다. 만약, 머지 리스트에 존재하는 머지 후보가 더 존재하는 경우, 머지 리스트의 머지 후보의 수 및/또는 HMVP의 수에 기반한 특정 기준(또는 규칙)에 따라 프루닝 체크를 수행할 HMVP 후보의 수가 감소될 수 있다. 이를 통해, 최악의 케이스에서의 중복 체크 수가 줄어들 수 있다. 예를 들어, 크기(또는 길이)가 6인 머지 리스트의 경우, 머지 리스트가 가득차지 않으면 머지 리스트는 최대 5 개의 공간 또는 다른 머지 후보를 포함할 수 있다. 6개의 HMVP 리스트에서 HMVP 후보를 삽입하려면 최악의 경우 30 개의 중복 체크가 필요할 수 있다. 일 실시예에서, 프루닝 체크의 대상이되는 HMVP 수에 대한 제한과 관련된 예시는 다음의 수학식 17 및 표 5과 같다. 수학식 17"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 22, "content": "표 5 표 5를 참조하면, 프루닝 체크의 대상이 되는 HMVP의 수를 2개로 제한함으로써 최악의 케이스에서 HMVP 추가를 위한 중복 체크의 수는 30회 대신 12회로 감소할 수 있다. 본 명세서의 일 실시예에서, 히스토리 기반 공간 시간 모션 벡터 예측(history-based spatial temporal motion vector prediction, H-STMVP)을 사용하여 머지 리스트를 구성하는 방법을 제안한다. H-STMVP 는 2개의 히스토 리 기반 공간 MVP 및 TMVP의 평균으로 유도되는 후보를 나타낸다. 상기 2개의 공간 HMVP는 HMVP 버퍼로부터 획 득될 수 있고, 상기 TMVP는 현재 머지 리스트로부터 획득될 수 있다. 여기서, 상기 공간 후보는 현재 블록 이전 의 디코딩 순서에서 마지막 2 개의 코딩된 MV로부터 획득된 후보일 수 있다. 예를 들어, 마지막 코딩된 MV(본 명세서에서 MV_L이라 지칭함), 마지막에서 두 번째로 코딩된 MV(본 명세서에서 MV_(L-1)이라 지칭함) 및 MV_TMVP는 머지 리스트에 삽입될 H-STMVP 후보를 생성하는 데 사용될 수 있다. 상술한 3개의 후보를 모두 사용할 수 있는 경우, 머지 리스트에 추가되는 MV는 다음의 수학식 18에 의해 계산될 수 있다. 수학식 18"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 23, "content": "일 실시예로서, 만약, 상술한 3개의 후보 중 2개만이 이용 가능하다면, 2개의 후보에 대해서만 평균화되어 H- STMVP가 생성될 수 있다. 마찬가지로, 하나의 후보만 사용 가능하다면, 상기 하나의 후보만 사용될 수 있다. 사 용 가능한 후보가 없는 경우 H-STMVP는 머지 리스트 구성에 사용되지 않을 수 있다. 본 명세서의 일 실시예에서, 상술한 수학식 18 이외에 다른 방법을 이용하여 H-STMVP 후보의 모션 벡터를 획득 하는 방법을 제안한다. 예를 들어, 3개 이상의 후보를 한번에 평균화하는 대신, 공간 후보를 먼저 평균화한 다음, 이 결과를 사용하여 2개의 후보를 다시 평균화하는 것이 계산적으로 더 간단할 수 있다. 이에 대한 예시는 다음의 수학식들과 같다. 수학식 19"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 24, "content": "또는, 다음과 같이 평균값을 획득할 수도 있다. 수학식 20"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 25, "content": "수학식 21 수학식 22"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 26, "content": "인코더/디코더는 수학식 19 내지 21과 같이 먼저, 2개의 후보를 평균하고, 세 번째 후보를 이용하여 결과값을 최종적으로 평균화할 수 있다. 또는 인코더/디코더는 수학식 22과 같이, 2만큼 시프트 연산을 적용함으로써, 후 보, 즉 MV_L에 더 높은 중요도/가중치를 부여할 수 있다. 상술한 수학식 19 내지 22를 사용하여 시프트 연산 만 으로 나눗셈 연산 없이 평균값을 유도할 수 있다. 본 명세서의 일 실시예에서, H-STMVP를 유도함에 있어서, 2개의 히스토리 기반 공간 후보 대신 임의의 개수(n) 의 공간 후보를 사용하는 방법을 제안한다. 이들 n 개의 후보는 반드시 연속적인 디코딩 순서일 필요는 없다. 임의로 또는 일부 규칙에 따라 선택할 수 있다. 따라서, 앞서 설명한 수학식 18는 다음의 수학식 23과 같이 보다 일반적인 방식으로 표현될 수 있다. 수학식 23"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 27, "content": "다른 일 실시예에서, 만약, 5개의 공간 후보를 사용하는 경우를 가정하면, 시간 후보에 적용되는 가중치를 향상 시킴으로써, H-STMVP 후보를 생성하기 위해 증가된 공간 후보의 영향을 최소화하고, 공간 후보 및 시간 후보를 적절히 반영할 수 있다. 따라서, 이를 위해 다음의 수학식 24를 이용하여 공간 후보를 함께 평균한 다음, 그 결과를 사용하여 MV_TMVP를 평균화함으로써 상술한 목적을 달성할 수 있다. 수학식 24"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 28, "content": "본 명세서의 일 실시예에서, H-STMVP를 유도하기 위해 이용되는 모션 벡터 후보에 가중치(또는 가중 인자)를 추 가하는 방법을 제안한다. 이때, 상기 가중치는 경험적으로 결정될 수도 있고, 고정된 참조 프레임까지의 시간 거리를 고려하여 결정될 수도 있고, 또는 히스토리 테이블에서의 위치를 고려함으로써 결정될 수도 있다. 일 예 로서, 새로운 후보는 이전 후보보다 더 많은 가중치를 가질 수 있다. 즉, 본 실시예에서, 앞서 설명한 수학식 18은 다음의 수학식 25와 같이 표현될 수 있다. 수학식 25"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 29, "content": "이때, 가중치는 동일한 값을 가질 수도 있고, 불균등하게 분산된 값을 가질 수도 있다. 본 명세서의 일 실시예에서, H-STMVP 후보를 유도하기 위하여 사용되는 움직임 벡터를 단일 참조 픽쳐로로 스케 일링하는 방법을 제안한다. 도 34는 본 명세서의 일 실시예에 따른 서로 다른 참조 픽쳐를 참조하는 모션 벡터들을 이용하여 H-STMVP 후보 를 유도하는 방법을 설명하기 위한 도면이다. 도 34를 참조하면, MV_L, MV_L-1 및 MV_TMVP 후보는 각각 서로 다른 참조 픽쳐를 참조(또는 지시)하는 경우를 가정한다. 즉, 도 34는 H-STMVP 후보를 생성하는데 사용된 각 후보가 다른 참조 인덱스를 가질 수 있으며 결과 적으로 다른 참조 프레임을 가질 수 있음을 보여준다. 근접 참조 프레임이있는 프레임이 본질적으로 H-STMVP의 모션 벡터에 더 큰 영향을 미칠 수 있으므로, 상술한 수학식 18 내지 25의 평균을 불균등한 결과 값으로 만들 수 있다. 따라서, 균등한 비교 및 반영을 위해 모든 모 션 벡터를 단일 참조 프레임으로 스케일링하는 방법을 제안한다. 이때, 인코더에서 RD 최적화의 일부로 수행되어 어떤 단일 프레임이 참조 프레임으로 사용하기에 가장 적합한지 를 결정될 수 있다. 실시예로서, 선택된 참조 프레임은 슬라이스 헤더에 존재하는 TMVP 배열 인덱스와 유사한 슬라이스 헤더에서 시그널링 될 수 있다. 예를 들어, 고정된 규칙을 사용하여 사용될 참조 프레임을 생성하는 것이 가능할 수 있다. 또는, 예를 들어, L0으로부터 첫 번째 이용 가능한 기준 프레임으로 스케일링되거나, 현 재 픽처 순서 카운트로 스케일링 될 수 있다. 일 실시예에서, 상술한 목적을 달성하기 위해 시퀀스 파라미터 세트, 픽쳐 파라미터 세트, 슬라이스 헤더, 코딩 트리 유닛 및/또는 다른 데이터 헤더의 일부일 수 있는 상위 레벨 신택스(HLS)를 이용하여 단일의 고정된 픽쳐 에 대한 정보를 인코더가 디코더로 전송할 수 있다. 예를 들어, 다음의 표 6 및/또는 표 7과 같은 상위 레벨 신 택스 구조가 정의될 수 있다. 표 6"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 30, "content": "표 6을 참조하면, set_HSTMVP_ref_pic_flag가 1과 같으면 set_HSTMVP_idx가 CVS에서 비 IDR 픽처의 슬라이스 헤더에 존재함을 나타낸다. set_HSTMVP_ref_pic_flag가 0이면 set_HSTMVP_idx가 슬라이스 헤더에 존재하지 않 도록 나타낸다. 표 7"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 31, "content": "표 7을 참조하면 slice_HMVP_idx는 참조 인덱스를 지정한다. 일 실시예로서, 참조 인덱스는 리스트 L0에 대해 선택될 수 있다. 본 명세서의 실시예에서, 앞서 설명한 실시예에 관하여 보다 상세한 실시예를 설명한다. 구체적으로, 현재 블록 의 CPMV를 계산(또는 유도)하기 위하여 위치 및 차원 정보를 사용하여 어파인 HMVP 후보를 간접적으로 사용하는 방법을 제안한다. 본 명세서에서, 유도된 CPMV는 상속된 어파인 HMVP 후보로 지칭될 수 있다. 본 명세서의 실시 예에 따른 상속된 어파인 HMVP 후보는 전술한 어파인 머지 리스트 및/또는 어파인 AMVP 리스트 생성 프로세스에 서 사용될 수 있다. 도 35는 본 명세서의 실시예에 따른 상속된 어파인 HMVP 후보를 유도하기 위한 블록의 위치를 예시하는 도면이 다. 도 35를 참조하면, 어파인 HMVP 후보의 위치 및 차원에 기초하여 현재 블록의 CPMV는 일반적인 상속된 CPMV를 주변 블록으로부터 유도하는 방법과 유사한 방법으로 유도될 수 있다. 즉, 인코더/디코더는 어파인 HMVP 후보인 참조 블록의 위치 및 차원(예컨대, 너비 및 높이) 정보에 기초하여 현재 블록의 제어점의 모션 벡터를 유도할 수 있다. 일 실시예로서, 현재 블록의 상속된 어파인 HMVP의 CPMV는 다음의 수학식 26 및 27을 이용하여 유도될 수 있다. 수학식 26"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 32, "content": "수학식 27"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 33, "content": "수학식 26 및 27에서, posCurCU_Y는 현재 블록의 좌상단 샘플의 수직 방향 좌표 값을 나타내고, posRefCU_Y는 참조 블록의 좌상단 샘플의 수직 방향 좌표 값을 나타낸다. posCurCU_X 는 현재 블록 의 좌상단 샘플의 수평 방향 좌표 값을 나타내고, posRefCU_X는 참조 블록의 좌상단 샘플의 수평 방향 좌표 값을 나타낸다. RefCU_height는 참조 블록의 높이를 나타내고, RefCU_width는 참조 블록 의 너비를 나타낸다. 본 명세서의 일 실시예에서, 어파인 HMVP 후보(직접 또는 상속된 HMVP)를 추가할때, 어파인 머지 또는 어파인 AMVP 리스트 생성에 사용될 수 있는 어파인 HMVP 후보를 선택하도록 제한 사항이 추가될 수 있다. 일 예로서, 어파인 HMVP 후보는 상기 어파인 HMVP 후보가 현재 블록에 인접하는 경우에만, 어파인 머지 또는 어 파인 AMVP 리스트에 추가될 수 있다. 다른 일 예로서, 어파인 HMVP 후보는 상기 어파인 HMVP 후보가 현재 블록으로부터 특정 거리 내에 위치(또는 존 재)하는 경우에만, 어파인 머지 또는 어파인 AMVP 리스트에 추가될 수 있다. 예를 들어, 상기 특정 거리는 미리 정의된 픽셀 거리일 수 있다. 인코더/디코더는 어파인 HMVP 후보가 이용 가능한지 판단하기 위해 상기 어파인 HMVP 후보가 미리 정의된 특정 거리 내에 위치하는지 여부를 판단(또는 결정)할 수 있다. 다른 일 예로서, 어파인 HMVP 후보는 현재 블록을 기준으로 특정 위치에 위치(또는 존재)하는 경우에만, 어파인 머지 또는 어파인 AMVP 리스트에 추가될 수 있다. 예를 들어, 상기 특정 위치에 존재하는 경우는 상기 어파인 HMVP 후보가 현재 블록의 좌측 또는 상측 이웃 블록인 경우일 수 있다. N개의 엘리먼트를 갖는 어파인 HMVP LUT에 대하여, 모든 엘리먼트 또는 처음 M개의 엘리먼트에 대한 상술한 확 인 프로스세가 머지 또는 AMVP 리스트가 가득찰 때까지 또는 미리 정의된 특정 HMVP 후보 수에 도달할 때까지 수행될 수 있다. 본 명세서의 일 실시예에서, 어파인 HMVP 후보는 어파인 머지 리스트 및/또는 어파인 AMVP 리스트에서 기존에 존재하는 상속된 어파인 후보를 대체하는데 사용하는 방법을 제안한다. 도 36은 본 명세서의 실시예에 따른 어파인 머지 리스트 또는 어파인 AMVP 리스트를 예시하는 도면이다. 도 36을 참조하면, 인코더/디코더는 기존의 어파인 머지 리스트 또는 어파인 AMVP 리스트에 존재하는 상속된 후 보를 상속된 어파인 HMVP 후보로 대체할 수 있다. 즉, 인코더/디코더는 현재 블록에 서브 블록 기반 머지 모드 가 적용되는 경우, 상속된 어파인 후보 및 구성된 어파인 후보를 이용하여 서브 블록 기반 머지 후보 리스트를 생성하고, 상속된 어파인 HMVP 후보를 유도하여 상기 서브 블록 기반 머지 후보 리스트에 포함된 적어도 하나의 상속된 어파인 후보를 상속된 어파인 HMVP 후보로 대체할 수 있다. 또한, 본 발명의 일 실시예에서, 어파인 HMVP 룩업 테이블(LUT)은 슬라이스, CTU 행(row), 또는 CTU의 시작에서 초기화될 수 있다. 이를 통해 병렬 처리 수행성을 향상시킬 수 있다. 이하, 후술하는 실시예들에서는 HMVP로부터의 최악의 프루닝 체크(pruning check)의 수를 감소시키기 위한 방법 을 제안한다. 본 명세서의 실시예에서, HMVP 후보가 머지 목록에 추가되는 경우, 프루닝 체크의 수는 머지 리스트 내 이용 가 능한 후보의 수 및 머지 리스트에 추가될 수 있는 HMVP 후보의 수에 기초하여 결정될 수 있다. 이하에서, 본 명 세서의 실시예들을 설명함에 있어서, 설명의 편의를 위해 아래와 같이 변수들을 정의하여 설명한다. - N ST: 머지 리스트 내 이용 가능한(또는 존재하는) 후보의 수 - N HMVP: 테이블 내 HMVP 후보의 수 (즉, HMVP 테이블 크기) - N mrgToBeAdded: 머지 리스트에 추가되는 HMVP 후보의 수 - N HMVPChecked: 프루닝 체크되는 HMVP 후보의 수 - N max_hmvp_prunning: HMVP 후보를 머지 리스트에 추가하기 위해 요구되는 최악의 경우의 프루닝 체크 수 본 명세서의 일 실시예에서, HMVP 후보는 다음의 조건에 따라 머지 리스트에 추가될 수 있다. - 제1 조건: LUT는 이전에 프루닝된 경우(즉, HMVP LUT 내 후보들간 동일한 mv는 없는 경우) - 제2 조건: HMVP LUT 테이블의 크기가 6인 경우 - 제3 조건: HMVP 후보를 머지 리스트에 추가하기 위하여 이용 가능한(또는 존재하는) 머지 후보의 최대 개수가 4인 경우. 즉, 최대 머지 리스트 크기(또는, 최대 머지 후보)에서 1을 감산한 값보다 머지 리스트 내 머지 후보 개수가 작은 경우. 예를 들어, 최대 머지 리스트 크기는 6일 수 있고, 현재 이용 가능한 머지 후보의 개수가 5 보다 작은 경우 HMVP 후보를 추가(또는 삽입)될 수 있다. 다시 말해, HMVP 후보는 머지 리스트 인덱스 5까지만 추가될 수 있다. HMVP 후보가 머지 리스트에 추가되면(즉, 머지 후보가 되면), 각 HMVP 후보는 머지 후보들 간 중복을 제거하기 위해 프루닝 체크가 필요할 수 있다. 기존의 영상 압축 기술에 따르면, 머지 리스트에 HMVP를 추가하기 위하여 필요한 최악의(또는 최악의 경우의) 프루닝 체크 수는 다음의 표 8와 같이 계산될 수 있다. 표 8 표 8을 참조하면, 기존의 영상 압축 기술에 따르면, HMVP 테이블(또는 HMVP 리스트, HMVP 후보 리스트)내 6개의 HMVP 후보에 대하여 프루닝 체크가 수행될 수 있다. 구체적으로, 1) 머지 리스트 내 후보가 1개인 경우, 머지 리스트에 추가되는 HMVP 후보는 4개일 수 있다. 그리 고, 6개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 4일 수 있다. 2) 머지 리스트 내 후보가 2개인 경우, 머지 리스트에 추가되는 HMVP 후보는 3개일 수 있다. 그리고, 6개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 7일 수 있다. 3) 머지 리 스트 내 후보가 3개인 경우, 머지 리스트에 추가되는 HMVP 후보는 2개일 수 있다. 그리고, 6개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 9일 수 있다. 4) 머지 리스트 내 후보 가 4개인 경우, 머지 리스트에 추가되는 HMVP 후보는 1개일 수 있다. 그리고, 6개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 10일 수 있다. 본 명세서의 실시예에서, 앞서 설명한 최악의 프루닝 체크 수의 수를 줄이기위한 방법을 제안한다. 만약 머지 리스트에 머지 후보들이 더 많이 존재하는 경우, 머지 후보들(즉, 비 HMVP 후보들)이 증가함에 따라 HMVP의 코 딩 영향이 감소하기 때문에, 프루닝 체크할 HMVP 후보들의 수가 감소될 필요가 있을 수 있다. 따라서, 본 명세 서의 실시예에서, 인코더/디코더는 최악의 프루닝 체크를 줄이기 위해, 체크될 HMVP 후보의 수(N HMVPChecked)를 추 가될 이용 가능한 HMVP 후보의 수(N mrgToBeAdded)와 동일하게 설정될 수 있다. 이 경우 최악의 프루닝 체크 수는 다음의 표 9와 같이 계산될 수 있다. 표 9"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 34, "content": "표 9를 참조하면, 종래의 영상 압축 기술과 비교했을 때 HMVP를 위한 최악의 프루닝 체크의 수는 10개에서 6개 로 줄어들 수 있다. 표 9를 참조하면, 일 실시예에서, 1) 머지 리스트 내 후보가 1개인 경우, 머지 리스트에 추가되는 HMVP 후보는 4개일 수 있다. 그리고, 4개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 4일 수 있다. 2) 머지 리스트 내 후보가 2개인 경우, 머지 리스트에 추가되는 HMVP 후보는 3개일 수 있다. 그리고, 3개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 6일 수 있 다. 3) 머지 리스트 내 후보가 3개인 경우, 머지 리스트에 추가되는 HMVP 후보는 2개일 수 있다. 그리고, 2개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 6일 수 있다. 4) 머지 리 스트 내 후보가 4개인 경우, 머지 리스트에 추가되는 HMVP 후보는 1개일 수 있다. 그리고, 1개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 4일 수 있다. 본 명세서 실시예에서, 최악의 프루닝 체크를 줄이기 위해, 인코더/디코더는 프루닝 체크되는 HMVP 후보의 수(N HMVPChecked)를 추가되는 이용 가능한 HMVP 후보의 수(N mrgToBeAdded)와 K의 합과 동일한 값으로 설정할 수 있다. 여기 서, K는 미리 정의된 상수 값을 나타낸다. 일 예로서, K가 1인 경우, 최악의 프루닝 체크 수는 다음의 표 10과 같이 계산될 수 있다.표 10"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 35, "content": "표 10을 참조하면, 일 실시예에서, 1) 머지 리스트 내 후보가 1개인 경우, 머지 리스트에 추가되는 HMVP 후보는 4개일 수 있다. 그리고, 5개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 4일 수 있다. 2) 머지 리스트 내 후보가 2개인 경우, 머지 리스트에 추가되는 HMVP 후보는 3개일 수 있다. 그리고, 4개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 7일 수 있 다. 3) 머지 리스트 내 후보가 3개인 경우, 머지 리스트에 추가되는 HMVP 후보는 2개일 수 있다. 그리고, 3개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 8일 수 있다. 4) 머지 리 스트 내 후보가 4개인 경우, 머지 리스트에 추가되는 HMVP 후보는 1개일 수 있다. 그리고, 2개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 7일 수 있다. 본 명세서의 실시예에서, 최악의 경우 프루닝 체크을 감소시키기 위해, 체크되는 HMVP 후보의 수(N HMVPChecked)는 다음의 수학식 28와 같이 정의될 수 있다. 수학식 28"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 36, "content": "수학식 28에서, C는 미리 정의된 상수 값을 나타낸다. 만약, C가 2인 경우 최악의 프루닝 체크 수는 다음의 표 11와 같이 계산될 수 있다. 표 11"}
{"patent_id": "10-2023-7043224", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 37, "content": "표 11을 참조하면, 일 실시예에서, 1) 머지 리스트 내 후보가 1개인 경우, 머지 리스트에 추가되는 HMVP 후보는 4개일 수 있다. 그리고, 6개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 4일 수 있다. 2) 머지 리스트 내 후보가 2개인 경우, 머지 리스트에 추가되는 HMVP 후보는 3개일 수 있다. 그리고, 6개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 7일 수 있 다. 3) 머지 리스트 내 후보가 3개인 경우, 머지 리스트에 추가되는 HMVP 후보는 2개일 수 있다. 그리고, 4개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 9일 수 있다. 4) 머지 리스트 내 후보가 4개인 경우, 머지 리스트에 추가되는 HMVP 후보는 1개일 수 있다. 그리고, 2개의 HMVP 후보에 대한 프루닝 체크가 수행될 수 있다. 이 경우, 최악의 프루닝 체크 수는 7일 수 있다. HMVP가 머지 리스트 및/또는 AMVP 리스트 구성에 추가되는 경우, 머지 리스트 및/또는 AMVP 리스트 내 존재하는 후보들과의 중복을 피하기 위하여 프루닝이 다시 수행될 필요성이 있다. 만약 HMVP LUT가 앞서 도 29에서 설명 한 바와 같이 제한적 FIFO 동작에 의해 이미 프루닝된 경우, HMVP 후보를 머지 리스트에 삽입(또는 추가)할 때, HMVP 후보들 사이에서 비교(또는 프루닝 체크)는 필요하지 않을 수 있다. 이로 인해, 앞서 도 28에서 설명한 바 와 같은 비제한적 FIFO 테이블을 사용하는 경우 대비 프루닝 체크의 수를 줄일 수 있다. 왜냐하면, HMVP 후보들 간 프루닝 체크는 HMVP 후보를 머지 리스트에 삽입할 때 필요하기 때문이다. 전술한 바와 같이, 본 명세서에서, HMVP LUT는 그 명칭에 제한되지 않으며, LUT, 테이블, HMVP 테이블, HMVP 후보 테이블, 버퍼, HMVP 버퍼, HMVP 후보 버퍼, HMVP 리스트, HMVP 후보 리스트, HMVP 머지 후보 리스트, 히스토리 기반 머지 후보 리스트 등으로 지칭될 수 있다. 본 명세서의 일 실시예에서, 머지 리스트 및/또는 AMVP 리스트 구성을 위한 HMVP 후보 삽입 프로세스를 고려한 HMVP 룩업 테이블 (LUT) 크기를 정의할 수 있다. 구체적으로, HMVP 후보는 미리 정의된 머지 리스트 크기까지 추가될 수 있다. 예를 들어, 최대 머지 리스트의 크기가 6으로 정의된 경우, HMVP는 6 번째 후보가 되지 않을 수 있다. 만약, 머지 리스트에 5개의 머지 후보가 이용 가능한(또는 존재하는) 경우, HMVP 후보는 추가되지 않 을 수 있다. 이 경우, 6 번째 후보는 HMVP를 제외한 후보(또는 이외의 다른 방법)으로부터 선택될 수 있다. 따 라서, 상술한 HMVP 후보 삽입 프로세스를 고려하면, 본 명세서의 일 실시예에서, 다음과 같은 HMVP LUT 크기 선 택 방법을 제안한다. 일 실시예로서, HMVP LUT 테이블 크기는 (MaxNumMergeCand - K)와 동일하게 정의(또는 설정)될 수 있다. 여기서, MaxNumMergeCand는 최대 머지 후보 리스트(또는 머지 후보 리스트의 최대 개수, 최대 머지 후보 개수) 를 나타내고, 이때, MaxNumMergeCand는 6으로 정의될 수 있다. K는 미리 정의된 상수를 나타낸다. 예를 들어, K 는 1일 수 있고, 이때, HMVP LUT 크기는 5일 수 있다. 본 명세서의 실시예에 따르면, HMVP를 MaxNumMergeCand - K (상술한 바와 같이, 예컨대 K는 1)로 제한함으로써, HMVP를 머지 리스트 및/또는 HMVP 테이블에 추가할 때, 최악의(또는 최악의 경우의) 프루닝 체크 수를 줄일 수 있다. (앞서 도 29에서 설명한 제한된 FIFO 동작). 또한, 본 발명의 실시예에 따르면, HMVP LUT 저장을 위한 메 모리가 감소할 수 있다. 본 명세서의 실시예에서, 상술한 HMVP 테이블 크기를 고려하여 HMVP 모션 후보를 갖는 테이블에 대하여 이하에 서 설명하는 실시예와 같은 업데이트 프로세스가 적용될 수 있다. 이하의 실시예는 HMVP 테이블 업데이트 프로 세스의 일 예로서 본 명세서의 실시예가 이에 한정되는 것은 아니다. HMVP 테이블 업데이트 프로세스 먼저, HMVP 테이블 업데이트 프로세스의 입력은 다음과 같이 정의될 수 있다. - 모션 벡터 mvL0 및 mvL1 - 참조 인덱스 refIdxL0 및refIdxL1 - 예측 리스트 활용 플래그 predFlagL0 및 predFlagL1 본 업데이트 프로세스의 출력은 HMVP 후보 리스트의 수정된 배열일 수 있다. 본 프로세스에서, mvCand는 상기 모션 벡터, 상기 참조 인덱스, 상기 예측 리스트 활용 플래그를 갖는 모션 벡터 후보를 지칭하는 변수를 나타낸 다. 본 업데이트 프로세스는 다음과 같은 단계로 수행될 수 있다. 1. 변수 identicalCandExist는 거짓(false)로 설정되고, 변수 tempIdx는 0으로 설정된다. 여기서, identicalCandExist는 HMVP 후보 리스트에 동일한 모션 정보가 존재하는지 나타내는 변수이고, tempIdx는 현재 모션 벡터와 HMVP 후보 리스트 내에서 동일한 모션 정보를 갖는 HMVP 후보의 인덱스를나타내는 변수이다. 2. HMVPCandNum이 0보다 큰 경우, HMVPIdx=0..HMVPCandNum-1인 각각의 인덱스 HMVPIdx에 대해, identicalCandExist 변수가 참(true)이 될 때까지 다음 단계가 적용될 수 있다. 여기서, HMVPCandNum은 HMVP 후보 리스트의 HMVP 후보 개수를 나타내고, HMVPIdx는 HMVP 후보 리스트 내 HMVP 후보들에 할당된 인덱스를 나 타낸다.- 만약, mvCand가 HMVPCandList[HMVPIdx](즉, HMVP 후보 리스트 내 HMVPIdx를 갖는 HMVP 후보)와 동일한 모션 벡터 및 동일한 참조 인덱스를 갖는 경우, identicalCandExist는 참으로 설정되고, tempIdx는 HMVPIdx로 설정 될 수 있다. 3. 그리고, HMVP 후보 리스트는 다음의 단계에 따라 업데이트될 수 있다. 만약, identicalCandExist가 참이거나 또는 HMVPCandNum이 MaxNumMergeCand-K인 경우(와 동일한 경우), 이 하의 단계가 적용될 수 있다. 여기서, MaxNumMergeCand은 머지 리스트(또는 머지 후보 리스트)의 크기(또는 머 지 리스트의 최대 후보 개수, 최대 머지 후보 개수)를 나타내는 변수이고, K는 임의의 상수이다. 일 실시예에서, K는 미리 정의될 수 있다. 또한, 일 실시예에서, K는 1로 설정될 수 있고, MaxNumMergeCand 값이 6 으로 정의됨에 따라 MaxNumMergeCand-K는 5일 수 있다. 또한, 일 실시예에서, MaxNumMergeCand-K는 5로 설정될 수 있다. 예를 들어, identicalCandExist가 참이거나 또는 HMVPCandNum이 5인 경우, 이하의 단계가 적용될 수 있다. - idx=(tempIdx+1)..(HMVPCandNum-1)인 각각의 인덱스 idx에 대해, HMVPCandList[idx-1]는 HMVPCandList[idx] 로 설정될 수 있다. 즉, tempIdx 이후의 인덱스를 가지는 HMVP 후보의 인덱스는 그 값이 1만큼 줄어든 값으로 설정될 수 있다. - HMVPCandList[HMVPCandNum-1]는 mvCand로 설정될 수 있다. 그렇지 않으면(즉, identicalCandExist는 거짓이고, HMVPCandNum이 MaxNumMergeCand-K보다 작은 경우), 이 하의 단계가 적용될 수 있다. 상술한 바와 같이, 일 실시예에서, MaxNumMergeCand-K는 5로 설정될 수 있다. 예 를 들어, 그렇지 않으면(즉, identicalCandExist는 거짓이고, HMVPCandNum이 5보다 작은 경우), 이하의 단계가 적용될 수 있다. - HMVPCandList[HMVPCandNum++]는 mvCand로 설정될 수 있다. 일 예로서, 본 업데이트 프로세스는 현재 슬라이스가 P 또는 B 슬라이스 일 때 호출될 수 있다. 이때, 변수 HMVPCandNum은 0으로 설정되고 변수 HMVPCandList은 MaxNumMergeCand-K의 엘리먼트 배열로 정의될 수 있다. 상 술한 바와 같이, 일 실시예에서, MaxNumMergeCand-K는 5로 설정될 수 있다. 예를 들어, 이때, 변수 HMVPCandNum은 0으로 설정되고 변수 HMVPCandList은 5의 엘리먼트 배열로 정의될 수 있다. 이하에서는, HMVP 테이블 업데이트 프로세스의 다른 일 예를 설명한다. 먼저, 본 업데이트 프로세스의 입력은 다음과 같이 정의될 수 있다. - 모션 벡터 mvL0 및 mvL1 - 참조 인덱스 refIdxL0 및refIdxL1 - 예측 리스트 활용 플래그 predFlagL0 및 predFlagL1 본 업데이트 프로세스의 출력은 HMVP 후보 리스트의 수정된 배열일 수 있다. 본 프로세스에서, mvCand는 상기 모션 벡터, 상기 참조 인덱스, 상기 예측 리스트 활용 플래그를 갖는 모션 벡터 후보를 지칭하는 변수를 나타낸 다. 본 업데이트 프로세스는 다음과 같은 단계로 수행될 수 있다. 1. HMVPIdx=0..HMVPCandNum-1인 각각의 인덱스 HMVPIdx에 대해 변수 sameCand가 참(true)이 될 때까지 다음 단 계가 순서대로 적용될 수 있다. 여기서, sameCand는 HMVP 후보 리스트에 동일한 모션 정보가 존재하는지 나타내 는 변수이다. - 만약, mvCand가 HMVPCandList[HMVPIdx]와 동일한 모션 벡터 및 동일한 참조 인덱스를 갖는 경우, sameCand는 참으로 설정된다. - 그렇지 않으면, sameCand는 거짓(false)으로 설정된다. - HMVPIdx++ (즉, HMVPIdx는 1만큼 증가된다) 2. 변수 tempIdx는 HMVPCandNum으로 설정된다. 3. sameCand가 참이거나 또는 HMVPCandNum이 MaxNumMergeCand-K인 경우, tempIdx=(sameCand? HMVPIdx : 1)..HMVPCandNum-1인 각각의 인덱스 tempIdx에 대해, HMVPCandList[tempIdx]는 HMVPCandList [tempIdx-1]으로 복사(또는 설정)된다. K는 임의의 상수이다. 일 실시예에서, K는 미리 정의될 수 있다. 또한, 일 실시예에서, K 는 1로 설정될 수 있고, MaxNumMergeCand 값이 6으로 정의됨에 따라 MaxNumMergeCand-K는 5일 수 있다. 또한, 일 실시예에서, MaxNumMergeCand-K는 5로 설정될 수 있다. 4. mvCand는 HMVPCandList[tempIdx]에 복사된다. 5. HMVPCandNum이 MaxNumMergeCand-K보다 작으면 HMVPCandNum은 1 씩 증가한다다. 상술한 바와 같이, 일 실시 예에서, MaxNumMergeCand-K는 5로 설정될 수 있다. 이상에서 설명한 본 명세서의 실시예들은 설명의 편의상 각각의 실시예들을 구분하여 설명하였으나, 본 발명이 이에 제한되는 것은 아니다. 즉, 앞서 설명한 실시예들은 각각 독립적으로 수행될 수도 있고, 하나 이상의 여러 실시예가 조합되어 수행될 수도 있다. 도 37은 본 발명이 적용되는 실시예에 따른 히스토리 기반 모션 벡터 예측을 기반으로 비디오 신호를 처리하는 방법을 예시하는 흐름도이다. 도 37을 참조하면, 설명의 편의를 위해 디코더를 위주로 설명하나 본 발명이 이에 한정되는 것이 아니며, 본 명 세서의 실시예에 따른 히스토리 기반 모션 벡터 예측 기반 비디오 신호 처리 방법은 인코더와 디코더에서 동일 하게 수행될 수 있다. 디코더는 현재 블록의 공간(spatial) 및 시간(temporal) 이웃 블록에 기초하여 머지 후보 리스트(merge candidate list)를 구성한다(S3701). 디코더는 상기 현재 블록의 히스토리 기반 머지 후보(history based merge candidate)를 상기 머지 후보 리스트 에 추가한다(S3702). 디코더는 상기 머지 후보 리스트 내에서 상기 현재 블록의 인터 예측에 이용되는 머지 후보를 지시하는 머지 인 덱스(merge index)를 획득한다(S3703). 디코더는 상기 머지 인덱스에 의해 지시되는 머지 후보의 모션 정보에 기초하여 상기 현재 블록의 예측 샘플을 생성한다(S3704). 디코더는 상기 모션 정보에 기초하여 히스토리 기반 머지 후보 리스트(history based merge candidate list)를 업데이트 한다(S3705). 전술한 바와 같이, 실시예로서, 상기 히스토리 기반 머지 후보는 상기 머지 후보 리스트에 포함된 머지 후보들 중에서 미리 정의된 머지 후보와 중복되지 않는 모션 정보를 갖는 경우, 상기 머지 후보 리스트에 추가될 수 있 다. 전술한 바와 같이, 실시예로서, 상기 히스토리 기반 머지 후보 리스트는 상기 머지 후보 리스트의 최대 머지 후 보 개수에 기초하여 결정되는 크기를 갖도록 정의될 수 있다. 전술한 바와 같이, 실시예로서, 상기 히스토리 기반 머지 후보 리스트는 상기 머지 후보 리스트의 최대 머지 후 보 개수에서 1을 감산한 값의 크기를 갖도록 정의될 수 있다. 전술한 바와 같이, 실시예로서, 상기 히스토리 기반 머지 후보 리스트의 크기는 5로 정의될 수 있다. 전술한 바와 같이, 실시예로서, 상기 히스토리 기반 머지 후보는 상기 머지 후보 리스트에 포함된 머지 후보들 중에서 미리 정의된 특정 개수의 머지 후보들과 중복되지 않는 모션 정보를 갖는 경우, 상기 머지 후보 리스트 에 추가될 수 있다. 전술한 바와 같이, 실시예로서, 상기 히스토리 기반 머지 후보는 상기 머지 후보 리스트에 포함된 특정 공간 머 지 후보와 중복되지 않는 모션 정보를 갖는 경우, 상기 머지 후보 리스트에 추가될 수 있다. 전술한 바와 같이, 실시예로서, 상기 히스토리 기반 머지 후보는 상기 히스토리 기반 머지 후보 리스트 내에서 미리 정의된 특정 개수의 후보들로부터 유도될 수 있다. 전술한 바와 같이, 실시예로서, 디코더는 상기 머지 리스트가 상기 머지 리스트의 최대 개수를 만족하지 않는 경우, 제로 모션 벡터를 상기 머지 리스트에 추가할 수 있다. 본 발명에서 설명한 실시예들은 프로세서, 마이크로 프로세서, 컨트롤러 또는 칩 상에서 구현되어 수행될 수 있 다. 예를 들어, 각 도면에서 도시한 기능 유닛들은 컴퓨터, 프로세서, 마이크로 프로세서, 컨트롤러 또는 칩 상 에서 구현되어 수행될 수 있다. 또한, 본 발명이 적용되는 디코더 및 인코더는 멀티미디어 방송 송수신 장치, 모바일 통신 단말, 홈 시네마 비 디오 장치, 디지털 시네마 비디오 장치, 감시용 카메라, 비디오 대화 장치, 비디오 통신과 같은 실시간 통신 장 치, 모바일 스트리밍 장치, 저장 매체, 캠코더, 주문형 비디오(VoD) 서비스 제공 장치, OTT 비디오(Over the top video) 장치, 인터넷 스트리밍 서비스 제공 장치, 3차원(3D) 비디오 장치, 화상 전화 비디오 장치, 및 의료 용 비디오 장치 등에 포함될 수 있으며, 비디오 신호 또는 데이터 신호를 처리하기 위해 사용될 수 있다. 예를 들어, OTT 비디오(Over the top video) 장치로는 게임 콘솔, 블루레이 플레이어, 인터넷 접속 TV, 홈시어터 시 스템, 스마트폰, 태블릿 PC, DVR(Digital Video Recoder) 등을 포함할 수 있다. 또한, 본 발명이 적용되는 처리 방법은 컴퓨터로 실행되는 프로그램의 형태로 생산될 수 있으며, 컴퓨터가 판독 할 수 있는 기록 매체에 저장될 수 있다. 본 발명에 따른 데이터 구조를 가지는 멀티미디어 데이터도 또한 컴퓨 터가 판독할 수 있는 기록 매체에 저장될 수 있다. 상기 컴퓨터가 판독할 수 있는 기록 매체는 컴퓨터로 읽을 수 있는 데이터가 저장되는 모든 종류의 저장 장치 및 분산 저장 장치를 포함한다. 상기 컴퓨터가 판독할 수 있 는 기록 매체는, 예를 들어, 블루레이 디스크(BD), 범용 직렬 버스(USB), ROM, PROM, EPROM, EEPROM, RAM, CD- ROM, 자기 테이프, 플로피 디스크 및 광학적 데이터 저장 장치를 포함할 수 있다. 또한, 상기 컴퓨터가 판독할 수 있는 기록 매체는 반송파(예를 들어, 인터넷을 통한 전송)의 형태로 구현된 미디어를 포함한다. 또한, 인코 딩 방법으로 생성된 비트스트림이 컴퓨터가 판독할 수 있는 기록 매체에 저장되거나 유무선 통신 네트워크를 통 해 전송될 수 있다. 또한, 본 발명의 실시예는 프로그램 코드에 의한 컴퓨터 프로그램 제품으로 구현될 수 있고, 상기 프로그램 코 드는 본 발명의 실시예에 의해 컴퓨터에서 수행될 수 있다. 상기 프로그램 코드는 컴퓨터에 의해 판독가능한 캐 리어 상에 저장될 수 있다. 본 명세서가 적용되는 디코딩 장치 및 인코딩 장치는 디지털 기기(digital de-vice)에 포함될 수 있다. “디지 털 기기(digital device)”라 함은 예를 들어, 데이터, 컨텐트, 서비스 등을 송신, 수신, 처리 및 출력 중 적어 도 하나를 수행 가능한 모든 디지털 기기를 포함한다. 여기서, 디지털 기기가 데이터, 컨텐트, 서비스 등을 처 리하는 것은, 데이터, 컨텐트, 서비스 등을 인코딩 및/또는 디코딩하는 동작을 포함한다. 이러한 디지털 기기는, 유/무선 네트워크(wire/wireless network)를 통하여 다른 디지털 기기, 외부 서버(external server) 등과 페어링 또는 연결(pairing or connect-ing)(이하 '페어링')되어 데이터를 송수신하며, 필요에 따라 변환 (converting)한다. 디지털 기기는 예를 들어, 네트워크 TV(network TV), HBBTV(Hybrid Broadcast Broadband TV), 스마트 TV(Smart TV), IPTV(internet protocol television), PC(Personal Com-puter) 등과 같은 고정형 기기(standing devic e)와, PDA(Personal Digital Assistant), 스마트 폰(Smart Phone), 태블릿 PC(Tablet PC), 노트북 등과 같은 모바일 기기(mobile device or handheld device)를 모두 포함한다. 본 명세서에서는 편의상 후술하는 Figure 도 33에서는 디지털 TV를, 도 34에서는 모바일 기기를 디지털 기기의 실시예로 도시하고 설명한다. 한편, 본 명세서에서 기술되는 “유/무선 네트워크”라 함은, 디지털 기기들 또는 디지털 기기와 외부 서버 사 이에서 상호 연결 또는/및 데이터 송수신을 위해 다양한 통신 규격 내지 프로토콜을 지원하는 통신 네트워크를 통칭한다. 이러한 유/무선 네트워크는 규격에 의해 현재 또는 향후 지원될 통신 네트워크와 그를 위한 통신 프 로토콜을 모두 포함할 수 있는바 예컨대, USB(Universal Serial Bus), CVBS(Composite Video Banking Sync), 컴포넌트, S-비디오(아날로그), DVI(Digital Visual Interface), HDMI(High Definition Multimedia Interface), RGB, D-SUB와 같은 유선 연결을 위한 통신 규격 내지 프로토콜과, 블루투스(Bluetooth), RFID(Radio Frequency Identification), 적외선 통신(IrDA, infrared Data Association), UWB(Ultra Wideband), 지그비(ZigBee), DLNA(Digital Living Network Alliance), WLAN(Wireless LAN)(Wi-Fi), Wibro(Wireless broadband), Wimax(World Interoperability for Microwave Access), HSDPA(High Speed Down- link Packet Access), LTE(Long Term Evolution), Wi-Fi 다이렉트(Direct)와 같은 무선 연결을 위한 통신 규격 에 의하여 형성될 수 있다. 이하 본 명세서에서 단지 디지털 기기로 명명하는 경우에는 문맥에 따라 고정형 기기 또는 모바일 기기를 의미 하거나 양자를 모두 포함하는 의미일 수도 있다. 한편, 디지털 기기는 예컨대, 방송 수신 기능, 컴퓨터 기능 내지 지원, 적어도 하나의 외부 입력(external input)을 지원하는 지능형 기기로서, 상술한 유/무선 네트워크를 통해 이메일(e-mail), 웹 브라우징(web browsing), 뱅킹(banking), 게임(game), 애플리케이션(application) 등을 지원할 수 있다. 더불어, 상기 디지 털 기기는, 수기 방식의 입력 장치, 터치 스크린(touch screen), 공간 리모콘 등 적어도 하나의 입력 또는 제어 수단(이하 입력수단)을 지원하기 위한 인터페이스(interface)를 구비할 수 있다. 디지털 기기는, 표준화된 범용 OS(operating system)를 이용할 수 있다. 예를 들어, 디지털 기기는 범용의 OS 커널(kernel) 상에 다양한 애플 리케이션(application)을 추가(adding), 삭제(deleting), 수정(amending), 업데이트(updating) 등을 할 수 있 으며, 그를 통해 더욱 사용자 친화적인(user-friendly) 환경을 구성하여 제공할 수 있다. 한편, 본 명세서에서 기술되는 외부 입력은, 외부 입력 기기 즉, 상술한 디지털 기기와 유/무선으로 연결되어 그를 통해 관련 데이터를 송/수신하여 처리 가능한 모든 입력 수단 내지 디지털 기기를 포함한다. 여기서, 상기 외부 입력은 예를 들어, HDMI(High Definition Multimedia Interface), 플레이 스테이션(play station)이나 엑 스 박스(X-Box)와 같은 게임 기기, 스마트 폰, 태블릿 PC, 프린터기, 스마트 TV와 같은 디지털 기기들을 모두 포함한다. 또한, 본 명세서에서 기술되는 “서버(server)”라 함은, 클라이언트(client), 즉, 상술한 디지털 기기로 데이 터를 공급하는 모든 디지털 기기 내지 시스템을 포함하는 의미로, 프로세서(processor)로 불리기도 한다. 이러 한 서버로는 예컨대, 웹 페이지 내지 웹 컨텐트를 제공하는 포털 서버(portal server), 광고 데이터 (advertising data)를 제공하는 광고 서버(advertising server), 컨텐트를 제공하는 컨텐트 서버(content server), SNS(Social Network Service) 서비스를 제공하는 SNS 서버(SNS server), 제조업체에서 제공하는 서비 스 서버(service server or manufacturing server) 등이 포함될 수 있다. 그 밖에, 본 명세서 기술되는 “채널(channel)”이라 함은, 데이터를 송수신하기 위한 경로(path), 수단(means) 등을 의미하는 것으로, 방송 채널(broadcasting channel)을 예로 들 수 있다. 여기서, 방송 채널은 디지털 방송 의 활성화에 따라 피지컬 채널(physical channel), 가상 채널(virtual channel), 논리 채널(logical channel) 등의 용어로 표현된다. 방송 채널은 방송망이라 불릴 수 있다. 이와 같이, 방송 채널은 방송국에서 제공하는 방 송 컨텐트를 제공 또는 수신기에서 접근하기 위한 채널을 말하는 것으로, 상기 방송 컨텐트는 주로 실시간 방송 (real-time broadcasting)에 기초하는바 라이브 채널(live channel)이라고도 한다. 다만, 최근에는 방송을 위 한 매체(medium)가 더욱 다양화되어 실시간 방송 이외에 비실시간(non-real time) 방송도 활성화되고 있어 라이 브 채널은 단지 실시간 방송뿐만 아니라 경우에 따라서는 비실시간 방송을 포함한 방송 채널 전체를 의미하는 용어로 이해될 수도 있다. 본 명세에서는 상술한 방송 채널 이외에 채널과 관련하여 “임의 채널(arbitrary channel)”를 더 정의한다. 상 기 임의 채널은, 방송 채널과 함께 EPG(Electronic Program Guide)와 같은 서비스 가이드(service guide)와 함 께 제공될 수도 있고, 임의 채널만으로 서비스 가이드, GUI(Graphic User Interface) 또는 OSD 화면(On-Screen Dis-play screen)를 구성/제공될 수도 있다. 한편, 송수신기 사이에 미리 약속된 채널 넘버를 가지는 방송 채널과 달리, 임의 채널은 수신기에서 임의로 할 당하는 채널로서 상기 방송 채널을 표현하기 위한 채널 넘버와는 기본적으로 중복되지 않는 채널 넘버가 할당된 다. 예컨대, 수신기는 특정 방송 채널을 튜닝하면, 튜닝된 채널을 통하여 방송 컨텐트와 그를 위한 시그널링 정 보(signaling information)를 전송하는 방송 신호를 수신한다. 여기서, 수신기는 상기 시그널링 정보로부터 채 널 정보를 파싱(parsing)하고, 파싱된 채널 정보에 기초하여 채널 브라우저(channel browser), EPG 등을 구성하 여 사용자에게 제공한다. 사용자는 입력 수단을 통해 채널 전환 요청을 하면, 수신기는 그에 대응하는 방식이다. 이와 같이, 방송 채널은 송수신단 사이에 미리 약속된 내용이므로, 임의 채널을 방송 채널과 중복 할당하는 경 우에는 사용자의 혼동을 초래하거나 혼동 가능성이 존재하므로, 전술한 바와 같이 중복 할당하지 않는 것이 바 람직하다. 한편, 상기와 같이 임의 채널 넘버를 방송 채널 넘버와 중복 할당하지 않더라도 사용자의 채널 서핑 과정에서 여전히 혼동 우려가 있는바, 이를 고려하여 임의 채널 넘버를 할당하는 것이 요구된다. 왜냐하면, 본 명세서에 따른 임의 채널 역시, 종래 방송 채널과 동일하게 입력 수단을 통한 사용자의 채널 전환 요청에 따라 동일한 방식으로 대응하여 방송 채널처럼 접근되도록 구현할 수 있기 때문이다. 따라서, 임의 채널 넘버는, 사 용자의 임의 채널 접근 편의와 방송 채널 넘버와의 구분 내지 식별 편의를 위하여, 방송 채널과 같이 숫자 형태 가 아닌 임의 채널-1, 임의 채널-2 등과 같이 문자가 병기된 형태로 정의하고 표시할 수 있다. 한편, 이 경우, 비록 임의 채널 넘버의 표시는 임의 채널-1과 같이 문자가 병기된 형태이나 수신기 내부적으로는 상기 방송 채 널의 넘버와 같이 숫자 형태로 인식하고 구현될 수 있다. 그 밖에, 임의 채널 넘버는, 방송 채널과 같이 숫자형태로 제공될 수도 있으며, 동영상 채널-1, 타이틀-1, 비디오-1 등과 같이 방송 채널과 구분 가능한 다양한 방 식으로 채널 넘버를 정의하고 표시할 수도 있다. 디지털 기기는, 웹 서비스(web service)를 위해 웹 브라우저(web browser)를 실행하여 다양한 형태의 웹 페이지 (web page)를 사용자에게 제공한다. 여기서, 상기 웹 페이지에는 동영상(video content)이 포함된 웹 페이지도 포함되는데, 본 명세서에서는 동영상을 웹 페이지로부터 별도로 또는 독립적으로 분리하여 처리한다. 그리고 상 기 분리되는 동영상은, 전술한 임의 채널 넘버를 할당하고, 서비스 가이드 등을 통해 제공하고, 사용자가 서비 스 가이드나 방송 채널 시청 과정에서 채널 전환 요청에 따라 출력되도록 구현할 수 있다. 그 밖에, 웹 서비스 이외에도 방송 컨텐트, 게임, 애플리케이션 등의 서비스에 대해서도, 소정 컨텐트, 이미지, 오디오, 항목 등을 상기 방송 컨텐트, 게임, 애플리케이션 자체로부터 독립적으로 분리 처리하고, 그 재생, 처리 등을 위해 임의 채널 넘버를 할당하고 상술한 바와 같이, 구현할 수 있다. 도 38은 디지털 기기를 포함한 서비스 시스템(service system)의 일 예를 개략적으로 나타낸 도면이다. 디지털 기기를 포함한 서비스 시스템은, 컨텐트 제공자(Content Provider; CP), 서비스 제공자(Service Provider; SP), 네트워크 제공자(Network Provider; NP) 및 HNED(Home Network End User)(Customer)를 포함한다. 여기서, HNED는 예를 들어, 클라이언트 즉, 디지털 기기이다. 컨텐트 제공자는, 각종 컨텐트를 제작하여 제공한다. 이러한 컨텐트 제공자로 도 38에 도시된 바와 같이, 지상파 방송 송출자(terrestrial broadcaster), 케이블 방송 사업자(cable SO (System Operator)) 또는 MSO (Multiple SO), 위성 방송 송출자(satellite broadcaster), 다양한 인터넷 방송 송출자(Internet broadcaster), 개인 컨텐트 제공자들(Private CPs) 등을 예시할 수 있다. 한편, 컨텐트 제공자는, 방송 컨텐트 외에도 다양한 애플리케이션 등을 제공한다. 서비스 제공자는, 컨텐트 제공자가 제공하는 컨텐트를 서비스 패키지화하여 HNED로 제공한다. 예를 들어, 도 38의 서비스 제공자는, 제1 지상파 방송, 제2 지상파 방송, 케이블 MSO, 위성 방송, 다양한 인터넷 방송, 애플리케이션 등을 패키지화하여 HNED에게 제공한다. 서비스 제공자는, 유니-캐스트(uni-cast) 또는 멀티-캐스트(multi-cast) 방식으로 클라이언트에 서 비스를 제공한다. 한편, 서비스 제공자는 데이터를 미리 등록된 다수의 클라이언트로 한꺼번에 전 송할 수 있는데, 이를 위해 IGMP(Internet Group Management Protocol) 프로토콜 등을 이용할 수 있다. 상술한 컨텐트 제공자와 서비스 제공자는, 동일한 개체(same or single entity)일 수 있다. 예를 들어, 컨텐트 제공자가 제작한 컨텐트를 서비스 패키지화하여 HNED로 제공함으로써 서비스 제공자 의 기능도 함께 수행하거나 그 반대일 수도 있다. 네트워크 제공자는, 컨텐트 제공자 또는/및 서비스 제공자와 클라이언트 사이의 데이 터 교환을 위한 네트워크 망을 제공한다. 클라이언트는, 홈 네트워크를 구축하여 데이터를 송수신할 수 있다. 한편, 서비스 시스템 내 컨텐트 제공자 또는/및 서비스 제공자는 전송되는 컨텐트의 보호를 위해 제한 수신(conditional access) 또는 컨텐트 보호(content protection) 수단을 이용할 수 있다. 이 경우, 클라 이언트는 상기 제한 수신이나 컨텐트 보호에 대응하여 케이블카드(CableCARD)(POD: Point of De- ployment), DCAS(Downloadable CAS) 등과 같은 처리 수단을 이용할 수 있다. 그 밖에, 클라이언트도 네트워크 망(또는 통신 망)을 통해, 양방향 서비스를 이용할 수 있다. 이러한 경 우, 오히려 클라이언트가 컨텐트 제공자의 기능을 수행할 수도 있으며, 기존 서비스 제공자는 이를 수신하여 다시 다른 클라이언트로 전송할 수도 있다. 도 39은 디지털 기기의 일 실시예를 설명하기 위해 도시한 구성 블록도이다. 여기서, 도 39은, 예를 들어, 도 38의 클라이언트에 해당할 수 있으며, 전술한 디지털 기기를 의미한다. 디지털 기기는, 네트워크 인터페이스부(network interface), TCP/IP 매니저(TCP/IP manager), 서비스 전달 매니저(service delivery manager), SI 디코더, 역다중화부 (demux), 오디오 디코더(audio decoder), 비디오 디코더(video decoder), 디스플레이부 (display A/V and OSD module), 서비스 제어 매니저(service control manager), 서비스 디스커버 리 매니저(service discovery manager), SI & 메타데이터 데이터베이스(SI&Metadata DB), 메타데이터 매니저(metadata manager), 서비스 매니저, UI 매니저 등을 포함하여 구성된다. 네트워크 인터페이스부는, 네트워크 망을 통하여 IP 패킷들(internet proto-col (IP) packets)을 수신하 거나 전송한다. 즉, 네트워크 인터페이스부는 네트워크 망을 통해 서비스 제공자로부터 서비스, 컨 텐트 등을 수신한다. TCP/IP 매니저는, 디지털 기기로 수신되는 IP 패킷들과 디지털 기기가 전송하는 IP 패킷들에 대하여 즉, 소스(source)와 목적지(destination) 사이의 패킷 전달에 관여한다. 그리고 TCP/IP 매니저는 수신된 패킷(들)을 적절한 프로토콜에 대응되도록 분류하고, 서비스 전달 매니저, 서비스 디스커버리 매 니저, 서비스 제어 매니저, 메타데이터 매니저 등으로 분류된 패킷(들)을 출력한다. 서비스 전달 매니저는, 수신되는 서비스 데이터의 제어를 담당한다. 예를 들어, 서비스 전달 매니저는 실 시간 스트리밍(real-time streaming) 데이터를 제어하는 경우에는 RTP/RTCP를 사용할 수 있다. 상기 실시간 스 트리밍 데이터를 RTP를 사용하여 전송하는 경우, 서비스 전달 매니저는 상기 수신된 데이터 패킷을 RTP에 따라 파싱(parsing)하여 역다중화부에 전송하거나 서비스 매니저의 제어에 따라 SI & 메타데이터 데이터베이스에 저장한다. 그리고 서비스 전달 매니저는 RTCP를 이용하여 상기 네트워크 수신 정보 를 서비스를 제공하는 서버 측에 피드백(feedback) 한다. 역다중화부는, 수신된 패킷을 오디오, 비디오, SI(system information) 데이터 등으로 역다중화하여 각각 오디오/비디오 디코더(3906/3907), SI 디코더(390 4)에 전송한다. SI 디코더는 예를 들어, PSI(program specific information), PSIP(program and system information protocol), DVB-SI(digital video broadcasting-service information) 등의 서비스 정보를 디코딩한다. 또한, SI 디코더는, 디코딩된 서비스 정보들을 예를 들어, SI & 메타데이터 데이터베이스에 저장한 다. 이렇게 저장된 서비스 정보는 예를 들어, 사용자의 요청 등에 의해 해당 구성에 의해 독출되어 이용될 수 있다. 오디오/비디오 디코더(3906/3907)는, 역다중화부에서 역다중화된 각 오디오 데이터와 비디오 데이터를 디 코딩한다. 이렇게 디코딩된 오디오 데이터 및 비디오 데이터는 디스플레이부를 통하여 사용자에게 제공된 다. 애플리케이션 매니저는 예를 들어, UI 매니저와 서비스 매니저를 포함하여 구성될 수 있다. 애플리 케이션 매니저는, 디지털 기기의 전반적인 상태를 관리하고 사용자 인터페이스를 제공하며, 다른 매니저 를 관리할 수 있다. UI 매니저는, 사용자를 위한 GUI(graphic user interface)를 OSD(on screen display) 등을 이용하여 제 공하며, 사용자로부터 키 입력을 받아 상기 입력에 따른 기기 동작을 수행한다. 예를 들어, UI 매니저는 사용자로부터 채널 선택에 관한 키 입력을 받으면 상기 키 입력 신호를 서비스 매니저에 전송한다. 서비스 매니저는, 서비스 전달 매니저, 서비스 디스커버리 매니저, 서비스 제어 매니저 , 메타데이터 매니저 등 서비스와 연관된 매니저를 제어한다. 또한, 서비스 매니저는, 채널 맵(channel map)을 만들고 사용자 인터페이스 매니저로부터 수신한 키 입력에 따라 상기 채널 맵을 이용하여 채널을 선택하다. 그리고 서비스 매니저는 SI 디코더로부 터 채널의 서비스 정보를 전송받아 선택된 채널의 오디오/비디오 PID(packet identifier)를 역다중화부에 설정한다. 이렇게 설정되는 PID는 상술한 역다중화 과정에 이용된다. 따라서, 역다중화부는 상기 PID를 이용하여 오디오 데이터, 비디오 데이터 및 SI 데이터를 필터링(filtering) 한다. 서비스 디스커버리 매니저는, 서비스를 제공하는 서비스 제공자를 선택하는데 필요한 정보를 제공한다. 서비스 매니저로부터 채널 선택에 관한 신호를 수신하면, 서비스 디스커버리 매니저는 상기 정보를 이용하여 서비스를 찾는다. 서비스 제어 매니저는, 서비스의 선택과 제어를 담당한다. 예를 들어, 서비스 제어 매니저는 사용 자가 기존의 방송 방식과 같은 생방송(live broadcast-ing) 서비스를 선택하는 경우 IGMP 또는 RTSP 등을 사용 하고, VOD(video on demand)와 같은 서비스를 선택하는 경우에는 RTSP를 사용하여 서비스의 선택, 제어를 수행 한다. 상기 RTSP 프로토콜은 실시간 스트리밍에 대해 트릭 모드(trick mode)를 제공할 수 있다. 또한, 서비스 제어 매니저는 IMS(IP multimedia subsys-tem), SIP(session initiation protocol)를 이용하여 IMS 게이 트웨이를 통하는 세션을 초기화하고 관리할 수 있다. 프로토콜들은 일 실시 예이며, 구현 예에 따라 다른프로토콜을 사용할 수도 있다. 메타데이터 매니저는, 서비스와 연관된 메타데이터를 관리하고 상기 메타데이터를 SI & 메타데이터 데이 터 베이스에 저장한다. SI & 메타데이터 데이터베이스는, SI 디코더가 디코딩한 서비스 정보, 메타데이터 매니저가 관리하는 메타데이터 및 서비스 디스커버리 매니저가 제공하는 서비스 제공자를 선택하는데 필요한 정보 를 저장한다. 또한, SI & 메타데이터 데이터베이스는 시스템에 대한 세트-업 데이터 등을 저장할 수 있다. SI & 메타데이터 데이터베이스는, 비휘발성 메모리(non-volatile RAM, NVRAM) 또는 플래시 메모리(flash memory) 등을 사용하여 구현될 수도 있다. 한편, IMS 게이트웨이는, IMS 기반의 IPTV 서비스에 접근하기 위해 필요한 기능들을 모아 놓은 게이트웨 이이다. 도 40는 디지털 기기의 다른 실시예를 설명하기 위해 도시한 구성 블록도이다. 특히, 도 40는 디지털 기기의 다 른 실시예로서 모바일 기기의 구성 블록도를 예시한 것이다. *도 40를 참조하면, 모바일 기기는, 무선 통신부, A/V(audio/video) 입력부, 사용자 입력부 , 센싱부, 출력부, 메모리, 인터페이스부, 제어부 및 전원 공급부 등을 포함할 수 있다. 도 40에 도시된 구성요소들이 필수적인 것은 아니어서, 그보다 많은 구성요소들을 갖거나 그보다 적은 구성요소들을 갖는 모바일 기기가 구현될 수도 있다. 무선 통신부는, 모바일 기기와 무선 통신 시스템 사이 또는 모바일 기기와, 모바일 기기가 위치한 네트워크 사이의 무선 통신을 가능하게 하는 하나 또는 그 이상의 모듈을 포함할 수 있다. 예를 들어, 무선 통 신부는 방송 수신 모듈, 이동통신 모듈, 무선 인터넷 모듈, 근거리 통신 모듈 및 위치 정보 모듈 등을 포함할 수 있다. 방송 수신 모듈은, 방송 채널을 통하여 외부의 방송 관리 서버로부터 방송 신호 및/또는 방송 관련된 정 보를 수신한다. 여기서, 방송 채널은 위성 채널, 지상파 채널을 포함할 수 있다. 방송 관리 서버는, 방송 신호 및/또는 방송 관련 정보를 생성하여 송신하는 서버 또는 기 생성된 방송 신호 및/또는 방송 관련 정보를 제공받 아 단말기에 송신하는 서버를 의미할 수 있다. 방송 신호는, TV 방송 신호, 라디오 방송 신호, 데이터 방송 신 호를 포함할 뿐만 아니라, TV 방송 신호 또는 라디오 방송 신호에 데이터 방송 신호가 결합한 형태의 방송 신호 도 포함할 수 있다. 방송 관련 정보는, 방송 채널, 방송 프로그램 또는 방송 서비스 제공자에 관련한 정보를 의미할 수 있다. 방송 관련 정보는, 이동통신망을 통하여도 제공될 수 있다. 이러한 경우에는 이동통신 모듈에 의해 수신될 수 있다. 방송 관련 정보는 다양한 형태 예를 들어, EPG(electronic program guide) 또는 ESG(electronic service guide) 등의 형태로 존재할 수 있다. 방송 수신 모듈은 예를 들어, ATSC, DVB-T(digital video broadcasting-terrestrial), DVB- S(satellite), MediaFLO(media forward link only), DVB-H(handheld), ISDB-T(integrated services digital broadcast-terrestrial) 등 디지털 방송 시스템을 이용하여 디지털 방송 신호를 수신할 수 있다. 물론, 방송 수 신 모듈은, 상술한 디지털 방송 시스템뿐만 아니라 다른 방송 시스템에 적합하도록 구성될 수도 있다. 방송 수신 모듈을 통해 수신된 방송 신호 및/또는 방송 관련 정보는, 메모리에 저장될 수 있다. 이동통신 모듈은, 이동 통신망 상에서 기지국, 외부 단말, 서버 중 적어도 하나와 무선 신호를 송수신한 다. 무선 신호는, 음성 신호, 화상 통화 신호 또는 문자/멀티미디어 메시지 송수신에 따른 다양한 형태의 데이 터를 포함할 수 있다. 무선 인터넷 모듈은, 무선 인터넷 접속을 위한 모듈을 포함하여, 모바일 기기에 내장되거나 외장될 수 있다. 무선 인터넷 기술로는 WLAN(wireless LAN)(Wi-Fi), Wibro(wireless broadband), Wimax(world interoperability for microwave access), HSDPA(high speed downlink packet access) 등이 이용될 수 있다.근거리 통신 모듈은, 근거리 통신을 위한 모듈을 말한다. 근거리 통신(short range communication) 기술 로 블루투스(Bluetooth), RFID(radio frequency Identi-fication), 적외선 통신(IrDA, infrared data association), UWB(ultra wideband), ZigBee, RS-232, RS-485 등이 이용될 수 있다. 위치정보 모듈은, 모바일 기기의 위치정보 획득을 위한 모듈로서, GPS(global position system) 모듈을 예로 할 수 있다. A/V 입력부는, 오디오 또는/및 비디오 신호 입력을 위한 것으로, 이에는 카메라와 마이크 등 이 포함될 수 있다. 카메라는, 화상통화 모드 또는 촬영 모드에서 이미지 센서에 의해 얻어지는 정지영상 또는 동영상 등의 화상 프레임을 처리한다. 처리된 화상 프레임은 디스플레이부에 표시될 수 있다. 카메라에서 처리된 화상 프레임은, 메모리에 저장되거나 무선 통신부를 통하여 외부로 전송 될 수 있다. 카메라는, 사용 환경에 따라 2개 이상이 구비될 수도 있다. 마이크는, 통화 모드 또는 녹음 모드, 음성인식 모드 등에서 마이크로폰(microphone)에 의해 외부의 음향 신호를 입력받아 전기적인 음성 데이터로 처리한다. 처리된 음성 데이터는, 통화 모드인 경우 이동통신 모듈 을 통하여 이동통신 기지국으로 송신 가능한 형태로 변환되어 출력될 수 있다. 마이크에는 외부의 음향 신호를 입력받는 과정에서 발생하는 잡음(noise)을 제거하기 위한 다양한 잡음 제거 알고리즘이 구현될 수 있다. 사용자 입력부는, 사용자가 단말기의 동작 제어를 위한 입력 데이터를 발생시킨다. 사용자 입력부 는, 키 패드(key pad), 돔 스위치(dome switch), 터치 패드(정압/정전), 조그 휠(jog wheel), 조그 스위치(jog switch) 등으로 구성될 수 있다. 센싱부는, 모바일 기기의 개폐 상태, 모바일 기기의 위치, 사용자 접촉 유무, 모바일 기기의 방위, 모바일 기기의 가속/감속 등과 같이 모바일 기기의 현재 상태를 감지하여 모바일 기기의 동 작 제어를 위한 센싱 신호를 발생시킨다. 예를 들어, 모바일 기기가 이동되거나 기울어진 경우 모바일 기 기의 위치 내지 기울기 등을 센싱할 수 있다. 또한, 전원 공급부의 전원 공급 여부, 인터페이스부 의 외부 기기 결합 여부 등도 센싱할 수도 있다. 한편, 센싱부는, NFC(near field communication)를 포 함한 근접 센서를 포함할 수 있다. 출력부는, 시각, 청각 또는 촉각 등과 관련된 출력을 발생시키기 위한 것으로, 디스플레이부, 음향 출력 모듈, 알람부, 및 햅틱 모듈 등이 포함될 수 있다. 디스플레이부는, 모바일 기기에서 처리되는 정보를 표시(출력)한다. 예를 들어, 모바일 기기가 통 화 모드인 경우 통화와 관련된 UI(user interface) 또는 GUI(graphic user interface)를 표시한다. 모바일 기 기가 화상 통화 모드 또는 촬영 모드인 경우에는, 촬영 또는/및 수신된 영상 또는 UI, GUI를 표시한다. 디스플레이부는, 액정 디스플레이(liquid crystal display, LCD), 박막 트랜지스터 액정 디스플레이 (thin film transistor-liquid crystal display, TFT LCD), 유기 발광 다이오드(organic light-emitting diode, OLED), 플렉시블 디스플레이(flexible display), 3차원 디스플레이(3D display) 중에서 적어도 하나를 포함할 수 있다. 이들 중 일부 디스플레이는 그를 통해 외부를 볼 수 있도록 투명형 또는 광투과형으로 구성될 수 있다. 이는 투 명 디스플레이라 호칭될 수 있는데, 상기 투명 디스플레이의 대표적인 예로는 TOLED(transparent OLED) 등이 있 다. 디스플레이부의 후방 구조 또한 광 투과형 구조로 구성될 수 있다. 이러한 구조에 의하여, 사용자는 단말기 바디의 디스플레이부가 차지하는 영역을 통해 단말기 바디(body)의 후방에 위치한 사물을 볼 수 있다. 모바일 기기의 구현 형태에 따라 디스플레이부가 2개 이상 존재할 수 있다. 예를 들어, 모바일 기 기에는 복수의 디스플레이부들이 하나의 면에 이격되거나 일체로 배치될 수 있고, 또한 서로 다른 면에 각각 배치될 수도 있다. 디스플레이부와 터치 동작을 감지하는 센서(이하 '터치 센서'라 함)가 상호 레이어 구조를 이루는 경우 (이하, '터치 스크린'이라 함)에, 디스플레이부는 출력 장치 이외에 입력 장치로도 사용될 수 있다. 터치 센서는, 예를 들어, 터치 필름, 터치 시트, 터치 패드 등의 형태를 가질 수 있다. 터치 센서는 디스플레이부의 특정 부위에 가해진 압력 또는 디스플레이부의 특정 부위에 발생하는 정전 용량 등의 변화를 전기적인 입력신호로 변환하도록 구성될 수 있다. 터치 센서는 터치 되는 위치 및 면적 뿐만 아니라, 터치 시의 압력까지도 검출할 수 있도록 구성될 수 있다. 터치 센서에 대한 터치 입력이 있는 경우, 그에 대응하는 신호(들)는 터치 제어기로 보내진다. 터치 제어기는 그 신호(들)를 처리한 다음 대응하는 데이터를 제어부로 전송한다. 이로써, 제어부는 디스플레이부 의 어느 영역이 터치 되었는지 여부 등을 알 수 있게 된다. 터치스크린에 의해 감싸지는 모바일 기기의 내부 영역 또는 상기 터치 스크린의 근처에 근접 센서가 배치 될 수 있다. 상기 근접 센서는 소정의 검출면에 접근하는 물체, 혹은 근방에 존재하는 물체의 유무를 전자계의 힘 또는 적외선을 이용하여 기계적 접촉이 없이 검출하는 센서를 말한다. 근접 센서는 접촉식 센서보다는 그 수 명이 길며 그 활용도 또한 높다. 근접 센서의 예로는 투과형 광전 센서, 직접 반사형 광전 센서, 미러 반사형 광전 센서, 고주파 발진형 근접 센 서, 정전용량형 근접 센서, 자기형 근접 센서, 적외선 근접 센서 등이 있다. 상기 터치스크린이 정전식인 경우 에는 상기 포인터의 근접에 따른 전계의 변화로 포인터의 근접을 검출하도록 구성된다. 이 경우 터치 스크린(터 치 센서)은 근접 센서로 분류될 수도 있다. 이하에서는 설명의 편의를 위해, 터치스크린 상에 포인터가 접촉되지 않으면서 근접되어 포인터가 터치스크린 상에 위치함이 인식되도록 하는 행위를 \"근접 터치(proximity touch)\"라고 칭하고, 상기 터치스크린 상에 포인 터가 실제로 접촉되는 행위를 \"접촉 터치(contact touch)\"라고 칭한다. 터치스크린 상에서 포인터로 근접 터치 가 되는 위치라 함은, 포인터가 근접 터치될 때 포인터가 터치스크린에 대해 수직으로 대응되는 위치를 의미한 다. 근접 센서는, 근접 터치와, 근접 터치 패턴(예를 들어, 근접 터치 거리, 근접 터치 방향, 근접 터치 속도, 근접 터치 시간, 근접 터치 위치, 근접 터치 이동 상태 등)을 감지한다. 감지된 근접 터치 동작 및 근접 터치 패턴에 상응하는 정보는 터치 스크린상에 출력될 수 있다. 음향 출력 모듈은, 호 신호 수신, 통화 모드 또는 녹음 모드, 음성인식 모드, 방송수신 모드 등에서 무선 통신부로부터 수신되거나 메모리에 저장된 오디오 데이터를 출력할 수 있다. 음향 출력 모듈(405 2)은 모바일 기기에서 수행되는 기능(예를 들어, 호신호 수신음, 메시지 수신음 등)과 관련된 음향 신호 를 출력하기도 한다. 이러한 음향 출력 모듈에는 리시버(receiver), 스피커(speaker), 버저(buzzer) 등 이 포함될 수 있다. 알람부는, 모바일 기기의 이벤트 발생을 알리기 위한 신호를 출력한다. 모바일 기기에서 발생되는 이벤트의 예로는 호 신호 수신, 메시지 수신, 키 신호 입력, 터치 입력 등이 있다. 알람부는, 비디오 신 호나 오디오 신호 이외에 다른 형태, 예를 들어 진동으로 이벤트 발생을 알리기 위한 신호를 출력할 수도 있다. 비디오 신호나 오디오 신호는 디스플레이부나 음성 출력 모듈을 통해서도 출력될 수 있어서, 디스 플레이부 및 음성 출력 모듈(4051,4052)은 알람부의 일부로 분류될 수도 있다. 햅틱 모듈(haptic module)은, 사용자가 느낄 수 있는 다양한 촉각 효과를 발생시킨다. 햅틱 모듈이 발생시키는 촉각 효과의 대표적인 예로는 진동이 있다. 햅택 모듈이 발생하는 진동의 세기와 패턴 등은 제어 가능하다. 예를 들어, 서로 다른 진동을 합성하여 출력하거나 순차적으로 출력할 수도 있다. 햅틱 모듈은, 진동 외에도, 접촉 피부면에 대해 수직 운동하는 핀 배열, 분사구나 흡입구를 통한 공기의 분사력이나 흡입력, 피부 표면에 대한 스침, 전극(electrode)의 접촉, 정전기력 등의 자극에 의한 효과와, 흡열 이나 발열 가능한 소자를 이용한 냉온감 재현에 의한 효과 등 다양한 촉각 효과를 발생시킬 수 있다. 햅틱 모듈은, 직접적인 접촉을 통해 촉각 효과의 전달할 수 있을 뿐만 아니라, 사용자가 손가락이나 팔 등의 근 감각을 통해 촉각 효과를 느낄 수 있도록 구현할 수도 있다. 햅틱 모듈은, 모바일 기기의 구성 태양에 따라 2개 이상이 구비될 수 있다. 메모리는, 제어부의 동작을 위한 프로그램을 저장할 수 있고, 입/출력되는 데이터들(예를 들어, 폰 북, 메시지, 정지영상, 동영상 등)을 임시 저장할 수도 있다. 메모리는 상기 터치스크린 상의 터치 입력 시 출력되는 다양한 패턴의 진동 및 음향에 관한 데이터를 저장할 수 있다. 메모리는, 플래시 메모리 타입(flash memory type), 하드디스크 타입(hard disk type), 멀티미디어 카드 마이크로 타입(multimedia card micro type), 카드 타입의 메모리(예를 들어 SD 또는 XD 메모리 등), 램(random access memory, RAM), SRAM(static random access memory), 롬(read-only memory, ROM), EEPROM(electrically erasable programmable read-only memory), PROM(programmable read-only memory), 자기 메모리, 자기 디스크, 광디스크 중 적어도 하나의 타입의 저장매체를 포함할 수 있다. 모바일 기기는 인 터넷(internet)상에서 메모리의 저장 기능을 수행하는 웹 스토리지(web storage)와 관련되어 동작할 수도 있다. 인터페이스부는, 모바일 기기에 연결되는 모든 외부기기와의 통로 역할을 한다. 인터페이스부 는 외부 기기로부터 데이터를 전송받거나, 전원을 공급받아 모바일 기기 내부의 각 구성 요소에 전 달하거나, 모바일 기기 내부의 데이터가 외부 기기로 전송되도록 한다. 예를 들어, 유/무선 헤드셋 포트, 외부 충전기 포트, 유/무선 데이터 포트, 메모리 카드(memory card) 포트, 식별 모듈이 구비된 장치를 연결하는 포트, 오디오 I/O(input/output) 포트, 비디오 I/O 포트, 이어폰 포트 등이 인터페이스부에 포함될 수 있 다. 식별 모듈은 모바일 기기의 사용 권한을 인증하기 위한 각종 정보를 저장한 칩으로서, 사용자 인증 모듈 (user identify module, UIM), 가입자 인증 모듈(subscriber identify module, SIM), 범용 사용자 인증 모듈 (universal subscriber identity module, USIM) 등을 포함할 수 있다. 식별 모듈이 구비된 장치(이하 '식별 장 치')는, 스마트 카드(smart card) 형식으로 제작될 수 있다. 따라서 식별 장치는 포트를 통하여 단말기와 연결될 수 있다. 인터페이스부는, 이동단말기가 외부 크래들(cradle)과 연결될 때, 크래들로부터의 전원이 이동단말 기에 공급되는 통로가 되거나, 사용자에 의해 크래들에서 입력되는 각종 명령 신호가 이동단말기로 전달 되는 통로가 될 수 있다. 크래들로부터 입력되는 각종 명령 신호 또는 전원은, 이동단말기가 크래들에 정확히 장착되었음을 인지하기 위한 신호로 동작될 수도 있다. 제어부는, 통상적으로 모바일 기기의 전반적인 동작을 제어한다. 예를 들어, 음성 통화, 데이터 통신, 화 상 통화 등을 위한 관련된 제어 및 처리를 수행한다. 제어부는, 멀티 미디어 재생을 위한 멀티미디어 모 듈을 구비할 수도 있다. 멀티미디어 모듈은, 제어부 내에 구현될 수도 있고, 제어부와 별도로 구현될 수도 있다. 제어부, 특히 멀티미디어 모듈은 전술한 인코딩 장치 및/또는 디코 딩 장치를 포함할 수 있다. 제어부는, 터치스크린 상에서 행해지는 필기 입력 또는 그림 그리기 입력을 각각 문자 및 이미지로 인식 할 수 있는 패턴 인식 처리를 행할 수 있다. 전원 공급부는, 제어부의 제어에 의해 외부의 전원, 내부의 전원을 인가받아 각 구성요소들의 동작 에 필요한 전원을 공급한다. 여기에 설명되는 다양한 실시예는 예를 들어, 소프트웨어, 하드웨어 또는 이들의 조합된 것을 이용하여 컴퓨터 또는 이와 유사한 장치로 읽을 수 있는 기록매체 내에서 구현될 수 있다. 하드웨어적인 구현에 의하면, 여기에 설명되는 실시예는 ASICs(application spe-cific integrated circuits), DSPs(digital signal processors), DSPDs(digital signal processing devic-es), PLDs(programmable logic devices), FPGAs(field programmable gate arrays, 프로세서, 제어기, 마이크로 컨트롤러(micro-controllers), 마이크로 프로세서(microprocessors), 기타 기능 수행을 위한 전기적인 유닛 중 적어도 하나를 이용하여 구현될 수 있다. 일부의 경우에 본 명세서에서 설명되는 실시예들이 제어부 자체로 구현될 수 있다. 소프트웨어적인 구현에 의하면, 본 명세서에서 설명되는 절차 및 기능과 같은 실시예들은 별도의 소프트웨어 모 듈들로 구현될 수 있다. 소프트웨어 모듈들 각각은 본 명세서에서 설명되는 하나 이상의 기능 및 작동을 수행할 수 있다. 적절한 프로그램 언어로 쓰여진 소프트웨어 애플리케이션으로 소프트웨어 코드가 구현될 수 있다. 여 기서, 소프트웨어 코드는, 메모리에 저장되고, 제어부에 의해 실행될 수 있다. 도 41은 디지털 기기의 또 다른 실시 예를 설명하기 위해 도시한 구성 블록도이다. 디지털 기기의 다른 예는, 방송 수신부, 외부장치 인터페이스부, 저장부, 사용자 입력 인터페이스부, 제어부, 디스플레이부, 오디오 출력부, 전원공급부 및 촬영부(미 도시)를 포함할 수 있다. 여기서, 방송 수신부는, 적어도 하나의 튜너, 복조부 및 네트워크 인터페이스부를 포함할 수 있다. 다만, 경우에 따라, 방송 수신부는 튜너와 복조부는 구비하나 네트워크 인터페이스부는 포함하지 않을 수 있으며 그 반대의 경우일 수도 있다. 또한, 방송 수신부는 도시되진 않았으나, 다중화부(multiplexer)를 구비하여 튜너를 거쳐 복조부에서 복조 된 신호와 네트워크 인터페이스부를 거쳐 수신된 신호를 다중화할 수도 있다. 그 밖에 방송 수신부(402 5)는 역시 도시되진 않았으나, 역다중화부(demultiplexer)를 구비하여 상기 다중화된 신호를 역다중화 하거나 상기 복조된 신호 또는 상기 네트워크 인터페이스부를 거친 신호를 역다중화할 수 있다. 튜너는, 안테나를 통해 수신되는 RF(radio frequency) 방송 신호 중 사용자에 의해 선택된 채널 또는 기 저장된 모든 채널을 튜닝하여 RF 방송 신호를 수신한다. 또한, 튜너는, 수신된 RF 방송 신호를 중간 주파 수(intermediate fre-quency, IF) 신호 혹은 베이스밴드(baseband) 신호로 변환한다. 예를 들어, 수신된 RF 방송 신호가 디지털 방송 신호이면 디지털 IF 신호(DIF)로 변환하고, 아날로그 방송 신호 이면 아날로그 베이스밴드 영상 또는 음성 신호(CVBS/SIF)로 변환한다. 즉, 튜너는 디지털 방송 신호 또 는 아날로그 방송 신호를 모두 처리할 수 있다. 튜너에서 출력되는 아날로그 베이스 밴드 영상 또는 음성 신호(CVBS/SIF)는 제어부로 직접 입력될 수 있다. 또한, 튜너는, ATSC(advanced television system committee) 방식에 따른 단일 캐리어의 RF 방송 신호 또는 DVB(digital video broadcasting) 방식에 따른 복수 캐리어의 RF 방송 신호를 수신할 수 있다. 한편, 튜너는, 안테나를 통해 수신되는 RF 방송 신호 중 채널 기억 기능을 통하여 저장된 모든 방송 채널 의 RF 방송 신호를 순차로 튜닝 및 수신하여 이를 중간 주파수 신호 혹은 베이스 밴드 신호로 변환할 수 있다. 복조부는, 튜너에서 변환된 디지털 IF 신호(DIF)를 수신하여 복조한다. 예를 들어, 튜너에서 출력되는 디지털 IF 신호가 ATSC 방식인 경우, 복조부는 예컨대, 8-VSB(8-vestigal side band) 복조를 수행한다. 또한, 복조부는 채널 복호화를 수행할 수도 있다. 이를 위해 복조부는 트렐리스 디코더 (trellis decoder), 디인터리버(de-interleaver), 및 리드 솔로먼 디코더(Reed-Solomon decoder) 등을 구비하 여, 트렐리스 복호화, 디인터리빙, 및 리드 솔로먼 복호화를 수행할 수 있다. 예를 들어, 튜너에서 출력되는 디지털 IF 신호가 DVB 방식인 경우, 복조부는 예컨대, COFDMA(coded orthogonal frequency division modulation) 복조를 수행한다. 또한, 복조부는, 채널 복호화를 수행할 수도 있다. 이를 위해, 복조부는, 컨벌루션 디코더(convolution decoder), 디인터리버, 및 리드-솔로먼 디코더 등을 구비하여, 컨벌루션 복호화, 디인터리빙, 및 리드 솔로먼 복호화를 수행할 수 있다. 복조부는, 복조 및 채널 복호화를 수행한 후 스트림 신호(TS)를 출력할 수 있다. 이때, 스트림 신호는 영 상 신호, 음성 신호 또는 데이터 신호가 다중화된 신호일 수 있다. 일 예로, 스트림 신호는 MPEG-2 규격의 영상 신호, 돌비(Dolby) AC-3 규격의 음성 신호 등이 다중화된 MPEG-2 TS(transport stream)일 수 있다. 구체적으로 MPEG-2 TS는, 4 바이트(byte)의 헤더(header)와 184 바이트의 페이로드(payload)를 포함할 수 있다. 한편, 상술한 복조부는, ATSC 방식과, DVB 방식에 따라 각각 별개로 구비되는 것이 가능하다. 즉, 디지털 기기는 ATSC 복조부와 DVB 복조부를 각각 별개로 구비할 수 있다. 복조부에서 출력한 스트림 신호는 제어부로 입력될 수 있다. 제어부는 역다중화, 영상/음성 신호 처리 등을 제어하고, 디스플레이부를 통해 영상을, 오디오 출력부를 통해 음성의 출력을 제어 할 수 있다. 외부장치 인터페이스부는 디지털 기기에 다양한 외부장치가 인터페이싱 되도록 환경을 제공한다. 이를 위해, 외부장치 인터페이스부는, A/V 입출력부(미도시) 또는 무선 통신부(미도시)를 포함할 수 있다. 외부장치 인터페이스부는, DVD(digital versatile disk), 블루-레이(blu-ray), 게임기기, 카메라, 캠코 더, 컴퓨터(노트북, 태블릿), 스마트폰, 블루투스 기기(bluetooth device), 클라우드(cloud) 등과 같은 외부 장 치와 유/무선으로 접속될 수 있다. 외부장치 인터페이스부는 연결된 외부 장치를 통하여 외부에서 입력되 는 영상, 음성 또는 데이터(이미지 포함) 신호를 디지털 기기의 제어부로 전달한다. 제어부는 처리 된 영상, 음성 또는 데이터 신호를 연결된 외부 장치로 출력되도록 제어할 수 있다. 이를 위해, 외부장치 인터 페이스부는, A/V 입출력부(미도시) 또는 무선 통신부(미도시)를 더 포함할 수 있다. A/V 입출력부는, 외부 장치의 영상 및 음성 신호를 디지털 기기로 입력할 수 있도록, USB 단자, CVBS(composite video banking sync) 단자, 컴포넌트 단자, S-비디오 단자(아날로그), DVI(digital visual interface) 단자, HDMI(high definition multime-dia interface) 단자, RGB 단자, D-SUB 단자 등을 포함할 수있다. 무선 통신부는, 다른 전자기기와 근거리 무선 통신을 수행할 수 있다. 디지털 기기는 예를 들어, 블루투 스(bluetooth), RFID(radio frequency identification), 적외선 통신(IrDA, infrared data association), UWB(ultra wideband), 지그비(ZigBee), DLNA(digital living network alliance) 등의 통신 프로토콜에 따라 다 른 전자기기와 네트워크 연결될 수 있다. 또한, 외부장치 인터페이스부는, 다양한 셋톱-박스와 상술한 각종 단자 중 적어도 하나를 통해 접속되어, 셋톱-박스와 입력/출력 동작을 수행할 수도 있다. 한편, 외부장치 인터페이스부는, 인접하는 외부장치 내의 애플리케이션 또는 애플리케이션 목록을 수신하 여, 제어부 또는 저장부로 전달할 수 있다. 네트워크 인터페이스부는, 디지털 기기를 인터넷 망을 포함하는 유/무선 네트워크와 연결하기 위한 인터페이스를 제공한다. 네트워크 인터페이스부는, 유선 네트워크와의 접속을 위해 예를 들어, 이더넷 (ethernet) 단자 등을 구비할 수 있으며, 무선 네트워크와의 접속을 위해 예를 들어, WLAN(wireless LAN)(Wi- Fi), Wibro(wireless broadband), Wimax(world interoperability for microwave access), HSDPA(high speed downlink packet access) 통신 규격 등을 이용할 수 있다. 네트워크 인터페이스부는, 접속된 네트워크 또는 접속된 네트워크에 링크된 다른 네트워크를 통해, 다른 사용자 또는 다른 디지털 기기와 데이터를 송신 또는 수신할 수 있다. 특히, 디지털 기기에 미리 등록된 다른 사용자 또는 다른 디지털 기기 중 선택된 사용자 또는 선택된 디지털 기기에, 디지털 기기에 저장된 일부의 컨텐트 데이터를 송신할 수 있다. 한편, 네트워크 인터페이스부는, 접속된 네트워크 또는 접속된 네트워크에 링크된 다른 네트워크를 통해, 소정 웹 페이지에 접속할 수 있다. 즉, 네트워크를 통해 소정 웹 페이지에 접속하여, 해당 서버와 데이터를 송 신 또는 수신할 수 있다. 그 외, 컨텐트 제공자 또는 네트워크 운영자가 제공하는 컨텐트 또는 데이터들을 수신 할 수 있다. 즉, 네트워크를 통하여 컨텐트 제공자 또는 네트워크 제공자로부터 제공되는 영화, 광고, 게임, VOD, 방송 신호 등의 컨텐트 및 그와 관련된 정보를 수신할 수 있다. 또한, 네트워크 운영자가 제공하는 펌웨어 (firmware)의 업데이트 정보 및 업데이트 파일을 수신할 수 있다. 또한, 인터넷 또는 컨텐트 제공자 또는 네트 워크 운영자에게 데이터들을 송신할 수 있다. 또한, 네트워크 인터페이스부는, 네트워크를 통해, 공중에 공개(open)된 애플리케이션들 중 원하는 애플 리케이션을 선택하여 수신할 수 있다. 저장부는, 제어부 내의 각 신호 처리 및 제어를 위한 프로그램을 저장할 수도 있고, 신호 처리된 영상, 음성 또는 데이터 신호를 저장할 수도 있다. 또한, 저장부는 외부장치 인터페이스부 또는 네트워크 인터페이스부로부터 입력되는 영상, 음성, 또는 데이터 신호의 임시 저장을 위한 기능을 수행할 수도 있다. 저장부는, 채널 기억 기능을 통하 여 소정 방송 채널에 관한 정보를 저장할 수 있다. 저장부는, 외부장치 인터페이스부 또는 네트워크 인터페이스부로부터 입력되는 애플리케이션 또는 애플리케이션 목록을 저장할 수 있다. 또한, 저장부는, 후술하여 설명하는 다양한 플랫폼(platform)을 저장할 수도 있다. 저장부는, 예를 들어 플래시 메모리 타입(flash memory type), 하드디스크 타입(hard disk type), 멀티 미디어 카드 마이크로 타입(multimedia card micro type), 카드 타입의 메모리(예를 들어 SD 또는 XD 메모리 등), 램(RAM), 롬(EEPROM 등) 중 적어도 하나의 타입의 저장매체를 포함할 수 있다. 디지털 기기는, 저장 부 내에 저장되어 있는 컨텐트 파일(동영상 파일, 정지영상 파일, 음악 파일, 문서 파일, 애플리케이션 파일 등)을 재생하여 사용자에게 제공할 수 있다. 도 41는 저장부가 제어부와 별도로 구비된 실시 예를 도시하고 있으나, 본 명세서의 범위는 이에 한정되지 않는다. 즉, 저장부는 제어부 내에 포함될 수도 있다. 사용자 입력 인터페이스부는, 사용자가 입력한 신호를 제어부로 전달하거나, 제어부의 신호 를 사용자에게 전달한다.예를 들어, 사용자 입력 인터페이스부는, RF 통신 방식, 적외선(IR) 통신 방식 등 다양한 통신 방식에 따 라, 원격제어장치로부터 전원 온/오프, 채널 선택, 화면 설정 등의 제어 신호를 수신하여 처리하거나, 제 어부의 제어 신호를 원격제어장치로 송신하도록 처리할 수 있다. 또한, 사용자 입력 인터페이스부는, 전원 키, 채널 키, 볼륨 키, 설정치 등의 로컬 키(미도시)에서 입력 되는 제어 신호를 제어부에 전달할 수 있다. 사용자 입력 인터페이스부는, 사용자의 제스처(gesture)를 센싱(sensing)하는 센싱부(미도시)로부터 입력 되는 제어 신호를 제어부에 전달하거나, 제어부의 신호를 센싱부(미도시)로 송신할 수 있다. 여기 서, 센싱부(미도시)는, 터치 센서, 음성 센서, 위치 센서, 동작 센서 등을 포함할 수 있다. 제어부는, 튜너, 복조부 또는 외부장치 인터페이스부를 통하여 입력되는 스트림을 역 다중화하거나 역다중화된 신호들을 처리하여, 영상 또는 음성 출력을 위한 신호를 생성 및 출력할 수 있다. 제 어부는 전술한 인코딩 장치 및/또는 디코딩 장치를 포함할 수 있다. 제어부에서 처리된 영상 신호는, 디스플레이부로 입력되어 해당 영상 신호에 대응하는 영상으로 표 시될 수 있다. 또한, 제어부에서 영상 처리된 영상 신호는 외부장치 인터페이스부를 통하여 외부 출력 장치로 입력될 수 있다. 제어부에서 처리된 음성 신호는 오디오 출력부로 오디오 출력될 수 있다. 또한, 제어부에서 처리된 음성 신호는 외부장치 인터페이스부를 통하여 외부 출력장치로 입력될 수 있다. 도 41에서는 도시되어 있지 않으나, 제어부는 역다중화부, 영상처리부 등을 포함할 수 있다. 제어부는, 디지털 기기의 전반적인 동작을 제어할 수 있다. 예를 들어, 제어부는, 튜너 를 제어하여, 사용자가 선택한 채널 또는 기저장된 채널에 해당하는 RF 방송을 튜닝(tuning)하도록 제어 할 수 있다. 제어부는, 사용자 입력 인터페이스부를 통하여 입력된 사용자 명령 또는 내부 프로그램에 의하여 디지털 기기를 제어할 수 있다. 특히, 네트워크에 접속하여 사용자가 원하는 애플리케이션 또는 애플리케 이션 목록을 디지털 기기 내로 다운로드 받을 수 있도록 할 수 있다. 예를 들어, 제어부는, 사용자 입력 인터페이스부를 통하여 수신한 소정 채널 선택 명령에 따라 선 택한 채널의 신호가 입력되도록 튜너를 제어한다. 그리고 선택한 채널의 영상, 음성 또는 데이터 신호를 처리한다. 제어부는, 사용자가 선택한 채널 정보 등이 처리한 영상 또는 음성신호와 함께 디스플레이부 또는 오디오 출력부를 통하여 출력될 수 있도록 한다. 다른 예로, 제어부는, 사용자 입력 인터페이스부를 통하여 수신한 외부장치 영상 재생 명령에 따라, 외부장치 인터페이스부를 통하여 입력되는 외부 장치, 예를 들어, 카메라 또는 캠코더로부터의, 영 상 신호 또는 음성 신호가 디스플레이부 또는 오디오 출력부를 통해 출력될 수 있도록 한다. 한편, 제어부는, 영상을 표시하도록 디스플레이부를 제어할 수 있다. 예를 들어, 튜너를 통 해 입력되는 방송 영상, 또는 외부장치 인터페이스부를 통해 입력되는 외부 입력 영상, 또는 네트워크 인 터페이스부를 통해 입력되는 영상, 또는 저장부에 저장된 영상을, 디스플레이부에 표시하도록 제어 할 수 있다. 이때, 디스플레이부에 표시되는 영상은, 정지 영상 또는 동영상일 수 있으며, 2D 영상 또는 3D 영상일 수 있다. 또한, 제어부는, 컨텐트를 재생하도록 제어할 수 있다. 이때의 컨텐트는, 디지털 기기 내에 저장된 컨텐트, 또는 수신된 방송 컨텐트, 외부로부터 입력되는 외부 입력 컨텐트일 수 있다. 컨텐트는, 방송 영상, 외 부 입력 영상, 오디오 파일, 정지 영상, 접속된 웹 화면, 및 문서 파일 중 적어도 하나일 수 있다. 한편, 제어부는, 애플리케이션 보기 항목에 진입하는 경우, 디지털 기기 내 또는 외부 네트워크로 부터 다운로드 가능한 애플리케이션 또는 애플리케이션 목록을 표시하도록 제어할 수 있다. 제어부는, 다양한 사용자 인터페이스와 더불어, 외부 네트워크로부터 다운로드 되는 애플리케이션을 설치 및 구동하도록 제어할 수 있다. 또한, 사용자의 선택에 의해, 실행되는 애플리케이션에 관련된 영상이 디스플레 이부에 표시되도록 제어할 수 있다. 한편, 도면에 도시하지 않았지만, 채널 신호 또는 외부 입력 신호에 대응하는 썸네일 이미지를 생성하는 채널 브라우징 처리부가 더 구비되는 것도 가능하다. 채널 브라우징 처리부는, 복조부에서 출력한 스트림 신호(TS) 또는 외부장치 인터페이스부에서 출 력한 스트림 신호 등을 입력받아, 입력되는 스트림 신호로부터 영상을 추출하여 썸네일 영상을 생성할 수 있다. 생성된 썸네일 영상은 그대로 또는 부호화되어 제어부로 입력될 수 있다. 또한, 생성된 썸네일 영상은 스 트림 형태로 부호화되어 제어부로 입력되는 것도 가능하다. 제어부는 입력된 썸네일 영상을 이용하 여 복수의 썸네일 영상을 구비하는 썸네일 리스트를 디스플레이부에 표시할 수 있다. 한편, 이러한 썸네 일 리스트 내의 썸네일 영상들은 차례로 또는 동시에 업데이트 될 수 있다. 이에 따라 사용자는 복수의 방송 채 널의 내용을 간편하게 파악할 수 있게 된다. 디스플레이부는, 제어부에서 처리된 영상 신호, 데이터 신호, OSD 신호 또는 외부장치 인터페이스 부에서 수신되는 영상 신호, 데이터 신호 등을 각각 R, G, B 신호로 변환하여 구동 신호를 생성한다. 디스플레이부는 PDP, LCD, OLED, 플렉시블 디스플레이(flexible display), 3차원 디스플레이(3D display) 등이 가능할 수 있다. 한편, 디스플레이부는, 터치 스크린으로 구성되어 출력 장치 이외에 입력 장치로 사용되는 것도 가능하다. 오디오 출력부는, 제어부에서 음성 처리된 신호, 예를 들어, 스테레오 신호, 3.1 채널 신호 또는 5.1 채널 신호를 입력받아 음성으로 출력한다. 음성 출력부는 다양한 형태의 스피커로 구현될 수 있다. 한편, 사용자의 제스처를 감지하기 위해, 상술한 바와 같이, 터치 센서, 음성 센서, 위치 센서, 동작 센서 중 적어도 하나를 구비하는 센싱부(미도시)가 디지털 기기에 더 구비될 수 있다. 센싱부(미도시)에서 감지된 신호는 사용자입력 인터페이스부를 통해 제어부로 전달될 수 있다. 한편, 사용자를 촬영하는 촬영부(미도시)가 더 구비될 수 있다. 촬영부(미도시)에서 촬영된 영상 정보는 제어부 에 입력될 수 있다. 제어부는, 촬영부(미도시)로부터 촬영된 영상, 또는 센싱부(미도시)로부터의 감지된 신호를 각각 또는 조 합하여 사용자의 제스처를 감지할 수도 있다. 전원 공급부는, 디지털 기기 전반에 걸쳐 해당 전원을 공급한다. 특히, 시스템 온 칩(system on chip, SOC)의 형태로 구현될 수 있는 제어부와, 영상 표시를 위한 디스플 레이부, 및 오디오 출력을 위한 오디오 출력부에 전원을 공급할 수 있다. 이를 위해, 전원 공급부는, 교류 전원을 직류 전원으로 변환하는 컨버터(미도시)를 구비할 수 있다. 한편, 예를 들어, 디스플레이부가 다수의 백라이트 램프를 구비하는 액정패널로서 구현되는 경우, 휘도 가변 또는 디밍(dimming) 구동을 위해, PWM 동작 가능한 인버터(미도시)를 더 구비할 수도 있다. 원격제어장치는, 사용자 입력을 사용자입력 인터페이스부로 송신한다. 이를 위해, 원격제어장치 는, 블루투스(bluetooth), RF(radio frequency) 통신, 적외선(IR) 통신, UWB(Ultra Wideband), 지그비 (ZigBee) 방식 등을 사용할 수 있다. 또한, 원격제어장치는, 사용자입력 인터페이스부에서 출력한 영상, 음성 또는 데이터 신호 등을 수 신하여, 이를 원격제어장치에서 표시하거나 음성 또는 진동을 출력할 수 있다. 상술한 디지털 기기는, 고정형 또는 이동형의 ATSC 방식 또는 DVB 방식의 디지털 방송 신호의 처리가 가 능한 디지털 방송 수신기일 수 있다. 그 밖에 본 명세서에 따른 디지털 기기는 도시된 구성 중 필요에 따라 일부 구성을 생략하거나 반대로 도시되진 않은 구성을 더 포함할 수도 있다. 한편, 디지털 기기는 상술한 바와 달리, 튜너와 복조부를 구비하지 않고, 네 트워크 인터페이스부 또는 외부장치 인터페이스부를 통해서 컨텐트를 수신하여 재생할 수도 있다. 도 42은 도 54 내지 도 41의 제어부의 상세 구성의 일 실시예를 설명하기 위해 도시한 구성 블록도이다. 제어부의 일 예는, 역다중화부, 영상 처리부, OSD(on-screen display) 생성부, 믹서 (mixer), 프레임 레이트 변환부(frame rate converter, FRC), 및 포맷터(formatter)를 포함 할 수 있다. 그 외 상기 제어부는 도시되진 않았으나 음성 처리부와 데이터 처리부를 더 포함할 수 있다.역다중화부는, 입력되는 스트림을 역다중화한다. 예를 들어, 역다중화부는 입력되는 MPEG-2 TS 영 상, 음성 및 데이터 신호로 역다중화할 수 있다. 여기서, 역다중화부에 입력되는 스트림 신호는, 튜너 또 는 복조부 또는 외부장치 인터페이스부에서 출력되는 스트림 신호일 수 있다. 영상 처리부는, 역다중화된 영상 신호의 영상 처리를 수행한다. 이를 위해, 영상 처리부는, 영상 디코더 및 스케일러를 구비할 수 있다. 영상 디코더는 역다중화된 영상 신호를 복호하며, 스케일러는 복호된 영상 신호의 해상도를 디스플 레이부에서 출력 가능하도록 스케일링(scaling)한다. 영상 디코더는 다양한 규격을 지원할 수 있다. 예를 들어, 영상 디코더는 영상 신호가 MPEG-2 규격 으로 부호화된 경우에는 MPEG-2 디코더의 기능을 수행하고, 영상 신호가 DMB(digital multimedia broadcasting) 방식 또는 H.264 규격으로 부호화된 경우에는 H.264 디코더의 기능을 수행할 수 있다. 한편, 영상 처리부에서 복호된 영상 신호는, 믹서로 입력된다. OSD 생성부는, 사용자 입력에 따라 또는 자체적으로 OSD 데이터를 생성한다. 예를 들어, OSD 생성부 는 사용자입력 인터페이스부의 제어 신호에 기초하여 디스플레이부의 화면에 각종 데이터를 그래픽 (graphic)이나 텍스트(text) 형태로 표시하기 위한 데이터를 생성한다. 생성되는 OSD 데이터는, 디지털 기기의 사용자 인터페이스 화면, 다양한 메뉴 화면, 위젯(widget), 아이콘(icon), 시청률 정보(viewing rate information) 등의 다양한 데이터를 포함한다. OSD 생성부는, 방송 영상의 자막 또는 EPG에 기반한 방송 정보를 표시하기 위한 데이터를 생성할 수도 있 다. 믹서는, OSD 생성부에서 생성된 OSD 데이터와 영상 처리부에서 영상 처리된 영상 신호를 믹싱하여 포맷터로 제공한다. 복호된 영상 신호와 OSD 데이터가 믹싱됨으로 인하여, 방송 영상 또는 외부 입력 영 상 상에 OSD가 오버레이(overlay) 되어 표시된다. 프레임 레이트 변환부(FRC)는, 입력되는 영상의 프레임 레이트(frame rate)를 변환한다. 예를 들어, 프레 임 레이트 변환부는 입력되는 60Hz 영상의 프레임 레이트를 디스플레이부의 출력 주파수에 따라 예를 들 어, 120Hz 또는 240Hz의 프레임 레이트를 가지도록 변환할 수 있다. 상기와 같이, 프레임 레이트를 변환하는 방 법에는 다양한 방법이 존재할 수 있다. 일 예로, 프레임 레이트 변환부는 프레임 레이트를 60Hz에서 120Hz로 변환하는 경우, 제1 프레임과 제2 프레임 사이에 동일한 제1 프레임을 삽입하거나, 제1 프레임과 제2 프레임으로부터 예측된 제3 프레임을 삽입함으로써 변환할 수 있다. 다른 예로, 프레임 레이트 변환부는 프레임 레이트를 60Hz에서 240Hz로 변환하는 경우, 기존 프레임 사이에 동일한 프레임 또는 예측된 프레임을 3 개 더 삽입하여 변환할 수 있다. 한편, 별도의 프레임 변환을 수행하지 않는 경우에는 프레임 레이트 변환부 를 바이패스(bypass) 할 수도 있다. 포맷터는, 입력되는 프레임 레이트 변환부의 출력을 디스플레이부의 출력 포맷에 맞게 변경한다. 예를 들어, 포맷터는 R, G, B 데이터 신호를 출력할 수 있으며, 이러한 R, G, B 데이터 신호는, 낮은 전 압 차분 신호(low voltage differential signaling, LVDS) 또는 mini-LVDS로 출력될 수 있다. 또한, 포맷터 는 입력되는 프레임 레이트 변환부의 출력이 3D 영상 신호인 경우에는 디스플레이부의 출력 포맷에 맞게 3D 형태로 구성하여 출력함으로써, 디스플레이부를 통해 3D 서비스를 지원할 수도 있다. 한편, 제어부 내 음성 처리부(미도시)는, 역다중화된 음성 신호의 음성 처리를 수행할 수 있다. 이러한 음성 처 리부(미도시)는 다양한 오디오 포맷을 처리하도록 지원할 수 있다. 일 예로, 음성 신호가 MPEG-2, MPEG-4, AAC, HE-AAC, AC-3, BSAC 등의 포맷으로 부호화된 경우에도 이에 대응되는 디코더를 구비하여 처리할 수 있다. 또한, 제어부 내 음성 처리부(미도시)는, 베이스(base), 트레블(treble), 음량 조절 등을 처리할 수 있다. 제어부 내 데이터 처리부(미도시)는, 역다중화된 데이터 신호의 데이터 처리를 수행할 수 있다. 예를 들어, 데 이터 처리부는 역다중화된 데이터 신호가 부호화된 경우에도 이를 복호할 수 있다. 여기서, 부호화된 데이터 신 호로는, 각 채널에서 방영되는 방송 프로그램의 시작시각, 종료시각 등의 방송 정보가 포함된 EPG 정보일 수 있 다. 한편, 상술한 디지털 기기는 본 명세서에 따른 예시로서, 각 구성요소는 실제 구현되는 디지털 기기의 사양에 따라 통합, 추가, 또는 생략될 수 있다. 즉, 필요에 따라, 2 이상의 구성요소가 하나의 구성요소로 합쳐지거나하나의 구성요소가 2 이상의 구성요소로 세분화될 수 있다. 또한, 각 블록에서 수행하는 기능은 본 명세서의 실 시예를 설명하기 위한 것이며, 그 구체적인 동작이나 장치는 본 명세서의 권리범위를 제한하지 아니한다. 한편, 디지털 기기는, 장치 내에 저장된 영상 또는 입력되는 영상의 신호 처리를 수행하는 영상신호 처리장치일 수 있다. 영상신호 처리장치의 다른 예로는, 도 41에서 도시된 디스플레이부와 오디오 출력부가 제 외된 셋톱-박스(STB), 상술한 DVD 플레이어, 블루-레이 플레이어, 게임기기, 컴퓨터 등이 더 예시될 수 있다. 도 43은 일 실시예에 따른 디지털 기기의 스크린이 메인 영상(main image)과 보조 영상(sub image)을 동시에 디 스플레이 하는 일 예시를 도시하는 도면이다. 일 실시예에 따른 디지털 기기는 스크린에 메인 영상과 보조 영상을 동시에 디스플레이 할 수 있다. 메인 영상은 제1 영상이라 불릴 수 있고, 보조 영상은 제2 영상이라 불릴 수 있다. 메인 영상과 보조 영상은 동영상, 스틸 이미지, EPG(electronic program guide), GUI(graphical user in-terface), OSD(on-screen display) 등을 포함할 수 있고, 이에 한정되지 않는다. 메인 영상은 전자 장치의 스크린에 보조 영상과 동시에 디스플레이 되면서 전자 장치의 스크린 보다 크기가 상 대적으로 작은 영상을 의미할 수 있으며, PIP(picture in picture)로 지칭되기도 한다. 도 43에서는 메인 영상 이 디지털 기기의 스크린의 좌측 상단에 디스플레이 되는 것으로 도시되어 있으나, 메인 영상 이 디스플레이 되는 위치는 이에 한정되지 않고, 메인 영상은 디지털 기기의 스크린 내의 임 의의 위치에서 디스플레이 될 수 있다. 메인 영상과 보조 영상은 상호 직접 또는 간접적으로 관련될 수 있다. 일 예시로, 메인 영상(431 0)은 스트리밍(streaming) 동영상이고, 보조 영상은 스트리밍 동영상과 유사한 정보를 포함하는 동영상들 의 썸네일(thumbnail)들을 순차로 디스플레이 하는 GUI일 수 있다. 다른 예시로, 메인 영상은 방송 영상 (broadcasted image)이고, 보조 영상은 EPG일 수 있다. 또 다른 예시로, 메인 영상은 방송 영상이 고, 보조 영상은 GUI일 수 있다. 메인 영상과 보조 영상의 예시는 이에 한정되지 않는다. 일 실시예에서, 메인 영상은 방송 채널(broadcasting channel)을 통해 수신한 방송 영상(broadcasting image)이고, 보조 영상은 방송 채널을 통해 수신한 방송 영상과 관련된 정보일 수 있다. 방송 채널을 통 해 수신한 방송 영상과 관련된 정보는, 예를 들어 종합 채널 편성표, 방송 프로그램 상세 정보 등을 포함하는 EPG 정보, 방송 프로그램 다시 보기 정보 등을 포함할 수 있으며, 이에 한정되지 않는다. 다른 일 실시예에서, 메인 영상은 방송 채널을 통해 수신한 방송 영상이고, 보조 영상은 디지털 기 기에 기저장된 정보에 기초하여 생성된 영상일 수 있다. 디지털 기기에 기 저장된 정보에 기초하여 생성된 영상 은, 예를 들어 EPG의 기본 UI(User Interface), 기본 채널 정보, 영상 해상도(resolution) 조작 UI, 취침 예약 UI 등을 포함할 수 있으며, 이에 한정되지 않는다. 또 다른 일 실시예에서, 메인 영상은 방송 채널을 통해 수신한 방송 영상이고, 보조 영상은 네트워 크 망을 통해 수신한, 방송 영상과 관련된 정보일 수 있다. 네트워크망을 통해 수신한, 방송 영상과 관련된 정 보는, 예를 들어 네트워크에 기반한 검색 엔진을 통해 획득된 정보일 수 있다. 보다 구체적으로 예를 들면, 네 트워크에 기반한 검색 엔진을 통해 현재 메인 영상에 디스플레이 되고 있는 등장 인물과 관련된 정보가 획득될 수 있다. 그러나 예시는 이에 한정되지 않으며, 네트워크망을 통해 수신한, 방송 영상과 관련된 정보는 예를 들어 인공지 능(artificial intelligence, AI) 시스템을 사용함으로써 획득될 수 있다. 보다 구체적으로 예를 들면, 네트워 크에 기반한 딥러닝(deep-learning)을 이용하여 현재 메인 영상에 디스플레이 되고 있는 장소의 지도상 추정 위치(estimated-location in map)가 획득될 수 있고, 디지털 기기는 네트워크 망을 통하여, 현재 메인 영 상에 디스플레이 되고 있는 장소의 지도상 추정 위치에 관한 정보를 수신할 수 있다. 일 실시예에 따른 디지털 기기는 외부로부터 메인 영상의 영상 정보 및 보조 영상의 영상 정보 중 적어도 하나를 수신할 수 있다. 메인 영상의 영상 정보는 예를 들어 방송 채널(broadcasting channel)을 통해 수신한 방송 신호(broadcasting signal), 메인 영상의 소스 코드(source code) 정보, 네트워크 망 을 통해 수신한 메인 영상의 IP 패킷(internet protocol packet) 정보 등을 포함할 수 있으며, 이에 한 정되지 않는다. 마찬가지로, 보조 영상의 영상 정보는, 예를 들어 방송 채널을 통해 수신한 방송 신호, 보조 영상의 소스 코드 정보, 네트워크 망을 통해 수신한 보조 영상의 IP 패킷 정보 등을 포함할 수 있으며, 이에 한정되지 않는다. 디지털 기기는 외부로부터 수신된 메인 영상의 영상 정보 또는 보조 영상의 영상 정보를 디코딩하여 이용할 수 있다. 다만, 경우에 따라서 디지털 기기는 메인 영상의영상 정보 또는 보조 영상의 영상 정보를 내부에 자체적으로 저장하고 있을 수도 있다. 디지털 기기는 메인 영상의 영상 정보 및 보조 영상과 관련된 정보에 기초하여, 메인 영상과 보조 영상을 디지털 기기의 스크린에 디스플레이 할 수 있다. 일 예시에서, 디지털 기기의 디코딩 장치는 메인 영상 디코딩 장치와 보조 영상 디코딩 장치를 포함하고, 메인 영상 디코딩 장치와 보조 영상 디코딩 장치는 각각 메인 영상의 영상 정보와 보조 영상의 영 상 정보를 디코딩 할 수 있다. 렌더러는 메인 영상 렌더러(제1 렌더러)와 보조 영상 렌더러(제2 렌더러)를 포함 하고, 메인 영상 렌더러는 메인 영상 디코딩 장치에서 디코딩 된 정보에 기초하여 메인 영상을 디지털 기 기의 스크린의 제1 영역에 디스플레이되도록 할 수 있고, 보조 영상 렌더러는 보조 영상 디코딩 장치에서 디코딩 된 정보에 기초하여 보조 영상을 디지털 기기의 스크린의 제2 영역에 디스플레이되도록 할 수 있다. 또 다른 예시에서, 디지털 기기의 디코딩 장치는 메인 영상의 영상 정보와 보조 영상의 영상 정보를 디코딩 할 수 있다. 디코딩 장치에서 디코딩된 정보에 기초하여, 렌더러는 메인 영상 및 보 조 영상을 함께 처리하여 동시에 디지털 기기의 스크린에 디스플레이되도록 할 수 있다. 즉, 본 문서에 따르면, 디지털 기기에서 영상 서비스 처리 방법을 제공할 수 있다. 상기 영상 서비스 처리 방법 에 따르면, 영상 정보를 수신하는 단계, 상기 영상 정보를 기반으로 (메인) 영상을 디코딩하는 단계, 디코딩된 영상을 디스플레이 내 제1 영역에 렌더링 또는 디스플레이하는 단계, 디스플레이 내 제2 영역에 보조 영상을 렌 더링 또는 디스플레이하는 단계를 포함할 수 있다. 이 경우 제1 영상을 디코딩하는 단계는, 상술한 도 3에 따른 디코딩 장치에서의 디코딩 절차를 따를 수 있다. 예를 들어, 상술한 바와 같이, 제1 영상을 디코딩하는 단 계는 인터 또는 인트라 예측을 기반으로 현재 블록에 대한 예측 샘플들을 도출하는 단계, 수신된 레지듀얼 정보 를 기반으로 현재 블록에 대한 레지듀얼 샘플들을 도출하는 단계(생략 가능) 및 예측 샘플들 및/또는 레지듀얼 샘플들을 기반으로 복원 샘플들을 생성하는 단계를 포함할 수 있다. 추가적으로 제1 영상을 디코딩하는 단계는 복원 샘플들을 포함하는 복원 픽처에 인루프 필터링 절차를 수행하는 것을 포함할 수도 있다. 예를 들어, 상기 보조 영상은 EPG(electronic program guide), OSD(on screen display), 또는 GUI(graphic user interface)일 수 있다. 예를 들어, 상기 영상 정보는 방송망(broadcast network)를 통하여 수신되고, 상 기 보조 영상에 관한 정보는 상기 방송망을 통하여 수신될 수 있다. 예를 들어, 상기 영상 정보는 통신망 (communication network)를 통하여 수신되고, 상기 보조 영상에 관한 정보는 상기 통신망을 통하여 수신될 수 있다. 예를 들어, 상기 영상 정보는 방송망을 통하여 수신되고, 상기 보조 영상에 관한 정보는 통신망을 통하여 수신될 수 있다. 예를 들어, 상기 영상 정보는 방송망 또는 통신망을 통하여 수신되고, 상기 보조 영상에 관한 정보는 상기 디지털 기기 내의 저장매체에 저장되어 있을 수 있다. 이상에서 설명된 실시예들은 본 발명의 구성요소들과 특징들이 소정 형태로 결합된 것들이다. 각 구성요소 또는 특징은 별도의 명시적 언급이 없는 한 선택적인 것으로 고려되어야 한다. 각 구성요소 또는 특징은 다른 구성요 소나 특징과 결합되지 않은 형태로 실시될 수 있다. 또한, 일부 구성요소들 및/또는 특징들을 결합하여 본 발명 의 실시예를 구성하는 것도 가능하다. 본 발명의 실시예들에서 설명되는 동작들의 순서는 변경될 수 있다. 어느 실시예의 일부 구성이나 특징은 다른 실시예에 포함될 수 있고, 또는 다른 실시예의 대응하는 구성 또는 특징과 교체될 수 있다. 특허청구범위에서 명시적인 인용 관계가 있지 않은 청구항들을 결합하여 실시예를 구성하거나 출원 후의 보정에 의해 새로운 청구항으로 포함시킬 수 있음은 자명하다. 본 발명에 따른 실시예는 다양한 수단, 예를 들어, 하드웨어, 펌웨어(firmware), 소프트웨어 또는 그것들의 결 합 등에 의해 구현될 수 있다. 하드웨어에 의한 구현의 경우, 본 발명의 일 실시예는 하나 또는 그 이상의 ASICs(application specific integrated circuits), DSPs(digital signal processors), DSPDs(digital signal processing devices), PLDs(programmable logic devices), FPGAs(field programmable gate arrays), 프로세서, 콘트롤러, 마이크로 콘트롤러, 마이크로 프로세서 등에 의해 구현될 수 있다. 펌웨어나 소프트웨어에 의한 구현의 경우, 본 발명의 일 실시예는 이상에서 설명된 기능 또는 동작들을 수행하 는 모듈, 절차, 함수 등의 형태로 구현될 수 있다. 소프트웨어 코드는 메모리에 저장되어 프로세서에 의해 구동 될 수 있다. 상기 메모리는 상기 프로세서 내부 또는 외부에 위치하여, 이미 공지된 다양한 수단에 의해 상기 프로세서와 데이터를 주고 받을 수 있다. 본 발명은 본 발명의 필수적 특징을 벗어나지 않는 범위에서 다른 특정한 형태로 구체화될 수 있음은 당업자에 게 자명하다. 따라서, 상술한 상세한 설명은 모든 면에서 제한적으로 해석되어서는 아니 되고 예시적인 것으로고려되어야 한다. 본 발명의 범위는 첨부된 청구항의 합리적 해석에 의해 결정되어야 하고, 본 발명의 등가적 범위 내에서의 모든 변경은 본 발명의 범위에 포함된다. 산업상 이용가능성 이상, 전술한 본 발명의 바람직한 실시예는, 예시의 목적을 위해 개시된 것으로, 당업자라면 이하 첨부된 특허 청구범위에 개시된 본 발명의 기술적 사상과 그 기술적 범위 내에서, 다양한 다른 실시예들을 개량, 변경, 대체 또는 부가 등이 가능할 것이다."}
{"patent_id": "10-2023-7043224", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 발명에 관한 이해를 돕기 위해 상세한 설명의 일부로 포함되는, 첨부 도면은 본 발명에 대한 실시예를 제공 하고, 상세한 설명과 함께 본 발명의 기술적 특징을 설명한다. 도 1은 본 명세서의 실시예에 따른 비디오 코딩 시스템의 예를 도시한다. 도 2는 본 명세서의 실시예에 따른 비디오/이미지 신호의 인코딩을 위한 인코딩 장치의 개략적인 블록도를 나타 낸다. 도 3은 본 명세서의 실시예로서, 영상 신호의 디코딩을 위한 디코딩 장치의 개략적인 블록도를 나타낸다. 도 4는 본 명세서의 실시예에 따른 컨텐츠 스트리밍 시스템의 구조도의 예를 도시한다. 도 5는 본 명세서의 실시예에 따른 비디오 신호를 처리하기 위한 장치의 블록도의 예를 도시한다.도 6은 본 명세서의 실시예에 따른 블록 분할 구조의 예로서, 도 6a는 QT(quad tree, 이하 'QT'로 지칭됨), 도 3b는 BT(binary tree, 이하 'BT'로 지칭됨), 도 3c는 TT(ternary tree, 이하 'TT'로 지칭됨) 도 3d는 AT(asymmetric tree, 이하 'TT'로 지칭됨)에 의한 블록 분할 구조들의 예를 도시한다. 도 7 및 도 8은 인터 예측에 기반한 비디오/영상 인코딩 절차 및 인코딩 장치 내 인터 예측부를 도시한다. 도 9 및 도 10은 인터 예측에 기반한 비디오/영상 디코딩 절차 및 디코딩 장치 내 인터 예측부를 도시한다. 도 11은 현재 블록에 대한 공간적 머지 후보 구성의 예를 도시한다. 도 12는 본 명세서의 실시예에 따른 머지 후보 리스트 구성을 위한 흐름도의 예를 도시한다. 도 13은 예측 후보 리스트(MVP 후보 리스트)를 구성하기 위한 흐름도의 예를 도시한다. 도 14는 본 발명의 실시예에 따른 모션 모델들(motion models)의 예를 도시한다. 도 15는 본 발명의 실시예에 따른 어파인 모션 예측을 위한 제어점 모션 벡터의 예를 도시한다. 도 16은 본 발명의 실시예에 따른 어파인 모션 예측이 적용된 블록의 각 서브 블록 별 모션 벡터의 예를 도시한 다. 도 17은 본 발명의 실시예에 따른 어파인 머지 모드(affine merge mode)에서 어파인 모션 예측에 사용되는 주변 블록의 예를 도시한다. 도 18은 본 발명의 실시예에 따른 어파인 모션 예측이 적용된 주변 블록을 사용하여 어파인 모션 예측이 수행되 는 블록의 예를 도시한다. 도 19는 본 발명의 실시예에 따른 주변 어파인 부호화 블록을 이용하여 머지 후보 리스트를 생성하는 방법을 설 명하기 위한 도면이다. 도 20 및 도 21은 본 발명의 실시예에 따른 어파인 예측으로 부호화된 주변 블록을 사용하여 어파인 머지 후보 리스트를 구성하는 방법을 설명하기 위한 도면이다. 도 22는 본 발명이 실시예에 따른 어파인 인터 모드(affine inter mode)에서 어파인 모션 예측에 사용되는 주변 블록의 예를 도시한다. 도 23은 본 발명이 실시예에 따른 어파인 인터 모드(affine inter mode)에서 어파인 모션 예측에 사용되는 주변 블록의 예를 도시한다. 도 24 및 도 25는 본 발명이 실시예에 따른 어파인 인터 모드(affine inter mode)에서 주변 블록의 모션 정보를 이용하여 모션 벡터 후보를 유도하는 방법을 예시하는 도면이다. 도 26은 본 발명의 실시예에 따른 서브 블록 단위의 어파인 모션 벡터 필드를 유도하는 방법의 일 예를 도시한 다. 도 27은 본 명세서의 실시예에 따른 HMVP를 저장하는 방법을 설명하기 위한 흐름도이다. 도 28은 본 명세서의 실시예에 따른 비제한적 FIFO 방식으로 동작하는 HMVP 테이블을 설명하기 위한 도면이다. 도 29는 본 명세서의 실시예에 따른 제한적 FIFO 방식으로 동작하는 HMVP 테이블을 설명하기 위한 도면이다. 도 30은 본 명세서의 실시예에 따른 HMVP LUT 및 롱 텀 HMVP LUT를 예시하는 도면이다. 도 31은 본 명세서의 실시예에 따른 HMVP LUT를 업데이트하는 방법의 일 예를 나타내는 도면이다. 도 32는 본 명세서의 실시예에 따른 프루닝 체크의 대상이 되는 HMVP 후보의 수를 제한하는 방법을 예시하는 도 면이다. 도 33은 본 명세서의 실시예에 따른 프루닝 체크 수행 방법의 일 예를 나타내는 흐름도이다. 도 34는 본 명세서의 일 실시예에 따른 서로 다른 참조 픽쳐를 참조하는 모션 벡터들을 이용하여 H-STMVP 후보 를 유도하는 방법을 설명하기 위한 도면이다. 도 35는 본 명세서의 실시예에 따른 상속된 어파인 HMVP 후보를 유도하기 위한 블록의 위치를 예시하는 도면이 다.도 36은 본 명세서의 실시예에 따른 어파인 머지 리스트 또는 어파인 AMVP 리스트를 예시하는 도면이다. 도 37은 본 발명이 적용되는 실시예에 따른 히스토리 기반 모션 벡터 예측을 기반으로 비디오 신호를 처리하는 방법을 예시하는 흐름도이다. 도 38은 디지털 기기를 포함한 서비스 시스템(service system)의 일 예를 개략적으로 나타낸 도면이다. 도 39는 디지털 기기의 일 실시예를 설명하기 위해 도시한 구성 블록도이다. 도 40은 디지털 기기의 다른 실시예를 설명하기 위해 도시한 구성 블록도이다. 도 41은 디지털 기기의 또 다른 실시 예를 설명하기 위해 도시한 구성 블록도이다. 도 42는 도 39 내지 도 41의 제어부의 상세 구성의 일 실시예를 설명하기 위해 도시한 구성 블록도이다. 도 43은 일 실시예에 따른 디지털 기기의 스크린이 메인 영상(main image)과 보조 영상(sub image)을 동시에 디 스플레이 하는 일 예시를 도시하는 도면이다."}
