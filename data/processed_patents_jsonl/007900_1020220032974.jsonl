{"patent_id": "10-2022-0032974", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0038643", "출원번호": "10-2022-0032974", "발명의 명칭": "악성코드 진화관계를 분석하는 장치 및 방법", "출원인": "국방과학연구소", "발명자": "임정호"}}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "악성코드 진화관계 분석을 위한 장치의 프로세서를 통해, 악성코드 진화관계를 분석하는 방법에 있어서,상기 프로세서를 통해 복수의 악성코드 바이너리들 각각의 제 1복잡도를 계산하는 단계;상기 프로세서를 통해 상기 계산된 제 1복잡도를 이용하여 최초로 생성된 근원 바이너리를 선별하는 단계; 및상기 프로세서를 통해 상기 계산된 제 1복잡도 및 상기 복수의 악성코드 바이너리들 간의 거리도를 기초로 하여상기 근원 바이너리 외 상기 복수의 악성코드 바이너리들의 진화 순서를 추론하는 단계;를 포함하고,상기 제 1복잡도는, 다음 수학식 1에 따라 계산하며,[수학식 1] (여기서, 상기 임의의 값으로 가중치에 해당하고, 상기 s는 제 2복잡도, 상기 d는 API 시퀀스개수임)상기 복수의 악성코드 바이너리들 중 임의의 악성코드 바이너리가 패킹되어 있을 경우, 상기 보다 작고, 상기 임의의 악성코드 바이너리가 안티디버깅 되어 있을 경우, 상기 보다 작고,상기 임의의 악성코드 바이너리가 패킹 및 안티디버깅 되어 있지 않을 경우, 상기 가 동일한 것을 포함하는, 악성코드 진화관계 분석 방법."}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1항에 있어서,상기 근원 바이너리를 선별하는 단계는,상기 복수의 악성코드 바이너리들 중 같은 패밀리로 분류된 악성코드 바이너리들로부터 상기 제 1복잡도가 가장낮은 악성코드 바이너리를 상기 근원 바이너리로 선별하는 단계;를 포함하는 악성코드 진화관계 분석 방법."}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1항에 있어서, 상기 제 1복잡도를 계산하는 단계는,동적 분석과 정적 분석을 이용하여 상기 제 1복잡도를 계산하는 단계;를 포함하고, 상기 동적 분석은, 상기 복수의 악성코드 바이너리들 각각이 호출하는 상기 API 시퀀스 개수를 추출하고, 상기 정적 분석은, 상기 복수의 악성코드 바이너리들 각각의 상기 제 2복잡도를 추출하되, 상기 추출된 제 2복잡도는 노드(Node)의 개수와 엣지(Edge)의 개수의 합으로 결정되는, 악성코드 진화관계 분석 방법."}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1항에 있어서,상기 거리도는,공개특허 10-2022-0038643-3-다음 수학식 2에 따라 계산되는 악성코드 진화관계 분석 방법. [수학식 2] (여기서, 는 임의의 악성코드 바이너리 각각을 의미하며, 상기 는 상기간의 거리도를 의미하며, 상기 는 상기 의 유사도임)"}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4항에 있어서,상기 유사도는 상기 API 시퀀스의 개수를 이용하여 계산하는, 악성코드 진화관계 분석 방법."}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 5항에 있어서,상기 유사도는 니들만-브니쉬 알고리즘(Needleman-Wunsch Algorithm), 스미스-워터맨 알고리즘(Smith-WatermanAlgorithm) 및 히르쉬베르크 알고리즘(Hirschberg's Algorithm)중 적어도 어느 하나를 이용하는, 악성코드 진화관계 분석 방법."}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1항에 있어서,상기 진화 순서를 추론하는 단계는,상기 근원 바이너리를 으로 식별하는 단계;상기 복수의 악성코드 바이너리들 중 진화 순서가 식별된 악성코드 바이너리들의 집합은 이며, 상기 복수의 악성코드 바이너리들 중 진화 순서가 식별되지 않은 악성코드 바이너리들의 집합은 라 할 때, 상기 상기 제 1복잡도에 따라 오름차순으로 정렬하는 단계;상기 에서 상기 제 1복잡도가 가장 낮은 악성코드 바이너리를 로 선택하는 단계;다음 수학식 3을 만족하는 상기 의 악성코드 바이너리를 로 선택하는 단계;[수학식 3] (여기서, 상기 는 임의의 악성코드 바이너리 각각을 의미하며, 상기 는 상기 간의 거리도임)상기 선택된 식별하는 단계;상기 에서 자식이 없는 악성코드 바이너리들인 와 상기 식별된에 대해 를 계산하는 단계; 상기 에 대해 를 계산하는 단계;공개특허 10-2022-0038643-4-상기 가 상기 보다 적다면, 상기를 상기의 부모로 식별하는 단계; 및 상기 에 상기 복수의 악성코드 바이너리들이 전부 포함될 때까지 반복하여 진화 순서를 식별하는 단계;를 포함하는 악성코드 진화관계 분석 방법."}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 7항에 있어서,상기 진화 순서를 추론하는 단계는,상기 식별된 진화 순서에 따라 그래프를 도출하는 단계;를 더 포함하는 악성코드 진화관계 분석 방법."}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1 항 내지 제 8 항 중 어느 한 항에 따른 방법을 컴퓨터에서 실행시키기 위한 프로그램을 기록한 기록매체."}
{"patent_id": "10-2022-0032974", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "악성코드 진화관계를 분석하는 장치에 있어서,메모리: 및프로세서를 포함하고,상기 프로세서는,복수의 악성코드 바이너리들 각각의 제 1복잡도를 계산하고;상기 계산된 제 1복잡도를 이용하여 최초로 생성된 근원 바이너리를 선별하고;상기 계산된 제 1복잡도 및 상기 복수의 악성코드 바이너리들 간의 거리도를 기초로 하여 상기 근원 바이너리외 상기 복수의 악성코드 바이너리들의 진화 순서를 추론하고,상기 제 1복잡도는, 다음 수학식 1에 따라 계산하며,[수학식 1] (여기서, 상기 임의의 값으로 가중치에 해당하고, 상기 s는 제 2복잡도, 상기 d는 API 시퀀스개수임)상기 복수의 악성코드 바이너리들 중 임의의 악성코드 바이너리가 패킹되어 있을 경우, 상기 보다 작고, 상기 임의의 악성코드 바이너리가 안티디버깅 되어 있을 경우, 상기 보다 작고,상기 임의의 악성코드 바이너리가 패킹 및 안티디버깅 되어 있지 않을 경우, 상기 가 동일한 것을 포함하는 악성코드 진화관계 분석 장치."}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 개시는 악성코드 진화관계를 분석하는 장치 및 방법에 관한 것으로, 일 실시예에 따른 악성코드 진화관계를 분석하는 방법은 복수의 악성코드 바이너리들 각각의 제 1복잡도를 계산하는 단계, 계산된 제 1복잡도를 이용하 여 최초로 생성된 근원 바이너리를 선별하는 단계 및 계산된 제 1복잡도 및 복수의 악성코드 바이너리들 간의 거 리도를 기초로 하여 근원 바이너리 외 복수의 악성코드 바이너리들의 진화 순서를 추론하는 단계를 포함함으로써 악성 코드의 진화 관계를 파악하여 악성코드의 분석을 정확하고 빠르게 수행할 수 있다."}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 악성코드의 진화관계를 분석하는 장치 및 방법을 제공한다."}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "악의적인 목적으로 제작되는 악성코드는 시스템과 시스템 사용자에게 심각한 피해를 가져온다. 악성코드를 탐지 하기 위하여 다양한 방법이 연구되고 있지만 악성코드 작성자 또한 악성코드 탐지 알고리즘을 우회하기 위하여 지속적으로 기능을 보강하여 새로운 악성 코드를 제작한다. 새로 출현하는 악성코드의 수는 점차 기하급수적으 로 증가하고 있으며 그에 따라 분석가들을 점점 힘들게 하고 있다. 그러나 이렇게 새로 출현하는 악성코드는 기존 악성코드와 완전히 다른 새로운 악성코드는 아니며, 기존 악성코 드를 기반으로 필요한 기능을 수정하거나, 추가 한 버전인 경우가 대부분이다. 비록, 기존 악성코드와 새로운 악성코드가 동일하거나 매우 유사하다고 할 수는 없지만, 악성코드의 버전이 올라가는 것을 생명체 진화의 관점 으로 보고 악성코드 진화 관계도를 구축해 놓으면 새로운 악성코드를 기 분석된 악성코드와 비교하여 분석을 정 확하고 빠르게 수행할 수 있다. 종래에는, Software Evolution 법칙에 의거하여 프로그램의 크기와 복잡도를 통해 악성코드의 진화관계를 자동 으로 추론하는 알고리즘을 개발하였다. 하지만 “Released”로 빌드된 바이너리에서의 추론과 Root를 추론하는 과정에서 정확하지 않은 결과가 나타날 수 있다. “Released”로 빌드 되었을 경우 실제 코드의 사이즈가 크다 고 해서 바이너리의 용량이 크게 나타나지 않기 때문이다. 또한, Creation Time 정보를 활용하여 인공지능 모델 을 설계한 뒤 진화관계를 추론하는 시스템을 제시하였다. Creation Time 정보가 제대로 제공되지 않는 악성코드 에 대해서는 정확한 진화관계 추론 과정이 어렵다는 한계점이 있다. 기존의 연구에서는, 기존의 툴을 이용하여 악성코드의 패밀리를 분류하고 동적으로 실행하여 Execution log를 얻고, 그 이후 Unpacking 과정을 통해 Packing된 악성코드에 대하여도 진화관계 분석이 가능한 방법을 제시하였 다. 또한, 바이너리 그 자체를 input으로 하지 않고 각 프로그램의 함수를 단위로 하여 동일하게 호출하는 함수 가 많을수록 유사도가 높다고 판단하였고, 함수의 유사도를 바탕으로 진화관계를 추론하고 그래프를 생성하였다. Unpacker를 사용할 시 기존 바이너리의 코드가 변경될 수 있다는 점과 함수의 식별이 제대로 이루 어지지 않으면 진화관계를 정상적으로 추론할 수 없다는 한계점이 있다. 소프트웨어의 진화관계 추론은 버전 정보를 알 수 없는 여러 프로그램의 집합에서 어떤 순서로 프로그램들이 개 발되어 왔는지 파악하기 위해 연구되고 있다. 소프트웨어의 진화관계는 악성코드의 분류 또는 소프트웨어 취약 점 추적 등을 수행할 때 매우 유용한 정보를 제공해 줄 수 있다. 특히 하루가 다르게 실시간으로 새롭게 생성되 고 있는 변종 악성코드를 분석하기 위해서는 기존의 악성코드들이 어떻게 변형되어 가는지 연구하는 것이 매우 중요하다. 또한 실제 사이버 환경에서 새롭게 발견되는 수많은 악성코드들을 분석가가 일일이 수동으로 분석하 는 데에는 한계가 존재한다. 이에 따라, 악성코드의 진화관계 분석을 자동화하여 새로운 악성코드에 대해 즉각적인 대응을 수행할 필요성이 대두되고 있는 실정이다. 선행기술문헌 특허문헌 (특허문헌 0001) KR 10-1880796 (특허문헌 0002) KR 10-1512462"}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "악성코드 진화관계를 분석하는 장치 및 방법을 제공하는 데 있다. 또한, 상기 방법을 컴퓨터에서 실행시키기 위 한 프로그램을 기록한 기록매체를 제공하는 데 있다. 본 실시예가 이루고자 하는 기술적 과제는 상기된 바와 같 은 기술적 과제들로 한정되지 않으며, 이하의 실시예들로부터 또 다른 기술적 과제들이 유추될 수 있다."}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "상술한 기술적 과제를 달성하기 위한 기술적 수단으로서, 본 개시의 제 1측면은, 악성코드 진화관계를 분석하는 방법에 있어서, 복수의 악성코드 바이너리들 각각의 제 1복잡도를 계산하는 단계, 상기 계산된 제 1복잡도를 이 용하여 최초로 생성된 근원 바이너리를 선별하는 단계, 및 상기 계산된 제 1복잡도 및 상기 복수의 악성코드 바 이너리들 간의 거리도를 기초로 하여 상기 근원 바이너리 외 상기 복수의 악성코드 바이너리들의 진화 순서를 추론하는 단계를 포함하는 악성코드 진화관계 분석 방법을 제공할 수 있다. 또한, 상기 근원 바이너리를 선별하는 단계는, 상기 복수의 악성코드 바이너리들 중 같은 패밀리로 분류된 악성 코드 바이너리들로부터 상기 제 1복잡도가 가장 낮은 악성코드 바이너리를 상기 근원 바이너리로 선별하는 단계 를 포함하는 악성코드 진화관계 분석 방법을 제공할 수 있다. 또한, 상기 제 1복잡도를 계산하는 단계는, 동적 분석과 정적 분석을 이용하여 상기 복잡도를 계산하는 단계를 포함하고, 상기 동적 분석은, 상기 복수의 악성코드 바이너리들 각각이 호출하는 API 시퀀스 개수를 추출하고, 상기 정적 분석은, 상기 복수의 악성코드 바이너리들 각각의 제 2복잡도를 추출하되, 상기 추출된 제 2복잡도는 노드(Node)의 개수와 엣지(Edge)의 개수의 합으로 결정되는 악성코드 진화관계 분석 방법을 제공할 수 있다. 또한, 상기 제 1복잡도는, 다음 수학식 1에 따라 계산하는 악성코드 진화관계 분석 방법을 제공할 수 있다. [수학식 1]"}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 2, "content": "(여기서, 상기 임의의 값으로 가중치에 해당하고, 상기 s는 상기 제 2복잡도, 상기 d는 상기 API 시 퀀스 개수임) 또한, 상기 복수의 악성코드 바이너리들 중 임의의 악성코드 바이너리가 패킹되어 있을 경우, 상기 보다 작고, 상기 임의의 악성코드 바이너리가 안티디버깅 되어 있을 경우, 상기 보다 작고, 상기 임의의 악성코드 바이너리가 패킹 및 안티디버깅 되어 있지 않을 경우, 상기 가 동일한 것을 포함하는 악성코드 진화관계 분석 방법을 제공할 수 있다. 또한, 상기 거리도는, 다음 수학식 2에 따라 계산되는 악성코드 진화관계 분석 방법을 제공할 수 있다. [수학식 2]"}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 3, "content": "(여기서,상기 는 임의의 악성코드 바이너리 각각을 의미하며, 상기 는 상기 간의 거리도를 의미하며, 상기 는 상기 의 유사도임) 또한, 상기 유사도는 API 시퀀스의 개수를 이용하여 계산하는, 악성코드 진화관계 분석 방법을 제공할 수 있다. 또한, 상기 유사도는 니들만-브니쉬 알고리즘(Needleman-Wunsch Algorithm), 스미스-워터맨 알고리즘(Smith- Waterman Algorithm) 및 히르쉬베르크 알고리즘(Hirschberg's Algorithm)중 적어도 어느 하나를 이용하는, 악 성코드 진화관계 분석 방법을 제공할 수 있다. 또한, 상기 진화 순서를 추론하는 단계는, 상기 근원 바이너리를 으로 식별하는 단계; 상기 복수의 악성코드 바이너리들 중 진화 순서가 식별된 악성코드 바이너리들의 집합은 이며, 상기 복수의 악성코드 바이너리들 중 진화 순서가 식별되지 않은 악성코드 바이너리들의 집합은 라 할 때, 상기 상기 제 1복잡도에 따라 오름차순으로 정렬하는 단계, 상기 에서 상기 제 1복잡도가 가장 낮은 바이너리를 로 선택하는 단계, 다음 수학식 3을 만족하는 상기 의 악성코드 바이너리를 로 선택하는 단계, [수학식 3] (여기서, 상기 는 임의의 악성코드 바이너리 각각을 의미하며, 상기 는 상기 간 의 거리도임) 상기 선택된 식별하는 단계, 상기 에서 자식이 없는 악성코드 바이너리 들인 와 상기 식별된 에 대해 를 계산하는 단계, 상기 에 대해 를 계산하는 단계, 상기 가 상기 보다 적다면, 상기 를 상기 의 부모로 식별하는 단계 및 상기 에 상기 복수의 악성코드 바이너리들이 전부 포함될 때까지 반복하여 진화순서 를 식별하는 단계를 포함하는 악성코드 진화관계 분석 방법을 제공할 수 있다. 또한, 상기 진화 순서를 추론하는 단계는, 상기 식별된 진화 순서에 따라 그래프를 도출하는 단계를 더 포함하 는 악성코드 진화관계 분석 방법을 제공할 수 있다. 본 개시의 제 2측면은, 제 1측면에 따른 방법을 컴퓨터에서 실행시키기 위한 프로그램을 기록한 기록매체를 제 공할 수 있다. 본 개시의 제 3측면은, 악성코드 진화관계를 분석하는 장치에 있어서, 메모리: 및 프로세서를 포함하고, 상기 프로세서는, 복수의 악성코드 바이너리들 각각의 제 1복잡도를 계산하고, 상기 계산된 제 1복잡도를 이용하여 최초로 생성된 근원 바이너리를 선별하고, 상기 계산된 제 1복잡도 및 상기 복수의 악성코드 바이너리들 간의 거리도를 기초로 하여 상기 근원 바이너리 외 상기 복수의 악성코드 바이너리들의 진화 순서를 추론하는 악성코 드 진화관계 분석 장치를 제공할 수 있다."}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시는, 다량의 악성코드가 주어진 경우, 악성코드 바이너리들의 제 1복잡도를 계산하고, 악성코드 바이너리 들의 제 1복잡도에 기초하여 근원 바이너리를 선별할 수 있으며, 악성코드 바이너리들 간의 거리도 및 제 1복잡 도에 기초하여 악성코드 바이너리들의 진화 순서를 추론할 수 있다. 또한, 악성코드 바이너리들의 진화 순서를 추론하여 그래프로 도출할 수 있다. 이에 따라, 악성코드 바이너리들의 진화 순서를 효과적으로 식별할 수 있고, 악성코드 바이너리들의 진화 순서를 추론하여 사용자에게 효과적으로 제공할 수 있으며, 새로운 악성코드 에 대한 분석을 정확하고 빠르게 수행할 수 있다."}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 실시예들에서 사용되는 용어는 본 실시예들에서의 기능을 고려하면서 가능한 현재 널리 사용되는 일반적인 용어들을 선택하였으나, 이는 당 분야에 종사하는 기술자의 의도 또는 판례, 새로운 기술의 출현 등에 따라 달 라질 수 있다. 또한, 특정한 경우는 출원인이 임의로 선정한 용어도 있으며, 이 경우 해당되는 부분에서 상세히 그 의미를 기재할 것이다. 따라서, 본 실시예들에서 사용되는 용어는 단순한 용어의 명칭이 아닌, 그 용어가 가 지는 의미와 본 실시예들 전반에 걸친 내용을 토대로 정의되어야 한다. 본 실시예들은 다양한 변경을 가할 수 있고 여러 가지 형태를 가질 수 있는바, 일부 실시예들을 도면에 예시하 고 상세하게 설명하고자 한다. 그러나, 이는 본 실시예들을 특정한 개시형태에 대해 한정하려는 것이 아니며, 본 실시예들의 사상 및 기술범위에 포함되는 모든 변경, 균등물 내지 대체물을 포함하는 것으로 이해되어야 한 다. 본 명세서에서 사용한 용어들은 단지 실시예들의 설명을 위해 사용된 것으로, 본 실시예들을 한정하려는 의도가 아니다."}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "본 실시예들에 사용되는 용어들은 다르게 정의되지 않는 한, 본 실시예들이 속하는 기술분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미가 있다. 일반적으로 사용되는 사전에 정의되어 있는 것 과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의미를 가지는 것으로 해석되어야 하며, 본 실시 예들에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적인 의미로 해석되지 않아야 한다. 본 개시의 일부 실시예는 기능적인 블록 구성들 및 다양한 처리 단계들로 나타내어질 수 있다. 이러한 기능 블 록들의 일부 또는 전부는, 특정 기능들을 실행하는 다양한 개수의 하드웨어 및/또는 소프트웨어 구성들로 구현 될 수 있다. 예를 들어, 본 개시의 기능 블록들은 하나 이상의 마이크로프로세서들에 의해 구현되거나, 소정의 기능을 위한 회로 구성들에 의해 구현될 수 있다. 또한, 예를 들어, 본 개시의 기능 블록들은 다양한 프로그래 밍 또는 스크립팅 언어로 구현될 수 있다. 기능 블록들은 하나 이상의 프로세서들에서 실행되는 알고리즘으로 구현될 수 있다. 또한, 본 개시는 전자적인 환경 설정, 신호 처리, 및/또는 데이터 처리 등을 위하여 종래 기 술을 채용할 수 있다. “매커니즘”, “요소”, “수단” 및 “구성”등과 같은 용어는 넓게 사용될 수 있으며, 기계적이고 물리적인 구성들로서 한정되는 것은 아니다. 또한, 명세서에 기재된 \"쪋부\", \"쪋모듈\" 등의 용어는 적어도 하나의 기능이나 동작을 처리하는 단위를 의미하며, 이는 하드웨어 또는 소프트웨어로 구현되거나 하드 웨어와 소프트웨어의 결합으로 구현될 수 있다. 또한, 도면에 도시된 구성 요소들 간의 연결 선 또는 연결 부재들은 기능적인 연결 및/또는 물리적 또는 회로적 연결들을 예시적으로 나타낸 것일 뿐이다. 실제 장치에서는 대체 가능하거나 추가된 다양한 기능적인 연결, 물 리적인 연결, 또는 회로 연결들에 의해 구성 요소들 간의 연결이 나타내어질 수 있다. 이하 첨부된 도면을 참고하여 본 개시를 상세히 설명하기로 한다. 도1은 일 실시예에 따른 악성코드 진화관계를 분석하는 방법의 흐름도이다. 도 1을 참조하면, 단계 110에서 악 성코드 진화관계를 분석하는 장치는 복수의 악성코드 바이너리들 각각의 제 1복잡도를 계산 할 수 있다. 악성코드는 기존의 악성코드 외에도 변종 악성코드가 포함 될 수 있다. 변종 악성코드는 아래의 다양한 기법이 적용되어 생성될 수 있다. 변종 악성코드는 난독화(Obfuscation) 기법에 의해 생성될 수 있으며, 난독화 기법은 쓰레기코드 삽입(dead code insertion), 레지스터 재할당(register reassignment), 서브루틴 재배치(subroutine reordering), 인스트 럭션 치환(instruction substitution), 코드 전위(code transportation), 코드 통합(code integration) 등을 포함할 수 있다. 악성코드 바이너리는, 악의적인 목적을 위해 작성된 악성코드를 컴퓨터 내부적으로 이용 할 수 있도록 하기 위"}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "해 0 또는 1로 이루어진 기계어일 수 있으며, 본 개시가 속하는 기술분야에서 통상의 지식을 가진 자에 의해 일 반적으로 이해 될 수 있다. 제 1복잡도는 악성코드 바이너리의 복잡도를 의미하고, 악성코드의 성능 또는 복잡한 정도를 의미할 수 있다. 복수의 악성코드 바이너리들은 시스템에서 입력 값으로 주어 질 수 있으며, 같은 패밀리로 분류된 악성코드 바 이너리들을 포함 할 수 있으나 이에 제한되지 않는다. 같은 패밀리로 분류된 악성코드 바이너리들은 백신 회사, 컴퓨터 프로그램 회사 등에서 제작한 프로그램에 악성 코드 바이너리들을 입력 하였을 때, 같은 제작자로부터 제작되거나, 유사하거나 같은 기능을 가진 악성코드 바 이너리들을 같은 군으로 분류하는데, 같은 군으로 분류된 악성코드 바이너리들을 의미할 수 있다. 악성코드 바이너리의 제 1복잡도는 동적 분석 및 정적 분석을 이용하여 계산 할 수 있고, 동적 분석은 분석 대 상 악성코드 파일을 실행하고 분석하는 방법을 의미하고, 정적 분석은 악성코드 파일을 실행하지 않고 분석하는 방법을 의미할 수 있다. 악성코드 진화관계 분석 장치는 동적 분석 및 정적 분석을 수행하여 추출된 정보를 기초로 하여 다음 수학식1에 따라 제 1복잡도를 계산 할 수 있다. [수학식 1] 제 1 앞의 수학식 1에서 임의의 값으로 가중치에 해당하고 휴리스틱(huristic)하게 정할 수 있다. s는 정적 분석을 수행하여 추출된 정보에 해당하는 것으로, 제 2복잡도를 의미 할 수 있고, d는 동적 분석을 수행하 여 추출된 정보에 해당하는 것으로, API 시퀀스 개수를 의미 할 수 있다. 제 2복잡도는 정적 분석기에 의해서 생성되는 하나의 프로그램을 구성하고 있는 단위 프로그램들 사이의 호출 관계를 나타내는 그래프인 호출 그래프의 복잡도를 의미하고, 제 2복잡도는 호출 그래프에서 나타나는 노드의 개수와 엣지의 개수의 합을 나타낼 수 있다. Windows내 프로그램이 실행되면서 함수를 호출하는데, 호출하는 시스템 함수들의 순서를 API 시퀀스라고 하며, API 시퀀스 개수는 시퀀스를 구성하는 API 개수를 의미할 수 있다. 단계 120에서, 악성코드 진화관계 분석 장치는 단계110에서 계산한 제 1복잡도를 이용하여 근원 바이너리(ROO T)를 선별 할 수 있다. 근원 바이너리는 프로그램들의 진화관계 내에서 가장 먼저 생성된 최초의 악성코드 바이너리이며, 제 1복잡도가 가장 낮은 악성코드 바이너리를 근원 바이너리로 선별 할 수 있다. 예를 들어, 악성코드 진화관계 분석 장치는 같은 패밀리로 분류된 악성코드 바이너리들 각각의 제 1복잡도를 계산하고, 계산된 제 1복잡도가 가장 낮은 악 성코드 바이너리를 근원 바이너리로 선별 할 수 있다. 단계 110 및 단계 120은 도2에서 상세히 후술하기로 한다. 단계 130에서, 악성코드 진화관계 분석 장치는 계산된 제 1복잡도 및 악성코드 바이너리들 간의 거리도를 기초 로 하여 근원 바이너리 외 악성코드 바이너리들의 진화 순서를 추론 할 수 있다. 악성코드 진화관계 분석 장치 는 악성코드 바이너리들의 진화 순서를 추론 하기 위해 거리도를 이용할 수 있으며, 거리도는 다음 수학식 2에 따라 계산할 수 있다. [수학식 2]"}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "는 임의의 악성코드 바이너리 각각을 의미하며, 는 간의 거리도를 의 미하며, 는 의 유사도를 나타낸다. 유사도는 자카드(Jaccard) 유사도를 의미 할 수 있으며, 거리도는 1에서 자카드 유사도를 뺀 값을 사용 할 수 있다. 악성코드 진화관계 분석 장치는 API 시퀀스 개수를 이용하여 유사도를 계산할 수 있다. 예를 들어, 제 1 악성코 드 바이너리 및 제 2 악성코드 바이너리의 API 시퀀스 개수가 각각 100개이고, 공통적으로 호출하는 API 시퀀스 개수가 50개 일 때, 는 50, 는 150이므로 유사도는 으로 계산될 수 있다. 또한, 악성코드 진화관계 분석 장치는 니들만-브니쉬 알고리즘(Needleman-Wunsch Algorithm), 스미스-워터맨 알 고리즘(Smith-Waterman Algorithm) 및 히르쉬베르크 알고리즘(Hirschberg's Algorithm)중 적어도 어느 하나를 이용함으로써 유사도를 계산할 수 있다. 니들만-브니쉬 알고리즘은 비교할 서열들의 전체의 길이에 대한 포괄적인 유사성 점수를 계산하는 것으로, 비교 할 두 서열의 길이가 비슷하고 서열의 모든 문자가 중요할 때 적절한 알고리즘이다. 스미스-워터맨 알고리즘은 비교할 서열들의 부분의 유사한 영역을 결정하기 위한 것으로 전체 시퀀스를 보는 대신 가능한 모든 길이의 부 분을 비교하고 유사성을 측정할 수 있다. 히르쉬베르크 알고리즘은 두 서열 사이에서 최적의 서열 정렬을 찾는 알고리즘이다. 일 실시예에서, 악성코드 바이너리들이 각각 동적으로 실행되며 호출하는 API 시퀀스를 비교하여 공통적으로 호 출되는 API 시퀀스 개수 계산시, 시퀀스 전체를 비교하는 Global Alignment에는 니들만-브니쉬 알고리즘 (Needleman-Wunsch Algorithm), 시퀀스 부분을 비교하는 Local Alignment에는 스미스-워터맨 알고리즘(Smith- Waterman Algorithm), 공간복잡도 최적화에는 히르쉬베르크 알고리즘(Hirschberg's Algorithm)중 적어도 어느 하나를 이용할 수 있다. 다만, 이에 반드시 제한되는 것은 아니다.악성코드 진화관계 분석 장치는 제 1복잡도 및 거리도를 기초로 하여 근원 바이너리 외 악성코드 바이너리들의 진화순서를 추론 할 수 있으며, 단계 130은 도 3에서 상세히 후술하기로 한다. 도2는 도 1에 도시된 단계 110 및 단계 120의 구체적인 흐름도이다. 도 2는 도 1의 단계 110 및 단계 120에 대 응되므로 중복되는 설명은 생략한다. 도2를 참조하면, 단계 210에서, 악성코드 진화관계 분석 장치는 악성코드 바이너리들 각각에 대해 동적 분석 및 정적 분석을 수행한다. 악성코드 바이너리들은 같은 패밀리로 분류된 악성코드 바이너리들을 의미할 수 있으나, 이에 제한되지는 않는다. 일 실시예에서, 악성코드 바이너리의 동적 분석을 수행시 쿠쿠 샌드박스(Cuckoo Sandbox)를 이용할 수 있다. 악 성코드 바이너리를 샌드박스 환경에서 실행시키고, 나타나는 결과 값을 제공받아 정보로 활용할 수 있다. 쿠쿠 샌드박스(Cuckoo Sandbox)에서 제공하는 정보는 JSON(JavaScript Object Notation) 파일 형태로 나타나며, JSON 파일 내에 API 시퀀스 정보가 포함되어 있다. 쿠쿠 샌드박스는 자동화된 동적 악성코드 분석 시스템으로, 격리된 환경에서 의심스러운 파일을 검사하는데 사 용되고, JSON은 웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성과 값의 형 태로 표현하는 형식이다. 쿠쿠 샌드박스의 결과는 JSON의 형식으로 생성할 수 있다. 또한, 악성코드 바이너리의 정적 분석을 수행하여 호출 그래프(Call Graph)의 정보를 얻을 수 있다. 호출 그래 프의 노드(node)는 단위 프로그램을, 엣지(edge)는 단위 프로그램 사이의 호출을 의미한다. 단계 220에서, 악성코드 진화관계 분석 장치는 API 시퀀스 개수 및 제 2복잡도를 추출 할 수 있다. 악성코드 바이너리의 동적 분석을 수행하여 얻을 수 있는 API 시퀀스 정보를 이용하여 API 시퀀스 개수를 추출 할 수 있고, 악성코드 바이너리의 정적 분석을 수행하여 얻을 수 있는 호출 그래프 정보를 이용하여 제 2복잡도 를 추출 할 수 있다. API 시퀀스 개수는 시퀀스를 구성하는 API 개수일 수 있고, 제 2복잡도는 호출 그래프 복잡도를 의미할 수 있다. 단계 230에서, 추출된 API 시퀀스 개수 및 제 2복잡도를 기초로 하여 악성코드 바이너리의 제 1복잡도를 계산할 수 있다. 악성코드 진화관계 분석 장치는 도 1에서 전술한 수학식1에 따라 제 1복잡도를 계산 할 수 있다. 임의의 값으로 가중치에 해당하고, 악성코드 바이너리의 특징을 파악하여 휴리스틱하게 정해질 수 있다. 악성코드 바이너리는 패킹(Packing) 또는 안티디버깅(Anti-debugging) 되어 있을 수 있는데, 악성코드 바이너리 가 패킹되어 있을 경우 정적 분석 보다는 동적 분석이 정확하게 나타나므로 를 높일 수 있다. 그러나 악성코드 바이너리가 안티디버깅 되어 있다면 동적 분석 보다는 정적 분석이 정확하게 나타나므로 를 낮출 수 있다. 또한, 악성코드 바이너리가 패킹 및 안티디버깅이 되어 있지 않을 경우 가 동일할 수 있다. 패킹은 악성코드 프로그램이 압축되어 분석할 수 없게 난독화된 프로그램의 일부를 의미하고, 안티디버깅은 리 버스 엔지니어링(Reverse Engineering)이나 디버깅을 방지하는 소프트웨어 기술로 악성코드의 탐지 및 제거를 어렵게 할 때 사용되는 것을 의미할 수 있다. 일 실시예에서, 악성코드 진화관계 분석 장치는 악성코드 바이너리의 제 1복잡도를 계산 할 때, 패킹 및 안티디 버깅이 되어 있지 않은 악성코드 바이너리의 경우, 이고, 패킹되어 있으나 안티디버깅이 되어 있지 않은 악성코드 바이너리의 경우, 이고, 패킹되어 있지 않으나 안티디버깅이 되어 있는 상기 악성코드 바이너리의 경우, 을 사용할 수 있으나, 이에 제한되지 않는다. 단계 240에서, 악성코드 진화관계 분석 장치는 악성코드 바이너리의 제 1복잡도가 가장 낮은 악성코드 바이너리 를 근원 바이너리(ROOT)로 선별할 수 있다. 도 3은 도 1에 도시된 단계 130의 구체적인 흐름도이다. 도 3은 도 1의 단계 130에 대응되므로 중복되는 설명은 생략한다. 도 3을 참조하면 단계 310에서, 악성코드 진화관계 분석 장치는 근원 바이너리를 P1으로 식별할 수 있다. 악성 코드 진화관계 분석 장치는 같은 패밀리로 분류된 악성코드 바이너리들 중 근원 바이너리를 P1으로 식별할 수 있 다. 근원 바이너리는 가장 먼저 생성된 최초의 악성코드 바이너리이며, 악성코드 진화관계 분석 장치는 근원 바이너 리를 선별할 수 있고, 근원 바이너리를 기준으로 근원 바이너리 외 악성코드 바이너리들의 진화 순서를 추론해 나갈 수 있다. 단계 320에서. 악성코드 진화관계 분석 장치는 의 악성코드 바이너리들을 제 1복잡도에 따라 오름차순으로 정 렬할 수 있다. 악성코드 진화관계 분석 장치는 의 악성코드 바이너리들을 제 1복잡도가 낮은 순으로 정렬할 수 있다."}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "은 복수의 악성코드 바이너리들 중 진화 순서가 식별된 악성코드 바이너리들의 집합을 의미하고, 은 복수의 악성코드 바이너리들 중 진화 순서가 식별되지 않은 악성코드 바이너리들의 집합을 의미할 수 있다. 일 실시예에서, 및 는 같은 패밀리로 분류된 악성코드 바이너리들에 포함된 집합일 수 있다. 단계 330에 서 악성코드 진화관계 분석 장치는 에서 제 1복잡도가 가장 낮은 원소를 Pj로 선택할 수 있다. 단계 340에서, 악성코드 진화관계 분석 장치는 원소 중 Pj와 가장 거리도가 적은 원소를 Pi로 선택할 수 있 다. 구체적으로, 악성코드 진화관계 분석 장치는 에 포함된 모든 악성코드 바이너리들과 에 포함된 Pj 의 거리도 를 계산하여 비교하고, 에 포함된 모든 악성코드 바이너리들 중 Pj 와의 거리도가 가장 적은 원소를 Pi로 선택 할 수 있다. 단계 350에서, 악성코드 진화관계 분석 장치는 Pj를 Pi의 자식으로 식별할 수 있다. 부모 및 자식은 진화 관계에서의 순서나 계층 구조를 나타내기 위한 표현으로 악성코드 바이너리들 간의 진화 관계가 관련되어 있어 진화 순서가 더 빠른 악성코드 바이너리를 부모라 하고, 진화 순서가 더 느린 악성코드 바이너리를 자식이라 할 수 있다. 악성코드 진화관계 분석 장치는 Pj를 Pi의 자식으로 식별할 수 있고, Pi를 Pj의 부모로 식별할 수 있으며, Pi의 진 화 순서가 Pj보다 더 빠를 수 있다. 단계 360에서, 악성코드 진화관계 분석 장치는 < 인 경우, Pk를 Pj의 부모로 식별할 수 있다. 구체적으로 악성코드 진화관계 분석 장치는 와 를 계산하여 < 인 경우, Pk를 Pj의 부모로 식별할 수 있고, Pj는 Pk의 자식으로 식별될 수 있다. 한편, > 인 경우, Pk를 Pj의 부모로 식별하지 않을 수 있다. 일 실시예에서, 악성코드 바이너리들은 진화 중에 다른 가지로 나뉘는 분기(Branch) 및 일정 규칙에 따라 하나 로 합쳐지는 병합(Merge)이 일어날 수 있는데, 악성코드 진화관계 분석 장치는 악성코드 바이너리들의 분기 및 병합이 일어날 수 있는 형태로 분석할 수 있다. 따라서 부모와 자식이 일대일로 대응되지 않을 수 있고, 임의 의 자식 악성코드 바이너리에 대해 부모 악성코드 바이너리가 여럿 존재할 수 있다. 도 3을 참조하면, 단계 370에서, 악성코드 진화관계 분석 장치는 모든 악성코드 바이너리들이 에 포함될 때까 지 과정을 반복할 수 있다. 일 실시예에서, 같은 패밀리로 분류된 악성코드 바이너리들 중 근원 바이너리는 한 개이므로, 단계 310을 제외 할 수 있고, 진화 순서가 식별되지 않은 의 악성코드 바이너리들이 모두 진화 순서가 식별되어 에 포함될 때까지, 단계 320부터 단계 370을 반복할 수 있다. 모든 악성코드 바이너리들이 에 포함되는 과정을 통해, 악 성코드 바이너리들의 진화 순서를 추론할 수 있다. 또한, 악성코드 진화관계 분석 장치는 악성코드 바이너리들의 진화 순서에 따라 그래프를 도출할 수 있다. 그래프는 악성코드 바이너리들의 진화 순서를 시각적으로 나타낼 수 있는 그림, 표, 차트, 다이어그램 등을 포 함할 수 있고, 이에 제한되지 않는다. 악성코드 진화관계 분석 장치는 악성코드 바이너리들의 진화 순서를 추론 후 진화 순서에 따라 그래프를 도출할 수도 있고, 악성코드 바이너리들의 진화 순서를 추론함과 동시에 그래프를 도출할 수도 있다. 도4 및 도 5는 일 실시예에 따른 악성코드 바이너리들의 진화 순서를 추론하고, 추론된 진화 순서에 따른 그래 프를 도출하는 예시를 설명하기 위한 도면이다. 도 4를 참조하면, P1, P2, P3 등은 임의의 악성코드 바이너리를 의미할 수 있으며, PM은 같은 패밀리로 분류된 악성코드 바이너리들의 개수가 M개 인 것을 의미할 수 있다. 은 복수의 악성코드 바이너리들 중 진화 순 서가 식별된 악성코드 바이너리들의 집합을 의미하고, 는 복수의 악성코드 바이너리들 중 진화 순서가 식별되지 않은 악성코드 바이너리들의 집합을 의미할 수 있다. P1은 근원 바이너리로 식별되어 에 포함되어 있고, P1, P2, P3, P4 쪋쪋 PM 순으로 제 1복잡도가 높아지는 것을 가정한다. 일 실시예에서, P1을 식별하고, 제 1복잡도를 오름차순(P2, P3, P4, 쪋쪋PM)으로 정렬한 후, 에서 제 1복 잡도가 가장 낮은 악성코드 바이너리 P2를 선택하고, 에는 P1만 존재하므로 P2는 P1의 자식으로 식별할 수 있다. P2와 P1의 진화 순서가 식별된 경우, 에서 제 1복잡도가 가장 낮은 악성코드 바이너리 P3를 선택하여, 에는 P1 및 P2가 존재하므로 및 를 계산하고, 가 보다 작은 값임 을 가정하여 P3는 P1의 자식으로 식별할 수 있다. P1, P2, P3의 진화 순서가 식별 된 경우, 에서 제 1복잡도가 가장 낮은 악성코드 바이너리 P4를 선택한다. 에는 P1, P2 및 P3가 존재하므로 , 및 를 계산하고, , , 중 가 가장 작은 값임을 가정하여 P4는 P2의 자식으로 식별할 수 있다. 악성코드 진화관계 분석 장치는 악성코드 바이너리들의 진화 순서를 그래프로 도출할 수 있다. 그래프는 방향성 이 있는 비순환 그래프(Directed Acyclic Graph)로 나타낼 수 있으나, 이에 제한되지 않는다. 일 실시예에서, P1, P2, P3 등은 임의의 악성코드 바이너리를 의미할 수 있고, 악성코드 바이너리들은 원 (circle)으로 표현할 수 있다. 부모와 자식 간은 화살표를 연결하여 나타낼 수 있다. 예를 들어, 근원 바이너리인 P1을 원을 그려 표현하고, 제 1복잡도를 오름차순(P2, P3, P4, 쪋쪋PM)으로 정렬하고, 에서 제 1복잡도가 가장 낮은 악성코드 바이너리 P2를 선택하여 원을 그려 표현할 수 있다. 에는 P1만 존재하므로 P2는 P1의 자식으로 화살표로 연결할 수 있다. 그리고, P3를 원을 그려 표현하고, 및 를 계산하고, 가 보다 작은 값임을 가정하여 P3는 P1의 자식으로 화살 표로 연결할 수 있다. 다음으로, P4를 원을 그려 표현하고, , 및 를 계산하고, , , 중 가 가장 작은 값임을 가정하여 P4는 P2의 자식으로 화살표로 연 결하여 그래프로 도출할 수 있다. 의 P4와 의 P4는 동일한 악성코드 바이너리이며, P4가 연결된 점선은 에서 P4를 선택하고, P4의 진화순서가 식별되어 에 포함되는 과정을 설명하기 위한 것으로 그래프로 도출 시에는 생 략할 수 있다.. 도 5를 참조하면, P1, P2, P3 등은 임의의 악성코드 바이너리를 의미할 수 있으며, PM은 같은 패밀리로 분류된 악성코드 바이너리들의 개수가 M개 인 것을 의미할 수 있다. 은 진화 순서가 식별된 악성코드 바이너리들의 집 합을 의미하고, 는 진화 순서가 식별되지 않은 악성코드 바이너리들의 집합을 의미할 수 있다. P1은 근원 바이너리로 식별되어 에 포함되어 있고, P1, P2, P3, P4 쪋쪋 PM 순으로 제 1복잡도가 높아지는 것을 가정한다. 한편, 도 5는 도 4에 이어지는 내용으로 중복되는 설명은 생략한다. 일 실시예에서, 악성코드 진화관계 분석 장치는 P4 와 P3의 관계성이 P2 와 P3의 관계성보다 떨어진다면, P2와 P3 의 거리보다 P4와 P3의 거리가 더 멀어져야 한다. 그러나, P4와 P3의 거리가 P2와 P3의 거리보다 더 가까워진다면 P4는 P3에 연관성이 높다는 것이며, P3를 P4의 부모로 식별할 수 있다. 예를 들어, P1, P2, P3, P4가 도 4에서와 동일하게 식별되어 있는 경우를 가정한다. P3는 에서 자식이 없는 악 성코드 바이너리에 해당하고, 도 3의 Pk에 해당할 수 있다. P4는 P2의 자식으로 식별된 악성코드 바이너리에 해 당하고, 도 3의 Pj에 해당할 수 있다. P2는 P4의 부모로 식별된 악성코드 바이너리에 해당하고, 도 3의 Pj의 부 모에 해당할 수 있다. 및 를 계산하고, 가 보다 작은 값임을 가정하여, P3을 P4의 부모로 식별할 수 있다. 악성코드 진화관계 분석 장치는 악성코드 바이너리들의 진화 순서를 그래프로 도출할 수 있다. 예를 들어, P1, P2, P3, P4가 도 4에서와 동일하게 그래프로 표현되어 있는 경우를 가정한다. 및 를 계산하고, 가 보다 작은 값임을 가정하여, P3을 P4의 부모로 화살표로 연결하여 그래프로 도출할 수 있다. 도 6은 일 실시예에 따른 악성코드 진화관계 분석 장치의 블록도이다. 도 6을 참조하면, 악성코드 진화관계 분석 장치는 메모리 및 프로세서를 포함할 수 있다. 도 6 에 도시된 악성코드 진화관계 분석 장치에는 실시예와 관련된 구성요소들만이 도시되어 있다. 따라서, 도"}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "6에 도시된 구성요소들 외에 다른 범용적인 구성요소들이 더 포함될 수 있음을 당해 기술분야의 통상의 기술자 라면 이해할 수 있다. 메모리는 악성코드 진화관계 분석 장치 내에서 처리되는 각종 데이터들을 저장하는 하드웨어이다. 예 를 들어, 메모리는 악성코드 바이너리의 제 1복잡도를 계산한 값을 저장할 수 있다. 또한, 메모리는 같은 패밀리로 분류된 악성코드 바이너리들, 악성코드 바이너리들 간의 거리도를 계산한 값 등을 저장할 수 있 다. 메모리는 DRAM(dynamic random access memory), SRAM(static random access memory) 등과 같은 RAM(random access memory), ROM(read-only memory), EEPROM(electrically erasable programmable read-only memory), CD-ROM, 블루레이 또는 다른 광학 디스크 스토리지, HDD(hard disk drive), SSD(solid state drive), 또는 플래시 메모리를 포함할 수 있다. 프로세서는 도 1 내지 도 5에서 상술한, 악성코드 진화관계를 분석하기 위한 전반적인 기능을 수행한다. 일 실시예에서 프로세서는 복수의 악성코드 바이너리들 각각의 제 1복잡도를 계산할 수 있다. 또한 프로세 서는 계산된 제 1복잡도를 이용하여 최초로 생성된 근원 바이너리를 선별할 수 있다. 프로세서는 계 산된 제 1복잡도 및 복수의 악성코드 바이너리들 간의 거리도를 기초로 하여 근원 바이너리 외 악성코드 바이너 리들의 진화 순서를 추론할 수 있다. 본 실시예들은 컴퓨터에 의해 실행되는 프로그램 모듈과 같은 프로그램을 기록한 기록 매체의 형태로도 구현될 수 있다. 컴퓨터 판독 가능 매체는 컴퓨터에 의해 액세스될 수 있는 임의의 가용 매체일 수 있고, 휘발성 및 비 휘발성 매체, 분리형 및 비분리형 매체를 모두 포함한다. 또한, 컴퓨터 판독가능 매체는 컴퓨터 저장 매체 및 통신 매체를 모두 포함할 수 있다. 컴퓨터 저장 매체는 컴퓨터 판독가능 명령어, 데이터 구조, 프로그램 모듈 또는 기타 데이터와 같은 정보의 저장을 위한 임의의 방법 또는 기술로 구현된 휘발성 및 비휘발성, 분리형 및 비분리형 매체를 모두 포함한다. 통신 매체는 전형적으로 컴퓨터 판독가능 명령어, 데이터 구조, 프로그램 모듈 과 같은 변조된 데이터 신호의 기타 데이터, 또는 기타 전송 메커니즘을 포함하며, 임의의 정보 전달 매체를 포 함한다. 또한, 본 명세서에서, \"부\"는 프로세서 또는 회로와 같은 하드웨어 구성(hardware component), 및/또는 프로세 서와 같은 하드웨어 구성에 의해 실행되는 소프트웨어 구성(software component)일 수 있다."}
{"patent_id": "10-2022-0032974", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "전술한 본 명세서의 설명은 예시를 위한 것이며, 본 명세서의 내용이 속하는 기술분야의 통상의 지식을 가진 자 는 본 발명의 기술적 사상이나 필수적인 특징을 변경하지 않고서 다른 구체적인 형태로 쉽게 변형이 가능하다는 것을 이해할 수 있을 것이다. 그러므로 이상에서 기술한 실시예들은 모든 면에서 예시적인 것이며 한정적이 아 닌 것으로 이해해야만 한다. 예를 들어, 단일형으로 설명되어 있는 각 구성 요소는 분산되어 실시될 수도 있으 며, 마찬가지로 분산된 것으로 설명되어 있는 구성 요소들도 결합된 형태로 실시될 수 있다. 상술한 실시예들에 대한 설명은 예시적인 것에 불과하며, 당해 기술 분야에서 통상의 지식을 가진 자라면 이로 부터 다양한 변형 및 균등한 다른 실시예가 가능하다는 점을 이해할 것이다. 따라서 발명의 진정한 보호 범위는 첨부된 청구범위에 의해 정해져야 할 것이며, 청구범위에 기재된 내용과 동등한 범위에 있는 모든 차이점은 청 구범위에 의해 정해지는 보호 범위에 포함되는 것으로 해석되어야 할 것이다."}
{"patent_id": "10-2022-0032974", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일 실시예에 따른 악성코드 진화관계를 분석하는 방법의 흐름도이다. 도 2는 도 1에 도시된 단계 110 및 단계 120의 구체적인 흐름도이다. 도 3은 도 1에 도시된 단계 130의 구체적인 흐름도이다. 도 4 및 도 5는 일 실시예에 따른 악성코드 바이너리들의 진화 순서를 추론하고, 추론된 진화 순서에 따른 그래 프를 도출하는 예시를 설명하기 위한 도면이다. 도 6은 일 실시예에 따른 악성코드 진화관계 분석 장치의 블록도이다."}
