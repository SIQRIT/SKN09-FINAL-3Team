{"patent_id": "10-2021-7035047", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0144846", "출원번호": "10-2021-7035047", "발명의 명칭": "양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법 및 장치, 그리고 칩", "출원인": "텐센트 테크놀로지", "발명자": "정 이총"}}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨터 디바이스에 적용가능한, 양자 회로를 위한 결함 허용 및 에러 정정(fault tolerant and errorcorrection) 디코딩 방법으로서,양자 회로의 실제 에러 신드롬 정보(actual error syndrome information)를 획득하는 단계 ―상기 실제 에러신드롬 정보는 양자 에러 정정(QEC: quantum error correction) 코드를 사용하여 상기 양자 회로에 대해 잡음성에러 신드롬(noisy error syndrome) 측정을 수행함으로써 획득된 정보임―;상기 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보(perfect error syndrome information) 및 논리 에러 부류(logic error class)를 획득하기 위해, 상기 실제 에러 신드롬 정보를 디코딩하는 단계 ―상기 논리 에러 부류는 상기 양자 회로에서 발생하는 에러의 맵핑을 통해 획득된 부류이고, 상기 퍼펙트 에러 신드롬정보는 상기 양자 회로에 대해 무-잡음 에러 신드롬(noise-free error syndrome) 측정을 수행함으로써 획득된정보임―; 및상기 논리 에러 부류 및 상기 퍼펙트 에러 신드롬 정보에 기반하여 상기 양자 회로의 에러 결과 정보를 결정하는 단계 ―상기 에러 결과 정보는 상기 양자 회로에서 에러가 발생하는 데이터 큐비트(data qubit) 및 대응하는에러 부류를 지시하는 데 사용됨―를 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 획득하기 위해, 상기 실제 에러 신드롬 정보를 디코딩하는 단계는,상기 실제 에러 신드롬 정보에 대응하는 논리 에러 부류를 획득하기 위해, 제1 디코더를 사용하여 상기 실제 에러 신드롬 정보를 디코딩하는 단계 ―상기 제1 디코더는 상기 논리 에러 부류를 결정하도록 구성된 뉴럴 네트워크 분류기(neural network classifier)임―; 및상기 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보를 획득하기 위해, 제2 디코더를 사용하여 상기 실제 에러 신드롬 정보를 디코딩하는 단계 ―상기 제2 디코더는 상기 퍼펙트 에러 신드롬 정보를 결정하도록구성된 뉴럴 네트워크 분류기임―를 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 실제 에러 신드롬 정보에 대응하는 논리 에러 부류를 획득하기 위해, 제1 디코더를 사용하여 상기 실제 에러 신드롬 정보를 디코딩하는 단계는,적어도 2개의 블록들을 획득하기 위해, 상기 제1 디코더를 사용하여 상기 실제 에러 신드롬 정보를 파티셔닝하는 단계; 및 피처 정보(feature information)를 획득하기 위해, 적어도 2개의 피처 추출 유닛들을 사용하여 상기 적어도 2개의 블록들에 대해 병렬로 피처 추출을 수행하는 단계; 및상기 실제 에러 신드롬 정보에 대응하는 논리 에러 부류를 획득하기 위해, 상기 제1 디코더를 사용하여 상기 피처 정보에 대해 융합 디코딩(fusion decoding)을 수행하는 단계를 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "공개특허 10-2021-0144846-3-제2항에 있어서, 상기 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보을 획득하기 위해, 제2 디코더를 사용하여 상기 실제 에러 신드롬 정보를 디코딩하는 단계는,k개의 퍼펙트 에러 신드롬 비트들을 획득하기 위해, k개의 제2 디코더들에 각각 상기 실제 에러 신드롬 정보를입력하는 단계 ―상기 k는 양의 정수이고 상기 k는 상기 QEC 코드의 스케일과 관련됨―; 및상기 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보를 획득하기 위해, 상기 k개의 퍼펙트 에러 신드롬 비트들을 통합하는 단계를 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서, 상기 제1 디코더 및 상기 제2 디코더의 트레이닝 프로세스는, 시뮬레이션 결과를 획득하기 위해, 샘플 양자 회로의 데이터 에러 및 측정 에러를 시뮬레이팅하는 것 ―상기 데이터 에러는 상기 샘플 양자 회로의 데이터 큐비트 상에서 발생하는 에러이고, 상기 측정 에러는 에러 신드롬측정 동안 발생하는 에러임―; 상기 시뮬레이션 결과에 기반하여, T개의 에러 신드롬 측정들에서 상기 샘플 양자 회로의 에러 신드롬 정보를획득하는 것 ―상기 T는 1보다 큰 정수임―;상기 T개의 에러 신드롬 정보(pieces of error syndrome information)를 타겟 시점(target time point)에 투영함으로써 획득된 등가 데이터 에러(equivalent data error) 정보를 결정하는 것;상기 등가 데이터 에러 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 결정하는 것;트레이닝 샘플을 구축하는 것 ―상기 트레이닝 샘플의 샘플 데이터는 상기 T개의 에러 신드롬 정보를 포함하고,상기 트레이닝 샘플은 라벨 데이터를 포함하고, 상기 라벨 데이터는 상기 등가 데이터 에러 정보에 대응하는 상기 퍼펙트 에러 신드롬 정보 및 상기 논리 에러 부류를 포함함―; 및상기 트레이닝 샘플을 사용하여 상기 제1 디코더 및 상기 제2 디코더를 트레이닝시키는 것으로 이루어지는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서, 상기 샘플 양자 회로의 데이터 에러 및 측정 에러를 시뮬레이팅하는 것은,상기 샘플 양자 회로에 포함된 데이터 큐비트에서 에러를 확률적으로 생성하는 것;상기 샘플 양자 회로에 대응하는 보조 큐비트(auxiliary qubit)에서 에러를 확률적으로 생성하는 것 ―상기 보조 큐비트는 상기 샘플 양자 회로의 에러 신드롬 정보를 측정하도록 구성됨―;고유값(eigenvalue) 측정 회로에 포함된 비-제어(CNOT: controlled-not) 게이트에서 에러를 확률적으로 생성하는 것 ―상기 고유값 측정 회로는, 상기 샘플 양자 회로에 대응하며, 스태빌라이저 생성자(stabilizergenerator)의 고유값을 측정하도록 구성됨―; 및상기 QEC 코드를 사용하여 상기 샘플 양자 회로에 대해 에러 신드롬 측정이 수행되는 경우에 측정 에러를 확률적으로 생성하는 것을 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제5항에 있어서, 상기 샘플 양자 회로의 데이터 에러 및 측정 에러를 시뮬레이팅하는 것은,공개특허 10-2021-0144846-4-상기 샘플 양자 회로의 잡음 모델을 추출하기 위해, 상기 샘플 양자 회로에 대해 양자 프로세스 토모그래피(QPT:quantum process tomography)를 수행하는 것 ―상기 잡음 모델은 시뮬레이션을 통해 상기 데이터 에러 및상기 측정 에러를 생성하도록 구성됨―; 및상기 잡음 모델에 기반하여, 잡음의 작용 하에 상기 샘플 양자 회로의 양자 상태의 진화(evolution)를 시뮬레이팅하는 것을 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제2항에 있어서, 상기 제1 디코더 및 상기 제2 디코더의 트레이닝 프로세스는,상기 샘플 양자 회로의 에러 신드롬 정보를 획득하기 위해, 상기 샘플 양자 회로에 대해 잡음성 에러 신드롬 측정을 수행하는 것;상기 샘플 양자 회로의 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 획득하기위해, 다른 디코더를 사용하여 상기 샘플 양자 회로의 에러 신드롬 정보를 디코딩하는 것;트레이닝 샘플을 구축하는 것 ―상기 트레이닝 샘플의 샘플 데이터는 상기 샘플 양자 회로의 에러 신드롬 정보를 포함하고, 상기 트레이닝 샘플은 라벨 데이터를 포함하고, 상기 라벨 데이터는 상기 샘플 양자 회로의 상기에러 신드롬 정보에 대응하는 상기 퍼펙트 에러 신드롬 정보 및 상기 논리 에러 부류를 포함함―; 및상기 트레이닝 샘플을 사용하여 상기 제1 디코더 및 상기 제2 디코더를 트레이닝시키는 것으로 이루어지는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서, 상기 논리 에러 부류 및 상기 퍼펙트 에러 신드롬 정보에 기반하여 상기 양자 회로의 에러 결과 정보를 결정하는 단계는,상기 논리 에러 부류에 대응하는 제1 에러 결과를 획득하는 단계;상기 퍼펙트 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득하는 단계; 및상기 제1 에러 결과 및 상기 제2 에러 결과에 기반하여 상기 양자 회로의 에러 결과 정보를 결정하는 단계를 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 논리 에러 부류에 대응하는 제1 에러 결과를 획득하는 단계는, 상기 논리 에러 부류에 포함된 엘리먼트들로부터의 임의의 엘리먼트를 상기 제1 에러 결과로서 선택하는 단계를 포함하며,상기 논리 에러 부류는 적어도 하나의 등가 에러 엘리먼트를 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제9항에 있어서, 상기 퍼펙트 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득하는 단계는,상기 퍼펙트 에러 신드롬 정보에서 각각 에러 신드롬 포인트들에 대응하는 심플 에러(simple error)들에 대한맵핑 테이블을 검색하는 단계 ―상기 맵핑 테이블은 에러 신드롬 포인트와 심플 에러 간의 적어도 한 세트의 맵핑 관계를 포함함 ―; 및공개특허 10-2021-0144846-5-제2 에러 결과를 획득하기 위해, 각각 에러 신드롬 포인트들에 대응하는 상기 심플 에러들을 곱하는 단계를 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제9항에 있어서, 상기 제1 에러 결과 및 상기 제2 에러 결과에 기반하여 상기 양자 회로의 에러 결과 정보를 결정하는 단계는,상기 양자 회로의 에러 결과 정보를 획득하기 위해, 상기 제1 에러 결과와 상기 제2 에러 결과의 곱(product)을결정하는 단계를 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1항 내지 제12항 중 어느 한 항에 있어서, 상기 논리 에러 부류 및 상기 퍼펙트 에러 신드롬 정보에 기반하여 상기 양자 회로의 에러 결과 정보를 결정한후, 상기 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법은,상기 에러 결과 정보에 기반하여 에러 정정 제어 신호를 생성하는 단계 ―상기 에러 정정 제어 신호는 상기 양자 회로에서 발생하는 에러를 정정하는 데 사용됨―; 및상기 에러 정정 제어 신호를 상기 양자 회로에 전송하는 단계를 더 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "양자 회로를 위한 결함 허용 및 에러 정정 디코딩 장치로서,양자 회로의 실제 에러 신드롬 정보를 획득하도록 구성된 신드롬 정보 획득 모듈 ―상기 실제 에러 신드롬 정보는 양자 에러 정정(QEC) 코드를 사용하여 상기 양자 회로에 대해 잡음 에러 신드롬 측정을 수행함으로써 획득된정보임―;상기 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 획득하기 위해, 상기 실제 에러 신드롬 정보를 디코딩하도록 구성된 신드롬 정보 디코딩 모듈 ―상기 논리 에러 부류는 상기 양자 회로에서 발생하는 에러의 맵핑을 통해 획득된 부류이고, 상기 퍼펙트 에러 신드롬 정보는 상기 양자 회로에 대해무-잡음 에러 신드롬 측정을 수행함으로써 획득된 정보임―; 및상기 논리 에러 부류 및 상기 퍼펙트 에러 신드롬 정보에 기반하여 상기 양자 회로의 에러 결과 정보를 결정하도록 구성된 에러 결과 결정 모듈 ―상기 에러 결과 정보는 상기 양자 회로에서 에러가 발생하는 데이터 큐비트및 대응하는 에러 부류를 지시하는 데 사용됨―를 포함하는, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 장치."}
{"patent_id": "10-2021-7035047", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "프로그래밍가능 논리 회로 및/또는 프로그램 명령들을 포함하는 칩으로서,상기 칩은, 제1항 내지 제13항 중 어느 한 항에 따른 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법을구현하기 위해 컴퓨터 디바이스 상에서 실행되도록 구성되는, 프로그래밍가능 논리 회로 및/또는 프로그램 명령들을 포함하는 칩."}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 출원은 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법 및 장치, 및 칩을 개시하며, 인공 지능(AI) 및 양자 기술들의 분야에 관한 것이다. 방법은, 양자 회로의 실제 에러 신드롬 정보(actual error syndrome information)를 획득하는 단계 ―실제 에러 신드롬 정보는 양자 에러 정정(QEC: quantum error correction) 코 (뒷면에 계속)"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원은, 2020년 4월 15일자로 출원되고 명칭이 \"양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법 및 장치, 그리고 칩\"인 중국 특허 출원 제202010296673.1을 우선권으로 주장하며, 이 출원은 그 전체가 인용에 의 해 본원에 포함된다. 본 출원의 실시예들은 인공 지능(AI: artificial intelligence) 및 양자(quantum) 기술 분야에 관한 것으로, 특히, 양자 회로를 위한 결함 허용(fault tolerant) 및 에러 정정(error correction) 디코딩 방법 및 장치, 및 칩에 관한 것이다."}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "큐비트(qubit)들은 잡음에 매우 민감하기 때문에, 현재 기술들로는, 물리적 큐비트들에 대해 양자 컴퓨테이션 (QC: quantum computing)을 직접 구현하는 것은 여전히 실용적이지 않다. 양자 에러 정정(QEC: quantum error correction) 코드 기술 및 결함 허용 양자 계산(FTQC: fault tolerant quantum computation) 기술의 개발은 원 칙적으로, 잡음성 큐비트(noisy qubit)들 상에서 임의의 정밀도로 QC를 구현하는 것을 가능하게 한다. 에러 신드롬 정보(error syndrome information)가 QEC 코드를 사용하여 양자 회로의 에러 신드롬들을 측정함으 로써 획득된 후, 양자 회로에서 에러가 발생하는 데이터 큐비트 및 대응하는 에러 부류를 결정하기 위해, 에러 신드롬 정보가 디코딩 알고리즘을 사용하여 디코딩될 수 있다. 에러 신드롬 정보가 퍼펙트(perfect)한 경우(즉, 에러 신드롬 측정이 무-잡음(noise-free)인 경우), 에러 신드롬 정보를 디코딩하여 대응하는 에러 결과 정보를 획득하기 위해 뉴럴 네트워크 디코더를 사용하여 것이 선행 기술에서 제안되었다. 그러나, 실제 상황들에서, 에러 신드롬 정보는 퍼펙트하지 않다(즉, 에러 신드롬 측정에는 잡음이 있음). 그러 한 실제 상황들에서 에러 신드롬 정보에 대해 실시간 결함 허용 및 에러 정정 디코딩을 수행하는 방법에 대한 효과적인 해결책은 현재 없다. 본 출원의 실시예들은 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법 및 장치, 및 칩을 제공하며, 이는, 에러 신드롬 정보가 퍼펙트하지 않은 경우, 양자 회로의 에러 신드롬 정보에 대한 실시간 결함 허용 및 에러 정정 디코딩을 달성한다. 기술적 해결책들은 다음과 같다: 일 양상에 따르면, 본 출원의 실시예는, 컴퓨터 디바이스에 적용가능한, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법을 제공하며, 이 방법은, 양자 회로의 실제 에러 신드롬 정보(actual error syndrome information)를 획득하는 단계 ―실제 에러 신드롬 정보는 QEC 코드를 사용하여 양자 회로에 대해 잡음성 에러 신드롬 측정을 수행함으로써 획득된 정보임―; 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보(perfect error syndrome information) 및 논리 에 러 부류(logic error class)를 획득하기 위해, 실제 에러 신드롬 정보를 디코딩하는 단계 ―논리 에러 부류는 양자 회로에서 발생하는 에러의 맵핑을 통해 획득된 부류이고, 퍼펙트 에러 신드롬 정보는 양자 회로에 대해 무 -잡음 에러 신드롬(noise-free error syndrome) 측정을 수행함으로써 획득된 정보임―; 및 논리 에러 부류 및 퍼펙트 에러 신드롬 정보에 기반하여 양자 회로의 에러 결과 정보를 결정하는 단계 ―에러 결과 정보는 양자 회로에서 에러가 발생하는 데이터 큐비트 및 대응하는 에러 부류를 지시하는 데 사용됨―를 포함한다. 다른 양상에 따르면, 본 출원의 실시예는 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 장치를 제공하며, 이 장치는, 양자 회로의 실제 에러 신드롬 정보를 획득하도록 구성된 신드롬 정보 획득 모듈 ―실제 에러 신드롬 정보는 QEC 코드를 사용하여 양자 회로에 대해 잡음성 에러 신드롬 측정을 수행함으로써 획득된 정보임―; 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 획득하기 위해, 실제 에러 신 드롬 정보를 디코딩하도록 구성된 신드롬 정보 디코딩 모듈 ―논리 에러 부류는 양자 회로에서 발생하는 에러의 맵핑을 통해 획득된 부류이고, 퍼펙트 에러 신드롬 정보는 양자 회로에 대해 무-잡음 에러 신드롬 측정을 수행 함으로써 획득된 정보임―; 및 논리 에러 부류 및 퍼펙트 에러 신드롬 정보에 기반하여 양자 회로의 에러 결과 정보를 결정하도록 구성된 에러 결과 결정 모듈 ―에러 결과 정보는 양자 회로에서 에러가 발생하는 데이터 큐비트 및 대응하는 에러 부류를 지 시하는 데 사용됨―를 포함한다. 다른 양상에 따르면, 본 출원의 실시예는, 프로세서 및 메모리를 포함하는 컴퓨터 디바이스를 제공하며, 메모리 는 적어도 하나의 명령, 적어도 하나의 프로그램 세그먼트, 코드 세트 또는 명령 세트를 저장하고, 적어도 하나 의 명령, 적어도 하나의 프로그램 세그먼트, 코드 세트, 또는 명령 세트는, 양자 회로에 대한 전술한 결함 허용및 에러 정정 디코딩 방법을 구현하도록 프로세서에 의해 로딩 및 실행된다. 다른 양상에 따르면, 본 출원의 실시예는, 적어도 하나의 명령, 적어도 하나의 프로그램 세그먼트, 코드 세트 또는 명령어 세트를 저장하는 컴퓨터-판독가능 저장 매체를 제공하며, 적어도 하나의 명령, 적어도 하나의 프로 그램 세그먼트, 코드 세트, 또는 명령 세트는, 양자 회로에 대한 전술한 결함 허용 및 에러 정정 디코딩 방법을 구현하도록 프로세서에 의해 로딩되고 실행된다. 또 다른 양상에 따르면, 본 출원의 실시예는, 프로그래밍가능 논리 회로 및/또는 프로그램 명령들을 포함하는 칩을 제공하며, 이 칩은 양자 회로에 대한 전술한 결함 허용 및 에러 정정 디코딩 방법을 구현하도록 컴퓨터 디 바이스에서 실행되도록 구성된다. 또 다른 양상에 따르면, 본 출원의 실시예는 컴퓨터 프로그램 제품 또는 컴퓨터 프로그램을 제공하며, 이 컴퓨 터 프로그램 제품 또는 컴퓨터 프로그램은 컴퓨터 명령들을 포함하며, 컴퓨터 명령들은 컴퓨터-판독가능 저장 매체에 저장된다. 컴퓨터 디바이스의 프로세서는, 컴퓨터-판독가능 저장 매체로부터 컴퓨터 명령들을 판독하고 그리고 컴퓨터 디바이스로 하여금, 양자 회로에 대한 전술한 결함 허용 및 에러 정정 디코딩 방법을 수행하게 하기 위해 컴퓨터 명령들을 실행한다. 본 출원의 실시예들에서 제공되는 기술적 해결책들은 적어도 다음의 유익한 효과들을 포함한다: 대응하는 논리 에러 부류 및 대응하는 퍼펙트 에러 신드롬 정보를 획득하기 위해 양자 회로의 실제 에러 신드롬 정보를 디코딩한 다음, 논리 에러 부류 및 퍼펙트 에러 신드롬 정보에 따라 양자 회로에서 에러가 발생한 데이 터 큐비트 및 대응하는 에러 부류를 결정함으로써, 본 출원은, 에러 신드롬 정보가 퍼펙트하지 않은 경우 양자 회로의 에러 신드롬 정보에 대한 결함 허용 및 에러 정정 디코딩을 달성한다. 부가하여, 본 해결책은 결함 허용 및 에러 정정 디코딩을 분류 문제로 등가적으로 변환하고, 이에 따라 효율적인 뉴럴 네트워크 분류기를 사용하 여 에러 신드롬 정보에 대해 결함 허용 및 에러 정정 디코딩이 수행될 수 있고, 이로써 결함 허용 및 에러 정정 디코딩 속도를 개선하고, 그리고 실시간 결함 허용 및 에러 정정 디코딩을 달성한다."}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 출원의 목적들, 기술적 해결책들 및 이점들을 더 명확하게 하기 위해, 하기에서는 첨부된 도면들을 참조하여 본 출원의 구현들을 상세히 설명한다. 본 출원의 실시예들을 설명하기 전에, 본 출원에 수반되는 일부 용어들이 먼저 소개된다. 1. 양자 컴퓨테이션(QC; quantum computation): QC는 특정 컴퓨테이션 작업을 신속하게 완료하기 위해 양자 상 태들의 중첩(superposition) 및 얽힘(entanglement) 특성들을 사용하는 방식이다. 2. 양자 순간이동(quantum teleportation): 양자 순간이동은, 양자 얽힌 상태들을 분산시키고 일부 고전적 정보 (classical information)를 전송하는 방식으로, 임의의 거리만큼 임의의 미지의 양자 상태를 송신하는 기술이다. 3. 양자 에러 정정(QEC: quantum error correction): QEC는 인코딩을 위해 다-물체(many-body) 양자 시스템의 힐베르트 공간(Hilbert space)의 서브공간에 양자 상태를 맵핑하는 방식이다. 양자 잡음은 인코딩된 양자 상태 가 다른 서브공간으로 전달되게 할 수 있다. 양자 상태가 위치된 공간을 연속적으로 관찰함으로써(신드롬 추 출), 양자 잡음이, 인코딩된 양자 상태를 간섭함 없이 평가 및 수정될 수 있어, 양자 잡음으로부터의 간섭에 대 해 인코딩된 양자 상태를 보호할 수 있다. 구체적으로, QEC 코드 의 경우, 이는, k개의 논리적 큐비 트가 n개의 물리적 큐비트들로 인코딩되어, 임의의 단일 큐비트에서 발생하는 임의의 에러들이 정정 된다는 것을 표현한다. 4. 데이터 양자 상태: 데이터 양자 상태는 QC 동안 양자 정보의 데이터 큐비트의 양자 상태를 저장하는 데 사용 된다. 5. 스태빌라이저 생성자(stabilizer generator): 스태빌라이저 생성자는 또한 패리티 검사 연산자(parity check operator)로 지칭된다. 양자 잡음(에러)의 발생은 일부 스태빌라이저 생성자들의 고유값(eigenvalue)들을 변화시키고, 이에 QEC는 그러한 정보에 따라 수행될 수 있다. 6. 스태빌라이저 그룹(stabilizer group): 스태빌라이저 그룹은 스태빌라이저 생성자들에 의해 생성된 그룹이다. k개의 스태빌라이저 생성자들이 존재하는 경우, 스태빌라이저 그룹은 개의 엘리먼트들을 포함하며, 이는 아벨 그룹(abelian group)이다. 7. 에러 신드롬: 에러가 없는 경우, 스태빌라이저 생성자들의 고유값들은 0이고; 양자 잡음이 발생하는 경우, 에러 정정 코드의 일부 스태빌라이저 생성자들(패리티 검사 연산자들)의 고유값들은 1로 변한다. 이러한 신드롬 비트들 0 및 1에 의해 형성된 비트 스트링이 에러 신드롬으로 지칭된다. 8. 신드롬 측정 회로: 검사 회로(checking circuit)로 또한 지칭되는 신드롬 측정 회로는, 에러 신드롬을 획득 하기 위한 양자 회로이다. 일반적으로, 회로 자체도 또한 잡음으로 오염된다. 9. 토폴로지 양자 에러 정정(QEC) 코드: 토폴로지 QEC 코드(topological QEC code)는 특정 타입의 QEC 코드이 다. 이러한 타입의 에러 정정 코드의 큐비트들은 2 초과 차원들의 그리드 어레이 상에 분산된다. 그리드들은 고 차원(high-dimensional) 매니폴드의 이산 구조를 형성한다. 이 경우, 에러 정정 코드의 스태빌라이저 생성자들 은 제한된 그리고 기하학적으로 이웃하는 큐비트들에 대해 정의되며, 이들 모두는 기하학적으로 로컬(local)이 고 측정하기 쉽다. 이러한 타입의 정정 코드의 논리 연산자들이 작용하는 큐비트들은 그리드 어레이의 매니폴드 상에서 비-자명 토폴로지(non-trivial topology)들을 갖는 기하학적 객체들의 부류를 형성한다. 10. 표면 코드(surface code): 표면 코드는 2차원 매니폴드 상에 정의된 토폴로지 QEC 코드의 부류에 속한다. 표면 코드의 스태빌라이저 생성자는 일반적으로 4개의 큐비트들(경계에서 2개의 큐비트들에 의해 지원됨)에 의 해 지원되며, 표면 코드의 논리 연산자는 스트립-형상 스패닝 어레이(strip-shaped spanning array)의 비-자명 체인이다. 표면 코드의 특정 2차원 구조(25개의 데이터 큐비트들 및 24개의 보조 큐비트들을 가지며 2개의 큐비 트들에서 발생하는 임의의 에러들을 정정할 수 있는, 5×5)가 도 1에 도시된다: 백색 원들은 QC에 사용되는 데이터 큐비트들을 표현하고, 흑색 원들은 보조 큐비트들을 표현한다. 보조 큐비트들은 초기에 또는 상태로 준비된다. 슬래시들로 채워진 블록들(또는 반원들) 및 백색의 클록들(또는 반원들)은, Z개 의 에러들 및 X 에러들을 검출하기 위해 각각 사용되는 2개의 상이한 타입들의 스태빌라이저 생성자들을 표현한 다. 본 출원에서, 도 1에 도시된 회전된 표면 코드가 사용될 것인데, 이는 물리적 큐비트들의 대략 절반을 절약 할 수 있으며, 최근의 실험에서 검증되기에 더 편리하기 때문이다. 11. 표면 코드 스케일 L: 표면 코드 스케일 L은 표면 코드 어레이의 원주의 1/4이다. 도 1의 표면 코드 스케일 L은 5와 등가이다. 12. 스태빌라이저 코드: 스태빌라이저 코드는 스태빌라이저 생성자들의 그룹에 의해 정의된 QEC 코드이다. 스태 빌라이저 생성자들은, 서로 가환(commutate)이며 n개의 큐비트들에 대해 독립적으로 작용하는 파울리 연산자 (Pauli operator)들의 그룹이다. 공통 고유값 +1을 갖는 파울리 연산자들의 그룹의 고유 서브공간들 (eigensubspace)은, 스태빌라이저 코드의 인코딩 공간이다. 13. 상동 부류(homoology class): 토폴로지에 있어, 상동 이론에서의 상동 부류는 0의 경계를 갖는 기하학적 서 브-객체들의 제한된 선형 결합에 의해 표현된다. 선형 결합의 기하학적 객체들이 하나 초과의 차원을 갖는 기하 학적 객체들의 경계들로서 여겨질 수 있다면, 선형 결합은 \"0\"과 상동하는 것으로 간주된다(본원에서 0은 토폴 로지 의미에서 자명 부류(trivial class)로 지칭되며, 이는 연속적으로 포인트들로 축소될 수 있는 기하학적 객 체들이다). 하기에서, 상동 부류는 때때로 \"에러 부류\"와 혼합된다. 14. X 및 Z 에러: X 에러 및 Z 에러는 물리적 큐비트의 양자 상태에 대해 무작위로 생성되는 파울리-X 진화 (evolution) 에러 및 파울리-Z 진화 에러이다. QEC 이론에 따라, 에러 정정 코드가 X 에러 및 Z 에러를 정정하 는 데 사용될 수 있다면, 에러 정정 코드는 단일 큐비트 상에서 발생하는 임의의 에러를 정정하는 데 사용될 수 있다. 15. 결함 허용 양자 에러 정정(FTQEC: fault tolerant quantum error correction): 양자 게이트 측정 및 양자 측정을 포함하는 실제 QC 동안 모든 동작 프로세스들에는 잡음이 있다. 즉, QEC를 위해 구성된 회로 또한 잡음 을 포함한다. FTQEC는, 에러 정정 회로를 능숙하게 설계함으로써 잡음을 갖는 에러 정정 회로가 그 정정에 사용 될 수 있으며, 에러를 정정하고 시간이 지남에 따라 에러가 전파되는 것을 방지하는 목적이 여전히 달성될 수 있음을 의미한다. 16. 결함 허용 양자 컴퓨테이션(FTQC: fault tolerant quantum computation): FTQC는 QEC 보호 하의 QC이다. QC 동안, QEC 회로 자체에 대한 동작 및 큐비트 측정을 포함하는 임의의 물리적 동작에서 잡음이 존재한다. FTQC는, 잡음을 갖는 큐비트들을 사용하여 QC 동안 효과적인 제어 및 에러 정정을 보장하기 위해, QEC 방식을 적절하게 설계하고 인코딩된 논리 양자 상태에 대해 특정 방식으로 게이트 동작을 수행하는 방법이 사용되는 기 술적 해결책이다. 17. 물리적 큐비트: 물리적 큐비트는 실제 물리적 디바이스를 사용하여 구현된 큐비트이다. 18. 논리적 큐비트: 논리적 큐비트는 에러 정정 코드에 의해 정의된 힐베르트 서브공간의 수학적 자유도 (mathematical degree of freedom)이다. 논리적 큐비트의 양자 상태의 설명은 일반적으로 다-물체 얽힌 상태이 고, 논리적 큐비트는 일반적으로 복수의 물리적 큐비트들의 조인트 힐베르트 공간(joint Hilbert space)의 2차원 서브공간들로 인코딩된다. FTQC는 에러 정정 코드에 의해 보호되는 논리적 큐비트 상에서 실행될 필요가 있 다. 19. 물리적 양자 게이트/회로: 물리적 양자 게이트/회로는 물리적 큐비트에 대해 작용하는 양자 게이트/회로이 다. 20. 논리 양자 게이트/회로: 논리 양자 게이트/회로는 논리적 큐비트에 대해 작용하는 양자 게이트/회로이다. 21. 데이터 에러: 데이터 에러는 데이터 큐비트 상에서 발생하는 에러이다. 22. 측정 에러: 측정 에러는 퍼펙트하지 않은 측정 프로세스에 의해 야기되는 에러이다. 23. 임계치 정리(threshold theorem): 임계치 정리에 있어서, FTQC 요건을 충족시키는 컴퓨테이션 방식의 경우, 모든 연산들의 에러 레이트들이 임계치 미만일 때, 더 나은 에러 정정 코드, 더 많은 큐비트들 및 더 많은 양자 연산들이, 컴퓨테이션 정확도가 1에 근사하게 하는 데 사용될 수 있다. 부가하여, 이러한 부가적인 자원 오버헤 드들은, QC의 기하급수적 속도증가(exponential speedup)와 비교할 때 무시될 수 있다. 24. 뉴럴 네트워크: 인공 뉴럴 네트워크(artificial neural network)는 적응형 비선형 동적 시스템이며, 이는 많은 수량의 간단한 기본 엘리먼트들(뉴런들은 서로 연결됨)을 포함한다. 각각의 뉴런의 구조 및 기능들은 비교 적 간단하지만, 많은 수량의 뉴런들의 결합에 의해 생성되는 시스템 거동들은 상당히 복잡하며, 이는 원칙적으 로 임의의 기능을 표현할 수 있다. 본 출원에서의 기술적 해결책은 양자 기술들 및 AI 기술들의 분야에 관한 것이다. AI는, 인간 지능을 시뮬레이 팅하고, 연장 및 확장하고, 환경을 인식하고, 지식을 습득하고, 그리고 최적의 결과를 획득하기 위해 이 지식을 사용하도록 디지털 컴퓨터에 의해 제어되는 머신 또는 디지털 컴퓨터를 사용하는 이론, 방법, 기술 및 애플리케 이션 시스템이다. AI 기술은 포괄적인 분야이며, 하드웨어-레벨 기술들 및 소프트웨어-레벨 기술들 둘 모두를 포함하는 광범위한 학문분야들과 관련된다. ML은, 다중-필드 다분야 학제간(multi-field interdiscipline)이며, 확률 이론, 통계, 근사 이론, 컨벡스 분석 (convex analysis) 및 알고리즘 복잡성 이론과 같은 복수의 학문분야들에 관한 것이다. ML은, 컴퓨터가 인간 학 습 거동을 시뮬레이팅하거나 구현하여 새로운 지식 또는 스킬들을 획득하고 그리고 기존 지식 구조를 재구성하 여 그의 성능을 계속 개선하는 방법을 연구하고 하는 것을 전문으로 한다. ML은, AI의 핵심이며, 컴퓨터를 지능 적으로 만들기 위한 기본적인 방법이며, 다양한 AI 분야들에 적용된다. ML 및 심층 학습은 일반적으로, 인공 뉴 럴 네트워크, 빌리프 네트워크(belief network), 강화 학습(reinforcement learning), 전이 학습(transfer learning), 귀납적 학습(inductive learning), 및 시연(demonstration)들로부터의 학습과 같은 기술들을 포함 한다. AI 기술의 연구 및 진보에 따라, AI 기술은, 공통 스마트 홈, 스마트 웨어러블 디바이스, 가상 비서(virtual assistant), 스마트 스피커, 스마트 마케팅, 무인 주행(unmanned driving), 자율 주행(automatic driving), 무 인 항공기(unmanned aerial vehicle), 로봇, 스마트 메디컬 케어(smart medical care) 및 스마트 고객 서비스 (smart customer service)와 같은 여러 분야들에서 연구되고 적용된다. 기술들의 발전에 따라, AI 기술은 더 많 은 분야들에 적용될 것이며, 점점 더 중요한 역할을 할 것으로 여겨진다. 본 출원의 실시예들에서 제공되는 해결책들은, 양자 기술들의 분야에서의 AI의 머신 학습 기술들의 적용을 수반 하며, 구체적으로는, 다음의 실시예들을 사용하여 구체적으로 설명되는, QEC 코드들에 대한 디코딩 알고리즘에 서의 머신 학습 기술들의 적용에 관한 것이다. 에러 정정 코드로서, 에러가 발생한 후에, 패리티 검사를 통해 에러 신드롬들이 획득될 수 있고; 그런 다음, 에 러가 발생한 포지션 및 에러 부류(에러는 X 에러이거나, Z 에러이거나 또는 이 둘 모두, 즉 Y 에러임)가, 에러 정정 코드들에 대한 특정 디코딩 알고리즘을 사용하여 신드롬들에 따라 결정된다. 표면 코드의 경우, 에러 및 에러 신드롬은 특정 공간 포지션들을 갖는다: 에러가 신드롬들을 야기하는 경우, 대응하는 포지션에서 보조 큐 비트의 고유값은 1이고(이는, 해당 포지션에서 포인트 입자(point particle)가 발생한다고 여겨질 수 있음)이고; 그리고 에러가 없을 경우, 대응하는 포지션에서 보조 큐비트의 고유값은 0이다. 디코딩 프로세스는"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "다음과 같이 요약될 수 있다: 공간 디지털 어레이(이는 2차원 또는 3차원이며 0 또는 1의 값을 가짐)가 제공되 고, 에러가 발생할 가장 가능성 있는 큐비트들 및 특정 에러 부류가 특별 에러 발생 모델에 따라 추론되며, 추론의 결과에 따라 에러 정정이 수행된다. 도 2는 표면 코드의 에러의 발생을 도시하는 개략도이다. 큐비트는 2-차원 어레이의 에지 상에 있고, 에러 신드 롬들을 측정하기 위한 보조 큐비트는 2-차원 어레이의 노드 상에 있다(이러한 신드롬들은 퍼펙트하게 측정됨). 도 2의 흑색 에지들은 에러가 발생하는 큐비트들에 의해 형성된 에러 체인들을 표현하고, 슬래시들로 채워 진 원 부분들은, 에러에 의해 야기되고 1의 신드롬 값들을 갖는 포인트들을 표현한다. 체인-형상 에러가 포 인트-형상 신드롬들에 기반하여 결정될 수 있다면, 디코딩은 완료될 수 있다. 대응하는 에러 결과 정보, 예컨대 에러가 발생하는 포지션 및 에러 부류가 QEC 코드들에 대한 디코딩 알고리즘 (이는, 대안적으로 디코더로 지칭될 수 있음)을 사용하여 에러 신드롬 정보를 디코딩함으로써 획득될 수 있다는 것이 위에서 이미 설명되었다. 에러 신드롬 정보가 퍼펙트한 경우(즉, 측정 프로세스에서 잡음이 없는 경우), 에러 신드롬 정보가 뉴럴 네트워크에 기반하여 구축된(constructed) 디코더(이는, 뉴럴 네트워크 디코더로 지칭 될 수 있음)를 사용하여 디코딩되어, 대응하는 에러 결과 정보가 획득될 수 있다. 디코딩 프로세스가 입력/출력 함수이기 때문에, 뉴럴 네트워크가 구축될 수 있고, 정확한 입력/출력 결과를 이용하여 뉴럴 네트워크를 트레이 닝시켜 에러의 부류 및 포지션을 정확하게 결정하는 것이 학습(지도 학습)된다. 에러들은 상이한 뉴럴 네트워크 디코더 출력 부류들에 따라 2개의 부류들로 분류될 수 있는데, 하나는 물리적 부류이고 다른 하나는 논리적 부 류이다. 물리적-부류 출력 모델은, 에러의 발생, 즉, 특정 큐비트에 대해 그의 부류가 발생하는 에러에 대응하 는 특정 큐비트 정보를 직접 생성한다. 논리적-부류 출력 모델이 특정 에러의 특별한 맵핑 후에 획득된 논리 에 러 부류(표면 코드의 경우, 상동 부류가 출력됨)를 출력한 다음, 큐비트 상에서 발생하는 특정 등가 에러가 논 리 에러 부류에 따라 역으로 추론된다(추론된 에러는, 원래 발생한 에러와 불필요하게 완전히 동일하지만, 동일 한 효과를 발생시키며, 이는 QEC 코드들의 고유한 에러 퇴화 현상(unique error degeneration phenomenon)임). 논리-부류 에러 정정은 신드롬이 퍼펙트(즉, 측정 프로세스에서 잡음이 없음)한 경우에서의 상동 부류 분류 문 제와 등가이며, 이는 지도 학습 트레이닝 후에 뉴럴 네트워크에 의한 추론 분류를 수행하는 데 적용가능하지만, 결함 허용 및 에러 정정 문제에는 완전히 적용가능하지는 않다. 비교적 일반적인 뉴럴 네트워크 디코딩 알고리 즘은 완전 연결 네트워크(fully connected network), CNN(convolutional neural network), RNN(recurrent neural network) 등을 사용한다. 뉴럴 네트워크의 대부분의 연산들은 행렬 연산들이며, 이는 고도로 병렬화될 수 있고, 그리고 매우 짧은 실시간 컴퓨테이션 시간으로, 특정 하드웨어(예를 들어, FPGA(Field Programmable Gate Array) 또는 ASIC(Application Specific Integrated Circuit))에서 실행하기에 매우 적합하다. 에러 신드롬 정보가 퍼펙트하지 않은 경우(이는, 잡음을 갖는 신드롬 측정으로 지칭될 수 있고, 측정 프로세스 에서 에러가 발생할 수 있는 경우를 지칭함), 뉴럴 네트워크 디코더가 디코딩을 위해 사용될 수 있고, 이로써 에러 신드롬 정보에 대한 결함 허용 및 에러 정정 디코딩이 구현될 수 있다는 것이 또한 예상된다. 본 출원에서는, 결함 허용 및 에러 정정 디코딩 문제를 복수의 분류 문제들로 대략적으로 변경하기 위해 엄격한 수학적 프레임워크가 구축되고, 에러가 발생한 포지션을 로케이팅하고 분류 결과에 따라 에러 부류를 결정하는 방법이 제공된다. 이러한 분류 문제들은 동시에 병렬로 수행될 수 있고, 거의 동일한 시간이 소비될 수 있고, 이로써 더 이상 지연들을 초래하지 않는다. 이론 프레임워크에 기반하여, 결함 허용 및 에러 정정 동안 디코딩 을 위해 뉴럴 네트워크 디코더(입력된 에러 신드롬 정보는 3차원 데이터 어레이임)가 사용되는 특정 프로토콜이 제안되고, 에러 정정의 결함 허용이 입증된다. 도 3은 본 출원의 실시예에 따른 해결책의 적용 시나리오의 개략도이다. 도 3에 도시된 바와 같이, 적용 시나리 오는 초전도 양자 컴퓨팅 플랫폼일 수 있다. 적용 시나리오는, 양자 회로, 희석식 냉동기(dilution refrigerator), 제어 디바이스 및 컴퓨터를 포함한다. 양자 회로는 물리적 큐비트들에 대해 작용하는 회로이고, 양자 칩, 예컨대 절대 영도(absolute zero) 부근 에 로케이팅된 초전도 양자 칩으로서 구현될 수 있다. 희석식 냉동기는 초전도 양자 칩에 대해 절대 영도의 환경을 제공하도록 구성된다. 제어 디바이스는 양자 회로를 제어하도록 구성되고, 컴퓨터는 제어 디바이스를 제어하도록 구 성된다. 예컨대, 프로그래밍된 양자 프로그램은 컴퓨터 내의 소프트웨어를 사용하여 명령으로 컴파일되고 제어 디바이스에 전송되며, 제어 디바이스는 명령을 전자/마이크로파 제어 신호로 변환하고 전자/마이 크로파 제어 신호를 희석식 냉동기에 입력하여 10mK에서 초전도 큐비트들을 제어한다. 판독 프로세스는 위 의 것과 반대이다. 도 4에 도시된 바와 같이, 본 출원의 이 실시예에 제공되는 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법은 제어 디바이스와 결합될 필요가 있다. 양자 회로로부터 에러 신드롬 정보를 측정한 후에, 제어 디바이스의 메인 제어 시스템(33a)(예컨대, 중앙 보드 FPGA)은 제어 디바이스의 에러 정정 모듈(33b)에 에러 정정 명령을 전송한다. 에러 정정 명령은 양자 회로의 에러 신드롬 정보를 포함한다. 에러 정정 모듈 (33b)은 FPGA 또는 ASIC 칩일 수 있다. 에러 정정 모듈(33b)은, 에러 신드롬 정보를 디코딩하기 위해 결함 허용 및 에러 정정 디코딩 알고리즘을 실행하고, 디코딩을 통해 획득된 에러 결과 정보를 실시간 방식으로 에러 정정 제어 신호로 변환하고, 에러 정정 제어 신호를 에러 정정을 위해 양자 회로에 전송한다. (뉴럴 네트워크 분류기로서 지칭될 수 있는) 뉴럴 네트워크 디코더는, 에러 신드롬 정보를 디코딩하는 데 사용 될 수 있다. 본 출원에서 제공되는 결함 허용 및 에러 정정 디코딩의 프레임워크 프로토콜에 기반하여, 결함 허 용 및 에러 정정 디코딩을 완료하기 위해, 적절한 뉴럴 네트워크 분류기가 실제 상황에 따라 자유롭게 선택될 수 있다. 다음의 소개를 용이하게 하기 위해, 신드롬들이 퍼펙트한 경우 최적의 디코딩 알고리즘이 본원에서 먼저 소개된 다. 에러 정정 코드로서, 에러가 발생한 후, 패리티 검사를 통해 에러 신드롬들이 획득될 수 있다. 에러 정정 코드들에 대한 특정 디코딩 알고리즘을 사용하여 에러 신드롬들에 따라 에러가 발생하는 포지션 및 에러 부류가 결정된다. 다시 말해서, 디코딩 프로세스는 다음과 등가일 수 있다: 에러 발생 모델(큐비트들 상에서 발생하는 에러들의 확률 분포), 및 단일 퍼펙트 신드롬 측정에 의해 획득된 신드롬들이 제공되고, 발생할 가장 가능성이 높은 에러가 추론된다. 잡음이 없는 에러 신드롬의 경우, 최대 사후(MAP: maximum a posterior) 알고리즘이 존 재하며, 이는 또한 최적의 알고리즘이다. MAP 알고리즘은 본 출원에서 제공되는 결함 허용 및 에러 정정 디코딩 프레임워크의 출발점이다. S는 QEC 코드 의 스태빌라이저 그룹으로서 정의되고, L은 n-큐비트 파울리 그룹에서 S의 노멀라이저 서 브부류(normalizer subclass)로서 정의된다. 발생하는 임의의 파울리 에러(E)의 경우, 파울리 에러(E)는 다음과 같이 분할된다:"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "여기서 은 노멀라이저 서브부류(L)에 속하며 E의 함수이고, S(E)는 에러의 신드롬(E)이며 에러 신드롬 에 따라 맵핑된 에러이고, 맵핑은 에러 세트를 생성하며, 이는 신드롬 세트와의 일대일 대응이고; T(S(E))는 심 플 디코딩(simple decoding)으로 지칭되고, 에러 세트의 엘리먼트들은 심플 에러들로 지칭된다. T(S(E))의 선택 은 큰 임의성(arbitrariness)을 갖는다. 다른 에러(E')의 경우, E와 E'가 동일한 에러 신드롬을 갖는 경우, 이다. L(E') 및 L(E)가 동일한 노멀라이저 서브부류(L)에 속한다면, 2개의 에러들은 스태빌라이저 그룹에서 하나의 엘 리먼트 만큼만 상이하다. 즉, 인코딩 공간에 대한 2개의 에러들의 함수들은 등가이다. E를 정정하기 위해 E'가 선택될 수 있다(즉, 실제 발생하는 에러는 E이지만, E 및 E'가 등가이기 때문에, E'에 따라 실제로 에러 정정이 수행될 수 있고, 동일한 효과가 획득된다). 표면 코드에 의해 표현되는 토폴로지 QEC 코드의 경우, 상이한 노멀 라이저 서브부류들(L)은 연산자들이 속하는 상이한 토폴로지 상동 부류들을 표현한다. 토폴로지 에러 정정 코드 들의 경우, \"상동 부류\" 또는 \"에러 부류\"와 같은 용어들은 하기에서 노멀라이저 서브부류를 표현하는 데 사용 된다. 상동 부류에 속하는 에러들은 임의의 에러 신드롬을 생성하지 않아(에러 신드롬들은 모두 0임), 논리 에 러들 및 에러들의 부류는 등가이다. 그 이유는, 상동 부류 에러의 원인이 수학적으로 논리 에러이기 때문이다. 인코딩 공간에서 논리 에러가 발생하는 경우, 논리 에러에 대한 신드롬 측정의 결과들은 모두 0이다. 이러한 방식으로, 발생하는 에러(E)가 주어지면, MAP 디코더의 추론 프로세스는 다음과 같이 표현될 수 있다:"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "즉, 심플 에러들이 제거된 후에, 에러가 속할 가장 가능성 있는 노멀라이저 서브부류만이 결정될 필요가 있고, 그런 다음, 이 부류 내의 임의의 엘리먼트를 선택하고 엘리먼트를 심플 디코더의 출력 에러와 곱함으로써, 정정 될 필요가 있는 에러가 획득될 수 있다. 표면 코드의 경우, 노멀라이저 서브부류에 대응하는 3개의 부류들은 논 리적 큐비트들의 3개의 연산자들(X, Y, 및 Z) 및 연산자들(X, Y, 및 Z)과 등가인 연산자들의 세트이다. 고성능 을 갖는 뉴럴 네트워크 분류기를 사용함으로써, (최적의 해결책에 근사화하는) 효과적인 해결책이 제공될 수 있다. 상동 부류( )가 매우 높은 정확도로 추정된 후에, 에러 신드롬들은 퍼펙트하기 때문에, 심플 에러 (T(S(E)))가 즉시 획득될 수 있고, 의 임의의 엘리먼트 가 곱해져, 정정될 필요가 있는 에러가 획득된다:"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "(이 공식은 “공식 1”로 기록된다). 일반적인 에러 정정 코드와 비교하여, 표면 코드의 에러 및 신드롬 둘 모두는 기하학적 의미를 갖는다. 표면 코 드의 경우, 에러 정정 프로세스의 에러가 고려되지 않으면, 에러 신드롬 정보는 0과 1을 포함하는 2차원 어레이 이미지로 여겨질 수 있다. 표면 코드의 경우, 에러 정정은, 신드롬들의 포지션들에 기반하여, 에러가 발생하는 포지션 및 에러 부류를 결정하는 것이다. 아래에서 작성의 용이함을 위해, 기하학적 의미를 갖는 심플 디코더들 의 타입이 본원에서 도입되며, 이는 \"최소 경계 거리(minimum boundary distance)\" 디코더들로 지칭된다. 표면 코드의 패리티 검사 연산자들은 각각 X 에러들 및 Z 에러들을 검출한다. 2개의 부류들의 에러들이 대칭적이기 때문에, 이들 중 단지 하나만이 고려된다. Z 에러들이 고려되는 것으로 가정된다. 회전된 표면 코드의 경우, 1 의 값을 갖는 임의의 신드롬 비트는 하나의 X 연산자 체인(에러 체인)에 의해 생성되는 것으로 고려되고, 체인 은 신드롬 포인트를 2개의 경계들 중 어느 하나에 연결한다. 체인들 내의 경계까지의 최단 거리를 갖는 체인이 선택되고, 신드롬 포인트에 대응하는 심플 에러가 기록된다. 도 5는 단일 신드롬 포인트에 대응하는 심플 에러 의 개략도이다. 도 5에서, 흑색 도트는 1의 값을 갖는 단일 신드롬 비트를 표현하고, 직선은 X-타입 심 플 에러 체인을 표현한다. 에러 체인은 신드롬 포인트를 경계에 연결하는 최단 거리이다. L×L의 회전된 표면 코드의 경우, X 에러들에 대해, 1의 값을 갖는 (L2-1)/2 신드롬들은 \"최소 경계 거리\" 디코더를 사용하여 디코 딩될 필요가 있고, 신드롬들에 대응하는 심플 에러들이 다음과 같이 기록된다:"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "그런 다음, 신드롬 이 측정되는 경우, 심플 디코더의 디코딩 입력은 , 즉, 1의 신드롬 비트를 갖는 모든 심플 에러들의 곱으로서 정의된다. 유사하게, Z 에러들의 경우, 1의 값을 갖는(L2- 1)/2 신드롬들이 또한 \"최소 경계 거리” 디코더를 사용하여 디코딩될 필요가 있고, 신드롬들에 대응하는 심플 에러들이 기록된다. 마지막으로, (L2-1) 세트들의 맵핑 관계들을 포함하는 맵핑 테이블이 구축되고, 맵핑 관계의 각각의 세트는 하나의 에러 신드롬 포인트와 하나의 심플 에러 사이의 맵핑 관계를 포함한다. 심플 디코딩 프로 세스들은 병렬로 수행될 수 있고, 실제 상황에서, 시간 복잡성은 O일 수 있다. 실제 시나리오에서 QEC의 경우, 스태빌라이저 생성자들을 위한 모든 신드롬 측정 회로들은 잡음에 의해 간섭될 수 있다. 도 6은 신드롬 측정 회로가 잡음을 포함하는 경우의 에러 신드롬 분포의 개략도이다. 도 6에서, 백색 포인트 는 1의 측정 값을 갖는 에러 신드롬을 표현하며 정확하게 측정되고, 그리고 흑색 포인트는 1의 측정 값 을 갖는 에러 신드롬을 표현하며 틀리게 측정된다. 하부 좌측 코너에서 중앙에 백색을 갖는 흑색 포인트는, 1이 측정될 것이지만 결과적으로는 0이 측정됨을 표현한다. 하나의 부정확한 신드롬 포인트만이 존재하더라도, 처참한 결과가 야기될 것이다. 부정확한 신드롬 포인트에 따라 디코딩 및 에러 정정을 수행하는 것은, 많은 수 량의 에러들을 야기하고, 결과적으로 에러 정정 코드의 에러 정정 능력을 즉시 능가한다. 따라서, 임의의 신드 롬 측정의 결과는 신뢰할 수 없다. 이에 대응하여, 복수의 신드롬 측정들이 수행될 필요가 있다. 결함 허용 및 에러 정정의 유효성을 보장하기 위해, T = O(L) 측정들의 에러 신드롬 정보가 수집되며; 그리고 발생하는 에러 의 포지션 및 부류가 신드롬들을 이용하여 함께 추론되어 에러 정정이 수행된다. 도 7은 3차원 신드롬 분포의 개략도이며, 여기서 세로 방향 (longitudinal direction)은 시간을 나타낸다. 이는, 0과 1을 포함하는 3차원 데이터 어레이로 여겨질 수 있다. 총 4개의 슬라이스들이 도 7에 포함되고, 각각의 슬라이스는 하나의 측정을 통해 획득된 에러 신드롬 정보를 표현한다. 라인은 Z 에러에 의해 야 기된 신드롬들을 표현하고, 라인은 X 에러에 의해 야기된 신드롬들을 표현하고, 라인은 측정 에러를 표 현한다. 결함 허용의 경우, 시공간 에러(spatiotemporal error)들의 임의의 분포는, 시점(ti)에서 발생하는 등가 데이터 에러(equivalent data error)들, 및 시점(tj) 내지 시점(tj+1)에서 발생하는 등가 측정 에러들의 그룹과 최종적으로 등가일 수 있다. 도 8에 도시된 바와 같이, 1의 값을 갖는 신드롬 포인트들은 3차원 공간에서 체인들(도 8 에 도시된, 슬래시들을 갖는 라인 세그먼트들)을 형성한다. MWPM(minimum weight perfect matching) 연결 이 라인 세그먼트들의 종점들을 취함으로써 수행되는 경우, 연결을 통해 형성된 에러 체인은, 상이한 시간"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "에 발생하는 측정 에러 및 데이터 큐비트 에러들을 동시에 로케이팅하고, 요약을 만들어 에러 정정을 수행하는 데 사용될 수 있다. 도 8에 도시된 바와 같이, 종점들에 연결된 포인트들을 갖는 라인 세그먼트들은 발 생하는 에러들을 표현한다. 수평 방향으로 있는 포인트들을 갖는 라인 세그먼트는 데이터 에러를 표현하고, 수직 방향으로 있는 포인트들을 갖는 라인 세그먼트는 측정 에러를 표현한다. MWPM 디코더의 작업들은 비교 적 긴 시간을 소비하며, 작업들이 완전히 병렬화되더라도, O(L6)의 시간 복잡성도 여전히 요구된다. 그러나, FTQC가 수행되는 경우, 양자 회로는 실시간으로 에러 부류를 변경하고, 상이한 시간 및 공간에서 발생하는 에러 들은 신드롬 정보에만 기반하여 정확하게 추적 및 로케이팅될 수 없다. QC가 원활하게 진행될 수 있게 하기 위 해, 디코딩은 에러 신드롬들이 획득된 직후에 수행될 필요가 있고, 에러 정정은 양자 알고리즘의 각각의 컴퓨테 이션 단계가 수행되기 전에(또는 그 다음 라운드의 에러 정정이 시작되기 전에) 완료될 필요가 있으며, 이는 실 시간 에러 정정으로 지칭된다. 실시간 에러 수정은 QEC 코드들에 대한 디코딩 알고리즘의 런타임 마진에 대한 매우 엄격한 요건들을 제기하지만, MWPM 디코더는 실시간 에러 수정에 대한 오건들을 충족할 수 없다. QEC 디코딩을 수행하기 위해 뉴럴 네트워크 디코더를 사용하려는 시도가 있었다. 뉴럴 네트워크 디코더는 논리 에러 부류들(상동 부류들)을 분류하는 데 능숙하다. 다음의 문제들이 본원에서 도입된다: 1. 라운드의 T = O(L) 신드롬 측정들이 수행되기 전에, 이전에 발생한 모든 에러들은 가능한 한 많이 제거될 필 요가 있다. 이러한 방식으로, T = O(L) 신드롬 측정들의 라운드를 통해 획득된 에러 신드롬 정보는, 마지막 시 간 및 공간으로부터의 나머지 로컬화 에러, 이 시간 및 공간에서 발생하는 데이터 큐비트들의 에러, 및 보조 큐 비트들에 대한 에러 측정에만 의존한다. 2. 수행될 분류가 결정될 필요가 있다. 에러 신드롬 정보가 퍼펙트한 경우, 실제 에러들에서 심플 에러들이 제 거된 후 남은 에러가 속하는 상동 부류가 결정될 필요가 있는데, 즉, 신드롬들에 따른 분류를 수행할 필요가 있 다. 결함 허용 및 에러 정정의 경우, 에러들은 상이한 시간 기간들에서 발생하지만, 실제로 양자 상태에 영향을 미치는 것은 최종 시간에서의 실제 데이터 에러들의 누적, 즉 에러 정정이 발생하기 전의 총 에러이다. 도 8이 예로 사용된다. 시점(t7)에서의 모든 에러들의 투영 전체성(totality of projections)이 우려되므로, 자연 선택 (natural selection)은, 모든 신드롬들에 따라, 데이터 큐비트들 상에서 발생하며 시점(t7)에 남아있는 모든 에 러들을 분류하는 것이다. 3. 에러 포지션의 최종 결정. 공식 1에 따르면, 최종 시간에서의 에러가 결정되는 상동 부류가 결정되더라도, 실제 디코딩을 위해서는 신뢰할 수 있는 에러 신드롬이 여전히 요구된다. 사용된 신드롬 포인트가 잘못된 값을 가지면, 잘못된 신드롬 포인트 값에 대해 대응하는 에러 체인이 사용된다. 모든 에러 체인들이 비로컬 (nonlocal)(이는 L의 증가와 함께 증가함)이기 때문에, 임의의 부정확한 신드롬 비트에 대해, 에러 정정 후에, 실제로 발생하는 에러가 정정될 수 없을뿐만 아니라, 많은 수량의 에러들이 야기된다. 이러한 에러들은 빠르게 누적된다. 최악의 상황에서, 그러한 에러 정정의 라운드 후에, 에러들의 누적 수량은 큰 확률로 표면 코드의 에 러 정정 능력을 능가한다. 그러한 에러 정정 프로세스는 에러를 정정할 수 없지만, 저장된 양자 상태를 더 신속 하게 손상시킨다. 4. 시점(t7)에서 상이한 비트-측정 에러 시공간 분포들의 투영 전체성은, 단지 제한된 로컬화들만이 에러들 간에 상이하더라도, 동일한 신드롬 분포를 생성할 수 있다. 최종 에러들은 완전히 상이한 상동 부류들 및 신드롬들을 가질 수 있지만, 최종 에러들에 의해 발생된 3차원 에러 신드롬 분포들은 동일하다. 이러한 방식으로, 무작위로 발생된 에러는 최종 시간에 직접 투영되는 데 사용될 수 없으며, 이후, 에러 신드롬 데이터에 대응하도록 상동 부류가 추출된다(동일한 수량의 입력 트레이닝 데이터는 복수 개의 상이한 라벨들에 대응함). 전술한 분석에 기반하여, 다음의 결론이 얻어질 수 있다: 1. 특정적으로 발생하는 에러에 분류 정보가 맵핑되는 경우, 이는 단일 시점에서의 신뢰할 수 없는 신드롬들에 의존할 수 없지만, 전체 O(L3) 시간 및 공간의 신드롬들에 의존할 필요가 있다. 2. 3차원 신드롬들이 사용되더라도, 이 문제는 여전히 심플 상동 부류 분류 문제로 변환될 수 없다. 명백히, 이는 공식 1을 사용하여 설명될 수 없으며, 전술한 문제를 해결하기 위해 새로운 방법이 제공될 필요가 있다. 첫째, 시간 및 공간에서 모든 부류들의 에러들과 신드롬들 사이의 관계가 관찰된다. 예컨대, 2개의 부류들의 에 러들에 대한 신드롬 측정 회로들이 도 9에 각각 도시된다. 도 9에서의 (a) 부분은 Z 에러들을 검출하는 신드롬 측정 회로를 도시하고, 도 9의 (b) 부분은 X 에러들을 검출하는 신드롬 측정 회로를 도시한다. 2개 타입의 회로 들이 고정되며, 여기서, 회로들 내의 임의의 엘리먼트의 시간 및 대응하는 비트 시퀀스는 반전(reverse)될 수 없다. 보조 상태들 및 의 준비, CNOT(controlled-not), 큐비트들의 저장, 및 에러 신드롬 측정을 포함하는, 회로의 모든 엘리먼트들은 잡음에 의해 간섭된다(각각, 상태 준비 에러, 양자 게이트 에러, 내부 메모리 에러 및 측정 에러로 정의됨). 분석의 간결성을 위해, 모든 잡음, 이를테면 CNOT, 보조 상태들의 준비 및 보조 상태 들에 대한 측정은 회로들의 우측 단부들(도 9에서 백색 직사각형들로 표현된 부분들)에 등가적으로 전파된 다. 도 9에서의 (a) 부분에 도시된 회로의 경우, 잡음의 타입은 보조 큐비트들에 등가 Z 에러만을 생성할 수 있 으며; 유사하게, 도 9에서의 부분(b)에 도시된 회로의 경우, 잡음의 타입은 보조 큐비트들에 등가 X 에러만을 생성할 수 있다(이는 도 9에 도시된 회로들의 특정 레이아웃들에 의해 야기됨). 도 9에 도시된 회로들이 사용되 기 때문에, X 측정의 경우, X 에러는 영향력이 없고, 실제로는 오직 Z 에러만이 영향력을 발휘한다. 유사하게, Z 측정의 경우, Z 에러는 영향력이 없고, 실제로는 오직 X 에러만이 영향력을 발휘한다. 동시에, 등가 에러들 및 내부 메모리 에러(도 9에서 흑색 직사각형들로 표현된 부분들)이 결합되어 등가 데이터 에러를 형성한다. 등가 에러는 잡음을 갖는 측정 회로의 데이터 큐비트들에 있다. 내부 메모리 에러는 그 다음 측정 라 운드 이전의 데이터 큐비트들에 있다. 다시 말해서, 시간 계층들(ti 및 ti+1) 사이에서의 신드롬 값들은 대응하는 등가 데이터 에러와 대응하는 등가 측정 에러 사이의 공통 결과로서 고려될 수 있다. 등가 데이터 에러가 ti에서 발생하는 경우, 등가 측정 에러는 ti 내지 ti+1에서 발생하는 보조 큐비트들에 대한 측정 에러이다. 이러한 방식 으로, 도 8에 도시된 시공간 격자들은 모든 에러들 및 신드롬 이력을 표현하는 데 사용될 수 있다. 다음은, 실제 에러 증상 정보에 대응하는 상동 부류들만을 분류하는 것은 FTQEC를 수행하는 데 사용될 수 없음 을 설명하고, 그리고 실제 에러 증상 정보에 대응하는 상동 부류들은 트레이닝 데이터를 라벨링하는 데 사용될 수 없음을 설명한다. 예컨대, 여전히 X 에러들만이 고려되며, Z 에러들에 대한 논의는 동일하다. 도 8에 도시된 시공간 격자들이 예로 사용된다. t6 내지 t7의 신드롬 측정의 라운드가 완료된 후, t0 내지 t6의 모든 부류들의 에러들에 관한 정보를 표현하기 위해 모든 신드롬들의 이력이 획득될 수 있다. 하기에서 확인되는 바와 같이, 에러 정정 프로세스가 완전히 정확하다면, 이 기간에 데이터 큐비트들에 대해 발생하는 모든 등가 에러들의 영 향력은 원칙적으로 제거될 수 있다. 그러나, t7에서 발생하는 등가 데이터 에러들을 표현하기 위한 대응하는 신 드롬이 없으므로, 등가 데이터 에러들은 후속 에러 정정 단계로 유지된다(에러들은 자연적으로 발생하는 독립적 인 잡음에 의해 발생되므로, 비로컬 에러들이 아니며, 결함 허용을 손상시키지 않는다). 유사하게, t0에서 발생 하는 등가 에러들은 또한, O(L) 시간 에러 정정의 마지막 라운드로부터 남은 로컬 에러들로서 고려될 수 있다 (다른 에러들은 모두 마지막 라운드의 에러 정정 프로세스를 통해 정정됨). 다시 말해서, 매번 선택되는 신드롬 다이어그램 상의 에러들 및 대응하는 시공간 격자들은 반-개방 세트(이는 양(positive)의 시간 방향의 경계에 대해 개방됨)이다. 전체 반-개방 세트 시공간 매니폴드에서 발생하는 모든 등가 데이터 에러들(ED)의 최종 누적이 실제로 정정될 필요가 있다는 것, 즉, 최종 시간에 대한 투영이 필요하다는 것을 알 수 있다. 일단 시간 및 공간에서의 모든 등가 에러들(예컨대, 도 10에서의 회색 라인들)이 주어지면, (실제 데이터 큐비트들 상에서 발생하는 등가 에러를 반영하는지 여부에 관계없이) 모든 신드롬들이 결정된다. 이러한 신드롬들은 또한 실험적으로 측정될 수 있다(도 10에서의 (a) 부분에서 흑색 라인들). 먼저, 신드롬들이 퍼펙트한 경우를 모방함으로써, 심플 에 러 정정이 수행된다: 시간 및 공간에서 신드롬들의 종점들(도 10에서의 흑색 종점들)을 취한 다음, 각각의 종점에 대해, 이 종점을, 시공간 격자에서 그리고 시공간 격자가 속한 시간 계층 내에서, 샘플 에러(도 10에서 의 (b) 부분에서 파선)를 획득하기 위해 \"최소 경계 거리 정정\" 알고리즘을 실행하기 위해 1의 값을 갖는 신드롬 포인트로서 사용하고, 그리고 모든 획득된 심플 에러들을 결합 방식으로 ES로서 정의한다. 도 10에서의 회색 라인들 및 파선들은 신드롬 포인트들을 공유하여, 다양한 부류들의 에러 체인들을 형성하 며, 이들은 논의를 위해 본원에서 3개의 부류들로 분류된다: 1. 회색 라인과 파선에 의해 형성된 각각의 에러 체인의 시작점 및 종점은 동일한 공간 경계를 가지 며, 이 경우, 에러 체인은 자명 상동 부류(또는 \"0\" 부류)에 속하는 것으로 지칭된다. 이 부류의 에러 체인들의 세트는 로서 정의되고, 에러 체인들의 부류 내의 데이터 큐비트들에 작용하는 모든 에러들은 로서 정의 된다. 2. 회색 라인 및 파선에 의해 형성된 에러 체인은, 토폴로지 비-자명 상동 부류를 형성하기 위해, 하 나의 공간의 경계로부터 다른 경계와 통신한다. 이 부류의 에러 체인들의 세트는 로서 정의되고, 에러 체인들 의 부류 내의 데이터 큐비트들에 작용하는 모든 에러들은 로서 정의된다. 3. 회색 라인 및 파선에 의해 형성된 에러 체인의 경우, 일 단부는 시공간 격자의 양의 시간 경계에 서 끝나고, 다른 단부는 공간 경계에서 끝난다. 에러 체인들의 부류는 \"시공간적 비-폐쇄 에러 체인들\"로 지칭 될 수 있고, 에러 체인들의 부류의 세트는 로서 정의된다. 에러 체인들의 부류의 데이터 큐비트들에 작용하는 모든 에러들은 로서 정의되고, 본원에서의 은, 에러 체인들의 부류(에러들의 부류는 임의의 심플 디 코더에 대해 존재함)의 존재로 인해 최종 시간 이전에 등가 측정 에러들이 발생할 수 있는 모든 체인들을 포함 한다. 따라서, 심플 에러 정정 후에, 결함 허용 및 에러 정정 디코딩은 심플 3차원 상동 부류 분류 문제에 통합 될 수 없는데, 이는 체인이 시공간적 폐쇄 체인이 아니기 때문이다. 따라서, 공간에서의 상동 부류는, 체인이 제거된 후에 컴퓨팅될 수 있다. 시공간 에러 다이어그램은 양의 시간 방향에 대해 반-개방이기 때문에, 최종 시간 이전에 발생하는 측정 에러들 (심플 디코딩 후에 부류의 에러 체인이 야기됨)은 문제의 복잡성을 크게 증가시킨다. 본원에서의 주요 문제 들은 다음과 같다: 1. 상이한 상동 부류들의 생성된 에러들은 동일한 신드롬들을 생성할 수 있다. 예컨대, 최종 시간 이전의 동일 한 신드롬은 등가 측정 에러에 의해 야기될 수 있거나, 또는 등가 데이터 에러에 의해 야기될 수 있다. 이러한 상이한 에러들은 상이한 상동 부류들에 속한다. 에러들을 무작위로 생성함으로써 트레이닝 데이터가 생성되고, 상동 부류들이 컴퓨팅되고, 데이터가 입력된 3차원 신드롬들에 대응하는 라벨 들로서 사용되는 경우, 각각의 신 드롬은 다양한 상이한 라벨들에 대응한다(그리고 각각의 라벨에 대응하는 신드롬이 발생할 확률은 10배이다). 이러한 방식으로, 데이터는 상동 부류들에 대한 분류를 학습하기 위해 뉴럴 네트워크 모델을 트레이닝시키는 데 사용될 수 없다. 2. 무작위로 생성된 에러의 데이터를 강제로 사용함으로써 분류가 수행되는 경우, L2 파라미터들을 총계로 포함 하는 에러의 상동 부류와 퍼펙트 에러 신드롬이 동시에 사용될 필요가 있고; L2 파라미터들은 특정 입력 신드롬 들에 대해 고정된다. 과 같은 잠재적인 상이한 라벨들이 존재한다. 분명히, 너무 많은 라벨들을 사용하는 것은 비실용적이다. 3. 부가하여, 최종 에러의 퍼펙트 신드롬이 추가로 요구된다. 상동 부류와 유사하게, 상이한 최종 에러들은 상 이한 퍼펙트 신드롬들을 갖지만, 동일한 3차원 신드롬을 생성할 수 있다. 따라서, 마지막으로, 뉴럴 네트워크 모델은 우려되는 최종 에러 신드롬 정보를 학습하도록 트레이닝될 수 없다. 최종 시점에서 측정된 에러 신드롬 정보가 퍼펙트 에러 신드롬 정보이고, 그리고 퍼펙트 에러 신드롬 정보에 기 반하여, 뉴럴 네트워크 디코더를 위한 트레이닝 데이터세트가 생성된다고 가정하면, 데이터 라벨들의 불일치 문 제는 더 이상 존재하지 않는다. 이러한 접근법은 일부 적절성을 갖는다: 양자 상태 저장만이 수행되는 경우, 데 이터 큐비트들의 에러의 부류 및 포지션이 실시간으로 알려질 필요가 없다. 상태가 최종적으로 판독될 때 에러 신드롬 정보가 퍼펙트하다고 가정될 수 있다. 그러나, 트레이닝을 통해 획득된 이러한 타입의 뉴럴 네트워크 디 코더는, QC에서 실시간 에러 정정 디코딩 문제를 프로세싱할 수 없고(왜냐하면, QC에서, 일부 단계들 전에, 에 러가 발생하는 포지션 및 에러 부류가 즉시 알려질 필요가 있고, 에러는 정정될 필요가 있기 때문임), QC에서 실제로 사용될 수 없다. 도 11은 본 출원의 실시예에 따른, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법의 흐름도이다. 방법 이 도 3에 도시된 적용 시나리오에서 제어 디바이스에 적용되는 예가 사용된다. 방법은 다음의 단계들을 포함할 수 있다.단계: 양자 회로의 실제 에러 신드롬 정보를 획득하며, 실제 에러 신드롬 정보는 QEC 코드를 사용하여 양 자 회로에 대해 잡음성 에러 신드롬 측정을 수행함으로써 획득된 정보이다. QEC 코드를 사용하여 양자 회로에 대해 에러 신드롬 측정을 수행함으로써, 대응하는 에러 신드롬 정보가 획득될 수 있다. 에러 신드롬 정보는 QEC 코드의 스태빌라이저 생성자들의 고유값들에 의해 형성된 데이터 어레이이다. 예시적으로, 에러 신드롬 정보는 0들 및 1들로 구성된 2차원 또는 3차원 데이터 어레이이다. 예컨대, 에러가 없 을 때, 스태빌라이저 생성자들의 고유값들은 0이고; 에러가 발생할 때, 일부 스태빌라이저 생성자들의 고유값들 은 1이다. 실제 시나리오에서, QEC 코드를 사용하여 양자 회로상에서 수행되는 에러 신드롬 측정은 잡음을 포함 하는데, 즉 측정 에러가 존재한다. 따라서, 본원에서 실제 에러 신드롬 정보는 실제 시나리오에서 측정된 잡음 을 갖는 에러 신드롬 정보를 지칭한다. QEC 코드가 표면 코드인 예가 사용된다. 표면 코드의 경우, 에러 및 에러 신드롬은 특정 공간 포지션들을 갖는 다: 에러가 신드롬을 야기하는 경우, 대응하는 포지션에서 보조 큐비트의 고유값은 1이고; 그리고 에러가 없을 경우, 대응하는 포지션에서 보조 큐비트의 고유값은 0이다. 따라서, 표면 코드의 경우, 에러 정정 프로세스의 에러가 고려되지 않으면(즉, 측정 프로세스가 퍼펙트하면), 에러 신드롬 정보는 0들 및 1들로 구성된 2차원 데 이터 어레이로서 간주될 수 있다. 예를 들어, 도 12는 에러 신드롬 정보의 2차원 데이터 어레이의 개략도 이며, 여기서 0은 에러가 없음을 지시하고, 1은 에러가 존재함을 지시한다. 부가하여, 결함 허용 및 에러 정정의 유효성을 보장하기 위해, 획득된 실제 에러 신드롬 정보는 T개의 데이터 어레이들을 포함할 수 있고, 여기서 각각의 데이터 어레이는 QEC 코드를 사용하여 양자 회로에 대해 잡음성 에 러 신드롬 측정을 수행함으로써 획득되고, T는 1보다 큰 정수이다. 위에서 설명된 바와 같이, T = O(L), 여기서 L은 QEC 코드의 스케일이다. 이러한 방식으로, 각각의 에러 신드롬 측정을 통해 획득된 실제 에러 신드롬 정보 는 (L+1) ×(L+1)의 2차원 데이터 어레이(머신 학습을 가능하게 하기 위해, 각각의 시점에서의 신드롬 경계는 적절하게 확장됨)일 수 있고, 그리고 T개의 에러 신드롬 측정들을 통해 획득된 실제 에러 신드롬 정보는 (L+1) ×(L+1)×T의 3차원 데이터 어레이를 형성할 수 있다. 예를 들어, 도 13은 에러 신드롬 정보의 3차원 데이터 어 레이의 개략도이며, 여기서 0은 에러가 없음을 지시하고, 1은 에러가 존재함을 지시한다. 단계: 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 획득하기 위해, 실제 에러 신드롬 정보를 디코딩한다. 논리 에러 부류들은 양자 회로에서 발생하는 에러들의 맵핑을 통해 획득된 부류들이다. 논리 에러 부류들은 또 한, 다음의 4개의 부류들: I, X, Y 및 Z를 포함하는 상동 부류들로 지칭될 수 있다. I는 에러가 없음을 지시하 고, X는 X 에러를 표현하고, Z는 Z 에러를 표현하고, Y는 X 에러 및 Z 에러 둘 모두가 있음을 지시한다. 각각의 논리 에러 부류는 적어도 하나의 등가 에러 엘리먼트를 포함한다. 선택적으로, 각각의 논리 에러 부류는 복수의 등가 에러 엘리먼트들을 포함한다. 논리 에러 부류 I의 엘리먼트들은 스태빌라이저 그룹의 엘리먼트들이다. 논 리 에러 부류 X의 엘리먼트들은 논리 X 연산자를 스태빌라이저 그룹의 엘리먼트들로 각각 곱함으로써 획득된 엘 리먼트 세트이다. 논리 에러 부류 Y의 엘리먼트들은 논리 Y 연산자를 스태빌라이저 그룹의 엘리먼트들로 각각 곱함으로써 획득된 엘리먼트 세트이다. 논리 에러 부류 Z의 엘리먼트들은 논리 Z 연산자를 스태빌라이저 그룹의 엘리먼트들로 각각 곱함으로써 획득된 엘리먼트 세트이다. 동일한 논리 에러 부류에 속하는 엘리먼트들은 등가 이다. 예컨대, 실제로 발생하는 에러 E 및 다른 에러 E'가 동일한 논리 에러 부류에 속하면, 에러 E에 대한 에 러 정정은 에러 E'에 대한 에러 정정과 동일하며, 즉, 동일한 효과가 달성될 수 있다. 퍼펙트 에러 신드롬 정보는 양자 회로에 대해 무-잡음 에러 신드롬 측정을 수행함으로써 획득된 정보이다. 본 출원의 이러한 실시예에서, 실제 에러 신드롬 정보를 디코딩하기 위해, 대응하는 논리 에러 부류가 획득될 필요 가 있을뿐만 아니라, 대응하는 퍼펙트 에러 신드롬 정보가 획득될 필요가 있다. 이러한 방식으로만, 양자 회로 의 에러 결과 정보가 위에서 설명된 공식 1에 따라 최종적으로 결정될 수 있다. 예를 들어, 도 14는 퍼펙트 에 러 신드롬 정보의 개략도이다. 도 14에서, 흑색 도트들은 데이터 큐비트들을 표현하고, 십자형들은 보조 큐비트들을 표현한다. 보조 큐비트들 상에서 발생하는 에러들은 퍼펙트 신드롬 측정에 영향을 미치지 않으 며, 에러들은 도면에서 X, Y, 및 Z로 마킹된다. 부가하여, 실제 에러 신드롬 정보는 뉴럴 네트워크 디코더를 사용하여 또는 임의의 다른 적절한 디코더를 사용 하여 디코딩될 수 있으며, 이는 본 출원의 실시예들로 제한되지 않는다. 뉴럴 네트워크 디코더는, 뉴럴 네트워 크에 기반하여 구축되고 에러 신드롬 정보를 디코딩하도록 구성된 머신 학습 모델이다. 뉴럴 네트워크 디코더가 실제 에러 신드롬 정보를 디코딩하는 데 사용되는 경우, 뉴럴 네트워크 디코더의 입력 데이터는 실제 에러 신드 롬 정보를 포함하고, 뉴럴 네트워크 디코더의 출력 데이터는 논리 에러 부류 및 퍼펙트 에러 신드롬 정보(실제에러 신드롬 정보에 대응함)를 포함한다. 부가하여, 디코딩을 통해 논리 에러 부류를 획득하도록 구성된 뉴럴 네트워크 디코더, 및 디코딩을 통해 퍼펙트 에러 신드롬 정보를 획득하도록 구성된 뉴럴 네트워크 디코더는 동 일한 또는 상이한 뉴럴 네트워크 디코더들이다. 예시적인 실시예에서, 도 15에 도시된 바와 같이, 단계는 다음의 단계들(1102a 및 1102b)로 대체되어 구 현될 수 있다: 단계(1102a): 실제 에러 신드롬 정보에 대응하는 논리 에러 부류를 획득하기 위해, 제1 디코더를 사용하여 실제 에러 신드롬 정보를 디코딩하며, 제1 디코더는 논리 에러 부류를 결정하도록 구성된 뉴럴 네트워크 분류기이다. 본 출원의 이 실시예에서, 실제 에러 신드롬 정보에 대응하는 논리 에러 부류는 트레이닝된 제1 디코더를 사용 하여 예측된다. 일부 실시예들에서, 제1 디코더들의 수는 1이고, 제1 디코더는 4-부류 분류 모델이다. 제1 디코 더의 출력은 4개의 논리 에러 부류들, 즉, I, X, Y, 및 Z를 포함한다. 제1 디코더는, 완전 연결 네트워크, CNN, RNN, 또는 다른 뉴럴 네트워크들에 기반하여 구축된 분류 모델일 수 있으며, 이는 본 출원의 실시예들에서 제한 되지 않는다. 일부 실시예들에서, 실제 에러 신드롬 정보는 적어도 2개의 블록들을 획득하기 위해 제1 디코더를 사용하여 파 티셔닝되고; 피처 추출은 피처 정보를 획득하기 위해 적어도 2개의 피처 추출 유닛들을 사용하여 병렬로 적어도 2개의 블록들에 대해 수행되고; 그리고 실제 에러 신드롬 정보에 대응하는 논리 에러 부류를 획득하기 위해, 제 1 디코더를 사용하여 피처 정보에 대해 융합 디코딩(fusion decoding)이 수행된다. 단계(1102b): 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보를 획득하기 위해, 제2 디코더를 사용 하여 실제 에러 신드롬 정보를 디코딩하며, 제2 디코더는 퍼펙트 에러 신드롬 정보를 결정하도록 구성된 뉴럴 네트워크 분류기이다. 본 출원의 이 실시예에서, 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보는 트레이닝된 제2 디코 더를 사용하여 예측된다. 일부 실시예들에서, 제2 디코더들의 수는 하나 이상이다. 선택적으로, 제2 디코더들의 수는 k이고, 여기서 k는 양의 정수이고, QEC 코드의 스케일과 관련된다. QEC 코드가 L의 스케일을 갖는 스태빌 라이저 코드라고 가정하면, 제2 디코더들의 수는 k = L2-1이다. 이 경우, 제2 디코더는 이진 분류 모델(binary classification model)일 수 있으며, 그 출력은 분류될 필요가 있는 2개의 에러 신드롬 값들, 즉 0 및 1을 포함 하며, 여기서 0은 에러가 없음을 지시하고, 1은 에러가 있음을 지시한다. 전술한 단계들(1102a 및 1102b)은 순차적으로 또는 병렬로 수행될 수 있으며, 2개의 단계들의 병렬 실행은 프로 세스들을 실행하는 데 필요한 시간을 단축시키는 것을 돕는다. 실시간 결함 허용 및 에러 정정 디코딩을 달성하 기 위해, 병렬 실행을 완료하기 위해 가능한 한 많은 디바이스들 및 적절한 통신 연결들이 선택되어야 한다. 예시적인 실시예에서, 도 16에 도시된 바와 같이, 단계(1102b)는 다음의 단계들로 대체되어 구현될 수 있다: 단계(1102b-1): k개의 퍼펙트 에러 신드롬 비트들을 획득하기 위해, 실제 에러 신드롬 정보를 k개의 제2 디코더 들에 각각 입력한다. 단계(1102b-2): 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보를 획득하기 위해, k개의 퍼펙트 에 러 신드롬 비트들을 통합한다. 각각의 제2 디코더는 하나의 신드롬 측정 포지션에서 퍼펙트 에러 신드롬 비트를 출력하도록 구성된다. k개의 제2 디코더들의 출력 결과들을 통합함으로써, 모든 신드롬 측정 포지션들에서의 퍼펙트 에러 신드롬 비트들, 즉, 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보가 획득될 수 있다. 도 17에 도시된 바와 같이, 실제 에러 신드롬 정보에 대응하는 3차원 데이터 어레이는 각각 제1 디코더 및 제2 디코더들에 입력되고; 제1 디코더는 실제 에러 신드롬 정보에 대응하는 논리 에러 부류 를 출력하고; 제2 디코더들은 퍼펙트 에러 신드롬 비트들을 출력하고; 제2 디코더들에 의해 출 력된 퍼펙트 에러 신드롬 비트들이 통합되어, 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보(17 5)가 획득되고; 마지막으로, 양자 회로의 에러 결과 정보가 논리 에러 부류 및 퍼펙트 에러 신드롬 정보에 따라 결정된다. 부가하여, 제2 디코더는, 완전 연결 네트워크, CNN, RNN, 또는 다른 뉴럴 네트워크들에 기반하여 구축된 분류 모델일 수 있으며, 이는 본 출원의 실시예들에서 제한되지 않는다. 제1 디코더 및 제2 디코더의 모델 구조들은 동일하거나 상이할 수 있으며, 모델들의 깊이들은 최대 병렬화를 달 성하기 위해 가능한 한 일관적일 필요가 있다. 단계: 논리 에러 부류 및 퍼펙트 에러 신드롬 정보에 기반하여 양자 회로의 에러 결과 정보를 결정하며, 에러 결과 정보는 양자 회로에서 에러가 발생하는 데이터 큐비트 및 대응하는 에러 부류를 지시하는 데 사용된 다. 위에서 설명된 공식 1을 참조하면, 논리 에러 부류 및 퍼펙트 에러 신드롬 정보가 획득된 후, 대응하는 심플 에 러들은 퍼펙트 에러 신드롬 정보에 따라 결정될 수 있다. 그런 다음, 심플 에러들을 논리 에러 부류의 임의의 엘리먼트와 곱함으로써, 정정될 필요가 있는 에러, 즉, 양자 회로의 에러 결과 정보가 획득될 수 있다. 양자 회로에서 에러가 발생하는 데이터 큐비트 및 대응하는 에러 부류는, 양자 회로의 에러 결과 정보에 기반하 여 결정될 수 있다. 예컨대, 양자 회로에서 에러가 발생한 데이터 큐비트의 포지션이 결정되고, 그 포지션에서 에러가 발생한 데이터 큐비트의 에러 부류가 결정된다. 예컨대, 에러가 X 에러인지, Z 에러인지, 또는 Y 에러인 지 여부가 결정된다. 예시적인 실시예에서, 도 15에 도시된 바와 같이, 단계는 다음의 단계들(1103a, 1103b, 및 1103c)로 대체 되어 구현될 수 있다: 단계(1103a): 논리 에러 부류에 대응하는 제1 에러 결과를 획득한다. 예시적인 실시예에서, 도 16에 도시된 바와 같이, 단계(1103a)는 전술한 단계에 의해 대체되어 구현될 수 있다: 단계(1103a-1): 논리 에러 부류에 포함된 엘리먼트들로부터의 임의의 엘리먼트를 제1 에러 결과로서 선택하며, 논리 에러 부류는 적어도 하나의 등가 에러 엘리먼트를 포함한다. 예컨대, 디코딩을 통해 획득된 실제 에러 신드롬 정보에 대응하는 논리 에러 부류가 X이면, 논리 에러 부류 X에 포함된 에러 엘리먼트들로부터의 임의의 엘리먼트가 제1 에러 결과로서 선택된다. 단계(1103b): 퍼펙트 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득한다. 디코딩을 통해 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보를 획득한 후, 심플 디코더를 이용하 여 퍼펙트 에러 신드롬 정보에 대응하는 제2 에러 결과가 획득될 수 있다. 예시적인 실시예에서, 도 16에 도시된 바와 같이, 단계(1103b)는 전술한 단계들로 대체되어 구현될 수 있다: 단 계(1103b-1): 퍼펙트 에러 신드롬 정보에서 각각 에러 신드롬 포인트들에 대응하는 심플 에러들에 대한 맵핑 테 이블을 검색하며, 맵핑 테이블은 에러 신드롬 포인트와 심플 에러 간의 적어도 한 세트의 맵핑 관계를 포함한다; 단계(1103b-2): 제2 에러 결과를 획득하기 위해, 각각 에러 신드롬 포인트들에 대응하는 심플 에러들 을 곱한다. 단계(1103c): 제1 에러 결과 및 제2 에러 결과에 기반하여 양자 회로의 에러 결과 정보를 결정한다. 예시적인 실시예에서, 도 16에 도시된 바와 같이, 단계(1103c)는 전술한 단계로 대체되어 구현될 수 있다: 단계 (1103c-1): 양자 회로의 에러 결과 정보를 획득하기 위해, 제1 에러 결과와 제2 에러 결과의 곱을 결정한다. 전술한 방식으로 논리 에러 부류로부터 역으로 유도된 에러는 데이터 큐비트 상에서 발생하는 등가 에러이다. 유도된 에러는, 원래 발생한 에러와 동일하지 않을 수 있지만, 동일한 효과를 가질 수 있다(또는 에러들 간의 차이는 로컬임). 부가하여, 전술한 단계들(1103a 및 1103b)은 순서대로 또는 병렬로 수행될 수 있으며, 2개의 단계들의 병렬 실 행은 프로세스들을 실행하는 데 필요한 시간을 단축시키는 것을 돕는다. 예시적으로, 도 16에 도시된 바와 같이, 양자 회로의 에러 결과 정보가 결정된 후에, 다음의 단계들이 추가로 수행될 수 있다: 단계: 에러 결과 정보에 기반하여 에러 정정 제어 신호를 생성하며, 에러 정정 제어 신호는 양자 회로에 서 발생하는 에러를 정정하는 데 사용된다. 단계: 에러 정정 제어 신호를 양자 회로에 전송한다. 예시적으로, 에러 정정 제어 신호는 마이크로파 제어 신호, 전자 제어 신호, 또는 임의의 다른 형태의 제어 신 호일 수 있으며, 이는 본 출원의 실시예들에서 제한되지 않는다. 에러 정정 제어 신호는 양자 회로에 전송되고, 그에 따라, 양자 회로는, 실시간 에러 정정의 목적을 달성하기 위해, 에러 정정 제어 신호에 기반하여, 양자 회로 상에서 발생하는 데이터 큐비트 에러를 정정한다. 위의 내용에 기반하여, 본 출원의 이 실시예에서 제공되는 기술적 해결책에서, 대응하는 논리 에러 부류 및 대 응하는 퍼펙트 에러 신드롬 정보를 획득하기 위해 양자 회로의 실제 에러 신드롬 정보를 디코딩한 다음, 논리 에러 부류 및 퍼펙트 에러 신드롬 정보에 따라 양자 회로에서 에러가 발생한 데이터 큐비트 및 대응하는 에러 부류를 결정함으로써, 본 출원은, 에러 신드롬 정보가 퍼펙트하지 않은 경우 양자 회로의 에러 신드롬 정보에 대한 결함 허용 및 에러 정정 디코딩을 달성한다. 부가하여, 본 해결책은 결함 허용 및 에러 정정 디코딩을 분류 문제로 등가적으로 변환하고, 이에 따라 효율적 인 뉴럴 네트워크 분류기를 사용하여 에러 신드롬 정보에 대해 결함 허용 및 에러 정정 디코딩이 수행될 수 있 고, 이로써 결함 허용 및 에러 정정 디코딩 속도를 개선하고, 그리고 실시간 결함 허용 및 에러 정정 디코딩을 달성한다. 적절한 뉴럴 네트워크 분류기가 선택되는 경우, 디코딩 알고리즘의 속도가 크게 개선될 수 있고, 이 로써, 실시간 결함 허용 및 에러 정정 디코딩의 구현의 발판이 마련된다. 전술한 실시예들은 뉴럴 네트워크를 사용하여 결함 허용 및 에러 정정 디코딩을 수행하기 위한 프레임워크를 제 공한다. 제1 디코더 및 제2 디코더의 트레이닝 프로세스는 아래에서 설명된다. 무작위로 생성된 에러들(내부 메모리 에러, 상태 준비 에러, 양자 게이트 에러, 측정 에러 등)은 트레이닝에 적 합한 샘플들을 생성하는 데 사용될 수 없기 때문에, 맵핑이 요구된다. 맵핑은 3차원 에러 신드롬 정보가 에러 (즉, 각각의 샘플)에 일대일 대응하게 한다. 이 에러와 3차원 신드롬 분포를 생성하는 임의의 최종 에러 사이의 차이가 로컬이라면, 이 에러가 실제 에러의 최종 맵핑과 완전히 등가일 필요는 없다. 로컬이라는 것은, 맵핑을 통해 획득된 에러와 실제 에러 사이에 n 개의 차이들이 존재하는 경우, 차이들의 부류가 발생할 확률이 O(pn)임 을 의미하며, 여기서 p는 대략적으로, 각각의 부류의 물리적 에러들이 발생할 확률이다. 이러한 방식으로, 각각 의 3차원 에러 신드롬 정보는 오직 하나의 결정된 에러, 즉, 고유하게 결정된 논리 에러 부류 및 고유하게 결정 된 퍼펙트 에러 신드롬들에 대응한다. 부가하여, 트레이닝 동안 데이터를 라벨링하기 위해 맵핑들의 부류가 수 반될 필요가 있기 때문에, 에러를 획득하기 위한 컴퓨테이션 시간은 수용가능해야 한다(적어도 L 지수로 증가될 수 없음). 이러한 조건들을 자연스럽게 충족시키는 맵핑은, 3차원 공간 MWPM 알고리즘 또는 심층 강화 학습 알고리즘과 같 은 결함 허용 디코딩 알고리즘을 사용하는 것이다. 알고리즘들의 부류는 데이터 에러들 및 측정 에러들의 시공 간적 분포를 제공한다. 맵핑을 통해 획득된 추정된 에러는 최종 시점에 투영되고, 그런 다음, 추정된 최종 에러 에 대응하는 논리 에러 부류 및 추정된 최종 에러에 대응하는 퍼펙트 에러 신드롬이 컴퓨팅될 수 있다. 이들 모 두는 트레이닝 라벨 들이며, 이후, 논리 에러 부류 및 각각의 획득된 퍼펙트 에러 신드롬 비트에 대해 뉴럴 네 트워크 모델이 설정된다. L의 스케일을 갖는 표면 코드가 예로 사용되며, 하나의 논리 에러 부류 및 L2-1 퍼펙 트 에러 신드롬 비트들이 존재할 수 있다. 따라서, 모델(즉, 위에서 설명된 제1 디코더)은 논리 에러 부류의 학 습을 위해 바인딩되고, 이후 L2-1 모델들(즉, 위에서 설명된 제2 디코더들은, 예컨대, (i, j)) 좌표들을 갖는 퍼펙트 에러 신드롬 비트에 대해 모델(Mi,j)을 바인딩)은 각각 L2-1 신드롬들에 대해 바인딩된다. 이러한 방식으 로, 총 L2 모델들이 트레이닝될 필요가 있다. 위의 설명들을 참조하면, 모델의 트레이닝 데이터세트는 시뮬레이션 방식으로 생성될 수 있거나, 또는 실제 실 험 데이터를 수집함으로써 획득될 수 있다. 가능한 구현에서, 트레이닝 데이터세트는 시뮬레이션 방식으로 생성된다. 도 18에 도시된 바와 같이, 프로세스 는 다음의 단계들을 포함할 수 있다: 단계: 시뮬레이션 결과를 획득하기 위해 샘플 양자 회로의 데이터 에러 및 측정 에러를 시뮬레이팅한다. 데이터 에러는 샘플 양자 회로의 데이터 큐비트 상에서 발생하는 에러이고, 측정 에러는 에러 신드롬 측정 동안 발생하는 에러이다. 데이터 에러는 위에서 설명된 내부 메모리 에러이다. 측정 에러들은, 위에서 설명된 상태 준비 에러, 양자 게이트 에러 및 측정 에러를 포함할 수 있다. 단계: 시뮬레이션 결과에 기반하여, T개의 에러 신드롬 측정들에서 샘플 양자 회로의 에러 신드롬 정보를 획득하며, T는 1보다 큰 정수이다. T개의 에러 신드롬 정보를 획득하기 위해, 샘플 양자 회로에 대해 T개의 에러 신드롬 측정들이 수행된다. L의 스케일을 갖는 표면 코드의 경우, 패리티 검사들에 대한 2개의 부류들의 획득된 결과들은, 0 및 1을 포함하는 하나의 2차원 T×(L+1) ×(L+1) 어레이로 결합된다. 단계: T개의 에러 신드롬 정보를 타겟 시점에 투영함으로써 획득된 등가 데이터 에러 정보를 결정한다. 등가 데이터 에러 정보 및 등가 측정 에러 정보의 포지션들은 시간 및 공간에서 상이하다. 도 8에 도시된 바와 같이, 등가 데이터 에러 정보는 수평 라인이고, 등가 측정 에러 정보는 수직 라인이며, 따라서, 타겟 시점에 에 러 신드롬 정보를 투사함으로써, 등가 에러 정보로부터 등가 데이터 에러 정보가 쉽게 추출될 수 있다. 단계: 등가 데이터 에러 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 결정한다. 단계: 트레이닝 샘플 구축하며, 트레이닝 샘플의 샘플 데이터는 T개의 에러 신드롬 정보를 포함하고, 트레 이닝 샘플의 라벨 데이터는 등가 데이터 에러 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 포함한다. 단계: 트레이닝 샘플을 사용하여 제1 디코더 및 제2 디코더를 트레이닝시킨다. 일 실시예에서, 도 18에 도시된 바와 같이, 단계는 다음의 서브-단계들(181a 내지 181d)을 포함할 수 있다: 서브-단계(181a): 샘플 양자 회로에 포함된 데이터 큐비트에서 에러를 확률적으로 생성한다. 예컨대, 각각의 데 이터 큐비트에 대해, X 에러, Y 에러, 또는 Z 에러(내부 메모리 잡음)는, 패리티 검사가 시작되기 전에 확률 (p)로 각각의 큐비트에 대해 생성된다. 예를 들어, X 에러, Y 에러, 또는 Z 에러는 확률(p)로 샘플 양자 회로의 각각의 데이터 큐비트에 대해 생성되며, 표준 난수(standard random number) 생성 방법은 [0,1]으로부터 난수를 균등하게 샘플링하기 위해 구체적으로 사용될 수 있다. 난수가 [0, p/3] 내에 속하면, 이는 X 에러로 설정되고; 난수가 [p/3, 2p/3] 내에 속하면, 이는 Y 에러로 설정되고; 난수가 [2p/3, p]에 속하면, 이는 Z 에러로 설정되 고; 그리고 난수가 [p, 1]에 속하면, 이는 I로 설정된다(즉, 에러가 없음). 서브-단계(181b): 샘플 양자 회로에 대응하는 보조 큐비트에서 에러를 확률적으로 생성하며, 보조 큐비트는 샘 플 양자 회로의 에러 신드롬 정보를 측정하도록 구성된다. 예를 들어, (또는 )에 대해 준비된 보조 큐비 트의 경우, 확률(p)로 X 에러 또는 Z 에러(상태 준비 잡음)가 생성된다. 서브-단계(181c): 고유값(eigenvalue) 측정 회로에 포함된 비-제어(CNOT: controlled-not) 게이트에서 에러를 확률적으로 생성하며, 고유값 측정 회로는, 샘플 양자 회로에 대응하며, 스태빌라이저 생성자의 고유값을 측정 하도록 구성된다. 예컨대, 고유치 측정 회로의 각각의 CNOT의 경우, 15개의 이중 파울리 연산자들(IX, IY, IZ, XI, YI, ZI, XX, XY, XZ, YX, YY, YZ, ZX, ZY, 및 ZZ 포함)에서 하나의 에러(양자 게이트 잡음)가 확률(p)로 생성된다. 서브-단계(181d): QEC 코드를 사용하여 샘플 양자 회로에 대해 에러 신드롬 측정이 수행되는 경우, 측정 에러를 확률적으로 생성한다. 예컨대, X(Z) 에러(측정 잡음)는 확률(p)로 Z(X) 측정 이전에 발생하며, 여기서 Z(X)는 X 에러만이 Z 측정에 영향을 미친다는 것을 지시하고, X(Z)는 Z 에러만이 X 측정에 영향을 미친다는 것을 지시한 다. 그러나, 그러한 잡음 모델은 지나치게 바람직하다. 다른 가능한 구현에서, QPT(quantum process tomography)가 먼저 큐비트들에 대해 실험적으로 수행되어 실제 잡음 모델이 추출될 수 있다. 이러한 방식은 3개 초과의 큐비 트들 사이의 잡음 연관성을 무시하는 것과 등가이다. 연관들이 매우 강한 경우, 연관들은 먼저 실험적으로 제거 될 필요가 있는데, 이는 이들이 QEC에 치명적인 영향을 야기하기 때문이다. QPT가 완료된 후, 양자 상태에 대한 실제 물리적 잡음의 영향력은, 몬테 카를로(Monte Carlo) 방법을 사용하여 QPT에 따라 직접적으로 시뮬레이이팅 될 수 있고, 이후, 바람직한 패리티 검사가 수행되고 신드롬들 및 에러 상동 부류들이 추출되어 라벨 데이터가 획득된다. QPT가 너무 많은 자원들을 소비하기 때문에, QPT는 단지 기껏해야 2개의 기하학적으로 이웃하는 큐비 트들에 대해 작용된다. 이러한 접근법의 단점은, 큰 스케일을 갖는 표면 코드(예컨대, 표면 코드는 10보다 큰 L 을 가짐)가 시뮬레이팅될 수 없다는 것인데, 이는 비교적 높은 컴퓨테이션 복잡성을 갖는 완전한 양자 시뮬레이 션(full quantum simulation)을 요구하기 때문이다. 다른 예에서, 도 18에 도시된 바와 같이, 단계는 다음의 서브-단계들(181h 내지 181i)을 포함할 수 있다: 서브-단계(181h): 샘플 양자 회로의 잡음 모델을 추출하기 위해, 샘플 양자 회로에 대해 QPT를 수행하고, 잡음 모델은 시뮬레이션을 통해 데이터 에러 및 측정 에러를 생성하도록 구성된다. 서브-단계(181i): 잡음 모델에 기반하여, 잡음의 작용 하에 샘플 양자 회로의 양자 상태의 진화를 시뮬레이팅한 다. 이러한 방식이 사용되는 경우에, QPT가 먼저, 내부 메모리 잡음, 상태 준비 잡음, 양자 게이트 잡음 및 측정 잡 음의 정확한 수학적 설명을 추출하기 위해, 큐비트들에 대해 실험적으로 수행된 다음, 잡음의 작용 하에서 양자 상태의 진화를 직접 시뮬레이팅한 후 신드롬들 및 라벨들이 생성된다. 전술한 내용은 시뮬레이션 방식으로 트레이닝 데이터세트의 생성을 설명한다. 제1 트레이닝 데이터 생성 방식의 경우, 원하는 잡음 모델을 사용하여 에러 모방을 수행함으로써 트레이닝 데이터가 생성되고; 그리고 제2 트레이 닝 데이터 생성 방식의 경우, QPT를 통해 실제 노이즈 모델이 추출된 다음, 실제 잡음 모델은 트레이닝 데이터 를 생성하기 위해 샘플 양자 회로에 대한 실제 물리적 잡음의 영향력을 시뮬레이팅하는 데 사용된다. 다른 가능한 구현에서, 트레이닝 데이터세트는 실제 실험 데이터를 수집함으로써 획득된다. 도 19에 도시된 바 와 같이, 프로세스는 다음의 단계들(191 내지 194)을 포함할 수 있다: 단계: 샘플 양자 회로의 에러 신드롬 정보를 획득하기 위해, 샘플 양자 회로에 대해 잡음성 에러 신드롬 측정이 수행된다. 단계: 샘플 양자 회로의 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 획득 하기 위해, 다른 디코더를 사용하여 샘플 양자 회로의 에러 신드롬 정보를 디코딩한다. 단계: 트레이닝 샘플을 구축하며, 트레이닝 샘플의 샘플 데이터는 샘플 양자 회로의 에러 신드롬 정보를 포함하고, 트레이닝 샘플은 라벨 데이터를 포함하고, 라벨 데이터는 샘플 양자 회로의 에러 신드롬 정보에 대응 하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 포함한다. 단계: 트레이닝 샘플을 사용하여 제1 디코더 및 제2 디코더를 트레이닝시킨다. 다른 디코더는 QEC 디코딩 능력을 갖는 임의의 디코더일 수 있다. 일 예에서, 다른 디코더는 심층 강화 학습 디 코더일 수 있다. 심층 강화 학습 디코더는 비지도 트레이닝 방식(unsupervised training manner)을 사용하며, 이에 따라 심층 강화 학습 디코더는, 심층 강화 학습 디코더가 실제 에러 신드롬 정보와 대응하는 논리 에러 부 류 및 대응하는 퍼펙트 에러 신드롬 정보 간의 관계를 학습할 수 있도록, 실제 실험 데이터를 수집하여 트레이 닝될 수 있다. 그런 다음, 트레이닝이 완료된 심층 강화 학습 디코더를 사용하여 실제 에러 신드롬 정보에 따라 샘플 데이터가 생성될 수 있다. 부가하여, 뉴럴 네트워크 디코더의 트레이닝은 표준 뉴럴 네트워크 트레이닝 방식이다. 예시적으로, 크로스 엔 트로피(cross entropy)가 타겟 함수로서 사용되고, 확률론적 경사 하강 알고리즘(stochastic gradient decent algorithm)이 트레이닝에 사용된다. 일반적으로, 적응형 모멘트 추정 알고리즘을 사용하면 더 양호한 성능을 얻 을 수 있다. 100만 내지 3000만 개의 트레이닝 샘플들이 있을 수 있고, 학습 레이트는 1e-5 내지 1e-2의 범위 내에 속하며, 학습 모멘텀은 1e-4 내지 1e-6에서 취해진다. 실험들을 통해, 전술한 하이퍼파라미터 세팅들 (hyperparameter settings)로, 파이토치(pytorch) 1.2 이하에서 비교적 만족스러운 트레이닝 결과가 획득될 수 있다는 것이 밝혀졌다. 전술한 내용은 트레이닝 데이터세트를 생성하는 여러 방식들을 설명한다. 시뮬레이션 방식의 사용은 더 간단하 고 더 효율적이며, 실제 실험 데이터를 수집하는 방식의 사용은 강화 학습에 대한 요건으로 인해 비교적 긴 시 간을 소비하지만, 이러한 방식으로 생성된 샘플 데이터는 실행에 더 가깝고 더 현실적이다. 실제 애플리케이션 에서, 트레이닝 데이터세트는 실제 요건에 따라 적절한 방식을 선택함으로써 생성될 수 있으며, 이는 본 출원의 실시예들로 제한되지 않는다. 예시적인 실시예에서, 뉴럴 네트워크 디코더들(위에서 설명된 제1 디코더 및 제2 디코더를 포함함)이 에러 신드 롬 정보에 대해 피처 추출을 수행하는 경우, 분할-규칙 아이디어(divide-and-rule idea) 및 파티셔닝-기반 피처 추출 방식이 사용된다. 파티셔닝-기반 피처 추출은, 피처 정보를 추출하는 경우, 뉴럴 네트워크 디코더의 피처 추출 계층은 입력 데이터를 파티셔닝하여 입력 데이터를 복수의 작은 블록들로 분할하고, 작은 블록들에 대해 개별적으로 피처 추출을 수행한다는 것을 의미한다. 즉, 파티셔닝-기반 피처 추출은, 입력 데이터가 적어도 2개 의 블록들을 획득하도록 파티셔닝된 후에, 피처 추출이 적어도 2개의 피처 추출 유닛들을 사용하여 적어도 2개 의 블록들에 대해 병렬로 수행되는 것을 의미한다. 적어도 2개의 블록들은 적어도 2개의 피처 추출 유닛들에 일 대일로 대응하고, 각각의 피처 추출 유닛은 하나의 블록에 대해 피처 추출을 수행하도록 구성된다. 부가하여,적어도 2개의 블록들은 피처 추출을 병렬로 수행하며, 이는 피처 추출에 의해 요구되는 시간을 단축시키는 것을 돕는다. 예컨대, 퍼펙트 에러 신드롬들이 획득될 수 있는 경우를 고려하면, 이 경우 모델의 유효성이 검사될 수 있다. 디코딩 문제는 분류 문제와 등가일 수 있기 때문에, 상이한 입력된 에러 신드롬들을 분류하기 위해 종래의 뉴럴 네트워크를 사용하려고 시도될 수 있다. 가장 간단한 접근법은, 입력 계층, 중간 은닉 계층들 및 출력 계층을 포함하는 완전 연결 네트워크를 사용하는 것이다. 출력 계층은 분류될 필요가 있는 4개의 상동 부류들(I, X, Y 및 Z)만을 포함한다. 그러한 네트워크는 디코딩될 필요가 있는 표면 코드의 스케일로 더 커지고, 포함된 파라미 터들의 수량이 기하급수적으로 증가하고, 트레이닝 난이도(요구되는 데이터세트들 및 요구되는 수렴 속도)가 또 한 기하급수적으로 증가한다. 이러한 상황을 다루기 위해, 본 출원은 분할-규칙 아이디어 및 파티셔닝-기반 피 처 추출 방식을 사용하는 것을 제안한다. 즉, 큰 표면 코드는 작은 블록들로 세분되고, 작은 블록들은 \"분류되 고\"(본원에서 \"분류된다\"는 피처 정보를 추출하는 것을 의미함); 그런 다음, 분류된 정보(부류들의 확률들)가 이전 계층으로 전송되고; 그런 다음, 이전 계층은, 그 다음 계층으로부터 전송된 정보 및 이전 계층에서의 등가 에러 신드롬들에 따라, 계층에서 에러 부류들이 발생할 확률들을 결정한다. 재귀(recursion)가, 전체 표면 코드"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "의 에러 부류들의 확률들이 최종적으로 요약될 때까지, 이런 방식으로 수행되고, 그런 다음, 분류 및 에러 정정 이 수행된다. 예시적인 실시예에서, 제1 디코더가 대응하는 논리 에러 부류를 획득하기 위해 실제 에러 신드롬 정보를 디코딩 하는 경우, 파티셔닝-기반 피처 추출 방식이 사용될 수 있다: 1. 피처 정보를 획득하기 위해, 제1 디코더를 사용하여 실제 에러 신드롬 정보에 대해 파티셔닝-기반 피처 추출 을 수행한다. 2. 실제 에러 신드롬 정보에 대응하는 논리 에러 부류를 획득하기 위해, 제1 디코더를 사용하여 피처 정보에 대 해 융합 디코딩을 수행한다. 예시적인 실시예에서, 제2 디코더가 대응하는 퍼펙트 에러 신드롬 비트들을 획득하기 위해 실제 에러 신드롬 정 보를 디코딩하는 경우, 파티셔닝-기반 피처 추출 방식이 또한 사용될 수 있다: 1. 피처 정보를 획득하기 위해, 제2 디코더를 사용하여 실제 에러 신드롬 정보에 대해 파티셔닝-기반 피처 추출 을 수행한다. 2. 퍼펙트 에러 신드롬 비트들을 획득하기 위해, 제2 디코더를 사용하여 피처 정보에 대해 융합 디코딩을 수행 한다. 예시적인 실시예에서, 뉴럴 네트워크 디코더(위에서 설명된 제1 디코더 및 제2 디코더를 포함함)는 m개의 캐스 케이드된 피처 추출 계층들을 포함하며, m은 양의 정수이다. 피처 추출 계층은 피처 추출을 위해 구성된 뉴럴 네트워크 계층이다. 실제 에러 신드롬 정보에 대해 파티셔닝-기반 피처 추출을 수행하는 단계들은: 피처 정보를 획득하기 위해, m개의 피처 추출 계층들을 사용하여 실제 에러 신드롬 정보에 대해 파티셔닝-기반 피처 추출을 수행하는 단계를 포함할 수 있다. 제1 피처 추출 계층은 실제 에러 신드롬 정보에 대해 파티셔닝-기반 피처 추 출을 수행하도록 구성되고, 제i 피처 추출 계층은 이전 피처 추출 계층의 피처 추출 결과에 대해 파티셔닝-기반 피처 추출을 수행하도록 구성되며, i는 1보다 크고 m 이하인 정수이다. 예시적으로, 뉴럴 네트워크 디코더는 복수의 캐스케이드된 피처 융합 계층들을 더 포함하며, 피처 추출 계층은 피처 추출 계층에 의해 추출된 피처 정보에 대해 융합 디코딩을 수행하도록 구성된 뉴럴 네트워크 계층이다. CNN을 예로 사용함으로써, 피처 추출 계층은 콘볼루션 계층이고, 피처 융합 계층은 완전 연결 계층일 수 있다. 뉴럴 네트워크 디코더는 입력 계층, 적어도 하나의 콘볼루션 계층, 적어도 하나의 완전 연결 계층 및 출력 계층 을 포함한다. 일반적으로 복수의 콘볼루션 계층들이 있고, 또한 일반적으로 복수의 완전 연결 계층들이 있다. 도 20에 도시된 바와 같이, 에러 신드롬 정보는 복수의 데이터 유닛들로 분할된다. 도 20에서, 에러 신드 롬 정보가 4×4의 데이터 어레이인 예가 사용되고, 데이터 어레이는 4개의 데이터 유닛들로 분할되고(상이한 데 이터 유닛들은 상이한 충전(filling)들로 도 20에 도시됨), 각각의 데이터 유닛은 2×2의 서브-어레이이다. 에 러 신드롬 정보는 뉴럴 네트워크 디코더에 입력된다. 뉴럴 네트워크 디코더의 콘볼루션 계층들 에 대해, 파티셔닝-기반 피처 추출 방식이 사용되고, 상이한 데이터 유닛들이 동일한 콘볼루션 커널 (convolution kernel)에 의해 동시에 판독된다. C개의 피처들이 판독될 필요가 있다면, C개의 콘볼루션 커널들 이 요구된다. C는 콘볼루션 계층들에 대응하는 채널들의 수량이다. L의 스케일을 갖는 표면 코드의 경우, 각각의 콘볼루션에 대응하는 서브-어레이의 스케일은 이다. 제1 계층에서, 하나의 채널로부터 개의 채널들로 맵핑되는 의 콘볼루션 커널이 요구되고, 제2 계층에서, 개의 채널들로부터 개의 채널들로 맵핑 되는 의 콘볼루션 커널이 요구된다. 유추에 의해, 총 개의 계층들이 요구된다. 채널들의 수량은 조정 될 필요가 있는 하이퍼파라미터이며, 이는 L에 따라 증가한다. 마지막으로, 약 의 크기를 갖는 어레 이가 콘볼루션 계층으로부터 출력되고, 어레이는 완전 연결 계층에 입력된다. 그런 다음, 각각의 완전 연결 계 층이 통과될 때, 이 선택되는 경우, 완전 연결 계층의 깊이는 약 이다. 이러한 방식으로, 서 브-어레이의 스케일이 상대적으로 크더라도, 상대적으로 작은 깊이를 갖는 모델이 대안적으로 사용될 수 있고, 모델의 깊이는 점진적으로 이 된다. 이 선택되는 경우, 제k 계층 내지 제(k+1) 계층의 CNN 은 파라미터들을 포함하고, 모든 콘볼루션 계층들의 파라미터들의 총 수량은 이다. 유사하게, 모든 완전 연결 계층들의 파라미터들의 총 수량은 또한 이다. 본원에서, 각각의 재정규화 (renormalization)에 대한 서브-어레이의 크기로서 상이한 값이 선택될 수 있다. 이러한 성장 방식은 명백히 다 항식(polynomial)이고 비-지수적(non-exponential)이다. 즉, 해결책은 확장가능할 것이다. 에러 신드롬 정보가 8×8의 데이터 어레이인 예가 사용된다. 데이터 어레이는 2×2의 16개의 서브-어레이들로 분할될 수 있고, 제1 콘볼루션 계층의 콘볼루션 커널 크기는 2×2이다. 파티셔닝-기반 피처 추출은 제1 콘볼루 션 계층을 사용하여 수행되며, 4×4의 피처 데이터 어레이가 획득될 수 있다. 4×4의 피처 데이터 어레이는 2× 2의 4개의 서브-어레이들로 분할될 수 있고, 제2 콘볼루션 계층의 콘볼루션 커널 크기는 2×2이다. 제2 콘볼루 션 계층을 사용하여 파티셔닝-기반 피처 추출이 수행되고, 2×2의 피처 데이터 어레이가 획득될 수 있다. 에러 신드롬 정보 또는 피처 데이터 어레이가 파티셔닝되는 경우, 분할을 통해 획득된 서브-어레이들의 크기들은 동 일하거나 상이할 수 있다. 상이한 큐비트들의 에러 레이트들이 상이한 경우, 상이한 크기들은 원칙적으로 이점 들을 가져오지만, 이는 크기들이 동일한 경우에는 동작하는 것이 더 쉽다. 예시적으로, 피처 추출 계층이 파티셔닝-기반 피처 추출을 수행하는 경우, 임의의 2개의 블록들 사이에는 어떠 한 교차도 존재하지 않는다. 즉, 각각의 계층의 피처 추출에 대해, 모든 서브-어레이들 사이에 통신이 없고, 콘 볼루션 커널들이 작용하는 구역들 사이에는 어떠한 신드롬 교차가 없다. 피처 추출 계층들의 특징 정보가 수집"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "되어 그 다음 계층으로 요약될 때에만, 이들의 정보가 동시에 프로세싱되어 포괄적으로 활용될 수 있다. 본원에 서의 피처 추출은 특정 큐비트 에러 확률에 불필요하게 대응하기 때문에, 주변 확률(marginal probability)들을 정렬시키기 위해 신뢰 전파(belief propagation)가 수행될 필요가 없으며, 이는 또한 알고리즘을 단순화하고, 아마도 더 양호한 성능을 제공할 수 있다. 예를 들어, L = 15를 예로 사용함으로써 알고리즘에 대해 설명된다. 총 2개의 콘볼루션 계층들이 존재한다: 제1 콘볼루션 계층의 경우, 하나의 채널 내지 500개의 채널들로의 맵핑을 수행하기 위해 4×4의 콘볼루션 커널이 사 용될 수 있고; 그리고 제2 계층의 콘볼루션 커널 크기는 2×2이고, 500개의 채널들 내지 1000개의 채널들로의 맵핑이 수행되며, 이 경우, 제2 계층에 4000개의 뉴런들이 존재한다. 그런 다음, 4000개의 뉴런들의 값들은 완 전 연결 네트워크를 사용하여 분류된다: 제1 완전 연결 계층은 4000개의 뉴런들을 1024개의 뉴런들에 연결하고; 제2 완전 연결 계층은 1024개의 뉴런들을 512개의 뉴런들에 연결하고; 제3 완전 연결 계층은 512개의 뉴런들을 128개의 뉴런들에 연결하고; 그리고 제4 완전 연결된 계층은 128개의 뉴런들을 4개의 뉴런들(I, X, Y 및 Z)에 연결한다. 특정 네트워크 모델의 파이토치 코드는 다음과 같을 수 있다:"}
{"patent_id": "10-2021-7035047", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 10, "content": "심플 ReLU(rectified linear unit) 계층이 제거되는 경우, 전체 뉴럴 네트워크의 6개의 계층들만이 존재하며, 이로써 매우 얕은 뉴럴 네트워크(very shallow neural network)가 된다는 것을, 전술한 예로부터 알 수 있다. 예시적인 실시예에서, 결함 허용 및 에러 정정의 유효성을 보장하기 위해, 획득된 에러 신드롬 정보는 T개의 데 이터 어레이들을 포함하고, 각각의 데이터 어레이는 QEC 코드를 사용하여 타겟 양자 회로에 대해 에러 신드롬 측정을 수행함으로써 획득되며, T는 1보다 큰 정수이다. 선택적으로, 위에서 설명된 바와 같이, T = O(L)이다. 이 경우, 에러 신드롬 정보가 획득된 후, 에러 신드롬 정보는, T개의 데이터 어레이들에서 동일한 포지션들에 위치된 적어도 2개의 데이터 유닛들(하나의 데이터 유닛은 T개의 어레이 유닛들을 포함함)로 분할된다. 특정 뉴 럴 네트워크 알고리즘이 도 21에 도시되며, 그 구조는 신드롬들이 퍼펙트한 경우의 구조와 매우 유사하지만, 또 한 차이가 있다. 도 21에 도시된 바와 같이, 에러 신드롬 정보는 복수의 데이터 유닛들로 분할된다. 도 21 에서, 에러 신드롬 정보가 4×4×4의 데이터 어레이인 예가 사용되고, 데이터 어레이는 4개의 데이터 유닛들로 분할되고(상이한 데이터 유닛들은 상이한 충전(filling)들로 도 21에 도시됨), 각각의 데이터 유닛은 2×2×2의 서브-어레이이다. 에러 신드롬 정보는 뉴럴 네트워크 디코더에 입력된다. 뉴럴 네트워크 디코더(21 2)의 콘볼루션 계층의 경우, 특징 정보 추출은 파티셔닝-기반 피처 추출 방식으로 수행된다. 실시간 에러 정정 동안, 상동 부류들에 대한 분류에 부가하여, 신드롬들이 추가로 분류될 필요가 있다. 반복을 피하기 위해, 상동 부류들에 대한 분류만이 본원에서 예로 열거된다. 먼저, CNN의 제1 계층의 입력 채널들은 T개의 계층들로 변한 다. 부가하여, CNN의 각각의 다른 계층들의 출력 채널들의 수량 또한, 에서 으로 증가한다. 이러한 방식으로, 마지막으로, 디코더의 깊이는 여전히 이고, 약 개의 파라미터들이 요구된다. 알고 리즘을 실행하기 위한 하드웨어의 선택은, 파라미터들을 저장하고 각각의 콘볼루션 계층 및 각각의 완전 연결 계층을 병렬화하기 위한 충분한 공간이 있는지 여부를 충분히 고려할 필요가 있다. 위의 내용에 기반하여, 본 출원의 이 실시예에서 제공되는 기술적 해결책에서, 복수의 그룹의 피처 정보를 획득 하기 위해, 양자 회로의 에러 신드롬 정보에 대해 파티셔닝-기반 피처 추출이 수행되고; 그런 다음, 에러 결과 정보를 획득하기 위해, 피처 정보의 복수의 그룹에 대해 융합 디코딩이 추가로 수행된다. 파티셔닝-기반 피처 추출 방식이 사용되기 때문에, 입력 데이터에 대해 완전한 피처 추출을 수행하는 것과 비교하여, 이 기술적 해 결책은, 한편으로, 각각의 피처 추출을 통해 획득된 피처 정보의 채널들의 수량이 감소하게 하고, 이에 따라 그 다음 피차 추출의 입력 데이터가 감소되며, 이는 뉴럴 네트워크 디코더에서 피처 추출 계층들의 수량을 감소시 키는 것을 도와, 뉴럴 네트워크 디코더의 깊이를 줄인다. 뉴럴 네트워크 디코더의 깊이가 줄기 때문에, 대응하 여, 뉴럴 네트워크 디코더의 디코딩 시간 또한 단축된다. 다른 한편으로, 파티셔닝-기반 피처 추출 동안, 복수의 피처 추출 유닛들은 복수의 블록들에 대해 병렬로 피처 추출을 수행하는 데 사용된다. 즉, 복수의 피처 추출 유닛들은 피처 추출을 병렬로(또는 동시로 지칭됨) 수행할 수 있으며, 이는 또한, 피처 추출에 요구되는 시간을 단축시키는 것을 도와, 디코딩 시간을 단축시킨다. 마지막 으로, 전술한 2개의 양상들을 참조하면, 뉴럴 네트워크 디코더가 QEC 디코딩을 수행하는 데 사용되는 경우, 디 코딩 시간이 충분히 단축되어, 실시간 에러 정정 요건이 충족된다. 부가하여, 뉴럴 네트워크 디코더는 논리-부류 출력을 사용할 수 있으며, 이는 논리-부류 출력의 복잡성을 감소 시키는 것을 도와, 디코딩 시간을 추가로 단축시킨다. 본 출원에서, 설명의 용이함을 위해, 결함 허용 및 에러 정정 디코딩 프레임워크에서는 직관적인 심플 디코더들 의 타입이 사용된다. 실제로, 임의의 심플 디코더가 사용될 수 있으며, 모든 심플 디코더들은 원칙적으로 등가 이다. 해결책의 설명에서, 회전된 표면 코드가 예로 사용된다. 본 출원은 경계를 갖는 다른 표면 코드로 확장될 수 있다. 에러 신드롬들을 정정하고 누설 감소 유닛(LRU: eakage reduction unit)을 부가함으로써 회로에 대해 추출이 수행될 수 있고, 그에 따라, 전체 결함 허용 및 에러 정정 프로토콜은 큐비트들의 상태 누설을 검출할 수 있다. 그런 다음, 우수한 성능을 갖고 LRU를 포함하는 결함 허용 및 에러 정정 프로토콜이 뉴럴 네트워크를 트레이닝시키는 데 사용될 수 있다. 디코딩 동안, 논리 에러 부류들 및 에러 신드롬들은 상태 누설을 억제하기 위한 결함 허용 및 에러 정정 디코딩 알고리즘을 획득하도록 분류된다. 원칙적으로, 본 출원은 고차원 토릭 코 드(high dimension toric code), 쌍곡선 코드(hyperbolic code) 및 컬러 코드(color code)를 포함하는 다른 양 자 토폴로지 에러 정정 코드들로 확장될 수 있다. 그러나, 다른 토폴로지 에러 정정 코드들의 사용 동안, 신드 롬 측정(패리티 검사) 동안 원-샷 또는 플래그 큐비트와 같은 기술이 사용될 필요가 있으며, 이는 해결책의 복 잡성을 증가시키고 에러 정정 성능을 감소시킬 수 있다. 본 출원에서 제공되는 결함 허용 및 에러 정정 디코딩 프레임워크는 3차원 이산 어레이들에 대해 제한된 분류를 수행하는 모든 뉴럴 네트워크들(CNN, RNN 등을 포함하 지만 이로 제한되지 않음)에 적용될 수 있으며, 차이점은 상이한 뉴럴 네트워크들이 디코딩 성능과 실시간 디코딩 시간에서 차이를 야기한다는 점이다. 본 출원에서, 초전도 양자 컴퓨팅 플랫폼이 예로 사용되지만, 알고리즘 의 일반적인 목적으로 인해, 본출원은 또한 임의의 양자 컴퓨팅 물리적 플랫폼에 적용될 수 있다. 하기는 본 출원의 장치 실시예들을 설명하며, 이는 본 출원의 방법 실시예들을 실행하는 데 사용될 수 있다. 본 출원의 장치 실시예들에서 개시되지 않은 세부사항들은 본 출원의 방법 실시예들을 참조한다. 도 22는 본 출원의 실시예에 따른, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 장치의 블록도이다. 장치 는 전술한 방법 실시예들을 구현하는 기능을 갖는다. 기능은 하드웨어에 의해 구현될 수 있거나, 또는 대응하는 소프트웨어를 실행하는 하드웨어에 의해 구현될 수 있다. 장치는 컴퓨터 디바이스일 수 있거나 컴퓨터 디바이스 에 배치될 수 있다. 장치는 신드롬 정보 획득 모듈, 신드롬 정보 디코딩 모듈 및 에러 결과 결정 모듈을 포함할 수 있다. 신드롬 정보 획득 모듈은 양자 회로의 실제 에러 신드롬 정보를 획득하도록 구성되며, 실제 에러 신드롬 정보는 QEC 코드를 사용하여 양자 회로에 대해 잡음성 에러 신드롬 측정을 수행함으로써 획득된 정보이다. 신드롬 정보 디코딩 모듈은 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부 류를 획득하기 위해, 실제 에러 신드롬 정보를 디코딩하도록 구성되며, 논리 에러 부류는 양자 회로에서 발생하 는 에러의 맵핑을 통해 획득된 부류이고, 퍼펙트 에러 신드롬 정보는 양자 회로에 대해 무-잡음 에러 신드롬 측 정을 수행함으로써 획득된 정보이다. 에러 결과 결정 모듈은 논리 에러 부류 및 퍼펙트 에러 신드롬 정보에 기반하여 양자 회로의 에러 결과 정보를 결정하도록 구성되며, 에러 결과 정보는 양자 회로에서 에러가 발생하는 데이터 큐비트 및 대응하는 에 러 부류를 지시하는 데 사용된다. 예시적인 실시예에서, 도 23에 도시된 바와 같이, 신드롬 정보 디코딩 모듈은 제1 디코딩 유닛 및 제2 디코딩 유닛을 포함한다. 제1 디코딩 유닛은 실제 에러 신드롬 정보에 대응하는 논리 에러 부류를 획득하기 위해, 제1 디코더를 사 용하여 실제 에러 신드롬 정보를 디코딩하도록 구성되며, 제1 디코더는 논리 에러 부류를 결정하도록 구성된 뉴 럴 네트워크 분류기이다. 제2 디코딩 유닛은 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보를 획득하기 위해 제2 디 코더를 사용하여 실제 에러 신드롬 정보를 디코딩하도록 구성되며, 제2 디코더는 퍼펙트 에러 신드롬 정보를 결 정하도록 구성된 뉴럴 네트워크 분류기이다. 예시적인 실시예에서, 제1 디코딩 유닛은, 적어도 2개의 블록들을 획득하기 위해, 제1 디코더를 사용하여 실제 에러 신드롬 정보를 파티셔닝하고; 그리고 피처 정보를 획득하기 위해, 적어도 2개의 피처 추출 유닛들을 사용하여 적어도 2개의 블록들에 대해 병렬로 피 처 추출을 수행하고; 그리고 실제 에러 신드롬 정보에 대응하는 논리 에러 부류를 획득하기 위해, 제1 디코더를 사용하여 피처 정보에 대해 융합 디코딩을 수행하도록 구성된다. 예시적인 실시예에서, 제2 디코딩 유닛은, k개의 퍼펙트 에러 신드롬 비트들을 획득하기 위해, k개의 제2 디코더들에 각각 실제 에러 신드롬 정보를 입력 하고 ―k는 양의 정수이고, k는 QEC 코드의 스케일과 관련됨―; 그리고 실제 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보를 획득하기 위해, k개의 퍼펙트 에러 신드롬 비트 들을 통합하도록 구성된다. 예시적 실시예에서, 제1 디코더 및 제2 디코더의 트레이닝 프로세스는 다음과 같다: 시뮬레이션 결과를 획득하기 위해, 샘플 양자 회로의 데이터 에러 및 측정 에러를 시뮬레이팅 ―데이터 에러는 샘플 양자 회로의 데이터 큐비트 상에서 발생하는 에러이고, 측정 에러는 에러 신드롬 측정 동안 발생하는 에러 임―; 시뮬레이션 결과에 기반하여, T개의 에러 신드롬 측정들에서 샘플 양자 회로의 에러 신드롬 정보를 획득 ―T는 1보다 큰 정수임―;T개의 에러 신드롬 정보를 타겟 시점에 투영함으로써 획득된 등가 데이터 에러 정보를 결정; 등가 데이터 에러 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 결정; 트레이닝 샘플을 구축 ―트레이닝 샘플의 샘플 데이터는 T개의 에러 신드롬 정보를 포함하고, 트레이닝 샘플은 라벨 데이터를 포함하고, 라벨 데이터는 등가 데이터 에러 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 포함함―; 및 트레이닝 샘플을 사용하여 제1 디코더 및 제2 디코더를 트레이닝. 예시적인 실시예에서, 샘플 양자 회로의 데이터 에러 및 측정 에러를 시뮬레이팅하는 것은, 샘플 양자 회로에 포함된 데이터 큐비트에서 에러를 확률적으로 생성하는 것; 샘플 양자 회로에 대응하는 보조 큐비트에서 에러를 확률적으로 생성하는 것 ―보조 큐비트는 샘플 양자 회로의 에러 신드롬 정보를 측정하도록 구성됨―; 고유값 측정 회로에 포함된 비-제어(CNOT: controlled-not) 게이트에서 에러를 확률적으로 생성하는 것 ―고유 값 측정 회로는, 샘플 양자 회로에 대응하며, 스태빌라이저 생성자의 고유값을 측정하도록 구성됨―; 및 QEC 코드를 사용하여 샘플 양자 회로에 대해 에러 신드롬 측정이 수행되는 경우, 측정 에러를 확률적으로 생성 하는 것. 예시적인 실시예에서, 샘플 양자 회로의 데이터 에러 및 측정 에러를 시뮬레이팅하는 것은, 샘플 양자 회로의 잡음 모델을 추출하기 위해, 샘플 양자 회로에 대해 QPT를 수행하는 것 ―잡음 모델은 시뮬레 이션을 통해 데이터 에러 및 측정 에러를 생성하도록 구성됨―; 및 잡음 모델에 기반하여, 잡음의 작용 하에 샘플 양자 회로의 양자 상태의 진화를 시뮬레이팅하는 것. 예시적 실시예에서, 제1 디코더 및 제2 디코더의 트레이닝 프로세스는 다음과 같다: 샘플 양자 회로의 에러 신드롬 정보를 획득하기 위해, 샘플 양자 회로에 대해 잡음성 에러 신드롬 측정을 수행 하는 것; 샘플 양자 회로의 에러 신드롬 정보에 대응하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 획득하기 위해, 다른 디코더를 사용하여 샘플 양자 회로의 에러 신드롬 정보를 디코딩하는 것; 트레이닝 샘플을 구축하는 것 ―트레이닝 샘플의 샘플 데이터는 샘플 양자 회로의 에러 신드롬 정보를 포함하고, 트레이닝 샘플은 라벨 데이터를 포함하고, 라벨 데이터는 샘플 양자 회로의 에러 신드롬 정보에 대응 하는 퍼펙트 에러 신드롬 정보 및 논리 에러 부류를 포함함―; 및 트레이닝 샘플을 사용하여 제1 디코더 및 제2 디코더를 트레이닝시키는 것. 예시적인 실시예에서, 도 23에 도시된 바와 같이, 에러 결과 결정 모듈은 제1 획득 유닛, 제2 획득 유닛 및 결과 결정 유닛을 포함한다. 제1 획득 유닛은 논리 에러 부류에 대응하는 제1 에러 결과를 획득하도록 구성된다. 제2 획득 유닛은 퍼펙트 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득하도록 구성된다. 결과 결정 유닛은 제1 에러 결과 및 제2 에러 결과에 기반하여 양자 회로의 에러 결과 정보를 결정하도록 구성된다. 예시적인 실시예에서, 제1 획득 유닛은, 논리 에러 부류에 포함된 엘리먼트들로부터의 임의의 엘리먼트를 제1 에러 결과로서 선택하도록 구성되며, 논리 에러 부류는 적어도 하나의 등가 에러 엘리먼트를 포함한다. 예시적인 실시예에서, 제2 획득 유닛은, 퍼펙트 에러 신드롬 정보에서 각각 에러 신드롬 포인트들에 대응 하는 심플 에러들에 대한 맵핑 테이블을 검색하고 ―맵핑 테이블은 에러 신드롬 포인트와 심플 에러 간의 적어 도 한 세트의 맵핑 관계를 포함함―; 그리고 제2 에러 결과를 획득하기 위해, 각각 에러 신드롬 포인트들에 대 응하는 심플 에러들을 곱하도록 구성된다. 예시적인 실시예에서, 결과 결정 유닛은, 양자 회로의 에러 결과 정보를 획득하기 위해, 제1 에러 결과와 제2 에러 결과의 곱을 결정하도록 구성된다.예시적인 실시예에서, 도 23에 도시된 바와 같이, 장치는 에러 정정 신호 생성 모듈 및 에러 정정 신호 송신 모듈을 더 포함한다. 에러 정정 신호 생성 모듈은 에러 결과 정보에 기반하여 에러 정정 제어 신호를 생성하도록 구성되며, 에 러 정정 제어 신호는 양자 회로에서 발생하는 에러를 정정하는 데 사용된다. 에러 정정 신호 송신 모듈은 에러 정정 제어 신호를 양자 회로에 송신하도록 구성된다. 위의 내용에 기반하여, 본 출원의 이 실시예에서 제공되는 기술적 해결책에서, 대응하는 논리 에러 부류 및 대 응하는 퍼펙트 에러 신드롬 정보를 획득하기 위해 양자 회로의 실제 에러 신드롬 정보를 디코딩한 다음, 논리 에러 부류 및 퍼펙트 에러 신드롬 정보에 따라 양자 회로에서 에러가 발생한 데이터 큐비트 및 대응하는 에러 부류를 결정함으로써, 본 출원은, 에러 신드롬 정보가 퍼펙트하지 않은 경우 양자 회로의 에러 신드롬 정보에 대한 결함 허용 및 에러 정정 디코딩을 달성한다. 부가하여, 본 해결책은 결함 허용 및 에러 정정 디코딩을 분류 문제로 등가적으로 변환하여, 효율적인 뉴럴 네 트워크 분류기를 사용함으로써 에러 신드롬 정보에 대해 결함 허용 및 에러 정정 디코딩이 수행될 수 있고, 이 로써 결함 허용 및 에러 정정 디코딩 속도를 개선하고, 그리고 실시간 결함 허용 및 에러 정정 디코딩을 달성한 다. 적절한 뉴럴 네트워크 분류기가 선택되는 경우, 디코딩 알고리즘의 속도가 크게 개선될 수 있고, 이로써, 실시간 결함 허용 및 에러 정정 디코딩의 구현의 발판이 마련된다. 전술한 실시예들에서 제공된 장치가 그 기능들을 구현하는 경우, 기능 모듈들의 전술한 분할을 단지 예로서만 사용하여 설명이 주어진다. 실제 애플리케이션들에서, 기능들은 요건들에 따라 상이한 기능 모듈들에 할당되고 그에 의해 구현될 수 있는데, 즉, 디바이스의 내부 구조는 위에서 설명된 기능들의 전부 또는 일부를 구현하기 위해 상이한 기능 모듈들로 분할될 수 있다. 부가하여, 전술한 실시예들에 제공된 장치 및 방법 실시예들은 동 일한 개념에 속한다. 특정 구현 프로세스에 대해, 방법 실시예들에 대한 참조가 이루어질 수 있으며, 세부 사항 들은 본원에서 다시 설명되지 않는다. 도 24는 본 출원의 실시예에 따른 컴퓨터 디바이스의 개략적인 구조도이다. 컴퓨터 디바이스는 도 3에 도시된 해결책의 적용 시나리오에서의 제어 디바이스일 수 있다. 컴퓨터 디바이스는 전술한 실시예들에서 제공된 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법을 구현하도록 구성될 수 있다. 컴퓨터 디바이스는 프로세싱 유닛(예컨대, CPU(central processing unit) 및/또는 GPU(graphics processing unit)), 랜덤 액세스 메모리(RAM) 및 판독-전용 메모리(ROM)를 포함하는 시스템 메모 리, 및 시스템 메모리를 프로세싱 유닛에 연결하는 시스템 버스를 포함한다. 컴퓨터 디바이스는, 컴퓨터 디바이스 내의 컴포넌트들 사이에서의 정보의 전송을 보조하는 기본 입력/출력 시스 템(I/O 시스템), 및 운영 시스템, 애플리케이션 프로그램 및 다른 프로그램 모듈을 저 장하도록 구성된 대용량 저장 디바이스를 더 포함한다. 기본 I/O 시스템은, 정보를 디스플레이하도록 구성된 디스플레이, 및 사용자가 정보를 입력하도록 구성된 입력 디바이스(이를테면, 용자가 마우스 또는 키보드)를 포함한다. 디스플레이 및 입력 디 바이스 둘 모두는 시스템 버스에 연결된 입력/출력 제어기에 의해 프로세싱 유닛에 연 결된다. 기본 I/O 시스템은, 키보드, 마우스 또는 전자 스타일러스와 같은 복수의 다른 디바이스들로부터 의 입력들을 수신 및 프로세싱하기 위한 입력/출력 제어기를 더 포함할 수 있다. 유사하게, 입력/출력 제 어기는 추가로, 디스플레이 스크린, 프린터 또는 다른 타입들의 출력 디바이스들에 출력을 제공한다. 대용량 저장 디바이스는 시스템 버스에 연결된 대용량 저장 제어기(미도시)에 의해 프로세싱 유닛 에 연결된다. 대용량 저장 디바이스 및 대용량 저장 디바이스와 연관된 컴퓨터-판독가능 매체는 컴 퓨터 디바이스에 대한 비-휘발성 저장소를 제공한다. 즉, 대용량 저장 디바이스는, 하드 디스크 또 는 CD-ROM(compact disc ROM) 드라이브와 같은 컴퓨터-판독가능 매체(미도시)를 포함할 수 있다. 일반성의 잃지 않으면서, 컴퓨터-판독가능 매체는 컴퓨터 저장 매체 및 통신 매체를 포함할 수 있다. 컴퓨터 저 장 매체는, 휘발성 및 비-휘발성 매체, 및 컴퓨터-판독 가능 명령들, 데이터 구조들, 프로그램 모듈들, 또는 다 른 데이터와 같은 정보를 저장하도록 구성되며 임의의 방법 또는 기법을 사용하여 구현되는 이동식 및 비-이동 식 매체를 포함한다. 컴퓨터 저장 매체는, RAM, ROM, EPROM(Erasable programmable ROM), EEPROM(electrically erasable programmable ROM), 플래시 메모리 또는 다른 솔리드-스테이트 메모리 기술, CD-ROM, DVD(digital versatile disc)(DVD) 또는 다른 광학 저장소, 테이프 카트리지, 자기 카세트, 자기 디스크 저장소, 또는 다른자기 저장 디바이스를 포함한다. 물론, 당업자는, 컴퓨터 저장 매체가 전술한 몇몇 타입들로 제한되지 않는다는 것을 이해할 수 있다. 시스템 메모리 및 대용량 저장 디바이스는 총체적으로 메모리로 지칭될 수 있다. 본 출원의 다양한 실시예들에 따르면, 컴퓨터 디바이스는 추가로, 실행을 위해 네트워크 상의 원격 컴퓨 터에, 인터넷과 같은 네트워크를 통해 연결될 수 있다. 즉, 컴퓨터 디바이스는 시스템 버스에 연결 된 네트워크 인터페이스 유닛에 의해 네트워크에 연결될 수 있거나, 또는 네트워크 인터페이스 유 닛에 의해 다른 타입들의 네트워크들 또는 원격 컴퓨터 시스템들(미도시)에 연결될 수 있다. 메모리는, 적어도 하나의 명령, 적어도 하나의 프로그램 세그먼트, 코드 세트 또는 명령 세트를 저장하고, 적어 도 하나의 명령, 적어도 하나의 프로그램 세그먼트, 코드 세트, 또는 명령 세트는 전술한 실시예들에서 제공디 는 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법을 구현하기 위해 하나 이상의 프로세서들에 의해 실 행되도록 구성된다. 예시적인 실시예에서, 컴퓨터-판독가능 저장 매체가 추가로 제공된다. 저장 매체는 적어도 하나의 명령, 적어도 하나의 프로그램 세그먼트, 코드 세트 또는 명령 세트를 저장하고, 적어도 하나의 명령, 적어도 하나의 프로그 램 세그먼트, 코드 세트, 또는 명령 세트는 전술한 실시예들에서 제공되는 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법을 구현하기 위해 컴퓨터 디바이스의 프로세서에 의해 실행되도록 구성된다. 예시적인 실시예 에서, 컴퓨터-판독가능 저장 매체는 ROM, RAM, CD-ROM, 자기 테이프, 플로피 디스크, 광학 데이터 저장 디바이 스 등일 수 있다. 예시적인 실시예에서, 컴퓨터 프로그램 제품이 추가로 제공된다. 컴퓨터 프로그램 제품은, 실행될 때, 전술한 실시예들에서 제공되는 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법을 구현하도록 구성된다. 예시적인 실시예에서, 프로그램가능 논리 회로 및/또는 프로그램 명령들을 포함하는 칩이 추가로 제공된다. 칩 은 전술한 실시예들에서 제공되는 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법을 구현하기 위해 컴퓨 터 디바이스 상에서 실행되도록 구성된다. 선택적으로, 칩은 FPGA 칩 또는 ASIC 칩이다. 명세서에서 언급되는 \"복수의\"는 둘 이상을 의미한다. \"및/또는\"은 연관된 객체들을 설명하기 위한 연관 관계를 설명하며, 세 가지 관계들이 존재할 수 있음을 표현한다. 예컨대, A 및/또는 B는, A만이 존재하고, A와 B 둘 모 두가 존재하고, 그리고 B만이 존재하는 3가지의 경우들을 표현할 수 있다. 본 명세서에서 문자 \"/\"는 일반적으 로, 연관된 객체들 간의 \"또는\" 관계를 지시한다. 부가하여, 본 명세서에서 설명된 단계 번호들은 단지 예시적 으로 단계들의 가능한 실행 순서를 나타낸다. 일부 다른 실시예들에서, 단계들은 번호 순서에 따라 수행되지 않 을 수 있다. 예컨대, 상이한 번호들을 갖는 2개의 단계들이 동시에 수행될 수 있거나, 또는 상이한 번호들을 갖 는 2개의 단계들이 도면에 도시된 시퀀스와 상반되는 시퀀스에 따라 수행될 수 있으며, 이는 본 출원의 실시예 들에서 제한되지 않는다. 전술한 설명들은 단지 본 출원의 예시적인 실시예들일 뿐이며, 본 출원을 제한하려는 것은 아니다. 본 출원의 사상 및 원리 내에서 이루어진 임의의 수정, 등가물 교체 또는 개선은 본 출원의 보호 범위 내에 속할 것이다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12 도면13 도면14 도면15 도면16 도면17 도면18 도면19 도면20 도면21 도면22 도면23 도면24"}
{"patent_id": "10-2021-7035047", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 출원의 실시예들의 기술적 해결책들을 보다 명확하게 설명하기 위해, 하기에서는 실시예들을 설명하는 데 요 구되는 첨부 도면들을 간략히 소개한다. 분명히, 하기 설명에서 첨부 도면들은 본 출원의 일부 실시예들만을 도 시하며, 당업자는 창의적인 노력들 없이도 이러한 첨부 도면들로부터 다른 도면들을 여전히 유도할 수 있다. 도 1은, 본 출원의 실시예에 따른, 표면 코드(surface code)의 개략적인 구조도이다. 도 2는, 본 출원의 실시예에 따른, 표면 코드의 에러의 발생을 도시하는 개략도이다. 도 3은 본 출원의 실시예에 따른 해결책의 적용 시나리오의 개략도이다. 도 4는 도 3에 도시된 해결책의 적용 시나리오에 수반되는 결함 허용 및 에러 정정 디코딩 프로세스의 개략도이 다. 도 5는, 본 출원의 실시예에 따른, 단일 신드롬 포인트에 대응하는 심플 에러(simple error)의 개략도이다. 도 6은, 본 출원의 실시예에 따른, 신드롬 측정 회로가 잡음을 포함하는 경우의 에러 신드롬 분포의 개략도이다. 도 7은 본 출원의 실시예에 따른 3차원 신드롬 분포의 개략도이다. 도 8은, 본 출원의 실시예에 따른, 시공간적 격자(spatiotemporal lattice)들 상의 에러들의 맵핑의 개략도이다. 도 9는 본 출원의 실시예에 따른 에러 신드롬 측정 회로의 개략도이다. 도 10은 본 출원의 실시예에 따른 상동 부류 결정(homology class determination)의 개략도이다. 도 11은, 본 출원의 실시예에 따른, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법의 흐름도이다. 도 12는, 본 출원의 실시예에 따른, 에러 신드롬 정보의 2차원 데이터 어레이의 개략도이다. 도 13은, 본 출원의 실시예에 따른, 에러 신드롬 정보의 3차원 데이터 어레이의 개략도이다.도 14는 본 출원의 실시예에 따른 퍼펙트 에러 신드롬 정보의 개략도이다. 도 15는, 본 출원의 다른 실시예에 따른, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법의 흐름도이다. 도 16은, 본 출원의 다른 실시예에 따른, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 방법의 흐름도이다. 도 17은 본 출원의 실시예에 따른 결함 허용 및 에러 정정 디코딩 프로세스의 개략도이다. 도 18은 본 출원의 실시예에 따른 트레이닝 데이터 생성 프로세스의 흐름도이다. 도 19는 본 출원의 다른 실시예에 따른 트레이닝 데이터 생성 프로세스의 흐름도이다. 도 20은 본 출원의 실시예에 따른 파티셔닝-기반 피처 추출(partitioning-based feature extraction)의 개략도 이다. 도 21은 본 출원의 다른 실시예에 따른 파티셔닝-기반 피처 추출의 개략도이다. 도 22는, 본 출원의 실시예에 따른, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 장치의 블록도이다. 도 23은, 본 출원의 다른 실시예에 따른, 양자 회로를 위한 결함 허용 및 에러 정정 디코딩 장치의 블록도이다. 도 24는 본 출원의 실시예에 따른 컴퓨터 디바이스의 개략적인 구조도이다."}
