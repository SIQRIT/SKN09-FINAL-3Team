{"patent_id": "10-2008-7025942", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2009-0021149", "출원번호": "10-2008-7025942", "출원인": "더 유니버시티 오브 미시시피", "발명자": "파리스, 루이스"}}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "각 컴퓨터 메모리 어드레스가 하나 이상의 별개 값을 각각 차지하는 하나 이상의 로케이션을 갖는 하나 이상의별개 컴퓨터 메모리 어드레스를 워크스페이스로 이용하여 값들의 열을 포함하는 원시 데이터 스트림으로부터 데이터를 압축하는 방법에 있어서,(a) K가 0보다 크면 원시 스트림에서 현재 리딩 포인트 직전인 K 비트를 원시 데이터 스트림으로부터 메모리 어드레스 참조로 읽어오고,(b) N 비트를 원시 스트림으로부터 현재 부호값으로 읽어오고,(c) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것하고도 일치하지 않으면 메모리 어드레스 참조에 있는 값들 중 하나를 대체하기 위해 현재 부호값을 기록하고, 현재 부호값이 뒤따르는 MISS 코드/값을 압축데이터 스트림에 기록하고, 그리고(d) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것이든 일치하면 그 값을 찾아낸 메모리 어드레스참조 내의 로케이션을 표현하는 HIT 코드를 압축 데이터 스트림에 기록하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, (a)에서 메모리 어드레스 참조의 가장 왼쪽 비트가 원시 데이터 스트림으로부터 읽는데 이용할 수 없으면 적절히 초기화되며, 각 메모리 어드레스에서의 모든 값들의 초기화 후에 원시 데이터 스트림에서 각 값에 대하여(a) 내지 (d)를 반복하는 것을 더 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어어,(a)에서 읽혀진 K 비트는 메모리 어드레스 참조로 이용되는 결과어를 생성하기 위해 더 적거나 같은 수의 비트로 변환되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 모든 메모리 어드레스는 메모리 어드레스 내의 로케이션 이용을 추적하기 위한 하우스 키핑을 위해 사용되고,메모리 어드레스에서 하나의 값을 읽어오거나/기록한 후에 (c) 또는 (d)에서 업데이트되는 상태 필드를 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 상태 필드는 값을 대체할 때 어느 로케이션이 사용되어야 하는지 결정하는 대체 정책과 연계하여 사용되는것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 대체 정책이 가장 덜 최근에 사용된 (LRU), 선입선출 (FIFO)이나 가장 오래 사용된, 가장 덜 빈번히 사용된 (LFU)와 임의로 이루어진 그룹으로부터 선택되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제3항에 있어서, 워크스페이스로 사용된 모든 메모리는 하나의 값만을 차지하는 하나의 로케이션만을 가지며, (d)에서 HIT 코드- 2 -공개특허 10-2009-0021149는 현재 부호값이 메모리 어드레스 참조에서 발견된 부호값과 일치한다는 것을 가리키는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제5항에 있어서,하나의 별개 값을 차지하는 다수의 로케이션을 갖는 한개의 단일 메모리 어드레스가 워크스페이스로 사용되며,(a)에서 K가 0이면 원시 스트림으로부터 아무런 비트도 읽혀지지 않고, 단지 하나의 메모리 어드레스가 있고 상기 메모리 어드레스는 0인 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 단일 메모리 어드레스는 별개 값들로 이전에 초기화된 2N 로케이션을 가지며, (c)에서 현재 부호값은 항상그러한 로케이션에서 이전에 초기화된 값들 중 어느 것이든 항상 일치하기 때문에 MISS 코드나 현재 부호값이압축 데이터 스트림에 추가되지 않는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제5항에 있어서,(d)에서 가장 빈번히 사용되는 더 낮은 로케이션은 더 짧은 코드를 사용하여 표현되고, 반면에 덜 자주 사용되는 더 높은 로케이션에는 더 긴 코드가 배정되는 식으로 배정되는 가변 길이 코딩 스킴이 HIT와 MISS 코드/값에대하여 사용되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서,하나는 각 로케이션의 이용 빈도를 계산하기 위한 것이고 나머지는 각 로케이션을 표현하는 가변 길이 코드를배정하기 위한 두개의 패스가 가장 빈번히 사용되는 로케이션에는 더 짧은 코드가 배정되고, 가장 빈번하지 않게 이용되는 로케이션에는 더 긴 코드가 배정되는 식으로 사용되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제5항에 있어서,가장 덜 최근에 사용된 카운터의 값은 상태 필드에 암호화되는 각 로케이션에 대해 하나씩 보관되고, 상기 가장덜 최근에 사용된 카운터는 가장 덜 최근에 사용된 대체 정책을 이행하고 각 로케이션에 대한 이용 순위를 나타내기 위해 사용되어, 더 높은 값은 보다 최근에 사용된 로케이션을 표현하고 그 반대의 경우가 있으며, 이로써더 높은 덜 최근에 사용된 계수값에는 더 짧은 코드가 배정되고, 반면에 더 낮은 값에는 더 긴 코드가 배정되는것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1항에 있어서,워크스페이스로 사용되는 상기 컴퓨터 메모리는 현재 부호값에 대한 입력으로 사용되는 N 비트, 상기 메모리 어드레스 참조에 대한 입력으로 사용되는 K 비트, 상기 메모리 어드레스 참조에서 값들이 발견되는 로케이션을 가리키기 위한 출력으로 사용되는 L 비트와 히트나 미스가 결과로 일어났는 지를 나타내기 위한 출력으로 사용되는 1 비트를 갖는 의사 캐시 메모리로 이행되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "각 컴퓨터 메모리 어드레스가 하나 이상의 별개 값을 각각 차지하는 하나 이상의 로케이션을 갖는 하나 이상의별개 컴퓨터 메모리 어드레스를 워크스페이스로 이용하여 MISS와 HIT 코드를 포함하는 압축 코드와 함께 적어도원시 데이터의 일부를 포함하는 압축 데이터 스트림으로부터 비압축 원시 데이터 스트림을 복원하는 방법에 있어서,- 3 -공개특허 10-2009-0021149(a) K가 0보다 크면 비압축 스트림에서 현재 삽입 포인트 직전인 K 비트를 상기 비압축 스트림으로부터 메모리어드레스 참조로 읽어오고,(b) 코드값을 상기 비압축 스트림으로부터 읽어오고, 상기 코드값은 HIT로 암호화된 로케이션이나 MISS 발생을표현하고,(c) 상기 값이 MISS 코드이면 N 비트를 상기 비압축 스트림으로부터 현재 부호값으로 읽어오고, (a)에서 얻은상기 메모리 어드레스 참조에서의 값들 중 하나를 대체하기 위해 현재 부호값을 기록하고, 현재 부호값을 비압축 스트림에 기록하고, 그리고(d) 상기 값이 HIT 코드이면 N 비트를 (a)에서 얻은 메모리 어드레스 참조에서 복호화된 HIT 코드에 의해 주어지는 로케이션으로부터 읽어오고, 현재 부호값을 비압축 스트림에 기록하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서,(a)에서 메모리 어드레스 참조의 가장 왼쪽 비트가 원시 데이터 스트림으로부터 읽어오는데 이용될 수 없으면적절히 초기화되어, 각 메모리 어드레스에서의 모든 값들의 적절한 초기화 후에 압축 데이터 스트림에서 각 값에 대하여 (a) 내지 (d)를 반복하는 것을 더 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서,(a)에서 읽어온/입력된 K 비트는 더 적거나/같은 수의 비트로 환원/변환되고, 그 결과어는 메모리 어드레스 참조로 사용되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서,모든 메모리 어드레스는 메모리 어드레스 내의 로케이션 이용을 추적하기 위한 하우스 키핑을 위해 사용되고,메모리 어드레스에서 하나의 값을 읽어오거나/기록한 후에 (c) 또는 (d)에서 업데이트되는 상태 필드를 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서,상기 상태 필드는 값을 대체할 때 어느 로케이션이 사용되어야 하는지 결정하는 대체 정책과 연계하여 사용되는것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서,상기 대체 정책이 가장 덜 최근에 사용된 (LRU), 선입선출 (FIFO) 이나 가장 오래 사용된, 가장 덜 빈번히 사용된 (LFU)와 임의로 이루어진 그룹으로부터 선택되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제16항에 있어서, 워크스페이스로 사용된 모든 메모리는 하나의 값만을 차지하는 하나의 로케이션만을 가지며, (d)에서 HIT 코드는 현재 부호값이 메모리 어드레스 참조에서 발견된 부호값과 일치한다는 것을 가리키는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제18항에 있어서,하나의 별개 값을 차지하는 다수의 로케이션을 갖는 한개의 단일 메모리 어드레스가 워크스페이스로 사용되며,- 4 -공개특허 10-2009-0021149(a)에서 K가 0이면 원시 스트림으로부터 아무런 비트도 읽혀지지 않고, 단지 하나의 메모리 어드레스가 있고 상기 메모리 어드레스는 0인 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제21항에 있어서,상기 단일 메모리 어드레스는 별개 값들로 이전에 초기화된 2N 로케이션을 가지며, (c)에서 현재 부호값은 항상그러한 로케이션에서 이전에 초기화된 로케이션에서 항상 발견되기 때문에 MISS 코드나 현재 부호값이 압축 데이터 스트림에서 읽혀지거나 나타나지 않는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제18항에 있어서,(d)에서 가변 길이 코딩 스킴이 압축 스트림으로부터 읽혀진 이전에 암호화된 HIT와 MISS 코드에 사용되는 것을특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제23항에 있어서,복호화된 각 HIT 코드는 로케이션 자체를 표현하는 것이 아니라 주어진 메모리 어드레스에 대한 히트로 기인되는 로케이션과 연관된 가장 덜 최근에 사용된(LRU) 카운터를 표현하고, 상기 방법은 (a) 상기 LRU 카운터값과 연관된 로케이션을 조사하고,(b) (a)에서 얻은 그러한 로케이션으로부터 현재 부호값을 읽어오며,LRU 카운터는 상태 필드에 보관되어 LRU 대체 정책을 이행하고 각 로케이션에 대한 이용 순위를 표현하는데 사용되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제14항에 있어서, 워크스페이스로 사용되는 상기 컴퓨터 메모리는 현재 부호값에 대한 입력으로 사용되는 N 비트, 상기 메모리 어드레스 참조에 대한 입력으로 사용되는 K 비트, 상기 메모리 어드레스 참조에서 현재 값들이 읽혀질 필요가 있는 상기 메모리 어드레스 참조에서의 로케이션을 가리키기 위한 입력으로 사용되는 L 비트와, 그러한 부호값을출력하기 위한 N 비트를 갖는 의사 캐시 메모리로 이행되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "제1항에 있어서,상기 HIT와 MISS 코드는 n-바이트 토큰으로 그룹이 되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "제26항에 있어서,n은 2의 제곱지수(power)이어서 원시 스트림이나 압축 스트림으로부터 읽혀진 값들은 압축 스트림으로 복제될때 바이트 정렬된 채로 있는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "제14항에 있어서,상기 HIT와 MISS 코드는 n-바이트 토큰으로 그룹지는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "제28항에 있어서,- 5 -공개특허 10-2009-0021149n은 2의 제곱지수(power)이어서 원시 스트림이나 압축 스트림으로부터 읽혀진 값들은 비압축 스트림으로 복제될때 바이트 정렬된 채로 있는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "제1항에 있어서,상기 방법은 소프트웨어나 하드웨어 인공물(artifact)로서 유한 상태 자동화로 이행되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "제24항에 있어서,상기 방법은 소프트웨어나 하드웨어 인공물로서 유한 상태 자동화로 이행되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제1항에 있어서,상기 HIT와 MISS 코드는 N 비트의 배수인 토큰으로 그룹을 이루며, 원시 스트림으로부터 읽혀진 값들이 압축 스트림으로 복제될 때 바이트 정렬된 채로 있는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "제32항에 있어서,N은 8 비트 길이이고, 상기 히트와 미스 코드가 n-바이트 토큰으로 그룹을 이루며, n은 상기 집합에서의 자연수이고, 원시나 압축 스트림으로부터 읽혀진 값들은 압축 스트림으로 복제될 때 바이트 정렬된 채로 있는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제14항에 있어서,상기 HIT와 MISS 코드/값들은 N 비트의 배수인 토큰으로 그룹을 이루며, 상기 원시나 압축 스트림으로부터 읽혀진 값들은 비압축 스트림으로 복제될 때 N 비트의 배수로 정렬된 채로 있는 것을 특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "제34항에 있어서,N은 8 비트 길이이고, 상기 히트와 미스 코드가 n-바이트 토큰으로 그룹을 이루며, n은 상기 집합에서의 자연수이고, 원시나 압축 스트림으로부터 읽혀진 값들은 비압축 스트림으로 복제될 때 바이트 정렬된 채로 있는 것을특징으로 하는 방법."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "제1항에 있어서,연관 메모리 스킴이 이행되며, 이로써 주어진 메모리 어드레스로부터의 다수 로케이션들이 병행적으로(inparallel) 또는 동시에 비교된다."}
{"patent_id": "10-2008-7025942", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "제14항에 있어서,연관 메모리 스킴이 이행되며, 이로써 주어진 메모리 어드레스로부터의 다수 로케이션들이 병행적으로(inparallel) 또는 동시에 비교된다.명 세 서[관련 출원에 대한 교차 참조] <1>- 6 -공개특허 10-2009-0021149본 출원은 2006년 3월 24일자 출원된 미국 가출원 제60/785,572호에 대한 우선권을 주장하며, 이에 대해 언급함 <2>으로써 본 명세서에 통합된다.기 술 분 야본 발명은 세트 연관 캐시 매핑 기술에 의거한 고속 데이터 압축에 관한 것이다. <3>배 경 기 술혁신적인 정보의 디지털화는 정보기술, 멀티미디어 어플리케이션, 새로운 데이터 포맷 및 지난 20년 이상 번창 <4>해 온 새로운 저장장치를 무수히 탄생시켰다. 디지털 정보를 즉시 이용가능한 포맷으로 변환 및 전달하는 데이터 및 멀티미디어 어플리케이션기술의 증가하는 수에는 텍스트, 이미지 그리고 웹으로 전달되는 영상, 서버에의한 파일 엑세스, 문서 전달, 데이터베이스 조회 및 지리적 매핑기술이 있다. 저장, 전송 및 계산력(computingpower)의 측면에서 이렇게 과도한 멀티미디어 능력을 추진하는데(drive) 필요로 하는 자원(resource)의 양이 위압적일 수 있다.데이터 집약적인 멀티미디어 어플리케이션의 전개를 허용하는 기술적 진전의 하나는 데이터 압축이다. 예를 들 <5>면 과학 정보, 고화질 이미지 및 웹이나 공동 네트워크(corporate network)를 경유하는 라이브 영상 컨텐츠를포함하는 대량 파일의 전달은 일부 데이터 압축의 사용을 수반한다. 마찬가지로 휴대폰이나 다른 무선 기술을경유하는 그러한 등가 서비스의 전송은 이용가능한 통신 대역폭을 효율적으로 사용하는 데이터 압축으로부터 큰이익을 얻을 수 있다.데이터 압축은 메시지, 파일에 저장된 비트 순서(sequence), 메모리 버퍼, 데이터 스트림 등의 정보 내용에서 <6>중복(redundancy)을 제거하는 기술이다. 더 적은 수의 비트로 정보를 표현하면 저장매체에서 더 많은 컨텐츠 공간을 절약하는 결과가 되고, 시간 단위 당 더 많은 데이터를 분배함으로써 전송에 이용할 수 있는 유효 대역폭을 증가시킨다. 그러므로 데이터 압축은 모두를 위한 통신 및 멀티미디어에 맞는 기술을 만드는데 중요한 역할을 해왔고 계속 중요한 역할을 할 것이다.데이터 압축 행위에서, 데이터 압축방법을 언급할 때 두개의 다른 과정이 내포된다. 그 두가지 방법은 압축자 <7>(compressor)와 복원자(reconstructor)로 지칭된다. 문헌에서 일부 순수주의자들이 압축 데이터에 대한 복원 과정을 명백히 의미하기 위해 복원자라는 용어를 사용함에도 불구하고, 후자는 감압자(decompressor) 또는 확대자(expandor)로 더 일반적으로 지칭된다. 복원이라는 용어가 선호되며, 복원 과정을 명백히 언급하기 위해 본 명세서에서 내내 사용된다.압축자는 이름이 의미하는 것처럼 입력 소스를 처리하고 이를 이상적으로 크기가 더 작은 원본의 또 다른 디지 <8>털 표현으로 전환시킨다. 반대로 복원자는 압축 데이터를 처리하고 원본의 복원본(reconstructed version)을 만들어낸다. 소스와 복원된 내용이 정확히 일치하면 그 방법은 손실이 없다고 언명되고, 그렇지 않으면 손실이 있는 것으로 여겨진다. 손실 스킴은 일반적으로 품질 저하를 희생으로 하여 무손실 스킴보다 더 높은 압축비를 얻는다.많은 압축 스킴이 개발되어 수년에 걸쳐 적응되어 왔지만 그들 대부분은 단지 압축 이득만을 개선하는 것을 엄 <9>청 강조해 왔다. 그러나 전형적으로 간과된 한가지 요인은 압축-복원 과정의 속도이다. 멀티미디어 스트리밍,비디오 프로세싱이나 데이터의 무선 전달처럼 시간이 매우 중요한 어플리케이션에서, 압축-복원 (이하, \"코덱(codec)\"으로 칭함)이 압축 이득보다 더 중요하지는 않지만 그 만큼은 중요할 수 있다. 압축이든 복원이든 너무많은 시간을 소모하는 것은 전형적으로 대부분의 실제 시나리오에서는 정당화되지 않는(unjustified) 상품이다.궁극적으로 응답 시간을 결정하고 데이터를 이용하는 어플리케이션의 성능을 구체화하는 것은 채널 대역폭, 코덱 이득과 코덱 속도의 조합이다. 간략히 말하면 데이터가 더 빨리 전달되면 더 빨리 처리되어 이용될 수 있다.그 결과, 시간이 매우 중요한 어플리케이션은 가능해지거나 또는 데이터가 더 빨리 압축되면 보다 최적으로 작업한다. 발명의 상세한 설명본 발명은 데이터 압축방법 및 그 역의 동등한 복원방법에 관한 것이다. 그 방법들은 효율, 고속, 경량, 실시간 <10>및 고도로 구성 가능한(highly configurable), 무손실 데이터 압축을 특징으로 하고, 이 때문에 다양한 통신 요건을 갖는 광범위한 어플리케이션에 적합하다. 본 발명의 신규한 한가지 특징은 압축 데이터를 생성 및 복원하기 위한 워크스페이스로서 의사 캐시 메모리(pseudo cashe memory)를 사용하는 것이다. 이 기술의 초석은 압축- 7 -공개특허 10-2009-0021149과정의 고유 평행성(parallelism)으로 기인한, 하드웨어에서 활용되는 잠재력은 물론 당연히 압축 속도에 유리한 본질적 능력을 갖는 새로운 캐시 매핑 압축(CMC)에 근거하고 있다. 여기서 비슷한 대역폭 조건 하에서 가장최신의 압축자보다 상당히 더 빠르게 데이터 스트림을 처리할 수 있는 속도에 최적화된 하드웨어 코덱 박스가가능하다. 본질적으로 본 발명의 현저한 특징은 다음과 같다.(a) 매우 낮은 메모리 소비 <11>(b) 매우 낮은 시스템 자원 사용 <12>(c) 압축방법 및 복원방법 모두에 매우 높은 실행속도 <13>(d) 대부분의 데이터 포맷에 대한 경쟁적 압축 <14>(e) 고 대역폭에서 압축 시간 + 전달 시간 + 복원 시간을 합하는 효과인 최소 배달 시간 <15>이들 특징은 그 방법이 임베디드 시스템, PDA, SOC (System-on-a-chip) 설계 및 기타 제한적 시스템 자원을 갖 <16>는 다른 하드웨어 장치에 대한 목표가 되게 한다. 또한, CMC방법의 간단함은 하드웨어 구현 또는 소프트웨어 구현을 저렴하게 할 수 있게 한다. 그러므로 본 발명은 무선, 임베디드 및 전자 하드웨어와 소프트웨어 산업에 대하여 잠재적으로 높은 상업적 가치를 갖는다.대부분의 이전 데이터 압축방법과 함께 본 방법은 압축 데이터 스트림을 생성하기 위해 문자 런(character <17>runs) 및/또는 부분 열 일치(partial string matches)에 의해 생성된 중복, 반복 또는 반복 사용된 데이터를 제거함으로써 원시 데이터 스트림의 크기를 줄여준다. 원시 데이터 스트림은 압축되어 할 값들, 즉 N 비트의 열(string, sequence)로 이루어진다. 압축 데이터 스트림은 후술하는 본 압축방법에 근거하여 압축 데이터 스트림에 삽입되는 압축 코드(MISS와 HIT)와 함께 원래 데이터 스트림의 부분 집합으로 이루어진다. 압축은 일부는 원시 데이터 스트림에서 중복, 반복되는 값들을 제거하는 새롭고 신규한 방법에 의해, 그리고 그 압축 스트림으로부터 원시 데이터의 복원을 유도하기 위해 압축 코드인 MISS나 HIT를 압축 데이터 스트림에 삽입함으로써 달성된다.예를 들면 다음의 입력 원시 스트림 \"ABCCCCABDDDD\"는 다음과 같은 압축 스트림 \"<m>A <m>B <m>C <m>C <h(C)> <18><h(C)>, <m>A <h(B)> <m>D <m>D <h(D)> <h(D)>\"로 처리되는데, 여기서 \"<m>\"은 MISS 코드이고, \"<h(X)>>\"는 개별 문자 X에 대한 HIT 코드이다.본 발명의 가장 현저한 이점 중의 하나는 상기 예에서처럼 긴 열 만큼 크게 또는 단일 문자 만큼 작게 설정될 <19>수 있는 크기 조절 가능 블록으로 데이터를 압축하는 능력이다. 블럭 크기가 일단 설정되면 그 방법은 단일 블럭의 입력 데이터가 수용된 후 즉시 압축 데이터 스트림의 출력을 시작하고, 그리고 어느 때나 그리고 어떤 블럭 크기이든 그러한 출력을 중지하고 다시 시작하는 유연성을 갖는다. 이는 필요할 때마다 제 때에 짧은 열 바운더리나 단일 문자 바운더리에 대한 처리를 재개하는 가능성을 함축한다. 이러한 특징들은 함께 \"배타 스트림\"동작 모드를 형성하며, 구체적 압축 매개변수를 특정 데이터 요건에 따라 맞춤화 함으로써 어플리케이션에 상당한 유연성을 제공한다. 배타 스트림 모드 동작은 정상 스트림 모드나 블럭 모드와 명백히 다르다. 블럭 모드에서 대개 소수(a few) 킬로바이트 길이인 한 블럭의 데이터는 압축자에 의해 읽히고 처리되며, 그 후에 압축 데이터가 출력될 수 있다. 정상 스트림 모드에서 압축자는 한 번에 하나의 문자를 읽지만 불명확한 수의 문자들이처리될 때까지 압축 데이터를 출력할 수는 없다. 이러한 불확실성은 어플리케이션의 성능에 영향을 미칠 수 있고, 때때로 그 어플리케이션을 정상 스트림이나 블록에 의한 압축 스킴 하에서 불가능하게 할 수 있다. 본 발명의 배타 스트림 모드는 압축 데이터의 모든 통신이 스트링이나 문자 바운더리 모두에 대하여 공간과 시간에 있어 결정적이게 할 능력을 제공한다. 디지털 통신에서 그리고 채팅 (chat) 소프트웨어 어플리케이션을 위한 배타스트림의 사용에 대한 추가적인 실시예가 상세한 설명에 제공되어 있다.압축과 복원은 모두 의사 캐시 메모리를 워크스페이스로 사용하는 대칭적인 가역(reversible) 과정이다. 그러한 <20>워크스페이스는 상태와 행위에서 컴퓨터 아키텍쳐에서 사용된 실제 캐시 메모리의 동작과 유사하다. 워크스페이스의 구조는 하나 이상의 메모리 어드레스를 포함하는데, 각각의 메모리 어드레스는 하나 이상의 별개 값을 차지하는 하나 이상의 로케이션를 가지며, 그 뒤에는 값들이 어떻게 대체되는지 결정하기 위한 로케이션 선택 정책을 위해 사용되는 임의(optional) 상태 필드가 온다. 압축을 달성하기 위해 값들은 원시 데이터 스트림으로부터 한번에 하나씩 읽혀지고 워크스페이스로 매핑된다. 마찬가지로 값들은 압축 데이터 스트림으로부터 읽혀지고원래의 비압축 데이터 스트림(uncompressed data stream)을 복원하기 위한 워크스페이스로 매핑된다.원시 또는 압축 스트림으로부터 읽혀지는 각각의 값이나 부호의 비트로 된 길이는 상수 N에 의해 결정된다. 워 <21>- 8 -공개특허 10-2009-0021149크스페이스 내의 메모리 어드레스의 수는 상수 K에 의해 결정되며, 2K의 가능한 별개 어드레스를 산출한다. 각메모리 어드레스 내의 로케이션의 수는 상수의(constant) 라인에 의해 결정되며, 메모리 어드레스당 가능한 별개 로케이션과 동일한 수를 산출한다. 모든 상수 N, K와 라인은 본 압축방법 및 복원방법에 의해 정의되며, 그에 따라 각 방법을 분류하기 위해 특정 메트릭스 <N,K,라인>으로 그룹을 이룬다.메모리 어드레스의 수와 각 메모리 어드레스 내의 로케이션 수를 다르게 함으로써 세개의 워크스페이스 배열이 <22>가능하다: 매트릭스 <N,K,1>로 정의되는 직접 매핑 배열(direct-mapped arrangement)은 각자 하나의 값만을 차지하는 많은 메모리 어드레스를 사용하고, 매트릭스 <N,0,라인>으로 정의되는 완전 연관 배열(fullyassociative arrangement)은 많은 값들을 차지하는 하나의 메모리 어드레스만을 사용하고, 그리고 <N,K,Lines>로 정의되고 가장 유연한(flexible) 세트 연관 배열(set associative arrangemen)은 각각 많은 값들을 차지하는 많은 어드레스를 사용한다. 추가 향상 및 변형(variant)과 더불어 기본적인 압축 및 복원 과정을 이행하기위하여 이러한 배열 각각을 워크스페이스로 사용함으로써 신규한 캐시 매핑 압축(CMC)과 복원방법의 집단(family)이 도출된다.본 데이터 압축방법은 특정 매트릭스 <N,K,Lines>를 갖는 워크스페이스 배열을 사용함으로써 데이터 스트림 내 <23>의 중복을 제거한다. 원시 데이터 스트림으로부터의 값들은 쌍을 이루는 다중 비트 길이로 K 비트와 N 비트로버퍼나 윈도우로 읽혀지고 메모러 어드레스 참조, 그리고 현재 부호값 각각으로 복사된다. 그러므로 최초의 K비트는 메모리 어드레스 참조로 읽혀지고 바로 뒤에 오는 N 비트는 처리되어야 할 현재 부호값으로 읽혀진다. K가 0이면 그러면 메모리 어드레스 참조는 0이다. 처리를 위해 이용 가능한 현재 부호값과 메모리 어드레스 참조와 함께, 현재 부호값은 메모리 어드레스 참조에 <24>서의 값들 각각과 비교된다. 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것과도 일치하지 않으면, (a)MISS 코드/값이 압축 데이터 스트림에 추가된다. <25>(b) 현재 부호값이 압축 데이터 스트림에 추가된다. <26>(c) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 하나를 대체한다. <27>(d) 임의로(optionally), 메모리 어드레스 참조 내의 상태 필드는 로케이션 이용(usage)상의 변화를 반영하 <28>기 위해 업데이트된다.그러나 현재 부호값이 그러한 메모리 어드레스 참조에서의 값들 중 어느 것이든 일치하면, <29>(a) 값을 구한 메모리 어드레스 내의 로케이션을 나타내는 HIT 코드/값이 부호화되어 압축 스트림에 추가되 <30>고,(b) 임의로, 그러한 메모리 참조 내의 상태 필드는 로케이션 이용상의 변화를 반영하기 위해 업데이트된다. <31>현재 부호값이 메모리 어드레스 참조를 컨텍스트로 이용하여 처리된 후에 버퍼나 윈도우는 원시 데이터 스트림 <32>이 소모되어 완전한 압축 데이터 스트림이 생성될 때까지 다음 쌍의 데이터 값을 준비하여 N 비트 오른쪽으로이동된다.원시 데이터는 전술한 것처럼 압축방법을 거꾸로 하여 압축 데이터로부터 복원된다. 복원방법은 압축방법 중에 <33>사용된 동일한 워크스페이스를 다시 압축방법과 관련하여 전술한 특정 메트릭스 <N,K,Lines>과 함께재사용한다. 복원방법은 이전에 비압축 스트림으로 출력된 이전 K 비트를 메모리 어드레스 참조로서 읽어온다.K가 0이면 아무런 비트도 읽혀지지 않고, 메모리 어드레스 참조도 0이다. 다음으로 복원방법은 MISS 코드가 복호될 때까지 한 번에 하나씩 압축 데이터를 읽는다.복호화 된 값이 MISS 코드이면, <34>(a) 압축 스트림으로부터 N 비트가 현재 부호값으로 읽혀진다. <35>(b)현재 부호값이 비압축 스트림에 추가된다. <36>(c) 현재 부호값은 메모리 어드레스 참조에서의 값들 중 하나를 대체한다. <37>(d) 임의로, 그러한 메모리 어드레스 참조 내의 상태 필드는 로케이션 이용상의 변화를 반영하기 위해 업데 <38>이트된다.그러나 복호화된 값이 HIT 코드이면, <39>- 9 -공개특허 10-2009-0021149(a) N 비트들은 상기 복호화된 값에 의해 규정된 로케이션에서 메모리 어드레스 참조로부터 현재 부호값으 <40>로 읽혀진다.(b) 임의로, 그러한 메모리 어드레스 참조 내의 상태 필드는 로케이션 이용상의 변화를 반영하기 위해 업데 <41>이트된다.(c)마지막으로 현재 부호값이 비압축 스트림에 추가된다. <42>메모리 어드레스 참조를 컨텍스트로 이용하여 현재 부호값이 처리된 후에 메모리 어드레스 참조는 이전에 비압 <43>축 스트림으로 출력된 이전 K 비트로 업데이트되고, 그 방법은 압축 데이터 스트림이 완전히 처리되어 완전 복원된 비압축 데이터 스트림이 생성될 때까지 HIT나 MISS 코드/값을 계속 읽고 복호화한다. 메모리 어드레스 참조를 만들 K 비트를 읽기 위해 비압축 데이터 스트림 상에서 수행되는 입력 동작은 바람직하지 않거나 또는 심지어 압축 스트림이 본질적으로 \"출력\" 스트림이기 때문에 전혀 가능하지 않을 수 있다는 것에 유의하시오. 출력 스트림 상의 이러한 입력 동작은 현재 부호값으로부터 메모리 어드레스 참조까지 N 비트의 왼쪽 이동 동작,그 결과로써 당연히 N 비트 왼쪽으로 이동하는 동작을 수행함으로써 방지될 수 있다.일 형태로 본 발명은 하나 이상의 별개 값을 각자 차지하는 하나 이상의 로케이션을 사용하는 값들의 열을 포함 <44>하는 원시 데이터 스트림으로부터 데이터를 복원하기 위한 방법에 관한 것이다. 그 방법은 다음을 포함한다. (a) K가 0보다 크면 원시 스트림에서 현재 리딩 포인트 직전인 K 비트를 원시 데이터 스트림으로부터 메모리 어 <45>드레스 참조로 읽어오고,(b) N 비트를 원시 스트림으로부터 현재 부호값으로 읽어오고, <46>(c) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것하고도 일치하지 않으면 메모리 어드레스 참조 <47>에 있는 값들 중 하나를 대체하기 위해 현재 부호값을 기록하고, 현재 부호값이 뒤따르는 MISS 코드/값을 압축데이터 스트림에 기록하고, 그리고(d) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것이든 일치하면 그 값을 찾아낸 메모리 어드레스 <48>참조 내의 로케이션을 표현하는 HIT 코드를 압축 데이터 스트림에 기록한다.(a)에서 메모리 어드레스 참조의 가장 왼쪽 비트가 원시 데이터 스트림으로부터 읽는데 이용할 수 없으면 적절 <49>히 초기화되며, 각 메모리 어드레스에서의 모든 값들의 초기화 후에 원시 데이터 스트림에서 각 값에 대하여(a) 내지 (d)를 반복할 수 있다.다른 형태로, 본 발명은 각 컴퓨터 메모리 어드레스가 하나 이상의 별개 값을 각각 차지하는 하나 이상의 로케 <50>이션을 갖는 하나 이상의 별개 컴퓨터 메모리 어드레스를 워크스페이스로 이용하여 MISS와 HIT 코드를 포함하는압축 코드와 함께 적어도 원시 데이터의 일부를 포함하는 압축 데이터 스트림으로부터 비압축 원시 데이터 스트림을 복원하는 방법에 관한 것이다. 이 방법은 다음을 포함한다.(a) K가 0보다 크면 비압축 스트림에서 현재 삽입 포인트 직전인 K 비트를 상기 비압축 스트림으로부터 메모리 <51>어드레스 참조로 읽어오고,(b) 코드값을 상기 비압축 스트림으로부터 읽어오고, 상기 코드값은 HIT로 암호화된 로케이션이나 MISS 발생을 <52>표현하고,(c) 상기 값이 MISS 코드이면 N 비트를 상기 비압축 스트림으로부터 현재 부호값으로 읽어오고, (a)에서 얻은 <53>상기 메모리 어드레스 참조에서의 값들 중 하나를 대체하기 위해 현재 부호값을 기록하고, 현재 부호값을 비압축 스트림에 기록하고, 그리고(d) 상기 값이 HIT 코드이면 N 비트를 (a)에서 얻은 메모리 어드레스 참조에서 복호화된 HIT 코드에 의해 주어 <54>지는 로케이션으로부터 읽어오고, 현재 부호값을 비압축 스트림에 기록한다.실 시 예본 캐시 매핑 압축(CMC) 방법은 컴퓨터 내에서 중앙처리장치(CPU)와 메인 메모리 사이에서 일어나는 내부 데이 <67>터 캐싱 메커니즘과 닮은 모델에 근거하고 있다. 한가지 차이점은 본 CMC 방법은 컴퓨터 아키텍쳐의 경우에서처럼 메모리 엑세스를 빠르게 하기 보다는 오히려 압축을 생성하기 위한 시도로 캐시의 데이터 지역성(localityproperties)을 활용하는 것이다. 본 명세서에서 설명하는 CMC 방법은 유한 상태 자동화(finite stateautomation)에서의 상태들을 표현하며, 그 자체로써 소프트웨어나 하드웨어 인공물(artifact)로 이행될 수- 10 -공개특허 10-2009-0021149있다. 본 명세서 내내 사용된대로 데이터 압축을 언급할 때 입력 및 출력 스트림은 각각 원시 스트림과 압축 스트림을 가리킨다. 마찬가지로 복원할 때 입력 및 압축 스트림은 각각 압축 스트림과 복원 스트림에 대응한다.본 방법은 원시 스트림과 복원 스트림을 블록으로 불리는 고정된 길이의 N-비트 값들의 순서로 간주한다. 원시 <68>부호를 직접 처리하는 대신에 N-비트 데이터 블럭에서 동작하는 이유는 두가지이다. 첫째는 블럭이 캐시 내의최소 데이터 전달 단위인 캐시 라인과 동일한 크기이고, 둘째는 블럭 크기가 비트로 된 원시 부호의길이와 독립적으로 설정될 수 있다는 것이다. 이는 다음에는 압축 매개변수에 대한 더 많은 제어를 허용하며, 원시 스트림의 특징들과 더 잘 일치하며 그러므로 더 나은 압축비를 시도하게 해준다. 그러나 명료성을 위하여 제안한 청구범위를 제출할 때 N-비트 데이터 블럭은 또한 현재 부호값으로 언급된다.CMC 압축방법은 원시 스트림으로부터 한 번에 하나의 N-비트 데이터 블록을 읽어온다. 현재 블록이 캐시 내의 <69>특정 위치에서 발견되면 히트(hit)가 일어난다. 그렇지 않으면 미스(miss)가 발생된다. 다음으로 압축방법은 현재 데이터 블럭이 뒤따르는 두 개의 가능한 순서, 즉 H 비트로 이루어진 Hit 코드나 M 비트로 이루어진 Miss 코드 중 하나를 출력한다. 압축방법은 원시 스트림으로부터 모든 블록이 처리될 때까지 지속한다.도 1은 압축 이전 그리고 이후 B, A, B, C의 임의의(arbitrary) 스트림 상태를 도시한다. 예를 들면 입력 순서 <70>가 {B, A, B, C...}라면 가상 압축 출력 순서는 {(A에 대하여) <miss> <B>, <hit>, (B에 대하여) <hit>,<miss> <C> ...}이다. 두 순서를 비교하면 첫번째와 마지막 블럭은 각 미스에 대하여 M 비트의 확장을 특징으로하는 반면에 중간의 두 블럭은 각 블럭에 대하여 (N-H) 비트의 압축 인자를 제공하는 것을 알 수 있다. 그러므로 전체 히트 수를 알면 압축비를 정확히 계산하는 것이 가능해진다.미스 코드와 히트 코드 간에는 개념적 차이가 있다. 미스 코드는 단순히 블린 마커의 역할을 하고, 복원자에게 <71>미스가 일어났다는 것을 알려주고, 그 때문에 다음에 미스 블럭이 뒤따른다는 것을 알려준다. 반대로 히트 코드는 블럭이 성공적으로 캐시되었다는 것을 가리킬 뿐만 아니라, 캐시 메트릭스에 따라서는 히트 코드가 히트가일어난 세트의 라인 번호도 암호화해야 한다는 것을 가리킨다. 미스 코드는 편의상 1 비트값으로 정의되지만,양자에 대한 평균 길이 코드를 최소화하기 위해 히트 코드 길이와 교환이 이루어질 수 있다는데 유의하시오. 라인 번호와 세트는 또한 로케이션 번호와 메모리 어드레스 참조로 각각 지칭되는 것에 유의하시오.도 1에서 출력 순서의 시각적 검사에 의해, 더 많은 히트 코드가 출력에서 출현할 때 압축이 개선되고, 반면에 <72>히트와 미스에 대한 코드 길이가 증가할 때 압축이 열화되는 것이 명백하다. 히트의 수는 세트당 더 많은 라인을 배열함으로써 극대화할 수 있지만, 불행히도 그렇게 하면 히트 코드 길이를 증가시킨다. 그러므로 분명히 최소화 문제가 수반된다.현재 블럭이 캐시의 특정 위치에서 발견되면 히트가 일어난다. 현재 블럭이 실제 매핑되는 특정 위치는 매우 중 <73>요하다. 이 매핑은 먼저 히트의 생성을 허용하는 것이고, 도 1이 나타내는 것처럼 압축을 달성하기 위해 출력순서의 크기를 줄이게 허용해 준다. 블럭을 캐시되게 하기 위해서는 두 개의 입력: 블럭과 어드레스가필요하다. 어드레스는 블럭이 매핑될 캐시 세트를 결정하며, 그러므로 \"캐시 매핑 어드레스\"로도 불린다.후속(incoming) 블럭에 대한 적절한 매핑 어드레스 기능을 추출하기 위하여 전형적으로 텍스트에서 활용될 수 <74>있는 데이터 중복의 유형을 시각화(visualize)하는게 중요하다. 다음 순서를 살펴보자.ABCCCCABDDDD...이 순서에서 단지 하나의 스트링 일치(두번째 서브스트링 \"AB\"와 일치하는 서브 스트링 \"AB\")와 <75>두개의 문자 런(\"CCC...\"과 \"DDD...\")이 있다. CMC 압축자를 효과적으로 하기 위해서 후속 블럭(문자)이 캐시에서 이미 마주친 블럭에 대하여 히트를 생성하게 함으로써 이들 중복을 활용해야 한다. 이는 양자에 대해 동일한매핑 어드레스를 얻도록 변환되며, 그래서 비교될 때 그들의 불럭 컨텐츠는 일치해진다. 상기 순서에서 처음 세문자 \"ABC\"가 이미 처리되었다고 가정해 보자. 그러한 캐시 상태는 도 1에 도시되어 있다.표 1 <76>매핑 어드레스 <77> 캐시 라인? A? B? C뒤따르는 다음 \"CCC...\" 문자 런에 대한 히트를 구하기 위해 후속 C 각각은 앞서 마주친 \"C\"와 동일한 매핑 어 <78>드레스에서 캐시되어야 한다. 이는 캐시 매핑 어드레스에 대한 입력으로 이전 문자들 차체를 사용하도록, 즉 캐- 11 -공개특허 10-2009-0021149시 매핑 어드레스를 생성하기 위해 이전 문자들과 등가의 컴퓨터 이진 표현을 사용하도록 이끈다. 결과적으로\"C\" 문자가 이전 문자 \"C\"의 기능인 매핑 어드레스의 라인에서 캐시되면 새로이 연속된 \"C\" 문자들은 비교될 때매핑 어드레스가 같아지므로 히트를 생성한다.도 2는 매핑 어드레스 K가 8 비트 길이이고 현재 블럭 크기 N도 8 비트 길이이고, 각 메모리 어드레스가 단지 <79>데이터 블록을 차지하기 위한 하나의 로케이션을 포함할 때의 CMC 압축방법을 보다 상세하게 예시한다. 원시 스트림으로부터 읽어오는 현재 블럭은 현재 문자(8 비트)를 수용하고, 매핑 어드레스에 이전 문자(8 비트)가 배정된다. 압축방법은 그저 원시 스트림의 처음 8 문자를 처리하고 그 결과로 나온 순서를 압축 스트림으로 출력한다. 미스 코드와 히트 코드는 각각 <m>X와 <h(X)>로 표현되며, X는 미스나 히트가 되는 블록이다. 도 2는 또한(두번째 서브 스트링 \"AB\"가 처리된 후의) 캐시의 현재 상태와 (마지막 \"D\" 문자가 처리된 후의) 최종 상태를도시한다. 히트는 캐시내의 원내에 표시되고, 나머지는 미스이다.도 2에 도시된 것처럼 압축 과정은 두번째 서브스트링 \"AB\"를 검출하고 문자 \"B\"에 대한 대응 히트를 생성함으 <80>로써 문자 런 \"CCC...\"와 \"DDD...\" 뿐만 아니라 스트링 매치도 검출한다. 캐시 라인은 주어진 시간에 단지 하나의 블럭만을 차지한다는 것에 유의하시오. 이는 도 4와 관련하여 후에 보다 상세하게 설명될 직접 매핑 캐시 배열에 대한 경우이다. 최우측 문자는 캐시에서 가장 최근의 블럭을 나타낸다. 히트가 일어날 때 현재 블럭은 그러한 블럭이 결국 히트가 되는 것을 나타내기 위해 예시를 위하여 원을 가진 캐시로 표현된다. 매핑 어드레스는실제로 캐시에서의 특정 세트를 가리킨다.CMC 코덱은 사용된 내부 캐시 구조와 긴밀하게 결합된다. 따라서 캐시 매트릭스를 변경하면 예를 들면 세트당 <81>라인 수는 본 압축방법의 행위를 철저히 변화시키는 효과를 갖는다.본 CMC 방법은 세 개의 매개변수 (N,K,Lines)와 한 개 코드의 측면에서 정의될 수 있다. 매개변수는 내부 캐시 <82>의 메트릭스(블럭당 비트, 세트 어드레싱을 위한 비트, 라인 수)를 기술하고, 코드는 압축 스트림에서의 히트와미스를 표현하는데 사용되는 인코딩을 정의한다. 라인은 또한 2L 라인을 암호화하는데 필요한 비트의 수인 L의측면에서 정의될 수 있다.본 CMC 압축방법은 세 개의 특정 캐시 구조 중 어느 하나를 이용하여 유리하게 이행될 수도 있다. 세 개의 캐시 <83>구조는 본 압축방법의 세가지 특정 형태를 정의하고 다음과 같이 일컬어진다: 직접 매핑, 세트 연관 또는 전체연관. 세 가지 방법은 설명을 위하여 의사 코드를 참조하여 설명되며, 의사 코드는 본 압축방법을 더 잘 이해하고 이행에 대한 상세 내역없이 세가지 유리한 이행을 제공하기 위한 것으로 이는 본 기술에 대한 보통의 지식을가진 사람에게는 명백할 것이다. 전체적으로 도 3을 참조하면 방법 10은 본 CMC 방법의 전체적 이행을 묘사한다. 방법 10은 하나 이상의 별개 컴 <84>퓨터 메모리 어드레스를 워크스페이스로 이용하여 값들의 열(string)을 포함하는 원시 데이터 스트림으로부터데이터를 압축한다. 각각의 컴퓨터 메모리 어드레스는 각각 하나 이상의 별개 값들을 차지하기 위한 하나 이상의 로케이션을 갖는다.K가 0보다 크면 원시 데이터 스트림에서 현재 리딩 포인트 바로 직전에 있는 K 비트들은 메모리 어드레스 참조 <85>로써 원시 데이터 스트림으로부터 읽혀지거나 입력된다 (단계 20). 현재 리딩 포인트 앞에 비트가 없으면 아무런 K 비트도 읽히지 않으며, K에는 값 0이 배정될 것이다. 예를 들어 도 3과 함께 도 2를 참조하면 원시 데이터스트림이 \"AACCCCABDDD\"라면 처음의 제1 리딩 포인트는 첫번째 A이다. A가 제1 위치에 있기 때문에 A를 앞서는비트들은 없다. 그러므로 아무런 K 비트도 원시 데이터 스트림으로부터 읽혀지지 않는다. 따라서 K에는 값 0이배정된다.다음으로 K 비트들은 본 예제에서 A인 현재 부호(심볼)값으로써 원시 스트림으로부터 읽혀진다 (단계 30). <86>부호값이 메모리 어드레스 참조에서의 값들 중 어느 것하고도 일치하지 않으면 메모리 어드레스에서의 값들 중 <87>하나를 대체하기 위한 현재 부호값, 즉 A가 기록된다. 이 외에도 현재 부호값이 뒤따르는 미스 코드 \"<m>\"은 압축 데이터 스트림에 기록된다. 본 예제에서 현재 부호값, 즉 A는 메모리 어드레스의 어느 값, 실제로는 유일한값인 0하고 일치하지 않으며, 그러므로 A가 뒤따르는 미스 코드 <m>은 압축 데이터 스트림에 기록된다 (단계40).히트 코드는 메모리 어드레스 참조에서 값이 발견된 로케이션을 나타내며, 그러한 현재 부호값이 메모리 어드레 <88>스에서의 값들 중 어느 것이든 일치하면 압축 스트림에 기록된다 (단계 50). 본 예제에서 값 A가 메모리 어드레스 0에서의 메모리 어드레스 내의 어떤 로케이션에서든 발견되지 않았기 때문에 히트 값은 압축 데이터 스트림- 12 -공개특허 10-2009-0021149에 기록되지 않는다.단계 60에서는 각 메모리 어드레서의 모든 값을 초기화한 후에 원시 데이터 스트림에서의 각각의 값에 대하여 <89>그 방법이 반복되는데, 메모리 어드레스 참조의 가장 왼쪽의 비트들은 이용가능하지 않으면 원시 데이터 스트림으로부터 적절히 초기화된다 (단계 60). 따라서 단계 20은 원시 데이터 스트림으로부터의 K 비트가 지금 B인 현재 리딩 포인트 바로 앞에서 읽혀지거나 입력되는 경우에 처음으로 반복되고, 메모리 어드레스 참조에는 현재리딩 포인트 직전의 값, 즉 A가 배정된다 (단계 20). 다음에 값 B는 원시 데이터 스트림으로부터 N 비트로 읽혀지고, 현재 부호값이 배정된다 (단계 30). 단계 40에서 현재 부호값은 현재 부호값, 즉 B가 메모리 어드레스 A에서의 어느 값, 실제로는 유일값과 일치하지 않기 때문에 메모리 어드레스 A에서의 값을 대체하기 위해 기록된다 (단계 40). 이어서 현재 부호값, 즉 B가 뒤따르는 미스 코드는 압축 데이터 스트림을 대체하기 위해 기록된다. 그 결과 현재 압축 스트림은 이제 <m>A<m>B를 포함한다.방법 10은 다음 두 개의 값, 즉 C와 D에 대하여 두번 더 반복된다. 방법 10의 5번째 반복 중에 왼쪽으로부터 세 <90>번째 C인 제5값이 원시 스트림으로부터 N 비트로 읽혀지고 (단계 30), 또한 C인 바로 직전의 값이 메모리 어드레스 참조로 입력된다 (단계 20). 단계 40에서 현재 부호값 C는 사실상 C에 대응하는 메모리 어드레스에서의 현재 값과 일치하지 않기 때문에 미스 코드나 현재 부호값은 압축 스트림에 기록되지 않는다. 대신에 단계 50에서값 C가 발견된 메모리 어드레스 참조에서의 로케이션을 나타내는 히트 코드는 현재 부호값 C가 메모리 어드레스참조 C에서의 값들 중 하나와 일치하므로 압축 데이터 스트림에 기록된다. 따라서 현재 압축 데이터 스트림은이제 <m>A, <m>B, <m>C, <m>C <h(C)>이다. 그리고 나서 방법 10은 모든 값들이 처리될 때까지 반복된다. 방법 10은 압축 이득, 즉 원시 데이터 스트림에 대한 압축 데이터 스트림의 크기는 물론 처리 시간과 효율을 최 <91>적화하기 위해 바라는 대로 변경될 수 있다. 예를 들면 단계 20에서 읽혀진 K 비트는 메모리 어드레스 참조로사용되는, 결과어(resulting word)를 생성하기 위해 더 적은 수 또는 동수의 비트로 환원(reduced)/변환될 수도있다. 예를 들면 읽혀진 K 비트는 그 후 아마도 워크스페이스 크기를 줄이려고 하는 해시 전략(hashingstrategy) 후에 동수 또는 더 적은 수의 비트로 변환되고, 그리고 나서는 압축방법과 복원방법 양자를 위한 연속 단계에서 메모리 어드레스 참조로써 사용된다.K 비트를 더 적은 수의 비트로 변환시키고, 그러므로 워크스페이스에 필요한 메모리의 양을 줄이는 한가지 방식 <92>은 K 비트가 K-비트값을 메모리 어드레스 참조로 사용되기 전에 더 작은 R-비트값으로 변환시키는 해시 함수(hash function)를 사용하는 것이다. 간단하지만 강력한 해시 함수를 예시하기 위해 두 정수를 나눈 나머지에내는 모듈러스 연산자를 고려해 보자. 즉 D와 d가 정수이고 D>d이라면 \"D 모듈러스 d\"는 D/d의 나머지를 내고,0과 d-1 사이의 또 다른 정수가 되는 것이 보장된다. 이는 원시 스트림으로부터 읽혀지는 모든 2K 메모리 어드레스가 이용가능한 워크스페이스 메모리에서 어드레스할 수 없다면 매우 편리할 수 있다. 그러한 경우에 D에는 원래 메모리 어드레스 참조가 배정되고 d에는 이용 가능한 실제 메모리 어드레스의 총수인 2R이 배정되고, \"D 모듈러스 d\"의 결과가 환원된 새로운 메모리 어드레스에 배정되며 그 이후에는 워크스페이스를 어드레스하기 위해사용된다.이 외에도 단계 20에서 메모리 어드레스의 임의 상태 필드는 메모리 어드레스 내의 로케이션 이용을 추적하는데 <93>사용될 수 있다. 그러면 그 방법이 단계 40이나 50에서 진행되므로 상태 필드는 메모리 어드레스로서 값을 읽거나/기록한 후에 업데이트된다. 상태 필드는 미스가 일어날 때 값들이 어떻게 대체되는지 추적하는 세트 연관 압축방법에 사용된댜.상태 필드는 미스가 일어날 때, 즉 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것하고도 일치하지 <94>않을 때의 값을 대체하기 위해 사용되는 전략에 따라서 다르게 이용되기도 한다. 전략과 상관없이 기대하는 것은 상태 필드가 특정 메모리 어드레스에 대한 값을 대체할 때 사용할 로케이션의 최선의 평가를 제공한다는 것이다. 실제에 있어 상태 필드는 로케이션이 메모리 어드레스에 존재하는 수 만큼의 카운터를 포함한다. 각각의카운터는 적절한 특정 대체(replacement) 정책에 따라 각 로케이션이 대체되어야 할 순서(order)를 나타내는 순위(rank)를 저장함으로써 특정 로케이션을 추적한다. 예를 들면 메모리 어드레스당 4개의 로케이션을 갖는 가장덜 최근에 사용된(LRU) 대체 전략과 각 로케이션과 연관된 4개 카운터 각각에 저장된 다음의 값 3, 1, 0, 2을일부 포인트에서 포함하는 상태 필드를 가정해 보자. 이는 메모레 어드레스의 로케이션 번호 0, 1, 2, 3이 값3, 1, 0, 2를 가지고 상태 필드에서 연관LRU 카운터를 가진다는 의미이다. LRU 전략 하에서 이는 로케이션 0는값 3을 갖는 최고 LRU 카운터를 갖기 때문에 가장 최근에 사용된 것이고, 다음은 LRU 카운터=2인 로케이션 3이고, 로케이션 1은 LRU 카운터=1을 가지고 그 뒤를 따르며, 마지막으로 로케이션 2는 LRU 카운터=0를 갖고 뒤따른다는 것을 의미한다. 그러므로 어느 값이 대체되어야 할 때 대체하기 위해 가장 낮은 LRU 카운터 값과 연관된- 13 -공개특허 10-2009-0021149로케이션 번호가 선택되고, 아니면 이 경우에 대체 전략 자체가 제시하는 것처럼 가장 덜 최근에 사용된 로케이션을 나타내므로 로케이션 2가 선택된다. 한편 상태 필드는 가장 오래된 값 대체 정책에서처럼 또 다른 정책이사용되면 다르게 이행될 수도 있는데, 그에 의하여 상태 필드는 바람직하게는 카운터 대신에 선입선출(FIFO) 대기 행렬(queue)로 인식되며, 새로이 대체된 로케이션들이 대기 행렬의 앞에 추가되고, 대체를 위해 사용된 가장오래된 로케이션은 꼬리(tail)로부터 얻어진다. 사용된 대체 전략과 상관없이 상태 필드는 미스가 일어난 후에값을 대체할 때 어느 로케이션이 선택되어야 할 지를 결정하기 위해 사용된다.방법 10은 다양한 캐시 구조를 사용하고, 직접 매핑 CMC 방법 100 (도 4), 세트 연관 CMC 방법 200 (도 5)와 전 <95>체 연관 CMC 방법 300 (도 6)을 비롯한 다양한 압축 스킴을 포함하기 위해 변경될 수 있다.도 4를 참조하면 일반적으로 방법 100은 간단한 캐시 배열을 채용한다. 이 배열에서 캐시는 세트당 1줄로 이루 <96>어지는데, 단지 하나의 데이터 블럭만 특정 세트에 저장될 수 있다. 그러므로 캐시 메트릭스는 <N,K,1>이다. 이구조는 수반하는 대체 정책이 없거나 아니면 반대로 전략이 최소이므로, 예를 들면 미스가 일어나면 세트에서이용 가능한 유일한 블럭을 대체하므로 내부 블럭 취급을 단순화시킨다. 직접 매핑 캐시는 세트 연관 압축방법200과 전체 연관 압축방법 300에서 이행되는 대체 정책에 대한 상태 비트를 필요로 하지 않는다. 그러므로 직접매핑 캐시는 본 발명의 다른 특징에 따라서 세트 연관이나 전체 연관 캐시보다 더 빠르고 자원에 덜 집중한다.그러나 교환은 다른 배열과 비교했을 때 히트율이 더 낮다.이제 구체적으로 도 4를 참조하면 직접 매핑 CMC 압축방법 100은 선언된 현재 블럭, 라인과 세트를 차지하는 변 <97>수를 찾는 것을 포함한다. 다시 이것들은 각각 현재 부호값, 로케이션 번호와 메모리 어드레스 참조를표현한다. 방법 10 (도 3)의 유사 단계들이 도 4에서 100으로 늘어난다. 세트는 0으로 초기화된다 (단계 105).N 비트는 원시 데이터 스트림으로부터 읽혀지고 블럭으로 복사되며, 스트림이 파일을 지칭하면 연관된 파일 포인터가 없데이트, 즉 N 비트만큼 전방으로(forward) 이동한다 (단계 130). 데이터 블록은 데이터 스트림의 끝에도달하지 않는 한 원시 스트림으로부터 읽혀진다 (단계 130).현재 블록은 특정 세트에서 조사되고, 직접 매핑 캐시에서는 세트당 오직 1줄만이 있기 때문에 유일한 그 줄이 <98>조사된다 (단계 134). 블록이 해당 라인의 내용과 일치하지 않으면 미스가 일어나고, 그 블럭은 캐시 라인에 기록된다 (단계 136).나아가 블록이 발견되지 않으면 \"미스\" 코드나 마커 역할을 하는 1비트 값이 압축 스트림에 기록된다 (단계 <99>140). 마커의 값은 상수 MISS이다 (단계 140). 나아가 현재 블록은 압축 스트림에 기록된다 (단계 142). 압축데이터 스트림의 복원이나 감압 중에 미스가 일어나기 때문에 그 복원방법은 상세히 후술하는 것처럼 캐시로부터 블록을 얻을 수 없다. 그러므로 블록은 나중에 복원될 수 있도록 압축 스트림에 복제될 필요가 있다 (단계142).대신에 블럭이 발견되면 (단계 136) 히트가 일어났다는 것을 가리키기 위해 1 비트 값이 압축 스트림에 기록된 <100>다 (단계 150). 히트 마커는 캐시로부터 블록을 추출하기 위한 복원방법 중에 사용된다. 직접 매핑 방법 100에는 세트당 1줄만 있기 때문에 단계 150에서 압축 스트림에 라인 번호를 암호화할 필요가 없다.현재 세트의 값은 방법 100의 다음 반복을 위해 준비된다 (단계 160). 업데이트 과정은 도 2에 도시된 것처럼 <101>각 반복 라운드 종료 시에 N 비트를 오른쪽으로 이동시키고 스트림 내의 해당 포인트에서 K 비트를 읽어오는 원시 스트림의 위에 있는 \"이동 플레이스홀더(shifting placeholder)\"와 개념적으로 유사하다. 이 동작은 현재 블록이 원시 스트림으로부터 방금 읽혀진 동일한 N 비트를 포함하기 때문에 세트 변수 N 비트의 내용을 왼쪽으로이동시키고 블록으로부터 N 비트를 읽어오는 것과 기본적으로 같다.직접 매핑 압축방법 100은 메트릭스 <N,K,1>을 갖는 특정의 직접 매핑 워크스페이스를 이용한다. 이 배열에서 <102>메모리 어드레스당 단지 하나의 로케이션이나 라인이 사용되는데, 하나의 값만이 저장되게 한다. 이는 정책이나상태 필드 어느 것도 필요로 하지 않기 때문에 미스된 값의 대체를 하찮게 한다. 또한 각 메모리 어드레스가 하나의 값만을 저장하기 위한 하나의 로케이션을 갖기 때문에 HIT 코드는 현재 메모리 어드레스 참조에서 찾아낸값의 단순한 발생, 즉 히트 자체의 발생을 표현한다.이제 도 5를 참조하면 방법 200은 현재 압축방법의 세트 연관 CMC 압축방법 형태이며, 방법 10과 방법 100에 대 <103>한 유사 단계가 각각 100과 200으로 상승한다. 방법 100처럼 단계 205에서 블럭, 라인과 세트가 초기화된다. 다음 데이터 블럭은 원시 데이터 스트림으로부터 읽혀진다. 직접 매핑 방법 100과 다르게 조사할 라인이 두 개 이상이다. 그러므로 특정 세트로부터의 모든 라인들이 조사된다 (단계 234). 블럭이 어느 라인의 내용과도 일치하지 않으면 미스가 일어나고 그 블럭은 캐시에 기록된다 (단계 236).- 14 -공개특허 10-2009-0021149방법 100과 유사하게 블럭이 발견되면 히트를 가리키는 1 비트 값이 압축 스트림에 기록된다 (단계 250). 그러 <104>나 세트당 2 라인 이상이기 때문에 비압축 데이터 스트림의 복원 중에는 복원방법이 어느 라인으로부터 블록을회수(retrieve)해야 할 지 알 방법이 없다. 결과적으로 히트 마커는 충분치 않으며 복원방법은 다음 단계로 전달될 히트가 일어난 곳의 라인 번호를 필요로 한다.히트 마커가 기록된 후에 히트가 일어난 곳의 라인 번호는 암호화되어 압축 스트림에 기록된다 (단계 252). 암 <105>호화는 라인을 식별하기에 충분하기만 할 필요가 있고, 그러므로 라인 번호의 2진 표현을 차지하는 L 비트로 이루어진 고정 코드 길이만큼 간단하다 (단계 252).그러나 미스가 일어나면 단계 200이 단계 100과 비슷한 방식으로 진행되는데, 미스 마커를 압축 스트림에 기록 <106>하고 (단계 200), 미스 블럭을 압축 스트림에 기록하는 (단계 242) 것을 포함하고, 현재 세트의 값은 다음 반복을 위해 준비된다 (단계 260).방법 200의 구체적인 후속 이행에서, 방법 200은 값을 대체할 때 어느 로케이션을 이용해야 하는지 결정하기 위 <107>한 대체 정책을 더 포함할 수 있다. 이는 그 방법이나 함수 SearchBlock_WriteIfMiss() (단계 236)에 의해 내부적으로 이루어진다. 전형적인 대체 정책은 가장 바람직한 것에서 가장 덜 바람직한 순서로 가장 덜 최근에 사용된(LRU), 선입선출(FIFO) 또는 가장 오래전 사용된, 가장 덜 빈번히 사용된(LFU), 랜덤(random) 등을 포함한다. 이들 대체 정책들과 연관되는 방법들은 블럭이 캐시 내부에서 어떤 이유로든 엑세스될 때마다 방법들ReadBlock()와 SearchBlock_WriteIfMiss() 내부에서 구해진다(invoked) (단계 230과 단계 236). 대체 정책이 어떻게 작업하는지 이해하기 위해, 다음의 구체적인 예를 가지고 가장 덜 최근에 사용된(LRU) 대체 <108>정책이 다음으로 설명된다. 4개 로케이션을 갖는 메모리 어드레스와 각 어드레스와 연관된 4개 LRU 카운터를 포함하는 상태 필드를 고찰한다. 압축 과정 중의 일부 지점에서 LRU 카운터는 값들 3, 0, 2, 1을 각각 포함한다고가정한다. 이는 연관된 LRU 카운터가 최대값 3을 갖기 때문에 로케이션 0가 가장 최근에 이용된 로케이션이고,반면에 연관된 LRU 카운터가 최소값 0을 갖기 때문에 로케이션 1이 가장 덜 최근에 사용된 로케이션이다. 그러므로 미스가 일어날 때 그것이 가장 덜 최근에 사용된 것이라는 것을 나타내는 LRU 카운터가 0이기 때문에 대체를 위해 로케이션 1이 선택된다. 이제 히트가 로케이션 3에서 일어난다고 가정한다.이 예제에서 LRU 카운터는 다음과 같이 업데이트된다. 로케이션 3이 이제 가장 최근에 사용된 것이기 때문에 모 <109>든 LRU 카운터들은 따라서 로케이션 이용에 새로운 변화를 반영하기 위해 업데이트될 필요가 있다. 이는 LRU 카운터를 업데이트하는 일반적 과정이고, 히트가 일어난 로케이션과 연관되는 현재 LRU 카운터 값은 T로읽혀진다. 다음으로 T보다 큰 값을 갖는 모든 LRU 카운터는 1씩 줄어든다. 마지막으로 현재 LRU 카운터에는 최대값이 배정되며, 그러므로 가장 최근에 이용된 로케이션이라는 태그가 붙는다. 그러므로 히트가 현재 카운터값들 3, 0, 2, 1을 갖는 로케이션 3에서 일어날 때 그러한 카운터들은 다음과 같이 업데이트된다. T에는 로케이션 3의 LRU 카운터 값인 1이 배정된다. 다음으로 T보다 큰 값을 갖는 모든 LRU 카운터들은 1씩 줄어든다. 그래서 LRU 카운터들은 2, 0, 1, 1이 된다. 마지막으로 현재 LRU 카운터에는 최대값 3이 배정된다. 이 때문에 LRU카운터는 이제 2, 0, 1, 3이 된다. 간략하게 LRU 대체 정책은 각 로케이션에 대한 이용 순위(usage rank)를 표현하는 다른 LRU 카운터값들이 항상 있는 식으로 작업한다. 대안 형태로써 변수 길이 코딩 스킴은 가장 정상적으로 사용되는 더 낮은 로케이션들이 더 짧은 코드를 사용하 <110>여 표현되는 반면에 덜 자주 사용되는 더 높은 번호의 로케이션들에는 더 긴 코드가 배정되는 식으로 배정되는히트와 미스 코드를 위해 사용될 수 있다.문헌에서 가능한 변수 길이 코딩 스킴의 일부는 히트와 미스 코드를 배정하는데 이용될 수 있다. 예를 들면 메 <111>모리 어드레스당 로케이션의 수가 적으면, 즉 2, 3 또는 4이면, 각 로케이션 번호를 나타내기 위해 Huffman이사용될 수 있다. 로케이션 번호가 더 크면, 제1 단계 종료 코드가 Huffman 스킴보다 훨씬 더 빠르게 생성되기때문에 바람직하다.예를 들면 변수 길이 코딩 스킴은 두가지 패스를 포함할 수 있다. 제1 패스는 각 로케이션에서 이용 빈도를 계 <112>산하는데 이용되고, 제2 패스는 가장 빈번히 이용되는 로케이션에 가장 짧은 코드가 배정되는 반면에 가장 덜빈번하게 사용되는 로케이션에는 더 긴 코드가 배정되는 식으로 각 로케이션을 표현하는 변수 길이 코드를 배정하는데 이용된다. 예를 들면 메모리 어드레스당 2개 로케이션이 이용된다고 가정해 보자. 결론적으로 로케이션0과 로케이션 1에서 일어나는 미스 백분율과 히트 백분율을 카운트하기 위한 압축방법을 실행함으로써 제1 패스가 수행된다. 그러므로 제1 패스 중에는 어떤 출력도 압축 스트림에 기록되지 않는다.백분율이 pA, pB와 pC로 얻어진 후에, 여기서 pA는 미스의 백분율이고, pB는 로케이션 0에서의 히트 백분율이고 <113>- 15 -공개특허 10-2009-0021149pC는 로케이션 1에서의 히트의 백분율이며, pA, pB와 pC에 대하여 Huffman 트리가 생성되고, 도 11의 Huffman트리에 도시된 것처럼 미스(A), 로케이션 0에서의 히트(B)와 로케이션 1에서의 히트(C)를 표현하기 위한Huffman 코드가 배정된다. pA<pB<pC를 의미하는 A<B<C라면 A, B와 C는 다음과 같은 Huffman 코드가 배정되게한다: 11, 10과 0.나아가 대안으로써 로케이션 번호를 암호화하기 보다는, 각 로케이션마다 하나씩 상태 필드에 보관된 LRU 카운 <114>터의 값이 대신에 암호화된다. LRU 카운터들은 LRU 대체 정책을 이행하고 각 로케이션에 대한 이용 순위를 나타내어 더 높은 값이 더 최근에 이용된 로케이션을 나타내고, 아니면 그 반대를 나타내는데 사용된다. 그러므로더 높은 LRU 카운터값에는 더 짧은 코드가 배정되는 반면에 더 낮은 값에는 더 긴 코드가 배정된다. 캐시 라인번호 자체를 암호화하는 대신에 캐시 라인과 연관된 LRU 카운터를 암호화하는 논거는 다음과 같다. 더 최근에사용된 라인들이 덜 최근에 사용된 것보다 장래 히트를 얻을 가능성이 더 많기 때문에 각 라인의 이용 순위는해당 라인에 대한 히트 발생의 확률과 상관관계가 있을 수 있다. 이 때문에 이러한 가정 하에 최고 순위를 갖는라인 카운터는 다음 히트를 구할 가능성이 더 높고, 두번째로 높은 순위를 갖는 카운터가 뒤에 오는 등 순위가0이 될 때까지 그러하다. 순위 0는 매칭 블록을 가질 확률이 가장 낮은 라인을 나타낸다. 기대하는 것은 더 높은 LRU 계수 (더 최근에 엑세스 된)를 갖는 라인들이 더 낮은 LRU 계수를 갖는 라인들보더 더 많은 히트를 산출한다는 것이다. 이러한 트렌트가 충족되면 히트를 표현하는 평균 코드 길이가 줄어들게 되므로 압축을개선한다.압축방법 10, 100과 200은 컴퓨터 메모리를 워크스페이스로 이용하여 현재 스트림값에 대한 입력으로 이용되는 <115>N 비트, 메모리 어드레스용 입력으로 이용되는 K 비트, 메모리 어드레스 참조에서 값들이 발견되는 로케이션을나타내는데 이용되는 L 비트와 히트나 미스가 결과로 나오는 지를 나타내는 출력으로서 이용되는 1 비트를 갖는의사 캐시 메모리로서 이행하는데 사용될 수 있다. 라인 번호를 나타내기 위해 고정 길이 코드를 이용하는 것은 모든 라인 번호들이 동등한 분포를 가질 때 유리하 <116>다. 그러나 이러한 불변은 실제에서는 바람직하지 않을 수 있다. 캐시 라인이 불균일 분포를 나타낼 수 있다면히트와 미스의 평균 코드 길이는 더 자주 평가되는 라인에 대해 더 짧은 코드를 배정함으로써 더욱 줄어들 수있다. 캐시 세트당 두개 이상의 캐시 라인이 있는 압축방법을 선택할 때 히트를 표현하기 위한 1 비트 마커의사용은 그 중요성을 상실한다. 암호화 문제는 그러한 미스 발생과 히트가 일어나는 라인 번호의 측면에서 다시언급되어야 한다. 이 때문에 암호화하는 부호들은 본질적으로 (1+LINES)이다: 즉, MISS를 표현하는 \"1\" 코드와매 히트가 일어나는 캐시 라인을 표현하는 \"LINES\" 코드이다.한가지 한계는 라인을 세트 내의 위치로, 즉 라인 번호로 암호화하는 것은 상관관계가 적다면, 즉 균일 분포를 <117>나타내면 코드 길이 감소 측면에서 이득을 제공하지 않는다는 것이다. 이는 캐시 라인과 관련된 또 다른 속성이대신에 사용되면, 예를 들면 방법 200과 관련하여 전술한대로 LRU 카운터의 값을 이용한다면 극복될 수 있다.또 다른 한계는 히트와 미스를 암호화하고 복호화하는데 더 많은 시간이 수반된다는 것이다. 그러나 이는 코딩과 모델링을 모두 고려하는 어떠한 방법에서든 일반적인 경우이다. 그러한 총체적 시간은 히트 코드의 불균일분포를 강제하기 위해 앞에서 논의된 변형과 연계하여 히트와 미스 코드의 정적 배정을 이용함으로써 감소될 수있으며, 따라서 평균 코드 길이를 감소시키는 대부분의 가변 길이 암호화 스킴을 만들고 압축을 개선할 수있다.이제 도 6과 도 7을 전체적으로 참조하면 완전 연관 CMC 방법(300)은 2K 세트를 표현하는 비트의 수인 K가 최소, <118>즉 0 비트로 감소될 때의 시나리오에 관한 것이다. 그 결과는 전체 캐시에서 하나의 세트만이 있는 완전 연관캐시이다. 도 7은 메트릭스 <N,0,2L>을 갖는 완전 연관 캐시 배열의 예를 도시한다. 방법 300에 의해 이행되는내부 캐싱 과정의 의미있는 한가지 효과는 매핑 어드레스가 본질적으로 제거되는 것이다. 그 결과 CMC 코덱 방법 300은 블록을 조사할 때 (단계 334), 블록을 읽어올 때 (단계 330) 그리고 캐시에 블록을 기록할 때 (단계340, 342 및 350) 현재 블록만을 필요로 한다. 세트변수는 항상 0이다. 방법 100과 200과는 달리 방법 300은 루프의 마지막 단계 후에, 즉 단계 342, 352 후에 변수를 업데이트할 필요가 없다.완전 연관 압축방법 300은 방법 100과 200보다 더 많은 히트를 생성하는데도 불구하고 방법 300은 더 높은 압축 <119>비를 산출하지 않는다. 이는 두가지 이유 때문이다. 첫째 양호한 히트비를 달성하기 위해서는 세트에서의 라인수가 충분한 블록을 수용할 정도로 클 필요가 있다, 그리고 둘째 다수의 히트수를 가짐에도 불구하고 고정 길이코딩은 암호화된 모든 히트 라인이 압축 스트림에서 동일 길이를 가져 궁극적으로 동일 길이의 후속 데이터 블럭을 갖기 때문에, 즉 정확히 2N 캐시 라인이 캐시 세트당 사용된다면 N 비트이기 때문에 그러한 이점을 충분히- 16 -공개특허 10-2009-0021149취할 수 없다. 그러나 후자의 변형은 정당한 방법이며, 보다 완전한 설명이 후술될 것이다.완전 상관 방법 300에서 메트릭스 <N,0,Lines>를 갖는 완전 연관 워크스페이스가 이용된다. 이러한 배열에서는 <120>다수 로케이션을 갖는 하나의 메모리스 어드레스만 이용되어 다수 값이 동일 메모리 어드레스에 동시에 저장될수 있게 한다. 이는 히트가 일어나는 로케이션을 압축 스트림 내로 암호화시키는 추가적 복잡도(complexity)를삽입하여 복호자는 원래 데이터 스트림을 복원할 수 있다. 그러므로 이 경우에 그러한 로케이션을 표현하기 위해 HIT 코드가 이용된다.후속 형태로 완전 상관 방법 300은 메모리 어드레스당 적어도 2N 로케이션을 사용하여 MISS 코드의 필요성을 완 <121>전히 제거하고, 각 로케이션에 대하여 특정 값들인 0, 1, 2, ... 2N-2, 2N-1 을 초기화함으로써 성능을 향상시키도록 변형될 수 있다. 따라서, 들어오는 값이 N 비트 길이이기 때문에, 이전에 워크스페이스에 초기화된 로케이션으로부터의 어떤값과 매칭되는 2N 에서 가능한 값이 존재한다. 다시 이 경우에 그러한 로케이션을 표현하기 위해 HIT 코드가 이용된다. 이 경우에 워크스페이스를 위해 사용된 특정 메트릭스는 <N,0,Lines>인데, Lines는 2의 N승, 즉 <N,0,Lines>=<N,0,2N>이다.이제 도 8을 참조하면 일반 CMC 압축방법 400은 방법 100, 방법 200과 방법 300을 통합하는데, 이번 개시에 근 <122>거하여 즉시 명백해진다. 방법 400은 앞의 방법 100, 200과 300으로부터의 단계들을 포함하지만, 그렇지만 각각100 내지 300 상승한다.방법 400에서 데이터 블록은 원시 스트림으로부터 검색되고 (단계 430), 발견되지 않으면 캐시되고 (단계 434, <123>436), 히트들이 암호화되고 (단계 450, 452), 미스들이 암호화된다 (단계 440, 442). 세트 연관 스킴에 더 많은라인이 추가되면 (단계 439), 그러면 히트 라인은 당연히 암호화되어야 한다 (단계 452). 연관 스킴에 하나의세트만 있다면 (단계 455) 그러면 세트 어드레스는 관련이 없으며, 따라서 단계 460과 462는 수행되지 않는다.특정 캐시 방법과의 주요 차이점은 도 8에서 회색으로 진하게 강조되어 있다.방법 400과 방법 10, 방법 100, 방법 200과 방법 300 사이의 또 다른 차이점은 히트 마커가 히트 라인의 암호화 <124>와 머지(merge)되고 암호화 자체는 히트와 미스 모두에 대해 개방형으로 남는다는 것이다. 이는 다수의 암호화가능성을 드러내는데, 가변 길이 스킴이 가장 효과적일 가능성이 있다. 대조적으로 세트 상관과 완전 상관의 경우에, 즉 방법 200과 방법 300에 대하여 암호화는 라인의 이진 표현을 지지하는 L 비트로 이루어진 고정 길이스킴에 의해 명백하게 정해진다.방법 400에서 히트와 미스는 방법 200에서 배정되는 방법과 동일하게 암호화되거나 배정된다. 예를 들면 히트와 <125>미스는 가장 빈번히 이용되는 더 낮은 로케이션은 더 짧은 코드로 표현되고, 덜 자주 이용되는 더 높은 로케이션은 더 긴 코드로 표현되는 식으로 암호화된다. HIT 코드에 대한 가변 길이 코드는 현재 부호값이 발견되는 메모리 어드레스 참조 내에서의 로케이션을, 즉 히트가 일어난 로케이션을 불일치(미스)가 일어날 때 어느 값이표현되어야 할지 결정하는 LRU 대체 정책과 연계하여 표현한다. 압축방법 400은 히트에 대한 가변 길이 코드를암호화한다. 유사하게 복원방법은 그러한 코드를 복호화한다. 이는 각 메모리 어드레스가 두 개 이상의 로케이션을 가질 때만, 즉 한 개보다 많은 값을 동시에 저장할 수 있을 때만 적용가능하다. 그러므로 라인이 엄밀하게한 개보다 큰 특정 메트릭스 <N,K,Lines>를 갖는 세트 연관 구성에 적용할 수 있다.워크스페이스로 이용되는 컴퓨터 메모리는 현재 부호값에 대한 입력으로 이용되는 N 비트, 메모리 어드레스 참 <126>조에 대한 입력으로 이용되는 K 비트, 메모리 어드레스 참조에서 값들이 발견되는 로케이션을 나타내기 위한 출력으로 이용되는 L 비트, 그리고 히트나 미스가 결과로 일어났는지 나타내기 위한 출력으로 이용되는 1 비트를갖는 의사 캐시 메모리로서 이행된다. 의사 캐시 메모리는 압축방법 10, 100, 200, 300과 400의 워크스페이스를이용하기 위해 사용된다. 용어 \"의사 캐시 메모리\"는 이 문맥에서 컴퓨터 아키텍처에서 사용된대로 실제 건축(architectural) 캐시 메모리와 캐시 매핑 압축 (CMC) 패밀리를 망라하는 모든 압축방법과 복원방법이 사용하는내부 워크스페이스와의 유사점을 강화하기 위해 사용된다. 특히 의사 캐시는 컴퓨터의 중앙처리장치(CPU)와 주메모리 사이에 생기는 내부 데이터 캐싱 메카니즘과 닮았지만, 입력 스트림에 대해서는 CPU를 출력 스트림에 대해서는 주 메모리를 대신한다. 결과적으로 각 캐시에 대한 데이터 지역성(locality properties)은 다르게 활용된다. 의사 캐시 메모리는 압축을 생성하기 위한 시도로 그러한 데이터 지역성의 공간 및 시간적 측면을 활용하는 반면에, 건축 캐시는 대신에 메모리 엑세스를 가속화하려고 시도한다. 의사 캐시 메모리는 이행된 워크스페이스가 압축방법과 복원방법을 각각 수행하기 위해 가질 필요가 있는 특정 입력과 출력의 측면에서 기술된다.도 9를 참조하면 일반적으로 CMC 복원방법 500은 현재 압축방법을 이용하여 이전에 생성된 압축 데이터 스트림 <127>- 17 -공개특허 10-2009-0021149으로부터 원래의 원시 데이터의 정확한 복사본을 생성한다. 방법 500은 압축방법10, 100, 200, 300과 400과 유사한 측면을 도입하는데, 예를 들어 압축 도중에 사용된 동일한 캐싱 이력 방법은 방법 500에서 복원동안에 복제된다.이제 특히 도 9를 구체적으로 참조하면 다양한 변수, 즉 Block, Line, Set와 Token이 초기화된다 (단계 505). <128>방법 500의 각 루프나 반복 중에 하나의 데이터 블럭이 추출되어 복원 또는 비압축 스트림에 기록된다. 그 블럭은 미스된 코드가 복호화되면 압축 스트림으로부터, 히트 라인이 대신에 복호화되면 캐시로부터 나온다. 미스마커가 검출되면 그 불럭은 우선 압축 스트림으로부터 읽혀지고 캐시된다. 그렇지 않으면 복호화된 히트 라인은캐시 내의 현재 세트로부터 직접 블록을 검색하기 위한 인덱스로 이용된다.구체적으로 도 9를 참조하면 (임시 히트와 미스 코드를 차지하는) 현재 블록, 라인, 세트 및 토큰에 대한 지역 <129>변수가 선언된다 (단계 505). 세트는 처음에 0으로 초기화된다.다음으로 토큰은 미스 마커나 히트 라인이든 차지해야만 하는 경우에 읽혀지고 복호화된다 (단계 530). 압축 스 <130>트림은 스트림 종료 때까지 완전히 읽혀진다 (단계 532). 미스 마커가 검출되면 (단계 538) 그러면 자연적으로미스 블럭이 따라온다. 그러므로 미스가 다음 원시 스트림으로부터 읽혀지고 (단계 540) 캐시로부터 현재 LRU라인에 기록된다 (단계 542). 그렇지 않으면 블록은 복호화된 히트 라인에 있는 캐시로부터 직접 읽혀진다 (단계 550).다음에 단계 542나 단계 550으로부터 얻은 블록은 복원 또는 비압축 데이터 스트림에 기록된다 (단계 555). 현 <131>재 세트는 해당되면 업데이트되고 (단계 560), 방법 500은 단계 530에서 재개된다.후속 형태로 HIT와 MISS 코덱/값은 데이터 복원 중에 감압방법을 안내하는데 이용되는 제어 비트인 토큰으로 그 <132>룹이 된다. 토큰은 N 비트의 배수이며 그래서 원시 또는 압축 스트림으로부터 읽혀진 값들은 압축 또는 비압축스트림으로 복제될 때 N 비트의 배수로 정렬된 채로 있다. N 비트가 8 비트 길이, 즉 1 문자 바이트라면 히트와미스 코드는 n-바이트 토큰으로 그룹이 되는데, n은 집합 {1,2,3,...}으로부터의 자연수이며, 그래서 원시나 압축 스트림으로부터 읽혀진 값들은 도 12의 압축 출력 데이터에서 도시된대로 압축 또는 비압축 스트림 각각에복제될 때 바이트 정렬된 채로 있다. 그 결과 실시간으로 압축 데이터가 포맷되는 방식을 재배열하여 개별 비트에 대한 입력/출력 연산을 단순화시키는 압축 데이터 스트림 상에서 임의 최적화가 수행되어야 한다. 이는 모든HIT와 MISS 코드를 함께 고정 길이 토큰으로 조합한다. 각 토큰은 N의 배수인데 그 길이는 원시 데이터 스트림으로부터 읽혀지는 각 후속 값들의 비트이다.전형적으로 N은 8 비트 길이로 이루어지는데, 즉 각각의 후속 값은 1 문자 바이트이며, 이는 각 토큰이 바이트 <133>의 배수, 또는 n-바이트 길이이며, n은 집합 {1,2,3,...}으로부터의 자연수라는 것을 의미한다. 이러한 최적화는 토큰(히트/미스 코드)와 원시 스트림 값을 N-비트 바운더리에 정렬하고 압축 및 비압축 데이터 스트림 모두에 대한 입력/출력 동작을 단순화시키는 효과를 갖는다. 이는 현재 압축방법과 복원방법의 전체 속도를 개선시킨다.이제 현재 압축방법은 이전 압축방법에서는 찾을 수 없는 특징과 장점을 제공하는 것이 확실해질 것이다. 현재 <134>CMC 코덱은 범용이고 모든 소스에 대하여 대단히 동일한 방식으로 그리고 입력 데이터의 특징과 상관없이 입력스트림으로부터 받은 데이터 블럭을 처리한다.현재 방법의 더 나은 특징은 대칭적이라는 것이다. 이는 CMC 압축방법과 복원방법이 모두 상대적 노력, 시간과 <135>공간 복잡도 등에 측면에서 본질적으로 동일한 과정을 수행한다는 것을 의미한다. 그러한 대칭적 행위는 CMC 코덱의 시간/공간 복잡도를 분석할 때 더 분명해 진다.이 외에도 현재 CMC 코덱은 \"배타 스트림\" 모드로 작업한다. 요약하면 이는 입력 스트림으로부터 받은 모든 부 <136>호가 \"한 번에 하나씩\" 처리되고, 보다 중요하게는 그러한 부호를 처리한 직후에 출력이 생성된다는 것을 의미한다. 이는 대부분의 이전 압축방법이 일반적으로 정상 스트림 모드나 블럭 모드로 작용하기 때문에 이전 압축방법과는 다르다. 정상 스트림 모드에서 부호들은 한 번에 하나씩 처리되지만 그들의 출력은 직후에 생성되지않는다. 오히려 주어진 수의 입력 부호들이 내부적으로 빌드업되어(build up) 처리될 수 있을 때까지 지연된다.블럭 모드에서는 압축자는 원시 데이터 스트림으로부터 고정된 수의 부호들, 대개 2~3 킬로바이트를 읽어와서처리하고 등가의 압축 블록을 생성한다.현재 방법에 의해 이행되는 \"배타 스트림\" 모드로부터 몇가지 이점이 얻어진다. 예를 들면 디지털 통신에서 주 <137>어진 통신 과정이 송신기로부터 수신기로의 간헐적인 데이터 흐름을 유지하는 것이 필요할 수도 있다. 데이터가송신기로부터 정상 간격으로 전송되지 않으면 수신기는 송신기와의 데이터 동기화(sync)를 잃을 수도 있다. 그- 18 -공개특허 10-2009-0021149통신 과정이 정상 모드나 블럭 모드에서 작용하는 압축 기술에 의존한다면 그러면 수신기는 송신기가 휴지기일(idle) 때의 간격(intervals) 중에 데이터 sync를 잃을 수 있는 반면에, 압축기는 입력 부호를 내부적으로 빌드업하여 처리한다. 대조적으로 CMC 기술과 연관된 현재 방법이 대신 사용되면 이들 방법은 수신된 모든 입력 부호에 대하여 등가의 출력을 즉시 생성하기 때문에 데이터 sync 손실의 가능성이 없다. 이는 디지털 통신의 특정영역에 대하여 배타 스트림 모드 대 정상 스트림 또는 블럭 모드의 이점을 강조하는 단지 하나의 예제이다.배타 스트림 모드로부터의 유사 장점들은 실시간 대응을 필요로 하는 다른 영역에서 얻을 수 있다. 예를 들면 <138>사용자가 하나의 문자를 입력하고, 그 문자가 인터넷 (또는 다른 채널)을 거쳐 전송되고 마침내 채팅 윈도우 상에서 그 문자를 보기를 기대하고 있는 수신인이 받는 간단한 채팅 어플리케이션을 살펴보자. 스트림이나 블럭모드에서 압축자가 문자들을 처리하기 시작하기 위해서는 2~3 문자가 먼저 수신되어야 하기 때문에 그러한 문자는 (전송기 측에서의) 압축자가 그 문자를 방출하지 않을 때까지는 전혀 디스플레이지 되지 않는다. 대조적으로CMC 압축자의 배타 스트림 모드는 압축 문자가 압축자에 의해 즉시 방출되어 채널을 통해 전송되고, 그 후에는감압기가 원래 문자를 복원하여 디스플레이를 위해 채팅 어플리케이션으로 방출된다는 것을 보장한다. CMC 코덱의 대칭 행위는 또한 고유의 실질적인 이점을 갖는데, 이는 코덱에 의해 사용되는 대부분의 내부 자원 <139>을 \"공유\"하는 것이다. 이는 동일한 방법이 수행되기 때문이지만, 반대 방향에서 실행되기 때문이다. 그러므로하나의 작동 모드는 나머지 모드가 휴지기인 동안에 공유된 자원을 이용할 수 있다. 이는 동작과 설계 비용을최소화시킨다.완전 연관 CMC 스킴의 일면은 일부 캐시 메트릭스가 특정 조건을 만족하도록 강제함으로써 미스 확률이 문자 그 <140>대로 0%가 될 수 있다는 것이다. 즉 원시 스트림으로부터 읽혀진 현재 블록과 매치하는 캐시에 항상 블록이 있을 것이다. 그러므로 히트가 항상 생성되면 히트나 미스를 마크하는 것이 전혀 필요치 않고, 압축된 출력은 그저 암호화된 히트 라인으로 이루어진다. LRU 스킴과 결합하고, 더 짧은 코드가 가장 빈번히 사용되는 라인에 배정되고, 그리고 마지막으로 출력 스트림에서 암호화되면 그러면 결과적인 방법은 전방 이동(Move-To-Front)으로불리는 코딩 기법으로 변질된다 (degenerate). 전방 이동법은 완전 상관 CMC 코덱의 변형으로 간주될 수 있고 기존의 워크스페이스 인프라스트럭쳐를 이용하여 <141>쉽게 이행될 수 있는데, 캐시 초록 데이터형(ADT)을 통해 모델화될 수 있다. 이러한 과정을 예시하기 위해 완전상관 캐시가 메트릭스 <N,0,2N>으로 생성된다고 가정하자. 즉 LINES (캐시 라인의 수)는 모든 가능한 별개 데이터 블럭의 수인 2N이다 (예를 들면 N=8이면 세트에는 256개 라인이 있다). 모든 캐시 라인이 별개 데이터 블럭을 차지하도록 초기화되면 그래서 0에서 2N개의 라인에는 각각 0에서 2N개 각각의 값을 갖는 블럭이 있고, 그래서 블럭이 원시 스트림으로부터 읽힐 때마다 캐시 내의 일부 라인에 항상 매칭 블럭이 있기 때문에 항상 히트가생성된다.작동 관점으로부터 CMC 코덱은 캐시 메트릭스의 경계(border) 조건에 따라 기능성을 \"이동시킨다.\" 도 10은 현 <142>재 방법의 이러한 측면을 도시하는 다이어그램이다. 캐시 라인의 수가 줄어듦에 따라 압축기는 수반되는 암호화없이 본질적으로 단지 캐싱만을 수행하는데-데이터 블럭은 직접 매핑 캐시로 매핑되며 어떤 라인 번호도 암호화되지 않는다. 마찬가지로 집합 수가 1로 줄어들기 때문에 현재 압축방법은 완전 암호기가 되며-캐싱 과정은 캐시 히트를 생성하는 것보다 최적 코드를 생성하는 것이 더 중요하기 때문에 중요성을 상실한다. 집합과 라인의수가 모두 증가할 때 전환점이 일어나는데, 캐싱과 코딩 양자는 압축 과정에 매우 중대하고 ,높은 압축비를 생성하기 위한 상대적 타당성을 공유한다.압축방법 10, 100, 200, 300과 400, 그리고 복원방법 500은 유한 상태 자동화로 실현될 수 있고 소프트웨어나 <143>하드웨어 인공물로서 이행될 수 있는데, 주어진 메모리 어드레스로부터의 다수 로케이션이 대응(in parallel)비교, 즉 동시에 또는 공동으로 비교되는 연관 또는 지능 메모리 스킴을 이용하여 그 방법의 고유 일치성(parallelism)을 활용하는 크기/속도 최적화를 포함한다. 다른 말로 하면 유한 상태 자동화로써 현재 압축방법과 복원방법 중 어느 것이든 그 이행은 유한 수의 상태로 이루어진 가상 머신으로써 실현될 수 있는데, 각 상태는 압축과정과 복원과정 각각의 한 단계를 표현한다. 이는 본 명세서에서 제안된 모든 압축방법과 복원방법에적용 가능하다. 이는 또한 메모리 어드레스의 다수 로케이션에 동시 저장된 모든 값들이 특수 하드웨어 회로를이용하여 현재 부호값과 동시에 비교되는 특정 사례를 포함하는데, 그러므로 내용-어드레스 가능한 데이터어를갖는 연관 또는 지능 메모리의 행위를 이행하는데, 각 데이터어는 이전에 입력 스트림으로부터 저장된 부호값을표현한다. 그렇게 동시(parallelized) 최적화된 버전은 라인이 1 보다 큰 특정 메트릭스 <N,K,Lines>를 갖는 세트-연관 워크스페이스 구성을 가질 때만 가능하다.- 19 -공개특허 10-2009-0021149이 과정은 메모리 참조 내의 모든 로케이션으로부터의 각 비트와 동시에 현재 부호값으로부터의 각 비트를 비교 <144>하여 N이 현재 부호값의 비트 크기인 대부분의 N 비교에서 매칭 로케이션을 산출하는 특수 하드웨어 회로에 의해 수행될 수 있다. 연관 메모리가 사용되지 않으면 그러면 각 로케이션의 값은 현재 부호값과 개별적으로 비교될 필요가 있는데, 그 결과 \"Lines\" x \"N\" 비교인데 라인은 각 메모리 어드레스에 대한 전체 로케이션 수이다.본 발명이 바람직한 실시예와 관련하여 상당히 자세하게 기재되었지만 당해기술에 숙련된 당업자에게는 본 발명 <145>이 청구범위의 정신과 범위를 벗어나지 않고 수많은 변경 및 변형이 가능하다는 것이 명백할 것이다.도면의 간단한 설명도 1은 본 발명에 따른 캐시 매핑 압축방법의 입력 및 출력 순서를 묘사하는 다이어그램으로, 라벨있는 블럭들 <55>은 원시 데이터 스트림으로부터 읽혀진 부호값을 가리킨다.도 2는 본 발명에 따른 캐시 매핑 압축을 묘사하는 다이어그램으로 '블럭'과 '어드레스' 라벨로 분류된 라인들 <56>은 각각 현재 부호값과 메모리 어드레스 참조를 가리킨다.도 3은 본 발명에 따른 일반적인 캐시 매핑 압축(CMC) 방법을 묘사하는 순서도이다. <57>도 4는 본 발명에 따른 직접 매핑 CMC 압축방법을 묘사하는 순서도이며, 변수 '블럭,' '라인'과 '세트'는 각각 <58>현재 부호값, (메모리 어드레스 내의) 로케이션 번호 및 메모리 어드레스 참조를 가리킨다.도 5는 본 발명에 따른 세트 연관 CMC 압축방법을 묘사하는 순서도이며, 변수 '블럭,' '라인'과 '세트'는 각각 <59>현재 부호값, (메모리 어드레스 내의) 로케이션 번호 및 메모리 어드레스 참조를 가리킨다.도 6은 본 발명에 따른 완전 연관 CMC 압축방법을 묘사하는 순서도이며, 변수 '블럭,' '라인'과 '세트'는 각각 <60>현재 부호값, (메모리 어드레스 내의) 로케이션 번호 및 메모리 어드레스 참조를 가리킨다.도 7은 본 발명에 개시된 모든 압축 및 복원방법에서 사용하는 워크스페이스나 의사 캐시 메모리의 다이어그램 <61>이다.도 8은 본 발명에 따른 일반적인 캐시 매핑 압축방법을 묘사하는 순서도이며, 변수 '블럭,' '라인'과 '세트'는 <62>각각 현재 부호값, (메모리 어드레스 내의) 로케이션 번호 및 메모리 어드레스 참조를 가리킨다.도 9는 본 발명에 따른 복원방법의 순서도이며, 변수 '블럭,' '라인'과 '세트'는 각각 현재 부호값, (메모리 어 <63>드레스 내의) 로케이션 번호 및 메모리 어드레스 참조를 가리킨다.도 10은 본 발명에 따른 직접 매핑, 완전 연관 및 세트 연관 방법에 관하여 코딩과정과 캐싱과정 간의 관계를 <64>묘사하는 비교 다이어그램이다.도 11은 본 발명에 따라 Huffman 코드가 배정되는 방법을 보여주는 Huffman 트리를 묘사한다. <65>도 12는 특정 경우에 대한 출력 압축 데이터가 정렬되는 방법을 묘사하며, N은 각 토큰을 포함하는 8이며, 즉 <66>HIT와 MISS 코드 또는 본 발명에 따라 데이터를 복원함에 있어 감압 방법을 유도하는데 사용되는 제어비트이다.도면 도면1- 20 -공개특허 10-2009-0021149 도면2- 21 -공개특허 10-2009-0021149 도면3- 22 -공개특허 10-2009-0021149 도면4- 23 -공개특허 10-2009-0021149 도면5- 24 -공개특허 10-2009-0021149 도면6 도면7- 25 -공개특허 10-2009-0021149 도면8- 26 -공개특허 10-2009-0021149 도면9 도면10- 27 -공개특허 10-2009-0021149 도면11 도면12- 28 -공개특허 10-2009-0021149"}
{"patent_id": "10-2008-7025942", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "각 컴퓨터 메모리 어드레스가 하나 이상의 별개 값을 각각 차지하는 하나 이상의 로케이션을 갖는 하나 이상의 별개 컴퓨터 메모리 어드레스를 워크스페이스로 이용하여 값들의 열을 포함하는 원시 데이터 스트림으로부터 데 이터를 압축하는 방법이 제공된다. 상기 방법은 길이가 각각 K 비트와 N 비트인 두개의 인접 데이터값들을 원시 데이터 스트림으로부터 메모리 어드레스 참조와 현재 부호값으로 각각 읽어옴으로써 작업한다. 현재 부호값은 메 모리 어드레스 참조에서의 값들 중 어느 것하고도 일치하지 않으면 메모리 어드레스 참조에 있는 값들 중 하나를 대체하기 위해 현재 부호값을 기록하고, 현재 부호값이 뒤따르는 MISS 코드/값을 압축 데이터 스트림에 기록한다. 대안으로 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것이든 일치하면 그 값을 찾아낸 메모리 어드레스 참조 내의 로케이션을 표현하는 HIT 코드를 압축 데이터 스트림에 기록한다. 상기 방법은 원시 스트림으로부터 읽혀지는 모든 부호에 대하여 반복된다. 등가의 대칭이고 가역적인 감압방법이나 복원방법은 원 래 원시 스트림과 등가의 비압축 데이터 스트림을 생성한다. 유리하게 압축방법에서 채용되는 워크스페이스는 컴 퓨터 아키텍쳐에서 사용되는 캐시 메모리와 유사한 행위를 가져서, 상기 압축방법이 내용 어드레스가 가능한 메 모리, 즉 하드웨어 이행을 위해서는 연관 또는 지능 메모리이고 소프트웨어 이행을 위해서는 연관 배치(array)를 이용하여 이행되게 한다. - 1 -공개특허 10-2009-0021149특허청구의 범위 청구항 1 각 컴퓨터 메모리 어드레스가 하나 이상의 별개 값을 각각 차지하는 하나 이상의 로케이션을 갖는 하나 이상의 별개 컴퓨터 메모리 어드레스를 워크스페이스로 이용하여 값들의 열을 포함하는 원시 데이터 스트림으로부터 데 이터를 압축하는 방법에 있어서, (a) K가 0보다 크면 원시 스트림에서 현재 리딩 포인트 직전인 K 비트를 원시 데이터 스트림으로부터 메모리 어 드레스 참조로 읽어오고, (b) N 비트를 원시 스트림으로부터 현재 부호값으로 읽어오고, (c) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것하고도 일치하지 않으면 메모리 어드레스 참조 에 있는 값들 중 하나를 대체하기 위해 현재 부호값을 기록하고, 현재 부호값이 뒤따르는 MISS 코드/값을 압축 데이터 스트림에 기록하고, 그리고 (d) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것이든 일치하면 그 값을 찾아낸 메모리 어드레스 참조 내의 로케이션을 표현하는 HIT 코드를 압축 데이터 스트림에 기록하는 것을 특징으로 하는 방법. 청구항 2 제1항에 있어서, (a)에서 메모리 어드레스 참조의 가장 왼쪽 비트가 원시 데이터 스트림으로부터 읽는데 이용할 수 없으면 적절 히 초기화되며, 각 메모리 어드레스에서의 모든 값들의 초기화 후에 원시 데이터 스트림에서 각 값에 대하여 (a) 내지 (d)를 반복하는 것을 더 포함하는 것을 특징으로 하는 방법. 청구항 3 제2항에 있어어, (a)에서 읽혀진 K 비트는 메모리 어드레스 참조로 이용되는 결과어를 생성하기 위해 더 적거나 같은 수의 비트 로 변환되는 것을 특징으로 하는 방법. 청구항 4 제3항에 있어서, 모든 메모리 어드레스는 메모리 어드레스 내의 로케이션 이용을 추적하기 위한 하우스 키핑을 위해 사용되고, 메모리 어드레스에서 하나의 값을 읽어오거나/기록한 후에 (c) 또는 (d)에서 업데이트되는 상태 필드를 포함하 는 것을 특징으로 하는 방법. 청구항 5 제4항에 있어서, 상기 상태 필드는 값을 대체할 때 어느 로케이션이 사용되어야 하는지 결정하는 대체 정책과 연계하여 사용되는 것을 특징으로 하는 방법. 청구항 6 제5항에 있어서, 상기 대체 정책이 가장 덜 최근에 사용된 (LRU), 선입선출 (FIFO)이나 가장 오래 사용된, 가장 덜 빈번히 사용 된 (LFU)와 임의로 이루어진 그룹으로부터 선택되는 것을 특징으로 하는 방법. 청구항 7 제3항에 있어서, 워크스페이스로 사용된 모든 메모리는 하나의 값만을 차지하는 하나의 로케이션만을 가지며, (d)에서 HIT 코드 - 2 -공개특허 10-2009-0021149는 현재 부호값이 메모리 어드레스 참조에서 발견된 부호값과 일치한다는 것을 가리키는 것을 특징으로 하는 방 법. 청구항 8 제5항에 있어서, 하나의 별개 값을 차지하는 다수의 로케이션을 갖는 한개의 단일 메모리 어드레스가 워크스페이스로 사용되며, (a)에서 K가 0이면 원시 스트림으로부터 아무런 비트도 읽혀지지 않고, 단지 하나의 메모리 어드레스가 있고 상 기 메모리 어드레스는 0인 것을 특징으로 하는 방법. 청구항 9 제8항에 있어서, 상기 단일 메모리 어드레스는 별개 값들로 이전에 초기화된 2N 로케이션을 가지며, (c)에서 현재 부호값은 항상 그러한 로케이션에서 이전에 초기화된 값들 중 어느 것이든 항상 일치하기 때문에 MISS 코드나 현재 부호값이 압축 데이터 스트림에 추가되지 않는 것을 특징으로 하는 방법. 청구항 10 제5항에 있어서, (d)에서 가장 빈번히 사용되는 더 낮은 로케이션은 더 짧은 코드를 사용하여 표현되고, 반면에 덜 자주 사용되 는 더 높은 로케이션에는 더 긴 코드가 배정되는 식으로 배정되는 가변 길이 코딩 스킴이 HIT와 MISS 코드/값에 대하여 사용되는 것을 특징으로 하는 방법. 청구항 11 제10항에 있어서, 하나는 각 로케이션의 이용 빈도를 계산하기 위한 것이고 나머지는 각 로케이션을 표현하는 가변 길이 코드를 배정하기 위한 두개의 패스가 가장 빈번히 사용되는 로케이션에는 더 짧은 코드가 배정되고, 가장 빈번하지 않 게 이용되는 로케이션에는 더 긴 코드가 배정되는 식으로 사용되는 것을 특징으로 하는 방법. 청구항 12 제5항에 있어서, 가장 덜 최근에 사용된 카운터의 값은 상태 필드에 암호화되는 각 로케이션에 대해 하나씩 보관되고, 상기 가장 덜 최근에 사용된 카운터는 가장 덜 최근에 사용된 대체 정책을 이행하고 각 로케이션에 대한 이용 순위를 나타 내기 위해 사용되어, 더 높은 값은 보다 최근에 사용된 로케이션을 표현하고 그 반대의 경우가 있으며, 이로써 더 높은 덜 최근에 사용된 계수값에는 더 짧은 코드가 배정되고, 반면에 더 낮은 값에는 더 긴 코드가 배정되는 것을 특징으로 하는 방법. 청구항 13 제1항에 있어서, 워크스페이스로 사용되는 상기 컴퓨터 메모리는 현재 부호값에 대한 입력으로 사용되는 N 비트, 상기 메모리 어 드레스 참조에 대한 입력으로 사용되는 K 비트, 상기 메모리 어드레스 참조에서 값들이 발견되는 로케이션을 가 리키기 위한 출력으로 사용되는 L 비트와 히트나 미스가 결과로 일어났는 지를 나타내기 위한 출력으로 사용되 는 1 비트를 갖는 의사 캐시 메모리로 이행되는 것을 특징으로 하는 방법. 청구항 14 각 컴퓨터 메모리 어드레스가 하나 이상의 별개 값을 각각 차지하는 하나 이상의 로케이션을 갖는 하나 이상의 별개 컴퓨터 메모리 어드레스를 워크스페이스로 이용하여 MISS와 HIT 코드를 포함하는 압축 코드와 함께 적어도 원시 데이터의 일부를 포함하는 압축 데이터 스트림으로부터 비압축 원시 데이터 스트림을 복원하는 방법에 있 어서, - 3 -공개특허 10-2009-0021149(a) K가 0보다 크면 비압축 스트림에서 현재 삽입 포인트 직전인 K 비트를 상기 비압축 스트림으로부터 메모리 어드레스 참조로 읽어오고, (b) 코드값을 상기 비압축 스트림으로부터 읽어오고, 상기 코드값은 HIT로 암호화된 로케이션이나 MISS 발생을 표현하고, (c) 상기 값이 MISS 코드이면 N 비트를 상기 비압축 스트림으로부터 현재 부호값으로 읽어오고, (a)에서 얻은 상기 메모리 어드레스 참조에서의 값들 중 하나를 대체하기 위해 현재 부호값을 기록하고, 현재 부호값을 비압 축 스트림에 기록하고, 그리고 (d) 상기 값이 HIT 코드이면 N 비트를 (a)에서 얻은 메모리 어드레스 참조에서 복호화된 HIT 코드에 의해 주어 지는 로케이션으로부터 읽어오고, 현재 부호값을 비압축 스트림에 기록하는 것을 특징으로 하는 방법. 청구항 15 제14항에 있어서, (a)에서 메모리 어드레스 참조의 가장 왼쪽 비트가 원시 데이터 스트림으로부터 읽어오는데 이용될 수 없으면 적절히 초기화되어, 각 메모리 어드레스에서의 모든 값들의 적절한 초기화 후에 압축 데이터 스트림에서 각 값 에 대하여 (a) 내지 (d)를 반복하는 것을 더 포함하는 것을 특징으로 하는 방법. 청구항 16 제15항에 있어서, (a)에서 읽어온/입력된 K 비트는 더 적거나/같은 수의 비트로 환원/변환되고, 그 결과어는 메모리 어드레스 참 조로 사용되는 것을 특징으로 하는 방법. 청구항 17 제16항에 있어서, 모든 메모리 어드레스는 메모리 어드레스 내의 로케이션 이용을 추적하기 위한 하우스 키핑을 위해 사용되고, 메모리 어드레스에서 하나의 값을 읽어오거나/기록한 후에 (c) 또는 (d)에서 업데이트되는 상태 필드를 포함하 는 것을 특징으로 하는 방법. 청구항 18 제17항에 있어서, 상기 상태 필드는 값을 대체할 때 어느 로케이션이 사용되어야 하는지 결정하는 대체 정책과 연계하여 사용되는 것을 특징으로 하는 방법. 청구항 19 제18항에 있어서, 상기 대체 정책이 가장 덜 최근에 사용된 (LRU), 선입선출 (FIFO) 이나 가장 오래 사용된, 가장 덜 빈번히 사용 된 (LFU)와 임의로 이루어진 그룹으로부터 선택되는 것을 특징으로 하는 방법. 청구항 20 제16항에 있어서, 워크스페이스로 사용된 모든 메모리는 하나의 값만을 차지하는 하나의 로케이션만을 가지며, (d)에서 HIT 코드 는 현재 부호값이 메모리 어드레스 참조에서 발견된 부호값과 일치한다는 것을 가리키는 것을 특징으로 하는 방 법. 청구항 21 제18항에 있어서, 하나의 별개 값을 차지하는 다수의 로케이션을 갖는 한개의 단일 메모리 어드레스가 워크스페이스로 사용되며, - 4 -공개특허 10-2009-0021149(a)에서 K가 0이면 원시 스트림으로부터 아무런 비트도 읽혀지지 않고, 단지 하나의 메모리 어드레스가 있고 상 기 메모리 어드레스는 0인 것을 특징으로 하는 방법. 청구항 22 제21항에 있어서, 상기 단일 메모리 어드레스는 별개 값들로 이전에 초기화된 2N 로케이션을 가지며, (c)에서 현재 부호값은 항상 그러한 로케이션에서 이전에 초기화된 로케이션에서 항상 발견되기 때문에 MISS 코드나 현재 부호값이 압축 데 이터 스트림에서 읽혀지거나 나타나지 않는 것을 특징으로 하는 방법. 청구항 23 제18항에 있어서, (d)에서 가변 길이 코딩 스킴이 압축 스트림으로부터 읽혀진 이전에 암호화된 HIT와 MISS 코드에 사용되는 것을 특징으로 하는 방법. 청구항 24 제23항에 있어서, 복호화된 각 HIT 코드는 로케이션 자체를 표현하는 것이 아니라 주어진 메모리 어드레스에 대한 히트로 기인되 는 로케이션과 연관된 가장 덜 최근에 사용된(LRU) 카운터를 표현하고, 상기 방법은 (a) 상기 LRU 카운터값과 연관된 로케이션을 조사하고,(b) (a)에서 얻은 그러한 로케이션으로부터 현재 부호값 을 읽어오며, LRU 카운터는 상태 필드에 보관되어 LRU 대체 정책을 이행하고 각 로케이션에 대한 이용 순위를 표현하는데 사 용되는 것을 특징으로 하는 방법. 청구항 25 제14항에 있어서, 워크스페이스로 사용되는 상기 컴퓨터 메모리는 현재 부호값에 대한 입력으로 사용되는 N 비트, 상기 메모리 어 드레스 참조에 대한 입력으로 사용되는 K 비트, 상기 메모리 어드레스 참조에서 현재 값들이 읽혀질 필요가 있 는 상기 메모리 어드레스 참조에서의 로케이션을 가리키기 위한 입력으로 사용되는 L 비트와, 그러한 부호값을 출력하기 위한 N 비트를 갖는 의사 캐시 메모리로 이행되는 것을 특징으로 하는 방법. 청구항 26 제1항에 있어서, 상기 HIT와 MISS 코드는 n-바이트 토큰으로 그룹이 되는 것을 특징으로 하는 방법. 청구항 27 제26항에 있어서, n은 2의 제곱지수(power)이어서 원시 스트림이나 압축 스트림으로부터 읽혀진 값들은 압축 스트림으로 복제될 때 바이트 정렬된 채로 있는 것을 특징으로 하는 방법. 청구항 28 제14항에 있어서, 상기 HIT와 MISS 코드는 n-바이트 토큰으로 그룹지는 것을 특징으로 하는 방법. 청구항 29 제28항에 있어서, - 5 -공개특허 10-2009-0021149n은 2의 제곱지수(power)이어서 원시 스트림이나 압축 스트림으로부터 읽혀진 값들은 비압축 스트림으로 복제될 때 바이트 정렬된 채로 있는 것을 특징으로 하는 방법. 청구항 30 제1항에 있어서, 상기 방법은 소프트웨어나 하드웨어 인공물(artifact)로서 유한 상태 자동화로 이행되는 것을 특징으로 하는 방 법. 청구항 31 제24항에 있어서, 상기 방법은 소프트웨어나 하드웨어 인공물로서 유한 상태 자동화로 이행되는 것을 특징으로 하는 방법. 청구항 32 제1항에 있어서, 상기 HIT와 MISS 코드는 N 비트의 배수인 토큰으로 그룹을 이루며, 원시 스트림으로부터 읽혀진 값들이 압축 스 트림으로 복제될 때 바이트 정렬된 채로 있는 것을 특징으로 하는 방법. 청구항 33 제32항에 있어서, N은 8 비트 길이이고, 상기 히트와 미스 코드가 n-바이트 토큰으로 그룹을 이루며, n은 상기 집합에서의 자연수 이고, 원시나 압축 스트림으로부터 읽혀진 값들은 압축 스트림으로 복제될 때 바이트 정렬된 채로 있는 것을 특 징으로 하는 방법. 청구항 34 제14항에 있어서, 상기 HIT와 MISS 코드/값들은 N 비트의 배수인 토큰으로 그룹을 이루며, 상기 원시나 압축 스트림으로부터 읽혀 진 값들은 비압축 스트림으로 복제될 때 N 비트의 배수로 정렬된 채로 있는 것을 특징으로 하는 방법. 청구항 35 제34항에 있어서, N은 8 비트 길이이고, 상기 히트와 미스 코드가 n-바이트 토큰으로 그룹을 이루며, n은 상기 집합에서의 자연수 이고, 원시나 압축 스트림으로부터 읽혀진 값들은 비압축 스트림으로 복제될 때 바이트 정렬된 채로 있는 것을 특징으로 하는 방법. 청구항 36 제1항에 있어서, 연관 메모리 스킴이 이행되며, 이로써 주어진 메모리 어드레스로부터의 다수 로케이션들이 병행적으로(in parallel) 또는 동시에 비교된다. 청구항 37 제14항에 있어서, 연관 메모리 스킴이 이행되며, 이로써 주어진 메모리 어드레스로부터의 다수 로케이션들이 병행적으로(in parallel) 또는 동시에 비교된다. 명 세 서 [관련 출원에 대한 교차 참조] <1> - 6 -공개특허 10-2009-0021149본 출원은 2006년 3월 24일자 출원된 미국 가출원 제60/785,572호에 대한 우선권을 주장하며, 이에 대해 언급함 <2> 으로써 본 명세서에 통합된다."}
{"patent_id": "10-2008-7025942", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 세트 연관 캐시 매핑 기술에 의거한 고속 데이터 압축에 관한 것이다. <3>"}
{"patent_id": "10-2008-7025942", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "혁신적인 정보의 디지털화는 정보기술, 멀티미디어 어플리케이션, 새로운 데이터 포맷 및 지난 20년 이상 번창 <4> 해 온 새로운 저장장치를 무수히 탄생시켰다. 디지털 정보를 즉시 이용가능한 포맷으로 변환 및 전달하는 데이 터 및 멀티미디어 어플리케이션기술의 증가하는 수에는 텍스트, 이미지 그리고 웹으로 전달되는 영상, 서버에 의한 파일 엑세스, 문서 전달, 데이터베이스 조회 및 지리적 매핑기술이 있다. 저장, 전송 및 계산력(computing power)의 측면에서 이렇게 과도한 멀티미디어 능력을 추진하는데(drive) 필요로 하는 자원(resource)의 양이 위 압적일 수 있다. 데이터 집약적인 멀티미디어 어플리케이션의 전개를 허용하는 기술적 진전의 하나는 데이터 압축이다. 예를 들 <5> 면 과학 정보, 고화질 이미지 및 웹이나 공동 네트워크(corporate network)를 경유하는 라이브 영상 컨텐츠를 포함하는 대량 파일의 전달은 일부 데이터 압축의 사용을 수반한다. 마찬가지로 휴대폰이나 다른 무선 기술을 경유하는 그러한 등가 서비스의 전송은 이용가능한 통신 대역폭을 효율적으로 사용하는 데이터 압축으로부터 큰 이익을 얻을 수 있다. 데이터 압축은 메시지, 파일에 저장된 비트 순서(sequence), 메모리 버퍼, 데이터 스트림 등의 정보 내용에서 <6> 중복(redundancy)을 제거하는 기술이다. 더 적은 수의 비트로 정보를 표현하면 저장매체에서 더 많은 컨텐츠 공 간을 절약하는 결과가 되고, 시간 단위 당 더 많은 데이터를 분배함으로써 전송에 이용할 수 있는 유효 대역폭 을 증가시킨다. 그러므로 데이터 압축은 모두를 위한 통신 및 멀티미디어에 맞는 기술을 만드는데 중요한 역할 을 해왔고 계속 중요한 역할을 할 것이다. 데이터 압축 행위에서, 데이터 압축방법을 언급할 때 두개의 다른 과정이 내포된다. 그 두가지 방법은 압축자 <7> (compressor)와 복원자(reconstructor)로 지칭된다. 문헌에서 일부 순수주의자들이 압축 데이터에 대한 복원 과 정을 명백히 의미하기 위해 복원자라는 용어를 사용함에도 불구하고, 후자는 감압자(decompressor) 또는 확대자 (expandor)로 더 일반적으로 지칭된다. 복원이라는 용어가 선호되며, 복원 과정을 명백히 언급하기 위해 본 명 세서에서 내내 사용된다. 압축자는 이름이 의미하는 것처럼 입력 소스를 처리하고 이를 이상적으로 크기가 더 작은 원본의 또 다른 디지 <8> 털 표현으로 전환시킨다. 반대로 복원자는 압축 데이터를 처리하고 원본의 복원본(reconstructed version)을 만 들어낸다. 소스와 복원된 내용이 정확히 일치하면 그 방법은 손실이 없다고 언명되고, 그렇지 않으면 손실이 있 는 것으로 여겨진다. 손실 스킴은 일반적으로 품질 저하를 희생으로 하여 무손실 스킴보다 더 높은 압축비를 얻 는다. 많은 압축 스킴이 개발되어 수년에 걸쳐 적응되어 왔지만 그들 대부분은 단지 압축 이득만을 개선하는 것을 엄 <9> 청 강조해 왔다. 그러나 전형적으로 간과된 한가지 요인은 압축-복원 과정의 속도이다. 멀티미디어 스트리밍, 비디오 프로세싱이나 데이터의 무선 전달처럼 시간이 매우 중요한 어플리케이션에서, 압축-복원 (이하, \"코덱 (codec)\"으로 칭함)이 압축 이득보다 더 중요하지는 않지만 그 만큼은 중요할 수 있다. 압축이든 복원이든 너무 많은 시간을 소모하는 것은 전형적으로 대부분의 실제 시나리오에서는 정당화되지 않는(unjustified) 상품이다. 궁극적으로 응답 시간을 결정하고 데이터를 이용하는 어플리케이션의 성능을 구체화하는 것은 채널 대역폭, 코 덱 이득과 코덱 속도의 조합이다. 간략히 말하면 데이터가 더 빨리 전달되면 더 빨리 처리되어 이용될 수 있다. 그 결과, 시간이 매우 중요한 어플리케이션은 가능해지거나 또는 데이터가 더 빨리 압축되면 보다 최적으로 작 업한다. 발명의 상세한 설명 본 발명은 데이터 압축방법 및 그 역의 동등한 복원방법에 관한 것이다. 그 방법들은 효율, 고속, 경량, 실시간 <10> 및 고도로 구성 가능한(highly configurable), 무손실 데이터 압축을 특징으로 하고, 이 때문에 다양한 통신 요 건을 갖는 광범위한 어플리케이션에 적합하다. 본 발명의 신규한 한가지 특징은 압축 데이터를 생성 및 복원하 기 위한 워크스페이스로서 의사 캐시 메모리(pseudo cashe memory)를 사용하는 것이다. 이 기술의 초석은 압축 - 7 -공개특허 10-2009-0021149과정의 고유 평행성(parallelism)으로 기인한, 하드웨어에서 활용되는 잠재력은 물론 당연히 압축 속도에 유리 한 본질적 능력을 갖는 새로운 캐시 매핑 압축(CMC)에 근거하고 있다. 여기서 비슷한 대역폭 조건 하에서 가장 최신의 압축자보다 상당히 더 빠르게 데이터 스트림을 처리할 수 있는 속도에 최적화된 하드웨어 코덱 박스가 가능하다. 본질적으로 본 발명의 현저한 특징은 다음과 같다. (a) 매우 낮은 메모리 소비 <11> (b) 매우 낮은 시스템 자원 사용 <12> (c) 압축방법 및 복원방법 모두에 매우 높은 실행속도 <13> (d) 대부분의 데이터 포맷에 대한 경쟁적 압축 <14> (e) 고 대역폭에서 압축 시간 + 전달 시간 + 복원 시간을 합하는 효과인 최소 배달 시간 <15> 이들 특징은 그 방법이 임베디드 시스템, PDA, SOC (System-on-a-chip) 설계 및 기타 제한적 시스템 자원을 갖 <16> 는 다른 하드웨어 장치에 대한 목표가 되게 한다. 또한, CMC방법의 간단함은 하드웨어 구현 또는 소프트웨어 구 현을 저렴하게 할 수 있게 한다. 그러므로 본 발명은 무선, 임베디드 및 전자 하드웨어와 소프트웨어 산업에 대 하여 잠재적으로 높은 상업적 가치를 갖는다. 대부분의 이전 데이터 압축방법과 함께 본 방법은 압축 데이터 스트림을 생성하기 위해 문자 런(character <17> runs) 및/또는 부분 열 일치(partial string matches)에 의해 생성된 중복, 반복 또는 반복 사용된 데이터를 제 거함으로써 원시 데이터 스트림의 크기를 줄여준다. 원시 데이터 스트림은 압축되어 할 값들, 즉 N 비트의 열 (string, sequence)로 이루어진다. 압축 데이터 스트림은 후술하는 본 압축방법에 근거하여 압축 데이터 스트림 에 삽입되는 압축 코드(MISS와 HIT)와 함께 원래 데이터 스트림의 부분 집합으로 이루어진다. 압축은 일부는 원 시 데이터 스트림에서 중복, 반복되는 값들을 제거하는 새롭고 신규한 방법에 의해, 그리고 그 압축 스트림으로 부터 원시 데이터의 복원을 유도하기 위해 압축 코드인 MISS나 HIT를 압축 데이터 스트림에 삽입함으로써 달성 된다. 예를 들면 다음의 입력 원시 스트림 \"ABCCCCABDDDD\"는 다음과 같은 압축 스트림 \"<m>A <m>B <m>C <m>C <h(C)> <18> <h(C)>, <m>A <h(B)> <m>D <m>D <h(D)> <h(D)>\"로 처리되는데, 여기서 \"<m>\"은 MISS 코드이고, \"<h(X)>>\"는 개 별 문자 X에 대한 HIT 코드이다. 본 발명의 가장 현저한 이점 중의 하나는 상기 예에서처럼 긴 열 만큼 크게 또는 단일 문자 만큼 작게 설정될 <19> 수 있는 크기 조절 가능 블록으로 데이터를 압축하는 능력이다. 블럭 크기가 일단 설정되면 그 방법은 단일 블 럭의 입력 데이터가 수용된 후 즉시 압축 데이터 스트림의 출력을 시작하고, 그리고 어느 때나 그리고 어떤 블 럭 크기이든 그러한 출력을 중지하고 다시 시작하는 유연성을 갖는다. 이는 필요할 때마다 제 때에 짧은 열 바 운더리나 단일 문자 바운더리에 대한 처리를 재개하는 가능성을 함축한다. 이러한 특징들은 함께 \"배타 스트림\" 동작 모드를 형성하며, 구체적 압축 매개변수를 특정 데이터 요건에 따라 맞춤화 함으로써 어플리케이션에 상당 한 유연성을 제공한다. 배타 스트림 모드 동작은 정상 스트림 모드나 블럭 모드와 명백히 다르다. 블럭 모드에 서 대개 소수(a few) 킬로바이트 길이인 한 블럭의 데이터는 압축자에 의해 읽히고 처리되며, 그 후에 압축 데 이터가 출력될 수 있다. 정상 스트림 모드에서 압축자는 한 번에 하나의 문자를 읽지만 불명확한 수의 문자들이 처리될 때까지 압축 데이터를 출력할 수는 없다. 이러한 불확실성은 어플리케이션의 성능에 영향을 미칠 수 있 고, 때때로 그 어플리케이션을 정상 스트림이나 블록에 의한 압축 스킴 하에서 불가능하게 할 수 있다. 본 발명 의 배타 스트림 모드는 압축 데이터의 모든 통신이 스트링이나 문자 바운더리 모두에 대하여 공간과 시간에 있 어 결정적이게 할 능력을 제공한다. 디지털 통신에서 그리고 채팅 (chat) 소프트웨어 어플리케이션을 위한 배타 스트림의 사용에 대한 추가적인 실시예가 상세한 설명에 제공되어 있다. 압축과 복원은 모두 의사 캐시 메모리를 워크스페이스로 사용하는 대칭적인 가역(reversible) 과정이다. 그러한 <20> 워크스페이스는 상태와 행위에서 컴퓨터 아키텍쳐에서 사용된 실제 캐시 메모리의 동작과 유사하다. 워크스페이 스의 구조는 하나 이상의 메모리 어드레스를 포함하는데, 각각의 메모리 어드레스는 하나 이상의 별개 값을 차 지하는 하나 이상의 로케이션를 가지며, 그 뒤에는 값들이 어떻게 대체되는지 결정하기 위한 로케이션 선택 정 책을 위해 사용되는 임의(optional) 상태 필드가 온다. 압축을 달성하기 위해 값들은 원시 데이터 스트림으로부 터 한번에 하나씩 읽혀지고 워크스페이스로 매핑된다. 마찬가지로 값들은 압축 데이터 스트림으로부터 읽혀지고 원래의 비압축 데이터 스트림(uncompressed data stream)을 복원하기 위한 워크스페이스로 매핑된다. 원시 또는 압축 스트림으로부터 읽혀지는 각각의 값이나 부호의 비트로 된 길이는 상수 N에 의해 결정된다. 워 <21> - 8 -공개특허 10-2009-0021149크스페이스 내의 메모리 어드레스의 수는 상수 K에 의해 결정되며, 2K의 가능한 별개 어드레스를 산출한다. 각 메모리 어드레스 내의 로케이션의 수는 상수의(constant) 라인에 의해 결정되며, 메모리 어드레스당 가능한 별 개 로케이션과 동일한 수를 산출한다. 모든 상수 N, K와 라인은 본 압축방법 및 복원방법에 의해 정의되며, 그 에 따라 각 방법을 분류하기 위해 특정 메트릭스 <N,K,라인>으로 그룹을 이룬다. 메모리 어드레스의 수와 각 메모리 어드레스 내의 로케이션 수를 다르게 함으로써 세개의 워크스페이스 배열이 <22> 가능하다: 매트릭스 <N,K,1>로 정의되는 직접 매핑 배열(direct-mapped arrangement)은 각자 하나의 값만을 차 지하는 많은 메모리 어드레스를 사용하고, 매트릭스 <N,0,라인>으로 정의되는 완전 연관 배열(fully associative arrangement)은 많은 값들을 차지하는 하나의 메모리 어드레스만을 사용하고, 그리고 <N,K,Line s>로 정의되고 가장 유연한(flexible) 세트 연관 배열(set associative arrangemen)은 각각 많은 값들을 차지 하는 많은 어드레스를 사용한다. 추가 향상 및 변형(variant)과 더불어 기본적인 압축 및 복원 과정을 이행하기 위하여 이러한 배열 각각을 워크스페이스로 사용함으로써 신규한 캐시 매핑 압축(CMC)과 복원방법의 집단 (family)이 도출된다. 본 데이터 압축방법은 특정 매트릭스 <N,K,Lines>를 갖는 워크스페이스 배열을 사용함으로써 데이터 스트림 내 <23> 의 중복을 제거한다. 원시 데이터 스트림으로부터의 값들은 쌍을 이루는 다중 비트 길이로 K 비트와 N 비트로 버퍼나 윈도우로 읽혀지고 메모러 어드레스 참조, 그리고 현재 부호값 각각으로 복사된다. 그러므로 최초의 K 비트는 메모리 어드레스 참조로 읽혀지고 바로 뒤에 오는 N 비트는 처리되어야 할 현재 부호값으로 읽혀진다. K 가 0이면 그러면 메모리 어드레스 참조는 0이다. 처리를 위해 이용 가능한 현재 부호값과 메모리 어드레스 참조와 함께, 현재 부호값은 메모리 어드레스 참조에 <24> 서의 값들 각각과 비교된다. 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것과도 일치하지 않으면, (a)MISS 코드/값이 압축 데이터 스트림에 추가된다. <25> (b) 현재 부호값이 압축 데이터 스트림에 추가된다. <26> (c) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 하나를 대체한다. <27> (d) 임의로(optionally), 메모리 어드레스 참조 내의 상태 필드는 로케이션 이용(usage)상의 변화를 반영하 <28> 기 위해 업데이트된다. 그러나 현재 부호값이 그러한 메모리 어드레스 참조에서의 값들 중 어느 것이든 일치하면, <29> (a) 값을 구한 메모리 어드레스 내의 로케이션을 나타내는 HIT 코드/값이 부호화되어 압축 스트림에 추가되 <30> 고, (b) 임의로, 그러한 메모리 참조 내의 상태 필드는 로케이션 이용상의 변화를 반영하기 위해 업데이트된다. <31> 현재 부호값이 메모리 어드레스 참조를 컨텍스트로 이용하여 처리된 후에 버퍼나 윈도우는 원시 데이터 스트림 <32> 이 소모되어 완전한 압축 데이터 스트림이 생성될 때까지 다음 쌍의 데이터 값을 준비하여 N 비트 오른쪽으로 이동된다. 원시 데이터는 전술한 것처럼 압축방법을 거꾸로 하여 압축 데이터로부터 복원된다. 복원방법은 압축방법 중에 <33> 사용된 동일한 워크스페이스를 다시 압축방법과 관련하여 전술한 특정 메트릭스 <N,K,Lines>과 함께 재사용한다. 복원방법은 이전에 비압축 스트림으로 출력된 이전 K 비트를 메모리 어드레스 참조로서 읽어온다. K가 0이면 아무런 비트도 읽혀지지 않고, 메모리 어드레스 참조도 0이다. 다음으로 복원방법은 MISS 코드가 복 호될 때까지 한 번에 하나씩 압축 데이터를 읽는다. 복호화 된 값이 MISS 코드이면, <34> (a) 압축 스트림으로부터 N 비트가 현재 부호값으로 읽혀진다. <35> (b)현재 부호값이 비압축 스트림에 추가된다. <36> (c) 현재 부호값은 메모리 어드레스 참조에서의 값들 중 하나를 대체한다. <37> (d) 임의로, 그러한 메모리 어드레스 참조 내의 상태 필드는 로케이션 이용상의 변화를 반영하기 위해 업데 <38> 이트된다. 그러나 복호화된 값이 HIT 코드이면, <39> - 9 -공개특허 10-2009-0021149(a) N 비트들은 상기 복호화된 값에 의해 규정된 로케이션에서 메모리 어드레스 참조로부터 현재 부호값으 <40> 로 읽혀진다. (b) 임의로, 그러한 메모리 어드레스 참조 내의 상태 필드는 로케이션 이용상의 변화를 반영하기 위해 업데 <41> 이트된다. (c)마지막으로 현재 부호값이 비압축 스트림에 추가된다. <42> 메모리 어드레스 참조를 컨텍스트로 이용하여 현재 부호값이 처리된 후에 메모리 어드레스 참조는 이전에 비압 <43> 축 스트림으로 출력된 이전 K 비트로 업데이트되고, 그 방법은 압축 데이터 스트림이 완전히 처리되어 완전 복 원된 비압축 데이터 스트림이 생성될 때까지 HIT나 MISS 코드/값을 계속 읽고 복호화한다. 메모리 어드레스 참 조를 만들 K 비트를 읽기 위해 비압축 데이터 스트림 상에서 수행되는 입력 동작은 바람직하지 않거나 또는 심 지어 압축 스트림이 본질적으로 \"출력\" 스트림이기 때문에 전혀 가능하지 않을 수 있다는 것에 유의하시오. 출 력 스트림 상의 이러한 입력 동작은 현재 부호값으로부터 메모리 어드레스 참조까지 N 비트의 왼쪽 이동 동작, 그 결과로써 당연히 N 비트 왼쪽으로 이동하는 동작을 수행함으로써 방지될 수 있다. 일 형태로 본 발명은 하나 이상의 별개 값을 각자 차지하는 하나 이상의 로케이션을 사용하는 값들의 열을 포함 <44> 하는 원시 데이터 스트림으로부터 데이터를 복원하기 위한 방법에 관한 것이다. 그 방법은 다음을 포함한다. (a) K가 0보다 크면 원시 스트림에서 현재 리딩 포인트 직전인 K 비트를 원시 데이터 스트림으로부터 메모리 어 <45> 드레스 참조로 읽어오고, (b) N 비트를 원시 스트림으로부터 현재 부호값으로 읽어오고, <46> (c) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것하고도 일치하지 않으면 메모리 어드레스 참조 <47> 에 있는 값들 중 하나를 대체하기 위해 현재 부호값을 기록하고, 현재 부호값이 뒤따르는 MISS 코드/값을 압축 데이터 스트림에 기록하고, 그리고 (d) 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것이든 일치하면 그 값을 찾아낸 메모리 어드레스 <48> 참조 내의 로케이션을 표현하는 HIT 코드를 압축 데이터 스트림에 기록한다. (a)에서 메모리 어드레스 참조의 가장 왼쪽 비트가 원시 데이터 스트림으로부터 읽는데 이용할 수 없으면 적절 <49> 히 초기화되며, 각 메모리 어드레스에서의 모든 값들의 초기화 후에 원시 데이터 스트림에서 각 값에 대하여 (a) 내지 (d)를 반복할 수 있다. 다른 형태로, 본 발명은 각 컴퓨터 메모리 어드레스가 하나 이상의 별개 값을 각각 차지하는 하나 이상의 로케 <50> 이션을 갖는 하나 이상의 별개 컴퓨터 메모리 어드레스를 워크스페이스로 이용하여 MISS와 HIT 코드를 포함하는 압축 코드와 함께 적어도 원시 데이터의 일부를 포함하는 압축 데이터 스트림으로부터 비압축 원시 데이터 스트 림을 복원하는 방법에 관한 것이다. 이 방법은 다음을 포함한다. (a) K가 0보다 크면 비압축 스트림에서 현재 삽입 포인트 직전인 K 비트를 상기 비압축 스트림으로부터 메모리 <51> 어드레스 참조로 읽어오고, (b) 코드값을 상기 비압축 스트림으로부터 읽어오고, 상기 코드값은 HIT로 암호화된 로케이션이나 MISS 발생을 <52> 표현하고, (c) 상기 값이 MISS 코드이면 N 비트를 상기 비압축 스트림으로부터 현재 부호값으로 읽어오고, (a)에서 얻은 <53> 상기 메모리 어드레스 참조에서의 값들 중 하나를 대체하기 위해 현재 부호값을 기록하고, 현재 부호값을 비압 축 스트림에 기록하고, 그리고 (d) 상기 값이 HIT 코드이면 N 비트를 (a)에서 얻은 메모리 어드레스 참조에서 복호화된 HIT 코드에 의해 주어 <54> 지는 로케이션으로부터 읽어오고, 현재 부호값을 비압축 스트림에 기록한다. 실 시 예 본 캐시 매핑 압축(CMC) 방법은 컴퓨터 내에서 중앙처리장치(CPU)와 메인 메모리 사이에서 일어나는 내부 데이 <67> 터 캐싱 메커니즘과 닮은 모델에 근거하고 있다. 한가지 차이점은 본 CMC 방법은 컴퓨터 아키텍쳐의 경우에서처 럼 메모리 엑세스를 빠르게 하기 보다는 오히려 압축을 생성하기 위한 시도로 캐시의 데이터 지역성(locality properties)을 활용하는 것이다. 본 명세서에서 설명하는 CMC 방법은 유한 상태 자동화(finite state automation)에서의 상태들을 표현하며, 그 자체로써 소프트웨어나 하드웨어 인공물(artifact)로 이행될 수 - 10 -공개특허 10-2009-0021149있다. 본 명세서 내내 사용된대로 데이터 압축을 언급할 때 입력 및 출력 스트림은 각각 원시 스트림과 압축 스 트림을 가리킨다. 마찬가지로 복원할 때 입력 및 압축 스트림은 각각 압축 스트림과 복원 스트림에 대응한다. 본 방법은 원시 스트림과 복원 스트림을 블록으로 불리는 고정된 길이의 N-비트 값들의 순서로 간주한다. 원시 <68> 부호를 직접 처리하는 대신에 N-비트 데이터 블럭에서 동작하는 이유는 두가지이다. 첫째는 블럭이 캐시 내의 최소 데이터 전달 단위인 캐시 라인과 동일한 크기이고, 둘째는 블럭 크기가 비트로 된 원시 부호의길이와 독립 적으로 설정될 수 있다는 것이다. 이는 다음에는 압축 매개변수에 대한 더 많은 제어를 허용하며, 원시 스트림 의 특징들과 더 잘 일치하며 그러므로 더 나은 압축비를 시도하게 해준다. 그러나 명료성을 위하여 제안한 청구 범위를 제출할 때 N-비트 데이터 블럭은 또한 현재 부호값으로 언급된다. CMC 압축방법은 원시 스트림으로부터 한 번에 하나의 N-비트 데이터 블록을 읽어온다. 현재 블록이 캐시 내의 <69> 특정 위치에서 발견되면 히트(hit)가 일어난다. 그렇지 않으면 미스(miss)가 발생된다. 다음으로 압축방법은 현 재 데이터 블럭이 뒤따르는 두 개의 가능한 순서, 즉 H 비트로 이루어진 Hit 코드나 M 비트로 이루어진 Miss 코 드 중 하나를 출력한다. 압축방법은 원시 스트림으로부터 모든 블록이 처리될 때까지 지속한다. 도 1은 압축 이전 그리고 이후 B, A, B, C의 임의의(arbitrary) 스트림 상태를 도시한다. 예를 들면 입력 순서 <70> 가 {B, A, B, C...}라면 가상 압축 출력 순서는 {(A에 대하여) <miss> <B>, <hit>, (B에 대하여) <hit>, <miss> <C> ...}이다. 두 순서를 비교하면 첫번째와 마지막 블럭은 각 미스에 대하여 M 비트의 확장을 특징으로 하는 반면에 중간의 두 블럭은 각 블럭에 대하여 (N-H) 비트의 압축 인자를 제공하는 것을 알 수 있다. 그러므 로 전체 히트 수를 알면 압축비를 정확히 계산하는 것이 가능해진다. 미스 코드와 히트 코드 간에는 개념적 차이가 있다. 미스 코드는 단순히 블린 마커의 역할을 하고, 복원자에게 <71> 미스가 일어났다는 것을 알려주고, 그 때문에 다음에 미스 블럭이 뒤따른다는 것을 알려준다. 반대로 히트 코드 는 블럭이 성공적으로 캐시되었다는 것을 가리킬 뿐만 아니라, 캐시 메트릭스에 따라서는 히트 코드가 히트가 일어난 세트의 라인 번호도 암호화해야 한다는 것을 가리킨다. 미스 코드는 편의상 1 비트값으로 정의되지만, 양자에 대한 평균 길이 코드를 최소화하기 위해 히트 코드 길이와 교환이 이루어질 수 있다는데 유의하시오. 라 인 번호와 세트는 또한 로케이션 번호와 메모리 어드레스 참조로 각각 지칭되는 것에 유의하시오. 도 1에서 출력 순서의 시각적 검사에 의해, 더 많은 히트 코드가 출력에서 출현할 때 압축이 개선되고, 반면에 <72> 히트와 미스에 대한 코드 길이가 증가할 때 압축이 열화되는 것이 명백하다. 히트의 수는 세트당 더 많은 라인 을 배열함으로써 극대화할 수 있지만, 불행히도 그렇게 하면 히트 코드 길이를 증가시킨다. 그러므로 분명히 최 소화 문제가 수반된다. 현재 블럭이 캐시의 특정 위치에서 발견되면 히트가 일어난다. 현재 블럭이 실제 매핑되는 특정 위치는 매우 중 <73> 요하다. 이 매핑은 먼저 히트의 생성을 허용하는 것이고, 도 1이 나타내는 것처럼 압축을 달성하기 위해 출력 순서의 크기를 줄이게 허용해 준다. 블럭을 캐시되게 하기 위해서는 두 개의 입력: 블럭과 어드레스가 필요하다. 어드레스는 블럭이 매핑될 캐시 세트를 결정하며, 그러므로 \"캐시 매핑 어드레스\"로도 불린다. 후속(incoming) 블럭에 대한 적절한 매핑 어드레스 기능을 추출하기 위하여 전형적으로 텍스트에서 활용될 수 <74> 있는 데이터 중복의 유형을 시각화(visualize)하는게 중요하다. 다음 순서를 살펴보자. ABCCCCABDDDD...이 순서에서 단지 하나의 스트링 일치(두번째 서브스트링 \"AB\"와 일치하는 서브 스트링 \"AB\")와 <75> 두개의 문자 런(\"CCC...\"과 \"DDD...\")이 있다. CMC 압축자를 효과적으로 하기 위해서 후속 블럭(문자)이 캐시에 서 이미 마주친 블럭에 대하여 히트를 생성하게 함으로써 이들 중복을 활용해야 한다. 이는 양자에 대해 동일한 매핑 어드레스를 얻도록 변환되며, 그래서 비교될 때 그들의 불럭 컨텐츠는 일치해진다. 상기 순서에서 처음 세 문자 \"ABC\"가 이미 처리되었다고 가정해 보자. 그러한 캐시 상태는 도 1에 도시되어 있다. 표 1 <76> 매핑 어드레스 <77> 캐시 라인 ? A ? B ? C 뒤따르는 다음 \"CCC...\" 문자 런에 대한 히트를 구하기 위해 후속 C 각각은 앞서 마주친 \"C\"와 동일한 매핑 어 <78> 드레스에서 캐시되어야 한다. 이는 캐시 매핑 어드레스에 대한 입력으로 이전 문자들 차체를 사용하도록, 즉 캐 - 11 -공개특허 10-2009-0021149시 매핑 어드레스를 생성하기 위해 이전 문자들과 등가의 컴퓨터 이진 표현을 사용하도록 이끈다. 결과적으로 \"C\" 문자가 이전 문자 \"C\"의 기능인 매핑 어드레스의 라인에서 캐시되면 새로이 연속된 \"C\" 문자들은 비교될 때 매핑 어드레스가 같아지므로 히트를 생성한다. 도 2는 매핑 어드레스 K가 8 비트 길이이고 현재 블럭 크기 N도 8 비트 길이이고, 각 메모리 어드레스가 단지 <79> 데이터 블록을 차지하기 위한 하나의 로케이션을 포함할 때의 CMC 압축방법을 보다 상세하게 예시한다. 원시 스 트림으로부터 읽어오는 현재 블럭은 현재 문자(8 비트)를 수용하고, 매핑 어드레스에 이전 문자(8 비트)가 배정 된다. 압축방법은 그저 원시 스트림의 처음 8 문자를 처리하고 그 결과로 나온 순서를 압축 스트림으로 출력한 다. 미스 코드와 히트 코드는 각각 <m>X와 <h(X)>로 표현되며, X는 미스나 히트가 되는 블록이다. 도 2는 또한 (두번째 서브 스트링 \"AB\"가 처리된 후의) 캐시의 현재 상태와 (마지막 \"D\" 문자가 처리된 후의) 최종 상태를 도시한다. 히트는 캐시내의 원내에 표시되고, 나머지는 미스이다. 도 2에 도시된 것처럼 압축 과정은 두번째 서브스트링 \"AB\"를 검출하고 문자 \"B\"에 대한 대응 히트를 생성함으 <80> 로써 문자 런 \"CCC...\"와 \"DDD...\" 뿐만 아니라 스트링 매치도 검출한다. 캐시 라인은 주어진 시간에 단지 하나 의 블럭만을 차지한다는 것에 유의하시오. 이는 도 4와 관련하여 후에 보다 상세하게 설명될 직접 매핑 캐시 배 열에 대한 경우이다. 최우측 문자는 캐시에서 가장 최근의 블럭을 나타낸다. 히트가 일어날 때 현재 블럭은 그 러한 블럭이 결국 히트가 되는 것을 나타내기 위해 예시를 위하여 원을 가진 캐시로 표현된다. 매핑 어드레스는 실제로 캐시에서의 특정 세트를 가리킨다. CMC 코덱은 사용된 내부 캐시 구조와 긴밀하게 결합된다. 따라서 캐시 매트릭스를 변경하면 예를 들면 세트당 <81> 라인 수는 본 압축방법의 행위를 철저히 변화시키는 효과를 갖는다. 본 CMC 방법은 세 개의 매개변수 (N,K,Lines)와 한 개 코드의 측면에서 정의될 수 있다. 매개변수는 내부 캐시 <82> 의 메트릭스(블럭당 비트, 세트 어드레싱을 위한 비트, 라인 수)를 기술하고, 코드는 압축 스트림에서의 히트와 미스를 표현하는데 사용되는 인코딩을 정의한다. 라인은 또한 2L 라인을 암호화하는데 필요한 비트의 수인 L의 측면에서 정의될 수 있다. 본 CMC 압축방법은 세 개의 특정 캐시 구조 중 어느 하나를 이용하여 유리하게 이행될 수도 있다. 세 개의 캐시 <83> 구조는 본 압축방법의 세가지 특정 형태를 정의하고 다음과 같이 일컬어진다: 직접 매핑, 세트 연관 또는 전체 연관. 세 가지 방법은 설명을 위하여 의사 코드를 참조하여 설명되며, 의사 코드는 본 압축방법을 더 잘 이해하 고 이행에 대한 상세 내역없이 세가지 유리한 이행을 제공하기 위한 것으로 이는 본 기술에 대한 보통의 지식을 가진 사람에게는 명백할 것이다. 전체적으로 도 3을 참조하면 방법 10은 본 CMC 방법의 전체적 이행을 묘사한다. 방법 10은 하나 이상의 별개 컴 <84> 퓨터 메모리 어드레스를 워크스페이스로 이용하여 값들의 열(string)을 포함하는 원시 데이터 스트림으로부터 데이터를 압축한다. 각각의 컴퓨터 메모리 어드레스는 각각 하나 이상의 별개 값들을 차지하기 위한 하나 이상 의 로케이션을 갖는다. K가 0보다 크면 원시 데이터 스트림에서 현재 리딩 포인트 바로 직전에 있는 K 비트들은 메모리 어드레스 참조 <85> 로써 원시 데이터 스트림으로부터 읽혀지거나 입력된다 (단계 20). 현재 리딩 포인트 앞에 비트가 없으면 아무 런 K 비트도 읽히지 않으며, K에는 값 0이 배정될 것이다. 예를 들어 도 3과 함께 도 2를 참조하면 원시 데이터 스트림이 \"AACCCCABDDD\"라면 처음의 제1 리딩 포인트는 첫번째 A이다. A가 제1 위치에 있기 때문에 A를 앞서는 비트들은 없다. 그러므로 아무런 K 비트도 원시 데이터 스트림으로부터 읽혀지지 않는다. 따라서 K에는 값 0이 배정된다. 다음으로 K 비트들은 본 예제에서 A인 현재 부호(심볼)값으로써 원시 스트림으로부터 읽혀진다 (단계 30). <86> 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것하고도 일치하지 않으면 메모리 어드레스에서의 값들 중 <87> 하나를 대체하기 위한 현재 부호값, 즉 A가 기록된다. 이 외에도 현재 부호값이 뒤따르는 미스 코드 \"<m>\"은 압 축 데이터 스트림에 기록된다. 본 예제에서 현재 부호값, 즉 A는 메모리 어드레스의 어느 값, 실제로는 유일한 값인 0하고 일치하지 않으며, 그러므로 A가 뒤따르는 미스 코드 <m>은 압축 데이터 스트림에 기록된다 (단계 40). 히트 코드는 메모리 어드레스 참조에서 값이 발견된 로케이션을 나타내며, 그러한 현재 부호값이 메모리 어드레 <88> 스에서의 값들 중 어느 것이든 일치하면 압축 스트림에 기록된다 (단계 50). 본 예제에서 값 A가 메모리 어드레 스 0에서의 메모리 어드레스 내의 어떤 로케이션에서든 발견되지 않았기 때문에 히트 값은 압축 데이터 스트림 - 12 -공개특허 10-2009-0021149에 기록되지 않는다. 단계 60에서는 각 메모리 어드레서의 모든 값을 초기화한 후에 원시 데이터 스트림에서의 각각의 값에 대하여 <89> 그 방법이 반복되는데, 메모리 어드레스 참조의 가장 왼쪽의 비트들은 이용가능하지 않으면 원시 데이터 스트림 으로부터 적절히 초기화된다 (단계 60). 따라서 단계 20은 원시 데이터 스트림으로부터의 K 비트가 지금 B인 현 재 리딩 포인트 바로 앞에서 읽혀지거나 입력되는 경우에 처음으로 반복되고, 메모리 어드레스 참조에는 현재 리딩 포인트 직전의 값, 즉 A가 배정된다 (단계 20). 다음에 값 B는 원시 데이터 스트림으로부터 N 비트로 읽혀 지고, 현재 부호값이 배정된다 (단계 30). 단계 40에서 현재 부호값은 현재 부호값, 즉 B가 메모리 어드레스 A 에서의 어느 값, 실제로는 유일값과 일치하지 않기 때문에 메모리 어드레스 A에서의 값을 대체하기 위해 기록된 다 (단계 40). 이어서 현재 부호값, 즉 B가 뒤따르는 미스 코드는 압축 데이터 스트림을 대체하기 위해 기록된 다. 그 결과 현재 압축 스트림은 이제 <m>A<m>B를 포함한다. 방법 10은 다음 두 개의 값, 즉 C와 D에 대하여 두번 더 반복된다. 방법 10의 5번째 반복 중에 왼쪽으로부터 세 <90> 번째 C인 제5값이 원시 스트림으로부터 N 비트로 읽혀지고 (단계 30), 또한 C인 바로 직전의 값이 메모리 어드 레스 참조로 입력된다 (단계 20). 단계 40에서 현재 부호값 C는 사실상 C에 대응하는 메모리 어드레스에서의 현 재 값과 일치하지 않기 때문에 미스 코드나 현재 부호값은 압축 스트림에 기록되지 않는다. 대신에 단계 50에서 값 C가 발견된 메모리 어드레스 참조에서의 로케이션을 나타내는 히트 코드는 현재 부호값 C가 메모리 어드레스 참조 C에서의 값들 중 하나와 일치하므로 압축 데이터 스트림에 기록된다. 따라서 현재 압축 데이터 스트림은 이제 <m>A, <m>B, <m>C, <m>C <h(C)>이다. 그리고 나서 방법 10은 모든 값들이 처리될 때까지 반복된다. 방법 10은 압축 이득, 즉 원시 데이터 스트림에 대한 압축 데이터 스트림의 크기는 물론 처리 시간과 효율을 최 <91> 적화하기 위해 바라는 대로 변경될 수 있다. 예를 들면 단계 20에서 읽혀진 K 비트는 메모리 어드레스 참조로 사용되는, 결과어(resulting word)를 생성하기 위해 더 적은 수 또는 동수의 비트로 환원(reduced)/변환될 수도 있다. 예를 들면 읽혀진 K 비트는 그 후 아마도 워크스페이스 크기를 줄이려고 하는 해시 전략(hashing strategy) 후에 동수 또는 더 적은 수의 비트로 변환되고, 그리고 나서는 압축방법과 복원방법 양자를 위한 연 속 단계에서 메모리 어드레스 참조로써 사용된다. K 비트를 더 적은 수의 비트로 변환시키고, 그러므로 워크스페이스에 필요한 메모리의 양을 줄이는 한가지 방식 <92> 은 K 비트가 K-비트값을 메모리 어드레스 참조로 사용되기 전에 더 작은 R-비트값으로 변환시키는 해시 함수 (hash function)를 사용하는 것이다. 간단하지만 강력한 해시 함수를 예시하기 위해 두 정수를 나눈 나머지에 내는 모듈러스 연산자를 고려해 보자. 즉 D와 d가 정수이고 D>d이라면 \"D 모듈러스 d\"는 D/d의 나머지를 내고, 0과 d-1 사이의 또 다른 정수가 되는 것이 보장된다. 이는 원시 스트림으로부터 읽혀지는 모든 2K 메모리 어드레 스가 이용가능한 워크스페이스 메모리에서 어드레스할 수 없다면 매우 편리할 수 있다. 그러한 경우에 D에는 원 래 메모리 어드레스 참조가 배정되고 d에는 이용 가능한 실제 메모리 어드레스의 총수인 2R이 배정되고, \"D 모듈 러스 d\"의 결과가 환원된 새로운 메모리 어드레스에 배정되며 그 이후에는 워크스페이스를 어드레스하기 위해 사용된다. 이 외에도 단계 20에서 메모리 어드레스의 임의 상태 필드는 메모리 어드레스 내의 로케이션 이용을 추적하는데 <93> 사용될 수 있다. 그러면 그 방법이 단계 40이나 50에서 진행되므로 상태 필드는 메모리 어드레스로서 값을 읽거 나/기록한 후에 업데이트된다. 상태 필드는 미스가 일어날 때 값들이 어떻게 대체되는지 추적하는 세트 연관 압 축방법에 사용된댜. 상태 필드는 미스가 일어날 때, 즉 현재 부호값이 메모리 어드레스 참조에서의 값들 중 어느 것하고도 일치하지 <94> 않을 때의 값을 대체하기 위해 사용되는 전략에 따라서 다르게 이용되기도 한다. 전략과 상관없이 기대하는 것 은 상태 필드가 특정 메모리 어드레스에 대한 값을 대체할 때 사용할 로케이션의 최선의 평가를 제공한다는 것 이다. 실제에 있어 상태 필드는 로케이션이 메모리 어드레스에 존재하는 수 만큼의 카운터를 포함한다. 각각의 카운터는 적절한 특정 대체(replacement) 정책에 따라 각 로케이션이 대체되어야 할 순서(order)를 나타내는 순 위(rank)를 저장함으로써 특정 로케이션을 추적한다. 예를 들면 메모리 어드레스당 4개의 로케이션을 갖는 가장 덜 최근에 사용된(LRU) 대체 전략과 각 로케이션과 연관된 4개 카운터 각각에 저장된 다음의 값 3, 1, 0, 2을 일부 포인트에서 포함하는 상태 필드를 가정해 보자. 이는 메모레 어드레스의 로케이션 번호 0, 1, 2, 3이 값 3, 1, 0, 2를 가지고 상태 필드에서 연관LRU 카운터를 가진다는 의미이다. LRU 전략 하에서 이는 로케이션 0는 값 3을 갖는 최고 LRU 카운터를 갖기 때문에 가장 최근에 사용된 것이고, 다음은 LRU 카운터=2인 로케이션 3이 고, 로케이션 1은 LRU 카운터=1을 가지고 그 뒤를 따르며, 마지막으로 로케이션 2는 LRU 카운터=0를 갖고 뒤따 른다는 것을 의미한다. 그러므로 어느 값이 대체되어야 할 때 대체하기 위해 가장 낮은 LRU 카운터 값과 연관된 - 13 -공개특허 10-2009-0021149로케이션 번호가 선택되고, 아니면 이 경우에 대체 전략 자체가 제시하는 것처럼 가장 덜 최근에 사용된 로케이 션을 나타내므로 로케이션 2가 선택된다. 한편 상태 필드는 가장 오래된 값 대체 정책에서처럼 또 다른 정책이 사용되면 다르게 이행될 수도 있는데, 그에 의하여 상태 필드는 바람직하게는 카운터 대신에 선입선출(FIFO) 대 기 행렬(queue)로 인식되며, 새로이 대체된 로케이션들이 대기 행렬의 앞에 추가되고, 대체를 위해 사용된 가장 오래된 로케이션은 꼬리(tail)로부터 얻어진다. 사용된 대체 전략과 상관없이 상태 필드는 미스가 일어난 후에 값을 대체할 때 어느 로케이션이 선택되어야 할 지를 결정하기 위해 사용된다. 방법 10은 다양한 캐시 구조를 사용하고, 직접 매핑 CMC 방법 100 (도 4), 세트 연관 CMC 방법 200 (도 5)와 전 <95> 체 연관 CMC 방법 300 (도 6)을 비롯한 다양한 압축 스킴을 포함하기 위해 변경될 수 있다. 도 4를 참조하면 일반적으로 방법 100은 간단한 캐시 배열을 채용한다. 이 배열에서 캐시는 세트당 1줄로 이루 <96> 어지는데, 단지 하나의 데이터 블럭만 특정 세트에 저장될 수 있다. 그러므로 캐시 메트릭스는 <N,K,1>이다. 이 구조는 수반하는 대체 정책이 없거나 아니면 반대로 전략이 최소이므로, 예를 들면 미스가 일어나면 세트에서 이용 가능한 유일한 블럭을 대체하므로 내부 블럭 취급을 단순화시킨다. 직접 매핑 캐시는 세트 연관 압축방법 200과 전체 연관 압축방법 300에서 이행되는 대체 정책에 대한 상태 비트를 필요로 하지 않는다. 그러므로 직접 매핑 캐시는 본 발명의 다른 특징에 따라서 세트 연관이나 전체 연관 캐시보다 더 빠르고 자원에 덜 집중한다. 그러나 교환은 다른 배열과 비교했을 때 히트율이 더 낮다. 이제 구체적으로 도 4를 참조하면 직접 매핑 CMC 압축방법 100은 선언된 현재 블럭, 라인과 세트를 차지하는 변 <97> 수를 찾는 것을 포함한다. 다시 이것들은 각각 현재 부호값, 로케이션 번호와 메모리 어드레스 참조를 표현한다. 방법 10 (도 3)의 유사 단계들이 도 4에서 100으로 늘어난다. 세트는 0으로 초기화된다 (단계 105). N 비트는 원시 데이터 스트림으로부터 읽혀지고 블럭으로 복사되며, 스트림이 파일을 지칭하면 연관된 파일 포 인터가 없데이트, 즉 N 비트만큼 전방으로(forward) 이동한다 (단계 130). 데이터 블록은 데이터 스트림의 끝에 도달하지 않는 한 원시 스트림으로부터 읽혀진다 (단계 130). 현재 블록은 특정 세트에서 조사되고, 직접 매핑 캐시에서는 세트당 오직 1줄만이 있기 때문에 유일한 그 줄이 <98> 조사된다 (단계 134). 블록이 해당 라인의 내용과 일치하지 않으면 미스가 일어나고, 그 블럭은 캐시 라인에 기 록된다 (단계 136). 나아가 블록이 발견되지 않으면 \"미스\" 코드나 마커 역할을 하는 1비트 값이 압축 스트림에 기록된다 (단계 <99> 140). 마커의 값은 상수 MISS이다 (단계 140). 나아가 현재 블록은 압축 스트림에 기록된다 (단계 142). 압축 데이터 스트림의 복원이나 감압 중에 미스가 일어나기 때문에 그 복원방법은 상세히 후술하는 것처럼 캐시로부 터 블록을 얻을 수 없다. 그러므로 블록은 나중에 복원될 수 있도록 압축 스트림에 복제될 필요가 있다 (단계 142). 대신에 블럭이 발견되면 (단계 136) 히트가 일어났다는 것을 가리키기 위해 1 비트 값이 압축 스트림에 기록된 <100> 다 (단계 150). 히트 마커는 캐시로부터 블록을 추출하기 위한 복원방법 중에 사용된다. 직접 매핑 방법 100에 는 세트당 1줄만 있기 때문에 단계 150에서 압축 스트림에 라인 번호를 암호화할 필요가 없다. 현재 세트의 값은 방법 100의 다음 반복을 위해 준비된다 (단계 160). 업데이트 과정은 도 2에 도시된 것처럼 <101> 각 반복 라운드 종료 시에 N 비트를 오른쪽으로 이동시키고 스트림 내의 해당 포인트에서 K 비트를 읽어오는 원 시 스트림의 위에 있는 \"이동 플레이스홀더(shifting placeholder)\"와 개념적으로 유사하다. 이 동작은 현재 블 록이 원시 스트림으로부터 방금 읽혀진 동일한 N 비트를 포함하기 때문에 세트 변수 N 비트의 내용을 왼쪽으로 이동시키고 블록으로부터 N 비트를 읽어오는 것과 기본적으로 같다. 직접 매핑 압축방법 100은 메트릭스 <N,K,1>을 갖는 특정의 직접 매핑 워크스페이스를 이용한다. 이 배열에서 <102> 메모리 어드레스당 단지 하나의 로케이션이나 라인이 사용되는데, 하나의 값만이 저장되게 한다. 이는 정책이나 상태 필드 어느 것도 필요로 하지 않기 때문에 미스된 값의 대체를 하찮게 한다. 또한 각 메모리 어드레스가 하 나의 값만을 저장하기 위한 하나의 로케이션을 갖기 때문에 HIT 코드는 현재 메모리 어드레스 참조에서 찾아낸 값의 단순한 발생, 즉 히트 자체의 발생을 표현한다. 이제 도 5를 참조하면 방법 200은 현재 압축방법의 세트 연관 CMC 압축방법 형태이며, 방법 10과 방법 100에 대 <103> 한 유사 단계가 각각 100과 200으로 상승한다. 방법 100처럼 단계 205에서 블럭, 라인과 세트가 초기화된다. 다 음 데이터 블럭은 원시 데이터 스트림으로부터 읽혀진다. 직접 매핑 방법 100과 다르게 조사할 라인이 두 개 이 상이다. 그러므로 특정 세트로부터의 모든 라인들이 조사된다 (단계 234). 블럭이 어느 라인의 내용과도 일치하 지 않으면 미스가 일어나고 그 블럭은 캐시에 기록된다 (단계 236). - 14 -공개특허 10-2009-0021149방법 100과 유사하게 블럭이 발견되면 히트를 가리키는 1 비트 값이 압축 스트림에 기록된다 (단계 250). 그러 <104> 나 세트당 2 라인 이상이기 때문에 비압축 데이터 스트림의 복원 중에는 복원방법이 어느 라인으로부터 블록을 회수(retrieve)해야 할 지 알 방법이 없다. 결과적으로 히트 마커는 충분치 않으며 복원방법은 다음 단계로 전 달될 히트가 일어난 곳의 라인 번호를 필요로 한다. 히트 마커가 기록된 후에 히트가 일어난 곳의 라인 번호는 암호화되어 압축 스트림에 기록된다 (단계 252). 암 <105> 호화는 라인을 식별하기에 충분하기만 할 필요가 있고, 그러므로 라인 번호의 2진 표현을 차지하는 L 비트로 이 루어진 고정 코드 길이만큼 간단하다 (단계 252). 그러나 미스가 일어나면 단계 200이 단계 100과 비슷한 방식으로 진행되는데, 미스 마커를 압축 스트림에 기록 <106> 하고 (단계 200), 미스 블럭을 압축 스트림에 기록하는 (단계 242) 것을 포함하고, 현재 세트의 값은 다음 반복 을 위해 준비된다 (단계 260). 방법 200의 구체적인 후속 이행에서, 방법 200은 값을 대체할 때 어느 로케이션을 이용해야 하는지 결정하기 위 <107> 한 대체 정책을 더 포함할 수 있다. 이는 그 방법이나 함수 SearchBlock_WriteIfMiss() (단계 236)에 의해 내 부적으로 이루어진다. 전형적인 대체 정책은 가장 바람직한 것에서 가장 덜 바람직한 순서로 가장 덜 최근에 사 용된(LRU), 선입선출(FIFO) 또는 가장 오래전 사용된, 가장 덜 빈번히 사용된(LFU), 랜덤(random) 등을 포함한 다. 이들 대체 정책들과 연관되는 방법들은 블럭이 캐시 내부에서 어떤 이유로든 엑세스될 때마다 방법들 ReadBlock()와 SearchBlock_WriteIfMiss() 내부에서 구해진다(invoked) (단계 230과 단계 236). 대체 정책이 어떻게 작업하는지 이해하기 위해, 다음의 구체적인 예를 가지고 가장 덜 최근에 사용된(LRU) 대체 <108> 정책이 다음으로 설명된다. 4개 로케이션을 갖는 메모리 어드레스와 각 어드레스와 연관된 4개 LRU 카운터를 포 함하는 상태 필드를 고찰한다. 압축 과정 중의 일부 지점에서 LRU 카운터는 값들 3, 0, 2, 1을 각각 포함한다고 가정한다. 이는 연관된 LRU 카운터가 최대값 3을 갖기 때문에 로케이션 0가 가장 최근에 이용된 로케이션이고, 반면에 연관된 LRU 카운터가 최소값 0을 갖기 때문에 로케이션 1이 가장 덜 최근에 사용된 로케이션이다. 그러 므로 미스가 일어날 때 그것이 가장 덜 최근에 사용된 것이라는 것을 나타내는 LRU 카운터가 0이기 때문에 대체 를 위해 로케이션 1이 선택된다. 이제 히트가 로케이션 3에서 일어난다고 가정한다. 이 예제에서 LRU 카운터는 다음과 같이 업데이트된다. 로케이션 3이 이제 가장 최근에 사용된 것이기 때문에 모 <109> 든 LRU 카운터들은 따라서 로케이션 이용에 새로운 변화를 반영하기 위해 업데이트될 필요가 있다. 이는 LRU 카 운터를 업데이트하는 일반적 과정이고, 히트가 일어난 로케이션과 연관되는 현재 LRU 카운터 값은 T로 읽혀진다. 다음으로 T보다 큰 값을 갖는 모든 LRU 카운터는 1씩 줄어든다. 마지막으로 현재 LRU 카운터에는 최 대값이 배정되며, 그러므로 가장 최근에 이용된 로케이션이라는 태그가 붙는다. 그러므로 히트가 현재 카운터 값들 3, 0, 2, 1을 갖는 로케이션 3에서 일어날 때 그러한 카운터들은 다음과 같이 업데이트된다. T에는 로케이 션 3의 LRU 카운터 값인 1이 배정된다. 다음으로 T보다 큰 값을 갖는 모든 LRU 카운터들은 1씩 줄어든다. 그래 서 LRU 카운터들은 2, 0, 1, 1이 된다. 마지막으로 현재 LRU 카운터에는 최대값 3이 배정된다. 이 때문에 LRU 카운터는 이제 2, 0, 1, 3이 된다. 간략하게 LRU 대체 정책은 각 로케이션에 대한 이용 순위(usage rank)를 표 현하는 다른 LRU 카운터값들이 항상 있는 식으로 작업한다. 대안 형태로써 변수 길이 코딩 스킴은 가장 정상적으로 사용되는 더 낮은 로케이션들이 더 짧은 코드를 사용하 <110> 여 표현되는 반면에 덜 자주 사용되는 더 높은 번호의 로케이션들에는 더 긴 코드가 배정되는 식으로 배정되는 히트와 미스 코드를 위해 사용될 수 있다. 문헌에서 가능한 변수 길이 코딩 스킴의 일부는 히트와 미스 코드를 배정하는데 이용될 수 있다. 예를 들면 메 <111> 모리 어드레스당 로케이션의 수가 적으면, 즉 2, 3 또는 4이면, 각 로케이션 번호를 나타내기 위해 Huffman이 사용될 수 있다. 로케이션 번호가 더 크면, 제1 단계 종료 코드가 Huffman 스킴보다 훨씬 더 빠르게 생성되기 때문에 바람직하다. 예를 들면 변수 길이 코딩 스킴은 두가지 패스를 포함할 수 있다. 제1 패스는 각 로케이션에서 이용 빈도를 계 <112> 산하는데 이용되고, 제2 패스는 가장 빈번히 이용되는 로케이션에 가장 짧은 코드가 배정되는 반면에 가장 덜 빈번하게 사용되는 로케이션에는 더 긴 코드가 배정되는 식으로 각 로케이션을 표현하는 변수 길이 코드를 배정 하는데 이용된다. 예를 들면 메모리 어드레스당 2개 로케이션이 이용된다고 가정해 보자. 결론적으로 로케이션 0과 로케이션 1에서 일어나는 미스 백분율과 히트 백분율을 카운트하기 위한 압축방법을 실행함으로써 제1 패스 가 수행된다. 그러므로 제1 패스 중에는 어떤 출력도 압축 스트림에 기록되지 않는다. 백분율이 pA, pB와 pC로 얻어진 후에, 여기서 pA는 미스의 백분율이고, pB는 로케이션 0에서의 히트 백분율이고 <113> - 15 -공개특허 10-2009-0021149pC는 로케이션 1에서의 히트의 백분율이며, pA, pB와 pC에 대하여 Huffman 트리가 생성되고, 도 11의 Huffman 트리에 도시된 것처럼 미스(A), 로케이션 0에서의 히트(B)와 로케이션 1에서의 히트(C)를 표현하기 위한 Huffman 코드가 배정된다. pA<pB<pC를 의미하는 A<B<C라면 A, B와 C는 다음과 같은 Huffman 코드가 배정되게 한다: 11, 10과 0. 나아가 대안으로써 로케이션 번호를 암호화하기 보다는, 각 로케이션마다 하나씩 상태 필드에 보관된 LRU 카운 <114> 터의 값이 대신에 암호화된다. LRU 카운터들은 LRU 대체 정책을 이행하고 각 로케이션에 대한 이용 순위를 나타 내어 더 높은 값이 더 최근에 이용된 로케이션을 나타내고, 아니면 그 반대를 나타내는데 사용된다. 그러므로 더 높은 LRU 카운터값에는 더 짧은 코드가 배정되는 반면에 더 낮은 값에는 더 긴 코드가 배정된다. 캐시 라인 번호 자체를 암호화하는 대신에 캐시 라인과 연관된 LRU 카운터를 암호화하는 논거는 다음과 같다. 더 최근에 사용된 라인들이 덜 최근에 사용된 것보다 장래 히트를 얻을 가능성이 더 많기 때문에 각 라인의 이용 순위는 해당 라인에 대한 히트 발생의 확률과 상관관계가 있을 수 있다. 이 때문에 이러한 가정 하에 최고 순위를 갖는 라인 카운터는 다음 히트를 구할 가능성이 더 높고, 두번째로 높은 순위를 갖는 카운터가 뒤에 오는 등 순위가 0이 될 때까지 그러하다. 순위 0는 매칭 블록을 가질 확률이 가장 낮은 라인을 나타낸다. 기대하는 것은 더 높 은 LRU 계수 (더 최근에 엑세스 된)를 갖는 라인들이 더 낮은 LRU 계수를 갖는 라인들보더 더 많은 히트를 산출 한다는 것이다. 이러한 트렌트가 충족되면 히트를 표현하는 평균 코드 길이가 줄어들게 되므로 압축을 개선한다. 압축방법 10, 100과 200은 컴퓨터 메모리를 워크스페이스로 이용하여 현재 스트림값에 대한 입력으로 이용되는 <115> N 비트, 메모리 어드레스용 입력으로 이용되는 K 비트, 메모리 어드레스 참조에서 값들이 발견되는 로케이션을 나타내는데 이용되는 L 비트와 히트나 미스가 결과로 나오는 지를 나타내는 출력으로서 이용되는 1 비트를 갖는 의사 캐시 메모리로서 이행하는데 사용될 수 있다. 라인 번호를 나타내기 위해 고정 길이 코드를 이용하는 것은 모든 라인 번호들이 동등한 분포를 가질 때 유리하 <116> 다. 그러나 이러한 불변은 실제에서는 바람직하지 않을 수 있다. 캐시 라인이 불균일 분포를 나타낼 수 있다면 히트와 미스의 평균 코드 길이는 더 자주 평가되는 라인에 대해 더 짧은 코드를 배정함으로써 더욱 줄어들 수 있다. 캐시 세트당 두개 이상의 캐시 라인이 있는 압축방법을 선택할 때 히트를 표현하기 위한 1 비트 마커의 사용은 그 중요성을 상실한다. 암호화 문제는 그러한 미스 발생과 히트가 일어나는 라인 번호의 측면에서 다시 언급되어야 한다. 이 때문에 암호화하는 부호들은 본질적으로 (1+LINES)이다: 즉, MISS를 표현하는 \"1\" 코드와 매 히트가 일어나는 캐시 라인을 표현하는 \"LINES\" 코드이다. 한가지 한계는 라인을 세트 내의 위치로, 즉 라인 번호로 암호화하는 것은 상관관계가 적다면, 즉 균일 분포를 <117> 나타내면 코드 길이 감소 측면에서 이득을 제공하지 않는다는 것이다. 이는 캐시 라인과 관련된 또 다른 속성이 대신에 사용되면, 예를 들면 방법 200과 관련하여 전술한대로 LRU 카운터의 값을 이용한다면 극복될 수 있다. 또 다른 한계는 히트와 미스를 암호화하고 복호화하는데 더 많은 시간이 수반된다는 것이다. 그러나 이는 코딩 과 모델링을 모두 고려하는 어떠한 방법에서든 일반적인 경우이다. 그러한 총체적 시간은 히트 코드의 불균일 분포를 강제하기 위해 앞에서 논의된 변형과 연계하여 히트와 미스 코드의 정적 배정을 이용함으로써 감소될 수 있으며, 따라서 평균 코드 길이를 감소시키는 대부분의 가변 길이 암호화 스킴을 만들고 압축을 개선할 수 있다. 이제 도 6과 도 7을 전체적으로 참조하면 완전 연관 CMC 방법은 2K 세트를 표현하는 비트의 수인 K가 최소, <118> 즉 0 비트로 감소될 때의 시나리오에 관한 것이다. 그 결과는 전체 캐시에서 하나의 세트만이 있는 완전 연관 캐시이다. 도 7은 메트릭스 <N,0,2L>을 갖는 완전 연관 캐시 배열의 예를 도시한다. 방법 300에 의해 이행되는 내부 캐싱 과정의 의미있는 한가지 효과는 매핑 어드레스가 본질적으로 제거되는 것이다. 그 결과 CMC 코덱 방 법 300은 블록을 조사할 때 (단계 334), 블록을 읽어올 때 (단계 330) 그리고 캐시에 블록을 기록할 때 (단계 340, 342 및 350) 현재 블록만을 필요로 한다. 세트변수는 항상 0이다. 방법 100과 200과는 달리 방법 300은 루 프의 마지막 단계 후에, 즉 단계 342, 352 후에 변수를 업데이트할 필요가 없다. 완전 연관 압축방법 300은 방법 100과 200보다 더 많은 히트를 생성하는데도 불구하고 방법 300은 더 높은 압축 <119> 비를 산출하지 않는다. 이는 두가지 이유 때문이다. 첫째 양호한 히트비를 달성하기 위해서는 세트에서의 라인 수가 충분한 블록을 수용할 정도로 클 필요가 있다, 그리고 둘째 다수의 히트수를 가짐에도 불구하고 고정 길이 코딩은 암호화된 모든 히트 라인이 압축 스트림에서 동일 길이를 가져 궁극적으로 동일 길이의 후속 데이터 블 럭을 갖기 때문에, 즉 정확히 2N 캐시 라인이 캐시 세트당 사용된다면 N 비트이기 때문에 그러한 이점을 충분히 - 16 -공개특허 10-2009-0021149취할 수 없다. 그러나 후자의 변형은 정당한 방법이며, 보다 완전한 설명이 후술될 것이다. 완전 상관 방법 300에서 메트릭스 <N,0,Lines>를 갖는 완전 연관 워크스페이스가 이용된다. 이러한 배열에서는 <120> 다수 로케이션을 갖는 하나의 메모리스 어드레스만 이용되어 다수 값이 동일 메모리 어드레스에 동시에 저장될 수 있게 한다. 이는 히트가 일어나는 로케이션을 압축 스트림 내로 암호화시키는 추가적 복잡도(complexity)를 삽입하여 복호자는 원래 데이터 스트림을 복원할 수 있다. 그러므로 이 경우에 그러한 로케이션을 표현하기 위 해 HIT 코드가 이용된다. 후속 형태로 완전 상관 방법 300은 메모리 어드레스당 적어도 2N 로케이션을 사용하여 MISS 코드의 필요성을 완 <121> 전히 제거하고, 각 로케이션에 대하여 특정 값들인 0, 1, 2, ... 2N-2, 2N-1 을 초기화함으로써 성능을 향상시키 도록 변형될 수 있다. 따라서, 들어오는 값이 N 비트 길이이기 때문에, 이전에 워크스페이스에 초기화된 로케이 션으로부터의 어떤값과 매칭되는 2N 에서 가능한 값이 존재한다. 다시 이 경우에 그러한 로케이션을 표현하기 위 해 HIT 코드가 이용된다. 이 경우에 워크스페이스를 위해 사용된 특정 메트릭스는 <N,0,Lines>인데, Lines는 2 의 N승, 즉 <N,0,Lines>=<N,0,2N>이다. 이제 도 8을 참조하면 일반 CMC 압축방법 400은 방법 100, 방법 200과 방법 300을 통합하는데, 이번 개시에 근 <122> 거하여 즉시 명백해진다. 방법 400은 앞의 방법 100, 200과 300으로부터의 단계들을 포함하지만, 그렇지만 각각 100 내지 300 상승한다. 방법 400에서 데이터 블록은 원시 스트림으로부터 검색되고 (단계 430), 발견되지 않으면 캐시되고 (단계 434, <123> 436), 히트들이 암호화되고 (단계 450, 452), 미스들이 암호화된다 (단계 440, 442). 세트 연관 스킴에 더 많은 라인이 추가되면 (단계 439), 그러면 히트 라인은 당연히 암호화되어야 한다 (단계 452). 연관 스킴에 하나의 세트만 있다면 (단계 455) 그러면 세트 어드레스는 관련이 없으며, 따라서 단계 460과 462는 수행되지 않는다. 특정 캐시 방법과의 주요 차이점은 도 8에서 회색으로 진하게 강조되어 있다. 방법 400과 방법 10, 방법 100, 방법 200과 방법 300 사이의 또 다른 차이점은 히트 마커가 히트 라인의 암호화 <124> 와 머지(merge)되고 암호화 자체는 히트와 미스 모두에 대해 개방형으로 남는다는 것이다. 이는 다수의 암호화 가능성을 드러내는데, 가변 길이 스킴이 가장 효과적일 가능성이 있다. 대조적으로 세트 상관과 완전 상관의 경 우에, 즉 방법 200과 방법 300에 대하여 암호화는 라인의 이진 표현을 지지하는 L 비트로 이루어진 고정 길이 스킴에 의해 명백하게 정해진다. 방법 400에서 히트와 미스는 방법 200에서 배정되는 방법과 동일하게 암호화되거나 배정된다. 예를 들면 히트와 <125> 미스는 가장 빈번히 이용되는 더 낮은 로케이션은 더 짧은 코드로 표현되고, 덜 자주 이용되는 더 높은 로케이 션은 더 긴 코드로 표현되는 식으로 암호화된다. HIT 코드에 대한 가변 길이 코드는 현재 부호값이 발견되는 메 모리 어드레스 참조 내에서의 로케이션을, 즉 히트가 일어난 로케이션을 불일치(미스)가 일어날 때 어느 값이 표현되어야 할지 결정하는 LRU 대체 정책과 연계하여 표현한다. 압축방법 400은 히트에 대한 가변 길이 코드를 암호화한다. 유사하게 복원방법은 그러한 코드를 복호화한다. 이는 각 메모리 어드레스가 두 개 이상의 로케이 션을 가질 때만, 즉 한 개보다 많은 값을 동시에 저장할 수 있을 때만 적용가능하다. 그러므로 라인이 엄밀하게 한 개보다 큰 특정 메트릭스 <N,K,Lines>를 갖는 세트 연관 구성에 적용할 수 있다. 워크스페이스로 이용되는 컴퓨터 메모리는 현재 부호값에 대한 입력으로 이용되는 N 비트, 메모리 어드레스 참 <126> 조에 대한 입력으로 이용되는 K 비트, 메모리 어드레스 참조에서 값들이 발견되는 로케이션을 나타내기 위한 출 력으로 이용되는 L 비트, 그리고 히트나 미스가 결과로 일어났는지 나타내기 위한 출력으로 이용되는 1 비트를 갖는 의사 캐시 메모리로서 이행된다. 의사 캐시 메모리는 압축방법 10, 100, 200, 300과 400의 워크스페이스를 이용하기 위해 사용된다. 용어 \"의사 캐시 메모리\"는 이 문맥에서 컴퓨터 아키텍처에서 사용된대로 실제 건축 (architectural) 캐시 메모리와 캐시 매핑 압축 (CMC) 패밀리를 망라하는 모든 압축방법과 복원방법이 사용하는 내부 워크스페이스와의 유사점을 강화하기 위해 사용된다. 특히 의사 캐시는 컴퓨터의 중앙처리장치(CPU)와 주 메모리 사이에 생기는 내부 데이터 캐싱 메카니즘과 닮았지만, 입력 스트림에 대해서는 CPU를 출력 스트림에 대 해서는 주 메모리를 대신한다. 결과적으로 각 캐시에 대한 데이터 지역성(locality properties)은 다르게 활용 된다. 의사 캐시 메모리는 압축을 생성하기 위한 시도로 그러한 데이터 지역성의 공간 및 시간적 측면을 활용하 는 반면에, 건축 캐시는 대신에 메모리 엑세스를 가속화하려고 시도한다. 의사 캐시 메모리는 이행된 워크스페 이스가 압축방법과 복원방법을 각각 수행하기 위해 가질 필요가 있는 특정 입력과 출력의 측면에서 기술된다. 도 9를 참조하면 일반적으로 CMC 복원방법 500은 현재 압축방법을 이용하여 이전에 생성된 압축 데이터 스트림 <127> - 17 -공개특허 10-2009-0021149으로부터 원래의 원시 데이터의 정확한 복사본을 생성한다. 방법 500은 압축방법10, 100, 200, 300과 400과 유 사한 측면을 도입하는데, 예를 들어 압축 도중에 사용된 동일한 캐싱 이력 방법은 방법 500에서 복원동안에 복 제된다. 이제 특히 도 9를 구체적으로 참조하면 다양한 변수, 즉 Block, Line, Set와 Token이 초기화된다 (단계 505). <128> 방법 500의 각 루프나 반복 중에 하나의 데이터 블럭이 추출되어 복원 또는 비압축 스트림에 기록된다. 그 블럭 은 미스된 코드가 복호화되면 압축 스트림으로부터, 히트 라인이 대신에 복호화되면 캐시로부터 나온다. 미스 마커가 검출되면 그 불럭은 우선 압축 스트림으로부터 읽혀지고 캐시된다. 그렇지 않으면 복호화된 히트 라인은 캐시 내의 현재 세트로부터 직접 블록을 검색하기 위한 인덱스로 이용된다. 구체적으로 도 9를 참조하면 (임시 히트와 미스 코드를 차지하는) 현재 블록, 라인, 세트 및 토큰에 대한 지역 <129> 변수가 선언된다 (단계 505). 세트는 처음에 0으로 초기화된다. 다음으로 토큰은 미스 마커나 히트 라인이든 차지해야만 하는 경우에 읽혀지고 복호화된다 (단계 530). 압축 스 <130> 트림은 스트림 종료 때까지 완전히 읽혀진다 (단계 532). 미스 마커가 검출되면 (단계 538) 그러면 자연적으로 미스 블럭이 따라온다. 그러므로 미스가 다음 원시 스트림으로부터 읽혀지고 (단계 540) 캐시로부터 현재 LRU 라인에 기록된다 (단계 542). 그렇지 않으면 블록은 복호화된 히트 라인에 있는 캐시로부터 직접 읽혀진다 (단 계 550). 다음에 단계 542나 단계 550으로부터 얻은 블록은 복원 또는 비압축 데이터 스트림에 기록된다 (단계 555). 현 <131> 재 세트는 해당되면 업데이트되고 (단계 560), 방법 500은 단계 530에서 재개된다. 후속 형태로 HIT와 MISS 코덱/값은 데이터 복원 중에 감압방법을 안내하는데 이용되는 제어 비트인 토큰으로 그 <132> 룹이 된다. 토큰은 N 비트의 배수이며 그래서 원시 또는 압축 스트림으로부터 읽혀진 값들은 압축 또는 비압축 스트림으로 복제될 때 N 비트의 배수로 정렬된 채로 있다. N 비트가 8 비트 길이, 즉 1 문자 바이트라면 히트와 미스 코드는 n-바이트 토큰으로 그룹이 되는데, n은 집합 {1,2,3,...}으로부터의 자연수이며, 그래서 원시나 압 축 스트림으로부터 읽혀진 값들은 도 12의 압축 출력 데이터에서 도시된대로 압축 또는 비압축 스트림 각각에 복제될 때 바이트 정렬된 채로 있다. 그 결과 실시간으로 압축 데이터가 포맷되는 방식을 재배열하여 개별 비트 에 대한 입력/출력 연산을 단순화시키는 압축 데이터 스트림 상에서 임의 최적화가 수행되어야 한다. 이는 모든 HIT와 MISS 코드를 함께 고정 길이 토큰으로 조합한다. 각 토큰은 N의 배수인데 그 길이는 원시 데이터 스트림 으로부터 읽혀지는 각 후속 값들의 비트이다. 전형적으로 N은 8 비트 길이로 이루어지는데, 즉 각각의 후속 값은 1 문자 바이트이며, 이는 각 토큰이 바이트 <133> 의 배수, 또는 n-바이트 길이이며, n은 집합 {1,2,3,...}으로부터의 자연수라는 것을 의미한다. 이러한 최적화 는 토큰(히트/미스 코드)와 원시 스트림 값을 N-비트 바운더리에 정렬하고 압축 및 비압축 데이터 스트림 모두 에 대한 입력/출력 동작을 단순화시키는 효과를 갖는다. 이는 현재 압축방법과 복원방법의 전체 속도를 개선시 킨다. 이제 현재 압축방법은 이전 압축방법에서는 찾을 수 없는 특징과 장점을 제공하는 것이 확실해질 것이다. 현재 <134> CMC 코덱은 범용이고 모든 소스에 대하여 대단히 동일한 방식으로 그리고 입력 데이터의 특징과 상관없이 입력 스트림으로부터 받은 데이터 블럭을 처리한다. 현재 방법의 더 나은 특징은 대칭적이라는 것이다. 이는 CMC 압축방법과 복원방법이 모두 상대적 노력, 시간과 <135> 공간 복잡도 등에 측면에서 본질적으로 동일한 과정을 수행한다는 것을 의미한다. 그러한 대칭적 행위는 CMC 코 덱의 시간/공간 복잡도를 분석할 때 더 분명해 진다."}
{"patent_id": "10-2008-7025942", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "이 외에도 현재 CMC 코덱은 \"배타 스트림\" 모드로 작업한다. 요약하면 이는 입력 스트림으로부터 받은 모든 부 <136> 호가 \"한 번에 하나씩\" 처리되고, 보다 중요하게는 그러한 부호를 처리한 직후에 출력이 생성된다는 것을 의미 한다. 이는 대부분의 이전 압축방법이 일반적으로 정상 스트림 모드나 블럭 모드로 작용하기 때문에 이전 압축 방법과는 다르다. 정상 스트림 모드에서 부호들은 한 번에 하나씩 처리되지만 그들의 출력은 직후에 생성되지 않는다. 오히려 주어진 수의 입력 부호들이 내부적으로 빌드업되어(build up) 처리될 수 있을 때까지 지연된다. 블럭 모드에서는 압축자는 원시 데이터 스트림으로부터 고정된 수의 부호들, 대개 2~3 킬로바이트를 읽어와서 처리하고 등가의 압축 블록을 생성한다. 현재 방법에 의해 이행되는 \"배타 스트림\" 모드로부터 몇가지 이점이 얻어진다. 예를 들면 디지털 통신에서 주 <137> 어진 통신 과정이 송신기로부터 수신기로의 간헐적인 데이터 흐름을 유지하는 것이 필요할 수도 있다. 데이터가 송신기로부터 정상 간격으로 전송되지 않으면 수신기는 송신기와의 데이터 동기화(sync)를 잃을 수도 있다. 그 - 18 -공개특허 10-2009-0021149통신 과정이 정상 모드나 블럭 모드에서 작용하는 압축 기술에 의존한다면 그러면 수신기는 송신기가 휴지기일 (idle) 때의 간격(intervals) 중에 데이터 sync를 잃을 수 있는 반면에, 압축기는 입력 부호를 내부적으로 빌드 업하여 처리한다. 대조적으로 CMC 기술과 연관된 현재 방법이 대신 사용되면 이들 방법은 수신된 모든 입력 부 호에 대하여 등가의 출력을 즉시 생성하기 때문에 데이터 sync 손실의 가능성이 없다. 이는 디지털 통신의 특정 영역에 대하여 배타 스트림 모드 대 정상 스트림 또는 블럭 모드의 이점을 강조하는 단지 하나의 예제이다. 배타 스트림 모드로부터의 유사 장점들은 실시간 대응을 필요로 하는 다른 영역에서 얻을 수 있다. 예를 들면 <138> 사용자가 하나의 문자를 입력하고, 그 문자가 인터넷 (또는 다른 채널)을 거쳐 전송되고 마침내 채팅 윈도우 상 에서 그 문자를 보기를 기대하고 있는 수신인이 받는 간단한 채팅 어플리케이션을 살펴보자. 스트림이나 블럭 모드에서 압축자가 문자들을 처리하기 시작하기 위해서는 2~3 문자가 먼저 수신되어야 하기 때문에 그러한 문자 는 (전송기 측에서의) 압축자가 그 문자를 방출하지 않을 때까지는 전혀 디스플레이지 되지 않는다. 대조적으로 CMC 압축자의 배타 스트림 모드는 압축 문자가 압축자에 의해 즉시 방출되어 채널을 통해 전송되고, 그 후에는 감압기가 원래 문자를 복원하여 디스플레이를 위해 채팅 어플리케이션으로 방출된다는 것을 보장한다. CMC 코덱의 대칭 행위는 또한 고유의 실질적인 이점을 갖는데, 이는 코덱에 의해 사용되는 대부분의 내부 자원 <139> 을 \"공유\"하는 것이다. 이는 동일한 방법이 수행되기 때문이지만, 반대 방향에서 실행되기 때문이다. 그러므로 하나의 작동 모드는 나머지 모드가 휴지기인 동안에 공유된 자원을 이용할 수 있다. 이는 동작과 설계 비용을 최소화시킨다. 완전 연관 CMC 스킴의 일면은 일부 캐시 메트릭스가 특정 조건을 만족하도록 강제함으로써 미스 확률이 문자 그 <140> 대로 0%가 될 수 있다는 것이다. 즉 원시 스트림으로부터 읽혀진 현재 블록과 매치하는 캐시에 항상 블록이 있 을 것이다. 그러므로 히트가 항상 생성되면 히트나 미스를 마크하는 것이 전혀 필요치 않고, 압축된 출력은 그 저 암호화된 히트 라인으로 이루어진다. LRU 스킴과 결합하고, 더 짧은 코드가 가장 빈번히 사용되는 라인에 배 정되고, 그리고 마지막으로 출력 스트림에서 암호화되면 그러면 결과적인 방법은 전방 이동(Move-To-Front)으로 불리는 코딩 기법으로 변질된다 (degenerate). 전방 이동법은 완전 상관 CMC 코덱의 변형으로 간주될 수 있고 기존의 워크스페이스 인프라스트럭쳐를 이용하여 <141> 쉽게 이행될 수 있는데, 캐시 초록 데이터형(ADT)을 통해 모델화될 수 있다. 이러한 과정을 예시하기 위해 완전 상관 캐시가 메트릭스 <N,0,2N>으로 생성된다고 가정하자. 즉 LINES (캐시 라인의 수)는 모든 가능한 별개 데이 터 블럭의 수인 2N이다 (예를 들면 N=8이면 세트에는 256개 라인이 있다). 모든 캐시 라인이 별개 데이터 블럭 을 차지하도록 초기화되면 그래서 0에서 2N개의 라인에는 각각 0에서 2N개 각각의 값을 갖는 블럭이 있고, 그래 서 블럭이 원시 스트림으로부터 읽힐 때마다 캐시 내의 일부 라인에 항상 매칭 블럭이 있기 때문에 항상 히트가 생성된다. 작동 관점으로부터 CMC 코덱은 캐시 메트릭스의 경계(border) 조건에 따라 기능성을 \"이동시킨다.\" 도 10은 현 <142> 재 방법의 이러한 측면을 도시하는 다이어그램이다. 캐시 라인의 수가 줄어듦에 따라 압축기는 수반되는 암호화 없이 본질적으로 단지 캐싱만을 수행하는데-데이터 블럭은 직접 매핑 캐시로 매핑되며 어떤 라인 번호도 암호화 되지 않는다. 마찬가지로 집합 수가 1로 줄어들기 때문에 현재 압축방법은 완전 암호기가 되며-캐싱 과정은 캐 시 히트를 생성하는 것보다 최적 코드를 생성하는 것이 더 중요하기 때문에 중요성을 상실한다. 집합과 라인의 수가 모두 증가할 때 전환점이 일어나는데, 캐싱과 코딩 양자는 압축 과정에 매우 중대하고 ,높은 압축비를 생 성하기 위한 상대적 타당성을 공유한다. 압축방법 10, 100, 200, 300과 400, 그리고 복원방법 500은 유한 상태 자동화로 실현될 수 있고 소프트웨어나 <143> 하드웨어 인공물로서 이행될 수 있는데, 주어진 메모리 어드레스로부터의 다수 로케이션이 대응(in parallel) 비교, 즉 동시에 또는 공동으로 비교되는 연관 또는 지능 메모리 스킴을 이용하여 그 방법의 고유 일치성 (parallelism)을 활용하는 크기/속도 최적화를 포함한다. 다른 말로 하면 유한 상태 자동화로써 현재 압축방법 과 복원방법 중 어느 것이든 그 이행은 유한 수의 상태로 이루어진 가상 머신으로써 실현될 수 있는데, 각 상태 는 압축과정과 복원과정 각각의 한 단계를 표현한다. 이는 본 명세서에서 제안된 모든 압축방법과 복원방법에 적용 가능하다. 이는 또한 메모리 어드레스의 다수 로케이션에 동시 저장된 모든 값들이 특수 하드웨어 회로를 이용하여 현재 부호값과 동시에 비교되는 특정 사례를 포함하는데, 그러므로 내용-어드레스 가능한 데이터어를 갖는 연관 또는 지능 메모리의 행위를 이행하는데, 각 데이터어는 이전에 입력 스트림으로부터 저장된 부호값을 표현한다. 그렇게 동시(parallelized) 최적화된 버전은 라인이 1 보다 큰 특정 메트릭스 <N,K,Lines>를 갖는 세 트-연관 워크스페이스 구성을 가질 때만 가능하다. - 19 -공개특허 10-2009-0021149이 과정은 메모리 참조 내의 모든 로케이션으로부터의 각 비트와 동시에 현재 부호값으로부터의 각 비트를 비교 <144> 하여 N이 현재 부호값의 비트 크기인 대부분의 N 비교에서 매칭 로케이션을 산출하는 특수 하드웨어 회로에 의 해 수행될 수 있다. 연관 메모리가 사용되지 않으면 그러면 각 로케이션의 값은 현재 부호값과 개별적으로 비교 될 필요가 있는데, 그 결과 \"Lines\" x \"N\" 비교인데 라인은 각 메모리 어드레스에 대한 전체 로케이션 수이다. 본 발명이 바람직한 실시예와 관련하여 상당히 자세하게 기재되었지만 당해기술에 숙련된 당업자에게는 본 발명 <145> 이 청구범위의 정신과 범위를 벗어나지 않고 수많은 변경 및 변형이 가능하다는 것이 명백할 것이다."}
