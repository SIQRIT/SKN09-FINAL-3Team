{"patent_id": "10-2017-0167588", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2019-0067542", "출원번호": "10-2017-0167588", "발명의 명칭": "암호화 관련 취약점 공격에 강인한 전자 장치 및 그 방법", "출원인": "삼성전자주식회사", "발명자": "서재우"}}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "전자 장치에 의하여 수행되는 보안 강화 방법에 있어서,실행 코드가 메모리에 로드 되는 것을 후킹(hooking) 하는 단계; 상기 실행 코드를 암호화 코드 식별 모델에 입력하는 단계;상기 암호화 코드 식별 모델이 상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계; 및상기 실행 코드의 메모리 로드를 불허하는 것으로 판정한 경우, 상기 실행 코드가 상기 메모리에 로드되는 것을차단하는 단계를 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서, 상기 실행 코드를 암호화 코드 식별 모델에 입력하는 단계는, 상기 실행 코드로부터 추출된 특징 데이터를 포함하는 입력값을 상기 암호화 코드 식별 모델에 입력하는 단계를포함하는, 보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2 항에 있어서,상기 특징 데이터는,상기 실행 코드의 실행 과정에서 반복적으로 호출된 수학/논리 연산 함수의 호출 시퀀스를 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2 항에 있어서,상기 특징 데이터는,상기 실행 코드가 실행되는 동안의 CPU 전력 소비와 관련된 데이터를 포함하되,상기 CPU 전력 소비와 관련된 데이터는, 기 지정된 수치 이상의 CPU 전력 소비량을 기록한 CPU 동작 사이클의개수에 대한 데이터를 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1 항에 있어서,상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계는,상기 암호화 코드 식별 모델의 출력 데이터가 상기 실행 코드에서 암호화 코드가 탐지 되었음을 가리키는 경우,상기 실행 코드의 메모리 로드를 불허하는 것으로 판정하고, 상기 암호화 코드 식별 모델의 출력 데이터가 상기실행 코드에서 암호화 코드가 탐지 되지 않았음을 가리키는 경우에 한하여, 상기 실행 코드의 메모리 로드를 허용하는 것으로 판정하는 단계를 포함하는,공개특허 10-2019-0067542-3-보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1 항에 있어서,상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계는,상기 암호화 코드 식별 모델의 출력 데이터가 상기 실행 코드에서 암호화 코드가 탐지 되었음을 가리키는 경우,상기 어플리케이션의 설치 기록이 발견되지 않으면 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정하는단계를 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1 항에 있어서,상기 실행 코드의 어플리케이션의 설치 시에 상기 어플리케이션의 설치 패키지에 포함된 어플리케이션 요구 권한 정보에서 사용 가능 암호화 알고리즘에 대한 정보를 얻고, 어플리케이션의 식별 정보 및 사용 가능 암호화알고리즘을 매칭하여 접근 리스트에 저장하는 단계를 더 포함하고,상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계는,상기 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘이, 상기 접근 리스트에 따른 상기 어플리케이션의 사용 가능 암호화 알고리즘이 아닌 경우, 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정하는 단계를 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1 항에 있어서,외부 장치에서 각 암호화 알고리즘의 취약점에 대한 정보를 수신하여 취약점 리스트에 저장하는 단계를 더 포함하고,상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계는,상기 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘의 취약점을 상기 취약점 리스트에서 조회하고, 조회된 취약점에 대한 정보를 기준으로 상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계를포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1 항에 있어서,상기 실행 코드가 메모리에 로드 되는 것을 후킹 하는 단계는,상기 실행 코드의 화이트 리스트 포함 여부, 상기 실행 코드의 실행 빈도 및 상기 실행 코드의 어플리케이션의설치 또는 업데이트 후 경과 시간 중 적어도 하나를 기준으로 상기 실행 코드에 대한 후킹 여부를 판정하는 단계를 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1 항에 있어서,상기 실행 코드가 메모리에 로드 되는 것을 후킹 하는 단계는,상기 실행 코드의 어플리케이션에 대한 인스톨 이력이 존재하지 않는 경우에 한하여 상기 실행 코드가 메모리에공개특허 10-2019-0067542-4-로드 되는 것을 후킹 하는 단계를 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "전자 장치에 의하여 수행되는 보안 강화 방법에 있어서,어플리케이션의 인스톨 시, 상기 어플리케이션의 실행 코드를 암호화 코드 식별 모델에 입력하고 상기 암호화코드 식별 모델의 출력 데이터를 이용하여 상기 실행 코드의 보안 테스트 통과 여부를 판정하는 단계; 및상기 보안 테스트 통과 여부의 판정 결과 실패로 판정한 경우, 상기 어플리케이션에 대하여 기 지정된 프로세스를 수행하는 단계를 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "전자 장치에 의하여 수행되는 보안 강화 방법에 있어서,제1 타입의 어플리케이션에 대하여, 상기 제1 타입의 어플리케이션을 실행하기 위한 사용자 조작 없이, 제1 빈도로 보안 테스트 프로세스를 수행하는 단계; 및제2 타입의 어플리케이션에 대하여, 상기 제2 타입의 어플리케이션을 실행하기 위한 사용자 조작 없이, 제2 빈도로 보안 테스트 프로세스를 수행하는 단계를 포함하되,상기 보안 테스트 프로세스는,어플리케이션의 실행 코드를 암호화 코드 식별 모델에 입력하고;상기 암호화 코드 식별 모델에서 출력 된 데이터를 이용하여 상기 실행 코드의 보안 테스트 통과 여부를 판정하는 것을 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "전자 장치에 의하여 수행되는 보안 강화 방법에 있어서,어플리케이션의 설치 패키지에 포함된 어플리케이션 요구 권한 정보에서 사용 가능 암호화 알고리즘에 대한 정보와 접근 가능 객체 정보를 얻고, 어플리케이션의 식별 정보, 사용 가능 암호화 알고리즘 및 접근 가능 객체를매칭하여 접근 리스트에 저장하는 단계;상기 전자 장치에 설치된 운영 체제에 의하여 제공되는 암호화 API(Application Programming Interface)가 호출되는 것을 감지하는 단계; 상기 암호화 API의 호출에 따른 암호화 알고리즘 및 암호화 대상 객체가, 상기 암호화 API를 호출한 어플리케이션의 접근 권한 내에 있는지 여부를, 상기 접근 리스트를 참조하여 판정하는 단계; 및 상기 암호화 알고리즘 및 상기 암호화 대상 객체가 상기 어플리케이션의 접근 권한 내에 없는 것으로 판정된 경우, 상기 호출된 암호화 API의 암호화 관련 루틴 수행을 차단하는 단계를 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13 항에 있어서,외부 장치에서 각 암호화 알고리즘의 취약점에 대한 정보를 수신하여 취약점 리스트를 구성하는 단계; 및상기 암호화 API의 호출에 따라 수행 될 암호화 알고리즘의 취약점을 상기 취약점 리스트에서 조회하고, 조회된취약점에 대한 정보를 기준으로 상기 호출된 암호화 API의 암호화 관련 루틴의 수행 여부를 판정하는 단계를 더포함하는,공개특허 10-2019-0067542-5-보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제13 항에 있어서,외부 장치에서 각 암호화 알고리즘의 취약점에 대한 정보를 수신하여 취약점 리스트를 구성하는 단계; 및상기 암호화 API의 호출에 따라 수행 될 암호화 알고리즘의 취약점에 대한 정보가 상기 취약점 리스트에 존재하는 경우, 취약 암호화 알고리즘 실행을 상기 외부 장치에 통지하는 단계를 더 포함하는,보안 강화 방법."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "프로세서; 어플리케이션의 실행 코드를 저장하는 스토리지; 및상기 프로세서에 의하여 실행되는 복수의 인스트럭션을 저장하는 메모리를 포함하되,상기 복수의 인스트럭션은,상기 실행 코드가 상기 스토리지에서 상기 메모리로 로드 되는 것을 후킹 하는 인스트럭션; 상기 실행 코드를 암호화 코드 식별 모델에 입력하는 인스트럭션;상기 암호화 코드 식별 모델이 상기 실행 코드의 메모리 로드 허용 여부를 판정하는 것을 제어하는 인스트럭션;및상기 실행 코드의 메모리 로드를 불허하는 것으로 판정한 경우, 상기 실행 코드가 상기 메모리에 로드 되는 것을 차단하는 인스트럭션을 포함하는,전자 장치."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16 항에 있어서,상기 실행 코드를 암호화 코드 식별 모델에 입력하는 인스트럭션은, 상기 실행 코드를 보안 환경에서 실행하고, 상기 실행의 결과를 이용하여 상기 암호화 코드 식별 모델에 대한입력 값을 구성하는 인스트럭션을 포함하되,상기 보안 환경은 샌드박스(sandbox) 환경이고, 상기 실행 코드의 실행 결과는 상기 샌드박스 환경 외부의 시스템 리소스에 영향을 미치지 않는 것을 특징으로 하는,전자 장치."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제16 항에 있어서,상기 스토리지는,상기 어플리케이션의 설치 패키지에 포함된 어플리케이션 요구 권한 정보에서 얻어진 사용 가능 암호화 알고리즘에 대한 정보와 상기 어플리케이션의 식별 정보의 매칭을 포함하는 접근 리스트를 더 저장하고,상기 실행 코드의 메모리 로드 허용 여부를 판정하는 인스트럭션은, 상기 접근 리스트를 참조할 때, 상기 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘이, 상기 사용 가능 암호화 알고리즘이 아닌 경우, 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정하는 인스트럭션을 포함하는,전자 장치.공개특허 10-2019-0067542-6-청구항 19 제16 항에 있어서,네트워크 인터페이스를 더 포함하고,상기 스토리지는, 상기 네트워크 인터페이스를 통하여 외부 장치로부터 수신된 각 암호화 알고리즘의 취약점에 대한 정보를 포함하는 취약점 리스트를 더 저장하고,상기 실행 코드의 메모리 로드 허용 여부를 판정하는 인스트럭션은,상기 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘의 취약점을 상기 취약점 리스트에서 조회하고, 조회된 취약점에 대한 정보를 기준으로 상기 실행 코드의 메모리 로드 허용 여부를 판정하는 인스트럭션을 포함하는,전자 장치."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제16 항에 있어서,상기 복수의 인스트럭션은,상기 어플리케이션의 인스톨러 인스트럭션을 더 포함하고,상기 어플리케이션의 인스톨러 인스트럭션은,상기 실행 코드의 구성이 완료되면, 상기 어플리케이션의 실행 코드를 상기 보안 환경에서 실행하는인스트럭션;상기 실행의 결과를 이용하여 상기 실행 코드의 특징 데이터를 추출하는 인스트럭션;상기 특징 데이터를 암호화 코드 식별 모델에 입력하고, 상기 암호화 코드 식별 모델의 출력 데이터를 이용하여상기 실행 코드의 보안 테스트 통과 여부를 판정하는 인스트럭션; 및상기 보안 테스트 통과 여부의 판정 결과 실패로 판정한 경우, 상기 어플리케이션의 언인스톨 프로세스를 수행하는 인스트럭션을 포함하는,전자 장치."}
{"patent_id": "10-2017-0167588", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제16 항에 있어서,상기 복수의 인스트럭션은,어플리케이션을 실행하기 위한 사용자 조작 없이, 상기 어플리케이션에 대하여 보안 테스트 프로세스를 수행하는 인스트럭션을 더 포함하되, 상기 보안 테스트 프로세스를 수행하는 인스트럭션은,상기 어플리케이션의 실행 코드를 암호화 코드 식별 모델에 입력하고, 상기 암호화 코드 식별 모델의 출력 데이터를 이용하여 상기 실행 코드의 보안 테스트 통과 여부를 판정하는 인스트럭션; 상기 보안 테스트 통과 여부의 판정 결과 실패로 판정한 경우, 사전 정의된 프로세스를 수행하고, 상기 보안 테스트 통과 여부의 판정 결과 성공으로 판정한 경우, 상기 어플리케이션에 대한 보안 테스트 통과 이력을 기록하는 인스트럭션을 포함하며,상기 실행 코드가 상기 스토리지에서 상기 메모리로 로드 되는 것을 후킹 하는 인스트럭션은,기 지정된 유효 기간 이내의 보안 테스트 통과 이력이 존재하지 않는 어플리케이션의 실행 코드에 한하여 메모리에 로드 되는 것을 후킹 하는 인스트럭션을 포함하는,공개특허 10-2019-0067542-7-전자 장치."}
{"patent_id": "10-2017-0167588", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "인공지능 기술에 기반한 암호화 알고리즘 탐지가 가능해짐으로써 암호화 관련 취약점 공격에 강인한 전자 장치 및 그 방법이 제공된다. 본 발명의 일 실시예에 따른 보안 강화 방법은, 실행 코드가 메모리에 로드 되는 것을 후킹(hooking) 하는 단계와, 상기 실행 코드를 인공 신경망(neural network) 기반의 암호화 코드 식별 모델에 입 력하는 단계와, 상기 암호화 코드 식별 모델이 상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계와, 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정한 경우 상기 실행 코드가 상기 메모리에 로드 되는 것을 차단하는 단계를 포함한다."}
{"patent_id": "10-2017-0167588", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 딥러닝 등의 기계학습 알고리즘을 활용하여 인간 두뇌의 인지, 판단 등의 기능을 모사하는 인공지능 (AI) 시스템 및 그 응용에 관련된 것으로서, 인공지능 기술에 기반한 암호화 알고리즘 탐지가 가능해짐으로써 암호화 관련 취약점 공격에 강인한 전자 장치 및 그 방법에 관한 것이다. 보다 자세하게는, 사용자의 의사와 무 관하게 무단으로 데이터를 암호화하는 등의 암호화를 악용한 공격(exploit), 또는 암호화와 관련하여 획득된 권 한을 넘어선 데이터 암호화 등의 행위에 대응할 수 있는 전자 장치 및 그 전자 장치에 의하여 수행될 수 있는 방법에 관한 것이다."}
{"patent_id": "10-2017-0167588", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능(Artificial Intelligence, AI) 시스템은 인간 수준의 지능을 구현하는 컴퓨터 시스템이며, 기존 Rule 기반 스마트 시스템과 달리 기계가 스스로 학습하고 판단하며 똑똑 해지는 시스템이다. 인공지능 시스템은 사용 할수록 인식률이 향상되고 사용자 취향을 보다 정확하게 이해할 수 있게 되어, 기존 Rule 기반 스마트 시스템은 점차 딥러닝 기반 인공지능 시스템으로 대체되고 있다. 인공지능 기술은 딥러닝 등의 기계학습 및 기계학습을 활용한 요소 기술들로 구성된다. 기계학습은 입력 데이터들의 특징을 스스로 분류/학습하는 알고리즘 기술이며, 요소기술은 딥러닝 등의 기계학 습 알고리즘을 활용하여 인간 두뇌의 인지, 판단 등의 기능을 모사하는 기술로서, 언어적 이해, 시각적 이해, 추론/예측, 지식 표현, 동작 제어 등의 기술 분야로 구성된다. 인공지능 기술이 응용되는 다양한 분야는 다음과 같다. 언어적 이해는 인간의 언어/문자를 인식하고 응용/처리 하는 기술로서, 자연어 처리, 기계 번역, 대화시스템, 질의 응답, 음성 인식/합성 등을 포함한다. 시각적 이해 는 사물을 인간의 시각처럼 인식하여 처리하는 기술로서, 객체 인식, 객체 추적, 영상 검색, 사람 인식, 장면 이해, 공간 이해, 영상 개선 등을 포함한다. 추론 예측은 정보를 판단하여 논리적으로 추론하고 예측하는 기술 로서, 지식/확률 기반 추론, 최적화 예측, 선호 기반 계획, 추천 등을 포함한다. 지식 표현은 인간의 경험정보 를 지식데이터로 자동화 처리하는 기술로서, 지식 구축(데이터 생성/분류), 지식 관리(데이터 활용) 등을 포함 한다. 동작 제어는 차량의 자율 주행, 로봇의 움직임을 제어하는 기술로서, 움직임 제어(항법, 충돌, 주행), 조 작 제어(행동 제어) 등을 포함한다. 랜섬웨어(ransomware) 또는 멀웨어(malware) 등의 악성 프로그램이 무단으로 데이터를 암호화한 경우, 암호화 된 데이터를 다시 원상으로 복원하는 것에 상당한 어려움이 따른다. 따라서, 상기 악성 프로그램이 데이터를 암 호화 하기 이전에 암호화를 사전 차단하는 것이 바람직하다. 기존의 기술에 따르면, 시그니처(signature) 또는 실행 코드의 해시 값 등의 프로그램 식별자를 기반으로 악성 프로그램을 식별하거나, 악성 프로그램의 행위에 대한 분석을 통하여 악성 프로그램을 식별하고, 식별된 악성 프로그램을 삭제하거나 실행 차단한다. 그런데, 기존의 기술에 따르면, 지속적으로 새로운 악성 프로그램이 등 장하고 있기 때문에, 새로운 악성 프로그램을 신속하고 정확하게 식별하기 위하여 상당한 시간 및 비용의 투입 이 요구된다. 또한, 어떠한 프로그램이 악성 프로그램이 아닌 것으로 판단되었다 하더라도, 그 프로그램이 승인 된 권한을 넘어서서 암호화를 수행하는 행위는 차단하지 못한다. 이처럼 부적절한 데이터 암호화의 다양한 패턴에 대응하기 위하여, 인간 두뇌의 판단을 모사하는 인공지능 기술 의 도움이 요구된다. 즉, 인공지능 기술에 기반한 암호화 알고리즘 탐지에 따라 암호화 관련 취약점 공격을 탐 지하는 능력을 강화 시킬 수 있는 보안 강화 기술의 제공이 요구된다."}
{"patent_id": "10-2017-0167588", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명이 해결하고자 하는 기술적 과제는, 암호화 기반의 해킹 공격 등에 강인한 보안 강화 전자 장치 및 보안 강화 방법을 제공하는 것이다. 본 발명이 해결하고자 하는 다른 기술적 과제는, 어플리케이션의 실행 코드에 포함된 암호화 알고리즘 실행 코 드를 식별하고, 암호화 알고리즘 실행 코드의 발견 여부 및 발견된 암호화 알고리즘의 종류 중 적어도 하나에 기반하여 상기 어플리케이션 실행되는 것을 차단하는 전자 장치 및 그 방법을 제공하는 것이다. 본 발명이 해결하고자 하는 또 다른 기술적 과제는, 어플리케이션의 실행 코드에 포함된 암호화 알고리즘의 식 별 결과에 기반하여 상기 어플리케이션이 메모리에 로드 되는 것을 선택적으로 차단하는 전자 장치 및 그 방법 을 제공하는 것이다. 본 발명이 해결하고자 하는 또 다른 기술적 과제는, 외부와 차단된 보안 환경에서 어플리케이션을 실행해보고, 그 실행 결과를 이용하여 상기 어플리케이션에 포함된 암호화 알고리즘을 식별하는 전자 장치 및 그 방법을 제 공하는 것이다. 본 발명이 해결하고자 하는 또 다른 기술적 과제는, 어플리케이션의 실행 코드에 대한 정적 분석 및 동적 분석 결과를 이용하여 추출된 특징 데이터를 이용하여 기계학습 된 암호화 코드 식별 모델을 활용하여 어플리케이션 의 실행 코드에 포함된 암호화 알고리즘을 식별하는, 인공지능 기술이 응용된 전자 장치 및 그 방법을 제공하는 것이다. 본 발명이 해결하고자 하는 또 다른 기술적 과제는, 어플리케이션의 실행 코드에 포함된 암호화 알고리즘의 식 별 결과에 기반하여 상기 어플리케이션의 인스톨 허용 여부를 결정하는 전자 장치 및 그 방법을 제공하는 것이다. 본 발명이 해결하고자 하는 또 다른 기술적 과제는, 어플리케이션의 실행 코드에 포함된 암호화 알고리즘의 식 별 결과에 기반하여 상기 어플리케이션의 암호화 기능 안정성을 사전 테스트 하는 전자 장치 및 그 방법을 제공 하는 것이다. 본 발명이 해결하고자 하는 또 다른 기술적 과제는, 어플리케이션에 승인된 접근 권한을 넘어선 암호화 시도를 감지하고, 이를 차단하는 전자 장치 및 그 방법을 제공하는 것이다. 본 발명이 해결하고자 하는 또 다른 기술적 과제는, 어플리케이션의 메모리 로드를 후킹(hooking) 하여 테스트 를 진행하는 보안 환경이 별도의 전용 프로세서를 통하여 구현된 전자 장치를 제공하는 것이다. 본 발명이 해결하고자 하는 또 다른 기술적 과제는, 암호화 알고리즘의 코드에 대한 특징 데이터를 이용하여 기 계학습 된 암호화 코드 식별 모델과, 암호화 알고리즘의 취약점에 대한 정보를 사용자 단말에 업데이트 해줌으 로써, 상기 사용자 단말의 보안 강화를 유도하는 시스템을 제공하는 것이다. 본 발명의 기술적 과제들은 이상에서 언급한 기술적 과제들로 제한되지 않으며, 언급되지 않은 또 다른 기술적"}
{"patent_id": "10-2017-0167588", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 2, "content": "과제들은 아래의 기재로부터 본 발명의 기술분야에서의 통상의 기술자에게 명확하게 이해 될 수 있을 것이다."}
{"patent_id": "10-2017-0167588", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 일 실시예에 따른 보안 강화 방법은, 실행 코드가 메모리에 로드 되는 것을 후킹 하는 단계와, 상기 실행 코드를 암호화 코드 식별 모델에 입력하는 단계와, 상기 암호화 코드 식별 모델이 상기 실행 코드의 메모 리 로드의 허용 여부를 판정하는 단계와, 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정한 경우, 상기 실행 코드가 상기 메모리에 로드 되는 것을 차단하는 단계를 포함한다. 일 실시예에서, 상기 실행 코드를 암호화 코드 식별 모델에 입력하는 단계는, 상기 실행 코드로부터 추출된 특 징 데이터를 포함하는 입력값을 상기 암호화 코드 식별 모델에 입력하는 단계를 포함할 수 있다. 이 때, 상기 특징 데이터는 상기 실행 코드의 실행 과정에서 반복적으로 호출된 수학/논리 연산 함수의 호출 시퀀스이거나, 상기 실행 코드가 실행되는 동안의 CPU 전력 소비와 관련된 데이터일 수 있다. 상기 CPU 전력 소비와 관련된 데 이터는, 기 지정된 수치 이상의 CPU 전력 소비량을 기록한 CPU 동작 사이클의 개수에 대한 데이터를 포함할 수 있다. 상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계는, 상기 암호화 코드 식별 모델의 출력 데이터가 상기 실행 코드에서 암호화 코드가 탐지 되었음을 가리키는 경우, 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정하고, 상기 암호화 코드 식별 모델의 출력 데이터가 상기 실행 코드에서 암호화 코드가 탐지 되지 않 았음을 가리키는 경우에 한하여, 상기 실행 코드의 메모리 로드를 허용하는 것으로 판정하는 단계와, 상기 암호 화 코드 식별 모델의 출력 데이터가 상기 실행 코드에서 암호화 코드가 탐지 되었음을 가리키는 경우, 상기 어 플리케이션의 설치 기록이 발견되지 않으면 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정하는 단계 중 적어도 하나를 포함할 수 있다.상기 보안 강화 방법은, 상기 실행 코드의 어플리케이션의 설치 시에 상기 어플리케이션의 설치 패키지에 포함 된 어플리케이션 요구 권한 정보에서 사용 가능 암호화 알고리즘에 대한 정보를 얻고, 어플리케이션의 식별 정 보 및 사용 가능 암호화 알고리즘을 매칭하여 접근 리스트에 저장하는 단계를 더 포함하고, 상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계는, 상기 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알 고리즘이, 상기 접근 리스트에 따른 상기 어플리케이션의 사용 가능 암호화 알고리즘이 아닌 경우, 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정하는 단계를 포함할 수 있다. 상기 보안 강화 방법은, 외부 장치에서 각 암호화 알고리즘의 취약점에 대한 정보를 수신하여 취약점 리스트에 저장하는 단계를 더 포함하고, 상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계는, 상기 암호화 코 드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘의 취약점을 상기 취약점 리스트에서 조회하고, 조회된 취약점에 대한 정보를 기준으로 상기 실행 코드의 메모리 로드의 허용 여부를 판정하는 단계를 포함할 수 있다. 상기 실행 코드가 메모리에 로드 되는 것을 후킹 하는 단계는, 상기 실행 코드의 화이트 리스트 포함 여부, 상 기 실행 코드의 실행 빈도 및 상기 실행 코드의 어플리케이션의 설치 또는 업데이트 후 경과 시간 중 적어도 하 나를 기준으로 상기 실행 코드에 대한 후킹 여부를 판정하는 단계와, 상기 실행 코드의 어플리케이션에 대한 인 스톨 이력이 존재하지 않는 경우에 한하여 상기 실행 코드가 메모리에 로드 되는 것을 후킹 하는 단계 중 적어 도 하나를 포함할 수 있다. 본 발명의 다른 실시예에 따른 보안 강화 방법은, 어플리케이션의 인스톨 시, 상기 어플리케이션의 실행 코드를 암호화 코드 식별 모델에 입력하고 상기 암호화 코드 식별 모델의 출력 데이터를 이용하여 상기 실행 코드의 보 안 테스트 통과 여부를 판정하는 단계와, 상기 보안 테스트 통과 여부의 판정 결과 실패로 판정한 경우, 상기 어플리케이션에 대하여 기 지정된 프로세스를 수행하는 단계를 포함한다. 상기 보안 테스트 통과 여부를 판정하 는 단계는, 상기 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘과, 상기 어플리케이션의 설 치 패키지에 포함된 어플리케이션 요구 권한 정보에서 얻은 사용 가능 암호화 알고리즘에 대한 정보가 매치되지 않는 경우, 상기 실행 코드의 보안 테스트 통과 여부의 판정 결과를 실패로 판정하는 단계를 포함할 수 있다. 본 발명의 또 다른 실시예에 따른 보안 강화 방법은, 제1 타입의 어플리케이션에 대하여, 상기 제1 타입의 어플 리케이션을 실행하기 위한 사용자 조작 없이, 제1 빈도로 보안 테스트 프로세스를 수행하는 단계와, 제2 타입의 어플리케이션에 대하여, 상기 제2 타입의 어플리케이션을 실행하기 위한 사용자 조작 없이, 제2 빈도로 보안 테 스트 프로세스를 수행하는 단계를 포함한다. 이 때, 상기 보안 테스트 프로세스는, 어플리케이션의 실행 코드를 암호화 코드 식별 모델에 입력하고, 상기 암호화 코드 식별 모델에서 출력 된 데이터를 이용하여 상기 실행 코 드의 보안 테스트 통과 여부를 판정하는 것을 포함할 수 있다. 본 발명의 또 다른 실시예에 따른 보안 강화 방법은, 상기 어플리케이션의 설치 패키지에 포함된 어플리케이션 요구 권한 정보에서 사용 가능 암호화 알고리즘에 대한 정보와 접근 가능 객체 정보를 얻고, 어플리케이션의 식 별 정보, 사용 가능 암호화 알고리즘 및 접근 가능 객체를 매칭하여 접근 리스트에 저장하는 단계와, 상기 전자 장치에 설치된 운영 체제에 의하여 제공되는 암호화 API(Application Programming Interface)가 호출되는 것을 감지하는 단계와, 상기 암호화 API의 호출에 따라 수행 될 암호화 알고리즘 및 암호화 대상 객체가, 상기 암호 화 API를 호출한 어플리케이션의 접근 권한 내에 있는지 여부를, 상기 접근 리스트를 참조하여 판정하는 단계와, 상기 암호화 알고리즘 및 상기 암호화 대상 객체가 상기 어플리케이션의 접근 권한 내에 없는 것으로 판정된 경우, 상기 호출된 암호화 API의 암호화 관련 루틴 수행을 차단하는 단계를 포함한다. 일 실시예에서, 상기 보안 강화 방법은, 외부 장치에서 각 암호화 알고리즘의 취약점에 대한 정보를 수신하여 취약점 리스트를 구성하는 단계와, 상기 암호화 API의 호출에 따라 수행 될 암호화 알고리즘의 취약점을 상기 취약점 리스트에서 조회하고, 조회된 취약점에 대한 정보를 기준으로 상기 호출된 암호화 API의 암호화 관련 루 틴의 수행 여부를 판정하는 단계를 더 포함할 수 있다. 다른 실시예에서, 상기 보안 강화 방법은, 외부 장치에 서 각 암호화 알고리즘의 취약점에 대한 정보를 수신하여 취약점 리스트를 구성하는 단계와, 상기 암호화 API의 호출에 따라 수행 될 암호화 알고리즘의 취약점에 대한 정보가 상기 취약점 리스트에 존재하는 경우, 취약 암호 화 알고리즘 실행을 상기 외부 장치에 통지하는 단계를 더 포함할 수 있다. 이 때, 상기 외부 장치는, 암호화 알고리즘의 취약점 정보를 취합하여 상기 전자 장치에 송신하고, 상기 취약 암호화 알고리즘 실행의 통지를 상 기 전자 장치로부터 취합하여 통계 데이터를 생성하며, 상기 취약 암호화 알고리즘을 사용하는 어플리케이션의 개발사 측 시스템에 상기 통계 데이터를 송신하는 장치이다. 본 발명의 또 다른 실시예에 따른 전자 장치는, 프로세서와, 어플리케이션의 실행 코드를 저장하는 스토리지와, 상기 프로세서에 의하여 실행되는 복수의 인스트럭션을 저장하는 메모리를 포함한다. 이 때, 상기 복수의 인스트럭션은, 상기 실행 코드가 상기 스토리지에서 상기 메모리로 로드 되는 것을 후킹(hooking) 하는 인스트럭션 과, 상기 실행 코드를 암호화 코드 식별 모델에 입력하는 인스트럭션, 상기 암호화 코드 식별 모델이 상기 실행 코드의 메모리 로드 허용 여부를 판정하는 것을 제어하는 인스트럭션과, 상기 실행 코드의 메모리 로드를 불허 하는 것으로 판정한 경우, 상기 실행 코드가 상기 메모리에 로드 되는 것을 차단하는 인스트럭션을 포함한다. 일 실시예에서, 상기 실행 코드를 암호화 코드 식별 모델에 입력하는 인스트럭션은, 상기 실행 코드를 보안 환 경에서 실행하고, 상기 실행의 결과를 이용하여 상기 암호화 코드 식별 모델에 대한 입력 값을 구성하는 인스트 럭션을 포함할 수 있다. 이 때, 상기 보안 환경은 샌드박스(sandbox) 환경이고, 상기 실행 코드의 실행 결과는 상기 샌드박스 환경 외부의 시스템 리소스에 영향을 미치지 않는 것일 수 있다. 일 실시예에서, 상기 스토리지는, 상기 어플리케이션의 설치 패키지에 포함된 어플리케이션 요구 권한 정보에서 얻어진 사용 가능 암호화 알고리즘에 대한 정보와 상기 어플리케이션의 식별 정보의 매칭을 포함하는 접근 리스 트를 더 저장한다. 이 때, 상기 실행 코드의 메모리 로드 허용 여부를 판정하는 인스트럭션은, 상기 접근 리스 트를 참조할 때, 상기 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘이, 상기 사용 가능 암 호화 알고리즘이 아닌 경우, 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정하는 인스트럭션을 포함할 수 있다. 이 때, 상기 접근 리스트는, 상기 어플리케이션 요구 권한 정보에서 얻어진 접근 가능 객체가 상기 어 플리케이션의 식별 정보와 더 매치된 것이고, 상기 복수의 인스트럭션은, 상기 전자 장치에 설치된 운영 체제에 의하여 제공되는 암호화 API가 호출되는 것을 감지하는 인스트럭션과, 상기 암호화 API의 호출에 따른 암호화 알고리즘 및 암호화 대상 객체가, 상기 암호화 API를 호출한 어플리케이션의 접근 권한 내에 있는지를 상기 접 근 리스트를 참조하여 판정하는 인스트럭션과, 상기 암호화 알고리즘 및 상기 암호화 대상 객체가 상기 어플리 케이션의 접근 권한 내에 없는 것으로 판정된 경우, 상기 호출된 암호화 API의 암호화 관련 루틴 수행을 차단하 는 인스트럭션을 더 포함할 수 있다. 일 실시예에서, 상기 전자 장치는 네트워크 인터페이스를 더 포함하고, 상기 스토리지는 상기 네트워크 인터페 이스를 통하여 외부 장치로부터 수신된 각 암호화 알고리즘의 취약점에 대한 정보를 포함하는 취약점 리스트를 더 저장하고, 상기 실행 코드의 메모리 로드 허용 여부를 판정하는 인스트럭션은, 상기 암호화 코드 식별 모델 의 출력 데이터가 가리키는 암호화 알고리즘의 취약점을 상기 취약점 리스트에서 조회하고, 조회된 취약점에 대 한 정보를 기준으로 상기 실행 코드의 메모리 로드 허용 여부를 판정하는 인스트럭션을 포함한다. 일 실시예에서, 상기 복수의 인스트럭션은, 상기 어플리케이션의 인스톨러 인스트럭션을 더 포함하고, 상기 어 플리케이션의 인스톨러 인스트럭션은, 상기 실행 코드의 구성이 완료되면, 상기 어플리케이션의 실행 코드를 상 기 보안 환경에서 실행하는 인스트럭션과, 상기 실행의 결과를 이용하여 입력 데이터를 구성하는 인스트럭션과, 상기 입력 데이터를 암호화 코드 식별 모델에 입력하고, 상기 암호화 코드 식별 모델의 출력 데이터를 이용하여 상기 실행 코드의 보안 테스트 통과 여부를 판정하는 인스트럭션과, 상기 보안 테스트 통과 여부의 판정 결과 실패로 판정한 경우, 상기 어플리케이션의 언인스톨 프로세스를 수행하는 인스트럭션을 포함한다. 일 실시예에서, 상기 복수의 인스트럭션은, 어플리케이션을 실행하기 위한 사용자 조작 없이, 상기 어플리케이 션에 대하여 보안 테스트 프로세스를 수행하는 인스트럭션을 더 포함한다. 이 때, 상기 보안 테스트 프로세스를 수행하는 인스트럭션은, 상기 어플리케이션의 실행 코드를 암호화 코드 식별 모델에 입력하고, 상기 암호화 코 드 식별 모델의 출력 데이터를 이용하여 상기 실행 코드의 보안 테스트 통과 여부를 판정하는 인스트럭션과, 상 기 보안 테스트 통과 여부의 판정 결과 실패로 판정한 경우, 사전 정의된 프로세스를 수행하고, 상기 보안 테스 트 통과 여부의 판정 결과 성공으로 판정한 경우, 상기 어플리케이션에 대한 보안 테스트 통과 이력을 기록하는 인스트럭션을 포함한다. 또한, 상기 실행 코드가 상기 스토리지에서 상기 메모리로 로드 되는 것을 후킹 하는 인스트럭션은 기 지정된 유효 기간 이내의 보안 테스트 통과 이력이 존재하지 않는 어플리케이션의 실행 코드에 한하여 메모리에 로드 되는 것을 후킹 하는 인스트럭션을 포함한다. 본 발명의 또 다른 실시예에 따른 전자 장치는, 제1 프로세서와, 어플리케이션의 실행 코드를 저장하는 스토리 지와, 상기 스토리지에서 로드 되어 상기 제1 프로세서에서 실행되는 실행 코드가 저장되는 메모리와, 상기 실 행 코드가 상기 메모리에 로드 되는 것의 허용 여부를 판정하는 복수의 인스트럭션을 실행하는 샌드박스 환경의 제2 프로세서를 포함한다. 이 때, 상기 복수의 인스트럭션은, 상기 실행 코드가 상기 스토리지에서 상기 메모리 로 로드 되는 것을 후킹 하는 인스트럭션과, 상기 실행 코드를 암호화 코드 식별 모델에 입력하는 인스트럭션과, 상기 암호화 코드 식별 모델의 출력 데이터를 이용하여 상기 실행 코드의 메모리 로드의 허용 여 부를 판정하는 인스트럭션과, 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정한 경우, 상기 실행 코드가 상기 메모리에 로드 되는 것을 차단하는 인스트럭션을 포함한다."}
{"patent_id": "10-2017-0167588", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 첨부된 도면을 참조하여 본 발명의 바람직한 실시예들을 상세히 설명한다. 본 발명의 이점 및 특징, 그리 고 그것들을 달성하는 방법은 첨부되는 도면과 함께 상세하게 후술되어 있는 실시 예들을 참조하면 명확해질 것 이다. 그러나 본 발명은 이하에서 게시되는 실시 예들에 한정되는 것이 아니라 서로 다른 다양한 형태로 구현될"}
{"patent_id": "10-2017-0167588", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "수 있으며, 단지 본 실시 예들은 본 발명의 게시가 완전하도록 하고, 본 발명이 속하는 기술분야에서 통상의 지 식을 가진 자에게 발명의 범주를 완전하게 알려주기 위해 제공되는 것이며, 본 발명은 청구항의 범주에 의해 정 의될 뿐이다. 명세서 전체에 걸쳐 동일 참조 부호는 동일 구성 요소를 지칭한다. 다른 정의가 없다면, 본 명세서에서 사용되는 모든 용어(기술 및 과학적 용어를 포함)는 본 발명이 속하는 기술 분야에서 통상의 지식을 가진 자에게 공통적으로 이해될 수 있는 의미로 사용될 수 있을 것이다. 또 일반적으로 사용되는 사전에 정의되어 있는 용어들은 명백하게 특별히 정의되어 있지 않는 한 이상적으로 또는 과도하게 해 석되지 않는다. 본 명세서에서 사용된 용어는 실시예들을 설명하기 위한 것이며 본 발명을 제한하고자 하는 것 은 아니다. 본 명세서에서, 단수형은 문구에서 특별히 언급하지 않는 한 복수형도 포함한다. 이하, 도면들을 참 조하여 본 발명의 몇몇 실시예들을 설명한다. 도 1을 참조하여 본 발명의 일 실시예에 따른 암호화 알고리즘 기반 보안 강화 시스템의 구성 및 동작을 설명한 다. 본 실시예에 따른 시스템은 암호화 코드 식별 모델 트레이닝 장치, 암호화 알고리즘 취약점 수집 장치 및 하나 이상의 전자 장치(100a 내지 100e)를 포함할 수 있다. 전자 장치(100a 내지 100e)는, 사용자에 의 하여 사용되는 사용자 단말로서, 예를 들어, 스마트폰, 스마트워치 등의 웨어러블 디바이스, 태블릿, 데스크톱, 노트북 등의 연산 프로세서가 구비된 컴퓨팅 장치 또는 컴퓨팅 수단이 구비된 디지털 장치 등의 전자 장치일 수 있다. 물론, 전자 장치(100a 내지 100e)는 사용자 단말에 서비스를 제공하는 서버 장치일 수도 있다. 암호화 코드 식별 모델 트레이닝 장치는 암호화 알고리즘의 실행 코드들의 집합인 트레이닝 데이터 (training data)를 이용하여 기계학습 트레이닝을 수행한다. 상기 트레이닝 데이터는 하나의 암호화 알고리즘에 대한 복수의 서로 다른 실행 코드들을 포함하는 것이 바람직하다. 상기 트레이닝 데이터는 복수의 암호화 알고 리즘에 대한 실행 코드들을 포함하는 것이 바람직하다. 암호화 코드 식별 모델 트레이닝 장치는 상기 실행 코드를 수집하거나, 암호화 알고리즘들을 포함하는 배포용 라이브러리를 직접 컴파일 하여 상기 실행 코드를 얻 을 수 있다. 상기 배포용 라이브러리는, 예를 들어 OpenSSL, PBC(Pairing-based Cryptography)이다.상기 기계학습 트레이닝은, 암호화 알고리즘의 존재 여부를 판정하는 모델을 생성하기 위한 것이거나, 암호화 알고리즘의 존재 여부 판정 및 암호화 알고리즘 종류의 분류(classifying)를 모두 수행하는 모델을 생성하기 위 한 것일 수 있다. 상기 기계학습 트레이닝은, 예를 들어 n-gram, 인공 신경망(neural network), 나이브 베이즈 (naive bayes), SVM(Support Vector Machine) 등 분류 모델(classification model)을 생성할 수 있는 다양한 종류의 알고리즘을 이용한 것일 수 있다. 일 실시예에서, 상기 암호화 알고리즘 종류는 sha-256, aes-128-cbc, hmac-128 등 IETF, ISO 표준 등에 명시된 복수의 서로 다른 암호화 알고리즘으로 나뉜다. 암호화 코드 식별 모델 트레이닝 장치는 각 종류의 암호화 알고리즘의 실행 코드들로부터 특징 데이터를 추 출하고, 추출된 특징 데이터를 이용하여 기계학습 트레이닝을 수행한다. 이하, 상기 특징 데이터의 추출 방법에 대하여 설명한다. 상기 특징 데이터의 추출은 정적 분석 및 동적 분석을 포함한다. 정적 분석은 암호화 알고리즘의 실행 코드를 실행하지 않고도 특징 데이터를 추출하는 것이다. 반면 에 동적 분석은 암호화 알고리즘의 실행 코드를 실행하고, 그 결과를 이용하여 특징 데이터를 추출하는 것이다. 이하, 본 발명의 몇몇 실시예들에서 수행될 수 있는 특징 데이터 추출용 정적 분석 및 동적 분석을 설명한다. 정적 분석으로서, 암호화 알고리즘의 실행 코드를 파싱(parsing) 하여 암호화 알고리즘을 특징짓는 기 지정된 키워드의 분포와 관련된 특징 데이터가 생성될 수 있다. 상기 키워드는 암호화 알고리즘 관련 스트링(string)과, 암호화 알고리즘 관련 함수명/라이브러리명을 포함한다. 상기 스트링은, 예를 들어 \"hash\", \"digest\", \"encrypt\", \"key\", \"sk\", \"pk\", \"rk\", \"salt\" 및 \"seed\" 중 적어 도 하나를 포함한다. 상기 스트링은 암호화 알고리즘에서 빈번하게 사용되는 것들이므로, 암호화 알고리즘의 식 별/분류에 있어서 기준이 되는 특징 데이터가 된다. 상기 함수명/라이브러리명은, 예를 들어 \"hash\", \"md5\", \"big number\", \"seed\", \"sorting\" 및 \"ordering\" 중 적어도 하나를 포함한다. 암호화 알고리즘의 구현을 위하여는 복잡한 수학 관련 함수들을 임포트(import) 하여 사용할 필요가 있다. 따라서, 상기 예시 된 것과 같은 함수명/라이브러리명 역시 암호화 알고리즘의 식별/분류 에 있어서 기준이 되는 특징 데이터가 된다. 일 형태의 동적 분석으로서, 암호화 알고리즘의 실행 코드가 보안 환경 내에서 실행되고, 상기 실행 과정에서 반복적으로 호출 된 수학/논리 연산 함수의 호출 시퀀스(sequence) 및 실행 코드의 실행 과정에서 CPU(Central Processing Unit) 전력 소비와 관련된 데이터가 상기 특징 데이터로 추출 될 수 있다. 암호화 알고리즘은 복잡 한 수학/논리 연산을 반복적으로 수행한다. 상기 수학/논리 연산은 예를 들어, add, multiplication, shift, XOR, AND, OR, NOR, NAND 등의 시스템 콜(system call)을 이용한다. 따라서, 반복적인 수학/논리 연산 함수의 호출 시퀀스 역시 암호화 알고리즘의 식별/분류에 있어서 기준이 되는 특징 데이터가 된다. 다른 형태의 동적 분석으로서, 암호화 알고리즘의 실행 코드가 보안 환경 내에서 실행되고, 상기 실행 코드의 실행 과정에서 CPU 전력 소비와 관련된 데이터가 상기 특징 데이터로 추출될 수 있다. 이미 설명한 바와 같이, 암호화 알고리즘은 복잡한 수학/논리 연산을 반복적으로 수행하기 때문에, 그 동안 CPU의 전력 소비가 많아질 것이다. 따라서, 암호화 알고리즘의 실행 코드를 실행하는 동안의 CPU 전력 소비와 관련된 데이터 역시 암호화 알고리즘의 식별/분류에 있어서 기준이 되는 특징 데이터가 된다. 상기 CPU 전력 소비와 관련된 데이터는 기 지정된 수치 이상의 CPU 전력 소비량을 기록한 CPU 동작 사이클의 개 수일 수 있다. 일부 암호화 알고리즘은 복잡도가 높은 연산을 반복적으로 수행하는 것이 알려져 있다. 예를 들 어, 공개키 기반의 암호화 알고리즘인 RSA(Rivest-Shamir-Adleman)는 1024-bit 정수 곱셈 및 modular 연산을 1024번 반복한다. 따라서, RSA의 실행 코드를 실행하는 CPU는 1024 동작 사이클에 걸쳐서 높은 수준의 전력 소 비량을 기록할 것이다. 따라서, 암호화 알고리즘의 실행 코드를 실행하는 동안에 기 지정된 수치 이상의 CPU 전 력 소비량을 기록한 CPU 동작 사이클의 개수와 관련된 데이터 역시 암호화 알고리즘의 식별/분류에 있어서 기준 이 되는 특징 데이터가 될 수 있다. 지금까지, 암호화 코드 식별 모델 트레이닝 장치가 특징 데이터를 입력 받아 기계학습 트레이닝을 수행하는 과정을 설명하였다. 암호화 코드 식별 모델 트레이닝 장치는 딥러닝 알고리즘을 활용하여, 학습 과정에서 자체적으로 실행 코드의 특징 데이터를 추출하고, 추출된 특징 데이터를 이용하여 상기 암호화 코드 식별 모델 을 생성할 수도 있다. 암호화 코드 식별 모델 트레이닝 장치는 상기 기계학습 트레이닝의 결과로 생성된 암호화 코드 식별 모델 을 네트워크를 통하여 전자 장치들(100a 내지 100e)에 송신한다. 암호화 코드 식별 모델은 모델을정의하는 파라미터의 세트(ML parameters set)를 포함할 수 있다. 암호화 코드 식별 모델 트레이닝 장치는 주기적 또는 비주기적으로 업데이트 된 트레이닝 데이터를 이용하여 암호화 코드 식별 모델을 업데이트 하 고, 업데이트 된 암호화 코드 식별 모델을 전자 장치들(100a 내지 100e)에 송신할 수 있다. 암호화 알고리즘 취약점 수집 장치는 암호화 알고리즘의 취약점에 대한 정보를 수집하여 가공함으로써, 암 호화 알고리즘 타입 별 취약점 정보를 포함하는 취약점 리스트를 생성한다. 암호화 알고리즘 취약점 수집 장치 는 주기적 또는 비주기적으로 상기 취약점 리스트를 업데이트 하여, 전자 장치들(100a 내지 100e)에 송신할 수 있다. 상기 취약점 정보는 취약성을 가리키는 스코어를 포함할 수 있다. 상기 스코어는 암호화 알고리즘에 오류가 존 재하는 등 취약한 정도가 심각하거나, 취약 암호화 알고리즘의 실행 시 시스템에 심각한 보안상 문제를 야기하 는 경우일 수록 높게 설정될 수 있다. 암호화 알고리즘 취약점 수집 장치는 전자 장치들(100a 내지 100e) 중 상기 취약점 리스트에 포함된 취약 암호화 알고리즘을 실행한 전자 장치로부터 취약 암호화 알고리즘 실행 통지를 수신할 수 있다. 암호화 알 고리즘 취약점 수집 장치는 취약 암호화 알고리즘 실행 통지를 취합하여 통계 데이터를 생성하며, 상기 통계 데이터를 상기 취약 암호화 알고리즘을 사용하는 어플리케이션의 개발사 측 시스템(미도시)에 송신할 수 있다. 상기 통계 데이터는 취약 암호화 알고리즘의 실행 횟수를 포함할 수 있다. 상기 통계 데이터가 개발사 측 시스 템에 송신되는 시점은 상기 취약 암호화 알고리즘의 취약성 스코어와 상기 실행 횟수를 모두 반영하여 결정될 수 있다. 예를 들어, 상기 취약성 스코어가 높은 취약 암호화 알고리즘에 대하여는 실행 횟수가 제1 건이 되면 상기 통계 데이터가 송신되고, 상기 취약성 스코어가 낮은 취약 암호화 알고리즘에 대하여는 실행 횟수가 상기 제1 건보다 많은 제2 건이 되어야 상기 통계 데이터가 송신되도록 통계 데이터 알림 조건이 설정될 수 있다. 전자 장치(100a 내지 100e)는 암호화 코드 식별 모델 및 취약 암호화 알고리즘 취약점 정보를 수신하여 저장하고, 사전 정의된 설정 또는 보안 관련 사용자 설정에 따른 보안 강화 관련 동작을 수행할 수 있다. 상기 보안 강화 관련 동작 도중에 암호화 코드 식별 모델 및 암호화 알고리즘 취약점 정보 중 적어도 하나가 참조될 수 있다. 이하, 도 2a 및 도 2b를 참조하여, 전자 장치(100a 내지 100e)의 상기 보안 강화 관련 동작의 실시예들을 설명 한다. 도 2a 내지 도 2b는 어플리케이션이 인스톨러(installer)에 의하여 정식으로 설치된 것인지 여부를 기준으로 고려 대상 케이스들을 나누고, 어플리케이션이 운영체제(OS; Operating System) 등 전자 장치(100a 내 지 100e)의 동작 기반이 되는 플랫폼(platform)에 의하여 제공되는 암호화 API를 호출하여 암호화 알고리즘을 실행하는지, 또는 어플리케이션의 실행 코드가 암호화 알고리즘의 실행 코드를 포함하여 자체 암호화 알고리즘 이 실행되는지 여부(51, 59)를 기준으로 고려 대상 케이스들을 다시 나눈 것을 도시한다. 본 명세서에서, 어플 리케이션은 사용자 레벨(user level)에서 실행되는 소프트웨어를 의미할 수 있다. 먼저, 어플리케이션이 인스톨러에 의하여 정식으로 설치된 것인 경우의 고려 대상 케이스들이 도시된 도 2a를 참조하여 설명한다. 인스톨러에 의하여 정식으로 설치된 어플리케이션의 실행 코드가 암호화 알고리즘의 실행 코드를 포함함으로써 자체 암호화 알고리즘을 실행하는 경우, 어플리케이션의 실행 코드가 메모리(RAM)에 로드 되는 것이 후킹 (hooking) 되고, 상기 실행 코드에 암호화 알고리즘의 실행 코드가 포함되어 있는 것이 암호화 코드 식별 모델 을 이용하여 감지된다. 상기 후킹은, 컨트롤 하고자 하는 대상 루틴이 실행 되는 것을 잠시 홀딩(holding) 하고, 특정 루틴을 실행하기 위한 다양한 방법론을 포괄하는 개념이다. 예를 들어, 상기 후킹은, 컨트롤 하고자 하는 대상 루틴이 실행 되기 전에 특정 루틴을 실행하는 것을 의미할 수 있다. 본 발명의 몇몇 실시예들에서, 상기 대상 루틴은 바이너리 코드를 메모리에 로드 하는 시스템 함수(또 는 커널 함수)이다. 상기 후킹을 설정하기 위하여, 후킹 대상 루틴에 대하여 후킹 함수를 등록하는 과정이 요구 될 수 있다. 상기 후킹 함수의 등록이 성공하면, 상기 후킹 대상 루틴이 실행되기 전에, 상기 후킹 함수가 실행 되게 된다. 따라서, 상기 후킹 함수 내부 루틴에서 return 하기 전에는 상기 후킹 대상 루틴은 실행되지 않을 것이다. 따라서, 후킹 대상 루틴이 메모리 로드 시스템 함수인 경우, 그 후킹 함수에서 메모리 로드 허용 여부 의 판정 후, 허용 해주고자 하는 경우 후킹 함수에 유입된 메모리 로드 시스템 함수의 파라미터를 그대로 상기 메모리 로드 시스템 함수에 전달해 줌으로써 메모리 로드를 허용할 수 있고, 허용 해주지 않는 경우 상기 파라미터를 상기 메모리 로드 시스템 함수에 전달해 주지 않거나, 상기 메모리 로드 시스템 함수가 아예 실행 되지 않도록 함으로써 메모리 로드를 차단할 수 있다. 이 때, 전자 장치는 어플리케이션의 실행 코드가 암호화 알고리즘의 실행 코드를 포함하면, 보안성 강화 차원에 서 무조건 상기 어플리케이션의 메모리 로드를 차단하는 것으로 대응 하거나, 합리적 수준의 사용성을 제공 하는 차원에서, 요구 권한 정보(예를 들어, 매니페스트(manifest) 파일)에 기재된 사용 가능 암호화 알고리즘과 다른 암호화 알고리즘이 상기 암호화 코드 식별 모델에 의하여 감지된 경우에 한하여 상기 어플리케이션의 메모 리 로드를 차단하는 것으로 대응할 수 있다. 인스톨러에 의하여 정식으로 설치된 어플리케이션이 운영체제에 의하여 제공되는 암호화 API를 호출하는 경우 , 상기 암호화 API 호출 시 실행 되는 함수의 내부 루틴이 실행됨으로써, 상기 암호화 API의 호출이 감지된 다. 이 때, 암호화 API의 파라미터로서 암호화 알고리즘 타입 및 암호화 대상 데이터가 지정될 것이므로, 상기 암호화 알고리즘의 타입 및 암호화 대상 데이터에 대한 정보가 함수의 내부 루틴으로 유입 된다. 상기 유 입 된 정보를 이용하여, 어플리케이션의 설치 시 사용자 확인 된 요구 권한을 벗어난 암호화 시도가 차단될 수 있다. 예를 들어, 상기 요구 권한에는 암호화 알고리즘 타입 A, B만 사용한다고 되어 있는데, 암호화 알고리즘 타입 C 가 상기 암호화 API의 파라미터로서 지정된 경우, 상기 암호화 API의 동작이 차단될 수 있다. 또한, 상기 요구 권한에는 접근 가능 객체로 연락처(contacts)만 지정 되어 있는데, 사진 데이터가 상기 암호화 API의 파라미터 로서 지정된 경우, 상기 암호화 API의 동작이 차단될 수 있다. 또한, 상기 요구 권한에 포함된 암호화 알고리즘 타입 및 접근 가능 객체 중 하나라도 벗어나는 파라미터가 지정된 암호화 API의 동작은 차단될 수 있다. 다음으로, 어플리케이션이 인스톨러에 의하여 정식으로 설치된 것이 아닌 경우의 고려 대상 케이스들이 도시된 도 2b를 참조하여 설명한다. 인스톨러에 의하여 정식으로 설치되지 않은 어플리케이션의 실행 코드가 암호화 알고리즘의 실행 코드를 포함함 으로써 자체 암호화 알고리즘을 실행하는 경우, 어플리케이션의 실행 코드가 메모리(RAM)에 로드 되는 것이 후킹 되고, 상기 실행 코드에 암호화 알고리즘의 실행 코드가 포함되어 있는 것이 암호화 코드 식별 모델을 이 용하여 감지된다. 이 때, 보안성 강화 차원에서 무조건 상기 어플리케이션의 메모리 로드를 차단하는 것으 로 대응 하거나, 감지된 암호화 알고리즘의 타입이 안전한 암호화 알고리즘 타입이 아닌 경우, 상기 어플리 케이션의 메모리 로드를 차단하는 것으로 대응할 수 있다. 상기 안전한 암호화 알고리즘 타입은 전자 장치에 저장된 화이트 리스트(white list)에 포함된 암호화 알고리즘 타입을 포함하거나, 도 1을 참조하여 설명한 취약점 리스트에 포함되지 않은 암호화 알고리즘 타입을 포함하거 나, 상기 취약점 리스트에 따를 때 취약점 스코어가 기준치 이하인 암호화 알고리즘 타입을 포함할 수 있다. 인스톨러에 의하여 정식으로 설치되지 않은 어플리케이션이지만, 운영체제에 의하여 제공되는 암호화 API를 호 출하는 경우, 상기 암호화 API 호출 시 실행 되는 함수의 내부 루틴이 실행됨으로써, 상기 암호화 API의 호 출이 감지된다. 그런데, 인스톨러에 의하여 정식으로 설치된 경우와 달리, 인스톨러에 의하여 정식으로 설 치되지 않은 어플리케이션에 대하여는 접근을 허용해야 할 범위를 알 수 없다. 따라서, 전자 장치는 인스톨러에 의하여 정식으로 설치되지 않은 어플리케이션이 운영체제에 의하여 제공되는 암호화 API를 호출한 경우, 무조건 상기 암호화 API의 동작을 차단하는 것으로 대응할 수 있다. 이하, 본 발명의 다른 실시예에 따른 보안 강화 시스템의 구성을 도 3을 참조하여 설명한다. 상기 보안 강화 시 스템은 클라이언트 파트 및 서버 파트를 포함한다. 도 3에는 각각의 논리적 동작 단위를 가리키는 모듈들이 도 시되어 있다. 이하, 각 모듈의 동작 순서에 따라 설명한다. 어플리케이션이 인스톨러를 통하여 클라이언트 파트에 설치될 때, 인스톨러는 어플리케이션 설 치 패키지에 포함된 어플리케이션 요구 권한 정보(예를 들어, manifest 파일)에서 사용 대상 암호화 알고리즘 타입, 접근 가능 객체 등에 대한 정보를 얻고, 접근 리스트 관리자를 통해 접근 리스트에 저장한다. 그 결과, 접근 리스트에는 각각의 어플리케이션 별로, 사용 가능한 암호화 알고리즘 타입 및 접근 가능 객체에 대한 정보가 저장될 것이다. 어플리케이션이 메모리로 로드 되기 위한 시스템 함수가 실행 되기 전 후킹 모듈이 먼저 실행된다. 후킹 모듈은 어플리케이션의 실행 코드가 보안 환경에서 실행 되도록 하고, 상기 실행 코드의 실행 결 과를 이용하여 암호화 코드 식별 모델에 대한 입력 데이터를 구성한다.한편, 암호화 코드 식별 모델은, 서버 파트의 암호화 코드 기계학습 모듈에 의하여 기계학습 된 것일 수 있다. 즉, 암호화 코드 식별 모델은 서버 파트에서 클라이언트 파트로 다운로드 된 것일 수 있다. 물론 암호화 코드 식별 모델은 클라이언트 파트에 저장되어 있던 것일 수도 있다. 암호화 코드 식별 모델의 출력 데이터는 상기 실행 코드에 포함된 암호화 알고리즘의 타입에 대한 데이터를 포함할 수 있다. 컨트롤러는 상기 출력 데이터를 제공 받고, 후킹 모듈에 의하여 홀딩(holding) 되어 있는 어플리케이션의 메모리 로드를 허용할 것인지 여부를 결정한다. 예를 들어, 컨트롤러는 상기 실행 코드에 포함된 암호화 알고리즘의 타입이 접근 리스트에 저장된 어플리케이션 접근 권한에 부합하는 것인지 판정하거나, 상기 실행 코드에 포함된 암호화 알고리즘의 타입이 취약점 리스트 관리자를 통하여 접근할 수 있는 취약점 리스트에 포함된 취약 암호화 알고리즘은 아닌지 판정함으로써, 상기 메모리 로드를 허용할 것 인지 여부를 결정할 수 있다. 이 때, 상기 취약점 리스트는 서버 파트의 취약점 정보 수집기로부터 다 운로드 된 취약 암호화 알고리즘 정보를 포함할 수 있다. 컨트롤러가 상기 메모리 로드를 불허하는 것으로 결정한 경우, 어플리케이션의 실행 코드는 메모리(7 5)에 로드 되지 않는다. 즉, 후킹 모듈은 후킹 된 메모리 로드 시스템 함수로 컨트롤을 반환해 주지 않고 종료한다. 또한, 통지 모듈은 부적절한 암호화 알고리즘의 실행과 관련된 클라이언트 사용자에 대한 통지 또는 서버 파트에 대한 통지를 수행한다. 반면, 컨트롤러가 상기 메모리 로드를 허용하는 것으로 결정한 경 우, 어플리케이션의 실행 코드는 메모리에 로드 된다. 즉, 후킹 모듈은 후킹 된 메모리 로드 시스 템 함수로 컨트롤을 반환해 주고 종료한다. 이하, 본 발명의 또 다른 실시예에 따른 전자 장치의 구성 및 동작에 대하여 도 4 내지 도 8을 참조하여 설명한 다. 일 실시예에서, 보안 강화 관련 동작의 수행을 위한 인스트럭션과, 어플리케이션의 실행 코드가 동일한 프로세 서에서 실행되는 전자 장치가 제공된다. 본 실시예의 전자 장치의 구성 예시가 도 4에 도시되어 있다. 다른 실시예에서, 보안 강화 관련 동작의 수행을 위한 인스트럭션과, 어플리케이션의 실행 코드가 서로 다른 프 로세서에서 실행되는 전자 장치가 제공된다. 본 실시예의 전자 장치의 구성 예시가 도 8에 도시 되어 있다. 본 명세서에서 인스트럭션(instruction)은 기능을 기준으로 묶인 일련의 명령어들로서 프로세서에서 실행되는 것을 가리킨다. 먼저, 도 4를 참조하여 본 실시예에 따른 전자 장치의 구성 및 동작을 설명한다. 도 4에 도시된 바와 같이, 본 실시예에 따른 전자 장치는 프로세서, 메모리 및 스토리지를 포함한다. 전자 장치는 어플리케이션의 실행 등을 위한 사용자 입력을 받고, 비디오/오디오 등의 출력을 제공하는 입출력 인터페이스 와, 네트워크에 연결되는 네트워크 인터페이스를 더 포함할 수 있다. 시스템 버스는 프로세 서, 메모리, 입출력 인터페이스 및 스토리지 사이의 데이터 송수신 통로 역할을 수행한다. 메모리는, 예를 들어 RAM(Random Access Memory)와 같은 휘발성 데이터 저장장치일 수 있다. 스토리지 는 플래시 메모리와 같은 비휘발성 메모리, 하드디스크 등의 데이터 저장 장치일 수 있다. 스토리지는 취약점 리스트(131a) 및 접근 리스트(132a)를 저장할 수 있다. 취약점 리스트(131a)는, 암호화 알고리즘 취약점 수집 장치에서 수신된 암호화 알고리즘 취약점 정보에 포함된 것이다. 접근 리스트(132a)는 어 플리케이션의 식별 정보 및 사용 가능 암호화 알고리즘을 매칭하여 저장한 것이거나, 도 7에 도시된 것과 같이, 어플리케이션의 식별 정보, 사용 가능 암호화 알고리즘 및 접근 가능 객체를 매칭하여 저장한 것일 수 있다. 스토리지는 암호화 알고리즘 모니터링 프로그램의 데이터(133a)를 저장할 수 있다. 암호화 알고리즘 모니 터링 프로그램의 데이터(133a)는 복수의 인스트럭션으로 구성된 실행 코드를 포함하고, 상기 실행 코드는 메모 리에 로드 되어 저장된다(133b). 메모리는 스토리지에 저장된 실행 코드(또는 바이너리 코드)를 로드 하여 저장한다. 상기 실행 코드 는 복수의 인스트럭션으로 구성된다. 프로세서는 메모리에 저장된 인스트럭션을 페치(fetch) 하여 실 행한다. 프로세서는 메모리에 저장된 인스트럭션을 시스템 버스를 통하여 제공 받을 수 있다. 전자 장치에 설치된 운영 체제와 관련된 데이터는 전자 장치의 부팅과 함께 메모리에 로드 되어 저장된다. 도 4에는 메모리에 로드 된 운영 체제 관련 인스트럭션(122a)이 도시되어 있다. 운영 체제 관련 인스트럭션(122a)은 프로세서에서 실행된다(122b). 이미 설명한 바와 같이, 상기 운영 체제는 암호화 API를 포함할 수 있다. 어플리케이션은 암호화 API를 호출(134d) 함으로써, 상기 운영 체제가 제공하는 데이터 암호화 기능을 실행할 수 있다. 프로세서에 보안 환경이 구현 될 수 있다. 보안 환경은 프로그램이 보안 환경의 내부에서만 실 행 되도록 하고, 보안 환경에서 실행되는 프로그램은 외부 리소스에 접근할 수 없다. 즉, 보안 환경 은 샌드박스(sandbox) 방식으로 구현될 수 있다. 또한, 메모리에도 보안 환경이 구현 될 수 있다. 메모리의 보안 환경은 사용자 레벨(user level)에서 수행되는 어플리케이션에 의하여 억세스 될 수 없는 주소 영역을 의미할 수 있다. 즉, 보안 환경 은 SE(Secure Element) 방식으로 구성될 수 있다. 도 4에 도시된 것과 달리, 보안 환경은 메모리 가 아닌 SIM((Subscriber Identification Module) 카드 등 별도의 저장 수단(미도시)을 이용하여 구성될 수도 있음을 유의한다. 메모리의 보안 환경에 포함된 인스트럭션은 프로세서-메모리 브리지를 통하여 프로세서로 바로 제공될 수 있다. 이로 인해, 보안 환경에 포함된 모니터링 인스트럭션(133b)이 본 발명의 실시예들에 따른 보안 강화 기술을 무력화 하기 위한 해킹 프로그램의 인스트럭션으로 무단 교체 되는 것을 방지할 수 있다. 프로세서의 보안 환경에서 실행된 인스트럭션의 출력 데이터 역시 프로세서-메모리 브리지 를 통하여 메모리의 보안 환경에 저장될 수 있다. 이로 인해, 모니터링 인스트럭션(133b)의 실 행 출력 데이터가 상기 해킹 프로그램에 의하여 무단 변경되는 것을 방지할 수 있다. 메모리의 보안 환경에는, 스토리지에 저장된 접근 리스트(132a)가 로드 되어 저장(133b) 될 수 있고, 스토리지에 저장된 취약점 리스트(131a)가 로드 되어 저장(131b) 될 수 있으며, 암호화 코드 식별 모델 트레이닝 장치로부터 수신 된 암호화 코드 식별 모델 관련 데이터가 저장 될 수 있다. 모니터링 인스 트럭션(133b), 모니터링 인스트럭션(133b)의 실행 시에 참조될 수 있는 취약점 리스트(131b), 접근 리스트 (132b) 및 암호화 코드 식별 모델 관련 데이터가 모두 보안 환경에 저장됨으로써, 상기 해킹 프로그 램이 모니터링 인스트럭션(133b)의 동작을 차단하거나 변경하는 것을 방지 할 수 있을 것이다. 암호화 알고리즘 모니터링 프로그램의 데이터(133a)에 포함된 실행 코드는, 전자 장치의 부팅 시점에 스토 리지에서 메모리의 보안 환경으로 로드 되어 저장(133b) 되고, 프로세서의 보안 환경(11 0)에서 백그라운드 모드로 항상 실행(133b) 될 수 있다. 일 실시예에서, 모니터링 인스트럭션(133b)은 스토리지 가 아닌 ROM(Read Only Memory)(미도시)에서 로드 됨으로써, 상기 해킹 프로그램으로부터 더욱 안전하게 보호 될 수 있다. 일 실시예에서, 전자 장치는 실행 코드가 메모리에 로드 되는 것을 후킹 하고, 상기 실행 코드를 보 안 환경에서 실행하고, 상기 실행의 결과를 이용하여 암호화 코드 식별 모델에 입력할 입력 데이터를 구성한다. 암호화 코드 식별 모델이 암호화 알고리즘의 실행 코드로부터 추출된 특징 데이터를 이용하여 기계학습 되 었다면, 상기 입력 데이터는 상기 실행 코드의 실행의 결과를 이용하여 추출된 상기 특징 데이터를 포함하게 될 것이다. 반대로, 암호화 코드 식별 모델이 암호화 알고리즘의 실행 코드의 실행 결과 및 상기 실행 코드 자체 중 적어도 하나를 트레이닝 데이터셋으로서 이용하여 딥러닝(deep learning) 되었다면, 상기 입력 데이터 는 상기 실행 코드의 실행 결과 및 상기 실행 코드 자체 중 적어도 하나를 포함하게 될 것이다. 이하, 이해의 편의를 위해 암호화 코드 식별 모델에 상기 특징 데이터가 입력되는 것을 가정하고 설명할 것이나, 본 발명의 범위는 암호화 알고리즘의 실행 코드의 실행 결과를 반영하는 모든 형태의 입력 데이터가 암 호화 코드 식별 모델에 입력 되는 것에 미치는 점을 유의하여야 한다. 상기 실행 코드의 특징 데이터를 추출하며, 상기 특징 데이터를 암호화 코드 식별 모델에 입력하고, 상기 암호화 코드 식별 모델의 출력 데이터를 이용하여 상기 실행 코드의 메모리 로드 허용 여부를 판정하며, 상기 실행 코드의 메모리 로드를 불허하는 것으로 판정한 경우, 상기 실행 코드가 메모리에 로드 되는 것을 차 단한다. 이하, 스토리지에 그 실행 코드가 저장된 APP(어플리케이션)#1(134a) 및 APP#2(135a)를 대상으로 본 실시예를 설명한다. 입출력 인터페이스를 통한 APP#2 실행 조작이 입력 되면, 운영 체제(122b)는 APP#2의 실행 코드(135a)가 메모리에 로드 되도록 전자 장치를 제어한다. 모니터링 인스트럭션(133b)은 APP#2의 실행 코드(135 a)가 메모리에 로드 되어 저장되기 전에 이를 후킹(hooking) 한다. 모니터링 인스트럭션(133b)의 상기 후킹은는, 예를 들어 프로그램을 실행하는 EXEC()와 같은 시스템 콜(system call)을 후킹(hooking) 하는 것에 의하여 이뤄지거나, 상기 시스템 콜의 내부 로직의 메모리 로딩 동작을 수행 하는 부분 이전에 모니터링 인스트럭션(133b)으로의 점프(jump) 인스트럭션을 삽입함으로써 이뤄질 수 있다. 상기 후킹으로로 인하여, 모니터링 인스트럭션(133b)이 다시 상기 프로그램 실행 시스템 콜으로의 리턴(retur n)을 해줄 때까지는, APP#2의 실행 코드(135a)는 메모리로 로드 될 수 없다. 이렇게 APP#2의 실행 코드 (135a)의 메모리 로딩을 홀딩(holding)해 둔 상태에서, 모니터링 인스트럭션(133b)은 어플리케이션#2의 실행 코 드(135a)의 메모리 로딩을 허용할지 여부를 결정하기 위한 인스트럭션을 실행한다. 이 때 실행될 수 있는 인스 트럭션이 도 5에 예시되어 있다. 상기 후킹을 수행하는 메모리 로드 후킹 인스트럭션(133b-1) 역시 도 5에 도시 되어 있다. 한편, 메모리 로드 후킹 인스트럭션(133b-1)이 모든 실행 코드의 메모리 로드를 다 후킹 하고, 메모리 로딩을 홀딩해 둔 상태에서 테스트를 수행하며, 상기 테스트의 결과 문제가 없을 때 상기 후킹을 해제하여 메로리 로딩 이 진행되도록 한다면, 전자 장치의 전체적인 동작 속도가 너무 느려질 수 있다. 일 실시예에서, 보안 강 화의 목적이 훼손되지 않는 범위에서 일부 실행 코드에 대하여는 메모리 로드 후킹이 면제됨으로써, 전자 장치 의 동작 속도가 너무 느려지는 것을 방지할 수 있다. 이하, 관련 실시예를 설명한다. 어플리케이션의 실행 코드의 화이트 리스트 포함 여부, 상기 실행 코드의 실행 빈도 및 상기 실행 코드의 어플 리케이션의 설치 또는 업데이트 후 경과 시간 중 적어도 하나를 기준으로 상기 실행 코드에 대한 후킹 여부가 판정될 수 있다. 어플리케이션의 실행 코드가 안전성이 확인된 실행 코드들의 리스트인 화이트 리스트에 포함된 것이라면, 후킹이 면제되는 것이 바람직하다. 또한, 어플리케이션의 실행 빈도가 높을 수록 안정성이 높은 범용 어플리케이션일 가능성이 높으므로, 어플리케이션의 실행 빈도가 높을 수록 후킹이 면제되는 것이 바람직하다. 어플리케이션의 설치 또는 업데이트 후 경과 시간이 얼마 되지 않았다면 본 실시예에 따른 보안 테스트를 받지 않았을 가능성이 높다. 따라서, 어플리케이션의 설치 또는 업데이트 후 경과 시간이 길을 수록 후킹이 면제되는 것이 바람직하다. 후킹의 면제 여부 판정은, 상기 설명된 판정 요소들 중 적어도 일부를 종합적으로 반영하여 수행 될 수 있을 것이다. 또한, 어플리케이션에 대한 인스톨 이력이 존재하는지 여부에 따라 상기 실행 코드에 대한 후킹 여부가 판정될 수도 있다. 전자 장치에 정식으로 인스톨 되지 않은 어플리케이션이라면, 정식으로 인스톨 된 어플리케이션에 비하여 악성 프로그램일 가능성이 더 높다고 볼 수 있을 것이다. 따라서, 상기 실행 코드의 어플리케이션에 대 한 인스톨 이력이 존재하지 않는 경우에 한하여 상기 실행 코드가 메모리에 로드 되는 것을 후킹 하고, 상기 실 행 코드의 어플리케이션에 대한 인스톨 이력이 존재하는 경우, 상기 실행 코드의 메모리 로드 후킹을 면제 할 수 있을 것이다. 상기 후킹 후, 실행 코드 특징 데이터 추출 인스트럭션(133b-2) 및 암호화 알고리즘 분류기 인스트럭션(133b- 3)이 APP#2의 실행 코드(135a)를 대상으로 실행된다. 도 6에 도시된 바와 같이, 실행 코드 특징 데이터 추출 인 스트럭션(133b-2)이 APP#2의 실행 코드(135a)를 보안 환경에서 실행하고, 그 결과를 이용하여 특징 데이터 를 추출할 수 있다. 도 6에 도시된 것과 달리, 암호화 코드 식별 모델 내부에서 APP#2의 실행 코드(135a)의 특징 데이터 추출 이 수행될 수도 있음을 유의한다. 예를 들어, 암호화 코드 식별 모델이 딥러닝(deep learning) 기반의 기 계 학습에 의하여 생성된 것이라면, 암호화 코드 식별 모델 내부에서 APP#2의 실행 코드(135a)의 특징 데 이터가 추출될 수 있다. 이 때, 암호화 코드 식별 모델은 복수의 CNN(Convolutional Neural Network) 레 이어를 포함할 수 있다. 이 때, 암호화 코드 식별 모델은 APP#2의 실행 코드(135a)을 직접 입력 받을 수 있을 것이다. 이미 설명한 바와 같이, 보안 환경은 샌드박스 환경일 수 있다. 코드 특징 데이터 추출 인스트럭션(133b- 2)이 APP#2의 실행 코드(135a)를 샌드박스 환경에서 실행함으로써, APP#2의 실행 코드(135a)에 전자 장치 에 나쁜 영향을 끼칠 수 있는 암호화 관련 로직이 포함되어 있다 하더라도, 상기 암호화 관련 로직의 수행 결과 는 샌드박스 환경 밖의 시스템 리소스에 영향을 주지 않는다. 따라서, 특징 데이터의 추출을 위한 APP#2의 실행 코드(135a)의 실행 때문에 전자 장치의 데이터가 복호화 불가능하도록 암호화 되는 것은 방지된다. 도 1을 참조하여 암호화 코드 식별 모델은 암호화 코드 식별 모델 트레이닝 장치로부터 수신한 데이터 를 이용하여 구성된 것인 점을 설명한 바 있다. 실행 코드 특징 데이터 추출 인스트럭션(133b-2)도 암호화 코드 식별 모델 트레이닝 장치와 동일한 방식으로 특징 데이터 추출을 수행하는 것이 바람직하다. 따라서, 실행 코드 특징 데이터 추출 인스트럭션(133b-2)의 특징 데이터 추출 관련 동작은, 암호화 코드 식별 모델 트레이닝장치의 특징 데이터 추출과 관련된 기재를 참조하여 이해될 수 있을 것이다. 암호화 알고리즘 분류기 인스트럭션(133b-3)은 상기 특징 데이터를 암호화 코드 식별 모델에 입력 하고, 상기 암호화 코드 식별 모델의 출력 데이터를 이용하여 APP#2의 실행 코드(135a)의 메모리 로드 허용 여부를 판 정한다. 도 6에 도시된 바와 같이, APP#2의 실행 코드(135a)에 암호화 알고리즘 aes-128-cbc의 실행 코드가 포함된 것이 판정 된 경우의 전자 장치의 동작을 설명하되, 이해의 편의를 돕기 위하여 도 2a 및 도 2b를 통하여 소개 된 4가지의 고려 대상 케이스(53, 57, 61, 65)를 함께 언급한다. APP#2가 사용자 조작에 따른 인스톨러의 실행에 의하여 전자 장치에 설치된 것인 경우라면, APP#2의 실행 코드 (135a)에 암호화 알고리즘 aes-128-cbc의 실행 코드가 포함된 바, 도 2a의 케이스에 해당한다. 이 때, 이미 설명한 바와 같이, 암호화 알고리즘의 실행 코드가 포함되었으므로 무조건 APP#2의 실행 코드의 메모리 로드를 차단하거나, 접근 리스트(132b)에 따를 때 APP#2가 암호화 알고리즘 aes-128-cbc에 대한 실행 권한을 가지 지 않았다면 APP#2의 실행 코드(135a)의 메모리 로드를 차단할 수 있다. 도 7에 도시된 접근 리스트(132b) 에 따르면 APP#2는 실행 가능 암호화 알고리즘이 RSA 뿐이므로, APP#2의 실행 코드(135a)는 메모리에 로드 될 수 없다. 일 실시예에서, 전자 장치는 상기 APP#2의 설치 기록이 발견되지 않는 경우에 한하여 메모리 로드를 차단할 수 도 있다. 이 경우, APP#2는 인스톨러의 실행에 의하여 전자 장치에 설치된 것이므로, 설치 기록이 발견될 것이 고, 따라서, APP#2의 메모리 로드는 차단되지 않을 것이다. 도 5에는 접근 리스트(132b)의 내용을 조회하는 접근 리스트 조회 인스트럭션(133b-4)과, 사전 정의된 설정 또 는 보안 관련 사용자 설정에 따라 어플리케이션의 실행 코드의 메모리 로드 허용 여부를 판정하는 메모리 로드 허용 여부 판정 인스트럭션(133b-6)과, 메모리 로드를 허용해야 할 경우, 상기 후킹을 해제하는 메모리 로드 후 킹 해제 인스트럭션(133b-7)이 도시되어 있다. 한편, 일 실시예에 따르면, APP#2가 암호화 알고리즘 aes-128-cbc에 대한 실행 권한을 가졌더라도, aes-128-cbc 가 취약점 리스트(131b)에 포함된 것이라면, aes-128-cbc의 취약성에 따라, APP#2의 실행 코드(135a)의 메모리 로드가 차단될 수 있다. 도 5에는 취약점 리스트(131b)의 내용을 조회하는 취약점 리스트 조회 인스트럭션 (133b-5)이 도시되어 있다. APP#2가 사용자 조작에 따른 인스톨러의 실행에 의하여 전자 장치에 설치된 것이 아니고, APP#2의 실행 코드 (135a) 만 외부 장치에서 네트워크 인터페이스를 통하여 수신되고, 스토리지에 저장된 것이며, 보안 상 취약점을 악용하여 실행 권한을 획득하여 실행을 시도하는 경우라면, APP#2의 실행 코드(135a)에 암호화 알 고리즘 aes-128-cbc의 실행 코드가 포함된 바, 도 2b의 케이스에 해당한다. 이 때, 이미 설명한 바와 같이, 암호화 알고리즘의 실행 코드가 포함되었으므로 무조건 APP#2의 실행 코드의 메모리 로드를 차단하거나, aes-128-cbc이 본 명세서에서 이미 설명된 '안전한 암호화 알고리즘'으로 등록된 것이 아니라면, APP#2의 실행 코드(135a)의 메모리 로드가 차단될 수 있다. 도 4에는 APP#2의 실행 코드(135a)가 스토리지에서 메모리로 로드 되는 것(135b)이 모니터링 인스트 럭션(133b)에 의하여 차단된 것이 도시되어 있다. APP#2와는 달리, APP#1은 암호화를 수행하지 않는 어플리케이 션인 등의 이유로 정상적으로 메모리에 로드(134b) 되어 저장(134c)될 수 있다. 일 실시예에서, 전자 장치는 어플리케이션의 인스톨 시에 자동으로 암호화 알고리즘과 관련된 보안 테스트 를 수행한다. 이하, APP#3의 인스톨러 실행 코드(136a)를 대상으로 본 실시예를 설명한다. APP#3의 인스톨러 실행 코드(136a)는 메모리로 로드(136b) 되어 저장된다(136c). 실행을 위해 메모리로 로 드 된 인스톨러(136c)는, APP#3의 실행 코드를 구성하고, APP#3의 설치 패키지(미도시)에 포함된 APP#3의 요구 권한 정보를 이용하여 (APP#3의 식별자, 사용 가능 암호화 알고리즘 및 접근 가능 객체)를 접근 리스트(132b)에 추가한다. 인스톨러(136c)는, 인스톨 관련 동작이 마무리 되면, 사용자의 별도 조작이 없이도 자동으로 모니터링 인스트럭 션(133b)을 실행한다(136d). 이 때, 모니터링 인스트럭션(133b)은 인스톨러(136c)에 의하여 구성된 APP#3의 실 행 코드를 보안 환경에서 실행하고, 상기 실행의 결과를 이용하여 상기 실행 코드의 특징 데이터를 추출하며, 상기 특징 데이터를 암호화 코드 식별 모델에 입력하고, 상기 암호화 코드 식별 모델의 출력 데이터를 이 용하여 APP#3의 실행 코드의 보안 테스트 통과 여부를 판정한다.모니터링 인스트럭션(133b)은 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘과, 상기 어플리케이션의 설치 패키지에 포함된 어플리케이션 요구 권한 정보에서 얻은 사용 가능 암호화 알고리즘에 대 한 정보와 매치되지 않는 경우, 상기 실행 코드의 보안 테스트 통과 여부의 판정 결과를 실패로 판정할 수 있다. 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘과, 상기 사용 가능 암호화 알고 리즘이 매치되지 않는다는 것은, APP#3의 실행 코드 내에 사용자에 고지하지 않은 다른 암호화 알고리즘의 실행 코드가 존재한다는 것을 의미한다. 따라서, 이러한 경우에는 APP#3의 인스톨을 정상적으로 완료하지 않는 것이 바람직할 것이다. 모니터링 인스트럭션(133b)은 상기 보안 테스트 통과 여부의 판정 결과 실패로 판정한 경우, APP#3에 대하여 기 지정된 프로세스를 수행한다. 상기 기 지정된 프로세스는, 인스톨러(136c)에 테스트 통과 실패 통지를 제공하여, 인스톨러(136c)로 하여금 언인스톨 등의 조치를 취하도록 하거나, 모니터링 인스트럭션(133b)이 직접 APP#3의 실행 코드를 삭제 또는 스크램블링(scrambling) 하여 실행 될 수 없도록 하는 것일 수 있다. 일 실시예에서, 전자 장치는 어플리케이션의 실행 코드에 포함된 암호화 알고리즘의 식별 결과에 기반하여 상기 어플리케이션의 암호화 기능 안정성을 사전 테스트 할 수 있다. 이 때, 어플리케이션의 타입에 따라 상기 사전 테스트의 빈도를 다르게 할 수 있다. 즉, 제1 타입의 어플리케이션을 상기 제1 타입의 어플리케이션을 실 행하기 위한 사용자 조작 없이 제1 빈도로 보안 테스트 프로세스를 수행하고, 제2 타입의 어플리케이션을 상기 제2 타입의 어플리케이션을 실행하기 위한 사용자 조작 없이 제2 빈도로 보안 테스트 프로세스를 수행할 수 있 다. 일 실시예에서, 실행 빈도가 높은 타입의 어플리케이션은 중요한 것일 확률이 높으므로, 상기 사전 테스트의 빈 도도 높을 수 있다. 다른 실시예에서는 기본 페이지의 바탕화면에 아이콘이 배치된 어플리케이션 역시 중요한 것일 확률이 높으므로, 상기 사전 테스트의 빈도도 높을 수 있다. 보안 강화의 목적이 훼손되지 않는 범위에서 메모리 로드 후킹이 일부 면제됨으로써, 전자 장치의 동작 속 도가 느려지는 것을 방지하는 것과 관련된 실시예를 설명한 바 있다. 상기 사전 테스트를 통과한 어플리케이션 에 대하여는 일정한 테스트 결과 유효 기간 동안 메모리 로드 후킹이 면제 될 수 있다. 상기 보안 테스트 프로세스는 보안 테스트 프로세스 인스트럭션(133c)에 의하여 실행될 수 있다. 보안 테스트 프로세스 인스트럭션(133c)은 테스트의 주기(예를 들어, 일간 테스트, 주간 테스트 등)를 관리하고, 테스트의 주기에 따라 테스트 대상 어플리케이션을 선정한다. 보안 테스트 프로세스 인스트럭션(133c)은 선정된 테스트 대상 어플리케이션에 대한 테스트를 진행하기 위하여 모니터링 인스트럭션(133b)을 호출(133d) 한다. 이미 설명 한 바와 같이, 모니터링 인스트럭션(133b)은 상기 실행 코드의 보안 테스트 통과 여부를 판정한다. 보안 테스트 에 통과되지 못한 어플리케이션에 대하여는 사용자 통지, 비활성화, 블랙 리스트 등록, 강제 삭제 등의 조치가 자동으로 취해질 수 있을 것이다. 일 실시예에서, 전자 장치는 어플리케이션에 승인된 접근 권한을 넘어선 암호화 시도를 감지하고, 이를 차 단한다. 도 7의 접근 리스트를 이용하여 설명하면, 전자 장치는 APP#1이 암호화 API를 호출하여 RSA 알고 리즘을 이용한 암호화를 시도하거나(사용 가능하지 않은 암호화 알고리즘 사용), APP#2가 RSA 알고리즘을 이용 하여 연락처의 암호화를 시도하거나(접근이 허용되지 않은 객체를 암호화), APP#3가 RSA 알고리즘을 이용하여 파일의 암호화를 시도하는 경우(사용 가능하지 않은 암호화 알고리즘으로 접근이 허용되지 않은 객체를 암호 화), 이를 차단할 것이다. 이하 APP#3이 sha-256 알고리즘을 이용하여 사진을 암호화 하기 위하여 암호화 API를 호출하는 경우의 전자 장치의 동작을 설명한다. APP#3 인스톨러(136c)가 어플리케이션의 설치 패키지에 포함된 어플리케이션 요구 권한 정보(예를 들어, 매니페 스트 파일)에서 사용 가능 암호화 알고리즘에 대한 정보와 접근 가능 객체 정보를 얻고, 어플리케이션의 식별 정보, 사용 가능 암호화 알고리즘 및 접근 가능 객체를 매칭하여 접근 리스트(132a)에 저장한다. 접근 리스트 (132a)는 주기적/비주기적으로 검증 절차를 거친 후 보안 환경에 로드 된다(132b). APP#3가 실행되고, 암호화 API가 APP#3에 의하여 호출된다. 암호화 API 내부 로직의 실행을 통해, 암 호화 API의 호출에 따른 (암호화 알고리즘[sha-256], 암호화 대상 객체)가 APP#3의 접근 권한 내에 있는지 여부가, 접근 리스트(132b)를 이용하여 판정된다. APP#3는 hmac-128 알고리즘 및 sha-256 알고리즘을 사용하여 연락처 또는 파일을 암호화할 수 있는 권한을 가지고 있는데, sha-256 알고리즘을 이용하여 사진을 암호화 하도 록 암호화 API를 호출하였으므로, 암호화 API는 암호화 관련 루틴 수행을 차단한다. 이 때, 암호화 API는 암호화 관련 루틴 수행 차단과 관련된 메시지를 디스플레이 할 수 있다.일 실시예에서, 암호화 API는 파라미터를 통하여 지정된 암호화 알고리즘의 취약점을 취약점 리스트(131 b)에서 조회하고, 조회된 취약점에 대한 정보를 기준으로 암호화 관련 루틴의 수행 여부를 판정할 수도 있다. 즉, 암호화 API의 호출에 따른 (암호화 알고리즘[sha-256], 암호화 대상 객체)가 APP#3의 접근 권한 내에 있더라도, sha-256 알고리즘에 대한 취약점 정보가 취약점 리스트(131b)에 포함되어 있고, 취약점 스코어가 기 준치를 초과하는 경우, sha-256 알고리즘이 실행되는 것이 차단될 수 있다. 이 때, 전자 장치는 취약 암호 화 알고리즘인 sha-256 알고리즘의 실행 사실을 암호화 알고리즘 취약점 수집 장치에 통지할 수 있다. 본 발명의 다른 실시예에 따른 전자 장치에 대하여 도 8을 참조하여 설명한다. 본 실시예에 따른 전자 장 치는, 어플리케이션의 메모리 로드를 후킹 하여 테스트를 진행하는 보안 환경이 별도의 전용 프로세서를 통하여 구현된 것이다. 이하, 도 4의 전자 장치와 차별화 되는 부분을 위주로 도 8의 전자 장치에 대 한 설명을 개시한다. 도 8에 도시된 바와 같이, 전자 장치는 스토리지에서 메모리로 로드 된 어플리케이션의 실행 코 드(134c)가 실행 되는 프로세서 및 상기 실행 코드가 상기 메모리에 로드 되는 것의 허용 여부를 판단하는 복수의 인스트럭션을 실행하는 암호화 알고리즘 모니터링 프로세서를 포함한다. 도 4를 참조하여 설명한 보안 환경이 별도의 암호화 알고리즘 모니터링 프로세서의 형태로 구현된 것으로 이해될 수 있을 것이다. 즉, 암호화 알고리즘 모니터링 프로세서에서 실행 된 프로그램은 암호화 알고리즘 모니터링 프로세서 내부에서만 실행 되고, 스토리지, 입출력 인터페이스, 네트워크 인터페이스 등 외부 리소스에 접근할 수 없다. 즉, 암호화 알고리즘 모니터링 프로세서는 샌드박스 환경을 구현 한 것이다. 암호화 알고리즘 모니터링 프로세서는 내부 스토리지(미도시)를 포함할 수 있다. 상기 내부 스토리지에 접 근 리스트(132b), 취약점 리스트(131b) 및 암호화 코드 식별 모델이 저장될 수 있다. 전자 장치는 모든 실행 코드가 암호화 알고리즘 모니터링 프로세서의 허용 여부 판단을 거쳐 메모리 로 로드 되도록 제어할 수 있다. APP#1의 실행 코드(134a)는 암호화 알고리즘 모니터링 프로세서의 로드 허용 판단에 따라 메모리에 로드(134b) 되어 저장(134c) 됨으로써, 프로세서에 의하여 실행될 수 있지만, APP#2의 실행 코드(135a)의 로드 시도(135b)는 암호화 알고리즘 모니터링 프로세서의 로드 불 허 판단에 따라 메모리에 로드 되지 않는 상황이 도 8에 도시 되어 있다. 모니터링 인스트럭션(133b)의 동 작은 도 4를 참조하여 설명한 것과 다르지 않다. 이하, 본 발명의 몇몇 실시예들에 따른 보안 강화 방법들에 대하여, 도 9a 내지 도 13을 참조하여 설명한다. 상 기 보안 강화 방법들은 전자 장치에 의하여 수행될 수 있다. 상기 전자 장치는, 예를 들어 도 1에 도시된 전자 장치(100a 내지 100e)일 수 있다. 상기 방법들에 도 1 내지 도 8을 참조하여 설명한 전자 장치의 동작이 적어도 일부 포함될 수 있음을 유의한다. 따라서, 이하 설명되는 상기 보안 강화 방법들에 대한 설명에서 별도의 개시 가 없더라도, 도 1 내지 도 8을 참조하여 설명한 전자 장치의 동작이 상기 방법들에 포함될 수 있다. 또한, 이 하 상기 방법들에 대한 설명에서, 동작의 주체에 대한 기재가 존재하지 않는 경우, 상기 주체는 상기 전자 장치 로 해석될 수 있다. 일 실시예에 따르면, 상기 전자 장치에 의하여 수행되는 어플리케이션의 실행 여부를 제어하는 방법이 제공된다. 본 실시예에 대하여 도 9a를 참조하여 설명한다. 상기 어플리케이션의 실행 코드가 메모리 로드 되는 것이 후킹 된다(S102). 상기 메모리 로드는, 상기 전자 장 치의 사용자가 상기 어플리케이션의 아이콘을 선택하는 등 상기 어플리케이션을 실행시키기 위한 사용자의 조작 에 의하여 트리거(trigger) 된다. 상기 후킹에 의하여 상기 어플리케이션의 실행 코드가 메모리에 로드 되는 것 이 잠시 홀딩 된 상태에서, 상기 실행 코드가 암호화 코드 식별 모델에 입력 되고(S105), 그 결과로 암호화 코 드 식별 모델이 실행 코드의 메모리 로드 허용 여부를 판정하게 된다(S107). 상기 실행 코드가 암호화 코드 식별 모델에 입력된다는 것은, 실행 코드 자체가 암호화 코드 식별 모델에 입력 되는 것 또는 실행 코드로부터 추출된 특징 데이터가 암호화 코드 식별 모델에 입력되는 것을 의미한다. 실행 코드로부터 추출된 특징 데이터가 암호화 코드 식별 모델에 입력되는 실시예는 도 9b 또는 도 9c를 참조하여 자 세히 후술될 것이다. 암호화 코드 식별 모델이 실행 코드의 메모리 로드 허용 여부를 판정한다는 것은, 상기 암호화 코드 식별 모델 의 출력 데이터를 이용하여 상기 메모리 로드 허용 여부가 판정되는 것을 의미하거나, 상기 암호화 코드 식별모델이 직접 상기 메모리 로드 허용 여부를 판정하는 것을 의미할 수 있다. 메모리 로드가 허용 되는 것으로 판정되면(S112), 후킹 함수에서 메모리 로드 시스템 함수로의 파라미터 전달 등의 방식으로, 메모리 로드를 후킹 한 것을 해제한다(S114). 메모리 로드가 허용 될 수 없는 것으로 판정되는 경우(S112), 메모리 로드가 차단되고(S116), 실행 코드에 포함된 암호화 알고리즘의 보안 설정 위반을 이유로 어플리케이션이 실행될 수 없음을 알리는 메시지가 디스플레이 될 수 있다(S118). 이하, 실행 코드로부터 추출된 특징 데이터가 암호화 코드 식별 모델에 입력되는 것과 관련된 실시예에 대하여 도 9b를 참조하여 설명한다. 단계 S100에서, 암호화 코드 식별 모델에 대한 데이터가 외부 장치로부터 다운로드 되어 저장된다. 상기 외부 장치는, 도 1을 참조하여 설명된 암호화 코드 식별 모델 트레이닝 장치일 수 있다. 상기 암호화 코드 식별 모델 이 인공 신경망(neural network) 기반의 모델인 경우, 다운로드 되는 데이터는 상기 인공 신경망을 정의하기 위 한 파라미터 셋(parameter set)일 수 있다. 본 실시예에서, 암호화 코드 식별 모델은 전자 장치에 탑재된 것일 수도 있다. 즉, 암호화 코드 식별 모델의 다 운로드는 선택적인 동작이다. 이와 관련하여 도 9c에는 암호화 코드 식별 모델 다운로드(S100) 동작이 제거된 순서도가 도시되어 있다. 상기 암호화 코드 식별 모델이 전자 장치에 탑재된 것인 경우, 상기 전자 장치는 탑재 된 암호화 코드 식별 모델에 비하여 업데이트 된 암호화 코드 식별 모델을 외부 장치로부터 다운로드 할 수 있 다. 상기 외부 장치는, 상기 전자 장치의 시스템 소프트웨어에 대한 업데이트를 관리하는 서버일 수 있고, 상기 서버는 상기 암호화 코드 식별 모델의 업데이트가 발생되면, 상기 전자 장치에 상기 암호화 코드 식별 모델 업 데이트 커맨드를 송신할 수 있다. 단계 S102에서, 어플리케이션의 실행 코드가 메모리에 로드 되는 것이 후킹 된다. 메모리로의 로딩 시도는 어플 리케이션의 아이콘의 선택 등 상기 어플리케이션을 실행시키기 위한 사용자의 조작에 의하여 트리거(trigger) 된다. 상기 후킹에 의하여 상기 어플리케이션의 실행 코드가 메모리에 로드 되는 것이 잠시 홀딩 된 상태에서, 상기 어플리케이션의 실행 코드가 보안 환경에서 실행 되고(S104), 실행 결과를 반영하여 특징 데이터가 추출되 며(S106), 상기 특징 데이터가 암호화 코드 식별 모델에 입력 되어 상기 실행 코드에 포함된 암호화 알고리즘이 판별 된다(S108). 상기 전자 장치의 동작 속도 저하를 방지하기 위하여, 일 실시예에서, 실행 코드의 화이트 리 스트 포함 여부, 상기 실행 코드의 실행 빈도 및 상기 실행 코드의 어플리케이션의 설치 또는 업데이트 후 경과 시간 중 적어도 하나를 기준으로 한 판정에 따라 상기 실행 코드에 대한 후킹이 면제될 수 있다. 또한, 다른 실 시예에서, 상기 실행 코드의 어플리케이션에 대한 인스톨 이력이 존재하는 경우, 상기 후킹이 면제될 수 있다. 단계 S110에서, 상기 판별의 결과를 이용하여 상기 어플리케이션의 실행 코드에 대하여 메모리 로드를 허용할 것인지 여부를 판정한다. 이하, 상기 판정 방법에 대하여 몇몇 실시예들을 설명한다. 제1 실시예에서, 어플리케이션의 실행 코드에서 암호화 알고리즘의 실행 코드가 발견되면 무조건 상기 실행 코 드의 메모리 로드를 차단할 수 있다. 제2 실시예에서, 상기 암호화 코드 식별 모델의 출력 데이터가 상기 실행 코드에서 암호화 코드가 탐지 되었음 을 가리키는 경우, 상기 실행 코드의 어플리케이션의 설치 기록을 조회하고, 상기 어플리케이션의 설치 기록이 발견되지 않는 경우 메모리 로드를 불허하는 것으로 판정한다. 즉, 본 실시예에서는, 어플리케이션의 실행 코드 에서 암호화 알고리즘의 실행 코드가 발견되면, 상기 어플리케이션이 인스톨러를 통하여 정식으로 설치된 것이 아닌 경우에 한하여 실행을 차단한다. 제3 실시예에서, 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘이 상기 어플리케이션의 사 용 가능 암호화 알고리즘인지 여부를 도 7 등을 참조하여 설명된 접근 리스트에서 조회하고, 상기 조회의 결과 상기 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘이 상기 어플리케이션의 사용 가능 암호 화 알고리즘이 아닌 경우, 상기 실행 코드의 메모리 로드를 불허한다. 즉, 본 실시예에서는, 어플리케이션의 실 행 코드에서 암호화 알고리즘의 실행 코드가 발견되면, 그 암호화 알고리즘이 인스톨 패키지에 사용 가능 알고 리즘으로 등록 되고 사용자에 의하여 승인된 것이 아닌 경우에 한하여 실행을 차단한다. 제4 실시예에서, 암호화 코드 식별 모델의 출력 데이터가 가리키는 암호화 알고리즘의 취약점을 도 4 등을 참조 하여 설명된 취약점 리스트에서 조회하고, 조회된 취약점에 대한 정보를 기준으로 상기 실행 코드의 메모리 로 드 허용 여부를 판정한다. 즉, 본 실시예에서는, 어플리케이션의 실행 코드에서 암호화 알고리즘의 실행 코드가 발견되면, 그 암호화 알고리즘에 대한 취약점이 보고된 경우에 한하여 실행을 차단한다.제5 실시예에서, 제3 실시예와 제4 실시예가 병합될 수 있다. 즉, 본 실시예에서, 어플리케이션의 실행 코드에 서 암호화 알고리즘의 실행 코드가 발견되면, 그 암호화 알고리즘이 인스톨 패키지에 사용 가능 알고리즘으로 등록 되고 사용자에 의하여 승인된 것이 맞더라도, 그 암호화 알고리즘에 대한 취약점이 보고된 경우라면 실행 을 차단한다. 제6 실시예에서, 전자 장치에 저장된 환경 설정 값에 따라 상기 제1 실시예 내지 상기 제5 실시예 중 어느 하나 가 선택된다. 제7 실시예에서, 어플리케이션의 신뢰도에 따라 상기 제1 실시예 내지 상기 제6 실시예 중 어느 하나가 선택된 다. 상기 어플리케이션의 신뢰도는, 어플리케이션의 제작사의 신뢰도가 높을 수록, 어플리케이션의 요구 권한 정보가 정확하게 작성될 수록, 어플리케이션의 실행 빈도가 높을 수록 높게 부여 되는 값일 수 있다. 메모리 로드가 허용 되는 것으로 판정되면(S112), 후킹 함수에서 메모리 로드 시스템 함수로의 파라미터 전달 등의 방식으로, 메모리 로드를 후킹 한 것을 해제한다(S114). 메모리 로드가 허용될 수 없는 것으로 판정되면 (S112), 메모리 로드가 차단되고(S116), 암호화 알고리즘의 보안 설정 위반을 이유로 어플리케이션이 실행될 수 없음을 알리는 메시지가 디스플레이 될 수 있다(S118). 한편, 본 발명의 다른 실시예에 따르면, 어플리케이션의 인스톨 시에 상기 어플리케이션에 포함된 암호화 알고 리즘의 실행 코드의 감지 결과에 기반하여, 상기 인스톨을 정상적으로 완료할지 여부가 결정될 수 있다. 본 실 시예에 대하여 도 10a를 참조하여 설명한다. 암호화 코드 식별 모델의 다운로드(S100) 후, 어플리케이션의 인스톨러가 실행된다(S103). 상기 인스톨러에 의 하여 상기 어플리케이션의 실행 코드가 구성되면, 곧바로 상기 실행 코드에 대한 암호화 알고리즘 관련 보안 테 스트가 수행된다(S104, S106, S108, S111, S113). 상기 보안 테스트의 방법은 도 9a 내지 도 9c를 참조하여 설 명된 관련 동작을 참조한다. 즉, 보안 테스트의 통과 여부의 판정(S113)을 위해, 도 9a 내지 도 9c의 메모리 로 드 허용 여부의 판정(S112)과 관련된 동작이 수행될 수 있다. 한편, 본 실시예에서, 암호화 코드 식별 모델은 전자 장치에 기 저장된 것일 수도 있다. 즉, 암호화 코드 식별 모델의 다운로드는 선택적인 동작이다. 이와 관련하여 도 10b에는 암호화 코드 식별 모델 다운로드(S100) 동작 이 제거된 순서도가 도시되어 있다. 판정 결과, 상기 어플리케이션의 실행 코드에 문제가 없다고 판단된 경우, 인스톨이 정상적으로 완료 될 것이다 (S119). 반대로 상기 어플리케이션의 실행 코드에 문제가 있다고 판단된 경우, 상기 어플리케이션에 대하여 기 지정된 프로세스가 수행된다(S117). 예를 들어, 사용자에 대한 통지 메시지가 디스플레이 되고, 상기 어플리케 이션이 다시 언인스톨(uninstall) 될 수 있다. 본 실시예에 따르면, 암호화 알고리즘과 관련하여 문제될 수 있는 어플리케이션이 상기 전자 장치에 인스톨 되 는 것 자체를 차단할 수 있다. 본 발명의 또 다른 실시예에 따르면, 어플리케이션의 실행 코드에 포함된 암호화 알고리즘의 식별 결과에 기반 하여 상기 어플리케이션의 암호화 기능 안정성이 사전 테스트 된다. 본 실시예에 대하여 도 11a 내지 도 11b를 참조하여 설명한다. 암호화 코드 식별 모델의 다운로드(S100) 후, 단계 S101에서, 사전 보안 테스트의 수행 시점인지 여부가 판단된 다. 상기 사전 보안 테스트는 주기적으로 반복 수행되거나, 특정 이벤트 발생 시 수행될 수 있다. 상기 사전 보 안 테스트는 제1 주기의 테스트 또는 제2 주기의 테스트일 수 있다. 예를 들어, 상기 제1 주기의 테스트는 일간 테스트이고, 상기 제2 주기의 테스트는 주간 테스트이다. 또한, 상기 특정 이벤트는, 예를 들어 보안 서비스 서 버 등 외부 장치로부터 테스트 수행 트리거 메시지가 수신되는 것일 수 있다. 한편, 본 실시예에서, 암호화 코드 식별 모델은 전자 장치에 기 저장된 것일 수도 있다. 즉, 암호화 코드 식별 모델의 다운로드는 선택적인 동작이다. 이와 관련하여 도 11b에는 암호화 코드 식별 모델 다운로드(S100) 동작 이 제거된 순서도가 도시되어 있다. 사전 보안 테스트 수행 시점인 것으로 판단된 경우(S101), 단계 S102에서, 보안 테스트 대상 어플리케이션이 선 정된다. 예를 들어, 현재 수행될 사전 보안 테스트가 일간 테스트인 경우, 일간 테스트 대상 어플리케이션이 선 정되고, 현재 수행될 사전 보안 테스트가 주간 테스트인 경우, 주간 테스트 대상 어플리케이션이 선정될 것이다.일 실시예에서, 실행 빈도가 높은 타입의 어플리케이션은 중요한 것일 확률이 높으므로, 일간 테스트와 같은 짧 은 주기의 사전 테스트의 대상으로 선정될 수 있다. 이에 따르면, 제1 주기의 사전 보안 테스트의 대상 어플리 케이션의 실행 빈도가, 상기 제1 주기보다 긴 제2 주기의 사전 보안 테스트의 대상 어플리케이션의 실행 빈도보 다 높을 것이다. 다른 실시예에서, 기본 페이지의 바탕화면에 아이콘이 배치된 어플리케이션 역시 중요한 것일 확률이 높으므로, 일간 테스트와 같은 짧은 주기의 사전 테스트의 대상으로 선정될 수 있다. 또 다른 실시예에서, 어플리케이션의 카테고리를 반영하여 사전 보안 테스트의 대상 어플리케이션이 선정될 수 있다. 예를 들어, '금융', '사진 및 비디오', '생산성', '소셜 네트워킹, '쇼핑' 및 '의학' 등 무단 암호화 시 큰 피해가 우려 되고, 보안성이 중요한 카테고리의 어플리케이션은, 일간 테스트와 같은 짧은 주기의 사전 보안 테스트의 대상이 될 수 있다. 다음으로, 선정 된 보안 테스트의 대상 어플리케이션들에 대하여, 암호화 알고리즘 관련 보안 테스트가 수행된 다(S104, S106, S108, S110). 상기 보안 테스트의 방법은 도 9a 내지 도 9c를 참조하여 설명된 관련 동작을 참 조한다. 즉, 보안 테스트의 통과 여부의 판정(S113)을 위해, 도 9a 내지 도 9c의 메모리 로드 허용 여부의 판정 (S112)과 관련된 동작이 수행될 수 있다. 판정 결과, 상기 보안 테스트의 대상 어플리케이션의 실행 코드에 문제가 없다고 판단된 경우, 보안 테스트 결 과 로그(log)가 상기 전자 장치에 기록 될 것이다(S120). 상기 보안 테스트 결과 로그에는 상기 보안 테스트의 대상 어플리케이션 각각에 대하여, 테스트 시점 및 테스트 결과 데이터가 포함된다. 이미 설명한 바와 같이, 상 기 보안 테스트를 통과한 시점으로부터 테스트 유효 기간이 만료되지 않은 어플리케이션에 대하여는, 메모리 로 드 후킹이 면제될 수 있다. 반대로 상기 보안 테스트의 대상 어플리케이션의 실행 코드에 문제가 있다고 판단된 경우, 상기 어플리케이션에 대하여 기 지정된 프로세스가 수행된다(S117). 예를 들어, 사용자에 대한 통지 메시 지가 디스플레이 되고, 보안 테스트를 통과하지 못한 어플리케이션이 강제 언인스톨(uninstall) 되거나, 상기 어플리케이션의 실행 코드가 삭제 될 수 있다. 도 12는 도 11a 또는 도 11b에 따른 방법에서 언급된 사전 테스트의 빈도가 높은 어플리케이션과 빈도가 낮은 어플리케이션을 도시한다. 핸들링 하는 데이터의 중요도가 높은 어플리케이션에 대하여는 잦은 빈도로 사 전 테스트가 수행되고, 핸들링 하는 데이터의 중요도가 중간인 어플리케이션에 대하여는 중간 빈도로 사전 테스트가 수행되며, 핸들링 하는 데이터의 중요도가 낮은 어플리케이션에 대하여는 높은 빈도로 사전 테스 트가 수행될 것이다. 핸들링 하는 데이터의 중요도가 높은 어플리케이션은, 예를 들어 사용자의 건강 관련 정보를 생성하고 가 공하는 헬스 관리 어플리케이션 및 모바일 뱅킹, 주식 거래 등 금융 관련 기능을 수행하는 어플리케이션 등일 수 있다. 핸들링 하는 데이터의 중요도가 중간인 어플리케이션은, 예를 들어 사용자의 사생활과 관련된 정보를 생성 하고 가공하는 SNS(Social Network Service) 관련 어플리케이션일 수 있다. 핸들링 하는 데이터의 중요도가 낮은 어플리케이션은, 예를 들어 공중에 공개된 정보에 억세스하는 웹 브 라우저 등의 정보 조회 어플리케이션일 수 있다. 또 다른 실시예에 따르면, 어플리케이션에 승인된 접근 권한을 넘어선 암호화 시도를 감지하고, 이를 차단한다. 본 실시예에 대하여 도 13을 참조하여 설명한다. 단계 S200에서, 어플리케이션 설치 패키지의 요구 권한 정보(예를 들어, 매니페스트 파일)에서 (사용 가능 암호 화 알고리즘, 접근 가능 객체)의 정보를 얻고, 단계 S201에서, 상기 얻은 정보가 접근 리스트에 저장된다. 단계 S200과 단계 S201은 상기 어플리케이션의 설치 시점에 수행 될 수 있다. 또한, 단계 S202에서, 도 1의 암호화 알고리즘 취약점 수집 장치 등 외부 장치에서 다운로드 된 취약점 리스트가 저장된다. 단계 S204에서, 상기 어플리케이션의 실행 코드가 상기 전자 장치의 운영 체제에서 제공하는 암호화 API가 호출 되는 것이 상기 암호화 API의 함수 내부에서 감지된다. 함수의 내부 루틴에 상기 암호화 알고리즘의 타입 및 암 호화 대상 데이터에 대한 정보가 상기 암호화 API의 파라미터 형태로 유입 된다. 단계 S206에서, 상기 유입 된 정보를 이용하여 암호화 알고리즘의 타입 및 암호화 대상 객체가 식별 된다. 단계 S206에서, 상기 암호화 API를 호출한 프로세스의 식별자 정보를 이용하여 상기 어플리케이션의 식별자도 식별된다. 단계 S208에서, 상기 접근 리스트에서 상기 식별된 정보를 확인하여, 암호화 API의 호출에 따른 (암호화 알고리 즘의 타입, 암호화 대상 객체)가 상기 어플리케이션의 접근 가능한 범위 내에 있는지 확인된다. 상기 암호화 API의 호출이 접근 가능한 범위 내의 것이 아니라면(S210), 어플리케이션에서 접근 권한을 벗어난 암호화를 시 도했음을 알리는 메시지가 디스플레이 되고(S218), 상기 호출된 암호화 API의 암호화 관련 내부 로직의 실행이 차단된다(S220). 상기 암호화 API의 호출이 접근 가능한 범위 내의 것이라면(S210), 암호화 API의 호출에 따른 암호화 알고리즘 에 취약점이 존재하는지 여부가 취약점 리스트에서 조회 된다(S212). 조회의 결과, 호출된 암호화 알고리즘의 취약점 스코어가 기준치를 초과하는 등의 이유로 상기 암호화 API의 실행에 문제가 있을 것으로 판단되면 (S214), 어플리케이션에서 취약점을 가지는 것으로 알려진 암호화 알고리즘의 실행이 시도되었음을 알리는 메시 지가 디스플레이 되고, 상기 암호화 알고리즘의 실행 시도에 대한 외부 장치로의 통지가 수행되며(S218), 상기 호출된 암호화 API의 암호화 관련 내부 로직의 실행이 차단된다(S220). 물론, 조회의 결과, 상기 암호화 API의 실행에 문제가 없을 것으로 판단되면(S214), 호출된 암호화 API가 정상 실행된다(S216). 도 13에 도시된 바와 달리, 취약점 관련 확인 절차는 수행되지 않고, 상기 암호화 API의 호출이 접근 가능한 범위 내의 것이라면 (S210), 바로 암호화 API가 정상 실행(S216) 될 수도 있다. 지금까지 설명된 본 발명의 실시예에 따른 방법들은 컴퓨터가 읽을 수 있는 코드로 구현된 컴퓨터프로그램의 실 행에 의하여 수행될 수 있다. 상기 컴퓨터프로그램은 인터넷 등의 네트워크를 통하여 제1 전자 장치로부터 제2 전자 장치에 전송되어 상기 제2 전자 장치에 설치될 수 있고, 이로써 상기 제2 전자 장치에서 사용될 수 있다. 상기 제1 전자 장치 및 상기 제2 전자 장치는, 서버 장치, 클라우드 서비스를 위한 서버 풀에 속한 물리 서버, 데스크탑 피씨와 같은 고정식 전자 장치를 모두 포함한다. 상기 컴퓨터프로그램은 DVD-ROM, 플래시 메모리 장치 등의 비-일시적인(non-transitory) 기록매체(recording medium)에 저장된 것일 수도 있다."}
{"patent_id": "10-2017-0167588", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "이상 첨부된 도면을 참조하여 본 발명의 실시예들을 설명하였지만, 본 발명이 속하는 기술분야에서 통상의 지식 을 가진 자는 본 발명이 그 기술적 사상이나 필수적인 특징을 변경하지 않고서 다른 구체적인 형태로 실시될 수 있다는 것을 이해할 수 있을 것이다. 그러므로 이상에서 기술한 실시예들은 모든 면에서 예시적인 것이며 한정 적인 것이 아닌 것으로 이해해야만 한다.도면 도면1 도면2a 도면2b 도면3 도면4 도면5 도면6 도면7 도면8 도면9a 도면9b 도면9c 도면10a 도면10b 도면11a 도면11b 도면12 도면13"}
{"patent_id": "10-2017-0167588", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 일 실시예에 따른 암호화 알고리즘 기반 보안 강화 시스템의 구성도이다. 도 2a 내지 도 2b는 본 발명의 몇몇 실시예들에 따른 케이스 별 보안 강화 관련 동작들을 설명하기 위한 도면이 다. 도 3은 본 발명의 일 실시예에 따른 보안 강화 시스템의 구성도이다. 도 4는 본 발명의 다른 실시예에 따른 전자 장치의 구성도이다. 도 5는 도 4에 도시된 일부 인스트럭션(instruction)의 구성을 인스트럭션의 기능 별로 상세하게 도시한 도면이 다. 도 6은 도 4에 도시된 전자 장치가 어플리케이션의 실행 코드에 포함된 암호화 알고리즘을 식별하는 과정을 설 명하기 위한 도면이다. 도 7은 본 발명의 몇몇 실시예들에서 참조되는 접근 리스트의 일 예를 도시한 도면이다. 도 8은 본 발명의 또 다른 실시예에 따른 전자 장치의 구성도이다. 도 9a 내지 도 9c는 본 발명의 또 다른 실시예에 따른 메모리 로드 후킹 기반 보안 강화 방법의 순서도이다. 도 10a 내지 도 10b는 본 발명의 또 다른 실시예에 따른 인스톨러 이용 보안 강화 방법의 순서도이다. 도 11a 내지 도 11b는 본 발명의 또 다른 실시예에 따른 사전 테스트 기반 보안 강화 방법의 순서도이다. 도 12는 도 11a 내지 도 11b에 따른 보안 강화 방법의 이해를 돕기 위한 도면이다. 도 13은 본 발명의 또 다른 실시예에 따른 접근 권한 기반 보안 강화 방법의 순서도이다."}
