{"patent_id": "10-2022-7033915", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0139419", "출원번호": "10-2022-7033915", "발명의 명칭": "어플리케이션들의 다목적 최적화", "출원인": "인터내셔널 비지네스 머신즈 코포레이션", "발명자": "파르타사라시, 스리니바산"}}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "에 있어서, 상기 두 개 또는 그 이상의 KPI 값들의 세트는 레이턴시(latency), 에러율(error rate), 처리율(throughput), 또는 이것들의 조합을 포함하며, 하나 또는 그 이상의 위상적 제약들(topologicalconstraints)과 연관된 상기 하나 또는 그 이상의 파라미터들은 타임아웃(timeout), 재시도(retry), 복제 카운트(replication count), 또는 이것들의 조합을 포함하는, 컴퓨터 시스템."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "청구항 1에 있어서, 상기 ML 기반 대리 함수 러닝 모델은 상기 하나 또는 그 이상의 파라미터들의 설정 각각을상기 두 개 또는 그 이상의 KPI 값들에 맵핑(map)하는, 컴퓨터 시스템."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "청구항 2에 있어서, 상기 ML 기반 대리 함수 러닝 모델은 신경망(neural network), 가우시안 프로그레스 회귀(Gaussian Progress regression), 커널 회귀 기법들(kernal regression techniques), 또는 이것들의 조합을 사용하여 구현되는, 컴퓨터 시스템."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "청구항 1에 있어서, 상기 획득 함수는 상기 어플리케이션의 제2 시험 실행을 위한 하나 또는 그 이상의 제2 파라미터들의 제2 설정(second configuration)을 선택하는, 컴퓨터 시스템."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "청구항 4에 있어서, 상기 획득 함수는 예상 향상 함수(expected improvement function), 향상 함수의 최대 확률(maximum probability of improvement fucntion), 신뢰 상한 함수(upper confidence bound function), 또는이것들의 조합으로 구현되는, 컴퓨터 시스템.공개특허 10-2022-0139419-3-청구항 6"}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "청구항 6에 있어서, 상기 위상적 제약들은 마이크로-서비스들의 계층구조(hierarchy)를 포함하고, 상기 하나 또는 그 이상의 파라미터들은 상기 계층구조에 대하여 설정되고, 자 마이크로-서비스(child micro-service)로부터의 하나 또는 그 이상의 쿼리들(queries)이 액티브 상태(active)인 한 상기 계층구조에서 부모 마이크로-서비스(parent micro-service)로부터의 쿼리가 액티브 상태임을 상기 하나 또는 그 이상의 파라미터들이 보증하도록보장하는 것을 포함하는, 컴퓨터 시스템."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "클라우드 어플리케이션들의 다목적 최적화(multi objective optimization)를 조정(orchestrate)하는 컴퓨터 프로그램 제품으로서, 상기 컴퓨터 프로그램 제품은 컴퓨터 판독가능 스토리지 매체를 포함하고, 상기 컴퓨터 판독가능 스토리지 매체는 그것으로 구현된 프로그램 코드를 가지며, 상기 프로그램 코드는 프로세서에 의해 실행가능하고, 상기 프로세서가,어플리케이션과 연관된 두 개 또는 그 이상의 핵심 성과 지표들(key performance indicators, KPI들)의 세트를수신하는 단계 - 상기 KPI들의 세트에서 각각의 KPI는 KPI 값과 연관됨 - ;상기 하나 또는 그 이상의 수신된 파라미터들로 상기 어플리케이션의 적응적 시험 실행(adaptive trialexecution)을 수행하기 위해 획득 함수(acquisition function)와 함께 머신 러닝(machine learning, ML) 기반대리 함수 러닝 모델(surrogate function learning model)을 활용하는 단계;각각의 시험 시행으로부터 출력을 관찰(observe)하여 상기 관찰된 출력의 파레토 표면(pareto surface)을 컴퓨팅하는 단계;상기 컴퓨팅된 파레토 표면을 탐구(explore)하고 상기 하나 또는 그 이상의 파라미터들의 설정(configuration)에 대응되는 최적의 어플리케이션 동작점(operating point)을 선택하는 단계, 그리고상기 선택된 최적의 어플리케이션 동작점에서 상기 어플리케이션을 실행하는 단계를 수행하게 하는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "청구항 8에 있어서, 상기 ML 기반 대리 함수 러닝 모델은 상기 하나 또는 그 이상의 파리미터들의 설정 각각을상기 두 개 또는 그 이상의 KPI 값들에 맵핑하는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "청구항 9에 있어서, 상기 ML 기반 대리 함수 러닝 모델은 신경망(neural network), 가우시안 프로그레스 회귀(Gaussian Progress regression), 커널 회귀 기법들(kernal regression techniques), 또는 이것들의 조합을 사용하여 구현되는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "청구항 8에 있어서, 상기 획득 함수는 상기 어플리케이션의 제2 시험 실행을 위한 하나 또는 그 이상의 제2 파공개특허 10-2022-0139419-4-라미터들의 제2 설정을 선택하는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "청구항 11에 있어서, 상기 획득 함수는 예상 향상 함수(expected improvement function), 향상 함수의 최대 확률(maximum probability of improvement fucntion), 신뢰 상한 함수(upper confidence bound function), 또는이것들의 조합으로 구현되는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "청구항 8에 있어서, 상기 두 개 또는 그 이상의 KPI 값들의 세트는 레이턴시(latency), 에러율(error rate), 처리율(throughput), 또는 이것들의 조합을 포함하며, 하나 또는 그 이상의 위상적 제약들(topologicalconstraints)과 연관된 상기 하나 또는 그 이상의 조정가능한 파라미터들은 타임아웃(timeout), 재시도(retry),복제 카운트(replication count), 또는 이것들의 조합을 포함하는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "청구항 13에 있어서, 상기 위상적 제약들은 마이크로-서비스들의 계층구조(hierarchy)를 포함하고, 상기 하나또는 그 이상의 파라미터들은 상기 계층구조에 대하여 설정되고, 자 마이크로-서비스(child micro-service)로부터의 하나 또는 그 이상의 쿼리들(queries)이 액티브 상태(active)인 한 상기 계층구조에서 부모 마이크로-서비스(parent micro-service)로부터의 쿼리가 액티브 상태임을 상기 하나 또는 그 이상의 파라미터들이 보증하도록보장하는 단계를 포함하는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "컴퓨터 구현 방법(computer implemented method)으로서, 어플리케이션과 연관된 두 개 또는 그 이상의 핵심 성과 지표들(key performance indicators, KPI들)의 세트를수신하는 단계 - 상기 KIPs의 세트에서 각각의 KPI는 KPI 값과 연관됨 - ;상기 하나 또는 그 이상의 수신된 파라미터들로 상기 어플리케이션의 적응적 시험 실행(adaptive trialexecution)을 수행하기 위해 획득 함수(acquisition function)와 함께 머신 러닝(machine learning, ML) 기반대리 함수 러닝 모델(surrogate function learning model)을 활용하는 단계;각각의 시험 실행으로부터 출력을 관찰(observe)하고 상기 관찰된 출력의 파레토 표면(pareto surface)을 컴퓨팅하는 단계;상기 컴퓨팅된 파레토 표면을 탐구(explore)하고 상기 하나 또는 그 이상의 파라미터들의 설정(configuration)에 대응되는 최적의 어플리케이션 동작점(operating point)을 선택하는 단계; 및상기 선택된 최적의 동작점에서 상기 어플리케이션을 실행하는 단계;를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "청구항 15에 있어서, 상기 ML 기반 대리 함수 러닝 모델은 상기 하나 또는 그 이상의 파라미터들의 설정 각각을상기 두 개 또는 그 이상의 KPI 값들에 맵핑하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "청구항 16에 있어서, 상기 ML 기반 대리 함수 러닝 모델은 신경망(neural network), 가우시안 프로그레스 회귀공개특허 10-2022-0139419-5-(Gaussian Progress regression), 커널 회귀 기법들(kernal regression techniques), 또는 이것들의 조합을 사용하여 구현되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "청구항 15에 있어서, 상기 획득 함수는 상기 어플리케이션의 제2 시험 실행을 위한 하나 또는 그 이상의 제2 파라미터들의 제2 설정을 선택하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "청구항 18에 있어서, 상기 획득 함수는 예상 향상 함수(expected improvement function), 향상 함수의 최대 확률(maximum probability of improvement fucntion), 신뢰 상한 함수(upper confidence bound function), 또는이것들의 조합으로 구현되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7033915", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "청구항 15에 있어서, 상기 두 개 또는 그 이상의 KPI 값들의 세트는 레이턴시(latency), 에러율(error rate),처리율(throughput), 또는 이것들의 조합을 포함하며, 하나 또는 그 이상의 위상적 제약들(topologicalconstraints)과 연관된 상기 하나 또는 그 이상의 파라미터들은 타임아웃(timeout), 재시도(retry), 복제 카운트(replication count), 또는 이것들의 조합을 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7033915", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "어플리케이션의 다목적 최적화(multi objective optimization)를 조정(orchestrate)하기 위한 시스템, 컴퓨터 프로그램 제품, 및 방법이 제공된다. 어플리케이션과 연관된 두 개 또는 그 이상의 핵심 성과 지표들(key performance indicators, KPI들) 및 하나 또는 그 이상의 파라미터들이 수신된다. 획득 함수(aquisition function)와 함께 머신 러닝(machine learning, ML) 기반 대리 함수 모델(surrogate function model)이 활용되 어 하나 또는 그 이상의 적응적 시험들을 수행한다. 각각의 시험은 하나 또는 그 이상의 파라미터들의 특정 설정 (configuration)으로 이루어진다. 어플리케이션의 KPI들의 파레토 표면(pareto surface)은 각각의 적응적 시험 으로부터 KIP 값들의 관찰들에 기초하여 컴퓨팅된다. 파레토 표면이 탐구(explore)되고 어플리케이션에 대한 최 적의 동작점(operating point)이 선택된다. 그런 다음 어플리케이션은 그 선택된 동작점에서 실행된다."}
{"patent_id": "10-2022-7033915", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명의 실시예(들)은 특정 핵심 성과 지표들(key performance indicators)에 대한 최적의 동작점 (operating point)에서 어플리케이션을 실행하는 것과 관련된다. 더 구체적으로는, 본 발명의 실시예들은 파레 토 표면(pareto surface)을 컴퓨팅하기 위해 머신 러닝(machine learning, ML)을 활용(leverage)하는 것, 그리 고 최적의 동작점 확인을 위한 파레토 표면의 탐구(exploration)를 목표로 한다."}
{"patent_id": "10-2022-7033915", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "클라우드 컴퓨팅(cloud computing)은 설정가능한(configurable) 리소스들, 예컨대, 네트워크들, 서버들, 스토리지, 어플리케이션, 및 서비스들의 공유된 풀(pool)에 대한 보편적이고 편리한 주문형 네트워크 (on-demand network)를 가능하게 하기 위한 모델이며, 설정가능한 리소스들은 최소의 관리 노력 또는 서비스 제 공 상호작용으로 신속하게 공급되고 배포될 수 있다. 어플리케이션, 또는 더 구체적으로 클라우드 어플리케이션 (cloud application)은 클라우드 기반 및 로컬 컴포넌트들이 함께 작동하는 소프트웨어 프로그램이다. 이 모델 은 거듭되는 인터넷 접속으로 웹 브라우저를 통해 접근될 수 있는 로직(logic)을 처리하기 위해서 원격 서버들 에 의존한다. 클라우드 어플리케이션 서버들은 원격 데이터 센터에 위치할 수 있다. 클라우드 기반 어플리케이 션 태스크들(tasks)은 이메일, 파일 저장 및 공유, 주문 입력, 재고 관리, 워드 프로세싱, 고객 관계 관리, 데 이터 수집 또는 재무 회계 기능들을 포함할 수 있다. 마이크로-서비스 아키텍쳐(micro-service architecture)로도 알려져 있는 마이크로-서비스들(micro- services)은 하나 또는 그 이상의 모듈형 컴포넌트들(modular components)로 표현되는 서비스들의 집합으로 어 플리케이션을 구성하는 아키텍쳐 방식이다. 모듈형 컴포넌트들은 유지보수와 테스트 가능성이 매우 높으며, 느 슨하게 결합되고, 독립적으로 배치 가능하다. 각각의 모듈은 특정 태스크 또는 사업 목표를 지원하며, 예를 들 어, 어플리케이션 프로그래밍 인터페이스(application programming interface, API)와 같은 심플하고 잘 정의 된 인터페이스를 사용하여 마이크로-서비스들의 다른 세트들과 통신한다. 마이크로-서비스들은 소형의 확장가능 한 컴포넌트들이다. 각각의 모듈은 특정 태스크를 지원하고 어플리케이션 프로그래밍 인터페이스(API)와 같은 정의된 인터페이스를 사용하여 다른 서비스들과 통신한다. 어떤 독립된 마이크로-서비스 모듈이든지 다수의 마이크로-서비스 모듈들로 이루어진 프로그램의 다른 부분들에 영향을 미치지 않고서 변경될 수 있다. 따라서, 마 이크로-서비스 아키텍쳐는 확장성(scalability)을 지원하고 확장성을 가능케 한다. 모놀리식 아키텍쳐(monolithic architecture)는 소프트웨어 어플리케이션의 설계를 위한 통합 모델을 일 컫는다. 모놀리식 소프트웨어는 상호연결되고 상호의존적인 프로그램의 컴포넌트들에 자체적으로 포함되도록 설 계되었다. 모놀리식 아키텍쳐에서, 코드가 컴파일되거나 실행되도록 하기 위해 각각의 컴포넌트 및 그것의 연관 된 컴포넌트들이 존재해야만 한다. 만약 어떤 프로그램 컴포넌트가 업데이트되어 다른 구성요소들 내에서 예상 및 예상되지 않는 변화들에 대처할 필요가 있다면, 전체 어플리케이션이 재작성되어야 한다. 따라서, 모놀리식 아키텍쳐는 크고, 긴밀하게 결합된 어플리케이션을 목표로 한다. 마이크로-서비스 아키텍쳐들은 모놀리식 소프트웨어 아키텍쳐에 비해 더 빠른 소프트웨어 개발 및 배치 로 사업 민첩성을 향상시킨다는 것이 당해 기술 분야에서 이해된다. 더 구체적으로는, 마이크로-서비스 아키텍 쳐는 크고 복잡한 어플리케이션들의 빠르고 빈번하며 신뢰할만한 배포를 가능하게 한다. 마이크로-서비스들로, 개별 서비스들은 개별적으로 배치되거나 개별적으로 확장될 수 있다. 정확하게 수행된다면, 마이크로-서비스들 은 모놀리식 어플리케이션들보다 더 적은 인프라구조를 필요로 한다. 왜냐하면 모놀리식 어플리케이션들의 경우 에 있어서의 전체 어플리케이션 대신에, 마이크로-서비스들은 단지 필요한 컴포넌트들의 정밀한 확장을 가능하 게 하기 때문이다. 마이크로-서비스들, 더 구체적으로는 마이크로-서비스 아키텍쳐에 당면한 과제들이 있다는 것이 당해 기술 분야에서 이해된다. 이러한 과제들은 마이크로-서비스들의 양이 증가함에 따라 마이크로-서비스 들을 관리하고, 마이크로-서비스들을 모니터링하고, 종속성들을 테스트하는 것 등을 목표로 한다."}
{"patent_id": "10-2022-7033915", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "실시예들은 핵심 성과 지표들(key performance indicators)에 관한 클라우드 어플리케이션의 다목적 최 적화를 위한 시스템, 컴퓨터 프로그램 제품, 및 방법을 포함한다. 일 측면에서, 컴퓨터 시스템이 제공되는데, 이 컴퓨터 시스템은 메모리에 동작적으로 결합되는 처리 유 닛과, 처리 유닛 및 메모리에 동작적으로 결합되는 인공 지능(AI) 플랫폼을 포함한다. AI 플랫폼은 입력 매니저 (input manager), 시험 매니저(trial manager), 및 최적화 매니저(optimization manager) 형태의 툴들(tools) 로 구성되어, 어플리케이션의 다목적 최적화를 조정(orchestrate)하기 위한 기능을 갖도록 구성된다. 입력 매니 저는 어플리케이션과 연관된 두 개 또는 그 이상의 핵심 성과 지표들(key performance indicators, KPI들)의 세 트를 수신하도록 구성된다. 시험 매니저는 입력 매니저에 동작적으로 결합되고, 하나 또는 그 이상의 수신된 파 라미터들로 어플리케이션의 적응적 시험 실행(adaptive trial execution)을 수행하기 위해 획득 함수 (acquisition function)와 함께 머신 러닝(ML) 기반 대리 함수 러닝 모델을 활용하도록 구성된다. 시험 매니저 는 시험 실행(들)로부터 관찰된 출력에 기초하여 어플리케이션의 KPI들의 파레토 표면(pareto surface)을 컴퓨 팅하도록 더 구성된다. 시험 매니저에 동작적으로 결합되는 최적화 매니저는, 컴퓨팅된 파레토 표면을 탐구 (explore)하고 어플리케이션에 대한 최적의 동작점을 선택하도록 기능한다. 최적의 동작점은 하나 또는 그 이상 의 파라미터들의 설정(configuration)에 대응된다. 최적화 매니저는 그 선택된 최적의 동작점에서 어플리케이션 을 실행한다. 또 다른 측면에서, 컴퓨터 프로그램 제품이 제공되는데, 이 컴퓨터 프로그램 제품은 어플리케이션의 다 목적 최적화를 조정(orchestrate)한다. 컴퓨터 프로그램 제품은 구현된 프로그램 코드를 갖는 컴퓨터 판독가능 스토리지 디바이스를 포함한다. 프로그램 코드는 어플리케이션들과 연관된 두 개 또는 그 이상의 핵심 성과 지 표들(KPI들)의 세트를 수신하는 기능을 갖는 처리 유닛에 의해 실행가능하다. 프로그램 코드는 하나 또는 그 이 상의 수신된 파라미터들로 어플리케이션의 적응적 시험 실행을 수행하기 위해 획득 함수와 함께 머신 러닝(ML) 기반 대리 함수 학습 모델을 활용한다. 프로그램 코드는 시험 실행(들)로부터 관찰된 출력에 기초하여 어플리케 이션의 KPI들의 파레토 표면을 컴퓨팅한다. 프로그램 코드는 컴퓨팅된 파레토 표면을 탐구하고 하나 또는 그 이 상의 파라미터들의 설정에 대응되는 최적의 동작점으로, 어플리케이션에 대한 최적화 동작점을 선택한다. 프로 그램 코드는 그 선택된 최적의 동작점에서 어플리케이션을 실행하도록 더 기능한다. 또 다른 측면에서, 어플리케이션의 다목적 최적화를 조정(orchestrate)하기 위한 방법이 제공된다. 어플 리케이션과 연관된 두 개 또는 그 이상의 핵심 성과 지표들(KPI들)의 세트가 수신된다. 획득 함수와 함께 머신 러닝(ML) 기반 대리 함수 러닝 모델이 활용되어 하나 또는 그 이상의 수신된 파라미터들로 어플리케이션의 적응 적 실행을 수행한다. 어플리케이션의 KPI들의 파레토 표면은 시험 실행(들)로부터 관찰된 출력에 기초하여 컴퓨 팅된다. 컴퓨팅된 파레토 표면이 탐구되고 그 탐구에 기초하여 어플리케이션에 대한 최적의 동작점이 선택되며, 최적의 동작점은 하나 또는 그 이상의 파라미터들의 설정에 대응된다. 그런 다음, 어플리케이션은 그 선택된 최 적의 동작점에서 실행된다. 본 발명의 여러 가지 특징들 및 장점들은 첨부된 도면들과 함께 설명되는 현재로서 선호되는 실시예 (들)에 관한 이하의 상세한 설명으로부터 분명해질 것이다."}
{"patent_id": "10-2022-7033915", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "여기서의 도면들에 일반적으로 기술되고 설명되는 바와 같이, 본 발명의 실시예들의 컴포넌트들은 광범 위하게 다양한 상이한 구성들에 마련되고 설계될 수 있다는 것은 쉽게 이해될 수 있을 것이다. 따라서, 도면들 에 제시된 바와 같이, 본 발명의 실시예들의 장치, 시스템, 방법, 및 컴퓨터 프로그램 제품의 실시예들에 관한 이하의 상세한 설명은 청구항에 기재된 발명의 실시예들의 범위를 한정하려는 의도는 아니고, 단지 선택된 실시 예들을 대표하는 것일 뿐이다. 본 명세서의 전체에서 \"선택된 실시예\", \"하나의 실시예\", 또는 \"일 실시예\" 라는 언급은 그 실시예들과 관련하여 설명된 구체적인 특징, 구조, 또는 특성이 적어도 하나의 실시예들에 포함된다는 것을 의미한다. 따라 서, 본 명세서 전체에서의 다양한 곳에서 \"선택된 실시예\", \"하나의 실시예에서\", 또는 \"일 실시예에서\" 라는 문구는 반드시 동일한 실시예를 일컫는 것은 아니다. 설명되는 실시예들은 도면들을 참조하여 가장 잘 이해될 것이며, 도면들 전체에서 유사한 부분들은 유사 한 참조번호로 지정되어 있다. 이하의 설명은 단지 예를 들기 위한 것으로 의도되었으며, 본 명세서에서 청구되 는 실시예들과 일치하는 디바이스들, 시스템들, 및 프로세스들의 어떤 선택된 실시예들을 단지 설명하는 것이다. 인공 지능(Artificial Intelligence, AI)은 인간들과 관련되어 컴퓨터들 및 컴퓨터 동작을 목표로 하는 컴퓨터 과학 분야와 관련된다. AI는, 정보에 기초하여 머신들(machines)이 예를 들어, 주어진 주제에서 성공의 기회를 개선하거나 최대화하는 결정을 할 수 있을 때의 지능을 일컫는다. 더 구체적으로는, AI는 데이터 세트로 부터 학습하여 문제들을 해결하고 적절한 추천을 제공할 수 있다. 예를 들어, 인공 지능 컴퓨터 시스템 분야에 서, 자연 언어 시스템들(예컨대, IBM Watson® 인공 지능 컴퓨터 시스템 또는 다른 자연 언어 질의 응답 시스템 들)은 시스템 획득 지식에 기초하여 자연 언어를 처리한다. 자연 언어를 처리하기 위해, 시스템은 데이터베이스 또는 코퍼스(corpus)에서 비롯되는 데이터로 훈련받을 수 있지만, 발생하는 결과는 다양한 이유들로 인해 부정 확하거나 오류가 있을 수 있다. AI와 연관 추론의 핵심에는 유사성(similarity)의 개념이 있다. 자연 언어와 대상물들을 이해하는 프로 세스는 도전적일 수 있는 관계적 관점으로부터의 추론을 필요로 한다. 정적 구조들 및 동적 구조들을 포함하는 구조들은 주어진 확실한 입력에 대한 결정된 출력 또는 동작을 지시한다. 더 구체적으로는, 결정된 출력 또는 동작은 그 구조 내에서의 표현 또는 고유의 관계에 기초한다. 이러한 방식은 선택된 환경들 및 조건들에 대해서 는 만족스러울 수 있다. 하지만, 동적 구조들은 본질적으로 변경의 대상이 되고, 따라서 출력 또는 동작이 변경 의 대상이 될 수 있다는 것이 이해된다. 위에서 언급한 바와 같이 AI의 서브-세트인 머신 러닝(machine learning, ML)은, 명시적인 프로그래밍을 통해서라기보다는 알고리즘들을 이용하여 데이터를 학습하고, 이러한 데이터에 기초하여 예견(foresights)을 생 성해낸다. ML은, 명시적으로 프로그램되지 않은 태스크들을 수행함으로써 러닝(learning) 동작을 보여줄 수 있 는 신경망들(neural networks)의 생성을 통한 AI의 어플리케이션이다. ML은 머신 러닝 모델을 구축하고 머신 러 닝 알고리즘을 훈련시키기 위해 분석되고, 포맷되고, 길들여진 데이터를 필요로 한다. ML 알고리즘이 컴퓨터화 된 절차이고, 데이터에 관해서 훈련받을 때, ML 알고리즘의 ML 모델을 생성한다는 것은 당해 기술 분야에서 이 해된다. ML 알고리즘을 선택하는 것은 ML을 성공적으로 적용하는 것에 있어서 필수적이다. ML의 예들은 회귀 알 고리즘들(regression algorithms), 결정 트리들(decision trees), 인스턴스 기반 알고리즘들(intance-based algorithms), 및 클러스터링 알고리즘들(clustering algorithms)을 포함하지만, 이러한 예들로 한정되는 것은 아니다. 데이터가 준비되고 알고리즘이 훈련되면, ML 모델은 그 데이터에 관한 결정들 또는 예측들을 할 수 있 다. 제공된 데이터의 양이 많으면 많을수록, 그 모델은 더 많은 것을 학습할 수 있고 그것의 예측들의 정확성을 더 향상시킬 수 있다. ML 모델들은 이하의 기본 카테고리들로 분류된다. 즉, 지도 머신 러닝(supervised machine learning), 비지도 머신 러닝(unsupervised machine learning), 강화 머신 러닝(reinforcement machine learinig), 및 딥 러닝(deep learning)이 그것이다. 지도 러닝 알고리즘들은 기존의 분류로 데이터 세트를 위한 맵핑 함수 (mapping function)를 학습하고, 비지도 러닝 알고리즘들은 데이터에서 일부 숨겨진 특징들에 기초하여 라벨이 지정되지 않은 데이터 세트를 분류할 수 있다. 강화 러닝은 불확실한 환경의 반복적인 탐구를 통해 그러한 불확 실한 환경에서 결정을 하기 위한 방침들(policies)을 학습할 수 있다. 딥 러닝은 연속적인 계층들에 신경망들을 포함시켜 반복적인 방식으로 데이터로부터 학습할 수 있다. 신경망들은 신경계가 작동하는 방식의 모델들이다. 기본 유닛들은 뉴런들(neurons)로 일컬어지며, 뉴런들은 일반적으로 계층들 내에 조직화된다. 신경망은 뉴런들 의 추상적 버젼들을 닮은 매우 많은 상호 연결된 처리 유닛들을 시뮬레이션함으로써 작동한다. 신경망에는 일반 적으로 세 부분이 있다. 입력 필드들을 나타내는 유닛들을 갖는 입력 계층(input layer), 하나 또는 그 이상의 히든 계층(hidden layers), 및 목표 필드(들)을 나타내는 유닛 또는 유닛들을 갖는 출력 계층(output layer)이 그것이다. 유닛들은 다양한 연결 강도들(strengths) 또는 가중치들(weights)로 연결된다. 입력 데이터는 제1 계 층으로 제시되며, 값들은 각각의 뉴런으로부터 그 다음 계층의 각각의 뉴런으로 전파된다. 결국, 결과는 출력 계층들로부터 전달된다. 딥 러닝 복합 신경망들(deep learning complex neural networks)은 인간의 뇌가 어떻 게 작동하는지를 에뮬레이트(emulate)하도록 설계되고, 그래서 컴퓨터들은 빈약하게 정의된 추상적 개념들 (abstractions) 및 문제들을 지원하도록 훈련받을 수 있다. 신경망들 및 딥 러닝은 이미지 인식, 스피치, 및 컴 퓨터 비전 어플리케이션들에서 흔히 사용된다. 머신 러닝(ML)을 사용하여 지능적인 실시간 분석을 실행하기 위한, 툴들 및 알고리즘들을 갖는 지능 시 스템, 컴퓨터 프로그램 제품, 및 방법이 여기에 제공된다. 더 구체적으로, 그리고 여기서 보여지고 설명되는 것과 같이, ML은 마이크로-서비스 아키텍쳐에 적용되어 예컨대 클라우드 어플리케이션들을 포함하는 어플리케이션 들의 다목적 최적화를 용이하게 한다. 클라우드 어플리케이션들을 파라미터화(parameterize)하기 위해 다른 방 안들이 이용가능하며, 그러한 파라미터들의 구성은 어플리케이션들에 대한 다른 값들의 핵심 성과 지표들(KPI들)을 양산한다. 레이턴시(latency)는, 시스템 컴포넌트가 또 다른 시스템 컴포넌트가 응답하기를 기다리고 있을 때의 시 간 간격(time interval) 또는 지연(delay)을 의미하는 네트워킹 용어이다. 시간 간격의 지속시간(duration)이 레이턴시로 일컬어진다. 타임아웃(timeout)은, 어떤 입력에 대해 어떤 길이의 시간을 기다렸지만 그것을 수신하 지 못하는 프로그램 또는 디바이스에 의해 생성된 인터럽트 신호를 의미한다. 많은 프로그램들은, 그 프로그램 이 결코 도착하지 않을 수도 있는 입력을 기다리며 유휴상태(idle)로 있지 않도록 하기 위해, 타임아웃들을 수 행한다. 마이크로-서비스들의 타임아웃 및 재시도(retry) 값들을 설정하는 것은, 어플리케이션(들), 예컨대, 클 라우드 어플리케이션(들)에 대한 종단간(end-to-end) 레이턴스 및 에러율들의 분명한 값들을 양산할 수 있다. 주어진 어플리케이션이 실행되기 전에, 예컨대 그 어플리케이션에 대한 레이턴시 대(verse) 에러율과 같은 KPI 들 사이의 최선의 트레이드오프를 결정할 수 있는 것이 바람직하다. 일 실시예에서, 이들 트레이드오프들을 결 정하는 것은 주어진 어플리케이션과 연관된 서비스 수준 협약들(service level agreements, SLAs들)의 현실적인 평가를 가능하게 한다. 하나의 실시예에서, 트레이드오프의 분석은 클라우드 어플리케이션들에서 마이크로-서비 스들의 아키텍쳐 구조에 비례하여 복잡해진다. 도 1을 참조하면, 컴퓨터 시스템은 어플리케이션들의 다목적 최적화를 지원하기 위한 툴들을 포함 한다. 도시된 바와 같이, 서버는 네트워크 연결을 통해 복수의 컴퓨팅 디바이스들(180, 182, 184, 186, 188, 및 190)과 통신하도록 구성된다. 서버는 버스를 통해 메모리에 동작적으로 결합된 처 리 유닛, 예컨대, 프로세서를 갖도록 구성된다. 인공 지능(AI) 플랫폼의 형태로 된 툴은 서버에 대해 로컬로 도시되어 있고, 처리 유닛과 메모리에 동작적으로 결합된다. 도시된 바와 같이, AI 플랫 폼은 입력 매니저(input manager), 시험 매니저(trial manager), 및 최적화 매니저 (optimization manager)의 형태로 된 하나 또는 그 이상의 툴들을 포함하여, 하나 또는 그 이상의 컴퓨팅 디바이스들(180, 182, 184, 186, 188, 및 190)로부터 네트워크를 통해 어플리케이션들의 다목적 최적화를 제공 및 지원한다. 더 구체적으로는, 컴퓨팅 디바이스들(180, 182, 184, 186, 188, 및 190)은 하나 또는 그 이 상의 유선 및/또는 무선 데이터 통신 링크들을 통해 서로 간에 그리고 다른 디바이스들 또는 컴포넌트들과 통신 한다. 각각의 통신 링크는 하나 또는 그 이상의 와이어들(wires), 라우터들(routers), 스위치들(switches), 송 신기들(transmitters), 수신기들(receivers) 등을 포함할 수 있다. 이렇게 네트워킹된 구성에서, 서버 및 네트워크 연결은 분산된 리소스들을 통해 클라우드 어플리케이션의 최적화를 가능하게 할 수 있다. 서버 의 다른 실시예들은 컴포넌트들, 시스템들, 서브-시스템들, 및/또는 여기에 설명되는 디바이스들 이외의 다른 디바이스들과 함께 사용될 수 있다. AI 플랫폼은 클라우드 어플리케이션 최적화를 용이하게 하고 가능하게 하기 위해, ML, 더 구체적으 로는, 획득 함수와 함께 ML 기반 대리 함수 러닝 모델을 지원하는 툴들을 갖도록 구성되는 것으로 여기서는 도 시되어 있다. 입력 매니저, 시험 매니저, 및 최적화 매니저를 포함하는 여기에 내포된 툴들은, 예컨대, 네트워크, 및 동작적으로 결합된 지식 기반(knowledge base)으로부터의 입력(이러한 예로 한 정되는 것은 아님)과 같은 여러 가지 소스들로부터의 입력을 수신하도록 구성된다. 일 실시예에서, 지식 기반 은 복수의 어플리케이션들을 갖는 라이브러리로 구성되며, 복수의 어플리케이션들은 여기서는 예시로 서 어플리케이션A(164A), 어플리케이션B(164B), 및 어플리케이션N(164N)으로 도시되어 있다. 비록 단지 세 개의 어플리케이션들만이 도시되어 있지만, 이는 예시하기 위한 목적이지 그 개수를 한정하려는 것으로 간주되어서는 아니된다. 일 실시예에서, 지식 기반은 하나 또는 그 이상의 추가 라이브러리들을 갖도록 구성될 수 있으 며, 추가 라이브러리들 각각은 하나 또는 그 이상의 어플리케이션들을 갖는다. 구조 또는 라이브러리에서 어플리케이션들의 양은 예시하기 위한 목적이지 그것을 한정하려는 것으로 간주되어서는 아니된다. 각각의 어플리케이션은 여기서는 머신 러닝(ML) 대리 함수를 갖도록 도시되며, 이는 여기서 ML 모델로 일컬어진다. 어플리케이션A(164A)는 ML 모델A(166A)를 갖는 것으로 도시되며, 어플리케이션B(164B)는 ML 모델 B(166B)를 갖는 것으로 도시되며, 어플리케이션N(164N)은 ML 모델N(166N)을 갖는 것으로 도시된다. 각각의 ML 모 델은 여기서는 대응되는 모델 맵을 갖도록 도시된다. 모델 맵은 여기서는 맵으로도 일컬어진다. 설명 목적으로, ML 모델A(166A)는 대응되는 모델 맵A(170A)을 갖는 것으로 도시되며, ML 모델B(166B)는 대응되는 모델 맵B(170B)을 갖는 것으로 도시되고, ML 모델N(166N)은 대응되는 모델 맵N(170N)을 갖는 것으로 도시되어 있다. 더 나아가, 각각의 기존의 어플리케이션은 또한 대응되는 획득 함수를 가질 수도 있는데, 이는 샘플링, 그리고 더 구체적으로 는 생성될 값을 측정하는 것을 목표로 한다. 어플리케이션A(164A)는 획득 함수A(168A)를 갖는 것으로 도시되고, 어플리케이션B(164B)는 획득 함수B(168B)를 갖는 것으로 도시되고, 어플리케이션N(164N)은 획득 함수N(168N)을 갖 는 것으로 도시되어 있다. ML 대리 함수, 대응되는 모델 맵, 및 획득 함수가 어떻게 이용되는가에 관한 상세내 용은 이하에서 더 상세히 보여지고 설명된다. 통신망과 통신하는 다양한 컴퓨팅 디바이스들(180, 182, 184, 186, 188, 및 190)은 AI 플랫폼 에 대한 접근점들(access points)을 보여준다. 툴들(152, 154, 및 156)은 어플리케이션들의 다목적 최적화 를 지원 및 가능하게 한다. 네트워크는 다양한 실시예들에서 로컬 네트워크 연결들 및 원격 연결들을 포함 할 수 있어, AI 플랫폼 및 내장된 툴들(152, 154, 및 156)은 로컬 및 글로벌, 예컨대, 인터넷을 포함하는 어떤 크기의 환경들에서 동작할 수 있도록 한다. 따라서, 서버 및 AI 플랫폼은 프론트-엔드 시스템 (front-end system)으로서의 역할을 하는 한편, 지식 기반 및 어플리케이션들(164A - 164N)은 백-엔드 시 스템(back-end system)으로서의 역할을 한다. 이하에서 상세히 설명되는 바와 같이, AI 플랫폼은 어플리케이션들의 성과(performance)를 최적화 하는데, 여기서 어플리케이션은, 확인된 핵심 성과 지표들(KPI들)과 관련하여, 마이크로-서비스들의 집합이다. AI 플랫폼은 입력 매니저를 이용하여 어플리케이션과 연관된 두 개 또는 그 이상의 KPI들의 세트를 수신한다. KPI들은 최적화의 대상인 어플리케이션의 성과 측면들(performance aspects)을 가리킨다. 일 실시예 에서, KPI들의 카테고리는 사용자에 의해 선택되고 사용자가 최적화하는 것에 관심이 있는 성과 측면들과 관계 가 있다. 수신된 KPI들의 세트에서 각각의 KPI는 연관되거나 대응되는 지표(indicator) 유형을 갖는다. 가능한 KPI 유형들의 예들은 양적 지표들(quantitative indicators) 및 질적 지표들(qualitative indicators)를 포함 한다. 양적 지표는 양(quantity)을 가리키는데, 일 실시예에서 수(number), 인덱스, 비율, 퍼센티지 등일 수 있 다. 질적 지표들은 수적인 측정들을 보여주지 않고, 오히려 품질에 있어서의 상황(status)을 나타낸다. 어플리 케이션 성과를 측정하는 양적 측정들의 유형들의 예들은, 레이턴시(latency), 에러율(error rate), 및 처리율 (throughput)을 포함하나, 이러한 예로 한정되는 것은 아니다. 각각의 양적 지표는 하나 또는 그 이상의 대응되 는 값들을 갖는다. 서비스들의 집합, 예컨대, 마이크로-서비스들로서의 어플리케이션과 관련하여 당해 기술 분야에서 이러 한 서비스들이 선형으로 배열되지 않을 수 있다는 것은 이해된다. 오히려, 마이크로-서비스들이 종속성들 (dependencies)을 포함할 수 있고, 그와 같은 마이크로-서비스들이 그러한 종속성들을 반영하기 위해 계층구조 적 배열(hierarchical arrangement)을 가지고 있다는 것이 이해된다. KPI들에 더하여, 입력 매니저는 또 한 어플리케이션과 연관되는 하나 또는 그 이상의 파라미터들을 수신한다. 파라미터들 각각은 파라미터 값과 연 관된다. 가능한 파라미터 값들의 예들은, 타임아웃(timeout), 재시도(retry), 및 복제 카운트(replication count)를 포함하며, 이들은 계층구조적 배열, 예컨대, 계층구조(hierarchy)에 대응되는 하나 또는 그 이상의 위 상적 제약들(topological constraints)과 연관된다. 파라미터 값들의 예들은 위에서 열거된 예들로 한정되는 것 은 아니다. 계층구조(hierarchy)는 항목들이 계층화되거나 그룹핑되어 복잡성을 감소시키는 조직화 기법이라는 것은 당해 기술 분야에서 이해된다. 마이크로-서비스들의 계층구조적 배열들의 예들은 도 6 - 8에 도시되고 설 명된다. 조정가능한 파라미터(들)은 마이크로-서비스들의 계층구조에 대하여 설정되어, 자 마이크로-서비스 (child micro-service)로부터의 쿼리(query)가 액티브 상태(active)인 한, 부모 마이크로-서비스(parent micro-service)로부터의 그 어떤 쿼리들이든 액티브 상태임을 파라미터 값(들)이 보증하도록 보장한다. 시험 매니저는 여기서는 입력 매니저에 동작적으로 결합하는 것으로 도시되며, 시험 매니저 는 AI 플랫폼 내에서 동적 리소스 상태를 모니터링하도록 기능한다. 더 구체적으로는, 시험 매니저 는 어플리케이션의 하나 또는 그 이상의 적응적 시험들을 수행하기 위해 획득 함수와 함께 ML 기반 대리 함수 러닝 모델을 활용한다. 지식 기반에서 보여지는 것과 같이, 각각의 어플리케이션은 대응되는 대리 함 수 및 획득 함수를 갖는다. 각각의 시험은 파라미터(들) 세팅(들)에 기초한 어플리케이션의 특정 설정 (configuration)을 목표로 한다. 시험 매니저는 획득 함수A(168A)를 활용하여 어플리케이션A(164A)의 적응 적 시험 실행을 위한 하나 또는 그 이상의 파라미터들의 설정을 선택한다. 적응적 시험의 결과들은 파라미터(들)의 특정 설정과 연관된 어플리케이션의 성능 지표 값들, 예컨대, KPI들을 제공한다. 또한, 시험 매 니저는 ML 대리 함수를 활용하여 연관된 ML 모델에서 KPI 값들을 캡쳐한다. ML 기반 대리 함수 러닝 모델 은 신경망, 가우시안 프로그레스 회귀(Gaussian Progress regression) 또는 다른 선형, 또는 비선형 또는 커널 회귀 기법들(kernel regression techniques), 또는 블랙박스 최적화 또는 강제 러닝에 사용되는 다른 밸류 추정기법들(value extimation techniques)을 사용하여 구현될 수 있다. 따라서, ML 모델은 하나 또는 그 이상의 파 라미터들의 각각의 설정을 두 개 또는 그 이상의 대응되는 KPI 값들에 맵핑한다. 어플리케이션에 관한 다수의 시험들은 파라미터 값 세팅을 통해 수행될 수 있다. 획득 함수, 즉 획득 함 수A(168A)는 하나 또는 그 이상의 파라미터 값들의 새로운 설정과 또 다른 적응적 시험을 선택하고, 대응되는 KPI 값들이 측정된다. 획득 함수는 예상 향상 함수(expected improvement function), 향상 함수의 최대 확률 (maximum probability of improvement function), 또는 신뢰 상한 함수(upper confidence bound function), 또는 블랙박스 최적화 또는 강제 러닝에 사용되는 다른 동작 추정 기법들로 구현될 수 있다. 시험 매니저 는 각각의 시험으로부터 KPI 값들을 사용하고 어플리케이션의 파레토 표면(areto surface)을 컴퓨팅한다. 파레 토 표면은, 적응적 시험에 이용된 파라미터 값들의 설정들에 기초하여달성될 수 있는 가능한 KPI 값들 전부를 그래픽적으로 보여준다. 따라서, 시험 매니저는, ML 대리 함수 러닝 모델와 획득 함수를 활용하여 조정가 능한 파라미터들의 선택된 설정들에 기초하여 어플리케이션의 적응적 시험들을 실행하고, 그 시험들로부터의 KPI 값들을 사용하여 대응되는 파레토 표면을 컴퓨팅한다. 최적화 매니저는 여기서는 입력 매니저와 시험 매니저에 동작적으로 결합된 것으로 보여 지는데, 최적화 매니저는 시험 매니저에 의해 컴퓨팅된 파레토 표면을 탐구하여 어플리케이션의 최적 의 동작점을 찾아내고, 선택된 동작점에서 그 어플리케이션을 실행하도록 기능한다. 최적화 매니저는 컴퓨 팅된 파레토 표면을 탐구하고 이 탐구로부터 어플리케이션에 대한 최적의 동작점- 이는 또한 여기서는 동작점으 로로 일컬어짐 - 을 선택한다. 일 실시예에서, 선택된 동작점은 KPI 값들에서의 트레이드 오프를 나타내는데, 여기서 선택된 동작점은 첫 번째에 대해 더 높은 값, 더 바람직한 KPI를 가질 수 있고, 두 번째에 대해 더 낮은 값, 덜 바람직한 KPI를 가질 수 있다. 일 실시예에서, 사용자에 의해 동작점이 선택될 수 있다. 최적화 매니저 는 선택된 동작점을 사용하여 어플리케이션을 실행한다. 선택된 동작점을 사용함으로써, 어플리케이션은 사용자에 의해 특정된 원하는 KPI 값들로 실행한다. 따라서, 최적화 매니저는 컴퓨팅된 파레토 표면을 탐 구하고 어플리케이션에 대한 최적의 동작점을 선택하고, 그런 다음 선택된 동작점을 사용하여 그 어플리케이션 을 실행한다. 도면에서는 서버에 구현된 것 또는 서버와 통합된 것으로 도시되었지만, AI 플랫폼은 서 버에 네트워크를 통해 연결되는 별도의 컴퓨팅 시스템(예컨대, 190)에 구현될 수 있다. 비록 서버 에 대해 로컬로 도시되었으나, 툴들(152, 154, 및 156)은 네트워크에 집합적으로 또는 개별적으로 분 산되어 있을 수 있다. 어디에 구현되든, 입력 매니저, 시험 매니저, 및 최적화 매니저는 어플리 케이션들의 다목적 최적화를 관리하고 지원하는데 이용된다. 어플리케이션들은 네트워크를 통해 서버에 통신될 수 있다. 예를 들어, 일 실시예에서, 하나 또는 그 이상의 어플리케이션들은 비휘발성 데이터 스토어(190A)로부터 서버에 통신될 수 있다. 지식 기반 으로부터든 통신망을 통해서든, 툴들(152, 154, 및 156)은 어플리케이션들을 처리한다. 서버를 이용할 수 있는 정보 핸들링 시스템들의 유형들은, 예컨대, 핸드헬드 컴퓨터/모바일 전화기 과 같은 소형의 핸드헬드 디바이스들에서부터, 메인프레임 컴퓨터와 같은 대형의 메인프레임 시스템 들까지 다양하다. 핸드헬드 컴퓨터의 예들은, 개인용 디지털 보조기기(personal digital assistants, PDAs), 개인용 엔터테인먼트 디바이스(personal entertainment devices) - 예컨대, MP4 플레이어 -, 휴대용 텔 레비젼, 및 컴팩트 디스크 플레이어를 포함한다. 정보 핸들링 시스템들의 다른 예들은 펜 또는 태블릿 컴퓨터 , 랩탑 또는 노트북 컴퓨터, 개인용 컴퓨터 시스템 및 서버를 포함한다. 도시된 바와 같이, 컴퓨터 네트워크를 사용하여 다양한 정보 핸들링 시스템들이 함께 네트워킹될 수 있다. 다양한 정보 핸들링 시스템들을 상호 연결하는데 사용될 수 있는 컴퓨터 네트워크의 유형들은 근거리 통신망(Local Area Networks, LANs), 무선 근거리 통시망(Wireless Local Area Networks, WLANs), 인터넷, 공중 교환 전화 통신망(Public Switched Telephone Network, PST), 다른 무선 통신망, 및 정보 핸들링 시스템들을 상호연결하 는데 사용될 수 있는 다른 어떤 네트워크 토폴로지를 포함한다. 정보 핸들링 시스템들 중 많은 것들은 하드 디 스크들 및/또는 비휘발성 메모리와 같은 비휘발성 데이터 스토어들을 포함한다. 정보 핸들링 시스템들 중 일부 는 별도의 비휘발성 데이터 스토어들을 사용할 수 있다(예컨대, 서버는 비휘발성 데이터 스토어(190A)를 이용하고, 메인프레임 컴퓨터는 비휘발성 데이터 스토어(182A)를 이용한다). 비휘발성 데이터 스토어(182 A)는 다양한 정보 핸들링 시스템들의 외부에 있는 컴포넌트일 수 있고 또는 정보 핸들링 시스템들 중 하나의 내 부에 있을 수 있다. 정보 핸들링 시스템은 여러 가지 형태들을 취할 수 있는데, 이들 중 일부가 도 1에 도시되어 있다. 예를 들어, 정보 핸들링 시스템은 데스크탑, 서버, 휴대용, 랩탑, 노트북, 또는 다른 폼팩터 컴퓨터 또는 데이터 처 리 시스템의 형태를 취할 수 있다. 또한, 정보 핸들링 시스템은 개인용 디지털 보조기기(PDA), 게이밍 디바이스, ATM 머신, 휴대용 전화 디바이스, 통신 디바이스 또는 프로세서와 메모리를 포함하는 다른 디바이스 들과 같은 다른 폼팩터들을 취할 수 있다. 어플리케이션 프로그램 인터페이스(Application Program Interface, API)는 두 개 또는 그 이상의 어플 리케이션들 사이에서 소프트웨어 중개자(intermediary)로 당해 기술 분야에서 이해된다. 도 1에 도시되고 설명 된 어플리케이션 최적화 시스템에 관하여, 하나 또는 그 이상의 API들이 하나 또는 그 이상의 AI 플랫폼 툴들을 지원하는데 이용될 수 있다. AI 플랫폼 툴들은 입력 매니저, 시험 매니저, 및 최적화 매니저, 및 그들의 연관된 기능을 포함한다. 도 2를 참조하면, AI 플랫폼 툴들과 그들의 연관된 API들을 나타내는 블록 다이어그램이 제공된다. 도시된 바와 같이, AI 플랫폼 내에 복수의 툴들이 포함되는데, 이 툴들은 API0과 연관된 입력 매니저, API1과 연관된 시험 매니저, 및 API2와 연관된 최적화 매니저를 포함한다. API들 각각은 하나 또는 그 이상의 언어들과 인터페이스 사양들로 구현될 수 있다. API0은 선택된 KPI들의 수신 및 관리 그리고 조정가능한 파라미터들에 대한 지원을 제공하고; API1은 하나 또는 그 이상의 적응적 어플리케이션 시험들을 수행하고, 시험들로부터 관찰된 KPI들을 사용하여 대응되는 파레토 표면을 컴퓨팅하는 것에 대한 지원을 제공하며; API2는, 최적의 어플리케이션 동작점의 선택 및 그 선택된 동작점에서 어플리케이션의 실행을 포함하여, 파레토 표면을 탐구하기 위한 지원을 제공한다. 도시된 바 와 같이, API들(212, 222, 및 232) 각각은 API 조정기(오케스트레이터, orchestrator)에 동작적으로 결합 된다. API 조정기는, 다르게는 조정 계층(orchestration layer)으로 알려져 있으며, 별도의 APIs를 명료 하게 함께 연결하는 추상화 계층으로 기능한다는 것은 당해 기술 분야에서 이해된다. 일 실시예에서, 별도의 API들의 기능은 합쳐지거나 결합될 수 있다. 이와 같이, 여기에 도시된 API들의 구성은 본 발명의 범위를 그러 한 것으로 한정하는 것으로 간주되어서는 아니된다. 따라서, 여기에 도시된 바와 같이, 툴들의 기능은 그들 각 각의 API들에 의해 구현 또는 지원될 수 있다. 도 3을 참조하면, 어플리케이션의 다목적 최적화를 위한 프로세스를 나타내는 플로우 챠트가 제공 된다. 도시되고 설명된 바와 같이, 사용자는 어플리케이션에 관해 관심있는 두 개 또는 그 이상의 핵심 성 과 지표들(KPI들)을 입력하는데, 하나의 실시예에서, 상기 어플리케이션은 클라우드 기반 어플리케이션일 수 있다. 일 실시예에서, KPI는, 프로세스 또는 프로젝트가 어떤 예상들 및 목표들을 얼마나 잘 충족하는지를 측정 및 추정하는 측정기준(metric)이다. KPI들은 클라우드 어플리케이션들 내에 포함되어 그 클라우드 어플리 케이션의 형태 및 기능에서의 예상 방향을 모니터링 및 확인할 수 있다. 다음 단계에서, 어플리케이션과 연관된 하나 또는 그 이상의 파라미터들이 수신된다. 단계 304에서 수신된 파라미터들은 조정가능한 파라 미터들이고. 일 실시예에서 그 수신된 파라미터들은 컨트롤가능하며, 단계 302에서 입력된 KPI들에 영향을 미친 다. 수신된 파라미터들의 예들은, 타임아웃, 재시도, 복제 카운트를 포함하며, 이들은 어플리케이션의 하나 또 는 그 이상의 위상적 제약들과 연관된다. 상기 수신된 파라미터들의 예들은 위와 같은 예들로 한정되는 것은 아 니다. 따라서, 관심있는 KPI들 및 어플리케이션과 연관된 파라미터들이 수신된다. 도 1에 설명된 것과 같이, 그리고 도 6 - 8에 도시되고 설명된 것과 같이, 어플리케이션은 마이크로-서 비스들의 위상적 배열(topological arrangement)로 구성되는데, 일 실시예에서 어플리케이션은 마이크로-서비스 들의 계층구조적 배열(hierarchical arrangement)을 포함한다. 계층구조적 배열은 그 계층구조에서 표현된 위상 (topology)에 대한 고유의 제약들을 갖는다. 단계 304에서 수신된 파라미터들은 위상에 반응하며, 일 실시예에 서, 파라미터 값(들)이 자(child), 예컨대, 종속(dependent), 마이크로 서비스로부터의 쿼리가 액티브 상태인 한 부모 마이크로-서비스로부터의 쿼리들이 액티브 상태임을 파라미터 값(들)이 보증하도록 보장하는 어플리케 이션을 포함하는 마이크로-서비스들의 계층구조에 대하여 조정되거나 설정된다. 단계 306에서 파라미터(들)의 수신 후에, 어플리케이션과 연관된 ML 기반 대리 함수는 대응되는 획득 함수와 함께 활용되어 하나 또는 그 이 상의 적응적 어플리케이션 퍼포먼스 시험들을 수행하여, 단계 302에서 지정된 지표들의 카테고리에 대응되는 KPI 값들을 측정한다. 측정된 KPI 값들은 단계 304에서 수신된 파라미터 값들의 설정들에 기초하여 달성될 수 있는 가능한 KPI 값들에 대응된다. 도 4를 참조하면, 어플리케이션 적응적 시험들을 수행하기 위해 ML을 활용하기 위한 프로세스를 설명하 는 플로우 챠트이 제공된다. 도시된 바와 같이, 획득 함수가 활용되고 하나 또는 그 이상의 조정가능한 파 라미터들, 예컨대, 단계 304에서 수신된 조정가능한 파라미터들의 설정이 선택된다. 일 실시예에서, 단계402에서의 선택은 이전에 이용되지 않았던 파라미터들을 그 대상으로 한다. 어플리케이션의 시험은 선택된 어플 리케이션 파라미터(들)로 수행된다. 시험으로부터의 출력이 KPI 값들의 형태로 관찰되고, 그래서 ML 모델 이 파라미터 변경 및 관찰된 출력으로 업데이트된다. 파라미터 선택 및 KPI 측정에 관한 이러한 프로세스는 미 리 정해진 시간 또는 정의된 양의 시험들 동안 계속될 것이다. 일 실시예에서, 시간 또는 양 한도는 설정가능하 다. 예를 들어, 일 실시예에서, 파라미터 설정 시험들(parameter configuration trials)이 시간, 예컨대, 30분 동안 평가되도록 설정될 수 있다. 따라서, ML 대리 함수 및 획득 함수가 활용되어 하나 또는 그 이상의 파라미 터들의 상이한 설정들에서 KPI들과 연관된 양적 출력을 결정한다. 어플리케이션의 각각의 시험은 관심 KPI들과 연관된 양적 성과 값을 생성한다. 도 4에 도시된 적응적 시 험들이 끝난 후에, 프로세스는 단계 308로 리턴하며, 여기서 KPI 값들의 관찰된 양적 출력이 이용되어 파레토 표면을 컴퓨팅한다. 파레토 효율(pareto efficiency)은 적어도 하나의 개별 또는 선호 기준을 더 나쁘게 만들지 않고서는 어떤 하나의 개별 또는 선호 기준을 더 좋게 만들 수 있도록 변경될 수 없는 상황이다. 파레토 프론트 (pareto front), 또는 파레토 표면(pareto surface)은 모든 파레토 효율적 할당들(pareto efficient allocations)의 세트이며, 이는 전통적으로 그래픽으로 보여진다. 단계 308에서 생성된 파레토 표면은 제공된, 그리고 하나의 실시예에서 조정가능한, 파라미터(들)에 기초하여 달성될 수 있는 어플리케이션 시험들로부터 측 정된 가능한 양적 KPI 값들의 모두를 보여준다. 생성된 파레토 표면은 어플리케이션에 대한 최적의 동작점 을 확인하기 위한 탐구의 대상이 된다. 그런 다음, 어플리케이션은 그 확인된 최적의 어플리케이션 동작점(31 2)을 사용하여 실행하는 대상이 된다. 따라서, 여기에 도시된 바와 같이, 어플리케이션 파라미터들은 어플리케 이션 마이크로-서비스들의 위상적 배열에 기초하여 선택되거나 조정되고, ML은 어플리케이션 파라미터들을 활용 하여 적응적 어플리케이션 시험들을 수행하고 대응되는 파레토 표면을 컴퓨팅하며, 대응되는 파레토 표면이 탐 구되어 최적의 동작점을 확인하고 최적의 동작점에서 어플리케이션을 실행한다. 도 5를 참조하면, 레이턴스와 에러율 목표들의 KPI들을 위한 파레토 표면의 그래프 및 일 예를 나타내는 도면이 제공된다. 도시된 바와 같이, 레이턴시와 에러율의 두 개의 KPI들을 나타내는 그래프가 보여 진다. 그래프는 제1 축 상에 측정된 레이턴시 지표, 그리고 제2 축 상에 측정된 에러율 지표가 보여진다. 어플리케이션 시험들은 선택된 파라미터(들)로 수행되고 지표들과 연관된 양적 값들이 측정되며, 이 들 측정들이 그래프에 나타나 있다. 각각의 측정은 그래프에 엔트리(entry)로 반영되어 있다. 복수의 KPI 측정들은 시험들로부터 그래프에 엔트리들로 보여지고, 엔트리들의 선택된 서브세트를 표현하기 위해 파레토 표면이 생성된다. 각각의 그래픽적인 엔트리는, 제공된 조정가능한 파라미터들(도시되지 않음)에 기초하여, 선택된 KPI들 - 이 예에서 레이턴시와 에러율임 - 의 값들을 나타낸다. 파레토 표면 상의 어떤 점은, 대응되고 알려진(또는 확인가능한) KPI 값들을 갖는 어플리케이션의 가능한 동작점이다. 예를 들어, 동작점 A와 동작점B와 같이 두 개의 가능한 또는 최적의 동작점들이 파레토 표면 상에 보여진다. 동작점 A는 레이턴시에 관하여 표면 상에 어플리케이션의 최적을 동작점을 표현하고, 동작점B는 에러율 에 관하여 표면 상에 어플리케이션의 최적의 동작점을 표현한다. 파레토 표면을 따라 동작점을 선택 하는 것은 어플리케이션을 실행하기 이전의 어플리케이션 성과 지표들을 지시한다. 도 5에 도시된 그래프는 두 개의 KPI들에 대응되는 2차원 파레토 표면이다. 일 실시예에서, 파레토 표면 은 더 많은 양의 KPI들을 표현할 수 있다는 것이 이해된다. 예를 들어, 세 개의 KPI들의 경우, 파레토 표면은 3 차원 표면이 될 것이다. 따라서, 도 5에 도시된 파레토 표면은 단지 어플리케이션 시험들로부터의 파레토 표면 의 일 예일 뿐이다. 앞서 도 1에서 설명된 바와 같이, 마이크로-서비스들은 계층구조적 배열을 가질 수 있다. 조정가능한 파 라미터(들)은, 자 마이크로-서비스로부터의 쿼리가 액티브 상태인 한, 부모 마이크로-서비스로부터의 그 어떤 쿼리들이든 액티브 상태임을 파라미터 값(들)이 보증하도록 보장하는 마이크로-서비스들의 계층구조에 관해 세 팅된다. 도 6을 참조하면, 상호작용하는 마이크로-서비스들의 계층구조의 일 예를 나타내는 블록 다이어그램 이 제공된다. 게이트웨이는 마이크로-서비스들의 계층구조와 통신하는 것으로 도시되어 있다. 계층구 조에 도시된 위상(topology)은 세 개의 티어들(tiers)을 포함한다. 세 개의 티어들은 여기에 도시된 것과 같이 티어0(tier0), 티어1(tier1), 및 티어2(tier2)이다. 일 실시예에서, 티어0(tier0)은 부모 계 층(parent layer)이고, 티어1(tier1)는 자 계층(child layer)이고, 티어2(tier2)은 손자 계층(grand- child layer)이다. 티어0(tier0)은 단일 마이크로-서비스, 예컨대, 마이크로-서비스0.0으로 도시된다. 일 실시예에서, 마이크로-서비스0.0는 부모 마이크로-서비스로 일컬어지며, 이는 자 마이크로-서비스로부터의 쿼리가 액티브 상태인 한 액티브 상태로 유지될 것이다. 마이크로-서비스1.0와 마이크로-서비스1.1 은 계층구조에서 자 티어(child tier), 예컨대, 티어1(tier1)에 도시된다. 마이크로-서비스1.0와 마이 크로-서비스1.1는 자 마이크로-서비스들로 일컬어지며, 각각 별도로 부모 마이크로 서비스0.0에 관련되 어 있으며 부모 마이크로-서비스0.0에 종속적이다. 마이크로-서비스는 계층구조에서 부모 마이크로-서비스 와 자 마이크로-서비스 둘 다 될 수 있다. 도시된 바와 같이, 마이크로-서비스1.1는 마이크로-서비스 0.0에 종속적이면서 또한 티어2(tier2)에서 마이크로-서비스2.0에 대해 부모이다. 여기에 도시된 계층구조 및 배열에 기초하여, 마이크로-서비스1.1은 마이크로-서비스2.0로부터의 쿼리가 액티브 상태 인 한 단지 액티브 상태로 유지될 것이다. 따라서, 여기에 도시된 마이크로-서비스들의 계층구조적 배열은 마이 크로-서비스들 사이에서 종속적인 관계들의 일 예를 나타낸다. 도 7은 순차적 쿼리 제한(sequential query constraint)을 갖는 어플리케이션 마이크로-서비스들의 계 층구조의 일 예를 도시한 블록 다이어그램이다. 게이트웨이는 마이크로-서비스들의 계층구조와 통신 하는 것으로 도시되어 있다. 계층구조에서 보여지는 위상(topology)은 두 개의 티어들(tiers)을 포함하는데, 여 기서는 티어0(tier0)과 티어1(tier1)로 도시되어 있다. 일 실시예에서, 티어0(tier0)은, 독립 계 층으로도 일컬어지는 부모 계층(parent layer)이고, 티어1(tier1)은 종속 계층으로도 일컬어지는 자 계층 (child layer)이다. 티어0(tier0)는 부모 마이크로-서비스, 마이크로-서비스0.0로도 일컬어지는, 단일 마이크로-서비스를 갖는 것으로 도시되어 있다. 티어1(tier1)은 마이크로-서비스1.0과 마이크로-서비스 1.1을 포함하는 두 개의 자 마이크로-서비스들을 갖는 것으로 도시되어 있다. 각각의 자 마이크로-서비스 (722와 732)는 별도이며 부모 마이크로-서비스에 직접적으로 관련된다. 부모 마이크로-서비스0.0는 타 임아웃 파라미터, y0를 갖도록 구성된다. 이와 유사하게, 자 마이크로-서비스들(722, 732) 각각은 대응되 는 타임아웃 파라미터와 재시도 파라미터를 갖도록 구성된다. 도시된 바와 같이, 마이크로-서비스1.0은 타 임아웃 파라미터, y2와 재시도 파라미터, z2를 갖는 것으로 도시되며, 마이크로-서비스1.1는 타임 아웃 파라미터, y3와 재시도 파라미터, z3을 갖는 것으로 도시되어 있다. 여기에 도시된 계층구조에 대한 위상적 제약은 방정식 y1≥y2z2 + y3z3 에 따라 보여지는 순차적 쿼리 시나리오이다. 이러한 순차적 쿼리 시 나리오 하에서, 자 마이크로-서비스1.0과 자 마이크로-서비스1.1 중 하나가 액티브 상태일 때, 부모 마 이크로-서비스0.0은 타임아웃되어서는 안된다. 도 8은 병렬 쿼리 제한(parallel query constraint)를 갖는 어플리케이션 마이크로-서비스들의 계층구조 의 일 예를 도시한 블록 다이어그램이다. 게이트웨이는 마이크로-서비스들의 계층구조, 마이크로-서 비스들의 두 개의 티어들을 포함하는 계층구조와 통신하는 것으로 도시되어 있다. 부모 마이크로-서비스인 마이 크로-서비스0.0는 제1 티어(first tier), 예컨대, 티어0(tier0)에서 보여지고, 게이트웨이와 제2 티어(second tier)로 표현된 마이크로-서비스들 사이에서 인터페이스한다. 제2 티어는 예컨대, 티어 1(tier1)이고, 자 티어(child tier)로도 일컬어진다. 티어1(tier1)은 두 개의 자 마이크로-서비스들을 갖는 것으로 도시되어 있는데, 각각은 부모 마이크로-서비스0.0에 직접적으로 그리고 별도로 대응된다. 자 마이 크로-서비스1.0는 부모 마이크로-서비스0.0에 직접적으로 관련되고, 자 마이크로-서비스1.1는 부모 마이크로-서비스0.0에 직접적으로 관련된다. 부모 마이크로-서비스0.0는 타임아웃 파라미터 y1를 갖도록 구성된다. 이와 유사하게, 자 마이크로-서비스1.0는 y2인 타임아웃 파라미터와 재시도 파라미 터 z2를 갖도록 구성되고, 마이크로-서비스1.1는 타임아웃 파라미터 y3와 재시도 파라미터 z3을 갖도록 구성된다. 여기에 도시된 계층구조에 대한 위상적 제약은 방정식 y1 ≥ max{y2z2, y3z3}로 보여 지는 병렬 쿼리 시나리오이다. 이러한 병렬 쿼리 시나리오 하에서, 자 마이크로-서비스1.0과 자 마이크로- 서비스1.1 중 하나가 액티브 상태일 때, 마이크로-서비스0.0는 타임아웃되어서는 안된다. 도 6, 7 및 8에 도시되고 설명된 계층구조적 배열들 및 대응되는 순차적 쿼리 시나리오 및 병렬 쿼리 시 나리오는 설명 목적으로 예를 든 것이고 본 발명의 범위를 한정하는 것으로 간주되어서는 아니된다. 더 구체적으로는, 여기에 도시된 계층구조 배열들은 배열에 반응을 보이는 위상적 제약들의 예들을 그 대상으로 한다. 일 실시예에서, 마이크로-서비스들의 양, 위상적 배열, 및 쿼리 시나리오들은 더 복잡해질 수 있다. 여기에 도시되고 설명되는 실시예들은 클라우드 어플리케이션의 다목적 최적화를 조정(orchestrate)하는 것을 목표로 하는 머신 러닝을 제공하기 위해 AI 플랫폼에서 사용하기 위한 컴퓨터 시스템의 형태일 수 있다. 툴들(152, 154, 및 156)과 그들의 연관된 기능의 측면들은 단일 위치에서 컴퓨터 시스템/서버에 구현될 수도 있 고, 또는 일 실시예에서, 클라우드 기반 시스템 공유 컴퓨팅 리소스들에서 구성될 수도 있다. 도 9를 참조하면, 컴퓨터 시스템/서버의 일 예를 나타내는 블록 다이어그램이 제공된다. 컴퓨터 시스템/서버는 이 후에 호스트로 언급되며, 이는 도 1 - 8에 관해 위에서 설명된 시스템 및 프로세스들을 구현하기 위해, 클 라우드 기반 지원 시스템과 통신한다. 호스트는 수많은 다른 범용 또는 전용 컴퓨팅 시스템 환경들 또는 구성들에서 동작한다. 호스트와 함께 사용하기에 적합할 수 있는 잘 알려진 컴퓨팅 시스템들, 환경들, 및/ 또는 구성들의 예들은, 개인용 컴퓨터 시스템들, 서버 컴퓨터 시스템들, 신 클라이언트들(thin clients), 시크 클라이언트들(thick clients), 핸드-헬드 또는 랩탑 디바이스들, 멀티프로세서 시스템들, 마이크로프로세서 기 반 시스템들, 셋탑 박스들, 프로그램가능 커스터머 전자장치들(programmable consumer electronics), 네트워크 PC들, 미니컴퓨터 시스템들, 메인프레임 컴퓨터 시스템들, 및 파일 시스템들(예컨대, 분산된 스토리지 환경들 및 분산된 클라우드 컴퓨팅 환경들)을 포함하며, 이들은 위와 같은 시스템들, 디바이스들, 및 그들의 균등물들 중 어떤 것을 포함한다. 그리고, 상기 예들로 한정되는 것은 아니다. 호스트는 컴퓨터 시스템에 의해 실행되는 프로그램 모듈들과 같은 컴퓨터 시스템-실행가능 명령들 의 일반적인 맥락에서 설명될 수 있다. 일반적으로, 프로그램 모듈들은 루틴들, 프로그램들, 객체들, 컴포넌트 들, 로직, 데이터 구조들 등을 포함할 수 있는데, 이것들은 특정 태스크들을 수행하거나 특정 추상적 데이터 유 형들을 구현한다. 호스트는 분산된 클라우드 컴퓨팅 환경들에서 실시될 수 있으며, 분산된 클라우드 컴퓨팅 환경들에서 태스크들은 통신망을 통해 링크된 원격 처리 디바이스들에 의해 수행된다. 분산된 클라 우드 컴퓨팅 환경에서, 프로그램 모듈들은 메모리 스토리지 디바이스들을 포함하는 로컬 컴퓨터 시스템 스토리 지 매체와 원격 컴퓨터 시스템 스토리지 매체 둘 다에 위치할 수 있다. 도 9에 도시된 바와 같이, 호스트는 범용 컴퓨팅 디바이스의 형태로 도시되어 있다. 호스트의 컴포넌트들은, 하나 또는 그 이상의 프로세서들 또는 처리 유닛들, 시스템 메모리, 및 버스를 포함할 수 있으나 이러한 예들로 한정되는 것은 아니다. 버스는 시스템 메모리를 포함하는 다양한 시 스템 컴포넌트들을 프로세서에 결합시킨다. 버스는, 메모리 버스 또는 메모리 컨트롤러, 주변 버스, 가속 그래픽스 포트(accelerated graphics port), 및 프로세서 또는 로컬 버스 - 이것들은 다양한 버스 아키텍 쳐들 중 어떤 것을 사용함 - 를 포함하는 몇 가지 유형의 어떤 버스 구조들 중 하나 또는 그 이상을 나타낸다. 예로서 이러한 아키텍쳐들은 산업 표준 아키텍쳐(Industry Standard Architecture, ISA) 버스, 마이크로 채널 아키텍쳐(Micro Channel Architecture, MCA) 버스, 향상된(Enhanced) ISA(EISA) 버스, 비디오 전자 표준 협회 (Video Electronics Standards Association, VESA) 로컬 버스, 및 주변 컴포넌트 인터커넥츠(Peripheral Component Interconnects, PCI) 버스를 포함하나, 이러한 예로 한정되는 것은 아니다. 호스트는 일반적으 로 다양한 컴퓨터 시스템 판독가능 매체를 포함한다 이러한 매체는 호스트에 의해 접근가능한 어떤 이용가 능한 매체일 수 있으며, 휘발성 및 비휘발성 매체, 착탈식 및 고정식 매체 둘 다를 포함할 수 있다. 메모리는 휘발성 메모리 형태의 컴퓨터 시스템 판독가능 매체를 포함할 수 있는데, 컴퓨터 시스템 판독가능 매체는, 예컨대, 랜덤 억세스 메모리(random access memory, RAM) 및/또는 캐시 메모리일 수 있다. 예로서(단지 예를 든 것임), 고정식, 비휘발성 자기 매체(도시되지 않았고 일반적으로 \"하드 드라이브\"로 일컬어짐)로부터 읽기 위해 그리고 고정식, 비휘발성 자기 매체에 쓰기 위해 스토리지 시스템(93 4)이 제공될 수 있다. 비록 도시되지는 않았으나, 착탈식, 비휘발성 자기 디스크(예컨대, \"플로피 디스크\")로부 터 읽고 착탈식, 비휘발성 자기 디스크에 쓰기 위한 자기 디스크 드라이브, 그리고 예를 들어 CD-ROM, DVD-ROM 또는 다른 광 매체와 같은 착탈식, 비휘발성 광 디스크로부터 읽거나 그러한 착탈식, 비휘발성 광 디스크에 쓰 기 위한 광 디스크 드라이브가 제공될 수 있다. 이러한 경우들에 있어서, 각각은 하나 또는 그 이상의 데이터 매체 인터페이스들에 의해 버스에 연결될 수 있다. 예를 들어 운영체제, 하나 또는 그 이상의 어플리케이션 프로그램들, 다른 프로그램 모듈들, 및 프로그 램 데이터 뿐만 아니라(이러한 예로 한정되는 것은 아님), 프로그램 모듈들의 세트(적어도 하나의)를 갖는 프로그램/유틸리티가 메모리에 저장될 수 있다. 운영체제들, 하나 또는 그 이상의 어플리케이션 프로 그램들, 다른 프로그램 모듈들, 및 프로그램 데이터 또는 이것들의 몇몇 조합 각각은 네트워킹 환경의 구현을 포함할 수 있다. 프로그램 모듈들은 일반적으로 대립관계에 있는 훈련(adversarial training) 및 동적 분류 모델 진화의 실시예들의 함수들 및/또는 방법론들(methodologies)을 수행한다. 예를 들어, 프로그램 모듈들 의 세트는 도 1에서 설명된 툴들(152, 154, 및 156)로 구성된 모듈들을 포함할 수 있다. 호스트는 또한, 키보드, 포인팅 디바이스, 감각 출력 디바이스(sensory output device) 등과 같은 하나 또는 그 이상의 외부 디바이스들; 디스플레이; 사용자에게 호스트와 상호작용할 수 있도록 하는 하나 또는 그 이상의 디바이스들; 및/또는 호스트에게 하나 또는 그 이상의 다른 컴퓨팅 디바이스들 과 통신할 수 있도록 하는 어떤 디바이스들(예컨대, 네트워크 카드, 모뎀 등)으로 통신할 수 있다. 이러한 통신 은 입력/출력(I/O) 인터페이스(들)을 통해 발생할 수 있다. 또한, 호스트는 네트워크 어댑터를 통해 근거리 통신망(local area network, LAN), 일반적인 광역 통신망(wide area network, WAN), 및/또는 공용 통신망(예컨대, 인터넷)과 같은 하나 또는 그 이상의 통신망들로 통신할 수 있다. 도시된 바와 같이, 네트워크 어댑터는 버스를 통해 호스트의 다른 컴포넌트들과 통신한다. 일 실시예에서, 분산된 파일 시스 템(도시되지 않음)의 복수의 노드들은 I/O 인터페이스를 통해 또는 네트워크 어댑터를 통해 호스트 와 통신한다. 비록 도시되지는 않았으나, 호스트와 함께 다른 하드웨어 및/또는 소프트웨어 컴포넌트 들이 사용될 수 있다는 것이 이해되어야 한다. 예들은 마이크로코드, 디바이스 드라이버들, 리던던트 처리 유닛 들, 외부 디스크 드라이브 어레이들, RAID 시스템들, 테이프 드라이브들, 및 데이터 기록 스토리지 시스템들 (data archival storage systems) 등을 포함하지만, 이러한 예들로 한정되는 것은 아니다. 본 명세서에서, \"컴퓨터 프로그램 매체\", \"컴퓨터 사용가능 매체\", 및 \"컴퓨터 판독가능 매체\" 라는 용 어들은, RAM, 캐시, 및 스토리지 시스템 - 예컨대, 착탈식 스토리지 드라이브 및 하드 디스크 드라이브에 설치된 하드 디스크 - 를 포함하는, 메인 메모리와 같은 매체를 일반적으로 지칭하기 위해 사 용된다. 컴퓨터 프로그램들(이는 또한 컴퓨터 컨트롤 로직으로도 일컬어짐)은 메모리에 저장된다. 컴퓨터 프로그램들은 또한 네트워크 어댑터와 같은 통신 인터페이스를 통해 수신될 수 있다. 이러한 컴퓨터 프로 그램들은, 실행될 때, 컴퓨터 시스템에게 여기에서 논의되는 본 발명의 실시예들의 특징들을 수행하도록 할 수 있다. 특히, 컴퓨터 프로그램들은, 실행될 때, 처리 유닛에게 컴퓨터 시스템의 특징들을 수행하도록 할 수 있다. 따라서, 이러한 컴퓨터 프로그램들은 컴퓨터 시스템의 컨트롤러들을 나타낸다. 일 실시예에서, 호스트는 클라우드 컴퓨팅 환경의 하나의 노드이다. 당해 기술 분야에서 알려진 바 와 같이, 클라우드 컴퓨팅은, 최소한의 유지관리 노력 또는 서비스 공급자와의 상호작용으로 빠르게 공급되고 배포될 수 있는 설정가능한 컴퓨팅 리소스들(예컨대, 통신망들, 통신망 대역폭, 서버들, 처리(processing), 메 모리, 스토리지, 어플리케이션들, 가상 머신들, 및 서비스들)의 공유 풀(shared pool)에 대한 편리한, 주문형 통신망 접근을 가능하게 하기 위한 서비스 전달 모델이다. 이 클라우드 모델은 적어도 다섯 개의 특징들, 적어 도 세 개의 서비스 모델들, 및 적어도 네 개의 배치 모델들(deployment models)을 포함할 수 있다. 이러한 특성 들의 예들인 이하와 같다. 주문형 셀프 서비스(on-demand self-service) : 클라우드 소비자는, 서비스의 공급자와의 인적 상호작용 을 필요로 함이 없이 자동으로 요구됨에 따라, 서버 시간 및 네트워크 스토리지와 같은 컴퓨팅 기능들을 일방적 으로 제공할 수 있다. 광범위한 통신망 접근 : 기능들은 네트워크를 통해 이용가능하고 이종(heterogeneous)의 신 클라이언트 플랫폼(thin client platform) 또는 시크 클라이언트 플랫폼(thick client platform)(예컨대, 모바일 전화기들, 랩탑 컴퓨터들, 및 PDA들)에 의한 사용을 촉진하는 표준 메커니즘들을 통해 접근된다. 리소스 풀링(resource pooling) : 공급자의 컴퓨팅 리소스들은 멀티 테넌트 모델(multi-tenant model) 을 사용하여 다수의 소비자들에게 제공하도록 모여(pool) 있다. 여기서는, 상이한 물리적 및 가상 리소스들이 수요에 따라 동적으로 할당 및 재할당된다. 일반적으로 소비자가 공급받은 리소스들의 정확한 위치에 대한 아무 런 컨트롤도 하지 않거나 어떠한 지식도 갖지 않지만 더 높은 추상화의 계층에서의 위치(예컨대, 나라, 주, 또 는 데이터센터)를 명시할 수 있다는 점에서 위치 독립감(a sense of location indepedence)이 있다. 빠른 탄력성(rapid elasticity) : 빠르게 축소(scale out)하고 빠르게 배포(release)되어 빠르게 확장 (scale in)하기 위해, 기능들은 빠르고 탄력적으로, 몇몇 경우들에 있어서는 자동적으로 공급될 수 있다. 소비 자에 대하여는, 공급을 위해 이용가능한 기능들은 종종 무제한으로 보일 수 있고 아무 때나 얼마든지 구매될 수 있다. 측정된 서비스 : 클라우드 시스템들은, 서비스의 유형(예컨대, 스토리지, 처리, 대역폭, 및 액티브 사용 자 어카운트들(active user accounts))에 적절한 일부 추상화 계층에서 계량 기능(metering capability)을 활 용함으로써, 리소스 사용을 자동으로 컨트롤하고 최적화한다. 리소스 사용량은 모니터링되고, 컨트롤되고, 보고 되어, 이용되는 서비스의 공급자와 소비자 둘 다에 대한 투명성을 제공한다. 서비스 모델들은 다음과 같다. 서비스로서의 소프트웨어(Software as a Service, SaaS) : 소비자에게 공급되는 기능은 클라우드 인프라 구조에서 실행되는 공급자의 어플리케이션들을 사용하는 것이다. 어플리케이션들은 웹 브라우저(예컨대, 웹 기 반 이메일)와 같은 신 클라이언트 인터페이스(thin client interface)를 통해 다양한 클라이언트 디바이스들로 부터 접근가능하다. 소비자는, 제한된 사용자 특정 어플리케이션 구성 설정들은 예외적으로 가능하지만, 네트워 크, 서버들, 운영체제들, 스토리지, 또는 심지어 개개의 어플리케이션 기능들을 포함하는 근본적인 클라우드 인 프라구조를 관리하거나 컨트롤하지 않는다. 서비스로서의 플랫폼(Platform as a Service, PaaS) : 공급자에 의해 지원되는 프로그래밍 언어들 및 툴들을 사용하여 생성된 클라우드 인프라구조 소비자-생성 또는 획득 어플리케이션들에 배치하기 위한 기능이 소바자에게 제공된다. 소비자는 네트워크들, 서버들, 운영체제들, 또는 스토리지를 포함하는 근본적인 클라우드 인프라구조를 관리 또는 컨트롤하지는 않지만 배치된 어플리케이션들 및 가능하게는 어플리케이션 호스팅 환경 구성들에 대해서는 컨트롤한다. 서비스로서의 인프라구조(Infrastructure as a Service, IaaS) : 처리, 스토리지, 네트워크들, 그리고 소비자가 임의의 소프트웨어를 배치하고 실행할 수 있는 다른 근본적인 컴퓨팅 리소스들을 제공하기 위한 기능 이 제공된다. 상기 근본적인 컴퓨팅 리소스들은 운영 체제들 및 어플리케이션들을 포함할 수 있다. 소비자는 근 본적인 클라우드 인프라구조를 관리 또는 컨트롤하지는 않지만 운영 체제들, 스토리지, 배치된 어플리케이션들 을 통해서 컨트롤하고, 가능하게는 선택된 네트워킹 컴포넌트들(예컨대, 호스트 방화벽들)에 제한되게 컨트롤한 다. 배치 모델들(Deployment Models)은 다음과 같다. 사설 클라우드(Private cloud) : 클라우드 인프라구조는 오로지 조직을 위해 동작된다. 그것은 조직 또 는 제3자에 의해 관리될 수 있고 구내에(on-premises) 또는 구외에(off-premises) 존재할 수 있다. 커뮤니티 클라우드 : 클라우드 인프라구조는 몇 개의 조직들에 의해 공유되고, 관심사(concerns)(예컨대, 임무(mission), 보안 요구사항(security requirements), 정책(polity), 및 준수 고 려사항(compliance considerations))을 공유한 특정 커뮤니티를 지원한다. 그것은 조직들 또는 제3자에 의해 관 리될 수 있고 구내에 또는 구외에 존재할 수 있다. 공중 클라우드(Public cloud) : 클라우드 인프라구조는 일반 공중 또는 대규모 산업 그룹에 이용가능하 도록 만들어지고 클라우드 서비스들을 판매하는 조직에 의해 소유된다. 하이브리드 클라우드(Hybrid cloud) : 클라우드 인프라구조는 독특한 엔티티들로 남아 있지만 데이터 및 어플리케이션 이동성(portability)(예컨대, 클라우드들 간의 부하 밸런싱을 위한 클라우드 버스팅(cloud bursting))을 가능하게 하는 표준화 또는 독점적(proprietary) 기술에 의해 함께 결합되는 두 개 또는 그 이상 의 클라우드들(사설, 커뮤니티, 또는 공중)의 구성(composition)이다. 클라우드 컴퓨팅 환경은, 상태비저장(statelessness), 낮은 결합(low coupling), 모듈화(modularity), 및 의미론적 상호운용성(semantic interoperability)에 중점을 두고 서비스 지향적이다. 클라우드 컴퓨팅의 핵 심에는 상호연결된 노드들의 네트워크를 포함하는 인프라구조가 있다. 이제 도 10을 참조하면, 클라우드 컴퓨팅 네트워크 도시되어 있다. 도시된 바와 같이, 클라우드 컴퓨팅 네트워크는 하나 또는 그 이상의 클라우드 컴퓨팅 노드들을 갖는 클라우드 컴퓨팅 환경 을 포함한다. 클라우드 컴퓨팅 노드들로 클라우드 소비자들에 의해 사용되는 로컬 컴퓨팅 디바이스 들이 통신할 수 있다. 이들 로컬 컴퓨팅 디바이스들의 예들은, 개인용 디지털 보조기기(PDA) 또는 셀룰러 전화 기(1054A), 데스크탑 컴퓨터(1054B), 랩탑 컴퓨터(1054C), 및 또는 자동차 컴퓨터 시스템(1054N)을 포함하지만, 이러한 예로 한정되는 것은 아니다. 노드들 내에서 개별 노드들은 나아가 서로 간에 통신할 수 있다. 그 들은 위에서 설명된 바와 같은 사설, 커뮤니티, 공중, 또는 하이브리드 클라우드들, 또는 이것들의 조합으로 물 리적으로 또는 가상으로 그룹핑될 수 있다(도시되지 않음). 이는 클라우드 컴퓨팅 환경에게 클라우드 소 비자가 로컬 컴퓨팅 디바이스 상에 리소스들을 유지할 필요가 없는 서비스들로서 인프라구조, 플랫폼들 및/또는소프트웨어를 제공하는 것을 가능하게 한다. 도 10에 도시된 컴퓨팅 디바이스들의 유형들(1054A - N)은 단지 예 시하려는 의도로 이해되고 또한 클라우드 컴퓨팅 환경이 어떤 네트워크의 유형 및/또는 네트워크 주소지 정가능(addressable) 연결(예컨대, 웹 브라우저를 사용하여)을 통해 컴퓨터화된 디바이스의 어떤 유형과 통신할 수 있다는 것이 이해된다. 이제 도 11을 참조하면, 도 10의 클라우드 컴퓨팅 네트워크에 의해 제공되는 기능적 추상화 계층들의 세 트가 도시되어 있다. 도 11에 도시된 컴포넌트들, 계층들, 및 기능들은 단지 예시하려는 의도이고 이 실 시예들로 한정되어서는 아니된다는 것이 먼저 이해되어야 한다. 도시된 바와 같이, 이하의 계층들 및 대응되는 기능들이 제공된다. 즉, 하드웨어 및 소프트웨어 계층, 가상화 계층, 관리 계층, 및 작업부 하 계층이다. 하드웨어 및 소프트웨어 계층은 하드웨어 및 소프트웨어 컴포넌트들을 포함한다. 하 드웨어 컴포넌드들의 예들은, 메인프레임(mainframe), 일 예로 IBM®zSeries®시스템들; RISC(감소된 명령 세트 컴퓨터(Reduced Instruction Set Computer)) 아키텍쳐 기반 서버들, 일 예로 IBM pSeries® 시스템들, IBM xSeries® 시스템들; IBM BladeCenter® 시스템들; 스토리지 디바이스들; 네트워크들 및 네트워킹 컴포넌트들을 포함한다. 소프트웨어 컴포넌트들의 예들은 네트워크 어플리케이션 서버 소프트웨어, 일 예로, IBM WebSphere® 어플리케이션 서버 소프트웨어; 및 데이터베이스 소프트웨어, 일 예로 IBM DB2® 데이터 베이스 소프트웨어를 포 함한다. (IBM, zSeries, pSeries, xSeries, BladeCenter, WebSphere, 및 DB2는 전 세계의 많은 관할 구역에서 등록된 인터내셔널 비즈니스 머신즈 코퍼레이션(International Business Machines Corporation)의 상표들이 다). 가상화 계층은 가상 엔티티들의 다음과 같은 예들이 제공될 수 있는 추상화 계층을 제공한다. 즉, 가상 서버들; 가상 스토리지; 가상 사설 네트워크들을 포함하는 가상 네트워크들; 가상 어플리케이션들 및 운영 체제들; 및 가상 클라이언트들이 그 예이다. 일 예에서, 관리 계층은 다음과 같은 기능들을 제공한다. 즉, 리소스 공급(resource provisioning), 계량 및 가격 설정(metering and pricing), 사용자 포털(user portal), 서비스 계층 관리 (service layer management), 및 SLA 계획 및 이행이 그것이다. 리소스 공급은 컴퓨팅 리소스들 및 클라우드 컴 퓨팅 환경 내에서 태스크들을 수행하기 위해 이용되는 다른 리소스들의 동적(dynamic) 조달(procurement)을 제 공한다. 계량 및 가격 설정은, 클라우드 컴퓨팅 환경 내에서 리소스들이 이용됨에 따른 비용 추적(cost tracking), 및 이들 리소스들의 소비에 대한 과금 및 청구서 작성(billing or invoicing)을 제공한다. 일 실시 예에서, 이들 리소스들은 어플리케이션 소프트웨어 라이선스들을 포함할 수 있다. 보안(security)은 데이터 및 다른 리소스들에 대한 보호 뿐만이 아니라 클라우드 소비자들 및 태스크들들에 대한 신원 확인을 제공한다. 사 용자 포털(user portal)은 소비자들 및 시스템 관리자들에게 클라우드 컴퓨팅 환경에 대한 접근을 제공한다. 서 비스 수준 관리 계층은 요구되는 서비스 계층들이 충족되도록, 클라우드 컴퓨팅 리소스 할당 및 관리를 제공한 다. 서비스 계층 동의(Service Layer Agreement, SLA) 계획 및 이행은 SLA에 따라 장래의 요구가 예상되는 클 라우드 컴퓨팅 리소스들의 사전준비(prearrangement), 및 조달(procurement)을 제공한다. 작업부하들 계층은 클라우드 컴퓨팅 환경이 이용될 수 있는 기능들의 예들을 제공한다. 이러한 계 층으로부터 제공될 수 있는 작업부하들 및 기능들의 예들은, 맵핑 및 내비게이션, 소프트웨어 개발 및 라이프사 이클 관리, 가상 교실 교육 전달; 데이터 분석 처리; 거래 처리(transaction processing); 및 어플리케이션 관 리의 다목적 최적화를 포함하나, 이러한 예들로 한정되는 것은 아니다. 여기에 도시된 시스템 및 플로우 챠트들은 또한 전제조건 중심의 정형화된 인프라구조(prerequisite driven codified infrastructure)를 동적으로 조정(orchestrate)하기 위한 컴퓨터 프로그램 디바이스의 형태로 될 수도 있다. 상기 디바이스는 디바이스로 구현된 프로그램 코드를 갖는다. 상기 프로그램 코드는 설명된 기능 을 지원하는 처리 유닛에 의해 실행가능하다. 특정 실시예들이 도시되고 설명되었으나, 여기에서의 가르침에 기초하여, 본 발명의 측면들을 확장하지 않고서 변경들 및 수정들이 이뤄질 수 있다는 것은 당해 기술 분야에서 통상의 기술자에게는 자명할 것이다. 그 러므로, 첨부된 청구항들은 실시예들의 실제 범위 내에 있는 그러한 모든 변경들 및 수정들을 그것들의 범위 내 에 포함하는 것이다. 더욱이, 실시예들은 오로지 첨부된 청구항들에 의해 정의된다는 것이 이해되어야 한다. 당 해 기술 분야에서 통상의 기술자들은, 만약 특정 번호의 소개된 청구항의 구성요소가 의도된다면, 청구항에 그"}
{"patent_id": "10-2022-7033915", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "러한 의도가 분명히 언급될 것이고, 그러한 언급이 없을 시 그러한 한정은 존재하지 않는다는 것은 당해 기술분야에서 통상의 기술자들에 의해 이해될 것이다. 예를 한정하지 않고서 이해를 돕기 위해, 이하의 청구항들은 도입 문구들인 \"적어도 하나의\" 및 \"하나 또는 그 이상의\" 의 사용을 포함하여, 청구항의 구성요소들을 소개한 다. 하지만, 이러한 문구들의 사용은, 심지어 동일한 청구항이 도입 문구들인 \"하나 또는 그 이상의\" 또는 \"적 어도 하나의\", 그리고 \"하나\"와 같은 단어를 포함할 때에도, 비한정적인 단어인 \"하나\"에 의해 청구항의 소개가 단지 하나의 그러한 구성요소를 포함하는 실시예들에 소개된 그러한 청구항 구성요소들을 포함하는 어떤 특정 청구항을 한정하는 것을 의미하도록 해석되어서는 아니되며, 이는 한정하지 않는 단어들을 청구항에서 사용할 경우에도 마찬가지이다. 본 발명의 실시예(들)은 시스템, 방법, 및/또는 컴퓨터 프로그램 제품일 수 있다. 또한, 본 발명의 실 시예(들)의 선택된 측면들은 전적으로 하드웨어 실시예, 전적으로 소프트웨어 실시예(펌웨어, 상주 소프트웨어, 마이크로-코드 등을 포함함), 또는 소프트웨어 및/또는 하드웨어 측면들을 결합하는 실시예의 형태를 취할 수 있다. 소프트웨어 및/또는 하드웨어 측면들을 결합하는 실시예는 모두 일반적으로 여기서는 \"회로\", \"모듈\" 또 는 \"시스템\"으로 일컬어질 수 있다. 더 나아가, 본 발명의 실시예(들)의 측면들은 컴퓨터 판독가능 스토리지 매 체(또는 매체들)에 구현되는 컴퓨터 프로그램 제품의 형태를 취할 수 있다. 컴퓨터 판독가능 스토리지 매체(또 는 매체)들은 그것에 대한 컴퓨터 판독가능 프로그램 명령들을 가지며, 컴퓨터 판독가능 프로그램 명령들은 프 로세서로 하여금 본 발명의 실시예(들)의 측면들을 수행하도록 한다. 그리하여, 구현되고, 개시된 시스템, 방법, 및/또는 컴퓨터 프로그램 제품은 어플리케이션들의 다목적 최적화의 기능 및 동작을 향상시키도록 동작한 다. 컴퓨터 판독가능 스토리지 매체는 명령 실행 디바이스에 의해 사용하기 위한 명령들을 보유하고 저장할 수 있는 유형적 디바이스일 수 있다. 컴퓨터 판독가능 스토리지 매체는, 예를 들어, 전자 스토리지 디바이스, 자기 스토리지 디바이스, 광 스토리지 디바이스, 전자기 스토리지 디바이스, 반도체 스토리지 디바이스, 또는 이것들의 어떤 적절한 조합일 수 있으나, 이러한 예로 한정되는 것은 아니다. 컴퓨터 판독가능 스토리지 매체의 더 많은 구체적인 예들의 리스트(전체를 다 열거한 것은 아님)는 또한 다음을 포함할 수 있다. 즉, 휴대용 컴퓨 터 디스켓, 하드 디스크, 동적(dynamic) 또는 정적(static) 랜덤 억세스 메모리(random access memory, RAM), 읽기 전용 메모리(read-only memory, ROM), 소거가능 프로그램가능 읽기 전용 메모리(erasable programmable read-only memory, EPROM 또는 플래쉬 메모리), 자기 스토리지 디바이스(magnetic storage device), 휴대용 컴 팩트 디스크 읽기 전용 메모리(portable compact disc read-only memory, CD-ROM), 디지털 다용도 디스크 (digital versatile disk, DVD), 메모리 스틱, 플로피 디스크, 펀치-카드들 또는 기록된 명령들을 갖는 홈 (groove)에서 볼록한 구조들과 같은 기계적으로 인코딩된 디바이스, 및 앞서 열거한 것들의 어떤 적절한 조합을 포함할 수 있다. 여기서 사용되는 것과 같이, 컴퓨터 판독가능 스토리지 매체는, 무선 전파(radio waves) 또는 다른 자유롭게 전파되는 전자기파, 도파관 또는 다른 전송 매질을 통해 전파되는 전자기파(예컨대, 광섬유 케이 블을 통과하는 광 펄스), 또는 와이어를 통해 전송되는 전기적 신호와 같은 일시적인 신호들 그 자체로 해석되 는 것은 아니다. 여기에 설명되는 컴퓨터 판독가능 프로그램 명령들은, 예를 들어, 인터넷, 근거리 통신망, 광역 통신망 및/또는 무선 통신망과 같은 통신망을 통해 컴퓨터 판독가능 스토리지 매체로부터 각각의 컴퓨팅/처리 디바이스 들로, 또는 내부 컴퓨터 또는 외부 스토리지 디바이스로 다운로드될 수 있다. 네트워크는 동선 전송 케이블, 광 전송 섬유, 무선 전송, 라우터, 방화벽, 스위치, 게이트웨이 컴퓨터 및/또는 엣지(edge) 서버를 포함할 수 있다. 각각의 컴퓨팅/처리 디바이스에서 네트워크 어댑터 카드 또는 네트워크 인터페이스는, 각각의 컴퓨팅/처 리 디바이스 내 컴퓨터 판독가능 스토리지 매체에 저장하기 위해 네트워크로부터 컴퓨터 판독가능 프로그램 명 령들을 수신하고 컴퓨터 판독가능 프로그램 명령들을 전송한다. 본 발명의 실시예(들)의 동작들을 수행하기 위한 컴퓨터 판독가능 프로그램 명령들은 어셈블러 명령 (assembler instructions), 명령-세트-아키텍쳐(instruction-set-architecture, ISA) 명령, 머신 명령(machine instructions), 머신 종속 명령(machine dependent instructions), 마이크로코드, 펌웨어 명령(firmware instructions), 상태-세팅 데이터(state-setting data), 또는 하나 또는 그 이상의 프로그래밍 언어들의 어떤 조합으로 작성된 소스 코드 또는 객체 코드(object code)일 수 있다. 상기 프로그래밍 언어들은 스몰토크 (Smalltalk), C++ 등과 같은 객체 지향 프로그래밍 언어(object oriented programming language), 및 \"C\" 프로 그래밍 언어 또는 유사 프로그래밍 언어들과 같은 절차형 프로그래밍 언어들을 포함한다. 컴퓨터 판독가능 프로 그램 명령들은 독립형(stand-alone) 소프트웨어 패키지로서 사용자의 컴퓨터 상에서 전적으로, 사용자의 컴퓨터 상에서 부분적으로 실행될 수 있고, 사용자의 컴퓨터 상에서 부분적으로 그리고 원격 컴퓨터 상에서 부분적으로 실행될 수 있고, 또는 원격 컴퓨터 또는 서버 또는 서버들의 클러스터 상에서 전적으로 실행될 수 있다. 후자의시나리오에 있어서, 원격 컴퓨터는 근거리 통신망(LAN) 또는 광역 통신망(WAN)을 포함하는 어떤 유형의 네트워 크를 통해 사용자의 컴퓨터에 연결될 수 있고, 또는 그 연결은 외부 컴퓨터에 대해 이뤄질 수 있다(예컨대, 인 터넷 서비스 공급자(Internet Service Provider)를 사용하여 인터넷을 통해서). 몇몇 실시예들에 있어서, 본 발 명의 실시예(들)의 측면들을 수행하기 위해, 예를 들어, 프로그램가능 로직 회로망(programmable logic circuitry), 필드-프로그램가능 게이트 어레이(field-programmable gate arrays, FPGA), 또는 프로그램가능 로 직 어레이(Programmable logic arrays, PLA)를 포함하는 전자 회로망(electronic circuitry)이 그 전자 회로망 을 개인화(personalize)하기 위해 컴퓨터 판독가능 프로그램 명령들의 상태 정보를 이용함으로써 그 컴퓨터 판 독가능 프로그램 명령들을 실행할 수 있다. 본 발명의 실시예(들)의 측면들은 여기서 방법들, 장치들(시스템들), 및 컴퓨터 프로그램 제품들의 플로 우챠트 설명들 및/또는 블록 다이어그램들을 참조하여 설명된다. 플로우챠트 설명들 및/또는 블록 다이어그램들 에서 플로우챠트 설명들 및/또는 블록 다이어그램들의 각각의 블록, 및 블록들의 조합들은 컴퓨터 판독가능 프 로그램 명령들에 의해 구현될 수 있다는 것이 이해될 것이다. 이들 컴퓨터 판독가능 프로그램 명령들은 범용 컴퓨터(general purpose computer), 전용 컴퓨터 (special purpose computer), 또는 다른 프로그램가능 데이터 처리 장치의 프로세서에게 제공되어 머신 (machine)을 생성할 수 있으며, 그리하여 컴퓨터 또는 다른 프로그램가능 데이터 처리 장치의 프로세서를 통해 실행될 때 그 명령들이 플로우챠트 및/또는 블록 다이어그램 블록 또는 블록들에 명시된 기능들/동작들을 구현 하기 위한 수단을 생성하도록 한다. 이들 컴퓨터 판독가능 프로그램 명령들은 또한 컴퓨터 판독가능 스토리지에 저장될 수 있으며, 컴퓨터 판독가능 스토리지는 컴퓨터, 프로그램가능 데이터 처리 장치, 및/또는 다른 디바이 스들이 특정 방식으로 기능하도록 지시할 수 있다. 그리하여, 내부에 저장된 명령들을 갖는 컴퓨터 판독가능 스 토리지 매체가 플로우챠트 및/또는 블록 다이어그램의 블록 또는 블록들에 명시된 기능/동작의 측면들을 구현하 는 명령들을 포함하는 제조 물품을 포함하도록 한다. 컴퓨터 판독가능 프로그램 명령들은 또한 컴퓨터, 다른 프로그램가능 데이터 처리 장치, 또는 다른 다바 이스 상으로 로딩되어 컴퓨터, 다른 프로그램가능 장치 또는 다른 디바이스 상에서 수행될 일련의 동작 단계들 로 하여금 컴퓨터 구현 프로세스(computer implemented process)를 생성하게 할 수 있다. 그리하여 컴퓨터, 다 른 프로그램가능 장치, 또는 다른 디바이스 상에서 실행되는 명령들이 플로우챠트 및/또는 블록 다이어그램의 블록 또는 블록들에 명시된 기능들/동작들을 구현하도록 한다. 도면들에서 플로우챠트 및 블록 다이어그램들은 본 발명의 다양한 실시예들에 따른 시스템들, 방법들, 및 컴퓨터 프로그램 제품들의 가능한 구현의 아키텍쳐, 기능, 및 동작을 보여준다. 이 점에서, 플로우챠트 또는 블록 다이어그램들에서의 각각의 블록은 모듈, 세그먼트, 또는 명령들의 일부분을 나타낼 수 있으며, 이는 명시 된 논리적 기능(들)을 구현하기 위한 하나 또는 그 이상의 실행가능한 명령들을 포함한다. 몇몇 다른 구현들에 있어서, 블록들에 기재되어 있는 기능들은 도면들에 기재되어 있는 순서를 벗어나서 발생할 수도 있다. 예를 들 어, 연속해서 보여지는 두 개의 블록들은, 사실상, 실질적으로 동시에 일어날 수 있고, 또는 블록들은 때로는 관련된 기능에 따라 역순으로 실행될 수도 있다. 또한, 블록 다이어그램들 및/또는 플로우챠트 그림의 각각의 블록, 및 블록 다이어그램들 및/또는 플로우챠트 그림에서의 블록들의 조합들은 명시된 기능들 또는 동작들을 수행하거나 전용 하드웨어와 컴퓨터 명령들의 조합들을 수행하는 전용 하드웨어 기반 시스템들에 의해 구현될 수 있다는 것에 유의해야 할 것이다. 여기서는 예시의 목적으로 구체적인 실시예들이 설명되었지만, 본 발명의 범위를 벗어남이 없이 다양한 변형 예들이 만들어질 있다는 것이 이해될 것이다. 특히 전제조건 중심의 정형화된 인프라구조의 동적 조정 (dynamic orchestration)을 포함하는 정형화된 인프라구조는 상이한 컴퓨팅 플랫폼들에 의해 또는 다수의 디바 이스들에 걸쳐서 수행될 수 있다. 더 나아가, 데이터 스토리지 및/또는 코퍼스는 로컬화, 원격, 또는 다수의 시 스템들에 퍼져 있을 수 있다. 따라서, 본 발명의 보호 범위는 이하의 청구항들과 그것들의 균등 범위에 의해서 만 한정된다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11"}
{"patent_id": "10-2022-7033915", "section": "도면", "subsection": "도면설명", "item": 1, "content": "여기에서 참조되는 도면들은 설명의 일부를 이루며 설명에 포함된다. 도면들에서 보여지는 특징들은, 달 리 명시되지 않는다면, 모든 실시예들에 관한 것이 아니라, 단지 몇몇 실시예들에 관한 설명로서의 의미를 갖는 것이다. 도 1은 어플리케이션들의 다목적 최적화를 지원하기 위한 컴퓨터 시스템 및 내장된 툴들을 설명하는 시 스템 다이어그램을 도시한다. 도 2는 도 1에 보여진 툴들 및 그것들의 연관된 어플리케이션 프로그램 인터페이스(들)을 나타내는 블록 다이어그램을 도시한다. 도 3은 어플리케이션의 다목적 최적화를 위한 프로세스를 나타내는 플로우 챠트를 도시한다. 도 4는 하나 또는 그 이상의 적응적 시험들을 수행하기 위해 머신 러닝을 활용하기 위한 프로세스를 나 타내는 플로우 챠트를 도시한다. 도 5는 레이턴시 및 에러율 목표들(objectives)의 KPI들을 위한 그래프와 파레토 표면의 일 예를 설명하 는 블록 다이어그램을 도시한다. 도 6은 인터랙팅 마이크로-서비스들의 계층구조(hierarchy)의 일 예를 도시하는 블록 다이어그램이다. 도 7은 순차적 쿼리 제약(sequential query constraint)을 갖는 어플리케이션 마이크로-서비스들의 계 층구조의 일 예를 도시하는 블록 다이어그램이다. 도 8은 병렬 쿼리 제약(parallel query constraint)을 갖는 어플리케이션 마이크로-서비스들의 계층구조 의 일 예를 도시하는 블록 다이어그램이다. 도 9는 도 1 - 8에 대해 위에서 설명된 시스템 및 프로세스들을 구현하기 위한, 클라우드 기반 지원 시 스템의 컴퓨터 시스템/서버의 일 예를 도시하는 블록 다이어그램이다. 도 10은 클라우드 컴퓨터 환경을 나타내는 블록 다이어그램을 도시한다. 도 11은 클라우드 컴퓨팅 환경에 의해 제공되는 기능적 추상화 모델 계층들(functional abstraction model layers)의 세트를 나타내는 블록 다이어그램을 도시한다."}
