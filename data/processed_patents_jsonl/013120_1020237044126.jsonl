{"patent_id": "10-2023-7044126", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0063811", "출원번호": "10-2023-7044126", "발명의 명칭": "가속기 하드웨어를 디버깅하기 위한 시스템들, 장치들 및 방법들", "출원인": "인텔 코포레이션", "발명자": "그리멜, 마틴-토마스"}}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "하드웨어 가속기를 디버깅하기 위한 장치로서,코어 입력 및 코어 출력을 갖는 코어 - 상기 코어는 데이터 입력에 기초하여 데이터 출력을 생성하기 위한 실행가능 코드를 실행하고, 상기 실행가능 코드는 기계 학습 모델에 기초함 -; 및 상기 코어 입력 또는 상기 코어 출력 중 적어도 하나에 결합된 디버그 회로부를 포함하고, 상기 디버그 회로부는,상기 코어 출력에 결합된 인터페이스 입력 또는 상기 코어 입력에 결합된 인터페이스 출력 중 적어도 하나를 갖는 인터페이스 회로부 - 상기 인터페이스 회로부는 상기 데이터 입력 또는 상기 데이터 출력 중 적어도 하나를수신함 -; 멀티플렉서 입력 및 멀티플렉서 출력을 갖는 멀티플렉서 회로부 - 상기 멀티플렉서 입력은 상기 인터페이스 출력에 결합됨 -; 및 상기 멀티플렉서 출력에 결합된 시프트 레지스터 입력을 갖는 시프트 레지스터를 포함하고, 상기 시프트 레지스터는 상기 실행가능 코드의 실행과 연관된 중단점의 트리거에 응답하여 상기데이터 입력 또는 상기 데이터 출력 중 상기 적어도 하나를 출력하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 인터페이스 입력은 메모리에 결합되고, 상기 인터페이스 출력은 상기 코어 입력에 결합되며,상기 인터페이스 회로부는,상기 메모리로부터 상기 데이터 입력을 수신하고;상기 중단점이 트리거되지 않는 것에 응답하여 상기 데이터 입력을 상기 코어 입력에 제공하며;상기 코어는 상기 코어 출력으로부터의 상기 데이터 출력을 상기 메모리에 제공하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 코어 입력은 메모리에 결합되고, 상기 인터페이스 입력은 상기 코어 출력에 결합되고, 상기 인터페이스 출력은 상기 메모리에 결합되며,상기 코어는,상기 메모리로부터 상기 데이터 입력을 수신하고;상기 코어 출력으로부터의 상기 데이터 출력을 상기 인터페이스 입력에 제공하며;상기 인터페이스 회로부는 상기 중단점이 트리거되지 않는 것에 응답하여 상기 데이터 출력을 상기 메모리에 제공하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 디버그 회로부는 제1 디버그 회로부이고, 상기 인터페이스 회로부는 제1 인터페이스 회로부이고, 상기 인터페이스 입력은 제1 인터페이스 입력이고, 상기 인터페이스 출력은 제1 인터페이스 출력이고, 상기 제1 인터페공개특허 10-2024-0063811-3-이스 입력은 메모리에 결합되고, 상기 제1 인터페이스 회로부는 상기 메모리로부터 상기 데이터 입력을 수신하고,상기 제1 인터페이스 회로부는 상기 중단점이 트리거되지 않는 것에 응답하여 상기 코어에 상기 데이터 입력을제공하며,상기 장치는,제2 인터페이스 입력 및 제2 인터페이스 출력을 갖는 제2 인터페이스 회로부를 포함하는 제2 디버그 회로부를더 포함하고, 상기 제2 인터페이스 입력은 상기 코어 출력에 결합되고, 상기 제2 인터페이스 출력은 상기 메모리에 결합되며, 상기 제2 디버그 회로부는,상기 코어로부터 상기 데이터 출력을 수신하는 것;상기 중단점의 트리거에 응답하여 상기 데이터 입력 또는 상기 데이터 출력 중 상기 적어도 하나를 출력하는것; 또는상기 중단점이 트리거되지 않는 것에 응답하여 상기 데이터 출력을 상기 메모리로 출력하는 것중 적어도 하나를 하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,상기 디버그 회로부는 상기 코어에 포함되고, 상기 하드웨어 가속기는 신경망 가속기이고, 상기 기계 학습 모델은 신경망이며,상기 코어는 데이터 입력에 기초하여 데이터 출력을 생성하기 위한 실행가능 코드를 실행하고, 상기 실행가능코드는 중단점을 포함하고, 상기 실행가능 코드는 상기 신경망 또는 상기 중단점 중 적어도 하나에 기초하며;상기 디버그 회로부는,상기 중단점을 트리거하여 상기 실행가능 코드의 실행을 중단시키고;상기 데이터 입력, 상기 데이터 출력 또는 상기 중단점 중 적어도 하나를 출력하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 데이터 입력 또는 상기 데이터 출력 중 상기 적어도 하나는 제1 값을 포함하고, 상기 디버그 회로부는,상기 코어의 구성 레지스터로부터 상기 중단점에 대응하는 제2 값을 획득하기 위한 제어 회로부;상기 제어 회로부에 결합된 중단점 레지스터 - 상기 중단점 레지스터는 상기 제2 값을 저장함 -;제1 비교기 입력 및 제2 비교기 입력을 갖는 비교기 회로부를 포함하며, 상기 제1 비교기 입력은 상기 인터페이스 출력에 결합되고, 상기 제2 비교기 입력은 상기 중단점레지스터 및 상기 제어 회로부에 결합되고, 상기 비교기 회로부는 상기 제1 값과 상기 제2 값을 비교하며;상기 제어 회로부는 상기 인터페이스 회로부에게 상기 비교에 기초하는 상기 제1 값과 상기 제2 값의 매치에 응답하여 상기 데이터 입력 또는 상기 데이터 출력 중 상기 적어도 하나를 상기 멀티플렉서 회로부에 제공하도록명령하고, 상기 중단점의 트리거링은 상기 매치에 응답하고, 상기 제어 회로부는 상기 인터페이스 회로부에게상기 비교기 회로부로부터 상기 매치의 표시를 수신하도록 명령하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 인터페이스 회로부는 제1 인터페이스 회로부이고, 상기 인터페이스 입력은 제1 인터페이스 입력이고, 상기인터페이스 출력은 제1 인터페이스 출력이고, 상기 코어는 제1 스레드 및 제2 스레드를 포함하고, 상기 제1 스레드는 상기 제1 인터페이스 입력에 결합되며,공개특허 10-2024-0063811-4-상기 장치는,제2 인터페이스 입력 및 제2 인터페이스 출력을 갖는 제2 인터페이스 회로부 - 상기 제2 인터페이스 입력은 상기 제2 스레드에 결합됨 -; 및상기 멀티플렉서 회로부의 선택 입력에 결합된 카운터 출력을 갖는 카운터 회로부를 더 포함하고, 상기 카운터 회로부는,제1 값을 출력하여 상기 멀티플렉서 회로부에게 상기 제1 인터페이스 회로부의 출력을 선택하도록 명령하고;제2 값을 출력하여 상기 멀티플렉서 회로부에게 상기 제2 인터페이스 회로부의 출력을 선택하도록 명령하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "하드웨어 가속기를 디버깅하기 위한 장치로서,데이터 입력에 기초하여 데이터 출력을 생성하기 위한 실행가능 코드를 실행하기 위한 수단 - 상기 실행가능 코드는 기계 학습 모델에 기초함 -; 및 상기 하드웨어 가속기를 디버깅하기 위한 수단을 포함하고, 상기 디버깅하기 위한 수단은 상기 실행하기 위한 수단에 결합되고, 상기 디버깅하기 위한수단은,상기 데이터 입력 또는 상기 데이터 출력 중 적어도 하나를 수신하기 위한 수단 - 상기 수신하기 위한 수단은상기 실행하기 위한 수단의 출력에 결합된 입력 또는 상기 실행하기 위한 수단의 입력에 결합된 출력 중 적어도하나를 가짐 -;상기 수신하기 위한 수단을 선택하기 위한 수단 - 상기 선택하기 위한 수단은 상기 수신하기 위한 수단의 출력에 결합된 입력을 가짐 -; 및상기 실행가능 코드의 실행과 연관된 중단점의 트리거에 응답하여 상기 데이터 입력 또는 상기 데이터 출력 중상기 적어도 하나를 출력하기 위한 수단을 포함하고, 상기 출력하기 위한 수단은 상기 선택하기 위한 수단의 출력에 결합된 입력을 갖는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 수신하기 위한 수단의 상기 입력은 저장하기 위한 수단에 결합되고, 상기 수신하기 위한 수단의 상기 출력은 상기 실행하기 위한 수단의 상기 입력에 결합되며,상기 수신하기 위한 수단은,상기 저장하기 위한 수단으로부터 상기 데이터 입력을 수신하고;상기 중단점이 트리거되지 않는 것에 응답하여 상기 데이터 입력을 상기 실행하기 위한 수단의 상기 입력에 제공하며;상기 실행하기 위한 수단은 상기 실행하기 위한 수단의 상기 출력으로부터의 상기 데이터 출력을 상기 저장하기위한 수단에 제공하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제8항에 있어서,상기 실행하기 위한 수단의 상기 입력은 상기 저장하기 위한 수단에 결합되고, 상기 수신하기 위한 수단의 상기입력은 상기 실행하기 위한 수단의 상기 출력에 결합되고, 상기 수신하기 위한 수단의 상기 출력은 상기 저장하기 위한 수단에 결합되며,상기 실행하기 위한 수단은,공개특허 10-2024-0063811-5-상기 저장하기 위한 수단으로부터 상기 데이터 입력을 수신하고;상기 실행하기 위한 수단의 상기 출력으로부터의 상기 데이터 출력을 상기 수신하기 위한 수단의 상기 입력에제공하며;상기 수신하기 위한 수단은 상기 중단점이 트리거되지 않는 것에 응답하여 상기 데이터 출력을 상기 저장하기위한 수단에 제공하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제8항에 있어서,상기 디버깅하기 위한 수단은 디버깅하기 위한 제1 수단이고, 상기 수신하기 위한 수단은 수신하기 위한 제1 수단이고, 상기 수신하기 위한 제1 수단의 상기 입력은 상기 저장하기 위한 수단에 결합되고, 상기 수신하기 위한제1 수단은 상기 저장하기 위한 수단으로부터 상기 데이터 입력을 수신하고,상기 수신하기 위한 제1 수단은 상기 중단점이 트리거되지 않는 것에 응답하여 상기 실행하기 위한 수단에 상기데이터 입력을 제공하며,상기 장치는 상기 하드웨어 가속기를 디버깅하기 위한 제2 수단을 더 포함하고, 상기 디버깅하기 위한 제2 수단은 수신하기 위한 제2 수단을 포함하고, 상기 수신하기 위한 제2 수단의 입력은 상기 실행하기 위한 수단의 상기 출력에 결합되고, 상기 수신하기 위한 제2 수단의 출력은 상기 저장하기 위한 수단에 결합되며,상기 디버깅하기 위한 제2 수단은,상기 실행하기 위한 수단으로부터 상기 데이터 출력을 수신하는 것;상기 중단점의 트리거에 응답하여 상기 데이터 입력 또는 상기 데이터 출력 중 상기 적어도 하나를 출력하는것; 또는상기 중단점이 트리거되지 않는 것에 응답하여 상기 데이터 출력을 상기 저장하기 위한 수단으로 출력하는 것중 적어도 하나를 하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제8항에 있어서,상기 디버깅하기 위한 수단은 상기 실행하기 위한 수단에 포함되고, 상기 하드웨어 가속기는 신경망가속기이고, 상기 기계 학습 모델은 신경망이며,상기 실행하기 위한 수단은 데이터 입력에 기초하여 데이터 출력을 생성하기 위한 실행가능 코드를 실행하고,상기 실행가능 코드는 중단점을 포함하고, 상기 실행가능 코드는 상기 신경망 또는 상기 중단점 중 적어도 하나에 기초하며;상기 디버깅하기 위한 수단은,상기 중단점을 트리거하여 상기 실행가능 코드의 실행을 중단시키고;상기 데이터 입력, 상기 데이터 출력 또는 상기 중단점 중 적어도 하나를 출력하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제8항에 있어서,상기 데이터 입력 또는 상기 데이터 출력 중 상기 적어도 하나는 제1 값을 포함하고,상기 디버깅하기 위한 수단은,상기 디버깅하기 위한 수단을 제어하기 위한 수단 - 상기 제어하기 위한 수단은 저장하기 위한 제1 수단으로부터 상기 중단점에 대응하는 제2 값을 획득함 -;상기 제2 값을 저장하기 위한 제2 수단 - 상기 저장하기 위한 제2 수단은 상기 제어하기 위한 수단에 결합됨 -;상기 제1 값과 상기 제2 값을 비교하도록 비교하기 위한 수단공개특허 10-2024-0063811-6-을 포함하고, 상기 비교하기 위한 수단의 제1 입력은 상기 수신하기 위한 수단의 상기 출력에 결합되고, 상기비교하기 위한 수단의 제2 입력은 상기 저장하기 위한 제2 수단 및 상기 제어하기 위한 수단에 결합되며;상기 제어하기 위한 수단은 상기 비교에 기초하는 상기 제1 값과 상기 제2 값의 매치에 응답하여 상기 데이터입력 또는 상기 데이터 출력 중 상기 적어도 하나를 상기 선택하기 위한 수단에 제공하도록 상기 수신하기 위한수단을 제어하고, 상기 중단점의 트리거링은 상기 매치에 응답하고, 상기 제어하기 위한 수단은 상기 비교하기위한 수단으로부터 상기 매치의 표시를 수신하도록 상기 수신하기 위한 수단을 제어하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제8항에 있어서,상기 데이터 입력은 제1 데이터 입력이고, 상기 데이터 출력은 제1 데이터 출력이고, 상기 수신하기 위한 수단은 수신하기 위한 제1 수단이고, 상기 실행하기 위한 수단은 실행하기 위한 제1 수단이며,상기 장치는,제2 데이터 입력 또는 제2 데이터 출력 중 적어도 하나를 수신하기 위한 제2 수단 - 상기 수신하기 위한 제2 수단의 입력은 실행하기 위한 제2 수단에 결합됨 -; 및카운터를 증분시키기 위한 수단을 더 포함하고, 상기 증분시키기 위한 수단의 출력은 상기 선택하기 위한 수단의 선택 입력에 결합되며, 상기증분시키기 위한 수단은,상기 카운터의 제1 값을 출력하여 상기 선택하기 위한 수단에게 상기 수신하기 위한 제1 수단의 상기 출력을 선택하도록 명령하고;상기 카운터의 제2 값을 출력하여 상기 선택하기 위한 수단에게 상기 수신하기 위한 제2 수단의 출력을 선택하도록 명령하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "하드웨어 가속기를 디버깅하기 위한 장치로서,적어도 하나의 메모리;상기 장치 내의 명령어들; 및프로세서 회로부를 포함하고, 상기 프로세서 회로부는 상기 명령어들을 실행하는 것 또는 인스턴스화하는 것 중 적어도 하나를하여,기계 학습 모델과 연관된 중단점을 생성하고;상기 기계 학습 모델 또는 상기 중단점 중 적어도 하나에 기초하여 실행가능 코드를 컴파일하고 - 상기 실행가능 코드는 데이터 입력에 기초하여 데이터 출력을 생성하기 위해 상기 프로세서 회로부에 의해 실행됨 -;상기 실행가능 코드의 실행에 응답하여,상기 중단점을 트리거하여 상기 실행가능 코드의 상기 실행을 중단시키고;상기 프로세서 회로부에 포함된 디버그 회로부로 상기 데이터 입력, 상기 데이터 출력 또는 상기 중단점 중 적어도 하나를 출력하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서, 상기 프로세서 회로부는,작업부하별로 트리거될 것으로 상기 중단점을 식별하고;작업부하별로 호출될 상기 실행가능 코드에 상기 중단점을 삽입하고;상기 프로세서 회로부의 제1 코어에 의한 상기 실행가능 코드의 상기 실행에 응답하여, 상기 제1 코어에 의해공개특허 10-2024-0063811-7-상기 중단점이 트리거될 때 상기 제1 코어에 의한 상기 실행가능 코드의 실행을 중단시키고;상기 프로세서 회로부의 제2 코어에 의한 상기 실행가능 코드의 상기 실행에 응답하여, 상기 제2 코어에 의해상기 중단점이 트리거될 때 상기 제2 코어에 의한 상기 실행가능 코드의 실행을 중단시키는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제15항에 있어서, 상기 프로세서 회로부는,코어별로 트리거될 것으로 상기 중단점을 식별하고;상기 프로세서 회로부의 제1 코어의 제1 구성 레지스터에 기입되고 상기 프로세서 회로부의 제2 코어의 제2 구성 레지스터에 기입되지 않을 것으로 상기 중단점을 식별하고;상기 제1 구성 레지스터에 상기 중단점을 기입하며,상기 중단점의 트리거링은 상기 제2 코어가 상기 실행가능 코드의 실행을 계속하는 동안 상기 제1 코어에 의한상기 실행가능 코드의 실행을 중단시키는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제15항에 있어서, 상기 데이터 입력은 제1 데이터를 포함하고, 상기 데이터 출력은 제2 데이터를 포함하며, 상기 프로세서 회로부는,제3 데이터에 기초하여 트리거될 것으로 상기 중단점을 식별하고;상기 제3 데이터를 상기 프로세서 회로부의 코어의 구성 레지스터에 기입하고;상기 제1 데이터와 상기 제3 데이터의 제1 비교를 실행하고 - 상기 중단점의 트리거링은 상기 제1 비교에 기초하는 상기 제1 데이터와 상기 제3 데이터의 제1 매치에 응답함 -;상기 제2 데이터와 상기 제3 데이터의 제2 비교를 실행하며,상기 중단점의 트리거링은 상기 제2 비교에 기초하는 상기 제2 데이터와 상기 제3 데이터의 제2 매치에 응답하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제15항에 있어서, 상기 프로세서 회로부는,데이터 출력과 연관된 메모리 내의 제1 어드레스에 기초하여 트리거될 것으로 상기 중단점을 식별하고;상기 프로세서 회로부의 코어의 구성 레지스터에 상기 제1 어드레스를 기입하고;상기 실행가능 코드를 실행하는 것에 응답하여, 상기 데이터 출력을 기입할 상기 메모리 내의 제2 어드레스를식별하고;상기 제1 어드레스와 상기 제2 어드레스의 비교를 실행하며,상기 중단점의 트리거링은 상기 제1 어드레스와 상기 제2 어드레스의 매치에 응답하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제15항에 있어서, 상기 데이터 입력은 제1 데이터 입력이고, 상기 프로세서 회로부는,상기 중단점의 트리거링에 응답하여, 상기 실행가능 코드의 증분 동작을 실행하는 것을 나타내는 제어 신호를획득하고 - 상기 증분 동작은 제1 값을 판독하기 위한 판독 동작, 제2 값을 기입하기 위한 기입 동작 또는 제2데이터 입력에 기초하여 제3 값을 결정하기 위한 계산 동작 중 적어도 하나를 포함함 -;상기 제1 값, 상기 제2 값 또는 상기 제3 값 중 적어도 하나를 출력하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제15항에 있어서, 상기 프로세서 회로부는,공개특허 10-2024-0063811-8-상기 중단점의 트리거링에 응답하여,상기 데이터 입력의 제1 값을 조정하는 것;상기 프로세서 회로부의 코어의 제1 레지스터의 제2 값을 조정하는 것; 또는상기 디버그 회로부의 제2 레지스터의 제3 값을 조정하는 것중 적어도 하나를 하고;상기 제1 값, 상기 제2 값, 또는 상기 제3 값 중 적어도 하나에 기초하여 상기 실행가능 코드의 상기 실행을 재개하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "명령어들을 포함하는 적어도 하나의 비일시적 컴퓨터 판독가능 매체로서,상기 명령어들은 실행될 때 제1 프로세서 회로부로 하여금 적어도:기계 학습 모델과 연관된 중단점을 생성하게 하고;상기 기계 학습 모델 또는 상기 중단점 중 적어도 하나에 기초하여 실행가능 코드를 컴파일하게 하고 - 상기 실행가능 코드는 데이터 입력에 기초하여 데이터 출력을 생성하기 위해 상기 제1 프로세서 회로부 또는 제2 프로세서 회로부에 의해 실행됨 -;상기 실행가능 코드의 실행에 응답하여,상기 중단점을 트리거하여 상기 실행가능 코드의 상기 실행을 중단시키게 하고;상기 제1 프로세서 회로부 또는 상기 제2 프로세서 회로부에 포함된 디버그 회로부로 상기 데이터 입력, 상기데이터 출력 또는 상기 중단점 중 적어도 하나를 출력하게 하는, 적어도 하나의 비일시적 컴퓨터 판독가능매체."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제22항에 있어서, 상기 명령어들은 실행될 때 상기 제1 프로세서 회로부로 하여금,작업부하별로 트리거될 것으로 상기 중단점을 식별하게 하고;작업부하별로 호출될 상기 실행가능 코드에 상기 중단점을 삽입하게 하고;상기 제1 프로세서 회로부 또는 상기 제2 프로세서 회로부의 제1 코어에 의한 상기 실행가능 코드의 상기 실행에 응답하여, 상기 제1 코어에 의해 상기 중단점이 트리거될 때, 상기 제1 코어에 의한 상기 실행가능 코드의실행을 중단시키게 하고;상기 제1 프로세서 회로부 또는 상기 제2 프로세서 회로부의 제2 코어에 의한 상기 실행가능 코드의 상기 실행에 응답하여, 상기 제2 코어에 의해 상기 중단점이 트리거될 때, 상기 제2 코어에 의한 상기 실행가능 코드의실행을 중단시키게 하는, 적어도 하나의 비일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제22항에 있어서, 상기 명령어들은 실행될 때 상기 제1 프로세서 회로부로 하여금,코어별로 트리거될 것으로 상기 중단점을 식별하게 하고;상기 제1 프로세서 회로부 또는 상기 제2 프로세서 회로부의 제1 코어의 제1 구성 레지스터에 기입되고 상기 제1 프로세서 회로부 또는 상기 제2 프로세서 회로부의 제2 코어의 제2 구성 레지스터에 기입되지 않을 것으로 상기 중단점을 식별하게 하고;상기 제1 구성 레지스터에 상기 중단점을 기입하게 하며,상기 중단점의 트리거링은 상기 제2 코어가 상기 실행가능 코드의 실행을 계속하는 동안 상기 제1 코어에 의한상기 실행가능 코드의 실행을 중단시키는, 적어도 하나의 비일시적 컴퓨터 판독가능 매체.공개특허 10-2024-0063811-9-청구항 25 제22항에 있어서, 상기 데이터 입력은 제1 데이터를 포함하고, 상기 데이터 출력은 제2 데이터를 포함하며, 상기 명령어들은 실행될 때 상기 제1 프로세서 회로부로 하여금,제3 데이터에 기초하여 트리거될 것으로 상기 중단점을 식별하게 하고;상기 제3 데이터를 상기 제1 프로세서 회로부 또는 상기 제2 프로세서 회로부의 코어의 구성 레지스터에 기입하게 하고;상기 제1 데이터와 상기 제3 데이터의 제1 비교를 실행하게 하고 - 상기 중단점의 트리거링은 상기 제1 비교에기초하는 상기 제1 데이터와 상기 제3 데이터의 제1 매치에 응답함 -;상기 제2 데이터와 상기 제3 데이터의 제2 비교를 실행하게 하며,상기 중단점의 트리거링은 상기 제2 비교에 기초하는 상기 제2 데이터와 상기 제3 데이터의 제2 매치에 응답하는, 적어도 하나의 비일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "제22항에 있어서, 상기 명령어들은 실행될 때 상기 제1 프로세서 회로부로 하여금,데이터 출력과 연관된 메모리 내의 제1 어드레스에 기초하여 트리거될 것으로 상기 중단점을 식별하게 하고;상기 제1 어드레스를 상기 제1 프로세서 회로부 또는 상기 제2 프로세서 회로부의 코어의 구성 레지스터에 기입하게 하고;상기 실행가능 코드를 실행하는 것에 응답하여, 상기 데이터 출력을 기입할 상기 메모리 내의 제2 어드레스를식별하게 하고;상기 제1 어드레스와 상기 제2 어드레스의 비교를 실행하게 하며,상기 중단점의 트리거링은 상기 제1 어드레스와 상기 제2 어드레스의 매치에 응답하는, 적어도 하나의 비일시적컴퓨터 판독가능 매체."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "제22항에 있어서, 상기 데이터 입력은 제1 데이터 입력이고, 상기 명령어들은 실행될 때 상기 제1 프로세서 회로부로 하여금,상기 중단점의 트리거링에 응답하여, 상기 실행가능 코드의 증분 동작을 실행하는 것을 나타내는 제어 신호를획득하게 하고 - 상기 증분 동작은 제1 값을 판독하기 위한 판독 동작, 제2 값을 기입하기 위한 기입 동작, 또는 제2 데이터 입력에 기초하여 제3 값을 결정하기 위한 계산 동작 중 적어도 하나를 포함함 -;상기 제1 값, 상기 제2 값 또는 상기 제3 값 중 적어도 하나를 출력하게 하는, 적어도 하나의 비일시적 컴퓨터판독가능 매체."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "제22항에 있어서, 상기 명령어들은 실행될 때 상기 제1 프로세서 회로부로 하여금,상기 중단점의 트리거링에 응답하여,상기 데이터 입력의 제1 값을 조정하는 것;상기 제1 프로세서 회로부 또는 상기 제2 프로세서 회로부의 코어의 제1 레지스터의 제2 값을 조정하는 것; 또는상기 디버그 회로부의 제2 레지스터의 제3 값을 조정하는 것중 적어도 하나를 하게 하고;상기 제1 값, 상기 제2 값 또는 상기 제3 값 중 적어도 하나에 기초하여 상기 실행가능 코드의 상기 실행을 재개하게 하는, 적어도 하나의 비일시적 컴퓨터 판독가능 매체.공개특허 10-2024-0063811-10-청구항 29 하드웨어 가속기를 디버깅하기 위한 장치로서,기계 학습 모델을 획득하기 위한 제1 인터페이스 회로부; 및프로세서 회로부를 포함하고, 상기 프로세서 회로부는,중앙 처리 유닛, 그래픽 처리 유닛 또는 디지털 신호 프로세서 중 적어도 하나 - 상기 중앙 처리 유닛, 상기 그래픽 처리 유닛 또는 상기 디지털 신호 프로세서 중 상기 적어도 하나는 상기 프로세서 회로부 내의 데이터 이동을 제어하기 위한 제어 회로부, 명령어들에 대응하는 하나 이상의 제1 동작을 수행하기 위한 산술 및 논리 회로부, 및 상기 하나 이상의 제1 동작의 결과를 저장하기 위한 하나 이상의 레지스터를 가지며, 상기 명령어들은상기 장치 내에 있음 -;필드 프로그래머블 게이트 어레이(FPGA) - 상기 FPGA는 논리 게이트 회로부, 복수의 구성 가능한 상호접속, 및저장 회로부를 포함하고, 상기 논리 게이트 회로부 및 상호접속들은 하나 이상의 제2 동작을 수행하고, 상기 저장 회로부는 상기 하나 이상의 제2 동작의 결과를 저장함 -; 또는하나 이상의 제3 동작을 수행하기 위한 논리 게이트 회로부를 포함하는 주문형 집적 회로부(ASIC)중 하나 이상을 포함하며;상기 프로세서 회로부는 상기 제1 동작들, 상기 제2 동작들 또는 상기 제3 동작들 중 적어도 하나를 수행하여,데이터 입력에 기초하여 데이터 출력을 생성하기 위한 실행가능 코드를 실행하기 위한 코어 회로부 - 상기 실행가능 코드는 상기 기계 학습 모델에 기초함 -;상기 데이터 입력 또는 상기 데이터 출력 중 적어도 하나를 수신하기 위한 제2 인터페이스 회로부;상기 제2 인터페이스 회로부를 선택하기 위한 멀티플렉서 회로부; 및상기 실행가능 코드의 실행과 연관된 중단점의 트리거에 응답하여 상기 데이터 입력 또는 상기 데이터 출력 중상기 적어도 하나를 출력하기 위한 시프트 레지스터를 인스턴스화하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "제29항에 있어서, 상기 제2 인터페이스 회로부는 메모리로부터 상기 데이터 입력을 수신하고, 상기 프로세서 회로부는 상기 제1 동작들, 상기 제2 동작들, 또는 상기 제3 동작들 중 적어도 하나를 수행하여,상기 중단점이 트리거되지 않는 것에 응답하여, 상기 제2 인터페이스 회로부로부터 상기 데이터 입력을 수신하고; 상기 데이터 입력을 상기 코어 회로부로 출력하기 위한 버퍼를 인스턴스화하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "제29항에 있어서, 상기 제2 인터페이스 회로부는 상기 코어 회로부로부터 상기 데이터 출력을 수신하고, 상기프로세서 회로부는 상기 제1 동작들, 상기 제2 동작들, 또는 상기 제3 동작들 중 적어도 하나를 수행하여,상기 중단점이 트리거되지 않는 것에 응답하여, 상기 제2 인터페이스 회로부로부터 상기 데이터 출력을 수신하고; 상기 데이터 출력을 메모리로 출력하기 위한 버퍼를 인스턴스화하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제29항에 있어서, 상기 제2 인터페이스 회로부는 메모리로부터 상기 데이터 입력을 수신하고, 상기 프로세서 회로부는 상기 제1 동작들, 상기 제2 동작들, 또는 상기 제3 동작들 중 적어도 하나를 수행하여,상기 중단점이 트리거되지 않는 것에 응답하여, 상기 제2 인터페이스 회로부로부터 상기 데이터 입력을 수신하공개특허 10-2024-0063811-11-고; 상기 데이터 입력을 상기 코어 회로부로 출력하기 위한 버퍼; 및상기 중단점의 트리거에 응답하여 상기 데이터 입력 또는 상기 데이터 출력 중 상기 적어도 하나를 출력하거나;상기 중단점이 트리거되지 않는 것에 응답하여 상기 데이터 출력을 상기 메모리로 출력하기 위한 디버그 회로부를 인스턴스화하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "제32항에 있어서, 상기 디버그 회로부는 상기 코어 회로부에 포함되는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제29항에 있어서, 상기 데이터 입력 또는 상기 데이터 출력 중 상기 적어도 하나는 제1 값을 포함하고, 상기 프로세서 회로부는 상기 제1 동작들, 상기 제2 동작들 또는 상기 제3 동작들 중 적어도 하나를 수행하여,상기 중단점에 대응하는 제2 값을 저장하기 위한 구성 레지스터; 및비교기 회로부를 인스턴스화하며, 상기 비교기 회로부는,상기 제1 값과 상기 제2 값을 비교하고;상기 제2 인터페이스 회로부에게 상기 비교에 기초하는 상기 제1 값과 상기 제2 값의 매치에 응답하여 상기 데이터 입력 또는 상기 데이터 출력 중 상기 적어도 하나를 상기 멀티플렉서 회로부에 제공하도록 명령하며, 상기중단점의 트리거링은 상기 매치에 응답하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "제29항에 있어서, 상기 코어 회로부는 제1 코어 회로부이고, 상기 프로세서 회로부는 상기 제1 동작들, 상기 제2 동작들, 또는 상기 제3 동작 중 적어도 하나를 수행하여,카운터 회로부를 인스턴스화하며, 상기 카운터 회로부는,제1 값을 출력하여 상기 멀티플렉서 회로부에게 상기 제2 인터페이스 회로부의 출력을 선택하도록 명령하고;제2 값을 출력하여 상기 멀티플렉서 회로부에게 제2 코어 회로부와 연관된 제3 인터페이스 회로부의 출력을 선택하도록 명령하는, 장치."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "하드웨어 가속기를 디버깅하기 위한 방법으로서,기계 학습 모델과 연관된 중단점을 생성하는 단계;상기 기계 학습 모델 또는 상기 중단점 중 적어도 하나에 기초하여 실행가능 코드를 컴파일하는 단계 - 상기 실행가능 코드는 데이터 입력에 기초하여 데이터 출력을 생성하기 위해 가속기 회로부에 의해 실행됨 -;상기 실행가능 코드의 실행에 응답하여,상기 중단점을 트리거하여 상기 실행가능 코드의 상기 실행을 중단시키는 단계; 및상기 가속기 회로부에 포함된 디버그 회로부로 상기 데이터 입력, 상기 데이터 출력 또는 상기 중단점 중 적어도 하나를 출력하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "제36항에 있어서,작업부하별로 트리거될 것으로 상기 중단점을 식별하는 단계;공개특허 10-2024-0063811-12-작업부하별로 호출될 상기 실행가능 코드에 상기 중단점을 삽입하는 단계;상기 가속기 회로부의 제1 코어에 의한 상기 실행가능 코드의 상기 실행에 응답하여, 상기 중단점이 상기 제1코어에 의해 트리거될 때, 상기 제1 코어에 의한 상기 실행가능 코드의 실행을 중단시키는 단계; 및상기 가속기 회로부의 제2 코어에 의한 상기 실행가능 코드의 상기 실행에 응답하여, 상기 중단점이 상기 제2코어에 의해 트리거될 때, 상기 제2 코어에 의한 상기 실행가능 코드의 실행을 중단시키는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "제36항에 있어서,코어별로 트리거될 것으로 상기 중단점을 식별하는 단계;상기 가속기 회로부의 제1 코어의 제1 구성 레지스터에 기입되고 상기 가속기 회로부의 제2 코어의 제2 구성 레지스터에 기입되지 않을 것으로 상기 중단점을 식별하는 단계; 및상기 제1 구성 레지스터에 상기 중단점을 기입하는 단계를 더 포함하고, 상기 중단점의 트리거링은 상기 제2 코어가 상기 실행가능 코드의 실행을 계속하는 동안 상기제1 코어에 의한 상기 실행가능 코드의 실행을 중단시키는, 방법."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_39", "content": "제36항에 있어서, 상기 데이터 입력은 제1 데이터를 포함하고, 상기 데이터 출력은 제2 데이터를 포함하며, 상기 방법은,제3 데이터에 기초하여 트리거될 것으로 상기 중단점을 식별하는 단계;상기 제3 데이터를 상기 가속기 회로부의 코어의 구성 레지스터에 기입하는 단계;상기 제1 데이터와 상기 제3 데이터의 제1 비교를 실행하는 단계 - 상기 중단점의 트리거링은 상기 제1 비교에기초하는 상기 제1 데이터와 상기 제3 데이터의 제1 매치에 응답함 -; 및상기 제2 데이터와 상기 제3 데이터의 제2 비교를 실행하는 단계를 더 포함하며, 상기 중단점의 트리거링은 상기 제2 비교에 기초하는 상기 제2 데이터와 상기 제3 데이터의 제2 매치에 응답하는, 방법."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "제36항에 있어서,상기 데이터 출력과 연관된 메모리 내의 제1 어드레스에 기초하여 트리거될 것으로 상기 중단점을 식별하는 단계;상기 제1 어드레스를 상기 가속기 회로부의 코어의 구성 레지스터에 기입하는 단계;상기 실행가능 코드를 실행하는 것에 응답하여, 상기 데이터 출력을 기입할 상기 메모리 내의 제2 어드레스를식별하는 단계; 및상기 제1 어드레스와 상기 제2 어드레스의 비교를 실행하는 단계를 더 포함하고, 상기 중단점의 트리거링은 상기 제1 어드레스와 상기 제2 어드레스의 매치에 응답하는, 방법."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "제36항에 있어서, 상기 데이터 입력은 제1 데이터 입력이고, 상기 방법은,상기 중단점의 트리거링에 응답하여, 상기 실행가능 코드의 증분 동작을 실행하는 것을 나타내는 제어 신호를획득하는 단계 - 상기 증분 동작은 제1 값을 판독하기 위한 판독 동작, 제2 값을 기입하기 위한 기입 동작, 또는 제2 데이터 입력에 기초하여 제3 값을 결정하기 위한 계산 동작 중 적어도 하나를 포함함 -; 및공개특허 10-2024-0063811-13-상기 제1 값, 상기 제2 값 또는 상기 제3 값 중 적어도 하나를 출력하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2023-7044126", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "제36항에 있어서,상기 중단점의 트리거링에 응답하여,상기 데이터 입력의 제1 값을 조정하는 것;상기 가속기 회로부의 코어의 제1 레지스터의 제2 값을 조정하는 것; 또는상기 디버그 회로부의 제2 레지스터의 제3 값을 조정하는 것중 적어도 하나를 하는 단계; 및상기 제1 값, 상기 제2 값 또는 상기 제3 값 중 적어도 하나에 기초하여 상기 실행가능 코드의 상기 실행을 재개하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2023-7044126", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "인공 지능 계산 작업부하들을 실행하기 위한 신경망 가속기와 같은 하드웨어 가속기를 디버깅하기 위한 방법들, 장치들, 시스템들 및 제조 물품들이 개시된다. 예시적인 장치는 데이터 입력에 기초하여 데이터 출력을 생성하 기 위해 기계 학습 모델에 기초하는 실행가능 코드를 실행하기 위한 코어 입력 및 코어 출력을 갖는 코어, 및 코 어에 결합된 디버그 회로부를 포함한다. 디버그 회로부는 기계 학습 모델과 연관된 중단점을 검출하고, 기계 학 습 모델 또는 중단점 중 적어도 하나에 기초하여 실행가능 코드를 컴파일하도록 구성된다. 중단점의 트리거링에 응답하여, 디버그 회로부는 실행가능 코드의 실행을 중단시키고, 하드웨어 가속기를 디버깅하기 위한 데이터 입 력, 데이터 출력 및 중단점과 같은 데이터를 출력한다."}
{"patent_id": "10-2023-7044126", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 일반적으로 하드웨어 가속기들에 관한 것으로서, 보다 상세하게는 하드웨어 가속기들을 디버깅하기 위한 시스템들, 장치들 및 방법들에 관한 것이다."}
{"patent_id": "10-2023-7044126", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "최근에, 인공 지능/기계 학습 및 이미지 처리 능력과 같은 계산 집약적인 처리 능력에 대한 요구는 고전력 전용 데스크톱 하드웨어를 넘어 개인용 그리고/또는 그 외의 모바일 디바이스들에 대한 기대치가 되었다. 하드웨어 가속기들은 이러한 능력을 구현하기 위해 그러한 디바이스들에 포함될 수 있다. 그러한 하드웨어 가속기들을 디버깅하는 것은 시간 소모적이고 복잡한 작업이다."}
{"patent_id": "10-2023-7044126", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "도면들은 비례에 맞지 않는다. 일반적으로, 도면(들) 및 첨부된 서면 설명 전체에서 동일하거나 유사한 부분들 을 지칭하기 위해 동일한 참조 번호들이 사용될 것이다. 본 명세서에서 사용되는 바와 같이, 접속 참조들(예를 들어, 부착, 결합, 접속 및 연결)은 달리 표시되지 않는 한 접속 참조에 의해 참조되는 요소들 사이의 중간 부 재들 및/또는 그러한 요소들 사이의 상대적 이동을 포함할 수 있다. 따라서, 접속 참조들은 반드시 2개의 요소 가 서로 직접 접속되고/되거나 고정된 관계에 있다고 유추할 필요는 없다. 본 명세서에서 사용되는 바와 같이, 임의의 부분이 다른 부분과 \"접촉\"한다고 말하는 것은 두 부분 사이에 중간 부분이 존재하지 않는다는 것을 의 미하는 것으로 정의된다. 구체적으로 달리 언급되지 않는 한, \"제1 \", \"제2\", \"제3\" 등과 같은 서술자들은 본 명세서에서 우선순위, 물리 적 순서, 목록에서의 배열 및/또는 임의의 방식으로의 순서화의 임의의 의미를 부여하거나 달리 나타내지 않고 사용되지만, 개시된 예들을 쉽게 이해할 수 있도록 요소들을 구별하기 위한 라벨들 및/또는 임의의 명칭들로 사 용될 뿐이다. 일부 예들에서, \"제1\"이라는 설명자는 상세한 설명에서 요소를 지칭하는 데 사용될 수 있는 반면, 동일한 요소는 청구항에서 \"제2\" 또는 \"제3\"과 같은 상이한 설명자로 지칭될 수 있다. 그러한 경우들에 서, 그러한 설명자들은 예를 들어 동일한 명칭을 달리 공유할 수 있는 요소들을 명확하게 식별하기 위해 사용될 뿐이라는 것을 이해해야 한다. 본 명세서에서 사용되는 바와 같이, \"통신하는\"이라는 문구는 그 변형들을 포함하여 직접 통신 및/또는 하나 이 상의 중개 컴포넌트를 통한 간접 통신을 포함하며, 직접적인 물리적(예를 들어, 유선) 통신 및/또는 지속적인 통신을 필요로 하는 것이 아니라, 오히려 주기적 간격, 스케줄링된 간격, 비주기적 간격 및/또는 일회성 이벤트 의 선택적 통신을 추가로 포함한다. 본 명세서에서 사용되는 바와 같이, \"프로세서 회로부\"는 (i) 특정 동작(들)을 수행하도록 구조화되고 하나 이 상의 반도체 기반 논리 디바이스(예를 들어, 하나 이상의 트랜지스터로 구현된 전기 하드웨어)를 포함하는 하나 이상의 특수 목적 전기 회로 및/또는 (ii) 특정 동작들을 수행하도록 명령어들로 프로그래밍되고 하나 이상의 반도체 기반 논리 디바이스(예를 들어, 하나 이상의 트랜지스터로 구현된 전기 하드웨어)를 포함하는 하나 이상 의 범용 반도체 기반 전기 회로를 포함하는 것으로 정의된다. 프로세서 회로부의 예들은 프로그래밍된 마이크 로프로세서, 명령어들을 인스턴스화할 수 있는 필드 프로그래머블 게이트 어레이(FPGA), 중앙 프로세서 유닛 (CPU), 그래픽 프로세서 유닛(GPU), 디지털 신호 프로세서(DSP), XPU 또는 마이크로컨트롤러 및 주문형 집적 회 로(ASIC)와 같은 집적 회로를 포함한다. 예를 들어, XPU는 여러 유형의 프로세서 회로부(예를 들어, 하나 이상의 FPGA, 하나 이상의 CPU, 하나 이상의 GPU, 하나 이상의 DSP 등 및/또는 이들의 조합) 및 여러 처리 회로부 유형 중에서 컴퓨팅 작업(들)을 실행하는 데 가장 적합한 어느 유형(들)에 컴퓨팅 작업(들)을 할당할 수 있는 애플리케이션 프로그래밍 인터페이스(API)(들)를 포함하는 이종 컴퓨팅 시스템에 의해 구현될 수 있다. 개인용 컴퓨터들 및/또는 모바일 디바이스들을 포함하는 통상적인 컴퓨팅 시스템들은 고급 이미지 처리 또는 컴 퓨터 비전 알고리즘들과 같은 계산 집약적인 작업들을 구현하여 사람의 비전이 수행할 수 있는 작업들을 자동화 한다. 예를 들어, 컴퓨터 비전 작업들은 디지털 이미지들의 획득, 처리, 분석 및/또는 이해를 포함할 수 있다. 일부 이러한 작업들은 부분적으로는 디지털 이미지들로부터 차원 데이터를 추출하여 숫자 및/또는 기호 정보를 생성하는 것을 용이하게 한다. 컴퓨터 비전 알고리즘들은 숫자 및/또는 기호 정보를 사용하여, 특히 3차원(3- D) 포즈 추정, 이벤트 검출, 객체 인식, 비디오 추적 등과 연관된 결정들을 내리고/내리거나 연관된 동작들을 달리 수행할 수 있다. 따라서, 증강 현실(AR), 가상 현실(VR), 로보틱스 및/또는 다른 응용들을 지원하려면, 이러한 작업들을 신속하고(예를 들어, 실질적으로 실시간 또는 거의 실시간으로) 효율적으로 수행하는 것이 중 요하며, 이러한 작업들은 본 명세서에 개시된 바와 같은 예시적인 하드웨어 가속기들에 의해 실행된다. 고급 이미지 처리 또는 컴퓨터 비전 알고리즘들과 같은 계산 집약적인 작업들은 신경망(예를 들어, 컨볼루션 신 경망(CNN, 또는 ConvNet))과 같은 인공 지능/기계 학습(AI/ML) 모델을 이용하여 구현될 수 있다. CNN과 같은 신경망은 컨볼루션을 사용하여 이미지들 내에서 객체 인식을 수행하는 데에, 유사성에 의해 이미지들을 클러스 터링(예를 들어, 사진 검색)하는 데에, 및/또는 이미지들을 분류하는 데에 통상적으로 사용되는 심층 인공 신경 망(ANN)이다. 따라서, 신경망은 입력 이미지 내에서 이미지 특징의 매치들을 식별하기 위해 입력 이미지를 통 해 이미지 특징(예를 들어, 수평선, 2차원(2-D) 형상 등)에 대응하는 하나 이상의 필터의 출력을 전달함으로써 입력 이미지에 포함된 얼굴, 개인, 도로 표지판, 동물 등을 식별하는 데 사용될 수 있다. 본 명세서에 개시된 예시적인 하드웨어 가속기는 상당한 양의 입력들(예를 들어, AI/ML 입력들)을 처리하여 식별들을 달성하는 데 사용될 수 있는 출력들(예를 들어, AI/ML 출력들)을 생성함으로써 이러한 식별들을 달성할 수 있다. 신경망들을 구현하기 위해 주문화, 맞춤화, 및/또는 달리 최적화된 하드웨어 가속기들은 신경망 가속기들로 지 칭된다. 다른 유형의 AI/ML 가속기들이 특정 유형의 AI/ML 모델의 성능을 개선할 수 있다. 이러한 신경망 가 속기들, 및/또는 보다 일반적으로, 하드웨어 가속기들은 AI/ML 모델이 구현될 수 있는 효율성 및 성능을 개선하 고/하거나 달리 최적화하려는 노력으로 디버깅하기가 점점 더 복잡해지고 있다. 하드웨어 가속기의 디버깅은 AI/ML 데이터 세트들의 스케일이 증가함에 따라 점점 더 시간 소모적이고 복잡한 작업이다. 디버깅은 하드웨어 가속기의 출력이 예상되지 않은 예들에서, 또는 하드웨어 가속기 및/또는 입력의 특정 구성(예를 들어, 구성 이 미지)이 하드웨어 가속기의 시스템 지연(system hang) 또는 파이프라인 중단을 유발할 수 있는 예들에서 이용된 다. 디버깅은 하드웨어 가속기의 성능을 개선시키기 위해 이용될 수도 있다. 예를 들어, 신경망 가속기에 의해 실 행되는 초당 프레임 수를 개선하려면 파이프라인 또는 처리 병목들을 식별하기 위해 상당한 양의 컴파일러 조정 및 수정이 필요할 수 있다. 본 명세서에 개시된 예들은 통상적인 하드웨어 디버깅 패러다임을 변화시킨다. 예 를 들어, 디버깅 하드웨어는 통상적으로 각각의 디버깅 명령어가 수 개의 작은 피연산자에 대해서만 작동하는 비교적 긴 프로그램들을 실행하는 종래의 마이크로프로세서 아키텍처들을 위해 설계된다. 그러나, 그래픽 프로 세서 유닛(GPU)들 및 신경망 가속기들과 같은 하드웨어 가속기들의 출현으로, 디버깅 명령어들과 피연산자들 간 의 비율이 역전된다. 예를 들어 하드웨어 가속기들은 디버깅 목적들을 위한 전용 하드웨어 지원을 갖지 않는다. 일부 이러한 예들에서, 하드웨어 가속기들을 디버깅하기 위한 소프트웨어 애플리케이션들(예를 들어, 소프트웨어 디버거들)은 비교적 작은 프로그램들을 실행하도록 설계될 수 있지만, 각각의 디버깅 명령어가 동작 하는 피연산자들(예를 들어, CNN의 예에서 텐서들)의 수는 상당히 많다. 전용 하드웨어 디버깅 능력이 없으면, 하드웨어 가속기를 디버깅하는 데 필요한 시간이 기하급수적으로 늘어날 수 있다. 예를 들어, 입력 이미지의 크기가 224x224x3(예를 들어, 150,000개 입력)인 ResNet-50 신경망을 통한 단일 패스는 단일 출력을 생성하기 위해 네트워크의 50개 계층을 트래버스하는 10,500,000개 이상의 활성화를 생성한다. 그러나 더 새로운 신경망 아키텍처들은 훨씬 더 높은 복잡도를 가질 수 있으므로, 아키텍처의 50개 보다 많은 계층에 걸친 10,500,000개보다 많은 활성화를 생성할 수 있다. 일부 이러한 예들에서, 50개 계층에 걸쳐 퍼져 있는 10,500,000개 크기의 숫자들의 세트에서 에러를 찾으려고 시도하는 것은 특히 네트워크 실행이 다수의 더 작은 작업부하로 분할되어야 하는 경우에 점점 더 어렵고 시간 소모적인 노력이다. 작업부하들(예를 들어, 하드웨어 가속기 작업부하들, AI/ML 작업부하들 등)이 병렬로 작동 또는 실행되도록 다수의 코어(예를 들 어, 하드웨어 가속기 코어)에 의한 실행을 위해 스케줄링되는 예들에서는 추가적인 디버깅 어려움이 발생한다. 일부 이러한 예들에서, 코어 상호 작용 및 작업부하 동기화로 인한 에러들에 대한 가능성은 다수의 코어가 병렬로 작동할 때 상당히 높다. 결과적으로, AI/ML 모델의 실행과 연관된 버그들, 에러들 등을 식별하는 것은 생성된 출력의 검사를 통해 하드 웨어 가속기의 구성 또는 다른 문제들을 지루하게 추론하기 위한 인원을 필요로 할 수 있다. 유리하게, 본 명 세서에 개시된 예들은 버그들을 찾고/찾거나 성능 병목들을 격리하기 위해 하드웨어 가속기 실행들을 통한 개선 된 데이터 중심 기동성(data-centric maneuverability)을 이용함으로써 하드웨어 가속기들을 디버깅하기 위한 시스템들, 장치들, 방법들 및 제조 물품들을 포함한다. 본 명세서에 개시된 예들은 성능의 개선 및 잘못된 출력 생성의 감소를 위해 하드웨어 가속기들을 디버깅하기 위한 시스템들, 장치들, 방법들 및 제조 물품들을 포함한다. 일부 개시된 예들에서, 하드웨어 가속기는 지정된 중단점들에서 하드웨어 가속기의 출력을 중단시키고 하나 이상의 후속 출력 트랜잭션을 통해 단일-스테핑 (single-stepping)하도록 인스턴스화될 수 있는 예시적인 디버그 회로부(또는 디버거 회로부)를 포함한다. 일 부 개시된 예들에서, 예시적인 디버그 애플리케이션(또는 디버거 애플리케이션)은 디버그 회로부, 및/또는 보다 일반적으로, 하드웨어 가속기를 프로그래밍 및/또는 인스턴스화하여, 하나의 특정한 생성된 데이터의 검출에 응 답하여 그리고/또는 출력 트랜잭션이 특정 어드레스 및/또는 어드레스 범위와 연관된다는 결정에 응답하여, 작 업부하별로, 코어별로 AI/ML 모델의 실행을 중단시킬 수 있다. 일부 개시된 예들에서, 디버그 회로부는 AI/ML 모델의 실행 동안에 지정된 시점에 생성되는 데이터를 식별하기 위해 출력 트랜잭션(예를 들어, 그와 같이 인스 턴스화되는 경우 모든 출력 트랜잭션)의 판독을 출력할 수 있다. 일부 예들에서, 하드웨어 가속기 작업부하 구성에서 어드레스 공간들이 잘못 겹치는 경우, 출력 데이터가 덮어 쓰기될 수 있다. 단일 작업부하로부터의 많은 상이한 출력 스트림 및 상이한 코어들로부터의 상이한 작업부하 들이 병렬로 실행되는 경우, 의도하지 않은 덮어쓰기들의 가능성이 증가한다. 일부 이러한 예들에서는 소프트 웨어 디버거를 사용하여, 생성된 출력들 및 근본 원인 문제들을 분석할 수 있지만, 이러한 노력들은 어렵고 상 당한 시간을 소비한다. 유리하게, 본 명세서에 개시된 예시적인 디버그 회로부는 이러한 노력들의 어려움 및 시간 소비를 감소시킨다. 일부 예들에서는, 잘못된 구성으로 인해, 가속기 출력이 실제 프로비저닝된 가속기 메모리 외부의 완전히 상이 한 어드레스 공간으로 전송될 수 있다. 소프트웨어 디버거는 출력이 전송되는 어드레스가 알려지지 않는 경우 출력을 찾지 못할 수 있다. 예를 들어, 소프트웨어 디버거는 메모리 내용물들을 분석할 수 있지만, 메모리 내 용물이 예상과 다르거나 아직 기입되지 않은 경우, 소프트웨어 디버거는 메모리 트랜잭션들이 발행되었는지 또 는 메모리 트랜잭션들이 관찰 가능한 어드레스 공간 외부의 잘못된 어드레스로 발행되었는지를 결정하지 못할 수 있다. 유리하게, 본 명세서에 개시된 예시적인 디버그 회로부는 이러한 결함들을 극복한다. 일부 예들에서, 기계 학습 모델은 문제에 대한 이해를 높이고 문제의 근본 원인을 정확히 찾아내기 위해 컴파일 러 소프트웨어의 변경을 통해 수정되어야 한다. 그러나, 디버깅 목적들을 위해 소프트웨어에서 맞춤 수정들을 구현해야 하는 것은 특히 병렬 코어 실행으로 인해서만 문제가 발생하는 경우 극히 시간 소모적이다. 유리하게, 본 명세서에 개시된 예시적인 디버그 회로부는 이러한 결함들을 극복한다. 일부 예들에서, 분석할 수백만 개의 출력 포인트를 갖는 네트워크 실행 동안 생성되고 있는 하나의 특정한 잘못 된 데이터를 격리시켜야 하는 것은 특정 데이터 피스(piece of data)를 자동으로 검출하고, 실행을 중단시키고, 추가 명령을 위해 사용자에게 시그널링할 수 있는 하드웨어 지원이 존재하지 않는 경우, 지루한 작업일 수 있다. 이러한 일부 예에서는, 하드웨어 가속기에 특정 어드레스들 또는 어드레스 범위들에 대한 기입들을 검출 하는 능력이 없을 수 있으므로, 예상치 못한 기입들을 격리시킬 때 결함들이 발생한다. 유리하게, 본 명세서에 개시된 예시적인 디버그 회로부는 이러한 결함들을 극복한다. 도 1은 예시적인 중앙 처리 유닛(CPU), 예시적인 필드 프로그래머블 게이트 어레이(FPGA), 예시적인 제1 가속기 회로부(가속기 회로부 A에 의해 식별됨) 및 예시적인 제2 가속기 회로부(가속기 회로부 B 에 의해 식별됨)를 포함하는 예시적인 컴퓨팅 시스템을 포함하는 예시적인 컴퓨팅 환경의 예시이다. 예시된 예에서, 제1 가속기 회로부 및 제2 가속기 회로부는 예시적인 디버그 회로부를 포함한다. 예시된 예에서, CPU 및 FPGA는 예시적인 디버그 애플리케이션(디버그 앱에 의해 식 별됨)을 포함하고/하거나 달리 인스턴스화한다. 이 예에서, 컴퓨팅 시스템은 예시적인 인터페이스 회로부 , 예시적인 메모리, 예시적인 전원, 및 예시적인 데이터 저장소를 포함한다. 예시된 예에서, 데이터 저장소는 예시적인 기계 학습(ML) 모델(들) 및 예시적인 중단점(들)을 포함한다. 예를 들어, ML 모델(들)은 하나 이상의 ML 모델을 포함할 수 있고, ML 모델들 중 하나(들)는서로 상이한 유형들일 수 있다. 중단점(들)은 디버그 회로부 및/또는 보다 일반적으로 제1 가속기 회로부 및/또는 제2 가속기 회로부에 의해 트리거, 활성화, 및/또는 달리 호출될 때, ML모델 (들) 중 하나에 대응하는 실행가능 바이너리, 실행가능 코드(예를 들어, 실행가능 기계 판독가능 코드), 실행가능 파일(예를 들어, 실행가능 바이너리 파일), 실행가능 프로그램, 실행가능 명령어들(예를 들어, 실행가 능 기계 판독가능 명령어들) 등에 의해 구현될 수 있는 실행가능물(executable)의 실행을 중단시킬 수 있는 하 나 이상의 중단점을 포함할 수 있다. 일부 예들에서, 중단점(들)은 작업부하의 시작에 대한 중단점, 기입 되고 있거나 기입될 프로세스에서의 특정 데이터 항목에 대한 중단점, 기입되는 특정 어드레스 또는 어드레스 범위에 대한 중단점, 메모리로부터 가속기 회로부(108, 110) 내로 판독되고 있는 특정 데이터 항목에 대한 중단점, 메모리로부터 판독되고 있는 특정 어드레스 또는 어드레스 범위에 대한 중단점, 가속기 회로부 (108, 110)에 대한 특정 내부 데이터 항목의 생성에 대한 중단점 등을 포함할 수 있다. 도 1의 예시된 예에서, CPU, FPGA, 제1 가속기 회로부, 제2 가속기 회로부, 디버그 회로 부, 디버그 애플리케이션, 인터페이스 회로부, 메모리, 전원 및 데이터 저장소 는 예시적인 버스를 통해 서로 중 하나(들)와 통신한다. 예를 들어, 버스는 I2C(Inter-Integrated Circuit) 버스, SPI(Serial Peripheral Interface) 버스, PCI(Peripheral Component Interconnect) 버스 또는 PCIe(Peripheral Component Interconnect express) 버스 중 적어도 하나로 구현될 수 있다. 추가적으로 또는 대안적으로, 버스는 임의의 다른 유형의 컴퓨팅 또는 전기 버스로 구현될 수 있다. 컴퓨팅 환경에는 예시적인 사용자 인터페이스, 예시적인 네트워크, 및 예시적인 외부 컴퓨팅 시스템이 더 도시되 어 있다. 일부 예들에서, 컴퓨팅 시스템은 컴퓨터 또는 다른 전자 시스템의 컴포넌트들을 컴팩트 포맷으로 통합하는 하나 이상의 집적 회로(IC)(예를 들어, 컴팩트 IC)를 나타내는 시스템 온 칩(SoC)이다. 예를 들어, 컴퓨팅 시 스템은 하나 이상의 유형의 프로세서 회로부, 하드웨어 논리, 및/또는 하드웨어 주변기기들 및/또는 인터 페이스들의 조합으로 구현될 수 있다. 추가적으로 또는 대안적으로, 컴퓨팅 시스템은 입력/출력(I/O) 포 트(들) 및/또는 보조 저장소를 포함할 수 있다. 예를 들어, 컴퓨팅 시스템은 CPU, FPGA, 제1 가속기 회로부, 제2 가속기 회로부, 디버그 회로부, 인터페이스 회로부, 메모리, 전 원, 데이터 저장소, 버스, I/O 포트(들), 및/또는 보조 저장소를 모두 동일한 기판(예를 들어, 실리콘 기판, 반도체 기반 기판 등) 상에 포함할 수 있다. 일부 예들에서, 컴퓨팅 시스템은 디지털, 아날 로그, 혼합 신호, 무선 주파수(RF), 또는 다른 신호 처리 기능들을 포함한다. 도 1의 예의 FPGA는 FPLD(field programmable logic device)이다. 예를 들어, 일단 구성되면, FPGA(10 6)는 디버그 애플리케이션을 인스턴스화할 수 있다. 대안적으로, FPGA, 제1 가속기 회로부, 및 /또는 제2 가속기 회로부 중 하나 이상은 디지털 신호 프로세서(DSP), 주문형 집적 회로(ASIC), 및/또는 프로그래머블 논리 디바이스(PLD)와 같은 상이한 유형의 하드웨어일 수 있다. 도 1의 예시된 예에서, 제1 가속기 회로부는 인공 지능(AI) 가속기이다. 예를 들어, 제1 가속기 회로부 는 신경망들(예를 들어, 컨볼루션 신경망(CNN), 심층 신경망(DNN), 인공 신경망(ANN) 등), 기계 비전, 기 계 학습 등과 같이 AI 작업들 또는 작업부하들을 가속화하도록 구성되는 하드웨어 가속기를 구현할 수 있다. 일부 예들에서, 제1 가속기 회로부는 희소 가속기(sparse accelerator)(예를 들어, 희소 하드웨어 가속 기)를 구현할 수 있다. 일부 예들에서, 제1 가속기 회로부는 기계 또는 컴퓨터 비전 컴퓨팅 작업들을 실 현하고/하거나 신경망을 훈련 및/또는 실행하기 위해 비전 처리 유닛(VPU)을 구현할 수 있다. 일부 예들에서, 제1 가속기 회로부는 CNN, DNN, ANN, RNN(recurrent neural network) 등 및/또는 이들의 조합을 훈련 및/ 또는 실행할 수 있다. 도 1의 예시된 예에서, 제2 가속기 회로부는 GPU(graphics processor unit)이다. 예를 들어, 제2 가속기 회로부는 컴퓨터 그래픽을 생성하고, 범용 컴퓨팅을 실행하고, 벡터 작업부하 등을 실행하는 GPU일 수 있 다. 일부 예들에서, 제2 가속기 회로부는 제1 가속기 회로부의 다른 인스턴스이다. 예를 들어, 제2 가속기 회로부는 AI 가속기일 수 있다. 일부 이러한 예들에서, 컴퓨팅 시스템(또는 CPU와 같은 그의 부분(들))은 제1 가속기 회로부 및 제2 가속기 회로부에 의해 병렬로 실행될 AI/ML 작업부하들 의 부분(들)을 제공할 수 있다. 도 1의 예시된 예에서, 인터페이스 회로부는 하나 이상의 인터페이스(예를 들어, 컴퓨팅 인터페이스, 네트 워크 인터페이스 등)를 구현할 수 있는 하드웨어이다. 예를 들어, 인터페이스 회로부는 네트워크를 통한 외부 기계들(예를 들어, 임의의 종류의 컴퓨팅 디바이스들)과의 데이터의 교환을 용이하게 하기 위한 송신기, 수신기, 송수신기, 모뎀, 주거용 게이트웨이, 무선 액세스 포인트, 및/또는 네트워크 인터페이스와 같은 통 신 디바이스(예를 들어, 네트워크 인터페이스 카드(NIC), 스마트 NIC, 게이트웨이, 스위치 등)를 구현하는 하드 웨어, 소프트웨어 및/또는 펌웨어일 수 있다. 일부 예들에서, 인터페이스 회로부는 블루투스® 접속, 이 더넷 접속, DSL(digital subscriber line) 접속, Wi-Fi(wireless fidelity) 접속, 전화선 접속, 동축 케이블 시스템, 위성 시스템, 현장선 무선 시스템, 셀룰러 전화 시스템, 광학 접속(예를 들어, 광섬유 접속) 등에 의해 통신을 실현한다. 예를 들어, 인터페이스 회로부는 블루투스® 인터페이스, 이더넷 인터페이스, Wi-Fi 인 터페이스, USB(universal serial bus), NFC(near field communication) 인터페이스, PCI 인터페이스, 및/또는 PCIe 인터페이스와 같은 임의의 유형의 인터페이스 표준에 의해 구현될 수 있다. 예시된 예의 메모리는 적어도 하나의 휘발성 메모리(예를 들어, SDRAM(Synchronous Dynamic Random Access Memory), DRAM(Dynamic Random Access Memory), RDRAM(RAMBUS Dynamic Random Access Memory) 등) 및/ 또는 적어도 하나의 비휘발성 메모리(예를 들어, 플래시 메모리)에 의해 구현될 수 있다. 컴퓨팅 시스템은 컴퓨팅 시스템의 하드웨어에 전력을 전달하기 위한 전원을 포함한다. 일부 예 들에서, 전원은 전력 전달 네트워크를 구현할 수 있다. 예를 들어, 전원은 교류-직류(AC/DC) 전력 공급, 직류-직류(DC/DC) 전력 공급 등을 구현할 수 있다. 일부 예들에서, 전원은 AC 메인(예를 들어, 110 볼트(V) AC 그리드 메인, 220V AC 그리드 메인 등)과 같은 전력 그리드 기반구조에 결합될 수 있다. 추가적으 로 또는 대안적으로, 전원은 하나 이상의 배터리에 의해 구현될 수 있다. 예를 들어, 전원은 리튬 이온 배터리 또는 임의의 다른 충전 가능한 배터리 또는 전원과 같은 제한된 에너지 디바이스일 수 있다. 일부 이러한 예들에서, 전원은 전력 어댑터 또는 컨버터(예를 들어, AC/DC 전력 변환기), 벽 아울렛(예를 들어, 110V AC 벽 아울렛, 220V AC 벽 아울렛 등), 휴대용 에너지 저장 디바이스(예를 들어, 휴대용 전력 뱅크, 휴대 용 전력 셀 등) 등을 사용하여 충전 가능할 수 있다. 도 1의 예시된 예의 컴퓨팅 시스템은 데이터(예컨대, ML 모델(들), 중단점(들) 등)을 기록하기 위한 데이터 저장소를 포함한다. 이 예의 데이터 저장소는 휘발성 메모리 및/또는 비휘발성 메모리 (예를 들어, 플래시 메모리)에 의해 구현될 수 있다. 데이터 저장소는 추가적으로 또는 대안적으로 DDR, DDR2, DDR3, DDR4, mDDR(mobile DDR) 등과 같은 하나 이상의 DDR(double data rate) 메모리에 의해 구현될 수 있다. 데이터 저장소는 추가적으로 또는 대안적으로 하드 디스크 드라이브(HDD)(들), 컴팩트 디스크(CD) 드라이브(들), 디지털 다용도 디스크(DVD) 드라이브(들), 솔리드 스테이트 디스크(SSD) 드라이브(들) 등과 같은 하나 이상의 대용량 저장 디바이스에 의해 구현될 수 있다. 예시된 예에서 데이터 저장소는 단일 데이터 저장소로서 예시되어 있지만, 데이터 저장소는 임의의 수 및/또는 유형(들)의 데이터 저장소에 의해 구현 될 수 있다. 또한, 데이터 저장소에 저장된 데이터는 예를 들어, 바이너리 데이터, 쉼표로 구분된 데이터, 탭으로 구분된 데이터, SQL(structured query language) 구조들, 실행가능물(예를 들어, 실행가능 바이 너리, 구성 이미지 등) 등과 같은 임의의 데이터 포맷일 수 있다. 도 1의 예시된 예에서, 컴퓨팅 시스템은 사용자 인터페이스와 통신한다. 예를 들어, 사용자 인터페 이스는 그래픽 사용자 인터페이스(GUI), 애플리케이션 사용자 인터페이스 등에 의해 구현될 수 있으며, 이 들은 컴퓨팅 시스템과 함께 회로 내에 있고/있거나 컴퓨팅 시스템과 달리 통신하는 디스플레이 디바 이스 상에서 사용자에게 제시될 수 있다. 이 예에서, 사용자 인터페이스는 디버그 애플리케이션을 구현할 수 있다. 예를 들어, 사용자(예컨대, 개발자, IT 관리자, 고객 등)는 사용자 인터페이스와 상호작 용함으로써 디버그 애플리케이션으로 컴퓨팅 시스템을 제어할 수 있고, ML 모델(들)을 구성, 훈 련, 실행, 및/또는 디버깅하고/하거나, 중단점(들) 등을 생성 및/또는 수정한다. 대안적으로, 컴퓨팅 시 스템은 사용자 인터페이스를 포함하고/하거나, 달리 구현할 수 있다. 도 1의 예시된 예에서, 네트워크는 인터넷이다. 그러나, 이 예의 네트워크는 예를 들어, 하나 이상 의 데이터 버스, 하나 이상의 근거리 네트워크(LAN), 하나 이상의 무선 LAN, 하나 이상의 셀룰러 네트워크, 하 나 이상의 비공개 네트워크, 하나 이상의 공개 네트워크, 하나 이상의 에지 네트워크 등을 포함하는 임의의 적 절한 유선 및/또는 무선 네트워크(들)을 사용하여 구현될 수 있다. 일부 예들에서, 네트워크는 컴퓨팅 시 스템이 외부 컴퓨팅 시스템들 중 하나(들)와 통신할 수 있게 한다. 도 1의 예시된 예에서, 외부 컴퓨팅 시스템들은 ML 모델(들)이 실행될 하나 이상의 컴퓨팅 디바이스 를 포함하고/하거나 달리 구현한다. 이 예에서, 외부 컴퓨팅 시스템들은 예시적인 데스크탑 컴퓨터, 예시적인 모바일 디바이스(예를 들어, 스마트폰, 인터넷 인에이블드 스마트폰 등), 예시적인 랩탑 컴퓨터 , 예시적인 태블릿(예를 들어, 태블릿 컴퓨터, 인터넷 인에이블드 태블릿 컴퓨터 등), 및 예시적인서버(예를 들어, 에지 서버, 랙 장착 서버, 가상화된 서버 등)를 포함한다. 일부 예들에서, 도 1에 도시 된 것보다 적거나 많은 외부 컴퓨팅 시스템들이 사용될 수 있다. 추가적으로 또는 대안적으로, 외부 컴퓨 팅 시스템들은 임의의 다른 유형 및/또는 양의 컴퓨팅 디바이스들을 포함하고, 이들에 대응하고/하거나, 이들을 달리 나타낼 수 있다. 예를 들어, 외부 컴퓨팅 시스템들 중 하나(들)는 가상화된 컴퓨팅 시스템들 일 수 있다. 일부 예들에서, 외부 컴퓨팅 시스템들 중 하나 이상은 컴퓨팅 작업부하(예를 들어, AI/ML 작업부하)를 처 리하기 위해 ML 모델(들) 중 하나(들)를 실행한다. 예를 들어, 모바일 디바이스는 ML 모델(들) 중 하나(들)를 사용하여 AI/ML 작업부하를 처리하기 위해 단일 SoC 상에 프로세서 회로부(예를 들어, CPU, GPU, VPU, AI 또는 신경망 특정 프로세서 등)를 갖는 셀 또는 모바일 폰으로 구현될 수 있다. 일부 예들에서, 데스 크탑 컴퓨터, 모바일 디바이스, 랩탑 컴퓨터, 태블릿 컴퓨터, 및/또는 서버는 ML 모 델(들) 중 하나(들)를 사용하여 AI/ML 작업부하(들)을 처리하기 위해 하나 이상의 SoC 상에 프로세서 회로 부(예를 들어, CPU, GPU, VPU, AI 또는 신경망 특정 프로세서 등)를 갖는 컴퓨팅 디바이스(들)로 구현될 수 있 다. 일부 예들에서, 서버는 ML 모델(들) 중 하나(들)를 사용하여 AI/ML 작업부하(들)을 처리하기 위 해 데이터 설비, 클라우드 서비스(예컨대, 공개 또는 비공개 클라우드 제공자, 클라우드 기반 저장소 등) 등을 구현할 수 있는 하나 이상의 서버(예컨대, 물리적 서버, 가상화된 서버 등 및/또는 이들의 조합)를 구현할 수 있다. 도 1의 예시된 예에서, 디버그 애플리케이션은 ML 모델(들)을 획득하고, AI/ML 작업부하들과 같은 가 속기 동작들을 수행하기 위해 제1 가속기 회로부 및/또는 제2 가속기 회로부 상에서 실행될 수 있는 실행가능 바이너리와 같은 출력을 컴파일하고/하거나 달리 생성한다. 예를 들어, 디버그 애플리케이션은 컴파일러(예를 들어, 가속기 컴파일러, AI/ML 컴파일러, 신경망 컴파일러 등)를 구현할 수 있다. 일부 이러한 예들에서, 디버그 애플리케이션은 가속기 회로부(108, 110) 중 하나(들) 상의 구현을 위해 ML 모델 (들) 및/또는 중단점(들)에 기초하여 구성 이미지를 컴파일할 수 있다. 예를 들어, 구성 이미지는 AI/ML 구성 데이터(예를 들어, 레지스터 구성들, 활성화 데이터, 활성화 희소성 데이터, 가중치 데이터, 가중치 희소성 데이터, 하이퍼파라미터들 등), 실행될 AI/ML 동작(예를 들어, 컨볼루션, 신경망 계층 등)을 포함하는 실행가능 바이너리에 의해 구현될 수 있다. 도 1의 예시된 예에서, 디버그 애플리케이션은 ML 모델(들) 중 하나(들)를 실행하도록 가속기 회로부 (108, 110) 중 하나(들)에 명령, 지시, 및/또는 달리 호출할 수 있고, 디버그 애플리케이션은 ML 모델 (들)의 실행(들)을 디버깅하도록 디버그 회로부를 구성할 수 있다. 기계 학습(ML), 심층 학습(DL) 및/또는 다른 인공 기계 구동 논리를 포함하는 AI는 기계들(예를 들어, 컴퓨터들, 논리 회로들 등)로 하여금 모 델을 사용하여 입력 데이터를 처리하여 모델이 이전에 훈련 프로세스를 통해 학습한 패턴들 및/또는 연관성들에 기초하여 출력을 생성할 수 있게 한다. 예를 들어, 기계 학습 모델(들)은 패턴들 및/또는 연관성들을 인 식하고, 입력 데이터를 처리할 때 이러한 패턴들 및/또는 연관성들을 따름으로써 다른 입력(들)이 인식된 패턴 들 및/또는 연관성들에 부합하는 출력(들)을 유발하게 하도록 데이터로 훈련될 수 있다. 많은 상이한 유형의 기계 학습 모델들 및/또는 기계 학습 아키텍처들이 존재한다. 일부 예들에서, 디버그 애플 리케이션은 기계 학습 모델(들)을 신경망 모델(들)로서 생성한다. 디버그 애플리케이션은 인터 페이스 회로부에게 기계 학습 모델(들)을 외부 컴퓨팅 시스템들 중 하나(들)로 전송하도록 명령 할 수 있다. 신경망 모델을 사용하는 것은 가속기 회로부(108, 110)가 AI/ML 작업부하를 실행할 수 있게 한다. 일반적으로, 본 명세서에 개시된 예시적인 접근법들에서 사용하기에 적합한 기계 학습 모델들/아키텍처들은 순 환 신경망들을 포함한다. 그러나, 지도 학습 ANN 모델들, 클러스터링 모델들, 분류 모델들 등 및/또는 이들의 조합과 같은 다른 유형의 기계 학습 모델들이 추가적으로 또는 대안적으로 사용될 수 있다. 예시적인 지도 학 습 ANN 모델들은 2-계층(2-layer) 방사상 기저 신경망(RBN)들, 학습 벡터 양자화(LVQ) 분류 신경망들 등을 포함 할 수 있다. 예시적인 클러스터링 모델들은 k-평균 클러스터링, 계층적 클러스터링, 평균 시프트 클러스터링, 밀도 기반 클러스터링 등을 포함할 수 있다. 예시적인 분류 모델들은 로지스틱 회귀, 지원 벡터 기계 또는 네 트워크, Naive Bayes 등을 포함할 수 있다. 일부 예들에서, 디버그 애플리케이션은 기계 학습 모델 (들) 중 하나(들)를 경량 기계 학습 모델들로서 컴파일하고/하거나 달리 생성할 수 있다. 일반적으로, ML/AI 시스템의 구현은 학습/훈련 단계와 추론 단계의 두 단계를 포함한다. 학습/훈련 단계에서는, 훈련 알고리즘을 사용하여, 기계 학습 모델(들)이 예를 들어 훈련 데이터에 기초하여 패턴들 및/또는 연관성들에 따라 동작하도록 훈련한다. 일반적으로, 기계 학습 모델(들)은 예를 들어, 입력 데이 터를 출력 데이터로 변환하기 위한 기계 학습 모델(들) 내의 일련의 노드들 및 접속들을 통해, 입력 데이터가 출력 데이터로 변환되는 방법을 안내하는 내부 파라미터들(예를 들어, 구성 데이터)을 포함한다. 또한, 하이퍼파라미터들은 학습이 수행되는 방법(예를 들어, 학습 레이트, 기계 학습 모델에서 사용될 계층들의 수 등)을 제어하기 위해 훈련 프로세스의 일부로 사용된다. 하이퍼파라미터들은 훈련 프로세스를 시작하기 전에 결정되는 훈련 파라미터들인 것으로 정의된다. ML/AI 모델의 유형 및/또는 예상 출력에 기초하여 상이한 유형들의 훈련이 수행될 수 있다. 예를 들어, 디버그 애플리케이션은 모델 에러를 감소시키는 기계 학습 모델(들)에 대한 파라미터들을 선택하기 위해(예 를 들어, 선택된 파라미터들의 조합들을 통해 반복함으로써) 입력들 및 대응하는 예상된(예를 들어, 라벨링된) 출력들을 사용할 지도 훈련을 호출할 수 있다. 본 명세서에서 사용되는 바와 같이, \"라벨링\"은 기계 학습 모델 의 예상 출력(예를 들어, 분류, 예상 출력 값 등)을 지칭한다. 대안적으로, 디버그 애플리케이션은 (예를 들어, 예상된(예를 들어, 라벨링된) 출력들의 이익 없이) 기계 학습 모델(들)에 대한 파라미터들을 선택하 기 위해 입력들로부터 패턴들을 추론하는 것을 포함하는 비지도 훈련(예를 들어, 심층 학습, 기계 학습의 서브 세트 등에서 사용됨)을 호출할 수 있다. 일부 예들에서, 디버그 애플리케이션은 동작하는 관찰가능물들의 비지도 클러스터링을 사용하여 기계 학습 모델(들)을 훈련한다. 그러나, 디버그 애플리케이션은 확률적 기울기 하강법(stochastic gradient descent), 시뮬레이션된 어닐링(Simulated Annealing), 입자 군집 최적화(Particle Swarm Optimization), 진화 알고리즘들, 유전 알고리즘들, 비선형 켤레 기울기(Nonlinear Conjugate Gradient) 등과 같은 임의의 다른 훈련 알고리즘을 추가적으로 또는 대안적으로 사용할 수 있다. 일부 예들에서, 디버그 애플리케이션은 에러 레벨이 더 이상 감소하지 않을 때까지 기계 학습 모델 (들)을 훈련할 수 있다. 일부 예들에서, 디버그 애플리케이션은 기계 학습 모델(들)을 컴퓨팅 시스템 상에서 국지적으로 그리고/또는 컴퓨팅 시스템과 통신 가능하게 결합된 외부 컴퓨팅 시스템 (예컨대, 외부 컴퓨팅 시스템들 중 하나(들))에서 원격적으로 훈련할 수 있다. 일부 예들에서, 디버그 애 플리케이션은 학습이 수행되는 방법(예를 들어, 학습 레이트, 기계 학습 모델에서 사용될 계층들의 수 등)을 제어하는 하이퍼파라미터들을 사용하여 기계 학습 모델(들)을 훈련한다. 일부 예들에서, 디버그 애 플리케이션은 학습 레이트 및 규칙화 파라미터(들)와 같은 모델 성능 및 훈련 속도를 제어하는 하이퍼파라 미터들을 사용할 수 있다. 디버그 애플리케이션은 예를 들어, 최적의 모델 성능에 도달하기 위해 시행착 오를 통해 이러한 하이퍼파라미터들을 선택할 수 있다. 일부 예들에서, 디버그 애플리케이션은 베이지안 하이퍼파라미터 최적화를 이용하여, 모델 오버피팅을 피하고 기계 학습 모델(들)의 전반적인 적용가능성을 개선하기 위해 최적의 그리고/또는 달리 개선되거나 더 효율적인 네트워크 아키텍처를 결정한다. 대안적으로, 디버그 애플리케이션은 임의의 다른 유형의 최적화를 사용할 수 있다. 일부 예들에서, 디버그 애플리케이 션은 재훈련을 수행할 수 있다. 디버그 애플리케이션은 컴퓨팅 시스템의 사용자에 의한 오버라 이드(들), 새로운 훈련 데이터의 수신에 응답하고, 가속기 회로부(108, 110)의 디버깅에 응답하는 등등으로 이 러한 재훈련을 실행할 수 있다. 일부 예들에서, 디버그 애플리케이션은 훈련 데이터를 사용하여 기계 학습 모델(들)의 훈련을 용이하 게 한다. 일부 예들에서, 디버그 애플리케이션은 국지적으로 생성된 데이터로부터 비롯되는 훈련 데이터 를 이용한다. 일부 예들에서, 디버그 애플리케이션은 외부에서 생성된 데이터로부터 비롯되는 훈련 데이 터를 이용한다. 지도 훈련이 사용되는 일부 예들에서, 디버그 애플리케이션은 훈련 데이터를 라벨링할 수 있다. 라벨링은 사용자에 의해 수동으로 또는 자동화된 데이터 전처리 시스템에 의해 훈련 데이터에 적용된다. 일부 예들에서, 디버그 애플리케이션은 예를 들어 인터페이스(예를 들어, 인터페이스 회로부)를 사용 하여 훈련 데이터를 전처리할 수 있다. 일부 예들에서, 디버그 애플리케이션은 훈련 데이터를 기계 학습 모델(들)을 훈련하기 위한 데이터의 제1 부분과, 기계 학습 모델(들)을 검증하기 위한 데이터의 제2 부분으로 세분한다. 훈련이 완료되면, 디버그 애플리케이션은 입력을 처리하고 기계 학습 모델(들)에 정의된 노드들 및 접속들의 네트워크에 기초하여 출력을 제공하는 실행가능 구성체로서 사용하기 위해 기계 학습 모델(들)을 배치할 수 있다. 디버그 애플리케이션은 기계 학습 모델(들)을 데이터 저장소에 저장할 수 있 다. 일부 예들에서, 디버그 애플리케이션은 인터페이스 회로부를 호출하여 기계 학습 모델(들)(12 4)을 외부 컴퓨팅 시스템들 중 하나(들)로 전송할 수 있다. 일부 이러한 예들에서, 기계 학습 모델 (들)을 외부 컴퓨팅 시스템들 중 하나(들)로 전송하는 것에 응답하여, 외부 컴퓨팅 시스템들 중 하나(들)는 기계 학습 모델(들)을 실행하여 개선된 효율 또는 성능 중 적어도 하나로 AI/ML 작업부하들을 실행할 수 있다. 유리하게, ML 모델(들)의 디버깅에 응답하여, 디버그 애플리케이션은 이전 구현들보다 더 정확한 ML 모델(들)을 발행하고/하거나 달리 푸시할 수 있다. 일단 훈련되면, 기계 학습 모델(들) 중 배치된 것(들)은 데이터를 처리하기 위해 추론 단계에서 동작될 수 있다. 추론 단계에서, 분석될 데이터(예를 들어, 라이브 데이터)는 기계 학습 모델(들)에 입력되고, 기계 학습 모델(들)은 출력을 생성하기 위해 실행된다. 이러한 추론 단계는 AI가 (예컨대, 학습된 패턴들 및/ 또는 연관성들을 라이브 데이터에 적용하기 위해 기계 학습 모델(들)을 실행함으로써) 훈련으로부터 학습 한 것에 기초하여 출력을 생성하기 위해 \"생각\"하는 것으로 간주될 수 있다. 일부 예들에서, 입력 데이터는 기 계 학습 모델(들)에 대한 입력으로서 사용되기 전에 전처리를 거친다. 더욱이, 일부 예들에서, 출력 데이 터는 출력을 유용한 결과(예를 들어, 데이터의 디스플레이, 객체의 검출 및/또는 식별, 기계에 의해 실행될 명 령어 등)로 변환하기 위해 기계 학습 모델(들)에 의해 생성된 후에 후처리를 거칠 수 있다. 일부 예들에서, 기계 학습 모델(들)의 배치된 것(들)의 출력이 캡처되어 피드백으로서 제공될 수 있다. 피드백을 분석함으로써, 기계 학습 모델(들)의 배치된 것(들)의 정확도가 결정될 수 있다. 피드백이 배치 된 모델의 정확도가 임계값 또는 다른 기준보다 낮다는 것을 나타내는 경우, 피드백 및 업데이트된 훈련 데이터 세트, 하이퍼파라미터들 등을 사용하여, 업데이트된 모델의 훈련을 트리거하여, 업데이트되고 배치된 모델을 생 성할 수 있다. 일부 예들에서, 디버그 애플리케이션은 바람직하지 않은 가속기 성능 또는 ML 모델 실행을 디버깅 및/또는 트러블슈팅하도록 디버그 회로부를 구성할 수 있다. 예를 들어, 디버그 회로부는 가속기 회로부 (108, 110)에 의해 처리될 입력(들)(예를 들어, ML 입력(들))을 수신할 수 있다. 일부 이러한 예들에서, 입력 (들)(예를 들어, 입력(들)의 값(들), 입력(들)의 어드레스(들) 등)에 기초하여 중단점(들)이 트리거되지 않는 것에 응답하여, 가속기 회로부(108, 110)는 입력(들)을 가속기 회로부(108, 110)의 코어로 전달할 수 있고, 디버그 회로부는 이에 따라 바이패스 동작 모드로 동작할 수 있다. 일부 예들에서, 입력(들)에 기 초하여 중단점(들) 중 하나(들)가 트리거되는 것에 응답하여, 디버그 회로부는 가속기 트랜잭션의 판 독, 트리거된 중단점(들)의 판독, 중단점(들)의 수정, 입력(들)의 수정 등 및/또는 이들의 조합을 포함할 수 있 는 디버그 동작을 실행할 수 있다. 유리하게, 디버그 회로부는 ML 모델(들)에 대한 입력(들)에 기초 하여 중단점이 트리거되는 것에 응답하여 가속기 파이프라인의 실행을 중단시킴으로써 가속기 회로부(108, 110) 및/또는 ML 모델(들)과 연관된 디버깅 시간을 감소시킬 수 있다. 일부 예들에서, 디버그 회로부는 ML 모델(들)의 실행에 응답하여 가속기 회로부(108, 110)에 의해 생 성된 출력(들)(예를 들어, ML 출력(들))을 수신할 수 있다. 일부 이러한 예들에서, 출력(들)(예를 들어, 출력 (들)의 값(들), 출력(들)의 어드레스(들) 등)에 기초하여 중단점(들)이 트리거되지 않는 것에 응답하여, 가속기 회로부(108, 110)는 출력(들)을 메모리로 전달할 수 있고, 이에 따라 바이패스 동작 모드로 동작할 수 있다. 일부 예들에서, 출력(들)에 기초하여 중단점(들) 중 하나(들)가 트리거되는 것에 응답하여, 디 버그 회로부는 가속기 트랜잭션의 판독, 트리거된 중단점(들)의 판독, 중단점(들)의 수정, 입력(들)의 수 정 등 및/또는 이들의 조합을 포함할 수 있는 디버그 동작을 실행할 수 있다. 유리하게, 디버그 회로부는 ML 모델(들)에 대한 출력(들)에 기초하여 중단점이 트리거되는 것에 응답하여 가속기 파이프라인의 실행을 중단시킴으로써, 가속기 회로부(108, 110) 및/또는 ML 모델(들)과 연관된 디버깅 시간을 감소시킬 수 있다. 도 2는 도 1의 디버그 애플리케이션, 도 1의 메모리 및 예시적인 제3 가속기 회로부를 포함하는 예시적인 제1 가속기 회로부 디버그 시스템의 블록도이다. 일부 예들에서, 도 2의 제3 가속기 회로부 는 도 1의 제1 가속기 회로부 및/또는 제2 가속기 회로부의 예시적인 구현일 수 있다. 도 2의 예시된 예에서, 메모리는 예시적인 기계 학습 입력(들) 및 예시적인 기계 학습 출력(들)(20 6)을 포함한다. 예를 들어, 기계 학습 입력(들)은 기계 학습 출력(들)을 생성하기 위해, 제3 가속기 회로부에 의해 인스턴스화될 수 있는 도 1의 ML 모델(들)에 의해 처리될 데이터일 수 있다. 일부 이 러한 예들에서, 기계 학습 입력(들)은 숫자 데이터, 카테고리 데이터, 시계열 데이터, 텍스트 데이터, 디 지털 이미지들 및/또는 비디오의 부분(들), 센서 데이터 등 및/또는 기계 학습 모델에 의해 처리 및/또는 분석 될 수 있는 임의의 다른 유형의 데이터(예를 들어, 자율 모션, 로봇 제어, 사물 인터넷(IoT) 데이터 등과 연관 된 데이터)일 수 있다. 일부 예들에서, 기계 학습 출력(들)은 숫자 데이터, 카테고리 데이터, 시계열 데 이터, 텍스트 데이터 등 및/또는 이들의 조합일 수 있다. 예를 들어, 제3 가속기 회로부는 제3 가속기 회 로부의 승산-누산기(MAC) 회로부로부터 숫자 데이터를 출력할 수 있다. 제3 가속기 회로부는 예시적인 디버그 회로부(208, 210) 및 예시적인 코어들(예를 들어, 코어 회로 부)(212, 214)을 포함한다. 예를 들어, 제3 가속기 회로부는 디버그 회로부(208, 210)의 2개 이상의 인스 턴스와 코어들(212, 214)의 2개 이상의 인스턴스를 포함한다. 대안적으로, 제3 가속기 회로부는 디버그 회로부(208, 210) 및/또는 코어들(212, 214)의 더 적은 인스턴스들을 포함할 수 있다. 일부 예들에서, 디버그 회로부(208, 210)는 도 1의 디버그 회로부의 예시적인 구현일 수 있다. 예시된 예의 디버그 회로부(208, 210)는 예시적인 디버그 레지스터(들)를 포함한다. 일부 예들에서, 디버 그 레지스터(들)는 벡터 레지스터(들), SIMD(single instruction multiple data) 레지스터(들), 범용 레 지스터(들), 플래그 레지스터(들), 세그먼트 레지스터(들), 기계 특정 레지스터(들), 명령어 포인터 레지스터 (들), 제어 레지스터(들), 디버그 레지스터(들), 메모리 관리 레지스터(들), 기계 체크 레지스터(들) 등으로 구 현될 수 있는 하나 이상의 레지스터를 포함할 수 있다. 디버그 레지스터(들)는 디버그 회로부(208, 210) 의 구성 파라미터들, 설정들 등에 대응하는 데이터 값들을 저장할 수 있다. 예를 들어, 디버그 레지스터 (들)는 디버그 회로부(208, 210) 및/또는 코어들(212, 214)에 의해 트리거될 중단점을 나타내는 값(들)을 저장할 수 있다. 일부 예들에서, 디버그 레지스터(들)는 기계 학습 입력(들) 중 하나(들), 기계 학 습 입력(들) 중 하나(들)와 연관된 어드레스(들) 및/또는 어드레스 범위, 기계 학습 출력(들) 중 하 나(들), 기계 학습 출력(들) 중 하나(들)와 연관된 어드레스(들) 및/또는 어드레스 범위 등 및/또는 이들 의 조합에 대응하는 값(들)을 저장할 수 있다. 예시된 예의 디버그 회로부(208, 210)는 예시적인 디버그 인터페이스를 포함한다. 일부 예들에서, 디버그 인터페이스는 I2C 버스, SPI 버스, PCI 버스, PCIe 버스, 및/또는 임의의 다른 유형의 전기, 하드웨어 또 는 컴퓨팅 버스로 구현될 수 있다. 일부 예들에서, 디버그 애플리케이션은 디버그 인터페이스에 의 해, 디버그 회로부(208, 210)의 디버그 레지스터(들) 및/또는 보다 일반적으로 디버그 회로부(208, 210)로 데이터를 전송하고/하거나 그 안에 데이터를 저장 또는 기입할 수 있다. 일부 예들에서, 디버그 애플리케이션 은 디버그 인터페이스에 의해, 디버그 레지스터(들) 및/또는 보다 일반적으로 디버그 회로부 (208, 210)로부터 데이터를 수신할 수 있다. 예시된 예의 코어들(212, 214)은 예시적인 실행 회로부를 포함한다. 일부 예들에서, 실행 회로부는 기계 학습 입력(들)에 기초하여 기계 학습 출력(들)을 생성할 수 있는 회로부로 구현될 수 있다. 예 를 들어, 실행 회로부는 도 1의 기계 학습 모델(들) 중 하나(들)를 구현할 수 있다. 일부 이러한 예 들에서, 실행 회로부는 MAC 회로부, DPU(data path unit) 회로부, 연산 논리 회로부(예를 들어, 하나 이상 의 ALU(arithmetic logic unit)) 등 및/또는 이들의 조합으로 구현될 수 있다. 예를 들어, 디버그 애플리케이 션은 기계 학습 모델(들)에 기초하여 실행가능 바이너리를 컴파일할 수 있고, 코어 인터페이스 에 의해 실행가능 바이너리를 코어들(212, 214)에 제공할 수 있다. 일부 이러한 예들에서, 실행 회로부는 기계 학습 모델(들)을 구현하기 위해 실행가능 바이너리에 기초하여 구성될 수 있다. 일부 예들에서, 디 버그 애플리케이션은 실행가능 바이너리에 하나 이상의 중단점을 포함시킴으로써 실행가능 바이너리를 컴 파일할 수 있다. 일부 이러한 예들에서, 코어들(212, 214)은 하나 이상의 중단점의 값(들) 및/또는 보다 일반 적으로 하나 이상의 중단점을 실행 회로부에 의해 호출될 구성 레지스터(들)에 저장할 수 있다. 예시된 예의 코어들(212, 214)은 예시적인 구성 레지스터(들)(구성 레지스터(들)에 의해 식별됨)를 포함한 다. 일부 예들에서, 구성 레지스터(들)는 벡터 레지스터(들), SIMD 레지스터(들), 범용 레지스터(들), 플 래그 레지스터(들), 세그먼트 레지스터(들), 기계 특정 레지스터(들), 명령어 포인터 레지스터(들), 제어 레지 스터(들), 디버그 레지스터(들), 메모리 관리 레지스터(들), 기계 체크 레지스터(들) 등으로 구현될 수 있는 하 나 이상의 레지스터를 포함할 수 있다. 구성 레지스터(들)는 실행 회로부, 및/또는 보다 일반적으로, 코어들(212, 214)의 구성 파라미터들, 설정들 등에 대응하는 데이터 값들을 저장할 수 있다. 예를 들어, 구성 레지스터(들)는 기계 학습 모델(들)을 구현하도록 실행 회로부 및/또는 보다 일반적 으로 코어들(212, 214)을 구성하기 위해 실행가능 바이너리로부터의 값(들)을 저장할 수 있다. 일부 예들에서, 구성 레지스터(들)는 디버그 회로부(208, 210) 및/또는 코어들(212, 214)에 의해 트리거될 중단점을 나타 내는 값(들)을 저장할 수 있다. 일부 예들에서, 구성 레지스터(들)는 기계 학습 입력(들) 중 하나 (들), 기계 학습 입력(들) 중 하나(들)와 연관된 어드레스(들) 및/또는 어드레스 범위, 기계 학습 출력(들) 중 하나(들), 기계 학습 출력(들) 중 하나(들)와 연관된 어드레스(들) 및/또는 어드레스 범 위 등 및/또는 이들의 조합에 대응하는 값(들)을 저장할 수 있다. 예시된 예의 코어들(212, 214)은 예시적인 코어 인터페이스를 포함한다. 일부 예들에서, 코어 인터페이스 는 I2C 버스, SPI 버스, PCI 버스, PCIe 버스, 및/또는 임의의 다른 유형의 전기, 하드웨어 또는 컴퓨팅 버스로 구현될 수 있다. 일부 예들에서, 디버그 애플리케이션은 코어 인터페이스에 의해 코어들(212, 214)의 구성 레지스터(들) 및/또는 보다 일반적으로 코어들(212, 214)로 데이터를 전송하고/하거나 그 안에 데이터를 저장 또는 기입할 수 있다. 일부 예들에서, 디버그 애플리케이션은 코어 인터페이스 에 의해 구성 레지스터(들) 및/또는 보다 일반적으로 코어들(212, 214)로부터 데이터를 수신할 수 있 다. 도 2의 예시된 예에서, 제3 가속기 회로부는 기계 학습 입력(들)에 기초하여 중단점(들)을 트리거하 고/하거나 달리 호출하도록 인스턴스화된 디버그 회로부(208, 210)로 구현된다. 예시된 예에서, 디버그 회로부 (208, 210)의 입력(들)(예를 들어, 입력 단자(들), 입력 접속(들) 등)은 메모리의 출력(들)에 결합된다. 디버그 회로부(208, 210)의 출력(들)(예를 들어, 출력 단자(들), 출력 접속(들) 등)은 코어(들)(212, 214)의 입 력(들)에 결합된다. 예를 들어, 디버그 회로부(208, 210)의 출력(들)은 코어들(212, 214)의 예시적인 버스 , 실행 회로부, 구성 레지스터(들) 및/또는 코어 인터페이스에 결합된다. 일부 예들에서, 버스는 I2C 버스, SPI 버스, PCI 버스, PCIe 버스, 및/또는 임의의 다른 유형의 전기적, 하드웨어, 또는 컴퓨팅 버스로 구현될 수 있다. 코어들(212, 214)의 출력(들)은 메모리의 입력(들)에 결합된다. 일부 예 들에서, 디버그 인터페이스 및 코어 인터페이스는 디버그 애플리케이션과 통신하도록 인스턴스 화된다. 예시적인 동작에서, 실행 회로부는 도 1의 ML 모델(들) 중 하나를 구현하기 위해 실행가능 바이너리 를 실행할 수 있다. 실행가능 바이너리의 실행에 응답하여, 실행 회로부는 기계 학습 입력(들) 중 하나(들)를 획득하기 위해 판독 동작을 실행할 수 있다. 예시적인 동작에서, 실행 회로부는 메모리 의 하나 이상의 어드레스에서 기계 학습 입력(들) 중 하나(들)를 판독하기 위한 요청을 생성할 수 있다. 디버그 회로부(208, 210)는 요청 및 하나 이상의 어드레스를 획득할 수 있다. 일부 예들에서, 디버그 회로부(208, 210)는 중단점이 트리거되지 않는 것에 응답하여 메모리에 요청을 제 공할 수 있다. 예를 들어, 디버그 회로부(208, 210)는 하나 이상의 어드레스가 중단점과 연관된 어드레스와 매 칭되지 않는다고 결정할 수 있다. 디버그 회로부(208, 210)는 메모리로부터 기계 학습 입력(들) 중 요청된 것(들)을 수신할 수 있다. 예시적인 동작에서, 디버그 회로부(208, 210)는 중단점이 트리거되지 않는 것에 응답하여 기계 학습 입력(들) 중 요청된 것(들)을 코어들(212, 214)에 제공할 수 있다. 실행 회로부 는 기계 학습 입력(들)에 기초하여 기계 학습 출력(들)을 생성할 수 있다. 실행 회로부는 기계 학습 출력(들)을 메모리에 기입할 수 있다. 일부 예들에서, 디버그 회로부(208, 210)는 (i) 하나 이상의 어드레스가 중단점과 연관된 어드레스(또는 어드레 스들의 범위)와 매칭되고/되거나 (ii) 기계 학습 입력(들) 중 요청된 것(들)이 중단점과 연관된 값(들)과 매칭된다는 결정에 응답하여 중단점을 트리거할 수 있다. 예를 들어, 디버그 회로부(208, 210)는 기계 학습 입 력(들)의 값이 저장된 어드레스(또는 어드레스들의 범위)가 중단점의 값과 매칭된다는 제2 결정에 응답하 여 중단점을 트리거할 수 있다. 일부 예들에서, 디버그 회로부(208, 210)는 기계 학습 입력(들)의 제1 값 (들)을 디버그 레지스터(들)의 제2 값(들)과 비교할 수 있다. 일부 예들에서, 디버그 회로부(208, 210)는 제1 값(들)이 제2 값(들)과 매칭되는 것에 응답하여 중단점(예를 들어, 디버그 중단점)을 트리거할 수 있다. 예를 들어, 디버그 회로부(208, 210)는 기계 학습 입력(들)의 값이 중단점의 값과 매칭된다는 제1 결정에 응답하여 중단점을 트리거할 수 있다. 예시적인 동작에서, 디버그 회로부(208, 210)는 중단점이 트리거되는 것 에 응답하여 코어들(212, 214)에 의한 실행가능 바이너리의 실행을 중단시킬 수 있다. 일부 예들에서, 디버그 애플리케이션은 하나 이상의 중단점이 트리거되는 것에 응답하여 디버그 동작을 실 행하고/하거나 실행을 야기할 수 있다. 예를 들어, 디버그 애플리케이션은 호출된 중단점(들)에 대해 코 어들(212, 214) 또는 디버그 회로부(208, 210) 중 적어도 하나에 질의할 수 있다. 일부 예들에서, 디버그 애플 리케이션은 기계 학습 입력(들), 기계 학습 출력(들), 또는 기계 학습 입력(들) 및/또는 기계 학습 출력(들)의 연관 메모리 어드레스(들)(예를 들어, 기계 학습 입력(들)이 메모리로부 터 판독되는 어드레스 또는 어드레스 범위 또는 기계 학습 출력(들)이 메모리에 기입될 어드레스 또 는 어드레스 범위) 중 적어도 하나를 검색하고/하거나 그에 달리 액세스할 수 있다. 일부 예들에서, 디버그 회 로부(208, 210) 및/또는 보다 일반적으로 제3 가속기 회로부는 디버그 인터페이스에 의해 기계 학습 입력(들), 기계 학습 출력(들), 또는 기계 학습 입력(들) 및/또는 기계 학습 출력(들)의 연관 메모리 어드레스(들) 중 적어도 하나를 출력할 수 있다. 일부 예들에서, 디버그 애플리케이션은 하 나 이상의 중단점이 실행가능 바이너리의 실행의 어느 부분에서 트리거되는지를 나타내는 데이터를 획득하기 위 해 코어들(212, 214)에 질의함으로써 코어들(212, 214)에 의해 실행되는 작업부하(들)(예컨대, 기계 학습 작업부하(들))의 완료의 진행을 결정할 수 있다. 일부 예들에서, 디버그 애플리케이션은 하나 이상의 중단점이 트리거되는 것에 응답하여 디버그 동작을 실 행하고/하거나 실행을 야기할 수 있으며, 디버그 동작은 데이터 값의 조정 및/또는 수정을 포함할 수 있다. 예 를 들어, 디버그 애플리케이션은 메모리, 디버그 회로부(208, 210), 및/또는 코어들(212, 214)에 저 장된 기계 학습 입력(들)의 값(들)을 변경할 수 있다. 일부 예들에서, 디버그 애플리케이션은 하나 이상의 중단점이 트리거되는 것에 응답하여 디버그 동작을 실 행하고/하거나 실행을 야기할 수 있으며, 디버그 동작은 실행가능 바이너리의 증분 동작을 포함할 수 있다. 예 를 들어, 디버그 애플리케이션은 디버그 회로부(208, 210) 및/또는 보다 일반적으로 제3 가속기 회로부 에게 실행가능물의 증분 동작(예를 들어, 가속기 회로부(108, 110)의 증분 가속기 동작, 단일 스텝 동작 등)을 실행하도록 명령할 수 있다. 일부 이러한 예들에서, 증분 동작은 하나 이상의 판독 동작, 하나 이상의 기입 동작, 및/또는 하나 이상의 계산 동작을 포함할 수 있다. 예를 들어, 디버그 애플리케이션은 디버그 회로부(208, 210)에게 기계 학습 입력(들)의 제1 입력을 획득하고/하거나 디버그 인터페이스에 의해 디버그 애플리케이션에 대한 제1 입력을 판독하도록 명령할 수 있다. 일부 이러한 예들에서, 디버그 애플 리케이션은 디버그 회로부(208, 210)에게 제1 입력이 하나 이상의 중단점을 트리거하는지를 결정하도록 명 령할 수 있다. 일부 이러한 예들에서, 디버그 애플리케이션은 디버그 회로부(208, 210)에게 코어들(212, 214)의 실행 회로부에 제1 입력을 제공하여 기계 학습 출력(들) 중 제1 출력을 생성하도록 명령할 수 있다. 일부 예들에서, 디버그 애플리케이션은 코어들(212, 214)에게 코어 인터페이스에 의해 디버그 애플리케이션으로의 제1 출력을 판독하도록 명령할 수 있다. 유리하게, 디버그 애플리케이션은 증분 방식으로 제3 가속기 회로부를 디버깅하여, 이전 구현들에 비해 개선된 정확도 및 입도로 잘못된 하드웨어 가속기 동작들을 식별할 수 있다. 유리하게, 디버그 회로부(208, 210)는 제3 가속기 회로부와 같은 하드웨어 가속기를 위한 소프트웨어 및 컴파일러 개발을 촉진하도록 구현될 수 있다. 예를 들어, 신경망들과 같은 기계 학습 모델들의 복잡성이 지속 적으로 증가함에 따라, 하드웨어 가속기에서의 그러한 기계 학습 모델들의 실행에서의 임의의 문제들(예를 들어, 버그들, 성능 병목들 등)을 정확히 찾아내기 위한 노력이 증가하고 있다. 디버그 회로부(208, 210) 및/ 또는 보다 일반적으로 도 1의 디버그 회로부를 이용하면, 임의의 문제들을 격리시키기 위한 작업이 크게 단순화될 수 있다. 유리하게, 디버그 회로부(208, 210)는 하드웨어 가속기에 대한 디버그 동작들을 수행하기 위한 전용 외부 디버깅 장비를 불필요하게 만들 수 있다. 예를 들어, 컴파일러 엔지니어는 하드웨어 가속기 내 에 통신 채널(예를 들어, SPI 통신 채널, I2C 통신 채널, 애플리케이션 프로그래밍 인터페이스(들)(API(들))을 이용하는 통신 채널 등)을 확립함으로써 디버그 회로부(208, 210)의 완전한 사용을 명령할 수 있다. 일부 예들에서, 기계 학습 모델(들)에 대한 주어진 입력에 대한 예상 하드웨어 출력의 사전 계산을 허용하 는 소프트웨어 모델이 존재한다. 일부 이러한 예들에서, 실행가능 바이너리에 의해 식별된 각각의 작업부하에 대하여, 메모리 트랜잭션들은 디버그 회로부(208, 210)로부터 획득될 수 있고, 소프트웨어 모델로부터의 예상 출력에 대해 매칭될 수 있다. 일부 이러한 예들에서, 디버그 애플리케이션은 검출된 미스매치에 기초하여 문제를 식별할 수 있다. 도 3은 도 1의 디버그 애플리케이션, 도 1의 메모리 및 예시적인 제4 가속기 회로부를 포함하는 예시적인 제2 가속기 회로부 디버그 시스템의 블록도이다. 일부 예들에서, 도 3의 제4 가속기 회로부 는 도 1의 제1 가속기 회로부 및/또는 제2 가속기 회로부의 예시적인 구현일 수 있다. 제4 가속기 회로부는 도 2의 디버그 레지스터(들) 및 디버그 인터페이스를 포함하는 도 2의 디 버그 회로부(208, 210)를 포함한다. 제4 가속기 회로부는 도 2의 실행 회로부, 구성 레지스터 (들), 코어 인터페이스 및 버스를 포함하는 도 2의 코어들(212, 214)을 포함한다. 도 3의 예시된 예에서, 제4 가속기 회로부는 코어들(212, 214)로부터의 출력(들) 및/또는 보다 일반적으로 기계 학습 출력(들)에 기초하여 중단점(들)을 트리거하고/하거나 달리 호출하도록 인스턴스화된 디버그 회 로부(208, 210)로 구현된다. 예시된 예에서, 코어들(212, 214)의 입력(들)은 메모리의 출력(들)에 결합된 다. 예를 들어, 실행 회로부, 구성 레지스터(들), 코어 인터페이스, 및/또는 버스의 입력 (들)은 메모리의 출력(들)에 결합될 수 있다. 코어들(212, 214)의 출력(들)은 디버그 회로부(208, 210)의 입력(들)에 결합된다. 예를 들어, 코어들(212, 214)의 출력(들)은 디버그 회로부(208, 210)의 디버그 레지스터 (들) 및/또는 디버그 인터페이스에 결합된다. 디버그 회로부(208, 210)의 출력(들)은 메모리의 입력(들)에 결합된다. 일부 예들에서, 디버그 인터페이스 및 코어 인터페이스는 디버그 애플리케이션과 통신하도록 인스턴스화된다. 예시적인 동작에서, 버스 및/또는 보다 일반적으로 코어들(212, 214)은 메모리로부터 기계 학습 입력 (들)을 획득할 수 있다. 실행 회로부는 기계 학습 입력(들)에 기초하여 기계 학습 출력 (들)을 생성할 수 있다. 실행 회로부는 기계 학습 출력(들)을 디버그 회로부(208, 210)로 제공, 전달 및/또는 달리 출력할 수 있다. 예시적인 동작에서, 디버그 회로부(208, 210)는 기계 학습 출력(들) 또는 그와 연관된 데이터(예를 들어, 메모리 어드레스, 메모리 어드레스들의 범위 등)가 중단점을 트리거하지 않는다고 결정하는 것에 응답하여, 기 계 학습 출력(들)을 메모리에 출력 및/또는 달리 기입할 수 있다. 예시적인 동작에서, 디버그 회로 부(208, 210)는 기계 학습 출력(들) 또는 그와 연관된 데이터에 기초하여 하나 이상의 중단점이 트리거된 다고 결정하는 것에 응답하여, 코어들(212, 214)로부터의 판독 동작들을 실행하지 않음으로써, 코어들(212, 214)에 의해 진행 중인 작업부하의 실행을 중단시킬 수 있다. 예시적인 동작에서, 디버그 애플리케이션은 하나 이상의 중단점이 트리거된다는 결정에 응답하여 하나 이상의 디버그 동작을 실행할 수 있다. 도 4는 도 1의 디버그 애플리케이션, 도 1의 메모리 및 예시적인 제5 가속기 회로부를 포함하는 예시적인 제3 가속기 회로부 디버그 시스템의 블록도이다. 일부 예들에서, 도 4의 제5 가속기 회로부 는 도 1의 제1 가속기 회로부 및/또는 제2 가속기 회로부의 예시적인 구현일 수 있다. 제5 가속기 회로부는 도 2의 디버그 레지스터(들) 및 디버그 인터페이스를 포함하는 도 2의 디 버그 회로부(208, 210)를 포함한다. 제5 가속기 회로부는 도 2의 실행 회로부, 구성 레지스터 (들), 코어 인터페이스 및 버스를 포함하는 도 2의 코어들(212, 214)를 포함한다. 예시된 예의 제5 가속기 회로부는 도 2의 코어들(212, 214)의 출력(들)에 결합된 디버그 회로부(208, 21 0)의 추가적인 예시적인 인스턴스들(404, 406)을 포함한다. 일부 예들에서, 디버그 회로부(404, 406)는 도 1의 디버그 회로부의 예시적인 구현일 수 있다. 제5 가속기 회로부는 (i) 코어들(212, 214)에 대한 입력 (들) 및/또는 보다 일반적으로 기계 학습 입력(들), 또는 (ii) 코어들(212, 214)로부터의 출력(들) 및/또 는 보다 일반적으로 기계 학습 출력(들) 중 적어도 하나에 기초하여 중단점(들)을 트리거 및/또는 달리 호 출하도록 인스턴스화된 디버그 회로부(208, 210, 404, 406)로 구현된다. 예시된 예에서, 디버그 회로부(208, 210)의 입력(들)은 메모리의 출력(들)에 결합된다. 예를 들어, 디버그 레지스터(들) 및/또는 디버그 인터페이스의 입력(들)은 메모리의 출력(들)에 결합된다. 디버그 회로부(208, 210)의 출력(들)은 코 어들(212, 214)의 입력(들)에 결합된다. 예를 들어, 디버그 회로부(208, 210)의 출력(들)은 실행 회로부, 구성 레지스터(들), 코어 인터페이스, 및/또는 버스의 입력(들)에 결합된다. 코어들(212, 21 4)의 출력(들)은 디버그 회로부(404, 406)의 입력(들)에 결합된다. 예를 들어, 코어들(212, 214)의 출력(들)은 디버그 회로부(404, 406)의 디버그 레지스터(들) 및/또는 디버그 인터페이스에 결합된다. 디버그 회 로부(404, 406)의 출력(들)은 메모리의 입력(들)에 결합된다. 일부 예들에서, 디버그 인터페이스 및 코어 인터페이스는 디버그 애플리케이션과 통신하도록 인스턴스화된다. 예시적인 동작에서, 코어들(212, 214)은 도 1의 ML 모델(들) 중 하나를 구현하기 위해 실행가능 바이너리 를 실행할 수 있다. 실행가능 바이너리의 실행에 응답하여, 코어들(212, 214)은 메모리로부터 기계 학습 입력(들) 중 하나(들)를 요청할 수 있다. 예시적인 동작에서, 디버그 회로부(208, 210)는 요청을 획득할 수 있다. 일부 예들에서, 디버그 회로부(208, 210)는 판독 요청과 연관된 어드레스(또는 어드레스들의 범위)가 중단점의 어드레스(또는 어드레스들의 범위)와 매칭된다는 결정에 응답하여 중단점을 트리거할 수 있다. 일부 이러한 예들에서, 디버그 회로부(208, 210)는 후속적인 판독 및/또는 기입 동작들이 완료되는 것을 방지함으로 써(그리고 이에 따라 가속기 파이프라인에서 배압을 생성함으로써) 실행가능 바이너리의 실행을 중단시킬 수 있 다. 어드레스(또는 어드레스들의 범위)에 기초한 중단점의 트리거에 응답하여, 디버그 애플리케이션은 중 단점을 트리거한 판독 요청, 어드레스, 어드레스들의 범위 등을 획득하는 것, 증분 동작을 실행하는 것 등 및/ 또는 이들의 조합을 포함할 수 있는 하나 이상의 디버그 동작을 실행할 수 있다. 일부 예들에서, 디버그 회로부(208, 210)는 판독 요청과 연관된 어드레스(또는 어드레스들의 범위)가 중단점의 어드레스(또는 어드레스들의 범위)와 매칭되지 않는다는 결정에 응답하여 중단점을 트리거하지 않을 수 있다. 판독 요청의 어드레스(또는 어드레스들의 범위)에 기초하여 중단점이 트리거되지 않는다는 결정에 응답하여, 디 버그 회로부(208, 210)는 메모리로부터 기계 학습 입력(들)을 획득할 수 있다. 일부 예들에서, 디버 그 회로부(208, 210)는 기계 학습 입력(들)에 기초하여 하나 이상의 중단점이 트리거되는 것을 식별할 수 있다. 기계 학습 입력(들)에 기초하여 하나 이상의 중단점 중 하나(들)가 트리거된다는 식별(들)에 응답하여, 디버그 애플리케이션은 하나 이상의 중단점 중 하나(들)를 트리거한 기계 학습 입력(들)을 획 득하는 것, 증분 동작을 실행하는 것 등 및/또는 이들의 조합을 포함할 수 있는 하나 이상의 디버그 동작을 실 행할 수 있다. 예시적인 동작에서, 디버그 회로부(208, 210)는 기계 학습 입력(들)이 중단점을 트리거하지 않는다는 결정 에 응답하여, 기계 학습 입력(들)을 코어들(212, 214)로 출력할 수 있다. 예를 들어, 디버그 회로부(208, 210)는 기계 학습 입력(들)에 기초하여 기계 학습 출력(들)을 생성함으로써 도 1의 기계 학습 모델 (들)을 구현하기 위해 코어들(212, 214)로 기계 학습 입력(들)을 출력할 수 있다. 코어들(212, 214)은 기계 학습 출력(들)을 디버그 회로부(404, 406)로 출력할 수 있다. 예시적인 동작에서, 디버그 회로부(404, 406)는 기계 학습 출력(들)의 값들, 값들이 기입될 수 있는 메모 리의 어드레스(들) 등을 포함할 수 있는 기계 학습 출력(들)에 기초하여 하나 이상의 중단점이 트리 거되는 것을 결정할 수 있다. 기계 학습 출력(들)에 기초하여 하나 이상의 중단점 중 하나(들)가 트리거 된다는 결정(들)에 응답하여, 디버그 애플리케이션은 하나 이상의 중단점 중 하나(들)를 트리거한 기계 학 습 출력(들)을 획득하는 것, 증분 동작을 실행하는 것 등 및/또는 이들의 조합을 포함할 수 있는 하나 이 상의 디버그 동작을 실행할 수 있다. 도 5는 도 1의 디버그 애플리케이션, 도 1의 메모리 및 예시적인 제6 가속기 회로부를 포함하는 예시적인 제4 가속기 회로부 디버그 시스템의 블록도이다. 일부 예들에서, 도 5의 제6 가속기 회로부 는 도 1의 제1 가속기 회로부 및/또는 제2 가속기 회로부의 예시적인 구현일 수 있다. 도 5의 예시된 예에서, 제6 가속기 회로부는 적어도 제1 예시적인 코어 및 제2 예시적인 코어를 포함하는 예시적인 코어들(504, 506)을 포함한다. 예시된 예에서, 코어들(504, 506)은 도 2의 디버그 레지스터 (들) 및 디버그 인터페이스를 포함하는 도 2의 디버그 회로부(208, 210)를 포함한다. 예시된 예의 코어들(504, 506)은 도 2의 실행 회로부, 구성 레지스터(들), 코어 인터페이스 및 버스를 포함한다. 제6 가속기 회로부는 코어들(504, 506)에 대한 입력(들) 및/또는 보다 일반적으로 기계 학습 입력 (들)에 기초하여 중단점(들)을 트리거 및/또는 달리 호출하도록 인스턴스화된 디버그 회로부(208, 210)로 구현된다. 예시된 예에서, 디버그 회로부(208, 210)의 입력(들)은 메모리의 출력(들)에 결합된다. 예를 들어, 디버그 레지스터(들) 및/또는 디버그 인터페이스의 입력(들)은 메모리의 출력(들)에 결합 된다. 디버그 회로부(208, 210)의 출력(들)은 실행 회로부, 구성 레지스터(들), 코어 인터페이스 , 및/또는 버스의 입력(들)에 결합된다. 코어들(504, 506)의 출력(들)은 메모리의 입력(들)에 결합된다. 예를 들어, 실행 회로부의 출력(들)은 메모리의 입력(들)에 결합된다. 일부 예들에서, 디버그 인터페이스 및 코어 인터페이스는 디버그 애플리케이션과 통신하도록 인스턴스화된다. 도 6은 도 1의 디버그 애플리케이션, 도 1의 메모리 및 예시적인 제7 가속기 회로부를 포함하는 예시적인 제5 가속기 회로부 디버그 시스템의 블록도이다. 일부 예들에서, 도 6의 제7 가속기 회로부 는 도 1의 제1 가속기 회로부 및/또는 제2 가속기 회로부의 예시적인 구현일 수 있다. 도 6의 예시된 예에서, 제7 가속기 회로부는 적어도 제1 예시적인 코어 및 제2 예시적인 코어를 포함하는 예시적인 코어들(604, 606)을 포함한다. 예시된 예에서, 코어들(604, 606)은 도 2의 디버그 레지스터 (들) 및 디버그 인터페이스를 포함하는 도 2의 디버그 회로부(208, 210)를 포함한다. 예시된 예의 코어들(604, 606)은 도 2의 실행 회로부, 구성 레지스터(들), 코어 인터페이스 및 버스를 포함한다. 제7 가속기 회로부는 코어들(604, 606)로부터의 출력(들) 및/또는 보다 일반적으로 기계 학습 출력 (들)에 기초하여 중단점(들)을 트리거 및/또는 달리 호출하도록 인스턴스화된 디버그 회로부(208, 210)로 구현된다. 예시된 예에서, 코어들(604, 606)의 입력(들)은 메모리의 출력(들)에 결합된다. 예를 들어, 실행 회로부의 입력(들)은 메모리의 출력(들)에 결합된다. 실행 회로부, 구성 레지스터 (들), 및/또는 코어 인터페이스의 출력(들)은 (예를 들어, 버스에 의해) 디버그 회로부(208, 210)의 입력(들)에 결합된다. 디버그 회로부(208, 210)의 출력(들)은 메모리의 입력(들)에 결합된다. 예 를 들어, 디버그 레지스터(들), 디버그 인터페이스, 및/또는 보다 일반적으로 디버그 회로부(208, 210)의 출력(들)은 메모리의 입력(들)에 결합된다. 일부 예들에서, 디버그 인터페이스 및 코어 인터 페이스는 디버그 애플리케이션과 통신하도록 인스턴스화된다. 도 7은 도 1의 디버그 애플리케이션, 도 1의 메모리 및 예시적인 제8 가속기 회로부를 포함하는 예시적인 제6 가속기 회로부 디버그 시스템의 블록도이다. 일부 예들에서, 도 7의 제8 가속기 회로부 는 도 1의 제1 가속기 회로부 및/또는 제2 가속기 회로부의 예시적인 구현일 수 있다. 제8 가속기 회로부는 예시적인 코어들(704, 706)을 포함한다. 코어들(704, 706)은 도 2의 디버그 레지스 터(들) 및 디버그 인터페이스를 포함하는 도 2의 디버그 회로부(208, 210), 및 도 4의 디버그 회로부 (404, 406)를 포함한다. 코어들(704, 706)은 도 2의 실행 회로부, 구성 레지스터(들), 코어 인터페 이스 및 버스를 포함한다. 제8 가속기 회로부는 (i) 코어들(704, 706)에 대한 입력(들) 및/또 는 보다 일반적으로 기계 학습 입력(들), 또는 (ii) 코어들(704, 706)로부터의 출력(들) 및/또는 보다 일 반적으로 기계 학습 출력(들) 중 적어도 하나에 기초하여 중단점(들)을 트리거 및/또는 달리 호출하도록 인스턴스화된 디버그 회로부(208, 210, 404, 406)로 구현된다. 도 7의 예시된 예에서, 디버그 회로부(208, 210)의 입력(들)은 메모리의 출력(들)에 결합된다. 예를 들어, 디버그 레지스터(들) 및/또는 디버그 인터페이스의 입력(들)은 메모리의 출력(들)에 결합 된다. 디버그 회로부(208, 210)의 출력(들)은 (예를 들어, 버스에 의해) 실행 회로부, 구성 레지스 터(들), 및/또는 코어 인터페이스의 입력(들)에 결합된다. 실행 회로부, 구성 레지스터 (들), 코어 인터페이스, 및/또는 버스의 출력(들)은 디버그 회로부(404, 406)의 입력(들)에 결 합된다. 예를 들어, 실행 회로부, 구성 레지스터(들), 코어 인터페이스, 및/또는 버스의 출력(들)은 디버그 회로부(404, 406)의 디버그 레지스터(들) 및/또는 디버그 인터페이스에 결합된다. 디버그 회로부(404, 406)의 출력(들)은 메모리의 입력(들)에 결합된다. 일부 예들에서, 디버그 인터페이 스 및 코어 인터페이스는 디버그 애플리케이션과 통신하도록 인스턴스화된다. 예시적인 동작에서, 코어들(704, 706)은 도 1의 ML 모델(들) 중 하나를 구현하기 위해 실행가능 바이너리 를 실행할 수 있다. 실행가능 바이너리의 실행에 응답하여, 코어들(704, 706)은 메모리로부터 기계 학습 입력(들) 중 하나(들)를 요청할 수 있다. 예시적인 동작에서, 디버그 회로부(208, 210)는 요청을 획득할 수 있다. 일부 예들에서, 디버그 회로부(208, 210)는 요청 또는 그와 연관된 데이터(예를 들어, 기계 학습 입 력(들) 중 요청된 것(들)이 메모리에 저장되는 어드레스 또는 어드레스들의 범위)가 중단점을 트리거 한다는 결정에 응답하여 중단점을 트리거할 수 있다. 일부 예들에서, 디버그 회로부(208, 210)는 요청이 중단점을 트리거하지 않았다는 결정에 응답하여, 메모리 로부터 기계 학습 입력(들)을 획득할 수 있다. 디버그 회로부(208, 210)는 기계 학습 입력(들)(20 4)에 기초하여 하나 이상의 중단점이 트리거되는 것을 식별할 수 있다. 기계 학습 입력(들)에 기초하여 하나 이상의 중단점 중 하나(들)가 트리거된다는 식별(들)에 응답하여, 디버그 애플리케이션은 하나 이상 의 중단점 중 하나(들)를 트리거한 기계 학습 입력(들)을 획득하는 것, 증분 동작을 실행하는 것 등 및/또 는 이들의 조합을 포함할 수 있는 하나 이상의 디버그 동작을 실행할 수 있다. 예시적인 동작에서, 디버그 회로부(208, 210)는 기계 학습 입력(들)에 기초하여 기계 학습 출력(들) 을 생성함으로써 도 1의 기계 학습 모델(들)을 구현하기 위해 기계 학습 입력(들)을 실행 회로부 로 출력할 수 있다. 실행 회로부는 기계 학습 출력(들)을 디버그 회로부(404, 406)로 출력할 수 있다. 예시적인 동작에서, 디버그 회로부(404, 406)는 기계 학습 출력(들)에 기초하여 하나 이상의 중단점이 트 리거되는 것을 결정할 수 있다. 기계 학습 출력(들)에 기초하여 하나 이상의 중단점 중 하나(들)가 트리 거된다는 결정에 응답하여, 디버그 애플리케이션은 하나 이상의 중단점 중 하나(들)를 트리거한 기계 학습 출력(들)을 획득하는 것, 증분 동작을 실행하는 것 등 및/또는 이들의 조합을 포함할 수 있는 하나 이상의 디버그 동작을 실행할 수 있다. 도 8a는 도 1의 디버그 애플리케이션, 도 1의 메모리 및 예시적인 제9 가속기 회로부를 포함하 는 예시적인 제7 가속기 회로부 디버그 시스템의 블록도이다. 제9 가속기 회로부는 예시적인 디버그 회로부를 포함한다. 일부 예들에서, 도 8a의 제9 가속기 회로부는 도 1의 제1 가속기 회로부 및/또는 제2 가속기 회로부의 예시적인 구현일 수 있다. 일부 예들에서, 디버그 회로부는 도 1의 디 버그 회로부의 예시적인 구현일 수 있다. 디버그 애플리케이션은, 메모리, 및/또는 제9 가속기 회로부는 명령어들을 실행하는 중앙 처리 유닛과 같은 프로세서 회로부에 의해 인스턴스화될 수 있다. 추 가적으로 또는 대안적으로, 도 8a의 디버그 애플리케이션, 메모리, 제9 가속기 회로부, 및/또는 디버그 회로부는 명령어들에 대응하는 동작들을 수행하도록 구조화된 ASIC 또는 FPGA에 의해 인스턴스화될수 있다. 예시된 예의 제9 가속기 회로부는 제1 예시적인 실행 회로부 스레드(실행 회로부 스레드 0에 의해 식 별됨), 제2 예시적인 실행 회로부 스레드(실행 회로부 스레드 N에 의해 식별됨) 및 예시적인 구성 레지스 터(들)를 포함한다. 일부 예들에서, 제1 실행 회로부 스레드 및/또는 제2 실행 회로부 스레드 는 도 2 내지 도 7의 실행 회로부의 예시적인 구현일 수 있다. 예를 들어, 실행 회로부는 제1 실행 회로부 스레드 및 제2 실행 회로부 스레드를 포함할 수 있는 N+1개의 스레드(예를 들어, 스레드 0- N)를 포함하는 멀티 스레드 실행 회로부(multi-threaded execution circuitry)일 수 있다. 예시된 예에서, 디 버그 회로부는 디버그 회로부를 통해 제1 실행 회로부 스레드 및/또는 제2 실행 회로부 스레드 로 라우팅될 메모리로부터 판독된 입력(들)을 인터셉트 및/또는 분석함으로써 가속기 파이프라인의 시작에서 인스턴스화된다. 일부 예들에서, 구성 레지스터(들)는 도 2의 구성 레지스터(들)의 예시적 인 구현일 수 있다. 일부 예들에서, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드 및 구성 레지 스터(들)는 도 2-4의 제1 코어 및/또는 제2 코어, 도 5의 제1 코어 및/또는 제2 코어 , 도 6의 제1 코어 및/또는 제2 코어 및/또는 도 7의 제1 코어 및/또는 제2 코어의 예시적인 구현일 수 있다. 예시된 예의 디버그 회로부는 제1 예시적인 인터페이스 회로부, 제1 예시적인 비교기 회로부, 제1 예시적인 중단점 레지스터(들), 제2 예시적인 인터페이스 회로부, 제2 예시적인 비교기 회로부 , 제2 예시적인 중단점 레지스터(들), 예시적인 제어 회로부, 예시적인 멀티플렉서 회로부 , 예시적인 카운터 회로부, 및 예시적인 시프트 레지스터를 포함한다. 예시된 예에서, 제1 실 행 회로부 스레드와 제1 인터페이스 회로부 사이의 통신 결합(들)은 제1 예시적인 통신 채널을 구현할 수 있다. 예시된 예에서, 제1 인터페이스 회로부, 메모리 및/또는 멀티플렉서 회로부 간의 통신 결합(들)은 제2 예시적인 통신 채널을 구현할 수 있다. 예시된 예에서, 제2 실행 회로부 스레 드와 제2 인터페이스 회로부 사이의 통신 결합(들)은 제3 예시적인 통신 채널을 구현할 수 있다. 예시된 예에서, 제2 인터페이스 회로부, 메모리 및/또는 멀티플렉서 회로부 사이의 통신 결합(들)은 제4 예시적인 통신 채널을 구현할 수 있다. 예시된 예에서, 제1 실행 회로부 스레드 및 제2 실행 회로부 스레드의 입력(들)은 구성 레지스터 (들)의 출력(들)에 결합된다. 제1 실행 회로부 스레드의 입력(들) 및/또는 출력(들)은 제1 인터페이 스 회로부의 각각의 출력(들) 및/또는 입력(들)에 결합된다. 제1 인터페이스 회로부의 입력(들) 및/ 또는 출력(들)은 메모리, 제1 비교기 회로부, 제어 회로부, 및/또는 멀티플렉서 회로부의 각각의 출력(들) 및/또는 입력(들)에 결합된다. 제1 비교기 회로부의 입력(들) 및/또는 출력(들)은 제어 회로부 및/또는 제1 중단점 레지스터(들)의 각각의 출력(들) 및/또는 입력(들)에 결합된다. 제1 중 단점 레지스터(들)의 입력(들) 및/또는 출력(들)은 제어 회로부의 각각의 출력(들) 및/또는 입력 (들)에 결합된다. 구성 레지스터(들)의 입력(들) 및/또는 출력(들)은 제어 회로부의 각각의 출력(들) 및/또는 입력(들)에 결합된다. 예시된 예에서, 제2 실행 회로부 스레드의 입력(들) 및/또는 출력(들)은 제2 인터페이스 회로부의 각 각의 출력(들) 및/또는 입력(들)에 결합된다. 제2 인터페이스 회로부의 입력(들) 및/또는 출력(들)은 메 모리, 제2 비교기 회로부, 제어 회로부, 및/또는 멀티플렉서 회로부의 각각의 출력(들) 및 /또는 입력(들)에 결합된다. 제2 비교기 회로부의 입력(들) 및/또는 출력(들)은 제어 회로부 및/또 는 제2 중단점 레지스터(들)의 각각의 출력(들) 및/또는 입력(들)에 결합된다. 제2 중단점 레지스터 (들)의 입력(들) 및/또는 출력(들)은 제어 회로부의 각각의 출력(들) 및/또는 입력(들)에 결합된다. 카운터 회로부의 출력(들)은 멀티플렉서 회로부의 입력(들)(예를 들어, 선택 입력(들), 제어 입력(들) 등)에 결합된다. 멀티플렉서 회로부의 출력(들)은 시프트 레지스터의 입력(들)에 결합된다. 시프트 레지스터의 입력(들)은 제어 회로부의 출력(들)에 결합된다. 시프트 레지스터 의 출력(들)은 구성 레지스터(들)의 입력(들)에 결합된다. 예시된 예에서, 구성 레지스터(들)는 디버그 애플리케이션과 통신하도록 인스턴스화된다. 예를 들어, 디버그 애플리케이션은 구성 레지스터(들)로부터 데이터를 판독하고/하거나 그것에 데이터를 기입할 수 있다. 일부 이러한 예들에서, 디버그 애플리케이션은 구성 레지스터(들)로 하여금 제1 실 행 회로부 스레드 및/또는 제2 실행 회로부 스레드를 구성하게 하는 실행가능 바이너리를 구성 레지 스터(들)에 기입할 수 있다. 일부 이러한 예들에서, 실행가능 바이너리는 구성 레지스터(들)에 기입 될 수 있는 하나 이상의 중단점을 포함할 수 있다. 일부 예들에서, 디버그 애플리케이션은 커맨드들, 명령어들 등, 예를 들어 판독 명령어, 단일 스텝 명령어, 재개 명령어 등을 구성 레지스터(들)에 기입할 수 있다. 일부 예들에서, 디버그 애플리케이션은 구성 레지스터(들)에 중단점들을 기입할 수 있으며, 이는 구성 레지스터(들)로 하여금, 예시적인 중단점 구성 명령어(BP CONFIG에 의해 식별됨)를 통해 중단점들을 제어 회로부에 제공하게 할 수 있다. 예시적인 동작에서, 디버그 애플리케이션은 제9 가속기 회로부에 의해 실행 및/또는 인스턴스화될 때 도 1의 기계 학습 모델(들) 중 하나(들)를 구현할 수 있는 실행가능 바이너리(예를 들어, 구성 이미지)를 컴파일할 수 있다. 디버그 애플리케이션은 실행가능 바이너리를 구성 레지스터(들)에 전송, 전달 및 /또는 달리 제공할 수 있다. 실행가능 바이너리를 수신하는 것에 응답하여, 제9 가속기 회로부는 실행가 능 바이너리에 기초한 값들을 구성 레지스터(들)에 로딩할 수 있다. 값들을 로딩하는 것에 응답하여, 구 성 레지스터(들)는 기계 학습 모델(들) 중 하나(들)를 구현하기 위해 제1 실행 회로부 스레드 및/또는 제2 실행 회로부 스레드의 각각의 하나(들)를 구성할 수 있다. 예시적인 동작에서, 제1 실행 회로부 스레드 및/또는 제2 실행 회로부 스레드는 실행가능 바이너리에 기초하여 하드웨어 배열들, 구성들, 설정들 등에 따라 가속기 작업부하들의 실행을 개시할 수 있다. 예를 들어, 제1 실행 회로부 스레드 및/또는 제2 실행 회로부 스레드는 도 2의 기계 학습 입력(들)을 획득하고, 기계 학습 입력(들)에 기초하여 도 2의 기계 학습 출력(들)을 생성할 수 있다. 일부 이러 한 예들에서, 제1 실행 회로부 스레드는 실행가능 바이너리, 또는 그의 부분(들)을 실행할 수 있고/있거나, 제2 실행 회로부 스레드는 실행가능 바이너리, 또는 그의 부분(들)을 실행할 수 있다. 예시적인 동작에서, 제1 실행 회로부 스레드는 실행가능 바이너리의 실행과 관련하여 데이터(예를 들어, 기계 학습 입력(들) 중 하나(들))를 요청할 수 있다. 제1 실행 회로부 스레드는 메모리로부터 판독할 어드레스를 포함할 수 있는 예시적인 요청 신호(REQ/ADR에 의해 식별됨)를 제1 인터페이스 회로부 에 대해 생성할 수 있다. 요청 신호가 중단점을 트리거하지 않는 것에 응답하여, 제1 인터페이스 회 로부는 메모리 판독 동작을 용이하게 하기 위해 제2 통신 채널을 통해 메모리에 요청 신호(84 0)를 제공할 수 있다. 메모리는 메모리가 요청된 데이터를 제공할 준비가 되었음을 제1 실행 회로부 스레드에 표시하기 위해 제1 예시적인 준비 신호(RDY에 의해 식별됨)를 생성할 수 있다. 제1 실행 회로부 스레드는 메모리에 제1 실행 회로부 스레드가 요청된 데이터를 수신할 준비가 되었음을 나타내기 위해 제2 예시적인 준비 신호(RDY에 의해 식별됨)를 생성할 수 있다. 메모리는 예시적인 응답 신호(RSP/DATA에 의해 식별됨)를 통해 요청된 데이터를 제공할 수 있다. 일부 예들에서, 디버그 애플리케이션은 제9 가속기 회로부의 입력(들) 및/또는 출력(들)의 입력(들), 출력(들), 또는 연관 메모리 어드레스(들)에 기초하여 중단점(예를 들어, 중단점 이벤트, 디버그 이벤트 등)을 트리거하기 위해 디버그 회로부를 인스턴스화할 수 있다. 일부 예들에서, 디버그 애플리케이션은 실 행가능 바이너리를 컴파일하여, 호출될 때, 실행가능 바이너리, 또는 그의 부분(들)의 실행을 중단시키는 하나 이상의 제1 중단점을 포함시킬 수 있다. 예를 들어, 디버그 애플리케이션은 실행가능 바이너리를 컴파일 하여 작업부하별로 제1 중단점을 트리거할 수 있으며, 이는 제1 중단점이 특정 또는 타겟 작업부하에 대응할 때 구현될 수 있다. 일부 이러한 예들에서, 디버그 회로부는 제1 중단점을 구성 레지스터(들) 중 하나 (들)에 로딩할 수 있다. 일부 이러한 예들에서, 구성 레지스터(들)는 BP CONFIG 명령어를 통해 제어 회로부에 제1 중단점을 제공할 수 있다. 일부 이러한 예들에서, 제어 회로부는 제1 중단점 레지스터 (들) 및 제2 중단점 레지스터(들)에 제1 중단점을 제공할 수 있다. 일부 예들에서, 제1 비교기 회로부는 제1 인터페이스 회로부 및 제1 통신 채널로부터 인입 데이 터를 제1 중단점 레지스터(들)로부터의 제1 중단점과 비교할 수 있다. 일부 이러한 예들에서, 제1 비교기 회로부는 비교(예를 들어, 인입 데이터가 제1 중단점과 연관된 데이터와 매칭됨)에 기초하여 제1 중단점이 트리거된다는 것을 제어 회로부에 나타낼 수 있다. 일부 이러한 예들에서, 제어 회로부는 제1 비교 기 회로부에 의해 제1 중단점이 트리거되는 것에 기초하여 제1 실행 회로부 스레드가 타겟 작업부하 를 실행했다고 결정할 수 있다. 일부 예들에서, 제2 비교기 회로부는 제2 인터페이스 회로부 및 제3 통신 채널로부터의 인입 데 이터를 제2 중단점 레지스터(들)로부터의 제1 중단점와 비교할 수 있다. 일부 이러한 예들에서, 제2 비교 기 회로부는 비교(예를 들어, 인입 데이터가 제1 중단점과 연관된 데이터와 매칭됨)에 기초하여 제1 중단 점이 트리거됨을 제어 회로부에 나타낼 수 있다. 일부 이러한 예들에서, 제어 회로부는 제2 비교기 회로부에 의해 제1 중단점이 트리거되는 것에 기초하여 제2 실행 회로부 스레드가 타겟 작업부하를실행했다고 결정할 수 있다. 예시적인 동작에서, 제1 실행 회로부 스레드가 작업부하별 중단점을 트리거하는 것에 응답하여, 제어 회로 부는 예시적인 중단점 히트 신호(BP HIT에 의해 식별됨)를 구성 레지스터(들)에 대해 생성한다. 일부 예들에서, BP HIT 신호는 작업부하 특정 중단점의 트리거를 나타낼 수 있다. 예를 들어, BP HIT 신 호는 예시적인 BREAKPOINT_ON_START 신호를 구현할 수 있으며, 이는 작업부하의 제1 데이터 항목에 대해 중단점이 트리거되었음을 나타내기 위해 사용될 수 있다. 일부 예들에서, BP HIT 신호는 예시적인 BREAKPOINT_ON_DATA+DATA 신호를 구현할 수 있으며, 이는 메모리 트랜잭션에서 특정 데이터 항목(+DATA)에 대해 중단점이 트리거되었음을 나타내기 위해 사용될 수 있다. 일부 예들에서, BP HIT 신호는 예시적인 BREAKPOINT_ON_ADR+ADR+MASK 신호를 구현할 수 있으며, 이는 메모리 트랜잭션에서 특정 어드레스(+ADR)에 대해 중단점이 트리거되었음을 나타내기 위해 사용될 수 있다. 일부 이러한 예들에서, 마스크(+MASK)는 어드레스의 어느 비트(들)가 비교 및/또는 분석될지를 나타내기 위해 사용될 수 있다. 유리하게, BREAKPOINT_ON_ADR+ADR+MASK 신호는 전체 어드레스 범위들(뿐만 아니라 특정 어드레스)에 대한 중단점들을 인스 턴스화하는 데 사용될 수 있다. 예시적인 동작에서, BP HIT 신호를 생성하는 것에 응답하여, 제어 회로부는 제1 인터페이스 회로부 에게 요청 신호 및 제1 준비 신호를 풀다운 및/또는 달리 디스에이블하도록 명령할 수 있다. (예를 들어, 요청 신호 및 제1 준비 신호를 논리 로우 신호(예를 들어, 디지털 '0'을 나타내는 신 호)로 변경함으로써) 요청 신호 및 제1 준비 신호를 풀다운하는 것에 응답하여, 제1 인터페이스 회로 부는 제1 실행 회로부 스레드에 의해 구현된 가속기 파이프라인의 일부의 실행을 중단시킨다. 예를 들어, 제1 실행 회로부 스레드는 제1 준비 신호의 디스에이블에 응답하여 메모리로부터 데이터 를 검색할 수 없을 수 있다. 일부 예들에서, 디버그 애플리케이션은 실행가능 바이너리를 컴파일하여, 코어별로 제2 중단점을 트리거할 수 있으며, 이는 제2 중단점이 특정 또는 타겟 코어에 대응할 때 구현될 수 있다. 일부 이러한 예들에서, 디버 그 애플리케이션은 제1 실행 회로부 스레드에 의해 트리거될 때 제1 실행 회로부 스레드에 의한 실행가능 바이너리의 실행을 중단시키는 제2 중단점을 구성 레지스터(들) 중 하나(들)에 로딩할 수 있다. 일부 이러한 예들에서, 제1 실행 회로부 스레드가 중단되고/되거나 그렇지 않으면 실행 일시중단 또는 대 기 상태에 있는 동안, 다른 스레드가 실행가능 바이너리의 실행을 계속할 수 있다. 예시적인 동작에서, 제1 실 행 회로부 스레드가 코어별로 중단점을 트리거하는 것에 응답하여, 제1 비교기 회로부는 제어 회로부(82 4)에 제2 중단점이 히트되었다는 것을 알릴 수 있다. 예시적인 동작에서, 제어 회로부는 제1 비교기 회로 부로부터 표시를 수신한 것에 응답하여 BP HIT 신호를 생성할 수 있다. 일부 예들에서, BP HIT 신호는 코어 특정 중단점(들)의 트리거(들)에 응답하여 생성된 하나 이상의 중단점 구성 신호를 구현할 수 있다. 예를 들어, BP HIT 신호는 예시적인 BREAKPOINT_ON_START 신호를 구현할 수 있으며, 이는 특정 코어 상의 작업부하의 제1 데이터 항목에 대해 중단점이 트리거되었음을 나타내기 위해 사용될 수 있다. 일부 예들에서, BP HIT 신호는 예시적인 BREAKPOINT_ON_DATA+DATA 신호를 구현할 수 있 으며, 이는 특정 코어에 의한 메모리 트랜잭션에서 특정 데이터 항목(+DATA)에 대해 중단점이 트리거되었음을 나타내기 위해 사용될 수 있다. 일부 예들에서, BP HIT 신호는 예시적인 BREAKPOINT_ON_ADR+ADR+MASK 신 호를 구현할 수 있으며, 이는 특정 코어에 의한 메모리 트랜잭션에서 특정 어드레스(+ADR)에 대해 중단점이 트 리거되었음을 나타내기 위해 사용될 수 있다. 일부 이러한 예들에서, 마스크(+MASK)는 어드레스의 어느 비트 (들)가 비교 및/또는 분석될지를 나타내기 위해 사용될 수 있다. 유리하게, BREAKPOINT_ON_ADR+ADR+MASK 신호 는 전체 어드레스 범위들(뿐만 아니라 특정 어드레스)에 대한 중단점들을 인스턴스화하는 데 사용될 수 있다. 예시적인 동작에서, BP 히트 신호가 생성되는 것에 응답하여, 제어 회로부는 제1 인터페이스 회로부 에게 요청 신호 및 제1 준비 신호를 풀다운 및/또는 달리 디스에이블하도록 지시할 수 있다. 요청 신호 및 제1 준비 신호를 풀다운하는 것에 응답하여, 제1 인터페이스 회로부는 제1 실행 회로부 스레드 및/또는 제2 실행 회로부 스레드에 의한 실행가능 바이너리의 실행을 중단시킨다. 일부 예들에서, 제어 회로부는 어떤 유형의 중단점들이 트리거되는지에 대한 표시를 제공할 수 있다. 예 를 들어, 제어 회로부는 BP HIT 신호를 구성 레지스터(들)에 제공할 수 있으며, 이는 제1 실행 회로부 스레드에 의해 실행된 제1 작업부하가 제1 작업부하의 시작 시에 중단점을 트리거했다는 표시(예컨 대, 시작 중단점 표시)를 디버그 애플리케이션에 제공할 수 있다. 일부 예들에서, 제어 회로부는 BP HIT 신호를 구성 레지스터(들)에 제공할 수 있으며, 이는 제2 실행 회로부 스레드에 의해 실행된 제2 작업부하가 입력으로 판독된 데이터 값 또는 중단점의 값과 매칭되는 출력으로서 생성된 데이터 값에 대 해 중단점을 트리거했다는 표시(예를 들어, 데이터 중단점 표시, 데이터 값 매치 중단점 표시 등)를 디버그 애 플리케이션에 제공할 수 있다. 일부 예들에서, 제어 회로부는 BP HIT 신호를 생성할 수 있으며, 이는 제2 실행 회로부 스레드에 의해 실행된 제3 작업부하가 중단점의 값과 매칭되는 것으로부터 데이터 값이 판독되는 제1 메모리 어드레스에 대해 중단점을 트리거했다는 표시(예를 들어, 어드레스 중단점 표 시, 메모리 어드레스 중단점 표시 등)를 디버그 애플리케이션에 제공할 수 있다. 예시적인 동작에서, 제어 회로부는 제1 실행 회로부 스레드에 의해 트리거된 중단점(들) 또는 제1 실 행 회로부 스레드에 의한 실행가능 바이너리의 완료 진행 중 적어도 하나의 표시(들)를 구성 레지스터 (들)에 저장할 수 있다. 예를 들어, 디버그 애플리케이션은 표시(들)에 대해 구성 레지스터 (들)에 질의할 수 있다. 예시적인 동작에서, 제어 회로부는 제1 실행 회로부 스레드에 의해 중 단점을 트리거한 기계 학습 입력, 기계 학습 출력, 또는 연관 어드레스(들) 중 적어도 하나를 저장할 수 있다. 예시적인 동작에서, 디버그 애플리케이션은 기계 학습 입력, 기계 학습 출력, 또는 연관 어드레스(들) 중 적어도 하나에 대해 구성 레지스터(들)에 질의할 수 있다. 예시적인 동작에서, 디버그 애플리케이션(11 4)은 구성 레지스터(들) 중 하나(들)를 수정하여 실행가능 바이너리의 변경을 유발하고 디버깅 목적을 위 해 실행가능 바이너리의 실행을 재개할 수 있다. 예시적인 동작에서, 디버그 애플리케이션은 메모리 및/또는 제1 실행 회로부 스레드에 저장된 기계 학습 입력을 수정하고, 디버깅 목적을 위해 실행가능 바이 너리의 실행을 재개할 수 있다. 일부 예들에서, 디버그 애플리케이션은 제1 중단점 레지스터(들) 및/또는 제2 중단점 레지스터 (들) 중 하나(들)에서 하나 이상의 제1 중단점 및/또는 하나 이상의 제2 중단점을 로딩할 수 있다. 예를 들어, 디버그 애플리케이션은 기계 학습 입력을 나타내는 구성 레지스터(들), 기계 학습 입력이 메모 리에 저장되는 메모리 어드레스 또는 메모리 어드레스들의 범위 등에 제1 값을 저장할 수 있다. 일부 이 러한 예들에서, 제어 회로부는 구성 레지스터(들)로부터 제1 값을 획득하고, 제1 중단점 레지스터(들)에 제1 값을 제공할 수 있다. 예시적인 동작에서, 제1 실행 회로부 스레드에 의한 중단점의 트리거에 응답하여, 제1 인터페이스 회로부 는 제1 실행 회로부 스레드로부터 멀티플렉서 회로부로 데이터(예를 들어, 메모리 판독 동작과 연관된 어드레스, 어드레스들의 범위, 기계 학습 입력 등)를 제공할 수 있다. 카운터 회로부는 멀티플렉 서 회로부에게 멀티플렉서 회로부의 입력들을 통해, 그리고/또는 보다 일반적으로, 실행 회로부 스레 드들(806, 808), 및 멀티플렉서 회로부로부터 출력될 그들 각각의 요소들을 통해 순환하도록 명령하기 위 해 카운터 회로부의 출력의 값을 증분시킬 수 있다. 예를 들어, 카운터 회로부는 멀티플렉서 회로부 에게 제1 실행 회로부 스레드로부터의 판독 요청을 출력하도록 명령하기 위한 0의 제1 카운터 값, 제 1 실행 회로부 스레드로부터의 판독 응답을 출력하기 위한 1의 제2 카운터 값, 제2 실행 회로부 스레드 로부터의 판독 요청을 출력하기 위한 2*N의 제3 카운터 값, 제2 실행 회로부 스레드로부터의 판독 응 답을 출력하기 위한 (2*N)+1의 제4 카운터 값 등을 출력할 수 있다. 예를 들어, 카운터 회로부는 멀티플 렉서 회로부로 하여금, 라운드 로빈 분포 또는 스키마에서 데이터를 출력하게 할 수 있다. 대안적으로, 카운터 회로부는 임의의 다른 시퀀스, 분포 또는 스키마에서 값들을 출력할 수 있다. 일부 예들에서, 카 운터 회로부는 멀티플렉서 회로부로부터 출력될 데이터를 갖지 않는 멀티플렉서 회로부로의 입 력들을 스킵할 수 있다. 예시적인 동작에서, 멀티플렉서 회로부는 기계 학습 입력 및/또는 연관 어드레스(들)와 연관된 데이터를 예시적인 트랜잭션(디버그 트랜잭션에 의해 식별됨)으로서 구성 레지스터(들)를 통해 디버그 애플리 케이션으로 출력할 수 있다. 예를 들어, 트랜잭션은 중단점을 트리거한 기계 학습 입력의 제1 값, 기계 학습 입력이 메모리에 저장되는 어드레스 등 중 적어도 하나를 포함하는 디버그 트랜잭션(예를 들어, 디버그 데이터 트랜잭션)을 구현할 수 있다. 일부 예들에서, 디버그 트랜잭션은 디버그 애플리케이션 및 구성 레지스터(들)를 통해 제어 회로부로부터 예시적인 판독 트랜잭션에 응답하여 생 성된다. 예를 들어, 디버그 애플리케이션은 예시적인 판독 트랜잭션 커맨드(판독에 의해 식별됨)를 구성 레지스터(들)에 기입할 수 있다. 제어 회로부는 구성 레지스터(들)로부터 판독 트랜잭션 커맨드를 획득할 수 있다. 제어 회로부는 판독 트랜잭션 커맨드를 획득하는 것에 응답하여 판 독 트랜잭션을 발행할 수 있다. 예를 들어, 판독 트랜잭션은 디버그 애플리케이션에 의해 생성 된 커맨드, 지시, 명령어 등을 구현할 수 있으며, 이는 시프트 레지스터에 의해 수신될 때, 시프트 레지스 터로 하여금 디버그 트랜잭션을 생성 및/또는 달리 출력하게 한다. 일부 예들에서, 시프트 레지스터는 자원들을 절약하기 위해 단일 비트 단위로 데이터를 판독할 수 있다. 예를 들어, 시프트 레지스터를 1 비트 전진시키기 위해, 디버그 애플리케이션은 판독 트랜잭션 을 펄스화 및/또는 달리 생성할 수 있다. 예를 들어, 디버그 애플리케이션은 예시적인 단일 스텝 커맨드 를 구성 레지스터(들)에 기입할 수 있다. 제어 회로부는 단일 스텝 커맨드를 획득하고, 단일 스텝 커맨드를 획득한 것에 응답하여 판독 트랜잭션을 생성할 수 있다. 대안적으로, 시프트 레 지스터는 임의의 다른 비트 단위(예를 들어, 2 비트 단위, 4 비트 단위, 16 비트 단위 등)로 데이터를 판 독할 수 있다. 일부 예들에서, 시프트 레지스터 내의 비트(예를 들어, 유효 비트)는 디버그 트랜잭션 의 유효한 하나가 캡처되었는지를 나타낼 수 있다. 일부 이러한 예들에서, 판독 클록 사이클들의 수를 줄 이기 위해, 유효 비트는 시프트 레지스터로부터 시프트되는 제1 비트일 수 있다. 일부 이러한 예들에서, 디버그 트랜잭션의 유효한 하나가 캡처되지 않았다는 디버그 애플리케이션에 의한 결정에 응답하여, 디버그 애플리케이션은 시프트 레지스터의 판독을 종료하고 다른 디버그 동작을 진행할 수 있다. 일 부 예들에서, 디버그 애플리케이션은 시프트 레지스터에게 모든 디버그 트랜잭션이 아니라 관심 있는 디버그 트랜잭션을 판독하도록 명령할 수 있다. 예시적인 동작에서, 디버그 애플리케이션은 디버그 회로부 및/또는 보다 일반적으로 제9 가속기 회로 부에게 하나 이상의 단일 스텝 동작을 실행하도록 명령할 수 있다. 예를 들어, 제1 인터페이스 회로부 는 중단점의 호출에 응답하여 요청 신호 및 제1 준비 신호를 풀다운할 수 있다. 일부 이러한 예들에서, 디버그 애플리케이션은 제1 실행 회로부 스레드로부터의 잠재적 출력이 메모리로 전 송될 수 있도록 하기 위해, 단일 스텝 커맨드를 통해 제1 인터페이스 회로부에게 제1 클록 사이클(또 는 디버그 애플리케이션에 의해 명령된 경우 그 이상) 동안 요청 신호 및 제1 준비 신호에 대한 풀다운을 해제하도록 명령할 수 있다. 제1 클록 사이클의 종료 후, 요청 신호 및 제1 준비 신호는 제1 실행 회로부 스레드에 의한 실행가능 바이너리의 실행을 중단시키기 위해 풀다운된다. 출력은 멀티플 렉서 회로부에 제공되고, 이는 시프트 레지스터에 제공될 수 있다. 이에 따라, 디버그 트랜잭션 이 생성될 수 있다. 유리하게, 디버그 애플리케이션은 디버그 회로부로 하여금 별개의 개별적 인 가속기 동작들에서 실행되어, 이전의 구현들에 비해 개선된 입도, 가시성, 및 정확도로 잘못된 구성들, 계산 들, 또는 메모리 판독/기입 동작들을 식별하게 할 수 있다. 예시적인 동작에서, 디버그 애플리케이션은 예시적인 재개 커맨드를 생성함으로써 중단점(들)이 트리 거되는 것에 응답하여, 제1 실행 회로부 스레드 및 제2 실행 회로부 스레드에 의한 실행가능 바이너 리의 동작을 재개하도록 디버그 회로부에 명령할 수 있다. 예를 들어, 디버그 애플리케이션은 재개 커맨드를 구성 레지스터(들)에 기입할 수 있다. 제어 회로부는 재개 커맨드를 획득하는 것에 응답하여, 제1 인터페이스 회로부에게 요청 신호 및 제1 준비 신호에 대한 풀다운 힘들을 해제하도록 명령하여 제1 실행 회로부 스레드와 디버그 회로부 사이의 데이터 전송을 재개할 수 있다. 일부 예들에서, 디버그 애플리케이션은 디버그 회로부에게 인에이블 또는 디스에이블되도록 명령할 수 있다. 예를 들어, 디버그 애플리케이션은 디버그 회로부를 인에이블할 수 있고, 이에 따라 디버 그 회로부로 하여금 임의의 중단점들이 트리거되었는지를 결정하게 할 수 있다. 일부 예들에서, 디버그 애플리케이션은 디버그 회로부를 디스에이블할 수 있고, 이에 따라 디버그 회로부로 하여금 디 버그 회로부가 제1 실행 회로부 스레드 및/또는 제2 실행 회로부 스레드에 의한 실행가능 바이 너리의 실행을 중단시키지 않는 바이패스 모드로 진입하게 할 수 있다. 일부 예들에서, 디버그 애플리케이션은 중단점(들)과 제9 가속기 회로부로의 입력(들) 또는 연관 어 드레스(들) 중 적어도 하나의 비교에 기초하여 작업부하(들)의 실행을 중단시키기 위해 구성 레지스터(들) 중 하나(들)에 중단점(들)을 기입한다. 예를 들어, 디버그 애플리케이션은 기계 학습 입력(들) 중 제1 기계 학습 입력에 기초할 수 있는 제1 중단점을 구성 레지스터(들)에 기입할 수 있다. 제어 회로부 는 구성 레지스터(들)로부터 제1 중단점을 획득하고, 제1 중단점을 제1 중단점 레지스터(들) 중 하나에 기입할 수 있다. 일부 이러한 예들에서, 제1 비교기 회로부는 메모리로부터의 제1 기계 학습 입력과 제1 중단점을 비교할 수 있다. 일부 이러한 예들에서, 비교에 기초한 매치에 응답하여, 제1 비교기 회 로부는 표시를 생성하고, 표시를 제어 회로부로 전송할 수 있다. 제어 회로부는 제1 인터페이 스 회로부로 하여금 요청 신호 및 제1 준비 신호를 풀다운하여 메모리로부터의 데이터 흐 름을 중단시키고, 이에 따라 제1 실행 회로부 스레드에 의한 실행가능 바이너리의 실행을 중단시키게 할 수 있다. 도 1의 제1 가속기 회로부, 제2 가속기 회로부, 및/또는 디버그 회로부를 구현하는 예시적인 방 식이 도 8a에 예시되어 있지만, 도 8a에 예시된 요소들, 프로세스들, 및/또는 디바이스들 중 하나 이상은 임의 의 다른 방식으로 결합, 분할, 재배열, 생략, 제거 및/또는 구현될 수 있다. 또한, 디버그 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 구성 레지스터(들), 제1 인터페이스 회로부 , 제1 비교기 회로부, 제1 중단점 레지스터(들), 제2 인터페이스 회로부, 제2 비교기 회로 부, 제2 중단점 레지스터(들), 제어 회로부, 멀티플렉서 회로부, 카운터 회로부, 예 시적인 시프트 레지스터, 통신 채널들(832, 834, 836, 838), 및/또는 보다 일반적으로, 도 1의 제1 가속기 회로부, 제2 가속기 회로부, 및/또는 디버그 회로부는 하드웨어, 소프트웨어, 펌웨어, 및/또는 하드웨어, 소프트웨어 및/또는 펌웨어의 임의의 조합에 의해 구현될 수 있다. 따라서, 예를 들어, 디버그 회로 부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 구성 레지스터(들), 제1 인터페이 스 회로부, 제1 비교기 회로부, 제1 중단점 레지스터(들), 제2 인터페이스 회로부, 제2 비 교기 회로부, 제2 중단점 레지스터(들), 제어 회로부, 멀티플렉서 회로부, 카운터 회로부 , 예시적인 시프트 레지스터, 통신 채널들(832, 834, 836, 838), 및/또는 보다 일반적으로, 제1 가 속기 회로부, 제2 가속기 회로부, 및/또는 디버그 회로부 중 임의의 것은 프로세서 회로부, 아 날로그 회로(들), 디지털 회로(들), 논리 회로(들), 프로그래머블 프로세서(들), 프로그래머블 마이크로컨트롤 러(들), GPU(들), DSP(들), ASIC(들), PLD(들) 및/또는 FPGA들과 같은 FPLD(들)에 의해 구현될 수 있다. 순전 히 소프트웨어 및/또는 펌웨어 구현을 커버하기 위한 본 특허의 장치 또는 시스템 청구항들 중 임의의 것을 읽 을 때, 디버그 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 구성 레지스터 (들), 제1 인터페이스 회로부, 제1 비교기 회로부, 제1 중단점 레지스터(들), 제2 인터페 이스 회로부, 제2 비교기 회로부, 제2 중단점 레지스터(들), 제어 회로부, 멀티플렉서 회 로부, 카운터 회로부, 예시적인 시프트 레지스터, 및/또는 통신 채널(832, 834, 836, 838) 중 적어도 하나는 이에 따라 소프트웨어 및/또는 펌웨어를 포함하여 비일시적 컴퓨터 판독가능 저장 디바이스 또는 저장 디스크, 예컨대 메모리, DVD(digital versatile disk), CD(compact disk), Blu-ray 디스크 등을 포함하도 록 명시적으로 정의된다. 또한, 도 1의 제1 가속기 회로부, 제2 가속기 회로부 및/또는 디버그 회로 부는 도 8a에 예시된 것들에 더하여 또는 그들 대신에 하나 이상의 요소, 프로세스, 및/또는 디바이스를 포함할 수 있고/있거나, 예시된 요소들, 프로세스들 및 디바이스들 중 임의의 것 또는 전부 중 하나 초과를 포 함할 수 있다. 도 8b는 도 8a의 가속기 회로부의 기입 동작들을 디버깅하기 위한 도 8a의 디버그 회로부의 블록도이 다. 예시된 예에서, 디버그 회로부는 제1 실행 회로부 스레드 및/또는 제2 실행 회로부 스레드(80 8)로부터의 출력(들)을 인터셉트 및/또는 분석함으로써 가속기 파이프라인의 단부에서 인스턴스화된다. 예시된 예는 도 8a의 디버그 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 구성 레지스터 (들), 제1 인터페이스 회로부, 제1 비교기 회로부, 제1 중단점 레지스터(들), 제2 인터페 이스 회로부, 제2 비교기 회로부, 제2 중단점 레지스터(들), 제어 회로부, 멀티플렉서 회 로부, 카운터 회로부, 예시적인 시프트 레지스터, BP CONFIG 신호, BP HIT 신호, 디 버그 트랜잭션, 판독 트랜잭션, 판독 트랜잭션 커맨드, 단일 스텝 커맨드 및 재개 커맨드 를 포함할 수 있다. 도 8b의 예시된 예에서, 제1 실행 회로부 스레드와 제1 인터페이스 회로부 사이의 통신 결합(들)은 제5 예시적인 통신 채널을 구현할 수 있다. 예시된 예에서, 제1 인터페이스 회로부, 메모리 및 /또는 멀티플렉서 회로부 사이의 통신 결합(들)은 제6 예시적인 통신 채널을 구현할 수 있다. 예시 된 예에서, 제2 실행 회로부 스레드와 제2 인터페이스 회로부 사이의 통신 결합(들)은 제7 예시적인 통신 채널을 구현할 수 있다. 예시된 예에서, 제2 인터페이스 회로부, 메모리 및/또는 멀티플 렉서 회로부 사이의 통신 결합(들)은 제8 예시적인 통신 채널을 구현할 수 있다. 예시적인 동작에서, 통신 채널들(862, 864, 866, 868)은 디버그 회로부가 기입 동작들을 디버깅하는 것을 용이하게 한다. 예를 들어, 실행가능 바이너리의 실행에 응답하여, 제1 실행 회로부 스레드는 도 2의 기 계 학습 입력(들) 중 제1 기계 학습 입력(들)에 기초하여 도 2의 기계 학습 출력(들) 중 제1 기계 학 습 출력(들)을 생성할 수 있다. 제1 기계 학습 출력(들)을 생성하는 것에 응답하여, 제1 실행 회로부 스레드 는 예시적인 요청 신호(REQ에 의해 식별됨)를 생성하여, 제1 기계 학습 출력(들)을 메모리에 기 입한다. 제1 실행 회로부 스레드는 예시적인 어드레스/데이터 신호(ADR/DATA에 의해 식별됨)를 생성 할 수 있으며, 이는 메모리에 제1 기계 학습 출력(들)을 기입할 어드레스, 제1 기계 학습 출력(들) 등 및/또는 이들의 조합을 포함할 수 있다. 메모리는 메모리가 기입될 데이터를 수신할 준비가 되었을 때 예시적인 준비 신호(RDY에 의해 식별됨)를 생성할 수 있다. 예시적인 동작에서, 제1 실행 회로부 스레드에 의해 중단점이 트리거되지 않는 것에 응답하여, 제1 인터페 이스 회로부는 제1 실행 회로부 스레드로부터의 기계 학습 출력을 메모리에 제공할 수 있다. 예시적인 동작에서, 제1 인터페이스 회로부는 실행가능 바이너리의 실행에 응답하여, 제1 실행 회로부 스 레드에 의해 생성된 제1 기계 학습 출력(들) 중 하나를 나타내는 제1 값을 수신할 수 있다. 예시적인 동 작에서, 제1 비교기 회로부는 제1 값과 제1 중단점 레지스터(들) 내의 중단점에 기초하는 제2 값을 비교할 수 있다. 매치에 응답하여, 제1 비교기 회로부는 제어 회로부에 매치를 시그널링할 수 있으 며, 제어 회로부는 제1 인터페이스 회로부 및 제2 인터페이스 회로부에게 요청 신호 또는 준비 신호 중 적어도 하나를 풀다운하여 실행가능 바이너리의 실행을 중단시키도록 명령할 수 있다. 예를 들어, 제1 비교기 회로부는 제1 실행 회로부 스레드로부터의 기계 학습 출력, 연관 어드레스(들) 등 이 중단점의 기계 학습 출력, 연관 어드레스(들) 등과 매칭되는 것에 응답하여 실행가능 바이너리의 실행을 일 시 중단시킬 수 있다. 예시적인 동작에서, 멀티플렉서 회로부는 기계 학습 출력, 연관 어드레스(들) 등과 연관된 데이터를 디버 그 트랜잭션으로서 출력할 수 있다. 예를 들어, 디버그 트랜잭션은 중단점을 트리거한 기계 학습 출 력 또는 기계 학습 출력이 메모리에 기입될 어드레스 중 적어도 하나를 포함할 수 있다. 도 8c는 도 8a 및/또는 도 8b의 가속기 회로부의 판독 동작들을 디버깅하기 위한 도 8a 및/또는 도 8b의 디버그 회로부의 다른 예시적인 구현의 블록도이다. 예시된 예의 가속기 회로부는 제1 실행 회로부 스레드, 구성 레지스터(들), 및 도 8a 및/또는 도 8b의 제어 회로부, 멀티플렉서 회로부, 카운터 회로부 및 시프트 레지스터를 포함하는 디버그 회로부를 포함한다. 도 8c에는 도 1의 디버그 애플리케이션 및 메모리가 더 도시되어 있다. 도 8c에는 도 8a 및 도 8b의 BP CONFIG 신호 , BP HIT 신호, 디버그 트랜잭션, 판독 트랜잭션, 판독 트랜잭션 커맨드, 단일 스텝 커맨드 및 재개 커맨드도 도시되어 있다. 예시된 예의 디버그 회로부는 예시적인 실행 회로부에 포함된다. 일부 예들에서, 실행 회로부 는 도 2-5의 제1 코어의 제1 실행 회로부, 도 6의 제1 코어의 실행 회로부 등을 구현할 수 있다. 예를 들어, 디버그 회로부는 실행 회로부 내부의 신호들을 인터셉트하도록 적응될 수 있다. 예시된 예에서, 실행 회로부는 도 8a 및 도 8b의 제1 실행 회로부 스레드 및 제2 실행 회로부 스레드 를 포함 및/또는 달리 구현한다. 예시된 예에서, 제1 예시적인 신호들(876, 877, 878, 879)은 제1 실행 회로부 스레드와 같은 실행 회로부 의 제1 스레드에 대응한다. 예를 들어, 제1 신호들(876, 877, 878, 879)은 제1 실행 회로부 스레드(80 6)에 대응하는 제1 예시적인 요청 신호(REQ_0에 의해 식별됨), 제1 예시적인 어드레스 신호(ADR_0에 의해 식별됨), 제1 예시적인 응답 신호(RSP_0에 의해 식별됨) 및 제1 예시적인 데이터 신호(DATA_0에 의해 식별됨)를 포함할 수 있다. 예시된 예에서, 제2 예시적인 신호들(880, 881, 882, 883)은 제2 실행 회로부 스레드와 같은 실행 회로부 의 제2 스레드에 대응한다. 예를 들어, 제2 신호들(880, 881, 882, 883)은 제2 실행 회로부 스레드(80 8)에 대응하는 제2 예시적인 요청 신호(REQ_N에 의해 식별됨), 제2 예시적인 어드레스 신호(ADR_N에 의해 식별됨), 제2 예시적인 응답 신호(RSP_N에 의해 식별됨) 및 제2 예시적인 데이터 신호(DATA_N에 의해 식별됨)를 포함할 수 있다. 예시적인 동작에서, 메모리로부터 데이터를 판독하기 위한 제1 실행 회로부 스레드에 의한 결정에 응 답하여, 제1 실행 회로부 스레드는 제1 실행 회로부 스레드의 다른 부분으로부터 데이터를 검색하기 위해 제1 요청 신호를 생성한다. 제1 실행 회로부 스레드는 데이터를 판독할 제1 실행 회로부 스레 드 내에 저장된 데이터의 어드레스를 나타내는 제1 어드레스 신호를 생성한다. 실행 회로부는 데이터가 제1 실행 회로부 스레드의 다른 부분으로부터 판독될 준비가 되었음을 나타내는 제1 응답 신호 를 생성한다. 실행 회로부는 요청된 데이터를 포함하는 제1 데이터 신호를 생성한다. 예시적인 동작에서, 제1 요청 신호, 제1 어드레스 신호, 제1 응답 신호 또는 제1 데이터 신호 중 적어도 하나와 연관된 데이터가 멀티플렉서 회로부에 제공된다. 카운터 회로부는 제1 요청 신호, 제1 어드레스 신호 또는 제1 데이터 신호 중 적어도 하나에 대응하는 멀티플렉서 회로부의 입력들을 선택할 수 있다. 멀티플렉서 회로부는 선택된 데이터를 시프트 레지스터로 출력한 다. 시프트 레지스터는 선택된 데이터를 디버그 트랜잭션으로서 구성 레지스터(들)로 출력한다. 디버그 애플리케이션은 구성 레지스터(들)로부터 선택된 데이터를 획득할 수 있다. 예시적인 동작에서, 실행 회로부의 다른 부분으로부터 검색된 어드레스, 어드레스 범위, 또는 데이터의 값 중 적어도 하나에 기초하여 중단점이 트리거되는 것에 응답하여, 제어 회로부는 예시적인 중단 신호들 을 생성함으로써, 실행 회로부에 의한 실행가능 바이너리의 실행을 중단시킬 수 있다. 중단 신호들 은 제1 요청 신호, 제1 응답 신호 및 수반되는 준비 신호(예를 들어, 도 8a의 준비 신호) 를 논리 하이 신호로부터 논리 로우 신호로 풀다운할 수 있다. 예를 들어, 요청된 메모리 어드레스에 기초하여 중단점이 트리거되었다는 결정에 응답하여, 제어 회로부는 중단 신호들 중 각각의 하나(들)를 생성하 여, 제1 요청 신호, 제1 응답 신호, 제2 요청 신호, 제2 응답 신호 및 수반되는 준비 신호 들 중 적어도 하나를 풀다운하여, 실행 회로부를 통한 정보의 흐름을 중단시킬 수 있다. 예시적인 동작에서, 제어 회로부는 단일 스텝 커맨드에 응답하여 실행가능 바이너리의 단일 스텝 실 행을 행할 수 있다. 예를 들어, 제어 회로부는 중단 신호들 중 각각의 하나(들)에게 단일 클록 사이 클, 2개 이상의 클록 사이클 등 동안 제1 요청 신호, 제1 응답 신호, 제2 요청 신호, 제2 응답 신호 및 수반되는 준비 신호들 중 적어도 하나에 대한 풀다운 힘을 해제하도록 명령할 수 있다. 예시적인 동작에서, 제어 회로부는 중단 신호들의 각각의 하나(들)를 생성하여 제1 요청 신호, 제1 응답 신호, 제2 요청 신호, 제2 응답 신호 및 수반되는 준비 신호들 중 적어도 하나에 대한 풀다운 힘들을 해제함으로써 실행가능 바이너리의 실행을 중단 해제할 수 있다. 도 8d는 도 8a 및/또는 도 8b의 가속기 회로부의 기입 동작들을 디버깅하기 위한 도 8a 및/또는 도 8b의 디버그 회로부의 다른 예시적인 구현의 블록도이다. 예시된 예의 가속기 회로부는 제1 실행 회로부 스레드, 구성 레지스터(들), 및 도 8a 및/또는 도 8b의 제어 회로부, 멀티플렉서 회로부, 카운터 회로부, 및 시프트 레지스터를 포함하는 디버그 회로부를 포함한다. 도 8d에는 도 1의 디버그 애플리케이션 및 메모리가 더 도시되어 있다. 도 8d에는 도 8a 및 도 8b의 BP CONFIG 신호 , BP HIT 신호, 디버그 트랜잭션, 판독 트랜잭션, 판독 트랜잭션 커맨드, 단일 스텝 커맨드 및 재개 커맨드도 도시되어 있다. 도 8d에는 도 8c의 실행 회로부 및 중단 신호들(88 4)이 더 도시되어 있다. 예시된 예의 디버그 회로부는 도 8c의 실행 회로부에 포함된다. 예시된 예에서, 제1 예시적인 신호 들(886, 888, 890)은 제1 실행 회로부 스레드와 같은 실행 회로부의 제1 스레드에 대응한다. 예를 들어, 제1 신호들(886, 888, 890)은 제1 실행 회로부 스레드에 대응하는 제1 예시적인 요청 신호 (REQ_0에 의해 식별됨), 제1 예시적인 어드레스/데이터 신호(ADR/DATA_0에 의해 식별됨) 및 제1 예시 적인 준비 신호(RDY_0에 의해 식별됨)를 포함한다. 예시된 예에서, 제2 예시적인 신호들(892, 894, 896)은 제2 실행 회로부 스레드와 같은 실행 회로부 의 제2 스레드에 대응한다. 예를 들어, 제2 신호들(892, 894, 896)은 제2 실행 회로부 스레드에 대응하는 제2 예시적인 요청 신호(REQ_N에 의해 식별됨), 제2 예시적인 어드레스/데이터 신호(ADR/DATA_N에 의 해 식별됨) 및 제2 예시적인 준비 신호(RDY_N에 의해 식별됨)를 포함한다. 예시적인 동작에서, 메모리에 데이터를 기입하기 위한 제1 실행 회로부 스레드에 의한 결정에 응답하 여, 제1 실행 회로부 스레드는 메모리에 데이터를 기입하기 위해 제1 요청 신호를 생성한다. 제1 실행 회로부 스레드는 메모리에 기입할 어드레스(들) 및/또는 데이터를 나타내는 제1 어드레스/ 데이터 신호를 생성한다. 메모리는 데이터가 메모리에 기입될 준비가 되었음을 나타내는 제1 준비 신호를 생성한다. 예시적인 동작에서, 제1 요청 신호 또는 제1 어드레스/데이터 신호 중 적어도 하나와 연관된 데이터 가 멀티플렉서 회로부에 제공된다. 카운터 회로부는 제1 요청 신호 또는 제1 어드레스/데이터 신호 중 적어도 하나에 대응하는 멀티플렉서 회로부의 입력들을 선택할 수 있다. 멀티플렉서 회로부 는 선택된 데이터를 시프트 레지스터로 출력한다. 시프트 레지스터는 선택된 데이터를 디버그 트랜잭션으로서 구성 레지스터(들)로 출력한다. 디버그 애플리케이션은 구성 레지스터 (들)로부터 선택된 데이터를 획득할 수 있다. 예시적인 동작에서, 메모리에 기입될 어드레스, 어드레스 범위, 또는 데이터의 값 중 적어도 하나에 기초 하여 중단점이 트리거되는 것에 응답하여, 제어 회로부는 중단 신호들을 생성함으로써 실행 회로부 에 의한 실행가능 바이너리의 실행을 중단시킬 수 있다. 중단 신호들은 제1 요청 신호, 제1 준 비 신호, 제2 요청 신호 및 제2 준비 신호를 논리 하이 신호로부터 논리 로우 신호로 풀다운할 수 있다. 예를 들어, 요청된 메모리 어드레스에 기초하여 중단점이 트리거되었다는 결정에 응답하여, 제어 회 로부는 중단 신호들 중 각각의 하나(들)를 생성하여, 제1 요청 신호, 제1 준비 신호, 제2 요청 신호 및 제2 준비 신호를 풀다운할 수 있다. 예시적인 동작에서, 제어 회로부는 단일 스텝 커맨드에 응답하여 실행가능 바이너리의 단일 스텝 실 행을 행할 수 있다. 예를 들어, 제어 회로부는 중단 신호들 중 각각의 하나(들)에게 단일 클록 사이 클, 2개 이상의 클록 사이클 등 동안 제1 요청 신호, 제1 준비 신호, 제2 요청 신호 및 제2 준 비 신호 중 적어도 하나에 대한 풀다운을 해제하도록 명령할 수 있다. 예시적인 동작에서, 제어 회로부 는 중단 신호들 중 각각의 하나(들)에게 제1 요청 신호, 제1 준비 신호, 제2 요청 신호 및 제2 준비 신호 중 적어도 하나에 대한 풀다운 힘들을 해제하도록 명령함으로써 실행가능 바이너 리의 실행을 중단해제할 수 있다. 도 9는 도 1의 제1 가속기 회로부, 도 1의 제2 가속기 회로부, 도 2의 제3 가속기 회로부, 도 3 의 제4 가속기 회로부, 도 4의 제5 가속기 회로부, 도 5의 제6 가속기 회로부, 도 6의 제7 가속 기 회로부, 도 7의 제8 가속기 회로부, 및/또는 도 8a-8d의 제9 가속기 회로부의 예시적인 동작 에 대응하는 제1 예시적인 작업 흐름이다. 예시된 예의 제1 작업 흐름은 예시적인 작업부하들(902, 904, 906, 908, 910)의 시퀀스를 구현하여, 예시 적인 입력 텐서에 기초하는 예시적인 출력 텐서를 생성할 수 있다. 예를 들어, 작업부하들(902, 904, 906, 908, 910)은 도 1의 기계 학습 모델(들) 중 하나(들)에 기초하여 신경망 계산 작업부하들을 구 현할 수 있다. 작업부하들(902, 904, 906, 908, 910)은 제1 예시적인 작업부하(작업부하 0에 의해 식별됨), 제2 예시적인 작업부하(작업부하 1에 의해 식별됨), 제3 예시적인 작업부하(작업부하 2에 의해 식별됨), 제4 예시적인 작업부하(작업부하 3에 의해 식별됨) 및 제5 예시적인 작업부하(작업부 하 4에 의해 식별됨)를 포함한다. 예시된 예에서, 작업부하들(902, 904, 906, 908, 910)은 도 2의 제1 코어 및 도 2의 제2 코어와 같 은 하드웨어 가속기의 2개의 코어에 의해 구현될 수 있다. 예시적인 동작에서, 제1 코어는 입력 텐서 에 대해 제1 작업부하를 실행한 후에 제3 작업부하를 실행할 수 있다. 예시적인 동작에서, 제2 코어는 제1 작업부하와 병렬로 입력 텐서에 대해 제2 작업부하를 실행할 수 있다. 제2 작 업부하의 완료에 응답하여, 제2 코어는 제4 작업부하를 실행할 수 있다. 제3 작업부하 및 제4 작업부하의 완료들에 응답하여, 제1 코어 및/또는 제2 코어는 제5 작업부하를 실행하 여 출력 텐서를 생성할 수 있다. 예시된 예의 제1 작업 흐름은 작업부하별로 생성된 예시적인 중단점들(916, 918)을 포함하는 예시적인 가 속기 회로부 동작을 구현할 수 있다. 예를 들어, 예시된 예의 중단점들(916, 918)은 제2 작업부하의 실행 에 대응하는 제1 예시적인 중단점 및 제3 작업부하의 실행에 대응하는 제2 예시적인 중단점을 포함한다. 일부 이러한 예들에서, 중단점들(916, 918)은 제2 작업부하 및 제3 작업부하에 특정적이 며, 이에 따라 제2 작업부하 및 제3 작업부하의 지속기간 동안 각각의 제2 작업부하 및 제3 작 업부하를 실행하는 코어(예를 들어, 제1 코어 또는 제2 코어 상에서 활성화될 수 있다. 일부 예들에서, 제2 코어는 제2 작업부하의 시작에 응답하여 제1 중단점을 트리거할 수 있다. 제1 중단점과 연관된 조건(들)을 충족시키는 것에 응답하여, 제2 디버그 회로부는 제2 코어의 입력 또는 출력에서의 데이터 흐름을 정지시켜 제2 작업부하의 실행을 중단시킬 수 있다. 이 예에서, 제1 코어는 영향을 받지 않으며, 제1 작업부하를 계속 실행할 수 있다. 이 예에서, 제1 코어는 제2 작업부하가 제2 디버그 회로부에 의해 중단되는 동안 제1 작업부하 및 제3 작업부하를 완 료할 수 있다. 유리하게, 제2 코어의 초기 상태(들)는 제2 작업부하의 실행 이전에 잘못된 구성들, 메모리 판독/기입 동작들 등을 식별하기 위해 디버그 애플리케이션에 의한 질의에 응답하여 판독될 수 있 다. 예를 들어, 제2 코어의 초기 상태(들)는 구성 레지스터(들)에 저장된 값들, 실행 회로부에 저장된 기계 학습 입력들의 값들 등을 포함할 수 있다. 일부 예들에서, 제1 코어는 0x42의 값과 매칭되는 제1 코어에 의해 생성된 기계 학습 출력의 기입 동 작의 발생에 응답하여 제2 중단점을 트리거할 수 있다. 유리하게, 제1 코어의 상태(들)는 제3 작업부하의 실행에 응답하여, 잘못된 구성들, 계산들, 메모리 판독/기입 동작들 등을 식별하기 위한 디버그 애 플리케이션에 의한 질의에 응답하여 판독될 수 있다. 예를 들어, 제1 코어의 상태(들)는 구성 레지 스터(들)에 저장된 값들, 실행 회로부에 저장된 기계 학습 입력(들)의 값(들), 메모리에 저장된 기계 학습 입력(들)의 값(들), 실행 회로부에 저장된 기계 학습 출력(들)의 값(들) 등을 포함할 수 있다. 도 10은 예시적인 제11 가속기 회로부의 예시적인 동작에 대응하는 제2 예시적인 작업 흐름이다. 일부 예들에서, 제11 가속기 회로부는 도 1의 제1 가속기 회로부, 도 1의 제2 가속기 회로부, 도 2의 제3 가속기 회로부, 도 3의 제4 가속기 회로부, 도 4의 제5 가속기 회로부, 도 5의 제6 가속기 회로부, 도 6의 제7 가속기 회로부, 도 7의 제8 가속기 회로부, 및/또는 도 8a-8d의 제9 가속기 회로부에 의해 구현될 수 있다. 예시된 예에서, 제11 가속기 회로부는 제1 예시적인 코어(코어 0에 의해 식별됨), 제2 예시적인 코 어(코어 1에 의해 식별됨), 제3 예시적인 코어(코어 2에 의해 식별됨) 및 제4 예시적인 코어 (코어 3에 의해 식별됨)를 포함할 수 있다. 예를 들어, 제1 코어는 도 2의 제1 코어에 의해 구현될 수 있고/있거나, 제2 코어는 도 2의 제2 코어에 의해 구현될 수 있다. 제2 작업 흐름(100 0)에서, 제11 가속기 회로부는 메모리(예를 들어, 도 1의 메모리)로부터 입력들을 판독하고, 출력들 을 생성하고, 출력들을 다시 메모리에 기입한다. 제11 가속기 회로부는 기계 학습 모델(예컨대, 도 1의 기계 학습 모델(들))의 다수의 더 작은 작업부하들을 사용하여 병렬로 코어(1004, 1006, 1008, 1010) 중 하나(들)에서 여러 번의 반복에 걸쳐 루프에서, 실행이 완료되고 기계 학습 모델의 원하는 출력이 달성될 때까 지, 제2 작업 흐름를 실행할 수 있다. 이 예에서, 코어들(1004, 1006, 1008, 1010) 각각은 도 1의 디버 그 회로부, 도 2 내지 도 7의 디버그 회로부(208, 210), 도 4 및 도 7의 디버그 회로부(404, 406), 및/또 는 도 8a 내지 도 8d의 디버그 회로부에 의해 구현될 수 있는 예시적인 디버그 회로부를 포함한다. 일부 예들에서, 코어들(1004, 1006, 1008, 1010) 중 하나(들) 및/또는 보다 일반적으로 제11 가속기 회로부 가 잘못 구성되면, 기계 학습 모델의 실행이 결코 완료되지 않을 수 있거나, 완료되더라도 출력이 예상과 다를 수 있다. 일부 이러한 예들에서, 디버그 회로부는 예상치 못한 출력에 대한 원인을 이해하고, 이어 서, 코어(1004, 1006, 1008, 1010) 중 하나(들) 및/또는 보다 일반적으로 제11 가속기 회로부에 대한 정 정 액션을 실행하여 예상치 못한 출력을 정정하기 위한 디버깅 동작을 수행하기 위해 호출될 수 있다. 예시된 예에서, 디버그 회로부는 예시적인 중단점이 트리거될지를 결정하기 위해 메모리로부터 획 득되고/되거나 메모리로 전송되는 트랜잭션들을 인터셉트하고 분석할 수 있다. 예시된 예의 중단점은 메 모리에 대한 0x11의 데이터 값의 코어들(1004, 1006, 1008, 1010) 중 하나(들)에 의한 기입 동작에 응답하여 트 리거된다. 대안적으로, 중단점은 메모리로부터의 0x11의 데이터 값의 코어들(1004, 1006, 1008, 1010) 중 하나(들)에 의한 판독 동작에 응답하여 트리거될 수 있다. 제2 작업 흐름은 모든 코어들(1004, 1006, 1008, 1010)이 동일한 데이터 기반 중단점으로 구성된 예를 구 현할 수 있다. 코어들(1004, 1006, 1008, 1010) 중 하나(들)가 데이터 값 0x11을 메모리에 기입하는 작업부하 를 실행하는 것에 응답하여, 중단점이 트리거된다. 중단점이 디버그 회로부에 의해 히트될 때, 디버그 회로부는 0x11의 데이터 값을 기입하고자 하는 코어의 파이프라인을 중단시킨다. 예를 들어, 하나 이상의 클록 사이클 후에, 중단점을 트리거한 전체 코어는 디버그 회로부로부터의 배압으로 인해 중단된다. 유리하게, 디버그 회로부는 코어를 중단시켜 메모리로 전송된 트랜잭션들의 분석 및 추출을 달성하고/하 거나 특정 트랜잭션들에 기초하여 상이한 중단점들을 트리거할 수 있다. 유리하게, 디버그 회로부는 메 모리로부터의 입력들 또는 메모리로의 출력들이 예상되는지를 결정하기 위해 실제 트랜잭션 정보의 개선된 가시 성을 달성한다. 예를 들어, 트랜잭션이 예상되지 않으면, 디버그 회로부는 제11 가속기 회로부의 가능한 잘못된 구성의 표시에 대한 가시성을 획득할 수 있다. 일부 이러한 예들에서, 기계 학습 모델(들)(12 4)로부터의 예상 출력은 동일한 기계 학습 모델(들)로 인스턴스화되는 제11 가속기 회로부로부터의 실제 출력과 비교될 수 있다. 유리하게, 디버그 회로부는 비교에 기초하여 미스매치를 식별할 수 있다. 일부 예들에서, 제1 가속기 회로부, 제2 가속기 회로부, 제3 가속기 회로부, 제4 가속기 회로부 , 제5 가속기 회로부, 제6 가속기 회로부, 제7 가속기 회로부, 제8 가속기 회로부, 제9 가속기 회로부, 및/또는 제10 가속기 회로부는 데이터 입력에 기초하여 데이터 출력을 생성하기 위해 실행가능물을 실행하기 위한 수단을 포함하고, 실행가능물은 도 1의 기계 학습 모델(들) 중 하나와같은 기계 학습 모델에 기초한다. 예를 들어, 실행하기 위한 수단은 실행 회로부, 제1 실행 회로부 스레 드, 제2 실행 회로부 스레드, 실행 회로부, 및/또는 보다 일반적으로 도 2의 제1 코어 및/ 또는 제2 코어에 의해 구현될 수 있다. 일부 예들에서, 실행 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 실행 회로부, 및/또는 보다 일반적으로 제1 코어 및/또는 제2 코어 는 도 14의 예시적인 프로세서 회로부와 같은 프로세서 회로부에 의해 인스턴스화될 수 있다. 예를 들어, 실행 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 실행 회로부, 및/ 또는 보다 일반적으로 제1 코어 및/또는 제2 코어는 적어도 도 11의 블록들(1108, 1110, 1112, 1114, 1116, 1118, 1120)에 의해 구현되는 것과 같은 기계 실행 가능 명령어들을 실행하는 도 15의 예시적인 범용 프 로세서 회로부에 의해 인스턴스화될 수 있다. 일부 예들에서, 실행 회로부, 제1 실행 회로부 스레 드, 제2 실행 회로부 스레드, 실행 회로부, 및/또는 보다 일반적으로 제1 코어 및/또는 제 2 코어는 기계 판독가능 명령어들에 대응하는 동작들을 수행하도록 구조화된 도 16의 ASIC 또는 FPGA 회로 부에 의해 구현될 수 있는 하드웨어 논리 회로부에 의해 인스턴스화될 수 있다. 추가적으로 또는 대안적 으로, 실행 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 실행 회로부, 및/ 또는 보다 일반적으로 제1 코어 및/또는 제2 코어는 하드웨어, 소프트웨어 및/또는 펌웨어의 임의의 다른 조합에 의해 인스턴스화될 수 있다. 예를 들어, 실행 회로부, 제1 실행 회로부 스레드, 제2 실 행 회로부 스레드, 실행 회로부, 및/또는 보다 일반적으로 제1 코어 및/또는 제2 코어는 소프트웨어 또는 펌웨어를 실행하지 않고 기계 판독가능 명령어들의 일부 또는 전부를 실행하고/하거나 기계 판 독가능 명령어들에 대응하는 동작들의 일부 또는 전부를 수행하도록 구조화된 적어도 하나 이상의 하드웨어 회 로(예를 들어, 프로세서 회로부, 개별 및/또는 집적 아날로그 및/또는 디지털 회로부, FPGA, ASIC, 비교기, 연 산 증폭기(op-amp), 논리 회로 등)에 의해 구현될 수 있지만, 다른 구조들도 적절하다. 일부 예들에서, 제1 가속기 회로부, 제2 가속기 회로부, 제3 가속기 회로부, 제4 가속기 회로부 , 제5 가속기 회로부, 제6 가속기 회로부, 제7 가속기 회로부, 제8 가속기 회로부, 제9 가속기 회로부, 및/또는 제10 가속기 회로부는 하드웨어 가속기를 디버깅하기 위한 수단을 포함 한다. 예를 들어, 디버깅하기 위한 수단은 디버그 회로부, 제1 디버그 회로부, 제2 디버그 회로부 , 디버그 회로부, 디버그 회로부, 디버그 회로부, 및/또는 디버그 회로부에 의해 구 현될 수 있다. 일부 예들에서, 디버그 회로부, 제1 디버그 회로부, 제2 디버그 회로부, 디버그 회로부, 디버그 회로부, 디버그 회로부 및/또는 디버그 회로부는 도 14의 예시적인 프로 세서 회로부와 같은 프로세서 회로부에 의해 인스턴스화될 수 있다. 예를 들어, 디버그 회로부, 제 1 디버그 회로부, 제2 디버그 회로부, 디버그 회로부, 디버그 회로부, 디버그 회로부 및/또는 디버그 회로부는 적어도 도 11의 블록들(1110, 1112, 1114, 1116, 1118) 및/또는 도 13의 블록 들(1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318)에 의해 구현되는 것과 같은 기계 실행 가능 명령 어들을 실행하는 도 15의 예시적인 범용 프로세서 회로부에 의해 인스턴스화될 수 있다. 일부 예들에서, 디버그 회로부, 제1 디버그 회로부, 제2 디버그 회로부, 디버그 회로부, 디버그 회로부 , 디버그 회로부 및/또는 디버그 회로부는 기계 판독가능 명령어들에 대응하는 동작들을 수행 하도록 구조화된 도 16의 ASIC 또는 FPGA 회로부에 의해 구현될 수 있는 하드웨어 논리 회로부에 의해 인 스턴스화될 수 있다. 추가적으로 또는 대안적으로, 디버그 회로부, 제1 디버그 회로부, 제2 디버그 회로부, 디버그 회로부, 디버그 회로부, 디버그 회로부, 및/또는 디버그 회로부는 하드웨어, 소프트웨어 및/또는 펌웨어의 임의의 다른 조합에 의해 인스턴스화될 수 있다. 예를 들어, 디버그 회로부, 제1 디버그 회로부, 제2 디버그 회로부, 디버그 회로부, 디버그 회로부, 디 버그 회로부, 및/또는 디버그 회로부는 소프트웨어 또는 펌웨어를 실행하지 않고 기계 판독가능 명 령어들의 일부 또는 전부를 실행하고/하거나 기계 판독가능 명령어들에 대응하는 동작들의 일부 또는 전부를 수 행하도록 구조화된 적어도 하나 이상의 하드웨어 회로(예를 들어, 프로세서 회로부, 개별 및/또는 집적 아날로 그 및/또는 디지털 회로부, FPGA, ASIC, 비교기, 연산 증폭기(op-amp), 논리 회로 등)에 의해 구현될 수 있지만, 다른 구조들도 적절하다. 일부 예들에서, 디버깅하기 위한 수단은 데이터 입력 또는 데이터 출력 중 적어도 하나를 수신하기 위한 수단을 포함한다. 일부 이러한 예들에서, 수신하기 위한 수단은 실행하기 위한 수단의 출력에 결합된 입력 또는 실행 하기 위한 수단의 입력에 결합된 출력 중 적어도 하나를 갖는다. 예를 들어, 수신하기 위한 수단은 제1 인터페 이스 회로부 및/또는 제2 인터페이스 회로부에 의해 구현될 수 있다. 일부 이러한 예들에서, 수신하 기 위한 제1 수단은 제1 인터페이스 회로부에 의해 구현될 수 있고, 수신하기 위한 제2 수단은 제2 인터페 이스 회로부에 의해 구현될 수 있다. 일부 예들에서, 수신하기 위한 수단의 입력은 저장하기 위한 수단에 결합되고, 수신하기 위한 수단의 출력은 실 행하기 위한 수단의 입력에 결합되며, 수신하기 위한 수단은 저장하기 위한 수단으로부터 데이터 입력을 수신하 고, 중단점이 트리거되지 않는 것에 응답하여 실행하기 위한 수단의 입력에 데이터 입력을 제공한다. 일부 이 러한 예들에서, 실행하기 위한 수단은 실행하기 위한 수단의 출력으로부터 저장하기 위한 수단에 데이터 출력을 제공한다. 일부 예들에서, 수신하기 위한 제1 수단은 제1 인터페이스 회로부에 의해 구현될 수 있고, 수 신하기 위한 제2 수단은 제2 인터페이스 회로부에 의해 구현될 수 있다. 일부 예들에서, 수신하기 위한 제1 수단은 제2 인터페이스 회로부에 의해 구현될 수 있고, 수신하기 위한 제2 수단은 제1 인터페이스 회 로부에 의해 구현될 수 있다. 일부 예들에서, 저장하기 위한 제1 수단은 메모리에 의해 구현될 수 있다. 일부 예들에서, 실행하기 위한 수단은 제1 코어, 제1 코어의 실행 회로부, 제2 코어 , 제2 코어의 실행 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 실행 회로부 등에 의해 구현될 수 있다. 일부 예들에서, 실행하기 위한 수단의 입력은 저장하기 위한 수단에 결합되고, 수신하기 위한 수단의 입력은 실 행하기 위한 수단의 출력에 결합되며, 수신하기 위한 수단의 출력은 저장하기 위한 수단에 결합되고, 실행하기 위한 수단은 저장하기 위한 수단으로부터 데이터 입력을 수신하고, 실행하기 위한 수단의 출력으로부터 수신하 기 위한 수단의 입력에 데이터 출력을 제공한다. 일부 이러한 예들에서, 수신하기 위한 수단은 중단점이 트리 거되지 않는 것에 응답하여 저장하기 위한 수단에 데이터 출력을 제공한다. 일부 예들에서, 수신하기 위한 제1 수단은 제1 인터페이스 회로부에 의해 구현될 수 있고, 수신하기 위한 제2 수단은 제2 인터페이스 회로부 에 의해 구현될 수 있다. 일부 예들에서, 수신하기 위한 제1 수단은 제2 인터페이스 회로부에 의해 구현될 수 있고, 수신하기 위한 제2 수단은 제1 인터페이스 회로부에 의해 구현될 수 있다. 일부 예들에 서, 저장하기 위한 제1 수단은 메모리에 의해 구현될 수 있다. 일부 예들에서, 실행하기 위한 수단은 제1 코어, 제1 코어의 실행 회로부, 제2 코어, 제2 코어의 실행 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 실행 회로부 등에 의해 구현될 수 있다. 일부 예들에서, 디버깅하기 위한 수단은 디버깅하기 위한 제1 수단이고, 수신하기 위한 수단은 수신하기 위한 제1 수단이고, 수신하기 위한 제1 수단의 입력은 저장하기 위한 수단에 결합되고, 수신하기 위한 제1 수단은 저 장하기 위한 수단으로부터 데이터 입력을 수신한다. 일부 이러한 예들에서, 수신하기 위한 제1 수단은 중단점 이 트리거되지 않는 것에 응답하여 실행하기 위한 수단에 데이터 입력을 제공한다. 일부 예들에서, 하드웨어 가속기를 디버깅하기 위한 제2 수단은 수신하기 위한 제2 수단을 포함한다. 일부 이러한 예들에서, 실행하기 위한 수단의 출력에 결합된 수신하기 위한 제2 수단의 입력, 저장하기 위한 수단에 결합된 수신하기 위한 제2 수단의 출력, 및 디버깅하기 위한 제2 수단은 실행하기 위한 수단으로부터 데이터 출력을 수신하는 것, 중단점 의 트리거에 응답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 출력하는 것, 또는 중단점이 트리거되지 않는 것에 응답하여 데이터 출력을 저장하기 위한 수단으로 출력하는 것 중 적어도 하나를 행한다. 일부 예들에서, 디버깅하기 위한 수단은 수신하기 위한 수단을 선택하기 위한 수단을 포함한다. 일부 이러한 예들에서, 선택하기 위한 수단은 수신하기 위한 수단의 출력에 결합된 입력을 갖는다. 예를 들어, 선택하기 위 한 수단은 멀티플렉서 회로부에 의해 구현될 수 있다. 일부 예들에서, 디버깅하기 위한 수단은 실행가능물의 실행과 연관된 중단점의 트리거에 응답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 출력하기 위한 수단을 포함한다. 일부 이러한 예들에서, 출력하기 위한 수 단은 선택하기 위한 수단의 출력에 결합된 입력을 갖는다. 예를 들어, 출력하기 위한 수단은 시프트 레지스터 에 의해 구현될 수 있다. 일부 예들에서, 데이터 입력 또는 데이터 출력 중 적어도 하나는 제1 값을 포함하고, 디버깅하기 위한 수단은 디버깅하기 위한 수단을 제어하기 위한 수단을 포함하고, 제어하기 위한 수단은 저장하기 위한 제1 수단으로부 터 중단점에 대응하는 제2 값을 획득한다. 일부 이러한 예들에서, 제2 값을 저장하기 위한 제2 수단은 제어하 기 위한 수단에 결합된다. 일부 이러한 예들에서, 제1 값과 제2 값을 비교하기 위한 비교하기 위한 수단은 수 신하기 위한 수단의 출력에 결합된다. 예를 들어, 비교하기 위한 수단의 제1 입력은 수신하기 위한 수단의 출 력에 결합되고, 비교하기 위한 수단의 제2 입력은 저장하기 위한 제2 수단 및 제어하기 위한 수단에 결합된다. 일부 예들에서, 제어하기 위한 수단은 비교에 기초하는 제1 값과 제2 값의 매치에 응답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 선택하기 위한 수단에 제공하도록 수신하기 위한 수단을 제어하고, 중단점의 트 리거링은 매치에 응답하고, 제어하기 위한 수단은 비교하기 위한 수단으로부터 매치의 표시를 수신하도록 수신 하기 위한 수단을 제어한다. 일부 이러한 예들에서, 디버깅하기 위한 제1 수단은 제1 디버그 회로부, 디 버그 회로부, 디버그 회로부, 및/또는 디버그 회로부에 의해 구현될 수 있다. 일부 이러한 예들에서, 디버깅하기 위한 제2 수단은 제2 디버그 회로부 및/또는 디버그 회로부에 의해 구현될 수 있 다. 일부 이러한 예들에서, 저장하기 위한 제1 수단은 구성 레지스터(들)에 의해 구현될 수 있다. 일부 이러한 예들에서, 저장하기 위한 제2 수단은 제1 중단점 레지스터(들) 및/또는 제2 중단점 레지스터 (들)에 의해 구현될 수 있다. 일부 예들에서, 수신하기 위한 제1 수단은 제1 인터페이스 회로부에 의해 구현될 수 있고, 수신하기 위한 제2 수단은 제2 인터페이스 회로부에 의해 구현될 수 있다. 일부 예 들에서, 수신하기 위한 제1 수단은 제2 인터페이스 회로부에 의해 구현될 수 있고, 수신하기 위한 제2 수 단은 제1 인터페이스 회로부에 의해 구현될 수 있다. 일부 예들에서, 디버깅하기 위한 제1 수단 또는 디 버깅하기 위한 제2 수단 중 적어도 하나는 실행하기 위한 수단에 포함된다. 일부 예들에서, 데이터 입력은 제1 데이터 입력이고, 데이터 출력은 제1 데이터 출력이고, 수신하기 위한 수단 은 수신하기 위한 제1 수단이고, 실행하기 위한 수단은 실행하기 위한 제1 수단이고, 수신하기 위한 제2 수단은 제2 데이터 입력 또는 제2 데이터 출력 중 적어도 하나를 수신하고, 수신하기 위한 제2 수단의 입력은 실행하기 위한 제2 수단에 결합된다. 일부 이러한 예들에서, 증분시키기 위한 수단은 카운터를 증분시키고, 증분시키기 위한 수단의 출력은 선택하기 위한 수단의 선택 입력에 결합되고, 증분시키기 위한 수단은 카운터의 제1 값을 출력하여 선택하기 위한 수단에게 수신하기 위한 제1 수단의 출력을 선택하도록 명령하고, 카운터의 제2 값을 출력하여 선택하기 위한 수단에게 수신하기 위한 제2 수단의 출력을 선택하도록 명령한다. 일부 이러한 예들에 서, 실행하기 위한 제1 수단은 실행 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 실행 회로부, 및/또는 보다 일반적으로 도 2의 제1 코어 및/또는 제2 코어에 의해 구현될 수 있 다. 일부 이러한 예들에서, 실행하기 위한 제2 수단은 실행 회로부, 제1 실행 회로부 스레드, 제2 실행 회로부 스레드, 실행 회로부, 및/또는 보다 일반적으로 도 2의 제1 코어 및/또는 제2 코어 에 의해 구현될 수 있다. 일부 예들에서, 수신하기 위한 제1 수단은 제1 인터페이스 회로부에 의해 구현될 수 있고, 수신하기 위한 제2 수단은 제2 인터페이스 회로부에 의해 구현될 수 있다. 일부 예들에 서, 수신하기 위한 제1 수단은 제2 인터페이스 회로부에 의해 구현될 수 있고, 수신하기 위한 제2 수단은 제1 인터페이스 회로부에 의해 구현될 수 있다. 일부 예들에서, 증분시키기 위한 수단은 카운터 회로부 에 의해 구현될 수 있다. 도 1의 가속기 회로부(108, 110)(또는 도 8a-8d의 가속기 회로부와 같은 본 명세서에 설명된 임의의 다른 가속기 회로부) 및/또는 도 1의 디버그 회로부(또는 도 8a-8d의 디버그 회로부와 같은 본 명세서에 설명된 임의의 다른 디버그 회로부)를 구현하기 위한 예시적인 하드웨어 논리 회로부, 기계 판독가능 명령어들, 하드웨어 구현 상태 기계들, 및/또는 이들의 임의의 조합을 나타내는 흐름도들이 도 11-13에 도시되어 있다. 기계 판독가능 명령어들은 도 14와 관련하여 아래에서 설명되는 예시적인 프로세서 플랫폼에 도시된 프로 세서 회로부 및/또는 도 15 및/또는 도 16과 관련하여 아래에서 설명되는 예시적인 프로세서 회로부와 같 은 프로세서 회로부에 의한 실행을 위한 하나 이상의 실행가능 프로그램 또는 실행가능 프로그램의 부분(들)일 수 있다. 프로그램은 하나 이상의 하드웨어 디바이스에 위치하는 프로세서 회로부와 연관된 CD, 플로피 디스크, 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD), DVD, 블루레이 디스크, 휘발성 메모리(예 를 들어, 임의의 유형의 RAM(Random Access Memory) 등), 또는 비휘발성 메모리(예를 들어, EEPROM(electrically erasable programmable read-only memory), 플래시 메모리, HDD, SSD 등)와 같은 하나 이 상의 비일시적 컴퓨터 판독가능 저장 매체에 저장된 소프트웨어에 구현될 수 있지만, 전체 프로그램 및/또는 그 부분들은 대안적으로 프로세서 회로부가 아닌 하나 이상의 하드웨어 디바이스에 의해 실행될 수 있고/하거나 펌 웨어 또는 전용 하드웨어에 구현될 수 있다. 기계 판독가능 명령어들은 다수의 하드웨어 디바이스에 걸쳐 분산 될 수 있고/있거나, 둘 이상의 하드웨어 디바이스(예를 들어, 서버 및 클라이언트 하드웨어 디바이스)에 의해 실행될 수 있다. 예를 들어, 클라이언트 하드웨어 디바이스는 엔드포인트 클라이언트 하드웨어 디바이스(예를 들어, 사용자와 연관된 하드웨어 디바이스) 또는 중간 클라이언트 하드웨어 디바이스(예를 들어, 서버와 엔드포 인트 클라이언트 하드웨어 디바이스 간의 통신을 용이하게 할 수 있는 RAN(radio access network) 게이트웨이) 에 의해 구현될 수 있다. 유사하게, 비일시적 컴퓨터 판독가능 저장 매체들은 하나 이상의 하드웨어 디바이스 에 위치하는 하나 이상의 매체를 포함할 수 있다. 또한, 예시적인 프로그램이 도 11 내지 도 13에 예시된 흐름 도들을 참조하여 설명되지만, 예시적인 가속기 회로부(108, 110) 및/또는 예시적인 디버그 회로부를 구현 하는 많은 다른 방법들이 대안적으로 사용될 수 있다. 예를 들어, 블록들의 실행 순서가 변경될 수 있고/있거 나, 설명된 블록들 중 일부가 변경, 제거 또는 결합될 수 있다. 추가적으로 또는 대안적으로, 블록들 중 일부 또는 전부는 소프트웨어 또는 펌웨어를 실행하지 않고 대응하는 동작을 수행하도록 구조화된 하나 이상의 하드 웨어 회로(예를 들어, 프로세서 회로부, 개별 및/또는 집적 아날로그 및/또는 디지털 회로부, FPGA, ASIC, 비교 기, 연산 증폭기(op-amp), 논리 회로 등)에 의해 구현될 수 있다. 프로세서 회로부는 상이한 네트워크 위치들에 분산되고/되거나, 단일 기계 내의 하나 이상의 하드웨어 디바이스(예를 들어, 단일 코어 프로세서(예를 들어, 단일 코어 중앙 프로세서 유닛(CPU), 멀티-코어 프로세서(예를 들어, 멀티-코어 CPU) 등), 서버 랙의 다 수의 서버에 걸쳐 분산된 다수의 프로세서, 하나 이상의 서버 랙에 걸쳐 분산된 다수의 프로세서, 동일한 패키 지(예를 들어, 동일한 집적 회로(IC) 패키지 또는 둘 이상의 개별 하우징 등)에 위치하는 CPU 및/또는 FPGA에 대해 국지적일 수 있다. 본 명세서에서 설명되는 기계 판독가능 명령어들은 압축된 포맷, 암호화된 포맷, 단편화된 포맷, 컴파일된 포맷, 실행가능 포맷, 패키징된 포맷 등 중 하나 이상으로 저장될 수 있다. 본 명세서에 설명된 기계 판독가능 명령어들은 기계 실행가능 명령어들을 생성, 제조 및/또는 생산하는 데 이용될 수 있는 데이터 또는 데이터 구 조로서(예를 들여, 명령어들, 코드, 코드의 표현들 등의 부분들로서) 저장될 수 있다. 예를 들어, 기계 판독가 능 명령어들은 네트워크 또는 네트워크들의 집합의 동일하거나 상이한 위치들(예를 들어, 클라우드, 에지 디바 이스들 등)에 위치하는 하나 이상의 저장 디바이스 및/또는 컴퓨팅 디바이스(예를 들어, 서버) 상에 단편화되고 저장될 수 있다. 기계 판독가능 명령어들은 이들이 컴퓨팅 디바이스 및/또는 다른 기계에 의해 직접 판독가능 하고, 해석가능하고/하거나, 실행가능하게 하기 위해, 설치, 수정, 적응, 업데이트, 결합, 보완, 구성, 해독, 압축 해제, 언팩킹, 배포, 재할당, 컴파일 등 중 하나 이상을 필요로 할 수 있다. 예를 들어, 기계 판독가능 명령어들은 개별적으로 압축되고, 암호화되고/되거나, 별개의 컴퓨팅 디바이스들 상에 저장되는 다수의 부분에 저장될 수 있으며, 부분들은 해독, 압축 해제 및/또는 결합될 때 본 명세서에 설명된 것과 같은 프로그램을 함 께 형성할 수 있는 하나 이상의 동작을 구현하는 기계 실행가능 명령어들의 세트를 형성한다. 다른 예에서, 기계 판독가능 명령어들은 프로세서 회로부에 의해 판독될 수 있지만, 특정 컴퓨팅 디바이스 또는 다른 디바이스 상에서 기계 판독가능 명령어들을 실행하기 위해 라이브러리(예를 들어, 동적 링크 라이브러리 (DLL)), 소프트웨어 개발 키트(SDK), 애플리케이션 프로그래밍 인터페이스(API) 등의 추가를 필요로 하는 상태 로 저장될 수 있다. 다른 예에서, 기계 판독가능 명령어들은 기계 판독가능 명령어들 및/또는 대응하는 프로그 램(들)이 전체적으로 또는 부분적으로 실행될 수 있기 전에 구성될 필요가 있을 수 있다(예를 들면, 설정들 저 장, 데이터 입력, 네트워크 어드레스들 기록 등). 따라서, 본 명세서에서 사용되는 바와 같이, 기계 판독가능 매체들은 기계 판독가능 명령어들 및/또는 프로그램(들)이 저장되거나 다른 방식으로 고정되거나 수송 중일 때 기계 판독가능 명령어들 및/또는 프로그램(들)의 특정 포맷 또는 상태에 관계없이 기계 판독가능 명령어들 및/ 또는 프로그램(들)을 포함할 수 있다. 본 명세서에 설명된 기계 판독가능 명령어들은 임의의 과거, 현재 또는 미래의 명령어 언어, 스크립팅 언어, 프 로그래밍 언어 등으로 표현될 수 있다. 예를 들어, 기계 판독가능 명령어들은 다음의 언어들: C, C++, Java, C#, Perl, Python, JavaScript, HTML(HyperText Markup Language), SQL(Structured Query Language), Swift 등 중 임의의 것을 사용하여 표현될 수 있다. 전술한 바와 같이, 도 11-13의 예시적인 동작들은 하나 이상의 비일시적 컴퓨터 및/또는 기계 판독가능 매체, 예컨대 광학 저장 디바이스들, 자기 저장 디바이스들, HDD, 플래시 메모리, 판독 전용 메모리(ROM), CD, DVD, 캐시, 임의의 유형의 RAM, 레지스터, 및/또는 임의의 지속기간 동안(예를 들어, 연장된 기간들 동안, 영구적으 로, 짧은 인스턴스들 동안, 일시적인 버퍼링 동안 그리고/또는 정보의 캐싱 동안) 정보가 저장되는 임의의 다른 저장 디바이스 또는 저장 디스크에 저장된 실행가능 명령어들(예를 들어, 컴퓨터 및/또는 기계 판독가능 명령어 들)을 사용하여 구현될 수 있다. 본 명세서에서 사용되는 바와 같이, 용어 비일시적 컴퓨터 판독가능 매체 및 비일시적 컴퓨터 판독가능 저장 매체는 임의의 유형의 컴퓨터 판독가능 저장 디바이스 및/또는 저장 디스크를 포함하고, 전파 신호들을 배제하고, 전송 매체들을 배제하도록 명시적으로 정의된다. \"포함하는(Including)\" 및 \"포함하는(comprising)\"(및 이들의 모든 형태들 및 시제들)은 본 명세서에서 개방형 용어들로 사용된다. 따라서, 청구항이 임의의 형태의 \"포함하다(include)\" 또는 \"포함하다(comprise)\"(예를 들 어, comprises, includes, 포함하는(comprising), 포함하는(including), 갖는(having) 등)를 프리앰블로서 또 는 임의의 종류의 청구항 기재 내에서 사용할 때마다, 추가적인 요소들, 용어들 등이 대응하는 청구항 또는 기 재의 범위를 벗어나지 않고 존재할 수 있다는 것을 이해해야 한다. 본 명세서에서 사용되는 바와 같이, 문구 \"적어도\"가 예를 들어 청구항의 프리앰블에서 전이 용어로서 사용될 때, 이는 용어 \"포함하는(comprising)\" 및 \"포함하는(including)\"이 개방형인 것과 동일한 방식으로 개방형이다. 용어 \"및/또는\"은 예를 들어 A, B, 및/ 또는 C와 같은 형태로 사용될 때 A 단독, B 단독, C 단독, A와 B, A와 C, B와 C, 또 는 A와 B와 C와 같은 A, B, C의 임의의 조합 또는 서브세트를 지칭한다. 구조들, 컴포넌트들, 항목들, 객 체들 및/또는 사물들을 설명하는 맥락에서 본 명세서에서 사용되는 바와 같이, 문구 \"A 및 B 중 적어도 하나\"는 적어도 하나의 A, 적어도 하나의 B, 또는 적어도 하나의 A 및 적어도 하나의 B 중 임의의 것을 포함하는 구현들을 지칭하도록 의도된다. 유사하게, 구조들, 컴포넌트들, 항목들, 객체들 및/또는 사물들을 설명 하는 맥락에서 본 명세서에서 사용되는 바와 같이, 문구 \"A 또는 B 중 적어도 하나\"는 적어도 하나의 A, 적어도 하나의 B, 또는 적어도 하나의 A 및 적어도 하나의 B 중 임의의 것을 포함하는 구현들을 지칭하 도록 의도된다. 프로세스들, 명령어들, 액션들, 활동들 및/또는 단계들의 수행 또는 실행을 설명하는 맥락에서 본 명세서에서 사용되는 바와 같이, 문구 \"A 및 B 중 적어도 하나\"는 적어도 하나의 A, 적어도 하나의 B, 또는 적어도 하나의 A 및 적어도 하나의 B 중 임의의 것을 포함하는 구현들을 지칭하도록 의도된다. 유 사하게, 프로세스들, 명령어들, 액션들, 활동들 및/또는 단계들의 수행 또는 실행을 설명하는 맥락에서 본 명세 서에서 사용되는 바와 같이, 문구 \"A 또는 B 중 적어도 하나\"는 적어도 하나의 A, 적어도 하나의 B, 또 는 적어도 하나의 A 및 적어도 하나의 B 중 임의의 것을 포함하는 구현들을 지칭하도록 의도된다. 본 명세서에서 사용되는 바와 같이, 단수 참조들(예를 들어, \"하나의(a)\", \"하나의(an)\", \"제1\", \"제2\" 등)는 복수를 배제하지 않는다. 본 명세서에서 사용되는 바와 같이, 용어 \"하나의(a)\" 또는 \"하나의(an)\" 객체는 해 당 객체의 하나 이상을 지칭한다. 용어 \"하나의(a)\"(또는 \"하나의(an)\"), \"하나 이상의\", 및 \"적어도 하나의\" 는 본 명세서에서 상호 교환가능하게 사용된다. 또한, 개별적으로 열거되더라도, 복수의 수단, 요소 또는 방법 액션은 예를 들어 동일한 엔티티 또는 객체에 의해 구현될 수 있다. 또한, 개별적인 특징들이 상이한 예들 또 는 청구항들에 포함될 수 있지만, 이들은 가능하게는 조합될 수 있으며, 상이한 예들 또는 청구항들 내의 포함 은 특징들의 조합이 실현 가능하지 않고/않거나 유리하지 않다는 것을 암시하지 않는다. 도 11은 가속기 회로부에 대해 디버그 동작(들)을 실행하기 위해 프로세서 회로부에 의해 실행 및/또는 인스턴 스화될 수 있는 예시적인 기계 판독가능 명령어들 및/또는 예시적인 동작들을 나타내는 흐름도이다. 도 11의 기계 판독가능 명령어들 및/또는 동작들은 블록 1102에서 시작하며, 여기서 도 1의 디버그 애플리케 이션은 기계 학습(ML) 모델과 연관된 중단점(들)을 생성한다. 예를 들어, 디버그 애플리케이션은 기 계 학습 입력(들)의 제1 값, 메모리로부터 제1 값이 판독되는 어드레스의 제2 값, 기계 학습 출력(들)의 제3 값, 제3 값이 메모리에 기입되는 어드레스의 제4 값 등 및/또는 이들의 조합에 응답 하여 트리거될 중단점을 생성할 수 있다. 블록 1102를 구현하기 위해 프로세서 회로부에 의해 실행 및/또는 인 스턴스화될 수 있는 예시적인 기계 판독가능 명령어들 및/또는 예시적인 동작들이 도 12와 관련하여 아래에 설 명된다. 블록 1104에서, 디버그 애플리케이션은 가속기 회로부에 의해 실행될 중단점(들) 또는 ML 모델 중 적어도 하나에 기초하여 실행가능물을 컴파일한다. 예를 들어, 디버그 애플리케이션은 기계 학습 모델(들) 에 기초하여 실행가능 바이너리를 컴파일할 수 있고, 실행가능 바이너리는 중단점을 포함할 수 있다. 블록 1106에서, 디버그 회로부는 중단점(들) 또는 ML 모델 중 적어도 하나에 기초하여 디버그 회로부 또는 가속기 회로부 중 적어도 하나를 구성한다. 예를 들어, 디버그 회로부는 디버그 레지스터(들)에 중 단점을 저장하여, 중단점이 히트 또는 트리거되는 것에 응답하여 실행가능 바이너리의 실행을 중단시키도록 디 버그 회로부를 구성할 수 있다. 일부 예들에서, 실행가능 바이너리의 실행에 응답하여, 제1 코어는 기계 학습 모델(들)에 기초하여 실행 회로부를 구성하는 데 이용될 수 있는 값(들)을 구성 레지스터 (들)에 저장할 수 있다. 일부 이러한 예들에서, 실행가능 바이너리의 실행에 응답하여, 제1 코어는 구성 레지스터(들)에 중단점을 저장할 수 있다. 블록 1108에서, 가속기 회로부(108, 110)는 실행가능물을 실행하여 입력(들)에 기초하는 출력(들)을 생성한다. 예를 들어, 제1 실행 회로부 스레드는 메모리로부터 기계 학습 입력(들) 중 제1 기계 학습 입력 을 획득하고, 제1 기계 학습 입력에 기초하여 기계 학습 출력(들) 중 제1 기계 학습 출력을 생성할 수 있 다. 블록 1110에서, 디버그 회로부는 입력(들)에 기초하여 중단점(들)을 트리거할지를 결정한다. 예를 들어, 디버그 회로부는 메모리로부터 제1 기계 학습 입력이 판독되는 어드레스의 제1 값이 중단점의 제2 값 과 매칭되는 것에 응답하여 중단점을 트리거하기로 결정할 수 있다. 일부 예들에서, 디버그 회로부는 제1 기계 학습 입력의 제3 값이 중단점의 제4 값과 매칭되는 것에 응답하여 중단점을 트리거하기로 결정할 수 있다. 블록 1110에서, 디버그 회로부가 입력(들)에 기초하여 중단점(들)을 트리거하기로 결정하면, 블록 1112에 서, 디버그 회로부는 실행가능물의 실행을 중단시킨다. 예를 들어, 제1 비교기 회로부는 제1 실행 회로부 스레드와 관련하여 중단점이 트리거되었음을 나타내는 제어 회로부에 대한 출력을 생성할 수 있다. 일부 이러한 예들에서, 제어 회로부는 BP HIT 신호를 생성하고, 제1 인터페이스 회로부 에게 제1 실행 회로부 스레드 및 제2 실행 회로부 스레드의 요청 신호, 제1 준비 신호, 응답 신호 등을 풀다운하도록 명령하여 메모리로부터의 데이터 흐름을 중단시킬 수 있다. 블록 1112에서 실행가능물의 실행을 중단시키는 것에 응답하여, 제어는 디버그 동작(들)을 실행하기 위해 블록 1116으로 진행한다. 예를 들어, 시프트 레지스터는 제1 기계 학습 입력에 기초하여 중단점의 트리거링에 대응하는 디버그 트랜잭션을 출력할 수 있다. 블록 1116을 구현하기 위해 프로세서 회로부에 의해 실행 및/또는 인스턴스화될 수 있는 예시적인 기계 판독가능 명령어들 및/또는 예시적인 동작들이 도 13과 관련하여 이하에서 설명된다. 블록 1110에서, 디버그 회로부가 입력(들)에 기초하여 중단점(들)을 트리거하지 않기로 결정하면, 제어는 블록 1114로 진행하여, 출력(들)에 기초하여 중단점(들)을 트리거할지를 결정한다. 예를 들어, 디버그 회로부 는 제1 기계 학습 출력이 메모리 또는 실행 회로부의 상이한 부분(예컨대, 도 8d의 실행 회로부(87 5)의 상이한 부분)에 기입될 어드레스의 제5 값이 중단점의 제6 값과 매칭되는 것에 응답하여 중단점을 트리거 하기로 결정할 수 있다. 일부 예들에서, 디버그 회로부는 제1 기계 학습 출력의 제7 값이 중단점의 제8 값과 매칭되는 것에 응답하여 중단점을 트리거하기로 결정할 수 있다. 블록 1114에서, 디버그 회로부가 출력(들)에 기초하여 중단점(들)을 트리거하기로 결정하면, 블록 1112에 서, 디버그 회로부는 실행가능물의 실행을 중단시킨다. 예를 들어, 제1 비교기 회로부는 제1 기계 학습 출력(또는 이와 연관된 데이터)이 중단점을 트리거했다고 결정할 수 있다. 일부 이러한 예들에서, 제1 비 교기 회로부는 제어 회로부에 대한 출력을 생성하여, 제어 회로부에 중단점이 트리거되었음을 알릴 수 있다. 일부 이러한 예들에서, 제어 회로부는 BP HIT 신호를 생성하고, 제1 인터페이스 회로 부에게 요청 신호, 제1 준비 신호 및 응답 신호를 풀다운하도록 명령하여 제1 실행 회로부 스레드로부터의 데이터 흐름을 중단시킨다. 블록 1112에서 실행가능물의 실행을 중단시키는 것에 응답하여, 제어는 디버그 동작(들)을 실행하기 위해 블록 1116으로 진행한다. 예를 들어, 시프트 레지스터는 제1 기계 학습 출력에 기초하여 중단점의 트리거링에 대응하는 디버그 트랜잭션을 출력할 수 있다. 일부 예들에서, 시프트 레지스터는 임의의 다른 유형 의 중단점에 대응하는 디버그 트랜잭션을 출력할 수 있다. 일부 예들에서, 중단점이 히트된 후에, 디버그 트랜잭션들의 하나 이상의 후속하는 것들이 구성 레지스터(들)로 판독될 수 있다. 블록 1116에서 디 버그 동작(들)을 실행하는 것에 응답하여, 제어는 블록 1118로 진행하여, ML 출력(들)을 생성하거나 ML 출력(들)을 메모리에 기입하기 위해 실행 회로부에 ML 입력(들)을 제공한다. 블록 1114에서, 디버그 회로부가 출력(들)에 기초하여 중단점(들)을 트리거하지 않기로 결정하면, 제어는 블록 1118로 진행하여, ML 출력(들)을 생성하거나 ML 출력(들)을 메모리에 기입하기 위해 실행 회로부에 ML 입 력(들)을 제공한다. 예를 들어, 제1 인터페이스 회로부는 메모리로부터 판독된 제1 기계 학습 입력 을 제1 실행 회로부 스레드에 제공하여 제1 실행 회로부 스레드로 하여금 제1 기계 학습 출력을 생성 하게 할 수 있다. 일부 예들에서, 제1 인터페이스 회로부는 제1 실행 회로부 스레드로부터 메모리 로 제1 기계 학습 출력을 제공할 수 있다. 블록 1118에서 ML 입력(들)을 실행 회로부에 제공하여 ML 출력 (들)을 생성하거나 ML 출력(들)을 메모리에 기입하는 것에 응답하여, 제어는 블록 1120으로 진행하여, 실행가능 물의 실행이 완료되었는지를 결정한다. 블록 1120에서, 제1 가속기 회로부 및/또는 제2 가속기 회로부가 실행가능물의 실행(들)이 완료되지 않았다고 결정하면, 제어는 블록 1108로 되돌아가서, 입력(들)에 기초하여 출력(들)을 생성하기 위해 실행가능 물을 실행한다. 블록 1120에서, 가속기 회로부(108, 110)가 실행가능물의 실행이 완료되었다고 결정하면, 도 11의 기계 판독가능 명령어들 및/또는 동작들이 종료된다. 도 12는 기계 학습(ML) 모델과 연관된 중단점(들)을 생성하기 위해 프로세서 회로부에 의해 실행 및/또는 인스 턴스화될 수 있는 예시적인 기계 판독가능 명령어들 및/또는 예시적인 동작들을 나타내는 흐름도이다. 일부 예들에서, 기계 판독가능 명령어들 및/또는 동작들은 도 11의 블록 1102를 구현할 수 있다. 도 12 의 기계 판독가능 명령어들 및/또는 동작들은 블록 1202에서 시작하며, 여기서 디버그 애플리케이션(11 4)은 중단점을 추가할지를 결정한다. 예를 들어, 디버그 애플리케이션은 하나 이상의 코어 특정 중단점 (예컨대, 코어별로 트리거될 중단점들), 하나 이상의 작업부하 특정 중단점(예를 들어, 작업부하별로 트리거될 중단점들) 등 및/또는 이들의 조합(들)을 추가할지를 결정할 수 있다. 블록 1202에서, 디버그 애플리케이션이 중단점을 추가하지 않기로 결정하면, 도 12의 기계 판독가능 명령 어들 및/또는 동작들이 종료된다. 예를 들어, 도 12의 기계 판독가능 명령어들 및/또는 동작들은도 11의 기계 판독가능 명령어들 및/또는 동작들의 블록 1104로 되돌아가서, 가속기 회로부에 의해 실행 될 중단점(들) 또는 ML 모델 중 적어도 하나에 기초하여 실행가능물을 컴파일할 수 있다. 블록 1202에서, 디버그 애플리케이션이 중단점을 추가하기로 결정하면, 블록 1204에서, 디버그 애플리케이 션은 추가될 중단점의 유형을 결정한다. 예를 들어, 디버그 애플리케이션은 즉각적인 중단점(예컨대, 작업부하의 시작시 트리거될 중단점, 도 9의 제1 중단점 등), 어드레스 중단점(예컨대, 어 드레스 또는 어드레스들의 범위에 기초하여 트리거될 중단점), 데이터 중단점(예컨대, 데이터의 값에 기초하여 트리거될 중단점, 도 9의 제2 중단점 등) 등을 추가하기로 결정할 수 있다. 블록 1206에서, 디버그 애플리케이션은 추가될 중단점이 코어 특정 중단점인지 또는 작업부하 특정 중단점 인지를 결정한다. 예를 들어, 디버그 애플리케이션은 추가될 중단점이 도 9의 제1 중단점 또는 제2 중단점에 의해 구현될 수 있는 코어 특정 중단점인 것으로 결정할 수 있다. 일부 예들에서, 디버그 애플 리케이션은 추가될 중단점이 도 10의 중단점에 의해 구현될 수 있는 작업부하 특정 중단점인 것으로 결정할 수 있다. 블록 1206에서, 디버그 애플리케이션이 추가될 중단점이 코어 특정 중단점인 것으로 결정하면, 제어는 블 록 1208로 진행하여 대응하는 코어(들)의 구성 레지스터(들)에 중단점을 기입한다. 예를 들어, 디버그 애플리 케이션은 특정 코어에 대응하는 도 8a-8d의 구성 레지스터(들)에 코어 특정 중단점을 기입할 수 있다. 블록 1208에서 대응하는 코어(들)의 구성 레지스터(들)에 중단점을 기입하는 것에 응답하여, 제어는 블 록 1202로 되돌아가서 다른 중단점을 추가할지를 결정한다. 블록 1206에서, 디버그 애플리케이션이 추가될 중단점이 작업부하 특정 중단점인 것으로 결정하면, 제어는 블록 1210으로 진행하여, 일단 실행을 위해 코어에 배치되면 구성 레지스터(들)에 기입될 작업부하 실행가능물 로 중단점을 컴파일한다. 예를 들어, 디버그 애플리케이션은 실행가능 바이너리가 실행을 위해 코어에 배 치될 때 도 8a-8d의 구성 레지스터(들)에 기입될 실행가능 바이너리(예를 들어, 작업부하 실행가능 바이너 리, 작업부하 실행가능 바이너리 파일 등)에 작업부하 특정 중단점을 기입할 수 있다. 블록 1210에서 실행을 위해 코어에 배치되면 구성 레지스터(들)에 기입될 작업부하 실행가능물로 중단점을 컴파일하는 것에 응답하여, 제어는 블록 1202로 되돌아가서 다른 중단점을 추가할지를 결정한다. 도 13은 디버그 동작(들)을 실행하기 위해 프로세서 회로부에 의해 실행 및/또는 인스턴스화될 수 있는 예시적 인 기계 판독가능 명령어들 및/또는 예시적인 동작들을 나타내는 흐름도이다. 일부 예들에서, 기계 판독 가능 명령어들 및/또는 동작들은 도 11의 블록 1116을 구현할 수 있다. 도 13의 기계 판독가능 명령어들 및/또는 동작들은 블록 1302에서 시작하며, 여기서 디버그 애플리케이션은 호출된 중단점(들)에 대 해 디버그 회로부에 질의한다. 예를 들어, 디버그 애플리케이션은 구성 레지스터(들)로부터 호출된 중단점(들)을 검색할 수 있다. 블록 1304에서, 디버그 회로부는 기계 학습(ML) 입력(들), ML 출력(들), 또는 연관 메모리 어드레스(들) 중 적어도 하나를 출력한다. 예를 들어, 디버그 애플리케이션은 판독 트랜잭션 커맨드를 구성 레지 스터(들)에 기입할 수 있다. 일부 이러한 예들에서, 제어 회로부는 구성 레지스터(들)로부터 판독 트랜잭션 커맨드를 검색하고, 판독 트랜잭션을 생성할 수 있다. 판독 트랜잭션에 응답하 여, 시프트 레지스터는 제1 기계 학습 입력(들) 중 제1 기계 학습 입력, 기계 학습 출력(들) 중 제1 기계 학습 출력, 제1 기계 학습 입력과 연관된 메모리 어드레스, 제1 기계 학습 출력과 연관된 메모리 어드 레스 등을 디버그 트랜잭션의 일부로서 구성 레지스터(들)로 출력할 수 있다. 일부 이러한 예들에서, 디버그 애플리케이션은 제1 기계 학습 입력(들) 중 제1 기계 학습 입력, 기계 학습 출력 (들) 중 제1 기계 학습 출력, 제1 기계 학습 입력과 연관된 메모리 어드레스, 제1 기계 학습 출력과 연관 된 메모리 어드레스 등을 구성 레지스터(들)로부터 검색할 수 있다. 블록 1306에서, 디버그 회로부 및/또는 디버그 애플리케이션은 코어(들)에 의해 실행되는 작업부하 (들)의 완료의 진행(들)을 결정한다. 예를 들어, 디버그 애플리케이션은 실행가능 바이너리, 제1 실행 회 로부 스레드에 의해 실행될 작업부하(들) 등의 완료의 상태 또는 진행을 구성 레지스터(들)로부터 요 청할 수 있다. 블록 1308에서, 디버그 회로부 및/또는 디버그 애플리케이션은 가속 회로부의 구성 이미지와 연관된 데이터를 수정할지를 결정한다. 예를 들어, 디버그 애플리케이션은 구성 레지스터(들) 중 하나(들) 에 상이한 값(들)을 기입함으로써 도 8a-8d의 가속기 회로부에 의해 구현될 구성 이미지의 부분(들)의 수정, 조정 등을 행할지를 결정할 수 있다. 블록 1308에서, 디버그 회로부 및/또는 디버그 애플리케이션이 가속 회로부의 구성 이미지와 연관된 데이터를 수정하지 않기로 결정하면, 제어는 ML 모델과 연관된 데이터를 수정할지를 결정하기 위해 블록 1312로 진행한다. 블록 1308에서, 디버그 회로부 및/또는 디버그 애플리케이션이 가속 회로부의 구성 이미 지와 연관된 데이터를 수정하기로 결정하면, 블록 1310에서, 디버그 애플리케이션은 구성 레지스터(들)의 값(들)을 조정하여 구성 이미지를 수정한다. 예를 들어, 디버그 애플리케이션은 구성 레지스터(들) 중 하나(들)에 상이한 값(들)을 기입함으로써 도 8a-8d의 가속기 회로부에 의해 구현될 구성 이미지의 부 분(들)의 수정, 조정 등을 행할 수 있다. 블록 1310에서 구성 레지스터(들)의 값(들)을 조정하여 구성 이미지를 수정하는 것에 응답하여, 디버그 회로부 및/또는 디버그 애플리케이션은 블록 1312에서 ML 모델과 연관된 데이터를 수정할지를 결정한다. 예를 들어, 디버그 애플리케이션은 메모리 내의 기계 학습 입력(들)의 값(들), 제1 실행 회로부 스레드 내의 기계 학습 입력(들)의 값(들) 등 및/또는 이들의 조합을 조정할지를 결정할 수 있다. 블록 1312에서, 디버그 회로부 및/또는 디버그 애플리케이션이 ML 모델과 연관된 데이터를 수정하지 않기로 결정하면, 제어는 블록 1318로 진행한다. 블록 1312에서, 디버그 회로부 및/또는 디버그 애플리케 이션이 ML 모델과 연관된 데이터를 수정하기로 결정하면, 블록 1314에서, 디버그 회로부 및/또는 디 버그 애플리케이션은 가속기 회로부 및/또는 메모리에서 ML 입력(들)의 값(들)을 조정한다. 예를 들어, 디버그 애플리케이션은 메모리 내의 기계 학습 입력(들)의 값(들), 제1 실행 회로부 스레드 내의 기계 학습 입력(들)의 값(들) 등 및/또는 이들의 조합의 변경, 수정, 조정 등을 행할 수 있다. 블록 1316에서, 디버그 회로부 및/또는 디버그 애플리케이션은 중단점(들)의 값(들)을 조정한다. 예 를 들어, 디버그 애플리케이션은 구성 레지스터(들), 제1 중단점 레지스터(들), 제2 중단점 레 지스터(들) 등 및/또는 이들의 조합에 저장된 중단점(들)의 상이한 값(들)을 기입할 수 있다. 블록 1318에서, 디버그 회로부 및/또는 디버그 애플리케이션은 가속기 회로부에게 실행가능물의 증분 동작(들)을 실행하도록 명령할지를 결정한다. 예를 들어, 디버그 애플리케이션은 디버그 회로부에게 하나 이상의 판독, 기입 또는 계산 동작을 실행하도록 명령할 수 있다. 일부 이러한 예들에서, 디버그 애플리 케이션은 단일 스텝 커맨드를 구성 레지스터(들)에 기입할 수 있으며, 이는 제어 회로부로 하여금 단일 스텝 동작을 실행하게 할 수 있다. 블록 1318에서, 디버그 회로부 및/또는 디버그 애플리케이션이 가속기 회로부에게 실행가능물의 증분 동작(들)을 실행하도록 명령하지 않기로 결정하면, 도 13의 기계 판독가능 명령어들 및/또는 동작들은 종 료된다. 예를 들어, 도 13의 기계 판독가능 명령어들 및/또는 동작들은 도 11의 기계 판독가능 명령어들 및/또는 동작들의 블록 1118로 되돌아가서, 실행 회로부에 ML 입력(들)을 제공하여 ML 출력(들)을 생성하 거나 ML 출력(들)을 메모리에 기입할 수 있다. 블록 1318에서, 디버그 회로부 및/또는 디버그 애플리케이션이 가속기 회로부에게 실행가능물의 증분 동작(들)을 실행하도록 명령하기로 결정하면, 블록 1320에서, 디버그 회로부 및/또는 디버그 애플리케이션 은 판독, 기입 또는 계산 동작(들) 중 적어도 하나를 포함하는 증분 동작(들)을 실행한다. 예를 들어, 디 버그 애플리케이션은, 단일 스텝 커맨드 및 제어 회로부를 통해, 도 8a의 제1 인터페이스 회로 부에게 제1 클록 사이클 동안 요청 신호, 제1 준비 신호 및 응답 신호에 대한 힘들을 해제 하여 판독 동작을 용이하게 하고, 이어서 제1 클록 사이클 이후에 요청 신호, 제1 준비 신호 및 응답 신호를 풀다운하도록 명령할 수 있다. 일부 예들에서, 디버그 애플리케이션은, 단일 스텝 커맨드 및 제어 회로부를 통해, 도 8b의 제1 인터페이스 회로부에게 제1 클록 사이클 동안 요청 신호 , 제1 준비 신호 및 응답 신호를 풀업하여 기입 동작을 용이하게 하고, 이어서 제1 클록 사이클 이후에 요청 신호, 제1 준비 신호 및 응답 신호를 풀다운하도록 명령할 수 있다. 일부 예들에 서, 디버그 애플리케이션은, 판독 트랜잭션 커맨드 및 제어 회로부를 통해, 시프트 레지스터 에게 판독 트랜잭션에 응답하여 디버그 트랜잭션을 출력하도록 명령할 수 있다. 블록 1318에서 판독, 기입 또는 계산 동작(들) 중 적어도 하나를 포함하는 증분 동작(들)을 실행하는 것에 응답 하여, 도 13의 기계 판독가능 명령어들 및/또는 동작들은 종료된다. 예를 들어, 도 13의 기계 판독가능 명령어들 및/또는 동작들은 도 11의 기계 판독가능 명령어들 및/또는 동작들의 블록 1120으로 되돌 아가서 실행가능물의 실행이 완료되었는지를 결정할 수 있다. 도 14는 도 11-13의 기계 판독가능 명령어들 및/또는 동작들을 실행 및/또는 인스턴스화하여 도 1의 제1 가속기 회로부, 제2 가속기 회로부, 디버그 회로부 및 디버그 애플리케이션을 구현하도록 구조화 된 예시적인 프로세서 플랫폼의 블록도이다. 프로세서 플랫폼은 예를 들어 서버, 개인용 컴퓨터, 워크스테이션, 자가 학습 기계(예를 들어, 신경망), 모바일 디바이스(예를 들어, 셀 폰, 스마트폰, iPadTM 등의 태블릿), PDA(personal digital assistant), 인터넷 기기, 디지털 비디오 레코더, 블루레이 플레이어, 게임 콘 솔, 개인용 비디오 레코더, 셋톱 박스, 헤드셋(예를 들어, 증강 현실(AR) 헤드셋, 가상 현실(VR) 헤드셋 등) 또 는 다른 웨어러블 디바이스, 또는 임의의 다른 유형의 컴퓨팅 디바이스일 수 있다. 예시된 예의 프로세서 플랫폼은 프로세서 회로부를 포함한다. 예시된 예의 프로세서 회로부(141 2)는 하드웨어이다. 예를 들어, 프로세서 회로부는 임의의 원하는 패밀리 또는 제조업자로부터의 하나 이상의 집적 회로, 논리 회로, FPGA 마이크로프로세서, CPU, GPU, DSP, 및/또는 마이크로컨트롤러에 의해 구현 될 수 있다. 프로세서 회로부는 하나 이상의 반도체 기반(예를 들어, 실리콘 기반) 디바이스에 의해 구 현될 수 있다. 이 예에서, 프로세서 회로부는 도 1의 디버그 회로부 및 디버그 애플리케이션 을 구현한다. 예를 들어, 프로세서 회로부는 도 8a-8d의 디버그 회로부 및/또는 도 10의 디버그 회 로부를 구현할 수 있다. 예시된 예의 프로세서 회로부는 로컬 메모리(예를 들어, 캐시, 레지스터 등)를 포함한다. 예시된 예의 프로세서 회로부는 버스에 의해 휘발성 메모리 및 비휘발성 메모리를 포함하는 메인 메모리와 통신한다. 일부 예들에서, 버스는 도 1의 버스를 구현한다. 휘발성 메모리는 SDRAM(Synchronous Dynamic Random-Access Memory), DRAM(Dynamic Random-Access Memory), RDRAM®(RAMBUS® Dynamic Random-Access Memory), 및/또는 임의의 다른 유형의 RAM 디바이스에 의해 구현될 수 있다. 비휘발성 메모리는 플래시 메모리 및/또는 임의의 다른 원하는 유형의 메모리 디바이스에 의해 구현될 수 있다. 예시된 예의 메인 메모리(1414, 1416)에 대한 액세스는 메모리 컨트롤러에 의해 제어된다. 예시된 예의 프로세서 플랫폼은 또한 인터페이스 회로부를 포함한다. 인터페이스 회로부는 이더넷 인터페이스, USB(universal serial bus) 인터페이스, 블루투스® 인터페이스, NFC(near field communication) 인터페이스, PCI 인터페이스, 및/또는 PCIe 인터페이스와 같은 임의의 유형의 인터페이스 표준 에 따라 하드웨어에 의해 구현될 수 있다. 예시된 예에서, 하나 이상의 입력 디바이스는 인터페이스 회로부에 접속된다. 입력 디바이스 (들)는 사용자가 프로세서 회로부에 데이터 및/또는 커맨드들을 입력하는 것을 허용한다. 입력 디 바이스(들)는 예를 들어 오디오 센서, 마이크로폰, 카메라(스틸 또는 비디오), 키보드, 버튼, 마우스, 터 치스크린, 트랙-패드, 트랙볼, 아이소포인트 디바이스, 및/또는 음성 인식 시스템에 의해 구현될 수 있다. 하나 이상의 출력 디바이스는 또한 예시된 예의 인터페이스 회로부에 접속된다. 출력 디바이스(들)은 예를 들어 디스플레이 디바이스들(예를 들어, LED(light emitting diode), OLED(organic light emitting diode), LCD(liquid crystal display), CRT(cathode ray tube) 디스플레이, IPS(in-place switching) 디스플레이, 터치스크린 등), 촉각 출력 디바이스, 프린터, 및/또는 스피커에 의해 구현될 수 있다. 따라서, 예시된 예의 인터페이스 회로부는 통상적으로 그래픽 드라이버 카드, 그래픽 드라이버 칩, 및/또 는 GPU와 같은 그래픽 프로세서 회로부를 포함한다. 이 예에서, 출력 디바이스(들)는 도 1의 사용자 인 터페이스를 구현한다. 예시된 예의 인터페이스 회로부는 또한 네트워크에 의한 외부 기계들(예를 들어, 임의의 종류의 컴 퓨팅 디바이스들)과의 데이터 교환을 용이하게 하기 위해 송신기, 수신기, 송수신기, 모뎀, 주거용 게이트웨이, 무선 액세스 포인트, 및/또는 네트워크 인터페이스와 같은 통신 디바이스를 포함한다. 통신은 예를 들어 이더 넷 접속, DSL(digital subscriber line) 접속, 전화선 접속, 동축 케이블 시스템, 위성 시스템, 현장선 무선 시스템, 셀룰러 전화 시스템, 광학 접속 등에 의해 이루어질 수 있다. 예시된 예의 프로세서 플랫폼은 또한 소프트웨어 및/또는 데이터를 저장하기 위한 하나 이상의 대용량 저 장 디바이스를 포함한다. 이러한 대용량 저장 디바이스들의 예들은 자기 저장 디바이스들, 광학 저장 디바이스들, 플로피 디스크 드라이브들, HDD들, CD들, 블루레이 디스크 드라이브들, RAID(redundant array of independent disks) 시스템들, 플래시 메모리 디바이스들 및/또는 SSD들과 같은 솔리드 스테이트 저장 디바 이스들, 및 DVD 드라이브들을 포함한다. 도 11-13의 기계 판독가능 명령어들에 의해 구현될 수 있는 기계 실행가능 명령어들은 대용량 저장 디바 이스, 휘발성 메모리, 비휘발성 메모리, 및/또는 CD 또는 DVD와 같은 이동식 비일시적 컴퓨 터 판독가능 저장 매체에 저장될 수 있다. 도 14의 예시된 예의 프로세서 플랫폼은 도 1의 제1 가속기 회로부 및 제2 가속기 회로부를 포 함한다. 이 예에서, 제1 가속기 회로부 및 제2 가속기 회로부는 버스에 의해 휘발성 메모리 , 비휘발성 메모리 등과 같은 프로세서 플랫폼의 상이한 하드웨어와 통신한다. 도 15는 도 14의 프로세서 회로부의 예시적인 구현의 블록도이다. 이 예에서, 도 14의 프로세서 회로부 는 범용 마이크로프로세서에 의해 구현된다. 범용 마이크로프로세서 회로부는 도 11-13의 흐름도들의 기계 판독가능 명령어들의 일부 또는 전부를 실행하여, 도 1의 제1 가속기 회로부, 제2 가속기 회로부, 및/또는 디버그 회로부를 논리 회로들로서 효과적으로 인스턴스화하여, 그러한 기계 판독가 능 명령어들에 대응하는 동작들을 수행한다. 예를 들어, 마이크로프로세서는 CPU, DSP, GPU, XPU 등과 같은 멀티-코어 하드웨어 회로부를 구현할 수 있다. 이는 임의의 수의 예시적인 코어(예를 들어, 1개의 코어)를 포함할 수 있지만, 이 예의 마이크로프로세서는 N개의 코어를 포함하는 멀티-코어 반도체 디바이 스이다. 마이크로프로세서의 코어들은 독립적으로 동작하거나, 협력하여 기계 판독가능 명령어들 을 실행할 수 있다. 예를 들어, 펌웨어 프로그램, 임베디드 소프트웨어 프로그램 또는 소프트웨어 프로그램에 대응하는 기계 코드는 코어들 중 하나에 의해 실행되거나, 코어들 중 다수의 코어에 의해 동일 또 는 상이한 시간들에 실행될 수 있다. 일부 예들에서, 펌웨어 프로그램, 임베디드 소프트웨어 프로그램, 또는 소프트웨어 프로그램에 대응하는 기계 코드는 스레드들로 분할되고, 코어들 중 둘 이상에 의해 병렬로 실 행된다. 소프트웨어 프로그램은 도 11-13의 흐름도들에 의해 표현된 기계 판독가능 명령어들 및/또는 동작들의 일부 또는 전부에 대응할 수 있다. 코어들은 제1 예시적인 버스에 의해 통신할 수 있다. 일부 예들에서, 제1 버스는 코어들 중 하나의 코어(들)와 연관된 통신을 실행하기 위해 통신 버스를 구현할 수 있다. 예를 들어, 제1 버스 는 I2C(Inter-Integrated Circuit) 버스, SPI(Serial Peripheral Interface) 버스, PCI 버스, 또는 PCIe 버스 중 적어도 하나를 구현할 수 있다. 추가적으로 또는 대안적으로, 제1 버스는 임의의 다른 유 형의 컴퓨팅 또는 전기 버스를 구현할 수 있다. 코어들은 예시적인 인터페이스 회로부에 의해 하 나 이상의 외부 디바이스로부터 데이터, 명령어들 및/또는 신호들을 획득할 수 있다. 코어들은 인터페이 스 회로부에 의해 하나 이상의 외부 디바이스에 데이터, 명령어들, 및/또는 신호들을 출력할 수 있다. 이 예의 코어들이 예시적인 로컬 메모리(예를 들어, L1 데이터 캐시 및 L1 명령어 캐시로 분할될 수 있는 레벨 1(L1) 캐시)를 포함하지만, 마이크로프로세서는 또한 데이터 및/또는 명령어들에 대한 고속 액세스를 위해 코어들(예를 들어, 레벨 2(L2) 캐시))에 의해 공유될 수 있는 예시적인 공유 메모리를 포 함한다. 데이터 및/또는 명령어들은 공유 메모리에 기입하고/하거나 그로부터 판독함으로써 전송(예를 들어, 공유)될 수 있다. 코어들 각각의 로컬 메모리, 및 공유 메모리는 다수의 레벨들의 캐 시 메모리 및 메인 메모리(예를 들어, 도 14의 메인 메모리(1414, 1416))를 포함하는 저장 디바이스들의 계층구 조의 일부일 수 있다. 통상적으로 계층구조에서 더 높은 메모리 레벨들은 더 낮은 메모리 레벨들보다 더 낮은 액세스 시간을 보이고, 더 적은 저장 용량을 갖는다. 캐시 계층구조의 다양한 레벨들에서의 변경들은 캐시 일 관성 정책에 의해 관리(예를 들어, 조율)된다. 각각의 코어는 CPU, DSP, GPU 등, 또는 임의의 다른 유형의 하드웨어 회로부로서 지칭될 수 있다. 각각 의 코어는 제어 유닛 회로부, 산술 및 논리(AL) 회로부(때때로 ALU로 지칭됨), 복수의 레지 스터, L1 캐시 및 제2 예시적인 버스를 포함한다. 다른 구조들이 존재할 수 있다. 예를 들 어, 각각의 코어는 벡터 유닛 회로부, SIMD(single instruction multiple data) 유닛 회로부, LSU(load/store unit) 회로부, 분기/점프 유닛 회로부, FPU(floating-point unit) 회로부 등을 포함할 수 있다. 제어 유닛 회로부는 대응하는 코어 내에서 데이터 이동을 제어(예를 들어, 조율)하도록 구 조화된 반도체 기반 회로들을 포함한다. AL 회로부는 대응하는 코어 내의 데이터에 대해 하나 이 상의 수학 및/또는 논리 연산을 수행하도록 구조화된 반도체 기반 회로들을 포함한다. 일부 예들의 AL 회로부 는 정수 기반 연산들을 수행한다. 다른 예들에서, AL 회로부는 또한 부동 소수점 연산들을 수행한 다. 또 다른 예들에서, AL 회로부는 정수 기반 연산들을 수행하는 제1 AL 회로부 및 부동 소수점 연산들 을 수행하는 제2 AL 회로부를 포함할 수 있다. 일부 예들에서, AL 회로부는 ALU(Arithmetic Logic Unit)로 지칭될 수 있다. 레지스터들은 대응하는 코어의 AL 회로부에 의해 수행된 연산들 중 하나 이상의 연산의 결과들과 같은 데이터 및/또는 명령어들을 저장하기 위한 반도체 기반 구조들이다. 예 를 들어, 레지스터들은 벡터 레지스터(들), SIMD 레지스터(들), 범용 레지스터(들), 플래그 레지스터(들), 세그먼트 레지스터(들), 기계 특정 레지스터(들), 명령어 포인터 레지스터(들), 제어 레지스터(들), 디버 그 레지스터(들), 메모리 관리 레지스터(들), 기계 체크 레지스터(들) 등을 포함할 수 있다. 레지스터들(151 8)은 도 15에 도시된 바와 같이 뱅크에 배열될 수 있다. 대안적으로, 레지스터들은 액세스 시간을 단축 하기 위해 코어 전체에 분산되는 것을 포함하는 임의의 다른 배열, 포맷 또는 구조로 조직화될 수 있다. 제2 버스는 I2C 버스, SPI 버스, PCI 버스 또는 PCIe 버스 중 적어도 하나를 구현할 수 있다. 각각의 코어 및/또는 보다 일반적으로, 마이크로프로세서는 도시되고 위에서 설명된 것들에 대한 추가적인 및/또는 대안적인 구조들을 포함할 수 있다. 예를 들어, 하나 이상의 클록 회로, 하나 이상의 전원, 하나 이상의 전력 게이트, 하나 이상의 캐시 홈 에이전트(CHA), 하나 이상의 수렴/공통 메시 스톱(CMS), 하나 이상의 시프터(예를 들어, 배럴 시프터(들)) 및/또는 다른 회로부가 존재할 수 있다. 마이크로프로세서 는 하나 이상의 패키지에 포함된 하나 이상의 집적 회로(IC)에 전술한 구조들을 구현하기 위해 상호 접속된 많 은 트랜지스터를 포함하도록 제작된 반도체 디바이스이다. 프로세서 회로부는 하나 이상의 가속기를 포함하고/ 하거나 그와 협력할 수 있다. 일부 예들에서, 가속기들은 범용 프로세서에 의해 수행될 수 있는 것보다 더 빠 르게 그리고/또는 효율적으로 특정 작업들을 수행하기 위해 논리 회로부에 의해 구현된다. 가속기들의 예들은 본 명세서에서 설명된 것과 같은 ASIC들 및 FPGA들을 포함한다. GPU 또는 다른 프로그래머블 디바이스도 가속 기일 수 있다. 가속기들은 프로세서 회로부와 동일한 칩 패키지에서 그리고/또는 프로세서 회로부와 별개인 하 나 이상의 패키지에서 프로세서 회로부에 탑재될 수 있다. 도 16은 도 14의 프로세서 회로부의 다른 예시적인 구현의 블록도이다. 이 예에서, 프로세서 회로부 는 FPGA 회로부에 의해 구현된다. FPGA 회로부는 예를 들어, 대응하는 기계 판독가능 명령 어들을 실행하는 도 15의 예시적인 마이크로프로세서에 의해 달리 수행될 수 있는 연산들을 수행하기 위 해 사용될 수 있다. 그러나, 일단 구성되면, FPGA 회로부는 하드웨어에서 기계 판독가능 명령어들을 인 스턴스화하고, 따라서, 종종 대응하는 소프트웨어를 실행하는 범용 마이크로프로세서에 의해 수행될 수 있는 것 보다 더 빠르게 연산들을 실행할 수 있다. 보다 구체적으로, 전술한 도 15의 마이크로프로세서(도 11-13의 흐름도들에 의해 표현된 기계 판독가능 명령어들의 일부 또는 전부를 실행하도록 프로그래밍될 수 있지만, 상호접속들 및 논리 회로부가 일단 제조되면 고정되는 범용 디바이스임)와는 대조적으로, 도 16의 예의 FPGA 회로부는 예를 들어, 도 11-13의 흐름도 들에 의해 표현된 기계 판독가능 명령어들의 일부 또는 전부를 인스턴스화하기 위해 제조 후에 상이한 방식들로 구성 및/또는 상호 접속될 수 있는 상호접속들 및 논리 회로부를 포함한다. 특히, FPGA 회로부는 논리 게이트들, 상호 접속들 및 스위치들의 어레이로 간주될 수 있다. 스위치들은 (FPGA 회로부가 다시 프로 그래밍되지 않는 한, 그리고 그때까지) 논리 게이트들이 상호접속들에 의해 상호접속되는 방법을 변경하여, 하 나 이상의 전용 논리 회로를 효과적으로 형성하도록 프로그래밍될 수 있다. 구성된 논리 회로들은 논리 게이트 들이 입력 회로부에 의해 수신된 데이터에 대해 상이한 연산들을 수행하기 위해 상이한 방식들로 협력할 수 있 게 한다. 이러한 동작들은 도 11-13의 흐름도들에 의해 표현된 소프트웨어의 일부 또는 전부에 대응할 수 있다. 따라서, FPGA 회로부는 도 11-13의 흐름도들의 기계 판독가능 명령어들의 일부 또는 전부를 ASIC 과 유사한 전용 방식으로 그러한 소프트웨어 명령어들에 대응하는 연산들을 수행하기 위한 전용 논리 회로들로 서 효과적으로 인스턴스화하도록 구조화될 수 있다. 따라서, FPGA 회로부는 도 11-13의 기계 판독 가능 명령어들 중 일부 또는 전부에 대응하는 연산들을 범용 마이크로프로세서가 동일한 것을 실행할 수 있는 것보다 더 빠르게 수행할 수 있다. 도 16의 예에서, FPGA 회로부는 Verilog와 같은 하드웨어 기술 언어(HDL)에 의해 최종 사용자에 의해 프 로그래밍(및/또는 한 번 이상 다시 프로그래밍)되도록 구조화된다. 도 16의 FPGA 회로부는 예시적인 구 성 회로부 및/또는 외부 하드웨어(예를 들어, 외부 하드웨어 회로부)로부터 데이터를 획득하고/하 거나 그것에 데이터를 출력하기 위한 예시적인 입력/출력(I/O) 회로부를 포함한다. 예를 들어, 구성 회 로부는 FPGA 회로부 또는 그 부분(들)을 구성하기 위한 기계 판독가능 명령어들을 획득할 수 있는 인터페이스 회로부를 구현할 수 있다. 일부 이러한 예들에서, 구성 회로부는 사용자, 기계(예컨대, 명령 어들을 생성하기 위해 인공 지능/기계 학습(AI/ML) 모델을 구현할 수 있는 하드웨어 회로부(예를 들어, 프로그 래밍된 또는 전용 회로부)) 등으로부터 기계 판독가능 명령어들을 획득할 수 있다. 일부 예들에서, 외부 하드 웨어 회로부는 도 15의 마이크로프로세서를 구현할 수 있다. FPGA 회로부는 또한 예시적인 논리 게이트 회로부, 복수의 예시적인 구성가능 상호접속 및 예시적인 저장 회로부의 어레이 를 포함한다. 논리 게이트 회로부 및 상호접속들은 도 11-13의 기계 판독가능 명령어들 중 적어도 일부에 대응할 수 있는 하나 이상의 연산들, 및/또는 다른 원하는 연산들을 인스턴스화하도록 구성가능하다.도 16에 도시된 논리 게이트 회로부는 그룹들 또는 블록들로 제조된다. 각각의 블록은 논리 회로들로 구 성될 수 있는 반도체 기반 전기 구조들을 포함한다. 일부 예들에서, 전기 구조들은 논리 회로들에 대한 기본 빌딩 블록들을 제공하는 논리 게이트들(예를 들어, 논리곱 게이트들(And gates), 논리합 게이트들(Or gates), 배타적 논리합 게이트들(Nor gates) 등)을 포함한다. 전기적으로 제어가능한 스위치들(예를 들어, 트랜지스터 들)은 논리 게이트 회로부 각각 내에 존재하여, 전기 구조들 및/또는 논리 게이트들의 구성이 원하는 연 산들을 수행하기 위한 회로들을 형성할 수 있게 한다. 논리 게이트 회로부는 탐색표(LUT)들, 레지스터들 (예를 들어, 플립플롭들 또는 래치들), 멀티플렉서들 등과 같은 다른 전기 구조들을 포함할 수 있다. 예시된 예의 상호접속들은 원하는 논리 회로들을 프로그래밍하기 위해 논리 게이트 회로부의 하나 이상 사이의 하나 이상의 접속을 활성화 또는 비활성화하기 위한 (예를 들어, HDL 명령어 언어를 사용하는) 프 로그래밍에 의해 상태가 변경될 수 있는 전기적으로 제어가능한 스위치들(예를 들어, 트랜지스터들)을 포함할 수 있는 도전성 경로들, 트레이스들, 비아들 등이다. 예시된 예의 저장 회로부는 대응하는 논리 게이트들에 의해 수행된 연산들 중 하나 이상의 연산의 결과 (들)를 저장하도록 구조화된다. 저장 회로부는 레지스터들 등에 의해 구현될 수 있다. 예시된 예에서, 저장 회로부는 액세스를 용이하게 하고 실행 속도를 증가시키기 위해 논리 게이트 회로부 사이에 분산된다. 도 16의 예시적인 FPGA 회로부는 또한 예시적인 전용 연산 회로부를 포함한다. 이 예에서, 전용 연산 회로부는 일반적으로 사용되는 함수들을 구현하기 위해 호출될 수 있는 특수 목적 회로부를 포함하여, 현장에서 이러한 함수들을 프로그래밍할 필요성을 없앤다. 이러한 특수 목적 회로부의 예들은 메모리(예를 들어, DRAM) 컨트롤러 회로부, PCIe 컨트롤러 회로부, 클록 회로부, 송수신기 회로부, 메모리, 및 승산기-누산기 회로부를 포함한다. 다른 유형들의 특수 목적 회로부가 존재할 수 있다. 일부 예들에서, FPGA 회로부는 또한 예시적인 CPU 및/또는 예시적인 DSP와 같은 예시적인 범용 프로그래머블 회로 부를 포함할 수 있다. 다른 연산들을 수행하도록 프로그래밍될 수 있는 GPU, XPU 등과 같은 다른 범용 프로그래머블 회로부가 추가적으로 또는 대안적으로 존재할 수 있다. 도 15 및 도 16은 도 14의 프로세서 회로부의 두 가지 예시적인 구현을 예시하지만, 많은 다른 접근법들 이 고려된다. 예를 들어, 전술한 바와 같이, 현대의 FPGA 회로부는 도 16의 예시적인 CPU 중 하나 이상 과 같은 온보드 CPU를 포함할 수 있다. 따라서, 도 14의 프로세서 회로부는 도 15의 예시적인 마이크로 프로세서와 도 16의 예시적인 FPGA 회로부를 조합하여 추가적으로 구현될 수 있다. 일부 이러한 하이브리드 예들에서, 도 11-13의 흐름도들에 의해 표현된 기계 판독가능 명령어들의 제1 부분은 도 15의 코어 들 중 하나 이상에 의해 실행될 수 있고, 도 11-13의 흐름도들에 의해 표현된 기계 판독가능 명령어들의 제2 부분은 도 16의 FPGA 회로부에 의해 실행될 수 있다. 일부 예들에서, 도 14의 프로세서 회로부는 하나 이상의 패키지 내에 있을 수 있다. 예를 들어, 도 15의 프로세서 회로부 및/또는 도 16의 FPGA 회로부는 하나 이상의 패키지 내에 있을 수 있다. 일부 예 들에서, XPU는 하나 이상의 패키지 내에 있을 수 있는 도 14의 프로세서 회로부에 의해 구현될 수 있다. 예를 들어, XPU는 하나의 패키지 내의 CPU, 다른 패키지 내의 DSP, 또 다른 패키지 내의 GPU, 및 또 다른 패키 지 내의 FPGA를 포함할 수 있다. 도 17은 도 14의 예시적인 기계 판독가능 명령어들과 같은 소프트웨어를 제3자들에 의해 소유 및/또는 운 영되는 하드웨어 디바이스들에 배포하기 위한 예시적인 소프트웨어 배포 플랫폼을 예시하는 블록도이다. 예시적인 소프트웨어 배포 플랫폼은 소프트웨어를 저장하고 다른 컴퓨팅 디바이스들에 전송할 수 있는 임 의의 컴퓨터 서버, 데이터 설비, 클라우드 서비스 등에 의해 구현될 수 있다. 제3자들의 예들은 (예를 들어, 라이선스, 판매 및/또는 사용을 위해) 최종 사용자들 및/또는 소비자들, (예를 들어, 판매, 재판매, 라이선스 및/또는 서브-라이선스를 위해) 소매업자들 및/또는 (예를 들어, 예를 들어 소매업자들 및/또는 직접 구매 고객 들과 같은 다른 최종 사용자들에게 배포될 제품들에 포함시키기 위해) 주문자 상표 부착 생산업체(OEM)들과 연 관된 클라이언트 디바이스들을 포함할 수 있다. 일부 예들에서, 제3자들은 소프트웨어 배포 플랫폼을 소 유 및/또는 운영하는 엔티티의 고객들일 수 있다. 예를 들어, 소프트웨어 배포 플랫폼을 소유 및/또는 운영하는 엔티티는 도 14의 예시적인 기계 판독가능 명령어들과 같은 소프트웨어의 개발자, 판매자 및/또 는 라이센서일 수 있다. 제3자들은 사용 및/또는 재판매 및/또는 서브-라이센싱을 위해 소프트웨어를 구매 및/ 또는 라이센싱하는 소비자들, 사용자들, 소매업자들, OEM들 등일 수 있다. 예시된 예에서, 소프트웨어 배포 플 랫폼은 하나 이상의 서버 및 하나 이상의 저장 디바이스를 포함한다. 저장 디바이스들은 전술한 바와 같은 도 11-13의 예시적인 기계 판독가능 명령어들 및/또는 동작들(1100, 1200, 1300)에 대응할 수 있는 기계 판 독가능 명령어들을 저장한다. 예시적인 소프트웨어 배포 플랫폼의 하나 이상의 서버는 네트워크 와 통신하며, 네트워크는 인터넷 및/또는 전술한 예시적인 네트워크들(132, 1426) 중 임의의 것 중 임의의 하나 이상에 대응할 수 있다. 일부 예들에서, 하나 이상의 서버는 상업적 거래의 일부로서 요청 당사자 에게 소프트웨어를 전송하기 위한 요청들에 응답한다. 소프트웨어의 전달, 판매 및/또는 라이센스에 대한 결제 는 소프트웨어 배포 플랫폼의 하나 이상의 서버 및/또는 제3자 결제 엔티티에 의해 핸들링될 수 있다. 서버들 은 구매자들 및/또는 라이센서들이 소프트웨어 배포 플랫폼으로부터 기계 판독가능 명령어들을 다 운로드할 수 있게 한다. 예를 들어, 도 11-13의 예시적인 기계 판독가능 명령어들 및/또는 동작(1100, 1200, 1300)에 대응할 수 있는 소프트웨어는 도 1의 제1 가속기 회로부, 제2 가속기 회로부, 디버그 회로부 및/또는 디버그 애플리케이션을 구현하기 위해 기계 판독가능 명령어들을 실행하는 예시적인 프로세서 플랫폼에 다운로드될 수 있다. 일부 예들에서, 소프트웨어 배포 플랫폼의 하나 이상의 서버는 개선들, 패치들, 업데이트들 등이 최종 사용자 디바이스들에서의 소프트웨어에 배포되고 적용되는 것을 보장하기 위해 소프트웨어(예를 들어, 도 14의 예시적인 기계 판독가능 명령어들)에 대한 업데이트들을 주기적으로 제공, 전송 및/또는 강제한다. 전술한 내용으로부터, 가속기 하드웨어를 디버깅하는 예시적인 시스템들, 방법들, 장치들 및 제조 물품들이 개 시되었음을 알 것이다. 개시된 시스템들, 방법들, 장치들, 및 제조 물품들은 디버깅하기 위한 전용 디버그 회 로부를 가짐으로써 디버깅 동안에 통합 소프트웨어 접근법을 허용한다. 예를 들어, 임의의 가속기 코어가 주어 진 시간에 중단될 수 있고, 본 명세서에 개시된 중단점들(예를 들어, 중단점 명령어들)을 갖는 기존 하드웨어를 사용을 통해 증분적으로 실행(예를 들어, 단일-스테핑)될 수 있다. 개시된 시스템들, 방법들, 장치들, 및 제조 물품들은 임의의 실행 바이너리(예컨대, 하드웨어 가속기 상에 디스패치되는 컴파일러의 출력)가 사용되고 디버 깅되는 것을 허용할 수 있다. 개시된 시스템들, 방법들, 장치들, 및 제조 물품들은 예상 거동(예를 들어, 예상 값들, 예상 어드레스들 등)을 벗어나는 트랜잭션(들)을 검출하기 위해, 코어의 실행을 중단시켜, 판독 및 디버 그 트랜잭션들을 갖는 코어로 작업부하를 증분적으로 실행하는 것을 달성한다. 개시된 시스템들, 방법들, 장치 들, 및 제조 물품들은 하드웨어 가속기 파이프라인 전체에 걸쳐 가시성을 개선시키기 위해 서로를 잘못 덮어쓰 는 메모리 기입 동작들을 검출할 수 있게 하는 제어된 기술로 디버그 트랜잭션들의 출력을 달성한다. 개시된 시스템들, 방법들, 장치들 및 제조 물품들은 생성된 데이터 스트림들에서의 하나의 사전 프로그래밍된 데이터의 자동 검출을 구현하여, 예기치 않은 데이터 피스 발생이 어느 실행 시점에 일어나는지, 또한 어떤 코 어에 대한 어떤 작업부하가 예기치 않은 발생을 담당하는지를 식별한다. 개시된 시스템들, 방법들, 장치들 및 제조 물품들은 예기치 않은 동작들의 개선된 식별을 달성하기 위해 특정 메모리 트랜잭션 어드레스들 또는 어드 레스 범위들에 중단점들을 설정하는 능력을 구현한다. 개시된 시스템들, 방법들, 장치들, 및 제조 물품들은 잘못된 가속기 구성들의 식별 및 정정에 응답하여 하드웨 어 가속기들의 실행을 개선 및/또는 달리 최적화함으로써 컴퓨팅 디바이스 사용의 효율성을 개선한다. 따라서, 개시된 시스템들, 방법들, 장치들, 및 제조 물품들은 컴퓨터 또는 다른 전자 및/또는 기계 디바이스와 같은 기 계의 동작에서의 하나 이상의 개선(들)과 연관된다. 가속기 하드웨어를 디버깅하기 위한 예시적인 방법들, 장치들, 시스템들, 및 제조 물품들이 본 명세서에 개시되 어 있다. 추가의 예들 및 이들의 조합들은 다음을 포함한다: 예 1은 하드웨어 가속기를 디버깅하기 위한 장치를 포함하고, 장치는 코어 입력 및 코어 출력을 갖는 코어 - 코 어는 데이터 입력에 기초하여 데이터 출력을 생성하기 위한 실행가능 코드를 실행하고, 실행가능 코드는 기계 학습 모델에 기초함 -; 및 코어 입력 또는 코어 출력 중 적어도 하나에 결합된 디버그 회로부를 포함하고, 디버 그 회로부는 코어 출력에 결합된 인터페이스 입력 또는 코어 입력에 결합된 인터페이스 출력 중 적어도 하나를 갖는 인터페이스 회로부 - 인터페이스 회로부는 데이터 입력 또는 데이터 출력 중 적어도 하나를 수신함 -; 멀 티플렉서 입력 및 멀티플렉서 출력을 갖는 멀티플렉서 회로부 - 멀티플렉서 입력은 인터페이스 출력에 결합됨 -; 및 멀티플렉서 출력에 결합된 시프트 레지스터 입력을 갖는 시프트 레지스터를 포함하고, 시프트 레지스터는 실행가능 코드의 실행과 연관된 중단점의 트리거에 응답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 출력한다. 예 2는 예 1의 장치를 포함하고, 인터페이스 입력은 메모리에 결합되고, 인터페이스 출력은 코어 입력에 결합되 며, 인터페이스 회로부는 메모리로부터 데이터 입력을 수신하고; 중단점이 트리거되지 않는 것에 응답하여 데이 터 입력을 코어 입력에 제공하며; 코어는 코어 출력으로부터의 데이터 출력을 메모리에 제공한다.예 3은 예 1의 장치를 포함하고, 코어 입력은 메모리에 결합되고, 인터페이스 입력은 코어 출력에 결합되고, 인 터페이스 출력은 메모리에 결합되며, 코어는 메모리로부터 데이터 입력을 수신하고; 코어 출력으로부터의 데이 터 출력을 인터페이스 입력에 제공하며; 인터페이스 회로부는 중단점이 트리거되지 않는 것에 응답하여 데이터 출력을 메모리에 제공한다. 예 4는 예 1의 장치를 포함하고, 디버그 회로부는 제1 디버그 회로부이고, 인터페이스 회로부는 제1 인터페이스 회로부이고, 인터페이스 입력은 제1 인터페이스 입력이고, 인터페이스 출력은 제1 인터페이스 출력이고, 제1 인 터페이스 입력은 메모리에 결합되고, 제1 인터페이스 회로부는 메모리로부터 데이터 입력을 수신하고, 제1 인터 페이스 회로부는 중단점이 트리거되지 않는 것에 응답하여 코어에 데이터 입력을 제공하며, 장치는 제2 인터페 이스 입력 및 제2 인터페이스 출력을 갖는 제2 인터페이스 회로부를 포함하는 제2 디버그 회로부를 더 포함하고, 제2 인터페이스 입력은 코어 출력에 결합되고, 제2 인터페이스 출력은 메모리에 결합되며, 제2 디버 그 회로부는 코어로부터 데이터 출력을 수신하는 것; 중단점의 트리거에 응답하여 데이터 입력 또는 데이터 출 력 중 적어도 하나를 출력하는 것; 또는 중단점이 트리거되지 않는 것에 응답하여 데이터 출력을 메모리로 출력 하는 것 중 적어도 하나를 한다. 예 5는 예 1의 장치를 포함하고, 디버그 회로부는 코어에 포함되고, 하드웨어 가속기는 신경망 가속기이고, 기 계 학습 모델은 신경망이며, 코어는 데이터 입력에 기초하여 데이터 출력을 생성하기 위한 실행가능 코드를 실 행하고, 실행가능 코드는 중단점을 포함하고, 실행가능 코드는 신경망 또는 중단점 중 적어도 하나에 기초하며; 디버그 회로부는 중단점을 트리거하여 실행가능 코드의 실행을 중단시키고; 데이터 입력, 데이터 출력 또는 중 단점 중 적어도 하나를 출력한다. 예 6은 예 1의 장치를 포함하고, 데이터 입력 또는 데이터 출력 중 적어도 하나는 제1 값을 포함하고, 디버그 회로부는 코어의 구성 레지스터로부터 중단점에 대응하는 제2 값을 획득하기 위한 제어 회로부; 제어 회로부에 결합된 중단점 레지스터 - 중단점 레지스터는 제2 값을 저장함 -; 제1 비교기 입력 및 제2 비교기 입력을 갖는 비교기 회로부를 포함하며, 제1 비교기 입력은 인터페이스 출력에 결합되고, 제2 비교기 입력은 중단점 레지스 터 및 제어 회로부에 결합되고, 비교기 회로부는 제1 값과 제2 값을 비교하며; 제어 회로부는 인터페이스 회로 부에게 비교에 기초하는 제1 값과 제2 값의 매치에 응답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 멀티플렉서 회로부에 제공하도록 명령하고, 중단점의 트리거링은 매치에 응답하고, 제어 회로부는 인터페이스 회로부에게 비교기 회로부로부터 매치의 표시를 수신하도록 명령한다. 예 7은 예 1의 장치를 포함하고, 인터페이스 회로부는 제1 인터페이스 회로부이고, 인터페이스 입력은 제1 인터 페이스 입력이고, 인터페이스 출력은 제1 인터페이스 출력이고, 코어는 제1 스레드 및 제2 스레드를 포함하고, 제1 스레드는 제1 인터페이스 입력에 결합되며, 장치는 제2 인터페이스 입력 및 제2 인터페이스 출력을 갖는 제 2 인터페이스 회로부 - 제2 인터페이스 입력은 제2 스레드에 결합됨 -; 및 멀티플렉서 회로부의 선택 입력에 결 합된 카운터 출력을 갖는 카운터 회로부를 더 포함하고, 카운터 회로부는 제1 값을 출력하여 멀티플렉서 회로부 에게 제1 인터페이스 회로부의 출력을 선택하도록 명령하고; 제2 값을 출력하여 멀티플렉서 회로부에게 제2 인 터페이스 회로부의 출력을 선택하도록 명령한다. 예 8은 하드웨어 가속기를 디버깅하기 위한 장치를 포함하고, 장치는 데이터 입력에 기초하여 데이터 출력을 생 성하기 위한 실행가능 코드를 실행하기 위한 수단 - 실행가능 코드는 기계 학습 모델에 기초함 -; 및 하드웨어 가속기를 디버깅하기 위한 수단을 포함하고, 디버깅하기 위한 수단은 실행하기 위한 수단에 결합되고, 디버깅하 기 위한 수단은 데이터 입력 또는 데이터 출력 중 적어도 하나를 수신하기 위한 수단 - 수신하기 위한 수단은 실행하기 위한 수단의 출력에 결합된 입력 또는 실행하기 위한 수단의 입력에 결합된 출력 중 적어도 하나를 가 짐 -; 수신하기 위한 수단을 선택하기 위한 수단 - 선택하기 위한 수단은 수신하기 위한 수단의 출력에 결합된 입력을 가짐 -; 및 실행가능 코드의 실행과 연관된 중단점의 트리거에 응답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 출력하기 위한 수단을 포함하고, 출력하기 위한 수단은 선택하기 위한 수단의 출력에 결합된 입력을 갖는다. 예 9는 예 8의 장치를 포함하고, 수신하기 위한 수단의 입력은 저장하기 위한 수단에 결합되고, 수신하기 위한 수단의 출력은 실행하기 위한 수단의 입력에 결합되며, 수신하기 위한 수단은 저장하기 위한 수단으로부터 데이 터 입력을 수신하고; 중단점이 트리거되지 않는 것에 응답하여 데이터 입력을 실행하기 위한 수단의 입력에 제 공하며; 실행하기 위한 수단은 실행하기 위한 수단의 출력으로부터의 데이터 출력을 저장하기 위한 수단에 제공 한다. 예 10은 예 8의 장치를 포함하고, 실행하기 위한 수단의 입력은 저장하기 위한 수단에 결합되고, 수신하기 위한 수단의 입력은 실행하기 위한 수단의 출력에 결합되고, 수신하기 위한 수단의 출력은 저장하기 위한 수단에 결 합되며, 실행하기 위한 수단은 저장하기 위한 수단으로부터 데이터 입력을 수신하고; 실행하기 위한 수단의 출 력으로부터의 데이터 출력을 수신하기 위한 수단의 입력에 제공하며; 수신하기 위한 수단은 중단점이 트리거되 지 않는 것에 응답하여 데이터 출력을 저장하기 위한 수단에 제공한다. 예 11은 예 8의 장치를 포함하고, 디버깅하기 위한 수단은 디버깅하기 위한 제1 수단이고, 수신하기 위한 수단 은 수신하기 위한 제1 수단이고, 수신하기 위한 제1 수단의 입력은 저장하기 위한 수단에 결합되고, 수신하기 위한 제1 수단은 저장하기 위한 수단으로부터 데이터 입력을 수신하고, 수신하기 위한 제1 수단은 중단점이 트 리거되지 않는 것에 응답하여 실행하기 위한 수단에 데이터 입력을 제공하며, 장치는 하드웨어 가속기를 디버깅 하기 위한 제2 수단을 더 포함하고, 디버깅하기 위한 제2 수단은 수신하기 위한 제2 수단을 포함하고, 수신하기 위한 제2 수단의 입력은 실행하기 위한 수단의 출력에 결합되고, 수신하기 위한 제2 수단의 출력은 저장하기 위 한 수단에 결합되며, 디버깅하기 위한 제2 수단은 실행하기 위한 수단으로부터 데이터 출력을 수신하는 것; 중 단점의 트리거에 응답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 출력하는 것; 또는 중단점이 트리거 되지 않는 것에 응답하여 데이터 출력을 저장하기 위한 수단으로 출력하는 것 중 적어도 하나를 한다. 예 12는 예 8의 장치를 포함하고, 디버깅하기 위한 수단은 실행하기 위한 수단에 포함되고, 하드웨어 가속기는 신경망 가속기이고, 기계 학습 모델은 신경망이며, 실행하기 위한 수단은 데이터 입력에 기초하여 데이터 출력 을 생성하기 위한 실행가능 코드를 실행하고, 실행가능 코드는 중단점을 포함하고, 실행가능 코드는 신경망 또 는 중단점 중 적어도 하나에 기초하며; 디버깅하기 위한 수단은 중단점을 트리거하여 실행가능 코드의 실행을 중단시키고; 데이터 입력, 데이터 출력 또는 중단점 중 적어도 하나를 출력한다. 예 13은 예 8의 장치를 포함하고, 데이터 입력 또는 데이터 출력 중 적어도 하나는 제1 값을 포함하고, 디버깅 하기 위한 수단은 디버깅하기 위한 수단을 제어하기 위한 수단 - 제어하기 위한 수단은 저장하기 위한 제1 수단 으로부터 중단점에 대응하는 제2 값을 획득함 -; 제2 값을 저장하기 위한 제2 수단 - 저장하기 위한 제2 수단은 제어하기 위한 수단에 결합됨 -; 제1 값과 제2 값을 비교하기 위한 비교하기 위한 수단을 포함하고, 비교하기 위한 수단의 제1 입력은 수신하기 위한 수단의 출력에 결합되고, 비교하기 위한 수단의 제2 입력은 저장하기 위 한 제2 수단 및 제어하기 위한 수단에 결합되며; 제어하기 위한 수단은 비교에 기초하는 제1 값과 제2 값의 매 치에 응답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 선택하기 위한 수단에 제공하도록 수신하기 위 한 수단을 제어하고, 중단점의 트리거링은 매치에 응답하고, 제어하기 위한 수단은 비교하기 위한 수단으로부터 매치의 표시를 수신하도록 수신하기 위한 수단을 제어한다. 예 14는 예 8의 장치를 포함하고, 데이터 입력은 제1 데이터 입력이고, 데이터 출력은 제1 데이터 출력이고, 수 신하기 위한 수단은 수신하기 위한 제1 수단이고, 실행하기 위한 수단은 실행하기 위한 제1 수단이며, 장치는 제2 데이터 입력 또는 제2 데이터 출력 중 적어도 하나를 수신하기 위한 제2 수단 - 수신하기 위한 제2 수단의 입력은 실행하기 위한 제2 수단에 결합됨 -; 및 카운터를 증분시키기 위한 수단을 더 포함하고, 증분시키기 위 한 수단의 출력은 선택하기 위한 수단의 선택 입력에 결합되며, 증분시키기 위한 수단은 카운터의 제1 값을 출 력하여 선택하기 위한 수단에게 수신하기 위한 제1 수단의 출력을 선택하도록 명령하고; 카운터의 제2 값을 출 력하여 선택하기 위한 수단에게 수신하기 위한 제2 수단의 출력을 선택하도록 명령한다. 예 15는 하드웨어 가속기를 디버깅하기 위한 장치를 포함하고, 장치는 적어도 하나의 메모리; 장치 내의 명령어 들; 및 프로세서 회로부를 포함하고, 프로세서 회로부는 명령어들을 실행하는 것 또는 인스턴스화하는 것 중 적 어도 하나를 하여, 기계 학습 모델과 연관된 중단점을 생성하고; 기계 학습 모델 또는 중단점 중 적어도 하나에 기초하여 실행가능 코드를 컴파일하고 - 실행가능 코드는 데이터 입력에 기초하여 데이터 출력을 생성하기 위해 프로세서 회로부에 의해 실행됨 -; 실행가능 코드의 실행에 응답하여 중단점을 트리거하여 실행가능 코드의 실 행을 중단시키고; 프로세서 회로부에 포함된 디버그 회로부로 데이터 입력, 데이터 출력 또는 중단점 중 적어도 하나를 출력한다. 예 16은 예 15의 장치를 포함하고, 프로세서 회로부는 작업부하별로 트리거될 것으로 중단점을 식별하고; 작업 부하별로 호출될 실행가능 코드에 중단점을 삽입하고; 프로세서 회로부의 제1 코어에 의한 실행가능 코드의 실 행에 응답하여, 제1 코어에 의해 중단점이 트리거될 때 제1 코어에 의한 실행가능 코드의 실행을 중단시키고; 프로세서 회로부의 제2 코어에 의한 실행가능 코드의 실행에 응답하여, 제2 코어에 의해 중단점이 트리거될 때 제2 코어에 의한 실행가능 코드의 실행을 중단시킨다. 예 17은 예 15의 장치를 포함하고, 프로세서 회로부는 코어별로 트리거될 것으로 중단점을 식별하고; 프로세서 회로부의 제1 코어의 제1 구성 레지스터에 기입되고 프로세서 회로부의 제2 코어의 제2 구성 레지스터에 기입되지 않을 것으로 중단점을 식별하고; 제1 구성 레지스터에 중단점을 기입하며, 중단점의 트리거링은 제2 코어가 실행가능 코드의 실행을 계속하는 동안 제1 코어에 의한 실행가능 코드의 실행을 중단시킨다. 예 18은 예 15의 장치를 포함하고, 데이터 입력은 제1 데이터를 포함하고, 데이터 출력은 제2 데이터를 포함하 며, 프로세서 회로부는 제3 데이터에 기초하여 트리거될 것으로 중단점을 식별하고; 제3 데이터를 프로세서 회 로부의 코어의 구성 레지스터에 기입하고; 제1 데이터와 제3 데이터의 제1 비교를 실행하고 - 중단점의 트리거 링은 제1 비교에 기초하는 제1 데이터와 제3 데이터의 제1 매치에 응답함 -; 제2 데이터와 제3 데이터의 제2 비 교를 실행하며, 중단점의 트리거링은 제2 비교에 기초하는 제2 데이터와 제3 데이터의 제2 매치에 응답한다. 예 19는 예 15의 장치를 포함하고, 프로세서 회로부는 데이터 출력과 연관된 메모리 내의 제1 어드레스에 기초 하여 트리거될 것으로 중단점을 식별하고; 프로세서 회로부의 코어의 구성 레지스터에 제1 어드레스를 기입하고; 실행가능 코드를 실행하는 것에 응답하여, 데이터 출력을 기입할 메모리 내의 제2 어드레스를 식별하 고; 제1 어드레스와 제2 어드레스의 비교를 실행하며, 중단점의 트리거링은 제1 어드레스와 제2 어드레스의 매 치에 응답한다. 예 20은 예 15의 장치를 포함하고, 데이터 입력은 제1 데이터 입력이고, 프로세서 회로부는 중단점의 트리거링 에 응답하여, 실행가능 코드의 증분 동작을 실행하는 것을 나타내는 제어 신호를 획득하고 - 증분 동작은 제1 값을 판독하기 위한 판독 동작, 제2 값을 기입하기 위한 기입 동작 또는 제2 데이터 입력에 기초하여 제3 값을 결정하기 위한 계산 동작 중 적어도 하나를 포함함 -; 제1 값, 제2 값 또는 제3 값 중 적어도 하나를 출력한다. 예 21은 예 15의 장치를 포함하고, 프로세서 회로부는 중단점의 트리거링에 응답하여, 데이터 입력의 제1 값을 조정하는 것; 프로세서 회로부의 코어의 제1 레지스터의 제2 값을 조정하는 것; 또는 디버그 회로부의 제2 레지 스터의 제3 값을 조정하는 것 중 적어도 하나를 하고; 제1 값, 제2 값, 또는 제3 값 중 적어도 하나에 기초하여 실행가능 코드의 실행을 재개한다. 예 22는 명령어들을 포함하는 적어도 하나의 비일시적 컴퓨터 판독가능 매체를 포함하고, 명령어들은 실행될 때 제1 프로세서 회로부로 하여금 적어도: 기계 학습 모델과 연관된 중단점을 생성하게 하고; 기계 학습 모델 또는 중단점 중 적어도 하나에 기초하여 실행가능 코드를 컴파일하게 하고 - 실행가능 코드는 데이터 입력에 기초하 여 데이터 출력을 생성하기 위해 제1 프로세서 회로부 또는 제2 프로세서 회로부에 의해 실행됨 -; 실행가능 코 드의 실행에 응답하여, 중단점을 트리거하여 실행가능 코드의 실행을 중단시키게 하고; 제1 프로세서 회로부 또 는 제2 프로세서 회로부에 포함된 디버그 회로부로 데이터 입력, 데이터 출력 또는 중단점 중 적어도 하나를 출 력하게 한다. 예 23은 예 22의 적어도 하나의 비일시적 컴퓨터 판독가능 매체를 포함하고, 명령어들은 실행될 때 제1 프로세 서 회로부로 하여금, 작업부하별로 트리거될 것으로 중단점을 식별하게 하고; 작업부하별로 호출될 실행가능 코 드에 중단점을 삽입하게 하고; 제1 프로세서 회로부 또는 제2 프로세서 회로부의 제1 코어에 의한 실행가능 코 드의 실행에 응답하여, 제1 코어에 의해 중단점이 트리거될 때, 제1 코어에 의한 실행가능 코드의 실행을 중단 시키게 하고; 제1 프로세서 회로부 또는 제2 프로세서 회로부의 제2 코어에 의한 실행가능 코드의 실행에 응답 하여, 제2 코어에 의해 중단점이 트리거될 때, 제2 코어에 의한 실행가능 코드의 실행을 중단시키게 한다. 예 24는 예 22의 적어도 하나의 비일시적 컴퓨터 판독가능 매체를 포함하고, 명령어들은 실행될 때 제1 프로세 서 회로부로 하여금, 코어별로 트리거될 것으로 중단점을 식별하게 하고; 제1 프로세서 회로부 또는 제2 프로세 서 회로부의 제1 코어의 제1 구성 레지스터에 기입되고 제1 프로세서 회로부 또는 제2 프로세서 회로부의 제2 코어의 제2 구성 레지스터에 기입되지 않을 것으로 중단점을 식별하게 하고; 제1 구성 레지스터에 중단점을 기 입하게 하며, 중단점의 트리거링은 제2 코어가 실행가능 코드의 실행을 계속하는 동안 제1 코어에 의한 실행가 능 코드의 실행을 중단시킨다. 예 25는 예 22의 적어도 하나의 비일시적 컴퓨터 판독가능 매체를 포함하고, 데이터 입력은 제1 데이터를 포함 하고, 데이터 출력은 제2 데이터를 포함하며, 명령어들은 실행될 때 제1 프로세서 회로부로 하여금, 제3 데이터 에 기초하여 트리거될 것으로 중단점을 식별하게 하고; 제3 데이터를 제1 프로세서 회로부 또는 제2 프로세서 회로부의 코어의 구성 레지스터에 기입하게 하고; 제1 데이터와 제3 데이터의 제1 비교를 실행하게 하고 - 중단 점의 트리거링은 제1 비교에 기초하는 제1 데이터와 제3 데이터의 제1 매치에 응답함 -; 제2 데이터와 제3 데이 터의 제2 비교를 실행하게 하며, 중단점의 트리거링은 제2 비교에 기초하는 제2 데이터와 제3 데이터의 제2 매 치에 응답한다. 예 26은 예 22의 적어도 하나의 비일시적 컴퓨터 판독가능 매체를 포함하고, 명령어들은 실행될 때 제1 프로세 서 회로부로 하여금, 데이터 출력과 연관된 메모리 내의 제1 어드레스에 기초하여 트리거될 것으로 중단점을 식 별하게 하고; 제1 어드레스를 제1 프로세서 회로부 또는 제2 프로세서 회로부의 코어의 구성 레지스터에 기입하 게 하고; 실행가능 코드를 실행하는 것에 응답하여, 데이터 출력을 기입할 메모리 내의 제2 어드레스를 식별하 게 하고; 제1 어드레스와 제2 어드레스의 비교를 실행하게 하며, 중단점의 트리거링은 제1 어드레스와 제2 어드 레스의 매치에 응답한다. 예 27은 예 22의 적어도 하나의 비일시적 컴퓨터 판독가능 매체를 포함하고, 데이터 입력은 제1 데이터 입력이 고, 명령어들은 실행될 때 제1 프로세서 회로부로 하여금, 중단점의 트리거링에 응답하여, 실행가능 코드의 증 분 동작을 실행하는 것을 나타내는 제어 신호를 획득하게 하고 - 증분 동작은 제1 값을 판독하기 위한 판독 동 작, 제2 값을 기입하기 위한 기입 동작, 또는 제2 데이터 입력에 기초하여 제3 값을 결정하기 위한 계산 동작 중 적어도 하나를 포함함 -; 제1 값, 제2 값 또는 제3 값 중 적어도 하나를 출력하게 한다. 예 28은 예 22의 적어도 하나의 비일시적 컴퓨터 판독가능 매체를 포함하고, 명령어들은 실행될 때 제1 프로세 서 회로부로 하여금, 중단점의 트리거링에 응답하여, 데이터 입력의 제1 값을 조정하는 것; 제1 프로세서 회로 부 또는 제2 프로세서 회로부의 코어의 제1 레지스터의 제2 값을 조정하는 것; 또는 디버그 회로부의 제2 레지 스터의 제3 값을 조정하는 것 중 적어도 하나를 하게 하고; 제1 값, 제2 값 또는 제3 값 중 적어도 하나에 기초 하여 실행가능 코드의 실행을 재개하게 한다. 예 29는 하드웨어 가속기를 디버깅하기 위한 장치를 포함하고, 장치는 기계 학습 모델을 획득하기 위한 제1 인 터페이스 회로부; 및 프로세서 회로부를 포함하고, 프로세서 회로부는 중앙 처리 유닛, 그래픽 처리 유닛 또는 디지털 신호 프로세서 중 적어도 하나 - 중앙 처리 유닛, 그래픽 처리 유닛 또는 디지털 신호 프로세서 중 적어 도 하나는 프로세서 회로부 내의 데이터 이동을 제어하기 위한 제어 회로부, 명령어들에 대응하는 하나 이상의 제1 동작을 수행하기 위한 산술 및 논리 회로부, 및 하나 이상의 제1 동작의 결과를 저장하기 위한 하나 이상의 레지스터를 가지며, 명령어들은 장치 내에 있음 -; 필드 프로그래머블 게이트 어레이(FPGA) - FPGA는 논리 게이 트 회로부, 복수의 구성 가능한 상호접속, 및 저장 회로부를 포함하고, 논리 게이트 회로부 및 상호접속들은 하 나 이상의 제2 동작을 수행하고, 저장 회로부는 하나 이상의 제2 동작의 결과를 저장함 -; 또는 하나 이상의 제 3 동작을 수행하기 위한 논리 게이트 회로부를 포함하는 주문형 집적 회로부(ASIC) 중 하나 이상을 포함하며; 프로세서 회로부는 제1 동작들, 제2 동작들 또는 제3 동작들 중 적어도 하나를 수행하여, 데이터 입력에 기초하 여 데이터 출력을 생성하기 위한 실행가능 코드를 실행하기 위한 코어 회로부 - 실행가능 코드는 기계 학습 모 델에 기초함 -; 데이터 입력 또는 데이터 출력 중 적어도 하나를 수신하기 위한 제2 인터페이스 회로부; 제2 인 터페이스 회로부를 선택하기 위한 멀티플렉서 회로부; 및 실행가능 코드의 실행과 연관된 중단점의 트리거에 응 답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 출력하기 위한 시프트 레지스터를 인스턴스화한다. 예 30은 예 29의 장치를 포함하고, 제2 인터페이스 회로부는 메모리로부터 데이터 입력을 수신하고, 프로세서 회로부는 제1 동작들, 제2 동작들, 또는 제3 동작들 중 적어도 하나를 수행하여, 중단점이 트리거되지 않는 것 에 응답하여, 제2 인터페이스 회로부로부터 데이터 입력을 수신하고; 데이터 입력을 코어 회로부로 출력하기 위 한 버퍼를 인스턴스화한다. 예 31은 예 29의 장치를 포함하고, 제2 인터페이스 회로부는 코어 회로부로부터 데이터 출력을 수신하고, 프로 세서 회로부는 제1 동작들, 제2 동작들, 또는 제3 동작들 중 적어도 하나를 수행하여, 중단점이 트리거되지 않 는 것에 응답하여, 제2 인터페이스 회로부로부터 데이터 출력을 수신하고; 데이터 출력을 메모리로 출력하기 위 한 버퍼를 인스턴스화한다. 예 32는 예 29의 장치를 포함하고, 제2 인터페이스 회로부는 메모리로부터 데이터 입력을 수신하고, 프로세서 회로부는 제1 동작들, 제2 동작들, 또는 제3 동작들 중 적어도 하나를 수행하여, 중단점이 트리거되지 않는 것 에 응답하여, 제2 인터페이스 회로부로부터 데이터 입력을 수신하고; 데이터 입력을 코어 회로부로 출력하기 위 한 버퍼; 및 중단점의 트리거에 응답하여 데이터 입력 또는 데이터 출력 중 적어도 하나를 출력하거나; 중단점 이 트리거되지 않는 것에 응답하여 데이터 출력을 메모리로 출력하기 위한 디버그 회로부를 인스턴스화한다. 예 33은 예 32의 장치를 포함하고, 디버그 회로부는 코어 회로부에 포함된다. 예 34는 예 29의 장치를 포함하고, 데이터 입력 또는 데이터 출력 중 적어도 하나는 제1 값을 포함하고, 프로세 서 회로부는 제1 동작들, 제2 동작들 또는 제3 동작들 중 적어도 하나를 수행하여, 중단점에 대응하는 제2 값을 저장하기 위한 구성 레지스터; 및 비교기 회로부를 인스턴스화하며, 비교기 회로부는 제1 값과 제2 값을 비교하 고; 제2 인터페이스 회로부에게 비교에 기초하는 제1 값과 제2 값의 매치에 응답하여 데이터 입력 또는 데이터출력 중 적어도 하나를 멀티플렉서 회로부에 제공하도록 명령하고, 중단점의 트리거링은 매치에 응답한다. 예 35는 예 29의 장치를 포함하고, 코어 회로부는 제1 코어 회로부이고, 프로세서 회로부는 제1 동작들, 제2 동 작들, 또는 제3 동작 중 적어도 하나를 수행하여 카운터 회로부를 인스턴스화하며, 카운터 회로부는 제1 값을 출력하여 멀티플렉서 회로부에게 제2 인터페이스 회로부의 출력을 선택하도록 명령하고; 제2 값을 출력하여 멀 티플렉서 회로부에게 제2 코어 회로부와 연관된 제3 인터페이스 회로부의 출력을 선택하도록 명령한다. 예 36은 하드웨어 가속기를 디버깅하기 위한 방법을 포함하고, 방법은 기계 학습 모델과 연관된 중단점을 생성 하는 단계; 기계 학습 모델 또는 중단점 중 적어도 하나에 기초하여 실행가능 코드를 컴파일하는 단계 - 실행가 능 코드는 데이터 입력에 기초하여 데이터 출력을 생성하기 위해 가속기 회로부에 의해 실행됨 -; 실행가능 코 드의 실행에 응답하여, 중단점을 트리거하여 실행가능 코드의 실행을 중단시키는 단계; 및 가속기 회로부에 포 함된 디버그 회로부로 데이터 입력, 데이터 출력 또는 중단점 중 적어도 하나를 출력하는 단계를 포함한다. 예 37은 예 36의 방법을 포함하고, 작업부하별로 트리거될 것으로 중단점을 식별하는 단계; 작업부하별로 호출 될 실행가능 코드에 중단점을 삽입하는 단계; 가속기 회로부의 제1 코어에 의한 실행가능 코드의 실행에 응답하 여, 중단점이 제1 코어에 의해 트리거될 때, 제1 코어에 의한 실행가능 코드의 실행을 중단시키는 단계; 및 가 속기 회로부의 제2 코어에 의한 실행가능 코드의 실행에 응답하여, 중단점이 제2 코어에 의해 트리거될 때, 제2 코어에 의한 실행가능 코드의 실행을 중단시키는 단계를 더 포함한다. 예 38은 예 36의 방법을 포함하고, 코어별로 트리거될 것으로 중단점을 식별하는 단계; 가속기 회로부의 제1 코 어의 제1 구성 레지스터에 기입되고 가속기 회로부의 제2 코어의 제2 구성 레지스터에 기입되지 않을 것으로 중 단점을 식별하는 단계; 및 제1 구성 레지스터에 중단점을 기입하는 단계를 더 포함하고, 중단점의 트리거링은 제2 코어가 실행가능 코드의 실행을 계속하는 동안 제1 코어에 의한 실행가능 코드의 실행을 중단시킨다. 예 39는 예 36의 방법을 포함하고, 데이터 입력은 제1 데이터를 포함하고, 데이터 출력은 제2 데이터를 포함하 며, 방법은 제3 데이터에 기초하여 트리거될 것으로 중단점을 식별하는 단계; 제3 데이터를 가속기 회로부의 코 어의 구성 레지스터에 기입하는 단계; 제1 데이터와 제3 데이터의 제1 비교를 실행하는 단계 - 중단점의 트리거 링은 제1 비교에 기초하는 제1 데이터와 제3 데이터의 제1 매치에 응답함 -; 및 제2 데이터와 제3 데이터의 제2 비교를 실행하는 단계를 더 포함하며, 중단점의 트리거링은 제2 비교에 기초하는 제2 데이터와 제3 데이터의 제 2 매치에 응답한다. 예 40은 예 36의 방법을 포함하고, 데이터 출력과 연관된 메모리 내의 제1 어드레스에 기초하여 트리거될 것으 로 중단점을 식별하는 단계; 제1 어드레스를 가속기 회로부의 코어의 구성 레지스터에 기입하는 단계; 실행가능 코드를 실행하는 것에 응답하여, 데이터 출력을 기입할 메모리 내의 제2 어드레스를 식별하는 단계; 및 제1 어 드레스와 제2 어드레스의 비교를 실행하는 단계를 더 포함하고, 중단점의 트리거링은 제1 어드레스와 제2 어드 레스의 매치에 응답한다. 예 41은 예 36의 방법을 포함하고, 데이터 입력은 제1 데이터 입력이고, 방법은 중단점의 트리거링에 응답하여, 실행가능 코드의 증분 동작을 실행하는 것을 나타내는 제어 신호를 획득하는 단계 - 증분 동작은 제1 값을 판독 하기 위한 판독 동작, 제2 값을 기입하기 위한 기입 동작, 또는 제2 데이터 입력에 기초하여 제3 값을 결정하기 위한 계산 동작 중 적어도 하나를 포함함 -; 및 제1 값, 제2 값 또는 제3 값 중 적어도 하나를 출력하는 단계를 더 포함한다. 예 42는 예 36의 방법을 포함하고, 중단점의 트리거링에 응답하여, 데이터 입력의 제1 값을 조정하는 것; 가속 기 회로부의 코어의 제1 레지스터의 제2 값을 조정하는 것; 또는 디버그 회로부의 제2 레지스터의 제3 값을 조 정하는 것 중 적어도 하나를 수행하는 단계; 및 제1 값, 제2 값 또는 제3 값 중 적어도 하나에 기초하여 실행가 능 코드의 실행을 재개하는 단계를 더 포함한다. 이에 따라, 다음의 청구항들은 이러한 참조에 의해 본 상세한 설명에 통합된다. 특정한 예시적인 시스템들, 방 법들, 장치들 및 제조 물품들이 본 명세서에 개시되었지만, 본 특허의 커버리지의 범위는 이에 제한되지 않는다. 반대로, 본 특허는 본 특허의 청구항들의 범위 내에 상당히 속하는 모든 시스템들, 방법들, 장치들 및 제조 물품들을 커버한다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8a 도면8b 도면8c 도면8d 도면9 도면10 도면11 도면12 도면13 도면14 도면15 도면16 도면17"}
{"patent_id": "10-2023-7044126", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 가속기 회로부의 개선된 디버깅을 달성하기 위해 예시적인 디버그 회로부를 갖는 예시적인 가속기 회로 부를 포함하는 예시적인 컴퓨팅 시스템의 예시이다. 도 2는 도 1의 가속기 회로부 및 디버그 회로부의 예시적인 구현의 블록도이다. 도 3은 도 1의 가속기 회로부 및 디버그 회로부의 다른 예시적인 구현의 블록도이다. 도 4는 도 1의 가속기 회로부 및 디버그 회로부의 또 다른 예시적인 구현의 블록도이다. 도 5는 도 1의 가속기 회로부 및 디버그 회로부의 다른 예시적인 구현의 블록도이다. 도 6은 도 1의 가속기 회로부 및 디버그 회로부의 또 다른 예시적인 구현의 블록도이다. 도 7은 도 1의 가속기 회로부 및 디버그 회로부의 다른 예시적인 구현의 블록도이다. 도 8a는 도 1의 예시적인 가속기 회로부의 판독 동작들을 디버깅하기 위한 도 1의 디버그 회로부의 예시적인 구 현의 블록도이다. 도 8b는 도 1의 가속기 회로부의 기입 동작들을 디버깅하기 위한 도 1의 디버그 회로부의 예시적인 구현의 블록 도이다. 도 8c는 도 1의 가속기 회로부의 판독 동작들을 디버깅하기 위한 도 1의 디버그 회로부의 다른 예시적인 구현의 블록도이다. 도 8d는 도 1의 가속기 회로부의 기입 동작들을 디버깅하기 위한 도 1의 디버그 회로부의 다른 예시적인 구현의블록도이다. 도 9는 도 1, 2, 3, 4, 5, 6, 7, 8a, 8b, 8c 및/또는 8d의 예시적인 가속기 회로부의 예시적인 동작에 대응하 는 제1 예시적인 작업 흐름이다. 도 10은 도 1의 가속기 회로부의 다른 예시적인 구현의 예시적인 동작에 대응하는 제2 예시적인 작업 흐름이다. 도 11은 도 1의 예시적인 컴퓨팅 시스템을 구현하기 위해 예시적인 프로세서 회로부에 의해 실행되는 예시적인 기계 판독가능 명령어들 및/또는 예시적인 동작들을 나타내는 흐름도이다. 도 12는 도 1의 예시적인 컴퓨팅 시스템을 구현하기 위해 예시적인 프로세서 회로부에 의해 실행되는 예시적인 기계 판독가능 명령어들 및/또는 예시적인 동작들을 나타내는 다른 흐름도이다. 도 13은 도 1, 2, 3, 4, 5, 6, 7, 8a, 8b, 8c, 8d 및/또는 10의 예시적인 디버그 회로부 및/또는 예시적인 가 속기 회로부를 구현하기 위해 예시적인 프로세서 회로부에 의해 실행되는 예시적인 기계 판독가능 명령어들 및/ 또는 예시적인 동작들을 나타내는 흐름도이다. 도 14는 도 1, 2, 3, 4, 5, 6, 7, 8a, 8b, 8c, 8d 및/또는 10의 예시적인 디버그 회로부 및/또는 예시적인 가 속기 회로부를 구현하기 위해 도 11-13의 예시적인 기계 판독가능 명령어들 및/또는 예시적인 동작들을 실행하 도록 구조화된 프로세서 회로부를 포함하는 예시적인 처리 플랫폼의 블록도이다. 도 15는 도 14의 프로세서 회로부의 예시적인 구현의 블록도이다. 도 16은 도 14의 프로세서 회로부의 다른 예시적인 구현의 블록도이다. 도 17은 최종 사용자들 및/또는 소비자들, 소매업자들, 및/또는 OEM(original equipment manufacturer)들과 연 관된 클라이언트 디바이스들에 소프트웨어를 배포하기 위한 예시적인 소프트웨어 배포 플랫폼의 블록도이다."}
