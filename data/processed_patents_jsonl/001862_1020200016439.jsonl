{"patent_id": "10-2020-0016439", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0101903", "출원번호": "10-2020-0016439", "발명의 명칭": "전자 장치 및 그 제어 방법", "출원인": "삼성전자주식회사", "발명자": "조영래"}}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "전자 장치에 있어서,메모리; 및상기 메모리와 연결되어 상기 전자 장치를 제어하는 프로세서;를 포함하고,상기 프로세서는,디컨벌루션(Deconvolution) 연산의 입력 데이터가 입력되면, 연산 정보를 획득하고,상기 획득된 연산 정보에 기초하여, 출력 데이터의 크기를 획득하고,주소 생성 모듈을 이용하여, 상기 출력 데이터의 크기에 대응되는 복수의 메모리 주소값을 획득하고,컨벌루션 연산 모듈을 이용하여, 상기 연산 정보에기초하여 컨벌루션(Convolution) 연산을 수행하여 상기 컨벌루션 연산 과정에서 중간값을 획득하고,상기 주소 생성 모듈을 이용하여, 상기 획득된 복수의 메모리 주소값 중 상기 획득된 중간값에 대응되는 메모리주소값을 획득하고,상기 획득된 중간값을 상기 중간값에 대응되는 메모리 주소값에 저장하고,누적 연산 모듈을 이용하여, 상기 중간값에 대응되는 메모리 주소값에 기초하여 적어도 하나의 중간값을 누적하고,상기 누적된 적어도 하나의 중간값에 기초하여 상기 입력 데이터에 대한 디컨벌루션 연산값을 획득하는, 전자장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 프로세서는,상기 컨벌루션 연산 과정에서 획득되는 제1 중간값에 대응되는 제1 메모리 주소값에 기초하여 상기 제1 중간값을 상기 메모리에 저장하고,상기 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 상기 제1 메모리 주소값과일치하면, 상기 누적 연산 모듈을 이용하여 상기 제1 중간값 및 상기 제2 중간값을 누적하여 누적값을획득하고, 상기 획득된 누적값을 상기 제1 메모리 주소값에 기초하여 상기 메모리에 저장하는, 전자 장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 연산 정보는,상기 입력 데이터의 크기, 상기 디컨벌루션 연산에 이용되는 필터 데이터의 크기, 상기 컨벌루션 연산에 이용되는 스트라이드의 크기 또는 상기 제1 중간값에 대응되는 연산 순서 정보 중 적어도 하나를 포함하고,상기 프로세서는,상기 주소 생성 모듈을 이용하여, 상기 연산 정보에 기초하여 상기 제1 메모리 주소값을 획득하는, 전자 장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 프로세서는,공개특허 10-2021-0101903-3-제1 중간값에 대응되는 연산 순서 정보에 기초하여 상기 획득된 복수의 메모리 주소값 중 상기 획득된 제1 중간값에 대응되는 제1 메모리 주소값을 획득하는, 전자 장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서,상기 프로세서는,상기 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 상기 제1 메모리 주소값과일치하지 않으면, 상기 제2 중간값을 상기 제2 메모리 주소값에 저장하는, 전자 장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 프로세서는,상기 입력 데이터를 상기 디컨벌루션 연산에 이용되는 필터 데이터의 가로축 라인에 포함된 복수의 가중치와 순차적으로 컨벌루션 연산하여 복수의 중간값을 획득하는, 전자 장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,상기 프로세서는,누적 연산 모듈을 이용하여 상기 복수의 중간값 중 적어도 일부를 누적하며,상기 누적의 횟수는,상기 연산 정보에 기초하여 결정되는, 전자 장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 프로세서는,상기 중간값에 대응되는 내부 버퍼의 주소값에 기초하여 상기 중간값을 상기 내부 버퍼에 저장하고,상기 중간값에 누적 연산될 추가 중간값이 있는지 식별하고,상기 추가 중간값이 없는 것으로 식별되면, 상기 내부 버퍼에 저장된 상기 중간값을 상기 메모리에 저장하는, 전자 장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 프로세서는,상기 연산 정보에 기초하여 상기 중간값이 저장될 내부 버퍼의 크기를 결정하는, 전자 장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 1항에 있어서,상기 획득된 디컨벌루션 연산값은,디컨벌루션 연산 모듈을 이용하지 않고 획득된, 전자 장치."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "전자 장치의 제어 방법에 있어서,디컨벌루션(Deconvolution) 연산의 입력 데이터가 입력되면, 연산 정보를 획득하는 단계;상기 획득된 연산 정보에 기초하여, 출력 데이터의 크기를 획득하는 단계;주소 생성 모듈을 이용하여, 상기 출공개특허 10-2021-0101903-4-력 데이터의 크기에 대응되는 복수의 메모리 주소값을 획득하는 단계;컨벌루션 연산 모듈을 이용하여, 상기 연산 정보에 기초하여 컨벌루션(Convolution) 연산을 수행하여 상기 컨벌루션 연산 과정에서 중간값을 획득하는 단계;상기 주소 생성 모듈을 이용하여, 상기 획득된 복수의 메모리 주소값 중 상기 획득된 중간값에 대응되는 메모리주소값을 획득하는 단계;상기 획득된 중간값을 상기 중간값에 대응되는 메모리 주소값에 저장하는 단계;누적 연산 모듈을 이용하여, 상기 중간값에 대응되는 메모리 주소값에 기초하여 적어도 하나의 중간값을 누적하는 단계; 및상기 누적된 적어도 하나의 중간값에 기초하여 상기 입력 데이터에 대한 디컨벌루션 연산값을 획득하는 단계;를포함하는, 제어 방법."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,상기 획득된 중간값을 상기 중간값에 대응되는 메모리 주소값에 저장하는 단계는,상기 컨벌루션 연산 과정에서 획득되는 제1 중간값에 대응되는 제1 메모리 주소값에 기초하여 상기 제1 중간값을 메모리에 저장하고,상기 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 상기 제1 메모리 주소값과일치하면, 상기 누적 연산 모듈을 이용하여 상기 제1 중간값 및 상기 제2 중간값을 누적하여 누적값을획득하고, 상기 획득된 누적값을 상기 제1 메모리 주소값에 기초하여 메모리에 저장하는, 제어 방법."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서,상기 연산 정보는,상기 입력 데이터의 크기, 상기 디컨벌루션 연산에 이용되는 필터 데이터의 크기, 상기 컨벌루션 연산에 이용되는 스트라이드의 크기 또는 상기 제1 중간값에 대응되는 연산 순서 정보 중 적어도 하나를 포함하고,상기 획득된 중간값에 대응되는 메모리 주소값을 획득하는 단계는,상기 주소 생성 모듈을 이용하여, 상기 연산 정보에 기초하여 상기 제1 메모리 주소값을 획득하는, 제어 방법."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서,상기 획득된 중간값에 대응되는 메모리 주소값을 획득하는 단계는,제1 중간값에 대응되는 연산 순서 정보에 기초하여 상기 획득된 복수의 메모리 주소값 중 상기 획득된 제1 중간값에 대응되는 제1 메모리 주소값을 획득하는, 제어 방법."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제12항에 있어서,상기 획득된 중간값을 상기 중간값에 대응되는 메모리 주소값에 저장하는 단계는,상기 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 상기 제1 메모리 주소값과일치하지 않으면, 상기 제2 중간값을 상기 제2 메모리 주소값에 저장하는, 제어 방법."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제11항에 있어서,상기 중간값을 획득하는 단계는,상기 입력 데이터를 상기 디컨벌루션 연산에 이용되는 필터 데이터의 가로축 라인에 포함된 복수의 가중치와 순공개특허 10-2021-0101903-5-차적으로 컨벌루션 연산하여 복수의 중간값을 획득하는, 제어 방법."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서,상기 적어도 하나의 중간값을 누적하는 단계는,누적 연산 모듈을 이용하여 상기 복수의 중간값 중 적어도 일부를 누적하며,상기 누적의 횟수는,상기 연산 정보에 기초하여 결정되는, 제어 방법."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제11항에 있어서,상기 획득된 중간값을 상기 중간값에 대응되는 메모리 주소값에 저장하는 단계는,상기 중간값에 대응되는 내부 버퍼의 주소값에 기초하여 상기 중간값을 상기 내부 버퍼에 저장하고,상기 중간값에 누적 연산될 추가 중간값이 있는지 식별하고,상기 추가 중간값이 없는 것으로 식별되면, 상기 내부 버퍼에 저장된 상기 중간값을 메모리에 저장하는, 제어방법."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서,상기 제어 방법은,상기 연산 정보에 기초하여 상기 중간값이 저장될 내부 버퍼의 크기를 결정하는 단계;를 더 포함하는, 제어 방법."}
{"patent_id": "10-2020-0016439", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제11항에 있어서,상기 획득된 디컨벌루션 연산값은,디컨벌루션 연산 모듈을 이용하지 않고 획득된, 제어 방법."}
{"patent_id": "10-2020-0016439", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "전자 장치가 개시된다. 본 전자 장치는 메모리 및 메모리와 연결되어 전자 장치를 제어하는 프로세서를 포함하고, 프로세서는 디컨벌루션(Deconvolution) 연산의 입력 데이터가 입력되면, 연산 정보를 획득하고, 획득 된 연산 정보에 기초하여, 출력 데이터의 크기를 획득하고, 주소 생성 모듈을 이용하여, 출력 데이터의 크기에 (뒷면에 계속)"}
{"patent_id": "10-2020-0016439", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 전자 장치 및 그 제어방법에 관한 것으로, 더욱 상세하게는 디컨벌루션 연산을 수행하는 전자 장치 및 그 제어방법에 대한 것이다."}
{"patent_id": "10-2020-0016439", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "초해상화(Super resolution, SR)란 저해상도의 이미지를 고해상도의 이미지로 변환해주는 것을 의미할 수 있다. 여기서, 초해상화 동작을 수행함에 있어 인공지능 모델이 이용될 수 있다. 그리고, 초해상화 동작을 수행하는 인공지능 모델은 컨벌루션 레이어, 비선형 레이어(non-linear layer) 및 업스케일링 레이어를 포함할 수 있다. 초해상화 네트워크를 지원하는 Hardware accelerator(HWA)는 컨벌루션 연산을 수행하는 하드웨어와, non-linear function 으로 구성된 layer를 지원하는 하드웨어, 그리고 업스케일을 담당하는 하드웨어를 포함할 수 있다. 업스케일링 방법은 계산 방법 또는 구현 방식에 따라 다양할 수 있다. 업스케일링 방법에 따라 별도의 하드웨 어를 구성하는 경우 지나치게 많은 면적을 차지하는 문제점이 있을 수 있다. 특히 임베디드(Embedded) 환경에 서 하드웨어의 면적을 최소화하는 것이 중요할 수 있다. 한편, 컨벌루션 연산 동작을 수행하는 하드웨어가 구비된 전자 장치는 디컨벌루션 연산 동작을 수행하기 위하여 별도의 하드웨어를 구비해야 할 수 있다. 따라서, 컨벌루션 연산 동작을 수행하는 하드웨어 및 디컨벌루션 연산 동작을 수행하는 하드웨어를 모드 구비하기 위해서 전자 장치는 많은 면적을 할당해야 하는 문제점이 있을 수있다."}
{"patent_id": "10-2020-0016439", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시는 상술한 문제를 개선하기 위해 고안된 것으로, 본 개시의 목적은 컨벌루션 연산 과정을 통하여 디컨벌 루션 연산의 결과값을 획득하는 전자 장치 및 그의 제어 방법을 제공함에 있다."}
{"patent_id": "10-2020-0016439", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "상술한 목적을 달성하기 위한 본 실시 예에 따른 전자 장치는, 메모리 및 상기 메모리와 연결되어 상기 전자 장 치를 제어하는 프로세서를 포함하고, 상기 프로세서는 디컨벌루션(Deconvolution) 연산의 입력 데이터가 입력되 면, 연산 정보를 획득하고, 상기 획득된 연산 정보에 기초하여, 출력 데이터의 크기를 획득하고, 주소 생성 모 듈을 이용하여, 상기 출력 데이터의 크기에 대응되는 복수의 메모리 주소값을 획득하고, 컨벌루션 연산 모듈을 이용하여, 상기 연산 정보에 기초하여 컨벌루션(Convolution) 연산을 수행하여 상기 컨벌루션 연산 과정에서 중 간값을 획득하고, 상기 주소 생성 모듈을 이용하여, 상기 획득된 복수의 메모리 주소값 중 상기 획득된 중간값 에 대응되는 메모리 주소값을 획득하고, 상기 획득된 중간값을 상기 중간값에 대응되는 메모리 주소값에 저장하 고, 누적 연산 모듈을 이용하여, 상기 중간값에 대응되는 메모리 주소값에 기초하여 적어도 하나의 중간값을 누 적하고, 상기 누적된 적어도 하나의 중간값에 기초하여 상기 입력 데이터에 대한 디컨벌루션 연산값을 획득한다. 여기서, 상기 프로세서는 상기 컨벌루션 연산 과정에서 획득되는 제1 중간값에 대응되는 제1 메모리 주소값에 기초하여 상기 제1 중간값을 상기 메모리에 저장할 수 있고, 상기 컨벌루션 연산 과정에서 획득되는 제2 중간값 에 대응되는 제2 메모리 주소값이 상기 제1 메모리 주소값과 일치하면, 상기 누적 연산 모듈을 이용하여 상기 제1 중간값 및 상기 제2 중간값을 누적하여 누적값을 획득할 수 있고, 상기 획득된 누적값을 상기 제1 메모리 주소값에 기초하여 상기 메모리에 저장할 수 있다. 여기서, 상기 연산 정보는 상기 입력 데이터의 크기, 상기 디컨벌루션 연산에 이용되는 필터 데이터의 크기, 상 기 컨벌루션 연산에 이용되는 스트라이드의 크기 또는 상기 제1 중간값에 대응되는 연산 순서 정보 중 적어도 하나를 포함할 수 있고, 상기 프로세서는 상기 주소 생성 모듈을 이용하여, 상기 연산 정보에 기초하여 상기 제 1 메모리 주소값을 획득할 수 있다. 여기서, 상기 프로세서는 제1 중간값에 대응되는 연산 순서 정보에 기초하여 상기 획득된 복수의 메모리 주소값 중 상기 획득된 제1 중간값에 대응되는 제1 메모리 주소값을 획득할 수 있다. 한편, 상기 프로세서는, 상기 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 상 기 제1 메모리 주소값과 일치하지 않으면, 상기 제2 중간값을 상기 제2 메모리 주소값에 저장할 수 있다. 한편, 상기 프로세서는 상기 입력 데이터를 상기 디컨벌루션 연산에 이용되는 필터 데이터의 가로축 라인에 포 함된 복수의 가중치와 순차적으로 컨벌루션 연산하여 복수의 중간값을 획득할 수 있다. 여기서, 상기 프로세서는 누적 연산 모듈을 이용하여 상기 복수의 중간값 중 적어도 일부를 누적할 수 있고, 상 기 누적의 횟수는 상기 연산 정보에 기초하여 결정될 수 있다. 한편, 상기 프로세서는 상기 중간값에 대응되는 내부 버퍼의 주소값에 기초하여 상기 중간값을 상기 내부 버퍼 에 저장할 수 있고, 상기 중간값에 누적 연산될 추가 중간값이 있는지 식별할 수 있고, 상기 추가 중간값이 없 는 것으로 식별되면, 상기 내부 버퍼에 저장된 상기 중간값을 상기 메모리에 저장할 수 있다. 여기서, 상기 프로세서는 상기 연산 정보에 기초하여 상기 중간값이 저장될 내부 버퍼의 크기를 결정할 수 있다. 한편, 상기 획득된 디컨벌루션 연산값은 디컨벌루션 연산 모듈을 이용하지 않고 획득될 수 있다. 본 개시의 일 실시 예에 따른 전자 장치의 제어 방법에 있어서, 디컨벌루션(Deconvolution) 연산의 입력 데이터 가 입력되면, 연산 정보를 획득하는 단계, 상기 획득된 연산 정보에 기초하여, 출력 데이터의 크기를 획득하는 단계, 주소 생성 모듈을 이용하여, 상기 출력 데이터의 크기에 대응되는 복수의 메모리 주소값을 획득하는 단계, 컨벌루션 연산 모듈을 이용하여, 상기 연산 정보에 기초하여 컨벌루션(Convolution) 연산을 수행하여 상기 컨벌루션 연산 과정에서 중간값을 획득하는 단계, 상기 주소 생성 모듈을 이용하여, 상기 획득된 복수의 메 모리 주소값 중 상기 획득된 중간값에 대응되는 메모리 주소값을 획득하는 단계, 상기 획득된 중간값을 상기 중 간값에 대응되는 메모리 주소값에 저장하는 단계, 누적 연산 모듈을 이용하여, 상기 중간값에 대응되는 메모리 주소값에 기초하여 적어도 하나의 중간값을 누적하는 단계 및 상기 누적된 적어도 하나의 중간값에 기초하여 상 기 입력 데이터에 대한 디컨벌루션 연산값을 획득하는 단계를 포함할 수 있다. 여기서, 상기 획득된 중간값을 상기 중간값에 대응되는 메모리 주소값에 저장하는 단계는 상기 컨벌루션 연산 과정에서 획득되는 제1 중간값에 대응되는 제1 메모리 주소값에 기초하여 상기 제1 중간값을 메모리에 저장하고, 상기 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 상기 제1 메모리 주소값과 일치하면, 상기 누적 연산 모듈을 이용하여 상기 제1 중간값 및 상기 제2 중간값을 누적하여 누적값을 획득하고, 상기 획득된 누적값을 상기 제1 메모리 주소값에 기초하여 메모리에 저장할 수 있다. 여기서, 상기 연산 정보는 상기 입력 데이터의 크기, 상기 디컨벌루션 연산에 이용되는 필터 데이터의 크기, 상 기 컨벌루션 연산에 이용되는 스트라이드의 크기 또는 상기 제1 중간값에 대응되는 연산 순서 정보 중 적어도 하나를 포함할 수 있고, 상기 획득된 중간값에 대응되는 메모리 주소값을 획득하는 단계는 상기 주소 생성 모듈 을 이용하여, 상기 연산 정보에 기초하여 상기 제1 메모리 주소값을 획득할 수 있다. 여기서, 상기 획득된 중간값에 대응되는 메모리 주소값을 획득하는 단계는 제1 중간값에 대응되는 연산 순서 정 보에 기초하여 상기 획득된 복수의 메모리 주소값 중 상기 획득된 제1 중간값에 대응되는 제1 메모리 주소값을 획득할 수 있다. 한편, 상기 획득된 중간값을 상기 중간값에 대응되는 메모리 주소값에 저장하는 단계는 상기 컨벌루션 연산 과 정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 상기 제1 메모리 주소값과 일치하지 않으면, 상기 제2 중간값을 상기 제2 메모리 주소값에 저장할 수 있다. 한편, 상기 중간값을 획득하는 단계는 상기 입력 데이터를 상기 디컨벌루션 연산에 이용되는 필터 데이터의 가 로축 라인에 포함된 복수의 가중치와 순차적으로 컨벌루션 연산하여 복수의 중간값을 획득할 수 있다. 여기서, 상기 적어도 하나의 중간값을 누적하는 단계는 누적 연산 모듈을 이용하여 상기 복수의 중간값 중 적어 도 일부를 누적할 수 있고, 상기 누적의 횟수는 상기 연산 정보에 기초하여 결정될 수 있다. 한편, 상기 획득된 중간값을 상기 중간값에 대응되는 메모리 주소값에 저장하는 단계는 상기 중간값에 대응되는 내부 버퍼의 주소값에 기초하여 상기 중간값을 상기 내부 버퍼에 저장할 수 있고, 상기 중간값에 누적 연산될 추가 중간값이 있는지 식별할 수 있고, 상기 추가 중간값이 없는 것으로 식별되면, 상기 내부 버퍼에 저장된 상 기 중간값을 메모리에 저장할 수 있다. 여기서, 상기 제어 방법은 상기 연산 정보에 기초하여 상기 중간값이 저장될 내부 버퍼의 크기를 결정하는 단계 를 더 포함할 수 있다. 한편, 상기 획득된 디컨벌루션 연산값은 디컨벌루션 연산 모듈을 이용하지 않고 획득될 수 있다."}
{"patent_id": "10-2020-0016439", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하에서는 첨부 도면을 참조하여 본 개시를 상세히 설명한다. 본 개시의 실시 예에서 사용되는 용어는 본 개시에서의 기능을 고려하면서 가능한 현재 널리 사용되는 일반적인 용어들을 선택하였으나, 이는 당 분야에 종사하는 기술자의 의도 또는 판례, 새로운 기술의 출현 등에 따라 달 라질 수 있다. 또한, 특정한 경우는 출원인이 임의로 선정한 용어도 있으며, 이 경우 해당되는 개시의 설명 부 분에서 상세히 그 의미를 기재할 것이다. 따라서 본 개시에서 사용되는 용어는 단순한 용어의 명칭이 아닌, 그 용어가 가지는 의미와 본 개시의 전반에 걸친 내용을 토대로 정의되어야 한다. 본 명세서에서, \"가진다,\" \"가질 수 있다,\" \"포함한다,\" 또는 \"포함할 수 있다\" 등의 표현은 해당 특징(예: 수 치, 기능, 동작, 또는 부품 등의 구성요소)의 존재를 가리키며, 추가적인 특징의 존재를 배제하지 않는다. A 또는/및 B 중 적어도 하나라는 표현은 \"A\" 또는 \"B\" 또는 \"A 및 B\" 중 어느 하나를 나타내는 것으로 이해되어 야 한다. 본 명세서에서 사용된 \"제1,\" \"제2,\" \"첫째,\" 또는 \"둘째,\"등의 표현들은 다양한 구성요소들을, 순서 및/또는 중요도에 상관없이 수식할 수 있고, 한 구성요소를 다른 구성요소와 구분하기 위해 사용될 뿐 해당 구성요소들 을 한정하지 않는다. 어떤 구성요소(예: 제1 구성요소)가 다른 구성요소(예: 제2 구성요소)에 \"(기능적으로 또는 통신적으로) 연결되 어((operatively or communicatively) coupled with/to)\" 있다거나 \"접속되어(connected to)\" 있다고 언급된 때에는, 어떤 구성요소가 다른 구성요소에 직접적으로 연결되거나, 다른 구성요소(예: 제3 구성요소)를 통하여연결될 수 있다고 이해되어야 할 것이다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 출원에서, \"포함하다\" 또 는 \"구성되다\" 등의 용어는 명세서상에 기재된 특징, 숫자, 단계, 동작, 구성요소, 부품 또는 이들을 조합한 것 이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 본 개시에서 \"모듈\" 혹은 \"부\"는 적어도 하나의 기능이나 동작을 수행하며, 하드웨어 또는 소프트웨어로 구현되 거나 하드웨어와 소프트웨어의 결합으로 구현될 수 있다. 또한, 복수의 \"모듈\" 혹은 복수의 \"부\"는 특정한 하드 웨어로 구현될 필요가 있는 \"모듈\" 혹은 \"부\"를 제외하고는 적어도 하나의 모듈로 일체화되어 적어도 하나의 프 로세서(미도시)로 구현될 수 있다. 본 명세서에서, 사용자라는 용어는 전자 장치를 사용하는 사람 또는 전자 장치를 사용하는 장치(예: 인공지능 전자 장치)를 지칭할 수 있다. 이하 첨부된 도면들을 참조하여 본 개시의 일 실시예를 보다 상세하게 설명한다. 본 개시의 계산은 머신 러닝 기반의 인식 시스템에 의해 수행될 수 있으며, 본 개시에서는 뉴럴 네트워크 (Neural Networks)에 기반한 일련의 기계학습 알고리즘에 의한 분류 시스템으로서, 딥 러닝 기반의 인식 시스템 을 예로서 설명한다. 딥 러닝 기반의 인식 시스템은 적어도 하나의 분류기를 포함할 수 있으며, 분류기는 하나 또는 복수 개의 프로 세서에 해당할 수 있다. 프로세서는 다수의 논리 게이트들의 어레이(Array)로 구현될 수 있고, 범용적인 마이크 로 프로세서와 이 마이크로 프로세서에서 실행될 수 있는 프로그램이 저장된 메모리의 조합으로 구현될 수도 있 다. 분류기는 뉴럴 네트워크(Neural Network) 기반 분류기, SVM(Support Vector Machine), 에이다부스트 분류기 (Adaboost Classifier), 베이지안 분류기(Bayesian Classifier) 및, 퍼셉트론 분류기(Perceptron Classifier) 등으로 구현될 수 있다. 이하, 본 개시의 분류기는 컨볼루션 뉴럴 네트워크(Convolutional Neural Network, CNN) 기반 분류기로 구현되는 실시 예에 대하여 설명한다. 뉴럴 네트워크 기반 분류기는, 연결선으로 연결된 많 은 수의 인공 뉴런들을 이용하여 생물학적인 시스템의 계산 능력을 모방하도록 구현된 연산모델로서, 연결 강도 (가중치)를 갖는 연결선을 통해 인간의 인지작용이나 학습과정을 수행하게 된다. 그러나, 본 개시의 분류기가 이에 한정되는 것은 아니며, 상술한 다양한 분류기로 구현될 수 있음은 물론이다. 일반적인 뉴럴 네트워크는 입력층(input layer), 은닉층(hidden layer) 및 출력층(output layer)을 포함하며, 은닉층은 필요에 따라서 1 이상의 층으로 구성될 수 있다. 이러한, 뉴럴 네트워크를 학습시키기 위한 알고리즘 으로 역전파(Back Propagation) 알고리즘을 이용할 수 있다. 분류기는 어떠한 데이터가 뉴럴 네트워크의 입력층에 입력되면, 입력된 학습 데이터에 대한 출력 데이터가 뉴럴 네트워크의 출력층으로 출력되도록 뉴럴 네트워크를 학습시킬 수 있다. 촬영 이미지로부터 추출된 특징 정보가 입력되면, 뉴럴 네트워크를 이용하여 특징 정보의 패턴을 여러 클래스 중에서 어느 하나의 클래스로 분류하고, 분류 결과를 출력할 수 있다. 프로세서는 뉴럴 네트워크(Neural Networks)에 기반한 일련의 기계학습 알고리즘에 의한 분류 시스템으로서, 딥 러닝 기반의 인식 시스템을 이용할 수 있다. 도 1은 본 개시의 일 실시 예에 따른 전자 장치를 도시한 블록도이다. 도 1을 참조하면 전자 장치는 메모리 및 프로세서를 포함할 수 있다. 본 명세서의 다양한 실시 예들에 따른 전자 장치는, 는 컨벌루션 연산 동작을 수행하는 하드웨어를 포함하 는 컴퓨터 또는 서버일 수 있다. 메모리는 프로세서에 포함된 롬(ROM)(예를 들어, EEPROM(electrically erasable programmable read- only memory)), 램(RAM) 등의 내부 메모리로 구현되거나, 프로세서와 별도의 메모리로 구현될 수도 있다. 이 경우, 메모리는 데이터 저장 용도에 따라 전자 장치에 임베디드된 메모리 형태로 구현되거나, 전 자 장치에 탈부착이 가능한 메모리 형태로 구현될 수도 있다. 예를 들어, 전자 장치의 구동을 위한 데이터의 경우 전자 장치에 임베디드된 메모리에 저장되고, 전자 장치의 확장 기능을 위한 데이터의 경우 전자 장치에 탈부착이 가능한 메모리에 저장될 수 있다. 한편, 전자 장치에 임베디드된 메모리의 경우 휘발성 메모리(예: DRAM(dynamic RAM), SRAM(static RAM), 또는 SDRAM(synchronous dynamic RAM) 등), 비휘발성 메모리(non-volatile Memory)(예: OTPROM(one time programmable ROM), PROM(programmable ROM), EPROM(erasable and programmable ROM), EEPROM(electrically erasable and programmable ROM), mask ROM, flash ROM, 플래시 메모리(예: NAND flash 또는 NOR flash 등), 하드 드라이브, 또는 솔리드 스테이트 드라이 브(solid state drive(SSD)) 중 적어도 하나로 구현되고, 전자 장치에 탈부착이 가능한 메모리의 경우 메 모리 카드(예를 들어, CF(compact flash), SD(secure digital), Micro-SD(micro secure digital), Mini- SD(mini secure digital), xD(extreme digital), MMC(multi-media card) 등), USB 포트에 연결 가능한 외부 메 모리(예를 들어, USB 메모리) 등과 같은 형태로 구현될 수 있다. 프로세서는 전자 장치의 전반적인 제어 동작을 수행할 수 있다. 구체적으로, 프로세서는 전자 장치의 전반적인 동작을 제어하는 기능을 한다. 프로세서는 디지털 신호를 처리하는 디지털 시그널 프로세서(digital signal processor(DSP), 마이크로 프 로세서(microprocessor), TCON(Time controller)으로 구현될 수 있다. 다만, 이에 한정되는 것은 아니며, 중앙 처리장치(central processing unit(CPU)), MCU(Micro Controller Unit), MPU(micro processing unit), 컨트롤 러(controller), 어플리케이션 프로세서(application processor(AP)), GPU(graphics-processing unit) 또는 커 뮤니케이션 프로세서(communication processor(CP)), ARM 프로세서 중 하나 또는 그 이상을 포함하거나, 해당 용어로 정의될 수 있다. 또한, 프로세서는 프로세싱 알고리즘이 내장된 SoC(System on Chip), LSI(large scale integration)로 구현될 수도 있고, FPGA(Field Programmable gate array) 형태로 구현될 수도 있다. 또 한, 프로세서는 메모리에 저장된 컴퓨터 실행가능 명령어(computer executable instructions)를 실 행함으로써 다양한 기능을 수행할 수 있다. 여기서, 프로세서는 제어 모듈, 컨벌루션 연산 모듈, 주소 생성 모듈, 누적 연산 모듈 또는 버퍼 중 적어도 하나를 포함할 수 있다. 제어 모듈은 연산 정보를 획득할 수 있고 컨벌루션 연산 모듈 또는 주소 생성 모듈에 연산 정보 를 전달할 수 있다. 여기서, 연산 정보는 연산의 종류, 입력 데이터, 필터 데이터, 스트라이드 중 적어도 하나를 포함할 수 있다. 연산의 종류는 컨벌루션 연산 또는 디컨벌루션 연산(Deconvolution) (또는 트랜스포즈드 컨벌루션 연산, transposed convolution 연산)을 의미할 수 있다. 입력 데이터는 연산을 수행할 대상 데이터를 의미할 수 있다. 필터 데이터는 커널 데이터를 의미할 수 있으며, 입력 데이터의 크기를 변경하는데 이용되는 데이터일 수 있다. 또한, 필터 데이터는 적어도 하나의 가중치를 포함할 수 있다. 스트라이드는 컨벌루션 연산을 수행함에 있어 이용되는 이동 간격을 의미할 수 있다. 컨벌루션 연산 모듈은 수신된 연산 정보에 기초하여 컨벌루션 연산을 수행하는 모듈을 의미할 수 있다. 일 실시 예에 따라, 컨벌루션 연산 모듈은 모든 컨벌루션 연산을 수행하여 하나의 연산 결과값을 획득하는 형 태로 구현될 수 있다. 다른 실시 예에 따라, 컨벌루션 연산 모듈은 복수의 컨벌루션 연산 중 하나의 컨벌 루션 연산을 수행하여 하나의 중간값을 획득하고, 획득된 하나의 중간값을 누적 연산 모듈에 전송하는 형 태로 구현될 수 있다. 주소 생성 모듈은 메모리 또는 버퍼의 주소값을 생성 및 관리하는 모듈을 의미할 수 있다. 컨벌루션 연산 결과값 또는 디컨벌루션 연산 결과값은 특정 메모리의 주소값에 저장될 수 있으며, 최종 연산 결과값 이전에 획 득되는 중간값들은 버퍼에 저장될 수 있다. 여기서, 주소 생성 모듈은 중간값(또는 연산 결과값)이 저장될 버퍼의 주소값 또는 메모리의 주소값을 생성 및 관리할 수 있다. 누적 연산 모듈은 기존의 값에 새로운값을 더하여 누적하는 연산을 수행할 수 있다. 구체적으로, 누적 연 산 모듈은 버퍼에 이미 저장된 값과 컨벌루션 연산 모듈에서 새로 수신한 값을 누적할 수 있으 며, 누적된 새로운 값을 버퍼에 전송할 수 있다. 버퍼는 임시로 데이터를 저장하는 구성을 의미할 수 있다. 버퍼는 연산 결과값이 최종적으로 확정되 기 이전에 누적값들을 임시로 저장할 수 있으며, 필요에 따라 누적 연산 모듈 또는 메모리에 저장된 누적값을 전송할 수 있다.프로세서는 메모리와 연결되어 전자 장치를 제어할 수 있다. 프로세서의 전반적인 제어 동작은 제어 모듈에 의해 수행될 수 있다. 다만, 아래의 설명에서는 설명의 편의를 위하여 제어 모듈이 아닌 프로세서로 기재할 수 있다. 프로세서는 디컨벌루션(Deconvolution) 연산의 입력 데이터가 입력되면, 연산 정보를 획득할 수 있고, 획 득된 연산 정보에 기초하여, 출력 데이터의 크기를 획득할 수 있고, 주소 생성 모듈을 이용하여, 출력 데 이터의 크기에 대응되는 복수의 메모리 주소값을 획득할 수 있고, 컨벌루션 연산 모듈을 이용하여, 연산 정보에 기초하여 컨벌루션(Convolution) 연산을 수행하여 컨벌루션 연산 과정에서 중간값을 획득할 수 있고, 주 소 생성 모듈을 이용하여, 획득된 복수의 메모리 주소값 중 획득된 중간값에 대응되는 메모리 주소값을 획 득할 수 있고, 획득된 중간값을 중간값에 대응되는 메모리 주소값에 저장할 수 있고, 누적 연산 모듈을 이 용하여, 중간값에 대응되는 메모리 주소값에 기초하여 적어도 하나의 중간값을 누적할 수 있고, 누적된 적어도 하나의 중간값에 기초하여 입력 데이터에 대한 디컨벌루션 연산값을 획득할 수 있다. 프로세서는 디컨벌루션 연산의 입력 데이터를 수신하여 디컨벌루션 연산의 연산 정보를 획득할 수 있다. 디컨벌루션 연산의 연산 정보는 디컨벌루션 연산을 수행함에 있어 필요한 데이터를 포함할 수 있다. 여기서, 연 산 정보는 입력 데이터의 크기, 디컨벌루션 연산에 이용되는 필터 데이터의 크기, 컨벌루션 연산에 이용되는 스 트라이드의 크기 또는 제1 중간값에 대응되는 연산 순서 정보 중 적어도 하나를 포함할 수 있다. 여기서, 프로세서는 획득된 연산 정보에 기초하여 출력 데이터의 크기를 획득할 수 있다. 따라서, 연산 정 보가 달라지면 출력 데이터의 크기가 달라질 수 있다. 여기서, 입력 데이터의 크기 및 출력 데이터의 크기란 입 력 데이터 및 출력 데이터를 형성하는 메트릭스의 크기를 의미할 수 있다. 예를 들어, 크기는 3*3 또는 4*4와 같이 메트릭스의 크기를 의미할 수 있다. 여기서, 프로세서는 주소 생성 모듈을 이용하여 획득된 출력 데이터의 크기에 대응되는 메모리 주소 값을 획득할 수 있다. 프로세서는 출력 데이터의 구체적인 값을 획득하기 이전에 출력 데이터를 저장할 메 모리 주소값을 먼저 획득할 수 있다. 그리고, 획득된 메모리 주소값을 복수 개일 수 있다. 한편, 디컨벌루션 연산은 복수의 컨벌루션 연산의 중간값(또는 중간 결과값)들의 합으로 이루어질 수 있다. 디 컨벌루션 연산을 세분화 시키면 복수의 컨벌루션 연산들로 구성될 수 있다. 따라서, 프로세서는 디컨벌루 션 연산값을 획득하기 위하여 복수의 컨벌루션 연산을 수행할 수 있으며, 복수의 컨벌루션 연산 과정에서 중간 값을 획득할 수 있다. 프로세서는 하나의 컨벌루션 연산에서 하나의 중간값을 획득할 수 있다. 여기서, 프로세서는 획득된 중간값에 대응되는 메모리 주소값을 획득할 수 있다. 프로세서는 획득된 복수의 메모리 주소값 중에서 획득된 중간값에 대응되는 메모리 주소값을 연산 정보에 기초하여 획득할 수 있다. 연산 정보는 연산에 필요한 데이터가 포함되어 있으므로 프로세서는 연산 순서에 기초하여 획득된 중간값이 어느 메모리 주소값에 대응되는 것인지 식별할 수 있다. 그리고, 프로세서는 획득된 중간값을 획 득된 중간값에 대응되는 메모리 주소값에 저장할 수 있다. 여기서, 프로세서는 누적 연산 모듈을 이용하여 누적 동작을 수행할 수 있다. 구체적으로, 누적 동작 이란 중간값을 더하는 과정을 의미할 수 있다. 연산 정보에 기초하여 프로세서는 복수의 컨벌루션 연산 동 작을 수행할 수 있으며, 복수의 중간값을 획득할 수 있다. 여기서, 각 중간값에 대응되는 메모리 주소값이 동일 한 중간값이 존재할 수 있다. 중간값에 대응되는 메모리 주소값이 동일하면 중간값이 누적될 수 있다. 메모리 주소값이 동일한 중간값이 하나라면, 해당 메모리 주소값에서는 누적 동작이 수행되지 않을 수 있다. 모든 누적 동작이 완료되면, 프로세서는 메모리 주소값에 저장된 값에 기초하여 최종 디컨벌루션 연산값을 획득할 수 있다. 한편, 프로세서는 주소 생성 모듈을 이용하여, 연산 정보에 기초하여 제1 메모리 주소값 또는 제2 메 모리 주소값을 획득할 수 있다. 여기서, 제1 메모리 주소값은 제1 컨벌루션 연산 과정에서 획득되는 제1 중간값에 대응되는 주소값일 수 있다. 여기서, 프로세서는 제1 중간값에 대응되는 연산 순서 정보에 기초하여 획득된 복수의 메모리 주소값 중 획득된 제1 중간값에 대응되는 제1 메모리 주소값을 획득할 수 있다. 그리고, 프로세서는 제1 메모리 주소 값에 기초하여 제1 중간값을 메모리에 저장할 수 있다. 여기서, 제2 메모리 주소값은 제2 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 주소값일 수 있다. 여기서, 프로세서는 제2 중간값에 대응되는 연산 순서 정보에 기초하여 획득된 복수의 메모리 주소값 중획득된 제2 중간값에 대응되는 제2 메모리 주소값을 획득할 수 있다. 그리고, 프로세서는 제2 메모리 주소 값에 기초하여 제2 중간값을 메모리에 저장할 수 있다. 프로세서는 제2 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 제1 메모리 주소값과 일치하면, 누적 연산 모듈을 이용하여 제1 중간값 및 제2 중간값을 누적하여 누적값을 획득할 수 있고, 획득된 누적값을 제1 메모리 주소값에 기초하여 메모리에 저장할 수 있다. 한편, 프로세서는, 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 제1 메 모리 주소값과 일치하지 않으면, 제2 중간값을 제2 메모리 주소값에 저장할 수 있다. 제2 중간값을 제2 메모리 주소값에 저장하면 제1 중간값과 제2 중간값은 누적하지 않을 수 있다. 한편, 프로세서는 입력 데이터를 디컨벌루션 연산에 이용되는 필터 데이터의 가로축 라인에 포함된 복수의 값(가중치)들과 순차적으로 컨벌루션 연산하여 복수의 중간값을 획득할 수 있다. 여기서 프로세서는 가로 축 라인으로만 필터 데이터를 이용하는 것이 아니며, 가로축 라인과 세로축 라인 중 가로축 라인에 대응되는 필 터 데이터를 우선적으로 이용하는 것을 의미할 수 있다. 필터 데이터는 복수의 행(가로축 라인)과 복수의 열(세 로축 라인)로 구성된 메트릭스 형태일 수 있다. 그리고, 프로세서는 메트릭스 형태로 저장된 가중치에서 행을 기준으로 컨벌루션 연산을 수행할 수 있다. 필터데이터는 메트릭스로 구성될 수 있으며, 가로축 라인(행)과 세로축 라인(열)을 기준으로 배열된 데이터를 포함할 수 있다. 예를 들어, 필터 데이터는 3*3 크기일 수 있으며, 1행에는 w0(1,1), w1(1,2), w2(1,3)를 포함 하고, 2행에는 w3(2,1), w4(2,2), w5(2,3)를 포함하고, 3행에는 w6(3,1), w7(3,2), w8(3,3)를 포함하는 것으로 가정한다. 프로세서는 가로축(행)을 기준으로, w0(1,1), w1(1,2), w2(1,3) 순서대로 컨벌루션 연산을 수행 할 수 있다. 즉, 프로세서는 필터 데이터 중 1행에 대응되는 필터 데이터를 먼저 이용하고, 그 다음 2행 및 3행에 대응되는 필터 데이터를 이용할 수 있다. 가로축을 기준으로 컨벌루션 연산을 수행하는 이유는 누적값을 효율적으로 관리하기 위함이다. 가로축을 기준으 로 컨벌루션 연산을 수행하면, 메모리 주소값에 대응되는 최종 누적값을 최소한의 연산으로 획득할 수 있다. 따 라서, 최종 획득된 누적값이 확정되면 더 이상 버퍼 등을 이용하지 않을 수 있으므로 메모리 관리에 효율적일 수 있다. 이와 관련된 구체적인 설명은 도 8에서 후술한다. 여기서, 프로세서는 누적 연산 모듈을 이용하여 복수의 중간값 중 적어도 일부를 누적할 수 있고, 누 적의 횟수는 연산 정보에 기초하여 결정될 수 있다. 한편, 프로세서는 중간값에 대응되는 내부 버퍼의 주소값에 기초하여 중간값을 내부 버퍼에 저 장할 수 있고, 중간값에 누적 연산될 추가 중간값이 있는지 식별할 수 있고, 추가 중간값이 없는 것으로 식별되 면, 내부 버퍼에 저장된 중간값을 메모리에 저장할 수 있다. 여기서, 프로세서는 연산 정보에 기초하여 중간값이 저장될 내부 버퍼의 크기를 결정할 수 있다. 내부 버 퍼의 크기는 고정되어 있을 수 있다. 하지만, 메모리의 효율적인 관리를 위하여 프로세서는 내부 버퍼의 크기를 연산 정보에 기초하여 결정할 수 있다. 구체적으로, 입력 데이터의 크기가 클수록 내부 버퍼의 크기를 크게 할 수 있다. 버퍼 등과 관련된 구체적인 설명은 도 19 및 도 20에서 후술한다. 한편, 획득된 디컨벌루션 연산값은 디컨벌루션 연산 모듈을 이용하지 않고 획득될 수 있다. 상술한 설명을 통해 디컨벌루션 연산은 복수의 컨벌루션 연산 동작으로 구성된다고 기술하였다. 따라서, 본원 전자 장치는 기 존 컨벌루션 연산 모듈만을 이용하여 디컨벌루션 연산값을 획득할 수 있다. 본원 전자 장치는 디컨벌루션 연산만을 위한 하드웨어를 포함하지 않을 수 있다. 전자 장치는 기존 컨벌루션 연산 모듈만을 이용하 여 디컨벌루션 연산을 수행할 수 있다. 따라서, 본원 전자 장치는 컨벌루션 연산을 위한 하드웨어 및 디컨 벌루션 연산을 위한 하드웨어를 모두 포함하는 전자 장치에 비해서 연산 하드웨어의 공간이 적게 필요할 수 있 다. 따라서, 전자 장치는 다른 전자 장치에 비하여 하드웨어 공간이 적게 필요하므로 공간 효율성을 극대 화시킬 수 있다. 도 2는 일 실시 예에 따른 컨벌루션 연산 동작을 설명하기 위한 도면이다. 도 2를 참조하면, 전자 장치는 5*5 크기의 입력 데이터 와 3*3크기의 필터 데이터에 대하여 컨 벌루션 연산을 수행할 수 있다. 여기서, 입력 데이터 는 C0부터 C24까지의 값을 갖는 데이터일 수 있으며, 필터 데이터는 w0부터 w8까지의 값을 갖는 데이터 일 수 있다. 도 2의 실시 예에서, 스트라이드는 1로 가 정한다. 전자 장치는 입력 데이터, 필터 데이터 및 스트라이드에 기초하여 컨벌루션 연산의 최종 출력 데이터를 획득할 수 있다. 여기서, 컨벌루션 연산의 최종 출력 데이터의 크기는 3*3 일 수 있다. 도 3은 도 2의 컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 3을 참조하면, 도 2의 실시 예에 대한 컨벌루션 연산을 수행하기 위하여 전자 장치는 입력 데이터(21 0)의 일부 데이터(210-0)와 필터 데이터에 대하여 컨벌루션 연산 동작을 수행하여 출력 데이터의 일 부 데이터(230-0)를 획득할 수 있다. 도 4는 도 2의 컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 4를 참조하면, 도3의 연산 이후에 전자 장치는 스트라이드 1만큼 이동하여 다음 컨벌루션 연산 동작을 수행할 수 있다. 구체적으로, 전자 장치는 입력 데이터의 일부 데이터(210-1)와 필터 데이터에 대하여 컨벌루션 연산 동작을 수행하여 출력 데이터의 일부 데이터(230-1)를 획득할 수 있다. 도 5는 도 2의 컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 5를 참조하면, 도 4의 연산 이후에 전자 장치는 스트라이드 1만큼 이동하여 복수의 컨벌루션 연산 동작 을 수행할 수 있다. 도 5에서는 복수의 연산 동작 중 마지막 연산 동작을 도시한 것이다. 구체적으로, 전자 장 치는 입력 데이터의 일부 데이터(210-8)와 필터 데이터와 컨벌루션 연산 동작을 수행하여 출력 데이터의 일부 데이터(230-8)를 획득할 수 있다. 전자 장치는 최종적으로 도 5의 출력 데이터를 획득할 수 있으며, 도 5의 출력 데이터는 컨벌루 션 연산의 최종 결과값일 수 있다. 도 2 내지 도 5에서 설명한 것은 스트라이드가 1인 경우이고, 스트라이드의 크기에 따라 다른 크기의 출력 데이 터가 생성될 수 있다. 또한, 컨벌루션 연산 동작에서 이용된 입력 데이터 및 필터 데이터는 일 예에 불과하며, 다양한 크기의 데이터들이 적용될 수 있다. 한편, 도2 내지 도 5에서 설명한 입력 데이터, 필터 데이터, 출력 데이터는 컨벌루션 연산의 입력 데이터, 컨벌 루션 연산의 필터 데이터, 컨벌루션 연산의 출력 데이터를 의미할 수 있다. 도 6은 컨벌루션 연산과 디컨벌루션 연산을 설명하기 위한 도면이다. 도 6을 참조하면, 컨벌루션 연산은 컨벌루션 연산의 입력 데이터와 필터 데이터에 기초하여 출 력 데이터를 획득하는 것을 의미할 수 있다. 그리고, 디컨벌루션 연산은 컨벌루션 연산의 역과정을 수행하는 것을 의미할 수 있다. 구체적으로, 디컨벌루션 연산은 컨벌루션 연산의 출력 데이터와 컨벌 루션 연산의 필터 데이터에 기초하여 컨벌루션 연산의 입력 데이터를 획득하는 것을 의미할 수 있다. 디컨벌루션 연산을 설명함에 있어 컨벌루션 연산의 출력 데이터는 디컨벌루션 연산의 입력 데이터를 의미할 수 있으며, 컨벌루션 연산의 입력 데이터는 디컨벌루션 연산의 출력 데이터를 의미할 수 있다. 한편, 디컨벌루션 연산은 트랜스포즈드 컨벌루션(transposed convolution) 연산일 수 있다. 도 7은 일 실시 예에 따른 디컨벌루션 연산 동작을 설명하기 위한 도면이다. 도 7을 참조하면, 전자 장치는 디컨벌루션 연산(또는 transposed convolution 연산)을 수행할 수 있 다. 도 2의 실시 예를 참조하면, 컨벌루션 연산은 컨벌루션 연산의 입력 데이터, 컨벌루션 연산의 필터 데 이터 및 스트라이드 1에 기초하여 컨벌루션 연산의 출력 데이터를 획득하는 과정일 수 있다. 여기서, 디컨벌루션 연산은 컨벌루션 연산의 출력 데이터, 컨벌루션 연산의 필터 데이터 및 스트라이드 1에 기초하여 컨벌루션 연산의 입력 데이터를 획득하는 과정일 수 있다. 여기서, 컨벌루션 연산의 출력 데이터는 디컨벌루션 연산의 입력 데이터일 수 있으며, 컨벌루션 연산 의 필터 데이터는 디컨벌루션 연산의 필터 데이터일 수 있으며, 컨벌루션 연산의 입력 데이터는 디컨벌루션 연산의 출력 데이터일 수 있다. 도 7 내지 도 12에서 입력 데이터는 디컨벌루션 연산의 입력 데이터를 의미할 수 있고, 출력 데이터는 디컨벌루 션 연산의 출력 데이터를 의미할 수 있다. 도 7을 참조하면, 전자 장치는 3*3 크기의 입력 데이터, 3*3 크기의 필터 데이터 및 스트라이드 1에 기초하여 디컨벌루션 연산을 수행하여, 5*5 크기의 출력 데이터를 획득할 수 있다. 도 8은 도 7의 디컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 8을 참조하면, 본 개시의 일 실시 예에 따른 디컨벌루션 연산은 필터 데이터를 구분하여 연산 동작을 수행할 수 있다. 그리고, 본 개시의 일 실시 예에 따른 전자 장치는 컨벌루션 연산을 이용하여 디컨벌루션 연산의 결과값을 획득할 수 있다. 예를 들어, 필터 데이터가 3*3 행렬의 메트릭스이고 9개의 가중치(w0~w8)을 갖는다고 가정한다. 여기서, 필터 데이터에 포함된 가중치(w0~w8)들은 행을 기준으로 구분될 수 있다. 전자 장치는 필터 데이터 의 1행에 해당하는 가중치(w0, w1, w2)를 제1 그룹(620-1)으로, 필터 데이터의 2행에 해당하는 가중 치(w3, w4, w5)를 제2 그룹(620-2)으로, 필터 데이터의 3행에 해당하는 가중치(w6, w7, w8)를 제3 그룹 (620-3)으로 구분할 수 있다. 그리고, 전자 장치는 입력 데이터와 구분된 복수의 가중치 그룹(620-1, 620-2, 620-3)의 컨벌루션 연산을 수행하여 디컨벌루션 연산의 최종 결과값을 획득할 수 있다. 입력 데이터와 필터 데이터의 제1 그룹(620-1)과의 컨벌루션 연산 과정을 제1 페이즈(600-1)로 기술 하고, 입력 데이터와 필터 데이터의 제2 그룹(620-2)과의 컨벌루션 연산 과정을 제2 페이즈(600-2)로 기술하고, 입력 데이터와 필터 데이터의 제3 그룹(620-3)과의 컨벌루션 연산 과정을 제3 페이즈(600- 3)로 기술할 수 있다. 도 8에서는 간략한 설명을 위해 입력 데이터 중 i0(610-0)만을 기준으로 설명한다. 전자 장치는 제1 페이즈(600-1)에서 i0(610-0)와 제1 그룹(620-1)과 컨벌루션 연산을 수행하여 복수의 중 간값(630-1-0)을 획득할 수 있다. 또한, 전자 장치는 제2 페이즈(600-2)에서 i0(610-0)와 제2 그룹(620- 2)과 컨벌루션 연산을 수행하여 복수의 중간값(630-2-0)을 획득할 수 있다. 또한, 전자 장치는 제3 페이즈 (600-3)에서 i0(610-0)와 제3 그룹(620-3)과 컨벌루션 연산을 수행하여 복수의 중간값(630-3-0)을 획득할 수 있 다. 도 8에서 제1 페이즈(600-1), 제2 페이즈(600-2) 및 제3 페이즈(600-3)에 대한 설명은 i0(610-0)에 대한 계산 과정을 설명하기 위한 것이며 각 페이즈에 따른 디컨벌루션 연산의 전체적인 계산 과정은 도 9 내지 도 11에서 후술한다. 한편, 전자 장치는 필터 데이터의 메트릭스 중 행을 기준으로 페이즈를 구분할 수 있다. 행을 기준으 로 페이즈를 구분하는 이유는 데이터 연산을 효율적으로 수행하기 위함이다. 결과적으로 모든 데이터를 계산하 는 것은 동일하지만 행을 우선순위로 연산을 수행하면 누적 연산을 위하여 버퍼에 대기하는 값들의 수가 줄어들 수 있다. 버퍼에 대기하는 값들의 수가 줄어들면, 효율적인 메모리 운용 가능하여 전자 장치는 처리 시간 및 처리 용량을 감축시키는 효과를 가질 수 있다. 도 9는 도 7의 디컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 9를 참조하면, 제1 페이즈(600-1)는 입력 데이터에 기초하여 9개의 단계들(600-1-0 내지 600-1-8)로 구 분될 수 있다. 제1 페이즈(600-1)의 제0 단계(600-1-0)에서 전자 장치는 i0(610-0)와 필터 데이터의 제1 그룹(620- 1)사이의 컨벌루션 연산을 수행하여 복수의 중간값(630-1-0)을 획득할 수 있다. 복수의 중간값(630-1-0)은 3개 의 중간값(i0w0, i0w1, i0w2)을 포함할 수 있다. 그리고, 복수의 중간값(630-1-0)은 메트릭스에 기 설정된 순서로 저장될 수 있다. 제1 페이즈(600-1)의 제1 단계(600-1-1)에서 전자 장치는 i1(610-1)과 필터 데이터의 제1 그룹(620- 1)사이의 컨벌루션 연산을 수행하여 복수의 중간값(630-1-1)을 획득할 수 있다. 복수의 중간값(630-1-1)은 3개 의 중간값(i1w0, i1w1, i1w2)을 포함할 수 있다. 그리고, 전자 장치는 복수의 중간값(630-1-0)이 저장된 메트릭스에서 스트라이드 1만큼 우측으로(행 방향으로) 이동하여 복수의 중간값(630-1-1)을 누적하여 저장 할 수 있다. 복수의 중간값(630-1-1)을 누적한 결과는 메트릭스일 수 있다. 제1 페이즈(600-1)의 제2 단계(600-1-2)에서 전자 장치는 i2(610-2)와 필터 데이터의 제1 그룹(620- 1)사이의 컨벌루션 연산을 수행하여 복수의 중간값(630-1-2)을 획득할 수 있다. 복수의 중간값(630-1-2)은 3개 의 중간값(i2w0, i2w1, i2w2)을 포함할 수 있다. 그리고, 전자 장치는 복수의 중간값(630-1-1)이 누적된 메트릭스에서 스트라이드 1만큼 우측으로 이동하여 복수의 중간값(630-1-2)을 새로 누적하여 저장할 수 있 다. 복수의 중간값(630-1-2)을 누적한 결과는 메트릭스일 수 있다. 제3단계 내지 제7단계는 기존 단계와 반복되므로 반복되는 설명을 생략한다. 마지막으로, 제1 페이즈(600-1)의 제8 단계(600-1-8)에서 전자 장치는 i8(610-8)과 필터 데이터의 제1 그룹(620-1)사이의 컨벌루션 연산을 수행하여 복수의 중간값(630-1-8)을 획득할 수 있다. 복수의 중간값 (630-1-8)은 3개의 중간값(i8w0, i8w1, i8w2)을 포함할 수 있다. 그리고, 전자 장치는 복수의 중간값 (i7w0, i7w1, i7w2)이 누적된 메트릭스(미도시)에서 스트라이드 1만큼 우측으로 이동하여 복수의 중간값(630-1- 8)을 누적하여 저장할 수 있다. 복수의 중간값(630-1-8) 을 누적한 결과는 메트릭스일 수 있다. 도 10은 도 7의 디컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 10을 참조하면, 제2 페이즈(600-2)는 입력 데이터에 기초하여 9개의 단계들(600-2-0 내지 600-2-8)로 구분될 수 있다. 제2 페이즈(600-2)의 제0 단계(600-2-0)에서 전자 장치는 i0(610-0)와 필터 데이터의 제2 그룹(620- 2)사이의 컨벌루션 연산을 수행하여 복수의 중간값(630-2-0)을 획득할 수 있다. 복수의 중간값(630-2-0)은 3개 의 중간값(i0w3, i0w4, i0w5)을 포함할 수 있다. 그리고, 복수의 중간값(630-2-0)은 제1 페이즈(600-1)의 최종 누적 메트릭스에 추가로 누적될 수 있다. 여기서, 복수의 중간값(630-2-0)은 복수의 중간값(630-1-0)이 메 트릭스에서 저장된 위치를 기준으로 아래측 방향(열방향)으로 스트라이드 1만큼 움직여 누적될 수 있다. 복수의 중간값(630-2-0)을 누적한 결과는 메트릭스일 수 있다. 1단계 내지 제7단계는 기존 단계와 반복되므로 반복되는 설명을 생략한다. 마지막으로, 제2 페이즈(600-2)의 제8 단계(600-2-8)에서 전자 장치는 i8(610-8)과 필터 데이터의 제2 그룹(620-2)사이의 컨벌루션 연산을 수행하여 복수의 중간값(630-2-8)을 획득할 수 있다. 복수의 중간값 (630-2-8)은 3개의 중간값(i8w3, i8w4, i8w5)을 포함할 수 있다. 그리고, 전자 장치는 복수의 중간값 (i7w3, i7w4, i7w5)이 저장된 메트릭스(미도시)에서 스트라이드 1만큼 우측으로 이동하여 복수의 중간값(630-2- 8)을 누적하여 저장할 수 있다. 복수의 중간값(630-2-8)을 누적한 결과는 메트릭스일 수 있다. 도 11a 및 도 11b는 도 7의 디컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 11a 및 도 11b를 참조하면, 제3 페이즈(600-3)는 입력 데이터에 기초하여 9개의 단계들(600-3-0 내지 600-3-8)로 구분될 수 있다. 제3 페이즈(600-3)의 제0 단계(600-3-0)에서 전자 장치는 i0(610-0)와 필터 데이터의 제3 그룹(620- 3)사이의 컨벌루션 연산을 수행하여 복수의 중간값(630-3-0)을 획득할 수 있다. 복수의 중간값(630-3-0)은 3개 의 중간값(i0w6, i0w7, i0w8)을 포함할 수 있다. 그리고, 복수의 중간값(630-3-0)은 제2 페이즈(600-2)의 최종 누적 메트릭스에 추가로 누적될 수 있다. 여기서, 복수의 중간값(630-3-0)은 복수의 중간값(630-2-0)이 메트릭스에서 저장된 위치를 기준으로 아래측 방향(열방향)으로 스트라이드 1만큼 움직여 누적될 수 있다. 복수의 중간값(630-3-0)을 누적한 결과는 메트릭스일 수 있다. 1단계 내지 제7단계는 기존 단계와 반복되므로 반복되는 설명을 생략한다. 마지막으로, 제3 페이즈(600-3)의 제8 단계(600-3-8)에서 전자 장치는 i8(610-8)과 필터 데이터의 제3 그룹(620-3)사이의 컨벌루션 연산을 수행하여 복수의 중간값(630-3-8)을 획득할 수 있다. 복수의 중간값 (630-3-8)은 3개의 중간값(i8w6, i8w7, i8w8)을 포함할 수 있다. 그리고, 전자 장치는 복수의 중간값 (i7w6, i7w7, i7w8)이 저장된 메트릭스(미도시)에서 스트라이드 1만큼 우측으로 이동하여 복수의 중간값(630-3- 8)을 누적하여 저장할 수 있다. 복수의 중간값(630-3-8)을 누적한 결과는 메트릭스일 수 있다. 한편, 총 3개의 그룹으로 구분된 필터 데이터에 대한 모든 페이즈가 완료되면, 전자 장치는 출력 데 이터가 획득할 수 있다. 여기서, 출력 데이터는 디컨벌루션 연산의 결과값일 수 있다. 출력 데이터 는 메트릭스 정보를 포함할 수 있다. 도 9 내지 도 11에서 설명한 바와 같이 디컨벌루션 연산의 결과값을 획득함에 있어 컨벌루션 연산 및 누적 연산 만을 이용하였다. 따라서, 본 개시의 일 실시 예에 따른 전자 장치는 컨벌루션 연산 모듈만을 이용하여 디 컨벌루션 연산의 결과값을 획득할 수 있다. 그리고, 도 9 내지 도 11에서 기재한 필터 데이터의 크기가 1*3 크기로 기재하였지만, 최소 단위의 계산 과정은 1*1 크기의 필터 데이터 단위로 이루어 질 수 있다. 즉, 전자 장치는 하나의 컨벌루션 연산을 수행함에 있 어 1*1 크기의 필터(또는 커널)를 이용하여 1*1 크기의 중간값을 획득할 수 있으며, 획득된 1*1 크기의 중간값 을 각 중간값에 대응되는 메모리 주소에 저장할 수 있다. 여기서, 각 중간값에 대응되는 메모리 주소는 컨벌루션 연산 순서에 따라 상이할 수 있다. 도 12는 스트라이드 크기에 기초하여 디컨벌루션 연산 동작을 수행하는 실시 예를 설명하기 위한 도면이다. 도 12를 참조하면, 디컨벌루션 연산을 수행함에 있어, 입력 데이터의 크기는 3*3이며, 필터 데이터 의 크기는 3*3 이고, 스트라이드가 2라고 가정한다. 전자 장치는 입력 데이터, 필터 데이터 및 스트라이드 2에 기초하여 7*7 크기의 출력 데이터 를 획득할 수 있다. 여기서, 전자 장치는 획득한 출력 데이터 중에서 테두리 데이터를 제거하여 일부 데이터만을 최종 결과값으로 획득할 수 있다. 3*3 크기의 입력 데이터를 6*6 크기의 출력 데이터로 변환하기 위하여 전자 장치는 출력 데이터에서 테두리 데이터를 제거할 수 있다. 여 기서, 테두리 데이터는 출력 데이터에 대응되는 메트릭스에서 가장 바깥쪽에 위치한 데이터를 의미 할 수 있다. 여기서, 테두리 데이터는 o0, o1, o2, o3, o4, o5, o6, o13, o20, o27, o34, o41, o48, o47, o46, o45, o44, o43, o42, o35, o28, o21, o14, o7를 의미할 수 있다. 한편, 전자 장치는 스트라이드가 2 이상인 경우에 디컨벌루션 연산의 결과값 중 테두리 데이터에 해당하는 부분을 제거할 수 있다. 그리고, 전자 장치는 디컨벌루션 연산의 결과값 중 테두리 데이터에 해당하는 부 분이 제거된 나머지 데이터를 최종 결과값으로 획득할 수 있다. 전자 장치가 스트라이드 2 이상인 경우에 한하여 테두리 데이터를 제거하는 이유는 스트라이드가 1인 경우 제거 동작의 필요성이 낮기 때문이다. 스트라 이드가 1인 경우 제거 동작을 수행하면 입력 데이터의 크기와 출력 데이터의 크기가 동일하게 될 가능성이 있다. 따라서, 디컨벌루션 연산의 의미(예를 들어, 업스케일링)가 없어질 수 있으므로, 전자 장치는 스트 라이드가 2 이상인 경우에 한하여 테두리 데이터를 제거할 수 있다. 도 13은 본 개시의 일 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 13을 참조하면, 전자 장치는 연산 정보를 획득할 수 있다 (S1305). 여기서, 연산 정보는 연산에 필요한 다양한 정보를 의미할 수 있다. 예를 들어, 연산 정보는 연산의 종류(컨벌루션 연산 또는 디컨벌루션 연산인지 여부), 입력 데이터, 필터 데이터(또는 커널 데이터), 스트라이드 중 적어도 하나일 수 있다. 전자 장치는 수신된 연산 정보에 기초하여 출력 데이터의 크기를 획득할 수 있다 (S1310). 출력 데이터는 연산 정보에 기초하여 다른 크기일 수 있다. 여기서, 전자 장치는 획득된 출력 데이터의 크기에 기초하여 출력 데이터의 크기에 대응되는 메모리 주소를 획득할 수 있다 (S1315). 구체적으로, 전자 장치는 출력 데 이터가 저장될 메모리의 공간을 특정할 수 있다. 예를 들어, 출력 데이터가 5*5크기의 메트릭스인 경우, 전자 장치는 5*5 크기의 메트릭스를 저장할 메모리 공간을 특정할 수 있다. 메모리 공간은 메모리 주소값으로 특정될 수 있다. 즉, 전자 장치는 5*5 크기의 메트릭스가 저장될 메모리 주소값을 획득할 수 있다. 전자 장치는 메모리 주소값을 획득하기 위하여 메모리와 정보를 주고 받을 수 있다. 구체적인 설명은 도 15에서 후술한다. 전자 장치는 메모리 주소를 획득한 이후에, 복수의 컨벌루션 연산 중 하나의 컨벌루션 연산을 수행할 수 있다. 복수의 컨벌루션 연산은 기 설정된 순서에 의하여 차례대로 전자 장치에 의하여 수행될 수 있다. 전 자 장치는 하나의 컨벌루션 연산을 수행하여 하나의 컨벌루션 연산에 대한 결과값인 중간값을 획득할 수 있다 (S1320). 여기서, 하나의 컨벌루션 연산은 1*1 커널 단위(또는 1*1 채널)의 연산일 수 있다. 1*1 커널 단 위의 연산을 수행하여 1*1 커널 단위의 연산 결과값인 중간값을 획득할 수 있다. 여기서, 전자 장치는 획득된 중간값에 대응되는 메모리 주소값을 획득할 수 있다 (S1325). 여기서, 복수의 컨벌루션 연산 각각이 기 설정된 순서를 가지고 있으므로, 전자 장치는 기 설정된 순서에 기초하여 컨벌루 션 연산의 결과인 중간값에 대응되는 메모리 주소값을 획득할 수 있다. 전자 장치는 컨벌루션 연산의 결과 는 연산 동작을 수행해야 획득할 수 있지만, 컨벌루션 연산의 결과가 어느 메모리 주소값에 저장될지에 대한 정 보는 연산 동작을 수행하기 이전에도 획득할 수 있다. 여기서, 전자 장치는 획득된 중간값에 대응되는 메모리 주소값에 획득된 중간값을 누적하여 누적값을 획득 할 수 있다 (S1330). 중간값은 하나의 연산 결과를 의미할 수 있으며, 누적값은 복수의 중간값이 합산된 결과를 의미할 수 있다. 즉, 동일한 메모리 주소값에는 복수개의 중간 값이 누적되어 저장될 수 있다. 한편, 중간값을 반복적으로 누적한 값이 누적값으로 설명하였지만, 추가적으로 누적되지 않는 경우에도 획득된 중간값을 누적값 으로 기재할 수 있다. 구체적인 동작은 도 16 내지 도 19에서 후술한다. 한편, 전자 장치는 중간값을 획득한 이후에 복수의 컨벌루션 연산을 모두 수행하였는지 판단할 수 있다 (S1335). 여기서, 전자 장치는 컨벌루션 연산을 모두 수행하지 않고 추가로 수행할 컨벌루션 연산이 존재 한다고 판단하면, 기 설정된 순서에 따라 다음 컨벌루션 연산을 수행할 수 있다. 만약, 전자 장치가 S1335 단계에서 복수의 컨벌루션 연산을 모두 수행하였다고 판단하면, 전자 장치는 메모리 주소값에 저장된 누적 값을 디컨벌루션 연산의 결과값으로 획득할 수 있다 (S1340). 도 14는 본 개시의 다른 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 14를 참조하면, 전자 장치는 메모리 및 프로세서를 포함할 수 있고, 프로세서는 제어 모듈, 컨벌루션 연산 모듈, 주소 생성 모듈, 누적 연산 모듈, 버퍼를 포함할 수 있다. 제어 모듈은 연산 정보를 획득할 수 있다 (S1405). 여기서, 연산 정보는 연산의 종류, 입력 데이터 정보, 필터 데이터 정보, 스트라이드 정보 중 적어도 하나를 포함할 수 있다. 한편, 입력 데이터 정보는 입력 데이터 자체뿐만 아니라 입력 데이터의 크기 정보를 포함할 수 있으며, 필터 데이터 정보는 필터 데이터의 크기 정보를 포함할 수 있다. 또한, 스트라이드 정보는 스트라이드의 크기 정보를 포함할 수 있다. 여기서, 제어 모듈 은 연산 명령이 디컨벌루션 연산인지 판단할 수 있다 (S1410). 여기서, 제어 모듈은 연산 정보에 포함된 연산 명령의 종류 정보에 기초하여 S1410 단계를 수행할 수 있다. 여기서, 연산 명령이 디컨벌루션 연산이 아닌 컨벌루션 연산인 경우, 제어 모듈은 연산 정보를 컨벌루션 연산 모듈에 전송할 수 있다 (S1411). 그리고, 컨벌루션 연산 모듈은 수신된 정보에 기초하여 컨벌루 션 연산을 수행하고, 컨벌루션 연산에 대한 결과값을 획득할 수 있다 (S1412). 그리고, 컨벌루션 연산은 획득된 컨벌루션 연산에 대한 결과값을 메모리에 전송할 수 있다 (S1413). 한편, 도 14에서는 컨벌루션 연산 모듈 이 바로 연산 결과값을 메모리에 전송하는 것으로 기술하였지만, 컨벌루션 연산 모듈은 구현 예 에 따라 연산 결과값을 버퍼를 거쳐 메모리에 전송할 수 있다. 그리고, 메모리는 연산 결과값을 수신하여 저장할 수 있다 (S1414). 한편, 연산 명령이 디컨벌루션 연산인 경우, 제어 모듈은 연산 정보를 주소 생성 모듈에 전송할 수 있다 (S1420). 주소 생성 모듈은 연산 정보에 기초하여 출력 데이터의 크기를 획득할 수 있다 (S1421). 그 리고, 주소 생성 모듈은 획득된 출력 데이터의 크기에 기초하여 출력 데이터에 대응되는 메모리 주소값을 획득할 수 있다 (S1422). 메모리 주소값을 획득하는 구체적인 실시 예는 도 15에서 후술한다. 여기서, 주소 생 성 모듈은 획득한 메모리 주소값을 메모리에 전송할 수 있다 (S1423). 또한, 연산 명령이 디컨벌루션 연산인 경우, 제어 모듈은 연산 정보를 컨벌루션 연산 모듈에 전송할 수 있다 (S1430). 컨벌루션 연산 모듈은 수신된 연산 정보에 기초하여 1*1 커널(kernel) 단위의 컨벌루션 연산을 수행하여 컨벌루션 연산의 중간 결과값(또는 중간값)을 획득할 수 있다 (S1435). 여기서, 1*1 커널 단위 의 컨벌루션 연산이란 1*1 채널에 해당하는 필터 데이터를 적용하는 것을 의미할 수 있다. 커널은 필터와 유사 한 즉, 개별적인 컨벌루션 연산에서 최소 단위의 계산 과정은 1*1 크기의 필터 데이터를 이용하여 이루어질 수 있다. 한편, 최소 단위의 계산 과정에서 획득되는 중간값 역시 1*1 크기로 구성될 수 있으며, 1*1 크기의 중간 값은 1*1 크기의 중간 값에 대응되는 메모리 주소에 저장 될 수 있다. 중간 값이 메모리 주소에 저장 과정에 대 한 설명은 S1440 내지 S1465에서 기술한다. 한편, 컨벌루션 연산 모듈은 획득한 중간값을 누적 연산 모듈에 전송할 수 있다 (S1440). 또한, 누적 연산 모듈은 컨벌루션 연산 모듈로부터 중간값을 수신하고 수신된 중간값을 기존 누적값에 누적하고 추가 누적값이 존재하는지 판단할 수 있다 (S1445). 기존 누적값은 이미 획득한 중간값 또는 이미 누적 연산 모 듈에서 획득한 중간값을 의미할 수 있다. 그리고, 추가 누적값은 컨벌루션 연산을 추가적으로 수행하여 누 적할 새로운 중간값을 누적하여 획득되는 새로운 누적값을 의미할 수 있다. 한편, 누적 연산 모듈은 누적 값을 버퍼에 전송할 수 있다 (S1450). 그리고, 버퍼는 누적 연산 모듈로부터 수신된 누적값을 저장할 수 있다. 그리고, 버퍼는 메모리에 누적값을 전송할 수 있다 (S1455). 그리고, 메모리는 수신된 누적값을 메모리에 디컨벌루션 연산 의 결과값으로서 저장할 수 있다 (S1460). 누적 동작과 관련해 서 구체적인 동작은 도 16에서 후술한다. 도 15는 본 개시의 또 다른 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 15를 참조하면, 제어 모듈은 연산 정보를 획득할 수 있다 (S1505). 그리고, 제어 모듈은 획득한 연산 정보를 주소 생성 모듈에 전송할 수 있다 (S1510). 그리고, 주소 생성 모듈은 수신된 연산 정보에 기초하여 출력 데이터의 크기 정보를 획득할 수 있다 (S1515). 그리고, 주소 생성 모듈은 획득한 출력 데이터의 크기 정보를 메모리에 전송할 수 있다 (S1520). 구체적으로, S1520 단계는 출력 데이터가 저장될 메모리 영역을 지정하고, 지정된 영역에 대응되는 메모리 주소값을 반환해달라는 요청을 메모리에 전송하 는 단계를 의미할 수 있다. 메모리는 수신된 출력 데이터 크기 정보에 기초하여 출력 데이터가 저장될 메 모리 영역을 지정하고, 지정된 메모리 영역에 대응되는 메모리 주소값을 생성할 수 있다 (S1525). 그리고, 메모 리는 생성된 메모리 주소값을 주소 생성 모듈에 전송할 수 있다 (S1530). 여기서, 주소 생성 모듈 은 획득한 출력 데이터의 크기에 대응되는 메모리 주소값을 획득할 수 있다 (S1535). 도 16은 본 개시의 또 다른 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 16을 참조하면, 도 15에서 수행한 S1505 내지 S1535 동작이 수행되었음을 가정한다. 주소 생성 모듈은 획득된 출력 데이터의 크기에 대응되는 메모리 주소값을 획득할 수 있다 (S1605). 그리고 S1605 단계는 도 15의 S1535 단계에 대응될 수 있다. S1605 단계 이후, 주소 생성 모듈은 획득한 메모리 주소값을 컨벌루션 연산 모듈에 전송할 수 있다 (S1610). 또한, 제어 모듈은 연산 정보를 컨벌루션 연산 모듈에 전송할 수 있다 (S1615). 여기서, 컨 벌루션 연산 모듈은 수신된 연산 정보에 기초하여 컨벌루션 연산이 수행되는 횟수를 판단할 수 있다. 그리 고, 컨벌루션 연산 모듈은 기 설정된 순서 정보에 따라 복수의 컨벌루션 연산을 수행할 수 있다 (S1620). 여기서, 하나의 컨벌루션 연산에서 획득되는 중간 결과값을 중간값이라고 기술한다. 컨벌루션 연산 모듈은 복수의 컨벌루션 연산 중 하나의 컨벌루션 연산을 수행하여 하나의 중간값을 획득할 수 있다. 여기서, 컨벌루션 연산 모듈은 수신된 메모리 주소값 및 기 설정된 순서 정보에 기초하여 중간값 및 중간값에 대응되는 메모 리 주소값을 획득할 수 있다. 그리고, 주소 생성 모듈은 획득한 중간값 및 중간값에 대응되는 메모리 주소 값을 누적 연산 모듈에 전송할 수 있다 (S1625). 여기서, 누적 연산 모듈은 중간값에 대응되는 메모리 주소값에 기 저장된 누적값이 있는지 판단할 수 있다 (S1630). 동일한 메모리 주소값에 하나 이상의 중간값이 저장될 수 있기 때문에, 누적 연산 모듈은 누적값 을 갱신할 수 있다. 따라서, 누적 연산 모듈은 획득한 중간값을 중간값에 대응되는 메모리 주소값에 저장 시키는 경우, 이미 해당 메모리 주소값에 기존 누적값이 저장되어 있는지 여부를 판단할 수 있다. 컨벌루션 연 산 모듈에서 수행되어 획득되는 값은 중간값이라고 호칭하고, 버퍼 또는 메모리에 저장되는 값 들을 누적값으로 호칭한다. 경우에 따라, 실제로 누적 연산이 수행되지는 않고 처음으로 메모리 주소값에 저장 되는 중간값도 누적값으로 호칭할 수 있다. 중간값에 대응되는 메모리 주소값에 기 저장된 누적값이 없으면, 누적 연산 모듈은 획득한 중간값 및 획득 한 중간값에 대응되는 메모리 주소값을 버퍼에 전송할 수 있다 (S1635). 그리고, 버퍼는 획득한 중간 값 및 획득한 중간값에 대응되는 메모리 주소값을 저장할 수 있다 (S1640). 중간값에 대응되는 메모리 주소값에 기 저장된 누적값이 있으면, 누적 연산 모듈은 획득한 중간값에 대응 되는 메모리 주소값을 버퍼에 요청할 수 있다 (S1645). 그리고, 버퍼는 획득한 메모리 주소값에 이미 저장하고 있던 누적값을 누적 연산 모듈에 전송할 수 있다 (S1650). 그리고, 누적 연산 모듈은 획득 한 중간값과 수신된 누적값을 합산하여 새로운 누적값을 획득할 수 있다 (S1655). 그리고, 누적 연산 모듈(12 4)은 새로운 누적값을 버퍼에 전송할 수 있다 (S1660). 그리고, 버퍼는 새로운 누적값을 새로운 누적 값에 대응되는 메모리 주소값에 저장할 수 있다 (S1665). 여기서, 기존 누적값에 대응되는 메모리 주소값과 새 로운 누적값에 대응되는 메모리 주소값은 동일할 수 있다. 한편, 컨벌루션 연산 모듈은 S1620 및 S1625 단계를 수행한 이후에, S1620 단계에서 획득한 중간값에 대응 되는 메모리 주소값을 식별하고, 식별된 메모리 주소값에 저장할 추가 컨벌루션 연산 결과가 있는지 판단할 수 있다 (S1670). 앞서 설명한 바와 같이, 하나의 메모리 주소값에는 복수 개의 중간값이 저장되어 누적값이 갱신 될 수 있다. 컨벌루션 연산 모듈은 메모리 주소값에 추가적으로 누적할 중간값이 있는지 여부를 판단할 수 있다. 여기서, 주소값에 추가적으로 누적할 중간값이 있다고 판단되면, 컨벌루션 연산 모듈은 기 설정된 순서에 기초하여 다음 컨벌루션 연산을 수행하여 중간값을 획득할 수 있다. 여기서, 주소값에 추가적으로 누적할 중간값이 없다고 판단되면, 컨벌루션 연산 모듈은 버퍼에 저장된 누 적값을 확정하기 위한 제어 신호를 누적 연산 모듈에 전송할 수 있다 (S1671). 그리고, 누적 연산 모듈 은 버퍼에 저장된 누적값을 확정할 수 있다 (S1675).그리고, 누적 연산 모듈은 확정된 누적값 및 확정된 누적값에 대응되는 메모리 주소값을 메모리에 전 송하도록 버퍼에 요청할 수 있다. 그리고, 버퍼는 확정된 누적값 및 확정된 누적값에 대응되는 메모 리 주소값을 메모리에 전송할 수 있다. 그리고, 메모리는 확정된 누적값을 확정된 누적값에 대응되는 메모리 주소값에 저장할 수 있다. 도 17은 본 개시의 또 다른 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 17을 참조하면, 도 15에서 수행한 S1505 내지 S1535 동작 및 도 16의 S1605 내지 S1690 동작이 수행되었음을 가정한다. 주소 생성 모듈은 획득된 출력 데이터의 크기에 대응되는 메모리 주소값을 획득할 수 있다 (S1705). 그리고 S1705 단계는 도 15의 S1535 단계에 대응될 수 있다. 주소 생성 모듈은 획득한 메모리 주소값을 컨벌루션 연산 모듈에 전송할 수 있다 (S1710). 또한, 제 어 모듈은 연산 정보를 컨벌루션 연산 모듈에 전송할 수 있다 (S1715). 여기서, 여기서, 컨벌루션 연산 모듈은 수신된 연산 정보에 기초하여 컨벌루션 연산이 수행되는 횟수를 판 단할 수 있다. 그리고, 컨벌루션 연산 모듈은 기 설정된 순서 정보에 따라 복수의 컨벌루션 연산을 수행할 수 있다 (S1720). S1720 단계는 도 16의 S1620 단계와 대응될 수 있으므로 중복 설명을 생략한다. 컨벌루션 연 산 모듈은 중간값 및 중간값에 대응되는 메모리 주소값을 누적 연산 모듈에 전송할 수 있다 (S1725). 그리고, 누적 연산 모듈은 누적 연산 동작을 수행할 수 있다 (S1730). 그리고, 누적 연산 모듈은 누 적 연산 동작에서 획득한 누적값을 메모리에 전송할 수 있다 (S1735). 그리고, 메모리는 누적값을 누 적값에 대응되는 메모리 주소값에 저장할 수 있다 (S1740). 도 17에서 설명한 S1730, S1735, S1740 동작은 도 16의 S1630 내지 S1690 동작을 간략히 기술한 것에 해당할 수 있다. 따라서, 도 17에서 중복되는 설명을 생략한 다. 컨벌루션 연산 모듈은 S1720 단계 이후에, 복수의 컨벌루션 연산이 모두 수행되었는지 판단할 수 있다 (S1745). 복수의 컨벌루션 연산이 모두 수행되지 않은 경우, 컨벌루션 연산 모듈은 기 설정된 순서에 기초 하여 다음 컨벌루션 연산을 수행할 수 있다. 복수의 컨벌루션 연산이 모두 수행된 것으로 판단하면, 컨벌루션 연산 모듈은 메모리 주소값에 저장된 누적값을 디컨벌루션 연산의 최종 결과값으로 획득할 수 있다 (S1750). 도 18은 디컨벌루션 연산 동작에 대한 결과값을 메모리 주소에 할당하는 동작을 설명하기 위한 도면이다. 도 18을 참조하면, 전자 장치는 입력 데이터, 필터 데이터, 스트라이드 1에 기초하여 디컨벌루 션 연산을 수행할 수 있다. 상술한 연산 동작은 도 7에서 설명한 바와 동일하여 중복 설명을 생략한다. 전자 장치는 3*3 크기의 입력 데이터, 3*3 크기의 필터 데이터 및 스트라이트 1에 기초하여 5*5 크기의 출력 데이터를 획득할 수 있다. 여기서, 3*3 크기의 입력 데이터, 3*3 크기의 필터 데이터 및 스트라이트 1은 연산 정보에 포함될 수 있다. 전자 장치는 연산 정보에 기초하여 출력 데이터의 크기가 5*5라는 정보를 획득할 수 있다. 연산 정보에 포함된, 입력 데이터의 크기, 필터 데이터의 크기, 스트라이드에 따라 출력데이터의 크기가 상이할 수 있으며, 해당 정보는 이미 전자 장치에 기 저장될 수 있다. 출력 데이터의 크기가 5*5인 경우, 전자 장치는 출력 데이터의 크기에 대응되는 메모리 주소값을 획득할 수 있다. 출력 데이터는 C0 내지 C24까지 5*5 크기의 메트릭스 형태일 수 있다. 여기서, 출력 데이터(63 0)에 포함된 C0 내지 C24의 값들은 각각 자신의 값에 대응되는 메모리 주소값에 저장될 수 있다. 출력 데이터 에 대응되는 메모리 주소값은 전자 장치가 직접 계산하거나 메모리에 의하여 획득될 수 있다. 또한, 출력 데이터에 대응되는 메모리 주소값은 메트릭스와 대응될 수 있다. 출력 데이터에 대응되는 메모리 주소값은 #m-00부터 #m-24까지 총 25개의 주소값을 포함할 수 있다. 예를 들어, 출력 데이터에 포함된 C0은 #m-00에 저장될 수 있으며, C24는 #m-24에 저장될 수 있다. 도 19는 디컨벌루션 연산 동작에서 획득되는 중간값을 버퍼 주소 및 메모리 주소에 할당하는 동작을 설명하기 위한 도면이다. 도 19를 참조하면, 도 9에서 설명한 과정 중 제1 페이즈(600-1)의 0단계(600-1-0)의 동작을 버퍼의 주소값 및 메모리의 주소값을 이용하여 설명한다. 한편, 구체적인 동작은 도 9에서 이미 설명하였으므로 중복 설 명을 생략한다. 그리고 도 19에서는 버퍼의 주소값이 3개이고 버퍼의 주소값은 #b-00(125-0), #b-01(125-1), #b-02(125-2)라고 가정한다. 그리고, 본 명세서에서는 버퍼의 제1 주소값(125-0), 버퍼의 제2 주소값(125-1), 버퍼의 제3 주소값 (125-2)으로 후술한다. 전자 장치는 제1 페이즈(600-1)의 0단계(600-1-0)에서 복수의 중간값(630-1-0)인 i0w0, i0w1, i0w2를 획 득할 수 있다. 여기서, 도 18에서 설명한 바와 같이 각각의 중간값은 중간값에 대응되는 메모리 주소값을 획득 할 수 있다. 여기서, i0w0은 메모리의 제1 주소값(#m-00, 110-1-00)에 대응되고, i0w1은 메모리의 제2 주소값 (#m-01, 110-1-01)에 대응되고, i0w2는 메모리의 제3 주소값(#m-02, 110-1-02)에 대응될 수 있다. 일 실시 예로, 복수의 중간값(630-1-0)인 i0w0, i0w1, i0w2가 바로 메모리에 저장되는 형태로 구현 될 수 있다. 하지만, 도 19에서는 버퍼를 거쳐 메모리에 저장되는 다른 실시 예를 설명한다. 전자 장치는 획득한 중간값(i0w0, i0w1, i0w2)을 버퍼에 저장할 수 있다. 구체적으로, 전자 장치 는 전자 장치에서 획득한 중간값을 획득한 순서에 기초하여 차례대로 버퍼에 저장할 수 있다. 예를 들어, 전자 장치는 버퍼의 제1 주소값(125-0)에 i0w0을 저장하고, 버퍼의 제2 주소값(125-1)에 i0w1 에 저장하고, 버퍼의 제3 주소값(125-2)에 i0w2을 저장할 수 있다. 한편, 다른 실시 예에 따라, 전자 장치(10 0)는 각 버퍼의 주소값에 중간값을 저장하면서 중간값에 대응되는 메모리의 주소값을 함께 저장할 수 있다. 예 를 들어, 버퍼의 제1 주소값(125-0)에 중간값(i0w0) 및 중간값(i0w0)에 대응되는 메모리의 주소값(#m-00)을 함 께 저장하고, 버퍼의 제2 주소값(125-1)에 중간값(i0w1) 및 중간값(i0w1)에 대응되는 메모리의 주소값(#m-01)을 함께 저장하고, 버퍼의 제3 주소값(125-2)에 중간값(i0w2) 및 중간값(i0w2)에 대응되는 메모리의 주소값(#m- 02)을 함께 저장할 수 있다. 제1 페이즈(600-1)의 0단계(600-1-0)가 완료된 후에 버퍼에 저장된 형태는 표와 같을 수 있다. 여기서, 전자 장치는 각각의 중간값에 대응되는 메모리 주소값에 기초하여 추가로 누적될 중간값이 있는지 판단할 수 있다. 해당 동작은 도 16의 S1670에 대응될 수 있다. 전자 장치는 획득한 중간값(i0w0)에 대응 되는 메모리 주소값 (#m-00)을 식별할 수 있고, 획득한 중간값(i0w0)에 대응되는 메모리 주소값 (#m-00)에 추가 로 누적할 중간값이 있는지 판단할 수 있다. 전자 장치는 출력 데이터의 크기 및 컨벌루션 연산의 수행 순 서에 기초하여 추가로 누적한 중간값이 있는지 여부를 판단할 수 있다. 도 11의 출력 데이터에 대응되는 메트릭스를 참고하면, 메모리 주소값 (#m-00)에 대응되는 중간값은 i0w0 가 유일할 수 있다. 따라서, 전자 장치는 획득한 중간값(i0w0)에 대응되는 메모리 주소값 (#m-00)에 추가 로 누적할 중간값이 없다고 판단할 수 있다. 획득한 중간값(i0w0)에 대응되는 메모리 주소값 (#m-00)에 추가로 누적할 중간값이 없는 경우, 전자 장치는 버퍼의 제1 주소값(125-0)에 저장된 중간값(i0w0)(또는 누적값으 로 기재)을 메모리에 전송할 수 있다. 그리고, 메모리는 수신된 중간값(i0w0)을 중간값(i0w0)에 대응 되는 메모리 주소값 (#m-00)에 저장할 수 있다. 한편, 도 11의 출력 데이터에 대응되는 메트릭스를 참고하면, 메모리 주소값 (#m-01)에 대응되는 중간값 (i0w1)은 추가로 저장될 중간값(i1w0)이 있을 수 있다. 따라서, 전자 장치는 획득한 중간값(i0w1)에 대응 되는 메모리 주소값 (#m-01)에 추가로 누적할 중간값이 있다고 판단할 수 있다. 여기서, 획득한 중간값(i0w1)에 대응되는 메모리 주소값 (#m-01)에 추가로 누적할 중간값이 있는 경우, 전자 장치는 버퍼의 제2 주소값 (125-1)에 저장된 중간값(i0w1)을 메모리로 전송하지 않고, 버퍼의 제2 주소값(125-1)에 계속 저장할 수 있다. 한편, 전자 장치는 버퍼의 제3 주소값(125-2)에 저장된 중간값(i0w2) 역시 메모리로 바로 전송하지 않고 버퍼의 제3 주소값(125-2)에 계속 저장할 수 있다. 중간값(i0w2)에 대한 구체적인 설명은 중간값(i0w1)과 동일하므로, 중복되는 설명을 생략한다. 표를 참조하면, 전자 장치는 제1 페이즈(600-1)의 0단계(600-1-0) 이후에 중간값(i0w0)만을 메모리 에 전송하여 중간값(i0w0)에 대응되는 메모리의 주소값(#m-00)에 저장할 수 있다. 그리고, 전자 장치는 메모리에 중간값(i0w0)을 전송한 이후(또는, 메모리가 중간값(i0w0)을 저 장하였다는 제어 신호를 수신한 이후) 버퍼의 제1 주소값(125-0)에 저장된 중간값(i0w0) 및 중간값(i0w0)에 대 응되는 메모리의 주소값(#m-00)을 버퍼의 제1 주소값(125-0)에서 삭제할 수 있다. 중간값(i0w0)은 추가로 누적 되지 않기 때문에 더 이상 버퍼에 저장될 필요성이 없기 때문이다. 중간값(i0w0) 및 중간값(i0w0)에 대응되는 메모리의 주소값(#m-00)이 삭제된 이후의 버퍼는 표에 대응될 수 있다. 도 20은 디컨벌루션 연산 동작에서 획득되는 중간값을 버퍼 주소 및 메모리 주소에 할당하는 동작을 설명하기 위한 도면이다.도 20을 참조하면, 도 9에서 설명한 과정 중 제1 페이즈(600-1)의 1단계(600-1-1)의 동작을 버퍼의 주소값 및 메모리의 주소값을 이용하여 설명한다. 한편, 구체적인 동작은 도 9에서 이미 설명하였으므로 중복 설 명을 생략한다. 또한, 도 20에서 설명하는 동작은 도 19에서 설명한 동작과 연속되며, 중복되는 내용은 생략한 다. 전자 장치는 제1 페이즈(600-1)의 1단계(600-1-1)에서 복수의 중간값(630-1-1)인 i1w0, i1w1, i1w2를 획 득할 수 있다. 여기서, 도 18에서 설명한 바와 같이 각각의 중간값은 중간값에 대응되는 메모리 주소값을 획득 할 수 있다. 여기서, i1w0은 메모리의 제2 주소값(#m-01,110-1-01)에 대응되고, i1w1은 메모리의 제3 주소값 (#m-02, 110-1-02)에 대응되고, i1w2는 메모리의 제4 주소값((#m-03, 110-1-03)에 대응될 수 있다. 그리고, 전자 장치는 획득한 중간값(i1w0, i1w1, i1w2)을 버퍼에 저장할 수 있다. 전자 장치는 획득한 중간값(i1w0, i1w1, i1w2)이 버퍼 어느 주소에 저장될지 판단할 수 있다. 구체적으로, 전자 장치 는 획득한 중간값에 대응되는 메모리 주소값에 대한 정보가 이미 버퍼에 저장되어 있는지 여부를 판 단할 수 있다. 도 19에서는 버퍼에 중간값이 저장되어 있지 않았기 때문에 중간값에 대응되는 메모리 주소 값에 대한 정보가 이미 버퍼에 저장되어 있는지 여부를 판단하지 않았다. 하지만, 버퍼에 이미 중간 값이 누적되어 있다면, 전자 장치는 새로 획득한 중간값에 대응되는 메모리 주소값이 버퍼에 저장되어 있 는지 판단 할 수 있다. 전자 장치는 새로 획득한 중간값에 대응되는 메모리 주소값이 버퍼에 저장되어 있 는 경우, 해당 메모리 주소값이 저장된 버퍼에 새로운 중간값을 누적할 수 있다. 구체적으로, 전자 장치는 중간값(11w0) 및 중간값(11w0)에 대응되는 메모리 주소값(#m-01)을 획득할 수 있 다. 여기서, 전자 장치는 메모리 주소값(#m-01)에 대한 정보가 버퍼에 저장되어 있는지 판단할 수 있 다. 버퍼에 메모리 주소값(#m-01)에 대한 정보가 있는 경우, 전자 장치는 메모리 주소값(#m-01)이 저 장된 버퍼의 주소값(#b-01, 125-1)을 식별하고, 식별된 주소값(#b-01, 125-1)에 기존 누적값(i0w1) 및 새로운 중간값(i1w0)을 합산할 수 있다. 그리고, 전자 장치는 합산된 새로운 누적값(i0w1+i1w0)을 식별된 버퍼의 주소값(#b-01, 125-1)에 저장할 수 있다. 마찬가지로, 전자 장치는 중간값(11w1) 및 중간값(11w1)에 대응되는 메모리 주소값(#m-02)을 획득할 수 있 다. 그리고, 전자 장치는 합산된 새로운 누적값(i0w2+i1w1)을 식별된 버퍼의 주소값(#b-02, 125-2)에 저장 할 수 있다. 중복되는 설명은 생략한다. 또한, 전자 장치는 중간값(11w2) 및 중간값(11w2)에 대응되는 메모리 주소값(#m-03)을 획득할 수 있다. 전 자 장치는 중간값(11w2)에 대응되는 메모리 주소값(#m-03)이 버퍼에 저장되어 있지 않았으므로, 새로운 버 퍼의 주소값 또는 비어 있는 버퍼의 주소값(#b-00, 125-0)에 중간값(11w2) 및 중간값(11w2)에 대응되는 메모리 주소값(#m-03)을 저장할 수 있다. 중간값(i1w0, i1w1, i1w2)이 버퍼에 저장된 최종 형태는 표와 같을 수 있다. 그리고, 전자 장치는 도 19에서 설명한 것과 같이, 버퍼에 저장된 중간값에 대응되는 메모리 주소값에 기 초하여 추가 누적값이 존재하는지 여부를 판단할 수 있다. 해당 동작은 도 16의 S1670에 대응될 수 있다. 도 11에서 기재한 출력 데이터에 대응되는 메트릭스를 참고하면, 메모리 주소값 (#m-01)에 대응되는 누적 값(i0w1+i1w0)은 추가로 누적할 중간값이 존재하지 않는다. 따라서, 전자 장치는 획득한 누적값 (i0w1+i1w0)에 대응되는 메모리 주소값 (#m-01)에 추가로 누적할 중간값이 없다고 판단할 수 있다. 획득한 누적 값(i0w1+i1w0)에 대응되는 메모리 주소값 (#m-01)에 추가로 누적할 중간값이 없는 경우, 전자 장치는 버퍼 의 제2주소값(#b-01, 125-1)에 저장된 누적값(i0w1+i1w0)을 메모리에 전송할 수 있다. 그리고, 메모리 는 수신된 누적값(i0w1+i1w0)을 누적값(i0w1+i1w0)에 대응되는 메모리 주소값 (#m-01)에 저장할 수 있다. 한편, 도 11에서 기재한 출력 데이터에 대응되는 메트릭스를 참고하면, 메모리 주소값 (#m-02)에 대응되 는 누적값(i0w2+i1w1)은 추가로 저장될 중간값(i2w0)이 있을 수 있다. 따라서, 전자 장치는 획득한 누적값 (i0w2+i1w1)에 대응되는 메모리 주소값 (#m-02)에 추가로 누적할 중간값이 있다고 판단할 수 있다. 여기서, 획 득한 누적값(i0w2+i1w1)에 대응되는 메모리 주소값 (#m-02)은 추가로 누적할 중간값이 있는 경우, 전자 장치 는 버퍼의 제3 주소값(#b-02, 125-2)에 저장된 누적값(i0w2+i1w1)을 메모리로 전송하지 않고, 버퍼의 제3 주소값(#b-02, 125-2)에 계속 저장할 수 있다. 한편, 전자 장치는 버퍼의 제1 주소값(125-0)에 저장된 중간값(i1w2) 역시 메모리로 바로 전송하지 않고 버퍼의 제1 주소값(125-0)에 계속 저장할 수 있다. 중간값(i1w2)에 대한 구체적인 설명은 누적값(i0w2+i1w1)과 동일하므로, 중복되는 설명을 생략한다. 표를 참조하면, 전자 장치는 제1 페이즈(600-1)의 1단계(600-1-1) 이후에 누적값(i0w1+i1w0)만을 메모리에 전송할 수 있고, 메모리는 누적값(i0w1+i1w0)을 누적값(i0w1+i1w0)에 대응되는 메모리의 주 소값(#m-01)에 저장할 수 있다. 그리고, 전자 장치는 메모리에 누적값(i0w1+i1w0)을 전송한 이후(또는, 메모리가 누적값(i0w1+i1w0) 을 저장하였다는 제어 신호를 수신한 이후) 버퍼의 제2 주소값(#b-01, 125-1)에 저장된 누적값(i0w1+i1w0) 및 누적값(i0w1+i1w0)에 대응되는 메모리 주소값(#m-01)을 버퍼의 제2 주소값((#b-01, 125-1)에서 삭제할 수 있다. 누적값(i0w1+i1w0)에 대응되는 메모리 주소값(#m-01)은 추가로 누적될 중간값이 없기 때문에 더 이상 버퍼에 저 장될 필요성이 없기 때문이다. 한편, 도 19 및 도 20에서는 버퍼의 주소값이 3개인 것을 가정하여 설명하였지만, 버퍼의 주소값은 구현 예에 따라 달라질 수 있다. 구체적으로, 버퍼의 주소값의 개수는 출력 데이터의 크기에 따라 상이할 수 있다. 출력 데이터의 크기에 기초하 여 컨벌루션 연산의 횟수가 결정될 수 있으므로, 전자 장치는 출력 데이터의 크기에 기초하여 최소 버퍼의 개수 또는 최소 버퍼의 주소값의 개수를 획득할 수 있다. 예를 들어, 5*5 크기의 출력 데이터에서 최소 버퍼는 10개일 수 있다. 도 21은 본 개시의 일 실시 예에 따른 하드웨어 다이어그램을 설명하기 위한 도면이다. 전자 장치는 DRAM, 제어 프로세서 및 연산 모듈을 포함할 수 있다. 전자 장치는 컨벌루션 연산과 디컨벌루션 연산을 모두 MAC(Multiply and Accumulate) Processing Array(MPA)에서 처리할 수 있다. 따라서, 연산 각각의 전용 하드웨어가 필요 없을 수 있다. 컨벌루션 연산 및 디컨벌루션 연산은 MAC Processing Array에서 처리될 수 있고, Non-linear 연산(ex: ReLU, Elementwise Sum 등)은 MAC Processing Array에서 처리한 결과를 이용하여 Post Processing Array(PPA)에서 처리될 수 있다. 한편, 전자 장치는 DMA(Direct Memory Access)를 통해 DRAM(External Memory)에 저장된 값을 읽어올 수 있다. DMA를 통해 불러오는(Read) 데이터는 Deep Neural Network 첫 layer의 입력 데이터, 중간 layer의 입력 데이터, 그리고 Weight 값일 수 있다. 또한, 전자 장치는 DMA를 통해 입력 데이터, 중간 결과 데이터(중간값), Filter 데이터를 외부 메모리 (DRAM)에서 읽을 수 있고 내부 메모리(On-chip Memory)인 Global Buffer에 저장할 수 있다. 또한, 전자 장치는 Input Buffer와 Weight Buffer를 이용하여 DMA를 통해 수신한 Global buffer에 저장된 데이터를 연산 유닛인 MAC Processing Array와 Post Processing Array에 전달할 수 있다. 또한, 전자 장치는 MAC Processing Array와 Post Processing Array에서 연산 동작이 끝난 데이터를 Output Buffer로 전송할 수 있으며, Output buffer는 해당 데이터를 Global Buffer에 저장할 수 있다. Global buffer에 저장된 데이터는 DMA를 통해 DRAM에 전송될 수 있다. 한편, 제어 프로세서는 연산에 필요한 정보 (입력/출력 Activation 크기, Kernel의 크기, Stride, 연산 종류 등)와 DMA동작과 관련한 정보(데이터 Address, 크기 등)에 기초하여 연산 모듈을 제어할 수 있다. 도 22는 입력 활성화(input activation)의 이동을 설명하기 위한 도면이다. 도 23은 가중치의 이동을 설명하기 위한 도면이다. 도 24는 MAC Processing Array의 동작을 설명하기 위한 도면이다. Mac Processing Array는 컨벌루션 연산 및 디컨벌루션 연산을 위한 MAC(Multiply and Accumulate) 연산 을 처리하는 MAC Processing Unit(MPU)가 1차원 행렬 형태로 이루어질 수 있다. 각각의 MPU에서는 Input Buffer로부터 Input Activation 데이터를 입력 받을 수 있고, Weight Buffer로부터 Weight 데이터를 입력 받을 수 있다. 여기서, Input Buffer에서 전송되는 데이터는 각각의 MPU에 공유될 수 있다. Weight Buffer로부터 오는 Weight 데이터는 MPU 마다 각기 다른 값일 수 있다. 1개의 MPU에 입력되는 Input Activation과 Weight를 나타내었다. 이때 Input Activation과 Weight의 Dimension 은 같을 수 있다. 예를 들어, Input Activation의 크기(x, y, z)가 100x100x64 라고 하면 총 100번에 걸쳐 1x1x64의 데이터가 MPA로 입력될 수 있다. 또한, 1개의 MPU에서 1개의 output이 생성되고, N개의 MPU가 Array를 이루고 있다고 가정하면, 총 N개의 output이 MPA에서 생성될 수 있다. 각각의 MPU는 서로 다른 Weight를 사용하므로 각각의 output은 Output Activation에서 Output channel에 해당할 수 있다. 도 25및 도 26은 MAC Processing Unit(MPU)의 단위 연산 동작을 설명하기 위한 도면이다. 1개의 MPU에서는 Input Activation을 Input Buffer로부터 1x1xIN_CH 형태로 입력 받을 수 있고, 1개의 Kernel(Filter)도 같은 크기인 1x1xIN_CH를 Weight Buffer로부터 입력 받을 수 있다. 입력 받은 2개의 데이터는 서로 위치에 해당하는 데이터와 서로 곱해질 수 있으며, 전자 장치는 출력 데이터를 획득 할 수 있다. 한편, IN_CH의 개수만큼의 곱셈 결과가 생성될 수 있으며 모든 곱셈 결과는 MPU 내부의 Adder Tree로 입력될 수 있다. Adder Tree에서는 입력되는 IN_CH 의 곱셈 결과를 모두 더한 1개의 Output을 생할 수 있다. MPU의 주요 연산인 곱셈과 덧셈이 위 과정을 통해 이루어 질 수 있다. Convolution의 경우 1x1xIN_CH * 1x1xIN_CH = 1x1x1 계산과 동일할 수 있다. 계산된 output은 MPA 내부에 저장공간 ACC(accumulator, 누산기)에 저장될 수 있다. 여 러 개의 결과를 저장할 수 있는 ACC에는 중간 결과값 partial sum이 저장될 수 있으며, 연산 종류, Kernel size, Stride에 따라 누적 횟수와 누적되는 위치가 정해질 수 있다. 이미 이전 연산으로 중간 결과값이 저장되 어 있다면 전자 장치는 새로 구한 중간 결과값과 더한 누적 값을 다시 저장할 수 있다. 여러 번의 누적으 로 최종 output이 ACC에 저장되면, 저장된 모든 최종 output은 Post Processing Array로 전달될 수 있으며, 전 자 장치는 Non-linear 연산을 수행할 수 있다. 도 27은 Post Processing Array의 동작을 설명하기 위한 도면이다. Post Processing Array 연산 유닛은 MAC 연산 후에 수행되는 연산(Non-linear layer)을 처리하는 부분일 수 있 다. MAC Processing Array에서 누적 값(Partial Sum)이 계산되기 때문에 컨벌루션 연산과 디컨벌루션 연산의 결 과물 모두 공통적으로 MAC Processing Array에 의해 수행될 수 있다. Post Processing Array 연산 유닛에서는 Non-linear 연산이 수행될 수 있으며, 대표적으로는 ReLU, Elementwise Sum 등이 있을 수 있다. MPA와 마찬가 지로 1개의 output channel에 해당하는 output을 연산하는 Post Processing Unit(PPU) 이 있을 수 있으며, 해 당 Unit을 병렬적으로 배치되어 Array형태를 이룰 수 있다. 따라서 MPA와 PPA의 Array 형태는 동일할 수 있다. 예를 들어, N개의 MPU로 이루어진 MPA에서는 N개의 Output이 병렬로 출력될 수 있으며, 마찬가지로 PPA또한 N개 의 입력을 받아 N개의 Output을 생성할 수 있다. 전자 장치는 Post Processing 연산까지 모두 마친 최종 Output을 Output Buffer로 전송할 수 있다. Output Buffer는 입력된 Output을 Control Processor가 설정한 Global Buffer의 Address로 쓰기 요청을 할 수 있다. 도 28은 컨벌루션 연산 또는 디컨벌루션 연산에 이용되는 수학식을 설명하기 위한 도면이다. 제1 수학식은 컨벌루션 연산의 중간값을 획득하는데 이용되는 수학식일 수 있다. O^*는 1x1xIN_CH의 MAC 연산으로 계산된 중간 결과 값일 수 있으며, I는 Input Activation일 수 있으며, W는 가중치(필터 데이터)일 수 있다. F_W는 필터의 가로 크기일 수 있으며, F_H는 필터의 높이 크기일 수 있다. [][]에 해당하는 부분은 좌표 정보일 수 있다. 예를 들어, [x+i][y+j], [x][y], [F_W-i][F_H-j]는 좌표 정보를 의미할 수 있다. 제2 수학식은 스트라이드가 2 이상인 경우 컨벌루션 연산의 중간값을 획득하는데 이용되는 수학식일 수 있다. 전자 장치는 O^*의 좌표[(x+i)/(STR_X)][(y+j)/(STR_Y)]가 정수일 경우에만 연산을 진행하여 ACC에 저장할 수 있다. 여기서, STR_X는 x축 방향의 스트라이드를 의미할 수 있고, STR_Y는 y축 방향의 스트라이드를 의미할 수 있다. 만약, O^*의 좌표[(x+i)/(STR_X)][(y+j)/(STR_Y)]가 정수가 아닌 경우, 전자 장치는 연 산 동작 및 ACC에 저장하는 동작을 수행하지 않을 수 있다. 결과적으로, 전자 장치는 Filter의 크기만큼 반복되어 누적하면 최종 Output을 획득할 수 있다. 제3 수학식은 디컨벌루션 연산 동작에서 이용되는 수학식일 수 있다. 구체적으로, 중간 결과값 (O^*[x+STR_X+i][y+STR_Y+j])은 Input Activation과 가중치의 곱셈 계산으로 획득될 수 있다. 도 29는 본 개시의 일 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 29를 참조하면, 본 개시의 일 실시 예에 따른 전자 장치의 제어 방법은 디컨벌루션(Deconvolution) 연산의 입력 데이터가 입력되면, 연산 정보를 획득하는 단계(S2905), 획득된 연산 정보에 기초하여, 출력 데이터의 크기를 획득하는 단계(S2910), 주소 생성 모듈을 이용하여, 출력 데이터의 크기에 대응되는 복수의 메모리 주소값을 획득하는 단계(S2915), 컨벌루션 연산 모듈을 이용하여, 연산 정보에 기초하여 컨벌루션 (Convolution) 연산을 수행하여 컨벌루션 연산 과정에서 중간값을 획득하는 단계(S2920), 주소 생성 모듈 을 이용하여, 획득된 복수의 메모리 주소값 중 획득된 중간값에 대응되는 메모리 주소값을 획득하는 단계 (S2925), 획득된 중간값을 중간값에 대응되는 메모리 주소값에 저장하는 단계(S2930), 누적 연산 모듈을 이용하여, 중간값에 대응되는 메모리 주소값에 기초하여 적어도 하나의 중간값을 누적하는 단계(S2935) 및 누적 된 적어도 하나의 중간값에 기초하여 입력 데이터에 대한 디컨벌루션 연산값을 획득하는 단계(S2940)를 포함할 수 있다. 여기서, 획득된 중간값을 중간값에 대응되는 메모리 주소값에 저장하는 단계(S2930)는 컨벌루션 연산 과정에서 획득되는 제1 중간값에 대응되는 제1 메모리 주소값에 기초하여 제1 중간값을 메모리에 저장할 수 있고, 컨벌루션 연산 과정에서 획득되는 제2 중간값에 대응되는 제2 메모리 주소값이 제1 메모리 주소값과 일치하면, 누적 연산 모듈을 이용하여 제1 중간값 및 제2 중간값을 누적하여 누적값을 획득할 수 있고, 획득된 누적 값을 제1 메모리 주소값에 기초하여 메모리에 저장할 수 있다. 여기서, 연산 정보는 입력 데이터의 크기, 디컨벌루션 연산에 이용되는 필터 데이터의 크기, 컨벌루션 연산에 이용되는 스트라이드의 크기 또는 제1 중간값에 대응되는 연산 순서 정보 중 적어도 하나를 포함할 수 있고, 획 득된 중간값에 대응되는 메모리 주소값을 획득하는 단계(S2925)는 주소 생성 모듈을 이용하여, 연산 정보 에 기초하여 제1 메모리 주소값을 획득할 수 있다. 여기서, 획득된 중간값에 대응되는 메모리 주소값을 획득하는 단계(S2925)는 제1 중간값에 대응되는 연산 순서 정보에 기초하여 획득된 복수의 메모리 주소값 중 획득된 제1 중간값에 대응되는 제1 메모리 주소값을 획득할 수 있다. 한편, 획득된 중간값을 중간값에 대응되는 메모리 주소값에 저장하는 단계(S2930)는 컨벌루션 연산 과정에서 획 득되는 제2 중간값에 대응되는 제2 메모리 주소값이 제1 메모리 주소값과 일치하지 않으면, 제2 중간값을 제2 메모리 주소값에 저장할 수 있다. 한편, 중간값을 획득하는 단계(S2920)는 입력 데이터를 디컨벌루션 연산에 이용되는 필터 데이터의 가로축 라인 에 포함된 복수의 가중치와 순차적으로 컨벌루션 연산하여 복수의 중간값을 획득할 수 있다. 여기서, 적어도 하나의 중간값을 누적하는 단계(S2935)는 누적 연산 모듈을 이용하여 복수의 중간값 중 적 어도 일부를 누적할 수 있고, 누적의 횟수는 연산 정보에 기초하여 결정될 수 있다. 한편, 획득된 중간값을 중간값에 대응되는 메모리 주소값에 저장하는 단계(S2930)는 중간값에 대응되는 내부 버 퍼의 주소값에 기초하여 중간값을 내부 버퍼에 저장할 수 있고, 중간값에 누적 연산될 추가 중간값이 있는지 식별할 수 있고, 추가 중간값이 없는 것으로 식별되면, 내부 버퍼에 저장된 중간값을 메모리 에 저장할 수 있다. 여기서, 제어 방법은 연산 정보에 기초하여 중간값이 저장될 내부 버퍼의 크기를 결정하는 단계를 더 포함할 수 있다. 한편, 획득된 디컨벌루션 연산값은 디컨벌루션 연산 모듈을 이용하지 않고 획득될 수 있다. 한편, 도 29와 같은 전자 장치의 제어 방법은 도 1의 구성을 가지는 전자 장치 상에서 실행될 수 있으며, 그 밖 의 구성을 가지는 전자 장치 상에서도 실행될 수 있다. 한편, 상술한 본 개시의 다양한 실시 예들에 따른 방법들은, 기존 전자 장치에 설치 가능한 어플리케이션 형태 로 구현될 수 있다. 또한, 상술한 본 개시의 다양한 실시 예들에 따른 방법들은, 기존 전자 장치에 대한 소프트웨어 업그레이드, 또 는 하드웨어 업그레이드 만으로도 구현될 수 있다. 또한, 상술한 본 개시의 다양한 실시 예들은 전자 장치에 구비된 임베디드 서버, 또는 전자 장치 및 디스플레이 장치 중 적어도 하나의 외부 서버를 통해 수행되는 것도 가능하다. 한편, 본 개시의 일시 예에 따르면, 이상에서 설명된 다양한 실시 예들은 기기(machine)(예: 컴퓨터)로 읽을 수 있는 저장 매체(machine-readable storage media에 저장된 명령어를 포함하는 소프트웨어로 구현될 수 있다. 기 기는, 저장 매체로부터 저장된 명령어를 호출하고, 호출된 명령어에 따라 동작이 가능한 장치로서, 개시된 실시예들에 따른 전자 장치(예: 전자 장치(A))를 포함할 수 있다. 명령이 프로세서에 의해 실행될 경우, 프로세서 가 직접, 또는 프로세서의 제어 하에 다른 구성요소들을 이용하여 명령에 해당하는 기능을 수행할 수 있다. 명 령은 컴파일러 또는 인터프리터에 의해 생성 또는 실행되는 코드를 포함할 수 있다. 기기로 읽을 수 있는 저장 매체는, 비일시적(non-transitory) 저장매체의 형태로 제공될 수 있다. 여기서, '비일시적'은 저장매체가 신호 (signal)를 포함하지 않으며 실재(tangible)한다는 것을 의미할 뿐 데이터가 저장매체에 반영구적 또는 임시적 으로 저장됨을 구분하지 않는다. 또한, 본 개시의 일 실시 예에 따르면, 이상에서 설명된 다양한 실시 예들에 따른 방법은 컴퓨터 프로그램 제품 (computer program product)에 포함되어 제공될 수 있다. 컴퓨터 프로그램 제품은 상품으로서 판매자 및 구매자 간에 거래될 수 있다. 컴퓨터 프로그램 제품은 기기로 읽을 수 있는 저장 매체(예: compact disc read only memory (CD-ROM))의 형태로, 또는 어플리케이션 스토어(예: 플레이 스토어TM)를 통해 온라인으로 배포될 수 있 다. 온라인 배포의 경우에, 컴퓨터 프로그램 제품의 적어도 일부는 제조사의 서버, 어플리케이션 스토어의 서버, 또는 중계 서버의 메모리와 같은 저장 매체에 적어도 일시 저장되거나, 임시적으로 생성될 수 있다. 또한, 상술한 다양한 실시 예들에 따른 구성 요소(예: 모듈 또는 프로그램) 각각은 단수 또는 복수의 개체로 구 성될 수 있으며, 전술한 해당 서브 구성 요소들 중 일부 서브 구성 요소가 생략되거나, 또는 다른 서브 구성 요 소가 다양한 실시 예에 더 포함될 수 있다. 대체적으로 또는 추가적으로, 일부 구성 요소들(예: 모듈 또는 프로 그램)은 하나의 개체로 통합되어, 통합되기 이전의 각각의 해당 구성 요소에 의해 수행되는 기능을 동일 또는 유사하게 수행할 수 있다. 다양한 실시 예들에 따른, 모듈, 프로그램 또는 다른 구성 요소에 의해 수행되는 동 작들은 순차적, 병렬적, 반복적 또는 휴리스틱하게 실행되거나, 적어도 일부 동작이 다른 순서로 실행되거나, 생략되거나, 또는 다른 동작이 추가될 수 있다. 이상에서는 본 개시의 바람직한 실시 예에 대하여 도시하고 설명하였지만, 본 개시는 상술한 특정의 실시 예에"}
{"patent_id": "10-2020-0016439", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "한정되지 아니하며, 청구범위에서 청구하는 본 개시의 요지를 벗어남이 없이 당해 개시에 속하는 기술분야에서 통상의 지식을 가진 자에 의해 다양한 변형 실시가 가능한 것은 물론이고, 이러한 변형실시들은 본 개시의 기술 적 사상이나 전망으로부터 개별적으로 이해되어져서는 안될 것이다."}
{"patent_id": "10-2020-0016439", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 개시의 일 실시 예에 따른 전자 장치를 도시한 블록도이다. 도 2는 일 실시 예에 따른 컨벌루션 연산 동작을 설명하기 위한 도면이다. 도 3은 도 2의 컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 4는 도 2의 컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 5는 도 2의 컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 6은 컨벌루션 연산과 디컨벌루션 연산을 설명하기 위한 도면이다. 도 7은 일 실시 예에 따른 디컨벌루션 연산 동작을 설명하기 위한 도면이다. 도 8은 도 7의 디컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 9는 도 7의 디컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 10은 도 7의 디컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다.도 11a는 도 7의 디컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 11b는 도 7의 디컨벌루션 연산 동작 중 일부 동작을 설명하기 위한 도면이다. 도 12는 스트라이드 크기에 기초하여 디컨벌루션 연산 동작을 수행하는 실시 예를 설명하기 위한 도면이다. 도 13은 본 개시의 일 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 14는 본 개시의 다른 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 15는 본 개시의 또 다른 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 16은 본 개시의 또 다른 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 17은 본 개시의 또 다른 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다. 도 18은 디컨벌루션 연산 동작에 대한 결과값을 메모리 주소에 할당하는 동작을 설명하기 위한 도면이다. 도 19는 디컨벌루션 연산 동작에서 획득되는 중간값을 버퍼 주소 및 메모리 주소에 할당하는 동작을 설명하기 위한 도면이다. 도 20은 디컨벌루션 연산 동작에서 획득되는 중간값을 버퍼 주소 및 메모리 주소에 할당하는 동작을 설명하기 위한 도면이다. 도 21은 본 개시의 일 실시 예에 따른 하드웨어 다이어그램을 설명하기 위한 도면이다. 도 22는 입력 활성화(input activation)의 이동을 설명하기 위한 도면이다. 도 23은 가중치의 이동을 설명하기 위한 도면이다. 도 24는 MAC Processing Array의 동작을 설명하기 위한 도면이다. 도 25는 MAC Processing Unit(MPU)의 단위 연산 동작을 설명하기 위한 도면이다. 도 26은 MAC Processing Unit(MPU)의 단위 연산 동작을 설명하기 위한 도면이다. 도 27은 Post Processing Array의 동작을 설명하기 위한 도면이다. 도 28은 컨벌루션 연산 또는 디컨벌루션 연산에 이용되는 수학식을 설명하기 위한 도면이다. 도 29는 본 개시의 일 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다."}
