{"patent_id": "10-2018-0127069", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2020-0045928", "출원번호": "10-2018-0127069", "발명의 명칭": "저전력 무선네트워크를 이용한 펌웨어 업데이트 방법", "출원인": "주식회사 시옷", "발명자": "박현주"}}
{"patent_id": "10-2018-0127069", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "업데이트 매니저 서버에서 펌웨어 업데이트의 대상이 되는 대상 단말기의 단말기 정보를 상기 제조사 서버로부터 수신받아 등록하는 단말기 등록 단계;상기 대상 단말기의 펌웨어 업데이트를 관리하는 플랫폼에서 저전력 무선네트워크를 이용하여 상기 대상 단말기의 펌웨어 버전 정보를 확인하는 펌웨어 버전 확인 단계;다운로드 서버에서 상기 제조사 서버로부터 업데이트용 펌웨어를 입력받아 상기 대상 단말기로 전송하기 위해패키징하는 펌웨어 패키징 단계;상기 대상 단말기에서 상기 다운로드 서버로부터 패키징된 펌웨어를 저전력 무선네트워크를 통해 다운로드 받는펌웨어 다운로드 단계; 및상기 대상 단말기에서 패키징된 펌웨어를 언패키징하여 펌웨어 업데이트를 수행하는 펌웨어 업데이트 단계를 포함하는, 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법."}
{"patent_id": "10-2018-0127069", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 단말기 등록 단계는, 상기 업데이트 매니저 서버가 상기 대상 단말기의 제조사 정보 및 상기 대상 단말기가 설치된 차량 단말 정보를 상기 제조사 서버로부터 수신받아 등록하는 단계; 상기 업데이트 매니저 서버가 등록되는 제조사 정보 및 차량 단말 정보를 데이터베이스에 저장하는 단계; 상기 플랫폼이 상기 업데이트 매니저서버로부터 제조사 정보 및 차량 단말 정보를 전달받아 등록하는 단계; 상기 업데이트 매니저 서버가 차량 단말정보에 대응하는 유니크 아이디인 토큰을 상기 플랫폼으로부터 전달받는 단계; 상기 업데이트 매니저 서버가 전달받은 토큰을 상기 제조사 서버로 전송하는 단계; 및 상기 대상 단말기가 상기 제조사 서버로부터 토큰을 입력받는 단계를 포함하며,상기 펌웨어 버전 확인 단계는, 상기 대상 단말기가 자신의 펌웨어 버전 정보를 주기적으로 상기 플랫폼으로 전송하는 단계; 및 상기 업데이트 매니저 서버가 상기 플랫폼으로 전송되는 상기 대상 단말기의 펌웨어 버전 정보를 확인하는 단계를 포함하며,상기 펌웨어 패키징 단계는, 상기 다운로드 서버가 상기 제조사 서버로부터 펌웨어를 입력받는 단계; 상기 다운로드 서버가 입력받은 펌웨어를 패키징하여 분할 및 보안이 적용된 전송용 펌웨어를 생성하는 단계; 상기 다운로드 서버가 생성된 전송용 펌웨어를 데이터베이스에 저장하는 단계; 상기 다운로드 서버가 생성된 전송용 펌웨어의 펌웨어 다운로드 디렉토리(URL)를 상기 업데이트 매니저 서버로 업로드하는 단계; 상기 업데이트 매니저서버가 펌웨어 업데이트 알림(Notice)을 생성하는 단계; 상기 업데이트 매니저 서버가 생성된 펌웨어 업데이트알림을 상기 플랫폼으로 전달하는 단계; 상기 플랫폼이 전달받은 펌웨어 업데이트 알림을 상기 대상 단말기로전송하는 단계; 및 상기 업데이트 매니저 서버가 펌웨어 업데이트 알림의 전송 결과를 상기 제조사 서버로 전송하는 단계를 포함하며,상기 펌웨어 다운로드 단계는, 상기 대상 단말기가 상기 다운로드 서버로부터 전송용 펌웨어를 다운로드 받는단계; 상기 대상 단말기가 다운로드 결과를 상기 플랫폼으로 전송하는 단계; 상기 업데이트 매니저 서버가 상기플랫폼을 통해 다운로드 결과를 확인하는 단계; 및 상기 업데이트 매니저 서버가 다운로드 결과를 상기 제조사서버로 전송하는 단계를 포함하며, 상기 펌웨어 업데이트 단계는, 상기 대상 단말기가 수신받은 수신용 펌웨어를 언패키징하여 펌웨어 업데이트를준비하는 단계; 업데이트의 준비가 완료되면, 상기 대상 단말기가 펌웨어 업데이트를 수행하는 단계; 상기 대상단말기가 펌웨어 업데이트의 결과를 상기 플랫폼으로 전송하는 단계; 상기 업데이트 매니저 서버가 상기 플랫폼을 통해 펌웨어 업데이트의 결과를 확인하는 단계; 및 상기 업데이트 매니저 서버가 펌웨어 업데이트의 결과를공개특허 10-2020-0045928-3-상기 제조사 서버로 전송하는 단계를 포함하는, 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법."}
{"patent_id": "10-2018-0127069", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법에 관한 것으로, 더욱 상세하게는 네비게이션과 같이 자동차에 장착되는 단말기의 펌웨어를 저전력 무선네트워크를 이용하여 무선으로 업그레이드할 수 있도록 구현한 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법에 관한 것이다."}
{"patent_id": "10-2018-0127069", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법에 관한 것으로, 더욱 상세하게는 네비게이션과 같이 자동차에 장착되는 단말기의 펌웨어를 저전력 무선네트워크를 이용하여 무선으로 업그레이드할 수 있도록 구현한 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법에 관한 것이다."}
{"patent_id": "10-2018-0127069", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "무선통신 기술이 발달하면서 사용자 편의를 위한 다양한 서비스와 기능이 포함된 단말기가 제공되고 있다. 이와 같이 다양한 서비스와 기능이 추가됨으로 인해 이동 단말기에 탑재되는 소프트웨어 또한 많은 버그가 발생할 확 률이 높아지고, 이동단말기의 출시 이후에 새로운 기능의 추가에 대한 요구가 갈수록 더해지고 있다. 이에 따라, 이동단말기의 펌웨어(Firmware)를 무선으로 자동 업그레이드하는 솔루션인 FOTA(Firmware Over The Air)가 개발되었다. 여기서, 펌웨어는 일반적으로 롬(ROM)에 저장된 하드웨어를 제어하는 마이크로 프로그램을 의미하며, 프로그램이라는 관점에서는 소프트웨어와 동일하지만 하드웨어와 밀접한 관계를 가지고 있다는 점에 서 일반 응용소프트웨어와 구분되어 펌웨어는 소프트웨어와 하드웨어의 특성을 동시에 가진다. 국제 모바일 규격 표준화 단체인 OMA(Open Mobile Alliance)에서 제정된 FOTA와 관련된 표준을 참조하면, 이동 단말기의 FOTA 서비스 수행과정은 DM(Device Management) 서버로부터 통지(Notification) 메시지를 수신하는 과정과, DM 서버와 이동통신단말기 간의 통신 수행 과정인 디스커버리(discovery) 과정, 업데이트 패키지의 다 운로드 과정을 포함한다. 그러므로, FOTA 서비스는 사용자가 A/S 센터에 방문하지 않고 이동단말기의 수정된 프로그램을 무선으로 다운받 아 바로 업데이트 할 수 있는 장점을 가진다. 한편, M2M(Machine to Machine)은 일반적인 유/무선 네트워크상에서 일련의 유저 트래픽 데이터를 유/무선 통신 방식을 이용하여 M2M 모듈과 디바이스가 연동하여 기계간의 통신을 지원하는 원격관리 및 제어 솔루션이다. 그 리고, M2M 모듈 및 그에 연결되는 디바이스의 성능개선, 오류 수정 등의 이유로 NV(Non Volatile) 설정값, 펌웨 어, 드라이버 및 응용 어플리케이션 등의 다양한 프로그램 업데이트가 요구된다. 그러나, 각각의 프로그램을 업 데이트한다 하더라도 각각 업데이트 프로그램을 버전별로 관리함으로써 어느 하나를 업데이트 하지 않았을 경우 오류가 발생하거나 향상된 서비스를 이용할 수 없는 문제점이 있다. 선행기술문헌 특허문헌 (특허문헌 0001) 한국등록특허 제10-1541112호 (특허문헌 0002) 한국공개특허 제10-2009-0004715호"}
{"patent_id": "10-2018-0127069", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명의 일측면은 네비게이션과 같이 자동차에 장착되는 단말기의 펌웨어를 저전력 무선네트워크를 이용하여 무선으로 업그레이드할 수 있도록 구현한 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법을 제공한다. 또한, 펌웨어 파일을 복수 개로 분할함으로써, FOTA(Firmware Over The Air) 대상 단말기의 성능이 우수하지 않 더라고 제조사에서 제공하는 펌웨어를 전송받을 수 있도록 구현한 저전력 무선네트워크를 이용한 펌웨어 업데이 트 방법을 제공한다.본 발명의 기술적 과제는 이상에서 언급한 기술적 과제로 제한되지 않으며, 언급되지 않은 또 다른 기술적 과제 들은 아래의 기재로부터 당업자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2018-0127069", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 일 실시예에 따른 펌웨어 패키징 및 언패키징 방법은 다운로드 서버가 제조사 서버로부터 입력되는 펌웨어를 다수 개의 블록으로 분할하는 단계; 및 상기 다운로드 서버가 분할된 블록들을 암호화하는 단계를 포 함하며, 상기 분할하는 단계에서 분할된 블록은, 펌웨어 명칭 및 펌웨어 버전을 포함하는 퍼스트 블록, 상기 퍼 스트 블록의 다음에 순서에 따라 배치되며, 펌웨어 데이터의 일부가 각각 할당되어 전체로서 하나의 펌웨어 데 이터를 형성하는 다수 개의 펌웨어 블록 및 마지막 펌웨어 블록 다음에 배치되어 패키징의 종료를 알리는 라스 트 블록으로 구성되며, 상기 암호화하는 단계는, 상기 펌웨어 블록을 헤더(Header)와 바디(Body)로 구분하고, 상기 헤더에는 펌웨어 데이터를 해쉬함수의 입력으로 했을 때의 출력값 또는 펌웨어 데이터를 해쉬함수의 입력 으로 했을 때의 출력값을 입력으로 대입한 사인값(Sign)을 입력하고, 상기 바디에는 펌웨어 데이터를 암호화한 값을 입력으로 한다. 일 실시예에 있어서, 상기 다운로드 서버와 통신하는 대상 단말기가 상기 퍼스트 블록을 복호한 후, 상기 퍼스 트 블록에 포함된 인포값(info)을 통해 상기 대상 단말기의 펌웨어 업데이트가 필요한지를 판독하고, 펌웨어 업 데이트가 필요한 경우 사인과 해쉬가 해제된 인포값과 상기 퍼스트 블록에 기 포함되어 있던 인포값을 비교하는 버전 확인 단계; 및 상기 대상 단말기가 상기 버전 확인 단계에서 버전 확인이 완료되면, 상기 펌웨어 블록들을 다운로드 받아 복호화한 후, 사인이 해제된 펌웨어 데이터의 해쉬값과 상기 펌웨어 블록에 기 포함되어 있던 펌 웨어 데이터의 해쉬값을 비교하여 같은 경우 분할된 각각의 펌웨어 데이터들을 병합하는 데이터 병합 단계를 포 함한다. 본 발명의 일 실시예에 따른 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법은, 업데이트 매니저 서버에서 펌웨어 업데이트의 대상이 되는 대상 단말기의 단말기 정보를 상기 제조사 서버로부터 수신받아 등록하는 단말 기 등록 단계; 상기 대상 단말기의 펌웨어 업데이트를 관리하는 플랫폼에서 저전력 무선네트워크를 이용하여 상 기 대상 단말기의 펌웨어 버전 정보를 확인하는 펌웨어 버전 확인 단계; 다운로드 서버에서 상기 제조사 서버로 부터 업데이트용 펌웨어를 입력받아 상기 대상 단말기로 전송하기 위해 패키징하는 펌웨어 패키징 단계; 상기 대상 단말기에서 상기 다운로드 서버로부터 패키징된 펌웨어를 저전력 무선네트워크를 통해 다운로드 받는 펌웨 어 다운로드 단계; 및 상기 대상 단말기에서 패키징된 펌웨어를 언패키징하여 펌웨어 업데이트를 수행하는 펌웨 어 업데이트 단계를 포함한다. 일 실시예에서, 상기 단말기 등록 단계는, 상기 업데이트 매니저 서버가 상기 대상 단말기의 제조사 정보 및 상 기 대상 단말기가 설치된 차량 단말 정보를 상기 제조사 서버로부터 수신받아 등록하는 단계; 상기 업데이트 매 니저 서버가 등록되는 제조사 정보 및 차량 단말 정보를 데이터베이스에 저장하는 단계; 상기 플랫폼이 상기 업 데이트 매니저 서버로부터 제조사 정보 및 차량 단말 정보를 전달받아 등록하는 단계; 상기 업데이트 매니저 서 버가 차량 단말 정보에 대응하는 유니크 아이디인 토큰을 상기 플랫폼으로부터 전달받는 단계; 상기 업데이트 매니저 서버가 전달받은 토큰을 상기 제조사 서버로 전송하는 단계; 및 상기 대상 단말기가 상기 제조사 서버로 부터 토큰을 입력받는 단계를 포함하며, 상기 펌웨어 버전 확인 단계는, 상기 대상 단말기가 자신의 펌웨어 버 전 정보를 주기적으로 상기 플랫폼으로 전송하는 단계; 및 상기 업데이트 매니저 서버가 상기 플랫폼으로 전송 되는 상기 대상 단말기의 펌웨어 버전 정보를 확인하는 단계를 포함하며, 상기 펌웨어 패키징 단계는, 상기 다 운로드 서버가 상기 제조사 서버로부터 펌웨어를 입력받는 단계; 상기 다운로드 서버가 입력받은 펌웨어를 패키 징하여 분할 및 보안이 적용된 전송 펌웨어를 생성하는 단계; 상기 다운로드 서버가 생성된 전송 펌웨어를 데이 터베이스에 저장하는 단계; 상기 다운로드 서버가 생성된 전송 펌웨어의 펌웨어 다운로드 디렉토리(URL)를 상기 업데이트 매니저 서버로 업로드하는 단계; 상기 업데이트 매니저 서버가 펌웨어 업데이트 알림(Notice)을 생성 하는 단계; 상기 업데이트 매니저 서버가 생성된 펌웨어 업데이트 알림을 상기 플랫폼으로 전달하는 단계; 상기 플랫폼이 전달받은 펌웨어 업데이트 알림을 상기 대상 단말기로 전송하는 단계; 및 상기 업데이트 매니저 서버 가 펌웨어 업데이트 알림의 전송 결과를 상기 제조사 서버로 전송하는 단계를 포함하며, 상기 펌웨어 다운로드 단계는, 상기 대상 단말기가 상기 다운로드 서버로부터 전송용 펌웨어를 다운로드 받는 단계; 상기 대상 단말기 가 다운로드 결과를 상기 플랫폼으로 전송하는 단계; 상기 업데이트 매니저 서버가 상기 플랫폼을 통해 다운로 드 결과를 확인하는 단계; 및 상기 업데이트 매니저 서버가 다운로드 결과를 상기 제조사 서버로 전송하는 단계 를 포함하며, 상기 펌웨어 업데이트 단계는, 상기 대상 단말기가 수신받은 수신용 펌웨어를 언패키징하여 펌웨 어 업데이트를 준비하는 단계; 업데이트의 준비가 완료되면, 상기 대상 단말기가 펌웨어 업데이트를 수행하는단계; 상기 대상 단말기가 펌웨어 업데이트의 결과를 상기 플랫폼으로 전송하는 단계; 상기 업데이트 매니저 서 버가 상기 플랫폼을 통해 펌웨어 업데이트의 결과를 확인하는 단계; 및 상기 업데이트 매니저 서버가 펌웨어 업 데이트의 결과를 상기 제조사 서버로 전송하는 단계를 포함할 수 있다. 일 실시예에서, 상기 전송용 펌웨어를 생성하는 단계는, 상기 제조사 서버로부터 입력되는 펌웨어를 다수 개의 블록으로 분할하는 단계; 및 분할된 블록들을 암호화하는 단계를 포함하며, 상기 분할하는 단계에서 분할된 블 록은, 펌웨어 명칭 및 펌웨어 버전을 포함하는 퍼스트 블록, 상기 퍼스트 블록의 다음에 순서에 따라 배치되며, 펌웨어 데이터의 일부가 각각 할당되어 전체로서 하나의 펌웨어 데이터를 형성하는 다수 개의 펌웨어 블록 및 마지막 펌웨어 블록 다음에 배치되어 패키징의 종료를 알리는 라스트 블록으로 구성되며, 상기 암호화하는 단계 는, 상기 펌웨어 블록을 헤더(Header)와 바디(Body)로 구분하고, 상기 헤더에는 펌웨어 데이터를 해쉬함수의 입 력으로 했을 때의 출력값 또는 펌웨어 데이터를 해쉬함수의 입력으로 했을 때의 출력값을 입력으로 대입한 사인 값(Sign)을 입력하고, 상기 바디에는 펌웨어 데이터를 암호화한 값을 입력으로 할 수 있다. 일 실시예에서, 상기 업데이트를 준비하는 단계는, 상기 퍼스트 블록을 복호한 후, 상기 퍼스트 블록에 포함된 인포값(info)을 통해 상기 대상 단말기의 펌웨어 업데이트가 필요한지를 판독하고, 펌웨어 업데이트가 필요한 경우 사인과 해쉬가 해제된 인포값과 상기 퍼스트 블록에 기 포함되어 있던 인포값을 비교하는 버전 확인 단계; 및 상기 버전 확인 단계에서 버전 확인이 완료되면, 상기 펌웨어 블록들을 다운로드 받아 복호화한 후, 사인이 해제된 펌웨어 데이터의 해쉬값과 상기 펌웨어 블록에 기 포함되어 있던 펌웨어 데이터의 해쉬값을 비교하여 같 은 경우 분할된 각각의 펌웨어 데이터들을 병합하는 데이터 병합 단계를 포함하며, 상기 펌웨어 업데이트를 수 행하는 단계는, 상기 라스트 블록에 대한 복호화까지 완료되면 병합된 펌웨어 데이터를 이용하여 펌웨어 업데이 트를 수행할 수 있다."}
{"patent_id": "10-2018-0127069", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "상술한 본 발명의 일측면에 따르면, 저전력 무선네트워크를 이용하여 펌웨어 업데이트를 수행할 수 있도록 함으 로써, 제조사에서 제공하는 펌웨어를 분할하여 FOTA 대상 단말기로 전송함에 따라, 저전력 무선네트워크 상황이 나, FOTA 대상 단말기의 성능이 우수하지 않다고 하더라도 제조사에서 제공하는 펌웨어를 부담없이 전송받도록 할 수 있다."}
{"patent_id": "10-2018-0127069", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "후술하는 본 발명에 대한 상세한 설명은, 본 발명이 실시될 수 있는 특정 실시예를 예시로서 도시하는 첨부 도 면을 참조한다. 이들 실시예는 당업자가 본 발명을 실시할 수 있기에 충분하도록 상세히 설명된다. 본 발명의 다양한 실시예는 서로 다르지만 상호 배타적일 필요는 없음이 이해되어야 한다. 예를 들어, 여기에 기재되어 있 는 특정 형상, 구조 및 특성은 일 실시예와 관련하여 본 발명의 정신 및 범위를 벗어나지 않으면서 다른 실시예 로 구현될 수 있다. 또한, 각각의 개시된 실시예 내의 개별 구성요소의 위치 또는 배치는 본 발명의 정신 및 범 위를 벗어나지 않으면서 변경될 수 있음이 이해되어야 한다. 따라서, 후술하는 상세한 설명은 한정적인 의미로서 취하려는 것이 아니며, 본 발명의 범위는, 적절하게 설명된다면, 그 청구항들이 주장하는 것과 균등한 모든 범위와 더불어 첨부된 청구항에 의해서만 한정된다. 도면에서 유사한 참조부호는 여러 측면에 걸쳐서 동일하거 나 유사한 기능을 지칭한다. 이하, 도면들을 참조하여 본 발명의 바람직한 실시예들을 보다 상세하게 설명하기로 한다. 도 1은 업데이트 본 발명의 매니저 서버, 다운로드 서버, 플랫폼, 대상 단말기 및 제조사 서버의 관계를 설명하 는 도면이다. 도 1에서 네트워크라 함은, 저전력 무선네트워크로서, LTE Cat m.1 등이 이에 해당할 수 있다. 본 발명의 일 실시예에 따른 펌웨어 패키징 및 언패키징 방법은 다운로드 서버가 제조사 서버로부터 입력되는 펌웨어를 다수 개의 블록으로 분할하는 단계; 및 상기 다운로드 서버가 분할된 블록들을 암호화하는 단계를 포 함하며, 상기 분할하는 단계에서 분할된 블록은, 펌웨어 명칭 및 펌웨어 버전을 포함하는 퍼스트 블록, 상기 퍼 스트 블록의 다음에 순서에 따라 배치되며, 펌웨어 데이터의 일부가 각각 할당되어 전체로서 하나의 펌웨어 데 이터를 형성하는 다수 개의 펌웨어 블록 및 마지막 펌웨어 블록 다음에 배치되어 패키징의 종료를 알리는 라스 트 블록으로 구성되며, 상기 암호화하는 단계는, 상기 펌웨어 블록을 헤더(Header)와 바디(Body)로 구분하고, 상기 헤더에는 펌웨어 데이터를 해쉬함수의 입력으로 했을 때의 출력값 또는 펌웨어 데이터를 해쉬함수의 입력 으로 했을 때의 출력값을 입력으로 대입한 사인값(Sign)을 입력하고, 상기 바디에는 펌웨어 데이터를 암호화한 값을 입력으로 한다. 일 실시예에 있어서, 상기 다운로드 서버와 통신하는 대상 단말기가 상기 퍼스트 블록을 복호한 후, 상기 퍼스 트 블록에 포함된 인포값(info)을 통해 상기 대상 단말기의 펌웨어 업데이트가 필요한지를 판독하고, 펌웨어 업 데이트가 필요한 경우 사인과 해쉬가 해제된 인포값과 상기 퍼스트 블록에 기 포함되어 있던 인포값을 비교하는 버전 확인 단계; 및 상기 대상 단말기가 상기 버전 확인 단계에서 버전 확인이 완료되면, 상기 펌웨어 블록들을 다운로드 받아 복호화한 후, 사인이 해제된 펌웨어 데이터의 해쉬값과 상기 펌웨어 블록에 기 포함되어 있던 펌 웨어 데이터의 해쉬값을 비교하여 같은 경우 분할된 각각의 펌웨어 데이터들을 병합하는 데이터 병합 단계를 포 함한다. 펌웨어 패키징 및 언패키징 방법은 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법의 전송용 펌웨어를 생 성하는 단계 및 업데이트를 준비하는 단계에 대응될 수 있음은 자명하다. 도 2는 본 발명의 일 실시예에 따른 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법을 설명하는 도면이다. 도 2를 참조하면, 본 발명의 일 실시예에 따른 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법은, 우선 업 데이트 매니저 서버에서 펌웨어 업데이트의 대상이 되는 대상 단말기의 단말기 정보를 제조사 서버 로부터 수신받아 등록한다(S110). 여기서, 대상 단말기라 함은, 네비게이션 등과 같이 차량에 장착되는 장치로서, 정기적 또는 비정기적으로 펌웨어 업데이트가 필요한 장치로서, 예를 들어, 스마트카의 V2X(vehicle to everything) 인포테이먼트 디바이 스 등이 이에 해당할 수 있다. 이에 따라, 대상 단말기은, 통신 기능(예를 들어, Cat m.1), F/W 다운로드 클라이언트 매니저, 업데이트 인증, 단말 인증, Secure FOTA 언패키징 API, Core Crypto 및 부트로더 등의 기능을 수행하여야 할 것이다 도 3을 참조하면, 단말기 등록 단계(S110)는, 업데이트 매니저 서버가 대상 단말기의 제조사 정보 및 대상 단말기가 설치된 차량 단말 정보(즉, 모델 정보)를 제조사 서버로부터 수신받아 등록하는 단계 (S111), 업데이트 매니저 서버가 등록되는 제조사 정보 및 차량 단말 정보를 데이터베이스에 저장하는 단 계(S112), 플랫폼이 업데이트 매니저 서버로부터 제조사 정보 및 차량 단말 정보를 전달받아 등록하 는 단계(S113), 업데이트 매니저 서버가 차량 단말 정보에 대응하는 유니크 아이디인 토큰을 플랫폼 으로부터 전달받는 단계(S114), 업데이트 매니저 서버가 전달받은 토큰을 제조사 서버로 전송하는 단 계(S115) 및 대상 단말기가 제조사 서버로부터 토큰을 입력받는 단계(S116)를 포함할 수 있다. 대상 단말기의 펌웨어 업데이트를 관리하는 플랫폼에서 저전력 무선네트워크(예를 들어, LTE Cat.M 1)를 이용하여 대상 단말기의 펌웨어 버전 정보를 확인한다(S120). 이때, 플랫폼은, 업데이트 매니저 서버와 REST(Representational State ransfer) API를 통하여 데이 터를 송수신할 수 있다.도 4를 참조하면, 펌웨어 버전 확인 단계(S120)는, 우선 대상 단말기가 자신의 펌웨어 버전 정보를 주기적 으로 플랫폼으로 전송하는 단계(S121)를 수행할 수 있다. 일 실시예에서, 대상 단말기가 펌웨어 버전 정보 이에 추가하여 플랫폼으로 전송하는 정보로는 다음 의 표 1과 같다. 표 1"}
{"patent_id": "10-2018-0127069", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "표 1에서, 주기 보고 및 속성 보고는 대상 단말기가 플랫폼으로 전송하는 정보들로서, 주기 보고는 분 단위 이상의 일정 간격으로 보고하는 정보로 구체적으로 주기 보고는 5분에 1번 정도로 보고하는 정보이고, 속성 보고는 24시간에 1번 정도로 보고하는 정보로서, 이때, 상술한 대상 단말기가 플랫폼으로 전송 하는 펌웨어 버전 정보는 속성 보고 중\"attfwVer, string, 펌웨어버전\"이다. 상술한 단계 S121이후에, 업데이트 매니저 서버가 상술한 단계 S121에서 플랫폼으로 전송되는 대상 단말기의 펌웨어 버전 정보를 확인하는 단계(S122)를 수행하게 된다. 다운로드 서버에서 제조사 서버로부터 업데이트용 펌웨어를 입력받아 대상 단말기로 전송하기 위해 패키징한다(S130). 도 5를 참조하면, 펌웨어 패키징 단계(S130)는, 다운로드 서버가 제조사 서버로부터 펌웨어를 입력받 는 단계(S131), 다운로드 서버가 입력받은 펌웨어를 패키징(여기서, 전송용 펌웨어를 생성하는 패키징이라 함은, 펌웨어 파일을 분할하고 분할 적용하는 것을 의미함)하여 분할 및 보안이 적용된 전송용 펌웨어를 생성하 는 단계(S132), 다운로드 서버가 생성된 전송용 펌웨어를 데이터베이스에 저장하는 단계(S133), 다운로드 서버가 생성된 전송용 펌웨어의 펌웨어 다운로드 디렉토리(URL)를 업데이트 매니저 서버로 업로드하 는 단계(S134), 업데이트 매니저 서버가 펌웨어 업데이트 알림(Notice)을 생성하는 단계(S135), 업데이트 매니저 서버가 생성된 펌웨어 업데이트 알림을 플랫폼으로 전달하는 단계(S136), 플랫폼이 전달 받은 펌웨어 업데이트 알림을 대상 단말기로 전송하는 단계(S137) 및 업데이트 매니저 서버가 펌웨어 업데이트 알림의 전송 결과를 제조사 서버로 전송하는 단계(S137)를 포함할 수 있다. 이때, 플랫폼이 대상 단말기로 전송하는 펌웨어 업데이트 알림에 포함되는 정보는 다음의 표 2와 같 다. 표 2"}
{"patent_id": "10-2018-0127069", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "표 2에서, FOTA 주소는, 상술한 펌웨어를 생성하는 단계(S132)에서 생성하는 URL이고, 펌웨어 파일 개수는 분할 된 파일의 개수를 의미한다. 기존에는 유선으로 FOTA 대상이 되는 단말기의 펌웨어를 업데이트 하지만, 본 발명에서는 저전력의 무선 네트워 크를 이용하여 업데이트를 수행하고, 시스템 자체를 저렴하게 구현하기 위해 저성능 FOTA 대상 단말기를 대상으 로 한다. 이에 따라, 본 발명에 따른 펌웨어 패키징 단계(S130)에 의해, 저전력 상황이나, FOTA의 대상 단말기의 성 능이 우수하지 않다고 하더라도 제조사에서 제공한 펌웨어를 부담 없이 전송할 수 있다. 일 실시예에서, 전송용 펌웨어를 생성하는 단계(S132)는, 먼저 제조사 서버로부터 입력되는 펌웨어를 다수 개의 블록으로 분할할 후, 분할된 블록들을 암호화할 수 있다. 기존의 업데이트용 펌웨어는, Sign(H(펌웨어)), 펌웨어 명칭, 펌웨어 버전, Sign key(제조사 개인키)를 포함하 는 헤더(Header)와 Encrypt(펌웨어), 암호화 key(Seed 키값에서 derivation)을 포함하는 바디(Body)로 구성됨 에 따라 네트워크를 통해 전송 부담을 증가시킬 뿐만 아니라, 이를 전송받는 단말기로서도 다운로드 및 실행에 부담이 가중될 수 있다는 단점을 가지고 있었다. 이에 따라, 본 발명에서는, 펌웨어를 다수 개의 블록들로 분할하고 각 블록들을 암호화시켜 전송함으로써, FOTA(Firmware Over The Air) 대상 단말기의 성능이 우수하지 않더라고 제조사에서 제공하는 펌웨어를 전 송받을 수 있다. 여기서, 전송용 펌웨어를 생성하는 단계(S132)의 분할하는 단계에서 분할된 블록은, 펌웨어 명칭 및 펌웨어 버 전을 포함하는 퍼스트 블록, 퍼스트 블록의 다음에 순서에 따라 배치되며, 펌웨어 데이터의 일부가 각각 할당되 어 전체로서 하나의 펌웨어 데이터를 형성하는 다수 개의 펌웨어 블록 및 마지막 펌웨어 블록 다음에 배치되어 패키징의 종료를 알리는 라스트 블록으로 구성될 수 있다. 이때, 각각의 펌웨어 블록의 사이즈는 무선네트워크에 따라 달라진다. 상기 펌웨어 블록의 사이즈는 구체적으 로 4KB일 수 있다. 다음으로, 전송용 펌웨어를 생성하는 단계(S132)의 암호화하는 단계에서는, 펌웨어 블록을 헤더(Header)와 바디 (Body)로 구분하고, 헤더에는 펌웨어 데이터를 해쉬함수의 입력으로 했을 때의 출력값 또는 펌웨어 데이터를 해 쉬함수의 입력으로 했을 때의 출력값을 입력으로 대입한 사인값(Sign)을 입력하고, 바디에는 펌웨어 데이터를 암호화한 값을 입력으로 할 수 있다. 즉, 각각의 펌웨어 블록은, 하나의 헤더와 하나의 바디로 구성되게 된다. 도 6은 도 5의 전송용 펌웨어를 생성하는 단계(S132)에 의한 분할 및 보안이 적용된 전송용 펌웨어의 생성을 설 명하는 도면이다. 도 6을 참조하면, 퍼스트 블록에는 \"info\"와 \"Sign(H(Info))\"가 암호화된 데이터(즉, Encrypted )가 저장되고, 각각의 펌웨어 블록에는 \"펌웨어 명칭\", \"펌웨어 데이터를 해쉬함수의 입력으로 했 을 때의 출력값\"과 \"펌웨어 데이터를 해쉬함수의 입력으로 했을 때의 출력값을 입력으로 대입한 사인값(Sign)\" 가 암호화된 데이터(즉, Encrypted 내지 Encrypted )가 저장되고, 라스트 불록에는 \"H(F/W)\"와 \"Sign(H(FW))\"가 암호화된 데이터(즉, Encrypted )가 저장된다. 여기서, \"펌웨어 데이터를 해쉬함수의 입력으로 했을 때의 출력값을 입력으로 대입한 사인값(Sign)\"은 선택 사 항으로서, 즉, 본 발명에 펌웨어 블록에는 펌웨어를 해쉬한 후 사인하는 경우와 펌웨어를 해쉬만 하는 경우 모 두 포함될 수 있다. 대상 단말기에서 다운로드 서버로부터 패키징된 펌웨어를 저전력 무선네트워크(예를 들어, LTE Cat.M1)를 통해 다운로드 받는다(S140). 도 7을 참조하면, 펌웨어 다운로드 단계(S140)는, 대상 단말기가 다운로드 서버로부터 전송용 펌웨어 를 다운로드 받는 단계(S141), 대상 단말기가 다운로드 결과를 플랫폼으로 전송하는 단계(S142), 업 데이트 매니저 서버가 플랫폼을 통해 다운로드 결과를 확인하는 단계(S143) 및 업데이트 매니저 서버 가 다운로드 결과를 제조사 서버로 전송하는 단계(S144)를 포함할 수 있다.이때, 펌웨어 다운로드는, RPC(Remote Procedure Call) 프로토콜을 특정 시간 예를 들면, 전송받은 익일 새벽 4 시에 자동으로 실시되며, 펌웨어 다운로드는 차량 주행이 끝났을 때 실시되며, 만약 다운로드가 정상적으로 완 료되지 않았을 경우에는 기존에 다운로드 받은 파일에 대해서 무시하고, 새롭게 다시 파일 다운로드를 시작하되, 만약 3회 이상 다운로드 실패 시에는 별도로 이슈를 관리한다. 대상 단말기에서 패키징된 펌웨어를 언패키징하여 펌웨어 업데이트를 수행한다(S150). 도 8을 참조하면, 펌웨어 업데이트 단계(S150)는, 대상 단말기가 수신받은 수신용 펌웨어를 언패키징하여 펌웨어 업데이트를 준비하는 단계(S151), 업데이트의 준비가 완료되면, 대상 단말기가 펌웨어 업데이트를 수행하는 단계(S152), 대상 단말기가 펌웨어 업데이트의 결과를 플랫폼으로 전송하는 단계(S153), 업 데이트 매니저 서버가 플랫폼을 통해 펌웨어 업데이트의 결과를 확인하는 단계(S154) 및 업데이트 매 니저 서버가 펌웨어 업데이트의 결과를 제조사 서버로 전송하는 단계(S155)를 포함할 수 있다. 이때, 차량의 시동이 꺼질 때 펌웨어 업데이트 여부를 확인하고 업데이트를 진행하게 되며, 펌웨어 언패키징과 동시에 언패키징된 펌웨어는 메모리에 올라간다. 일 실시예에서, 업데이트를 준비하는 단계(S151)는, 퍼스트 블록을 복호한 후, 퍼스트 블록에 포함된 인포값 (info)을 통해 대상 단말기의 펌웨어 업데이트가 필요한지를 판독하고, 펌웨어 업데이트가 필요한 경우 사 인과 해쉬가 해제된 인포값과 퍼스트 블록에 기 포함되어 있던 인포값을 비교하는 버전 확인한 후, 버전 확인이 완료되면, 펌웨어 블록들을 다운로드 받아 복호화한 후, 사인이 해제된 펌웨어 데이터의 해쉬값과 펌웨어 블록 에 기 포함되어 있던 펌웨어 데이터의 해쉬값을 비교하여 같은 경우 분할된 각각의 펌웨어 데이터들을 병합할 수 있다. 그리고, 펌웨어 업데이트를 수행하는 단계(S152)는, 라스트 블록에 대한 복호화까지 완료되면 병합된 펌웨어 데 이터를 이용하여 펌웨어 업데이트를 수행할 수 있다. 본 발명에 따른, 각각의 서버들은, 통신기능(예를 들어, Cat m.1) F/W 업로드 매니저, F/W 서비스 웹 기반 UI, 펌웨어 관리(버전, F/W), Secure FOTA 패키징 API, Core Crypto 등의 기능을 수행하여야 할 것이다. 상술한 바와 같은 기능을 수행하는 업데이트 매니저 서버는, 백업 파일 분산화 모듈(설명의 편의상 도면에 는 도시하지 않음)을 포함할 수 있다. 백업 파일 분산화 모듈은, 해킹 또는 랜섬웨어와 같은 외부의 공격으로부터 보호하여야 할 사용자 정보나 시스 템 정보 등과 같은 중요 정보를 백업 파일로 생성한 후, 생성된 백업 파일을 동일한 데이터를 포함하는 1차 백 업 파일과 2차 백업을 차례로 생성하여 저장하되, 1차 백업 파일과 2차 백업 파일의 저장 장소를 달리 하여 저 장한다. 다만, 백업 파일의 생성은 1차와 2차에 한정되는 것은 아니며, 시스템의 성능 등을 고려하여 3차 이상의 복수 개의 백업 파일을 생성하여도 무방하다. 그리고, 백업 파일 분산화 모듈은, 기 설정된 주기로(예를 들어, 시스템 상 기본적으로 설정된 주기인 3시간 마 다 1회 내지 5시간 마다 1회 등, 다만 해당 설정된 주기에 한정되는 것은 아니며 사용자로부터 지정 받은 주기 로 설정되어도 무방하다) 저장되었던 1차 백업 파일과 2차 백업 파일의 저장 장소를 시스템 상의 기 설정된 장 소 또는 새롭게 생성된 장소로 변경한다. 이때, 백업 파일의 이동 장소는, 시스템 상에서 기 설정되거나 사용자로부터 지정 받은 장소가 아니라, 임의의 랜덤 변수에 따라 생성된 폴더나 서브 폴더로 지정됨이 바람직하다. 이에 따라, 해킹 또는 랜섬웨어와 같은 공격형 프로그램이 공격하고자 하는 파일이 위치하는 폴더의 존재 또는 해당 폴더의 위치를 예측하고 용이하게 공격하는 것을 원천적으로 방지함은 물론, 삭제되어서는 안 되는 고객 정보와 같은 중요한 데이터가 사용자의 실수로 삭제되거나 수정되는 것을 방지할 수 있다. 본 발명에서, 1차 백업 파일과 2차 백업 파일은, 동일한 내용의 데이터를 포함하고 있는 파일들로써, 상호 간에 우열이 존재하는 것은 아니며, 파일의 이동에 있어서도 1차 백업 파일의 이동 후 2차 백업 파일이 이동하거나, 2차 백업 파일의 이동 후 1차 백업 파일이 이동하여도 무방하다. 일 실시예에서, 백업 파일 분산화 모듈은, 외부로부터 침입이 감지될 경우, 기 생성되었던 1차 백업 파일과 2차 백업 파일로부터의 복제를 연속적으로 수행하여 각 백업 파일의 서브 백업 파일들을 다수 개 생성하며, 생성된다수 개의 서브 백업 파일들을 역시 랜덤 변수에 따라 생성된 서로 다른 장소에 개별적으로 저장할 수 있다. 이에 따라, 시스템 상에서 산발적으로 생성된 다수 개의 백업 파일을 임의의 장소로 나누어 저장함으로써, 일부 백업 파일이 공격에 의해 손실되거나 삭제되는 경우에도 시스템 상에 산발적으로 존재하는 백업 파일을 이용하 여 필요한 자료 등을 용이하게 복구하도록 할 수 있다. 다음으로, 백업 파일 분산화 모듈은, 다수 개의 백업 파일 중 현재 공격받고 있는 백업 파일이라고 판단된 파일 을 시스템 상에서 영구적으로 삭제하게 된다. 이에 따라, 본 발명에서는, 해킹 또는 랜섬웨어의 공격 등으로 인해 시스템 상에서 정상적인 기능을 수행하지 못하거나, 해당 공격으로 인해 시스템 상에 존재하는 다른 파일까지도 위험에 노출시킬 수 있는 좀비 프로그램 으로 변할 수 있는 파일을 미연에 시스템 상에서 삭제시킴으로써, 일부 파일로 인해 시스템 전체가 공격받는 것 을 미연에 방지할 수 있다. 일 실시예에서, 백업 파일 분산화 모듈은, 백업 파일을 클라우드 서비스와 연동된 동기화 폴더에 저장한 경우, 해당 동기화 폴더에 백업 파일의 저장이 완료되고 저장한 백업 파일이 클라우드 상에 업로드 되면, 해당 동기화 폴더에 대한 동기화를 해제할 수 있다. 예를 들어, 사용자의 동기화를 위한 클라우드 서비스가 \"Dropbox\"라고 할 경우, \"Dropbox\"에서 제공하고 있는 \"선택적 동기화 서비스\"를 이용하여 상술한 바와 같은 백업 파일 분산화 모듈의 기능을 구현하게 된다. 즉, 백업 파일 분산화 모듈은, 백업 파일을 저장하기 위한 공간으로서 \"백업 폴더\"를 시스템 상에 생성하면, 클 라우드 서비스는 새롭게 생성된 \"백업 폴더\"를 클라우드 상에서 역시 동일하게 생성하게 된다. 다음으로, 백업 파일 분산화 모듈은, 해당 폴더에 백업 파일을 저장하게 될 것이고, 이에 따라 클라우드 상에도 해당 백업 파일이 업로드 된다. 마지막으로, 클라우드 상에 해당 백업 파일의 업로드가 완료되면, 백업 파일 분산화 모듈은, 백업 파일 업로드 에 사용되었던 \"백업 폴더\"에 대한 동기화만을 선택적으로 해제하고, \"백업 폴더\"를 시스템 상에서 삭제한다. 이 경우, 시스템 전체에 대한 동기화를 해제하는 것이 아니라, 백업 파일의 업로드에 사용하기 위해 임시적으로 생성되었던 \"백업 폴더\"만에 대한 동기화를 해제함으로써, 클라우드 서비스와의 안정적인 동기화 서비스는 지속 적으로 수행하는 반면, 백업 파일은 클라우스 상에 업로드시킨 후 시스템 상에서는 삭제함에 따라 크라우드 상 에서 백업 파일은 안전하게 저장하는 한편 시스템을 침투한 공격에 지속적으로 노출되는 것은 원천적으로 방지 할 수 있게 된다. 일 실시예에서, 백업 파일 분산화 모듈은, 클라우드 상에 업로드 하였던 백업 파일의 저장 장소를 변경할 순서 가 된 경우, 선택적 동기화를 해제하였던 폴더의 동기화를 다시 수행하여 클라우드 서비스에 업로드 하였던 백 업 파일을 다운받은 후, 다운받은 백업 파일을 상술한 바와 같이 랜덤 변수에 따라 새롭게 생성된 장소로 이동 시킬 수 있다. 상술한 바와 같은 구성을 가지는 업데이트 매니저 서버는, 개발 환경 관리 시스템(설명의 편의상 도면에는 도시하지 않음) 상에서 구현될 수 있다. 개발 환경은 다수의 개발자가 소프트웨어 개발을 위해 다수의 개발 시스템을 사용하며, 각 개발 시스템은 개발 자의 제어에 따라 소프트웨어 컴포넌트 및 소프트웨어를 개발하고 직접 관리할 수 있다. 각 개발 시스템은 신뢰 플랫폼 모듈(TPM: Trusted Platform Module) 표준기술을 사용하며, 이에 따라 소프트웨어 컴포넌트가 사용 허가 된 개발 시스템에서만 사용 가능하도록 한다. 신뢰 플랫폼 모듈(TPM)은 일종의 보안 장치로서, 데이터 암호화를 위한 보안키를 생성 및 관리할 수 있다. 개발 환경 관리 시스템은 소프트웨어 컴포넌트 사용에 대한 개발자의 권한을 제한하고, 개발자가 사용하는 개발 시스템에 대한 보안 인증을 수행할 수 있다. 개발 환경 관리 시스템은 개발 시스템으로부터 소프트웨어 컴포넌트 생성 또는 수정 허가 요청 메시지를 수신하 는 경우, 해당 개발 시스템의 권한 정보를 확인하여 소프트웨어 컴포넌트 생성 또는 수정 허가 요청 메시지를 처리할 수 있다. 여기에서, 소프트웨어 컴포넌트는 소스코드, 디버깅 정보를 포함하는 바이너리, 디버깅 정보를 포함하지 않는 순수 바이너리, 코드에 대한 상세설명을 위한 문서, 코드의 이해를 위한 공정 수식모델 중 적어도 하나를 포함하여 구성될 수 있다. 권한 정보는 소프트웨어 컴포넌트를 읽을 수 있는 읽기 권한, 소프트웨어 컴포넌트를 생성 및 수정하여 저장할 수 있는 저장 권한, 권한 정보를 조정할 수 있는 권한조정 권한 중 적어도 하나를 포함하여 구성될 수 있다. 개발 환경 관리 시스템은 권한 정보를 만족하는 어느 하나의 개발 시스템에 의해 소프트웨어 컴포넌트가 생성 또는 수정되는 경우, 이를 저장하여 다른 개발 시스템에서도 공유 가능하도록 제어할 수 있다. 이는 어느 하나 의 개발 시스템에 의해 빌드한 모듈을 다른 개발 시스템에서 사용하여야 하는 경우가 있기 때문이다. 개발 환경 관리 시스템은 이러한 소프트웨어 컴포넌트의 생성 또는 수정 이력을 저장한 데이터베이스를 구축할 수 있다. 이는 이력 정보를 통해 특정 변수의 값이 어떻게 달라졌는지 단계별로 추적할 수 있고, 그 특정 변수 가 임의의 다른 변수의 값 변경에 어떠한 영향을 주었는지도 파악할 수 있기 때문이다. 구체적으로는, 개발 환경 관리 시스템은 소프트웨어 컴포넌트의 종류, 해당 소프트웨어 컴포넌트의 생성/수정 여부, 해당 소프트웨어 컴포넌트의 생성/수정 일자, 해당 소프트웨어 컴포넌트의 생성/수정 빈도, 해당 소프트 웨어 컴포넌트를 생성/수정한 개발 시스템의 권한 정보를 포함하여 이력 정보를 생성할 수 있다. 개발 환경 관리 시스템은 이력 정보를 생성할 때마다 인덱스를 부여하여 이력 정보 데이터베이스에 저장할 수 있다. 이때, 개발 환경 관리 시스템은 소프트웨어 컴포넌트의 종류별로 이력 정보 데이터베이스를 구축할 수 있다. 즉, 개발 환경 관리 시스템은 소프트웨어 컴포넌트의 중요도에 따라 이력 정보 데이터베이스를 구축할 수 있으 며, 중요도가 가장 높은 종류에 해당하는 소프트웨어 컴포넌트의 이력 정보 데이터베이스는 후술하는 바와 같이 저장 공간 관리를 위한 데이터베이스 갱신 대상에서 제외될 수 있을 것이다. 또는, 개발 환경 관리 시스템은 소프트웨어 컴포넌트의 생성/수정 일자 별로 이력 정보 데이터베이스를 구축할 수 있다. 일예로, 개발 환경 관리 시스템은 특정 일자의 이력 정보 데이터베이스를 구축하여, 해당 이력 정보 데이터베이스를 데이터베이스 갱신 대상에서 제외시킬 수 있다. 또는, 개발 환경 관리 시스템은 권한 정보 별로 이력 정보 데이터베이스를 구축할 수 있다. 일예로, 개발 환경 관리 시스템은 최고 권한 정보로 간주되는 권한 정보를 조정할 수 있는 권한조정 권한에 해당하는 개발 시스템 에 의한 소프트웨어 컴포넌트의 이력 정보 데이터베이스를 구축하여, 해당 이력 정보 데이터베이스를 데이터베 이스 갱신 대상에서 제외시킬 수 있다. 개발 환경 관리 시스템은 상술한 바와 같이 효율적인 저장 공간 관리를 위해 이력 정보 데이터베이스를 갱신할 수 있다. 구체적으로는, 개발 환경 관리 시스템은 이력 정보 데이터베이스의 인덱스가 미리 설정된 인덱스에 도달하면 이 력 정보 데이터베이스 갱신을 수행할 수 있다. 예를 들면, 개발 환경 관리 시스템은 이력 정보 데이터베이스의 전체 인덱스를 오름차순으로 하여 3 개의 구간 으로 나눌 수 있다. *개발 환경 관리 시스템은 3 개의 구간 중 가장 낮은 인덱스를 포함하는 구간에 해당하는 이력 정보를 조건 없 이 삭제할 수 있다. 해당 구간에 해당하는 이력 정보는 생성/수정 일자가 오랜 시간이 경과한 것으로 간주할 수 있으며, 이에 해당 이력 정보가 다시 참조될 가능성은 낮으므로 조건 없이 삭제할 수 있다. 개발 환경 관리 시스템은 3 개의 구간 중 가운데 구간에 해당하는 이력 정보를 소프트웨어 컴포넌트의 종류에 따라 삭제 또는 유지 여부를 결정하여 갱신할 수 있다. 즉, 개발 환경 관리 시스템은 소프트웨어 컴포넌트의 종 류에 따라 중요도를 분류할 수 있으며, 3 개의 구간 중 가운데 구간에 해당하는 이력 정보 중 중요도가 가장 높 은 소프트웨어 컴포넌트의 종류에 해당하는 이력 정보만을 유지하고 나머지 이력 정보는 모두 삭제하는 방식으 로 이력 정보 데이터베이스를 갱신할 수 있다. 또는, 개발 환경 관리 시스템은 3 개의 구간 중 가운데 구간에 해당하는 이력 정보를 소프트웨어 컴포넌트의 생 성/수정 빈도에 따라 삭제 또는 유지 여부를 결정하여 갱신할 수 있다. 즉, 3 개의 구간 중 가운데 구간에 해당 하는 이력 정보 중 그 생성/수정 빈도가 미리 설정된 기준 빈도보다 높은 이력 정보는 모두 삭제하고 나머지 이 력 정보는 유지하는 방식으로 이력 정보 데이터베이스를 갱신할 수 있다.또는, 개발 환경 관리 시스템은 3 개의 구간 중 가운데 구간에 해당하는 이력 정보를 개발 시스템의 권한 정보 에 따라 삭제 또는 유지 여부를 결정하여 갱신할 수 있다. 즉, 3 개의 구간 중 가운데 구간에 해당하는 이력 정 보 중 그 권한 정보가 최고 권한 정보로 간주되는 권한 정보를 조정할 수 있는 권한조정 권한인 이력 정보는 그 대로 유지하고, 나머지 이력 정보는 모두 삭제하는 방식으로 이력 정보 데이터베이스를 갱신할 수 있다. 개발 환경 관리 시스템은 3 개의 구간 중 가장 높은 인덱스를 포함하는 구간에 해당하는 이력 정보를 그대로 유 지할 수 있다. 해당 구간에 해당하는 이력 정보는 생성/수정 일자가 비교적 최근의 것으로 간주할 수 있으며, 이에 해당 이력 정보가 다시 참조될 가능성은 높으므로 그대로 유지할 수 있다. 상술한 바와 같은 구성을 가지는 업데이트 매니저 서버의 구성 중 일부는 인공지능에 의해 구현될 수 있으 며, 의사결정 이유 제시부(설명의 편의상 도면에는 도시하지 않음)을 더 포함할 수 있다. 의사결정 이유 제시부는, 주어지거나 사용자에 의해 입력된 데이터에 대해서 분류ㅇ예측할 뿐만 아니라 결정에 대한 인과관계를 분석하여 적절한 근거를 찾아, 인공지능이 제시한 결과에 대해서 왜 그런 결과가 나오는지에 대한 이유를 사용자 레벨에서 설명할 수 있다. 의사결정 이유 제시부를 통해 사용자와 인공지능 상호간의 신뢰 할 수 있는 의사결정을 가능케 함으로써, 문제나 오류 발생 시 사용자에 의한 피드백이 적절하게 반영될 수 있 다. 또한, 의사결정 이유 제시부를 둠으로써, 인공지능이 제시하는 결과에 대해서 왜 그런 결과가 나오는지에 대한 원인을 명쾌하게 설명할 수 없어 사용자가 인공지능에 가질 수 있는 불신감을 해소할 수 있으며, 과도하게 학습을 진행할 경우 전체적인 관점에서의 최적해가 아닌 지역 내 최적해가 선택될 수 있다는 과적합화 (overfitting) 문제를 미연에 방지할 수 있다. 일 실시 예에서, 의사결정 이유 제시부는 모델 구축 모듈 및 이유 설명 인터페이스 모듈을 더 포함할 수 있다. 모델 구축 모듈은 심층 설명 학습 모듈, 해석 가능한 모델 생성 모듈 및 모델 귀납 모듈로 구현될 수 있다. 심층 설명 학습 모듈은 변형된 딥러닝 기술로서 심층 신경망이 설명 가능한 특징들을 학습하도록 할 수 있다. 은닉계층의 노드가 의미 있는 속성을 나타내도록 학습할 수 있으며, 예를 들어 팔과 다리의 이미지를 구분하는 모델을 학습한다면, 각 은닉 노드가 손톱이나 발톱 모양, 손가락이나 발가락 모양, 손바닥이나 발바닥의 위치 등을 나타내도록 학습해서 모델이 어떤 이미지를 손이라고 판단했을 때 활성화된 은닉 노드를 통해 판단의 근거 를 알 수 있다. 이러한 판단의 근거는 예를 들어 RNN(순환신경망, Recurrent Neural Network) 등의 자연어 생성 모델을 통해 언어적으로 나타낼 수도 있다. RNN은 딥러닝의 모델이며 인공신경망의 한 종류로서, 시계열 데이터 와 같이 시간의 흐름에 따라 변화하는 데이터를 학습하기 위한 것으로서, 입력조절벡터와 망각벡터 그리고 출력 조절벡터를 이용하여 입력과 출력데이터를 얻는다. 입력조절벡터에서는 입력신호가 활성화함수와의 연결계층을 거친 후에 값을 받아들이며 망각 벡터는 과거 입력의 일부를 현재 입력에 반영하는 역할을 한다. 그리고 출력조 절벡터는 과거의 값과 수정된 입력값을 고려하여 활성화 함수를 이용해 값을 받아들인다. 그리고 그 최종결과는 다시 입력으로 되돌아가게 된다. 이러한 순환신경망은 문서 감정을 분류하거나 필기체를 인식하는데 주로 활용 되며, 음성 인식, 시계열 예측이나 파형생성을 할 때에도 주로 활용될 수 있다. 이는 입력데이터가 순서가 없는 고정된 모양이여도 적절할 순서에 따라 처리할 수 있기 때문이다. 또한, 일 실시 예에서, 심층 설명 학습 모듈은 이미지에 근거가 되는 부분을 표시하여 시각적으로 나타낼 수도 있다. 예를 들어 인공지능 시스템이 고양이 이미지를 분류할 경우, 기존 시스템은 입력된 이미지의 고양이 여부 만을 도출하지만, 심층 설명 학습 모듈은 고양이 여부를 도출하고, 이것의 근거(털, 수염 등) 이미지를 사용자 에게 제공할 수 있다. 해석 가능한 모델 생성 모듈은, 구조화된 데이터를 해석 가능한 인과관계 모델로 구축할 수 있다. 일 실시 예에 따르면, BPL(bayesian program learning)을 이용하여 해석 가능한 모델 생성 모듈을 구축할 수 있으며, BPL은 작은 조각들의 조합으로 표현하도록 학습하는 방법으로서, 예를 들어 글자를 생성하는 모델을 학습할 때 글자를 획으로 나누어서 가장 합리적인 획의 조합으로 생성하도록 한다. BPL은 대량의 데이터가 없이도 사람과 같이 한 번 보면 그대로 모방할 수 있으며, Neural Network(신경망 모델)를 진화시킨 것으로서 새로운 사건이 주어졌을 때 그 사건을 바탕으로 확률값을 변화시킬 수 있다. 즉, BPL은 가상 변수들에 들어가는 가중치만 바꾸는 방식이 아니라, 중간에 다른 가상 변수를 생성하는 내용까지 포함된다. 새로운 환경이 주어지면 다른 방식으로 현상을 이해하는 것으로서 예를 들어, 동전을 100번 던져서 앞면이 60번, 뒷면이 40번 나와서 앞 면이 나올 확률을 60% 로 잡은 다음, 다음번에 뒷면이 나오게 되면 앞면이 나올 확률을 59.4%로 내리는 방식이다. 또한, 일 실시 예에서, 해석 가능한 모델 생성 모듈은 확률론적 접근 방법을 통해 구현될 수 있다. 확률론적 접 근 방법은 몇 가지 샘플만으로도 학습 효과를 낼 수 있으며, 예를 들면 길이가 긴 의자와 짧은 의자를 보여주면중간 길이의 의자도 있다는 것을 배우는 것과 비슷하다. 즉, 부족한 데이터를 스스로 채워 나가며 학습하는 기 술이다. 실시 예에 따라서는 확률론적 접근 방법은 수학적 계산을 통해 스스로 확률과 프로그램을 보정하는 기 능을 포함할 수 있다. 또한, 일 실시 예에서, 해석 가능한 모델 생성 모듈은 And-Or-Graph를 이용하여 구현된 수 있다. And-Or- Graph는 AND/OR 그래프란 rule의 조건 및 결론관계와 AND/OR 관계를 그래프 형태로 나타내는 것으로서, 인공지 능에 의해 도출되는 중간 및 최종 데이터가 구조화 되어있어 모델의 결정과정을 논리적으로 설명하기 쉬운 장점 이 있다. 즉, AND 노드와 OR 노드로 그래프를 나타내는데, AND 노드는 모두 처리되어야 하며 OR 노드는 하나만 처리되면 끝낼 수 있다. AND/OR 그래프를 이용하면 서로 산재해 있는 rule들의 집합을 하나의 구조로 조감할 수 있으며 각 문장간의 논리적인 관계를 쉽게 파악할 수 있다. 모델 귀납 모듈은 임의의 블랙박스 모델을 설명가능한 모델로 추론할 수 있다. 일 실시 예에서, 모델 귀납 모듈 은 LIME(local interpretable model-agnostic explanations)로 구현될 수 있으며, LIME은 임의의 블랙박스 모 델을 이미 설명이 가능한 데이터 주변에서 희소 선형 결합을 통해 국부적으로 설명 가능하게 만들 수 있다. 예 를 들어, 이미지를 분류하는 블랙박스 모델이 어떤 이미지를 심장이라고 판단했다면 이미 설명 가능한 다른 모 델의 심장에 대한 설명 즉, 심장을 표현하는 픽셀들을 주어진 이미지와 대조하여 어느 부분이 심장이라고 판단 한 근거인지 제시할 수 있다. 또한, 일 실시 예에서 모델 귀납 모듈은 모델을 일련의 if-then 조건문으로 표현하는 BRL(bayesian rule list s)로 구현될 수 있다. BRL은 고차원, 다변수인 특징공간을 간단하고 이미 해석 가능한 조건문으로 나누어 복잡 한 모델을 이해할 수 있게 한다. 상술한 심층 설명 학습 모듈, 해석 가능한 모델 생성 모듈 및 모델 귀납 모듈은 서로 독립적으로 또는 서로 결 합되어 작용될 수 있으며, 그 구현 순서도 실시 예에 따라 달라질 수 있다. 다음으로, 이유 설명 인터페이스 모듈은 인공지능의 의사결정에 대한 설명을 사용자가 이해할 수 있는 방식으로 표현할 수 있다. 이유 설명 인터페이스 모듈은 제시한 설명이 반복적일 것, 필요한 설명을 모두 포함하고 있을 것, 불필요한 설명을 포함하지 않을 것, 양이 적절할 것 등을 필수 항목으로 포함할 수 있다. 즉, 사용자가 용 이하게 인공지능이 어떠한 과정과 이유로 최종 결과를 도출했는지와 각 단계별로 영향을 미친 요소나 데이터가 무엇인지 언어, 표, 이미지, 그래프, 수식 등을 포함하여 사용자에게 제공할 수 있다. 또한, 이유 설명 인터페이스 모듈은 사용자의 정정 명령을 입력받을 수 있다. 이를 위해 이유 설명 인터페이스 모듈은 정정가능성은 설명이 유동적일 것, 사용자의 피드백을 존중할 것, 점진적인 변화를 주시할 것 등을 필수 항목으로 포함할 수 있다. 이렇게 제시된 설명에 대해서 사용자에게 설명의 명확도와 활용도 등에 대한 피드백 을 받아 이유 설명 인터페이스 모듈의 효과를 평가하고 발전시킬 수 있다. 다른 실시 예에서, 의사결정 이유 제시부는, 인과관계 모델로 형성될 수 있다. 인과과계 모델은 딥러닝과 마르 코브 랜덤 필드를 결합하는 형태로 형성될 수 있다. 먼저 학습 데이터로부터 심층 마르코브 랜덤 필드 모델의 확률 분포를 모델링하고, 확률 변수들 사이의 조건부 독립성을 나타내는 마르코브 랜덤 필드의 구조를 학습한다. 구조가 학습된 마르코브 랜덤 필드의 잠재 함수를 심층 신경망으로 추론하여 입력 변수의 수가 증가 함에 따라 잠재 함수에 필요한 매개 변수의 수가 기하급수적으로 증가하는 문제를 완화하고, 변수 연관관계에 대한 제약 없이 복잡한 연관관계를 학습할 수 있다. 실시예에 따라 클래스 분류 문제를 보조태스크인 속성, 슈 퍼카테고리와 같이 학습한 후, 출력 단계에서 선형 결합하여 효과적인 표현이 가능하도록 할 수 있다. 또한 인 과관계가 정확히 학습되었는지 사람이 확인하고 피드백을 주어 수정할 수 있도록 하는 상호작용 학습 알고리즘 을 포함할 수 있다. 또 다른 실시 예에서, 의사결정 이유 제시부는, 분석 모듈로 구현될 수 있다. 시계열 함수를 다양한 커널을 바 탕으로 다변수 가우시안으로 회귀분석 하는 기술로서, 가우시안 프로세스에서 커널을 표현하는 최적의 커널 조 합을 학습하여 주어진 시계열 데이터를 위에서 찾은 커널 조합을 바탕으로 설명할 수 있다. 더 나아가서 여러 개의 시계열 데이터가 있을 때에도 공통적으로 표현되는 커널 및 각 시계열 데이터의 특성을 표현하는 커널의 조합을 학습하여 여러 개의 시계열 데이터에서 공통적으로 나타나는 특징을 설명할 수 있다. 시계열 데이터 분 석 모델을 통해 찾은 커널의 조합을 자연어로 작성함으로써 사용자에게 인공지능에 의해 도출된 의사결정의 도 출과정 및 그 이유를 자연어로 설명해 줄 수 있다. 이와 같은 의사결정 이유 제시부를 통해, 인공지능의 의사결정 과정을 사용자의 입장에서 시각화 및 문자화함으 로써, 의사결정에 과정에 관여한 구성요소를 설명할 수 있으며 동시에 복잡한 모델의 상관관계를 분석하여 원인요소와 결과요소로 나누어 설명할 수 있다. 특히 사용자가 용이하게 이해할 수 있는 자동 보고서의 형식으로 작성됨으로써, 데이터를 분석한 결과 뿐만 아니라 이유를 제공하여 인공지능이 보다 정밀하게 인간과 상호 작용 하게 할 수 있다. 상술한 바와 같은 단계를 가지는 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법은, 저전력 무선네트워크 를 이용하여 펌웨어 업데이트를 수행할 수 있도록 함으로써, 제조사에서 제공하는 펌웨어를 분할하여 FOTA 대상 단말기로 전송함에 따라, 저전력 무선네트워크 상황이나, FOTA 대상 단말기의 성능이 우수하지 않다고 하더라도 제조사에서 제공하는 펌웨어를 부담없이 전송받도록 할 수 있다. 이상에서는 실시예들을 참조하여 설명하였지만, 해당 기술 분야의 숙련된 당업자는 하기의 특허 청구의 범위에 기재된 본 발명의 사상 및 영역으로부터 벗어나지 않는 범위 내에서 본 발명을 다양하게 수정 및 변경시킬 수 있음을 이해할 수 있을 것이다."}
{"patent_id": "10-2018-0127069", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 업데이트 매니저 서버, 다운로드 서버, 플랫폼, 대상 단말기 및 제조사 서버의 관계를 설명하는 도면이 다. 도 2는 본 발명의 일 실시예에 따른 저전력 무선네트워크를 이용한 펌웨어 업데이트 방법을 설명하는 순서도이 다. 도 3은 도 2의 단말기 등록 단계를 설명하는 순서도이다. 도 4는 도 2의 펌웨어 버전 확인 단계를 설명하는 순서도이다. 도 5는 도 2의 펌웨어 패키징 단계를 설명하는 순서도이다. 도 6은 도 5의 전송용 펌웨어를 생성하는 단계에 의한 분할 및 보안이 적용된 전송용 펌웨어의 생성을 설명하는 도면이다. 도 7은 도 2의 펌웨어 다운로드 단계를 설명하는 순서도이다. 도 8은 도 2의 펌웨어 업데이트 단계를 설명하는 순서도이다."}
