{"patent_id": "10-2021-7043355", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0079801", "출원번호": "10-2021-7043355", "발명의 명칭": "머신 러닝 모델을 호스팅, 모니터링, 및 리트레이닝하기 위한 로보틱 프로세스 오토메이션 아", "출원인": "유아이패스, 인크.", "발명자": "스리바스타바 샤샨크"}}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "시스템으로서,하나 이상의 머신 러닝(machine learning, ML) 모델을 호출하도록 구성된 하나 이상의 로봇 프로세스 오토메이션(robotic process automation, RPA) 로봇; 및상기 하나 이상의 ML 모델을 저장하고 상기 하나 이상의 RPA 로봇의 각 RPA 로봇으로부터의 호출 시에 상기 하나 이상의 ML 모델을 실행하도록 구성된 인공 지능(artificial intelligence, AI) 센터를 포함하며,상기 AI 센터는,상기 ML 모델에 대한 복수의 데이터세트들을 저장하도록 - 각 데이터세트는 논리적 또는 물리적으로 그룹화된유사한 타입들의 데이터를 포함함 -, 그리고ML 모델에 대한 트레이닝 구성에서 지정된 상기 복수의 데이터세트들의 서브세트를 사용하여 리트레이닝이 수동으로 요청될 때 또는 트레이닝 조건이 충족될 때 상기 하나 이상의 ML 모델 중의 상기 ML 모델을 리트레이닝하고, 상기 리트레이닝된 ML 모델을 상기 하나 이상의 RPA 로봇에 의해 호출되게 디플로이하도록 구성된 것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 AI 센터는,하나 이상의 리트레이닝 파이프라인을 실행하도록 구성된 트레이닝 클러스터;상기 하나 이상의 ML 모델에 대한 생성/판독/업데이트/삭제(create/read/update/delete, CRUD) 동작들을 수행하고, 상기 트레이닝 클러스터의 리트레이닝 파이프라인으로 하여금, 상기 하나 이상의 ML 모델의 리트레이닝을개시하게 하도록 구성된 코어 마이크로서비스 클러스터; 및상기 하나 이상의 ML 모델을 실행하고, 상기 실행의 결과들을 상기 하나 이상의 RPA 로봇 중 호출 RPA 로봇들에제공하도록 구성된 ML 서비스 클러스터를 포함하는 것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 하나 이상의 RPA 로봇 중 적어도 하나의 RPA 로봇의 RPA 워크플로우는 상기 각 RPA 로봇이 리트레이닝을 위한 데이터를 업로드하기 위한 스토리지의 위치를 포함하는 데이터 푸시 액티비티를 포함하는것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서, 상기 하나 이상의 RPA 로봇 중 적어도 하나의 RPA 로봇은 로컬 데이터, 원격 데이터베이스에저장된 데이터, 또는 양자를 통해 반복하고, 리트레이닝을 위해 상기 데이터를 상기 AI 센터의 스토리지에 송신하도록 구성된 것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서, 상기 복수의 데이터세트들은 리트레이닝 동안 ML 모델들에 대한 포인터들로서 제시되며, 리트레이닝되고 있는 상기 ML 모델은 각각의 상기 포인터들을 통해 리트레이닝을 위해 상기 복수의 데이터세트들의상기 서브세트에 액세스하는 것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "공개특허 10-2022-0079801-3-제1항에 있어서, 상기 AI 센터는,리트레이닝되고 있는 상기 ML 모델에 대한 하나 이상의 성능 척도를 수신하도록; 그리고상기 리트레이닝 동안 상기 하나 이상의 성능 척도에 대한 하나 이상의 스코어를 생성하도록 구성된 것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서, 상기 하나 이상의 스코어에 대한 변화가 여러 번 리트레이닝이 수행됨에 따라 시간이 지나면서추적되는 것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 상기 AI 센터는 리트레이닝을 위한 데이터 포인트들의 수, 리트레이닝 데이터가 수집되는빈도, 수집되는 리트레이닝 데이터의 양, 리트레이닝을 위한 하나 이상의 트리거, 또는 이들의 조합을 조정하도록 구성된 것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서, 상기 하나 이상의 RPA 로봇 중 적어도 하나의 RPA 로봇의 RPA 워크플로우가 리트레이닝을 위한데이터 포인트들의 수, 리트레이닝 데이터가 수집되는 빈도, 수집되는 리트레이닝 데이터의 양, 리트레이닝을위한 하나 이상의 트리거, 또는 이들의 조합을 조정하도록 구성된 것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1항에 있어서, 상기 AI 센터는 상기 하나 이상의 RPA 로봇이 상기 하나 이상의 ML 모델을 호출하고 상기 ML모델의 실행의 결과들을 수신하는 것을 허용하지만, 상기 하나 이상의 RPA 로봇이 상기 하나 이상의 ML 모델 자체에 액세스하는 것은 허용하지 않는 것인, 시스템."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "컴퓨터 프로그램을 저장하는 컴퓨터 판독 가능 비일시적 저장 매체로서, 상기 컴퓨터 프로그램은 적어도 하나의프로세서로 하여금,복수의 머신 러닝(ML) 모델들, 및 상기 ML 모델들에 대한 복수의 데이터세트들을 저장하게 하도록 - 각 데이터세트는 논리적 또는 물리적으로 그룹화된 유사한 타입들의 데이터를 포함함 -;ML 모델에 대한 트레이닝 구성에서 지정된 상기 복수의 데이터세트들의 서브세트를 사용하여 리트레이닝이 수동으로 요청될 때 또는 트레이닝 조건이 충족될 때 상기 복수의 ML 모델들 중의 상기 ML 모델을 리트레이닝하게하도록; 그리고상기 리트레이닝된 ML 모델을 상기 하나 이상의 로보틱 프로세스 오토메이션(RPA) 로봇에 의해 호출되는 데 이용 가능하게 함으로써 상기 리트레이닝된 ML 모델을 디플로이하게 하도록 구성된 것인, 컴퓨터 판독 가능 비일시적 저장 매체."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서, 상기 복수의 데이터세트들은 리트레이닝 동안 ML 모델들에 대한 포인터들로서 제시되며, 리트레이닝되고 있는 상기 ML 모델은 각각의 상기 포인터들을 통해 리트레이닝을 위해 상기 복수의 데이터세트들의상기 서브세트에 액세스하는 것인, 컴퓨터 판독 가능 비일시적 저장 매체."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제11항에 있어서, 상기 컴퓨터 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금,리트레이닝되고 있는 상기 ML 모델에 대한 하나 이상의 성능 척도를 수신하게 하도록; 그리고상기 리트레이닝 동안 상기 하나 이상의 성능 척도에 대한 하나 이상의 스코어를 생성하도록 구성된 것인, 컴퓨터 판독 가능 비일시적 저장 매체.공개특허 10-2022-0079801-4-청구항 14 제13항에 있어서, 상기 하나 이상의 스코어에 대한 변화가 여러 번 리트레이닝이 수행됨에 따라 시간이 지나면서 추적되는 것인, 컴퓨터 판독 가능 비일시적 저장 매체."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제11항에 있어서, 상기 컴퓨터 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금,리트레이닝을 위한 데이터 포인트들의 수, 리트레이닝 데이터가 수집되는 빈도, 수집되는 리트레이닝 데이터의양, 리트레이닝을 위한 하나 이상의 트리거, 또는 이들의 조합을 조정하게 하도록 구성된 것인, 컴퓨터 판독 가능 비일시적 저장 매체."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제11항에 있어서, 상기 컴퓨터 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금,상기 하나 이상의 RPA 로봇이 상기 복수의 ML 모델들을 호출하고 상기 ML 모델들의 실행의 결과들을 수신하는것을 허용하게 하도록; 그리고상기 하나 이상의 RPA 로봇이 상기 복수의 ML 모델들 중 적어도 하나 자체에 액세스하는 것을 방지하게 하도록구성된 것인, 컴퓨터 판독 가능 비일시적 저장 매체."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "인공 지능(AI) 센터로서,하나 이상의 리트레이닝 파이프라인을 실행하도록 구성된 트레이닝 클러스터;하나 이상의 머신 러닝(ML) 모델에 대한 생성/판독/업데이트/삭제(CRUD) 동작들을 수행하고, 상기 트레이닝 클러스터의 리트레이닝 파이프라인으로 하여금, 상기 하나 이상의 ML 모델의 리트레이닝을 개시하게 하도록 구성된 코어 마이크로서비스 클러스터; 및상기 하나 이상의 ML 모델을 실행하고, 상기 실행의 결과들을 호출 로보틱 프로세스 오토메이션(RPA) 로봇들에제공하도록 구성된 ML 서비스 클러스터를 포함하는, 인공 지능(AI) 센터."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서, 상기 트레이닝 클러스터는 ML 모델에 대한 트레이닝 구성에서 지정된 상기 복수의 데이터세트들의 서브세트를 사용하여 리트레이닝이 수동으로 요청될 때 또는 트레이닝 조건이 충족될 때 상기 하나 이상의ML 모델 중의 상기 ML 모델을 리트레이닝하도록 구성된 것인, 인공 지능(AI) 센터."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서, 상기 코어 마이크로서비스 클러스터는 상기 리트레이닝된 ML 모델을 상기 RPA 로봇에 의해 호출되게 상기 ML 서비스 클러스터에 디플로이하도록 구성된 것인, 인공 지능(AI) 센터."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제18항에 있어서, 상기 복수의 데이터세트들은 리트레이닝 동안 ML 모델들에 대한 포인터들로서 제시되며, 리트레이닝되고 있는 상기 ML 모델은 각각의 상기 포인터들을 통해 리트레이닝을 위해 상기 복수의 데이터세트들의상기 서브세트에 액세스하는 것인, 인공 지능(AI) 센터."}
{"patent_id": "10-2021-7043355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제17항에 있어서, 상기 AI 센터는 리트레이닝을 위한 데이터 포인트들의 수, 리트레이닝 데이터가 수집되는 빈도, 수집되는 리트레이닝 데이터의 양, 리트레이닝을 위한 하나 이상의 트리거, 또는 이들의 조합을 조정하도록구성된 것인, 인공 지능(AI) 센터.공개특허 10-2022-0079801-5-청구항 22 제17항에 있어서, 상기 ML 서비스 클러스터는 상기 하나 이상의 RPA 로봇이 상기 하나 이상의 ML 모델을 호출하고 상기 ML 모델의 실행의 결과들을 수신하는 것을 허용하지만, 상기 하나 이상의 RPA 로봇이 상기 하나 이상의ML 모델 자체에 액세스하는 것은 허용하지 않는 것인, 인공 지능(AI) 센터."}
{"patent_id": "10-2021-7043355", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "머신 러닝 모델들을 호스팅, 모니터링, 및 리트레이닝하기 위한 로보틱 프로세스 오토메이션(robotic process automation, RPA) 아키텍처들 및 프로세스들이 개시된다. 리트레이닝은 ML 모델 라이프사이클의 중요한 부분이다. 리트레이닝은 ML 모델의 타입, 및 ML 모델이 트레이닝될 데이터에 종속적일 수 있다. 리트레이닝을 위 한 RPA 로봇들로부터의 데이터를 저장하기 위해 보안 스토리지 계층이 사용될 수 있다. 이러한 리트레이닝은 자 동으로, 원격으로, 그리고 사용자 개입 없이 수행될 수 있다."}
{"patent_id": "10-2021-7043355", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "관련 출원 상호참조 본 출원은 2021년 1월 7일자로 출원된 미국 특허 출원 제17/143,392호의 이익을 주장하며, 이는 2020년 11월 25 일자로 출원된 인도 특허 출원 제202011051237호 및 2020년 11월 25일자로 출원된 인도 특허 출원 제 202011051236호의 이익을 주장한다. 이들 선출원들의 발명 내용은 전문이 본 명세서에 원용된다."}
{"patent_id": "10-2021-7043355", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 2, "content": "기술분야 본 발명은 일반적으로 로보틱 프로세스 오토메이션(robotic process automation, RPA)을 위한 인공 지능 (artificial intelligence, AI)에 관한 것이고, 보다 구체적으로는 머신 러닝(machine learning, ML) 모델을 호스팅, 모니터링, 및 리트레이닝하기 위한 RPA 아키텍처 및 프로세스에 관한 것이다."}
{"patent_id": "10-2021-7043355", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "ML은 RPA에서 정의하기 어렵고, 가변성이 높으며, 확률적 접근 방식이 필요한 단계들을 오토메이션하는 데 유용 할 수 있다. 그러나, RPA에서의 ML은 현재 실용적인 운용화 수단이 부족하다. 보다 구체적으로, ML은 고속 ML을 제공하기 위해 비즈니스 프로세스에 원활하게 플러깅(plugging)되어야 한다. RPA와 ML이 함께 원활하게 작동하는 것을 방지하는 세 가지 중요한 장벽이 있으며, 바로 운용, 기술, 및 프로세 스이다. 운용 관점에서, 로보틱 운용 센터(robotic operations center, ROC)와 데이터 과학 팀(data science team)들은 일반적으로 서로 다른 기술 세트들, 초점들, 및 비즈니스 우선 순위들을 갖는 사일로(silo)들로서 독 립적으로 존재한다. 기술 관점에서, RPA 개발자들은 RPA 플랫폼을 사용하여 로봇들에 의해 수행되는 오토메이션 을 구축, 배포, 및 관리한다. 한편, 데이터 과학자들은 전용 머신 러닝 모델링 툴들을 사용한다. 현재, ML 모델 들을 API(응용 프로그래밍 인터페이스)로서 발표하는 것은 Azure®, Google®, 및 Amazon®과 같은 플랫폼을 통해 이루어진다. ML 모델은 HTTP를 통해 노출된다. 그러나, 사용자는 API를 이용하기 위해 코드를 작성해야 한다. 현재, 이들 툴들, 파이프라인들, 및 기술들은 단절되어 있고, RPA와 ML은 별개의 프로세스들로서 관리된다. ML 모델들을 통합하려고 할 때, ROC는 모델이 정확한 출력을 생성하고 있는지 여부 또는 모델이 업데이트되었는지 여부를 알지 못한다. 또한, 데이터 과학 팀은 모델들이 정확하게 사용되고 있는지 여부 그리고 모델들이 얼마나 유용한지를 알지 못한다. 예를 들어, 데이터 과학자들은 현재 워크플로우에 포함시킬 스키마 정의를 RPA 개발자 에게 전달하는 간단한 메커니즘을 갖지 않는다. 또한, RPA 개발자가 ML 모델을 배포할 엔드포인트가 변경될지 여부, 또는 다른 어떤 작업들에 ML 모델이 사용되고 있는지도 알려져 있지 않다. 또한, 데이터 과학자에게는 모 델이 중단된 원인(예를 들어, 데이터 과학자는 엔드포인트가 도달 가능한지 여부를 알지 못할 수 있음) 또는 입 력 데이터가 변경된다면 모델이 어떻게 리트레이닝되고 워크플로우를 업데이트할지가 알려지지 않는다. 이는 RPA와 ML 사이에 근본적인 단절을 만든다. 따라서, RPA와 ML 모델 관리의 통합에 대한 접근 방식 개선이 유용할 수 있다. 본 발명의 특정 실시예들은 현재의 RPA 기술들에 의해 아직 완전히 식별, 인식, 또는 해결되지 않은 당업계의 문제들 및 요구들에 대한 솔루션들을 제공할 수 있다. 예를 들어, 본 발명의 일부 실시예는 ML 모델들을 호스팅, 모니터링, 및 리트레이닝하기 위한 RPA 아키텍처들 및 프로세스들에 관한 것이다. 일 실시예에서, 시스템은 하나 이상의 ML 모델을 호출하도록 구성된 하나 이상의 RPA 로봇을 포함한다. 시스템 은 또한, 하나 이상의 ML 모델을 저장하고 하나 이상의 RPA 로봇의 각 RPA 로봇으로부터의 호출 시에 하나 이상 의 ML 모델을 실행하도록 구성된 AI 센터를 포함한다. AI 센터는 또한, ML 모델에 대한 복수의 데이터세트들을 저장하도록 구성된다. 각 데이터세트는 논리적 또는 물리적으로 그룹화된 유사한 타입들의 데이터를 포함한다.AI 센터는 또한, ML 모델에 대한 트레이닝 구성에서 지정된 복수의 데이터세트들의 서브세트를 사용하여 리트레 이닝이 수동으로 요청될 때 또는 트레이닝 조건이 충족될 때 하나 이상의 ML 모델 중의 ML 모델을 리트레이닝하 고, 리트레이닝된 ML 모델을 하나 이상의 RPA 로봇에 의해 호출되게 디플로이하도록 구성된다. 또 다른 실시예에서, 비일시적인 컴퓨터 판독 가능 매체는 컴퓨터 프로그램을 저장한다. 컴퓨터 프로그램은 적 어도 하나의 프로세서로 하여금 복수의 ML 모델들 및 ML 모델들에 대한 복수의 데이터세트들을 저장하게 하도록 구성된다. 각 데이터세트는 논리적 또는 물리적으로 그룹화된 유사한 타입들의 데이터를 포함한다. 컴퓨터 프로 그램은 또한, 적어도 하나의 프로세서로 하여금, ML 모델에 대한 트레이닝 구성에서 지정된 복수의 데이터세트 들의 서브세트를 사용하여 리트레이닝이 수동으로 요청될 때 또는 트레이닝 조건이 충족될 때 복수의 ML 모델들 중의 ML 모델을 리트레이닝하게 하도록 구성된다. 컴퓨터 프로그램은 또한, 적어도 하나의 프로세서로 하여금, 리트레이닝된 ML 모델을 하나 이상의 RPA 로봇에 의해 호출되는 데 이용 가능하게 함으로써 리트레이닝된 ML 모 델을 디플로이하게 하도록 구성된다. 또 다른 실시예에서, AI 센터는 하나 이상의 리트레이닝 파이프라인을 실행하도록 구성된 트레이닝 클러스터, 및 하나 이상의 ML 모델에 대한 생성/판독/업데이트/삭제(create/read/update/delete, CRUD) 동작들을 수행하 고 트레이닝 클러스터의 리트레이닝 파이프라인으로 하여금, 하나 이상의 ML 모델의 리트레이닝을 개시하게 하 도록 구성된 코어 마이크로서비스 클러스터를 포함한다. 또 다른 실시예에서, AI 센터는 또한, 하나 이상의 ML 모델을 실행하고, 실행의 결과들을 호출 RPA 로봇들에 제공하도록 구성된 ML 서비스 클러스터를 포함한다. 또 다른 실시예에서, 시스템은 ML 모델을 컨테이너에 저장하고 RPA 로봇으로부터의 호출 시에 저장된 ML 모델을 실행하도록 구성된 AI 센터를 포함한다. ML 모델을 포함하는 컨테이너의 컨텐츠가 암호화 또는 난독화되거나 (obfuscated), ML 모델이 암호화되거나, 또는 둘 모두이다. 또 다른 실시예에서, AI 센터는 컴퓨터 프로그램 명령어들을 저장하는 메모리 및 컴퓨터 프로그램 명령어들을 실행하도록 구성된 적어도 하나의 프로세서를 포함한다. 컴퓨터 프로그램 명령어들은 적어도 하나의 프로세서로 하여금, 복수의 ML 모델들에 대한 복수의 데이터세트들을 저장하게 하도록 구성된다. 각 데이터세트는 논리적 또는 물리적으로 그룹화된 유사한 타입들의 데이터를 포함한다. 컴퓨터 프로그램 명령어들은 또한, 적어도 하나 의 프로세서로 하여금, ML 모델에 대한 트레이닝 구성에서 지정된 복수의 데이터세트들의 서브세트를 사용하여 트레이닝 조건이 충족될 때 또는 수동으로 요청 시에 복수의 ML 모델들 중의 ML 모델을 리트레이닝하게 하도록 구성된다. 컴퓨터 프로그램 명령어들은 또한, 적어도 하나의 프로세서로 하여금, 리트레이닝되고 있는 ML 모델 에 대한 하나 이상의 성능 척도를 수신하고 리트레이닝 동안 하나 이상의 성능 척도에 대한 하나 이상의 스코어 를 생성하게 하도록 구성된다. 하나 이상의 스코어가 향상될 때, 컴퓨터 프로그램 명령어들은 적어도 하나의 프 로세서로 하여금, ML 모델의 이전 버전 대신에 리트레이닝된 ML 모델을 디플로이하게 하거나, 또는 ML 모델의 리트레이닝된 버전을 디플로이하게 하고, ML 모델의 리트레이닝된 버전 및 ML 모델의 이전 버전 양자를 사용하 게 하며, 가장 높은 신뢰도를 갖는 결과를 선택하게 하도록 구성된다. 또 다른 실시예에서, 컴퓨터 구현 방법은 AI 센터에 의해, 컨테이너에 ML 모델을 저장하는 단계를 포함한다. 컴 퓨터 구현 방법은 또한, RPA 로봇으로부터의 호출 시에, AI 센터에 의해, 저장된 ML 모델을 실행하는 단계를 포 함한다. ML 모델을 포함하는 컨테이너의 컨텐츠가 암호화 또는 난독화되거나, ML 모델이 암호화되거나, 또는 둘 모두이다."}
{"patent_id": "10-2021-7043355", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "일부 실시예는 ML 모델들을 호스팅, 모니터링, 및 리트레이닝하기 위한 RPA 아키텍처들 및 프로세스들에 관한 것이다. 리트레이닝은 ML 모델 라이프사이클의 중요한 부분이다. 리트레이닝은 ML 모델의 타입(예를 들어, 이의 알고리즘들의 아키텍처), 및 ML 모델이 트레이닝될 데이터에 종속적일 수 있다. 일부 실시예는 보안 테넌트 레 벨 스토리지 계층 - 여기에 테넌트들은 그들이 트레이닝하려는 데이터를 포함시킬 수 있음 - 을 채용하고, RPA 로봇들은 이러한 스토리지 계층과 상호작용할 수 있다. 데이터는 (예를 들어, 사용자 컴퓨팅 시스템들, 서버들, 모바일 디바이스들, 이들의 조합 등으로부터) 시간이 지나면서 수집될 수 있고, RPA 로봇들은 이 데이터를 스토 리지 계층에 제공할 수 있다. 일부 실시예에서, ML 모델을 리트레이닝하기 위한 로직은 ML 모델의 거동에 기초한다. ML 모델들은 트레이닝/리 트레이닝에 사용되는 데이터가 ML 모델의 거동을 다양한 정도로 변화시킬 수 있는 데이터에 대해 상이한 민감도 를 갖는다. 또한, 하나의 ML 모델로부터 또 다른 모델로의 리트레이닝에 상이한 양의 데이터가 필요할 수 있다. 일부 ML 모델들은 몇 개의 샘플들 또는 데이터 포인트들을 사용하여 리트레이닝될 수 있는 반면, 다른 ML 모델 들은 효과적으로 트레이닝/리트레이닝되기 위해 수백, 수천, 수만, 또는 그 이상의 샘플들 또는 데이터 포인트 들을 필요로 할 수 있다. 또한, ML 모델들은 상이한 타입들의 트레이닝 데이터, 이를테면 수치 또는 텍스트 데 이터, 문서들, 스크린샷들, 이미지들 등을 필요로 할 수 있다. 일부 실시예에서, RPA 로봇이 스토리지가 어디에 있는지를 자동으로 알고 데이터를 업로드할 수 있게 하는 데이 터 푸시 액티비티(RPA 로봇의 워크플로우에 포함된다면)가 있다. 추가적으로 또는 대안적으로, RPA 로봇은 로컬 데이터 및/또는 원격 데이터베이스에 저장된 데이터를 통해 반복할 수 있고, 그 다음 이 데이터를 스토리지 계 층으로 송신할 수 있다. 그러나, 일부 실시예에서는, 인간이 애플리케이션(예를 들어, 데스크톱 애플리케이션, 웹 브라우저, 모바일 폰 애플리케이션 등)을 사용하고 그로부터 데이터를 업로드할 수 있다. 시간이 지나면서 스토리지 계층 내에 수집되는 데이터는 상이한 타입들의 데이터의 그룹화(예를 들어, 데이터세트들)가 가능할 수 있다. 유사한 타입들의 데이터는 논리적 또는 물리적으로 그룹화될 수 있다. 일부 실시예에서, 사용자들은 그들이 트레이닝시키려는 ML 모델을 선택하고, 그들이 ML 모델을 트레이닝시키려는 데이터세트(들)를 선택하며, 그들이 리트레이닝이 일어나기를 원하는 때(예를 들어, 요청시 또는 주기적으로) 를 선택할 수 있다. 일부 실시예에서, 데이터세트들은 ML 모델이 데이터세트에서의 데이터에 액세스하기 위한 포인터들로서 제시될 수 있다. ML 모델은 ML 모델이 마지막으로 트레이닝되었던 땐 이용 가능하지 않았던 더 새로운 데이터, 더 오래 된 데이터와 더 새로운 데이터의 조합, 전체 데이터세트 등에 기초하여 리트레이닝될 수 있다. ML 모델들은 새 로운 데이터가 획득됨에 따라 시간이 지나면서 더 정확해질 수 있다. 일부 실시예에서, 사용자들은 사용하고자 하는 성능 척도(들)를 선택할 수 있고, 시스템은 선택된 성능 척도(들)에 기초하여 리트레이닝된 ML 모델에 대한 하나 이상의 스코어를 생성한다. 스코어(들)가 향상된다면, 리트레이닝된 ML 모델은 사용자가 원한다면 자동으로 이전 버전 대신에 사용될 수 있다. 그렇지 않으면, 사용자 는 알림을 받고, 리트레이닝된 버전을 디플로이하는 것이 바람직한지 여부를 결정할 수 있다. 일부 실시예에서, 스코어의 변화는 시간이 지나면서 추적되어, 정확도의 향상과 감소 양자를 강조할 수 있다. 그 다음, 사용자 또 는 시스템은 부정적인 추이를 야기하는 원인이 무엇인지 파악하려고 시도할 수 있다. 일부 실시예에서, 사용되는 데이터의 양은 자동으로 조정될 수 있다. 예를 들어, 본 발명의 범위로부터 벗어나 지 않고, 데이터 포인트들의 수, 데이터가 수집되는 빈도, 수집되는 데이터의 양, 리트레이닝을 위한 트리거들, 및/또는 임의의 다른 적합한 트레이닝 파라미터들을 사용자들이 조정할 수 있게 하는 트레이닝 인터페이스가 제 공될 수 있다. 일부 실시예의 아키텍처는 지적 재산권(intellectual property, IP) 침해를 줄이거나 방지하는 것을 도울 수 있 다. 예를 들어, 일부 호스팅된 ML 모델들은 이용자들에 의해 제공되지 않을 수 있고 호스팅 아키텍처를 제공하 는 회사의 소유일 수 있다. 이들 ML 모델들은 단지 설명만으로 사용자들의 RPA 로봇들에 이용 가능하고 호출 가 능하게 될 수 있고, ML 모델들 자체는 사용자들 또는 호출 RPA 로봇들에 제공되지 않을 수 있다. 더 정확히 말 하면, ML 모델 실행의 결과들만 제공될 수 있다. 일부 실시예는 이용자 사이트들 상에서의 IP 침해를 줄이거나 방지할 수 있다. 예를 들어, ML 모델을 포함하는 Docker™ 컨테이너의 컨텐츠는 암호화 또는 난독화될 수 있고/거나, ML 모델 자체가 암호화될 수 있다. 이는 RPA 서비스 제공자가 RPA 서비스 제공자 소유 ML 모델들(포함된다면)이 복사되거나 리버스 엔지니어링(reverse engineering)될 위험이 적은 ML 운용 플랫폼을 이용자 사이트에 디플로이할 수 있게 할 수 있다. 일부 실시예에서, RPA를 위한 로우 코드 ML 모델 디플로이먼트 및 트레이닝 시스템이 제공될 수 있다. ML 패키 지들은 사용자들에 의한 코딩 없이 한 번의 클릭으로 디플로이될 수 있다. 예를 들어, 사용자들은 ML 모델들의 카탈로그로부터 선택하고 선택된 ML 모델들을 타겟 컴퓨팅 환경(예를 들어, 단일 노드 쿠버네티스(Kubernete) 설비, 다중 노드 설비 등) 상에 디플로이할 수 있다. 특정 실시예들에서, 사용자들은 버튼을 한 번 클릭하여 ML 모델들을 트레이닝할 수 있다. 이러한 실시예들은 사용자들에게 기술적 지식을 가질 것을 요구하지 않을 수 있 고, 사용자들은 수동 프로그래밍 없이 RPA 워크플로우에 이러한 기능을 플러깅할 수 있다. 일부 실시예에서, 사용자들은 다수의 ML 모델들을 함께 체이닝할 수 있다. 이는 특정 로직 또는 구성에 기초할 수 있다. ML 모델들의 네트워크는 인터페이스에서 사용자들에게 이용 가능하게 될 수 있으며, 가능하게는 가장 관련성이 높을 것으로 시스템이 결정한 ML 모델들이 제안된다. 예를 들어, 사용자가 버튼을 클릭하는 액티비티 에 대한 ML 모델을 추가하고자 한다면, 그래픽 요소 인식 ML 모델들이 제안될 수 있다. 그 다음, 사용자는 원하 는 결과를 달성하도록 ML 모델들을 선택하고 이들을 적절하게 체이닝할 수 있다. AI/ML 모델들의 체이닝은 클라이언트측에서, 서버측에서, 또는 양자에서 일어날 수 있다. 클라이언트측 체이닝 에 대해, RPA 개발자는 RPA 워크플로우로 체이닝 로직을 수동으로 개발할 수 있다. 예를 들어, RPA 개발자는 하 나의 AI/ML 모델을 호출하는 액티비티를 포함할 수 있고, 결과들을 또 다른 AI/ML 모델에 공급하는 시퀀스의 또 다른 액티비티에 모델 실행 결과들을 공급할 수 있는 등이다. 서버측에서, 서로 연결될 수 있는 AI/ML 모델들이 그래프에 제공될 수 있거나, 다수의 AI/ML 모델들을 함께 연 결할 수 있는 워크플로우가 생성될 수 있다. 예를 들어, 사용자는 AI/ML 모델들을 그래프로 볼 수 있고, 자신이 원하는 대로 이들을 함께 체이닝할 수 있다. 클라이언트측 및 서버측 체이닝 양자에 대해, 사용자들은 AI/ML 모 델 직렬 연결들, 병렬 연결들, 또는 이들의 조합을 생성할 수 있다. 일부 실시예에서, ML 운용 플랫폼의 기능은 하나의 컴퓨팅 시스템(예를 들어, 단일 서버) 상에 포함될 수 있다. 이러한 컴퓨팅 시스템은 예를 들어, RPA 서비스 제공자에 의해 원격으로 호스팅되기보다는, 클라이언트 사이트 상에 위치될 수 있다. 이러한 컴퓨팅 시스템은 그렇지 않으면 호스팅된 클라우드 시스템 상에 제공될 수 있는 기능을 로컬로 제공할 수 있다는 의미에서 \"클라우드형(cloud-like)\" 기능을 제공할 수 있다. 이러한 실시예들 은 특정 건강 관리 애플리케이션, 금융 서비스 애플리케이션 등과 같은, 규제 또는 보안상 이유들로 컴퓨팅 시 스템이 공공 설비를 사용하지 않아야 하는(off the grid) 에어 갭(air gap) 시나리오들에 특히 유용할 수 있다. 이러한 시나리오들에서, 특정 권한이 있는 사용자들 및/또는 다른 컴퓨팅 시스템들이 ML 운용 플랫폼을 제공하 는 컴퓨팅 시스템에 액세스할 수 있다. 일부 실시예에서, 사용자들이 트레이닝/리트레이닝을 위한 데이터를 마킹/라벨링할 수 있는 라벨링 툴을 갖는 애플리케이션이 제공될 수 있다. 그 다음, 라벨링된 데이터는 트레이닝/리트레이닝을 위한 데이터세트로 푸시될 수 있다. 사용자들이 데이터를 검증할 수 있는 검증 기능들도 또한 제공될 수 있다. 도 1은 본 발명의 일 실시예에 따른, RPA 시스템을 도시하는 구성도이다. RPA 시스템은 개발자가 워 크플로우들을 설계 및 구현할 수 있게 하는 디자이너를 포함한다. 디자이너는 애플리케이션 통합뿐만 아니라, 서드 파티 애플리케이션들, 관리용 정보 기술(IT) 작업들, 및 비즈니스 IT 프로세스들을 오토메이션하 기 위한 솔루션을 제공할 수 있다. 디자이너는 오토메이션 프로젝트의 개발을 가능하게 할 수 있으며, 이 는 비즈니스 프로세스의 그래픽 표현이다. 간단히 말하면, 디자이너는 워크플로우들 및 로봇들의 개발 및디플로이먼트를 가능하게 한다. 오토메이션 프로젝트는 워크플로우로 개발되는 커스텀 단계들 - 본원에서 \"액티비티들\"로서 정의됨 - 의 세트 사이의 실행 순서 및 관계에 대한 제어 권한을 개발자에게 부여함으로써 규칙 기반 프로세스들의 오토메이션을 가능하게 한다. 디자이너의 일 실시예의 하나의 상용례는 UiPath Studio™이다. 각 액티비티는 버튼을 클 릭하는 것, 파일을 읽는 것, 로그 패널에 쓰는 것 등과 같은 액션을 포함할 수 있다. 일부 실시예에서, 워크플 로우들은 네스트되거나(nested) 임베드될(embedded) 수 있다. 워크플로우들의 일부 타입들은 시퀀스들, 흐름도들, 유한 상태 머신(Finite State Machine; FSM)들, 및/또는 전 역 예외 처리기들을 포함할 수 있지만, 이에 제한되지 않는다. 시퀀스들은 워크플로우를 클러터링하지 않고 한 액티비티로부터 또 다른 액티비티로의 흐름을 가능하게 하여, 선형 프로세스들에 특히 적합할 수 있다. 흐름도 들은 다중 분기 논리 연산자들을 통해 보다 다양한 방식으로 결정들의 통합 및 액티비티들의 연결을 가능하게 하여, 보다 복잡한 비지니스 로직에 특히 적합할 수 있다. FSM들은 대규모 워크플로우들에 특히 적합할 수 있다. FSM들은 실행에, 조건(즉, 전환) 또는 액티비티에 의해 트리거되는 유한 개의 상태를 사용할 수 있다. 전 역 예외 처리기들은 실행 오류가 발생할 때 워크플로우 거동을 결정하고 프로세스들을 디버깅하는 데 특히 적합 할 수 있다. 디자이너에서 워크플로우가 개발되면, 컨덕터에 의해 비즈니스 프로세스들의 실행이 오케스트레이션 되며, 이 컨덕터는 디자이너에서 개발된 워크플로우들을 실행하는 하나 이상의 로봇을 오케스트레이 션한다. 컨덕터의 일 실시예의 하나의 상용례는 UiPath Orchestrator™이다. 컨덕터는 환경에서 리소 스들의 생성, 모니터링, 및 디플로이먼트의 관리를 가능하게 한다. 컨덕터는 또한 서드 파티 솔루션들 및 애플리케이션들과의 통합 지점으로서의 역할을 할 수 있다. 컨덕터는 로봇들을 중앙 집중 지점으로부터 연결 및 실행하여, 로봇 전체를 관리할 수 있다. 관 리될 수 있는 로봇들의 타입들은 협업 로봇(attended robot)들, 무인 로봇(unattended robot)들 , 개발 로봇들(무인 로봇들과 유사하나, 개발 및 테스트를 위해 사용됨), 및 비생산 로봇 (nonproduction robot)들(협업 로봇들과 유사하나, 개발 및 테스트를 위해 사용됨)을 포함하지만, 이에 제 한되지 않는다. 협업 로봇들은 사용자 이벤트들에 의해 트리거되고 동일한 컴퓨팅 시스템 상에서 인간과 함께 동작한다. 협업 로봇들은 중앙 집중화된 프로세스 디플로이먼트 및 로깅 매체에 컨덕터와 함께 사용될 수 있다. 협업 로봇들은 인간 사용자가 다양한 작업들을 실현하는 것을 도울 수 있고, 사용자 이벤 트들에 의해 트리거될 수 있다. 일부 실시예에서, 프로세스들은 이러한 타입의 로봇 상에서 컨덕터로부터 시작될 수 없고/거나 프로세스들은 스크린이 잠긴 상태에서 실행될 수 없다. 특정 실시예에서, 협업 로봇 은 단지 로봇 트레이로부터 또는 커맨드 프롬프트로부터만 시작될 수 있다. 일부 실시예에서, 협업 로봇들(13 2)은 인간의 감독 하에서 실행되어야 한다. 무인 로봇들은 가상 환경들에서 무인으로 실행되고 많은 프로세스들을 오토메이션할 수 있다. 무인 로봇들 은 작업 큐들에 대한 원격 실행, 모니터링, 스케줄링, 및 지원 제공을 담당할 수 있다. 일부 실시예에서, 모든 로봇 타입들에 대한 디버깅은 디자이너에서 실행될 수 있다. 협업 로봇 및 무인 로봇 양자는 메인프 레임, 웹 애플리케이션, VM, 엔터프라이즈 애플리케이션(예를 들어, SAP®, SalesForce®, Oracle® 등에 의해 제 작된 것들), 및 컴퓨팅 시스템 애플리케이션(예를 들어, 데스크탑 및 랩탑 애플리케이션, 모바일 디바이스 애플 리케이션, 웨어러블 컴퓨터 애플리케이션 등)을 포함하는 다양한 시스템들 및 애플리케이션들을 오토메이션할 수 있지만, 이에 제한되지 않는다. 컨덕터는 프로비저닝(provisioning), 디플로이먼트, 구성(configuration), 큐잉(queue), 모니터링, 로깅, 및/또는 상호연결(interconnectivity) 제공을 포함하는 다양한 기능들을 가질 수 있지만, 이에 제한되지 않는다. 프로비저닝은 로봇과 컨덕터(예를 들어, 웹 애플리케이션) 사이의 연결들의 생성 및 유지 보 수를 포함할 수 있다. 디플로이먼트는 실행을 위해 패키지 버전들의 할당된 로봇으로의 정확한 전달을 보 장하는 것을 포함할 수 있다. 구성은 로봇 환경들 및 프로세스 구성들의 유지 보수 및 전달을 포함할 수 있다. 큐잉은 큐들 및 큐 항목들의 관리를 제공하는 것을 포함할 수 있다. 모니터링은 로봇 식별 데이터를 추적하는 것과 사용자 권한을 유지하는 것을 포함할 수 있다. 로깅은 데이터베이스(예를 들어, SQL 데이터베이스) 및/또 는 또 다른 스토리지 메커니즘(예를 들어, ElasticSearch® - 이는 대용량 데이터세트들을 저장하고 신속하게 질 의할 수 있는 능력을 제공함)에 로그들을 저장하는 것과 인덱싱하는 것을 포함할 수 있다. 컨덕터는 서드 파티 솔루션들 및/또는 애플리케이션들에 대한 통신의 중앙 집중 지점으로서의 역할을 함으로써 상호연결을 제공할 수 있다. 로봇들은 디자이너에서 구축된 워크플로우들을 실행하는 실행 에이전트들이다. 로봇(들)의 일 부 실시예의 하나의 상용례는 UiPath Robots™이다. 일부 실시예에서, 로봇들은 Microsoft Windows® 서비 스 제어 관리자(Service Control Manager, SCM) 관리 서비스를 디폴트로 설치한다. 그 결과, 이러한 로봇들 은 로컬 시스템 계정 하에서 대화형 Windows® 세션들을 열 수 있고, Windows® 서비스의 권한들을 가질 수 있다. 일부 실시예에서, 로봇들은 사용자 모드로 설치될 수 있다. 이러한 로봇들에 대해, 이는 로봇들이 소 정의 로봇이 설치된 사용자 모드와 동일한 권한들을 가진다는 것을 의미한다. 이러한 특징은 또한 고밀도 (High Density, HD) 로봇들에도 이용 가능할 수 있으며, 이는 각 머신의 최대 잠재력에서의 완전한 활용을 보장 한다. 일부 실시예에서, 임의의 타입의 로봇은 HD 환경에서 구성될 수 있다. 일부 실시예에서, 로봇들은 각각이 특정 오토메이션 작업에 전용되는 몇몇 컴포넌트들로 나뉜다. 일부 실 시예에서, 로봇 컴포넌트들은 SCM 관리 로봇 서비스들, 사용자 모드 로봇 서비스들, 실행기들, 에이전트들, 및 커맨드 라인을 포함하지만, 이에 제한되지 않는다. SCM 관리 로봇 서비스들은 Windows® 세션들을 관리 및 모니 터링하고, 컨덕터와 실행 호스트들(즉, 로봇들이 실행되는 컴퓨팅 시스템들) 사이의 프록시로서의 역 할을 한다. 이러한 서비스들은 로봇들에 대한 자격 증명들로 신뢰되고 그 자격 증명들을 관리한다. 로컬 시스템 하에서 SCM에 의해 콘솔 애플리케이션이 론칭된다. 일부 실시예에서, 사용자 모드 로봇 서비스들이 Windows® 세션들을 관리 및 모니터링하고, 컨덕터와 실행 호스트들 사이의 프록시로서의 역할을 한다. 사용자 모드 로봇 서비스들은 로봇에 대한 자격 증명들로 신 뢰될 수 있고 그 자격 증명들을 관리할 수 있다. SCM 관리 로봇 서비스가 설치되지 않은 경우 Windows® 애플리 케이션이 자동으로 론칭될 수 있다. 실행기들은 Windows® 세션 하에서 소정의 작업들을 실행할 수 있다(즉, 실행기들은 워크플로우들을 실행할 수 있다). 실행기들은 각 모니터에 대한 DPI(dots per inch) 설정들을 인식할 수 있다. 에이전트들은 시스템 트레 이 윈도우에서 이용 가능한 작업들을 디스플레이하는 Windows® Presentation Foundation(WPF) 애플리케이션들일 수 있다. 에이전트들은 서비스의 클라이언트일 수 있다. 에이전트들은 작업들을 시작 또는 중지하고 설정들을 변경할 것을 요청할 수 있다. 커맨드 라인은 서비스의 클라이언트이다. 커맨드 라인은 작업들을 시작할 것을 요 청할 수 있고 작업들의 출력을 대기하는 콘솔 애플리케이션이다. 위에서 설명된 바와 같이 로봇들의 컴포넌트들을 나누는 것은 개발자들이 사용자들을 지원하고, 컴퓨팅 시 스템들이 각 컴포넌트가 실행하고 있는 것을 보다 쉽게 실행하고, 식별하며, 추적하는 것을 돕는다. 실행기 및 서비스에 대한 상이한 방화벽 규칙들을 설정하는 것과 같은 특수한 거동들이 이러한 방식으로 컴포넌트마다 구 성될 수 있다. 일부 실시예에서, 실행기는 모니터에 대한 DPI 설정들을 항상 인식할 수 있다. 그 결과, 워크플 로우들은 자신들이 생성되었던 컴퓨팅 시스템의 구성에 관계없이, 임의의 DPI에서 실행될 수 있다. 일부 실시예 에서, 디자이너로부터의 프로젝트들이 또한 브라우저 줌 레벨에 독립적일 수 있다. DPI를 인식하지 못하거 나 의도적으로 미인식으로서 마킹된 애플리케이션들에 대해, 일부 실시예에서, DPI는 디스에이블될 수 있다. 도 2는 본 발명의 일 실시예에 따른, 디플로이된 RPA 시스템을 도시하는 구성도이다. 일부 실시예에서, RPA 시스템은 도 1의 RPA 시스템일 수 있거나, 또는 이의 일부일 수 있다. 클라이언트측, 서버측, 또 는 양자는 본 발명의 범위로부터 벗어나지 않고, 임의의 요구되는 수의 컴퓨팅 시스템을 포함할 수 있다는 점을 유의해야 한다. 클라이언트측에서, 로봇 애플리케이션은 실행기들, 에이전트, 및 디자이너(21 6)를 포함한다. 그러나, 일부 실시예에서, 디자이너는 동일한 컴퓨팅 시스템 상에서 실행되고 있지 않을 수 있다. 실행기들은 프로세스들을 실행하고 있다. 도 2에 도시된 바와 같이, 여러 비지니스 프로젝 트들이 동시에 실행될 수 있다. 이러한 실시예에서, 에이전트(예를 들어, Windows® 서비스)는 모든 실행기 들에 대한 단일 접촉 지점이다. 이 실시예에서의 모든 메시지들은 컨덕터로 로깅되며, 이 컨덕터는 메시지들을 데이터베이스 서버, 인덱서 서버, 또는 양자를 통해 추가로 처리한다. 도 1과 관련하여 상술한 바와 같이, 실행기들은 로봇 컴포넌트들일 수 있다. 일부 실시예에서, 로봇은 머신명과 사용자명 사이의 연관을 나타낸다. 로봇은 다수의 실행기들을 동시에 관리할 수 있다. 동시에 실행되는 다수의 쌍방향 세션들을 지원하는 컴퓨팅 시스템들(예를 들어, Windows® 서버) 상에서, 다수의 로봇들은 각각 별개의 Windows® 세션에서 고유한 사용자명을 사용하여 동시에 실행될 수 있다. 이는 위에서 HD 로봇들로서 지칭된다. 에이전트는 또한 로봇의 상황을 송신(예를 들어, 로봇이 계속해서 기능하고 있음을 나타내는 \"하트비트 (heartbeat)\" 메시지를 주기적으로 송신)하는 것과, 실행될 패키지의 필수 버전을 다운로드하는 것을 담당한다. 일부 실시예에서, 에이전트와 컨덕터 사이의 통신은 항상 에이전트에 의해 개시된다. 알림 시나 리오에서, 에이전트는 커맨드들(예를 들어, 시작, 정지 등)을 로봇에 송신하기 위해 나중에 컨덕터에 의해 사용되는 웹소켓(WebSocket) 채널을 열 수 있다. 서버측 상에는, 표현 계층(웹 애플리케이션, 오픈 데이터 프로토콜(Open Data Protocol, OData) 대표 상황 전달(Representative State Transfer, REST) 애플리케이션 프로그래밍 인터페이스(Application Programming Interface, API) 엔드포인트들, 및 알림 및 모니터링 API), 서비스 계층(API 구현/비즈니스 로직 ), 및 영구 계층(데이터베이스 서버 및 인덱서 서버)이 포함된다. 컨덕터는 웹 애플리케이 션, OData REST API 엔드포인트들, 알림 및 모니터링, 및 API 구현/비즈니스 로직을 포함 한다. 일부 실시예에서, 사용자가 (예를 들어, 브라우저를 통해) 컨덕터의 인터페이스에서 수행하는 대부분의 액션들은 다양한 API들을 호출함으로써 수행된다. 이러한 액션들은 본 발명의 범위로부터 벗어나지 않 고, 로봇들에 대한 작업들을 시작하는 것, 큐들에 데이터를 추가하는 것/제거하는 것, 무인으로 실행할 작업들 을 스케줄링하는 것 등을 포함할 수 있지만, 이에 제한되지 않는다. 웹 애플리케이션은 서버 플랫폼의 시 각 계층이다. 이러한 실시예에서, 웹 애플리케이션은 하이퍼텍스트 마크업 언어(Hypertext Markup Language, HTML) 및 자바 스크립트(JavaScript, JS)를 사용한다. 그러나, 본 발명의 범위로부터 벗어나지 않고, 임의의 요구되는 마크업 언어들, 스크립트 언어들, 또는 임의의 다른 포맷들이 사용될 수 있다. 이러한 실시예 에서, 사용자는 컨덕터를 제어하는 다양한 액션들을 수행하기 위해 브라우저를 통해 웹 애플리케이션 으로부터의 웹 페이지들과 상호작용한다. 예를 들어, 사용자는 로봇 그룹들을 생성하고, 로봇들에 패키지 들을 부여하고, 로봇마다 그리고/또는 프로세스마다 로그들을 분석하며, 로봇들을 시작 및 정지시키는 등을 할 수 있다. 컨덕터는 웹 애플리케이션 외에, OData REST API 엔드포인트들을 노출시키는 서비스 계층을 또 한 포함한다. 그러나, 본 발명의 범위로부터 벗어나지 않고, 다른 엔드포인트들이 포함될 수 있다. REST API는 웹 애플리케이션과 에이전트 양자에 의해 이용된다. 이러한 실시예에서, 에이전트는 클라이언트 컴퓨터 상의 하나 이상의 로봇의 감독자이다. 이러한 실시예에서, REST API는 구성, 로깅, 모니터링, 및 큐잉 기능을 커버한다. 일부 실시예에서, 구성 엔드 포인트들은 애플리케이션 사용자, 권한, 로봇, 에셋, 릴리스, 및 환경을 정의 및 구성하기 위해 사용될 수 있다. 로깅 REST 엔드포인트들은 예를 들어, 오류, 로봇에 의해 송신된 명시적 메시지, 및 다른 환경 특정 정보 와 같은 상이한 정보를 로깅하기 위해 사용될 수 있다. 디플로이먼트 REST 엔드포인트들은 컨덕터에서 시 작 작업 커맨드가 사용되는 경우 실행되어야 하는 패키지 버전을 질의하기 위해 로봇들에 의해 사용될 수 있다. 큐잉 REST 엔드포인트들은 큐들 및 큐 항목 관리, 이를테면 큐에 데이터를 추가하는 것, 큐로부터 트랜잭션을 획득하는 것, 트랜잭션의 상황을 설정하는 것 등을 담당할 수 있다. 모니터링 REST 엔드포인트들은 웹 애플리케이션 및 에이전트를 모니터링할 수 있다. 알림 및 모니터 링 API는 에이전트를 등록하고, 에이전트에 구성 설정들을 전달하며, 서버 및 에이전트로 부터 알림들을 송신/수신하는 데 사용되는 REST 엔드포인트들일 수 있다. 일부 실시예에서, 알림 및 모니터링 API는 또한 웹소켓 통신을 사용할 수 있다. 이러한 실시예에서, 영구 계층은 한 쌍의 서버들 - 데이터베이스 서버(예를 들어, SQL 서버) 및 인덱서 서 버 - 을 포함한다. 이러한 실시예에서, 데이터베이스 서버는 로봇들, 로봇 그룹들, 관련 프로세스들, 사용자들, 역할들, 스케줄들 등의 구성을 저장한다. 일부 실시예에서, 이러한 정보는 웹 애플리케이션을 통해 관리된다. 데이터베이스 서버는 큐들 및 큐 항목들을 관리할 수 있다. 일부 실시예에서, 데이터베이 스 서버는 (인덱서 서버에 추가하여 또는 인덱서 서버 대신에) 로봇들에 의해 로깅된 메시지들 을 저장할 수 있다. 인덱서 서버 - 일부 실시예에서, 임의 사항임 - 는 로봇들에 의해 로깅된 정보를 저장 및 인덱싱한다. 특 정 실시예들에서, 인덱서 서버는 구성 설정들을 통해 디스에이블될 수 있다. 일부 실시예에서, 인덱서 서버는 ElasticSearch® - 이는 오픈 소스 프로젝트 풀 텍스트 검색 엔진임 - 를 사용한다. (예를 들어, 메시 지 로깅 또는 행 쓰기와 같은 액티비티들을 사용하여) 로봇들에 의해 로깅된 메시지들은 로깅 REST 엔드포인트 (들)를 통해 인덱서 서버로 송신될 수 있으며, 여기서 로깅된 메시지들이 추후 이용을 위해 인덱싱된다. 도 3은 본 발명의 일 실시예에 따른, 디자이너, 액티비티들(320, 330), 드라이버들, 및 AI/ML 모델들 사이의 관계를 도시한 구성도이다. 상술한 바에 따라, 개발자는 디자이너를 사용하여 로봇들에 의해 실행되는 워크플로우들을 개발한다. 워크플로우들은 사용자 정의 액티비티들 및 UI 오토메이션 액티 비티들을 포함할 수 있다. 일부 실시예에서, 사용자 정의 액티비티들 및/또는 UI 오토메이션 액티비 티들은 로봇이 동작하고 있는 컴퓨팅 시스템에 로컬로 그리고/또는 원격으로 위치될 수 있는 하나 이상의 AI/ML 모델을 호출할 수 있다. 일부 실시예는 이미지에서의 비-텍스트 시각적 컴포넌트들을 식별할 수 있 으며, 이는 본원에서 컴퓨터 시각(computer vision, CV)이라고 지칭된다. 이러한 컴포넌트들과 관련된 일부 CV 액티비티들은 클릭(click), 타입(type), 텍스트 가져오기(get text), 호버(hover), 요소 존재 여부 확인 (element exist), 범위 새로고침(refresh scope), 강조 표시(highlight) 등을 포함할 수 있지만, 이에 제한되 지 않는다. 일부 실시예에서, 클릭은 예를 들어, CV, 광학적 문자 인식(optical character recognition, OCR), 퍼지 텍스트 매칭, 및 다중 앵커(multi-anchor)를 사용하여 요소를 식별하고, 이를 클릭한다. 타입(type)은 상 기한 것들을 사용하여 요소를 식별하고, 요소에서의 타입들을 식별할 수 있다. 텍스트 가져오기(get text)는 특 정 텍스트의 위치를 식별하고, OCR을 사용하여 이를 스캔할 수 있다. 호버(hover)는 요소를 식별하고, 그 위에 호버링할 수 있다. 요소 존재 여부 확인(element exist)은 상술된 기법들을 사용하여 스크린 상에 요소가 존재 하는지 여부를 검사할 수 있다. 일부 실시예에서, 디자이너에서 수백 또는 심지어 수천의 액티비티들이 구 현될 수 있다. 그러나, 본 발명의 범위로부터 벗어나지 않고, 임의의 수 및/또는 타입의 액티비티가 이용 가능 할 수 있다. UI 오토메이션 액티비티들은 보다 하위 레벨 코드로 작성되는 특수 하위 레벨 액티비티들의 서브세트(예를 들어, CV 액티비티들)이고 스크린과의 상호작용들을 가능하게 한다. UI 오토메이션 액티비티들은 로봇이 원하는 소프트웨어와 상호작용할 수 있게 하는 드라이버들 및/또는 AI/ML 모델들을 통해 이러한 상호작용 들을 가능하게 한다. 예를 들어, 드라이버들은 OS 드라이버들, 브라우저 드라이버들, VM 드라이 브들, 엔터프라이즈 애플리케이션 드라이버들 등을 포함할 수 있다. AI/ML 모델들 중 하나 이상 은 컴퓨터 시스템과의 상호작용들을 결정하기 위해 UI 오토메이션 액티비티들에 의해 사용될 수 있다. 일 부 실시예에서, AI/ML 모델들은 드라이버들을 보강하거나 완전히 대체할 수 있다. 실제로, 특정 실시 예들에서, 드라이버들은 포함되지 않는다. 드라이버들은 후크들(hooks)을 찾고, 키들을 모니터링하는 등 하위 레벨에서 OS와 상호작용할 수 있다. 이 것들은 Chrome®, IE®, Citrix®, SAP® 등과의 통합을 가능하게 할 수 있다. 예를 들어, \"클릭\" 액티비티는 드라 이버들을 통해 이들 상이한 애플리케이션들에서 동일한 역할을 수행한다. 도 4는 본 발명의 일 실시예에 따른, RPA 시스템을 도시하는 구성도이다. 일부 실시예에서, RPA 시스템 은 도 1 및/또는 도 2의 RPA 시스템(100 및/또는 200)일 수 있거나, 또는 이를 포함할 수 있다. RPA 시스 템은 로봇들을 실행하는 다수의 클라이언트 컴퓨팅 시스템들을 포함한다. 컴퓨팅 시스템들은 컨 덕터 컴퓨팅 시스템 상에서 실행되는 웹 애플리케이션을 통해 이와 통신할 수 있다. 차례로, 컨덕터 컴퓨 팅 시스템은 데이터베이스 서버 및 임의 사항인 인덱서 서버와 통신할 수 있다. 도 1 및 도 3과 관련하여, 이러한 실시예들에서 웹 애플리케이션이 사용되지만, 본 발명의 범위로부터 벗어나지 않고, 임의의 적합한 클라이언트/서버 소프트웨어가 사용될 수 있다는 점을 유념해야 한다. 예를 들어, 컨덕터 는 클라이언트 컴퓨팅 시스템들 상의 웹 기반이 아닌 클라이언트 소프트웨어 애플리케이션들과 통신하는 서버측 애플리케이션을 실행할 수 있다. 도 5는 본 발명의 일 실시예에 따른, AI/ML 모델들을 호스팅, 모니터링, 및 리트레이닝하거나, 또는 이를 행하 는 시스템의 일부로서 동작하도록 구성된 컴퓨팅 시스템을 도시한 구성도이다. 일부 실시예에서, 컴퓨팅 시스템은 본원에서 도시되고/거나 설명되는 컴퓨팅 시스템들 중 하나 이상일 수 있다. 컴퓨팅 시스템(50 0)은 정보를 통신하기 위한 버스 또는 다른 통신 메커니즘, 및 정보를 처리하기 위해 버스에 커플링 되는 프로세서(들)를 포함한다. 프로세서(들)는 중앙 처리 장치(CPU), 주문형 반도체(ASIC), 필드 프 로그래머블 게이트 어레이(FPGA), 그래픽 처리 장치(GPU), 이들의 다수의 인스턴스들, 및/또는 이들의 임의의 조합을 포함하여, 임의의 타입의 범용 또는 특수 목적 프로세서일 수 있다. 또한, 프로세서(들)는 다수의 처리 코어들을 가질 수 있고, 코어들 중 적어도 일부는 특정 기능들을 수행하도록 구성될 수 있다. 일부 실시예에서, 다중 병렬 처리가 사용될 수 있다. 특정 실시예들에서, 프로세서(들) 중 적어도 하나는 생물학적 뉴 런들을 모방하는 처리 요소들을 포함하는 뉴로모픽 회로일 수 있다. 일부 실시예에서, 뉴로모픽 회로들은 폰 노 이만 컴퓨팅 아키텍처의 전형적인 컴포넌트들을 필요로 하지 않을 수 있다. 컴퓨팅 시스템은 프로세서(들)에 의해 실행될 정보 및 명령어들을 저장하기 위한 메모리를 더 포함한다. 메모리는 랜덤 액세스 메모리(RAM), 판독 전용 메모리(ROM), 플래시 메모리, 캐시, 자기 또는 광학 디스크와 같은 정적 스토리지, 또는 임의의 다른 타입들의 비일시적인 컴퓨터 판독 가능 매체들 또는 이들 의 조합들의 임의의 조합으로 구성될 수 있다. 비일시적인 컴퓨터 판독 가능 매체들은 프로세서(들)에 의 해 액세스될 수 있는 임의의 이용 가능한 매체들일 수 있고, 휘발성 매체들, 비휘발성 매체들, 또는 양자를 포 함할 수 있다. 매체들은 또한 착탈식, 비착탈식, 또는 양자일 수 있다. 또한, 컴퓨팅 시스템은 무선 및/또는 유선 연결을 통해 통신 네트워크에 액세스할 수 있기 위해 트랜스시 버와 같은 통신 디바이스를 포함한다. 일부 실시예에서, 통신 디바이스는 본 발명의 범위로부터 벗어 나지 않고, 주파수 분할 다중 액세스(FDMA), 단일 캐리어 FDMA(SC-FDMA), 시분할 다중 액세스(TDMA), 코드 분할 다중 액세스(CDMA), 직교 주파수 분할 다중화(OFDM), 직교 주파수 분할 다중 액세스(OFDMA), 모바일용 글로벌 시스템(GSM) 통신, 일반 패킷 라디오 서비스(GPRS), 유니버셜 모바일 통신 시스템(UMTS), cdma2000, 광대역 CDMA(W-CDMA), 고속 다운링크 패킷 액세스(HSDPA), 고속 업링크 패킷 액세스(HSUPA), 고속 패킷 액세스(HSPA), 롱텀 에볼루션(LTE), LTE 어드밴스트(LTE-A), 802.11x, Wi-Fi, 지그비(Zigbee), 초광대역(UWB), 802.16x, 802.15, 홈 노드-B(HnB), 블루투스(Bluetooth), 라디오 주파수 식별(RFID), 적외선 데이터 통신(IrDA), 근거리 통신(NFC), 제5 세대(5G), 엔알(NR: New Radio), 이들의 임의의 조합, 및/또는 임의의 다른 현재 존재하거나 미 래에 구현될 통신 표준 및/ 또는 프로토콜을 사용하도록 구성될 수 있다. 일부 실시예에서, 통신 디바이스(52 0)는 본 발명의 범위로부터 벗어나지 않고, 개별, 배열, 위상, 스위칭, 빔포밍, 빔스티어링, 이들의 조합, 및/ 또는 임의의 다른 안테나 구성인 하나 이상의 안테나를 포함할 수 있다. 프로세서(들)는 또한, 버스를 통해 디스플레이, 이를테면 플라즈마 디스플레이, 액정 디스플레 이(LCD), 발광 다이오드(LED) 디스플레이, 전계 방출 디스플레이(FED), 유기 발광 다이오드 (OLED) 디스플레이, 플렉시블 OLED 디스플레이, 플렉서블 기판 디스플레이, 투사 디스플레이, 4K 디스플레이, 고화질 디스플레이, Retina® 디스플레이, 평면 정렬 스위칭(IPS) 디스플레이, 또는 사용자에게 정보를 디스플레이하기 위한 임의의 다른 적합한 디스플레이에 커플링된다. 디스플레이는 저항성, 용량성, 표면 탄성파(SAW) 용량성, 적외선, 광학 이미징, 분산 신호 기술, 음향 펄스 인식, 좌절된 내부 전반사 등을 사용하여 터치 (햅틱) 디스플레이, 3 차원(3D) 터치 디스플레이, 다중 입력 터치 디스플레이, 다중 터치 디스플레이 등으로서 구성될 수 있다. 본 발 명의 범위로부터 벗어나지 않고, 임의의 적합한 디스플레이 디바이스 및 햅틱 I/O가 사용될 수 있다. 키보드 및 커서 제어 디바이스, 이를테면 컴퓨터 마우스, 터치패드 등은 또한, 사용자가 컴퓨팅 시스 템과 인터페이스할 수 있게 하기 위해 버스에 커플링된다. 그러나, 특정 실시예들에서, 물리적 키보드 및 마우스는 존재하지 않을 수 있고, 사용자는 단지 디스플레이 및/또는 터치패드(도시되지 않음)를 통해 디 바이스와 상호작용할 수 있다. 임의의 타입 및 조합의 입력 디바이스들이 설계 선택의 문제로서 사용될 수 있다. 특정 실시예들에서는, 어떠한 물리적 입력 디바이스 및/또는 디스플레이도 존재하지 않는다. 예를 들어, 사용자는 컴퓨팅 시스템과 통신하는 또 다른 컴퓨팅 시스템을 통해 컴퓨팅 시스템과 원격으로 상호작용할 수 있거나, 또는 컴퓨팅 시스템이 자율적으로 동작할 수 있다. 메모리는 프로세서(들)에 의해 실행될 때 기능을 제공하는 소프트웨어 모듈들을 저장한다. 모듈들은 컴퓨팅 시스템을 위한 운영 체제를 포함한다. 모듈들은 본원에서 설명되는 프로세스들 또는 이의 파 생물들의 전부 또는 일부를 수행하도록 구성된 AI/ML 모델 호스팅, 모니터링, 및 리트레이닝 모듈을 더 포 함한다. 컴퓨팅 시스템은 추가 기능을 포함하는 하나 이상의 추가 기능 모듈을 포함할 수 있다. 당업자는 \"시스템\"이 본 발명의 범위로부터 벗어나지 않고, 서버, 임베디드 컴퓨팅 시스템, 개인용 컴퓨터, 콘 솔, 개인용 정보 단말기(PDA), 휴대 전화, 태블릿 컴퓨팅 디바이스, 양자 컴퓨팅 시스템, 또는 임의의 다른 적 합한 컴퓨팅 디바이스, 또는 디바이스들의 조합으로서 구현될 수 있다는 것을 이해할 것이다. 상술된 기능들을 \"시스템\"에 의해 수행되는 것으로서 제시하는 것은 본 발명의 범위를 어떠한 식으로도 제한하려는 것이 아니라, 본 발명의 많은 실시예들의 일례를 제공하려는 것이다. 실제로, 본원에서 개시되는 방법들, 시스템들, 및 장치 들은 클라우드 컴퓨팅 시스템들을 포함하여, 컴퓨팅 기술에 부합하는 로컬 및 분산 형태들로 구현될 수 있다. 컴퓨팅 시스템은 근거리 네트워크(LAN), 이동 통신 네트워크, 위성 통신 네트워크, 인터넷, 퍼블릭 또는 프라이 빗 클라우드, 하이브리드 클라우드, 서버 팜, 이들의 임의의 조합 등의 일부일 수 있거나 그 외 이들에 의해 액세스 가능할 수 있다. 본 발명의 범위로부터 벗어나지 않고, 임의의 로컬 또는 분산 아키텍처가 사용될 수 있다. 본 명세서에서 설명되는 시스템 특징들 중 일부는 이들의 구현 독립성을 특히 더 강조하기 위해, 모듈들로서 제 시되었다는 점을 유념해야 한다. 예를 들어, 모듈은 커스텀 초고밀도 집적(VLSI) 회로들 또는 게이트 어레이들, 기성 반도체들 이를테면 로직 칩들, 트랜지스터들, 또는 다른 개별 컴포넌트들을 포함하는 하드웨어 회로로서 구현될 수 있다. 모듈은 또한 필드 프로그래머블 게이트 어레이들, 프로그래머블 어레이 로직, 프로그래머블 로 직 디바이스들, 그래픽 처리 장치들 등과 같은 프로그래머블 하드웨어 디바이스들로 구현될 수도 있다. 모듈은 또한 다양한 타입들의 프로세서들에 의한 실행을 위해 소프트웨어로 적어도 부분적으로 구현될 수도 있 다. 실행 가능 코드의 식별 유닛은 예를 들어, 객체, 절차, 또는 기능으로서 조직화될 수 있는 컴퓨터 명령어들 의 하나 이상의 물리적 또는 논리적 블록을 포함할 수 있다. 그럼에도 불구하고, 식별된 모듈의 실행 가능 코드 들은 물리적으로 함께 위치될 필요는 없고, 상이한 위치들에 저장된 이질적인 명령어들 - 이는 논리적으로 함께 결합될 때 모듈을 포함하고 모듈에 대해 언급된 목적을 달성함 - 를 포함할 수 있다. 또한, 모듈들은 본 발명의 범위로부터 벗어나지 않고, 예를 들어, 하드 디스크 드라이브, 플래시 디바이스, RAM, 테이프, 및/또는 데이터 를 저장하는 데 사용되는 임의의 다른 상기한 비일시적인 컴퓨터 판독 가능 매체일 수 있는 컴퓨터 판독 가능 매체에 저장될 수 있다. 실제로, 실행 가능 코드의 모듈은 단일 명령어, 또는 많은 명령어들일 수 있고, 여러 상이한 코드 세그먼트들에 걸쳐, 상이한 프로그램들 중에, 그리고 여러 메모리 디바이스들에 걸쳐 분산될 수도 있다. 유사하게, 운용 데이 터는 본원에서 모듈들 내에서 식별 및 예시될 수 있고, 임의의 적합한 형태로 구현되고 임의의 적합한 타입의 데이터 구조 내에 조직화될 수 있다. 운용 데이터는 단일 데이터 세트로서 모아질 수 있거나, 또는 상이한 스토 리지 디바이스들을 포함하는 상이한 위치들에 걸쳐 분산될 수 있고, 시스템 또는 네트워크 상에 적어도 부분적 으로, 단지 전자 신호들로서 존재할 수 있다. 도 6a 및 도 6b는 본 발명의 일 실시예에 따른, ML 모델들을 호스팅, 모니터링, 및 리트레이닝하기 위한 RPA 아 키텍처를 도시한 구성도이다. 아키텍처는 AI 센터 클라이언트 티어, AI 센터 서비스 티어, 및 AI 센터 스토리지 티어를 포함한다. 이러한 실시예에서, AI 센터 서비스 티어에서의 서비스 컴포 넌트들은 쿠버네티스(k8s) 클러스터들 내부에서 호스팅된다. 그러나, 일부 실시예에서, 본 발명의 범위로부터 벗어나지 않고, 단일 k8s 클러스터가 사용될 수 있다. 이러한 실시예에서의 클라이언트 티어에서, 클라우드 RPA는 AI 센터 사용자와 같은 사용자들이 등록될 수 있고 조직으로부터의 다른 사용자들이 다양한 서비스들을 사용하도록 초대될 수 있는 서비스로서의 소프트웨어(SaaS)를 제공하는 클라우드 플랫폼(예를 들어, 퍼블릭 클라우드, 프라이빗 클라우드, 하이브리드 클 라우드 등)이다. 관리자는 조직 내의 사용자들에 대한 AI 센터를 인에이블하는 능력을 가질 수 있다. 관리 자는 또한 해당 계정 하의 테넌트들/그룹들에 라이센스들을 할당할 수 있다. 일부 실시예에서, 클라우드 RPA와 AI 센터 사이의 전형적인 상호작용은 AI 센터 및 테넌트들에 대한 라이센스들의 할당 - 이는 ML 스 킬들을 디플로이하기 위해 사용될 수 있음 - 을 인에이블/디스에이블할 것이다. AI 센터 서비스 티어에 의 해 공급되는 사용 통계치가 또한 클라우드 RPA를 통해 관리자에 의해 액세스 가능하다. 사용자(예를 들어, ML 엔지니어, 프로세스 엔지니어, 또는 데이터 과학자)는 미리 구성된 ML 모델들을 AI 애플리케이션의 일부로서 구축한다. 일부 실시예에서, AI 애플리케이션은 사용자가 ML 모델들의 라이 프사이클을 생성하고 관리할 수 있는 UI를 제공하는 웹 애플리케이션이다. RPA 개발자는 RPA 디자이너 (예를 들어, UiPath Studio™)로 워크플로우들을 개발하며, 이것들은 이후 RPA 로봇들을 생성하는 데 사용된다. RPA 디자이너 및 RPA 로봇은 컨덕터와 통신하여 AI 센터 서비스 티어의 AI 센터 서비스들에 액세스하기 위한 구성들 및 토큰들을 가져온다. 일부 실시예에서, 단지 인증 및 인가된 클라이언트 들만 컨덕터로부터 데이터를 획득할 수 있다. 클라이언트가 인가되는 경우, 토큰이 유효한 동안 서비스 티 어에의 액세스를 가능하게 하는 토큰이 제공될 수 있다. RPA 로봇들은 자신들이 동작하고 있는 컴퓨팅 시스템 및/또는 자신들이 액세스할 수 있는 임의의 다른 데 이터 소스 또는 스토리지로부터 데이터를 획득할 수 있다. 이러한 데이터는 RPA 로봇들에 의해 API 게이트 웨이들(632, 642)을 통해 코어 마이크로서비스들 또는 ML 스킬들에 각각 송신될 수 있다. ML 스킬들(646, 647, 648)은 예를 들어, ML 패키지들의 이용자가 이용할 준비가 된(consumer-ready) 라이브 디플로이먼트일 수 있다. 일부 실시예에서, 로봇들의 역할은 상이한 위치들로부터 상이한 타입들의 데이터(예를 들어, 블랍/파일 저 장소및/또는 데이터 스트림들로부터의 데이터)를 취하고 이를 ML 스킬들에 공급하는 것뿐만 아니라, ML 스킬들(646, 647, 648)의 출력을 취하고 이를 요구되는 스토리지들 및/또는 스트림들로 푸시하는 것이다. 일부 실시예 에서, RPA 로봇들은 또한 데이터를 데이터세트들로 업로드할 수 있다. RPA 개발자는 RPA 디자이너를 사용하여 RPA 워크플로우를 구축하고, 사용자는 ML 모델들을 구축 하고 이들을 컨덕터 또는 AI 애플리케이션에 업로드한다. ML 스킬들(및 각각의 ML 모델들)을 프로비 저닝, 생성/판독/업데이트/삭제(CRUD), 및 열거하는 것은 코어 서비스들로부터 ML 모델들에 대한 메타데이터를 수신하는 API 게이트웨이를 통해 일어난다. 로봇들은 또한 자신들의 동작들을 위한 모델들을 실행한 ML 스킬들(예를 들어, ML 스킬들(646, 647, 648))을 이용한다. API 게이트웨이와의 통신에 대하여, 클라우드 RPA는 테넌트 프로비저닝(tenant provisioning, TP) 정보를 송신한다. 이러한 실시예에서, TP 정보는 테넌트에 대한 메타데이터이다. 테넌트는 해당 이용자와 연관 된 ML 모델들 및 데이터를 소유할 이용자의 논리적 유닛이다. 이러한 메타데이터는 컨덕터 테넌트에 대한 참조, 명칭 및 위치 등과 같은 몇몇 기본적인 세부 사항들 등을 포함할 수 있다. AI 애플리케이션은 코어 엔티티들(core entities, CE)에 대한 CRUD를 수행한다. 이러한 실시예에서, 코어 엔티티들은 다른 엔티티들(예를 들어, ML 패키지, ML 스킬, 테넌트, 프로젝트, 감사 로그(audit log)들, 데이터 세트 등)과의 관계를 갖는 데이터베이스에 저장된 메타데이터 테이블들이다. 컨덕터 또는 AI 애플리케이션 이 ML 스킬들(LS)을 열거하고, RPA 로봇(들)이 ML 스킬들을 열거한다. 컨덕터 및/또는 AI 애플 리케이션은 ML 스킬들에 대한 CRUD 동작들을 담당하는 관리자에게 세부 사항들을 제시하기 위해 ML 스킬들 을 열거할 수 있는 반면, RPA 로봇들은 RPA 개발자가 ML 스킬을 선택하고 이를 RPA 워크플로우에 사용할 수 있도록 판독 전용 ML 스킬 리스트를 제시한다. RPA 로봇(들)은 또한 ML 서비스 클러스터의 API 게이트 웨이를 통해 ML 스킬들(646, 647, 648)로부터 예측된 것을 수신한다. 이러한 실시예에서, 서비스 티어의 서비스들은 세 개의 k8s 클러스터들 - 트레이닝 클러스터, 코어 마이크로서비스 클러스터, 및 ML 서비스 클러스터 - 를 포함한다. 이러한 실시예에서, 코어 마이크로 서비스 클러스터는 데이터베이스를 사용할 수 있는 API 게이트웨이를 포함한다. 유사하게, ML 서비스 클러스터는 데이터베이스를 사용할 수 있는 API 게이트웨이를 포함한다. 데이터베이스(633, 643)는 착신 요청들을 검증하는 데 사용될 수 있는 각각의 API 게이트웨이들(632, 642)에 대한 구성들 및 규칙 들을 저장한다. API 게이트웨이들(632, 642)은 비인가 사용, 남용, 침해, 서비스 거부 공격(denial-of-service attack) 등을 방지하기 위해 서비스들/스킬들 앞에 배치되는 서비스들이다. 게이트웨이들(632, 642)은 요청들을 검증하고 또한 더 많은 보안 정책들을 적용하여 배후 리소스들을 보호할 수 있다. 그 다음, 게이트웨이들(632, 642)은 게이트웨이들(632 및 642) 배후의 서비스들로부터의 검증된 요청들에 대한 정보를 다시 전달한다. AI 트레이너는 트레이닝 클러스터의 리트레이닝 파이프라인들(622, 624, 626)을 통해 ML 모델들의 리 트레이닝을 가이하게 하는 서비스이다. 리트레이닝 파이프라인들(622, 624, 626)은 상이한 테넌트들에 대해 트 레이닝 클러스터에서 실행되는 트레이닝 작업들이다. AI 트레이너는 AI 애플리케이션에서 리트 레이닝 파이프라인들(622, 624, 626)을 생성할 때 사용자가 지정한 것에 기초하여 필요한 컴퓨팅 리소스들(예를 들어, CPU 리소스 설정들, GPU 리소스 설정들, RAM 할당 등)을 이용하여 트레이닝 작업들을 생성할 것을 트레이 닝 클러스터에 지시한다. 주어진 트레이닝 작업이 완료되면, 생성된 아티팩트들이 스토리지 (예를 들어, 블랍 스토리지 )에 부싱(bushing)되고, 리소스들은 해제될 수 있다. AI 헬퍼는 비동기 동작, 상태 머신 관리, 스토리지 추상화 및 액세스 등과 같은 내부 유틸리티 서비스들의 집합을 제공한다. AI 패키지 매니저는 컨덕터 및/또는 AI 애플리케이션에 의해 호출될 ML 패키 지 및 프로젝트 CRUD 및 관련 REST API들을 제공한다. AI 디플로이어는 필요한 종속성을 갖는 ML 모델들의 이미지들(예를 들어, Docker™ 이미지들)을 구축하고, 컨테이너 레지스트리로 푸시하며, ML 서비스 클러스 터의 쿠버네티스 API들과 상호작용하여, 컨테이너들을 ML 스킬들(646, 647, 648)의 ML 스킬들로서 디플로 이한다. 상기한 내용에 따라, 일부 실시예에서, Docker™은 ML 모델 이미지들을 패키징하는 데 사용될 수 있다. 코어 마이크로서비스 클러스터는 메시지 브로커(message broker)를 포함하는데, 이는 장기 실행 및 비동기 작업들을 지원하기 위해 발행/구독 모델 기반 메시징 기능을 제공하는 다중 테넌트 서버이다. 블랍 스토 리지 는 ML 모델들 및 다른 종속 파일들을 저장하기 위한 다중 테넌트 스토리지를 제공한다. 컨테이너 레 지스트리는 이용자가 업로드한 ML 모델들의 도커 이미지들을 저장하기 위한 다중 테넌트 프라이빗 컨테이 너 레지스트리를 제공한다. SQL 서버는 ML 스킬들, ML 패키지들, 데이터세트들 등에 대한 메타데이터를 저 장한다. 이벤트/로그 스토리지 는 k8s 클러스터들(620, 630, 640)에서 실행되는 애플리케이션들/포드(po d)들에 대한 로그들 및 메트릭들을 저장한다. k8s 클러스터들(620, 630, 640)과 이벤트/로그 스토리지 사이에 연결이 존재하지만, 이는 도 6b에 도시되어 있지 않다. 서비스 메시 제어기(예를 들어, Istio™)는 ML 스킬들(646, 647, 648)에 대해, 트래픽 라우팅 규칙들, 모 니터링 등과 같은 서비스 메시 기능을 제공한다. ML 스킬들(646, 647, 648)로 들어가고 이들로부터 나올 수 있 는 것은 서비스 메시 제어기에 의해 제어된다. 서비스 메시 제어기는 ML 스킬들에 대한 네트워킹 및 모니터링 정책들을 푸시한다. 예를 들어, 서비스 메시 제어기는 요청들이 유래할 수 있는 인터넷 프로토콜 (IP) 어드레스들을 제어하고, 바이러스들을 차단하며, 이용자들이 독점 코드를 다운로드하고/거나 특정 포트들 에 액세스하는 것을 차단하는 등을 할 수 있다. API 게이트웨이는 ML 스킬들(646, 647, 648)에 대한 클라 이언트 요청들을 검증한다. ML 모델들이 검증되고 디플로이되면, 그리고 RPA 로봇들이 자신들의 동작 동안 ML 모델을 사용하는 액티비 티에 도달할 때, RPA 로봇들에 ML 스킬들(646, 647, 648)로서 이용 가능해지면, RPA 로봇들은 요청 및 관련 데이터를 ML 서비스 클러스터의 API 게이트웨이에 송신한다. 그러나, 일부 실시예에서, ML 모델의 실행을 위한 데이터는 RPA 로봇들과 상이한 소스에 의해 보충될 수 있거나, 또는 전적으로 RPA 로 봇들과 상이한 소스로부터 유래할 수 있다는 점을 유념해야 한다. 주어진 RPA 로봇에 대한 ML 동작들을 위한 데이터는 서비스 메시 제어기를 통해 적절한 ML 스킬 (들)(646, 647, 648)로 라우팅된다. 그 다음, ML 스킬들(646, 647, 648)로부터의 출력이 API 게이트웨이 를 통해 적절한 RPA 로봇으로 다시 송신된다. 그 다음, 로봇은 이러한 데이터를 사용하여 자신의 ML 액티 비티를 수행한다. 특정 ML 액티비티들에 대해, 로봇들은 여러 번 데이터를 ML 스킬들(646, 647, 648)에 송 신하고/거나 이들로부터 데이터를 수신할 수 있다는 점을 유념해야 한다. 그러나, ML 스킬들(646, 647, 648)이 디플로이되었으면, ML 스킬들(646, 647, 648)의 후속 관리가 바람직하다. 일부 실시예에서, 리트레이닝은 ML 모델의 타입, 및 ML 모델이 트레이닝될 데이터에 종속적일 수 있다. 일부 실 시예는 AI 센터 스토리지 티어 - 여기에 테넌트들은 그들이 트레이닝하려는 데이터를 포함시킬 수 있음 - 를 채용하고, RPA 로봇들이 AI 센터 스토리지 티어와 상호작용할 수 있다. 데이터는 시간이 지나면서 수집될 수 있고, RPA 로봇들은 이 데이터를 AI 센터 스토리지 티어에 제공할 수 있다. 일부 실시예에 서, 트레이닝 데이터는 블랍 스토리지에 저장된다. 예를 들어, RPA 로봇들은 각각의 RPA 로봇이 AI 센터 스토리지 티어가 어디에 있는지를 자동으 로 알고 데이터를 업로드할 수 있게 하는 RPA 워크플로우에서의 액티비티를 통해 데이터를 AI 센터 스토리지 티 어에 계속해서 푸시할 수 있다. 추가적으로 또는 대안적으로, RPA 로봇들은 로컬 데이터 및/또는 AI 센터 스토리지 티어 외부의 원격 데이터베이스에 저장된 데이터를 통해 반복할 수 있고, 그 다음 이 데이 터를 AI 센터 스토리지 티어에 송신할 수 있다. 이러한 데이터는 ML 스킬들(646, 647, 648)과 연관된 ML 모델들을 리트레이닝하는 데 사용될 수 있다. 예를 들어, ML 스킬들(646, 647, 648)의 ML 모델들의 성능이 모니 터링될 수 있다. ML 스킬들(646, 647, 648)의 ML 모델의 성능이 특정 문턱값(예를 들어, 애플리케이션에 따라, 60%, 80%, 95%, 99% 등의 신뢰도) 아래로 떨어진다면, AI 트레이너는 AI 센터 스토리지 티어에 저장 된 데이터를 사용하여 해당 ML 모델의 리트레이닝을 개시할 수 있다. 추가적으로 또는 대안적으로, ML 스킬들 (646, 647, 648)의 ML 모델들은 각각의 해당 ML 모델을 트레이닝하기 위한 특정 양의 데이터가 수신된 후, 특정 시간량이 경과한 후 등에 리트레이닝될 수 있다. 시간이 지나면서 AI 센터 스토리지 티어에 수집되는 데이터는 상이한 타입들의 데이터가 데이터세트들로 그룹화될 수 있다. 유사한 타입들의 데이터는 논리적 또는 물리적으로 그룹화될 수 있다. 일부 실시예에서, 사 용자들은 AI 애플리케이션을 통해, 그들이 트레이닝시키려는 ML 모델을 선택하고(그들이 적절한 액세스 권 한을 갖는다면), 그들이 각각의 ML 모델을 트레이닝시키려는 데이터세트(들)를 선택 및 관리하고, 그들이 리트 레이닝이 일어나기를 원하는 때(예를 들어, 요청시 또는 주기적으로)를 선택하며, 리트레이닝 파이프라인들 등 을 생성/모니터링하는 등을 할 수 있다. 일부 실시예에서, 데이터세트들은 ML 모델들이 데이터세트에서의 데이터에 액세스하기 위한 포인터들로서 제시 될 수 있다. ML 스킬들(646, 647, 648)의 ML 모델들은 각각의 ML 모델이 마지막으로 트레이닝되었던 땐 이용 가 능하지 않았던 더 새로운 데이터, 더 오래된 데이터와 더 새로운 데이터의 조합, 전체 데이터세트 등에 기초하 여 리트레이닝될 수 있다. ML 모델들은 새로운 데이터가 획득됨에 따라 시간이 지나면서 더 정확해질 수 있다. 일부 실시예에서, 사용자들은 사용하고자 하는 성능 척도(들)를 선택 또는 정의할 수 있고, 리트레이닝 파이프 라인들(622, 624, 626)은 선택된 성능 척도(들)에 기초하여 리트레이닝된 ML 모델에 대한 하나 이상의 스코어를생성한다. 트레이닝 클러스터는 리트레이닝을 위한 리소스들(예를 들어, CPU들, GPU들, RAM 등)의 관리를 가능하게 하는 추상화 계층을 제공한다. 일부 실시예에서, 본 발명의 범위로부터 벗어나지 않고, 다수의 k8s 클 러스터들, 다수의 스토리지 티어들, 또는 양자가 사용될 수 있다는 점을 유념해야 한다. 스코어(들)가 향상된다 면, 리트레이닝된 ML 모델은 사용자가 원한다면 자동으로 이전 버전 대신에 사용될 수 있다. 그렇지 않으면, 사 용자는 알림을 받고, 리트레이닝된 버전을 디플로이하는 것이 바람직한지 여부를 결정할 수 있다. 일부 실시예 에서, 스코어의 변화는 시간이 지나면서 추적되어, 정확도의 향상과 감소 양자를 강조할 수 있다. 그 다음, 사 용자 또는 트레이닝 클러스터는 부정적인 추이를 야기하는 원인이 무엇인지 결정하려고 시도할 수 있다. 일부 실시예에서, 사용되는 데이터의 양은 자동으로 조정될 수 있다. 예를 들어, 본 발명의 범위로부터 벗어나 지 않고, 데이터 포인트들의 수, 데이터가 수집되는 빈도, 수집되는 데이터의 양, 리트레이닝을 위한 트리거들, 및/또는 임의의 다른 적합한 트레이닝 파라미터들을 사용자들이 조정할 수 있게 하는 트레이닝 인터페이스가 컨 덕터 또는 AI 애플리케이션로서 제공될 수 있다. 도 6a 및 도 6b의 아키텍처는 IP 침해를 줄이거나 방지하는 것을 도울 수 있다. 예를 들어, 일부 실시예에서, 호스팅된 ML 스킬들(646, 647, 648)의 ML 모델들 또는 다른 이용 가능한 호스팅된 ML 모델들의 적어도 일부는 이용자들에 의해 제공되지 않을 수 있고, 아키텍처를 제공하는 회사의 소유일 수 있다. 이들 ML 모델들은 단지 설명만으로 RPA 로봇들에 의해 이용 가능하고 호출 가능하게 될 수 있고, 독점 ML 모델들 자체는 사 용자들 또는 호출 RPA 로봇들에 제공되지 않을 수 있다. 더 정확히 말하면, ML 모델 실행의 결과들만 제공 될 수 있다. 일부 실시예에서, RPA를 위한 로우 코드 ML 모델 디플로이먼트 및 트레이닝 시스템이 제공될 수 있다. ML 패키 지들은 사용자들 및/또는 RPA 개발자들에 의한 코딩 없이 한 번의 클릭으로 디플로이될 수 있다. 예 를 들어, 사용자들은 ML 모델들의 카탈로그로부터 선택하고 선택된 ML 모델들을 타겟 컴퓨팅 환경(예를 들어, 단일 노드 k8s 설비, 다중 노드 k8s 설비 등) 상에 디플로이할 수 있다. 특정 실시예들에서, 사용자들은 버튼을 한 번 클릭하여 ML 스킬들(646, 647, 648)의 ML 모델들을 트레이닝할 수 있다. 예를 들어, 도 8의 로우 코드 ML 모델 파이프라인 생성 인터페이스를 참조한다. 이러한 실시예들은 사용자들 및/또는 RPA 개발자들 에게 기술적 지식을 가질 것을 요구하지 않을 수 있고, 이들은 수동 프로그래밍 없이 트레이닝/리트레이닝 을 트리거할 수 있다. 그러나, 이는 ML 모델 패키지들이 이용자들의 것이고 UiPath®와 같은 RPA 제공자에 의해 제공되는 특별 취급(out-of-the-box) ML 모델들이 아니라면, 완전히 사실이 아닐 수도 있다. 트레이닝 가능한 ML 모델 패키지를 구축하기 위해, 자신들의 커스텀 ML 모델들을 생성하는 이용자들은 ML 모델 패키지 예측을 위 해 행할 수 있는 것 외에 일부 코딩을 행할 수 있다. 일부 실시예에서, RPA 개발자들은 다수의 ML 모델들을 함께 체이닝할 수 있다. 이는 특정 로직 또는 구성 에 기초할 수 있다. ML 모델들의 네트워크는 인터페이스(예를 들어, RPA 디자이너 애플리케이션)에서 사용 자들에게 이용 가능하게 될 수 있으며, 가능하게는 가장 관련성이 높을 것으로 시스템이 결정한 ML 모델들이 제 안된다. 예를 들어, RPA 개발자가 디자이너 애플리케이션을 사용하여 버튼을 클릭하는 액티비티에 대 한 ML 모델을 추가하고자 한다면, 예를 들어, 코어 마이크로서비스 클러스터에 의해 그래픽 요소 인식 ML 모델들이 제안될 수 있다. 그 다음, RPA 개발자는 원하는 결과를 달성하도록 ML 모델들을 선택하고 이들을 적절하게 체이닝할 수 있다. 도 7은 본 발명의 일 실시예에 따른, ML 모델들을 호스팅, 모니터링, 및 리트레이닝하는 것을 수행하도록 구성 된 시스템을 도시한 구성도이다. 시스템은 데스크탑 컴퓨터, 태블릿, 및 스마트폰과 같은 사용자 컴퓨팅 시스템들을 포함한다. 그러나, 본 발명의 범위로부터 벗어나지 않고, 스마트 워치들, 랩탑 컴퓨터들 등을 포함하지만 이에 제한되지 않는 임의의 요구되는 컴퓨팅 시스템이 사용될 수 있다.또한, 세 개의 사용자 컴퓨팅 시스템들이 도 7에 도시되어 있지만, 본 발명의 범위로부터 벗어나지 않고, 임의의 적합한 수의 컴퓨팅 시스템이 사용될 수 있다. 예를 들어, 일부 실시예에서, 수십, 수백, 수천, 또는 수백만의 컴퓨팅 시스 템들이 사용될 수 있다. 각 컴퓨팅 시스템(702, 704, 706)은 데이터를 수집하여 데이터베이스(도시되지 않음)로 송신하고/거나, 특정 작 업들의 수행으로 AI/ML 모델(들)(예를 들어, 체이닝되거나 체이닝되지 않은 AI/ML 모델들 중 하나 이상)을 실행하는 RPA 로봇을 갖는다. 예를 들어, RPA 로봇들 중 하나 이상은 각각의 컴퓨팅 시스템 상에서 사용자가 무엇을 행하고 있는지를 인식하기 위해 CV를 사용하도록 트레이닝되는 AI/ML 모델들을 사용할 수 있다. 컴퓨팅 시스템들(702, 704, 706)은 정보를 네트워크(예를 들어, 근거리 네트워크(LAN), 모바일 통신 네트워크, 위성 통신 시스템, 인터넷, 이들의 임의의 조합 등)를 통해 서버로 송신한다. 일부 실시예에서,서버는 퍼블릭 클라우드 아키텍처, 프라이빗 클라우드 아키텍처, 하이브리드 클라우드 아키텍처 등의 일부 일 수 있다. 특정 실시예들에서, 서버는 단일 컴퓨팅 시스템 상에서 다수의 소프트웨어 기반 서버들 을 호스팅할 수 있다. 일부 실시예에서, 서버는 하나 이상의 가상 머신(virtual machine, VM)을 통해 구현 될 수 있다. 특정 실시예들에서, 서버는 인터넷 연결성을 갖지 않는 \"에어 갭\" 서버일 수 있다. 일부 실시 예에서, 서버는 AI 센터 기능을 제공하는 하나의 머신, 또는 머신들의 클러스터일 수 있다. 이러한 실시예 에서, 서버는 오토메이션을 완료함에 있어서 각 호출 RPA 로봇을 보조하는 정보를 제공하기 위해 RPA 로봇 들 중 하나 이상에 의해 호출되는 AI/ML 모델들을 포함한다. 일부 실시예에서, RPA 로봇들에 의 해 호출되는 AI/ML 모델들은 사용자 상호작용들의 시퀀스들을 식별하기 위해 통계적 모델링(예를 들어, 은 닉 마르코프 모델(hidden Markov models, HMM)들)과 같은 다양한 기능들을 수행하고, 딥 러닝 기법들(예를 들어, LSTM(long short term memory) 딥 러닝, 이전의 은닉 상태들의 인코딩 등)을 이용하는 다수의 계층들을 가질 수 있다. 디플로이되면, AI/ML 모델들의 리트레이닝이 바람직할 수 있다. 그러나, 일부 실시예에서, ML 모델 또는 ML 스킬의 디플로이먼트가 트레이닝의 선행 조건은 아닐 수 있다. 실제로, 일부 ML 모델들은 디플로이되기 전에 트레이닝될 필요가 있다. 일부 실시예에서, 리트레이닝은 ML 모델의 타입, 및 ML 모델이 트레이닝될 데이터에 종속적일 수 있다. 일부 실시예는 (예를 들어, 데이터베이스의 일부로서) 보안 테넌트 레벨 스토리지 계층 - 여기에 테넌트들은 그들이 트레이닝하려는 데이터를 포함시킬 수 있음 - 을 채용하고, RPA 로봇들 중 하 나 이상이 이러한 스토리지 계층과 상호작용할 수 있다. 데이터는 시간이 지나면서 수집될 수 있고, RPA 로봇들 은 이 데이터를 데이터베이스에 제공할 수 있다. 예를 들어, RPA 로봇들 중 하나 이상은 각각의 RPA 로봇이 데이터베이스가 어디에 있는지를 자 동으로 알고 데이터를 업로드할 수 있게 하는 RPA 워크플로우에서의 액티비티를 통해 데이터를 데이터베이스 에 계속해서 푸시할 수 있다. 추가적으로 또는 대안적으로, RPA 로봇들은 로컬 데이터 및/또는 또 다 른 원격 데이터베이스에 저장된 데이터를 통해 반복할 수 있고, 그 다음 이 데이터를 데이터베이스에 송신 할 수 있다. 이러한 데이터는 AI/ML 모델들을 리트레이닝하는 데 사용될 수 있다. 예를 들어, 서버는 AI/ML 모델들의 성능을 모니터할 수 있다. AI/ML 모델의 성능이 특정 문턱값(예를 들어, 애플리케이 션에 따라, 60%, 80%, 95%, 99% 등의 신뢰도) 아래로 떨어진다면, 서버는 데이터베이스에 저장된 데 이터를 사용하여 해당 AI/ML 모델의 리트레이닝을 개시할 수 있다. 추가적으로 또는 대안적으로, AI/ML 모 델들은 각각의 해당 AI/ML 모델을 트레이닝하기 위한 특정 양의 데이터가 수신된 후, 특정 시간량이 경과 한 후 등에 리트레이닝될 수 있다. 시간이 지나면서 데이터베이스 내에 수집되는 데이터는 상이한 타입들의 데이터가 데이터세트들로 그룹화 될 수 있다. 유사한 타입들의 데이터는 논리적 또는 물리적으로 그룹화될 수 있다. 일부 실시예에서, 사용자들 은 AI/ML 모델들 중 그들이 트레이닝시키려는 AI/ML 모델을 선택하고(그들이 적절한 액세스 권한을 갖는다 면), 그들이 각각의 AI/ML 모델을 트레이닝시키려는 데이터세트(들)를 선택하며, 그들이 리트레이닝이 일어나기 를 원하는 때(예를 들어, 요청시 또는 주기적으로)를 선택할 수 있다. 일부 실시예에서, 데이터세트들은 AI/ML 모델들이 데이터세트에서의 데이터에 액세스하기 위한 포인터들로 서 제시될 수 있다. AI/ML 모델들은 각각의 AI/ML 모델이 마지막으로 트레이닝되었던 땐 이용 가능하지 않 았던 더 새로운 데이터, 더 오래된 데이터와 더 새로운 데이터의 조합, 전체 데이터세트 등에 기초하여 리트레 이닝될 수 있다. AI/ML 모델들은 새로운 데이터가 획득됨에 따라 시간이 지나면서 더 정확해질 수 있다. 일부 실시예에서, 사용자들은 사용하고자 하는 성능 척도(들)를 선택할 수 있고, 서버는 선택된 성능 척도 (들)에 기초하여 리트레이닝된 ML 모델에 대한 하나 이상의 스코어를 생성한다. 일부 실시예에서, 본 발명의 범 위로부터 벗어나지 않고, 다수의 서버들, 다수의 데이터베이스들, 또는 양자가 사용될 수 있다는 점을 유념해야 한다. 스코어(들)가 향상된다면, 리트레이닝된 AI/ML 모델은 자동으로 이전 버전 대신에 사용하기 위해 서버 에 의해 디플로이될 수 있다. 대안적으로, 컴퓨팅 시스템의 사용자는 알림을 받고, 리트레이닝된 버 전을 디플로이하는 것이 바람직한지 여부를 결정할 수 있다. 일부 실시예에서, 스코어의 변화는 시간이 지나면 서 추적되어, 정확도의 향상과 감소 양자를 강조할 수 있다. 그 다음, 서버 또는 컴퓨팅 시스템의 사 용자는 부정적인 추이를 야기하는 원인이 무엇인지 결정하려고 시도할 수 있다. 일부 실시예에서, 사용되는 데이터의 양은 자동으로 조정될 수 있다. 예를 들어, 본 발명의 범위로부터 벗어나 지 않고, 데이터 포인트들의 수, 데이터가 수집되는 빈도, 수집되는 데이터의 양, 리트레이닝을 위한 트리거들, 및/또는 임의의 다른 적합한 트레이닝 파라미터들을 컴퓨팅 시스템의 사용자가 조정할 수 있게 하는 트레이닝 인터페이스가 제공될 수 있다. 시스템의 아키텍처는 IP 침해를 줄이거나 방지하는 것을 도울 수 있다. 예를 들어, 호스팅된 AI/ML 모델들 중 적어도 일부는 사용자 컴퓨팅 시스템들(702, 704, 706)의 회사에 의해 제공되지 않을 수 있다. 이러한 AI/ML 모델들은 단지 설명만으로 RPA 로봇들에 의해 이용 가능하고 호출 가능하게 될 수 있고, 독점 AI/ML 모델들 자체는 사용자들 또는 호출 RPA 로봇들에 제공되지 않을 수 있다. 더 정확히 말하면, AI/ML 모델 실행의 결과들만 제공될 수 있다. AI 계층들 일부 실시예에서, 다수의 AI 계층들이 사용될 수 있다. 각 AI 계층은 데이터에 대해 실행되는 알고리즘(또는 모 델)이고, AI 모델 자체는 트레이닝 데이터에서 트레이닝되는 트레이닝된 인공 \"뉴런들\"의 딥 러닝 뉴럴 네트워 크(deep learning neural network, DLNN)들일 수 있다. 계층들은 직렬로, 병렬로, 또는 이들의 조합으로 실행 될 수 있다. AI 계층들은 시퀀스 추출 계층, 클러스터링 검출 계층, 시각적 컴포넌트 검출 계층, 텍스트 인식 계층(예를 들 어, OCR), 오디오-텍스트 변환 계층, 또는 이들의 임의의 조합을 포함할 수 있지만, 이에 제한되지 않는다. 그 러나, 본 발명의 범위로부터 벗어나지 않고, 임의의 요구되는 수 및 타입(들)의 계층이 사용될 수 있다. 다수의 계층들을 사용하면 시스템이 스크린들에서 어떤 일이 일어나고 있는지에 대한 전체적인 묘사를 전개시킬 수 있 다. 예를 들어, 하나의 AI 계층은 OCR을 수행할 수 있고, 또 다른 계층은 버튼들을 검출할 수 있으며, 또 다른 계층은 시퀀스들을 비교할 수 있는 등이다. 패턴들은 한 AI 계층에 의해 개별적으로 또는 다수의 AI 계층들에 의해 집합적으로 결정될 수 있다. 도 8은 본 발명의 일 실시예에 따른, 로우 코드 ML 모델 파이프라인 생성 인터페이스를 도시한다. 인터페 이스는 사용자가 프로그래밍 없이 새로운 실행 ML 파이프라인을 생성할 수 있게 한다. 예를 들어, 사용자 는 파이프라인 타입(예를 들어, 트레이닝, 평가, 또는 전체(트레이닝 + 평가)), ML 패키지, ML 패키지 메이저 및 마이너 버전들, 입력 데이터세트, 및 평가 데이터세트를 지정할 수 있다. 일부 실시예에서, 트레이닝 파이프 라인은 입력으로서 패키지 및 데이터세트를 취하며 새로운 패키지 버전을 생성하고, 평가 파이프라인은 입력으 로서패키지 버전 및 데이터세트를 취하며 메트릭들 및 로그들의 세트를 생성하며, 전체 파이프라인은 처리 기능, 트레이닝 파이프라인, 그리고 그 직후, 평가 파이프라인을 실행한다. ML 패키지들의 메이저 버전들은 RPA 제공자에 의해 제공되거나 이용자에 의해 업로드되는 버전들인 반면, ML 패키지들의 마이너 버전들은 메이저/마 이너 버전이 파이프라인을 사용하여 트레이닝될 때 생성되는 버전들이다. 일부 실시예에서, 모든 트레이닝 파이 프라인 실행은 ML 패키지의 마이너 버전을 생성한다. 사용자는 또한 환경 변수들을 추가하고, GPU 트레이닝을 인에이블할지 여부를 선택하며, ML 파이프라인이 언제 실행되어야 하는지(예를 들어, 지금, 시간 기반, 반복 등)를 선택할 수 있다. 환경 변수들은 예를 들어, 트레이닝 작업을 조정하기 위해 ML 모델 알고리즘에 의해 사 용될 수 있는 하이퍼파라미터들(예를 들어, 추정기들의 수, 에포크들의 수 등)과 같은, 데이터에 추가하여 선택 사항으로서 제공될 수 있는 모델 특정 구성들을 포함할 수 있다. 도 9는 본 발명의 일 실시예에 따른, ML 모델들을 호스팅, 모니터링, 및 리트레이닝하기 위한 프로세스를 도시한 흐름도이다. 프로세스는 단계 910에서 ML 모델들 및 ML 모델들에 대한 데이터세트들을 저장하는 것으로 시작된다. 일부 실시예에서, 각 데이터세트는 논리적 또는 물리적으로 그룹화된 유사한 타입들의 데이터를 포함 한다. 특정 실시예들에서, 데이터세트들은 로컬 데이터, 원격 데이터베이스에 저장된 데이터, 또는 양자를 통해 반복하고, 데이터를 리트레이닝을 위해 AI 센터의 스토리지에 송신하는 RPA 로봇들에 의해 제공된다. 그 다음, 단계 920에서 RPA 로봇들에 의해 호출되는 저장된 ML 모델들이 실행된다. 일부 실시예에서, 호출 RPA 로봇들의 RPA 워크플로우는 각 RPA 로봇이 리트레이닝을 위한 데이터를 업로드하기 위한 스토리지의 위치를 포함하는 데 이터 푸시 액티비티를 포함한다. 특정 실시예들에서, AI 센터 또는 RPA 로봇의 액티비티는 리트레이닝을 위한 데이터 포인트들의 수, 리트레이닝 데이터가 수집되는 빈도, 수집되는 리트레이닝 데이터의 양, 리트레이닝을 위한 하나 이상의 트리거, 또는 이들의 조합을 조정하도록 구성된다. 일부 실시예에서, RPA 로봇들은 모델들을 호출하고 ML 모델들의 실행의 결과들을 수신하는 것이 허용되지만, 하나 이상의 ML 모델 자체에 액세스하는 것 은 허용되지 않는다. 특정 실시예들에서, ML 모델은 컨테이너에 저장되고, ML 모델을 포함하는 컨테이너의 컨텐 츠는 암호화 또는 난독화되거나, ML 모델이 암호화되거나, 또는 둘 모두이다. 단계 930에서 리트레이닝 요청이 수신되거나 리트레이닝 조건이 충족된다면, 단계 940에서 ML 모델은 ML 모델에 대한 트레이닝 구성에서 지정된 복수의 데이터세트들의 서브세트를 사용하여 리트레이닝다. 일부 실시예에서, 복수의 데이터세트들은 리트레이닝 동안 ML 모델들에 대한 포인터들로서 제시되며, 리트레이닝되고 있는 ML 모델은 각각의 포인터들을 통해 리트레이닝을 위해 복수의 데이터세트들의 서브세트에 액세스한다. 단계 950에서 리트레이닝되고 있는 ML 모델에 대한 하나 이상의 성능 척도가 수신되고, 리트레이닝 동안 하나 이상의 성능 척 도에 대한 하나 이상의 스코어가 생성되며, 시간이 지나면서 하나 이상 스코어에 대한 변화가 추적된다. 그 다 음, 단계 960에서 리트레이닝된 ML 모델이 디플로이되고, 프로세스는 단계 920으로 되돌아간다. 일부 실시예에 서, 하나 이상의 스코어가 향상될 때, AI 센터는 ML 모델의 이전 버전 대신에 리트레이닝된 ML 모델을 디플로이 하도록 구성될 수 있다. 특정 실시예들에서, 하나 이상의 스코어가 향상될 때, AI 센터는 ML 모델의 리트레이닝 된 버전을 디플로이하고, ML 모델의 리트레이닝된 버전 및 ML 모델의 이전 버전 양자를 사용하며, 가장 높은 신 뢰도를 갖는 결과를 선택하도록 구성된다. 일부 실시예에서, 프로세스는 하나 이상의 리트레이닝 파이프라 인을 실행하도록 구성된 트레이닝 클러스터, ML 모델들에 대한 CRUD 동작들을 수행하고 트레이닝 클러스터의 리 트레이닝 파이프라인으로 하여금, ML 모델들의 리트레이닝을 개시하게 하도록 구성된 코어 마이크로서비스 클러 스터, 및 ML 모델들을 실행하고 실행의 결과들을 호출 RPA 로봇들에 제공하도록 구성된 ML 서비스 클러스터에 의해 수행될 수 있다. 일부 실시예에서, RPA를 위한 로우 코드 ML 모델 디플로이먼트 및 트레이닝 애플리케이션이 사용되며, 여기서 로우 코드 ML 모델 디플로이먼트 및 트레이닝 애플리케이션은 사용자들에 의한 코딩 없이 한 번의 클릭으로 ML 패키지들을 디플로이하도록 구성된다. 특정 실시예들에서, 로우 코드 ML 모델 디플로이먼트 및 트레이닝 애플리 케이션은 ML 모델들의 카탈로그로부터의 선택을 가능하게 하고, 선택된 ML 모델들을 타겟 컴퓨팅 환경으로서 AI 센터에 디플로이하도록 구성된다. 일부 실시예에서, 로우 코드 ML 모델 디플로이먼트 및 트레이닝 애플리케이션 은 서로 연결 가능한 ML 모델들의 그래프를 디스플레이하도록 구성된다. 특정 실시예들에서, 그래프에서의 ML 모델들은 직렬, 병렬, 또는 양자로 연결 가능하다. 도 9에서 수행되는 프로세스 단계들은 본 발명의 실시예들에 따라, 도 9에서 설명된 프로세스(들)의 적어도 일 부를 수행하기 위한 프로세서(들)에 대한 명령어들을 인코딩하여, 컴퓨터 프로그램에 의해 수행될 수 있다. 컴 퓨터 프로그램은 비일시적인 컴퓨터 판독 가능 매체 상에 구현될 수 있다. 컴퓨터 판독 가능 매체는 하드 디스 크 드라이브, 플래시 디바이스, RAM, 테이프, 및/또는 데이터를 저장하는 데 사용되는 임의의 다른 이러한 매체 또는 매체들의 조합일 수 있지만, 이에 제한되지 않는다. 컴퓨터 프로그램은 도 9에 설명된 프로세스 단계들의 전부 또는 일부를 구현하도록 컴퓨팅 시스템의 프로세서(들)(예를 들어, 도 5의 컴퓨팅 시스템의 프로세서 (들))를 제어하기 위한 인코딩된 명령어들을 포함할 수 있으며, 이는 또한 컴퓨터 판독 가능 매체 상에 저 장될 수 있다. 컴퓨터 프로그램은 하드웨어, 소프트웨어, 또는 하이브리드 구현으로 구현될 수 있다. 컴퓨터 프로그램은 서로 통신 가동 준비가 되고, 디스플레이할 정보 또는 명령어들을 전달하도록 설계된 모듈들로 구성될 수 있다. 컴퓨 터 프로그램은 범용 컴퓨터, ASIC, 또는 임의의 다른 적합한 디바이스 상에서 동작하도록 구성될 수 있다. 본원에서의 도면들에서 일반적으로 설명되고 도시된 바와 같이, 본 발명의 다양한 실시예들의 컴포넌트는 매우 다양한 상이한 구성들로 배열 및 설계될 수 있다는 것이 쉽게 이해될 것이다. 따라서, 첨부된 도면들에 나타내 어진 바와 같이, 본 발명의 실시예들에 대한 상세한 설명은 청구된 바와 같은 본 발명의 범위를 제한하려는 것 이 아니라, 단지 본 발명의 선택된 실시예들을 나타내는 것이다. 본 명세서 전반에 걸쳐 설명된 본 발명의 특징들, 구조들, 또는 특성들은 하나 이상의 실시예에서 임의의 적합 한 방식으로 조합될 수 있다. 예를 들어, 본 명세서 전체에 걸쳐 \"특정 실시예들\", \"일부 실시예\", 또는 유사한 용어의 언급은 그 실시예와 관련하여 설명된 특정 특징, 구조, 또는 특성이 본 발명의 적어도 하나의 실시예에 포함된다는 것을 의미한다. 따라서, 본 명세서 전체에 걸쳐 어구들 \"특정 실시예들에서\", \"일부 실시예에서\",\" 다른 실시예들에서\", 또는 유사한 용어들의 출현은 반드시 모두 동일한 그룹의 실시예들을 지칭하는 것은 아니 며, 설명된 특징들, 구조들 또는, 특성들이 하나 이상의 실시예에서 임의의 적합한 방식으로 조합될 수 있다. 본 명세서 전체에 걸쳐 특징들, 이점들, 또는 유사한 용어의 언급은 본 발명으로 실현될 수 있는 특징들 및 이 점들 모두가 본 발명의 임의의 단일 실시예이어야 하거나 또는 본 발명의 임의의 단일 실시예에 있다는 것을 암 시하는 것이 아님을 유념해야 한다. 더 정확히 말하면, 특징들 및 이점들을 지칭하는 용어는 실시예와 관련하여 설명된 특정 특징, 이점, 또는 특성이 본 발명의 적어도 하나의 실시예에 포함된다는 것을 의미하는 것으로 이 해된다. 따라서, 본 명세서 전반에 걸친 특징들 및 이점들에 대한 논의, 및 유사한 용어는 동일한 실시예를 지 칭할 수 있지만, 반드시 그러한 것은 아니다. 뿐만 아니라, 본 발명의 설명된 특징들, 이점들, 및 특성들은 하나 이상의 실시예에서 임의의 적합한 방식으로 조합될 수 있다. 당업자는 본 발명이 특정 실시예의 특정 특징들 또는 이점들 중 하나 이상 없이 실시될 수 있다는 것을 인식할 것이다. 다른 사례들에서, 본 발명의 모든 실시예들에 존재하는 것은 아닐 수 있는 추가적인 특징들 및 이점들이 특정 실시예들에서 인식될 수 있다. 당업자는 위에서 논의된 바와 같은 본 발명이 개시된 것들과 상이한 상이한 순서의 단계들로, 그리고/또는 구성 들의 하드웨어 요소들로 실시될 수 있다는 것을 쉽게 이해할 것이다. 따라서, 본 발명이 이들 바람직한 실시예 들에 기초하여 설명되었지만, 본 발명의 사상 및 범위 내에 유지되면서, 특정 수정, 변형, 및 대안적인 구성이 명백할 것이라는 것이 당업자들에게 명백할 것이다. 따라서, 본 발명의 한계 및 경계를 결정하기 위해, 첨부된 청구범위가 참조되어야 한다."}
{"patent_id": "10-2021-7043355", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 발명의 특정 실시예들의 장점들이 쉽게 이해될 수 있도록 하기 위해, 위에서 약술된 본 발명의 보다 구체적 인 설명을 첨부된 도면들에 도시된 특정 실시예들을 참조하여 제공할 것이다. 이들 도면들은 단지 본 발명의 통 상적인 실시예들을 도시할 뿐이며, 이에 따라 본 발명의 범위를 제한하는 것으로 고려되어서는 안 된다는 것이 이해되어야 하며, 본 발명은 다음 첨부 도면들의 사용을 통해 추가적인 특이성 및 세부사항으로 설명되고 기술 될 것이다. 도 1은 본 발명의 일 실시예에 따른, RPA 시스템을 도시한 구성도이다. 도 2는 본 발명의 일 실시예에 따른, 디플로이된 RPA 시스템을 도시한 구성도이다. 도 3은 본 발명의 일 실시예에 따른, 디자이너, 액티비티들, 및 드라이버들 사이의 관계를 도시한 구성도이다. 도 4는 본 발명의 일 실시예에 따른, RPA 시스템을 도시한 구성도이다.도 5는 본 발명의 일 실시예에 따른, ML 모델들을 호스팅, 모니터링, 및 리트레이닝하거나, 또는 이를 행하는 시스템의 일부로서 동작하도록 구성된 컴퓨팅 시스템을 도시한 구성도이다. 도 6a 및 도 6b는 본 발명의 일 실시예에 따른, ML 모델들을 호스팅, 모니터링, 및 리트레이닝하기 위한 RPA 아 키텍처를 도시한 구성도이다. 도 7은 본 발명의 일 실시예에 따른, ML 모델들을 호스팅, 모니터링, 및 리트레이닝하는 것을 수행하도록 구성 된 시스템을 도시한 구성도이다. 도 8은 본 발명의 일 실시예에 따른, 로우 코드(low code) ML 모델 파이프라인 생성 인터페이스를 도시한다. 도 9는 본 발명의 일 실시예에 따른, ML 모델들을 호스팅, 모니터링, 및 리트레이닝하기 위한 프로세스를 도시 한 흐름도이다. 달리 지시되지 않는 한, 유사한 참조 문자들은 첨부된 도면들을 통해 일관되게 대응하는 특징부들을 나타낸다."}
