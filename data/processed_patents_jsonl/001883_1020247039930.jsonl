{"patent_id": "10-2024-7039930", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0002716", "출원번호": "10-2024-7039930", "발명의 명칭": "컨볼루션 연산 방법, 컨볼루션 연산 장치, 전자 디바이스및 저장 매체", "출원인": "베이징 요우쭈쥐 네트워크 테크놀러지 컴퍼니 리", "발명자": "왕, 슈아이"}}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "연산 컨볼루션 커널을 결정하는 단계;타겟 데이터를 획득하기 위해 상기 연산 컨볼루션 커널의 채널들의 수에 기초하여 입력 데이터의 레이아웃을 조절하는 단계; 및컨볼루션 연산 결과를 획득하기 위해 상기 타겟 데이터 및 상기 연산 컨볼루션 커널에 기초하여 컨볼루션 연산을 수행하는 단계를 포함하고,상기 연산 컨볼루션 커널은 초기 컨볼루션 커널에 기초하여 획득되고,상기 초기 컨볼루션 커널은 [R, S, C, K]로 표현되고,상기 연산 컨볼루션 커널은 [1, 1, (CХRХS), K]로 표현되고,R, S, C 및 K는 0보다 큰 정수이고,상기 타겟 데이터의 채널들의 수 및 크기는 상기 입력 데이터의 채널들의 수 및 크기와 다르고,상기 타겟 데이터의 채널들의 수는 상기 연산 컨볼루션 커널의 채널들의 수와 같고,상기 타겟 데이터 및 상기 연산 컨볼루션 커널의 상기 컨볼루션 연산 결과는 상기 입력 데이터 및 상기 초기 컨볼루션 커널의 컨볼루션 연산 결과와 같은,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 타겟 데이터의 채널들의 수는상기 입력 데이터의 채널들의 수보다 크고,상기 연산 컨볼루션 커널의 채널들의 수는상기 초기 컨볼루션 커널의 채널들의 수보다 큰,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항 또는 제2항에 있어서,상기 타겟 데이터를 획득하기 위해 상기 연산 컨볼루션 커널의 채널들의 수에 기초하여 상기 입력 데이터의 상기 레이아웃을 조절하는 단계는상기 입력 데이터를 행 단위들로 정적 메모리 내에 저장하는 단계;확장된 데이터를 획득하기 위해 상기 정적 메모리에 저장된 상기 입력 데이터에 패딩을 수행하는 단계; 및상기 타겟 데이터를 획득하기 위해 상기 확장된 데이터의 채널들의 수 및 크기를 변화시키도록 상기 확장된 데이터의 레이아웃을 조절하는 단계를 포함하고,상기 입력 데이터의 각각의 행은공개특허 10-2025-0002716-3-상기 정적 메모리 내의 해당하는 N개 엔트리들에 내에 저장되고,N은 0보다 큰 정수인,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 입력 데이터를 상기 행 단위들로 상기 정적 메모리 내에 저장하는 단계는상기 입력 데이터를 밀집 레이아웃(dense layout)으로 메모리 내에 저장하는 단계; 및상기 메모리 내의 상기 입력 데이터를 직접 메모리 접근 방식으로 하드웨어 가속기의 상기 정적 메모리에게 전송하고, 상기 입력 데이터의 각각의 행이 상기 정적 메모리 내의 상기 해당하는 N개 엔트리들 내에 저장되도록상기 입력 데이터의 행들의 제1 데이터 포인트들을 상기 정적 메모리의 상이한 행들의 제1 열들 내에 저장하는단계를 포함하고,상기 입력 데이터는복수의 채널들을 포함하고,상기 밀집 레이아웃은같은 데이터 포인트의 복수의 채널들이 상기 메모리 내에 순차적이고 근접 방식으로 저장되는 것을 의미하는,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제3항에 있어서,상기 확장된 데이터를 획득하기 위해 상기 정적 메모리 내에 저장된 상기 입력 데이터에 상기 패딩을 수행하는단계는상기 정적 메모리 내에서, 제1 중간 데이터를 획득하기 위해 상기 입력 데이터에 대응하는 저장 위치의 전후의엔트리들을 제1 프리셋 값으로 패딩하는 단계;상기 제1 중간 데이터를 벡터 계산 유닛에게 전송하고, 제2 중간 데이터를 획득하기 위해 상기 벡터 계산 유닛으로부터의 쉬프트 명령어 및 패딩 명령어 사용하여 상기 제1 중간 데이터에 대응하는 각각의 행의 두 엔드들을제2 프리셋 값으로 패딩하는 단계; 및상기 확장된 데이터를 획득하기 위해 상기 제2 중간 데이터를 상기 정적 메모리 내의 해당하는 저장 위치로 전송하는 단계를 포함하고,상기 제1 중간 데이터는상기 입력 데이터 및 상기 패딩된 제1 프리셋 값을 포함하고,상기 제2 중간 데이터는상기 제1 중간 데이터 및 상기 패딩된 제2 프리셋 값을 포함하고,상기 확장된 데이터는상기 제2 중간 데이터와 내용이 동일한,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "공개특허 10-2025-0002716-4-제5항에 있어서,상기 타겟 데이터는 [1, ht, wt, (CХRХS)]로 표현되고,ht 및 wt는 0보다 큰 정수이고,상기 타겟 데이터를 획득하기 위해 상기 확장된 데이터의 채널들의 수 및 크기를 변경하도록 상기 확장된 데이터의 상기 레이아웃을 조절하는 단계는상기 정적 메모리 내의 R*N개 엔트리들 내의 데이터를 연속적으로 읽고 상기 벡터 계산 유닛에게 전송하는단계; 및상기 타겟 데이터를 획득하기 위해, 상기 벡터 계산 유닛에 의해, 매번 수신되는 상기 R*N개 엔트리들 내의 데이터를 wt*ceil((CХRХS)/L)개 엔트리들의 데이터로 변환하는 단계를 포함하고,각각의 읽기의 시작 주소는 프리셋 스트라이드 str에 따라 str*N개 엔트리들만큼 쉬프트되고,상기 프리셋 스트라이드는 상기 입력 데이터 및 상기 초기 컨볼루션 커널에 행 방향 및 열 방향으로 컨볼루션연산을 수행하기 위해 요구되는 특징 윈도우의 스트라이드이고,상기 정적 메모리로부터의 데이터의 읽기의 총 수는 ht와 같고,L은 상기 정적 메모리 내의 각각의 엔트리에 의해 저장가능한 데이터 포인트들의 수를 나타내고,ceil((CХRХS)/L)은 (CХRХS)/L를 정수로 올림하는 것을 나타내며,상기 변환된 데이터는 상기 타겟 데이터인,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,상기 타겟 데이터를 획득하기 위해, 상기 벡터 계산 유닛에 의해, 매번 수신되는 상기 R*N개 엔트리들 내의 데이터를 상기 wt*ceil((CХRХS)/L)개 엔트리들의 데이터로 변환하는 단계는상기 프리셋 스트라이드에 따라 상기 R*N개 엔트리들 내의 데이터를 복수의 데이터의 세트들로 나누는 단계;각각의 데이터의 세트에 대해, 상기 데이터의 세트에 해당하는 상기 특징 윈도우의 데이터의 각각의 행의 타겟위치 정보 파라미터 및 초기 위치 정보 파라미터를 결정하는 단계; 및상기 타겟 데이터를 획득하기 위해, 상기 초기 위치 정보 파라미터 및 상기 타겟 위치 정보 파라미터에 기초하여, 상기 벡터 계산 유닛에 의해, 각각의 데이터의 세트를 타겟 메모리의 해당하는 위치 내에 변환된 레이아웃으로 저장하는 단계를 포함하고,각각의 데이터의 세트는 상기 행 방향의 하나의 특징 윈도우에 대응하고,상기 복수의 데이터의 세트들의 수는 wt와 같고,상기 타겟 메모리는 상기 행 단위들로의 저장을 허용하고,상기 타겟 메모리에게 전송되고 상기 타겟 메모리에 저장되는 데이터는 상기 타겟 데이터인,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 초기 위치 정보 파라미터는 제1 시작 경계 좌표, 제1 엔드 경계 좌표, 제1 시작 주소, 제1 엔드 주소, 제1시작 일련번호, 및 제1 엔드 일련번호를 포함하고,공개특허 10-2025-0002716-5-상기 제1 시작 경계 좌표는 상기 확장된 데이터의 상기 행 방향에서 해당하는 특징 윈도우의 시작 경계의 상대적인 좌표를 나타내고, 상기 제1 엔드 경계 좌표는 상기 확장된 데이터의 상기 행 방향에서 상기 해당하는 특징윈도우의 엔드 경계의 상대적인 좌표를 나타내고, 상기 해당하는 특징 윈도우의 상기 시작 경계 및 상기 해당하는 특징 윈도우의 상기 엔드 경계는 상기 확장된 데이터의 상기 행 방향에서 상이한 위치들에 위치되고,상기 제1 시작 주소는 상기 벡터 계산 유닛의 메모리 내의 상기 제1 시작 경계 좌표의 주소를 나타내고, 상기제1 엔드 주소는 상기 벡터 계산 유닛의 상기 메모리 내의 상기 제1 엔드 경계 좌표의 주소를 나타내고,상기 제1 시작 일련번호는 상기 제1 시작 주소에서의 상기 제1 시작 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타내고, 상기 제1 엔드 일련번호는 상기 제1 엔드 주소에서의 상기 제1 엔드 경계 좌표에 대응하는데이터 포인트의 일련번호를 나타내는,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 제1 시작 경계 좌표에 대한 계산 식은 src_row_start_index = i * str * ch이고, src_row_start_index는상기 제1 시작 경계 좌표를 나타내고, i는 상기 타겟 데이터의 크기 wt 내에서 상기 해당하는 특징 윈도우의 해당하는 데이터 포인트의 일련번호를 나타내고, str은 상기 행 방향에서 상기 특징 윈도우의 스트라이드를 나타내고, ch는 상기 입력 데이터의 채널들의 수를 나타내고,상기 제1 엔드 경계 좌표에 대한 계산 식은 src_row_end_index = src_row_start_index + (kernel_w * ch - 1)이고, src_row_end_index는 상기 제1 엔드 경계 좌표를 나타내고, kernel_w는 상기 특징 윈도우의 폭을 나타내고, 상기 특징 윈도우의 크기는 상기 초기 컨볼루션 커널의 크기와 같고,상기 제1 시작 주소에 대한 계산 식은 src_row_start_address = src_row_start_index / vmem_lane + j *N이고, src_row_start_address는 상기 제1 시작 주소를 나타내고, vmem_lane은 상기 벡터 계산 유닛의 상기 메모리 내의 각각의 엔트리에 의해 저장가능한 데이터 포인트들의 수를 나타내고, j는 상기 특징 윈도우 내의 해당하는 데이터의 행 일련번호를 나타내고,상기 제1 엔드 주소에 대한 계산 식은 src_row_end_address = src_row_end_index / vmem_lane + j * N이고,src_row_end_address는 상기 제1 엔드 주소를 나타내고,상기 제1 시작 일련번호에 대한 계산 식은 src_row_start_lane = src_row_start_index % vmem_lane이고,src_row_start_lane은 상기 제1 시작 일련번호를 나타내고, %는 모듈로 연산을 나타내고,상기 제1 엔드 일련번호에 대한 계산 식은 src_row_end_lane = src_row_end_index % vmem_lane이고,src_row_end_lane은 상기 제1 엔드 일련번호를 나타내는,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제7항에 있어서,상기 타겟 위치 정보 파라미터는 제2 시작 경계 좌표, 제2 엔드 경계 좌표, 제2 시작 주소, 제2 엔드 주소, 제2시작 일련번호, 및 제2 엔드 일련번호를 포함하고,상기 제2 시작 경계 좌표는 [1, 1, (CХRХS)]의 데이터 크기 내에서 내에서 해당하는 특징 윈도우의 시작 경계의 상대적인 좌표를 나타내고, 상기 제2 엔드 경계 좌표는 상기 [1, 1, (CХRХS)]의 데이터 크기 내에서 내에서 상기 해당하는 특징 윈도우의 엔드 경계의 상대적인 좌표를 나타내고, 상기 해당하는 특징 윈도우의 상기 시작 경계 및 상기 해당하는 특징 윈도우의 상기 엔드 경계는 상기 확장된 데이터의 상기 행 방향에서 상이한 위치들에 위치되고,상기 제2 시작 주소는 상기 벡터 계산 유닛의 메모리 내의 상기 제2 시작 경계 좌표의 주소를 나타내고, 상기제2 엔드 주소는 상기 벡터 계산 유닛의 상기 메모리 내의 상기 제2 엔드 경계 좌표의 주소를 나타내고,상기 제2 시작 일련번호는 상기 제2 시작 주소에서의 상기 제2 시작 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타내고, 상기 제2 엔드 일련번호는 상기 제2 엔드 주소에서의 상기 제2 엔드 경계 좌표에 대응하는공개특허 10-2025-0002716-6-데이터 포인트의 일련번호를 나타내는,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서,상기 제2 시작 경계 좌표에 대한 계산 식은 dst_row_start_index＝j*kernel_w*ch이고, dst_row_start_index는상기 제2 시작 경계 좌표를 나타내고, j는 상기 특징 윈도우 내의 해당하는 데이터의 행 일련번호를 나타내고,kernel_w는 상기 특징 윈도우의 폭을 나타내고, 상티 특징 윈도우의 크기는 상기 초기 컨볼루션 커널의 크기와같고, ch는 상기 입력 데이터의 채널들의 수를 나타내고,상기 제2 엔드 경계 좌표에 대한 계산 식은 dst_row_end_index = dst_row_start_index + (kernel_w * ch - 1)이고, dst_row_end_index는 상기 제2 엔드 경계 좌표를 나타내고,상기 제2 시작 주소에 대한 계산 식은 dst_row_start_address = dst_row_start_index / vmem_lane이고,dst_row_start_address는 상기 제2 시작 주소를 나타내고, vmem_lane은 상기 벡터 계산 유닛의 상기 메모리 내의 각각의 엔트리에 의해 저장가능한 데이터 포인트들의 수를 나타내고,상기 제2 엔드 주소에 대한 계산 식은 dst_row_end_address = dst_row_end_index / vmem_lane이고,dst_row_end_address는 상기 제2 엔드 주소를 나타내고,상기 제2 시작 일련번호에 대한 계산 식은 dst_row_start_lane = dst_row_start_index % vmem_lane이고,dst_row_start_lane은 상기 제2 시작 일련번호를 나타내고, %는 모듈로 연산을 나타내고,상기 제2 엔드 일련번호에 대한 계산 식은 dst_row_end_lane = dst_row_end_index % vmem_lane이고,dst_row_end_lane은 상기 제2 엔드 일련번호를 나타내는,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제7항에 있어서,상기 타겟 데이터를 획득하기 위해, 상기 초기 위치 정보 파라미터 및 상기 타겟 위치 정보 파라미터에 기초하여, 상기 벡터 계산 유닛에 의해, 각각의 데이터의 세트를 상기 타겟 메모리의 상기 해당하는 위치 내에 상기변환된 레이아웃으로 저장하는 단계는상기 타겟 데이터를 획득하기 위해, 상기 초기 위치 정보 파라미터 및 상기 타겟 위치 정보 파라미터에 기초하여, 벡터 프레디케이트 레지스터 내의 프리셋 활성화 신호에 따라서 및 순환 쉬프트 명령어를 사용하여 상기 벡터 계산 유닛에 의해, 각각의 데이터의 세트를 상기 변환된 레이아웃으로 스플라이싱하고 상기 데이터를 상기타겟 메모리의 상기 해당하는 위치 내에 저장하는 단계를 포함하는,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1항 내지 제12항 중 어느 하나의 항에 있어서,상기 타겟 데이터 및 상기 연산 컨볼루션 커널에 기초하여 상기 컨볼루션 연산을 수행하는 단계는행렬 연산 유닛에 의해, 상기 타겟 데이터 및 상기 연산 컨볼루션 커널에 상기 컨볼루션 연산을 수행하는 단계를 포함하는,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제1항 내지 제13항 중 어느 하나의 항에 있어서,상기 컨볼루션 연산 방법은공개특허 10-2025-0002716-7-컨볼루션 뉴럴 네트워크의 첫번째-레이어 컨볼루션 연산에 적용되는,컨볼루션 연산 방법."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "연산 컨볼루션 커널을 결정하도록 구성된 결정 유닛;타겟 데이터를 획득하기 위해 상기 연산 컨볼루션 커널의 채널들의 수에 기초하여 입력 데이터의 레이아웃을 조절하도록 구성된 조절 유닛; 및컨볼루션 연산 결과를 획득하기 위해 상기 타겟 데이터 및 상기 연산 컨볼루션 커널에 기초하여 컨볼루션 연산을 수행하도록 구성된 계산 유닛을 포함하고,상기 연산 컨볼루션 커널은 초기 컨볼루션 커널에 기초하여 획득되고,상기 초기 컨볼루션 커널은 [R, S, C, K]로 표현되고,상기 연산 컨볼루션 커널은 [1, 1, (CХRХS), K]로 표현되고,R, S, C 및 K는 0보다 큰 정수이고,상기 타겟 데이터의 채널들의 수 및 크기는 상기 입력 데이터의 채널들의 수 및 크기와 다르고,상기 타겟 데이터의 채널들의 수는 상기 연산 컨볼루션 커널의 채널들의 수와 같고,상기 타겟 데이터 및 상기 연산 컨볼루션 커널의 상기 컨볼루션 연산 결과는 상기 입력 데이터 및 상기 초기 컨볼루션 커널의 컨볼루션 연산 결과와 같은,컨볼루션 연산 장치."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항의 컨볼루션 연산 장치를 포함하는 전자 디바이스."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "프로세서; 및적어도 하나의 컴퓨터 프로그램 모듈을 포함하는 메모리를 포함하고,상기 적어도 하나의 컴퓨터 프로그램 모듈은상기 프로세서에 의해 실행되도록 구성되고 상기 메모리에 저장되고,상기 적어도 하나의 컴퓨터 프로그램 모듈은제1항 내지 제14항 중 어느 한 항의 컨볼루션 연산 방법을 구현하도록 구성되는, 전자 디바이스."}
{"patent_id": "10-2024-7039930", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "컴퓨터에 의해 실행되었을 때, 상기 컴퓨터로 하여금 제1항 내지 제14항 중 어느 한 항의 상기 컨볼루션 연산방법을 구현하도록 하는 비-일시적 컴퓨터-판독가능 명령어들을 저장하는, 저장 매체."}
{"patent_id": "10-2024-7039930", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "컨볼루션 연산 방법, 컨볼루션 연산 장치, 전자 디바이스 및 저장 매체. 컨볼루션 연산 방법은 다음을 포함한다: 연산 컨볼루션 커널을 결정하는 단계, 여기서 연산 컨볼루션 커널은 초기 컨볼루션 커널에 기초하여 획득되고, 초기 컨볼루션 커널은 [R, S, C, K]로 표현되고, 연산 컨볼루션 커널은 [1, 1, (CХRХS), K]로 표현 (뒷면에 계속)"}
{"patent_id": "10-2024-7039930", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원은 2022년 5월 31에 출원된 중국 특허 출원 제202210610935.6호의 우선권을 주장하고, 이것의 개시는 그 전체가 여기에 참조로서 본 출원의 일부로 포함된다. 본 개시(present disclosure)의 실시예들은 컨볼루션 연산 방법, 컨볼루션 연산 장치, 전자 디바이스, 및 저장 매체에 관한 것이다."}
{"patent_id": "10-2024-7039930", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "기술의 발전과 함께, 인공지능(artificial intelligence, AI) 기술은 복수의 분야들 내에서 넓게 사용된다. 딥 러닝(deep learning)은 AI 기술의 중요한 기술들 중 하나이다. 인공 뉴럴 네트워크(artificial neural network)에 기반한 딥 러닝 기술은 객체 분류, 텍스트 처리, 이미지 검색(image search), 및 사람-기계 대화 (man-machine conversation)와 같은 분야들 내의 큰 진전(progress)을 달성했다. 컨볼루션 뉴럴 네트워크 (convolution neural network, CNN)는, 복잡한 처리 없이 이미지 데이터를 입력할 수 있기 때문에 이미지 처리 (image processing) 등에 큰 이점들을 갖는 딥 러닝 기술에 넓게 적용된다. 본 개시의 적어도 하나의 실시예는 다음을 포함하는 컨볼루션 연산 방법을 제공한다: 연산 컨볼루션 커널 (operation convolution kernel)을 결정하는 단계, 여기서 연산 컨볼루션 커널은 초기 컨볼루션 커널에 기초하 여 획득되고, 초기 컨볼루션 커널은 [R, S, C, K]로 표현되고, 연산 컨볼루션 커널은 [1, 1, (CХRХS), K]로 표현되고, R, S, C 및 K는 0보다 큰 정수이다; 타겟 데이터를 획득(obtain)하기 위해 연산 컨볼루션 커널의 채 널들의 수에 기초하여 입력 데이터의 레이아웃(layout)을 조절(adjust)하는 단계, 여기서 타겟 데이터의 채널들 의 수 및 크기는 입력 데이터의 채널들의 수 및 크기와 다르고, 타겟 데이터의 채널들의 수는 연산 컨볼루션 커 널의 채널들의 수와 같다; 및 컨볼루션 연산 결과를 획득하기 위해 타겟 데이터 및 연산 컨볼루션 커널에 기초 하여 컨볼루션 연산(convolution operation)을 수행하는 단계, 여기서 타겟 데이터 및 연산 컨볼루션 커널의 컨 볼루션 연산 결과는 입력 데이터 및 초기 컨볼루션 커널의 컨볼루션 연산 결과와 같다. 본 개시의 적어도 하나의 실시예는 다음을 포함하는 컨볼루션 연산 장치를 제공한다: 연산 컨볼루션 커널을 결 정하도록 구성된 결정 유닛(determination unit), 여기서 연산 컨볼루션 커널은 초기 컨볼루션 커널에 기초하여 획득되고, 초기 컨볼루션 커널은 [R, S, C, K]로 표현되고, 연산 컨볼루션 커널은 [1, 1, (CХRХS), K]로 표현 되고, R, S, C 및 K는 0보다 큰 정수이다; 타겟 데이터를 획득하기 위해 연산 컨볼루션 커널의 채널들의 수에 기초하여 입력 데이터의 레이아웃을 조절하도록 구성된 조절 유닛(adjustment unit), 여기서 타겟 데이터의 채 널들의 수 및 크기는 입력 데이터의 채널들의 수 및 크기와 다르고, 타겟 데이터의 채널들의 수는 연산 컨볼루 션 커널의 채널들의 수와 같다; 및 컨볼루션 연산 결과를 획득하기 위해 타겟 데이터 및 연산 컨볼루션 커널에 기초하여 컨볼루션 연산을 수행하도록 구성된 계산 유닛(calculation unit), 여기서 타겟 데이터 및 연산 컨볼 루션 커널의 컨볼루션 연산 결과는 입력 데이터 및 초기 컨볼루션 커널의 컨볼루션 연산 결과와 같다. 본 개시의 적어도 하나의 실시예는, 본 개시의 어느 실시예에 의해 제공되는 컨볼루션 연산 장치를 포함하는, 전자 디바이스를 제공한다. 본 개시의 적어도 하나의 실시예는 다음을 포함하는 전자 디바이스를 제공한다: 프로세서; 및 메모리, 메모리는 적어도 하나의 컴퓨터 프로그램 모듈(computer program module)을 포함하고, 여기서 적어도 하나의 컴퓨터 프로 그램 모듈은 프로세서에 의해 실행되도록 구성되고 메모리에 저장 (store)되고, 적어도 하나의 프로그램 모듈은 본 개시의 어느 실시예에 의해 제공되는 컨볼루션 연산 방법을 구현(implement)하도록 구성된다. 본 개시의 적어도 하나의 실시예는, 컴퓨터에 의해 실행되었을 때, 컴퓨터로 하여금 본 개시의 어느 실시예에 의해 제공되는 컨볼루션 연산 방법을 구현하도록 하는 비-일시적 컴퓨터 판독가능 명령어(non-transitory computer-readable instruction)들을 저장하는 저장 매체(storage medium)를 제공한다."}
{"patent_id": "10-2024-7039930", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 개시의 실시예들은 이 뒤의 첨부 도면들을 참조하여 더 상세하게 설명될 것이다. 본 개시의 특정 실시예들 이 도면들에 도시되어 있지만, 본 개시는 다양한 형태들로 구체화될 수 있고 여기에 제시된 실시예들에 제한되 는 것으로서 해석되어서는 안 된다고 이해되어야 한다; 오히려, 이 실시예들은 본 개시의 개념을 완전하고 완벽 하게 전달하기 위해 제공된다. 본 개시의 실시예들 및 첨부 도면들은 오직 예시적인 목적들을 위해 제공되고 본 개시의 보호의 권리범위를 제한하는 것으로 의도되지 않는다고 이해되어야 한다. 본 개시의 방법 실시예들에서 설명된 다양한 단계들은 다른 순서로, 및/또는 동시에 수행될 수 있는 점이 이해 되어야 한다. 게다가, 방법 실시예들은 추가적인 단계들을 포함할 수 있고 및/또는 일부 도시된 단계들은 생략 될 수 있다. 본 개시의 범위는 이러한 점에서 제한되지 않는다. 여기 사용되는 용어 \"포함하다(comprising)\" 및 이것의 변형(variant)들은 개방형(open-ended) 포함, 즉, \"포 함하지만 제한하지 않는\"으로 해석되어야 한다. 용어 \"기초하여(based on)\"는 \"적어도 부분적으로 기초\"하는 것을 지시한다. 문구 \"실시예\"는 :\"적어도 하나의 실시예\"를 나타내고; 문구 \"또다른 실시예\"는 \"적어도 하나 의 다른 실시예\"를 나타내고; 문구 \"일부 실시예들\"은 \"적어도 일부의 실시예들\"을 나타낸다. 다른 용어들의 정의들은 이후의 설명들에서 제공될 것이다. 본 개시 내의 \"제1\", \"제2\", 등과 같은 용어들의 사용은 상이한 디바이스들, 모듈들, 또는 유닛들 사이를 구별 하기 위한 목적들만을 위한 것이고, 이러한 디바이스들, 모듈들, 또는 유닛들에 의해 실행되는 기능들의 상호의 존성(interdependency) 또는 시퀀스(sequence)를 정의하도록 의도되지 않는다는 점은 주목되어야 한다. 또한, 본 개시 내에서 사용되는 수식어 \"하나의(one)\" 및 \"다수의(multiple)\"는 한정적이기보다는 예시적이라는 점은 주목할 만하다. 기술 분야에서 통상의 지식을 가진자들은, 문맥에서 달리 명시적으로 언급하지 않는 이상, 이들은 \"하나 이상(one or more)\"을 의미하는 것으로 해석되어야 한다고 이해해야 한다. 본 개시의 실시예들 내의 복수의 장치들 사이에서 교환되는 정보 또는 메시지들의 명칭은 오직 설명의 목적을 위해 사용되고 이 메시지들 또는 정보의 범위를 제한하는 것을 의도하지 않는다. 컨볼루션 뉴럴 네트워크의 입력은 일반적으로 3-채널 픽처(3-channel picture)다. 예를 들어, 레지듀얼 네트워 크(residual network) ResNet50의 첫번째-레이어 컨볼루션(first-layer convolution)의 입력은 [1, 224, 224, 3]이다. 즉, 입력 이미지는 3개 채널들을 갖고, 각각의 채널의 이미지 크기는 224Х224이다. 레지듀얼 네트워 크 ResNet50의 첫번째-레이어 컨볼루션에 의해 사용되는 컨볼루션 커널 형태의 형태는 [7, 7, 3, 64]이다. 일 반적으로 사용되는 뉴럴 네트워크 가속기(neural network accelerator)는, 일반적으로, 뉴럴 네트워크 내의 컨 볼루션 연산 및 행렬 연산(matrix operation)의 가속에 주로 책임이 있는 행렬 연산 유닛(matrix operation unit)이 제공된다. 행렬 연산을 가속하기 위해, 행렬 연산 유닛은 일반적으로 계산 스케일(computation scal e)을 증가시킴으로써 계산 병렬의 정도를 개선할 수 있다. 예를 들어, 연산 스케일은 64Х64, 128Х128 등일 수 있다. 그러나, 컨볼루션 뉴럴 네트워크의 첫번째-레이어 컨볼루션의 입력 데이터의 채널들의 적은 수(예를 들어, 3개 채널들)로 인해, 하드웨어 가속기(hardware accelerator) 상의 행렬 연산 유닛의 컴퓨팅 전력 (computing power) 활용 비율이 낮고, 첫번째-레이어 컨볼루션의 계산 시간은 상대적으로 길 수 있고 가속의 효 과는 분명하지 않다. 이것에 더하여, 만약 채널 정렬 텐서 레이아웃(channel align tensor layout)을 엄격하게 따른다면, 데이터의 메모리 공간은 상당히 증가할 것이고, 데이터의 전송 시간은 증가할 것이다. 도 1에 도시된 바와 같이, 하드웨어 가속기는 일반적으로 호스트(host)의 주변 컴포넌트 상호접속 익스프레스 (peripheral component interconnect express , PCIe) 노드(node) 상에 호스트의 슬레이브(slave) 디바이스로 서 마운트(mount)된다. PCIe는 고속 데이터 전송을 실현할 수 있는 고속 직렬 컴퓨터 확장 버스 표준(high- speed serial computer expansion bus standard)이다. 호스트에 관하여, 하드웨어 가속기는 디바이스로서 사 용된다. 컨볼루션 연산이 수행될 때, 첫번째-레이어 컨볼루션의 데이터 입력은 PCIe를 통해 호스트로부터 하드 웨어 가속기로 보내질 필요가 있고, 이 프로세스는 Host2Device로 불린다. 예를 들어, 중앙 처리 장치(central processing unit, CPU)는, 그 다음에 PCIe를 통해 디바이스 하드웨어 가속기로 전송(transmit)되고 하드웨어 가속기 상의 메모리(예를 들어, DDR) 내에 저장되는, 데이터를 메모리로부터 읽는다. 하드웨어 가속기는 그 다 음에 컨볼루션 연산을 수행하기 위해 이 데이터를 활용할 수 있다. 레지듀얼 네트워크 ResNet50의 첫번째-레이어 컨볼루션을 예로 들면, 첫번째-레이어 컨볼루션은 다음과 같이 표 현된 입력 데이터 및 컨볼루션 커널의 연산을 달성할 필요가 있다: [1, 224, 224, 3]Х[7, 7, 3, 64] = [1, 112, 112, 64]. 여기서, 입력 데이터는 [1, 224, 224, 3], 즉, 3-채널 데이터이고 224Х224의 크기를 갖는 것으로 표현된다. 컨볼루션 커널은 [7, 7, 3, 64], 즉, 각각이 3개 컨볼루션 커널들을 가지고 컨볼루션 커널은 7 Х7의 크기를 갖는 64 세트들로 표현된다. 결과는 112Х112의 크기를 갖는 64-채널 데이터로 획득된다. 하드웨어 가속기 상의 행렬 연산 유닛이 64Х64라고 가정하면, 채널 정렬 텐서 레이아웃의 한계로 인해, 첫번째 -레이어 컨볼루션의 입력 데이터는 호스트 상에서 [1, 224, 224, 3]로부터 [1, 224, 224, 64]로 확장될 필요가 있고, 모든 리더던트(redundant) 채널 데이터는 0으로 패딩(pad)된다. 메모리 공간에 관해서는, 21.33배 증가 할 필요가 있다. 유사하게, 호스트로부터 하드웨어 가속기로 전송될 데이터에 대한 전송 시간 또한 21.33배 증 가될 수 있다. 이 경우, 행렬 연산 유닛의 컴퓨팅 전력 활용 비율은 겨우 4.68%다. 컨볼루션 연산에 대한 시 간에 대해, 행렬 연산 유닛은 첫번째-레이어 컨볼루션의 연산을 완료하기 위해 614656 사이클이 걸릴 수 있다. 입력 데이터를 계산하기 위한 컨볼루션 뉴럴 네트워크의 첫번째-레이어 컨볼루션에 대한 채널들의 수가 적고 하 드웨어 가속기의 행렬 연산 유닛의 스케일이 크기 때문에, 결과는 계산 요구사항이 하드웨어 특성에 부합하지 않고, 컨볼루션 뉴럴 네트워크의 첫번째-레이어 컨볼루션의 계산 내의 다음 문제들을 야기한다. 첫째로, 입력 데이터의 레이아웃은 호스트의 CPU를 사용하여 재-조절(re-adjusted)될 필요가 있고, 차지(occupy)된 메모리 공 간은 증가하고 CPU 시간은 소모된다. 둘째로, 재-배열된 입력 데이터의 용량이 증가하고, Host2Device의 PCIe 전송 시간이 증가한다. 셋째로, 하드웨어 가속기의 행렬 연산 유닛의 활용 비율이 낮아서, 그것의 완전한 컴퓨 팅 전력을 활용하는데 실패하고, 하드웨어 자원의 낭비를 초래한다. 넷째로, 하드웨어 가속기의 행렬 연산 유 닛이 첫번째-레이어 컨볼루션의 계산을 수행하는 시간은 길고, 하드웨어 가속기의 목적은 달성될 수 없다. 본 개시의 적어도 하나의 실시예는 컨볼루션 연산 방법, 컨볼루션 연산 장치, 전자 디바이스, 및 저장 매체를 제공한다. 컨볼루션 연산 방법은 행렬 연산 유닛의 활용 비율을 증가시킬 수 있고, 컨볼루션 연산의 시간을 단 축할 수 있고, 행렬 연산 유닛의 컴퓨팅 전력을 효과적으로 활용할 수 있고, 연산 효율성을 개선할 수 있고, 데 이터 전송 시간을 절약할 수 있다. 본 개시의 실시예들은 첨부 도면들을 참조하여 더 상세하게 아래에서 설명될 것이다. 상이한 도면들 내의 유사 한 참조 번호들은 설명된 유사한 요소들을 지정하는데 사용될 수 있다는 점은 주목되어야 한다. 본 개시의 적어도 하나의 실시예는 컨볼루션 연산 방법을 제공한다. 컨볼루션 연산 방법은 다음을 포함한다: 연산 컨볼루션 커널을 결정하는 단계, 여기서 연산 컨볼루션 커널은 초기 컨볼루션 커널에 기초하여 획득되고,초기 컨볼루션 커널은 [R, S, C, K]로 표현되고, 연산 컨볼루션 커널은 [1, 1, (CХRХS), K]로 표현되고, R, S, C 및 K는 0보다 큰 정수이다; 타겟 데이터를 획득하기 위해 연산 컨볼루션 커널의 채널들의 수에 기초하여 입력 데이터의 레이아웃을 조절하는 단계, 여기서 타겟 데이터의 채널들의 수 및 크기는 입력 데이터의 채널들 의 수 및 크기와 다르고, 타겟 데이터의 채널들의 수는 연산 컨볼루션 커널의 채널들의 수와 같다; 및 컨볼루션 연산 결과를 획득하기 위해 타겟 데이터 및 연산 컨볼루션 커널에 기초하여 컨볼루션 연산을 수행하는 단계 타겟 데이터 및 연산 컨볼루션 커널의 컨볼루션 연산 결과는 입력 데이터 및 초기 컨볼루션 커널의 컨볼루션 연 산 결과와 같다. 도 2는 본 개시의 일부 실시예들에 의해 제공되는 컨볼루션 연산 방법의 흐름도이다. 도 2에 도시된 바와 같이, 일부 실시예들에서, 컨볼루션 연산 방법은 단계(S10) 내지 단계(S30)를 포함한다. 단계(S10): 연산 컨볼루션 커널을 결정하는 단계, 여기서 연산 컨볼루션 커널은 초기 컨볼루션 커널에 기초하여 획득되고, 초기 컨볼루션 커널은 [R, S, C, K]로 표현되고, 연산 컨볼루션 커널은 [1, 1, (CХRХS), K]로 표현 되고, R, S, C 및 K는 0보다 큰 정수다. 단계(S20): 타겟 데이터를 획득하기 위해 연산 컨볼루션 커널의 채널들의 수에 기초하여 입력 데이터의 레이아 웃을 조절하는 단계, 여기서 타겟 데이터의 채널들의 수 및 크기는 입력 데이터의 채널들의 수 및 크기와 다르 고, 타겟 데이터의 채널들의 수는 연산 컨볼루션 커널의 채널들의 수와 같다. 단계(S30): 컨볼루션 연산 결과를 획득하기 위해 타겟 데이터 및 연산 컨볼루션 커널에 기초하여 컨볼루션 연산 을 수행하는 단계, 여기서 타겟 데이터 및 연산 컨볼루션 커널의 컨볼루션 연산 결과는 입력 데이터 및 초기 컨 볼루션 커널의 컨볼루션 연산 결과와 같다. 예를 들어, 컨볼루션 연산 방법은 컨볼루션 뉴럴 네트워크의 첫번째-레이어 컨볼루션 연산에 적용될 수 있다. 물론, 본 개시의 실시예들이 그것에 제한되는 것은 아니다. 컨볼루션 연산 방법은, 컨볼루션 뉴럴 네트워크뿐 만 아니라 다른 유형들의 네트워크들의 컨볼루션 연산들에도 적용될 수 있고, 첫번째-레이어 컨볼루션 연산(레 이어 1 컨볼루션 연산)뿐만 아니라, 컨볼루션 연산들의 다른 레이어들에도 적용될 수 있다. 이것은 실제 요구 사항에 따라 결정될 수 있고 본 개시의 실시예들에 의해 제한되지 않는다. 예를 들어, 단계(S10)에서, 초기 컨볼루션 커널은 첫번째-레이어 컨볼루션 연산이 수행될 때 필요한 컨볼루션 커널이다. 초기 컨볼루션 커널은 [R, S, C, K]로 표현된다. 레지듀얼 네트워크 ResNet50의 첫번째-레이어 컨 볼루션을 예로 들면, 첫번째-레이어 컨볼루션에 의해 실현될 필요가 있는 연산은 다음과 같이 표현되고: [1, 224, 224, 3]Х[7, 7, 3, 64] = [1, 112, 112, 64], 초기 컨볼루션 커널[R, S, C, K]은 [7, 7, 3, 64]이다. 즉, 이 예시에서, R=7, S=7, C=3, 및 K=64이다. 초기 컨볼루션 커널의 파라미터는 연산 컨볼루션 커널 [1, 1, (CХRХS), K]을 획득하기 위해 변환(transform)된다. 위의 예시에서, 연산 컨볼루션 커널은 초기 컨볼루션 커 널에 따라 획득될 수 있다. 연산 컨볼루션 커널은 [1, 1, 147, 64]이다. 컨볼루션 커널의 변환(transform) 원 칙은 도 3을 참조하여 아래에서 간단하게 설명된다. 도 3은 컨볼루션 연산의 개략적인 도면이다. 도 3에 도시된 바와 같이, 만약 입력 데이터의 크기가 [1, 3, 3, 5]이고, 컨볼루션 커널의 크기가 [2, 2, 5, 4]라면, 출력 데이터의 크기는 [1, 2, 2, 4]이다. 예를 들어, 포인 트(point) M에 대하여, 그것의 계산 방식은 도 3에 도시된 바이다. 컨볼루션 커널의 크기는 2Х2이고 채널의 수는 5이기 때문에, 포인트 M은 입력 데이터의 20개 포인트들에 컨볼루션 커널의 해당하는 포인트들을 곱셈 (multiply)하고 그 다음에 곱(product)들을 축적(accumulate)한 것의 결과이다. 컨볼루션 계산의 특성들을 활 용함으로써, 컨볼루션 커널은 RХSХCХK로부터 1Х1Х(CХRХS)ХK로 변환(transform)될 수 있고, 입력 데이터 는 이에 따라 조절된다. 그러므로, 전체적인 컨볼루션의 계산 결과는 변하지 않고 유지된다. 이와 같은 변환 연산(transform operation)에 의해, 채널들의 수는 증가될 수 있다. 컨볼루션 뉴럴 네트워크의 첫번째-레이어 네트워크에 대하여, 컨볼루션 커널은 [7, 7, 3, 64]로부터 [1, 1, 147, 64]로 조절되고, 채널들의 수는 3으로부 터 3Х7Х7=147로 증가된다. 따라서, 행렬 연산 유닛의 컴퓨팅 전력은 완전히 활용될 수 있다. 그러므로, 단 계(S10)에서, 초기 컨볼루션 커널 [R, S, C, K]은 연산 컨볼루션 커널 [1, 1, (CХRХS), K]을 획득하기 위해 변환(transform)될 수 있고, 그렇게 함으로써 컨볼루션 커널의 레이아웃 내의 변화(change)를 달성한다. 예를 들어, 컨볼루션 커널의 레이아웃은, 배치(deployment) 스테이지에서 뉴럴 네트워크 모델에 의해 사용되는 컨볼루션 커널은 고정되어 있고 입력을 변화(vary)시키는 것으로 변화(vary)하지 않기 때문에, 오프라인으로 변 화될 수 있다. 그러므로, 컨볼루션 커널은 원하는 레이아웃으로 전처리(preprocess)될 수 있다. 본 개시의 실 시예들에서, 사용될 필요가 있는 컨볼루션 커널 [R, S, C, K]은 뉴럴 네트워크 모델의 배치 스테이지에서, 이후의 사용에 대해 컨볼루션 커널로 사용되는, [1, 1, (CХRХS), K]로 설정될 수 있다. 예를 들어, 초기 컨볼루 션 커널 [R, S, C, K]에 대응하는 코드는 모델 컴파일링(compiling) 단계에서 고-수준 언어(예를 들어, 파이썬 (Python))를 사용하여 수정(modify)될 수 있고, 그렇게 함으로써 연산 컨볼루션 커널 [1, 1, (CХRХS), K]을 획득한다. 물론, 본 개시의 실시예들은 그것에 제한되지 않는다. 또한, 사용될 필요가 있는 초기 컨볼루션 커 널 [R, S, C, K]은, 현재 연산 내에서 실제로 사용되는 연산 컨볼루션 커널 [1, 1, (CХRХS), K]을 획득하기 위해, 매번 컨볼루션 연산이 수행되기 전에 조절될 수 있다. 다시 도 2를 참조하면, 단계(S20)에서, 타겟 데이터를 획득하기 위해 연산 컨볼루션 커널의 채널들의 수에 기초 하여 입력 데이터의 레이아웃이 조절된다. 예를 들어, 타겟 데이터의 채널들의 수 및 크기는 입력 데이터의 채 널들의 수와 크기와 다르고, 타겟 데이터의 채널들의 수는 연산 컨볼루션 커널의 채널들의 수와 같다. 레지듀 얼 네트워크 ResNet50의 첫번째-레이어 컨볼루션을 예로 들면, 계산되어야하는 계산은 [1, 224, 224, 3]Х[7, 7, 3, 64] = [1, 112, 112, 64]이다. 컨볼루션 커널은 [1, 1, 147, 64]로 조절되었기 때문에, 계산 결과가 변 화하지 않는 것을 보장하기 위해서는, 연산이 [1, 112, 112, 147]Х[1, 1, 147, 64] = [1, 112, 112, 64]가 되 도록 입력 데이터의 레이아웃이 조절될 필요가 있다. 따라서, 입력 데이터를 조절한 후 획득되는 데이터가 [1, 112, 112, 147]라는 것은 알려질 수 있다. 예를 들어, 입력 데이터의 레이아웃을 조절한 후에 획득되는 데이터 는 타겟 데이터로서 언급(refer to)되고, 타겟 데이터는 연산 컨볼루션 커널과 컨볼루션 연산을 위한 최종 데이 터다. 예를 들어, 레이아웃이 조절되었기 때문에, 타겟 데이터의 채널들의 수 및 크기는 입력 데이터의 채널들 의 수 및 크기와 다르다. 위의 계산 식으로부터 알 수 있듯이, 타겟 데이터의 채널들의 수는 연산 컨볼루션 커 널의 채널들의 수(예를 들어, 위의 예시 내의 147개)와 같고, 그렇게 함으로써 양쪽의 컨볼루션 연산을 용이하 게 한다. 예를 들어, 타겟 데이터의 채널들의 수는 입력 데이터의 채널들의 수보다 크고 연산 컨볼루션 커널의 채널들의 수는 초기 컨볼루션 커널의 채널들의 수보다 크고, 그렇게 함으로써 채널들의 수의 증가를 달성하고 그 다음에 행렬 연산 유닛의 컴퓨팅 전력을 완전히 활용한다. 예를 들어, 위의 예시에서, 입력 데이터의 채널들의 수 및 초기 컨볼루션 커널의 수는 둘 다 3이고, 타겟 데이터의 채널들의 수 및 연산 컨볼루션 커널의 채널들의 수는 둘 다 147이고, 그렇게 함으로써 채널들의 수의 증가를 달성한다. 예를 들어, 입력 데이터의 레이아웃의 변화 는 온라인에서 완료될 필요가 있다. 즉, 데이터 입력의 레이아웃은 매번 뉴럴 네트워크의 추론(reasoning) 스 테이지에서 조절될 필요가 있다. 도 4는 도 2 내의 단계(S20)의 개략적인 흐름도이다. 예를 들어, 일부 예시들에서, 도 4에 도시된 바와 같이, 단계(S20)는 단계(S21) 내지 단계(S23)를 더 포함할 수 있다. 단계(S21): 입력 데이터를 행 단위 (units of a row)들로 정적 메모리에 저장하는 단계, 여기서 입력 데이터의 각각의 행은 정적 메모리 내의 해당하는 N개 엔트리(entry)들 내에 저장되고, N은 0보다 큰 정수이다. 단계(S22): 확장된 데이터를 획득하기 위해 정적 메모리에 저장된 입력 데이터에 패딩(padding)을 수행하는 단 계. 단계(S23): 타겟 데이터를 획득하기 위해 확장된 데이터의 채널들의 수 및 크기를 변화(change)시키도록 확장된 데이터(extended data)의 레이아웃을 조절하는 단계. 예를 들어, 단계(S21)에서, 입력 데이터는 첫째로 하드웨어 가속기 내에 배치(dispose)된 정적 메모리 내에 저 장된다. 정적 메모리는, 예를 들어, 정적 랜덤 액세스 메모리(static random access memory, SRAM)다. 입력 데이터는 행 단위들로 정적 메모리 내에 저장된다. 즉, 입력 데이터의 각각의 행은 정적 메모리 내의 해당하는 N개 엔트리들 내에 저장되고, N은 0보다 큰 정수이다. 예를 들어, 입력 데이터는 도 1에 도시된 데이터 흐름을 사용하여 정적 메모리에게 전송될 수 있다. 도 5에 도시된 바와 같이, 단계(S21)는 단계(S211) 내지 단계(S212)를 더 포함할 수 있다. 단계(S211): 입력 데이터를 밀집 레이아웃(dense layout)으로 메모리 내에 저장하는 단계, 여기서 입력 데이터 는 복수의 채널들을 포함하고, 밀집 레이아웃은 같은 데이터 포인트의 복수의 채널들이 메모리 내에 순차적 (sequential) 이고 근접 (contiguous) 방식으로 저장되는 것을 의미한다. 단계(S212): 메모리 내의 입력 데이터를 직접 메모리 접근 방식(direct memory access manner)으로 하드웨어 가속기의 정적 메모리에게 전송하고, 입력 데이터의 각각의 행이 정적 메모리 내의 해당하는 N개 엔트리들 내에 저장되도록 입력 데이터의 행들의 제1 데이터 포인트들을 정적 메모리의 상이한 행들의 제1 열들 내에 저장하는단계. 예를 들어, 단계(S211)에서, 밀집 레이아웃은, 예를 들어, 채널 정렬 텐서 레이아웃이다. 입력 데이터는 복수 의 채널들을 포함하고, 밀집 레이 아웃은 같은 데이터 포인트들의 복수의 채널들이 메모리 내에 순차적이고 근 접 방식으로 저장되는 것을 의미한다. 도 6에 도시되는 바와 같이, 일부 예시들에서, 첫번째-레이어 컨볼루션 의 입력 데이터는 [1, 224, 224, 3]이고, 여기서 숫자 1은 Batchsize=1을 나타내고(represent), 하나의 숫자 224는 Height=224를 나타내고, 반면 다른 숫자 224는 Width=224를 나타내고, 숫자 3은 Channel=3을 나타낸다. 즉, 입력 데이터는 224Х224의 크기를 갖는 3-채널 픽처다. 호스트 상의 데이터의 메모리 공간을 줄이기 위해, 데이터는 밀집 레이아웃으로 저장된다. 예를 들어, 입력 데이터의 제1 행 및 제1 열의 픽셀들에 대해, 3개 채 널들의 값들은 메모리 공간 상에 연속적으로(successively) 및 계속적으로 저장된다. 다음에, 제1 행 및 제2 열 상의 픽셀들이 계속적으로 저장되고, 그것의 3개 채널들의 값들은 메모리 공간 상에 연속적으로 및 계속적으 로 저장된다. 예를 들어, 각각의 픽셀의 각각의 채널의 값은 2바이트의 주소 공간을 차지하는 FP16 데이터 포맷으로 표현된다. 초기 레이어의 입력 픽처는 총 224Х224Х3Х2바이트=301056 바이트, 즉, 294KB를 차지한다. 여기 서, 사용되는 데이터 포맷 및 차지된 주소 공간은 둘 다, 본 개시의 실시예들 상에 제한들을 부과하지 않는, 예 시적인 것이다. 예를 들어, 단계(S212)에서, 메모리 내의 입력 데이터는 직접 메모리 접근(direct memory access, DMA) 방식으 로 하드웨어 가속기의 정적 메모리에게 전송된다. 데이터 이동 방식은 도 1에 도시된 방식일 수 있다. 첫번째 -레이어 컨볼루션의 입력 데이터는 PCIe를 통해 호스트로부터 디바이스의 DDR로 이동된다. DDR 내의 입력 데이 터의 저장 방식은 호스트의 메모리 내의 입력 데이터의 저장 방식과 일치한다. 따라서, 1차원의(1D) 텐서의 Host2Device 프로세스가 실현된다. 예를 들어, 입력 데이터는, 예를 들어 294KB를 차지하는, DDR 내에 계속적 으로 저장된다. 그 다음에, 입력 데이터는 정적 메모리에게 전송될 필요가 있다. 즉, 294KB 데이터는 처리 엔 진(processing engine, PE)(또한, 하드웨어 가속기로도 언급됨) 내에서 DDR로부터 SRAM으로 이동될 필요가 있다. 예를 들어, 저장할 때, 입력 데이터의 각각의 행이 정적 메모리 내의 해당하는 N개 엔트리들 내에 저장되도록 입력 데이터의 행들의 제1 데이터 포인트들(first data points)은 정적 메모리의 상이한 행들의 제1열(first column)들 내에 저장된다. 도 7에 도시된 바와 같이, 일부 예시들에서, SRAM의 조직 형태(organization form)는 M개 행들 및 N개 열들의 테이블로서 추상화(abstract)될 수 있고, 데이터의 한 조각은 각각의 테이블 내에 저장된다. 입력 데이터의 크 기가 224Х224이기 때문에, 입력 데이터는 논리적으로 224 행들로 나누어지며, 각각의 행의 시작 위치는 SRAM의 특정 행의 제1 열에 있다. SRAM의 열들의 제한된 수로 인해, 입력 데이터의 하나의 행을 SRAM의 하나의 행 내 에 완전히 저장하는 것은 어렵다. 그러므로, 입력 데이터의 하나의 행은 SRAM의 복수의 행들, 즉, 상이한 SRAM 주소에 흩어진다. [1, 224, 224, 3]의 입력 데이터에 대하여, 이후의 패딩에 의해 패딩되는 데이터를 고려하여, 각각의 행은 229개 포인트들을 가지고 각각의 포인트는 3개 채널들을 갖는다. 각각의 행이 1024비트 인 메모리 공간의 SRAM에 대하여, 데이터의 행을 저장하는데 필요한 SRAM의 행들의 수는 다음과 같고: ceil(229*3/64) = 11, ceil은 정수로 올림(round up)하는 것을 나타낸다. 즉, 입력 데이터의 데이터 포인트들 의 행은 SRAM의 11개 엔트리들 내에 대응하여 저장될 수 있다. 이 예시에서, N=11이고, 전체의 입력 데이터는 SRAM의 224Х11=2464개 행들을 차지한다. 도 7에 도시된 바와 같이, 왼쪽은 H, W, 및 C의 개념 없이 DDR 내에 계속적으로 저장되는 입력 데이터를 나타내 고; 오른쪽은, DMA에 의해 SRAM으로 이동된 후, 데이터는 입력 데이터의 행들을 따라 SRAM 내로 분열(split)되 고, 데이터의 각각의 행은 SRAM 공간의 특정 양(예를 들어, 11개 엔트리들)을 차지하는 것을 나타낸다. 따라서, DDR 내에서 DDR 로부터 SRAM으로의 데이터 이동, 및 1D 텐서로부터 2차원(2D) 텐서로의 변환은 완료된 다. DMA에 의한 이동의 프로세스는 아래에 간단하게 설명된다. 입력 데이터가 소스 주소(source address)(source_address)로 시작하는 계속적인 DDR 공간 내에 저장된다고 가 정하면, 224Х3Х2 바이트=1344 바이트의 데이터의 제1 행은 첫째로 데스티니 주소(destiny address)(destiny_address)로 시작하는 계속적인 SRAM 공간으로 이동될 필요가 있다. SRAM의 하나의 행이 128 바이트이기 때문에, 1344바이트는 SRAM의 ceil(1344/128)=11개 행들 내에 저장될 필요가 있다. 즉, DMA는 11Х128바이트의 데이터를 계속적으로 보낼 필요가 있다. 데이터의 제1 행의 이동을 완료한 후, DMA는 읽기 주소 를 source_address로부터 source_address + 1344바이트의 위치, 즉, 실제 입력 데이터의 제2 행의 시작의 DDR 주소로 점프(jump)하도록 할 필요가 있다. 그 다음에, 11Х128바이트는 density_address + 11로 시작하는 SRAM 공간으로 계속적으로 이동된다. 유사한 방식에서, 224번 이동을 완료한 후, 모든 입력 데이터는 처리 엔 진 내에서 DDR로부터 SRAM으로 이전(transfer)된다, 즉, 1D 텐서로부터 2D 텐서로의 변환을 완료한다. 매번 보내지는 11Х128바이트의 데이터의 용량은 각각의 행의 실제 데이터 용량보다 크고, 즉, 또한 다음 행의 데이터를 포함한다는 점은 주목될 필요가 있따. 그러나, 매번 보내지는 시작 주소가 정확하기 때문에, 데이터 자체는 데이터가 반복적으로 보내지더라도 영향을 받지 않을 수 있고, 리던던트 데이터(redundant data)는 이후 의 처리에 영향을 주지 않을 것이다. 다시 도 4를 참조하여, 예를 들어, 단계(S22)에서, 확장된 데이터를 획득하기 위해 정적 메모리 내에 저장된 입 력 데이터에 패딩이 수행된다. 여기서, 확장된 데이터는 패딩이 수행된 후에 획득되는 데이터를 의미한다. 예 를 들어, 일부 예시들에서, 실제 완료될 필요가 있는 컨볼루션 계산이 [1, 224, 224, 3]Х[7, 7, 3, 64] = [1, 112, 112, 64]라고 가정하면, 패딩은 입력 데이터에 위, 아래, 왼쪽, 및 오른쪽 방향으로 수행될 필요가 있다. 패딩할 때, 입력 데이터의 위쪽 및 왼쪽의 각각은 3개 포인트로 패딩될 필요가 있고(3개 열들이 왼쪽에 패딩되 고, 3개 행들이 위쪽에 패딩된다), 입력 데이터의 아래쪽 및 오른쪽의 각각은 2개 포인트로 패딩될 필요가 있다 (2개 열들이 오른쪽에 패딩되고, 2개 행들이 아래쪽에 패딩된다). 패딩이 수행된 후 획득된 확장된 데이터의 크기는 [1, 229, 229, 3]이다. 도 8은 도 4 내의 단계(S22)의 개략적인 흐름도이다. 도 8에 도시된 바와 같이, 단계(S22)는 단계(S221) 내지 단계(S223)를 더 포함할 수 있다. 단계(S221): 정적 메모리 내에서, 제1 중간 데이터(first intermediate data)를 획득하기 위해 입력 데이터에 대응하는 저장 위치(storage location)의 전후(in front of and after)의 엔트리들을 제1 프리셋 값(first preset value)으로 패딩하는 단계, 여기서 제1 중간 데이터는 입력 데이터 및 패딩된 제1 프리셋 값을 포함한다. 단계(S222): 제1 중간 데이터를 벡터 계산 유닛에게 전송하고, 제2 중간 데이터(second intermediate data)를 획득하기 위해 벡터 계산 유닛으로부터의 쉬프트 명령 및 패딩 명령을 사용하여 제1 중간 데이터에 대응하는 각 각의 행의 두 엔드(two ends)들을 제2 프리셋 값(second preset value)으로 패딩하는 단계, 여기서 제2 중간 데이터는 제1 중간 데이터 및 패딩된 제2 프리셋 값을 포함한다. 단계(S223): 확장된 데이터를 획득하기 위해 제2 중간 데이터를 정적 메모리 내의 해당하는 저장 위치로 전송하 는 단계, 여기서 확장된 데이터는 제2 중간 데이터와 내용이 동일하다. 예를 들어, 단계(S221)에서, 제1 중간 데이터를 획득하기 위해 정적 메모리 내의 입력 데이터에 대응하는 저장 위치의 전후의 엔트리들은 제1 프리셋 값으로 패딩되고, 여기서 제1 중간 데이터는 입력 데이터 및 패딩된 제1 프리셋 값을 포함한다. 예를 들어, 입력 데이터의 위쪽 및 아래쪽의 패딩은 이 단계에서 수행된다. 예를 들어, 일부 예시들에서, 위쪽 패딩에 의해 요구되는 SRAM 공간은 SRAM의 데스티니 주소 부근에 보류(reserve)될 필요가 있다. 즉, 복수의 데이터의 행들은 실제 입력 데이터의 제1 행 전에 삽입될 필요가 있다. 패딩은 하드 웨어 가속기 내의 벡터 계산 유닛(vector calculation unit)을 사용하여 위쪽 및 아래쪽에 수행된다. 예를 들 어, 패딩된 제1 프리셋 값은 일반적으로 0이고, 그러므로, 모든 0의 값은 SRAM 내의 입력 데이터의 메모리 공간 앞뒤의 복수의 주소에 작성(write)될 필요가 있고, 그렇게 함으로써 제1 중간 데이터를 획득한다. 제1 중간 데 이터는 위쪽 및 아래쪽에 패딩된 데이터이고, 제1 중간 데이터는 왼쪽 및 오른쪽에 패딩되지 않았다. 예를 들어, 단계(S222)에서, 제1 중간 데이터는 벡터 계산 유닛에게 전송되고, 제2 중간 데이터를 획득하기 위 해 제1 중간 데이터에 대응하는 각각의 행의 두 끝들은 벡터 계산 유닛으로부터의 쉬프트 명령어(shift instruction)(예를 들어, vshiftri 명령어) 및 패딩 명령어(padding instruction)(예를 들어, SI2V 명령어)를 사용하여 제2 프리셋 값으로 패딩된다. 제2 중간 데이터는 제1 중간 데이터 및 패딩된 제2 프리셋 값을 포함한 다. 예를 들어, 제1 중간 데이터의 왼쪽 및 오른쪽에 패딩이 수행된다. 예를 들어, 일부 예시들에서, SRAM 내의 2464개 주소 공간 상의 데이터는 11 행들 마다 그룹화(group)되고, 연 속적으로 벡터 계산 유닛에게 보내지고, 벡터 계산 유닛 내의 메모리 공간 vmem 내에 저장된다. 벡터 계산 유 닛은 그 다음에 vshiftri 명령어를 사용하여 전체를 오른쪽으로 쉬프트(shift)하고, 왼쪽 편에 패딩을 위한 공 간을 남기고, 그 후에 SI2V 명령어를 사용하여 해당하는 제2 프리셋 값(예를 들어, 일반적으로 0으로 설정된다)을 이 위치들에 작성한다. 오른쪽 편의 패딩을 위해, 데이터가 전체로서 오른쪽으로 쉬프트된 후, 해당하는 제2 프리셋 값은 입력 데이터의 제1 행 및 마지막 열 이후에 작성된다. 만약 데이터 용량이 너무 크다면, vmem 공간은 요구되는 만큼 추가적으로 증가될 필요가 있다. 예를 들어, 왼쪽 패딩 및 오른쪽 패딩은 처리 효율성 (processing efficiency)을 개선하기 위해 파이프라인 방식으로 복수의 11 행들의 데이터의 세트들 상에 수행될 수 있다. 예를 들어, 단계(S223)에서, 확장된 데이터를 획득하기 위해 제2 중간 데이터는 정적 메모리 내의 해당하는 저 장 위치로 전송된다. 확장된 데이터는 제2 중간 데이터와 내용이 동일하다. 즉, vmem 내의 제2 중간 데이터는 SRAM 내의 해당하는 주소 공간으로 돌아가 다시 작성된다. SRAM 내에 저장되고 패딩된 데이터는 확장된 데이터 로 불린다. 단계(S22)는 입력 데이터 상에 패딩이 수행될 필요가 없을 때 생략될 수 있다는 점은 주목될 필요가 있다. 게 다가, 본 개시의 실시예에서, 패딩이 수행되어야 하는 경우에 관하여, 첫째로 위쪽 및 아래쪽 패딩, 뒤이어 왼 쪽 및 오른쪽 패딩이 수행될 수 있고; 또는 첫째로 왼쪽 및 오른쪽 패딩, 뒤이어 위쪽 및 아래쪽 패딩이 수행될 수 있다. 구체적인 패딩 순서는 제한되지 않는다. 패딩을 수행할 때 사용되는 명령어들은 vshiftri 명령어 및 SI2V 명령어에 제한되지 않고, 패딩이 달성될 수 있는 한 다른 적합한 명령어들이 사용될 수 있고, 이는 본 개 시의 실시예들에 제한되지 않을 것이다. 다시 도 4를 참조하면, 예를 들어, 단계(S23)에서, 확장된 데이터의 채널들의 수 및 크기를 변화시키도록 확장 된 데이터의 레이아웃이 조절되고, 그렇게 함으로써 타겟 데이터를 획득한다. 즉, 연산 컨볼루션 커널에 부합 하고 연산 결과가 변화하지 않고 유지되는 것을 보장하기 위해서, 확장된 데이터의 레이아웃은 그것의 채널들의 수 및 크기가 변화하도록 조절될 필요가 있다. 예를 들어, 조절로부터의 결과적인 타겟 데이터의 채널들의 수 는 연산 컨볼루션 커널의 채널들의 수와 같고, 타겟 데이터는 [1, ht, wt, (CХRХS)]로 표현되고, ht 및 wt는 0보다 큰 정수이다. 도 9는 도 4 내의 단계(S23)의 개략적인 흐름도이다. 도 9에서 나타난 바와 같이, 단계(S23)는 단계들(S231 및 S232)를 더 포함할 수 있다. 단계(S231): 정적 메모리의 R*N개 엔트리들 내의 데이터를 연속적으로 읽어 벡터 계산 유닛으로 전송하는 단계. 단계(S232): 타겟 데이터를 획득하기 위해, 벡터 계산 유닛에 의해, 매번 수신되는 R*N개 엔트리들 내의 데이터 를 wt*ceil((CХRХS)/L)개 엔트리들의 데이터로 변환(convert)하는 단계. 예를 들어, 단계(S231)에서, 벡터 계산 유닛이 매번 수신되는 R*N개 엔트리들 내의 데이터를 변환할 수 있도록 정적 메모리의 R*N개 엔트리들 내의 데이터가 매번 읽히고 벡터 계산 유닛에 전송된다. 예를 들어, 각각의 읽 기의 시작 주소(start address)는 프리셋 스트라이드(preset stride) str에 따라 str*N개 엔트리들만큼 쉬프트 (shift)된다. 프리셋 스트라이드는 입력 데이터 및 초기 컨볼루션 커널에 행 방향 및 열 방향으로 컨볼루션 연 산을 수행하기 위해 요구되는 특징 윈도우(feature window)의 스트라이드(stride)이고, 정적 메모리로부터의 데 이터의 읽기의 총 수는 ht와 같다. 예를 들어, 일부 예들에서, 여전히 레지듀얼 네트워크 ResNet50의 첫번째-레이어 컨볼루션를 예로 들 때, 초기 컨볼루션 커널은 [R, S, C, K]=[7, 7, 3, 64]이고, 즉, R=7이다. 입력 데이터는 [1, 224, 224, 3]이다. 입력 데이터의 하나의 행은 SRAM의 N개 엔트리들에 저장된다. 만약 SRAM의 하나의 행의 공간이 128 Bytes라면, N=11 이다. 그러므로, R*N=77개의 엔트리들의 데이터는 224Х224 크기의 입력 데이터의 하나의 행에 대응된다. 예 를 들어, 입력 데이터 [1, 224, 224, 3] 및 초기 컨볼루션 커널 [7, 7, 3, 64]에 행 방향 및 열 방향으로 컨볼 루션 연산을 수행하기 위해 요구되는 특징 윈도우의 스트라이드는 2이다. 그러므로, 프리셋 스트라이드 str은 2이다. 예를 들어, 컨볼루션 연산이 수행될 때, 읽혀진 데이터가 특징 윈도우에 포함된 원본 데이터와 일치 (consistent)하도록, 각각의 읽기의 시작 주소는 프리셋 스트라이드 str에 따라 str*N(즉, 2Х11=22)개 엔트리 들만큼 쉬프트된다. 식 [1, 224, 224, 3]Х[7, 7, 3, 64] = [1, 112, 112, 147]Х[1, 1, 147, 64] = [1, 112, 112, 64]에서 알 수 있듯, 컨볼루션 커널은 [1, 1, 147, 64]로 변환(transform)되고, 변환(transformation)을 통해 획득되어야 하는 타겟 데이터 [1, ht, wt, (CХRХS)]는 [1, 112, 112, 147]이고, 그러므로, ht=112 이고 wt=112이다. 예를 들어, 정적 메모리로부터의 데이터의 읽기의 총 수는 ht(즉, 112)이다. 매번 읽혀진 데이터 는 변환 후 타겟 데이터의 하나의 행에 대응된다. 예를 들어, 단계(S232)에서, 벡터 계산 유닛은 매번 수신되는 R*N개 엔트리들 내의 데이터를 wt*ceil((CХRХ S)/L)개 엔트리들의 데이터로 변환(convert)하고, 변환된 데이터는 타겟 데이터이다. 즉, 데이터의 레이아웃(layout)이 데이터의 사이즈 및 채널들의 수를 변경하도록 조절된다. 예를 들어, 계산식에서, L은 정적 메모리 의 각 엔트리에서 저장가능한(storable) 데이터 포인트들(data points)의 수를 나타내고, ceil((CХRХS)/L)은 정수로 반올림한 (CХRХS)/L를 나타낸다. 예를 들어, 일부 예들에서, 벡터 계산 유닛은 매번 7Х11개의 엔트 리들의 데이터를 수신한다. 만약 SRAM의 하나의 행의 공간이 128 Bytes라면, 각 엔트리에서 저장가능한 데이터 포인트들의 수 L은 64이다. 초기 컨볼루션 커널이 [7, 7, 3, 64]일 때, R=7이고, S=7이고, C=3이다. 타겟 데 이터가 [1, ht, wt, (CХRХS)]=[1, 112, 112, 147]일 때, wt=112이다. 그러므로, wt*ceil((CХRХS)/L)=112 Х3이다. 즉, 벡터 계산 유닛은 매번 7Х11개의 엔트리들의 데이터를 112Х3개 엔트리들의 데이터로 변화한다. 도 10은 도 9 내의 단계(S232)의 개략적인 흐름도이다. 예를 들어, 일부 예들에서, 단계(S232)는 단계들(S2321 내지 S2323)을 더 포함한다. 단계(S2321): 프리셋 스트라이드에 따라 R* N 엔트리들(entries)을 복수의 데이터의 세트들로 나누는(divide) 단계. 단계(S2322): 각각의 데이터의 세트에 대해, 데이터의 세트에 대응하는 특징 윈도우의 각각의 데이터의 행의 초 기 위치 정보 파라미터 및 타겟 위치 정보 파라미터를 결정하는 단계. 단계(S2323): 타겟 데이터를 획득하기 위해 초기 위치 정보 파라미터 및 타겟 위치 정보 파라미터에 기초하여 벡터 계산 유닛(vector calculation unit)에 의해, 각각의 데이터의 세트를 타겟 메모리의 대응하는 위치 내에 변환(convert)된 레이아웃으로 저장하는 단계. 예를 들어, 단계(S2321)에서, R*N개 엔트리들 내의 데이터는 프리셋 스트라이드에 따라 복수의 데이터의 세트들 로 분할되고, 여기서 각 데이터의 세트는 행 방향의 하나의 특징 윈도우에 대응하고, 복수의 데이터의 세트들의 수는 wt와 같다. 예를 들어, 일부 예들에서, 7x11개 엔트리들의 데이터는 프리셋 스트라이드 str=2, 및 wt=112 에 따라 112개의 데이터의 세트들로 분할된다. 7x11개 엔트리들의 데이터는 입력 데이터 224x224의 한 행의 데 이터에 해당하고, 분할된 112개의 데이터의 세트들은 보폭 2로 한 행의 데이터 224에 수행되는 112개의 특징 윈 도우들에 해당한다. 예를 들어, 단계(S2322)에서, 각 데이터의 세트에 대해, 데이터의 세트에 대응하는 특징 윈도우의 각 데이터의 행의 초기 위치 정보 파라미터 및 타겟 위치 정보 파라미터가 결정된다. 초기 위치 정보 파라미터는 특징 윈도 우 내의 데이터의 행의 소스 주소(source address)를 결정하는 데 사용되고, 타겟 위치 정보 파라미터는 이러한 데이터가 이동되는 목적지 주소를 결정하는 데 사용된다. 단계들(S2321 내지 S2322)의 동작 모드는 예시의 방식으로 아래에 설명된다. 예를 들어, 입력 데이터 [1, 224, 224, 3]에 상하, 좌우 패딩을 수행한 후, 전체 입력 데이터의 크기가 [1, 229, 229, 3]으로 변경되어, SRAM에서 229x11 주소 공간들을 차지(occupy)한다. 다음으로, 입력 데이터의 형태 (shape)가 [1, 112, 112, 147]로 변환되어야 한다. 본질적으로, 컨볼루션 연산의 경우, 컨볼루션 커널이 슬라 이딩(slide)하는 각 특징 윈도우는 도 11에 도시된 바와 같이 [7x7x3]으로부터 [1, 1, 147]로의 변환을 완수 (accomplish)해야 한다. 컨볼루션 커널이 슬라이딩하는 각 특징은 원본(original) 데이터(입력 데이터 또는 입력 이미지)의 7개 행들 및 7개 열들에 해당하고, 좌측 상단으로부터 우측 하단까지 슬라이딩하는 동안 컨볼루션 커널에 의해 스위핑 (sweep)되는 특징 윈도우들은 오버랩(overlap)을 가질 수 있다. 열 방향의 오버랩의 경우, SRAM으로부터 데이 터를 반복적으로 읽(read)는 것을 방지(avoid)하기 위해, 7x11=77개 주소 공간들의 데이터가 매번 SRAM으로부터 읽히고 처리를 위해 벡터 계산 유닛으로 전송된다. 행 방향의 오버랩의 경우, 특징 윈도우는 왼쪽으로부터 오 른쪽으로 슬라이딩하면서 행 방향으로 오버랩하는 데이터(overlapping data)를 반복적으로 읽을 것이다. 전체 적으로, SRAM 내의 데이터는 변환된 112개 행들에 해당하는 112개 데이터의 세트들로 분할된다. 각 데이터의 세트는 변환 전에 7x11 주소 공간들을 차지한다. 한 데이터의 세트를 읽은 후, 벡터 계산 유닛은 데이터를 처 리하고 112x3 주소 공간들의 데이터 크기를 출력하며, 여기서 112는 변환 후의 데이터 폭에 해당하며, 3은 147 개 채널들에 의해 차지되는 공간에 해당한다(147개 채널들은 3개의 SRAM 엔트리들, 즉, 3개의 SRAM 주소 공간들 을 차지해야 한다). 벡터 계산 유닛이 한 데이터의 세트를 가져온 후, 7x11 SRAM 엔트리들의 데이터는 벡터 계산 유닛 내의 vmem에 일시적으로 저장될 것이고, 데이터 레이아웃은 변경되지 않는다. 데이터는 그 후 벡터 계산 유닛으로부터의 명 령어 연산을 사용하여 112x3 vmem 엔트리들의 데이터로 변환된다. 결과는 그 후 SRAM에 다시 기록된다.변환 후의 데이터 폭은 행 방향으로 112 포인트들이고, 각 포인트는 3개의 vmem 엔트리들에 분산되는 147개의 채널들을 가진다. 행 방향의 각 포인트에 대해, 원본의 7x7x3에 해당하는 특징 윈도우는 1x1x147로 변환되어야 한다. 이를 위해, 각 특징 윈도우 내의 해당하는 7개의 데이터의 행들이 발견되고 그 후 새로운 데이터 레이아 웃으로 재구성(reorganize)되어야 한다. 도 12에 도시된 바와 같이, 제1 특징 윈도우의 경우, 특징 윈도우의 데이터 폭은 7x3=21개 채널들이고 총 7개 데이터의 행들을 커버(cover)한다(따라서 7x11개 엔트리들에 저장됨). 7개의 데이터의 행들의 저장 주소가 결정되어야 하고 그 후 해당 데이터의 레이아웃이 변환되어야 한다. 도 12 의 우측을 참조하면, 7개 데이터의 행들은 3개 행들로 재배열되고, 원본의 행들 0, 1, 및 2는 새로운 제1 행을 구성하고, 원본의 행들 3 및 4는 새로운 제2 행을 구성하며, 원본의 행들 5 및 6은 새로운 제3 행을 구성한다. 새로운 3개 행들은 원본의 7x7x3에 해당하는 특징 윈도우 내에서 커버되는 총 147개 데이터 포인트들을 저장한 다. 유사한 방식으로, 행 방향의 다음 특징 윈도우에 대해, 7개 데이터의 행들에 해당하는 특징 윈도우들의 한 행이 완전히 변환될 때까지 데이터의 레이아웃은 여전히 유사하게 변환된다. 그 후, 7x11개 엔트리들의 다음 데이터의 세트가 읽힌다. 특징 윈도우 내에서 데이터의 각 행의 초기 위치 및 타겟 위치를 결정하기 위해, 초기 위치 정보 파라미터 및 타겟 위치 정보 파라미터가 특징 윈도우 내의 각 데이터의 행에 대해 정의되어야 한다. 초기 위치 정보 파라미터는 제1 시작 경계 좌표(first start boundary coordinate), 제1 엔드 경계 좌표(first end boundary coordinate), 제1 시작 주소(first start address), 제1 엔드 주소(first end address), 제1 시 작 일련번호(first start serial number), 및 제1 엔드 일련번호(first end serial number)를 포함한다. 제1 시작 경계 좌표는 확장된 데이터의 행 방향에서 해당하는 특징 윈도우의 시작 경계의 상대 좌표(relative coordinate)를 나타내고, 제1 엔드 경계 좌표는 확장된 데이터의 행 방향에서 해당하는 특징 윈도우의 엔드 경 계의 상대 좌표를 나타낸다. 해당하는 특징 윈도우의 시작 경계 및 해당하는 특징 윈도우의 엔드 경계는 확장 된 데이터의 행 방향에서 상이한 위치들에 위치된다. 패딩이 수행된 후 획득되는 데이터가 확장된 데이터이므 로, 좌표들 및 파라미터들이 확장된 데이터에 대해 정의된다. 패딩을 수행할 필요가 없는 다른 경우들에서, 이 러한 좌표들 및 파라미터들은 입력 데이터에 대해 직접 정의될 수 있다. 도 12에 도시된 바와 같이, 시작 경계 (start boundary) 는, 예를 들어, 특징 윈도우의 좌측 경계이고, 제1 시작 경계 좌표는, 예를 들어, 229x3의 확 장된 데이터의 행 방향에서 특징 윈도우의 좌측 경계의 상대 좌표이다. 엔드 경계(end boundary)는, 예를 들어, 특징 윈도우의 우측 경계이고, 제1 엔드 경계 좌표는 229x3의 확장된 데이터의 행 방향에서 특징 윈도우 의 우측 경계의 상대 좌표이다. 제1 시작 경계 좌표에 대한 계산 식은 src_row_start_index = i * str * ch이다. src_row_start_index는 제1 시작 경계 좌표를 나타내고; i는 타겟 데이터의 크기 wt에서 해당하는 특징 윈도우의 해당하는 데이터 포인트의 일련번호(serial number)를 나타내고(예: 특징 윈도우가 총 112개의 특징 윈도우들 중 어느 행에 있는지, 즉, 출력 데이터의 폭 wt=112에서 어느 행에 있는지를 나타냄); str은 행 방향의 특징 윈도우의 스트라이드(예: 2) 를 나타내고; ch은 입력 데이터의 채널들의 수(예: 3)을 나타낸다. 제1 엔드 경계 좌표에 대한 계산 식은 src_row_end_index = src_row_start_index + (kernel_w * ch - 1)이다. src_row_end_index는 제1 엔드 경계 좌표를 나타내고; kernel_w는 특징 윈도우의 폭(예: 7)을 나타내고; 특징 윈도우의 크기는 초기 컨볼루션 커널의 크기와 동일하다(예: 둘 다 7x7). 제1 시작 주소는 벡터 계산 유닛의 메모리(예: vmem) 내에서 제1 시작 경계 좌표의 주소를 나타내고, 제1 엔드 주소는 벡터 계산 유닛의 메모리(예: vmem) 내에서 제1 엔드 경계 좌표의 주소를 나타낸다. 제1 시작 일련번호 는 제1 시작 주소에서 제1 시작 경계 좌표에 해당하는 데이터 포인트의 일련번호를 나타내고, 제1 엔드 일련번 호는 제1 엔드 주소에서 제1 엔드 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타낸다. vmem은 행 단 위의 저장을 허용하므로, vmem 내의 특정 엔트리는 제1 시작 주소 또는 제1 엔드 주소에 따라 위치될 수 있다. 제1 시작 일련번호 또는 제1 엔드 일련번호는 해당하는 데이터가 엔트리 내에서 어떤 데이터인지를 나타낸다. 제1 시작 주소에 대한 계산 식은 src_row_start_address = src_row_start_index / vmem_lane + j * N이다. src_row_start_address는 제1 시작 주소를 나타내고; vmem_lane은 벡터 계산 유닛의 메모리 내의 각각의 엔트리 에 의해 저장 가능한 데이터 포인트들의 수를 나타내고; j는 특징 윈도우 내의 해당하는 데이터의 행 일련번호 (예: 1 내지 7의 숫자)를 나타낸다. 제1 엔드 주소에 대한 계산 식은 src_row_end_address = src_row_end_index / vmem_lane + j * N이다. src_row_end_address는 제1 엔드 주소를 나타낸다.제1 시작 일련번호에 대한 계산 식은 src_row_start_lane = src_row_start_index % vmem_lane이다. src_row_start_lane은 제1 시작 일련번호를 나타낸다. 예를 들어, %는 모듈로 연산(modulo operation)을 나타 낸다. 제1 엔드 일련번호에 대한 계산 식은 src_row_end_lane = src_row_end_index % vmem_lane이다. src_row_end_lane은 제1 엔드 일련번호를 나타낸다. 위의 파라미터들이 결정된 후, vmem 내에서 7x7x3을 변환하는 데 요구되는 소스 데이터의 위치가 결정될 수 있 다. 이러한 소스 데이터를 vmem의 목적지 주소로 전송하기 위해, 해당하는 목적지 주소 및 관련된 파라미터들 도 결정되어야 한다. 즉, 타겟 위치 정보 파라미터가 결정되어야 한다. 타겟 위치 정보 파라미터는 제2 시작 경계 좌표(second start boundary coordinate), 제2 엔드 경계 좌표 (second end boundary coordinate), 제2 시작 주소(second start address), 제2 엔드 주소(second end address), 제2 시작 일련번호(second start serial number), 및 제2 엔드 일련번호(second end serial numbe r)를 포함한다. 제2 시작 경계 좌표는 [1, 1, (CХRХS)]의 데이터 크기에서 해당하는 특징 윈도우의 시작 경계의 상대 좌표를 나타내고, 제2 엔드 경계 좌표는 [1, 1, (CХRХS)]의 데이터 크기에서 해당하는 특징 윈도우의 엔드 경계의 상 대 좌표를 나타낸다. 해당하는 특징 윈도우의 시작 경계 및 해당하는 특징 윈도우의 엔드 경계는 확장된 데이 터의 행 방향에서 상이한 위치들에 위치된다. 예를 들어, 타겟 데이터는 [1, ht, wt, (CХRХS)]로 표현된다. 일부 예들에서, 타겟 데이터는 [1, 112, 112, 147]이고, 각각의 특징 윈도우에 대응하는 데이터 크기는 [7, 7, 3]으로부터 [1, 1, 147]으로 변환되어야 한다. 도 12에 도시된 바와 같이, 시작 경계는, 예를 들어, 특징 윈도 우의 좌측 경계이고, 제2 시작 경계 좌표는 [1, 1, 147]의 데이터 크기에서 특징 윈도우의 좌측 경계의 상대 좌 표이다. 엔드 경계는, 예를 들어, 특징 윈도우의 우측 경계이고, 제2 엔드 경계 좌표는 [1, 1, 147]의 데이터 크기에서 특징 윈도우의 우측 경계의 상대 좌표이다. 제2 시작 경계 좌표에 대한 계산 식은 dst_row_start_index = j * kernel_w * ch이다. dst_row_start_index는 제2 시작 경계 좌표를 나타내고; j는 특징 윈도우 내에서 해당하는 데이터의 행 일련번호(예: 1 내지 7의 숫 자)를 나타내고; kernel_w는 특징 윈도우의 폭(width)(예: 7)을 나타내고; 특징 윈도우의 크기는 초기 컨볼루션 커널의 크기와 동일하고(예: 둘 다 7x7); ch는 입력 데이터의 채널의 수(예: 3)를 나타낸다. 제2 엔드 경계 좌표에 대한 계산 식은 dst_row_end_index = dst_row_start_index + (kernel_w * ch - 1)이다. dst_row_end_index는 제2 엔드 경계 좌표를 나타낸다. 제2 시작 주소는 벡터 계산 유닛의 메모리(예: vmem) 내의 제2 시작 경계 좌표의 주소를 나타내고, 제2 엔드 주 소는 벡터 계산 유닛의 메모리(예: vmem) 내의 제2 엔드 경계 좌표의 주소를 나타낸다. 제2 시작 일련번호는 제2 시작 주소에서 제2 시작 경계 주소에 대응하는 데이터 포인트의 일련번호를 나타내고, 제2 엔드 일련번호는 제2 엔드 주소에서 제2 엔드 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타낸다. vmem은 행 단위로의 저장을 허용하므로, vmem 내의 특정 엔트리는 제2 시작 주소 또는 제2 엔드 주소에 따라 위치될 수 있다. 제2 시작 일련번호 또는 제2 엔드 일련번호는 엔트리 내에서 해당하는 데이터가 어떤 데이터인지를 나타낸다. 제2 시작 주소에 대한 계산 식은 dst_row_start_address = dst_row_start_index / vmem_lane이다. dst_row_start_address는 제2 시작 주소를 나타내고; vmem_lane은 벡터 계산 유닛의 메모리 내의 각각의 엔트리 에 의해 저장 가능한 데이터 포인트들의 수를 나타낸다. 제2 엔드 주소에 대한 계산 식은 dst_row_end_address = dst_row_end_index / vmem_lane이다. dst_row_end_address는 제2 엔드 주소를 나타낸다. 제2 시작 일련번호에 대한 계산 식은 dst_row_start_lane = dst_row_start_index % vmem_lane이다. dst_row_start_lane은 제2 시작 일련번호를 나타낸다. 제2 엔드 일련번호에 대한 계산 식은 dst_row_end_lane = dst_row_end_index % vmem_lane이다. dst_row_end_lane은 제2 엔드 일련번호를 나타낸다. 초기 위치 정보 파라미터 및 타겟 위치 정보 파라미터가 결정된 후에, 데이터 전송을 위해 요구되는 소스 주소 및 목적지 주소가 결정될 수 있다. 다음으로, 소스 데이터는 이러한 파라미터들에 따라 목적지 주소로 이동될 수 있다.예를 들어, 단계(S2323)에서, 초기 위치 정보 파라미터 및 타겟 위치 정보 파라미터가 결정된 후, 벡터 계산 유 닛은 각각의 데이터의 세트를 타겟 메모리의 해당하는 위치에 변환된 레이아웃으로 저장한다. 타겟 위치 정보 파라미터에 의해 지시(indicate)되는 목적지 주소는 타겟 메모리 내의 주소이다. 따라서, 타겟 데이터가 획득 된다. 예를 들어, 타겟 메모리는 행 단위로의 저장을 허용한다. 타겟 메모리에 전송되고 타겟 메모리에 저장 되는 데이터는 타겟 데이터이다. 예를 들어, 타겟 메모리는 위에 설명된 정적 메모리일 수 있으며(이 경우, 변 환 전의 데이터 및 변환 후의 데이터는 정적 메모리의 상이한 주소에 저장됨), 또는 위에 설명된 정적 메모리와 다른 저장 디바이스(storage device)일 수 있고, 본 개시의 실시예들에 제한되지 않을 것이다. 예를 들어, 단계(S2323)는 다음을 더 포함할 수 있다: 초기 위치 정보 파라미터 및 타겟 위치 정보 파라미터에 기초하여, 벡터 계산 유닛에 의해 순환 쉬프트 명령어(cyclic shift instruction)예를 들어, 단계(S2323)는 다 음을 더 포함할 수 있다: 초기 위치 정보 파라미터 및 타겟 위치 정보 파라미터에 기초하여, 벡터 계산 유닛에 의해 순환 쉬프트 명령어(cyclic shift instruction)를 사용하여 벡터 프레디케이트 레지스터(vector predicate register) 내의 프리셋 활성화 신호(preset enable signal)에 따라 변환된 레이아웃의 각각의 데이 터의 세트를 스플라이싱(splice)하고, 타겟 데이터를 획득하기 위해 타겟 메모리의 해당하는 위치에 데이터를 저장하는 단계. 예를 들어, 일부 예들에서, 소스 주소의 데이터는 벡터 계산 유닛의 명령어 세트 아키텍처(벡 터 ISA(Vector ISA)) 내의 vshiftri 명령어를 사용하여 복수의 위치들만큼 오른쪽으로 순환적으로 쉬프트 (shift)된 후, (VR 레지스터로도 지칭되는) 벡터 프레디케이트 레지스터내의 기록 활성화 신호(write enable signal)에 따라 목적지 주소에 기록될 수 있다. 이전에 설명된 프리셋 활성화 신호는, 예를 들어, 기록 활성화 신호이다. 7Х7Х3의 특징 윈도우에 해당하는 데이터를 1Х1Х147의 데이터로 변환하는 스플라이싱 프로세스 (splicing process)에서, 사용되는 VR 레지스터는 제2 시작 일련번호(dst_row_start_lane) 및 제2 엔드 일련번 호(dst_row_end_lane)에 따라 결정되어야 한다. vshiftri 명령어 및 VP 레지스터를 사용하는 방식에 대해서, 기존 설계를 참조할 수 있으므로, 여기서는 더이상 상세히 설명되지 않을 것이다. 위에서 언급된 방식으로, 2D 텐서로부터 3차원(three-dimensional, 3D) 텐서로의 변환은 벡터 계산 유닛을 사용 하여 완료(complete)된다. 단계들의 진행 후, 입력 데이터 [1, 224, 224, 3]는 타겟 데이터 [1, 112, 112, 147]로 변환되고 초기 컨볼루 션 커널 [7, 7, 3, 64]에 따라 결정되는 연산 컨볼루션 커널은 [1, 1, 147, 64]이고, 이는 3으로부터 147로의 채널들의 수의 증가를 초래한다. 도 2를 다시 참조하면, 단계(S30)에서, 컨볼루션 결과를 획득하기 위해 컨볼루션 연산이 타겟 데이터 및 연산 컨볼루션 커널에 기초하여 수행된다. 타겟 데이터 및 연산 컨볼루션 커널의 컨볼루션 연산 결과는 입력 데이터 및 초기 컨볼루션 커널의 컨볼루션 연산 결과와 동일하다. 예를 들어, 단계(S30)는 다음을 더 포함한다: 매트 릭스 연산 유닛(Matrix)을 사용하여 타겟 데이터 및 연산 컨볼루션 커널에 대해 컨볼루션 연산을 수행하는 단계. 예를 들어, 일부 예들에서, 레지듀얼 네트워크 ResNet50의 첫번째-레이어 컨볼루션을 예로 들면, 구현되어야 하 는 입력 데이터 및 초기 컨볼루션 커널에 대한 연산은 [1, 224, 224, 3]Х[7, 7, 3, 64] = [1, 112, 112, 64] 이다. 3개의 채널들만 있으므로, 행렬 연산 유닛의 컴퓨팅 파워(computing power)가 충분히 활용되지 않는다. 본 개시의 실시예들에 의해 제공되는 컨볼루션 연산 방법을 사용하면, 초기 컨볼루션 커널 [7, 7, 3, 64]에 기 초하여 획득되는 연산 컨볼루션 커널은 [1, 1, 147, 64]이고, 입력 데이터 [1, 224, 224, 3]의 레이아웃을 조절 함으로써 획득되는 타겟 데이터는 [1, 112, 112, 147]이다. 따라서, 타겟 데이터 및 연산 컨볼루션 커널에 대 해 실제로 수행되는 연산은 [1, 112, 112, 147] Х [1, 1, 147, 64] = [1, 112, 112, 64]이다. 컨볼루션 연산 결과는 획득되도록 의도되는 컨볼루션 연산 결과와 일치한다. 채널들의 수가 147개로 증가하므로, 행렬 연산 유닛의 컴퓨팅 파워는 충분히 활용될 수 있고; 행렬 연산 유닛의 활용률(utilization ratio)이 증가할 수 있고; 컨볼루션 연산의 시간이 단축될 수 있고; 연산 효율이 개선될 수 있다. 또한, 호스트 CPU를 사용하여 입력 데 이터의 레이아웃을 다시 조절하고 호스트의 채널들의 수를 늘릴 필요가 없으므로, 차지된 데이터 공간이 크게 증가하지 않을 것이고, 호스트로부터 디바이스로 전송되는 데이터 볼륨이 증가하지 않을 것이다. 따라서, Host2Device의 PCIe 전송 시간은 증가하지 않으므로 데이터 전송 시간이 절약될 것이다. 본 개시의 실시예들에 의해 제공되는 컨볼루션 연산 방법은 하드웨어 가속의 목적을 달성하는 것을 돕고, 컨볼 루션 뉴럴 네트워크(convolutional neural network, CNN)의 첫번째-레이어 컨볼루션 계산의 가속을 구현할 수 있고, 작은 저장 공간, 짧은 전송 시간, 높은 하드웨어 모듈 활용률, 및 짧은 계산 시간과 같은 특성들 (characteristics)을 가진다. 예를 들어, 일반적인 컨볼루션 연산 방법을 사용하여 레지듀얼 네트워크ResNet50의 첫번째-레이어 컨볼루션을 수행하는 데 필요한 시간은 614656 사이클이고, 본 개시의 실시예들에 의 해 제공되는 컨볼루션 연산 방법을 사용하여 레지듀얼 네트워크 ResNet50의 첫번째-레이어 컨볼루션을 수행하는 데 드는 시간은 전자의 6.1%로 감소된 37632 사이클이다. 이는 컨볼루션 뉴럴 네트워크(CNN)의 첫번째-레이어 컨볼루션 계산 시간을 크게 단축시킨다. 본 개시의 실시예들에서, 본 개시의 전술한 실시예들에서 제공되는 컨볼루션 연산 방법의 흐름은 더 많거나 적 은 연산들을 포함할 수 있고, 이러한 연산들은 순차적으로(in sequence) 수행되거나 동시에 수행될 수 있다는 것에 유의해야 한다. 위에 설명된 컨볼루션 연산 방법의 흐름은 특정 순서로 발생하는 복수의 연산들을 포함하 지만, 복수의 연산들의 순서가 제한되지 않는다는 것이 명확히 이해될 것이다. 위에 설명된 컨볼루션 연산 방 법은 한 번 수행될 수 있고 또는 미리 결정된 조건에 따라 여러 번 수행될 수도 있다. 전술한 설명은 예로서 레지듀얼 네트워크 ResNet50의 첫번째-레이어 컨볼루션을 들었지만, 본 개시의 실시예들 로 제한하는 것이 아니라는 것에 유의해야 한다. 본 개시의 실시예들에 의한 컨볼루션 연산 방법은 임의의 적 절한 연산에 적용될 수 있고, 다양한 타입들의 데이터의 채널들의 크기들 및 개수들과 다양한 컨볼루션 커널들 의 채널들의 크기들 및 개수들은 실제 요구 사항들에 따라 결정될 수 있고, 위에 설명한 바와 같이 특정 값들로 제한되지 않는다. 본 개시의 적어도 하나의 실시예는 컨볼루션 컨볼루션 연산 장치를 더 제공한다. 컨볼루션 연산 장치는 행렬 연산 유닛의 활용률을 증가시키고, 행렬 연산 유닛의 컴퓨팅 파워를 효과적으로 활용하고, 컨볼루션 연산의 시 간을 단축하고, 연산 효율을 개선하고, 데이터 전송 시간을 절약할 수 있다. 도 13은 본 개시의 일부 실시예들에 의해 제공되는 컨볼루션 연산 장치의 개략적인 블록도이다. 도 13에 도시 된 바와 같이, 일부 실시예들에서, 컨볼루션 연산 장치는 결정 유닛, 조절 유닛, 및 계산 유닛 을 포함한다. 결정 유닛은 연산 컨볼루션 커널을 결정하도록 구성된다. 예를 들어, 연산 컨볼루션 커널은 초기 컨볼루 션 커널에 기초하여 획득되고; 초기 컨볼루션 커널은 [R, S, C, K]로 표현되며; 연산 컨볼루션 커널은 [1, 1, (CХRХS), K]로 표현되고; R, S, C, 및 K는 모두 0보다 큰 정수들이다. 예를 들어, 결정 유닛은 도 2에 도시된 컨볼루션 연산 방법의 단계(S10)를 수행할 수 있다. 조절 유닛은 타겟 데이터를 획득하기 위해 연산 컨볼루션 커널의 채널들의 수에 기초하여 입력 데이터의 레이아웃을 조절하도록 구성된다. 예를 들어, 타겟 데이터의 채널들의 크기 및 개수는 입력 데이터의 채널들의 크기 및 개수와 다르고, 타겟 데이터의 채널들의 수는 연산 컨볼루션 커널의 채널들의 수와 동일하다. 예를 들 어, 조절 유닛은 도 2에 도시된 컨볼루션 연산 방법의 단계(S20)을 수행할 수 있다. 계산 유닛은 컨볼루션 연산 결과를 획득하기 위해 타겟 데이터 및 연산 컨볼루션 커널에 기초하여 컨볼루 션 연산을 수행하도록 구성된다. 예를 들어, 타겟 데이터 및 연산 컨볼루션 커널의 컨볼루션 연산 결과는 입력 데이터 및 초기 컨볼루션 커널의 컨볼루션 연산 결과와 동일하다. 예를 들어, 계산 유닛은 도 2에 도시된 컨볼루션 연산 방법의 단계(S30)을 수행할 수 있다. 예를 들어, 결정 유닛, 조절 유닛, 및 계산 유닛은 하드웨어, 소프트웨어, 펌웨어, 및 이들의 임의의 실현 가능한 조합일 수 있다. 예를 들어, 결정 유닛, 조절 유닛, 및 계산 유닛은 범용 또는 특수 목적의 회로들일 수 있고, 프로세서 및 메모리의 조합일 수도 있다. 본 개시의 실시예들은 결정 유 닛, 조절 유닛, 및 계산 유닛의 구체적인 구현 형태들에 특별한 제한을 가지지 않는다. 본 개시의 실시예들에서, 컨볼루션 연산 장치의 유닛들은 위에 설명된 컨볼루션 연산 방법의 단계들에 대 응한다는 점에 유의해야 한다. 컨볼루션 연산 장치의 구체적인 기능들은 위에서 설명된 컨볼루션 연산 방 법에 관한 관련 설명들을 참조하여 알 수 있고, 여기서는 중복적으로 설명되지 않을 것이다. 도 13에 도시된 컨볼루션 연산 장치의 구성 요소들 및 구조들은 단지 예시일 뿐이고 제한적이지 않다. 필요에 따라, 컨볼 루션 연산 장치는 다른 구성 요소들 및 구조들을 더 포함할 수 있다. 본 개시의 적어도 하나의 실시예는 전자 디바이스를 더 제공한다. 전자 디바이스는 행렬 연산 유닛의 활용률을 증가시키고, 행렬 연산 유닛의 컴퓨팅 파워를 효과적으로 활용하고, 컨볼루션 연산의 시간을 단축시키고, 연산 효율을 개선하고, 데이터 전송 시간을 절약할 수 있다. 도 14는 본 개시의 일부 실시예들에서 제공되는 전자 디바이스의 개략적인 블록도이다. 도 14에 도시된 바와 같이, 전자 디바이스는 컨볼루션 연산 장치를 포함한다. 컨볼루션 연산 장치는 본 개시의 임의의 실시예에 의해 제공되는 컨볼루션 연산 장치, 예를 들어, 위에 설명된 컨볼루션 연산 장치일 수 있다. 전자 디바이스는 서버, 단말 디바이스(terminal device) 및 개인용 컴퓨터와 같이, 컴퓨팅 기능을 가지는 임의의 디바이스일 수 있고, 본 개시의 실시예들로 제한되지 않을 것이다. 도 15는 본 개시의 일부 실시예들에 의해 제공되는 또다른 전자 디바이스의 개략적인 블록도이다. 도 15에 도 시된 바와 같이, 전자 디바이스는 프로세서 및 메모리를 포함하고, 클라이언트 또는 서버를 구 현하도록 구성될 수 있다. 메모리는 컴퓨터-실행가능 명령어들(computer-executable instructions)(예: 적어도 하나의(하나 이상의) 컴퓨터 프로그램 모듈)을 비일시적으로 저장하도록 구성된다. 프로세서는 컴 퓨터-실행가능 명령어들을 실행하도록 구성된다. 컴퓨터-실행가능 명령어들은, 프로세서에 의해 실행될 때, 위에서 설명된 컨볼루션 연산 방법의 하나 이상의 단계들을 구현하여, 위에서 설명된 컨볼루션 연산 방법을 실현할 수 있다. 메모리 및 프로세서는 버스 시스템 및/또는 (도시되지 않은) 다른 형태의 연결 메 커니즘을 통해 상호 연결될 수 있다. 예를 들어, 프로세서는 중앙 처리 유닛(central processing unit, CPU), 그래픽 처리 유닛(graphics processing unit, GPU), 또는 데이터 처리 능력 및/또는 프로그램 실행 능력을 가지는 다른 형태의 처리 유닛일 수 있다. 예를 들어, CPU는 X86 또는 ARM 아키텍처 등일 수 있다. 프로세서는 범용 프로세서 또는 특수 목적의 프로세서일 수 있고 원하는 기능들을 수행하기 위해 전자 디바이스의 다른 구성 요소들을 제어할 수 있다. 예를 들어, 메모리는 적어도 하나의(하나 이상의) 컴퓨터 프로그램 제품의 임의의 조합을 포함할 수 있다. 컴퓨터 프로그램 제품들은 다양한 형태들의 컴퓨터 판독가능 기록 매체들, 예를 들어, 휘발성 메모리 및/또는 비휘발성 메모리를 포함할 수 있다. 휘발성 메모리는, 예를 들어, 랜덤-액세스 메모리(random-access memory, RAM) 및/또는 캐시 등을 포함할 수 있다. 비휘발성 메모리는, 예를 들어, 읽기 전용 메모리(read only memory, ROM), 하드 디스크, 지울 수 있는 프로그래밍 가능한 읽기 전용 메모리(erasable programmable read-only memory, EPROM), 컴팩트 디스크 읽기 전용 메모리(compact disk read-only memory, CD-ROM), USB 메모리, 플래 시 메모리 등을 포함할 수 있다. 적어도 하나의(예를 들어, 하나 이상의) 컴퓨터 프로그램 모듈들이 컴퓨터 판 독가능 저장 매체에 저장될 수 있고, 프로세서는 적어도 하나의(예를 들어, 하나 이상의) 컴퓨터 프로그램 모듈을 실행하여 전자 디바이스의 다양한 기능들을 실현할 수 있다. 다양한 APP들 및 다양한 종류의 데이 터 뿐만 아니라 APP들에 의해 사용 및/또는 생성되는 다양한 종류의 데이터 등도 컴퓨터 판독가능 기록 매체에 저장될 수 있다. 본 개시의 실시예들에서, 전자 디바이스의 구체적인 기능들 및 기술적 효과들은 컨볼루션 연산 방법에 관 한 위의 설명을 참조하여 알 수 있으며, 여기서는 중복하여 설명되지 않을 것임에 유의하여야 한다. 도 16은 본 개시의 일부 실시예들에 의해 제공되는 또다른 전자 디바이스의 개략적인 블록도이다. 예를 들어, 본 개시의 실시예들에서 제공되는 컨볼루션 연산 방법을 구현하도록 적응(adapt)된 전자 디바이스. 전자 디바이스는 단말 디바이스 등일 수 있고 클라이언트 또는 서버를 구현하도록 구성될 수 있다. 본 개시의 실시예에서 전자 디바이스는 모바일 폰(mobile phone), 노트북 컴퓨터, 디지털 방송 수신기(digital broadcasting receiver), 개인용 디지털 보조기기(personal digital assistant, PDA), 휴대 가능 안드로이드 디바이스 (portable Android device, PAD), 휴대 가능 미디어 플레이어(portable media player, PMP), 차량-장 착 단말(vehicle-mounted terminal)(예: 차량-장착 내비게이션 단말(vehicle-mounted navigation terminal)), 웨어러블 전자 디바이스(wearable electronic device), 및 디지털 TV, 데스크탑 컴퓨터, 및 스마트 홈 디바이스 와 같은 고정 단말들(fixed terminals)을 포함할 수 있으나 이에 한정되지 않는다. 도 16에 도시된 전자 디바 이스는 단지 예시일 뿐이고 본 개시의 실시예들의 기능들 및 사용 범위에 어떠한 제한도 가하지 않을 것이 라는 점에 유의해야 한다. 도 16에 도시된 바와 같이, 전자 디바이스는 읽기 전용 메모리(ROM)에 저장된 프로그램 또는 저장 수 단들로부터 랜덤 액세스 메모리(RAM)으로 로딩(load)된 프로그램에 따라 다양한 적절한 액션들 (actions) 및 처리를 수행할 수 있는, 처리 수단들(예: 중앙 처리 유닛, 그래픽 처리 유닛)을 포함할 수 있다. RAM은 전자 디바이스의 동작들을 위해 요구되는 다양한 프로그램들 및 데이터를 더 저장한다. 처리 수단들, ROM, 및 RAM은 버스를 통해 상호 연결된다. 입력/출력(I/O) 인터페이스 (interface)도 버스에 연결된다. 보통, 다음의 수단들이 I/O 인터페이스에 연결될 수 있다: 예를 들어, 터치 스크린(touch screen), 터치 패드(touch pad), 키보드, 마우스, 카메라, 마이크, 가속도계(accelerometer), 및 자이로스코프(gyroscope)를포함하는 입력 수단들; 예를 들어, 액정 디스플레이(LCD), 라우드스피커(loudspeaker), 및 진동기 (vibrator)를 포함하는 출력 수단들; 예를 들어, 자기 테이프(magnetic tape) 및 하드 디스크를 포함하는 저장 수단들; 및 통신 수단. 통신 수단들은 전자 디바이스가 다른 전자 디바이스들과 무 선 또는 유선으로 통신하여 데이터를 교환할 수 있도록 한다. 도 16은 다양한 수단들을 가지는 전자 디바이스 를 도시하지만, 모든 도시된 수단들이 반드시 구현 또는 포함된 것은 아니라는 점이 이해되어야 한다. 전 자 디바이스는 대안적으로 더 많거나 적은 수단들을 구현하거나 포함할 수 있다. 예를 들어, 본 개시의 실시예들에 따르면, 위에 설명된 컨볼루션 연산 방법은 컴퓨터 소프트웨어 프로그램으로 구현될 수 있다. 예를 들어, 본 개시의 실시예는 비일시적 컴퓨터 판독가능 매체에 탑재(carry)된 컴퓨터 프로 그램을 포함하는, 컴퓨터 프로그램 제품을 제공한다. 컴퓨터 프로그램은 위에 설명된 컨볼루션 연산 방법을 수 행하기 위한 프로그램 코드를 포함한다. 이러한 실시예에서, 컴퓨터 프로그램은 통신 수단들을 통해 온라 인으로 다운로드되어 설치되거나, 저장 매체들로부터 설치되거나, ROM으로부터 설치될 수 있다. 컴 퓨터 프로그램이 처리 수단에 의해 실행될 때, 본 개시의 실시예들에서 제공되는 컨볼루션 연산 방법에 정 의된 기능들이 실현될 수 있다. 본 개시의 적어도 하나의 실시예는 저장 매체를 더 제공한다. 행렬 연산 유닛의 활용률을 증가시키고, 행렬 연 산 유닛의 컴퓨팅 파워를 효과적으로 활용하고, 컨볼루션 연산의 시간을 단축하고, 연산 효율을 개선하고, 데이 터 전송 시간을 절약하기 위해 저장 매체가 사용될 수 있다. 도 17은 본 개시의 일부 실시예들들에 의해 제공되는 저장 매체의 개략도이다. 도 17에 도시된 바와 같이, 저 장 매체는 비일시적 컴퓨터 실행가능 명령어들(non-transitory computer-executable instructions) 을 저장하는 비일시적 컴퓨터 판독가능 저장 매체일 수 있다. 비일시적 컴퓨터 실행가능 명령어들이 프로 세서에 의해 실행될 때, 본 개시의 실시예들에서의 컨볼루션 연산 방법이 구현될 수 있다. 예를 들어, 비일시 적 컴퓨터 실행가능 명령어들이 프로세서에 의해 실행될 때, 위에서 설명된 컨볼루션 연산 방법의 하나 이 상의 단계들이 수행될 수 있다. 예를 들어, 저장 매체가 위에서 설명된 전자 디바이스에 적용될 수 있다. 예를 들어, 저장 매체는 전자 디바이스 내의 메모리를 포함할 수 있다. 예를 들어, 저장 매체는 스마트 폰의 저장 카드(storage card), 태블릿 컴퓨터의 메모리 소자(memory component), 개인용 컴퓨터의 하드 디스크, 랜덤 액세스 메모리(RAM), 읽기 전용 메모리(ROM), 지울 수 있는 프 로그래밍 가능한 읽기 전용 메모리(EPROM), 컴팩트 디스크 읽기 전용 메모리(CD-ROM), 플래시 메모리, 또는 이 러한 저장 매체들의 임의의 조합을 포함할 수 있고, 다른 적절한 저장 매체일 수도 있다. 예를 들어, 저장 매체에 관한 설명은 전자 디바이스의 실시예에서 메모리의 설명을 참조하여 알 수 있으며, 여기서는 중복해서 설명되지 않을 것이다. 저장 매체의 구체적인 기능들 및 기술적 효과들은 컨 볼루션 연산 방법에 관한 위의 설명을 참조하여 알 수 있으며, 여기서는 중복해서 설명되지 않을 것이다. 본 개시의 실시예들에 의해 제공되는 컨볼루션 연산 방법, 컨볼루션 연산 장치, 전자 디바이스, 및 저장 매체는 도 1 내지 도 17과 함께 위에서 설명되었다. 본 개시의 실시예들에 의해 제공되는 컨볼루션 연산 방법은 컨볼 루션 뉴럴 네트워크의 첫번째-레이어 컨볼루션 연산에 적용될 수 있다. 채널들의 수는 컨볼루션 연산이 많은 채널들을 가지는 타겟 데이터 및 많은 채널들을 가지는 연산 컨볼루션 커널에 대해 수행되도록 데이터의 레이아 웃을 조절함으로써 증가된다. 따라서, 행렬 연산 유닛의 활용률이 증가될 수 있고; 행렬 연산 유닛의 컴퓨팅 파워가 효과적으로 활용될 수 있고; 컨볼루션 연산의 시간이 단축될 수 있고; 연산 효율이 개선될 수 있고; 데 이터 전송 시간이 절약될 수 있다. 본 개시의 맥락에서, 컴퓨터 판독가능 매체는 명령어 실행 시스템, 장치 또는 디바이스에 의해 사용되거나 이와 조합하여 사용하기 위한 프로그램을 포함하거나 저장할 수 있는 유형 매체(tangible medium)일 수 있다는 점에 유의해야 한다. 컴퓨터 판독가능 매체는 컴퓨터 판독가능 신호 매체 또는 컴퓨터 판독가능 저장 매체 또는 이 들의 임의의 조합일 수 있다. 예를 들어, 컴퓨터 판독가능 저장 매체는 전기, 자기, 광학, 전자기, 적외선, 또 는 반도체 시스템, 장치 또는 디바이스, 또는 이들의 임의의 조합일 수 있으나 이에 국한되지 않는다. 컴퓨터 판독가능 저장 매체의 보다 구체적인 예들은 하나 이상의 와이어를 사용한 전기적 연결, 휴대 가능한 컴퓨터 디 스크, 하드 디스크, 랜덤 액세스 메모리(RAM), 읽기 전용 메모리(ROM), 지울 수 있는 프로그래밍 가능한 읽기 전용 메모리(EPROM 또는 플래시 메모리), 광섬유, 컴팩트 디스크 읽기 전용 메모리(CD-ROM), 광학적 저장 디바 이스, 자기 저장 디바이스, 또는 이들의 임의의 적절한 조합을 포함할 수 있지만 이에 국한되지 않는다. 본 개시에서, 컴퓨터 판독가능 저장 매체는 프로그램을 포함하거나 저장하는 임의의 유형의 매체일 수 있고, 프로그 램은 명령어 실행 시스템, 장치, 또는 디바이스에 의해 사용되거나 이와 조합하여 사용될 수 있다. 본 개시에 서, 컴퓨터 판독가능 신호 매체는 베이스밴드(baseband)에서 또는 캐리어(carrier)의 일부로서 전파되고 컴퓨터 판독가능 프로그램 코드를 전달(carry)하는 데이터 신호를 포함할 수 있다. 이러한 방식으로 전파되는 데이터 신호는 전자기 신호, 광 신호, 또는 이들의 임의의 적절한 조합을 포함하되 이에 국한되지 않는 복수의 형태들 을 취할 수 있다. 컴퓨터 판독가능 신호 매체는 컴퓨터 판독가능 저장 매체 이외의 또다른 컴퓨터 판독가능 매 체일 수도 있다. 컴퓨터 판독가능 저장 매체는 명령어 실행 시스템, 장치 또는 디바이스에 의해 또는 이와 조 합하여 사용되는 프로그램을 보내거나, 전파하거나, 전송할 수 있다. 컴퓨터 판독가능 매체에 포함된 프로그램 코드는 전선(electric wire), 광섬유 케이블(fiber-optic cable), 무선 주파수(radio frequency, RF) 등 또는 이들의 임의의 조합을 포함하지만 이에 국한되지 않는 임의의 적절한 매체를 사용함으로써 전송될 수 있다. 일부 실시 예들에서, 클라이언트와 서버는 HTTP(HyperText Transfer Protocol)와 같이 현재 알려져 있거나 미래 에 개발될 임의의 네트워크 프로토콜을 이용하여 통신할 수 있으며, 임의의 형태 또는 임의의 매체로 디지털 데 이터(예: 통신 네트워크)와의 통신 또는 상호 연결을 달성(achieve)할 수 있다. 통신 네트워크의 예들은 로컬 영역 네트워크(Local Area Network, LAN), 광역 네트워크(Wide Area Network, WAN), 인터넷 워크(예: 인터넷), 피어투피어(peer-to-peer) 네트워크(예: 애드혹 피어투피어 네트워크(ad hoc peer-to-peer network)), 및 현재 알려져 있거나 미래에 개발될 임의의 네트워크를 포함할 수 있다. 상기 언급된 컴퓨터 판독 가능 매체는 위에서 설명된 전자 디바이스에 포함되거나 전자 디바이스와 조립 (assemble)되지 않고 단독으로 존재할 수 있다. 본 개시의 동작들을 수행하기 위해 컴퓨터 프로그램 코드는 하나 이상의 프로그래밍 언어들 또는 이들의 조합으 로 작성될 수 있다. 프로그래밍 언어들은 Java, Smalltalk 및 C++과 같은 객체 지향 프로그래밍 언어 및 C 또는 이와 유사한 프로그래밍 언어들과 같은 기존의(conventional) 절차적 프로그래밍 언어들을 포함하지만, 이에 국 한되지 않는다. 프로그램 코드는 사용자 컴퓨터에서 완전히 실행되거나, 사용자 컴퓨터에서 부분적으로 실행되 거나, 독립 소프트웨어 패키지로 실행되거나, 원격 컴퓨터 또는 서버에서 완전히 실행될 수 있다. 원격 컴퓨터 가 사용되는 경우, 원격 컴퓨터는 로컬 영역 네트워크 또는 광역 네트워크를 포함한 모든 유형의 네트워크를 통 해 사용자 컴퓨터에 연결되거나 외부 컴퓨터에 연결(예를 들어, 인터넷 서비스 공급자를 이용하여 인터넷 상으 로 연결)될 수 있다. 첨부된 도면들의 흐름도들 또는 블록도들은 본 개시의 실시예들에 따른 시스템, 방법 및 컴퓨터 프로그램 제품 에 의해 구현될 수 있는 시스템 아키텍쳐들(system architectures), 기능들 및 동작들을 예시한다. 이와 관련하 여, 흐름도 또는 블록도의 각 블록은 모듈, 프로그램 세그먼트(program segment) 또는 코드의 일부를 나타낼 수 있으며, 모듈, 프로그램 세그먼트 또는 코드의 일부는 특정된 논리 기능들을 구현하기 위한 하나 이상의 실행가 능한 명령어들을 포함할 수 있다. 또한, 일부 대안적인 실시예들에서는 블록들에 표시된 기능들이 도면들에 표 시된 것과 다른 순서로 발생할 수 있음을 유의할 필요가 있다. 예를 들어, 연속적으로 나타나는 두 블록들은 관련된 기능들에 따라, 실제로 상당 부분 병렬적으로 실행되거나 때때로 역순으로 실행될 수 있다. 흐름도들 및/또는 블록도들의 각 블록 및 흐름도들 및/또는 블록도들의 블록들의 조합들은 특정된 기능들 또는 동작들을 실행하기 위한 전용 하드웨어 기반 시스템에 의해 구현되거나, 전용 하드웨어와 컴퓨터 명령어들의 조합에 의해 구현될 수 있다. 본 개시의 실시예들에서 기술된 관련 유닛들은 소프트웨어에 의해 구현되거나 하드웨어에 의해 구현될 수 있다. 유닛의 이름은 유닛 자체에 대한 제한을 구성하지 않는다. 본 명세서에서 상기 기술된 기능들은 하나 이상의 하드웨어 논리 구성 요소들에 의해 적어도 부분적으로 수행될 수 있다. 예를 들어, 제한 없이 사용될 수 있는 하드웨어 논리 구성 요소의 대표적인 유형들로는 FPGA(Field Programmable Gate Array), ASIC(Application Specific Integrated Circuit), ASSP(Application Specific Standard Product), SOC(System on Chip), CPLD(Complex Programmable Logic Device) 등이 있다. 본 개시의 하나 이상의 실시 예들에 따르면, 컨볼루션 연산 방법은, 연산 컨볼루션 커널(operation convolution kernel)을 결정하는 단계, 타겟 데이터를 획득(obtain)하기 위해 상기 연산 컨볼루션 커널의 채널들의 수에 기 초하여 입력 데이터의 레이아웃을 조절(adjust)하는 단계 및 컨볼루션 연산 결과를 획득하기 위해 타겟 데이터 및 연산 컨볼루션 커널에 기초하여 컨볼루션 연산(convolution operation)을 수행하는 단계를 포함하고, 연산 컨볼루션 커널은 초기 컨볼루션 커널에 기초하여 획득되고, 초기 컨볼루션 커널은 [R, S, C, K]로 표현되고, 연 산 컨볼루션 커널은 [1, 1, (CХRХS), K]로 표현되고, R, S, C 및 K는 0보다 큰 정수이고, 타겟 데이터의 채널들의 수 및 크기는 입력 데이터의 채널들의 수 및 크기와 다르고, 타겟 데이터의 채널들의 수는 연산 컨볼루션 커널의 채널들의 수와 같고, 타겟 데이터 및 연산 컨볼루션 커널의 컨볼루션 연산 결과는 입력 데이터 및 초기 컨볼루션 커널의 컨볼루션 연산 결과와 같을 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 데이터의 채널들의 수는 입력 데이터의 채널들의 수보다 크고, 연산 컨볼루션 커널의 채널들의 수는 초기 컨볼루션 커널의 채널들의 수보다 클 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 데이터를 획득하기 위해 연산 컨볼루션 커널의 채널들의 수에 기초하여 입력 데이터의 레이아웃을 조절하는 단계는, 입력 데이터를 행 단위들로 정적 메모리(static memory) 내에 저장(store)하는 단계, 확장된 데이터(extended data)를 획득하기 위해 정적 메모리에 저장된 입력 데이터 에 패딩(padding)을 수행하는 단계 및 타겟 데이터를 획득하기 위해 확장된 데이터의 채널들의 수 및 크기를 변 화시키도록 확장된 데이터의 레이아웃을 조절하는 단계를 포함하고, 입력 데이터의 각각의 행은 정적 메모리 내 의 해당하는 N개 엔트리(entry)들에 내에 저장되고, N은 0보다 큰 정수일 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 입력 데이터를 행 단위들로 정적 메모리 내에 저장하는 단계는, 입 력 데이터를 밀집 레이아웃으로 메모리 내에 저장하는 단계, 및 메모리 내의 입력 데이터를 직접 메모리 접근 방식으로 하드웨어 가속기의 정적 메모리에게 전송하고, 입력 데이터의 각각의 행이 정적 메모리 내의 해당하는 N개 엔트리들 내에 저장되도록 입력 데이터의 행들의 제1 데이터 포인트들을 정적 메모리의 상이한 행들의 제1 열들 내에 저장하는 단계를 포함하고, 입력 데이터는 복수의 채널들을 포함하고, 밀집 레이아웃은 같은(same) 데이터 포인트의 복수의 채널들이 메모리 내에 순차적이고 근접 방식으로 저장되는 것을 의미(refer to)할 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 확장된 데이터를 획득하기 위해 정적 메모리 내에 저장된 입력 데이 터에 패딩을 수행하는 단계는, 정적 메모리 내에서, 제1 중간 데이터를 획득하기 위해 입력 데이터에 대응하는 저장 위치의 전후의 엔트리들을 제1 프리셋 값으로 패딩하는 단계, 제1 중간 데이터를 벡터 계산 유닛에게 전송 하고, 제2 중간 데이터를 획득하기 위해 벡터 계산 유닛으로부터의 쉬프트 명령어 및 패딩 명령어을 사용하여 제1 중간 데이터에 대응하는 각각의 행의 두 엔드들을 제2 프리셋 값으로 패딩하는 단계 및 확장된 데이터를 획 득하기 위해 제2 중간 데이터를 정적 메모리 내의 해당하는 저장 위치로 전송하는 단계를 포함하고, 제1 중간 데이터는 입력 데이터 및 패딩된 제1 프리셋 값을 포함하고, 제2 중간 데이터는 제1 중간 데이터 및 패딩된 제2 프리셋 값을 포함하고, 확장된 데이터는 제2 중간 데이터와 내용(content)이 동일할 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 데이터는 [1, ht, wt, (CХRХS)]로 표현되고, ht 및 wt는 0보 다 큰 정수이고, 타겟 데이터를 획득하기 위해 확장된 데이터의 채널들의 수 및 크기를 변화시키도록 확장된 데 이터의 레이아웃을 조절하는 단계는 정적 메모리 내의 R*N개 엔트리들 내의 데이터를 연속적으로 읽고 벡터 계 산 유닛에게 전송하는 단계; 및 타겟 데이터를 획득하기 위해, 벡터 계산 유닛에 의해, 매번 수신되는 R*N개 엔 트리들 내의 데이터를 wt*ceil((CХRХS)/L)개 엔트리들의 데이터로 변환(convert)하는 단계를 포함하고, 각각 의 읽기의 시작 주소(start address)는 프리셋 스트라이드(preset stride) str에 따라 str*N개 엔트리들만큼 쉬프트(shift)되고, 프리셋 스트라이드는 입력 데이터 및 초기 컨볼루션 커널에 행 방향 및 열 방향으로 컨볼루 션 연산을 수행하기 위해 요구되는 특징 윈도우의 스트라이드이고, 정적 메모리로부터의 데이터의 읽기의 총 수 는 ht와 같고, L은 정적 메모리 내의 각각의 엔트리에 의해 저장가능한 데이터 포인트들의 수를 나타내고, ceil((CХRХS)/L)은 (CХRХS)/L를 정수로 올림하는 것을 나타내며, 변환된 데이터는 타겟 데이터일 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 데이터를 획득하기 위해, 벡터 계산 유닛에 의해, 매번 수신되 는 R*N개 엔트리들 내의 데이터를 wt*ceil((CХRХS)/L)개 엔트리들의 데이터로 변환하는 단계는 프리셋 스트라 이드에 따라 R*N개 엔트리들 내의 데이터를 복수의 데이터의 세트들로 나누는 단계, 각각의 데이터의 세트에 대 해, 데이터의 세트에 해당하는 특징 윈도우의 데이터의 각각의 행의 타겟 위치 정보 파라미터 및 초기 위치 정 보 파라미터를 결정하는 단계 및 타겟 데이터를 획득하기 위해, 초기 위치 정보 파라미터 및 타겟 위치 정보 파 라미터에 기초하여, 벡터 계산 유닛에 의해, 각각의 데이터의 세트를 타겟 메모리의 해당하는 위치 내에 변환된 레이아웃으로 저장하는 단계를 포함하고, 각각의 데이터의 세트는 행 방향의 하나의 특징 윈도우에 대응하고, 복수의 데이터의 세트들의 수는 wt와 같고, 타겟 메모리는 행 단위들로의 저장을 허용하고, 타겟 메모리에게 전 송되고 타겟 메모리에 저장되는 데이터는 타겟 데이터일 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 초기 위치 정보 파라미터는 제1 시작 경계 좌표, 제1 엔드 경계 좌 표, 제1 시작 주소, 제1 엔드 주소, 제1 시작 일련번호, 및 제1 엔드 일련번호를 포함하고, 제1 시작 경계 좌표 는 확장된 데이터의 행 방향에서 해당하는 특징 윈도우의 시작 경계의 상대적인 좌표를 나타내고, 제1 엔드 경계 좌표는 확장된 데이터의 행 방향에서 해당하는 특징 윈도우의 엔드 경계의 상대적인 좌표를 나타내고, 해당 하는 특징 윈도우의 시작 경계 및 해당하는 특징 윈도우의 엔드 경계는 확장된 데이터의 행 방향에서 상이한 위 치들에 위치되고, 제1 시작 주소는 벡터 계산 유닛의 메모리 내의 제1 시작 경계 좌표의 주소를 나타내고, 제1 엔드 주소는 벡터 계산 유닛의 메모리 내의 제1 엔드 경계 좌표의 주소를 나타내고, 제1 시작 일련번호는 제1 시작 주소에서의 제1 시작 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타내고, 제1 엔드 일련번호는 제1 엔드 경계 주소에서의 제1 엔드 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타낼 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 제1 시작 경계 좌표에 대한 계산 식(calculation formula)은 src_row_start_index = i * str * ch이고, rc_row_start_index는 제1 시작 경계 좌표를 나타내고, i는 타겟 데 이터의 크기 wt 내에서 해당하는 특징 윈도우의 해당하는 데이터 포인트의 일련번호를 나타내고, str은 행 방향 내의 특징 윈도우의 스트라이드를 나타내고, ch는 입력 데이터의 채널들의 수를 나타내고, 제1 엔드 경계 좌표 에 대한 계산 식은 src_row_end_index = src_row_start_index + (kernel_w * ch - 1)이고, src_row_end_index 는 제1 엔드 경계 좌표를 나타내고, kernel_w는 특징 윈도우의 폭을 나타내고, 특징 윈도우의 크기는 초기 컨볼 루션 커널의 크기와 같고, 제1 시작 주소에 대한 계산 식은 src_row_start_address = src_row_start_index / vmem_lane + j * N이고, src_row_start_address는 제1 시작 주소를 나타내고, vmem_lane은 벡터 계산 유닛의 메모리 내의 각각의 엔트리에 의해 저장가능한 데이터 포인트들의 수를 나타내고, j는 특징 윈도우 내의 해당하 는 데이터의 행 일련번호를 나타내고, 제1 엔드 주소에 대한 계산 식은 src_row_end_address = src_row_end_index / vmem_lane + j * N이고, src_row_end_address는 제1 엔드 주소를 나타내고, 제1 시작 일 련번호에 대한 계산 식은 src_row_start_lane = src_row_start_index % vmem_lane이고, src_row_start_lane은 제1 시작 일련번호를 나타내고, %는 모듈로 연산을 나타내고, 제1 엔드 일련번호에 대한 계산 식은 src_row_end_lane = src_row_end_index % vmem_lane이고, src_row_end_lane은 제1 엔드 일련번호를 나타낼 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 위치 정보 파라미터는 제2 시작 경계 좌표(a second start boundary coordinate), 제2 엔드 경계 좌표(a second end boundary coordinate), 제2 시작 주소(a second start address), 제2 엔드 주소(a second end address), 제2 시작 일련번호(a second start serial number), 및 제2 엔드 일련번호(a second end serial number)를 포함하고, 제2 시작 경계 좌표는 [1, 1, (CХRХS)]의 데이터 크기 내에서 내에서 해당하는 특징 윈도우의 시작 경계의 상대적인 좌표를 나타내고, 제2 엔드 경계 좌 표는 [1, 1, (CХRХS)]의 데이터 크기 내에서 내에서 해당하는 특징 윈도우의 엔드 경계의 상대적인 좌표를 나 타내고, 해당하는 특징 윈도우의 시작 경계 및 해당하는 특징 윈도우의 엔드 경계는 확장된 데이터의 행 방향에 서 상이한 위치들에 위치되고, 제2 시작 주소는 벡터 계산 유닛의 메모리 내의 제2 시작 경계 좌표의 주소를 나 타내고, 제2 엔드 주소는 벡터 계산 유닛의 메모리 내의 제2 엔드 경계 좌표의 주소를 나타내고, 제2 시작 일련 번호는 제2 시작 주소에서의 제2 시작 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타내고, 제2 엔드 일련번호는 제2 엔드 경계 주소에서의 제2 엔드 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타낼 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 제2 시작 경계 좌표에 대한 계산 식은 dst_row_start_index＝ j*kernel_w*ch 이고, dst_row_start_index는 제2 시작 경계 좌표를 나타내고, j는 특징 윈도우 내의 해당하는 데이터의 행 일련번호를 나타내고, kernel_w는 특징 윈도우의 폭을 나타내고, 상티 특징 윈도우의 크기는 초기 컨볼루션 커널의 크기와 같고, ch는 입력 데이터의 채널들의 수를 나타내고, 제2 엔드 경계 좌표에 대한 계산 식은 dst_row_end_index = dst_row_start_index + (kernel_w * ch - 1)이고, dst_row_end_index는 제2 엔드 경계 좌표를 나타내고, 제2 시작 주소에 대한 계산 식은 dst_row_start_address = dst_row_start_index / vmem_lane이고, dst_row_start_address는 제2 시작 주소를 나타내고, vmem_lane은 벡터 계산 유닛의 메모리 내 의 각각의 엔트리에 의해 저장가능한 데이터 포인트들의 수를 나타내고, 제2 엔드 주소에 대한 계산 식은 dst_row_end_address = dst_row_end_index / vmem_lane이고, dst_row_end_address는 제2 엔드 주소를 나타내고, 제2 시작 일련번호에 대한 계산 식은 dst_row_start_lane = dst_row_start_index % vmem_lane이고, dst_row_start_lane은 제2 시작 일련번호를 나타내고, %는 모듈로 연산을 나타내고, 제2 엔드 일련번호에 대한 계산 식은 dst_row_end_lane = dst_row_end_index % vmem_lane이고, dst_row_end_lane은 제2 엔드 일련번호를 나타낼 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 데이터를 획득하기 위해, 초기 위치 정보 파라미터 및 타겟 위 치 정보 파라미터에 기초하여, 벡터 계산 유닛에 의해, 각각의 데이터의 세트를 타겟 메모리의 해당하는 위치 내에 변환된 레이아웃으로 저장하는 단계는, 타겟 데이터를 획득하기 위해, 초기 위치 정보 파라미터 및 타겟위치 정보 파라미터에 기초하여, 벡터 프레디케이트 레지스터 내의 프리셋 활성화 신호에 따라서 및 순환 쉬프 트 명령어를 사용하여 벡터 계산 유닛에 의해, 각각의 데이터의 세트를 변환된 레이아웃으로 스플라이싱하고 데 이터를 타겟 메모리의 해당하는 위치 내에 저장하는 단계를 포함할 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 데이터 및 연산 컨볼루션 커널에 기초하여 컨볼루션 연산을 수 행하는 단계는, 행렬 연산 유닛에 의해, 타겟 데이터 및 연산 컨볼루션 커널에 컨볼루션 연산을 수행하는 단계 를 포함할 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 컨볼루션 연산 방법은, 컨볼루션 뉴럴 네트워크의 첫번째-레이어 컨 볼루션 연산에 적용될 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 컨볼루션 연산 장치는, 연산 컨볼루션 커널을 결정하도록 구성된 결 정 유닛, 타겟 데이터를 획득하기 위해 연산 컨볼루션 커널의 채널들의 수에 기초하여 입력 데이터의 레이아웃 을 조절하도록 구성된 조절 유닛 및 컨볼루션 연산 결과를 획득하기 위해 타겟 데이터 및 연산 컨볼루션 커널에 기초하여 컨볼루션 연산을 수행하도록 구성된 계산 유닛을 포함하고, 연산 컨볼루션 커널은 초기 컨볼루션 커널 에 기초하여 획득되고, 초기 컨볼루션 커널은 [R, S, C, K]로 표현되고, 연산 컨볼루션 커널은 [1, 1, (CХRХ S), K]로 표현되고, R, S, C 및 K는 0보다 큰 정수이고, 타겟 데이터의 채널들의 수 및 크기는 입력 데이터의 채널들의 수 및 크기와 다르고, 타겟 데이터의 채널들의 수는 연산 컨볼루션 커널의 채널들의 수와 같고, 타겟 데이터 및 연산 컨볼루션 커널의 컨볼루션 연산 결과는 입력 데이터 및 초기 컨볼루션 커널의 컨볼루션 연산 결 과와 같을 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 데이터의 채널들의 수는 입력 데이터의 채널들의 수보다 크고, 연산 컨볼루션 커널의 채널들의 수는 초기 컨볼루션 커널의 채널들의 수보다 클 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 조절 유닛은 제1 조절 서브 유닛(first adjustment sub-unit), 제2 조절 서브 유닛(second adjustment sub-unit) 및 제3 조절 서브 유닛(third adjustment sub-unit)을 포함할 수 있다. 제1 조절 서브 유닛은 입력 데이터를 행 단위들(units of a row)로 정적 메모리(static memory) 내에 저장(store)하도록 구성되고, 입력 데이터의 각각의 행은 정적 메모리 내의 해당하는 N개 엔트리(entry)들에 내 에 저장되고, N은 0보다 큰 정수일 수 있다. 제2 조절 서브 유닛은 확장된 데이터(extended data)를 획득하기 위해 정적 메모리에 저장된 입력 데이터에 패딩(padding)을 수행하도록 구성될 수 있다. 제3 조절 서브 유닛은 타겟 데이터를 획득하기 위해 확장된 데이터의 채널들의 수 및 크기를 변화시키도록 확장된 데이터의 레이아웃 을 조절하도록 구성될 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 제1 조절 서브 유닛은 제1 저장 유닛(first storage unit) 및 제2 저장 유닛(second storage unit)을 포함할 수 있다. 제1 저장 유닛은 입력 데이터를 밀집 레이아웃으로 메모리 내에 저장하도록 구성되고, 입력 데이터는 복수의 채널들을 포함하고, 밀집 레이아웃은 같은 데이터 포인트의 복수의 채널들이 메모리 내에 순차적이고 근접 방식으로 저장되는 것을 의미할 수 있다. 제2 저장 유닛은 메모 리 내의 입력 데이터를 직접 메모리 접근 방식으로 하드웨어 가속기의 정적 메모리에게 전송하고, 입력 데이터 의 각각의 행이 정적 메모리 내의 해당하는 N개 엔트리들 내에 저장되도록 입력 데이터의 행들의 제1 데이터 포 인트들을 정적 메모리의 상이한 행들의 제1 열들 내에 저장하도록 구성될 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 제2 조절 서브 유닛은 제1 패딩 유닛(first padding unit), 제2 패 딩 유닛(second padding unit), 및 제3 패딩 유닛(third padding unit)을 포함할 수 있다. 제1 패딩 유닛은 정적 메모리 내에서, 제1 중간 데이터를 획득하기 위해 입력 데이터에 대응하는 저장 위치의 전후의 엔트리들을 제1 프리셋 값으로 패딩하도록 구성될 수 있다. 제2 패딩 유닛은 제1 중간 데이터를 벡터 계산 유닛에게 전송 하고, 제2 중간 데이터를 획득하기 위해 벡터 계산 유닛으로부터의 쉬프트 명령어 및 패딩 명령어를 사용하여 제1 중간 데이터에 대응하는 각각의 행의 두 엔드들(two ends)을 제2 프리셋 값(second preset value)으로 패딩 하도록 구성될 수 있다. 제3 패딩 유닛은 확장된 데이터를 획득하기 위해 제2 중간 데이터를 정적 메모리 내의 해당하는 저장 위치로 전송하도록 구성되고, 확장된 데이터는 제2 중간 데이터와 내용(content)이 동일할 수 있 다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 데이터는 [1, ht, wt, (CХRХS)]로 표현되고, ht 및 wt는 0보 다 큰 정수일 수 있다. 제3 조절 서브 유닛은 제1 변경 유닛(first changing unit) 및 제2 변경 유닛(second changing unit)을 포함할 수 있다. 제1 변경 유닛은, 정적 메모리 내의 R*N개 엔트리들 내의 데이터를 연속적 으로 읽고 벡터 계산 유닛에게 전송하도록 구성되고, 각각의 읽기의 시작 주소는 프리셋 스트라이드 str에 따라str*N개 엔트리들만큼 쉬프트되고, 프리셋 스트라이드는 입력 데이터 및 초기 컨볼루션 커널에 행 방향 및 열 방향으로 컨볼루션 연산을 수행하기 위해 요구되는 특징 윈도우의 스트라이드이고, 정적 메모리로부터의 데이터 의 읽기의 총 수는 ht와 같을 수 있다. 제2 변경 유닛은, 타겟 데이터를 획득하기 위해, 벡터 계산 유닛에 의 해, 매번 수신되는 R*N개 엔트리들 내의 데이터를 wt*ceil((CХRХS)/L)개 엔트리들의 데이터로 변환하도록 구 성되고, L은 정적 메모리 내의 각각의 엔트리에 의해 저장가능한 데이터 포인트들의 수를 나타내고, ceil((CХR ХS)/L)은 (CХRХS)/L를 정수로 올림하는 것을 나타내며, 변환된 데이터는 타겟 데이터일 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 제2 변경 유닛은 그룹화 유닛(grouping unit), 파라미터 결정 유닛 (parameter determination unit) 및 벡터 계산 유닛(vector calculation unit)을 포함할 수 있다. 그룹화 유 닛은, 프리셋 스트라이드에 따라 R*N개 엔트리들 내의 데이터를 복수의 데이터의 세트들로 나누도록 구성되고, 각각의 데이터의 세트는 행 방향의 하나의 특징 윈도우에 대응하고, 복수의 데이터의 세트들의 수는 wt와 같을 수 있다. 파라미터 결정 유닛은, 각각의 데이터의 세트에 대해, 데이터의 세트에 해당하는 특징 윈도우의 데이 터의 각각의 행의 타겟 위치 정보 파라미터 및 초기 위치 정보 파라미터를 결정하도록 구성될 수 있다. 벡터 계산 유닛은 타겟 데이터를 획득하기 위해, 초기 위치 정보 파라미터 및 타겟 위치 정보 파라미터에 기초하여, 벡터 계산 유닛에 의해, 각각의 데이터의 세트를 타겟 메모리의 해당하는 위치 내에 변환된 레이아웃으로 저장 하도록 구성되고, 타겟 메모리는 행 단위들로의 저장을 허용하고, 타겟 메모리에게 전송되고 타겟 메모리에 저 장되는 데이터는 타겟 데이터일 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 초기 위치 정보 파라미터는 제1 시작 경계 좌표, 제1 엔드 경계 좌 표, 제1 시작 주소, 제1 엔드 주소, 제1 시작 일련번호, 및 제1 엔드 일련번호를 포함하고, 제1 시작 경계 좌표 는 확장된 데이터의 행 방향에서 해당하는 특징 윈도우의 시작 경계의 상대적인 좌표를 나타내고, 제1 엔드 경 계 좌표는 확장된 데이터의 행 방향에서 해당하는 특징 윈도우의 엔드 경계의 상대적인 좌표를 나타내고, 해당 하는 특징 윈도우의 시작 경계 및 해당하는 특징 윈도우의 엔드 경계는 확장된 데이터의 행 방향에서 상이한 위 치들에 위치되고, 제1 시작 주소는 벡터 계산 유닛의 메모리 내의 제1 시작 경계 좌표의 주소를 나타내고, 제1 엔드 주소는 벡터 계산 유닛의 메모리 내의 제1 엔드 경계 좌표의 주소를 나타내고, 제1 시작 일련번호는 제1 시작 주소에서의 제1 시작 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타내고, 제1 엔드 일련번호는 제1 엔드 경계 주소에서의 제1 엔드 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타낼 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 제1 시작 경계 좌표에 대한 계산 식은 src_row_start_index = i * str * ch이고, rc_row_start_index는 제1 시작 경계 좌표를 나타내고, i는 타겟 데이터의 크기 wt 내에서 해당 하는 특징 윈도우의 해당하는 데이터 포인트의 일련번호를 나타내고, str은 행 방향 내의 특징 윈도우의 스트라 이드를 나타내고, ch는 입력 데이터의 채널들의 수를 나타내고, 제1 엔드 경계 좌표에 대한 계산 식은 src_row_end_index = src_row_start_index + (kernel_w * ch - 1)이고, src_row_end_index는 제1 엔드 경계 좌표를 나타내고, kernel_w는 특징 윈도우의 폭을 나타내고, 특징 윈도우의 크기는 초기 컨볼루션 커널의 크기 와 같고, 제1 시작 주소에 대한 계산 식은 src_row_start_address = src_row_start_index / vmem_lane + j * N 이고, src_row_start_address는 제1 시작 주소를 나타내고, vmem_lane은 벡터 계산 유닛의 메모리 내의 각각의 엔트리에 의해 저장가능한 데이터 포인트들의 수를 나타내고, j는 특징 윈도우 내의 해당하는 데이터의 행 일련 번호를 나타내고, 제1 엔드 주소에 대한 계산 식은 src_row_end_address = src_row_end_index / vmem_lane + j * N이고, src_row_end_address는 제1 엔드 주소를 나타내고, 제1 시작 일련번호에 대한 계산 식은 src_row_start_lane = src_row_start_index % vmem_lane이고, src_row_start_lane은 제1 시작 일련번호를 나타 내고, %는 모듈로 연산을 나타내고, 제1 엔드 일련번호에 대한 계산 식은 src_row_end_lane = src_row_end_index % vmem_lane이고, src_row_end_lane은 제1 엔드 일련번호를 나타낼 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 타겟 위치 정보 파라미터는 제2 시작 경계 좌표(a second start boundary coordinate), 제2 엔드 경계 좌표(a second end boundary coordinate), 제2 시작 주소(a second start address), 제2 엔드 주소(a second end address), 제2 시작 일련번호(a second start serial number), 및 제2 엔드 일련번호(a second end serial number)를 포함하고, 제2 시작 경계 좌표는 [1, 1, (CХRХS)]의 데이터 크기 내에서 내에서 해당하는 특징 윈도우의 시작 경계의 상대적인 좌표를 나타내고, 제2 엔드 경계 좌 표는 [1, 1, (CХRХS)]의 데이터 크기 내에서 내에서 해당하는 특징 윈도우의 엔드 경계의 상대적인 좌표를 나 타내고, 해당하는 특징 윈도우의 시작 경계 및 해당하는 특징 윈도우의 엔드 경계는 확장된 데이터의 행 방향에 서 상이한 위치들에 위치되고, 제2 시작 주소는 벡터 계산 유닛의 메모리 내의 제2 시작 경계 좌표의 주소를 나 타내고, 제2 엔드 주소는 벡터 계산 유닛의 메모리 내의 제2 엔드 경계 좌표의 주소를 나타내고, 제2 시작 일련 번호는 제2 시작 주소에서의 제2 시작 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타내고, 제2 엔드일련번호는 제2 엔드 경계 주소에서의 제2 엔드 경계 좌표에 대응하는 데이터 포인트의 일련번호를 나타낼 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 제2 시작 경계 좌표에 대한 계산 식은 dst_row_start_index＝ j*kernel_w*ch 이고, dst_row_start_index는 제2 시작 경계 좌표를 나타내고, j는 특징 윈도우 내의 해당하는 데이터의 행 일련번호를 나타내고, kernel_w는 특징 윈도우의 폭을 나타내고, 상티 특징 윈도우의 크기는 초기 컨볼루션 커널의 크기와 같고, ch는 입력 데이터의 채널들의 수를 나타내고, 제2 엔드 경계 좌표에 대한 계산 식은 dst_row_end_index = dst_row_start_index + (kernel_w * ch - 1)이고, dst_row_end_index는 제2 엔드 경계 좌표를 나타내고, 제2 시작 주소에 대한 계산 식은 dst_row_start_address = dst_row_start_index / vmem_lane이고, dst_row_start_address는 제2 시작 주소를 나타내고, vmem_lane은 벡터 계산 유닛의 메모리 내 의 각각의 엔트리에 의해 저장가능한 데이터 포인트들의 수를 나타내고, 제2 엔드 주소에 대한 계산 식은 dst_row_end_address = dst_row_end_index / vmem_lane이고, dst_row_end_address는 제2 엔드 주소를 나타내고, 제2 시작 일련번호에 대한 계산 식은 dst_row_start_lane = dst_row_start_index % vmem_lane이고, dst_row_start_lane은 제2 시작 일련번호를 나타내고, %는 모듈로 연산을 나타내고, 제2 엔드 일련번호에 대한 계산 식은 dst_row_end_lane = dst_row_end_index % vmem_lane이고, dst_row_end_lane은 제2 엔드 일련번호를 나타낼 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 벡터 계산 유닛은 타겟 데이터를 획득하기 위해, 초기 위치 정보 파 라미터 및 타겟 위치 정보 파라미터에 기초하여, 벡터 프레디케이트 레지스터 내의 프리셋 활성화 신호에 따라 서 및 순환 쉬프트 명령어를 사용하여 벡터 계산 유닛에 의해, 각각의 데이터의 세트를 변환된 레이아웃으로 스 플라이싱하고 데이터를 타겟 메모리의 해당하는 위치 내에 저장하도록 더 구성될 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 계산 유닛은 행렬 연산 유닛을 이용하여, 타겟 데이터 및 연산 컨볼 루션 커널에 컨볼루션 연산을 수행하도록 구성되는 계산 서브 유닛을 포함할 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 컨볼루션 연산 장치는, 컨볼루션 뉴럴 네트워크의 첫번째-레이어 컨 볼루션 연산에 적용될 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 전자 디바이스는 본 개시의 임의의 실시예에 따라 제공되는 컨볼루 션 연산 장치를 포함할 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 전자 디바이스는, 프로세서 및 적어도 하나의 컴퓨터 프로그램 모듈 을 포함하는 메모리를 포함하고, 적어도 하나의 컴퓨터 프로그램 모듈은 프로세서에 의해 실행되도록 구성되고 메모리에 저장되고, 적어도 하나의 컴퓨터 프로그램 모듈은 본 개시의 어느 한 실시예의 컨볼루션 연산 방법을 구현하도록 구성될 수 있다. 본 개시의 하나 이상의 실시예들에 따르면, 컴퓨터에 의해 실행되었을 때, 컴퓨터로 하여금 본 개시의 어느 한 실시예의 컨볼루션 연산 방법을 구현하도록 하는 비-일시적 컴퓨터-판독가능 명령어들을 저장하는, 저장 매체가 제공될 수 있다. 상기 설명은 단지 본 개시의 바람직한 실시예들 및 적용된 기술적 원리들의 설명들에 해당한다. 기술 분야에서 통상의 지식을 가진 자들은, 본 개시에 포함된 개시의 범위가 상기 언급된 기술적 특징들의 특정한 조합들에 의 해 형성된 기술 솔루션들에 제한되지 않는다는 것을 이해해야 한다. 대신, 이는 본 개시의 개념에서 벗어나지 않고 이러한 기술적 특징들 또는 그들과 동등한 특징들의 임의의 조합에 의해 형성된 다른 기술 솔루션들을 더 포함한다. 예를 들어, 상기 언급된 기술적 특징들을 본 개시에서 개시되는 기술적 특징들과 유사한 기능을 가 진(단, 이에 국한되지 않는) 기술적 특징들로 상호 치환(mutual substitution)하여 형성된 기술적 해결책이 포 함될 수 있다. 또한, 도면에서 특정 순서로 작업들이 묘사되었더라도, 이러한 작업들이 반드시 도면에 나타난 특정 순서대로 또는 순차적으로 수행되어야 함을 요구하는 것으로 이해되어서는 안 된다. 특정 맥락들(contexts)에서는, 멀티 태스킹(multitasking)이나 병렬 처리(parallel processing)가 유리할 수 있다. 마찬가지로, 위의 논의에서 여 러 구체적인 세부사항들이 포함되어 있지만, 이는 본 개시의 범위를 제한하는 것으로 해석되어서는 안 된다. 별도의 실시예들에 대한 맥락에서 설명된 특징들은 하나의 실시예에서 조합으로 구현될 수 있다. 반대로, 하나 의 실시예에 대한 맥락에서 설명된 다양한 특징들은 별도의 다수 실시예들로 각각 구현되거나 임의의 적절한 하 위 조합(sub-combination)으로 구현될 수도 있다. 주제가 구조적 특징들 및/또는 방법론적 동작들로 특정되는 언어로 묘사되었으나, 첨부된 청구항들에서 정의되 는 주제들은 반드시 상기 설명된 특정한 특징들 또는 동작들로 제한되지 않음이 이해되어야 한다. 오히려 특정 한 특징들 또는 동작들은 오직 청구항들을 구현하는 예들로서 제공된다. 본 개시와 관련하여, 다음과 같은 사항들은 추가적인 설명이 필요하다: 본 개시의 실시예들의 도면들은 본 개시의 실시예들과 관련되는 구조들만을 포함하며, 기타 구조들은 종래 의 설계들을 참조할 수 있다. 충돌이 없는 경우, 본 개시의 실시예들 및 그 실시예에 포함된 특징들은 새로운 실시예들을 얻기 위해 서로 결합될 수 있다. 상기 설명은 단지 본 개시의 실시예들을 제공하기 위한 것일 뿐, 본 개시의 보호 범위가 이에 한정되는 것은 아 니고, 본 개시의 보호 범위는 청구항들의 보호 범위에 따라야 한다."}
{"patent_id": "10-2024-7039930", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시의 실시예들의 기술적 해결책을 도시하기 더 명확하게 도시하기 위해, 실시예들의 첨부 도면들의 간단한 소개가 아래 주어질 것이다. 분명하게, 아래 설명되는 첨부 도면들은 본 개시의 일부 실시예들에 관한 것일 뿐 이고, 본 개시를 제한하도록 의도되지 않는다. 도 1은 본 개시의 일부 실시예들에 의해 제공되는 컨볼루션 연산의 데이터 흐름(data flow)의 개략적인 도면이 다; 도 2는 본 개시의 일부 실시예들에 의해 제공되는 컨볼루션 연산 방법의 흐름도이다; 도 3은 컨볼루션 연산의 개략적인 도면이다;도 4는 도 2 내의 단계(S20)의 개략적인 흐름도이다; 도 5는 도 4 내의 단계(S21)의 흐름도이다; 도 6은 본 개시의 일부 실시예들에 의해 제공되는 컨볼루션 연산 방법 내의 메모리 내의 입력 데이터의 저장 방 식의 개략적인 도면이다; 도 7은 본 개시의 일부 실시예들에 의해 제공되는 컨볼루션 연산 방법 내의 정적 메모리(static memory) 내의 입력 데이터의 저장 방식의 개략적인 도면이다; 도 8은 도 4 내의 단계(S22)의 개략적인 흐름도이다; 도 9는 도 4 내의 단계(S23)의 개략적인 흐름도이다; 도 10은 도 9 내의 단계(S232)의 개략적인 흐름도이다; 도 11은 본 개시의 일부 실시예들에 의해 제공되는 컨볼루션 연산 방법 내의 데이터 레이아웃을 변화(vary)시키 는 것의 개략적인 도면 I이다; 도 12는 본 개시의 일부 실시예들에 의해 제공되는 컨볼루션 연산 방법 내의 데이터 레이아웃을 변화시키는 것 의 개략적인 도면 II이다; 도 13은 본 개시의 일부 실시예들에 의해 제공되는 컨볼루션 연산 장치의 개략적인 블록도이다; 도 14는 본 개시의 일부 실시예들에 의해 제공되는 전자 디바이스의 개략적인 블록도이다; 도 15는 본 개시의 일부 실시예들에 의해 제공되는 또다른 전자 디바이스의 개략적인 블록도이다; 도 16은 본 개시의 일부 실시예들에 의해 제공되는 또다른 전자 디바이스의 개략적인 블록도이다; 및 도 17은 본 개시의 일부 실시예들에 의해 제공되는 저장 매체의 개략적인 블록도이다."}
