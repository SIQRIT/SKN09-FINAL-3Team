{"patent_id": "10-2021-7043160", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0051031", "출원번호": "10-2021-7043160", "발명의 명칭": "의미론적 인공 지능을 사용한 소스 화면 또는 소스 데이터와 타겟 화면 간의 의미론적 매칭", "출원인": "유아이패스, 인크.", "발명자": "마이어 크리스천"}}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨터 프로그램을 저장하는 비-일시적 컴퓨터-판독 가능 매체로서, 상기 컴퓨터 프로그램은 적어도 하나의 프로세서로 하여금, 소스 화면 또는 소스 데이터의 선택을 수신하고;타겟 화면의 선택을 수신하고;상기 소스 화면의 레이블들과 상기 타겟 화면의 레이블들 사이에서, 상기 소스 데이터의 데이터 요소들과 상기타겟 화면의 레이블들 사이에서 또는 둘 모두에서 의미론적 매칭을 수행하도록 트레이닝된 하나 이상의 인공 지능/기계 학습(AI/ML) 모델들을 호출하고;상기 하나 이상의 AI/ML 모델들로부터 상기 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들의 표시들 및 개개의 신뢰도 점수들을 수신하고; 그리고매칭 인터페이스에서 상기 타겟 화면 상에 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들을 디스플레이하게 하도록 구성되는 것인, 비-일시적 컴퓨터-판독 가능 매체."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 컴퓨터 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금, 상기 매칭 인터페이스에서 상기 하나 이상의 AI/ML 모델들에 의해 식별된 잠재적 매칭 그래픽 요소들에 대한 개개의 신뢰도 점수들을 디스플레이하게 하도록 구성되는 것인, 비-일시적 컴퓨터-판독 가능 매체."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서, 상기 컴퓨터 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금, 연관된 의미론적으로 매칭되는 레이블을 갖는 것으로서 상기 하나 이상의 AI/ML 모델들에 의해 식별된 상기 타겟 화면의 그래픽 요소에 대한 정정을 수신하고, 상기 하나 이상의 AI/ML 모델들에 의해 상기 소스 화면의 레이블과 의미론적으로 매칭되지 않는 상기 타겟 화면의 새로운 요소의 표시를 수신하거나, 또는 둘 모두를 행하고;상기 타겟 화면의 수정된 그리고/또는 새롭게 레이블링된 그래픽 요소 및 상기 연관된 레이블에 관한 정보를 수집하고; 그리고상기 하나 이상의 AI/ML 모델들의 재트레이닝을 위해 상기 수집된 정보를 직접 또는 간접적으로 저장하게 하도록 구성되는 것인, 비-일시적 컴퓨터-판독 가능 매체."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 컴퓨터 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금, 상기 하나 이상의 AI/ML 모델들이 상기 타겟 화면의 필드들과 의미론적으로 매칭되는 것으로서 식별한 레이블들을 갖는 상기 소스 화면의 필드들로부터의 데이터를 카피하고, 상기 소스 데이터로부터의 데이터 요소들을, 상기 하나 이상의 AI/ML 모델들이 상기 소스 데이터로부터의 데이터 요소들과 의미론적으로 매칭되는 것으로서 식별한 레이블들을 갖는 상기 타겟 화면의 필드들 내로 카피하거나, 또는 둘 모두를 행하는 RPA(robotic processautomation) 워크플로우의 하나 이상의 활동들을 생성하게 하도록 구성되는 것인, 비-일시적 컴퓨터-판독 가능공개특허 10-2023-0051031-3-매체."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4 항에 있어서,상기 컴퓨터 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금, 상기 RPA 워크플로우에서 하나 이상의 생성된 활동들을 구현하는 RPA 로봇을 생성하고; 그리고런타임 환경(runtime environment)에서 생성된 RPA 로봇을 전개하게 하도록 구성되는 것인, 비-일시적 컴퓨터-판독 가능 매체."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1 항에 있어서,상기 컴퓨터 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금, 상기 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들에 대한 신뢰도 점수들로부터 합성신뢰도 점수를 생성하고; 그리고상기 매칭 인터페이스에서 상기 합성 신뢰도 점수를 디스플레이하게 하도록 구성되는 것인, 비-일시적 컴퓨터-판독 가능 매체."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서,상기 하나 이상의 AI/ML 모델들은, 주어진 단어 또는 구문에 대한 유사 단어들 및 구문들이 식별될 수 있도록단어들과 구문들 사이의 의미론적 연관들을 갖는 상기 단어들 및 상기 구문들을 제공하고 상기 단어들 및 구문들이 나타나는 화면과 관련된 콘텍스트 레이블들을 제공함으로써 트레이닝되는 것인, 비-일시적 컴퓨터-판독 가능 매체."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1 항에 있어서,상기 컴퓨터 프로그램은 RPA(robotic process automation) 디자이너 애플리케이션이거나 이를 포함하는 것인,비-일시적 컴퓨터-판독 가능 매체."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1 항에 있어서, 상기 하나 이상의 AI/ML 모델들은 CV(computer vision) 모델, OCR(optical character recognition) 모델, 레이블 매칭 모델, 및 입력 데이터 매칭 모델을 포함하고,상기 레이블 매칭 모델은 상기 OCR 모델에 의해 검출된 레이블들을 상기 CV 모델에 의해 검출된 필드들과 매칭시키고,상기 입력 데이터 매칭 모델은 상기 레이블 매칭 모델로부터 매칭 레이블들을 수신하고 상기 데이터 소스로부터의 데이터 요소들 또는 상기 소스 화면으로부터의 레이블들과 연관된 필드들로부터의 데이터를 상기 타겟 화면상의 의미론적으로 매칭되는 레이블들과 연관된 필드들과 의미론적으로 매칭시키는 것인, 비-일시적 컴퓨터-판독 가능 매체."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "RPA(robotic process automation)를 위한 의미론적 인공 지능(AI)을 수행하기 위한 컴퓨터-구현 방법으로서,RPA 디자이너 애플리케이션에 의해, 소스 화면의 레이블들과 타겟 화면의 레이블들 사이에서, 소스 데이터의 데이터 요소들과 상기 타겟 화면의 레이블들 사이에서 또는 둘 모두에서 의미론적 매칭을 수행하도록 트레이닝된하나 이상의 인공 지능/기계 학습(AI/ML) 모델들을 호출하는 단계;공개특허 10-2023-0051031-4-상기 RPA 디자이너 애플리케이션에 의해, 상기 하나 이상의 AI/ML 모델들로부터 상기 타겟 화면의 의미론적으로매칭되는 레이블들과 연관된 그래픽 요소들의 표시들 및 개개의 신뢰도 점수들을 수신하는 단계;상기 RPA 디자이너 애플리케이션에 의해, 매칭 인터페이스에서 상기 타겟 화면 상에 상기 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들을 디스플레이하는 단계; 및상기 RPA 디자이너 애플리케이션에 의해, 상기 소스 화면의 필드들 또는 상기 소스 데이터의 데이터 요소들로부터의 데이터를, 상기 하나 이상의 AI/ML 모델들이 상기 소스 화면으로부터의 레이블들 또는 상기 소스 데이터로부터의 데이터 요소들과 의미론적으로 매칭되는 것으로서 식별한 레이블들을 갖는 상기 타겟 화면의 필드들 내로 카피하는 RPA 워크플로우의 하나 이상의 활동들을 자동으로 생성하는 단계를 포함하는, RPA를 위한 의미론적AI를 수행하기 위한 컴퓨터-구현 방법."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 10 항에 있어서,상기 RPA 디자이너 애플리케이션에 의해, 상기 매칭 인터페이스에서 상기 하나 이상의 AI/ML 모델들에 의해 식별된 잠재적 매칭 그래픽 요소들에 대한 개개의 신뢰도 점수들을 디스플레이하는 단계를 더 포함하는, RPA를 위한 의미론적 AI를 수행하기 위한 컴퓨터-구현 방법."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 10 항에 있어서,상기 RPA 디자이너 애플리케이션에 의해, 연관된 의미론적으로 매칭되는 레이블을 갖는 것으로서 상기 하나 이상의 AI/ML 모델들에 의해 식별된 상기 타겟 화면의 그래픽 요소에 대한 정정을 수신하고, 상기 하나 이상의AI/ML 모델들에 의해 상기 소스 화면의 레이블과 의미론적으로 매칭되지 않는 상기 타겟 화면의 새로운 요소의표시를 수신하거나, 또는 둘 모두를 행하는 단계;상기 RPA 디자이너 애플리케이션에 의해, 상기 타겟 화면의 수정된 그리고/또는 새롭게 레이블링된 그래픽 요소및 상기 연관된 레이블에 관한 정보를 수집하는 단계; 및상기 RPA 디자이너 애플리케이션에 의해, 상기 하나 이상의 AI/ML 모델들의 재트레이닝을 위해 상기 수집된 정보를 직접 또는 간접적으로 저장하는 단계를 더 포함하는, RPA를 위한 의미론적 AI를 수행하기 위한 컴퓨터-구현 방법."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 10 항에 있어서, 상기 RPA 디자이너 애플리케이션에 의해, 상기 RPA 워크플로우에서 상기 하나 이상의 자동으로 생성된 활동들을구현하는 RPA 로봇을 생성하는 단계; 및상기 RPA 디자이너 애플리케이션에 의해, 런타임 환경에서 생성된 RPA 로봇을 전개하는 단계를 더 포함하는,RPA를 위한 의미론적 AI를 수행하기 위한 컴퓨터-구현 방법."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 10 항에 있어서, 상기 RPA 디자이너 애플리케이션에 의해, 상기 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽요소들에 대한 개개의 신뢰도 점수들을 디스플레이하는 단계를 더 포함하는, RPA를 위한 의미론적 AI를 수행하기 위한 컴퓨터-구현 방법."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 10 항에 있어서,상기 RPA 디자이너 애플리케이션에 의해, 상기 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽요소들에 대한 신뢰도 점수들로부터 합성 신뢰도 점수를 생성하는 단계; 및공개특허 10-2023-0051031-5-상기 RPA 디자이너 애플리케이션에 의해, 상기 매칭 인터페이스에서 상기 합성 신뢰도 점수를 디스플레이하는단계를 더 포함하는, RPA를 위한 의미론적 AI를 수행하기 위한 컴퓨터-구현 방법."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 10 항에 있어서,상기 하나 이상의 AI/ML 모델들은, 주어진 단어 또는 구문에 대한 유사 단어들 및 구문들이 식별될 수 있도록단어들 및 구문들 사이의 의미론적 연관들을 갖는 상기 단어들 및 상기 구문들을 제공하고 상기 단어들 및 구문들이 나타나는 화면과 관련된 콘텍스트 레이블들을 제공함으로써 트레이닝되는 것인, RPA를 위한 의미론적 AI를수행하기 위한 컴퓨터-구현 방법."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제 10 항에 있어서, 상기 하나 이상의 AI/ML 모델들은 CV(computer vision) 모델, OCR(optical character recognition) 모델, 레이블 매칭 모델, 및 입력 데이터 매칭 모델을 포함하고,상기 레이블 매칭 모델은 상기 OCR 모델에 의해 검출된 레이블들을 상기 CV 모델에 의해 검출된 그래픽 요소들과 매칭시키고,상기 입력 데이터 매칭 모델은 상기 레이블 매칭 모델로부터 매칭 레이블들을 수신하고 상기 소스 데이터로부터의 데이터 요소들 또는 상기 소스 화면으로부터의 레이블들과 연관된 그래픽 요소들로부터의 데이터를 상기 타겟 화면 상의 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들과 의미론적으로 매칭시키는 것인, RPA를위한 의미론적 AI를 수행하기 위한 컴퓨터-구현 방법."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "컴퓨팅 시스템으로서,RPA(robotic process automation)를 위한 의미론적 인공 지능(AI)을 수행하기 위한 컴퓨터 프로그램 명령들을저장하는 메모리; 및상기 컴퓨터 프로그램 명령들을 실행하도록 구성된 적어도 하나의 프로세서를 포함하고, 상기 컴퓨터 프로그램 명령들은 적어도 하나의 프로세서로 하여금, 소스 화면의 레이블들과 타겟 화면의 레이블들 사이에서, 소스 데이터의 데이터 요소들과 상기 타겟 화면의 레이블들 사이에서 또는 둘 모두에서 의미론적 매칭을 수행하도록 트레이닝된 하나 이상의 인공 지능/기계 학습(AI/ML) 모델들로부터 상기 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들의 표시들 및개개의 신뢰도 점수들을 수신하고;매칭 인터페이스에서 상기 타겟 화면 상에 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들을 디스플레이하고;연관된 의미론적으로 매칭되는 레이블을 갖는 것으로서 상기 하나 이상의 AI/ML 모델들에 의해 식별된 상기 타겟 화면의 그래픽 요소에 대한 정정을 수신하고, 상기 하나 이상의 AI/ML 모델들에 의해 상기 소스 화면의 레이블과 의미론적으로 매칭되지 않는 상기 타겟 화면의 새로운 요소의 표시를 수신하거나, 또는 둘 모두를 행하고;상기 타겟 화면의 수정된 그리고/또는 새롭게 레이블링된 그래픽 요소 및 상기 연관된 레이블에 관한 정보를 수집하고; 그리고상기 하나 이상의 AI/ML 모델들의 재트레이닝을 위해 상기 수집된 정보를 직접 또는 간접적으로 저장하게 하도록 구성되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 18 항에 있어서, 상기 컴퓨터 프로그램 명령들은 또한, 상기 적어도 하나의 프로세서로 하여금,공개특허 10-2023-0051031-6-상기 하나 이상의 AI/ML 모델들이 상기 타겟 화면의 필드들과 의미론적으로 매칭되는 것으로서 식별한 레이블들을 갖는 상기 소스 화면의 필드들로부터의 데이터를 카피하고, 상기 소스 데이터로부터의 데이터 요소들을, 상기 하나 이상의 AI/ML 모델들이 상기 소스 데이터로부터의 데이터 요소들과 의미론적으로 매칭되는 것으로서 식별한 레이블들을 갖는 상기 타겟 화면의 필드들 내로 카피하거나, 또는 둘 모두를 행하는 RPA 워크플로우의 하나 이상의 활동들을 자동으로 생성하게 하도록 구성되는, 컴퓨팅 시스템."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제 19 항에 있어서, 상기 컴퓨터 프로그램 명령들은 또한, 상기 적어도 하나의 프로세서로 하여금, 상기 RPA 워크플로우에서 상기 하나 이상의 생성된 활동들을 구현하는 RPA 로봇을 생성하고; 그리고런타임 환경에서 생성된 RPA 로봇을 전개하게 하도록 구성되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제 18 항에 있어서, 상기 컴퓨터 프로그램 명령들은 또한, 상기 적어도 하나의 프로세서로 하여금, 상기 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들에 대한 개개의 신뢰도 점수들을 디스플레이하게 하도록 구성되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제 18 항에 있어서,상기 컴퓨터 프로그램 명령들은 또한, 상기 적어도 하나의 프로세서로 하여금, 상기 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들에 대한 신뢰도 점수들로부터 합성신뢰도 점수를 생성하고; 그리고상기 매칭 인터페이스에서 상기 합성 신뢰도 점수를 디스플레이하게 하도록 구성되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제 18 항에 있어서, 상기 하나 이상의 AI/ML 모델들은, 주어진 단어 또는 구문에 대한 유사 단어들 및 구문들이 식별될 수 있도록단어들 및 구문들 사이의 의미론적 연관들을 갖는 상기 단어들 및 상기 구문들을 제공하고 상기 단어들 및 구문들이 나타나는 화면과 관련된 콘텍스트 레이블들을 제공함으로써 트레이닝되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제 18 항에 있어서, 상기 컴퓨터 프로그램 명령들은 RPA(robotic process automation) 디자이너 애플리케이션이거나 이를 포함하는것인, 컴퓨팅 시스템."}
{"patent_id": "10-2021-7043160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제 18 항에 있어서, 상기 하나 이상의 AI/ML 모델들은 CV(computer vision) 모델, OCR(optical character recognition) 모델, 레이블 매칭 모델, 및 입력 데이터 매칭 모델을 포함하고,상기 레이블 매칭 모델은 상기 OCR 모델에 의해 검출된 레이블들을 상기 CV 모델에 의해 검출된 필드들과 매칭시키고,상기 입력 데이터 매칭 모델은 상기 레이블 매칭 모델로부터 매칭 레이블들을 수신하고 상기 데이터 소스로부터의 데이터 요소들 또는 상기 소스 화면으로부터의 레이블들과 연관된 필드들로부터의 데이터를 상기 타겟 화면공개특허 10-2023-0051031-7-상의 의미론적으로 매칭되는 레이블들과 연관된 필드들과 의미론적으로 매칭시키는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "RPA(robotic process automation) 워크플로우들을 위한 의미론적 인공 지능(AI)을 사용하여 소스 화면 또는 소 스 데이터와 타겟 화면 간의 의미론적 매칭이 개시된다. 소스 데이터 또는 소스 화면 및 타겟 화면은 매칭 인터 페이스 상에서 선택되고, 인공 지능/기계 학습(AI/ML) 모델을 사용하여 소스 데이터/화면과 타겟 화면 간의 의미 론적 매칭이 수행되고, 매칭 그래픽 요소들 및 언매칭 그래픽 요소들은 강조되어, 개발자가 그래픽 요소들 중 어 느 것이 매칭하고 어느 것이 매칭하지 않는지를 알도록 허용한다. 매칭 인터페이스는 또한 개별 매칭들의 신뢰 도 점수를 제공하고, 전체 매핑 점수를 제공하고, 개발자가 매칭/언매칭 그래픽 요소들을 숨기고/숨김 해제하도 록 허용한다. 자동화를 수행하기 위해 실행될 수 있는 의미론적 매칭에 기초하여 RPA 워크플로우의 활동들이 자 동으로 생성될 수 있다."}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "관련 출원에 대한 상호-참조 본 출원은, 2021년 10월 5일에 출원된 미국 정규특허 출원 번호 제17/494,744호를 우선권으로 주장한다. 이로 써, 상기 이전 출원된 출원의 청구 대상은 그 전체가 참고로 포함된다."}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 2, "content": "기술분야 본 발명은 일반적으로 의미론적 매칭(semantic matching)에 관한 것으로서, 보다 구체적으로 RPA(Robotic Process Automation) 워크플로우(workflow)들을 위한 의미론적 인공 지능(AI; artificial intelligence)을 사 용한 소스 화면 또는 소스 데이터와 타겟 화면 간의 의미론적 매칭에 관한 것이다."}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "현재, 개발자들은 활동들을 사용하여 RPA 디자이너 애플리케이션에서 RPA(robotic process automation) 워크플 로우를 수동으로 생성할 필요가 있다. RPA 워크플로우를 생성하는 동안, 개발자는 화면 상에 타겟 그래픽 요소 를 표시할 필요가 있으며, 이는 RPA 디자이너 애플리케이션으로 하여금, 일 세트의 앵커(anchor)들로 타겟 요소 에 대응하는 선택기를 자동으로 생성하게 한다. 활동 추천 및 제안 기능성은 현재 UiPath Studio™에 존재하는 데, 예컨대, 완전히 자동화된 RPA 워크플로우 생성이 지원되지 않는다. RPA 워크플로우를 생성하는 동안 모든 타겟 그래픽 요소들을 수동으로 표시하는 것은 시간 소모적이다. 따라서 RPA 워크플로우 생성에 대한 개선된 접근법이 유익할 수 있다. 본 발명의 특정 실시예들은 현재 RPA 워크플로우 생성 기술들에 의해 아직 완전히 식별되거나, 인식되거나 또는 해결되지 않은 당업계의 문제들 및 요구들에 대한 솔루션들을 제공할 수 있다. 예컨대, 본 발명의 일부 실시예 들은 RPA 워크플로우들을 위한 의미론적 AI를 사용한 소스 화면 또는 소스 데이터와 타겟 화면 간의 의미론적 매칭에 관한 것이다. 일 실시예에서, 비-일시적 컴퓨터-판독 가능 매체는 컴퓨터 프로그램을 저장한다. 컴퓨터 프로그램은 적어도 하나의 프로세서로 하여금, 소스 화면 또는 소스 데이터의 선택을 수신하고 타겟 화면의 선택을 수신하게 하도 록 구성된다. 컴퓨터 프로그램은 또한 적어도 하나의 프로세서로 하여금, 소스 화면의 레이블들과 타겟 화면의 레이블들 사이에서, 소스 데이터의 데이터 요소들과 타겟 화면의 레이블들 사이에서 또는 둘 모두에서 의미론적 매칭을 수행하도록 트레이닝된 하나 이상의 AI/ML 모델들을 호출하게 하도록 구성된다. 컴퓨터 프로그램은 추 가로, 적어도 하나의 프로세서로 하여금, 하나 이상의 AI/ML 모델들로부터 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들의 표시들 및 개개의 신뢰도 점수들을 수신하고 매칭 인터페이스에서 타겟 화 면 상에 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들을 디스플레이하게 하도록 구성된다. 다른 실시예에서, RPA를 위한 의미론적 AI를 수행하기 위한 컴퓨터-구현 방법은, RPA 디자이너 애플리케이션에 의해, 소스 화면의 레이블들과 타겟 화면의 레이블들 사이에서, 소스 데이터의 데이터 요소들과 타겟 화면의 레 이블들 사이에서 또는 둘 모두에서 의미론적 매칭을 수행하도록 트레이닝된 하나 이상의 AI/ML 모델들을 호출하 는 것을 포함한다. 컴퓨터-구현 방법은 또한 RPA 디자이너 애플리케이션에 의해, 하나 이상의 AI/ML 모델들로 부터 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들의 표시들 및 개개의 신뢰도 점수들 을 수신하는 것, 그리고 RPA 디자이너 애플리케이션에 의해, 매칭 인터페이스에서 타겟 화면 상에 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요소들을 디스플레이하는 것을 포함한다. 컴퓨터-구현 방법은, RPA 디자이 너 애플리케이션에 의해, 소스 화면의 필드들 또는 소스 데이터의 데이터 요소들로부터의 데이터를, 하나 이상 의 AI/ML 모델들이 소스 화면으로부터의 레이블들 또는 소스 데이터로부터의 데이터 요소들과 의미론적으로 매 칭되는 것으로 식별한 레이블들을 갖는 타겟 화면의 필드들 내로 카피(copy)하는 RPA 워크플로우의 하나 이상의 활동들을 자동으로 생성하는 것을 더 포함한다. 또 다른 실시예에서, 컴퓨팅 시스템은 RPA를 위한 의미론적 AI를 수행하기 위한 컴퓨터 프로그램 명령들을 저장 하는 메모리 및 컴퓨터 프로그램 명령들을 실행하도록 구성된 적어도 하나의 프로세서를 포함한다. 컴퓨터 프로그램 명령들은, 적어도 하나의 프로세서로 하여금, 소스 화면의 레이블들과 타겟 화면의 레이블들 사이에서, 소스 데이터의 데이터 요소들과 타겟 화면의 레이블들 사이에서 또는 둘 모두에서 의미론적 매칭을 수행하도록 트레이닝된 하나 이상의 AI/ML 모델들로부터 타겟 화면의 의미론적으로 매칭되는 레이블들과 연관된 그래픽 요 소들의 표시들 및 개개의 신뢰도 점수들을 수신하게 하도록 구성된다. 컴퓨터 프로그램 명령들은 또한, 적어도 하나의 프로세서로 하여금, 매칭 인터페이스에서 타겟 화면 상에 의미론적으로 매칭되는 레이블들과 연관된 그 래픽 요소들을 디스플레이하게 하도록 구성된다. 컴퓨터 프로그램 명령들은 추가로, 적어도 하나의 프로세서로 하여금, 연관된 의미론적으로 매칭되는 레이블을 갖는 것으로서 하나 이상의 AI/ML 모델들에 의해 식별된 타겟 화면의 그래픽 요소에 대한 정정을 수신하고, 하나 이상의 AI/ML 모델들에 의해 소스 화면의 레이블과 의미론적 으로 매칭되지 않는 타겟 화면의 새로운 요소의 표시를 수신하거나, 또는 둘 모두를 행하게 하도록 구성된다. 부가적으로, 컴퓨터 프로그램 명령들은, 적어도 하나의 프로세서로 하여금, 타겟 화면의 수정된 그리고/또는 새 롭게 레이블링된 그래픽 요소 및 연관된 레이블에 관한 정보를 수집하고; 그리고 하나 이상의 AI/ML 모델들의 재트레이닝을 위해 수집된 정보를 직접 또는 간접적으로 저장하게 하도록 구성된다."}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "일부 실시예들은 RPA 워크플로우들을 위한 의미론적 AI를 사용한 소스 화면 또는 소스 데이터와 타겟 화면 간의 의미론적 매칭에 관한 것이다. 예컨대, 일부 실시예들에서, 소스 데이터 또는 소스 화면 및 타겟 화면은 매칭 인터페이스 상에서 선택되고, 인공 지능/기계 학습(AI/ML) 모델을 사용하여 소스 데이터/화면과 타겟 화면 간의 의미론적 매칭이 수행되고, 매칭 그래픽 요소들 및 언매칭 그래픽 요소들은 상이한 컬러(예컨대, 각각 녹색 및 빨간색)를 사용하여 강조되어, 개발자가 그래픽 요소들 중 어느 것이 매칭하고 어느 것이 매칭하지 않는지를 알 도록 허용한다. 매칭 인터페이스는 또한 일부 실시예들에서, 이를테면, 개별 매칭들의 신뢰도 점수를 제공하고, 전체 매핑 점수를 제공하고, 개발자가 매칭/언매칭 그래픽 요소들을 숨기고/숨김해제하도록 허용하는 부가적인 특징들을 갖는다. 또한, 하나 이상의 RPA 워크플로우 활동들은 일부 실시예들에서, RPA 로봇에 의해 실행되는 자동화의 부분으로서 의미론적 AI 기능성을 수행하기 위해 실행될 수 있는 의미론적 매핑에 기초하여 자동으로 생성된다. 일부 실시예들에서, 데이터 필드들의 리스트는 이를테면, Excel® 스프레드시트, 관계형 데이터베이스, 플랫 파 일 소스(flat file source) 등으로부터 획득될 수 있다. 의미론적 매칭 AI/ML 모델은 데이터의 엔트리들에 걸 쳐 반복되고 이를 타겟 화면 내로 채운다. 의미론적 매칭 AI/ML 모델은 데이터 소스의 유형에 관계없이 이를 수행하도록 트레이닝될 수 있다. 이 AI/ML 모델의 의미론적 매칭 기능성으로 인해, 1 대 1 매칭이 요구되지 않 을 수 있다. 예컨대, 자연어 모델은 타겟 화면의 동일하거나 유사한 이름들/구문들을, 소스 데이터의 이름들/ 구문들과 매칭시키고자(또는 소스 데이터로 시작하여 타겟 화면에서의 유사한 이름들/구문들을 찾고자) 할 수 있다. 특정 실시예들에서, 특정 용어들에 대해 다수의 유사한 단어들 또는 구문들이 존재할 수 있고 콘텍스트 에 의존하여 다수의 상이한 서브세트들이 또한 존재할 수 있기 때문에, 의미론적 매칭 AI/ML 모델을 보다 정확 하게 만들기 위해 광범위한 세트의 트레이닝 데이터가 사용된다. 일부 실시예들에서, 콘텍스트가 또한 사용될 수 있다. 예컨대, 의미론적 매칭 AI/ML 모델은 주어진 타겟이 은행 세부사항들 대 인보이스, 구매 주문서 대 연락처 정보 등과 관련되어 있음을 학습할 수 있다. 일부 실시예들의 의미론적 매칭 AI/ML 모델은 설계 시간 동안 RPA 개발자들을 보조하기 위해 전개될 수 있다. 그러나, 일부 실시예들에서, 의미론적 매칭 AI/ML 모델은 런타임에 사용되어 보다 강건한 기능성 및 자가-치유 를 제공할 수 있다. 이는 일부 실시예들에서, UI 디스크립터가 의미론적 매칭 AI/ML 모델들보다 상당히 빠른 경향이 있기 때문에, 일반적으로 사용되기 보다는, UI 디스크립터가 런타임에 타겟 그래픽 요소를 식별하지 못 하는 경우 사용될 수 있다. 따라서 UI 디스크립터들은 동일하거나 유사한 타겟 화면들에 대해 먼저 사용되어야 한다. 예컨대, 주어진 타겟 요소가 런타임에 주어진 사용자 인터페이스(UI) 디스크립터에 의해 식별될 수 없는 경우, 이를테면, 타겟 애플리케이션의 새로운 버전으로 인해 UI가 변경되는 경우, 의미론적 매칭 AI/ML 모델이 사용되 어 타겟 그래픽 요소를 식별할 수 있다. 그 후, 이 정보는 관심의 단어 또는 구문에 대한 동의어로서 추가될 수 있고, 그 그래픽 요소에 대한 UI 디스크립터는 UI 디스크립터가 앞으로 작동하도록 업데이트될 수 있다. 사 용자 인터페이스가 또 다시 변경되고 변경된 그래픽 요소 및/또는 앵커(들)가 충분히 유사한 경우, RPA 로봇은 애플리케이션의 새로운 버전에서 타겟 그래픽 요소를 식별할 수 있을 수 있다. 예컨대, 미국 특허 출원 공개 번호 제16/922,289호를 참조한다. UI 디스크립터는 UI 요소를 찾기 위한 일 세트의 명령들이다. 일부 실시예들에서 UI 디스크립터들은 UI 요소 선택자(들), 앵커 선택자(들), 컴퓨터 비전(computer vision; CV) 디스크립터(들), 통합 타겟 디스크립터(들), 화면 이미지 캡처(콘텍스트), 요소 이미지 캡처, 다른 메타데이터(예컨대, 애플리케이션 및 애플리케이션 버 전), 이들의 조합 등을 포함하는 캡슐화된 데이터/스트럭(struct) 포맷이다. 캡슐화된 데이터/스트럭 포맷은 플랫폼에 대한 향후 업데이트들에 따라 확장 가능할 수 있고 위의 정의로 제한되지 않는다. 화면 상에서 UI 요 소를 식별하기 위한 임의의 적합한 UI 디스크립터는 본 발명의 범위를 벗어나지 않고 사용될 수 있다. 일부 실시예들에서, 의미론적 매칭 AI/ML 모델이 검출하는 것은 런타임 검출을 위해 통합 타겟 디스크립터들과 결합될 수 있다. 이러한 실시예들에 대해, 소스 및 타겟에 대한 단어들 및 구문들 외에도, 매핑들이 확인되면, 통합 타겟 정보가 수집될 수 있다. 런타임에, 통합 타겟 디스크립터가 먼저 시도될 수 있고, 성공하지 못한 경 우, 의미론적 매칭 AI/ML 모델이 사용될 수 있다. 통합 타겟 디스크립터들은 AI/ML 모델들보다 안정적이고 정확한 경향이 있다. 통합 타겟 디스크립터는 다수의 유형들의 UI 디스크립터들을 함께 묶는다(chain). 통합 타겟 정보는 사용되는 UI 디스크립터(들)에 대한 그래 픽 요소의 식별을 용이하게 하는 UI 디스크립터 정보를 포함한다. 통합 타겟 디스크립터는 FSM(finite state machine)처럼 기능할 수 있으며, 여기서 제1 콘텍스트에서, 제1 UI 디스크립터 메커니즘이 적용되고, 제2 콘텍스트에서, 제2 UI 디스크립터가 적용되는 식이다. 즉, UI 디스크립 터들은 일부 실시예들에서, 이미지 검출 및 정의가 수행되는 일부 또는 모든 UI 검출 메커니즘들을 포괄하는 통 합 타겟과 함께 작동할 수 있다. 통합 타겟은 UI 요소들을 식별하고 자동화하는 다수의 기술들을 하나의 응집 성 접근법으로 병합할 수 있다. 통합 타겟은 특정 UI 디스크립터 유형들을 우선순위화하는데, 일부 실시예들에 서, 이를테면, 타겟은 선택자-기반 및 드라이버-기반 UI 검출 메커니즘들을 우선순위화하고 처음 2개의 메커니 즘들이 성공적이지 않은 경우 타겟 UI 요소를 찾기 위한 폴백(fallback)으로 CV를 사용할 수 있다. 일부 실시예들에서, NLP(natural language processing) AI/ML 모델은 의미론적 매칭 AI/ML 모델에 추가하여 또 는 그 대신에 사용될 수 있다. 특정 실시예들에서, 이들 AI/ML 모델들은 함께 사용될 수 있다. 예컨대, 모델 들 중 하나가 특정 임계치를 충족하거나 초과하고, 모델들 둘 모두의 평균이 임계치를 충족하거나 초과하는 경 우, 매칭이 사용자에게 제안될 수 있다. 일부 실시예들에서, 피드백 루프 기능성이 제공된다. 예컨대, 사용자가 매칭을 추가하거나 의미론적 매칭 AI/ML 모델에 의해 제안된 매칭을 수정하는 경우, 이 매칭과 관련된 정보가 저장될 수 있다. 이 정보는 타겟 애플리케이션의 스크린샷, 타겟 애플리케이션의 레이블 및 소스 화면 또는 소스 데이터의 대응하는 레이블, 틀 린 매칭의 레이블 등을 포함(그러나 이에 제한되지 않음)할 수 있다. 이를테면, 웹 페이지, SAP® 등에 대해 수정이 발생한 콘텍스트가 또한 캡처될 수 있다. 이 데이터는 의미론적 매칭 AI/ML 모델을 재트레이닝하기 위 해 이러한 방식으로 수집된 다른 레이블링된 데이터와 함께 사용될 수 있다. 도 1은 본 출원의 일 실시예에 따라 RPA 시스템을 예시하는 아키텍처 다이어그램이다. RPA 시스템은 개발자가 워크플로우들을 설계하고 구현하도록 허용하는 디자이너를 포함한다. 디자이너는 제3자 애 플리케이션들, 관리 정보 기술(IT) 작업들 및 비즈니스 IT 프로세스들을 자동화할 뿐만 아니라 애플리케이션 통 합을 위한 솔루션을 제공할 수 있다. 디자이너는 비즈니스 프로세스의 그래픽 표현인 자동화 프로젝트의 개발을 용이하게 할 수 있다. 간단히 말해서, 디자이너는 워크플로우들 및 로봇들의 개발 및 전개를 용이 하게 한다. 자동화 프로젝트는 워크플로우에서 개발된 단계들의 맞춤형 세트 ― 본원에서 \"활동들\"로서 정의됨 ― 간의 관 계 및 실행 순서의 개발자 제어를 제공함으로써 규칙-기반 프로세스들의 자동화를 가능하게 한다. 디자이너 의 실시예의 하나의 상업적 예는 UiPath Studio™이다. 각각의 활동은 버튼 클릭, 파일 읽기, 로그 패널 에 쓰기 등과 같은 액션을 포함할 수 있다. 일부 실시예들에서 워크플로우들은 네스팅되거나(nested) 매립될 수 있다. 일부 유형들의 워크플로우들은 시퀀스들, 흐름도들, FSM(Finite State Machine)들 및/또는 글로벌 예외 처리기 들을 포함(그러나 이에 제한되지 않음)할 수 있다. 시퀀스들은 워크플로우를 난잡하게 하지 않고 하나의 활동 으로부터 다른 활동으로의 흐름을 가능하게 하도록 선형 프로세스들에 대해 특히 적합할 수 있다. 흐름도들은 다수의 분기 로직 연산자들을 통해 보다 다양한 방식으로 활동들의 연결 및 판단들의 통합을 가능하게 하도록 보다 복잡한 비즈니스 로직에 특히 적합할 수 있다. FSM들은 대규모 워크플로우들에 특히 적합할 수 있다. FSM들은 그의 실행 시에, 조건(즉, 트랜지션) 또는 활동에 의해 트리거되는 유한한 수의 상태들을 사용할 수 있 다. 글로벌 예외 처리기들은 실행 오류에 직면할 때 워크플로우 거동(workflow behavior)을 결정하고 프로세스 들을 디버깅하는 데 특히 적합할 수 있다. 워크플로우가 디자이너에서 개발되면, 비즈니스 프로세스들의 실행은, 디자이너에서 개발된 워크플 로우들을 실행하는 하나 이상의 로봇들을 조화시키는(orchestrate) 지휘자에 의해 조화된다. 지휘자 의 실시예의 하나의 상업적 예는 UiPath Orchestrator™이다. 지휘자는 환경에서 자원들의 생성, 모 니터링 및 전개의 관리를 용이하게 한다. 지휘자는 제3자 솔루션들 및 애플리케이션들과의 통합 포인트로서 작용할 수 있다. 지휘자는 중앙 포인트로부터 로봇들을 연결하고 실행하도록 일단의 로봇들을 관리할 수 있다. 관리될 수 있는 로봇들의 유형들은 유인 로봇들, 무인 로봇들, 개발 로봇들(무인 로봇들과 유사하지만, 개발 및 테스트 목적들로 사용됨) 및 비생산 로봇들(유인 로봇과 유사하지만 개발 및 테스트 목적들로 사용됨)을 포함(그러나 이에 제한되지 않음)한다. 유인 로봇들은 사용자 이벤트들에 의해 트리 거되고 동일한 컴퓨팅 시스템 상에서 인간과 함께 동작한다. 유인 로봇들은 중앙 프로세스 전개 및 로깅 매체를 위해 지휘자와 함께 사용될 수 있다. 유인 로봇들은 인간 사용자가 다양한 작업들을 달성하 는 것을 도울 수 있고 사용자 이벤트들에 의해 트리거될 수 있다. 일부 실시예들에서, 프로세스들은 이러한 유 형의 로봇 상에서 지휘자로부터 시작될 수 없고 그리고/또는 잠금 화면 하에서 실행될 수 없다. 특정 실 시예들에서, 유인 로봇들은 로봇 트레이로부터 또는 커맨드 프롬프트로부터만 시작될 수 있다. 유인 로봇 들은 일부 실시예들에서, 인간 감독 하에 실행되어야 한다. 무인 로봇들은 가상 환경들에서 무인으로 실행되고 다수의 프로세스들을 자동화할 수 있다. 무인 로봇들 은 원격 실행, 모니터링, 스케줄링 및 작업 큐들에 대한 지원의 제공을 담당할 수 있다. 모든 로봇 유형 들에 대한 디버깅은 일부 실시예들에서 디자이너에서 실행될 수 있다. 유인 및 무인 로봇들 둘 모두는 메 인프레임들, 웹 애플리케이션들, VM들, 엔터프라이즈 애플리케이션들(예컨대, SAP® , SalesForce® , Oracle® 등에 의해 생산된 것들) 및 컴퓨팅 시스템 애플리케이션들(예컨대, 데스크톱 및 랩톱 애플리케이션들, 모바일 디바이스 애플리케이션들, 웨어러블 컴퓨터 애플리케이션들 등)을 포함(그러나 이에 제한되지 않음)하는 다양한 시스템들 및 애플리케이션들을 자동화할 수 있다. 지휘자는 프로비저닝(provisioning), 전개, 구성, 큐잉, 모니터링, 로깅, 및/또는 상호연결성의 제공을 포 함(그러나 이에 제한되지 않음)하는 다양한 능력들을 가질 수 있다. 프로비저닝은 로봇들과 지휘자 (예컨대, 웹 애플리케이션) 사이의 연결들의 생성 및 유지보수를 포함할 수 있다. 전개는 실행을 위해 할당된 로봇들로의 패키지 버전들의 올바른 전달을 보장하는 것을 포함할 수 있다. 구성은 로봇 환경들 및 프로 세스 구성들의 유지보수 및 전달을 포함할 수 있다. 큐잉은 큐들 및 큐 아이템들의 관리를 제공하는 것을 포함 할 수 있다. 모니터링은 로봇 식별 데이터를 계속 추적하고 사용자 허가들을 유지하는 것을 포함할 수 있다. 로깅은 데이터베이스(예컨대, SQL 데이터베이스) 및/또는 다른 저장 메커니즘(예컨대, 대형 데이터세트들을 저 장하고 신속하게 질의(query)하는 능력을 제공하는 ElasticSearch® )에 대한 로그들을 저장 및 인덱싱하는 것 을 포함할 수 있다. 지휘자는 제3자 솔루션들 및/또는 애플리케이션들을 위한 중앙 통신 포인트로서 작용 함으로써 상호연결성을 제공할 수 있다. 로봇들은 디자이너에서 구축된 워크플로우들을 실행하는 실행 에이전트들이다. 로봇(들)의 일 부 실시예들의 하나의 상업적 예는 UiPath Robots™이다. 일부 실시예들에서, 로봇들은 디폴트로 Microsoft Windows® SCM(Service Control Manager)-관리 서비스를 설치한다. 결과적으로, 그러한 로봇들 은 로컬 시스템 계정 하에서 대화형 Windows® 세션들을 열 수 있고 Windows® 서비스의 권한들을 가질 수 있다. 일부 실시예들에서, 로봇들은 사용자 모드에서 설치될 수 있다. 이러한 로봇들에 대해, 이는 이 로 봇들이 주어진 로봇이 설치한 사용자와 동일한 권한들을 갖는다는 것을 의미한다. 이 특징은 또한, 각각 의 기계의 최대 잠재력에서 그 각각의 기계의 최대 활용을 보장하는 고밀도(HD) 로봇들에 대해 이용 가능할 수 있다. 일부 실시예들에서, 임의의 유형의 로봇은 HD 환경에서 구성될 수 있다. 일부 실시예들에서 로봇들은 여러 구성요소들로 분할되고, 각각은 특정 자동화 작업에 전용된다. 로봇 구 성요소들은 일부 실시예들에서, SCM-관리 로봇 서비스들, 사용자 모드 로봇 서비스들, 실행기들, 에이전트들 및 커맨드 라인들을 포함(그러나 이에 제한되지 않음)한다. SCM-관리 로봇 서비스들은 Windows® 세션을 관리 및 모니터링하고 지휘자와 실행 호스트들(즉, 로봇들이 실행되는 컴퓨팅 시스템들) 사이의 프록시로서 작용한다. 이러한 서비스들은 신뢰할 수 있고 로봇들에 대한 크리덴셜(credential)들을 관리할 수 있다. 콘솔 애플리케이션은 로컬 시스템 하에서 SCM에 의해 론칭된다(launched). 사용자 모드 로봇 서비스들은 일부 실시예들에서, Windows® 세션들을 관리 및 모니터링하고 지휘자와 실 행 호스트들 간의 프록시로서 작용한다. 사용자 모드 로봇 서비스들은 신뢰할 수 있고 로봇들에 대한 크 리덴셜들을 관리할 수 있다. SCM-관리 로봇 서비스가 설치되지 않은 경우 Windows® 애플리케이션이 자동으로 론칭될 수 있다. 실행기들은 Windows® 세션 하의 주어진 작업들을 실행할 수 있는데 즉, 이들은 워크플로우들을 실행할 수 있다. 실행기들은 모니터-당 DPI(dots per inch) 세팅들을 알고 있을 수 있다. 에이전트들은 시스템 트레이 창에 이용 가능한 작업들을 디스플레이하는 WPF(Windows® Presentation Foundation) 애플리케이션들일 수 있다. 에이전트들은 서비스의 클라이언트일 수 있다. 에이전트들은 작업들을 시작 또는 중지하고 세팅들을 변 경하도록 요청할 수 있다. 커맨드 라인은 서비스의 클라이언트이다. 커맨드 라인은 작업들을 시작하고 그의 출력을 대기하도록 요청할 수 있는 콘솔 애플리케이션이다. 위에 설명된 바와 같이 로봇들의 구성요소들을 분할하면, 개발자들, 지원 사용자들 및 컴퓨팅 시스템들은 보다 쉽게 실행되고, 각각의 구성요소가 실행 중인 것을 보다 쉽게 식별 및 추적하는 데 도움이 된다. 실행기 및 서비스에 대해 상이한 방화벽 규칙들을 설정하는 것과 같은 특수 거동들은 이러한 방식으로 구성요소마다 구 성될 수 있다. 실행기는 일부 실시예들에서 모니터 당 DPI 세팅들을 항상 인식할 수 있다. 결과적으로, 워크 플로우들은 이들이 생성된 컴퓨팅 시스템의 구성에 관계없이 임의의 DPI에서 실행될 수 있다. 디자이너로 부터의 프로젝트들은 또한 일부 실시예들에서 브라우저 줌 레벨(browser zoom level)에 독립적일 수 있다. DPI-비인식 또는 비인식으로서 의도적으로 표시된 애플리케이션들에 대해, DPI가 일부 실시예들에서 디스에이블 될 수 있다. 도 2는 본 발명의 일 실시예에 따라, 전개된 RPA 시스템을 예시하는 아키텍처 다이어그램이다. 일부 실시 예들에서, RPA 시스템은 도 1의 RPA 시스템일 수 있거나 그의 부분일 수 있다. 클라이언트 측, 서버 측 또는 둘 모두는 본 발명의 범위를 벗어나지 않고 임의의 원하는 수의 컴퓨팅 시스템들을 포함할 수 있다는 것이 주의되어야 한다. 클라이언트 측 상에서, 로봇 애플리케이션은 실행기들, 에이전트, 및 디자이너를 포함한다. 그러나 일부 실시예들에서, 디자이너는 컴퓨팅 시스템에서 실행되지 않 을 수 있다. 실행기들은 프로세스들을 실행한다. 도 2에 도시된 바와 같이, 여러 비즈니스 프로젝트들이 동시에 실행될 수 있다. 에이전트(예컨대, Windows® 서비스)는 이 실시예에서 모든 실행기들에 대 한 단일 접촉 포인트이다. 이 실시예의 모든 메시지들은 데이터베이스 서버, 인덱서 서버 또는 둘 모두를 통해 추가로 이들을 프로세싱하는 지휘자에 로깅된다. 도 1과 관련하여 위에서 논의된 바와 같이, 실행기들은 로봇 구성요소들일 수 있다. 일부 실시예들에서, 로봇은 기계 이름과 사용자 이름 사이의 연관을 표현한다. 로봇은 동시에 다수의 실행기들 을 관리할 수 있다. 동시에 실행중인 다수의 대화형 세션들을 지원하는 컴퓨팅 시스템들(예컨대, Windows® Server 2012) 상에서, 다수의 로봇들은 각각 고유한 사용자 이름을 사용하는 별도의 Windows® 세션에서 동시에 실행될 수 있다. 이는 위에서 HD 로봇들로서 지칭된다. 에이전트는 또한 로봇의 상태를 전송하고(예컨대, 로봇이 여전히 기능하고 있음을 표시하는 \"하트비트 (heartbeat)\" 메시지를 주기적으로 전송함) 실행될 패키지의 요구된 버전을 다운로드하는 것을 담당한다. 에이 전트와 지휘자 사이의 통신은 일부 실시예들에서 항상 에이전트에 의해 개시된다. 알림 시나리 오에서, 에이전트는 커맨드들(예컨대, 시작, 중지 등)을 로봇에 전송하기 위해 지휘자에 의해 추후에 사용되는 WebSocket 채널을 열 수 있다. 서버 측 상에서, 프리젠테이션 층(웹 애플리케이션, OData(Open Data Protocol) REST(Representative State Transfer) API(Application Programming Interface) 엔드포인트들, 알림 및 모니터링), 서비 스 층(API 구현/비즈니스 로직) 및 영속 층(데이터베이스 서버 및 인덱서 서버)이 포함된다. 지휘자는 웹 애플리케이션, OData REST API 엔드포인트들, 알림 및 모니터링, API 구현/ 비즈니스 로직을 포함한다. 일부 실시예들에서, 지휘자의 인터페이스에서 사용자가 (예컨대, 브라우 저를 통해) 수행하는 대부분의 액션들은 다양한 API들을 호출함으로써 수행된다. 이러한 액션들은 본 발 명의 범위로부터 벗어남 없이 로봇들 상에서 작업들의 시작, 큐들에의 데이터의 추가/제거, 무인으로 실행할 작 업들의 스케줄링 등을 포함(그러나 이에 제한되지 않음)할 수 있다. 웹 애플리케이션은 서버 플랫폼의 시 각적 층이다. 이 실시예에서, 웹 애플리케이션은 HTML(Hypertext Markup Language) 및 JS(JavaScript)를 사용한다. 그러나, 임의의 원하는 마크업 언어들, 스크립트 언어들, 또는 임의의 다른 포맷들이 본 발명의 범 위를 벗어나지 않고 사용될 수 있다. 사용자는 지휘자를 제어하기 위한 다양한 액션들을 수행하기 위해 이 실시예에서 브라우저를 통해 웹 애플리케이션으로부터의 웹 페이지들과 상호작용한다. 예컨대, 사용자는 로봇 그룹들을 생성하고, 로봇들에 패키지들을 할당하고, 로봇 당 그리고/또는 프로세스 당 로그들을 분석하고, 로봇들을 시작 및 중지하는 등을 행할 수 있다. 웹 애플리케이션 외에도, 지휘자는 OData REST API 엔드포인트들을 노출하는 서비스 층을 또한 포함한다. 그러나, 본 발명의 범위를 벗어나지 않고 다른 엔드포인트들이 포함될 수 있다. REST API는 웹 애 플리케이션 및 에이전트 둘 모두에 의해 소비된다. 에이전트는 이 실시예에서 클라이언트 컴퓨 터 상의 하나 이상의 로봇들의 감독자이다. 이 실시예의 REST API는 구성, 로깅, 모니터링 및 큐잉 기능성을 커버한다. 구성 엔드포인트들은 일부 실시예 들에서 애플리케이션 사용자들, 허가들, 로봇들, 자산들, 릴리스들 및 환경들을 정의 및 구성하는 데 사용될 수 있다. 로깅 REST 엔드포인트들은 예컨대, 오류들, 로봇에 의해 전송된 명시적 메시지들 및 다른 환경-특정 정 보와 같은 상이한 정보를 로깅하는 데 사용할 수 있다. 전개 REST 엔드포인트들은 작업 시작 커맨드가 지휘자 에서 사용되는 경우 실행되어야 하는 패키지 버전을 질의하기 위해 로봇들에 의해 사용될 수 있다. 큐잉 REST 엔드포인트들은 큐들 및 큐 아이템 관리 이를테면, 큐에 데이터를 추가하는 것, 큐로부터 트랜잭션을 획득 하는 것, 트랜잭션의 상태를 세팅하는 것 등을 담당할 수 있다. 모니터링 REST 엔드포인트들은 웹 애플리케이션 및 에이전트를 모니터링할 수 있다. 알림 및 모니터 링 API는 에이전트를 등록하고, 구성 세팅들을 에이전트에 전달하고, 서버 및 에이전트에 알림들을 전송/수신하는 데 사용되는 REST 엔드포인트들일 수 있다. 알림 및 모니터링 API는 또한 일부 실시예들에서 WebSocket 통신을 사용할 수 있다. 영속 층은 이 실시예에서 한 쌍의 서버들 ― 데이터베이스 서버(예컨대, SQL 서버) 및 인덱서 서버를 포함한다. 이 실시예에서 데이터베이스 서버는 로봇들, 로봇 그룹들, 연관된 프로세스들, 사용자들, 역할 들, 스케줄러들 등의 구성들을 저장한다. 이 정보는 일부 실시예들에서 웹 애플리케이션을 통해 관리된다. 데이터베이스 서버는 큐들 및 큐 아이템들을 관리할 수 있다. 일부 실시예들에서, 데이터베이 스 서버는 (인덱서 서버에 추가로 또는 그 대신에) 로봇들에 의해 로깅된 메시지들을 저장할 수 있다. 일부 실시예들에서 선택적인 인덱서 서버는 로봇들에 의해 로깅된 정보를 저장 및 인덱싱한다. 특정 실시 예들에서, 인덱서 서버는 구성 세팅들을 통해 디스에이블될 수 있다. 일부 실시예들에서, 인덱서 서버 는 오픈 소스 프로젝트 풀-텍스트 검색 엔진인 ElasticSearch®를 사용한다. (예컨대, 로그 메시지 또는 쓰기 라인과 같은 활동들을 사용하여) 로봇들에 의해 로깅된 메시지들은 로깅 REST 엔드포인트(들)를 통해 인덱 서 서버 ― 여기서 메시지들은 향후 활용을 위해 인덱싱됨 ― 에 전송될 수 있다. 도 3은 본 발명의 일 실시예에 따러, 디자이너, 활동들(320, 330), 드라이버들, 및 AI/ML 모델들 사이의 관계를 예시하는 아키텍처 다이어그램이다. 위의 내용에 따라, 개발자는 디자이너를 사용하여 로봇들에 의해 실행되는 워크플로우들을 개발한다. 워크플로우들은 사용자-정의 활동들 및 UI 자동화 활동들을 포함할 수 있다. 사용자 정의 활동들 및/또는 UI 자동화 활동들은 일부 실시 예들에서 하나 이상의 AI/ML 모델들을 호출할 수 있으며, 이는 로봇이 동작하는 컴퓨팅 시스템에 로컬로 및/또는 그에 원격으로 위치될 수 있다. 일부 실시예들은 이미지에서 비-텍스트 시각적 구성요소들을 식별할 수 있으며, 이는 본원에서 CV(computer vision)라 불린다. 이러한 구성요소들과 관련된 일부 CV 활동들은 클릭, 타이핑, 텍스트 가져오기, 호버(hover), 요소 이그지스트(element exist)들, 리프레시 범위, 강조 등을 포함(그러나 이에 제한되지 않음)할 수 있다. 일부 실시예들에서 클릭은 예컨대, CV, OCR(optical character recognition), 퍼지 텍스트 매칭 및 다중-앵커를 사용하여 요소를 식별하고 이를 클릭한다. 타이핑은 위를 이 용하여 요소를 식별하고 요소를 타이핑할 수 있다. 텍스트 가져오기는 특정 텍스트의 위치를 식별하고 OCR을 사용하여 그 특정 텍스트를 스캔할 수 있다. 호버는 요소를 식별하고 그 요소 위에서 호버링할 수 있다. 요소 이그지스트들은 위에서 설명한 기술들을 사용하여 화면 상에 요소가 존재하는지 체크할 수 있다. 일부 실시예 들에서, 디자이너에서 구현될 수 있는 수백 또는 심지어 수천 개의 활동들이 존재할 수 있다. 그러나, 본 발명의 범위를 벗어나지 않고 임의의 수 및/또는 유형의 활동들이 이용 가능할 수 있다. UI 자동화 활동들은 하위 레벨 코드(예컨대, CV 활동들)로 작성되고 화면과의 상호작용들을 용이하게 하는 특별한 하위 레벨 활동들의 서브세트이다. UI 자동화 활동들은 로봇이 원하는 소프트웨어와 상호작용하도 록 허용하는 AI/ML 모델들 및/또는 드라이버들을 통해 이러한 상호작용들을 용이하게 한다. 예컨대, 드라이버들은 OS 드라이버들, 브라우저 드라이버들, VM 드라이버들, 엔터프라이즈 애플리 케이션 드라이버들 등을 포함할 수 있다. AI/ML 모델들 중 하나 이상은 컴퓨팅 시스템과의 상호작용 들의 수행을 결정하기 위해 UI 자동화 활동들에 의해 사용될 수 있다. 일부 실시예들에서, AI/ML 모델들 은 드라이버들을 보강하거나 이들을 완전히 대체할 수 있다. 실제로, 특정 실시예들에서, 드라이버 들은 포함되지 않는다.드라이버들은 후크(hook)들을 찾고, 키들을 모니터링하는 등 저레벨에서 OS와 상호작용할 수 있다. 이들 은 Chrome® , IE® , Citrix® , SAP® 등과의 통합을 용이하게 할 수 있다. 예컨대, \"클릭\" 활동은 드라이버 들을 통해 이러한 상이한 애플리케이션들에서 동일한 역할을 수행한다. 도 4는 본 출원의 일 실시예에 따라 RPA 시스템을 예시하는 아키텍처 다이어그램이다. 일부 실시예들에서, RPA 시스템은 도 1 및/또는 도 2의 RPA 시스템들(100 및/또는 200)이거나 이를 포함할 수 있다. RPA 시스템은 로봇들을 실행하는 다수의 클라이언트 컴퓨팅 시스템들을 포함한다. 컴퓨팅 시 스템들은 지휘자 컴퓨팅 시스템 상에서 실행되는 웹 애플리케이션을 통해 지휘자 컴퓨팅 시스템과 통 신할 수 있다. 지휘자 컴퓨팅 시스템은 차례로, 데이터베이스 서버 및 선택적 인덱서 서버와 통신할 수 있다. 도 1 및 도 3과 관련하여, 이들 실시예들에서 웹 애플리케이션이 사용되는 동안, 본 발명의 범위를 벗어나지 않 고 임의의 적합한 클라이언트/서버 소프트웨어가 사용될 수 있다는 것이 주의되어야 한다. 예컨대, 지휘자는 클라이언트 컴퓨팅 시스템들 상에서 비-웹-기반 클라이언트 소프트웨어 애플리케이션들과 통신하는 서버-측 애 플리케이션을 실행할 수 있다. 도 5는 본 발명의 일 실시예에 따라, RPA 워크플로우를 위한 의미론적 AI를 이용한 소스 화면/소스 데이터와 타 겟 화면 간의 의미론적 매칭을 수행하도록 구성된 컴퓨팅 시스템을 예시하는 아키텍처 다이어그램이다. 일부 실시예들에서, 컴퓨팅 시스템은 본원에서 도시되고 그리고/또는 설명된 컴퓨팅 시스템들 중 하나 이 상일 수 있다. 컴퓨팅 시스템은 정보를 통신하기 위한 버스 또는 다른 통신 메커니즘, 및 정보를 프 로세싱하기 위해 버스에 커플링된 프로세서(들)를 포함한다. 프로세서(들)는 CPU(Central Processing Unit), ASIC(Application Specific Integrated Circuit), FPGA(Field Programmable Gate Array), GPU(Graphics Processing Unit), 이들의 다수의 인스턴스들 및/또는 이들의 임의의 조합을 포함하는 임의의 유 형의 범용 또는 특수 목적 프로세서일 수 있다. 프로세서(들)는 또한 다수의 프로세싱 코어들을 가질 수 있고, 코어들의 적어도 일부는 특정 기능들을 수행하도록 구성될 수 있다. 다중-병렬 프로세싱이 일부 실시예 들에서 사용될 수 있다. 특정 실시예들에서, 프로세서(들) 중 적어도 하나는 생물학적 뉴런들을 모방하는 프로세싱 요소들을 포함하는 뉴로모픽 회로(neuromorphic circuit)일 수 있다. 일부 실시예들에서, 뉴로모픽 회로는 폰 노이만(Von Neumann) 컴퓨팅 아키텍처의 통상적인 구성요소들을 요구하지 않을 수 있다. 컴퓨팅 시스템은 프로세서(들)에 의해 실행될 명령들 및 정보를 저장하기 위한 메모리를 더 포 함한다. 메모리는 RAM(Random Access Memory), ROM(Read Only Memory), 플래시 메모리, 캐시, 정적 저장 소 이를테면, 자기 또는 광학 디스크, 또는 임의의 다른 유형들의 비-일시적 컴퓨터-판독 가능 매체들 또는 이 들의 조합들의 임의의 조합으로 구성될 수 있다. 비-일시적 컴퓨터-판독 가능 매체들은 프로세서(들)에 의해 액세스될 수 있는 임의의 이용 가능한 매체들일 수 있고 휘발성 매체들, 비-휘발성 매체들, 또는 둘 모두 를 포함할 수 있다. 매체들은 또한 착탈식, 비-착탈식 또는 둘 모두일 수 있다. 부가적으로, 컴퓨팅 시스템은 무선 및/또는 유선 연결을 통해 통신 네트워크에 대한 액세스를 제공하도록 통신 디바이스 이를테면, 트랜시버를 포함한다. 일부 실시예들에서, 통신 디바이스는 FDMA(Frequency Division Multiple Access), SC-FDMA(Single Carrier FDMA), TDMA(Time Division Multiple Access), CDMA(Code Division Multiple Access), OFDM(Orthogonal Frequency Division Multiplexing), OFDMA(Orthogonal Frequency Division Multiple Access), GSM(Global System for Mobile) 통신들, GPRS(General Packet Radio Service), UMTS(Universal Mobile Telecommunications System), cdma2000, W- CDMA(광대역 CDMA), HSDPA(High-Speed Downlink Packet Access), HSUPA(High-Speed Uplink Packet Access), HSPA(High-Speed Packet Access), LTE(Long Term Evolution), LTE-A(LTE Advanced), 802.11x, Wi-Fi, Zigbee, UWB(Ultra-WideBand), 802.16x, 802.15, HnB(Home Node-B), Bluetooth, RFID(Radio Frequency Identification), IrDA(Infrared Data Association), NFC(Near-Field Communications), 5세대(5G), NR(New Radio), 이들의 임의의 조합, 및/또는 본 발명의 범위를 벗어나지 않고 임의의 다른 현재 존재하거나 향후에 구 현되는 통신 표준 및/또는 프로토콜을 사용하도록 구성될 수 있다. 일부 실시예들에서, 통신 디바이스는 본 발명의 범위를 벗어나지 않고 단일의, 어레이화된, 단계화된, 스위칭되는, 빔포밍, 빔스티어링, 이들의 조합, 및/또는 임의의 다른 안테나 구성인 하나 이상의 안테나들을 포함할 수 있다. 프로세서(들)는 추가로, 버스를 통해 디스플레이, 이를테면, 플라즈마 디스플레이, LCD(Liquid Crystal Display), LED(Light Emitting Diode) 디스플레이, FED(Field Emission Display), OLED(Organic Light Emitting Diode) 디스플레이, 플렉서블 OLED 디스플레이, 플렉서블 기판 디스플레이, 프로젝션 디스플레이, 4K 디스플레이, 고화질 디스플레이, Retina® 디스플레이, IPS(In-Plane Switching) 디스플레이 또는 사용 자에게 정보를 디스플레이하기 위한 임의의 다른 적합한 디스플레이에 커플링될 수 있다. 디스플레이는 저항성, 용량성, SAW(surface-acoustic wave) 용량성, 적외선, 광학 이미징, 분산 신호 기술, 음향 펄스 인식, 불완전 전반사(frustrated total internal reflection) 등을 이용하여 터치(햅틱) 디스플레이, 3차원(3D) 터치 디스플레이, 다중-입력 터치 디스플레이, 다중-터치 디스플레이 등으로 구성될 수 있다. 임의의 적합한 디스플 레이 디바이스 및 햅틱 I/O가 본 발명의 범위를 벗어나지 않고 사용될 수 있다. 키보드 및 커서 제어 디바이스 이를테면, 컴퓨터 마우스, 터치패드 등은 추가로, 사용자가 컴퓨팅 시 스템과 인터페이싱하는 것을 가능하게 하도록 버스에 커플링된다. 그러나, 특정 실시예들에서, 물리 적 키보드 및 마우스가 존재하지 않을 수 있고, 사용자는 디스플레이 및/또는 터치패드(도시되지 않음)를 통해서만 디바이스와 상호작용할 수 있다. 입력 디바이스들의 임의의 유형 및 조합은 설계 선택 사항으로서 사 용될 수 있다. 특정 실시예들에서, 어떠한 물리적 입력 디바이스 및/또는 디스플레이도 존재하지 않는다. 예 컨대, 사용자는 컴퓨팅 시스템과 통신하는 다른 컴퓨팅 시스템을 통해 원격으로 컴퓨팅 시스템과 상 호작용할 수 있거나 컴퓨팅 시스템은 자율적으로 동작할 수 있다. 메모리는 프로세서(들)에 의해 실행되는 경우 기능을 제공하는 소프트웨어 모듈들을 저장한다. 모듈 들은 컴퓨팅 시스템을 위한 운영 체제를 포함한다. 모듈들은 본원에서 설명된 프로세스들 또는 그의 파생물들 전부 또는 일부를 수행하도록 구성된 의미론적 매칭 모듈을 더 포함한다. 컴퓨팅 시스템은 부가적인 기능성을 포함하는 하나 이상의 부가적인 기능 모듈들을 포함할 수 있다. 당업자는, \"시스템\"이 서버, 임베디드 컴퓨팅 시스템, 개인용 컴퓨터, 콘솔, PDA(personal digital assistant), 셀 전화, 태블릿 컴퓨팅 디바이스, 양자 컴퓨팅 시스템, 또는 임의의 다른 적합한 컴퓨팅 디바이스, 또는 본 발명의 범위를 벗어나지 않으면서 디바이스들의 조합으로서 구체화될 수 있다는 것을 인지할 것이다. \"시스템\"에 의해 수행되는 것으로 위에서 설명된 기능들을 제시하는 것은 본 발명의 범위를 어떤 식으 로든 제한하는 것으로 의도되는 것이 아니라, 본 발명의 다수의 실시예들의 하나의 예를 제공하는 것으로 의도 된다. 실제로, 본원에서 개시된 방법들, 시스템들 및 장치들은 클라우드 컴퓨팅 시스템들을 포함하는 컴퓨팅 기술과 일치하는 로컬화된 그리고 분산된 형태들로 구현될 수 있다. 컴퓨팅 시스템은 LAN(local area network), 모바일 통신 네트워크, 위성 통신 네트워크, 인터넷, 공용 또는 사설 클라우드, 하이브리드 클라우드, 서버 팜, 이들의 임의의 조합 등의 일부이거나 이들에 의해 다른 방식으로 액세스 가능할 수 있다. 본 발명의 범위를 벗어나지 않고 임의의 로컬화된 또는 분산된 아키텍처가 사용될 수 있다. 본 명세서에서 설명된 시스템 특징들 중 일부는 그의 구현 독립성을 보다 구체적으로 강조하기 위해 모듈들로서 제시되었다는 것이 주의되어야 한다. 예컨대, 모듈은 맞춤형 VLSI(very large scale integration) 회로들 또 는 게이트 어레이들, 기성품 반도체들 이를테면, 로직 칩들, 트랜지스터들 또는 다른 개별 구성요소들을 포함하 는 하드웨어 회로로서 구현될 수 있다. 모듈은 또한 필드 프로그래밍 가능 게이트 어레이들, 프로그래밍 가능 어레이 로직, 프로그래밍 가능 로직 디바이스들, 그래픽 프로세싱 유닛들 등과 같은 프로그래밍 가능 하드웨어 디바이스들로 구현될 수 있다. 모듈은 또한 다양한 유형들의 프로세서들에 의한 실행을 위해 소프트웨어에서 적어도 부분적으로 구현될 수 있 다. 예컨대, 실행 가능 코드의 식별된 유닛은 예컨대, 오브젝트, 절차 또는 함수로서 구성될 수 있는 컴퓨터 명령들의 하나 이상의 물리적 또는 논리적 블록들을 포함할 수 있다. 그럼에도, 식별된 모듈의 실행 가능한 것 들은 물리적으로 함께 위치될 필요는 없지만 논리적으로 함께 결합될 때 모듈을 포함하고 모듈에 대해 언급된 목적을 달성하는 상이한 로케이션들에 저장된 이종 명령들을 포함할 수 있다. 또한, 모듈들은 예컨대, 하드 디 스크 드라이브, 플래시 디바이스, RAM, 테이프 및/또는 본 발명의 범위를 벗어나지 않으면서 데이터를 저장하는 데 사용되는 임의의 다른 비-일시적 컴퓨터-판독 가능 매체일 수 있는 컴퓨터-판독 가능 매체 상에 저장될 수 있다. 실제로, 실행 가능 코드의 모듈은 단일 명령, 또는 다수의 명령들을 포함할 수 있고, 심지어는 여러 개의 상이 한 코드 세그먼트들에 걸쳐, 상이한 프로그램들 중에, 그리고 여러 메모리 디바이스들에 걸쳐 분산될 수 있다. 유사하게, 운용 데이터는 모듈들 내에서 본원에서 식별되고 예시될 수 있으며, 임의의 적합한 형태로 구체화되 고 임의의 적합한 유형의 데이터 구조 내에서 구성될 수 있다. 운용 데이터는 단일 데이터 세트로서 수집될 수 있거나, 또는 상이한 저장 디바이스들을 포함하는 상이한 로케이션들에 걸쳐 분산될 수 있고, 적어도 부분적으 로, 시스템 또는 네트워크 상에서 단지 전자 신호들로서 존재할 수 있다. 도 6은 본 발명의 일 실시예에 따라, RPA 워크플로우를 위한 의미론적 AI를 이용하여 AI/ML 모델들을 트레이닝 하고 소스 화면/소스 데이터와 타겟 화면 간의 의미론적 매칭을 수행하도록 구성된 시스템을 예시하는 아 키텍처 다이어그램이다. 시스템은 데스크톱 컴퓨터, 태블릿 및 스마트폰과 같은 사용자 컴퓨팅 시스템들을 포함한다. 그러나, 스마트 워치들, 랩톱 컴퓨터들, IoT(Internet-of-Things) 디바이스들, 차량 컴퓨팅 시스템 등을 포함(그러나 이에 제한되지 않음)하는 임의의 원하는 컴퓨팅 시스템이 본 발명의 범위 를 벗어나지 않고 사용될 수 있다. 각각의 컴퓨팅 시스템(602, 604, 606)에는 RPA 디자이너 애플리케이션이 설치되어 있다. RPA 디자이너 애플리 케이션은 개개의 사용자가 소스 화면들 또는 소스 데이터 및 타겟 화면들을 선택하도록 허용하는 매핑 기 능성을 제공한다. RPA 디자이너 애플리케이션은 또한 네트워크(예컨대, LAN(local area network), 모바일 통신 네트워크, 위성 통신 네트워크, 인터넷, 이들의 임의의 조합 등)을 통해 서버의 AI/ML 모델들 을 호출하도록 구성된다. 서버는 데이터베이스에 데이터를 저장하고 데이터베이스로부터 데이터를 리트리브(retrieve)한다. AL/ML 모델들은 의미론적 AI 기능성, CV, OCR, NLP 등을 제공한다. 예컨대, 하나의 AI/ML 모델은 CV 기 능성을 제공할 수 있고, 다른 모델은 OCR을 수행할 수 있으며, 또 다른 모델은 이 데이터를 사용하여 의미론적 매칭을 수행할 수 있는 등등이다. 도 7a는 본 발명의 일 실시예에 따라, 이미지의 그래픽 요소들을 인식하도록 트레이닝된 신경망의 예를 예 시한다. 여기서, 신경망은 입력 층의 입력 \"뉴런들\" 1 내지 I에 대한 입력으로서 1920×1080 화면의 스크 린샷 이미지의 픽셀들을 수신한다. 이 경우에, I는 스크린샷 이미지의 픽셀들의 총 수인 2,073,600이다. 신경망은 또한 다수의 은닉 층들을 포함한다. DLNN들 및 SLNN들 둘 모두는 일반적으로 다수의 층들을 갖 지만, SLNN들은 일부 경우들에서 하나 또는 2개의 층들만을 가질 수 있고, 일반적으로 DLNN들보다 적다. 통상 적으로 신경망 아키텍처는 신경망의 경우와 같이 입력 층, 다수의 중간 층 및 출력 층을 포함한다. DLNN은 종종 다수의 층들(예컨대, 10, 50, 200 등)을 가지며, 후속 층은 통상적으로 이전 층들로부터의 특징들 을 재사용하여 더 복잡하고 일반적인 기능들을 컴퓨팅한다. 반면에, SLNN은 익스퍼트 특징(expert feature)들 이 원시 데이터 샘플들로부터 미리 생성되기 때문에, 단 몇 개의 층들만을 갖고 비교적 빠르게 트레이닝하는 경 향이 있다. 그러나 특징 추출은 수고스럽다. 반면에, DLNN들은 일반적으로 익스퍼트 특징들을 요구하지 않지 만, 트레이닝하는 데 시간이 더 오래 걸리고 더 많은 층들을 갖는 경향이 있다. 양 접근법들에 대해, 층들은 트레이닝 세트 상에서 동시에 트레이닝되며, 일반적으로 격리된 교차-검증 세트 상 에서 오버피팅(overfitting)에 대해 체크한다. 양 기술들은 뛰어난 결과들을 산출할 수 있으며 양 접근법들에 대해 상당한 열광(enthusiasm)이 존재한다. 개별 층들의 최적 크기, 형상 및 수량은 개개의 신경망에 의해 해 결되는 문제에 의존하여 변동된다. 도 7a를 참조하면, 입력 층으로서 제공된 픽셀들은 은닉 층 1의 J개의 뉴런들에 대한 입력들로서 공급된다. 이 예에서 모든 픽셀들이 각각의 뉴런에 공급되지만, 본 발명의 범위를 벗어나지 않으면서 피드 포워드 네트워크들, 방사형 기준 네트워크들, 딥 피드 포워드 네트워크들, 딥 콘볼루셔널 인버스 그래픽 네트워크들, 콘볼루셔널 신경망들, 순환 신경망들, 인공 신경망들, 장기/단기 메모리 네트워크들, 게이트 순환 단위 네트워 크들, 생성적 적대 네트워크(generative adversarial network)들, 액체 상태 기계들, 자동 인코더들, 변이 자 동 인코더들, 디노이징 자동 인코더들, 희소 자동 인코더들, 익스트림 러닝 머신들, 에코 상태 네트워크들, 마 르코프(Markov) 체인, 홉필드(Hopfield) 네트워크, 볼츠만(Boltzmann) 머신들, 제한된 볼츠만 머신들, 딥 잔차 네트워크들, 코호넨(Kohonen) 네트워크들, 딥 빌리프 네트워크들, 딥 콘볼루셔널 네트워크들, 지원 벡터 머신들, 신경 튜링 머신(neural Turing machine)들, 또는 신경망들의 임의의 다른 적합한 유형 또는 조합을 포 함(그러나 이에 제한되지 않음)해서, 개별적으로 또는 조합하여 사용될 수 있는 다양한 아키텍처들이 가능하다. 마지막 은닉 층이 출력 층에 대한 입력들로서 그의 출력들을 제공할 때까지, 모든 은닉 층들에 대해, 은닉 층 2 는 은닉 층 1로부터 입력들을 수신하고, 은닉 층 3은 은닉 층 2로부터 입력들을 수신하는 식이다. 뉴런들의 수 들(I, J, K, 및 L)은 반드시 동일할 필요는 없으며, 따라서 본 발명의 범위를 벗어나지 않고 신경망의 주 어진 층에 대해 임의의 원하는 수의 층들이 사용될 수 있다는 것이 주의되어야 한다. 실제로, 특정 실시예들에 서, 주어진 층에서 뉴런들의 유형들은 모두 동일하진 않을 수 있다. 신경망은 이미지에서 발견된 것으로 여겨지는 그래픽 요소들에 신뢰도 점수를 할당하도록 트레이닝된다. 수락 불가능하게 낮은 가능성들을 가진 매칭들을 감소시키기 위해, 일부 실시예들에서, 신뢰도 임계치를 충족하 거나 초과하는 신뢰도 점수를 갖는 그러한 결과들만이 제공될 수 있다. 예컨대, 신뢰도 임계치가 80%인 경우,이 양을 초과하는 신뢰도 점수들을 가진 출력들이 사용될 수 있고, 나머지는 무시될 수 있다. 이 경우에, 출력 층은 2개의 텍스트 필드들, 텍스트 레이블들 및 제출 버튼이 발견되었음을 표시한다. 신경망은 본 발명의 범위를 벗어나지 않고 이러한 요소들에 대한 로케이션들, 치수들, 이미지들 및/또는 신뢰도 점수들을 제공할 수 있으며, 이는 주어진 목적을 위해 이 출력을 사용하는 RPA 로봇 또는 다른 프로세스에 의해 후속적으로 사용될 수 있다. 신경망들은 통상적으로 신뢰도 점수를 갖는 확률론적 구조들이라는 것이 주의되어야 한다. 신뢰도 점수는 트레 이닝 동안 유사한 입력이 얼마나 자주 올바르게 식별되었는지에 기초하여 AI/ML 모델에 의해 학습된 점수일 수 있다. 예컨대, 텍스트 필드들은 종종 직사각형 형상 및 백색 배경을 갖는다. 신경망은 높은 신뢰도로 이러한 특성들을 가진 그래픽 요소들을 식별하도록 학습할 수 있다. 일부 공통적인 유형들의 신뢰도 점수들은 0과 1 사이의 십진수(신뢰도의 퍼센티지로서 해석될 수 있음), 음의 ∞와 양의 ∞ 사이의 숫자 또는 일 세트의 표현들 (예컨대, \"낮음\", \"중간\", 및 \"높음\")을 포함한다. 보다 정확한 신뢰도 점수를 획득하기 위한 일환으로 온도 스케일링, 배치 정규화(batch normalization), 가중치 감쇠(weight decay), NLL(negative log likelihood) 등 과 같은 다양한 포스트-프로세싱 교정 기술들이 또한 사용될 수 있다. 신경망의 \"뉴런들\"은 통상적으로 생물학적 뉴런의 기능에 기초하는 수학적 함수들이다. 뉴런들은 가중화된 입 력을 수신하고 출력을 다음 층으로 전달할지를 통제하는 합산 및 활성화 함수를 갖는다. 이 활성화 함수는 값 이 임계치 미만인 경우 아무 일도 일어나지 않는 비선형 임계 활동 함수일 수 있지만, 그 후 임계치 초과 시에 함수는 선형으로 응답한다(즉, ReLU(rectified linear unit) 비선형성). 실제 뉴런들은 거의 유사한 활동 기능 들을 가질 수 있기 때문에, 합산 함수들 및 ReLU 함수들은 딥 러닝(deep learning)에서 사용된다. 선형 변환들 을 통해, 정보가 차감되고, 추가되는 등이 가능할 수 있다. 본질적으로 뉴런들은 그의 근본 수학적 함수에 의 해 통제되는 바와 같은, 다음 층으로 출력을 전달하는 게이팅 함수들로서 작용한다. 일부 실시예들에서, 적어 도 일부 뉴런들에 대해 상이한 함수들이 사용될 수 있다. 뉴런의 예가 도 7b에 도시된다. 선행 층으로부터의 입력들( )에는 개개의 가중치들 ( )이 할당된다. 따라서 선행 뉴런 1의 집합적 입력은 이다. 이러한 가중화된 입력들은 다음 과 같이 편향에 의해 수정된 뉴런의 합산 함수에 대해 사용된다:"}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "이 합산은 뉴런이 \"발화(fires)\"하는지를 결정하기 위해 활성화 함수 f(x)에 대해 비교된다. 예컨대, f(x)는 다음에 의해 주어질 수 있다:"}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "따라서 뉴런의 출력 y는 다음에 의해 주어질 수 있다:"}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "이 경우에, 뉴런은 단일-층 퍼셉트론(single-layer perceptron)이다. 그러나, 임의의 적합한 뉴런 유형 또는 뉴런 유형들의 조합이 본 발명의 범위를 벗어나지 않고 사용될 수 있다. 이를테면, 이 경우에, 이미지에서 그래픽 요소의 성공적 식별에 대해 목표 또는 \"보상 함수(reward function)\" 가 종종 사용된다. 보상 함수는 상태 공간 검색을 안내하고 목표(예컨대, 그래픽 요소들의 성공적인 식별, RPA 워크플로우에 대한 활동들의 다음 시퀀스의 성공적인 식별 등)의 달성을 시도하기 위해 단기 및 장기 보상들 둘 모두를 갖는 중간 트랜지션들 및 단계를 탐색한다(explore). 트레이닝 동안 다양한 레이블링된 데이터(이 경우에, 이미지들)가 신경망을 통해 공급된다. 성공적인 식 별들은 뉴런들에 대한 입력들에 대해 가중치들을 강화하는 반면 실패한 식별들은 가중치들을 약화시킨다. 매우 잘못된 예측들보다 훨씬 약하게 약간 잘못된 예측들을 벌하기(punish) 위해 MSE(mean square error) 또는 경사하강법(gradient descent)과 같은 비용 함수가 사용될 수 있다. AI/ML 모델의 성능이 특정 수의 트레이닝 반복 들 후에도 개선되지 않는 경우, 데이터 과학자는 보상 함수를 수정하고, 식별되지 않은 그래픽 요소들이 있는 곳의 표시들을 제공하고, 오식별된 그래픽 요소들의 수정을 제공하는 등을 행할 수 있다. 역전파(backpropagation)는 피드포워드 신경망에서 시냅틱 가중치(synaptic weight)를 최적화하기 위한 기술이 다. 역전파는 신경망의 은닉 층들을 \"팝 더 후드(pop the hood)\"를 하는데 사용되어 모든 각각의 노드가 손실 중 얼마나 많이 담당하고 있는지를 파악하고, 더 높은 오류 레이트들을 갖는 노드들에 더 낮은 가중치들을 부여 (그리고 그 반대의 경우도 마찬가지임)함으로써 손실을 최소화하는 방식으로 가중치들을 후속적으로 업데이트할 수 있다. 즉, 역전파는 데이터 과학자들이 가중치들을 반복적으로 조정하여 실제 출력과 원하는 출력 간의 차 이를 최소화하도록 허용한다. 역전파 알고리즘은 수학적으로 최적화 이론에서 발견된다. 지도 학습에서, 알려진 출력을 갖는 트레이닝 데이 터는 신경망을 통해 전달되고 알려진 타겟 출력으로부터 비용 함수에 따라 오류가 컴퓨팅되며, 이는 역전파에 대한 오류를 제공한다. 오류는 출력에서 컴퓨팅되고 이 오류는 오류를 최소화하는 네트워크 가중치들에 대한 수정들로 변환된다. 지도 학습의 경우에, 역전파의 예가 아래에 제공된다. 열 벡터 입력 x는 네트워크의 각각의 층 사 이의 일련의 N개의 비선형 활동 함수 fi를 통해 프로세싱되며, 주어진 층에서의 출력에는 먼저 시냅틱 행렬 Wi이 곱해지고, 바이어스 벡터 bi가 추가된다. 네트워크 출력 o는 다음에 의해 주어진다:"}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "일부 실시예들에서, o는 타겟 출력 t와 비교되어, 최소화되는 것이 바람직한 오류 를 초래한다. 각각의 층에 대한 시냅틱 가중치 Wi를 수정함으로써 오류를 최소화하기 위해 경사 하강법 절차 형태의 최적화가 사용될 수 있다. 경사 하강법 절차는 입력 x가 알려진 타겟 출력 t에 대응하고 오류 ot를 생성한다는 것을 고 려하여, 출력 o의 컴퓨테이션을 요구한다. 그 후, 이 글로벌 오류는 역방향으로 전파되어 순방향 전파에 사용 된 것들과 유사하지만 정확히 동일하지는 않은 컴퓨테이션들에 의해 가중치 업데이트들에 대한 로컬 오류들을 제공한다. 특히, 역전파 단계는 통상적으로 형태의 활동 함수를 요구하며, 여기서 nj는 층 j 에서의 네트워크 활동이고(즉, 임), 여기서 이고 아포스트로피'는 활동 함수 f의 도함수를 나타낸다. 가중치 업데이트들은 다음 공식들을 통해 컴퓨팅될 수 있다."}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "여기서 는 하다마르(Hadamard) 곱(즉, 2개의 벡터들의 요소별 곱)을 나타내고 T는 행렬 전치를 나타내고 oj는 를 나타내며 이다. 여기에서 학습 레이트 η는 기계 학습 고려사항들과 관련하여 선택된다. 아래에서 η는 신경 구현에 사용되는 뉴럴 헤비안(Hebbian) 학습 메커니즘과 관련된다. 시냅스들 W 및 b 는 하나의 대형 시냅스 행렬로 결합될 수 있으며, 여기에서 입력 벡터에 추가된 것들이 있다고 가정하고 b 시냅 스들을 표현하는 추가 열들은 W에 포함된다는 것에 주의한다. AI/ML 모델은 그것이 양호한 레벨의 정확도에 도달할 때까지 다수의 에포크들(예컨대, 검출에 대해 F2 또는 F4 임계치를 사용하여 97% 이상 및 대략 2,000 에포크들)에 걸쳐 트레이닝된다. 이 정확도 레벨은 일부 실시예들 에서, F1 점수, F2 점수, F4 점수, 또는 본 발명의 범위를 벗어나지 않고 임의의 다른 적합한 기술을 사용하여 결정될 수 있다. 트레이닝 데이터에 대해 트레이닝되면, AI/ML 모델은 AI/ML 모델이 이전에 직면하지 못한 일 세트의 평가 데이터에 대해 테스트된다. 이는 AI/ML 모델이 트레이닝 데이터의 그래픽 요소들을 잘 식별하지만 다른 이미지들에 대해 잘 일반화되지 않도록 \"오버 피트(over fit)\"하지 않게 하는 데 도움이 된다. 일부 실시예들에서, 어떤 정확도 레벨이 달성될 수 있는지는 알려지지 않을 수 있다. 따라서 평가 데이터를 분 석할 때 AI/ML 모델의 정확도가 떨어지기 시작하는 경우(즉, 모델이 트레이닝 데이터에 대해 잘 수행되지만 평 가 데이터에 대해 덜 잘 수행되기 시작하는 경우), AI/ML은 모델은 트레이닝 데이터(및/또는 새로운 트레이닝 데이터)에 대해 더 많은 트레이닝 에포크들을 거칠 수 있다. 일부 실시예들에서, AI/ML 모델은 정확도가 특정 레벨에 도달하는 경우 또는 트레이닝된 AI/ML 모델의 정확도가 기존 전개된 AI/ML 모델보다 우수한 경우에만 전 개된다. 특정 실시예들에서, 트레이닝된 AI/ML 모델들의 집합은 관심의 그래픽 요소의 각각의 유형에 대해 AI/ML 모델을 사용하고, OCR을 수행하기 위해 AI/ML 모델을 사용하고, 그래픽 요소들 간의 근접 관계들을 인식하기 위해 또 다른 AI/ML 모델을 전개하고, 다른 AI/ML 모델들로부터의 출력들에 기초하여 RPA 워크플로우를 생성하기 위해 또 다른 AI/ML 모델을 사용하는 등과 같은 작업을 달성하기 위해 사용될 수 있다. 이는 집합적으로, 예컨대, AI/ML 모델들이 의미론적 자동화를 가능하게 하도록 허용한다. 일부 실시예들은 최첨단 문장, 텍스트 및 이미지 임베딩들을 위한 Python™ 프레임워크인 SentenceTransformers ™와 같은 트랜스포머 네트워크(transformer network)들을 사용할 수 있다. 이러한 트랜스포머 네트워크들은 높은 점수들 및 낮은 점수들 둘 모두를 갖는 단어들 및 구문들의 연관성들을 학습한다. 이는 무엇이 입력에 가 까운지 그리고 무엇이 가깝지 않은지를 각각 결정하기 위해 AI/ML 모델을 트레이닝한다. 단어들/구문들의 쌍들 을 사용하기 보다는, 트랜스포머 네트워크들은 필드 길이 및 필드 유형을 또한 사용할 수 있다. 도 8은 본 발명의 일 실시예에 따라, RPA 워크플로우를 위한 의미론적 AI를 이용한 소스 화면 또는 소스 데이터 와 타겟 화면 간의 의미론적 매칭을 수행하도록 AI/ML 모델(들)을 트레이닝하기 위한 프로세스를 예시하는 흐름도이다. 프로세스는 810에서, 레이블링된 화면들(예컨대, 식별된 그래픽 요소들 및 텍스트를 가짐), 단어 들 및 구문들, 주어진 단어 또는 구문에 대한 유사한 단어들 및 구문들이 식별될 수 있도록 단어들과 구문들 사 이의 의미론적 연관성의 \"시소러스(thesaurus)\" 등을 제공하는 것으로 시작된다. 그 후 AI/ML 모델은 820에서 다수의 에포크들에 걸쳐 트레이닝되고 결과들이 830에서 검토된다. AI/ML 모델이 840에서 원하는 신뢰도 임계치를 충족하지 못하는 경우, 850에서 AI/ML 모델이 그의 목적들을 더 잘 달성하는데 도움이 되도록 트레이닝 데이터가 보완되고 그리고/또는 보상 함수가 수정되고, 프로세스가 단계 로 리턴한다. AI/ML 모델이 840에서 신뢰도 임계치를 충족하는 경우, AI/ML 모델은 860에서, AI/ML 모델 이 잘 일반화되고 AI/ML 모델이 트레이닝 데이터에 대해 오버 피트하지 않도록 보장하기 위해 평가 데이터에 대 해 테스트된다. 평가 데이터는 AI/ML 모델이 이전에 프로세싱하지 않은 소스 화면들, 소스 데이터, 및 타겟 화 면들을 포함할 수 있다. 평가 데이터에 대한 신뢰도 임계치가 870에서 충족되는 경우, AI/ML 모델이 880에서 전개된다. 만약 그렇지 않다면, 프로세스는 단계로 리턴되고 AI/ML 모델이 추가로 트레이닝된다. 일부 실시예들은 개발자로부터 더 적거나 최소한의 상호작용 입력으로 완전히 자동화된 워크플로우를 생성하기 위해 의미론적 자동화를 자동화 플랫폼들에 가져온다. 의미론적 매핑을 사용하여, 데이터 소스/소스 화면으로 부터의 UI 필드들이 하나 이상의 AI/ML 모델들을 사용하여 의미론적으로 타겟 화면 상의 UI 필드들에 매핑되고 완전히 자동화된 워크플로우가 개발자에 의한 개입 없이 이 의미론적 매핑으로부터 생성될 수 있다. 현재 프로 토타입에서, UI 필드들 중 80%까지에 대해 매핑이 달성될 수 있으며, 개발자 보조로, 잔여 ~20%가 매핑될 수 있 다. AI/ML 모델(들)은 향후 매핑이 100% 정확도에 근접할 것이란 기대로, 시간이 지남에 따라 UI 필드들을 더 정확하게 매칭시키도록 학습시키기 위해 재트레이닝될 수 있다. 일부 실시예들에서, RPA 디자이너 애플리케이션은 RPA 개발자들이 2개의 화면들 사이에서 또는 데이터(예컨대, 고객 데이터)와 화면 사이에서 매칭을 수행하도록 허용하는 의미론적 매칭 특징을 포함한다. 이는 예컨대, 리본, 드롭다운 메뉴 또는 다른 적합한 사용자 인터페이스 요소에 관한 \"의미론적 AI\" 버튼으로서 구현될 수 있다. 의미론적 AI 기능성의 선택 시에, RPA 디자이너 애플리케이션은 도 9a-g의 매칭 인터페이스와 같은 매칭 인터페이스를 디스플레이할 수 있다. 이는 일반적인 예이지만, 인보이스를 SAP® 에 매핑하는 것, 엑셀 스프레드시트로부터의 데이터를 CRM 애플리케이션 내로 자동으로 입력하는 것, RPA 워크플로우로부터의 XAML을 다른 RPA 워크플로우에 매핑하는 것과 같이 본 발명의 실시예들에 의해 제공되는 의미론적 AI에 대한 다수의 사 용 사례들이 존재한다. 또한, 이 예는 텍스트 필드들로 구성되지만, 버튼들, 텍스트 영역들 등과 같은 다른 그 래픽 요소들이 본 발명의 범위를 벗어나지 않고 매핑될 수 있다. 매칭 인터페이스는 매핑 옵션 패인 및 매핑 패인을 포함한다. 개발자가 맵 화면 옵션을 선택할 때, 소스 선택 버튼 및 타겟 선택 버튼이 매핑 패인에 나타난다. 사용자는 뒤로 가기 버튼을 클릭함으로써 이전 디자이너 애플리케이션 화면으로 리턴할 수 있다. 사용자가 이들 버튼들 중 하 나를 클릭할 때, 사용자는 일부 실시예들에서 UiPath Studio™와 유사하거나 동일한 화면 상의 표시 기능성 (indicate on screen functionality)을 사용하여 소스 및 타겟을 선택할 수 있다. 예컨대, 미국 특허 출원 번 호 제17/100,146호를 참조한다. 이는 선택된 소스 화면 및 선택된 타겟 화면이 매핑 패인에 디 스플레이되게 한다. 소스 화면 및/또는 타겟 화면은 애플리케이션 윈도우들, 디스플레이된 애플리케 이션들의 일부들 등일 수 있다는 것이 주의되어야 한다. 사용자가 매핑 버튼을 클릭할 때, 디자이너 애플리케이션은 소스 화면 및 타겟 화면 상에서 OCR 및 CV를 수행하는 하나 이상의 AI/ML 모델들을 호출하고 소스 화면의 필드들을 타겟 화면의 필드들과 매칭시키도록 시도하는 의미론적 AI 분석을 실행하고, 신뢰도 임계치를 충족하거나 초과하는 신뢰도 점수와 매 칭을 디스플레이한다. 도 9b를 참조한다. 글로벌 신뢰도 점수가 또한 디스플레이된다. 매핑들은 일부 실시예들에서 동일하거나 유사한 화면들에 대한 향후 사용을 위해 오브젝트 저장소에 저장될 수 있다. 예컨대, 미국 특허 출원 번호 제16/922,289호를 참조한다. 이 예에서, 디자이너 애플리케이션은 AI/ML 모델(들)을 통해 소스 화면 및 타겟 화면의 필드들 대부 분을 올바르게 매칭시킬 수 있었다. 소스 화면의 통화(Currency) 필드가 빈 채로 남겨져 있었고, 이에 따 라 이 그래픽 요소에 대한 매칭이 시도되지 않았다. 그러나 회사(Company) 필드 및 인보이스(Invoice) # 필드 에 대한 매칭들이 발견되지 않았고 이는 상이한 컬러로 강조되고 0의 신뢰도 점수를 갖는 이러한 요소들을 디스 플레이함으로써 개발자에게 표시된다. 개발자는 AI/ML 모델(들)에 의해 매칭되지 않은 필드들을 수동으로 매칭시킬 수 있고, 사용자 매칭 정보는 일부 실시예들에서 AI/ML 모델(들)의 재트레이닝을 위해 레이블링된 트레이닝 데이터로서 자동으로 저장된다. 예컨 대, 소스 및 타겟 화면들은 경계 상자 정보(예컨대, 좌표들) 및 소스 화면 및 타겟 화면의 매칭된 필 드들과 연관된 레이블들의 좌표들 및 텍스트와 함께 저장될 수 있다. 이는 예컨대, 도 9c에서 볼 수 있으며, 여기서 소스 화면의 인보이스(Invoice) # 필드가 타겟 화면의 인보이스 번호(Inv. Num.) 필드와 매칭 한다고 사용자가 표시한다. 이는 그 요소에 대한 신뢰도 점수 및 글로벌 신뢰도 점수가 상응하게 증가되 게 한다. 일부 실시예들에서, 개발자는 타겟 필드 이름들에 대한 동의어들을 제공하도록 프롬프트되거나 그렇지 않으면 허용될 수 있다. 예컨대, 도 9c의 예에서, 동의어 텍스트 필드의 인보이스 번호(Inv. Num.) 필드에 대한 동의어들을 타이핑하도록 프롬프트되는데, 그 이유는 이 요소가 올바르게 식별되지 않았기 때문이다. 예컨대, 개발자는 \"인보이스 번호(Invoice Number)\", \"청구 번호(Billing Number)\" \"인보이스(Invoice) ID\", \"청구 (Billing) ID\" 등을 추가할 수 있다. 특정 실시예들에서, 개발자는 주어진 그래픽 요소가 올바르게 식별된 경 우에도 동의어들을 입력할 수 있다. 이 기능성은 또한 개발자들이 자체 용어들 및 콘텍스트를 추가하도록 허용 한다. 예컨대, 타겟 애플리케이션이 AI/ML 모델이 이전에 본 적이 없는 툴인 경우, 개발자는 그 툴에 대해 AI/ML 모델을 보다 정확하게 만들기 위해 용어들을 추가할 수 있다. 그 후 이 정보는 AI/ML 모델을 트레이닝하 는 데 사용될 수 있고, 이에 따라 AI/ML 모델은 그 툴뿐만 아니라 글로벌적으로 다른 타겟 화면들에서 발견되는 유사한 단어들 및 구문들에 대해 더 정확해진다. 특정 실시예들에서, 동의어들은 개발자에게 제안될 수 있다. 이들은 AI/ML 모델을 그 콘텍스트에 대해 더 정확 하게 만들기 위해 수락되거나 거부할 수 있다. 이는 AI/ML 모델이 긍정적인 예 및 부정적인 예 둘 모두를 학습 하도록 허용한다. 또한 이는 AI/ML 모델이 주어진 콘텍스트에 응용 가능한 동의어들의 상이한 서브세트들 또는 동의어들의 대안적인 세트들을 학습하도록 허용한다. 일부 실시예들에서, 이미지들 이외의 소스 데이터가 또한 사용될 수 있다. 예컨대, 개발자가 맵 데이터 옵션 을 선택하고 도 9d의 소스 선택 버튼을 클릭할 때, 데이터 소스 옵션들이 나타난다. 도 9e를 참조한다. 개발자는 Excel®, JavaScript® Object Notation(JSON), RPA 워크플로우의 XAML, CSV(comma separated variable) 파일 등과 같은 원하는 소스 데이터 포맷을 선택할 수 있다. 그 후 데이터 소스 및 타겟 이미지가 디스플레이된다. 개발자가 매핑 버튼을 클릭할 때, AI/ML 모델(들)은 소스 정보를 타겟 이미지의 필드들에 매칭시키려고 시도한다. 도 9f를 참조한다. 이 경우에, 소스 데이터는 소스 화면과 동일한 정보를 포함한다. 도 9g에서, 개발자는 도 9c에서의 수정과 유사 한 수정을 행하고, 글로벌 신뢰도 점수가 개선된다. 텍스트 필드들이 서로 유사하거나 동일할 수 있더라도, 주어진 텍스트 필드가 무엇을 표현하도록 의도되었는지 를 결정하기 위해 소스 화면과 타겟 화면의 레이블들 간의 관계들이 사용될 수 있다. 이는 주어진 텍스트 필드 에 하나 이상의 앵커들을 할당함으로써 달성될 수 있다. 예컨대, 시(City) 필드가 타겟 화면에서 그것과 연관된 텍스트 필드 바로 좌측에 나타나고 이 레이블을 포함하는 다른 텍스트 필드가 없기 때문에, 디자이너 애 플리케이션 및/또는 AI/ML 모델(들)은 이러한 필드들이 링크된 것으로 결정하고 시(City) 레이블을 타겟 텍스트 필드에 대한 앵커로서 할당할 수 있다. 레이블이 텍스트 필드를 고유하게 식별하지 않는 경우에, 하나 이상의 다른 그래픽 요소들이 앵커들로서 할당될 수 있고, 그의 기하학적 관계들이 주어진 타겟 요소를 고유하게 식별 하는데 사용될 수 있다. 예컨대, 미국 특허 번호 제10,936,351호 및 미국 특허 출원 번호 제17/100,146호를 참 조한다. 소스 화면 또는 소스 데이터 및 타겟 화면이 매핑된 후, 사용자는 생성(Create) 버튼을 클릭하여 원하는 매핑을 구현하는 RPA 워크플로우의 하나 이상의 활동들을 자동으로 생성할 수 있다. 도 9c 및 도 9g를 참조한 다. 이는 RPA 워크플로우 활동들이 자동으로 생성되게 한다. 일부 실시예들에서, RPA 워크플로우는 생성 후에 사용자가 원하는 매핑 작업을 수행하기 위해 즉시 실행된다. RPA 워크플로우를 자동으로 생성하기 위해, 디자이너 애플리케이션은 UI 오브젝트 저장소를 사용할 수 있다. 예컨대, 미국 특허 출원 공개 번호 제16/922,289호를 참조한다. UI 오브젝트 저장소(예컨대, UiPath Object Repository™)는, 자체가 (예컨대, 애플리케이션의 특정 버전 및 그의 하나 이상의 화면들에 대한) UI 디스크립 터들의 모음인 UI 오브젝트 라이브러리들의 모음이다. 유사한 그래픽 요소들에 대한 통합 타겟 제어들이 UI 오 브젝트 저장소로부터 획득될 수 있으며, 이는 주어진 그래픽 요소와 어떻게 상호작용할지를 RPA 로봇에 지시한 다. 이러한 예는 본 발명의 일 실시예에 따라 RPA 워크플로우에서 자동으로 생성된 활동들을 갖는 RPA 디자이 너 애플리케이션을 예시하는 도 10에서 도시된다. 의미론적 매칭 AI/ML 모델(들)은 위의 내용에 따라 소 스 화면 또는 소스 데이터와 타겟 화면 간의 연관성들을 인식하도록 트레이닝되었다. 도 9a 내지 도 9g 및 도 10의 예의 경우에, 의미론적 매칭 AI/ML 모델(들)은 소스 데이터 또는 소스 화면의 필드들로부터의 데이터가 타 겟 화면의 매칭 필드들 내로 카피되어야 한다고 결정할 수 있다. 따라서, RPA 디자이너 애플리케이션은 UI 오브젝트 저장소로부터 타겟 요소들에 대한 UI 디스크립터들을 획득하고, 타겟 화면을 클릭하는 활동들을 RPA 워크플로우에 추가하고, 각각의 타겟 필드를 클릭하고 이러한 UI 디스크립터들을 사용하여 소스 화면 또는 데이터 소스로부터의 텍스트를 타겟 화면의 개개의 매칭 필드들에 입력하는 것을 알고 있다. RPA 디자이 너 애플리케이션은 이 기능성을 구현하는 RPA 워크플로우의 하나 이상의 활동들을 자동으로 생성한 다. 일부 실시예들에서, 개발자는 이러한 활동들을 수정하는 것이 허용되지 않을 수 있다. 그러나 특정 실시 예들에서, 개발자는 활동들에 대한 구성들을 수정할 수 있고 활동들을 편집하는 것에 대한 완전한 허가들을 가 질 수 있는 등이 가능하다. 일부 실시예에서, RPA 디자이너 애플리케이션은 RPA 워크플로우를 구현하는 RPA 로 봇을 자동으로 생성하고 RPA 로봇을 실행하여 개발자로부터의 추가 지시 없이 소스 화면 또는 소스 데이터로부 터의 정보를 타겟 화면 내에 자동으로 카피한다. 일부 실시예들은 실질적인 프로그래밍 경험이 없는 개발자들이 의미론적 자동화를 수행하도록 허용하는 의미론 적 카피 및 페이스트 특징을 제공한다. 도 11a는 본 발명의 일 실시예에 따른 의미론적 카피 및 페이스트 인터 페이스를 예시한다. 일부 실시예들에서, 의미론적 카피 및 페이스트 인터페이스는 RPA 디자이너 애플리케이션의 일부이다. 그러나, 특정 실시예들에서, 의미론적 카피 및 페이스트 인터페이스는 자립형 애플리케이션의 일부이다. 의미론적 카피 및 페이스트 인터페이스는 데이터 추출 버튼, 데이터 입 력 버튼, 카피 및 페이스트 버튼, 추출된 데이터 보기 버튼, 및 닫기 버튼을 포함한다. 의미론적 카피 및 페이스트 인터페이스를 사용하여, 사용자는 데이터를 추출하거나 데이터를 입력하거나 소스 애플리케이션으로부터 타겟 애플리케이션으로 카피 및 페이스트를 수행할 수 있다. 데이터 추출 버튼의 클릭 시에, 디자이너 애플리케이션은 데이터 추출 인터페이스를 통해 데이터를 추출하고 싶은 애플리케이션을 열고 표시하도록 개발자에게 요청한다. 도 11b를 참조한다. 사용자가 데이터 추출 인터페이스의 애플리케이션 표시 버튼을 클릭할 때, 화면 상의 표시 기능성이 인에이블된다 (예컨대, UiPath Studio™에 의해 제공되는 것과 동일하거나 유사함). 그 후, 사용자는 데이터 소스로서 인보 이스를 선택할 수 있다. 소스(즉, 이 예에서 인보이스)로서 애플리케이션을 표시한 후, 의미론적 자동화 로직(즉, 의미론적 매칭 AI/ML 모델(들))은 분류 알고리즘을 사용하여 소스의 유형을 예측할 수 있고 데이터 추출 인터페이스는 드롭다운 메뉴에 소스의 유형에 관한 그의 예측을 디스플레이한다. 도 11c를 참조한다. 사용자는 확인 버튼을 사용하여 예측을 확인하거나 드롭다운 메뉴로부터 다른 유형을 선택할 수 있다. 도 11d를"}
{"patent_id": "10-2021-7043160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "참조한다. 추출된 데이터의 요약은 그 후 데이터 추출 인터페이스에 제공된다. 도 11e를 참조한 다. 사용자는 그 후 데이터 입력을 수행하기 위해 의미론적 카피 및 페이스트 인터페이스로 리턴하기 위 해 뒤로 가기 버튼을 선택할 수 있다. 데이터 입력 버튼의 선택 시에, 디자이너 애플리케이션은 데이터 입력 인터페이스를 통해 데이터를 추출하고 싶은 애플리케이션을 열고 표시하도록 개발자에게 요청한다. 도 11f를 참조한다. 사용자가 데이터 입력 인터페이스의 애플리케이션 표시 버튼을 클릭할 때, 화면 상의 표시 기능성이 인에이블된다. 그 후 사용자는 타겟 애플리케이션으로서 웹 인보이스 프로세싱 페이지를 선택할 수 있다. 타겟으로서 웹 인보이스 프로세싱 페이지를 표시한 후, 의미론적 자동화 로직은 분류 알고리즘을 사용하 여 타겟의 유형을 예측할 수 있고, 데이터 입력 인터페이스는 드롭다운 메뉴에 타겟의 유형에 관한 그의 예측을 디스플레이한다. 도 11g를 참조한다. 사용자는 확인 버튼을 사용하여 예측을 확인하거나 드롭다운 메뉴로부터 다른 유형을 선택할 수 있다. 도 11h를 참조한다. 사용자에 의한 확인 후, 디자이 너 애플리케이션은 추출된 데이터를 사용하여 웹 브라우저를 자동으로 채운다. 도 11i를 참조한다. 사용자들은 또한 카피 및 페이스트 버튼을 사용하여 데이터를 \"카피 및 페이스트\"할 수 있다. 카피 및 페이스트 버튼의 클릭 시에, 디자이너 애플리케이션은 카피 및 페이스트 인터페이스를 통해 데이터 를 입력하고 싶은 애플리케이션을 열고 표시하도록 개발자에게 요청한다. 도 11j를 참조한다. 사용자가 카피 및 페이스트 인터페이스의 애플리케이션 표시 버튼을 클릭할 때, 화면 상의 표시 기능성이 인에이 블된다. 그 후 사용자는 타겟 애플리케이션으로서 라인 아이템 엔트리 페이지를 선택할 수 있다. 타겟으로서 라인 아이템 엔트리 페이지를 표시한 후, 의미론적 자동화 로직은 분류 알고리즘을 사용하여 타겟의 유형을 예측할 수 있고, 카피 및 페이스트 인터페이스는 드롭다운 메뉴에 타겟의 유형에 관 한 그의 예측을 디스플레이한다. 도 11k를 참조한다. 사용자는 확인 버튼을 사용하여 예측을 확인하거 나 드롭다운 메뉴로부터 다른 유형을 선택할 수 있다. 도 11l를 참조한다. 사용자는 또한 스프레드시트 와 같은 가능한 후보(potential)의 리스트로부터 선택할 수 있다. 사용자에 의한 확인 후 디자이너 애플 리케이션은 스프레드시트로부터 라인 아이템 엔트리 페이지 내로 데이터를 자동으로 카피한다. 도 11m를 참조한다. 일부 실시예들에서, 디자이너 애플리케이션은 카피 및 페이스트 인터페이스를 통해, 주어진 라인 아이템 을 타겟 애플리케이션에 입력하기 전에 사용자에게 프롬프트할 수 있다. 이러한 예는 도 11n에서 도시되며, 여 기서 사용자는 각각의 행이 라인 아이템 입력 페이지에 입력되기 전에 그 각각의 행을 검토 및 승인한다. 카피 및 페이스트 인터페이스는 스프레드시트의 다음 행으로부터 입력될 데이터의 미리보기 를 보여준다. 사용자가 행 확인 버튼을 클릭할 때, 디자이너 애플리케이션은 미리보기에 보여진 라인을 라인 아이템 입력 페이지의 대응하는 필드들 내로 입력한다. 도 12는 본 발명의 일 실시예에 따라, 의미론적 AI를 수행하기 위한 AI/ML 모델들의 아키텍처를 예시하는 아키텍처 다이어그램이다. CV 모델은 컴퓨터 비전 기능성을 수행하여 화면에서 그래픽 요소들을 식별하 고 OCR 모델은 화면(들)에 대한 텍스트 검출 및 인식을 수행한다. 소스 화면 및 타겟 화면 둘 모두가 사 용되는 실시예들에서, CV 모델 및 OCR 모델은 양 화면들 상에서 CV 및 OCR 기능성을 수행한다. 그 후 CV 모델 및 OCR 모델은 OCR 모델의 레이블을 CV 모델의 그래픽 요소들과 매칭 시키는 레이블 매칭 모델에, 타겟 화면 또는 타겟 및 소스 화면 둘 모두에서 검출된 그래픽 요소들 및 텍 스트의 유형들, 로케이션들, 크기들, 텍스트 등을 제공한다. 그 후, 화면(들)으로부터의 매칭 레이블들 및 연 관된 그래픽 요소들은 데이터 소스 또는 소스 화면으로부터의 입력 데이터를 타겟 화면의 그래픽 요소들의 레이블들과 매칭시키는 입력 데이터 매칭 모델에 전달된다. 그 후, 매칭들 및 개개의 신뢰도들은 입력 데이 터 매칭 모델로부터의 출력으로서 제공된다. 일부 실시예들에서, 다수의 AI/ML 모델들은 상이한 방식들 로(예컨대, 이들은 상이한 신경망 아키텍처들을 갖고, 상이한 전략들을 사용하고, 상이한 트레이닝 데이터에 대 해 트레이닝되는 등) 매칭을 수행하는 입력 데이터 매칭을 위해 사용될 수 있다. 일부 실시예들에서, AI/ML 모델(들)은 동일한 레이블들을 가진 필드들이 상이한 콘텍스트를 가질 수 있음을 학 습할 수 있다. 예컨대, 화면의 청구 정보와 배송 정보 섹션 둘 모두는 \"Address\" 레이블을 가질 수 있지만 AI/ML 모델은 하나 근처에 있는 요소들의 패턴이 다른 요소 근처의 것들과 상이하다는 것을 학습할 수 있다. 그 후, 이러한 화면의 섹션들은 텍스트 필드가 타겟이고 \"Address\" 레이블 및 인식된 패턴을 갖는 섹션이 앵커 들인 다중-앵커 기술에서 앵커들로서 사용될 수 있다. 예컨대, 미국 특허 번호 제10,936,351호 및 미국 특허 출원 번호 제17/100,146호를 참조한다. 도 13은 본 발명의 일 실시예에 따라, RPA 워크플로우를 위한 의미론적 AI를 이용한 소스 화면 또는 소스 데이 터와 타겟 화면 간의 의미론적 매칭을 수행하기 위한 프로세스를 예시하는 흐름도이다. 프로세스는 1305 에서 소스 화면 또는 소스 데이터의 선택을 수신하고 1310에서 타겟 화면의 선택을 수신하는 것으로 시작한다. 그 후, 소스 화면의 레이블들과 타겟 화면의 레이블들 사이에서, 소스 데이터의 데이터 요소들과 타겟 화면의 레이블들 사이에서 또는 둘 모두에서 의미론적 매칭을 수행하도록 트레이닝된 하나 이상의 AI/ML 모델들이 1315 에서 호출된다. 일부 실시예들에서, 하나 이상의 AI/ML 모델들은, 주어진 단어 또는 구문에 대한 유사 단어들 및 구문들이 식별될 수 있도록 단어들 및 구문들 사이의 의미론적 연관들을 갖는 단어들 및 구문들을 제공하고 단어들 및 구문들이 나타나는 화면과 관련된 콘텍스트 레이블들을 제공함으로써 트레이닝된다. 일부 실시예들 에서, 하나 이상의 AI/ML 모델은 CV 모델, OCR 모델, 레이블 매칭 모델, 및 입력 데이터 매칭 모델을 포함하고, 여기서 레이블 매칭 모델은 OCR 모델에 의해 검출된 레이블들을 CV 모델에 의해 검출된 필드들과 매칭시키고 입 력 데이터 모델은 레이블 매칭 모델로부터 매칭 레이블들을 수신하고 데이터 소스로부터의 데이터 요소들 또는 소스 화면으로부터의 레이블들과 연관된 필드들로부터의 데이터를 타겟 화면 상의 의미론적으로 매칭되는 레이 블들과 연관된 필드들과 의미론적으로 매칭시킨다. 하나 이상의 AI/ML 모델들로부터 타겟 화면의 의미론적으로 매칭되는 레이블들(예컨대, 로케이션, 좌표들, 유형 등)과 연관된 그래픽 요소들의 표시들 및 개개의 신뢰도 점수들이 1320에서 수신된다. 의미론적으로 매칭되는 레이블들, 개별 신뢰도 점수들 및 글로벌 신뢰도 점수와 연관된 그래픽 요소들이 1325에서 매칭 인터페이스의 타겟 화면 상에 디스플레이된다. 예컨대, 타겟 화면이 보여지고 매칭 요소들이 강조되거나, 또는 다른 방식으 로 개발자에게 명확해질 수 있다. 일부 실시예들에서, 연결들은 소스 화면 또는 소스 데이터의 매칭 필드들과 타겟 화면 사이에서 그려진다. 특정 실시예들에서, 어떠한 매칭도 발견되지 않은 소스 화면 또는 소스 데이터 의 요소들이 강조되거나, 또는 다른 방식으로 개발자에게 표시된다. 연관된 의미론적으로 매칭되는 레이블을 갖는 것으로서 하나 이상의 AI/ML 모델들에 의해 식별된 타겟 화면의 그래픽 요소에 대한 정정(들), 하나 이상의 AI/ML 모델들에 의해 소스 화면의 레이블과 의미론적으로 매칭되지 않는 타겟 화면의 새로운 요소의 표시 또는 둘 모두가 1330에서 수신된다. 타겟 화면의 수정된 그리고/또는 새 롭게 레이블링된 그래픽 요소(들) 및 연관된 레이블에 관한 정보는 1335에서 직접(즉, 컴퓨팅 시스템 메모리에 직접 저장됨) 또는 간접적으로(즉, 저장을 위해 외부 시스템에 전송됨) 수집 및 저장된다. 이러한 수정들이 개 발자에 의해 제공되는 경우, 단계들(1330 및 1335)이 수행된다. 하나 이상의 AI/ML 모델들이 타겟 화면의 필드들과 의미론적으로 매칭되는 것으로 식별한 레이블들을 갖는 소스 화면의 필드들로부터의 데이터를 카피하고, 소스 데이터로부터의 데이터 요소들을, 하나 이상의 AI/ML 모델들이 소스 데이터로부터의 데이터 요소들과 의미론적으로 매칭되는 것으로 식별한 레이블들을 갖는 타겟 화면의 필드 들 내로 카피하거나, 또는 둘 모두를 행하는 RPA 워크플로우의 하나 이상의 활동들이 1340에서 자동으로 생성된 다. RPA 워크플로우에서 하나 이상의 생성된 활동들을 구현하는 RPA 로봇은 1345에서 생성 및 전개된다. 런타임에서, 전개된 RPA 로봇은 UI 오브젝트 저장소의 RPA 워크플로우에 따라 자동화를 수행하기 위해 그것이 식별하고자 하는 그래픽 요소들에 대한 UI 디스크립터들에 액세스하고 이러한 UI 디스크립터들을 사용하여 타겟 화면에서 그래픽 요소들을 식별하려고 시도한다. 모든 타겟 그래픽 요소들이 1355에서 식별될 수 있는 경우, 정보가 1360에서 소스 화면 또는 데이터 소스로부터 타겟 화면으로 카피된다. 그러나 1355에서 모든 그래픽 요 소들을 찾을 순 없는 경우, RPA 로봇은 1365에서 AI/ML 모델(들)을 호출하여 누락 그래픽 요소(들)를 식별하고 이들 개개의 그래픽 요소들에 대한 UI 디스크립터들을 업데이트한다. 예컨대, RPA 로봇은 AI/ML 모델(들)에 의 해 제공되는 디스크립터 정보를 사용하여 UI 오브젝트 저장소의 누락 요소들에 대한 개개의 UI 디스크립터들을업데이트하고, 이에 따라 다른 RPA 로봇들이 향후에 동일한 이슈에 직면하지 않을 것이다. 이러한 의미에서, 시스템은 자가-치유적이다. 도 14는 본 발명의 일 실시예에 따라, 유인 자동화 인터페이스를 사용하기 위해 의미론적 AI를 이용한 소스 화 면 또는 소스 데이터와 타겟 화면 간의 의미론적 매칭을 수행하기 위한 프로세스를 예시하는 흐름도이다. 프로세스는 1405에서 의미론적 카피 및 페이스트 인터페이스를 제공하는 것으로 시작된다. 데이터는 1410에서 소스 애플리케이션 또는 데이터 소스로부터 추출된다. 소스의 유형은 1415에서 분류 알고리즘을 사용하여 예측 된다. 일부 실시예들에서, 의미론적 카피 및 페이스트 애플리케이션은 1420에서 사용자에 의한 예측에 대한 변 경 또는 예측의 확인을 수신하기를 기다린다. 사용자가 데이터를 추출하기를 원하는 타겟 애플리케이션의 표시가 1425에서 수신된다. 타겟의 유형은 1430에 서 분류 알고리즘을 사용하여 예측된다. 일부 실시예들에서, 의미론적 카피 및 페이스트 애플리케이션은 1435 에서 사용자에 의한 예측에 대한 변경 또는 예측의 확인을 수신하기를 기다린다. 일부 실시예들에서, 사용자에게는 1440에서 각각의 데이터 엔트리 전에 프롬프트된다. 예컨대, 주어진 데이터 아이템(예컨대, 데이터의 라인, 개별 그래픽 요소 등)을 입력하기 전에, 사용자는 입력될 데이터가 타겟 애플리 케이션에 나타나는 것을 볼 수 있다. 그 후, 사용자는 엔트리를 미리보고 승인하거나 거부할 수 있다. 소스로 부터의 데이터는 그 후 1445에서 타겟 애플리케이션 내로 입력된다. 본 발명의 실시예들에 따라 프로세서(들)가 도 13 및 도 14에서 설명된 프로세스(들)의 적어도 일부를 수행하기 위한 명령들을 인코딩하는, 도 13 및 도 14에서 수행되는 프로세스 단계들은 컴퓨터 프로그램에 의해 수행될 수 있다. 컴퓨터 프로그램은 비-일시적 컴퓨터-판독 가능 매체 상에서 구체화될 수 있다. 컴퓨터-판독 가능 매체 는 하드 디스크 드라이브, 플래시 디바이스, RAM, 테이프, 및/또는 데이터를 저장하는 데 사용되는 임의의 다른 이러한 매체 또는 매체들의 조합일 수 있다(그러나 이에 제한되지 않음). 컴퓨터 프로그램은, 컴퓨터-판독 가 능 매체 상에 또한 저장될 수 있는 도 13 및 도 14에 설명된 프로세스 단계들 전부 또는 그의 일부를 구현하기 위해 컴퓨팅 시스템의 프로세서(들)(예컨대, 도 5의 컴퓨팅 시스템의 프로세서(들))를 제어하기 위한 인코딩된 명령들을 포함할 수 있다. 컴퓨터 프로그램은 하드웨어, 소프트웨어 또는 하이브리드 구현으로 구현될 수 있다. 컴퓨터 프로그램은 디스 플레이할 정보 또는 명령들을 전달하도록 설계되고 서로 동작 가능하게 통신하는 모듈들로 구성될 수 있다. 컴 퓨터 프로그램은 범용 컴퓨터, ASIC 또는 임의의 다른 적합한 디바이스에서 동작하도록 구성될 수 있다. 본원의 도면들에서 일반적으로 설명되고 예시되는 바와 같은 본 발명의 다양한 실시예들의 구성요소들은, 광범 위하게 다양한 상이한 구성들로 배열 및 설계될 수 있다는 것이 용이하게 이해될 것이다. 따라서, 첨부된 도면 들에서 표현된 바와 같은 본 발명의 실시예들의 상세한 설명은 청구된 바와 같은 본 발명의 범위를 제한하는 것으로 의도되는 것이 아니라, 단지 본 발명의 선택된 실시예들을 대표할 뿐이다. 본 명세서 전반에 걸쳐 설명되는 본 발명의 특징들, 구조들, 또는 특성들은 하나 이상의 실시예들에서 임의의 적합한 방식으로 결합될 수 있다. 예컨대, 본 명세서 전반에 걸친 \"특정 실시예들\", \"일부 실시예들\", 또는 유 사한 언어에 대한 참조는 실시예와 관련하여 설명된 특정 특징, 구조 또는 특성이 본 발명의 적어도 하나의 실 시예에 포함된다는 것을 의미한다. 따라서, 본 명세서 전반에 걸쳐 문구들 \"특정 실시예들에서\", \"일부 실시예 에서\", \"다른 실시예들에서\", 또는 유사한 언어의 출현들 전부가 반드시 동일한 그룹의 실시예들을 지칭하는 것 은 아니며, 설명된 특징들, 구조들, 또는 특성들은 하나 이상의 실시예들에서 임의의 적합한 방식으로 결합될 수 있다. 본 명세서 전반에 걸친 특징들, 이점들 또는 유사한 언어에 대한 참조는 본 발명으로 실현될 수 있는 모든 특징 들 및 이점들이 본 발명의 어느 하나의 실시예이어야 한다는 것 또는 어느 하나의 실시예에 있다는 것을 암시하 지 않는다는 것이 주의되어야 한다. 오히려, 특징들 및 이점들을 참조하는 언어는 실시예와 관련하여 설명된 특정 특징, 이점 또는 특성이 본 발명의 적어도 하나의 실시예에 포함된다는 것을 의미하는 것으로 이해된다. 따라서, 본 명세서 전반에 걸친 특징들, 및 이점들, 및 유사한 언어에 대한 논의는 동일한 실시예를 참조할 수 있지만 반드시 그런 것은 아니다. 추가로, 본 발명의 설명된 특징들, 이점들, 및 특성들이 하나 이상의 실시예들에서 임의의 적합한 방식으로 결 합될 수 있다. 당업자는, 특정 실시예의 특정 특징들 또는 이점들 중 하나 이상 없이도 본 발명이 실시될 수 있음을 인지할 것이다. 다른 경우들에서, 본 발명의 모든 실시예들에 존재하지 않을 수 있는 부가적인 특징들 및 이점들이 특정 실시예들에서 인지될 수 있다. 당업자는, 위에 논의된 본 발명이 개시된 것과 상이한 구성들의 하드웨어 요소들로 그리고/또는 상이한 순서의 단계들로 실시될 수 있음을 용이하게 이해할 것이다. 따라서, 본 발명이 이들 바람직한 실시예들에 기초하여 설명되었지만, 본 발명의 사상 및 범위 내에 유지되면서 특정한 수정들, 변형들, 및 대안적인 구조들이 명백할 것임이 당업자들에게 명백할 것이다. 따라서, 본 발명의 범위(mete)들 및 경계들을 결정하기 위해 첨부된 청구 항들에 대한 참조가 이루어져야 한다."}
{"patent_id": "10-2021-7043160", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 발명의 특정 실시예들이 쉽게 이해되도록 하기 위해, 위에서 간략하게 설명한 본 발명들의 보다 구체적 설명 이 첨부 도면들에서 예시되는 특정 실시예들을 참조하여 제공될 것이다. 이들 도면들은 단지 본 발명의 통상적 인 실시예들을 도시할 뿐이며, 이에 따라 본 발명의 범위의 제한인 것으로 간주되지 않는다는 것이 이해되어야 하는 반면, 본 발명은 첨부된 도면들의 사용을 통해 부가적인 특이성 및 세부사항에 관해 설명되고 기술될 것이다. 도 1은 본 출원의 일 실시예에 따라 RPA 시스템을 예시하는 아키텍처 다이어그램이다. 도 2는 본 발명의 일 실시예에 따라, 전개된 RPA 시스템을 예시하는 아키텍처 다이어그램이다. 도 3은 본 발명의 일 실시예에 따라, 디자이너, 활동들, 드라이버들 간의 관계를 예시하는 아키텍처 다이어그램 이다. 도 4는 본 출원의 일 실시예에 따라 RPA 시스템을 예시하는 아키텍처 다이어그램이다. 도 5는 본 발명의 일 실시예에 따라, RPA 워크플로우를 위한 의미론적 AI를 이용한 소스 화면 또는 소스 데이터 와 타겟 화면 간의 의미론적 매칭을 수행하도록 구성된 컴퓨팅 시스템을 예시하는 아키텍처 다이어그램이다. 도 6은 본 발명의 일 실시예에 따라, 인공 지능/기계 학습(AI/ML) 모델들을 트레이닝하고 RPA 워크플로우들을 의미론적 AI를 사용하여 소스 화면 또는 소스 데이터와 타겟 화면 간의 의미론적 매칭을 수행하도록 구성된 시 스템을 예시하는 아키텍처 다이어그램이다. 도 7a는 본 발명의 일 실시예에 따라, 이미지의 그래픽 요소들을 인식하도록 트레이닝된 신경망의 예를 예시한 다. 도 7b는 본 발명의 일 실시예에 따라 뉴런의 예를 예시한다. 도 8은 본 발명의 일 실시예에 따라, RPA 워크플로우를 위한 의미론적 AI를 이용한 소스 화면 또는 소스 데이터 와 타겟 화면 간의 의미론적 매칭을 수행하도록 AI/ML 모델(들)을 트레이닝하기 위한 프로세스를 예시하는 흐름 도이다. 도 9a 내지 도 9g는 본 발명의 일 실시예에 따라, RPA 디자이너 애플리케이션을 위한 매칭 인터페이스를 예시한 다. 도 10은 본 발명의 일 실시예에 따라, 자동으로 생성된 RPA 워크플로우를 갖는 RPA 디자이너 애플리케이션을 예 시한다. 도 11a 내지 도 11n은 본 발명의 일 실시예에 따라, 예시적인 의미론적 카피 및 페이스트 인터페이스의 화면들 을 예시한다. 도 12는 본 발명의 일 실시예에 따라, 의미론적 AI를 수행하기 위한 AI/ML 모델들의 아키텍처를 예시하는 아키 텍처 다이어그램이다. 도 13은 본 발명의 일 실시예에 따라, RPA 워크플로우를 위한 의미론적 AI를 이용한 소스 화면 또는 소스 데이터와 타겟 화면 간의 의미론적 매칭을 수행하기 위한 프로세스를 예시하는 흐름도이다. 도 14는 본 발명의 일 실시예에 따라, 유인 자동화 인터페이스(attended automation interface)를 사용하기 위 해 의미론적 AI를 이용한 소스 화면 또는 소스 데이터와 타겟 화면 간의 의미론적 매칭을 수행하기 위한 프로세 스를 예시하는 흐름도이다. 달리 표시되지 않는 한, 유사한 참조 문자들은 첨부된 도면들 전반에 걸쳐 일관되게 대응하는 특징들을 나타낸 다."}
