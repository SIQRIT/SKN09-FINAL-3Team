{"patent_id": "10-2020-7025531", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2020-0106558", "출원번호": "10-2020-7025531", "발명의 명칭": "인간 운영자로의 에스컬레이션", "출원인": "구글 엘엘씨", "발명자": "시걸리스 이엘"}}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨터로 구현되는 방법으로서, 컴퓨팅 디바이스의 봇과 인간들 사이에서 전화 대화들을 수행하도록 구성된 상기 컴퓨팅 디바이스에 의해, 인간으로부터의 전화 통화를 수신하는 단계;상기 컴퓨팅 디바이스에 의해, 구조화되지 않은 대화(unstructured dialog)를 인간으로부터 수신하는 단계;상기 컴퓨팅 디바이스에 의해, 상기 구조화되지 않은 대화의 전사(transcription)를 생성하는 단계;상기 구조화되지 않은 대화의 전사에 기초하여, 상기 컴퓨팅 디바이스의 봇에 의해, 상기 인간의 의도를 결정하는 단계; 및 상기 인간의 의도에 기초하여, 상기 컴퓨팅 디바이스의 봇에 의해, 음성 응답(spoken response)을 생성하는 단계를 포함하는 것을 특징으로 하는 컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 컴퓨팅 디바이스에 의해, 상기 구조화되지 않은 대화와 관련된 데이터에 액세스하는 단계를 더 포함하고, 상기 음성 응답은 상기 구조화되지 않은 대화와 관련된 데이터에 기초하는 것을 특징으로 하는 컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 구조화되지 않은 대화와 관련된 데이터는, 상기 컴퓨팅 디바이스의 사용자에 대한 칼렌다 데이터인 것을특징으로 하는 컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서,상기 구조화되지 않은 대화와 관련된 데이터는, 상기 봇이 작업을 수행하기 위한, 상기 컴퓨팅 디바이스의 사용자에 의한 요청인 것을 특징으로 하는 컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서, 상기 음성 응답을 생성하는 단계는, 상기 인간의 의도에 기초하여, 상기 컴퓨팅 디바이스에 의해, 상기 음성 응답에 대한 추가적인 전사를 생성하는단계; 및 상기 컴퓨팅 디바이스에 의해, 상기 음성 응답에 대한 추가적인 전사를 스피치 합성기에 제공하는 단계를 더 포함하는 것을 특징으로 하는 컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,공개특허 10-2020-0106558-3-상기 컴퓨팅 디바이스에 의해, 인간으로부터 추가적인 구조화되지 않은 대화를 수신하는 단계;상기 컴퓨팅 디바이스에 의해, 상기 추가적인 구조화되지 않은 대화에 대한 추가적인 전사를 생성하는 단계; 및 상기 추가적인 전사에 기초하여, 상기 컴퓨팅 디바이스의 봇에 의해, 추가적인 음성 응답을 생성하는 단계를 더포함하는 것을 특징으로 하는 컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 컴퓨팅 디바이스에 의한 출력을 위해, 상기 인간으로부터의 구조화되지 않은 대화의 요약 및 상기 음성 응답을 나타내는 데이터를 제공하는 단계를 더 포함하는 것을 특징으로 하는 컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "시스템으로서, 하나 이상의 컴퓨터들 및 명령들을 저장하는 하나 이상의 저장 디바이스들을 포함하고, 상기 명령들은 상기 하나 이상의 컴퓨터들에 의해 실행될 때, 상기 하나 이상의 컴퓨터들로 하여금, 동작들을 수행하게 하며, 상기 동작들은, 컴퓨팅 디바이스의 봇과 인간들 사이에서 전화 대화들을 수행하도록 구성된 상기 컴퓨팅 디바이스에 의해, 인간으로부터의 전화 통화를 수신하게 하고;상기 컴퓨팅 디바이스에 의해, 구조화되지 않은 대화를 인간으로부터 수신하게 하고;상기 컴퓨팅 디바이스에 의해, 상기 구조화되지 않은 대화의 전사를 생성하게 하고;상기 구조화되지 않은 대화의 전사에 기초하여, 상기 컴퓨팅 디바이스의 봇에 의해, 상기 인간의 의도를 결정하게 하고; 그리고 상기 인간의 의도에 기초하여, 상기 컴퓨팅 디바이스의 봇에 의해, 음성 응답(spoken response)을 생성하게 하는 동작들을 포함하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서, 상기 동작들은 또한, 상기 컴퓨팅 디바이스에 의해, 상기 구조화되지 않은 대화와 관련된 데이터에 액세스하게 하는 동작을 더 포함하고, 상기 음성 응답은 상기 구조화되지 않은 대화와 관련된 데이터에 기초하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 구조화되지 않은 대화와 관련된 데이터는, 상기 컴퓨팅 디바이스의 사용자에 대한 칼렌다 데이터인 것을특징으로 하는 시스템."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제9항에 있어서, 상기 구조화되지 않은 대화와 관련된 데이터는, 상기 봇이 작업을 수행하기 위한, 상기 컴퓨팅 디바이스의 사용자에 의한 요청인 것을 특징으로 하는 시스템."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제8항에 있어서, 공개특허 10-2020-0106558-4-상기 음성 응답을 생성하게 하는 동작은, 상기 인간의 의도에 기초하여, 상기 컴퓨팅 디바이스에 의해, 상기 음성 응답에 대한 추가적인 전사를 생성하게하고; 그리고 상기 컴퓨팅 디바이스에 의해, 상기 음성 응답에 대한 추가적인 전사를 스피치 합성기에 제공하게 하는 동작을더 포함하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제8항에 있어서, 상기 동작들은 또한, 상기 컴퓨팅 디바이스에 의해, 인간으로부터 추가적인 구조화되지 않은 대화를 수신하게 하고;상기 컴퓨팅 디바이스에 의해, 상기 추가적인 구조화되지 않은 대화에 대한 추가적인 전사를 생성하게 하고; 그리고 상기 추가적인 전사에 기초하여, 상기 컴퓨팅 디바이스의 봇에 의해, 추가적인 음성 응답을 생성하게 하는 동작을 더 포함하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제8항에 있어서, 상기 동작들은 또한, 상기 컴퓨팅 디바이스에 의한 출력을 위해, 상기 인간으로부터의 구조화되지 않은 대화의 요약 및 상기 음성 응답을 나타내는 데이터를 제공하게 하는 동작을 더 포함하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "소프트웨어를 저장하는 비일시적 컴퓨터 판독가능 매체로서, 상기 소프트웨어는 명령들을 포함하고, 상기 명령들은 하나 이상의 컴퓨터들에 의해 실행될 때 상기 하나 이상의 컴퓨터들로 하여금 동작들을 수행하게 하며, 상기 동작들은, 컴퓨팅 디바이스의 봇과 인간들 사이에서 전화 대화들을 수행하도록 구성된 상기 컴퓨팅 디바이스에 의해, 인간으로부터의 전화 통화를 수신하게 하고;상기 컴퓨팅 디바이스에 의해, 구조화되지 않은 대화를 인간으로부터 수신하게 하고;상기 컴퓨팅 디바이스에 의해, 상기 구조화되지 않은 대화의 전사를 생성하게 하고;상기 구조화되지 않은 대화의 전사에 기초하여, 상기 컴퓨팅 디바이스의 봇에 의해, 상기 인간의 의도를 결정하게 하고; 그리고 상기 인간의 의도에 기초하여, 상기 컴퓨팅 디바이스의 봇에 의해, 음성 응답(spoken response)을 생성하게 하는 동작들을 포함하는 것을 특징으로 하는 비일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서, 상기 동작들은 또한, 상기 컴퓨팅 디바이스에 의해, 상기 구조화되지 않은 대화와 관련된 데이터에 액세스하게 하는 동작을 더 포함하고, 상기 음성 응답은 상기 구조화되지 않은 대화와 관련된 데이터에 기초하는 것을 특징으로 하는 비일시적 컴퓨터판독가능 매체."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "공개특허 10-2020-0106558-5-제16항에 있어서, 상기 구조화되지 않은 대화와 관련된 데이터는, 상기 봇이 작업을 수행하기 위한, 상기 컴퓨팅 디바이스의 사용자에 의한 요청인 것을 특징으로 하는 비일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제15항에 있어서, 상기 음성 응답을 생성하게 하는 동작은, 상기 인간의 의도에 기초하여, 상기 컴퓨팅 디바이스에 의해, 상기 음성 응답에 대한 추가적인 전사를 생성하게하고; 그리고 상기 컴퓨팅 디바이스에 의해, 상기 음성 응답에 대한 추가적인 전사를 스피치 합성기에 제공하게 하는 동작을더 포함하는 것을 특징으로 하는 비일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제15항에 있어서, 상기 동작들은 또한, 상기 컴퓨팅 디바이스에 의해, 인간으로부터 추가적인 구조화되지 않은 대화를 수신하게 하고;상기 컴퓨팅 디바이스에 의해, 상기 추가적인 구조화되지 않은 대화에 대한 추가적인 전사를 생성하게 하고; 그리고 상기 추가적인 전사에 기초하여, 상기 컴퓨팅 디바이스의 봇에 의해, 추가적인 음성 응답을 생성하게 하는 동작을 더 포함하는 것을 특징으로 하는 비일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2020-7025531", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제15항에 있어서, 상기 동작들은 또한, 상기 컴퓨팅 디바이스에 의한 출력을 위해, 상기 인간으로부터의 구조화되지 않은 대화의 요약 및 상기 음성 응답을 나타내는 데이터를 제공하게 하는 동작을 더 포함하는 것을 특징으로 하는 비일시적 컴퓨터 판독가능매체."}
{"patent_id": "10-2020-7025531", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "인공 호출 개시(synthetic call initiations) 및 긴급 구제(bailouts)와 관련된, 컴퓨터 저장매체 상에 인코딩 된 컴퓨터 프로그램을 포함하는 방법들, 시스템들 및 장치가 제공된다. 일부 구현예에서, 본 발명의 방법은, 호 출 개시 시스템에 의해서, 상기 전화 호출의 제 1 측 상의 제 1 인간과 상기 전화 호출의 제 2 측 상의 상기 봇 사이의 전화 호출 동안, 상기 제 1 인간과 상기 봇 사이의 실시간 대화를 분석하는 단계를 포함한다. 호출 개시 시스템은, 상기 실시간 대화에 대한 분석에 기초하여, 상기 전화 호출이 상기 봇으로부터 상기 전화 호출의 제 2 측 상의 제 2 인간으로 전환되어야 하는지를 결정할 수 있다. 상기 전화 호출이 상기 전화 호출의 제 2 측 상의 제 2 인간으로 전환되어야 한다고 결정함에 응답하여, 호출 개시 시스템은 상기 전화 호출을 상기 봇으로부터 상 기 제 2 인간으로 전환할 수 있다."}
{"patent_id": "10-2020-7025531", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 자연 언어 프로세싱(natural language processing)에 관한 것이다."}
{"patent_id": "10-2020-7025531", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "사용자들은 인간의 상호작용 없이는 용이하게 획득할 수 없는 종류의 정보를 수집할 필요가 있다. 예를 들어, 여러 곳의 사업체(이하, '비즈니스' 또는 '사업체'이라 함)들 또는 조직들로부터 데이터를 확인하거나 수집하기 위하여, 사용자는 정보를 모으기 위해 각각의 사업체들 또는 조직들에 전화를 해야할 필요가 있을 수 있다. 웹 검색 엔진은 서비스 또는 사업체에 대한 연락처 정보를 제공하여 이러한 작업을 수행하는 사용자를 지원할 수 있지만, 이러한 작업을 완료하기 위해서 사용자는 계속해서 서비스 또는 사업체에 직접 전화를 걸어야 한다."}
{"patent_id": "10-2020-7025531", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "여러 곳의 사업체들 또는 조직들로부터 수집된 정보의 데이터베이스를 유지하기 위해, 인간 운영자는 데이터를 수집하기 위해 많은 수의 사업체들에 대한 자동 통화를 개시할 수 있지만, 피호출자들(예를 들어, 동일한 요리 를 제공하는 특정 마을 내의 모든 레스토랑들)을 선택하는 것 및 전화들을 거는 것은, 수동으로 수행할 경우 시간이 많이 걸리는 작업일 수 있다. 더욱이, 전화를 언제 걸 것인지 및 어떻게 걸 것인지를 결정하는 것은, 검증 필요성, 업데이트 또는 보충 정보를 식별하기 위해 기존 데이터에 대한 인간의 분석을 요구하는 것이 일반적이 다. 사용자들은 또한, 약속 일정을 잡거나 서비스를 이용하는 등의 작업들을 수행하고자 할 수도 있다. 하지만, 일 반적으로는 이러한 원하는 작업을 완료하기 위해서, 사용자가 반드시 상호작용해야하는 사람이 존재한다. 예를 들어, 웹 사이트가 없는 소규모 레스토랑에서 예약하기 위해, 사용자는 여주인에게 전화를 걸어 통화를 해야할 수 있다. 경우에 따라, 사용자가 직접 전화를 거는 경우에도, 사용자는 자동 전화망(automated phone trees)에 연결될 수도 있으며, 이러한 자동 전화 연락망은 종종 제한된 세트의 사용자 응답들만을 수락한다."}
{"patent_id": "10-2020-7025531", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 시스템은 시스템에 의해 수신된 데이터로부터 특정 번호로 호출을 개시할지의 여부를 판별함으로써, 전화 호출을 통해 인간과 통신하는 것 또는 전화를 통해 동작되는 자동화된 시스템(예컨대, IVR)과 통신하는 것 을 수반하는 다양한 태스크들을 이용하여, 사용자를 도울 수 있다. 일단, 전화가 걸리면 시스템은 정보를 획득 하거나, 제 3 자에게 정보를 제공하거나, 조치를 취하거나(예컨대, 사용자를 대신하여), 기타 등등을 할 수 있 다. 일 구현예에서, 시스템은 사용자를 대신하여 인간과의 대화에 참여한다. 이러한 대화는 시스템과 인간 사이 의 전화 연결을 통해 발생할 수 있다. 특정 일례들에서, 시스템은 완료될 태스크들(작업들)을 포함하는 질의을 제출하는 검색 엔진 사용자들의 인텐트와 연관된 워크 플로우를 따라, 검색 엔진의 일부를 포함하거나, 이들과 함께 동작하거나, 또는 일부를 형성할 수 있다. 시스템은 적어도 하나의 자동(autonomous) 또는 반자동(semi- autonomous) 소프트웨어 에이전트(\"봇(bot)\") 동작들을 통해 사용자를 위한 작업을 실행할 수 있다. 일반적인 하나의 양상에서, 본 발명의 방법은, 전화들(호출들)을 걸고 그리고 호출들 동안 호출 개시 시스템의 봇과 인간 피호출자 사이에서 대화를 수행하는 호출 개시 시스템의 호출 트리거링 모듈에 의해서, 제 1 이벤트 를 나타내는 데이터를 수신하는 단계; 호출 트리거링 모듈에 의해서 그리고 제 1 이벤트를 나타내는 데이터를 이용하여, 상기 제 1 이벤트가, 복수의 가능한 트리거 이벤트들 중 호출 개시 시스템이 전화 호출의 개시를 시 작하게 하는 워크플로우를 트리거링하는 특정한 트리거 이벤트인지를 결정하는 단계; 결정된 트리거 이벤트에 기초하여, 복수의 가능한 워크플로우들 중 특정한 워크플로우를 선택하는 단계, 상기 특정한 워크플로우는 상기 결정된 트리거 이벤트에 대응하며; 그리고 이러한 선택에 응답하여, i) 상기 특정한 워크플로우에 의해 지정된 피호출자에게 전화 호출을 개시하는 단계, 및 ii) 상기 봇과 상기 피호출자 사이의 양방향 대화로서 워크플로우 를 실행하는 단계를 포함한다. 구현예들은 다음과 같은 특징들 중 하나 이상을 포함할 수 있다. 예를 들어, 결정된 트리거 이벤트는 제 1 데이 터 소스와 연관된 값과 제 2 데이터 소스와 연관된 대응하는 값 사이의 불일치이다. 제 1 이벤트를 나타내는 데 이터는 사용자에 의해 제공될 수 있다. 결정된 트리거 이벤트는 사용자 요청일 수 있다. 결정된 트리거 이벤트 는 날씨 이벤트, 엔터테인먼트 이벤트 또는 계절 이벤트 중 하나인 특정 타입의 이벤트일 수 있다. 결정된 트리 거 이벤트는 검색 엔진에 제출된 검색 요청들에서 검출된 트렌드일 수 있다. 결정된 트리거 이벤트는 기결정된 기간의 도과일 수 있다. 또 다른 일반적인 양상에서, 본 방법은, 사용자가 통화 요청의 현재 상태를 제공하기 위하여 트리거링 이벤트가 발생했음을 작업 관리자 모듈에 의해서, 결정하는 단계; 상기 작업 관리자 모듈에 의해 상기 사용자 호출 요청 의 현재 상태를 결정하는 단계; 상기 사용자 호출 요청의 현재 상태에 대한 표현을 생성하는 단계; 및 상기 사 용자 호출 요청의 현재 상태에 대해 생성된 표현을 상기 사용자에게 제공하는 단계를 포함한다. 구현예들은 다음과 같은 특징들 중 하나 이상을 포함할 수 있다. 예를 들어, 결정된 트리거 이벤트는 상태에 대 한 사용자 요청일 수 있다. 결정된 트리거 이벤트는 운영자가 사용자 호출 요청과 관련된 세션 정보를 검토한 후에 사용자에게 상기 상태를 제공하기 위한 운영자 상호작용일 수 있다. 결정된 트리거 이벤트는 상태 업데이 트 이벤트일 수 있다. 현재 상태의 표현은 시각적인 표현일 수 있다. 현재 상태의 표현은 구술 표현일 수 있다. 사용자 호출 요청의 현재 상태에 대해 생성된 표현을 사용자에게 제공하는 단계는 사용자에게 현재 상태를 전달 하는데 편리한 시간 및 방법을 결정하는 단계를 포함할 수 있다. 또 다른 일반적인 양상에서, 봇으로부터 전화 호출(phone call)을 전환하는 방법은, 호출 개시 시스템에 의해서, 상기 전화 호출의 제 1 측 상의 제 1 인간과 상기 전화 호출의 제 2 측 상의 상기 봇 사이의 전화 호출 동안, 상기 제 1 인간과 상기 봇 사이의 실시간 대화를 분석하는 단계; 상기 호출 개시 시스템에 의해서, 상기 실시간 대화에 대한 분석에 기초하여, 상기 전화 호출이 상기 봇으로부터 상기 전화 호출의 제 2 측 상의 제 2인간으로 전환되어야 하는지를 결정하는 단계; 및 상기 전화 호출이 상기 전화 호출의 제 2 측 상의 제 2 인간 으로 전환되어야 한다고 결정함에 응답하여, 상기 호출 개시 시스템에 의해서, 상기 전화 호출을 상기 봇으로부 터 상기 제 2 인간으로 전환하는 단계를 포함한다. 구현예들은 다음과 같은 특징들 중 하나 이상을 포함할 수 있다. 예를 들어, 상기 제 1 인간과 상기 봇 사이의 실시간 대화를 분석하는 단계는, 상기 제 1 인간의 행동(conduct), 태도(demeanor), 음색(tone), 짜증 레벨 (annoyance level), 언어 또는 단어 선택에 기초하여 상기 전화 호출 동안의 스트레인(strain)을 결정하는 단계 를 포함할 수 있다. 상기 방법은 상기 봇이 자체적으로 반복하거나(repear itself), 사과하거나, 설명을 요청 (asks for clarification)하는 경우, 상기 전화 호출 동안 상기 스트레인이 증가한다라고 결정하는 단계를 포함 할 수 있다. 상기 방법은 상기 제 1 인간이 상기 봇을 정정하거나(correct) 혹은 통화 품질에 대해 불평하는 경 우, 상기 전화 호출 동안 상기 스트레인이 증가한다라고 결정하는 단계를 포함할 수 있다. 상기 방법은 상기 봇 이 상기 제 1 인간의 대화에 적절히 응답하는 경우, 상기 전화 호출 동안 상기 스트레인이 감소한다라고 결정하 는 단계를 포함할 수 있다. 상기 제 1 인간과 상기 봇 사이의 실시간 대화를 분석하는 단계는, 상기 전화 호출 의 작업(task)이 상기 봇에 의해서 완료될 것이라는 상기 호출 개시 시스템의 신뢰도 레벨을 결정하는 단계를 포함할 수 있다. 상기 제 1 인간과 상기 봇 사이의 실시간 대화를 분석하는 단계는, 상기 전화 호출이 요청된 상기 제 1 인간이 다른 인간으로 전환될지를 결정하는 단계를 포함할 수 있다. 상기 제 1 인간과 상기 봇 사이 의 실시간 대화를 분석하는 단계는, 상기 제 1 인간이 상기 봇을 조롱했는지 또는 상기 봇이 로봇인지를 물어보 았는지를 결정하는 단계를 포함할 수 있다. 상기 전화 호출이 상기 봇으로부터 상기 제 2 인간으로 전환되어야 하는지를 결정하는 단계는, 상기 스트레인이 기결정된 임계값 보다 큰지를 결정하는 단계; 및 상기 스트레인이 기결정된 임계값 보다 큼에 응답하여, 상기 전화 호출이 상기 봇으로부터 상기 제 2 인간으로 전환되어야함을 결정하는 단계를 포함할 수 있다. 상기 제 1 인간과 상기 봇 사이의 실시간 대화를 분석하는 단계는, 상기 실시 간 대화 내에서 하나 이상의 이벤트들을 추적하는 단계를 포함할 수 있다. 상기 전화 호출이 상기 봇으로부터 상기 제 2 인간으로 전환되어야 하는지를 결정하는 단계는, 상기 실시간 대화 내의 하나 이상의 이벤트들이 규 칙의 기준을 충족했는지를 결정하는 피처-기반 규칙 세트(feature-based rule set)를 이용하는 단계; 및 상기 하나 이상의 이벤트들이 규칙의 기준을 충족했다고 결정함에 응답하여, 상기 전화 호출이 상기 봇으로부터 상기 제 2 인간으로 전환되어야함을 결정하는 단계를 포함할 수 있다. 상기 제 1 인간과 상기 봇 사이의 실시간 대화를 분석하는 단계는, 상기 실시간 대화로부터 인텐트들(intents) 을 식별하는 단계; 및 이전 대화들로부터 역사적 인텐트들(historical intents) 및 역사적 결과들(historical outcomes)을 식별하는 단계를 포함할 수 있다. 상기 전화 호출이 상기 봇으로부터 상기 제 2 인간으로 전환되어 야 하는지를 결정하는 단계는, 상기 실시간 대화로부터의 인텐트들, 역사적 인텐트들, 또는 역사적 결과들을 하 나 이상의 머신 학습 모델로 전송하는 단계; 상기 인텐트들, 역사적 인텐트들, 또는 역사적 결과들에 기초하여, 상기 전화 호출이 전환되어야 하는지를 결정하는 단계를 포함할 수 있다. 상기 제 2 인간은 인간 운영자(human operator)일 수 있다. 상기 봇으로부터 상기 제 2 인간으로의 전환이 상기 제 1 인간에게 투명(transparent)하 도록, 상기 봇은 상기 인간 운영자와 동일한 음성을 사용할 수 있다. 상기 제 2 인간은 사용자이며, 상기 봇은 상기 사용자를 위해 상기 전화 호출을 수행한다. 상기 방법은 상기 전화 호출이 상기 봇으로부터 상기 제 2 인 간으로 전환되는 것이 기결정된 시간 보다 오래 걸리는 경우, 상기 전화 호출을 종료하는 단계를 포함할 수 있 다. 상기 방법은 상기 전화 호출을 인간으로 전환시키는 대신에 상기 전화 호출을 종료하는 단계를 포함할 수 있다. 이러한 양상들 및 다른 양상들의 다른 구현예들은 컴퓨터 저장 디바이스 상에 인코딩된, 본 방법의 동작을 수행 하도록 구성된 대응하는 방법, 장치 및 컴퓨터 프로그램을 포함한다. 하나 이상의 컴퓨터 프로그램은 데이터 처 리 장치에 의해 실행될 때 장치로 하여금 동작을 수행하게 하는 명령을 갖도록 구성될 수 있다. 다음의 장점들 중 하나 이상을 실현하기 위해서, 본 명세서에 설명된 주제의 특정 실시예들이 구현될 수 있다. 확인되지 않은 데이터의 다수의 세트들 대신에, 확인된 데이터의 하나의 세트만이 저장되기 때문에, 다양한 데 이터 소스들을 위해 요구되는 데이터 저장량이 감소할 수 있다. 예를 들어, 특정 식료품점에 대한 서로 다른 확 인되지 않은 영업 시간들의 3개의 세트들(예컨대, 매장 정면으로부터 수집된 1 세트, 상점의 웹 사이트로부터 수집된 1 세트, 및 매장의 자동 응답 시스템(answering machine)으로부터 수집된 1 세트)을 저장하는 대신에, 데이터 소스는 그 식료품점의 인간 대표자(human representative)와의 호출로부터 획득된, 확인된 상점 영업 시 간의 오직 한 세트만을 저장할 수 있다. 호출이 개시되어야함을 호출 개시 시스템에게 알려주는 트리거 이벤트들을 자동으로 검출함으로써, 피호출자들 로부터 데이터를 수집하는 것, 약속들을 스케줄링하는 것, 혹은 제 3자들에게 정보를 제공하는 것 등과 같은 동작들을 수행하는데 필요한 인간의 입력 분량(amount of human input)이 감소된다. 또한, 트리거 이벤트가 발생 할 때만 호출들이 개시되기 때문에, 정보 데이터베이스를 유지관리하는데 필요한 컴퓨터 리소스의 양이 감소한 다(걸어야할 전화 통화들이 감소하기 때문에). 본 시스템은 특정 피호출자들 또는 피호출자들의 세트들에게 자 동으로 전화를 걸기 때문에, 인간이 수행해야 하는 분석량 및 인간이 모니터링해야 하는 데이터의 양이 감소한 다. 또한, 본 발명의 시스템은 인간 사용자들을 대신하여 대화를 수행하기 때문에, 특정 작업(태스크)을 수행하는데 필요한 휴먼 입력의 양을 더욱 감소시킬 수 있다. 호출 개시 시스템은 동시에 여러 개의 호출들을 조정할 수 있 다. 예를 들어, 사용자는 장래에 30분 동안 예약을 원할 수 있다. 상기 시스템은 사용자가 지정한 각각의 레스 토랑을 호출하고 그리고 통화 상대방인 레스토랑 담당자와 대화를 수행할 수 있다. 첫 번째 레스토랑의 직원은 예약은 가능하지만 손님(diner)은 바(bar)에 앉아야한다는 제안을 할 수 있다. 두 번째 레스토랑 직원은 20 분 의 대기 시간이 있음을 제안할 수 있으며, 세 번째 레스토랑의 직원은 세 번째 레스토랑은 손님이 1시간 이내에 식사를 마칠 것을 요구하며, 따라서 그 시간 내에 테이블이 준비될 수 있음을 시스템에게 알릴 수 있다. 상기 시스템은 3개의 레스토랑 각각에 병렬로(in parallel) 전화를 걸수 있으며, 그의 옵션들을 제시하고 응답을 수 신함으로써 사용자와 상의하며, 그리고 사용자의 응답에 기초하여 사용자에게 가장 적합한 레스토랑을 예약함과 동시에 다른 모든 예약들을 취소(decline)할 수 있다. 자동화된 호출 개시 시스템은 인간 상대방(human counterpart) 보다 효율적인데, 왜냐하면 자동화된 시스템은 이러한 호출들 모두를 한번에 수행할 수 있기 때문 이다. 인간 보조자들은 이러한 레스토랑 호출들 모두를 용이하게 병렬로 수행할 수 없다. 본 명세서에 기술된 본 발명의 주제에 대한 하나 이상의 실시예들의 세부 사항들은 첨부된 도면들 및 아래에 설 명된다. 본 발명의 주제의 다른 특징들, 양상들 및 장점들은 상세한 설명, 도면 및 청구 범위로부터 명백해질 것이다."}
{"patent_id": "10-2020-7025531", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 발명은 이하에서 \"봇(bot)\" 으로 지칭되는 자동화 또는 반 자동화된 시스템을 가능하게 하는 기술을 설명하 는데, 상기 봇은 전화를 걸고 그리고 호출 동안 사람과의 대화를 독립적으로 수행함으로써 인간과 통신할 수 있 다. 봇은 데이터를 수신하고 모니터링하여, 호출이 개시되어야 함을 나타내는 트리거 이벤트를 감지한다. 상기 봇은 기정의된 워크플로우(workflows) 또는 반복가능한 동작 패턴들의 시퀀스를 통해 작동하며, 이들 각각은 수 행될 동작들에 대한 추상적인 설명 또는 인텐트들에 링크된다. 본질적으로, 상기 봇은 사용자에게 도움이 되는 태스크(이하, '태스크' 혹은 '작업' 이라 함)들을 수행하기 위하여, 인간에게 어떻게 반응하고 그리고 무엇을 말해야 할지를 결정하도록 이러한 워크플로우들을 사용할 수 있다. 상기 시스템은 가령, \"목요일 이브 생 토마스 레스토랑에서 2명 테이블을 예약해줘\" , \"내 싱크대에서 물이 새, 배관공이 필요해! 오후 10시 이후에!\" 기타 등등과 같은, 질의들로서 수신되는 다양한 작업들을 핸들링할 수 있 다. 약속을 스케줄링하고, 제품을 구매하고, 서비스들을 요청하고 기타 등등을 하고자 하는 사용자는, 성취하고자 하는 작업을 완료하기 전에, 여러 번의 검색들을 수행하고 그리고 많은 전화들을 걸어야할 필요가 있을 수 있다. 레스토랑에서 테이블을 예약하는 제 1 사용 일례에서, 사용자는 검색 엔진에서 레스토랑을 검색할 수 있 다. 일부 일례들에서, 레스토랑이 웹 사이트 또는 어플리케이션 상에 있는 경우, 웹 사이트 또는 어플리케이션 (또는 웹 사이트 또는 어플리케이션과의 통합을 통해)에서 질의가 실행될 수 있으며, 그렇지 않은 경우 사용자 는 레스토랑에 전화하여 예약을 진행해야 한다. 일례로서, 상기 시스템은 사용자를 위해 전화들을 거는데 이용될 수 있다. 상기 시스템은 사용자들이 요청한 작 업을 완료하기 위해, 비즈니스들 및 기타 서비스들과 통신한다. 일부 일례들에서 상기 봇은 매우 많은 통신들을 수행한다. 일부 일례들에서, 운영자는 봇들에 의해 수행되는 동작들의 성공을 리뷰하고 검증할 수 있다. 일부 일례들에서, 인간 운영자는 액션들을 수행하고 그리고 상기 봇들은 자동화된 통신 스킬들을 향상시키기 위해 운 영자의 통신 내용을 학습한다. 제 2 사용 일례에서, 사용자는 통상적인 업무 시간 이외의 배관공을 찾고자 할 수 있다. 이러한 질의는 처리하 기가 더 어려울 수 있다. 예를 들어, 만일 사용자가 수동으로 배관공을 검색하는 경우, 사용자는 검색 엔진에서 배관공들을 검색할 것이며 그 중 일부에게 전화를 걸 수 있다. 사용자는 각각의 배관공에게 시간 상의 제약들, 위치 및 문제의 성격을 설명해야 하고 그리고 가격 견적을 얻어야 한다. 이것은 매우 많은 시간이 소요될 수 있 다. 이와 유사하게, 지역 상점에 제품의 재고가 있는지를 체크하는 제 3 사용 일례의 경우, 찾고 있는 특정 아이템 또는 제품이 그 상점에 있는지를 알아보기 위해 사용자는 지역 상점들을 검색해야 하고 그리고 각각의 상점에 전화를 걸어야 할 수도 있다. 특정 작업들로 사용자들에게 도움을 주는 것 이외에도, 상기 시스템은 사업체 영업 시간, 제공되는 서비스, 기 타 등등과 같은 정보의 인덱스를 업데이트할 수 있다. 상기 시스템은 누락(missing), 에이징(aging), 불일치하 는 데이터를 검출하는 것에 응답하여 데이터를 업데이트하도록 자동으로 트리거링될 수 있다. 일반적으로, 이러 한 정보를 획득하기 위해, 사용자는 각각의 개별 사업체 또는 데이터 소스를 검사할 필요가 있다. 상기 시스템은 전화 호출을 개시하는 것을 포함하여 특정 작업들을 완료하기 위해 필요한 인간 입력(human input)의 양을 감소시키는 것을 포함하는, 많은 장점들을 제공한다. 예를 들어, 상기 시스템은 살롱에서 제공하 는 서비스와 제 3자 예약 웹 사이트에 나열된 서비스들 간의 불일치 등과 같은, 특정 트리거 조건이 충족되었다 라고 결정함에 응답하여, 전화 호출을 자동으로 개시할 수 있다. 상기 시스템은 거래 질의들에 대한 마찰을 줄 일 수 있는바, 예를 들어, 전화 통화의 일측 당사자인 인간의 좌절감이나 불편함을 감지하고 그리고 통화를 종 료하거나 또는 대화가 수행되는 방식을 변경함으로써, 마찰을 줄일 수 있다. 상기 시스템은 개발 도상국들의 사 용자들을 운송 또는 교육 서비스들과 같은 서비스들과 연결할 수 있다. 상기 시스템은 또한 웹 사이트 또는 디 지털 프리젠시(digital presences)가 없는 로우 테크(low tech) 산업들과 사용자들을 연결할 수 있다. 또한, 상 기 시스템은 최대 통합관리자(largest aggregator)와 비견될 정도로, 다른 어플리케이션들에 대해서도 확장가능하다. 도 1a는 전화를 걸고 그리고 호출 동안 호출 개시 시스템의 봇(bot)과 인간 사이에서 대화를 수행하는 호 출 개시 시스템에 대한 예시적인 블록도를 도시한다. 도면에 도시된 각 구성요소들은 이하에서 상세히 설 명될 것이다. 시스템은 봇이 인간과 효과적으로 통신할 수 있게 하도록 함께 동작하는 다양한 구성요소들과 서브시 스템들을 포함한다. 시스템은 통신 프레임워크 또는 플랫폼, 다이얼러, 사운드 시스템 , 호출 트리거링 모듈 또는 트리거 모듈, 오디오 패키지, 세션 레코더, 세션 저장소 , 텍스트-스피치 모듈, 스피치 종료점 검출기, 저장된 텍스트-스피치 결과들 또는 레코딩들 , 인텐트-텍스트 모듈(intent-to-text module), 스피치-텍스트 모듈, 스피치 어플리케이션 프 로그램 인터페이스(API), 텍스트-인텐트 모듈, 플로우 관리자, 운영자 제어기 및 긴급 구 제 모듈(bailout module)을 포함한다. 일부 구현예에서, 시스템은 모든 모듈을 포함한다. 다른 구현예에서, 시스템은 이들 모듈들의 조합을 포함한다. 예를 들어, 일 실시예에서, 텍스트-인텐트 계층은 불필 요하며 그리고 상기 인텐트(intent)는 스피치 합성 모듈에 직접 제공된다. 도 1b는 전화를 걸고 그리고 호출 동안 호출 개시 시스템의 봇(bot)과 인간 사이에서 대화를 수행하는 호 출 개시 시스템에 대한 대안적인 블록도를 예시한다. 이 일례에서, 통신 플랫폼은 사용자 요청에 대한 클 라이언트 엔트리 포인트 및 다른 요청들, 즉 사업체들로부터의 착신 콜(inbound calls)들에 대한 전화 시그널링 서버로 대체된다. 시스템은 2개 유형들의 요청들을 전화 서버로 전송하는바, 전화 서버(telephony server)는 상대방으로부터 호출을 수행하는 봇 서비스에게 전화를 건다. 일부 구현예에서, 봇 서비스 는 봇 서비스가 인간과 유사한 전화 대화를 수행할 수 있게하는 다이얼로그 모델 및 언어 모델 을 포함한다. 전화 서버는 TTS 모델을 포함할 수 있다. 스피치 인식기 및/또는 오디오 믹서 는 전화 서버가 전화 호출의 다른 일방인 인간을 이해하고 인간에게 응답할 수 있는 정보를 제 공할 수 있다. 운영자는 작업 사용자 인터페이스 및 큐레이션 사용자 인터페이스를 사용하여 호 출을 모니터링한다. 운영자는 레코딩 스튜디오 및 평가 TTS로부터 녹음된 호출들을 리뷰할 수 있다. 호출 플레이어는 운영자에게 호출을 다시 재생할 것이다. 운영자는 로컬 에이전트를 사용하여 호출들을 스케줄링하여, 전화 서버를 통해 전화 호출들을 개시할 수 있다. 도 1a의 구현예에서, 통신 플랫폼은 전화들을 걸거나, 사업체 또는 사용자(104, 144)로부터 착신 콜들을 수신하거나, 타겟 사업체에 연락하는 것 등과 같은 작업들을 수행함으로써 봇이 외부 행위자들(external actors)과 콘택할 수 있게 한다. 또한, 통신 플랫폼은 봇이 사용자로부터의 요청을 수신하여 사용자를 대 신하여 호출하도록 허용한다. 몇몇 구현예에서, 사용자는 사용자 인터페이스와의 상호작용을 통해 또는 스피치성 요청을 통해 다른 사용자 또 는 사업체에 대한 호출을 요청한다. 이러한 사용자 요청들은 약속 예약, 레스토랑 예약, 개를 산책시키는 사람 (dog walker) 찾기, 또는 사용자가 구매할만한 아이템을 어떤 상점이 갖고 있는지를 파악하는 것 등과 같은, 보 조-유형 작업들일 수 있다. 도 1c는 사용자가 요청에 대한 더 많은 세부 사항을 입력할 수 있는 예시적인 사용자 인터페이스를 도시한다. 사용자는 \"예약(book)\" 버튼을 클릭하거나 다른 방법으로 사용자 인터페이스와 상호작용하여 요청을 시작할 수 있다. 예를 들어, 사용자가 이발 약속을 하고 싶다면, 사용자는 이발을 하고 싶은 살롱과 관련된 웹 사이트와 상호작용할 수 있다. 대안적으로, 사용자는 검색 결과들 내의 결과로서 살롱을 포함하는 검색 결과 리스트와 상 호작용하거나 또는 지도 상에서 살롱을 보여주는 사용자 인터페이스와 상호작용할 수 있다. 인터페이스들을 이 용하여 사용자는 전화를 요청할 수 있다. 사용자는 사용자 요청의 세부사항들을 입력할 수 있는바, 가령 사용자 가 보고 싶어하는 전문 스타일리스트, 사용자가 해보고 싶어하는 서비스 카테고리, 그리고 서비스 날짜 및 시간 등을 입력할 수 있다. 도 1b에 도시된 바와 같이, 사용자는 이발 약속에 대한 요청이 행해지고 있음을 나타내도 록 \"예약 계속\" 버튼을 클릭하거나 다른 액션을 취할 수 있다. 도 1d는 요청을 하기 위해 봇에 말을 하는 사용자의 예를 도시한다. 사용자가 봇에 요청을 말하고 난 후, 봇은 요청을 수신확인(acknowledge)할 수 있다. 봇은 사용자의 요청에 대한 추가 정보를 요구할 수도 있다. 예를 들 어, 사용자가 이발에 관하여 봇에 요청을 말하면, 봇은 사용자가 어디에서 이발 약속을 원하는지, 이발 약속을 예약해야 하는 날 및 사용자가 어떤 종류의 헤어컷 서비스를 예약하기를 원하는지에 대한 정보를 요청할 수 있 다. 작업이 수행될 수 없는 시간에서, 사용자가 시스템에 작업을 요청할 수도 있다. 예를 들어, 사용자는 모든 이발 살롱이 문을 닫는 시간인 밤 11시에 이발 약속을 스케줄링하기 위한 호출을 요청할 수도 있다. 시스템에 의해 달리 결정되거나 시스템에 의해 획득되는 살롱의 오픈 시간 동안과 같이 나중에 또는 시간에 개시되 고 완료될 작업 정보 저장부에 요청을 저장할 수 있다. 따라서, 시스템은 후속 일자 또는 후속 시간에서(가령, 시스템에 의해 달리 결정되거나 또는 획득되는 이발 살롱의 영엽 시간) 개시 및 완료되도록, 상기 요청을 작업 정보 저장부에 저장할 수 있다. 몇몇 구현예에서, 시스템은 상기 요청을 처리함에 있어서 지연이 있을 것이라는 초기 피드백을 사용자에게 제공 한다. 예를 들어, 이발 살롱이 문을 닫는 시간인 밤 11시에 이발 약속을 스케줄링하기 위한 호출을 사용자가 요 청하는 경우, 시스템은, 살롱이 문을 닫았기 때문에, 살롱이 문을 열고 시스템이 살롱에 도달(reach)할 때까지 작업을 완료하는데 지연이 있을 것이라는 표시(시각적 표시, 오디오 표시 또는 일부 다른 표시)를 사용자에게 제공한다. 일부 구현예에서, 작업 정보 저장소는 각각의 작업에 대한 정보를 저장하는바, 작업을 요청하는 사용자의 이름, 호출할 하나 이상의 사용자들 또는 장소들, 요청된 작업의 유형, 작업 요청이 이루어진 방법, 유형별 작 업에 대한 세부 사항들, 작업을 완료하기 위해 수행된 행위들에 대한 세부 사항들, 작업 시작 날짜, 작업 완료 날짜, 요청한 사용자에 대한 최종 상태 업데이트 시간, 호출 작업을 더블-체크한 운영자, 사용자가 요청한 작업 종료 날짜, 및 작업의 현재 상태 등을 저장한다. 일부 구현예에서, 작업 관리자 모듈은 사람들 또는 사업체들에 대한 호출들을 언제 스케줄링할지를 결정한 다. 작업 관리자 모듈은 작업 정보 저장소로부터 작업들을 모니터링하고 그리고 수신된 작업들을 스 케쥴링하기 위한 적절한 시간을 결정한다. 일부 작업들은 즉시 스케줄링되는 반면에, 다른 작업들은 특정 작업 이벤트가 발생한 후에 스케줄링된다. 많은 경우들에서, 시스템에 의해 걸려진 전화통화의 상대방 측에는 예를 들어, 인간와 같은 인간이 존재할 것이다. 인간은 상기 봇이 콘택을 시도하는 조직의 대표일 수 있다. 일부 일례들에서는 사업체들을 호출하기 위해 통신 플랫폼들이 사용된다. 본 시스템은 통신 플랫폼과 통합될 수 있다. 예를 들어, 본 시 스템은 프로그래밍 방식으로 웹 브라우저를 동작시키고 웹 기반의 화상 전자 회의 서비스 (teleconferencing service)를 사용하기 위해 웹 어플리케이션을 테스트하기 위한 프레임워크를 사용할 수 있다. 시스템은 여러 개의 통신 플랫폼 계정들을 생성 및 사용할 수 있다. 일부 예들에서, 시스템은 호출 속도의 쓰로틀링(throttling)을 방지하기 위해 서로 다른 통신 플랫폼 계정들 사이에서 자동으로 교번할 수 있다. 다이얼러는 봇이 수행하는 호출들의 개시 및 걸기를 용이하게 한다. 다이얼러는 통신 플랫폼에 통신가능하게 접속된다. 다이얼러는 통신 플랫폼에 명령들을 제공하여, 다이얼러에 의해 선택된 특정 피호출자(callee)에 대한 전화 호출을 개시한다. 예를 들어, 다이얼러 전화 번호의 숫자들(digits)에 대응하는 오디오 톤을 재생할 수 있다. 일단 전화가 호출되면, 시스템은 회선의 다른 종단에 있는 인간 피 호출자와 대화를 수행할 수 있다. 다이얼러는 특정 피호출자에 대한 호출을 개시하도록 지시받을 수 있다. 예를 들어, 다이얼러는 트리 거 모듈 또는 플로우 관리자와 같은 시스템 내의 다른 모듈로부터 명령을 포함하는 데이터를 수 신할 수 있다. 트리거 모듈은 시스템은 특정 피호출자에게 통화를 시작해야 함을 나타내는 트리거 이벤트 또는 특정 이벤트를 검출한다. 트리거 이벤트는 미리 결정된 유형의 이벤트가 될 수 있다. 예를 들어, 시스템의 사용 자는 특정 유형의 트리거 이벤트를 지정할 수 있다. 트리거 이벤트는 시스템의 사용자에 의해 수행되는 명 시적 동작, 트리거 모듈에 제공되는 데이터 내의 검출된 패턴, 특정 이벤트가 발생한 이후 경과된 미리 결 정된 시간 기간 및 다양한 다른 유형의 이벤트를 포함할 수 있다. 트리거 이벤트를 검출하는 것에 응답하여, 트 리거 모듈은 특정한 피호출자에게 호출을 개시하기 위해 다이얼러에 명령을 제공하거나 특정 워크 플 로의 노드를 선택하기 위해 플로우 관리자에 명령을 제공한다. 사운드 시스템은 오디오를 기록 및 재생하는데 사용된다. 일부 일례들에서, (a) 전화기 또는 화상 회의 서 비스로부터 시스템으로 들어오는 오디오; (b) 시스템으로부터 다시 통신 플랫폼으로 나가는 오디오; (c) a와 b를 결합한 혼합된 스트림이라는 3 개의 가상 스트림들이 설정되며, 전체 호출을 레코딩하는데 사용된 다. 사운드 시스템은 오디오 패키지를 사용하여 통신 플랫폼을 통한 통신들을 수행한다. 오디오 패키지들은 사운드 시스템과 통신하는데 사용된다. 일부 실시예들에서, 본 시스템은 오 디오 패키지를 감싸며 그리고 인커밍 오디오 패킷들의 연속적인 스트림을 핸들링하는 오디오 모듈을 포함 한다. 모듈은 또한 모든 인커밍 패킷을 기록하고 그리고 미리 녹음된 오디오 파일을 재생할 수 있다. 본 시스템 은 다양한 비트 깊이, 샘플링 주파수, 패킷 크기 등을 사용한다. 상기 시스템은 봇에 의해서 수행되는 인커밍 및 아웃고잉 대화들을 기록할 수 있다. 오디오 패키지는 시스템이 세션 레코더를 사용하여 특정 세션 또는 호출을 기록할 수 있게한다. 일부 일례들에서, 세 션 레코더는 생성된 봇의 스피치를 기록함으로써 봇에 의해 수행된 대화의 일부를 기록할 수 있다. 다른 일례에서, 세션 레코더는 통신 시스템에 의해 인간에게 외부적으로 출력되는 봇의 스피치를 기 록함으로써 봇에 의해 수행된 대화의 일부를 기록할 수 있다. 또한, 세션 레코더는 인간의 응답도 기 록할 수 있다. 세션 레코더는 기록된 세션 데이터를 저장소에 저장할 수 있다. 기록된 세션 데이터는 오디오 데이터 또는 상기 오디오 데이터를 나타내는 피처 데이터로서 저장될 수 있다. 예를 들어, 기록된 세션 데이터는 세션 의 오디오 데이터의 특정 피처들에 대한 값을 저장하는 벡터로서 저장될 수 있다. 세션 저장소는 로컬 데 이터베이스, 원격 서버, 시스템 내의 물리적 메모리, 또는 임의의 다양한 다른 유형의 메모리일 수 있다. 스피치 종료점 검출기는 봇과 라인의 타측에 인간 사이의 대화를 단순화한다. 대화를 단순화하기 위해, 그 것은 인간과 봇을 사이에서 별개로 스위칭하는 개별 문장들로 섹션화된다. 스피치 종료점 검출기는 오디오 패키지로부터 연속적인 입력 오디오 스트림을 수신하고 이를 개별 문장들로 변환하는 역할을 한다. 스피치 종료점 검출기는 스피치의 종료점을 검출한다. 일 구현예에서, 스피치 종료점 검출기는 스피 치 대기; 및 무음(silence) 대기 라는 2개의 스테이지들에서 동작한다. 스피치 종료점 검출기는 다음과 같 이 이들 상태들 사이에서 교번한다: 각각의 오디오 패킷은 그것의 RMSD(root-mean-square-deviation)를 기정의 된 임계값과 비교함으로써 검사된다. 하나의 패킷은 그것의 RMSD가 상기 임계값 보다 낮으면 \"무음\"으로 간주된 다. 비무음 패킷(non-silence packet)이 수신될 때마다 상기 모듈은 \"스피치 대기\" 상태에서 \"무음 대기\" 상태 로 전환된다. 상기 모듈은 전체 시스템의 상태에 따라, 기정의된 시간 동안 계속되는 연속적인 무음 패킷들이 수신된 이후에만 다시 전환될 것이다. 일부 구현예에서, \"사운드 대기\" 기간 동안, 스피치 종료점 검출기는 순수한 무음 패킷들(pure-silence packets)(10개의 실제 패킷 당 하나의 가공 패킷(fabricated packet))을 가공하며 그리고 이들을 스피치-텍스트 모듈로 전송한다. 가공된 패킷들은 스피치 API로부터의 연결해제를 회피할 수 있다. \"무음 대기\" 기 간 동안, 스피치 종료점 검출기는 기정의된 시간(베이스라인 노이즈 추정에 유용함)동안 스트림으로부터 무음 패킷들을 송신하고, 이후 모든 오디오 패킷들을 전송한다. 다른 구현예에서, 스피치 종료점 검출기는 억양(intonation) 및 언어 컨텍스트(language context)를 관찰 하도록 트레이닝된 머신 러닝, 뉴럴 네트워크 또는 다른 헝태의 딥 러닝을 사용하여, 종료점들을 찾아낸다. 일부 실시예에서, 특정 오디오 스트림 입력을 구문분석(parsing)할 방법을 결정할 때에, 스피치 종료점 검출기 는 말한 내용, 스피커의 억양, 등등을 고려한다. 예를 들어, 스피치 종료점 검출기는, 특정한 인간 피호출자가 낮은 어조(low inflection)로 문장을 끝내는 경향이 있다라고 결정할 수 있고, 그리고 스피치 종료점 검출기는 어조의 낮아짐이 검출되면 상기 피호출자가 말한 문장의 종료점을 예측할 수 있다. 스피치 종료점 검출기는 시간 프레임 내의 신호 대 잡음비에 기초하여 호출 동안 동적으로 임계값을 조정 할 수 있다. 스피치 종료점 검출기에 의해 구문분석된(parsed) 오디오 데이터를 텍스트로 변환하며, 텍스트는 봇의 다 음 응답을 선택하는데 사용되는 인텐트(intent)를 위해 분석될 수 있다. 스피치-텍스트 모듈의 출력은 스 피치 옵션들의 순서화된 리스트(ordered list)이며, 일부 경우에서는, 최상의 옵션에 대한 신뢰가 제공된다. 스 피치 인식 프로세스는 2개의 주요 구성요소들인 음향 모듈과 언어 모듈을 포함한다. 음향 모듈의 경우, 시스템 은 사람들이 전화기에 직접 말한 내용의 레코딩들로부터 트레이닝된 모델을 사용할 수 있다. 뉴럴 네트워크가 모델에 의해 사용될 수 있으며, 그리고 일부 일례들에서, 뉴럴 네트워크의 제 1 계층(first layer)은 전화 통화 에 존재하는 보코더(vocoder)를 설명하기 위해 재-트레이닝될 수 있다. 보코더는 스피치 입력의 분석으로부터 사운드를 생성하는 음성 코덱이다. 뉴럴 네트워크는 사업체들에 대한 전화들 및 개인 전화 호출들 사이에서 서 로 다른 배경 잡음을 설명하기 위해 재-트레이닝될 수 있다. 언어 모듈은 시스템의 과거 경험에 기초하여 언어 모듈을 바이어스하는 시스템을 사용하여 구축될 수 있다. 일부 일례들에서, 바이어스는 자동으로 구성될 수 있다. 일부 일례들에서, 이러한 바이어스는 수동으로 구성된다. 일부 일례들에서, 언어 바이어스 구성(language- bias configuration)은 분야별로 변경된다. 스피치-텍스트 모듈은 호출의 콘텍스트를 이용하는바, 이는 대화의 상대방인 사람이 어떤 말을 할지를 예 측하는 것에 기초하여 언어 모듈을 바이어스하기 위한 것이다. 예를 들어, 시스템의 봇은 \"화요일에 문을 여십 니까?\"라고 질문할 수 있다. 이러한 질문을 토대로, 대화의 상대방인 사람은 \"아뇨, 우리는 문 열지 않아요(no, we are closed)\" 또는 \"예, 물론이죠(yeah, sure)\" 와 같은 대답으로 응답할 가능성이 매우 높다. 봇은 과거의 호출들에 기초하여 가능성있는 응답들(likely responses)을 학습하며 그리고 인커밍 오디오를 이해하기 위해 예 측들을 이용한다. 상기 봇은 완전한 문장의 응답들(full sentence responses)을 예측할 수 있지만, 상기 봇은 문구(phrases)를 예측할 수도 있다. 예를 들어, 상기 봇이 \"우리 인원은 일곱명 입니다(we have seven people in our party)\"라고 말한 이후에, 상기 봇은 \"일곱명이라고 했나요?(you said seven people?)\" 라는 문구를 예 측할 수 있다. 또한, 상기 봇은 \"열한명이라고 했나요?(you said eleven people?)\" 라는 문구를 예측할 수도 있 는데, 왜냐하면 세븐과 일레븐은 유사하게 들리기 때문이다. 또한, 상기 봇은 낮은 확률로 다음과 같은 응답, \"두명 이라고 했나요?(you said two?)\"을 예측할 수도 있다. 상기 봇은 예측들에 기초하여 각각의 문구에 확률 가중치를 할당할 수 있다. 몇몇 구현예에서, 스피치-텍스트 모듈은 오디오 데이터를 텍스트로 변환하기 위해 스피치 API를 사용 한다. 일부 일례들에서, 스피치 API는 머신 러닝을 이용하여 오디오 데이터를 텍스트로 변환한다. 예를 들 어, 스피치 API는 입력으로서 오디오 데이터를 수용하는 모델을 사용할 수 있다. 스피치 API는 의사 결정 트리(decision tree), 선형 회귀 모델, 로지스틱 회귀 모델, 뉴럴 네트워크, 분류기(classifiers), 지원 벡터 머신, 귀납적 논리 프로그래밍(inductive logic programming), 모델들의 앙상블(예컨대, 배깅(bagging), 부스팅, 랜덤 포레스트 등의 기법을 이용하여), 유전자 알고리즘(genetic algorithm), 베이지안 네트워크 (Bayesian network), 기타 등등과 같은 다양한 모델들 중 임의의 모델을 이용할 수 있으며, 그리고 딥 러닝, 퍼 셉트론(perceptrons), 연관 규칙(association rules), 귀납 로직, 클러스터링, 최대 엔트로피 분류, 학습 분류 (learning classification) 등과 같은 다양한 접근법을 사용하여 트레이닝될 수 있다. 일부 일례들에서, 스피치 API는 지도 학습(supervised learning)을 사용할 수 있다. 일부 일례들에서, 스피치 API는 비 지도 학습(unsupervised learning)을 사용할 수 있다. 일부 일례들에서, 스피치 API는 네트워크를 통해 음성-텍 스트 모듈에 의해 액세스될 수 있다. 예를 들어, 스피치 API는 클라우드 서버 상의 원격 제3자에 의 해 제공될 수 있다. 대화의 동기화(가령, 봇이 응답하는 자연스러운 기회들을 결정하기 위해 사람이 말하고 있는 전후맥락(contex t)을 결정하는 것 등과 같은)를 해결하기 위해, 상기 시스템은 인텐트(intent)를 식별할 수 있다. 인텐트 는, 인간이나 봇이 말한 문장 내의 하나의 의미론적 의미(a single semantic meaning)에 대한 정형화된 언어 표 현(formal-language representation)이다. 일부 구현예들에서, 시스템은 마지막으로 수신된 인텐트와 봇 의 응답 사이에서 인간으로부터 수신된 임의의 인텐트를 무시하는데, 이는 인간이 말한 가장 최근의 문장과 관 련된 응답을 봇에 의해 생성하기 위한 것이다. 하지만, 시스템은 미래의 응답을 알아내기 위해 이전의 인 텐트들을 사용할 수 있다. 예를 들어, 시스템은 가장 최근에 수신된 인텐트 이전에 수신된 인텐트들을 ANCIENT 라고 마킹할 수 있으며, ANCIENT 인텐트를 구문해석(parse)할 수 있고, 그리고 오프라인 평가를 위해 이를 저장 할 수 있다. 일부 일례들에서, 다양한 다른 형태의 핸들링 로직이 사용될 수 있다. 시스템의 대부분은 불가지론 유스 케이스(use case agnostic)이지만, 시스템의 일부는 수동으로 설정 되거나 또는 특정 유스 케이스를 위해 완전히 프로그래밍된다(즉, 시스템 버티컬(system vertical)). 버티컬은 본질적으로, 인텐트들의 스키마(schema of intents)와 비즈니스 로직 코드로 구성된다. 스키마 내의 인텐트는, 인간이나 봇이 말한 문장 내의 하나의 의미론적 의미(a single semantic meaning)에 대한 내부 정형화된 언어 표현(internal formal-language representation)이다. 예를 들어, 영업 시간 추출 버티컬(opening-hours extraction vertical)에서, \"AreYouOpen {date : tomorrow}\" 라는 봇 인텐트와, 이에 대응하는 \"WeAreClosed {date_range : Sep}\" 라는 인간 인텐트가 존재한다. 인간으로부터 인입되는 오디오가 인텐트로 변환되는 프로세 스는, 본 명세서에서 인텐트 레졸루션(Intent Resolution)라고 지칭된다. 이와 반대되는 프로세스(봇의 인텐트 를 음성으로 변환)는 인텐트 투 스피치(Intent to Speech)라고 지칭된다. 스키마는 버티컬 별로(per vertical) 구성되지만, 인텐트를 학습하고 분류하는 대부분의 코드는 범용이며 그리고 버티컬들에서 사용된다. 일부 일례 들에서는, 시스템의 언어-특정 부분들(language-specific parts) 만이 인텐트 레졸루션 및 인텐트 투 스피치 구 성들 내에 상주한다. 로직 코드는 버티컬 별로 프로그래밍될 수 있으며(일부 공통 코드를 공유함) 그리고 호출의 콘텍스트(입력 파라 미터들 및 지금까지 발생한 일들)에 의해 정의되는, 가능한 모든 상황들에 대한 봇의 거동을 결정할 뿐만 아니 라, 인커밍 인간 인텐트도 결정할 수 있다. 일 구현예에서, 스피치는 텍스트로 변경되고, 이후 텍스트는 인간의 인텐트로서 해석된다. 인간의 인텐트는 로봇의 인텐트를 결정하는데 사용된다. 일부 버티컬들에서는, 봇이 대화 를 주도하는 반면에, 다른 경우들에는 대부분 인간에 반응한다. 예를 들어, 데이터 획득 유형의 버티컬들에서, 봇은 사업체들로부터 소정 정보를 추출하는 것을 목표로 한다. 일반적으로, 봇은 원하는 모든 정보를 얻을 때까 지 일련의 질문들을 시도할 것이다. 트랜잭션 유형의 버티컬들의 경우(예를 들어, 봇이 예약을 하는 것을 목표 로 하는), 봇은 대부분 인간이 한 질문들(\"이름이 무엇입니까?\"... \"전화 번호는?\")에 대답할 것이다. 이러한 경우들에서, 시스템은 인간이 갑자기 침묵하는 경우, 기타 등등의 경우에서만 주도적인 역할을 수행할 것이다. 프로그래머는 번역이 논리적으로 이루어지도록, 인간의 인텐트와 로봇의 인텐트 사이의 플로우(flow)를 설계할 수 있다. 일부 구현에에서는, 플로우에 대한 프로토콜이 존재하는바, 이는 인간 인텐트로부터 로봇 인텐트로의 번역을 변경하거나 업데이트하기 위해 비-엔지니어가 제어할 수 있게 하기 위한 것이다. 또한, 상기 플로우는 머신 러닝을 이용하여 자동으로 학습될 수도 있다. 다른 구현예에서, 입력 인간 인텐트 레졸루션은 히든 계층(hidden layer)이 될 수 있으며 그리고 입력 텍스트로 부터 출력 로봇 인텐트를 직접 학습하기 위해 머신 러닝이 이용될 수 있다. 인간의 스피치 입력은 텍스트로 변 경될 수 있으며, 그리고 이러한 텍스트로부터 로봇 인텐트가 직접 결정될 수 있다. 사람의 음성 입력을 텍스트 로 변경 한 다음이 텍스트에서 로봇의 인텐트를 직접 결정할 수 있다. 또 다른 구현예에서, 시스템은 인간의 스 피치로부터 인텐트를 직접 출력할 수 있다. 이러한 두 가지 설계들은 머신 러닝을 사용하여, 콘텍스트 및 각각 의 입력에 대응하는 로봇의 인텐트를 학습한다. 텍스트-인텐트 모듈은 가능한 인커밍 인텐트들의 스키마, 이러한 인텐트 각각에 대한 예시적인 문장들, 및 언어-바이어스 설정(language-bias configuration)을 이용하여 구성된다. 본질적으로, 텍스트-인텐트 모듈(13 0)은 인커밍 문장을 기정의된(혹은 \"미지의(unknown)\") 인텐트 목록으로 \"스냅핑(snapping)\"하는 역할을 수행하 며, 아울러 낯선 표현방식들(unfamiliar phrasings) 및 스피치 인식 프로세스의 오류들을 처리하는 역할을 수행 한다. 예를 들어, 일부 구현예에서, 텍스트-인텐트 모듈은 (음성 인식 모듈로부터 수신된 바와 같은) 다음 의 문장 \"아침 11시부터 내일 9시까지, 미안, 내일 9시 30분까지 문을 여는 사람은 누구인가?\" (\"who be open eleven o'clock in the morning till nine o'clock tomorrow nine thirty I'm sorry\")은 알려진 일례 \"we open at +(TIME,from_time) and close at +(TIME,to_time) i'm sorry\" 와 유사함을 식별할 수 있으며, 이것은 인텐트 \"WeAreOpen {from_time=11am, to_time=9:30}\" 의 일례이다. \"from_time\" 및 \"to_time\" 과 같은 필드들 은 인텐트 파라미터들이다. 텍스트-인텐트 모듈은 다음과 같은 2개의 주요 부분으로 구성될 수 있다: 주석자(annotators), 주 석이 달린 텍스트-인텐트 분류기(annotated-text to intent classifier). 일부 구현예에서, 시스템은 논증 분 류(argument classification)를 수행하는 포스트-분류 단계(post-classification phase)를 갖는다. 예를 들어, \"월요일부터 화요일까지, 미안, 수요일까지 문을 닫습니다(Monday to Tuesday, sorry Wednesday, we are closed)\" 라는 문구의 경우, 주석 파트(annotation part)는 상기 텍스트를 다음과 같이 재작성할 것이다: \"<DATE: Monday> to <DATE: Tuesday>, sorry <DATE: Wednesday> we are closed.\" 이러한 일례는 응답 텍스트에 서 주석들을 특정하는 주석자들로 문장이 재작성됨을 보여준다. 주석이 달린 텍스트 인텐트 분류는, 주석이 달 린 문구를 다음과 같이 변환할 것이다: WeAreClosed {day1: monday, day2: tuesday, day3: wednesday}. 포스트 -분류 단계는 상기 문구를 다음과 같이 재작성할 것이다: WeAreClosed {from_day: monday, to_day: wednesday, wrong_to_day; tuesday}. 시스템이 스피치 옵션들을 수신하자 마자, 시스템은 텍스트-인텐트 모듈을 이용하여, 날짜들, 시간들, 공통 이름들, 등등에 대해 이들 스피치 옵션들 각각에 주석을 단다. 이것은 2개의 목적들을 위해 수행 된다: 로직 모듈을 위한 인텐트 파라미터들을 추출하는 목적(예컨대, \"time, 10am\"), 이전에 조우한 문 장들과 매칭되는 것의 발견을 간단하게 하기위해 텍스트를 일반화하려는 목적. 텍스트-인텐트 모듈은 스피 치-텍스트 모듈로부터 출력을 수신하고 그리고 스피치 옵션들의 리스트에 주석을 붙인다. 그 다음, 텍스트 -인텐트 모듈은 주석들을 이용하여, 가장 가능성있는 옵션을 특정 워크 플로우 내의 다음 동작을 선택하기 위해 플로우 관리자에 의해 사용되는 인텐트에 맵핑시킨다. 호출 동안 계산 시간을 감소시키기 위하여, 시스템은, (현재 시간 및 날짜와 관련하여) 주석이 달려야하는 알려진 텍스트들의 라이브러리를 미리 구축할 수 있다. 예를 들어, 2015년 9월 1일 화요일인 경우, \"내일\" , \" 이번주 수요일\" , \"9월 2일\" 기타 등등은, \"DATE: (2015, 9, 2)\" 주석에 대한 후보들로서 저장될 수 있다. 실시 간으로, 시스템은 입력 문장 내의 단어들에 대해 순차적으로 반복하며(일부 시성식 이후에(after somecanonization)) 그리고 주석 후보의 가장 긴 매치를 검색한다. 그 다음, 시스템은 상기 텍스트를 주석으로 대체하고 그리고 왼쪽에서 오른쪽으로 모든 후보들이 주석들로 대체된 편집된 문자열(string)을 리턴한다. 예를 들어, \"we open at 7 in the morning\" 라는 문장은 \"we open at @(TIME, 7am)\" 라는 문장으로 대체될 것이다. 주석자(annotator) 또는 텍스트-인텐트 모듈은 축약(contractions)을 하는 역할도 수행한다. 예를 들어, 상기 시스템은 \"나와 만나자... 그래..4시, 오후 4시(let me see... yes, 4, 4 pm)\"와 같은 문장과 조우 할 수 있다. 텍스트-인텐트 모듈은 \"4시, 오후 4시(4, 4 pm)\" 라는 문구를 하나의 \"@(TIME, 4pm)\" 주석으 로 대체할 수 있다. 또한, 텍스트-인텐트 모듈은 다음과 같은 사소한 시간 보정들 \"10시, 아, 오후 10시 30분에 닫는다(we close at 10, ah, 10:30 pm)\" 을 \"we close at @(TIME, 10:30pm)\" 으로 축약할 수 있다. 다른 구현예에서, 시스템은 텍스트에 주석을 달기 위한 다음과 같은 다른 방법들을 이용할 수도 있다: 큐레이팅 된 데이터(curated data)에 기초하여 텍스트에 주석을 다는 법을 학습할 수 있는 머신 러닝 알고리즘; 텍스트에 주석을 다는데 사용될 수 있는 프리픽스 트리(prefix trees); 또는 주석을 위해 특별히 파생된 규칙 기반 패턴 (rule-based patterns). 텍스트-인텐트 모듈은 대부분의 통화들에서 새로운 문장들을 구문해석(parsing)하고 그리고 주석을 단다. 그리고 스피치 인식은 종종 말한 단어들의 많은 것들을 왜곡시킨다. 시스템은 유스 케이스 당 수천 개의 인텐트들을 저장하며, 그리고 저장된 인텐트들 중에서 문장의 파라미터들에 기초하여 문장과 가장 관련이 있다 고 결정된 인텐트를 갖는 것으로 각각의 문장을 분류한다. 예를 들어, 피호출자의 이름을 묻는 질문을 암시하는 특정 문장 내의 단어들을 검출하는 것에 기초하여, 시스템은 이름을 묻는 인텐트를 갖는 것으로 상기 특정 문장을 분류할 수 있다. 일부 구현예에서, 시스템은 문장에 대한 인텐트를 인식하지 않으며, 그리고 상기 문장을 알려지지 않은 인텐트를 갖는 것으로 분류할 수 있다. 텍스트-인텐트 모듈은 분류를 처리하기 위해 머신 러닝 알고리즘을 사용한다. 예를 들어, 시스템은 로지스 틱 회귀 모듈과 함께 조건부 랜덤 필드 모듈의 조합을 사용할 수 있다. 일 구현예에서, 분류는 문장 레벨에서 행해지는바 즉, 텍스트 문자열(string)은 인텐트들의 세트 또는 리스트로 변환된다. 또 다른 구현에서, 원래 문 자열의 모든 토큰(token)은 인텐트로 분류되고 그리고 인텐트 바운더리들도 분류된다. 예를 들어, \"월요일에, 우리는 7시에 열어, 생각해보면 ... 화요일에, 우리는 8시에 연다(On Monday, we open at seven, let me think ... on Tuesday, we open at eight)\" 라는 문장은, 제 1 구현예에서는 GiveDailyHours + AskToWait 라는 인텐 트들을 포함하는 것으로 분류될 수 있다. 제 2 구현예에서, \"월요일에, 우리는 7시에 열어(On Monday, we open at seven)라는 서브스트링은 GiveDailyHours 인텐트의 바운더리들로서 분류될 것이며, \"생각해보면...(let me think...)\" 이라는 서브스트링은 AskToWait 유형의 다른 인텐트로서 분류될 것이며, \"화요일에, 우리는 8시에 연다(on Tuesday, we open at eight)\" 라는 서브스트링은 GiveDailyHours 유형의 다른 인텐트로서 분류될 것이다. 일부 구현예에서, 텍스트-인텐트 모듈은 머신 러닝 알고리즘을 사용하지 하지 않을 수도 있으며, 그 대신 각각의 인텐트에 대한 사례들의 세트를 사용하고, 각각의 스피치 옵션과 모든 사례들 사이의 1-최근접 이웃(1- nearest neighbor)(패턴 인식 알고리즘)을 사용하는바, 여기서 알고리즘의 거리 메트릭(distance metric)은 문 장 내의 단어들의 정규화된 에디트 거리의 변동(variation of normalized edit distance)이다(2개의 문자열들, 예컨대 단어들이 얼마나 서로 유사하지 않은지를 정량화하는 방법). 2개의 개별 단어들 사이의 거리는 좀더 복 잡하며, 그리고 음성학적 거리(phonetic distance)의 근사치를 목표로 한다. 일부 일례들에서는, 주석이 달린 텍스트-인텐트 모듈에 의해서 의미론적 거리(semantic distance)가 결정될 수 있다. 실제로, 텍스트-인텐트 모듈은 또한 크로스 스피치 옵션 신호들을 사용할 수 있다(예를 들면, 스피치 옵션 들 중 하나에만 존재하는 숫자는 잘못된 해석일 가능성이 있다). 일부 일례들에서, 텍스트-인텐트 모듈은 사전에 시스템 컨텍스트에 기초하여 주석이 달린 텍스트-인텐트 모듈의 결과를 바이어싱한다. 최종적으로, 텍스 트-인텐트 모듈은 \"ComplexOpeningHours\"와 같은 애매하게 정의된(nebulously-defined) 인텐트들에 대한 몇몇 맞춤형 추출물(some tailored extractions)을 갖는바, 여기서 시스템은 영업개시 시간(opening hours)에 대한 복잡한 문구(complex phrasing)가 주어졌음을 식별할 수는 있지만, 상기 시스템은 파라미터들을 올바르게 추출할 수 없다(예컨대, \"... 저녁 식사는 9시까지 제공되며, 한 시간 더 디저트를 주문할 있다, 그리고 바는 2 시까지 영업하지만, 1시 이후에는 손님을 받지 않는다...\". 기타 등등). 일부 일례들에서, 분류에 사용되는 일례들은 큐레이팅된 과거 호출들에 기초하여 자동으로 추론되며, 그리고 또 한 수동으로 편집될 수 있다. 일반화 프로세스는 텍스트를 주석으로 대체할 수 있으며 그리고 의심스러운 큐레 이션(curations)을 생략할 수 있다. 일부 일례들에서, 인간은 하나의 인텐트를 말하는 것이 아니라 일련의 인텐트들을 말할 수도 있다. 예를 들면, \"머리를 자르실 겁니까? 몇시에?(you want a haircut? what time?)\" 라고 말할 수 있다. 예시적인 시스템은 주 어진 문장 내에 있는 많은 수의 인텐트들을 지원한다. 일부 일례들에서, 주석이 달린 텍스트-인텐트 모듈은, 다 른 인텐트의 프리픽스들로서 구체적으로 긍정적인 및 부정적인 인텐트를 결정한다(예를 들어, \"no sir, we will be closed at this date\" => Negative+WeAreClosed). 일부 일례들에서, 주석이 달린 텍스트-인텐트 모듈은 인 텐트들의 체이닝(chaining)을 지원한다. 시스템은 플로우 관리자를 포함한 조직 로직의 다른 기능들을 수행하는 다수의 모듈들을 포함하며, 이는 상식 모듈(common sense module) 및 긴급 구제 모듈(bailout module)을 포함한다. 플로우 관리자는 각각의 호출을 추적하고, 인간으로부터 수신된 각각의 인텐트(또는 긴 무음)에 응답하는 방법을 결정하는, 버티컬 당 커스텀 코드(custom code per vertical)를 포함할 수 있다. 그러나, 다른 구현예에 서, 플로우 관리자는 버티컬들에 대해 일반적(generic)이다. 응답은 인간에게 말하는 합성 인텐트들의 리 스트이며(봇은 무음을 유지할 수도 있다) 그리고 때때로 호출을 종료하라는 명령이다. 또한, 플로우 관리자 는 그 동안 수집된 임의의 정보를 포함하여 호출의 결과를 생성할 책임이 있다. 일부 일례들에서, 시스템 은 인간에 의해 처음 생성되고 이후에 '차일드'봇에 의한 라이브 호출들에 기초하여 각각의 입력에 반응하 는 방법을 학습한다. 시스템은 통화 중에 생긴 임의의 오해를 해결할 수 있도록 로직을 가능한한 유연하게 유지한다. 시스템은 다수의 플로우들을 갖는바, 이들 플로우들 각각은, 사업체들의 영업 개시 시간을 판별하는 것 또 는 살롱 약속을 위해 예약을 진행하는 것 등의 특정 유형의 작업들에 맞춤화된다. 상기 시스템은 서로 다 른 플로우들 사이에서 공유되는 공통 라이브러리를 유지할 수 있고, 걸려온 호출들의 이력으로부터 서브 플로우 들을 추출함으로써, 시스템이 각각의 작업에 대해 새로운 버티컬로 점프-스타트할 수 있게 한다. 일부 일례들에 서, 시스템은 수동으로 걸려온 호출들에 기초하여 상이한 작업들에 대한 플로우를 자동으로 학습할 수 있 다. 인간들은 대화할 때 일부 중요한 내용들을 빼먹을 수도 있다(대화 상대방을 혼란시킴이 없이). 예를 들어, 인간 은 \"우리는 10시에서 4시까지 문을 연다(we open 10 to 4)\" 라고 말할 수 있다. 봇은 사업체가 오전 10시 또는 오후 10시에 문을 여는지를 이해할 필요가 있으며, 이와 유사하게 오후 4시에 문을 닫는지 또는 오전 4시에 문 을 닫는지를 이해할 필요가 있다. 예를 들어, 상기 사업체가 나이트클럽이라면, 상기 봇은 오후 10시 부터 오전 4시 까지로 추정할 것이라 예측될 수 있다. 만일, 상기 사업체가 레스토랑이라면, 상기 봇은 오전 10시 부터 오 후 4시 까지로 추정할 것이라 예측될 수 있다. 플로우 관리자는 수신된 스피치 입력 내의 인텐트들의 애매모호함을 명확히 구별하는(disambiguate) 상식 모듈(common sense module) 포함한다. 일부 실시예에서, 플로우 관리자는 여러 유형의 상식 모듈들, 예를 들어, 일부 데이터 세트(예를 들어, 베이스라인 로컬 데이터베이스)에 대한 통계로부터 학습하는 모듈 및 수동으로 프로그래밍되는 모듈을 포함한다. 제 1 유형의 모듈은 옵션들의 데이터 세트(예컨대, 영업 시간들)를 취하고 그리고 각각의 옵션 및 서브-옵션(예: \"2am - 4am\" 또는 단지 \"2am\" ?)에 대한 p-값을 계산한다. 제 2 유형의 모듈은 기정의된 규칙들의 세트를 사용하는바, 기정의된 규칙들의 세트는 시스템이 데이터 세트에 상주 할 수 있는 \"상식적인\" 실수를 범하지 않게한다. 소정 변수를 해석하는 여러 방법들이 있을 때마다, 플로우 관 리자는 가장 가능성있는 옵션을 결정하기 위해 2개의 스코어들을 결합할 수 있다. 일부 일례들에서, 플로 우 관리자는 충분한 가능성이 있는 옵션은 없다라고 결론을 내리며, 그리고 상기 시스템은 그들이 의 미하는 바를 명확히 하기 위해 인간에게 명시적으로 질문을 시도하는 단계로 되돌아 간다. 상식 모듈은 유사한 피호출자들로부터의 데이터를 사용하여, 가장 가능성있는 옵션을 선택한다. 예를 들어, 필라델피아에 있는 대부분의 바(bar)가 오후 8시부터 오전 2시까지 영업한다면, 상식 모듈은 \"10시 부터 2시까지 문을 연다\"라는 애매모호한 문구에 대한 가장 가능성이 높은 옵션은, 오후 10시부터 오전 2시까지 임을 의미한다라고 결정할 수 있다. 일부 실시예에서, 상식 모듈은 추가적인 설명(clarification)이 요구 됨을 플로우 관리자에 표시할 수 있다. 예를 들어, 미시건 주 잭슨에 있는 대부분의 우체국들이 오전 10시 부터 오후 5시까지 업무 시간을 갖는다면, 업무 시간이 \"오후 2시부터 오후 6시까지(이는 일반적인 우체국과는 다른 기준이다)\"라는 피호출자의 응답을 상기 시스템이 믿고 있는지에 대한 설명을 요구하도록 플로우 관 리자에게 지시할 수 있다. 때때로, 호출 동안에 누적된 스트레인(accumulated strain)이 존재할 수 있는데, 이는 대부분 높은 배경 잡음, 예외적인 시나리오들, 강한 악센트, 또는 코드 상의 단지 버그로 인한 것이다. 또한, 스트레인은 예상치 못한인텐트로 인해 야기될 수도 있다. 예를 들어, 레스토랑에 전화를 걸 때, 시스템은 다음과 같은 예상치 못한 문 장과 마주할 수 있다: \"그래서, 프레젠테이션을 만들고 싶습니까?(so, do you want to make a presentation?)\" 또는 \"우리는 너도 알다시피, 슈퍼볼을 볼 수 있는 TV가 없다(we don't have a TV to show the Super Bowl, just so you know).\" 시스템은 이전에 경험하지 못한 인텐트들을 처리해야만 한다. 어느 일방에 대해 문제가 되 는 상황들을 파악하기 위해서, 상기 봇은 통화 중에 나타나는 스트레스의 분량을 계량하려고 시도한다. 긴급 구 제 모듈(bailout module)은 호출을 감독하는 운영자를 모방할 수 있으며 그리고 수동 개입을 언제 실시할 지를 선택할 수 있다. 운영자 제어기는 플로우 관리자에 통신가능하게 접속되며, 그리고 운영자 제어기는 인간 운영자 가 플로우 관리자에게 직접 명령들을 제공할 수 있게 한다. 일부 일례들에서, 호출이 인간 운영자에게로 일단 이관되면, 운영자 제어기는 플로우 관리자를 홀딩 패턴으로 놓거나 또는 플로우 관리자를 멈추거나 셧다운시킨다. 텍스트-인텐트 모듈에서 결정된 인텐트에 기초하여 플로우 관리자가 특정 워크플로우 내의 다음번 노 드를 선택하면, 플로우 관리자는 인텐트-텍스트 모듈에 명령들을 제공한다. 플로우 관리자에 의 해 제공된 명령들은 통신 플랫폼을 통해 피호출자에게 전달될 다음 인텐트를 포함한다. 또한, 인텐트 -텍스트 모듈은 스피치 합성을 위한 마크업 큐(markup cues)를 생성하는바, 예를 들어 일부 단어들에 대한 상이한 강조(emphasis) 또는 운율( prosody)을 정의한다. 인텐트-텍스트 모듈은 수동으로 정의된 규칙 또 는 강화 학습을 사용하여, 새로운 텍스트를 인텐트로부터 생성할 수 있다. 인텐트-텍스트 모듈의 출력은 텍스트이며, 이 텍스트는 통신 플랫폼에서의 출력을 위해 오디오 데이 터로 변환할 수 있다. 상기 텍스트는 텍스트-스피치 모듈에 의해서 오디오로 변환되며, 텍스트-스피치 모 듈은 이전에 저장된 텍스트-스피치 출력들 및 판독들을 사용한다. 텍스트-스피치 모듈은 저장된 출력들/판독들로부터 이전에 저장된 출력들을 선택할 수 있다. 일부 구현예에서, 상기 시스템은 호출 동안 에 텍스트-스피치 합성기를 사용할 것이다. 예를 들어, 봇(bot)이 제공하기 위해 플로우 관리자에 의해 선 택된 통상적인 응답이 \"좋아요, 도와줘서 고마워요!(Great, thank you for your help!)\" 라면, 텍스트-스피치 모듈은 실행-시간(run-time)에서 출력을 생성할 필요없이, 이전에 생성된 텍스트-스피치 출력을 선택할 수 있다. 일부 일례들에서, 텍스트-스피치 모듈은 네트워크 접속을 통해 액세스되는 제3자 API(스피치 API 128와 유사한)를 사용한다. 전술한 바와 같이, 소정 일례들에서, 사용자는 사용자에 의해 제공되는 검색(예를 들면, 웹 검색) 결과들과 상 호작용함으로써, 시스템에 대한 작업을 개시할 수 있다. 예를 들어, 사용자는 \"미슐랭 스타 레스토랑에서 오늘 밤 2명 테이블 예약\"을 검색할 수 있다. 작업 관리자 모듈은 작업를 수신하고 작업 정보 저장소(15 0)에 작업 정보를 저장할 수 있다. 이후, 작업 관리자 모듈은 작업를 언제 스케줄링할지를 결정하고 트리 거링 이벤트를 설정할 수 있다. 예를 들어, 만일 사용자가 미쉐린 스타 레스토랑이 오픈하기 전에 테이블 예약 을 요청한다면, 작업 관리자 모듈은 레스토랑이 언제 오픈하는지를 결정하고 그 시간에서 트리거링 이벤트 를 설정할 수 있다. 만일, 트리거링 이벤트 때문에 프로세싱에서 지연이 발생할 것을 작업 관리자 모듈이 아는 경우, 작업 관리자 모듈은 시각적 표시, 음성 표시 또는 다른 표시를 제공함으로써 사용자에게 지연 을 경고할 수 있다. 일부 구현예에서, 작업 관리자 모듈은 작업이 시작되도록 스케줄링되는 때에, 작업를 완료하는데 걸리는 시간에 대한 정보를 제공할 수 있거나 또는 작업에 왜 지연되는지에 대한 추가적인 정보를 제공할 수 있다. 트리거 모듈은 특정 트리거 이벤트(본 일례의 경우, 레스토랑의 오픈 시간)가 발생하였음을 검출할 수 있 으며, 그리고 다이얼러에게 지시하여 전화를 걸게할 수 있다. 일부 일례들에서, 시스템은 전화할 레 스토랑을 선택하기 위한 옵션을 사용자에게 제시할 수 있다. 다른 일례들에서, 시스템은 일련의 특징들에 기초하여 선택된 특정 레스토랑에 자동으로 전화를 걸 수 있다. 사용자는 특정 작업들을 위해 전화들을 걸기 위 한 디폴트 선호도들을 정의할 수 있다. 예를 들어, 사용자는 시스템이 사용자의 현재 위치에 가장 가까운 레스토랑을 선택하여 전화를 걸어야함을 지정하거나 또는 시스템이 가장 높은 등급의 레스토랑을 선택하여 전화를 걸어야 함을 지정할 수 있다. 소정 실시예들에서, 시스템은 통신 어플리케이션를 포함하거나, 그 일부를 구성하거나, 또는 통신 어플리 케이션과 통신하도록 구성될 수 있는바, 이러한 통신 어플리케이션은 가령, 작업에 대한 도움을 사용자가 시스 템에게 요청할 수 있는 사용자 인터페이스를 포함하는 메시징 어플 또는 채팅 어플 등이 될 수 있다. 예를 들어, 사용자는 메시징 어플리케이션을 이용하여 \"와이어 시티(Wire City)에 빨간색 20 AWG(American WireGauge) 와이어가 있습니까?\" 와 같이, 숫자를 구비한 요청을 문자 메시징할 수 있다. 시스템은 이러한 텍스트 메시지를 수신하고, 상기 요청을 구문해석(parse)하여 트리거 이벤트가 발생했다고 결정하고, 그리고 적절한 행 동을 수행하기 위해 호출을 개시할 수 있다. 예를 들어, 시스템은 가장 가까운 와이어 시티에 전화하여 현재 20 게이지 빨간색 와이어가 매장에 있는지를 문의할 수 있다. 마찬가지로, 소정 실시예에서, 시스템은 가상 어시스턴트 시스템을 포함하거나, 그 일부를 형성하거나, 또 는 가상 어시스턴트 시스템과 통신하도록 구성될 수 있는바, 가상 어시스턴트 시스템 자체는 다양한 서비스들 혹은 작업들로 사용자를 도와주기 위한 소프트웨어 에이전트들의 컬렉션이다. 예를 들어, 사용자는 가상 어시스 턴트에게 (음성 또는 텍스트로) \"내 드라이 클리닝이 준비됐습니까(Is my dry cleaning ready)?\" 라고 입력할 수 있다. 가상 어시스턴트는 이러한 입력을 프로세싱하고 그리고 상기 질의를 충족시키기 위해서는 사업체와의 통신이 필요하다고 결정할 수 있으며, 그리고 결과적으로, 시스템과 통신하여 인텐트를 식별하고, 전화를 걸고, 적절한 워크플로우를 실행한다. 특정 실시예에서, 시스템은 자율적으로 다수의 사람들 각각과의 다수의 대화들을 통해 자율적으로 (autonomously) 다수의 작업들을 실행하고, 그리고 수집하고, 분석하고, 액션을 취하고 및/또는 대화들의 개별 혹은 누적 결과들을 제공할 수 있다. 예를 들어, 특정 지역 내의 다수의 레스토랑들이 가장 바쁜 시간대가 언제 인지에 대한 데이터를 수집하라는 작업이 시스템에 할당된다면, 시스템은 자동으로 각 레스토랑에 전화를 걸어서 소정 시간 기간 동안 얼마나 많은 고객들이 착석하고 있는지를 질문하여, 데이터를 분석하고 결과를 제 공할 수 있다. 도 2a는 사용자에 의해 할당된 작업을 완료하기 위한 예시적인 프로세스를 도시한다. 간략하게, 프로세스 는 각각 인텐트들에 의해 링크되는 기정의된 워크플로우들의 세트의 초기 노드에 대화를 매핑하는 단계 , 워크플로우의 현재 노드에 기초하여 아웃고잉 메시지를 선택하는 단계, 인간 사용자로부터 응답을 수신하는 단계, 상기 응답을 상기 기정의된 워크플로우 내의 인텐트에 매핑하는 단계, 상기 인 텐트에 기초하여 다음 노드를 상기 워크플로우 내의 현재 노드로서 선택하는 단계, 및 상기 기정의된 워크 플로우 내의 링크된 노드들의 세트 중 종료 노드에 도달할 때까지 단계 204-210을 반복하는 단계를 포함한다. 프로세스는 시스템과 같은 호출 개시(call initiating) 시스템에 의해 실행될 수 있다. 프로세스는 인텐트들에 의해 각각 링크된 기정의된 워크플로우들의 세트의 초기 노드에 대화를 매핑하는 단계를 포함할 수 있다. 예를 들어, 도 1과 관련하여 전술한 바와 같은 플로우 관리자는 인텐트들에 의해서 각각 링크된 기정의된 워크플로우들의 세트의 초기 노드에 대화를 맵핑할 수 있다. 일부 일례들에서, 시 스템과 인간 피호출자 간의 대화는 사용자에 의해 개시될 수 있다. 일부 일례들에서, 상기 대화는 기정의 된 워크플로들의 세트의 노드에 맵핑되는 인텐트를 포함한다. 예를 들어, 시스템은 기정의된 워크플로우들 의 세트를 수행될 동작들과 함께 저장할 수 있다. 일부 일례들에서, 시스템은 식별된 인텐트에 기초하여 기결정 된 워크 플로우를 선택할 수 있다. 워크플로우들 각각은 인텐트들에 의해 링크될 수 있다. 일부 일례들에서, 시 스템은 대화에서 사용자에 의해 특정된 사업체에 전화 통화를 걸 수 있다. 일부 일례들에서, 상기 사업체 는 레스토랑, 미용실, 의사의 사무실 등일 수 있다. 일부 일례들에서, 시스템은 인간이 응답을 하는 경우에만 전화가 성공적으로 걸렸다고 고려할 수 있으며, 그리고 아무도 응답하지 않거나, 또는 시스템이 전화망(phone tree)으로 안내되고 상기 전화망을 성공적으로 네티게이팅하는데 실패한다면, 상기 시스템은 전화가 성공적으로 걸리지 않았다고 결정할 수 있다. 상기 프로세스는 워크플로우의 현재의 노드에 기초하여 아웃고잉 메시지를 선택하는 단계를 포함할 수 있다. 예를 들어, 플로우 관리자는 워크플로우의 현재 노드가 사용자가 그러한 약속을 스케줄링하기를 원한다고 나타내는 경우, \"안녕, 이발에 대한 약속을 스케줄링하고 싶다\" 라는 메시지를 선택할 수 있다. 프로세스는 인간 사용자로부터 응답을 수신하는 단계를 포함할 수 있다. 예를 들어, 시스템은 \"물론입니다, 몇일 몇시에 약속을 예약하고 싶습니까?\"와 같은 응답을 전화 통화의 상대방인 인간 피호출자로 부터 수신할 수 있다. 일부 일례들에서, 시스템은(예를 들어, 세션 레코더를 사용하여) 이러한 응답 을 기록할 수 있다. 일부 일례들에서, 시스템은 인간 운영자를 위해 상기 응답을 재생산할 수 있다. 일부 일례들에서, 인간 운영자는 호출을 모니터링하고 있을 수도 있다(예를 들어, 운영자 제어기 134를 사용하여). 프로세스는 기결정된 워크플로우 내의 인텐트에 응답을 맵핑하는 단계를 포함할 수 있다. 플로우 관 리자는 기정의된 워크플로우 내의 인텐트에 상기 응답을 맵핑할 수 있다. 일부 일례들에서, 시스템은 기정 의된 워크플로우 세트가 각각 링크되는 인텐트들과 식별된 인텐트를 비교한다. 프로세스는 인텐트에 기초하여, 워크플로우 내의 현재 노드로서 다음 노드를 선택하는 단계를 포함할 수 있다. 예를 들어, 플로우 관리자는 인텐트를 사용하여 워크플로우의 다음 노드를 결정할 수 있다. 이후 플로우 관리자는 다음 노드를 현재 노드로 지정할 수 있다. 프로세스는 종료 노드에 도달할 때까지 204-210을 반복하는 것을 포함할 수 있다. 따라서, 지정된 현재 노드가 204-210의 각각의 반복 사이클에서 사용 되어, 종료 노드에 도달할 때까지 다음 아웃고잉 메시지를 결정한다."}
{"patent_id": "10-2020-7025531", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 2, "content": "도 2b는 사용자에 의해 할당된 작업을 완료하기 위한 예시적인 프로세스를 도시한다. 요약하면, 프로세스 는 사용자로부터 인텐트와 관련된 작업를 수신하는 단계, 인텐트를 식별하는 단계, 인텐트들에 의해 링크된 기정의된 워크플로우들의 세트 중에서 인텐트에 기초하여 기정의된 워크플로우를 선택하는 단계 , 기정의된 워크플로우를 따르는 단계, 작업을 완료하는 단계를 포함한다. 프로세스는 시 스템과 같은 호출 개시(call initiating) 시스템에 의해 실행될 수 있다. 프로세스는 인텐트와 관련된 작업를 사용자로부터 수신하는 단계를 포함할 수 있다. 예를 들어, 사용 자는 사용자 인터페이스를 통해 \"이발 약속을 예약하라\"는 검색 질의(search query)를 시스템에 제출할 수 있다. 일부 일례들에서, 검색 질의는 트리거 모듈에 의해 수신될 수 있으며, 트리거 모듈은 상기 질 의가 특정 피호출자에게 전화를 걸어야 함을 나타내는 트리거 이벤트임을 검출한다. 작업은 약속을 예약하는 것 이 될 수 있으며, 인텐트는 머리를 이발하는 것이 될 수 있다. 일부 일례들에서는 작업 또는 인텐트가 명시적으 로 입력되지 않을 수도 있다. 일부 일례들에서, 사용자는 검색 질의를 입력함이 없이, 작업 및 인텐트를 제출할 수 있다. 인텐트와 관련된 작업은 작업을 지원하기 위해 시스템에 의해서 수신될 수 있다. 프로세스는 인텐트를 식별하는 단계를 포함할 수 있다. 예를 들어, 시스템은 인텐트와 연관된 수신된 작업를 프로세싱하고 인텐트를 식별할 수 있다. 일부 일례들에서 인텐트는 명시적으로 입력될 수 있으며 그리고 작업과 구분된다. 일부 일례들에서 인텐트는 작업의 속성일 수 있다. 일부 일례들에서, 입력은 스피치 입력으로서 제공되고, 스피치 종료점 검출기는 구문해석된 출력을 스피치-텍스트 모듈에 제공하고, 스피치-텍스트 모듈은 텍스트를 텍스트-인텐트 모듈로 전송하며, 텍스트-인텐트 모듈은 인텐트 를 식별한다. 프로세스는 인텐트들에 의해 링크된 기결정된 워크플로우들의 세트 중에서 기결정된 워크플로우를 상기 인 텐트에 기초하여 선택하는 단계를 포함할 수 있다. 예를 들어, 시스템은 수행될 동작들과 함께 기정 의된 워크플로우들의 세트를 저장할 수 있다. 일부 일례들에서, 시스템은 단계 254로부터 식별된 인텐트에 기초 하여 기정의된 워크플로우를 선택할 수 있다. 예를 들어, 플로우 관리자는 텍스트-인텐트 모듈에 의 해서 단계 254에서 식별된 인텐트에 기초하여 기정의된 워크플로우를 선택할 수 있다. 일부 일례들에서, 시스템 은 기정의된 워크플로우들의 세트가 각각 링크되는 인텐트들과 상기 식별된 인텐트를 비교한다. 프로세스는 기정의된 워크플로우를 따르는 단계를 포함할 수 있다. 예를 들어, 시스템은 기정의 된 워크플로우에 포함된 명령들을 따르는 모듈들을 포함할 수 있다. 일부 일례들에서, 시스템의 봇(bot)은 기정의된 워크플로우에 포함된 명령들을 따를 수 있다. 예를 들어, 상기 명령들은 제어 데이터를 다이얼러(10 6)에 제공하도록 트리거 모듈에게 지시하는 것을 포함할 수 있는바, 이는 사업체의 대표자인 사람에게 전 화를 걸어서 그와 대화하도록 지시하기 위한 것이다. 프로세스는 작업을 완료하는 단계를 포함할 수 있다. 예를 들어, 시스템은 가령, 청구서 납부, 저녁 식사 예약을 변경하는 것 등과 같은 할당된 전체 작업을 완료할 수 있다. 일부 일례들에서, 시스템은 작업의 일부를 완료할 수 있는바 가령, 전화를 걸고 그리고 사람과 연결될 때까지 전화망을 네비게이팅할 수 있 다. 일부 일례들에서, 시스템은 사용자에 의해 지정된 작업의 일부분을 완료할 수 있다. 예를 들어, 사용 자는 시스템이 모든 작업을 완료하고 그리고 검증을 위해 호출을 사용자에게 이관하도록 지정할 수 있다. 많은 사용 사례들은, 사업체로부터 무언가를 구입하고 싶어하지만 거래에 요구되는 복잡성, 메뉴 선정, 언어적 문제, 기초 지식 등으로 인해 어려움을 겪는 사용자들과 관련될 수 있다. 거래 질의(Transaction queries)는, 거래의 완료를 위해 본 시스템의 성공을 기꺼히 도와주고자 하는 판매자측(vendor side) 사람들로부터 지원을 얻을 수 있다. 일부 일례들에서, 본 시스템은 개발 도상국들(developing countries) 그리고 배관 공사 (plumbing), 지붕 공사(roofing) 등의 저급 기술 및 서비스 산업분야(low tech and servie industries)에서 중 요한 도움을 제공한다. 인간 사용자가 이러한 거래들을 성공적으로 처리하는 것을 도와주기 위해서, 뿐만 아니 라 판매자측 시스템이 사용자를 도와주는 것을 장려하기 위해서 워크플로우들이 채용될 수 있다. 본 시스템은 다양한 사용 사례들을 수용할 수 있도록 확장가능하다. 예를 들어, 레스토랑 예약 어플리케이션은 전 세계에 있 는 수천 개의 사업체들과 제휴할 수 있다. 본 명세서에 개시된 시스템은 필요한 규모로 레스토랑 예약을 발행하도록 구성될 수 있다. 도 3은 시스템에 의해 실행되는 프로세스에 대한 예시적인 워크플로우를 도시한다. 이 특정 예에서, 간단 한 부울 질문(Boolean question)이 시스템의 봇에 의해 요구된다. 시스템은 보다 복잡한 문제에 응답할 수 있고, 상기 워크플로우는 설명의 간략화를 위해 제시된 것으로 이해된다. 워크플로우는 봇에 의해 제기되는 \"내일 문을 엽니까?\" 라는 예시적인 질문을 보여준다. 인간에 의해 제공 되는 가능한 응답들이 배치되고, 인간의 응답들 각각에 대한 봇의 응답들이 제공된다. 사람의 응답에 따라, 시 스템이 안내될 수 있는 플로우의 여러 단계들이 존재한다. 이중 경계들로 도시된 단계들은 시스템 이 플로우를 종료하는 최종 단계이다. 예를 들어, 봇에 의해 제기된 2진법 질문(binary question)에 응답하여, 인간 피호출자는 사업체가 내일 열린다고 확답할 수 있으며, 플로우는 종료한다. 인간 피호출자 는 사업체가 내일 열리지 않는다고 확답할 수 있으며, 플로우는 종료한다. 인간 피호출자는 봇에게 기다리 라고(hold) 요청할 수 있으며, 따라서 상기 봇은 플로우와는 별개인 홀드 플로우로 보내지며, 플로우(30 0)는 종료한다. 사용자들에 대한 액세스 용이성을 위해 그리고 본 시스템의 보급을 촉진하기 위해서, 상기 시스템은 기존의 어플리케이션들, 프로그램들 및 서비스들과 통합된다. 예를 들어, 시스템은 사용자의 모바일 디바 이스 상의 기존의 검색 엔진들 또는 어플리케이션들과 통합될 수 있다. 다른 서비스들 또는 버티컬들과의 통합 을 통해, 사용자는 완료될 작업들에 대한 요청을 용이하게 제출할 수 있다. 예를 들어, 시스템은 검색 엔 진 지식 그래프(search engine knowledge graph)와 통합될 수 있다. 일부 사용 사례들에서, 인간의 실시간 판단은 자동화될 수 있다. 예를 들어, 시스템은 사용자가 이발소 약 속 시간에 10분 늦음을 자동으로 검출할 수 있으며 그리고 사용자의 도착 전에 이발사에게 경고를 발할 수 있다. 상기 시스템은, 수행된 대화의 문맥에 기초하여 또는 지식 데이터베이스에 저장된 특정 피호출자에 대한 데이터에 기초하여, 봇의 소정 파라미터들을 선택할 수 있다. 예를 들어, 시스템은 피호출자의 액센트, 위 치 및 다른 문맥 데이터에 기초하여, 통화가 현재 수행되고 있는 언어와는 다른 언어가 피호출자에게 더 편하다 라고 결정할 수 있다. 다음으로, 시스템은 피호출자가 더 편안할 것이라고 상기 봇이 믿고있는 언어로 스 위칭하며 그리고 그 또는 그녀가 새로운 언어로 전화 통화를 수행하는 것을 선호하는지의 여부를 피호출자에게 물어본다. 인간 피호출자의 소정의 스피치 특징들을 미러링함으로써, 시스템은 호출이 성공할 가능성을 증 가시킨다. 시스템은 스피치 특징들로 인한 대화 중의 잠재적인 충돌 원인들을 감소시킴으로써 호출 동안에 축적되는 스트레인을 감소시킨다. 이러한 특징들은 사용되는 단어의 평균 길이, 문장 구조의 복잡성, 문구들 사 이에 있는 휴지기(pause)의 길이, 피호출자가 가장 편안하게 말하는 언어, 및 다양한 다른 스피치 특징들을 포 함할 수 있다. 도 4는 시스템의 호출 트리거링 모듈의 블록도이다. 트리거 모듈은 다이얼러에 통신가능하 게 연결되고, 그리고 트리거 이벤트를 검출하는 것에 기초하여 특정 피호출자들 또는 피호출자들의 세트에 대한 호출을 개시하도록, 다이얼러에게 명령들을 제공한다. 일부 일례들에서, 트리거 모듈은 플로우 관리 자와 통신하여, 플로우 관리자가 특정 워크플로우의 노드를 선택하거나 다이얼러에 명령을 제공 하기 위해 사용하는 트리거 이벤트 데이터를 제공할 수 있다. 트리거 모듈은 불일치 검출기, 제3자 API, 트랜드 검출기, 및 이벤트 식별기을 포함 하는 다양한 모듈들로부터 입력을 수신한다. 트리거 모듈은 또한 플로우 관리자로부터 입력을 수신할 수 있다. 일부 일례들에서, 모듈들(402-408) 각각은 상기 시스템에 통합된다. 다른 일례들에서, 상기 모듈들(402-408) 중 하나 이상은 시스템으로부터 원격이며 그리고 LAN(Local Area Network), WAN(Wide Area Network), 인터넷 또는 이들의 조합 등과 같은 네트워크를 통해 트리거 모듈에 연결된다. 네트워크는 하나 이상의 모듈들(402-408)을 트리거 모듈에 연결할 수 있고 그리고 시스템의 구 성요소들 간의 통신을 용이하게 할 수 있다(예컨대, 스피치 API와 스피치-텍스트 모듈 사이에서). 불일치 검출기는 다수의 상이한 소스들로부터 데이터를 수신하며 그리고 제 1 데이터 소스로부터의 데이터 값들과 제 2 데이터 소스로부터의 대응 데이터 값들 사이의 불일치를 검출한다. 예를 들어, 불일치 검출기(40 2)는 병원의 업무 시간을 나타내는 데이터를 수신할 수 있으며 그리고 병원의 웹 사이트에 열거된 병원 업무 시 간이 병원의 외부에 게시된 업무 시간과 다르다는 점을 검출할 수 있다. 불일치 검출기는 경합의 소스 (source of contention), 불일치가 검출된 데이터 값의 유형, 충돌하는 데이터 값 및 다양한 다른 특성을 나타내는 데이터를 트리거 모듈에 제공할 수 있다. 일부 일례들에서, 불일치 검출기는 특정 피호출자에 대한 호출을 개시하기 위한 명령을 트리거 모듈에 제공한다. 다른 일례에서, 트리거 모듈은 불일치 검출기로부터 수신된 데이터에 기초하여, 연락할 특정 피호출자 및 특정 피호출자로부터 수집될 데이터 필 드들을 결정한다. 트리거 모듈은 불일치 검출기에 의해 제공된 데이터에 기초하여 트리거 이벤트를 검출할 수 있다. 트 리거 이벤트는 불일치를 나타내는 사용자 입력을 수신하는 것을 포함할 수 있다. 예를 들어, 트리거 모듈 은 사용자 인터페이스를 통해 사용자 입력을 수신할 수 있다. 사용자 인터페이스는 별도의 어플리케 이션 또는 프로그램을 위한 인터페이스일 수 있다. 예를 들어, 사용자 인터페이스는 검색 엔진 어플리케이 션 또는 네비게이션 어플리케이션을 위한 그래픽 사용자 인터페이스일 수 있다. 일부 구현예에서, 사용자 인터페이스는 정보를 제공할 것을 사용자에게 프롬프트할 수 있다. 예를 들어, 상점의 광고된 폐점 시간 이후에 사용자가 상점에 있음 감지되면, 시스템은 상점이 아직 열려 있는지를 사용자 에게 질문하거나 또는 시간을 입력하도록 사용자에게 요청할 수 있다. 사용자는 사용자 인터페이스를 통해 요청된 데이터를 입력할 수 있고, 불일치 검출기는 사용자 인터페이스를 통해 입력된 데이터와 제 2 소스(가령, 지식 베이스 412)로부터의 대응하는 데이터 사이에 불일치가 존재하는지를 결정할 수 있다. 지식 베 이스는 원격 저장 장치, 로컬 서버 또는 임의의 다양한 다른 유형의 저장 매체와 같은 저장 매체일 수 있 다. 불일치 검출기는 사용자가 정규 시간 이외의 소정 시간에서 상점에 있는지의 여부를 결정할 수 있다 (예를 들어, 20분 이상, 상점들은 특히나 느린 고객으로 인하여 여분의 추가 시간 동안 열려있을 수 있기 때문 에). 다른 예시적인 상황에서, 불일치 검출부는 업체의 웹 사이트 상의 정보가 오래되었음(outdated)을 결정할 수 있다. 예를 들어, 불일치 검출기는 지식 데이터베이스로부터의 데이터에 기초하여, 베이스 낚시 클럽의 웹 사이트는 매달 첫 번째 수요일에 월례 미팅이 있음을 보여주지만, 상기 클럽의 보다 활동적인 소셜 미디어 프로파일들 모두는 상기 월례 미팅이 매월 두 번째 화요일에 개최됨을 검출할 수 있다. 불일치 검출기 는이 검출된 불일치를 나타내는 데이터를 트리거 모듈에 출력할 수 있다. 트리거 이벤트는 기결정된 시간 기간 동안 특정 데이터 세트가 업데이트되지 않았음을 결정하는 단계를 포함할 수 있다. 예를 들어, 시스템의 사용자는 임의의 다른 트리거 이벤트가 발생하는지의 여부와 상관없이, 소 정의 시간 분량(이러한 시간 분량 이후에 데이터가 리프레시되어야함)을 지정할 수 있다. 불일치 검출기는 특정 데이터 값에 대한 최종-업데이트된 타임스탬프를 비교할 수 있으며, 그리고 타임스탬프에 기초하여 기결정된 시 간이 경과했는지 여부를 판별할 수 있다. 타임 스탬프들 및 데이터 값들 자체를 포함하는 특정 데이터 필드들에 대한 특징들이 지식 데이터베이스에 저장될 수 있다. 타이머는 지식 데이터베이스에 데이터를 제공하여 경과된 시간 분량을 업데이트할 수 있다. 불일치 검출기는 타이머에 의해 제공된 타이밍 데 이터에 기초하여 기결정된 시간이 경과했음을 결정할 수 있다. 예를 들어, 지식 데이터베이스로부터 데이터에 기초하여, 불일치 검출기는 뉴욕, 이타카에 있는 작은 커피 숍들의 영업 시간이 3 달 동안 업데이트되지 않았음을 판별할 수 있다. 이후, 불일치 검출기는 검출 된 이벤트를 나타내는 출력 데이터를 트리거 모듈에 제공할 수 있다. 트리거 이벤트는 한 명 이상의 사용자들로부터 통화를 개시하기 위한 요청들을 수신하는 단계를 포함할 수 있다. 예를 들어, 트리거 모듈은 제3자 API를 통해 사용자로부터 요청을 수신하는 것을 검출할 수 있 다. 제3자 API는 사용자 인터페이스와 같은 사용자 인터페이스에 통신 가능하게 접속되며, 사용자는 호출을 시작하라는 요청을 나타내는 입력을 사용자 인터페이스를 통해 제공할 수 있다. 예를 들어, 사용자 인터 페이스는 어플리케이션에 대한 그래픽 사용자 인터페이스일 수 있으며, 이를 통해 사용자는 호출 캠페인을 스케줄링 및 실행하도록 요청할 수 있다. 사용자는 특정 피호출자 또는 피호출자들의 세트 및 추출을 위해 요구 된 특정 데이터를 나타내는 데이터를 제공할 수 있다. 예를 들어, 사용자는 가축 용품들(livestock supplies)을 판매하는 버지니아의 각 철물점(hardware store)에 대한 호출 캠페인이 실시되도록 요청할 수 있으며, 그리고 이들 철물점들은 병아리 사료(chick starter feed)를 제공하는지의 여부를 질문받을 수 있다(예컨대, 이러한 용 품들을 갖고있는 지점들의 목록이 후속 검색에서 이용가능함). 호출 동안 피호출자는 피호출자에게 다시 전화하도록 시스템에 대해 상이한 시간을 스케줄링할 수 있다. 예를 들어, 레스토랑의 메뉴가 변경되었는지 여부에 대한 질문을 받으면, 인간 피호출자는 시스템에게 한 시간후 또는 내일 다시 전화하라고 요청할 수 있으며, 이 시간 동안 레스토랑 측은 추가 작업을 위해, 새로운 메뉴를 살펴볼 수 있을 것이다. 시스템은 요청된 시간에 호출을 하도록 스케줄링할 수 있다. 일부 일례들에서, 트리거 모듈은 장래에 트리거 이벤트를 스케줄링할 수 있다. 다른 일례에서, 플로우 관리자는 호출을 개시하도록, 다이얼러에 의해 실행될 인텐트 또는 호출 이벤트를 스케줄링할 수 있다. 트리거 이벤트들은 지식 데이터베이스에 저장된 데이터 또는 실시간으로 제공하는 데이터에서 검출된 트렌드들 또는 패턴들을 포함할 수 있다. 예를 들어, 검색 엔진으로부터 수신된 검색 데이터에서 검출된 트렌드들은 트리거 이벤트가 될 수 있다. 검색 엔진은 사용자로부터 검색 요청을 수신하고, 검색 요청을 나타내는 데 이터를 트렌드 검출기에 제공할 수 있다. 트렌드 검출기는 수신된 데이터를 분석하고 수신된 데이터 의 트렌드를 검출한다. 예를 들어, 노스 캐롤라이나 애쉬빌(Asheville, NC)의 쿠바 레스토랑에 대한 검색이 지 난 달에 500% 증가한 경우, 트렌드 검출기는 이러한 검색의 증가를 감지하고, 그리고 트렌드를 나타내는 데이터를 트리거 모듈에 제공할 수 있다. 식별된 트렌드에 기초하여, 트렌드 검출기는 특정 피호출자 또는 피호출자들의 세트를 나타내는 데이터를 트리거 모듈에 출력할 수 있다. 일부 구현예에서, 트렌드 검출기는 검출된 트렌드를 나타내는 데이터 를 제공하고, 트리거 모듈은 식별된 트렌드에 기초하여 특정 피호출자 또는 피호출자들의 세트를 결정한다. 예를 들어, 트렌드 검출기는 \"네브라스카 주(NE)의 토네이도 링컨\"에 대한 검색들이 40% 증가했 음을 판별할 수 있고 그리고 검색 키워드들을 트리거 모듈에 제공할 수 있다. 트리거 모듈은 각 상점 의 필수 품목의 재고량 및 영업 시간을 확인하도록 비상 용품들(emergency supplies)을 제공하는 모든 상점들에 게 전화를 걸어야 함을 결정할 수 있다(예를 들어, 검색 엔진의 사용자에 의한 색인 및 후속 검색을 위해). 트리거 이벤트들은, 사업체들, 단체들, 개인들 기타 등등의 정상적인 활동에 영향을 미치는 것으로 식별된 관심 있는 특정 이벤트들을 포함할 수 있다. 이벤트 식별기는 제3자 데이터베이스 및 이벤트 데이터베이스 를 포함하는 다양한 제3자 소스들로부터 데이터를 수신한다. 이벤트 식별기는 로컬 메모리 디바이스 또는 실시간 데이터 스트림과 같은 다른 소스들로부터 데이터를 수신할 수 있다. 이벤트 식별기는 데이터 베이스들(420 및 422)로부터의 특정 이벤트를 식별하고 그리고 식별된 이벤트들을 나타내는 데이터를 트리거 모 듈로 출력한다. 일부 일례들에서, 트리거 모듈은 이벤트 식별기에 의해 제공된 데이터에 기초하 여, 특정 피호출자 또는 피호출자들의 세트 및 호출 동안에 요청될 데이터를 선택한다. 사업체들, 단체들, 개별 사람들의 활동에 영향을 미칠 수 있는 특별한 이벤트는 극단적인 기상 조건, 연방 공휴 일, 종교 휴일, 스포츠 이벤트, 그리고 다양한 다른 사건들을 포함한다. 제3자 데이터베이스 등의 기상 서비스, 정부 경고(governmental alerts) 등등의 다양한 제3자 데이터 소스 로부터의 데이터를 이벤트 식별기에 제공한다. 예를 들어, 제3자 데이터베이스는 트렌드 식별기(40 8)에게 태풍 경고를 제공할 수 있다. 그 후, 이벤트 식별기는 겨울 폭풍우가 미네소타 주 미니애폴리스의 북동부 코너로 접근하고 있는지를 결정할 수 있고 그리고 이용가능한 발전기들의 현재 재고를 파악하기 위해 미 니애폴리스의 북동부 코너에 있는 철물점들에 전화를 해야한다고 결정할 수 있다. 이벤트 데이터베이스는 다양한 데이터 소스들로부터의 데이터를 이벤트 식별기에게 제공하며 그리고 구체적으로는 공지된 이벤트들을 나타내는 데이터를 포함한다. 예를 들어, 이벤트 데이터베이스는 연방 휴 일 및 주 휴일, 종교 휴일, 퍼레이드, 스포츠 이벤트, 전시회 오프닝, 고위 인사들의 방문, 및 다양한 다른 이 벤트들을 나타내는 데이터를 제공할 수 있다. 예를 들어, 특정 도시가 수퍼볼을 개최하는 경우, 이벤트 데이터베이스는 이러한 데이터를 이벤트 식별기 에게 제공할 수 있고, 이벤트 식별기는 이러한 이벤트를 나타내는 데이터를 트리거 모듈에 제공 한다. 트리거 모듈은, 이번 슈퍼볼에 대한 알려진 정보와 과거 슈퍼볼에 대한 저장된 정보에 기초하여, 숙 박가능성(availability) 및 가격(pricing)을 확인하기 위해 해당 지역 내의 모든 호텔들에 전화를 걸어야함을 결정할 수 있다. 또한, 트리거 모듈은 수퍼볼에 참가하는 팀들 각각에 대한 유니폼의 이용가능을 판별하기 위해 스포츠 용품 판매점들에 전화를 걸어야함을 결정할 수 있다. 이러한 상황에서, 트리거 모듈이 요청할 수 있는 사업체들, 단체들 또는 개인들의 활동에 영향을 미치는 다른 정보는, 사무실 빌딩 및 학교의 폐쇄, 대 중 교통 스케줄의 변경, 특별 레스토랑 제공물들(special restaurant offerings) 또는 다양한 다른 정보를 포함 한다. 시스템의 하나 이상의 다양한 모듈들은 이벤트 식별기로부터 수신된 이벤트 정보에 기초하여, 추론된 트리거 이벤트들(inferred trigger events) 또는 요청 정보를 결정할 수 있다. 예를 들어, 만일 이것이 \"죽은자 들의 날(Dia de Muertos)\" 이라면, 남미 레스토랑들, 특히 멕시코 레스토랑들은 축하 행사 때문에 특별 메뉴들 또는 특별한 시간들을 가질 수 있다. 이러한 일례들에서, 트리거 모듈은 다이얼러에 명령들을 제공하여, 그 날의 영업 시간 및 메뉴를 업데이트하도록 남미 레스토랑들에 전화를 걸 수 있다. 일부 구현예에서는, 시스템 자체에 의해서 걸려진 전화로부터 트리거 이벤트가 검출될 수도 있다. 플로우 관리자는 시스템에 의해 수행되는 대화의 일부에 기초하여, 전화가 걸려야 함을 암시하는 인텐트가 대화 중에 노출되었음을 결정할 수 있다. 예를 들어, 인간 피호출자가 \"우리는 매주 목요일 오후 8 시까지 열지 만, 다음 주에는 여름 스케쥴로 전환할 것이고 그리고 오후 9시 30 분까지 영업할 것이다\" 라고 말하면, 플로우 관리자는 데이터 필드에 관한 추가 정보를 제공하는 인텐트를 식별할 수 있다. 일부 구현예에서, 트리거 이벤트는 이전에 걸려진 전화로부터 불만족스러운 결과(unsatisfactory results)를 수 신하는 단계를 포함할 수 있다. 예를 들어, 사업체가 독립 기념일 휴일에 특별 공휴일을 가질 것인지를 판별하 기 위해 봇이 사업체에 전화를 걸었고 그리고 상기 사업체의 인간 대표자가 제공한 답변의 진실성에서 적어도 임계 분량 이상의 신뢰도를 갖지 못한다면, 시스템은 특별 공휴일이 있을 것인지를 판별하기 위해 가령, 7 월 1일과 같은 다른 특정 요일 또는 시간에 대해서 호출을 스케줄링할 수 있다. 이러한 일례들에서, 트리거 모 듈은 트리거 이벤트를 스케줄링하거나 또는 동작을 스케줄링하기 위해 플로우 관리자에 정보를 제공 할 수 있다. 일부 일례들에서, 플로우 관리자는 다이얼러에 대한 명령들의 전송을 스케줄링함으로써 콜백을 개시하도록 스케줄링한다. 시스템은 플로우 관리자가 특정 워크플로우의 노드들을 지능적으로 스케줄링 및 선택할 수 있게 하는 상식 모듈(common sense module)을 갖는다. 예를 들어, 전술한 상황에서, 호출 동안에 요청되는 정보의 유 용성에 대한 데드라인이 존재하는 경우, 상식 모듈은 또한 호출을 언제 스케줄링하고 어떤 정보를 요청해 야 할지를 결정할 수 있다. 일부 일례들에서, 상식 모듈은 도 1에 기술된 바와 같은 플로우 관리자의 컴포넌트이다. 다른 실시예에서, 상식 모듈은 트리거 모듈의 컴포넌트이며 그리고 언제 통화가 개시 되어야 하는지를 트리거 모듈이 지능적으로 결정하는 것을 용이하게 한다. 도 5는 전화 호출을 개시하기 위한 예시적인 프로세스를 도시한다. 간략하게, 상기 프로세스는 호출 을 개시하고 호출 동안 호출 개시 시스템의 봇과 인간 피호출자 사이의 대화를 수행하기 위한 호출 개시 시스템 의 호출 트리거링 모듈에 의해, 제 1 이벤트를 나타내는 데이터를 수신하는 단계, 상기 호출 트리거링 모 듈에 의해서 그리고 상기 제 1 이벤트를 나타내는 데이터를 사용하여, 상기 제 1 이벤트가 전화 호출을 개시하 는 것으로 시작하는 상기 호출 개시 시스템에 대한 워크 플로우를 트리거링하는 트리거 이벤트인지를 결정하는 단계, 상기 결정된 트리거 이벤트에 기초하여, 특정 워크 플로우를 선택하는 단계, 및 상기 선택에 응답하여, 상기 특정 워크 플로우에 의해 특정된 피호출자에 대한 전화 호출을 개시하는 단계를 포함한다. 상기 프로세스는 호출을 개시하고 호출 동안 호출 개시 시스템의 봇과 인간 피호출자 사이의 대화를 수행 하기 위한 호출 개시 시스템의 호출 트리거링 모듈에 의해, 제 1 이벤트를 나타내는 데이터를 수신하는 단계 를 포함할 수 있다. 예를 들어, 트리거 모듈은 샐리의 음식점(Sally's Saloon of Sweets)이라는 가 게의 웹사이트에 게재된 영업 시간과 그 사업체와 관련된 검색 색인에 저장된 영업 시간 사이의 불일치를 나타 내는 데이터를 불일치 검출기로부터 수신할 수 있다. 프로세스는, 상기 호출 트리거링 모듈에 의해서 그리고 상기 제 1 이벤트를 나타내는 데이터를 사용하여, 상기 제 1 이벤트가 전화 호출을 개시하는 것으로 시작하는 상기 호출 개시 시스템에 대한 워크 플로우를 트리 거링하는 트리거 이벤트인지를 결정하는 단계를 포함할 수 있다. 일부 일례들에서, 결정된 트리거 이벤트 는 제 1 데이터 소스와 연관된 값과 제 2 데이터 소스와 연관된 대응하는 값 사이의 불일치이다. 예를 들어, 트 리거 모듈은 불일치 검출기로부터의 검출된 불일치를 이용하여, 상기 불일치가 샐리의 음식점에 대한 실제 영업 시간을 결정하기 위해 워크 플로우를 트리거링할 트리거 이벤트임을 결정할 수 있다. 일부 실시예에서, 상기 제 1 이벤트를 나타내는 데이터는 사용자에 의해 제공된다. 예를 들어, 사용자는 샐리의 음식점(Sally's Saloon)의 웹 사이트에 게시된 영업 시간과 샐리의 음식점의 가게 앞에 게시된 영업 시간 사이 에 불일치가 있다라고 보고할 수 있다. 일부 실시예에서, 결정된 트리거 이벤트는 사용자 요청이다. 예를 들어, 사용자는 사용자 인터페이스와 같 은 사용자 인터페이스를 통해 제3자 API와 같은 제3자 API에 입력을 제공하여, 특정 피호출자 또는 피호출 자들의 특정 세트에 대한 호출들의 스케줄링 및 실행을 요청할 수 있다. 일부 실시예에서, 결정된 트리거 이벤트는 특정 유형의 이벤트이며, 이는 기상 이벤트, 스포츠 이벤트, 엔터테 인먼트 이벤트 또는 계절별 이벤트를 포함할 수 있다. 예를 들어, 이벤트 식별기는 찰스강 보트 경기(Head of the Charles regatta)가 매사추세츠 주 보스톤에서 개최됨을 판별할 수 있고, 그리고 이러한 이벤트 데이터를 트리거 모듈에 제공할 수 있다. 이후 트리거 모듈은 보트 경기(regatta)가 트리거 이벤트임을 결 정할 수 있다. 일부 실시예에서, 결정된 트리거 이벤트는, 검색 엔진에 제출된 검색 요청들에서 검출된 트렌드이다. 예를 들어, 트렌드 검출기는 검색 엔진으로부터 검색 엔진 데이터를 수신할 수 있으며 그리고 스페인 타파 스 레스토랑(Spanish tapas restaurant)이 트렌드임을 결정할 수 있다. 트렌드 검출기는 트렌드를 나타내 는 데이터를 트리거 모듈에 제공할 수 있고, 트리거 모듈은 트렌드가 트리거 이벤트임을 결정할 수 있다. 일부 실시예에서, 결정된 트리거 이벤트는 소정 시간 기간이 경과됨이다. 예를 들어, 불일치 검출기는 타 이머로부터의 지식 데이터베이스의 데이터에 기초하여, 뉴욕 맨해튼의 쿠바 레스토랑 메뉴가 4개월 동안 업데이트되지 않았음을 결정할 수 있다. 불일치 검출기는 타이밍 데이터를 트리거 모듈에 제공 할 수 있고 그리고 트리거 모듈은 맨해튼의 쿠바 레스토랑에 대한 메뉴 데이터가 업데이트없이 4개월이 경 과되었다는 것이 트리거 이벤트임을 결정할 수 있다. 그 후, 트리거 모듈은 업데이트된 메뉴 정보를 획득 하도록 맨하탄의 쿠바 레스토랑에 전화를 걸어야함을 제안하는 데이터를 플로우 관리자에 제공할 수 있다. 상기 프로세스는 결정된 트리거 이벤트에 기초하여 특정 워크플로우를 선택하는 단계를 포함할 수 있 다. 트리거 모듈은 트리거 이벤트 데이터를 다이얼러 또는 플로우 관리자에 제공하여, 특정 워 크 플로우 또는 워크 플로우 또는 노드를 선택하는데 사용할 수 있다. 예를 들어, 트리거 모듈은 샐리의 음식점에 대해 광고된 영업 시간들 간의 불일치를 나타내는 트리거 이벤트 데이터를 플로우 관리자에 제공 할 수 있으며, 상기 데이터를 이용하여 플로우 관리자는 이러한 불일치를 해결하도록 샐리의 음식점을 호 출하는 특정 워크플로우를 선택할 수 있다. 상기 프로세스는 상기 선택에 응답하여, 특정 워크플로우에 의해 특정된 피호출자에게 전화 통화를 개시하 는 단계를 포함할 수 있다. 플로우 관리자는 연락할 특정 피호출자를 나타내는 명령을 다이얼러(10 6)에 제공할 수 있다. 예를 들어, 플로우 관리자는 샐리의 음식점을 호출하기 위한 명령을 다이얼러 에 제공할 수 있다. 비록, 본 명세서에 개시된 시스템 및 방법에 의해서 워크플로우들을 개시하는 것, 보다 상세하게는 호출들을 하 는 것은, 트리거링 이벤트들에 의해서 상대적으로 자동화될 수 있지만, 원치않는 호출들 혹은 로컬 법규를 위반 하는 호출들을 방지하기 위하여, 세이프가드(safeguards)가 시스템에 포함될 수 있다. 예를 들어, 만일 피 호출자가 시스템으로부터의 전화들을 더 이상 수신하지 않기를 원한다면, 시스템은 이를 인식하고 그리고 후속 호출을 방지하기 위해 피호출자의 전화번호로 거는 호출들을 체크할 수 있다. 또한, 본 명세서에 서술된 시스템 및 방법이 데이터를 수집하는 한, 개인 식별 정보가 제거되거나 영구적으로 불명료해지도록, 상기 데이터는 저장 혹은 사용되기 전에 하나 이상의 방식으로 처리될 수 있다. 예를 들어, 피 호출자의 신원은 그 어떤 개인 식별 정보도 판별될 수 없도록 영구적으로 제거되거나 처리될 수 있으며, 또는 피호출자의 지리적 위치는 위치 정보가 획득된 곳에 대해서 일반화되므로, 사용자의 특정 위치가 적절히 결정될 수 없다. 워크플로우의 일부로서 요청되었거나, 피호출자에 의해서 자발적으로 제공되었거나, 또는 의도치않게 수신되었거나 기타 등등의 사유로 인하여 개인 정보, 사적인 정보, 또는 민감한 정보가 통화 도중에 수신되는 경우, 워크플로우는 시스템으로부터 이러한 정보를 영구적으로 제거하거나 난독화시키는 단계들을 포함할 수 있 다. 일부 일례에서, 시스템은 자동으로 또는 사용자의 요청에 따라, 작업 지원을 위한 요청을 실행하기 위한 노력의 현재 상태를 사용자에게 제공할 수 있다. 예를 들어, 시스템은 컴퓨터, 모바일 디바이스 등과 같은 사용자가 사용중인 디바이스 상에서의 통지를 통해, 수행중인 작업의 상태를 사용자에게 제공할 수 있다. 일부 일례들에서, 시스템은 메시징 어플리케이션과 같은 다른 수단을 통해, 전화 통신, 기타등등을 통해, 진행 중인 작업의 상태를 사용자에게 통지할 수 있다. 도 6은 시스템의 작업 관리자 모듈의 블록도이다. 작업 관리자 모듈은 통신 플랫폼, 트리 거 모듈, 작업 정보 저장소, 및 세션 저장소에 연결된다. 사용자가 통신 플랫폼을 통해 작업을 통신하는 경우, 작업 정보는 작업 정보 저장소에 저장되고, 작업 관리자 모듈은 작업이 언제 스케줄 링될지를 결정한다. 작업 관리자는 작업을 트리거 이벤트와 연관시킬 수 있다. 작업은 처음에 \"new\"로 설정되는 상태를 갖거나 또는 요청에 대한 프로세싱이 없었음을 나타내는 몇몇 다른 표시자로 설정되는 상태를 가질 수 있다. 트리거 이벤트가 발생하면, 트리거 모듈은 다이얼링 프로세스를 시작할 것이다. 일부 구현예에서,작업 관리자 모듈은 작업들의 상태가 시작(initiated)으로부터, 진행 중(in progress)으로, 완료 (complete)로 변경될 때 각 작업의 상태를 업데이트하도록 세션 저장소를 모니터링한다. 세션 정보로부터 작업 관리자 모듈은 각 통화의 상태와 결과를 결정할 수 있다. 예를 들어, 봇(bot)은 예약을 하기 위해 누군가와 통화를 하기 전에, 레스토랑에 여러 번 전화 통화를 시도할 수 있다. 세션 저장소는 봇이 수행한 각각의 호출에 대한 정보를 보유하고 있다. 일부 구현예에서, 작업 관리자 모듈은 호출 작업의 상태, 즉 호출이 초기화되었는지, 진행 중인지 또는 완료되었는지 여부를 결정하기 위해 주기적으로 세션 저장소를 폴링 할 수 있다. 다른 구현예에서, 세션 저장소는 작업 정보 저장소에서 작업의 상태를 업데이트하기 위해 작업 관 리자 모듈에게 호출의 결과를 전송할 수 있다. 일부 구현예에서는, 호출 작업들 및 작업들의 진행 상황에 대한 정보가 디스플레이되는 운영자 대시보드를 통해 운영자에 의해 호출이 검토된다. 도 7a는 기존의 호출 작업들의 진행 상황에 대한 정보를 나타내는 운영자 대시보드를 도시한다. 예를 들어, 도 7a는 이발 약속을 위한 작업을 도시한다. 운영자 대시 보드는 예약 시간, 요청자의 이름, 요청된 서비스, 사업 체 이름, 약속 날짜 및 시간을 포함하여 약속에 관한 정보를 제공할 수 있다. 운영자는 요청된 약속이 적절하게 예약되었는지를 결정하기 위하여, 요청들과 연관된 통화들로부터 요청들 및 관련 세션 정보를 검토할 수 있다. 도 7b는 사용자가 요청한 작업들 중 하나를 검토하기 위한 운영자 리뷰 스크린을 도시한다. 상기 스크린은 작업 의 현재 상태를 운영자에게 표시할 수 있다. 도 7b에 도시된 바와 같이, 예약이 이루어졌기 때문에 작업이 완료 된다. 하지만, 일부 경우들에서는, 작업이 완료되지 않으며 예약이 이루어지지 않았을 수도 있다. 운영자는 작 업과 관련된 녹음을 재생하거나, 녹음으로부터의 다른 저장된 정보(예컨대, 기록들(transcriptions), 추출된 인 텐트 등)를 보거나, 작업과 관련된 사업체를 호출하거나, 또는 향후 자동화된 호출을 스케줄링하거나 등의 옵션 을 가질 수도 있다. 또한, 운영자는 작업의 현재 상태를 요청 사용자에게 제공하는 옵션을 가질 수도 있다. 또한, 사용자는 통신 플랫폼을 통해 작업의 상태를 요청할 수도 있다. 추가적으로 또는 대안적으로, 작업 관리자 모듈은 작업 상태 변화나 시간 등과 같은 다른 트리거링 이벤트에 기초하여, 상태 업데이트를 사용 자에게 언제 전송할지를 결정할 수 있다. 도 8은 작업의 상태를 제공하는 프로세스의 일례를 도시하는 흐름도이다. 프로세스는 사용자 호출 요 청의 현재 상태를 제공하기 위해 트리거링 이벤트가 발생했는지를 작업 관리자 모듈에 의해 결정하는 단계(80 2)를 포함할 수 있다. 전술한 바와 같이, 트리거링 이벤트는 상태에 대한 사용자 요청, 일정 시간의 경과 또는 특정 작업의 상태 변화를 포함할 수 있다. 다음으로, 프로세스는 사용자 호출 요청의 현재 상태를 작업 관 리자 모듈에 의해 결정하는 단계를 포함한다. 작업 관리자 모듈은 작업 정보 저장소의 상태를 확인함으로 써 현재 상태를 결정할 수 있다. 작업의 상태는 작업 정보 저장소에 작업이 추가될 때 초기화된다. 작업과 관련된 호출이 수행 및 완료됨에 따라, 작업의 상태가 업데이트된다. 다음으로, 작업 관리자는 사용자 호출 요 청의 현재 상태에 대한 표현을 생성한다. 상기 표현은 작업의 현재 상태를 전달하는 시각적 표현 또는 음 성 표현일 수 있다. 프로세스는 사용자 호출 요청의 현재 상태에 대해 생성된 표현을 사용자에게 제공한다 . 도 9a는 약속 스케줄링이 진행되는 동안 도 1b의 이발 약속 요청의 시각적인 상태를 나타낸다. 사용자는 작업 요청의 상태를 검사하기 위해 사용자 인터페이스에 액세스할 수 있으며 또는, 스마트 폰, 스마트 시계, 랩톱, 퍼스널 홈 어시스턴트 디바이스 또는 다른 전자 장치와 같은 사용자 장치로 상태가 전송될 수 있다. 상태는 이 메일, SMS 또는 기타 메커니즘을 통해 전송될 수 있다. 도 9b는 일단 약속이 성공적으로 스케줄링된 후의 도 1b의 이발 약속 요청의 시각적인 상태를 나타낸다. 이러한 상태는 사용자에 의해 요청될 수 있으며, 또는 약속이 성공적으로 예약된 이후에는 사용자 프롬프팅이 없이도 사용자에게 전송될 수 있다. 도 10a는 도 1c의 레스토랑 예약 요청의 구술 상태 요청 및 업데이트를 도시한다. 도 10a에 도시된 바와 같이, 사용자가 레스토랑 예약이 이루어졌는지의 여부를 묻는 것에 응답하여, 시스템은 작업를 완료하기 위해 시스템 이 수행한 단계들(가령, 레스토랑에 2번 전화를 했다)을 설명할 수 있다. 또한, 상기 시스템은 다음 번에 시스 템이 호출을 시도할 때를 사용자에게 알릴 수 있으며 그리고 호출 시도 이후의 상태를 사용자에게 알릴 수 있다. 도 10b는 도 9의 레스토랑 예약 요청에 대한 사용자에 의한 프롬프팅없이 시스템에 의해 제공되는 구술 상태 업 데이트를 도시한다. 용자 작업이 완료되었음을 시스템이 알게되면 시스템은 사용자에게 상태 업데이트를 제공할수 있다. 일부 구현예에서, 시스템은 사용자에게 상태 업데이트를 즉시 제공한다. 다른 구현예에서, 시스템은 사용자에게 통지하기 위한 편리한 시간 또는 방법을 결정할 수 있다. 예를 들어, 사용자는 영국 런던에서 저녁 식사 예약을 요청할 수 있다. 그러나 현재 사용자는 미국 캘리포니아주 마운틴 뷰에 있을 수 있다. 시스템은 사 용자가 잠자고있는 시간에 레스토랑에 전화를 시도할 수 있다. 시스템이 런던에서 오후 12시에 예약을 확인한다 면, 상기 시스템은 PDT 오전 4시에 상태 업데이트 텍스트 메시지를 보내게 되면 사용자를 깨울 수 있다고 판단 할 수 있다. 그런 다음 시스템은 대안적인 상태 업데이트 방법(예컨대, 전자 메일)을 선택하거나 또는 사용자에 게 보다 편리한 시간 동안 상태 업데이트를 보류할 수 있다. 시스템은 사용자의 스케줄, 시간대(time zone), 습 관 또는 사용자의 기타 개인적인 정보로부터 정보를 사용하여 사용자에게 상태 업데이트를 제공하기 위한 적절 하고 편리한 시간들 및 방법을 결정할 수 있다. 일부 구현에서, 시스템은 작업의 긴급성을 결정하기 위해 또는 작업을 완료하기 위한 노력을 반복할 것인지를 결정하기 위해 사용자 정보를 사용할 수 있다. 예를 들어, 시스템은 사용자를 위해 캘리포니아주 마운틴 뷰에 있는 특정 레스토랑을 예약하려고 시도할 수 있다. 사용자의 마운틴 뷰(Mountain View)로의 여행은 5월 15일에 끝난다. 만일, 시스템이 5월 15일 당일에도 여전히 성공적이지 않다면, 5월 16일 또는 그 이후의 날짜에 대하여 시스템이 예약을 계속 요청하는 것은 이치에 맞지 않는데, 왜냐하면 사용자의 여행은 끝날 것이기 때문이다. 하 지만, 레스토랑의 누군가와 연락이 되어 예약을 하기 위하여, 앞선 날짜들에 비하여 5월 14일에 2배 정도 자주 전화를 하는 것은 바람직하다. 데드라인이 다가옴에 따라 작업(task)은 더 긴급해지며, 데드라인이 지나면 덜 긴급해지거나 혹은 쓸모가 없게 된다. 일부 구현예에서, 도 1b의 긴급 구제 모듈은 통화가 진행되는 동안 통화에 대해 도입되어야하는 개입 (intervention)의 유형을 결정한다. 긴급 구제 모듈은 실시간으로 봇 대화를 수동으로 긴급 구제하도록 선 택할 수 있으며 그리고 다른 이(another)가 통화를 대신할 것이라고 설명할 수 있다. 다른 구현예들에서, 상기 모듈은 인간 운영자(human operator)가 자동으로 통화를 인수하는 것을 허용할 수 있다. 부가적으로 또는 대안 적으로, 긴급 구제 모듈은 수동 개입없이 봇과 인간 사이의 전화 통화를 공손하게 종결할 수도 있다. 도 11은 봇으로부터 인간으로 전화 호출을 전환시키는 예시적인 프로세스를 도시한다. 상기 프로세스 는 호출 개시 시스템에 의해서, 전화 통화의 제 1 측에 있는 제 1 사람과 전화 통화의 제 2 측에 있는 봇 간의 전화 통화 동안에 상기 제 1 사람과 봇 간의 실시간 대화를 분석하는 단계를 포함할 수 있다. 다음 으로, 호출 개시 시스템은 실시간 대화에 대한 분석에 기초하여, 상기 봇으로부터 상기 제 2 측에 있는 제 2 사 람으로 전화 통화가 전환되어야 하는지의 여부를 결정할 수 있다. 전화 통화가 상기 제 2 측에 있는 제 2 사람 으로 전환되어야 한다는 결정에 응답하여, 상기 호출 개시 시스템에 의하여, 전화 통화가 봇으로부터 상기 제 2 사람으로 전환된다. 특정 봇 전화 통화에 가장 적합한 개입의 유형을 결정하기 위해, 긴급 구제 모듈은 스트레인 이벤트 (strain event)를 식별하거나 또는 통화가 종료되어야 하거나 또는 인간 운영자에게로 넘겨져야함을 나타내는 다른 징후들을 찾을 수 있다. 일부 구현예에서, 긴급 구제 모듈은 인간의 질문에 적절하게 응답하기 위하여, 인간에 대한 스트레인 또는 봇에 대한 스트레인을 나타내는 스트레인 이벤트를 식별한다. 긴급 구제 모듈이 스트레인 이벤트를 식별할 때마다, 그것은 호출의 로컬 및 글로벌 스트레인 둘다의 저장된 레벨들을 증가시킨다. 대화가 다시 진행되는 것 처럼 보일 때마다 긴급 구제 모듈은 로컬 스트레인 레벨을 재설정한다. 예를 들어, 6명 예약을 하기 위해 레스토랑에 봇이 전화를 걸었을 때, 인간은 봇에게 \"유아용 의자(highchair)가 얼마나 많이 필요한가요?\"라고 질문할 수 있다. 봇은 \"우리 모두는 의자가 필요하다(we all need chairs)\" 라고 응답할 수 있다. 인간은 봇의 응답 때문에 약간 짜증내는 음색을 가질 수 있으며 그리고 \"네, 당신들이 의자가 필요한 것은 알고 있지만, 아 기들을 위한 유아용 의자가 얼마나 많이 필요합니까?(Yes, I know you all need chairs, but how many high chairs for babies do you need?)\" 와 같이 응답할 수 있다. 시스템은 억양 패턴(intonation pattern), 즉 인 간의 진술의 시작 부분, 진술의 마지막 부분 또는 진술 전체에서 더 높은 음조를 감지할 수 있다. 일부 구현예 에서, 억양 패턴은 스트레스 또는 짜증(irritation)과 미리 연관되어 있다. 시스템은 미리 연관된 패턴과 실시 간 대화에서 탐지된 패턴을 매칭시킬 수 있다. 일부 구현예에서, 억양 패턴은 반복되는 단어들, 의도적으로 느 리게 말하는 것, 키워드들 혹은 문구들(\"너 내 말을 듣고 있기는 한거니?(are you even listening to me?)\" , \"내가 지금 로봇과 말하고 있나?(am I talking to a robot?)\")을 검출할 수 있다. 인간의 약간 짜증내는 음색을 시스템이 검출하는 경우, 시스템은 전화 통화의 로컬 스트레인 레벨을 증가시킨다. 로컬 스트레인은 현재 상태와 관련된 스트레인의 가능한 분량을 반영하는 러닝 스코어(runningscore)이다. 실시간 대화 내에서 임의의 스트레인 지표가 인간의 진술에 등장하면, 스트레인 점수는 상기 점수 가 개입 임계값에 도달할 때까지 증가한다. 그 어떤 스트레스 지표도 등장하지 않는다면, 시스템은 상기 호출이 워크플로우에 따라 진행중임을 나타낼 수 있으며 그리고 로컬 스트레인 점수는 감소하거나 또는 낮게(예컨대, 0 으로) 유지될 수 있다. 가령, \"우리 일행에는 아이들이 없다\"와 같이, 인간이 예측하는 응답을 제공함으로써 상 기 봇이 질문에 적절히 대응한다면, 시스템은 로컬 스트레인을 감소시킬 수 있다. 만일, 인간이 그 혹은 그녀의 목소리에서 아무 짜증없이 응답하고 있음을 시스템이 검출한다면, 긴급 구제 모듈은 대화가 다시 진행되는 것으 로 판단할 수 있으며 그리고 로컬 스트레인을 디폴트 값으로 리셋하거나 또는 0 으로 리셋할 수 있다. 전화 호출에 대한 글로벌 스트레인은 오직 누적만 된다. 로컬 스트레인은 인간과의 현재의 교신 (correspondence)이 스트레스 상태인지의 여부를 평가하려고 시도하는 반면에, 글로벌 스트레인은 호출 전체의 총 스트레인을 평가하려고 시도한다. 예를 들어, 상기 봇이 인간 운영자에 의해 긴급 구제되기 전에, 3 개의 착 오들(misunderstanding)에 대해서 임계값이 설정될 수 있다. 만일, 상기 봇이 인간을 3번 연속으로 이해하지 못 했다면, 로컬 스트레인이 높아질 것이며 그리고 상기 봇이 긴급 구제될 것이다. 다른 호출에서, 만일, 상기 봇 이 상대방을 두 번 연속으로 이해하지 못했지만 세 번째 문장을 이해했다면, 로컬 스트레인은 세번째 상호작용 에 대해서 리셋될 것이며, 대화는 아마도 계속될 것이다. 글로벌 스트레인은 상기 봇과 인간 사이에서 2개의 착 오들이 있었음을 나타내는 정보를 여전히 유지한다. 만일, 상기 호출 동안의 후속 시간에서 상기 봇이 다시한번 인간을 연속으로 2번 이해하지 못한다면, 글로벌 스트레인 레벨은 임계값 이상으로 올라갈 것이고, 상기 봇은 아마도 긴급 구제될 것이다(비록, 로컬 스트레인은 3개의 착오들에 대해 설정된 임계값 보다 여전히 아래이지만). 전술한 바와 같이, 로컬 스트레인 레벨 또는 글로벌 스트레인 레벨 중 어느 하나가 소정의 임계값에 도달하면, 긴급 구제 모듈은 수동 개입을 할 때가 되었음 혹은 통화를 정중하게 종료할 시간이 되었음을 시스템(11 0)에게 알려줄 것이다. 일부 일례들에서, 긴급 구제 모듈은 자체적으로 반복할 필요가 있거나, 사과를 하 거나, 설명을 요청할 필요가 있거나 기타 등등 뿐만 아니라, 인간이 시스템을 정정하거나 혹은 통화에 대 하여 불평할 때(당신 말을 못 알아듣겠다. 내 말이 들리느냐?(I can't hear you, can you hear me?), 이벤트를 스트레인 이벤트로 간주할 것이다. 일부 일례들에서, 긴급 구제 모듈은 만일, 인간이 봇이 로봇인지를 질문하거나, 예컨대, 황당한 (nonsensical) 질문을 하여 봇을 조롱하거나, 또는 시스템이 예측하지 못하는 다른 방식으로 행동한다면(예를 들어, 시스템이 레스토랑 예약시에 스포츠 경기에 대해서 질문받는 경우), 이벤트를 스트레인 이벤트로 간주할 것이다. *일부 구현예에서, 긴급 구제 모듈은 시스템이 언제 수동 개입을 구제해야 하는지를 결정하는 피처-기반 규칙 세트(feature-based rule set)이다. 하나의 피처-기반 규칙은, 2개의 연속되는 미지의(unknon) 입력 인텐 트가 발생할 때 시스템이 긴급 구제되어야한다고 규정하는 규칙일 수 있다. 다른 규칙은, 통화 중 임의의 지점 에서 4개의 미지의(unknon) 입력 인텐트가 발생하는 경우, 시스템이 수동 조작원에게 긴급 구제되어야 한다고 규정할 수 있다. 시스템은 대화에서 발생하는 이벤트를 추적하고, 그리고 규칙의 기준을 충족하는 이벤트들이 발생했는지를 판별한다. 다른 구현예에서, 긴급 구제 모듈은 언제 자동으로 인간 운영자에 의해 긴급 구제될지를 예측하기 위해 머 신 학습을 사용한다. 예를 들어, 긴급 구제 모듈은 하나 이상의 머신 학습 모델에 대한 입력으로서 인간과 의 대화로부터의 인텐트를 수신할 수 있다. 머신 학습 모델은 수신된 인텐트와 역사적 인텐트 및 결과에 따라 인간 운영자에 의해 긴급 구제될지의 여부를 결정할 수 있다. 시스템은 긴급 구제가 발생했어야 했는지 또는 발 생해서는 안됐는지를 나타내는 주석 기록들로부터의 피처들에 대해서 머신 학습 모델을 트레이닝할 수 있다. 이 후 머신 학습 모듈은 일련의 입력 피처들이 주어지면 긴급 구제가 언제 발생해야하는지를 예측할 수 있다. 긴급 구제 모듈은 인간의 행위, 인간의 음색, 인간의 판별된 짜증 레벨(annoyance level), 인간이 사용하 는 언어 또는 인간의 단어 선택을 포함하는 많은 인자들을 이용하여, 긴급 구제 여부를 판별한다. 시스템은 봇에 의해 수행되는 대화를 인간 운영자에게로 처리를 위해 이관할 수 있다. 예를 들어, 특정 대화에 임계 분량의 스트레인이 있으면, 긴급 구제 모듈은 피드백 데이터를 플로우 관리자에 제공할 수 있다. 플로우 관리자는 인간 피호출자에 청각적으로 경고하거나 경고함이 없이, 운영자 제어기를 통 해 입력을 제공하는 인간 운영자에게 통화를 넘겨주도록 봇에게 지시할 수 있다. 예를 들어, 봇은 다음과 같이말할 수 있다: \"알겠습니다, 오늘 시간을 내주셔서 감사합니다. 이분은 저의 감독관입니다.(Sure, thank you for your time today. Here is my supervisor.)\" 이후, 인간 운영자는 봇이 수행하고자 했던 작업을 운영자 제 어기를 통해 마무리할 수 있다. 또한, 긴급 구제 모듈은, 달성되고 있는 현재 작업에 대해서 시스템이 갖는 신뢰도를 정의하는 신뢰도 레 벨을 결정할 수 있다. 예를 들어, 사용자를 위해 저녁 식사 예약을 하는 작업이 봇에게 주어질 수 있다. 봇이 레스토랑에 전화를 걸고 그리고 봇이 대답을 모르는 여러 개의 문의들을 인간이 질문한 경우, 시스템은 수행중 인 현재 작업에 대해 낮은 신뢰도를 가질 수 있다. 시스템이 정답을 알지 못하는 질문을 시스템이 받은 후에, 작업 수행에 대한 시스템의 신뢰도 레벨은 낮아질 수 있다. 만일, 시스템이 복구되고 그리고 작업을 완료하는 쪽으로 대화가 진행되고 있다라고 시스템이 판단하는 경우, 상기 시스템은 신뢰도 레벨을 높일 수 있다. 일부 구현에서, 시스템은 호출들을 모니터링하는 인간 운영자에게 전화 통화를 핸드 오프한다. 시스템은 운영자 사용자 인터페이스 또는 일부 다른 통지 메커니즘을 사용하여 전화 통화를 전환할 필요성을 운영자에게 경고할 수 있다. 일단 통보되면, 운영자는 시스템이 전화를 종료하기로 결정하기 전까지 전화 통화를 전환할 유한 시간 을 가질 수 있다. 시스템에서 운영자와 동일한 음성을 사용할 수 있다. 이 경우, 음성이 동일하게 유지되므로 봇에서 운영자로의 전환은 다른 쪽에서도 투명해질 수 있다. 다른 구현에서, 시스템은 작업을 요청한 인간 사용자에게 전화 통화를 핸드 오프할 수 있다. 시스템은 진행중인 전화 통화를 사용자에게 경고할 수 있다. 시스템은, 작업을 완료하는데 있어서 문제가 언제 발생했는지 또는 봇 이 정답을 모르는 질문을 봇이 언제 문의받았는지를 사용자에게 알려줄 수 있다. 상기 봇은 봇이 사용자 입력을 필요로 하는 대화의 세부 정보를 텍스트, 전자 메일 또는 일부 다른 방법으로 통신할 수 있다. 일부 구현예에서, 봇은 사용자 입력없이 대화를 계속하기 전에 사용자가 응답하기 위한 임계 시간(예컨대, 5 초)을 기다릴 것이다. 대화가 실시간으로 진행되기 때문에, 상기 봇은 사용자 응답을 위해 오랜 시간 동안 기다릴 수 없다. 일부 구현예에서, 시스템은, 전화 통화가 봇으로부터 전환될 필요가 있다고 시스템이 판정한 경우, 요청 사용자에게 전화 통화를 전환하려고 시도할 수 있다. 전술한 바와 같이, 시스템은 사용자가 응답하고 전화 통화 를 넘겨받기 위하여, 임계 시간을 기다릴 수 있다. 일부 구현예에서, 임계 시간 내에 사용자가 전화 통화를 넘 겨받지 않는다면, 시스템은 전화 통화를 운영자에게로 전환할 것이다. 다른 경우, 시스템은 전화 통화를 종료할 것이다. 또한, 시스템은 인간 사용자와 동일한 음성을 사용할 수도 있으므로 봇으로부터 사용자로의 전환은 대 화의 타측 상대방에게 원활하게(seamless) 이루어진다. 도 12는 상술한 기술들을 구현하는데 사용될 수 있는 컴퓨팅 디바이스의 일례 및 모바일 컴퓨팅 디바이스 의 일례를 도시한다. 컴퓨팅 디바이스는 랩탑, 데스크탑, 워크 스테이션, 개인용 디지털 보조 디바 이스, 서버, 블레이드 서버, 메인 프레임 및 다른 적절한 컴퓨터와 같은 다양한 형태의 디지털 컴퓨터를 나타내 기 위한 것이다. 모바일 컴퓨팅 디바이스는 개인 휴대 정보 단말기, 셀룰러 전화기, 스마트 폰 및 다른 유사한 컴퓨팅 디바이스와 같은 다양한 형태의 모바일 디바이스를 나타내기 위한 것이다. 여기에 도시된 구성요 소들, 이들의 접속 및 관계, 및 그 기능은 단지 예시적인 것을 의미하며, 본 명세서에 기재된 및/또는 청구된 발명의 구현예들을 제한하는 것을 의미하지는 않는다. 컴퓨팅 디바이스는 프로세서, 메모리, 저장 디바이스, 메모리 및 다수의 고속 확장 포트에 연결되는 고속 인터페이스, 그리고 저속 확장 포트 및 저장 디바이스에 연결되는 저속 인터페이스를 포함한다. 프로세서, 메모리, 저장 디바이스, 고속 인터 페이스, 고속 확장 포트, 및 저속 인터페이스 각각은 다양한 버스들을 사용하여 상호접속되 고, 공통 마더보드 상에 또는 적절하게 다른 방식으로 마운트될 수 있다. 프로세서는 메모리 또는 저장 디바이스에 저장된 명령을 포함하여, 컴퓨팅 디바이스 내에서의 실행을 위해 명령들을 프로세싱하여, 고속 인터페이스에 접속된 디스플레이와 같은 외부 입/출력 디바이스 상에 GUI를 위한 그래픽 정보를 디스플레이한다. 다른 구현예에서는, 다수의 메모리들 및 메 모리 유형들과 함께, 다수의 프로세서들 및/또는 다수의 버스들이 적절하게 사용될 수 있다. 또한, 다수의 컴퓨 팅 디바이스들이 연결될 수도 있는바, 여기서 각각의 디바이스는 필요한 연산들의 일부분을 제공한다(예를 들어, 서버 뱅크, 블레이드 서버들의 그룹 또는 멀티 프로세서 시스템으로서). 메모리는 컴퓨팅 디바이스 내에 정보를 저장한다. 일 실시예에서, 메모리는 휘발성 메모리 유닛(들)이다. 또 다른 구현예에서, 메모리는 비휘발성 메모리 유닛(들)이다. 또한, 메모리는 자기 또는 광학 디스크와 같은 다른 형태의 컴퓨터 판독가능 저장매체일 수 있다. 저장 디바이스는 대용량 저장소를 컴퓨팅 디바이스에 제공할 수 있다. 일 구현예에서, 저장 디바이 스는 플로피 디스크 디바이스, 하드 디스크 디바이스, 광 디스크 디바이스 또는 테이프 디바이스, 플래시 메모리 또는 다른 유사한 고체 상태 메모리 디바이스, 또는 저장 영역 네트워크 또는 다른 구성의 디바이스들을 포함하는 디바이스들의 어레이 등과 같은 컴퓨터 판독가능 매체이거나 이를 포함할 수 있다. 컴퓨터 프로그램 제품은 정보 캐리어에 유형적으로 구현될 수 있다. 또한, 컴퓨터 프로그램 제품은 실행될 때, 전술한 바와 같은 하나 이상의 방법들을 수행하는 명령들을 포함할 수 있다. 또한, 컴퓨터 프로그램 제품은 메모리, 저장 디바이스 또는 프로세서 상의 메모리와 같은, 컴퓨터-판독가능 또는 머신-판독가능한 매체에 유형 적으로 구현될 수 있다. 고속 인터페이스는 컴퓨팅 디바이스를 위해, 대역폭-집중형 연산들을 관리하고, 저속 인터페이스 는 낮은 대역폭-집중형 연산들을 관리한다. 기능들의 이러한 할당은 단지 예시일 뿐이다. 일 구현예에서, 고속 인터페이스는 메모리, 디스플레이(예를 들어 그래픽 프로세서 또는 가속기를 통해)에 접속되며, 그리고 다양한 확장 카드(미도시)를 수용할 수 있는 고속 확장 포트에 접속된다. 일 구현예에 서, 저속 인터페이스는 저장 디바이스 및 저속 확장 포트에 접속된다. 다양한 통신 포트들 (예를 들어, USB, 블루투스, 이더넷, 무선 이더넷)를 포함하는 저속 확장 포트는 키보드, 포인팅 디바이 스, 스캐너와 같은 하나 이상의 입력/출력 디바이스에 접속되거나 또는 네트워크 어댑터를 통해 스위치 또는 라 우터와 같은 네트워킹 디바이스에 접속될 수 있다. 컴퓨팅 디바이스는 도면에 도시된 바와 같이 다수의 상이한 형태로 구현될 수 있다. 예를 들어, 표준 서 버로서 구현되거나, 또는 그러한 서버들의 그룹에서 여러 번 구현될 수도 있다. 또한, 랩탑 컴퓨터와 같 은 개인용 컴퓨터로 구현될 수도 있다. 또한, 랙 서버(rack server) 시스템의 일부로서 구현될 수도 있다. 대안적으로, 컴퓨팅 디바이스의 구성 요소들은 가령, 모바일 컴퓨팅 디바이스와 같은 모바일 디바이스(미도시)의 다른 구성요소들과 결합될 수 있다. 이러한 디바이스들 각각은 하나 이상의 컴퓨팅 디바이 스 및 모바일 컴퓨팅 디바이스를 포함할 수 있으며, 그리고 전체 시스템은 서로 통신하는 다수의 컴퓨팅 디바이스로 구성될 수 있다. 모바일 컴퓨팅 디바이스는 다른 구성요소들 중에서 프로세서, 메모리, 디스플레이와 같은 입/출력 디바이스, 통신 인터페이스 및 송수신기를 포함한다. 모바일 디바이스에는 추 가 저장소를 제공하기 위해 마이크로 드라이브 또는 다른 디바이스와 같은 저장 디바이스가 제공될 수 있다. 프 로세서, 메모리, 디스플레이, 통신 인터페이스 및 송수신기 각각은 다양한 버스 를 사용하여 상호접속되고, 구성요소들 중 몇몇은 공통 마더 보드 상에 또는 적절하게 다른 방식으로 마운트될 수 있다. 프로세서는 메모리에 저장된 명령들을 포함하여, 컴퓨팅 디바이스 내의 명령들을 실행할 수 있다. 프로세서는 개별적인 다수의 아날로그 및 디지털 프로세서들을 포함하는 칩들의 칩셋으로서 구현될 수 있 다. 프로세서는 예를 들어 사용자 인터페이스들의 제어, 모바일 디바이스에 의해 실행되는 어플리케이션 들 및 모바일 디바이스에 의한 무선 통신과 같은 모바일 디바이스의 다른 구성요소들 간의 조정을 제공할 수 있다. 프로세서는 제어 인터페이스 및 디스플레이에 연결된 디스플레이 인터페이스를 통해 사용자와 통신할 수 있다. 디스플레이는 예를 들어, TFT LCD(박막 트랜지스터 액정 디스플레이) 또는 OLED(Organic Light Emitting Diode: 유기 발광 다이오드) 디스플레이, 또는 다른 적절한 디스플레이 기술을 이용할 수 있다. 디스플레이 인터페이스는 사용자에게 그래픽 및 다른 정보를 제공하기 위해 디스플레이 를 구동하기 위한 적절한 회로를 포함할 수 있다. 제어 인터페이스는 사용자로부터 커맨드들을 수 신하고 그리고 프로세서에 제출하기 위해 이들을 변환할 수 있다. 또한, 프로세서와 통신하기 위해 외부 인터페이스가 제공되는바, 다른 디바이스들과 모바일 디바이스의 근거리 통신이 가능해진다. 예를 들어, 외부 인터페이스는 일부 구현에서는 유선 통신을 제공하고, 다른 구현예에서는 무선 통신을 제공할 수 있으며, 다중 인터페이스들이 또한 사용될 수 있다. 메모리는 모바일 컴퓨팅 디바이스 내에 정보를 저장한다. 메모리는 컴퓨터 판독가능 매체(들), 휘발성 메모리 유닛(들) 또는 비휘발성 메모리 유닛(들) 중 하나 이상으로서 구현될 수 있다. 또한, 예를 들어 SIMM(Single In Line Memory Module) 카드 인터페이스를 포함할 수 있는 확장 인터페이스를 통해 확장 메모리가 모바일 디바이스에 제공되고 접속될 수 있다. 이러한 확장 메모리는 여 분의 저장 공간을 모바일 디바이스에 제공할 수 있으며, 또는 모바일 디바이스를 위한 어플리케이션들 혹은 다른 정보를 저장할 수도 있다. 특히, 확장 메모리는 전술한 프로세스들을 수행하거나 보충하 기 위한 명령들을 포함할 수 있고, 또한 보안 정보를 포함할 수 있다. 따라서, 예를 들어, 확장 메모리는 모바일 디바이스에 대한 보안 모듈로서 제공될 수 있고, 모바일 디바이스의 보안 사용을 허용하는 명령들로 프로그램될 수 있다. 또한, 보안 어플리케이션은 SIMM 카드를 통해 제공될 수 있는데 가령, 식별 정보 를 해킹불가능한 방식으로 SIMM 카드에 배치하는 것과 같이 추가 정보와 함께 제공될 수 있다. 메모리는, 예를 들어, 후술되는 바와 같이, 플래시 메모리 및/또는 NVRAM 메모리를 포함할 수 있다. 일 실시예 에서, 컴퓨터 프로그램 제품은 정보 캐리어에 유형적으로 구현된다. 컴퓨터 프로그램 제품은 실행될 때 전술한 방법들과 같은 하나 이상의 방법들을 수행하는 명령들을 포함한다. 예를 들어, 컴퓨터 프로그램 제품은 가령, 메모리, 확장 메모리 또는 프로세서 상의 메모리 등에 저장되는 컴퓨터 판독가능 또는 머신 판독가능한 매체일 수 있다. 일부 구현예에서, 컴퓨터 프로그램 제품은 송수신기 또는 외부 인터페이스 를 통해 전파된 신호에서 수신될 수 있다. 모바일 컴퓨팅 디바이스는 필요한 경우 디지털 신호 처리 회로를 포함할 수 있는 통신 인터페이스 를 통해 무선으로 통신할 수 있다. 통신 인터페이스는 GSM 음성 호출, SMS, EMS 또는 MMS 메시징, CDMA, TDMA, PDC, WCDMA, CDMA2000 또는 GPRS와 같은 다양한 모드들 또는 프로토콜들 하에서 통신을 제공할 수 있다. 이러한 통신은 예를 들어 무선 주파수를 이용하여 송수신기를 통해 수행될 수 있다. 또한, 블루투스, Wi- Fi 또는 다른 트랜시버(미도시)를 사용하여 단거리 통신이 수행될 수 있다. 또한, GPS(Global Positioning System) 수신기 모듈은 추가적인 네비게이션-관련 및 위치-관련 무선 데이터를 모바일 컴퓨팅 디바이스 에 제공할 수 있는바, 이는 모바일 컴퓨팅 디바이스 상에서 구동되는 어플리케이션들에 의해 적절 히 사용될 수 있다. 또한, 모바일 컴퓨팅 디바이스는 오디오 코덱을 사용하여 청각적으로 통신할 수 있는바, 이는 사용 자로부터 음성 정보를 수신하고 이것을 이용가능한 디지털 정보로 변환할 수 있다. 이와 유사하게, 오디오 코덱 은, 예를 들어 모바일 컴퓨팅 디바이스의 핸드셋 내의 스피커를 통하는 것과 같이, 사용자를 위한 가청 사운드를 생성할 수 있다. 이러한 사운드는 음성 전화 호출로부터의 사운드를 포함할 수 있고, 기록된 사 운드(예를 들어, 음성 메시지들, 음악 파일들 기타 등등)를 포함할 수 있으며 그리고 모바일 컴퓨팅 디바이스 상에서 동작하는 어플리케이션에 의해 생성된 사운드를 또한, 포함할 수 있다. 모바일 컴퓨팅 디바이스는 도면에 도시된 바와 같이 다수의 상이한 형태들로 구현될 수 있다. 예를 들어, 디바이스는 셀룰러 전화로서 구현될 수 있다. 또한, 스마트 폰, 개인 휴대 정보 단말기(personal digital assistant), 또는 다른 유사한 모바일 디바이스의 일부로서 구현될 수도 있다. 다수의 구현예들이 설명되었다. 그럼에도 불구하고, 본 개시 내용의 사상 및 범위를 벗어나지 않고 다양한 변형 들이 이루어질 수 있음을 이해할 것이다. 예를 들어, 앞서 도시된 플로우들의 다양한 형태가 단계들이 재배열, 추가 또는 제거되어 함께 사용될 수 있다. 본 명세서에 서술된 기능적 동작들 모두는 디지털 전자 회로로 구현될 수 있고, 또는 본 명세서에 개시된 구조 들 및 이들의 구조적 균등물을 포함하여 컴퓨터 소프트웨어, 펌웨어, 또는 하드웨어에서, 또는 하나 또는 그 이 상을 조합하여 구현될 수 있다. 본 명세서에 개시된 기술은 하나 이상의 컴퓨터 프로그램 제품, 즉 데이터 프로 세싱 장치에 의해 실행되거나 데이터 프로세싱 장치의 동작을 제어하기 위해 컴퓨터 판독 가능 매체 상에 인코 딩된 컴퓨터 프로그램 명령의 하나 이상의 모듈로서 구현될 수 있다. 컴퓨터 판독가능 매체는 머신 판독가능 저 장 디바이스, 머신 판독가능 저장 기판, 메모리 디바이스, 머신 판독가능 전파 신호에 영향을 미치는 물질의 조 성물, 또는 이들 중 하나 이상의 조합일 수 있다. 컴퓨터 판독가능 매체는 비일시적인 컴퓨터 판독가능 매체일 수 있다. \"데이터 프로세싱 장치\"라는 용어는 예를 들어 프로그램가능 프로세서, 컴퓨터, 또는 복수의 프로세서 또는 컴퓨터를 포함하는, 데이터를 처리하기 위한 모든 장치, 디바이스 및 머신을 포괄한다. 상기 장치는 하드 웨어 이외에도, 문제의 컴퓨터 프로그램을 위한 실행 환경을 생성하는 코드, 예컨대, 프로세서 펌웨어, 프로토 콜 스택, 데이터베이스 관리 시스템, 운영 체제, 또는 이들의 조합을 구성하는 코드를 포함할 수 있다. 전파된 신호는 인위적으로 생성된 신호, 예를 들어 적절한 수신기 장치로 전송하기 위해 정보를 인코딩하기 위해 생성 된 머신-생성 전기, 광학 또는 전자기 신호이다. 컴퓨터 프로그램(또한 프로그램, 소프트웨어, 소프트웨어 응용 프로그램, 스크립트, 또는 코드라고도 함)은, 컴 파일 또는 해석 언어를 포함하는 임의의 형태의 프로그래밍 언어로 기록될 수 있으며 그리고 독립형 프로그램 또는 컴퓨팅 환경에서 사용하기에 적합한 모듈, 구성요소, 서브 루틴 또는 기타 유닛들을 포함하는 임의의 형태 로 배치될 수 있다. 컴퓨터 프로그램이 반드시 파일 시스템의 파일과 대응하지는 않는다. 프로그램은 다른 프로그램이나 데이터를 갖는 파일의 일부분에 저장되거나(예: 마크 업 언어 문서에 저장된 하나 이상의 스크립트), 문제의 프로그램에 전용되는 파일에 저장되거나 또는 여러 개의 조정 파일들(예: 하나 이상의 모듈, 하위 프로 그램 또는 코드의 일부를 저장하는 파일들)에 저장될 수 있다. 컴퓨터 프로그램은 하나의 컴퓨터 상에서 실행되 거나 또는 한 장소에 있거나 혹은 여러 장소에 분산되어 있으며 통신 네트워크로 상호연결된 여러 대의 컴퓨터 상에서 실행될 수도 있다. 본 명세서에 서술된 프로세스들 및 로직 플로우는, 입력 데이터 상에서 동작하고 출력을 생성함으로써 기능을 수행하는 하나 개 이상의 컴퓨터 프로그램을 실행하는 하나 이상의 프로그래밍가능한 프로세서에 의해 수행될 수 있다. 프로세스 및 논리 흐름은 또한 FPGA(필드 프로그램가능 게이트 어레이) 또는 ASIC(주문형 집적회로)과 같은 특수 목적의 논리 회로에 의해 수행될 수도 있고 상기 장치는 이러한 특수 목적 논리 회로로 구현될 수 있 다. 컴퓨터 프로그램의 실행에 적합한 프로세서들은, 예로서, 범용 및 특수 목적 마이크로 프로세서, 디지털 컴퓨터 의 임의의 종류의 하나 이상의 프로세서들을 포함할 수 있다. 일반적으로, 프로세서는 판독 전용 메모리 또는 랜덤 액세스 메모리 또는 둘 모두로부터 명령 및 데이터를 수신할 것이다. 컴퓨터의 필수 구성요소는 명령을 수 행하기 위한 프로세서와 명령 및 데이터를 저장하기 위한 하나 이상의 메모리 디바이스이다. 일반적으로, 컴퓨 터는 또한 자기, 광 자기 디스크 또는 광학 디스크와 같은 데이터를 저장하기 위한 하나 이상의 대용량 저장 장 치로부터 데이터를 수신하거나 전송하기 위해 이에 동작가능하게 결합될 것이다. 그러나 컴퓨터에는 이러한 디 바이스들을 반드시 가질 필요는 없다. 또한, 컴퓨터는 태블릿 컴퓨터, 모바일 전화, 개인 휴대 정보 단말기 (PDA), 모바일 오디오 플레이어, GPS(Global Positioning System) 수신기와 같은 다른 장치에 내장될 수 있다. 컴퓨터 프로그램 명령 및 데이터를 저장하기에 적합한 컴퓨터 판독가능 매체는, 예를 들어 EPROM, EEPROM 및 플 래시 메모리 디바이스와 같은 반도체 메모리 디바이스, 자기 디스크, 내부 하드 디스크 또는 이동식 디스크, 광 -자기 디스크 및 CD-ROM 및 DVD-ROM 디스크를 포함하는, 모든 형태의 비 휘발성 메모리, 매체 및 메모리 장치를 포함한다. 프로세서 및 메모리는 특수 목적 논리 회로에 의해 보충되거나 또는 그 안에 포함될 수 있다. 사용자와의 상호 작용을 제공하기 위해, 본 명세서에 서술된 시스템들 및 기술들은 컴퓨터 상에서 구현될 수 있 는바, 이러한 컴퓨터는 사용자에게 정보를 디스플레이하기 위한 디스플레이 디바이스(예를 들어, CRT 또는 LCD 모니터)와 사용자가 컴퓨터에 입력을 제공할 수 있는 키보드 및 포인팅 디바이스(예를 들어, 마우스 또는 트랙 볼)를 갖는다. 사용자와의 상호작용을 제공하는데 다른 종류의 디바이스들이 사용될 수 있다. 예를 들어, 사용 자에게 제공되는 피드백은 임의의 형태의 감각 피드백(예를 들어, 시각적 피드백, 청각 피드백 또는 촉각 피드 백)일 수 있다. 그리고 사용자로부터의 입력은 음향, 음성 또는 촉각 입력을 포함하는 임의의 형태로 수신될 수 있다. 구현예들은 컴퓨팅 시스템을 포함할 수 있고, 컴퓨팅 시스템은 백 엔드 구성 요소(예컨대, 데이터 서버)를 포함 하거나, 또는 미들웨어 구성 요소(예컨대, 응용 프로그램 서버)를 포함하거나, 또는 프론트 엔드 구성 요소(예 컨대, 사용자가 여기에 설명된 시스템 및 기술의 구현과 상호작용할 수 있는 그래픽 사용자 인터페이스 또는 웹 브라우저가 있는 클라이언트 컴퓨터)를 포함하거나, 또는 이러한 백 엔드, 미들웨어 또는 프론트 엔드 구성요소 들의 임의의 조합을 포함할 수 있다. 시스템의 구성요소들은 디지털 데이터 통신의 임의의 형태 또는 매체(예컨 대, 통신 네트워크)에 의하여 상호연결될 수 있다. 통신 네트워크의 일례는, 근거리 통신망(LAN), 광대역 통신 망(WAN), 및 인터넷을 포함한다. 컴퓨팅 시스템은 클라이언트들 및 서버들을 포함할 수 있다. 클라이언트와 서버는 일반적으로 서로 멀리 떨어져 있으며, 통신 네트워크를 통해 상호작용하는 것이 통상적이다. 클라이언트와 서버의 관계는 각각의 컴퓨터에서 실행되고 서로 클라이언트-서버 관계를 갖는 컴퓨터 프로그램의 덕택으로 발생한다. 본 명세서는 많은 세부 내용들을 포함하지만, 이것들은 제한하는 것으로 해석되어서는 안되며, 오히려 특정 구 현예에 특화된 피처들에 대한 설명으로 이해되어야 한다. 개별적인 구현예들의 맥락에서 본 명세서에 기술된 소 정의 피처들은 또한 하나의 구현예에서 조합되어 구현될 수도 있다. 반대로, 단일 구현예의 맥락에서 서술된 다 양한 피처들은 또한 다수의 구현예들에서 개별적으로 또는 임의의 적합한 하위 조합으로 구현될 수 있다. 또한, 피처들이 소정의 특정 조합으로 작용하는 것으로 앞서 서술될 수 있으며 심지어 초기에 그렇게 청구되었더라도, 청구된 조합으로부터의 하나 이상의 피처들은 일부 경우 조합으로부터 제거될 수 있고, 청구된 조합은 하위 조 합 또는 하위 조합의 변형에 관한 것일 수도 있다. 이와 유사하게, 비록 동작들이 특정 순서대로 도면에 도시되었지만, 이는 이러한 동작들이 도시된 특정 순서대 로 또는 순차적으로 수행될 것을 요구하는 것으로 이해되어서는 안되며, 또는 바람직한 결과를 달성하기 위하여도시된 모든 동작들이 수행되어야 함을 의미하지도 않는다. 소정의 상황에서 멀티 태스킹 및 병렬 처리가 유리 할 수 있다. 또한, 상술한 구현예에서 다양한 시스템 구성요소들의 분리는 모든 구현예에서 그러한 분리를 요구 하는 것으로 이해되어서는 안되며, 서술된 프로그램 구성요소들 및 시스템은 일반적으로 단일 소프트웨어 제품 내에 함께 통합되거나 여러 소프트웨어 제품 내에 패키지화될 수 있다. 이와 같이, 특정한 구현예들이 서술되었다. 다른 구현예들은 다음의 청구항들의 범위에 속한다. 예를 들어, 청 구 범위에서 열거된 동작들은 상이한 순서대로 수행될 수 있고 여전히 바람직한 결과를 달성할 수 있다."}
{"patent_id": "10-2020-7025531", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1a는 전화를 걸고 그리고 호출 동안 호출 개시 시스템의 봇(bot)과 인간 사이에서 대화를 수행하는 호출 개 시 시스템에 대한 예시적인 블록도를 도시한다. 도 1b는 전화를 걸고 그리고 호출 동안 호출 개시 시스템의 봇(bot)과 인간 사이에서 대화를 수행하는 호출 개 시 시스템에 대한 대안적인 블록도를 예시한다. 도 1c는 사용자가 요청에 대한 더 많은 세부 사항을 입력할 수 있는 예시적인 사용자 인터페이스를 도시한다. 도 1d는 요청을 하기 위해 봇과 대화하는 사용자의 일례를 도시한다. 도 2a는 사용자에 의해 할당된 작업을 완료하기 위한 프로세스의 예를 도시하는 흐름도이다. 도 2b는 사용자에 의해 할당된 작업을 완료하기 위한 프로세스의 다른 예를 도시하는 흐름도이다. 도 3은 시스템에 의해 실행되는 프로세스에 대한 예시적인 워크 플로우를 도시한다. 도 4는 트리거링 모듈의 블록도이다. 도 5는 전화 호출을 개시하기 위한 프로세스의 일례를 나타내는 흐름도이다. 도 6은 시스템의 작업 관리자 모듈의 블록도이다. 도 7a는 기존 작업들의 진행에 대한 정보를 보여주는 운영자 대시 보드를 도시한다. 도 7b는 사용자 요청 작업들 중 하나를 리뷰하기 위한 운영자 리뷰 화면을 도시한다. 도 8은 작업의 상태를 제공하는 프로세스의 예를 도시하는 흐름도이다. 도 9a는 약속 스케줄링이 진행되는 동안에 도 1b의 이발 약속 요청의 시각적 인 상태를 나타낸다. 도 9b는 약속이 성공적으로 스케줄링된 이후의 도 1b의 이발 약속 요청의 시각적인 상태를 나타낸다. 도 10a는 도 1c의 레스토랑 예약 요청의 구술 상태 요청 및 업데이트를 도시한다. 도 10b는 도 1c의 레스토랑 예약 요청에 대한 사용자에 의한 프롬프트없이, 시스템에 의해 제공되는 구술 상태 업데이트를 도시한다. 도 11은 전화 호출을 봇으로부터 인간에게 이전시키는 예시적인 프로세스를 도시한다. 도 12는 컴퓨팅 디바이스 및 모바일 컴퓨팅 디바이스의 일례를 나타내는 개략도이다. 여러 도면들에서 유사한 참조 번호들과 명칭들은 유사한 구성요소들을 나타낸다."}
