{"patent_id": "10-2022-7039671", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0002702", "출원번호": "10-2022-7039671", "발명의 명칭": "파이프라인 아티팩트들 선정의 동적 자동화", "출원인": "인터내셔널 비지네스 머신즈 코포레이션", "발명자": "황, 진호"}}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨터 시스템에 있어서, 상기 시스템은: 메모리에 작동 가능하게 결합된 처리 유닛;상기 처리 유닛에 작동 가능하게 결합된 인공 지능(AI) 플랫폼을 포함하고, 상기 AI 플랫폼은 소프트웨어 개발및 운영(development and operations: DevOps)을 위한 지속적 통합 및 지속적 배치(CI/CD) 파이프라인(acontinuous integration and continuous deployment (CI/CD) pipeline)을 지원하는 하나 또는 그 이상의 툴들(tools)로 구성되며, 상기 하나 또는 그 이상의 툴들은: 둘 또는 그 이상의 애플리케이션 아티팩트들(application artifacts)에 기반하여 하나 또는 그 이상의 종속성그래프들(dependency graphs)을 생성하는 그래프 관리자;상기 그래프 관리자에 작동 가능하게 결합된 머신 러닝(ML) 관리자 - 상기 ML 관리자는 하나 또는 그 이상의 종속성 그래프들과 하나 또는 그 이상의 파이프라인 아트팩트들 사이의 관계를 캡쳐하기 위해 ML 모델을 활용함(leverage)-; 상기 하나 또는 그 이상의 애플리케이션 아트팩트들에 대한 변경을 감지하는 모니터를 포함하고, 상기 감지된변경에 응답하여 상기 ML 관리자는: 상기 하나 또는 그 이상의 파이프라인 아티팩트들에 미치는 상기 감지된 변경의 영향을 식별하기 위해 상기 캡쳐된 관계를 활용하는 단계; 및상기 식별된 영향에 응답하여 상기 파이프라인을 선택적으로 최적화하는 단계를 수행하며, 상기 최적화는 상기식별된 영향에 대응하는 매핑된 변경들을 상기 파이프라인에 자동으로 인코딩하는 단계를 포함하고; 그리고상기 처리 유닛은 상기 최적화된 파이프라인을 실행하는 컴퓨터 시스템."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 하나 또는 그 이상의 파이프라인 아티팩트들에 미치는 상기 검출된 변경의 영향을 식별하는 단계는: 상기 ML 관리자가 상기 영향의 측정을 생성하고 상기 측정을 사용하여 상기 파이프라인에서 상기 애플리케이션아티팩트 변경의 결과를 예측하는 단계를 더 포함하는컴퓨터 시스템."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 시스템은 피드백 관리자가 상기 최적화된 파이프라인에서 모든 종속성 패턴들(anydependency patterns)을 캡쳐하는 단계를 더 포함하는컴퓨터 시스템."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 시스템은 상기 피드백 관리자가 실시간 데이터 및 실시간 데이트 피드백을 캡쳐하기 위해능동 학습 방법(an active learning methodology)을 채용하고, 상기 ML 모델을 훈련시키기 위해 상기 캡쳐된데이터를 채용하는 단계를 더 포함하는컴퓨터 시스템. 공개특허 10-2023-0002702-3-청구항 5 제1항에 있어서, 상기 애플리케이션 아티팩트들은 소스 코드, 테스팅 코드, 애플리케이션 프로그래밍 인터페이스(API) 사양들, 구성들, 배치 스크립트들, 또는 이들의 조합을 포함하는컴퓨터 시스템."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 하나 또는 그 이상의 종속성 그래프들과 하나 또는 그 이상의 파이프라인 아티팩트들 사이의 캡처된 관계는 상기 애플리케이션 아티팩트들과 상기 하나 또는 그 이상의 파이프라인 아티팩트들 사이의영향 종속성들(impact dependencies)을 나타내는컴퓨터 시스템."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서, 상기 하나 또는 그 이상의 파이프라인 아티팩트들 각각은 대응하는 종속성 그래프를 가지는컴퓨터 시스템."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "소프트웨어 개발 및 운영(DevOps)을 위한 지속적 통합 및 지속적 배치(CI/CD) 파이프라인을 지원하기 위한 컴퓨터 프로그램 제품에 있어서, 상기 컴퓨터 프로그램 제품은 프로그램 코드가 구현된 컴퓨터 판독 가능 저장 매체를 포함하고, 상기 프로그램 코드는 프로세서에 의해 실행 가능하며, 상기 프로세서가:둘 또는 그 이상의 애플리케이션 아티팩트들을 기반으로 하나 또는 그 이상의 종속성 그래프들을 생성하는단계;상기 하나 또는 그 이상의 종속성 그래프들과 하나 또는 그 이상의 파이프라인 아티팩트들 사이의 관계를 캡쳐하기 위해 머신 러닝(ML) 모델을 채용하는 단계; 상기 하나 또는 그 이상의 애플리케이션 아티팩트들에 대한 변경을 감지하는 단계를 수행하게 하고, 상기 감지된 변경에 응답하여 상기 ML 모델이: 상기 하나 또는 그 이상의 파이프라인 아티팩트들에 미치는 상기 감지된 변경의 영향을 식별하기 위해 상기 캡쳐된 관계를 활용하는 단계; 및상기 식별된 영향에 응답하여 상기 파이프라인을 선택적으로 최적화하는 단계를 수행하게 하며, 상기 최적화는상기 식별된 영향에 대응하는 매핑된 변경들을 상기 파이프라인에 자동으로 인코딩하는 단계를 포함하고; 그리고상기 프로세서가 상기 최적화된 파이프라인을 실행하는 단계를 수행하게 하는 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서, 상기 하나 또는 그 이상의 파이프라인 아티팩트들에 미치는 상기 검출된 변경의 영향을 식별하는 단계는: 상기 ML 관리자가 상기 영향의 측정을 생성하고 상기 측정을 사용하여 상기 파이프라인에서 상기 애플리케이션아티팩트 변경의 결과를 예측하는 단계를 수행하는 프로그램 코드를 더 포함하는컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제8항에 있어서, 상기 최적화된 파이프라인에서 모든 종속성 패턴들(any dependency patterns)을 캡쳐하는 단계를 수행하는 프로그램 코드를 더 포함하는컴퓨터 프로그램 제품.공개특허 10-2023-0002702-4-청구항 11 제10항에 있어서, 실시간 데이터 및 실시간 데이트 피드백을 캡쳐하기 위해 능동 학습 방법(an active learningmethodology)을 채용하고, 상기 ML 모델을 훈련시키기 위해 상기 캡쳐된 데이터를 채용하는 단계를 수행하는 프로그램 코드를 더 포함하는컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제8항에 있어서, 상기 애플리케이션 아티팩트들은 소스 코드, 테스팅 코드, 애플리케이션 프로그래밍 인터페이스(API) 사양들, 구성들, 배치 스크립트들, 또는 이들의 조합을 포함하는 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제8항에 있어서, 상기 애플리케이션 아티팩트들은 소스 코드, 테스팅 코드, 애플리케이션 프로그래밍 인터페이스(API) 사양들, 구성들, 배치 스크립트들, 또는 이들의 조합을 포함하는 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제8항에 있어서, 상기 하나 또는 그 이상의 종속성 그래프들과 하나 또는 그 이상의 파이프라인 아티팩트들 사이의 캡처된 관계는 상기 애플리케이션 아티팩트들과 상기 하나 또는 그 이상의 파이프라인 아티팩트들 사이의영향 종속성들(impact dependencies)을 나타내는컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제8항에 있어서, 상기 하나 또는 그 이상의 파이프라인 아티팩트들 각각은 대응하는 종속성 그래프를 가지는컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "방법에 있어서, 상기 방법은:둘 또는 그 이상의 애플리케이션 아티팩트들을 기반으로 하나 또는 그 이상의 종속성 그래프들을 생성하는단계;상기 하나 또는 그 이상의 종속성 그래프들과 하나 또는 그 이상의 파이프라인 아티팩트들 사이의 관계를 캡쳐하기 위해 머신 러닝(ML) 모델을 채용하는 단계; 상기 하나 또는 그 이상의 애플리케이션 아티팩트들에 대한 변경을 감지하는 단계를 포함하고, 상기 감지된 변경에 응답하여 상기 ML 모델이: 상기 하나 또는 그 이상의 파이프라인 아티팩트들에 미치는 상기 감지된 변경의 영향을 식별하기 위해 상기 캡쳐된 관계를 활용하는 단계; 및상기 식별된 영향에 응답하여 상기 파이프라인을 선택적으로 최적화하는 단계를 수행하게 하며, 상기 최적화는상기 식별된 영향에 대응하는 매핑된 변경들을 상기 파이프라인에 자동으로 인코딩하는 단계를 포함하고; 그리고상기 방법은 상기 최적화된 파이프라인을 실행하는 단계를 포함하는방법."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서, 상기 하나 또는 그 이상의 파이프라인 아티팩트들에 미치는 상기 검출된 변경의 영향을 식별공개특허 10-2023-0002702-5-하는 단계는: 상기 ML 관리자가 상기 영향의 측정을 생성하고 상기 측정을 사용하여 상기 파이프라인에서 상기 애플리케이션아티팩트 변경의 결과를 예측하는 단계를 더 포함하는방법."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제16항에 있어서, 상기 방법은 상기 최적화된 파이프라인에서 모든 종속성 패턴들(any dependency patterns)을캡쳐하는 단계 및 실시간 데이터 및 실시간 데이트 피드백을 캡쳐하기 위해 능동 학습 방법(an active learningmethodology)을 채용하고, 상기 ML 모델을 훈련시키기 위해 상기 캡쳐된 데이터를 채용하는 단계를 더 포함하는방법."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제16항에 있어서, 상기 애플리케이션 아티팩트들은 소스 코드, 테스팅 코드, 애플리케이션 프로그래밍 인터페이스(API) 사양들, 구성들, 배치 스크립트들, 또는 이들의 조합을 포함하는 방법."}
{"patent_id": "10-2022-7039671", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제16항에 있어서, 상기 하나 또는 그 이상의 종속성 그래프들과 하나 또는 그 이상의 파이프라인 아티팩트들 사이의 캡처된 관계는 상기 애플리케이션 아티팩트들과 상기 하나 또는 그 이상의 파이프라인 아티팩트들 사이의영향 종속성들(impact dependencies)을 나타내는방법."}
{"patent_id": "10-2022-7039671", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "소프트웨어 개발 및 운영(DevOps)을 위한 지속적 통합 및 배치(CI/CD) 파이프라인을 지원하는 인공지능(AI) 플랫 폼이 제공된다. 애플리케이션 아티팩트들을 기반으로 하나 또는 그 이상의 종속성 그래프들이 생성된다. 머신 러 닝(ML) 모델이 종속성 그래프(들)의 컴포넌트들과 하나 또는 그 이상의 파이프라인 아티팩트들 사이의 관계를 캡 쳐하기 위해 활용된다. 애플리케이션 아티팩트의 변경에 응답하여, 상기 캡처된 관계는 상기 파이프라인 아티팩 트(들)에 미치는 상기 감지된 변경의 영향을 식별하기 위해 활용된다. 상기 CI/CD 파이프라인은 상기 식별된 영 향을 기반으로 선택적으로 최적화되고 실행되어 상기 파이프라인의 효율성과 상기 배치 시간을 향상시킨다."}
{"patent_id": "10-2022-7039671", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명의 실시예들은 소프트웨어 개발 및 운영(DevOps)을 위한 지속적 통합/지속적 제공(Continuous Integration/Continuous Delivery, CI/CD) 파이프라인에 관한 것이다. 보다 구체적으로, 실시예들은 애플리케 이션 컴포넌트들(application components)과 CI/CD 파이프라인 컴포넌트들 사이의 종속성들(dependencies)을 학습함으로써 식별된 변경들에 기초하여 CI/CD 파이프라인 아티팩트들을 자동적으로 그리고 선택적으로 최적화 하는 것에 관한 것이다."}
{"patent_id": "10-2022-7039671", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능(Artificial Intelligence, AI)의 서브세트인 머신러닝(Machine Learning, ML)은 알고리즘들을 이용하여 데이터로부터 학습하고 이 데이터를 기반으로 예측들(foresights)을 생성한다. AI는, 정보를 기반으로, 머신이 결정들을 내릴 수 있는 지능을 의미하며, 이는 주어진 주제에서 성공할 가능성을 극대화한다. 보다 구체적으로, AI는 데이터 세트로부터 학습하여 문제들을 해결하고 관련 권장 사항들을 제공할 수 있다. 인 지 컴퓨팅(Cognitive computing)은 컴퓨터 과학과 인지 과학의 혼합이다. 인지 컴퓨팅은 데이터 최소값, 시각적 인식 및 자연어 처리를 사용하여 문제들을 해결하고 휴먼 프로세스들(human processes)을 최적화하는 자기- 학 습 알고리즘들(self-teaching algorithms)을 이용한다."}
{"patent_id": "10-2022-7039671", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "AI와 관련 추론(associated reasoning)의 핵심에는 유사성의 개념(the concept of similarity)이 있다. 자연어와 객체들을 이해하는 프로세스는 도전적일 수 있는 관계적 관점(a relational perspective)으로부터의 추론이 필요하다. 정적 구조들 및 동적 구조들(static structures and dynamic structures)을 포함하는, 구조 들은 주어진 확정 입력(a given determinate input)에 대해 결정된 출력 또는 동작(determined output or action)을 지시한다(dictate). 보다 구체적으로, 결정된 출력 또는 동작은 구조 내에서 명시적이거나 고유한 관계(an express or inherent relationship)를 기반으로 한다. 이러한 구성(arrangement)은 선택된 상황들과 조 건들에 대해서는 만족스러울 수 있다. 그러나, 동적 구조들은 본질적으로 변경될 수 있으며, 특히 소프트웨어 제공을 위한 파이프라인 환경에서 그에 따라 출력이나 동작이 변경될 수 있다고 여겨지고 있다. 객체들을 효율 적으로 식별하고 내용을 처리하기 위한 기존 솔루션(Existing solutions)은 물론, 구조들에 대한 변경들도 실용 적인 수준에서 매우 어렵다."}
{"patent_id": "10-2022-7039671", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 실시예들은 애플리케이션 아티팩트들과 파이프라인 아티팩트들 간의 종속성을 학습함으로써 CI/CD 파이프라인을 자동으로 그리고 선택적으로 최적화하기 위한 시스템, 컴퓨터 프로그램 제품, 및 방법을 포 함한다 일 실시예에서, 컴퓨터 시스템이 제공되고, 상기 시스템에는 메모리에 작동 가능하게 결합된 처리 유닛, 상기 처리 유닛에 작동 가능하게 결합된 인공 지능(AI) 플랫폼이 제공된다. 상기 AI 플랫폼은 소프트웨어 개발 및 운영(development and operations: DevOps)을 위한 지속적 통합 및 지속적 배치(CI/CD) 파이프라인(a continuous integration and continuous deployment (CI/CD) pipeline)을 지원한다. 상기 AI 플랫폼은 그래프 관리자, 머신 러닝(ML) 관리자, 및 모니터의 형태로 툴들(tools)을 포함한다. 상기 그래프 관리자는 둘 또는 그 이상의 애플리케이션 아티팩트들(application artifacts)에 기반하여 하나 또는 그 이상의 종속성 그래프들 (dependency graphs)을 생성하는 기능을 수행한다. 상기 그래프 관리자에 작동 가능하게 결합된, 상기 ML 관리 자는 하나 또는 그 이상의 종속성 그래프들과 하나 또는 그 이상의 파이프라인 아트팩트들 사이의 관계를 캡쳐 하기 위해 ML 모델을 활용한다(leverage). 상기 그래프 관리자에 작동 가능하게 결합된 것으로 도시된, 상기 모 니터는 상기 하나 또는 그 이상의 애플리케이션 아트팩트들에 대한 변경을 감지하는 기능을 수행하고, 상기 감 지된 변경에 응답하여, 상기 ML 관리자는 상기 하나 또는 그 이상의 파이프라인 아티팩트들에 미치는 상기 감지 된 변경의 영향을 식별하기 위해 상기 캡쳐된 관계를 활용하고, 그리고 상기 식별된 영향에 응답하여 상기 파이 프라인을 선택적으로 최적화한다. 상기 최적화는 상기 식별된 영향에 대응하는 매핑된 변경들을 상기 파이프라 인에 자동으로 인코딩하는 단계를 포함한다. 상기 처리 유닛은 상기 최적화된 파이프라인을 실행한다. 다른 실시예에서, 컴퓨터 프로그램 제품이 소프트웨어 개발 및 운영(DevOps)을 위한 지속적 통합 및 지 속적 배치(CI/CD) 파이프라인을 지원하기 위해 제공된다. 상기 컴퓨터 프로그램 제품은 프로그램 코드가 구현된 컴퓨터 판독 가능 저장 매체를 포함한다. 프로세서에 의해 실행 가능한, 상기 프로그램 코드는 둘 또는 그 이상 의 애플리케이션 아티팩트들을 기반으로 하나 또는 그 이상의 종속성 그래프들을 생성하기 위해 제공된다. 상기 프로그램 코드는 상기 하나 또는 그 이상의 종속성 그래프들과 하나 또는 그 이상의 파이프라인 아티팩트들 사 이의 관계를 캡쳐하기 위해 머신 러닝(ML) 모델을 활용한다. 상기 프로그램 코드는 상기 하나 또는 그 이상의 애플리케이션 아티팩트들에 대한 변경을 감지하고, 상기 감지된 변경에 응답하여 상기 ML 모델이 상기 하나 또 는 그 이상의 파이프라인 아티팩트들에 미치는 상기 감지된 변경의 영향을 식별하기 위해 상기 캡쳐된 관계를 활용하고, 상기 식별된 영향에 응답하여 상기 파이프라인을 선택적으로 최적화한다. 상기 최적화는 상기 식별된 영향에 대응하는 매핑된 변경들을 상기 파이프라인에 자동으로 인코딩하는 단계를 포함한다, 그 다음 상기 최적 화된 파이프라인은 실행된다. 또 다른 실시예에서, 방법이 소프트웨어 개발 및 운영(development and operations: DevOps)을 위한 지 속적 통합 및 지속적 배치(CI/CD) 파이프라인(a continuous integration and continuous deployment (CI/CD) pipeline)을 지원하기 위해 제공된다. 상기 방법은 둘 또는 그 이상의 애플리케이션 아티팩트들을 기반으로 하 나 또는 그 이상의 종속성 그래프들을 생성하는 단계를 포함한다. 머신 러닝(ML) 모델이 상기 하나 또는 그 이 상의 종속성 그래프들과 하나 또는 그 이상의 파이프라인 아티팩트들 사이의 관계를 캡쳐하기 위해 활용된다. 상기 파이프라인은 상기 식별된 영향에 응답하여 선택적으로 최적화되고, 상기 최적화는 상기 식별된 영향에 대 응하는 매핑된 변경들을 상기 파이프라인에 자동으로 인코딩하는 단계를 포함하고; 그리고 상기 최적화된 파이 프라인은 실행된다. 이들 및 다른 특징 및 이점은 첨부 도면들과 함께 취해진 현재 바람직한 실시예(들)의 다음의 상세한 설 명으로부터 명백해질 것이다."}
{"patent_id": "10-2022-7039671", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 실시예의 컴포넌트들은, 본 명세서의 도면에 일반적으로 설명되고 도시된 바와 같이, 매우 다양한 다 른 구성으로 배열 및 설계될 수 있다는 것을 이해해야 한다. 따라서, 본 실시예의 장치, 시스템, 방법 및 컴퓨 터 프로그램 제품에 대한 다음과 같은 상세한 설명은, 특허 청구된 바와 같이, 실시예의 범위를 한정하기 위한 것이 아니라, 선택된 실시예를 나타내기 위한 것일 뿐이다. 본 명세서 전반에 걸쳐 \"선택된 실시예\", \"일 실시예\" 또는 \"실시예\"에 대한 참조는 실시예와 관련하여 설명된 특정 특징, 구조 또는 특성이 적어도 하나의 실시예에 포함된다는 것을 의미한다. 따라서, 본 명세서 전 반에 걸쳐 다양한 곳에서 \"선택된 실시예\", \"일 실시예에서\" 또는 \"실시예에서\"라는 문구가 나타나는 것은 반드 시 동일한 실시예를 지칭하는 것은 아니다. 예시된 실시예들은 도면을 참조하여 가장 잘 이해될 것이며, 여기서 유사한 부분은 전체에 걸쳐 동일한 번호로 지정된다. 다음 설명은 단지 일 예로서 의도된 것이며, 본 명세서에 청구된 실시예와 일치하는 장치, 시 스템 및 프로세스의 특정 선택된 실시예들을 간단히 설명한다. 데브옵스(“개발”과 “운영”의 합성어, DevOps)는 소프트웨어 개발자와 다른 정보기술(IT) 전문가 간 의 의사 소통, 협업, 통합, 자동화 및 협력 측정을 강조하는 소프트웨어 개발 방법이다. 데브옵스(DevOps)는 소 프트웨어 개발, 품질 보증 및 IT 운영의 상호 의존성을 인정하며 조직이 소프트웨어 제품 및 서비스를 신속하게 생산할 수 있도록 돕고 더 빠른 개발 및 배치 주기를 제공하면서 신뢰성과 보안을 개선하는 것을 목표로 한다. 지속적 통합(Continuous Integration, CI)는 개발자가 통합 문제를 식별하기 위해 코드를 통합하는 소프트웨어 개발 프로세스이다. 보다 구체적으로, 지속적 통합(CI) 기능은 코드 개발 노력을 줄임으로써 더 높은 품질의 소 프트웨어와 예측 가능한 제공 일정을 만들어낸다. 따라서, 지속적 통합은 개발된 소프트웨어 코드가 기존 소프 트웨어 코드와 통합되는 데브옵스(DevOps) 방식이다. 지속적 제공(Continuous Delivery, CD)은 선택한 하부구조 환경에 대한 애플리케이션 제공을 자동화한다. 개발, 테스트 및 프로덕션과 같은 다양한 환경에 대한 코드 변경 사항들의 자동화된 푸시(automated pushing)를 보장한다. 데브옵스(DevOps)에서, CI는 테스트 배치 및 CD의 릴 리스 단계들을 위한 전제 조건 역할을 한다. 지속적 통합/지속적 제공(CI/CD) 파이프라인(이하 파이프라인이라고 함)은 데브옵스(DevOps)의 일부로서 또는 통합되는 자동화된 프로세스 세트이다. 파이프라인은 여러 단계들로 구성된다. 일 실시예에서, 상기 단계 들은 빌드(Build), 유닛 테스트(Unit Test), 개발 배치(Deploy Development), 통합 테스트(Integration Tests), 컴플라이언스 검사(Compliance Checks) 및 제품 배치(Deploy Product)를 포함할 수 있다. 각 단계는 하나 또는 그 이상의 작업 또는 옵션으로 구성된다. 예를 들어, 테스트 단계는 단순 테스터, 고급 테스터 및/또 는 컴플라이언스 스캐너(compliance scanner)를 사용할 수 있다. 일 실시예에서, 파이프라인의 하나 또는 그 이 상의 단계들은 중복성과 비효율성을 피하기 위해, 이용 가능한 모든 동작들(actions)보다 적은 수의 선택만을 요구할 수 있다. 파이프라인은 빌드, 테스트 및 배치 단계들을(the building, testing, and deployment stages)를 자동화한다. 마이크로 서비스(micro-services) 또는 마이크로 서비스 아키텍처(micro-service architecture)는 애플 리케이션이 기능 정의를 기반으로 하는 모듈형 컴포넌트들 또는 서비스의 모음으로 구축되고, 각각 하나의 기능 정의에 해당하며, 각각이 자체 프로세스에서 실행되고, 경량 메커니즘(lightweight mechanisms)의 방식으로 통 신하는 컴퓨터 환경을 의미한다. 마이크로 서비스 아키텍처에서, 데이터는 서비스 외부에 저장되므로 서비스는 상태 비보존(stateless)이다. 서비스 또는 컴포넌트들을 일반적으로 \"원자 서비스(atomic services)\"라고 한다. 각 원자 서비스는 모듈식 서비스를 독립적으로 수행하기 위한 경량 컴포넌트(lightweight component)이다. 예를 들어, 원자 서비스는 키워드를 수신 및 결합하거나, 알고리즘을 처리하거나, 알고리즘 처리 결과를 기반으로 결 정을 내릴 수 있다. 각 모듈은 특정 작업을 지원하고 애플리케이션 프로그래밍 인터페이스(application programming interface, API)와 같은 정의 인터페이스(a define interface)를 사용하여 다른 서비스와 통신한 다. 마이크로 서비스 아키텍처는 하이브리드 네트워크(hybrid network)에서 확장성을 지원하고 활성화한다. 클라우드 네이티브 환경(cloud native environment)에서 분할될 때 마이크로 서비스는 더 많은 이점을 제공하기 때문에 파이프라인에서 사용되는 마이크로 서비스의 수가 기하급수적으로 증가하고 있다. 마이크로 서 비스는 개발 및 배치와 관련하여 몇 가지 이점이 있지만, 고유한 문제도 있다. 애플리케이션 수가 증가함에 따 라 마이크로 서비스 저장소들(micro-service repositories) 및 파이프라인들의 관리는 훨씬 어려워진다. 파이프 라인은 마이크로 서비스 배치를 자동화하는 데 활용된다. 일부 회사에서 서비스를 운영하기 위해 수백 또는 수 천 개의 마이크로 서비스를 운영함에 따라 파이프라인은 시간이 지남에 따라 견고해졌으며 계속해서 더욱 커질 것이다. 코드, 구성, 변수 변경, 네트워크 포트 변경 등이 변경될 때마다 마이크로 서비스를 다시 배치해야 한 다. 재배치는 마이크로 서비스를 프로비저닝하기 위해 동일한 프로세스를 따르며 프로세스는 너무 많은 프로세 스로 인해 점점 더 복잡해지고 속도가 느려지고 있다. 여기에 도시되고 설명된 바와 같이, 파이프라인이 신뢰성 의 수준을 유지하면서 재배치 프로세스를 효율적으로 촉진하고 지원할 수 있도록 최적화된 솔루션이 제공된다. 애플리케이션 아티팩트(application artifact)는 소프트웨어 개발 동안 생성되는 유형의 부산물(a tangible by-product)로 당업계에 알려져 있다. 아티팩트는 파이프라인의 단계 간 또는 다른 파이프라인 간에 파일을 공유하는 자원(a resource to share files) 역할을 한다. 애플리케이션 아티팩트의 예에는 애플리케이션 소스 코드(application source code), 테스팅 코드(testing code), 애플리케이션 프로그래밍 인터페이스(API) 사양(application programming interface (API) specifications), 애플리케이션 구성(application configurations), 배치 스크립트(deployment scripts) 및 변수(variables)가 포함되지만 이에 한정되지는 않는 다. 파이프라인 아티팩트는 소프트웨어 개발 프로세스 중에 생성되는 부산물이다. 프로젝트 소스 코드 (project source code), 종속성(dependencies), 이진수(binaries) 또는 자원(resources)로 구성될 수 있다. 파 이프라인 아티팩트의 예에는 현재 파이프라인에서 사용할 수 있는 기능, 프로세스 및 컴포넌트들이 포함되지만 이에 한정되지는 않는다. 도 1을 참조하면, 파이프라인의 자동 선택 및 최적화를 지원하는 툴(tools)과 함께 컴퓨터 시스템 의 개략도가 제공된다. 도시된 바와 같이, 서버는 네트워크 연결를 통해 복수의 컴퓨팅 장치들, , , , 및 과 통신하도록 제공된다. 서버는 버스를 통해 메모리과 통신하는 프로세서로 구성된다. 서버는 애플리케이션 아티팩트에 기반한 파이프라인 아티팩트의 선택 을 지원하기 위해 인공지능(AI) 플랫폼과 함께 도시된다. 보다 구체적으로, AI 플랫폼은 애플리케이 션 아티팩트와 파이프라인 아티팩트 간의 종속성(dependencies)을 캡쳐하고 학습하며, 학습된 종속성을 기반으 로 파이프라인을 선택적으로 최적화하는 하나 또는 그 이상의 툴로 구성된다. 컴퓨팅 장치들, , , , , 및 은 하나 또는 그 이상의 유선 및/또는 무선 데이터 통신 링크를 통해 서로 및 다 른 장치들 또는 컴포넌트들과 통신하며, 여기서 각각의 통신 링크는 와이어(wires), 라우터(routers), 스위치 (switches), 송신기(transmitters), 수신기(receivers) 등 중 하나 또는 그 이상을 포함할 수 있다. 서버(11 0)의 다른 실시예들은 본 명세서에 설명된 것 이외의 컴포넌트들, 시스템, 서브시스템 및/또는 장치들과 함께 사용될 수 있다. 본 명세서에는 다양한 소스로부터 입력를 수신하도록 구성된 인공지능(AI) 플랫폼이 도시되어 있다. 예를 들어, AI 플랫폼은 네트워크를 통해 입력을 수신하고, 본 명세서에서 코퍼스(corpus) 또 는 데이터 소스라고 지칭되는 지식 베이스(knowledge base)을 활용하여 하나 또는 그 이상의 파이프라인 아티팩트의 자동 선택 및 인코딩을 파이프라인(CI/CD 파이프라인이라고도 함)에 적용할 수 있다. 도시된 바와 같이, 지식 베이스는 본 명세서에서 제1 라이브러리, 제2 라이브러리 및 제3 라이브러리로 표시된 하나 또는 그 이상의 라이브러리로 구성된다. 본 명세서에 도시된 라이브러리들의 수량은 예시적인 목적을 위한 것이며, 일 실시예에서, 지식 베이스는 더 적은 수의 라이브러리들을 가질 수 있다. 예를 들어, 일 실시예에서, 지식 베이스는 종속성 그래프, 모델 및 대응하는 피드백을 위한 하나의 라이브러리 또는 데이터 구조를 가질 수 있다. 제1 라이브러리는 그래프A (162A), 그래프B (162B) 및 그래프N (162N)을 포함하여, 본 명세서에서 그 래프로 지칭되는 복수의 종속성 그래프와 함께 도시된다. 종속성 그래프(162A), (162B) 및 (162N)의 수량은 예시 적인 목적을 위한 것이며 제한적인 것으로 간주되어서는 안 된다. 각 종속성 그래프는 애플리케이션의 부분들 사이의 관계를 나타내며, 보다 구체적으로, 그래프는 애플리케이션 변경의 각 부분이 애플리케이션 또는 관련 애플리케이션의 하나 또는 그 이상의 다른 부분들에 어떻게 영향을 미칠 수 있는지를 나타낸다. 종속성 그래프 는 애플리케이션 아티팩트 간의 코드 종속성, 구성 종속성, API 종속성, 배치 종속성 등을 나타낸다. 예를 들어, 일 실시예에서, 그래프는 하나의 애플리케이션에 대해 감지된 변경이 다른 애플리케이션의 API 테스트를 필요로 할 수 있는 방법을 설명할 수 있다. 제2 라이브러리는 모델A (164A), 모델B (164B) 및 모델N (164N)을 포함하는 복수의 ML 모델과 함께 도시된다. ML 모델(164A), (164B) 및 (164N)의 수량은 예시적인 목적을 위한 것이며 제한적인 것으로 간주되어서 는 안 된다. 각 ML 모델은 제1 라이브러리에 저장된 종속성 그래프와 파이프라인 아티팩트 사이의 관계를 캡처한다. ML 관리자는 캡쳐된 관계의 영향을 식별하기 위해 ML 모델(164A), (164B) 및 (164N)에 연관 규칙 학습을 사용하거나 적용한다. 제3 라이브러리는 ML 모델과 관련된 피드백과 함께 도시된다. 여기에 도시된 예에서, 각 모델은 대 응하는 피드백(166A), (166B) 및 (166N)을 갖는다. 피드백(166A) - (166N)에 대한 자세한 내용은 아래에 표시되 고 설명된다. 연관 규칙 학습(Association rule learning)은 데이터베이스에서 변수들 간의 관계들을 발견하기 위한 규칙 기반 ML 방법이다. 트랜잭션들 세트(a set of transactions)가 주어지면, 연관된 규칙 학습은 트랜잭션에 서 다른 아이템의 발생을 기반으로 아이템의 발생을 예측한다. 연관 규칙 학습은 데이터의 발생 빈도와 같은 변 수들 사이의 발견된 관계의 일부 척도를 사용하여 데이터베이스에서 발견된 강력한 규칙을 식별하기 위한 것이다. 연관 규칙 학습의 일 예는 아프리오리 알고리즘(Apriori algorithm)이다. 아프리오리 알고리즘은 프로그램 코드를 스위프(sweep through)하기 위해 너비 우선 탐색(breadth-first search) 전략을 사용하고 지원의 하향 폐쇄 속성(a downward closure property of support)을 이용하기 위해 후보 생성 기능들을 사용한다. 이 알고 리즘은 아래에 표시되고 설명되는 ML 모델(들)에 의해 이용될 수 있는 예시적인 연관 규칙 학습 알고리즘이다. 여기에서 (164A), (164B) 및 (164N)으로 도시된 ML 모델(들)은 애플리케이션 아티팩트와 파이프라인 아티팩트(들) 사이의 매핑을 효과적으로 생성한다. 보다 구체적으로, ML 모델은 종속성 그래프에 반영된 수집된 애플리케이션 아티팩트와 파이프라인 아티팩트 사이의 영향을 분석하는 알고리즘을 사용한다. 매핑은 하나 또는 그 이상의 애플리케이션 아티팩트의 감지된 변경이 파이프라인의 마이크로 서비스에 어떻게 영향을 미치는지에 대한 종속성 정보를 제공한다. 일 실시예에서, ML 관리자는 검출된 변경의 영향을 분석하고, 그 분석을 사 용하여 파이프라인에서의 애플리케이션 변경의 결과를 예측한다. 이러한 분석은 아래 도 3에 설명되어 있다. 일 실시예에서는, 매핑은 하나 또는 그 이상의 선택된 애플리케이션 아티팩트에 대한 변경이 하나 또는 그 이상의 파이프라인 아티팩트에 어떻게 영향을 미치는지 방식을 캡쳐하고, 파이프라인에 대한 변경을 효과적으로 제안하 거나 구현하기 위해 임팩트 매핑(impact mapping)이라고 한다. AI 플랫폼은 하나 또는 그 이상의 애플리케이션 아티팩트에 대한 변경 감지 또는 식별, 파이프라인 아티팩트에 대한 변경의 영향에 대한 학습 또는 학습된 종속성, 영향을 기반으로 파이프라인에서 파이프라인 아 티팩트의 선택적 최적화 및 선택적으로 최적화된 파이프라인의 실행 등을 기반으로 하는 파이프라인의 최전화를 지원하는 여러 툴과 함께 여기에 도시된다. 본 명세서에는 AI 플랫폼 툴은 그래프 관리자, 머신러닝 (ML) 관리자, 모니터 및 피드백 관리자로 도시된다. 상기 툴들, , 및 은 직접 또는 간접적으로 함께 작동 가능하게 결합되고, 아래에 설명된 바와 같은 기능들을 제공한다. 그래프 관리자는 제1 라이브러리에 도시된 종속성 그래프를 생성한다. 애플리케이션 및 파이 프라인 아티팩트 수집 및 종속성 그래프 생성에 대한 자세한 내용은 도 3에 도시되고 설명되어 있다. 본 명세서 에 도시된 예시적인 그래프 (162A), (162B) 및 (162N)은 둘 또는 그 이상의 수집된 애플리케이션 아티팩트에 기 반하고 수집된 애플리케이션 아티팩트들 사이의 하나 또는 그 이상의 관계를 표현한다. 따라서, 그래프 관리자는 수집된 애플리케이션 아티팩트에 존재하고 식별된 관계를 표현하기 위해 하나 또는 그 이상의 종속성 그래프를 생성한다. 애플리케이션 변경으로 인해 해당 애플리케이션에 하나 또는 그 이상의 마이크로 서비스가 재배치될 수 있음을 이해한다. 도시된 바와 같이, 모니터는 그래프 관리자 및 ML 관리자 모두에 작동 가능하 게 결합된다. 모니터는 해당 애플리케이션 아티팩트에 반영된 바와 같이 애플리케이션의 변경을 감지하는 기능을 한다. 모니터는 하나 또는 그 이상의 마이크로 서비스의 재배치를 트리거하는 애플리케이션 아티팩 트의 모든 변경을 감시한다. 이러한 변경의 감지에 응답하여, 모니터는 ML 관리자와 인터페이스 하여, 제2 라이브러리로부터 해당 ML 모델(164A) - (164N)을 식별하며, 감지된 변경에 대응하는 ML 모델을 식별한다. 상기 ML 관리자는 식별된 ML 모델을 이용하여 하나 또는 그 이상의 파이프라인 아티팩트에 대한 감지된 변경의 영향을 식별하고, 그 영향을 기반으로 파이프라인을 선택적으로 최적화한다. 각 ML 모델은 종속 성 그래프와 파이프라인 아티팩트 사이의 관계를 캡처하므로, ML 관리자는 지식 베이스으로부터 적절 한 모델을 식별하고, 상기 모델은 알고리즘을 채택하는데, 이는 일 실시예에서 연관 규칙 학습 알고리즘이다. 또한, ML 관리자는 ML 모델(164A) - (164N)의 영향에 해당하는 매핑된 변경사항을 파이프라인으로 인코딩한 다. 일 실시예에서, 상기 인코딩은 식별된 영향에 대한 응답으로서 최적화된 파이프라인을 투명하게 생성하기 위해 자동적이다. 일 실시예에서, 파이프라인의 최적화는 애플리케이션 아티팩트 변경(들)에 의해 영향을 받거 나 다른 영향을 받는 파이프라인의 하나 또는 그 이상의 파이프라인 아티팩트로 인코딩을 제한함으로써 선택적 이 된다. 파이프라인의 선택적 인코딩은 ML 모델이 향후 프로세스에서 반복 가능한 패턴을 인식하도록 추가로 가르치는 능동 학습 방법(active learning methodology)을 지원한다. 일 실시예에서, 능동 학습 방법을 도입하 면 영향을 받지 않는 파이프라인 아티팩트가 불필요하게 평가되지 않기 때문에 파이프라인의 배치와 관련하여 효율성을 향상시킨다. 처리 유닛(processing unit)은 파이프라인의 효율성 및 배치 시간을 개선하기 위해 식별된 영향에 기초하여 선택적으로 인코드된 파이프라인 또는 파이프라인 아티팩트를 사용하여 최적화된 파이 프라인을 실행한다. 이에 따라, AI 및 ML은 파이프라인 및 파이프라인 아티팩트를 자동 및 선택적으로 최적화하 기 위해 사용된다. 추가로 도시된 바와 같이, 피드백 관리자는 모니터에 작동 가능하게 결합된다. 피드백 관리자 는, 감지된 영향에 대응하여, 지식 베이스에 저장된 피드백(166A) - (166N)으로, 여기서 도시된 피드 백을 수집한다. 일 실시예에서, 수집된 피드백(166A) - (166N) 또는 본 명세서에서 지칭되는 피드백 데이터는 사 용자 생성 피드백이다. 도 4에 도시되고 설명된 바와 같이, 수집된 피드백은 주제 전문가(subject matter expert, SME)로부터 나오고 영향을 받는 파이프라인 아티팩트의 배치 또는 재배치에 대응하는 실시간 데이터를 포함할 수 있다. 본 명세서에 도시된 바와 같이, 피드백(166A) - (166N)은 ML 모델(들)(164A) - (164N)에 작동 가능하게 결합된다. 보다 구체적으로, ML 모델(164A)은 피드백(166A)와 함께 도시되고, ML 모델(164B)는 피드백 (166B)와 함께 도시되며, ML 모델(164N)은 피드백(166N)과 함께 도시된다. 일 실시예에서, 하나 또는 그 이상의 ML 모델(164A) - (164N)은 작동적으로 결합된 피드백을 갖지 않을 수 있다는 것을 이해한다. 피드백은 피드백 관 리자에 의해 사용되어 해당 ML 모델(164A) - (164N)을 추가로 훈련하거나 훈련 대상으로 삼기 위해 활용한 다. 따라서, 피드백 관리자은 해당 ML 모델과 연관된 피드백을 이용하여 애플리케이션 아티팩트 변경의 향 후 검출에서 애플리케이션을 위한 ML 모델을 추가로 훈련시킨다. 일부 예시적인 실시예들에서, 서버은 뉴욕주 아몽크의 인터내셔널 비즈니스 머신 코퍼레이션 (International Business Machines Corporation)에서 이용할 수 있는 아이 비 엠 왓슨(IBM Watson®) 시스템일 수 있으며, 이는 다음에 설명되는 예시적인 실시예들의 메커니즘으로 강화된다. 그래프 관리자, ML 관리자 , 모니터 및 피드백 관리자(이하 AI 툴로 칭함)은 서버의 AI 플랫폼에 구현되거나 통 합되는 것으로 도시된다. 일 실시예에서, AI 툴은 네트워크를 통해 서버에 연결된 별도의 컴퓨팅 시 스템(예를 들어, )에서 구현될 수 있다. 구현된 위치에 관계없이 AI 툴은 학습 종속성에 의해 식별된 변경 사항을 기반으로 파이프라인에 처리 규칙을 자동으로 인코딩하는 기능을 지원한다. AI 플랫폼을 이용할 수 있는 정보 처리 시스템(information handling systems)의 종류는 휴대용 컴퓨터/휴대전화과 같은 소형 휴대용 장치(small handheld devices)부터 메인프레임 컴퓨터와 같은 대형 메인프레임 시스템에 이르기까지 다양하다. 휴대용 컴퓨터의 예로는 개인 정보 단말기(personal digital assistants, PDAs), MP4 플레이어, 휴대용 텔레비전 및 콤팩트 디스크 플레이어(compact disc players)와 같은 개인용 엔터테인먼트 장치가 있다. 정보 처리 시스템의 다른 예로는 펜, 또는 태블릿 컴퓨터, 랩탑 또는 노트북 컴퓨터, 개인용 컴퓨터 시스템, 서버 등이 있다. 도시된 바와 같이, 다양한 정보 처리 시스템은 컴퓨터 네트워크를 사용하여 함께 네트워크화될 수 있다. 다양한 정보 처리 시 스템을 상호 연결하는 데 사용할 수 있는 컴퓨터 네트워크의 종류는 근거리 통신망(Local Area Networks, LANs), 근거리 무선 통신망(Wireless Local Area Networks, WLANs), 인터넷, 공공 교환 전화망(Public Switched Telephone Network, PSTN), 기타 무선 네트워크들 및 정보 처리 시스템을 상호 연결하는 데 사용할 수 있는 기타 네트워크 토폴로지(network topology)를 포함한다. 많은 정보 처리 시스템에는 하드 드라이브 및/ 또는 비휘발성 메모리와 같은 비휘발성 데이터 저장소를 포함된다. 일부 정보 처리 시스템은 별도의 비휘발성 데이터 저장소를 사용할 수 있다(예를 들어, 서버은 비휘발성 데이터 저장소(190A)를 사용하고 메인프레임 컴퓨터는 비휘발성 데이터 저장소(182A)를 사용한다). 비휘발성 데이터 저장소(182A)는 다양한 정보 처리 시스템의 외부에 있거나 정보 처리 시스템 중 하나의 내부에 있는 컴포넌트일 수 있다. AI 플랫폼을 지원하기 위해 사용되는 정보처리 시스템은 다양한 형태를 취할 수 있으며, 그 중 일 부가 도 1에 도시되어 있다. 예를 들어, 정보처리 시스템은 데스크탑, 서버, 휴대용, 랩탑, 노트북 또는 기타 폼팩터 컴퓨터(form factor computer) 또는 데이터 처리 시스템의 형태를 취할 수 있다. 또한, 정보 처리 시스 템은 개인 정보 단말기(PDA), 게임 장치, ATM 기계, 휴대 전화 장치, 통신 장치 또는 프로세서 및 메모리를 포 함하는 다른 장치들과 같은 다른 폼 팩터들을 취할 수 있다. 또한, 정보 처리 시스템은 노스 브리지(north bridge)/사우스 브리지(south bridge) 컨트롤러 아키텍처를 구현할 수 있는 것이 이해될 것이지만, 다른 아키텍 처들도 사용될 수 있다는 것을 이해한다. 애플리케이션 프로그램 인터페이스(API)는 당업계에서 둘 또는 그 이상의 애플리케이션 사이의 소프트웨 어 중개자로 이해된다. 도 1에 도시되고 설명된 AI 플랫폼과 관련하여, 하나 또는 그 이상의 API는 하나 또는 그 이상의 툴들, , , 및 관련 기능을 지원하기 위해 활용될 수 있다. 도 2를 참조하 면, 툴들, , , 및 이들의 관련 API들을 도시한 블록도이 제공된다. 도시된 바와 같 이, API0와 관련된 그래프 관리자와 API1와 관련된 ML 관리자, API2와 관련된 피드백 관리자 및 API3와 관련된 모니터를 포함하는 툴들과 함께 다수의 툴들이 인공지능 플랫폼 내에 내장되어 있다. 각각의 API는 하나 또는 그 이상의 언어들 및 인터페이스 사양들로 구현될 수 있다. 도시된 바와 같이, API0는 그래프 관리자에 의해 표현되는 기능을 지원하고 활성화하도록 구 성된다. API0는 수집된 두 개 또는 그 수집된 이상의 애플리케이션 아티팩트를 기반으로 하나 또는 그 이 상의 종속성 그래프를 생성하기 위한 기능 지원을 제공한다; API1는 종속성 그래프와 하나 또는 그 이상의 수집된 파이프라인 아티팩트 사이의 관계를 캡처하고, 매핑 형태로 하나 또는 그 이상의 파이프라인 아티팩트에 대한 감지된 애플리케이션 변경의 영향을 식별하며, 식별된 영향에 해당하는 매핑된 변경을 파이프라인에 인코 딩하기 위한 기능 지원을 제공한다; API2는 애플리케이션 변경을 모니터링하기 위한 기능 지원을 제공한다; 그리고 API3는 능동 학습 방법에서 사용자 피드백을 이용하여 향후 프로세스를 위한 ML 모델을 추가로 훈련하기 위한 기능 지원을 제공한다. 도시된 바와 같이, 각각의 API들, , , 및 는 오케스트레이션 계층(orchestration layer)으로 더 잘 알려진 API 오케스트레이터(orchestrator)에 작동 가능하게 결합되며, 이는 별도의 API를 함께 투명하게 스레드하기 위한 추상화 계층으로서 기능하는 것으로 당 업계에서 이해된다. 일 실시예에서, 개별 API들의 기능은 결합되거나 결합될 수 있다. 따라서, 여기에 표시된 API들의 구성이 제한적인 것으로 간주되어서는 안된다. 따라서, 본 명세서에 도시된 바와 같이, 툴들의 기능들 은 각각의 API들에 의해 구현되거나 지원될 수 있다. 도 3을 참조하면, 애플리케이션 아티팩트들과 파이프라인 아티팩트들 간의 관계를 결정하기 위해 영향 분석을 수행하는 프로세스를 도시한 플로차트가 제공된다. 도시된 바와 같이, 두 개 또는 그 이상의 애플 리케이션 아티팩트들이 식별된다. 애플리케이션 아티팩트들의 예에는 애플리케이션 소스 코드, 테스팅 코 드, 애플리케이션 프로그래밍 인터페이스(API) 사양, 애플리케이션 구성, 배치 스크립트 및 변수가 포함되지만 이에 한정되지는 않는다. 애플리케이션 아티팩트 식별 후에, 하나 또는 그 이상의 파이프라인 아티팩트(들)가 식별된다. 파이프라인 아티팩트들의 예에는 기능, 프로세스 및 컴포넌트들이 포함되지만 이에 한정되지는 않는다. 식별된 애플리케이션 아티팩트들에 대해 종속성 그래프가 생성된다. 각 종속성 그래프는 애플리케 이션의 부분들 사이의 관계를 나타내며, 보다 구체적으로, 상기 그래프는 애플리케이션 변경의 각 부분이 애플 리케이션 또는 관련 애플리케이션의 하나 또는 그 이상의 다른 부분들에 어떻게 영향을 미칠 수 있는지를 설명 한다. 예를 들어, 애플리케이션 중 하나에서 변경이 감지되면 하나 또는 그 이상의 관련 애플리케이션들에 대한하나 또는 그 이상의 API 테스트들이 트리거될 수 있다. 따라서, 종속성 그래프들은 애플리케이션 아티팩트들의 상호 종속 관계들을 캡처한다. 종속성 그래프의 생성 후에, 상기 종속성 그래프에 반영된 애플리케이션 아티팩트와 하나 또는 그 이상 의 파이프라인 아티팩트(들) 사이에 영향 분석이 수행된다. 일 실시예에서, 연관 규칙 학습 알고리즘은 영 향 분석을 수행하기 위해 활용된다. 애플리케이션 아티팩트들은 하나 또는 그 이상의 파이프라인 아티팩트들과 인터페이스 할 수 있다는 것이 본 기술 분야에서 이해된다. 이 인터페이스는 애플리케이션 아티팩트들과 파이프 라인 아티팩트들 사이의 직접적인 관계 또는 간접적인 관계일 수 있다. 영향 분석은 직접 및 간접 관계를 모두 캡처한다. 보다 구체적으로, 영향 분석은 존재하는 경우 서로 다른 파이프라인 아티팩트(들)에 해당하는 애플리 케이션 아티팩트들의 직접적 및 간접적 관계를 모두 나타낸다. 예를 들어, 매핑은 감지된 애플리케이션 변경 사 항이 파이프라인 아티팩트와 연결된 마이크로 서비스에 어떻게 영향을 미치는지에 대한 종속성 정보를 제공할 수 있다. 애플리케이션 아티팩트들과 파이프라인 아티팩트들 사이의 관계를 나타내는 영향 분석은 하나 또는 그 이상의 연관된 ML 모델(들)을 훈련시키는 데 사용된다. 따라서, 여기에 도시된 단계들은 애플리케이션 아 티팩트들의 수집 및 파이프라인 아티팩트들의 수집을 나타내며, 이들은 애플리케이션 아티팩트들의 직접적 및 간접적 관계를 캡쳐하기 위한 종속성 그래프를 생성하고, 하나 또는 그 이상의 ML 모델(들)의 훈련을 위해 애플 리케이션 및 파이프라인 아티팩트들 사이의 관계를 결정하도록 영향분석을 수행한다. 도 1에 도시되고 설명된 바와 같이, ML 관리자는 파이프라인의 최적화를 지원하고 가능하게 하기 위해 하나 또는 그 이상의 ML 모델(들)(164A) -(164N)을 지원하고 가능하게 하는 기능을 한다. 도 4를 참조하면, 파이프라인의 자동 및 선택적 최적화를 위한 프로세스를 도시한 플로 차트가 제공된다. 도시된 바와 같이, 파이프라인은 마이크로 서비스의 재배치에 영향을 미치거나 야기시킬 하나 또는 그 이상의 애플리케이션 아티팩 트들의 모든 변경을 식별하기 위해 모니터링된다. 도 3에 생성된 하나 또는 그 이상의 ML 모델(들)을 이용 하여, 식별된 변경이 하나 또는 그 이상의 파이프라인 아티팩트(들)와 관련이 있는지 평가하기 위한 결정이 이 루어진다. 결정에 대한 부정적인 응답은 파이프라인 아티팩트(들)가 식별된 변경에 의해 영향을 받지 않고 파이프라인이 현재 구성으로 유지되고, 지속적인 모니터링을 위해 단계로 돌아가는 것을 나타낸다. 단계에서의 결정에 대한 긍정적인 응답은 식별된 변경이 하나 또는 그 이상의 파이프라인 아티팩트들에 영 향을 미치고 영향을 받은 파이프라인 아티팩트들에 대한 규칙이 생성됨을 나타낸다. 보다 구체적으로, 단 계에서 각각의 영향을 받는 파이프라인 아티팩트의 서브루틴(subroutines)을 호출하도록 지시된 규칙이 생 성된다. 예를 들어, 상기 규칙은 영향을 받는 특정 파이프라인 아티팩트의 배치 또는 재배치를 지시할 수 있다. 본 명세서에 도시된 바와 같이, 하나 또는 그 이상의 규칙을 생성하는 것에 추가하여, 단계에서 이루어진 긍정적인 결정으로부터 대응하는 관계 정보가 상기 지식 베이스에 저장되는 것으로 여기에서 도시된다 . 일 실시예에서, 단계에서 상기 규칙을 업데이트하고 단계에서 관계 정보를 저장하는 것은 병렬로 발 생할 수 있다. 따라서, 하나 또는 그 이상의 마이크로 서비스의 재배치를 유발하는 변경이 식별되고, 상기 식별 된 변경이 하나 또는 그 이상의 파이프라인 아티팩트(들)에 영향을 미치는지를 결정하기 위해 평가가 수행된다. 단계 다음에, 생성된 규칙들에 기초한 피드백이 수집되고 대응하는 ML 모델(들)에 적용된다. 일 실시예에서, 단계에서 수집된 피드백은 주제 전문가(SME)로부터 나온다. 마찬가지로, 일 실시예에서, 수집된 피드백은 영향을 받은 파이프라인 아티팩트의 배치 또는 재배치에 대응하는 실시간 데이터를 포함할 수 있다. 일 실시예에서, 단계에서의 피드백의 적용은 선택적이다. 생성된 규칙은 파이프라인으로 인코드된이 다. 애플리케이션 아티팩트들과 파이프라인 아티팩트들 사이의 식별된 관계(종속성 패턴이라고도 함)는 생 성된 규칙과 연관되어 향후 프로세스에서 반복 가능한 패턴을 식별하기 위해 캡쳐되고, 캡쳐된 종속성 패 턴은 ML 모델에 대한 피드백으로 지식 베이스에 저장된다. 일 실시예에서, 데이터 처리는 파이프라인 아티 팩트들과 관련된 소프트웨어 엘리멘트들(elements)을 식별하기 위해 사용될 수 있다. 식별된 패턴의 예는 애플 리케이션 아티팩트에서 모니터링되거나 감지된 변경에 대응하는 하나 또는 그 이상의 마이크로 서비스의 배치 또는 재배치다. 수집되어 인코드된 규칙에 통합된 모든 사용자 피드백은 여기서 보여지고 지식 베이스에 저장된다. 단계에서 종속성 패턴의 캡처 후에, 인코드된 규칙이 있는 파이프라인이 배치된다. 인코드된 규칙이 있는 파이프라인의 배치는 단계에서 식별된 변경에 의해 영향을 받는 파이프라인 아티팩 트만이 재배치를 위해 파이프라인으로 인코딩되는 최적화된 파이프라인을 생성한다. 최적화된 파이프라인은 신 뢰성 수준을 유지하면서 파이프라인의 재배치를 위한 효율적인 프로세스를 생성한다. 단계 다음에, 프로세 스는 지속적인 모니터링을 위해 단계로 돌아간다. 따라서, 생성된 규칙은 파이프라인에 인코딩되어 배치에 최적화된 파이프라인을 생성한다. 학습 종속성들에 의해 식별된 변경들에 기초하여 파이프라인 아티팩트들을 자동으로 그리고 선택적으로 최적화하는 실시 예들이 도 1 및 도 2에, 각각, 도시된 툴들 및 API와 도 3 및 도 4에 도시된 프로세스들로 도 시되고 설명된다. 기능적 툴들, , 및 의 실시 예들 및 이들의 연관된 기능들은 단일 위치 의 컴퓨터 시스템/서버에 구현될 수 있거나, 또는 일 실시예에서, 컴퓨팅 자원들을 공유하는 클라우드 기반 시 스템에서 구성될 수 있다.도 5를 참조하면, 컴퓨터 시스템/서버의 일 예를 나타내는 블록 다이어그램(50 0)이 제공된다. 컴퓨터 시스템/서버는 이후에 호스트로 언급되며, 이는 도 3-4에 관해 위에서 설명된 시스템 및 프로세스들을 구현하기 위해, 클라우드 기반 지원 시스템과 통신한다. 호스트는 수많은 다른 범 용 또는 전용 컴퓨팅 시스템 환경들 또는 구성들에서 동작한다. 호스트와 함께 사용하기에 적합할 수 있는 잘 알려진 컴퓨팅 시스템들, 환경들, 및/또는 구성들의 예들은, 개인용 컴퓨터 시스템들, 서버 컴퓨터 시스템들, 신 클라이언트들(thin clients), 시크 클라이언트들(thick clients), 핸드-헬드 또는 랩탑 디바이스 들, 멀티프로세서 시스템들, 마이크로프로세서 기반 시스템들, 셋탑 박스들, 프로그램가능 커스터머 전자장치들 (programmable consumer electronics), 네트워크 PC들, 미니컴퓨터 시스템들, 메인프레임 컴퓨터 시스템들, 및 파일 시스템들(예컨대, 분산된 스토리지 환경들 및 분산된 클라우드 컴퓨팅 환경들)을 포함하며, 이들은 위와 같은 시스템들, 디바이스들, 및 그들의 균등물들 중 어떤 것을 포함한다. 그리고, 상기 예들로 한정되는 것은 아니다. 호스트는 컴퓨터 시스템에 의해 실행되는 프로그램 모듈들과 같은 컴퓨터 시스템-실행가능 명령들 의 일반적인 맥락에서 설명될 수 있다. 일반적으로, 프로그램 모듈들은 루틴들, 프로그램들, 객체들, 컴포넌트 들, 로직, 데이터 구조들 등을 포함할 수 있는데, 이것들은 특정 태스크들을 수행하거나 특정 추상적 데이터 유 형들을 구현한다. 호스트는 분산된 클라우드 컴퓨팅 환경들에서 실시될 수 있으며, 분산된 클라우드 컴퓨팅 환경들에서 태스크들은 통신망을 통해 링크된 원격 처리 디바이스들에 의해 수행된다. 분산된 클라 우드 컴퓨팅 환경에서, 프로그램 모듈들은 메모리 스토리지 디바이스들을 포함하는 로컬 컴퓨터 시스템 스토리 지 매체와 원격 컴퓨터 시스템 스토리지 매체 둘 다에 위치할 수 있다. 도 5에 도시된 바와 같이, 호스트는 범용 컴퓨팅 디바이스의 형태로 도시되어 있다. 호스트의 컴포넌트들은, 하나 또는 그 이상의 프로세서들 또는 처리 유닛들, 시스템 메모리, 및 버스를 포함할 수 있으나 이러한 예들로 한정되는 것은 아니다. 버스는 시스템 메모리를 포함하는 다양한 시 스템 컴포넌트들을 프로세서에 결합시킨다. 버스는, 메모리 버스 또는 메모리 컨트롤러, 주변 버스, 가속 그래픽스 포트(accelerated graphics port), 및 프로세서 또는 로컬 버스 - 이것들은 다양한 버스 아키텍 쳐들 중 어떤 것을 사용함 - 를 포함하는 몇 가지 유형의 어떤 버스 구조들 중 하나 또는 그 이상을 나타낸다. 예로서 이러한 아키텍쳐들은 산업 표준 아키텍쳐(Industry Standard Architecture, ISA) 버스, 마이크로 채널 아키텍쳐(Micro Channel Architecture, MCA) 버스, 향상된(Enhanced) ISA(EISA) 버스, 비디오 전자 표준 협회 (Video Electronics Standards Association, VESA) 로컬 버스, 및 주변 컴포넌트 인터커넥츠(Peripheral Component Interconnects, PCI) 버스를 포함하나, 이러한 예로 한정되는 것은 아니다. 호스트는 일반적으 로 다양한 컴퓨터 시스템 판독가능 매체를 포함한다 이러한 매체는 호스트에 의해 접근가능한 어떤 이용가 능한 매체일 수 있으며, 휘발성 및 비휘발성 매체, 착탈식 및 고정식 매체 둘 다를 포함할 수 있다. 메모리는 휘발성 메모리 형태의 컴퓨터 시스템 판독가능 매체를 포함할 수 있는데, 컴퓨터 시스템 판독가능 매체는, 예컨대, 랜덤 억세스 메모리(random access memory, RAM) 및/또는 캐시 메모리일 수 있다. 예로서(단지 예를 든 것임), 고정식, 비휘발성 자기 매체(도시되지 않았고 일반적으로 \"하드 드라이브\"로 일컬어짐)로부터 읽기 위해 그리고 고정식, 비휘발성 자기 매체에 쓰기 위해 스토리지 시스템(53 4)이 제공될 수 있다. 비록 도시되지는 않았으나, 착탈식, 비휘발성 자기 디스크(예컨대, \"플로피 디스크\")로부 터 읽고 착탈식, 비휘발성 자기 디스크에 쓰기 위한 자기 디스크 드라이브, 그리고 예를 들어 CD-ROM, DVD-ROM 또는 다른 광 매체와 같은 착탈식, 비휘발성 광 디스크로부터 읽거나 그러한 착탈식, 비휘발성 광 디스크에 쓰 기 위한 광 디스크 드라이브가 제공될 수 있다. 이러한 경우들에 있어서, 각각은 하나 또는 그 이상의 데이터 매체 인터페이스들에 의해 버스에 연결될 수 있다. 예를 들어, 운영체제, 하나 또는 그 이상의 어플리케이션 프로그램들, 다른 프로그램 모듈들, 및 프로그 램 데이터 뿐만 아니라(이러한 예로 한정되는 것은 아님), 프로그램 모듈들의 세트(적어도 하나의)를 갖는 프로그램/ 유틸리티가 메모리에 저장될 수 있다. 운영체제들, 하나 또는 그 이상의 어플리케이션 프 로그램들, 다른 프로그램 모듈들, 및 프로그램 데이터 또는 이것들의 몇몇 조합 각각은 네트워킹 환경의 구현을 포함할 수 있다. 프로그램 모듈은 일반적으로 학습 종속성들에 의해 식별된 변경들에 기초하여 DevOps 파 이프라인 아티팩트들을 자동으로 선택하여 통합하는 실시예들의 기능들 및/또는 방법들을 수행한다. 예를 들어, 프로그램 모듈들의 세트는 도 1에서 설명된 툴들(152, 154, 및 156)로 구성된 모듈들을 포함할 수 있다. 호스트는 또한, 키보드, 포인팅 디바이스, 감각 출력 디바이스(sensory output device) 등과 같은 하나 또는 그 이상의 외부 디바이스들; 디스플레이; 사용자에게 호스트와 상호작용할 수 있도록 하는 하나 또는 그 이상의 디바이스들; 및/또는 호스트에게 하나 또는 그 이상의 다른 컴퓨팅 디바이스들 과 통신할 수 있도록 하는 어떤 디바이스들(예컨대, 네트워크 카드, 모뎀 등)으로 통신할 수 있다. 이러한 통신 은 입력/출력(I/O) 인터페이스(들)을 통해 발생할 수 있다. 또한, 호스트는 네트워크 어댑터를 통해 근거리 통신망(local area network, LAN), 일반적인 광역 통신망(wide area network, WAN), 및/또는 공용 통신망(예컨대, 인터넷)과 같은 하나 또는 그 이상의 통신망들로 통신할 수 있다. 도시된 바와 같이, 네트워크 어댑터는 버스를 통해 호스트의 다른 컴포넌트들과 통신한다. 일 실시예에서, 분산된 파일 시스 템(도시되지 않음)의 복수의 노드들은 I/O 인터페이스를 통해 또는 네트워크 어댑터를 통해 호스트 와 통신한다. 비록 도시되지는 않았으나, 호스트와 함께 다른 하드웨어 및/또는 소프트웨어 컴포넌트 들이 사용될 수 있다는 것이 이해되어야 한다. 예들은 마이크로코드, 디바이스 드라이버들, 리던던트 처리 유닛 들, 외부 디스크 드라이브 어레이들, RAID 시스템들, 테이프 드라이브들, 및 데이터 기록 스토리지 시스템들 (data archival storage systems) 등을 포함하지만, 이러한 예들로 한정되는 것은 아니다. 본 명세서에서, \"컴퓨터 프로그램 매체\", \"컴퓨터 사용가능 매체\", 및 \"컴퓨터 판독가능 매체\" 라는 용 어들은, RAM, 캐시, 및 스토리지 시스템 - 예컨대, 착탈식 스토리지 드라이브 및 하드 디스크 드라이브에 설치된 하드 디스크 -를 포함하는, 메인 메모리와 같은 매체를 일반적으로 지칭하기 위해 사용 된다. 컴퓨터 프로그램들(이는 또한 컴퓨터 컨트롤 로직으로도 일컬어짐)은 메모리에 저장된다. 컴퓨터 프로그램들은 또한 네트워크 어댑터와 같은 통신 인터페이스를 통해 수신될 수 있다. 이러한 컴퓨터 프로 그램들은, 실행될 때, 컴퓨터 시스템에게 여기에서 논의되는 본 발명의 실시예들의 특징들을 수행하도록 할 수 있다. 특히, 컴퓨터 프로그램들은, 실행될 때, 처리 유닛에게 컴퓨터 시스템의 특징들을 수행하도록 할 수 있다. 따라서, 이러한 컴퓨터 프로그램들은 컴퓨터 시스템의 컨트롤러들을 나타낸다. 일 실시예에서, 호스트는 클라우드 컴퓨팅 환경의 하나의 노드이다. 당해 기술 분야에서 알려진 바 와 같이, 클라우드 컴퓨팅은, 최소한의 유지관리 노력 또는 서비스 공급자와의 상호작용으로 빠르게 공급되고 배치될 수 있는 설정가능한 컴퓨팅 자원들(예컨대, 통신망들, 통신망 대역폭, 서버들, 처리(processing), 메모 리, 스토리지, 어플리케이션들, 가상 머신들, 및 서비스들)의 공유 풀(shared pool)에 대한 편리한, 주문형 통 신망 접근을 가능하게 하기 위한 서비스 전달 모델이다. 이 클라우드 모델은 적어도 다섯 개의 특징들, 적어도 세 개의 서비스 모델들, 및 적어도 네 개의 배치 모델들(deployment models)을 포함할 수 있다. 이러한 특성들 의 예들인 이하와 같다. 주문형 셀프 서비스(on-demand self-service): 클라우드 소비자는, 서비스의 공급자와의 인적 상호작용 을 필요로 함이 없이 자동으로 요구됨에 따라, 서버 시간 및 네트워크 스토리지와 같은 컴퓨팅 기능들을 일방적 으로 제공할 수 있다. 광범위한 통신망 접근(Broad network access): 기능들은 네트워크를 통해 이용가능하고 이종 (heterogeneous)의 신 클라이언트 플랫폼(thin client platform) 또는 시크 클라이언트 플랫폼(thick client platform)(예컨대, 모바일 전화기들, 랩탑 컴퓨터들, 및 PDA들)에 의한 사용을 촉진하는 표준 메커니즘들을 통 해 접근된다. 자원 풀링(resource pooling): 공급자의 컴퓨팅 자원들은 멀티 테넌트 모델(multi-tenant model)을 사 용하여 다수의 소비자들에게 제공하도록 모여(pool) 있다. 여기서는, 상이한 물리적 및 가상 자원들이 수요에 따라 동적으로 할당 및 재할당된다. 일반적으로 소비자가 공급받은 자원들의 정확한 위치에 대한 아무런 컨트롤 도 하지 않거나 어떠한 지식도 갖지 않지만 더 높은 추상화의 계층에서의 위치(예컨대, 나라, 주, 또는 데이터 센터)를 명시할 수 있다는 점에서 위치 독립감(a sense of location indepedence)이 있다. 빠른 탄력성(rapid elasticity): 빠르게 축소(scale out)하고 빠르게 배치(release)되어 빠르게 확장 (scale in)하기 위해, 기능들은 빠르고 탄력적으로, 몇몇 경우들에 있어서는 자동적으로 공급될 수 있다. 소비 자에 대하여는, 공급을 위해 이용가능한 기능들은 종종 무제한으로 보일 수 있고 아무 때나 얼마든지 구매될 수 있다. 측정된 서비스(Measured service): 클라우드 시스템들은, 서비스의 유형(예컨대, 스토리지, 처리, 대역 폭, 및 액티브 사용자 어카운트들(active user accounts))에 적절한 일부 추상화 계층에서 계량 기능(meteringcapability)을 활용함으로써, 자원 사용을 자동으로 컨트롤하고 최적화한다. 자원 사용량은 모니터링되고, 컨트 롤되고, 보고되어, 이용되는 서비스의 공급자와 소비자 둘 다에 대한 투명성을 제공한다. 서비스 모델들은 다음과 같다. 소프트웨어 서비스(Software as a Service, SaaS) : 소비자에게 공급되는 기능은 클라우드 하부구조에서 실행되는 공급자의 어플리케이션들을 사용하는 것이다. 어플리케이션들은 웹 브라우저(예컨대, 웹 기반 이메 일)와 같은 신 클라이언트 인터페이스(thin client interface)를 통해 다양한 클라이언트 디바이스들로부터 접 근가능하다. 소비자는, 제한된 사용자 특정 어플리케이션 구성 설정들은 예외적으로 가능하지만, 네트워크, 서 버들, 운영체제들, 스토리지, 또는 심지어 개개의 어플리케이션 기능들을 포함하는 근본적인 클라우드 하부구조 를 관리하거나 컨트롤하지 않는다. 플랫폼 서비스(Platform as a Service, PaaS) : 공급자에 의해 지원되는 프로그래밍 언어들 및 툴들을 사용하여 생성된 클라우드 하부구조 소비자-생성 또는 획득 어플리케이션들에 배치하기 위한 기능이 소바자에게 제공된다. 소비자는 네트워크들, 서버들, 운영체제들, 또는 스토리지를 포함하는 근본적인 클라우드 하부구조를 관리 또는 컨트롤하지는 않지만 배치된 어플리케이션들 및 가능하게는 어플리케이션 호스팅 환경 구성들에 대해 서는 컨트롤한다. 하부구조 서비스(Infrastructure as a Service, IaaS): 처리, 스토리지, 네트워크들, 그리고 소비자가 임의의 소프트웨어를 배치하고 실행할 수 있는 다른 근본적인 컴퓨팅 자원들을 제공하기 위한 기능이 제공된다. 상기 근본적인 컴퓨팅 자원들은 운영 체제들 및 어플리케이션들을 포함할 수 있다. 소비자는 근본적인 클라우드 하부구조를 관리 또는 컨트롤하지는 않지만 운영 체제들, 스토리지, 배치된 어플리케이션들을 통해서 컨트롤하 고, 가능하게는 선택된 네트워킹 컴포넌트들(예컨대, 호스트 방화벽들)에 제한되게 컨트롤한다. 배치 모델들(Deployment Models)은 다음과 같다. 사설 클라우드(Private cloud): 클라우드 하부구조는 오로지 조직을 위해 동작된다. 그것은 조직 또는 제3자에 의해 관리될 수 있고 구내에(on-premises) 또는 구외에(off-premises) 존재할 수 있다. 커뮤니티 클라우드: 클라우드 하부구조는 몇 개의 조직들에 의해 공유되고, 관심사(concerns)(예컨대, 임무(mission), 보안 요구사항(security requirements), 정책(polity), 및 준수 고려사항(compliance considerations))을 공유한 특정 커뮤니티를 지원한다. 그것은 조직들 또는 제3자에 의해 관리될 수 있고 구내 에 또는 구외에 존재할 수 있다. 공공 클라우드(Public cloud): 클라우드 하부구조는 일반 공공 또는 대규모 산업 그룹에 이용가능하도록 만들어지고 클라우드 서비스들을 판매하는 조직에 의해 소유된다. 하이브리드 클라우드(Hybrid cloud): 클라우드 하부구조는 독특한 엔티티들로 남아 있지만 데이터 및 어 플리케이션 이동성(portability)(예컨대, 클라우드들 간의 부하 밸런싱을 위한 클라우드 버스팅(cloud bursting))을 가능하게 하는 표준화 또는 독점적(proprietary) 기술에 의해 함께 결합되는 두 개 또는 그 이상 의 클라우드들(사설, 커뮤니티, 또는 공공)의 구성(composition)이다. 클라우드 컴퓨팅 환경은, 상태 비보존(statelessness), 낮은 결합(low coupling), 모듈화(modularity), 및 의미론적 상호운용성(semantic interoperability)에 중점을 두고 서비스 지향적이다. 클라우드 컴퓨팅의 핵 심에는 상호연결된 노드들의 네트워크를 포함하는 하부구조가 있다. 이제 도 6을 참조하면, 클라우드 컴퓨팅 네트워크 도시되어 있다. 도시된 바와 같이, 클라우드 컴 퓨팅 네트워크는 하나 또는 그 이상의 클라우드 컴퓨팅 노드들을 갖는 클라우드 컴퓨팅 환경을 포함한다. 클라우드 컴퓨팅 노드들로 클라우드 소비자들에 의해 사용되는 로컬 컴퓨팅 디바이스들이 통신 할 수 있다. 이들 로컬 컴퓨팅 디바이스들의 예들은, 개인용 디지털 보조기기(PDA) 또는 셀룰러 전화기(654A), 데스크탑 컴퓨터(654B), 랩탑 컴퓨터(654C), 및 또는 자동차 컴퓨터 시스템(654N)을 포함하지만, 이러한 예로 한정되는 것은 아니다. 노드들 내에서 개별 노드들은 나아가 서로 간에 통신할 수 있다. 그들은 위에서 설 명된 바와 같은 사설, 커뮤니티, 공공, 또는 하이브리드 클라우드들, 또는 이것들의 조합으로 물리적으로 또는 가상으로 그룹핑될 수 있다(도시되지 않음). 이는 클라우드 컴퓨팅 환경에게 클라우드 소비자가 로컬 컴퓨 팅 디바이스 상에 자원들을 유지할 필요가 없는 서비스들로서 하부구조, 플랫폼들 및/또는 소프트웨어를 제공하 는 것을 가능하게 한다. 도 6에 도시된 컴퓨팅 디바이스들의 유형들(654A - N)은 단지 예시하려는 의도로 이해 되고 또한 클라우드 컴퓨팅 환경이 어떤 네트워크의 유형 및/또는 네트워크 주소지정가능(addressable) 연결(예컨대, 웹 브라우저를 사용하여)을 통해 컴퓨터화된 디바이스의 어떤 유형과 통신할 수 있다는 것이 이해된 다. 이제 도 7을 참조하면, 도 6의 클라우드 컴퓨팅 네트워크에 의해 제공되는 기능적 추상화 계층들의 세트 가 도시되어 있다. 도 7에 도시된 컴포넌트들, 계층들, 및 기능들은 단지 예시하려는 의도이고 이 실시예 들로 한정되어서는 아니된다는 것이 먼저 이해되어야 한다. 도시된 바와 같이, 이하의 계층들 및 대응되는 기능 들이 제공된다. 즉, 하드웨어 및 소프트웨어 계층, 가상화 계층, 관리 계층, 및 워크로드 계층 이다. 하드웨어 및 소프트웨어 계층은 하드웨어 및 소프트웨어 컴포넌트들을 포함한다. 하드웨어 컴포넌 드들의 예들은, 메인프레임(mainframe), 일 예로 IBM®zSeries®시스템들; RISC(감소된 명령 세트 컴퓨터 (Reduced Instruction Set Computer)) 아키텍쳐 기반 서버들, 일 예로 IBM pSeries® 시스템들, IBM xSeries® 시스템들; IBM BladeCenter® 시스템들; 스토리지 디바이스들; 네트워크들 및 네트워킹 컴포넌트들을 포함한다. 소프트웨어 컴포넌트들의 예들은 네트워크 어플리케이션 서버 소프트웨어, 일 예로, IBM WebSphere® 어플리케이 션 서버 소프트웨어; 및 데이터베이스 소프트웨어, 일 예로 IBM DB2® 데이터 베이스 소프트웨어를 포함한다. (IBM, zSeries, pSeries, xSeries, BladeCenter, WebSphere, 및 DB2는 전 세계의 많은 관할 구역에서 등록된 인터내셔널 비즈니스 머신즈 코퍼레이션(International Business Machines Corporation)의 상표들이다). 가상화 계층은 가상 엔티티들의 다음과 같은 예들이 제공될 수 있는 추상화 계층을 제공한다. 즉, 가상 서버들; 가상 스토리지; 가상 사설 네트워크들을 포함하는 가상 네트워크들; 가상 어플리케이션들 및 운영 체제들; 및 가상 클라이언트들이 그 예이다. 일 예에서, 관리 계층은 다음과 같은 기능들을 제공한다. 즉, 자원 공급(resource provisioning), 계량 및 가격 설정(metering and pricing), 사용자 포털(user portal), 서비스 계층 관리(service layer management), 및 SLA 계획 및 이행이 그것이다. 자원 공급은 컴퓨팅 자원들 및 클라우드 컴퓨팅 환경 내에서 태 스크들을 수행하기 위해 이용되는 다른 자원들의 동적(dynamic) 조달(procurement)을 제공한다. 계량 및 가격 설정은, 클라우드 컴퓨팅 환경 내에서 자원들이 이용됨에 따른 비용 추적(cost tracking), 및 이들 자원들의 소 비에 대한 과금 및 청구서 작성(billing or invoicing)을 제공한다. 일 실시예에서, 이들 자원들은 어플리케이 션 소프트웨어 라이선스들을 포함할 수 있다. 보안(security)은 데이터 및 다른 자원들에 대한 보호뿐만 아니라 클라우드 소비자들 및 태스크들에 대한 신원 확인을 제공한다. 사용자 포털(user portal)은 소비자들 및 시스템 관리자들에게 클라우드 컴퓨팅 환경에 대한 접근을 제공한다. 서비스 수준 관리 계층은 요구되는 서비스 계층들 이 충족되도록, 클라우드 컴퓨팅 자원 할당 및 관리를 제공한다. 서비스 계층 동의(Service Layer Agreement, SLA) 계획 및 이행은 SLA에 따라 장래의 요구가 예상되는 클라우드 컴퓨팅 자원들의 사전준비(prearrangement), 및 조달(procurement)을 제공한다. 워크로드들 계층은 클라우드 컴퓨팅 환경이 이용될 수 있는 기능들의 예들을 제공한다. 이러한 계 층으로부터 제공될 수 있는 워크로드들 및 기능들의 예들은, 맵핑 및 내비게이션, 소프트웨어 개발 및 라이프사 이클 관리, 가상 교실 훈련 전달; 데이터 분석 처리; 트랜잭션 처리(transaction processing); 및 파이프라인의 자동 및 선택적 최적화(automatic and selective optimization of the pipeline)를 포함하나, 이러한 예들로 한정되는 것은 아니다. 특정 실시예들이 도시되고 설명되었으나, 여기에서의 기술적 사상에 기초하여, 본 발명의 실시 예들을 확장하지 않고서 변경들 및 수정들이 이뤄질 수 있다는 것은 당해 기술 분야에서 통상의 기술자에게는 자명할 것이다. 그러므로, 첨부된 청구항들은 실시예들의 실제 범위 내에 있는 그러한 모든 변경들 및 수정들을 그것들 의 범위 내에 포함하는 것이다. 더욱이, 실시예들은 오로지 첨부된 청구항들에 의해 정의된다는 것이 이해되어 야 한다. 당해 기술 분야에서 통상의 기술자들은, 만약 특정 번호의 소개된 청구항의 구성요소가 의도된다면, 청구항에 그러한 의도가 분명히 언급될 것이고, 그러한 언급이 없을 시 그러한 한정은 존재하지 않는다는 것은 당해 기술 분야에서 통상의 기술자들에 의해 이해될 것이다. 예를 한정하지 않고서 이해를 돕기 위해, 이하의 청구항들은 도입 문구들인 \"적어도 하나의\" 및 \"하나 또는 그 이상\"의 사용을 포함하여, 청구항의 구성요소들을 소개한다. 하지만, 이러한 문구들의 사용은, 심지어 동일한 청구항이 도입 문구들인 \"하나 또는 그 이상의\" 또 는 \"적어도 하나의\", 그리고 \"하나\"와 같은 단어를 포함할 때에도, 비한정적인 단어인 \"하나\"에 의해 청구항의 소개가 단지 하나의 그러한 구성요소를 포함하는 실시예들에 소개된 그러한 청구항 구성요소들을 포함하는 어떤특정 청구항을 한정하는 것을 의미하도록 해석되어서는 아니되며, 이는 한정하지 않는 단어들을 청구항에서 사 용할 경우에도 마찬가지이다. 본 발명의 실시예(들)은 시스템, 방법, 및/또는 컴퓨터 프로그램 제품일 수 있다. 또한, 본 발명의 실시 예(들)의 선택된 측면들은 전적으로 하드웨어 실시예, 전적으로 소프트웨어 실시예(펌웨어, 상주 소프트웨어, 마이크로-코드 등을 포함함), 또는 소프트웨어 및/또는 하드웨어 측면들을 결합하는 실시예의 형태를 취할 수 있다. 소프트웨어 및/또는 하드웨어 측면들을 결합하는 실시예는 모두 일반적으로 여기서는 \"회로\", \"모듈\" 또 는 \"시스템\"으로 일컬어질 수 있다. 더 나아가, 본 발명의 실시예(들)의 측면들은 컴퓨터 판독가능 스토리지 매 체(또는 매체들)에 구현되는 컴퓨터 프로그램 제품의 형태를 취할 수 있다. 컴퓨터 판독가능 스토리지 매체(또 는 매체)들은 그것에 대한 컴퓨터 판독가능 프로그램 명령들을 가지며, 컴퓨터 판독가능 프로그램 명령들은 프 로세서로 하여금 본 발명의 실시예(들)의 측면들을 수행하도록 한다. 그리하여, 구현되고, 개시된 시스템, 방법, 및/또는 컴퓨터 프로그램 제품은 어플리케이션들의 다목적 최적화의 기능 및 동작을 향상시키도록 동작한 다. 컴퓨터 판독가능 스토리지 매체는 명령 실행 디바이스에 의해 사용하기 위한 명령들을 보유하고 저장할 수 있는 유형적 디바이스일 수 있다. 컴퓨터 판독가능 스토리지 매체는, 예를 들어, 전자 스토리지 디바이스, 자기 스토리지 디바이스, 광 스토리지 디바이스, 전자기 스토리지 디바이스, 반도체 스토리지 디바이스, 또는 이것들의 어떤 적절한 조합일 수 있으나, 이러한 예로 한정되는 것은 아니다. 컴퓨터 판독가능 스토리지 매체의 더 많은 구체적인 예들의 리스트(전체를 다 열거한 것은 아님)는 또한 다음을 포함할 수 있다. 즉, 휴대용 컴퓨 터 디스켓, 하드 디스크, 동적(dynamic) 또는 정적(static) 랜덤 억세스 메모리(random access memory, RAM), 읽기 전용 메모리(read-only memory, ROM), 소거가능 프로그램가능 읽기 전용 메모리(erasable programmable read-only memory, EPROM 또는 플래쉬 메모리), 자기 스토리지 디바이스(magnetic storage device), 휴대용 컴 팩트 디스크 읽기 전용 메모리(portable compact disc read-only memory, CD-ROM), 디지털 다용도 디스크 (digital versatile disk, DVD), 메모리 스틱, 플로피 디스크, 펀치-카드들 또는 기록된 명령들을 갖는 홈 (groove)에서 볼록한 구조들과 같은 기계적으로 인코드된 디바이스, 및 앞서 열거한 것들의 어떤 적절한 조합을 포함할 수 있다. 여기서 사용되는 것과 같이, 컴퓨터 판독가능 스토리지 매체는, 무선 전파(radio waves) 또는 다른 자유롭게 전파되는 전자기파, 도파관 또는 다른 전송 매질을 통해 전파되는 전자기파(예컨대, 광섬유 케이 블을 통과하는 광 펄스), 또는 와이어를 통해 전송되는 전기적 신호와 같은 일시적인 신호들 그 자체로 해석되 는 것은 아니다. 여기에 설명되는 컴퓨터 판독가능 프로그램 명령들은, 예를 들어, 인터넷, 근거리 통신망, 광역 통신망 및/또는 무선 통신망과 같은 통신망을 통해 컴퓨터 판독가능 스토리지 매체로부터 각각의 컴퓨팅/처리 디바이스 들로, 또는 내부 컴퓨터 또는 외부 스토리지 디바이스로 다운로드될 수 있다. 네트워크는 동선 전송 케이블, 광 전송 섬유, 무선 전송, 라우터, 방화벽, 스위치, 게이트웨이 컴퓨터 및/또는 엣지(edge) 서버를 포함할 수 있다. 각각의 컴퓨팅/처리 디바이스에서 네트워크 어댑터 카드 또는 네트워크 인터페이스는, 각각의 컴퓨팅/처 리 디바이스 내 컴퓨터 판독가능 스토리지 매체에 저장하기 위해 네트워크로부터 컴퓨터 판독가능 프로그램 명 령들을 수신하고 컴퓨터 판독가능 프로그램 명령들을 전송한다. 본 발명의 실시예(들)의 동작들을 수행하기 위한 컴퓨터 판독가능 프로그램 명령들은 어셈블러 명령 (assembler instructions), 명령-세트-아키텍쳐(instruction-set-architecture, ISA) 명령, 머신 명령(machine instructions), 머신 종속 명령(machine dependent instructions), 마이크로코드, 펌웨어 명령(firmware instructions), 상태-세팅 데이터(state-setting data), 또는 하나 또는 그 이상의 프로그래밍 언어들의 어떤 조합으로 작성된 소스 코드 또는 객체 코드(object code)일 수 있다. 상기 프로그래밍 언어들은 스몰토크 (Smalltalk), C++ 등과 같은 객체 지향 프로그래밍 언어(object oriented programming language), 및 \"C\" 프로 그래밍 언어 또는 유사 프로그래밍 언어들과 같은 절차형 프로그래밍 언어들을 포함한다. 컴퓨터 판독가능 프로 그램 명령들은 독립형(stand-alone) 소프트웨어 패키지로서 사용자의 컴퓨터 상에서 전적으로, 사용자의 컴퓨터 상에서 부분적으로 실행될 수 있고, 사용자의 컴퓨터 상에서 부분적으로 그리고 원격 컴퓨터 상에서 부분적으로 실행될 수 있고, 또는 원격 컴퓨터 또는 서버 또는 서버들의 클러스터 상에서 전적으로 실행될 수 있다. 후자의 시나리오에 있어서, 원격 컴퓨터는 근거리 통신망(LAN) 또는 광역 통신망(WAN)을 포함하는 어떤 유형의 네트워 크를 통해 사용자의 컴퓨터에 연결될 수 있고, 또는 그 연결은 외부 컴퓨터에 대해 이뤄질 수 있다(예컨대, 인 터넷 서비스 공급자(Internet Service Provider)를 사용하여 인터넷을 통해서). 몇몇 실시예들에 있어서, 본 발 명의 실시예(들)의 측면들을 수행하기 위해, 예를 들어, 프로그램가능 로직 회로망(programmable logic circuitry), 필드-프로그램가능 게이트 어레이(field-programmable gate arrays, FPGA), 또는 프로그램가능 로직 어레이(Programmable logic arrays, PLA)를 포함하는 전자 회로망(electronic circuitry)이 그 전자 회로망 을 개인화(personalize)하기 위해 컴퓨터 판독가능 프로그램 명령들의 상태 정보를 이용함으로써 그 컴퓨터 판 독가능 프로그램 명령들을 실행할 수 있다. 본 발명의 실시예(들)의 측면들은 여기서 방법들, 장치들(시스템들), 및 컴퓨터 프로그램 제품들의 플로 우챠트 설명들 및/또는 블록 다이어그램들을 참조하여 설명된다. 플로우챠트 설명들 및/또는 블록 다이어그램들 에서 플로우챠트 설명들 및/또는 블록 다이어그램들의 각각의 블록, 및 블록들의 조합들은 컴퓨터 판독가능 프 로그램 명령들에 의해 구현될 수 있다는 것이 이해될 것이다. 이들 컴퓨터 판독가능 프로그램 명령들은 범용 컴퓨터(general purpose computer), 전용 컴퓨터 (special purpose computer), 또는 다른 프로그램가능 데이터 처리 장치의 프로세서에게 제공되어 머신 (machine)을 생성할 수 있으며, 그리하여 컴퓨터 또는 다른 프로그램가능 데이터 처리 장치의 프로세서를 통해 실행될 때 그 명령들이 플로우챠트 및/또는 블록 다이어그램 블록 또는 블록들에 명시된 기능들/동작들을 구현 하기 위한 수단을 생성하도록 한다. 이들 컴퓨터 판독가능 프로그램 명령들은 또한 컴퓨터 판독가능 스토리지에 저장될 수 있으며, 컴퓨터 판독가능 스토리지는 컴퓨터, 프로그램가능 데이터 처리 장치, 및/또는 다른 디바이 스들이 특정 방식으로 기능하도록 지시할 수 있다. 그리하여, 내부에 저장된 명령들을 갖는 컴퓨터 판독가능 스 토리지 매체가 플로우챠트 및/또는 블록 다이어그램의 블록 또는 블록들에 명시된 기능/동작의 측면들을 구현하 는 명령들을 포함하는 제조 물품을 포함하도록 한다. 컴퓨터 판독가능 프로그램 명령들은 또한 컴퓨터, 다른 프로그램가능 데이터 처리 장치, 또는 다른 다바 이스 상으로 로딩되어 컴퓨터, 다른 프로그램가능 장치 또는 다른 디바이스 상에서 수행될 일련의 동작 단계들 로 하여금 컴퓨터 구현 프로세스(computer implemented process)를 생성하게 할 수 있다. 그리하여 컴퓨터, 다 른 프로그램가능 장치, 또는 다른 디바이스 상에서 실행되는 명령들이 플로우챠트 및/또는 블록 다이어그램의 블록 또는 블록들에 명시된 기능들/동작들을 구현하도록 한다. 도면들에서 플로우챠트 및 블록 다이어그램들은 본 발명의 다양한 실시예들에 따른 시스템들, 방법들, 및 컴퓨터 프로그램 제품들의 가능한 구현의 아키텍쳐, 기능, 및 동작을 보여준다. 이 점에서, 플로우챠트 또는 블록 다이어그램들에서의 각각의 블록은 모듈, 세그먼트, 또는 명령들의 일부분을 나타낼 수 있으며, 이는 명시 된 논리적 기능(들)을 구현하기 위한 하나 또는 그 이상의 실행가능한 명령들을 포함한다. 몇몇 다른 구현들에 있어서, 블록들에 기재되어 있는 기능들은 도면들에 기재되어 있는 순서를 벗어나서 발생할 수도 있다. 예를 들 어, 연속해서 보여지는 두 개의 블록들은, 사실상, 실질적으로 동시에 일어날 수 있고, 또는 블록들은 때로는 관련된 기능에 따라 역순으로 실행될 수도 있다. 또한, 블록 다이어그램들 및/또는 플로우챠트 그림의 각각의 블록, 및 블록 다이어그램들 및/또는 플로우챠트 그림에서의 블록들의 조합들은 명시된 기능들 또는 동작들을 수행하거나 전용 하드웨어와 컴퓨터 명령들의 조합들을 수행하는 전용 하드웨어 기반 시스템들에 의해 구현될 수 있다는 것에 유의해야 할 것이다. 여기서는 예시의 목적으로 구체적인 실시예들이 설명되었지만, 본 발명의 범위를 벗어남이 없이 다양한 변형 예들이 만들어질 있다는 것이 이해될 것이다. 특히, 상기 지식 기반은 지역화되거나 원격에 있거나 여러 시스템에 걸쳐 분산될 수 있다. 따라서, 본 발명의 보호 범위는 이하의 청구항들과 그것들의 균등 범위에 의해 서만 한정된다. 도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7"}
{"patent_id": "10-2022-7039671", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 명세서에서 참조하는 도면들은 명세서의 일부이다. 도면들에 도시된 특징들은 달리 명시되지 않는 한 모든 실시예들이 아닌 일부 실시예들만을 예시하는 것을 의미한다. 도 1은 CI/CD 파이프라인의 자동 선택 및 최적화를 지원하고 가능하게 하는 컴퓨터 시스템의 개략도 (schematic diagram)를 도시한다. 도 2는 도1에 도시되고 설명된 AI 플랫폼 툴과 이들의 연관된 응용 프로그램 인터페이스(application program interfaces, APIs)를 예시하는 블록도를 도시한다. 도 3은 애프리케이션 아티팩트와 파이프라인 아티팩트 간의 관계를 결정하기 위해 영향 분석을 수행하기 위한 프로세스를 예시하는 플로차트를 도시한다. 도 4는 CI/CD 파이프라인의 자동 및 선택적 최적화를 위한 프로세스를 예시하는 플로차트를 도시한다. 도 5는 도 1-4와 관련하여 위에서 설명된 시스템 및 프로세스를 구현하기 위한 클라우드 기반 지원 시스 템의 컴퓨터 시스템/서버의 예를 예시하는 블록도를 도시한다. 도 6은 클라우드 컴퓨터 환경을 예시하는 블록도를 도시한다. 도 7은 클라우드 컴퓨팅 환경에 의해 제공되는 기능적 추상화 모델 계층의 세트를 예시하는 블록도를 도 시한다."}
