{"patent_id": "10-2022-0066221", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0166352", "출원번호": "10-2022-0066221", "발명의 명칭": "프로세싱 엘리먼트, 이를 포함하는 뉴럴 프로세싱 장치 및 이를 이용한 곱셈 연산 방법", "출원인": "리벨리온 주식회사", "발명자": "배재완"}}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "웨이트를 저장하는 웨이트 레지스터;인풋 액티베이션을 저장하는 인풋 액티베이션 레지스터;연산 모드 신호에 따라, 제1 프리시젼의 제1 멀티플라이어를 이용하거나, 상기 제1 멀티플라이어와 상기 제1 프리시젼의 제2 멀티플라이어를 모두 이용하여, 상기 웨이트 및 상기 인풋 액티베이션을 곱셈 연산하여 결과 데이터를 생성하는 플렉서블 멀티플라이어; 및상기 결과 데이터를 이용하여 부분합을 생성하는 새츄레이팅 애더를 포함하는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서,상기 플렉서블 멀티플라이어는, 상기 연산 모드 신호가 상기 제1 프리시젼과 연관된 제1 모드 신호인 경우, 상기 제1 멀티플라이어를 이용하여,상기 웨이트 및 상기 인풋 액티베이션을 곱셈 연산하고,상기 연산 모드 신호가 상기 제1 프리시젼 보다 큰 제2 프리시젼과 연관된 제2 모드 신호인 경우, 상기 제1 멀티플라이어와 상기 제2 멀티플라이어를 모두 이용하여, 상기 웨이트 및 상기 인풋 액티베이션을 곱셈 연산하는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2 항에 있어서,상기 플렉서블 멀티플라이어는,상기 연산 모드 신호가 상기 제2 모드 신호인 경우, 상기 제1 멀티플라이어에서 생성된 제1 부분곱 그룹과, 상기 제2 멀티플라이어에서 생성된 제2 부분곱 그룹의 자릿수를 정렬하여, 제1 정렬 부분곱 그룹 및 제2 정렬 부분곱 그룹을 생성하는 얼라이너를 포함하는, 프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3 항에 있어서,상기 플렉서블 멀티플라이어는, 상기 제1 정렬 부분곱 그룹을 연산하는 제1 부스 리덕션 트리; 및상기 제2 정렬 부분곱 그룹을 연산하는 제2 부스 리덕션 트리를 포함하고, 상기 제1 정렬 부분곱 그룹의 뎁스(depth)는 상기 제2 정렬 부분곱 그룹의 뎁스보다 큰,공개특허 10-2023-0166352-3-프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제3 항에 있어서,상기 플렉서블 멀티플라이어는, 상기 제1 정렬 부분곱 그룹을 연산하는 제1 부스 리덕션 트리; 및상기 제2 정렬 부분곱 그룹을 연산하는 제2 부스 리덕션 트리를 포함하고, 상기 제1 부스 리덕션 트리의 연산 가능한 뎁스(depth)는 상기 제2 부스 리덕션 트리의 연산 가능한 뎁스보다큰,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제3 항에 있어서,상기 플렉서블 멀티플라이어는, 상기 제1 정렬 부분곱 그룹을 연산하는 하나의 제1 부스 리덕션 트리; 및상기 제2 정렬 부분곱 그룹을 연산하는 복수의 제2 부스 리덕션 트리를 포함하는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제3 항에 있어서,상기 웨이트 및 상기 인풋 액티베이션이 각각 32비트 데이터이고, 상기 제1 프리시젼은 INT4이고, 상기 제2 프리시젼은 INT8인 경우, 상기 플렉서블 멀티플라이어는, 상기 제1 정렬 부분곱 그룹을 연산하는 하나의 제1 부스 리덕션 트리; 및상기 제2 정렬 부분곱 그룹을 연산하는 4개의 제2 부스 리덕션 트리를 포함하는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1 항에 있어서,상기 플렉서블 멀티플라이어는, 상기 제1 멀티플라이어와 상기 제2 멀티플라이어에서 생성된 부분곱 그룹을 이용하여, 상기 결과 데이터를 생성하는 부스 리덕션 트리를 포함하는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "공개특허 10-2023-0166352-4-제8 항에 있어서,상기 부스 리덕션 트리는, 상기 부분곱 그룹의 뎁스(depth)를 감소시키는 뎁스 리듀서; 및상기 뎁스 리듀서에 의해 뎁스가 감소된 부분곱 그룹에 대한 덧셈 연산을 수행하는 애더를 포함하는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1 항에 있어서,상기 제1 멀티플라이어와 상기 제2 멀티플라이어는 각각 k 개인,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10 항에 있어서,상기 웨이트 및 상기 인풋 액티베이션이 각각 32비트 데이터이고, 상기 제1 프리시젼은 INT4이고, 제2 프리시젼은 INT8인 경우, 상기 k는 8인,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1 항에 있어서,상기 플렉서블 멀티플라이어는, 상기 제1 멀티플라이어 및 상기 제2 멀티플라이어에서 생성된 부분곱 그룹을 이용하여, 제1 정렬 부분곱 그룹및 제2 정렬 부분곱 그룹을 생성하는 얼라이너; 상기 제1 정렬 부분곱 그룹을 연산하는 제1 부스 리덕션 트리; 상기 제2 정렬 부분곱 그룹을 연산하는 제2 부스 리덕션 트리; 및상기 제2 부스 리덕션 트리의 연산 결과에 대한 덧셈 연산을 수행하는 프리 애더를 포함하고,상기 제1 부스 리덕션 트리에서의 연산 결과와, 상기 프리 애더에서의 연산 결과는 상기 새츄레이팅 애더에 제공되는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1 항에 있어서,상기 플렉서블 멀티플라이어는,상기 웨이트를 이용하여 상기 제1 프리시젼의 제1 분할 웨이트를 생성하고, 상기 인풋 액티베이션을 이용하여상기 제1 프리시젼의 제1 분할 인풋 액티베이션을 생성하는 비트 디비젼 로직을 포함하는, 공개특허 10-2023-0166352-5-프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13 항에 있어서,상기 연산 모드 신호가 상기 제1 프리시젼과 연관된 제1 모드 신호인 경우, 상기 제1 멀티플라이어는 상기 제1 분할 웨이트와 상기 제1 분할 인풋 액티베이션을 이용하여 상기 결과 데이터를 생성하는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제13 항에 있어서,상기 패스 셀렉션 로직은,상기 연산 모드 신호가 상기 제1 프리시젼보다 큰 제2 프리시젼과 연관된 제2 모드 신호인 경우, 상기 비트 디비젼 로직은,상기 제1 분할 웨이트를 이용하여, 제1 상위 분할 웨이트 및 제1 하위 분할 웨이트를 생성하고, 상기 제1 분할 인풋 액티베이션을 이용하여, 제1 상위 분할 인풋 액티베이션 및 제1 하위 분할 인풋 액티베이션을 생성하는, 프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15 항에 있어서,상기 제1 하위 분할 웨이트 및 상기 제1 하위 분할 인풋 액티베이션은 각각 양의 값을 가지기 위한 엑스트라 비트를 포함하는, 프로세싱 엘리먼트."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "적어도 하나의 뉴럴 코어를 포함하고,상기 뉴럴 코어는,연산을 수행하는 프로세싱 유닛과,상기 프로세싱 유닛의 입출력 데이터를 저장하는 L0 메모리를 포함하고,상기 프로세싱 유닛은 적어도 하나의 프로세싱 엘리먼트를 포함하는 PE 어레이를 포함하고,상기 PE 어레이는,웨이트 및 인풋 액티베이션을 수신하고, 연산 모드 신호에 따라, 제1 프리시젼의 제1 멀티플라이어를 이용하거나, 상기 제1 멀티플라이어와 상기 제1 프리시젼의 제2 멀티플라이어를 모두 이용하여 복수의 부분곱 그룹을 생성하고, 상기 복수의 부분곱 그룹을 이용하여 결과 데이터를 생성하는 플렉서블 멀티플라이어와,상기 결과 데이터를 수신하여 부분합을 생성하는 새츄레이팅 애더를 포함하는,공개특허 10-2023-0166352-6-뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17 항에 있어서,상기 플렉서블 멀티플라이어는, 부스 알고리즘을 이용하여, 상기 복수의 부분곱 그룹을 덧셈 연산함으로써 상기 결과 데이터를 생성하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제17 항에 있어서,상기 플렉서블 멀티플라이어는, 상기 복수의 부분곱 그룹의 자릿수를 기초로 복수의 정렬 부분곱 그룹으로 그룹핑하고, 상기 복수의 정렬 부분곱 그룹을 덧셈 연산하여, 상기 결과 데이터를 생성하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0066221", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "웨이트, 인풋 액티베이션 및 연산 모드 신호를 수신하는 단계;상기 웨이트를 이용하여 복수의 분할 웨이트를 생성하는 단계;상기 인풋 액티베이션을 이용하여 복수의 분할 인풋 액티베이션을 생성하는 단계;상기 연산 모드에 따라, 상기 복수의 분할 웨이트 및 상기 복수의 분할 인풋 액티베이션이 제공될 멀티플라이어를 결정하는 단계;상기 멀티플라이어에서 생성된 제1 부분곱 그룹과 제2 부분곱 그룹의 자릿수를 정렬하여, 제1 정렬 부분곱 그룹과 제2 정렬 부분곱 그룹을 생성하는 단계; 및상기 제1 정렬 부분곱 그룹과 상기 제2 정렬 부분곱 그룹을 독립적으로 연산하여 결과 데이터를 생성하는 단계를 포함하는,곱셈 연산 방법."}
{"patent_id": "10-2022-0066221", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 프로세싱 엘리먼트, 포함하는 뉴럴 프로세싱 장치 및 이를 이용한 곱셈 연산 방법을 개시한다. 상기 프로세싱 엘리먼트는, 웨이트를 저장하는 웨이트 레지스터, 인풋 액티베이션을 저장하는 인풋 액티베이션 레지스 터, 연산 모드 신호에 따라, 제1 프리시젼의 제1 멀티플라이어를 이용하거나, 상기 제1 멀티플라이어와 상기 제1 프리시젼의 제2 멀티플라이어를 모두 이용하여, 상기 웨이트 및 상기 인풋 액티베이션을 곱셈 연산하여 결과 데 이터를 생성하는 플렉서블 멀티플라이어 및 상기 결과 데이터를 이용하여 부분합을 생성하는 새츄레이팅 애더를 포함한다."}
{"patent_id": "10-2022-0066221", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 프로세싱 엘리먼트, 이를 포함하는 뉴럴 프로세싱 장치 및 이를 이용한 곱셈 연산 방법에 관한 것이다. 구체적으로, 본 발명은 상대적으로 낮은 프리시젼의 멀티플라이어를 이용하여, 상대적으로 높은 프리시젼의 연산을 수행하는 프로세싱 엘리먼트, 이를 포함하는 뉴럴 프로세싱 장치 및 이를 이용한 곱셈 연산 방법에 관한 것이다."}
{"patent_id": "10-2022-0066221", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "지난 몇년간, 인공지능(Artificial Intelligence) 기술은 4차 산업혁명의 핵심 기술로 전세계적으로 가장 유망 한 기술로 거론되고 있다. 이러한 인공지능 기술의 가장 큰 문제는 컴퓨팅 성능이다. 인간의 학습능력과 추론능 력, 지각능력, 자연언어의 이행능력 등을 실현해내는 인공지능 기술은 많은 데이터를 빠르게 처리하는 것이 가 장 중요하다. 초기 인공지능의 딥러닝 학습과 추론에는 기성 컴퓨터의 중앙처리장치(CPU; Central processing unit)나 그래픽 처리장치(GPU; Graphics Processing Unit)가 쓰였지만, 높은 워크 로드를 가지는 딥러닝 학습 및 추론의 작업에 는 한계가 있어 구조적으로 딥러닝 작업에 특화된 신경망 처리 장치(NPU; Neural Processing Unit)가 각광받고 있다. 신경망 처리 장치는 일반적으로 특정한 프리시젼(precision)의 데이터를 이용할 수 있다. 데이터의 비트 수가 클수록 데이터가 정밀하게 표현될 수 있지만, 그만큼 하드웨어 리소스가 많이 필요할 수 있다. 선행기술문헌 특허문헌 (특허문헌 0001) 등록특허공보 제10-1981109호"}
{"patent_id": "10-2022-0066221", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명의 과제는, 상대적으로 낮은 프리시젼의 멀티플라이어를 이용하여, 상대적으로 높은 프리시젼의 연산을 수행하는 프로세싱 엘리먼트를 제공하는 것이다. 본 발명의 다른 과제는, 상대적으로 낮은 프리시젼의 멀티플라이어를 이용하여, 상대적으로 높은 프리시젼의 연 산을 수행하는 뉴럴 프로세싱 장치를 제공하는 것이다. 본 발명의 또 다른 과제는, 상대적으로 낮은 프리시젼의 멀티플라이어를 이용하여, 상대적으로 높은 프리시젼의 연산을 수행하는 방법을 제공하는 것이다. 본 발명의 목적들은 이상에서 언급한 목적으로 제한되지 않으며, 언급되지 않은 본 발명의 다른 목적 및 장점들 은 하기의 설명에 의해서 이해될 수 있고, 본 발명의 실시예에 의해 보다 분명하게 이해될 것이다. 또한, 본 발 명의 목적 및 장점들은 특허 청구 범위에 나타낸 수단 및 그 조합에 의해 실현될 수 있음을 쉽게 알 수 있을 것 이다."}
{"patent_id": "10-2022-0066221", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "상기 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 프로세싱 엘리먼트는 웨이트를 저장하는 웨이트 레지 스터, 인풋 액티베이션을 저장하는 인풋 액티베이션 레지스터, 연산 모드 신호에 따라, 제1 프리시젼의 제1 멀 티플라이어를 이용하거나, 상기 제1 멀티플라이어와 상기 제1 프리시젼의 제2 멀티플라이어를 모두 이용하여, 상기 웨이트 및 상기 인풋 액티베이션을 곱셈 연산하여 결과 데이터를 생성하는 플렉서블 멀티플라이어 및 상기 결과 데이터를 이용하여 부분합을 생성하는 새츄레이팅 애더를 포함한다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 상기 연산 모드 신호가 상기 제1 프리시젼과 연관된 제1 모드 신호인 경우, 상기 제1 멀티플라이어를 이용하여, 상기 웨이트 및 상기 인풋 액티베이션을 곱셈 연산하고, 상기 연산 모드 신호가 상기 제1 프리시젼 보다 큰 제2 프리시젼과 연관된 제2 모드 신호인 경우, 상기 제1 멀 티플라이어와 상기 제2 멀티플라이어를 모두 이용하여, 상기 웨이트 및 상기 인풋 액티베이션을 곱셈 연산할 수 있다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 상기 연산 모드 신호가 상기 제2 모드 신호인 경우, 상 기 제1 멀티플라이어에서 생성된 제1 부분곱 그룹과, 상기 제2 멀티플라이어에서 생성된 제2 부분곱 그룹의 자 릿수를 정렬하여, 제1 정렬 부분곱 그룹 및 제2 정렬 부분곱 그룹을 생성하는 얼라이너를 포함할 수 있다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 상기 제1 정렬 부분곱 그룹을 연산하는 제1 부스 리덕션 트리 및 상기 제2 정렬 부분곱 그룹을 연산하는 제2 부스 리덕션 트리를 포함하고, 상기 제1 정렬 부분곱 그룹 의 뎁스(depth)는 상기 제2 정렬 부분곱 그룹의 뎁스보다 클 수 있다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 상기 제1 정렬 부분곱 그룹을 연산하는 제1 부스 리덕션 트리 및 상기 제2 정렬 부분곱 그룹을 연산하는 제2 부스 리덕션 트리를 포함하고, 상기 제1 부스 리덕션 트리 의 연산 가능한 뎁스(depth)는 상기 제2 부스 리덕션 트리의 연산 가능한 뎁스보다 클 수 있다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 상기 제1 정렬 부분곱 그룹을 연산하는 하나의 제1 부스 리덕션 트리 및 상기 제2 정렬 부분곱 그룹을 연산하는 복수의 제2 부스 리덕션 트리를 포함할 수 있다. 몇몇 실시예에 따르면, 상기 웨이트 및 상기 인풋 액티베이션이 각각 32비트 데이터이고, 상기 제1 프리시젼은 INT4이고, 상기 제2 프리시젼은 INT8인 경우, 상기 플렉서블 멀티플라이어는, 상기 제1 정렬 부분곱 그룹을 연 산하는 하나의 제1 부스 리덕션 트리 및 상기 제2 정렬 부분곱 그룹을 연산하는 4개의 제2 부스 리덕션 트리를 포함할 수 있다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 상기 제1 멀티플라이어와 상기 제2 멀티플라이어에서 생 성된 부분곱 그룹을 이용하여, 상기 결과 데이터를 생성하는 부스 리덕션 트리를 포함할 수 있다. 몇몇 실시예에 따르면, 상기 부스 리덕션 트리는, 상기 부분곱 그룹의 뎁스(depth)를 감소시키는 뎁스 리듀서 및 상기 뎁스 리듀서에 의해 뎁스가 감소된 부분곱 그룹에 대한 덧셈 연산을 수행하는 애더를 포함할 수 있다. 몇몇 실시예에 따르면, 상기 제1 멀티플라이어와 상기 제2 멀티플라이어는 각각 k 개일 수 있다. 몇몇 실시예에 따르면, 상기 웨이트 및 상기 인풋 액티베이션이 각각 32비트 데이터이고, 상기 제1 프리시젼은 INT4이고, 제2 프리시젼은 INT8인 경우, 상기 k는 8일 수 있다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 상기 제1 멀티플라이어 및 상기 제2 멀티플라이어에서 생성된 부분곱 그룹을 이용하여, 제1 정렬 부분곱 그룹 및 제2 정렬 부분곱 그룹을 생성하는 얼라이너, 상기 제 1 정렬 부분곱 그룹을 연산하는 제1 부스 리덕션 트리, 상기 제2 정렬 부분곱 그룹을 연산하는 제2 부스 리덕션 트리 및 상기 제2 부스 리덕션 트리의 연산 결과에 대한 덧셈 연산을 수행하는 프리 애더를 포함하고, 상기 제1 부스 리덕션 트리에서의 연산 결과와, 상기 프리 애더에서의 연산 결과는 상기 새츄레이팅 애더에 제공될 수 있 다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 상기 웨이트를 이용하여 상기 제1 프리시젼의 제1 분할 웨이트를 생성하고, 상기 인풋 액티베이션을 이용하여 상기 제1 프리시젼의 제1 분할 인풋 액티베이션을 생성하 는 비트 디비젼 로직을 포함할 수 있다. 몇몇 실시예에 따르면, 상기 연산 모드 신호가 상기 제1 프리시젼과 연관된 제1 모드 신호인 경우, 상기 제1 멀 티플라이어는 상기 제1 분할 웨이트와 상기 제1 분할 인풋 액티베이션을 이용하여 상기 결과 데이터를 생성할 수 있다. 몇몇 실시예에 따르면, 상기 패스 셀렉션 로직은, 상기 연산 모드 신호가 상기 제2 프리시젼과 연관된 제2 모드 신호인 경우, 상기 비트 디비젼 로직은, 상기 제1 분할 웨이트를 이용하여, 제1 상위 분할 웨이트 및 제1 하위 분할 웨이트를 생성하고, 상기 제1 분할 인풋 액티베이션을 이용하여, 제1 상위 분할 인풋 액티베이션 및 제1 하위 분할 인풋 액티베이션을 생성할 수 있다. 몇몇 실시예에 따르면, 상기 제1 하위 분할 웨이트 및 상기 제1 하위 분할 인풋 액티베이션은 각각 양의 값을 가지기 위한 엑스트라 비트를 포함할 수 있다. 상기 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 뉴럴 프로세싱 장치는 적어도 하나의 뉴럴 코어를 포 함하고, 상기 뉴럴 코어는, 연산을 수행하는 프로세싱 유닛과, 상기 프로세싱 유닛의 입출력 데이터를 저장하는 L0 메모리를 포함하고, 상기 프로세싱 유닛은 적어도 하나의 프로세싱 엘리먼트를 포함하는 PE 어레이를 포함하 고, 상기 PE 어레이는, 웨이트 및 인풋 액티베이션을 수신하고, 연산 모드 신호에 따라, 제1 프리시젼의 제1 멀 티플라이어를 이용하거나, 상기 제1 멀티플라이어와 상기 제1 프리시젼의 제2 멀티플라이어를 모두 이용하여 복 수의 부분곱 그룹을 생성하고, 상기 복수의 부분곱 그룹을 이용하여 결과 데이터를 생성하는 플렉서블 멀티플라 이어와, 상기 결과 데이터를 수신하여 부분합을 생성하는 새츄레이팅 애더를 포함한다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 부스 알고리즘을 이용하여, 상기 복수의 부분곱 그룹을 덧셈 연산함으로써 상기 결과 데이터를 생성할 수 있다. 몇몇 실시예에 따르면, 상기 플렉서블 멀티플라이어는, 상기 복수의 부분곱 그룹의 자릿수를 기초로 복수의 정 렬 부분곱 그룹으로 그룹핑하고, 상기 복수의 정렬 부분곱 그룹을 덧셈 연산하여, 상기 결과 데이터를 생성할 수 있다. 상기 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 곱셈 연산 방법은 웨이트, 인풋 액티베이션 및 연산 모드 신호를 수신하는 단계, 상기 웨이트를 이용하여 복수의 분할 웨이트를 생성하는 단계, 상기 인풋 액티베이 션을 이용하여 복수의 분할 인풋 액티베이션을 생성하는 단계, 상기 연산 모드에 따라, 상기 복수의 분할 웨이 트 및 상기 복수의 분할 인풋 액티베이션이 제공될 멀티플라이어를 결정하는 단계, 상기 멀티플라이어에서 생성 된 제1 부분곱 그룹과 제2 부분곱 그룹의 자릿수를 정렬하여, 제1 정렬 부분곱 그룹과 제2 정렬 부분곱 그룹을 생성하는 단계, 상기 제1 정렬 부분곱 그룹과 상기 제2 정렬 부분곱 그룹을 독립적으로 연산하여 결과 데이터를 생성하는 단계를 포함한다."}
{"patent_id": "10-2022-0066221", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명에 따르면, 상대적으로 높은 프리시젼의 연산을 수행할 때, 상대적으로 낮은 프리시젼의 멀티플라이어를 이용할 수 있으므로, 프로세싱 엘리먼트 및 뉴럴 프로세싱 장치의 하드웨어 복잡도를 감소시킬 수 있다. 상술한 내용과 더불어 본 발명의 구체적인 효과는 이하"}
{"patent_id": "10-2022-0066221", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 명세서 및 특허청구범위에서 사용된 용어나 단어는 일반적이거나 사전적인 의미로 한정하여 해석되어서는 아 니된다. 발명자가 그 자신의 발명을 최선의 방법으로 설명하기 위해 용어나 단어의 개념을 정의할 수 있다는 원 칙에 따라, 본 발명의 기술적 사상과 부합하는 의미와 개념으로 해석되어야 한다. 또한, 본 명세서에 기재된 실 시예와 도면에 도시된 구성은 본 발명이 실현되는 하나의 실시예에 불과하고, 본 발명의 기술적 사상을 전부 대 변하는 것이 아니므로, 본 출원시점에 있어서 이들을 대체할 수 있는 다양한 균등물과 변형 및 응용 가능한 예 들이 있을 수 있음을 이해하여야 한다. 본 명세서 및 특허청구범위에서 사용된 제1, 제2, A, B 등의 용어는 다양한 구성요소들을 설명하는데 사용될 수 있지만, 상기 구성요소들은 상기 용어들에 의해 한정되어서는 안 된다. 상기 용어들은 하나의 구성요소를 다른 구성요소로부터 구별하는 목적으로만 사용된다. 예를 들어, 본 발명의 권리 범위를 벗어나지 않으면서 제1 구성 요소는 제2 구성요소로 명명될 수 있고, 유사하게 제2 구성요소도 제1 구성요소로 명명될 수 있다. '및/또는' 이라는 용어는 복수의 관련된 기재된 항목들의 조합 또는 복수의 관련된 기재된 항목들 중의 어느 항목을 포함 한다. 본 명세서 및 특허청구범위에서 사용된 용어는 단지 특정한 실시 예를 설명하기 위해 사용된 것으로, 본 발명을 한정하려는 의도가 아니다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 출원에서 \"포함하다\" 또는 \"가지다\" 등의 용어는 명세서상에 기재된 특징, 숫자, 단계, 동작, 구성요소, 부 품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 본 발명이 속하는 기술 분야에서 통상의 지식을 가진 자에 의해서 일반적으로 이해되는 것과 동일한 의미를 가지고 있다. 일반적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의 미를 가지는 것으로 해석되어야 하며, 본 출원에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적 인 의미로 해석되지 않는다. 또한, 본 발명의 각 실시예에 포함된 각 구성, 과정, 공정 또는 방법 등은 기술적으로 상호 간 모순되지 않는 범위 내에서 공유될 수 있다. 이하, 도 1 내지 도 36을 참조하여, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치를 설명한다. 도 1은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템을 설명하기 위한 블록도이다. 도 1을 참조하면, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템(NPS)은 제1 뉴럴 프로세싱 장치, 제2 뉴럴 프로세싱 장치 및 외부 인터페이스를 포함할 수 있다. 제1 뉴럴 프로세싱 장치는 인공 신경망을 이용하여 연산을 수행하는 장치일 수 있다. 제1 뉴럴 프로세싱 장 치는 예를 들어, 딥 러닝(deep learning) 연산 작업을 수행하는 것에 특화된 장치일 수 있다. 단, 본 실시예 가 이에 제한되는 것은 아니다. 제2 뉴럴 프로세싱 장치는 제1 뉴럴 프로세싱 장치와 동일 내지 유사한 구성을 가지는 장치일 수 있다. 제1 뉴럴 프로세싱 장치 및 제2 뉴럴 프로세싱 장치는 서로 외부 인터페이스를 통해서 연결되어 데이 터 및 제어 신호를 공유할 수 있다. 도 1에서는 2개의 뉴럴 프로세싱 장치를 도시하였지만, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템 (NPS)이 이에 제한되는 것은 아니다. 즉, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템(NPS)은 3개 이 상의 뉴럴 프로세싱 장치가 외부 인터페이스를 통해서 서로 연결될 수도 있다. 또한, 반대로, 본 발명의 몇 몇 실시예들에 따른 뉴럴 프로세싱 시스템(NPS)은 하나의 뉴럴 프로세싱 장치만을 포함할 수도 있다. 도 2는 도 1의 뉴럴 프로세싱 장치를 세부적으로 설명하기 위한 블록도이다. 도 2를 참조하면, 제1 뉴럴 프로세싱 장치는 뉴럴 코어 SoC, CPU, 오프 칩 메모리, 제1 비휘발 성 메모리 인터페이스, 제1 휘발성 메모리 인터페이스, 제2 비휘발성 메모리 인터페이스 및 제2 휘 발성 메모리 인터페이스를 포함할 수 있다. 뉴럴 코어 SoC는 시스템 온 칩(System on Chip) 장치일 수 있다. 뉴럴 코어 SoC는 인공지능 연산 유닛 으로 가속기(Accelerator)일 수 있다. 뉴럴 코어 SoC는 예를 들어, GPU(graphics processing unit), FPGA(field programmable gate array) 및 ASIC(application-specific integrated circuit) 중 어느 하나일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 뉴럴 코어 SoC는 외부 인터페이스를 통해서 다른 외부의 연산 유닛들과 데이터를 교환할 수 있다. 또한, 뉴럴 코어 SoC는 제1 비휘발성 메모리 인터페이스 및 제1 휘발성 메모리 인터페이스를 통해서 각각 비휘발성 메모리 및 휘발성 메모리와 연결될 수 있다. CPU는 제1 뉴럴 프로세싱 장치의 시스템을 통제하고 프로그램의 연산을 실행하는 제어장치일 수 있다. CPU는 범용 연산 유닛으로서 딥러닝에 많이 사용되는 병렬 단순 연산을 수행하기에는 효율이 낮을 수 있다. 따라서, 뉴럴 코어 SoC가 딥러닝 추론 및 학습 작업에 연산을 수행하여 높은 효율을 가질 수 있다. CPU는 외부 인터페이스를 통해서 다른 외부의 연산 유닛들과 데이터를 교환할 수 있다. 또한, CPU는 제2 비휘발성 메모리 인터페이스 및 제2 휘발성 메모리 인터페이스를 통해서 각각 비휘발성 메모리 및 휘발성 메모리와 연결될 수 있다. 오프 칩 메모리는 뉴럴 코어 SoC의 칩 외부에 배치된 메모리일 수 있다. 오프 칩 메모리는 비휘발 성 메모리 및 휘발성 메모리를 포함할 수 있다. 비휘발성 메모리는 전원이 공급되지 않아도 저장된 정보를 계속 유지하는 메모리일 수 있다. 비휘발성 메모 리는 예를 들어, ROM(Read-Only Memory), PROM(Programmable Read-Only Memory), EAROM(Erasable Alterable ROM), EPROM(Erasable Programmable Read-Only Memory), EEPROM(Electrically Erasable Programmable Read-Only Memory)(예를 들어, 낸드 플래시 메모리(NAND Flash memory), 노어 플래시 메모리(NOR Flash memory)), UVEPROM(Ultra-Violet Erasable Programmable Read-Only Memory), FeRAM(Ferroelectric Random Access Memory), MRAM(Magnetoresistive Random Access Memory), PRAM(Phase-change Random Access Memory), SONOS(silicon-oxide-nitride-oxide-silicon), RRAM(Resistive Random Access Memory), NRAM(Nanotube Random Access Memory), 마그네틱 컴퓨터 기억 장치(예를 들면, 하드 디스크, 디스켓 드라이브, 마그네틱 테이프), 광디스크 드라이브 및 3D 크로스포인트 메모리(3D XPoint memory) 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 휘발성 메모리는 비휘발성 메모리와 달리, 저장된 정보를 유지하기 위해서 전력을 지속적으로 필요로 하는 메모리일 수 있다. 휘발성 메모리는 예를 들어, DRAM(Dynamic Random Access Memory), SRAM(StaticRandom Access Memory), SDRAM(Synchronous Dynamic Random Access Memory) 및 DDR SDRAM(Double Data Rate SDRAM) 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 제1 비휘발성 메모리 인터페이스 및 제2 비휘발성 메모리 인터페이스는 각각 예를 들어, PATA(Parallel Advanced Technology Attachment), SCSI(Small Computer System Interface), SAS(Serial Attached SCSI), SATA(Serial Advanced Technology Attachment) 및 PCIe(PCI Express) 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 제1 휘발성 메모리 인터페이스 및 제2 휘발성 메모리 인터페이스는 각각 예를 들어, SDR(Single Data Rate), DDR(Double Data Rate), QDR(Quad Data Rate), 및 XDR(eXtreme Data Rate, Octal Data Rate) 중 적어 도 하나일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 도 3은 도 2의 뉴럴 코어 SoC를 세부적으로 설명하기 위한 블록도이다. 도 2 및 도 3을 참조하면, 뉴럴 코어 SoC는 적어도 하나의 뉴럴 프로세서, 공유 메모리, DMA(Direct Memory Access), 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤러 및 글로벌 인터커넥션을 포함할 수 있다. 뉴럴 프로세서는 연산 작업을 직접 수행하는 연산 유닛일 수 있다. 뉴럴 프로세서가 복수인 경우 연산 작업은 각각의 뉴럴 프로세서로 할당될 수 있다. 각각의 뉴럴 프로세서는 글로벌 인터커넥션 을 통해서 서로 연결될 수 있다. 공유 메모리는 여러 뉴럴 프로세서에 의해서 공유되는 메모리일 수 있다. 공유 메모리는 각 각의 뉴럴 프로세서의 데이터를 저장할 수 있다. 또한, 공유 메모리는 오프 칩 메모리로부터 데이터를 수신하여 일시적으로 저장하고 각각의 뉴럴 프로세서로 전달할 수 있다. 반대로, 공유 메모리 는 뉴럴 프로세서로부터 데이터를 수신하여 일시적으로 저장하고 도 2의 오프 칩 메모리로 전 달할 수도 있다. 공유 메모리는 상대적으로 속도가 빠른 메모리가 필요할 수 있다. 이에 따라서, 공유 메모리는 예 를 들어, SRAM을 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 즉, 공유 메모리는 DRAM 을 포함할 수도 있다. 공유 메모리는 SoC 레벨 즉, L3(level 3)에 해당하는 메모리일 수 있다. 따라서, 공유 메모리는 L3 공유 메모리라 정의할 수도 있다. DMA는 뉴럴 프로세서가 데이터의 입출력을 제어할 필요없이 직접 데이터의 이동을 제어할 수 있다. 이에 따라서, DMA가 메모리 사이의 데이터 이동을 제어하여 뉴럴 프로세서의 인터럽트의 횟수를 최 소화시킬 수 있다. DMA는 공유 메모리와 오프 칩 메모리 사이의 데이터 이동을 제어할 수 있다. DMA의 권한 을 통해서 비휘발성 메모리 컨트롤러 및 휘발성 메모리 컨트롤러가 데이터를 이동을 수행할 수 있 다. 비휘발성 메모리 컨트롤러는 비휘발성 메모리에 리드(read) 또는 라이트(Write) 작업을 제어할 수 있 다. 비휘발성 메모리 컨트롤러는 제1 비휘발성 메모리 인터페이스를 통해서 비휘발성 메모리를 제어할 수 있다. 휘발성 메모리 컨트롤러는 휘발성 메모리에 리드 또는 라이트 작업을 제어할 수 있다. 또한, 휘발성 메모리 컨트롤러는 휘발성 메모리의 리프레쉬 작업을 수행할 수 있다. 휘발성 메모리 컨트롤러(500 0)는 제1 휘발성 메모리 인터페이스를 통해서 비휘발성 메모리를 제어할 수 있다. 글로벌 인터커넥션은 적어도 하나의 뉴럴 프로세서, 공유 메모리, DMA, 비휘발성 메모 리 컨트롤러 및 휘발성 메모리 컨트롤러를 서로 연결할 수 있다. 또한, 외부 인터페이스도 글로 벌 인터커넥션에 연결될 수 있다. 글로벌 인터커넥션은 적어도 하나의 뉴럴 프로세서, 공유 메모리, DMA, 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤러 및 외부 인터페이스 사이의 데이터가 이동하는 경로일 수 있다. 글로벌 인터커넥션은 데이터뿐만 아니라 제어 신호의 전송 및 동기화를 위한 신호를 전송할 수 있다. 즉, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 별도의 제어 프로세서가 동기화의 신호를 관리하는 것이아니라 각각의 뉴럴 프로세서가 직접 동기화 신호를 전송하고 수신할 수 있다. 이에 따라서, 제어 프로세 서에 의해서 발생하는 동기화 신호의 레이턴시를 차단할 수 있다. 즉, 뉴럴 프로세서가 복수일 때, 어느 뉴럴 프로세서의 작업이 종료되어야 다음 뉴럴 프로세서 가 새로운 작업을 시작할 수 있는 개별 작업의 디펜던시가 존재할 수 있다. 이러한 개별 작업의 종료와 시작은 동기화 신호를 통해서 확인할 수 있는데, 기존의 기술은 이러한 동기화 신호의 수신과 새로운 작업의 시 작 지시를 제어 프로세서가 수행하였다. 그러나, 뉴럴 프로세서의 숫자가 늘어나고, 작업의 디펜던시가 복잡하게 설계되면 될수록 이러한 동기화 작업은 요청 및 지시의 수는 기하급수적으로 늘어나게 되었다. 따라서, 각각의 요청 및 지시에 따른 레이턴시가 작업의 효율을 크게 낮출 수 있다. 따라서, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 제어 프로세서 대신 각각의 뉴럴 프로세서 가 직접 동기화 신호를 작업의 디펜던시에 따라 다른 뉴럴 프로세서로 전송할 수 있다. 이 경우 제 어 프로세서에 의해서 관리되는 방식에 비해서 병렬적으로 여러 뉴럴 프로세서가 동기화 작업을 수행할 수 있어 동기화에 따른 레이턴시를 최소화할 수 있다. 또한, 제어 프로세서가 작업 디펜던시에 따른 뉴럴 프로세서들의 작업 스케쥴링을 수행해야 하는데 이러 한 스케쥴링의 오버헤드도 뉴럴 프로세서의 개수가 늘어나면 늘어날수록 크게 늘어날 수 있다. 따라서, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 스케쥴링 작업도 개별 뉴럴 프로세서에 의해서 진 행되어 그에 따른 스케쥴링 부담도 없어 장치의 성능이 향상될 수 있다. 도 4는 도 3의 글로벌 인터커넥션을 세부적으로 설명하기 위한 구조도이다. 도 4를 참조하면, 글로벌 인터커넥션은 데이터 채널, 컨트롤 채널 및 L3 싱크 채널을 포함할 수 있다. 데이터 채널은 데이터를 전송하는 전용 채널일 수 있다. 데이터 채널을 통해서 적어도 하나의 뉴럴 프로세서, 공유 메모리, DMA, 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤러 및 외부 인터페이스가 서로 데이터를 교환할 수 있다. 컨트롤 채널은 제어 신호를 전송하는 전용 채널일 수 있다. 컨트롤 채널을 통해서 적어도 하나의 뉴럴 프로세서, 공유 메모리, DMA, 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤 러 및 외부 인터페이스가 서로 제어 신호를 교환할 수 있다. L3 싱크 채널은 동기화 신호를 전송하는 전용 채널일 수 있다. L3 싱크 채널을 통해서 적어도 하나 의 뉴럴 프로세서, 공유 메모리, DMA, 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트 롤러 및 외부 인터페이스가 서로 동기화 신호를 교환할 수 있다. L3 싱크 채널은 글로벌 인터커넥션 내부에 전용 채널로 설정되어 다른 채널과 겹치지 않고 동기화 신호를 빠르게 전송할 수 있다. 이에 따라서, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 새로운 와 이어링 작업이 필요하지 않고 기존에 사용되는 글로벌 인터커넥션을 이용하여 동기화 작업을 원활하게 진 행할 수 있다. 도 5는 도 3의 뉴럴 프로세서를 세부적으로 설명하기 위한 블록도이다. 도 3 내지 도 5를 참조하면, 뉴럴 프로세서는 적어도 하나의 뉴럴 코어, L2 공유 메모리, 로컬 인터커넥션 및 L2 싱크 패스를 포함할 수 있다. 적어도 하나의 뉴럴 코어는 뉴럴 프로세서의 작업을 분담하여 수행할 수 있다. 뉴럴 코어는 예 를 들어, 8개일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 도 3 및 도 5에서는 여러 개의 뉴럴 코 어가 뉴럴 프로세서에 포함되는 것으로 도시하였지만, 본 실시예가 이에 제한되는 것은 아니다. 즉, 뉴럴 코어 1개만으로 뉴럴 프로세서가 구성될 수 있다. L2 공유 메모리는 뉴럴 프로세서 내에서 각각의 뉴럴 코어들이 공유하는 메모리일 수 있다. L2 공유 메모리는 각각의 뉴럴 코어의 데이터를 저장할 수 있다. 또한, L2 공유 메모리는 도 4의 공유 메모리로부터 데이터를 수신하여 일시적으로 저장하고 각각의 뉴럴 코어로 전달할 수 있다. 반 대로, L2 공유 메모리는 뉴럴 코어로부터 데이터를 수신하여 일시적으로 저장하고 도 3의 공유 메모 리로 전달할 수도 있다. L2 공유 메모리는 뉴럴 프로세서 레벨, 즉, L2(level 2)에 해당하는 메모리일 수 있다. L3 공유 메모리 즉, 공유 메모리는 뉴럴 프로세서에 의해서 공유되고, L2 공유 메모리는 뉴럴 코어에 의 해서 공유될 수 있다. 로컬 인터커넥션은 적어도 하나의 뉴럴 코어 및 L2 공유 메모리를 서로 연결할 수 있다. 로컬 인터커넥션은 적어도 하나의 뉴럴 코어 및 L2 공유 메모리 사이의 데이터가 이동하는 경로일 수 있다. 로컬 인터커넥션은 도 3의 글로벌 인터커넥션과 연결되어 데이터를 전송할 수 있다. L2 싱크 패스는 적어도 하나의 뉴럴 코어 및 L2 공유 메모리를 서로 연결할 수 있다. L2 싱크 패스는 적어도 하나의 뉴럴 코어 및 L2 공유 메모리의 동기화 신호가 이동하는 경로일 수 있다. L2 싱크 패스는 로컬 인터커넥션과 물리적으로 별도로 형성될 수 있다. 로컬 인터커넥션의 경우 글로벌 인터커넥션과 달리 내부에 충분한 채널이 형성되지 않을 수 있다. 이러한 경우에는 L2 싱크 패스 가 별도의 형성되어 동기화 신호의 전송을 빠르고 지체없이 수행할 수 있다. L2 싱크 패스는 글로벌 인터커넥션의 L3 싱크 채널에 비해서 한단계 낮은 레벨에서 수행되는 동기화에 사용될 수 있다. 도 6은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 계층적 구조를 설명하기 위한 도면이다. 도 6을 참조하면, 뉴럴 코어 SoC는 적어도 하나의 뉴럴 프로세서를 포함할 수 있다. 각각의 뉴럴 프 로세서는 글로벌 인터커넥션을 통해서 서로 데이터를 전송할 수 있다. 뉴럴 프로세서는 각각 적어도 하나의 뉴럴 코어를 포함할 수 있다. 뉴럴 코어는 딥러닝 연산 작업에 최적화된 프로세싱 단위 유닛일 수 있다. 뉴럴 코어는 딥러닝 연산 작업의 하나의 오퍼레이션에 대 응하는 프로세싱 단위 유닛일 수 있다. 즉, 딥러닝 연산 작업은 여러 오퍼레이션의 순차적 또는 병렬적 결합으 로 표현 가능할 수 있다. 뉴럴 코어는 각각 하나의 오퍼레이션을 처리할 수 있는 프로세싱 단위 유닛으로 서 컴파일러 입장에서 스케쥴링에 고려할 수 있는 최소한의 연산 단위일 수 있다. 본 실시예에 따른 뉴럴 프로세싱 장치는 컴파일러 스케쥴링 입장에서 고려되는 최소한의 연산 단위와 하드웨어 프로세싱 단위 유닛의 스케일을 동일하게 구성하여 빠르고 효율적인 스케쥴링 및 연산 작업의 수행을 도모할 수 있다. 즉, 연산 작업에 비해서 하드웨어의 분할할 수 있는 프로세싱 단위 유닛이 지나치게 크다면 프로세싱 단위 유닛 의 구동에서 연산 작업의 비효율이 발생할 수 있다. 반대로, 컴파일러의 스케쥴링 최소 단위인 오퍼레이션보다 더 작은 단위의 프로세싱 유닛을 매번 스케쥴링하는 것은 스케쥴링의 비효율이 발생할 수 있고, 하드웨어 설계 비용이 높아질 수 있어 적절하지 않다. 따라서, 본 실시예는 컴파일러의 스케쥴링 단위와 하드웨어 프로세싱 단위의 스케일을 유사하게 조율하여 빠른 연산 작업의 스케쥴링과 하드웨어 리소스의 낭비없이 효율적인 연산 작업 수행을 동시에 충족시킬 수 있다. 도 7은 도 5의 뉴럴 코어를 세부적으로 설명하기 위한 블록도이다. 도 7을 참조하면, 뉴럴 코어는 LSU(Load/Store Unit), L0 메모리, 웨이트 버퍼, 액티베이 션 LSU, 액티베이션 버퍼 및 프로세싱 유닛을 포함할 수 있다. LSU는 로컬 인터커넥션 및 L2 싱크 패스를 통해서 외부에서 데이터, 제어 신호 및 동기화 신호 중 적어도 하나를 수신할 수 있다. LSU는 L0 메모리로 수신한 데이터, 제어 신호 및 동기화 신호 중 적어도 하나를 전송할 수 있다. 유사하게 LSU는 로컬 인터커넥션 및 L2 싱크 패스를 통해서 데 이터, 제어 신호 및 동기화 신호 중 적어도 하나를 외부로 전달 수 있다. 도 8는 도 7의 LSU을 세부적으로 설명하기 위한 블록도이다. 도 8을 참조하면, LSU는 로컬 메모리 로드 유닛(111a), 로컬 메모리 스토어 유닛(111b), 뉴럴 코어 로드 유닛(112a), 뉴럴 코어 스토어 유닛(112b), 로드 버퍼(LB), 스토어 버퍼(SB), 로드 엔진(113a), 스토어 엔진 (113b) 및 변환 색인 버퍼를 포함할 수 있다. 로컬 메모리 로드 유닛(111a)은 L0 메모리에 대한 로드 인스트럭션을 페치(fetch)하고, 로드 인스트럭션을 이슈(issue)할 수 있다. 로컬 메모리 로드 유닛(111a)이 이슈된 로드 인스트럭션을 로드 버퍼(LB)에 제공하면 로드 버퍼(LB)가 입력된 순서에 따라서 순차적으로 로드 엔진(113a)으로 메모리 액세스 요청을 전송할 수 있다. 또한, 로컬 메모리 스토어 유닛(111b)은 L0 메모리에 대한 스토어 인스트럭션을 페치하고, 스토어 인스트 럭션을 이슈할 수 있다. 로컬 메모리 스토어 유닛(111b)이 이슈된 스토어 인스트럭션을 스토어 버퍼(SB)에 제공 하면 스토어 버퍼(SB)가 입력된 순서에 따라서 순차적으로 스토어 엔진(113b)으로 메모리 액세스 요청을 전송할 수 있다. 뉴럴 코어 로드 유닛(112a)은 뉴럴 코어에 대한 로드 인스트럭션을 페치하고, 로드 인스트럭션을 이슈할 수 있다. 뉴럴 코어 로드 유닛(112a)이 이슈된 로드 인스트럭션을 로드 버퍼(LB)에 제공하면 로드 버퍼(LB)가 입력된 순서에 따라서 순차적으로 로드 엔진(113a)으로 메모리 액세스 요청을 전송할 수 있다. 또한, 뉴럴 코어 스토어 유닛(112b)은 뉴럴 코어에 대한 스토어 인스트럭션을 페치하고, 스토어 인스트럭 션을 이슈할 수 있다. 뉴럴 코어 스토어 유닛(112b)이 이슈된 스토어 인스트럭션을 스토어 버퍼(SB)에 제공하면 스토어 버퍼(SB)가 입력된 순서에 따라서 순차적으로 스토어 엔진(113b)으로 메모리 액세스 요청을 전송할 수 있다. 로드 엔진(113a)은 메모리 액세스 요청을 수신하여 로컬 인터커넥션을 통해서 데이터를 불러올 수 있다. 이때, 로드 엔진(113a)은 변환 색인 버퍼에서 최근에 사용된 가상 주소와 물리 주소의 변환 테이블을 이용 하여 빠르게 데이터를 찾을 수 있다. 로드 엔진(113a)의 가상 주소가 변환 색인 버퍼에 없는 경우에는 다 른 메모리에서 주소 변환 정보를 찾을 수 있다. 스토어 엔진(113b)은 메모리 액세스 요청을 수신하여 로컬 인터커넥션을 통해서 데이터를 불러올 수 있다. 이때, 스토어 엔진(113b)은 변환 색인 버퍼에서 최근에 사용된 가상 주소와 물리 주소의 변환 테이블을 이 용하여 빠르게 데이터를 찾을 수 있다. 스토어 엔진(113b)의 가상 주소가 변환 색인 버퍼에 없는 경우에는 다른 메모리에서 주소 변환 정보를 찾을 수 있다. 로드 엔진(113a) 및 스토어 엔진(113b)은 L2 싱크 패스로 동기화 신호를 보낼 수 있다. 이때, 동기화 신호 는 작업이 종료되었다는 의미를 가질 수 있다. 다시, 도 7을 참조하면, L0 메모리는 뉴럴 코어 내부에 위치한 메모리로서, 뉴럴 코어가 작업에 필요한 모든 입력 데이터를 외부로부터 수신하여 임시로 저장할 수 있다. 또한, L0 메모리는 뉴럴 코어 에 의해서 연산된 출력 데이터를 외부로 전송하기 위해서 일시적으로 저장할 수 있다. L0 메모리는 뉴럴 코어의 캐시 메모리 역할을 수행할 수 있다. L0 메모리는 액티베이션 LSU에 의해서 인풋 액티베이션(Act_In)을 액티베이션 버퍼로 전송하고, 아웃풋 액티베이션(Act_Out)을 수신할 수 있다. L0 메모리는 액티베이션 LSU 외에도, 프로세싱 유닛 과 직접 데이터를 송수신할 수 있다. 즉, L0 메모리는 PE 어레이 및 벡터 유닛 각각과 데 이터를 주고받을 수 있다. L0 메모리는 뉴럴 코어 레벨 즉, L1(level 1)에 해당하는 메모리일 수 있다. 따라서, L0 메모리는 L1 메모리라 정의할 수도 있다. 단, L1 메모리는 L2 공유 메모리 및 L3 공유 메모리, 즉 공유 메모리와 는 달리 공유되지 않고 뉴럴 코어의 전용(private) 메모리일 수 있다. L0 메모리는 데이터 패스(Data Path)를 통해 액티베이션이나 웨이트 같은 데이터를 전송할 수 있다. L0 메 모리는 별도의 전용 패스인 L1 싱크 패스(L1 Sync Path)를 통해서 동기화 신호를 주고받을 수 있다. L0 메 모리는 예를 들어, LSU, 웨이트 버퍼, 액티베이션 LSU 및 프로세싱 유닛과 L1 싱크 패스(L1 Sync Path)를 통해서 동기화 신호를 주고받을 수 있다. 웨이트 버퍼는 웨이트(Weight)를 L0 메모리로부터 수신할 수 있다. 웨이트 버퍼는 웨이트 (Weight)를 프로세싱 유닛으로 전달할 수 있다. 웨이트 버퍼는 웨이트(Weight)를 전달하기 전에 일시 적으로 웨이트(Weight)를 저장할 수 있다. 인풋 액티베이션(Act_In) 및 아웃풋 액티베이션(Act_Out)은 신경망 네트워크의 레이어의 입력값과 출력값을 의 미할 수 있다. 이때, 신경망 네트워크의 레이어가 복수인 경우 이전 레이어의 출력값이 다음 레이어의 입력값이 되므로 이전 레이어의 아웃풋 액티베이션(Act_Out)이 다음 레이어의 인풋 액티베이션(Act_In)으로 활용될 수 있 다. 웨이트(Weight)는 각 레이어에서 입력되는 입력 액티베이션(Act_In)과 곱해지는 파라미터를 의미할 수 있다. 웨 이트(Weight)는 딥 러닝 학습 단계에서 조절되어 확정되고, 추론 단계에서는 고정된 값을 통해서 아웃풋 액티베 이션(Act_Out)을 도출하기 위해서 사용될 수 있다.액티베이션 LSU은 L0 메모리로부터 인풋 액티베이션(Act_In)을 액티베이션 버퍼로 전달하고, 액 티베이션 버퍼로부터 아웃풋 액티베이션(Act_Out)을 L0 메모리로 전달할 수 있다. 즉, 액티베이션 LSU은 액티베이션의 로드 작업과 스토어 작업을 모두 수행할 수 있다. 액티베이션 버퍼는 프로세싱 유닛으로 인풋 액티베이션(Act_In)을 제공하고, 프로세싱 유닛으로 부터 아웃풋 액티베이션(Act_Out)을 수신할 수 있다. 액티베이션 버퍼는 인풋 액티베이션(Act_In)과 아웃 풋 액티베이션(Act_Out)을 일시적으로 저장할 수 있다. 액티베이션 버퍼는 연산량이 많은 프로세싱 유닛, 특히, PE 어레이에 빠르게 액티베이션을 제공 하고, 빠르게 액티베이션을 수신하여 뉴럴 코어의 연산 속도를 높일 수 있다. 프로세싱 유닛은 연산을 수행하는 모듈일 수 있다. 프로세싱 유닛은 1차원 연산뿐만 아니라 2차원 매 트릭스 연산 즉, 컨볼루션 연산을 수행할 수 있다. 프로세싱 유닛은 인풋 액티베이션(Act_In)을 수신하여 웨이트와 곱한 뒤 이를 더하여 아웃풋 액티베이션(Act_Out)을 생성할 수 있다. 도 9는 도 7의 프로세싱 유닛을 세부적으로 설명하기 위한 블록도이다. 도 7 및 도 9를 참조하면, 프로세싱 유닛은 PE 어레이, 벡터 유닛, 컬럼 레지스터 및 로우 레지스터를 포함할 수 있다. PE 어레이는 인풋 액티베이션(Act_In) 및 웨이트(Weight)를 수신하여 곱셈을 수행할 수 있다. 이때, 인풋 액티베이션(Act_In)과 웨이트(Weight)는 각각 매트릭스 형태로 컨볼루션을 통해서 연산될 수 있다. 이를 통해서, PE 어레이는 아웃풋 액티베이션(Act_Out)을 생성할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. PE 어레이는 아웃풋 액티베이션(Act_Out)외의 다른 종류의 출력도 얼마든지 생성할 수 있다. PE 어레이는 적어도 하나의 프로세싱 엘리먼트(163_1)를 포함할 수 있다. 프로세싱 엘리먼트(163_1)는 서 로 정렬되어 각각 하나의 인풋 액티베이션(Act_In)과 하나의 웨이트(Weight)에 대한 곱셈을 수행할 수 있다. PE 어레이는 각각의 곱셈에 대한 값을 합한 부분합을 생성할 수 있다. 이러한 부분합은 아웃풋 액티베이션 (Act_Out)으로 활용될 수 있다. PE 어레이는 이차원 매트릭스 곱셈을 수행하므로 이차원 매트릭스 연산 유 닛(2D matrix compute unit)으로 지칭될 수도 있다. 벡터 유닛은 1차원 연산을 수행할 수 있다. 벡터 유닛은 PE 어레이와 함께 딥러닝 연산을 수행 할 수 있다. 이를 통해서 프로세싱 유닛은 필요한 연산에 특화될 수 있다. 즉, 뉴럴 코어는 대량의 2 차원 매트릭스 곱셈과 1차원 연산을 수행하는 연산 모듈이 각각 있어 효율적으로 딥러닝 작업을 수행할 수 있다. 컬럼 레지스터는 제1 입력(I1)을 수신할 수 있다. 컬럼 레지스터는 제1 입력(I1)을 수신하고 이를 분 할하여 프로세싱 엘리먼트(163_1)의 각 열(column)에 제공할 수 있다. 로우 레지스터는 제2 입력(I2)을 수신할 수 있다. 로우 레지스터는 제2 입력(I2)을 수신하고 이를 분 할하여 프로세싱 엘리먼트(163_1)의 각 행(row)에 제공할 수 있다. 제1 입력(I1)은 인풋 액티베이션(Act_In) 또는 웨이트(Weight)일 수 있다. 제2 입력(I2)은 인풋 액티베이션 (Act_In) 또는 웨이트(Weight) 중 제1 입력(I1)이 아닌 값일 수 있다. 또는, 제1 입력(I1) 및 제2 입력(I2)은 인풋 액티베이션(Act_In) 및 웨이트(Weight) 외의 값이 될 수도 있다. 도 10은 도 9의 프로세싱 엘리먼트를 세부적으로 설명하기 위한 블록도이다. 도 10을 참조하면, 프로세싱 엘리먼트(163_1)는 웨이트 레지스터(WR), 인풋 액티베이션 레지스터(ACR), 플렉서 블 멀티플라이어(FM) 및 새츄레이팅 애더(SA)를 포함할 수 있다. 웨이트 레지스터(WR)는 프로세싱 엘리먼트(163_1)에 입력되는 웨이트(Weight)를 수신하여 저장할 수 있다. 웨이 트 레지스터(WR)는 웨이트(Weight)를 플렉서블 멀티플라이어(FM)로 전송할 수 있다. 인풋 액티베이션 레지스터(ACR)는 인풋 액티베이션(Act_In)을 수신하여 저장할 수 있다. 인풋 액티베이션 레지 스터(ACR)는 인풋 액티베이션(Act_In)을 플렉서블 멀티플라이어(FM)로 전송할 수 있다. 플렉서블 멀티플라이어(FM)는 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 수신할 수 있다. 플렉서블 멀티플 라이어(FM)는 웨이트(Weight)와 인풋 액티베이션(Act_In)의 곱셈을 수행할 수 있다. 플렉서블 멀티플라이어(FM)는 모드 신호(Mode)를 수신할 수 있다. 이때, 모드 신호(Mode)는 제1 프리시젼(Precision)과 제2 프리시젼 중 어느 프리시젼을 사용하여 연산을 할지에 대한 신호일 수 있다. 플렉서블 멀티플라이어(FM)는 곱셈 결과를 결과 데이터로 출력할 수 있다. 결과 데이터는 사인 비트(SB) 및 프 로덕트 비트(PB)를 포함할 수 있다. 이때, 사인 비트(SB)는 결과 데이터의 부호를 나타내는 비트일 수 있다. 프 로덕트 비트(PB)는 결과 데이터의 크기를 나타내는 비트일 수 있다. 플렉서블 멀티플라이어(FM)는 제1 프리시젼 또는 제2 프리시젼으로 결과 데이터를 출력할 수 있다. 새츄레이팅 애더(SA)는 결과 데이터를 수신할 수 있다. 새츄레이팅 애더(SA)는 즉, 사인 비트(SB) 및 프로덕트 비트(PB)를 수신할 수 있다. 새츄레이팅 애더(SA)는 결과 데이터를 여러 차례 수신하여 누산할 수 있다. 이에 따라서, 새츄레이팅 애더(SA)는 부분합(Psum)을 생성할 수 있다. 이러한 부분합(Psum)은 각각의 프로세싱 엘리 먼트(163_1)에서 출력되어 최종적으로 합산될 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 도 11은 도 10의 플렉서블 멀티플라이어를 세부적으로 설명하기 위한 블록도이다. 도 11을 참조하면, 플렉서블 멀티플라이어(FM)는 패스 결정 유닛(PDU), 디멀티플렉서(Dx), 제1 멀티플라이어 (Mul1), 제2 멀티플라이어(Mul2), 얼라이너(ALNR), 제1 부스 리덕션 트리(BRT1) 및 제2 부스 리덕션 트리 (BRT2)를 포함할 수 있다. 패스 결정 유닛(PDU)은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 수신할 수 있다. 다시 말해서, 패스 결정 유닛(PDU)은 웨이트 레지스터(WR)로부터 웨이트(Weight)를 제공받고, 인풋 액티베이션 레지스터(ACR)로부터 인 풋 액티베이션(Act_In)을 제공받을 수 있다. 또한, 패스 결정 유닛(PDU)은 연산 모드 신호(Mode)를 제공받을 수 있다. 연산 모드 신호(Mode)는 패스 결정 유 닛(PDU)에 제공된 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 연산하기 위한 프리시젼과 관련된 신호일 수 있다. 예를 들어, 연산 모드 신호(Mode)는 제1 프리시젼(Pr1)과 연관된 제1 모드 신호와 제2 프리시젼(Pr2)과 연관된 제2 모드 신호를 포함할 수 있다. 패스 결정 유닛(PDU)은 비트 디비젼 로직(BDL) 및 패스 셀렉션 로직(PSL)을 포함할 수 있다. 비트 디비젼 로직 (BDL)은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 분할하여, 분할 웨이트(D_W) 및 분할 인풋 액티베이션 (D_A)을 생성할 수 있다. 다시 말해서, 비트 디비젼 로직(BDL)은 웨이트(Weight)를 제1 프리시젼(Pr1) 단위로 분할하여, 복수의 분할 웨이트(D_W)를 생성할 수 있다. 또한, 비트 디비젼 로직(BDL)은 인풋 액티베이션 (Act_In)을 제1 프리시젼(Pr1) 단위로 분할하여, 복수의 분할 인풋 액티베이션(D_A)을 생성할 수 있다. 예를 들 어, 웨이트(Weight) 및 인풋 액티베이션(Act_In)이 각각 32-비트 데이터이고, 제1 프리시젼(Pr1)이 INT4(4-비트 정수, 4-bit integer)인 경우, 비트 디비젼 로직(BDL)은 웨이트(Weight)를 8개의 4-비트 단위의 분할 웨이트 (D_W)로 분할하고, 인풋 액티베이션(Act_In)을 8개의 4-비트 단위의 분할 웨이트(D_W)로 분할할 수 있다. 몇몇 실시예에 따르면, 비트 디비젼 로직(BDL)은 연산 모드 신호(Mode)에 따라 제1 프리시젼(Pr1) 단위로 분할 된 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)의 적어도 일부에 대해, 부호 고정을 위한 엑스트라 비트를 추가할 수 있다. 몇몇 실시예에 따르면, 연산 모드 신호(Mode)가 제2 모드 신호라는 것은, 제2 프리시젼(Pr2) 단위의 웨이트 (Weight)와 제2 프리시젼(Pr2) 단위의 인풋 액티베이션(Act_In)의 연산이 필요한 경우를 의미할 수 있다. 다만, 연산 모드 신호(Mode)가 제2 모드 신호인 경우에도, 비트 디비젼 로직(BDL)은 웨이트(Weight) 및 인풋 액티베이 션(Act_In)을 각각 제1 프리시젼(Pr1) 단위로 분할하여, 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 생 성할 수 있다. 이때, 분할 웨이트(D_W)는 상위 분할 웨이트(D_W) 또는 하위 분할 웨이트(D_W)를 의미할 수 있다. 또한, 분할 인풋 액티베이션(D_A)은 상위 분할 인풋 액티베이션(D_A) 또는 하위 분할 인풋 액티베이션 (D_A)을 의미할 수 있다. 이때, 상위 분할 웨이트(D_W)는 연산이 필요한 제2 프리시젼(Pr2) 단위의 웨이트 (Weight) 중 상위 비트를, 하위 분할 웨이트(D_W)는 연산이 필요한 제2 프리시젼(Pr2) 단위의 웨이트(Weight) 중 하위 비트를 의미할 수 있다. 또한, 상위 분할 인풋 액티베이션(D_A)은 연산이 필요한 제2 프리시젼(Pr2) 단 위의 인풋 액티베이션(Act_In) 중 상위 비트를, 하위 분할 인풋 액티베이션(D_A)은 연산이 필요한 제2 프리시젼 (Pr2) 단위의 인풋 액티베이션(Act_In) 중 하위 비트를 의미할 수 있다. 연산 모드 신호(Mode)가 제2 모드 신호인 경우, 실제 연산이 수행되어야 할 웨이트(Weight) 및 인풋 액티베이션 (Act_In)은 각각 제2 프리시젼(Pr2) 단위여야 하지만, 본 발명의 몇몇 실시예에 따른 비트 디비젼 로직(BDL)은 제2 프리시젼(Pr2) 단위의 웨이트(Weight)를 제1 프리시젼(Pr1) 단위의 상위 분할 웨이트(D_W)와, 제1 프리시젼 (Pr1) 단위의 하위 분할 웨이트(D_W)로 분할하여 연산할 수 있다. 마찬가지로, 비트 디비젼 로직(BDL)은 제2 프리시젼(Pr2) 단위의 인풋 액티베이션(Act_In)을 제1 프리시젼(Pr1) 단위의 상위 분할 인풋 액티베이션(D_A)과, 제1 프리시젼(Pr1) 단위의 하위 분할 인풋 액티베이션(D_A)으로 분할하여 연산할 수 있다. 다시 말해서, 플렉서블 멀티플라이어(FM)는 상위 분할 웨이트(D_W), 하위 분할 웨이트(D_W), 상위 분할 인풋 액 티베이션(D_A) 및 하위 분할 인풋 액티베이션(D_A)을 이용하여, 제2 프리시젼(Pr2) 단위의 웨이트(Weight) 및 인풋 액티베이션(Act_In)의 연산 결과 데이터와 동일한 결과 데이터를 생성할 수 있다. 즉, 플렉서블 멀티플라 이어(FM)는 제2 프리시젼(Pr2) 단위의 웨이트(Weight) 및 제2 프리시젼(Pr2) 단위의 인풋 액티베이션(Act_In)의 연산을, 제1 프리시젼(Pr1) 단위의 상위 분할 웨이트(D_W), 하위 분할 웨이트(D_W), 상위 분할 인풋 액티베이션 (D_A) 및 하위 분할 인풋 액티베이션(D_A)의 연산으로 대체할 수 있다. 이때, 하위 분할 웨이트(D_W) 및 하위 분할 인풋 액티베이션(D_A)은 연산이 수행되어야 할 제2 프리시젼(Pr2) 단위의 웨이트(Weight) 및 인풋 액티베 이션(Act_In)의 하위 비트를 의미한다. 즉, 하위 분할 웨이트(D_W) 및 하위 분할 인풋 액티베이션(D_A)은 음수 값을 가질 수 없다. 그러므로, 하위 분할 웨이트(D_W) 및 하위 분할 인풋 액티베이션(D_A)에 대한 부호를 양수 로 고정할 필요가 있으므로, 비트 디비젼 로직(BDL)은 하위 분할 웨이트(D_W) 및 하위 분할 인풋 액티베이션 (D_A)에 엑스트라 비트를 추가할 수 있다. 예를 들어, 제1 프리시젼(Pr1)이 INT4이고, 제2 프리시젼(Pr2)이 INT8(8-비트 정수, 8-bit integer)이고, 연산 모드 신호(Mode)는 제2 모드 신호(Mode(Pr2))인 경우를 가정한다. 제2 모드 신호(Mode(Pr2))에 따라, 8-비트의 웨이트(Weight)와 8-비트의 인풋 액티베이션(Act_In)의 연산을 수행하기 위해, 비트 디비젼 로직(BDL)은 4-비트 의 상위 분할 웨이트(D_W)와 5-비트의 하위 분할 웨이트(D_W)를 생성할 수 있다. 이때, 4-비트의 상위 분할 웨 이트(D_W)는 8-비트의 웨이트(Weight) 중 상위 4개의 비트를 포함할 수 있고, 5-비트의 하위 분할 웨이트(D_W) 는 8-비트의 웨이트(Weight) 중 하위 4개의 비트를 포함할 수 있다. 이때, 5-비트의 하위 분할 웨이트(D_W)의 최상위 비트는 엑스트라 비트로 구성될 수 있으며, 양수를 의미하는 '0'이 될 수 있다. 마찬가지로, 비트 디비 젼 로직(BDL)은 4-비트의 상위 분할 인풋 액티베이션(D_A)과 5-비트의 하위 분할 인풋 액티베이션(D_A)을 생성 할 수 있다. 이때, 4-비트의 상위 분할 인풋 액티베이션(D_A)은 8-비트의 인풋 액티베이션(Act_In) 중 상위 4개 의 비트를 포함할 수 있고, 5-비트의 하위 분할 인풋 액티베이션(D_A)은 8-비트의 인풋 액티베이션(Act_In) 중 하위 4개의 비트를 포함할 수 있다. 이때, 5-비트의 하위 분할 인풋 액티베이션(D_A)의 최상위 비트는 엑스트라 비트로 구성될 수 있으며, 양수를 의미하는 '0'이 될 수 있다. 플렉서블 멀티플라이어(FM)는 4-비트의 상위 분 할 웨이트(D_W), 5-비트의 하위 분할 웨이트(D_W), 4-비트의 상위 분할 인풋 액티베이션(D_A) 및 5-비트의 하위 분할 인풋 액티베이션(D_A)을 이용하여, 8-비트의 웨이트(Weight) 및 8-비트의 인풋 액티베이션(Act_In)의 연산 과 동일한 결과 데이터를 생성할 수 있다. 패스 셀렉션 로직(PSL)은 연산 모드 신호(Mode)를 기초로 패스 결정 신호(PD)를 생성할 수 있다. 패스 셀렉션 로직(PSL)은 생성된 패스 결정 신호(PD)를 디멀티플렉서(Dx)에 제공할 수 있다. 패스 결정 신호(PD)는 분할 웨 이트(D_W) 및 분할 인풋 액티베이션(D_A)이 제공될 멀티플라이어를 결정하는 신호일 수 있다. 몇몇 실시예에 따 르면, 패스 셀렉션 로직(PSL)은 연산 모드 신호(Mode)가 제1 모드 신호인 경우, 패스 결정 신호(PD)로 제1 패스 결정 신호를 생성할 수 있다. 또한, 패스 셀렉션 로직(PSL)은 연산 모드 신호(Mode)가 제2 모드 신호인 경우, 패스 결정 신호(PD)로 제2 패스 결정 신호를 생성할 수 있다. 디멀티플렉서(Dx)는 패스 결정 유닛(PDU)에서 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 제공받을 수 있다. 또한, 디멀티플렉서(Dx)는 패스 결정 유닛(PDU)에서 패스 결정 신호(PD)를 제공받을 수 있다. 디멀티플렉 서(Dx)는 패스 결정 신호(PD)에 따라, 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 제1 멀티플라이어 (Mul1)에만 제공하거나, 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2)에 제공할 수 있다. 몇몇 실시예에 따르면, 디멀티플렉서(Dx)는 패스 결정 신호(PD)가 제1 패스 결정 신호인 경우, 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 모두 제1 멀티플라이어(Mul1)에 제공할 수 있다. 디멀티플렉서(Dx)는 패스 결정 신호(PD)가 제2 패스 결정 신호인 경우, 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)의 일부를 제1 멀티플라이어(Mul 1)에 제공하고, 다른 일부를 제2 멀티플라이어(Mul2)에 제공할 수 있다. 제1 멀티플라이어(Mul1)는 제1 프리시젼(Pr1)의 곱셈 연산기일 수 있다. 제1 멀티플라이어(Mul1)는 k(k는 자연 수)개일 수 있다. 또한, 제2 멀티플라이어(Mul2)는 제1 프리시젼(Pr1)의 곱셈 연산기일 수 있다. 제2 멀티플라 이어(Mul2)는 k개일 수 있다. 예를 들어, 웨이트(Weight) 및 인풋 액티베이션(Act_In)이 32-비트 데이터이고, 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2)는 INT4 곱셈 연산기인 경우, 플렉서블 멀티플라이어(FM)는 8개의 제1 멀티플라이어(Mul1)와, 8개의 제2 멀티플라이어(Mul2)를 포함할 수 있다. 제2 멀티플라이어(Mul2)는 제1 멀티플라이어(Mul1)와 실질적으로 동일할 수 있으나, 실시예들이 이에 제한되는 것은 아니다. 몇몇 실시예에 따르면, 분할 웨이트(D_W) 및 인풋 액티베이션(Act_In)은 전술한 엑스트라 비트가 추가될 수 있 으므로, 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2)의 적어도 일부는, 제1 프리시젼(Pr1) 보다 1-비트 큰 자릿수의 연산을 지원할 수 있다. 예를 들어, 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2)의 적어도 일부는, 5-비트의 연산을 지원하는 INT4 곱셈 연산기일 수 있다. 그러나, 실시예들이 이러한 용어에 제한되는 것은 아니고, 5-비트의 연산을 지원하는 INT4 곱셈 연산기는 INT5 곱셈 연산기로도 지칭할 수 있을 것이다. 몇몇 실시예에 따르면, 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2)는 부스 알고리즘(Booth algorithm) 을 이용하여 곱셈 연산을 수행할 수 있다. 얼라이너(ALNR)는 제1 멀티플라이어(Mul1)에서 생성된 제1 부분곱 그룹과 제2 멀티플라이어(Mul2)에서 생성된 제2 부분곱 그룹을 제공받을 수 있다. 얼라이너(ALNR)는 제1 부분곱 그룹과 제2 부분곱 그룹의 자릿수에 기초하 여, 제1 부분곱 그룹과 제2 부분곱 그룹을 각각 제1 정렬 부분곱 그룹과 제2 정렬 부분곱 그룹으로 그룹핑할 수 있다. 다시 말해서, 얼라이너(ALNR)는 제1 부분곱 그룹과 제2 부분곱 그룹에서 동일한 자릿수를 갖는 일부를 그 룹핑하여, 제1 정렬 부분곱 그룹을 생성하고, 다른 일부를 그룹핑하여 제2 정렬 부분곱 그룹을 생성할 수 있다. 다시 말해서, 얼라이너(ALNR)는 제1 자릿수를 갖는 부분곱 그룹을 그룹핑하여 제1 정렬 부분곱 그룹을 생성하고, 제2 자릿수를 갖는 부분곱 그룹을 그룹핑하여 제2 정렬 부분곱 그룹을 생성할 수 있다. 따라서, 제1 정렬 부분곱 그룹에 포함된 부분곱 그룹들은 서로 동일한 자릿수를 가지며, 제2 정렬 부분곱 그룹에 포함된 부 분곱 그룹들은 서로 동일한 자릿수를 가질 수 있다. 따라서, 몇몇 실시예에 따르면, 얼라이너(ALNR)를 이용하여 부분곱 그룹의 자릿수를 정렬함으로써, 추후 수행될 부분곱 그룹의 덧셈 연산에서 연산의 자릿수가 감소되고, 이에 따라 덧셈 연산기의 복잡도가 감소될 수 있다. 제1 부스 리덕션 트리(BRT1) 및 제2 부스 리덕션 트리(BRT2)는 생성된 부분곱 그룹을 덧셈 연산하여, 결과 데이 터를 생성할 수 있다. 제1 부스 리덕션 트리(BRT1)는 제1 뎁스 리듀서(DR_1) 및 제1 애더(Adder_1)를 포함할 수 있다. 제2 부스 리덕션 트리(BRT2)는 제2 뎁스 리듀서(DR_2) 및 제2 애더(Adder_2)를 포함할 수 있다. 제2 부스 리덕션 트리(BRT2)는 m개일 수 있다. 예를 들어, 제1 프리시젼(Pr1)이 INT4, 제2 프리시젼(Pr2)이 INT8, 웨이트 (Weight) 및 인풋 액티베이션(Act_In)이 32-비트 데이터인 경우, 제2 부스 리덕션 트리(BRT2)는 4개일 수 있다. 다만, 실시예들이 이에 제한되는 것은 아니고, 제2 부스 리덕션 트리(BRT2)의 개수는 하드웨어의 설계에 따라 다양하게 변경될 수 있다. 제1 뎁스 리듀서(DR_1) 및 제2 뎁스 리듀서(DR_2)는 부분곱 그룹들의 뎁스(depth)를 감소시킬 수 있다. 몇몇 실 시예에 따르면, 제2 뎁스 리듀서(DR_2) 및 제2 뎁스 리듀서(DR_2)는 부호 확장 비트를 이동 및 변형함으로써, 부분곱 그룹의 뎁스를 감소시킬 수 있다. 설명의 편의상 뎁스가 감소된 부분곱 그룹을 변형 부분곱 그룹으로 명 명한다. 이에 대한 구체적인 설명은 후술한다. 제1 애더(Adder_1) 및 제2 애더(Adder_2)는 각각 제1 뎁스 리듀서(DR_1) 및 제2 뎁스 리듀서(DR_2)에서 뎁스가 감소된 부분곱 그룹들에 대해 덧셈 연산을 수행할 수 있다. 몇몇 실시예에 따르면, 제1 애더(Adder_1) 및 제2 애더(Adder_2)는 3:2 CSA(Carry Save Adder)를 이용하여 뎁스가 감소된 부분곱 그룹들에 대한 덧셈 연산을 수행 할 수 있다. 도 12 내지 도 16을 이용하여, 연산 모드 신호(Mode)가 제1 모드 신호인 경우의 플렉서블 멀티플라 이어(FM)의 연산 과정에 대해 설명한다. 도 12는 연산 모드 신호가 제1 모드 신호인 경우, 본 발명의 몇몇 실시예들에 따른 플렉서블 멀티플라이어의 동 작을 설명하기 위한 도면이다. 도 12를 참조하면, 패스 결정 유닛(PDU)은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 수신할 수 있다. 또한, 패스 결정 유닛(PDU)은 연산 모드 신호(Mode)로, 제1 모드 신호(Mode(Pr1))를 수신할 수 있다. 비트 디비젼 로직(BDL)은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 제1 프리시젼(Pr1) 단위로 분할할 수 있다. 제1 프리시젼(Pr1) 단위로 분할된 웨이트(Weight)는 분할 웨이트(D_W)로, 제1 프리시젼(Pr1) 단위로 분할 된 인풋 액티베이션(Act_In)은 분할 인풋 액티베이션(D_A)으로 명명한다. 다시 말해서, 비트 디비젼 로직(BDL) 은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 제1 프리시젼(Pr1) 단위로 분할하여, 분할 웨이트(D_W) 및 분 할 인풋 액티베이션(D_A)을 생성할 수 있다. 패스 셀렉션 로직(PSL)은 제1 모드 신호(Mode(Pr1))에 따라, 제1 패스 결정 신호(PD1)를 생성할 수 있다. 제1 패스 결정 신호(PD1)는 플렉서블 멀티플라이어(FM)가 제1 패스(Path#1)를 따라 연산을 수행하도록 제어하는 신 호일 수 있다. 제1 패스(Path#1)는 제1 멀티플라이어(Mul1) 및 제1 부스 리덕션 트리(BRT1)가 동작하는 경로일 수 있다. 패스 결정 유닛(PDU)은 분할 웨이트(D_W), 분할 인풋 액티베이션(D_A) 및 제1 패스 결정 신호(PD1)를 디멀티플 렉서(Dx)에 제공할 수 있다. 디멀티플렉서(Dx)는 제1 패스 결정 신호(PD1)에 따라, 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 제1 멀티플라이어(Mul1)에 제공할 수 있다. 제1 멀티플라이어(Mul1)는 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 곱셈 연산하여, 부분곱 그룹을 생 성할 수 있다. 몇몇 실시예에 따르면, 제1 멀티플라이어(Mul1)는 부스 알고리즘을 이용하여, 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 연산하여 부분곱 그룹을 생성할 수 있다. 제1 멀티플라이어(Mul1)에서 생성된 부분곱 그룹은 제1 부스 리덕션 트리(BRT1)에 제공될 수 있다. 제1 부스 리 덕션 트리(BRT1)는 제1 멀티플라이어(Mul1)에서 생성된 부분곱 그룹에 대한 뎁스를 감소시키고, 뎁스가 감소된 부분곱 그룹들에 대한 덧셈 연산을 통해 결과 데이터를 생성할 수 있다. 다시 말해서, 제1 부스 리덕션 트리 (BRT1)에 포함된 제1 뎁스 리듀서(DR_1)는 제1 멀티플라이어(Mul1)에서 생성된 부분곱 그룹에 대한 뎁스를 감소 시켜 변형 부분곱 그룹을 생성하고, 제1 애더(Adder_1)는 3:2 CSA를 이용하여 변형 부분곱 그룹들에 대한 덧셈 연산을 수행하여, 결과 데이터를 생성할 수 있다. 결과 데이터는 새츄레이팅 애더(SA)로 제공되고, 새츄레이팅 애더(SA)는 결과 데이터를 이용하여 부분합(Psum)을 생성할 수 있다. 예시적인 설명을 위해, 도 13 내지 도 15 를 더 참조한다. 도 13 내지 도 15는, 웨이트(Weight) 및 인풋 액티베이션(Act_In)이 각각 32-비트 데이터이고, 제1 모드 신호(Mode(Pr1))는 INT4를 의미하고, k는 8인 경우를 가정하여 도시된 도면이다. 도 13은 본 발명의 몇몇 실시예들에 따른 제1 멀티플라이어가 부스 알고리즘을 이용하여 분할 웨이트 및 분할 인풋 액티베이션을 연산하는 과정을 설명하기 위한 도면이다. 도 12 및 도 13을 참조하면, k개(본 예시에서 8개)의 제1 멀티플라이어(Mul1)는 각각 제1 분할 웨이트(D_W1) 내 지 제8 분할 웨이트(D_W8)를 제공받을 수 있다. 또한, 8 개의 제1 멀티플라이어(Mul1)는 각각 제1 분할 인풋 액 티베이션(D_A1) 내지 제8 분할 인풋 액티베이션(D_A8)을 제공받을 수 있다. 예를 들어, 첫번째 제1 멀티플라이 어(Mul1)는 제1 분할 웨이트(D_W1)와 제1 분할 인풋 액티베이션(D_A1)을 제공받아, 이를 곱셈 연산할 수 있다. 또한, 여덟번째 제1 멀티플라이어(Mul1)는 제8 분할 웨이트(D_W8)와 제8 분할 인풋 액티베이션(D_A8)을 제공받 아, 이를 곱셈 연산할 수 있다. 다시 말해서, 8 개의 제1 멀티플라이어(Mul1)는 제1 분할 웨이트(D_W1) 내지 제 8 분할 웨이트(D_W8) 각각과, 제1 분할 인풋 액티베이션(D_A1) 내지 제8 분할 인풋 액티베이션(D_A8) 각각을 병 렬적/독립적으로 연산할 수 있다. 제1 멀티플라이어(Mul1)는 부스 알고리즘을 이용하여, 분할 웨이트(D_W)와 분할 인풋 액티베이션(D_A)을 연산할 수 있다. 예를 들어, 제1 멀티플라이어(Mul1)는 피승수(multiplicand)인 제1 분할 인풋 액티베이션(D_A1)과 승 수(multiplier)인 제1 분할 웨이트(D_W1)를 연산하여, 제1 부분곱 그룹(ppg_1)과 제2 부분곱 그룹(ppg_2)을 생 성할 수 있다. 예를 들어, 제1 멀티플라이어(Mul1)는 제1 분할 인풋 액티베이션(D_A1)과 제1 분할 웨이트(D_W1)의 제1 부분 (p_W1)을 연산하여 제1 부분곱 그룹(ppg_1)을 생성할 수 있다. 제1 부분곱 그룹(ppg_1)은 8-비트의 자릿수를 가 지고, 2의 뎁스를 가질 수 있다. 또한, 제1 멀티플라이어(Mul1)는 제1 분할 인풋 액티베이션(D_A1)과 제1 분할 웨이트(D_W1)의 제2 부분(p_W2)을 연산하여 제2 부분곱 그룹(ppg_2)을 생성할 수 있다. 제2 부분곱 그룹(ppg_ 2)은 8-비트의 자릿수를 가지고, 2의 뎁스를 가질 수 있다. 이와 유사하게, 제1 멀티플라이어(Mul1)는 제8 분할 인풋 액티베이션(D_A8)과 제8 분할 웨이트(D_W8)의 제15 부 분(p_W15)을 연산하여, 제15 부분곱 그룹(ppg_15)을 생성할 수 있다. 제15 부분곱 그룹(ppg_15)은 8-비트의 자 릿수를 가지고, 2의 뎁스를 가질 수 있다. 또한, 제1 멀티플라이어(Mul1)는 제8 분할 인풋 액티베이션(D_A8)과 제1 분할 웨이트(D_W1)의 제16 부분(p_W16)을 연산하여 제16 부분곱 그룹(ppg_16)을 생성할 수 있다. 제16 부분 곱 그룹(ppg_16)은 8-비트의 자릿수를 가지고, 2의 뎁스를 가질 수 있다. 제1 부분곱 그룹(ppg_1)에서, w0 및 w0'는 제1 분할 인풋 액티베이션(D_A1)과 제1 분할 웨이트(D_W1)의 제1 부 분(p_W1)의 부분곱을 의미한다. w0'은 제1 분할 인풋 액티베이션(D_A1)과 제1 분할 웨이트(D_W1)의 제1 부분 (p_W1)의 부분곱 중 최상위 비트를 의미한다. 각 자리의 w0는 서로 같거나 다른 값을 가질 수 있다. 또한, s0는 제1 분할 인풋 액티베이션(D_A1)과 제1 분할 웨이트(D_W1)의 제1 부분(p_W1)의 부분곱 중 최상위 비트 w0'의 부 호 확장한 값이다. w0'과 s0는 서로 동일한 값을 가질 수 있다. s0n은 s0의 반댓값(inversion)일 수 있다. 제2 부분곱 그룹(ppg_2)에서, w1 및 w1'는 제1 분할 인풋 액티베이션(D_A1)과 제1 분할 웨이트(D_W1)의 제2 부 분(p_W2)의 부분곱을 의미한다. w1'은 제1 분할 인풋 액티베이션(D_A1)과 제1 분할 웨이트(D_W1)의 제2 부분 (p_W2)의 부분곱 중 최상위 비트를 의미한다. 각 자리의 w1은 서로 같거나 다른 값을 가질 수 있다. 또한, s1는제1 분할 인풋 액티베이션(D_A1)과 제1 분할 웨이트(D_W1)의 제2 부분(p_W2)의 부분곱 중 최상위 비트 w1'의 부 호 확장한 값이다. w1'과 s1는 서로 동일한 값을 가질 수 있다. s1n은 s1의 반댓값일 수 있다. 이와 유사하게, 제15 부분곱 그룹(ppg_15)에서, w14 및 w14'는 제8 분할 인풋 액티베이션(D_A8)과 제8 분할 웨 이트(D_W8)의 제15 부분(p_W15)의 부분곱을 의미한다. w14'은 제8 분할 인풋 액티베이션(D_A8)과 제8 분할 웨이 트(D_W8)의 제15 부분(p_W15)의 부분곱 중 최상위 비트를 의미한다. 각 자리의 w14는 서로 같거나 다른 값을 가 질 수 있다. 또한, s14는 제8 분할 인풋 액티베이션(D_A8)과 제8 분할 웨이트(D_W8)의 제15 부분(p_W15)의 부분 곱 중 최상위 비트 w14'의 부호 확장한 값이다. w14'과 s14는 서로 동일한 값을 가질 수 있다. s14n은 s14의 반 댓값일 수 있다. 제16 부분곱 그룹(ppg_16)에서, w16 및 w16'는 제8 분할 인풋 액티베이션(D_A8)과 제8 분할 웨이트(D_W8)의 제 16 부분(p_W16)의 부분곱을 의미한다. w16'은 제8 분할 인풋 액티베이션(D_A8)과 제8 분할 웨이트(D_W8)의 제16 부분(p_W16)의 부분곱 중 최상위 비트를 의미한다. 각 자리의 w16은 서로 같거나 다른 값을 가질 수 있다. 또한, s16는 제8 분할 인풋 액티베이션(D_A8)과 제8 분할 웨이트(D_W8)의 제16 부분(p_W16)의 부분곱 중 최상위 비트 w16'의 부호 확장한 값이다. w16'과 s16는 서로 동일한 값을 가질 수 있다. s16n은 s16의 반댓값일 수 있 다. 제1 멀티플라이어(Mul1)는 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 연산하고, 이를 제1 부스 리덕션 트리(BRT1)에 제공할 수 있다. 다시 말해서, 복수의 제1 멀티플라이어(Mul1)는 각각 제1 부분곱 그룹(ppg_1) 내 지 제16 부분곱 그룹(ppg_16)을 생성하여, 이를 제1 부스 리덕션 트리(BRT1)에 제공할 수 있다. 제1 부스 리덕 션 트리(BRT1)는 제1 부분곱 그룹(ppg_1) 내지 제16 부분곱 그룹(ppg_16)을 이용하여, 결과 데이터를 생성할 수 있다. 도 14 및 도 15를 더 참조하여 설명한다. 도 14 및 도 15는 본 발명의 몇몇 실시예에 따른 제1 부분곱 그룹 내지 제16 부분곱 그룹의 뎁스를 감소시키는 과정을 설명하기 위한 도면이다. 연산기에 입력되는 부분곱 그룹들의 뎁스는 결국 연산 반복 횟수와 연관될 수 있다. 또한, 연산기에 입력되는 부분곱 그룹의 뎁스가 상대적으로 크다는 것은, 상대적으로 큰 저장 용량의 레지스터가 필요하다는 것을 의미할 수 있다. 따라서, 연산기에 입력되는 부분곱 그룹들의 뎁스를 최적화하여, 하드웨어 복잡성과 연산 비용을 감소 시킬 필요가 있다. 도 12 및 도 14를 참조하면, 제1 부분곱 그룹(ppg_1) 내지 제16 부분곱 그룹(ppg_16)은 각각 뎁스가 2이지만, 이를 적절히 정렬하는 경우, 제1 부분곱 그룹(ppg_1) 내지 제16 부분곱 그룹(ppg_16) 전체의 뎁스를 24로 정렬 할 수 있다. 이때, 3번째, 6번째, 9번째, 12번째, 15번째, 18번째, 21번째 및 24번째 뎁스를 참고하면, 각 뎁스 에는 연산이 필요한 단 하나의 값만 존재한다. 따라서, 3번째, 6번째, 9번째, 12번째, 15번째, 18번째, 21번째 및 24번째 뎁스의 값들을 적절히 변형하여 뎁스를 감소시키는 실시예에 대해 도 15를 통해 설명한다. 도 14 및 도 15를 참조하면, 제1 뎁스 리듀서(DR_1)는 제1 부분곱 그룹(ppg_1)의 뎁스 및 자릿수를 변형하여, 뎁스가 1인 제1 변형 부분곱 그룹(rppg_1)을 생성할 수 있다. 예를 들어, 제1 뎁스 리듀서(DR_1)는 제1 부분곱 그룹(ppg_1)에서 두번째 뎁스의 s0를 첫번째 뎁스의 하위 비트로 확장하여 제1 변형 부분곱 그룹(rppg_1)을 생 성할 수 있다. 또한, 제1 뎁스 리듀서(DR_1)는 제2 부분곱 그룹(ppg_2)의 뎁스 및 자릿수를 변형하여, 뎁스가 1인 제2 변형 부 분곱 그룹(rppg_2)을 생성할 수 있다. 예를 들어, 제1 뎁스 리듀서(DR_1)는 제2 부분곱 그룹(ppg_2)에서 두번째 뎁스의 s1을 첫번째 뎁스의 하위 비트로 확장하여 제2 변형 부분곱 그룹(rppg_2)을 생성할 수 있다. 이와 유사 하게, 제1 뎁스 리듀서(DR_1)는 제3 부분곱 그룹(ppg_3) 내지 제16 부분곱 그룹(ppg_16)을 변형하여, 제3 변형 부분곱 그룹(rppg_3) 내지 제16 변형 부분곱 그룹(rppg_16)을 생성할 수 있다. 이와 같이, 제1 뎁스 리듀서(DR_1)는 제1 부분곱 그룹(ppg_1) 내지 제16 부분곱 그룹(ppg_16)을 제1 변형 부분 곱 그룹(rppg_1) 내지 제16 변형 부분곱 그룹(rppg_16)으로 변형함으로써, 뎁스를 24에서 16으로 약 30% 이상 감소시킬 수 있다. 제1 뎁스 리듀서(DR_1)에서 생성된 제1 변형 부분곱 그룹(rppg_1) 내지 제16 변형 부분곱 그룹(rppg_16)은 제1 애더(Adder_1)에 제공될 수 있다. 제1 애더(Adder_1)는 제1 변형 부분곱 그룹(rppg_1) 내지 제16 변형 부분곱 그룹(rppg_16)을 더하여, 결과 데이터를 생성할 수 있다. 제1 애더(Adder_1)는 뎁스가 감소된 제1 변형 부분곱 그룹(rppg_1) 내지 제16 변형 부분곱 그룹(rppg_16)에 대해 연산하므로, 제1 애더(Adder_1)를 구현하기 위해서, 제1 뎁스 리듀서(DR_1)가 존재하지 않을 때보다 상대적으로 더 간단한 구조의 하드웨어로 구현할 수 있을 것이다. 몇몇 실시예에 따르면, 연산 모드 신호(Mode)가 제1 모드 신호(Mode(Pr1))인 경우, 얼라이너(ALNR)는 별도의 동 작 없이, 제1 멀티플라이어(Mul1)에서 생성된 부분곱 그룹을 제1 부스 리덕션 트리(BRT1)에 제공할 수 있다. 다 만, 실시예들이 이에 제한되는 것은 아니고, 도 12에 도시된 것과는 달리, 연산 모드 신호(Mode)가 제1 모드 신 호(Mode(Pr1))인 경우, 제1 멀티플라이어(Mul1)에서 생성된 부분곱 그룹은 얼라이너(ALNR)를 통과하지 않고 별 도의 경로를 통해 제1 부스 리덕션 트리(BRT1)에 제공될 수도 있을 것이다. 다음으로 도 16 내지 도 25를 이용 하여, 연산 모드 신호(Mode)가 제2 모드 신호인 경우의 플렉서블 멀티플라이어(FM)의 연산 과정에 대해 설명한 다. 도 16은 연산 모드 신호가 제2 모드 신호인 경우, 본 발명의 몇몇 실시예들에 따른 플렉서블 멀티플라이어의 동 작을 설명하기 위한 도면이다. 도 16을 참조하면, 패스 결정 유닛(PDU)은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 수신할 수 있다. 또한, 패스 결정 유닛(PDU)은 연산 모드 신호(Mode)로, 제2 모드 신호(Mode(Pr2))를 수신할 수 있다. 비트 디비젼 로직(BDL)은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 제1 프리시젼(Pr1) 단위로 분할할 수 있다. 다시 말해서, 비트 디비젼 로직(BDL)은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 제1 프리시젼(Pr1) 단위로 분할하여, 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 생성할 수 있다. 예를 들어, 분할 웨이트 (D_W)는 제1 분할 웨이트 내지 제8 분할 웨이트 중 어느 하나를 의미할 수 있다. 또한, 분할 인풋 액티베이션 (D_A)은 제1 분할 인풋 액티베이션 내지 제8 분할 인풋 액티베이션 중 어느 하나를 의미할 수 있다. 패스 셀렉션 로직(PSL)은 제2 모드 신호(Mode(Pr2))에 따라, 제2 패스 결정 신호(PD2)를 생성할 수 있다. 제2 패스 결정 신호(PD2)는 플렉서블 멀티플라이어(FM)가 제2 패스(Path#2)를 따라 연산을 수행하도록 제어하는 신 호일 수 있다. 제2 패스(Path#2)는 제1 멀티플라이어(Mul1), 제2 멀티플라이어(Mul2), 얼라이너(ALNR), 제1 부 스 리덕션 트리(BRT1) 및 제2 부스 리덕션 트리(BRT2)가 동작하는 경로일 수 있다. 패스 결정 유닛(PDU)은 분할 웨이트(D_W), 분할 인풋 액티베이션(D_A) 및 제2 패스 결정 신호(PD2)를 디멀티플 렉서(Dx)에 제공할 수 있다. 디멀티플렉서(Dx)는 제2 패스 결정 신호(PD2)에 따라, 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)을 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2)에 제공할 수 있다. 제1 멀티플라이어(Mul1)는 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)의 일부를 곱셈 연산하여, 부분곱 그 룹을 생성할 수 있다. 몇몇 실시예에 따르면, 제1 멀티플라이어(Mul1)는 부스 알고리즘을 이용하여, 분할 웨이 트(D_W) 및 분할 인풋 액티베이션(D_A)의 일부를 연산하여, 부분곱 그룹을 생성할 수 있다. 또한, 제2 멀티플라 이어(Mul2)는 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)의 다른 일부를 곱셈 연산하여, 부분곱 그룹을 생 성할 수 있다. 몇몇 실시예에 따르면, 제2 멀티플라이어(Mul2)는 부스 알고리즘을 이용하여, 분할 웨이트(D_W) 및 분할 인풋 액티베이션(D_A)의 다른 일부를 연산하여 부분곱 그룹을 생성할 수 있다. 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2)에서 생성된 부분곱 그룹은 얼라이너(ALNR)에 제공될 수 있 다. 얼라이너(ALNR)는 제1 멀티플라이어(Mul1)에서 생성된 부분곱 그룹과, 제2 멀티플라이어(Mul2)에서 생성된 부분곱 그룹의 자릿수를 정렬하여, 정렬 부분곱 그룹을 생성할 수 있다. 다시 말해서, 얼라이너(ALNR)는 부분곱 그룹의 자릿수를 기초로, 제1 멀티플라이어(Mul1)에서 생성된 부분곱 그룹과 제2 멀티플라이어(Mul2)에서 생성 된 부분곱 그룹을 정렬할 수 있다. 자릿수를 기초로 정렬된 부분곱 그룹을 정렬 부분곱 그룹으로 명명한다. 얼 라이너(ALNR)는 정렬 부분곱 그룹을 제1 부스 리덕션 트리(BRT1) 및 제2 부스 리덕션 트리(BRT2)에 제공할 수 있다. 이때, 제1 부스 리덕션 트리(BRT1)에 제공되는 정렬 부분곱 그룹은 제2 부스 리덕션 트리(BRT2)에 제공되 는 정렬 부분곱 그룹보다 뎁스가 클 수 있다. 구체적인 설명은 후술한다. 제1 부스 리덕션 트리(BRT1)는 얼라이너(ALNR)에서 제공받은 정렬 부분곱 그룹에 대한 뎁스를 감소시키고, 뎁스 가 감소된 정렬 부분곱 그룹들에 대한 덧셈 연산을 통해 제1 결과 데이터를 생성할 수 있다. 다시 말해서, 제1 부스 리덕션 트리(BRT1)에 포함된 제1 뎁스 리듀서(DR_1)는 얼라이너(ALNR)에서 제공받은 정렬 부분곱 그룹에 대한 뎁스를 감소시키고, 제1 애더(Adder_1)는 3:2 CSA를 이용하여 뎁스가 감소된 정렬 부분곱 그룹들에 대한 덧셈 연산을 수행하여, 제1 결과 데이터를 생성할 수 있다. 설명의 편의상 뎁스가 감소된 정렬 부분곱 그룹을 변형 정렬 부분곱 그룹으로 명명한다. 또한, 제2 부스 리덕션 트리(BRT2)는 얼라이너(ALNR)에서 제공받은 정렬 부분곱 그룹에 대한 뎁스를 감소시키고, 변형 정렬 부분곱 그룹들에 대한 덧셈 연산을 통해 제2 결과 데이터를 생성할 수 있다. 다시 말해 서, 제2 부스 리덕션 트리(BRT2)에 포함된 제2 뎁스 리듀서(DR_2)는 얼라이너(ALNR)에서 제공받은 정렬 부분곱그룹에 대한 뎁스를 감소시켜 변형 정렬 부분곱 그룹을 생성하고, 제2 애더(Adder_2)는 3:2 CSA를 이용하여 변 형 정렬 부분곱 그룹들에 대한 덧셈 연산을 수행하여, 제2 결과 데이터를 생성할 수 있다. 몇몇 실시예에 따르면, 제1 부스 리덕션 트리(BRT1)에 제공되는 정렬 부분곱 그룹의 뎁스는, 제2 부스 리덕션 트리(BRT2)에 제공되는 정렬 부분곱 그룹의 뎁스보다 클 수 있다. 다시 말해서, 제1 부스 리덕션 트리(BRT1)는 제2 부스 리덕션 트리(BRT2) 보다 많은 연산을 처리해야할 수 있다. 따라서, 제1 부스 리덕션 트리(BRT1)는 제2 부스 리덕션 트리(BRT2)보다 하드웨어 복잡도가 높을 수 있다. 몇몇 실시예에 따르면, 제2 부스 리덕션 트리(BRT2)는 m개(m은 자연수)로 구현될 수 있다. 예를 들어, 제1 프리 시젼(Pr1)이 INT4, 제2 프리시젼(Pr2)이 INT8, 웨이트(Weight) 및 인풋 액티베이션(Act_In)이 각각 32-비트 데 이터인 경우, 제2 부스 리덕션 트리(BRT2)는 4개로 구현될 수 있다. 예를 들어, 얼라이너(ALNR)는 다섯개의 정 렬 부분곱 그룹을 생성할 수 있고, 다섯개의 정렬 부분곱 그룹 중 뎁스가 가장 큰 정렬 부분곱 그룹은 제1 부스 리덕션 트리(BRT1)에 제공되고, 나머지 네개는 제2 부스 리덕션 트리(BRT2)에 각각 제공될 수 있다. 제1 결과 데이터와 제2 결과 데이터는 새츄레이팅 애더(SA)로 제공되고, 새츄레이팅 애더(SA)는 제1 및 제2 결 과 데이터를 이용하여 부분합(Psum)을 생성할 수 있다. 예시적인 설명을 위해, 도 17 내지 도 25를 더 참조한다. 도 17 내지 도 25는, 웨이트(Weight) 및 인풋 액티베이션(Act_In)이 각각 32-비트 데이터이고, 제2 모드 신호(Mode(Pr2))는 INT8을 의미하고, k는 8인 경우를 가정하여 도시된 도면이다. 도 17 내지 도 21은 8-비트 데이터의 곱셈 연산을 4-비트 데이터의 곱셈 연산으로 변환하여 연산하는 과정에 대 해 설명한다. 도 17을 참조하면, 8-비트 데이터의 곱셈 연산은 4-비트 데이터의 곱셈 연산으로 대체할 수 있다. 예를 들어, 제2 프리시젼(Pr2)의 인풋 액티베이션(A(Pr2)_1)과 제2 프리시젼(Pr2)의 웨이트(W(Pr2)_1)의 곱셈 연산은, 5-비 트의 제1 하위 분할 인풋 액티베이션(D_AL1)과 5-비트의 제1 하위 분할 웨이트(D_WL1), 4-비트의 제1 상위 분할 인풋 액티베이션(D_AH1)과 5-비트의 제1 하위 분할 웨이트(D_WL1), 5-비트의 제1 하위 분할 인풋 액티베이션 (D_AL1)과 4-비트의 제1 상위 분할 웨이트(D_WH1), 4-비트의 제1 상위 분할 인풋 액티베이션(D_AH1)과 4-비트의 제1 상위 분할 웨이트(D_WH1) 각각의 곱셈 연산의 결과를 이용하여 수행될 수 있다. 이때, 5-비트의 제1 하위 분할 인풋 액티베이션(D_AL1)의 최상위 비트는 부호 고정을 위해 확장된 비트일 수 있 다. 예를 들어, 제1 하위 분할 인풋 액티베이션(D_AL1)의 최상위 비트는 양수를 의미하는 '0'일 수 있다. 또한, 5-비트의 제1 하위 분할 인풋 액티베이션(D_AL1)의 나머지 비트는 8-비트의 제1 분할 인풋 액티베이션(D_A1)의 하위 4개의 값과 동일할 수 있다. 마찬가지로, 5-비트의 제1 하위 분할 웨이트(D_WL1)의 최상위 비트는 부호 고 정을 위해 확장된 비트일 수 있다. 예를 들어, 제1 하위 분할 웨이트(D_WL1)의 최상위 비트는 양수를 의미하는 '0'일 수 있다. 또한, 5-비트의 제1 하위 분할 웨이트(D_WL1)의 나머지 비트는 8-비트의 제1 분할 웨이트(D_W 1)의 하위 4개의 값과 동일할 수 있다. 전술한 바와 같이, 8-비트 데이터의 곱셈 연산은 4-비트 데이터의 곱셈 연산으로 분할하여 수행할 수 있다. 이 때, 8-비트 데이터를 2개의 4-비트 데이터로 분할하는 경우, 하위 4개의 비트를 포함하는 데이터는 부호가 항상 양수여야 한다. 따라서, 제1 하위 분할 인풋 액티베이션(D_AL1) 및 제1 하위 분할 웨이트(D_WL1)의 최상위 비트 는 양수를 의미하는 데이터로 고정할 필요가 있다. 제1 상위 분할 인풋 액티베이션(D_AH1)은 제2 프리시젼(Pr2)의 인풋 액티베이션(A(Pr2)_1)의 상위 4개의 값과 동일할 수 있다. 또한, 제1 상위 분할 웨이트(D_WH1)는 제2 프리시젼(Pr2)의 웨이트(W(Pr2)_1)의 상위 4개의 값 과 동일할 수 있다. 다시 말해서, 제1 상위 분할 인풋 액티베이션(D_AH1)은 제2 프리시젼(Pr2)의 인풋 액티베이 션(A(Pr2)_1)의 상위 4개의 값을 포함하고, 제1 하위 분할 인풋 액티베이션(D_AL1)은 제2 프리시젼(Pr2)의 인풋 액티베이션(A(Pr2)_1)의 하위 4개의 값을 포함할 수 있다. 마찬가지로, 제1 상위 분할 웨이트(D_WH1)는 제2 프 리시젼(Pr2)의 웨이트(W(Pr2)_1)의 상위 4개의 값을 포함하고, 제1 하위 분할 웨이트(D_WL1)는 제2 프리시젼 (Pr2)의 웨이트(W(Pr2)_1)의 하위 4개의 값을 포함할 수 있다. 도 18을 참조하면, 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2) 중 하나는 제1 하위 분할 인풋 액티베이 션(D_AL1)과 제1 하위 분할 웨이트(D_WL1)를 곱셈 연산할 수 있다. 제1 멀티플라이어(Mul1) 및 제2 멀티플라이 어(Mul2) 중 하나는 제1 하위 분할 인풋 액티베이션(D_AL1)과 제1 하위 분할 웨이트(D_WL1)를 곱셈 연산하여, 제0-1 부분곱 그룹(ppg0_1), 제1-1 부분곱 그룹(ppg1_1) 및 제2-1 부분곱 그룹(ppg2_1)을 생성할 수 있다. 제0-1 부분곱 그룹(ppg0_1) 내지 제2-1 부분곱 그룹(ppg2_1)에서, w0_1, w0_1', w1_1, w1_1', w2_1 및 w2_1'는 제1 하위 분할 인풋 액티베이션(D_AL1)과 제1 하위 분할 웨이트(D_WL1)의 부분곱을 의미한다. w0_1', w1_1' 및w2_1'은 각 부분곱 중 최상위 비트를 의미한다. 각 자리의 w0_1, w1_1 및 w2_1은 서로 같거나 다른 값을 가질 수 있다. s0_1, s1_1 및 s2_1은 각 부분곱 중 최상위 비트 w0_1', w1_1' 및 w2_1'의 부호 확장한 값이다. w0_1', w1_1' 및 w2_1' 각각과 s0_1, s1_1 및 s2_1 각각은 서로 동일한 값을 가질 수 있다. s0_1n, s1_1n 및 s2_1n은 각각 s0_1, s1_1 및 s2_1의 반댓값일 수 있다. 도 19를 참조하면, 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2) 중 하나는 제1 상위 분할 인풋 액티베이 션(D_AH1)과 제1 하위 분할 웨이트(D_WL1)를 곱셈 연산할 수 있다. 제1 멀티플라이어(Mul1) 및 제2 멀티플라이 어(Mul2) 중 하나는 제1 상위 분할 인풋 액티베이션(D_AH1)과 제1 하위 분할 웨이트(D_WL1)를 곱셈 연산하여, 제3-1 부분곱 그룹(ppg3_1), 제4-1 부분곱 그룹(ppg4_1) 및 제5-1 부분곱 그룹(ppg5_1)을 생성할 수 있다. 제3-1 부분곱 그룹(ppg3_1) 내지 제5-1 부분곱 그룹(ppg5_1)에서, w3_1, w3_1', w4_1, w4_1', w5_1 및 w5_1'는 제1 상위 분할 인풋 액티베이션(D_AH1)과 제1 하위 분할 웨이트(D_WL1)의 부분곱을 의미한다. w3_1', w4_1' 및 w5_1'은 각 부분곱 중 최상위 비트를 의미한다. 각 자리의 w3_1, w4_1 및 w5_1은 서로 같거나 다른 값을 가질 수 있다. s3_1, s4_1 및 s5_1은 각 부분곱 중 최상위 비트 w3_1', w4_1' 및 w5_1'의 부호 확장한 값이다. w3_1', w4_1' 및 w5_1' 각각과 s3_1, s4_1 및 s5_1 각각은 서로 동일한 값을 가질 수 있다. s3_1n, s4_1n 및 s5_1n은 각각 s3_1, s4_1 및 s5_1의 반댓값일 수 있다. 도 20을 참조하면, 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2) 중 하나는 제1 하위 분할 인풋 액티베이 션(D_AL1)과 제1 상위 분할 웨이트(D_WH1)를 곱셈 연산할 수 있다. 제1 멀티플라이어(Mul1) 및 제2 멀티플라이 어(Mul2) 중 하나는 제1 하위 분할 인풋 액티베이션(D_AL1)과 제1 상위 분할 웨이트(D_WH1)를 곱셈 연산하여, 제6-1 부분곱 그룹(ppg6_1) 및 제7-1 부분곱 그룹(ppg7_1)을 생성할 수 있다. 제6-1 부분곱 그룹(ppg6_1) 및 제7-1 부분곱 그룹(ppg7_1)에서, w6_1, w6_1', w7_1 및 w7_1'는 제1 하위 분할 인풋 액티베이션(D_AL1)과 제1 상위 분할 웨이트(D_WH1)의 부분곱을 의미한다. w6_1' 및 w7_1'은 각 부분곱 중 최상위 비트를 의미한다. 각 자리의 w6_1 및 w7_1은 서로 같거나 다른 값을 가질 수 있다. s6_1 및 s7_1은 각 부분곱 중 최상위 비트 w6_1' 및 w7_1'의 부호 확장한 값이다. w6_1' 및 w7_1' 각각과 s6_1 및 s7_1 각각은 서 로 동일한 값을 가질 수 있다. s6_1n 및 s7_1n은 각각 s6_1 및 s7_1의 반댓값일 수 있다. 도 21을 참조하면, 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2) 중 하나는 제1 상위 분할 인풋 액티베이 션(D_AH1)과 제1 상위 분할 웨이트(D_WH1)를 곱셈 연산할 수 있다. 제1 멀티플라이어(Mul1) 및 제2 멀티플라이 어(Mul2) 중 하나는 제1 상위 분할 인풋 액티베이션(D_AH1)과 제1 상위 분할 웨이트(D_WH1)를 곱셈 연산하여, 제8-1 부분곱 그룹(ppg8_1) 및 제9-1 부분곱 그룹(ppg9_1)을 생성할 수 있다. 제8-1 부분곱 그룹(ppg8_1) 및 제9-1 부분곱 그룹(ppg9_1)에서, w8_1, w8_1', w9_1 및 w9_1'는 제1 상위 분할 인풋 액티베이션(D_AH1)과 제1 상위 분할 웨이트(D_WH1)의 부분곱을 의미한다. w8_1' 및 w9_1'은 각 부분곱 중 최상위 비트를 의미한다. 각 자리의 w8_1 및 w9_1은 서로 같거나 다른 값을 가질 수 있다. s8_1 및 s9_1은 각 부분곱 중 최상위 비트 w8_1' 및 w9_1'의 부호 확장한 값이다. w8_1' 및 w9_1' 각각과 s8_1 및 s9_1 각각은 서 로 동일한 값을 가질 수 있다. s8_1n 및 s9_1n은 각각 s8_1 및 s9_1의 반댓값일 수 있다. 도 18 내지 도 21은 제1 멀티플라이어(Mul1) 또는 제2 멀티플라이어(Mul2)에서 제1 분할 인풋 액티베이션(D_A1) 및 제1 분할 웨이트(D_W1)를 연산하는 과정에 대해 설명한다. 이와 유사하게, 제1 멀티플라이어(Mul1) 또는 제2 멀티플라이어(Mul2)는 제2 분할 인풋 액티베이션과 제2 분할 웨이트를 연산하여, 제0-2 부분곱 그룹(ppg0_2) 내 지 제9-2 부분곱 그룹(ppg9_2)을 생성할 수 있다. 또한, 제1 멀티플라이어(Mul1) 또는 제2 멀티플라이어(Mul2) 는 제3 분할 인풋 액티베이션과 제3 분할 웨이트를 연산하여, 제0-3 부분곱 그룹(ppg0_3) 내지 제9-3 부분곱 그 룹(ppg9_3)을 생성할 수 있다. 또한, 제1 멀티플라이어(Mul1) 또는 제2 멀티플라이어(Mul2)는 제4 분할 인풋 액 티베이션과 제4 분할 웨이트를 연산하여, 제0-4 부분곱 그룹(ppg0_4) 내지 제9-4 부분곱 그룹(ppg9_4)을 생성할 수 있다. 제1 멀티플라이어(Mul1) 또는 제2 멀티플라이어(Mul2)에서 생성된 제0-1 부분곱 그룹(ppg0_1) 내지 제9-4 부분 곱 그룹(ppg9_4)은 얼라이너(ALNR)에 제공될 수 있다. 얼라이너(ALNR)는 제1 멀티플라이어(Mul1) 또는 제2 멀티플라이어(Mul2)에서 생성된 제0-1 부분곱 그룹(ppg0_1) 내지 제9-4 부분곱 그룹(ppg9_4)의 자릿수를 기초로, 제1 정렬 부분곱 그룹(ALNG_1) 내지 제5 정렬 부분곱 그룹 (ALNG_5)을 생성할 수 있다. 다시 말해서, 얼라이너(ALNR)는 부분곱 그룹의 자릿수에 따라 부분곱 그룹을 정렬 하여, 제1 정렬 부분곱 그룹(ALNG_1) 내지 제5 정렬 부분곱 그룹(ALNG_5)을 생성할 수 있다. 제1 정렬 부분곱 그룹(ALNG_1) 내지 제5 정렬 부분곱 그룹(ALNG_5)을 설명하기 위해, 도 22 내지 도 25를 더 참조한다. 도 22 내지 도 25는 제1 정렬 부분곱 그룹 내지 제5 정렬 부분곱 그룹을 설명하기 위한 도면이다. 설명의 편의 를 위해 전술한 내용과 동일하거나 유사한 내용은 생략하거나 간단히 설명한다. 도 18 내지 도 25를 참조하면, 얼라이너(ALNR)는 제1 멀티플라이어(Mul1) 또는 제2 멀티플라이어(Mul2)에서 생 성된 부분곱 그룹에 대해, 동일한 자릿수를 갖는 부분곱 그룹들을 그룹핑하여, 제1 정렬 부분곱 그룹(ALNG_1) 내지 제5 정렬 부분곱 그룹(ALNG_5)을 생성할 수 있다. 예를 들어, 도 22를 참조하면, 얼라이너(ALNR)는 자릿수가 동일한 제0-1 부분곱 그룹(ppg0_1), 제1-1 부분곱 그 룹(ppg1_1), 제0-2 부분곱 그룹(ppg0_2), 제1-2 부분곱 그룹(ppg1_2), 제0-3 부분곱 그룹(ppg0_3), 제1-3 부분 곱 그룹(ppg1_3), 제0-4 부분곱 그룹(ppg0_4) 및 제1-4 부분곱 그룹(ppg1_4)을 그룹핑하여, 제1 정렬 부분곱 그룹(ALNG_1)을 생성할 수 있다. 또한, 예를 들어, 도 23을 참조하면, 얼라이너(ALNR)는 자릿수가 동일한 제2-1 부분곱 그룹(ppg2_1), 제2-2 부 분곱 그룹(ppg2_2), 제2-3 부분곱 그룹(ppg2_3) 및 제2-4 부분곱 그룹(ppg2_4)을 그룹핑하여, 제2 정렬 부분곱 그룹(ALNG_2)을 생성할 수 있다. 또한, 예를 들어, 얼라이너(ALNR)는 자릿수가 동일한 제5-1 부분곱 그룹(ppg5_1), 제5-2 부분곱 그룹(ppg5_2), 제5-3 부분곱 그룹(ppg5_3) 및 제5-4 부분곱 그룹(ppg5_4)을 그룹핑하여, 제3 정렬 부분곱 그룹(ALNG_3)을 생성 할 수 있다. 또한, 예를 들어, 도 24를 참조하면, 얼라이너(ALNR)는 자릿수가 동일한 제8-1 부분곱 그룹(ppg8_1), 제9-1 부 분곱 그룹(ppg9_1), 제8-2 부분곱 그룹(ppg8_2), 제9-2 부분곱 그룹(ppg9_2), 제8-3 부분곱 그룹(ppg8_3), 제 9-3 부분곱 그룹(ppg9_3), 제8-4 부분곱 그룹(ppg8_4) 및 제9-4 부분곱 그룹(ppg9_4)을 그룹핑하여, 제4 정렬 부분곱 그룹(ALNG_4)을 생성할 수 있다. 또한, 예를 들어, 도 25를 참조하면, 얼라이너(ALNR)는 자릿수가 동일한 제3-1 부분곱 그룹(ppg3_1), 제4-1 부 분곱 그룹(ppg4_1), 제6-1 부분곱 그룹(ppg6_1), 제7-1 부분곱 그룹(ppg7_1), 제3-2 부분곱 그룹(ppg3_2), 제 4-2 부분곱 그룹(ppg4_2), 제6-2 부분곱 그룹(ppg6_2), 제7-2 부분곱 그룹(ppg7_2), 제3-3 부분곱 그룹 (ppg3_3), 제4-3 부분곱 그룹(ppg4_3), 제6-3 부분곱 그룹(ppg6_3), 제7-3 부분곱 그룹(ppg7_3), 제3-4 부분곱 그룹(ppg3_4), 제4-4 부분곱 그룹(ppg4_4), 제6-4 부분곱 그룹(ppg6_4) 및 제7-4 부분곱 그룹(ppg7_4)을 그룹 핑하여, 제5 정렬 부분곱 그룹(ALNG_5)을 생성할 수 있다. 몇몇 실시예에 따르면, 제5 정렬 부분곱 그룹(ALNG_5)의 뎁스는, 제1 정렬 부분곱 그룹(ALNG_1) 내지 제4 정렬 부분곱 그룹(ALNG_4)의 뎁스보다 크므로, 얼라이너(ALNR)는 제5 정렬 부분곱 그룹(ALNG_5)을 제1 부스 리덕션 트리(BRT1)에 제공하고, 제1 정렬 부분곱 그룹(ALNG_1) 내지 제4 정렬 부분곱 그룹(ALNG_4)을 4개의 제2 부스 리덕션 트리(BRT2)에 각각 제공할 수 있다. 전술한 바와 같이, 제1 부스 리덕션 트리(BRT1)는 제2 부스 리덕션 트리(BRT2) 보다 처리할 수 있는 연산량이 많을 수 있다. 다시 말해서, 제1 부스 리덕션 트리(BRT1)는 제5 정렬 부분곱 그룹(ALNG_5)을 제공받고, 복수의 제2 부스 리덕 션 트리(BRT2) 각각은 제1 정렬 부분곱 그룹(ALNG_1) 내지 제4 정렬 부분곱 그룹(ALNG_4)을 제공받을 수 있다. 도 14 및 도 15에서 설명한 것과 유사하게, 제1 부스 리덕션 트리(BRT1)의 제1 뎁스 리듀서(DR_1)는 제5 정렬 부분곱 그룹(ALNG_5)의 뎁스를 감소하여, 제5 변형 정렬 부분곱 그룹을 생성할 수 있다. 제1 애더(Adder_1)는 3:2 CSA를 이용하여, 제5 변형 정렬 부분곱 그룹에 대한 덧셈 연산을 수행하여 제1 결과 데이터를 생성할 수 있 다. 제1 결과 데이터는 새츄레이팅 애더(SA)에 제공될 수 있다. 이와 유사한 과정이 복수의 제2 부스 리덕션 트리(BRT2)에서도 수행될 수 있다. 예를 들어, 제2-1 부스 리덕션 트리의 제2-1 뎁스 리듀서는 제1 정렬 부분곱 그룹(ALNG_1)의 뎁스를 감소하여, 제1 변형 정렬 부분곱 그룹을 생성할 수 있다. 제2-1 애더는 3:2 CSA를 이용하여, 제1 변형 정렬 부분곱 그룹에 대한 덧셈 연산을 수행하여 제2-1 결과 데이터를 생성할 수 있다. 제2-1 결과 데이터는 새츄레이팅 애더(SA)에 제공될 수 있다. 또한, 제2- 2 부스 리덕션 트리의 제2-2 뎁스 리듀서는 제2 정렬 부분곱 그룹(ALNG_2)의 뎁스를 감소하여, 제2 변형 정렬 부분곱 그룹을 생성할 수 있다. 제2-2 애더는 3:2 CSA를 이용하여, 제2 변형 정렬 부분곱 그룹에 대한 덧셈 연 산을 수행하여 제2-2 결과 데이터를 생성할 수 있다. 제2-2 결과 데이터는 새츄레이팅 애더(SA)에 제공될 수 있 다. 제2-3 부스 리덕션 트리의 제2-3 뎁스 리듀서는 제3 정렬 부분곱 그룹(ALNG_3)의 뎁스를 감소하여, 제3 변 형 정렬 부분곱 그룹을 생성할 수 있다. 제2-3 애더는 3:2 CSA를 이용하여, 제3 변형 정렬 부분곱 그룹에 대한 덧셈 연산을 수행하여 제2-3 결과 데이터를 생성할 수 있다. 제2-3 결과 데이터는 새츄레이팅 애더(SA)에 제공될 수 있다. 제2-4 부스 리덕션 트리의 제2-4 뎁스 리듀서는 제4 정렬 부분곱 그룹(ALNG_4)의 뎁스를 감소하여, 제4 변형 정렬 부분곱 그룹을 생성할 수 있다. 제2-4 애더는 3:2 CSA를 이용하여, 제4 변형 정렬 부분곱 그룹에 대한 덧셈 연산을 수행하여 제2-4 결과 데이터를 생성할 수 있다. 제2-4 결과 데이터는 새츄레이팅 애더(SA)에 제공될 수 있다. 새츄레이팅 애더(SA)는 제1 결과 데이터, 제2-1 결과 데이터, 제2-2 결과 데이터, 제2-3 결과 데이터 및 제2-4 결과 데이터를 이용하여, 부분합(Psum)을 생성할 수 있다. 몇몇 실시예에 따르면, 플렉서블 멀티플라이어(FM)는 제2 프리시젼(Pr2)의 연산을 위해, 제1 프리시젼(Pr1)의 제1 멀티플라이어(Mul1) 및 제1 프리시젼(Pr1)의 제2 멀티플라이어(Mul2)를 이용할 수 있다. 제1 프리시젼(Pr 1)의 멀티플라이어는 제2 프리시젼(Pr2)의 멀티플라이어 보다 하드웨어 복잡도가 낮으며, 이에 따라 소비 전력 또한 상대적으로 작기 때문에, 제1 프리시젼(Pr1)의 멀티플라이어로 구성된 플렉서블 멀티플라이어(FM)는 상대 적으로 작은 면적 내에 구현될 수 있으며, 소비 전력 또한 절감할 수 있다는 장점이 있다. 또한, 몇몇 실시예에 따르면, 플렉서블 멀티플라이어(FM)는 뎁스를 감소시키는 뎁스 리듀서를 포함하기 때문에, 상대적으로 더 적은 연산으로 동일한 결과 데이터를 생성할 수 있다. 따라서, 연산에 필요한 레이턴시를 효과적 으로 감소시킬 수 있다. 또한, 몇몇 실시예에 따르면, 플렉서블 멀티플라이어(FM)는 제2 프리시젼(Pr2)의 연산을 위해, 얼라이너(ALNR) 를 이용하여 자릿수가 서로 동일한 부분곱을 그룹핑할 수 있다. 이때, 플렉서블 멀티플라이어(FM)는 그룹핑된 부분곱 그룹을 뎁스의 크기에 따라 적절한 부스 리덕션 트리에 제공할 수 있기 때문에, 하드웨어 리소스의 낭비 를 최소화할 수 있으며, 복수의 부스 리덕션 트리가 이용되므로 병렬적인 처리가 가능하다는 장점이 있다. 도 26은 본 발명의 다른 몇몇 실시예에 따른 플렉서블 멀티플라이어의 구성을 설명하기 위한 도면이다. 설명의 편의를 위해 전술한 내용과 동일하거나 유사한 내용은 생략하거나 간단히 설명한다. 도 22 내지 도 26을 참조하면, 플렉서블 멀티플라이어(FM)는 패스 결정 유닛(PDU), 디멀티플렉서(Dx), 제1 멀티 플라이어(Mul1), 제2 멀티플라이어(Mul2), 얼라이너(ALNR), 제1 부스 리덕션 트리(BRT1), 제2 부스 리덕션 트리 (BRT2) 및 프리 애더(PADR)를 포함할 수 있다. 패스 결정 유닛(PDU)은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 이용하여, 복수의 분할 웨이트(D_W) 및 복수의 분할 인풋 액티베이션(D_A)을 생성할 수 있다. 패스 결정 유닛(PDU)은 복수의 분할 웨이트(D_W) 및 복수 의 분할 인풋 액티베이션(D_A)을 디멀티플렉서(Dx)에 제공할 수 있다. 또한, 패스 결정 유닛(PDU)은 연산 모드 신호(Mode)를 수신하고, 수신한 연산 모드 신호(Mode)를 기초로 패스 결정 신호(PD)를 생성하여, 디멀티플렉서 (Dx)에 제공할 수 있다. 연산 모드 신호(Mode)가 제1 모드 신호(Mode(Pr1))인 경우, 디멀티플렉서(Dx)는 복수의 분할 웨이트(D_W) 및 복 수의 분할 인풋 액티베이션(D_A)을 제1 멀티플라이어(Mul1)에 제공할 수 있다. 제1 멀티플라이어(Mul1)는 복수 의 분할 웨이트(D_W) 각각과, 복수의 분할 인풋 액티베이션(D_A) 각각을 연산하여, 복수의 부분곱 그룹을 생성 할 수 있다. 제1 멀티플라이어(Mul1)에서 생성된 복수의 부분곱 그룹은 제1 부스 리덕션 트리(BRT1)에 제공될 수 있다. 제1 부스 리덕션 트리(BRT1)는 복수의 부분곱 그룹을 이용하여, 결과 데이터를 생성할 수 있다. 결과 데이터는 새츄레이팅 애더(SA)에 제공될 수 있다. 연산 모드 신호(Mode)가 제2 모드 신호(Mode(Pr2))인 경우, 디멀티플렉서(Dx)는 복수의 분할 웨이트(D_W) 및 복 수의 분할 인풋 액티베이션(D_A)의 일부를 제1 멀티플라이어(Mul1)에 제공하고, 다른 일부를 제2 멀티플라이어 (Mul2)에 제공할 수 있다. 제1 멀티플라이어(Mul1)는 복수의 분할 웨이트(D_W) 및 복수의 분할 인풋 액티베이션(D_A)의 일부를 연산하여, 복수의 부분곱 그룹을 생성할 수 있다. 또한, 제2 멀티플라이어(Mul2)는 복수의 분할 웨이트(D_W) 및 복수의 분 할 인풋 액티베이션(D_A)의 다른 일부를 연산하여, 복수의 부분곱 그룹을 생성할 수 있다. 제1 멀티플라이어 (Mul1) 및 제2 멀티플라이어(Mul2)에서 생성된 복수의 부분곱 그룹은 얼라이너(ALNR)에 제공될 수 있다. 얼라이너(ALNR)는 제1 멀티플라이어(Mul1) 및 제2 멀티플라이어(Mul2)에서 제공받은 복수의 부분곱 그룹의 자릿 수를 기초로, 복수의 정렬 부분곱 그룹을 생성할 수 있다. 얼라이너(ALNR)에서 생성된 복수의 정렬 부분곱 그룹 중 뎁스가 가장 큰 정렬 부분곱 그룹은 제1 부스 리덕션 트리(BRT1)에 제공되고, 나머지 정렬 부분곱 그룹은 복 수의 제2 부스 리덕션 트리(BRT2)에 각각 제공될 수 있다. 제1 부스 리덕션 트리(BRT1)는 정렬 부분곱 그룹을 이용하여, 제1 결과 데이터를 생성할 수 있다. 복수의 제2 부스 리덕션 트리(BRT2) 각각은 정렬 부분곱 그룹을 이용하여 제2-1 결과 데이터, 제2-2 결과 데이 터, 제2-3 결과 데이터 및 제2-4 결과 데이터를 생성할 수 있다. 예를 들어, 복수의 제2 부스 리덕션 트리 (BRT2)가 제2-1 부스 리덕션 트리, 제2-2 부스 리덕션 트리, 제2-3 부스 리덕션 트리 및 제2-4 부스 리덕션 트 리를 포함한다고 가정하면, 제2-1 부스 리덕션 트리는 제2-1 결과 데이터를 생성하고, 제2-2 부스 리덕션 트리 는 제2-2 결과 데이터를 생성하고, 제2-3 부스 리덕션 트리는 제2-3 결과 데이터를 생성하고, 제2-4 부스 리덕 션 트리는 제2-4 결과 데이터를 생성할 수 있다. 제2-1 결과 데이터 내지 제2-4 결과 데이터는 프리 애더(PADR)에 제공될 수 있다. 프리 애더(PADR)는 제2-1 결 과 데이터 내지 제2-4 결과 데이터에 대해 덧셈 연산을 수행하여, 제2 결과 데이터를 생성할 수 있다. 전술한 바와 같이, 제1 결과 데이터를 생성하는데 이용되는 정렬 부분곱 그룹은 뎁스가 가장 클 수 있다. 따라서, 제1 부스 리덕션 트리(BRT1)가 제1 결과 데이터를 생성하는데 걸리는 시간은, 제2-1 부스 리덕션 트리 내지 제2-4 부스 리덕션 트리 각각이 제2-1 결과 데이터 내지 제2-4 결과 데이터 각각을 생성하는데 걸리는 시간보다 클 수 있다. 따라서, 프리 애더(PADR)는 제1 결과 데이터가 생성되기 전 미리 동작하여, 제2-1 결과 데이터 내지 제2- 4 결과 데이터의 덧셈 연산을 미리 시작할 수 있다. 프리 애더(PADR)는 제2-1 결과 데이터 내지 제2-4 결과 데 이터를 덧셈 연산하여, 제2 결과 데이터를 생성할 수 있다. 제2 결과 데이터는 새츄레이팅 애더(SA)에 제공될 수 있다. 몇몇 실시예에 따르면, 프리 애더(PADR)는 제1 부스 리덕션 트리(BRT1)가 동작을 완료하기 전, 즉, 제1 결과 데 이터가 생성되기 전에 미리 제2-1 결과 데이터 내지 제2-4 결과 데이터에 대한 연산을 시작할 수 있다. 다시 말 해서, 프리 애더(PADR)는 제1 부스 리덕션 트리(BRT1)의 연산 시간과 제2 부스 리덕션 트리(BRT2)의 연산 시간 의 차이만큼 먼저 연산을 시작할 수 있다. 따라서, 새츄레이팅 애더(SA)는 제1 결과 데이터와, 제2 결과 데이터 를 이용하여 부분합을 생성하기 때문에, 새츄레이팅 애더(SA)의 연산 속도는 상대적으로 증가될 수 있다. 도 27은 도 7의 L0 메모리를 세부적으로 설명하기 위한 블록도이다. 도 27을 참조하면, L0 메모리는 아비터 및 적어도 하나의 로컬 메모리 뱅크를 포함할 수 있다. 데이터가 L0 메모리로 저장될 때, 아비터는 로드 엔진(113a)으로부터 데이터를 수신할 수 있다. 이때, 데이터는 라운드 로빈(round robin) 방식으로 로컬 메모리 뱅크를 할당 받을 수 있다. 이에 따라서, 데이터는 적어도 하나의 로컬 메모리 뱅크 중 어느 하나에 저장될 수 있다. 반대로, 데이터가 L0 메모리에서 로드될 때, 아비터는 로컬 메모리 뱅크로부터 데이터를 수신하 여 스토어 엔진(113b)으로 전달될 수 있다. 스토어 엔진(113b)은 로컬 인터커넥션을 통해서 외부로 데이터 를 저장시킬 수 있다. 도 28은 도 27의 로컬 메모리 뱅크를 세부적으로 설명하기 위한 블록도이다. 도 28을 참조하면, 로컬 메모리 뱅크는 로컬 메모리 뱅크 컨트롤러(122_1) 및 로컬 메모리 뱅크 셀 어레이 (122_2)를 포함할 수 있다. 로컬 메모리 뱅크 컨트롤러(122_1)는 로컬 메모리 뱅크에 저장되는 데이터의 어드레스를 통해서 리드 및 라이트 동작을 관리할 수 있다. 즉, 로컬 메모리 뱅크 컨트롤러(122_1)는 데이터의 입출력을 전체적으로 관리할 수 있다. 로컬 메모리 뱅크 셀 어레이(122_2)는 데이터가 직접 저장되는 셀이 행과 열을 맞춰 정렬된 구조일 수 있다. 로 컬 메모리 뱅크 셀 어레이(122_2)는 로컬 메모리 뱅크 컨트롤러(122_1)에 의해서 제어될 수 있다. 도 29는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 구조를 세부적으로 설명하기 위한 블록도이다. 도 29를 참조하면, 뉴럴 코어는 뉴럴 코어와 달리 CGRA 구조일 수 있다. 뉴럴 코어는 인스트럭 션 메모리(111_1), CGRA L0 메모리(111_2), PE 어레이(111_3), LSU(Load/Store Unit)(111_4)를 포함할 수 있다. 인스트럭션 메모리(111_1)는 인스트럭션을 수신하여 저장할 수 있다. 인스트럭션 메모리(111_1)는 인스트럭션을 내부에 순차적으로 저장하고, 저장된 인스트럭션을 PE 어레이(111_3)로 제공할 수 있다. 이때, 인스트럭션은 각 PE 어레이(111_3)에 포함된 프로세싱 엘리먼트(111_3a)의 동작을 지시할 수 있다. CGRA L0 메모리(111_2)는 뉴럴 코어 내부에 위치한 메모리로서, 뉴럴 코어가 작업에 필요한 모든 입 력 데이터를 외부로부터 수신하여 임시로 저장할 수 있다. 또한, CGRA L0 메모리(111_2)는 뉴럴 코어에 의해서 연산된 출력 데이터를 외부로 전송하기 위해서 일시적으로 저장할 수 있다. CGRA L0 메모리(111_2)는 뉴럴 코어의 캐시 메모리 역할을 수행할 수 있다. CGRA L0 메모리(111_2)는 PE 어레이(111_3)와 데이터를 송수신할 수 있다. CGRA L0 메모리(111_2)는 L1 보다 낮은 L0(level 0)에 해당하는 메모리일 수 있다. 이때, L0 메모리는 공유되지 않는 뉴럴 코어의 전용 (private) 메모리일 수 있다. CGRA L0 메모리(111_2)는 액티베이션이나 웨이트 같은 데이터와 프로그램 등을 PE 어레이(111_3)로 전송할 수 있다. PE 어레이(111_3)는 연산을 수행하는 모듈일 수 있다. PE 어레이(111_3)는 1차원 연산뿐만 아니라 2차원 이상의 매트릭스/텐서 연산도 수행할 수 있다. PE 어레이(111_3)는 내부에 복수의 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)를 포함할 수 있다. 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 행과 열로 정렬될 수 있다. 프로세싱 엘리먼 트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 m 열로 정렬될 수 있다. 또한, 프로세싱 엘리먼트(111_3a)는 n 행으로 정렬되고, 특정 프로세싱 엘리먼트(111_3b)는 l행으로 정렬될 수 있다. 이에 따라서, 프로세싱 엘리먼 트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 (n+l)행과 m열로 정렬될 수 있다. LSU(111_4)는 로컬 인터커넥션을 통해서 외부에서 데이터, 제어 신호 및 동기화 신호 중 적어도 하나를 수 신할 수 있다. LSU(111_4)은 CGRA L0 메모리(111_2)로 수신한 데이터, 제어 신호 및 동기화 신호 중 적어도 하 나를 전송할 수 있다. 유사하게 LSU(111_4)는 로컬 인터커넥션을 통해서 데이터, 제어 신호 및 동기화 신 호 중 적어도 하나를 외부로 전달 수 있다. 뉴럴 코어는 CGRA(Coarse Grained Reconfigurable Architecture) 구조를 가질 수 있다. 이에 따라서, 뉴 럴 코어는 PE 어레이(111_3)의 각각의 프로세싱 엘리먼트(111_3a)와 특정 프로세싱 엘리먼트(111_3b)가 각 각 CGRA L0 메모리(111_2), 인스트럭션 메모리(111_1) 및 LSU(111_4) 중 적어도 하나와 연결될 수 있다. 즉, 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 CGRA L0 메모리(111_2), 인스트럭션 메모리 (111_1) 및 LSU(111_4)의 전부와 연결되어야 하는 것은 아니고 일부와 연결될 수도 있다. 또한, 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 서로 다른 종류의 프로세싱 소자일 수 있다. 이에 따라서, CGRA L0 메모리(111_2), 인스트럭션 메모리(111_1) 및 LSU(111_4) 중 프로세싱 엘리먼트 (111_3a)와 연결되는 소자와 특정 프로세싱 엘리먼트(111_3b)와 연결되는 소자는 서로 다를 수 있다. CGRA 구조를 가지는 본 발명의 뉴럴 코어는 높은 수준의 병렬 연산이 가능하고, 프로세싱 엘리먼트 (111_3a) 및 특정 프로세싱 엘리먼트(111_3b) 사이의 직접적인 데이터 교환이 가능하므로 전력 소모가 낮을 수 있다. 또한, 2개 이상의 종류의 프로세싱 엘리먼트(111_3a)를 포함하여 다양한 연산 작업에 따른 최적화도 가능 할 수 있다. 예를 들어, 프로세싱 엘리먼트(111_3a)가 2차원 연산을 수행하는 프로세싱 엘리먼트인 경우 특정 프로세싱 엘리 먼트(111_3b)는 1차원 연산을 수행하는 프로세싱 엘리먼트일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아 니다. 도 30은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템의 메모리 재구성을 설명하기 위한 블록도이다. 도 30을 참조하면, 뉴럴 코어 SoC은 제1 내지 제8 프로세싱 유닛(160a~160h) 및 온 칩 메모리(OCM)를 포함 할 수 있다. 도 34에서는 예시적으로 8개의 프로세싱 유닛을 도시하였으나, 이는 예시에 불과하고 프로세싱 유 닛의 개수는 얼마든지 달라질 수 있다. 온 칩 메모리(OCM)는 제1 내지 제8 L0 메모리(120a~120h) 및 공유 메모리를 포함할 수 있다. 제1 내지 제8 L0 메모리(120a~120h)는 각각 제1 내지 제8 프로세싱 유닛(160a~160h)의 전용 메모리로 사용될 수 있다. 즉, 제1 내지 제8 프로세싱 유닛(160a~160h)과 제1 내지 제8 L0 메모리(120a~120h)는 서로 1:1로 대응될 수 있다. 공유 메모리는 제1 내지 제8 메모리 유닛(2100a~2100h)을 포함할 수 있다. 제1 내지 제8 메모리 유닛 (2100a~2100h)은 제1 내지 제8 프로세싱 유닛(160a~160h) 및 제1 내지 제8 L0 메모리(120a~120h)에 각각 대응 할 수 있다. 즉, 메모리 유닛의 개수는 프로세싱 유닛 및 L0 메모리의 개수와 동일한 8개일 수 있다. 공유 메모리는 2가지 종류의 온 칩 메모리 형식 중 어느 하나로 동작할 수 있다. 즉, 공유 메모리 는 L0 메모리 형식 또는 글로벌 메모리 형식 중 어느 하나로 동작할 수 있다. 즉, 공유 메모리는 하나의하드웨어로 2가지의 논리적인(logical) 메모리를 구현할 수 있다. 공유 메모리가 L0 메모리 형식으로 구현되는 경우, 공유 메모리는 제1 내지 제8 L0 메모리 (120a~120h)와 같이 제1 내지 제8 프로세싱 유닛(160a~160h) 각각의 전용 메모리(private memory)로 동작할 수 있다. L0 메모리는 글로벌 메모리에 비해서 상대적으로 고속의 클럭으로 동작할 수 있고, 공유 메모리도 L0 메모리 형식으로 동작할 때 상대적으로 더 빠른 클럭을 사용할 수 있다. 공유 메모리가 글로벌 메모리 형식으로 구현되는 경우, 공유 메모리는 제1 프로세싱 유닛(100a) 및 제2 프로세싱 유닛(100b)이 서로 같이 사용하는 공용 메모리(common memory)로 동작할 수 있다. 이때, 공유 메 모리는 제1 내지 제8 프로세싱 유닛(160a~160h)뿐만 아니라 제1 내지 제8 L0 메모리(120a~120h)에 의해 서도 공유될 수 있다. 글로벌 메모리는 일반적으로 L0 메모리에 비해서 낮은 클럭을 사용할 수 있으나, 이에 제한되는 것은 아니다. 공유 메모리가 글로벌 메모리 형식으로 동작할 때는, 제1 내지 제8 프로세싱 유닛(160a~160h)이 공유 메 모리를 공유할 수 있다. 이때, 공유 메모리는 도 2의 휘발성 메모리와 글로벌 인터커넥션 을 통해서 연결되고, 휘발성 메모리의 버퍼로 동작할 수도 있다. 공유 메모리는 적어도 일부가 L0 메모리 형식으로 동작하고, 나머지가 글로벌 메모리 형식으로 동작할 수 있다. 즉, 공유 메모리 전체가 L0 메모리 형식으로 동작할 수도 있고, 공유 메모리 전체가 글로벌 메모리 형식으로 동작할 수도 있다. 또는, 공유 메모리의 일부가 L0 메모리 형식으로 동작하고, 나머지 일부가 글로벌 메모리 형식으로 동작할 수 있다. 도 31은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템의 메모리 재구성의 예시를 나타낸 블록도이다. 도 30 및 도 31을 참조하면, 제1, 제3, 제5 및 제7 프로세싱 유닛(100a, 100c, 100e, 100g) 각각의 제1, 제3, 제5 및 제7 전용 영역(AE1, AE3, AE5, AE7)은 각각 제1, 제3, 제5 및 제7 L0 메모리(120a, 120c, 120e, 120g) 만을 포함할 수 있다. 또한, 제2, 제4, 제6 및 제8 프로세싱 유닛(100b, 100d, 100f, 100h) 각각의 제2, 제4, 제6 및 제8 전용 영역(AE2, AE4, AE6, AE8)은 각각 제2, 제4, 제6 및 제8 L0 메모리(120b, 120d, 120f, 120h) 를 포함할 수 있다. 또한, 제2, 제4, 제6 및 제8 전용 영역(AE2, AE4, AE6, AE8)은 제2, 제4, 제6 및 제8 메모 리 유닛(2100b, 2100d, 2100f, 2100h)을 포함할 수 있다. 공유 메모리의 제1, 제3, 제5 및 제7 메모리 유닛(2100a, 2100c, 2100e, 2100g)은 공용 영역(AC)으로 활용될 수 있다. 공용 영역(AC)은 제1 내지 제8 프로세싱 유닛(160a~160h)에 의해서 공유되는 메모리일 수 있다. 제2 전용 영역 (AE2)은 제2 L0 메모리(120b)와 제2 메모리 유닛(2100b)을 포함할 수 있다. 제2 전용 영역(AE2)은 하드웨어적으 로 분리된 제2 L0 메모리(120b)와 제2 메모리 유닛(210b)이 같은 방식으로 동작하여 논리적으로 하나의 L0 메모 리로 동작하는 영역일 수 있다. 제4, 제6 및 제8 전용 영역(AE4, AE6, AE8)도 제2 전용 영역(AE2)과 같은 방식 으로 동작할 수 있다. 본 실시예에 따른 공유 메모리는 각 뉴럴 코어에 대응하는 영역을 최적화된 비율의 논리적인 L0 메모리와 논리적인 글로벌 메모리로 전환하여 사용할 수 있다. 공유 메모리는 이러한 비율의 조정을 런 타임(Run time)에서 수행할 수 있다. 즉, 각 뉴럴 코어는 서로 동일한 작업을 하는 경우도 있지만, 서로 상이한 작업을 하는 경우도 있을 수 있다. 이 경우 각 뉴럴 코어가 하는 작업에 필요한 L0 메모리의 용량과 글로벌 메모리의 용량은 매번 다를 수밖에 없 다. 이에 따라서, 기존의 온 칩 메모리와 같이 L0 메모리와 공유 메모리의 구성 비율이 고정적으로 설정되는 경 우에는 각 뉴럴 코어에게 할당되는 연산 작업에 따른 비효율이 발생할 수 있다. 따라서, 본 실시예에 따른 뉴럴 프로세싱 장치의 공유 메모리는 런 타임 중에 연산 작업에 따라서 최적의 L0 메모리 및 글로벌 메모리의 비율을 설정할 수 있고, 연산의 효율성 및 속도를 향상시킬 수 있다. 도 32는 도 30의 A부분을 확대한 블록도이다. 도 30 및 도 32를 참조하면, 공유 메모리는 제1 L0 메모리 컨트롤러(122_1a), 제2 L0 메모리 컨트롤러 (122_1b), 제5 L0 메모리 컨트롤러(122_1e), 제6 L0 메모리 컨트롤러(122_1f), 제1 내지 제8 메모리 유닛 (2100a~2100h) 및 글로벌 컨트롤러를 포함할 수 있다. 도시되지 않은 다른 L0 메모리 컨트롤러도 본 실시 예에 포함될 수 있으나 편의상 설명을 생략한다. 제1 L0 메모리 컨트롤러(122_1a)는 제1 L0 메모리(120a)를 제어할 수 있다. 또한, 제1 L0 메모리 컨트롤러 (122_1a)는 제1 메모리 유닛(2100a)을 제어할 수 있다. 구체적으로, 제1 메모리 유닛(2100a)이 논리적인 L0 메 모리 형식으로 구현될 때, 제1 L0 메모리 컨트롤러(122_1a)에 의한 제어가 제1 메모리 유닛(2100a)에 수행될 수 있다. 제2 L0 메모리 컨트롤러(122_1b)는 제2 L0 메모리(120b)를 제어할 수 있다. 또한, 제2 L0 메모리 컨트롤러 (122_1b)는 제2 메모리 유닛(2100b)을 제어할 수 있다. 즉, 제2 메모리 유닛(2100b)이 논리적인 L0 메모리 형식 으로 구현될 때, 제1 L0 메모리 컨트롤러(122_1a)에 의한 제어가 제2 메모리 유닛(2100b)에 수행될 수 있다. 제5 L0 메모리 컨트롤러(122_1e)는 제5 L0 메모리(120e)를 제어할 수 있다. 또한, 제5 L0 메모리 컨트롤러 (122_1e)는 제5 메모리 유닛(2100e)을 제어할 수 있다. 즉, 제5 메모리 유닛(2100e)이 논리적인 L0 메모리 형식 으로 구현될 때, 제5 L0 메모리 컨트롤러(122_1e)에 의한 제어가 제5 메모리 유닛(2100e)에 수행될 수 있다. 제6 L0 메모리 컨트롤러(122_1f)는 제6 L0 메모리(120f)를 제어할 수 있다. 또한, 제6 L0 메모리 컨트롤러 (122_1f)는 제6 메모리 유닛(2100f)을 제어할 수 있다. 즉, 제6 메모리 유닛(2100f)이 논리적인 L0 메모리 형식 으로 구현될 때, 제6 L0 메모리 컨트롤러(122_1f)에 의한 제어가 제6 메모리 유닛(2100f)에 수행될 수 있다. 글로벌 컨트롤러는 제1 내지 제8 메모리 유닛(2100a~2100h)을 모두 제어할 수 있다. 구체적으로, 글로벌 컨트롤러는 제1 내지 제8 메모리 유닛(2100a~2100h)이 각각 논리적으로 글로벌 메모리 형식으로 동작할 때(즉, 논리적으로 L0 메모리 형식으로 동작하지 않을 때), 제1 메모리 유닛(2100a) 내지 제8 메모리 유닛 (2100h)을 제어할 수 있다. 즉, 제1 내지 제8 메모리 유닛(2100a~2100h)은 논리적으로 어떤 형식의 메모리로 구현되느냐에 따라서 제1 내지 제8 L0 메모리 컨트롤러(122_1a~122_1h)에 의해 각각 제어되거나 글로벌 컨트롤러에 의해서 제어될 수 있 다. 제1, 제2, 제5 및 제6 L0 메모리 컨트롤러(122_1a, 122_1b, 122_1e, 122_1f)를 포함하는 L0 메모리 컨트롤러가 각각 제1 내지 제8 메모리 유닛(2100a~2100h)을 제어하는 경우, 제1 내지 제8 L0 메모리 컨트롤러 (122_1a~141h)는 제1 내지 제8 메모리 유닛(2100a~2100h)을 제1 내지 제8 L0 메모리(120a~120h)와 동일하게 제 어하므로, 제1 내지 제8 프로세싱 유닛(160a~160h)의 전용 메모리로 제어할 수 있다. 이에 따라서, 제1 내지 제 8 메모리 유닛(2100a~2100h)은 제1 내지 제8 프로세싱 유닛(160a~160h)의 클럭 주파수와 대응하는 클럭 주파수 로 동작할 수 있다. 제1 L0 메모리 컨트롤러(122_1a), 제2 L0 메모리 컨트롤러(122_1b), 제5 L0 메모리 컨트롤러(122_1e) 및 제6 L0 메모리 컨트롤러(122_1f)를 포함하는 L0 메모리 컨트롤러는 각각 도 7의 LSU을 포함할 수 있다. 글로벌 컨트롤러가 제1 내지 제8 메모리 유닛(2100a~2100h) 중 적어도 하나를 각각 제어하는 경우, 글로 벌 컨트롤러는 제1 내지 제8 메모리 유닛(2100a~2100h)을 각각 제1 내지 제8 프로세싱 유닛(160a~160h) 의 글로벌 메모리로 제어할 수 있다. 이에 따라서, 제1 내지 제8 메모리 유닛(2100a~2100h) 중 적어도 하나는 각각 제1 내지 제8 프로세싱 유닛(160a~160h)의 클럭 주파수와는 무관한 클럭 주파수로 동작할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 글로벌 컨트롤러는 제1 내지 제8 메모리 유닛(2100a~2100h)을 도 3의 글로벌 인터커넥션과 연결할 수 있다. 제1 내지 제8 메모리 유닛(2100a~2100h)은 글로벌 컨트롤러에 의해서 도 1의 오프 칩 메모리 와 데이터를 교환하거나, 제1 내지 제8 L0 메모리(120a~120h) 와 각각 데이터를 교환할 수 있다. 제1 내지 제8 메모리 유닛(2100a~2100h)은 각각 적어도 하나의 메모리 뱅크를 포함할 수 있다. 제1 메모리 유닛 (2100a)은 적어도 하나의 제1 메모리 뱅크(2110a)를 포함할 수 있다. 제1 메모리 뱅크(2110a)는 제1 메모리 유 닛(2100a)을 특정한 크기로 나눈 영역일 수 있다. 각각의 제1 메모리 뱅크(2110a)는 모두 동일한 크기의 메모리 소자일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 도 32에서는 4개의 메모리 뱅크가 하나의 메모리 유닛에 포함되는 것으로 도시되었다. 유사하게 제2, 제5 및 제6 메모리 유닛(2100b, 2100e, 2100f)는 각각 적어도 하나의 제2, 제5 및 제6 메모리 뱅 크(2110b, 2110e, 2110f)를 포함할 수 있다. 이하 제1 메모리 뱅크(2110a) 및 제5 메모리 뱅크(2110e)를 기준으로 설명하고, 이는 제2 및 제6 메모리 뱅크 (2110b, 2110f)를 포함한 다른 메모리 뱅크와 동일할 수 있다. 제1 메모리 뱅크(2110a)는 각각 논리적으로 L0 메모리 형식으로 동작하거나 논리적으로 글로벌 메모리 형식으로 동작할 수 있다. 이때, 제1 메모리 뱅크(2110a)는 제1 메모리 유닛(2100a) 내의 다른 메모리 뱅크와 독립적으로 동작할 수도 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 각 메모리 뱅크별로 독립적으로 동작하는 경우, 제1 메모리 유닛(2100a)은 제1 L0 메모리(120a)와 동일한 방식 으로 동작하는 제1 영역과, 제1 L0 메모리(120a)와 다른 방식으로 동작하는 제2 영역을 포함할 수 있다. 이때, 제1 영역과 제2 영역이 반드시 병존하는 것은 아니고 어느 하나의 영역이 전체 제1 메모리 유닛(2100a)의 전체 를 차지할 수도 있다. 마찬가지로, 제2 메모리 유닛(2100b)은 제2 L0 메모리(120b)와 동일한 방식으로 동작하는 제3 영역과, 제2 L0 메모리(120b)와 다른 방식으로 동작하는 제4 영역을 포함할 수 있다. 이때, 제3 영역과 제4 영역이 반드시 병존 하는 것은 아니고 어느 하나의 영역이 전체 제1 메모리 유닛(2100a)의 전체를 차지할 수도 있다. 이때, 제1 영역과 제2 영역의 비율은 제3 영역과 제4 영역의 비율과 상이할 수 있다. 단, 본 실시예가 이에 제 한되는 것은 아니다. 따라서, 제1 영역과 제2 영역의 비율은 제3 영역과 제4 영역의 비율과 동일할 수도 있다. 즉, 각 메모리 유닛에서의 메모리 구성 비율을 얼마든지 달라질 수 있다. 일반적으로 기존의 시스템 온 칩의 경우에는 고속의 L0 메모리를 제외한 온 칩 메모리를 고밀도 저전력 SRAM으 로 구성하는 경우가 많았다. 이는 필요한 용량 대비 칩의 면적과 사용 전력에서 SRAM이 높은 효율을 가지기 때 문이다. 그러나, 기존의 온 칩 메모리는 미리 결정된 L0 메모리의 용량보다 더 많은 데이터가 빠르게 필요한 작 업의 경우에는 처리 속도가 크게 느려질 수밖에 없었고, 글로벌 메모리의 필요가 크지 않은 경우에도 남아있는 글로벌 메모리를 활용할 방안이 전혀 없어 비효율이 발생하였다. 이에 반해서, 본 발명의 몇몇 실시예에 따른 공유 메모리는 경우에 따라서 각각 2개의 컨트롤러 중 어느 하나에 의해서 선택적으로 제어될 수 있다. 이때, 공유 메모리가 전체적으로 2개의 컨트롤러 중 정해진 어느 하나에 의해서만 제어되는 것은 아니고, 메모리 유닛 단위 또는 메모리 뱅크 단위로 독립적으로 제어될 수 있다. 이를 통해서, 본 실시예에 따른 공유 메모리는 연산 작업에 따른 최적의 메모리 구성 비율을 런 타임 중 에 획득하여 더 빠르고 효율적인 연산작업을 수행할 수 있다. 인공지능에 특화된 프로세싱 유닛의 경우 특정 어 플리케이션 단위로 L0 메모리와 글로벌 메모리의 필요한 크기가 달라질 수 있다. 나아가, 동일한 어플리케이션 이라도 딥러닝 네트워크를 사용하는 경우 각 층(layer) 별로 L0 메모리와 글로벌 메모리의 필요한 크기가 달라 질 수 있다. 본 실시예에 따른 공유 메모리는 각 층에 따른 연산 단계의 변화에도 메모리의 구성 비율이 런 타임 중에 변화될 수 있어 빠르고 효율적인 딥러닝 작업이 가능할 수 있다. 도 33은 도 32의 제1 메모리 뱅크를 세부적으로 설명하기 위한 도면이다. 도 33는 제1 메모리 뱅크(2110a)에 대 해서 도시하였지만, 다른 메모리 뱅크도 제1 메모리 뱅크(2110a)와 동일한 구조일 수 있다. 도 33을 참조하면, 제1 메모리 뱅크(2110a)는 셀 어레이(Ca), 뱅크 컨트롤러(Bc), 제1 경로 유닛(P1) 및 제2 경 로 유닛(P2)을 포함할 수 있다. 셀 어레이(Ca)는 내부에 복수의 메모리 소자(Cell)를 포함할 수 있다. 셀 어레이(Ca)는 복수의 메모리 소자가 격자 구조로 정렬되어 배치될 수 있다. 셀 어레이(Ca)는 예를 들어, SRAM(Static Random Access Memory) 셀 어 레이일 수 있다. 뱅크 컨트롤러(Bc)는 셀 어레이(Ca)를 제어할 수 있다. 뱅크 컨트롤러(Bc)는 셀 어레이(Ca)가 L0 메모리 형식으 로 동작할지, 아니면 글로벌 메모리 형식으로 동작할 지를 결정하고 그에 따라 셀 어레이(Ca)를 제어할 수 있다. 구체적으로, 뱅크 컨트롤러(Bc)는 런 타임 중에 제1 경로 유닛(P1) 방향으로 데이터를 송수신할지, 제2 경로 유 닛(P2) 방향으로 데이터를 송수신할지를 결정할 수 있다. 뱅크 컨트롤러(Bc)는 경로 컨트롤 신호(Spc)에 따라 데이터의 송수신 방향을 결정할 수 있다. 경로 컨트롤 신호(Spc)는 미리 설계된 장치 드라이버나 컴파일러에 의해서 생성될 수 있다. 경로 컨트롤 신호 (Spc)는 연산 작업의 특성에 따라서 생성될 수 있다. 또는, 경로 컨트롤 신호(Spc)는 사용자로부터 수신된 입력 에 의해서 생성될 수 있다. 즉, 사용자가 가장 최적의 메모리 구성 비율을 선택하기 위해서 경로 컨트롤 신호 (Spc)에 대한 입력을 직접 인가할 수 있다. 뱅크 컨트롤러(Bc)는 경로 컨트롤 신호(Spc)를 통해서 셀 어레이(Ca)에 저장된 데이터들의 송수신되는 경로를 결정할 수 있다. 뱅크 컨트롤러(Bc)가 데이터들이 송수신되는 경로를 결정하는 것에 따라 데이터들의 교환 인터 페이스가 달라질 수 있다. 즉, 뱅크 컨트롤러(Bc)가 제1 경로 유닛(P1)과 데이터를 교환하는 경우 제1 인터페이 스를 이용할 수 있고, 제2 경로 유닛(P2)과 데이터를 교환하는 경우 제2 인터페이스를 이용할 수 있다. 이때, 제1 인터페이스와 제2 인터페이스는 서로 다를 수 있다. 또한, 데이터가 저장되는 어드레스 체계도 달라질 수 있다. 즉, 특정 인터페이스를 선택하면 그에 대응하는 어 드레스 체계로 리드 및 라이트 동작이 수행될 수 있다. 뱅크 컨트롤러(Bc)는 특정 클럭 주파수로 동작할 수 있다. 예를 들어, 셀 어레이(Ca)가 SRAM 셀 어레이인 경우 에는 일반적인 SRAM의 동작 클럭 주파수로 뱅크 컨트롤러(Bc)가 동작할 수 있다. 제1 경로 유닛(P1)은 뱅크 컨트롤러(Bc)와 연결될 수 있다. 제1 경로 유닛(P1)은 셀 어레이(Ca)의 데이터를 제1 프로세싱 유닛(100a)과 직접 교환할 수 있다. 이때, “직접”이란 글로벌 인터커넥션을 거치지 않고 서로 교환됨을 의미할 수 있다. 즉, 제1 프로세싱 유닛(100a)은 제1 L0 메모리(120a)와 직접 데이터를 교환할 수 있 고, 제1 프로세싱 유닛(100a)은 공유 메모리가 논리적으로 L0 메모리 형식으로 구현되었을 때 제1 경로 유닛(P1)을 통해서 데이터를 교환할 수 있다. 제1 경로 유닛(P1)은 도 14의 제1 L0 메모리 컨트롤러(122_1a) 및 제2 L0 메모리 컨트롤러(122_1b)를 포함한 L0 메모리 컨트롤러를 포함할 수 있다. 제1 경로 유닛(P1)은 멀티 사이클 싱크 패스(Multi-Cycle Sync-Path)를 구성할 수 있다. 즉, 제1 경로 유닛 (P1)의 동작 클럭 주파수는 제1 프로세싱 유닛(100a)의 동작 클럭 주파수와 동일할 수 있다. 제1 L0 메모리 (120a)는 제1 프로세싱 유닛(100a)의 동작과 같은 속도로 빠르게 데이터를 교환하기 위해서 제1 프로세싱 유닛 (100a)의 동작 클럭 주파수와 동일한 클럭 주파수로 빠르게 데이터를 교환할 수 있다. 제1 경로 유닛(P1)도 동 일하게 제1 프로세싱 유닛(100a)의 동작 클럭 주파수와 동일한 클럭 주파수로 동작할 수 있다. 이때, 제1 경로 유닛(P1)의 동작 클럭 주파수는 뱅크 컨트롤러(Bc)의 동작 클럭 주파수의 배수(倍數)일 수 있다. 이 경우, 뱅크 컨트롤러(Bc)와 제1 경로 유닛(P1) 사이에 클럭의 동기화를 위한 CDC(Clock Domain Crossing) 작업이 따로 필요하지 않고, 이에 따라서 데이터 전송의 지연(delay)이 발생하지 않을 수 있다. 이에 따라서, 더 빠르고 효율적인 데이터 교환이 가능할 수 있다. 도 33에서는 예시적으로, 제1 경로 유닛(P1)의 동작 클럭 주파수는 1.5GHz일 수 있다. 이는 뱅크 컨트롤러(Bc) 의 750MHz의 2배의 주파수일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니고 뱅크 컨트롤러(Bc)의 클럭 주파수의 정수배로 제1 경로 유닛(P1)이 동작하는 경우라면 얼마든지 가능할 수 있다. 제2 경로 유닛(P2)은 뱅크 컨트롤러(Bc)와 연결될 수 있다. 제2 경로 유닛(P2)은 셀 어레이(Ca)의 데이터를 제1 프로세싱 유닛(100a)과 직접 교환하지 않고, 글로벌 인터커넥션을 통해서 교환할 수 있다. 즉, 제1 프로 세싱 유닛(100a)은 글로벌 인터커넥션 및 제2 경로 유닛(P2)을 통해서 셀 어레이(Ca)와 데이터를 교환할 수 있다. 이때, 셀 어레이(Ca)는 단순히 제1 프로세싱 유닛(100a)뿐만 아니라 다른 뉴럴 코어와도 데이터를 교 환할 수 있다. 즉, 제2 경로 유닛(P2)은 제1 메모리 뱅크(2110a)가 논리적으로 글로벌 메모리 형식으로 구현되었을 때 셀 어레 이(Ca)와 모든 뉴럴 코어와의 데이터 교환 경로일 수 있다. 제2 경로 유닛(P2)은 도 32의 글로벌 컨트롤러 를 포함할 수 있다. 제2 경로 유닛(P2)은 어싱크 패스(Async-Path)를 구성할 수 있다. 제2 경로 유닛(P2)의 동작 클럭 주파수는 글 로벌 인터커넥션의 동작 클럭 주파수와 동일할 수 있다. 제2 경로 유닛(P2)도 동일하게 글로벌 인터커넥 션의 동작 클럭 주파수와 동일한 클럭 주파수로 동작할 수 있다. 이때, 제2 경로 유닛(P2)의 동작 클럭 주파수는 뱅크 컨트롤러(Bc)의 동작 클럭 주파수와 서로 동기화되지 않을 수 있다. 이 경우, 뱅크 컨트롤러(Bc)와 제2 경로 유닛(P2) 사이에 클럭의 동기화를 위한 CDC(Clock Domain Crossing) 작업이 필요할 수 있다. 뱅크 컨트롤러(Bc)의 동작 클럭 주파수와 제2 경로 유닛(P2)의 동작 클럭 주 파수를 서로 동기화 시키지 않는 경우에는 클럭 도메인의 설계의 자유도가 높아질 수 있다. 따라서, 하드웨어 설계의 난이도가 낮아져 더욱 용이하게 하드웨어 동작을 도출할 수 있다. 뱅크 컨트롤러(Bc)는 제1 경로 유닛(P1)을 통해서 데이터를 교환하는 경우와 제2 경로 유닛(P2)을 통해서 데이 터를 교환하는 경우에 서로 다른 어드레스 체계를 이용할 수 있다. 즉, 뱅크 컨트롤러(Bc)는 제1 경로 유닛(P 1)을 통해서는 제1 어드레스 체계를 이용하고, 제2 경로 유닛(P2)을 통해서는 제2 어드레스 체계를 이용할 수 있다. 이때, 제1 어드레스 체계와 제2 어드레스 체계는 서로 다를 수 있다.뱅크 컨트롤러(Bc)는 반드시 메모리 뱅크별로 존재할 필요는 없다. 즉, 뱅크 컨트롤러(Bc)는 스케쥴링을 위한 부분이 아니라 신호를 전달하는 역할을 하므로, 2개의 포트를 가지는 각각의 메모리 뱅크에 필수적인 부분은 아 니다. 따라서, 하나의 뱅크 컨트롤러(Bc)가 여러 메모리 뱅크를 제어할 수 있다. 여러 메모리 뱅크는 뱅크 컨트 롤러(Bc)에 의해 제어되더라도 독립적으로 동작할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 물론, 뱅크 컨트롤러(Bc)는 각 메모리 뱅크별로 존재할 수도 있다. 이 경우, 뱅크 컨트롤러(Bc)가 각각의 메모 리 뱅크를 개별적으로 제어할 수 있다. 도 32 및 도 33을 참조하면, 제1 메모리 유닛(210a)이 제1 경로 유닛(P1)을 통해서 데이터를 교환하는 경우 제1 어드레스 체계를 사용하고, 제2 경로 유닛(P2)을 통해서 데이터를 교환하는 경우 제2 어드레스 체계를 사용할 수 있다. 유사하게, 제2 메모리 유닛(210b)이 제1 경로 유닛(P1)을 통해서 데이터를 교환하는 경우 제3 어드레 스 체계를 사용하고, 제2 경로 유닛(P2)을 통해서 데이터를 교환하는 경우 제2 어드레스 체계를 사용할 수 있다. 이때, 제1 어드레스 체계와 제3 어드레스 체계는 서로 동일할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 제1 어드레스 체계와 제3 어드레스 체계는 각각 제1 프로세싱 유닛(100a) 및 제2 프로세싱 유닛(100b)에 각각 전용으로 사용될 수 있다. 제2 어드레스 체계는 제1 프로세싱 유닛(100a) 및 제2 프로세싱 유닛(100b)에 공용으 로 적용될 수 있다. 도 33에서는 예시적으로, 제2 경로 유닛(P2)의 동작 클럭 주파수는 1GHz로 동작할 수 있다. 이는 뱅크 컨트롤러 (Bc)의 750MHz의 동작 클럭 주파수와 동기화 되지 않은 주파수일 수 있다. 즉, 제2 경로 유닛(P2)의 동작 클럭 주파수는 뱅크 컨트롤러(Bc)의 동작 클럭 주파수에 전혀 종속되지 않고 자유롭게 설정될 수 있다. 일반적인 글로벌 메모리는 느린 SRAM(예를 들어, 750MHz)과 그보다 빠른 글로벌 인터커넥션(예를 들어, 1GHz)를 이용하여 CDC 작업에 따른 지연이 발생할 수밖에 없었다. 이에 반해서, 본 발명의 몇몇 실시예들에 따른 공유 메모리는 제2 경로 유닛(P2) 외에도 제1 경로 유닛(P1)을 이용할 여지가 있어 CDC 작업에 따른 지연을 회 피할 수 있다. 또한, 일반적인 글로벌 메모리는 복수의 뉴럴 코어가 하나의 글로벌 인터커넥션을 이용하므로 데이터 전 송량이 동시에 발생하였을 때 전체적인 처리 속도의 저하가 쉽게 발생할 수 있다. 이에 반해서, 본 발명의 몇몇 실시예들에 따른 공유 메모리는 제2 경로 유닛(P2) 외에도 제1 경로 유닛(P1)을 이용할 여지가 있어 글로 벌 컨트롤러에 몰리는 데이터 처리량을 적절하게 분산하는 효과도 얻을 수 있다. 도 34는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 소프트웨어 계층 구조를 설명하기 위한 블록도 이다. 도 34를 참조하면, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 소프트웨어 계층 구조는 DL 프레임워 크, 컴파일러 스택 및 백엔드 모듈을 포함할 수 있다. DL 프레임워크는 사용자가 사용하는 딥러닝 모델 네트워크에 대한 프레임워크를 의미할 수 있다. 예를 들어, 텐서플로우나 파이토치와 같은 프로그램을 이용하여 학습이 완료된 뉴럴 네트워크가 생성될 수 있다. 컴파일러 스택은 어댑테이션 레이어, 컴퓨트 라이브러리, 프론트엔드 컴파일러, 백엔드 컴파일러 및 런타임 드라이버를 포함할 수 있다. 어댑테이션 레이어는 DL 프레임워크에 접하는 레이어일 수 있다. 어댑테이션 레이어는 DL 프레임워크에서 생성된 유저의 신경망 모델을 양자화시키고 그래프 수정을 할 수 있다. 또한, 어댑테이 션 레이어는 모델의 타입을 필요한 타입으로 변환시킬 수 있다. 프론트엔드 컴파일러는 어댑테이션 레이어에서 전달받은 다양한 신경망 모델 및 그래프를 일정한 중간 표현(intermediate representation, IR)으로 변환해줄 수 있다. 변환된 IR은 추후 백엔드 컴파일러 에서 다루기 쉬운 미리 설정된 표현일 수 있다. 이러한, 프론트엔드 컴파일러의 IR은 그래프 차원에서 미리 할 수 있는 최적화가 수행될 수 있다. 또한, 프론트엔드 컴파일러는 하드웨어에 최적화된 레이아웃으로 변환시키는 작업을 통해서 최종적으로 IR을 생성할 수 있다. 벡엔드 컴파일러는 프론트엔드 컴파일러에서 변환된 IR을 최적화하고 바이너리 파일로 변환하여 런타임 드라이버가 사용할 수 있게 한다. 백엔드 컴파일러는 하드웨어의 세부 사항에 맞는 스케일로 잡(job)을 분할하여 최적화된 코드를 생성할 수 있다. 컴퓨트 라이브러리는 여러가지 오퍼레이션 중에 하드웨어에 적합한 형태로 설계된 템플릿 오퍼레이션을 저장할 수 있다. 컴퓨트 라이브러리는 하드웨어가 필요한 여러 템플릿 오퍼레이션을 벡엔드 컴파일러 에 제공하여 최적화된 코드가 생성될 수 있게 한다. 런타임 드라이버는 구동 중에 계속해서 모니터링을 수행하여 본 발명의 몇몇 실시예들에 따른 뉴럴 네트 워크 장치의 구동을 수행할 수 있다. 구체적으로, 뉴럴 네트워크 장치의 인터페이스의 실행을 담당할 수 있다. 백엔드 모듈은 ASIC(Application Specific Integrated Circuit), FPGA(Field programmable gate array) 및 C-model을 포함할 수 있다. ASIC은 미리 결정된 설계 방식에 따라 결정 되는 하드웨어 칩을 의미할 수 있다. FPGA는 프로그래밍이 가능한 하드웨어 칩일 수 있다. C- model은 소프트웨어 상에 하드웨어를 모사하여 구현한 모델을 의미할 수 있다. 백엔드 모듈은 컴파일러 스택을 통해서 생성된 바이너리 코드를 이용하여 다양한 작업을 수행하 고 결과를 도출할 수 있다. 도 35는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치가 수행하는 딥 러닝 연산을 설명하기 위한 개념도 이다. 도 35를 참조하면, 인공신경망 모델은, 기계학습 모델의 일 예로서, 기계학습(Machine Learning) 기술과 인지과학에서, 생물학적 신경망의 구조에 기초하여 구현된 통계학적 학습 알고리즘 또는 그 알고리즘을 실행하 는 구조이다. 인공신경망 모델은, 생물학적 신경망에서와 같이 시냅스의 결합으로 네트워크를 형성한 인공 뉴런인 노 드(Node)들이 시냅스의 웨이트를 반복적으로 조정하여, 특정 입력에 대응한 올바른 출력과 추론된 출력 사이의 오차가 감소되도록 학습함으로써, 문제 해결 능력을 가지는 기계학습 모델을 나타낼 수 있다. 예를 들어, 인공 신경망 모델은 기계 학습, 딥러닝 등의 인공지능 학습법에 사용되는 임의의 확률 모델, 뉴럴 네트워크 모델 등을 포함할 수 있다. 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 이러한 인공신경망 모델의 형태를 구현하여 연산 을 수행할 수 있다. 예를 들어, 인공신경망 모델은 입력 영상을 수신하고, 입력 영상에 포함된 대상의 적어도 일부에 대한 정보를 출력할 수 있다. 인공신경망 모델은 다층의 노드들과 이들 사이의 연결로 구성된 다층 퍼셉트론(MLP: multilayer perceptron)으로 구현된다. 본 실시예에 따른 인공신경망 모델은 MLP를 포함하는 다양한 인공신경망 모 델 구조들 중의 하나를 이용하여 구현될 수 있다. 도 35에 도시된 바와 같이, 인공신경망 모델은, 외부 로부터 입력 신호 또는 데이터를 수신하는 입력층, 입력 데이터에 대응한 출력 신호 또는 데이터 를 출력하는 출력층, 입력층과 출력층 사이에 위치하며 입력층으로부터 신 호를 받아 특성을 추출하여 출력층으로 전달하는 n개(여기서, n은 양의 정수)의 은닉층(42000 내지 43000)으로 구성된다. 여기서, 출력층은 은닉층(42000 내지 43000)으로부터 신호를 받아 외부로 출력한 다. 인공신경망 모델의 학습 방법에는, 교사 신호(정답)의 입력에 의해서 문제의 해결에 최적화되도록 학습 하는 지도 학습(Supervised Learning) 방법과, 교사 신호를 필요로 하지 않는 비지도 학습(Unsupervised Learning) 방법이 있다. 뉴럴 프로세싱 장치는 인공신경망 모델을 학습시키기 위한 학습 데이터를 시뮬레이션을 통해 직접 생성 할 수 있다. 이와 같이, 인공신경망 모델의 입력층과 출력층에 복수의 입력변수와 대응되 는 복수의 출력변수가 각각 매칭되고, 입력층, 은닉층(42000 내지 43000) 및 출력층에 포함된 노 드들 사이의 시냅스 값이 조정됨으로써, 특정 입력에 대응한 올바른 출력이 추출될 수 있도록 학습될 수 있다. 이러한 학습 과정을 통해, 인공신경망 모델의 입력변수에 숨겨져 있는 특성을 파악할 수 있고, 입력변수 에 기초하여 계산된 출력변수와 목표 출력 간의 오차가 줄어들도록 인공신경망 모델의 노드들 사이의 시 냅스 값(또는 웨이트)을 조정할 수 있다. 도 36은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 뉴럴 네트워크의 학습 및 추론 동작을 설명하기 위한 개념도이다.도 36을 참조하면, 학습 과정(Training Phase)에서는 다수의 학습 자료(TD)들이 인공신경망 모델(NN)로 포워딩 되고, 다시 백워딩되는 과정을 거칠 수 있다. 이를 통해서 인공신경망 모델(NN)의 각 노드의 웨이트와 바이어스 들이 조율되고 이를 통해서 점점 더욱 정확한 결과를 도출할 수 있게 학습이 수행될 수 있다. 이렇게 학습 과정 (Training Phase)을 통해서 인공신경망 모델(NN)은 학습된 신경망 모델(NN_T)로 변환될 수 있다. 추론 과정(Inference Phase)에서는 새로운 데이터(ND)가 다시 학습된 신경망 모델(NN_T)로 입력될 수 있다. 학 습된 신경망 모델(NN_T)은 새로운 데이터(ND)를 입력으로 하여 이미 학습된 웨이트와 바이어스를 통해서 결과 데이터(RD)를 도출할 수 있다. 이러한 결과 데이터(RD)는 학습 과정(Training Phase)에서 어떤 학습 자료(TD)로 학습하였는지와, 얼마나 많은 학습 자료(TD)를 이용하였는지가 중요할 수 있다. 도 37은 본 발명의 몇몇 실시예에 따른 프로세싱 엘리먼트를 이용하여, 곱셈 연산을 수행하는 방법을 설명하기 위한 도면이다. 설명의 편의를 위해 전술한 내용과 동일하거나 유사한 내용은 생략하거나 간단히 설명한다. 도 11 및 도 37을 참조하면, 패스 결정 유닛(PDU)은 웨이트(Weight) 및 인풋 액티베이션(Act_In)을 수신할 수 있다. 또한, 패스 결정 유닛(PDU)은 연산 모드 신호(Mode)를 수신할 수 있다(S100). 웨이트(Weight)를 분할하여, 복수의 분할 웨이트(D_W)를 생성할 수 있다(S110). 몇몇 실시예에 따르면, 패스 결 정 유닛(PDU)은 제1 프리시젼(Pr1)의 단위로 웨이트(Weight)를 분할하여, 복수의 분할 웨이트(D_W)를 생성할 수 있다. 예를 들어, 웨이트(Weight)가 32-비트 데이터일 때, 패스 결정 유닛(PDU)은 웨이트(Weight)를 4-비트 단 위로 분할하여, 8개의 분할 웨이트(D_W)를 생성할 수 있다. 또한, 인풋 액티베이션(Act_In)을 분할하여, 복수의 분할 인풋 액티베이션(D_A)을 생성할 수 있다(S120). 몇몇 실시예에 따르면, 패스 결정 유닛(PDU)은 제1 프리시젼(Pr1)의 단위로 인풋 액티베이션(Act_In)을 분할하여, 복 수의 분할 인풋 액티베이션(D_A)을 생성할 수 있다. 예를 들어, 인풋 액티베이션(Act_In)이 32-비트 데이터일 때, 패스 결정 유닛(PDU)은 인풋 액티베이션(Act_In)을 4-비트 단위로 분할하여, 8개의 분할 인풋 액티베이션 (D_A)을 생성할 수 있다. 연산 모드 신호(Mode)에 따라, 복수의 분할 웨이트(D_W) 및 복수의 분할 인풋 액티베이션(D_A)이 제공될 멀티플 라이어를 결정할 수 있다(S130). 몇몇 실시예에 따르면, 연산 모드 신호(Mode)가 제1 모드 신호(Mode(Pr1))인 경우, 패스 결정 유닛(PDU)은 제1 패스 결정 신호(PD1)를 생성하고, 생성된 제1 패스 결정 신호(PD1)를 디멀티 플렉서(Dx)에 제공할 수 있다. 디멀티플렉서(Dx)는 제1 패스 결정 신호(PD1)에 따라, 복수의 분할 웨이트(D_W) 및 복수의 분할 인풋 액티베이션(D_A)을 제1 멀티플라이어(Mul1)에 제공할 수 있다. 만약, 연산 모드 신호 (Mode)가 제2 모드 신호(Mode(Pr2))인 경우, 패스 결정 유닛(PDU)은 제2 패스 결정 신호(PD2)를 생성하고, 생성 된 제2 패스 결정 신호(PD2)를 디멀티플렉서(Dx)에 제공할 수 있다. 디멀티플렉서(Dx)는 제2 패스 결정 신호 (PD2)에 따라, 복수의 분할 웨이트(D_W) 및 복수의 분할 인풋 액티베이션(D_A)의 일부를 제1 멀티플라이어 (Mul1)에 제공하고, 다른 일부를 제2 멀티플라이어(Mul2)에 제공할 수 있다. 복수의 분할 웨이트(D_W) 및 복수의 분할 인풋 액티베이션(D_A)을 연산하여 복수의 부분곱 그룹을 생성할 수 있 다(S140). 몇몇 실시예에 따르면, 제1 멀티플라이어(Mul1) 및/또는 제2 멀티플라이어(Mul2)는 복수의 분할 웨이 트(D_W) 및 복수의 분할 인풋 액티베이션(D_A)을 연산하여, 복수의 부분곱 그룹을 생성할 수 있다. 연산 모드 신호(Mode)가 제1 모드 신호(Mode(Pr1))인 경우(S150, Y), 복수의 부분곱 그룹을 이용하여 제1 결과 데이터를 생성할 수 있다(S160). 몇몇 실시예에 따르면, 제1 부스 리덕션 트리(BRT1)는 복수의 부분곱 그룹에 대한 뎁스를 감소시켜, 복수의 변형 부분곱 그룹을 생성하고, 복수의 변형 부분곱 그룹에 대해 덧셈 연산을 수 행하여, 제1 결과 데이터를 생성할 수 있다. 연산 모드 신호(Mode)가 제2 모드 신호(Mode(Pr2))인 경우(S150, N), 복수의 부분곱 그룹을 정렬하여 복수의 정 렬 부분곱 그룹을 생성할 수 있다(S170). 몇몇 실시예에 따르면, 얼라이너(ALNR)는 복수의 부분곱 그룹을 자릿 수를 기초로 정렬하여, 복수의 정렬 부분곱 그룹을 생성할 수 있다. 이어서, 복수의 정렬 부분곱 그룹을 독립적으로 연산하여, 제1 결과 데이터 및 제2 결과 데이터를 생성할 수 있 다(S180). 몇몇 실시예에 따르면, 얼라이너(ALNR)는 복수의 정렬 부분곱 그룹 중 뎁스가 가장 큰 정렬 부분곱 그룹을 제1 부스 리덕션 트리(BRT1)에 제공하고, 나머지 정렬 부분곱 그룹을 제2 부스 리덕션 트리(BRT2)에 제 공할 수 있다. 제1 부스 리덕션 트리(BRT1)와 제2 부스 리덕션 트리(BRT2)는 병렬적으로/독립적으로 연산을 수 행하여, 각각 제1 결과 데이터와 제2 결과 데이터를 생성할 수 있다. 이상의 설명은 본 실시예의 기술 사상을 예시적으로 설명한 것에 불과한 것으로서, 본 실시예가 속하는 기술 분 야에서 통상의 지식을 가진 자라면 본 실시예의 본질적인 특성에서 벗어나지 않는 범위에서 다양한 수정 및 변 형이 가능할 것이다. 따라서, 본 실시예들은 본 실시예의 기술 사상을 한정하기 위한 것이 아니라 설명하기 위 한 것이고, 이러한 실시예에 의하여 본 실시예의 기술 사상의 범위가 한정되는 것은 아니다. 본 실시예의 보호 범위는 아래의 청구범위에 의하여 해석되어야 하며, 그와 동등한 범위 내에 있는 모든 기술 사상은 본 실시예의 권리범위에 포함되는 것으로 해석되어야 할 것이다."}
{"patent_id": "10-2022-0066221", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템을 설명하기 위한 블록도이다. 도 2는 도 1의 뉴럴 프로세싱 장치를 세부적으로 설명하기 위한 블록도이다. 도 3은 도 2의 뉴럴 코어 SoC를 세부적으로 설명하기 위한 블록도이다. 도 4는 도 3의 글로벌 인터커넥션을 세부적으로 설명하기 위한 구조도이다. 도 5는 도 3의 뉴럴 프로세서를 세부적으로 설명하기 위한 블록도이다. 도 6은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 계층적 구조를 설명하기 위한 도면이다. 도 7은 도 5의 뉴럴 코어를 세부적으로 설명하기 위한 블록도이다. 도 8는 도 7의 LSU을 세부적으로 설명하기 위한 블록도이다. 도 9는 도 7의 프로세싱 유닛을 세부적으로 설명하기 위한 블록도이다. 도 10은 도 9의 프로세싱 엘리먼트를 세부적으로 설명하기 위한 블록도이다. 도 11은 도 10의 플렉서블 멀티플라이어를 세부적으로 설명하기 위한 블록도이다. 도 12는 연산 모드 신호가 제1 모드 신호인 경우, 본 발명의 몇몇 실시예들에 따른 플렉서블 멀티플라이어의 동 작을 설명하기 위한 도면이다. 도 13은 본 발명의 몇몇 실시예들에 따른 제1 멀티플라이어가 부스 알고리즘을 이용하여 분할 웨이트 및 분할 인풋 액티베이션을 연산하는 과정을 설명하기 위한 도면이다. 도 14 및 도 15는 본 발명의 몇몇 실시예에 따른 제1 부분곱 그룹 내지 제16 부분곱 그룹의 뎁스를 감소시키는 과정을 설명하기 위한 도면이다. 도 16은 연산 모드 신호가 제2 모드 신호인 경우, 본 발명의 몇몇 실시예들에 따른 플렉서블 멀티플라이어의 동 작을 설명하기 위한 도면이다. 도 17 내지 도 21은 8-비트 데이터의 곱셈 연산을 4-비트 데이터의 곱셈 연산으로 변환하여 연산하는 과정에 대 해 설명한다. 도 22 내지 도 25는 제1 정렬 부분곱 그룹 내지 제5 정렬 부분곱 그룹을 설명하기 위한 도면이다. 도 26은 본 발명의 다른 몇몇 실시예에 따른 플렉서블 멀티플라이어의 구성을 설명하기 위한 도면이다. 도 27은 도 7의 L0 메모리를 세부적으로 설명하기 위한 블록도이다. 도 28은 도 27의 로컬 메모리 뱅크를 세부적으로 설명하기 위한 블록도이다. 도 29는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 구조를 세부적으로 설명하기 위한 블록도이다. 도 30은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템의 메모리 재구성을 설명하기 위한 블록도이다. 도 31은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템의 메모리 재구성의 예시를 나타낸 블록도이다. 도 32는 도 30의 A부분을 확대한 블록도이다. 도 33은 도 32의 제1 메모리 뱅크를 세부적으로 설명하기 위한 도면이다. 도 34는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 소프트웨어 계층 구조를 설명하기 위한 블록도 이다. 도 35는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치가 수행하는 딥 러닝 연산을 설명하기 위한 개념도 이다. 도 36은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 뉴럴 네트워크의 학습 및 추론 동작을 설명하기 위한 개념도이다. 도 37은 본 발명의 몇몇 실시예에 따른 프로세싱 엘리먼트를 이용하여, 곱셈 연산을 수행하는 방법을 설명하기 위한 도면이다."}
