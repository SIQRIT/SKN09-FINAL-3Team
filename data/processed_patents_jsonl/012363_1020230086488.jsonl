{"patent_id": "10-2023-0086488", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0006554", "출원번호": "10-2023-0086488", "발명의 명칭": "화면 이미지 처리를 사용하여 소프트웨어의 기능점수를 산출하는 방법 및 장치", "출원인": "삼성에스디에스 주식회사", "발명자": "홍정환"}}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨팅 장치에 의해 수행되는 소프트웨어의 기능점수를 산출하는 방법에 있어서,대상 소프트웨어가 제공하는 사용자 기능에 대응하는 화면 이미지 및 URL을 수집하되, 상기 수집된 화면 이미지의 해시 값은 블록체인 네트워크에 저장되는, 단계;상기 수집된 화면 이미지의 레이블을 인식하는 단계;상기 수집된 URL에 의해 실행되는 SQL 구문을 분석하여 데이터 테이블을 확인하는 단계;상기 확인된 데이터 테이블 및 상기 레이블 인식 결과를 비교하여 데이터 테이블을 결정하는 단계;상기 결정된 데이터 테이블에 기반하여 데이터 기능점수를 산출하는 단계;상기 결정된 데이터 테이블에 기반하여 트랜잭션 기능점수를 산출하는 단계; 및상기 데이터 기능점수 및 상기 트랜잭션 기능점수에 기반하여 상기 대상 소프트웨어의 기능점수를 산출하는 단계를 포함하는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 수집된 화면 이미지의 레이블을 인식하는 단계는:상기 수집된 화면 이미지의 해시 값의 변화 여부를 통해 상기 수집된 화면 이미지의 변화를 판단하는 단계; 및상기 수집된 화면 이미지에 변화가 있는 경우, 상기 수집된 화면 이미지의 변화에 응답하여, 상기 수집된 화면이미지의 레이블을 인식하는 단계를 포함하고,상기 레이블은 버튼의 레이블과 데이터 테이블 컬럼의 레이블을 포함하는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 2 항에 있어서,상기 수집된 화면 이미지의 레이블은 CNN(Convolutional Neural Network) 또는 RNN(Recurrent Neural Network)중 어느 하나를 사용하여 인식되는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 SQL 구문을 분석하여 데이터 테이블을 확인하는 단계는:상기 수집된 URL의 호출 정보에 기반하여 상기 대상 소프트웨어 내 복수의 클래스 간 호출 관계를 확인하는 단계;상기 호출 관계가 확인된 복수의 클래스의 입력 파라미터 정보를 획득하는 단계; 및상기 획득한 입력 파라미터 정보에 기반하여 상기 SQL 구문과 연관된 상기 데이터 테이블을 확인하는 단계를 포함하는,공개특허 10-2025-0006554-3-소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4 항에 있어서,상기 입력 파라미터 정보는 상기 복수의 클래스의 메소드, 상기 메소드의 입력 파라미터, 및 상기 입력 파라미터를 통해 반환되는 출력 값을 포함하는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 5 항에 있어서,상기 데이터 테이블의 컬럼은 상기 반환되는 출력 값에 대응하는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서,상기 데이터 테이블을 결정하는 단계는:상기 확인된 데이터 테이블의 각 컬럼과 상기 인식된 레이블을 비교하는 단계; 및상기 비교 결과 상기 확인된 데이터 테이블로부터 상기 인식된 레이블과 일치하지 않는 컬럼을 삭제하는 단계를포함하는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1 항에 있어서,상기 데이터 기능점수를 산출하는 단계는:상기 대상 소프트웨어의 데이터 기능의 유형을 식별하는 단계;상기 데이터 기능의 RET 수 및 DET 수를 결정하는 단계;상기 데이터 기능의 상기 유형, 상기 RET 수, 및 상기 DET 수에 기반하여 상기 데이터 기능의 가중치를 결정하는 단계; 및상기 가중치에 기반하여 상기 데이터 기능점수를 산출하는 단계를 포함하는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 8 항에 있어서,상기 데이터 기능의 상기 유형은 내부 논리 파일(Internal Logical File; ILF) 및 외부 연계 파일(ExternalInterface File; EIF) 중 어느 하나이고,상기 데이터 기능의 상기 유형은 상기 결정된 데이터 테이블에 기초하여 상기 대상 소프트웨어의 기능 요소와데이터 요소 간 CRUD 관계를 결정함으로써 식별되는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 1 항에 있어서,상기 트랜잭션 기능점수를 산출하는 단계는:공개특허 10-2025-0006554-4-상기 대상 소프트웨어의 트랜잭션 기능의 유형을 식별하는 단계;상기 트랜잭션 기능의 FTR 수 및 DET 수를 결정하는 단계;상기 트랜잭션 기능의 상기 유형, 상기 FTR 수, 및 상기 DET 수에 기반하여 상기 트랜잭션 기능의 가중치를 결정하는 단계; 및상기 가중치에 기반하여 상기 트랜잭션 기능점수를 산출하는 단계를 포함하는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 10 항에 있어서,상기 트랜잭션 기능의 상기 유형은 외부 입력(External Input; EI), 외부 출력(External Output; EO), 및 외부조회(External inQuiry; EQ) 중 어느 하나이고,상기 트랜잭션 기능의 상기 유형은 상기 결정된 데이터 테이블에 기초하여 상기 대상 소프트웨어의 기능 요소와데이터 요소 간 CRUD 관계를 결정함으로써 식별되는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 1 항에 있어서,상기 대상 소프트웨어의 기능점수를 산출하는 단계는 상기 데이터 기능점수 및 상기 트랜잭션 기능점수를 합산하는 단계를 포함하는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 1 항에 있어서,그래픽 사용자 인터페이스를 이용하여 상기 대상 소프트웨어의 상기 기능점수를 표시하는 단계를 더 포함하고,상기 그래픽 사용자 인터페이스는 상기 수집된 URL에 기반하여 도출된 상기 대상 소프트웨어의 클래스 간 의존관계 그래프를 포함하는,소프트웨어의 기능점수를 산출하는 방법."}
{"patent_id": "10-2023-0086488", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "소프트웨어의 기능점수를 산출하는 장치에 있어서,하나 이상의 인스트럭션들(instructions)을 저장하는 메모리;블록체인 네트워크와 통신하는 통신 인터페이스; 및상기 하나 이상의 인스트럭션들을 실행함으로써,대상 소프트웨어가 제공하는 사용자 기능에 대응하는 화면 이미지 및 URL을 수집하고, 상기 수집된 화면 이미지의 레이블을 인식하고, 상기 수집된 URL에 의해 실행되는 SQL 구문을 분석하여 데이터 테이블을 확인하고, 상기확인된 데이터 테이블 및 상기 레이블 인식 결과를 비교하여 데이터 테이블을 결정하고, 상기 결정된 데이터 테이블에 기반하여 데이터 기능점수를 산출하고, 상기 결정된 데이터 테이블에 기반하여 트랜잭션 기능점수를 산출하고, 상기 데이터 기능점수 및 상기 트랜잭션 기능점수에 기반하여 상기 대상 소프트웨어의 기능점수를 산출하는 프로세서를 포함하되,상기 수집된 화면 이미지의 해시 값은 상기 블록체인 네트워크에 저장되는,소프트웨어의 기능점수를 산출하는 장치.공개특허 10-2025-0006554-5-"}
{"patent_id": "10-2023-0086488", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 개시의 실시 예에 따른 소프트웨어의 기능점수를 산출하는 방법은 컴퓨팅 장치에 의해 수행되고, 대상 소프트 웨어가 제공하는 사용자 기능에 대응하는 화면 이미지 및 URL을 수집하되, 상기 수집된 화면 이미지의 해시 값은 블록체인 네트워크에 저장되는, 단계, 상기 수집된 화면 이미지의 레이블을 인식하는 단계, 상기 수집된 URL에 의해 실행되는 SQL 구문을 분석하여 데이터 테이블을 확인하는 단계, 상기 확인된 데이터 테이블 및 상기 레이블 인식 결과를 비교하여 데이터 테이블을 결정하는 단계, 상기 결정된 데이터 테이블에 기반하여 데이터 기능점수 를 산출하는 단계, 상기 결정된 데이터 테이블에 기반하여 트랜잭션 기능점수를 산출하는 단계, 및 상기 데이터 기능점수 및 상기 트랜잭션 기능점수에 기반하여 상기 대상 소프트웨어의 기능점수를 산출하는 단계를 포함할 수 있다."}
{"patent_id": "10-2023-0086488", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 화면 이미지 처리를 사용하여 소프트웨어의 기능점수를 산출하는 방법 및 장치에 관한 것으로, 좀 더 상세하게는 화면 이미지 상의 레이블 인식을 통해 URL 기반 기능점수 산출의 정확도를 향상시키는 방법 및 장치 에 관한 것이다."}
{"patent_id": "10-2023-0086488", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "기능점수(function point; FP)는 소프트웨어의 규모 및 복잡도를 기능별로 점수화하여 수치적으로 소프트웨어 개발에 필요한 인력 및 기간을 산정하는데 사용되는 점수이다. 기능점수는 기존의 프로그램 스텝 수에 의한 SW 가격 산정 방식을 개선한 방식으로, 소프트웨어 비교를 위한 하나의 공통 기준이 되고 있다. 종래의 기능점수 산출 방법 중 하나는 수작업으로 소스 코드를 체크하여 데이터 기능 및 트랜잭션 기능을 집계 하는 방법이다. 이 방법은 수백만, 수천만 소스 코드 라인을 수동으로 전부 체크하여야 하므로 기능점수 산출에 너무 많은 시간과 리소스가 소요되는 문제가 있다. 종래의 기능점수 산출 방법 중 또 다른 하나는 정적인 소스 코드를 기반으로 의존성(dependency)를 분석하여 기능점수를 산출하는 방법이다. 이 방법은 수동 집계 방법에 비해 시간과 리소스 소모는 적으나, 사용하지 않는 불용 코드까지 기능점수 산정에 반영되어 결과가 정확하지 않은 단점이 있으며 시스템의 초기 설정에 많이 시간이 걸리는 문제점이 있다. 이에 따라, 보다 효율적이고 정 확하게 소프트웨어의 기능점수를 산출하는 솔루션이 요구되는 실정이다. 선행기술문헌 특허문헌 (특허문헌 0001) 등록특허공보 제10-1705465호 (공고일자 2017.02.09)"}
{"patent_id": "10-2023-0086488", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시의 실시 예에 따라 해결하고자 하는 기술적 과제는, 소프트웨어 기능점수 산출의 정확도를 향상시키기 위한 것으로, 소프트웨어 화면 이미지에 대해 인공지능 모델을 적용하여 레이블을 인식하고, URL 수집을 통해 SQL 구문을 분석한 결과 확인된 데이터 테이블에 대해 레이블 인식 결과를 맵핑하여 데이터 기능점수 및 트랜잭 션 기능점수를 계산함으로써 소프트웨어 기능점수를 산출하기 위한 것이다."}
{"patent_id": "10-2023-0086488", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시의 실시 예에 따른 소프트웨어의 기능점수를 산출하는 방법은 컴퓨팅 장치에 의해 수행되고, 대상 소프 트웨어가 제공하는 사용자 기능에 대응하는 화면 이미지 및 URL을 수집하되, 상기 수집된 화면 이미지의 해시 값은 블록체인 네트워크에 저장되는, 단계, 상기 수집된 화면 이미지의 레이블을 인식하는 단계, 상기 수집된 URL에 의해 실행되는 SQL 구문을 분석하여 데이터 테이블을 확인하는 단계, 상기 확인된 데이터 테이블 및 상기 레이블 인식 결과를 비교하여 데이터 테이블을 결정하는 단계, 상기 결정된 데이터 테이블에 기반하여 데이터 기능점수를 산출하는 단계, 상기 결정된 데이터 테이블에 기반하여 트랜잭션 기능점수를 산출하는 단계, 및 상 기 데이터 기능점수 및 상기 트랜잭션 기능점수에 기반하여 상기 대상 소프트웨어의 기능점수를 산출하는 단계 를 포함할 수 있다. 일 실시 예에서, 상기 수집된 화면 이미지의 레이블을 인식하는 단계는, 상기 수집된 화면 이미지의 해시 값의 변화 여부를 통해 상기 수집된 화면 이미지의 변화를 판단하는 단계, 및 상기 수집된 화면 이미지에 변화가 있 는 경우, 상기 수집된 화면 이미지의 변화에 응답하여, 상기 수집된 화면 이미지의 레이블을 인식하는 단계를 포함하고, 상기 레이블은 버튼의 레이블과 데이터 테이블 컬럼의 레이블을 포함할 수 있다. 일 실시 예에서, 상기 수집된 화면 이미지의 레이블은 CNN(Convolutional Neural Network) 또는 RNN(Recurrent Neural Network) 중 어느 하나를 사용하여 인식될 수 있다.일 실시 예에서, 상기 SQL 구문을 분석하여 데이터 테이블을 확인하는 단계는, 상기 수집된 URL의 호출 정보에 기반하여 상기 대상 소프트웨어 내 복수의 클래스 간 호출 관계를 확인하는 단계, 상기 호출 관계가 확인된 복 수의 클래스의 입력 파라미터 정보를 획득하는 단계, 및 상기 획득한 입력 파라미터 정보에 기반하여 상기 SQL 구문과 연관된 상기 데이터 테이블을 확인하는 단계를 포함할 수 있다. 일 실시 예에서, 상기 입력 파라미터 정보는 상기 복수의 클래스의 메소드, 상기 메소드의 입력 파라미터, 및 상기 입력 파라미터를 통해 반환되는 출력 값을 포함할 수 있다. 일 실시 예에서, 상기 데이터 테이블의 컬럼은 상기 반환되는 출력 값에 대응할 수 있다. 일 실시 예에서, 상기 데이터 테이블을 결정하는 단계는, 상기 확인된 데이터 테이블의 각 컬럼과 상기 인식된 레이블을 비교하는 단계, 및 상기 비교 결과 상기 확인된 데이터 테이블로부터 상기 인식된 레이블과 일치하지 않는 컬럼을 삭제하는 단계를 포함할 수 있다. 일 실시 예에서, 상기 데이터 기능점수를 산출하는 단계는, 상기 대상 소프트웨어의 데이터 기능의 유형을 식별 하는 단계, 상기 데이터 기능의 RET 수 및 DET 수를 결정하는 단계, 상기 데이터 기능의 상기 유형, 상기 RET 수, 및 상기 DET 수에 기반하여 상기 데이터 기능의 가중치를 결정하는 단계, 및 상기 가중치에 기반하여 상기 데이터 기능점수를 산출하는 단계를 포함할 수 있다. 일 실시 예에서, 상기 데이터 기능의 상기 유형은 내부 논리 파일(Internal Logical File; ILF) 및 외부 연계 파일(External Interface File; EIF) 중 어느 하나이고, 상기 데이터 기능의 상기 유형은 상기 결정된 데이터 테이블에 기초하여 상기 대상 소프트웨어의 기능 요소와 데이터 요소 간 CRUD 관계를 결정함으로써 식별될 수 있다. 일 실시 예에서, 상기 트랜잭션 기능점수를 산출하는 단계는, 상기 대상 소프트웨어의 트랜잭션 기능의 유형을 식별하는 단계, 상기 트랜잭션 기능의 FTR 수 및 DET 수를 결정하는 단계, 상기 트랜잭션 기능의 상기 유형, 상 기 FTR 수, 및 상기 DET 수에 기반하여 상기 트랜잭션 기능의 가중치를 결정하는 단계, 및 상기 가중치에 기반 하여 상기 트랜잭션 기능점수를 산출하는 단계를 포함할 수 있다. 일 실시 예에서, 상기 트랜잭션 기능의 상기 유형은 외부 입력(External Input; EI), 외부 출력(External Output; EO), 및 외부 조회(External inQuiry; EQ) 중 어느 하나이고, 상기 트랜잭션 기능의 상기 유형은 상기 결정된 데이터 테이블에 기초하여 상기 대상 소프트웨어의 기능 요소와 데이터 요소 간 CRUD 관계를 결정함으로 써 식별될 수 있다. 일 실시 예에서, 상기 대상 소프트웨어의 기능점수를 산출하는 단계는 상기 데이터 기능점수 및 상기 트랜잭션 기능점수를 합산하는 단계를 포함할 수 있다. 일 실시 예에서, 상기 방법은 그래픽 사용자 인터페이스를 이용하여 상기 대상 소프트웨어의 상기 기능점수를 표시하는 단계를 더 포함하고, 상기 그래픽 사용자 인터페이스는 상기 수집된 URL에 기반하여 도출된 상기 대상 소프트웨어의 클래스 간 의존관계 그래프를 포함할 수 있다. 본 개시의 다른 실시 예에 따른 소프트웨어의 기능점수를 산출하는 장치는 하나 이상의 인스트럭션들 (instructions)을 저장하는 메모리, 블록체인 네트워크와 통신하는 통신 인터페이스, 및 상기 하나 이상의 인스 트럭션들을 실행함으로써, 대상 소프트웨어가 제공하는 사용자 기능에 대응하는 화면 이미지 및 URL을 수집하고, 상기 수집된 화면 이미지의 레이블을 인식하고, 상기 수집된 URL에 의해 실행되는 SQL 구문을 분석하 여 데이터 테이블을 확인하고, 상기 확인된 데이터 테이블 및 상기 레이블 인식 결과를 비교하여 데이터 테이블 을 결정하고, 상기 결정된 데이터 테이블에 기반하여 데이터 기능점수를 산출하고, 상기 결정된 데이터 테이블 에 기반하여 트랜잭션 기능점수를 산출하고, 상기 데이터 기능점수 및 상기 트랜잭션 기능점수에 기반하여 상기 대상 소프트웨어의 기능점수를 산출하는 프로세서를 포함하되, 상기 수집된 화면 이미지의 해시 값은 상기 블록 체인 네트워크에 저장될 수 있다."}
{"patent_id": "10-2023-0086488", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 첨부된 도면을 참조하여 본 개시의 바람직한 실시 예들을 상세히 설명한다. 본 개시의 이점 및 특징, 그 리고 그것들을 달성하는 방법은 첨부되는 도면과 함께 상세하게 후술되어 있는 실시 예들을 참조하면 명확해질 것이다. 그러나 본 개시는 이하에서 설명되는 실시 예들에 한정되는 것이 아니라 서로 다른 다양한 형태로 구현 될 수 있으며, 단지 본 실시 예들은 본 개시가 완전하도록 하고, 본 개시가 속하는 기술 분야에서 통상의 지식 을 가진 자에게 발명의 범주를 완전하게 알려주기 위해 제공되는 것이며, 본 개시는 청구항의 범주에 의해 정의 될 뿐이다. 각 도면의 구성 요소들에 참조 부호를 부가함에 있어서, 동일한 구성 요소들에 대해서는 비록 다른 도면상에 표 시되더라도 가능한 한 동일한 부호를 가지도록 하고 있음에 유의해야 한다. 또한, 본 개시를 설명함에 있어, 관 련된 공지 구성 또는 기능에 대한 구체적인 설명이 본 개시의 요지를 흐릴 수 있다고 판단되는 경우에는 그 상 세한 설명은 생략한다. 다른 정의가 없다면, 본 명세서에서 사용되는 모든 용어(기술 및 과학적 용어를 포함)는 본 개시가 속하는 기술 분야에서 통상의 지식을 가진 자에게 공통적으로 이해될 수 있는 의미로 사용될 수 있다. 또 일반적으로 사용되 는 사전에 정의되어 있는 용어들은 명백하게 특별히 정의되어 있지 않는 한 이상적으로 또는 과도하게 해석되지 않는다. 본 명세서에서 사용된 용어는 실시 예들을 설명하기 위한 것이며 본 발명을 제한하고자 하는 것은 아니 다. 본 명세서에서, 단수형은 문구에서 특별히 언급하지 않는 한 복수형도 포함한다. 또한, 본 개시의 구성 요소를 설명하는 데 있어서, 제 1, 제 2, A, B, (a), (b) 등의 용어를 사용할 수 있다. 이러한 용어는 그 구성 요소를 다른 구성 요소와 구별하기 위한 것일 뿐, 그 용어에 의해 해당 구성 요소의 본 질이나 차례 또는 순서 등이 한정되지 않는다. 어떤 구성 요소가 다른 구성요소에 \"연결\", \"결합\" 또는 \"접속\" 된다고 기재된 경우, 그 구성 요소는 그 다른 구성요소에 직접적으로 연결되거나 또는 접속될 수 있지만, 각 구 성 요소 사이에 또 다른 구성 요소가 \"연결\", \"결합\" 또는 \"접속\"될 수도 있다고 이해되어야 할 것이다. 명세서에서 사용되는 \"포함한다 (comprises)\" 및/또는 \"포함하는 (comprising)\"은 언급된 구성 요소, 단계, 동 작 및/또는 소자는 하나 이상의 다른 구성 요소, 단계, 동작 및/또는 소자의 존재 또는 추가를 배제하지않는다. 도 1은 본 개시의 실시 예에 따른 소프트웨어의 기능점수를 산출하는 장치의 구성을 나타내는 블록도이다. 이하의 설명들에서, 소프트웨어의 기능점수를 산출하는 장치는 기능점수 산출 장치라고 나타내기로 한다. 도 1 을 참조하면, 기능점수 산출 장치는 수집부, 분석부, 기능점수 산출부, 및 결과 제공부 를 포함할 수 있다. 또한, 실시 예에 따라 기능점수 산출 장치는 기능점수 산출의 대상이 되는 대상 소프트웨어를 더 포함할 수도 있다. 도 1에 도시된 각각의 구성 요소들은 기능적으로 구분되는 기능 요소들 을 나타낸 것으로서, 적어도 하나의 구성 요소가 실제 물리적 환경에서는 서로 통합되는 형태로 구현될 수도 있 음에 유의한다. 수집부는 사용자 단말로부터 화면 이미지 및 URL을 수집할 수 있다. 이때, 수집되는 화면 이미지 및 URL은 대상 소프트웨어 상에 구현된 사용자 기능에 대응하는 화면 이미지 및 URL일 수 있다. 수집부에 의해 수집된 화면 이미지의 해시 값은 블록체인 네트워크의 각 블록체인 노드에 저장될 수 있다. 예를 들어, 사용자 단말은 스마트폰, 태블릿 PC, 랩탑 등을 포함할 수 있으나 본 개시는 이에 한정되지 않으며, 사용자 단말은 연산 수단 및 통신 수단이 구비된 모든 종류의 컴퓨팅 장치를 포함할 수 있다. 분석부는 수집부로부터 수집된 화면 이미지를 처리하여 변화 발생 여부를 판단하고, 화면 이미지 상 의 레이블들을 인식할 수 있다. 예를 들어, 화면 이미지의 변화는 사용자 기능의 수행을 통해(예를 들어, 검색 조건의 추가나 데이터 테이블 컬럼의 추가 및 삭제 등을 통해) 화면이 수정된 것을 나타낸다. 화면 이미지의 변 화 발생 여부는 블록체인 네트워크에 저장된 이미지의 해시 값이 변화했는지 여부에 기반하여 판단될 수 있 다. 그 후, 분석부는 화면 이미지에 나타난 레이블들(예를 들어, 버튼의 레이블, 데이터 테이블 컬럼의 레 이블 등)을 인식할 수 있다. 예를 들어, 분석부는 CNN(Convolutional Neural Network), RNN(Recurrent Neural Network) 등 텍스트 인식을 위한 임의의 인공지능 모델을 사용하여 이미지의 레이블들을 인식할 수 있다. 또한, 분석부는 수집부로부터 수집된 URL을 이용하여 대상 소프트웨어의 클래스와 메소드 간 관 계를 분석할 수 있다. 구체적으로, 분석부는 수집된 URL을 출발점으로 하여, 대상 소프트웨어 내 클래 스 간의 호출관계를 식별할 수 있다. 그리고, 분석부는 식별된 클래스 간 호출관계를 기초로 입력 파라미 터 정보를 획득하고, 획득한 입력 파라미터 정보를 참조하여 URL에 의해 수행되는 SQL 구문을 분석할 수 있다. 기능점수 산출부는 분석부의 이미지 처리 결과 및 SQL 구문 분석 결과에 기초하여 대상 소프트웨어 의 데이터 기능점수 및 트랜잭션 기능점수를 산출하고, 이를 기초로 대상 소프트웨어의 기능점수를 산 출할 수 있다. 구체적으로, 기능점수 산출부는 SQL 구문을 분석하여 SQL 구문과 연관된 데이터 테이블을 확인한 후, 확인된 데이터 테이블 컬럼과 이미지 처리 결과 인식된 레이블을 서로 맵핑하여 기능점수 산출에 사 용될 컬럼을 선택한 후, 이를 기초로 대상 소프트웨어의 기능점수를 산출할 수 있다. 결과 제공부는 산출된 기능점수를 사용자 인터페이스를 통해 출력할 수 있다. 이때, 결과 제공부는 URL을 출발점으로 한 클래스 간 호출관계를 그래픽 사용자 인터페이스(Graphic User Interface; GUI)로 표시할 수 있다. 블록체인 네트워크는 복수의 블록체인 노드로 구성된 P2P 구조의 네트워크로, 상술한 바와 같이 각 블록체 인 노드는 수집부에서 수집한 화면 이미지의 해시 값들을 저장할 수 있다. 예를 들어, 각 블록체인 노드는 속성으로서 화면 이미지의 해시 값을 갖는 스마트 컨트랙트(smart contract)를 포함할 수 있으며, 스마트 컨트 랙트는 화면 이미지의 해시 값들을 블록체인으로서 관리할 수 있다. 블록체인 노드는 스마트 컨트랙트를 실행하 기 위한 가상 머신(예컨대, 이더리움 가상 머신(Ethereum Virtual Machine; EVM))을 포함할 수 있다. 기능점수 산출 장치는 적어도 하나의 컴퓨팅 장치 상에 구현될 수 있다. 예를 들어, 기능점수 산출 장치 의 모든 기능이 하나의 컴퓨팅 장치에서 구현될 수도 있고, 기능점수 산출 장치의 일부 기능은 제 1 컴퓨팅 장치에서 구현되고 나머지 기능은 제 2 컴퓨팅 장치에서 구현될 수도 있다. 또는, 기능점수 산출 장치 의 특정 기능이 복수의 컴퓨팅 장치들에서 구현될 수도 있다. 컴퓨팅 장치는 컴퓨팅 기능을 구비한 임의의 장치를 모두 포함할 수 있으며, 기능점수 산출 장치가 컴퓨팅 장치로서 구현된 실시 예는 도 18을 참조하 여 더 상세히 설명된다. 사용자 단말, 블록체인 네트워크, 및 기능점수 산출 장치는 네트워크를 통해 통신할 수 있다. 예 를 들어, 네트워크는 근거리 통신망(Local Area Network; LAN), 광역 통신망(Wide Area Network; WAN), 이동 통신망(mobile radio communication network), Wibro(Wireless Broadband Internet) 등과 같은 모든 종류의 유/무선 네트워크로 구현될 수 있다. 도 2는 소프트웨어의 기능점수의 정의를 개념적으로 나타낸다. 기능점수는 소프트웨어의 규모 및 복잡도를 나타 내는 지표로서, 소프트웨어 개발 시 예상 비용을 산정하거나, 소프트웨어의 예상 유지보수 비용을 산정하거나, 소프트웨어 개발 시 필요한 예상 자원을 산정하는데 참조된다. 기능점수는 소프트웨어의 기능적 요구 사항을 중심으로 한 측정 지표로서, 물리적 파일, 화면, 프로그램 수와 같은 구현 관점이 아닌 사용자 관점의 요구 기능을 정량적으로 산정한 지표이다. 기능점수는 데이터 기능을 점 수화한 데이터 기능점수와 트랜잭션 기능을 점수화한 트랜잭션 기능점수로 구성되며, 통상 데이터 기능점수와 트랜잭션 기능점수를 각각 구한 후 단순 합산하는 방식으로 기능점수가 산출된다. 구체적으로, 데이터 기능은 그 유형에 따라 내부 논리 파일(Internal Logical File; ILF)와 외부 연계 파일 (External Interface File; EIF)로 구분되며, 트랜잭션 기능은 그 유형에 따라 외부 입력(External Input; EI), 외부 출력(External Output; EO), 외부 조회(External inQuiry; EQ)로 구분된다. 내부 논리 파일, 외부 연계 파일, 외부 입력, 외부 출력, 외부 조회의 개념에 대해서는 도 3을 참조하여 설명하도록 한다. 도 3은 각 사용자가 인사 관리 소프트웨어를 사용하는 예를 나타낸다. 여기서 인사 관리 소프트웨어는 도 1의 대상 소프트웨어일 수 있다. 먼저, 외부 입력은 외부에서 들어오는 데이터 및 제어 정보를 처리하는 기능 또는 프로세스를 의미한다. 주로 소프트웨어 내부 데이터에 대해 데이터를 추가, 수정, 삭제하는 것이 외부 입력에 해당된다. 도 3의 예에서는 제 1 사용자가 인사 관리 소프트웨어에 인사기본정보를 등록하는 기능이 외부 입력이 된다. 외부 조회는 외부에 데이터나 제어 정보를 내보내는 기능 또는 프로세스를 의미한다. 외부 조회는 일반적으로 키 값을 통해 내부 데이터 테이블에서 데이터 및 제어 정보를 조회하여 외부로 제공한다. 도 3의 예에서는 제 2 사용자가 인사 관리 소프트웨어에서 인사기본정보를 조회하는 기능이 외부 조회가 된다. 외부 출력은 외부 조회 이외의 처리 로직을 통해서 사용자에게 정보를 제공하는 기능 또는 프로세스를 의미한다. 가령, 단순히 데이터 테이블을 조회하여 출력하는 것이 아니라, 데이터 처리 로직이나 계산식을 통해 결과 데이터를 산출한 후 이를 외부로 출력하는 것이 외부 출력의 예이다. 도 3의 예에서는 제 3 사용자가 인사 관리 소프트웨어에서 데이터 처리를 통해 부서별 직급별 인원현황을 도출한 후 이를 출력하는 기능이 외부 출력이 된다. 내부 논리 파일은 대상 소프트웨어 내에 저장된 데이터를 의미한다. 도 3의 예에서는 인사 관리 소프트웨어 내에 저장된 인사마스터 파일이 내부 논리 파일이 된다. 이와 상대되는 개념으로, 외부 연계 파일은 대상 소프트웨어가 참조하는 데이터이지만 그 저장 위치는 대상 소프트웨어 외부에 있는 파일을 의미한다. 도 3의 예 에서는 부서별 직급별 인원현황을 도출하기 위해 인사 관리 소프트웨어 외부에서 읽어오는 메시지 정보(3 5)가 외부 연계 파일이 된다. 도 4는 본 개시의 실시 예에 따른 소프트웨어의 기능점수를 산출하기 위한 방법을 예시적으로 나타내는 흐름도 이다. 도 4에 도시된 단계들 및 방법들은 도 1의 기능점수 산출 장치에 의해 수행될 수 있다. 따라서, 이 하의 방법들에서 각 단계의 수행 주체가 생략된 경우, 해당 수행 주체는 도 1의 기능점수 산출 장치인 것으로 가정한다. 이하 도 4와 함께, 도 1을 참조하여 설명한다. 단계 S110에서, 기능점수 산출 장치의 수집부는 사용자 단말로부터 대상 소프트웨어가 제공 하는 사용자 기능에 대응하는 화면 이미지 및 URL을 수집할 수 있다. 단계 S110에 대해, 도 5 내지 도 6을 참조 하여 설명한다. 도 5는 본 개시의 실시 예에 따른 대상 소프트웨어에 의해 구현된 인터페이스 화면을 예시적으로 나타낸다. 사용자는 해당 인터페이스 화면을 통해 다양한 사용자 기능을 요청할 수 있다. 예를 들어, 사용자는 인터페 이스 화면 상에서 역할(41a)을 선택함으로써 권한이나 역할과 관련된 메뉴를 선택할 수 있다. 또는, 사용자 는 인터페이스 화면 상에서 조회(41b)을 선택함으로써 권한이나 역할과 관련된 정보를 조회할 수 있다. 또 는, 사용자는 인터페이스 화면 상에서 추가(41c)를 선택함으로써 신규 권한이나 역할을 추가할 수 있다. 또 는, 사용자는 인터페이스 화면 상에서 삭제(41d)를 선택함으로써 기존 권한이나 역할의 일부 또는 전부를 삭제할 수 있다. 이와 같은 인터페이스 화면의 이미지는 기능점수 산출 장치의 수집부에 의해 수 집될 수 있으며, 수집된 화면 이미지의 해시 값은 블록체인 네트워크의 각 블록체인 노드에 저장될 수 있다. 한편, 각 사용자 기능, 즉 역할, 조회, 추가, 삭제는 각각 미리 결정된 URL에 대응할 수 있다. 예를 들어, 사용 자가 사용자 단말(도 1의 10)을 통해 역할(41a)을 선택한 경우, 역할(41a)에 대응하는 URL이 서버로 전송되어 역할 기능이 수행된다. 유사하게, 사용자가 사용자 단말(도 1의 10)을 통해 조회(41b), 추가(41c), 삭제(41d)를 선택한 경우, 그 때마다 선택된 기능에 대응하는 URL이 서버로 전송되어 선택된 기능이 수행되며, 이하 도 6을 참조하여 설명한다. 도 6은 도 5의 사용자 기능과 URL 간의 대응관계를 예시적으로 나타낸다. 도 6의 대응표를 참조하면, 사용 자 기능 중 역할 기능에 대해서는'admin/rolemgn' URL이, 사용자 기능 중 조회 기능에 대해서 는'admin/rolemgn/searchRoleList' URL이, 사용자 기능 중 추가 기능에 대해서 는'admin/rolemgn/viewRoleAddPopup' URL이, 사용자 기능 중 삭제 기능에 대해서는'admin/rolemgn/deleteRole' URL이 각각 대응되는 것이 확인될 수 있다. 이러한 대응 관계를 기초로, 각 사용자 기능에 대응하는 URL은 기능 점수 산출 장치의 수집부에 의해 수집될 수 있다. 다시 도 4로 돌아가서, 단계 S120에서, 기능점수 산출 장치의 분석부는 수집된 화면 이미지의 레이블 을 인식할 수 있다. 단계 S120에 대해, 다시 도 5를 참조하여 설명한다. 도 5에서 '역할'은 역할(41a) 메뉴의 레이블이고, '조회', '추가', '삭제'는 각각 조회(41b), 추가(41c), 삭제 (41d) 버튼의 레이블이다. 그리고, 데이터 테이블 컬럼의 이름을 나타내는 레이블(예를 들어, '역할ID', '역할 명', '설명', '사용여부' 등)은 입력 레이블이라고 지칭되고, 각 컬럼의 항목을 나타내는 레이블(예를 들어, 'SYSTEM_ADMIN', '일반 사용자', '시스템을 사용하는 사용자', 'Y' 등)은 출력 레이블이라고 지칭된 다. 분석부는 이미지에서 텍스트를 인식하기 위한 인공지능 모델(예를 들어, CNN, RNN 등)을 사용하여, 이 와 같은 레이블을 인식할 수 있다. 도 7은 도 4의 수집된 화면 이미지의 레이블을 인식하는 단계(S120)를 구체적으로 나타내는 흐름도이다. 단계 S121에서, 기능점수 산출 장치의 분석부는 수집된 화면 이미지의 해시 값의 변화 여부를 통해 화면 이미지의 변화를 판단할 수 있다. 예를 들어, 화면 이미지의 변화는 도 5의 사용자 인터페이스에서 추 가(41c) 또는 삭제(41d)를 통해 화면을 수정하거나, 검색 조건을 추가하여 화면을 수정한 경우를 나타낼 수 있 다. 단계 S122에서, 화면 이미지에 변화가 있는 것으로 판단된 경우, 단계 S123에서, 분석부는 화면 이미지의 변화에 응답하여 화면 이미지의 레이블을 인식할 수 있다. 예를 들어, 다시 도 5를 참조하여, 사용자가 추가 (41c)를 통해 데이터 테이블에 컬럼을 추가한 경우, 컬럼이 추가된 화면의 레이블을 인식할 수 있다. 반면, 단 계 S122에서, 화면 이미지에 변화가 없는 것으로 판단된 경우 다시 단계 S121이 수행될 수 있다. 다시 도 4로 돌아가서, 단계 S130에서, 기능점수 산출 장치의 분석부는 수집된 URL에 의해 실행되는 SQL 구문을 분석하여 데이터 테이블을 확인할 수 있다. 단계 S130에 대해, 도 8 내지 도 11을 참조하여 설명한 다. 도 8은 도 4의 수집된 URL에 의해 실행되는 SQL 구문을 분석하는 단계(S130)를 구체적으로 나타내는 흐름도이다. 단계 S131에서, 분석부는 수집된 URL의 호출 정보를 기초로 대상 소프트웨어 내 복수의 클래 스 간 호출 관계를 확인할 수 있다. 이에 대한 부연 설명을 위해 도 9를 참조하면, 도 9는 수집된 URL과 대상 소프트웨어의 클래스들을 예시적으로 나타낸다. 각 URL(51, 52, 53)은 실행될 때 제 1 클래스(Controller) 내의 각 메소드를 호출한다(A). 예를 들어, 제 1 URL은 제 1 클래스(Controller)의 제 3 메소드인 saveRole(RoleinfoVo)를 호출하고, 제 2 URL은 제1 클래스(Controller)의 제 2 메소드인 deleteRole(List)를 호출하고, 제 3 URL은 제1 클래스(Controller)의 제 1 메소드인 searchRoleList(Map)을 호출한다. 한편, 대상 소프트웨어의 각 클래스 간에도 호출 관계가 존재할 수 있다(B). 예를 들어, 제 1 클래스 (Controller)의 제 1 메소드인 searchRoleList(Map)은 실행될 때 제 2 클래스(ServiceImpl)의 제 1 메소드인 searchRoleList(Map)을 호출하고, 제 1 클래스(Controller)의 제 2 메소드인 deleteRole(List)는 실행될 때 제 2 클래스(ServiceImpl)의 제2 메소드인 deleteRoleInfo(List)를 호출하고, 제 1 클래스(Controller)의 제3 메 소드인 saveRole(RoleinfoVo)는 실행될 때 제 2 클래스(ServiceImpl)의 제 3 메소드인 saveRoleInfo(RoleinfoVo)를 호출할 수 있다. 이처럼, 수집된 URL을 출발점으로 하여, URL이 호출하는 제 1 클래스의 메소드들을 확인하고, 다시 그 메소드들 이 호출하는 다른 클래스의 메소드들을 확인하는 방식으로, 도 9에 도시된 것과 같이, 대상 소프트웨어 내 클래 스들 간 호출 관계가 확인될 수 있다. 다시 도 8로 돌아가서, 단계 S132에서, 분석부는 호출 관계가 확인된 복수의 클래스의 입력 파라미터 정보 를 획득할 수 있다. 이 때, 입력 파라미터 정보는 복수의 클래스의 메소드, 메소드의 입력 파라미터, 또는 입력 파라미터를 통해 반환되는 출력 값을 포함할 수 있다. 이에 대한 구체적인 설명을 위해 도 10을 참조하면, 도 10은 도 9의 클래스들에 대해 획득된 입력 파라미터 정보를 예시적으로 나타낸다. 도 10의 상단에는 호출관계가 확인된 클래스인 ServiceImpl과 그 메소드가 도시되어 있다. 클래스 ServiceImpl 은 메소드 searchRoleList(Map), deleteRoleInfo(List), saveRoleInfo(RoleinfoVo)를 포함하고, 각 메소드의 입력 파라미터는 Map, List, RoleinfoVo가 된다. 여기서, 클래스 ServiceImpl, 메소드 searchRoleList(Map), deleteRoleInfo(List), saveRoleInfo(RoleinfoVo), 그리고 입력 파라미터 Map, List, RoleinfoVo가 입력 파라 미터 정보를 구성할 수 있다. 한편, 입력 파라미터로는 다른 클래스가 들어올 수도 있다. 도 10의 상단을 참조하여, 클래스 ServiceImpl의 세 번째 메소드의 입력 파라미터인 RoleinfoVo가 클래스인 것으로 가정한다. 입력 파라미터 RoleinfoVo는 자신의 메소드 set_ID(int), set_RoleNm(string), set_Desc(string)을 포함할 수 있다. 이 경우, 입력 파라미터 RoleinfoVo의 세 개의 메소드들을 통해 출력 값 role_id, role_name, description이 각각 반환될 수 있는데, 이 때의 출력 값들도 입력 파라미터 정보를 구성할 수 있다. 이를 정리한 도표가 도 10의 하단에 도시된다. 도 10의 입력 파라미터 정보를 참조하면, 호출관계가 확인된 클래스, 그 클래스에 포함된 메소드, 그 메소드의 입력 파라미터, 및 그 입력 파라미터를 통해 반환되는 출력 값이 입력 파라미터 정보에 포함되는 것을 확인할 수 있다. 여기서 입력 파라미터를 통해 반환되는 출력 값 은 SQL 구문의 입력 파라미터로 사용될 수 있다. 다시 도 8로 돌아가서, 단계 S133에서, 분석부는 획득한 입력 파라미터 정보에 기반하여 SQL 구문과 연관 된 데이터 테이블을 확인할 수 있다. 이에 대한 구체적인 설명을 위해 도 11을 참조하면, 도 11은 사용자 기능 에 대응하는 SQL 구문을 분석하여 데이터 테이블을 확인하는 과정을 예시적으로 나타낸다. 먼저, 사용자 기능 중 조회에 대응되는 URL이 수집된다. 그리고, 수집된 URL을 통해 실행되는 SQL 구문을 분석한다. SQL 구문은 데이터 테이블 TABLE_INFO로부터 필드 role_id, role_name, description 을 추출하는 구문이므로, 조회 또는 URL과 연관된 데이터 테이블은 TABLE_INFO이고, 관련 필드는 role_id, role_name, description 인 것이 확인된다. 한편, SQL 구문이 실행되면 TABLE_INFO로부터 추출된 role_id, role_name, description의 필드 값이 사용자 단말에 반환되어, 사용자 인터페이스에는 조회 결과가 표시된다. 여기서, 필드 role_id, role_name, description은 앞서 입력 파라미터 정보를 통해 반환 된 출력 값에 해당하며, TABLE_INFO와 같이 확인된 데이터 테이블은 이후 단계들에서 기능점수 산출에 사용될 수 있다. 다시 도 4로 돌아가서, 단계 S140에서, 기능점수 산출 장치의 기능점수 산출부는 단계 S130에서 확인 된 데이터 테이블과 단계 S120의 레이블 인식 결과를 비교하여 데이터 테이블을 결정할 수 있다. 단계 S140에 대해, 도 12를 참조하여 더 구체적으로 설명한다. 도 12는 도 4의 확인된 데이터 테이블과 레이블 인식 결과를 비교하여 데이터 테이블을 결정하는 단계(S140)를 구체적으로 나타내는 흐름도이다. 단계 S141에서, 기능점수 산출부는 SQL 구문 분석 결과 확인된 데이터 테이블의 각 컬럼과, 화면 이미지 분석 결과 인식된 레이블(예를 들어, 도 5를 참조하여 설명한 입력 레이블 )을 비교할 수 있다. 단계 S142에서, 기능점수 산출부는 비교 결과 인식된 레이블과 일치하지 않는 컬 럼을 삭제하여, 기능점수 산출에 사용될 데이터 테이블을 결정할 수 있다. 이와 같이 대상 소프트웨어의 화면 이미지 처리 및 SQL 구문 분석을 모두 활용함으로써, 기능점수 산출에 관여하지 않는 컬럼을 효과적으로 제거할 수 있으며, 화면 이미지의 변화에 기반하여 레이블 인식을 수행하고 이미지 내부의 텍스트 추출을 위한 인공지능 모델을 사용하므로 속도 및 정확도도 보장될 수 있다. 따라서, 본 개시의 실시 예에 따라 화면 이미지 처리 및 SQL 구문 분석을 함께 사용하면, 기능점수 산출에 사용될 데이터 테이블이 정확하게 결정됨으로써 SQL 구문 분석만을 사용할 때에 비해 기능점수 산출의 정확도가 향상될 수 있 다. 다시 도 4로 돌아가서, 단계 S150에서, 기능점수 산출 장치의 기능점수 산출부는 단계 S140에서 결정 된 데이터 테이블에 기반하여 데이터 기능점수를 산출할 수 있다. 단계 S150에 대해, 도 13 내지 도 14를 참조하여 설명한다. 도 13은 결정된 데이터 테이블에 기반하여 데이터 기능점수를 산출하는 단계(S150)를 구체적으로 나타낸다. 단계 S151에서, 기능점수 산출부는 데이터 기능의 유형을 식별할 수 있다. 예를 들어, 데이터 기능의 유형 은 도 2를 참조하여 설명한 내부 논리 파일(ILF) 및 외부 논리 파일(EIF)이 있으며, 데이터 기능의 유형 식별에 는 CRUD 매트릭스가 사용될 수 있다. CRUD 매트릭스는 대상 소프트웨어의 특정 기능 요소와 특정 데이터 요소 간의 생성(Create; C), 읽기(Read; R), 업데이트(Update; U), 및/또는 삭제(Delete; D) 관계가 정리된 매트릭스로, 데이터 요소에 내부적 사용 관계가 존재하는지 여부를 파악하는 데 용이하게 사용될 수 있다. 여기서 기능 요소는 대상 소프트웨어의 클래스, 단위 프로세스, 또는 패키지일 수 있고, 데이터 요소는 대상 소프트웨어가 포함하는 내부의 데이터 테이블 또는 대상 소프트웨어가 참조하는 외부의 데이터 테이블일 수 있다. 예를 들어, CRUD 매트릭스를 참조했을 때 해당 데이터 요소에 CRUD 관계가 없으면 내부적 사용 관계가 없다는 의미이므로 해당 데이터 요소는 EIF 유형이 되며, CRUD 관계가 있으면 내부적 사용 관계가 있다는 의미이므로 해당 데이터 요소는 ILF 유형이 된다. 또한, CRUD 매트릭스는 기능 요소의 유형이 EI인지, EO인지 또는 EQ인지 판단하는데 사용될 수 있다. CRUD 매트릭스에 표시된 CRUD 관계가 생성(C), 업데이트(U), 삭제(D) 인 경우 EI 유형으로 판단된다. CRUD 매트릭스에 표시된 CRUD 관계가 읽기(R) 인 경우 EO 또는 EQ 유형으로 판단된다. 이 때, SQL 구문 내에서 avg, sum, count, group by 함수가 사용되었으면 EO 유형으로, 그렇지 않고 단순 조회 이면 EQ 유형으로 판단된다. 그러나 본 개시는 이에 한정되지 않으며, 데이터 요소 및 기능 요소의 유형은 상술 한 방법과 다른 방법을 통해 결정될 수도 있다. 단계 S152에서, 기능점수 산출부는 데이터 기능의 레코드 요소 유형(Record Element Type; RET) 수 및 데 이터 요소 유형(Data Element Type; DET) 수를 결정할 수 있다. 여기서, ILF 또는 EIF 자체는 하나의 RET로 식 별될 수 있으며, 데이터 테이블로부터 반환되는 필드 각각은 DET로 식별될 수 있다. 예를 들어, 데이터 기능으로서 직원정보라는 1개의 데이터 테이블이 있다고 가정하고, 직원정보에 대해 CRUD 관 계가 정의되지 않았다면 직원정보는 EIF 유형으로 확인된다. 또한, 직원정보는 1개의 데이터 테이블이므로 RET 수는 1이며, 직원정보로부터 반환되는 필드가 직원번호, 부서코드, 성명, 근무시작일, 근무종료일의 5개라고 가 정하면, DET 수는 5가 된다. 단계 S153에서, 기능점수 산출부는 단계 S151에서 결정된 데이터 기능의 유형 및 단계 S152에서 결정된 RET 수 및 DET 수에 기반하여 가중치를 결정할 수 있다. 도 14는 데이터 기능점수와 관련된 가중치 결정을 위한 테이블을 예시적으로 나타낸다. 상술한 예에 대해 도 14를 참조하면, 데이터 기능의 유형이 EIF이고, RET 수가 1이고, DET 수가 5이면 복잡도는 낮음이고, 그에 따른 가중치는 5로 결정된다. 그리고 단계 S154에서, 기능점수 산출부는 가중치에 기반하여 데이터 기능점수를 산출할 수 있다. 구체적 으로, 데이터 기능점수는 데이터 기능의 개수에 가중치를 곱한 값으로 결정될 수 있다. 위의 예에서는, EIF 유 형 개수 1에 가중치 5를 곱한 값인 5가 데이터 기능점수가 된다. 다시 도 4로 돌아가서, 단계 S160에서, 기능점수 산출 장치의 기능점수 산출부는 단계 S140에서 결정 된 데이터 테이블에 기반하여 트랜잭션 기능점수를 산출할 수 있다. 단계 S160에 대해, 도 15 내지 도 16을 참 조하여 설명한다. 도 15는 결정된 데이터 테이블에 기반하여 트랜잭션 기능점수를 산출하는 단계(S160)를 구체적으로 나타낸다. 단계 S161에서, 기능점수 산출부는 트랜잭션 기능의 유형을 식별할 수 있다. 예를 들어, 트랜잭션 기능의 유형은 도 2를 참조하여 설명한 외부 입력(EI), 외부 출력(EQ), 및 외부 조회(EQ)가 있으며, 데이터 기능의 유 형 식별과 마찬가지로 트랜잭션 기능의 유형 식별에는 CRUD 매트릭스가 사용될 수 있다. CRUD 매트릭스와 관련 된 상세한 설명은 도 13을 참조하여 설명한 것과 중복되므로 생략하기로 한다. 예를 들어, 연간감사계획등록이라는 트랜잭션 기능이 있다고 가정할 때 CRUD 매트릭스를 참조하여 생성(Create, C) 관계가 있는 것이 확인되면 트랜잭션 기능의 유형은 EI로 식별될 수 있다. 또는, SQL 구문 분석을 통해서도 트랜잭션 기능의 유형이 식별될 수 있다. 예를 들어, SQL 구문에 insert 문장이 있으면 이를 근거로 트랜잭션 기능의 유형은 EI로 식별될 수 있다. 단계 S162에서, 기능점수 산출부는 트랜잭션 기능의 참조 파일 유형(File Type Referenced; FTR) 수 및 DET 수를 결정할 수 있다. 여기서, FTR은 트랜잭션 기능에 의해 읽히거나 유지되는 파일을 의미하며, 트랜잭션 기능에 의해 읽히거나 유지되는 ILF 또는 EIF 자체가 하나의 FTR로 식별될 수 있고, 트랜잭션 기능에 의해 처리 되는 필드 각각이 DET로 식별될 수 있다. 예를 들어, 연간감사계획등록이라는 트랜잭션 기능에 의해 직원정보와 연간감사계획이라는 2개의 데이터 테이블 이 읽히거나 유지된다고 가정하면 트랜잭션 기능에 의해 읽히거나 유지되는 파일이 2개이므로 FTR 수는 2가 된 다. 그리고, 연간감사계획등록이라는 트랜잭션 기능에 의해 처리되는 필드가 연도, 부서명, 프로젝트명, 프로젝 트시작일, 프로젝트종료일의 5개라고 가정하면, DET 수는 5가 된다. 단계 S163에서, 기능점수 산출부는 단계 S161에서 결정된 트랜잭션 기능의 유형 및 단계 S162에서 결정된 FTR 수 및 DET 수에 기반하여 가중치를 결정할 수 있다. 도 16은 트랜잭션 기능점수와 관련된 가중치 결정을 위 한 테이블을 예시적으로 나타낸다. 도 16을 참조하면, 트랜잭션 기능의 유형이 EI이고, FTR 수가 2이고, DET 수 가 5이면 복잡도는 보통이고, 그에 따른 가중치는 4로 결정된다. 그리고 단계 S164에서, 기능점수 산출부는 가중치에 기반하여 트랜잭션 기능점수를 산출할 수 있다. 구체 적으로, 트랜잭션 기능점수는 트랜잭션 기능의 개수에 가중치를 곱한 값으로 결정될 수 있다. 위의 예에서는, EI 유형 개수 1에 가중치 4를 곱한 값인 4가 트랜잭션 기능점수가 된다. 도 13 내지 도 16을 참조하여 설명한 바와 같이, DET 수는 데이터 기능 또는 트랜잭션 기능에 의해 처리되는 필 드 수를 나타낼 수 있고, 이는 단계 S140에서 결정된 데이터 테이블의 컬럼 수에 해당할 수 있다. 즉, 본 개시 의 실시 예에 따르면 SQL 구문 분석 결과 1차적으로 확인된 데이터 테이블 중에서 화면 이미지의 변화에 따른 레이블 인식 결과와 일치하지 않는 컬럼을 삭제하고 최종 데이터 테이블을 결정함으로써, DET 수가 정확하게 산 출될 수 있고, 데이터 기능점수 및 트랜잭션 기능점수가 정확하게 산출될 수 있다. 다시 도 4로 돌아가서, 단계 S170에서, 기능점수 산출 장치의 기능점수 산출부는 단계 S150 내지 단 계 S160에서 산출된 데이터 기능점수 및 트랜잭션 기능점수에 기반하여 소프트웨어의 기능점수를 산출할 수 있 다. 예를 들어, 대상 소프트웨어의 기능점수는 데이터 기능점수와 트랜잭션 기능점수를 합산하여 산출될 수 있다. 예를 들어, 대상 소프트웨어의 데이터 기능점수가 5이고 트랜잭션 기능점수가 4이면, 소프트웨어의 기능점수는 그 둘을 합산한 9가 될 수 있다. 마지막으로 단계 S180에서, 기능점수 산출 장치의 결과 제공부는 그래픽 사용자 인터페이스(GUI)를 이용하여 단계 S170에서 산출된 대상 소프트웨어의 기능점수를 표시할 수 있다. 단계 S180에 대해, 도 17을 참 조하여 설명한다. 도 17은 본 개시의 실시 예에 따른 기능점수 산출 결과가 표시된 그래픽 사용자 인터페이스를 예시적으로"}
{"patent_id": "10-2023-0086488", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "나타낸다. 사용자 인터페이스는 그래픽 사용자 인터페이스로서, 하단에 산출된 기능점수를 요약하여 표시 하는 제1 GUI 부분이 표시되고, 상단에 대상 소프트웨어 내 클래스 간 의존관계 그래프가 도시된 제2 GUI 부분이 표시된다. 상기 의존관계 그래프는 도시된 것처럼 각 클래스 간 호출관계를 기초로 작성되되 기타 부수적인 정보가 더 부가될 수 있다. 도 18은 본 개시의 실시 예에 따른 소프트웨어의 기능점수를 산출하기 위한 컴퓨팅 장치의 하드웨어 구성 을 나타내는 블록도이다. 도 18을 참조하면, 컴퓨팅 장치는 하나 이상의 프로세서, 버스, 통신 인터페이스, 프로세 서에 의하여 수행되는 컴퓨터 프로그램을 로드(load)하는 메모리와, 컴퓨터 프로그램을 저장하 는 스토리지를 포함할 수 있다. 다만, 도 18에는 본 개시의 실시 예와 관련 있는 구성 요소들만이 도시되 어 있다. 따라서, 본 개시가 속한 기술 분야의 통상의 기술자라면 도 18에 도시된 구성요소들 외에 다른 범용적 인 구성 요소들이 더 포함될 수 있음을 알 수 있다. 즉, 컴퓨팅 장치에는, 도 18에 도시된 구성 요소 이외 에도 다양한 구성 요소가 더 포함될 수 있다. 또한, 경우에 따라, 도 18에 도시된 구성요소들 중 일부가 생략된 형태로 컴퓨팅 장치가 구성될 수도 있다. 이하, 컴퓨팅 장치의 각 구성 요소에 대하여 설명한다. 프로세서는 컴퓨팅 장치의 각 구성의 전반적인 동작을 제어할 수 있다. 프로세서는 CPU(Central Processing Unit), MPU(Micro Processor Unit), MCU(Micro Controller Unit), GPU(Graphic Processing Unit) 또는 본 개시의 기술 분야에 잘 알려진 임의의 형태의 프로세서 중 적어도 하나를 포함하여 구성될 수 있다. 또 한, 프로세서는 본 개시의 실시 예들에 따른 동작/방법을 실행하기 위한 적어도 하나의 애플리케이션 또는 프로그램에 대한 연산을 수행할 수 있다. 컴퓨팅 장치는 하나 이상의 프로세서를 구비할 수 있다.다음으로, 메모리는 각종 데이터, 명령 및/또는 정보를 저장할 수 있다. 메모리는 본 개시의 실시 예 들에 따른 동작/방법을 실행하기 위하여 스토리지로부터 컴퓨터 프로그램을 로드할 수 있다. 메모리 는 RAM과 같은 휘발성 메모리로 구현될 수 있을 것이나, 본 개시는 이에 한정되지 않는다. 다음으로, 버스는 컴퓨팅 장치의 구성 요소 간 통신 기능을 제공할 수 있다. 버스는 주소 버스 (Address Bus), 데이터 버스(Data Bus) 및 제어 버스(Control Bus) 등 다양한 형태의 버스로 구현될 수 있다. 다음으로, 통신 인터페이스는 컴퓨팅 장치의 유무선 인터넷 통신을 지원할 수 있다. 또한, 통신 인터 페이스는 인터넷 통신 외의 다양한 통신 방식을 지원할 수도 있다. 이를 위해, 통신 인터페이스는 본 개시의 기술 분야에 잘 알려진 통신 모듈을 포함하여 구성될 수 있다. 다음으로, 스토리지는 하나 이상의 컴퓨터 프로그램을 비임시적으로 저장할 수 있다. 스토리지 는 ROM(Read Only Memory), EPROM(Erasable Programmable ROM), EEPROM(Electrically Erasable Programmable ROM), 플래시 메모리 등과 같은 비휘발성 메모리, 하드 디스크, 착탈형 디스크, 또는 본 개시가 속하는 기술 분 야에서 잘 알려진 임의의 형태의 컴퓨터로 읽을 수 있는 기록 매체를 포함하여 구성될 수 있다. 다음으로, 컴퓨터 프로그램은 메모리에 로드될 때 프로세서로 하여금 본 개시의 다양한 실시 예 들에 따른 동작/방법을 수행하도록 하는 하나 이상의 인스트럭션을 포함할 수 있다. 즉, 프로세서는 로드 된 하나 이상의 인스트럭션을 실행함으로써, 본 개시의 다양한 실시 예들에 따른 동작/방법을 수행할 수 있다. 예를 들어, 컴퓨터 프로그램은 대상 소프트웨어가 제공하는 사용자 기능에 대응하는 화면 이미지 및 URL을 수집하고, 수집된 화면 이미지의 레이블을 인식하고, 수집된 URL에 의해 실행되는 SQL 구문을 분석하여 데이터 테이블을 확인하고, 확인된 데이터 테이블과 레이블 인식 결과를 비교하여 데이터 테이블을 결정하고, 결정된 데이터 테이블에 기반하여 데이터 기능점수 및 트랜잭션 기능점수를 산출하고, 데이터 기능점수 및 트랜잭션 기 능점수에 기반하여 대상 소프트웨어의 기능점수를 산출하고, 그래픽 사용자 인터페이스를 이용하여 대상 소프트 웨어의 기능점수를 표시하도록 하는 인스트럭션들을 포함할 수 있다. 지금까지 설명된 본 개시의 기술적 사상은 컴퓨터가 읽을 수 있는 매체 상에 컴퓨터가 읽을 수 있는 코드로 구 현될 수 있다. 컴퓨터로 읽을 수 있는 기록 매체는, 예를 들어 이동형 기록 매체(CD, DVD, 블루레이 디스크, USB 저장 장치, 이동식 하드 디스크)이거나, 고정식 기록 매체(ROM, RAM, 컴퓨터 구비 형 하드 디스크)일 수 있 다. 컴퓨터로 읽을 수 있는 기록 매체에 기록된 컴퓨터 프로그램은 인터넷 등의 네트워크를 통하여 다른 컴퓨팅 장치에 전송되어 다른 컴퓨팅 장치에 설치될 수 있고, 이로써 다른 컴퓨팅 장치에서 사용될 수 있다. 지금까지 도 1 내지 도 18을 참조하여 본 개시의 다양한 실시 예들 및 그 실시 예들에 따른 효과들을 언급하였 다. 본 개시의 기술적 사상에 따른 효과들은 이상에서 언급한 효과들로 제한되지 않으며, 언급되지 않은 또 다 른 효과들은 아래의 기재로부터 통상의 기술자에게 명확하게 이해될 수 있을 것이다. 이상에서, 본 개시의 실시 예를 구성하는 모든 구성 요소들이 하나로 결합되거나 결합되어 동작하는 것으로 설 명되었다고 해서, 본 개시가 반드시 이러한 실시 예에 한정되는 것은 아니다. 즉, 본 개시의 목적 범위 안에서 라면, 그 모든 구성 요소들이 하나 이상으로 선택적으로 결합하여 동작할 수도 있다. 도면에서 동작들이 특정한 순서로 도시되어 있지만, 반드시 동작들이 도시된 특정한 순서로 또는 순차적 순서로 실행되어야만 하거나 또는 모든 도시 된 동작들이 실행되어야만 원하는 결과를 얻을 수 있는 것으로 이해되어서 는 안 된다. 특정 상황에서는, 멀티태스킹 및 병렬 처리가 유리할 수도 있다. 더욱이, 위에 설명한 실시 예들에 서 다양한 구성들의 분리는 그러한 분리가 반드시 필요한 것으로 이해되어서는 안 되고, 설명된 프로그램 컴포 넌트들 및 시스템들은 일반적으로 단일 소프트웨어 제품으로 함께 통합되거나 다수의 소프트웨어 제품으로 패키 지 될 수 있음을 이해하여야 한다."}
{"patent_id": "10-2023-0086488", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "이상 첨부된 도면을 참조하여 본 개시의 실시 예들을 설명하였지만, 본 개시가 속하는 기술분야에서 통상의 지 식을 가진 자는 본 개시가 그 기술적 사상이나 필수적인 특징을 변경하지 않고서 다른 구체적인 형태로 실시될 수 있다는 것을 이해할 수 있다. 그러므로 이상에서 기술한 실시 예들은 모든 면에서 예시적인 것이며 한정적인 것이 아닌 것으로 이해해야만 한다. 본 개시의 보호 범위는 아래의 청구범위에 의하여 해석되어야 하며, 그와 동등한 범위 내에 있는 모든 기술 사상은 본 개시의 권리범위에 포함되는 것으로 해석되어야 할 것이다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12 도면13 도면14 도면15 도면16 도면17 도면18"}
{"patent_id": "10-2023-0086488", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 개시의 실시 예에 따른 소프트웨어의 기능점수를 산출하는 장치의 구성을 나타내는 블록도이다. 도 2는 소프트웨어의 기능점수의 정의를 개념적으로 나타낸다. 도 3은 각 사용자가 인사 관리 소프트웨어를 사용하는 예를 나타낸다.도 4는 본 개시의 실시 예에 따른 소프트웨어의 기능점수를 산출하기 위한 방법을 예시적으로 나타내는 흐름도 이다. 도 5는 본 개시의 실시 예에 따른 대상 소프트웨어에 의해 구현된 인터페이스 화면을 예시적으로 나타낸다. 도 6은 도 5의 사용자 기능과 URL 간의 대응관계를 예시적으로 나타낸다. 도 7은 도 4의 수집된 화면 이미지의 레이블을 인식하는 단계를 구체적으로 나타내는 흐름도이다. 도 8은 도 4의 수집된 URL에 의해 실행되는 SQL 구문을 분석하는 단계를 구체적으로 나타내는 흐름도이다. 도 9는 수집된 URL과 대상 소프트웨어의 클래스들을 예시적으로 나타낸다. 도 10은 도 9의 클래스들에 대해 획득된 입력 파라미터 정보를 예시적으로 나타낸다. 도 11은 사용자 기능에 대응하는 SQL 구문을 분석하여 데이터 테이블을 확인하는 과정을 예시적으로 나타낸다. 도 12는 도 4의 확인된 데이터 테이블과 레이블 인식 결과를 비교하여 데이터 테이블을 결정하는 단계를 구체적 으로 나타내는 흐름도이다. 도 13은 결정된 데이터 테이블에 기반하여 데이터 기능점수를 산출하는 단계를 구체적으로 나타낸다. 도 14는 데이터 기능점수와 관련된 가중치 결정을 위한 테이블을 예시적으로 나타낸다. 도 15는 결정된 데이터 테이블에 기반하여 트랜잭션 기능점수를 산출하는 단계를 구체적으로 나타낸다. 도 16은 트랜잭션 기능점수와 관련된 가중치 결정을 위한 테이블을 예시적으로 나타낸다. 도 17은 본 개시의 실시 예에 따른 기능점수 산출 결과가 표시된 그래픽 사용자 인터페이스를 예시적으로 나타 낸다. 도 18은 본 개시의 실시 예에 따른 소프트웨어의 기능점수를 산출하기 위한 컴퓨팅 장치의 하드웨어 구성을 나 타내는 블록도이다."}
