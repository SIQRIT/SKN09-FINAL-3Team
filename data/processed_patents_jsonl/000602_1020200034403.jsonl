{"patent_id": "10-2020-0034403", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2020-0115213", "출원번호": "10-2020-0034403", "발명의 명칭": "비디오 게임에서 자동 플레이어 제어의 인계", "출원인": "일렉트로닉 아트 아이엔씨.", "발명자": "보로비코프, 이고르"}}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "시스템에 있어서,하나 이상의 비디오 게임과 관련된 플레이어 모방 모델(player imitation model)을 저장하는 데이터 저장소(data store) - 상기 플레이어 모방 모델은 복수의 게임 플레이 상황 각각에서 플레이어에 의해 취해진 동작(action)의 표시를 포함함 -; 및상기 데이터 저장소와 전자적(electronic) 통신하고, 컴퓨터로 판독 가능한(computer-readable) 명령어(instruction)를 실행하도록 구성된 컴퓨팅 시스템을 포함하되,상기 명령어는:멀티 플레이어 비디오 게임의 호스팅된 인스턴스(hosted instance)를 개시(initiate)하도록 하되, 상기 멀티플레이어 비디오 게임의 상기 호스팅된 인스턴스는 가상 환경에서 상호 작용(interacting)하는 복수의 가상 캐릭터를 포함하고, 제1 플레이어 컴퓨팅 장치(first player computing device)는 초기에 제1 가상 캐릭터(firstvirtual character)를 제어하고, 상기 제1 가상 캐릭터 이외의 적어도 하나의 추가적인 가상 캐릭터가 하나 이상의 다른 플레이어 컴퓨팅 장치에 의해 초기에 제어되고; 상기 멀티 플레이어 비디오 게임의 상기 호스팅된 인스턴스가 제1 게임 상태(first game state)에 있는 동안,적어도 상기 제1 플레이어 컴퓨팅 장치로부터 플레이어 제어 명령(player control commands)을 수신하며;적어도 상기 플레이어 제어 명령에 기초하여 상기 멀티 플레이어 비디오 게임의 상기 호스팅된 인스턴스에 대한제1 업데이트된 게임 상태(first updated game state)를 생성하고;상기 제1 업데이트된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공하고;상기 제1 게임 상태 및 상기 제1 플레이어 컴퓨팅 장치로부터의 상기 플레이어 제어 명령에 기초하여 상기 플레이어 모방 모델을 업데이트하고;상기 컴퓨팅 시스템과 상기 제1 플레이어 컴퓨팅 장치 사이의 연결 문제를 검출하되, 상기 연결 문제는 손실된네트워크 연결, 임계값(threshold)을 만족하는 네트워크 지연, 또는 상기 제1 플레이어 컴퓨팅 장치로부터 발생하는 제어 명령의 예상치 못한 부족(unexpected lack) 중 적어도 어느 하나를 포함하고;상기 연결 문제에 기초하여, 상기 제1 플레이어 컴퓨팅 장치에 의한 제어 대신에 상기 컴퓨팅 시스템에 의한 자동화된 제어 하에 있도록 상기 제1 가상 캐릭터를 전환(switch)하고;상기 제1 업데이트된 게임 상태와 상기 플레이어 모방 모델에 기초하여 적어도 상기 제1 가상 캐릭터와 관련한에뮬레이트된 제어 명령(emulated control command)을 결정하고; 적어도 상기 에뮬레이트된 제어 명령에 기초하여 상기 멀티 플레이어 비디오 게임의 상기 호스팅된 인스턴스에대한 제2 업데이트된 게임 상태(second updated game state)를 생성하고; 및상기 제2 업데이트된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공하도록 상기 컴퓨팅 시스템(computing system)을 구성하는,시스템."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,공개특허 10-2020-0115213-3-상기 컴퓨팅 시스템은 제1 기간(first time period)에 걸쳐 상기 플레이어에 의해 입력된 플레이어 제어 명령의결과로서 수행된 복수의 게임 내 동작(in-game action)의 자동화된 분석에 기초하여 상기 플레이어 모방 모델을생성하도록 추가로 구성되고,상기 플레이어는 상기 제1 플레이어 컴퓨팅 장치를 이용하고, 상기 플레이어 모방 모델은 상기 플레이어에 특정된(specific),시스템."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 제1 기간은 상기 멀티 플레이어 비디오 게임의 복수의 인스턴스를 포함하고, 상기 복수의 인스턴스는 상기 멀티 플레이어 비디오 게임의 상기 호스팅된 인스턴스를 포함하는,시스템."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서,상기 제1 기간은 상기 플레이어에 의해 구성될 수 있고,상기 컴퓨팅 시스템은 상기 플레이어가, (a) 기간, 또는 (b) 상기 플레이어 모방 모델을 생성할 때 상기 컴퓨팅 시스템에 의해 고려되는 하나 이상의 이전(previous) 게임 인스턴스를 선택할 수 있도록 하는 사용자 인터페이스를 생성하도록 더 구성된,시스템."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,상기 컴퓨팅 시스템은 상기 컴퓨팅 시스템과 상기 제1 플레이어 컴퓨팅 장치 사이의 연결과 관련된 하트비트 프로토콜(heartbeat protocol)을 유지하도록 더 구성되고,상기 연결 문제는 상기 하트비트 프로토콜에 적어도 부분적으로 기초하여 검출되는,시스템."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 컴퓨팅 시스템은:상기 컴퓨팅 시스템과 상기 제1 플레이어 컴퓨팅 장치 사이의 상기 연결 문제가 해결되었음을 검출하고;상기 컴퓨팅 시스템에 의한 자동화된 제어 대신에 상기 제1 플레이어 컴퓨팅 장치의 제어 하에 제1 가상 캐릭터를 리턴(return)하고; 및공개특허 10-2020-0115213-4-적어도 상기 제1 플레이어 컴퓨팅 장치로부터의 하나 이상의 플레이어 제어 명령에 기초하여 상기 멀티 플레이어 비디오 게임의 상기 호스팅된 인스턴스에 대한 제3 업데이트된 게임 상태(third updated game state)를 생성하도록 더 구성되는, 시스템."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 플레이어 모방 모델은 상기 데이터 저장소에 저장된 복수의 플레이어 모방 모델 중 어느 하나이며, 상기 복수의 플레이어 모방 모델 각각은 상기 멀티 플레이어 비디오 게임의 다른 인스턴스에서 상기 플레이어가취한 동작의 표시를 포함하는,시스템."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "컴퓨터로 구현되는 방법에 있어서,컴퓨터 하드웨어를 포함하는 컴퓨터 시스템의 제어 하에서, 멀티 플레이어 비디오 게임의 인스턴스를 개시(initiating)하고, 상기 멀티 플레이어 비디오 게임의 상기 인스턴스는 가상 환경에서 상호 작용하는 복수의 가상 개체(virtual entities)를 포함하고, 제1 플레이어 컴퓨팅 장치는 초기에 제1 가상 개체(first virtual entity)를 제어하고, 상기 제1 가상 개체 외에 적어도 하나의 추가적인 가상 개체는 하나 이상의 다른 플레이어 컴퓨팅 장치에 의해 초기에 제어되고;상기 멀티 플레이어 비디오 게임의 상기 인스턴스가 제1 게임 상태(first game state)에 있는 동안, 적어도 상기 제1 플레이어 컴퓨팅 장치로부터 플레이어 제어 명령을 수신하고;적어도 상기 플레이어 제어 명령에 기초해 상기 멀티 플레이어 비디오 게임의 상기 인스턴스에 대한 제1 업데이트된 게임 상태(first updated game state)를 생성하고;상기 제1 업데이트 된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공하고;상기 제1 플레이어 컴퓨팅 장치와 관련된 제어 입력 문제를 검출하고, 상기 제어 입력 문제는 적어도 손실된네트워크 연결, 임계값을 만족하는 네트워크 지연, 상기 제1 플레이어 컴퓨팅 장치로부터 발생하는 제어 명령의예상치 못한 부족, 또는 상기 제1 플레이어 컴퓨팅 장치와 관련된 연결이 끊긴(disconnected) 컨트롤러 장치(controller device) 중 어느 하나이고;상기 제어 입력 문제에 기초하여, 상기 제1 업데이트된 게임 상태와 플레이어 모방 모델에 기초하여 적어도 상기 제1 가상 개체와 관련한 에뮬레이트된 제어 명령(emulated control command)을 결정하고, 상기 플레이어 모방 모델은 상기 멀티 플레이어 비디오 게임의 현재 게임 상태를 입력으로 수신하고 이전에(previously) 관찰된플레이어 행동에 기초한 게임 내 동작(in-game action) 또는 명령을 출력하도록 구성된 트레이닝 모델(trainedmodel)을 포함하고;적어도 상기 에뮬레이트된(emulated) 제어 명령에 기초하여 상기 멀티 플레이어 비디오 게임의 상기 인스턴스에대한 제2 업데이트된 게임 상태(second updated game state)를 생성하고; 및상기 제2 업데이트된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공하는 컴퓨터 실행 가능 명령어(computer executable instruction)로 구성되는 상기 컴퓨터 시스템을 포함하는, 컴퓨터로 구현되는 방법.공개특허 10-2020-0115213-5-청구항 9 제8항에 있어서,상기 제1 가상 개체는 가상 캐릭터, 가상 객체(object), 게임 내 가상 유닛 그룹, 가상 이동체(vehicle), 또는가상 구조물 중 적어도 어느 하나를 포함하는,컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제8항에 있어서,상기 제어 입력 문제가 해결되었음을 검출하는 단계;상기 제1 플레이어 컴퓨팅 장치의 제어 하에 상기 제1 가상 개체를 리턴(return)하는 단계; 및적어도 제1 플레이어 컴퓨팅 장치로부터의 하나 이상의 플레이어 제어 명령에 기초해 상기 멀티 플레이어 비디오 게임의 상기 인스턴스에 대한 제3 업데이트된 게임 상태를 생성하는 단계를 더 포함하는, 컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제8항에 있어서,상기 플레이어 모방 모델은 상기 멀티 플레이어 비디오 게임의 상기 인스턴스 동안 적어도 부분적으로 실시간으로 훈련되고, 상기 멀티 플레이어 비디오 게임의 상기 인스턴스 동안 상기 이전에 관찰된 플레이어 행동의 적어도 제1 부분이관찰되는,컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,상기 이전에 관찰된 플레이어 행동의 제2 부분은 상기 멀티 플레이어 비디오 게임의 이전에 플레이된 인스턴스에서 상기 제1 플레이어 컴퓨팅 장치로부터 수신된 명령과 관련되는,컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제11항에 있어서,상기 이전에 관찰된 플레이어 행동의 제2 부분은 복수의 플레이어의 행동을 포함하는,컴퓨터로 구현되는 방법."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "컴퓨터로 판독가능한 명령어를 저장한 비일시적(non-transitory) 컴퓨터 판독 가능 저장 매체에 있어서, 공개특허 10-2020-0115213-6-실행될 때, 컴퓨팅 시스템이:멀티 플레이어 비디오 게임의 인스턴스를 개시(initiating)하는 단계로, 제1 플레이어 컴퓨팅 장치가 상기 멀티플레이어 비디오 게임에서 제1 가상 개체(first virtual entity)를 초기에 제어하고, 상기 제1 가상 개체 이외에 적어도 하나의 추가적인 가상 개체가 하나 이상의 다른 플레이어 컴퓨팅 장치에 의해 초기에 제어되는 단계;상기 멀티 플레이어 비디오 게임의 상기 인스턴스가 제1 게임 상태(first game state)에 있는 동안, 적어도 상기 제1 플레이어 컴퓨팅 장치로부터 플레이어 제어 명령을 수신하는 단계;적어도 상기 플레이어 제어 명령에 기초하여, 상기 멀티 플레이어 비디오 게임의 상기 인스턴스에 대한 제1 업데이트된 게임 상태(first updated game state)를 생성하는 단계;상기 제1 업데이트된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공하는단계;적어도 (a) 상기 컴퓨팅 시스템과 상기 제1 플레이어 컴퓨팅 장치 상에 동작하는 게임 애플리케이션(application) 간의 네트워크 연결 또는 (b) 상기 제1 플레이어 컴퓨팅 장치와 게임 컨트롤러 간의 연결 중 적어도 어느 하나와 관련된 연결 문제를 검출하는 단계;상기 연결 문제에 기초하여, 상기 제1 업데이트된 게임 상태와 플레이어 모방 모델에 기초하여 적어도 상기 제1가상 개체에 대한 에뮬레이트된 제어 명령(emulated control command)를 결정하는 단계로, 상기 플레이어 모방모델은 상기 멀티 플레이어 비디오 게임의 현재 게임 상태를 입력으로 수신하고 이전에 관찰된 플레이어 행동에기초한 게임 내 동작(in-game action) 또는 명령을 출력하도록 구성된 트레이닝 모델(trained model)을 포함하는 단계; 및적어도 상기 에뮬레이트된 제어 명령에 기초하여 상기 멀티 플레이어 비디오 게임의 상기 인스턴스에 대한 제2업데이트된 게임 상태(second updated game state)를 생성하는 단계를 포함하는 동작을 수행하도록 구성하는 컴퓨터로 판독가능한 명령어를 저장하는, 비일시적(non-transitory) 컴퓨터 판독 가능 저장 매체"}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서, 상기 동작은,상기 제2 업데이트된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치로 제공하는 단계를 더 포함하는, 비일시적 컴퓨터 판독 가능 저장 매체."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제14항에 있어서, 상기 동작은,상기 연결 문제가 해결되었음을 검출하는 단계;상기 제1 플레이어 컴퓨팅 장치의 제어 하에 상기 제1 가상 개체를 리턴(returning)하는 단계; 및적어도 상기 제1 플레이어 컴퓨팅 장치로부터의 하나 이상의 플레이어 제어 명령에 기초하여, 상기 멀티 플레이어 비디오 게임의 상기 인스턴스에 대한 제3 업데이트된 게임 상태(third updated game state)를 생성하는 단계를 더 포함하는, 비일시적 컴퓨터 판독 가능 저장 매체."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "공개특허 10-2020-0115213-7-제14항에 있어서,상기 플레이어 모방 모델은, 상기 멀티 플레이어 비디오 게임의 상기 현재 게임 상태에 따라 다른 동작에 대한 신뢰 점수(confidence score)를 결정하도록 각각 구성된 복수의 스택 가능 레벨(stackable levels)을 포함하는,비일시적 컴퓨터 판독 가능 저장 매체."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서,상기 플레이어 모방 모델은, 상기 현재 게임 상태와 관련한 임계값(threshold)을 만족하는 신뢰 점수를 결정하는 상기 스택 가능 레벨의 제1체크 레벨(first checked level)과 관련된 게임 내 동작(in-game action)을 출력하도록 구성되는,비일시적 컴퓨터 판독 가능 저장 매체."}
{"patent_id": "10-2020-0034403", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제14항에 있어서,상기 플레이어 모방 모델은, 결정 트리(decision tree), 마르코프 모델(Markov model) 또는 딥 뉴럴 네트워크(deep neural network)를 포함하는,비일시적 컴퓨터 판독 가능 저장 매체."}
{"patent_id": "10-2020-0034403", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "플레이어의 장치가 게임 서버와의 네트워크 연결이 끊어졌을 때와 같이, 특정 기준이 충족될 때 비디오 게임에서 플레이어 제어 캐릭터 또는 가상 개체를 적어도 일시적으로 에뮬레이트된 제어로 전환하기 위한 시스템 및 방법 이 개시되어 있다. 캐릭터 또는 가상 개체는 게임 세션이 끝날 때까지 또는 근본적인 연결 문제 또는 다른 문제 가 해결될 때까지 실제 플레이어의 플레이를 에뮬레이트 하거나 모방하는 방식으로 게임에서 계속 작동할 수 있 고, 그로 인해 게임 세션에 참여중인 다른 플레이어들이 연결이 끊긴 해당 플레이어가 계속 플레이했을 때와 동 일하거나 유사한 게임 플레이 경험을 갖도록 한다."}
{"patent_id": "10-2020-0034403", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원에 출원된 바와 같이 외국 또는 국내 우선권 주장이 본 출원 데이터 시트에서 인정되는 임의의 및 모든 출원이 본원에 참조로 포함된다. 최근 몇 년 동안 비디오 게임 애플리케이션의 인기와 복잡성이 증가했다. 최근 몇 년 간 인기있는 비디오 게임 은 멀티 플레이어 온라인 게임으로, 플레이어는 각각 자신의 휴대폰, 콘솔 시스템, 개인용 컴퓨터 또는 기타 게 임 장치를 사용해 실시간으로 다른 실제 플레이어와 함께 및/또는 대항하여 게임을 한다."}
{"patent_id": "10-2020-0034403", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "일반적인 온라인 멀티 플레이어 게임에서, 각 플레이어 게임 장치는 인터넷을 통해 지정된 비디오 게임과 연결 된 서버와 통신한다. 서버는 종종 플레이어들이 상호 작용하는 가상 환경과 게임에 관한 다양한 플레이어들의 상호 작용을 반영하는 공유 게임 상태(shared game state) 및/또는 가상 환경 데이터(virtual environment data)를 유지 관리해야 한다."}
{"patent_id": "10-2020-0034403", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "종종 멀티 플레이어 게임은 원격에 위치한 다수의 플레이어가 같은 팀, 파티(party), 클랜(clan) 또는 다른 그 룹과 같은 협력 방식으로 함께 플레이 할 수 있게 한다. 협력적인 게임 플레이 세션 동안 플레이어 중 한 명이특정 시점에서 계속 플레이 할 수 없는 경우, 나머지 플레이어는 일반적으로 좌절하고 그 플레이어가 계속 플레 이한 경우와 비교해 불리하다(예를 들어, 상대 팀에는 네 명의 경쟁 플레이어가 있는 경기에서, 그 팀은 이제 적극적으로 플레이하는 세 명의 플레이어만 있음). 온라인 게임 환경에서 플레이어가 게임 플레이 세션 도중에 게임을 계속할 수 없는 이유는, 그 플레이어의 장치가 서버와 네트워크 연결이 끊어지거나, 그 플레이어의 장치 가 적절한 게임 플레이를 방해하는 과도한 네트워크 지연을 겪거나, 그 플레이어의 장치에 작동하는 게임 애플 리케이션이 충돌하거나 멈추는 것을 포함한다."}
{"patent_id": "10-2020-0034403", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시의 시스템, 방법 및 장치는 각각 몇 가지 혁신적인 양태를 가지며, 그 중 어느 것도 여기에 개시된 모든 바람직한 특징에 대해 단독으로 책임을 지지 않는다. 일부 실시예에서, 시스템은 하나 이상의 비디오 게임과 관련된 플레이어 모방 모델을 저장하는 데이터 저장소를 포함할 수 있으며, 플레이어 모방 모델은 복수의 게임 플레이 상황에서 각각 플레이어에 의해 취해진 동작의 표 시를 포함한다. 시스템은 데이터 저장소와 전자적(electronic) 통신하고, 컴퓨터로 판독 가능한 명령어를 실행 하도록 구성된 컴퓨팅 시스템을 더 포함할 수 있고, 상기 명령어는 멀티 플레이어 비디오 게임의 호스팅된 인스 턴스(hosted instance)를 개시(initiate)하도록 하되, 상기 멀티플레이어 비디오 게임의 상기 호스팅된 인스턴 스는 가상 환경에서 상호 작용(interacting)하는 복수의 가상 캐릭터를 포함하고, 제1 플레이어 컴퓨팅 장치 (first player computing device)는 초기에 제1 가상 캐릭터(first virtual character)를 제어하고, 상기 제1 가상 캐릭터 이외의 적어도 하나의 추가적인 가상 캐릭터가 하나 이상의 다른 플레이어 컴퓨팅 장치에 의해 초 기에 제어되고; 상기 멀티 플레이어 비디오 게임의 상기 호스팅된 인스턴스가 제1 게임 상태(first game stat e)에 있는 동안, 적어도 상기 제1 플레이어 컴퓨팅 장치로부터 플레이어 제어 명령(player control commands)을 수신하며; 적어도 상기 플레이어 제어 명령에 기초하여 상기 멀티 플레이어 비디오 게임의 상기 호스팅된 인스 턴스에 대한 제1 업데이트된 게임 상태(first updated game state)를 생성하고; 상기 제1 업데이트된 게임 상태 와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공하고; 상기 제1 게임 상태 및 상기 제1 플레이어 컴퓨팅 장치로부터의 상기 플레이어 제어 명령에 기초하여 상기 플레이어 모방 모델을 업데이트하고; 상기 컴퓨팅 시스템과 상기 제1 플레이어 컴퓨팅 장치 사이의 연결 문제를 검출하되, 상기 연결 문제는 손실된 네트워크 연결, 임계값(threshold)을 만족하는 네트워크 지연, 또는 상기 제1 플레이어 컴퓨팅 장치로부터 발생 하는 제어 명령의 예상치 못한 부족(unexpected lack) 중 적어도 어느 하나를 포함하고; 상기 연결 문제에 기초 하여, 상기 제1 플레이어 컴퓨팅 장치에 의한 제어 대신에 상기 컴퓨팅 시스템에 의한 자동화된 제어 하에 있도 록 상기 제1 가상 캐릭터를 전환(switch)하고; 상기 제1 업데이트된 게임 상태와 상기 플레이어 모방 모델에 기 초하여 적어도 상기 제1 가상 캐릭터와 관련한 에뮬레이트된 제어 명령(emulated control command)을 결정하고; 적어도 상기 에뮬레이트된 제어 명령에 기초하여 상기 멀티 플레이어 비디오 게임의 상기 호스팅된 인스턴스에 대한 제2 업데이트된 게임 상태(second updated game state)를 생성하고; 및 상기 제2 업데이트된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공하도록 상기 컴퓨팅 시스템(computing system)을 구성한다. 상기 컴퓨팅 시스템은 다음 특징 중 하나, 전부, 또는 임의의 조합을 가질 수 있다. 상기 컴퓨팅 시스템은 제1 기간(first time period)에 걸쳐 상기 플레이어에 의해 입력된 플레이어 제어 명령의 결과로서 수행된 복수의 게임 내 동작(in-game action)의 자동화된 분석에 기초하여 상기 플레이어 모방 모델을 생성하도록 추가로 구성 될 수 있고, 상기 플레이어는 상기 제1 플레이어 컴퓨팅 장치를 이용하고, 상기 플레이어 모방 모델은 상기 플 레이어에 특정된다(specific). 제1 기간은 상기 멀티 플레이어 비디오 게임의 복수의 인스턴스를 포함할 수 있 고, 상기 복수의 인스턴스는 상기 멀티 플레이어 비디오 게임의 상기 호스팅된 인스턴스를 포함한다. 제1 기간 은 상기 플레이어에 의해 구성될 수 있고, 상기 컴퓨팅 시스템은 상기 플레이어가 (a) 기간 또는 (b) 상기 플레 이어 모방 모델을 생성할 때 상기 컴퓨팅 시스템에 의해 고려되는 하나 이상의 이전(previous) 게임 인스턴스를 선택할 수 있도록 하는 사용자 인터페이스를 생성하도록 더 구성될 수 있다. 상기 컴퓨팅 시스템은 컴퓨팅 시 스템과 상기 제1 플레이어 컴퓨팅 장치 사이의 연결과 관련된 하트비트 프로토콜(heartbeat protocol)을 유지하 도록 더 구성될 수 있으며, 상기 연결 문제는 상기 하트비트 프로토콜에 적어도 부분적으로 기초하여 검출된다. 일부 실시예에서, 컴퓨팅 시스템은 또한 컴퓨터 시스템과 상기 제1 플레이어 컴퓨팅 장치 사이의 연결 문제가 해결되었음을 검출하고, 상기 컴퓨팅 시스템에 의한 자동화된 제어 대신에 상기 제1 플레이어 컴퓨팅 장치의 제 어 하에 제1 가상 캐릭터(first virtual character)를 리턴(return)하고; 및 적어도 상기 제1 플레이어 컴퓨팅장치로부터의 하나 이상의 플레이어 제어 명령에 기초하여 멀티 플레이어 비디오 게임의 호스팅된 인스턴스에 대한 제3 업데이트된 게임 상태(third updated state)를 생성하도록 구성된다. 플레이어 모방 모델은 데이터 저장소에 저장된 복수의 플레이어 모방 모델 중 어느 하나일 수 있으며, 복수의 플레이어 모방 모델 각각은 멀 티 플레이어 비디오 게임의 다른 인스턴스에서 상기 플레이어가 취한 동작의 표시를 포함한다. 일부 실시예에서, 컴퓨터로 구현되는 방법은, 컴퓨터 하드웨어를 포함하는 컴퓨터 시스템의 제어 하에서, 컴퓨 터 실행 가능 명령어로 구성된 컴퓨터 시스템을 포함할 수 있고, 상기 명령어는: 멀티 플레이어 비디오 게임의 인스턴스를 개시(initiating)하고, 상기 멀티 플레이어 비디오 게임의 상기 인스턴스는 가상 환경에서 상호 작 용하는 복수의 가상 개체(virtual entities)를 포함하고, 제1 플레이어 컴퓨팅 장치는 초기에 제1 가상 개체 (first virtual entity)를 제어하고, 상기 제1 가상 개체 외에 적어도 하나의 추가적인 가상 개체는 하나 이상 의 다른 플레이어 컴퓨팅 장치에 의해 초기에 제어되고; 상기 멀티 플레이어 비디오 게임의 상기 인스턴스가 제 1 게임 상태(first game state)에 있는 동안, 적어도 상기 제1 플레이어 컴퓨팅 장치로부터 플레이어 제어 명령 을 수신하고; 적어도 상기 플레이어 제어 명령에 기초해 상기 멀티 플레이어 비디오 게임의 상기 인스턴스에 대 한 제1 업데이트된 게임 상태(first updated game state)를 생성하고; 상기 제1 업데이트 된 게임 상태와 관련 된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공하고; 상기 제1 플레이어 컴퓨팅 장치와 관련된 제어 입력 문제를 검출하고, 상기 제어 입력 문제는 적어도 손실된 네트워크 연결, 임계값을 만족하는 네트워 크 지연, 상기 제1 플레이어 컴퓨팅 장치로부터 발생하는 제어 명령의 예상치 못한 부족, 또는 상기 제1 플레이 어 컴퓨팅 장치와 관련된 연결이 끊긴(disconnected) 컨트롤러 장치(controller device) 중 어느 하나이고; 상 기 제어 입력 문제에 기초하여, 상기 제1 업데이트된 게임 상태와 플레이어 모방 모델에 기초하여 적어도 상기 제1 가상 개체와 관련한 에뮬레이트된 제어 명령(emulated control command)을 결정하고, 상기 플레이어 모방 모델은 상기 멀티 플레이어 비디오 게임의 현재 게임 상태를 입력으로 수신하고 이전에(previously) 관찰된 플 레이어 행동에 기초한 게임 내 동작(in-game action) 또는 명령을 출력하도록 구성된 트레이닝 모델(trained model)을 포함하고; 적어도 상기 에뮬레이트된(emulated) 제어 명령에 기초하여 상기 멀티 플레이어 비디오 게 임의 상기 인스턴스에 대한 제2 업데이트된 게임 상태(second updated game state)를 생성하고; 및 상기 제2 업 데이트된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공한다. 상기 컴퓨터로 구현되는 방법은 다음 특징들의 하나, 전부 또는 임의의 조합을 더 포함할 수 있다. 상기 제1 가상 개체는 가상 캐릭터, 가상 객체(object), 게임 내 가상 유닛 그룹, 가상 이동체(vehicle), 또는 가상 구조 물 중 적어도 어느 하나를 포함할 수 있다. 상기 방법은 상기 제어 입력 문제가 해결되었음을 검출하는 단계; 상기 제1 플레이어 컴퓨팅 장치의 제어 하에 상기 제1 가상 개체를 리턴하는 단계; 및 적어도 제1 플레이어 컴 퓨팅 장치로부터의 하나 이상의 플레이어 제어 명령에 기초해 멀티 플레이어 비디오 게임의 인스턴스에 대한 제 3 업데이트된 게임 상태를 생성하는 단계를 더 포함할 수 있다. 상기 플레이어 모방 모델은 멀티 플레이어 비 디오 게임의 인스턴스 동안 적어도 부분적으로 실시간으로 훈련될 수 있고, 멀티 플레이어 비디오 게임의 인스 턴스 동안 이전에 관찰된 플레이어 행동의 적어도 제1 부분이 관찰된다. 이전에 관찰된 플레이어 행동의 제2 부분은 멀티 플레이어 비디오 게임의 이전에 플레이된 인스턴스에서 제1 플레이어 컴퓨팅 장치로부터 수신된 명 령과 관련될 수 있다. 이전에 관찰된 플레이어 행동의 제2 부분은 복수의 플레이어의 행동을 포함할 수 있다. 일부 실시예에서, 비일시적 컴퓨터 판독 가능 저장 매체는 실행될 때, 컴퓨팅 시스템이 동작을 수행하도록 구성 하는 컴퓨터로 판독 가능한 명령어를 그곳에 저장할 수 있다. 상기 동작은: 멀티 플레이어 비디오 게임의 인스 턴스를 개시(initiating)하는 단계로, 제1 플레이어 컴퓨팅 장치가 상기 멀티 플레이어 비디오 게임에서 제1 가 상 개체(first virtual entity)를 초기에 제어하고, 상기 제1 가상 개체 이외에 적어도 하나의 추가적인 가상 개체가 하나 이상의 다른 플레이어 컴퓨팅 장치에 의해 초기에 제어되는 단계; 상기 멀티 플레이어 비디오 게임 의 상기 인스턴스가 제1 게임 상태(first game state)에 있는 동안, 적어도 상기 제1 플레이어 컴퓨팅 장치로부 터 플레이어 제어 명령을 수신하는 단계; 적어도 상기 플레이어 제어 명령에 기초하여, 상기 멀티 플레이어 비 디오 게임의 상기 인스턴스에 대한 제1 업데이트된 게임 상태(first updated game state)를 생성하는 단계; 상 기 제1 업데이트된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치에 제공하는 단계; 적어도 (a) 상기 컴퓨팅 시스템과 상기 제1 플레이어 컴퓨팅 장치 상에 동작하는 게임 애플리케이션 (application) 간의 네트워크 연결 또는 (b) 상기 제1 플레이어 컴퓨팅 장치와 게임 컨트롤러 간의 연결 중 적 어도 어느 하나와 관련된 연결 문제를 검출하는 단계; 상기 연결 문제에 기초하여, 상기 제1 업데이트된 게임 상태와 플레이어 모방 모델에 기초하여 적어도 상기 제1 가상 개체에 대한 에뮬레이트된 제어 명령(emulated control command)를 결정하는 단계로, 상기 플레이어 모방 모델은 상기 멀티 플레이어 비디오 게임의 현재 게임 상태를 입력으로 수신하고 이전에 관찰된 플레이어 행동에 기초한 게임 내 동작(in-game action) 또는 명령을 출력하도록 구성된 트레이닝 모델(trained model)을 포함하는 단계; 및 적어도 상기 에뮬레이트된 제어 명령에기초하여 상기 멀티 플레이어 비디오 게임의 상기 인스턴스에 대한 제2 업데이트된 게임 상태(second updated game state)를 생성하는 단계를 포함할 수 있다. 상기 컴퓨터 판독 가능 매체는 다음 특징들의 하나, 전부 또는 임의의 조합을 더 포함할 수 있다. 상기 동작은 상기 제2 업데이트된 게임 상태와 관련된 정보를 상기 하나 이상의 다른 플레이어 컴퓨팅 장치로 제공하는 단계 를 더 포함할 수 있다. 상기 동작은 상기 연결 문제가 해결되었음을 검출하는 단계; 상기 제1 플레이어 컴퓨팅 장치의 제어 하에 상기 제1 가상 개체를 리턴하는 단계; 및 적어도 상기 제1 플레이어 컴퓨팅 장치로부터의 하 나 이상의 플레이어 제어 명령에 기초하여, 멀티 플레이어 비디오 게임의 상기 인스턴스에 대한 제3 업데이트된 게임 상태(third updated game state)를 생성하는 단계를 더 포함할 수 있다. 상기 플레이어 모방 모델은 멀티 플레이어 비디오 게임의 현재 게임 상태에 따라 다른 동작에 대한 신뢰 점수(confidence score)를 결정하도록 각각 구성된 복수의 스택 가능 레벨(stackable levels)을 포함할 수 있다. 플레이어 모방 모델은 현재 게임 상 태와 관련한 임계값(threshold)을 만족하는 신뢰 점수를 결정하는 상기 스택 가능 레벨의 제1 체크 레벨(first checked level)과 관련된 게임 내 동작(in-game action)을 출력하도록 구성될 수 있다. 플레이어 모방 모델은 결정 트리, 마르코프 모델 또는 딥 뉴럴 네트워크를 포함할 수 있다. 비록 특정 실시예 및 예시가 여기 개시되어 있지만, 발명의 주제는 구체적으로 개시된 실시예의 예시를 넘어서 다른 대안적인 실시예 및/또는 용도, 및 그 수정 및 그에 상응하는 것으로 확장된다."}
{"patent_id": "10-2020-0034403", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 명세서에 개시되어 있다."}
{"patent_id": "10-2020-0034403", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "개요 본 개시의 양태는, 플레이어의 장치가 게임에 대한 네트워크 연결을 상실한 경우나 네트워크 지연이 임계값을 초과하는 경우와 같이, 특정 기준이 충족될 때 비디오 게임의 플레이어 제어 캐릭터를 비 플레이어 캐릭터(non- player character; NPC)로 효과적으로 전환하는 것에 관한 것이다. NPC는 게임 세션이 끝날 때까지 또는 플레 이어가 온라인으로 돌아올 때까지 실제 플레이어의 게임을 에뮬레이트 (emulate) 하거나 모방하는 방식으로 게 임 내에서 계속 행동할 수 있어서, 그 게임 세션에 참여하는 다른 플레이어가 연결이 끊긴 플레이어가 계속 플 레이 했을 경우 그들이 경험할 수 있었던 것과 같거나 비슷한 게임 플레이를 경험할 수 있다.많은 비디오 게임은 플레이어 제어 가상 개체(entities) 또는 캐릭터뿐만 아니라 소프트웨어 제어 가상 개체 또 는 캐릭터를 포함한다. 비디오 게임에서, 이러한 소프트웨어 제어 또는 프로그램 제어 가상 개체는 때때로 컴 퓨터 플레이어, 봇(bot), 인공지능(artificial intelligence; AI) 유닛, AI 캐릭터, 또는 비 플레이어 캐릭터 (NPC)로 지칭될 수 있다. NPC는 게임 내 자극(예를 들어, 게임 내 동작 또는 다른 NPC나 플레이어 제어 캐릭터 와 관련된 사건)에 대해 인간 플레이어에게 사실적으로 보이는 방식으로 반응하도록 프로그래밍 될 수 있다. 전통적으로, 주어진 NPC의 행동은 일반적으로 게임 개발 프로세스의 일부로 미리 프로그래밍 된다. 그러나, 본 개시의 양태는 게임 세션 또는 다수의 게임 세션과 같이 주어진 시간 동안 특정 플레이어의 플레이를 모방하거 나 에뮬레이트(emulate)할 수 있는 개선된 AI 또는 NPC 행동 모델링을 포함한다. 본 개시의 양태들에 따르면, 특정 플레이어에 대한 플레이어 모방 모델은 다양한 게임 상태에 응답하여 수행되 는 플레이어의 제어 명령 또는 동작을 분석하는 학습 프로세스에 기초하여 하나 이상의 게임 플레이 세션 동안 동적으로 구성될 수 있다. 본원에 기재된 바와 같은 플레이어 모방 시스템이 게임 중 플레이어의 제어를 인계 해야 한다고 결정할 때(예컨대, 플레이어의 네트워크가 끊긴 것을 검출하는 시스템에 응답하여), 트레이닝된 플 레이어 모방 모델은 플레이어 모방 시스템에 의해 사용되어 현재 게임 상태에 기초한, 다른 플레이어에게 연결 이 끊긴 플레이어가 여전히 연결되어 있고 플레이 중이었다면 했을 제어나 동작으로 보이는 제어 또는 액션을 에뮬레이트(emulate)할 수 있다. 따라서 이전에 상기 플레이어에 의해 제어되던 가상 캐릭터가, 실제로는 가상 캐릭터가 플레이어 모방 시스템의 자동화된 제어 하에 있는 경우에도 게임 내의 상대방(opponents) 및/또는 팀 원(teammates)에게는 여전히 상기 플레이어에 의해 제어되는 것으로 보일 수 있다. 본원에서 사용되는 바와 같이, 게임 상태는 일반적으로 주어진 스냅샷 순간(snapshot instant)에 관한 데이터를 지칭할 수 있고, 게임의 유형 및 게임 환경이 컴퓨터 메모리에 표현되는 방식에 따라 다른 정보를 포함할 수 있 다. 게임 상태 정보는 캐릭터 상태, 캐릭터 동작, 환경 상태, 게임 내 객체(object) 및/또는 캐릭터에 대한 위 치 정보, 게임 내 캐릭터 및/또는 객체에 대한 비 위치 정보(non-positional information), 속도, 방향, 건강 및 다른 속성, 게임 모드, 레벨, 및/또는 게임 애플리케이션의 런타임(runtime) 상태와 관련된 기타 정보와 같 은 게임 데이터를 포함할 수 있다. 예를 들어, 게임 상태 정보는 가상 세계에서 상호 작용할 수 있는 여러 가 상 캐릭터(플레이어 제어 캐릭터 및 NPC 둘 다와 같은) 각각에 대해, 캐릭터 위치, 캐릭터 방향, 현재 캐릭터 동작, 속성, 및/또는 게임 애플리케이션의 상태에 기여하는 다른 정보를 포함할 수 있다. 게임 상태 정보는 캐 릭터 이동 위치와 같이 지속적으로 변하는 동적(dynamic) 상태 정보 및 게임 내 게임 레벨이나 맵의 식별과 같 은 정적(static) 상태 정보를 포함할 수 있다. 일부 실시예에서, 게임 상태 정보의 적어도 일부는 초당 여러 번과 같이 주기적으로 업데이트 될 수 있다. 일부 실시예에서, 게임 상태 정보는 이벤트 기반으로 업데이트 될 수 있다. 일부 실시 예에서, 게임 상태 정보는 개별 게임 플레이어 컴퓨팅 시스템과 다양한 다른 플레이어들의 게임 내 동작을 반영하는 게임 상태 정보에 관한 업데이트를 플레이어 컴퓨팅 시스템에 주기적으로 전송하는 서 버 사이에서 비동기적으로(asynchronously) 유지될 수 있다. 플레이어 모방 시스템 및 동작 환경 개요 도 1은 프록시 제어 특징을 갖는 플레이어 모방 시스템의 하나 이상의 실시예를 구현하기 위한 네트워크 컴퓨팅 환경의 실시예를 도시한다. 환경은 네트워크, 플레이어 컴퓨팅 시스템, 하나 이상 의 다른 플레이어 컴퓨팅 시스템 및 인터랙티브 컴퓨팅 시스템(interactive computing system)을 포 함한다. 논의를 단순화하고 본 개시를 제한하지 않기 위해, 도 1은 하나의 인터랙티브 컴퓨팅 시스템을 도시하지만, 다수의 시스템이 사용될 수 있다. 인터랙티브 컴퓨팅 시스템은 애플리케이션 호스트 시스템(application host system), 하나 이상의 데 이터 저장소 및 플레이어 모방 시스템을 포함할 수 있다. 플레이어 모방 시스템은 데이터 저장 소 및/또는 애플리케이션 호스트 시스템과 통신하여 게임 애플리케이션과 관련된 데이터를 획득하고 플레이어가 네트워크 단절 또는 본원에서 논의되는 다른 제어 문제를 겪을 때 게임 애플리케이션 내에서 자동화 된 플레이어 제어 인계를 제공할 수 있다. 플레이어 모방 시스템은 네트워크를 통해 플레이어 컴퓨 팅 시스템 및/또는 하나 이상의 다른 플레이어 컴퓨팅 시스템과 추가로 또는 대안적으로 통신할 수 있다. 하나의 네트워크만이 도시되어 있지만, 다수의 개별 및/또는 분산 네트워크가 존재할 수 있다. 이 들 사이의 상호 작용 또는 통신을 포함하여, 도 1에 도시된 다양한 시스템 및 다른 컴포넌트가 이하에서 보다상세하게 기재될 것이다. A. 인터랙티브 컴퓨팅 시스템 도시된 실시예에서, 인터랙티브 컴퓨팅 시스템은 애플리케이션 호스트 시스템, 데이터 저장소 및 플레이어 모방 시스템을 포함한다. 이 시스템들은 서로 통신할 수 있다. 예를 들어, 플레이어 모방 시스템은 하나 이상의 애플리케이션 호스트 시스템으로부터 게임 애플리케이션과 관련된 데이터(게임 상태 정보와 같은)를 획득하고, 하나 이상의 애플리케이션 호스트 시스템으로 에뮬레이트된 제어 데이터를 제공할 수 있다. 애플리케이션 호스트 시스템은 게임 애플리케이션을 실행 및/또는 호스트하기 위해 데이 터 저장소와 통신할 수 있다. 특정 실시예에서, 인터랙티브 컴퓨팅 시스템은 플레이어 컴퓨팅 시스 템(102 및 103)과 같은 다양한 플레이어 컴퓨팅 시스템을 이용하는 플레이어에 의해 플레이되는 싱글 플레이어 또는 멀티 플레이어 비디오 게임에 대한 네트워크 기반 지원을 제공하는 게임 서버로 간주될 수 있다. 1. 애플리케이션 호스트 시스템 애플리케이션 호스트 시스템은 플레이어 컴퓨팅 시스템 상에서 동작하는 게임 애플리케이션 및/ 또는 인터랙티브 컴퓨팅 시스템 상의 호스트 애플리케이션(미도시)의 일부를 실행하도록 구성될 수 있다. 특정 실시예에서, 애플리케이션 호스트 시스템은 게임 애플리케이션 및/또는 호스트 애플리케이션의 일부를 실행하는 대신 또는 그에 더해 다른 애플리케이션을 실행할 수 있으며, 이는 게임 애플리케이션의 게임 플레이 세션 실행 중 게임 애플리케이션과 보완 및/또는 상호 작용할 수 있다. 플레이어 컴퓨팅 시 스템의 하나 이상의 게임 애플리케이션과 상호 작용하는 애플리케이션 호스트 시스템에 적어도 부분적으로 기초 하여 실행되는 게임의 인스턴스는 본원에서 게임의 호스팅 된 인스턴스라고 지칭될 수 있다. 애플리케이션 호 스트 시스템에 대한 자세한 내용은 이하 기재되어 있다. 인터랙티브 컴퓨팅 시스템은 다수의 플레이어 또는 컴퓨팅 시스템이 게임 애플리케이션 및/또는 호스 트 애플리케이션의 일부에 액세스(access)할 수 있게 할 수 있다. 일부 실시예에서, 인터랙티브 컴퓨팅 시스템 의 애플리케이션 호스트 시스템에 의해 실행되는 게임 애플리케이션의 일부는 지속적인 가상 세 계(persistent virtual world)를 생성할 수 있다. 이 지속적인 가상 세계 또는 가상 환경은 한 명 이상의 플레 이어가 가상 세계 및 서로와 동기(synchronous) 및/또는 비동기(asynchronous) 방식으로 상호 작용할 수 있게 한다. 일부 경우, 지속적인 가상 세계의 다수의 인스턴스가 인터랙티브 컴퓨팅 시스템에 의해 생성되거나 호스팅 될 수 있다. 한 플레이어 집단은 지속적인 가상 세계의 한 인스턴스에 할당되거나 액세스할 수 있는 반 면, 다른 플레이어 집단은 지속적인 가상 세계의 다른 인스턴스에 할당되거나 액세스할 수 있다. 일부 게임에 서, 스포츠 비디오 게임의 인스턴스 내에서 같은 팀에 배치되거나, 임의의 다양한 타입이나 장르의 게임의 경기, 미션, 퀘스트, 캠페인 또는 기타 협동 모드 내에서 함께 그룹화 되는 것과 같이, 한 플레이어 집단은 가 상 세계의 동일한 인스턴스 내에서 서로 협력적으로 상호 작용할 수 있다. 일부 실시예에서, 애플리케이션 호스트 시스템은 게임 환경의 다양한 양태를 실행하기 위한 호스팅 시스템 을 실행할 수 있다. 예를 들어, 일실시예에서, 게임 애플리케이션은 1인칭 슈팅 게임 또는 스포츠 게임과 같은 경쟁 게임일 수 있고, 호스트 애플리케이션 시스템은 멀티 플레이어 게임 인스턴스를 호스팅하기 위 한 전용 호스팅 서비스를 제공하거나, 플레이어 컴퓨팅 장치에 의해 호스팅되는 게임 인스턴스의 생성을 용이하 게 할 수 있다. 일부 실시예에서, 애플리케이션 호스트 시스템은 플레이어들이 서로 상호 작용하도록 로 비(lobby) 또는 다른 환경을 제공할 수 있다. 게임 인스턴스 내에서 플레이어 간의 게임 내 상호 작용은 플레 이 중인 게임의 유형에 따라 크게 달라질 수 있다. 예를 들어, 한 게임에서는 한 그룹의 플레이어가 협력하여 가상 도시를 건설할 수 있는 한편, 다른 게임에서 플레이어들은 전투 시뮬레이션에서 서로를 쏘려고 시도하는 경쟁 상황에 놓일 수 있다. 본 개시의 양태는 슈팅 게임(1인칭 또는 3인칭 슈팅 게임과 같은), 생존 게임, 모 험 게임, 스포츠 게임, 플랫폼 게임, 롤 플레잉 게임, 시뮬레이션 게임, 전략 게임, 레이싱 게임 등의 비디오 게임의 거의 모든 장르에 이점을 제공할 수 있다. 2. 플레이어 모방 시스템 본원에서 더 상세하게 기재되는 바와 같이, 플레이어 모방 시스템은 한 명 이상의 특정 플레이어에 대한 플레이어 모방 모델을 생성하기 위해 다른 시스템과 통신할 수 있고, 플레이어의 연결이 끊어지거나 플레이어 모방 시스템에 의해 인계된 제어를 가져야 하는 시점을 검출할 수 있고, 구성된 플레이어 모방 모델을 사용해 플레이어의 제어를 에뮬레이트(emulate)할 수 있다. 플레이어 모방 시스템은 본원에 기재된 다양한 기능을 구현하기 위한 하나 이상의 시스템, 서브 시스템(subsystem) 또는 컴포넌트(component)를 포함할 수 있다. 예를 들어, 플레이어 모방 시스템은 컨트롤러 소스 스위치(controller source switch), 컨트롤러 프 록시 컴포넌트(controller proxy component), 플레이어 하트비트 컴포넌트(player heartbeat component) 및 게임 플레이 모델링 시스템을 포함할 수 있다. 이러한 예시적인 시스템 또는 컴포넌 트는 제한적인 것으로 의도되지 않으며, 플레이어 모방 시스템은 도시되거나 기재된 것보다 더 적거나 더 많은 시스템 또는 컴포넌트를 포함할 수 있다. 플레이어 모방 시스템 및 그 다양한 시스템 또는 컴포넌트는 다수의 컴퓨팅 시스템에 걸쳐 분산될 수 있다. 플레이어 모방 시스템의 다양한 시스템은 서로 통신하여 데이터를 획득, 분석 및 생성할 수 있다. 다양한 시스템이 인터랙티브 컴퓨팅 시스템 및/또는 플레이어 모방 시스템의 일부로서 도시되어 있지 만, 각 시스템의 기능은 다른 또는 다수의 컴퓨팅 시스템 또는 장치에 의해 구현될 수 있음을 이해할 것이다. 또한, 싱글 시스템은 서로 통신하는 다수의 시스템에 의해 제공되거나 구현되는 것으로 본원에 기재된 기능을 구현할 수 있다. 유사하게, 인터랙티브 컴퓨팅 시스템의 플레이어 모방 시스템에 의해 제공되는 것으로 기재된 기능은 다른 실시예에서는 플레이어 컴퓨팅 시스템에서 구현될 수 있다. 플레이어 모방 시스 템의 각 시스템 또는 컴포넌트는 도 2의 예시적인 데이터 흐름과 관련하여 아래에서 더 기재된다. 플레이어 모방 시스템은 플레이어 모방 모델 데이터 저장소를 포함할 수 있다. 데이터 저장소 는 게임 상태를 입력으로 수신하고 실제 플레이어가 주어진 게임 상태에서 할 예측된 동작 또는 제어 명령을 출 력하도록 트레이닝된 모델과 같은 플레이어 모방 모델을 저장하도록 구성될 수 있다. 플레이어 모방 모델은 아 래에서 더 상세히 기재될 것이며, 하나 이상의 일반 모델 및 하나 이상의 플레이어 특정 모델을 포함할 수 있고, 플레이어 특정 모델은 주어진 플레이어와 관련된 게임 플레이 데이터의 특정 시간 주기에 기초해 개발될 수 있다. 데이터 저장소는 다수의 컴퓨팅 장치에 걸쳐 분산될 수 있다(예를 들어, 도 5의 컴퓨팅 장치 참조). 일부 실시예에서, 데이터 저장소는 데이터가 다른 위치에 저장될 수 있는 네트워크 기반 저 장 시스템일 수 있다. 3. 인터랙티브 컴퓨팅 시스템의 데이터 저장소 인터랙티브 컴퓨팅 시스템은 데이터 저장소를 포함할 수 있다. 데이터 저장소는 다른 시스템에 의해 얻어진 데이터, 예를 들어, 원격 측정 데이터(telemetry data), 비디오 데이터, 게임 상태 정보, 사용자 데이터 등을 저장하도록 구성될 수 있다. 일부 실시예에서, 데이터 저장소는 비디오 게임 퍼블리셔(video game publisher), 게임 플랫폼 제공자 또는 사용자가 복수의 다른 비디오 게임에 걸쳐 선호도, 가상 캐릭터, 아 바타, 업적, 및/또는 다른 데이터를 유지할 수 있게 하는 다른 서비스와 관련된 사용자 계정 데이터를 저장할 수 있다. 예를 들어, 데이터 저장소에 저장된 계정 식별자(account identifier) 데이터는 저장된 플레이 어 모방 모델을 특정 플레이어의 계정과 연관시키기 위해 플레이어 모방 시스템에 의해 사용될 수 있다. 데이터 저장소는 다수의 컴퓨팅 장치에 걸쳐 분산될 수 있다(예를 들어, 도 5의 컴퓨팅 장치 참조). 일부 실시예에서, 데이터 저장소는 데이터가 다른 위치에 저장될 수 있는 네트워크 기반 저장 시스템일 수 있다. B. 플레이어 컴퓨팅 시스템 플레이어 컴퓨팅 시스템 및 다른 플레이어 컴퓨팅 시스템 각각은 비디오 게임의 다른 플레이어와 같 은 다른 사용자에 의해 제어될 수 있다. 플레이어 컴퓨팅 시스템은 통신 네트워크를 통한 통신을 확 립하기 위한 하드웨어 및 소프트웨어 컴포넌트를 포함할 수 있다. 예를 들어, 플레이어 컴퓨팅 시스템은 하나 이상의 네트워크(예를 들어, 인터넷 또는 인트라넷)를 통한 통신을 용이하게 하는 네트워킹 장비 및 네트 워크 소프트웨어 애플리케이션(예를 들어, 웹 브라우저)이 구비될 수 있다. 플레이어 컴퓨팅 시스템은 중 앙 처리 장치 및 아키텍쳐(architectures), 메모리, 대용량 저장 장치, 그래픽 처리 장치, 통신 네트워크 이용 가능성(availability) 및 대역폭(bandwidth) 등과 같은 다양한 로컬 컴퓨팅 자원을 가질 수 있다. 또한, 플레 이어 컴퓨팅 시스템은 임의의 유형의 컴퓨팅 시스템을 포함할 수 있다. 예를 들어, 플레이어 컴퓨팅 시스 템은 몇 가지 예로 들어 데스크탑, 랩탑, 게임 애플리케이션 플랫폼, 게임 콘솔 시스템, 가상 현실 시스템, 증강 현실 시스템, 텔레비전 셋톱 박스, 텔레비전(예를 들어, 인터넷 TV), 네트워크 가능 키오스크, 자 동차 콘솔 장치, 컴퓨터화된 가전기구, 웨어러블(wearable) 장치(예를 들어, 스마트 와치 및 컴퓨팅 기능이 있 는 안경), 및 무선 모바일 장치(예를 들어, 스마트폰, PDA, 태블릿 등)와 같은 임의의 유형의 컴퓨팅 장치(들) 를 포함할 수 있다.일부 실시예에서, 플레이어 컴퓨팅 시스템은 이하 기재되는 하나 이상의 컴포넌트 또는 실시예를 포함할 수 있다. 일부 실시예에서, 개별적인 다른 플레이어 컴퓨팅 시스템은 플레이어 컴퓨팅 시스템과 유 사한 컴포넌트를 포함할 수 있지만, 또한 차이가 있을 수 있다(예를 들어, 한 플레이어는 모바일 장치로부터 주 어진 게임을 할 수 있는 반면, 다른 플레이어는 데스크톱 컴퓨터 또는 게임 콘솔 시스템으로 같은 게임을 할 수 있다). 1. 게임 애플리케이션 및 호스트 애플리케이션 시스템 플레이어 컴퓨팅 시스템 및 각각의 다른 플레이어 컴퓨팅 시스템은 로컬 및/또는 분산된 환경에서 저 장 및/또는 실행될 수 있는 하나 이상의 게임 애플리케이션을 실행할 수 있다. 로컬로 실행되는 게임 애 플리케이션에서, 일반적으로, 게임은 게임 애플리케이션을 실행하기 위해 외부 컴퓨팅 시스템(예를 들어, 인터랙티브 컴퓨팅 시스템)에 의존하거나 이를 이용하지 않는다. 일부 경우, 로컬로 실행 가능한 게임은 게임 패치, 게임 인증, 클라우드 저장, 커스텀 가상 캐릭터 데이터(custom virtual character data), 사용자 계정 데이터, 또는 다른 특징과 같은 게임과 관련된 정보를 검색하기 위해 외부 서버와 통신할 수 있다. 분산 된 게임 애플리케이션에서, 플레이어 컴퓨팅 시스템은 게임 및 인터랙티브 컴퓨팅 시스템의 일부를 실행할 수 있거나, 인터랙티브 컴퓨팅 시스템의 애플리케이션 호스트 시스템이 게임의 다른 부분을 실행할 수 있다. 예를 들어, 게임은 각각의 플레이어 컴퓨팅 시스템(102 및 103)에 의해 실행되는 클라이언트 부분과, 하나 이상의 애플리케이션 호스트 시스템에 의해 실행되는 서버 부분을 포함하는 대규모 멀티 플 레이어 온라인 롤 플레잉 게임(massively multiplayer online role-playing game; MMORPG)일 수 있다. 본 논 의에서, 게임 애플리케이션의 유형은 로컬로 실행 가능한 게임, 분산된 애플리케이션, 또는 플레이어 컴퓨 팅 시스템에서 실행되는 부분 및 적어도 애플리케이션 호스트 시스템에서 실행되는 부분을 포함하는 애플리케이션일 수 있다. 2. 플레이어 데이터 저장소 플레이어 컴퓨팅 시스템은 데이터 저장소를 포함할 수 있다. 데이터 저장소는 하나 이상의 게 임 애플리케이션과 관련된 데이터, 인터랙티브 컴퓨팅 시스템에 의해 플레이어를 위해 유지된 계정과 관련된 로컬 계정 데이터, 게임 플레이 이력 데이터 및/또는 다른 게임 관련 또는 계정 관련 데이터를 저장하도 록 구성될 수 있다. 일부 실시예에서, 데이터 저장소는 (플레이어 모방 시스템에 의해 생성되었을 수 있는) 특정 플레이어에 대한 플레이어 모방 모델 데이터의 로컬 사본을 선택적으로 저장하여 플레이어가 자 신의 이전 버전에 대항해 로컬로 플레이할 수 있게 하고, 싱글 플레이 게임의 일부를 자동 플레이할 수 있게 하 고, 및/또는 인터랙티브 컴퓨팅 시스템에 대한 네트워크 연결이 없는 경우의 다른 용도의 사용을 가능하게 할 수 있다. 데이터 저장소는 다수의 컴퓨팅 장치에 걸쳐 분산될 수 있다(예를 들어, 도 5의 컴퓨팅 장치 참조). C. 기타 고려사항 다양한 시스템이 위에서 개별적으로 기재되었지만, 이들 시스템 중 하나 이상이 함께 결합될 수 있음에 유의해 야 한다. 예를 들어, 하나 이상의 시스템은 동일한 컴퓨팅 장치(예를 들어, 도 5의 컴퓨팅 장치 참조) 또 는 도 1에 도시된 것과 다른 컴퓨팅 시스템에 의해 실행될 수 있다. 일부 실시예에서, 플레이어 모방 시스템 은 플레이어 컴퓨팅 시스템과 동일한 컴퓨팅 장치에서 실행될 수 있다. 한편, 하나 이상의 시스템은 다수의 컴퓨팅 장치에 의해 실행될 수 있다. 예를 들어, 플레이어 모방 시스템의 일부 또는 서브 시스템 은 플레이어 컴퓨팅 시스템에 의해 구현될 수 있는 반면, 다른 부분 또는 서브 시스템은 서버에 의해 구현 될 수 있다. 도시된 동작 환경 내에서의 예시적인 데이터 흐름 도 2는 도 1의 네트워크 컴퓨팅 환경 내의 예시적인 데이터 흐름을 도시한다. 도시의 편의를 위해, 도 2의 데 이터 흐름은 도시된 컴포넌트 또는 시스템 사이의 개별 통신이 네트워크를 통해 이루어지는지 또는 싱글 컴퓨팅 시스템이나 장치 내의 로컬인지를 특정하지 않는다. 하나의 예시적인 네트워크 구성이 도 1에 도시되고 위에 기재되었지만, 도 1의 싱글 컴퓨팅 시스템의 일부로서 도시된 컴포넌트 또는 서브 시스템(예컨대, 플레이어 모방 시스템의 시스템 및 컴포넌트)은 대신에 서로에 대해 원격 위치할 수 있음이 이해될 것이다. 유사하게, 도 1에 서로 네트워크 통신하는 것으로 도시된 다른 시스템(예를 들어, 플레이어 컴퓨팅 시스템(10 2)과 플레이어 모방 시스템)은 일부 실시예에서 함께 싱글 컴퓨팅 시스템 상에서 작동될 수 있고, 또는 네 트워크를 통한 통신보다 서로 직접 로컬 통신할 수 있다. 도 2에 도시된 바와 같이, 플레이어 컴퓨팅 시스템은 를레이어 제어 명령을 인터랙티브 컴퓨팅 시스템 의 애플리케이션 호스트 시스템(122a)으로 전송하는데, 이는 인터랙티브 컴퓨틱 시스템의 컨트롤러 소스 스위치(controller source switch)에 의해 먼저 수신될 수 있다(또는 애플리케이션 호스트 시스템과 동시에 또는 직후에 수신될 수 있다). 플레이어는 자신의 게임 애플리케이션 사본을 실행하는 다른 플레 이어 컴퓨팅 시스템에 의해 실시간으로 영향받는 공유된 게임 상태 정보(shared game state informatio n)를 수신하기 위해 애플리케이션 호스트 시스템(122a)과 통신하도록 구성된 온라인 멀티 플레이어 게임 애플리 케이션을 플레이하고 있을 수 있다. 따라서, 애플리케이션 호스트 시스템(122a)은 멀티 플레이어 게임의 다른 플레이어가 플레이어 컴퓨팅 시스템을 이용하는 플레이어와 동일한 가상 세계의 동일한 인스턴스와 상호 작용할 수 있게 하고, 다른 플레이어 컴퓨팅 시스템 사이에서 각 플레이어의 상호 작용(뿐만 아니라 프로 그램 환경 변화, NPC 동작 등)을 반영하도록 현재 공유된 게임 상태를 지속적으로 업데이트할 수 있다. 플레이어 제어 명령은 예를 들어, 제1 축(first axis)(상/하와 같은)에 따르거나 제1 조이스틱(왼쪽 조이스틱과 같은)에 제공되는 지향성 입력(directional inputs), 제2 축(second axis)(좌/우와 같은)을 따라 제공되거나 제2 조이스틱(오른쪽 조이스틱과 같은)에 제공되는 제2 지향성 입력(second directional inputs), 비디오 게임 의 유닛 또는 캐릭터가 할당된 동작 및/또는 다른 입력 데이터를 수행하도록 버튼(예를 들어, A, B, X, Y, Z, 왼쪽 범퍼, 오른쪽 범퍼, 시작, 선택, 터보, 마우스 클릭, 손가락 탭 등)이 눌렸는지 여부를 포함한다. 플레이 어 제어 명령은 컨트롤러, 마우스 및 키보드, 음성 명령, 터치스크린, 제스쳐 등을 통해 임의의 다양한 입력 장 치 및 입력 형식을 통해 제공될 수 있다. 다른 실시예에서, 실제 버튼 누름, 마우스 클릭, 제스쳐 또는 다른 정보가 플레이어 컴퓨팅 시스템에서 게임 애플리케이션에 의해 로컬로 처리되고 게임 내 동작(in- game action) 으로 변환될 수 있고(예를 들어, 총을 발사하거나 왼쪽으로 90도 회전한 가상 캐릭터, 특정 게임 내 지도 좌표에 군대를 배치하기로 선택하는 플레이어 등), 게임 내 동작 또는 플레이어 입력의 다른 결과는 플 레이어 제어 명령으로 애플리케이션 호스트 시스템에 제공된다. 컨트롤러 소스 스위치는 애플리케이션 호스트 시스템(122a)과 별개의 컴포넌트로서 도시되어 있지만, 일부 실시예에서는 컨트롤러 소스 스위치 기능은 애플리케이션 호스트 시스템(122a) 내에 통합될 수 있다. 컨트롤러 소스 스위치는 애플리케이션 호스트 시스템(122a)으로 (a) 플레이어 컴퓨팅 시스템으로부터 수신된 플레이어 제어 명령 또는 (b) 컨트롤러 프록시 컴포넌트에 의해 생성된 에뮬레이트된 제어 명령(emulated control command) 중 하나를 제공할 것인지를 선택할 수 있다. 컨트롤러 소스 스위치는 플레이어 하트비 트 컴포넌트에 적어도 부분적으로 기초하여 애플리케이션 호스트 시스템에 어느 소스가 제어 명령을 제공 해야 하는지를 결정할 수 있다. 플레이어 하트비트 컴포넌트는 플레이어 컴퓨팅 시스템과 인터랙티 브 컴퓨팅 시스템 사이에 일관된 연결이 유지되는지를 결정하는 하나 이상의 하트비트 프로토콜(heartbeat protocols)을 구현할 수 있다. 예를 들어, 네트워크 연결이 끊어지거나 네트워크 지연이 특정 게임의 플레이 가능을 위해 설정된 임계값을 초과한 결과로, 플레이어 하트비트 컴포넌트에 의해 유지되던 하트비트가 실패할 수 있다(예를 들어, 느린 플레이 또는 턴-기반 게임의 경우 빈번한 초 단위의 제어 판단을 포함하는 빠른 페이 스의 게임보다 임계값이 클 수 있다). 플레이어 하트비트 컴포넌트에 의해 모니터링 되는 하나 이상의 추가적인 또는 대안적인 연결은 플레이어 제어 장치 또는 게임 컨트롤러가 플레이어 컴퓨팅 시스템에 꽂혀 있거나(plugged into) 연결된 상태인지를 모니 터링 하는 것을 포함할 수 있다(예를 들어, 누군가 코드를 넘어갈 때 발생할 수 있는, 유선 게임 컨트롤러가 플 레이어 컴퓨팅 시스템으로부터 연결이 끊어졌는지를 감지하는 것). 일부 실시예에서, 플레이어 하트비트 컴포 넌트는 플레이어가 버튼을 누르거나 달리 제어 명령을 입력한 이후의 시간을 모니터링할 수 있고, 위 시간을 게 임 상태에 따라 바뀔 수 있는 임계 시간과 비교할 수 있다. 예를 들어, 움직임이 예상되는 상황에서 플레이어 가 가상 캐릭터를 몇 초 동안 움직이지 않거나 플레이어의 예상되는 행동에서 플레이어 행동이 벗어난 경우(예 를 들어, 가상 캐릭터가 총에 맞거나 그의 팀원이 모두 도망간 게임 상태), 플레이어 하트비트 컴포넌트는 제어 하트비트의 실패를 컨트롤러 소스 스위치에 표시할 수 있다. 반대로, 아무 제어 명령도 내리지 않는 것이 게임 내에서 플레이어에게 바람직한 게임 플레이 상황(예를 들어, 가상 환경에서 가상 캐릭터가 적으로부터 숨 어 있는 상황)과 같은 다른 게임 상황이 있을 수 있고, 플레이어 하트비트 컴포넌트는 몇 초 간의 플레이어 제 어 비활성에도 불구하고 일관된 제어 하트비트를 표시할 수 있다. 다른 예로서, 플레이어 하트비트 컴포넌트는모션 센서(motion sensor) 또는 카메라를 모니터링하여 플레이어가 더 이상 시야에 있지 않으며 아마도 그의 컴 퓨팅 시스템을 떠난 것(예를 들어, 플레이어는 집에서 초인종에 응하기 위해 게임중인 그의 자리에서 일어날 수 있다)을 식별할 수 있다. 하트비트 컴포넌트가 어떤 제어 실패 또는 연결 실패도 식별하지 않으면, 컨트롤러 소스 스위치는 플 레이어 컴퓨팅 시스템으로부터 수신된 모든 플레이어 제어 명령을 곧바로 애플리케이션 호스트 시스템 (122a)으로 전달하여 그에 따라 게임 상태를 업데이트할 수 있다(예를 들어, 플레이어의 제어 명령 및 다른 플 레이어 컴퓨팅 시스템으로부터 수신된 제어 명령에 기초해 게임 상태를 업데이트 하는 것과 같이). 그 후, 각 플레이어 컴퓨팅 시스템에서 실행되는 게임 애플리케이션이 새로운 게임 상태에 기초해 업데이트된 게임 내 뷰(view) 또는 컨텐츠(content)를 디스플레이(display)하도록 하기 위해, 업데이트된 게임 상태 정보가 애플 리케이션 호스트 시스템(122a)로부터 각각의 플레이어 컴퓨팅 시스템(102 및 103)으로 다시 전송된다. 주어진 게임 상태에 대응한 플레이어의 최근 동작(들) 또는 제어 명령(들)에 기초해 현재 플레이어 모방 모델을 업데이 트 하기 위해, 애플리케이션 호스트 시스템(122a)은 플레이어 및 게임 상태 데이터를 게임 플레이 모델링 시스 템으로 추가로 제공할 수 있고, 이하에 더 기재될 것이다. 컨트롤러 소스 스위치가 플레이어 컴퓨팅 시스템 연결이 끊어졌거나 하트비트 프로토콜이 실패했다고 판단하면, 컨트롤러 소스 스위치가 컨트롤러 프록시 컴포넌트에게 컨트롤러 프록시 컴포넌트가 플레 이어가 이전에 게임 내에서 제어하던 플레이어의 가상 캐릭터나 다른 가상 유닛의 제어를 인수해야 한다는 것을 나타내는 스위치 시그널을 보낼 수 있다. 그 후 컨트롤러 프록시 컴포넌트는 게임 플레이 모델링 시스템 으로부터 에뮬레이트된 제어 명령을 획득하거나 요청할 수 있고, 이는 애플리케이션 호스트 시스템(122a) 으로부터 얻어진 현재 게임 상태에 기초해 에뮬레이트된 제어 명령을 생성할 수 있다. 에뮬레이트된 제어 명령 은 주어진 현재 게임 상태에서 플레이어가 취할 예상되는 동작을 나타낼 수 있고, 하나 이상의 유사한 게임 상 태에서의 플레이어(또는 다른 플레이어)에 의한 과거 동작들에 기초할 수 있고, 이하 더 논의될 것이다. 애플리케이션 호스트 시스템(122a)은 그 후 에뮬레이트된 제어 명령에 기초해 게임 상태를 업데이트할 수 있고, 이는 게임의 가상 환경 내에서 플레이어의 가상 캐릭터나 가상 유닛의 동작 및/또는 위치를 업데이트 하는 것을 포함할 수 있으며, 이 업데이트된 게임 상태 정보를 다른 플레이어 컴퓨팅 시스템으로 전송할 수 있다. 애플리케이션 호스트 시스템(122a)은, 플레이어 명령이 수신되기까지 및/또는 컨트롤러 또는 네트워크 연결이 재설정될 때까지 등의 컨트롤러 소스 스위치가 다시 플레이어의 제어로 전환하기로 결정할 때까지, 플레이어 컴 퓨팅 시스템이 아닌 컨트롤러 프록시 컴포넌트로부터 플레이어의 가상 캐릭터에 대한 제어 명령을 계속해 서 수신할 수 있다. 도 2는 멀티 플레이어 온라인 게임과 관련하여 위에서 기재되었지만, 본 개시의 양태는 싱글 플레이어 게임 내 에서도 이점을 갖는다. 예를 들어, 플레이어가 게임을 하고 있고 게임 컨트롤러나 다른 입력장치의 연결이 끊 어지거나, 플레이어 컴퓨팅 시스템의 게임 애플리케이션이 정지된 경우(서버 측 애플리케이션 호스트가 게임 인 스턴스를 계속 실행하는 동안), 플레이어는 플레이어가 제어를 재설정할 수 있을 때까지(짧은 연결 끊김이나 제 어 문제로 인해 게임 내에서 죽거나 패배하지 않기 위해) 그의 플레이 스타일이 에뮬레이트 되기를 원할 수 있 다. 일부 싱글 플레이어 실시예 (및/또는 멀티 플레이어 실시예)에서, 컨트롤러 소스 스위치는 시간 제한이 만 료되기 전 또는 플레이어가 돌아올 때 까지만 에뮬레이트된 제어가 사용되도록 시간 제한(예를 들어, 2분)을 시 행할 수 있다."}
{"patent_id": "10-2020-0034403", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "플레이어 제어 인계(takeover)를 위한 도시된 방법들 도 3은 일부 실시예에 따른, 플레이어 제어 명령 또는 모방 학습 모델의 에뮬레이트된 제어에 기초해 비디오 게 임 인스턴스의 상태를 업데이트 하는 것 간의 전환에 대한 예시적인 방법의 흐름도이다. 일부 실시예에서, 방법은 전체적으로 또는 부분적으로 게임 애플리케이션, 플레이어 모방 시스템, 플 레이어 컴퓨팅 시스템, 인터랙티브 컴퓨팅 시스템, 또는 다른 애플리케이션 컴포넌트 또는 모듈에 의 해 구현될 수 있다. 임의의 수의 시스템이 전체적으로 또는 부분적으로 방법을 구현할 수 있지만, 논의를 단순화하기 위해, 방법은 인터랙티브 컴퓨팅 시스템의 특정 시스템 또는 컴포넌트와 관련하여 기재될 것이다. 예시적인 방법은 게임 플레이 세션 또는 게임의 인스턴스 동안 발생할 수 있다. 예를 들어, 블록 302 이 전에, 인터랙티브 컴퓨팅 시스템은 제1 플레이어의 제어를 받는 하나 이상의 가상 캐릭터 또는 게임 내의 다른 가상 유닛을 포함하는 게임 인스턴스를 개시할 수 있다. 게임 인스턴스는 해당 게임 인스턴스 내에서 제1 플레이어(first player)와 경쟁하거나 협력할 수 있는 한 명 이상의 다른 플레이어의 제어 하에 있는 하나 이상 의 다른 가상 캐릭터 또는 게임 내 다른 가상 유닛을 추가로 포함할 수 있다. 예시적인 방법은 블록 302 에서 시작하는데, 여기서 게임 애플리케이션 및/또는 애플리케이션 호스트 시스템(122a)은 키를 누르고, 버튼을 누르고, 마우스를 클릭하고, 제스쳐를 만들고, 및/또는 다른 동작 또는 동작의 조합의 결과 플레이어에 의해 입력된 하나 이상의 제어 명령과 같은 게임 내 플레이어 입력을 수신할 수 있다. 일부 실시예에서, 제어 명령은 게임 애플리케이션 또는 애플리케이션 호스트 시스템에 의해 플레이어의 제어 하 에 있는 게임 내 특정 가상 개체가 하나 이상의 게임 내 동작(예를 들어, 플레이어가 누른 특정 버튼에 이전에 할당된 동작)을 수행하도록 하는 명령으로 해석될 수 있다. 예를 들어, 농구 경기에서 특정 버튼을 누르면 게 임 상태에 따라(예를 들어, 가상 농구 선수 캐릭터가 공을 가지고 있는지 또는 수비 중인지에 따라) 가상 농구 선수 캐릭터가 득점하거나(shoot a basket) 상대방의 슛을 막기 블로킹(block)하기 위해 점프할 수 있다. 다른 예로서, 캐릭터가 제어하는 가상 개체는 전쟁 시뮬레이션 게임에서 군인 부대와 같은 다수의 게임 내 가상 유닛 의 그룹일 수 있고, 이는 플레이어에 의해 입력되는 일련의 명령에 기반한 특정 타겟을 특정 형식으로 공격을 개시한다. 플레이어가 제어하는 다른 타입의 가상 개체는 예를 들어 가상 객체(object), 가상 이동체(예를 들 어, 레이싱 게임에서의 자동차) 또는 가상 구조물을 포함할 수 있다. 블록304에서, 애플리케이션 호스트 시스템(122a)은 전술한 바와 같이 플레이어 입력에 기초해 게임 상태를 업데 이트 할 수 있다. 위의 농구 게임 예시에서, 업데이트된 게임 상태는 슛이 블로킹 당했고(blocked) 다른 가상 농구 선수 캐릭터가 이제 공을 가지고 있음을 나타내는 데이터 뿐만 아니라, 공을 소유한 팀, 코트 위의 다양한 가상 농구 선수 캐릭터의 포지션, 해당 쿼터의 남은 시간, 플레이어의 에너지 레벨 등과 같은 게임 상태 데이터 를 업데이트하는 데이터를 포함할 수 있다. 블록306에서, 플레이어 모방 시스템은 플레이어 입력 및 그 입력이 수신된 게임 상태에 기초하여 플레이어 학습 모델을 업데이트 할 수 있다. 이 블록은 모델이 게임 플레이 인스턴스 전체에 걸쳐 동적 방식이 아닌 일 괄 처리 방식으로 트레이닝 되는(trained in a batch process rather than dynamically) 실시예에서와 같이, 선택적일 수 있다. 주어진 실시예 및 인스턴스에서 블록306이 수행되면, 플레이어 모방 시스템은 플레이 어가 주어진 제어 명령을 입력했거나 주어진 게임 상태에서 특정 게임 내 동작을 요청한 것을 반영하기 위해 주 어진 플레이어에 대한 플레이어 모방 모델을 업데이트할 수 있다. 모델 트레이닝은 도 4와 관련하여 아래에서 더 기재될 것이다. 한 예로서, 블록306은 주어진 게임 상태 또는 유사한 게임 상태에 대한 업데이트된 플레이어 행동 통계를 반영 하기 위해 마르코프 모델을 업데이트 하는 단계를 포함할 수 있다. 예를 들어, 플레이어가 유사한 미래 게임 상태에서 주어진 동작 또는 명령을 수행할 이전보다 높은 가능성(예를 들어, 수비 상황에서 슛을 블로킹(bloc k)하기 위해 점프할 가능성 및 코트의 특정 부분에서 슈터로부터 특정 거리 내에 서있을 가능성) 을 반영하도록 모델이 업데이트 될 수 있다. 이하 기재되는 바와 같이, 다른 모델은 게임에 적용되는 다양한 레벨의 양자화 (quantization), 라운딩(rounding) 또는 추상화(abstraction)를 가질 수 있다. 예를 들어, 게임 상태는 모델 내에서 \"긴박한 위협을 받고 있다\"와 같이 매우 광범위하게 식별되거나, \"사격자(shooter)보다 높은 지면에 서 있는 동안 33야드 떨어진 지점으로부터 권총으로 사격당함, 수류탄으로 공격시 일부 커버됨\"등과 같이 훨씬 더 구체적으로 식별될 수 있다. 블록308에서, 인터랙티브 컴퓨팅 시스템은 컨트롤러 소스 스위치 및/또는 플레이어 하트비트 컴포넌 트를 통해, 컨트롤러의 연결 끊김 또는 네트워크 연결 끊김과 같은 플레이어의 연결 끊김이 검출되었는지 를 결정할 수 있다. 위에서 논의된 바와 같이, 에뮬레이트된 제어를 사용하도록 스위치를 작동시키는 연결 끊 김, 문제, 하트비트 실패 또는 다른 사건의 유형은 실시예에 따라 달라질 수 있다. 예를 들어, 블록 308은 기 기 고장(예를 들어, 게임 컨트롤러 플러그가 뽑혔거나 무선 신호의 손실), 프레임 버퍼(frame buffer)로부터 검 출된 문제(예를 들어, 멀티 플레이어 게임 플레이가 시작되었는데 플레이어 컴퓨팅 시스템의 게임 애플리케이션 이 여전히 로딩화면을 나타내는 것), 플레이어가 방을 떠난 시각적 감지 또는 모션 감지(예를 들어, 카메라 또 는 모션 캡쳐 데이터에 기반하는), 예측된 제어 입력보다 수신된 제어 입력의 부족(예를 들어, 팀의 나머지 가 상 캐릭터가 전략적으로 실행중일 때 플레이어의 가상 캐릭터는 그대로 서있음), 네트워크 연결 끊김 또는 과도 한 네트워크 지연, 및/또는 기타 문제를 검사하는 것을 포함할 수 있다. 블록 308에서 연결 끊김 또는 다른 문제가 검출되지 않으면, 예시적인 방법은 플레이어로부터 제어 명령을 계속 수신하기 위해 (예를 들어 플레이어 컴퓨팅 시스템을 통해) 블록 302로 되돌아간다. 대신에 블록 308에서 연결 끊김 또는 다른 문제가 검출되면, 예시적인 방법은 블록 310으로 진행하고, 여기서 플레이어 의 가상 유닛(들)에 대한 제어 입력 소스는 위에서 도 2에 관해 논의된 바와 같이 컨트롤러 프록시 컴포넌트 로 전환된다. 위에서 논의된 바와 같이, 플레이어 모방 시스템은 그 후 블록 312에서, 컨트롤러 프 록시로부터 게임 내 명령(예를 들어, 플레이어의 가상 유닛을 이동시키라는 명령, 플레이어 가상 유닛이 특정 게임 내 동작을 수행하도록 하는 명령 등)을 제공하기 시작할 수 있다. 논의된 바와 같이, 컨트롤러 프록시로 부터의 에뮬레이트된 제어는 현재 게임 상태 및 현재 게임 상태의 관점에서 플레이어의 가능한 동작을 따라하도 록 구성될 수 있는 모방 학습 모델에 기초하여 결정될 수 있다. 블록 314에서, 플레이어가 복귀하거나, 네트워크 연결이 재설정되거나, 또는 다른 연결 문제 또는 제어 문제가 해결되면, 방법은 플레이어 가상 유닛(들)의 제어를 에뮬레이트된 제어가 아닌 플레이어에 의한 제어로 재 개하기 위해 블록 302로 되돌아갈(loop back to) 수 있다. 블록 314에서, 연결 또는 제어 문제가 해결되지 않 으면, 방법은 플레이어의 가상 유닛(들)을 제어하기 위해 에뮬레이트된 제어를 계속 사용하기 위해 블록 312로 돌아갈 수 있다. 방법은, 일부 실시예에서, 예를 들어 게임 인스턴스가 종료되거나 플레이어의 가상 유닛 (들)이 게임에서 제거될 때까지 지시된 바와 같이 반복 실행(looping)을 계속할 수 있다. 도 4는 일부 실시예에 따른, 플레이어의 게임 플레이 데이터의 특정 기간에 기초해 생성된 하나 이상의 스택 가 능한 모델의 형태로 하나 이상의 플레이어 모방 모델을 트레이닝하고 이용하는 방법의 예시적인 데이터 흐름도 를 제공한다. 도 4는 본 개시에서 이용될 수 있는 특정 모델의 예시를 제공하지만, 본원에 기재된 자동화된 플 레이어 인계의 특징의 다양한 장점은 어느 특정 모델 타입에만 특정적이지 않을 수 있다는 것이 이해될 것이다. 예를 들어, 일부 실시예에서, 주어진 플레이어에 국한되지 않은 플레이어 모방 모델이 이용될 수 있고, 게임 플 레이 데이터로부터 트레이닝 되는 것이 아니라 게임 개발자에 의해 프로그래밍 방식으로 생성될 수 있다. 다른 실시예에서, 플레이어 모방 모델은 결정 트리(decision tree), 마르코프 모델(Markov model), 딥 뉴럴 네트워크 (deep neural network) 및/또는 비디오 게임에서 행동을 모델링하거나 AI나 NPC 개체를 제어하는 다른 방법을 포함할 수 있다. 따라서, 도 4와 관련하여 이하 기재되는 예시적인 예는 모든 실시예에서 게임 플레이 모델링 시스템 또는 플레이어 모방 모델 데이터 저장소에 의해 이용될 수 있는 AI 또는 행동 모델의 유형을 제한하는 것으로 이해되어서는 안된다. 도 4에 도시된 바와 같이, 현재 게임 세션 데이터는 현재 스택 가능한 모방 모델을 트레이닝 하기 위한 입 력으로서 제공될 수 있고, 및/또는 저장을 위해 게임 세션 이력 데이터 저장소에 제공될 수 있다. 게임 세션 데이터는 예를 들어 게임 상태 데이터, 플레이어 입력, 취해진 동작, 가상 환경 데이터 및/또는 주어진 게 임 내 상황에서 명령이나 동작에 대한 플레이어의 선택에 영향을 줄 수 있는 임의의 다른 게임 데이터를 포함할 수 있다. 게임 세션 또는 게임 인스턴스 동안 실시간으로 또는 동적으로 트레이닝 될 수 있는 현재 스택 가능 한 모방 모델은, 수신된 라이브 게임 세션 데이터에 기초하여 게임 플레이 모델링 시스템에 의해 수 정될 수 있다. 여기에는 수신된 원본 게임 세션 데이터에 양자화, 압축, 라운딩 또는 다른 조작을 적용한 다음, 위에서 논의된 바와 같이 현재 게임 상태에 입력된 새로 수신된 동작(들)이나 제어 명령(들)에 따라 이전 에 저장된 플레이어 모방 모델 내에서 통계 또는 가능성을 업데이트하는 것을 포함할 수 있다. 스택 가능 모델 을 업데이트하는 것은 현재 게임 상태에 기초한 새로운 규칙을 통합하기 위해 모델에 새로운 스택 또는 레벨을 추가하는 것을 포함할 수 있다. 이 접근 방식은 모델의 전체 리트레이닝(retraining)을 구현하는 대신 실시간 으로 모델을 반복적으로 구축하는 것을 가능하게 할 수 있다. 임의의 업데이트를 포함하는 현재 스택 가능한 모방 모델은 플레이어 모방 모델 데이터 저장소에 저장될 수 있다. 새로 수신된 동작 또는 제어 명령이 현재 게임 상태에서 플레이어가 어떻게 행동할 것인가에 대한 예측에서 벗 어나지 않는 일부 인스턴스의 경우, 이 새로운 게임 세션 데이터를 기반으로 모델을 업데이트 할 필요가 없다. 실시예에 따라, 임의의 업데이트 이전의 현재 모델은 이 특정 플레이어를 위해 이전에 생성된 모델, 다수의 다 른 플레이어의 게임 플레이 데이터에 대해 트레이닝 된 모델, 또는 일반 모델일 수 있다. 따라서, 모델의 수정 은, 일부 실시예에서 (실시예에 따라 임의의 플레이어에 대한 일반적인 예측 또는 이 특정 플레이어에 대한 예 측으로서)모델이 이전에 예측했던 것과 관련하여 관찰된 플레이어의 새로운 행동 또는 동작의 차이를 반영하기 위해서만 발생할 수 있다. 다른 실시예에서, 전체 통계가 모델 네에 반영될 수 있고(예를 들어, 플레이어가 다 수의 게임 상태 카테고리 각각에서 특정 동작을 취한 것으로 관찰된 횟수), 이 경우 동작의 각각의 관찰된 인스 턴스에 대해 업데이트가 일어날 수 있다. 게임 세션 이력 데이터 저장소에 대한 논의로 되돌아가면, 이 데이터 저장소는 잠재적으로 장기간(예를 들 어, 몇 달 또는 몇 년)에 걸친 플레이어에 대한 세부적인 게임 플레이 데이터를 포함할 수 있고, 잠재적인 다수의 기본 비디오 게임(예를 들어, 관련없는 게임 뿐만 아니라, 첫번째 게임과 그 후속편)을 포함할 수 있다. 저 장된 세부 사항의 레벨은 특정 게임의 복잡성, 인터랙티브 컴퓨팅 시스템 운영자(operator)와 플레이어의 계정과 관련된 가입 또는 계획 레벨, 및/또는 다른 요인들을 포함하는 여러 요인에 의존할 수 있다. 예를 들어, 하나의 세션 동안 저장된 게임 세션 이력 데이터는 플레이어가 플레이어에 의해 취해진 모든 동작의 전체 리플레이를 다시 재생하기에 충분히 상세할 수 있다. 덜 상세한 인스턴스에서, 저장된 데이터는 저장 전에 전 술한 바와 같이 코어스 되거나(coarsened) 양자화(quantized)될 수 있다. 도시된 바와 같이, 데이터 저장소의 게임 세션 이력 데이터는 플레이어 모방 시스템에 의해 하나 이 상의 부분 게임 플레이 세션 또는 게임 플레이의 기간에 기초하여 하나 이상의 타임 캡슐 모방 모델(들)(time capsule imitation model(s))을 생성하는 데 사용될 수 있다. 일부 실시예에서, 인터랙티브 컴퓨팅 시스 템 또는 플레이어 컴퓨팅 시스템은, 타임 캡슐 모방 모델을 생성하는데 사용되는, 플레이어가 과거 게임 플레이 세션(예를 들어, 플레이어의 역대 최고의 게임 퍼포먼스를 모방하는 모델을 생성하도록 요청) 또는 기간(예를 들어, 지난 3개월 또는 지난 100게임 세션의 모델을 생성하도록 요청)에 대한 선택을 가능하게 하는 사용자 인터페이스를 생성할 수 있다. 어떤 인스턴스에서는, 감쇠값(decay value) 또는 감쇠 기능(decay function)이 시간을 기반으로 적용될 수 있어서, 더 최근 게임 플레이 세션에서의 플레이어 행동이 모델 내에서 오래된 게임 플레이 세션에서의 플레이어 행동보다 더 크게 가중될 수 있다. 일단 생성되면, 타임 캡슐 모방 모델(들)은 플레이어 모방 모델 데이터 저장소에 저장될 수 있다. 도 4의 모델 사용 섹션에 도시된 바와 같이, 플레이어 모방 모델 데이터 저장소에서 저장된 모방 모델 중 하나의 사용은 데이터 저장소로부터 모델이 검색되고 입력으로 현재 게임 상태를 제공하는 것을 포함할 수 있다. 도시된 예에서, 모델은 우선 순위가 높은 동작 또는 상태가 모델 내에서 먼저 점검되는 낮은 번호 레벨 로 저장된 스택 가능한 모델이다. 예를 들어, 레벨 1은 하위 레벨의 다른 게임 상태 요인(game state factor) 또는 규칙보다 우선할 가능성이 높은 게임 상태 요인 또는 규칙을 의미할 수 있다(예를 들어, 플레이어의 캐릭 터가 근거리에서 총격당하고 있는 경우, 플레이어의 캐릭터가 이전에 특정 현재 맵 위치에서 총격당한 적이 없 다거나, 또는 현재 맵 위치에 있을 때는 일반적으로 도망가지 않는다 할지라도, 도망가라는 즉각적인 동작을 결 정하는 것은 충분한 게임 상태 정보일 것이다). 도시된 바와 같이, 모델은 먼저 플레이어가 현재 게임 상태 및 규칙 또는 레벨 1과 관련된 게임 상태 정보를 고 려하여 레벨 1과 관련된 특정 동작을 수행할 것에 대한 신뢰 점수(confidence score)를 결정할 수 있다. 신뢰 점수가 임계값을 충족하면 모델이 레벨 진행을 중지하고, 레벨 1에서 결정된 동작을 출력할 수 있다. 그렇지 않으면, 모델은 그 레벨을 통해 진행하며, 임계값을 만족하는 신뢰 점수를 갖는 동작을 결정할 때까지 현재 게임 상태를 각각의 연속적인 스택 가능 레벨로 전달할 수 있다. 마지막 레벨(도 4에서 레벨 N으로 표시 됨)에 도달하고 현재 게임 상태에 기초해 동작을 결정하지 못하면, 디폴트 또는 폴백 동작(default or fallback action)이 결정될 수 있다. 일부 실시예에서, 폴백 동작은 아무것도 하지 않거나 이전의 동작을 계속하는 것일 수 있다(예를 들어, 가상 캐릭터가 이미 걷고 있다면 현재 방향으로 계속 걷기). 다른 실시예에서, 모델은 현 재 플레이어 모방 모델이 제안된 동작을 하지 않을 때 동작을 결정하기 위해 게임 상태 정보를 일반 모델 또는 다른 모델로 전달할 수 있다. 본원에서 논의된 바와 같이, 자동화된 플레이어 인계에 사용되는 것뿐만 아니라, 위에서 논의된 타임 캡슐 모델 은 플레이어가 자신에 대해 플레이하거나 (예를 들어, NPC 적을 제어하기 위해 자신의 타임 캡슐을 로딩함으로 써) 또는 자신과 함께 플레이(예를 들어, NPC 팀원을 제어하기 위해 자신의 타임 캡슐을 로딩함으로써)하기 위 해 선택할 수 있다. 일부 실시예에서, 플레이어는 자신의 타임 캡슐을 다른 플레이어와 공유 가능하게 할 수 있으며, 이는 챔피언 또는 특히 숙련된 플레이어가 과거에 수행했거나 현재 수행하는 것에 대해 연습하는 방법 을 제공할 수 있다. 컴퓨팅 장치 개요 도 5는 본 개시에 따른 컴퓨팅 장치의 실시예를 도시한다. 컴퓨팅 장치의 컴포넌트를 제거 또는 추가 하는 것처럼, 컴퓨팅 장치의 다른 변형이 본원에 명시적으로 개시된 예시를 대체할 수 있다. 컴퓨팅 장치 는 게임 장치, 스마트폰, 태블릿, 개인용 컴퓨터, 랩탑, 스마트 텔레비전, 자동차 콘솔 디스플레이, 서버 등을 포함할 수 있다. 컴퓨팅 장치는 또한 다수의 지리적 위치에 걸쳐 분산될 수 있다. 예를 들어, 컴퓨팅 장치는 클라우드 기반 서버 클러스터(cluster)일 수 있다. 일부 실시예에서, 플레이어 컴퓨팅 시스템 은 도 5에 도시된 하나 이상의 컴포넌트를 포함할 수 있고, 다른 실시예에서는, 인터랙티브 컴퓨팅 시스템 이 도 5에 도시된 하나 이상의 컴포넌트를 포함할 수 있다. 도시된 바와 같이, 컴퓨팅 장치는 컴퓨팅 장치의 다른 컴포넌트 및 컴퓨팅 장치의 외부 컴포넌트와 도 상호 작용하는 처리 장치를 포함한다. 게임 매체와 통신하는 게임 매체 판독기가 포함된다. 게임 매체 판독기는 CD-ROM 또는 DVD와 같은 광디스크를 판독할 수 있는 광디스크 판독기, 또는 게임 매체 로부터 데이터를 수신 및 판독할 수 있는 임의의 다른 유형의 판독기일 수 있다. 하나 이상의 컴퓨팅 장치 가 본원에 개시된 하나 이상의 시스템을 구현하는 데 사용될 수 있다. 컴퓨팅 장치는 별도의 그래픽 프로세서를 포함할 수 있다. 일부 경우, 그래픽 프로세서는 처리 장 치 내에 내장될 수 있다. 그러한 일부 경우에, 그래픽 프로세서는 랜덤 액세스 메모리(Random Access Memory; RAM)를 처리 장치와 공유할 수 있다. 대안적으로 또는 추가적으로, 컴퓨팅 장치는 처리 장치 와 분리된 개별 그래픽 프로세서를 포함할 수 있다. 그러한 일부 경우, 그래픽 프로세서는 처리 장치와 별도의 RAM을 가질 수 있다. 컴퓨팅 장치는 휴대용 게임 애플리케이션 장치, 전용 게임 콘솔 컴퓨팅 시스템, 범용 랩탑 또는 데스크탑 컴퓨터, 스마트폰, 태블릿, 자동차 콘솔 또는 다른 적절한 시스템일 수 있다. 컴퓨팅 장치는 또한 I/O, 사용자 I/O, 디스플레이 I/O 및 네트워크 I/O와 같은 입력/출력 을 가능하게 하기 위한 다양한 컴포넌트를 포함한다. I/O는 컴퓨팅 장치를 위한 저장소(storage)를 제 공하기 위해, 저장 장치(storage element)와 상호작용하고, 장치를 통해 탈착 가능한 저장 매체와 상호 작용한다. 처리 장치는 게임 상태 데이터 및 임의의 공유 데이터 파일과 같은 데이터를 저장하기 위 해 I/O를 통해 통신할 수 있다. 저장 장치 및 탈착 가능한 저장 매체 외에, ROM(Read-Only Memory) 및 RAM을 포함하는 컴퓨팅 장치가 도시되어 있다. RAM은 게임이 플레이될 때처럼, 자 주 액세스되는 데이터에 사용될 수 있다. 사용자 I/O는 처리 장치와, 게임 컨트롤러와 같은 사용자 장치 사이에서 명령을 송수신하는 데 사용된 다. 일부 실시예에서, 사용자 I/O는 터치 스크린 입력을 포함할 수 있다. 터치 스크린은 정전 용량 방식 터치스크린(capacitive touch screen), 저항막 방식 터치스크린(resistive touch screen) 또는 플레이어로부터 촉각 입력(tactile input)을 통해 사용자 입력을 수신하도록 구성된 다른 유형의 터치 스크린 기술일 수 있다. 디스플레이 I/O는 재생중인 게임의 이미지를 디스플레이하는 데 사용되는 입/출력 기능을 제공한다. 네트 워크 I/O는 네트워크의 입/출력 기능에 사용된다. 네트워크 I/O는 게임이 온라인으로 플레이되거나 온 라인으로 액세스 될 때와 같은 게임 실행 동안 사용될 수 있다. 디스플레이 I/O에 의해 생성된 디스플레이 출력 신호는 그래픽, 사용자 인터페이스, 비디오 및/또는 다른 시각적 컨텐츠와 같은 디스플레이 장치 상에 컴퓨팅 장치에 의해 생성된 시각적 컨텐츠를 디스플레이하기 위한 신호를 포함한다. 컴퓨팅 장치는 디스플레이 I/O에 의해 생성된 디스플레이 출력 신호를 수신하 도록 구성된 하나 이상의 통합형 디스플레이를 포함할 수 있다. 일부 실시예에 따르면, 디스플레이 I/O에 의해 생성된 디스플레이 출력 신호는 컴퓨팅 장치 외부의 하나 이상의 디스플레이 장치로도 출력될 수 있다. 컴퓨팅 장치는 또한 클락(clock), 플래시 메모리 및 다른 컴포넌트와 같은 게임에 사용될 수 있는 다른 특징들을 포함할 수 있다. 오디오/비디오 플레이어는 또한 영화와 같은 비디오 시퀀스(video sequence)를 재생하는 데 사용될 수 있다. 다른 컴포넌트가 컴퓨팅 장치에 제공될 수 있고, 당업자는 컴퓨 팅 장치의 다른 변형을 이해할 것이다. 프로그램 코드는 ROM, RAM 또는 저장 장치(하드 디스크, 다른 자기 저장 장치, 광학 저장 장치, 다 른 비휘발성 저장 장치 또는 이들의 조합이나 변형을 포함할 수 있음)에 저장될 수 있다. 프로그램 코드의 일 부는 프로그램 가능한 ROM(ROM, PROM, EPROM, EEPROM 등)에 저장될 수 있고, 프로그램 코드의 일부는 저장 장치 및/또는 게임 매체와 같은 탈착 가능한 매체에 저장될 수 있다(CD-ROM, 카트리지, 메모리 칩 등일 수 있거나, 필요에 따라 네트워크 또는 기타 전자 채널을 통해 얻어질 수 있음). 일반적으로, 프로그램 코드는 유 형의 비일시적 신호 베어링 매체(tangible non-transitory signal bearing medium)에 구현되어 있다. RAM(Random Access Memory)(및 가능한 다른 저장 장치)은 필요에 따라 변수 및 다른 게임 및 처리 데이터를 저장하는 데 사용될 수 있다. RAM은 애플리케이션의 실행 동안 생성된 데이터를 보유하며, 이들의 일부는프레임 버퍼, 애플리케이션 상태 정보 및/또는 사용자 입력을 해석하고 디스플레이 출력을 생성하는 데 필요하 거나 사용할 수 있는 다른 데이터를 위해 남겨질(reserved) 수 있다. 일반적으로, RAM은 휘발성 저장 장치 이고, RAM 내에 저장된 데이터는 컴퓨팅 장치가 꺼지거나 전력이 손실될 때 손실될 수 있다. 컴퓨팅 장치가 게임 매체를 판독하고 애플리케이션을 제공함에 따라, 정보는 게임 매체로부터 판독 되고 RAM과 같은 메모리 장치에 저장될 수 있다. 또한, 저장 장치, ROM, 네트워크(미도시)를 통해 액세스 된 서버, 또는 탈착 가능한 저장 매체로부터의 데이터가 판독되고 RAM으로 로딩될 수 있다. 데 이터가 RAM에서 발견되는 것으로 기재되었지만, 데이터는 RAM에 저장될 필요는 없고 처리 장치에 액세스 가능하거나, 게임 매체 및 저장 장치와 같은 여러 매체에 분산된 다른 메모리에 저장될 수 있음 을 이해할 것이다. 모든 목적 또는 장점이 본원에 기재된 임의의 특정 실시예에 따라 반드시 달성될 필요는 없음이 이해되어야 한 다. 따라서, 예를 들어, 당업자는 특정 실시예가 본원에서 교시 또는 제안될 수 있는 다른 목적이나 장점을 반 드시 달성하지 않고 본원에서 교시된 바와 같이 하나의 장점이나 한 그룹의 장점을 달성하거나 최적화하는 방식 으로 동작하도록 구성될 수 있음을 인식할 것이다. 본원에 기재된 모든 프로세스는 하나 이상의 컴퓨터 또는 프로세서를 포함하는 컴퓨팅 시스템에 의해 실행되는 소프트웨어 코드 모듈을 통해 구현되고, 완전 자동화될 수 있다. 코드 모듈은 임의의 유형의 비일시적 컴퓨터 판독 가능 매체 또는 다른 컴퓨터 저장 장치에 저장될 수 있다. 일부 또는 모든 방법은 전문화된 컴퓨터 하드 웨어로 구현될 수 있다. 본원에 기재된 것 이외의 많은 다른 변형이 본 개시로부터 명백해질 것이다. 예를 들어, 실시예에 따라, 본원 에 개시된 임의의 알고리즘의 특정 동작, 이벤트 또는 기능은 다른 순서로 수행될 수 있거나, 추가, 병합 또는 생략될 수 있다(예를 들어, 알고리즘의 실행에 대해 설명된 모든 동작이나 이벤트가 필수적인 것은 아니다). 더욱이, 특정 실시예에서, 동작 또는 이벤트는 순차적 수행되는 것이 아니라, 예를 들어 멀티 스레디드 프로세 싱(multi-threaded processing), 인터럽트 프로세싱(interrupt processing) 또는 다중 처리 장치(multiple processors) 또는 프로세서 코어(processor cores) 또는 다른 병렬 아키텍쳐를 통해 동시에 수행될 수 있다. 또한, 서로 다른 작업이나 프로세스는 함께 작동할 수 있는 다른 기계 및/또는 컴퓨팅 시스템에 의해 수행될 수 있다. 본원에 개시된 실시예와 관련해 기재된 다양한 예시적인 논리 블록 및 모듈들은 처리 장치 또는 프로세서, DSP(digital signal processor), ASIC(application specific integrated circuit), FPGA(field programmable gate array) 또는 다른 프로그래밍 가능한 로직 장치, 이산 게이트(discrete gate) 또는 트랜지스터 로직, 이산 하드웨어 컴포넌트, 또는 본원에 기재된 기능을 수행하도록 설계된 이들의 임의의 조합과 같은 기계에 의해 구 현되거나 수행될 수 있다. 프로세서는 마이크로 프로세서일 수 있지만, 대안적으로 프로세서는 컨트롤러, 마이 크로 컨트롤러, 또는 상태 머신(state machine), 이들의 조합 등일 수 있다. 프로세서는 컴퓨터로 실행 가능한 명령어를 처리하도록 구성된 전기 회로를 포함할 수 있다. 다른 실시예에서, 프로세서는 컴퓨터로 실행 가능한 명령어를 처리하지 않고 로직 동작을 수행하는 FPGA 또는 다른 프로그래밍 가능한 장치를 포함한다. 프로세서 는 또한 컴퓨팅 장치의 조합, 예를 들어, DSP 및 마이크로 프로세서의 조합, 복수의 마이크로 프로세서, DSP 코 어와 관련된 하나 이상의 마이크로 프로세서 또는 이런 임의의 다른 구성으로 구현될 수 있다. 본원에서 주로 디지털 기술과 관련하여 기재되었지만, 프로세서는 주로 아날로그 컴포넌트를 포함할 수도 있다. 예를 들어, 본원에 기재된 신호 처리 알고리즘 중 일부 또는 전부는 아날로그 회로 또는 혼합 아날로그 및 디지털 회로로 구현될 수 있다. 컴퓨팅 환경은 몇 가지 예를 들면 기기 내의 마이크로 프로세서, 메인 프레임 컴퓨터, 디지털 신호 프로세서, 휴대용 컴퓨팅 장치, 장치 컨트롤러, 또는 컴퓨터 엔진에 기초한 컴퓨터 시스템을 포함하지만, 이에 제한되지는 않는 임의의 유형의 컴퓨터 시스템을 포함할 수 있다. 특별히 달리 언급되지 않는 한, \"할 수 있는(can)\", \"할 수 있는(could)\", \"할 수 있는(might)\" 또는 \"할 수 있는(may)\"과 같은 조건부 언어는 다른 실시예는 특정 기능, 요소 및/또는 단계를 포함하지 않지만, 특정 실시 양태는 이들을 포함한다는 것을 전달하기 위해 일반적으로 사용되는 문맥 내에서 이해된다. 따라서, 이런 조건 부 언어는 일반적으로 특징, 요소 및/또는 단계가 하나 이상의 실시예에 대해 어떤 식으로든 요구된다거나, 사 용자 입력이나 프롬프팅(prompting)이 있거나 없거나 이 특징, 요소 및/또는 단계가 어느 특정 실시예에 포함되 거나 거기서 수행되어야 할지를 판단하는 로직을 하나 이상의 실시예가 반드시 포함해야 한다고 암시하도록 의 도한 것이 아니다. 달리 구체적으로 언급되지 않는 한, \"X, Y 또는 Z 중 적어도 어느 하나\"라는 어구와 같은 분리적(disjunctive) 언어는 항목, 용어 등이 X, Y 또는 Z, 또는 이들의 임의의 조합(예를 들어, X, Y 및/또는 Z)을 나타내기 위해 일반적으로 사용되는 문맥에서 이해될 것이다. 따라서, 이런 분리적 언어는 일반적으로 특정 실시예가 적어도 X중 하나, 적어도 Y중 하나, 또는 적어도 Z중 하나가 각각 존재하도록 요구하는 것으로 암시하도록 의도한 것이 아니며, 암시해서는 안된다. 본원에 기재되고 및/또는 첨부된 도면에 도시된 흐름도의 임의의 프로세서 기재, 요소 또는 블록은 프로세스에 서 특정 논리 기능이나 요소를 구현하기 위한 하나 이상의 실행 가능한 명령을 포함하는 모듈, 세그먼트 또는 코드의 일부를 잠재적으로 나타내는 것으로 이해되어야 한다. 당업자에게 이해되는 바와 같이, 관련 기능에 따 라 요소나 기능이 삭제되거나, 실질적으로 동시에 또는 역순인 것을 포함해 도시된 것과 다른 순서로 실행 또는 논의되는 대안적인 구현들이 여기 기재된 실시예들의 범위에 포함된다. 달리 명시되지 않는 한, \"a\" 또는 \"an\"과 같은 것은 일반적으로 하나 이상의 기재된 항목을 포함하는 것으로 해 석되어야 한다. 따라서, \"~로 구성된 장치\"와 같은 문구는 하나 이상의 언급된 장치를 포함하도록 의도된다. 이러한 하나 이상의 인용된 장치는 언급된 설명을 수행하도록 집합적으로 구성될 수도 있다. 예를 들어, \"설명 A, B 및 C를 수행하도록 구성된 프로세서\"는 설명B 및 C를 수행하도록 구성된 제2 프로세서와 함께 작동하는 설 명 A를 수행하도록 구성된 제1 프로세서를 포함할 수 있다. 위에 기재된 실시예에 대해 많은 변형 및 수정이 이루어질 수 있으며, 그 컴포넌트는 다른 허용 가능한 예시 중 하나인 것으로 이해되어야 한다. 이러한 모든 수정 및 변형은 본원의 범위 내에 포함되도록 의도된다."}
{"patent_id": "10-2020-0034403", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도면 전체에 걸쳐 참조 번호는 참조된 요소 간의 대응을 나타내기 위해 재사용된다. 도면은 여기에 기재된 주 제의 실시예를 도시하기 위해 제공되며, 그 범위를 제한하기 위한 것이 아니다. 도 1은 프록시 제어(proxy control) 특징을 갖는 플레이어 모방 시스템의 하나 이상의 실시예를 구현하기 위한 네트워크 컴퓨팅 환경의 실시예를 도시한다. 도 2는 도 1의 네트워크 컴퓨팅 환경 내의 예시적인 데이터 흐름을 도시한다. 도 3은 일부 실시예에 따른, 플레이어의 제어 명령 또는 모방 학습 모델(imitation learning model)로부터의 에 뮬레이트된 제어(emulated control) 중 하나에 기초하여 비디오 게임 인스턴스의 상태를 업데이트 하는 것 간의 전환(switching)을 위한 예시적인 방법의 흐름도이다. 도 4는 일부 실시예에 따라, 플레이어의 게임 플레이 데이터의 특정 기간에 기초하여 생성된 하나 이상의 스택 가능한 모델의 형태로 하나 이상의 플레이어 모방 모델을 트레이닝(training) 하고 이용하는 예시적인 데이터 흐름을 제공한다. 도 5는 본 개시의 양태를 구현할 수 있는 컴퓨팅 장치의 실시예를 도시한다."}
