{"patent_id": "10-2020-0029131", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0113859", "출원번호": "10-2020-0029131", "발명의 명칭": "데이터 처리 시스템 및 그 동작 방법", "출원인": "에스케이하이닉스 주식회사", "발명자": "임민수"}}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "메모리 장치;호스트가 어플리케이션의 오프로드 처리를 요청함에 따라 상기 메모리 장치에 접근하여 상기 어플리케이션을 처리하는 컨트롤러; 및상기 호스트가 상기 어플리케이션 처리에 사용되는 데이터를 상기 메모리 장치의 타겟 영역에 저장함에 따라,상기 타겟 영역의 접근 권한을 상기 컨트롤러가 갖도록 설정하고, 상기 어플리케이션의 처리 상태에 따라 상기타겟 영역의 접근 권한을 상기 컨트롤러 또는 상기 호스트가 갖도록 설정하며, 상기 컨트롤러에 구비되는 공유메모리 관리부;를 포함하도록 구성되는 데이터 처리 시스템."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 데이터는, 상기 어플리케이션의 프로그램 코드를 포함하여 상기 메모리 장치의 제 1 영역에 저장되는 제 1데이터; 및상기 프로그램 코드에 의해 연산되며 상기 메모리 장치의 제 2 영역에 저장되는 제 2 데이터를 포함하도록 구성되는 데이터 처리 시스템."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 2 항에 있어서,상기 공유 메모리 관리부는,상기 어플리케이션의 실행 종료시까지 상기 제 1 영역의 접근 권한을 상기 컨트톨러가 소유하도록 설정하고,상기 제 2 데이터를 이용한 연산 결과가 상기 제 2 영역에 저장될 때까지 상기 제 2 영역의 접근 권한을 상기컨트롤러가 소유하도록 설정하는 데이터 처리 시스템."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 공유 메모리 관리부는, 상기 메모리 장치의 영역별 접근 권한 정보를 모드 설정 커맨드에 포함시켜 상기메모리 장치로 전송하고, 상기 메모리 장치는 상기 접근 권한 정보에 따라 모드 레지스터 셋(Mode RegisterSet; MRS)을 설정하도록 구성되는 데이터 처리 시스템."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1 항에 있어서,상기 공유 메모리 관리부는, 상기 타겟 영역의 물리 주소에 논리 주소를 할당하도록 구성되는 데이터 처리 시스템."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 5 항에 있어서,상기 데이터는, 상기 어플리케이션의 프로그램 코드를 포함하여 제 1 논리 주소가 할당된 제 1 물리 영역에 저장되는 제 1 데이터; 및공개특허 10-2021-0113859-3-상기 프로그램 코드에 의해 연산되며 제 2 논리 주소가 할당된 제 2 물리 영역에 저장되는 제 2 데이터를 포함하고,상기 공유 메모리 관리부는 상기 제 2 데이터의 연산이 완료되면 상기 제 2 데이터에 후속하여 상기 프로그램코드에 의해 연산되는 제 3 데이터가 저장된 제 3 물리 영역에 상기 제 2 논리 주소를 할당하도록 구성되는 데이터 처리 시스템."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서,상기 호스트가 상기 컨트롤러를 통해 상기 메모리 장치로 접근하도록 하는 제 1 인터페이스; 및상기 컨트롤러가 상기 메모리 장치로 접근하도록 하는 제 2 인터페이스;를 더 포함하도록 구성되는 데이터 처리 시스템."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1 항에 있어서,상기 컨트롤러와 상기 메모리 장치는 독립적인 모듈 보드로 구성되고 인터페이싱하도록 구성되는 데이터 처리시스템."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1 항에 있어서,상기 컨트롤러는 상기 메모리 장치와 단일 패키지로 구성되는 데이터 처리 시스템."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "메모리 장치 및, 상기 메모리 장치를 제어하는 컨트롤러를 포함하는 데이터 처리 시스템의 동작 방법으로서,상기 호스트가 상기 컨트롤러로 어플리케이션의 오프로드 처리를 요청하고, 상기 어플리케이션 처리에 사용되는데이터를 상기 메모리 장치의 타겟 영역에 저장함에 따라,상기 컨트롤러가 상기 타겟 영역의 접근 권한을 상기 컨트롤러가 갖도록 설정하는 단계; 및상기 어플리케이션의 처리 상태에 따라, 상기 컨트롤러가 상기 타겟 영역의 접근 권한을 상기 컨트롤러 또는 상기 호스트가 갖도록 설정하는 단계;를 포함하도록 구성되는 데이터 처리 시스템의 동작 방법."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 10 항에 있어서,상기 데이터는, 상기 어플리케이션의 프로그램 코드를 포함하여 상기 메모리 장치의 제 1 영역에 저장되는 제 1데이터를 포함하고,상기 어플리케이션의 실행 종료시까지 상기 제 1 영역의 접근 권한을 상기 컨트롤러가 소유하도록 설정하는 단계를 더 포함하도록 구성되는 데이터 처리 시스템의 동작 방법."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 11 항에 있어서,상기 데이터는, 상기 프로그램 코드에 의해 연산되며 상기 메모리 장치의 제 2 영역에 저장되는 제 2 데이터를포함하고,상기 제 2 데이터를 이용한 연산 결과가 상기 제 2 영역에 저장될 때까지 상기 제 2 영역의 접근 권한을 상기컨트롤러가 소유하도록 설정하는 단계를 더 포함하도록 구성되는 데이터 처리 시스템의 동작 방법.공개특허 10-2021-0113859-4-청구항 13 제 10 항에 있어서,상기 컨트롤러가, 상기 메모리 장치의 영역별 접근 권한 정보를 모드 설정 커맨드에 포함시켜 상기 메모리 장치로 전송하고,상기 메모리 장치는, 상기 접근 권한 정보에 따라 모드 레지스터 셋(Mode Register Set; MRS)을 설정하는 단계를 더 포함하도록 구성되는 데이터 처리 시스템의 동작 방법."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 10 항에 있어서,상기 컨트롤러가, 상기 타겟 영역의 물리 주소에 논리 주소를 할당하는 단계를 더 포함하도록 구성되는 데이터처리 시스템의 동작 방법."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 14 항에 있어서,상기 데이터는, 상기 어플리케이션의 프로그램 코드를 포함하여 제 1 논리 주소가 할당된 제 1 물리 영역에 저장되는 제 1 데이터; 및상기 프로그램 코드에 의해 연산되며 제 2 논리 주소가 할당된 제 2 물리 영역에 저장되는 제 2 데이터를 포함하고,상기 컨트롤러가, 상기 제 2 데이터의 연산이 완료되면 제 3 데이터가 저장된 제 3 물리 영역에 상기 제 2 논리주소를 할당하는 단계를 더 포함하도록 구성되는 데이터 처리 시스템의 동작 방법."}
{"patent_id": "10-2020-0029131", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 10 항에 있어서,상기 컨트롤러는, 상기 상기 호스트가 제 1 인터페이스를 통해 상기 메모리 장치로 접근하도록 하고,상기 컨트롤러는 제 2 인터페이스를 통해 상기 메모리 장치로 접근하는 데이터 처리 시스템의 동작 방법."}
{"patent_id": "10-2020-0029131", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "일 실시예에 의한 데이터 처리 시스템은 메모리 장치, 호스트가 어플리케이션의 오프로드 처리를 요청함에 따라 메모리 장치에 접근하여 어플리케이션을 처리하는 컨트롤러 및, 호스트가 어플리케이션 처리에 사용되는 데이터 를 메모리 장치의 타겟 영역에 저장함에 따라, 타겟 영역의 접근 권한을 컨트롤러가 갖도록 설정하고, 어플리케 이션의 처리 상태에 따라 타겟 영역의 접근 권한을 컨트롤러 또는 호스트가 갖도록 설정하며, 컨트롤러에 구비되 는 공유 메모리 관리부;를 포함하도록 구성될 수 있다."}
{"patent_id": "10-2020-0029131", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 컴퓨팅 장치에 관한 것으로, 보다 구체적으로는 데이터 처리 시스템 및 그 동작 방법에 관한 것이다."}
{"patent_id": "10-2020-0029131", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능 어플리케이션 및 빅데이터 분석에 대한 관심과 중요성이 높아지면서, 대용량의 데이터를 효율적으로 처리할 수 있는 컴퓨팅 시스템에 대한 요구가 증가하고 있다. 전통적인 컴퓨팅 시스템이 프로세서 중심 컴퓨팅에 집중하였다면, 최근의 컴퓨팅 시스템은 방대한 데이터를 고 속으로 병렬 처리할 수 있는 데이터 중심 컴퓨팅, 또는 메모리 중심 컴퓨팅으로 진화하였다. 이에 따라 프로세 서와 메모리 간의 데이터 병목 현상을 줄일 수 있어 연산 성능이 극대화되고 있다. 메모리 중심 컴퓨팅 장치에서는 연산을 수행하는 프로세서가 메모리 장치 내에 또는 메모리 장치에 근접하여 배 치될 수 있다. 빅 데이터 처리를 위해 프로세서와 메모리 장치 간에 방대한 양의 데이터가 송수신되어야 하며, 송수신되는 데이터의 양은 데이터 처리 시스템의 소모 전력 및 연산 성능과 밀접한 관계가 있다."}
{"patent_id": "10-2020-0029131", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 기술의 실시예는 호스트 및 호스트로부터 특정 연산을 오프로드하여 처리하는 프로세서가 호스트 독립적으로 메모리 장치에 접근할 수 있는 데이터 처리 시스템 및 그 동작 방법을 제공할 수 있다."}
{"patent_id": "10-2020-0029131", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 기술의 일 실시예에 의한 데이터 처리 시스템은 메모리 장치; 호스트가 어플리케이션의 오프로드 처리를 요 청함에 따라 상기 메모리 장치에 접근하여 상기 어플리케이션을 처리하는 컨트롤러; 및 상기 호스트가 상기 어 플리케이션 처리에 사용되는 데이터를 상기 메모리 장치의 타겟 영역에 저장함에 따라, 상기 타겟 영역의 접근 권한을 상기 컨트롤러가 갖도록 설정하고, 상기 어플리케이션의 처리 상태에 따라 상기 타겟 영역의 접근 권한 을 상기 컨트롤러 또는 상기 호스트가 갖도록 설정하며, 상기 컨트롤러에 구비되는 공유 메모리 관리부;를 포함 하도록 구성될 수 있다. 본 기술의 일 실시예에 의한 데이터 처리 시스템의 동작 방법은 메모리 장치 및, 상기 메모리 장치를 제어하는 컨트롤러를 포함하는 데이터 처리 시스템의 동작 방법으로서, 상기 호스트가 상기 컨트롤러로 어플리케이션의 오프로드 처리를 요청하고, 상기 어플리케이션 처리에 사용되는 데이터를 상기 메모리 장치의 타겟 영역에 저장 함에 따라, 상기 컨트롤러가 상기 타겟 영역의 접근 권한을 상기 컨트롤러가 갖도록 설정하는 단계; 및 상기 어 플리케이션의 처리 상태에 따라, 상기 컨트롤러가 상기 타겟 영역의 접근 권한을 상기 컨트롤러 또는 상기 호스 트가 갖도록 설정하는 단계;를 포함하도록 구성될 수 있다."}
{"patent_id": "10-2020-0029131", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 기술에 의하면, 메모리 장치 내(in-memory), 또는 메모리 장치와 근접한(near-memory) 곳에 구비된 프로세서 가 호스트와 독립적으로 메모리 장치에 접근하여 연산을 수행할 수 있다. 이에 따라 메모리 장치 접근에 필요한 시간을 감소시켜 데이터 처리 시스템의 소모 전력을 줄이고 연산 성능을 향상시킬 수 있다. 데이터 처리 시스템 외부의 호스트와 내부의 연산 코어가 메모리 장치에 동시에 접근할 수 있도록 독립적인 메 모리 인터페이스 및 독립적인 메모리 공간을 사용하므로 어느 하나의 장치가 메모리 장치를 점유함에 따른 성능 저하를 방지할 수 있다."}
{"patent_id": "10-2020-0029131", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 첨부된 도면을 참조하여 본 기술의 실시예를 보다 구체적으로 설명한다. 도 1은 일 실시예에 의한 데이터 처리 시스템을 포함하는 전자 장치의 구성도이다. 도 1을 참조하면, 전자 장치는 호스트 및 데이터 처리 시스템을 포함할 수 있다. 전자 장치는 개인용 컴퓨터, 서버 컴퓨터, 모바일 컴퓨팅 장치, 자동차의 전자 제어 장치 등 다양한 전자 장 치일 수 있다.전자 장치는 슈퍼컴퓨터 또는 컴퓨터 클러스터를 사용하여 협력적인 방식으로 연산을 수행하는 고성능 컴퓨 팅(High Performance Computing: HPC) 장치, 또는 개별적으로 데이터를 처리하는 네트워킹된 정보 처리 장치들 또는 서버들의 어레이를 포함할 수 있다. 호스트는 미도시한 사용자 인터페이스를 통해 사용자에게 다양한 서비스를 제공할 수 있다. 이를 위해 호 스트는 데이터 처리 시스템으로 데이터 처리와 관련된 요청과 어드레스, 그리고 필요한 경우 데이터를 전송하고, 그에 대한 처리 결과를 수신할 수 있다. 데이터 처리 시스템은 호스트의 요청 및 어드레스에 응답하여 대응하는 동작을 처리(연산)하고, 필요 한 경우 처리 결과로 얻어진 데이터를 호스트로 전송할 수 있다. 호스트는 데이터 처리 시스템으로 데이터 입출력을 요청하거나, 또는 데이터 입출력을 수반하는 어플 리케이션을 오프로드하여 처리(실행)할 것을 요청할 수 있다. 어플리케이션의 오프로드 처리 요청시 호스트 는 데이터 처리 시스템으로 동작 제어정보 및 초기 파라미터(또는 초기 파라미터가 저장된 메모리 영 역의 주소)를 전송할 수 있다. 동작 제어정보는 데이터 처리 시스템에서 실행할 어플리케이션 종류, 어플 리케이션의 프로그램 코드 또는 프로그램 코드의 저장 주소를 포함할 수 있고, 초기 파라미터는 프로그램 코드 를 실행시키기 위해 필요한 초기 데이터 또는 초기 데이터의 저장 주소를 포함할 수 있다. 데이터 처리 시스템은 동작 제어정보 및 초기 파라미터에 응답하여 호스트의 요청을 처리할 수 있다. 여 기에서, 오프로드란 호스트의 연산을 다른 장치, 예를 들어 데이터 처리 시스템으로 위임하는 것을 의 미한다. 일 실시예에서, 호스트는 데이터 처리 시스템으로 신경망 어플리케이션, 다른 관점에서는 신경망 처리 를 위한 연산을 오프로드하여 처리할 것을 요청할 수 있으나 이에 한정되는 것은 아니다. 호스트가 데이터 처리 시스템으로 신경망 어플리케이션을 위한 연산 처리를 요청하는 경우 초기 파라미터는 초기 데이터 및 초기 가중치를 포함할 수 있다. 데이터 처리 시스템은 메모리 장치 및 컨트롤러를 포함할 수 있다. 호스트는 데이터 처리 시스템으로 특정 어플리케이션의 오프로드 처리를 요청하기 위해 컨트롤러(30 0)로 동작 제어정보를 전송하는 한편, 메모리 장치로 초기 파라미터를 전송하여 저장할 수 있다. 메모리 장치는 컨트롤러의 제어에 따라 데이터를 저장하거나 저장된 데이터를 출력할 수 있다. 메모 리 장치는 복수의 메모리 모듈(200-1~200-l)을 포함할 수 있고, 페이지(바이트) 단위로 접근 가능하게 구 성될 수 있다. 즉, 컨트롤러는 메모리 장치에 페이지 단위로 접근할 수 있다. 메모리 모듈(200-1~200-l)은 휘발성 메모리 모듈을 포함할 수 있고, 이에 더하여 비휘발성 메모리 모듈을 더 포 함할 수 있다. 메모리 모듈은 워드라인(로우라인) 및 비트라인(컬럼라인, 스트링) 간에 접속되는 복수의 메모 리 셀을 포함하며, 예를 들어 하나의 워드라인에 접속되는 메모리 셀들이 하나의 페이지를 이룰 수 있다. 휘발성 메모리 모듈은 예를 들어 DRAM(Dynamic Random Access Memory) 및/또는 SRAM(Static Random Access Memory)을 포함하도록 구성될 수 있다. 비휘발성 메모리 모듈은 예를 들어 EEPROM(Electrically Erasable and Programmable ROM), 낸드(NAND) 플래시 메모리, 노어(NOR) 플래시 메모리, PRAM(Phase-Change RAM), ReRAM(Resistive RAM) FRAM(Ferroelectric RAM), STT-MRAM(Spin Torque Transfer Magnetic RAM)중 적어도 하 나를 포함하도록 구성될 수 있다. 일 실시예에서, 메모리 모듈(200-1~200-l) 각각은 인쇄회로 기판과 같은 모듈 보드 상에 장착된 다수의 메모리 칩들을 포함하는 SIMM(single in-line memory module) 또는 DIMM(dual inline memory module) 형태의 메모리 모듈 또는, 고 대역폭 메모리(high bandwidth memory, HBM)일 수 있다. HBM 모듈은 인터포저(Interposer) 상 에 장착된 복수의 HBM들 및 적어도 하나의 하드웨어 가속기를 포함할 수 있다. 일 실시예에서, 메모리 모듈 (200-1~200-l)은 모듈 보드 상에 컨트롤러를 포함하는 형태로, 또는 HBM 모듈의 경우 베이스 다이에 컨트 롤러를 포함하는 형태로 구성될 수 있다. 컨트롤러는 호스트로부터 제공되는 동작 제어정보에 따라, 어플리케이션 프로그램 코드 저장 주소에 대응하는 메모리 영역으로부터 프로그램 코드를 읽어와 내부 메모리에 로딩하는 한편, 메모리 장치로부터 초기 파라미터를 리드하고 내부 메모리에 로딩하여 프로그램 코드를 실행, 즉 연산할 수 있다. 어플리케이션 프 로그램 코드는 호스트의 메모리 또는 메모리 장치의 비휘발성 메모리 모듈에 저장될 수 있다. 어플리 케이션의 프로그램 코드를 실행함에 따라 생성된 데이터들은 메모리 장치에 저장되고 호스트로 제공될수 있다. 예를 들어, 프로그램 코드를 실행하여 생성된 데이터들은 휘발성 메모리 모듈에 임시 저장된 후, 필요 에 따라 비휘발성 메모리 모듈에 저장될 수 있다. 일 실시예에서, 호스트는 데이터 처리 시스템으로 기계학습이나 인공지능 어플리케이션, 예를 들어 신 경망 연산을 오프로드하여 처리할 것을 요청할 수 있다. 본 기술의 일 실시예에서, 컨트롤러는 호스트 인터페이스 및 메모리 인터페이스를 포함할 수 있 다. 컨트롤러는 메모리 장치에 근접하게 배치되어 메모리 인터페이스를 통해 메모리 장치(20 0)에 접근할 수 있다. 도 1에 도시한 데이터 처리 시스템은 메모리 근접 프로세서(Processor Near Memory; PNM)라 지칭될 수 있다. 일 실시예에서, 컨트롤러는 호스트가 특정 어플리케이션의 프로그램 코드 및 초기 파라미터를 메모리 장치에 저장하여 해당 어플리케이션을 오프로드하여 처리할 것을 요청함에 따라, 프로그램 코드가 저장된 메모리 장치의 제 1 영역 및 초기 파라미터가 저장된 메모리 장치의 제 2 영역에 대한 접근 권한을 컨트롤러가 소유하도록 설정할 수 있다. 컨트롤러는 어플리케이션 처리 결과에 따라 생성된 데이터 를 메모리 장치의 제 2 영역에 저장하는 한편, 제 2 영역에 대한 접근 권한을 호스트가 갖도록 변경할 수 있다. 호스트가 처리 요청한 어플리케이션의 실행이 종료될 때까지 호스트가 처리 대상 데이터를 메모리 장치 의 특정 영역에 저장함에 따라, 컨트롤러가 데이터 저장 영역에 대한 접근 권한을 변경하여 어플리케 이션을 처리하고, 접근 권한을 다시 호스트로 이양하는 등의 과정이 반복될 수 있다. 일 실시예에서, 호스트가 처리 요청한 어플리케이션을 처리하는 동안 컨트롤러가 지속적으로 사용하여 야 하는 제 1 데이터, 예를 들어 프로그램 코드가 저장된 메모리 영역은 해당 어플리케이션의 처리가 종료될 때 까지 컨트롤러에 의해서만 접근되도록 접근 권한을 설정할 수 있다. 한편, 호스트가 처리 요청한 어플리케이션을 처리하는 동안 연산되는 제 2 데이터(연산 데이터)가 저장된 메모리 영역은 연산이 수행되는 동안은 컨트롤러가 접근 권한을 갖도록, 연산이 종료된 후에는 호스트(1 0)가 접근 권한을 갖도록 설정할 수 있다. 이와 같이, 연산에 필요한 데이터가 저장된 영역에 컨트롤러가 독점적으로 접근하여 어플리케이션을 처리 하고, 처리 결과로 생성된 데이터는 호스트가 접근 가능하도록 할 수 있다. 따라서, 호스트와 메모리 장치 간에 송수신되는 데이터의 양이 최소화되어 전자 장치의 동작 속도가 향상될 수 있다. 일 실시예에서, 컨트롤러는 메모리 영역의 어드레스별 접근 권한 정보를 모드 설정 커맨드에 포함시켜 메 모리 장치로 전송할 수 있고, 이에 응답하여 메모리 장치는 모드 레지스터 셋(Mode Register Set; MRS)을 설정할 수 있다. 일 실시예에서, 메모리 장치는 뱅크로 구분되는 영역을 가질 수 있고, 컨트롤러 는 뱅크별 접근 권한 정보를 MRS 커맨드의 형태로 메모리 장치에 전송할 수 있다. 메모리 영역별 접근 권한 정보는 MRS를 통해 설정하는 것에 한정되지 않으며, 메일박스 등 다양한 방식을 이용 할 수 있다. 메모리 장치에 영역별 접근 권한 정보가 설정됨에 따라, 메모리 장치는 특정 메모리 영역(뱅크)을 접 근하려는 주체가 설정값과 동일한 경우에만 접근을 허용할 수 있다. 특정 메모리 영역(뱅크)에 접근하여는 주 체가 설정값과 상이한 경우에는 에러 정보를 생성하고 컨트롤러를 통해 호스트로 전송하여 디버깅에 이용하도록 할 수 있다. 도 2는 일 실시예에 의한 데이터 처리 시스템을 포함하는 전자 장치의 구성도이다. 도 2에 도시한 전자 장치는 호스트 및 데이터 처리 시스템을 포함할 수 있다. 데이터 처리 시스템은 복수의 메모리 모듈(200-1~200-L)을 포함하는 메모리 장치 및 컨트롤러(101 3)를 포함할 수 있다. 도 1에 도시한 데이터 처리 시스템과 비교하여, 도 2의 데이터 처리 시스템는 컨트롤러가 메모 리 장치 내에 구비되도록 단일 패키지로 구성될 수 있으며, 메모리 내 프로세서(Processor In Memory; PIM)이라 지칭될 수 있다. 단일 패키지란 집적 회로 장치들, 즉 컨트롤러와 메모리 장치를 하나의 패키지 내에 탑재한 것을 의미한다.도 3은 일 실시예에 의한 메모리 모듈의 구성도이다. 메모리 모듈(200-1~200-L)은 복수의 메모리 뱅크를 포함할 수 있다. 도 3을 참조하면, 메모리 뱅크는 데이터가 저장되는 메모리 셀 어레이, 메모리 셀 어레이의 프로그램, 리드, 리프레쉬 등의 내부 동작을 제어하는 주변 회로들(2013~2023)을 포함할 수 있다. 주변 회로들 (2013~2023)은 제어 로직, 전압 생성부, 어드레스 처리 회로, 로우 디코더, 컬럼 디 코더 및 입출력 회로를 포함할 수 있다. 메모리 셀 어레이는 복수의 메모리 셀들, 예를 들어 DRAM 셀들을 포함할 수 있다. 제어 로직은 입출력 회로로부터 수신받은 커맨드(CMD)에 응답하여 동작 코드(OP)를 출력할 수 있다. 제어 로직은 프로그램, 리드, 리프레쉬 동작에 필요한 전압들을 생성하기 위한 동작 코드(OP)를 출 력할 수 있다. 전압 생성부는 동작 코드(OP)에 응답하여 프로그램, 리드, 리프레쉬 동작에 필요한 동작 전압들(Vop)을 생성하고, 생성된 동작 전압들(Vop)을 출력할 수 있다. 어드레스 처리 회로는 입출력 회로로부터 수신한 어드레스(ADD)를 로우 어드레스(RADD)과 컬럼 어 드레스(CADD)로 구분하고 출력할 수 있다. 로우 디코더는 로우 어드레스(RADD)에 응답하여 동작 전압들(Vop)을 메모리 셀 어레이에 전달할 수 있다. 컬럼 디코더는 컬럼 어드레스(CADD)에 응답하여 입출력 회로로부터 수신한 데이터(DATA)를 메모리 셀 어레이에 전달하거나 메모리 셀 어레이로부터 리드된 데이터(DATA)를 입출력 회로로 전달할 수 있다. 입출력 회로는 컨트롤러(300, 1013)로부터 커맨드(CMD), 어드레스(ADD) 및 데이터(DATA)를 수신받을 수 있다. 입출력 회로는 컨트롤러(300, 1013)로부터 수신받은 커맨드(CMD)는 제어 로직으로, 어드레 스(ADD)는 어드레스 처리 회로로, 데이터(DATA)를 수신받고, 수신받은 데이터(DATA)를 컬럼 디코더(202 1)로 전송하고, 컬럼 디코더로부터 수신받은 데이터(DATA)를 컨트롤러(300, 1013)로 전송할 수 있다. 도 4는 일 실시예에 의한 컨트롤러의 구성도로서, 도 1에 도시한 컨트롤러의 일 예시도이다. 도 4를 참조하면, 일 실시예에 의한 컨트롤러는 공유 메모리 관리부, 호스트 인터페이스, ROM, RAM, 메모리 인터페이스 및 연산 코어를 포함할 수 있다. 공유 메모리 관리부는 메모리 장치의 동작 전반을 제어할 수 있고, 호스트가 전송하는 명령에 응 답하여 호스트가 요청한 연산을 처리하도록 연산 코어를 제어할 수 있다. 호스트 인터페이스는 호스트와 데이터 처리 시스템 간의 인터페이스를 제공할 수 있다. 호스트 인터페이스는 호스트로부터 제공되는 커맨드 및 데이터를 공유 메모리 관리부를 통해 연산 코어 로 제공할 수 있다. 호스트 인터페이스는 공유 메모리 관리부의 제어에 따라 호스트와 메 모리 장치 간에 데이터가 송수신되도록 할 수 있다. ROM은 컨트롤러의 동작에 필요한 프로그램 코드, 예를 들어 펌웨어 또는 소프트웨어가 저장되고, 프 로그램 코드들이 이용하는 코드 데이터 등이 저장될 수 있다. RAM은 컨트롤러의 동작에 필요한 데이터 또는 컨트롤러에 의해 생성된 데이터를 저장할 수 있 다. 메모리 인터페이스는 호스트가 도 5는 일 실시예에 의한 컨트롤러의 구성도이다. 제 1 및 제 2 메모리 인터페이스(3071, 3073)는 컨트롤러와 메모리 장치를 연결하는 물리적인 통신 채널일 수 있다. 일 실시예에서, 연산 코어는 전자 장치에서 실행되는 특화된 어플리케이션을 위한 연산을 수행할 수 있 다. 일 실시예에서, 전자 장치는 높은 대역폭을 요구하는 기계학습 어플리케이션, 또는 인공지능 어플리케 이션을 실행할 수 있고 연산 코어는 기계학습이나 인공지능 어플리케이션에 특화된 논리 함수를 실행하는 하드웨어 가속기일 수 있다.연산 코어는 호스트가 요청한 연산을 처리하기 위하여 호스트 또는 메모리 장치로부터 제공 되는 데이터를 이용할 수 있다. 호스트는 데이터 처리 시스템으로 특정 어플리케이션에 대한 연산 처리를 컨트롤러의 연산 코어 에서 오프로드하여 처리하도록 명령할 수 있고, 공유 메모리 관리부는 호스트의 오프로드 명령을 추출하고 복호화하여 연산 코어를 제어할 수 있다. 연산 코어는 공유 메모리 관리부로부터 출력된 명령에 응답하여 메모리 장치에 로딩된 프로그램 코드 및 초기 파라미터에 따라 연산을 수행할 수 있다. 연산 코어의 처리 결과로 생성된 데이터는 메모리 장치의 특정 영역에 저장되고 호스트로 전송될 수 있다. 일 실시예에서, 연산 코어는 산술논리장치(Arithmetic Logic Unit; ALU), 부동소수점장치(Floating-Point Unit; FPU)를 포함할 수 있다. 가속기는 FPGA(Field-programmable gate array), MPPA(Massively parallel processor array), GPU(Graphics processing unit), ASIC(Application-Specific Integrated Circuit), NPU(Neural processing unit), TPU(Tensor Processing Unit) 및 MPSoC(Multi-Processor System-on- Chip) 등의 다양한 종류의 가속기 중에서 선택될 수 있다. 일 실시예에서, 호스트가 특정 어플리케이션의 프로그램 코드 및 초기 파라미터를 메모리 장치에 저장 하고 해당 어플리케이션을 오프로드하여 처리할 것을 요청함에 따라, 공유 메모리 관리부는 프로그램 코드 가 저장된 메모리 장치의 제 1 영역 및 초기 파라미터가 저장된 메모리 장치의 제 2 영역에 대한 접 근 권한을 컨트롤러가 소유하도록 설정할 수 있다. 공유 메모리 관리부는 제 2 영역에 저장된 데이 터를 이용한 연산 결과를 메모리 장치의 제 2 영역에 저장하는 한편, 제 2 영역에 대한 접근 권한을 호스 트가 갖도록 변경할 수 있다. 호스트가 처리 요청한 어플리케이션의 실행이 종료될 때까지 호스트가 처리 대상 데이터를 메모리 장치 의 특정 영역에 저장하고, 컨트롤러가 데이터 저장 영역에 대한 접근 권한을 변경하여 어플리케이션 을 처리하고, 접근 권한을 다시 호스트로 이양하는 등의 과정이 반복될 수 있다. 도 5는 일 실시예에 의한 컨트롤러의 구성도로서, 도 2에 도시한 컨트롤러의 일 예시도이다. 도 5에 도시한 컨트롤러는 메모리 장치 내에서 호스트가 요청한 어플리케이션을 실행하도록 구성될 수 있다. 도 5를 참조하면, 컨트롤러는 메모리 장치와 제 1 버스 및 제 2 버스를 통해 접속될 수 있다. 제 1 버스는 호스트가 메모리 장치에 접근할 수 있는 경로이고, 제 2 버스는 공유 메모리 관리부가 메모리 장치에 전근할 수 있는 경로로 작용할 수 있다. 도 6은 일 실시예에 의한 공유 메모리 관리부의 구성도이다. 도 6을 참조하면, 공유 메모리 관리부는 커맨드 해석부, 모니터링부, 권한 설정부 및 어드레스 맵퍼를 포함할 수 있다. 커맨드 해석부는 호스트(10, 110)의 오프로드 명령을 추출하고 복호화하여 연산 코어309)를 제어할 수 있 다. 모니터링부는 호스트(10, 110)의 데이터가 저장되는 메모리 영역의 어드레스를 추출할 수 있다. 아울러, 메모리 장치(200, 1011)에 저장된 데이터를 이용한 연산 완료 여부를 감시할 수 있다. 권한 설정부는 호스트(10, 110)가 오프로드 처리 요청한 어플리케이션 관련 데이터가 저장된 메모리 영역 의 권한을 변경할 수 있다. 일 실시예에서, 권한 설정부는 호스트(10, 110)가 처리 요청한 어플리케이션을 처리하는 동안 컨트롤러 (300, 1013)가 지속적으로 사용하여야 하는 제 1 데이터, 예를 들어 프로그램 코드가 저장된 메모리 영역은 해 당 어플리케이션의 처리가 종료될 때까지 컨트롤러(300, 1013)에 의해서만 접근되도록 접근 권한을 설정할 수 있다. 한편, 호스트(10, 110)가 처리 요청한 어플리케이션을 처리하는 동안 연산되는 제 2 데이터가 저장된 메모리 영 역은 연산이 수행되는 동안은 컨트롤러(300, 1013)가 접근 권한을 갖도록, 연산이 종료된 후에는 호스트(10, 110)가 접근 권한을 갖도록 설정할 수 있다.호스트(10, 110) 및 컨트롤러(300, 1013)가 메모리 장치(200, 1011)의 물리 어드레스를 그대로 사용하여 메모리 장치(200, 1011)에 접근하거나, 호스트(10, 110)나 컨트롤러(300, 1013)에서 부여하는 논리 어드레스를 사용하 여 메모리 장치(200, 1011)에 접근할 수 있다. 어드레스 맵퍼는 컨트롤러(300, 1013)가 논리 어드레스를 사용하여 메모리 장치(200, 1011)에 접근하는 경우, 컨트롤러(300, 1013)로 접근 권한을 이양한 메모리 영역의 물리 어드레스와, 컨트롤러(300, 103)가 메모 리 장치(200, 1011)를 접근하는 데 사용하는 논리 어드레스 간의 맵핑 정보를 저장할 수 있다. 일 실시예에서, 어드레스 맵퍼는 호스트(10, 110)가 전송한 데이터가 저장된 메모리 영역 각각에 대해, 데이터가 저장된 순서에 따라 논리 주소를 초기값(예를 들어 0번지)부터 오름차순으로 할당하여 물리 주소와 맵 핑시킬 수 있으나 이에 한정되는 것은 아니다. 일 실시예에 의한 공유 메모리 관리부에 의하면, 상기 호스트(10, 110)가 어플리케이션 처리에 필요한 데 이터를 상기 메모리 장치(200, 1011)의 특정 영역에 저장함에 따라, 데이터 저장 영역의 접근 권한을 컨트롤러 (300, 1013)가 소유하도록 하고, 어플리케이션의 처리 상태에 따라 데이터 저장 영역의 접근 권한을 컨트롤러 (300, 1013) 또는 호스트(10, 110)가 갖도록 설정할 수 있다. 도 7 및 도 8은 실시예들에 따른 데이터 처리 시스템의 동작 방법을 설명하기 위한 흐름도이다. 도 7을 참조하면, 전자 장치(1, 11)에 전원이 인가되어 부팅되면(S101), 메모리 장치(200, 1011)의 모든 영역에 대한 접근 권한은 호스트(10, 110)에게 부여될 수 있다. 호스트(10, 110)가 데이터 처리 시스템(100, 101)으로 특정 어플리케이션의 오프로드 처리를 요청하고, 이를 위 한 데이터를 전송함에 따라(S103), 컨트롤러(300, 101)는 호스트(10, 110)가 데이터를 저장한 메모리 영역의 접 근 권한을 컨트롤러(300, 1013)가 소유하도록 설정할 수 있다(S105). 일 실시예에서, 호스트(10, 110)가 전송 하는 데이터는 메모리 장치(200, 1011)의 제 1 영역에 저장되는 프로그램 코드 및 메모리 장치(200, 1011)의 제 2 영역에 저장되고 프로그램 코드에 의해 연산되는 제 2 데이터를 포함할 수 있다. 접근 권한 설정시(S105) 컨 트롤러(300, 1013)는 제 1 영역 및 제 2 영역의 접근 권한을 컨트롤러(300, 1013)로 이양할 수 있다. 컨트롤러(300, 1013)는 제 1 영역에 저장된 프로그램 코드를 이용하여 제 2 영역에 저장된 데이터를 연산하고 (S107), 연산이 완료되면 제 2 영역에 대한 접근 권한을 호스트(10, 110)가 갖도록 변경하고 연산이 완료되었음 을 호스트(10, 110)로 보고할 수 있다(S109). 호스트(10, 110)는 오프로드 처리 요청할 추가 작업이 존재하는지 확인하여(S111), 추가 작업이 존재하는 경우 (S111:Y) 추가 작업을 처리하기 위한 데이터를 전송하고(S103), 이후의 과정이 수행될 수 있다. 추가 작업이 존재하지 않는 경우(S111:N)에는 메모리 장치(200, 1011)의 모든 영역에 대한 접근 권한을 호스트 (10, 110)가 갖도록 변경할 수 있다(S113). 도 8을 참조하면, 전자 장치(1, 11)에 전원이 인가되어 부팅되면(S200), 메모리 장치(200, 1011)의 모든 영역에 대한 접근 권한은 호스트(10, 110)에게 부여될 수 있다. 호스트(10, 110)가 데이터 처리 시스템(100, 101)으로 특정 어플리케이션의 오프로드 처리를 요청하고, 이를 위 한 제 1 데이터를 전송함에 따라(S201), 컨트롤러(300, 1013)는 호스트(10, 110)가 제 1 데이터를 저장한 메모 리 영역의 접근 권한을 컨트롤러(300, 1013)가 소유하도록 설정할 수 있다(S203). 일 실시예에서, 제 1 데이터 는 오프로드 처리 요청된 어플리케이션의 처리시 지속적으로 사용되는 데이터, 예를 들어 메모리 장치(200, 1011)의 제 1 영역에 저장되는 프로그램 코드를 포함할 수 있다. 호스트(10, 110)가 제 2 데이터를 전송함에 따라(S205), 컨트롤러(300, 1013)는 호스트(10, 110)가 제 2 데이 터를 저장한 메모리 영역의 접근 권한을 컨트롤러(300, 1013)가 소유하도록 설정할 수 있다(S207). 일 실시예에 서, 제 2 데이터는 메모리 장치(200, 1011)의 제 2 영역에 저장되고 프로그램 코드에 의해 연산되는 데이터를 포함할 수 있다. 제 2 영역에 저장된 데이터는 연산이 진행됨에 따라 중간 연산 결과 및 최종 연산 결과로 업 데이트될 수 있다. 컨트롤러(300, 1013)는 제 1 영역에 저장된 프로그램 코드를 이용하여 제 2 영역에 저장된 데이터를 연산하고 (S209), 연산이 완료되면 호스트(10, 110)로 보고하는 한편, 제 2 영역에 대한 접근 권한을 호스트(10, 110)가 갖도록 변경할 수 있다(S211). 호스트(10, 110)는 연산에 필요한 데이터가 제 2 영역의 크기를 초과하여 메모리 장치(200, 1011)로 전송할 추 가 데이터가 존재하는지 확인하여(S213), 추가 데이터가 존재하는 경우에는 제 3 데이터를 메모리 장치(200, 1011)의 제 3 영역에 저장할 수 있다(S215). 컨트롤러(300, 1013)는 제 2 영역에 저장된 제 2 데이터에 대한 연산이 완료되면 제 3 영역의 접근 권한을 컨트롤러(300, 1013)가 갖도록 변경하고(S217) 제 3 데이터에 대한 연산을 수행하는 단계(S209)로 진행할 수 있다. 추가 데이터가 존재하지 않는 경우(S213:N)에는 제 1 데이터인 프로그램 데이터에 의해 처리할 추가 작업이 존 재하는지 확인할 수 있다(S219). 추가 작업이 존재하는 경우(S219:Y)에는 단계 S205)로 진행하여 추가 작업을 처리하기 위한 데이터를 전송하고, 이후의 과정을 수행할 수 있다. 추가 작업이 존재하지 않는 경우(S219:N)에는 메모리 장치(200, 1011)의 모든 영역에 대한 접근 권한을 호스트(10, 110)가 갖도록 변경할 수 있다(S221). 도 9 및 도 10은 실시예들에 따른 데이터 처리 시스템의 동작 방법을 설명하기 위한 개념도이다. 도 9는 컨트롤러(300, 1013)가 메모리 장치(200, 1011)의 물리 어드레스를 그대로 사용하여 메모리 장치(200, 1011)에 접근하는 경우의 권한 설정 방법을 나타낸다. (a)에 도시한 것과 같이, 전자 장치(1, 11)에 전원이 인가되어 부팅되면, 메모리 장치(200, 1011)의 모든 영역 에 대한 접근 권한은 호스트(10, 110)에게 부여될 수 있다. (b)에 도시한 것과 같이, 호스트(10, 110)가 데이터 처리 시스템(100, 101)으로 특정 어플리케이션의 오프로드 처리를 요청하고, 이를 위한 프로그램 코드를 메모리 장치(200, 1011)의 제 1 영역(뱅크 7, 8)에 저장할 수 있 다. 이에 따라 컨트롤러(300, 101)는 뱅크 7 및 8에 대한 접근 권한을 컨트롤러(300, 1013)가 소유하도록 설정 할 수 있다. (c)에 도시한 것과 같이, 호스트(10, 110)가 프로그램 코드에 의해 연산할 제 2 데이터를 제 2 영역(뱅크 5, 6)에 저장함에 따라, 컨트롤러(300, 1013)는 뱅크 5 및 6에 대한 접근 권한을 컨트롤러(300, 1013)가 소유하도 록 설정할 수 있다. 아울러, 호스트(10, 110)는 다음 연산을 위한 데이터를 제 3 영역(뱅크 3, 4)에 준비해둘 수 있다. (d)에 도시한 것과 같이, 뱅크 5 및 6에 저장된 제 2 데이터에 대한 연산이 완료되면, 컨트롤러(300, 1013)는 뱅크 5 및 6에 대한 접근 권한을 호스트(10, 110)가 갖도록 변경하고 뱅크 3 및 4에 대한 접근 권한을 컨트롤러 (300, 1013)가 소유하도록 설정하고 연산할 수 있다. 도 10은 컨트롤러(300, 1013)가 메모리 장치(200, 1011)의 물리 어드레스에 논리 어드레스를 맵핑시켜 메모리 장치(200, 1011)에 접근하는 경우의 권한 설정 방법을 나타낸다. (a)에 도시한 것과 같이, 전자 장치(1, 11)에 전원이 인가되어 부팅되면, 메모리 장치(200, 1011)의 모든 영역 에 대한 접근 권한은 호스트(10, 110)에게 부여될 수 있다. (b)에 도시한 것과 같이, 호스트(10, 110)가 데이터 처리 시스템(100, 101)으로 특정 어플리케이션의 오프로드 처리를 요청하고, 이를 위한 프로그램 코드를 메모리 장치(200, 1011)의 제 1 영역(뱅크 7, 8)에 저장할 수 있 다. 이에 따라 컨트롤러(300, 101)는 물리 뱅크 7 및 8에 논리 주소 1 및 2를 맵핑시키고 논리 뱅크 1 및 2에 대한 접근 권한을 컨트롤러(300, 1013)가 소유하도록 설정할 수 있다. (c)에 도시한 것과 같이, 호스트(10, 110)가 프로그램 코드에 의해 연산할 제 2 데이터를 제 2 영역(뱅크 5, 6)에 저장함에 따라, 컨트롤러(300, 1013)는 물리 뱅크 5 및 6에 논리 주소 3 및 4를 맵핑시키고 논리 뱅크 3 및 4에 대한 접근 권한을 컨트롤러(300, 1013)가 소유하도록 설정할 수 있다. 아울러, 호스트(10, 110)는 다음 연산을 위한 데이터를 제 3 영역(물리 뱅크 3, 4)에 준비해둘 수 있다. (d)에 도시한 것과 같이, 논리 뱅크 3 및 4에 저장된 제 2 데이터에 대한 연산이 완료되면, 컨트롤러(300, 1013)는 물리 뱅크 3 및 4 에 논리 주소 3 및 4를 맵핑시키고 논리 뱅크 3 및 4에 대한 접근 권한을 컨트롤러 (300, 1013)가 소유하도록 설정하고 연산할 수 있다. 모든 데이터에 대한 연산이 완료되면 모든 메모리 영역의 접근 권한을 호스트(10, 110)가 갖도록 설정할 수 있 다. 컨트롤러(300, 1013)가 논리 주소를 이용하여 메모리 장치(200, 1011)에 접근하는 경우 컨트롤러(300, 1013)가 동일한 논리 영역에 계속 접근하여 연산하도록 제어할 수 있어 메모리 영역별 접근 권한을 변경하는 빈도를 대폭 감소시킬 수 있다. 도 11 내지 도 13은 실시예들에 의한 적층형 반도체 장치의 구성도이다. 도 11은 일 실시예에 의한 적층형 반도체 장치의 구성도이다. 일 실시예에 의한 적층형 반도체 장치는 복수의 다이가 적층된 적층 구조체를 포함할 수 있다. 적층 구조체는 복수의 다이를 적층하고, 관통 전극(TSV, Through Silicon Via)을 통해 전기적으로 연결시킴으로 써 입/출력 유닛의 수를 늘려 대역폭(Bandwidth)을 증가시킨 HBM(High Bandwidth Memory) 형태로 구성될 수 있 다. 적층 구조체는 베이스 다이(Base Die) 및 복수의 코어 다이(Core Die)를 포함할 수 있다. 복수의 코어 다이는 베이스 다이 상에 적층될 수 있으며, 관통 전극(TSV)을 통해 서로 연결될 수 있 다. 코어 다이 각각에는 데이터를 저장하기 위한 메모리 셀들 및 메모리 셀의 코어 동작을 위한 회로들이 배치될 수 있다. 코어 다이는 관통전극(TSV)을 통해 베이스 다이와 전기적으로 접속되어, 관통전극(TSV)을 통해 베이 스 다이로부터 신호 및 전원 등을 제공받을 수 있다. 베이스 다이는 예를 들어 도 4 또는 도 5에 도시한 것과 같은 컨트롤러(300, 1013)를 포함할 수 있다. 베 이스 다이는 적층형 반도체 장치 내의 다양한 기능, 예를 들어, 메모리 셀들의 부분적 활성화를 통한 전력 관리 기능 혹은 코어 다이와 베이스 다이 간의 타이밍조절 기능들을 수행할 수 있다. 베이스 다이에 구비되는 물리 영역(PHY)은 어드레스, 명령어, 데이터, 제어신호 등의 입출력 영역일 수 있 다. 물리 영역(PHY)에는 적층형 반도체 장치에 요구되는 데이터 처리 속도를 만족시킬 수 있는 수만큼의 입출력 회로부가 구비될 수 있다. 그리고 베이스 다이의 배면 중 물리 영역(PHY) 부분에는 입출력 동작시 필요한 신호 및 전원을 공급받을 수 있도록 복수의 입출력 단자와 전원공급 단자가 구비될 수 있다. 도 12는 일 실시예에 의한 적층형 반도체 장치의 구성도이다. 도 12를 참조하면, 적층형 반도체 장치는 복수의 코어 다이와 베이스 다이의 적층 구조체, 메모리 호스트 및 인터페이스 기판을 포함할 수 있다. 호스트는 CPU, 또는 GPU, 또는 ASIC(Application Specific Integrated Circuit), 또는 FPGA(Field Programmable Gate Arrays) 등이 될 수 있 다. 베이스 다이는 코어 다이와 호스트 간의 인터페이스를 위한 회로가 실장될 수 있다. 적층 구조 체는 도 11을 참조하여 설명한 것과 유사한 구조를 가질 수 있다. 적층 구조체와 호스트는 인터페이스 기판을 통해 각각의 물리 영역(PHY)이 연결될 수 있다. 인 터페이스 기판은 인터포저(Interposer)가 지칭될 수 있다. 도 13은 일 실시예에 의한 적층형 반도체 장치의 구성도이다. 도 13에 도시한 적층형 반도체 장치는 도 12에 도시한 적층형 반도체 장치를 패키지 기판 상에 배치한 것으로 이해할 수 있다. 패키지 기판과 인터페이스 기판은 접속단자를 통해 전기적으로 접속될 수 있다. 인터페이스 기판 상에 도 11에 도시한 것과 같은 적층 구조체 및 호스트를 적층하고, 이를 패키 지 기판에 장착한 후 패키징함으로써 시스템 인 패키지(System In Package; SiP) 타입의 반도체 장치를 구 현할 수 있다. 도 14는 일 실시예에 의한 네트워크 시스템의 구성도이다. 도 14를 참조하면, 네트워크 시스템은 네트워크를 통해서 연결된 서버 시스템 및 복수의 클 라이언트 시스템들(5410~5430)을 포함할 수 있다. 서버 시스템은 복수의 클라이언트 시스템들(5410~5430)의 요청에 응답하여 데이터를 서비스할 수 있다. 예를 들면, 서버 시스템은 복수의 클라이언트 시스템들(5410~5430)로부터 제공된 데이터를 저장할 수 있 다. 다른 예로서, 서버 시스템은 복수의 클라이언트 시스템들(5410~5430)로 데이터를 제공할 수 있다.서버 시스템은 호스트 장치 및 메모리 시스템을 포함할 수 있다. 메모리 시스템은 도 1 내지 도 6에 도시한 데이터 처리 시스템으로 구성될 수 있다."}
{"patent_id": "10-2020-0029131", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "이와 같이, 본 발명이 속하는 기술분야의 당업자는 본 발명이 그 기술적 사상이나 필수적 특징을 변경하지 않고 서 다른 구체적인 형태로 실시될 수 있다는 것을 이해할 수 있을 것이다. 그러므로 이상에서 기술한 실시예들 은 모든 면에서 예시적인 것이며 한정적인 것이 아닌 것으로서 이해해야만 한다. 본 발명의 범위는 상기 상세 한 설명보다는 후술하는 특허청구범위에 의하여 나타내어지며, 특허청구범위의 의미 및 범위 그리고 그 등가개 념으로부터 도출되는 모든 변경 또는 변형된 형태가 본 발명의 범위에 포함되는 것으로 해석되어야 한다."}
{"patent_id": "10-2020-0029131", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일 실시예에 의한 데이터 처리 시스템을 포함하는 전자 장치의 구성도이다. 도 2는 일 실시예에 의한 데이터 처리 시스템을 포함하는 전자 장치의 구성도이다. 도 3은 일 실시예에 의한 메모리 모듈의 구성도이다. 도 4는 일 실시예에 의한 컨트롤러의 구성도이다. 도 5는 일 실시예에 의한 컨트롤러의 구성도이다. 도 6은 일 실시예에 의한 공유 메모리 관리부의 구성도이다. 도 7 및 도 8은 실시예들에 따른 데이터 처리 시스템의 동작 방법을 설명하기 위한 흐름도이다. 도 9 및 도 10은 실시예들에 따른 데이터 처리 시스템의 동작 방법을 설명하기 위한 개념도이다. 도 11 내지 도 13은 실시예들에 의한 적층형 반도체 장치의 구성도이다. 도 14는 일 실시예에 의한 네트워크 시스템의 구성도이다."}
