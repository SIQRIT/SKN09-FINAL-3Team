{"patent_id": "10-2023-7030113", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0005674", "출원번호": "10-2023-7030113", "발명의 명칭": "사이퍼제닉스 기반 생태계 보안 플랫폼들", "출원인": "퀀텀 디지털 솔루션즈 코포레이션", "발명자": "존슨, 윌리엄 씨."}}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "디바이스로서,하나 이상의 컴퓨터 판독가능한 저장 매체를 포함하는 스토리지 시스템,처리 시스템, 및처리 코어 세트를 포함하고,상기 스토리지 시스템은,인코딩된 컴퓨터 실행가능한 명령어 세트로 구성된 컴퓨터 프로그램;상기 인코딩된 컴퓨터 실행가능한 명령어 세트를 인코딩하는데 이용되었던 게놈 분화 객체를 포함하는 게놈 데이터 세트;상기 컴퓨터 프로그램에 대응하는 게놈 조절 명령어들(GRI; genomic regulation instructions)을 저장하고, 상기 게놈 조절 명령어들은 상기 인코딩된 컴퓨터 실행가능한 명령어 세트를 인코딩하는데 이용되었고;상기 처리 시스템은 VDAX를 포함하며,상기 VDAX는,상기 인코딩된 컴퓨터 실행가능한 명령어 세트로부터 실행될 인코딩된 명령어들을 수신하고;수정된 게놈 분화 객체 ―상기 수정된 게놈 분화 객체는 상기 GRI를 이용하여 상기 게놈 분화 객체로부터 수정됨― 및 상기 인코딩된 명령어들과 연관된 메타데이터로부터 추출된 서열들에 기초하여 상기 인코딩된 명령어들을 디코딩된 실행가능한 명령어로 디코딩하도록 구성되고;상기 처리 코어 세트는, 상기 VDAX로부터 상기 디코딩된 실행가능한 명령어들을 수신하고 상기 디코딩된 실행가능한 명령어들을 실행하도록 구성된, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 VDAX는 :상기 수정된 게놈 분화 객체를 획득하기 위해 계산 기능 세트를 이용해 상기 GRI에 기초하여 상기 게놈 분화 객체를 수정하고;상기 처리 디바이스에 의해 실행될 각각의 상응하는 인코딩된 명령어에 대해:상기 각각의 인코딩된 컴퓨터 실행가능한 명령어에 대응하는 게놈 결합 인자(GEF)를 획득하고, ―상기 GEF는 상기 각각의 인코딩된 컴퓨터 실행가능한 명령어, 상기 GRI, 및 상기 수정된 게놈 데이터 객체에 대응하는 메타데이터로부터 추출된 서열에 기초하여 생성됨―;각각의 디코딩된 실행가능한 명령어를 획득하기 위해 실행될 상기 각각의 인코딩된 명령어에 대응하는 GEF를 이용하여 상기 각각의 인코딩된 명령어를 디코딩하고;상기 각각의 디코딩된 명령어를 상기 처리 코어 세트 중의 한 처리 코어에 출력하도록 구성된, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 GEF를 이용하여 상기 각각의 인코딩된 명령어를 디코딩하는 것은, 상기 각각의 디코딩된명령어를 획득하기 위한 키로서 상기 GEF를 이용하여 상기 각각의 인코딩된 명령어를 해독하는 것을 포함하는,디바이스.공개특허 10-2024-0005674-3-청구항 4 제2항에 있어서, 상기 GEF를 이용하여 상기 각각의 인코딩된 명령어를 디코딩하는 것은, 상기 각각의 GEF를 이용하여 상기 각각의 인코딩된 명령어로부터 각각의 디코딩된 명령어를 명료화하는 것을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서, 상기 각각의 인코딩된 명령어로부터 상기 각각의 디코딩된 명령어를 명료화하는 것은, XOR 연산에 대한 입력으로서 상기 GEF와 상기 인코딩된 명령어를 이용하여 상기 XOR 연산을 실행하는 것을 포함하는,디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제2항에 있어서, 각각의 상응하는 인코딩된 명령어는, 각각의 상응하는 GEF가 상기 각각의 인코딩된 명령어에고유하게 대응하는 각각의 메타데이터로부터 추출된 각각의 서열에 기초하여 결정되도록, 상이한 각각의 GEF로인코딩되었던, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서, 상기 각각의 인코딩된 명령어에 고유하게 대응하는 각각의 메타데이터는, RAM(Random-AccessMemory) 메타데이터, 애플리케이션 메타데이터, 운영 체제-애플리케이션 메타데이터, 및 파일 시스템 메타데이터 중 하나 이상을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서, 상기 각각의 인코딩된 명령어를 디코딩하는데 이용되는 각각의 GEF를 생성하는데 이용되는 각각의 서열은 상기 각각의 메타데이터의 비트 표현으로부터 추출된 비트 세트인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제2항에 있어서, 상기 인코딩된 컴퓨터 실행가능한 명령어 세트는 명령어들의 복수의 서브세트를 포함하여, 상기 복수의 서브세트 중의 각각의 서브세트가 상기 컴퓨터 실행가능한 명령어들의 상기 각각의 서브세트에 각각대응하는 메타데이터로부터 추출된 각각의 서열에 기초하여 생성되는 각각의 GEF로 디코딩되도록 하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 각각의 서열이 추출되었던 각각의 메타데이터는 상기 서브세트에 대응하는 RAM(Random-Access Memory) 메타데이터, 상기 서브세트에 대응하는 애플리케이션 메타데이터, 상기 서브세트에 대응하는 운영 체제-애플리케이션 메타데이터, 및 상기 서브세트에 대응하는 파일시스템 메타데이터 중 하나 이상을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제2항에 있어서, 상기 각각의 인코딩된 컴퓨터 실행가능한 명령어에 대응하는 GEF를 획득하는 것은, 상기 GEF를획득하기 위해 상기 서열을 상기 수정된 게놈 데이터 객체에 서열 맵핑하는 것을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서, 상기 서열을 수정된 게놈 데이터 객체에 서열 맵핑하는 것은,상기 서열과 상기 GRI에 기초하여 서열 변환 벡터(SCV; Sequence Conversion Vector)를 생성하는 것;맵핑된 수정된 게놈 분화 객체를 획득하기 위해 상기 SCV에 기초하여 상기 수정된 게놈 분화 객체를 맵핑하는것; 및상기 맵핑된 수정된 게놈 분화 객체에 기초하여 상기 GEF를 생성하는 것을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1항에 있어서, 상기 스토리지 시스템은 제2 컴퓨터 프로그램을 저장하고, 상기 제2 컴퓨터 프로그램은 인코딩공개특허 10-2024-0005674-4-된 컴퓨터 실행가능한 명령어들의 제2 세트와, 상기 인코딩된 컴퓨터 실행가능한 명령어들의 제2 세트를 디코딩하는데 이용되는 상기 제2 컴퓨터 프로그램에 대응하는 제2 GRI를 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제11항에 있어서, 상기 제2 GRI는 상기 인코딩된 컴퓨터 실행가능한 명령어 세트를 디코딩하는데 이용되는 GRI와는 상이한, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서, 상기 스토리지 디바이스는 또한, 상기 인코딩된 컴퓨터 실행가능한 명령어들의 제2 세트를 인코딩 및 디코딩하는데 이용되며 상기 인코딩된 컴퓨터 실행가능한 명령어 세트를 인코딩 및 디코딩하는데 이용되는 상기 게놈 분화 객체와는 상이한 제2 게놈 분화 객체를 저장하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제14항에 있어서, 상기 게놈 분화 객체가 제2 GRI를 이용하여 수정되어 제2 수정된 게놈 분화 객체를 획득하여,상기 제2 수정된 게놈 분화 객체가 상기 인코딩된 컴퓨터 실행가능한 명령어들의 제2 세트를 디코딩하는데 이용되도록 하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제1항에 있어서, 상기 처리 시스템은 처리 디바이스이고, 상기 VDAX는 상기 처리 디바이스의 전용 코어인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제1항에 있어서, 상기 VDAX는 상기 처리 코어 세트와 전기적으로 통신하는 필드 프로그래머블 게이트 어레이인,디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제1항에 있어서, 상기 VDAX는 상기 처리 코어 세트와 전기적으로 통신하는 마이크로프로세서인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제1항에 있어서, 상기 VDAX는 처리 코어 세트에 의해 실행되는 운영 체제에 포함되는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제1항에 있어서, 상기 게놈 분화 객체는 ZNA 객체인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제1항에 있어서, 상기 디바이스는 서버 컴퓨팅 디바이스인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제1항에 있어서, 상기 디바이스는 모바일 컴퓨팅 디바이스인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제1항에 있어서, 상기 디바이스는 개인용 컴퓨팅 디바이스인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제1항에 있어서, 상기 디바이스는 차량인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "제1항에 있어서, 상기 디바이스는 사물 인터넷 디바이스인, 디바이스.공개특허 10-2024-0005674-5-청구항 27 제1항에 있어서, 상기 디바이스는 센서 디바이스인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "제1항에 있어서, 상기 디바이스는 비디오 녹화 디바이스인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "제1항에 있어서, 상기 디바이스는 착용형 컴퓨팅 디바이스인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "제1항에 있어서, 상기 디바이스는 스마트 기기인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "제1항에 있어서, 상기 디바이스는 네트워크 라우터인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제1항에 있어서, 상기 디바이스는 게임 디바이스인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "제1항에 있어서, 상기 컴퓨터 프로그램은 소프트웨어 애플리케이션인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제1항에 있어서, 상기 컴퓨터 프로그램은 미들웨어 애플리케이션인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "제1항에 있어서, 상기 컴퓨터 프로그램은 펌웨어 애플리케이션인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "제1항에 있어서, 상기 컴퓨터 프로그램은 운영 체제인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "디바이스의 신뢰받는 실행 환경에서 컴퓨터 프로그램들을 실행하기 위한 방법으로서,제1 컴퓨터 프로그램을 포함하는 하나 이상의 컴퓨터 프로그램의 세트에 대응하는 게놈 분화 객체를 리트리브하는 단계, ―상기 제1 컴퓨터 프로그램은 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트를 포함하고, 상기 게놈 분화 객체는 특정한 길이의 2원 벡터를 포함함―;제1 수정된 게놈 분화 객체를 획득하기 위해 제1 게놈 조절 명령어들(GRI)에 기초하여 상기 게놈 분화 객체를수정하는 단계, ―상기 제1 GRI는 상기 제1 컴퓨터 프로그램의 상기 인코딩된 실행가능한 명령어들의 제1 세트를 인코딩하는데 이용되었음―;상기 제1 컴퓨터 프로그램의 상기 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트로부터 실행될 제1 인코딩된명령어를 획득하는 단계;상기 제1 인코딩된 명령어와 연관된 제1 메타데이터로부터 제1 서열을 획득하는 단계;상기 제1 서열 및 상기 제1 수정된 게놈 분화 객체에 기초하여 제1 게놈 결합 인자(GEF)를 생성하는 단계;제1 디코딩된 명령어를 획득하기 위해 상기 제1 GEF를 이용하여 상기 제1 인코딩된 명령어를 디코딩하는 단계;및상기 제1 디코딩된 명령어를 실행하는 단계공개특허 10-2024-0005674-6-를 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "제37항에 있어서,상기 제1 컴퓨터 프로그램의 상기 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트로부터 실행될 제2 인코딩된명령어를 획득하는 단계;상기 제2 인코딩된 명령어와 연관된 제2 메타데이터로부터 제2 서열을 획득하는 단계;상기 제2 서열 및 상기 수정된 게놈 분화 객체에 기초하여 제2 GEF를 생성하는 단계;제2 디코딩된 명령어를 획득하기 위해 상기 제2 GEF를 이용하여 상기 제2 인코딩된 명령어를 디코딩하는 단계;및상기 제2 디코딩된 명령어를 실행하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_39", "content": "제37항에 있어서,제2 수정된 게놈 분화 객체를 획득하기 위해 상기 컴퓨터 프로그램 세트 중 제2 컴퓨터 프로그램에 대응하는 제2 GRI로 상기 게놈 분화 객체를 수정하는 단계, ―상기 제2 컴퓨터 프로그램은 인코딩된 컴퓨터 실행가능한 명령어들의 제2 세트를 포함함―;상기 제2 컴퓨터 프로그램의 상기 인코딩된 컴퓨터 실행가능한 명령어들의 제2 세트로부터 실행될 제3 인코딩된명령어를 획득하는 단계;상기 제3 인코딩된 명령어와 연관된 제3 메타데이터로부터 제3 서열을 획득하는 단계;상기 제3 서열 및 상기 제2 수정된 게놈 분화 객체에 기초하여 제3 GEF를 생성하는 단계;제3 디코딩된 명령어를 획득하기 위해 상기 제3 GEF를 이용하여 상기 제3 인코딩된 명령어를 디코딩하는 단계;및상기 제3 디코딩된 명령어를 실행하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "제39항에 있어서, 상기 게놈 분화 객체는 상기 제1 컴퓨터 프로그램과 상기 제2 컴퓨터 프로그램 양쪽 모두에할당되는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "제40항에 있어서, 상기 제1 GRI는 상기 제1 컴퓨터 프로그램에만 대응하고 제2 GRI는 상기 제2 컴퓨터 프로그램에만 대응하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "제40항에 있어서, 상기 컴퓨터 프로그램 세트 중 상기 제1 컴퓨터 프로그램, 상기 제2 컴퓨터 프로그램, 및 임의의 다른 컴퓨터 프로그램들은 동일한 엔티티에 의해 배포되는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_43", "content": "제42항에 있어서, 상기 엔티티는 상기 게놈 분화 객체를 상기 제1 및 제2 컴퓨터 프로그램들에 할당하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_44", "content": "제39항에 있어서, 상기 디바이스의 VDAX는 상기 게놈 분화 객체를 상기 제1 및 제2 컴퓨터 프로그램들에 할당하공개특허 10-2024-0005674-7-는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_45", "content": "제44항에 있어서, 상기 VDAX는 상기 제1 GRI 및 상기 제2 GRI를 생성하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_46", "content": "제37항에 있어서,상기 제1 인코딩된 명령어 및 상기 제2 인코딩된 명령어를 디코딩하기 전에 상기 제1 컴퓨터 프로그램을 설치하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_47", "content": "제46항에 있어서, 상기 제1 컴퓨터 프로그램을 설치하는 단계는,상기 제1 컴퓨터 프로그램을 포함하는 미인코딩된 컴퓨터 실행가능한 명령어 세트를 획득하는 단계;상기 디바이스의 컴퓨터 판독가능한 저장 매체 상의 메모리를 상기 제1 컴퓨터 프로그램에 할당하는 단계;상기 제1 GRI를 생성하고 상기 제1 GRI를 상기 제1 컴퓨터 프로그램과 연관시키는 단계;상기 수정된 게놈 분화 객체를 획득하기 위해 상기 제1 GRI에 기초하여 상기 게놈 분화 객체를 수정하는 단계;상기 미인코딩된 컴퓨터 실행가능한 명령어 세트 중의 각각의 상응하는 미인코딩된 명령어에 대해, 상기 각각의 미인코딩된 명령어와 연관된 각각의 메타데이터로부터 각각의 서열을 결정하는 단계;상기 각각의 서열 및 상기 수정된 게놈 분화 객체에 기초하여 각각의 GEF를 생성하는 단계;상기 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트 중의 각각의 인코딩된 명령어를 획득하기 위해 상기 각각의 GEF를 이용하여 각각의 미인코딩된 컴퓨터 실행가능한 명령어를 인코딩하는 단계; 및상기 할당된 메모리의 메모리 위치에 각각의 인코딩된 명령어를 저장하는 단계에 의해 상기 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트를 생성하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_48", "content": "제47항에 있어서, 상기 각각의 서열이 추출되는 각각의 메타데이터는, RAM(Random-Access Memory) 메타데이터,애플리케이션 메타데이터, 운영 체제-애플리케이션 메타데이터, 및 파일시스템 메타데이터 중 하나 이상을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_49", "content": "제37항에 있어서, 상기 실행 환경은, 인코딩된 명령어들을 디코딩하는 처리 디바이스의 전용 코어인 실행가능한격리 컴포넌트들 VDAX와 상기 디코딩된 명령어들을 실행하는 처리 코어 세트를 포함하는 처리 디바이스인,방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_50", "content": "제37항에 있어서, 상기 게놈 분화 객체는 ZNA 객체인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_51", "content": "제37항에 있어서, 상기 디바이스는 서버 컴퓨팅 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_52", "content": "제37항에 있어서, 상기 디바이스는 모바일 컴퓨팅 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_53", "content": "공개특허 10-2024-0005674-8-제37항에 있어서, 상기 디바이스는 개인용 컴퓨팅 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_54", "content": "제37항에 있어서, 상기 디바이스는 차량인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_55", "content": "제37항에 있어서, 상기 디바이스는 게임 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_56", "content": "제37항에 있어서, 상기 디바이스는 사물 인터넷 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_57", "content": "제37항에 있어서, 상기 디바이스는 센서 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_58", "content": "제37항에 있어서, 상기 디바이스는 비디오 녹화 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_59", "content": "제37항에 있어서, 상기 디바이스는 착용형 컴퓨팅 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_60", "content": "제37항에 있어서, 상기 디바이스는 스마트 기기인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_61", "content": "제37항에 있어서, 상기 디바이스는 네트워크 라우터인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_62", "content": "제37항에 있어서, 상기 제1 컴퓨터 프로그램은 소프트웨어 애플리케이션인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_63", "content": "제37항에 있어서, 상기 제1 컴퓨터 프로그램은 미들웨어 애플리케이션인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_64", "content": "제37항에 있어서, 상기 제1 컴퓨터 프로그램은 펌웨어 애플리케이션인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_65", "content": "제37항에 있어서, 상기 제1 컴퓨터 프로그램은 운영 체제인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_66", "content": "디바이스의 신뢰받는 실행 환경에서 컴퓨터 프로그램들을 실행하기 위한 방법으로서,컴퓨터 프로그램을 포함하는 하나 이상의 컴퓨터 프로그램의 세트에 대응하는 게놈 분화 객체를 리트리브하는단계;수정된 게놈 분화 객체를 획득하기 위해 게놈 조절 명령어들(GRI)에 기초하여 상기 게놈 분화 객체를 수정하는단계; 및상기 컴퓨터 프로그램의 제1 실행가능한 명령어를 실행하는 단계 ― 상기 제1 실행가능한 명령어를 실행하는 단계는,상기 제1 실행가능한 명령어에 입력된 제1 인코딩된 데이터를 리트리브하는 단계;공개특허 10-2024-0005674-9-상기 제1 인코딩된 데이터와 연관된 제1 메타데이터로부터 제1 서열을 추출하는 단계;상기 제1 서열, 상기 GRI, 및 상기 수정된 게놈 분화 객체에 기초하여 제1 게놈 결합 인자(GEF)를 생성하는 단계;제1 디코딩된 데이터를 획득하기 위해 상기 제1 GEF에 기초하여 상기 제1 인코딩된 데이터를 디코딩하는 단계;상기 제1 디코딩된 데이터를 이용하여 상기 제1 실행가능한 명령어를 실행하는 단계를 포함함 ―; 및상기 컴퓨터 프로그램의 제2 실행가능한 명령어를 실행하는 단계 ― 상기 제2 실행가능한 명령어를 실행하는 단계는,상기 제2 실행가능한 명령어에 입력된 제2 인코딩된 데이터를 리트리브하는 단계;상기 제2 인코딩된 데이터와 연관된 제2 메타데이터로부터 제2 서열을 추출하는 단계;상기 제2 서열, 상기 GRI, 및 상기 수정된 게놈 분화 객체에 기초하여 제2 GEF를 생성하는 단계;제2 디코딩된 데이터를 획득하기 위해 상기 제2 GEF에 기초하여 제2 인코딩된 데이터를 디코딩하는 단계; 및상기 제2 디코딩된 데이터를 이용하여 제2 실행가능한 명령어를 실행하는 단계를 포함함 ―를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_67", "content": "제66항에 있어서, 상기 제1 실행가능한 명령어를 실행하는 단계는,상기 제1 실행가능한 명령어의 실행으로부터 발생하는 출력 데이터를 획득하는 단계;상기 출력 데이터, 상기 GRI, 및 상기 수정된 게놈 분화 객체에 대응하는 제3 서열에 기초하여 제3 GEF를 생성하는 단계; 및상기 제3 GEF에 기초하여 상기 출력 데이터를 제3 인코딩된 데이터로 변환하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_68", "content": "제67항에 있어서, 상기 제3 인코딩된 데이터를 메모리에 기입하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_69", "content": "제68항에 있어서, 상기 제3 서열은 상기 출력 데이터에 대응하는 메타데이터로부터 추출되며, 상기 메타데이터는, RAM(Random-Access Memory) 메타데이터, 애플리케이션 메타데이터, 운영 체제-애플리케이션 메타데이터, 및파일시스템 메타데이터 중 하나 이상을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_70", "content": "제69항에 있어서, 상기 제3 실행가능한 명령어에 입력된 제3 인코딩된 데이터를 리트리브하는 단계;상기 출력 데이터에 대응하는 메타데이터를 나타내는 값으로부터 상기 제3 서열을 추출하는 단계;상기 제3 서열, 상기 GRI, 및 상기 수정된 게놈 분화 객체에 기초하여 상기 제3 GEF를 생성하는 단계;상기 출력 데이터를 획득하기 위해 상기 제3 GEF에 기초하여 상기 제3 인코딩된 데이터를 디코딩하는 단계; 및상기 제1 실행가능한 명령어의 실행으로부터 발생하는 출력 데이터를 이용하여 상기 제1 실행가능한 명령어를실행하는 단계에 의해 상기 컴퓨터 프로그램의 제3 실행가능한 명령어를 실행하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_71", "content": "제66항에 있어서, 상기 제1 서열이 추출되는 상기 제1 메타데이터 및 상기 제2 서열이 추출되는 상기 제2 메타공개특허 10-2024-0005674-10-데이터는, RAM(Random-Access Memory) 메타데이터, 애플리케이션 메타데이터, 운영 체제-애플리케이션 메타데이터, 및 파일시스템 메타데이터 중 하나 이상을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_72", "content": "제66항에 있어서, 상기 제1 GEF를 생성하는 단계는,상기 제1 서열과 상기 제1 GRI에 기초하여 서열 변환 벡터(SCV; Sequence Conversion Vector)를 생성하는단계;맵핑된 수정된 게놈 분화 객체를 획득하기 위해 상기 SCV에 기초하여 상기 수정된 게놈 분화 객체를 맵핑하는단계; 및상기 맵핑된 수정된 게놈 분화 객체에 기초하여 상기 제1 GEF를 생성하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_73", "content": "제72항에 있어서, 상기 SCV를 생성하는 단계는 상기 제1 서열과 상기 GRI를 결합하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_74", "content": "제73항에 있어서, 상기 SCV를 생성하는 단계는, SCV를 획득하기 위해 하나 이상의 계산 기능을 상기 제1 서열과상기 GRI의 조합에 적용하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_75", "content": "제66항에 있어서, 상기 제1 인코딩된 데이터를 디코딩하는 단계는 제1 GEF를 이용하여 상기 제1 인코딩된 데이터를 해독하는 단계를 포함하고, 상기 제2 인코딩된 데이터를 디코딩하는 단계는 상기 제2 GEF를 이용하여 상기제2 인코딩된 데이터를 해독하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_76", "content": "제66항에 있어서, 상기 제1 인코딩된 데이터를 디코딩하는 단계는 제1 GEF를 이용하여 상기 제1 인코딩된 데이터를 명료화하는 단계를 포함하고, 상기 제2 인코딩된 데이터를 명료화하는 단계는 상기 제2 GEF를 이용하여 상기 제2 인코딩된 데이터를 해독하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_77", "content": "제66항에 있어서, 상기 게놈 분화 객체는 ZNA 객체인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_78", "content": "제77항에 있어서, 상기 ZNA 객체는 N x M 2진 행렬인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_79", "content": "제77항에 있어서, 상기 디바이스의 VDAX는 상기 ZNA 객체를 생성하여 상기 컴퓨터 프로그램에 할당하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_80", "content": "제66항에 있어서, 상기 디바이스는 서버 컴퓨팅 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_81", "content": "제66항에 있어서, 상기 디바이스는 모바일 컴퓨팅 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_82", "content": "제66항에 있어서, 상기 디바이스는 개인용 컴퓨팅 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_83", "content": "제66항에 있어서, 상기 디바이스는 차량인, 방법.공개특허 10-2024-0005674-11-청구항 84 제66항에 있어서, 상기 디바이스는 게임 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_85", "content": "제66항에 있어서, 상기 디바이스는 사물 인터넷 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_86", "content": "제66항에 있어서, 상기 디바이스는 센서 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_87", "content": "제66항에 있어서, 상기 디바이스는 비디오 녹화 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_88", "content": "제66항에 있어서, 상기 디바이스는 착용형 컴퓨팅 디바이스인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_89", "content": "제66항에 있어서, 상기 디바이스는 스마트 기기인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_90", "content": "제66항에 있어서, 상기 디바이스는 네트워크 라우터인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_91", "content": "제66항에 있어서, 상기 컴퓨터 프로그램은 소프트웨어 애플리케이션인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_92", "content": "제66항에 있어서, 상기 컴퓨터 프로그램은 미들웨어 애플리케이션인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_93", "content": "제66항에 있어서, 상기 컴퓨터 프로그램은 펌웨어 애플리케이션인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_94", "content": "제66항에 있어서, 상기 컴퓨터 프로그램은 운영 체제인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_95", "content": "원장 기반의 디지털 생태계에서 창작자 코호트에 의해 유지되는 자료 데이터 체인(MDC; Material Data Chain)의미검증된 부분을 검증하기 위한 방법으로서,검증 코호트의 처리 시스템에 의해, 창작자 코호트로부터 MDC의 미검증된 부분을 수신하는 단계, ―상기 MDC의미검증된 부분은, 상기 창작자 코호트에 의해 생성된 연속적인 자료 데이터 블록(MDB) 세트를 포함하고, 각각의상응하는 MDB는 각각의 MDB에 저장되어 있는 각각의 자료 데이터, MDB에 관련된 각각의 메타데이터, 및 검증 코호트에 관하여 창작자 코호트에 의해 생성된 창작자-생성된 검증값을 포함함―;상기 검증 코호트의 처리 시스템에 의해, 상기 원장 기반의 생태계에 관하여 상기 검증 코호트에 할당된 게놈분화 객체를 리트리브하는 단계;상기 검증 코호트의 처리 시스템에 의해, 창작자-생성된 검증값을 생성하기 위해 창작자 코호트에 의해 이용된제1 게놈 조절 명령어들(GRI)을 리트리브하는 단계;상기 검증 코호트의 처리 시스템에 의해, 수정된 분화 객체를 획득하기 위해 계산 기능 세트를 이용하여 상기제1 GRI에 기초해 게놈 분화 객체를 수정하는 단계;공개특허 10-2024-0005674-12-MDC의 미검증된 부분 내의 각각의 MDB에 대해:상기 처리 시스템에 의해, 상기 MDB, 상기 수정된 게놈 분화 객체, 및 상기 제1 GRI에 관해 추출된 서열에 기초하여 게놈 결합 인자(GEF)를 생성하는 단계;상기 MDB, 상기 MDC 내의 상기 MDB에 선행하는 MDB, 및 상기 GEF에 기초하여 검증자-생성된 검증값을 결정하는단계;상기 처리 시스템에 의해, 상기 검증자-생성된 검증값이 상기 MDB 내의 상기 창작자-생성된 검증값과 정합하는지를 결정하는 단계; 및상기 검증자-생성된 검증값이 상기 창작자-생성된 검증값과 정합한다고 결정하는 것에 응답하여, 상기 MDB가 상기 검증 코호트에 의해 검증되었음을 나타내는 상기 MDB에 대응하는 검증 기록을 생성하는 단계를 포함하고,상기 MDC의 미검증된 부분은, 상기 MDC의 미검증된 부분 내의 MDB들 각각이 상기 검증 코호트에 의해 검증되었을 때 상기 검증 코호트에 의해 검증되는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_96", "content": "제95항에 있어서, 각각의 MDB의 창작자-생성된 검증값은, 상기 MDB, 상기 MDC 내의 상기 MDB에 선행하는 MDB,및 제2 GRI를 이용하여 상기 창작자 코호트에 할당된 제2 게놈 분화 객체를 수정함으로써 상기 창작자 코호트에의해 도출되는 제2 수정된 게놈 분화 객체에 기초하여 상기 창작자 코호트에 의해 생성되고, 상기 제2 GRI는 상기 제1 GRI와 정합하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_97", "content": "제96항에 있어서, 각각의 MDB의 창작자-생성된 검증값은, 상기 검증 코호트에 할당된 게놈 분화 객체가 상기 창작자 코호트에 할당된 제2 게놈 분화 객체와 충분히 상관된 경우에만 상기 검증 코호트에 의해 생성된 검증자-생성된 검증값과 정합하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_98", "content": "제96항에 있어서, 각각의 MDB의 상기 창작자-생성된 검증값은, 상기 검증 코호트에 할당된 게놈 분화 객체가 상기 창작자 코호트에 할당된 제2 게놈 분화 객체와 정확히 정합하는 경우에만 상기 검증 코호트에 의해 생성된상기 검증자-생성된 검증값과 정합하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_99", "content": "제96항에 있어서, 상기 게놈 분화 객체는, 상기 원장 기반의 생태계의 게놈 토폴로지를 제어하는 생태계 VDAX에의해 상기 검증 코호트에 할당되고, 상기 제2 게놈 분화 객체는 상기 생태계 VDAX에 의해 상기 창작자 코호트에할당되는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_100", "content": "제95항에 있어서, 상기 제1 GRI는 일회성 링크 교환 프로세스 동안 상기 창작 코호트에 의해 생성 및 제공된,방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_101", "content": "제95항에 있어서, 상기 제1 GRI는 상기 검증 코호트에 의해 생성되었고 일회성 링크 교환 프로세스 동안에 상기창작 코호트에 제공되었던, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_102", "content": "제95항에 있어서, 상기 제1 GRI는 엔클레이브 VDAX에 의해 생성되었고, 창작 코호트, 검증 코호트, 및 하나 이상의 다른 검증 코호트에 제공되었어서, 상기 제1 GRI가 상기 창작자-생성된 검증값을 검증하기 위해 상기 검증코호트 및 상기 하나 이상의 다른 검증 코호트에 의해 이용되게 하는, 방법.공개특허 10-2024-0005674-13-청구항 103 제95항에 있어서, 상기 GEF를 생성하는 단계는,상기 서열과 상기 제1 GRI에 기초하여 서열 변환 벡터를 생성하는 단계;맵핑된 수정된 게놈 분화 객체를 획득하기 위해 상기 서열 변환 벡터에 기초하여 상기 수정된 게놈 분화 객체를맵핑하는 단계; 및상기 맵핑된 게놈 분화 객체에 기초하여 상기 GEF를 생성하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_104", "content": "제95항에 있어서, 상기 검증자-생성된 검증값을 생성하는 단계는,상기 MDB와 상기 MDC 내의 선행하는 MDB에 기초하여 링킹값을 생성하는 단계 ―상기 링킹값은 상기 MDB와 상기선행 MDB의 조합을 나타냄― ; 및상기 검증자-생성된 검증값을 획득하기 위해 상기 GEF에 기초하여 상기 링킹값에 하나 이상의 계산 기능을 적용하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_105", "content": "제104항에 있어서, 상기 링킹값을 생성하는 단계는,상기 MDB의 적어도 일부의 제1 해시값을 생성하는 단계;상기 선행 MDB의 적어도 일부의 제2 해시값을 생성하는 단계; 및상기 링킹값을 획득하기 위해 제1 해시값과 제2 해시값을 결합하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_106", "content": "제104항에 있어서, 상기 하나 이상의 계산 기능은, 상기 GEF를 키로서 이용하여 상기 링킹값을 상기 검증자-생성된 검증값으로 변환하는 하나 이상의 암호 기반의 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_107", "content": "제106항에 있어서, 상기 하나 이상의 암호 기반의 기능은 암호화 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_108", "content": "제106항에 있어서, 상기 하나 이상의 암호 기반의 기능은 명료화 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_109", "content": "제105항에 있어서, 상기 하나 이상의 계산 기능은, 상기 GEF를 입력 파라미터로서 이용하여 상기 링킹값을 상기검증자-생성된 검증값으로 변환하는 하나 이상의 암호 없는 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_110", "content": "제109항에 있어서, 상기 하나 이상의 암호 없는 기능은 해시 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_111", "content": "제104항에 있어서, 상기 하나 이상의 계산 기능은, 상기 GEF를 입력 파라미터로서 이용하여 상기 링킹값을 상기검증자-생성된 검증값으로 조합하여 변환하는, 하나 이상의 암호 없는 기능과 하나 이상의 암호 기반의 기능을포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_112", "content": "제95항에 있어서, 상기 검증 기록을 상기 창작자 코호트에 전송하는 단계를 더 포함하는 방법.공개특허 10-2024-0005674-14-청구항 113 제112항에 있어서, 상기 검증 코호트의 처리 시스템에 의해, 상기 검증 코호트에 의해 유지되는 검증 체인에 상기 검증 기록을 저장하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_114", "content": "제113항에 있어서, 상기 검증 기록을 저장하는 단계는,상기 MDC 내의 하나 이상의 각각의 MDB에 대응하는 하나 이상의 검증 기록을 포함하는 검증 블록을 생성하는 단계; 및상기 검증 체인에 상기 검증 블록을 추가하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_115", "content": "제114항에 있어서, 상기 검증 체인은, 상기 검증 코호트에 의해 유지되는 제2 MDC의 사이드체인(sidechain)인,방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_116", "content": "제112항에 있어서, 상기 창작자 코호트는, 검증 코호트들에 의해 제공된 검증 기록들을 유지하는 창작자-코호트검증 체인에 상기 검증 기록을 저장하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_117", "content": "제116항에 있어서, 상기 창작자-코호트 검증 체인은 상기 MDC의 사이드체인인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_118", "content": "자료 데이터 블록체인(MDC)을 유지하기 위한 방법으로서,원장 기반의 애플리케이션을 실행하는 프로세서들의 제1 세트와 창작자 코호트에 대응하는 창작자 VDAX에 의해,상기 원장 기반의 애플리케이션으로부터 미공증된 자료 데이터 블록(MDB; unnotarized material data block)을수신하는 단계, ―상기 미공증된 MDB는, 메타데이터 부분과, 상기 MDB에 저장되는 실질적 데이터를 포함하는 페이로드 부분을 포함함―;상기 창작자 VDAX에 의해, 상기 MDB의 상기 메타데이터 부분으로부터 제1 비트 서열을 추출하는 단계;상기 창작자 VDAX에 의해, 상기 제1 서열, 상기 창작자 VDAX에 할당된 제1 게놈 분화 객체, 및 상기 창작자VDAX에 의해 유지되는 제1 게놈 조절 명령어들(GRI)에 기초하여, 제1 게놈 결합 인자(GEF)를 생성하는 단계;상기 창작자 VDAX에 의해, 상기 미공증된 MBD에 대응하는 창작자-생성된 값을 획득하기 위해 상기 제1 GEF를 입력으로서 이용하여 하나 이상의 계산 기능을 상기 미공증된 MDB에 적용하는 단계;상기 프로세서들의 제1 세트에 의해, 상기 창작자-생성된 값으로 상기 미공증된 MBD를 디지털 방식으로 서명함으로써 상기 미공증된 MBD를 업데이트하는 단계;상기 프로세서들의 제1 세트에 의해, 상기 미공증된 MDB를 하나 이상의 공증 코호트에 제공하는 단계;상기 프로세서들의 제1 세트에 의해, 상기 하나 이상의 공증 코호트 각각으로부터 각각의 공증값을 수신하는 단계, ―각각의 상응하는 공증값은, 상기 하나 이상의 공증 코호트 중 각각의 공증 코호트에 의해 보유되는 각각의 GRI 및 상기 각각의 공증 코호트에 할당된 각각의 게놈 분화 객체를 이용하여 상기 각각의 공증 코호트에 의해 생성됨―;상기 프로세서들의 제1 세트에 의해, 공증된 MDB를 획득하기 위해 상기 하나 이상의 공증 코호트로부터 수신된각각의 공증값들로 상기 미공증된 MDB를 업데이트하는 단계; 및상기 프로세서들의 제1 세트에 의해, 상기 공증된 MDB를 상기 MDC에 추가하는 단계를 포함하는 방법.공개특허 10-2024-0005674-15-청구항 119 제118항에 있어서,상기 하나 이상의 공증 코호트 중의 공증 코호트에 대응하는 공증 VDAX를 실행하는 프로세서들의 제2 세트에 의해, 상기 미공증된 MDB를 수신하는 단계;상기 공증 VDAX에 의해, 상기 MDB의 상기 메타데이터 부분으로부터 제2 비트 서열을 추출하는 단계;상기 공증 VDAX에 의해, 상기 제2 서열, 상기 공증 VDAX에 할당된 제2 게놈 분화 객체, 및 상기 공증 VDAX에 의해 유지되는 제2 GRI에 기초하여, 제2 게놈 결합 인자(GEF)를 생성하는 단계;상기 공증 VDAX에 의해, 상기 미공증된 MBD에 대응하는 공증값을 획득하기 위해 상기 제2 GEF를 입력으로서 이용하여 하나 이상의 계산 기능을 상기 미공증된 MDB에 적용하는 단계; 및상기 프로세서들의 제2 세트에 의해, 상기 공증값을 상기 창작자 코호트에 제공하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_120", "content": "제119항에 있어서,상기 프로세서들의 제2 세트에 의해, 적어도 부분적으로 공증된 MDB를 획득하기 위해 상기 미공증된 MDB를 상기공증값으로 디지털 방식으로 서명하는 단계; 및상기 프로세서들의 제2 세트에 의해, 상기 공증 코호트에 의해 유지되는 제2 MDC를 적어도 부분적으로 공증된MDB로 업데이트하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_121", "content": "제120항에 있어서, 상기 공증값을 상기 창작자 코호트에 제공하는 단계는 상기 적어도 부분적으로 공증된 MDB를상기 창작자 코호트에 제공하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_122", "content": "제119항에 있어서, 상기 제2 GEF를 생성하는 단계는 상기 제2 서열 및 상기 제2 GRI에 기초하여 서열 변환 벡터(SCV)를 결정하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_123", "content": "제122항에 있어서, 상기 제2 GEF를 생성하는 단계는,맵핑된 게놈 분화 객체를 획득하기 위해 상기 SCV에 기초하여 상기 제2 게놈 분화 객체를 맵핑하는 단계;수정된 맵핑된 게놈 분화 객체를 획득하기 위해 상기 SCV 및 상기 제2 GRI 중 적어도 하나에 기초하여 상기 맵핑된 게놈 분화 객체를 수정하는 단계; 및상기 수정된 맵핑된 게놈 분화 객체에 기초하여 상기 제2 GEF를 결정하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_124", "content": "제121항에 있어서, 상기 제2 GEF를 생성하는 단계는,수정된 게놈 분화 객체를 획득하기 위해 상기 제2 GRI에 기초하여 상기 제2 게놈 분화 객체를 수정하는 단계;맵핑된 수정된 게놈 분화 객체를 획득하기 위해 상기 SCV에 기초하여 상기 수정된 게놈 분화 객체를 맵핑하는단계; 및상기 맵핑된 수정된 게놈 분화 객체에 기초하여 상기 제2 GEF를 결정하는 단계를 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_125", "content": "제124항에 있어서, 상기 방법은, 상기 수정된 게놈 분화 객체가 상기 창작자 코호트로부터 수신된 다른 MDB들에공개특허 10-2024-0005674-16-대한 후속 GEF들을 결정하는데 이용되도록, 상기 수정된 게놈 분화 객체를 저장하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_126", "content": "제119항에 있어서, 상기 비트들의 제2 서열은 상기 비트들의 제1 서열과 동일한, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_127", "content": "제119항에 있어서, 상기 제2 서열은 상기 비트들의 제1 서열과는 상이한, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_128", "content": "제119항에 있어서, 상기 하나 이상의 계산 기능은, 상기 제2 GEF를 키로서 이용하여 상기 미공증된 MDB의 적어도 일부를 상기 공증값으로 변환하는 하나 이상의 암호 기반의 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_129", "content": "제128항에 있어서, 상기 하나 이상의 암호 기반의 기능은 암호화 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_130", "content": "제128항에 있어서, 상기 하나 이상의 암호 기반의 기능은 명료화 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_131", "content": "제119항에 있어서, 상기 하나 이상의 계산 기능은, 상기 제2 GEF를 입력 파라미터로서 이용하여 상기 미공증된MDB의 적어도 일부를 상기 공증값으로 변환하는 하나 이상의 암호 없는 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_132", "content": "제131항에 있어서, 상기 하나 이상의 암호 없는 기능은 해시 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_133", "content": "제119항에 있어서, 하나 이상의 계산 기능은, 상기 제2 GEF를 입력 파라미터로서 이용하여 상기 미공증된 MDB의적어도 일부를 상기 공증값으로 변환하는, 조합으로 변환하는 하나 이상의 암호없는 기능과 하나 이상의 암호기반의 기능을 포함하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_134", "content": "제119항에 있어서, 상기 제2 게놈 분화 객체와 상기 제1 게놈 분화 객체는 상관된 게놈 분화 객체들인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_135", "content": "제119항에 있어서, 상기 제2 게놈 분화 객체와 상기 제1 게놈 분화 객체는 비상관된 게놈 분화 객체들인, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_136", "content": "제119항에 있어서,상기 프로세서들의 제2 세트에 의해, 검증 코호트로부터 확정 요청을 수신하는 단계, ―상기 확정 요청은 상기공증된 MDB를 포함함―; 및상기 공증 VDAX에 의해, 상기 공증된 MDB로부터 추출된 비트들의 제3 서열, 상기 제2 GRI, 및 상기 제2 게놈 데이터 객체에 기초하여, 상기 공증된 MDB에 기초해 재생성된 공증값을 생성하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_137", "content": "제136항에 있어서,상기 프로세서들의 제2 세트에 의해, 상기 재생성된 공증값이 상기 공증된 MDB를 공증하는데 이용된 공증값과정합하는지를 결정하는 단계; 및상기 재생성된 공증값이 상기 공증된 MDB를 공증하는데 이용된 공증값과 정합한다고 결정하는 것에 응답하여,공개특허 10-2024-0005674-17-상기 프로세서들의 제2 세트에 의해, 상기 공증된 MDB의 무결성을 확정하는 응답을 상기 검증 코호트에 제공하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_138", "content": "제136항에 있어서, 상기 프로세서들의 제2 세트에 의해, 상기 재생성된 공증값을 나타내는 응답을 상기 검증 코호트에 제공하는 단계를 더 포함하고, 상기 검증 코호트는, 상기 재생성된 공증값이 상기 공증된 MDB를 공증하는데 이용된 공증값과 정합한다는 결정에 응답하여 상기 공증된 MDB의 무결성을 확정하는, 방법."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_139", "content": "디바이스로서,게놈 데이터 세트가 할당된 VDAX, ―상기 게놈 데이터 세트는 상기 디바이스가 한 멤버가 되는 디지털 생태계에대응하고, 게놈 적격성 객체, 게놈 상관관계 객체, 및 게놈 분화 객체를 포함함―를 포함하고, 상기 VDAX는,상기 디지털 생태계 내의 제2 디바이스에 대한 제1 링크를 스폰하기 위한 링크 스폰 수단, ―상기 링크는, 상기VDAX에 의해 디코딩가능한 가상 2진 언어 스크립트(VBLS)를 생성하기 위해 상기 제2 디바이스에 의해 이용되는제1 게놈 조절 명령어들(GRI)을 포함함―;상기 VBLS에 인코딩되어 있는 디코딩된 디지털 객체들을 획득하기 위해 상기 제1 GRI 및 상기 게놈 분화 객체에기초하여 상기 디바이스에 대해 상기 제2 디바이스에 의해 생성된 VBLS를 디코딩하기 위한 VBLS 디코딩 수단을포함하는 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_140", "content": "제139항에 있어서, 상기 제1 링크는, 상기 제1 GRI를 포함하는 인코딩된 GRI, 상기 인코딩된 GRI로부터 상기 제1 GRI를 디코딩하기 위해 상기 제2 디바이스에 의해 이용되는 정보를 포함하는 인코딩된 링크 정보, 및 상기 인코딩된 링크 정보로부터 링크 정보를 디코딩하기 위해 상기 제2 디바이스에 의해 이용되는 공개 서열을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_141", "content": "제140항에 있어서, 상기 링크 스폰 수단은, 상기 게놈 적격성 객체, 상기 게놈 상관관계 객체, 상기 디바이스에대응하는 제1 자격증들, 및 상기 제2 디바이스에 대응하는 제2 자격증들에 기초하여 상기 제1 링크를 생성하는,디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_142", "content": "제141항에 있어서, 상기 링크 스폰 수단은, 상기 VDAX에 할당된 상기 게놈 적격성 객체, 상기 제1 자격증들, 및상기 제2 자격증들에 기초하여 상관관계 벡터를 생성함으로써 상기 제1 링크를 생성하고, 상기 상관관계 벡터는상기 링크 정보를 인코딩하는데 이용되는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_143", "content": "제142항에 있어서, 상기 게놈 적격성 객체는 상기 제1 자격증들을 이용하여 마스터 CNA 객체로부터 고유하게 도출되는 제1 CNA 객체인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_144", "content": "제143항에 있어서, 상기 링크 스폰 수단은, 상기 제1 CNA 객체, 상기 제1 자격증들, 및 상기 제2 자격증들에 기초하여 상기 상관관계 벡터를 생성하기 위한 수단을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_145", "content": "제144항에 있어서, 상기 상관관계 벡터를 생성하기 위한 수단은,상기 제1 디바이스에 고유하게 대응하고 상기 제1 CNA 객체에 할당되었던 상기 마스터 CNA 객체의 각각의 부분공개특허 10-2024-0005674-18-들을 나타내는 제1 코드 워드 벡터를 획득하기 위해 상기 제1 자격증들에 코드 맵핑 기능을 적용하고;상기 제2 디바이스에 고유하게 대응하고 상기 제2 디바이스에 할당된 제2 CNA 객체에 할당되었던 상기 마스터CNA 객체의 각각의 부분들을 나타내는 제2 코드 벡터를 획득하기 위해 상기 제2 자격증들에 코드 맵핑 기능을적용하고;상기 제1 코드 벡터와 제2 코드 벡터의 교차를 나타내는 교차 벡터를 결정하고;상기 교차 벡터에 기초하여 상기 제1 CNA 객체로부터 상관관계 벡터를 결정하도록 구성된, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_146", "content": "제144항에 있어서, 상기 상관관계 벡터는 상기 디바이스의 상기 제1 CNA 객체와 상기 제2 디바이스의 상기 제2CNA 객체 사이의 고유한 상관관계를 나타내는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_147", "content": "제142항에 있어서, 상기 게놈 적격성 객체는, 상기 디바이스에 대응하는 제1 자격증들을 이용하여 마스터 PNA객체로부터 고유하게 도출되는 PNA 객체이고, 상기 PNA 객체는 상기 디바이스에 의해 비밀로 유지되는 비밀 비율, 상기 디바이스에 할당된 공개 원시 다항식, 및 상기 마스터 PNA 객체의 공개 컴포넌트를 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_148", "content": "제147항에 있어서, 상기 마스터 PNA 객체의 공개 컴포넌트는, M차의 제1 마스터 원시 다항식, M차의 제2 마스터원시 다항식, 및 M비트 값들의 (N-1)개의 각각의 쌍을 포함하는 공개 컴포넌트를 포함하고, 상기 제1 자격증들및 상기 제2 자격증들은 N비트 벡터들로 표현되는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_149", "content": "제147항에 있어서, 상기 링크 스폰 수단은, 상기 디바이스의 PNA 객체와 상기 제2 디바이스의 결합 정보에 기초하여 상기 상관관계 벡터를 생성하기 위한 수단을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_150", "content": "제149항에 있어서, 상기 제2 디바이스의 결합 정보는 상기 제2 디바이스에 대응하는 자격증들 및 상기 제2 디바이스에 할당된 제2 공개 다항식을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_151", "content": "제140항에 있어서, 상기 링크 스폰 수단은,상기 게놈 적격성 객체, 상기 디바이스의 제1 자격증들, 및 상기 제2 디바이스의 제2 자격증들에 기초하여 상관관계 벡터를 생성하기 위한 수단;상기 제1 GRI를 생성하기 위한 수단;구역 참조 세트를 생성하기 위한 수단, ―각각의 구역 참조는 상기 게놈 상관관계 객체의 각각의 부분을 나타냄―;상기 게놈 상관관계 객체 및 상기 구역 참조 세트에 기초하여 윈도우 벡터를 생성하기 위한 수단;상기 윈도우 및 상기 제1 GRI에 기초하여 상기 공개 서열을 생성하기 위한 수단;상기 공개 서열, 상기 윈도우, 상기 디바이스의 상기 게놈 상관관계 객체에 기초하여 변환값을 생성하기 위한수단;상기 인코딩된 GRI를 획득하기 위해 상기 변환값을 이용하여 상기 제1 GRI를 인코딩하기 위한 수단; 및상기 인코딩된 링크 정보를 획득하기 위해 상기 상관관계 벡터를 이용하여 상기 구역 참조 세트를 인코딩하기위한 수단을 포함하는, 디바이스.공개특허 10-2024-0005674-19-청구항 152 제151항에 있어서, 상기 디바이스는, 상기 인코딩된 링크 정보, 상기 공개 서열, 및 상기 인코딩된 GRI를 상기제2 디바이스에 제공하고, 상기 제2 디바이스는, 상기 인코딩된 링크 정보, 상기 공개 서열, 상기 제2 디바이스에 할당된 제2 게놈 데이터 세트, 상기 제1 자격증들, 및 상기 제2 자격증들에 기초하여 상기 인코딩된 GRI를디코딩하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_153", "content": "제139항에 있어서, VBLS를 디코딩하기 위한 수단은,상기 제1 GRI, VBLS 객체의 미인코딩된 부분으로부터 추출된 서열, 및 상기 게놈 분화 객체에 기초하여 게놈 결합 인자(GEF)를 생성하기 위한 수단;디지털 객체의 디코딩된 부분을 획득하기 위해 상기 GEF에 기초하여 상기 VBLS 객체를 디코딩하기 위한 수단을포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_154", "content": "제153항에 있어서, 상기 VBLS 객체를 디코딩하기 위한 수단은, 상기 디지털 객체의 디코딩된 부분을 획득하기위한 키로서 상기 GEF를 이용하여 상기 VBLS 객체의 인코딩된 부분을 해독하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_155", "content": "제153항에 있어서, 상기 VBLS 객체를 디코딩하기 위한 수단은, 상기 디코딩된 디지털 객체를 획득하기 위해VBLS 객체의 미인코딩된 부분과 상기 GEF를 XOR함으로써 상기 VBLS 객체의 인코딩된 부분을 명료화하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_156", "content": "제153항에 있어서, 상기 디지털 객체는 미디어 프레임인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_157", "content": "제153항에 있어서, 상기 디지털 객체는 네트워크 패킷인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_158", "content": "제153항에 있어서, 상기 디지털 객체는 파일인, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_159", "content": "제139항에 있어서,상기 제2 디바이스에 의해 생성된 제2 GRI를 획득하기 위해 상기 제2 디바이스로부터 수신된 제2 링크를 디코딩하기 위한 링크 호스팅 수단, ―상기 제2 링크는, 제2 인코딩된 GRI, 상기 인코딩된 GRI를 디코딩하기 위한 제2인코딩된 링크 정보, 및 상기 제2 인코딩된 링크 정보를 디코딩하는데 이용되는 제2 공개 서열을 포함함―;상기 제2 GRI 및 상기 게놈 분화 객체에 기초하여 상기 제2 디바이스에 대한 디지털 객체들을 인코딩하기 위한VBLS 인코딩 수단을 더 포함하는 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_160", "content": "제159항에 있어서, 상기 링크 호스팅 수단은,상기 게놈 적격성 객체, 상기 디바이스의 제1 자격증들, 및 상기 제2 디바이스의 제2 자격증들에 기초하여 상관관계 벡터를 생성하기 위한 수단;구역 참조 세트를 획득하기 위해 상기 상관관계 벡터에 기초하여 상기 제2 인코딩된 링크 정보를 디코딩하기 위한 수단;상기 구역 참조 세트 및 상기 게놈 상관관계 객체에 기초하여 윈도우 벡터를 생성하기 위한 수단;공개특허 10-2024-0005674-20-상기 공개 서열, 상기 윈도우, 및 상기 디바이스의 상기 게놈 상관관계 객체에 기초하여 변환값을 생성하기 위한 수단; 및상기 제2 GRI를 획득하기 위해 상기 변환값을 이용하여 상기 제2 GRI를 디코딩하기 위한 수단을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_161", "content": "제160항에 있어서, 상기 VBLS 인코딩 수단은,상기 제1 GRI, 디지털 객체의 미인코딩된 부분으로부터 추출된 서열, 및 상기 게놈 분화 객체에 기초하여 게놈결합 인자(GEF)를 생성하기 위한 수단;상기 제2 디바이스에 의해 디코딩가능한 VBLS 객체를 획득하기 위해 상기 GEF에 기초하여 디지털 객체를 인코딩하기 위한 수단을 포함하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_162", "content": "제161항에 있어서, 상기 디지털 객체를 인코딩하기 위한 수단은 VBLS 객체를 획득하기 위한 키로서 상기 GEF를이용하여 상기 디지털 객체의 페이로드를 암호화하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_163", "content": "제161항에 있어서, 상기 디지털 객체를 인코딩하기 위한 수단은 상기 VBLS 객체를 획득하기 위해 상기 디지털객체의 페이로드와 GEF를 XOR하는, 디바이스."}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 개시내용은, 제어된 엔트로피를 나타내지만 게놈 무결성의 손실없이 계산적 복합 기능(computationally complex function)들 및 프로세스들에 의해 디지털 수정 및 재구성을 거치는 Cyphergenics(사이퍼제닉스)(CG) 지원형 보안 플랫폼들 및 대응하는 디지털 게놈 조성(digital genomic construction)들에 관한 것이다. 이들 (뒷면에 계속)"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "관련 출원의 상호참조 본 출원은, 2021년 2월 4일 출원된 미국 가출원번호 63/145,860호와 2021년 8월 4일 출원된 63/229,348호의 우 선권을 주장한다. 상기 출원들의 전체 개시내용은 참조에 의해 명세서에 포함된다. 발명의 분야 본 개시내용은, 제어된 엔트로피를 나타내지만 게놈 무결성의 손실없이 계산적 복합 기능(computationally complex function)들 및 프로세스들에 의해 디지털 수정 및 재구성을 거치는 Cyphergenics(사이퍼제닉스) (CG) 지원형 보안 플랫폼들 및 대응하는 디지털 게놈 조성(digital genomic construction)들에 관한 것이다. 이들 조성들은, 동시대 애플리케이션 및 네트워크 스택들과 상호운용가능한 게놈 네트워크 토폴로지들에 기초한 애플 리케이션 특유의 보안 아키텍쳐 및 상호 관심 ID(identity)를 갖는 포괄적으로 안전한 초확장성 디지털 생태계 들, 엔클레이브들 및/또는 디지털 코호트들의 형성을 가능케한다. 본 개시내용의 일부 구현에서, 보안 플랫폼 들은 생태계 멤버들 사이의 보안 데이터 교환을 용이화하도록 구성될 수 있다. 본 개시내용의 일부 양태에서, 보안 플랫폼은 가상의 신뢰받는 실행 도메인들을 용이화하도록 구성되며, 그에 따라 처리 환경은 명령어들 및 프로그램 데이터의 CG 기반의 인코딩 및 디코딩을 수행하도록 구성된다. 본 개시내용의 일부 양태에서, 보안 플랫폼은 MDC(Material Data Chain)들을 용이화하도록 구성된다."}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "ARPAnet 부속 노드 커뮤니티가 상호운용가능한 디지털 단일문화(Digital Monoculture)에 의해 지원되는 가상 디 지털 생태계들로 구성된 월드 와이드 웹 내로 그들의 경계를 허물고 돌파함에 따라 선인(Noble)과 악인 (Nefarious)을 구별해야 하는 요구조건이 시급하게 성장했다. 이 새로운 머신-접속된-세상이 직면한 중대한 결 과가 명백해질 무렵, 최초의 그 대응하는 기술들(예를 들어, 방화벽들, 분석들, 포렌식들, PKI, 프록시들, 및 모니터링)은 이미 네트워크 경계 순찰 및 신속 복구 서비스들로 격하되었다. 전문가들은, 암호화야말로 유일하게 증명가능한 머신-접속된-세상 보안 솔루션을 제공한다는 것에 광범위하게 동의한다. 양자(Quantum), 동형(Homomorphic), 및 난독화(Obfuscation) 기반의 암호화 연구는 막대한 투자를 유치했지만 영향력에 대해서는 희망사항 이상은 아니다. 그럼에도 불구하고, 모든 암호화 분야 중 가장 필수적이지만 절대적으로 복잡한 초확장성(hyper-scalability)은 미개척 상태로 남아 있다. 선형 확장성이 보존되는 경우에도 PKI를 사후 양자 상태(post quantum status)로 업데이트하려는 노력들은 많다. 출원인은 지금까지 다루기 힘든 초확장성 딜레마를 광범위하게 해결하는 Cyphergenics(CG) 기술을 개발하여 여 기서 공개했으며, 이에 대한 설명은 본 문서에서 공개된다. 논의될 바와 같이, Cyphergenics는 상호운용성을 완벽하게 보존하면서 오버헤드와 대역폭을 최소화하기 위해 암호화 기반의 디지털 생태계 보안의 무제한 배치를 가능케한다. 중요하게도, 초확장성은 기능적 동형 암호화 및 기능적 구별불가능한 난독화를 직접적으로 용이화 한다."}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "사이버 기반시설에 관한 공격과 사생활 정보에 관한 공격의 인위적인 분기는, 양쪽 모두가 동일한 디지털 생태 계(머신-접속된-세상)와 디지털 단일문화(만물과 상호운용가능한 만물)를 활용하기 때문에, 잘못된 방향으로 유 도되어 왔다. 보안 솔루션들은, 오래된 보안 기술들 및 방법들의 뛰어난 적응성 및 확장에도 불구하고 평범한 해결책이자, 사후 포렌식에서 전문적이면서도, 금지시 무기력한 상태로 남아 있다. (은밀한 감시가 가능한지에 관계없이) 전복, 간첩행위, 침입, 불법 복제 및 사생활에 대한 공격들을 저지하는 이들 기술들의 제한된 능력은 잘 문서화되어 있다. 점점 더 큰 디지털 공격 표면과 무기화된 맬웨어 및 프로세서 착취의 강력하고 새로운 변 종들, 및 궁극적으로 양자 컴퓨터 보조형 암호화 및 인공 지능 숙지형 전복 알고리즘들은 새로운 수준의 재앙을 예고한다. 선인들의 참여는 지금까지는 상상할 수 없는 제품들, 서비스들, 및 지식의 가상화를 촉진하고 효율성과 효능을 재정의했다. 동일한 네트워크 중심 캠퍼스 내에서, 악인들의 참여는 재앙적인 사이버 공격들(예를 들어, 전복, 간첩행위, 침입 및 불법 복제)과 사생활에 대한 만연된 공격(예를 들어, 은밀한 대중 감시, 프로파일링 및 동화)을 조장한다. 그들이 공유하는 것은 실질적으로 공통-기계어와 그들의 네트워크 중심 미션들에 대해 필수 적인 고유한 초확장성이며, 이것은 선인과 악인을 효과적으로 구별할 수 없게 만든다. 출원인은, 가장 중요한 네트워크 중심 역량이 다양한 디지털 코호트들(예를 들어, 네트워크들, 그리드들, 클라 우드들, 시스템들, 디바이스들, 기기들, 센서들, IoT, 애플리케이션들, 파일들, 및 데이터)로 구성된 디지털 생 태계도 아니고 그 상호운용가능한 디지털 단일문화도 아니라고 여긴다. 하루 수천억개의 무인 보안 인스턴스: 매일 수천억개의 보안 인스턴스에 의한 수백만개의 제어 지점에 의한 수십억개의 코호트들의 엄청난 치환을 설 명하는 것은, 유비쿼터스 주문형 결합(예를 들어, 접속, 통신, 협업, 및 조율)을 확장하기 위해 공유하는 공통 기계어 및 초확장성이다. 디지털 생태계와 디지털 단일문화를 재건하는 것은 여전히 비현실적이며, 끝없이 파괴적이고 재정적으로 경솔하 다. 계산적 양자-증거 암호화에 기초하여 공통 기계어를 변경할 수 있는 기술은 디지털 단일문화 상호운용성에 필수적인 초확장성을 제거하면서 매우 효과적인 보안을 제공할 것이다. 계산적으로 복합의 게놈 조성들에 기초한 완전히 새로운 기술인 CG(Cyphergenics)는, 현대 암호화를 다루기 어 렵게 제한되어 있지만 계산적으로 복합의 강력한 기반으로부터 해방한다. 실시예들에서, CG는 생화학적 가능형 조성들로서 직접 조절될 수 있는 계산 복잡성을 나타내는 정보 이론-조성된 게놈 조성들을 생성함으로써 사실상 의 무제한성을 가능케한다. 중요한 것은, CG 디지털 렌더링이 생화학적 무제한 속성들을 보존하면서 그들의 고 유한 차이들과 상관관계의 범위를 크게 확장한다는 것이다. CG는 계산 무결성이 손상되지 않는 한 전략적으로 조절되는 상이한 Digital-DNA에 기초하는 게놈 조성의 능력을 보존한다. 도 1은, 본 개시내용의 일부 실시예에 따른, 유기 생태계들 및 현대의 디지털 생태계들의 관련 속성들과 관련한 Cyphergenics-기반의 디지털 생태계들 의 속성을 도시한다. 실시예들에서, 정보 이론 원리들에 의해 결합된 고유한 게놈 및 암호학적 속성들은 Cyphergenics 기반의 기술이 무제한의 차이(제휴) 및 상관관계(인증)를 나타내는 고도로 기능적인 초확장성을 달성할 수 있게 한다. 이들 속성들은, 결국, 애플리케이션들이 보안을 훨씬 능가하는 강력한 속성들인, 가상 제휴, 가상 인증, 가상 기민성, 가상 유기적 결합 및 가상의 신뢰할 수 있는 실행 도메인들을 발생시킨다. 실시예들에서, Cyphergenics는 상호 관심 ID(디지털-DNA 관련되고 조절됨)를 갖는 특정한 디지털 생태계들, 엔 클레이브들 및 코호트들의 초확장성을 가능케하며, 이것은 그들의 결합의 활성 기반을 형성한다. 이들 도메인 상주 생태계들, 엔클레이브들, 및 코호트들은, 그들이 사악한 의도에 대해 무사히 공유하는 가상 2진 언어 스크립트(VBLS; Virtual Binary Language Script)라고 하는 상호 관심 ID를 반영하는 고유하고 비반복적이며 계산 적으로 양자-증거 속성들을 나타내는 초확장가능한 디지털 데이터 객체들 및 디지털 코더 객체들에 기초하여 참 여한다. Cyphergenics(CG) 기술은, 광범위한 디지털 가능 플랫폼들 및 컴포넌트 구성들에 의해 지원될 수 있지만, 본 개 시내용의 일부 실시예는 중요한 계산적으로 복합의 게놈 조성 및 디지털-DNA 조절 기능들 및 프로세스들의 질서 있는 수행을 보장하도록 구성된다. 실시예들에서, Cyphergenics 생태계 보안 플랫폼(CG-ESP)은, 특정한 계산적 및 게놈적 조성과 디지털 DNA 조절 기능들을 제어하는 모듈들로 구성될 수 있다. 실시예들에서, 이 적응성은, Cyphergenics 기능들이, 암호들에 의해, 암호없이, 또는 조합으로 렌더링될 수 있다면 매우 중요하다. 실시예들에서, Cyphergenics는, 그 모듈들 기반의 렌더링이 여러 목적을 서비스할 수 있도록 네트워크 중심적 관심들을 넘어서는 애플리케이션들을 지원한다. 예를 들어, 이들은, 개개의 게놈 정보 이론이 초확장성을 손상 시키지 않으면서 조성 및 조절 프로세스들 및 기능들을 재상상하고 점진적으로 개선하거나 수정하는 것을 가능 하게 허용하며, Cyphergenics 애플리케이션 준비 속성들 사이에서 계산적 및 기능적 혁신을 허용한다. 몇 가지 예외를 제외하고 보안 애플리케이션들은, 그들이 거래하기 위해 경유하는 네트워크 구성들과 이들 네트 워크들이 종종 유발하는 취약성들, 예를 들어, 소진된 IP-IV 주소들을 확장하기 위해 IP-SEC 보안의 NAT 우회를 견뎌야 한다. Cyphergenics VBLS 속성은, 강력하고 새로운 보안 애플리케이션-중심적 게놈 네트워크 토폴로지 들이 기존 네트워크 구성들에 대해 동시에, 상호운용가능하게, 주문형 방식으로 동작할 수 있게 한다. Cyphergenics는, Directed Architectures, Spontaneous Architectures, Ephemeral Architectures, Interledger Architecture 등을 포함하는 많은 보안 중심적 게놈 네트워크 토폴로지들을 가능케한다. 도 2는, 이러한 적응성의 한 예를 보여주며, 본 개시내용의 일부 실시예에 따른, 흔하게 알려진 애플리케이션의 다양한 계층들 및 네트워크 스택들에서 동일한 시공간에 걸쳐 적용될 수 있는 Cyphergenics 지원형 보안 스택 및 이러 한 애플리케이션으로 인해 발생할 수 있는 디지털 생태계들의 Cyphergenics 지원형 게놈 아키텍쳐들의 예들을 도시한다. 실시예들에서, 정보 이론 지원형 게놈 조성의 Cyphergenics의 범위는 디지털 코호트가 그들 자신의 개념 이전에 특정한 기업 및/또는 엔클레이브의 자손으로서 스폰(spawn)되는 것을 허용한다. 실시예들에서, Cyphergenics 지원형 디지털 생태계들은 예를 들어 시간 등의 순서에 대한 방향이 있거나 없이 유전학적으로 평탄하거나 계층 적으로 렌더링될 수 있다. 실시예들에서, Cyphergenics 코호트는 그 자신의 종-특이적 생태계들, 엔클레이브들, 및 자손(역 번식)의 후속 조성을 위한 명령어들을 보존하는 Cambrian Genome 운반체의 역할을 할 수 있으며, 이에 대해 상관관계 및 분화를 달성하기 위해 여전히 게놈 조절을 받아야 한다. 그 구현 및 실시가 본 특허의 상세한 설명에서 설명되어 있는 Cyphergenics와 포스트모던(양자 증명) 암호화 기"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 2, "content": "술에 대한 연구 사이의 차이점들이 아래에 요약되어 있으며 그 예는 도 3에서 볼 수 있다. 양자 컴퓨터 강화된 암호 분석을 물리치기 위한 동시대의 노력들은, 성공적이라 하더라도, 네트워크 중심적 보안 문제들이 계속해서 현저하고 실질적으로 고조되더라도, 현상 유지에 불과하다. 실시예들에서, Cyphergenics 기반의 기술은 기존 기술의 변형들 및 고유한 한계들을 개발하는 것이 아니라 기저 접근법들을 대체할 수 있다. 본 개시내용은, 상이하고 광범위한 상호 관심 ID들 및 토폴로지들을 갖는 무수한 디지털 생태계들에 적용되는 Cyphergenics 기반의 기술들 및 보안 플랫폼들의 상이한 구현에 관한 것이다. 본 개시내용의 실시예들에서, Cyphergenics 기반의 보안 플랫폼들의 인스턴스들은 그들이 서비스하는 각각의 생태계의 상이한 양태들을 최적 화하기 위해 상이한 유형들의 디지털 생태계들에 대해 상이한 아키텍쳐들로 구성될 수 있다."}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시내용의 일부 실시예에 따르면, 디바이스가 개시된다. 실시예들에서, 디바이스는 하나 이상의 컴퓨터 판 독가능한 저장 매체를 포함하는 스토리지 시스템을 포함하고, 여기서, 스토리지 시스템은 : 인코딩된 컴퓨터 실 행가능한 명령어 세트로 구성된 컴퓨터 프로그램; 인코딩된 컴퓨터 실행가능한 명령어 세트를 인코딩하는데 이 용되었던 게놈 분화 객체를 포함하는 게놈 데이터 세트; 및 컴퓨터 프로그램에 대응하는 게놈 조절 명령어(GRI; genomic regulation instruction)들을 저장하며, 여기서 게놈 조절 명령어들은 인코딩된 컴퓨터 실행가능한 명 령어 세트를 인코딩하는데 이용되었다. 디바이스는 VDAX 및 처리 코어 세트를 포함하는 처리 시스템을 더 포함 한다. VDAX는, 인코딩된 컴퓨터 실행가능한 명령어 세트로부터 실행될 인코딩된 명령어들을 수신하고, 인코딩 된 명령어들과 연관된 메타데이터로부터 추출된 서열들 및 수정된 게놈 분화 객체에 기초하여 인코딩된 명령어들을 디코딩된 실행가능한 명령어로 디코딩하도록 구성된다. 이들 실시예들에서, 수정된 게놈 분화 객체는 GRI 를 이용하여 게놈 분화 객체로부터 수정된다. 처리 코어 세트는 VDAX로부터 디코딩된 실행가능한 명령어들을 수신하고 디코딩된 실행가능한 명령어들을 실행하도록 구성된다. 일부 구현에서, 게놈 분화 객체는 ZNA 객체이 다. 구현들에서, VDAX는 수정된 게놈 분화 객체를 획득하기 위해 계산 기능 세트를 이용해 GRI에 기초하여 게놈 분 화 객체를 수정하도록 구성된다. 처리 디바이스에 의해 실행될 각각의 상응하는 인코딩된 명령어에 대해, VDAX 는 또한 : 각각의 인코딩된 컴퓨터 실행가능한 명령어들에 대응하는 게놈 결합 인자(GEF)를 획득하고, 각각의 디코딩된 실행가능한 명령어들을 획득하기 위해 실행될 각각의 인코딩된 명령어들에 대응하는 GEF를 이용하여 각각의 인코딩된 명령어들을 디코딩하고; 각각의 디코딩된 명령어들을 처리 코어 세트 중의 한 처리 코어에 출 력하도록 구성된다. 이들 구현들에서, GEF는, 각각의 인코딩된 컴퓨터 실행가능한 명령어들, GRI 및 수정된 게 놈 데이터 객체에 대응하는 메타데이터로부터 추출된 서열에 기초하여 생성된다. 이들 구현들 중 일부에서, GEF를 이용하여 각각의 인코딩된 명령어들을 디코딩하는 것은, 각각의 디코딩된 명령어를 획득하기 위한 키로서 GEF를 이용하여 각각의 인코딩된 명령어들을 해독하는 것을 포함한다. 일부 구현에서, GEF를 이용하여 각각의 인코딩된 명령어들을 디코딩하는 것은, 각각의 GEF를 이용하여 각각의 인코딩된 명령어로부터 각각의 디코딩된 명령어를 명료화하는 것을 포함한다. 이들 구현들 중 일부에서, 각각의 인코딩된 명령어로부터 각각의 디코딩 된 명령어들을 명료화하는 것은, XOR 연산에 대한 입력으로서 GEF와 인코딩된 명령어를 이용하여 XOR 연산을 실 행하는 것을 포함한다. 일부 구현에서, 각각의 상응하는 인코딩된 명령어는, 각각의 상응하는 GEF가 각각의 인 코딩된 명령어들에 고유하게 대응하는 각각의 메타데이터로부터 추출된 각각의 서열에 기초하여 결정되도록, 상 이한 각각의 GEF로 인코딩되었다. 이들 구현들 중 일부에서, 각각의 인코딩된 명령어에 고유하게 대응하는 각 각의 메타데이터는, RAM(Random-Access Memory) 메타데이터, 애플리케이션 메타데이터, 운영 체제-애플리케이션 메타데이터, 및 파일 시스템 메타데이터 중 하나 이상을 포함한다. 이들 구현들 중 일부에서, 각각의 인코딩된 명령어들을 디코딩하는데 이용되는 각각의 GEF를 생성하는데 이용되는 각각의 서열은 각각의 메타데이터의 비트 표현으로부터 추출된 비트 세트이다. 일부 구현에서, 인코딩된 컴퓨터 실행가능한 명령어 세트는 명령어들의 복수의 서브세트를 포함하되, 복수의 서브세트 중의 각각의 서브세트가 각각의 서브세트의 컴퓨터 실행가능한 명령어들에 각각 대응하는 메타데이터로부터 추출된 각각의 서열에 기초하여 생성되는 각각의 GEF로 디코딩되도 록 한다. 이들 구현들 중 일부에서, 각각의 서열이 추출된 각각의 메타데이터는 서브세트에 대응하는 RAM(Random-Access Memory) 메타데이터, 서브세트에 대응하는 애플리케이션 메타데이터, 서브세트에 대응하는 운영 체제-애플리케이션 메타데이터, 및 서브세트에 대응하는 파일시스템 메타데이터 중 하나 이상을 포함한다. 일부 구현에서, 각각의 인코딩된 컴퓨터 실행가능한 명령어에 대응하는 GEF를 획득하는 것은, GEF를 획득하기 위해 서열을 수정된 게놈 데이터 객체에 서열 맵핑하는 것을 포함한다. 이들 구현들 중 일부에서, 서열을 수정 된 게놈 데이터 객체에 서열 맵핑하는 것은 서열 및 GRI에 기초하여 서열 변환 벡터(SCV)를 생성하는 것; 맵핑 된 수정된 게놈 분화 객체를 획득하기 위해 SCV에 기초하여 수정된 게놈 분화 객체를 맵핑하는 것; 및 맵핑된 수정된 게놈 분화 객체에 기초하여 GEF를 생성하는 것을 포함한다. 구현들에서, 스토리지 시스템은 제2 컴퓨터 프로그램을 저장하고, 제2 컴퓨터 프로그램은, 인코딩된 컴퓨터 실 행가능한 명령어들의 제2 세트와, 인코딩된 컴퓨터 실행가능한 명령어들의 제2 세트를 디코딩하는데 이용되는 제2 컴퓨터 프로그램에 대응하는 제2 GRI를 포함한다. 이들 구현들 중 일부에서, 제2 GRI는 인코딩된 컴퓨터 실행가능한 명령어 세트를 디코딩하는데 이용되는 GRI와는 상이하다. 이들 구현들 중 일부에서, 스토리지 디바 이스는 또한, 인코딩된 컴퓨터 실행가능한 명령어들의 제2 세트를 인코딩 및 디코딩하는데 이용되며 인코딩된 컴퓨터 실행가능한 명령어 세트를 인코딩 및 디코딩하는데 이용되는 게놈 분화 객체와는 상이한 제2 게놈 분화 객체를 저장한다. 일부 구현에서, 게놈 분화 객체는, 제2 수정된 게놈 분화 객체가 인코딩된 컴퓨터 실행가능 한 명령어들의 제2 세트를 디코딩하는데 이용되도록, 제2 GRI를 이용하여 수정되어 제2 수정된 게놈 분화 객체 를 획득한다. 일부 구현에서, 처리 시스템은 처리 디바이스이고, VDAX는 처리 디바이스의 전용 코어이다. 일부 구현에서, VDAX는 처리 코어 세트와 전기적으로 통신하는 필드 프로그래머블 게이트 어레이이다. 일부 구현에서, VDAX는 처리 코어 세트와 전기적으로 통신하는 마이크로프로세서이다. 일부 구현에서, VDAX는 처리 코어 세트에 의해 실행되는 운영 체제에 포함된다. 구현들에서, 디바이스는, 서버 컴퓨팅 디바이스, 모바일 컴퓨팅 디바이스, 개인용 컴퓨팅 디바이스, 차량, 사물 인터넷 디바이스, 센서 디바이스, 비디오 녹화 디바이스, 착용형 컴퓨팅 디바이스, 스마트 기기, 네트워크 라우 터, 게임 디바이스 등 중의 하나이다. 구현들에서, 컴퓨터 프로그램은, 소프트웨어 애플리케이션, 미들웨어 애플리케이션, 펌웨어 애플리케이션, 및/또는 운영 체제이다. 본 개시내용의 일부 실시예에 따르면, 디바이스의 신뢰받는 실행 환경에서 컴퓨터 프로그램들을 실행하기 위한 방법이 개시된다. 이 방법은 제1 컴퓨터 프로그램을 포함하는 하나 이상의 컴퓨터 프로그램의 세트에 대응하는 게놈 분화 객체를 리트리브하는 단계를 포함하고, 여기서 제1 컴퓨터 프로그램은 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트를 포함하고 게놈 분화 객체는 특정한 길이의 2원 벡터를 포함한다. 이 방법은 제1 수정된 게놈 분화 객체를 획득하기 위해 제1 게놈 조절 명령어들(GRI)에 기초하여 게놈 분화 객체를 수정하는 단계를 더 포함하고, 여기서, 제1 GRI는 제1 컴퓨터 프로그램의 인코딩된 실행가능한 명령어들의 제1 세트를 인코딩하 는데 이용되었다. 이 방법은 또한, 제1 컴퓨터 프로그램의 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트로 부터 실행될 제1 인코딩된 명령어들을 획득하는 단계; 제1 인코딩된 명령어와 연관된 제1 메타데이터로부터 제1 서열을 획득하는 단계; 제1 서열 및 제1 수정된 게놈 분화 객체에 기초하여 제1 게놈 결합 인자(GEF)를 생성하 는 단계; 제1 디코딩된 명령어를 획득하기 위해 제1 GEF를 이용하여 제1 인코딩된 명령어를 디코딩하는 단계; 및 제1 디코딩된 명령어를 실행하는 단계를 포함한다. 일부 구현에서, 게놈 분화 객체는 ZNA 객체이다. 일부 구현에서, 이 방법은, 제1 컴퓨터 프로그램의 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트로부터 실 행될 제2 인코딩된 명령어들을 획득하는 단계; 제2 인코딩된 명령어와 연관된 제2 메타데이터로부터 제2 서열을 획득하는 단계; 제2 서열 및 수정된 게놈 분화 객체에 기초하여 제2 GEF를 생성하는 단계; 제2 디코딩된 명령어 를 획득하기 위해 제2 GEF를 이용하여 제2 인코딩된 명령어를 디코딩하는 단계; 및 제2 디코딩된 명령어를 실행 하는 단계를 더 포함한다. 일부 구현에서, 이 방법은, 제2 수정된 게놈 분화 객체를 획득하기 위해 컴퓨터 프로그램 세트 중 제2 컴퓨터 프로그램에 대응하는 제2 GRI로 게놈 분화 객체를 수정하는 단계를 더 포함하고, 여기서 제2 컴퓨터 프로그램은 인코딩된 컴퓨터 실행가능한 명령어들의 제2 세트를 포함한다. 이들 구현들에서, 이 방법은, 제2 컴퓨터 프로 그램의 인코딩된 컴퓨터 실행가능한 명령어들의 제2 세트로부터 실행될 제3 인코딩된 명령어를 획득하는 단계; 제3 인코딩된 명령어와 연관된 제3 메타데이터로부터 제3 서열을 획득하는 단계; 제3 서열 및 제2 수정된 게놈 분화 객체에 기초하여 제3 GEF를 생성하는 단계; 제3 디코딩된 명령어를 획득하기 위해 제3 GEF를 이용하여 제3 인코딩된 명령어를 디코딩하는 단계; 및 제3 디코딩된 명령어를 실행하는 단계를 더 포함한다. 이들 구현들 중 일부에서, 게놈 분화 객체는 제1 컴퓨터 프로그램과 제2 컴퓨터 프로그램 양쪽 모두에 할당된다. 이들 구현들 중 일부에서, 제1 GRI는 제1 컴퓨터 프로그램에만 대응하고 제2 GRI는 제2 컴퓨터 프로그램에만 대응한다. 일 부 구현에서, 컴퓨터 프로그램 세트 중 제1 컴퓨터 프로그램, 제2 컴퓨터 프로그램, 및 임의의 다른 컴퓨터 프 로그램은, 동일한 엔티티에 의해 배포된다. 이들 구현들 중 일부에서, 엔티티는 게놈 분화 객체를 제1 및 제2 컴퓨터 프로그램들에 할당한다. 일부 구현에서, 디바이스의 VDAX는 게놈 분화 객체를 제1 및 제2 컴퓨터 프로 그램들에 할당한다. 이들 구현들 중 일부에서, VDAX는 제1 GRI 및 제2 GRI를 생성한다. 일부 구현에서, 이 방법은 제1 인코딩된 명령어 및 제2 인코딩된 명령어를 디코딩하기 전에 제1 컴퓨터 프로그 램을 설치하는 단계를 더 포함한다. 이들 구현들 중 일부에서, 제1 컴퓨터 프로그램을 설치하는 단계는: 제1 컴퓨터 프로그램을 포함하는 미인코딩된 컴퓨터 실행가능한 명령어 세트를 획득하는 단계; 디바이스의 컴퓨터 판독가능한 저장 매체 상의 메모리를 제1 컴퓨터 프로그램에 할당하는 단계; 제1 GRI를 생성하고 제1 GRI를 제1 컴퓨터 프로그램과 연관시키는 단계; 수정된 게놈 분화 객체를 획득하기 위해 제1 GRI에 기초하여 게놈 분화 객 체를 수정하는 단계; 및 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트를 생성하는 단계를 포함한다. 인코 딩된 명령어들의 제1 세트를 생성할 때, 이 방법은, 미인코딩된 컴퓨터 실행가능한 명령어 세트 중의 각각의 상 응하는 미인코딩된 명령어에 대해 : 각각의 미인코딩된 명령어와 연관된 각각의 메타데이터로부터 각각의 서열 을 결정하는 단계; 각각의 서열 및 수정된 게놈 분화 객체에 기초하여 각각의 GEF를 생성하는 단계; 인코딩된 컴퓨터 실행가능한 명령어들의 제1 세트 중의 각각의 인코딩된 명령어를 획득하기 위해 각각의 GEF를 이용하여 각각의 미인코딩된 명령어를 인코딩하는 단계; 및 할당된 메모리의 메모리 위치에 각각의 인코딩된 명령어를 저 장하는 단계를 포함한다. 이들 구현들 중 일부에서, 각각의 서열이 추출되는 각각의 메타데이터는, RAM(Random-Access Memory) 메타데이터, 애플리케이션 메타데이터, 운영 체제-애플리케이션 메타데이터, 및 파 일시스템 메타데이터 중 하나 이상을 포함한다. 일부 구현에서, 실행 환경은, 인코딩된 명령어들을 디코딩하는 처리 디바이스의 전용 코어인 실행가능한 격리 컴포넌트들 VDAX와 디코딩된 명령어들을 실행하는 처리 코어 세트를 포함하는 처리 디바이스이다. 구현들에서, 디바이스는, 서버 컴퓨팅 디바이스, 모바일 컴퓨팅 디바이스, 개인용 컴퓨팅 디바이스, 차량, 사물 인터넷 디바이스, 센서 디바이스, 비디오 녹화 디바이스, 착용형 컴퓨팅 디바이스, 스마트 기기, 네트워크 라우터, 게임 디바이스 등 중의 하나이다. 구현들에서, 제1 컴퓨터 프로그램은, 소프트웨어 애플리케이션, 미들웨 어 애플리케이션, 펌웨어 애플리케이션, 및/또는 운영 체제이다. 본 개시내용의 일부 실시예에 따르면, 디바이스의 신뢰받는 실행 환경에서 컴퓨터 프로그램들을 실행하기 위한 방법이 개시된다. 이 방법은, 컴퓨터 프로그램을 포함하는 하나 이상의 컴퓨터 프로그램의 세트에 대응하는 게 놈 분화 객체를 리트리브하는 단계; 수정된 게놈 분화 객체를 획득하기 위해 게놈 조절 명령어들(GRI)에 기초하 여 게놈 분화 객체를 수정하는 단계; 및 컴퓨터 프로그램의 제1 실행가능한 명령어를 실행하는 단계를 포함한다. 구현들에서, 제1 실행가능한 명령어를 실행하는 단계는: 제1 실행가능한 명령어에 입력된 제1 인코 딩된 데이터를 리트리브하는 단계; 제1 인코딩된 데이터와 연관된 제1 메타데이터로부터 제1 서열을 추출하는 단계; 제1 서열, GRI 및 수정된 게놈 분화 객체에 기초하여, 제1 게놈 결합 인자(GEF)를 생성하는 단계; 제1 디 코딩된 데이터를 획득하기 위해 제1 GEF에 기초하여 제1 인코딩된 데이터를 디코딩하는 단계; 및 제1 디코딩된 데이터를 이용하여 제1 실행가능한 명령어를 실행하는 단계를 포함한다. 이 방법은, 컴퓨터 프로그램의 제2 실 행가능한 명령어를 실행하는 단계를 더 포함하고, 제2 실행가능한 명령어들을 실행하는 단계는, 제2 실행가능한 명령어들 입력된 제2 인코딩된 데이터를 리트리브하는 단계; 제2 인코딩 데이터와 연관된 제2 메타데이터로부터 제2 서열을 추출하는 단계; 제2 서열, GRI, 및 수정된 게놈 분화 객체에 기초하여, 제2 GEF를 생성하는 단계; 제2 디코딩된 데이터를 획득하기 위해 제2 GEF에 기초하여 제2 인코딩된 데이터를 디코딩하는 단계; 및 제2 디 코딩된 데이터를 이용하여 제2 실행가능한 명령어를 실행하는 단계를 포함한다. 일부 구현에서, 게놈 분화 객 체는 ZNA 객체이다. 이들 구현들 중 일부에서, ZNA 객체는 N x M 2진 행렬이다. 이들 구현들 중 일부에서, 디 바이스의 VDAX는 ZNA 객체를 생성하여 컴퓨터 프로그램에 할당한다. 일부 구현에서, 제1 실행가능한 명령어를 실행하는 단계는: 제1 실행가능한 명령어의 실행으로부터 발생하는 출 력 데이터를 획득하는 단계; 출력 데이터, GRI 및 수정된 게놈 분화 객체에 대응하는 제3 서열에 기초하여 제3 GEF를 생성하는 단계; 및 제3 GEF에 기초하여 출력 데이터를 제3 인코딩된 데이터로 변환하는 단계를 더 포함한 다. 이들 구현들 중 일부에서, 이 방법은 제3 인코딩된 데이터를 메모리에 기입하는 단계를 더 포함한다. 이 들 구현들 중 일부에서, 제3 서열은 출력 데이터에 대응하는 메타데이터로부터 추출되며, 여기서 메타데이터는, RAM(Random-Access Memory) 메타데이터, 애플리케이션 메타데이터, 운영 체제-애플리케이션 메타데이터, 및 파 일시스템 메타데이터 중 하나 이상을 포함한다. 일부 구현에서, 이 방법은, 제3 실행가능한 명령어에 입력된 제3 인코딩된 데이터를 리트리브하는 단계; 출력 데이터에 대응하는 메타데이터를 나타내는 값으로부터 제3 서 열을 추출하는 단계; 제3 서열, GRI, 및 수정된 게놈 분화 객체에 기초하여, 제3 GEF를 생성하는 단계; 출력 데 이터를 획득하기 위해 제3 GEF에 기초하여 제3 인코딩된 데이터를 디코딩하는 단계; 및 제1 실행가능한 명령어 의 실행으로부터 발생하는 출력 데이터를 이용하여 제1 실행가능한 명령어를 실행하는 단계에 의해, 컴퓨터 프 로그램의 제3 실행가능한 명령어를 실행하는 단계를 더 포함한다. 일부 구현에서, 제1 서열이 추출되는 제1 메타데이터 및 제2 서열이 추출되는 제2 메타데이터는, RAM(Random- Access Memory) 메타데이터, 애플리케이션 메타데이터, 운영 체제-애플리케이션 메타데이터, 및 파일시스템 메 타데이터 중 하나 이상을 포함한다. 일부 구현에서, 제1 GEF를 생성하는 단계는: 제1 서열 및 제1 GRI에 기초하여 서열 변환 벡터(SCV)를 생성하는 단계; 맵핑된 수정된 게놈 분화 객체를 획득하기 위해 SCV에 기초하여 수정된 게놈 분화 객체를 맵핑하는 단계; 및 맵핑된 수정된 게놈 분화 객체에 기초하여 제1 GEF를 생성하는 단계를 포함한다. 이들 구현들 중 일부에서, SCV를 생성하는 단계는 제1 서열과 GRI를 결합하는 단계를 포함한다. 이들 구현들 중 일부에서, SCV를 생성하 는 단계는, SCV를 획득하기 위해 하나 이상의 계산 기능을 제1 서열과 GRI의 조합에 적용하는 단계를 더 포함한 다. 일부 구현에서, 제1 인코딩된 데이터를 디코딩하는 단계는, 제1 GEF를 이용하여 제1 인코딩된 데이터를 해독하 는 단계를 포함하고, 제2 인코딩된 데이터를 디코딩하는 단계는, 제2 GEF를 이용하여 제2 인코딩된 데이터를 해 독하는 단계를 포함한다. 일부 구현에서, 제1 인코딩된 데이터를 디코딩하는 단계는, 제1 GEF를 이용하여 제1 인코딩된 데이터를 명료화 하는 단계를 포함하고, 제2 인코딩된 데이터를 명료화하는 단계는, 제2 GEF를 이용하여 제2 인코딩된 데이터를 해독하는 단계를 포함한다. 구현들에서, 디바이스는, 서버 컴퓨팅 디바이스, 모바일 컴퓨팅 디바이스, 개인용 컴퓨팅 디바이스, 차량, 사물 인터넷 디바이스, 센서 디바이스, 비디오 녹화 디바이스, 착용형 컴퓨팅 디바이스, 스마트 기기, 네트워크 라우 터, 게임 디바이스 등 중의 하나이다. 구현들에서, 제1 컴퓨터 프로그램은, 소프트웨어 애플리케이션, 미들웨어 애플리케이션, 펌웨어 애플리케이션, 및/또는 운영 체제이다. 본 개시내용의 일부 실시예에 따르면, 원장 기반의 디지털 생태계에서 창작자 코호트에 의해 유지되는 MDC(Material Data Chain)의 미검증된 부분을 검증하는 방법이 개시된다. 실시예들에서, 이 방법은, 검증 코호 트의 처리 시스템에 의해, 창작자 코호트로부터 MDC의 미검증된 부분을 수신하는 단계를 포함하고, MDC의 미검 증된 부분은 창작자 코호트에 의해 생성된 연속적인 자료 데이터 블록(MDB; material data block) 세트를 포함 한다. 각각의 상응하는 MDB는, 각각의 MDB에 저장되어 있는 각각의 자료 데이터, MDB와 관련된 각각의 메타데 이터, 및 검증 코호트에 관해 창작자 코호트에 의해 생성된 창작자-생성된 검증값을 포함한다. 이 방법은, 검 증 코호트의 처리 시스템에 의해, 원장 기반의 생태계에 관하여 검증 코호트에 할당된 게놈 분화 객체와 창작자 -생성된 검증값을 생성하기 위해 창작자 코호트에 의해 이용된 제1 게놈 조절 명령어들(GRI)을 리트리브하는 단 계를 더 포함한다. 이 방법은, 검증 코호트의 처리 시스템에 의해, 수정된 분화 객체를 획득하기 위해 계산 기 능 세트를 이용하여 제1 GRI에 기초해 게놈 분화 객체를 수정하는 단계를 더 포함한다. MDC의 미검증된 부분 내의 각각의 MDB에 대해, 이 방법은, MDB, 수정된 게놈 분화 객체, 및 제1 GRI에 관해 추출된 서열에 기초하여 게놈 결합 인자(GEF)를 생성하는 단계; MDB, MDC 내의 상기 MDB에 선행하는 MDB, 및 GEF에 기초하여 검증자-생 성된 검증값을 결정하는 단계; 검증자-생성된 검증값이 MDB 내의 창작자-생성된 검증값과 정합하는지를 결정하 는 단계; 및 검증자-생성된 검증값이 창작자-생성된 검증값과 정합한다고 결정하는 것에 응답하여, MDB가 검증 코호트에 의해 검증되었음을 나타내는 MDB에 대응하는 검증 기록을 생성하는 단계를 더 포함한다. MDC의 미검 증된 부분은, MDC의 미검증된 부분 내의 MDB들 각각이 검증 코호트에 의해 검증되었을 때 검증 코호트에 의해 검증된다. 일부 구현에서, 각각의 MDB의 창작자-생성된 검증값은, MDB, MDC 내의 상기 MDB에 선행하는 MDB, 및 제2 GRI를 이용하여 창작자 코호트에 할당된 제2 게놈 분화 객체를 수정함으로써 창작자 코호트에 의해 도출되는 제2 수정 된 게놈 분화 객체에 기초하여, 창작자 코호트에 의해 생성되고, 여기서 제2 GRI는 제1 GRI와 정합한다. 이들 구현들 중 일부에서, 각각의 MDB의 창작자-생성된 검증값은, 검증 코호트에 할당된 게놈 분화 객체가 창작 자 코호트에 할당된 제2 게놈 분화 객체와 충분히 상관된 경우에만 검증 코호트에 의해 생성된 검증자-생성된 검증값과 정합한다. 일부 구현에서, 각각의 MDB의 창작자-생성된 검증값은, 검증 코호트에 할당된 게놈 분화 객체가 창작자 코호트에 할당된 제2 게놈 분화 객체와 정확히 정합하는 경우에만 검증 코호트에 의해 생성된 검 증자-생성된 검증값과 정합한다. 일부 구현에서, 게놈 분화 객체는, 원장 기반의 생태계의 게놈 토폴로지를 제 어하는 생태계 VDAX에 의해 검증 코호트에 할당되고, 제2 게놈 분화 객체는 생태계 VDAX에 의해 창작자 코호트 에 할당된다. 일부 구현에서, 제1 GRI는 일회성 링크 교환 프로세스 동안 창작 코호트에 의해 생성 및 제공되었다. 일부 구 현에서, 제1 GRI는 검증 코호트에 의해 생성되어 일회성 링크 교환 프로세스 동안에 창작 코호트에 제공되었다. 일부 구현에서, 제1 GRI는 엔클레이브 VDAX에 의해 생성되어, 창작 코호트, 검증 코호트, 및 하나 이상의 다른 검증 코호트에 제공되되, 제1 GRI는, 창작자-생성된 검증값을 검증하기 위해 검증 코호트 및 하나 이상의 다른 검증 코호트에 의해 이용된다. 일부 구현에서, GEF를 생성하는 단계는: 서열 및 제1 GRI에 기초하여 서열 변환 벡터를 생성하는 단계; 및 맵핑 된 게놈 분화 객체를 획득하기 위해 서열 변환 벡터에 기초하여 수정된 게놈 분화 객체를 맵핑하는 단계; 및 맵 핑된 게놈 분화 객체에 기초하여 GEF를 생성하는 단계를 포함한다. 일부 구현에서, 검증자-생성된 검증값을 생성하는 단계는: MDB와 MDC 내의 선행 MDB에 기초하여 링킹값을 생성 하는 단계, ―링킹값은 MDB와 선행 MDB의 조합을 나타냄―; 및 검증자-생성된 검증값을 획득하기 위해 GEF에 기 초하여 링킹값에 하나 이상의 계산 기능을 적용하는 단계를 포함한다. 이들 구현들 중 일부에서, 링킹값을 생 성하는 단계는 : MDB의 적어도 일부의 제1 해시값을 생성하는 단계; 선행 MDB의 적어도 일부의 제2 해시값을 생 성하는 단계; 및 링킹값을 획득하기 위해 제1 해시값과 상기 제2 해시값을 결합하는 단계를 포함한다. 일부 구 현에서, 하나 이상의 계산 기능은, GEF를 키로서 이용하여 링킹값을 검증자-생성된 검증값으로 변환하는 하나 이상의 암호 기반의 기능을 포함한다. 이들 구현들 중 일부에서, 하나 이상의 암호 기반의 기능은 암호화 기능 을 포함한다. 일부 구현에서, 하나 이상의 암호 기반의 기능은 명료화 기능을 포함한다. 일부 구현에서, 하나 이상의 계산 기능은, GEF를 입력 파라미터로서 이용하여 링킹값을 검증자-생성된 검증값으로 변환하는 하나 이 상의 암호없는 기능을 포함한다. 이들 구현들 중 일부에서, 하나 이상의 암호없는 기능은 해시 기능을 포함한 다. 일부 구현에서, 하나 이상의 계산 기능은, 입력 파라미터로서 GEF를 이용하여 링킹값을 검증자-생성된 검 증값으로 조합하여 변환하는, 하나 이상의 암호 없는 기능과 하나 이상의 암호 기반의 기능을 포함한다.일부 구현에서, 이 방법은 검증 기록을 창작자 코호트에 전송하는 단계를 더 포함한다. 이들 구현들 중 일부에 서, 이 방법은, 검증 코호트의 처리 시스템에 의해, 검증 코호트에 의해 유지되는 검증 체인에 검증 기록을 저 장하는 단계를 더 포함한다. 이들 구현들 중 일부에서, 검증 기록을 저장하는 단계는, MDC 내의 하나 이상의 각각의 MDB에 대응하는 하나 이상의 검증 기록을 포함하는 검증 블록을 생성하는 단계 및 검증 블록을 검증 체 인에 추가하는 단계를 포함한다. 이들 구현들 중 일부에서, 검증 체인은, 검증 코호트에 의해 유지되는 제2 MDC의 사이드체인(sidechain)이다. 일부 구현에서, 창작자 코호트는, 검증 코호트들에 의해 제공된 검증 기록 들을 유지하는 창작자-코호트 검증 체인에 검증 기록을 저장한다. 이들 구현들 중 일부에서, 창작자-코호트 검 증 체인은 MDC의 사이드체인이다. 본 개시내용의 일부 실시예에 따르면, 자료 데이터 블록체인(MDC)을 유지하기 위한 방법이 개시된다. 이 방법 은, 원장 기반의 애플리케이션을 실행하는 프로세서들의 제1 세트와 창작자 코호트에 대응하는 창작자 VDAX에 의해, 원장 기반의 애플리케이션으로부터 미공증된 자료 데이터 블록(MDB)을 수신하는 단계를 포함하고, 여기서, 미공증된 MDB는, 메타데이터 부분과, MDB에 저장되는 실질적 데이터를 포함하는 페이로드 부분을 포함 한다. 이 방법은, 창작자 VDAX에 의해, MDB의 메타데이터 부분으로부터 비트들의 제1 서열을 추출하는 단계, 및 창작자 VDAX에 의해, 제1 서열, 창작자 VDAX에 할당된 제1 게놈 분화 객체, 및 창작자 VDAX에 의해 유지되는 제1 게놈 조절 명령어들(GRI)에 기초하여, 제1 게놈 결합 인자(GEF)를 생성하는 단계를 더 포함한다. 이 방법 은, 창작자 VDAX에 의해, 미공증된 MBD에 대응하는 창작자-생성된 값을 획득하기 위해 제1 GEF를 입력으로서 이 용하여 하나 이상의 계산 기능을 미공증된 MDB에 적용하는 단계를 더 포함한다. 이 방법은 또한, 프로세서들의 제1 세트에 의해, 창작자-생성된 값으로 미공증된 MBD를 디지털 방식으로 서명함으로써 미공증된 MBD를 업데이 트하는 단계; 프로세서들의 제1 세트에 의해, 미공증된 MDB를 하나 이상의 공증 코호트에 제공하는 단계; 및 프 로세서들의 제1 세트에 의해, 하나 이상의 공증 코호트 각각으로부터 각각의 공증값을 수신하는 단계를 포함하 고, 여기서, 각각의 공증값은, 하나 이상의 공증 코호트 중의 각각의 공증 코호트에 의해, 각각의 공증 코호트 및 각각의 공증 코호트에 할당된 각각의 게놈 분화 객체에 의해 보유되는 각각의 GRI를 이용하여 생성된다. 이 방법은, 프로세서들의 제1 세트에 의해, 공증된 MDB를 획득하기 위해 하나 이상의 공증 코호트로부터 수신된 각 각의 공증값들로 미공증된 MDB를 업데이트하는 단계 및 프로세서들의 제1 세트에 의해, 공증된 MDB를 MDC에 추 가하는 단계를 더 포함한다. 일부 구현에서, 이 방법은 : 하나 이상의 공증 코호트 중의 한 공증 코호트에 대응하는 공증 VDAX를 실행하는 프로세서들의 제2 세트에 의해, 미공증된 MDB를 수신하는 단계; 공증 VDAX에 의해, MDB의 메타데이터 부분으로 부터 비트들의 제2 서열을 추출하는 단계; 공증 VDAX에 의해, 제2 서열에 기초한 제2 게놈 결합 인자(GEF), 공 증 VDAX에 할당된 제2 게놈 분화 객체, 및 공증 VDAX에 의해 유지되는 제2 GRI를 생성하는 단계; 공증 VDAX에 의해, 미공증된 MBD에 대응하는 공증값을 획득하기 위해 제2 GEF를 입력으로서 이용하여 하나 이상의 계산 기능 을 미공증된 MDB에 적용하는 단계; 및 프로세서들의 제2 세트에 의해, 공증값을 창작자 코호트에 제공하는 단계 를 더 포함한다. 이들 구현들 중 일부에서, 이 방법은, 프로세서들의 제2 세트에 의해, 적어도 부분적으로 공 증된 MDB를 획득하기 위해 미공증된 MDB를 공증값으로 디지털 서명하는 단계, 및 프로세서들의 제2 세트에 의해, 공증 코호트에 의해 유지되는 제2 MDC를, 적어도 부분적으로 공증된 MDB로 업데이트하는 단계를 더 포함 한다. 이들 구현들 중 일부에서, 창작자 코호트에 공증값을 제공하는 단계는 적어도 부분적으로 공증된 MDB를 창작자 코호트에 제공하는 단계를 포함한다. 일부 구현에서, 제2 GEF를 생성하는 단계는 제2 서열 및 제2 GRI 에 기초하여 서열 변환 벡터(SCV)를 결정하는 단계를 포함한다. 이들 구현들 중 일부에서, 제2 GEF를 생성하는 단계는 : 맵핑된 게놈 분화 객체를 획득하기 위해 SCV에 기초하여 제2 게놈 분화 객체를 맵핑하는 단계; 수정된 맵핑된 게놈 분화 객체를 획득하기 위해 SCV 및 제2 GRI 중 적어도 하나에 기초하여 맵핑된 게놈 분화 객체를 수정하는 단계; 및 수정된 맵핑된 게놈 분화 객체에 기초하여 제2 GEF를 결정하는 단계를 포함한다. 이들 구현 들 중 일부에서, 제2 GEF를 생성하는 단계는: 수정된 게놈 분화 객체를 획득하기 위해 제2 GRI에 기초하여 제2 게놈 분화 객체를 수정하는 단계; 맵핑된 수정된 게놈 분화 객체를 획득하기 위해 SCV에 기초하여 수정된 게놈 분화 객체를 맵핑하는 단계; 및 맵핑된 수정된 게놈 분화 객체에 기초하여 제2 GEF를 결정하는 단계를 포함한다. 이들 구현들 중 일부에서, 이 방법은, 수정된 게놈 분화 객체가 창작자 코호트로부터 수신된 다른 MDB들에 대한 후속 GEF들을 결정하는데 이용되도록, 수정된 게놈 분화 객체를 저장하는 단계를 더 포함한다. 일부 구현에서, 비트들의 제2 서열은 비트들의 제1 서열과 동일하다. 다른 구현들에서, 제2 서열은 비트들의 제1 서열과는 상이하다. 일부 구현에서, 하나 이상의 계산 기능은, 제2 GEF를 키로서 이용하여 미공증된 MDB의 적어도 일부를 공증값으로 변환하는 하나 이상의 암호 기반의 기능을 포함한다. 이들 구현들 중 일부에서, 하 나 이상의 암호 기반의 기능은 암호화 기능을 포함한다. 일부 구현에서, 하나 이상의 암호 기반의 기능은 명료 화 기능을 포함한다. 일부 구현에서, 하나 이상의 계산 기능은 입력 파라미터로서 제2 GEF를 이용하여 미공증된 MDB의 적어도 일부를 공증값으로 변환하는 하나 이상의 암호없는 기능을 포함한다. 이들 구현들 중 일부에 서, 하나 이상의 암호없는 기능은 해시 기능을 포함한다. 일부 구현에서, 하나 이상의 계산 기능은 입력 파라 미터로서 제2 GEF를 이용하여 미공증된 MDB의 적어도 일부를 공증값으로 변환하는, 조합으로 변환하는 하나 이 상의 암호없는 기능과 하나 이상의 암호 기반의 기능을 포함한다. 일부 구현에서, 제2 게놈 분화 객체와 제1 게놈 분화 객체는 상관된 게놈 분화 객체들이다. 일부 구현에서, 제2 게놈 분화 객체와 제1 게놈 분화 객체는 비상관된 게놈 분화 객체들이다. 일부 구현에서, 이 방법은, 프로세서들의 제2 세트에 의해, 검증 코호트로부 터 확정 요청을 수신하는 단계, ―확정 요청은 공증된 MDB를 포함함―, 및 공증 VDAX에 의해, 공증된 MDB, 제2 GRI, 및 제2 게놈 데이터 객체로부터 추출된 비트들의 제3 서열에 기초한 공증된 MDB에 기초하여 재생성된 공증 값을 생성하는 단계를 더 포함한다. 일부 구현에서, 이 방법은, 프로세서들의 제2 세트에 의해, 재생성된 공증 값을 나타내는 응답을 검증 코호트에 제공하는 단계를 더 포함하고, 여기서, 검증 코호트는, 재생성된 공증값이 공증된 MDB를 공증하는데 이용된 공증값과 정합한다는 결정에 응답하여 공증된 MDB의 무결성을 확정한다. 이들 구현들 중 일부에서, 이 방법은, 프로세서들의 제2 세트에 의해, 재생성된 공증값이 공증된 MDB를 공증하는데 이용된 공증값과 정합하는지를 결정하는 단계, 및 재생성된 공증값이 공증된 MDB를 공증하는데 이용된 공증값과 정합한다는 결정에 응답하여, 프로세서들의 제2 세트에 의해, 공증된 MDB의 무결성을 확정하는 응답을 검증 코 호트에 제공하는 단계를 더 포함한다. 본 개시내용의 일부 구현에 따르면, 디바이스가 개시된다. 이 디바이스는 게놈 데이터 세트가 할당된 VDAX를 포함하고, 게놈 데이터 세트는 디바이스가 그 한 멤버인 디지털 생태계에 대응하고, 게놈 적격성 객체, 게놈 상 관관계 객체, 및 게놈 분화 객체를 포함한다. VDAX는 디지털 생태계 내의 제2 디바이스에 대한 제1 링크를 스 폰하기 위한 링크 스폰 수단을 포함하고, 여기서, 링크는, VDAX에 의해 디코딩가능한 가상 2진 언어 스크립트 (VBLS)를 생성하기 위해 제2 디바이스에 의해 이용되는 제1 게놈 조절 명령어들(GRI)을 포함한다. VDAX는, VBLS에 인코딩되어 있는 디코딩된 디지털 객체들을 획득하기 위해 제1 GRI 및 게놈 분화 객체에 기초하여 디바 이스에 대해 제2 디바이스에 의해 생성된 VBLS를 디코딩하기 위한 VBLS 디코딩 수단을 더 포함한다. 실시예들에서, VDAX는, 제2 디바이스에 의해 생성된 제2 GRI를 획득하기 위해 제2 디바이스로부터 수신된 제2 링크를 디코딩하기 위한 링크 호스팅 수단을 더 포함하고, 제2 링크는, 제2 인코딩된 GRI, 인코딩된 GRI를 디코 딩하기 위한 제2 인코딩된 링크 정보, 및 제2 인코딩된 링크 정보를 디코딩하는데 이용되는 제2 공개 서열을 포 함한다. VDAX는 또한, 제2 GRI 및 게놈 분화 객체에 기초하여 제2 디바이스에 대한 디지털 객체들을 인코딩하 기 위한 VBLS 인코딩 수단을 포함한다. 일부 실시예에서, 링크 호스팅 수단은 : 게놈 적격성 객체, 디바이스의 제1 자격증, 및 제2 디바이스의 제2 자격증에 기초하여, 상관관계 벡터를 생성하기 위한 수단; 구역 참조 세트 를 획득하기 위해 상관관계 벡터에 기초하여 제2 인코딩된 링크 정보를 디코딩하기 위한 수단; 구역 참조 세트 및 게놈 상관관계 객체에 기초하여 윈도우 벡터를 생성하기 위한 수단; 디바이스의 공개 서열, 윈도우 및 게놈 상관관계 객체에 기초하여 변환값을 생성하기 위한 수단; 및 제2 GRI를 획득하기 위해 변환값을 이용하여 제2 GRI를 디코딩하기 위한 수단을 포함한다. 이들 구현들 중 일부에서, VBLS 인코딩 수단은 : 제1 GRI, 디지털 객 체의 미인코딩된 부분으로부터 추출된 서열, 및 게놈 분화 객체에 기초하여, 게놈 결합 인자(GEF)를 생성하기 위한 수단; 및 제2 디바이스에 의해 디코딩가능한 VBLS 객체를 획득하기 위해 GEF에 기초하여 디지털 객체를 인 코딩하기 위한 수단을 포함한다. 이들 구현들 중 일부에서, 디지털 객체를 인코딩하기 위한 수단은 VBLS 객체 를 획득하기 위한 키로서 GEF를 이용하여 디지털 객체의 페이로드를 암호화한다. 일부 구현에서, 디지털 객체 를 인코딩하기 위한 수단은 VBLS 객체를 획득하기 위해 디지털 객체의 페이로드와 GEF를 XOR한다. 일부 구현에서, 제1 링크는, 제1 GRI를 포함하는 인코딩된 GRI, 인코딩된 GRI로부터 제1 GRI를 디코딩하기 위해 제2 디바이스에 의해 이용되는 정보를 포함하는 인코딩된 링크 정보, 및 인코딩된 링크 정보로부터 링크 정보를 디코딩하기 위해 제2 디바이스에 의해 이용되는 공개 서열을 포함한다. 이들 구현들 중 일부에서, 링크 스폰 수단은, 게놈 적격성 객체, 게놈 상관관계 객체, 디바이스에 대응하는 제1 자격증, 및 제2 디바이스에 대응하는 제2 자격증에 기초하여 제1 링크를 생성한다. 이들 구현들 중 일부에서, 링크 스폰 수단은, VDAX에 할당된 게 놈 적격성 객체, 제1 자격증, 및 제2 자격증에 기초하여 상관관계 벡터를 생성함으로써 제1 링크를 생성하고, 여기서 상관관계 벡터는 링크 정보를 인코딩하는데 이용된다. 이들 구현들 중 일부에서, 게놈 적격성 객체는 제1 자격증을 이용하여 마스터 CNA 객체로부터 고유하게 도출되는 제1 CNA 객체이다. 이들 구현들 중 일부에서, 링크 스폰 수단은, 제1 CNA 객체, 제1 자격증, 및 제2 자격증에 기초하여 상관관계 벡터를 생성하기 위한 수단을 포함한다. 이들 구현들 중 일부에서, 상관관계 벡터를 생성하기 위한 수단은, 제1 디바이스에 고 유하게 대응하고 제1 CNA 객체에 할당된 마스터 CNA 객체의 각각의 부분들을 나타내는 제1 코드 워드 벡터를 획 득하기 위해 코드 맵핑 기능을 제1 자격증에 적용하고; 제2 디바이스에 고유하게 대응하고 제2 디바이스에 할당 된 제2 CNA 객체에 할당되었던 마스터 CNA 객체의 각각의 부분들을 나타내는 것에 대응하는 제2 코드 벡터를 획득하기 위해 코드 맵핑 기능을 제2 자격증에 적용하고; 상기 제1 코드 벡터와 제2 코드 벡터의 교차를 나타내는 교차 벡터를 결정하고; 및 교차 벡터에 기초하여 제1 CNA 객체로부터 상관관계 벡터를 결정하도록 구성된다. 이들 구현들 중 일부에서, 상관관계 벡터는 디바이스의 제1 CNA 객체와 제2 디바이스의 제2 CNA 객체 사이의 고 유한 상관관계를 나타낸다. 일부 구현에서, 게놈 적격성 객체는, 디바이스에 대응하는 제1 자격증을 이용하여 마스터 PNA 객체로부터 고유 하게 도출되는 PNA 객체이고, 여기서, PNA 객체는 디바이스에 의해 비밀로 유지되는 비밀 비율, 디바이스에 할 당된 공개 원시 다항식, 및 마스터 PNA 객체의 공개 컴포넌트를 포함한다. 이들 구현들 중 일부에서, 마스터 PNA 객체의 공개 컴포넌트는, M차의 제1 마스터 원시 다항식, M차의 제2 마스 터 원시 다항식, 및 M비트 값들의 (N-1)개의 각각의 쌍을 포함하는 공개 컴포넌트를 포함하고, 여기서, 제1 자 격증 및 제2 자격증은 N비트 벡터들로 표현된다. 일부 구현에서, 링크 스폰 수단은, 디바이스의 PNA 객체와 제 2 디바이스의 결합 정보에 기초하여 상관관계 벡터를 생성하기 위한 수단을 포함한다. 이들 구현들 중 일부에 서, 제2 디바이스의 결합 정보는 제2 디바이스에 대응하는 자격증 및 제2 디바이스에 할당된 제2 공개 다항식을 포함한다. 일부 구현에서, 링크 스폰 수단은 : 게놈 적격성 객체, 디바이스의 제1 자격증, 및 제2 디바이스의 제2 자격증 에 기초하여 상관관계 벡터를 생성하기 위한 수단; 제1 GRI를 생성하기 위한 수단; 구역 참조 세트를 생성하기 위한 수단, ―각각의 구역 참조는 게놈 상관관계 객체의 각각의 부분을 나타냄―; 게놈 상관관계 객체 및 구역 참조 세트에 기초하여 윈도우 벡터를 생성하기 위한 수단; 윈도우 및 제1 GRI에 기초하여 공개 서열을 생성하기 위한 수단; 공개 서열, 윈도우, 디바이스의 게놈 상관관계 객체에 기초하여 변환값을 생성하기 위한 수단; 인코 딩된 GRI를 획득하기 위해 변환값을 이용하여 제1 GRI를 인코딩하기 위한 수단; 및 인코딩된 링크 정보를 획득 하기 위해 상관관계 벡터를 이용하여 구역 참조 세트를 인코딩하기 위한 수단을 포함한다. 이들 구현들 중 일 부에서, 디바이스는, 인코딩된 링크 정보, 공개 서열 및 인코딩된 GRI를 제2 디바이스에 제공하고, 제2 디바이 스는, 인코딩된 링크 정보, 공개 서열, 제2 디바이스에 할당된 제2 게놈 데이터 세트, 제1 자격증, 및 제2 자격 증에 기초하여 인코딩된 GRI를 디코딩한다. 일부 구현에서, VBLS를 디코딩하기 위한 수단은 : 제1 GRI, VBLS 객체의 미인코딩된 부분으로부터 추출된 서열, 및 게놈 분화 객체에 기초하여 게놈 결합 인자(GEF)를 생성하기 위한 수단; 디지털 객체의 디코딩된 부분을 획 득하기 위해 GEF에 기초하여 VBLS 객체를 디코딩하기 위한 수단을 포함한다. 이들 구현들 중 일부에서, VBLS 객체를 디코딩하기 위한 수단은, 디지털 객체의 디코딩된 부분을 획득하기 위한 키로서 GEF를 이용하여 VBLS 객 체의 인코딩된 부분을 해독한다. 일부 구현에서, VBLS 객체를 디코딩하기 위한 수단은, 디코딩된 디지털 객체를 획득하기 위해 VBLS 객체의 미인 코딩된 부분과 GEF를 XOR함으로써 VBLS 객체의 인코딩된 부분을 명료화한다. 일부 구현에서, 디지털 객체는 미디어 프레임이다. 일부 구현에서, 디지털 객체는 네트워크 패킷이다. 일부 구현에서, 디지털 객체는 파일이다. 본 개시내용의 더 완전한 이해는 이하의 설명 및 첨부된 도면들 및 청구항들로부터 이해될 것이다."}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "서언 초확장성(예를 들어, N개의 디지털 코호트가 N개의 상이한 디지털 코호트와의 높은 엔트로피를 나타내는 상호 관심 ID를 직접 확립할 수 있는 능력을 갖는 경우)은 네트워크 중심의 모든 사물에 중요하고 디지털 생태계의 동적-상태 가상화의 포괄적 보안에 대한 누락된 링크들이라고 여겨진다. 초확장성(예를 들어, 다수-대-다수)은, 널리 사용되는 선형적으로 확장가능한 기술들, 예를 들어, 공개 키 기반시설(일-대-다수) 및 양자 키 배포(일대일)가 할 수 없는 포괄적인 보안에 추가하여 완전히 새로운 네트워크 중심의 가상화된 제품들 및 서비스들을, 이들이 양자 저항 상태를 달성하든 그렇지 않든 상관없이, 용이화할 수 있다. 여기서 논의된 바와 같이, 최소한의 추가 오버헤드 또는 대역폭을 요구하는 Cyphergenics 지원형 초확장성은, N x N 결합 인스턴스들이 NX x NY로 증가할 수 있더라도 모든 네트워크 및 애플리케이션 스택 레벨에 걸쳐 동등하 게 효과적이고 계산적으로 부담스럽지 않다. 실시예들에서, 초확장가능한 직접 디지털-코호트-대-디지털-코호 트 가상 인증 및 가상 제휴의 결과들은, 각각이 완전히 상이한 기반 기술들에 의해 달성되는지와는 상관없이, 초확장가능한 생물학적-자손-대-생물학적-자손 가상 상관관계 및 가상 분화와 결과에 있어서 유사하다. CG 기 반의 초확장성에 의해 지원되는 다른 디지털 속성들(예를 들어, 가상 기민성, 가상 데이터 객체들 및 가상 코드 객체들)도 마찬가지이다. 완전히 디지털적으로 구현된 기술인 Cyphergenics에 대한 논의는, 현재 소수를 제외하고 모두에게 친숙할 가능 성이 크고 희망적으로는 더 친숙하게 될 완전 생화학적 구현을 갖는 필연적인 게놈 용어의 채택에 의해 실질적 으로 보조된다. 특정한 생화학적 프로세스들이 기술적으로 Cyphergenics에 정보를 제공하지는 않지만, 유사한 문제들과 복잡성 레벨들을 해결할 수 있는 그들의 능력은 사실 Cyphergenics의 기저 제안들에 장점을 추가했다. Cyphergenics 기반의 용어들과 계산적 복합 디지털 기능들 및 프로세스들, 및 생화학 기반의 기능들 및 프로세 스들이 특히 필연적 게놈 발현을 공유하는 비제한적인 예는 다음을 포함할 수 있다 : 게놈 정보: 요소들이 총체적으로 계산적으로 식별할 수 있는 순서나 관계를 거의 또는 전혀 나타내지 않는 숫자, 담화, 또는 기타의 이러한 스크립트들. 게놈 엔트로피: 계산적으로 평가가능한 및 확정가능한, 게놈 정보에서 반복적 또는 예측가능한 패턴들이 없는 정도. 게놈 조성: 상대적 엔트로피의 손실 없이 게놈 정보를 그 원래의 서열 또는 관계 기초로부터 특정한 서브세트들 로 재배열하거나 재구성하는 능력. 게놈 수정: 관찰할 수 없는 경우에도 계산 속성들이 입증가능하고 수정된 게놈 정보 기반에 걸쳐 일관성을 유지 하는, 계산적 복합 기능들 및 프로세스들에 기초하여 게놈 정보를 처리하는 능력. 게놈 조절: 당시의(즉, 수정된) 현재 베이스의 선행필수 지식을 요구하는, 특정한 목표(예를 들어, 디지털-코 호트 정밀도 비조율된 철회)를 달성하기 위해 전체 게놈 정보 베이스 또는 특정한 서브세트(들)를 조건부로 및 일시적으로 수정할 수 있는 능력. 게놈 수정: 특정한 게놈 상관관계 및 분화 속성들을 유지하면서도 디지털-데이터-객체들 및 디지털-코드-객체들 의 고유하고 계산적 양자 증명, 비반복적 변환을 가능케하는, 재구성, 수정, 또는 조절에 의해 게놈 정보의 서 브세트를 도출하는 능력. 본 개시내용은, Cyphergenics 생태계 보안 플랫폼들(\"CG-ESPs\", \"보안 플랫폼들\" 또는 \"게놈 보안 플랫폼들\"이 라고도 지칭됨) 및 CG 지원형 프로세스들 및 기술들의 다양한 실시예에 관한 것이다. 실시예들에서, CG-ESP는, 게놈 정보, 게놈 엔트로피, 게놈 조성, 게놈 수정, 게놈 조절 및 게놈 정정이 고유하게 협력하여 계산적 복합 초확장성을 제공하기 위한 계산 자원들 및 프로세스 제어를 제공한다. 실시예들에서, 초확장성은, 결국, 가상 인증, 가상 제휴, 가상 기민성, 가상 무세션 결합, 및/또는 가상 실행 도메인 속성들을 달성하기 위해 디지털 생태계들, 엔클레이브들, 및 디지털 코호트들이 게놈 기반으로 결합할 수 있게 한다. 일부 실시예에서, 이들 속성들은, 결국, 하드웨어 접속의 교체 또는 재구성 없이 애플리케이션 특유의 게놈 네트워크 보안 토폴로지들 을 용이화한다.실시예들에서, CG-ESP의 인스턴스들은, 특정한 정보 이론-조성된 게놈 속성들(예를 들어, 생태계, 엔클레이브들, 및/또는 디지털 코호트들(또는 \"코호트들\")의 전체 또는 일부에 포함된 특정한 디지털 커뮤니티 의 하나 이상의 상호 관심 ID를 반영하는 디지털 게놈 데이터 세트들)로 파라미터화될 수 있다. 실시예들에서, 특정한 정보 이론-조성된 게놈 속성들을 가진 CG-ESP 인스턴스의 파라미터화는, VDAX가 상응하는 디지털 커뮤니 티 내에서 역할을 수행할 수 있게 하도록 처리 시스템에 의해 실행될 수 있는, 상응하는 가상 익명 교환 제어기 (또는 \"VDAX\")를 구성한다. 논의되는 바와 같이, VDAX는, VDAX가 서빙하는 디바이스 유형, VDAX의 의도된 목적, 및/또는 원하는 보안 레벨에 따라 상이한 방식들로 구현될 수 있다. 예를 들어, 일부 구현에서, VDAX는, 소프트웨어, 펌웨어, 또는 프로세서에 의해 실행되는 기타의 컴퓨터 실행가능한 명령어들로서 구현될 수 있다. 일부 구현에서, VDAX는, 처리 디바이스의 전용 코어, 필드 프로그래머블 게이트 어레이, 마이크로프로세서, 시 스템 온 칩(SoC), 및/또는 기타 등등의 하드웨어로서 구현될 수 있다. 일부 구현에서, VDAX는 하드웨어와 소프 트웨어 요소들의 조합일 수 있다. 실시예들에서, CG-ESP는, 이질적인 또는 중복되는 상호 관심 ID를 갖더라도 여러 VDAX를 인에이블할 수 있다. 실시예들에서, CG-ESP는 디지털 생태계 또는 그 컴포넌트들을 대신하여 디지털 상관관계 및 분화 기능들을 조성 하고 관리하도록 구성될 수 있다. 실시예들에서, 디지털 생태계란, 상호 관심 ID를 각각 갖는 하나 이상의 엔 클레이브를 갖는 디지털 커뮤니티를 지칭할 수 있다. 실시예들에서, 엔클레이브란, 상호 관심 ID를 갖는 한 세 트의 하나 이상의 코호트를 지칭할 수 있다. 실시예들에서, 용어 \"코호트들\"이란, 독립 코호트들 및/또는 종속 들 코호트들을 지칭할 수 있다. 일부 실시예에서, 독립 코호트들이란, 독립 엔티티로서 동작하는 하나 이상의 디바이스들의 집합을 지칭할 수 있다. 이들 실시예들 중 일부에서, 독립 코호트들은, 그리드들, 네트워크들, 클라우드 서비스들, 시스템들, 컴퓨터들, 기기들, 디바이스들, 및 (IoT 센서들을 포함한) IoT 디바이스들을 포 함할 수 있지만 이들로 제한되는 것은 아니다. 종속 코호트란, 개개의 디지털 엔티티를 대신하여 대리 역할을 하는 독립 코호트에 의해 인에이블되는 개개의 디지털 엔티티를 지칭할 수 있다. 종속 코호트들의 예는, 센서 들, 애플리케이션들(앱들), 데이터, 파일들, 및 콘텐츠를 포함하지만 이들로 제한되는 것은 아니다. 논의될 바 와 같이, 독립 및 종속 코호트들의 지정은 상이한 유형들의 아키텍쳐들 및 생태계들에 걸쳐 달라질 수 있다. 예를 들어, 임시 아키텍쳐들(아래에서 논의됨)의 일부 실시예에 따르면, 소정의 디바이스 컴포넌트들(예를 들어, 프로세서들, 프로세서 코어들, 카메라들 등) 및 소프트웨어 인스턴스들은 독립 코호트들로서 지정될 수 있는 반면, 다른 디바이스 컴포넌트들 및 소프트웨어 인스턴스들은 종속 코호트들로서 지정될 수 있다. 일부 실시예에서, 이들 유형들의 지정은 디지털 생태계와 연관된 커뮤니티 소유자에 의해 결정될 수 있다는 점에 유 의한다. 예시적인 실시예들에서, Cyphergenics 기반의 생태계 보안 플랫폼(\"CG-ESP\")은 하나 이상의 엔클레이브를 갖는 생태계를 형성하고 상호 관심 ID를 갖는 독립 및 종속 코호트들의 집합의 멤버십을 관리한다. 실시예들에서, GC-ESP는 게놈 기능들 및 프로세스들을 제어하고 관리하는 플랫폼 역량 등의 하나 이상의 핵심 역량과, 링크 데 이터(예를 들어, 게놈 결합 화물)를 교환하기 위한 수단을 제공하는 링크 교환 역량을 제공한다. 실시예들에서, 상호 관심 ID는, 커뮤니티 소유자에 의해 또는 커뮤니티 소유자를 대신하여 정의될 수 있는 엔클 레이브 내의 코호트들 사이의 임의의 논리적 공통성에 따라 정의될 수 있다. 예를 들어, 기업 조직(예를 들어, 디지털 생태계) 내에서 비즈니스 유닛들(예를 들어, 엔클레이브들)을 형성하는 사용자 디바이스들, 서버들, 프 린터들, 문서들, 애플리케이션들(예를 들어, 코호트들) 사이에는 상호 관심 ID들이 존재할 수 있다. 또 다른 예에서, 상호 관심 ID들은, 사용자 디바이스들, 스마트 디바이스들, 게임 디바이스들, 센서들, 착용형 디바이스 들, 파일들, 및 홈 네트워크(예를 들어, 생태계)에서 동작하는 애플리케이션들(예를 들어, 코호트들) 사이에 존 재할 수 있어서, 홈 네트워크가 하나 이상의 엔클레이브(예를 들어, 홈 오피스에 이용되는 업무 관련 엔클레이 브 및 개인 또는 가족의 디바이스들, 애플리케이션들, 및 파일들에 대한 개인 엔클레이브)를 가질 수 있게 할 수 있다. 또 다른 예에서, 지역 당국(예를 들어, 커뮤니티 소유자)에 의해 관리되는 스마트 수송 시스템(생태 계)의 특정한 그리드(예를 들어, 엔클레이브)에서 운전하는 자율 차량들(예를 들어, 코호트) 사이에는 상호 관 심 ID가 존재할 수 있다. 앞서 말한 내용은, 생태계들, 엔클레이브들, 코호트들, 및 관심 ID들의 비-제한적인 예들이며, 본 문서 전체에서 다른 많은 예들이 논의될 것이다. 더욱이, 디지털 엔티티는 제1 생태계 내의 코호 트(예를 들어, 기업 생태계 내의 모바일 디바이스)로서 간주될 수 있기 때문에, 디지털 엔티티는 생태계 내에서 또는 여러 생태계에 걸쳐 상이한 역할들을 할 수 있다는 점에 유의한다. 예를 들어, 기업 생태계 내의 모바일 디바이스는 기업 생태계 코호트로서 간주될 수 있지만 실행가능한 생태계에서 전체 디지털 생태계를 정의할 수 있다. 더 상세히 논의되는 바와 같이, CG-ESP의 구성은 디지털 생태계의 커뮤니티 소유자에 의해 정의될 수 있다. 본 개시내용 전반에 걸쳐 \"커뮤니티 소유자\"를 언급할 때, 이 용어는 커뮤니티를 관리, 유지 또는 소유하는 엔티티 (예를 들어, 회사, 조직, 정부, 개인 등) 및/또는 그 대표자(예를 들어, 네트워크 관리자, CIO, IT 관리자, 홈 소유자, 컨설턴트, 보안 전문가, 커뮤니티 소유자를 대신하는 인공 지능 소프트웨어, 또는 임의의 다른 적절한 대표자)를 지칭할 수 있다. 또한, 일부 실시예에서, CG-ESP는 미리구성되어 커뮤니티 소유자에게 판매될 수 있 으며, 이에 따라 커뮤니티 소유자는 커뮤니티 멤버십 및/또는 CG-ESP의 기능들(예를 들어, CG-ESP에서 이용되는 CG-ESP 모듈들 및 구성들)에 관한 결정을 내리거나 내리지 못할 수도 있다. 생물학의 맥락에서, 생물학적 분화 및 상관관계를 포함하는 핵심 생물학적 게놈 역량은 CG-ESP 디지털 프로세스 들의 공식화를 설명하는데 편리한 필연적 결과를 제공한다. 그러나, Cyphergenics 관련 기술들의 맥락에서 \"게 놈\" 코호트들(예를 들어, 게놈 데이터 세트들, DNA, 서열 맵핑, 변이, 클로닝, 및/또는 기타 등등)에 대한 언급 또는 그 파생어들은, 이들 프로세스들이 생물학적 게놈 조성들 또는 프로세스들 중 임의의 또는 모든 특정한 속 성들을 모방하거나 계승한다고 암시하려는 의도가 아님을 이해해야 한다. 실시예들에서, CG-ESP는, 특정한 유 형들의 게놈 데이터의 디지털 생성, 수정, 확증(corroboration), 및/또는 할당을 포함할 수 있는 게놈 프로세스 들을 실행한다. 실시예들에서, 이들 게놈 프로세스들 및 데이터는 사용자 제어형 엔트로피를 나타내는 차이들 및 상관관계의 계산을 가능케한다. 이들 실시예들에서, 이들 디지털 게놈 프로세스들은 특정한 정보 이론 지원 형의 조성들에 의존한다. 일부 구현들에서, 이들 조성들은 디지털 DNA(또는 게놈 데이터)라고 지칭될 수 있다. 실시예들에서, 디지털 DNA는, LNA(게놈 상관관계), CNA(게놈 결합-무결성), PNA(게놈 결합-적격성), XNA(게놈 분화), 및/또는 ZNA(게놈 코드 분리/은폐) 등의 하나 이상의 정보 이론 지원형의 조성들을 포함할 수 있다. 논 의될 바와 같이, 이들 Cyphergenics 기반의(또는 \"CG 기반의\") 프로세스들 및 조성들은 다양한 디지털 생태계 전반에 걸쳐 초확장성을 용이화한다. CG 기반의 프로세스들의 예들은, CG 기반의 링크 프로세스들, CG 기반의 서열 맵핑, 및/또는 CG 기반의 변환들을 포함할 수 있지만, 이것으로 제한되지 않으며, 그 예시적인 구현들은 본 개시내용 전체에 걸쳐 논의된다. 실시예들에서, 게놈 디지털 링크들(또는 \"링크들\")은 가상 디지털 익명 교환 제어기(\"VDAX\")(아래에서 더 논의 됨)가 더 높은 레벨의 계산적 복합 게놈 기능들을 수행하는데 필요한 정보 교환을 가능케한다. 실시예들에서, CG 기반의 게놈 링크 프로세스들은, 링크 스폰, 링크 호스팅, 및/또는 링크 업데이트를 포함할 수 있으며, 이들 의 예시적인 구현들은 본 개시내용 전체에 걸쳐 설명되어 있다. 이들 CG 기반의 링크 프로세스들은, LNA(게놈 상관관계), CNA(게놈 결합-무결성), 및 PNA(게놈 결합-적격성) 등의 속성-특유의 게놈 조성 정보를 제공한다. 실시예들에서, CG 기반의 서열 맵핑이란, 디지털 서열들(예를 들어, 공개 또는 사적 프로토콜 서열들)을 게놈 결합 인자들로 계산적으로 변환하는데 이용되는 기술들을 지칭할 수 있다. 실시예들에서, 이들 게놈 결합 인자 들은 고유하고 비반복적일 수 있다. 상이한 유형들의 서열들은 광범위하게 이질적일 수 있지만, 서열들은 특정 한 레벨들의 엔트로피를 나타내는 게놈 결합 인자들을 생성하는 방식으로 처리될 수 있다. 실시예들에서, 광범 위한 프로토콜들 및 포맷들과 호환되는 CG 기반의 서열 맵핑 프로세스들은, 기존 엔트로피를 나타내는 서열들과 관련하여 시작될 수 있으며, 이에 의해 서열들은 계산적 복합 CG 기능들에 의해 고유한 게놈 결합 인자들로 각 각 변환 및 처리된다. 그 다음, 이들 게놈 결합 인자들을 이용하여 디지털 객체들을 VBLS로 인코딩할 수 있다. 논의될 바와 같이, CG-ESP의 실시예들은 현대의 암호화 및 관련 보안 시스템들로 가능하지 않은 다수의 초확장 가능한 속성들을 용이화할 수 있다. 이들 속성들은, 가상 제휴(무제한의 차이들), 가상 인증(무제한의 상관관 계), 가상 기민성(무제한의 구조적 적응성), 및 가상 결합(이산 데이터 객체별 무세션 제어)과 가상의 신뢰할 수 있는 실행 도메인(이산 코드 객체별 실행 제어)을 가능케하는 가상 2진 언어 스크립트(VBLS)를 포함할 수 있 지만 이것으로 제한되는 것은 아니다. 본 명세서에 사용된 용어 \"무제한의\"는, \"제한된\" 시나리오를 기술하는 것이 이론적으로 가능할 수 있다는 것을 인식하면서 단어의 실용적인 의미에서 무제한인 것을 의미한다는 점에 유의한다. 초확장성: 일부 실시예에서, 초확장성이란, T개의 인스턴스들(M x N x T)에 걸쳐 M개의 접점(point of contac t)들에 의해 N개의 코호트(또는 다른 커뮤니티 멤버들)를 포괄적으로 연관시키는 능력을 지칭할 수 있다. 수십 억개의 잠재적인 코호트가 무수히 많은 접점을 만들고 무수히 많은 인스턴스들을 통해 통신한다는 점을 고려할 때, 이러한 규모의 초확장성은 현대 암호화의 근본적인 돌파구를 요구한다. 여기서 설명된 CG 기반의 시스템들 은 계산 비용과 세션 상태들에서의 상당한 감소를 생성할 것이다. 실시예들에서, 이들 상당한 감소는 비교적 미미한 오버헤드 및/또는 대역폭을 댓가로 한다. 가상 인증 : 실시예들에서, 생태계 멤버들(예를 들어, 생태계, 엔클레이브, 코호트들 등)의 가상 인증은 초확장 성 기술들을 요구할 수 있다. 실시예들에서, 초확장성 기술은 정확하고 고유한 상관관계(예를 들어, \"누가 누구인지\")가 요구될 수 있는 생태계, 엔클레이브, 및/또는 코호트 결합을 가능케한다. 이들 실시예들 중 일부에 서, 정확하고 고유한 상관관계란, 디지털 커뮤니티(예를 들어, 코호트, 엔클레이브, 생태계 등)가 또 다른 멤버 (예를 들어, 또 다른 코호트, 엔클레이브, 생태계, 및/또는 기타 등등)의 신원을 고유하게 확인하는 특정한 세 트의 정보 이론 지원형의 게놈 프로세스들을 지칭할 수 있다. 실시예들에서, 가상 인증이란, 무제한의 수의 생 태계 멤버(예를 들어, 생태계, 엔클레이브, 코호트들 등)를 인증하는 능력을 지칭할 수 있다. 논의될 바와 같 이, CG 지원형 생태계들은 생태계 멤버들(예를 들어, 엔클레이브, 코호트, 종속 코호트)에 대한 무제한의 상관 관계를 달성할 수 있으며, 이것은 결국 형성될 고유한 관계들의 무제한의 양을 제공한다. 본 개시내용의 일부 실시예에서, 상이한 생태계들로부터의 코호트들은 또한, 무제한의 방식으로 서로를 인증하도록 구성될 수 있다. 설명되는 바와 같이, 무제한의 상관관계는, 게놈 계산적으로 복합의 조성들 및 프로세스들(\"Cyphergenics 기반 의\" 또는 \"CG 기반의\" 또는 \"CG 지원형\" 조성들 및/또는 프로세스들이라고도 함)에 의해 달성될 수 있다. 가상 제휴: 실시예들에서, 생태계들, 엔클레이브들, 및 코호트들 사이의 가상 분화된 결합은 초확장성을 요구할 수 있다. 초확장성 기술은, 정확하고 고유한 분화(\"무엇이 무엇인지\" 및 \"우리는 혼자\")가 요구될 수 있는 전 부는 아니더라도 대부분의 시나리오에 대해, 생태계, 엔클레이브, 및 코호트 결합을 가능케한다. 실시예들에서, 정확하고 고유한 분화란, 커뮤니티 멤버들의 고유한 쌍에 의해 수행되어 임의의 다른 커뮤니티 멤버들로부터 그 쌍을 분화하는 고유한 결합을 확립하는 한 세트의 합동하는 또는 충분히 합동하는 프로세스들 을 지칭할 수 있다. 이들 실시예들 중 일부에서, 이러한 정확하고 고유한 분화는, 의도하지 않은 디지털 엔티 티들이 고유하게 확립된 결합에 참여(예를 들어, 가로챈 데이터 등을 디코딩)할 수 없다는 것을 보장한다. 실 시예들에서, 초확장가능한 분화란, 생태계 멤버가 무제한의 수의 다른 생태계 멤버(예를 들어, 생태계, 엔클레 이브, 코호트들, 및/또는 기타 등등)과 고유하게 제휴할 수 있는 능력을 지칭할 수 있다. 유기 생태계들은 복 잡한 생화학적 프로세스들로부터 도출된 종들, 자손, 및 형제자매들 사이의 강력한 분화를 입증한다. 그럼에도 불구하고, 특정한 게놈 정보 이론 기반의 디지털 조성들 및 프로세스들에 의해 무제한의 분화가 달성될 수 있다. 논의될 바와 같이, CG 지원형 생태계들은 생태계 멤버들(예를 들어, 엔클레이브, 코호트, 종속 코호트) 에 대한 무제한의 분화를 달성할 수 있으며, 이것은 결국 형성될 고유한 관계들의 무제한의 양을 제공한다. 본 개시내용의 일부 실시예에서, 상이한 생태계들로부터의 코호트들은 또한, 무제한의 방식으로 고유한 결합들을 형성하도록 구성될 수 있다. 설명되는 바와 같이, 무제한의 분화는 게놈 정보 이론에 의해 지배되는 조성들 및 프로세스들(\"Cyphergenics 기반의\" 또는 \"CG 기반의\" 또는 \"CG 지원형\" 조성들 및/또는 프로세스들이라고도 함)에 의해 달성될 수 있다. 가상 기민성: 실시예들에서, 생태계, 엔클레이브 및/또는 코호트 플랫폼 스택(들) 내의 가상 기민성은 초확장성 에 의해 강화될 수 있다. 초확장성 기술은, 생태계, 엔클레이브들, 및 코호트들이 소프트웨어 및 하드웨어 관 리형 프로세스들에 대한 초확장성 분화 및 초확장성 상관관계를 기민하게 실행할 수 있게 한다. 일부 실시예에 서, 소프트웨어 및/또는 하드웨어 관리 프로세스들의 기민한 실행이란, 상응하는 프로토콜 스택(예를 들어, OSI 네트워킹 스택, 소프트웨어 스택, 처리 스택, 및/또는 기타 등등)의 다양한 레벨에서 적용될 수 있는 프로세스 들을 지칭할 수 있다. 유기 생태계들은 복잡한 생화학적 프로세스들에 의해 제어되는 세포 수준에서 제한적이 지만 강력한 기민성을 입증한다. 그럼에도 불구하고, 특정한 게놈 정보 이론 지원형의 디지털 조성들 및 프로 세스들에 의해 무제한의 기민성이 달성될 수 있다. 가상 2진 언어 스크립트(VBLS): 가상 2진 언어 스크립트 지원형의 생태계, 엔클레이브 및/또는 코호트 결합은 초확장성을 요구한다. 초확장성 기술은, 생태계들, 엔클레이브, 및 코호트들이, 고유한, 비반복적, 계산적 양 자 증명 2진 언어들(또는 커뮤니티 소유자가 원하는 경우 비-양자-증명 2진 언어들)를 통해 결합할 수 있게 한 다. 유기 생태계들은, 복잡한 생화학적 프로세스들 기초하여 제한적이지만 강력한 고유한 세포 결합을 입증한 다. 그럼에도 불구하고, 무제한의 고유한 디지털 객체 결합은, 특정한 게놈 정보 이론이 지배하는 디지털 조성 들에 의해 달성될 수 있다. 가상의 신뢰할 수 있는 실행 도메인: 일부 실시예에서, 계산적 복합 게놈 조성들 및 프로세스들을 이용하여, 적 절하게 구성된 CG-ESP는 실행가능한 생태계들의 컴포넌트들에 대한 결합을 고유하게 변환하기 위한 프로세스들 을 가능케한다. 실시예들에서, 실행가능한 생태계들이란, 디바이스(또는 단일 유닛으로서 동작하는 상호의존적 디바이스들의 시스템)의 상이한 소프트웨어 및 하드웨어 컴포넌트들을 지칭할 수 있다. 실시예들에서, 실행가 능한 생태계 컴포넌트들은, 예를 들어 애플리케이션 컴포넌트들(API들, 라이브러리들, 스레드들), 운영 체제 컴 포넌트들(예를 들어, 커널, 서비스들, 드라이버들, 라이브러리들 등), 및 시스템-온-칩(SoC) 컴포넌트들(처리 유닛들, 예를 들어, 코어), 하드웨어 컴포넌트들(예를 들어, 디스크들, 센서들, 주변 디바이스들, 및/또는 기타 등등), 및/또는 기타의 적절한 유형들의 컴포넌트들을 포함할 수 있지만, 이것으로 제한되는 것은 아니다. 일부 실시예에서, 이들 생태계 컴포넌트들(예를 들어, 생태계들, 엔클레이브들, 및 코호트들 등의 특정한 지정들 및 조직들)은 협력적으로 또는 독립적으로 실행가능한 2진수들을 수행(예를 들어, 인코딩 및/또는 디코딩)할 수 있다. 게놈 기반의 가상 네트워크 아키텍쳐들: 실시예들에서, CG-EPS들의 게놈 프로세스들 및 역량들은, 특정한 이용 사례의 고유한 수요에 관계없이, 애플리케이션 보안 및 네트워크 아키텍쳐 관계 프로토콜의 반전을 가능케한다. 일부 실시예에서, 개시된 \"게놈 네트워크 토폴로지\" 기술은 완전히 새로운 이용 사례-특유의 보안 아키텍쳐의 생성을 가능케한다. 일부 실시예에서, 단일 물리적 네트워크 토폴로지는 다중 게놈 토폴로지들을 동시에 지원 할 수 있다. 본 명세서에서 사용될 때, 게놈 토폴로지 또는 게놈 네트워크 토폴로지란, 디지털 생태계의 상응 하는 멤버들의 게놈 조성들을 이용하여 정의된 디지털 생태계의 토폴로지를 지칭할 수 있다. 실시예들에서, 생태계들, 및 엔클레이브들 뿐만 아니라 그에 대한 멤버십은 디지털 커뮤니티의 소유자에 의해 정의될 수 있다. 예를 들어, 기업 엔티티와 제휴한 네트워크 관리자는 보안 플랫폼 인스턴스를 구성할 수 있으 며, 이것은 회사 엔티티의 상이한 유닛들 또는 프로젝트들에 대한 상응하는 엔클레이브들을 확립한다. 이 예에 서, 네트워크 관리자는 코호트의 기능에 기초하여 하나 이상의 엔클레이브에 코호트들을 추가하도록 보안 플랫 폼 인스턴스를 구성할 수 있다. 일부 실시예에서, 코호트는 여러 엔클레이브들에 포함될 수 있고 엔클레이브들 은 중첩하는 코호트들을 가질 수 있다는 점에 유의한다. 또한, 일부 실시예에서, 여러 코호트들이, 컴퓨팅 디 바이스 및 다양한 하드웨어(예를 들어, CPU, GPU, 메모리 디바이스) 및/또는 소프트웨어 컴포넌트들(운영 체제, 파일 시스템들, 애플리케이션들, 파일들) 등의 단일의 디바이스와 연관될 수 있다. 논의될 바와 같이, CG- ESP들은 상이한 유형들의 생태계들을 형성하도록 구성될 수 있고, 멤버쉽 적격성은 커뮤니티 소유자 및/또는 CG-ESP 제공자에 의해 구성가능하고 정의될 수 있다. 실시예들에서, 보안 플랫폼은 상호 관심 ID들에 기초하여 \"게놈적으로(genomically)\" 이질적인 기능들, 시스템들, 및/또는 운영 극단들을 \"게놈적으로\" 조성하도록 구성 된다. 다시 말해, 이들 실시예들에서, CG-ESP는 디지털 커뮤니티 내의 커뮤니티 멤버들(예를 들어, 엔클레이브 들, 생태계들, 및/또는 코호트들)의 게놈 조성들을 이용하여 디지털 생태계의 게놈 네트워크 토폴로지를 제어하 도록 (예를 들어, 커뮤니티 소유자 또는 유사한 당사자에 의해) 구성 및 동작될 수 있다. 이러한 방식으로, 커 뮤니티 멤버들은 디지털 커뮤니티 내의 하나 이상의 멤버의 게놈 조성들을 수정함으로써 확립될 수 있고, 소정 의 엔클레이브들 또는 생태계들에 추가될 수 있고, 소정의 엔클레이브들 또는 생태계들로부터 철회될 수 있고, 기타 등등이다. 일부 실시예에서, Cyphergenics 기반의 생태계 보안 플랫폼(CG-ESP)이란 게놈 데이터의 특정 구성에 대해 다양 한 CG 기반의 기능들을 수행하는 한 세트의 CG 지원형의 모듈들을 지칭할 수 있으며, CG-ESP 인스턴스란, 커뮤 니티에 관하여 CG-ESP 인스턴스가 수행하고 있는 역할(예를 들어, 생태계-레벨, 엔클레이브-레벨, 코호트 레벨, 종속 코호트 레벨)에 의존적인 CG 지원형의 모듈들의 구성을 갖는 CG-ESP 플랫폼의 한 인스턴스를 지칭할 수 있 다. 일부 실시예에서, CG-ESP 플랫폼 인스턴스는 VDAX로서 구현될 수 있다. 이들 실시예들에서, VDAX는 VDAX 의 역할에 대해 정의된 CG 지원형의 모듈들의 특정한 구성을 실행할 수 있다. VDAX 역할들의 예들은, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX를 포함할 수 있으며, 이에 의해 이들 VDAX 각각은 역 할이 필요로 하는 CG-ESP 모듈들 및 CG 지원형의 동작들에 따라 구성될 수 있다. 실시예들에서, CG-ESP 인스턴 스는, 게놈 조성들, 기능들 및 프로세스들의 제어 및 관리(플랫폼 역량) 및/또는 보안 데이터 교환 기능들 및 프로세스들(링크 교환 역량)을 포함할 수 있는, 하나 이상의 핵심 역량을 제공할 수 있다. 실시예들에서, 생태 계 VDAX는 생태계를 대신하여 보안 관련 기능들을 수행할 수 있고 생태계의 \"선조\"로서 간주될 수 있다. 이들 실시예들 중 일부에서, 하나 이상의 대응하는 엔클레이브 VDAX는 상응하는 엔클레이브를 대신하여 보안 관련 기 능들을 수행하도록 구성될 수 있다. 실시예들에서, 코호트 VDAX는 생태계 내의 상응하는 독립적인 코호트들을 대신하여 게놈 보안 관련 기능들을 수행할 수 있다. 실시예들에서, 종속 VDAX는 생태계 내의 상응하는 종속 코 호트를 대신하여 게놈 보안 관련 기능들을 수행할 수 있다. 일부 실시예에서, 독립 코호트가 독립 코호트에 의 존하는 하나 이상의 종속 코호트를 대신하여 하나 이상의 종속 VDAX를 호스트할 수 있다는 점에 유의한다. 또 한, 일부 실시예에서, 독립 코호트와 연관된 단일 코호트 VDAX는 이질적인 엔클레이브들 및 생태계들에 걸쳐 코 호트에 대한 보안 관련 기능들을 수행하도록 구성될 수 있다. 이들 실시예에서, 코호트 VDAX는 상이한 생태계 들 및/또는 엔클레이브들의 상응하는 구성에 따라 코호트를 대신하여 상이한 게놈 데이터 세트들을 관리하고 활 용할 수 있다. 예를 들어, 사용자가 업무 및 개인 문제들에 이용하는 모바일 디바이스는, 사용자가 일하는 조 직의 CG-ESP 구성에 따라 사용자의 작업 생태계 및 엔클레이브들에 속하는 하나 이상의 게놈 데이터 세트뿐만 아니라 이들 생태계들 및 엔클레이브들의 플랫폼 구성들에 따라 사용자가 참여하는 생태계들 및 엔클레이브들에 속하는 하나 이상의 게놈 데이터 세트를 관리하고 활용하는 코호트 VDAX로 구성될 수 있다. 일부 실시예에서, 하나 이상의 엔클레이브 VDAX 및/또는 생태계 VDAX는 동일한 컴퓨팅 시스템에 의해 호스팅될 수 있다. 예를 들어, 대규모 디지털 생태계(예를 들어, 연방 또는 주 정부, 대기업, 군대, 자율 차량 그리드, IoT 그리드 등)의 생태계 및 엔클레이브 VDAX들은 분산형 클라우드 컴퓨팅 시스템(예를 들어, AWS®, Azure®, Google Cloud Services®, 개인 소유 서버 뱅크들 등) 반면, 소규모 디지털 생태계(예를 들어, 홈 네트워크, 소규모 사무실 네트워크, 풀뿌리 비영리단체 등)의 생태계 및 엔클레이브 보안 제어기들은 단일 컴퓨팅 디바이스(예를 들어, 중앙 서버, 라우터, 모바일 디바이스 등)에서 호스팅될 수 있다. 일부 예시적인 실시예에서, VDAX는 상이한 생 태계들에 관해 상이한 역할들을 수행하도록 구성될 수 있다는 점도 역시 유의한다. 설명을 위해 \"선조\" 및 \"자손\"(예를 들어, \"선조 보안 제어기\" 또는 \"선조 VDAX\" 및 \"자손 보안 제어기\" 또는 \"자손 VDAX\")이라는 용어들은, \"선조\" VDAX가 \"자손\" VDAX에 게놈 데이터 세트를 생성, 할당 및/또는 기타의 방식으로 제공할 수 있는 관계를 나타내기 위해 사용될 수 있다. 예를 들어, 일부 실시예에서, 생태계 VDAX는, 각각의 엔클레이브에 대해, 그 \"자손\" 엔클레이브 VDAX는 고유하지만 \"선조\" 생태계 VDAX로부터 도출된 상관된 게놈 데이터 세트를 할당받도록, 하나 이상의 엔클레이브에 대한 자신의 디지털 게놈 데이터 세트를 수정할 수 있다. 유사하게, 또 다른 예에서, 엔클레이브 VDAX는, 각각의 코호트에 대해 그 자손 코호트 VDAX가 그 자신의 게놈 데이터 세트를 할당받도록, 엔클레이브 내의 코호트들에 대한 고유하고 상관된 게놈 데이터 세트들을 생성, 할당, 및/또는 기타의 방식으로 제공하도록 자신의 게놈 데이터 세트를 수정할 수 있다. 이 방식으로, 선조 VDAX의 자손(예를 들어, 자손 VDAX)은, 부분적으로는 그들의 상응하는 게놈 데이터 세트들 사이의 높은 상 관관계로 인해 암호학적으로 안전한 방식으로 데이터를 교환할 수 있다. CG-ESP 플랫폼의 일부 실시예에서, 생 태계 VDAX는, 엔클레이브 VDAX들이 존재하더라도, 생태계의 코호트들에 대한 게놈 데이터 세트들을 생성 및 할 당할 수 있다는 점에 유의한다. 실시예들에서, 선조 VDAX(예를 들어, 생태계 또는 엔클레이브 VDAX)는, VDAX에 관한 자손 VDAX의 역할이 주어질 때 자손 VDAX가 적절한 CG-ESP 모듈로 구성되도록, CG-ESP 플랫폼의 역할 기반 의 구성을 자손 VDAX에 제공할 수 있다. 논의될 바와 같이, 구성들은 논의된 CG 기반의 프로세스들에서 이용되 는 특정한 암호 기반의, 암호 없는, 및/또는 하이브리드 계산적 복합 기능들로 구성된 상응하는 모듈들을 포함 할 수 있다. 실시예들에서, 암호 기반의 기능이란, 기능의 모든 스테이지들(하나 이상의 스테이지)이 키 기반 의 가역 변환들(예를 들어, 대칭 암호들)을 이용하여 수행되는 실행형 기능들을 나타낼 수 있다. 키 기반의 가 역 기능들의 예들로는, AES(Advanced Encryption Standard), SAFER+, SAFER++, TDES 등이 포함될 수 있지만 이 것으로 제한되는 것은 아니다. 실시예들에서, 암호 없는 기능들이란, 기능의 어떤 스테이지도 키 기반의 가역 기능들을 이용하여 수행되지 않는 실행형 기능들을 지칭할 수 있다. 실시예들에서, 하이브리드 기능들은, 암호 기반의 기능을 이용하여 수행되는 적어도 하나의 스테이지 및 암호 없는 기능을 이용하여 수행되는 적어도 하나 의 스테이지를 포함하는 실행형 기능들을 지칭할 수 있다. 예를 들어, 하이브리드 기능은, 역전되거나 역전되 지 않을 수 있는, 암호 기반의 기능을 이용하여 중간 값을 결정하는 제1 스테이지와 암호를 이용하지 않고 중간 값을 출력 값으로 변환하는 제2 스테이지를 포함할 수 있다. 일부 실시예에서, CG-ESP는 생태계 소유자에 의해 또는 생태계 소유자를 대신하여 구성가능하다. 언급된 바와 같이, CG-ESP는, 임의 레벨의 VDAX가 일부의 또는 모든 상호의존적 모듈의 인스턴스를 포함하도록, 하나 이상의 게놈 보안 기능을 집합적으로 수행하는 한 세트의 상호의존적 모듈들을 포함할 수 있다. 이들 상호의존적 모듈 들은, 소정의 게놈 기능들을 수행하도록 특별히 구성된 전통적인 처리 디바이스(예를 들어, CPU 또는 GPU 및/또 는 FPGA, 마이크로프로세서, 또는 특별 목적 칩셋들)에 의해 실행되는 실행가능한 명령어들로서 구현될 수 있다 는 점에 유의한다. 다시 말해, 특정한 보안 제어기 인스턴스(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호 트 VDAX, 종속 VDAX, 및/또는 기타 등등)의 상호의존적 모듈들은, 소프트웨어, 미들웨어, 펌웨어, 및/또는 하드 웨어로서 개별적으로 구현될 수 있다. 프로세서들, 실행 등에 대한 언급은, 문맥에서 구체적으로 달리 제공하 지 않는 한, 이들 구성들 중 임의의 것에 적용되는 것을 지칭한다. 실시예들에서, 특정한 CG-ESP 인스턴스의 개개의 모듈들은 특정한 세트의 상이한 유형들의 게놈 데이터 객체들(예를 들어, CNA, LNA, XNA, PNA, ZNA 등) 에 관해 동작하도록 및/또는 상이한 유형들의 기능들과 전략들을 실행하도록 구성될 수 있다. 예를 들어, 일부 모듈은, 암호 기반의 계산적 복합 기능들을, 게놈 데이터 객체들 및/또는 게놈 보안 동작과 관련하여 생성되거 나 활용되는 디지털 데이터에 적용하도록 구성될 수 있다. 암호 기반의 계산적 복합 기능들의 예들로는, AES(Advanced Encryption Standard) 암호화/해독, SAFER+ 암호화/해독 연산들, XOR 연산들, 전용의 사적으로 개발된 암호화/해독 연산들, 및/또는 기타 등등이 포함될 수 있지만, 이들로 제한되는 것은 아니다. 추가적으 로 또는 대안으로서, 일부 실시예에서, 상호의존적 모듈들 중 일부는, 암호 없는 계산적 복합 기능들을, 게놈 데이터 객체들 및/또는 게놈 보안 동작과 관련하여 생성되거나 활용되는 디지털 데이터에 적용하도록 구성될 수 있다. 암호 없는 계산적 복합 기능들의 예들로는, 암호 해시 기능들, 파라미터화된 선형 방정식들에 기초한 변 환들, 다변수 방정식들에 기초한 변환들, 격자 기반의 변환들, 파라미터화된 순환 시프트 연산들, 및/또는 기타 등등 등이 포함될 수 있지만 이들로 제한되는 것은 아니다. 추가적으로 또는 대안으로서, 일부 실시예에서, 일부 모듈은 하이브리드(예를 들어, 암호 기반의 및 암호 없는) 계산적 복합 기능들을 게놈 데이터 객체들 및/또 는 게놈 보안 동작과 관련하여 생성되거나 활용되는 디지털 데이터에 적용하도록 구성될 수 있다. 논의된 바와 같이, 하이브리드 기능은 암호 기반의 기능들과 암호 없는 기능들의 일부 조합을 포함할 수 있다. 논의될 바와 같이, CG-ESP는 자신이 서비스를 제공하는 디지털 커뮤니티의 요구들 및 제한들에 따라 (예를 들어, 커뮤니티 소유자에 의해 또는 커뮤니티 소유자를 대신하여) 구성될 수 있다. 기능은 반드시 그 기능의 복잡성 때문이 아 니라 키 또는 유사한 정보 없이 기능을 반전시키는 것과 연관된 계산 복잡성 때문에 \"계산적 복합\"이라고 지칭 될 수 있다는 점에 유의해야 한다. 예를 들어, 2개의 입력 파라미터를 수신하고 2개의 입력 파라미터의 XOR을 나타내는 출력 값을 출력하는 XOR 기능은, XOR 연산의 출력 값만이 주어질 때 입력 파라미터들을 결정하는 것은 훨씬 더 많은 정도의 컴퓨팅 자원을 요구하기 필요하기 때문에 \"계산적 복합\"이라고 할 수 있다. 실시예들에서, 실시예들에서, CG-ESP는, 구성가능한 엔트로피를 나타내는 객체들(예를 들어, 2원 행렬, 2원 벡 터, 원시 2진 다항식들 등)에서 구현될 수 있는 하나 이상의 디지털적으로 생성된 게놈 조성들을 포함하는 특정 한 게놈 데이터 세트들을 이용하여 생태계 멤버들 사이에서 안전한 종단간 데이터 교환들을 제공하도록 구성된 다. 실시예들에서, 이들 디지털적으로 생성된 수학적 객체들은 일련의 CG 기반의 프로세스들을 이용하여 생태 계 멤버들의 상응하는 게놈 데이터 세트들 사이의 높은 정도의 상관관계 및 구분성을 활용함으로써 임의의 쌍의 충분히 상관된 생태계 멤버들 사이에서 디지털 객체들을 안전하게 교환하는데 이용된다. 실시예들에서, 초확장 가능한 게놈 상관관계는, 한계를 벗어난 신뢰할 수 있는 서비스들(예를 들어, 인증 기관, 비밀 키 교환 등)의 지원 없이 동료 엔클레이브 또는 생태계 멤버들로서 직접 인증될 수 있는 게놈 자손의 무제한의 커뮤니티를 가 질 수 있는 능력을 제공할 수 있다. 일부 실시예에서, 초확장가능한 분화란, 2개의 충분히 제휴된 코호트들이 다른 커뮤니티 멤버에 관하여 호스팅되는 링크들에 기초하여 가상 2진 언어 스크립트(VBLS)(그 개개의 인스턴스 들은 VBLS 객체들이라고 지칭될 수 있음)를 생성하고 교환하기 위한 능력을 지칭할 수 있다. 실시예들에서, 링 크는, (링크가 제2 VDAX에 의해 안전하게 유지된다고 가정하여) 제2 VDAX가 VBLS에 의해 디코딩될 수 있는 VBLS 를 생성하기 위해 제2 VDAX의 게놈 데이터 세트(예를 들어, XNA 또는 ZNA)가 수정되어야 하는 방식을 정의하는, 하나의 VDAX로부터 또 다른 VDAX로의 디지털 인코딩된 명령어들(\"게놈 조절 명령어들\" 또는 \"GRI\"라고 지칭될 수 있음)를 포함한다. 실시예들에서, 제2 VDAX는 제1 VDAX에 대응하는 GRI를 나타내는 링크를 \"호스팅\"할 수 있고, 이에 의해 제2 VDAX는 GRI에 기초하여 자신의 게놈 데이터 세트를 수정할 수 있고, 수정된 게놈 데이터 및 GRI에 기초하여, 제1 코호트에 의해 판독가능한 VBLS를 생성할 수 있다. 실시예들에서, 제2 VDAX는 서열을 수정된 게놈 데이터에 맵핑하여 게놈 결합 인자를 획득하고, 이것은 결국 VBLS 객체에 포함된 디지털 객체를 (예를 들어, 명료화 및/또는 암호화 기술들을 이용하여) 인코딩하는데 이용된다. 실시예들에서, VBLS 객체들은, 하나 이상의 인코딩된 디지털 객체 및 인코딩된 디지털 객체(들)를 디코딩하는데 이용되는 메타데이 터를 포함하는 데이터 컨테이너일 수 있다. 실시예들에서, 제1 VDAX는 VBLS 객체를 수신하고 제2 VDAX에 제공 된 GRI를 이용하여 그 자신의 게놈 데이터 세트를 수정하고 수정된 게놈 데이터 세트에 기초하여 게놈 결합 인 자를 결정하고 게놈 결합 인자에 기초하여 인코딩된 디지털 객체들을 디코딩함으로써 VBLS로부터 디지털 객체를 디코딩한다. 논의될 바와 같이, 제1 VDAX만이 VBLS에서 디지털 객체들을 디코딩할 수 있는 반면, 링크 정보에 포함된 GRI에 액세스할 수 없는 임의의 다른 코호트(디지털 커뮤니티 멤버 또는 기타)는 VBLS 내의 인코딩된 디 지털 객체들을 디코딩할 수 없다. 논의될 바와 같이, 실시예들에서, CG 도메인 컴포넌트들(예를 들어, 생태계, 엔클레이브, 독립 코호트들, 및/또 는 종속 코호트들)은, 디지털 생태계 CG 지원형 컴포넌트들이, 암호 기반의, 암호 없는, 및/또는 하이브리드 기 능들일 수 있는 계산적 복합 기능들을 이용하여 차이들 및 상관관계의 정밀한 제어를 달성할 수 있도록, 디지털 게놈 데이터 세트들로 구성될 수 있다. 실시예들에서, CG 지원형 방법들은 엔트로피의 동적 명세를 가능케하는 CG 기반의 게놈 프로세스들을 지원할 수 있다. 실시예들에서, CG 도메인 컴포넌트들은 정보 이론 게놈 (Cyphergenics)에 따라 결합하고, 가상 인증, 가상 확장성, 및/또는 가상 기민성이 가능한 정보 이론 게놈들을 이용할 수 있다. 실시예들에서, CG 컴포넌트들은, CG 지원형 프로세스들이 2개의 도메인 컴포넌트가 고유의 비 반복적 디지털 언어들(예를 들어, VBLS)을 통해 조성하고 결합할 수 있게 하도록 VBLS를 생성하도록 구성된다. 실시예들에서, CG 컴포넌트들은, CG 도메인 컴포넌트들 사이의 차이들 및 상관관계를 확립하고 제어하는 능력을 제공하며, 이것은 광범위한 확장성(예를 들어, 초확장성)을 가능케할 수 있다. 실시예들에서, CG 도메인 컴포 넌트들은 디지털 객체들로 구성된 특정한 디지털 프로토콜들을 통해 결합하며, 이에 의해 디지털 객체들은 그들 의 선조 컴포넌트들(예를 들어, 생태계 또는 엔클레이브)의 정보 게놈 속성들을 유지한다. 실시예들에서, 초확 장성은 디지털 객체 레벨에서 실행될 때 컴포넌트 레벨을 넘어 (예를 들어, 포맷 및/또는 프로토콜 레벨에서) CG 기반의 속성들의 기민한 적용을 가능케한다. 언급된 바와 같이, 게놈 데이터 세트(\"디지털 DNA 세트\", \"DNA 세트\" 또는 \"DNA\"라고도 함)는, 엔트로피의 레벨 들이 구성가능하도록, 특정한 레벨들의 엔트로피를 나타내는 하나 이상의 디지털적으로 생성된 수학적 조성을 포함할 수 있다. 언급한 바와 같이, 설명을 위해, 생물학적 유전 개념들에 대한 참조 및 도출들이 이루어진다. 예를 들어, DNA, \"게놈 데이터\", \"변이\", \"게놈 조성들\", \"자손\", \"클로닝\", \"서열 맵핑\" 등의 용어들은 본 개 시내용 전반에 걸쳐 사용된다. 이들 참조들은 생물학적 유전 물질들 또는 프로세스들의 임의의 특정한 속성들 이 여기서 사용된 임의의 용어에 귀속시키려는 의도가 아님을 이해해야 한다. 오히려, 용어는 본 개시내용의 다양한 양태를 실시하는 방법을 다른 사람들에게 가르치기 위해 사용된다. 실시예들에서, 게놈 데이터 세트는, 일반적으로 \"게놈 데이터 객체들\"이라고 지칭될 수 있는, 게놈 적격성 객체, 게놈 상관관계 객체, 및/또는 게놈 분화 객체를 포함할 수 있다. 실시예들에서, 게놈 적격성 객체는, 2개의 VDAX 사이의 \"신뢰할 수 없는\" 인증 프로세스의 일부에서 수행될 수 있는, 한 쌍의 코호트들이 결합 적격성을 게놈적으로 확정하는 것을 허용하는 디지털 생성된 수학적 객체들을 지칭할 수 있다. 실시예들에서, 선조 VDAX(예를 들어, 생태계 VDAX)는, 각각의 자손이 고유하지만 상관된 게놈 적격성 객체를 수신하도록, 그 게놈 적격성 객체(\"선조 게놈 적격성 객체\")로부터 그 자손에 대한 자손 게놈 적 격성 객체들을 도출할 수 있다. 게놈 적격성 객체를 할당받으면, 자손 VDAX는 게놈 적격성 객체를 수신할 수 있다. 일부 실시예에서, 자손 VDAX는 일회성 신뢰할 수 있는 이벤트를 통해 게놈 적격성을 수신할 수 있다(예 를 들어, 특정한 생태계로의 생태계 허용시, 디바이스가 제조, 구성 또는 판매될 때 등). 이 단일의 신뢰할 수 있는 이벤트 후에, 충분한 VDAX들이 그들의 상응하는 게놈 적격성 객체들을 이용하여 서로 결합 적격성을 독립 적으로 확정할 수 있다. 실시예들에서, 게놈 적격성 객체들은, CNA 객체들, PNA 객체들, 또는 아래에서 더 상 세히 논의되는, 구성가능한 엔트로피 레벨, 상관관계 및 분화를 나타내는 다른 적절한 유형들의 수학적 객체들 을 포함할 수 있다. 실시예들에서, 게놈 상관관계 객체들은, VDAX들이 링크들을 교환하는 것을 허용하는 디지털적으로 생성된 수학 적 객체들을 지칭할 수 있고, 이에 의해 링크는 한 쌍의 충분히 상관된 VDAX들이 디지털 커뮤니티 내의 다른 충 분히 상관된 VDAX들로부터 충분히 분화되는 것을 허용하는 명령어들을 제공한다. 실시예들에서, 게놈 상관관계 객체는 VDAX들이 링크 교환 상관관계를 확정하는데 이용되며, 이것은 2개의 생태계 컴포넌트(예를 들어, 엔클레 이브 및/또는 코호트들)가 특정한 관계를 확립하고 서로 결합하는 것을 허용한다. 예시적인 구현들에서, 디지 털 생태계의 커뮤니티 멤버들의 게놈 상관관계 객체들은, LNA 객체들, 또는 아래에서 더 상세히 논의되는 구성 가능한 엔트로피 및 상관관계를 나타내는 임의의 다른 적절한 유형들의 수학적 객체들이다. 실시예들에서, 게놈 분화 객체들은, VDAX들이 다른 상응하는 VDAX에 의해 스폰된 링크들을 성공적으로 호스팅하 는 경우, 한 쌍의 VDAX들(예를 들어, 엔클레이브들 또는 코호트들)이 다른 상응하는 VDAX들에 의해 생성된 VBLS 객체들을 생성 및 디코딩하는 것을 허용하는 디지털적으로 생성된 수학적 객체들을 지칭할 수 있다. 일부 실시 예에서, 제1 VDAX는, 부분적으로, 제2 VDAX에 대응하는 호스팅된 링크에 포함된 명령어들에 정의된 방식으로 그 게놈 분화 객체를 부분적으로 수정함으로써 제2 VDAX에 대한 VBLS를 생성하고, 부분적으로, 제1 VDAX와 관하여 제2 VDAX에 의해 호스팅된 링크에 포함된 명령어들에 정의된 방식으로 그 게놈 분화 객체를 수정함으로써 제2 VDAX로부터 VBLS를 디코딩한다. 게놈 분화 객체들의 예들은, XNA 객체, ZNA 객체들, 또는 아래에서 더 상세히 논의되는, 구성가능한 엔트로피 및 상관관계를 나타내는 임의의 다른 적절한 유형들의 수학적 객체들을 포함할 수 있지만 이들로 제한되는 것은 아니다. 논의될 바와 같이, CG-ESP 모듈들 및 게놈 데이터 세트들의 상이한 조합들 및 구성들이 상이한 CG-ESP들에서 이 용될 수 있다. 동시대 네트워크 능력들은 그들의 기저 배치 아키텍쳐를 상당히 반영한다. 비트 레벨에서 동작 하는 VBLS 지원형 게놈 조성된 아키텍쳐들은, 기저 배치 아키텍쳐와 상호운용가능한 상태로 유지될 수 있다. 본 개시내용의 실시예들에 따르면, VBLS는, 네트워크이든, 소프트웨어이든 또는 하드웨어 중심 아키텍쳐이든지, 고유하게 맞춤화된 이용 사례들에 전례없는 설비 및 유연성을 제공한다. 상이한 아키텍쳐들의 예들은, 정적 생 태계들(예를 들어, 대기업)에 배치할 수 있는 지시된 아키텍쳐들, 일시적인 생태계들(예를 들어, 소셜 네트워크 들, 웹사이트들)에 배치할 수 있는 자유 형태 아키텍쳐들, 동적 생태계들(예를 들어, 도시 전체 자율 차량 제어 시스템)에 대해 구현될 수 있는 자발적 생태계, 실행가능한 생태계들(예를 들어, OS, 브라우저)을 위해 구현될 수 있는 임시 아키텍쳐들, 및/또는 확정 생태계들(예를 들어, 블록체인들 또는 기타 분산형 원장들)에 대해 구 현될 수 있는 인터렛저 아키텍쳐들을 포함할 수 있지만 이들로 제한되는 것은 아니다. 실시예들에서, 기존의 물리적 네트워크 토폴로지들을 오버레이하는 이들 아키텍쳐들은 게놈 조성형 토폴로지들을 입증한다; 여러 게놈 조성형 토폴로지들이 동시에 및 상호운용가능하게 존재할 수 있다. 상이한 아키텍쳐들 및 CG 지원형 생태계들 의 예들이 본 개시내용 전반에 걸쳐 논의된다.CypherGenics 생태계 보안 플랫폼 도 4는 본 개시내용의 일부 실시예에 따른 CG-ESP의 한 예를 나타낸다. 이들 실시예들에서, CG- ESP는, 상이한 CG-ESP들이 상이한 게놈 기능들을 수행하는 상이한 CG 모듈들과 게놈 데이터 세트의 대응하는 구성에서 동작하는 관련 계산 방법들을 포함할 수 있도록, 게놈 데이터 세트의 특정한 구성에 관하여 한 세트의 CG-프로세스들 및 관련 계산 방법들을 수행하도록 구성된 한 세트의 CG-모듈들을 포함한다. 실시예 들에서, CG-ESP는, 상이한 역할들이 CG-ESP의 상응하는 CG 모듈들에 정의된 CG 프로세스들 및 계산 방법들 의 일부, 전부를 실행하거나 아무것도 실행할 수 없도록, 상이한 역할들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)을 갖는 생태계 멤버들에 의해 실행되도록 구성된다. 이러한 방식으로, 모든 커뮤니티 멤버들은, CG-ESP 인스턴스가 커뮤니티 멤버(예를 들어, 생태계, 엔클레이브, 코호트 또는 종속 코호트)의 역할에 맞게 구성되도록, 커뮤니티 멤버에 의해 및/또는 커뮤니티 멤버를 대신하여(예를 들어, 종속 코호트의 경우) 실행되는 대응하는 CG-ESP 인스턴스를 이용하여 CG 지원형 디지털 생태계에 참여할 수 있다. 예를 들어, 생태계 선조로서 역할하는 커뮤니티 멤버(예를 들어, 생태계 VDAX)는, 하나 이상의 특정한 유형의 게놈 데이터(예를 들어, CNA, PNA, LNA, XNA 및/또는 ZNA)를 갖는 게놈 데이터 세트들(디지털 DNA 세트들)을 생 성하기 위한 CG 기능들 및 관련 계산 방법들을 정의하는 CG 모듈을 포함하는 CG-ESP 인스턴스로 구성될 수 있는 반면, 생태계 내의 독립적인 코호트인 커뮤니티 멤버(예를 들어, 최초 VDAX)는 그 게놈 데이터의 변이화, 링크 교환, 서열 맵핑, 디지털 객체 변환 등을 위한 CG-프로세스들 및 계산 방법들을 정의하는 CG 모듈들을 포함하는 CG-ESP 인스턴스로 구성될 수 있다. 이러한 방식으로, CG 지원형 생태계의 상이한 커뮤니티 멤버들은 소정의 CG-ESP의 상이한 인스턴스들을 실행할 수 있다. 일부 실시예에서, CG-ESP 한 인스턴스의 모듈들은 CG-ESP 인스턴스가 지원하는 디지털 생태계의 VDAX들에 의해 실행된다는 점에 유의한다. 또한, 특정한 디지털 생태계 내의 상이한 유형들의 VDAX들은 디지털 생태계 내에서 상이한 역할들을 수행할 수 있으므로, CG 지원형 생태계의 상이한 클래스들의 VDAX들은 CG-ESP의 모듈들 중 일부 또는 전부를 실행할 수 있고, 개개의 모듈들에 대해, CG-ESP 인스턴스의 상이한 클래스들의 VDAX들은 CG 모듈의 게놈 기능들의 일부 또는 전부를 수행하도록 구성될 수 있다. 디지털 생태계 내의 상이한 클래스들의 VDAX들이 디지털 생태계 내에서 상이한 상응하는 역할 들을 수행하도록 구성될 수 있지만, 디지털 생태계에 관하여 소정의 CG 프로세스(예를 들어, XNA 및 LNA 수정, 링크 교환 프로세스, VBLS 생성/디코딩, 및/또는 기타 등등)를 수행하도록 구성된 모든 VDAX들은 그 소정의 프 로세스를 수행하는 기능적으로 동일한 기능들(예를 들어, 동일한 암호 기반의, 암호 없는, 또는 하이브리드 기 능들, 동일한 서열을 추출하는 기능들 등)을 포함하는 CG-ESP 모듈들로 구성된다는 점에도 유의한다. 이러한 방식으로, 충분히 관련된 VDAX들은 기능적으로 합동하는 방식으로 소정의 CG 동작들을 수행할 수 있으며, 이것 은 충분히 관련된 VDAX들이, 예를 들어 결합 적격성 및/또는 무결성을 확정하고 링크들을 스폰 및 호스팅하거나, 및/또는 VBLS 객체들을 생성 및 디코딩할 수 있게 한다. 실시예들에서, CG-ESP의 CG 모듈들은, 루트 DNA 모듈, 실행가능한 격리 컴포넌트들(EIC; executable isolation component) 모듈, 링크 모듈, 서열 맵핑 모듈, 2진 변환 모듈, 인증 모듈 , 및/또는 마스터 무결성 제어기를 포함할 수 있다. 언급된 바와 같이, 일부 실시예에서, CG 지원형 디지털 생태계는 한 세트의 VDAX들을 포함하고, 이에 의해, VDAX 세트는, 2개 이상의 클래스의 VDAX들(예를 들 어, 생태계 VDAX(들), 엔클레이브 VDAX(들), 코호트 VDAX(들), 및/또는 종속 VDAX(들))을 포함한다. 이들 실시 예들 중 일부에서, 각각의 클래스의 VDAX들은, CG-ESP 모듈들(예를 들어, 루트 DNA 모듈, EIC 모듈, 링크 모듈, 서열 맵핑 모듈, 2진 변환 모듈, 인증 모듈, 및/또는 마스터 무결성 제어기 )의 일부 또는 전부의 상응하는 인스턴스들을 실행할 수 있다. 실시예들에서, 개개의 모듈들은, 암호 기 반의, 암호 없는, 및/또는 하이브리드(예를 들어, 암호 기반의 및 암호 없는 기능들을 포함)일 수 있다. 실시예들에서, 상응하는 CG-ESP 인스턴스들은, 하나 이상의 CPU, GPU, 마이크로제어기, FPGA, 마이크로프로세서, 특별 목적 하드웨어, 및/또는 기타 등등을 포함할 수 있는 상응하는 처리 시스템들에 의해 실행될 수 있다. 또한, 일부 실시예에서, CG-ESP 인스턴스의 모듈들은 가상 머신 또는 컨테이너(예를 들어, Docker 컨테이너)에 의해 실행될 수 있다. 루트 DNA 모듈(들) 실시예들에서, CG-ESP는 루트 DNA 모듈을 포함한다. 실시예들에서, 루트 DNA 모듈은 생태계 특 유의 데이터 및 게놈 프로세스들을 관리하고, 이들로부터 루트 DNA 모듈은 게놈 조성들(예를 들어, DNA 세 트들)을 가능케하는 특정한 및 매우 엄격한 차이 및 상관관계를 공식화한다. 일부 실시예에서, 루트 DNA 모듈 은, CNA 모듈, PNA 모듈, LNA 모듈, 및/또는 XNA 모듈을 포함할 수 있다.실시예들에서, 루트 DNA 모듈은 생태계 특유의 데이터 및 CG 게놈 프로세스들을 관리하고, 이들로부터 루 트 DNA 모듈은 특정의 및 매우 엄격한 차이 및 상관관계를 가능케 하는 CNA를 공식화한다. 실시예들에서, CG 지원형 생태계 컴포넌트 적격성 상관관계는 CNA 객체들을 공식화하고 조성하는 CG-게놈 프로세스들에 의해 가능케된다. 실시예들에서, CNA 모듈은, 개개의 생태계 컴포넌트들(생태계들, 엔클레이브들, 코호트들, 및/또는 종속 코호트들) 사이에 특정한 관계들을 확립하도록 구성된 CG-게놈 프로세스들 및 관련 방법들을 정의 할 수 있다. 실시예들에서, CNA는 동일한 생태계의 VDAX들이 결합에 대한 적격성을 확정할 수 있게 한다. 실 시예들에서, CNA는 생태계 VDAX들 및 하위 생태계 VDAX들이 결합에 대한 적격성의 고유한 확정을 유지할 수 있 게 한다. 실시예들에서, CNA 모듈은 광범위한 정보 이론 지원형의 계산적 복합 기능들을 이용하여 게놈 기반의 적격성 상관을 수행하도록 구성될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기 반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. CNA 생성 및 CNA 기반의 적격성 상관관계의 비제한적인 예들은 본 개시내용에서 나중에 논의된다. 실시예들에서, 루트 DNA 모듈은 생태계 특유의 데이터 및 CG 게놈 프로세스들을 관리하고, 이들로부터 루 트 DNA 모듈은 특정의 및 매우 엄격한 차이 및 상관관계를 가능케 하는 PNA를 공식화한다. 실시예들에서, CG 지원형 생태계 컴포넌트 적격성-동기화는, PNA 객체들을 공식화하고 조성하는 CG-게놈 프로세스들에 의해 가 능케된다. 일부 실시예에서, PNA 모듈은 개개의 생태계 컴포넌트들 사이에 특정한 관계들을 확립하기 위 해 CG-게놈 프로세스들 및 관련 계산 방법들을 채용하는 CG-프로세스들을 정의한다. 이러한 방식으로, PNA는 동일한 생태계의 생태계 컴포넌트들(예를 들어, 엔클레이브들, 코호트들, 및/또는 종속 코호트들)이 결합에 대 한 적격성을 확정할 수 있게 할 수 있다. 실시예들에서, PNA는 생태계 VDAX 및 후손 VDAX 하위 생태계들이 그 럼에도 불구하고 결합에 대한 적격성의 고유한 확정을 유지할 수 있게 한다. 실시예들에서, PNA 루트 모듈 은, 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 계산될 수 있는, 게놈 기반의 적격성 동기화 를 수행하도록 구성될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들을 포함할 수 있다. PNA 생성 및 PNA 기반의 적격성 상관관계의 비제한적 인 예들은 본 개시내용에서 나중에 논의된다. 실시예들에서, 루트 DNA 모듈은 생태계 특유의 데이터 및 CG 게놈 프로세스들을 관리하고, 이들로부터 루 트 DNA 모듈은 특정의 및 매우 엄격한 차이 및 상관관계를 가능케 하는 LNA를 공식화한다. 일부 실시예에 서, CG 생태계 컴포넌트 링크-교환-상관관계(link-exchange-correlation)는 LNA 객체들을 공식화하고 조성하는 CG-게놈 프로세스들에 의해 가능케된다. 실시예들에서, LNA 모듈은 개개의 생태계 컴포넌트들 사이에 특 정한 관계들을 확립하기 위해 CG 프로세스들 및 관련 계산 방법들을 정의한다. 이러한 방식으로, LNA는 생태계 (예를 들어, 동일한 엔클레이브의 멤버) 내의 소정의 VDAX들이 링크-교환-상관관계를 확정할 수 있게 할 수 있 다. 실시예들에서, LNA는 디지털 생태계의 VDAX들이 서로 결합하는 것을 허용하는 정보를 교환(\"링크 교환\")할 수 있게 하여, 링크 교환이 대응하는 계산 복잡성을 부담하게 한다. 일부 실시예에서, CG 기반의 LNA 지원형 링크 교환은, 당사자들(예를 들어, 제1 VDAX 및 제2 VDAX) 사이의 링크 교환이 고유하도록(예를 들어, 쌍대칭), 각각이 다른 당사자에 대해 고유한 2개 세트들의 정보에서 예측된다. 실시예들에서, LNA 루트 모듈들은, 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 계산될 수 있는 게놈 기반의 링크-교환-상관을 수행한 다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. LNA 생성 및 LNA 기반의 링크 교환의 비제한적인 예들은 본 개시내용에서 나중에 논의된다. 실시예들에서, 루트 DNA 모듈은 생태계 특유의 데이터 및 CG 게놈 프로세스들을 관리하고, 이들로부터 루 트 DNA 모듈은 특정의 및 매우 엄격한 차이를 가능케하는 XNA를 공식화한다. 이들 실시예들에서, 생태계 멤버 결합-분화는, XNA 객체들을 공식화하고 조성하는 CG-게놈 프로세스들에 의해 가능케될 수 있다. 실시예들 에서, 루트 XNA 모듈은 개개의 생태계 컴포넌트들 사이에 특정한 관계들을 확립하기 위해 XNA 특유의 CG 프로세스들 및 관련 계산 방법들을 채용한다. 실시예들에서, XNA는 동일한 생태계의 VDAX들이 결합-분화를 확 정할 수 있게 한다. 일부 실시예에서, XNA는, 상이한 생태계들의 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)가 결합-분화를 확정할 수 있게 한다. 결합-분화는, 한 쌍의 VDAX들이 데이터를 안전하게 교환할 목적으로 충분히 상관된 다른 VDAX들로부터 자신들을 충분히 분화시키는 것을 허용하 여, 결합이 대응하는 계산 복잡성을 부담한다. 일부 실시예에서, XNA 지원형 결합은, 2개의 VDAX(예를 들어, 제1 VDAX 및 제2 VDAX) 사이의 결합이 고유하도록(예를 들어, 쌍대칭), 각각이 다른 당사자에 대해 고유한 2개 세트의 정보에서 예측될 수 있다. 실시예들에서, XNA 모듈은 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 계산될 수 있는 게놈 기반의 결합 분화를 수행한다. 실시예들에서, 정보 이론 지원형 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다 XNA 생성 및 XNA 기반의 게놈 분화의비제한적인 예들은 본 개시내용에서 나중에 논의된다. 실시예들에서, CG-ESP는 생태계 특유의 데이터 및 CG-게놈 프로세스들을 관리하는 EIC 모듈을 포함할 수 있고, 이들로부터 EIC 모듈들이 ZNA라고 불리는 특정한 및 매우 엄격한 차이를 가능케하는 조성들을 공식 화한다. 실시예들에서, 생태계 EIC 결합-분화는 ZNA 객체들을 공식화하고 조성하는 CG-게놈 프로세스들에 의해 가능케된다. 실시예들에서, ZNA는 동일한 생태계의 VDAX들이 다른 VDAX 컴포넌트들에 의한 참여없이 게놈 지원 형 분화 프로세스들을 직접 제어할 수 있게 한다. 예를 들어, 실시예들에서 EIC VDAX(예를 들어, 코어 및 메모 리)는 ZNA 특유의 게놈 프로세스들 및 다른 관련 계산 방법들을 채용하여 다른 특정한 EIC VDAX들과의 분화를 확립할 수 있다. 실시예들에서, EIC 모듈은, 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 계 산될 수 있는 게놈 기반의 결합 분화를 수행하기 위한 CG 프로세스들을 정의할 수 있다. 실시예들에서, 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. ZNA 생성 및 ZNA 기반의 게놈 분화의 비제한적인 예들은 본 개시내용에서 나중에 논의된다. 링크 모듈 실시예들에서, 링크 모듈은 2개의 VDAX(예를 들어, 제1 VDAX 및 제2 VDAX)가 쌍대칭 결합을 가능케하는데 필요한 정보를 안전하게 교환하는 것을 허용하는 한 세트의 CG 프로세스들 및 관련 계산 방법들을 정의한다. 일부 실시예에서, 링크 교환은 쌍대칭 결합과 동일한 레벨의 엔트로피를 나타낸다. 일부 실시예에서, 링크 모 듈 인스턴스는 또 다른 VDAX와의 결합 적격성 및 링크 교환 상관관계를 확정하도록 구성될 수 있다. 실시 예들에서, 결합 적격성 및 링크 교환 상관관계는 한 쌍의 VDAX들이 링크들을 성공적으로 교환하는 것을 허용한 다(예를 들어, 링크 스폰 및 링크 호스팅). 실시예들에서, 링크 모듈은 그 게놈 결합 객체(예를 들어, CNA 또는 PNA)에 기초하여 또 다른 VDAX와의 결합 적격성을 확정하도록 구성될 수 있다. 예를 들어, 링크 모듈 은 그 대응하는 CNA 객체 및/또는 그 대응하는 PNA 객체를 이용한 적격성-동기화를 이용하여 결합-상관관 계를 확정할 수 있다. 실시예들에서, VDAX(예를 들어, 제1 VDAX)의 링크 모듈은 제1 VDAX의 게놈 상관관계 객 체에 기초하여 또 다른 VDAX와의 링크-교환-상관관계를 확정하도록 구성될 수 있다. 일부 실시예에서, 링크 모 듈 인스턴스는 제1 VDAX의 게놈 상관관계 객체(예를 들어, LNA 객체) 및 VDAX와 결합할 다른 VDAX에 대한 정보에 기초하여 또 다른 VDAX(예를 들어, 제2 VDAX)에 대한 링크를 스폰한다. 실시예들에서, VDAX(예를 들어, 제1 VDAX)의 링크 모듈 인스턴스는, 부분적으로, 제1 VDAX의 게놈 상관관계 객체를 이용하여 다른 VDAX에 의해 또는 이를 대신하여 제공되는 링크로부터 또 다른 VDAX와 결합하기 위한 정보를 디코딩함으로써 링크를 호 스팅할 수 있다. 링크 모듈의 상이한 구성들은 다양한 CG 게놈 프로세스들 및 관련 계산 방법들을 이용하 여 광범위한 상호운용가능한 디지털 통신 매체, 디지털 네트워크들, 및/또는 디지털 디바이스들에 걸쳐 보안 링 크 교환을 실행할 수 있다는 점에 유의한다. VDAX들 사이의 링크 교환은 교환 순서가 프로토콜의 보안에 영향 을 미치지 않는다는 점에서 비동기적으로 실행될 수 있다는 점에 유의한다. 더욱이, 실시예들에서, 링크 교환 은, 하나의 VDAX가 또 다른 VDAX(예를 들어, 대칭)에 대한 링크를 제공하거나 양쪽 VDAX들이 다른 상응하는 VDAX에 대한 링크를 제공하는 것(예를 들어, 쌍대칭)을 포함할 수 있다. 실시예들에서, 링크 모듈은 광범 위한 계산적 복합 기능들에 따라 계산될 수 있는 정보의 게놈 기반의 교환을 수행하는 CG 프로세스들을 정의할 수 있다. 실시예들에서, 계산적 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 기능들일 수 있다. 언급된 바와 같이, 링크는 쌍대칭적 결합을 가능케하는 정보를 포함할 수 있다. 실시예들에서, 링크에 포함된 정보는 게놈 조절 명령어들(GRI)을 포함할 수 있다. 일부 실시예에서, GRI는, 제1 VDAX가 제2 VDAX에 대한 링 크를 제공하고 제2 VDAX가 링크에 포함된 GRI를 성공적으로 디코딩할 때, 제1 VDAX와 제2 VDAX 양쪽 모두가 GRI 를 이용하여 그들의 상응하는 게놈 분화 객체를 수정하여 결과적으로 수정된 게놈 분화 객체(예를 들어, 수정된 XNA 또는 수정된 ZNA)의 고도의 상관된 사본들이 생성될 수 있도록, 결정론적 방식으로 게놈 분화 객체(예를 들 어, XNA 또는 ZNA)를 수정하는데 이용되는 명령어들 및/또는 데이터를 정의할 수 있다. 본 명세서에서 사용될 때, 게놈 객체들과 관련하여 사용될 때 \"고도로 상관된\"은 동일한 및/또는 그렇지 않으면 충분히 상관된 게놈 객체들을 지칭할 수 있으며, 이에 의해 2개의 게놈 객체는, 2개 이상의 게놈 객체들 사이의 상관의 정도가 의도 된 CG 동작 또는 프로세스가 성공적으로 수행될 수 있게 한다면 \"충분히 상관된\" 것이라고 말할 수 있다. 실시 예들에서, GRI는 서열 맵핑 동안 VDAX에 의해 이용되는 명령어들 및/또는 데이터 등의 추가 정보를 포함할 수 있다. 더 상세히 논의되는 바와 같이, 이러한 결정론적 수정은 2개의 코호트가 보안 VBLS의 생성을 실행하기 위해 다른 모든 코호트로부터 자신을 분화하는 것을 허용한다. 실시예들에서, 링크 모듈은, 고유한 GRI가 임의의 상응하는 결합에 대해 생성되도록, 상응하는 링크에 대한 GRI를 생성할 수 있다. 일부 실시예에서, 링 크 모듈은 인코딩된 GRI를 획득하기 위해 링크 특유의 결합 인자를 이용하여 GRI를 인코딩할 수 있다. 링 크 모듈은, 정보 및 링크 호스팅 VDAX의 게놈 데이터에 기초하여 GEC로부터 GRI를 디코딩하기 위해 링크호스팅 VDAX에 의해 이용되는 추가 정보 및 인코딩된 GRI를 포함하는 게놈 결합 화물(GEC)을 생성할 수 있다. 실시예들에서, 링크 모듈은 또한, (\"링크 호스팅\"의 일부인) 링크를 디코딩하도록 구성되며, 이에 의해 링 크 모듈은 GEC에 포함된 정보 및 그 게놈 데이터 세트에 기초하여 변환값을 획득하고 변환값을 이용하여 인코딩된 GRI를 디코딩해 GRI를 획득한다. 그 다음, 디코딩된 GRI는, 링크를 제공한 링크 스폰 VDAX에 대한 VBLS를 생성할 때 링크 호스팅 VDAX에 의해 이용될 수 있다. 실시예들에서, 링크 모듈은 또한, 링크들을 업데이트하도록 구성될 수 있다. 링크 업데이트는, VDAX 쌍 사이의 특정한 결합을 위해 제1 VDAX에 의해 제2 VDAX에 제공된 게놈 조절 명령어들(GRI)을 수정하기 위한 프로 세스를 지칭할 수 있다. 링크가 손상되었다는 우려를 포함한 임의의 수의 이유로 및/또는 일상적인 보안 프로 토콜들에 따라 링크가 업데이트될 수 있다(예를 들어, 링크들은, 매일, 매주 또는 매월 업데이트되거나, 링크를 업데이트하라는 코호트 요청에 응답하여). 일부 실시예에서, 링크 모듈은 링크 업데이트 정보를 생성함으 로써 링크를 업데이트할 수 있으며, 이에 의해 링크를 호스팅하고 있는 VDAX에 대한 링크를 스폰한 VDAX로부터 링크 업데이트 정보가 제공된다. 실시예들에서, 링크 업데이트 정보는 현재 GRI를 대체하는 새로운 GRI를 포함 할 수 있다. 다른 실시예들에서, 링크 업데이트 정보는 현재의 GRI를 수정하는데 이용되는 데이터를 포함할 수 있다. 예를 들어, 링크 업데이트 정보는, 호스팅 VDAX가 하나 이상의 계산적 복합 기능(예를 들어, 암호 기반 의, 암호 없는 또는 하이브리드 기능들)을 이용하여 현재 GRI에 값을 적용하여 업데이트된 GRI를 획득하도록, GRI를 변환하는데 이용되는 값일 수 있다. 일부 실시예에서, 링크 업데이트는 링크 업데이트 정보가, 계산적으 로 비용이 더 많이 드는 동작들을 포함할 수 있는 링크 교환과는 대조적으로, VBLS에서 인코딩될 수 있다는 점 에서 링크 교환과 상이하다. 따라서, 링크 교환은 일회성 프로세스로서 수행될 수 있고, 링크 업데이트는 임의 의 횟수 및/또는 임의의 적절한 이유로 수행될 수 있다. 실시예들에서, 링크들은 정적 링크들 또는 동적 링크들일 수 있다. 실시예들에서, 동적 링크들은 한 쌍의 코호 트를 더 분화시키는 추가 정보를 포함하는 링크들을 지칭할 수 있다. 일부 실시예에서, 동적 링크들은, 그들의 결합과 관련하여서만 VDAX 쌍에 의해 수행되는 기능들 중 하나 이상을 변경하는데 이용되는 실행가능한 코드(또 는 실행가능한 코드에 대한 참조)를 포함할 수 있다. 예를 들어, 동적 링크는, 상응하는 결합에 대한 XNA/ZNA 수정 기능, 서열 맵핑 기능 및/또는 2진 변환 기능을 변경하는 실행가능한 코드를 포함할 수 있다. 이러한 방 식으로, 한 쌍의 VDAX들이 동적 링크를 교환할 때, 코호트 쌍은 특정 기능(예를 들어, XNA/ZNA 분화, 서열 맵핑, 및/또는 2진 변환)을 수행할 때 디폴트 코드 대신에 또는 이에 추가하여 실행가능한 코드를 실행할 수 있 다. 실시예들에서, 정적 링크들은, CG-ESP의 구성이 특정한 결합에 대해 변경되지 않는 경우의 결합들에서 이 용되는 링크들을 지칭할 수 있다. 실시예들에서, 정적 링크 모듈은, 2개의 VDAX(예를 들어, 제1 VDAX 및 제2 VDAX)가 고유한 쌍대칭 결합을 가능케하는데 필요한 정보를 안전하게 교환(예를 들어, 링크 스폰 및 링크 호스팅)할 수 있게 하는 CG 프로세스 들을 정의하고, 이에 의해 교환은 동일한 레벨의 엔트로피를 나타낸다. 실시예들에서, 정적 링크들을 지배하는 규칙들 및 프로세스들은 생태계(예를 들어, 생태계 VDAX)에서 가장 높은 클래스의 VDAX에 의해 규정되며, 이에 따라 규칙들은 생태계 내의 모든 링킹 VDAX들에 적용될 수 있다. 실시예들에서, 정적 링크 모듈 인스턴스 는, 적격성-상관에 이용되는 CNA 및/또는 적격성-동기화에 이용되는 PNA와 관련된 CG 프로세스들을 실행할 수 있다. 일부 실시예에서, 정적 링크 모듈 인스턴스는 링크-교환-상관에 이용되는 LNA와 관련된 CG 프로세 스들을 실행한다. 실시예들에서, CG 플랫폼 인스턴스는, 광범위한 상호운용가능한 디지털 통신 매체, 디지털 네트워크들, 및/또는 디지털 디바이스들에 걸친 보안 링크 교환을 용이화하는 프로세스들을 실행하도록 구성될 수 있다. 실시예들에서, VDAX들은 교환 순서가 프로토콜의 보안에 영향을 미치지 않는다는 점에서 비동기적으 로 링크 교환을 수행할 수 있다. 더욱이, 실시예들에서, 링크 교환은, 하나의 VDAX가 또 다른 VDAX(예를 들어, 대칭)에 대한 링크를 제공하거나 양쪽 VDAX들이 다른 상응하는 VDAX에 대한 링크를 제공하는 것(예를 들어, 쌍 대칭)을 포함할 수 있다. 일부 실시예에서, 정적 링크 모듈들 인스턴스들은, 암호 기반, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있는, 광범위한 계산적 복합 기능들에 따라 계산될 수 있는 게놈 기반의 결합 분화를 수행한다. 실시예들에서, 동적 링크 모듈은, 2개의 VDAX(예를 들어, 제1 VDAX 및 제2 VDAX)가 고유한 쌍대칭 결합을 가능케하는데 필요한 정보를 안전하게 교환(예를 들어, 링크 스폰 및 링크 호스팅)할 수 있게 하는 CG 프로세스 들을 정의하고, 이에 의해 교환은 동일한 레벨의 엔트로피를 나타낸다. 실시예들에서, 동적 링크들을 지배하는 규칙들 및 프로세스들은, 추가적인 게놈적으로 호환되는 링크 교환 명령어들 및 프로세스들을 확립하는 권한을 포함한, 생태계 내의 최고 클래스의 VDAX(예를 들어, 생태계 VDAX)에 의해 규정된다. 실시예들에서, 동적 링크 모듈은 CG 지원형 생태계에서 최고 레벨의 VDAX에 의해 허용되는 다양한 CG 프로 세스를 수정하는 실행가능한 명령어 세트들(예를 들어, 2진 코드, 스크립트 등)을 포함하는 동적 링크들을 생성 할 수 있다. 이들 실시예들에서, 동적 링크 내의 실행가능한 명령어 세트는 특정한 결합에 대해 소정의 모듈들 (예를 들어, XNA 모듈, 서열 맵핑 모듈 및/또는 2진 변환 모듈)의 기능들을 무시할 수 있다. 이러한 방식으로, 동적 링크를 교환한 한 쌍의 VDAX들은 그 특정한 결합과 관련하여 수행되는 그들의 CG 프로세스들을 변경할 수 있고, 이것은 추가적인 보안 계층을 제공할 수 있다. 일부 실시예에서, 동적 링크 모듈은, 처리된 명령어 세트가 특정한 결합에 관하여 실행되어 상기 결합 동안에 수행되는 하나 이상의 CG 프로세스를 무시하도록, 동 적 링크에 포함된 명령어 세트를 처리하는 인터프리터 또는 적시 컴파일러(just-in-time compiler)를 포함할 수 있다. 일부 실시예에서, 제1 동적 링크 모듈 인스턴스는 실행가능한 명령어 세트를 포함하는 동적 링크를 스폰할 수 있다. 이들 실시예들에서, 제2 VDAX의 제2 동적 링크 모듈 인스턴스는, 제2 VDAX가 제1 VDAX에 대한 VBLS를 생성하고 있을 때, 상응하는 동적 링크 모듈들이 그 특정한 결합에 대해 양쪽 모두 우선적인 CG-프로세스(들)를 이용할 수 있도록, 동적 링크를 디코딩할 수 있다. 제2 VDAX는 VBLS를 생성하기 위해 우선 적인 CG-프로세스(들)를 이용할 수 있는 반면, 제1 VDAX는 VBLS를 디코딩하기 위해 우선적인 CG-프로세스(들)를 이용할 수 있다. 제2 동적 링크 모듈 인스턴스로부터 제1 동적 링크 모듈 인스턴스로의 제2 동적 링 크를 이용한 반대 방향으로의 데이터 교환은, 제1 VDAX가, 제2 동적 링크에 정의된, 우선적인 CG-프로세스(들) 를 이용하여 제2 VBLS를 생성하는 반면, 제2 VDAX는 우선적인 CG-프로세스(들)를 이용하여 제2 VBLS를 디코딩한 다는 점에서, 동일한 방식으로 동작할 수 있다는 것을 이해해야 한다. 실시예들에서, 동적 링크 모듈 인스턴스들은, 광범위한 옵션, 상황, 조건 및 목표에 의해 지배될 수 있는, 다른 VDAX들에 의해 공유되지 않는 명령어들 및 관련 CG 프로세스 프로세스들을 확립할 수 있다. 실시예들에서, CG 프로세스들 자체가 고유한 쌍의 VDAX들에 대해 고유한 방식으로 수정되기 때문에 동적 링크들 은 추가적인 레벨들의 보안을 제공한다. 실시예들에서, 동적 링크 모듈은, 교환 순서가 프로토콜의 보안에 영향을 미치지 않는다는 점에서 동적 링 크 교환을 비동기적으로 수행할 수 있다. 또한, 실시예들에서, 동적 링크 모듈에 의해 수행되는 링크 교 환은, 하나의 VDAX가 또 다른 VDAX로의 링크를 제공하는 것(예를 들어, 대칭) 또는 양쪽 VDAX들이 다른 상응하 는 VDAX로의 링크들을 제공하는 것(예를 들어, 쌍대칭)을 포함할 수 있다. 실시예들에서, 동적 링크 모듈 인스턴스들은, 암호 기반, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있는, 광범위한 계산적 복합 기능들에 따라 계산될 수 있는, 게놈 기반의 결합 분화를 수행한다. 서열 맵핑 모듈 실시예들에서, 서열 맵핑 모듈은 서열 맵핑을 수행하는 한 세트의 CG 프로세스들 및 계산 방법들을 정의할 수 있다. 일부 실시예에서, 서열 맵핑은 고유한 비반복적 디지털 객체들을 변환하기 위한 중요한 계산일 수 있 다. 실시예들에서, 서열 맵핑 모듈 인스턴스들은, 공개 서열들(예를 들어, 공개 프로토콜 및/또는 포맷 종속 메타데이터) 및/또는 사적 서열들(예를 들어, 사적 및 전용 프로토콜들 및/또는 포맷 종속 메타데이터)를 (수정된) 게놈 데이터 객체들로 맵핑하도록 구성될 수 있다. 서열들이 공개인지 사적인지에 관계없이, 서열들 은 광범위하게 이질적일 수 있고(예를 들어, TCP, UDP, TLS, HTTP, H.265, 또는 기타의 공개 또는 사적 서열 들), 특정한 레벨들의 엔트로피를 나타내는 결과들을 획득하기 위해 수정된 게놈 데이터에 맵핑될 수 있다(예를 들어, 게놈 결합 인자들). 실시예들에서, 서열 맵핑 모듈은 공개 서열 맵핑 모듈 및/또는 사적 서열 맵핑 모듈을 포함할 수 있다. 실시예들에서, 공개 서열 맵핑 모듈은 공개 소스들(예를 들어, 특정한 프로토콜 또는 포맷 종속 메타데이 터)로부터 특정한 서열을 선택하도록 구성된 CG 지원형 프로세스들 및 관련 방법들을 정의할 수 있다. 일부 실 시예에서, 공개 서열 맵핑 모듈 인스턴스는 특정한 값(예컨대, 서열 변환 벡터 또는 \"SCV\")을 도출하기 위 해 주어진 공개 서열(\"PBS\")를 처리할 수 있다. 일부 구현에서, 공개 서열 맵핑 모듈은 GRI 및/또는 하나 이상의 계산적 복합 기능에 기초하여 SCV를 도출한다. 실시예들에서, SCV는 게놈 데이터 객체(예컨대, XNA, ZNA 또는 LNA) 및 GRI로 처리되어 특정 엔트로피(예컨대, 게놈 결합 인자 또는 변환값)를 나타내는 고유 벡터를 생성할 수 있다. 실시예들에서, 결과적인 벡터는 벡터를 도출하는데 이용되는 공개 서열의 크기를 크게 초과하 는 엔트로피 레벨을 나타낼 수 있다. 실시예들에서, 공개 서열 맵핑 모듈들은 무관한 프로토콜들 및 포맷 들에 존재하는 특정한 설비들을 활용할 수 있는 고유한 벡터들을 생성한다. 실시예들에서, 공개 서열 맵핑 모 듈들은, 공개 서열들 및 게놈 분화 객체(예를 들어, 수정된 XNA 객체)에 기초하여 고유한 벡터들을 생성하 기 위해 계산적 복합 기능들에 따라 계산된 게놈 프로세스들을 실행한다. 실시예들에서, 이들 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다.실시예들에서, 사적 서열 맵핑 모듈은, 사적 소스들(예를 들어, 사적 및/또는 전용 프로토콜 또는 포맷 종 속 메타데이터)로부터 특정한 서열들을 선택하고 특정한 엔트로피를 나타내는 고유한 벡터를 도출하도록 구성된 CG 지원형 프로세스들 및 관련 방법들을 정의할 수 있다. 일부 구현에서, 사적 서열 맵핑 모듈 인스턴스 는 GRI에 기초하여 특정한 값(예컨대, 서열 변환 벡터(SCV))를 도출하기 위해 주어진 사적 서열(\"PVS1\")을 처리 할 수 있다. 실시예들에서, SCV는 게놈 데이터 객체(예컨대, XNA, ZNA 또는 LNA) 및 GRI로 처리되어 특정 엔트 로피(예컨대, 게놈 결합 인자 또는 변환값)를 나타내는 고유 벡터를 생성할 수 있다. 실시예들에서, 결과적인 벡터는 벡터를 도출하는데 이용되는 공개 서열의 크기를 크게 초과하는 엔트로피 레벨을 나타낼 수 있다. 실시 예들에서, 사적 서열 맵핑 모듈 인스턴스는 무관한 사적 프로토콜들 및 포맷들에 존재하는 특정한 설비들 을 활용할 수 있는 고유한 벡터들을 생성한다. 실시예들에서, 사적 서열 맵핑 모듈 인스턴스는, 공개 서 열들 및 게놈 분화 객체(예를 들어, 수정된 XNA 객체)에 기초하여 고유한 벡터들을 생성하기 위해 한 세트의 계 산적 복합 기능들에 따라 계산된 게놈 프로세스들을 실행한다. 실시예들에서, 이들 기능들은, 암호 기반, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 서열 맵핑 모듈의 예시적인 구성들은 아래에서 더 상세히 제공된다. 2진 변환 모듈 실시예들에서, 2진 변환 모듈은 가상 2진(예를 들어, 객체-대-객체) 언어 스크립트(VBLS)를 생성하도록 구 성된 한 세트의 CG 프로세스들 및 관련 계산 방법들을 정의할 수 있다. 실시예들에서, 2진 변환 모듈 인 스턴스들은, 다양한 계산 방법(예를 들어, 명료화 방법들 및/또는 암호화 방법)들에 의해 특정한 포맷들 및 프 로토콜들을 갖는 디지털 객체들(예를 들어, 패킷들, 섹터들, 서열들, 및/또는 프레임들)을 변환한다. 실시예들 에서, 2진 변환 모듈 인스턴스들은, 대응하는 서열 맵핑 모듈에 의해 결정된 값들(예를 들어, 게놈 결합 인자들)에 기초하여 디지털 객체들을 인코딩하여, 고유한, 비반복적, 및/또는 계산적으로 양자 증명일 수 있는 인코딩된 디지털 객체들을 생성하도록 구성된다. 실시예들에서, 2진 변환 모듈 인스턴스들은 또한, 대응하는 서열 맵핑 모듈에 의해 결정되는 값들(예를 들어, 게놈 결합 인자들)을 이용하여 인코딩된 디지 털 객체들을 디코딩하도록 구성될 수 있다. 실시예들에서, 2진 변환 모듈은 명료화 모듈들 및/또는 암호화 모듈들을 포함할 수 있다. 실시예들에서, 명료화 모듈은, 대응하는 서열 맵핑 모듈 인스턴스에 의해 생성된 게놈적으로 도출된 게놈 결합 인자들에 따라 디지털 객체들의 2진 변환을 수행하는 CG 프로세스들 및 계산 방법들을 정의할 수 있 으며, 이에 의해 결과적인 인코딩된 디지털 객체들은 무차별 공격에만 노출된다. 실시예들에서, 명료화 모듈 인스턴스는, 게놈 결합 인자 및 디지털 객체에 관해 XOR 연산을 수행하여 인코딩된 디지털 객체를 획득함 으로써 게놈 결합 인자에 기초하여 디지털 객체를 변환할 수 있다. 실시예들에서, 명료화 모듈 인스턴스 는, 동일한 게놈 결합 인자가 2개 이상의 디지털 객체를 인코딩하는데 이용되는 경우 명료화 기술들이 더 효율 적인 공격으로 공격할 수 있기 때문에, 각각의 디지털 객체에 대해 상이한 게놈 결합 인자를 수신하도록 구성될 수 있다. 실시예들에서, 명료화 모듈 인스턴스는, 역 명료화 기능 및 게놈 결합 인자를 이용하여 인코딩 된 디지털 객체를 디코딩하도록 구성될 수 있다. 게놈 결합 인자가 디지털 객체를 인코딩하는데 이용된 게놈 결합 인자와 정합한다고 가정하면, 역 명료화 기능은, 게놈 결합 인자 및 인코딩된 디지털 객체가 주어질 경우 디코딩된 디지털 객체를 출력한다. 실시예들에서, 명료화 모듈 인스턴스는 계산적 복합 기능들에 따라 게 놈 프로세스들을 실행한다. 실시예들에서, 이들 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 실시예들에서, 암호화 모듈은, 대응하는 서열 맵핑 모듈 인스턴스에 의해 생성된 게놈적으로 도출된 게놈 결합 인자들에 따라 디지털 객체들의 2진 변환을 수행하는 CG 프로세스들 및 계산 방법들을 정의할 수 있 으며, 이에 의해 결과적인 인코딩된 디지털 객체들은 무차별 공격에만 노출된다. 실시예들에서, 암호화 모듈 인스턴스는, 게놈 결합 인자 및 디지털 객체를 입력으로서 수신하고 인코딩된 디지털 객체를 출력하는 임 의의 적절한 암호화 기능을 이용하여 게놈 결합 인자에 기초하여 디지털 객체를 변환할 수 있다. 실시예들에서, 이용되는 암호화 기능은, 인코딩된 디지털 객체를 디코딩하는데 이용될 수 있는 대응하는 역 암 호화 기능(또는 해독 기능)을 가져야 한다. 실시예들에서, 암호화 모듈 인스턴스는, 각각의 디지털 객체 에 대해 상이한 게놈 결합 인자를 수신하도록 구성될 수 있거나 2개 이상의 상이한 디지털 객체에 대해 동일한 변환을 이용할 수 있다. 실시예들에서, 암호화 모듈 인스턴스는, 역 암호화 기능 및 게놈 결합 인자를 이용하여 인코딩된 디지털 객체를 디코딩하도록 구성될 수 있다. 게놈 결합 인자가 디지털 객체를 암호화하는데 이용된 게놈 결합 인자와정합한다고 가정하면, 역 암호화 기능은, 게놈 결합 인자 및 인코딩된 디지털 객체가 주어질 경우 디코딩된 디 지털 객체를 출력한다. 실시예들에서, 암호화 모듈 인스턴스들은 계산적 복합 기능들에 따라 게놈 프로세 스들을 실행한다. 실시예들에서, 이들 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능 들일 수 있다. 인증 모듈 실시예들에서, 인증 모듈은 공통 게놈 조성을 갖는 VDAX들을 인증하도록 구성된 CG 프로세스들 및 계산 방 법들을 정의할 수 있다. 논의된 바와 같이, 최고 레벨의 VDAX(예를 들어, 생태계 VDAX)에 의해 조성된 디지털 생태계들은, 게놈 데이터(예를 들어, CNA, PNA, LNA, XNA 및/또는 ZNA)의 특정한 분포를 갖고, 또한 특정한 게 놈 적격성-상관관계, 적격성-동기화 링크 교환-상관관계, 및/또는 결합-상관관계 속성들을 갖는다. 실시예들에 서, 인증 모듈 인스턴스들은, 대응하는 VDAX가 그들의 1차 게놈 조성(예를 들어, 디지털 생태계 내의 상이 한 엔클레이브의 멤버들)에 관계없이, 공통 조성(예를 들어, 관련 게놈 데이터)을 갖는 임의의 다른 VDAX의 결 합 상관관계를 확정할 수 있게 하도록 구성될 수 있다. 실시예들에서, 인증 모듈은, 대응하는 VDAX가, VDAX들이 어느 엔클레이브(들)에 속하는지에 관계없이, 그들의 공통 게놈 조성에 기초하여 동일한 CG 지원형 디 지털 생태계로부터의 또 다른 VDAX와의 결합 상관관계를 확정할 수 있게 하는 CG 프로세스들 및 관련 계산 방법 들을 정의하는 코호트-대-코호트 모듈을 포함할 수 있다. 실시예들에서, 인증 모듈 인스턴스들은, 암호 기반, 암호없는, 또는 하이브리드 계산적 복합 기능들일 수 있는 계산적 복합 기능들에 따라 게놈 데이터 세트들의 안전한 게놈 기반의 결합 상관을 수행하도록 구성된다. 마스터 무결성 제어기 논의된 바와 같이, 루트 DNA 조성들의 일치 및 지원하는 게놈 프로세스들(예를 들어, 링크 생성, 결합 상관, VBLS 생성 등)은 CG 모듈들의 특정한 구성에 의해 직접 관리되고 제어된다. 실시예들에서, 상응하는 CG-ESP들 은 마스터 무결성 제어기 CG-프로세스들 및 VDAX를 대신하여 모듈 순응성을 관리하는 관련 계산 방법들을 포함할 수 있다. 실시예들에서, 마스터 무결성 제어기들은, 디지털 생태계들 전반에 걸쳐 VDAX들에 대한 구성 관리 및 동작 성능의 정확성을 보장하는 CG-프로세스들 및 관련 계산 방법들을 포함할 수 있다. 실시예들 에서, 마스터 무결성 제어기는, 게놈 프로세스 제어기, 인가 모듈, 및 결합 인스턴스 모듈(47 6)을 포함할 수 있다. 실시예들에서, VDAX들, 그들의 게놈 모듈들, 및 기타의 이러한 기능 모듈의 결합은, (예를 들어, 대응하는 VDAX 에 의해 실행될 수 있는) 상응하는 CG-ESP 인스턴스들의 상응하는 마스터 무결성 제어기 인스턴스들에 의 해 제어될 수 있다. 실시예들에서, 마스터 무결성 제어기 인스턴스는 계산적 복합 기능들을 활용하여 특 정한 모듈들(예를 들어, 1 내지 N)과 결합한다. 이들 실시예들 중 일부에서, 마스터 무결성 제어기 인스 턴스는, 모듈들과 마찬가지로, 상응하는 게놈 데이터 세트(예를 들어, CNA, PNA, LNA, 및/또는 XNA)를 가질 것 이며, 계산적 복합 기능들을 이용하여 특정한 모듈들과 결합하고 이들을 관리할 수 있다. 일부 실시예에서, 게 놈 프로세스 제어기는 모듈들의 무결성을 검증하고 그 게놈 데이터 및 계산적 복합 기능들을 이용하여 모 듈들을 인증할 수 있다. 이들 실시예들에서, 게놈 프로세스 제어기 인스턴스들은 상응하는 VDAX에 의해 실행되는 프로세스들이나 기능들을 결정하도록 구성되지 않는다. 상응하는 VDAX에 의해 실행되는 계산적 복합 게놈 프로세스들을 보호하기 위해, 게놈 프로세스 제어기는 모듈 프로세스들 및 기능들의 올바른 적용에 수반되는 동작 프로세스들 및 기능들을 제어할 수 있으며, 또한 특정한 모듈들의 제어하에 소정의 동작 프로세 스들 및 기능들을 모듈 프로세스들 및 기능들의 올바른 적용에 노출시킬 수도 있다. 달리 말하면, 실시예들에 서, 게놈 프로세스 제어기는 CG-ESP 모듈 인스턴스의 소스를 확정하거나 및/또는 CG-ESP 인스턴스의 무결 성뿐만 아니라, 모듈 인스턴스들(예를 들어, 다양한 CG 기반의 기능들을 위해 모듈들을 접속하는 프로세스들)을 지원하여 수행되는 임의의 프로세스들 및 동작들을 확정하거나 거부할 수 있다. 실시예들에서, 모듈들 및 마스터 무결성 제어기처럼, 동일한 계산적 복합 게놈 기능들을 이용하는 VDAX들 은 특정한 CG-ESP 구성들을 확정하거나 실격시킬 수 있다. 예를 들어, 실시예들에서, 동일한 계산적 복합 게놈 기능들을 이용하는 VDAX들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)은, 모 듈들 및 마스터 무결성 제어기처럼, 특정한 CG-ESP 구성들을 확정하거나 실격시킬 수 있다. 실시예들에서, 모듈들 및 마스터 무결성 제어기처럼, 동일한 계산적 복합 게놈 기능들을 이용하는 VDAX는 특정한 CG-ESP 구성들을 확정, 실격 또는 수정할 수 있다. 실시예들에서, 마스터 무결성 제어기는, 게놈 프로세스 제어기, 인가 모듈, 및 결합 인스턴스 모듈을 포함할 수 있다. 실시예들에서, 게놈 프로세스 제어기 모듈 인스턴스들은, 광범위한 계산적 복합 기능들에 따라 계산될 수 있는 VDAX 모듈들 및특정한 VDAX 구성들의 보안 게놈 기반의 확정, 실격 및 수정을 수행한다. 실시예들에서, 이들 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 실시예들에서, VDAX들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)는, 구성 제 어가 수평적으로 및/또는 계층적으로 영향을 받을 수 있다는 점에서 엄청난 채택, 배치 및 운영 유연성을 제공 한다. 실시예들에서, 이들 유연성은 CG-ESP 모듈들에 의해 용이화되는 동일한 고유의 계산적 복합 게놈 기능들 (예를 들어, 상관 및 분화)로부터 도출된다. 실시예들에서, VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)는, 단일 생태계 또는 엔클레이브 VDAX들(예를 들어, 선조)이 다른 VDAX들의 동작 구성(예를 들어, 마스터 무결성 제어기 상호통신)을 결정할 수 있도록 고유하게 구성되고 인에이블될 수 있다. 실시예들에서, 선조(예를 들어, 생태계 VDAX 또는 엔클레이브 VDAX)는 그들의 구성들에 기초하여 다 른 VDAX들의 동작 상태를 직접 확정하거나 실격시킬 수 있다. 실시예들에서, 선조(예를 들어, 생태계 VDAX 또 는 엔클레이브 VDAX)는, VDAX들의 인가된 모듈 업데이트들이 다른 인가된 CG-ESP 모듈들과 연계하여 실행될 수 있도록, 구성되고 인에이블된 고유한 게놈 속성들을 소유할 수 있다. 실시예들에서, 마스터 인가 모듈 인 스턴스들은, 암호 기반, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있는 광범위한 계산적 복합 기능 들에 따라 계산될 수 있는 VDAX 모듈들 및 특정한 VDAX 구성들의 보안 게놈 기반의 확인, 실격, 및 수정을 실행 한다. 실시예들에서, EG-CSP 지원형 계산적 복합 게놈 기능들을 이용하는 2개 이상의 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX) 사이의 결합은 단일 보안 인스턴스를 구성한다. 일부 실시 예에서, 이들 보안 인스턴스들은 특정한 디지털 생태계 커뮤니티에 의해 나타나는 계층적 게놈 관계에 따라 집 결될 수 있다. 실시예들에서, 더 낮은 레벨들에서 집결된 보안 인스턴스들은, 그 다음의 또는 임의의 다른 상 위 집결 지점에 전달될 수 있고(예를 들어, 코호트 VDAX들로부터 엔클레이브 VDAX들), 기타 등등(예를 들어, 코 호트 VDAX들 및 엔클레이브 VDAX들로부터 생태계 VDAX들)으로 전달할 수 있다. 실시예들에서, VDAX 모듈들 사 이의 통신(예를 들어, 보안 인스턴스 보고)은 그들의 1차 보안 인스턴스들을 관리하기 위한 동일하거나 상이한 계산적 복합 게놈 기능들에 기초할 수 있다. 실시예들에서, 마스터 결합 인스턴스 모듈 인스턴스는, VDAX 들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)이 한 세트의 결합 추적 정책들 에 따라 보안 인스턴스들을 추적할 수 있게 한다. 일부 실시예에서, 이들 정책들은 보안 인스턴스들이 정의되 는 방법을 규정할 수 있다. 실시예들에서, 이들 정의들은 특정한 계산적 복합 보안 기능들을 포함할 수 있다. 실시예들에서, 마스터 결합 인스턴스 모듈 인스턴스들은, VDAX들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)이 결합 어카운팅 정책들에 따라 생성되는 보안 인스턴스의 수를 계산할 수 있게 한다. 실시예들에서, 이들 정책들은 보안 인스턴스들이 축적되는 방법을 규정한다. 실시예들에서, 이 들 축적은 특정한 계산적 복합 보안 기능들을 가질 수 있다. 실시예들에서, 마스터 결합 인스턴스 모듈 인스턴스들은, 공통 조성을 갖는 VDAX들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)이, 한 세트의 결합 보고 정책들에 따라 보안 인스턴스들을 다른 VDAX(예를 들어, 생태계 VDAX, 엔클레이 브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX))에 보고할 수 있게 한다. 실시예들에서, 이들 정책들은 보안 인스 턴스들이 보고되는 방법, 빈도 및 대상을 규정한다. 실시예들에서, 이러한 보고는 특정한 계산적 복합 보안 기 능들을 포함한다. 일부 실시예에서, VDAX들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)은, 단일 VDAX(예를 들어, 생태계 VDAX)가 디지털 생태계(예를 들어, 커뮤니티) 결합 추적 정책들, 결합 어카운팅 정책들, 및/또는 결합 보고 정책들을 정의할 수 있도록, 고유하게 구성 및 인에이블될 수 있다. 일부 실시예에서, 단일의 결합 인스턴스 모듈 인스턴스는, 특정한 계산적 복합 게놈 기능들을 이용하여 다 중 추적 정책들, 어카운팅 정책들, 및/또는 보고 정책들을 실행할 수 있다. 실시예들에서, 마스터 결합 인스턴스 모듈은, 공통 조성(예를 들어, 생태계 VDAX)을 갖는 VDAX(예를 들어, 생태 계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)가 결합 보고 정책들에 따라 특정한 계산적 복합 게놈 기능들에 의해 인에이블된 다른 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX 및/또는 종 속 VDAX)로부터의 보안 인스턴스들을 집결할 수 있게 한다. 실시예들에서, 마스터 결합 인스턴스 모듈 인 스턴스들은, 암호 기반, 암호 없는 또는 하이브리드 기능들일 수 있는 광범위한 암호화 계산적 복합 기능들에 따라 계산될 수 있는, VDAX 게놈 특유의 보안 인스턴스들의 보안 게놈 기반의 추적, 회계, 보고 및 집계를 수행 한다. 마스터 확증 모듈(Master Corroboration Module) 본 개시내용의 일부 실시예에서, CG-ESP는 MCM(Master Corroboration Module)을 포함할 수 있다. 논의되는 바 와 같이, 마스터 확증 모듈은 원장 기반의 아키텍쳐들을 용이화하도록 구성될 수 있다. 실시예들에서, API 또는 VDAX 명시된 자료-데이터는 특정한 애플리케이션들을 갖는 광범위한 데이터를 포함할 수 있다. 이러한 데이 터는 특정한 포맷들에 따라 관리될 수 있다; 여기서는 이런 데이터를 블록이라고 한다. 이들 MDB(MDB)들은 관 련 VDAX의 게놈 관계에 따라 계산적 복합 인코딩을 수행한다. 구현들에서, VDAX 상주 MCM은 게놈적으로 인코딩 된 블록들을, 여러 게놈 커뮤니티를 반영하는 전용의, 분산된, 또는 상호작용 체인들(예컨대, 많은 VDAX를 포함 할 수 있음)로 집결시킬 수 있다. 실시예들에서, 특정한 VDAX 제어형 LNA 및 DNA에 따라 변환된 MDB들은 고도로 확장성인 상관적 고유성 (correlational uniqueness)을 보유한다. MDB 체인(MDC)들은 계산적으로 관련된 블록들의 서열(예컨대, ILB(Intra-Ledger Blockchain) 및 XLB(Inter-Ledger Blockchain))를 형성하기 위해 집결될 수 있다. MDC는 분 산 원장 기반의 블록체인 기술보다 관리하기에 훨씬 더 효율적이고 덜 복잡하다, 예를 들어, 코호트들은 복잡성 이나 효율성에 대한 실질적인 영향이 거의 또는 전혀 없이 공급망(“심층망”) 내에 깊이 확립될 수 있다. 실시예들에서, MDC들은 어떠한 형태의 분산형 원장(DL)도 생성을 요구하거나 이용하지 않는다. 일부 실시예에 서, MDC들은 어떠한 형태의 비대칭 촉진형의 합의도 요구하지 않는다. 실시예들에서, MDC들은 어떠한 형태의 대역내 또는 대역외 신뢰받는-제3자 촉진을 요구하지 않는다. 실시예들에서, MDB들은 알려진 모든 프로토콜과 포맷들을 포함할 수 있다; 이들은 프로토콜과 포맷에 구애받지 않을 수도 있다. 실시예들에서, MDB들은 상호 관심 ID를 보존하면서 동일하거나 상이한 게놈 인코딩을 가질 수 있다. 실시예들에서, 마스터 확증 모듈들은 MDB들이 전용 체인으로서 집결될 수 있게 하며, 이것은 전단 상호 관심 ID 및 게놈 상관관계를 차단한다. 실시 예들에서, 마스터 확증 모듈들은 MDB들이 상호 관심 ID를 갖는 체인들을 형성할 수 있게 하며, 이것은 여러 VDAX에 걸쳐 분산(예를 들어, 저장)되지만 게놈 상관관계를 유지한다. 실시예들에서, 마스터 확증 모듈은 MDB 들이 상이한 게놈 상관관계를 입증하지만 기능적 상호 관심 ID를 유지할 수 있다는 점에서 상호작용하는 직접 또는 분산형 체인들을 형성할 수 있게 한다. 실시예들에서, 마스터 확증 모듈들은, 암호 기반, 암호 없는 또는 하이브리드 기능들일 수 있는 광범위한 계산적 복합 기능들에 따라 계산될 수 있는 게놈 기반의 보안 MDC 생성 을 수행한다. 실시예들에서, CG-ESP는 원장내 기능(ILF)을 포함할 수 있다. 이들 실시예들 중 일부에서, 마스터 확증 모듈 (MCM; master corroboration module)들은 원장내 블록 계산(MDB; intra-ledger block computation) 및 MDB 체 인들(MDC)의 형성을 지원한다. 이들 실시예들에서, VDAX들은 운영 ILF 능력들을 가질 수 있다. 일부 실시예에 서, ILF-가능형 MDB들은 전단 상호 관심 ID 및 게놈 상관관계를 차단하는 전용 체인으로서 집결될 수 있다. 실 시예들에서, ILF 가능형 MDB들은, 여러 VDAX에 걸쳐 분산(예를 들어, 저장)되지만 게놈 상관관계를 유지하는 상 호 관심 ID를 갖는 체인들을 형성할 수 있다. 일부 실시예에서, CG-ESP는 원장간 기능(ILX; Inter-ledger Function)을 포함할 수 있다. 이들 실시예들에서, 마스터 확증 모듈은, 원장간 블록 계산(MDB) 및 MDB 체인들(MDC)의 형성을 지원할 수 있다. 이들 실시예들에서, VDAX들은 운영 ILX 능력들을 가질 수 있다. 이들 실시예에서, ILX-가능형 MDB들은 전단 상호 관 심 ID 및 게놈 상관관계를 차단하는 전용 체인으로서 집결될 수 있다. 실시예들에서, ILX-가능형 MDB들은, 여 러 VDAX에 걸쳐 분산(예를 들어, 저장)되지만 게놈 상관관계를 유지하는 상호 관심 ID를 갖는 체인들을 형성할 수 있다. 실시예들에서, ILX는, MDB들이, 상이한 게놈 상관관계를 입증하지만 기능적 상호 관심 ID를 유지할 수 있다는 점에서 상호작용하는 직접 또는 분산형 체인들을 형성할 수 있게 한다. 실시예들에서, MDC는 계산 속성 세트를 포함할 수 있다. ILB와 XLB 양쪽 모두의 엄격성은 특정한 계산적 복합 게놈 기능들에 의존한다. 일부 실시예에서, MDC는 어떠한 비대칭 계산 기반의 프로세스 또는 관련 속성도 갖지 않는다. 일부 실시예에서, MDC 가능형 체인들은, 공통 게놈 상관관계 및 분화와, 차원 VDAX(N) × VDAX를 갖는 VDAX 커뮤니티들 내에서 거부되지 않을 수 있다. 실시예들에서, MDC 계산 기반은, 계산적으로 진보된 기술들, 예컨대, 완전히 애플리케이션에 구애받지 않는 프로토콜인 양자 컴퓨팅에 대한 장기적인 보호를 보여준다. 실 시예들에서, MDC들은 어떠한 추가 대역폭 없이 계산적으로 양자 증명이 될 수 있다. 실시예들에서, ILX 가능형 MDB들은 전단 상호 관심 ID 및 게놈 상관관계를 차단하는 전용 체인으로서 집결될 수 있다. 마스터 확증 모듈, 원장 기반의 아키텍쳐, 및 MDC들은 아래에서 상세히 논의된다. 도 4는 설명의 목적을 위해 제공된 것임을 이해할 것이다. 본 개시내용의 범위를 벗어나지 않고 CG-ESP를 구성 하기 위해 추가적인 또는 대안적인 모듈들이 이용될 수 있다. 논의된 바와 같이, 상이한 CG-ESP들은 게놈 데이 터 세트들의 상이한 구성들에 관해 상이한 CG-동작들을 수행하도록 구성될 수 있다. 게놈 데이터와 관련하여 수행되는 상이한 CG 동작들 및 게놈 데이터 세트들의 예들은 아래에서 더 상세히 논의된다. 게놈 데이터 객체들 도 5는 게놈 데이터 세트들(\"디지털 DNA 세트\", \"DNA 세트\" 또는 \"DNA\"라고도 지칭됨)의 예시적인 구현들 을 나타낸다. 논의된 바와 같이, 실시예들에서, CG-ESP(예를 들어, CG-ESP)는 특정한 게놈 데이터 세트들 에 관해 동작하는 한 세트의 CG 프로세스들 및 관련 계산 방법들로 구성된다. 도 3은 상이한 CG-ESP들과 관련 하여 구현될 수 있는 상이한 유형들의 게놈 데이터의 예들을 나타낸다. 다른 유형들의 게놈 데이터가 나중에 개발될 수 있다는 것을 이해할 것이다. 실시예들에서, CG-ESP와 관련하여 사용되는 DNA 세트는, 구성가능한 엔트로피를 나타내는 하나 이상의 상 이한 유형들의 디지털적으로 생성된 수학적 객체(그 인스턴스들은, 일반적으로 \"게놈 데이터\" 또는 \"DNA 객체\" 라고 지칭될 수 있음)를 포함할 수 있다. 일부 실시예에서, DNA 세트의 디지털적으로 생성된 수학적 객체들은, 게놈 적격성 객체, 게놈 상관관계 객체, 및/또는 게놈 분화 객체의 임의의 적절한 조합을 포함 할 수 있다. 논의될 바와 같이, 상응하는 CG-ESP들의 상이한 구현들은, 상응하는 커뮤니티 소유자들의 목표들 및/또는 상응하는 플랫폼 인스턴스들이 지원하는 생태계의 유형들에 의존하여, 게놈 데이터 객체들의 상이한 조 합들, 유형들, 및 크기들을 이용하고 지원할 수 있다. 상이한 목표들의 예들은, 성능 및 효율성 목표들, 보안 목표들, 자원 할당 목표들(예를 들어, 메모리, 스토리지, 처리 능력, 네트워크 대역폭 등), 경제적 목표 등을 포함할 수 있다. 또한, 소정의 유형들의 생태계들은 상이한 제약 조건들 또는 이점들을 갖는다. 예를 들어, 소정의 제어 생태계들(예를 들어, 일부 실행가능한 생태계들)은 소정의 코호트들(예를 들어, 애플리케이션들, 센서들, 디바이스 드라이버들, 프로세서들, 메모리 디바이스들 등의 종속 코호트들)이 매우 제한된 수의 관계들 을 (예를 들어, 링크들을 통해) 확립할 것을 요구할 수 있다. 이들 시나리오들에서, 생태계 내의 각각의 상응 하는 관계에 대한 링크들은, 각각의 VDAX가 필요한 임의의 및 모든 링크에 액세스할 수 있도록, 생태계가 생성 될 때 생성될 수 있다. 이들 시나리오들에서, DNA 세트는, 이러한 생태계에 대한 DNA 세트들이 게놈 적격성 객 체 또는 게놈 상관관계 객체 없이 구성될 수 있지만 게놈 분화 객체를 포함할 수 있도록, 소정 의 유형들의 DNA 객체들을 갖는 것으로부터 어떠한 추가적인 이점도 이끌어 내지 못할 수도 있다. 또 다른 예 시적인 시나리오에서, 결합 적격성 결정, 링크 교환, 및/또는 분화/VBLS 생성 중 2개 이상의 구현들은, (예를 들어, 결합 적격성 검증, 링크 교환, 및 VBLS 결정에 이용되는 상응하는 쌍의 VDAX들의 상응하는 DNA 객체의 고 유한 교차를 통해) 단일 DNA 객체를 이용하여 수행될 수 있다. 이 예에서, 커뮤니티 소유자는, 이질적인 유형 들의 게놈 데이터 객체들을 저장하는 것과 연관된 저장 요건들을 감소시키기 위해 추가적인 보안 조치들을 희생 하기를 원할 수도 있다. 다른 시나리오들에서, 커뮤니티 소유자는, 선택된 데이터 구조의 유형 및/또는 데이터 구조의 크기에 기초하여 DNA 세트 내의 각각의 유형의 DNA 객체에 나타내는 엔트로피의 양을 제어할 수 있다. 예를 들어, 512 x 512-비트 2원 벡터들 또는 비트 행렬들로서 구현되는 게놈 분화 객체는 양자 증명 레벨 들의 보안을 제공할 수 있다. 본 개시내용의 실시예들에서, 게놈 적격성 객체들은, 2개의 코호트들 사이의 \"신뢰 없는\" 인증 프로세스의 일부에서 수행될 수 있는, 한 쌍의 코호트들이 결합 적격성을 확정하는 것을 허용하는 디지털적으로 생성된 수 학적 객체들을 지칭할 수 있다. 실시예들에서, 선조 VDAX(예를 들어, 생태계 VDAX 또는 엔클레이브 VDAX)는, 그 게놈 적격성 객체(\"선조 게놈 적격성 객체\")에 기초하여 상응하는 디지털 생태계에 합류할 자손 VDAX들에 대 한 자손 게놈 적격성 객체들을 도출할 수 있다. 이들 실시예들에서, 각각의 자손 VDAX는 선조 게놈 적격 성 객체의 고유하지만 상관된 도출을 수신할 수 있다. 또한, 일부 구현에서, 생태계의 모든 게놈 적격성 객체 들은, 생태계의 임의의 멤버가 그들의 상관된 게놈 적격성 객체들(예를 들어, 선조 게놈 적격성 객체의 교차하 는 또는 공유된 부분들)에 기초하여 다른 생태계 멤버들과의 어떤 관계를 확정할 수 있도록, 선조 게놈 적격성 객체로부터 도출될 수 있다. 특정한 커뮤니티에 대한 게놈 적격성 객체가 할당되면, 자손 VDAX는 그 게놈 적격성 객체를 수신할 수 있다. 일부 실시예에서, 자손 VDAX는, 1회의 신뢰할 수 있는 이벤트를 통해 그 게놈 데이터 세트에서 게놈 그 적격성 객체를 수신할 수 있다(예를 들어, 특정한 엔클레이브에 대한 허용시, 디바이 스가 제조, 구성 또는 판매될 때 등). 그들의 상응하는 게놈 적격성 객체들을 수신한 후, VDAX들은 그들 의 상응하는 게놈 적격성 객체를 이용하여 그들의 엔클레이브 및/또는 생태계 내의 하나의 다른 VDAX와의 결합 적격성을 독립적으로 확정할 수 있다. 실시예들에서, 특정한 CG 지원형 디지털 생태계에 대한 게놈 적격 성 객체들은, CNA 객체들, PNA 객체들, 및/또는 2개의 커뮤니티 멤버들이 결합 적격성 및/또는 결합 무결성을 확정하는 것을 허용하는 다른 적절한 수학적 조성들로부터 선택될 수 있다. 실시예들에서, CNA는, 또 다른 VDAX가 동일한 생태계 커뮤니티의 일부임을 한 VDAX가 고유하게 결정하는 것을 허용하는 게놈 수학적 조성들을 지칭할 수 있다. 실시예들에서, 이 생태계 상관관계는 계산적 양자 증거가 될 수 있다. 실시예들에서, VDAX-수행형 생태계 상관관계는, 중앙 기관(예를 들어, 신뢰할 수 있는 제3자)과의 임 의의 형태의 협의없이 수행될 수 있는, 일반적인 계산적 복합 게놈 기능들에 기초한다. 이들 상관관계 속성들은, 수년 간격으로 활성화된 동일한 생태계 내의 2개의 VDAX는, 서로에 대한 어떠한 사전지식 없이 및 신뢰할 수 있는 제3자와의 어떠한 협의없이 그들의 생태계 상태를 확정할 수 있게 한다. 실시예들에서, CNA 객체들은, 2원 벡터들, 2원 행렬들 등으로서 구현될 수 있다. 실시예들에서, CNA 객체 들은 특정한 엔트로피를 나타내도록 구성된다. 일부 실시예에서, 생태계의 CNA의 엔트로피는 제어가능한 엔트로피이며, 이에 의해 엔트로피는 예를 들어 커뮤니티 소유자에 의해 구성될 수 있다. 일부 구현에서, CNA 객체의 구성가능한 레벨의 엔트로피는, 실질적으로 양자-증거 레벨의 엔트로피일 수 있다. 예를 들어, 실 질적으로 양자-증거 CNA 객체들은 256-비트 엔트로피 이상의 엔트로피 레벨을 나타내도록 구성될 수 있다. 예 를 들어, 일부 실시예에서, 이들 엔트로피 레벨들은 512 x 512-비트 2원 벡터 또는 2원 행렬로서 구현된 CNA 객 체들에 의해 달성될 수 있다. 양자-증거 CNA 객체들은 일부 예시적인 구현에서 더 적은 엔트로피를 나타 낼 수 있다는 것을 이해할 것이다. (예를 들어, 커뮤니티 소유자 또는 보안 플랫폼을 구성하는 임의의 다른 당 사자에 의해 결정된) 더 적은 엔트로피를 나타내는 CNA 객체들이 이용될 수 있다는 것을 이해할 것이다. 예를 들어, 커뮤니티 소유자는 관할 규정들을 준수하기를 원할 수 있으므로, 전체 보안을 희생하지만 저장 및 처리 요구사항들이 적은, 더 낮은 레벨들의 엔트로피를 나타내는 CNA 객체들(또는 다른 게놈 데이터 세트들)을 이용할 수 있다. 실시예들에서, CNA는, 한 세트의 게놈 프로세스들 및 관련 계산 방법들을 이용하여 개개 의 생태계 멤버들 사이의 특정한 관계들을 확립하고 결합에 대한 적격성을 확정하도록 구성될 수 있다. 실시예들에서, 게놈 적격성-상관관계 응용들을 위한 CNA 생성은 특정한 2원 벡터들로서 조직화될 수 있는 대규 모 세트들의 무작위 데이터를 생성한다. 일부 실시예에서, 게놈 적격성-상관관계 응용들을 위한 CNA 생성은 제 어가능한 엔트로피를 갖는 고품질 랜덤 프로세스들에 의해 가능케될 수 있다. 실시예들에서, 게놈 적격성-상관 관계 응용들을 위한 CNA 생성은 제어가능한 엔트로피를 갖는 특정한 수학적 기초에 따라 가능케될 수 있다. 실 시예들에서, CNA는 광범위한 정보 이론 지원형의 복합 기능들에 따라 생성될 수 있다. 실시예들에서, 이들 정 보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. CNA 객 체들을 생성하고, 결합에 대한 적격성을 확정하기 위한 예시적인 기술들은 본 개시내용 전체에 걸쳐 더 상세히 논의된다. 실시예들에서, PNA는 또 다른 VDAX가 동일한 생태계 커뮤니티의 일부임을 한 VDAX가 고유하게 결정하는 것을 허 용하는 디지털이라고 지칭될 수 있다. 실시예들에서, 이 생태계 상관관계는 계산적 양자 증거가 될 수 있다. 실시예들에서, VDAX-수행형 생태계 상관관계는, 중앙 기관(예를 들어, 신뢰할 수 있는 제3자)과의 임의의 형태 의 협의없이 수행될 수 있는, 일반적인 계산적 복합 게놈 기능들에 기초한다. 이들 상관관계 속성들은, 수년 간격으로 활성화된 동일한 생태계 내의 2개의 VDAX는, 서로에 대한 어떠한 사전지식 없이 및 신뢰할 수 있는 제 3자와의 어떠한 협의없이 그들의 생태계 상태를 확정할 수 있게 한다. 실시예들에서, PNA 객체들은 한 세트의 2진 원시 다항식들뿐만 아니라 적격성 동기화 동안 이용되는 기타 의 데이터를 포함할 수 있다. 실시예들에서, PNA 객체들은 특정한 엔트로피를 나타내도록 구성된다. 일 부 실시예에서, 생태계의 PNA 객체들의 엔트로피는 제어가능한 엔트로피이며, 이에 의해 엔트로피는 예를 들어 커뮤니티 소유자에 의해 구성될 수 있다. 일부 구현에서, PNA 객체의 구성가능한 레벨의 엔트로피는, 실질적으로 양자-증거 레벨의 엔트로피일 수 있다. 예를 들어, 실질적으로 양자-증거 PNA 객체들 은 256비트 엔트로피 이상의 엔트로피 레벨을 나타내도록 구성될 수 있다. 예를 들어, 일부 실시예에서, 이러한 엔트로피 레벨들은 2개의 상이한 세트들(예를 들어, 2048 x 2048 비트 2진 행렬을 나타내는 제1 벡터, 및 차수 256의 216개의 무작위로 선택된 2진 원시 다항식 세트를 나타내는 제2 벡터)로서 구현된 PNA 객체들에 의해 달성될 수 있다. 양자-증거 PNA 객체들은 일부 예시적인 구현에서 더 적은 엔트로피를 나타낼 수 있 다는 것을 이해할 것이다. (예를 들어 커뮤니티 소유자 또는 보안 플랫폼을 구성하는 임의의 다른 당사자에 의 해 결정된) 더 적은 엔트로피를 갖는 PNA 객체들이 이용될 수 있다는 것을 이해할 것이다. 예를 들어, 커 뮤니티 소유자는 관할 규정들을 준수하기를 원할 수 있으므로, 전체 보안을 희생하지만 저장 및 처리 요구사항 들이 적은, 더 낮은 레벨들의 엔트로피를 나타내는 PNA 객체들(또는 다른 게놈 데이터 세트들)을 이용할 수 있 다. 실시예들에서, PNA는, 한 세트의 게놈 프로세스들 및 관련 계산 방법들을 이용하여 개개의 생태계 멤버들 사이의 특정한 관계들을 확립하고 결합에 대한 적격성을 확정하도록 구성될 수 있다. 실시예들에서, 게놈 적격성-동기화 응용들을 위한 PNA 생성은 특정한 2원 벡터들로서 조직화될 수 있는 대규모 세트들의 무작위 데이터를 생성한다. 일부 실시예에서, 게놈 적격성-상관관계 응용들을 위한 PNA 생성은 제어 가능한 엔트로피를 갖는 고품질 랜덤 프로세스들에 의해 가능케될 수 있다. 실시예들에서, 게놈 적격성-적격성 -동기화 응용들을 위한 PNA 생성은 제어가능한 엔트로피를 갖는 특정한 수학적 기초에 따라 가능케될 수 있다.PNA 객체들을 생성하고, 결합에 대한 적격성을 확정하기 위한 예시적인 기술들은 본 개시내용 전체에 걸쳐 더 상세히 논의된다. 실시예들에서, 게놈 상관관계 객체는 VDAX들이 서로 상관관계를 확립할 수 있게 하는 디지털적으로 생성된 수학적 객체들을 지칭할 수 있다. 실시예들에서, 게놈 상관관계 객체들은 VDAX들 사이의 링크 교환을 가능케하 고, 이에 의해 제1 VDAX는 제2 VDAX에 제공되고 제2 VDAX에 의해 호스팅되는 링크(\"링크\"라고도 함)를 스폰할 수 있으며, 이에 의해 링크는, 제2 VDAX가 제1 코호트만이 디코딩할 수 있는 VBLS를 생성하는데 이용하는 명령 어들을 제공한다(링크가 제2 VDAX에 의해 안전하게 유지된다고 가정). 실시예들에서, 링크 교환 상관관계를 확 정하기 위해 CG-ESP에서 이용되는 게놈 상관관계 객체들은 2개의 생태계 컴포넌트(예를 들어, 엔클레이브 VDAX, 코호트 VDAX 등)가 특정한 관계를 확립하고 서로 결합하는 것을 허용한다. CG-ESP의 예시적인 구현들에서, 디지털 생태계의 커뮤니티 멤버들의 게놈 상관관계 객체들은 LNA 객체들 로서 구현된다. 일부 실시예에서, LNA는 게놈 상관관계 기능들이 의존하는 핵심 역량이다. 실시예들에서, LNA는 VDAX들이 서로 상관관계를 확립하는 기초를 형성한다. LNA 객체들이 나타내는 엔트 로피는 상관관계의 품질 측면에서 중요하다. 비반복적 상관관계 속성들은 특정한 계산적 복합 게놈 기능들로부 터 도출될 수 있다. CG-ESP의 일부 구현에서, LNA는 대규모 세트들의 랜덤 데이터에서 게놈 상관관계 응용들을 위해 (예를 들어, 생태계 VDAX에 의해) 생성될 수 있다. 일부 실시예에서, LNA 객체들은 2원 벡터들, 비 트 행렬들, 또는 다른 적절한 구조들로서 구현된다. 실시예들에서, LNA 객체들은, LNA 객체가 나타내는 엔트로피의 레벨이 전체 상관관계 정도의 인자일 수 있도록 구성가능한 엔트로피를 나타내도록 구성된다. 실시 예들에서, LNA 생성은 제어가능한 엔트로피를 갖는 고품질 랜덤 프로세스들에 의해 수행될 수 있다. 일부 실시 예에서, 게놈 상관관계 응용들을 위한 LNA 생성은 제어가능한 엔트로피를 갖는 특정한 수학적 기초에 의해 인에 이블될 수 있다. 실시예들에서, LNA는 광범위한 정보 이론 지원형의 복합 기능들에 따라 생성될 수 있다. 실 시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들 일 수 있다. 실시예들에서, 한 쌍의 VDAX들은 그들의 공통 LNA들에 기초하여 쌍대칭 링크 교환 및/또는 단방향 링크 교환에 관여할 수 있다(예를 들어, 양쪽 모두의 VDAX들이 동일한 선조로부터 상응하는 LNA를 할당받았다). 실시예들에 서, 제1 VDAX는 그 LNA 객체를 수정할 수 있고, 제2 코호트가 맵핑된 GRI를 디코딩할 수 있는 유일한 다른 VDAX 이도록, 수정된 LNA에 기초하여 게놈 조절 명령어들(\"GRI\")을 인코딩할 수 있다. 실시예들에서, GRI는 데이터 (예를 들어, 하나 이상의 값) 및 데이터 교환을 위한 VDAX 쌍을 분화하기 위해 데이터가 이용되는 방식을 나타 내는 명령어들을 포함할 수 있다. 실시예들에서, GRI는, GRI에 포함된 데이터가 분화 값에 기초하여 게놈 분화 객체를 수정하는 정보 이론 지원형의 계산적 복합 기능에 대한 입력 파라미터로서 이용되는 분화 값(예를 들어, 2원 벡터로 구현됨)을 포함할 수 있도록, 분화 객체를 수정하는데 이용될 수 있다. 일부 실시예에서, GRI는 서 열 맵핑 프로세스 동안 이용되는 서열 수정 값을 포함할 수 있다. 이들 실시예들에서, 서열 맵핑 프로세스는, 중간 값과 수정된 분화 객체가 원래의 서열에 대응하는 게놈 결합 값을 출력하는 정보 이론 지원형의 계산적 복 합 기능에 대한 입력 값들로서 이용되도록, 분화 값에 기초하여 서열을 중간 값으로 수정하는 정보 이론 지원형 의 계산적 복합 기능에 대한 입력 파라미터로서 이용될 수 있다. 수정된 LNA에 기초한 게놈 조절 명령어들을 인코딩하는 것은 중간 동작들을 포함할 수 있다는 것을 이해할 것이다. 예를 들어, CG-ESP의 일부 구현에서, VDAX는, 맵핑 서열을 결정하고, 계산적 복합 기능을 이용하여 맵핑 서열을 수정된 LNA에 맵핑하고, 게놈 결합 인자에 기초하여 GRI를 인코딩하도록 구성될 수 있다. 이들 예시적 인 구현들에서, VDAX는, 다른 VDAX가 고도로 상관된 LNA를 소유하는 경우 다른 VDAX가 인코딩된 GRI를 성공적으 로 디코딩할 수 있도록, 다른 VDAX로의 링크를 제공할 수 있다. CG-ESP의 일부 구현에서, VDAX들의 LNA 객체들 은, 그들이 동일하거나 그렇지 않으면 충분히 상관되는 경우 고도로 상관될 수 있다. 일부 실시예에서, 링크 교환은, 코호트들 중 하나가 GRI를 수정하기 위해 그 상응하는 링크를 명시적으로 업데이트하지 않는 한, 링크 교환이 한 쌍의 코호트들 사이에서 한 번만 수행되도록, 일회성 프로세스이다. 이러한 액션 외에, 한 쌍의 코 호트들은, 상응하는 VDAX들의 LNA 객체들이 예를 들어, 성공적인 링크 교환 후 선조 VDAX의 명령어에 의해 또는 명령시에 변이(예를 들어, 지속적으로 수정)되는 일부 시나리오에서도 각각의 코호트에 의해 생성된 상응하는 링크들에 기초하여 데이터를 계속 교환할 수 있다. LNA 객체들을 생성하고, LNA 객체들을 수정하고, LNA 객체들을 이용하여 링크 교환을 수행하기 위한 기술들을 포함한, LNA 객체들을 수반하는 게놈 동 작들의 예들은 본 개시내용 전체에 걸쳐 더 상세히 논의된다. 본 개시내용의 실시예들에서, 게놈 분화 객체들은, 커뮤니티 멤버 쌍이 링크들을 성공적으로 교환했고 충 분히 상관된 게놈 분화 객체들을 가지고 있는 경우 커뮤니티 멤버 쌍(예를 들어, 코호트들)이 커뮤니티 멤버 쌍에 의해 생성된 VBLS를 교환 및 디코딩하는 것을 허용하는 디지털적으로 생성된 수학적 객체들을 지칭할 수 있 다. 일부 실시예에서, 제1 VDAX는, 부분적으로, 제2 VDAX로부터의 링크에서 제1 VDAX에 제공된 게놈 조절 명령 어들(GRI)에 정의된 방식으로 그 게놈 분화 객체를 수정함으로써 제2 VDAX에 대한 VBLS를 생성하고, 부분 적으로, 제2 코호트에 제공된 GRI에 따라 게놈 분화 객체를 부분적으로 수정함으로써 제2 코호트로부터의 VBLS를 디코딩한다. CG-ESP의 실시예들에서, 제1 VDAX는 계산적 복합 기능(예를 들어, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들)을 이용하여 수정된 XNA 객체에 서열(예를 들어, 사적 또는 공개 서 열)을 맵핑하여 디지털 객체를 인코딩하는데 이용할 수 있는 게놈 결합 인자를 획득할 수 있다. 게놈 분화 객 체들의 예들은, XNA 객체들 및 ZNA 객체들을 포함할 수 있지만 이들로 제한되는 것은 아니다. 예시적인 구현들에서, 디지털 생태계의 커뮤니티 멤버들의 게놈 분화 객체들은 XNA이다. 일부 실시예에서, XNA는 모든 게놈 차이들이 의존하는 핵심 역량이다. 이들 실시예들에서, XNA는 VDAX들이 고유한 비반복적 결합을 제어하기 위해 이용하는 쌍대칭 언어들(예를 들어, VBLS)의 기초를 형성한다. 일부 실시예에 서, 고유한 비반복적 결합은 양자-증거(quantum-proof)일 수 있다. 실시예들에서, XNA가 나타내는 엔트로피는 VBLS의 보안 측면에서 중요할 수 있으며, 여기서 더 높은 엔트로피는 더 높은 레벨들의 보안을 제공한다. 실시 예들에서, 반복적 차이 속성들은 특정한 계산적 복합 게놈 기능들로부터 도출된다. 실시예들에서, 게놈 분화 응용들을 위한 XNA 생성은, 특정한 2원 벡터들로서 조직화될 수 있는 대규모 세트들의 무작위 데이터를 생성한 다. 실시예들에서, 게놈 분화 응용들을 위한 XNA 생성은 제어가능한 엔트로피를 갖는 고품질 랜덤 프로세스들 에 의해 수행될 수 있다. 일부 실시예에서, 게놈 분화 응용들을 위한 XNA 생성은 제어가능한 엔트로피를 갖는 특정한 수학적 기초에 의해 인에이블될 수 있다. 실시예들에서, XNA는 광범위한 정보 이론 지원형의 복합 기능 들에 따라 생성될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 일부 실시예에서, XNA 객체는 구성가능한 엔트로피를 나타내는 2원 벡터, 행렬 등으로서 구현될 수 있다. 일부 실시예에서, XNA 객체가 나타내는 엔트로피는 커뮤니티 멤버에 의해 생성된 VBLS의 보안을 결정한다. 실시예들에서, 선조 VDAX로부터의 상응하는 커뮤니티 멤버들(예를 들어, 엔클레이브 멤버들)에 할당된 XNA는 동 일하거나 및/또는 그렇지 않으면 충분히 상관된다. 일부 실시예에서, 제2 VDAX에 대한 VBLS를 생성하는 제1 VDAX는, 링크에서 제2 VDAX에 의해 제공되는 GRI에 따라 그 XNA 객체를 수정한다. 그 다음, 제1 VDAX는 제2 VDAX에 의해 결정가능한 서열(예를 들어, 공개 또는 사적 서열)을 수정된 XNA 객체에 맵핑하여 게놈 결합 인자를 획득할 수 있다. 그 다음, 디지털 객체(예를 들어, 프로세서 명령어, 패킷 페이로드, 디스크 섹터 등)는 암호 기반의 암호화 또는 명료화 및 게놈 결합 인자를 이용하여 인코딩되어 VBLS 객체에 포함된 인코딩된 디지털 객체를 획득할 수 있다. 실시예들에서, VBLS 객체는 게놈 결합 인자를 생성하는데 이용된 서열 등의 메 타데이터를 더 포함할 수 있다. 그 다음, VBLS 결과 인코딩된 디지털 객체는 제2 코호트에 제공될 수 있다. 이들 예시적인 구현들에서, 제2 코호트는 VBLS 객체를 수신하고 제2 VDAX에 의해(또는 대신하여) 제1 VDAX에 제 공된 링크에 포함된 GRI에 따라 그 XNA를 수정한 다음 서열을 수정된 XNA에 맵핑하여 게놈 결합 인자를 재 생성한다. 그 다음, 게놈 결합 인자는, 디지털 객체를 인코딩하는데 이용된 암호 기반의 해독 또는 명료화를 이용하여 디코딩된 디지털 객체를 획득하기 위해 인코딩된 디지털 객체를 디코딩하는데 이용될 수 있다. 이들 예시적인 구현들에서, VDAX들이 동일한 GRI를 이용하여 그들의 상응하는 XNA 객체들을 수정하고 결정론적 방식으로 게놈 결합 인자를 결정하는 능력은, 제1 코호트가 데이터 객체를 제2 VDAX에 안전하게 제공하고 데이 터 교환의 각각의 인스턴스(예를 들어, 모든 패킷, 모든 섹터, 모든 샤드, 모든 프레임 등)에 대해 게놈 결합 인자를 잠재적으로 변화시키는 것을 허용한다. 이러한 방식으로, VBLS는 양자 증명 레벨들의 보안을 제공할 수 있다. 전술한 논의는 XNA 또는 기타의 게놈 분화 객체들이 보안 데이터 교환 프로세스에서 어떻게 활용될 수 있는지의 한 예라는 점에 유의한다. 일부 실시예에서, 커뮤니티(예를 들어, 엔클레이브)로부터의 커뮤니티 멤버(예를 들어, 코호트)의 철회는, 선조 VDAX에 의해 커뮤니티 내의 커뮤니티 멤버들 중 일부의 XNA 객체들을 선택적으로 변이시킴으로써 달성될 수 있 다. XNA 객체를 \"변이\"시키는 것은 그 XNA 객체를 지속적으로 수정하기 위해 자손 VDAX에 명령어들을 제공하거 나 자손 VDAX에 새로운 XNA 객체를 제공하는 것을 지칭할 수 있다는 점에 유의한다. 이러한 방식으로 변이된 XNA는 특정한 커뮤니티에 관한 후속 VBLS 코딩 및 인코딩에 이용된다. 예를 들어, 일부 예시적인 구현에서, 생 태계 VDAX는 엔클레이브에 남아 있어야 하는 코호트들만의 XNA를 변이시킬 수 있다. 이러한 방식으로, 엔클레 이브로부터 철회된 코호트들은 여전히 코호트들과의 결합을 시도할 수 있지만 변이된 XNA 객체를 갖는 코호트들 에 대한 VBLS를 생성하거나 이들로부터의 VBLS를 디코딩할 수 없다. 커뮤니티 소유자(예를 들어, 생태계 및/또 는 생태계의 엔클레이브와 연관된 네트워크 관리자)가 코호트를 복원하기로 선택한 경우, 엔클레이브 VDAX는, 코호트가 이전에 확립된 링크들 및/또는 미래에 확립된 링크들을 이용하여 엔클레이브 내의 다른 코호트들과의데이터 교환을 시작할 수 있도록, 그 XNA가 이전에 변이된 다른 커뮤니티 멤버들과의 충분히 상관된 XNA를 갖도 록 코호트의 XNA를 변이시킬 수 있다. 예시적인 구현들에서, 디지털 생태계의 커뮤니티 멤버들의 게놈 분화 객체들은 ZNA이다. 일부 실시예에서, ZNA는 모든 실행가능한 분리 컴포넌트 게놈 차이들이 의존하는 핵심 역량이다. 이들 실시예들에서, ZNA는 고유하고 비반복적(잠재적으로 양자 증거) 실행가능한 바이너리들이 제어되는 기초를 형성 한다. EIC 반복적 변환들은 특정한 계산적 복합 게놈 기능들로부터 도출될 수 있다. 실시예들에서, 게놈 분화 응용들을 위한 ZNA 생성은, 특정한 2원 벡터들로서 조직화될 수 있는 대규모 세트들의 무작위 데이터를 생성한 다. 실시예들에서, 게놈 분화 응용들을 위한 ZNA 생성은 제어가능한 엔트로피를 갖는 고품질 랜덤 프로세스들 에 의해 수행될 수 있다. 일부 실시예에서, 게놈 분화 응용들을 위한 ZNA 생성은 제어가능한 엔트로피를 갖는 특정한 수학적 기초에 의해 인에이블될 수 있다. 실시예들에서, ZNA는 광범위한 정보 이론 지원형의 복합 기능 들에 따라 생성될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 일부 실시예에서, ZNA 객체는, 2원 벡터, 행렬 등으로서 구현될 수 있고, 이에 의해 ZNA 객체들은 구 성가능한 엔트로피를 나타낸다. 일부 실시예에서, ZNA는 구조적으로 XNA와 유사할 수 있지만 실행가능한 생태 계들에서 이용된다. 실시예들에서, ZNA는 실행가능한 생태계의 컴포넌트들 사이에서 교환되는 VBLS를 생성하는 데 이용될 수 있다. 일부 실시예에서, ZNA 객체가 나타내는 엔트로피는 커뮤니티 멤버에 의해 생성된 VBLS의 보안을 결정한다. 실시예들에서, 선조 VDAX로부터의 상응하는 커뮤니티 멤버들(예를 들어, 디바이스 컴 포넌트들)에 할당된 ZNA는 동일하거나 및/또는 그렇지 않으면 충분히 상관된다. 일부 실시예에서, 제2 VDAX(예 를 들어, 제2 EIC)에 대한 VBLS를 생성하는 제1 VDAX(예를 들어, 제1 EIC)는, 링크에서 제2 VDAX에 의해 제공된 GRI에 따라 그 ZNA 객체를 수정한다. 그 다음, 제1 VDAX는 제2 VDAX에 의해 결정가능한 서열(예를 들어, 공개 또는 사적 서열)을 수정된 ZNA 객체에 맵핑하여 게놈 결합 인자를 획득할 수 있다. 그 다음, 디지털 객체(예를 들어, 프로세서 명령어, 디스크 섹터 등)는 VBLS 객체에 포함된 인코딩된 디지털 객체를 획득하기 위 해 복합 기능 및 게놈 결합 인자를 이용하여 인코딩될 수 있다. 실시예들에서, VBLS 객체는 게놈 결합 인자를 생성하는데 이용된 서열 등의 메타데이터를 더 포함할 수 있다. 그 다음, VBLS 결과적 인코딩된 디지털 객체는 제2 VDAX에 제공될 수 있다. 이들 예시적인 구현들에서, 제2 VDAX는 VBLS 객체를 수신하고 제2 VDAX를 대신하 여 제1 VDAX에 제공된 링크에 포함된 GRI에 따라 그 ZNA 객체를 수정하고 서열을 수정된 ZNA 객체에 맵핑하여 게놈 결합 인자를 재생성한다. 그 다음, 게놈 결합 인자는 디지털 객체를 인코딩하는데 이용된 양방 향 기능의 역을 이용하여 디코딩된 디지털 객체를 획득하기 위해 인코딩된 디지털 객체를 디코딩하는데 이용될 수 있다. 이들 예시적인 구현들에서, VDAX들이 동일한 GRI를 이용하여 그들의 상응하는 ZNA 객체들을 수 정하고 결정론적 방식으로 게놈 결합 인자를 결정하는 능력은, 제1 코호트가 데이터 객체를 제2 VDAX에 안전하 게 제공하고 데이터 교환의 각각의 인스턴스(예를 들어, 모든 패킷, 모든 섹터, 모든 샤드(shard), 모든 프레임 등)에 대해 게놈 결합 인자를 잠재적으로 변화시키는 것을 허용한다. 이러한 방식으로, VBLS는 양자 증명 레벨 들의 보안을 제공할 수 있다. 전술한 논의는 ZNA 또는 기타의 게놈 분화 객체들이 보안 데이터 교환 프로세스 에서 어떻게 활용될 수 있는지의 한 예라는 점에 유의한다. 본 개시내용으로부터 이해할 수 있는 바와 같이, 핵심 게놈 역량들(예를 들어, CG-ESP 프로세스들을 지원하는 분화 및 상관)은, 특정한 게놈(예를 들어, LNA, XNA, ZNA, CNA 및/또는 PNA의 일부 조합을 포함할 수 있는 디지 털 DNA)의 생성(예를 들어, LNA 생성, XNA 생성, ZNA 생성, CNA 생성 및/또는 PNA 생성을 포함할 수 있는 DNA 생성), 수정(예를 들어, LNA 수정, XNA 수정, ZNA 수정, CNA 수정, 및/또는 PNA 수정을 포함할 수 있는 DNA 수 정), 및 할당(예를 들어, LNA 할당, XNA 할당, ZNA 할당, CNA 할당 및/또는 PNA 할당)을 포함할 수 있는 DNA 할당)에 의존할 수 있다. 실시예들에서, 이들 응용 특유의 DNA 조성들(예를 들어, LNA, XNA, CNA, PNA, 및/또 는 ZNA의 일부 조합)은 특유의 변환들을 가지며 분화의 제어가능한 가상화에 중요하다. 실시예들에서, 생태계 선조(예를 들어, 생태계 VDAX)는 생태계 멤버들의 일부 또는 모두의 게놈 데이터를 변이시킬(예를 들어, 지속적으로 수정할) 수 있다. 실시예들에서, 게놈 데이터의 변이는 게놈 데이터 객 체의 지속적인 수정 또는 업데이트를 지칭할 수 있다. 예를 들어, 실시예들에서, 생태계는, VDAX들이 이전의 게놈 데이터 대신에 변이된 게놈 데이터를 이용하도록, 생태계 멤버의 일부 또는 전부의 LNA 객체들, XNA 객체들, CNA 객체들, 및/또는 PNA 객체들을 변이시킬 수 있다. \"변이\"라는 용어는, 일시적인 수정일 수 있는 링크 교환 또는 VBLS 생성 동안의 수정과 대조적으로, 지속적인 DNA 객체들에 대한 수정을 지칭하는데 사용될 수 있다는 점에 유의한다. 그러나, 수정 및 변이는 DNA 조성과 유사한 효과들을 가질 수 있 으며, 정황상 암시하는 경우 \"수정\"이라는 용어는 지속적인 수정과 관련하여 이용될 수 있다는 점에 유의한다.실시예들에서, 커뮤니티 멤버들의 LNA 객체들은 (예를 들어, 링크 교환을 위해) 수정 및 변이(예를 들어, 지속 적으로 수정/업데이트)될 수 있다. 논의된 바와 같이, 비반복적 상관관계 객체들(예를 들어, LNA)은, 특정한 계산적 복합 게놈 기능들로부터 도출될 수 있고, 이 상관관계는, 다양한 엔클레이브 관계들 N x Ma를 갖는 VDAX 들로 구성된 차원 N x M을 갖는 디지털 생태계들을 포함할 수 있다. 이러한 디지털 생태계 관계들은 미래의 또 는 추가의 생태계 관계들의 확립을 방지하기 위해 그들의 상관관계 속성들의 수정을 요구할 수 있다. LNA의 변 이는 상관관계 속성들의 특정한 (넓고 좁은) 재결정을 가능케한다. 실시예들에서, LNA 게놈 조성들은, 조성들 이 수정가능한, 특정한 디지털 생태계 조직들에 맞게 조정될 수 있다. 일부 실시예에서, LNA 랜덤 벡터들은 특 정한 명령어들에 기초하여 균일하게 또는 신중하게(넓게 및 좁게) 수정될 수 있다. LNA 수정들은 LNA 조성의 게놈 무결성과 그 상관관계 속성들을 보존한다. 실시예들에서, 수정된 LNA를 소유한 VDAX들은 미수정된 LNA를 소유한 VDAX들과의 미래의 상관관계에 영향을 미칠 수 없다. 실시예들에서, LNA는 광범위한 정보 이론 지원형 의 암호 계산적 복합 기능들에 따라 게놈적으로 수정될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능 들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 실시예들에서, 커뮤니티 멤버들의 XNA는 변이될 수 있다(예를 들어, 지속적으로 수정/업데이트될 수 있다). 논 의된 바와 같이, 비반복적 분화 객체들(예를 들어, XNA)은, 특정한 계산적 복합 게놈 기능들로부터 도출될 수 있고, 이 분화는, 다양한 엔클레이브 관계들 N x Ma를 갖는 VDAX들로 구성된 차원 N x M을 갖는 디지털 생태계 들을 포함할 수 있다. 이들 디지털 생태계 관계들은 보안 관리(예를 들어, 관계 철회)에서 가장 어려운 문제들 중 하나인 분화 속성들의 수정을 요구할 수 있다. XNA의 변이는 분화 속성들의 특정한 (넓고 좁은) 재결정을 가능케하여, 관계 철회 문제를 효율적으로 해결한다. 실시예들에서, XNA 게놈 조성들은, 조성들이 수정가능한, 특정한 디지털 생태계 조직들에 맞게 조정될 수 있다. 일부 실시예에서, XNA 랜덤 벡터들은 특정한 명령어들에 기초하여 균일하게 또는 신중하게(넓게 및 좁게) 수정될 수 있다. XNA 수정들은 XNA 조성의 게놈 무결성과 그 상관관계 속성들을 보존한다. 실시예들에서, 변이된 XNA를 소유한 VDAX들은 변이되지 않은 XNA를 소유한 VDAX 와의 미래의 분화에 영향을 미칠 수 없다. 실시예들에서, XNA는 광범위한 정보 이론 지원형의 암호 계산적 복 합 기능들에 따라 게놈적으로 변이될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 실시예들에서, 커뮤니티 멤버들의 CNA 객체들은 변이될 수 있다(예를 들어, 지속적으로 수정/업데이트될 수 있다). 논의된 바와 같이, 비반복적 적격성 객체들(예를 들어, CNA 또는 PNA)은, 특정한 계산적 복합 게놈 기능들로부터 도출될 수 있고, 이 수정은, 다양한 엔클레이브 관계들 N x Ma를 갖는 VDAX들로 구성된 차원 N x M을 갖는 디지털 생태계들을 포함할 수 있다. 이들 디지털 생태계 관계들은 보안 관리(예를 들어, 관계 철회) 에서 가장 어려운 문제들 중 하나인 분화 속성들의 수정을 요구할 수 있다. VDAX 생태계 적격성 객체들의 수정 은 일반적인 계산적 복합 게놈 기능들을 보존한다. 이들 디지털 생태계 관계들은 그들의 적격성 객체들의 수정 을 요구하여, VDAX들이 미래의 또는 추가적인 생태계 관계들을 확립하는 것을 방지할 수 있다. CNA 또는 PNA의 변이는 적격성 객체들의 구체적인 (넓고 좁은) 재결정을 가능케한다. 실시예들에서, CNA 게놈 조성들은, 조성들이 수정가능한, 특정한 디지털 생태계 조직들에 맞게 조정될 수 있다. 일부 실시예에서, CNA 랜덤 벡터들은 특정한 명령어들에 기초하여 균일하게 또는 신중하게(넓게 및 좁게) 수정 될 수 있다. CNA 수정들은 CNA 조성의 게놈 무결성과 그 적격성-상관관계 속성들을 보존한다. 실시예들에서, 변이된 CNA를 소유한 VDAX들은 변이되지 않은 CNA의 VDAX들과의 미래의 적격성-상관관계를 확립할 수 없다. 실 시예들에서, CNA는 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 게놈적으로 변이될 수 있다. 실시 예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 실시예들에서, PNA 게놈 조성들은, 조성들이 수정가능한, 특정한 디지털 생태계 조직들에 맞게 조정될 수 있다. 일부 실시예에서, PNA 랜덤 원시 다항식들은 특정한 명령어들에 기초하여 균일하게 또는 신중하게 (넓게 및 좁 게) 수정될 수 있다. PNA 수정들은 PNA 조성의 게놈 무결성과 그 적격성-동기화 속성들을 보존한다. 실시예들 에서, 변이된 PNA를 소유한 VDAX들은 변이되지 않은 PNA의 VDAX들과의 미래의 적격성-동기화를 확립할 수 없다. 실시예들에서, PNA는 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 게놈적으로 변이될 수 있다. 실시예들에서, 생태계 선조(예를 들어, 생태계 VDAX)는 DNA를 커뮤니티 멤버들(예를 들어, 엔클레이브들, 코호 트들 등)에 할당할 수 있다. 실시예들에서, 특정한 DNA 조성들 각각은 고유의 게놈 관계들을 가지고 있다. LNA는 상관관계를, XNA는 분화를, CNA는 결합-무결성을, PNA는 결합-적격성을 제공한다. 이들 조성들에 의해 용이화되는 전체 능력들은 실질적으로 게놈 수학적 조성들과 최종적으로 그들의 특정한 VDAX 할당의 관계로부터도출된다. 이들 VDAX 관계들은, DNA의 특정한 수정(예를 들어, LNA, XNA, CNA 및 PNA)에 따라 수정될 수 있다. 실시예들에서, 생태계 선조(또는 적절한 선조 VDAX)는 LNA를 커뮤니티 멤버들에게 할당할 수 있다. 실시예들에 서, LNA 상관관계 능력들은, 다양한 엔클레이브 및 코호트 관계들 N x Ma를 역시 가질 수 있는, VDAX들로 구성 된 차원 N x M을 갖는 모든 디지털 생태계와 관련이 있다. 실시예들에서, LNA 게놈 기반의 조성들은 특정한 디 지털 생태계 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)에 할당되고, 그 들의 관련 상관관계 능력들을 결정한다. 실시예들에서, LNA 할당은 LNA 조성의 게놈 무결성 및 그 상관관계 속 성들을 보존한다. 실시예들에서, 그 초기 LNA 할당이 수정된 VDAX들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX 등)은 미수정된 LNA를 소유한 VDAX와의 상관관계에 더 이상 영향을 미칠 수 없으며, 이제는, 동일한 수정된 LNA 할당을 갖는 다른 VDAX들과의 미래의 상관관계에 영향을 미칠 수 있다. 실시예들에서, LNA 는 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 게놈적으로 할당될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 실시예들에서, 생태계 선조(또는 적절한 선조 VDAX)는 XNA를 커뮤니티 멤버들에게 할당할 수 있다. 실시예들에 서, XNA 분화 능력들은 또한, 다양한 엔클레이브 및 코호트 관계들 N x Ma를 가질 수 있는, VDAX들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)로 구성된, N x M 차원을 갖는 모든 디지털 생 태계와 관련이 있다. 실시예들에서, XNA 게놈 기반의 조성들은 특정한 디지털 생태계 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)에 할당되고, 그들의 관련 분화 능력들을 결정한다. 실시예들에서, XNA 할당은 XNA 조성의 게놈 무결성 및 그 분화 속성들을 보존한다. 일부 실시예에서, 그 초기 XNA 할당이 수정된 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX 등)은 미수정된 XNA를 소유한 VDAX들과의 분화에 더 이상 영향을 미칠 수 없으며, 이제는, 동일한 수정된 XNA 할당을 갖는 다른 VDAX와의 분 화에 영향을 미칠 수 있다. 실시예들에서, XNA는 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 게 놈적으로 할당될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 실시예들에서, 생태계 선조(또는 적절한 선조 VDAX)는 CNA를 커뮤니티 멤버들에게 할당할 수 있다. 실시예들에 서, CNA 결합-무결성 능력들은 또한, 다양한 엔클레이브 및 코호트 관계들 N x Ma를 가질 수 있는, VDAX들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)로 구성된, N x M 차원을 갖는 모든 디 지털 생태계와 관련이 있다. 실시예들에서, CNA 게놈 기반의 조성들은 특정한 디지털 생태계 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)에 할당된다. 실시예들에서, 이들 CNA 게놈 기반의 조성들은 생태계 내에서 그들의 관련된 결합-무결성 능력들을 결정한다. 일부 실시예에서, 특정한 디지 털 생태계 VDAX들에 할당된 CNA 게놈 기반의 조성들은 또한 고유할 수 있다. 실시예들에서, CNA 할당은 CNA 조성의 게놈 무결성, 및 그 결합-무결성 속성들을 보존한다. 일부 실시예에서, 초기 CNA 할당이 수정된 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX 등)는 미수정된 CNA를 소 유한 VDAX와의 결합-무결성에 더 이상 영향을 미칠 수 없고, 이제는, 동일한 수정된 CNA 할당을 갖는 다른 VDAX 들과의 결합-무결성에 영향을 미칠 수 있다. 실시예들에서, CNA는 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 게놈적으로 할당될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 실시예들에서, 생태계 선조(또는 적절한 선조 VDAX)는 PNA를 커뮤니티 멤버들에게 할당할 수 있다. 실시예들에 서, PNA 결합-적격성 능력들은 또한, 다양한 엔클레이브 및 코호트 관계들 N x Ma를 가질 수 있는, VDAX들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)로 구성된, N x M 차원을 갖는 모든 디 지털 생태계와 관련이 있다. 실시예들에서, PNA 게놈 기반의 조성들은 특정한 디지털 생태계 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX, 및/또는 종속 VDAX)에 할당되고, 그들의 관련 결합-적격성 능력들 을 결정한다. 실시예들에서, 특정한 디지털 생태계 VDAX들에 할당된 PNA 게놈 기반의 조성들은 또한 고유할 수 있다. 실시예들에서, PNA 할당은 PNA 조성의 게놈 무결성, 및 그 결합-적격성 속성들을 보존한다. 그 초기 PNA 할당 이 수정된 VDAX(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호트 VDAX 등)는 미수정된 PNA를 소유한 VDAX와의 결합-적격성에 더 이상 영향을 미칠 수 없고, 이제는, 동일한 수정된 PNA 할당을 갖는 다른 VDAX와의 결합-적격 성에 영향을 미칠 수 있다. 실시예들에서, PNA는 광범위한 정보 이론 지원형의 계산적 복합 기능들에 따라 VDAX들에 게놈적으로 할당될 수 있다. 실시예들에서, 이들 정보 이론 지원형의 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다.링크 교환 논의된 바와 같이, 한 쌍의 충분히 상관된 VDAX들은 링크들을 이용하여 결합할 수 있다. 실시예들에서, 링크들 의 주요 목적은 한 쌍의 VDAX들이 더 높은 레벨의 계산적 복합 게놈 기능들을 수행하는데 필요한 정보 교환을 가능케하는 것이다. 실시예들에서, 링크에서 교환되는 정보는 게놈-결합-화물(GEC; genomic-engagement- cargo)이라고 지칭된다. 실시예들에서, 링크 프로세스들은, 링크 스폰, 링크 호스팅, 및 링크 업데이트를 포함 할 수 있다. 링크 스폰은, 스폰 VDAX에 의한 링크 생성 및 수송을 지칭할 수 있다. 링크 호스팅은 수신자 VDAX에 의해 링크에 포함된 정보의 취득 및 통합을 지칭할 수 있다. 링크 업데이트는 VDAX가 또 다른 VDAX와 결합하는데 이용되는 게놈 기초를 수정할 수 있는 CG 프로세스를 지칭할 수 있다. 링크 업데이트 프로세스는 \"링크 수정\"이라고도 지칭될 수 있다. 실시예들에서, 링크 프로세스들(스폰, 호스팅, 업데이트)은 특정한 정 보 이론 조성들에 의존한다. 예를 들어, 실시예들에서, LNA는 게놈 상관관계에 대한 기초로서 이용될 수 있고, CNA는 게놈 결합-무결성에 대한 기초로서 이용될 수 있으며, PNA는 게놈 결합-적격성에 대한 기초로서 이용될 수 있다. 이들 DNA 조성들(예를 들어, LNA, CNA, 및 PNA)은, 링크 프로세스들을 용이화하는 특정한 게놈 변환 기능들을 가능케하는, 응용 특유의 게놈 조성들이다. 실시예들에서, 링크 프로세스들은 CG-ESP의 링크 모듈 에서 정의될 수 있고, 이에 의해 CG-ESP 인스턴스들의 일부 또는 전부는 이들 기능들을 수행하는 링크 모 듈 인스턴스들로 구성될 수 있다. 예를 들어, 그 역할이 링크들을 스폰, 호스팅 및/또는 업데이트할 것을 요구하는 임의의 VDAX는, 정적 링크들 및/또는 동적 링크들에 대한 프로세스들을 정의할 수 있는, 이러한 링크 모듈 인스턴스들로 구성될 수 있다. 실시예들에서, 동일한 CG 지원형의 디지털 생태계에 속하는 한 쌍의 VDAX들(예를 들어, 제1 VDAX 및 제2 VDAX) 은 어떠한 사전 배치 없이 링크들을 스폰하고 호스팅할 수 있다. 이들 실시예들에서, 또 다른 VDAX(예를 들어, 제2 VDAX)에 의한 게놈 결합 화물(GEC)의 수신 및 이용을 위한 게놈 링크를 스폰하려는 VDAX(예를 들어, 제1 VDAX)는, 링크가 생성된 그 다른 VDAX(예를 들어, 제2 VDAX)와의 결합-무결성을 확립하기 위해 그 CNA를 이용한 다. 일부 실시예에서, VDAX(예를 들어, 제1 VDAX)는 또 다른 VDAX(예를 들어, 제2 VDAX)에 의한 포함된 GEC의 수신 및 이용을 위한 게놈 링크를 스폰하고, 이에 의해 VDAX 쌍(예를 들어, 제1 및 제2 VDAX들)은 결합-무결성 을 확립하기 위해 동일한 CNA를 이용하는 복수의 게놈 링크들을 가질 수 있다. 실시예들에서, 또 다른 VDAX(예를 들어, 제2 VDAX)에 의한 GEC의 수신 및 이용을 위한 게놈 링크를 스폰하려는 VDAX(예를 들어, 제1 VDAX)는 링크가 생성된 그 다른 VDAX와의 결합-적격성을 확립하기 위해 그 PNA를 이용할 수 있다. 일부 실시예에서, VDAX(예를 들어, 제1 VDAX)는 또 다른 VDAX(예를 들어, 제2 VDAX)에 의한 포함된 GEC의 수신 및 이용을 위한 게놈 링크를 스폰하고, 이에 의해 VDAX 쌍(예를 들어, 제1 및 제2 VDAX들)은 결합- 적격성을 확립하기 위해 동일한 PNA를 이용하는 복수의 게놈 링크들을 가질 수 있다. 일부 실시예에서, 링크에 포함된 GEC는 추가적인 링크 활성화 요건들을 포함할 수 있다는 점에 유의한다. 일부 실시예에서, 또 다른 VDAX(예를 들어, 제2 VDAX)에 의한 전송 및 이용(예를 들어, \"링크 호스팅\")을 위한 링크를 스폰하고 있는 스폰 VDAX는, 링크가 생성된 그 다른 VDAX와의 게놈 상관관계를 확립하기 위해 그 LNA를 이용할 수 있다. 논의된 바와 같이, LNA 기반의 게놈 프로세스들은 전체 디지털 생태계(커뮤니티)가 단일 게놈 조성(예를 들어, LNA)에 기초하여 VDAX 대 VDAX 상관관계를 달성할 수 있게 할 수 있다. 실시예들에서, LNA 기 반의 게놈 프로세스들은 특정한 계산적 복합 기능들을 이용함으로써 VDAX가 그 상응하는 LNA 조성을 수정할 수 있게 하고, 이에 의해 이들 LNA 기반의 게놈 프로세스들은 게놈 정보의 하위조성들(예를 들어, LNA 기반의 게놈 하위조성들)을 활용한다. 실시예들에서, LNA 기반의 게놈 하위조성들은, 기저 계산적 복합 게놈 기능들과 동일 한 레벨의 엔트로피에서, 링크 호스팅 VDAX에 의해서만 재생산될 수 있는 링크 스폰 VDAX에 의해 고유한 변환 정보를 계산하는데 이용될 수 있다. 실시예들에서, 고유 게놈 결합 인자는 스폰 VDAX로부터 호스팅 VDAX로의 디지털 수송을 위한 GEC를 준비하는데 이용된다. 이들 실시예들 중 일부에서, 링크 호스팅 VDAX는 고유 게놈 결합 인자를 이용하여 GEC에 포함된 인코딩된 GRI를 디코딩할 수 있다. 일부 실시예에서, 고유 게놈 결합 인자 는 복수의 디지털 수송 채널에서의 응용을 위한 복수의 하위조성들로서 될 수 있다. 일부 시나리오에서, 생태계 상관관계는 이용가능하지 않다. 일부 실시예에서, 생태계 상관관계가 이용가능하지 않을 때 링크 스폰 및 호스팅을 위해 VDAX 인증이 필요할 수 있다. 이들 실시예들에서, VDAX 인증은 자유-형태 -상관(FFC)을 용이화하기 위해 대안적인 게놈 하위조성들의 이용에 의해 달성될 수 있다. 예를 들어, 한 쌍의 VDAX들이 고유한 게놈 디지털 생태계들(\"공화국들\"이라고 지칭될 수 있음)에 있는 시나리오가 발생할 수 있다. 일부 실시예에서, 이들 무관한 VDAX들은 특정한 동작들 및 이용들에 대해 고유한 게놈 디지털 생태계(\"연방\"이 라고 지칭될 수 있음)를 형성할 수 있다. 이들 실시예들에서, VDAX들은 그들의 상응하는 공화국들 내에서 뿐만아니라 연방의 멤버들로서 링크들을 스폰할 수 있다. 실시예들에서, 링크 스폰 게놈 프로세스들은 게놈 기능들 및 프로세스들의 실행을 용이화하는 광범위한 계산적 복합 기능들에 따라 실행될 수 있다. 실시예들에서, 이들 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 언급한 바와 같이, 게놈 링크 호스팅(또는 \"링크 호스팅\")은, 링크가 또 다른 VDAX(예를 들어, 제1 VDAX)로부터 의 특정한 게놈-결합-화물(GEC)을 포함하도록, VDAX(예를 들어, 제2 VDAX)에 의한 링크 정보의 취득 및 통합을 포함할 수 있다. 실시예들에서, 링크 호스팅은 특정한 계산적 복합 게놈 기능들에 따라 수행될 수 있다. 실시 예들에서, 호스팅 VDAX(예를 들어, 제2 VDAX)는 하나 또는 복수의 디지털 수송 채널을 통해 고유한 변환 정보 하위조성들을 수신한다. 실시예들에서, 스폰 VDAX(예를 들어, 제1 VDAX)에 의해 스폰된 링크에 의해 수송된(호 스트) 게놈-결합-화물(GEC)을 이용하려는 호스팅 VDAX(예를 들어, 제2 VDAX)는 스폰 VDAX와의 결합-무결성을 확 립하기 위해 그 CNA를 이용할 수 있다. 실시예들에서, 스폰 VDAX(예를 들어, 제1 VDAX)에 의해 스폰된 링크에 의해 수송된(호스트) 게놈-결합-화물(GEC)을 이용하려는 호스팅 VDAX(예를 들어, 제2 VDAX)는 스폰 VDAX와의 결 합-적격성 확립하기 위해 그 PNA를 이용할 수 있다. 실시예들에서, 호스팅 VDAX는 고유한 변환 정보 하위조성들을 활용하는 특정한 계산적 복합 기능들을 이용하여 그 LNA를 수정함으로써 그 디지털 생태계 상관관계를 가능케하는 LNA를 활용할 수 있다. 실시예들에서, LNA 기 반의 게놈 하위조성은, 기저 계산적 복합 게놈 기능들과 동일한 레벨의 엔트로피에서 링크 호스팅 VDAX에 의해 고유한 게놈 결합 인자를 계산하는데 이용된다. 실시예들에서, 호스팅 VDAX(예를 들어, 제2 VDAX)는 고유한 게 놈 결합 인자를 이용하여 스폰 VDAX(예를 들어, 제1 VDAX)에 의해 제공되는 링크로부터 GEC를 추출한다. 실시 예들에서, 호스팅 VDAX(예를 들어, 제2 VDAX)는 스폰 VDAX에 의해 부과되는 추가적인 링크 활성화 요건들을 완 료하기 위해 요구될 수 있으며, 이에 의해 추가적인 링크 활성화 요건들은 GEC에서 제공된다. 논의된 바와 같이, 한 쌍의 VDAX들이 고유한 게놈 디지털 생태계들(\"공화국들\"이라고 지칭될 수 있음)에 있는 시나리오가 발생할 수 있다. 일부 실시예에서, 이들 무관한 VDAX들은 특정한 동작들에 대해 고유한 게놈 디지 털 생태계(\"연방\"이라고 지칭될 수 있음)를 형성할 수 있고, 논의된 바와 같이, 이용할 수 있다. 실시예들에서, 링크 호스팅 게놈 프로세스들은 광범위한 계산적 복합 기능들에 따라 실행될 수 있다. 실시예들 에서, 이들 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 실시예들에서, 이들 기능들은 게놈 동작들을 수행하는데 필요할 수 있다. 실시예들에서, VDAX들은 다른 VDAX들에 의해 호스팅된 링크들을 업데이트할 수 있다. 예를 들어, 보안 레벨들 을 증가시키기 위해, VDAX는, 악의적인 당사자가 링크 정보(예를 들어, GRI)를 결정하거나 그렇지 않으면 획득 할 수 있는 가능성을 감소시키도록 또 다른 VDAX에 의해 호스팅된 링크를 업데이트할 수 있다. 이들 실시예들 에서, \"링크 스폰\" 및 \"링크 호스팅\" 프로토콜들을 이전에 완료한 한 쌍의 VDAX들(예를 들어, 제1 VDAX 및 제2 VDAX)은 하나 또는 양쪽 모두의 링크들을 업데이트할 수 있다. 이러한 방식으로, VDAX(예를 들어, 제1 VDAX)는 또 다른 VDAX(예를 들어, 제2 VDAX)와 결합하는데 이용되는 게놈 기초를 수정할 수 있고, 및/또는 그 반대도 마 찬가지이다. 일부 실시예에서, VDAX(예를 들어, 제1 VDAX)에 의해 스폰되고 호스팅을 위해 또 다른 VDAX(예를 들어, 제2 VDAX)에 전송되는 새로운 게놈 링크는, 그 다른 VDAX에 의해 하나 이상의 기존의 호스팅된 링크를 새 로 스폰된 링크로 대체함으로써 링크를 업데이트하는데 이용될 수 있다. 실시예들에서, VDAX에 의해 스폰되고 호스팅을 위해 또 다른 VDAX에 전송되는 게놈 링크는 기존의 호스팅된 링크의 GRI 데이터의 일부 또는 전부를 수정하는데 이용될 수 있다. 위에서 논의된 바와 같이, 한 쌍의 VDAX들이 고유한 게놈 디지털 생태계들(\"공화국들\"이라고 지칭될 수 있음)에 있는 시나리오가 발생할 수 있다. 일부 실시예에서, 이들 무관한 VDAX들은 특정한 동작들 및 이용들에 대해 고 유한 게놈 디지털 생태계(또는 \"연방\")를 형성할 수 있다. 이들 실시예들 중 일부에서, VDAX들의 연방은 또한, 특정한 동작들 및 이용들에 대해 그들의 링크들을 업데이트할 수 있다. 실시예들에서, 링크 업데이트 게놈 프로세스들은 광범위한 계산적 복합 기능들에 따라 실행될 수 있다. 실시예 들에서, 이들 기능들은, 게놈 기능들 및 프로세스들을 실행하는데 필요한, 암호 기반의, 암호 없는 또는 하이브 리드 계산적 복합 기능들일 수 있다. 서열 맵핑 및 2진 변환 본 개시내용 전체에 걸쳐 논의된 바와 같이, 서열 맵핑 및 2진 변환은 VBLS를 형성하기 위해 수행될 수 있는 CG 동작들이다. 실시예들에서, 서열 맵핑은 공개 서열들 및/또는 사적 서열들로 수행될 수 있다. 실시예들에서,서열이란 데이터의 서열(예를 들어, 비트들의 서열)을 지칭할 수 있다. 실시예들에서, 공개 서열들이란, 공개 프로토콜 및 포맷 종속 정보(예를 들어, TCP, UDP, TLS, HTTP, H.265 등)를 지칭할 수 있는 반면, 사적 서열들 이란, 사적 및/또는 전용 프로토콜 및 포맷 종속 정보를 지칭할 수 있다. 실시예들에서, 서열들(예를 들어, 공 개 또는 사적 서열들)은 비반복적 값들로 계산적으로 변환된다. 서열들은 광범위하게 이질적일 수 있지만(예를 들어, 프로토콜 독립적이고 기존 엔트로피를 가짐), 서열들은 특정한 레벨들의 엔트로피를 갖는 값들을 생성하 는 방식으로 처리된다. 실시예들에서, 이 프로세스는 광범위한 프로토콜들 및 포맷들과 호환되며 상응하는 기 존 엔트로피들을 나타내는 상이한 서열들로 시작될 수 있다. 실시예들에서, 이 프로세스는 특정한 레벨들의 엔 트로피를 나타내는 게놈 결합 인자를 생성하는 복합 게놈 프로세스들 및 기능들을 이용하여 수행될 수 있다. 실시예들에서, CG 기반의 보안 관리 시스템들 및 아키텍쳐들은 게놈 데이터 조성들과 연계하여 게놈 결합 인자 들의 이용을 요구할 수 있다. 실시예들에서, 이들 게놈 결합 인자들은, 부분적으로 반복 데이터(예를 들어, 서 열들)의 이용에 의해 도출될 수 있다. 게놈 데이터 조성들과 연계하여 서열들을 이용하기 전에, 결과적인 게놈 결합 인자들의 엔트로피가 게놈 조성(예를 들어, XNA)의 엔트로피와 일치하도록 서열들이 처리된다. 이 프로세 스를 \"서열 맵핑(sequence mapping)\"이라고 하며, 그 생성물을 게놈 결합 인자(genomic Engagement factor)라 고 한다. 서열이 광범위하게 이질적일 수 있더라도, 결과적인 생성된 게놈 결합 인자들은 특정한 레벨의 엔트 로피를 나타낸다. 실시예들에서, 게놈 결합 인자는 XNA 벡터들의 통합으로부터 생성될 수 있다. 일부 실시예 에서, 다중 게놈 결합 인자들은 한 세트의 XNA 벡터들로부터 생성될 수 있다. 일부 실시예에서, 이 프로세스는 특정한 디지털 객체 변환에 의존하는 개방형 아키텍쳐 애플리케이션에 중요할 수 있으며, 객체들은 잠재적으로 이질적 프로토콜들 및 포맷들(예를 들어, TCP, UDP, TLS, HTTP, H.265)을 포함한다. 일부 실시예에서, 수정 없이 광범위하게 이질적인 외부 포맷 및 프로토콜 상주 데이터를 이용하여 서열들을 조 성한다. 일부 실시예에서, 수정된 광범위하게 이질적인 외부 포맷 및 프로토콜 상주 데이터를 이용하여 서열들 을 조성한다. 일부 실시예에서, 서열들은 특정한 엔트로피를 나타내는 고유한 벡터들을 결정하기 위해 특이적 게놈 기반의 데이터 조성들과 연계하여 이용된다. 일부 실시예에서, 서열들은 특정한 게놈 결합 인자를 도출하 기 위해 특정한 게놈 데이터 조성들과 연계하여 계산적 복합 게놈 프로세스들 및 기능들에 따라 맵핑된다. 실 시예들에서, 서열 맵핑은, 서열의 고유 엔트로피와 상관없이, 게놈 데이터 조성의 엔트로피와 일치하는 엔트로 피를 나타내는 게놈 결합 인자들을 생성한다. 일부 실시예에서, 게놈 결합 인자들은 이들 외부 포맷들 및 프로 토콜들과 연계하여 내부 CG-ESP 포맷들 및 프로토콜들을 활용하는 서열 맵핑으로부터 생성될 수 있다. 게놈 결 합 인자들은 포맷 및 프로토콜 상주 데이터와 게놈 기반의 조성을 드러내기 위해 활용될 수 없는 방식으로 (예 를 들어, 계산적 복합 기능들 이용하여) 결정되어야 한다는 점에 유의한다. 실시예들에서, 서열 맵핑은 계산적 복합 기능들에 따라 계산된 게놈 결합 인자 생성 게놈 프로세스들을 실행한 다. 실시예들에서, 이들 기능들은, 암호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있으며, 이에 의해 서열(공개 또는 사적) 및 XNA는 고유한 게놈 결합 인자를 생성한다. 서열 맵핑 예들은 아래 에서 더 상세히 논의된다 초확장성: 일부 실시예에서, CG-ESP는 초확장가능한 상관관계를 용이화하기 위해 게놈 프로세스들을 구현할 수 있다. 실 시예들에서, 생태계, 엔클레이브, 및 코호트 결합 관계의 가상 인증(예를 들어, 고유한 상관)은 초확장가능한 상관으로 달성될 수 있다. 논의된 바와 같이, 초확장성 기술들은 정확하고 고유한 상관관계에 의존하는 생태계, 엔클레이브 및 코호트 결합들을 강력하게 강화하는데 이용될 수 있다. 논의된 바와 같이, 유기 생태계 들(예를 들어, 생물학적 생태계들)은 복합 생화학적 프로세스들로부터 도출되는, 종들, 자손, 및 형제자매들 사 이의, 제한적이지만, 강력한 상관관계를 입증한다. 이들 생화학적 프로세스들을 지배하는 원리들은, 생태계들, 엔클레이브들, 및 코호트들 사이의 고유한 상관관계를 나타내는, 정보 이론에 의해 용이화되는 특정한 디지털 게놈 조성들에 의해 반영될 수 있다. 실시예들에서, 디지털 게놈 상관관계는 실질적으로 무제한이며, 특정한 및 사용자가 제어할 수 있는 엔트로피를 나타낸다. 실시예들에서, 게놈 적격성 객체들(예를 들어, CNA 및/또는 PNA) 및 게놈 상관관계 객체들(예를 들어, LNA)은 디지털 게놈 상관에 이용될 수 있다. 실시예들에서, 생태계 VDAX들은 엔클레이브들 및 코호트들과의 가상 제휴를 달성하기 위해 계산적 복합 게놈 프 로세스들을 활용할 수 있다. 유사하게, 엔클레이브 VDAX들은 코호트들과의 초확장가능한 상관관계를 달성하기 위해 이들 계산적 복합 게놈 프로세스들을 이용할 수 있고 코호트 VDAX들은 다른 코호트들과의 초확장가능한 상 관관계를 달성하기 위해 계산적 복합 게놈 프로세스들을 이용할 수 있다. 실시예들에서, 생태계들, 엔클레이브 들, 및 코호트들 사이의 고유한 초확장가능한 상관관계는 계산적 복합 게놈 프로세스들에 의해 수정될 수 있다.예를 들어, 생태계 VDAX는, 엔클레이브 멤버들 중 하나 이상에 대한 그 특정한 엔클레이브에서의 미래의 링크 교환을 방지하도록, 주어진 엔클레이브에 대한 LNA를 수정할 수 있다. 일부 실시예에서, 주어진 생태계의 구성 요소들인 엔클레이브 VDAX들 및 코호트 VDAX들은 다른 생태계들의 구성요소들인 엔클레이브 VDAX들 및 코호트 VDAX들과의 결합을 상관시키기 위해 계산적 복합 게놈 프로세스들을 이용할 수 있다. 예를 들어, 일부 실시예 에서, 2개의 생태계 VDAX들은 그들의 상응하는 게놈 데이터 세트들로부터 도출된 게놈 데이터 세트를 형성할 수 있고, 이에 의해 생태계의 멤버들은 생태계들 전반에 걸쳐 결합하기 위해 도출된 게놈 데이터(또는 그 파생물들)를 이용할 수 있다. 이러한 방식으로, 엔클레이브 VDAX들 및 코호트 VDAX들은 계산적 복합 게놈 프로 세스들 및 그들의 상응하는 게놈 데이터 세트들에 기초하여 여러 생태계들에 걸쳐 고유한 초확장가능한 상관관 계를 달성할 수 있다. 실시예들에서, 초확장가능한 상관관계는, PNA, CNA 및 LNA가 고유한 게놈 결합 인자들을 생성하기 위한, 광범위한 계산적 복합 기능들에 따라 계산된 게놈 프로세스들을 실행한다. 이들 기능들은, 암 호 기반의, 암호 없는, 또는 하이브리드 계산적 복합 기능들일 수 있다. 일부 실시예에서, CG-ESP는 초확장가능한 분화를 용이화하기 위해 계산적 복합 프로세스들을 구현할 수 있다. 일부 예에서, 디지털 네트워크 지원형의 관계들에 기초하여, 생태계들, 엔클레이브들, 및 코호트들 사이의 고유 한 제휴를 제공하기 위해 초확장가능한 분화가 필요하거나 요구될 수 있다. 실시예들에서, 초확장성 기술들은 정확하고 고유한 분화에 의존하는 생태계들, 엔클레이브들, 및 코호트들의 제휴를 강력하게 강화하는데 이용될 수 있다. 일부 예시적인 유기 생태계는, 복합 생화학적 프로세스들로부터 도출될 수 있는 종들, 자손, 및 형제 자매들에 걸쳐 제한적이지만 강력한 분화의 증거를 보여줄 수 있다. 이들 예시적인 생화학적 프로세스들을 지 배하는 원리들은, 생태계들, 엔클레이브들, 및 코호트들에 걸쳐 고유한 분화를 나타낼 수 있는, 정보 이론에 의 해 지배되는 특정한 디지털 게놈 조성들에 의해 반영될 수 있다. 일부 예에서, 이들 디지털 게놈 분화는 실질 적으로 무제한일 수 있고, 특정한 및 사용자 제어가능한 엔트로피를 나타낼 수 있다. 생태계들, 엔클레이브들, 및/또는 코호트들에서 초확장가능한 분화를 적용하기 위한 다양한 예시적인 구현이 있 을 수 있다. 예를 들어, CG 지원형 생태계들의 멤버들은 계산적 복합 게놈 프로세스를 활용하여, 생태계들, 엔 클레이브들, 및 코호트들 사이의 고유한 비반복적 가상 제휴를 용이화하는 초확장가능한 분화를 달성할 수 있다. 일부 예에서, CG 지원형 엔클레이브들은, 엔클레이브들과 코호트들 사이의 고유한 비반복적 가상 제휴를 용이화하도록 초확장가능한 분화를 달성하기 위해 계산적 복합 게놈 프로세스들을 활용한다. 일부 예에서, 코 호트들은 코호트들 사이의 고유한 비반복적 가상 제휴를 용이화하도록 초확장가능한 분화를 달성하기 위해 계산 적 복합 게놈 프로세스들을 이용할 수 있다. 실시예들에서, 생태계들, 엔클레이브들, 및 코호트들 사이의 고유 한 초확장가능한 분화는 계산적 복합 게놈 프로세스들에 의해 수정될 수 있다. 일부 실시예에서, 주어진 생태 계의 멤버들인 엔클레이브들 및 코호트들은, 다른 생태계들의 멤버들인 엔클레이브들 및 코호트들과 제휴하기 위해 계산적 복합 게놈 프로세스들을 채용할 수 있다. 이러한 방식으로, 엔클레이브들 및 코호트들은, 본 개시 내용의 일부 실시예에 따라, 계산적 복합 게놈 프로세스들에 기초하여 복수의 생태계에 걸쳐 고유한 가상 제휴 를 달성할 수 있다. 일부 예에서, 초확장가능한 분화는, 서열들 및 XNA가 VBLS를 생성하는데 이용될 수 있는 고유한 게놈 결합 인자를 생성하기 위한 광범위한 암호 기반의, 암호가 없는, 또는 하이브리드(예를 들어, 암호 기반의 및/또는 암호 없는) 계산적 복합 기능들에 따라 계산된 게놈 프로세스들을 실행할 수 있다. 일부 실시예에서, CG-ESP는 가상 기민성을 용이화하기 위해 게놈 프로세스들을 구현할 수 있다. 일부 예에서, 가상 기민성은, 네트워크(예를 들어, 개방형 시스템 상호접속(OSI))에서, 소프트웨어 스택 레벨에서, 및/또는 하드웨어 컴포넌트들에서, 초확장가능한 분화 및 초확장가능한 상관관계를 실행할 수 있는 능력들을 요구할 수 있는 생태계들, 엔클레이브들, 및 코호트들 사이의 고유한 결합을 제공할 수 있다. 네트워크 및 소프트웨어 결 합 양쪽 모두는 전통적으로 세션 기반의 프로토콜들의 생성, 협상 및 유지보수를 요구한다. 일부 예에서, 이들 프로토콜들은 계산 비용이 많이 들고 네트워크 및 소프트웨어 스택 채택 옵션들을 제한할 수 있다. 가상 기민 성은, 세션 기반의 프로토콜들에 대한 요건들 중 적어도 일부를 강력하게 제거함으로써, 생태계들, 엔클레이브 들, 및 코호트들의 결합을 강화할 수 있다. 가상 기민성은, 계산적 복합 프로세스들에 의해 생성될 수 있고 실 질적으로 제한이 없고 특정하고 사용자가 제어할 수 있는 엔트로피를 나타낼 수 있는, 특정한 디지털 게놈 조성 들을 반영할 수 있다. 생태계들, 엔클레이브들, 및/또는 코호트들에서 가상 기민성을 적용하기 위한 다양한 예시적인 구현이 있을 수 있다. 예를 들어, 가상 기민성은, 네트워크 스택 레벨, 소프트웨어 스택 레벨, 및/또는 하드웨어 레벨에서 채 택할 수 있음으로써, 많은 수의 생태계, 엔클레이브 및/또는 코호트를 지원할 수 있다. 실시예들에서, 가상 기 민성은, 네트워크 통신 결합, 소프트웨어 애플리케이션 결합, 및/또는 하드웨어 컴포넌트 결합을 위한 세션 기 반의 프로토콜들을 생성, 협상 및 유지하기 위한 요건을 제거할 수 있다.가상 2진 언어 스크립트(VBLS): 일부 실시예에서, CG-ESP는 VBLS를 생성 및/또는 디코딩하기 위해 계산적으로 복합의 프로세스들을 구현할 수 있다. 논의된 바와 같이, CG-ESP는, 링크 교환(예를 들어, 링크 스폰 및/또는 링크 호스팅) 및 VBLS 객체들로 계산적으로 변환될 특정한 포맷들 및 프로토콜들(예를 들어, 패킷, 섹터, 서열 및 프레임)을 포함하는 디지털 객체들을 허용할 수 있는 서열 맵핑을 수행하도록 구성될 수 있다. 실시예들에서, 이 프로세스에 의해 생성된 VBLS 객체들은, 고유하고, 비반복적이며, 및/또는 계산적 양자 증거일 수 있다. 일부 실시예에서, VBLS는, 게 놈 정보 이론 제어형 및 지원형의 링크, 서열, 상관관계, 분화, 기민성 기능들 및 프로세스들의 완성일 수 있다. 계산적 양자 증명 VBLS는, 현재의 배치들이든 또는 새로 개발된 배치들이든, 특정한 네트워크, 소프트웨 어, 및 하드웨어 아키텍쳐들을 조성하기 위한 기초를 형성할 수 있다. 생태계들, 엔클레이브들, 및/또는 코호트들에서 가상 2진 언어 스크립트(VBLS)를 적용하기 위한 다양한 예시적 인 구현이 있을 수 있다. 예를 들어, VBLS는, 생태계, 엔클레이브, 및/또는 코호트 관계들의 광범위하고 매우 유연한 보완들의 제어를 허용할 수 있다. 실시예들에서, VBLS는 동적 게놈 기반의 아키텍쳐들의 완성 및 제어 를 용이화할 수 있다. 일부 예에서 VBLS 렌더링된 디지털 객체들은, 비밀 키 생성, 교환 및 보존의 필요성을 제거하면서, 고유하고 비반복적이며 계산적 양자 증거가 될 수 있다. VBLS 렌더링된 객체들은 VDAX(들)의 결합 에 대해 최소한의 오버헤드와 대역폭을 요구할 수 있다. 일부 예에서, VBLS 렌더링된 객체들은, 생태계, 엔클 레이브, 및/또는 코호트-지시된 게놈 수정들을 나타낼 수 있다. 실시예들에서, VBLS 애플리케이션들은 프로토 콜에 구애받지 않을 수 있다(예를 들어, 네트워크, 소프트웨어, 및/또는 하드웨어 솔루션들과 상호운용가능). 예들에서, VBLS는, 커뮤니티 멤버들 사이의 고유하고, 비반복적이며, 계산적으로 양자 증명 결합들(예를 들어, 생태계-대-생태계, 생태계-대-엔클레이브, 생태계-대-코호트, 엔클레이브-대-코호트, 및/또는 코호트-대-코호트 결합들)을 그들의 고유한 계산적 복합 게놈 조성들 및 프로세스들에 기초하여 용이화할 수 있다. 일부 예시적 인 실시예에서, 임의의 VBLS 지원형 VDAX는 다른 VDAX(들)와의 복수의 VBLS 관계들에 참여할 수 있다. 이들 실 시예들에서, VDAX는 각각의 VDAX와 고유한 관계를 형성할 수 있다. 일부 실시예에서, 생성되기 위해 이용된 게 놈 결합 인자들은, 특정한 엔트로피에서 고유한 비반복적 값들을 역시 요구하는 1차 및 2차 적용들에 동시에 이 용될 수 있다. 실시예들에서, VDAX들은 대칭 및/또는 쌍대칭 VBLS 기반의 결합들에 관여하도록 구성될 수 있다. 예를 들어, 일부 실시예에서, VBLS 지원형 VDAX(들)는, 게놈 링크 명령어들 및 동일할 수 있는 게놈 조성들을 이용할 수 있 는 링크 교환(예를 들어, 스폰된 및 호스팅된)의 기초들에서 결합하여, 대칭 기반의 결합을 생성할 수 있다. 실시예들에서, VBLS 지원형 VDAX들은, 고도로 상관된 게놈 조성들(예를 들어, 동일하거나 그렇지 않으면 충분히 상관된 XNA)에 기초하여 하는 쌍대칭 결합에 관여할 수 있다. 이들 실시예들에서, VBLS-지원형 VDAX들은 고유 한 게놈 조절 명령어들(GRI)을 포함하는 링크들을 교환한다. 그러나, 일부 시나리오에서, 링크 교환이 동일한 GRI를 수반하는 경우 VBLS 지원형 VDAX들은 대칭 결합들에 관여할 수 있다. 예를 들어, CG-ESP는 일방향 링크 교환을 수행하도록 구성될 수 있고, 이에 의해 하나의 VDAX는 VBLS 생성 프로세스에서 양쪽 VDAX들에 의해 이용 되는 GRI를 제공할 수 있다. 이러한 방식으로, VBLS 지원형 VDAX들은 VDAX들 사이의 반복적 조율 없이 대칭 및 /또는 쌍대칭 2진 언어들에 기초하여 다른 VDAX들과 결합할 수 있다. 이들 실시예들 중 일부에서, VBLS 지원형 VDAX 결합은, 그들의 대칭 또는 쌍대칭 2진 언어들이, 인증, 무결성 및 프라이버시를 동시에 캡슐화하기 때문에, 공식적 세션의 협상 없이 진행될 수 있다. 가상의 신뢰할 수 있는 실행 도메인: 원격 네트워크 중심의 고도로 분산된 솔루션들 및 서비스들(예를 들어, 원격 클라우드 및 엣지 클라우드)의 급 속한 확장은, 민감한 바이너리들이 아마도 개방된 또는 반개방된 환경들에서 실행되어 신뢰할 수 없는 제3자들 (예를 들어, 적)에게 스스로를 노출시킬 수 있는 상황을 생성했다. 동형 암호화(암호화된 상태의 데이터의 강 력한 처리), 기능적 난독화(암호화된 상태의 데이터 및 애플리케이션 코드의 강력한 처리), 및 다양한 신뢰할 수 있는 실행 환경(예를 들어, 실행가능한 코드의 물리적 및 소프트웨어 격리)은 이들 중요한 문제를 해결하기 위한 현재의 접근법들이다. 이들 방법은 눈에 띄게 향상될 수 있지만, 이들 솔루션들 중 어느 것도, 각각이 성 능에 중대한 영향을 미치기 때문에, 광범위한 상용 애플리케이션에 대해 요구되는 중요한 확장성을 해결하지 못 한다. 본 개시내용의 일부 실시예에 따르면, CG-ESP 기술은, 게놈 생태계들로서 조직화될 수 있는, 데이터 및 애플리 케이션 코드의 처리를 위해 계산적 양자 증명, 고효율, 및 초확장가능한 가상의 신뢰할 수 있는 실행 도메인들 을 가능케한다. 이들 실시예들 중 일부에서, 가상의 신뢰할 수 있는 실행 도메인은, 애플리케이션들(예를들어, API, 라이브러리들, 및 스레드들), 운영 체제(예를 들어, 커널, 서비스들, 드라이버들, 및 라이브러리 들), 및 시스템 온 칩(예를 들어, 처리 유닛들, 예를 들어, 코어) 등의, 컴포넌트 상주 실행가능한 바이너리들 및 데이터의 고유한 변환을 허용한다. 실시예들에서, CG-ESP EIC(Executable Isolation Components)는 요구되 는 변환들에 필요한 CBI(component-binary-isolation)를 용이화한다. 일부 실시예에서, 격리는, 1) 동일한 생 태계에 속하는 분산된 컴포넌트들 사이의 고유한 게놈 상관관계, 및 2) 다른 실행가능한 생태계 컴포넌트들과의 고유한 게놈 분화에 의해 가능케된다. 이 상관관계 및 분화 프로세스는 가상의 신뢰할 수 있는 실행 도메인 (VTED; virtual trusted execution domain)이 매우 유연하고 확장가능한 컴포넌트-2진-격리(CBI; component- binary-isolation)를 가능케하기 위한 기초를 형성한다. 실시예들에서, 초확장가능한 분화는, 생태계들, 엔클레이브들, 및 코호트들의 고도로 유연한 컴포넌트 2진 격리 (CBI)를 가능케한다. 이들 실시예들 중 일부에서, 가상의 신뢰할 수 있는 실행 도메인(VTED) 격리는, VTED 및 CBI 내의 게놈 컴포넌트들을 그들의 VTED 생태계 VDAX와 공유함으로써 달성될 수 있으며, 이로써 이들 멤버들 사이에 계층적 링크를 확립할 수 있다. 실시예들에서, VTED는, CBI들이 유휴 상태로 유지되고 런타임 동작들이 인코딩된 바이너리들 및 연관된 데이터에 관해 수행되는 동형 암호화의 기능적 대체를 제공한다. 실시예들에서, VTED 가상-기민성은 고도로 유연한 컴포넌트-2진-분리(CBI) 및 동적 게놈 기반의 아키텍쳐들의 제어를 가능케한다. 추가 실시예들에서, 게놈 상관관계 및 분화는 동적 게놈 기반의 시스템들이 물리적 동작 환경들을 수정할 필요 없이 동적 게놈 네트워크 토폴로지들을 구성할 수 있게 한다. 실시예들에서, VTED-변환된 실행가능한 바이너리들은 고유하고 비반복적이며 계산적 양자 증거이다. 실시예들 에서, 이들 변환은 신뢰할 수 있는 실행 환경(TEE; trusted execution environment) 기술들에 의해 종종 요구 되는 비밀 키 생성, 교환, 및 보유에 대한 요건을 제거한다. 실시예들에서, VTED 실행가능한 바이너리들은 게 놈 조성들(예를 들어, LNA 또는 ZNA)의 적용을 통해 변환되어 변환된 실행 바이너리들을 구축한다. 실시예들에서, VTED 초확장가능한-상관관계, 초확장가능한 분화, 초확장가능한 기민성은, CBI가 최소한의 오버 헤드와 대역폭에서 고유하게 동작할 수 있게 한다. 추가 실시예들에서, 많은 수의 게놈 조성들이 VTED 생태계 의 초확장성을 제공하는 방대한 수의 CBI에 적용된다. 실시예들에서, 생태계들, 엔클레이브들, 및 코호트들에 대한 VTED 지원형 CBI는 2진 실행가능한 관계들의 손상 없이 게놈적으로 직접 수정될 수 있다. 실시예들에서, VTED 지원형 CBI는 2진 정보를 수정하는 반면 VTED는 그 생태계 내에서 CBI를 실행할 수 있는 능력을 유지한다. 실시예들에서, VTED 지원형 CBI는 알려진 암호 기반의 및 암호 없는 계산 방법들과 호환될 수 있다. 추가 실시 예들에서, VTED 및 CBI와 암호 기반의 및 암호 없는 계산 방법들의 호환성은, 투명한 게놈 조성 기반의 변환들 에 의해 유지된다. 실시예들에서, VTED는, 그들의 고유한 계산적 복합 게놈 조성들 및 프로세스들에 기초하여 특정한 생태계들 사 이의 고유하고 비반복적이며 계산적 양자 증거인 CBI 실행파일들을 인에이블할 수 있다. 추가 실시예들에서, CBI 조성 프로세스는 전통적인 계산적으로 비용이 많이 드는 동작들에 의존하지 않는 게놈 조성들을 적용한다. 실시예들에서, VTED는, CBI 실행파일들이, 특정한 생태계들과 엔클레이브들 사이의 고유하고 비반복적이며 계산 적 양자 증명 결합들을 포함하는 다수의 특성을 가질 수 있게 할 수 있다. 실시예들에서, CBI 실행파일들은 고 유한 계산적 복합 게놈 조성들 및 프로세스들에 기초하여 이들 특성들을 나타낸다. 추가 실시예들에서, VTED는 게놈 조성들을 적용하여 CBI 실행파일들과 게놈 VTED 사이의 양자 증명 동작들을 가능케하는 CBI 실행파일들을 배치한다. 실시예들에서, VTED는 그들의 고유한 계산적 복합 게놈 조성들 및 프로세스들에 기초하여 CBI 실행파일들을 인 에이블할 수 있다. 추가 실시예들에서, VTED가 복수의 엔클레이브에 걸쳐 복수의 코호트를 포함하는 시나리오 들에서, VTED는, 엔티티들 사이의 고유하고 비반복적이며 양자 증거인 것 등의, 소정의 바람직한 특성들을 가질 수 있는 CBI 실행파일들을 인에이블하기 위해 게놈 컴포넌트들을 적용할 수 있다. 추가 실시예들에서, 생태계 VDAX는, 개개의 코호트가 그들의 생태계, 엔클레이브, 또는 코호트 내에서 동작을 위해 인에이블된 특정한 피처 들 또는 CBI들을 가질 수 있는 게놈 조성 기반의 CBI 라이센싱 모델들을 제공할 수 있다. CypherGenics-지원형 디지털 생태계들 및 아키텍쳐들 이제 도 6을 참조하면, 본 개시내용의 일부 예시적인 실시예에 따른 예시적인 CG 지원형 디지털 생태계가 도시되어 있다. 도면에 도시된 보안 플랫폼의 토포그래피 및 아키텍쳐를 포함한, 도 6에 도시된 CG 지원형 디지털 생태계의 예시적인 구성은 비제한적인 예로서 제공되는 것이며, 본 개시내용의 범위를 제한하려는 의 도가 아니라는 점에 유의한다. 본 개시내용 전반에 걸쳐 논의되는 바와 같이, CG-ESP의 구성은 디지털 생태계 의 커뮤니티 소유자에 의해 정의될 수 있다. \"커뮤니티 소유자\"를 언급할 때, 이 용어는, 커뮤니티를 관리, 유 지 또는 소유하는 엔티티, 그 대표자들(예를 들어, 네트워크 관리자, CIO, IT 관리자, 홈소유자, 컨설턴트, 보 안 전문가, 커뮤니티 소유자를 대신하여 작동하는 인공 지능 소프트웨어, 또는 임의의 다른 적절한 대리인), 및 /또는 CG 지원형 생태계와 관련하여 이용되는 CG-ESP의 구성을 정의할 수 있는 임의의 다른 적절한 당사자 를 지칭할 수 있다. 실시예들에서, 한 세트의 VDAX들(예를 들어, VDAX 608, 610, 612, 614)은 디지털 생태계를 대신하여 한 세트의 게놈 보안 기능들을 수행한다. VDAX들은 \"CG 보안 제어기들\" 또는 \"보안 제어기들\"이라고도 할 수 있다. 실시예들에서, CG 지원형 디지털 생태계는, 한 세트의 엔클레이브들, 및 각각의 엔클레이브에 대해, 상응하는 세트의 코호트들을 포함한다. CG-ESP에 대한 일반적인 언급들, 디지털 생태계에 참여하는 VDAX 들(예를 들어, 생태계 VDAX들, 엔클레이브 VDAX들, 코호트 VDAX들, 및/또는 종속 VDAX들(61 4))의 구성들에 대한 참조일 수 있다는 점에 유의한다. 실시예들에서, 코호트의 세트는 독립 코호트들을 포함할 수 있다. 논의된 바와 같이, 독립 코호트들은 독립 엔티티로서 동작하는 하나 이상의 디바이스의 집합을 포함할 수 있다. 독립 코호트들의 예들은, 그리드들, 네트워크들, 클라우드 서비스들, 시스템들, 컴퓨터들, 기기들, 디바이스들, IoT 디바이스들 등을 포함하지만, 이들로 제한되는 것은 아니다. 일부 실시예 에서, 코호트 세트는 종속 코호트들을 더 포함할 수 있다. 종속 코호트는, 디지털 컨테이너 기반의 VDAX에 의해 인에이블되거나 독립 코호트가 대리 역할을 하는 개개의 디지털 엔티티를 지칭할 수 있다. 종속 코호트들의 예들은, 센서들, 애플리케이션들, 데이터, 파일들, 데이터베이스들, 미디어 콘텐츠, 암호화폐, 스마 트 계약 등을 포함하지만, 이들로 제한되는 것은 아니다. 엔클레이브는 상호 관심 ID를 갖는 2개 이상의 코호트(예를 들어, 독립 코호트 및/또는 종속 코호트)의 집합일 수 있다. 논의된 바와 같이, 상호 관심 ID는 엔클레이브 내의 코호트들 사이의 임의의 논리적 공통성일 수 있다. 예를 들어, 상호 관심 ID는, 기 업 조직 내의 사업부에 의해 이용되는 한 세트의 디바이스들, 서버들, 문서들, 애플리케이션들 등일 수 있다. 또 다른 예에서, 상호 관심 ID는, 단일 가족 또는 사용자에 속하는 디바이스들, 문서들, 애플리케이션들 등일 수 있다. 또 다른 예에서, 상호 관심 ID는 특정한 그리드에서 주행하는 한 세트의 자율 차량들일 수 있다. 실 시예들에서, 디지털 커뮤니티의 토포그래피(및 대응하는 CG-ESP의 아키텍쳐)는 이들 상호관심 ID들을 고려하여 커뮤니티 소유자에 의해 정의될 수 있다. 실시예들에서, 생태계 및/또는 그 하나 이상의 엔클레이브(60 2)에 대한 멤버십 적격성은 커뮤니티 소유자에 의해 정의될 수 있고, 멤버쉽 및 그 취소는 커뮤니티 소유자에 의해 및/또는 한 세트의 하나 이상의 규칙에 따라 관리될 수 있다. 일부 실시예에서, 소정의 CG 지원형 디지털 생태계들 및 대응하는 CG-ESP의 상응하는 아키텍쳐들은, 커뮤니티 소유자가 디폴트 구성으로 미리구성된 디지털 생태계를 구매하거나 획득하도록, 디폴트 구성에 따라 정의될 수 있다. 일부 실시예에서, 생태계 선조(예를 들어, 생태계 VDAX)는 하나 이상의 엔클레이브를 조성하도록 구 성되고, 커뮤니티 소유자에 의해 정의된 아키텍쳐 및 구성들에 따라 상응하는 세트의 코호트들을 각각의 엔클레 이브에 추가할 수 있다. 일부 실시예에서, CG 지원형 디지털 생태계와 관련된 아키텍쳐 및 구성들은 CG-ESP에 의해 정의될 수 있다(예를 들어, 도 4에서 논의된 바와 같이). 이들 실시예들에서, 디지털 생태계 에 참여하는 VDAX들 각각은, CG-ESP 인스턴스가 상응하는 VDAX로 하여금 생태계와 관련하여 상응하는 역할을 수행하고 의도된 생태계 멤버들과의 관계를 형성할 수 있게끔 각각의 VDAX가 CG-ESP 인스턴스를 실행하 도록, CG-ESP 인스턴스의 상응하는 인스턴스를 실행할 수 있다. 예를 들어, VDAX 세트는 생태계-레벨 역할을 서비스하는 생태계 VDAX, 엔클레이브-레벨 역할들을 서비스하는 하나 이상의 엔클레이브 VDAX, 코호 트-레벨 역할들을 서비스하는 하나 이상의 코호트 VDAX, 및/또는 종속 코호트 역할들을 서비스하는 하나 이상의 종속 VDAX의 임의의 적절한 조합을 포함할 수 있다. 예를 들어, 일부 예시적인 구현에서, 생태계 VDAX는, (예를 들어, CG-ESP 인스턴스를 통해) 다른 생태계 멤버들의 게놈 데이터를 생성, 할당 및 지속적 으로 수정하고, 결합 적격성을 확정하고, 링크들을 교환하고, VBLS를 생성하도록 구성될 수 있는 반면; 코호트 VDAX는 (예를 들어, 코호트 CG-ESP 인스턴스를 통해) 생태계에 관하여 게놈 데이터를 생성하거나 다른 코 호트들에 할당하는 능력을 갖지 않을 수도 있지만, 결합 적격성을 확정하고 링크들을 교환하고 VBLS를 생성하도 록 구성된다. 실시예들에서, VDAX는 생태계에 관하여 특정한 세트의 게놈 기능들을 수행하는 소프트웨어, 하드웨어, 펌웨어, 및/또는 미들웨어의 임의의 조합으로서 구현될 수 있다. 종속 코호트의 존재는 적어도 하나의 독립 코호 트에 의존한다는 점에 유의한다(예를 들어, 파일은 파일이 저장되는 디바이스에 의존하거나 애플리케이션 인스 턴스는 애플리케이션이 실행되는 디바이스에 의존한다). 따라서, 일부 실시예에서, 종속 코호트(예를 들어, 파일, 미디어 콘텐츠, 애플리케이션 등)의 종속 VDAX는, 종속 코호트가 의존하는 독립 코호트 (예를 들어, 사용자 디바이스, 스마트 디바이스, 게임 디바이스, 개인용 컴퓨팅 디바이스, 서버, 클라우드 시스템 등)에 의해 실행될 수 있다. 실시예들에서, 생태계 VDAX는 생태계 VDAX가 엔클레이브를 초기화하고 그 게놈 데이터 세트를 할당한 후에 엔클레이브들 또는 엔클레이브의 코호트들과의 어떠한 후속 상호작용도 요구하지 하지 않기 때문에, 생태계 VDAX는 디지털 생태계에 대한 보안 관련 기능들을 수행하고 생태계의 \"선조\"로서 간주될 수 있다. 실시예 들에서, 생태계는 독립적인 하위생태계들을 가능케 하도록 구성될 수 있고, 기능적 생태계-레벨 VDAX 능력들을 갖지만 1차 생태계 VDAX로부터 도출되는 복수의 하위 레벨 VDAX를 포함할 수 있다는 점에 유의한다. 실시예들에서, 생태계 VDAX는 생태계 엔클레이브들 및/또는 상응하는 엔클레이브들 내의 코호트 들(604, 606)로의 일회성 분배를 위해 상응하는 게놈 데이터 세트들을 디지털적으로 생성한다. 게놈 데이터 세 트 내의 게놈 데이터 객체들은, 유사하거나 동일한 조성들, 수학적 역량들, 및/또는 엔트로피 레벨들을 가질 수 있거나, 및/또는 각각은 상이한 목적을 수행한다. 실시예들에서, 게놈 적격성 객체들(예를 들어, CNA 또는 PNA 객체들)은, 커뮤니티 멤버들(예를 들어, 엔클레이브들 또는 코호트들)이 그들 개개의 생태계 정체성을 계산적 상관시키기 위한 핵심 게놈 역량을 제공한다. 실시예들에서, 게놈 상관관계 객체들(예를 들어, LNA 객체들)은, 또 다른 멤버와의 결합을 확립하는 멤버의 능력을 제어하는, 멤버-대-멤버 링크 교환(예를 들어, 생태계-대-엔 클레이브, 엔클레이브-대-엔클레이브, 엔클레이브-대-코호트, 코호트-대-코호트, 및/또는 이와 유사한 것)에 대 한 역량을 제공한다. 실시예들에서, 게놈 분화 객체들(예를 들어, XNA 또는 ZNA 객체들)은 VBLS 기반의 멤버 대 멤버 쌍대칭 통신들에 대한 역량을 제공한다. 실시예들에서, CNA, PNA, LNA, 및 XNA의 디지털 게놈 조성들 은 복잡하고 고유하다. 실시예들에서, CNA, LNA, XNA, 및 PNA는 복합 수학적 기능들을 이용하여 도출될 수 있 다. 본 개시내용의 일부 실시예에 따르면, 생태계 VDAX는 자신에게 할당하는 게놈 데이터 세트를 생성할 수 있 다. 게놈 데이터 세트는 하나 이상의 상이한 유형의 게놈 데이터 객체를 포함할 수 있다. 예를 들어, 일부 실 시예에서, 생태계 VDAX는, 플랫폼 인스턴스 요건들(예를 들어, 게놈 객체의 유형들, 각각의 게놈 객체의 엔트로 피 레벨들, 및 이러한 게놈 데이터 객체들을 생성하는데 이용되는 특정한 알고리즘들)에 따라, 게놈 적격성 객 체(예를 들어, CNA 객체 및/또는 PNA 객체), 게놈 상관관계 객체(예를 들어, LNA 객체), 및 게놈 분화 객체(예 를 들어, XNA 객체 또는 ZNA 객체)를 생성할 수 있다. 실시예들에서, 생태계 VDAX에 의해 초기에 생성되 고 전체 생태계에 할당된 게놈 데이터 세트는 디지털 생태계의 모든 자손 게놈 데이터 세트가 도출되 는 게놈 데이터 세트일 수 있다. 설명의 목적을 위해, 생태계 선조의 게놈 데이터 세트란, \"선조 게놈 데이터 세트\"(또는 \"선조 DNA 세트\")라고 지칭될 수 있다. 일부 실시예에서, 생태계 VDAX는 초기에 선조 게놈 데 이터 세트들을 생성할 수 있다. 예를 들어, 생태계 VDAX는, 각각의 선조 게놈 데이터 객체에 대해, 특정 한 차원을 갖는 상응하는 2원 벡터를 생성할 수 있다. 일부 실시예에서, 생태계 VDAX는 선조 게놈 데이터 세트로부터의 각각의 엔클레이브에 대한 상응하는 자손 게놈 데이터 세트를 생성할 수 있다. 일부 실시예에서, 생태계 VDAX는, 상응하는 엔클레이브에 전파되는 자손 게놈 데이터 세트(또는 \"엔클레이브 데이터 세트\")를 획득하기 위해 한 세트의 미리정의된 게놈 동작들을 이용하여 선조체 게놈 데이터 세트를 수정할 수 있다. 예를 들어, 생태계 VDAX는, 생태계 내의 각각의 상 응하는 엔클레이브에 대한 상이한 엔클레이브 게놈 적격성 객체를 획득하기 위해 계산적 복합 기능들을 이용하 여 선조 게놈 데이터 세트의 선조 게놈 적격성 객체를 수정할 수 있고; 생태계 내의 각각의 상응하는 엔클레이 브에 대해 상이한 엔클레이브 상관관계 객체를 획득하기 위해 계산적 복합 기능들을 이용하여 선조 게놈 데이터 세트의 선조 상관관계 객체를 수정하고; 생태계 내의 각각의 상응하는 엔클레이브에 대해 상이한 엔클레이브 분 화 객체를 획득하기 위해 계산적 복합 기능들을 이용하여 선조 게놈 데이터 세트의 선조 분화 객체를 수정할 수 있다. 실시예들에서, 상이한 게놈 객체들은 상이한 유형들의 데이터 구조들에서 구현되거나 및/또는 상이한 속 성들을 나타내도록 요구될 수 있기 때문에 상이한 유형들의 게놈 객체들을 수정하기 위한 기술들은 상이할 수 있다. 상이한 수정 기술들이 본 개시내용 전체에 걸쳐 설명된다. 보안 플랫폼의 일부 구현에서, 단일 엔클레 이브만 있을 수 있다는 점에 유의한다. 특정한 CG-ESP에서 구현된 다양한 기술들에 따라, 소정의 유형들의 게 놈 객체들(예를 들어, LNA 및 XNA)은 일부 또는 모든 엔클레이브(예를 들어, 동일하거나 충분히 상관됨)와 높은 상관관계를 가질 수 있는 반면, 다른 유형들의 게놈 객체들(예를 들어, 예를 들어 CNA 또는 PNA)은 각각의 상응 하는 커뮤니티 멤버들에게 고유하지만 여전히 충분히 상관된다. 자손 게놈 데이터 세트의 하나 이상의 게놈 객 체가 선조 게놈 데이터 세트로부터 미수정된 경우에도 자손 게놈 데이터 세트(예를 들어, 엔클레이브 게놈 데이 터 세트 또는 코호트 게놈 데이터 세트)가 선조체 게놈 데이터 세트(예를 들어, 선조체 게놈 데이터 세트 또는엔클레이브 게놈 데이터 세트)로부터 도출된다고 말할 수 있도록, 자손 게놈 데이터 세트의 일부 유형들의 게놈 객체들이 선조 게놈 데이터 세트의 대응하는 게놈 객체들로부터 미수정된 경우에도, 게놈 데이터 세트의 하나 이상의 다른 부분의 수정 및 자손 커뮤니티 멤버(예를 들어, 엔클레이브 또는 코호트)로의 자손 게놈 데이터 세 트의 후속 할당은 \"도출\"이라고도 지칭될 수 있다는 점에 유의한다. 실시예들에서, 엔클레이브 VDAX는, 대응하는 엔클레이브의 엔클레이브 게놈 데이터 세트를 수정하고 결과 의 자손 게놈 데이터 세트들을 엔클레이브 내의 상응하는 코호트들에 할당함으로써 대응하는 엔클레이브에 코호 트들을 추가하도록 구성될 수 있다. 일부 실시예에서, 엔클레이브 VDAX는 엔클레이브에 추가되고 있 는 각각의 새로운 독립 코호트에 대한 코호트 게놈 데이터 세트를 생성할 수 있다. 일부 실시예에서, CG- ESP는, 엔클레이브 VDAX가 대응하는 엔클레이브에 추가되거나 추가될 각각의 독립 코호트에 대 해 고유하지만 고도로 상관된 게놈 적격성 객체(예를 들어, CNA)를 생성하도록 구성될 수 있다. 이들 실시예들 중 일부에서, 생태계 VDAX 또는 엔클레이브 VDAX는, 엔클레이브 내의 임의의 쌍의 코호트들이 게놈 적격성 객체들의 고유한 상관관계를 갖도록 게놈 적격성 객체를 생성할 수 있다. 예를 들어, 일부 실시예에서, 엔클레이브 내의 각각의 코호트는, 코호트들이 높은 레벨의 상관관계를 유지하면서 고유하도록, 선조 객체 (예를 들어, 생태계 또는 엔클레이브)의 게놈 적격성에 기초하여 생성된 게놈 적격성 객체를 할당받는다. 이러 한 방식으로, 임의의 쌍의 코호트들은 그들의 상응하는 게놈 적격성 객체들의 상관관계에 기초하여 서로 결합하 기 위한 적격성을 확정할 수 있다. 일부 실시예에서, 엔클레이브의 멤버들(예를 들어, 코호트 VDAX)은 고도로 상관된(예를 들어, 동일하거나 기타의 방식으로 충분히 상관된) 게놈 상관관계 객체들 및 게놈 분화 객체들을 할당받는다. 일부 실시예에서, 한 쌍의 코호트들은 각각의 코호트의 상응하는 게놈 상관관계 객체에 기초하여 서로를 인증할 수 있고, 각각의 코호트의 상응하는 게놈 분화 객체에 기초하여 다른 코호트들로부터 그들 자신 을 분화할 수 있다. 실시예들에서, 코호트의 게놈 상관관계 객체 및 게놈 분화 객체는 별개의 객체들일 수 있 다(비록 그들이 구조에 있어서 유사하거나 동일할 수 있더라도). 대안으로서, 일부 실시예에서, 코호트의 게놈 상관관계 객체 및 게놈 분화 객체는 동일한 객체일 수 있다. 일부 실시예에서 코호트 게놈 데이터 세트는 단 하나의 엔티티(예를 들어, 디바이스, 문서, 센서 등)에만 할당 되지만, 다른 실시예들에서 커뮤니티 소유자는 코호트의 게놈 데이터 세트가 하나 이상의 추가적인 커뮤니티 멤 버에 클론되는 것을 허용할 수 있다. 예를 들어, 사용자는 그들의 직업과 관련하여 이용하는 2개의 디바이스 (예를 들어, 데스크탑 및 랩탑 컴퓨터)를 가질 수 있다. 커뮤니티 소유자는 이 시나리오에서 디바이스들에 게 놈 데이터 세트의 동일한 사본들을 할당하기로 선택할 수 있다. 이러한 방식으로, 사용자와 연관된 각각의 디 바이스는 상응하는 엔클레이브에 관해 동일한 액세스 권한들을 부여받을 수 있다. 이들 실시예들 중 일부 에서, 클론된 게놈 데이터 세트를 갖는 각각의 상응하는 디바이스는, 적격성을 독립적으로 확정하거나, 인증하 거나, 및/또는 엔클레이브 내의 다른 코호트들과 링크들을 교환할 것이 여전히 요구될 것이라는 점에 유의 한다. 일부 실시예에서, VDAX가 게놈 데이터 세트를 할당받고 디지털 생태계에 추가될 때, VDAX는 또한, 구성 데 이터(예를 들어, CG-ESP 인스턴스에 정의된 바와 같음)뿐만 아니라, 생태계에 참여하기 위해 요구될 수 있는 다 른 적절한 데이터를 수신할 수 있다는 점에 유의한다. 이러한 구성 데이터는, 적격성 상관관계, 링크 스폰, 링 크 호스팅, 서열 맵핑, LNA 수정, XNA 수정, 2진 객체 변환 등의 게놈 동작들을 수행할 때 VDAX가 올바른 게놈 기능들을 이용하는 것을 허용할 수 있다. 이들 실시예들에서, 이러한 구성 데이터는 커뮤니티 멤버들이 다른 커뮤니티 멤버들과 성공적으로 결합하고 데이터를 교환하는 것을 허용한다. 일부 실시예에서, VDAX는 또한, 커 뮤니티 멤버를 고유하게 식별하는 게놈 커뮤니티 자손(GCP; genomic community progeny) 데이터를 수신할 수 있 다. 이들 실시예들에서, GCP는 코호트들의 결합 적격성을 확정하는데 이용될 수 있다. 일부 실시예에서, 코호트 VDAX는 독립 코호트를 대신하여 게놈 보안 동작들 및 프로세스들을 수행하 도록 구성될 수 있다. 일부 실시예에서, 코호트 VDAX는 충분히 상관된 커뮤니티 멤버들(예를 들어, 엔클 레이브 내의 다른 코호트들)과의 데이터 교환을 용이화한다. 이들 실시예들 중 일부에서, 또 다른 커뮤니 티 멤버와의 데이터 교환의 용이화는, 결합 적격성(예를 들어, 결합 무결성 및 결합 동기화)을 확정하고 다른 상응하는 커뮤니티 멤버(예를 들어, 또 다른 독립 코호트)와 링크를 교환하는 것을 포함할 수 있다. 일부 실시예에서, 결합 적격성 및 링크 교환을 확정하는 것은, 일단 한 쌍의 코호트들이 이 \"핸드셰이크\"를 성공적으 로 완료하고 나면, VDAX 쌍이 높은 상관된 (예를 들어, 동일하거나 충분히 상관된) 분화 객체들을 계속 공유하 는 한, 안전하게 데이터를 교환할 수 있도록 일회성 프로세스이다. 예를 들어, 한 쌍의 VDAX들은, 그들이 공통 분화 객체를 더 이상 공유하지 않는 한 초기에 결합 적격성을 확정하고 링크를 교환할 수 있으며, VDAX들은, 며 칠, 몇 주, 몇 달 또는 몇 년 동안 계속해서 안전하게 통신할 수 있다. 일단 코호트들이 공통 분화 객체들을더 이상 공유하지 않게 되면, 그들은 데이터 교환을 시도할 수 있지만 다른 상응하는 코호트에 의해 제공되는 어떠한 인코딩된 디지털 객체들도 더 이상 디코딩할 수 없을 것이다. 실시예들에서, 한 쌍의 VDAX들은 상응하는 VDAX들에 의해 생성 및 디코딩되는 가상 2진 언어 스크립트(VBLS)를 통해 서로 결합한다. 논의된 바와 같이, VBLS란, 고유하고 비반복적인 (또는 극소 확률로 반복되는) 2진 언어 들을 지칭할 수 있다. 실시예들에서, VBLS의 개개의 인스턴스들은 VBLS 객체들이라고 지칭될 수 있다. 실시예 들에서, 제1 VDAX(예를 들어, 코호트 VDAX 또는 엔클레이브 VDAX)는, 제2 VDAX에 의해 제1 VDAX에 제공되는 링크에 인코딩된 게놈 조절 명령어들(GRI) 및 제1 VDAX의 게놈 데이터(예를 들어, XNA)에 기초하여 제 2 VDAX(예를 들어, 코호트 VDAX 또는 엔클레이브 VDAX)에 대한 VBLS 객체를 생성할 수 있다. 이들 실시예들에서, 제2 VDAX는 제1 VDAX로부터 VBLS 객체들을 수신할 수 있고 제1 VDAX로의 링크에서 제공된 GRI 및 VDAX의 게놈 데이터 세트에 기초하여 VBLS를 디코딩할 수 있다. 일부 실시예에서, VBLS 객체는 VBLS 객체에 포 함된 인코딩된 디지털 객체를 디코딩하기 위해 제2 VDAX가 처리하는 메타데이터를 포함한다. 예를 들어, 일부 실시예에서, VBLS 객체는, 패킷 헤더 및 인코딩된 디지털 객체(예를 들어, 페이로드)를 포함하는 데이터 패킷이 다. 이들 실시예들 중 일부에서, 인코딩된 디지털 객체를 디코딩하는데 이용되는 메타데이터는, 디지털 객체의 하나 이상의 프로토콜 계층(예를 들어, TCP, UDP, TLS, HTTP, H.256, 또는 임의의 다른 적절한 프로토콜 계층 유형들)에서 나타나는 공개 서열 또는 사적 서열을 포함한다. 실시예들에서, 제1 VDAX는 서열(예를 들어, 공개 또는 사적 서열) 및 제1 VDAX의 게놈 분화 객체에 기초하여 게 놈 결합 인자를 결정함으로써 제2 디지털 객체에 제공될 디지털 객체에 대응하는 VBLS 객체를 생성할 수 있다. 실시예들에서, 제1 VDAX는 제2 VDAX에 의해 제공되는 링크에서 제2 VDAX에 의해 제공되는 GRI에 따라 그 게놈 분화 객체를 수정하고 디지털 객체(예를 들어, 디지털 객체 내의 프로토콜 또는 포맷 데이터)에 포함된 서열(또 는 이로부터 도출된 값)을 수정된 게놈 분화 객체에 맵핑하여 게놈 결합 인자를 획득한다. 실시예들에서, 제1 VDAX는 수정된 게놈 분화 객체에 서열을 맵핑하기 위해 계산적 복합 기능(예를 들어, 암호 기반의 기능, 비암호 기반의 기능, 또는 하이브리드 기능들)을 이용할 수 있다. 그 다음, 제1 VDAX는 게놈 결합 인자를 이용하여 디 지털 객체(예를 들어, 패킷 페이로드, 파일의 샤드, 비디오 또는 오디오 프레임, 또는 임의의 다른 적절한 유형 의 디지털 객체)를 인코딩하여 인코딩된 디지털 객체를 획득할 수 있다. 실시예들에서, 제1 VDAX는 게놈 결합 인자에 기초하여 디지털 객체를 인코딩하기 위해 계산적 복합 기능(예를 들어, 암호화 기능 또는 명료화/XOR 기 능)을 활용한다. 그 다음, 제1 VDAX는 메타데이터(예를 들어, 서열) 및 인코딩된 디지털 객체를 포함하는 VBLS 객체를 (예를 들어, 네트워크 및/또는 데이터 버스를 통해) 제2 VDAX에 제공할 수 있다. 실시예들에서, 제2 VDAX는 VBLS 객체를 수신하고, VBLS 객체 및 제2 VDAX의 게놈 분화 객체에 포함된 메타데이 터에 기초하여 VBLS 객체에서 인코딩된 디지털 객체를 디코딩할 수 있다. 실시예들에서, 제2 VDAX는, VBLS 객 체로부터 서열(예를 들어, 데이터 패킷 또는 데이터 프레임의 암호화되지 않은 공개 또는 사적 서열 부분)를 추 출하도록 구성된다. 제2 VDAX는 또한, 제2 VDAX가 게놈 결합 인자를 획득하기 위해 동일한 계산적 복합 기능을 이용하여 서열(또는 이로부터 도출된 값)을 수정된 게놈 분화 객체로 맵핑하도록, (예를 들어, 링크 교환 프로 세스 동안) 제1 VDAX에 제공된 링크에 포함된 GRI를 이용하여 그 게놈 분화 객체를 수정할 수 있다. 제1 VDAX 및 제2 VDAX가 정합하는(또는 일부 실시예에서 충분히 상관된) 게놈 분화 객체들을 갖고 양쪽 모두가 상응하는 게놈 분화 객체들을 수정하기 위해 동일한 명령어들을 이용한다고 가정하면, 동일한 서열 및 수정된 게놈 분화 객체가 주어질 때 동일한 게놈 결합 인자가 생성될 것이다. 실시예들에서, 제2 VDAX는 동일한 게놈 결합 인자 에 기초하여 디지털 객체를 디코딩하기 위해 기능(예를 들어, 해독 기능 또는 명료화/XOR 기능)을 활용한다. 이러한 방식으로, 제1 VDAX와 제2 VDAX는, 제2 VDAX에 의해 제1 VDAX에 제공되는 링크를 소유하지 않는 다른 커 뮤니티 멤버는 동일한 방식으로 그들의 게놈 분화 객체를 수정할 수 없기 때문에, 동일한 게놈 분화 객체를 공 유하는 다른 커뮤니티 멤버들로부터 그들 자신들을 고유한 방식으로 분화할 수 있다. 따라서, 다른 커뮤니티 멤버들은, 이들 커뮤니티 멤버들이 동일한 계산적 복합 맵핑 기능을 실행하도록 구성되고 공개 서열을 결정할 수 있는 경우에도 게놈 결합 인자를 생성할 수 없을 것이다. 게놈 데이터에 액세스할 수 없는 침입하는 또는 기타의 악의적인 디바이스는, 이들 침입자들이 : 게놈 결합 인자를 생성하는데 이용된 계산적 복합 기능들, 서 열들을 추출하는 방법, 또는 공통 게놈 분화 객체 중 하나 이상을 모를 수 있기 때문에 더욱 제한될 것이다. 따라서, 그들은, 무차별 대입 방법들 없이는 게놈 결합 인자를 결정할 수 없을 것이다. 또한, CG-ESP는, 제1 VDAX가 모든 디지털 객체(예를 들어, 모든 데이터 패킷, 파일 샤드, 비디오 프레임, 오디오 프레임 등)에 대해 새로운 게놈 결합 인자를 계산하도록 구성될 수 있으며, 각각은 인코딩 VBLS 객체는 디지털 객체에 대한 별도의 무차별 대입 결정을 요구하므로, VBLS가 제2 VDAX 양자 증거에 대해 제1 VDAX에 의해 생성되게 한다. 일부 실시예에서, VBLS 객체 내의 메타데이터는 데이터 무결성 정보를 더 포함할 수 있다. 예를 들어, 데이터 무결성 정보는, 일반 데이터에 대해 제1 VDAX에서 계산된 다음 서열로서 이용되는 값일 수 있다. 이러한 방식 으로, 제2 VDAX는 VBLS 객체가 변조되지 않았는지를 확인할 수 있다. 실시예들에서, 디지털 객체들은, OSI 컴포넌트들(예를 들어, 레벨 2-7 컴포넌트들) 및/또는 컴퓨터 실행가능형 코드/명령어들을 지칭할 수 있다. 디지털 객체들의 예들은, 패킷들, 섹터들, 프레임들, 및 서열들을 포함한다. VBLS는, 엔클레이브 또는 코호트가 또 다른 엔클레이브 또는 코호트에게 말하는 언어들로서 수신자 엔클레이브 또는 코호트에 의해 고유하게 이해되는 언어들 ―즉, 수신자 엔클레이브 또는 코호트에 의해서만 이해될 수 있 는 언어들을 지칭할 수 있다. 이러한 방식으로, 비인가된 코호트들, 바이러스들, 및/또는 맬웨어를 포함하려는 침입자들은 인가된 코호트들 사이에서 VBLS를 생성하거나 해독할 수 없다. 전술한 논의는 CG 지원형 디지털 생태계의 한 예로서 제공된 것임을 이해할 것이다. CG-ESP의 상이한 구 성들은 상이한 기능들 및 동작을 수행할 수 있고 상이한 CG-ESP 모듈들을 가질 수 있다는 것을 이해할 것이다. 예를 들어, CG-ESP의 상이한 구성들은, 상이한 암호화 기능들, 상이한 해시 기능들, 상이한 서열 맵핑 기능들, 상이한 유형들의 게놈 조성들 등을 이용할 수 있다. CG-ESP는 상이한 아키텍쳐를 가능케할 수 있는 상이한 생 태계들에 대해 구성될 수 있다는 점에 더 유의한다. 도 7 내지 도 12은 상이한 유형들의 디지털 생태계들 및 대응하는 아키텍쳐들을 나타낸다. 동시대 네트워크 능 력들은 그들의 기저 배치 아키텍쳐를 상당히 반영한다. 실시예들에서, 게놈 조성들을 이용하여 VBLS를 가능케 하는 CG 지원형 아키텍쳐들은 비트 레벨에서 동작할 수 있으므로, 기저 배치 아키텍쳐와 상호운용가능한 상태로 유지될 수 있다. VBLS는, 네트워크, 소프트웨어, 및/또는 하드웨어 중심 아키텍쳐들에 대해 애플리케이션을 고 유하게 맞춤화할 수 있는 전례없는 기능들과 유연성을 제공한다. CG-ESP 생태계 아키텍쳐들의 예들은, 정적 생 태계들을 지원하는 지시된 아키텍쳐들, 일시적인 생태계들에 대해 구성된 자유 형태 아키텍쳐들, 동적 생태계들 을 지원하는 자발적 아키텍쳐들, 실행가능한 생태계들을 지원하는 임시 아키텍쳐들, 및 긍정 생태계들을 지원하 는 인터렛져 아키텍쳐들을 포함할 수 있지만, 이들로 제한되는 것은 아니다. 실시예들에서, 기존의 물리적 네 트워크 토폴로지들을 오버레이할 수 있는 이들 아키텍쳐들은, 게놈 조성된 토폴로지들을 입증한다. 일부 실시 예에서, 복수의 게놈 조성된 토폴로지들이 동시에 및 상호운용가능케 존재할 수 있다. 예를 들어, 컴퓨팅 디바 이스는, 컴퓨팅 디바이스의 내부 컴포넌트들이 VBLS를 교환하도록 실행가능한 생태계일 수 있으며; 동시에, 컴 퓨팅 디바이스는, 컴퓨팅 디바이스가 상이한 세트의 게놈 데이터를 이용하여 정적 생태계의 다른 디바이스들과 결합할 수 있도록 정적 생태계의 멤버일 수 있다. 도 7을 참조하면, 이러한 생태계들과 이들 생태계들에 참여하는 엔클레이브들 및 코호트들의 피처들이 상당히 안정적인 구성을 나타내므로, 지시된 아키텍쳐는 정적 생태계에서 구현될 수 있다. 예를 들어, 기업 배치에서, 대다수의 사용자들은 유사한 디바이스들(예를 들어, 데스크탑들, 랩탑들 및 모바일 디바이스들), 이메일 클라이 언트들, 소프트웨어 솔루션들(클라우드 기반의 및 로컬 실행되는 양쪽 모두), 디바이스들(예를 들어, 프린터들, IoT 디바이스들)을 이용할 것이며, 이들 모두는 시간이 지남에 따라 크게 변하지 않을 것이다. 이들 생태계들 은 유연성의 손실이나 억압없이 관계 안정성을 제공한다. 이들 아키텍쳐들의 속성들은 고유하게 확장되고 강화 되어 단독으로 이용될 수 있다. 일부 예시적인 실시예에서, 자유 형태 아키텍쳐들과는 대조적으로, 정적 아키 텍쳐들에 의해 인에이블될 수 있는 대비책은 상관이 실행되고 관리되는 방식일 수 있다. 정적 아키텍쳐들의 경 우, 단일 생태계 VDAX에 의해 제공되는 공통 게놈 조성들에 기초하여 상관이 달성된다. 실시예들에서, 지시된 아키텍쳐들은 생태계 VDAX가 특정한 게놈 상관관계 및 분화를 나타내는 하나 이상의 엔클 레이브를 확립하는 구성들을 반영한다. 이들 실시예들 중 일부에서, 각각의 엔클레이브 VDAX는, 특정한 게놈 상관관계 및 분화를 역시 나타내는, 하나 이상의 코호트를 대응적으로 확립할 수 있다. 실시예들에서, 이러한 생태계, 엔클레이브, 및 코호트 구성은, 계층적 게놈 상관관계 및 분화를 나타낼 수 있으며, 이것은 지시된 아 키텍쳐들에서 유리할 수 있다. 실시예들에서, 지시된 아키텍쳐들, 생태계, 엔클레이브, 및 코호트 VDAX들은 복 수의 게놈 상관관계들 및 분화 속성들을 가질 수 있다. 예를 들어, 지시된 아키텍쳐들에서의 엔클레이브들은 종속 엔클레이브들 및 코호트들 양쪽 모두를 전파할 수 있다. 실시예들에서, 상이한 아키텍쳐들은 상이한 상관 관계 속성들을 나타내도록 구성될 수 있다. 예를 들어, 지시된 아키텍쳐들은 본질적으로 공통 상관관계를 나타 낼 수 있는, 반면 자유 형태 아키텍쳐들은 준비된 공통 상관관계를 나타낼 수 있다. 실시예들에서, 게놈 상관관계 및 분화는 지시된 아키텍쳐들이 물리적 토폴로지를 수정할 필요 없이 게놈 네트워 크 토폴로지들을 구성할 수 있게 한다. 예를 들어, 이들 실시예들에서, 커뮤니티 소유자는, 상이한 엔클레이브 들 내의 (예를 들어, 링크 교환을 통한) 코호트들 사이의 결합이 상이한 엔클레이브 멤버들에게 제공되는 LNA 및/또는 XNA를 제어함으로써 커뮤니티에 의해 방지될 수 있도록 상이한 LNA 및 XNA를 이용하여 상이한 엔클레이브들 내의 코호트들의 결합을 제어할 수 있다. 유사하게, 이들 예들에서, 커뮤니티 소유자는 역시 상이한 코호 트들에 제공되는 LNA 및 XNA를 제어함으로써 새로운 엔클레이브를 생성할 수 있다. 실시예들에서, 지시된 아키텍쳐들에 의해 인에이블된 게놈 토폴로지들은 점진적으로 게놈적으로 수정될 수 있다. 이들 실시예들 중 일부에서, 커뮤니티 소유자는 임의의 수의 고려사항들(예를 들어, 보안, 더 이상 존재 하지 않는 코호트 제거, 엔클레이브 해결 등)을 위해 일부 또는 모든 생태계 및/또는 엔클레이브 멤버들의 소정 의 게놈 조성들(예를 들어, XNA 및/또는 LNA)을 주기적으로 수정할 수 있다. 도 7은 지시된 아키텍쳐를 갖는 CG 지원형 생태계의 한 예를 나타내며, 이에 의해 생태계는 정적 생 태계이다. 실시예들에서, 정적 생태계들은, 로컬, 내부적으로 관리되지만 분산된, 원격 주문형 IT 자원들 및 능력들을 포함하도록 더 전통적인 배치를 지원하는 엔클레이브들 및 코호트들을 포함한다. 정적 생태계들은 원 활한 성능과 보안을 요구한다. 이들 배치들은 종종 엔터프라이즈급 조직들 및 기관들에서 흔히 볼 수 있지만, 그들의 복잡성으로 인해, 중소기업(SMB)에 대해서는 보안은 어려운 과제였다. 이들 구현들은 비교적 정적이고 중앙에서 관리되는 경향이 있다. 예를 들어, 정적 생태계에서 사업부는 공통 세트의 파일들에 액세스(예를 들 어, 읽기, 쓰기 및/또는 편집)하는 것이 허용된 다수의 직원을 포함할 수 있다. 또한, 직원들은 특별 프로젝트 들(예를 들어, 제품 출시)에 관해 작업할 수 있으며 이들 직원들은 전형적으로 또 다른 공통 세트의 파일들에 액세스하는 것이 허용된다. 일부 시나리오에서, 커뮤니티 소유자(예를 들어, IT 관리자 또는 기업과 제휴된 임 의의 다른 당사자로 대표됨)는 소정의 파일들 또는 폴더들, 각각의 코호트가 속한 하나 이상의 엔클레이브, 각 각의 코호트가 디지털적으로 결합할 수 있는 코호트들 및/또는 엔클레이브들(예를 들어, 프린터들, 로컬 파일 서버들 등)과 관련하여 개개의 코호트에게 부여될 수 있는 액세스 유형을 정의하는 한 세트의 정책들, 및/또는 기타 적절한 정책들을 정의할 수 있다. 논의된 바와 같이, 이러한 정책들은, 생태계 전반에 걸쳐 허용가능한 관계들 및 게놈 토폴로지들을 정의하는데 이용될 수 있는 XNA, CNA, PNA 및 LNA 등의 게놈 조성들을 이용하여 시행될 수 있다. 실시예들에서, 보안 플랫폼은 디지털 생태계가 정적 생태계일 때 지시된 아키텍쳐로서 구현될 수 있다. 지시된 아키텍쳐를 이용하여, 생태계 VDAX(예를 들어, 사적 VDAX)는 정적 생태계에 대응하는 하나 이상의 엔클레이브를 정의한다. 도 7의 예에서, 생태계 VDAX는, 제1 엔클레이브(704-1) 및 제N 엔클레이브(704- N)를 포함하는 N개의 엔클레이브를 계층적 방식(예를 들어, 지시된 아키텍쳐)으로 정의했다. 각각의 엔클 레이브(704-1, ... 704-N)에 대해, 생태계 VDAX는 엔클레이브(704-1)에 대한 (엔클레이브 VDAX를 실행하 는) 엔클레이브 VDAX를 생성할 수 있고 하나 이상의 코호트를 엔클레이브(704-1)에 할당할 수 있다. 이 예에서, 제1 엔클레이브(704-1) 및 제N 엔클레이브(704-N)의 코호트들은, 워크스테이션들, 태블릿들, 로컬 데이터 센터들, 프린터들, IoT 디바이스들, 모바일 디바이스들 등을 포함한다. 이 예에서, 각각의 엔클레이브 내의 라우터는 코호트로서 간주되지 않고 VBLS를 이용하여 통신하지 않는다는 점에 유의한다. 오히려, 각각의 라우터는 VBLS를 포함하는 데이터 패킷들을 엔클레이브 내의, 생태계 내의 코호트들에 및/또는 임의의 더 넓은 네트워크(예를 들어, 인터넷)에 라우팅하는 통과 디바이스이다. 라우터들이 코호트들인 실시예 들에서, 각각의 라우터는 그 자신의 게놈 데이터 세트(XNA, LNA, 및 CNA)를 가질 수 있고, 엔클레이브 내 의 다른 코호트들은 라우터만이 이해할 수 있는 VBLS를 이용하여 라우터와 통신할 것이다. 이러한 결정들 은 커뮤니티 소유자 또는 CG-ESP 제공자가 내릴 수 있는 설계 선택사항들이라는 점을 이해해야 한다. 이 예에 서 클라우드 시설들은 생태계의 엔클레이브들이 아니라는 점에도 유의해야 한다. 이 예에서, 클라우 드 시설들은 제3자 애플리케이션들 및/또는 데이터를 호스팅한다. 일부 예시적인 실시예들에서, 생태계 의 생태계 VDAX는 제3자 애플리케이션 시스템의 VDAX(미도시) 및/또는 클라우드 시설과의 배열을 협 상하여 지시된 생태계의 코호트들에 상관된 게놈 물질들을 획득하도록 구성될 수 있고, 이로써 생태계와 제3자 애플리케이션 시스템/클라우드 시설 사이의 인증, 링킹, 및 결합을 가능케한다. 추가적으로 또는 대안으로서, 커뮤니티 소유자는, 커뮤니티 소유자가 LNA 및 XNA 조성을 통해 생태계에 대한 제3자 서비스 제공자의 액세스를 특정한 용도로 제한할 수 있도록, 소정의 제3자 서비스 제공자들(예를 들어, 클라우드 서비스들)이 코호트로서 생태계에 추가될 수 있다고 결정할 수 있다. 이러한 방식으로, 제3자 서비스는 유사한 LNA를 가진 다른 코호트 들(예를 들어, 제3자 서비스의 의도된 사용자들)과만 링크들을 교환할 수 있다. 마찬가지로, 제3자 서비스 제 공자와의 관계가 종료되면, 커뮤니티 소유자는 XNA 수정을 통해 제3자 서비스 제공자를 철회할 수 있다. 일부 실시예에서, 엔클레이브의 엔클레이브 VDAX(또는 생태계 VDAX)는 게놈 물질을 생성하고 엔클레이브 내의 각각의 코호트의 VDAX들에 할당할 수 있다. 실시예들에서, 생태계 VDAX는 각각의 상응하 는 엔클레이브에 대한 게놈 정보(예를 들어, XNA, LNA, 및 CNA)를 생성한다. 그 게놈 정보를 수신하는 것에 응 답하여, 엔클레이브 VDAX는 엔클레이브에 포함된 각각의 코호트에 대한 상응하는 게놈 정보를 생성할수 있다. 예를 들어, 엔클레이브 VDAX(또는 생태계 VDAX)는 새로운 코호트들에 할당되는 CNA를 생성할 수 있거 나 및/또는 엔클레이브의 멤버들에게 그 LNA 및/또는 XNA를 제공할 수 있다. CG-ESP의 구성 및 그 게놈 조성들에 따라, 엔클레이브에 허용된 2개의 코호트 VDAX가 링크 교환에 참여할 것이 요구될 수 있다. 일단 2개 의 코호트 VDAX가 링크 교환에 참여하고 나면, 이들은 호스트된 링크(들)에 기초하여 VBLS 교환을 시작할 수 있 다. 지시된 아키텍쳐에서, 생태계 소유자는 (예를 들어, 생태계 VDAX를 통해) 코호트 및/또는 엔클레이브 의 XNA 및/또는 LNA의 수정을 개시함으로써 엔클레이브들 및/또는 엔클레이브들 내의 코호트들 의 보안 피처들을 관리할 수 있다. 예를 들어, 어떤 직원이 더 이상 사업부의 일부가 아닌 경우, 소정의 자원들(예를 들어, 문서들, 프린터들, 파일 시스템들 등)에 대한 직원의 액세스가 철회될 수 있다. 실시예들에 서, VDAX는, 제거된 직원에 대응하는 코호트들에 대한 동일한 XNA 수정을 개시하지 않고 엔클레이브 및/또는 생태계에 머무를 코호트들(및 일부 시나리오에서는 LNA)의 XNA의 수정을 개시함으로써 직원 의 코호트들(예를 들어, 워크스테이션, 모바일 디바이스 등)에 대한 액세스를 \"철회\"할 수 있다. 또 다른 예에 서, 직원이 문서들의 제1 폴더와 문서들의 제2 폴더에 대한 액세스 권한이 있고 제1 폴더에 대한 직원의 액세스 권한은 철회되지만 제2 폴더에 대한 액세스 권한은 철회되지 않는 경우, VDAX는, 제2 폴더에 대한 액세스가 철 회된 직원의 코호트(들)에 수정을 제공하지 않고 엔클레이브의 다른 코호트들의 DNA 및 LNA와 제2 폴더의 XNA의 수정을 개시할 수 있다. 이들 제공된 예들에서, 커뮤니티 소유자는 게놈 조성들(예를 들어, LNA 및/또는 XNA) 을 이용하여 상이한 엔클레이브들에서의 코호트들의 결합을 제어할 수 있다. 전술한 논의는 지시된 아키텍쳐들의 몇몇 예시적인 구현을 제공한다는 것을 이해할 것이다. CG-ESP들은 본 개 시내용의 범위를 벗어나지 않고 다른 적절한 생태계들에서 지시된 아키텍쳐들에 따라 구성될 수 있다는 것을 이 해할 것이다. 이제 도 8을 참조하면, 자유 형태 아키텍쳐들은 잠재적으로 무관한 생태계들, 엔클레이브들, 및 코호트들을 특 징으로 한다. 이러한 생태계들에서, 엔클레이브의 구성들(예를 들어, 제한된 수의 사용자들, 디바이스들 등)은 상당히 안정적이지만 상호 관심 ID에 따라 변경될 수 있다(예를 들어, 생태계의 변경은 정적 생태계들에서보다 예측하기 어렵다). 따라서, 자유 형태 아키텍쳐들은 유연성의 손실이나 억제 없이 관계 안정성을 제공할 수 있 다. 일부 실시예에서, 이들 아키텍쳐들의 속성들은 고유하게 확장 및 강화될 수 있으므로, 단독으로 이용될 수 있다. 실시예들에서, 정적 아키텍쳐들과는 대조적으로 자유 형태 아키텍쳐들에 의해 인에이블될 수 있는 대책 은 상관이 실행되고 관리되는 방식이다. 자유 형태 아키텍쳐들의 경우, 공통 게놈 상관관계는 정적 아키텍쳐의 경우와 동일한 기초로 달성될 수 없으며, 이것은 자유 형태 등의 공통 게놈 상관관계를 용이화하기 위해 대안적 인 게놈 하위조성의 이용에 의해 달성된다. 실시예들에서, 자유 형태 아키텍쳐는 애플리케이션 특유의 네트워크 토폴로지들의 게놈 조성을 용이화할 수 있 다. 예를 들어, 일부 실시예에서, 생태계 VDAX들은, 고유한 게놈 상관관계 및/또는 분화 조성들(예를 들어, LNA 및/또는 XNA)을 독립적으로 개시한다. 일부 실시예에서, 지시된 아키텍쳐의 엔클레이브 VDAX들 및/또는 코 호트 VDAX들은 고유한 게놈 상관관계 조성들을 직접 취득할 수 있다(예를 들어, LNA). 예를 들어, 생태계 VDAX 는 게놈 조성 생성 및 수정을 통해 어느 코호트들이 어느 엔클레이브들에 속해야 하는지를 제어할 수 있다. 실시예들에서, 자유 형태 아키텍쳐들에서의 생태계 VDAX들은 대안적인 게놈 하위조성들을 통해 그들의 고유한 게놈 상관관계 조성들을 취득할 수 있다. 이들 실시예들 중 일부에서, 각각의 생태계 VDAX는 상관관계 및 분화 속성들이 도출되는 고유한 게놈 조성을 가질 수 있다. 이들 실시예들 중 일부에서, 이들 도출된 속성들은 생태 계의 엔클레이브들의 게놈 토폴로지를 제어한다. 이들 실시예들 중 일부에서, 각각의 엔클레이브는 (예를 들어, 그 엔클레이브 VDAX를 통해) 상관관계 및 분화 속성들이 도출되는 고유한 게놈 조성을 가질 수 있으며, 이들 속성들은 엔클레이브의 코호트들(예를 들어, 코호트 VDAX들)의 게놈 토폴로지를 제어한다. 실시예들에서, 물리적 네트워크 토폴로지들을 오버레이하는 복수의 게놈 조성된 토폴로지들은 동시에 및 상호운용가능한 방식 으로 존재할 수 있다. 일부 실시예에서, 게놈 기반의 디지털 네트워크 토폴로지들은 물리적 또는 논리적 디지 털 네트워크들을 인에이블하는데 이용되는 기저 기술들과는 독립적이다. 이들 실시예들에서, 게놈 기반의 디지 털 네트워크들은 그들의 토폴로지들을, 일부 시나리오에서는, 게놈 조성 지원형의 VBLS에만 의존할 수 있게 한 다. 도 8은 상호작용 생태계를 서비스하는 자유 형태 아키텍쳐를 갖는 보안 플랫폼의 한 예를 나타낸다. 실시 예들에서, 상호작용 생태계는 하나 이상의 엔클레이브(예를 들어, 사적 엔클레이브, 홈 오피스, 소규 모 사업체 등)를 포함할 수 있고, 각각의 엔클레이브는, 상호 관심 ID를 공유하고 서비스들과 애플리케이션들이상호작용하지만 사용자 제어형 보안을 요구하는 광범위한 네트워크 지원형 웹 포털들(예를 들어, Facebook, Amazon, 은행 서버들, 의료 서버들 등)과 상호작용할 수 있는 하나 이상의 코호트(예를 들어, 컴퓨터들, 기기들, 허브들, 미디어 디바이스들, IoT 디바이스들, 착용형 디바이스들, 스마트 스피터들 등)를 포함할 수 있 다. 상호작용 생태계의 한 예는 홈 네트워크, 소규모 사무실 네트워크 등일 수 있다. 자유 형태 아키텍쳐에서, 생태계 내의 코호트는 생태계의 VDAX로서 지정될 수 있다. 예를 들어, 사용자는 생태계의 VDAX로 동작하도록 모바일 디바이스, 데스크탑 또는 라우터를 지정할 수 있 다. 또한, VDAX를 통해, 사용자는 (예를 들어, 사용자 인터페이스를 통해) 하나 이상의 엔클레이브를 정 의할 수 있다. 예를 들어, 일부 상황에서, 사용자는 단일 엔클레이브(예를 들어, 사용자와 연관된 모든 디바이스)를 정의할 수 있다. 또 다른 예에서, 사용자는, 상이한 가족 멤버들, 상이한 디바이스 클래스들, 및/ 또는 다른 논리적 공통성들에 대해 상이한 엔클레이브들(예를 들어, 부모에 의해 이용되는 디바이스들에 대한 엔클레이브, 미성년자에 의해 이용되는 디바이스들에 대한 엔클레이브, 및 온도조절기들, 가전기기들, 텔 레비전들, 스피커들 등의 스마트 디바이스들에 대한 엔클레이브)을 정의할 수 있다. 실시예들에서, 사용자는, VDAX를 통해, 엔클레이브들 및/또는 개개의 디바이스들에 대한 하나 이상의 설정(예를 들어, 규칙들, 정책들, 블랙리스트들, 화이트리스트들 등)을 정의할 수 있다. 이들 파라미터들은, 엔클레이브 또는 코호 트의 게놈 데이터(예를 들어, XNA, LNA, CNA 및/또는 PNA)를 생성할 때 이용될 수 있다. VDAX는 각 각의 엔클레이브에 대한 게놈 데이터를 생성할 수 있다. 일부 실시예에서, VDAX는 또한, 각각의 코 호트(독립 및 종속)에 대한 게놈 데이터를 생성할 수 있다. 다른 실시예들에서, 또 다른 디바이스는 엔클레이 브 VDAX를 호스팅할 수 있고, 이에 의해 엔클레이브 VDAX는 엔클레이브에서 코호트들의 XNA, LNA, PNA 및/또는 CNA를 생성한다. 상호작용 생태계에서, 코호트가 액세스할 수 있는 외부 시스템들은 광범위하다. 예를 들어, 사용자 는, 웹 포탈들에 액세스하여 비디오를 스트리밍하거나, 소셜 미디어 플랫폼에 액세스하거나, 웹사이트들을 방문 하거나, 이메일 및 메시지를 읽거나, 첨부물을 여는 등을 위해 자신의 워크스테이션 또는 모바일 디바이스를 이 용할 수 있다. 유사하게, 사용자는, 움직임을 검출하거나, 오디오를 녹음하거나, 비디오를 캡처하거나, 사용자 또는 사용자의 집이나 사무실과 관련된 센서 측정값들 또는 기타의 데이터를 기록할 수 있는 디바이스들을 집에 가지고 있을 수 있다. 이들 디바이스들은 또한, 웹 포털들에 액세스하여 데이터를 보고하거나 웹 포털의 서비 스(예를 들어, 상품 주문, 온도조절기 조정 등)를 활용한다. 전자의 예에서 사용자는 개인정보 보호 및/또는 악성 소프트웨어(예를 들어, 바이러스 또는 맬웨어)가 디바이스에 설치되는 것을 염려할 수 있다. 후자의 예에 서, 사용자들은 개인정보 보호에 관심을 가질 수 있다(예를 들어, 누가 스마트 디바이스들 또는 알 수 없는 감 시에 의해 캡처된 데이터에 액세스했는지). 상호작용 생태계에서, 자유 형태 아키텍쳐로서 구현된 보안 플랫폼은 이들 염려를 완화한다. 일부 실시예에서, 생태계의 VDAX는 포털의 VDAX(미도시)와 보 안 관계를 협상할 수 있다. 이들 실시예들 중 일부에서, 사용자 및 웹 포털의 VDAX들은 상관된 게놈 데이터를 생성한다. 이들 실시예들에서, 상호작용 생태계의 VDAX는 웹 포털에 액세스를 시도하는 코호트에 대 한 게놈 데이터를 (예를 들어, 코호트의 VDAX를 통해) 생성할 수 있다. 코호트가 웹 포털에 액세스하려고 시도할 때, 코호트 및 웹 포털은 대응하는 VDAX 쌍이 적격성-무결성 및/또는 동기화를 확정하고 궁극 적으로 링크들을 교환하는 것을 허용하는 결합 정보를 생성 및 교환한다. 일단 웹 포털 및 코호트가 링크들을 스폰 및 교환하고 나면, 코호트 및 웹 포털은 각각 상대방의 링크를 호스팅할 수 있다. 코 호트는 웹 포털에 의해 스폰되고 호스팅된 링크를 이용하여 웹 포털에 전송되는 VBLS를 생성할 수 있고, 웹 포털은 코호트에 의해 스폰된 링크를 이용하여 코호트에 전송되는 VBLS를 생성할 수 있다. 전술한 예는 자유 형태 아키텍쳐의 하나의 예일 뿐이고, 다른 구현들은 본 개시내용의 범위 내에 있 다. 이제 도 9를 참조하면, 메트릭(예를 들어, 시간, 데이터, 조건, 수요, 좌표, 동작, 상대적 위치, 및 이벤트) 상 태들에서의 매우 동적인 변화들에 종속되는 애플리케이션들 및 서비스들을 지원하도록 자발적 아키텍쳐가 구현 될 수 있다. 예를 들어, 자율 자동차 관리 시스템은, 제어 그리드가 도로의 트래픽 상황에 기초하여 동적으로 제어되는 제어 그리드를 통해 이동하는 자율 차량들의 생태계를 관리할 수 있다. 실시예들에서, 이 그리드 토 폴로지는 환경 및 상태의 매우 동적인 변화의 지원을 가능케하도록 동적으로 재구성될 수 있다. 추가 예에서, 자발적 아키텍쳐는, 코호트들이 끊임없이 변화하고 환경에 대해 고도로 동적인 보안 응답들을 가질 수 있는 항 공 트래픽 제어 시스템 또는 군사 극장 또는 드론 떼를 제공할 수 있다. 실시예들에서, 자발적 토폴로지는 상 황 이벤트들에 응답하여 DNA를 변경함으로써 변경될 수 있다. 이들 상황 이벤트들에 응답하기 위해, 수정된 DNA는 상이한 코호트들 또는 그룹들에 동적으로 분산될 수 있다.실시예들에서, 이러한 아키텍쳐들 ―자발적 아키텍쳐―은 메트릭 상태들 또는 운영자 선호사항(들) 등의 특정한 제어 파라미터를 처리하기 위해 그들의 네트워크 토폴로지들의 완전한 및/또는 실시간 재구성으로부터 혜택을 받을 수 있다. 소정의 상황들에서, 네트워크 아키텍쳐들은 메트릭들의 고도로 동적인 변화들과 그들의 가능한 상태의 다양성을 지원할 수 없다는 추가적인 문제를 해결할 것이 요구된다. 실시예들에서, 자발적 아키텍쳐는 부상하는 초대역폭 애플리케이션들 또는 인공 지능 포털들의 지원을 허용하는 메트릭들의 이들 고도로 동적인 변화들을 해결한다. 자발적 아키텍쳐들의 적용들의 추가 예들은, 군사 극장들, 전력 그리드들의 관리 또는 고 도로 분산된 금융 거래 시스템을 포함할 수 있다. 실시예들에서, 생태계 VDAX들은 동적 상태 속성들을 요구하는 애플리케이션들을 지원하는 게놈 네트워크 토폴로 지들을 조성 및 제어할 수 있다. 실시예들에서, 생태계 VDAX는, 생태계 내의 코호트들 사이의 (예를 들어, 링 크 교환을 통한) 결합이, 상이한 멤버들에게 제공되는 LNA 및/또는 XNA를 제어함으로써 커뮤니티 소유자에 의해 인에이블되거나, 방지되거나, 및/또는 철회될 수 있도록, 상이한 게놈 조성들(예를 들어, LNA 및 XNA)을 이용하 여 생태계 내의 코호트들의 결합을 제어할 수 있다. 마찬가지로, 이들 예들에서, 생태계 VDAX는 상이한 코호트 들에 제공되는 LNA 및 XNA를 제어함으로써 생태계의 동적 네트워크 토폴로지를 변경할 수 있다. 실시예들에서, 엔클레이브 VDAX들은, 생태계의 게놈 네트워크 토폴로지의 상응하는 부분들을 제어하도록 구성될 수 있으며, 이에 의해 엔클레이브 VDAX는 게놈 네트워크 토폴로지의 엔클레이브 VDAX 부분과 관련하여 특정한 VDAX-지정된 기능들 및 프로세스들을 담당한다. 추가의 실시예들에서, 게놈 상관관계 및 분화는 엔클레이브 VDAX들이 물리적 토폴로지를 수정할 필요 없이 동적 게놈 네트워크 토폴로지들을 구성할 수 있게 한다. 예를 들어, 이들 실시예들에서, 엔클레이브 VDAX들은, 상이한 엔클레이브들 내의 코호트들 사이의 (예를 들어, 링크 교환을 통한) 결합이, 상이한 엔클레이브 멤버들에게 제공되는 LNA 및/또는 XNA를 제어함으로써 엔클레이브 VDAX에 의해 동적으로 인에이블되거나 방지되거나 취소될 수 있도록, 상이한 게놈 조성들(예를 들어, LNA 및 XNA)을 이용하여 상이한 엔클레이브들 내의 코호트들의 결합을 제어할 수 있다. 유사하게, 이들 예에서, 엔클 레이브 VDAX들은, 역시 상이한 코호트에게 제공되는 게놈 조성들(예를 들어, LNA 및 XNA)을 제어함으로써 새로 운 동적 자발적 엔클레이브들을 생성할 수 있다. 일부 실시예에서, 코호트 VDAX들은 생태계 게놈 네트워크 토 폴로지의 상응하는 부분들을 제어할 수 있다. 이들 실시예들에서, 코호트 VDAX는 생태계 VDAX 및/또는 엔클레 이브 VDAX에 의해 지정되는 게놈 네트워크 토폴로지의 상응하는 부분에 대한 특정한 기능들을 수행하는 것을 담 당할 수 있다. 추가 실시예들에서, 이러한 기능들을 수행하는 코호트 VDAX들은 물리적 네트워크 토폴로지를 수 정할 필요 없이 동적 게놈 네트워크 토폴로지들을 구성함으로써 자발적 아키텍쳐들을 인에이블할 수 있다. 예 를 들어, 이들 실시예들에서, 코호트 VDAX는, 지정된 부분에서의 VDAX들 사이의 (예를 들어, 링크 교환을 통한) 결합이 이들 VDAX들의 LNA 및/또는 XNA를 선택적으로 수정함으로써 지정된 코호트 VDAX에 의해 동적으로 인에이 블되거나, 방지되거나, 및/또는 철회될 수 있도록, 상이한 게놈 조성들(예를 들어, LNA 및 XNA)을 이용하여 게 놈 네트워크 토폴로지의 지정된 부분에 대한 VDAX들의 결합을 제어할 수 있다. 실시예들에서, 다양한 유형의 상호작용(예를 들어, 생태계 VDAX-대 엔클레이브 VDAX, 엔클레이브 VDAX-대-코호 트 VDAX, 생태계 VDAX-대-코호트 VDAX, 및/또는 코호트 VDAX-대-코호트 VDAX 상호작용들)은 생태계 VDAX에 의해 결정되는 특정한 게놈 조성들(예를 들어, CNA, PNA, LNA 및 XNA)에 의해 제어될 수 있다. 예를 들어, 이들 실 시예들에서, 생태계 VDAX는, 생태계, 엔클레이브들, 및/또는 게놈 네트워크 토폴로지의 상응하는 부분에서의 코 호트 VDAX들의 게놈 조성들(예를 들어, LNA 또는 XNA)의 일부 또는 전부를 동적으로 수정함으로써 게놈 네트워 크 토폴로지의 상응하는 부분들에 대응하는 VDAX들 사이의 결합을 제어할 수 있다. 이러한 방식으로, VDAX들은, 그들의 상응하는 게놈 조성들을 통해 게놈 네트워크 토폴로지의 상이한 부분들로부터 추가, 방지 및/ 또는 철회될 수 있다. 예를 들어, 일부 실시예에서, 게놈 네트워크 토폴로지의 상응하는 부분을 제어하도록 지 정된 엔클레이브 VDAX는, 게놈 네트워크 토폴로지의 상응하는 부분으로부터 추가 및/또는 철회될 VDAX들의 게놈 조성들을 선택적으로 수정함으로써 게놈 네트워크 토폴로지의 그 부분을 변경할 수 있다. 실시예들에서, 생태 계, 엔클레이브, 및 코호트 결합들을 담당하는 게놈 조성들(예를 들어, CNA, PNA, LNA 및/또는 XNA)은, 결국 게 놈 네트워크 토폴로지를 수정하는, 분화 및/또는 상관관계의 기초를 변경하도록 수정될 수 있다. 일부 실시예 에서, 이러한 수정들은 게놈 네트워크 토폴로지를 업데이트하는 것(예를 들어, 코호트 철회)의 일부로서 영향을 받을 수 있다. 실시예들에서, 이들 게놈 조성들은 생태계의 멤버들 사이의 (예를 들어, 링크 교환을 통한) 결 합이 게놈 조성들을 제어함으로써 인에이블되거나 방지되거나 철회될 수 있도록, 상이한 게놈 조성들(예를 들어, LNA 및 XNA)을 이용하여 생태계 내의 코호트들의 결합의 제어를 인에이블하도록 수정될 수 있다. 유사하 게, 이들 예에서, 생태계 CNA, PNA, LNA 및/또는 XNA는 상이한 코호트들에 제공되는 게놈 조성들을 제어함으로 써 생태계의 동적 네트워크 토폴로지를 변경할 수 있다.실시예들에서, 자발적 아키텍쳐들은, 그들이 지원하는 메트릭 상태들(예를 들어, 시간, 데이터, 조건, 수요, 좌 표, 동작, 또는 이벤트)의 동적 빈도와 관계없이 그들의 동작 무결성을 유지한다. 예를 들어, 일부 실시예에서, 코호트들은 메트릭들의 보고 빈도가 가변적일 수 있는 환경에서 동작할 수 있다. 이들 실시예들에 서, 자발적 아키텍쳐는 생태계의 전체 무결성을 유지하면서 전체 메트릭 데이터에서 이들 변동들을 취급한다. 도 9는 동적 생태계를 서비스하는 자발적 아키텍쳐를 갖는 보안 플랫폼의 한 예를 나타낸다. 실시예들에 서, 동적 생태계는, 상태(시간, 데이터, 조건, 수요, 좌표, 행동 등)의 고도로 동적인 변화에 종속되는 애 플리케이션들 및 서비스들을 지원하는 엔클레이브들 및 그들의 코호트들을 포함한다. 동적 생태계의 예들 은, 인공 지능 애플리케이션들, 자율 차량 시스템들, 및 실시간 공급망 시스템들을 포함한다. 자발적 생태계 는 종종 특정한 상태들 및/또는 운영자 선호사항(들)에 응답하여 실시간으로 완전한 재구성을 요구한다. 이들 생태계들의 보안 요건들은, 전통적인 암호화 프로토콜들이 동적 빈도를 지원할 수 없고 가능한 다양한 상 태들과 호환되지 않도록 하는 것이다. 실시예들에서, 보안 플랫폼은 자발적 생태계를 서비스하기 위한 자 발적 아키텍쳐로서 구현된다. 이들 아키텍쳐들은, 초대역폭 및 인공 지능(AI) 포털들의 부상하는 통합에 대한 큰 가능성을 가지고 있다. 자발적인 아키텍쳐에서, 생태계 VDAX는 엔클레이브들을 동적으로 정의하거나 및/또는 코호트들 을 하나 이상의 엔클레이브에 실시간으로 할당하도록 구성될 수 있다. 이들 실시예들 중 일부에서, AI 포 털은 VDAX에 의해 엔클레이브를 정의하고 거기에 코호트를 할당하기 위해 활용될 수 있다. 각 각의 코호트에 대해, VDAX는 초기에 코호트에 대한 게놈 정보를 생성하고 제공할 수 있다. 이 게놈 정보는, 매일, 코호트의 전원이 켜질 때마다, 또는 다른 적절한 간격들로 생성 및 제공될 수 있다. 게놈 정보는 생태계의 다른 모든 코호트와 상관될 수 있지만, 특정한 엔클레이브에 할당되지는 않는다. 코호트가 생태계에 참여할 때, VDAX 및 AI 포털은 코호트가 어느 엔클레이 브에 속하는지 및 코호트가 어느 엔클레이브로부터 철회되어야 하는지를 결정할 수 있다. 코호 트가 속하는 각각의 엔클레이브에 대해, VDAX는, AI 포털이 이들 엔클레이브 내의 코 호트들에 의해 생성된 VBLS를 해독할 수 있도록, 코호트의 XNA 및 LNA에 대한 수정들을 전달할 수 있다. 유사하게, 코호트가 철회된 각각의 엔클레이브에 대해, VDAX는, 코호트가 이들 엔클레이브 내의 나머지 코호트들에 대해 생성된 VBLS를 더 이상 해독할 수 없도록, 코호트의 XNA 및 LNA에 대한 수정 들을 전달할 수 있다. 자발적 생태계들에서, VDAX(또는 복수의 VDAX)는, 그리드 내의 코호트들이 엔 클레이브 내의 다른 코호트들과 높은 레벨의 상관관계를 유지하고 그리드 내에 더 이상 존재하 지 않는 코호트들은 높은 레벨의 상관관계를 더 이상 유지하지 않도록 하는 이러한 방식으로, 생태계 내의 엔클레이브들에 대한 멤버십을 관리할 수 있다. 도시된 예에서, 자발적 생태계는 자율 차량 환경이다. 이러한 환경에서, 차량들은 지역(예를 들어, 전체 도시, 주 등)의 도로들을 횡단할 수 있다. 때로는, 수십만 대의 자동차들이 도로를 횡단할 수도 있고 또 어떤 때에는 차량들이 적을 수도 있다. 각각의 차량은, 클라우드 기반의 시스템이 도로들에 관련된 상태 데이터(예 를 들어, 차량들, 장애물들, 트래픽 등이 있는 장소)를 유지할 수 있도록, 그 센서 데이터(예를 들어, LIDAR, 레이더, 비디오, 습기 등)를 클라우드 기반의 시스템에 보고하도록 구성될 수 있다. 클라우드 기반의 시스템은, 관련 상태 데이터를 각각의 차량에 보고하여 차량의 경로를 따라 상태(또는 특정한 차량들에 대한 명 령어들 등의, 다른 적절한 데이터)를 차량에 통보하도록 구성될 수 있다. 각각의 차량은 그 자신의 경로를 따 라 이동하기 때문에, 차량들의 수집으로부터 매초마다 수집되는 데이터의 양은 방대할 수 있다. 예시된 예에서, VDAX 및 AI 포털은 VBLS를 이용하여 그리드를 따른 차량들로의 관련 상태 데이터의 보고를 용이화 한다. 이 예에서, VDAX는 영역(예를 들어, 도시, 카운티, 주 등)에 대응하는 그리드를 생성할 수 있고, 여기서, 그리드는 셀들을 갖는다. 셀들은 크기가 고정되거나 도로들 상의 트래픽량에 따라 동적으로 크기 가 조정될 수 있다. 마찬가지로, 셀들은 그 수가 고정되거나, 도로들 상의 트래픽량에 따라 동적으로 할당될 수 있다. 일부 실시예에서, AI 포털은 도로들의 상태(예를 들어, 얼마나 많은 차량이 도로들 상에 있는지, 전 통적으로 얼마나 많은 차량이 이 시간에 도로들 상에 존재하는지 등)에 응답하여 셀들의 수 및/또는 셀들의 크 기들을 결정한다. 실시예들에서, 각각의 셀은 엔클레이브로서 간주되고, 클라우드 기반의 시스템은 엔클 레이브 내의 이들 차량들에 관련 상태 데이터를 보고할 수 있다. 일부 실시예에서, 통신 타워들(예를 들 어, 5G 타워들)은 엔클레이브 내의 코호트들과 통신하는 엔클레이브 VDAX들을 호스팅할 수 있다. 차 량이 도로들을 횡단할 때, 차량은 한 셀을 벗어나 또 다른 셀로 들어갈 수 있다. 또한, 차량이 직진, 우회전 또는 좌회전할 가능성이 높기 때문에, VDAX는, 차량이 그 차량의 바로 앞의 하나 이상의 셀, 그 차량 우측 의 하나 이상의 셀, 및 그 차량 좌측의 하나 이상의 셀의 관련 상태 데이터를 수신할 있도록, 차량을 복수의 셀(즉, 엔클레이브)에 할당할 수 있다. VDAX는 이들 엔클레이브들 각각(예를 들어, 차량의 우측, 좌측 및 전방에 있는 하나 이상의 셀)에 대한 게놈 정보를 차량에 제공할 수 있다. 각각의 셀/엔클레이브에 대해, 차량 (예를 들어, 그 위에서 실행되는 코호트 VDAX)은 GEC를 생성하고 특정한 셀에 대해 자신을 인증하기 위해 클라 우드 기반의 시스템과 GEC를 교환할 수 있다. 일단 인증되고 나면, 차량과 클라우드 기반의 시스템은 링크들을 교환하여 각각의 셀에 관해 결합될 수 있다. 차량이 센서 데이터를 수집함에 따라, 차량은, 수집된 센서 데이 터, 그 XNA 및 클라우드 기반의 시스템에서 수신된 링크에 포함된 정보에 기초하여 VBLS를 생성할 수 있다. 유 사하게, 클라우드 기반의 시스템은, 각각의 셀에 대해, 그 셀 특유의 (예를 들어, 엔클레이브에 할당된 임의의 코호트에 의해 이해되는) VBLS에서 생성된 VBLS를 브로드캐스트할 수 있다. 차량이 셀을 벗어날 때, VDAX는, 그 차량이 더 이상 그 셀에 대응하는 VBLS를 이해하거나 그 셀에 대응하는 VBLS를 생성할 수 없도록 그 셀에 대 한 차량의 유전 정보를 수정할 수 있다. 애플리케이션 생태계들은 더 풍부한 자원 가용성과 낮은 레이턴시 네트워크들을 요구하는 복합 서비스들 및 프 로세스들을 특징으로 계속 진화하고 있다. 이것은 부분적으로 프로세스들의 재분배 및 기반시설의 재할당에 의 해 입증된다. 애플리케이션들은 일반적으로 정교한 OS가 요구한다. OS 서비스들은 점점 더 두 갈래로 나뉘어, 더 낮은 복잡성 및 자원 요건들을 갖는 서비스들은 로컬로 호스팅되고(예를 들어, 클라이언트 OS) 더 큰 복잡성 및 자원 요건들을 갖는 서비스들은 원격으로 호스팅된다(예를 들어, 클라우드 OS). 이 효율적인 OS 분기는 다 른 중대한 이점들을 갖는다 : 강력한 비상주 능력들에 대한 액세스를 유지하는 매우 저렴한 클라이언트 디바이 스들의 확산, 매우 낮은 비용의 대역폭 예산들, 및 강력한 새로운 애플리케이션들의 자유로운 형태 배포 및 개 발. 이들 확실히 새롭고 유익한 애플리케이션들은, 그들의 이전 애플리케이션들과 마찬가지로, 액세스 및 소유 권 제어에 대한 훨씬 더 복잡한 문제를 부과할 것이다. 이제 도 10을 참조하면, 계산적 복합 게놈 조성들을 구현함으로써, CG-ESP들은, 상이한 소프트웨어 및 하드웨어 컴포넌트들, \"실행가능한 생태계들\", 예를 들어: 애플리케이션들(API, 라이브러리들, 및 스레드들), 운영 체제 (커널, 서비스들, 드라이버들, 및 라이브러리들), 및 시스템 온 칩(System on a Chip)(처리 유닛들, 예를 들어, 코어) 사이의 결합을 고유하게 변환하기 위한 방법들을 인에이블한다. 이들 생태계 컴포넌트들은, 실행가능한 바이너리들을 공동으로 또는 독립적으로 수행할 수 있다. 실시예들에서, 방법들은, 게놈적으로 조성된 임시 아 키텍쳐들을 형성하도록 이러한 생태계들 및 엔클레이브들, 및 코호트들(독립 코호트 및 종속 코호트)의 특정한 지정 및 조직화를 가능케할 수 있다 - 이것은 그들의 능력들, 제한들, 및 성능 효율들에 최상으로 잘 부합한다. 실시예들에서, 임시 아키텍쳐들은, 실행가능한 바이너리들을, 고유한 게놈 분화 및 상관관계를 나타내는, VBLS 디지털 객체들 및 결과적인 VBLS 스트림들로 변환할 수 있다. 이들 실시예들 중 일부에서, 임시 아키텍쳐들에 서의 CG-ESP들은, 지시된(정적 생태계들 및 자유 형태 생태계들) 및 자발적(동적 상태) 등의, 다른 CG 지원형 아키텍쳐들과의 계산적 복합 게놈 조성 지원형의 결합이 가능하다. 실시예들에서, 임시 아키텍쳐들은, 그들의 많은 속성이 다른 아키텍쳐들(예를 들어, Directed 및 Spontaneous) 와 직접적인 상관관계를 나타낸다는 점에서 많은 이점을 제공할 수 있다. 그러나, 임시 아키텍쳐들은, 그들의 컴포넌트들이 일반적으로 밀접하게 결합되어 있고 프로세스들이 프로세스 전과 프로세스 도중에 고도로 관찰가 능하고 수정가능하다는 점에서 매우 상이한 공격 표면을 구성한다. 따라서, 이러한 조건들의 가상 다양성은 VBLS 지원형의 동적 가상 신뢰할 수 있는 실행 도메인들로부터 혜택을 받을 수 있다. 실시예들에서, 게놈 상관관계 및 분화는, 실행가능한 생태계들(예를 들어, 생태계 VDAX, 엔클레이브 VDAX, 코호 트 VDAX 및 종속 VDAX)을 인에이블하도록 VDAX에 의해 게놈적으로 구성될 수 있는 임시 아키텍쳐들을 인에이블 한다. 추가 실시예들에서, 및 임시 아키텍쳐 기반은, 상이한 계층적 레벨들의 VDAX가 신뢰할 수 있는 컴포넌트 들의 확립을 허용하는 소스에 대한 깊은 지식을 제공하는 실행가능한 생태계를 제공한다. 추가 실시예들에서, 자율 차량, 우주선 또는 모바일 전화, 또는 웹 서비스 아키텍쳐 등의 복합 생태계는, 각각 추가적인 서브컴포넌 트들로 구성된 방대한 컴포넌트 어레이로 구성되며, 이 예에서 생태계의 각각의 계층은 그들의 상응하는 VDAX 및 게놈 조성들이 컴포넌트들의 소스에 대한 지식 체계를 구축하는 것을 허용한다. 추가 실시예들에서, 각각의 컴포넌트는 소스 및 서브컴포넌트들의 동작의 정확성을 검증하는 동작들을 실행할 수 있다. 이 예에서, 동작의 정확성은 신뢰할 수 있는 공급 소스들과의 게놈 조성 지원형 교환들에 의해 수행될 수 있다. 실시예들에서, 게놈적으로 조성된 애플리케이션 특유의 실행가능한 생태계들은 그들의 기저 아키텍쳐 실시예들 의 수정을 요구하지 않는다. 추가 실시예들에서, 기저 아키텍쳐는 변경되지 않고 실행가능한 생태계들은 소스 에 대한 지식을 제공할 수 있는 정보 오버레이로서 존재한다. 추가 실시예들에서, 임시 아키텍쳐의 컴포넌트들 의 소스에 대한 지식은 실행가능한 생태계의 동작 파라미터들을 검증하기 위해 적용될 수 있다.실시예들에서, 실행가능한 생태계 VDAX는 고유한 게놈 상관관계 조성들을 독립적으로 개시할 수 있다. 추가 실 시예들에서, 상관관계 조성들은 엔클레이브 VDAX 내의 서브컴포넌트들의 속성의 검증을 제공할 수 있다. 일부 실시예에서, 상관관계 조성들은, LNA(게놈 상관관계), CNA(게놈 결합-무결성), 및/또는 PNA(게놈 결합-적격성) 를 포함할 수 있다. 이 예에서, 이들 조성들은 가상 인증을 가능케할 수 있다. 실시예들에서, 실행가능한 생태계 VDAX는 고유한 게놈 분화 조성들(예를 들어, ZNA)을 독립적으로 개시할 수 있 다. 이들 실시예들 중 일부에서, 실행가능한 생태계-개시형 분화 조성들은 생태계 내에서 어떤 컴포넌트들이 특정한 동작들을 담당하는지의 결정 및/또는 컴포넌트가 격리되어 있다는 결정을 위해 적용될 수 있다. 일부 실시예에서, 분화 조성들은 ZNA(게놈 코드-격리)를 포함할 수 있다. 이 예에서, 이들 분화들은 가상 제휴를 가 능케할 수 있다. 실시예들에서, 실행가능한 생태계 VDAX들은 그들의 고유한 게놈 상관관계 조성들을 직접 취득할 수 있다. 추가 실시예들에서, 상관관계 조성들은, 엔클레이브 VDAX 또는 코호트 VDAX 등의, 게놈 후손 VDAX 내의 서브컴포넌트 들의 속성의 검증을 제공할 수 있다. 일부 실시예에서, 상관관계 조성들은, LNA(게놈 상관관계), CNA(게놈 결 합-무결성), 및/또는 PNA(게놈 결합-적격성)를 포함할 수 있다. 이 예에서, 이들 조성들은 가상 인증을 가능케 할 수 있다. 실시예들에서, 실행가능한 엔클레이브 VDAX들은 그들의 고유한 게놈 분화 조성들을 직접 취득할 수 있다. 추가 실시예들에서, 실행가능한 엔클레이브 개시형 분화 조성들은 어떤 컴포넌트들이 특정한 동작을 담당하는지의 결 정 또는 컴포넌트가 단독이라는 결정을 위해 적용될 수 있다. 일부 실시예에서, 분화 조성들은 ZNA(게놈 코드- 격리)를 포함할 수 있다. 이 예에서, 이들 분화들은 가상 제휴를 가능케할 수 있다. 실시예들에서, 실행가능한 엔클레이브 VDAX들은 그들의 고유한 게놈 상관관계 조성들을 직접 취득할 수 있다. 추가 실시예들에서, 상관관계 조성들은, 종속 VDAX 또는 코호트 VDAX 등의, 게놈 자손 VDAX 내의 서브컴포넌트 들의 속성의 검증을 제공할 수 있다. 일부 실시예에서, 상관관계 조성들은, LNA(게놈 상관관계), CNA(게놈 결 합-무결성), 및/또는 PNA(게놈 결합-적격성)를 포함할 수 있다. 이 예에서, 이들 조성들은 가상 인증을 가능케 할 수 있다. 실시예들에서, 실행가능한 코호트 VDAX들은 그들의 고유한 게놈 상관관계 조성들을 직접 취득할 수 있다. 추가 실시예들에서, 상관관계 조성들은, 종속 VDAX 등의, 게놈 자손 VDAX 내의 서브컴포넌트들의 속성의 검증을 제공 할 수 있다. 일부 실시예에서, 상관관계 조성들은, LNA(게놈 상관관계), CNA(게놈 결합-무결성), 및/또는 PNA (게놈 결합-적격성)를 포함할 수 있다. 이 예에서, 이들 조성들은 가상 인증을 가능케할 수 있다. 실시예들에서, 실행가능한 코호트 VDAX는 그들의 고유한 게놈 분화 조성들을 직접 취득할 수 있다. 추가 실시 예들에서, Executable Enclave 개시형 분화 조성들은 어떤 컴포넌트들이 특정한 동작을 담당하는지의 결정 또는 컴포넌트가 격리되어 있다는 결정을 위해 적용될 수 있다. 이들 실시예들 중 일부에서, 실행가능한 생태계개시 형 분화 조성들은 생태계 내에서 어떤 컴포넌트들이 특정한 동작들을 담당하는지의 결정 및/또는 컴포넌트가 격 리되어 있다는 결정을 위해 적용될 수 있다. 일부 실시예에서, 분화 조성들은 ZNA(게놈 코드-격리)를 포함할 수 있다. 이 예에서, 이들 분화들은 가상 제휴를 가능케할 수 있다. 실시예들에서, 실행가능한 VDAX(무관한 VDAX가 결합하는 경우)는 대안적인 게놈 하위조성들을 통해 그들의 고유 한 게놈 상관관계 조성들을 취득할 수 있다. 추가 실시예들에서, 상관관계 조성들은 무관한 컴포넌트들의 속성 의 검증을 제공할 수 있다. 일부 실시예에서, 상관관계 조성들은, LNA(게놈 상관관계), CNA(게놈 결합-무결 성), 및/또는 PNA(게놈 결합-적격성)를 포함할 수 있다. 이 예에서, 이들 조성들은 가상 인증을 가능케할 수 있다. 실시예들에서, 실행가능한 VDAX(무관한 VDAX들이 결합하는 경우)는 대안적인 게놈 하위조성들을 통해 그들의 고 유한 게놈 분화 조성들을 취득할 수 있다. 추가 실시예들에서, Executable Enclave 개시형 분화 조성들은 어떤 컴포넌트들이 특정한 동작을 담당하는지의 결정 또는 컴포넌트가 격리되어 있다는 결정을 위해 적용될 수 있다. 이들 실시예들 중 일부에서, 실행가능한 생태계-개시형 분화 조성들은 생태계 내에서 어떤 컴포넌트들이 특정한 동작들을 담당하는지의 결정 및/또는 컴포넌트가 격리되어 있다는 결정을 위해 적용될 수 있다. 일부 실시예에 서, 분화 조성들은 ZNA(게놈 코드-격리)를 포함할 수 있다. 이 예에서, 이들 분화들은 가상 제휴를 가능케할 수 있다. 실시예들에서, 복수의 조성된 실행가능한 게놈 토폴로지들이 동시에 존재할 수 있다. 일부 실시예에서, 이들 다중 게놈 토폴로지들은 상이한 아키텍쳐 기능들에 대해 게놈적으로 인에이블된 동작들을 제공할 수 있다. 이들 예시적인 실시예들에서, 상이한 아키텍쳐 기능들은, 소스의 검증, 동작의 검증 또는 라이센스 요금 지불의 검증을 포함할 수 있다. 실시예들에서, 각각의 실행가능한 생태계는, 상관관계 및 분화 속성들이 도출되는 고유한 게놈 조성을 가지며, 이들 속성들은 그 엔클레이브들의 게놈 토폴로지를 제어한다. 일부 실시예에서, 각각의 실행가능한 엔클레이브 는 상관관계 및 분화 속성들이 도출되는 고유한 게놈 조성을 가질 수 있으며, 이에 의해 이들 게놈 속성들은 그 코호트들의 게놈 토폴로지를 제어한다. 추가 실시예들에서, 이들 고유한 조성들은, 종들, 자손, 및 형제자매들 에 걸친 분화를 제공한다. 실시예들에서, 다양한 게놈적으로 구성된 구성들을 갖는 임시 아키텍쳐들은 2진 데이터를 VBLS 기반의 디지털 객체들 및/또는 스트림들로 변환할 수 있다. 실시예들에서, 임시 아키텍쳐 보안 플랫폼은 가상 기민성을 제공 한다. 실시예들에서, VBLS는, 엔클레이브 또는 코호트가 또 다른 엔클레이브 또는 코호트에게 말하는 언어들로 서 수신자 엔클레이브 또는 코호트에 의해 고유하게 이해될 수 있는 언어들 ―즉, 수신자 엔클레이브 또는 코호 트에 의해서만 이해될 수 있는 언어들을 지칭할 수 있다. 이 예에서, 비인가된 코호트들, 바이러스들, 및/또는 맬웨어를 포함하려는 침입자들은 인가된 코호트들 사이에서 VBLS를 생성하거나 해독할 수 없다. 실시예들에서, VBLS 변환된 2진 데이터는 공통 게놈 상관관계 및 분화를 갖는 2개 이상의 상이한 구성들로부터 의 컴포넌트들에 의해 교환 및 수행될 수 있다. 실시예들에서, 상이한 구성들은 Executable Ecosystem 동작 파 라미터들에 대한 상태 정보를 제공한다. 추가 실시예들에서, 이들 상이한 구성들 각각은, 연관된 구성에 대한 지식과 함께 그들의 상태 및 기능적 컴포넌트들에 따라 동작할 수 있다. 실시예들에서, 임시 아키텍쳐들은 복수의 게놈적으로 조성된 구성들을 가질 수 있으며, 여기서 소정의 컴포넌트 들은 실행가능한 바이너리들을 가상 2진 언어 스크립트(VBLS; Virtual Binary Language Script) 기반의 디지털 객체들 및/또는 스트림들로 변환할 수 있다. 추가 실시예들에서, 실행가능한 바이너리들은 VBLS 디지털 객체들 또는 VBLS 스트림들로 변환될 수 있으며, 이 변환은 게놈적으로 조성된 구성 컴포넌트들의 적용에 의해 달성된 다. 추가 실시예들에서, 변환은 게놈 서열 맵핑 및 변환들을 적용함으로써 달성된다. 실시예들에서, 서열은 디지털 객체를 고유한 비반복적 게놈 결합 인자들로 계산적으로 변환하는데 있어서 핵심이다. 예들에서, 서열 들은 광범위하게 이질적일 수 있으며, 서열들은 특정한 레벨들의 엔트로피를 야기하는 처리를 요구할 수 있다. 실시예들에서, 서열 맵핑은 광범위한 프로토콜들 및 포맷들과 호환될 수 있거나 기존 엔트로피를 나타내는 객체 들로 시작될 수 있으며, 여기서 이들 객체들은 계산적 복합 게놈 프로세스들 및 기능들에 의해 특정한 레벨들의 엔트로피를 나타내는 객체들로 변환될 수 있다. 실시예들에서, VBLS 변환된 실행가능한 바이너리들은 공통 게놈 상관관계 및 분화를 갖는 2개 이상의 상이한 구 성들로부터의 컴포넌트들에 의해 교환 및 수행될 수 있다. 실시예들에서, 특정한 임시 아키텍쳐 내에서, 컴포넌트들은 VBLS 실행가능한 바이너리들(예를 들어, 전용 컴퓨 터 애플리케이션)을 변환하되, 변환된 실행가능한 바이너리가 공통 게놈 상관관계 및 분화를 공유하는 특정한 하드웨어 컴포넌트(예를 들어, SoC Core)에 의해서만 올바르게 처리될 수 있도록 변환될 수 있다. 추가 실시예 들에서, 특정한 하드웨어는 게놈 생태계의 일부이고 VBLS 실행가능한 바이너리들의 처리를 가능케하기 위해 게 놈 상관관계 프로세스들을 적용할 수 있다. 실시예들에서, 임시 아키텍쳐 VDAX 상주 컴포넌트는 (VBLS) 실행가능한 바이너리들(예를 들어, 전용 컴퓨터 애 플리케이션)을 변환하되, 변환된 실행가능한 바이너리들이 공통 게놈 상관관계 및 분화를 공유하는 또 다른 임 시 아키텍쳐 VDAX 특유의 하드웨어 컴포넌트(예를 들어, SoC Core)에 의해서만 올바르게 처리될 수 있도록 변환 할 수 있다. 추가 실시예들에서, 또 다른 임시 아키텍쳐 VDAX는 게놈 생태계의 일부일 수 있다. 실시예들에서, 특정한 임시 아키텍쳐 내에서, 2개 이상의 컴포넌트는 그 조성들이 또 다른 컴포넌트에 알려져 있는, 고유한 게놈 조성들에 기초하여 실행가능한 바이너리들(예를 들어, 전용 컴퓨터 애플리케이션)을 변환할 수 있다. 이들 변환된 바이너리들은 이들 컴포넌트들 중 하나에 의해서만 실행가능한 바이너리들로서 재형성될 수 있다. 실행가능한 바이너리들의 재형성 및 수행은 제위치에서 발생한다. 실시예들에서, 컴포넌트들은 동일 한 게놈 생태계 또는 게놈 엔클레이브의 일부이다. 실시예들에서, 특정한 임시 아키텍쳐 내에서, 특정한 컴포넌트들은, 그 조성들이 또 다른 임시 아키텍쳐의 특정 한 컴포넌트들에게 알려져 있는 고유한 게놈 조성들에 기초하여 실행가능한 바이너리들(예를 들어, 전용 컴퓨터 애플리케이션)을 변환할 수 있다. 한 아키텍쳐에서 시작된 변환된 바이너리들은 다른 아키텍쳐의 특정한 컴포 넌트들에 의해 실행가능한 바이너리들서만 재형성될 수 있다. 실행가능한 바이너리들의 재형성 및 수행은 제위치에서 발생한다. 추가 실시예들에서, 컴포넌트들을 공유하는 임시 아키텍쳐들은 동일한 게놈 생태계 또는 게 놈 엔클레이브의 일부이다. 추가 실시예들에서, 변환된 실행가능한 바이너리들을 공유하고 있는 컴포넌트들은 컴포넌트들의 소스에 대한 지식을 제공하기 위해 게놈 링크 교환을 수행한다. 추가 실시예들에서, 컴포넌트들 의 소스에 대한 지식은 컴포넌트들 사이에 신뢰 관계를 확립하기 위해 추가 게놈 조성들과 함께 이용된다. 실시예들에서, 특정한 임시 아키텍쳐 내에서, 컴포넌트 VDAX는 그 컴포넌트에만 알려진 특정한 고유한 게놈 조 성들에 기초하여 실행가능한 바이너리들(예를 들어, 전용 컴퓨터 애플리케이션)을 변환할 수 있다. 이들 변환 된 바이너리들은 이 특정한 컴포넌트에 의해서만 실행가능한 바이너리들로 재형성될 수 있다. 이 특정한 컴포 넌트에 의한 실행가능한 바이너리들의 재형성 및 수행은 제위치에서 발생한다. 실시예들에서, 이들 컴포넌트 특유의 변환들은 연관된 컴포넌트 VDAX에게만 알려진 게놈 데이터에 기초하여 하는 게놈 조성들을 적용한다. 추가 실시예들에서, 변환된 컴포넌트들은 변환된 바이너리들에 대한 비 컴포넌트 적용된 변경이 변환된 실행가 능한 바이너리들을 동작하지 않게 만드는 안전한 방식으로 동작할 수 있다. 도 10은 실행가능한 생태계를 서비스하는 임시 아키텍쳐를 갖는 보안 플랫폼의 한 예를 나타낸다. 논의 된 바와 같이, 실행가능한 생태계는, 컴퓨팅 디바이스(예를 들어, 서버, 모바일 디바이스, 개인용 컴퓨터, 랩탑 컴퓨터 등) 등의, 자립적인 임의의 생태계일 수 있다. 실시예들에서, 임시 아키텍쳐는 코호트들이 실행가능한 코드 인스턴스들의 VBLS 기반의 격리들을 생성 및 해독하기 위한 프레임워크를 제공함으로써, 지능 형 외부 관찰에 종속되지 않는 실시간 가상의 신뢰할 수 있는 실행 도메인을 제공한다. 예를 들어, 컴퓨팅 디 바이스에서, 엔클레이브들은 컴퓨팅 디바이스의 시스템-온-칩(SoC), 디바이스의 운영 체제, 및 애플리케 이션들을 포함할 수 있다. 이 예시적인 생태계에서, 시스템-온-칩 엔클레이브의 독립 코호트들은, 프로 세서 코어들, 메모리 디바이스들(예를 들어, RAM, ROM) 등을 포함할 수 있다. 운영 체제 엔클레이브의 독립 코 호트들은, 운영 체제의 커널, 다양한 드라이버들(네트워크 드라이버들, 파일 시스템 드라이버들, 인쇄 드 라이버들, 비디오 드라이버, 카메라 드라이버, 종속 \"대리\" 코호트 등), 공유 라이브러리들 등을 포함할 수 있 다. 예에서, 애플리케이션의 종속 코호트들은, 스레드들, API들, 파일들 등을 포함할 수 있다. 일부 실 시예에서, 각각의 엔클레이브(SoC, 운영 체제, 애플리케이션)는, 각각의 상응하는 엔클레이브의 코호트들에 의 해 상속되는 게놈 데이터 세트(예를 들어, ZNA, LNA, CNA, 및/또는 PNA)를 할당받을 수 있다. 실시예들에서, 생태계 VDAX는 애플리케이션이 액세스될 때 임시 엔클레이브를 생성할 수 있으며, 이에 의해 애플리케이션의 코 호트들, 및 애플리케이션에 연루된 운영 체제의 코호트들, 및 애플리케이션을 실행할 때 운영 체제에 의해 호출 되는 SoC의 코호트들에 대해 임시 엔클레이브가 생성된다. 이 예에서, 임시 엔클레이브 내의 코호트들은, 서로 를 인증하고, 링크들을 교환하고, VBLS를 생성할 수 있다. 실행시, 애플리케이션의 소정의 스레드들은 운영 체 제의 커널에게 자원들을 요청할 수 있다. 소정의 스레드가 실행될 때, 애플리케이션 스레드를 나타내는 독립 코호트 VDAX는 커널의 자원을 요청하는 소정의 스레드의 실행가능한 코드에 기초하여 VBLS를 생성한다. 이 시 나리오에서, 애플리케이션 스레드는, 스레드 애플리케이션에 할당된 생태계 CNA를 이용하여 생성된 생태계 게놈 자손 데이터를 이용하여 커널(예를 들어, 커널 VDAX)을 나타내는 독립 코호트 VDAX에 의해 인증될 수 있다(반대 의 경우도 마찬가지). 응답하여, 커널 VDAX와 스레드를 나타내는 스레드 VDAX는, 커널과 애플리케이션 스레드 의 상응하는 LNA를 이용하여 생성된 링크들을 교환한다. 그 다음, 스레드 VDAX는 자원을 요청하는 실행가능한 코드 인스턴스(들), 애플리케이션 스레드에 할당된 ZNA, 및 커널 VDAX에 의해 제공된 링크에 기초하여 VBLS를 생성할 수 있다. 스레드 VDAX는 VBLS를 커널 VDAX에 제공하고, 커널 VDAX는 차례로 VBLS를 해독한다. 그 다음, 커널 VDAX는, 커널 또는 요청된 자원에 의해서만 해독가능한 VBLS를 이용하여 요청된 자원(예를 들어, 컴 퓨팅 디바이스의 카메라에 액세스하기 위한 카메라 드라이버, 종속 \"대리\" 코호트)에 대응하는 VDAX와 인터페이 스할 수 있다. 일부 실시예에서, (독립 애플리케이션들과는 대조적으로) 종속 애플리케이션들은 그들의 내부 API 및 스레드 컴 포넌트들의 보안 VBLS 격리가 가능하지 않다. 그러나, 독립 애플리케이션과 종속 애플리케이션 양쪽 모두는, 서로간에 및 인증된 외부 자원들(예를 들어, 운영 체제, 시스템 온 칩)과의 안전한 VBLS 프로세스간 통신이 가 능하다. 이들 실시예들에서, 임시 엔클레이브들은, 커널 및 처리 코어들의 안전한 VBLS 격리를 가능케하여, 시 스템 버스 상의 모든 디지털 객체가 특정한 애플리케이션, 운영 체제, 및/또는 SoC 코호트들과만 결합할 수 있 도록 보장한다. 도 11 및 도 12은 본 개시내용의 교시들을 이용하여 구현될 수 있는 CG 지원형 디지털 생태계들의 추가적인 비 제한적인 예들을 나타낸다. 이해할 수 있는 바와 같이, 복수의 게놈 네트워크 토폴로지가 이들 디지털 생태계 의 다양한 레벨들에서 구현될 수 있다.CypherGenics 프로세스들 도 4를 다시 참조하면, CG-ESP는 생태계 멤버가 디지털 생태계에 참여할 수 있게 하는 모듈 세트로 구성될 수 있다. 논의된 바와 같이, 특정한 CG-ESP의 모듈 구성들 및 이 특정한 CG-ESP와 관련하여 이용되는 게놈 구 성들은, 생태계 유형, 생태계의 목적, 생태계의 보안 요건들, 커뮤니티 소유자의 결정들, 및/또는 기타 등등에 따라 달라질 수 있다. 도 13 내지 도 24는 소정의 Cyphergenics 기반의 프로세스들을 수행하기 위해 CG-ESP의 다양한 모듈에 의해 구현될 수 있는 예시적인 방법들을 나타낸다. 논의된 바와 같이, 본 개시내용의 일부 구현 에서, CG-ESP의 모듈들은 처리 디바이스(예컨대, 처리 디바이스의 특별 목적 프로세서/칩셋 또는 전용 코어)에 통합될 수 있는 VDAX에 배열될 수 있다. 추가적으로 또는 대안으로서, CG-ESP의 모듈들은 하나 이상의 처리 디 바이스에 의해 실행되는 실행가능한 명령어들로서 구현될 수 있다. 이하의 예시적인 구성들은 단지 예로서 제 공되는 것이며 본 개시내용의 범위를 제한하려는 의도는 아니다. 추가 모듈 구성들은 본 개시내용의 범위를 벗 어나지 않고 CG-ESP에서 나중에 개발 및 구현될 수 있다는 것을 이해해야 한다. 게놈 데이터 생성 및 할당 CG-ESP의 일부 구현에서, 선조 VDAX(예컨대, 생태계 VDAX)의 루트 DNA 모듈은 디지털 생태계 멤버들(예컨 대, 엔클레이브 VDAX들 및/또는 코호트 VDAX들)의 자손 VDAX들에 할당되는 게놈 데이터 세트들을 생성하고 업데 이트한다. 논의된 바와 같이, 게놈 데이터 세트들은, 게놈 적격성 객체들, 게놈 상관관계 객체들, 및 게놈 분 화 객체들을 포함할 수 있다. 일부 구현에서, 선조 VDAX의 루트 DNA 모듈은 원시 게놈 데이터 세트(\"원시 DNA 세트\", \"마스터 DNA 세트\", 또는 \"마스터 게놈 데이터 세트\"라고도 함)를 생성한다. 이들 구현들 중 일부 에서, 마스터 DNA 세트는 디지털 생태계의 각각의 멤버(예컨대, 엔클레이브 VDAX들 및/또는 코호트 VDAX들)에 대한 (\"DNA 세트들\" 또는 간단히 \"DNA\"라고도 하는) 게놈 데이터 세트들을 생성하기 위해 선조 VDAX에 의해 이 용되고, 여기서 생성된 게놈 데이터 세트들은 디지털 커뮤니티의 각각의 멤버들에게 할당된다. 일부 구현에서, 마스터 DNA 세트는 선조 VDAX(예컨대, 생태계 VDAX)에 할당되어, 선조 VDAX가 마스터 DNA 세트를 이용하여 디지 털 생태계의 다양한 커뮤니티 멤버와 교류할 수 있게 한다. 다른 구현들에서, 선조 VDAX는 마스터 게놈 데이터 세트로부터 그 게놈 데이터 세트를 생성하여, 선조 VDAX의 게놈 데이터 세트가 디지털 생태계의 다른 커뮤니티 멤버들의 게놈 데이터 세트들과 동일한 방식으로 생성될 수 있게 한다. CG-ESP의 일부 구현에서, 선조 VDAX의 루트 DNA 모듈은, 하나 이상의 마스터 적격성 객체(예컨대, 마 스터 CNA 객체 및/또는 마스터 PNA 객체), 마스터 상관관계 객체(예컨대, 마스터 LNA 객체), 및 마스터 분화 객 체(예컨대, 마스터 XNA 객체)를 생성하도록 구성된다. 일부 구현에서, EIC 모듈은 임시 아키텍쳐들과 관 련하여 이용되는 게놈 데이터 세트들을 생성하는 루트 DNA 모듈을 포함할 수 있다는 점에 유의한다. 이들 구현들에서, 게놈 데이터 세트들은, 분화 객체들(예컨대, ZNA 객체들)뿐만 아니라 임의의 다른 적합한 게놈 조 성들(예컨대, CNA, PNA 및/또는 LNA 객체들)을 포함할 수 있다. 일부 예시적인 구현에서, 루트 DNA 모듈(예컨대, PNA 모듈 및/또는 CNA 모듈)은, 하나 이상의 마스터 게놈 적격성 객체(예컨대, 마스터 PNA 객체 및/또는 마스터 CNA 객체)에 기초하여 디지털 생태계의 각각 의 생태계 멤버(엔클레이브 및/또는 코호트))에 대해 하나 이상의 고유한 적격성 객체(예컨대, PNA 객체들 및/ 또는 CNA 객체들)를 도출할 수 있다. 이들 구현들 중 일부에서, 각각의 생태계 멤버에는, 디지털 생태계의 각 각의 다른 상응하는 멤버들의 각각의 게놈 적격성 객체들과 상관되는 하나 이상의 고유한 게놈 적격성 객체(예 컨대, 고유 PNA 객체 및/또는 고유 CNA 객체)가 할당된다. 본 개시내용 전반에 걸쳐 논의되는 바와 같이, 생태 계 멤버들은, 링크 교환 프로세스 동안 서로의 결합 적격성 및 결합 무결성을 확정하기 위해 그들 각각의 게놈 적격성 객체들을 이용할 수 있다. 일부 구현에서, 루트 DNA 모듈(예컨대, LNA 모듈)은, 각각의 상응하는 엔클레이브에 할당되는(예컨대, 엔클레이브를 나타내는 하나 이상의 엔클레이브 VDAX에 할당될 수 있는) 고유한 게놈 상관관 계 객체(예컨대, LNA 객체들)를 생성하도록 구성된다. 논의된 바와 같이, 게놈 상관관계 객체들은, 커뮤니티 멤버들 사이에서의 정보에 기반한 게놈 상관관계를 가능케한다. 일부 구현에서, 루트 DNA 모듈은 마스터 게놈 상관관계 객체(예컨대, 마스터 LNA 객체)를 생성하고, 이로부터 루트 DNA 모듈은 하나 이상의 게놈 상관관계 객체(예컨대, 엔클레이브 특유의 LNA 객체들)를 생성한다. 이들 구현들 중 일부에서, 각각의 엔클레 이브에는 각각의 엔클레이브 특유의 게놈 상관관계 객체가 할당되고, 이에 의해, 각각의 엔클레이브의 코호트들 각각은 할당되고 엔클레이브 특유의 상관관계 객체(또는 엔클레이브 특유의 상관관계 객체의 충분히 상관된 파 생물)를 할당받고 이를 이용하여 엔클레이브의 다른 멤버들(다른 코호트 VDAX들 및/또는 엔클레이브 VDAX)과 링 크들을 교환한다. 추가적으로 또는 대안으로서, 생태계-레벨 게놈 상관관계 객체가 생태계 VDAX에 할당되어,디지털 생태계의 임의의 멤버들이 생태계-레벨 게놈 상관관계 객체를 할당받을 수 있게 할수 있다. 이들 구현 들에서, 게놈 상관관계 객체는 마스터 게놈 상관관계 객체이거나 (예컨대, 아래에서 논의되는 바와 같이) 마스 터 게놈 상관관계 객체로부터 도출된 게놈 상관관계 객체일 수 있다. 유사하게, 선조 VDAX의 루트 DNA 모듈(예컨대, XNA 모듈 또는 EIC 모듈)은, 각각의 상응하는 엔클레이브에 할당되는(예컨대, 엔클레이브를 나타내는 하나 이상의 엔클레이브 VDAX에 할당될 수 있는) 고유한 분화 객체들 (예컨대, XNA 객체들 또는 ZNA 객체들)를 생성하고, 이에 의해, 각각의 엔클레이브의 코호트들은 엔클레이브 특 유의 분화 객체(또는 엔클레이브 특정한 상관관계 객체의 충분히 상관된 파생물)를 할당받고 이를 이용하여 엔 클레이브의 다른 멤버들(다른 코호트 VDAX들 및/또는 엔클레이브 VDAX)과의 고유한 관계들을 교환한다. 구현들 에서, 선조 VDAX의 루트 DNA 모듈은, 게놈 상관관계 객체들과 동일하거나 유사한 방식으로 생태계에 대한 게놈 분화 객체들을 생성하도록 구성될 수 있다. 루트 DNA 모듈은 본 개시내용의 범위를 벗어나지 않고 디지털 생태계에 대한 상관관계 객체들 및/또는 분 화 객체들을 생성하기 위해 상이한 알고리즘들로 구성될 수 있다는 것을 본 개시내용으로부터 이해해야 한다. 도 13은 본 개시내용의 일부 구현에 따른 게놈 상관관계 객체들 및/또는 게놈 분화 객체들을 생성하기 위해 선 조 VDAX(예컨대, 루트 DNA 모듈)에 의해 실행될 수 있는 프로세스를 나타낸다. 설명의 목적을 위해, 게놈 데이터 객체라는 용어는 게놈 상관관계 객체들 및/또는 게놈 분화 객체들을 포함할 수 있다. 도 13의 예에서, 마스터 게놈 데이터 객체를 구현하는 데이터 구조(예컨대, 2진 행렬, 벡터, 및/또는 기타 등등)는 \"GDX\"라고 지 칭될 수 있는 반면, 도출된 게놈 데이터 객체들(예컨대, 엔클레이브-레벨 게놈 상관관계 객체들 및/또는 엔클레 이브-레벨 게놈 분화 객체들)은 GDXY라고 지칭될 수 있고, 여기서 GDXY는 디지털 생태계에서 K개의 그룹 중 Y번 째 그룹(예컨대, 엔클레이브)에 할당된 게놈 데이터 객체이다. 1310에서, 루트 DNA 모듈은 마스터 게놈 데이터 객체를 생성한다. 논의된 바와 같이, 마스터 게놈 데이터 객체란 마스터 게놈 상관관계 객체 또는 마스터 게놈 분화 객체를 지칭할 수 있다. 구현들에서, 루트 DNA 모듈 은 차원 N을 갖는 무작위 2진 정보 데이터 세트 GDX(예컨대, 마스터 상관관계 객체 및/또는 마스터 분화 객체)를 생성한다. 무작위 2진 정보 데이터 세트 GDX는 임의의 적절한 구조를 가질 수 있다. 일부 구현에서, 루트 DNA 객체는 2진 행렬이다. 1312에서, 루트 DNA 모듈은 디지털 생태계의 K개 그룹(예컨대, 엔클레이브)에 대한 게놈 데이터 객체들(예 컨대, 게놈 상관관계 객체들 및/또는 게놈 분화 객체들)를 생성한다. 일부 구현에서, 루트 DNA 모듈은, 고유한 게놈 생태계들 또는 엔클레이브들을 나타내는 k개의 추가적인 2진 정보 데이터 세트, GDX1...k를 도출하며, 여기서 GDX1...K 각각은 차원 N을 갖고 GDX와 동일한 레벨의 엔트로피를 나타낸다. 표-1은 K개의 추가 적인 2진 정보 데이터 세트, GDX1…k를 도출하기 위한 한 예시적인 프로세스를 보여준다. [표 1]"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "표 1의 예에서, 루트 DNA 모듈은, T=N/X 등의 P차의 T개의 원시 2진 다항식을 선택할 수 있다. 그 다음, 루트 DNA 모듈은 T개의 원시 2진 다항식을 이용하여 마스터 게놈 데이터 객체 GDX를 수정할 수 있다. 예 를 들어, 루트 DNA 모듈은 GDX를 GDXT로 수정하기 위해 다음을 적용할 수 있다: g(x)= 1 + a1*x+...+aP-1*xP- 1+xP. 루트 DNA 모듈은 GDX를 GDXT로 수정하기 위해 다른 적합한 기술들을 이용할 수 있다는 것을 이해해야 한다. 루트 DNA 모듈은 변환된 마스터 게놈 데이터 객체 GDXT를 이용하여, K개의 그룹에 대한 k개의 게놈 데이터 객체를 생성할 수 있다. 일부 구현에서, 루트 DNA 모듈은 아래의 표 2에 도시된 예시적인 프로세스에 따라 k개 그룹 중 y번째 그룹 에 대한 게놈 데이터 객체(GDXy)를 생성할 수 있다. 표 2의 예는 게놈 데이터 객체의 생성의 일부로서 수행되 는 것으로 도시되어 있다는 점에 유의한다. 추가적으로, 본 개시내용의 일부 구현에서, 표 2의 예시적인 프로 세스 또는 그 변형들은, 게놈 데이터 객체들을 수정하기 위해(예컨대, 엔클레이브 및/또는 생태계의 게놈 데이 터 객체를 업데이트할 때) 루트 DNA 모듈에 의해 이용될 수 있다. [표 2]"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "표 2의 예에서, L비트 2진 서열 Sy는 0 내지 (2L-1)의 값이다. 일부 구현에서, 고유한 생태계들 및/또는 엔클레 이브들의 수 k는 L에 의해 제한된다. 서열 Sy는 비공개 서열, 공개 서열, 또는 무작위로 생성된 서열일 수 있 다. 일부 구현에서, 새로운 서열 Sy는 각각의 그룹에 대해 무작위로 생성될 수 있다. 이러한 방식으로, 각각 의 게놈 데이터 객체인 GDXy는 상이한 서열을 이용하여 생성된다. 대안으로서, 루트 DNA 모듈은 임의의 적절한 데이터 소스로부터 공개 또는 비공개 서열을 선택하도록 구성될 수 있다. 이들 구현들에서, 각각의 게 놈 데이터 객체 GDXy는 상이한 서열을 이용하여 여전히 생성되며, 이로써 각각의 그룹(예컨대, 엔클레이브)이 상 이한 게놈 데이터 객체를 할당받도록 보장한다. 일부 구현에서, 표 2에 제공된 예의 맵핑 단계는 서열 맵핑 모듈에 의해 수행될 수 있고, 이에 의해 루트 DNA 모듈은 서열 맵핑 모듈에 대한 입력으로서 서열 및 GDXT를 제공하고, 서열 맵핑 모듈은 변 환값 TVY를 획득하기 위해 서열을 GDXT에 맵핑한다. 일부 구현에서, 루트 DNA 모듈은 서열을 GDXT에 맵핑 하도록 구성될 수 있다. 일부 구현에서, 루트 DNA 모듈은 계산 기능(예컨대, 암호, 암호 없는, 또는 하이브리드 기능)을 이용하여 GDX를 수정할 수 있다. 이들 구현들 중 일부에서, 계산 기능은, 마스터 게놈 데이터 객체 GDX와 변환값 TVy를 수신하고, 디지털 생태계의 y번째 그룹에 할당된 게놈 데이터 객체 GDXy를 출력한다. 일부 구현에서, GDX의 수 정은 2진 변환 모듈에 의해 수행되며, 이로써 루트 DNA 모듈은 게놈 데이터 객체를 생성할 때 2진 변 환 모듈을 기동한다. 표 1 및 표 2의 예에서, 루트 DNA 모듈은 원시 다항식을 이용하여 GDX를 수정하거나, TVK를 결정하거나, S를 선 택하거나, SK를 RT에, 맵핑하거나, 및/또는 GDXT를 변환하기 위해 광범위한 상이한 구성들(예컨대, 실행가능한 계산 방법들)을 이용할 수 있다. 또한, 표 1 및 표 2의 예들은, 생태계의 각각의 그룹들에 할당되는 게놈 데이 터 객체들을 생성하기 위한 프로세스를 설명한다. 논의된 바와 같이, 생태계 VDAX 및/또는 엔클레이브 VDAX는, 마스터 게놈 데이터 객체 및/또는 하나 이상의 그룹의 하나 이상의 게놈 데이터 객체를 수정하도록 구성될 수 있다. 예를 들어, 생태계 VDAX는 엔클레이브의 게놈 토폴로지를 변경하도록(예컨대, 엔클레이브로부터 하나 이 상의 코호트를 제거하도록) 엔클레이브의 게놈 데이터 객체를 수정할 수 있다. 일부 구현에서, 생태계 VDAX 또 는 엔클레이브 VDAX는 표 1 및 표 2에 제시된 프로세스들을 이용하여 게놈 데이터 객체들을 수정할 수 있다. 예를 들어, 특정한 엔클레이브의 현재 게놈 데이터 객체를 수정함에 있어서, 생태계 VDAX 또는 엔클레이브를 나 타내는 엔클레이브 VDAX는, P차의 T개의 2진 다항식을 선택하고, T개의 다항식을 이용하여 현재의 게놈 데이터 객체를 변환하고, L-비트 서열을 선택하고, 서열을 변환된 게놈 데이터 객체에 맵핑하여 변환값을 획득하고, 변 환값을 이용하여 현재의 게놈 데이터 객체를 수정하여 특정한 엔클레이브에 대한 새로운 게놈 데이터 객체를 획 득한다. 그 다음, 이 새로운 게놈 데이터 객체는 엔클레이브에 남아 있는 엔클레이브의 코호트들에게 제공될 수 있다. 이러한 방식으로, 새로운 게놈 데이터 객체가 제공되지 않은 엔클레이브 내의 임의의 코호트는 더 이 상 엔클레이브의 나머지 코호트들에 참여할 수 없다. 마찬가지로, 미인가된 VDAX가 생태계 또는 그 엔클레이브 에 대한 게놈 데이터 객체(예컨대, 게놈 상관관계 객체 또는 게놈 분화 객체)를 획득할 수 있는 경우, 생태계 VDAX 또는 엔클레이브 VDAX는 업데이트된 게놈 데이터 객체를 생성하고 업데이트된 게놈 데이터를 생태계 또는 엔클레이브의 인가된 VDAX들에 배포할 수 있다. 게놈 데이터 객체들의 수정은 본 개시내용의 범위를 벗어나지않고 나중에 개발된 프로세스들을 이용하여 수행될 수 있다는 것을 이해해야 한다. 소정의 시나리오들에서, 디지털 생태계의 게놈 데이터 객체들(예컨대, 마스터 게놈 데이터 객체들 및/또는 할당 되거나 미할당된 게놈 데이터 객체들)은 이 데이터의 민감성으로 인해 특별한 보호를 요구할 수 있다. 일부 구 현에서, CG-ESP(예컨대, 루트 DNA 모듈)은, 게놈 데이터 객체들(예컨대, 마스터 게놈 데이터 객체들 및/또는 생태계 멤버들의 할당되거나 미할당된 게놈 데이터 객체들) 및/또는 게놈 데이터 객체들을 생성하는데 이용된 데이터를 안전하게 유지하도록 구성된다. 이들 구현들 중 일부에서, CG-ESP는, Shamir 임계값 방 식(\"Shamir의 비밀 공유\"라고도 함)을 이용하여 게놈 데이터 객체들 및/또는 게놈 데이터 객체들을 생성하는데 이용되는 데이터를 저장하도록 구성될 수 있다. 구현들에서, Shamir 임계값 방식은 임의의 유형의 게놈 데이터 객체(예컨대, LNA 객체, CNA 객체, PNA 객체, XNA 객체, ZNA 객체 등)를 저장하도록 개조될 수 있다. 예를 들 어, 차원 4096 x 4096의 마스터 게놈 데이터 객체 GDX의 경우, GDX는 214개의 1024비트 섹션들로 세그먼트화될 수 있다. 예를 들어, GDX 행렬은 GDX의 212개 행에 대해 2개의 섹션을 생성함으로써 세그먼트화될 수 있다. 이 예에서, 1024비트 섹션들 각각은 1024비트 다항식으로서 표시된다. 그 다음, Shamir(5, 3) 임계값 방식이 (각 각 세그먼트들을 나타내는) 각각의 1024비트 다항식들 각각에 적용될 수 있다. 일부 구현에서, GDX로부터 도출 된 k개의 게놈 데이터 객체를 생성하는데 이용되는 데이터를 저장하기 위해 Shamir(5, 3) 임계값 방식이 추가로 적용될 수 있다. 예를 들어, GDX를 GDXT로 수정하는데 이용된 원시 2진 다항식들(예컨대, 16개의 256비트 원시 2진 다항식들) 각각에 Shamir(5, 3) 임계값 방식이 적용될 수 있다. 추가적으로 또는 대안으로서, Shamir(5, 3) 임계값 방식은 그룹-특유의 게놈 데이터 객체들 GDXY를 생성하는데 이용된 서열들 Sy 각각에 적용될 수 있다. 예를 들어, 각각의 서열 Sy가 256비트 값인 경우, 각각의 256비트 값은 2진 다항식으로서 표현될 수 있고, Shamir(5, 3) 임계값 방식이 2진 다항식들 각각에 적용될 수 있다. 전술된 내용은 게놈 데이터 객체 및 관련 데이터를 저장하기 위해 Shamir Secret Sharing이 어떻게 적용될 수 있는지에 대한 예들이며 제공된 값들은 단 지 예일 뿐이라는 점을 이해해야 한다. 또한, 게놈 데이터 객체들을 안전하게 저장하기 위한 추가적인 또는 대 안적인 기술들이 개발될 수 있다. 언급된 바와 같이, 예시적인 프로세스는 게놈 상관관계 객체들(예컨대, LNA 객체들) 및/또는 게놈 분화 객체들 (예컨대, XNA 또는 ZNA 객체들)를 생성하기 위해 루트 DNA 모듈에서 구현될 수 있다. 예시적인 프로세스 들은, 암호 기반, 암호 없는, 또는 하이브리드일 수 있다. 도 14와 도 15는 LNA 객체들의 암호 기반의 및 하이 브리드 생성의 예들을 제공한다. 이들 예에서, 설명의 목적을 위해 소정의 값들(예컨대, 게놈 데이터 객체들 및 기타 데이터 구조의 차원들, 서열 크기들, 그룹 수들 등)이 정의된다. 값들은 오직 예시를 위해서만 제공되 며, 상이한 최적화들 및/또는 효과들을 달성하기 위해 조정될 수 있다. LNA 생성 본 개시내용의 일부 구현에서, 루트 DNA 모듈은 디지털 생태계의 멤버들에게 할당되는 LNA 객체들을 생성 하도록 구성된 LNA 모듈을 포함할 수 있다. 논의된 바와 같이, LNA 모듈의 구성은, 암호 기반, 암호 없는, 또는 하이브리드일 수 있다. 일부 구현에서, 도 13의 프로세스는 게놈 상관관계 객체들(예컨대, LNA 객 체들)을 생성하기 위해 LNA 모듈에서 구현될 수 있다. 예를 들어, 도 14 및 도 15는 본 개시내용의 일부 구현에 따른 게놈 상관관계 객체들을 생성하기 위한 예시적인 방법들을 제공한다. 이들 예들에서, LNA 모듈 은 마스터 LNA 객체를 생성하고 k개의 LNA 객체 세트를 도출하도록 구성된다. 일부 구현에서, 각각의 그 룹 내의 멤버들(예컨대, 코호트들)은 상호 관심 ID를 갖는다. 구현들에서, 각각의 LNA 객체는 디지털 생태계 내의 각각의 그룹(예컨대, 엔클레이브 또는 전체 생태계)에 할당되어, 각각의 엔클레이브 내의 커뮤니티 멤버들 (예컨대, 코호트 VDAX들)이 각각의 LNA 객체를 이용하여 링크들을 교환할 수 있게 할 수 있다. 이들 예시적인 구성들에서, LNA 모듈은 고정 크기 2진 행렬들(예컨대, n x m 행렬들)로 구조화된 LNA 객체들을 생성하도 록 구성된다. 2진 행렬들은 2원 벡터들로서 표현될 수 있다는 것을 이해해야 한다. 본 개시내용으로부터 알 수 있는 바와 같이, CG-ESP의 구성가능한 속성들은 커뮤니티 소유자(예컨대, 크기, 구 조, 보안 레벨들, 의도된 용도, 및/또는 멤버십 요건들을 정의하는 엔티티)가 최대 그룹 수(K), LNA 객체의 차 원(예컨대, n x m), LNA 객체 구역들의 크기, 및/또는 기타의 적합한 파라미터들로 LNA 모듈을 파라미터화 하는 것을 허용한다. 더욱이, 본 개시내용 전체에 걸쳐 논의되는 바와 같이, 커뮤니티 소유자는 LNA 객체 생성 프로세스에서 이용되는 계산 동작들의 유형들 및 순서를 정의할 수 있다. 예를 들어, 커뮤니티 소유자는, 예를 들어, 마스터 게놈 상관관계 객체를 생성하거나 및/또는 게놈 상관관계 객체를 수정하는데 이용되는 특정한 암 호 기반의 기능들(예컨대, 상이한 암호화 기능들, 명료화 기능들, 및/또는 기타 등등) 및/또는 암호없는 기능들(예컨대, 해시 기능들, 파라미터화된 순환 비트-시프트 연산들, 및/또는 기타 등등)로 LNA 모듈을 구성할 수 있다. 도 14와 도 15의 예들을 논의할 때, 예시적인 LNA 객체들은 4096비트 x 4096비트 행렬들로서 기술된다. LNA 객 체들은, 디지털 커뮤니티의 유형, 디지털 커뮤니티의 보안 요건들, 디지털 커뮤니티의 의도된 크기, 디지털 커 뮤니티의 목적, 및/또는 기타의 적절한 구성에 따라 더 크거나 더 작을 수 있다는 것을 이해해야 한다. 예를 들어, LNA 객체들의 크기는, 9182비트 x 9182비트, 1024비트 x 1024비트, 512비트 x 512비트, 1024비트 x 256 비트, 또는 기타 임의의 적절한 값일 수 있다. 또한, 이 예에서 LNA 객체들이 생성되는 최대 엔클레이브 수 k 는 4096개 그룹(엔클레이브 또는 생태계)이다. 값 k는 디지털 커뮤니티와 커뮤니티 소유자의 필요사항에 따라 조정될 수 있다는 것을 이해해야 한다. 예를 들어, 더 크거나 및/또는 더 복잡한 생태계들은, 수백 또는 수천 개의 엔클레이브들을 가질 수 있는 반면, 더 작고/또는 덜 복잡한 생태계들은 10개, 5개, 2개 또는 1개의 엔클 레이브만을 가질 수 있다. 일부 예시적인 구현에서, LNA 모듈은, n x m(예컨대, 4096비트 x 4096비트) 크 기의 k(예컨대, k= 4096)개의 고유 LNA 객체들을 생성하기 위해 2진 원시 다항식들(예컨대, 256차) 등의 계산적 복합 수학적 구조들을 이용할 수 있다. 제공된 예들에서, n은 m과 동일하지만(예컨대, n = 4096 및 m = 4096), n이 m과 동일할 것이 요구되는 것은 아니다. 구현들에서, LNA 모듈은 마스터 LNA 객체(아래 예들에서는 \"LNA\"라고 지칭될 수 있음)를 무작위로 생성할 수 있고, 디지털 생태계의 k개의 각각의 그룹들에 대해 마스터 LNA 객체로부터 k개의 상이한 LNA 객체를 생성할 수 있다(여기서 LNA로부터 생성된 y번째 LNA 객체는 \"LNAy\"라 고 지칭됨). 아래의 도 14는 본 개시내용의 일부 예시적인 구현에 따른 디지털 생태계에 대한 LNA 객체들을 생성하기 위한 예시적인 암호 기반의 방법을 제공한다. LNA 모듈은 본 개시내용의 범위를 벗어나지 않고 다른 적절한 암 호 기반의 방식들로 LNA 객체들을 생성하도록 구성될 수 있다는 것을 이해해야 한다. 1412에서, LNA 모듈은 마스터 LNA 객체를 생성한다. 예시적인 구현들에서, LNA 모듈은 4096비트 x 4096비트 행렬로 구조화된 무작위 2진 정보 데이터 세트를 생성한다. 이들 구현들 중 일부에서, 무작위 2진 정 보 데이터 세트는 마스터 LNA 객체이며, 여기서 마스터 LNA 객체의 각각의 행은 j개의 고정 길이 구역(예컨대, 16개의 256비트 영역) 세트로 조직화되어, LNA의 i 번째 행이 로서 정의될 수 있다. 예를 들어, 마스터 LNA 객체는 i = 1…4096 및 j = 16에 대해 정의될 수 있다. 이 예에서, 마스터 LNA 객체는 4096개의 행 을 포함할 수 있고, 여기서, 각각의 행은, 각각이 256비트 길이인 16개의 구역을 포함한다. 전술된 값들은 단 지 예로서 제공되는 것임을 이해해야 한다. 1414에서, LNA 모듈은, 마스터 LNA 객체, LNA를, 변환된 LNA 객체, LNAT로 변환한다. 구현들에서, LNA 모 듈은 j(예컨대, j=16)개의 무작위로 선택된 2진 원시 다항식, 를 이용하여 LNA를 LNAT로 변환한다. 이들 구현들 중 일부에서, 2진 원시 다항식들 각각은 명시된 차수이다(예컨대, 256차 2진 원 시 다항식들). 이들 구현들에서, 각각의 상응하는 행 ti에 의해 표현된 각각의 상응하는 값은 각각의 수정된 값 ti(m)으로 변환된다. 이들 구현들 중 일부에서, LNA의 각각의 행은 다음에 따라 변환될 수 있다 : . 이 예에서, 전술된 변환 기능은, 이 기능이 이산 로그 문제를 해결함으로써 가역적이 될 수 있으므로 암호 기반 이다. 마스터 LNA 객체는 본 개시내용의 범위를 벗어나지 않고 다른 적절한 방식들로 변환될 수 있다는 것을 이해해야 한다. 1416에서, LNA 모듈은 디지털 생태계의 k개의 각각의 그룹에 대해 k개의 LNA 객체를 생성한다. 일부 구현 에서, LNA 모듈은 디지털 커뮤니티 내의 각각의 상응하는 그룹에 대한 각각의 LNA 객체를 생성한다. 이들 구현들 중 일부에서, LNA 모듈은 마스터 LNA 객체 및 변환된 LNA 객체, LNAT에 기초하여 LNA 객체를 도출 한다. 표 3은 마스터 LNA 객체(LNA로 표시됨)와 변환된 마스터 LNA 객체(LNAT로 표시됨)에 기초하여 LNA 객체 를 생성하기 위한 예시적인 프로세스를 정의한다. 이 예에서, LNA 모듈은 다음과 같이 디지털 생태계의 y 번째 그룹(예컨대, Groupy)에 대한 y번째 LNA 객체를 생성할 수 있다:[표 3]"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "한 예시적인 구현에서, LNA 모듈은 256비트 서열 Sy를 선택할 수 있다. 이 예시적인 구성에서, L 값은 256이어서, Sy 값은 0 내지 (2256-1)이다. LNA 모듈의 구성에 따라, Sy는, 비공개 서열, 공개 서열, 또는 무작위로 생성된 서열일 수 있다. 논의된 바와 같이, 새로운 서열 Sy는 각각의 그룹에 대해 무작위로 생성될 수 있다. 이러한 방식으로, 각각의 LNA 객체 LNAy는 상이한 서열을 이용하여 생성된다. 대안으로서, LNA 모듈 은 임의의 적절한 데이터 소스로부터 공개 또는 비공개 서열을 선택하도록 구성될 수 있다. 이들 구현들 에서, LNA 객체 LNAy는 상이한 서열을 이용하여 여전히 생성되며, 이로써 각각의 그룹(예컨대, 엔클레이브)이 상이한 게놈 데이터 객체를 할당받도록 보장한다. 일부 구현에서, 표 3에 제공된 예의 맵핑 단계는 서열 맵핑 모듈에 의해 수행될 수 있고, 이에 의해 루트 LNA 모듈은 서열 맵핑 모듈에 대한 입력으로서 Sy 및 LNAT를 제공하고, 서열 맵핑 모듈 서열을 LNAT에 맵핑함으로써 결정되는 변환값 TVy를 출력한다. 일부 구현에서, LNA 모듈은 서열을 LNAT에 맵핑함 으로써 변환값을 결정하도록 구성될 수 있다. 표 3의 예에서, LNA 모듈은, 디지털 생태계의 각각의 그룹에 대해 LNA 객체 LNAy를 획득하기 위해 변환값 TVy를 이용하여 마스터 LNA 객체 LNA를 수정하는 암호 기반의 기능을 실행한다. 예시적인 구현들에서, 암호 기 반의 기능은 암호화 기능 또는 명료화 기능일 수 있다. 이들 구현들 중 일부에서, LNA 모듈은, 각각의 LNA 객체를 생성할 때 2진 변환 모듈에 대한 입력으로서 변환값 및 마스터 LNA 객체를 제공함으로써 LNA 객체를 결정하도록 구성된다. 대안으로서, LNA 모듈은 암호 기반의 변환 기능을 실행함으로써 LNA 객체 LNAy를 결정하도록 구성될 수 있다. 일단 생성되고 나면, 선조 VDAX는 LNA 객체 LNAy를 y번째 그룹(예컨대, 엔 클레이브 또는 생태계)에 할당할 수 있고, 이에 의해 LNA 객체는 그룹의 멤버들(예컨대, 엔클레이브 또는 생태 계 내의 코호트들)에게 제공될 수 있다. 도 14의 예는 단지 예로서 제공된다. 예를 들어, 암호 기반의 방식으로 마스터 LNA 객체를 수정하거나, 변환값 TVK를 결정하거나, 서열을 선택하거나, 서열을 변환된 마스터 LNA 객체에 맵핑하거나, 및/또는 마스터 LNA 객체 를 LNA 객체로 변환하기 위해, 광범위한 상이한 구성들(예컨대, 실행가능한 계산 방법들)이 개발될 수 있다는 것을 이해해야 한다. 아래의 도 15는, 본 개시내용의 일부 예시적인 구현에 따른 디지털 생태계에 대한 LNA 객체들을 생성하기 위한 예시적인 하이브리드 방법(예컨대, 적어도 하나의 암호 기반의 동작 및 적어도 하나의 암호 없는 동작)을 제공 한다. 일부 예시적인 구현에서, 도 15의 기술은 암호 기반의 기능과 암호 없는 기능의 조합을 이용하여 디지털 생태계에 대한 LNA 객체들을 생성하기 위해 LNA 모듈에서 구현될 수 있다. 도 15의 예시적인 구현을 논의 할 때, LNA 모듈은 4096비트 x 4096비트 크기의 LNA 객체들을 생성하는 것으로 설명된다. 이들 예시적인 구성들에서, LNA 모듈은 마스터 LNA 객체(예컨대, 위의 표 2의 \"GDX\")로부터 k개의 상이한 그룹에 대해 최 대 k개의 LNA 객체(예컨대, k = 4096)를 도출한다. 예시적인 구현들에서, 암호 없는 기능들은, 하나 이상의 보 안 수정 파라미터를 이용하여 파라미터화될 수 있는, 파라미터화가능한 암호 없는 동작들을 포함할 수 있다. 예시적인 구현들에서, 암호 없는 동작들은 XOR와 순환 시프트 동작의 조합일 수 있고, 여기서 LNA 모듈은 보안 수정 파라미터들을 무작위로 생성하여 XOR와 순환 시프트 동작들의 조합을 파라미터화하며, 그 예시적인 구현들이 아래에서 설명된다. 1512에서, LNA 모듈은 마스터 LNA 객체를 생성한다. 예시적인 구현들에서, LNA 모듈은 n x m 행렬 (예컨대, 4096비트 x 4096비트 행렬)로 구조화된 무작위 2진 정보 데이터 세트를 생성한다. 이들 구현들 중 일 부에서, 무작위 2진 정보 데이터 세트는 마스터 LNA 객체이고, 여기서 마스터 LNA 객체의 각각의 행은 한 세트 의 n개 행들 [R1, R2,…Rn]로 구성된다. 이 예에서, Ri는 무작위로 생성된 마스터 LNA 객체의 i번째 행일 수 있고, [Ri,1, Ri,2,…Ri,m]으로서 정의될 수 있다, 여기서 Ri,j는 i번째 행의 j번째 열의 개개의 비트 값이다. 이 예에서, 마스터 LNA 객체는 4096개의 행을 포함할 수 있고, 여기서, 각각의 행은, 각각이 256비트 길이인 16개 의 구역을 포함한다. 전술된 값들은 단지 예로서 제공되는 것이며, LNA 모듈은 다른 적절한 방식들로 마 스터 LNA 객체를 생성하도록 구성될 수 있다는 것을 이해해야 한다. 1514에서, LNA 모듈은 암호없는 변환 기능을 이용하여 마스터 LNA 객체 LNA를 변환된 LNA 객체 LNAT로 변 환한다. 구현들에서, LNA 모듈은 보안 수정 파라미터(SMP; secure modification parameters) 세트를 이 용하여 LNA를 LNAT로 변환한다. 일부 구현에서, SMP는 마스터 LNA 객체에 적용되는 파라미터화가능한 동작 세 트를 파라미터화하는데 이용되는 파라미터 세트를 정의할 수 있다. 파라미터화가능한 동작들의 예들로는, 순환 비트 시프트 동작들, XOR 동작들, 및/또는 기타 등등이 포함될 수 있다. 이들 예에서, SMP는, 마스터 LNA 객체 의 각각의 행에 대해, 정의된 방향으로 행을 시프트하기 위한 비트 위치들의 각각의 수 및/또는 행을 XOR하는 값을 정의할 수 있다(예컨대, 시프트 후, 시프트 전, 또는 시프트 대신). 예를 들어, SMPi는, i번째 행에 대한 보안 수정 파라미터들을 정의할 수 있고, i번째 행을 순환적으로 시프트하기 위한 비트 위치들의 수(예컨대, 우 측으로 n 비트)를 나타내는 제1 파라미터와, i번째 행과 XOR되는 무작위 값을 정의하는 제2 파라미터를 포함할 수 있다. 제2 파라미터는 0 내지 (2m-1)의 값일 수 있고, 여기서 m은 LNA 객체의 한 행 내의 비트 수라는 것을 이해해야 한다. 이들 구현들에서, LNA 모듈은, LNA 객체의 각각의 행을, 그 행에 대응하는 각각의 SMP들 로 파라미터화되는 파라미터화가능한 동작 세트를 이용하여 변환하여 변환된 마스터 LNA 객체 LNAT를 획득할 수 있다. 이들 예시적인 구현들에서, LNA 모듈은, 마스터 LNA 객체의 각각의 상응하는 행을 각각 변환하기 위해 SMP 세트(예컨대, SMPi)를 무작위로 생성하는 것을 포함한, 임의의 적절한 방식으로 SMP들을 결정할 수 있 다. LNA 모듈은 본 개시내용의 범위를 벗어나지 않고 다른 암호없는 방식들 또는 암호 기반의 방식들(예 컨대, 도 14의 단계 1414)로 마스터 LNA 객체를 변환하도록 구성될 수 있다는 것을 이해해야 한다. 1516에서, LNA 모듈은 디지털 생태계의 k개의 각각의 그룹에 대해 k개의 LNA 객체를 생성한다. 일부 구현 에서, LNA 모듈은 디지털 커뮤니티 내의 각각의 상응하는 그룹(예컨대, 엔클레이브)에 대한 각각의 LNA 객 체를 생성한다. 이들 구현들 중 일부에서, LNA 모듈은 마스터 LNA 객체 및 변환된 LNA 객체, LNAT에 기초 하여 LNA 객체를 도출한다. 표 4는 마스터 LNA 객체(LNA로 표시됨)와 변환된 마스터 LNA 객체(LNAT로 표시 됨)에 기초하여 LNA 객체를 생성하기 위한 예시적인 프로세스를 정의한다. 이 예에서, LNA 모듈은 다음과 같이 디지털 생태계의 y번째 그룹(예컨대, Groupy)에 대한 y번째 LNA 객체를 생성할 수 있다: [표 4]"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "한 예시적인 구현에서, LNA 모듈은 256비트 서열 Sy를 선택할 수 있다. 이 예시적인 구성에서, L 값은 256이어서, Sy 값은 0 내지 (2256-1)이다. LNA 모듈의 구성에 따라, Sy는, 비공개 서열, 공개 서열, 또는 무작위로 생성된 서열일 수 있다. 논의된 바와 같이, 새로운 서열 Sy는 각각의 그룹에 대해 무작위로 생성될 수 있다. 이러한 방식으로, 각각의 LNA 객체 LNAy는 상이한 서열을 이용하여 생성된다. 대안으로서, LNA 모듈 은 임의의 적절한 데이터 소스로부터 공개 또는 비공개 서열을 선택하도록 구성될 수 있다. 이들 구현들 에서, LNA 객체 LNAy는 상이한 서열을 이용하여 여전히 생성되며, 이로써 각각의 그룹(예컨대, 엔클레이브)이 상이한 게놈 데이터 객체를 할당받도록 보장한다. 일부 구현에서, 표 4에 제공된 예의 맵핑 단계는 암호 기반의 서열 맵핑 기능일 수 있다. 이들 구현들 중 일부 에서, 암호 기반의 서열 맵핑 기능은 서열 맵핑 모듈에 의해 수행될 수 있다. 이들 예시적인 구현들에서, LNA 모듈은 Sy 및 LNAT를 서열 맵핑 모듈에 입력으로서 제공함으로써 변환값을 결정하고, 서열 맵핑모듈은 변환값 TVy를 획득하기 위해 서열을 LNAT에 맵핑한다. 일부 구현에서, LNA 모듈은 변환값을 결정하기 위해 서열 맵핑 기능을 수행하도록 구성될 수 있다. 일부 구현에서, LNA 모듈은, 디지털 생태계의 각각의 그룹(Groupy)에 대해, LNA 객체 LNAy를 획득하기 위 해, 변환값 TVy를 이용하여 마스터 LNA 객체 LNA를 수정하는 암호없는 변환 기능을 이용할 수 있다. 예시적인 구현들에서, 암호없는 기능은, 역상 저항성 해시 기능(pre-image resistant hash function), 변환값을 이용하 여 파라미터화되는 파라미터화가능한 동작 세트 등을 포함할 수 있다. 도 15의 예는 단지 예로서 제공된다. 예를 들어, 변환된 마스터 LNA 객체를 획득하기 위해 마스터 LNA 객체를 수정하거나, 서열을 선택하거나, 변환값 TVk를 결정하거나, 및/또는 마스터 LNA 객체를 LNA 객체로 변환하기 위 해, 광범위한 상이한 구성들(예컨대, 실행가능한 계산 방법들)이 개발될 수 있다는 것을 이해해야 한다. 게다 가, 일부 구현에서, 도 15의 예시적인 프로세스의 암호 기반의 동작들은 암호없는 동작으로 대체되어, LNA 모듈 이 암호없는 방식으로 구성될 수 있게 할 수 있다. 도 14 및 도 15의 예에서, LNA 모듈은 결과적인 LNA 객체 LNAy를 디지털 커뮤니티의 각각의 엔클레이브에 할당할 수 있다. 이들 예시적인 구현들 중 일부에서, 각각의 엔클레이브를 나타내는 엔클레이브 VDAX는 그 LNA 객체 LNAY를 엔클레이브의 멤버들(예컨대, 코호트들의 코호트 VDAX들)에 할당할 수 있다. 구현들에서, 각각의 코호트 VDAX의 링크 모듈은, 각각의 코호트 VDAX가 대응하는 엔클레이브에서 코호트의 또 다른 코호트 VDAX에 대한 링크를 스폰하거나 그로부터의 링크를 디코딩할 때마다 그 할당된 LNA 객체를 수정할 수 있다. 이 러한 방식으로, LNA 객체는 대응하는 엔클레이브 및/또는 생태계의 멤버들 사이의 초확장성 상관을 용이화하기 위한 메커니즘을 제공한다. 도 14 및 도 15에 제공된 예들은 LNA 모듈의 예시적인 구성들이고, 커뮤니티 멤버들에 대한 LNA 객체들을 생성하기 위한 추가적 및 대안적 수단이 나중에 개발될 수 있다는 것을 이해해야 한다. 또한, 도 14 및 도 15의 예들은 생태계의 각각의 그룹들에 할당된 LNA 객체들을 생성하는 프로세스들을 도시한 다. 논의된 바와 같이, 생태계 VDAX 및/또는 엔클레이브 VDAX는, 마스터 LNA 객체 및/또는 하나 이상의 엔클레 이브의 하나 이상의 LNA 객체를 수정하도록 구성될 수 있다. 예를 들어, 생태계 VDAX는 엔클레이브의 게놈 토 폴로지를 변경하기 위해(예컨대, 엔클레이브로부터 하나 이상의 코호트를 제거하거나, 보안 상의 이유로 LNA 객 체를 주기적으로 변경하기 위해, 또는 기타 등등을 위해) 엔클레이브의 LNA 객체를 수정할 수 있다. 이 시나리 오에서, 엔클레이브의 LNA 객체의 수정은, 코호트가 향후에 엔클레이브 내의 다른 코호트들과 링크를 교환하는 것을 방지할 것이다. 게놈 분화 객체(예컨대, XNA 객체)에 대한 수정이 없으면, 코호트는 링크들이 성공적으로 교환된 코호트들과 VBLS를 계속 교환할 수 있을 것이다. 일부 구현에서, 생태계 VDAX 또는 엔클레이브 VDAX는, 표 3 또는 표 4에 제시된 예시적인 프로세스를 이용하여 이러한 목적으로 LNA 객체를 수정할 수 있다. 예를 들 어, 특정한 엔클레이브의 현재의 LNA 객체를 수정함에 있어서, 생태계 VDAX 또는 엔클레이브를 나타내는 엔클레 이브 VDAX는 현재의 LNA 객체를 변환하여 변환된 LNA 객체를 획득하고, L비트 서열을 선택하고, 이 서열을 변환 된 LNA 객체에 맵핑하여 변환값을 획득하고, 변환값을 이용하여 현재의 LNA 객체를 수정하여 특정한 엔클레이브 에 대한 새로운 LNA 객체를 획득할 수 있다. 그 다음, 이 새로운 LNA 객체는 엔클레이브에 남아 있는 코호트들 에게 제공될 수 있다. 이러한 방식으로, 새로운 LNA 객체가 제공되지 않은 엔클레이브 내의 임의의 코호트는 엔클레이브에 남아 있는 코호트들과 더 이상 링크들을 교환할 수 없을 것이다. 게놈 데이터 객체들의 수정은 본 개시내용의 범위를 벗어나지 않고 나중에 개발된 프로세스들을 이용하여 수행될 수 있다는 것을 이해해야 한 다. XNA 생성 본 개시내용의 일부 구현에서, 루트 DNA 모듈은 디지털 생태계의 멤버들에게 할당되는 XNA 객체들을 생성 하도록 구성된 XNA 모듈을 포함할 수 있다. 논의된 바와 같이, XNA 모듈의 구성은, 암호 기반, 암호 없는, 또는 하이브리드일 수 있다. 일부 구현에서, 도 13의 프로세스는 게놈 분화 객체들(예컨대, XNA 객체들)을 생성하기 위해 XNA 모듈에서 구현될 수 있다. 도 16 및 도 17의 예들은, 본 개시내용의 일부 구현에 따른 게놈 분화 객체들을 생성하기 위한 예시적인 방법들을 제공한다. 이들 예들에서, XNA 모듈은 마스터 XNA 객체를 생성하고 디지털 생태계의 k개 그룹의 k개 XNA 객체 세트를 도출하도록 구성된다. 이들 구 현들에서, 각각의 XNA 객체는 디지털 생태계(예컨대, 디지털 생태계의 엔클레이브 또는 디지털 생태계 전체)의 각각의 그룹에 할당되어, 각각의 XNA 객체가 그룹 멤버들(예를 들어, 코호트 VDAX들, 엔클레이브 VDAX들, 및/또 는 기타 등등)에 제공됨으로써 그룹 멤버들이 각각의 XNA 객체를 이용하여 VBLS를 안전하게 교환하는 것을 허용할 수 있다(이들 그룹 멤버들이 링크들을 교환했다고 가정). 본 개시내용으로부터 알 수 있는 바와 같이, CG-ESP의 구성가능한 속성들은 커뮤니티 소유자(예컨대, 크기, 구 조, 보안 레벨들, 의도된 용도, 및/또는 멤버십 요건들을 정의하는 엔티티)가 최대 그룹 수(k), XNA 객체의 차 원(예컨대, n x m), XNA 객체 구역들의 크기, 및/또는 기타의 적합한 파라미터들로 XNA 모듈을 파라미터화 하는 것을 허용한다. 더욱이, 본 개시내용 전체에 걸쳐 논의되는 바와 같이, 커뮤니티 소유자는 XNA 객체 생성 프로세스에서 이용되는 계산 기능들의 유형들을 정의할 수 있다. 예를 들어, 커뮤니티 소유자는 특정한 암호 기반의 기능들(예컨대, 상이한 암호화 기능들, 명료화 기능들, 및/또는 기타 등등) 및/또는 암호없는 기능들(예 컨대, 해시 기능들, 파라미터화된 순환 비트 시프트 동작들, 및/또는 기타 등등)을 이용하여 XNA 모듈을 구성할 수 있다. 일부 예시적인 구현들에서, XNA 모듈은 고정 크기 2진 행렬들(예컨대, n x m 행렬들)로 구조화된 XNA 객체 들을 생성하도록 구성된다. 2진 행렬들은 2원 벡터들로서 표현될 수 있다는 것을 이해해야 한다. 도 16 및 도 17의 예들에서, 예시적인 XNA 객체들은 4096비트 x 4096비트 행렬들이다. XNA 객체들은, 디지털 커뮤니티의 유 형, 디지털 커뮤니티의 보안 요건들, 디지털 커뮤니티의 의도된 크기, 디지털 커뮤니티의 목적, 및/또는 기타의 적절한 구성에 따라 더 크거나 더 작을 수 있다는 것을 이해해야 한다. 예를 들어, XNA 객체들의 크기는, 9182 비트 x 9182비트, 1024비트 x 1024비트, 512비트 x 512비트, 1024비트 x 256비트, 또는 기타 임의의 적절한 값 일 수 있다. 또한, 이 예에서 XNA 객체들이 생성되는 최대 엔클레이브 수 k는 4096개 그룹(엔클레이브 또는 생 태계)이다. 값 k는 디지털 커뮤니티와 커뮤니티 소유자의 필요사항에 따라 조정될 수 있다는 것을 이해해야 한 다. 예를 들어, 더 크거나 및/또는 더 복잡한 생태계들은, 수백 또는 수천개의 엔클레이브들을 가질 수 있는 반면, 더 작고/또는 덜 복잡한 생태계들은 10개, 5개, 2개 또는 1개의 엔클레이브만을 가질 수 있다. 도 16 및 도 17의 예시적인 구현들에 관하여 논의될 바와 같이, XNA 모듈은, n x m(예컨대, 4096비트 x 4096비트) 크기의 k(예컨대, k= 4096)개의 고유 XNA 객체들을 생성하기 위해 2진 원시 다항식들(예컨대, 256차) 등의 계산 적 복합 수학적 구조들을 이용할 수 있다. 제공된 예들에서는 n은 m과 동일하지만(예컨대, n=4096이고 m=4096), n이 m과 동일한 것이 요구되는 것은 아니다. 구현들에서, XNA 모듈은 마스터 XNA 객체(아래 예 들에서는 XNA라고 지칭될 수 있음)를 무작위로 생성할 수 있고, 디지털 생태계의 k개의 각각의 그룹들에 대한 마스터 XNA 객체로부터 k개의 상이한 XNA 객체를 생성할 수 있으며(여기서 y번째 XNA 객체는 XNAy라고 지칭됨), 각각의 그룹은 상호 관심 ID를 갖는다. 아래의 도 16은 본 개시내용의 일부 예시적인 구현에 따른 디지털 생태계에 대한 XNA 객체들을 생성하기 위한 예시적인 암호 기반의 방법을 제공한다. XNA 모듈은 본 개시내용의 범위를 벗어나지 않고 다른 적절한 암 호 기반의 방식들로 XNA 객체들을 생성하도록 구성될 수 있다는 것을 이해해야 한다. 1612에서, XNA 모듈은 마스터 XNA 객체를 생성한다. 예시적인 구현들에서, XNA 모듈은 4096비트 x 4096비트 행렬로 구조화된 무작위 2진 정보 데이터 세트를 생성한다. 이들 구현들 중 일부에서, 무작위 2진 정 보 데이터 세트는 마스터 XNA 객체이며, 여기서 마스터 XNA 객체의 각각의 행은 j개의 고정 길이 구역(예컨대, 16개의 256비트 영역) 세트로 조직화되어, XNA의 i 번째 행이 로서 정의될 수 있다. 예를 들어, 마스터 XNA 객체는 i = 1…4096 및 j = 16에 대해 정의될 수 있다. 이 예에서, 마스터 XNA 객체는 4096개의 행 을 포함할 수 있고, 여기서, 각각의 행은, 각각이 256비트 길이인 16개의 구역을 포함한다. 전술된 값들은 단 지 예로서 제공된 것이고, 마스터 XNA 객체는 커뮤니티 소유자에 의해 정의된 다른 적절한 차원들을 가질 수도 있다는 것을 이해해야 한다. 1614에서, XNA 모듈은, 마스터 XNA 객체, XNA를, 변환된 XNA 객체, XNAT로 변환한다. 구현들에서, XNA 모 듈은 j(예컨대, j=16)개의 무작위로 선택된 2진 원시 다항식, 를 이용하여 XNA를 XNAT로 변환한다. 이들 구현들 중 일부에서, 2진 원시 다항식들 각각은 명시된 차수이다(예컨대, 256차 2진 원 시 다항식들). 이들 구현들에서, 각각의 상응하는 행 ti에 의해 표현된 각각의 상응하는 값은 각각의 수정된 값 ti(m)으로 변환된다. 이들 구현들 중 일부에서, XNA의 각각의 행은 다음에 따라 변환될 수 있다 : . 이 예에서, 전술된 변환 기능은, 이 기능이 이산 로그 문제를 해결함으로써 가역적이 될 수 있으므로 암호 기반 이다. 마스터 XNA 객체는 본 개시내용의 범위를 벗어나지 않고 다른 적절한 방식들로 변환될 수 있다는 것을 이해해야 한다. 1616에서, XNA 모듈은 디지털 생태계의 k개의 각각의 그룹에 대해 k개의 XNA 객체를 생성한다. 일부 구현 에서, XNA 모듈은 디지털 커뮤니티 내의 각각의 상응하는 그룹에 대한 각각의 XNA 객체를 생성한다. 이들 구현들 중 일부에서, XNA 모듈은 마스터 XNA 객체 및 변환된 XNA 객체, XNAT에 기초하여 XNA 객체를 도출 한다. 표 5는 마스터 XNA 객체(XNA로 표시됨)와 변환된 마스터 XNA 객체(XNAT로 표시됨)에 기초하여 XNA 객체 를 생성하기 위한 예시적인 프로세스를 정의한다. 이 예에서, XNA 모듈은 다음과 같이 디지털 생태계의 y 번째 그룹(예컨대, Groupy)에 대한 y번째 XNA 객체를 생성할 수 있다: [표 5]"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "한 예시적인 구현에서, XNA 모듈은 256비트 서열 Sy를 선택할 수 있다. 이 예시적인 구성에서, L 값은 256이어서, Sy 값은 0 내지 (2256-1)이다. XNA 모듈의 구성에 따라, Sy는, 비공개 서열, 공개 서열, 또는 무작위로 생성된 서열일 수 있다. 논의된 바와 같이, 새로운 서열 Sy는 각각의 그룹에 대해 무작위로 생성될 수 있다. 이러한 방식으로, 각각의 XNA 객체 XNAy는 상이한 서열을 이용하여 생성된다. 대안으로서, XNA 모듈 은 임의의 적절한 데이터 소스로부터 공개 또는 비공개 서열을 선택하도록 구성될 수 있다. 이들 구현들 에서, XNA 객체 XNAy는 상이한 서열을 이용하여 여전히 생성되며, 이로써 각각의 그룹(예컨대, 엔클레이브)이 상이한 게놈 데이터 객체를 할당받도록 보장한다. 일부 구현에서, 표 5에 제공된 예의 맵핑 단계는 서열 맵핑 모듈에 의해 수행될 수 있고, 이에 의해 XNA 모듈은 서열 맵핑 모듈에 대한 입력으로서 Sy 및 XNAT를 제공하고, 서열 맵핑 모듈은 서열을 XNAT에 맵핑함으로써 결정되는 변환값 TVy를 출력한다. 일부 구현에서, XNA 모듈은 서열을 XNAT에 맵핑함 으로써 변환값을 결정하도록 구성될 수 있다. 표 5의 예에서, XNA 모듈은, 디지털 생태계의 각각의 그룹에 대해 XNA 객체 XNAy를 획득하기 위해 변환값 TVy를 이용하여 마스터 XNA 객체 XNA를 수정하는 암호 기반의 기능을 실행한다. 예시적인 구현들에서, 암호 기 반의 기능은 암호화 기능 또는 명료화 기능일 수 있다. 이들 구현들 중 일부에서, XNA 모듈은, 각각의 XNA 객체를 생성할 때 2진 변환 모듈에 대한 입력으로서 변환값 및 마스터 XNA 객체를 제공함으로써 XNA 객체를 결정하도록 구성된다. 대안으로서, XNA 모듈은 암호 기반의 변환 기능을 실행함으로써 XNA 객체 XNAy를 결정하도록 구성될 수 있다. 일단 생성되고 나면, 선조 VDAX는 XNA 객체 XNAy를 y번째 그룹(예컨대, 엔 클레이브 또는 생태계)에 할당할 수 있고, 이에 의해 XNA 객체는 그룹의 멤버들(예컨대, 엔클레이브 또는 생태 계 내의 코호트들)에게 제공될 수 있다. 도 16의 예는 단지 예로서 제공된다. 예를 들어, 암호 기반의 방식으로 마스터 XNA 객체를 수정하거나, 변환값 TVK를 결정하거나, 서열을 선택하거나, 서열을 변환된 마스터 XNA 객체에 맵핑하거나, 및/또는 마스터 XNA 객체 를 XNA 객체로 변환하기 위해, 광범위한 상이한 구성들(예컨대, 실행가능한 계산 방법들)이 개발될 수 있다는 것을 이해해야 한다. 구현들에서, XNA 모듈은 하이브리드 구성으로 구성될 수 있다. 이들 구현들에서, XNA 모듈은 실행될 때 XNA 객체들을 생성하는 암호 기반의 기능과 암호없는 기능의 조합을 포함한다. 예시적인 구현들에서, XNA 모듈은 크기 4096비트 x 4096비트의 XNA 객체들을 생성하도록 구성된다. 예시적인 구성에서, XNA 모듈 은 최대 k(예컨대, k = 4096)개의 상이한 그룹에 대한 XNA 객체들을 생성하며, 각각의 그룹은 암호 기반의 기능 및 암호없는 기능의 조합을 이용하여 마스터 XNA 객체(표 2의 GDX)로부터의 상호 관심 ID를 갖는다. 일부 예시적인 구현에서, 암호없는 기능(들)은, 하나 이상의 보안 수정 파라미터(SMP)를 이용하여 파라미터화될 수있는, 파라미터화가능한 암호없는 동작 세트를 포함할 수 있다. 예시적인 구현들에서, 암호없는 동작들은 XOR 와 순환 시프트 동작의 조합일 수 있고, 여기서 XNA 모듈은 보안 수정 파라미터들을 무작위로 생성하여 XOR와 순환 시프트 동작들의 조합을 파라미터화하며, 그 예들이 아래에서 설명된다. 아래의 도 17은, 본 개시내용의 일부 예시적인 구현에 따른 디지털 생태계에 대한 객체들을 생성하기 위한 예시 적인 하이브리드 프로세스(예컨대, 적어도 하나의 암호 기반의 동작 및 적어도 하나의 암호 없는 동작)을 제공 한다. XNA 모듈은 본 개시내용의 범위를 벗어나지 않고 다른 적절한 하이브리드 방식들로 XNA 객체들을 생성하도록 구성될 수 있다는 것을 이해해야 한다. 1712에서, XNA 모듈은 마스터 XNA 객체를 생성한다. 예시적인 구현들에서, XNA 모듈은 n x m 행렬 (예컨대, 4096비트 x 4096비트 행렬)로 구조화된 무작위 2진 정보 데이터 세트를 생성한다. 이들 구현들 중 일 부에서, 무작위 2진 정보 데이터 세트는 마스터 XNA 객체이고, 여기서 마스터 XNA 객체의 각각의 행은 한 세트 의 n개 행들 [R1, R2,…Rn]로 구성된다. 이 예에서, Ri는 무작위로 생성된 마스터 XNA 객체의 i번째 행일 수 있 고, [Ri,1, Ri,2,…Ri,m]으로서 정의될 수 있다, 여기서 Ri,j는 i번째 행의 j번째 열의 개개의 비트 값이다. 이 예 에서, 마스터 XNA 객체는 4096개의 행을 포함할 수 있고, 여기서, 각각의 행은, 각각이 256비트 길이인 16개의 구역을 포함한다. 전술된 값들은 단지 예로서 제공된 것이고, 다른 적절한 값들이 XNA 모듈을 구성하는데 이용될 수 있다는 점에 유의한다. 1714에서, XNA 모듈은 변환 기능(예컨대, 암호없는 또는 암호 기반의 변환 기능)를 이용하여 마스터 XNA 객체 XNA를 변환된 XNA 객체 XNAT로 변환한다. 일부 구현에서, XNA 모듈은 보안 수정 파라미터(SMP) 세트 를 수신하는 암호없는 기능을 이용하여 XNA를 XNAT로 변환한다. 일부 구현에서, SMP는 마스터 XNA 객체에 적용 되는 파라미터화가능한 동작 세트를 파라미터화하는데 이용되는 파라미터 세트를 정의할 수 있다. 파라미터화 가능한 동작들의 예들로는, 순환 비트 시프트 동작들, XOR 동작들 등이 포함될 수 있다. 이들 예들에서, SMP는, 마스터 XNA 객체의 각각의 행에 대해, 순환적으로 시프트할 각각의 비트 수를 정의할 수 있다. 추가적 으로 또는 대안으로서, SMP는 특정한 행을 XOR하는데 이용되는 값을 정의할 수 있다. 예를 들어, SMPi는, i번 째 행에 대한 보안 수정 파라미터들을 정의할 수 있고, i번째 행을 (예컨대, 우측으로) 순환적으로 시프트하기 위한 비트 위치들의 수를 나타내는 제1 파라미터와, i번째 행과 XOR되는 무작위 값을 정의하는 제2 파라미터를 포함할 수 있다. 제2 파라미터는 0 내지 (2m-1)의 값일 수 있고, 여기서 m은 XNA 객체에서의 열의 개수임을 이 해해야 한다. 이들 구현들에서, XNA 모듈은, XNA 객체의 각각의 행을, 그 행에 대응하는 각각의 SMP들로 파라미터화되는 파라미터화가능한 동작 세트를 이용하여 변환하여 변환된 마스터 XNA 객체 XNAT를 획득할 수 있 다. 마스터 XNA 객체는 본 개시내용의 범위를 벗어나지 않고 다른 암호 없는 방식들 또는 암호 기반의 방식들 (예컨대, 도 16의 단계 1614)로 변환될 수 있다는 것을 이해해야 한다. 1716에서, XNA 모듈은 디지털 생태계의 k개의 각각의 그룹에 대해 k개의 XNA 객체를 생성한다. 일부 구현 에서, XNA 모듈은 디지털 커뮤니티 내의 각각의 상응하는 그룹에 대한 각각의 XNA 객체를 생성한다. 이들 구현들 중 일부에서, XNA 모듈은 마스터 XNA 객체 및 변환된 XNA 객체, XNAT에 기초하여 XNA 객체를 도출 한다. 표 6은 마스터 XNA 객체(XNA로 표시됨)와 변환된 마스터 XNA 객체(XNAT로 표시됨)에 기초하여 XNA 객체 를 생성하기 위한 예시적인 프로세스를 정의한다. 이 예에서, XNA 모듈은 다음과 같이 디지털 생태계의 y 번째 그룹(예컨대, Groupy)에 대한 y번째 XNA 객체를 생성할 수 있다: [표 6]"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "한 예시적인 구현에서, XNA 모듈은 256비트 서열 Sy를 선택할 수 있다. 이 예시적인 구성에서, L 값은 256이어서, Sy 값은 0 내지 (2256-1)이다. XNA 모듈의 구성에 따라, Sy는, 비공개 서열, 공개 서열, 또는무작위로 생성된 서열일 수 있다. 논의된 바와 같이, 새로운 서열 Sy는 각각의 그룹에 대해 무작위로 생성될 수 있다. 이러한 방식으로, 각각의 XNA 객체 XNAy는 상이한 서열을 이용하여 생성된다. 대안으로서, XNA 모듈 은 임의의 적절한 데이터 소스로부터 공개 또는 비공개 서열을 선택하도록 구성될 수 있다. 이들 구현들 에서, XNA 객체 XNAy는 상이한 서열을 이용하여 여전히 생성되며, 이로써 각각의 그룹(예컨대, 엔클레이브)이 상이한 게놈 데이터 객체를 할당받도록 보장한다. 일부 구현에서, 표 6에 제공된 예의 맵핑 단계는, 암호 기반, 암호 없는, 또는 하이브리드 서열 맵핑 기능일 수 있다(그 예들은 아래에서 더 상세히 설명된다). 이들 구현들 중 일부에서, 암호 기반의 서열 맵핑 기능은 서열 맵핑 모듈에 의해 수행될 수 있다. 이들 예시적인 구현들에서, XNA 모듈은 Sy 및 XNAT를 서열 맵핑 모듈에 입력으로서 제공함으로써 변환값을 결정하고, 서열 맵핑 모듈은 변환값 TVy를 획득하기 위해 서열을 XNAT에 맵핑한다. 일부 구현에서, XNA 모듈은 변환값을 결정하기 위해 서열 맵핑 기능을 수행하도 록 구성될 수 있다. 일부 구현에서, XNA 모듈은, 디지털 생태계의 각각의 그룹(Groupy)에 대해, XNA 객체 XNAy를 획득하기 위 해, 변환값 TVy를 이용하여 마스터 XNA 객체 XNA를 수정하는 암호없는 변환 기능을 이용할 수 있다. 예시적인 구현들에서, 암호없는 기능은, 변환값과 함께 키잉되는 해시 기능(예컨대, 역상 저항성 해시 기능 또는 임의의 다른 적절한 해시 기능), 변환값을 이용하여 파라미터화되는 파라미터화가능한 동작 세트 등을 포함할 수 있다. 도 17의 예는 단지 예로서 제공된다. 예를 들어, 변환된 마스터 XNA 객체를 획득하기 위해 마스터 XNA 객체를 수정하거나, 서열을 선택하거나, 변환값 TVk를 결정하거나, 및/또는 마스터 XNA 객체를 XNA 객체로 변환하기 위 해, 광범위한 상이한 구성들(예컨대, 실행가능한 계산 방법들)이 개발될 수 있다는 것을 이해해야 한다. 게다 가, 일부 구현에서, 도 17의 예시적인 프로세스의 암호 기반의 동작들은 암호없는 동작으로 대체되어, XNA 모듈 이 암호없는 방식으로 구성될 수 있게 할 수 있다. 도 16 및 도 17의 예들에서, XNA 모듈은 결과적인 XNA 객체 XNA를 디지털 커뮤니티의 각각의 엔클레이브 VDAX에 할당할 수 있다. 엔클레이브 VDAX는 그 XNA 객체 XNAY를 엔클레이브의 멤버들(예컨대, 코호트들의 코호 트 VDAX들)에 할당할 수 있다. 구현들에서, 각각의 코호트 VDAX의 링크 모듈은, 각각의 코호트 VDAX가 대 응하는 엔클레이브에서 코호트의 또 다른 코호트 VDAX에 대한 링크를 스폰하거나 그로부터의 링크를 디코딩할 때마다 그 할당된 XNA 객체를 수정할 수 있다. 이러한 방식으로, XNA 객체는 대응하는 엔클레이브 및/또는 생 태계의 멤버들 사이의 초확장성 상관을 용이화하기 위한 메커니즘을 제공한다. 도 16 및 도 17에 제공된 예들 은 XNA 모듈의 예시적인 구성들이고, 커뮤니티 멤버들에 대한 XNA 객체들을 생성하기 위한 다른 수단이 나 중에 개발될 수 있다는 것을 이해해야 한다. 또한, 도 16 및 도 17의 예들은 생태계의 각각의 그룹들에 할당된 XNA 객체들을 생성하는 프로세스들을 도시한 다. 논의된 바와 같이, 생태계 VDAX 및/또는 엔클레이브 VDAX는, 마스터 XNA 객체 및/또는 하나 이상의 엔클레 이브의 하나 이상의 XNA 객체를 수정하도록 구성될 수 있다. 예를 들어, 생태계 VDAX는 엔클레이브의 게놈 토 폴로지를 변경하기 위해(예컨대, 엔클레이브로부터 하나 이상의 코호트를 제거하거나, 보안 상의 이유로 XNA 객 체를 주기적으로 변경하기 위해, 또는 기타 등등을 위해) 엔클레이브의 XNA 객체를 수정할 수 있다. 일부 구현 에서, 생태계 VDAX 또는 엔클레이브 VDAX는, 표 5 또는 표 6에 제시된 예시적인 프로세스를 이용하여 이러한 목 적으로 XNA 객체를 수정할 수 있다. 예를 들어, 특정한 엔클레이브의 현재의 XNA 객체를 수정함에 있어서, 생 태계 VDAX 또는 엔클레이브를 나타내는 엔클레이브 VDAX는 현재의 XNA 객체를 변환하여 변환된 XNA 객체를 획득 하고, L비트 서열을 선택하고, 이 서열을 변환된 XNA 객체에 맵핑하여 변환값을 획득하고, 변환값을 이용하여 현재의 XNA 객체를 수정하여 특정한 엔클레이브에 대한 새로운 XNA 객체를 획득할 수 있다. 그 다음, 이 새로 운 XNA 객체는 엔클레이브에 남아 있는 코호트들에게 제공될 수 있다. 이러한 방식으로, 새로운 XNA 객체가 제 공되지 않은 엔클레이브 내의 임의의 코호트들은, 더 이상, 엔클레이브에 남아 있는 코호트들에 대한 VBLS를 생 성하거나 그로부터 VBLS를 해독할 수 없을 것이. 게놈 분화 객체들의 수정은 본 개시내용의 범위를 벗어나지 않고 나중에 개발된 프로세스들을 이용하여 수행될 수 있다는 것을 이해해야 한다. ZNA 생성 본 개시내용의 일부 구현에서, CG-ESP는 디지털 생태계의 멤버들에게 할당되는 ZNA 객체들을 생성하도록 구성된 EIC 모듈을 포함할 수 있다. 이들 구현들에서, 디지털 생태계는 VTEE(Virtual Trusted ExecutionEnvironment)일 수 있으며, 여기서 각각의 ZNA 객체는 각각의 컴퓨터 프로그램(예컨대, 운영 체제, 소프트웨어 애플리케이션, 펌웨어 애플리케이션, 미들웨어 애플리케이션 등) 또는 컴퓨터 프로그램 그룹(예컨대, 소프트웨 어 수트)에 할당될 수 있다. 대안으로서, EIC 모듈은, 단일 ZNA 객체(예컨대, 마스터 ZNA 객체)를 생성하 도록 구성될 수 있고, 이에 의해 각각의 상응하는 컴퓨터 프로그램은 EIC 모듈이 컴포넌트 2진 격리를 용 이화할 때 이용하는 연관된 대응하는 GRI를 갖는다. 논의된 바와 같이, EIC 모듈의 구성은, 암호 기반, 암호없는, 또는 하이브리드 방식으로 구성될 수 있다. 일부 구현에서, 도 13의 프로세스는 VTEE의 멤버들에 대한 ZNA 객체들을 생성하기 위해 EIC 모듈에서 구현 될 수 있다. 도 18은 ZNA 객체들을 생성하기 위한 프로세스의 예시적인 구현을 제공한다. 이들 예시적인 구현 들에서, EIC 모듈은 마스터 ZNA 객체를 생성하도록 구성된다. 이들 구현들 중 일부에서, EIC 모듈은 마스터 ZNA 객체를 VTEE의 각각의 멤버에 할당한다. 다른 구현들에서, EIC 모듈은 또한, k개의 ZNA 객체 세트를 도출하도록 구성되며, 여기서, EIC 모듈은 각각의 상응하는 ZNA 객체들을 각각의 커뮤니티 멤버 또 는 커뮤니티 멤버들의 각각의 그룹에 할당할 수 있다. 아래에서 더 상세히 논의되는 바와 같이, ZNA는 컴퓨터 프로그램의 실행가능한 명령어들 및/또는 컴퓨터 프로그램에 입력되거나 및/또는 컴퓨터 프로그램에 의해 출력 되는 데이터를 인코딩 및 디코딩할 때 이용될 수 있다. 따라서, VBLS-인코딩된 명령어들은 메모리에 저장되고 런타임시에 디코딩될 수 있음으로써, 악성 코드 또는 기타의 유사한 공격의 위험을 크게 감소시킨다. 이해할 수 있는 바와 같이, 이러한 생태계들은 악의적인 당사자가 명령어들 및/또는 프로그램 데이터를 가로챌 가능성 이 적기 때문에 다른 생태계들과는 상이하다. 일부 예시적인 구성에서, EIC 모듈은 고정 크기 2진 행렬들(예컨대, n x m 행렬들)로 구조화된 ZNA 객체들 을 생성하도록 구성된다. 2진 행렬들은 2원 벡터들로서 표현될 수 있다는 것을 이해해야 한다. 본 개시내용으 로부터 알 수 있는 바와 같이, CG-ESP의 구성가능한 속성들은 커뮤니티 소유자(예컨대, 크기, 구조, 보안 레벨 들, 의도된 용도, 및/또는 멤버십 요건들을 정의하는 엔티티)가 ZNA 객체들의 최대 수(K), ZNA 객체의 차원들 (예컨대, n x m), ZNA 객체 구역들의 크기, 및/또는 기타의 적합한 파라미터들로 EIC 모듈을 파라미터화하 는 것을 허용한다. 더욱이, 본 개시내용 전체에 걸쳐 논의되는 바와 같이, 커뮤니티 소유자는 ZNA 객체 생성 프로세스에서 이용되는 계산 기능들의 유형들을 정의할 수 있다. 예를 들어, 커뮤니티 소유자는 특정한 암호 기반의 기능(예컨대, 상이한 암호화 기능들, 명료화 기능들, 및/또는 기타 등등) 및/또는 암호 없는 기능들을 이용할 수 있다. 아래의 도 18은 본 개시내용의 일부 예시적인 구현에 따른 디지털 생태계에 대한 ZNA 객체들을 생성하기 위한 예시적인 암호 기반의 방법을 제공한다. EIC 모듈은 본 개시내용의 범위를 벗어나지 않고 다른 적절한 암 호 기반의 방식들로 ZNA 객체들을 생성하도록 구성될 수 있다는 것을 이해해야 한다. 도 18의 예시적인 구현들 에서, 예시적인 ZNA 객체는 1024비트 x 1024비트 행렬들이다. ZNA 객체들은, VTEE의 목적, VTEE의 보안 요건, 디지털 커뮤니티의 의도된 크기, 및/또는 기타 적절한 구성에 따라 더 크거나 더 작을 수 있다는 것을 이해해야 한다. 1810에서, EIC 모듈은 마스터 ZNA 객체를 생성한다. 예시적인 구현들에서, EIC 모듈은 1024비트 x 1024비트 행렬로 구조화된 무작위 2진 정보 데이터 세트를 생성한다. 이들 구현들 중 일부에서, 무작위 2진 정 보 데이터 세트는 마스터 ZNA 객체이며, 여기서 마스터 ZNA 객체의 각각의 행은 j개의 고정 길이 구역(예컨대, 4개의 256비트 영역) 세트로 조직화되어, ZNA의 i 번째 행이 로서 정의될 수 있다. 예를 들어, 마스터 ZNA 객체는 i = 1…1024 및 j = 14에 대해 정의될 수 있다. 이 예에서, 마스터 ZNA 객체는 1024개의 행 을 포함할 수 있고, 여기서, 각각의 행은, 각각이 256비트 길이인 4개의 구역을 포함한다. 전술된 값들은 단지 예로서 제공된 것이고, 마스터 ZNA 객체는 커뮤니티 소유자에 의해 정의된 다른 적절한 차원들을 가질 수도 있 다는 것을 이해해야 한다. 일부 구현에서, EIC 모듈은 VTEE의 각각의 커뮤니티 멤버(예컨대, 컴퓨터 프로 그램)에 대한 마스터 ZNA 객체를 이용할 수 있고 각각의 커뮤니티 멤버에게 고유한 GRI를 할당할 수 있다. 그 러나, 다른 구현들에서, EIC 모듈은 마스터 ZNA 객체를 변환하고 할당할 수 있다. 1814에서, EIC 모듈은 마스터 ZNA 객체 ZNA를 변환된 ZNA 객체인 ZNAT로 변환한다. 구현들에서, EIC 모듈 은 j(예컨대, j=4)개의 무작위로 선택된 2진 원시 다항식, 를 이용하여 ZNA를 ZNAT 로 변환한다. 이들 구현들 중 일부에서, 2진 원시 다항식들 각각은 명시된 차수이다(예컨대, 256차 2진 원시 다항식들). 이들 구현들에서, 각각의 상응하는 행 ti에 의해 표현된 각각의 상응하는 값은 각각의 수정된 값ti(m)으로 변환된다. 이들 구현들 중 일부에서, ZNA의 각각의 행은 다음에 따라 변환될 수 있다 : . 이 예에서, 전술된 변환 기능은, 이 기능이 이산 로그 문제를 해결함으로써 가역적이 될 수 있으므로 암호 기반 이다. 마스터 ZNA 객체는 본 개시내용의 범위를 벗어나지 않고 다른 적절한 방식들로 변환될 수 있다는 것을 이해해야 한다. 1816에서, EIC 모듈은 VTEE의 k개의 각각의 커뮤니티 멤버들(예컨대, 컴퓨터 프로그램)에 대해 k개의 ZNA 객체를 생성한다. 일부 구현에서, EIC 모듈은 디지털 커뮤니티 내의 각각의 개별 멤버에 대한 각각의 ZNA 객체를 생성한다. 이들 구현들 중 일부에서, EIC 모듈은 마스터 ZNA 객체 및 변환된 ZNA 객체 ZNAT에 기 초하여 ZNA 객체를 도출한다. 표 7은 마스터 ZNA 객체(ZNA로 표시됨)와 변환된 마스터 ZNA 객체(ZNAT로 표시 됨)에 기초하여 ZNA 객체를 생성하기 위한 예시적인 프로세스를 정의한다. 이 예에서, EIC 모듈은 다음과 같이 디지털 생태계의 y번째 커뮤니티 멤버에 대한 y번째 ZNA 객체를 생성할 수 있다: [표 7]"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "한 예시적인 구현에서, EIC 모듈은 256비트 서열 Sy를 선택할 수 있다. 이 예시적인 구성에서, L 값은 256이어서, Sy 값은 0 내지 (2256-1)이다. EIC 모듈의 구성에 따라, Sy는, 비공개 서열, 공개 서열, 또는 무작위로 생성된 서열일 수 있다. 논의된 바와 같이, 새로운 서열 Sy가 각각의 커뮤니티 멤버에 대해 선택되거 나 무작위로 생성될 수 있다. 이러한 방식으로, 각각의 ZNA 객체 ZNAy는 상이한 서열을 이용하여 생성된다. 일부 구현에서, 표 5에 제공된 예의 맵핑 단계는 서열 맵핑 모듈에 의해 수행될 수 있고, 이에 의해 EIC 모듈은 서열 맵핑 모듈에 대한 입력으로서 Sy 및 ZNAT를 제공하고, 서열 맵핑 모듈은 서열을 ZNAT에 맵핑함으로써 결정되는 변환값 TVy를 출력한다. 일부 구현에서, EIC 모듈은 서열을 ZNAT에 맵핑함 으로써 변환값을 결정하도록 구성될 수 있다. 표 7의 예에서, EIC 모듈은, 변환값 TVy를 이용하여 마스터 ZNA 객체 ZNA를 수정하는 변환 기능을 실행하 여 ZNA 객체 ZNAy를 획득할 수 있다. 변환 기능은, 암호 기반, 암호 없는, 또는 하이브리드일 수 있다. 암호 기반, 암호 없는, 및 하이브리드 변환 기능의 예들은 본 개시내용 전체에 걸쳐 논의된다. 일단 생성되고 나면, EIC 모듈은 ZNA 객체 ZNAy를 y번째 커뮤니티 멤버(예컨대, 컴퓨터 프로그램)에 할당할 수 있고, 이에 의해 ZNA 객체는 메모리에 저장되고 컴퓨터 프로그램이 실행되고 있을 때 EIC 모듈에 의해 리트리브될 수 있다. 도 18의 예는 단지 예로서 제공된다. 예를 들어, 마스터 ZNA 객체를 수정하거나, 변환값 TVK를 결정하거나, 서 열을 선택하거나, 서열을 변환된 마스터 ZNA 객체에 맵핑하거나, 및/또는 마스터 ZNA 객체를 ZNA 객체로 변환하 기 위해, 광범위한 상이한 구성들(예컨대, 실행가능한 계산 방법들)이 개발될 수 있다는 것을 이해해야 한다. 일부 구현에서, EIC 모듈은 때때로(예컨대, 보안을 유지하기 위해, 보안 침해를 해결하기 위해) ZNA 객체 를 수정할 수 있다. 이러한 시나리오들에서, EIC 모듈은 ZNA 객체를 수정하기 위해 표 7에 설명된 예시적 인 프로세스를 적용할 수 있다. 예를 들어, 현재의 ZNA 객체를 수정함에 있어서, EIC 모듈은 현재의 ZNA 객체를 변환하여 변환된 ZNA 객체를 획득하고, L-비트 서열을 선택하고, 서열을 변환된 ZNA 객체에 맵핑하여 변 환값을 획득하고, 변환값을 이용하여 현재의 ZNA 객체를 수정하여 새로운 ZNA 객체를 획득할 수 있다. 게놈 분 화 객체들의 수정은 본 개시내용의 범위를 벗어나지 않고 나중에 개발된 프로세스들을 이용하여 수행될 수 있다 는 것을 이해해야 한다. 게놈 적격성 객체 생성 및 할당 구현들에서, 루트 DNA 모듈은 게놈 적격성 객체들을 생성하도록 구성된다. 논의된 바와 같이, 게놈 적격 성 객체는 CNA 객체들 및/또는 PNA 객체들을 포함한다. 일부 구현에서, CNA 객체들은 링크 교환 동안 결합-무 결성을 확정하기 위해 생태계 멤버들에 의해 이용될 수 있다. 일부 구현에서, PNA 객체들은 링크 교환 동안 결 합-동기화를 확정하기 위해 생태계 멤버들에 의해 이용될 수 있다. CNA 생성 및 할당 CG-ESP의 일부 구현에서, 선조 VDAX의 루트 DNA 모듈은 CNA 객체들을 생성하는 CNA 모듈을 포함한다. 이들 구현들 중 일부에서, 선조 VDAX(예컨대, 생태계 VDAX)의 CNA 모듈은 마스터 CNA 객체를 생성하고 마 스터 CNA 객체의 각각의 고유 서브세트를 디지털 커뮤니티(예컨대, 엔클레이브들, 코호트들 등)의 각각의 상응 하는 멤버에게 할당한다. 이러한 방식으로, 생태계 멤버들의 각각의 상응하는 쌍은 마스터 CNA 객체의 공유된 부분들에 기초하여 고유한 관계를 형성할 수 있다. 일부 구현에서, 이 고유한 상관관계는 링크 교환 동안 서로 의 결합 무결성을 확정하는데 이용될 수 있다. 도 19는, 마스터 CNA 객체를 생성하고 CNA 객체들을 생태계 커뮤니티 멤버들에게 할당하기 위한 CNA 모듈 의 한 예시적인 구성을 나타낸다. 도 19의 예시적인 프로세스는 마스터 CNA 객체를 생성하기 위한 예시적인 프 로세스로서 제공된다는 점에 유의한다. 추가적인 CNA 생성 및 할당 프로세스들은 나중에 개발될 수 있고 생태 계에 대한 CNA를 생성하는데 이용될 수 있다. 1910에서, CNA 모듈은 마스터 CNA 모듈을 무작위로 생성한다. 이들 구현들 중 일부에서, CNA 모듈은 특정한 크기 U를 갖는 무작위 2진 정보 데이터 세트 CNAR을 생성한다. U의 크기는, 디지털 커뮤니티의 예상 크 기, 시스템의 아키텍쳐, 예상되는 사용자들의 유형들(예컨대, 가족 멤버들, 직원들, 일반 대중 등), 및/또는 기 타 임의의 요인 등의, 다수의 요인에 기초하여 선택될 수 있다. 예를 들어, U는, 224 비트(~2MB), 223(~1MB), 222(~500kB), 또는 기타 임의의 적절한 크기일 수 있다. CNA 모듈은 무작위 2진 정보 데이터 세트 CNAR을 마스터 CNA 객체로 구조화한다. 이들 구현들 중 일부에서, CNA 모듈은 마스터 CNA 객체를 획득하기 위해 CNAR 객체로부터 크기 V의 고유 2원 벡터 세그먼트들 Sj를 선택하고 열거함으로써 CNAR을 재조직화할 수 있다. 예를 들어, 구현들에서, CNA 모듈은, CNAR을, 에 대해 각각 크기가 V(예컨대, V = 8비트, 16비트, 1028비트, 4096비트 등)인 비중첩 2원 벡터 세그먼트 세트 Sj로 분할하되, 각각의 세그먼트 Sj는 마스터 CNA 객체의 각각의 j번째 부분을 정의하고, 여기서, 는 정수이다. 이들 구현들에서, CNA의 각각의 상응하는 부분은 0부터 까지의 대응하는 값으로 인덱싱되되, 값 \"0\"은 마스터 CNA 객체의 첫 번째 부분을 참조하고, 값 \"1\"은 마스터 CNA 객체의 두 번째 부분을 참조하고, ..., 값 은 마스터 CNA 객체의 번 째 부분을 참조한다. 아래에서 논의되는 바와 같이, 구현들에서, 각각의 커뮤니티 멤버들의 CNA 객체들은, 부 분적으로, 길이 의 고유 코드워드 벡터(\"코드워드\"라고도 함)를 결정하고 할당하되, 코드워드 벡터의 1들의 비트 위치들이 각각의 커뮤니티 멤버에 의해 상속된 마스터 CNA 객체의 각각의 부분들에 대응하게 함으로써, 마 스터 CNA 객체로부터 도출될 수 있다. 예를 들어, 커뮤니티 멤버 코드워드 벡터가 [1001…01]인 경우, 커뮤니 티 멤버의 CNA 객체는 마스터 CNA 객체의 첫 번째 부분, 네 번째 부분, … 및 번째 부분을 포함한다. 1912에서, CNA 모듈은 마스터 CNA 객체에 기초하여 CNA 객체들을 하나 이상의 디지털 커뮤니티 멤버에게 할당한다. 일부 구현에서, CNA 모듈은, 마스터 CNA 객체의 부분들의 고유한 서브세트를 각각의 상응하는 디지털 커뮤니티 멤버에게 할당하되, 어떠한 2개의 디지털 커뮤니티 멤버의 CNA 객체들도 마스터 CNA 객체 부분 들의 동일한 서브세트를 할당받지 않게 하도록 구성된다. 구현들에서, CNA 모듈은 각각의 커뮤니티 멤버들(예컨대, 엔클레이브들, 코호트들 등)에 대한 고유 코드워 드 벡터를 생성하기 위해 코드 맵핑을 적용하는 코드 맵핑 기능을 실행할 수 있다. 구현들에서, 코드 맵핑은 Z 개의 값들을 Z개의 기본 2원 벡터 세트에 각각 연관시키는 기본 2진 비트 벡터 인덱스를 포함한다(예컨대, Z개의 기본 2원 벡터는 0부터 Z-1까지 열거된다(예컨대, )). 일부 구현에서, Z의 값은 마스터 CNA 객체의 부분들의 개수(즉, )가 Z의 배수가 되도록(즉, ) 선택될 수 있다. 이들 구현들 중 일부에서, 기본 2원 벡터들은, 기본 2원 벡터 세트로부터의 임의의 기본 2원 벡터 쌍(예컨대, 0 < i, j < Z에 대해, Ci 및 Cj)이 고유한 어드레싱가능한 상관관계를 갖도록 선택될 수 있다. 고유한 어드레싱가능한 상관관계 란, 임의의 벡터 쌍(즉, (Ci AND Cj))의 교차점이 고유한 벡터일 때 2원 벡터 세트의 속성을 지칭할 수 있다. 구현들에서, 기본 2진 비트 벡터 인덱스는 각각의 상응하는 기본 2원 벡터 Ci를 0 내지 Z-1의 대응하는 값과 연 관시킨다. 예를 들어, Z=4일 때, 기본 2원 벡터 인덱스는([00], [01], [10], 및 [11])로 구성되고, 예시적인 코드 맵핑은 {[00]-> C0, [01]-> C1, [10]-> C2, 및 [11]-> C3}로서 정의될 수 있되, 코드 맵핑은 임의의 주어진 2비트 값을 4개의 기본 2원 벡터 중 대응하는 기본 2원 벡터에 맵핑되도록 한다. CNA 할당 프로세스들과 관련 하여 논의되는 바와 같이, 코딩 기능은 디지털 커뮤니티의 각각의 멤버들에 대응하는 고유 코드워드들을 생성하 는데 이용될 수 있고, 이에 의해, 디지털 커뮤니티 멤버에 대응하는 각각의 코드워드는 디지털 커뮤니티 멤버의 CNA 객체에 할당되는 마스터 CNA 객체의 부분들에 대한 인덱스를 제공한다. 도 20은 본 개시내용의 일부 구현에 따른 커뮤니티 멤버에 대한 CNA 객체를 할당하기 위한 예시적인 프로세스를 나타낸다. 도 20의 프로세스는 선조 VDAX의 CNA 모듈에 의해 수행되는 것으로 설명된다. CNA 모듈 은 본 개시내용의 범위를 벗어나지 않고 대안적인 CNA 생성 프로세스들을 실행하도록 구성될 수 있다는 것을 이 해해야 한다. 또한, 도 20의 프로세스는 단일 커뮤니티 멤버에 관하여 설명된다. CNA 모듈은 사실상 무 제한의 커뮤니티 멤버들에 대한 CNA 객체들을 생성하도록 구성될 수 있다는 것을 이해해야 한다. 2010에서, CNA 모듈은 생태계 커뮤니티 멤버에 대한 고유 코드워드를 결정한다. 위에서 언급된 바와 같이, 생태계 커뮤니티 멤버의 코드워드는 디지털 커뮤니티 멤버의 CNA 객체에 할당되는 마스터 CNA 객체의 부 분들에 대한 인덱스로서 이용될 수 있다. 일부 구현에서, 코드워드는 크기 (즉, 마스터 CNA 객체의 V 크기 부분들의 수)의 2원 벡터로서 구조화될 수 있다. 이들 구현들 중 일부에서, 코드워드의 각각의 상응하는 비트 는, 마스터 CNA 객체의 대응하는 부분이 코드워드에 대응하는 커뮤니티 멤버에 할당되는지(예컨대, \"1\"은 특정 한 부분이 커뮤니티 멤버에 할당됨을 나타냄)를 나타낸다. 구현들에서, CNA 모듈은 하나 이상의 충돌 내성 프로세스(예컨대, 충돌 내성 해시 기능)를 이용하여 특정 한 생태계 멤버의 코드워드 CW를 결정한다. 이들 구현들 중 일부에서, CNA 모듈은 인간이 판독할 수 있거 나 판독할 수 없는 특정한 생태계 멤버(예컨대, 생태계 멤버의 자격증)에 고유한 획득 가능한 데이터 세트를 수 신 및/또는 할당한다. 획득가능한 데이터 세트란, 생태계 내의 다른 생태계 멤버 VDAX들(예컨대, 코호트 VDAX 들, 엔클레이브 VDAX들, 생태계 VDAX들)이 액세스할 수 있거나 링크 교환 프로세스 동안에 획득할 수 있는 임의 의 디지털 정보를 지칭할 수 있다. 예를 들어, 인간 사용자와 연관된 디바이스(예컨대, 개인 컴퓨팅 디바이스, 모바일 디바이스, 착용형 디바이스, 및/또는 기타 등등)의 코호트 VDAX에 대응하는 고유한 획득가능한 데이터 세트는 인간 사용자 고유의 정보일 수 있다(예컨대, 인간 사용자의 이름, 이메일 주소, 및/또는 전화번호의 조 합), 여기서 데이터 세트에 포함된 정보는 정의된 포맷에 따라 구조화된다. 또 다른 예에서, 단일 사용자와 연 관되거나 연관되지 않을 수 있는 디바이스(예컨대, 서버, 프린터, IoT 센서, 스마트 기기, 및/또는 기타 등등) 또는 디바이스들의 시스템(예컨대, 클라우드 컴퓨팅 시스템)의 코호트 VDAX에 대응하는 획득가능한 데이터 세트 는 디바이스 또는 디바이스들의 시스템 고유의 정보를 포함할 수 있다(예컨대, 디바이스들 또는 디바이스 세트 내의 하나 이상의 디바이스의 MAC 주소, 디바이스 또는 디바이스 세트 내의 하나 이상의 디바이스의 디바이스 이름, 및/또는 기타 등등의 조합). 구현들에 있어서, 획득가능한 고유 정보는 디지털 생태계와의 제휴에 관계 없이 임의의 디바이스에게 공개적으로 이용가능하거나, 제한된 수의 엔티티에 의해(예컨대, 디지털 생태계의 멤 버들에 의해서만) 획득될 수 있다. 일부 구현에서, 생태계 멤버들의 획득가능한 데이터 세트들은 데이터 구조 (예컨대, 연관 테이블, 데이터베이스, 인덱스 등)에서 인덱싱되는 \"자격증들\"로 조직화되되, 임의의 생태계 멤 버의 고유 정보를 포함하는 자격증들이 데이터 구조를 저장하고 있는 디바이스나 시스템에 질의함으로써 생태계 의 VDAX에 의해 획득될 수 있다. 생태계 멤버의 고유한 획득가능한 데이터 세트는 임의의 다른 적절한 방식으 로 결정될 수 있다는 것을 이해해야 한다. 구현들에서, CNA 모듈은 자격증들을 수신하고 이에 대응하는 맵핑되지 않은 코드워드인 CWA를 출력하는 인 코딩 기능에 생태계 멤버의 자격증들을 입력한다. 이들 예시적인 구현들에서, 맵핑되지 않은 코드워드는 고정크기 P의 2원 벡터 CWA이고, 여기서:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "예를 들어 U/V = 4096이고 Z=4인 경우, 인코딩 기능은 2048비트 길이의 맵핑되지 않은 코드워드들을 출력하도록 구성된다; 반면 U/V= 4096이고 Z = 16인 경우, 인코딩 기능은 1024비트 길이의 맵핑되지 않은 코드워드들을 출 력한다. 일부 구현에서, 인코딩 기능은 커뮤니티 멤버의 자격증들을 수신하고 자격증들에 해시 기능(예컨대, 충돌 내성 기능, 역상 저항성 기능, 제2 역상 저항성 기능 등)를 적용하여 \"맵핑되지 않은 코드워드\"라고 지칭 될 수 있는 P-비트 벡터를 획득할 수 있다. 구현들에서, CNA 모듈은 맵핑되지 않은 코드워드 CWA를 코드 맵핑 기능(예컨대, 도 19의 설명에서 제공된 예시적인 코드 맵핑 기능)에 입력하고, 코드 맵핑 기능은 디지털 커뮤니티 멤버에 대응하는 코드워드를 출력한 다. 일부 구현에서, 코드 맵핑 기능은 2원 벡터 CWSA를 초기화한다. 이들 구현들에서, 코드 맵핑 기능은 맵핑 되지 않은 코드워드 CWA를 기본 2원 벡터들 Ci에 대한 인덱스들의 서열로서 이용하여 맵핑되지 않은 코드워드 CWA에 의해 표시된 특정한 기본 2원 벡터를 2원 벡터 CWSA에 연결함으로써 코드워드를 조성한다. 일부 예시적인 구현에서, 코드 맵핑 기능은 최하위 비트부터 시작하여 맵핑되지 않은 코드워드의 서브세그먼트들을 처리하며, 여기서 맵핑되지 않은 코드워드의 각각의 서브세그먼트는 log2 Z 비트이며, 이것은 기본 2원 벡터 인덱스의 각각 의 엔트리의 길이이다. 이들 구현들 중 일부에서, 코드 맵핑 기능은, 맵핑되지 않은 코드워드의 각각의 연속적 인 서브세그먼트(예컨대, CWA의 각각의 2비트)에 대해, 그 서브세그먼트의 값과 코드 맵핑 기능에 정의된 코드 맵핑들에 기초하여 서브세그먼트에 대응하는 기본 2원 벡터를 식별할 수 있다. 이들 구현들 중 일부에서, 코드 맵핑 기능은 각각의 식별된 기본 2원 벡터를 2원 벡터 CWSA에 연속적으로 연결한다. 예를 들어, 코드 맵핑 기 능의 코드 맵핑들이 {[00]-> C0, [01]-> C1, [10]-> C2, 및 [11]-> C3}으로 구성되고 맵핑되지 않은 코드워드의 처음 4개 비트가 [1101…]인 경우, 코드 맵핑 기능은 먼저 맵핑되지 않은 코드워드의 첫 번째 서브세그먼트[1 1]에 기초하여 첫 번째 기본 2원 벡터 C3을 식별하고 C3을 (처음에는 널(null)이고 어떠한 비트도 포함하지 않는) CWSA에 연결할 수 있다. 그 다음, 코드 맵핑 기능은 맵핑되지 않은 코드워드의 두 번째 서브세그먼트"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 10, "content": "[01]에 기초하여 제2 기본 2원 벡터 C1을 식별할 수 있고, 제2 기본 2원 벡터 C1을 CWSA에 연결할 수 있다. 코 드 맵핑 기능은 CWA가 완전히 처리될 때까지 이러한 방식으로 계속될 수 있다. CNA 모듈은 본 개시내용의 범위를 벗어나지 않고 다른 적절한 방식으로 및/또는 상이한 코드 맵핑 기능들을 이용하여 코드워드를 결정하도 록 구성될 수 있다는 것을 이해해야 한다. 2012에서, 선조 VDAX의 CNA 모듈은 코드워드 및 마스터 CNA 객체에 기초하여 디지털 커뮤니티 멤버에 대한 CNA 객체를 생성한다. 일부 구현에서, CNA 모듈은 커뮤니티 멤버의 코드워드에 기초하여 마스터 CNA 객체 의 고유한 서브세트를 디지털 커뮤니티 멤버에게 할당한다. 구현들에서, CNA 모듈은 커뮤니티 멤버에게 할당될 CNA 객체인 CNAA를 처음에 초기화할 수 있다. 이들 구현들 중 일부에서, CNA 객체 CNAA는 마스터 CNA 객체(예컨대, U x V 행렬)와 동일한 구조를 가지며 처음에는 0으로 채워집니다. 이들 구현들 중 일부에서, CNA 모듈은, 커뮤니티 멤버의 코드워드 벡터 CWA를 마스터 CNA 객체의 각각의 부분들에 대한 인덱스들의 서열로서 이용할 수 있다. 이들 구현들에서, 코드워드의 각각의 비트 위치는 마스터 CNA 객체의 각각의 세그먼트를 참조하되, CNA 모듈이, 각각의 비트 위치를, 마스터 CNA 객체의 대응하는 부분이 커뮤니티 멤버의 CNA 객체에 할당되는지를 나타내는 플래그로서 처리할 수 있게 한다. 구현들에서, CNA 모듈은, 코드워드 벡터 내의 각각의 비트에 대해, 그 비트의 값에 기초하여 마스터 CNA 객체의 대응하는 부분을 할당할지를 결정할 수 있다. 예를 들어, biti의 값이 \"1\"이면, CNA 모듈은 마스터 CNA 객체의 (i- 1)번째 부분 S(i-1)을 커뮤니티 멤버의 CNA 객체의 마스터 CNA 객체의 (i-1)번째 부분에 할당한다. 이 예에서, biti의 값이 \"0\"이면, CNA 모듈은 마스터 CNA 객체의 (i-1)번째 부분을 커뮤니티 멤버의 CNA 객체에 할당 하지 않는다. 이 시나리오에서, CNA 모듈은 커뮤니티 멤버 CNA 객체의 미할당된 부분을 무작위 값으로 채 울 수 있다. 예를 들어, CNA 모듈은 무작위 값을 생성한 다음, 무작위 값에 관해 하나 이상의 계산 연산을 수행하여 V 비트 값을 획득할 수 있고, 이에 의해 CNA 모듈은 V 비트 값을 CNA 객체의 (i-1)번째 부분 에 추가한다. 설명의 목적을 위해, 전술된 내용은 CNA 객체에 \"노이즈\"를 추가하는 것이라고 지칭될 수 있다. 한 구체적인 예, 마스터 CNA 객체는 [S0, S1, S2,…, S(U-2), S(U-1)]일 수 있다. 이 예에서, 커뮤니티 멤버 CWSA의 코드워드가 [011…01]이면, CNA 모듈은 다음과 같은 CNA 객체 CNAA를 생성한다: [Noise0, S1, S2,…, NOISE(U-2), S(U-1)], 여기서, S1, S2, 및 S(U-1)은 CNAA에 할당되고, NOISE0 및 NOISE(U-2)는 CNA 객체의 0번째 부분과 (U-2)번째 부분들에 각각 할당되는 길이 V의 무작위로 생성된 비트 스트링들이다. CNA 모듈은 마스터 CNA 객체의 할당된 부분들 및/또는 노이즈를 임의의 적절한 방식으로 CNA 객체에 추가하도록 구성될 수 있다. 예를 들어, CNA 모듈은 마스터 CNA 객체의 할당된 부분들 및/또는 노이즈를 CNA 객체에 추가하기 위해 연결 연 산들 및/또는 비트 시프팅과 OR 연산들의 조합을 이용할 수 있다. 그 다음, CNA 모듈은 생성된 CNA 객체 CNAA를 각각의 디지털 커뮤니티 멤버에게 할당할 수 있다. 앞선 설명은 CNA 생성 및 할당의 예시적인 구현들을 제공한다는 것을 이해해야 한다. 제공된 기술들은 단지 예 로서만 제공된 것이며, CNA를 생성하고 할당하기 위한 새로운 방식들이 나중에 개발되어 CNA 모듈에서 구 현될 수 있다. PNA 생성 및 할당 CG-ESP의 일부 구현에서, 디지털 생태계의 선조 VDAX의 루트 DNA 모듈은 디지털 생태계의 멤버들(예컨대, 코호트 VDAX들, 엔클레이브 VDAX들, 및/또는 생태계 VDAX)에 대한 PNA 객체들을 생성하도록 구성된 PNA 모듈 을 포함한다. 이들 구현들에서, PNA 객체들은, 생태계 멤버들이 적격성 동기화 프로세스를 통해 링크 교 환 동안에 결합-적격성을 확정할 수 있게 한다. 일부 구현에서, 선조 VDAX의 PNA 모듈은 처음에 디지털 생태계에 대응하는 마스터 PNA 객체를 생성하고, (아래에서 더 상세히 논의되는) 생태계 멤버에 대응하는 자격 증들에 기초하여 마스터 PNA 객체로부터 각각의 상응하는 생태계 멤버에 대한 고유 PNA 객체를 도출한다. 일단 PNA 객체가 생성되고 나면, PNA 객체는 하나 이상의 디지털 매체를 통해 디지털 커뮤니티 멤버에게 제공될 수 있다. 도 21은 PNA 객체들을 디지털 생태계의 멤버들에게 할당하기 위한 예시적인 구현들을 나타낸다. 이들 구현들에 서, PNA 모듈은 마스터 PNA 객체를 생성한 다음, 디지털 코호트의 각각의 멤버들에 대한 PNA 객체들을 도 출 및 할당한다. 설명의 목적을 위해, 디지털 생태계의 코호트에 대한 PNA 객체를 생성하는 것과 관련하여 방 법이 설명된다. 그러나, 도 21의 방법은, 다른 유형들의 커뮤니티 멤버들(예컨대, 엔클레이브들, 생태계들 등)에 대한 PNA 객체들을 생성하기 위해 실행될 수 있다. 도 21의 방법은 PNA 모듈과 관련하여 설명된다. 이 방법은 본 개시내용의 범위를 벗어나지 않고 다른 적절한 컴퓨팅 자원들에 의해 실행될 수 있다는 것을 이해 해야 한다. 또한, 도 21에 설명된 기술들은 PNA 객체들을 생성하는 예시적인 수단으로서 제공된 것이고 나중의 기술들은 추가로 개발될 수 있다. 2110에서, 선조 VDAX의 PNA 모듈은 마스터 PNA 객체를 생성한다. 일부 구현에서, 마스터 PNA 객체는 비밀 컴포넌트(PNAS로 표시됨)와 공개 컴포넌트(PNAP로 표시됨)를 포함한다. 구현들에 있어서, 마스터 PNA 객체의 비 밀 컴포넌트 PNAS는 비공개이고 보안 저장되어, 선조 VDAX만이 PNAS에 액세스할 수 있다. 구현들에서, PNAS는 M 차의 비밀 2진 원시 다항식( 로 표시됨), 비밀 M 비트 값(\"비밀값\"이라고 지칭되고 로 표시됨), 및 N개 쌍들의 M 비트 난수들을 포함하는 비밀 객체를 포함한다. 일부 구현에서, PNA 모듈은 비밀 원시 다항식 을 생성하거나 기타의 방식으로 결정할 수 있다. 달리 언급되지 않는 한, 다항식들 및 원시 다항식들이 라는 언급은 각각 2진 다항식들 및 2진 원시 다항식들을 언급한다는 점에 유의한다. 일부 구현에서, PNA 모듈 은, 비밀 2진 원시 다항식 으로서 이용될 수 있는 M차 2진 원시 다항식을 무작위로 생성할 수 있다. 구현들에서, PNA 모듈은, 가 M 비트 벡터로 표현되도록 비밀 번호 를 무작위로 생성하거나 기타의 방 식으로 결정할 수 있다. 일부 구현에서, PNA 모듈은 가 M 비트 벡터로 정의되도록 비밀 번호 를 무작위로 생성할 수 있다. 언급된 바와 같이, 는 M차의 2진 원시 다항식이며, d는 M비트 숫자이다(예컨대, M = 256).구현들에서, 비밀 컴포넌트의 비밀 객체 PNAS는 N개 쌍의 M비트 값들을 포함하며, 이것은 i= 1…N에 대해 로서 표시될 수 있다. 이 예에서, 은 i번째 쌍의 제1 M-비트 값일 수 있고, 는 i번째 쌍의 제2 M-비트 값일 수 있다. M 비트 수들의 쌍들의 개수 N은 디지털 생태계의 각각의 멤버들의 각각의 자격증들을 나 타내는데 이용되는 비트 수와 동일할 수 있다는 점에 유의한다. 예를 들어, (예컨대, 고정 길이 벡터 등의 구 조화된 포맷의) 코호트들의 자격증들이 256비트 벡터들로 표시되는 경우, N=256이다. 일부 구현에서, PNA 모듈 은 M 비트 값들의 각각의 쌍을 무작위로 생성할 수 있다. 이들 구현들 중 일부에서, PNA 모듈은 M비 트 값들 각각이 특정 값과 서로 소(prime)라는 조건으로 M비트 값들 각각을 생성할 수 있다. 예를 들어, 일부 구현에서, i=1…N에 대한 각각은 (2M-1))과 서로 소이다. 구현들에서, 마스터 PNA 객체의 공개 컴포넌트 PNAP는 디지털 생태계 내에서 공개이므로, PNAP는 디지털 생태계 에 허용된 임의의 멤버(예컨대, 코호트, 엔클레이브 등)와 공유될 수 있다. 이들 구현들 중 일부에서, PNAP는 PNAS와 동일한 크기이다(예컨대, 16KB, 8KB, 32KB 등). 구현들에서, 마스터 PNA 객체의 공개 컴포넌트 PNAP는 2개의 초기 M차 2진 원시 다항식 및 , 및 공개 객체를 포함한다. 이들 구현들 중 일부에서, PNA 모듈은 M차의 임의의 2개의 초기 M차 2진 원시 다항식을 생성하거나 기타의 방식으로 결정할 수 있다. 구현들에서, PNAP의 공개 객체는, i= 2…N에 대해 로서 표시될 수 있는, N-1개 쌍의 M비트 값들을 포 함할 수 있다. 이 예에서, 는 i번째 쌍의 제1 M-비트 값일 수 있고, 는 i번째 쌍의 제2 M-비트 값일 수 있다. 일부 구현에서, PNA 모듈은 M 비트 값들의 각각의 쌍을 무작위로 생성할 수 있다. 이들 구현들 중 일부에서, PNA 모듈은 M비트 값들 각각이 특정한 값과 서로 소라는 조건(예컨대, i= 2…N에 대한 각각은 (2M-1))와는 서로 소이다)으로 M비트 값들 각각을 무작위로 생성할 수 있다. 2112에서, CG-ESP는 마스터 PNA 객체와 생태계 멤버의 고유한 자격증들에 기초하여 디지털 생태계의 각각의 상 응하는 멤버에 대한 PNA 객체를 할당하고 배포한다. 설명의 목적을 위해, 이 단계는 단일 코호트에 대해 설명 되지만, 개시된 기술들은 임의의 수의 생태계 멤버들(예컨대, 다른 코호트들, 엔클레이브들, 또는 생태계 전 체)에 대해 반복될 수 있다는 점에 유의한다. 구현들에서, PNA 모듈은, 마스터 PNA 객체 및 코호트의 자격증들에 기초하여 디지털 생태계의 각각의 코호 트(예컨대, i번째 코호트)에 대한 고유한 PNA 객체(PNAi로 표시됨)를 생성한다. 일부 구현에서, 코호트의 자격증들이란 코호트를 나타내는 데이터를 포함하는 데이터 구조를 지칭할 수 있으며, 여기서 자격증들은 사람이 이해할 수 있거나 이해하지 못할 수도 있다. 일부 구현에서, 자격증들은 코호트 고 유의 고정-크기 비트 벡터(예컨대, N비트 벡터)로 구조화될 수 있다. 추가적으로 또는 대안으로서, 코호트의 자격증들은 가변 길이 벡터로부터 (예컨대, 변환 기능을 이용하여) 코호트 고유의 N비트 벡터로 변환될 수 있다. 구현들에서, PNA 모듈은 (예컨대, 위에서 CNA 모듈과 관련하여 논의된 바와 같이) 많은 잠재 적 유형의 데이터 소스들 중 한 데이터 소스로부터 수신된 데이터에 기초하여 자격증들을 결정할 수 있다. 일부 구현에서, 코호트(예컨대, i 번째 코호트)의 고유 PNA 객체 PNAi는, 비밀 비율 , 공개 2진 원시 다 항식 , 및 마스터 PNA 객체의 공개 컴포넌트 PNAP를 포함한다. 이들 구현들에서, PNA 모듈은, 특 히 코호트의 자격증들에 기초하여 코호트에 대한 비밀값 및 공개 다항식을 결정할 수 있다. 실시예들에서, PNA 모듈은, 비밀 객체로부터 획득된 비밀 원시 다항식 와 비밀값 , 및 비밀값 에 기초하여 공개 원시 다항식 을 생성한다. 이들 구현들 중 일부에서, PNA 모듈은 입력으로서 코호트의 자격증들 이 주어지면 마스터 PNA 컴포넌트의 비밀 컴포넌트 PNAS에 제1 맵핑 기능을 적용함으로써 비밀값 를 결정할 수 있다. 이들 구현들에서, 제1 맵핑 기능은 비밀 비율 를 M비트 값으로서 출력한다. 일부 구현에서,비밀 비율 는, PNAS, PNAP, 및 i번째 코호트의 자격증들로부터 도출될 수 있다. 예를 들어, 일부 구현에 서, PNA 모듈은 고정 길이 벡터의 코호트의 자격증들을 획득할 수 있다(예컨대, 코호트의 자격증들의 길이 가 256비트인 경우 ). 그 후, PNA 모듈은 i번째 코호트의 제1 값 를 획득하기 위해 자격증들의 개개의 비트들 의 값들에 기초하여 비밀 컴포넌트 PNAS의 비밀 객체 로부터 대응 하는 요소들을 선택하고 결합할 수 있다. 유사하게, PNA 모듈은 코호트의 제2 값 를 획득하기 위해 코 호트의 자격증들의 개개의 비트들 의 값들에 따라 공개 컴포넌트 PNAP의 공개 객체 로부터 요소들을 선택하고 결합할 수 있다. 그 후, PNA 모듈은, 코호트의 제1 값 및 제2 값 가 주어지면 i번째 코 호트의 비밀 비율 를 결정할 수 있다. 일부 구현에서, 제1 값과 제2 값 및 는 코호트와 공유되지 않는다; 오히려 비밀 비율 만 코호트와 공유된다는 점에 유의한다. 예시적인 구현들에서, PNA 모듈은, 입력으로서 코호트의 자격증들이 주어지면 마스터 PNA 객체의 비밀 컴 포넌트 PNAS 및 공개 컴포넌트 PNAP에 제2 맵핑 기능을 적용함으로써 공개 2진 원시 다항식 를 결정할 수 있다. 이들 구현들에서, PNA 모듈은, 제2 맵핑 기능의 출력, 마스터 PNA 객체의 비밀 컴포넌트 PNAS의 제1 값 , 비밀값 와, 비밀 컴포넌트 PNAS의 비밀 2진 원시 다항식 에 기초하여 공개 원시 다항식 를 결정할 수 있다. 구현들에서, PNA 모듈은, 코호트가 마스터 PNA 객체의 공개 컴포넌트 PNAP, 비밀 비율 , 및 공개 2진 원시 다항식 (예컨대, )을 수신하도록, 결과 PNA 객체 PNAi를 코호 트에 할당할 수 있다. 임의의 2개의 코호트 i와 j는, 마스터 PNA 객체의 공개 컴포넌트 PNAP의 공개 객체와 공 개 원시 다항식 쌍 및 와, 코호트들 i와 j의 자격증들에 기초하여 공개 비율 를 계산할 수 있다는 점에 유의한다. 논의되는 바와 같이, PNA 객체는 커뮤니티의 또 다른 코호트에 대해 적격성 동기화를 수행함으로써 결합 적격성 을 확정하기 위해 링크 교환 동안에 코호트의 VDAX에 의해 이용될 수 있다. 예를 들어, 일부 구현에서, 제1 코 호트(예컨대, \"코호트 A\")의 코호트 VDAX는, (예컨대, 아래에서 더 상세히 설명되는 바와 같이) 제1 코호트의 PNA 객체와 제1 및 제2 코호트들의 자격증들에 기초하여 제2 코호트(예컨대, \"코호트 B\")에 대한 링크를 스폰하 거나 및/또는 이로부터의 링크를 디코딩할 때 상관관계 벡터 CPNA(A, B)를 생성할 수 있다. 도 21의 구현들은 생태계의 멤버들을 위한 PNA 객체들을 생성하기 위한 예시적인 기술들로서 제공된다. 선조 VDAX는 본 개시내용의 범위를 벗어나지 않고 다른 적절한 방식으로 마스터 PNA 객체 및 생태계 멤버들에 대한 PNA 객체들을 생성하도록 구성될 수 있다는 것을 이해해야 한다. 마스터 PNA 객체들 및/또는 생태계 멤버들에 대한 PNA 객체들의 컴포넌트들을 생성하기 위한 추가적인 기술들이 나중에 개발될 수 있다는 것을 추가로 이해 해야 한다. 서열 맵핑 논의된 바와 같이, 서열 맵핑은 변환값(TV) 또는 게놈 결합 인자(GEF)를 획득하기 위해 게놈 데이터 객체(예컨 대, LNA 객체, XNA 객체 또는 ZNA 객체)에 \"서열을 맵핑\"하는 것을 포함하는 동작 세트를 지칭할 수 있다. 일 반적으로, 서열 맵핑은, 서열, 게놈 데이터 객체, 및 명령어 세트(예컨대, GRI, 윈도우 벡터로 표시된 명령어들 등)을 수신하고 그에 기초하여 고정 길이 벡터(예컨대, GEF 또는 TV)를 출력하는 계산 프로세스이다. 예를 들 어, 서열 맵핑 모듈은 서열(PSS)(예를 들어, 생태계 멤버 및 생태계 멤버 B(예를 들어, 코호트 A 및 코호 트 B)에 대해 획득가능한 메타데이터에서 취해진 공개 또는 비공개 대칭 서열)을 수신할 수 있고, 서열, A와 B양쪽 모두에 할당된 게놈 데이터 객체(예컨대, XNA, LNA 또는 ZNA), 및 (D(A, B)로 표시되는) A와 B간에 공유되 는 서열 맵핑 명령어들에 기초하여 벡터를 결정할 수 있다. 논의되는 바와 같이, 서열 맵핑 명령어들 D(A, B) 는 서열 맵핑을 기동시키는 프로세스(예컨대, 링크 스폰/호스팅 대 VBLS 인코딩/디코딩) 및 생태계의 CG-ESP의 구성에 따라 달라질 수 있다. 예시적인 구현들에서, D(A,B)는 (예를 들어, 링크 교환 또는 후속 링크 업데이트 동안에) A가 B에게 제공하는 GRI이거나, B에 대한 링크를 스폰할 때 A에 의해 생성된 \"윈도우\"에 의해 표시되는 명령어들, 또는 서열 맵핑 모듈이 서열 맵핑 동작을 수행할 때 이용하는 다른 적절한 데이터 구조들일 수 있다. 다른 곳에서 설명되는 바와 같이, GRI 또는 \"윈도우\"에 의해 표시된 명령어들 등의, 서열 맵핑 명령어들 은 2원 벡터들로 구현될 수 있거나 및/또는 스크립트 또는 실행가능한 코드 등의 파라미터화된 명령어 세트로 구현될 수 있다. 나중 구현들에서, 명령어들은, 서열 맵핑 명령어들이 상이한 관계들에 대해 달라지도록, 값들 (예컨대, 파라미터화된 GRI에 대해 무작위로 생성된 값들 또는 링크 교환 기반의 서열 맵핑에서 이용되는 명령 어들을 파라미터화하기 위해 무작위로 선택된 윈도우)로 파라미터화될 수 있다. 구현들에서, 서열 맵핑 기능은 게놈 데이터 객체를 입력으로서 수신하며(예컨대, LNA, XNA 및 ZNA), 여기서 게놈 데이터 객체의 유형은 서열 맵핑 프로세스를 기동시키는 프로세스에 의존한다. 일부 시나리오에서, 서열 맵핑 모듈은 게놈 결합 인자(GEF)를 생성하기 위해(예컨대, VBLS 생성을 위해) 기동된다. 논의된 바와 같이, GEF란 디지털 객체를 VBLS 객체로 변환하는데 이용되는 값을 지칭할 수 있다. 구현들에서, 서열 맵핑 모듈은, 특정한 게놈 조절 명령어들(GRI)이 주어지면, 서열(예컨대, 공개 서열 또 는 비공개 서열)을, 수정되거나 미수정된 게놈 분화 객체(예컨대, 수정되거나 미수정된 XNA 객체 또는 수정되거 나 미수정된 ZNA 객체)에 \"맵핑\"함으로써 GEF를 생성할 수 있다. 수정되거나 미수정된 게놈 데이터 객체에 \"서 열을 맵핑\"하는 것은 결과 값(예컨대, GEF 또는 TV)을 획득하기 위해, 서열, GRI, 및 게놈 데이터 객체에 관해 수행되는 일련의 명시된 동작들을 지칭할 수 있다는 것을 이해해야 한다. 구현들에서, 서열 맵핑 모듈은 GRI 및 (수정되거나 미수정된 게놈 분화 객체일 수 있는) 게놈 분화 객체를 입력으로서 수신할 수 있다. 일부 구현에서, 서열 맵핑 모듈은 (비공개 서열 또는 공개 서열일 수 있는) 맵핑될 서열를 입력으로서 추가로 수신할 수 있다. 대안으로서, 서열 맵핑 모듈은 디지털 객체(또는 VBLS 객체)를 수신하고, 디지털 객체(또는 VBLS 객체)로부터 맵핑할 서열을 추출하도록 구성될 수 있다. 일부 구현에서, 서열 맵핑 명령어들(예컨대, GRI 등)은 생태계 멤버에 의해 생성될 수 있고 임의의 다른 생태계 멤버와 공유되지 않을 수 있다는 점에 유의한다. 예를 들어, 서열 맵핑이 신뢰받는 실행 환경 내에서 수행되고 있는 경우(예컨대, 프로세서가 런타임시에 프로그램에 의해 이용되거나 출력되는 컴퓨터 프로그램 및/또는 관련 데이터의 명령어들을 인코딩 및 디코딩하고 있는 경우), 신뢰받는 실행 환경 내에서 서열 맵핑을 수행하는데 이 용되는 GRI는, 어떠한 다른 생태계 멤버들과 공유되지 않고 그 GRI를 생성한 VDAX(예컨대, 아래에서 논의되는 EIC VDAX)에만 알려진 GRI일 수 있다. 이들 구현들 중 일부에서, EIC VDAX는 GRI를 생성할 수 있고, EIC VDAX 는 이를 이용하여 명령어들 및/또는 관련 데이터를 인코딩 및 디코딩하기 위해 EIC VDAX에서 이용하는 GEF들을 생성한다. 따라서, 일부 구현에서, GRI가 임의의 다른 VDAX와 공유되지 않지만 GEF들을 생성하기 위해 서열 맵 핑 프로세스에서 계속 이용된다. 따라서, 아래에 논의된 서열 맵핑의 예시적인 구현들은 VDAX들 사이에서 교환 되는 GRI를 논의하지만, 논의된 기술들은 VDAX가 VDAX에게만 알려진 GRI(또는 다른 적절한 서열 맵핑 명령어 들)를 이용하여 서열 맵핑을 수행하고 있는 시나리오에 적용될 수 있다. 이러한 시나리오들에서, 커뮤니티 멤 버들 사이에서 교환되는 GRI(또는 다른 적절한 서열 맵핑 명령어들)를 이용하여 수행되는 기술들에 대한 설명들 은, 단일 커뮤니티 멤버(예컨대, EIC VDAX)에 의해 생성되고 비밀리에 저장된 GRI(또는 다른 적절한 서열 맵핑 명령어들)를 이용하여 GEF들 및/또는 변환값들을 생성하는 서열 맵핑 모듈/CG-ESP를 구성할 때 이들 시나리오들 을 처리하기 위해 적용될 수 있다. 아래에 논의되는 바와 같이, 자료 데이터 블록(MDB)을 공증하는 경우 등의, 소정의 GRI가 임의의 다른 생태계 멤버와 교환되지 않는 다른 시나리오들도 있다. 설명의 목적을 위해, \"비밀 GRI\" 또는 \"비밀 명령어들\"이라는 용어는, 임의의 다른 생태계 멤버와 공유되지 않는 명령어들을 지칭할 수 있 다. GEF와 유사하게, 변환값(TV)은 링크 스폰 동안에 GEC(Genomic Engagement Cargo)를 변환하는데 이용되는 값을 지칭할 수 있으며, 이것은 보안 링크 교환 프로세스를 용이화한다. 일부 구현에서, 서열 맵핑 모듈은, (링크 교환 프로세스에 관해 논의된 바와 같이) 게놈 상관관계 객체로부터 추출된 \"윈도우\"가 주어지면 서열(예 컨대, 공개 서열 또는 비공개 서열)을 수정된 게놈 상관관계 객체(예컨대, 수정된 LNA 객체)에 \"맵핑\"함으로써 변환값을 생성할 수 있다. 구현들에서, 서열 맵핑 모듈은 윈도우 및 (수정되거나 미수정된 게놈 분화 객 체일 수 있는) 게놈 상관관계 객체(예컨대, LNA 객체)를 입력으로서 수신할 수 있다. 일부 구현에서, 서열 맵 핑 모듈은 맵핑될 서열을 입력으로 더 수신할 수 있다. 예를 들어, 일부 구현에서 서열 맵핑 모듈은 링크모듈에 의해 생성된 맵핑 서열(예컨대, 링크 스폰 프로세스 동안에 생성된 윈도우 및 GRI로부터 도출된 값)를 수신할 수 있다. 대안으로서, 서열 맵핑 모듈은 입력 값들(예컨대, 윈도우 및 GRI)을 수신하도록 구성될 수 있고, 계산 기능 세트를 이용하여 입력 값들로부터 맵핑 서열을 생성하도록 구성될 수 있다. \"변환 값\"이라는 용어는, 게놈 분화 객체 또는 게놈 상관관계 객체를 수정하기 위해 생성되는 경우 등의, 다른 유형의 동작들과 관련하여 사용될 수 있다는 점에 유의한다. 일부 구현에서, 서열 맵핑 모듈은 동일한 서열 맵핑 프로세스를 이용하여 GEF들 및 TV들을 생성한다. 이 들 구현들에서, 서열 맵핑 모듈은 서열(예컨대, 비공개 서열 또는 공개 서열) 및 게놈 데이터 객체(예컨대, LNA 객체, XNA 객체 또는 ZNA 객체)를 수신할 수 있고, 동일한 일련의 계산 기능들을 이용하여 변 환값(예컨대, LNA 객체가 수신되는 경우) 또는 GEF(예컨대, XNA 또는 ZNA 객체가 수신되는 경우)을 출력할 수 있다. 대안으로서, 변환값들을 생성하는데 이용되는 서열 맵핑 프로세스와 GEF들을 생성하는데 이용되는 서열 맵핑 프로세스는 상이한 프로세스들일 수도 있다. 도 22 및 도 23의 예들은 변환값들 및/또는 GEF들을 생성하 는데 이용될 수 있는 서열 맵핑 프로세스들의 상이한 변형들을 도시한다. 이해할 수 있는 바와 같이, 서열 맵 핑 프로세스는, 암호 기반, 암호 없는, 또는 하이브리드일 수 있다. 추가적인 또는 대안적인 서열 맵핑 프로세 스들이 본 개시내용의 범위를 벗어나지 않고 CG-ESP에서 구현될 수 있다는 것을 이해해야 한다. 미수정된 게놈 데이터 객체로의 서열 맵핑 도 22는 서열을 생성하기 위한 예시적인 방법을 나타낸다. 이들 예시적인 구현들에서, 서열 맵핑 모듈은 미수정된 게놈 분화 객체를 수신하고 일련의 계산 기능들을 이용하여 서열을 게놈 분화 객체에 맵핑한다. 설명 의 목적을 위해, 프로세스는, 서열, 미수정된 게놈 분화 객체(예컨대, XNA 또는 ZNA) 및 GRI에 기초하여 GEF를 생성하는 것으로서 설명된다. 이 프로세스는 GRI를 윈도우들로 대체하고 미수정된 게놈 분화 객체를 미수정된 상관관계 객체(예컨대, LNA 객체)로 대체함으로써 TV들을 생성하도록 개조될 수 있다. 도 22의 서열 맵핑 프로 세스는 암호 기반 방식, 암호 없는 방식, 또는 하이브리드 방식으로 수행될 수 있다. 2210에서, 서열 맵핑 모듈은, 게놈 분화 객체, GRI 및 서열을 포함하는 서열 맵핑 데이터를 획득한다. 구 현들에서, 서열 맵핑 모듈에 대한 입력은 게놈 분화 객체(예컨대, XNA 또는 ZNA) 및 GRI를 포함할 수 있다. 도 22의 예에서, 게놈 분화 객체는 수정되지 않았고 엔클레이브 특유의 또는 생태계 특유의 게놈 분화 객체와 미-분화되어 있다. 일부 구현에서, GRI는 호스트 VDAX가 또 다른 충분히 상관된 디지털 생태계 멤버와 형성한 특유의 관계에 대응한다. 대안으로서, 일부 구현에서, GRI는 또 다른 생태계 멤버와 교환되지 않은 비 밀 GRI이다. 일부 구현에서, 서열은, 서열이 양쪽 VDAX 모두에 의해 획득가능하도록 대칭 서열일 수 있다. 구현들에서, 서 열은 공개 서열 또는 비공개 서열일 수 있다. 아래 제공된 일부 예에서, \"PSS\"는 임의의 유형의 서열을 지칭할 수 있다. 언급한 바와 같이, 서열은 공개 서열 또는 비공개 서열일 수 있고, 여기서 \"PBS\"는 공개 서열을 지칭 할 수 있고, \"PVS\"는 비공개 서열을 지칭할 수 있다. 구현들에서, 서열 PSS는 서열 맵핑 모듈에 입력으로 서 제공된다. 대안으로서, 일부 구현에서, 서열은 서열 맵핑 모듈에 의해 추출된다. 이들 구현들에서, 서열 맵핑 모듈은 (예컨대, 서열 맵핑 모듈의 구성에 정의된 및/또는 GRI에 정의된) 명시된 세트의 비트들을 추출하도록 구성된다. 예를 들어, 데이터 패킷(또는 대응하는 VBLS-인코딩된 데이터 패킷) 등의 디지 털 객체(또는 대응하는 VBLS 객체)의 경우, 비트 세트는 하나 이상의 패킷 헤더의 정의된 세트의 비트 위치들로 부터 추출될 수 있다. 이들 구현들에서, 서열은 디지털 객체의 미인코딩된 부분으로부터 선택될 수 있다. 이 러한 방식으로, 인코딩 및 디코딩 프로세스를 통해 서열의 대칭성이 유지될 수 있다. 2212에서, 서열 맵핑 모듈은 GRI에 기초하여 서열 PSS를 서열 변환 벡터(SCV)로 변환한다. 일부 구현에서, PSS는 한 세트의 하나 이상의 계산 기능을 포함하는 변환 기능을 이용하여 SCV로 변환될 수 있다. 구현들에서, SCV는 다음에 따라 결정될 수 있다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 11, "content": "여기서 F1은 서열 PSS를 입력으로서 수신하고 하나 이상의 계산 기능을 이용하여 PSS를 변환하여 SCV를 획득하 는 (\"서열 변환 기능\"이라고도 지칭될 수 있는) 변환 기능이다. 실시예들에서, 서열 변환 기능은, 암호 기반 (예컨대, 키-명료화, 암호화, 및/또는 다른 키-가역 계산 기능들), 암호 없는(예컨대, 해시 기능들, 순환 시프 트 및/또는 XOR 기능들의 일련의 파라미터화된 조합, 단방향 비가역 기능들, 및/또는 기타 등등), 또는 하이브 리드 기능들(암호 기반의 기능과 암호 없는 기능들의 일부 조합)일 수 있다. 일부 구현에서, 서열 변환 기능은 PSS 및 GRI를 수신하고, 하나 이상의 계산 기능(예컨대, 암호 기반의 기능(들) 및/또는 암호 없는 기능(들))를실행하여, 결과적으로 SCV를 생성한다. SCV의 크기는 CG-ESP의 디폴트 구성의 일부로서 및/또는 GRI에서 정의 될 수 있고, 이에 의해 더 큰 SCV들을 이용하여 CG-ESP의 전반적인 보안을 강화할 수 있다는 점에 유의한다. 설명과 예시의 목적들을 위해, SCV는 256비트 벡터로서 설명된다. 일부 구현에서, 서열 변환 기능 F1은, 서열 맵핑 모듈의 표준 구성에 포함될 수 있다. 대안으로서, GRI는 PSS를 SCV로 변환하는데 이용될 특정한 구성을 나타낼 수 있다. 예를 들어, GRI에서의 n비트 세트는 PSS를 변 환하기 위해 이용할 특정한 변환 기술(예컨대, 계산 기능)을 나타낼 수 있다. 추가적으로 또는 대안으로서, GRI는, 실행될 때 서열을 SCV로 변환하는 특정한 명령어들을 포함할 수 있다. 일부 구현에서, GRI는 PSS를 변 환하는데 이용되는 파라미터들을 나타낼 수 있다. 예를 들어, GRI는, PSS의 암호 기반의 변환을 수행할 때 이 용할 키, 암호 없는 동작들(예컨대, 순환 시프트와 XOR 기능들의 조합)을 파라미터화하는데 이용되는 보안 수정 파라미터들(SMP), 해시 기능에 대한 입력, 및/또는 이와 유사한 것을 나타낼 수 있다. 추가적으로 또는 대안으 로서, 변환 기능은, 서열과 GRI를 결합하고(예컨대, (PSS || GRI)) 결합된 서열과 GRI를 하나 이상의 계산 기능 세트를 이용하여 변환해 SCV를 획득하도록 구성될 수 있다. 입력 서열이 주어지면 SCV를 결정하기 위해 서열 맵핑 모듈에 의해 추가적인 또는 대안적인 기술들이 적용될 수 있다는 것을 이해해야 한다. 2214에서, 서열 맵핑 모듈은 SCV에 기초하여 미수정된 게놈 분화 객체를 맵핑하여 맵핑된 분화 객체를 획 득한다. 일부 구현에서, 서열 맵핑 모듈은 게놈 분화 객체(예컨대, XNA 또는 ZNA)를 SCV에 기초한 N개의 2원 벡터에 맵핑하여 맵핑된 게놈 분화 객체( 로서 표시됨)를 획득한다. 일부 구현 에서, 서열 맵핑 모듈은 아래에 도시된 바와 같이 맵핑 기능 F2를 실행한다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 12, "content": "맵핑 기능(위에서 F2로 표시됨)은 상이한 방식들로 구성될 수 있다는 것을 이해해야 한다. 일부 구현에서, 맵 핑 기능 F2가 구성되는 방식은 GRI에 적어도 부분적으로 정의된다. 이들 구현들에서, 맵핑 기능이 미수정된 게 놈 분화 객체를 맵핑하는 방식은 GRI에 의해 지정되거나 및/또는 파라미터화될 수 있다. 일부 실시예에서, 맵 핑 기능 F2가 디폴트 구성으로서 제공될 수 있다. 일부 구현에서, 맵핑 기능 F2는 SCV에 기초하여 게놈 분화 객체로부터 N 벡터 세트를 선택하여 N 벡터 세트 ( 또는 i= 1...N에 대해 로서 표시됨)를 획득할 수 있다. 예를 들어, 일부 구현에서, 맵핑 기능 F2는 SCV에 의해 표시된 N 값들에 기초하여 게놈 분화 객체로부터 N개의 벡터 를 선택할 수 있다. 예를 들어, 일부 구현에서, 맵핑 기능은 SCV를 N개 섹션으로 분리할 수 있다(예컨대, , 여기서 SCV의 i번째 섹션 si로 표시되는 값은 i번째 벡터가 추출되는 게놈 분화 객체에서의 시 작 위치를 나타낸다). 이들 예시적인 구현들에서, 맵핑 기능은, 게놈 분화 객체의 si번째 비트에서 시작하여 미 리정의된 수의 비트들을 추출하여 각각의 벡터 를 획득할 수 있다. 이들 예시적인 구현들 중 일부에서, 맵 핑 기능 F2는 를 다음과 같이 출력할 수 있다: . 일부 구현에서, 맵핑 기능은, 서열 맵핑 모듈의 구성에 따라 및/또는 SCV 및/또는 GRI에 기초하여 N개 벡 터(i=1…N에 대해 ) 각각을 추가로 수정하여 맵핑된 2원 벡터 세트(예컨대, i= 1…N에 대해 )를 획 득하도록 구성될 수 있다. 이들 예시적인 구현들에서, 맵핑 기능 F2는 를 로서 출력할 수 있다. 이러한 방식으로, 맵핑된 게놈 분화 객체 (예컨대, ) 객체는 또한, CG-ESP의 보안 레벨을 증가시키기 위해 더욱 난독화될 수 있다. 이들 예시적인 구현들에서, 맵핑 기능은 N 벡터(i= 1…N에 대해 ) 각각에 관해 하나 이상의 계산 기능을수행하여 N개의 맵핑된 벡터 세트(i= 1…N에 대해 )를 획득할 수 있다. 예를 들어, 일부 예시적인 구현에 서, 맵핑 기능은 N개의 벡터들 [A0, A1,…AN-1] 각각에 관해 각각의 순환 시프트 동작을 실행하여 N개의 맵핑된 벡터 [L0, L1,…LN-1]를 획득할 수 있다. 이들 구현들 중 일부에서, 각각의 벡터에 적용되는 각각의 상응하는 순 환 시프트 동작은 SCV 또는 GRI의 각각의 세그먼트에 의해 표시되는 값에 기초하여 파라미터화될 수 있다. 이 들 예시적인 구현들에서, 각각의 벡터 는 Mi와 동일한 값만큼 시프트될 수 있고, 여기서 Mi는 SCV 또는 GRI의 i번째 섹션에 의해 표현되는 값이다. 예를 들어, 일부 구현에서 맵핑 기능은 각각의 상응하는 벡터 Ai를 Mi 비트만큼 우측으로 순환적으로 비트 시프트할 수 있다. Mi의 값은 임의의 다른 적절한 방식으로 SCV 또는 GRI로부터 도출될 수 있다. 전술된 내용은 SCV에 기초하여 게놈 분화 객체를 맵핑하기 위한 맵핑 기능의 예시적인 구현들이고, 대안적인 맵 핑 기능들이 개발되고 서열 맵핑 모듈에서 구현될 수 있다는 점에 유의한다. 더욱이, 예시적인 맵핑 기능 구현들이 XNA 객체들에 관해 설명되기 때문에, 상기의 설명은 본 개시내용의 범위를 벗어나지 않고 ZNA 객체들 및/또는 LNA 객체들을 맵핑하기 위해 적용될 수 있다. 2216에서, 서열 맵핑 모듈은 계산 기능 세트를 이용하여 맵핑된 분화 객체를 수정해 수정된 맵핑된 게놈 분화 객체(\"수정된 게놈 분화 객체\"라고도 함)를 획득한다. 예를 들어, 일부 구현에서, 서열 맵핑 모듈은 다음에 따라 맵핑된 게놈 분화 객체를 수정하는 수정 기능 F3을 포함할 수 있다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 13, "content": "여기서, 는 M개의 행을 갖는 수정된 게놈 분화 객체를 나타낸다. 일부 구현에서, 수 정 기능 F3은 GRI에 기초하여 맵핑된 게놈 분화 객체를 수정한다. 이들 구현들 중 일부에서, 수정 기능 F3은, 계산 기능 세트를 이용하여 GRI에 대응하는 하나 이상의 수정 파라미터(MP)에 기초해 맵핑된 게놈 분화 객체를 수정한다. 일부 구현에서, 수정 파라미터들은 GRI에서 정의되거나 GRI에 의해 기타의 방식으로 표시될 수 있다. 추가적으로 또는 대안으로서, 하나 이상의 수정 파라미터는, (예컨대, 2122에서) 부분적으로 GRI에 기초 하여 결정된 SCV를 포함할 수 있다. 추가적으로 또는 대안으로서, 수정 파라미터는 GRI에 기초하여 기타의 방 식으로 결정될 수 있다. 실시예들에서, 수정 기능 F3은, 암호 기반, 암호 없는, 또는 하이브리드 방식으로 구 성될 수 있다. 구현들에서, 수정 기능은 N개의 수정된 벡터 세트, 를 출력할 수 있 다. 일부 구현에서, 수정 기능 F3은 암호 기반의 수정 기능일 수 있다. 이들 구현들에서, 수정 기능은 수정 값을 이용하여 맵핑된 게놈 분화 객체를 변환하는 명료화 기능 및/또는 암호화 기능을 포함할 수 있다. 이들 구현들 중 일부에서, 수정 기능 F3은 수정 값을 명료화 또는 암호화를 위한 키로서 이용할 수 있다. 이들 구현들에서, 수정 기능은 N개의 맵핑된 벡터(예컨대, 또는 ) 중의 각각의 벡터에 명료화 및/또는 암호화 기능을 적용하여 N개의 수정된 벡터 를 획득할 수 있다. 이전에 논의된 바와 같이, N개의 수정된 벡터 세트 를 획득하기 위해 N개의 맵핑된 벡터에 임의의 수의 상이한 암호화 알고리즘이 적용될 수 있다. 수정된 게놈 데이터 객체의 수정은 N개의 맵핑된 벡터 각각에 관해 또는 맵핑된 분화 객체의 명시된 세그먼트들에 대해 수행 될 수 있다는 것을 이해해야 한다. 일부 구현에서, 수정 기능 F3은, 수정 값을 이용하여 N개의 맵핑된 벡터 정보 세트에 관해 하나 이상의 암호 없 는 계산 기능을 수행하는 암호 없는 수정 기능일 수 있다. 이들 구현들 중 일부에서, 수정 기능은 수정 파라미 터에 의해 키잉되는 해시 기능을 포함할 수 있다. 이들 구현들에서, 해시 기능은 값으로 키잉될 수 있는 임의 의 적절한 해시 기능일 수 있다. 해시 기능은, N개의 수정된 벡터 를 획득하기 위해 N개의 맵핑된 벡터 중의 개개의 벡터들(예를 들어, i=1...N에 대해 , 여기서)에 적용될 수 있다 일부 구현에서, 암호 없는 수정 기능 F3은 맵핑된 게놈 분화 객체에 대한 파라미터화된 XOR 및 순환 시프트 동 작들의 조합을 실행하여 수정된 게놈 분화 객체를 획득할 수 있다. 이들 구현들 중 일부에서, XOR 및 순환 시 프트 동작들은, 비트들이 시프트 및/또는 XOR되는 방식을 정의하는 보안 수정 파라미터(SMP) 세트를 이용하여 파라미터화된다. 구현들에서, SMP는 하나 이상의 수정 파라미터에 의해 정의될 수 있다. 이들 구현들 중 일부 에서, 수정 기능은 파라미터화된 암호 없는 동작들을 맵핑된 분화 객체에 적용하여(예컨대, ) N개의 수정된 벡터 세트 를 획득할 수 있다. 수정은 N개의 맵핑된 벡터 각각에 대해 또는 맵핑된 분화 객체 의 명시된 세그먼트들에 대해 수행될 수 있다는 것을 이해해야 한다. 일부 구현에서, 수정 기능 F3은 하이브리드 수정 기능일 수 있다. 이들 구현들에서, 수정 기능은 이들 기능들 을 N개의 맵핑된 벡터 중의 각각의 벡터에 적용하여(예컨대, ) N개의 수정된 벡터 를 획득할 수 있다. 이들 구현들에서, 하이브리드 수정 기능은 적어도 하나의 암호 기반의 동작 및 적어도 하나의 암호 없는 수정 기능을 포함할 수 있다. 이들 구현들 중 일부에서, 하이브리드 수정 기능은 수정 파라미터를 암호 기반의 기능 및/또는 암호 없는 기능에 대한 입력 파라미터로 이용할 수 있다. 전술된 내용은 게놈 분화 객체를 수정하기 위한 수정 기능의 예시적인 구현들이고, 대안적인 맵핑 기능들이 개 발되고 서열 맵핑 모듈에서 구현될 수 있다는 점에 유의해야 한다. 더욱이, 예시적인 수정 기능 구현들이 맵핑된 XNA 객체들과 관련하여 설명되었으므로, 상기의 설명들은 본 개시내용의 범위를 벗어나지 않고 맵핑된 ZNA 객체들 및/또는 맵핑된 LNA 객체들을 수정하기 위해 적용될 수 있다. 2218에서, 서열 맵핑 모듈은 수정된 게놈 분화 객체를 GEF로 변환한다. 구현들에서, 서열 맵핑 모듈(44 0)은, 수정된 분화 객체를 수신하고 일련의 계산 동작들을 이용하여 수정된 분화 객체를 GEF로 변환하는 변환 기능 F4를 적용한다. 이들 구현들에서, GEF는 다음에 따라 결정될 수 있다: . 서열 맵핑 모듈의 구성에 따라, 변환 기능 F4는, 암호 기반, 암호 없는, 또는 하이브리드일 수 있다. 변 환 기능은 고정된 크기의 벡터를 출력하도록 구성될 수 있다. 예를 들어, 일부 예시적인 구현들에서, 변환 기 능은 고정 길이(예컨대, 128비트, 256비트, 512비트 등)의 GEF를 출력하도록 구성될 수 있다. GEF의 크기는 CG-ESP에 정의된 표준 크기이거나 GRI에 의해 표시될 수 있다(예컨대, GRI의 비트들의 미리결정된 서브세트)는 것을 이해해야 한다. 논의된 바와 같이, GEF가 클수록 보안 레벨이 높아진다. 일부 구현에서, 변환 기능 F4는 암호 기반의 기능이다. 예를 들어, 일부 구현에서, GEF는 다음에 따라 결정될 수 있다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 14, "content": "이 예에서, 변환 기능 F4는, GEF가 고정 길이(예컨대, 256비트)가 되도록, GRI 및 수정된 맵핑된 분화 객체(예 컨대, 연결된 벡터들)를 수신하고 이에 기초하여 GEF를 출력하는 블록 암호 기반의 메시지 인증 코드(CMAC) 기 능을 포함한다. 본 개시내용의 범위를 벗어나지 않고 GEF를 획득하기 위해 추가적인 또는 대안적인 암호 기반 의 동작들이 수정된 벡터들에 적용될 수 있다는 것을 이해해야 한다. 일부 구현에서, 변환 기능은 암호 없는 기능이다. 예를 들어, 일부 구현에서, GEF는 다음에 따라 결정될 수 있 다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 15, "content": "이들 예시적인 구현들에서, 변환 기능은 수정된 벡터 세트( ) 내의 벡터들을 연결할 수 있고, 그 다음 고정 길이 벡터 GEF를 출력하기 위해 연결 동작들의 결과에 해시 기능(예컨대, 이미지 저항성 기 능)을 적용할 수 있다. 제공된 예에서, 해시 기능은 256비트 벡터들을 출력한다. 그러나, 변환 기능은 본 개 시내용의 범위를 벗어나지 않고 상이한 길이들(예컨대, 128비트 해시값, 512비트 해시값 등)의 벡터들을 출력하도록 구성될 수 있다는 것을 이해해야 한다. GEF의 길이는 이 예에서 달라질 수 있고, 에서의 벡터들의 길이와 같거나, 작거나, 클 수 있다는 것을 이해해야 한다. 변환 기 능은 본 개시내용의 범위를 벗어나지 않고 GEF를 획득하기 위해 수정된 벡터들에 추가적인 또는 대안적인 암호 없는 기능들을 적용할 수 있다는 것을 이해해야 한다. 일부 구현에서, 변환 기능 F4는 하이브리드 기능이다. 예를 들어, 일부 구현에서, GEF는 다음에 따라 결정될 수 있다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 16, "content": "이 예시적인 구현들에서, 변환 기능 F4는 수정된 벡터들 각각을 단일 벡터로 연결할 수 있고 결과 벡터를 암호 화하여 암호화된 벡터를 획득할 수 있다. 예시적인 구현에서, 변환 기능 F4는 암호화된 벡터를 해싱하여 GEF (예컨대, 256비트 GEF)를 획득할 수 있다. 제공된 예에서, 해시 기능은 256비트 벡터들을 출력한다. 그러나, 변환 기능은 본 개시내용의 범위를 벗어나지 않고 상이한 길이들(예컨대, 128비트 해시값, 512비트 해시값 등) 의 벡터들을 출력하도록 구성될 수 있다는 것을 이해해야 한다. 본 개시내용의 범위를 벗어나지 않고 GEF를 획 득하기 위해 추가적인 또는 대안적인 암호 기반의 및/또는 암호 없는 동작들이 수정된 벡터들에 적용될 수 있다 는 것을 이해해야 한다. 도 22의 전술된 방법은 서열 맵핑 모듈의 예시적인 구현들을 제공한다. 위에서 제공된 기술들은, 서열 맵 핑 모듈에서 이용될 수 있는 기능들(예컨대, F1, F2, F3 및 F4)의 예시적인 구성들을 포함한 서열 맵핑 모 듈들의 예시적인 구성들을 설명하는데 이용된다. 본 개시내용의 범위를 벗어나지 않고 추가적인 또는 대 안적인 기술들이 서열 맵핑 모듈에서 구현되고 적용될 수 있다는 것을 본 개시내용으로부터 이해해야 한다. 또한, 위에서 설명된 기술들은 XNA 또는 ZNA에 적용되어 GEF를 생성할 수 있다. 더욱이, 위에서 언급한 바와 같이, 서열 맵핑 모듈은 링크 교환 프로세스 동안 이용되는 변환값들을 결정하기 위해 위에서 설명된 기술들 또는 다른 적절한 서열 맵핑 동작들에 따라 구성될 수 있다. 이들 구현들 중 일부에서, 위에 논의된 기 술들은 역시 변환값을 생성하기 위해 적용될 수 있다. 이들 구현들에서, 서열 맵핑은, 게놈 상관관계 객체(예 컨대, LNA 객체), 서열, 및 윈도우를 획득할 수 있다. 이들 구현들에서, 윈도우는, 윈도우가 서열 맵핑 동작들 을 수행하는데 이용되는 정보를 나타내도록 GRI와 동일한 방식으로 구조화될 수 있다. 이들 구현들 중 일부에 서, 링크 교환 동안 획득되는 서열은, 링크 스폰 VDAX에 의해 생성되고 링크 스폰 VDAX와 링크 호스팅 VDAX에 의해 공유되는 공통 게놈 적격성 정보를 이용하여 암호화되는 값일 수 있다. 수정된 DNA를 이용한 서열 맵핑 도 23은 본 개시내용의 일부 구현에 따른 서열 맵핑을 수행하기 위한 예시적인 프로세스를 나타낸다. 도 23의 예에서, 서열 맵핑 모듈은 수정된 게놈 분화 객체(예컨대, 수정된 XNA 또는 수정된 ZNA) 또는 수정된 게놈 상관관계 객체(예컨대, 수정된 LNA)를 획득하고 이에 기초하여 GEF 또는 변환값을 결정한다. 설명의 목적을 위 해, 예시적인 프로세스는 게놈 분화 객체와 관련하여 설명되고 서열 맵핑 모듈은 GEF를 생성하고 있다. 2310에서, 서열 맵핑 모듈은, 수정된 게놈 분화 객체, GRI 및 서열을 포함하는 서열 맵핑 데이터를 획득한 다. 일부 구현에서, 서열 맵핑 모듈에 대한 입력은, 수정된 게놈 분화 객체(예컨대, 수정된 XNA 객체 또 는 수정된 ZNA 객체) 및 GRI를 포함할 수 있다. 예를 들어, 일부 구현에서, VDAX는 수정된 게놈 분화 객체를 메모리에 저장할 수 있고, 이에 의해 수정된 게놈 분화 객체는 디지털 커뮤니티의 특정한 코호트 또는 엔클레이 브에 관하여 VBLS를 생성하거나 디코딩하도록 수정되었다. 도 22와 관련하여 논의된 바와 같이, GRI는, 호스트 VDAX가 또 다른 충분히 상관된 디지털 커뮤니티 멤버와 형 성한 특정한 관계에 대응하고, 서열은 공개 서열 또는 비공개 서열일 수 있는 대칭 서열이다. 일부 구현에서, 서열은 입력으로서 서열 맵핑 모듈에 제공된다. 대안으로서, 일부 구현에서, 서열은 서열 맵핑 모듈(44 0)에 의해 추출된다. 이들 구현들에서, 서열 맵핑 모듈은 (예컨대, 서열 맵핑 모듈의 구성에 정의된 및/또는 GRI에 정의된) 명시된 세트의 비트들을 추출하도록 구성된다. 예를 들어, 데이터 패킷 등의 디지털 객 체의 경우, 정의된 세트의 비트 값들은 하나 이상의 패킷 헤더로부터 추출되어 서열이 생성될 수 있다. 일부 구현에서, 서열은 디지털 객체의 미인코딩된 부분으로부터 선택될 수 있다. 이러한 방식으로, 서열의 대칭성이 각각의 VDAX들에 의해 인코딩 및 디코딩 프로세스를 통해 유지될 수 있다. 2312에서, 서열 맵핑 모듈은 GRI에 기초하여 서열 PSS를 서열 변환 벡터(SCV)로 변환한다. 도 22와 관련 하여 논의된 바와 같이, PSS는 한 세트의 하나 이상의 계산 기능을 포함하는 변환 기능을 이용하여 SCV로 변환 될 수 있다. 일부 구현에서, 서열 맵핑 모듈은 한 세트의 하나 이상의 계산 기능을 포함하는 변환 기능을 이용하여 PSS를 SCV로 변환할 수 있다. 구현들에서, SCV는 다음에 따라 결정될 수 있다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 17, "content": "여기서 F1은, 서열 PSS를 입력으로서 수신하고 하나 이상의 계산 기능을 이용하여 PSS를 변환하는 (\"서열 변환 기능\"이라고 지칭되는) 변환 기능이다. 도 22와 관련하여 논의된 바와 같이, 변환 기능 F1의 계산 기능들은, 암호 기반의 기능들(예컨대, 명료화, 암호화, 및/또는 기타의 가역적 계산 기능들), 암호 없는 기능들(예컨대, 키-해시 기능, 순환 시프트 및/또는 XOR 기능들의 일련의 파라미터화된 조합의 실행, 및/또는 기타의 적절한 단 방향 계산 기능들), 또는 하이브리드 기능들(암호 기반의 및 암호 없는 기능들의 일부 조합)일 수 있다. 일부 구현에서, 서열 변환 기능은 PSS 및 GRI를 수신하고 계산 기능들을 실행하여, 결과적으로 SCV를 생성한다. SCV 의 크기는 CG-ESP의 디폴트 구성의 일부로서 및/또는 GRI에서 정의될 수 있고, 이에 의해 더 큰 SCV들을 이용하 여 CG-ESP의 전반적인 보안을 강화할 수 있다는 점에 유의한다. 그러나, 설명과 예시의 목적들을 위해, SCV는 256비트 벡터로서 설명된다. 일부 구현에서, 서열 변환 기능 F1은, 서열 맵핑 모듈의 표준 구성에 포함될 수 있다. 대안으로서, GRI는 PSS를 SCV로 변환하는데 이용될 특정한 구성을 나타낼 수 있다(예컨대, GRI의 처음 n개 비트는 PSS를 변환하기 위해 이용할 특정한 변환 기술(예컨대, 하나 이상의 특정한 암호 기반의 기능 및/또는 암호 없는 기능)을 나타 낼 수 있다). 일부 구현에서, GRI는 PSS를 변환하는데 이용되는 파라미터들을 나타낼 수 있다. 예를 들어, GRI는, PSS의 암호 기반의 변환을 수행할 때 이용할 키, 암호 없는 동작들(예컨대, 순환 시프트와 XOR 기능들의 조합)을 파라미터화하는데 이용되는 보안 수정 파라미터들(SMP), 해시 기능에 대한 입력, 및/또는 이와 유사한 것을 나타낼 수 있다. 추가적으로 또는 대안으로서, 서열 변환 기능은, 서열과 GRI를 결합하고(예컨대, (PSS || GRI)) 결합된 서열과 GRI를 계산 기능 세트를 이용하여 변환해 SCV를 획득하도록 구성될 수 있다. 입력 서 열이 주어지면 SCV를 결정하기 위해 서열 맵핑 모듈에 의해 추가적인 또는 대안적인 기술들이 적용될 수 있다는 것을 이해해야 한다. 2314에서, 서열 맵핑 모듈은 SCV를 이용하여 수정된 게놈 분화 객체를 맵핑해 맵핑된 분화 객체를 획득한 다. 이들 구현들 중 일부에서, 서열 맵핑 모듈은, SCV에 기초하여 수정된 게놈 분화 객체를 맵핑해 맵핑 된 수정된 게놈 분화 객체(또는 간단히, 맵핑된 게놈 분화 객체)를 획득하는 맵핑 기능을 포함한다. 구현들에 서, 서열 맵핑 모듈은 맵핑 기능 F2를 실행할 수 있고, 여기서 맵핑 기능은 수정된 게놈 분화 객체 및 SCV 를 입력으로서 수신한다. 이들 구현들 중 일부에서, 서열 맵핑 모듈은 다음을 실행할 수 있다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 18, "content": "여기서, XNAm은 서열 맵핑 모듈에 입력으로서 제공된 수정된 XNA 객체이고, 는 수정된 XNA 객체와 SCV가 주어지면 맵핑 기능 F2에 의해 생성된 결과적인 맵핑된 XNA 객체이다. 일부 구현에서, 맵핑 기능 F2는 도 22와 관련하여 논의된 것과 동일한 방식으로 구성될 수 있다. 맵핑 기능 F2는 본 개시내용의 범위를 벗어나지 않고 대안적인 방식들로 구성될 수 있다는 것을 이해해야 한다. 도 22와 관련하여 논의된 바와 같이, 일부 구현에서, 맵핑 기능 F2는 SCV에 기초하여 수정된 게놈 분화 객체로 부터 N개 벡터들의 세트를 선택하여 N개 벡터들의 세트( 또는 (i= 1...N에 대해 )로서 표시됨)를 획득할 수 있다. 예를 들어, 일부 구현에서, 맵핑 기능은, 도 22에 관하여 설명된 바와 같이, SCV 에 의해 표시된 N 값들에 기초하여 수정된 게놈 분화 객체로부터 N개의 벡터 을 선택할 수 있다. 이들 예시적인 구현들 중 일부에서, 맵핑 기능 F2는 를 으 로서 출력할 수 있다. 일부 구현에서, 맵핑 기능은, 서열 맵핑 모듈의 구성에 따라 및/또는 SCV 및/또는 GRI에 기초하여 N개 벡 터(i=1…N에 대해 ) 각각을 추가로 수정하여 맵핑된 벡터 세트(예컨대, i= 1…N에 대해 )를 획득하도록 구성될 수 있다. 이들 예시적인 구현들에서, 맵핑 기능 F2는 을 로서 출력할 수 있다. 이러한 방식으로, 맵핑된 게놈 분화 객체 객체는 CG-ESP의 보안을 증가시키기 위해 더욱 난독화될 수 있다. 이들 예시적인 구현들에서, 맵핑 기능은 (예컨대, 도 22에 관하여 설명된 바와 같이) N 벡터(i= 1…N에 대해 ) 각각에 관 해 하나 이상의 계산 기능을 수행하여 N개의 맵핑된 벡터 세트(i= 1…N에 대해 )을 획득할 수 있다. 전술된 내용은 SCV를 이용하여 수정된 게놈 분화 객체를 맵핑하기 위한 맵핑 기능 F2의 예시적인 구현들을 제 공하고, 대안적인 맵핑 기능들이 개발되고 서열 맵핑 모듈에서 구현될 수 있다는 것을 이해해야 한다. 2316에서, 서열 맵핑 모듈은 맵핑된 게놈 분화 객체를 GEF로 변환한다. 구현들에서, 서열 맵핑 모듈(44 0)은, 맵핑된 분화 객체를 수신하고 맵핑된 게놈 분화 객체를 GEF로 변환하는 변환 기능을 적용한다. 일부 구 현에서, 서열 맵핑 모듈은, 도 22에 관하여 설명된 바와 같이, 변환 기능 F4를 실행할 수 있다. 이들 구 현들에서, 서열 맵핑 모듈은 다음에 따라 GEF를 결정할 수 있다: . 서열 맵핑 모듈의 구성에 따라, 변환 기능 F4는, 암호 기반, 암호 없는, 또는 하이브리드일 수 있다. 변 환 기능은 고정된 크기의 벡터를 출력하도록 구성될 수 있다. 예를 들어, 일부 예시적인 구현들에서, 변환 기 능은 고정 길이(예컨대, 128비트, 256비트, 512비트 등)의 GEF를 출력하도록 구성될 수 있다. GEF의 크기는 CG-ESP에 정의된 표준 크기이거나 GRI에 의해 정의된 수 있다는 것을 이해해야 한다. 논의된 바와 같이, GEF가 클수록 보안 레벨이 높아진다. 일부 구현에서, 변환 기능 F4는 암호 기반의 기능이다. 예를 들어, 일부 구현에서, GEF는 다음에 따라 결정될 수 있다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 19, "content": "이 예에서, 변환 기능 F4는, GEF가 고정 길이(예컨대, 256비트)가 되도록, GRI 및 수정된 맵핑된 분화 객체(예 컨대, 연결된 벡터들)를 수신하고 이에 기초하여 GEF를 출력하는 블록 암호 기반의 메시지 인증 코드(CMAC) 기 능을 포함한다. 본 개시내용의 범위를 벗어나지 않고 GEF를 획득하기 위해 추가적인 또는 대안적인 암호 기반 의 동작들이 수정된 벡터들에 적용될 수 있다는 것을 이해해야 한다. 본 개시내용의 범위를 벗어나지 않고 GEF 를 획득하기 위해 추가적인 또는 대안적인 암호 기반의 동작들이 수정된 벡터들에 적용될 수 있다는 것을 이해 해야 한다. 일부 구현에서, 변환 기능은 암호 없는 기능이다. 예를 들어, 일부 구현에서, GEF는 다음에 따라 결정될 수 있 다:"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 20, "content": "이들 예시적인 구현들에서, 변환 기능은 수정된 벡터 세트( ) 내의 벡터들을 연결할 수 있고, 그 다음 고정 길이 벡터 GEF를 출력하기 위해 연결 동작들의 결과에 해시 기능(예컨대, 이미지 저항성 기 능)을 적용할 수 있다. 제공된 예에서, 해시 기능은 256비트 벡터들을 출력한다. 그러나, 변환 기능은 본 개 시내용의 범위를 벗어나지 않고 상이한 길이들(예컨대, 128비트 해시값, 512비트 해시값 등)의 벡터들을 출력하 도록 구성될 수 있다는 것을 이해해야 한다. GEF의 길이는 이 예에서 달라질 수 있고, 에서의 벡터들의 길이와 같거나, 작거나, 클 수 있다는 것을 이해해야 한다. 변환 기 능은 본 개시내용의 범위를 벗어나지 않고 GEF를 획득하기 위해 수정된 벡터들에 추가적인 또는 대안적인 암호 없는 기능들을 적용할 수 있다는 것을 이해해야 한다. 일부 구현에서, 변환 기능 F4는 하이브리드 기능이다. 예를 들어, 일부 구현에서, GEF는 다음에 따라 결정될 수 있다: 이 예시적인 구현들에서, 변환 기능 F4는 수정된 벡터들 각각을 단일 벡터로 연결할 수 있고 결과 벡터를 암호 화하여 암호화된 벡터를 획득할 수 있다. 예시적인 구현에서, 변환 기능 F4는 암호화된 벡터를 해싱하여 GEF (예컨대, 256비트 GEF)를 획득할 수 있다. 제공된 예에서, 해시 기능은 256비트 벡터들을 출력한다. 그러나, 변환 기능은 본 개시내용의 범위를 벗어나지 않고 상이한 길이들(예컨대, 128비트 해시값, 512비트 해시값 등) 의 벡터들을 출력하도록 구성될 수 있다는 것을 이해해야 한다. 본 개시내용의 범위를 벗어나지 않고 GEF를 획 득하기 위해 추가적인 또는 대안적인 암호 기반의 및/또는 암호 없는 동작들이 수정된 벡터들에 적용될 수 있다 는 것을 이해해야 한다. 도 23의 전술된 방법은 서열 맵핑 모듈의 예시적인 구현들을 제공한다. 위에서 제공된 기술들은, 서열 맵 핑 모듈에서 이용될 수 있는 기능들(예컨대, F1, F2, F3 및 F4)의 예시적인 구성들을 포함한 서열 맵핑 모 듈들의 예시적인 구성들을 설명하는데 이용된다. 본 개시내용의 범위를 벗어나지 않고 추가적인 또는 대 안적인 기술들이 서열 맵핑 모듈에서 구현되고 적용될 수 있다는 것을 본 개시내용으로부터 이해해야 한다. 또한, 위에서 설명된 기술들은 수정된 XNA 또는 수정된 ZNA 객체들에 적용되어 GEF를 생성할 수 있다. 더욱이, 위에서 언급한 바와 같이, 서열 맵핑 모듈은 링크 교환 프로세스 동안 이용되는 변환값(TV)들을 결정하기 위해 위에서 설명된 기술들 또는 다른 적절한 서열 맵핑 동작들에 따라 구성될 수 있다. 이들 구현들 중 일부에서, 위에 논의된 기술들은 역시 변환값을 생성하기 위해 적용될 수 있다. 이들 구현들에서, 서열 맵 핑은, 수정된 게놈 상관관계 객체(예컨대, 수정된 LNA 객체), 서열, 및 윈도우를 획득할 수 있다. 이들 구현들 에서, 윈도우는, 윈도우가 서열 맵핑 동작들을 수행하는데 이용되는 정보를 나타내도록 GRI와 동일한 방식으로 구조화될 수 있다. 이들 구현들 중 일부에서, 링크 교환 동안 획득되는 서열은, 링크 스폰 VDAX에 의해 생성되 고 링크 스폰 VDAX와 링크 호스팅 VDAX에 의해 공유되는 공통 게놈 적격성 정보를 이용하여 암호화되는 값일 수 있다. 링크 교환 예들 논의된 바와 같이, 링크 모듈은 본 개시내용의 일부 구현에 따라 링크를 스폰하고 디코딩하도록 구성될 수 있다. 구현들에서, VDAX의 링크 모듈은 링크 교환 프로세스 동안 또 다른 VDAX와의 결합 적격성을 검증하 기 위해 VDAX에 할당된 게놈 적격성 객체(예컨대, CNA 객체 및/또는 PNA 객체)를 활용할 수 있다. 본 개시내용 으로부터 알 수 있는 바와 같이, 링크 교환 프로세스는 사실상 무제한의 초확장성 상관관계를 가능케한다. -- 즉, 인증에 참여하는 신뢰받는 제3자 없이도 2개의 충분히 제휴된 생태계 코호트가 서로를 인증할 수 있는 능력 을 가능케한다. 일부 구현에서, 초확장성 상관관계는 링크 교환 프로세스 동안 게놈 상관관계 객체들(예컨대, LNA 객체들)을 이용하여 달성될 수 있으며, 이에 의해, 링크를 스폰하고 호스팅하는데 이용되는 정보는 링크를 교환하는 생태계 코호트들 사이의 고유한 상관관계를 나타내는 상관관계 벡터(예컨대, CCNA(A,B) 또는 CPNA(A, B))를 이용하여 암호화되거나 기타의 방식으로 변환될 수 있다. 일부 구현에서, 링크 모듈은 CNA 객체들을 이용하여 결합 적격성을 확정하고 이 프로세스는 결합 상관이라 고 지칭될 수 있다. 논의된 바와 같이, 일부 구현에서 VDAX의 CNA 객체는, 무작위로 생성된 행렬일 수 있는 마 스터 CNA 객체로부터 도출될 수 있다. 이들 구현들에서, 마스터 CNA 객체는 비공개일 수 있고 선조 VDAX 외부 의 어떠한 VDAX에 의해서도 액세스가능하지 않다. 일부 구현에서, 선조 VDAX는 각각의 커뮤니티 멤버에 대응하 는 고유한 획득가능한 데이터 세트에 대응하는 코드워드 벡터를 결정한다. 이들 구현들에서, 선조 VDAX는 각자 의 커뮤니티 멤버에게 할당할 마스터 CNA 객체의 고유한 서브세트를 결정하기 위해 각각의 커뮤니티 멤버의 고 유 코드워드 벡터를 이용할 수 있고, 전술된 바와 같이 CNA 객체의 할당된 서브세트에 기초하여 CNA 객체를 생 성할 수 있다. 일부 구현에서, 고유의 획득가능한 데이터 세트는 커뮤니티 멤버에 의해 커뮤니티 멤버의 자격 증들로서 이용될 수 있되, 자격증들은 생태계 멤버의 코드워드 벡터를 결정하기 위해 다른 커뮤니티 멤버들에 의해 이용될 수 있다. 이러한 방식으로, 동일한 생태계의 임의의 2개의 커뮤니티 멤버(예컨대, 코호트 A 및 코 호트 B) 양쪽 모두는 각각의 커뮤니티 멤버의 각자의 자격증들에 기초하여 그들 자신의 코드워드 벡터와 다른 커뮤니티 멤버의 코드워드 벡터를 결정할 수 있다. 이들 구현들에서, 커뮤니티 멤버들 각각은 2개의 커뮤니티 멤버의 코드워드 벡터들의 교차점에 기초하여 공통 상관관계 벡터를 생성할 수 있고, 이에 의해 공통 상관관계 벡터는 링크 교환 프로세스를 확보하는데 이용될 수 있다. 설명의 목적을 위해, 는, 제1 커뮤니티 멤 버의 제1 자격증들, 제2 커뮤니티 멤버의 제2 자격증들, 및 제1 커뮤니티 멤버의 CNA 객체 또는 제2 커뮤니티 멤버의 CNA 객체에 기초하여, 제1 커뮤니티 멤버(예컨대, 코호트 A)와 제2 커뮤니티 멤버(예컨대, 코호트 B)에의해 생성될 수 있는 상관관계 벡터를 지칭할 수 있다. 제1 커뮤니티 멤버와 제2 커뮤니티 멤버 양쪽 모두는 그들 각자의 CNA 객체와 제1 및 제2 자격증들만을 이용하여 동일한 상관관계 벡터 를 생성할 수 있다. 일부 구현에서, 링크 모듈은 PNA 객체들을 이용하여 결합 적격성을 확정하고 이 프로세스는 적격성 동기화 라고 지칭될 수 있다. 이들 구현들에서, VDAX의 링크 모듈은 아래에서 더 상세히 설명되는 바와 같이 PNA 를 이용하여 공통 상관관계 벡터 를 획득하도록 구성될 수 있다. 도 24는 본 개시내용의 일부 구현에 따른 예시적인 링크 교환 프로세스를 나타낸다. 링크 교환 프로세스는 링 크 스폰 및 링크 호스팅을 포함할 수 있다. 설명의 목적을 위해, 예시적인 링크 스폰 프로세스는, 링크 스폰 VDAX의 링크 모듈에 의해 수행되는 것으로 설명되고 도 24의 우측에 도시되어 있다. 유사하게, 예 시적인 링크 호스팅 프로세스는 링크 호스팅 VDAX의 링크 모듈에 의해 수행되는 것으로 설명되고 도 24의 좌측에 도시되어 있다. 일부 구현에서, 단계들 중 일부 또는 전부는 각각의 VDAX의 다른 적절한 모듈들 에 의해 실행될 수 있다는 것을 이해해야 한다. 도 24의 예에서, 링크 스폰 VDAX는 링크 호스팅 VDAX에 제공되는 게놈 조절 명령어들(GRI)을 포함 하는 링크를 생성하고, 링크 호스팅 VDAX는 이것을 디코딩하여 링크 스폰 VDAX에 의해 디코딩되는 VBLS를 생성하는데 사용되는 GRI를 획득한다. 도시된 예에서, 링크 스폰 VDAX와 링크 호스팅 VDAX(240 4)는 동일한 CG-ESP 구성으로 구성된다. 링크 스폰 VDAX는 제1 게놈 데이터 세트(예컨대, 제1 CNA 객체 및/또는 제1 PNA 객체, 제1 LNA 객체 및 제1 XNA 객체)를 할당받고, 링크 호스팅 VDAX는 제2 게놈 데이터 세트(예컨대, 제2 CNA 객체 및/또는 제2 PNA 객체, 제2 LNA 객체 및 제2 XNA 객체)를 할당받는다. 링크 호스팅 VDAX와 링크 스폰 VDAX가 동일한 디지털 생태계의 멤버들이라고 가정하면, 디지털 생태계의 선조 VDAX는 제1 게놈 데이터 세트를 생성하여 링크 스폰 VDAX에 할당하고 제2 게놈 데이터 세트를 생성하여 링크 호스팅 VDAX에 할당한다. 이들 구현들에서, 링크 스폰 VDAX와 링크 호스팅 VDAX의 CNA 객체들 및/또는 PNA 객체들은 고유하지만 상관되어 있다. 이들 구현들에서, 링크 스폰 VDAX와 링크 호스팅 VDAX의 LNA 객체들은, 2개의 커뮤니티 멤버가 (예컨대, 커뮤니티 소유자에 의해 지정되고 생태계 VDAX에 의해 시행되는) 상호 관심 ID를 가질 때 동일한 LNA 객체일 수 있다. 2410에서, 링크 스폰 VDAX의 링크 모듈은 링크 스폰 VDAX와 링크 호스팅 VDAX 사이의 고유 상관관계를 나타내는 상관관계 벡터 C(A, B)를 결정한다. 일부 구현에서, 링크 스폰 VDAX의 링크 모듈은, 링크 스폰 VDAX에 대응하는 제1 자격증들, 링크 호스팅 VDAX에 대응하는 제2 자격증 들, 및 링크 스폰 VDAX에 할당된 제1 CNA 객체에 기초하여, 상관관계 벡터 CCNA(A, B)를 결정한다. 일부 구현에서, 링크 스폰 VDAX와 링크 호스팅 VDAX는 링크 스폰 VDAX와 링크 호스팅 VDAX(240 4)에 의해 표현되는 각각의 커뮤니티 멤버들 고유의 자격증들을 교환한다. 예를 들어, 링크 스폰 VDAX의 제1 자격증들은 링크 스폰 VDAX에 의해 표현되는 커뮤니티 멤버(예컨대, 제1 코호트)에 관련된 정보를 포 함할 수 있고, 링크 호스팅 VDAX의 제2 자격증들은 링크 호스팅 VDAX에 의해 표현되는 제2 커뮤니 티 멤버(예컨대, 제2 코호트)에 관련된 정보를 포함할 수 있다. 일부 구현에서, 링크 스폰 VDAX는 링크 호스팅 VDAX에 제1 자격증들을 제공할 수 있고, 링크 호스팅 VDAX는 링크 스폰 VDAX에 제2 자격증들을 제공할 수 있다. 대안으로서, VDAX들은 각각의 커뮤니티 멤버들의 획득가능한 정보를 유지하는 데 이터 소스로부터 다른 커뮤니티의 자격증들을 획득할 수 있다. 일부 구현에서, 링크 스폰 VDAX의 링크 모듈은 코드 맵핑 기능을 제1 자격증들에 적용함으로써 제1 자격증들에 기초하여 링크 스폰 VDAX에 대응하는 제1 코드워드 벡터를 결정한다. 이들 구현들에서, 코드 맵핑 기능은 (예컨대, 본 개시내용의 다른 곳에서 설명되는 바와 같이) 제1 자격증들을 수신하고 링크 스폰 VDAX에 의해 표현되는 제1 커뮤니티 멤버에 대응하는 고유 코드워드 벡터를 출력한다. 마찬가지로, 링 크 모듈은 링크 호스팅 VDAX에 의해 표현되는 커뮤니티 멤버의 제2 자격증들에 기초하여 링크 호스 팅 VDAX에 대응하는 제2 코드워드 벡터를 결정한다. 이들 구현들 중 일부에서, 링크 모듈은 제1 자 격증들 및 제2 자격증들에 동일한 코드 맵핑 기능을 적용할 수 있다. 링크 모듈은 제1 코드워드 벡터 및 제2 코드워드에 기초하여 교차 벡터를 결정할 수 있다. 예를 들어, 링크 모듈은 제1 코드워드 벡터와 제2 코드워드 벡터의 교차점(예컨대, Codeword(A) AND Codeword(B))을 결정하여 교차 벡터를 획득할 수 있다. 일부 구현에서, 교차 벡터는, 링크 스폰 VDAX 및 링크 호스팅 VDAX에 의해 표현되는 각각의 디지털 생태계 멤버들에 할당된 각각의 CNA 객체들에 의해 공통적으로 공유되는 디지털 생태계의 마스터 CNA 객체의 각 각의 부분들에 대한 인덱스들의 서열이다. 이하에서 논의되는 바와 같이, 링크 호스팅 VDAX는 또한, 제1자격증들 및 제2 자격증들에 기초하여 동일한 교차 값을 계산하도록 구성된다. 이러한 방식으로, 링크 호스팅 VDAX와 링크 스폰 VDAX 양쪽 모두는 동일한 교차 벡터를 계산할 수 있고; 교차 벡터는 링크 스폰 VDAX와 링크 호스팅 VDAX의 CNA 객체들 양쪽 모두에 할당된 마스터 CNA 객체의 각각의 부분들을 인 덱싱하기 때문에, 링크 호스팅 VDAX와 링크 스폰 VDAX 양쪽 모두는 그들 각자의 CNA 객체들로부터 CNA 객체의 공통 부분들을 추출할 수 있다. 구현들에서, 링크 스폰 VDAX의 링크 모듈은 교차 벡터에 의해 표시된 CNA 객체의 부분들을 추출하고 이들 부분들을 연결하여 2원 벡터를 획득한다. 일부 구현에서, 이 결과 벡터는 상관관계 벡터 CCNA(A, B)로서 이용될 수 있다. 다른 구현들에서, 결과 벡터는 상관관계 벡터 CCNA(A, B)를 획득하기 위해 하나 이상의 계산 기능을 이용하여 수정될 수 있다. 링크 스폰 VDAX의 링크 모듈은 본 개시내용의 범위를 벗어나지 않고 다른 적절한 방식들로 상관관계 벡터 C(A, B)를 생성할 수 있다는 것을 이해해야 한다. 일부 구현에서, 링크 스폰 VDAX의 링크 모듈은, 링크 스폰 VDAX에 할당된 PNA 객체 및 링크가 스폰되고 있는 커뮤니티 멤버에 대응하는 결합 정보(예컨대, 자격증들 및 링크 호스팅 VDAX의 공개 원시 다항식들)에 기초하여 PNA 기반의 상관관계 벡터 CPNA(A, B)를 결정할 수 있다. PNA 기반의 상관관계 벡터들의 생성의 예들은 아래에서 더 상세히 논의된다. 2412에서, 링크 모듈은 구역 참조 세트를 생성한다. 일부 구현에서, 구역 참조란 LNA 객체의 일부를 나 타내는 값을 지칭할 수 있다. 예를 들어, 구역 참조는 LNA 객체의 일부의 시작 비트 위치를 나타내는 값일 수 있고, 여기서 그 부분은 명시된 비트 크기를 갖는다. 이들 예시적인 구현들에서, 링크 모듈은 M개의 구역 참조를 무작위로 생성할 수 있고, 여기서 각각의 구역 참조는 LNA 객체 내의 구역 수보다 적고 0보다 크거나 같 은 값이다. 2414에서, 링크 모듈은 게놈 상관관계 객체 및 구역 참조들에 기초하여 윈도우를 생성한다. 일부 구현에 서, 링크 스폰 VDAX의 링크 모듈은 M개의 벡터 세트(예컨대, )를 획득하기 위해 M개의 구역 참조에 의해 표시된 LNA 객체로부터 M개의 구역을 추출할 수 있다. 일부 구현에서, 윈도우는 고정 길이의 2원 벡터로서 구조화된다. 이들 구현들 중 일부에서, 링크 모듈은 M개의 벡터를 연결하여 윈도우를 획득 할 수 있다. 일부 구현에서, 링크 모듈은 M개의 벡터를 연결할 수 있고, 그 다음, 연결된 벡터들에 변환 기능을 적용하여 윈도우를 획득할 수 있다. 예를 들어, 이들 구현들 중 일부에서 링크 모듈은 연결된 벡 터들에 역상 저항성 변환 기능을 적용하여 윈도우를 획득할 수 있다. 이들 구현들 중 일부에서, 링크 모듈 은 역상 저항성 변환 기능에 대한 입력으로서 링크 스폰 VDAX 및 링크 호스팅 VDAX 고유의 정보를 포함할 수 있다. 예를 들어, 링크 모듈은 윈도우를 획득하는 역상 저항성 변환 기능에 대한 입력으로서 링크 스폰 VDAX와 링크 호스팅 VDAX의 각각의 자격증들(또는 그로부터 도출된 값들)을 포함할 수 있다. 윈도우는 다른 적절한 방식들로 결정될 수 있다는 것을 이해해야 한다. 2416에서, 링크 모듈은 링크 호스팅 VDAX에 전송될 게놈 조절 명령어들(GRI)을 생성한다. 구현들에 서, 링크 모듈은, 링크 호스팅 VDAX가 링크 스폰 VDAX에 의해 해독가능한 VBLS를 생성할 때 GRI를 이용하도록, 특히 링크 호스팅 VDAX에 대해 생성되는 게놈 조절 명령어들을 생성한다. 일부 구현 에서, GRI는 고정 길이 L(예컨대, 256비트, 512비트 등)의 2원 벡터로서 표현될 수 있다. 일부 구현에서, 링크 모듈은 길이 L의 2원 벡터를 무작위로 생성함으로써 GRI를 생성할 수 있다. 이들 구현들에서, 링크 모듈 은 0보다 크거나 같고 2L보다 작은 무작위 값을 생성할 수 있으며, 여기서 L은 무작위로 생성된 2원 벡터 의 길이이다. 일부 구현에서, GRI를 포함하는 2원 벡터의 다양한 부분들은, 링크 스폰 VDAX에 대한 VBLS를 생성할 때 링크 호스팅 VDAX에 의해, 및 링크 호스팅 VDAX로부터 VBLS를 해독할 때 링크 스폰 VDAX에 의해 이 용되는 명령어들에 맵핑될 수 있다(LS02). GRI에 의해 표시될 수 있는 명령어들의 비제한적인 예들로는, 서열 추출을 위해 공개 또는 비공개 서열을 추출하는 방법(예컨대, 디지털 객체의 어떤 비트들, 얼마나 많은 비트들 을 추출할지, 및/또는 기타 등등)을 나타내는 서열 선택 파라미터들, 다양한 작업을 수행할 때 이용할 계산 기 능들(예컨대, GEF 또는 변환값을 생성할 때 이용할 기능들, 디지털 객체를 변환할 때 이용할 기능들, 게놈 데이 터 객체를 변환할 때 이용할 기능, 및/또는 기타 등등)을 나타내는 구성 파라미터들, 및/또는 입력 파라미터들 (예컨대, 서열 맵핑을 수행할 때 게놈 데이터 객체를 수정하는데 이용되는 값, 보안 수정 파라미터들(SMP), 및/ 또는 기타 등등)이 포함될 수 있다. 일부 구현에서, 어느 한 VDAX의 링크 모듈은, GRI 2원 벡터의 특정한부분들을 추출하고, 각각의 추출된 부분에 대해, (예컨대, 연관 테이블, 인덱스 등을 이용하여) 추출된 부분에 서 정의된 값과 연관된 명령어를 결정하도록 구성될 수 있다. 2418에서, 링크 모듈은 윈도우 및 GRI에 기초하여 서열을 생성한다. 일부 구현에서, 링크 모듈은 윈 도우와 GRI를 결합함으로써 서열을 생성한다. 예를 들어, 링크 모듈은 윈도우 벡터를 GRI 벡터에 연결하 거나 그 반대로 연결하여 서열을 획득될 수 있다. 대안으로서, 링크 모듈은 역상 저항성 기능(또는 임의 의 다른 적절한 계산 단방향 기능)을 GRI와 윈도우의 조합에 적용하여 서열을 획득할 수 있다. 링크 모듈(43 0)은 다른 적절한 방식들로도 윈도우 및 GRI에 기초하여 서열을 결정할 수 있다. 일부 구현에서, 윈도우 및 GRI를 이용하여 생성된 서열은 링크의 무결성을 검증하기 위해 링크 호스팅 VDAX(2404 430)에 의해 이용될 수 있다(아래에서 상세히 논의됨). 2420에서, 링크 모듈은 서열 및 윈도우에 기초하여 변환값을 획득한다. 구현들에서, 링크 모듈은, 윈도우, 서열, 및 LNA 객체를 서열 맵핑 모듈에 제공한다. 서열 맵핑 모듈은, (예컨대, 전술된 바와 같이) 윈도우, 서열 및 LNA 객체에 기초하여 변환값을 결정할 수 있다. 이들 구현들 중 일부에서, 서열 맵핑 모듈은, 윈도우를 처리하여 윈도우의 특정한 부분을 추출하고, 추출된 윈도우의 각각의 부분에 대해, 서열 과 LNA 객체가 주어지면 변환값을 생성하는데 이용되는 연관 명령어를 결정하도록 구성될 수 있다. 위에서 설 명된 서열 맵핑 예들은, GRI, 서열, 및 게놈 분화 객체가 주어질 때 GEF의 생성과 관련하여 설명되었다는 점에 유의한다. 논의된 바와 같이, 이들 다양한 구현들은, 윈도우, 서열 및 LNA 객체가 주어질 때 변환값들을 생성 하도록 개조된다. 2422에서, 링크 모듈은, 서열, GRI, 변환값, 구역 참조들, 및 상관관계 벡터에 기초하여 링크를 생성한다. 이들 구현들에서, 링크 모듈은 변환값을 이용하여 GRI를 변환해 변환된 GRI를 획득할 수 있다. 링크 모듈 은 또한, 상관관계 벡터를 이용하여 구역 참조들을 변환하여 변환된 구역 참조를 획득할 수 있다. 이들 구현들에서, 링크는, 서열(미인코딩), 변환된 구역 참조들, 및 변환된 GRI를 포함한다. 구현들에서, 링크 모듈은 변환값을 이용하여 GRI를 변환한다. 일부 구현에서, 링크 모듈은 암호화 기능을 이용하여 GRI를 변환할 수 있고, 이에 의해 GRI는 변환값을 키로서 이용하여 암호화될 수 있다. 일부 구현에서, 링크 모듈은 명료화 기능을 이용하여 GRI를 변환하고, 이에 의해 GRI는 변환값과 XOR될 수 있다. 이들 구현들 중 일부에서, 링크 모듈은 변환값이 주어질 때 GRI에 관해 변환 기능을 실행하는 변환 모듈에 GRI 및 변환값을 제공할 수 있다. 구현들에서, 링크 모듈은 상관관계 벡터를 이용하여 구역 참조들을 변환한다. 일부 구현에서, 링크 모듈 은 암호화 기능을 이용하여 구역 참조들을 변환할 수 있고, 이에 의해 구역 참조들은 변환값을 키로서 이 용하여 암호화될 수 있다. 일부 구현에서, 링크 모듈은 명료화 기능을 이용하여 구역 참조들을 변환하고, 이에 의해 구역 참조들은 변환값과 XOR될 수 있다. 이들 구현들 중 일부에서, 링크 모듈은, 상관관계 벡 터가 주어지면 구역 참조 벡터에 관해 변환 기능을 실행하는 변환 모듈에 구역 참조 세트를 나타내는 구역 참조 벡터 및 상관관계 벡터를 제공할 수 있다. 2424에서, 링크 스폰 VDAX는, 변환된 구역 참조들, 변환된 링크, 및 서열을 링크 호스팅 VDAX에 제 공한다. 일부 구현에서, 링크 스폰 VDAX는, 변환된 구역 참조들, 변환된 링크, 및 서열을 링크 호스팅 VDAX에 제공하기 위해 별개의 채널들(예컨대, 네트워크들, 통신 매체들, 및/또는 기타 등등)을 이용할 수 있다. 예를 들어, 일부 구현에서, 링크 스폰 VDAX는 제1 채널을 통해(예컨대, LAN을 통해) 변환된 구역 참조들을 제공할 수 있고, 제2 채널을 이용하여(예컨대, 셀룰러 네트워크를 이용하여) 서열 및 변환된 GRI를 제 공할 수 있다. 다른 구현들에서, 링크 스폰 VDAX는, 변환된 구역 참조들, 변환된 링크, 및 서열을 동일 한 채널을 이용하여 링크 호스팅 VDAX에 제공한다. 논의된 바와 같이, 전술된 데이터는 집합적으로 \"게 놈 결합 화물(genomic engagement cargo)\"이라고 지칭될 수 있다. 링크 호스팅 VDAX는 링크 스폰 VDAX에 의해 제공되는 게놈 결합 화물을 수신할 수 있고, 수신된 게 놈 결합 화물에 기초하여 링크 호스팅 프로세스를 실행할 수 있다. 링크 호스팅 프로세스들의 예시적인 구현들 은 아래에서 더 설명된다. 2426으로서, 링크 호스팅 VDAX는 링크 스폰 VDAX로부터 게놈 결합 화물(예컨대, 변환된 구역 참조 들, 변환된 링크, 및 서열)을 수신한다. 위에서 논의된 바와 같이, 변환된 구역 참조들, 변환된 링크, 및 서열 은, 하나 이상의 채널을 통해 수신될 수 있다. 2428에서, 링크 호스팅 VDAX의 링크 모듈은, 링크 호스팅 VDAX와 링크 스폰 VDAX 사이 의 고유한 상관관계를 나타내는 상관관계 벡터를 결정한다. 구현들에서, 링크 모듈은, 상관관계 벡터를 생성하기 위해 링크 스폰 VDAX에 의해 이용된 것과 동일한 방식으로 상관관계 벡터를 생성할 수 있다. 예를 들어, 일부 구현들에서, 링크 모듈은 링크 스폰 VDAX의 제1 자격증들 및 링크 호스팅 VDAX의 제2 자격증들을 획득할 수 있고, 제1 자격증들, 제2 자격증들, 및 링크 호스팅 VDAX의 제2 CNA 객체에 기초하여 상관관계 벡터를 결정할 수 있다. 이들 구현들에서, 상관관계 벡터는, 링크 스폰 VDAX와 링크 호스팅 VDAX 양쪽 모두에 공통적인 마스터 CNA 객체의 부분들을 참조한다. 따라서, 링크 스폰 VDAX와 링크 호스팅 VDAX 양쪽 모두의 링크 모듈은 결합할 자격이 있는 경우(예를 들어, 동일한 디지털 생태계에서 나온 경우) 동일한 상관관계 벡터들을 생성한다. 링크 스폰 VDAX와 관련하여 논의된 바와 같이, 링크 호스팅 VDAX의 링크 모듈은 다른 적절한 방식들로 상관관계 벡터를 생성할 수 있다. 예를 들어, 일부 구현에서 링크 호스팅 VDAX의 링크 모듈 은, 링크 호스팅 VDAX에 할당된 PNA 객체, 링크 호스팅 VDAX에 의해 표현되는 커뮤니티 멤버 에 대응하는 자격증들, 및 링크 스폰 VDAX에 의해 표현되는 커뮤니티 멤버에 대응하는 결합 정보에 기초 하여, 상관관계 벡터 CPNA(B, A)를 결정할 수 있다. 이들 구현들에서, 각각의 VDAX들이 그들 각각의 PNA 객체들 의 비밀 컴포넌트들에 액세스할 수 있는 경우에만, 링크 호스팅 VDAX에 의해 생성된 상관관계 벡터 CPNA(B,A)는, 링크 스폰 VDAX에 의해 생성된 상관관계 벡터 CPNA(A,B)와 정합할 것이다. 다르게 말하면, 유효한 커뮤니티 멤버의 공개 결합 정보를 이용하려는 악의적인 엔티티들은, 커뮤니티 멤버의 PNA 객체의 비밀 컴포넌트들에 액세스하지 않고는 상관관계 벡터들을 재생성할 수 없을 것이다. PNA 기반의 상관관계 벡터들의 생성의 예들은 아래에서 더 상세히 논의된다. 2430에서, 링크 호스팅 VDAX의 링크 모듈은 상관관계 벡터를 이용하여 변환된 구역 참조들을 디코딩 해 구역 참조 세트를 획득한다. 논의된 바와 같이, 링크 스폰 VDAX의 링크 모듈은, 상관관계 벡터 를 변환값으로서 이용하는 변환 기능(예컨대, 암호화 기능 또는 명료화 기능(XOR))를 이용하여 구역 참조 세트 를 변환할 수 있다. 따라서, 링크 호스팅 VDAX의 링크 모듈은 상관관계 벡터를 변환값으로 이용하 여 변환된 구역 참조들을 디코딩할 수 있다. 예를 들어, 변환된 구역 참조들이 상관관계 벡터를 이용하여 링크 스폰 VDAX에 의해 암호화된 구현들에서, 링크 호스팅 VDAX의 링크 모듈은 상관관계 벡터를 이 용하여 변환된 구역 참조들을 해독해 구역 참조 세트를 획득될 수 있다. 변환된 구역 참조들이 명료화 기능을 이용하여 링크 스폰 VDAX에 의해 변환된 구현들에서, 링크 호스팅 VDAX의 링크 모듈은 상관관 계 벡터(예컨대, 변환된 구역 참조들과 상관관계 벡터의 XOR)를 이용하여 변환된 구역 참조들을 명료화해 구역 참조 세트를 획득할 수 있다. 2432에서, 링크 호스팅 VDAX의 링크 모듈은, 게놈 상관관계 객체 및 구역 참조 세트에 기초하여 윈 도우를 생성한다. 일부 구현에서, 링크 호스팅 VDAX의 링크 모듈은 윈도우를 생성하기 위해 링크 스폰 VDAX에 의해 이용된 것과 동일한 기술들을 이용한다. 예를 들어, 일부 구현에서, 링크 호스팅 VDAX의 링크 모듈은 M개의 벡터 세트(예컨대, )를 획득하기 위해 M개의 구역 참조에 의 해 표시된 링크 호스팅 VDAX의 LNA 객체로부터 M개의 구역을 추출할 수 있다. 이들 구현들 중 일부에서, 링크 모듈은 M개의 벡터를 연결하여 윈도우를 획득할 수 있다. 일부 구현에서, 링크 모듈은 M개의 벡터를 연결할 수 있고, 그 다음, 연결된 벡터들에 변환 기능을 적용하여 윈도우를 획득할 수 있다. 예를 들어, 이들 구현들 중 일부에서 링크 모듈은 연결된 벡터들에 역상 저항성 변환 기능을 적용하여 윈도우를 획득할 수 있다. 이들 구현들 중 일부에서, 링크 모듈은, 링크 스폰 VDAX 및 링크 호스팅 VDAX의 각각의 자격증들(또는 그로부터 도출된 값들) 등의, 링크 스폰 코호트 및 링크 호스팅 코호트 고 유의 정보를, 역상 저항성 변환 기능에 대한 입력으로서 포함할 수 있다. 링크 스폰 VDAX와 링크 호스팅 VDAX가 동일하거나 충분히 상관된 LNA 객체들을 가질 때 동일한 윈도우를 생성할 수 있는 한, 윈도우는 다른 적절한 방식들로 결정될 수 있다는 것을 이해해야 한다. 2434에서, 링크 호스팅 VDAX의 링크 모듈은 서열 및 윈도우에 기초하여 변환값을 획득한다. 구현들 에서, 링크 호스팅 VDAX의 링크 모듈은 링크 스폰 VDAX의 링크 모듈에 의해 수행되는 것과 동 일한 동작들에 의해 변환값을 획득한다. 예를 들어, 일부 구현에서, 링크 모듈은, 윈도우, 서열 및 LNA 객체를 서열 맵핑 모듈에 제공하며, 서열 맵핑 모듈은, (예컨대, 전술된 바와 같이) 윈도우, 서열, 및 LNA 객체에 기초하여, 변환값을 결정한다. 2436에서, 링크 모듈은 변환값을 이용하여 변환된 GRI를 디코딩해 GRI를 획득한다. 구현들에서, 링크 호 스팅 VDAX의 링크 모듈은 링크 스폰 VDAX의 링크 모듈에 의해 수행되는 역 동작들을 이 용하여 변환값을 디코딩한다. 논의된 바와 같이, 링크 스폰 VDAX의 링크 모듈은 변환값에 기초하여 변환 기능(예컨대, 해독 기능 또는 명료화 기능(XOR))를 이용해 GRI를 변환할 수 있다. 따라서, 링크 호스팅 VDAX의 링크 모듈은, 2436에서 결정된 변환값을 이용하여 변환된 GRI를 디코딩할 수 있다. 예를 들 어, 변환된 GRI가 암호화 키로서 변환값을 이용하여 링크 스폰 VDAX에 의해 암호화된 구현들에서, 링크 호스팅 VDAX의 링크 모듈은 변환값을 이용하여 변환된 GRI를 해독해 디코딩된 GRI를 획득될 수 있다. 변환된 GRI가 명료화 기능을 이용하여 링크 스폰 VDAX에 의해 변환된 구현들에서, 링크 호스팅 VDAX의 링크 모듈은 변환값(예컨대, 변환된 GRI와 변환의 XOR)을 이용하여 변환된 GRI를 명료화해 디코딩된 GRI를 획득할 수 있다. 2438에서, 링크 호스팅 VDAX의 링크 모듈은, 디코딩된 GRI, 링크 호스팅 VDAX에 의해 생성된 윈도우, 및 링크 스폰 VDAX로부터 수신된 서열에 기초하여 링크의 무결성을 검증한다. 일부 구현에서, 링크 호스팅 VDAX의 링크 모듈은 디코딩된 GRI 및 2438에서 생성된 윈도우에 기초하여 검증 서열을 생성한 다. 검증 서열이 링크 스폰 VDAX에 의해 제공된 서열과 정합하는 경우, 링크 모듈은 링크의 무결성 을 검증한다. 링크 호스팅 VDAX의 링크 모듈은, 링크 스폰 VDAX가 제공된 서열을 생성할 때 실행한 것과 동일한 프로세스를 실행하여 검증 서열을 생성할 수 있다. 일부 예시적인 구현에서, 링크 호스팅 VDAX의 링크 모듈은 검증 서열을 획득하기 위해 디코딩된 GRI와 윈도우를 결합(예컨대, 연결)할 수 있다. 대안으로서, 링크 모듈은 검증 서열을 획득하기 위해 디코딩된 GRI와 윈도우의 조합에 역상 저항성 기능(또는 임의의 다른 적절한 계산 단방향 기능)을 적용할 수 있다. 링크 모듈은, 링크 스폰 VDAX(240 2)와 링크 호스팅 VDAX가 기능적으로 합동인 링크 모듈로 구성된다는 가정하에, 다른 적절한 방식들 로 윈도우 및 디코딩된 GRI에 기초하여 검증 서열을 결정할 수도 있다. 일부 구현에서, 링크 호스팅 VDAX의 링크 모듈은 링크의 무결성을 검증하기 위해 링크 스폰 VDAX에 의해 제공되는 서열과 검증 서열을 비교할 수 있다. 검증 서열과 수신된 서열이 정합하면, 2440 에 도시된 바와 같이, 링크 호스팅 VDAX의 링크 모듈은 링크를 검증하고 디코딩된 GRI(및 임의의 다 른 적절한 링크 정보)를 저장할 수 있다. 일단 링크가 저장되고 호스팅되고 나면, 링크 호스팅 VDAX는 링크 스폰 VDAX를 위해 의도된 VBLS를 생성할 때 디코딩된 GRI를 이용한다. 도 24의 예는 단방향 링크 교환(즉, 링크 스폰 VDAX로부터 링크 호스팅 VDAX로)를 예시한다는 점에 유의한다. 전술된 동작들은 비대칭 방식으로도 수행될 수 있으며, 이에 의해 VDAX들 각각은 다른 VDAX에 대한 각각의 링크를 스폰하고 다른 VDAX로부터의 또 다른 링크를 디코딩한다는 것을 이해해야 한다. 이들 구현들에 서, VDAX들은 구역 참조들 및 GRI들을 독립적으로 생성하므로, 교환된 링크들은 상이할 것이다. 더욱이, 도 24 에 제공된 예시적인 구현들은 예시의 목적으로 제공되며, 링크 교환을 수행하기 위한 다른 기술들이 본 개시내 용의 범위를 벗어나지 않고 나중에 개발될 수도 있다. PNA 기반의 상관관계 벡터들 및 적격성 동기화 논의된 바와 같이, CG-ESP의 일부 구현에서, 링크 모듈은 PNA 객체들에 기초하여 상관관계 벡터들을 생성 하도록 구성될 수 있다. CG-ESP의 일부 구현에서, 생태계 멤버 VDAX들(예컨대, 코호트 VDAX들, 엔클레이브 VDAX들, 생태계 VDAX들 등)의 링크 모듈들은, PNA 및 상대 생태계 멤버들의 공개 결합 정보를 이용하여 PNA 기반의 상관관계 벡터를 생성하도록 구성된다. 도 21과 관련하여 논의된 바와 같이, 각각의 커뮤니티 멤버 의 PNA 객체 PNAi는, 마스터 PNA 객체의 공개 컴포넌트 PNAP, 생태계 멤버의 비밀 비율 , 및 생태계 멤버 의 공개 2진 원시 다항식 를 포함할 수 있다(예컨대, ). 구현들에 서, 생태계 멤버의 결합 정보는 생태계 멤버의 자격증들 및 공개 2진 원시 다항식 를 포함할 수 있다. 생태계 멤버의 VDAX가 상대 생태계 멤버의 결합 정보를 수신하면, VDAX는 생태계 멤버의 자격증들 및 PNA 객체 와 상대 생태계 멤버의 결합 정보에 기초하여 상관관계 벡터를 생성할 수 있다. PNA 기반의 상관관계 벡터들의 생성의 예시적인 구현들이 아래에 제공된다. 설명의 목적을 위해, 제공된 예는 제1 코호트 VDAX(\"코호트 A\"라고 지칭됨)와 제2 코호트 VDAX(\"코호트 B\"라고 지칭됨) 사이의 링크 교환을 설명 한다. 이 예에서, 코호트 A의 PNA 객체는 로서 지정된다. 마찬가지로, 코호트 B의 PNA 객체는 로서 지정된다. 표 8 및 표 9는 PNA 기반의 적격성 동기화를 수행할 때 제1 코호트 VDAX(예컨대, 코호트 A)와 제2 코호트(예컨대, 코호트 B)가 각각 실행하는 예시 적인 프로세스를 나타낸다. [표 8]"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 21, "content": "표 8의 예에서, 코호트 A는 코호트 B에 대응하는 결합 정보를 수신한다. 논의된 바와 같이, 코호트 B의 결합 정보는 코호트 B의 자격증들 및 공개 다항식을 포함할 수 있다. 예를 들어, 코호트 A 또는 코호트 B가 링크 교 환을 시작할 때, 코호트 B는 자격증들과 공개 원시 다항식 를 제공할 수 있다. 대안으로서, 결합 정보 는 생태계 멤버들의 자격증들 및 공개 다항식들을 저장하는 공개 또는 준-공개 데이터 소스로부터 획득될 수 있 다. 코호트 B의 결합 정보를 수신하면, 코호트 A는 코호트 A의 자격증들, 코호트 B의 자격증들, 및 마스터 PNA 객체 의 공개 컴포넌트 PNAP에 기초하여, 코호트 A 대 코호트 B의 공개 비율 를 결정한다. 일부 구현에서 공개 컴포넌트인 PNAP는, 2개의 공개 M차 원시 다항식 및 와, N-1개 쌍의 M비트 값(예컨대, i= 2…N 에 대해 )을 포함하는 공개 객체를 포함한다. 언급한 바와 같이, 마스터 PNA 객체의 공개 컴포넌트인 PNAP를 소유하는 충분히 구성된 VDAX는, 생태계 멤버들의 자격증들과 마스터 PNA 객체의 공개 컴포넌트 PNAP가 주어지면 디지털 생태계의 2개의 멤버의 공개 비율을 결정할 수 있다. 따라서, 코호트 A와 코호트 B의 자격증 들이 주어지면, 코호트 A는 코호트 A와 코호트 B의 각각의 자격증들과 PNAP의 공개 객체에 기초하여 코호트 A 대 코호트 B의 공개 비율 를 결정한다. 언급한 바와 같이, 일부 구현에서, 생태계 멤버의 자격증들은 N- 길이 2원 벡터 등의 고정 길이 데이터 구조로 정의될 수 있다. 예를 들어, N=256일 때 코호트 A와 코호트 B의 자격증들은 각각 및 로서 정의될 수 있다. 구현들에서, 코호트 A 는 원시 다항식 쌍 및 와, 코호트 A 및 코호트 B의 각각의 자격증들의 각각의 개개의 비트 위치 들에서의 각각의 값들(1 또는 0)에 기초하여 공개 객체로부터의 요소들 , i= 2...N을 선택하고 결합하 여 공개 비율 를 획득한다. 표 8의 예에서, 코호트 A는, 코호트 B에 대한 코호트 A의 공개 비율 , 코호트 B의 공개 2진 원시 다항식 , 및 코호트 A의 비밀 비율 에 기초하여, 제1 2진 원시 다항식 P1PNA(A, B)를 결정한다. 도 21 과 관련하여 논의된 바와 같이, 코호트 A의 비밀 비율은 선조 VDAX(예컨대, 생태계 VDAX)에 의해 결정되었으며 코호트 A의 PNA 객체에 포함되었다. 비밀 비율 는 코호트 A에 의해 저장되고, 어떠한 다른 생태계 멤버 와도 공유되지 않는다. 예시적인 구현들에서, 코호트 A는, 제1 선형 연립 방정식을 구성하고, 비밀 비율 , 코호트 B의 공개 2진 원시 다항식 , 및 선형 연립 방정식이 주어질 때 제1 2진 원시 다항식을 결정함으로써 제1 2진 원시 다항식 P1PNA(A, B)를 결정한다. 이들 예시적 구현들에서, 코호트 A는, 제1 2진 원 시 다항식이 M차 다항식이고 제1 2진 원시 다항식과 코호트 B의 공개 2진 원시 다항식 사이의 거리 가 비밀 비율 와 같도록, 제1 2진 원시 다항식을 결정하기 위해 제1 연립 방정식을 푼다. 구현들에서, 제1 2진 원시 다항식 P1PNA(A, B)는 2원 벡터로 표현된다. 제1 2진 원시 다항식 P1PNA(A, B)를 결정하면, 코호트 A는, 제1 2진 원시 다항식 P1PNA(A, B)와 코호트 B에 대한 코호트 A의 공개 비율 에 기초하여 제2 2진 원시 다항식 P2PNA(A, B)를 결정한다. 예시적인 구현들에서, 코호트 A는 제2 연립 선형 방정식을 구성하고, 공개 비율, 제1 2진 원시 다항식 및 제2 연립 선형 방정식이 주 어질 때 제2 2진 원시 다항식을 결정한다. 이들 구현들에서, 코호트 A는, 제2 2진 원시 다항식이 M차 다항식이 고 제2 2진 원시 다항식과 제1 2진 원시 다항식 사이의 거리가 코호트 A의 공개 비율 와 같도록, 연립 선 형 방정식을 풀고 제2 2진 원시 다항식을 결정한다. 구현들에서, 제2 2진 원시 다항식 P2PNA(A, B)는 2원 벡터 로 표현된다. 일부 구현에서, 코호트 A는 제1 원시 다항식 P1PNA(A, B) 및 제2 원시 다항식 P2PNA(A, B)에 기초하여 상관관계 벡터 CPNA(A, B)를 결정한다. 이들 실시예들 중 일부에서, 코호트 A는 제2 다항식의 2진 표현 P2(A, B)를 제1 원시 다항식의 2진 표현 P1(A, B)에 첨부할 수 있다(또는 그 반대). 코호트 A는 또한, 다른 적절한 방식으로 제1 및 제2 원시 다항식들에 기초하여 상관관계 벡터를 결정하도록 구성될 수 있다는 것을 이해해야 한다. 더 욱이, 일부 구현에서, 코호트 A는 링크를 스폰할 때 상관관계 벡터로서 제1 2진 원시 다항식의 비트 벡터 표현 을 이용할 수 있고, 링크를 호스팅할 때 상관관계 벡터로서 제2 2진 원시 다항식의 비트 벡터 표현을 이용할 수 있다. 논의된 바와 같이, 코호트 B는 또한, 링크 교환 동안에 상관관계 벡터를 생성하도록 구성된다. 표 9는 적격성 동기화 프로세스의 한 구현 예를 제공한다. 이들 예시적인 구현에서, 코호트 B는, 아래에서 더 상세히 논의되 는 바와 같이, 코호트 A의 결합 정보, 코호트 B의 자격증들, 코호트 B의 PNA 객체, 및 마스터 PNA 객체의 공개 컴포넌트 PNAP에 기초하여, 상관관계 벡터 CPNA(B, A)를 생성한다.[표 9]"}
{"patent_id": "10-2023-7030113", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 22, "content": "표 9의 예에서, 코호트 B는 코호트 A에 대응하는 결합 정보를 수신한다. 논의된 바와 같이, 코호트 A의 결합 정보는 코호트 A의 자격증들 및 공개 다항식을 포함할 수 있다. 예를 들어, 코호트 B 또는 A가 링크 교환을 시 작할 때, 코호트 A는 자격증들 및 그 공개 원시 다항식 를 제공할 수 있다. 대안으로서, 결합 정보는 생태계 멤버들의 자격증들 및 공개 다항식들을 저장하는 공개 또는 준-공개 데이터 소스로부터 획득될 수 있다. 코호트 A의 결합 정보를 수신하면, 코호트 AB는, 코호트 B의 자격증들, 코호트 A의 자격증들, 및 마스터 PNA 객 체의 공개 컴포넌트 PNAP에 기초하여, 코호트 A에 대한 코호트 B의 공개 비율 를 결정한다. 논의된 바와 같이, 공개 컴포넌트인 PNAP는, 2개의 공개 M차 원시 다항식 및 와, N-1개 쌍의 M비트 값들(예 컨대, i= 2…N에 대해 )을 포함하는 공개 객체를 포함한다. 코호트 A에 관해 논의된 바와 같이, 마스 터 PNA 객체의 공개 컴포넌트인 PNAP를 소유하는 충분히 구성된 VDAX는, 생태계 멤버들의 자격증들과 마스터 PNA 객체의 공개 컴포넌트 PNAP가 주어지면 디지털 생태계의 2개의 멤버의 공개 비율을 결정할 수 있다. 따라 서, 코호트 B와 코호트 A의 자격증들이 주어지면, 코호트 B는 코호트 B와 코호트 A의 각각의 자격증들과 PNAP의 공개 객체에 기초하여 코호트 A에 대한 코호트 B의 공개 비율 를 결정한다. 언급한 바와 같이, 일부 구현 에서, 생태계 멤버의 자격증들은 N-길이 2원 벡터 등의 고정 길이 데이터 구조로 정의될 수 있다(예컨대, N=256 일 때 각각 및 ). 구현들에서, 코호트 B는, 원시 다항식 쌍 및 와, 코호트 B 및 코호트 A의 각각의 자격증들의 각각의 개개의 비트 위치들에서의 각각의 값들(1 또는 0)에 기초하여 공개 객체로부터의 요소들 , i= 2...N을 선택하고 결합하여 공개 비율 를 획득한다. 표 9의 예에서, 코호트 B는, 코호트 A에 대한 코호트 B의 공개 비율 , 코호트 A의 공개 2진 원시 다항식 , 및 코호트 B의 비밀 비율 에 기초하여, 제1 2진 원시 다항식 P1PNA(B, A)를 결정한다. 예시적 인 구현들에서, 코호트 B는, 제1 선형 연립 방정식을 구성하고 비밀 비율 , 코호트 A의 공개 2진 원시 다 항식 , 및 제1 선형 연립 방정식이 주어질 때 제1 2진 원시 다항식을 결정함으로써 제1 원시 다항식P1PNA(B, A)를 결정한다. 이들 예시적 구현들에서, 코호트 B는, 제1 2진 원시 다항식이 M차 다항식이고 제1 2진 원시 다항식과 코호트 A의 공개 2진 원시 다항식 사이의 거리 가 코호트 B의 비밀 비율 와 같도 록, 제1 2진 원시 다항식에 대한 제1 연립 방정식을 푼다. 구현들에서, 제1 2진 원시 다항식 P1PNA(B, A)는 2원 벡터로 표현된다. 제1 2진 원시 다항식 P1PNA(B, A)를 결정하면, 코호트 B는, 제1 2진 원시 다항식 P1PNA(B, A)와 코호트 A에 대한 코호트 B의 공개 비율 에 기초하여 제2 2진 원시 다항식 P2PNA(B, A)를 결정한다. 예시적인 구현들에서, 코호트 B는, 제2 연립 선형 방정식을 구성하고, 공개 비율 , 제1 2진 원시 다항식 P2(B, A), 및 제2 연립 선형 방정식에 기초하여 제2 2진 원시 다항식을 결정한다. 이들 구현들에서, 코호트 B는, 제2 2진 원시 다항식 이 M차 다항식이고 제2 2진 원시 다항식 P2PNA(B, A)와 제1 2진 원시 다항식 P1PNA(B, A) 사이의 거리가 코호트 A 에 대한 코호트 B의 공개 비율 와 같도록, 연립 선형 방정식을 풀어 제2 2진 원시 다항식 P2PNA(B, A)을 결정한다. 구현들에서, 제2 2진 원시 다항식 P2PNA(B, A)는 2원 벡터로 표현된다. 일부 구현에서, 코호트 B는, 제1 원시 다항식의 2진 표현 P1PNA(B, A), 및 제2 원시 다항식의 2진 표현 P2PNA(B, A)에 기초하여 상관관계 벡터 CPNA(B, A)를 결정한다. 일부 구현에서, 코호트 A와 코호트 B가 충분히 상관된 PNA 객체들을 가질 때, 제1 다항식 P1PNA(B, A)는 코호트 A에 의해 생성된 제2 다항식 P2PNA(A, B)와 동일할 것이 라는 점에 유의한다. 유사하게, 코호트 B에 의해 생성된 제2 다항식 P2PNA(B, A)는 코호트 A에 의해 생성된 제1 다항식 P1PNA(A, B)와 동일할 것이다. 따라서, 일부 구현에서, 코호트 B는 제1 원시 다항식의 2진 표현 P1PNA(B, A)을 제2 원시 다항식의 2진 표현 P2PNA(B, A)으로 변환하여 CPNA(B, A)를 획득한다. 이 예에서, CPNA(A,B) = P1PNA(A, B) || P2PNA(A, B)이고 CPNA(B, A) = P2PNA(B, A) || P1PNA(B, A)일 때, CPNA(A,B)는 CPNA(B,A)와 같을 것이다. 이들 예시적인 구현들에서, 링크 호스팅 및 링크 스폰을 위해 코호트들 A와 B가 이용하는 상관관계 벡터들 은 대칭이다. 다른 구현들에서, 코호트 A 및 코호트 B는 링크 스폰 및 링크 호스팅을 위해 비대칭 상관관계 벡 터들을 이용하도록 구성될 수 있다. 예를 들어, 일부 구현에서, 코호트 A는 코호트 B에 대한 링크를 스폰할 때 상관관계 벡터로서 제1 2진 원시 다항식의 2진 표현 P1PNA(A, B)를 이용하고 코호트 B로부터의 링크를 호스팅할 때 상관관계 벡터로서 제2 2진 원시 다항식의 2진 표현 P2PNA(A, B)를 이용하도록 구성될 수 있다. 이들 예시적 구현들에서, 코호트 B는 코호트 A로부터의 링크를 호스팅할 때 상관관계 벡터로서 제2 원시 다항식의 2진 표현 P2PNA(B, A)을 이용하고 코호트 A에 대한 링크를 스폰할 때 상관관계 벡터로서 제1 원시 다항식의 2진 표현 P1PNA(B, A)를 이용하도록 구성될 수 있다. 코호트 B와 코호트 A의 VDAX들이 충분히 구성되고 링크 교환 동안에 그들 자신을 정확하게 표현한다고 가정하면, CPNA(B, A)는 CPNA(A, B)와 정합할 것이다(예컨대, P1PNA(A, B) || P2PNA(A, B) =P2PNA(B, A) || P1PNA(B, A), P1PNA(A, B) = P2PNA(B, A), or P2PNA(A, B) = P1PNA(B, A)). 그러나, 링크 교환 참가자들 중 하나(예컨대, 악의적인 VDAX)가 악의적으로 링크들을 교환하기 위해 코호트의 자격증들 및 공개 다항식을 악의적으로 이용하 려고 시도하는 경우, 악의적인 VDAX는 악의적인 VDAX가 사칭하려고 시도하고 있는 코호트의 비밀 비율에 액세스 할 수 없을 것이다. 따라서, 악의적인 VDAX가 적절하게 구성되고 마스터 PNA 객체의 공개 컴포넌트 PNAP와 악 의적인 VDAX가 사칭하려고 시도하고 있는 코호트의 결합 정보에 액세스할 수 있더라도, 비밀 비율 없이는 악의 적인 VDAX는 상관관계 벡터 CPNA(B, A)를 정확하게 결정할 수 없을 것이다. 앞선 설명은 PNA 기반의 상관관계 벡터들을 생성하기 위한 예시적인 수단을 제공한다. PNA 기반의 상관관계 벡 터들을 생성하기 위한 다른 수단이 향후에 개발되어 링크 교환 프로세스 동안 이용될 수 있다는 것을 이해해야 한다. VBLS 생성 일부 구현에서, CG-ESP는 2개의 생태계 멤버 A와 B (예컨대, 생태계 대 코호트, 엔클레이브 대 코호트, 코호트 대 코호트 및/또는 등) 사이의 고유한 VBLS의 생성 및 디코딩을 용이화하도록 구성된다. 이들 구현들에서, 양 쪽 커뮤니티 멤버들 모두는, 동일한 서열(예컨대, 공개 서열 또는 비공개 서열), 동일한 서열 맵핑 기능, 및 동 일한 GRI를 이용하여, 디지털 객체를 (예컨대, 명료화 및/또는 암호화 기술들을 이용하여) VBLS 객체로 변환하 고 VBLS 객체를 디코딩하여 디지털 객체를 획득하는데 이용되는 게놈 결합 인자(GEF)를 생성한다. 이들 구현들 에서, 결합 VDAX들의 서열 맵핑 기능들은 서열(디지털 객체/VBLS 객체의 메타데이터일 수 있음)을 게놈 분화 객 체(예컨대, 수정되거나 미수정된 XNA 객체 또는 ZNA 객체)에 맵핑하여 GEF를 획득한다. 서열 맵핑 프로세스의 예들은 위에서 설명되어 있다. 도 25는 제1 VDAX를 디코딩할 수 있는 제2 VDAX에 의해 VBLS를 생성하고 제1 VDAX에 의해 VBLS를 디코딩하기 위한 방법에 대한 예시적인 동작 세트를 나타낸다. 이전에 논의된 바와 같이, 일부 구현에 서 VBLS는 디지털 객체들로부터 생성될 수 있다. 디지털 객체들은 가상의 세션 없는 결합들을 용이화하는 Cyphergenics의 초확장성 속성에 의해 인에이블된 세포간 결합 및 디지털 세션 결합의 속성을 입증한다. 본 개 시내용의 일부 구현에 따르면, 디지털 객체들은 정보 이론 촉진형의 게놈 데이터 조성들에 관해 동작하는 계산 기능 세트를 이용하여 VBLS로 변환된다. 일부 구현에서, 디지털 객체들의 상대 엔트로피는 2N으로 강화될 수 있다. 설명의 목적을 위해, 도 25와 관련하여 설명된 예시적인 구현들은 제1 VDAX와 제2 VDAX가 링크들을 교환했다고 가정한다. 예를 들어, 개시된 방법은 한 방향으로의 VBLS 교환을 나타낸다. 이 방향에서, 제2 VDAX 2504(예컨대, 도 24의 링크 호스팅 VDAX)는 링크 교환 동안 제1 VDAX(예컨대, 도 24의 링크 스폰 VDAX)에 의해 제공되는(또는 이에 대응하는) GRI를 이용하여 제1 VDAX에 의해 해독될 수 있는 VBLS를 생성한다. 예시적인 VBLS 생성 구현들은 도 25의 우측에 도시되고 예시적인 VBLS 디코딩 구현들은 도 25의 좌측에 도시된다. 이들 예시적인 프로세스들은 또한, 링크 교환 동안 제2 VDAX에 의해 제1 VDAX에 제공되는 제2 GRI를 이용하여 제1 VDAX가 제2 VDAX에 의해 해독가능한 VBLS를 생성 할 때 적용될 수도 있다는 것을 이해해야 한다. 일부 구현에서, VBLS 생성 프로세스는 제2 VDAX가 제1 VDAX에 대한 VBLS를 생성할 때 수행될 수 있다. 도 25의 예시적인 구현들에서, VBLS 생성 프로세스에 대한 입력은, 일련의 디지털 객체들, 게놈 데이터 객체(예컨대, 수정되거나 미수정된 XNA 객체) 및 GRI일 수 있다. 이들 구현들 중 일부에서, 제2 VDAX는 제1 VDAX에 제공될 일련의 디지털 객체들을 수신할 수 있다. 이들 구현들에서, 제2 VDAX는 제1 VDAX에 의해 제공된 GRI 및 GRI에 대응하는 게놈 분화 객체(예컨대, XNA 객체)를 리트리브할 수 있다. 예를 들어, 게놈 데이터 객체는 제1 VDAX 및 제2 VDAX 양쪽 모두가 멤버를 이루는 엔클레이브 또는 생태계에 대응하는 XNA 객체일 수 있다. 일부 구현에서, 게놈 데이터 객체는, GRI를 이용하여 이전에 수정된, 수정된 게놈 데이터 객체일 수 있다. 대안으로서, 게놈 데이터 객체는 미수정된 게놈 데이터 객체일 수 있다. 도 25의 예시적인 프로세스들은 단일 VBLS 객체의 생성 및 디코딩을 나타낸다는 점에 유의한다. 이해할 수 있 는 바와 같이, 프로세스들은 일련의 디지털 객체들 중의 디지털 객체들 각각에 적용될 수 있다. 2510에서, 제2 VDAX는 디지털 객체로부터 서열을 추출한다. 논의된 바와 같이, 서열은 공개 서열 또는 비공개 서열일 수 있다. 일부 구현에서, 서열은 변환되지 않을 디지털 객체의 일부(\"디지털 객체의 미인코딩된 부분\"이라고 지칭될 수 있음)로부터 추출될 수 있다. 이들 구현들 중 일부에서, 제2 VDAX는 디지털 객체 의 메타데이터로부터 서열을 추출할 수 있다. 예를 들어, 디지털 객체가 페이로드가 암호화될 네트워킹 패킷인 경우, 서열은 패킷 헤더(예컨대, TCP/IP 라우팅 데이터)에서 추출될 수 있다. 또 다른 예에서, 디지털 객체가 MPEG 트랜스포트 스트림 패킷이라면, 서열은 트랜스포트 패킷 헤더로부터 추출될 수 있다. 다른 유형들의 디지 털 객체들에 대해, 서열은 다른 유형들의 디지털 객체들의 다른 적절한 메타데이터로부터 추출될 수 있다는 것 을 이해해야 한다. 앞서 논의된 바와 같이, 서열이 추출되는 방식(예컨대, 메타데이터 내의 비트 위치들, 서열 의 크기, 및/또는 기타 등등)은 디지털 생태계에 대응하는 CG-ESP의 구성에서 정의될 수 있거나 위에서 논의한 바와 같이 GRI에 의해 표시될 수도 있다. 2512에서, 제2 VDAX는 추출된 서열에 기초하여 GEF를 결정한다. 일부 구현에서, 제2 VDAX의 서열 맵핑 모듈은, 추출된 서열, GRI, 및 게놈 분화 객체(예컨대, XNA 객체)를 수신한다. 논의된 바와 같이, 게놈 분화 객체는 수정되거나 수정되지 않을 수 있다. 미수정된 게놈 분화 객체가 서열 맵핑 모듈에 입력되는 구현들에서, 서열 맵핑 모듈은, (예컨대, 도 22와 관련하여 설명된 바와 같이) 서열, 미수정된 게놈 분화 객체, 및 GRI에 기초하여 GEF를 생성할 수 있다. 예를 들어, 이들 구현들 중 일부에서 서열 맵핑 모듈은 서열을 서열 변환 벡터(SCV)로 변환할 수 있고 CSV를 미수정된 게놈 분화 객체에 맵핑하여 맵핑된 게놈 객체를 획득할 수 있다. 그 다음, 서열 맵핑 모듈은 맵핑된 게놈 분화 객체를 수정하여 수정된 게놈 분화 객체를 획득할 수 있다. 이들 구현들에서, 서열 맵핑 모 듈은 (예컨대, 도 22와 관련하여 설명된 바와 같이) 수정된 게놈 분화 객체 및 GRI에 기초하여 GEF를 결정 할 수 있다. 서열 맵핑 모듈은 다른 적절한 방식들에 따라 구성될 수 있다는 것을 이해해야 한다. 예를 들어, 서열 맵핑 모듈은 게놈 분화 객체를 수정한 다음, SCV를 수정된 게놈 분화 객체에 맵핑하여 맵핑된 게놈 분화 객체를 획득할 수 있다. 이들 예시적인 구현들에서, 서열 맵핑 모듈은 맵핑된 게놈 분화 객체 및 GRI에 기초하여 GEF를 결정할 수 있다. 수정된 게놈 분화 객체가 서열 맵핑 모듈에 입력되는 구현들에서, 서열 맵핑 모듈은, (예컨대, 도 23 과 관련하여 설명된 바와 같이) 서열, 수정된 게놈 분화 객체, 및 GRI에 기초하여 GEF를 생성할 수 있다. 이들 구현들 중 일부에서, 서열 맵핑 모듈은 서열을 CSV로 변환할 수 있고 CSV를 수정된 게놈 분화 객체에 맵핑 하여 맵핑된 게놈 분화 객체를 획득할 수 있다. 이들 구현들에서, 서열 맵핑 모듈은 맵핑된 게놈 분화 객 체 및 GRI에 기초하여 GEF를 결정할 수 있다. 이들 구현들에서, 수정된 게놈 분화 객체는 이전에 수정되어 메 모리(예컨대, 지속적인 장기 저장 또는 RAM 등의 일시적 메모리)에 저장되었거나 및/또는 서열 맵핑 모듈 에 입력되기 전에 수정되었을 수 있다는 점에 유의한다. 2514에서, 제2 VDAX는 GEF를 이용하여 디지털 객체를 VBLS 객체로 변환한다. 일부 구현에서, 2진 변환 모듈은 변환될 디지털 객체 및 GEF를 수신하고 이에 기초하여 암호 기반의 기능(예컨대, 암호화 기능 또는 명료화 기능)을 이용해 VBLS 객체를 생성한다. VBLS 객체를 생성하는데 이용되는 기능은 제2 VDAX의 디 폴트 구성에서 정의되거나 GRI에서 표시될 수 있다는 점에 유의한다. 논의된 바와 같이, 결과적인 VBLS 객체는 인코딩된 부분(예컨대, 디지털 객체의 페이로드) 및 미인코딩된 부분(예컨대, 인코딩되지 않은 디지털 객체의 메타데이터)을 포함할 수 있다. 일부 구현에서, 2진 변환 모듈은 GEF를 이용하여 디지털 객체를 VBLS 객체로 변환하는 명료화 모듈을 포함한다. 이들 구현들에서, 명료화 모듈은 인코딩된 디지털 객체를 획득하기 위해 변환될 디지털 객체의 일부와 GEF를 XOR함으로써 GEF에 기초하여 디지털 객체를 변환할 수 있다. 이들 구현들에서, GEF와 XOR되는 디 지털 객체의 부분은 디지털 객체의 페이로드일 수 있다. 구현들에서, 명료화 모듈은 각각의 디지털 객체 에 대해 상이한 GEF를 수신할 수 있는데, 이것은 동일한 게놈 결합 인자가 2개 이상의 디지털 객체를 인코딩하 는데 이용되는 경우 명료화 기술들이 더 효율적인 공격으로 공격가능할 수 있기 때문이다. 일부 구현에서, 2진 변환 모듈은 디지털 객체를 VBLS 객체로 변환하는 암호화 모듈을 포함한다. 이 들 구현들에서, 암호화 모듈은, GEF를 암호화 키로서 이용하여 변환될 디지털 객체의 일부를 암호화함으로 써 GEF에 기초하여 디지털 객체를 변환하는 하나 이상의 암호화 기능으로 구성될 수 있다. 암호화 모듈은, 인코딩된 디지털 객체를 디코딩하는데 이용될 수 있는 대응하는 역암호화 기능(또는 해독 기능)을 갖는 임의의 적절한 대칭 암호화 기능들(예컨대, TDES, AES, Safer+, SAFER++, Twofish 등)으로 구성될 수 있 다. 구현들에서, 암호화 모듈 인스턴스는, 각각의 디지털 객체에 대해 상이한 게놈 결합 인자를 수신하도 록 구성될 수 있거나 2개 이상의 상이한 디지털 객체에 대해 동일한 변환을 이용할 수 있다. 각각의 상응하는 디지털 객체에 대해 상이한 GEF가 생성되는 구현들에서, 결과적으로 인코딩된 디지털 객체들은 무차별 대입 공 격만을 받을 수 있다. 일부 구현에서, 제2 VDAX는 VBLS 객체를 제1 VDAX에 제공하는 무결성 값을 생성할 수 있다. 일부 구현에서, 제2 VDAX는, 2512에서 결정된 GEF를 이용하여 전체 디지털 객체(미인코딩된 부분 포함)를 변환 함으로써 무결성 값을 결정할 수 있다. 이들 구현들에서, 전체 디지털 객체는, 입력으로서 GEF를 수신하는 계 산 기능(예컨대, 암호 기반, 암호 없는, 또는 하이브리드 기능)을 이용하여 변환될 수 있다. 예를 들어, 일부 구현에서 제2 VDAX는 입력으로서 GEF를 수신하는 해시 기능에 디지털 객체를 입력할 수 있다. 이들 구현 들에서, 해시 기능은, 제2 VDAX가 VBLS 객체와 함께 제1 VDAX에 제공할 수 있는 무결성 값을 출력 한다. 2516에서, 제2 VDAX는 VBLS 객체를 제1 VDAX에 제공하고 제1 VDAX는 디지털 객체를 수신한 다. 제2 VDAX는 임의의 적절한 매체를 통해 VBLS 객체를 제1 VDAX에 제공할 수 있다. 제1 VDAX는 제2 VDAX에 의해 생성된 일련의 VBLS 객체들 중에서 VBLS 객체를 수신한다. 이들 구현들에 서, 제1 VDAX는 제2 VDAX에 제공한 GRI 및 GRI에 대응하는 게놈 분화 객체(예컨대, XNA 객체)를 리트리브할 수 있다. 예를 들어, 게놈 분화 객체는 제1 VDAX 및 제2 VDAX 양쪽 모두가 멤버를 이 루는 엔클레이브 또는 생태계에 대응하는 XNA 객체일 수 있다.2518에서, 제1 VDAX는 VBLS 객체의 미인코딩된 부분으로부터 서열을 추출한다. 논의된 바와 같이, 서열 은 공개 서열 또는 비공개 서열일 수 있다. 일부 구현에서, 서열은 VBLS 객체의 미인코딩된 부분에서 추출될 수 있어, 그 안에 포함된 메타데이터는 원래의 디지털 객체에 있었던 것과 동일한 메타데이터일 수 있다. 이들 구현들 중 일부에서, 제1 VDAX는 VBLS 객체의 메타데이터로부터 서열을 추출할 수 있다. 예를 들어, VBLS 객체가, VBLS 객체의 인코딩된 부분이 인코딩된 페이로드를 포함하는 네트워킹 패킷인 경우, 서열은 패킷 헤더(예컨대, TCP/IP 라우팅 데이터)로부터 추출될 수 있다. 또 다른 예에서, 디지털 객체가 MPEG 트랜스포트 스트림 패킷이라면, 서열은 트랜스포트 패킷 헤더로부터 추출될 수 있다. 다른 유형들의 디지털 객체들에 대해, 서열은 다른 유형들의 디지털 객체들의 다른 적절한 메타데이터로부터 추출될 수 있다는 것을 이해해야 한다. 앞서 논의된 바와 같이, 서열이 추출되는 방식(예컨대, 메타데이터 내의 비트 위치들, 서열의 크기, 및/ 또는 기타 등등)은 디지털 생태계에 대응하는 CG-ESP의 구성에서 정의될 수 있거나 위에서 논의한 바와 같이 GRI에 의해 표시될 수도 있다. 2520에서, 제1 VDAX는, 추출된 서열, 게놈 분화 객체, 및 제1 VDAX에 의해 제2 VDAX에 제공 된 GRI에 기초하여 GEF를 생성한다. 일부 구현에서, 제1 VDAX의 서열 맵핑 모듈은, 추출된 서열, GRI 및 게놈 분화 객체(예컨대, XNA 객체)를 수신하고, 이에 기초하여 GEF를 결정한다. VBLS 객체를 성공적으 로 디코딩하기 위하여, 제1 VDAX의 서열 맵핑 모듈은 제2 VDAX의 서열 맵핑 모듈과 동 일한 입력(예컨대, 서열, 게놈 분화 객체, 및 GRI)을 이용하여 기능적으로 균등한 서열 맵핑 프로세스를 수행해 야 한다는 점에 유의한다. 미수정된 게놈 분화 객체가 서열 맵핑 모듈에 입력되는 구현들에서, 서열 맵핑 모듈은, (예컨대, 도 22와 관련하여 설명된 바와 같이) 서열, 미수정된 게놈 분화 객체, 및 GRI에 기초하여 GEF를 생성할 수 있다. 제2 VSDAX와 관련하여 논의된 바와 같이, 서열 맵핑 모듈은 서열을 서열 변환 벡터(SCV)로 변환할 수 있고 CSV를 미수정된 게놈 분화 객체에 맵핑하여 맵핑된 게놈 객체를 획득할 수 있다. 그 다음, 서열 맵핑 모듈 은 맵핑된 게놈 분화 객체를 수정하여 수정된 게놈 분화 객체를 획득할 수 있다. 이들 구현들에서, 서열 맵핑 모듈은 수정된 게놈 분화 객체 및 GRI에 기초하여 GEF를 결정할 수 있다. 서열 맵핑 모듈은 다 른 적절한 방식들에 따라 구성될 수 있다는 것을 이해해야 한다. 예를 들어, 서열 맵핑 모듈은 게놈 분화 객체를 수정한 다음, 서열을 수정된 게놈 분화 객체에 맵핑하여 맵핑된 게놈 분화 객체를 획득할 수 있다. 이 들 예시적인 구현들에서, 서열 맵핑 모듈은 맵핑된 게놈 분화 객체 및 GRI에 기초하여 GEF를 결정할 수 있 다. 수정된 게놈 분화 객체가 서열 맵핑 모듈에 입력되는 구현들에서, 서열 맵핑 모듈은, (예컨대, 도 23 과 관련하여 설명된 바와 같이) 서열, 수정된 게놈 분화 객체, 및 GRI에 기초하여 GEF를 생성할 수 있다. 이들 구현들 중 일부에서, 서열 맵핑 모듈은 서열을 CSV로 변환할 수 있고 CSV를 수정된 게놈 분화 객체에 맵핑 하여 맵핑된 게놈 분화 객체를 획득할 수 있다. 이들 구현들에서, 서열 맵핑 모듈은 맵핑된 게놈 분화 객 체 및 GRI에 기초하여 GEF를 결정할 수 있다. 이들 구현들에서, 수정된 게놈 분화 객체는 이전에 수정되어 메 모리(예컨대, 지속적인 장기 저장 또는 RAM 등의 일시적 메모리)에 저장되었거나 및/또는 서열 맵핑 모듈 에 입력되기 전에 수정되었을 수 있다는 점에 유의한다. 수정된 게놈 분화 객체는 제2 VDAX의 수정된 게 놈 분화 객체와 동일한 방식으로(예컨대, GRI에 의해 정의된 대로) 수정되어야 한다는 점에 유의한다. 2522에서, 제1 VDAX는 GEF를 이용하여 VBLS 객체의 변환된 부분을 디코딩하여 디지털 객체의 디코딩된 부 분을 획득한다. 일부 구현에서, 2진 변환 모듈은 디코딩된 디지털 객체를 획득하기 위해 입력으로서 GEF 를 이용하여 VBLS 객체의 인코딩된 부분에 역변환을 수행한다. 역변환 기능은 디지털 객체를 인코딩하기 위해 제2 VDAX에 의해 이용되는 변환 기능의 역기능이라는 점에 유의한다. 일부 구현에서, 제1 VDAX의 2진 변환 모듈은, 2520에서 결정된 GEF에 기초하여 VBLS 객체를 디코딩 된 디지털 객체로 변환하는 명료화 모듈을 포함한다. 구현들에서, 명료화 모듈은 역 명료화 기능 및 GEF를 이용하여 디지털 객체의 인코딩된 부분을 디코딩하도록 구성될 수 있다. 구현들에서, 역 명료화 기능은 GEF와 VBLS 객체의 인코딩된 부분을 XOR하는 것을 포함할 수 있다. 이들 구현들에서, XOR 동작은, 디지털 객체 의 인코딩된 부분을 변환하는데 이용된 GEF가 제1 VDAX의 서열 맵핑 모듈에 의해 결정된 GEF와 정합 한다고 가정하여, 디코딩된 디지털 객체를 생성한다. 일부 구현에서, 2진 변환 모듈은, GEF에 기초하여 VBLS 객체를 디코딩된 디지털 객체로 변환하는 암호화 모듈을 포함한다. 구현들에서, 암호화 모듈 인스턴스는, 역암호화 기능 및 2520에서 결정된 GEF를 이용하여 디지털 객체의 인코딩된 부분을 디코딩하도록 구성될 수 있다. 2520에서 결정된 GEF가 디지털 객체를암호화하는데 이용된 GEF와 정합한다고 가정하면, 역 암호화 기능은 GEF를 키로서 이용하여 디지털 객체의 인코 딩된 부분을 해독해 디코딩된 디지털 객체를 획득한다. 2524에서, 제2 VDAX는 무결성 값에 기초하여 VBLS 객체의 무결성을 확인한다. 일부 구현에서, 제2 VDAX는 무결성 값을 VBLS 객체에 포함할 수 있다. 논의된 바와 같이, 일부 구현에서, 제2 VDAX는 VBLS 객체의 인코딩된 부분을 인코딩하는데 이용된 GEF를 이용하여 전체 디지털 객체(미인코딩된 부분 포함)를 변환함으로써 무결성 값을 결정할 수 있다. 이들 구현들에서, 전체 디지털 객체는, 입력으로서 GEF를 수신하는 계산 기능(예컨대, 암호 기반, 암호 없는, 또는 하이브리드 기능)을 이용하여 변환될 수 있다. VBLS 객체를 디 코딩된 디지털 객체로 디코딩할 때, 제1 VDAX는 무결성 값을 획득하기 위해 입력으로서 2518에서 결정된 GEF 및 동일한 계산 기능을 이용하여 디코딩된 디지털 객체를 변환할 수 있다. 생성된 무결성 값이 VBLS 객체 와 함께 제공된 무결성 값과 정합하면, 제1 VDAX는, 2526에 도시된 바와 같이, 디코딩된 디지털 객체의 무결성을 검증하고 디코딩된 디지털 객체를 출력할 수 있다. 전술된 프로세스들은 예를 위해 제공된 것이다. VBLS를 생성하고 디코딩하기 위한 다른 프로세스들이 본 개시 내용의 범위를 벗어나지 않고 본 개시내용에 따라 개발될 수 있다는 것을 이해해야 한다. CG 지원형 처리 환경들 도 26 및 도 27은 예시적인 임시 아키텍쳐에서 구현될 수 있는 CG 지원형 처리 환경들의 예들을 나타낸다. 도 26은 가상의 신뢰받는 실행 도메인들을 가능케하는 CG 지원형 처리 환경의 한 예를 나타내며, 이에 의해, CG 지 원형 처리 환경은, VBLS-인코딩된 2진 명령어들을 나중에 처리 환경의 처리 코어들에 의해 실행될 수 있 는 실행가능한 2진 명령어들로 디코딩하거나 및/또는 2진 명령어들을 나중의 디코딩 및 실행을 위 해 메모리에 저장되는 VBLS-인코딩된 2진 명령어들로 인코딩하도록 구성된다. 설명의 목적을 위해, 도 26은 CG 지원형 명령어 경로를 보여주는 것으로서 설명될 수 있다. 도 27은, VBLS-인코딩된 데이터를 처리 코 어에 입력되는 디코딩된 데이터로 디코딩하거나 및/또는 처리 코어에 의해 출력된 출력 데이터를 VBLS-인코딩된 데이터로 인코딩하도록 구성된 예시적인 VDAX를 나타낸다. 설명의 목적을 위해, 도 27은 CG 지 원형 명령어 경로를 보여주는 것으로서 설명될 수 있다. 일부 구현에서, 도 26 및/또는 도 27의 VDAX는 하드웨어 기반의 VDAX(예컨대, CG 지원형 처리 코어, 필드 프로 그래머블 게이트 어레이, 마이크로프로세서 등)이다. 하드웨어 기반의 VDAX는 개선된 보안 피처들을 제공할 수 있지만, 도 26 및/또는 도 27의 VDAX는, 처리 디바이스에 의해 실행되는 소프트웨어 기반의 VDAX로서, 또는 하 드웨어와 소프트웨어 요소들로 구성된 하이브리드 VDAX로서 구현될 수도 있다. 일부 구현에서, 실행가능한 명 령어 컴포넌트들(EIC) VDAX라는 용어는, VBLS-인코딩된 명령어 세트 및/또는 VBLS-인코딩된 프로그램 데이터를 인코딩 및 디코딩하는 CG-ESP로 구성된 하드웨어 기반의 VDAX를 지칭할 수 있다. 일부 실시예에서, 도 26 및 도 27의 예시적인 VDAX는 동일한 VDAX일 수 있고, 여기서 VDAX는 명령어 세트들 및 데이터 양쪽 모두를 인코딩 및/또는 디코딩한다. 대안으로서, 일부 실시예에서, 하드웨어 기반의 EIC VDAX는 명령어 인코딩/디코딩을 수행 하는 반면, 소프트웨어 또는 하이브리드 기반의 VDAX는 데이터 인코딩/디코딩을 수행한다(또는 그 반대). 도 26 및 도 27의 예에서, 인코딩 및/또는 디코딩되고 있는 디지털 객체들은 실행가능한 명령어들 및/또는 프로 그램 데이터이다. 서열 맵핑과 관련하여 배치될 수 있는 전략들은, 처리 시스템의 유형, 디바이스의 운영 체제, 설계 선택사항들 및 절충들(예컨대, 더 높은 레벨의 보안 대 더 효율적인 실행) 등에 따라 달라질 수 있 다. 설계 선택사항들 및 대응하는 절충들과 관련하여, 각각의 상응하는 명령어 또는 프로그램 데이터의 인스턴 스에 대해 고유한 GEF를 생성하는 것은 개선된 보안 피처들을 제공할 수 있지만, 각각의 상응하는 명령어에 대 한 GEF를 결정해야 하는 결과로 실행 환경의 성능을 감소시킬 수 있다. 이들 구현들에서, 각각의 디지털 객체 (예컨대, 단일 명령어들 또는 프로그램 데이터의 인스턴스들)를 인코딩/디코딩하는데 이용되는 각각의 GEF들은 디지털 객체에 고유하게 대응하는 메타데이터로부터 추출된 각각의 서열들에 기초하여 생성된다. 다른 구현들 에서, 디지털 객체의 각각의 묶음들(예컨대, 컴퓨터 프로그램의 명령어 그룹들 또는 프로그램 데이터의 그룹)은 각각의 GEF들을 이용하여 인코딩되되, 제1 묶음에 대응하는 메타데이터로부터 추출된 제1 서열이 제1 묶음의 디 지털 객체들을 인코딩/디코딩하는데 이용되는 제1 GEF를 생성하는데 이용될 수 있는 반면, 제2 묶음에 대응하는 메타데이터로부터 추출된 제2 서열은 제2 묶음의 디지털 객체를 인코딩/디코딩하는데 이용되는 제2 GEF를 생성 하는데 이용되도록 한다. 다른 구현들에서, 단일 GEF는 명령어들 및/또는 프로그램 데이터를 인코딩/디코딩하 는데 이용될 수 있고, 이에 의해 단일 GEF는 컴퓨터 프로그램과 연관된 메타데이터로부터 추출된 서열에 기초하 여 생성된다. 이들 구현들에서, 서열 맵핑 동작들의 수가 크게 감소되지만, 그 댓가로 보안 레벨이 감소된다. 이해할 수 있는 바와 같이, 서열 맵핑을 위해 서열이 추출되는 메타데이터는, GEF를 생성하는데 이용되는 메타데이터의 유형, 이용가능한 메타데이터의 유형, 처리 환경의 원하는 보안 레벨들 등에 기초하여 달라질 수 있다. 컴퓨터 프로그램의 하나 이상의 명령어 세트를 디코딩할 때 서열이 추출될 수 있는 메타데이터의 비제한 적인 예들로는, 파일시스템 메타데이터, RAM 메타데이터, OS-애플리케이션 특유의 메타데이터, 실행가능한 애플 리케이션 특유의 메타데이터 및/또는 기타 등등이 포함될 수 있다. RAM 메타데이터의 비제한적인 예들로는, 물 리적 주소, 논리적 주소, 가상 주소, 메모리 페이지, 페이지 테이블, 및/또는 기타 등등의, 디지털 객체 또는 디지털 객체 세트의 메모리 위치일 수 있다. 파일시스템 메타데이터의 비제한적인 예들로는, 프로그램의 파일 경로, 프로그램에 대응하는 inode, 명령어 세트들이 HDD 또는 SSD에 저장되는 위치들을 나타내는 FAT32 또는 FAT16 테이블 컴포넌트들, 명령어 세트들이 HDD 또는 SSD에 저장되는 위치들을 나타내는 NTFS 테이블 컴포넌트 들, 명령어 또는 명령어 세트가 저장되는 하드 디스크 파티션, 명령어 또는 명령어 세트가 저장되는 하드 디스 크 클러스터, 및/또는 기타 등등이 포함된다. OS-애플리케이션 특유의 메타데이터의 비제한적인 예들로는, 프 로세스 제어 메타데이터, 스레드 제어 데이터, 및/또는 기타 등등이 포함될 수 있다. 애플리케이션 특유의 메 타데이터로는, 오브젝트 파일 메타데이터, ELF(executable and link) 메타데이터, ELF 세그먼트들, COFF(common object format file) 메타데이터, COFF 세그먼트들, 세그먼트, 세그먼트 오프셋, 코드 세그먼트, 코드 세그먼트 오프셋, 데이터 세그먼트, 데이터 세그먼트 오프셋, BSS(block starting symbol), BSS 오프셋, 힙 세그먼트, 힙 세그먼트 오프셋, 스택 세그먼트, 스택 세그먼트 오프셋, 및/또는 기타 등등이 포함될 수 있다. 도 26의 예시적인 구현들에서, CG 지원형 처리 환경은, 실행가능한 2진 명령어들로 구현된 컴퓨터 프로그 램 명령어 세트들(예컨대, 소프트웨어 애플리케이션들, 미들웨어 애플리케이션들, 디바이스 드라이버들, 운영 체제/커널 코드, 및/또는 기타 등등의 명령어 세트들)을 실행하는 처리 코어 세트를 포함할 수 있다. 컴 퓨터 프로그램은 명령어들이 컴퓨터(예컨대, 데스크탑 컴퓨터, 서버 컴퓨터, 모바일 디바이스 등)에 의해 실행 될 것을 요구하지 않는다는 점에 유의한다. 컴퓨터 프로그램으로는, 서버 컴퓨터, 데스크탑 컴퓨터, 모바일 디 바이스, 게임 디바이스, 스마트 기기, 로봇 또는 기타 자율 디바이스, IoT 디바이스, 라우팅 또는 기타의 네트 워킹 디바이스, 및/또는 기타 등등을 포함한 그러나 이것으로 제한되지 않는 임의의 유형의 디바이스에 의해 실 행되는 프로그램들, 루틴들, 애플리케이션들 등이 포함될 수 있다는 것을 이해해야 한다. 처리 환경의 처리 코 어로는, 범용 처리 코어들, 특별 목적 처리 코어들(예컨대, 그래픽 처리 코어들, 인공 지능 처리 코어, 및/또는 기타 등등), 또는 실행가능한 명령어들을 실행할 수 있는 기타의 적절한 처리 디바이스들(FPGA(Field Programmable Gate Array)들, 마이크로프로세서들 등)이 포함될 수 있다. 일부 예시적인 실시예에서, 각각의 컴퓨터 프로그램 명령어 세트는 각각의 VBLS 인코딩된 명령어들로서 저장된다. 예를 들어, 일부 구현에서, 각각의 컴퓨터 프로그램 명령어 세트는 각각의 비반복적 \"언어\"로 인코 딩될 수 있으며, 이에 의해 각각의 컴퓨터 프로그램 명령어 세트는 특정한 게놈 데이터 세트 및 특정한 GRI를 이용하여 인코딩된다. 이들 구현들 중 일부에서, 상이한 컴퓨터 프로그램 명령어 세트들을 인코딩 하는데 이용되는 게놈 데이터 세트들은 상이한 GRI를 이용하는 동일한 게놈 데이터 세트들일 수 있되, 각각의 GRI가 각자의 컴퓨터 프로그램(예컨대, 제1 컴퓨터 프로그램에 대한 제1 GRI(2614-1), 제2 GRI(2614-2), ... 제N 컴퓨터 프로그램에 대한 제N GRI(2614-N))에 대응하게 한다. 일부 구현에서, 상이 한 컴퓨터 프로그램 명령어 세트들은 상이한 게놈 데이터 세트들 및 상이한 GRI를 이용하여 인코딩 될 수 있다. 예를 들어, 각각의 컴퓨터 프로그램은 그 명령어 세트들을 디코딩 및/또는 인코딩하는데 이용되는 그 자신의 게놈 데이터 세트를 할당받을 수 있다(예컨대, 제1 컴퓨터 프로그램에 대한 제1 게놈 데이터 세트(2612-1), 제2 게놈 데이터 세트(2612-2) … 제N 컴퓨터 프로그램에 대한 제N 게놈 데이터 세트(2612-N)). 일부 실시예에서, 컴퓨터 프로그램들의 상이한 그룹들은 각각의 게놈 데이터 세트들을 할당받을 수 있다. 예를 들어, 수트 또는 컬렉션의 일부이거나 및/또는 동일한 조직에 의해 제공되는 컴퓨터 프로그램 그룹은 동일 한 게놈 데이터 세트를 할당받을 수 있다. 이 예에서, 각각의 컴퓨터 프로그램들은 동일한 GRI 또 는 상이한 GRI를 이용하여 인코딩 및 디코딩될 수 있다. 커뮤니티 소유자(예컨대, 칩 제공자, 운영자 시 스템 제공자, 펌웨어 제공자 등)는 이들 방식들 중 임의의 방식으로 CG 지원형 처리 환경을 구성할 수 있다는 것을 이해해야 한다. 컴퓨터 프로그램 명령어 세트는 초기에 임의의 적절한 방식으로 VBLS로 인코딩될 수 있다. 예를 들어, 일부 실 시예에서, 컴퓨터 프로그램 명령어 세트는 실행가능한 포맷으로 초기에 수신되어, 컴퓨터 프로그램 명령어 세트 가 초기에는 인코딩되지 않게 한다. 이 예에서, EIC VDAX는 설치 프로세스 동안 컴퓨터 프로그램에 게놈 데이터(예컨대, XNA)를 할당할 수 있고 컴퓨터 프로그램 명령어 세트를 인코딩하기 위한 GRI를 생성할 수 있다. 그 다음, EIC VDAX는 컴퓨터 프로그램에 할당된 게놈 데이터 세트 및 대응하는 GRI에 기초하여 컴퓨터 프로그램 명령어 세트 내의 각각의 명령어를 각각의 VBLS-인코딩된 명령어로 인코딩할 수 있다. VBLS-인코딩된 명령어들은 나중의 실행을 위해 메모리에 저장될 수 있다. 이해할 수 있는 바와 같이, \"메모리\"는, 판독 전용 메모리(ROM), 랜덤 액세스 메모리(RAM), 캐시, RAM, 하드 디스크 드 라이브(HDD), 솔리드 스테이트 드라이브(SDD), 등 중에서 하나 이상을 지칭할 수 있다. 다른 예시적인 실시예들에서, 컴퓨터 프로그램은 VBLS-인코딩된 포맷으로 프로그램 제공자에 의해(예를 들어 다 운로드를 통해 또는 CD, DVD, 착탈식 플래시 메모리 드라이브 등의 컴퓨터 판독가능한 매체를 통해) 제공될 수 있다. 일부 예시적인 구현에서, 프로그램 제공자는 또한, 명령어들을 디코딩하기 위해 필수 게놈 데이터 및 GRI를 제공할 수 있다. 일부 구현에서, 프로그램 제공자와 컴퓨터 프로그램이 설치되는 디바 이스를 나타내는 VDAX(예컨대, EIC VDAX 또는 더 높은 레벨의 소프트웨어 기반의 또는 하이브리드 VDAX) 는 링크 교환 프로세스를 수행할 수 있어서, VDAX가 프로그램 제공자에게 GRI를 제공하고, 프로그램 제공 자를 나타내는 VDAX가 컴퓨터 프로그램 명령어 세트를 인코딩하는데 이용하게 할 수 있다. 이들 예시적인 실시 예들 중 일부에서, 인코딩된 명령어들은 메모리에 저장되어, EIC VDAX가 컴퓨터 프로그램에 대응하는 게놈 데이터 및 GRI를 이용하여 런타임에 VBLS-인코딩된 2진 명령어들을 디코딩할 수 있게 할 수 있다. 일부 구현에서, EIC VDAX는 제1 세트의 게놈 데이터(2612-1) 및 제1 GRI(2614- 1)를 이용하여 전체 VBLS-인코딩된 컴퓨터 프로그램 명령어 세트를 디코딩한 다음, 컴퓨터 프로그램 명령어를 재인코딩할 수 있다. 이들 구현들에서, EIC VDAX는 제2 게놈 데이터(2612-2) 및/또는 제2 GRI(2614- 2)를 이용하여 컴퓨터 프로그램 명령어 세트를 인코딩하거나 및/또는 상이한 구성을 이용하여 CG 기반의 인코딩 을 수행할 수 있다. 예를 들어, EIC VDAX는 컴퓨터 프로그램 명령어 세트를 재인코딩하기 위해 상이한 서열 맵핑 기술 및/또는 2진 변환 기술을 이용할 수 있다. 이들 구현들에서, EIC VDAX는 이들 서열 맵핑 및/또는 2진 변환 기술들, 상이한 게놈 데이터(2612-2) 및/또는 제2 GRI(2614-2)를 이용하여 런타임시에 VBLS- 인코딩된 명령어들을 디코딩한다. 이러한 방식으로, 프로그램 제공자라도 VBLS-인코딩된 명령어들을 복 제할 수 없을 것이다. 예시적인 실시예들에서, EIC VDAX는 메모리로부터 컴퓨터 프로그램의 VBLS-인코딩된 2진 명령어들 을 판독하고 인코딩된 2진 명령어들을 디코딩하여 컴퓨터 프로그램에 할당된 게놈 데이터 세트 및 이전에 명령어들을 인코딩하는데 이용된 GRI에 기초하여 실행가능한 2진 명령어들(260 8)를 획득하도록 구성될 수 있다. 일부 구현에서, 디코딩된 실행가능한 2진 명령어들은 CPU의 하나 이상 의 처리 코어에 출력된다. 일부 구현에서, 하나 이상의 처리 코어는 디코딩된 2진 명령어들을 수 신하고 2진 명령어들을 실행한다. 실행된 명령어들로 인해 출력 데이터가 생성되는 경우, 출력 데 이터는 VBLS-인코딩된 데이터로 인코딩될 수도 있다(예컨대, 도 27 참조). 인코딩 출력 데이터 는, 운영 체제 레벨 및/또는 애플리케이션 레벨 등의, 상이한 레벨에서 수행될 수 있다. 예를 들어, 출 력 데이터는, 상이한 게놈 데이터 세트 및 GRI를 이용하여 운영 체제에 의해 VBLS-인코딩된 데이터(270 6)로 인코딩될 수 있고 결과적인 VBLS-인코딩된 데이터는 메모리에 기입될 수 있다. 추가적으로 또는 대안으로서, EIC VDAX는 출력 데이터를 VBLS-인코딩된 데이터로 인코딩하도록 구성될 수 있다. 실시예들에서, EIC VDAX는 2진 명령어 세트들의 CG 기반의 디코딩 및/또는 인코딩을 수행하는 전용 처리 코어로서 구현될 수 있다. 추가적으로 또는 대안으로서, EIC VDAX는, 필드 프로그래머블 게이트 어레이, 전문화된 칩, 및/또는 일반 처리 코어로서 구현될 수 있다. 도시된 예에서, EIC VDAX는, EIC 모듈, 서열 맵핑 모듈, 및 2진 변환 모듈을 포함할 수 있다. 앞서 논의된 바와 같이, EIC 모듈은, EIC VDAX가 VLBS를 디코딩하거나, VBLS를 인코딩 하거나, 및/또는 가상의 신뢰받는 실행 도메인의 게놈 토폴로지를 제어할 수 있게 하는 각각의 게놈 데이터 세 트들에 관한 게놈 동작들(예컨대, ZNA 생성 및/또는 수정)을 수행할 수 있다. 실시예들에서, 서열 맵핑 모듈은, 게놈 결합 인자(GEF)를 획득하기 위해 특정한 게놈 데이터(예컨대, 수정되거나 미수정된 DNA), 특정한 GRI, 및 획득된 서열을 이용하여, EIC VDAX를 대신하여 서열을 획득하고 서열 맵핑 동작들을 수행 한다. 실시예들에서, 2진 변환 모듈은 서열 맵핑 모듈에 의해 획득된 게놈 결합 인자들에 기초하 여 VBLS-인코딩된 2진 명령어들을 디코딩한다. 예를 들어, 각각의 명령어들(또는 명령어 세트)은 상이한 게놈 결합 인자를 이용하여 디코딩될 수 있다. 더욱이, 일부 실시예에서, 2진 변환 모듈은 게놈 결합 인자 및 계산 기능 세트를 이용하여 미인코딩된 2진 명령어들을 VBLS-인코딩된 명령어들로 인코딩하여, 결과적인 VBLS- 인코딩된 명령어들이 향후의 디코딩 및 실행을 위해 메모리에 저장될 수 있게 할 수 있다. 일부 구현에서, EIC VDAX는 그 구성에 따라 추가적인 또는 대안적인 모듈들을 포함할 수 있다. 예를 들 어, 일부 구현에서 EIC VDAX는, 처리 디바이스가 서비스하는 디바이스에 새로운 프로그램이 다운로드 및/또는 설치될 때 처리 디바이스를 대신하여 링크 교환을 수행하는 링크 모듈(미도시)을 포함할 수 있다. 추가적 으로 또는 대안으로서, EIC VDAX는 컴퓨터 프로그램 명령어 세트를 디바이스에 설치되기 전에 검증하도록 구성된 마스터 무결성 모듈을 포함할 수 있다. EIC VDAX는 본 개시내용의 범위를 벗어나지 않고 추가적 인 또는 대안적인 모듈을 포함할 수 있다. 도 26에 도시된 예시적인 실시예들에서, EIC VDAX는 제1 컴퓨터 프로그램의 제1 컴퓨터 프로그램 명령어 세트(2606-1) 및 제2 컴퓨터 프로그램의 제2 컴퓨터 프로그램 명령어 세트(2606-2)를 디코딩하고 있다. 예시된 예에서, EIC 모듈은 디코딩될 제1 컴퓨터 프로그램 명령어 세트에 대응하는 제1 게놈 객체 및 제1 GRI를 인출하거나 기타의 방식으로 획득하도록 구성된다. 언급한 바와 같이, 예시 구현에서의 게놈 객체들은 ZNA 객 체들일 수 있다. 예시된 예에서, EIC 모듈은 제1 수정된 ZNA를 획득하기 위해 계산 기능 세트를 이용하 여 제1 GRI에 기초해 제1 ZNA 객체를 수정한다. 마찬가지로, EIC 모듈은 제2 GRI에 기초하여 제2 ZNA 객 체를 수정해 제2 수정된 ZNA를 획득할 수 있다. 일부 실시예에서, EIC 모듈은 수정된 ZNA를 획득하기 위 해 입력으로서 ZNA 객체 및 GRI를 이용하여 계산 기능들을 실행하도록 구성될 수 있다. 본 개시내용 전체에 걸 쳐 논의된 바와 같이, 수정된 ZNA는 2진 명령어 세트를 인코딩하거나 및/또는 VBLS-인코딩된 명령어 세트를 디 코딩하는데 이용될 수 있다. 실시예들에서, 서열 맵핑 모듈은, 게놈 결합 인자들을 획득하기 위해 수정된 ZNA를 이용하여 EIC VDAX를 대신하여 서열 맵핑 동작들을 수행하도록 구성된다. 실시예들에서, 서열 맵핑 모듈은 실행될 명령어(또 는 명령어 세트 중의 2개 이상의 명령어들의 세트)에 대응하는 서열(예컨대, 공개 또는 비공개 서열)를 획득하 도록 구성될 수 있고 서열을 수정된 ZNA에 맵핑할 수 있다. 구현들에서, 서열은 컴퓨터 프로그램의 하나 이상 의 명령어 세트와 연관된 메타데이터로부터 추출될 수 있다. 서열 맵핑 모듈은 본 개시내용의 범위를 벗 어나지 않고 다른 적절한 공개 또는 비공개 서열들을 활용할 수 있다. 논의된 바와 같이, 서열을 수정된 게놈 데이터(예컨대, 수정된 ZNA)로 맵핑하는 단계는 0개 이상의 중간 변환 단계를 포함할 수 있는데, 여기서 획득된 서열은 계산 기능 세트(예컨대, 해시 기능들)를 이용해 변환되어 중간값을 획득하고, 이에 의해, 중간값과 수정 된 ZNA 값은 제2 세트의 계산 기능들에 입력되어 게놈 결합 인자(GEF)를 획득한다. 예시된 예에서, 서열 맵핑 모듈은 제1 명령어(또는 제1 명령어들의 세트)에 대응하는 제1 서열(공개 또는 비공개 서열)을 결정할 수 있고, 제1 서열을 제1 수정된 ZNA에 맵핑하여 제1 GEF를 획득할 수 있다. 유사하게, 서열 맵핑 모듈은 제2 명령어(또는 제2 명령어들의 세트)에 대응하는 제2 서열(공개 또는 비공개)을 결정할 수 있고, 제2 서열을 제2 수정된 ZNA에 맵핑하여 제2 GEF를 획득할 수 있다. 본 개시내용 전체에 걸쳐 논의된 바와 같이, GEF는 2진 명령어들을 인코딩하거나 및/또는 VBLS-인코딩된 명령어들을 디코딩하는데 이용될 수 있다. 논의된 바와 같이, 서열이 추출되는 메타데이터는 명령어들이 인코딩되고 디코딩되는 방식에 의존할 수 있다. 예를 들어, 각각의 명령어가 상이한 GEF로 인코딩(및 디코딩)되면, 각각의 명령어를 디코딩하거나 인코딩할 때 서열이 추출되는 메 타데이터는 각각의 명령어 특유일 수 있다(예컨대, 값은 각각의 명령어의 메모리 위치를 나타냄). 컴퓨터 프로 그램의 명령어들의 상이한 서브세트들이 상이한 GEF로 각각 인코딩(및 디코딩)된다면, 각각의 상응하는 서브세 트에 대응하는 GEF는 명령어들의 서브세트에 대응하는 메타데이터에 기초하여 결정될 수 있다. 컴퓨터 프로그 램의 모든 명령어들이 동일한 GEF를 이용하여 인코딩되는 구현들에서, 서열이 추출되는 메타데이터는 컴퓨터 프 로그램에 대응할 수 있다. 실시예들에서, 2진 변환 모듈은 계산 기능 세트를 이용하여 게놈 결합 인자에 기초해 VBLS-인코딩된 명령 어를 디코딩된 명령어로 변환한다. 일부 실시예에서, 2진 변환 모듈은 각각의 GEF에 기초하여 각각의 VBLS-인코딩된 명령어(또는 명령어 세트)를 해독한다. 대안으로서, 2진 변환 모듈은 디코딩된 명령어를 획득하기 위해 각각의 GEF를 이용하여(예컨대, XOR 동작을 이용하여) VBLS-인코딩된 명령어를 명료화할 수 있다. 그러면, 디코딩된 명령어는 명령어를 실행하는 처리 코어에 출력될 수 있다. 예를 들어, 예시된 예에서, 2진 변환 모듈은 제1 GEF를 이용하여 제1 VBLS-인코딩된 명령어(또는 제1 명령어 세트)를 디코딩 할 수 있고, 제2 GEF를 이용하여 제2 VBLS-인코딩된 명령어(또는 제2 명령어 세트)를 디코딩할 수 있다. 실시 예들에서, 2진 변환 모듈은 또한, 서열 맵핑 모듈에 의해 결정된 각각의 GEF들에 기초하여 미인코 딩된 2진 명령어들을 VBLS로 변환할 수 있다는 점에 유의한다. 이들 실시예들에서, 2진 변환 모듈은 미 인코딩된 2진 명령어들을 VBLS-인코딩된 명령어들로 변환한 다음, VBLS-인코딩된 명령어들은 나중의 실행을 위 해 메모리에 저장된다. 이제 도 27을 참조하면, VBLS-인코딩된 데이터를 디코딩하고 미인코딩된 데이터를 인코딩하도록 구성된 CG 지원형 VDAX가 있다. 실시예들에서, CG 지원형 VDAX은 전용 처리 코어(예컨대, 도 26에 도시된 EIC VDAX)로서 구현된다. 대안으로서, CG 지원형 VDAX는 처리 디바이스에 의해 실행되는 소프트웨어 기반의 VDAX이다. 예를 들어, CG 지원형 VDAX은 운영 체제 레벨에서 구현될 수 있고 런타임시에 데이 터 인코딩/디코딩을 처리할 수 있다. 이들 실시예들에서, CG 지원형 VDAX는 처리 디바이스에 의해 실행 되고 있는 컴퓨터 프로그램들에 의해 이용되고 있거나 출력되는 데이터를 보호한다. 실시예들에서, VDAX는 CG- ESP 모듈 세트를 포함한다. 예를 들어, CG-ESP 모듈들은, 루트 DNA 모듈(또는 EIC 모듈), 서열 맵핑 모듈, 및/또는 2진 변환 모듈을 포함할 수 있다. 실시예들에서, CG-ESP 모듈들은, 링크 교환 모듈, 마스터 확증 모듈, 마스터 무결성 제어기, 및/또는 기타 등등의, 다른 모듈들을 더 포함할 수 있다. 도시된 예에서, VDAX는 메모리 디바이스(예컨대, RAM, ROM, 솔리드 스테이트 SSD, 하드 디스크 드라이브 HHD, 캐시, 하드 디스크, 외부 메모리 디바이스 등)로부터 VBLS-인코딩된 데이터를 획득할 수 있다. 일 부 실시예에서, 루트 DNA 모듈은, VLBS 인코딩된 데이터 및 대응하는 GRI를 인코딩하는데 이용된 게놈 데이터(예컨대, XNA)를 리트리브한다. 이들 실시예들에서, VDAX(예컨대, 서열 맵핑 모듈)는 VBLS-인코딩된 데이터에 대응하는 서열(예컨대, 비공개 또는 공개 서열)을 획득할 수 있고, 서열, 게놈 데이터(예컨대, 수정되거나 미수정된 XNA), 및 VBLS-인코딩된 데이터를 인코딩하는데 이용된 GRI에 기초하여 게놈 결합 인자(GEF)를 생성할 수 있다. 이들 예시적인 실시예들에서, 2진 변환 모듈은 처리 코어에 입력 데이터로서 제공될 수 있는 디코딩된 데이터를 획득하기 위해 GEF를 이용하여 VBLS-인코딩된 데이터를 디코딩(예컨대, 해독 또는 명료화)할 수 있다. 일부 시나리오에서, 처리 코어는 하나 이상의 2진 명령어들 실행에 응답하여 데이터(\"출력 데이 터\"라고도 함)를 출력할 수 있다. 일부 실시예에서, VDAX는 출력 데이터를 나중에 메모리 에 저장되는 VBLS-인코딩된 데이터로 인코딩하도록 구성될 수 있다. 실시예들에서, VDAX는 출력 데이터(예컨대, 실행 중인 컴퓨터 프로그램의 수정되거나 미수정된 XNA)에 대응하는 게놈 데이터 및 GRI를 획득할 수 있고, 서열, 게놈 데이터(예컨대, 수정되거나 미수정된 XNA), 및 VBLS-인코딩된 데이터 를 인코딩하는데 이용된 GRI에 기초하여 GEF를 생성할 수 있다. 예를 들어, 일부 실시예에서 VDAX(270 0)는 출력 데이터에 할당된 메모리 공간을 정의하는 값으로부터 서열을 추출할 수 있고, 추출된 서열을 서열 맵핑 프로세스에 대한 입력으로서 제공하여 GEF를 획득할 수 있으며, 그 다음, GEF는 출력 데이터를 나중에 메모리(예컨대, RAM, ROM, HDD, SDD, 캐시, 및/또는 기타 등등)에 저장될 수 있는 VBLS-인코딩된 데이터로 인코딩하는데 이용된다. 전술된 내용은 CG 지원형 디코딩 및 인코딩 프로세스들의 예들이라는 것을 이해해야 한다. 추가적인 예시적인 구성들이 고려된다는 것을 이해해야 한다. 예를 들어, 일부 실시예에서, GEF가 결정되는 전략들은 원하는 최적 화(예컨대, 더 빠른 디코딩 대 더 높은 레벨의 보안)에 따라 달라질 수 있다. CG-지원형의 자료 데이터 체인들 도 4와 관련하여 논의된 바와 같이, Cyphergenics 기반의 디지털 생태계는, 각각의 자료 데이터 블록(MDB)들로 구성된 자료 데이터 블록 체인들(\"MDC들\"이라고 함)을 용이와하는 CG-ESP로 구성될 수 있다. 설명의 목적을 위 해, 이들 디지털 생태계들은 \"원장 기반의 생태계\"라고 지칭될 수 있다. 실시예들에서, 자료 데이터 블록(MD B)은, MDB가 MDC에 배열되도록 구성되게끔, 데이터(\"자료 데이터\"라고도 함) 및 대응하는 MDB 메타데이터를 저 장하는 임의의 적절한 데이터 구조일 수 있다. AN MDC란, 특정한 CG-ESP 구성에 따라 원장 기반의 생태계에서 하나 이상의 코호트(예컨대, 블록체인 노드 디바이스)에 의해 집합적으로 유지될 수 있는 디지털 원장을 지칭할 수 있다. 이하의 개시내용으로부터 이해될 수 있는 바와 같이, MDC들 및 이들 MDC들을 지원하는 CG-ESP 구성들 은 현재의 블록 체인 기술들에 비해 감소된 자원 소비(예컨대, 더 적은 전체 저장 공간, 블록들을 검증하기 위 한 더 적은 계산 자원, 및/또는 참여 노드 디바이스 세트에 걸친 에너지 소비)를 제공하면서, 이러한 블록체인 기술들의 무결성과 보안을 유지하거나 향상시킬 수 있다. MDC의 유형, 속성들, 및/또는 프로토콜들은, MDC의 애플리케이션(들), 디지털 생태계의 참가자들, 디지털 생태 계의 목적, 및/또는 생태계 소유자의 이해관계에 따라 달라질 수 있다. 예를 들어, 일부 예시적인 실시예에서, MDC의 프로토콜은, 각각의 참여 코호트는 각각의 코호트에 의해 생성된 MDB들을 그 자신의 MDC에 저장하지만 각 각의 코호트가 디지털 생태계의 다른 코호트들에 의해 생성된 MDB들을 저장할 것을 요구하지 않도록, 비-중복 MDC들을 허용할 수 있다. 이들 예시적인 실시예들 중 일부에서, 각각의 코호트는 코호트에 의해 생성된 MDB들 로 구성된 MDC를 유지하며, 이에 의해, 각각의 코호트는, 그 MDC의 미검증된 부분을, MDC의 미검증된 부분을 제 공한 코호트를 대신하여 MDC의 미검증된 부분을 검증하는 하나 이상의 다른 코호트에 제공한다. 이들 예시적인 실시예들에서, 다른 코호트들을 대신하여 MDC들을 검증하는 코호트들은, 아래에서 더 상세히 논의되는 바와 같 이, MDC의 이전에 미검증된 부분을 검증할 때 코호트에 의해 검증된 각각의 MDB들에 대응하는 검증 기록들을 유지할 수 있다. 이들 실시예들 중 일부에서, 하나 이상의 코호트는 다른 코호트들에 의해 생성 및 유지되는 검 증된 MDC들을 검증하거나 및/또는 다른 코호트들에 의해 생성된 MDB들로 구성된 마스터 MDC에 병합하도록 구성 될 수 있다. 예를 들어, 더 신뢰받는 유형의 생태계들(예컨대, 기업 환경, 산업/제조 환경 등)에서, 전체 생태 계 또는 그 엔클레이브를 나타내는 코호트는 생태계/엔클레이브의 각각의 코호트들에 의해 각각 생성되고 유지 된 MDC들의 검증된 부분들을 수신하고, 각각의 코호트 특유의 MDC의 무결성을 검증할 수 있다(예컨대, 어떠한 MDB도 변경, 제거, 또는 MDC의 각각의 코호트의 확인된 부분에 추가되지 않았는지). 이들 실시예들 중 일부에 서, 검증 코호트는, 코호트의 각각의 검증된 MDC들 중 하나 이상으로부터의 MDB들로 구성된 마스터 MDC를 생성 하거나 업데이트할 수 있다. 그러나, 개별 MDC들로부터의 MDB들을 마스터 MDC 내로 병합하는 것은 선택사항이 고 필수는 아님을 이해해야 한다. 일부 예시적인 실시예들에서, MDC 또는 원장 기반의 애플리케이션의 프로토콜(들)은, MDC 내의 MDB들의 적어도 일부가 공증되고 중복적으로 유지되는 것을 요구할 수 있다. 예를 들어, 일부 신뢰할 수 없는(또는 덜 신뢰받 는) 디지털 생태계들(예컨대, 원장 기반의 디지털 생태계에 집합적으로 참여하는 한 세트의 경쟁사들 또는 적대 자들)에서, 소정의 유형들의 데이터(예컨대, 거래 데이터, 물류 데이터, 센서 데이터, 임상 테스트 데이터, 또 는 기타 유형들의 데이터)를 포함하는 MDB들은, 생태계의 다른 코호트들에 의해 \"공증\"되고, 이에 의해 공증된 MDB들은 MDB들을 공증한 각각의 코호트들에 의해 유지되는 각각의 MDC들에 중복적으로 저장된다. 이들 실시예 에서, 각각의 코호트는 공증된 MDB들로 구성된 MDC의 완전한 사본 또는 공증된 MDB들의 적어도 일부 중첩 세트 를 포함하는 MDC의 불완전한 버전을 저장할 수 있다. 전술된 내용에서 알 수 있는 바와 같이, 원장 기반의 생태계의 상이한 멤버들은 디지털 생태계와 관련하여 하나 이상의 상이한 역할을 수행할 수 있다. 상이한 역할들의 비제한적인 예들로는 \"MDB 창작자\", \"MDB 검증자\", 및 /또는 \"MDB 공증인\"이 포함될 수 있다. 설명의 목적을 위해, \"MDB 창작자 코호트\"(또는 \"창작자 코호트\")는 MDB를 생성 및/또는 MDC 사본에 MDB를 저장하도록 구성된 디지털 커뮤니티의 코호트를 지칭할 수 있다. 실시예 들에서, \"검증 코호트\"는 디지털 생태계의 하나 이상의 창작자 코호트를 대신하여 MDC의 일부를 검증하도록 구 성된 원장 기반의 생태계의 코호트를 지칭할 수 있으며, 이에 의해 MDC의 일부를 검증하면, MDC의 그 부분이 변 경될 수 없게 된다. 실시예들에서, 공증 코호트는 MDB 창작자들에 의해 생성된 MDB들을 공증하는 디지털 커뮤 니티의 코호트를 지칭할 수 있으며, 이에 의해 공증 코호트는 MDB를 불변으로 만들기 위해 MDB를 디지털 방식으 로 공증한다. 원장 기반의 생태계 내에서 코호트는 하나보다 많은 역할을 수행할 수 있다는 것을 이해해야 한다. 예를 들어, 일부 실시예에서, MDB 창작자 코호트는 검증 코호트 및/또는 공증 코호트로서도 역할할 수 있다. 유사하게, 일 부 실시예에서, 검증 코호트는 또한, 공증 코호트 및/또는 창작자 코호트로서 역할할 수 있다. 일부 실시예에 서, 소정의 코호트들은 단지 하나의 역할만을 수행할 수 있다. 예를 들어, 일부 디지털 생태계에서, MDB 창작 자들은 MDB들을 생성하고 MDC들을 유지하도록 구성될 수 있지만 다른 코호트들의 MDC들을 검증하거나 공증하지 는 않는다. 실시예들에서, 디지털 생태계 내의 각각의 코호트들에 의해 수행될 수 있는 역할들은 각각의 코호 트들의 CG-ESP 구성 및 게놈 데이터 세트들의 기능이다. 예를 들어, 일부 예시적인 실시예에서, 코호트의 VDAX 가 Cyphergenics 기반의 필수 기능 세트와 창작자 코호트의 게놈 데이터 세트와 충분한 상관된 게놈 데이터 세 트로 구성되어 MDB 세트가 주어졌을 때 검증 코호트와 창작자 코호트가 동일한 CG-도출된 검증값들을 독립적으 로 생성하는 것을 조합하여 허용하는 경우, 코호트는 창작자 코호트를 대신하여 MDC를 검증할 수 있다. 유사하 게, 일부 예시적인 실시예에서, 코호트의 VDAX가 Cyphergenics 기반의 필수 기능 세트와 게놈 데이터 세트로 구 성되어 공증 코호트만이 CG-도출된 공증값을 재생성할 수 있도록 창작자 코호트에 의해 생성된 주어진 MDB에 대 해 공증 코호트가 고유한 CG-도출된 공증값을 생성하는 것을 허용하는 경우, 코호트는 창작자 코호트를 대신하 여 MDC를 공증할 수 있다. 일부 구현에서, MDB들의 공증은 비상관된 코호트들에 의해 수행될 수 있어서, 공증 코호트는 동일한 디지털 생 태계에 속하지 않을 수 있다(예컨대, 공증 코호트는 \"충분히 상관된 게놈 데이터\"를 갖지 않음)는 점에 유의한 다. 이러한 공증 코호트들의 경우, MDB 창작자 코호트와 상관되는 게놈 데이터를 갖지 않음에도 불구하고 이들 에게 할당된 게놈 데이터 객체들을 이용하여 CG-도출된 공증값들을 생성할 수 있다. 이러한 생태계들에서 유지 되는 MDC들은 \"원장간\" MDC들이라고 지칭될 수 있고, 이러한 원장간 MDC들을 지원하는 기능들을 갖는 CG-ESP 구 성들은 \"원장간\" 기능들이라고 지칭될 수 있는 반면, 모든 코호트가 공통 게놈 데이터를 공유하는 디지털 생태 계들에서 유지되는 MDC들은 \"원장내\" MDC들이라고 지칭될 수 있고 이러한 원장내 MDC들을 지원하는 기능들을 갖 는 CG-ESP 구성들은 \"원장내\" 기능들이라고 지칭될 수 있다. 또한, 본 명세서에서 사용될 때, 용어 \"CG-도출된 값들\"(예컨대, CG-도출된 검증값들, CG-도출된 공증값들, CG- 도출된 창작자 값들, CG-도출된 디지털 서명들 등)은, CG 기반의 기능들 및/또는 CG 기반의 기능들을 이용하여 결정된 입력 파라미터들을 이용하여 VDAX에 의해 생성되는 값들을 지칭할 수 있다. 예를 들어, (논의되는 바와 같이) MDB의 CG-도출된 검증값은, MDB로부터의 서열이 VDAX의 게놈 분화 객체에 맵핑될 때 생성되는 게놈 결합 인자(GEF)를 이용하여 결정될 수 있다. 서열 맵핑 동작은 CG 기반의 기능으로 간주될 수 있고, 결과적인 GEF는 CG 기반의 기능(및 CG-도출된 값)을 이용하여 결정된 입력 파라미터이다. VDAX는 MDB에 대응하는 검증값을 생 성하기 위해 비-CG 기반의 기능들(예컨대, 해시 기능, CMAC, XOR, 파라미터화된 동작들, 및/또는 기타 등등)을 채용할 수 있지만, 결과적인 검증값은 \"CG-도출된 검증값\"이라고 여전히 지칭될 수 있는, 그것은 GEF가 비-CG 기반의 기능에 대한 입력으로서 제공되기 때문이다. 전술된 내용은, CG-도출된 공증값들, CG-도출된 창작자 값 들, CG-도출된 디지털 서명들(VDAX의 PNA 객체를 이용하여 결정될 수 있음) 등에 적용된다. 또한, CG-도출된 값들은 원장 기반의 생태계들 특유인 것은 아니다. CG-도출된 값들은 또한, 상이한 유형들의 CG 지원형 디지털 생태계에서 생성되는 값들도 역시 지칭할 수 있다. 이제 도 28을 참조하면, 원장 기반의 생태계들과 기저 VDAX들의 예시적 구성들이 논의된다. 도 28에서, 생태계 참가자(예컨대, 코호트)의 예시적인 VDAX는 CG-ESP 및 게놈 데이터 세트로 구성된다. 실시예들에 서, VDAX는 원장 기반의 애플리케이션과 인터페이스하거나 및/또는 이에 통합된다. 원장 기반의 애플리케이션은 원장 기반의 애플리케이션이 액세스할 수 있는 메모리(예컨대, 컴퓨터 판독 가능한 매체(들))에 저장된 MDC에 기입하거나, 유지하거나, 이로부터 판독하거나, 또는 기타의 방식으로 인터페이스하는 임의의 컴퓨팅 프로그램을 지칭할 수 있다. 원장 기반의 애플리케이션은, 스마트 계약들, IOT 애플리케이션들(예컨대, IOT 센서들), 상용 애플리케이션들, 시스템 애플리케이션들(예컨대, 운영 체제 애플리케이션들), 서버 애플리케이션들, 및/또는 MDC와 인터페이스할 수 있는 기타 임의의 적절한 유형들의 애플리케이션들을 포함할 수 있다. 실시예들에서, 원장 기반의 애플리케이션은, 검증 코호트들 및/또는 공증 코호트들 등의, 원 장 기반의 디지털 생태계 내의 다른 코호트들과 통신할 수 있다. 예를 들어, 일부 예시적인 디지털 생태계에서, 원장 기반의 애플리케이션은 검증 데이터(예컨대, MDC의 미검증된 부분, 또는 이를 나 타내는 데이터)를 검증 코호트에 전송하도록 구성될 수 있다. 이들 예시적인 실시예들 중 일부에서, 검 증 코호트는 각각의 MDB를 검증할 때 MDC의 (이전에) 미검증된 부분 내의 각각의 상응하는 MDB에 대한 검증 기록들을 반환하고, 이에 의해 각각의 MDB에 대응하는 검증 기록은 검증 코호트에 의해 생성된 CG-도출된 검증값을 포함한다. 일부 예시적인 디지털 생태계에서, 원장 기반의 애플리케이션은 각각의 공증 코호트에 의한 공증을 위해 미공증된 MDB들을 하나 이상의 공증 코호트로 전송하도록 구성될 수 있다. 이들 실시예들에서, 공증 코 호트는 MDB에 기초하여 CG-도출된 공증값을 생성하고 CG-도출된 공증값으로 디지털 공증된 MDB의 공증된 버전을 원장 기반의 애플리케이션에 반환하고, 이어서, 원장 기반의 애플리케이션은, 원장 기반의 애플리케이션에 의해 유지되는 MDC의 대응하는 MDB에 CG-도출된 공증값을 기입한다. 일부 실시예에서, 공증 코호트는 또한, 그 자신의 MDC(미도시)에 공증된 MDB를 저장할 수 있다. 이들 예들에서, 공증 코호 트(들)은 공증 코호트에 의해 도출된 CG-도출된 공증값과 CG-도출된 창작자 값을 포함하는 공증된 MDB의 사본을 갖고 있어서, 공증된 MDB의 무결성이 의심되는 경우, 공증 코호트는 CG-도출된 공증값을 재계산함 으로써 공증된 MDB의 내용들(예컨대, 자료 데이터 및/또는 MDB 메타데이터)이 변경되었는지를 입증할 수 있게 한다. 전술된 예시적인 실시예들에서, 각각의 검증 코호트 및/또는 공증 코호트는 또한, Cyphergenics 기 반의 기능을 대신 수행하는 각각의 VDAX(도 28에 도시되지 않음)를 포함한다는 점에 유의한다. 원장 기반의 디지털 생태계의 상이한 구현들에서, MDC는, 완전 분산형(노드들이 다른 노드들에 의해 생성된 모 든 MDB를 중복 저장함), 준-분산형(노드들이 다른 노드들에 의해 생성된 MDB의 전부가 아닌 일부만 저장함), 또 는 비-분산형 원장(노드들은 다른 노드들에 의해 생성된 MDB들을 저장하지 않음)일 수 있다. 실시예들에서, MDC는 MDB들로 구성될 수 있고, 여기서, 각각의 MDB는 자료 데이터, MDB 메타데이터 , 및 CG-도출된 값 세트를 포함한다. 실시예들에서, 자료 데이터란 MDB에 저장되어 있는 실질적 데이터를 지칭할 수 있다. 예를 들어, 자료 데이터는, 센서 판독값들, 거래 기록들, 물류 기록들, 투표 데이터, 임상 데이터, 건강 기록들, 보험 기록들, 기업 데이터, 베팅 데이터, 액세스 기록들, 계 약 데이터, 증거 데이터, 및/또는 기타 임의의 적절한 데이터일 수 있다. 실시예들에서, MDB 메타데이터(282 8)는 원장 기반의 애플리케이션에 의해 및/또는 기저 디지털 원장의 프로토콜(들)에 따라 MDB에 유 지되는 임의의 적합한 메타데이터를 포함할 수 있다. 예를 들어, MDB 메타데이터의 비제한적인예들로는, MDB가 생성된 날짜 및/또는 시간을 나타내는 타임스탬프, MDB를 생성한 코호트를 나타내 는 발원자 속성, MDB를 식별하는 MDB 식별자, MDB의 해시값(예컨대, 자료 데이터 및 하나 이상의 해시 기능에 기초하여 원장 기반의 애플리케이션에 의해 생성된 해시값), MDC 내의 선행 MDB의 해 시값, MDB를 포함하는 MDC를 검증하는 하나 이상의 각각의 검증 코호트를 나타내는 하나 이 상의 검증자 ID, MDC를 공증하는 하나 이상의 공증 코호트를 나타내는 하나 이상의 공증 ID, 및/또 는 다른 적절한 정보가 포함될 수 있다. MDB에 유지되는 MDB 메타데이터의 정확한 유형들은 원장 기반의 애플리케이션 및/또는 원장 기반의 디지털 생태계를 용이화하는 CG-ESP(들)의 구성과는 독립적인 기저 디지털 원장의 프로토콜들에 기초하여 달라질 수 있다는 점에 유의한다. 더욱이, CG-도출된 값(들)은 CG-도출 된 값(들)에 대응하는 MDB에 저장되는 것으로 도시되어 있지만, 일부 구현에서, CG-도출된 값들은 별도의 MDB들 및/또는 다른 적절한 데이터 구조들에 저장될 수 있다. 실시예들에서, CG-도출된 값들은 각각의 VDAX(예컨대, VDAX)의 게놈 데이터와 MDB의 적어도 일부에 기초하여 Cyphergenics 기반의 동작 세트를 이용해 디지털 생태계에서 VDAX들에 의해 생성된 수치 값들 (예컨대, 비트 벡터들)이다. MDB에서 유지되는 CG-도출된 값들의 정확한 유형들은, 원장 기반의 디지털 생태계의 목적, 디지털 생태계의 신뢰성, 디지털 생태계의 소유자, 및/또는 디지털 생태계의 참가자들 유형에 따라 달라질 수 있다. 따라서, 특정한 디지털 생태계에 대해 유지되는 CG-도출된 값들의 유형들 및 속성 들, CG-도출된 값들을 결정하는데 이용되는 게놈 데이터 객체들의 유형들, 및 특정한 디지털 생태계에 대 한 CG-도출된 값들을 결정하는데 이용되는 계산 기능들은, 특정한 디지털 생태계의 커뮤니티 멤버들의 CG-ESP들 에서 정의된다. CG-도출된 값들의 예들로는, CG-도출된 검증값들, CG-도출된 공증값들, CG-도출된 창작자 값들, 및/또는 기타 등등이 포함될 수 있다. 실시예들에서, CG-도출된 창작자 값은, MDB의 적어도 일부, MDB 창작자의 게놈 데이터 세트, 및 GRI(비밀 GRI, 또는 2개 이상의 코호트에 공통된 GRI일 수 있음)를 이용하여 MDB의 창작자에 의해 생성된 값일 수 있다. 이러한 방식으로, MDB 창작자만이, MDB 창작자에 의해 생성된 MDB가 주어 지면 CG-도출된 창작자 값을 재생성할 수 있다. 일부 구현에서, CG-도출된 창작자 값은, MDB에 대응하는 게놈 결합 인자가 주어지면 하나 이상의 계산 기능(예컨대, 암호 기반의 및/또는 암호 없는) 세트를 이용하여 MDB 창 작자의 VDAX에 의해 생성되는 값이다. CG-도출된 창작자 값은, 입력으로서 GEF와 MDB(또는 MDB의 해시값)를 수신하는 해시 기능, 입력으로서 GEF 및 MDB의 해시값을 수신하는 XOR 기능, 입력으로서 GEF와 MDB (또는 MDB의 해시값)를 수신하는 CMAC 기능, 및/또는 기타 등등의, 임의의 수의 적절한 유형들의 기능들을 이용 하여 결정될 수 있다. 실시예들에서, CG-도출된 공증값은, MDB의 적어도 일부, 공증 코호트의 게놈 데이터 세트, 및 GRI(비밀 GRI, 또는 2개 이상의 코호트에 공통된 GRI일 수 있음)를 이용하여, 디지털 생태계에서 공증 코호트에 의해 생 성되는 MDB에 대응하는 값이다. 이러한 방식으로, 초기에 각각의 MDB를 생성한 공증 코호트만이, 코호트에 의해 공증된 MDB가 주어지면 CG-도출된 창작자 값을 재생성할 수 있다. 일부 실시예에서, CG- 도출된 공증값은, MDB에 대응하는 게놈 결합 인자가 주어지면 하나 이상의 계산 기능(예컨대, 암호 기반의 및/ 또는 암호 없는) 세트를 이용하여 MDB 창작자의 VDAX에 의해 생성되는 CG-도출된 해시값이다. CG-도출된 창작자 값은, 입력으로서 GEF와 MDB(또는 MDB의 해시값)를 수신하는 해시 기능, 입력으로서 GEF 및 MDB의 해시 값을 수신하는 XOR 기능, 입력으로서 GEF와 MDB(또는 MDB의 해시값)를 수신하는 CMAC 기능, 및/또는 기타 등등 의, 임의의 수의 적절한 유형들의 기능들을 이용하여 결정될 수 있다. 실시예들에서, CG-도출된 검증값은, MDB의 적어도 일부, 선행 MDB의 적어도 일부, MDB 창작자 및/또는 MDC 검증 자(들)의 게놈 데이터 객체(예컨대, XNA), 및 MDB 창작자 및/또는 MDC 검증자(들) 사이에서 교환되고 비밀리에 보관되는 GRI에 기초하여 MDB 창작자 및/또는 하나 이상의 MDC 검증자에 의해 생성되는 값이다. 이러한 방식으로, 충분한 상관된 게놈 데이터를 갖고 GRI를 보유하고 있는 코호트들만이 MDB와 선행 MDB의 내용들에 기 초하여 MDB의 검증값을 재생성할 수 있다. 일부 구현에서, CG-도출된 검증값은, 창작자와 검증자 사이에 충분 히 상관된 게놈 데이터 세트와 공통으로 보유되는 GRI에 기초하여 생성된 GEF가 주어질 때 계산 기능 세트(예컨 대, 암호 기반의 및/또는 암호 없는)를 이용하여 MDB 창작자 및/또는 검증자의 VDAX들에 의해 생성되는 값이다. CG-도출된 검증값은, 해시 기능, XOR 기능, CMAC 기능, 및/또는 기타 등등의, 임의 개수의 적절한 유형들의 기 능들을 이용하여 결정될 수 있다. 실시예들에서, 코호트에 의해 또는 코호트와 관련하여 실행되는 원장 기반의 애플리케이션은, 코호트의 VDAX에 하나 이상의 MDB를 제공하도록 구성되고, VDAX는 수신된 MDB들에 기초하여 하나 이상 의 CG-도출된 값을 결정한다. 실시예들에서, VDAX는, 루트 DNA 모듈, 링크 모듈, 서열 맵핑 모듈(예컨대, 공개 및/또는 비공개 서열 맵핑 모듈), 2진 변환 모듈, 및/또는 마스터 확증 모듈 을 포함할 수 있다. 루트 DNA 모듈, 링크 모듈, 서열 맵핑 모듈, 및 2진 변환 모듈 은, 본 출원 전반에 걸쳐 다른 곳에서 설명된 방식들로 동작할 수 있다는 것을 이해해야 한다. 실시예들 에서, VDAX는 디지털 생태계의 또 다른 멤버들(예컨대, 코호트들)과 링크 교환을 수행하여 임의의 적절한 방식들로 이들 멤버들과 GRI를 교환할 수 있다. 원장 기반의 디지털 생태계 내의 코호트들은 교환된 링 크 정보(예컨대, GRI)를 이용하여 생태계 내에서 데이터(예컨대, MDB들 또는 기타의 데이터)를 안전하게 교환할 수 있지만, 디지털 생태계 내의 또 다른 코호트와 교환되는 GRI는 또한, 소정의 유형들의 CG-도출 된 값들(예컨대, CG-도출된 검증값들)을 생성할 때 코호트의 VDAX에 의해 이용될 수 있다. CG-도출된 검증값들 을 생성하는데 이용되는 GRI는 VBLS 인코딩/디코딩을 용이화하는데 이용되는 것과 동일한 GRI일 수 있거나 코호트들 사이에서 교환되는 상이한 GRI일 수 있다는 것을 이해해야 한다. 또한, 일부 실시예에 서, VDAX는 소정의 유형들의 CG-도출된 값들(예컨대, CG-도출된 공증값들 및/또는 CG-도출된 창작자 값들)을 생성하는데 이용되는 GRI를 생성하고 비밀리에 보유하도록 구성될 수 있다. MDC들의 CG-기반의 검증 도 29를 참조하고 도 28을 계속 참조하면, 원장내 MDC를 유지하기 위해 CG 기반의 검증을 이용하는 예시적인 원 장 기반의 디지털 생태계가 공개된다. 이들 예시적인 디지털 생태계 중 일부에서, 각각의 상응하는 MDB 창작자 코호트는 각각의 MDB 창작자 코호트(예컨대, 창작자 코호트(2900-1) 및 창작자 코호트(2900-2))에 의해 생성된 MDB들로 구성된 각각의(및 잠재적으로 중복되지 않는) MDC(예컨대, MDC(2822-1) 및 MDC(2822-2))를 유지하되, 각각의 창작자 코호트가 적어도 MDC의 그 자신의 부분을 유지하는 것을 담당할 수 있게 한다. 실시예들에서, MDB 창작자 코호트는, MDC 및 그 MDB들의 유효성, 진본성, 소스 및 /또는 무결성을 증명하는데 이용될 수 있는, 각각의 자료 데이터, MDB 메타데이터, 및 CG-도출된 값 세트(예컨 대, CG-도출된 검증값들 및 기타 임의의 요구되는 CG-도출된 값들)를 각각 포함하는 MDB들을 생성하도록 구성될 수 있다. 이들 실시예들 중 일부에서, 창작자 코호트의 VDAX는, MDB, MDC 내의 선행 MDB, 창작자 코 호트의 게놈 데이터 객체(예컨대, XNA 등의 게놈 분화 객체), 및 (VDAX에 의해 콘텐츠 창작자의 VDAX에 제공될 수 있거나 그 반대일 수 있는) 검증 코호트의 VDAX와 교환된 GRI에 기초하여 MDB에 대응하 는 CG-도출된 검증값을 생성할 수 있다. 예를 들어, 디지털 생태계가 하나의 검증 코호트를 포함하는(및 /또는 검증이 엔클레이브 레벨에서 수행되는) 경우, 각각의 MDB는 MDB 창작자 코호트 VDAX 및 검증 코호 트에게 알려진 GRI를 이용하여 생성된 하나의 CG-도출된 검증값을 포함할 수 있다. 일부 구현에서, 복수 의 검증 코호트가 MDB 창작자 코호트에 의해 생성된 MDB들을 검증하는 경우, MDB 창작자 VDAX는 MDB를 포함하는 MDC의 부분을 검증하는 각각의 검증 코호트에 대응하는 각각의 상응 하는 CG-도출된 검증값을 생성할 수 있다. 예를 들어, 도시된 예에서 VDAX는 MDB 창작자 코호트와 각각의 검증 코호트에 의해 교환된 GRI에 기초하여 검증 코호트에 대한 검증값을 생성할 수 있다. 그러나, 추가적인 검증 코호트들(미도시)이 있는 경우, VDAX는 각각의 상응하는 검증 코호트와 교환된 GRI에 기초하여 각각의 추가 검증 코호트(미도시)에 대한 각각의 검증값들을 생성할 수 있다. 이러한 방식으로, 각각의 검증 코호트는 각각의 검증 코호트와 MDB 창작자 코호트 사이에서 공유되 는 GRI를 이용하여, MDB 창작자 코호트에 의해 생성되는 각각의 CG-도출된 검증값에 기초하여 다른 검증 코호트들과는 독립적으로 MDB 창작자의 MDC를 검증할 수 있다. 일부 다른 구현들에서, 원장 기반의 생태 계 또는 그 엔클레이브에 있는 참여 노드 디바이스의 각각의 코호트 VDAX는, 원장 기반의 생태계 또는 그 엔클 레이브 내의 각각의 코호트 VDAX 각각이 생태계 VDAX 또는 엔클레이브 VDAX로부터 동일한 생태계 특유의 또는 엔클레이브 특유의 GRI를 수신할 수 있도록, 생태계 VDAX, 또는 참여 노드 디바이스들의 특정한 엔클레이브를 나타내는 엔클레이브 VDAX와의 링크 교환을 수행할 수 있다. 이들 구현들에서, 생태계 특유의 또는 엔클레이브 특유의 GRI를 보유한 각각의 코호트 VDAX는, 특정한 MDB 세트에 대해 동일한 CG 지원형 검증값들을 생성할 수 있다. 따라서, 여러 검증 코호트가 동일한 검증값을 이용하여 MDB를 검증할 수 있다. 일부 실시예에서, 각자의 디지털 생태계의 각각의 검증 코호트는 검증 코호트에 의해 검증된 MDC 내의 각각의 상응하는 MDB에 대한 검증 기록을 생성한다. 일부 예시적인 실시예에서, 검증 기록은, 검증된 MDB(예컨대, MDB를 고유하게 식별하는 MDB 식별자), MDB에 대응하는 CG-도출된 검증값, 및 검증에 관련된 추가 데이터를 나타낼 수 있다. 검증 기록의 예시적인 추가 데이터로는, MDB를 생성한 MDB 창작자 코호트의 식별자, MDB를 검증한 검증 코호트의 식별자, 검증된 MDB가 위치해 있는 MDC를 나타내는 MDC 식별자, MDB의 MDB 창작자 CG-도출된 값, 검증이 이루어진 때의 타임스탬프, MDB를 검증한 다른 검증 코호트들, MDB(또는 그 일부)의 해시값, MDC 내의 선행 MDB(또는 선행 MDB의 일부)의 해시값, 및/또는 기타의 적절한 메타데이터가 포함될 수 있지 만, 이것으로 제한되는 것은 아니다. MDB 및 선행 MDB의 해시값들은 전통적인 해싱 기술들을 이용하여 도출 될 수 있어서, 해시값들은 CG-도출된 GEF를 이용하지 않고 생성된다는 점에 유의한다. 즉, MDB 및/또는 선행 MDB의 해시값들은, CG-도출된 검증값들을 생성하는데 이용된 게놈 데이터 및/또는 GRI를 보유하지 않은 엔티티 에 의해 확정될 수 있다. 일부 실시예에서, 검증 코호트는 검증 체인을 유지하되, 검증 체인이 검증 블록들을 포함할 수 있도록 하고, 여기서 각각의 검증 블록은 하나 이상의 검증 기록을 포함한다. 예를 들어, 일부 실시예에서, 각각의 검증 블록은, 검증 코호트에 의해 검증된 MDB를 나타내는 검증 기록, MDB에 대응하는 CG-도출된 검증값, 및 기타 임의의 적절한 데이터를 저장할 수 있다. 일부 실시예에서, 검증 체인 내의 각각의 검 증 블록은, MDC로부터 검증된 MDB들의 뮦음을 나타내는 검증 기록들의 묶음을 포함할 수 있다. 예를 들 어, MDB 창작자 코호트가 자신의 MDC의 미검증된 부분을 검증 코호트에 \"커밋\"할 때, 검증 코호트는 MDC의 미검증된 부분 내의 각각의 MDB를 검증할 수 있고, 검증 블록 내의 MDC의 (이전에) 미검 증된 부분으로부터 각각의 검증된 MDB에 대한 검증 기록들을 포함할 수 있고, 이것은 그 다음 각각의 검증 코호 트에 의해 유지되는 검증 체인에 추가된다. 전용 체인으로서 도시되어 있지만, 검증 체인은 각각의 검증 코호트에 의해 유지되는 MDC에 저장될 수 있다는 점에 유의한다. 이들 구현들 중 일부에서, 검증 블록은, 검증 블록이 생태계의 또 다른 코호트에 의해 검증될 필요가 없도록 MDC의 사이드 체인으로서 저장될 수 있다. 일부 실시예에서, 검증 코호트는, MDB 창작자에 의해 제공되는 MDB에 대한 검증 또는 MDC의 미검증된 부 분에 대한 검증을 나타내는 검증 통보를 MDB 창작자 코호트에 제공할 수 있다. 실시예들에서, 검증 통보 는 MDB 또는 MDB들의 묶음이 검증되었는지 뿐만 아니라 다른 적절한 데이터(예컨대, 검증 코호트에 의해 결정된 MDB의 CG-도출된 검증값, 타임 스탬프, 통보의 출처 및/또는 진본성을 증명하는 CG-도출된 값, 및/또는 기타 등 등)를 나타낼 수 있다. 일부 실시예에서, 검증 통보는 각각의 검증 코호트에 의해 생성된 하나 이상의 검증 기록을 포함할 수 있다. 일부 구현에서, MDB 창작자 코호트는 검증 통보를 수신할 수 있고 검증 통 보를 저장할 수 있어서(예컨대, MDC에, MDC의 사이드체인에, 또는 다른 곳에), MDC 및/또는 그 MDB의 진실성이 문제되는 경우, MDB 창작자 코호트는 검증 코호트들에 의한 검증 증명을 제공할 수 있다(이것은 MDC 및 그 MDB들의 무결성을 증명하는데 이용될 수 있다). 일부 실시예에서, 창작자 코호트는 검증 체인도 역시 유지할 수 있다. 이들 구현들에서, 창작자 코호트는 창작자 코호트에 의해 생성된 MDB들을 검증한 검증 코호트들에 의해 제공된 검증 기록들을 포함하는 하나 이상의 검증 블록을 저장할 수 있다. 실시예 들에서, 검증 코호트는 별도의 검증 체인(미도시) 또는 MDC에(예컨대, MDC의 사이드 체인에 또는 MDC의 메인 체인에) 검증 블록들을 저장할 수 있다. 일단 MDC의 일부가 하나 이상의 검증 코호트에 의해 검증되고 나면, MDC의 그 부분은 변경할 수 없게 된다. MDB 창작자 코호트는 MDC의 검증된 부분 내의 임의의 MDB의 자료 데이터 및/또는 메타데이터 중 어느 것도 변경할 수 없으며, MDC의 검증된 부분 내의 MDB들과 연관된 CG-도출된 검증값들 을 변경하지 않고 MDC의 검증된 부분으로부터 MDB를 제거하거나 CG-도출된 검증값들로서 이를 추가할 수 없다. 이러한 방식으로, 각각의 MDB 창작자 코호트는 임의의 다른 코호트(노드)에 있는 MDB들을 복제할 필요없이 그 자신의 MDC를 저장할 수 있다. 특정한 코호트에 의해 유지되는 MDC의 무결성 또는 진 본성이 문제가 되는 경우, MDC를 검증한 하나 이상의 검증 코호트에 의해 MDC의 무결성 또는 진본성이 쉽게 검증될 수 있다. 예를 들어, 일부 실시예에서, 각각의 검증 코호트는 문제의 MDC의 일부를 수신할 수 있고, MDC 내의 각각의 MDB에 대해, MDB 및 그 MDB에 선행하는 MDB에 기초하여 CG-도출 된 검증값을 생성할 수 있다. 생성된 CG-도출된 검증값이 MDB 내의 CG-도출된 검증값 및/또는 검증 코호트 (들)에 의해 유지되는 검증 체인(들)에서 유지되는 CG-도출된 검증값과 정합하지 않는 경우, 검증 코호트 는 MDC가 손상되었다고 결정한다. 나아가, 검증 코호트는 또한, 제1 변경이 발생한 MDC 내의 특정한 MDB 를 결정할 수 있다. 생성된 CG-도출된 검증값이 MDB 내의 CG-도출된 검증값 및/또는 검증 코호트에 의해 유지되는 검증 체인에서 유지되는 CG-도출된 검증값과 정합하는 경우, 검증 코호트는 MDC가 손상되 지 않았다고 결정한다. 검증 코호트는 MDB 창작자 코호트로서 역할할 수 있고 그 반대의 경우도 가능하다는 점에 유의한다. 더욱이, 전술된 내용은 MDB 창작자 코호트들과 검증 코호트들이 동일한 게놈 커뮤니티 에 속하는 경우(예컨대, 충분히 상관된 게놈 데이터 세트들을 가짐) 임의의 유형의 원장 기반의 디지털 생태계 에 적용될 수 있다. 이러한 디지털 생태계들의 구성들은 커뮤니티 소유자(예컨대, 분산 원장의 프로토콜, 플 랫폼 제공자, 기업, 및/또는 기타의 적절한 커뮤니티 소유자들)에 의해 정의될 수 있다.일부 예시적인 구현에서, MDB 창작자 코호트의 VDAX는 원장 기반의 애플리케이션으로부터 하 나 이상의 연속 MDB(즉, MDC의 일부)에 관련된 입력 데이터를 수신할 수 있고, MDB 및 MDC 내의 선 행하는 MDB에 기초하여 각각의 상응하는 MDB에 대한 CG-도출된 검증값을 결정할 수 있다. 언급된 바와 같이, 일부 예시적인 구현에서, 블록을 검증하기 위해 상이한 GRI를 이용하는 디지털 생태계 내의 여러 검 증 코호트가 있는 경우, 창작자 코호트의 VDAX는 여러 CG-도출된 검증값을 생성할 수 있다. 이들 예시적 인 구현들 중 일부에서, VDAX의 루트 DNA 모듈은 MDB 창작자 코호트와 각각의 검증 코호트 사이에서 교환된 GRI(예컨대, MDB 창작자 코호트에 의해 검증 코호트에 제공되거나 그 반대 의 GRI)를 이용하여 디지털 생태계에 참여하기 위해 VDAX에 할당된 게놈 분화 객체(예컨대, XNA)를 수정 하여 수정된 게놈 데이터 객체를 획득할 수 있다. 이들 구현들 중 일부에서, VDAX는 MDB로부터(예 컨대, MDB의 MDB 메타데이터 및/또는 다른 서열 소스들로부터) 서열을 추출하고 수정된 게놈 데이터 객체 를 서열 맵핑 모듈에 입력한다. 이들 구현들에서, 서열 맵핑 모듈은 (예컨대, 전술된 바와 같이) 추출된 서열 및 수정된 게놈 데이터 객체에 기초하여 게놈 결합 인자(GEF)를 생성할 수 있다. 대안으로서, 서 열 맵핑 모듈은, 서열, GRI, 및 미수정된 게놈 데이터 객체(XNA)를 수신할 수 있고, (예컨대, 전술된 바 와 같이) 이에 기초하여 GEF를 결정할 수 있다. 실시예들에서, 마스터 확증 모듈은 MDB에 대응하 는 GEF를 수신하고, GEF, MDB, 및 MDC 내의 선행하는 MDB에 기초하여 CG-도출된 검증값을 생성한다. 일부 예시 적인 구성에서, 마스터 확증 모듈은 MDB의 제1 해시값과 MDC 내의 선행하는 MDB의 제2 해시 값을 결정하도록 구성될 수 있다. 제1 및 제2 해시값은, MDB와 선행 MDB가 주어질 때 임의의 적절하게 구성된 코호트가 각각 제1 및 제2 해시값들을 재생성할 수 있도록, 디지털 생태계 내의 모든 참가자에게 알려진 해시 기능(예컨대, 비-CG-지원형의 해시 기능)을 이용하여 결정될 수 있다는 점에 유의한다. 일부 실시예에서, 마스 터 확증값은 제1 및 제2 해시값들을 생성한다. 대안으로서, 일부 실시예에서, 제1 및 제2 해시값들은 원 장 기반의 애플리케이션에 의해 생성되어 VDAX에 제공될 수 있다(예컨대, 입력 데이터와 함께, 검증 중인 MDB의 MDB 메타데이터에서 등). 예시적인 구현들에서, 마스터 확증값은, MDB와, MDC 내의 MDB 이전의 MDB의 조합을 나타내는 링킹값을 획득하기 위해 명시된 방식으로 제1 및 제2 해시값들을 결합 (예컨대, 연결, 추가, 섞기, 추가, 곱하기 등)할 수 있다. 이들 실시예들 중 일부에서, 마스터 확증 모듈 은, MDB에 대해 결정된 GEF, 링킹값 및 계산 기능 세트(예컨대, 암호 기반, 암호 없는, 또는 하이 브리드 기능)에 기초하여 CG-도출된 검증값을 생성할 수 있다. 예를 들어, 일부 실시예에서, 마스터 확증 모듈 은 GEF 및 링킹값을 일련의 하나 이상의 암호화 해시 기능, 암호화 기능, 2진 변환(또는 입력으로서 링킹 값과 GEF를 수신할 수 있는 임의의 다른 적절한 계산 기능)에 입력하여 선행 MDB에 대해 MDB에 대응하는 CG-도출된 검증값을 획득할 수 있다. 이러한 방식으로, 검증값 및 충분히 상관된 게놈 데이터 객체(예컨대, XNA)를 생성하기 위해 창작자 코호트에 의해 이용된 GRI를 (예컨대, MDB 창작자 코호트 또는 엔클 레이브 VDAX와의 링크 교환을 통해) 검증 코호트가 보유하는 경우, 결과적인 CG-도출된 검증값은 검증 코 호트에 의해서만 검증될 수 있다. 실시예들에서, MDB의 CG-도출된 검증값은 MDB의 CG-도출 된 값들에 기입될 수 있다. 실시예들에서, 창작자 코호트의 VDAX는, MDB가 창작자 코호트 의 MDC에 추가될 때 창작자 코호트에 의해 생성된 각각의 상응하는 MDB에 대해 하나 이상의 CG-도 출된 검증값을 결정할 수 있다. 새로 추가된 MDB는, 원장 기반의 애플리케이션이 MDC의 미검증된 부분을 하나 이상의 검증 코호트에 전송함으로써 새로 추가된 MDB를 포함하는 MDC의 미검증된 부분을 \"커 밋\"할 때까지 미검증된 상태로 유지된다는 점에 유의한다. 일단 MDC의 일부가 검증 코호트(들)에 의해 검증되고 나면, MDC의 그 부분은 검증되고 변경 불가능하게 된다. 일부 구현에서, MDB 창작자 코호트(예컨대, 원장 기반의 애플리케이션)는 MDC의 미검증된 부 분에 대응하는 검증 데이터를 하나 이상의 검증 코호트에 제공할 수 있다. 이들 구현들 중 일부에서, 검 증 데이터는 MDC의 전체 미검증된 부분일 수 있다. 다른 구현들에서, 검증 데이터는 각각의 MDB의 비- CG-도출된 값(예컨대, 비-CG-도출된 값들)을 포함하고, 각각의 MDB에 대해, 서열이 추출될 수 있는 임의 의 다른 적절한 메타데이터를 포함한다. 구현들에서, 검증 코호트는 MDC의 미검증된 부분에 대응 하는 검증 데이터를 수신할 수 있고, 검증 데이터, 그 게놈 데이터 세트, 및 검증 코호트와 MDB 창작자 코호트에 의해 공통으로 보유된 GRI에 기초하여, MDC의 미검증된 부분 내의 각각의 MDB를 반 복적으로 검증할 수 있다. 검증 코호트의 VDAX는 MDB 창작자 코호트의 VDAX와 동일 한 동작들을 수행할 수 있다. 예를 들어, 일부 구현에서, 검증 코호트 VDAX는 MDB 창작자 코호트 에 대응하는 GRI로 디지털 생태계에 대응하는 게놈 분화 객체(예컨대, XNA 객체)를 수정하여 수정된 게놈 분화 객체(예컨대, 수정된 XNA 객체)를 획득할 수 있다. MDC의 미검증된 부분 내의 각각의 MDB에 대해, 검증 코호트 VDAX는 MDB에 대응하는 서열을 추출하고(예컨대, MDB의 MDB 메타데이터로부터), (예컨대, 전술된 바와 같이) 서열, 공통으로 보유된 GRI, 및 수정된 게놈 데이터 객체에 기초하여 MDB에 대응하는 GEF를 생성할 수 있다. 대안으로서, 일부 구현에서, 검증 코호트 VDAX는 (예컨대, MDB의 MDB 메타데이터로부터) MDB에 대 응하는 서열을 추출할 수 있고, (예컨대, 전술된 바와 같이) 서열, 공통으로 보유된 GRI, 및 미수정된 게놈 데 이터 객체에 기초하여 MDB에 대응하는 GEF를 생성할 수 있다. 검증 코호트의 VDAX 구성은 MDB 창작자 코호트 의 VDAX 구성과 동일하거나 기능적으로 대칭적일 수 있어서, 동일한 서열들이 추출되고 동일한 계 산 기능들이 실행되어 GEF를 도출할 수 있다는 점에 유의한다. 구현들에서, 검증 코호트 VDAX는, 각각의 상응하는 MDB에 대해, MDB, MDC에서 MDB에 선행하는 선행 MDB, 및 MDB에 대응하는 GEF에 기초하여, CG-도출된 검증값을 생성할 수 있다. 예를 들어, 일부 실시예에서, 검증 코호트 VDAX는 MDB 창작자 코호트의 마스터 확증 모듈과 동일한 방식으로 MDB 및 선행 MDB에 대응하는 링킹값을 결정할 수 있다. 일부 실시 예에서, 검증 코호트 VDAX는 창작자 코호트 VDAX의 마스터 확증 모듈에 의해 이용되었던 것 과 동일한 계산 기능 세트에 GEF 및 링킹값을 입력함으로써 CG-도출된 검증값을 생성할 수 있다. MDB와 선행 MDB의 내용들이 변경되지 않았다고 가정하면, 검증 코호트 VDAX는 창작자 코호트 VDAX가 결정한 것 과 동일한 CG-도출된 검증값을 획득할 수 있다. 결정된 CG-도출된 검증값이 MDB 내의 CG-도출된 검증값과 정합 하면, 검증 코호트 VDAX 2932는 MDB를 검증한다. MDB를 검증하는 것에 응답하여, 검증 코호트 VDAX는 검 증된 MDB에 대응하는 검증 기록을 생성할 수 있다. 논의된 바와 같이, 검증 기록은 검증 코호트에 의해 유지되 는 검증 체인의 검증 블록에 유지되거나 및/또는 MDB 창작자(또는 디지털 생태계의 임의의 다른 적절한 코호트)에게 제공될 수 있다. 검증 기록은, 검증된 MDB, 검증 코호트와 창작자 코호트 양쪽 모두에 의해 결정 된 CG-도출된 검증값, 기타 임의의 적절한 메타데이터를 나타낼 수 있다. 나중에 MDB 창작자 코호트의 MDC 무 결성이 감사받거나 기타의 방식으로 의심받는 경우, MDC에 대응하는 검증 기록들은 MDC의 이전에 검증된 부분들 이 어떤 방식으로든 변경되었는지를 입증하는데 이용될 수 있다. MDC들의 CG 기반의 공증 이제 도 30과 관련하여 도 28의 VDAX를 참조하면, 원장 기반의 생태계의 일부 예시적인 구현에서, 원장 기반의 생태계의 VDAX들은 MDB(또는 MDB의 일부)가 주어지면 CG-도출된 값들(예컨대, CG-도출된 창작자 값들 및/또는 CG-도출된 공증 값들)을 생성하도록 구성된다. 이들 예시적인 구현들 중 일부에서, MDB 창작자 코호트의 VDAX는 원장 기반의 애플리케이션 으로부터 MDB(예컨대, MDB 자체 또는 그 일부)에 관련된 입력 데이터를 수신할 수 있고, 입력 데이 터, 창작자 코호트의 게놈 분화 객체, 및 GRI에 기초하여 CG-도출된 창작자 값을 결정할 수 있다. 일부 구현에서, GRI는 비밀 GRI일 수 있어서, 공증 코호트는 다른 코호트들로부터의 MDB들을 공증하는데 이용할 고유 한 GRI를 갖는다. 다른 구현들에서, GRI는 다른 코호트들로부터의 MDB들을 공증하기 위해 여러 공증 코호트에 의해 이용될 수 있다. 이들 구현들에서, 소정의 엔클레이브에 참여하는 공증 코호트들이 엔클레이브 코호트들 에 의해 생성된 MDB들을 공증하는데 이용되는 GRI를 수신하도록, 반-비밀 GRI가 엔클레이브 레벨에서 교환될 수 있다. 예시적인 구현들에서, 공증 코호트의 VDAX는 또한, 원장 기반의 애플리케이션으로부터 MDB(예컨대, MDB 자체 또는 그 일부)에 관한 입력 데이터를 수신할 수 있고, 입력 데이터, 공증 코 호트의 게놈 분화 객체, 및 GRI에 기초하여, CG-도출된 공증값을 결정할 수 있다. 이들 구현들에서, 창 작자 코호트는 MDB가 주어지면 CG-도출된 창작자 값을 생성할 수 있고 하나 이상의 공증 코호트 는 동일한 MDB가 주어지면 각각의 공증값들을 생성할 수 있다(창작자 코호트들과 공증 코호트들 양 쪽 모두가 동일한 GRI 및 동일한 게놈 데이터를 이용하지 않는 한, 정합하는 값들이 아닐 수 있음). 일부 구현 에서, CG-도출된 창작자 값과 하나 이상의 CG-도출된 공증 값이 MDB에 기입됨으로써, 공증된 MDB를 생성할 수 있다. MDC의 일부의 무결성을 보장하는 검증과는 달리, 공증은 개개의 MDB들의 무결성을 보장하는데 이용될 수 있다. 예를 들어, 각각의 공증 코호트는 MDB를 공증할 수 있고, 공증된 MDB의 사본을 CG-도 출된 창작자 값 및 CG-도출된 공증 값(공증 코호트에 의해 생성됨)과 함께 MDB에 저장할 수 있어서, 공증된 MDB 내용들의 무결성이 의문시되는 경우, MDB를 공증한 공증 코호트(들)이 내용이 변경되었는지의 여부를 증명할 수 있게 한다. 예를 들어, MDB 창작자 코호트와 2개 이상의 공증 코호트 세트가 MDB를 디지털 방식으로 공증하고 나중에 당사자가 MDB의 내용이 변경되었다고 주장 하는 경우, 창작자 코호트와 공증 코호트들 각각은 공증된 MDB를 디지털 방식으로 공증하는데 이용된 각각의 CG-도출된 값들을 재계산하고 재계산된 값들을 공증된 MDB 내의 각각의 값들과 비교하여 MDB의 내 용들이 변경되었는지를 결정할 수 있다. 논의된 바와 같이, 일부 구현에서, MDB 창작자 코호트의 VDAX 및 공증 코호트의 VDAX(294 2)는, MDB 창작자 코호트에 의해 생성된 미공증된 MDB를 획득하고 MDB의 내용에 기초하여 각각의 CG-도출 된 값(예를 들어 창작자 값 또는 공증값)을 생성하도록 구성될 수 있다. CG-도출된 창작자 값 또는 CG-도출된 공증값을 생성하기 위한 전체 프로세스는 상당히 유사하다는 것을 이해해야 한다. 따라서, 이하의 설명은 공증 코호트에 관하여 설명되지만, CG-도출된 창작자 값을 생성하기 위해 MDB 창작자 코호트의 VDAX에도 적용될 수 있다. 실시예들에서, 공증 코호트의 VDAX(\"공증 VDAX\"라고도 함)는, MDB의 내용들, 공증 VDAX에 할당된 게놈 분화 객체(예컨대, XNA 객체)고, 및 공증 VDAX에 의해 보유된 비밀 또는 반-비밀 GRI에 기초하여 CG-도출된 공증값을 생성함으로써 미공증된 MDB를 공증할 수 있다. 이들 구현들에서, 공증 VDAX는, 미공증된 MDB에 관하여 추출된 서열, 공증 VDAX의 게놈 분화 객체(예컨대, XNA 객체), 및 공증 VDAX에 의해 보유된 GRI에 기초하 여 GEF를 생성한다. 구현들에서, 공증 VDAX는 미공증된 MDB의 메타데이터로부터 서열을 추출할 수 있다(예컨대, 미공증된 MDB의 메타데이터로부터 연속 또는 비연속 비트 또는 바이트 세트). 이들 구현들 중 일부에서, 공증 VDAX는, (예를 들어, 도 22 또는 도 23과 관련하여 설명된 바와 같이) 추출된 서열, VDAX에 의해 보유된 비밀 또는 반-비밀 GRI, 및 VDAX의 게놈 분화 객체에 기초하여 미공증된 MDB에 대응하는 GEF를 생성할 수 있다. 이들 구현들 중 일부에서, 공증 VDAX는 그 게놈 분화 객체 를 수정할 수 있고, (예컨대, 도 23과 관련하여 설명된 바와 같이) 각각의 미공증된 MDB에 대해, 서열, GRI, 및 공증 VDAX의 수정된 게놈 분화에 기초하여 각각의 GEF를 생성할 수 있다. 다른 구현들에서, 공 증 VDAX는, (예컨대, 도 22와 관련하여 설명된 바와 같이) 추출된 서열, 비밀 또는 반-비밀 GRI, 및 공증 VDAX의 미수정된 게놈 분화에 기초하여 각각의 미공증된 MDB에 대응하는 GEF를 생성할 수 있다. 공증 VDAX는 본 개시내용의 범위를 벗어나지 않고 다른 적절한 서열 맵핑 기술들을 이용하여 GEF를 생성 할 수 있다는 것을 이해해야 한다. 구현들에서, 공증 VDAX(예컨대, 그 마스터 확증 모듈)는 GEF 및 미공증된 MDB(예컨대, 전체 미공증 된 MDB 또는 그 특정한 부분들)에 기초하여 공증값을 생성할 수 있다. 이들 구현들 중 일부에서, 공증 VDAX는 미공증된 MDB에 대응하는 GEF를 입력으로서 이용하여 하나 이상의 계산 기능(예컨대, 암호 기반, 암호 없는, 또는 하이브리드 기능(들))을 미공증된 MDB에 적용하여 미공증된 MDB에 대한 공 증값을 획득할 수 있다. 이들 구현들 중 일부에서, 공증 VDAX는 입력으로서 GEF를 이용하여 MDB의 \"페이 로드\"를 포함하는 MDB의 부분에 계산 기능을 적용함으로써 미공증된 MDB에 하나 이상의 계산 기능 을 적용하여 공증값을 획득할 수 있다. 이들 구현들에서, MDB의 일부에 저장된 자료 데이터(예컨대, 페 이로드)가 후속해서 변경되지 않는 한 공증값은 변경되지 않을 것이다. 대안으로서, 공증 VDAX는 공증값 을 획득하기 위해 GEF를 입력으로서 이용하여 전체 미공증된 MDB에 하나 이상의 계산 기능을 적용할 수 있다. 설명의 목적상, MDB에 기초하여 공증값을 생성하는 것(또는 창작자 값을 생성하는 것)은, MDB의 실질적인 부분, 미공증된 MDB 전체, MDB의 해시값 등을 이용하여 공증값을 생성하는 것을 지칭할 수 있다. 일부 구현에서, 공증 VDAX는 GEF를 키로서 이용하여 미공증된 MDB의 적어도 일부(예컨대, MDB의 실질적인 부분 또는 미공증된 MDB 전체)를 암호화하거나 명료화(예컨대, XOR) 할 수 있고, 이에 의해 결과적인 값은 공증값으로 이용되거나 공증 VDAX이 결과 값으로부터 공증값을 추 가로 도출한다. 일부 구현에서, 공증 VDAX는 해시 기능에 대한 입력으로서 GEF를 이용하여 미공증된 MDB의 적어도 일부를 해시할 수 있고, 이에 의해 결과적인 해시값이 공증값으로서 이용된다. 공증 VDAX는, 본 개시내용의 범위를 벗어나지 않고, 하이브리드 방식들을 포함한, 대응하는 GEF에 기초하여 다 른 적절한 방식들로 미공증된 MDB의 공증값을 결정할 수 있다는 것을 이해해야 한다. 일부 구현에서, 공증 코호트(예컨대, 공증 VDAX 또는 원장 기반의 애플리케이션)는 미공증된 MDB를 공증값으로 디지털 방식으로 공증함으로써, 고유하고 VDAX에 의해서만 재생성될 수 있는 값 으로 MDB를 공증할 수 있다. 창작자 코호트는 또한, 창작자 VDAX 및 창작자 VDAX의 게놈 분화 객체에 의해 유지되는 GRI를 이용하여 CG-도출된 창작자 값과 동일한 방식으로 MDB를 디지털 방식으로 공증할 수도 있다는 것을 이해해야 한다. 일부 구현에서, MDB 창작자 코호트 및 하나 이상의 공증 코호트는 상이한 게놈 커뮤니티들에 속할 수 있 고 상관된 게놈 데이터(예컨대, 상관된 분화 객체들)를 갖지 않을 수 있다는 점에 유의한다. 이러한 시나리오 들에서도, 공증 코호트는 MDB를 공증할 수 있는데, 이것은 CG-도출된 공증값이 공증 코호트 가 보유한 비밀 또는 반-비밀 정보에 기초하여 생성되기 때문이다. 이러한 방식으로, 공증 코호트는 신 뢰없는 생태계들에서도 공증된 MDB의 내용들이 변경되지 않았음을 독립적으로 검증할 수 있다. 예를 들 어, 공증된 MDB의 무결성이 의심되는 경우, 공증 코호트는 MDB의 CG-공증값을 재결정하고 재 결정된 공증값을 MDB를 공증하는데 이용되는 공증값과 비교함으로써 공증 후에 MDB의 내용들이 변경되었는지를 결정할 수 있다. CG-도출된 공증값들이 정합하면, 공증 코호트는 MDB 2926의 무결성을 검증할 수 있다. 구현들에서, 공증 코호트는 공증된 MDB를 MDB 창작자 코호트에 제공할 수 있고, MDB 창작자 코호트 는 공증된 MDB를 자신의 MDC 사본에 추가할 수 있다. 이들 실시예들에서, MDB 창작자는, CG-도출된 공증 값들이 MDB가 변경되거나 변조되지 않았다는 검증가능한 증거를 제공할 수 있도록, 공증 코호트들에 의해 생성 된 특정한 MDB에 대한 CG-도출된 공증값(들)을 MDB에 또는 MDB와 관련하여(예컨대, MDC의 사이드 체인에 또는 MDC의 메인 체인 내의 또 다른 MDB에) 저장할 수 있다. 예를 들어, 일부 실시예에서 공증 코호트는 MDB의 공증 을 검증하라는 요청을 수신할 수 있다. 이들 예시적인 실시예들에서, 공증 코호트는 MDB(또는 그 소정의 내용 들)를 수신할 수 있고 CG-도출된 공증값을 재생성하려고 시도할 수 있다. 공증 코호트가 CG-도출된 공증값을 재생성할 수 있는 경우, 공증 코호트는 MDB가 변경되었거나 변조되지 않았음을 확정할 수 있다. 공증 코호트가 MDB를 공증하는데 이용된 CG-도출된 공증값과 정합하지 않는 값을 생성하는 경우, 공증 코호트는 MDB가 변경되 었음을 확정할 수 있다. 일부 실시예에서, 각각의 공증 코호트는 또한, 공증된 MDB를 그들 각각의 MDC들(예컨대, 원장간 체 인들)에 저장할 수 있다. 이들 실시예들에서, 디지털 생태계의 각각의 상응하는 코호트에 의해 유지되는 MDC들 이 반드시 합동일 필요는 없다는 점에 유의해야 한다; 그러나 각각의 공증된 MDB는 MDB 창작자 코호트 및 MDB를 공증한 각각의 공증 코호트에 의해 유지되는 각각의 MDC에 저장될 수 있다. 또한, 디지털 생태계의 구성에 따라, MDB와 관련하여 상이한 공증 코호트들에 의해 생성된 CG-도출된 공증 값들은 공증 코호트들 사이에서 공유될 수 있고 후속해서 각각의 공증 코호트의 각자의 MDB 사본에 기입되어, 공증된 MDB의 무결성 더욱 보장한다. 일부 예시적인 실시예에서, 원장 기반의 디지털 생태계는, 도 30의 예에 도시된 바와 같이, 선택사항으로서 공 증과 검증 양쪽 모두를 지원할 수 있다. 이들 예들에서, 검증 코호트의 VDAX(\"검증 VDAX\"라 고 함)는, 도 29와 관련하여 설명된 바와 같이, 코호트들을 대신하여 MDC의 부분들을 검증할 수 있다. 이들 구 현들에서, 검증 VDAX는 생태계 내의 또 다른 코호트에 의해 유지되는 MDC의 미검증된 부분을 검증하도록 구성될 수 있다. 이들 구현들 중 일부에서, 검증 VDAX는 일련의 순차적 MDB들을 포함하는 코호트(예컨대, 창작자 코호트)로부터 MDC의 미검증된 부분을 수신할 수 있고, 여기서 MDC의 미검증된 부 분 내의 MDB들 중 적어도 일부는 하나 이상의 공증 코호트에 의해 공증되었다. 이들 구현들에서, MDC의 미검 증된 부분은 공증된 MDB들을 포함할 수 있고, 미공증된 MDB들(예컨대, 공증 코호트에 의한 공증을 요구하지 않는 MDB들)을 더 포함할 수 있다. 이들 구현들에서, 검증 코호트가 MDC의 미검증된 부분을 수 신할 때, 검증 코호트는, 도 29와 관련하여 설명된 바와 같이, 창작자 코호트와 검증 코호트 양쪽 모두에게 알려진 GRI를 이용하여 MDC의 미검증된 부분 내의 각각의 순차적 MDB를 검증할 수 있다. 이러한 방식 으로, MDC에 포함되고 후속해서 하나 이상의 검증 코호트에 의해 검증되는 공증된 MDB들은 불변이 된다. 일부 구현에서, 검증 코호트는 또한 공증 코호트일 수 있어서, 검증 VDAX가 (도 29 에 대해 설명된 바와 같이) MDC들을 검증하고 MDB들을 공증할 수 있다는 것을 이해해야 한다. 대안으로서, 일 부 구현에서, 검증 코호트는 MDC들을 검증하도록 구성될 수 있는 반면, 공증 코호트는 MBD들을 공 증하도록 구성될 수 있다. 일부 예시적인 구현에서, 검증 코호트(또는 원장 기반의 디지털 생태계의 임의의 다른 적절한 코호트)는 공증된 MDB의 무결성을 확정하도록 구성될 수 있다. 이들 구현들에서, 검증 코호트는 MDB를 공증한 공증 코호트(들)에 검증 요청을 제공할 수 있다. 이들 구현들에서, MDB가 공증 코호트에 의해 공증된 이후 변경되지 않았음을 확정하기 위해 검증 요청이 공증 코호트에 전송된다. 이들 구현들 중 일부에서, 공증 코호트는 검증 코호트가 검증하고 있는 공증된 MDB의 사본(예컨대, 창작 자 코호트로부터의 MDB)을 수신할 수 있다. 일부 구현에서, 확정 요청은 확정될 공증된 MDB(292 6)를 포함할 수 있고 공증 코호트에 의해 MDB를 공증하는데 이용된 공증값을 더 포함할 수 있다. 이들 구현들에서, 공증 VDAX는 수신된 MDB가 주어지면 공증값을 재계산할 수 있고 재계산된 공증값 에 기초하여 확정 요청에 대한 응답을 반환할 수 있다. 일부 구현에서, 공증 코호트는 응답으로서 재계 산된 공증값을 검증 코호트에 반환할 수 있다. 이들 구현들에서, 검증 코호트는 응답을 수신할 수 있고 재계산된 공증값이 공증 코호트에 의해 MDB를 공증하는데 이용된 공증값과 정합하는지를 결정 할 수 있다. 만일 정합한다면, 검증 코호트는 MDB의 무결성을 확정할 수 있다. 일부 구현에서, 공증 코호트는 재계산된 공증값이 MDB를 공증하는데 이용된 공증값과 정합하는지를 결정하도록 구 성될 수 있다. 재계산된 공증값이 MDB를 공증하는데 이용된 공증값과 정합하는 경우, 공증 코호트는 MDB의 무결성을 확정할 수 있고 확인을 응답에 포함시킬 수 있다. 재계산된 값이 MDB를 공증 하는데 이용된 공증값과 정합하지 않는 경우, MDB는 또한, MDB가 변경되었는지 및 블록이 누구에 의해 변경되었는지를 결정할 수 있다. 예를 들어, 여러 공증 코호트가 재생성된 값들이 MBD를 공 증하는데 이용된 공증값들과 정합하지 않는다고 결정하는 경우, MDB 창작자 코호트(또는 악의적인 행위자)가 MDB를 변경했다고 결정할 수 있다. 도 28 내지 도 30의 전술된 예들은 원장 기반의 디지털 생태계의 예시적인 구성들로서 제공된 것임을 이해해야 한다. CG-ESP의 상이한 생태계들 및 구현들 내에서, 게놈 데이터 세트들, 공증 메커니즘들, 검증 메커니즘들, 및/또는 CG-ESP의 계산 기능은 본 개시내용의 범위를 벗어나지 않고 커뮤니티 소유자에 의해 변경될 수 있다. 또한, 도 28 내지 도 30의 예들은 MDC들을 유지하기 위한 상이한 구현들에 관한 것이지만, Cyphergenics는 기존 의 원장 기반의 생태계들에 적용될 수 있다. 예를 들어, Cyphergenics는 기존 프로토콜들(예컨대, Ethereum 블 록체인, Hyperledger Fabric 블록체인, R3 Corda 블록체인, Ripple 블록체인, Quorum 블록체인, 나중에 개발된 블록체인들 등) 또는 계층화된 프로토콜 세트에 부합하는 디지털 원장에 적용될 수 있다. 결론 전술된 내용에 비추어, 본 개시내용 전체에 걸쳐 설명된 기술들은 기존의 암호화 프레임워크들 내에서 구현되도 록 개조될 수 있다는 점에 유의한다. 또한, 설명된 프레임워크들의 모듈성은 특정한 모듈들 및 CG 기반의 기술 들을 추가 개발을 위한 기회를 제공한다. 더 많은 구성들이 개발됨에 따라, CG-ESP의 모듈성은 또 다른 난독화 계층을 제공하여, CG-ESP의 보안 피처들을 더욱 향상시킨다. 배경 설명은 단순히 맥락을 위해 제시된 것이며, 반드시 충분히 잘 이해되거나, 일상적이거나, 관례적일 필요는 없다. 또한, 배경 설명은 선행 기술로서 인정되거나 인정되지 않는 것에 대한 시인은 아니다. 사실상, 배경 설명의 일부 또는 전부는 본 기술 분야에서 보통은 알려지지 않은 명명된 발명자들에 의한 연구일 수도 있다. 요소들(예컨대, 모듈들, 회로 요소들, 반도체 층들 등) 사이의 (공간적 및/또는 전기적 등의) 물리적 및 기능적 관계들은 다양한 용어를 사용하여 설명된다. \"직접적\"인 것이라고 명시적으로 설명하지 않는 한, 제1 요소와 제2 요소 사이의 관계가 설명될 때, 그 관계는 (i) 제1 요소와 제2 요소 사이에 다른 중간 요소가 존재하지 않 는 직접적인 관계와 (ii) 제1 요소와 제2 요소 사이에 하나 이상의 중간 요소가 존재하는 간접적인 관계 양쪽 모두를 포괄한다. 예시적인 관계 용어들로는, \"인접한\", \"전송하는\", \"수신하는\", \"접속된\", \"관여된\", \"결합 된\", \"이웃의\", \"옆에\", \"상단\", \"위\", \"아래\", “맞붙은” 및 “배치된”이 포함된다. 상세한 설명은 단지 예시를 위한 특정한 예들을 포함하며, 본 개시내용이나 그 적용성을 제한하지 않는다. 예 들은 완전한 목록을 제공하기 위한 것이 아니라, 그 대신에, 단순히 현재 제시된 및 구상된 미래의 청구항들의 전체 범위가 발명자들의 소유임을 보여주기 위한 것이다. 예들의 수정들, 조합들, 및 균등물들은 본 개시내용 의 범위 내에 있다. 본 명세서의 어떤 언어도 임의의 청구되지 않은 요소가 본 개시내용의 실시에 대해 필수적 이거나 결정적이라는 것을 나타내는 것으로서 해석되어서는 안 된다. \"예시적\"이라는 용어는 단순히 \"예\"를 의미하며 최상의 또는 선호되는 예를 나타내는 것은 아니다. \"세트\"라는 용어는 반드시 빈 세트를 제외하는 것은 아니다 ―즉, 어떤 상황에서는 \"세트\"는 0개의 요소를 가질 수도 있다. \"비어 있지 않은 세트\"라는 용어는 빈 세트의 제외를 나타내기 위해 사용될 수 있다 ―즉, 비어 있지 않은 세트 는 반드시 하나 이상의 요소를 가져야 한다. \"서브세트\"라는 용어는 반드시 적절한 서브세트를 요구하는 것은 아니다. 즉, 제1 세트의 \"서브세트\"는 제1 세트와 동일 범위일(동등할) 수 있다. 또한, \"서브세트\"라는 용어 는 반드시 빈 세트를 제외하는 것은 아니다 ― 어떤 상황에서는 \"서브세트\"는 0개의 요소를 가질 수도 있다. \"A, B, C 중 적어도 하나”라는 문구는 비배타적 논리 OR를 이용하는 논리적 (A OR B OR C)를 의미하는 것으로 해석되어야 하며, “A 중 적어도 하나”, B 중 적어도 하나, C 중 적어도 하나”를 의미하는 것으로 해석되어서 는 안 된다. 본 개시내용 및 청구항들을 설명하는 맥락에서 용어들 \"a\", \"an\", \"the\" 및 유사한 지시어의 사용 은, 명시적으로 또는 문맥에 의해 모순되지 않는 한, 단수 및 복수 양쪽 모두를 포괄한다. 달리 명시하지 않는 한, \"포함하는\", \"갖는\", \"함께\", \"내포하는\", 담고 있는\"이라는 용어들과 그 변형들은 \"~를 포함하지만 그것으 로 제한되지 않는\"을 의미하는 개방형 용어들이다. 외국 및 국내 특허 출원들 및 특허들을 포함한, 본 개시내용에서 참조된 각각의 간행물은 그 전체내용이 참조에 의해 본 명세서에 포함된다. 실시예들 각각이 소정의 피처들을 갖는 것으로 위에서 설명되었지만, 본 개시내용의 임의의 실시예와 관련하여 설명된 이들 피처들 중 임의의 하나 이상은 임의의 다른 실시예의 피처들에서 구현되거나 및/또는 그 조합이 명 시적으로 설명되지 않더라도 이들과 결합될 수 있다. 즉, 설명된 실시예들은 상호배타적이지 않으며, 여러 실 시예들의 치환은 본 개시내용의 범위 내에 유지된다. 하나 이상의 요소(예컨대, 방법 내의 단계들, 명령어들, 행위들 또는 동작들)는 본 개시내용의 원리들을 변경하 지 않고 상이한 순서로(및/또는 동시에) 실행될 수 있다. 기술적으로 실행가능하지 않은 경우가 아닌 한, 직렬 인 것으로서 설명된 요소들은 부분적으로 또는 완전히 병렬로 구현될 수 있다. 마찬가지로, 기술적으로 실행가 능하지 않은 경우가 아닌 한, 병렬인 것으로서 설명된 요소들은 부분적으로 또는 완전히 직렬로 구현될 수 있다. 본 개시내용은 청구된 요소들에 대응하는 구조들을 설명하지만, 이들 요소들은 명시적으로 \"~를 위한 수단\"이라 는 기표를 이용하지 않는 한 수단 + 기능 해석을 반드시 호출하는 것은 아니다. 달리 표시되지 않는 한, 값들 의 범위들의 언급들은 그 범위 내에 속하는 각각의 별개 값을 개별적으로 언급하는 약식 방식으로서 역할할 뿐 이며, 이에 의해 각각의 별개 값이 마치 개별적으로 언급된 것처럼 본 명세서에 포함된다. 도면들은 본 개시내용의 요소들을 상이한 기능 블록들 또는 행위 블록들로 구분하지만, 이들 구분들은 단지 예 시를 위한 것이다. 본 개시내용의 원리들에 따르면, 별개로 도시된 여러 블록으로부터의 일부의 또는 모든 기 능이 단일 기능 블록으로 구현될 수 있도록 기능은 다른 방식들로 결합될 수 있다; 마찬가지로, 단일 블록에 도 시된 기능은 여러 블록으로 분리될 수 있다. 상호배타적이라고 명시적으로 언급되지 않는 한, 상이한 도면들에 도시된 피처들은 본 개시내용의 원리들에 따라 결합될 수 있다. 도면들에서, 참조 번호들은 동일한 요소들을 식별하기 위해 재사용되거나, 유사한 기능을 구현하는 요소들을 단 순히 식별할 수도 있다. 명령어들 또는 방법 단계들의 넘버링 또는 기타의 라벨링은 고정된 순서를 나타내기 위한 것이 아니라 편리한 참조를 위해 이루어진다. 도면들에서, 화살표의 방향은, 화살표 머리에 의해 표시된 바와 같이, 일반적으로 도면에서 관심대상 (데이터 또는 명령어들 등의) 정보의 흐름을 나타낸다. 예를 들어, 요소 A와 요소 B가 다양한 정보를 교환하지만, 요소 A로부터 요소 B에 전송되는 정보가 예시와 관련이 있는 경 우, 화살표는 요소 A로부터 요소 B쪽으로 가리킬 수 있다. 이러한 단방향 화살표는 요소 B로부터 요소 A로는 어떠한 다른 정보도 전송되지 않음을 암시하는 것은 아니다. 한 예로서, 요소 A로부터 요소 B에 전송된 정보에 대해, 요소 B는 요소 A에게 요청들 및/또는 확인응답들을 보낼 수 있다. 특별 목적 시스템은 하드웨어 및/또는 소프트웨어를 포함하고, 장치, 방법 또는 컴퓨터 판독가능한 매체의 측면 에서 설명될 수 있다. 다양한 실시예에서, 기능은 소프트웨어와 하드웨어 사이에서 상이하게 할당될 수 있다. 예를 들어, 일부 기능은, 한 실시예에서는 하드웨어에 의해, 또 다른 실시예에서는 소프트웨어에 의해 구현될 수 있다. 또한, 소프트웨어는 하드웨어 구조들에 의해 인코딩될 수 있고, 하드웨어는 소프트웨어-정의된 네트 워킹 또는 소프트웨어-정의된 무선 등의, 소프트웨어에 의해 정의될 수 있다. 청구항들을 포함한, 본 출원에서, 모듈이라는 용어는 특별-목적 시스템을 지칭한다. 모듈은 하나 이상의 특별 목적 시스템에 의해 구현될 수 있다. 하나 이상의 특별-목적 시스템은 또한, 다른 모듈들의 일부 또는 전부를 구현할 수 있다. 청구항들을 포함한 본 출원에서, 모듈이라는 용어는 제어기 또는 회로라는 용어로 대체될 수 있다. 청구항들을 포함한 본 출원에서, 플랫폼이라는 용어는 기능 세트를 제공하는 하나 이상의 모듈을 지칭한 다. 청구항들을 포함한 본 출원에서, 시스템이라는 용어는 모듈 또는 특별-목적 시스템이라는 용어와 서로 바 꾸어 사용될 수 있다. 특별-목적 시스템은 운영자에 의해 지시되거나 제어될 수 있다. 특별-목적 시스템은, 운영자가 소유한 자산들, 운영자가 임대한 자산들, 및 제3자 자산들 중 하나 이상에 의해 호스팅될 수 있다. 자산들은, 비공개, 커뮤니 티, 하이브리드 클라우드 컴퓨팅 네트워크 또는 클라우드 컴퓨팅 환경이라고 지칭될 수 있다. 예를 들어, 특별 -목적 시스템은, SaaS(Software as a Service), PaaS(Platform as a Service), 및/또는 IaaS(Infrastructure as a Service)를 제공하는 제3자에 의해 부분적으로 또는 완전히 호스팅될 수 있다. 특별-목적 시스템은 애자 일 개발 및 운영(DevOps) 원칙들을 이용하여 구현될 수 있다. 실시예들에서, 특별-목적 시스템의 일부 또는 전 부는 다중 환경 아키텍쳐에서 구현될 수 있다. 예를 들어, 다중 환경들로는, 하나 이상의 프로덕션 환경, 하나 이상의 통합 환경, 하나 이상의 개발 환경 등이 포함될 수 있다. 특별-목적 시스템은 모바일 디바이스를 이용하여 또는 모바일 디바이스에 의해 부분적으로 또는 완전히 구현될 수 있다. 모바일 디바이스들의 예들로는, 네비게이션 디바이스들, 셀 전화들, 스마트 폰들, 모바일 전화들, 모 바일 개인 정보 단말기들, 팜탑들, 넷북들, 호출기들, 전자책 리더기들, 태블릿들, 음악 재생기들 등이 포함된다. 특별-목적 시스템은 네트워크 디바이스를 이용하여 또는 네트워크 디바이스에 의해 부분적으로 또는 완전 히 구현될 수 있다. 네트워크 디바이스들의 예들로는, 스위치들, 라우터들, 방화벽들, 게이트웨이들, 허브들, 기지국들, 액세스 포인트들, 리피터들, 헤드엔드들, 사용자 장비, 셀 사이트들, 안테나들, 타워들 등이 포함된 다. 특별-목적 시스템은 다양한 폼 팩터 및 기타 특성들을 갖는 컴퓨터를 이용하여 부분적으로 또는 완전히 구현될 수 있다. 예를 들어, 컴퓨터는, 개인용 컴퓨터로서, 서버로서 등으로 특성규정될 수 있다. 컴퓨터는 노트북, 넷북 등과 같이 휴대할 수 있다. 컴퓨터는, 모니터, 라인 프린터, 액정 디스플레이(LCD), 발광 다이오드(LED) 들 등의 임의의 출력 디바이스를 갖거나 갖지 않을 수도 있다. 컴퓨터는, 키보드, 마우스, 터치패드, 트랙패드, 컴퓨터 비전 시스템, 바코드 스캐너, 버튼 배열 등의 임의의 입력 디바이스를 갖거나 갖지 않을 수도 있다. 컴퓨터는, Microsoft Corporation의 WINDOWS 운영 체제, Apple, Inc.의 MACOS 운영 체제, 또는 LINUX 운영 체제의 변형판 등의 범용 운영 체제를 실행할 수 있다. 서버들의 예들로는, 파일 서버, 인쇄 서버, 도메 인 서버, 인터넷 서버, 인트라넷 서버, 클라우드 서버, 서비스형 인프라 서버, 서비스형 플랫폼 서버, 웹 서버, 보조 서버, 호스트 서버, 분산형 서버, 장애조치 서버, 및 백업 서버가 포함된다. 하드웨어라는 용어는, 처리 하드웨어, 스토리지 하드웨어, 네트워킹 하드웨어, 기타의 범용 및 특별-목적 컴포 넌트들 등의 컴포넌트들을 포괄한다. 이들은 상호배타적인 범주들이 아님에 유의한다. 예를 들어, 처리 하드 웨어는 스토리지 하드웨어를 통합할 수 있고 그 반대의 경우도 마찬가지이다. 컴포넌트의 예들로는, 집적 회로(IC)들, 주문형 집적 회로(ASIC)들, 디지털 회로 요소들, 아날로그 회로 요소들, 조합 로직 회로들, 필드 프로그래머블 게이트 어레이(FPGA)들 등의 게이트 어레이들, 디지털 신호 프로 세서(DSP)들, 복합 프로그래밍가능한 로직 디바이스(CPLD)들 등이 있다. 하드웨어의 여러 컴포넌트는, 단일 다이 상에, 단일 팩키지로, 또는 단일 인쇄 회로 보드나 로직 보드 상에 등 에 통합될 수 있다. 예를 들어, 하드웨어의 여러 컴포넌트는 시스템 온 칩(system-on-chip)으로서 구현될 수 있다. 컴포넌트 또는 통합된 컴포넌트 세트는, 칩, 칩셋, 칩렛, 또는 칩 스택이라고 지칭될 수 있다. 시스템 온 칩의 예들로는, RF(Radio Frequency) 시스템 온 칩, 인공 지능(AI) 시스템 온 칩, 비디오 처리 시스템 온 칩, 장기 온 칩(organ-on-chip), 양자 알고리즘 시스템 온 칩 등이 포함된다. 하드웨어는 센서들로부터의 신호들을 통합하거나 및/또는 수신할 수 있다. 센서들은, 온도, 압력, 마모, 빛, 습도, 변형, 팽창, 수축, 편향, 구부러짐, 스트레스, 스트레인, 하중 지지, 수축, 전력, 에너지, 질량, 위치, 온도, 습도, 압력, 점도, 액체 흐름, 화학물질/가스 존재, 소리, 및 공기 품질을 포함한 상태들의 관찰 및 측정 을 허용한다. 센서로는, 전하 결합 소자(CCD) 또는 상보성 금속 산화물 반도체(CMOS) 센서 등의, 가시 및/또는 (열 등의) 비가시 파장들의 이미지 및/또는 비디오 캡처가 포함될 수 있다. 처리 하드웨어의 예들로는, 중앙 처리 유닛(CPU), 그래픽 처리 유닛(GPU), 근사 컴퓨팅 프로세서, 양자 컴퓨팅 프로세서, 병렬 컴퓨팅 프로세서, 신경망 프로세서, 신호 프로세서, 디지털 프로세서, 데이터 프로세서, 임베디 드 프로세서, 마이크로프로세서, 및 코프로세서가 포함된다. 코프로세서는, 속도 또는 전력 소비 등의, 추가 처리 기능들 및/또는 최적화들을 제공할 수 있다. 코프로세서의 예들로는, 수학 코프로세서, 그래픽 코프로세 서, 통신 코프로세서, 비디오 코프로세서, 및 인공지능(AI) 코프로세서가 포함된다. 프로세서는 다중 스레드의 실행을 가능케할 수 있다. 이들 다중 스레드들은 상이한 프로그램들에 대응할 수 있 다. 다양한 실시예에서, 단일 프로그램은 프로그래머에 의해 다중 스레드로 구현될 수 있거나 처리 하드웨어에 의해 다중 스레드로 분해될 수 있다. 스레드들은 프로세서의 성능을 향상시키고 애플리케이션의 동시 동작을 용이화하기 위해 동시에 실행될 수 있다. 프로세서는 팩키징된 반도체 다이로서 구현될 수 있다. 다이는 하나 이상의 처리 코어를 포함하고, 캐시 등의 추가 기능 블록들을 포함할 수 있다. 다양한 실시예에서, 프로세서는 단일 팩키지로 결합되거나 별개로 팩키징될 수 있는 다중 다이에 의해 구현될 수 있다. 네트워킹 하드웨어는 하나 이상의 인터페이스 회로를 포함할 수 있다. 일부 예에서, 인터페이스 회로(들)는 하 나 이상의 네트워크에 직접 또는 간접적으로 접속하는 유선 또는 무선 인터페이스들을 구현할 수 있다. 네트워 크들의 예들로는, 셀룰러 네트워크, LAN(Local Area Network), WPAN(Wireless Personal Area Network), MAN(Metropolitan Area Network), 및/또는 WAN(Wide Area Network)이 포함된다. 네트워크들은, 지점간 기술과 메시 기술 중 하나 이상을 포함할 수 있다. 네트워킹 컴포넌트들에 의해 전송되거나 수신되는 데이터는 동일하 거나 상이한 네트워크들을 통과할 수 있다. 네트워크들은 MPLS(Multiprotocol Label Switching) 및 VPN(가상 사설망) 등의 기술들을 이용하여 WAN 또는 지점간 임대 회선들을 통해 서로 접속될 수 있다.셀룰러 네트워크들의 예들로는, GSM, GPRS, 3G, 4G, 5G, LTE 및 EVDO가 포함된다. 셀룰러 네트워크는, FDMA(Frequency Division Multiple Access) 네트워크 또는 CDMA(Code Division Multiple Access) 네트워크를 이용하여 구현될 수 있다. LAN의 예들로는, IEEE(Institute of Electrical and Electronics Engineers) 표준 802.11-2020(WIFI 무선 네트워킹 표준이라고도 알려짐) 및 IEEE 표준 802.3-2018(ETHERNET 유선 네트워킹 표준 이라고도 알려짐)이 있다. WPAN의 예들로는, ZigBee Alliance로부터의 ZIGBEE 표준을 포함한 IEEE 표준 802.15.4가 포함된다. WPAN의 추가 예들로는, Bluetooth SIG(Special Interest Group)으로부터의 Core Specification 버전 3.0, 4.0, 4.1, 4.2, 5.0 및 5.1을 포함한, BLUETOOTH 무선 네트워킹 표준이 포함된다. WAN은 또한, 분산형 통신 시스템(DCS)이라고도 지칭될 수 있다. WAN의 한 예는 인터넷이다. 스토리지 하드웨어는 컴퓨터 판독가능한 매체이거나 이를 포함한다. 본 개시내용에서 사용되는 컴퓨터 판독가 능한 매체라는 용어는, 비휘발성 스토리지와 DRAM(Dynamic Random Access Memory) 등의 휘발성 스토리지 양쪽 모두를 포괄한다. 컴퓨터 판독가능한 매체라는 용어는, (캐리어파 등의) 매체를 통해 전파되는 일시적인 전기 또는 전자기 신호들만 제외한다. 따라서, 본 개시내용의 컴퓨터 판독가능한 매체는 비일시적이며, 유형 (tangible)인 것으로 간주될 수도 있다. 스토리지 하드웨어에 의해 구현되는 스토리지의 예들로는, (관계형 데이터베이스 또는 NoSQL 데이터베이스 등의) 데이터베이스, 데이터 저장소, 데이터 레이크, 열 저장소, 데이터 웨어하우스가 포함된다. 스토리지 하 드웨어의 예로는, 비휘발성 메모리 디바이스들, 휘발성 메모리 디바이스들, 자기 스토리지 매체, SAN(Storage Area Network), NAS(Network-Attached Storage), 광학 스토리지 매체, (바코드 및 자기 잉크 등의) 인쇄 매체, 및 (펀치 카드들 및 종이 테이프 등의) 종이 매체가 포함된다. 스토리지 하드웨어는, 처리 하드웨어와 함께 배 치되거나 통합될 수 있는 캐시 메모리를 포함할 수 있다. 스토리지 하드웨어는, 판독 전용, 1회 기입, 또는 판 독/기입 속성들을 가질 수 있다. 스토리지 하드웨어는 랜덤 액세스 또는 순차 액세스일 수 있다. 스토리지 하 드웨어는, 위치-어드레싱가능하거나, 파일 어드레싱가능하거나, 및/또는 내용 어드레싱가능할 수 있다. 비휘발성 메모리 디바이스들의 예로는, (NAND 및 NOR 기술들을 포함한) 플래시 메모리, SSD(Solid State Drive), EEPROM(Electrically Erasable Programmable Read-Only Memory) 디바이스 등의 소거가능하고 프로그램 가능한 판독 전용 메모리 디바이스, 및 마스크 판독 전용 메모리 디바이스(ROM)가 포함된다. 휘발성 메모리 디 바이스들의 예로는, SRAM(Static RAM), DRAM(Dynamic RAM), SDRAM(Synchronous DRAM), SGRAM(Synchronous Graphics RAM), 및 VRAM(비디오 RAM) 등의, 프로세서 레지스터들 및 RAM(Random Access Memory)이 포함된다. 자기 스토리지 매체의 예로는, 아날로그 자기 테이프, 디지털 자기 테이프, 회전식 하드 디스크 드라이브(HDD) 가 포함된다. 광 스토리지 매체의 예들로는, (CD-R, CD-RW 또는 CD-ROM 등의) CD, DVD, Blu-ray 디스크, 및 Ultra HD Blu-ray 디스크가 포함된다. 스토리지 하드웨어에 의해 구현되는 스토리지의 예로는, 허가형 또는 비허가형 블록체인 등의 분산형 원장이 포 함된다. 블록체인에서와 같이 거래들을 기록하는 엔티티들은, 지분 증명, 작업 증명, 스토리지 증명 등의, 알 고리즘을 이용하여 합의에 도달할 수 있다. 본 개시내용의 요소들은 대체 불가능한 토큰(NFT)들에 의해 표현되 거나 이들로서 인코딩될 수 있다. 대체 불가능한 토큰들에 관련된 소유권들은 분산형 원장에 기록되거나 이에 의해 참조될 수 있다. 본 개시내용에 의해 시작되거나 본 개시내용과 관련된 거래들은 법정화폐와 암호화폐 중 하나 또는 양쪽 모두를 이용할 수 있으며, 암호화폐의 예로는 비트코인과 이더(ether)가 포함된다. 하드웨어의 일부 또는 모든 피처는, IEEE Standard 1364-2005(일반적으로 \"Verilog\"라고 함) 및 IEEE Standard 1076- 2008(일반적으로 \"VHDL\"이라고 함) 등의 하드웨어 서술을 위한 언어를 이용하여 정의될 수 있다. 하드웨어 서 술 언어는 하드웨어를 제조 및/또는 프로그래밍하는데 이용될 수 있다. 특별-목적 시스템은 여러 상이한 소프트웨어 및 하드웨어 엔티티들에 분산될 수 있다. 특별-목적 시스템 내 및 특별-목적 시스템들 사이의 통신은 네트워킹 하드웨어를 이용하여 수행될 수 있다. 분포는 실시예들에 따라 달 라질 수 있고 시간에 따라 달라질 수 있다. 예를 들어, 배포는 수요에 기초하여 달라질 수 있고, 더 높은 수요 를 처리하기 위해 추가 하드웨어 및/또는 소프트웨어 엔티티들이 기동된다. 다양한 실시예에서, 부하 밸런서는 요청을 특별-목적 시스템의 여러 인스턴스들 중 하나에 보낼 수 있다. 하드웨어 및/또는 소프트웨어 엔티티들 은 물리적으로 별개이거나 및/또는 가상화된 환경에서와 같이 일부 하드웨어 및/또는 소프트웨어를 공유할 수도 있다. 여러 하드웨어 엔티티들은, 서버 랙, 서버 팜, 데이터 센터 등이라고 지칭될 수 있다. 소프트웨어는 머신 판독가능하거나 및/또는 실행가능한 명령어들을 포함한다. 명령어들은, 프로그램들, 코드들, 방법들, 단계들, 행위들, 루틴들, 함수들, 라이브러리들, 객체들, 클래스들 등으로 논리적으로 그룹화 될 수 있다. 소프트웨어는 스토리지 하드웨어에 의해 저장되거나 다른 하드웨어에서 인코딩될 수 있다. 소프트웨어는, (i) HTML(hypertext markup language), XML(extensible markup language), JSON(JavaScript Object Notation) 등의 파싱될 서술적 텍스트, (ii) 어셈블리 코드, (iii) 소스 코드로부터 컴파일러에 의해 생성된 오 브젝트 코드, (iv) 인터프리터에 의한 실행을 위한 소스 코드, (v) 바이트코드, (vi) JIT(Just-In-Time) 컴파일 러에 의한 컴파일 및 실행을 위한 소스 코드 등을 포괄한다. 단지 예들로서, 소스 코드는, C, C++, JavaScript, Java, Python, R 등을 포함한, 언어들로부터의 구문을 이용하여 작성될 수 있다. 소프트웨어는 또한 데이터도 포함한다. 그러나, 데이터와 명령어들은 상호배타적인 범주들이 아니다. 다양한 실시예에서, 명령어들은 하나 이상의 동작에서 데이터로서 이용될 수 있다. 또 다른 예로서, 명령어들은 데이 터로부터 도출될 수 있다. 본 개시내용의 기능 블록들 및 플로차트 요소들은, 숙련된 기술자 또는 프로그래머 의 일상적인 작업에 의해 소프트웨어로 변환될 수 있는 소프트웨어 명세로서 역할한다. 소프트웨어에는, 펌웨 어, 프로세서 마이크로코드, 운영 체제(OS), 기본 입력/출력 시스템(BIOS), 애플리케이션 프로그래밍 인터페이 스(API), 동적 링크 라이브러리(DLL) 등의 라이브러리들, 디바이스 드라이버들, 하이퍼바이저들, 사용자 애플리 케이션들, 백그라운드 서비스들, 백그라운드 애플리케이션들 등을 포함하거나 및/또는 이에 의존할 수 있다. 소프트웨어는 네이티브 애플리케이션들 및 웹 애플리케이션들을 포함한다. 예를 들어, 웹 애플리케이션은 하이 퍼텍스트 마크업 언어 5차 개정판(HTML5)을 이용하는 브라우저를 통해 디바이스에 서비스될 수 있다. 소프트웨어는, 머신 학습이나 기타의 계산 지능이 포함할 수 있는, 인공 지능 시스템들을 포함할 수 있다. 예 를 들어, 인공 지능은 하나 이상의 문제 영역에 이용되는 하나 이상의 모델을 포함할 수 있다. 많은 데이터 피 처들이 제시될 때, 문제 영역과 관련된 피처들의 서브세트의 식별은, 예측 정확도를 개선하고 스토리지 공간을 감축시키고, 처리 속도를 증가시킬 수 있다. 이러한 식별은 피처 엔지니어링이라고 지칭될 수 있다. 피처 엔 지니어링은 사용자들에 의해 수행되거나 사용자들에 의해서만 안내받을 수 있다. 다양한 구현에서, 머신 학습 시스템은 출력들에 대한 상이한 피처들의 기여도들에 관해 특이값 분해를 수행하는 등에 의해 관련 피처들을 계 산적으로 식별할 수 있다. 이들 모델들의 예들로는, 장단기 메모리(LSTM) 등의 순환 신경망(RNN)들, 변환기 등의 딥 러닝 모델, 의사 결정 트리들, 지원 벡터 머신들, 유전 알고리즘들, Bayesian 네트워크, 및 회귀 분석이 포함된다. 변환기 모델에 기 초하는 시스템들의 예들로는, 변환기들로부터의 양방향 인코더 표현(BERT; bidirectional encoder representations from transformer)들 및 생성적 사전 훈련된 변환기(GPT; generative pre-trained transformer)가 포함된다. 머신 학습 모델을 훈련시키는 것은, 지도 학습(예컨대, 라벨링된 입력 데이터에 기 초), 비지도 학습, 및 강화 학습을 포함할 수 있다. 다양한 실시예에서, 머신 학습 모델은 그들의 운영자에 의 해 또는 제3자에 의해 사전 훈련될 수 있다. 문제 영역들은 구조화된 데이터가 수집될 수 있는 거의 임의의 상 황을 포함하고, 자연어 처리(NLP), 컴퓨터 비전(CV), 분류, 이미지 인식 등을 포함한다. 소프트웨어의 일부 또는 전부는 하드웨어에서 직접 실행되는 것이 아니라 가상 환경에서 실행될 수 있다. 가상 환경은, 하이퍼바이저, 에뮬레이터, 샌드박스, 컨테이너 엔진 등을 포함할 수 있다. 소프트웨어는, 가상 머신, 컨테이너 등으로 구축될 수 있다. 가상화된 자원들은, 예를 들어, DOCKER 컨테이너 플랫폼, PCF(Pivotal Cloud Foundry) 플랫폼 등을 이용하여 제어될 수 있다. 클라이언트-서버 모델에서, 소프트웨어 중 일부는 기능적으로 서버로서 식별되는 제1 하드웨어에서 실행되는 반 면, 다른 소프트웨어는 기능적으로 클라이언트로서 식별되는 제2 하드웨어에서 실행된다. 클라이언트와 서버의 ID는 고정되어 있지 않다: 일부 기능의 경우, 제1 하드웨어가 서버로서 역할할 수 있는 반면, 다른 기능의 경우 제1 하드웨어가 클라이언트로서 역할할 수 있다. 상이한 실시예들 및 상이한 시나리오들에서, 기능은 클라이언 트와 서버 사이에서 시프트될 수 있다. 하나의 동적 예에서, 정상적으로 제2 하드웨어에 의해 수행되는 일부 기능은 제2 하드웨어가 더 적은 능력을 가질 때 제1 하드웨어로 시프트된다. 다양한 실시예에서, \"클라이언트\" 대신 \"로컬\"이라는 용어가 사용될 수 있고, \"서버\" 대신 \"원격\"이라는 용어가 사용될 수 있다. 소프트웨어의 일부 또는 전부는 마이크로서비스들로서 논리적으로 분할될 수 있다. 각각의 마이크로서비스는 축소된 기능 서브세트를 제공한다. 다양한 실시예에서, 각각의 마이크로서비스는 마이크로서비스에 더 많은 자 원을 할당하거나 마이크로서비스의 더 많은 인스턴스를 인스턴스화함으로써 부하에 따라 독립적으로 스케일링될 수 있다. 다양한 실시예에서, 하나 이상의 마이크로서비스에 의해 제공되는 기능은 서로 및/또는 마이크로서비 스 모델을 준수하지 않는 다른 소프트웨어와 결합될 수 있다. 소프트웨어의 일부 또는 전부는 논리적으로 계층들로 배열될 수 있다. 계층형 아키텍쳐에서, 제2 계층은 논리 적으로 제1 계층과 제3 계층 사이에 배치될 수 있다. 그러면 제1 층과 제3 층은 일반적으로 서로 상호작용하지 않고 제2 층과 상호작용하게 된다. 다양한 실시예에서, 이것은 엄격하게 시행되지 않는다 ―즉, 일부 직접적인통신이 제1 계층과 제3 계층 사이에서 발생할 수 있다."}
{"patent_id": "10-2023-7030113", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시내용의 더 나은 이해를 제공하기 위해 포함된 첨부된 도면들은, 본 개시내용의 실시예를 예시하고, 설명 과 함께 본 개시내용의 원리를 설명하는 역할을 한다. 도면들에서: 도 1은, 본 개시내용의 일부 실시예에 따른, 유기 생태계 및 현대의 디지털 생태계와 관련된 Cyphergenics 기반 의 디지털 생태계들의 피처들을 나타내는 개략도이다. 도 2는, 본 개시내용의 일부 실시예에 따른, 흔하게 알려진 애플리케이션 및 네트워크 스택들과 함께 동일한 시 공간에 걸쳐 적용될 수 있는 Cyphergenics 지원형 보안 스택 및 이러한 애플리케이션으로부터 발생할 수 있는 디지털 생태계들의 Cyphergenics 지원형 게놈 아키텍쳐들의 예들을 나타낸다. 도 3은, 본 개시내용의 일부 실시예에 따른, 현재의 및 개발 중인 보안 관련 기술들의 속성들(및 잠재적인 단점 들)과 관련된 Cyphergenics 기반의 기술들의 속성들을 나타낸다. 도 4는, 본 개시내용의 일부 실시예에 따른, Cyphergenics 기반의 생태계 보안 플랫폼의 한 예시적인 구성을 나 타낸다.도 5는, 본 개시내용의 일부 실시예에 따른 게놈 데이터 세트들의 예시적인 구현들을 나타낸다. 도 6은, 본 개시내용의 일부 실시예에 따른, 한 세트의 CG 지원형 VDAX들에 의해 관리되는 한 예시적인 Cyphergenics 지원형 디지털 생태계를 나타낸다. 도 7은, 본 개시내용의 일부 실시예에 따른, 정적 생태계들을 지원하는 지시된 아키텍쳐들에 따라 구성된 보안 플랫폼 인스턴스들의 예시적인 구현들을 나타낸다. 도 8은, 본 개시내용의 일부 실시예에 따른, 일시적 생태계를 지원하는 자유 형태 아키텍쳐에 따라 구성된 보안 플랫폼 인스턴스의 한 예시적인 구현을 나타낸다. 도 9는, 본 개시내용의 일부 실시예에 따른, 실시간/동적 생태계를 지원하는 자발적 아키텍쳐에 따라 구성된 보 안 플랫폼 인스턴스의 한 예시적인 구현을 나타낸다. 도 10은, 본 개시내용의 일부 실시예에 따른, 가상의 신뢰할 수 있는 실행 도메인을 지원하는 임시 아키텍쳐에 따라 구성된 보안 플랫폼 인스턴스의 한 예시적인 구현을 나타낸다. 도 11 및 도 12는, 본 개시내용의 일부 실시예에 따라 형성될 수 있는 상이한 CG 지원형 디지털 생태계의 예들 을 나타낸다. 도 13은 본 개시내용의 일부 실시예에 따른 게놈 데이터 객체들을 생성하기 위한 예시적인 프로세스를 나타낸다. 도 14 및 도 15는 본 개시내용의 일부 실시예에 따른 LNA 객체들을 생성하기 위한 예시적인 프로세스를 나타낸 다. 도 16 및 도 17은 본 개시내용의 일부 실시예에 따른 XNA 객체들을 생성하기 위한 예시적인 프로세스를 나타낸 다. 도 18은 본 개시내용의 일부 실시예에 따른 ZNA 객체들을 생성하기 위한 예시적인 프로세스를 나타낸다. 도 19는 본 개시내용의 일부 실시예에 따른 마스터 CNA 객체를 생성하기 위한 예시적인 프로세스를 나타낸다. 도 20은 본 개시내용의 일부 실시예에 따른 마스터 CNA 객체에 기초하여 생태계 멤버들에 대한 CNA 객체들을 할 당하기 위한 예시적인 프로세스를 나타낸다. 도 21은 본 개시내용의 일부 실시예에 따른 디지털 생태계의 생태계 멤버들에 대한 PNA 객체들을 생성하고 할당 하기 위한 예시적인 프로세스를 나타낸다. 도 22는 본 개시내용의 일부 실시예에 따른 미수정 게놈 데이터 객체에 관해 서열 맵핑을 수행하기 위한 예시적 인 프로세스를 나타낸다. 도 23은 본 개시내용의 일부 실시예에 따른 수정된 게놈 데이터 객체에 관해 서열 맵핑을 수행하기 위한 예시적 인 프로세스를 나타낸다. 도 24는 본 개시내용의 일부 실시예에 따른 링크 교환을 수행하기 위한 예시적인 프로세스를 나타낸다. 도 25는 본 개시내용의 일부 실시예에 따른 VBLS(Virtual Language Binary Script)를 생성하기 위한 예시적인 프로세스를 나타낸다. 도 26은 본 개시내용의 일부 실시예에 따른 VBLS-인코딩된 명령어들을 디코딩된 실행가능한 명령어들로 디코딩 하거나 및/또는 실행가능한 명령어들을 VBLS-인코딩된 명령어들로 인코딩하도록 구성된 한 예시적인 VDAX를 나 타낸다. 도 27은 본 개시내용의 일부 실시예에 따른 VBLS-인코딩된 데이터를 처리 코어에 입력되는 디코딩된 데이터로 디코딩하거나 및/또는 처리 코어에 의해 출력된 출력 데이터를 VBLS-인코딩된 데이터로 인코딩하도록 구성된 예 시적인 VDAX를 나타낸다. 도 28은 본 개시내용의 일부 실시예에 따른 원장 기반의 생태계들 및 기저 VDAX들의 예시적인 구성들을 나타낸 다. 도 29는 본 개시내용의 일부 실시예에 따른 원장내 MDC(intra-ledger MDC)들을 유지하기 위해 CG 기반의 검증을 이용하는 한 예시적인 원장 기반의 디지털 생태계를 나타낸다.도 30은 본 개시내용의 일부 실시예에 따른 원장간 MDC(inter-ledger MDC)들을 유지하기 위해 CG 기반의 공증을 이용하는 한 예시적인 원장 기반의 디지털 생태계를 나타낸다."}
