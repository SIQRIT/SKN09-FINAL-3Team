{"patent_id": "10-2022-7040718", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0022844", "출원번호": "10-2022-7040718", "발명의 명칭": "인공 지능 요청 및 제안 카드", "출원인": "밋카이, 인크.", "발명자": "카플란 제임스"}}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "인공 지능 기반 사용자 인터페이스 카드를 생성하는 시스템으로서,스크린, 비일시적 머신 실행 가능 코드를 저장한 메모리, 및 상기 머신 실행 가능 코드를 실행하도록 구성된 프로세서를 가진 제1 사용자 디바이스를 포함하고,상기 머신 실행 가능 코드는,상기 제1 사용자 디바이스와 호환 가능하도록 스마트 카드 번들을 수정하도록 - 상기 스마트 카드 번들은 디스플레이 엘리먼트의 제1 세트 및 컨텍스트 데이터의 제1 세트를 포함하고, 상기 디스플레이 엘리먼트의 제1 세트는 사용자 애플리케이션에 의해 제공되는 하나 이상의 기능을 사용하고, 상기 컨텍스트 데이터의 제1 세트는 사용자에 의한 제1 요청에 응답함 - ;사용자 정보의 분석에 기초하여 사용자 선호도(preferences)를 예측하고, 상기 예측에 기초하여 상기 스마트 카드 번들을 구성하도록; 그리고디스플레이 엘리먼트의 제2 세트 및 컨텍스트 데이터의 제2 세트를 상기 스마트 카드 번들에 추가하도록 - 상기디스플레이 엘리먼트의 제2 세트는 상기 사용자 애플리케이션에 의해 제공되지 않은 기능을 사용함 -구성되는 것인, 시스템."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 사용자 정보는 사용자 계정 정보, 사용자 선호도, 이전 사용자 선택, 사용자 입력, 사용자 웹 브라우저 히스토리, 사용자 통신, 또는 보조 메타데이터 중 하나 이상으로부터 선택되는 것인, 시스템."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 디스플레이 엘리먼트의 제1 세트는 추가 사용자 동작을 제안하는 상기 사용자에 대한 상호작용 프롬프트를포함하는 것인, 시스템."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,백엔드 서버(backend server)를 더 포함하고, 상기 디스플레이 엘리먼트의 제1 세트는 상기 백엔드 서버로부터의 데이터로 주기적으로 업데이트되는 디스플레이 엘리먼트를 포함하고, 상기 데이터는 상기 백엔드 서버로부터상기 스마트 카드 번들로 스트리밍되는 것인, 시스템."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,상기 디스플레이 엘리먼트의 제2 세트는 제2 사용자 디바이스와 통신하도록 구성되는 것인, 시스템."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 머신 실행 가능 코드는 또한, 상기 사용자에 의해 제2 요청에 기초하여 상기 스마트 카드 번들에 디스플레이 엘리먼트의 제3 세트 및 컨텍스트 데이터의 제3 세트를 추가하도록 구성되고, 상기 컨텍스트 데이터의 제3세트는 상기 제1 요청 및 상기 제2 요청에 응답하는 것인, 시스템.공개특허 10-2023-0022844-3-청구항 7 인공 지능 기반 사용자 인터페이스 카드를 생성하기 위한 방법으로서,사용자 디바이스 상에서 실행되는 사용자 애플리케이션으로부터 제1 사용자 요청을 수신하는 단계;디스플레이 엘리먼트의 제1 세트 및 디스플레이 엘리먼트의 제2 세트를 포함하는 스마트 카드 번들을 컴파일링하는 단계 - 상기 디스플레이 엘리먼트의 제1 세트는 상기 사용자 애플리케이션에 의해 제공되는 하나 이상의기능을 사용하고, 상기 디스플레이 엘리먼트의 제2 세트는 상기 사용자 애플리케이션에 의해 제공되지 않는 기능을 사용함 - ;사용자 정보의 분석에 기초하여 사용자 선호도를 예측하는 단계;상기 예측에 기초하여 상기 스마트 카드 번들을 구성하는 단계; 및상기 사용자 디바이스의 스크린 상에 상기 디스플레이 엘리먼트의 제1 세트 및 상기 디스플레이 엘리먼트의 제2세트를 디스플레이하는 단계를 포함하는, 방법."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 사용자 정보는 사용자 계정 정보, 사용자 선호도, 이전 사용자 선택, 사용자 입력, 사용자 웹 브라우저 히스토리, 사용자 통신, 또는 보조 메타데이터 중 하나 이상으로부터 선택되는 것인, 방법."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제7항에 있어서,상기 스마트 카드 번들은 컨텍스트 데이터의 제1 세트를 더 포함하고, 상기 컨텍스트 데이터의 제1 세트는 상기제1 사용자 요청에 응답하는 것인, 방법."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 사용자 애플리케이션으로부터 제2 사용자 요청을 수신하는 단계;컨텍스트 데이터의 제2 세트로 상기 스마트 카드 번들을 업데이트하는 단계 - 상기 컨텍스트 데이터의 제2 세트는 상기 제1 사용자 요청 및 상기 제2 사용자 요청에 응답함 - ; 및상기 예측 및 상기 제2 사용자 요청에 기초하여 상기 스마트 카드 번들을 구성하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제9항에 있어서,백엔드 서버로부터 스트리밍되는 새로운 정보로 상기 컨텍스트 데이터의 제1 세트를 업데이트하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제7항에 있어서,상기 스마트 카드 번들은 추가 동작을 제안하는 사용자에 대한 상호작용 프롬프트를 더 포함하고, 상기 상호작용 프롬프트는 상기 예측에 기초하여 구성되는 것인, 방법."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제7항에 있어서,공개특허 10-2023-0022844-4-상기 스마트 카드 번들을 구성하는 단계는, 디스플레이 엘리먼트를 추가하는 동작, 디스플레이 엘리먼트를 제거하는 동작, 디스플레이 엘리먼트를 리사이즈하는 동작, 또는 2개 이상의 디스플레이 엘리먼트를 재정렬하는(reorder) 동작 중 하나 이상의 동작을 수행하는 단계를 포함하는 것인, 방법."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "인공 지능 기반 사용자 인터페이스 카드를 생성하는 시스템으로서,스크린, 비일시적 머신 실행 가능 코드를 저장한 메모리, 및 상기 머신 실행 가능 코드를 실행하도록 구성된 프로세서를 포함하고,상기 머신 실행 가능 코드는,제1 스크린 상에 디스플레이를 위해 스마트 카드 번들을 제1 스마트 카드로 프로세싱하도록 - 상기 스마트 카드번들은 디스플레이 엘리먼트의 세트 및 컨텍스트 데이터를 세트를 포함함 - ;상기 제1 사용자 디바이스에 의해 제공되지 않는 기능을 사용하여 상기 제1 스마트 카드 상에 상기 디스플레이엘리먼트의 세트를 렌러딩하도록; 그리고제2 사용자 디바이스로부터의 데이터로 상기 컨텍스트 데이터를 업데이트하도록구성되는 것인, 시스템."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서,상기 제2 사용자 디바이스에 의해 상기 스마트 카드 번들로부터 프로세싱된 제2 스마트 카드; 및 제3 사용자 디바이스에 의해 상기 스마트 카드 번들로부터 프로세싱된 제3 스마트 카드를 더 포함하고,상기 제1 사용자 디바이스 상의 상기 컨텍스트 데이터는 상기 제2 스마트 카드 및 상기 제3 스마트 카드로부터의 데이터로 업데이트되는 것인, 시스템."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서,상기 제1, 제2, 및 제3 스마트 카드는 피어 투 피어 방식(peer-to-peer fashion)으로 서로 데이터를 전송하고,상기 제1 스마트 카드는 호스트로서 선택되는 것인, 시스템."}
{"patent_id": "10-2022-7040718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제14항에 있어서,상기 제2 사용자 디바이스로부터의 데이터는 상기 제2 사용자 디바이스로부터 백엔드 서버로 그 다음 상기 백엔드 서버로부터 상기 제1 사용자 디바이스로 라우팅되는 것인, 시스템."}
{"patent_id": "10-2022-7040718", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "인공 지능 기반 사용자 인터페이스 카드를 생성하는 방법 및 시스템. 시스템은 사용자 디바이스와 호환되도록 스마트 카드 번들을 수정하도록 구성된 비일시적 머신 실행 가능 코드를 포함한다. 스마트 카드 번들은 디스플 레이 엘리먼트의 제1 세트 및 컨텍스트 데이터의 제1 세트를 포함한다. 디스플레이 엘리먼트의 제1 세트는 사용 자 애플리케이션에 의해 제공된 하나 이상의 기능을 사용하고, 컨텍스트 데이터의 제1 세트는 사용자에 의한 제1 요청에 응답한다. 머신 실행 가능 코드는 또한, 사용자 정보의 분석에 기초하여 사용자 선호도(preference)를 예측하도록 그리고 예측에 기초하여 스마트 카드 번들을 구성하도록 구성된다. 제2 세트의 디스플레이 엘리먼트 및 제2 세트의 컨텍스트 데이터도 스마트 카드 번들이 될 수 있고, 제2 세트의 디스플레이 엘리먼트를 사용자 애 플리케이션에 의해 제공되지 않는 기능을 사용한다."}
{"patent_id": "10-2022-7040718", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "[1. 관련 출원에 대한 상호 참조] 본 출원은, 여기에 참조에 의해 포함되어 있는 2020년 4월 27일에 출원된 미국 가출원 No. 63/016,244에 대한 우선권을 주장한다. [2. 발명의 분야] 본 발명은 인공 지능(artificial intelligent; \"AI\") 가상 어시스턴트와 페어링하기 위한 개선된 사용자 인터페 이스, 특히 사용자와의 양방향 상호작용을 위한 시각적 디스플레이 카드 시스템 및 방법을 제공하는 것에 관한 것이다."}
{"patent_id": "10-2022-7040718", "section": "발명의_설명", "subsection": "배경기술", "item": 1, "content": "도 1은 정적 카드(static card)를 생성하기 위해 백엔드 서버와 상호작용하는 종래 기술의 사용자 애플리케이션 을 도시한다. 사용자는, 사용자 디바이스(용어집에 정리됨) 또는 백엔드 서버와 상호작용하는 사용자 디바이스 상의 임의의 사용자 애플리케이션(용어집에 정리됨)과 상호작용한다. 능동 입력(예컨대, 음성 명령 입력) 또는 수동 동작[예컨대, 사용자 애플리케이션 또는 사용자 애플리케이션에서의 피쳐 페이지(feature page) 열기]일 수 있는 사용자 요청은 카드 요청으로 프로세싱되며, 이는 그런 다음 백엔드 서버로 전송된다. 백엔드 서버는 정적 카드 프리미티브(static card primitive)로 변환되는 정적 카드를 리 턴함으로써 카드 요청에 응답한다. 정적 카드 프리미티브는 정수, 문자열, 부울(Boolean)과 같은 단순한 데이 터 타입으로 나눌(break down) 수 없는 기본 데이터 타입이다. 그 다음, 정적 카드 프리미티브는 템플릿 엔진 (templating engine)에 의해 프로세싱되고, 템플릿 엔진은 정적 카드의 사양에 기초하여 렌더링할 미리 정 의된 템플릿 및 스타일의 세트로부터 미리 정의된 템플릿을 선택한다. 종래 기술은 또한 카드 버전이 일치하지 않는 경우에 대한 폴백 모드(fallback mode)를 가질 수 있다. 예컨대, 템플릿 엔진이 제공된 정적 카드에 대한 대응하는 네이티브 디스플레이 구현(corresponding native display implementation)을 포함하지 않았다면, 폴백 엔진(fallback engine)은 에러를 출력하도록 트리거되어, 사용자가 정의되지 않은 동 작(예컨대, 에러 메시지 또는 임의의 정적 카드에 대응하지 않는 기본 템플릿)을 경험하게 할 수 있다. 현재 카드는 렌더링과 백엔드 서버가 특정 버전 그룹핑으로 함께 묶이도록(tied) 구성되어 있다. 이 방법에서, 사용자 애플리케이션은 버전 X에서 실행 중이며, 버전 X에 전원을 공급하기 위해 백엔드 서버에만 연결될 수 있 다. 사용자 애플리케이션은 모든 결과가 사용자가 상호 작용할 수 있도록 디바이스 상에서 렌더링될 수 있다고 가정하고 백엔드 서버에 요청한다. 이것은 사용자 애플리케이션이 고정된 양의 상호 작용을 갖는 시나리오에서 잘 작동한다. 그러나, AI 서비스를 제공하는 임의의 서비스(용어집에 정리됨)에는 잠재적으로 무한한 가능성이 있다. 이러한 상황에서, 사용자 애플리케이션은 백엔드 서버가 예기치 않은 요청의 일부로 결과를 사용자 디바 이스에 리턴하는 경우 사용자 애플리케이션이 충돌하지 않도록 폴백 모드를 구현해야 한다. 이것을 회피하기 위해, 백엔드 서버는 대응하는 애플리케이션 업데이트 없이 새로운 기능을 포함할 수 없다. 또한 외부 개발자 가 완전히 커스텀 사용자 인터페이스(fully custom user interface)를 가진 커스텀 기술(custom skill)을 만드 는 것은 불가능하며, 대신 매우 일반적인 시나리오에서 렌더링할 수 있는 범위로 제한된다. 마지막으로, 인터페이스는 순전히 디스플레이 기반 로직으로 제한된다. 결과적으로, 이것은 동적인 그리고 맞 춤화 가능한 카드(customizable card)를 가질 수 없음을 의미한다. 마찬가지로, 종래 기술에는 깊은 로직 기능 (deep logic capability)이 없기 때문에 사용자가 취할 수 있는 추가 작업을 제안하거나 사용자의 요구에 맞게 레이아웃을 조정하는 것과 같이 다른 레벨의 AI를 카드 자체에 구축하는 것이 불가능하거나 효율적이지 않다. 종래 기술에서는 두 명의 사용자가 동일한 기본 결과를 수신하는 경우 동일한 기본 디스플레이를 관찰하는 방식 으로 정적으로 렌더링된 카드를 디스플레이하는 것만 가능하다. 정적으로 렌더링된 카드는 동일한 쿼리(quer y)를 요청하는 두 명의 사용자가 정확히 동일한 정보와 결과를 수신하게 될 것을 의미한다. 이것은, 참여를 높 이기 위해 데이터 디스플레이 순서 또는 이미지 선택을 재구성하는 등의 작업 - 이것에 한정되지 않음 - 을 수 행할 수 없게 한다. 또한, 후속 작업에 대한 제안은 현재 컨텍스트의 외부에서 훨씬 더 일반적인 포맷으로 이 루어져야 한다. 종래 기술의 단점을 극복하기 위해 그리고 추가 장점을 제공하기 위해, 인공 지능 기반 사용자 인터페이스 카드 를 생성하는 시스템이 개시된다. 일 실시형태에서, 이 시스템은 스크린을 가진 사용자 디바이스, 비일시적 머 신 실행 가능 코드를 저장하는 메모리, 및 머신 실행 가능 코드를 실행하도록 구성된 프로세서를 포함한다. 본 실시형태에서, 머신 실행 가능 코드는 스마트 카드 번들(smart card bundle)을 제1 사용자 디바이스와 호환 가 능하게 수정하도록 구성된다. 스마트 카드 번들은 디스플레이 엘리먼트의 제1 세트 및 컨텍스트 데이터의 제1 세트를 포함한다. 디스플레이 엘리먼트의 제1 세트는 사용자 애플리케이션에 의해 제공된 하나 이상의 기능을 사용하고, 컨텍스트 데이터의 제1 세트는 사용자에 의한 제1 요청에 응답한다. 머신 실행 가능 코드는 또한, 사용자 정보의 분석에 기초하여 사용자 선호도(preference)를 예측하도록 그리고 예측에 기초하여 스마트 카드 번들을 구성하도록 구성된다. 제2 세트의 디스플레이 엘리먼트 및 제2 세트의 컨텍스트 데이터도 스마트 카드 번들이 될 수 있고, 제2 세트의 디스플레이 엘리먼트를 사용자 애플리케이션에 의해 제공되지 않는 기능을 사용 한다.다른 실시형태에서, 사용자 정보는, 사용자 계정 정보, 사용자 선호도, 이전 사용자 선택, 사용자 입력, 사용자 웹 브라우저 히스토리, 사용자 통신, 또는 보조 메타데이터 중 하나 이상으로부터 선택된다. 디스플레이 엘리 먼트의 제1 세트는 추가적인 사용자 동작을 제안하는 사용자에 대한 상호작용 프롬프트(interactive prompt)를 포함할 수 있음이 고려된다. 일 실시형태에서, 시스템은 백엔드 서버를 더 포함하고, 디스플레이 엘리먼트의 제1 세트는 백엔드 서버로부터의 데이터로 주기적으로 업데이트되는 디스플레이 엘리먼트를 포함한다. 데이터 는 백엔드 서버로부터 스마트 카드 번들로 스트리밍될 수 있다. 제2 세트의 디스플레이 엘리먼트는 또한, 제2 사용자 디바이스와 통신하도록 구성될 수 있다. 또한, 제3 세트의 컨텍스트 데이터가 제1 사용자 요청 및 제2 사용자 요청 둘 다에 응답하도록, 사용자에 의한 제2 요청에 기초하여 스마트 카드 번들에 제3 세트의 디스플레 이 엘리먼트 및 제3 세트의 컨텍스트 데이터가 추가될 수 있음이 고려된다. 또한, 인공 지능 기반 사용자 인터페이스를 생성하는 방법이 개시되고, 상기 방법은, 사용자 디바이스 상에서 실행되는 사용자 애플리케이션으로부터 제1 사용자 요청을 수신하는 단계, 디스플레이 엘리먼트의 제1 세트 및 제2 세트의 디스플레이 엘리먼트를 포함하는 스마트 카드 번들을 컴파일링하는 단계 ? 디스플레이 엘리먼트의 제1 세트는 사용자 애플리케이션에 의해 제공된 하나 이상의 기능을 사용하고, 제2 세트의 디스플레이 엘리먼트 는 사용자 애플리케이션에 의해 제공되지 않는 기능을 사용함 - , 사용자 정보의 분석에 기초하여 사용자 선호 도를 예측하는 단계, 예측에 기초하여 스마트 카드 번들을 구성하는 단계, 및 사용자 디바이스의 스크린 상에 제2 세트의 디스플레이 엘리먼트 및 제2 세트의 디스플레이 엘리먼트를 디스플레이하는 단계를 포함한다. 사용자 정보는, 사용자 계정 정보, 사용자 선호도, 이전 사용자 선택, 사용자 입력, 사용자 웹 브라우저 히스토 리, 사용자 통신, 또는 보조 메타데이터 중 하나 이상으로부터 선택될 수 있다. 일 실시형태에서, 스마트 카드 번들은, 제1 사용자 요청에 응답하는 컨텍스트 데이터의 제1 세트를 포함할 수 있다. 상기 방법은, 사용자 애 플리케이션으로부터 제2 사용자 요청을 수신하는 단계, 제2 세트의 컨텍스트 데이터로 스마트 카드 번들을 업데 이트하는 단계 ? 제2 세트의 컨텍스트 데이터는 제1 사용자 요청 및 제2 사용자 요청에 응답함 - , 및 예측 및 제2 사용자 요청에 기초하여 스마트 카드 번들을 구성하는 단계의 추가 단계들을 포함할 수 있다. 다른 실시형 태에서, 방법은 백엔드 서버로부터 스트리밍되는 새로운 정보와 컨텍스트 데이터의 제1 세트를 업데이트하는 추 가 단계를 포함할 수 있다. 또한, 스마트 카드 번들은 추가 동작을 제안하는 사용자에 대한 상호작용 프롬프트를 포함할 수 있음이 고려된 다. 상호작용 프롬프트는 예측된 사용자 선호도에 기초하여 구성될 수 있다. 일 실시형태에서, 스마트 카드 번들은 디스플레이 엘리먼트를 추가하는 동작, 디스플레이 엘리먼트를 제거하는 동작, 디스플레이 엘리먼트를 리사이즈하는 동작, 또는 2개 이상의 디스플레이 엘리먼트를 리오더(reorder)하는 동작, 중 하나 이상을 수행함 으로써 구성될 수 있다. 스크린을 가진 제1 사용자 디바이스, 비일시적 머신 실행 가능 코드를 저장하는 메모리, 및 머신 실행 가능 코 드를 실행하도록 구성된 프로세서를 포함하는, 인공 지능 기반 사용자 인터페이스 카드를 생성하는 다른 시스템 이 개시된다. 머신 실행 가능 코드는 스마트 카드 번들을 제1 스크린 상의 디스플레이를 위해 제1 스마트 카드 로 프로세싱하도록 구성되고, 스마트 카드 번들은 디스플레이 엘리먼트의 세트 및 컨텍스트 데이터의 세트를 포 함한다. 머신 실행 가능 코드는 또한, 제1 사용자 디바이스에 의해 제공되지 않는 기능을 사용하여 제1 스마트 카드 상의 디스플레이 엘리먼트의 세트를 렌더링하고 제2 사용자 디바이스로부터의 데이터로 컨텍스트 데이터를 업데이트하도록 구성된다. 일 실시형태에서, 이 시스템은 또한, 제2 사용자 디바이스에 의해 스마트 카드 번들로부터 프로세싱된 제2 스마 트 카드 및 제3 사용자 디바이스에 의해 스마트 카드 번들로부터 프로세싱된 제3 스마트 카드를 포함할 수 있다. 본 실시형태에서, 제1 사용자 디바이스 상의 컨텍스트 데이터는 제2 스마트 카드 및 제3 스마트 카드로 부터의 데이터로 업데이트될 수 있다. 제1, 제2, 및 제3 스마트 카드는 피어-투-피어 방식(peer-to-peer fashion)으로 서로에게 데이터를 전송할 수 있고, 제1 스마트 카드는 호스트로 선택되는 것이 고려된다. 다른 실시형태에서, 제2 사용자 디바이스로부터의 데이터는 제2 사용자 디바이스로부터 백엔드 서버로, 그 다음 백엔드 서버로부터 제1 사용자 디바이스로 라우팅 된다. [용어집] AI 서비스: AI 서비스는 인공 지능 목적을 달성하기 위해 프로그램에 절차 및 방법으로서 제공되는 서비스이다. 실시예는 이미지 모델링, 텍스트 모델링, 예측(forecasting), 플래닝(planning), 추천, 검색, 음성 프로세싱,오디오 프로세싱, 오디오 생성, 텍스트 생성, 이미지 생성 등을 포함할 수 있다. 디바이스: 디바이스는 최소한의 네트워크 인터페이스와 CPU로 실행되는 임의의 엘리먼트이다. 선택적으로 가속 기가 GPU 또는 기타 특수 하드웨어 가속기의 형태로 부착될 수 있다. 이 가속기는 AI 서비스의 계산 속도를 높 일 수 있다. 운영체제(“OS”): 운영체제는 작업을 스케쥴링하는 것, 애플리케이션을 실행하는 것, 및 하드웨어를 제어하는 것 등의 컴퓨터의 기본 기능을 지원하는 소프트웨어이다. 운영체제는 이 기능들에 대한 액세스를 다른 소프트 웨어에 제공한다. 사용자 애플리케이션: 사용자 애플리케이션은, 모바일 디바이스, 스마트 시계, 태블릿, 가정용 스피커, 스마트 링을 포함한 웨어러블 디바이스, 안경, 보청기, CarPlay 디바이스, 보안 카메라, 웹캠, 텔레비전, 프로젝션 스 크린 모니터, 사운드 바, 개인용 컴퓨터, 헤드폰, 이어버드, 및 사용자가 터치, 오디오, 시각적 또는 수동적으 로 상호 작용할 수 있는 랩톱 디바이스와 같은 사용자 대면 디바이스에서 실행되는 임의의 소프트웨어이다. AI 가상 어시스턴트: AI 가상 어시스턴트는 AI 서비스를 사용하여 디바이스 상에서 사용자와 상호작용하고, 사 용자에 정보를 제공하고, 사용자와 인터페이싱하는 사용자 애플리케이션이다. 사용자 정보: 사용자 데이터(예컨대, 계정 정보, 위치 데이터, 사용 선호도) 및 사용자 히스토리(예를 들어, 사 용자가 디바이스 또는 사용자 애플리케이션과 이전에 상호작용한 데이터, 사용자 관심사, 이전 활동, 이전 웹 검색, 이전에 방문한 웹 사이트, 위치 히스토리, 건강 정보) 등의 사용자에 의해 생성되거나 사용자로부터 수집 된 사용자 정보 데이터. 보조 메타데이터: 보조 메타데이터는 현재 날짜, 뉴스, 룸 온도, 날씨 조건 등의 사용자에 관련되지 않은 임의 의 데이터이다. 카드(즉, 스마트 카드): 카드는 사용자가 요청한 정보로 채워지는(populated) 디스플레이 메커니즘이다. 이 카 드는 텍스트 정보, 제안 정보, 비디오, 및/또는 이미지의 조합일 수 있다. 도 8은 예시적인 카드가 어떻게 생겼 는지에 대한 시각적 표현을 나타낸다. 스마트 카드는 각 사용자에 대한 고유한 정보를 디스플레이할 수 있다. 이 혁신은 가상 어시스턴트가 사용자 애플리케이션 업데이트를 요구하지 않고 새로운 기능으로 확장될 수 있는 시스템을 생성함으로써 종래 기술보다 향상된다. 새로운 기능이 추가되면 이러한 새로운 기능적 응답으로 질의 응답을 시작하기 위해 사용자 애플리케이션이 업그레이드될 필요가 없다. 본 발명은 결과의 일부로서 고정 마 크업 언어를 사용하기 위한 요건을 제거함으로써 종래 기술에서 경험한 외측 외부 개발자에 의한 확장성의 제한 을 개선한다. 이를 통해 렌더링된 항목 자체에 깊은 도메인 특정 로직을 통합할 수 있다. 또한, 본 발명은 백 엔드 서버가 사용자 애플리케이션 렌더링으로부터 직접 통신되도록 동적 결과를 가능하게 함으로써 종래 기술보 다 개선된다. 이 개선 사항은 사용자 애플리케이션이 이러한 통합을 처리하지 않고도 서로 다른 사용자 애플리 케이션의 프런트엔드(frontend)가 서로 직접 상호 작용할 수 있는 다중 사용자 상황의 배포를 허용한다. 마지 막으로, 본 발명은 스마트 카드의 범위 내에 로직 AI 엔진을 포함시킴으로써 종래 기술보다 개선된다. 이 엔진 은 스마트 카드를 동적으로 조정하여 사용자 참여를 높일 수 있을 뿐만 아니라 사용자가 도메인 자체 내에서, 스마트 카드 자체와 관련되거나 잠재적으로 관련 도메인 둘 모두를 수행하도록 제안할 수 있다. 보다 구체적으 로는, 서버 제어 AI가 스마트 카드의 엘리먼트를 렌더링할 수 있는 수단을 제공한다. 또한, 이 렌더링을 통해 AI 기반 제안을 카드 자체의 일부로 만들 수 있다. 본 발명의 다른 시스템, 방법, 피쳐(feature), 및 이점은 하기 도면 및 상세한 설명을 검토함으로써 당업자에게 명백하거나 명백해질 것이다. 이러한 모든 추가 시스템, 방법, 피쳐, 및 이점은 본 설명 내에 포함되고, 본 발 명의 범위 내에 있으며, 첨부된 청구범위에 의해 보호되도록 의도된다."}
{"patent_id": "10-2022-7040718", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "스마트 카드를 생성하기 위한 방법 및 시스템은 4개의 핵심 엘리먼트(key element)를 포함한다. 제1 엘리먼트 는 스마트 카드를 디스플레이하는 역할을 하는 렌더링 프레임워크이다. 제2 엘리먼트는 스마트 카드 상에 AI 서비스를 구현하는 역할을 하는 스마트 카드 로직 엔진이다. 제3 엘리먼트는 사용자 애플리케이션과 호환 가능 한 외부 개발된 스마트 카드를 만드는 최적화 시스템이다. 제4 엘리먼트는 복수의 스마트 카드가 사용자 디바 이스를 통해 서로 통신할 수 있게 하고, 스마트 카드가 또한, 백엔드 서버와 직접 통신할 수 있게 하는 스마트 카드 통신 프레임워크이다. 특히, 렌더링 프레임워크는 사용자 애플리케이션측과 백엔드 서버 구현 둘 다로 구성된다. 백엔드 서버 구현에 서 렌더링 프레임워크는 스마트 카드에 대한 데이터 및 관련 메타데이터를 렌더링 요청 컨텍스트에 주입하는 역 할을 한다. 또한, 백엔드 서버 렌더(backend server render)는 스마트 카드가 사용자에게 제공되는 동안 지능 형 작업을 계속 수행할 수 있도록 결과 중심 AI(result driven AI)에 대한 후크(hook)를 제공해야 한다. 후크 는 베이스 시스템이 확장 코드를 호출하여 기존 프로그램이나 시스템의 변경이나 확장을 허용하는 기능의 타입 이다. 사용자 애플리케이션 구현은 서버로부터의 렌더링을 디바이스 상에 디스플레이할 수 있는 네이티브 엘리 먼트(native element)로 변환하는(translating) 역할을 한다. 상이한 운영체제 및 플랫폼에서는 디스플레이에 사용할 수 있는 상이한 프리미티브 카드 세트가 있을 수 있다. 최적의 경우, 사용된 많은 프리미티브 카드, 테이블, 그래프, 그리드, 이미지 등에 대한 네이티브 매핑(native mapping)이 있을 수 있다. 그러나, 가장 간단 한 경우에 가장 최소한의 사용자 애플리케이션은 미리 렌더링된 아이템을 디스플레이하기 위해 캔버스를 제공하 기만 하면 된다. 이러한 방식으로, 스크린이 있는 임의의 디바이스는 최소한의 사용자 애플리케이션 렌더링을 사용할 수 있다. 제2 핵심 엘리먼트는 스마트 카드 로직 엔진이다. 스마트 카드 로직 엔진은 보다 강력한 디스플레이를 위해 AI 작업을 실행하는 프레임워크이다. 이 작업은 임의의 수의 분야에 관련될 수 있다. 일부 예시적 애플리케이션 은 다양한 유형의 사용자 데이터를 기반으로 하는 AI 선택 엔진을 활용하여 특정 사용자에게 맞춤화된 스마트 카드에서 사용자가 볼 수 있는 최상의 이미지를 선택하기 위한 것이다. 엔진은 AI 모델을 실행하여 사용자의 과거 선호도 또는 이미지에 대한 상호 작용 레벨뿐만 아니라 사용자에 대한 기타 정보를 고려하여 최적의 이미 지를 결정함으로써 이것을 달성한다. 이 적응형 카드 지능 피쳐(adaptive card intelligence feature)는 사용 자 히스토리 및 활동을 기반으로 하는 지능형 엔진을 사용하여 디스플레이의 임의의 컴포넌트를 맞춤화할 수 있 다. AI 엔진이 이 특정 사용자가 읽을 가능성이 없다고 결정하는 경우 세부 섹션을 제거하거나, 해당 세부사항 이 포함된 경우 사용자가 스마트 카드와 상호 작용할 가능성이 더 높을 것으로 예측되는 경우 세부 섹션을 소개 할 수도 있다. 이것은 AI 엔진에 의해 자동으로 수행될 수 있으며, 선택적인 수동 무시(override)가 가능할 수 있지만 사용자가 시스템에 선호도를 수동으로 입력하여 제어할 수 있다. 또한, 카드를 생성하고 구동하는 (powering) 엔진은 후속 제안 및 사용자와의 상호 작용을 포함할 수 있다. 가상 어시스턴트의 범위 내에서, 이 러한 제안은 일반적인 방식으로 도메인 자체 내의 후속 작업에 대한 것일 수 있다(즉, 사용자가 날씨 정보를 보 고 있는 경우 내일 날씨를 문의하는 것을 제안할 수 있음). 이러한 제안은 도메인 내에서 더욱 개인화된 아이 템의 형태 및/또는 관련 아이템일 수도 있다(즉, 사용자가 영화를 보고 있는 경우, 로직 엔진을 통해 사용자가 그렇게 할 가능성이 있거나 사용자에게 도움이 될 것으로 결정되는 경우, 사용자가 특정 감독 또는 특정 배우의 다수의 영화를 보는 등의 경우와 같은 과거 영화 시청 습관이 있는 경우에 특정 감독의 영화에 대해 요청하도록 제안할 수 있음). 또한, 이러한 제안은 다른 도메인의 맥락에서 후속 조치(follow ups)를 위한 것일 수도 있다 (예컨대, 사용자가 책을 보고 있는 경우 동일 주제와 관련된 영화를 요청하는 것이 제안될 수 있음). 이러한 모든 제안은 본 발명의 제1 핵심 엘리먼트로부터 백엔드 서버 렌더링 엔진에 의해 주입된 스마트 카드의 컨텍스 트를 활용함으로써 로직 엔진에 의해 직접 계산될 수 있다. 제3 핵심 엘리먼트는 최적화 시스템이다. 이 엘리먼트는 사용자 애플리케이션 업데이트 없이 새로운 타입의 스 마트 카드를 포함하고 그리고/또는 사용자 애플리케이션 고유의(native) 기능을 활용하지 않는 스마트 카드에 새로운 디스플레이 엘리먼트를 포함할 수 있게 한다. 이 기능은 이하에서 도 11 내지 도 14에 관하여 더 상세 히 논의될 것이다. 이 시스템은 프로토콜 및 그 프로토콜의 간단한 구현에 제공되는 소프트웨어 개발 키트로 구성된다. 프로토콜은 등록 스테이지, 컨텍스트 주입 스테이지, 및 로직 스테이지로 구성된다. 등록 스테이지에서, 새 스 마트 카드 타입은 백엔드 서버 렌더링 프레임워크에 알려야 한다. 이것이 완료되면 백엔드 서버 사용자 애플리 케이션은 이 스마트 카드를 렌더링할 수 있음을 알게 된다. 백엔드 서버 렌더 양태 또는 사용자 애플리케이션 의 서브 모듈은 리소스를 준비하기 위해 미리 또는 특정 타입의 스마트 카드를 먼저 렌더링해야 할 때 필요에 따라 이 정보를 사용자 애플리케이션에 푸시(push)할 수 있다. 컨텍스트 주입 스테이지에서, 스마트 카드는 렌더링 요구사항을 충족시키기 위해 필요한 데이터의 타입을 정의 한다. 이것은 스마트 카드에 대한 요청 또는 스마트 카드 자체의 일부로 렌더링되는 결과와 관련된 컨텍스트의 주입을 의미할 수 있다. 최종 스테이지는 로직 주입 스테이지이고, 로직 주입 스테이지에서 개발자는 로직 엔진이 동작해야 하는 제안 또는 다른 동적 기능을 결정하기 위한 프로그래밍 언어 명령어의 형태로 프로그램 로직을 인코딩할 수 있다. 이것은 임의의 프로그래밍 언어로 수행될 수 있고 이전 스테이지에 의해 주입된 임의의 컨텍스트를 동작시킬 수 있다. 업데이트 시스템은 다수의 버전의 동일 타입 스마트 카드를 관리할 수 있다. 사용자 애플리케이션 디바 이스의 사양에 따라, 이것은 사용자에게 전송될 스마트 카드의 최적 버전을 선택한다. 이것은 스크린 사이즈, 해상도, 컴퓨팅 기능 또는 네트워크 연결과 같은 디바이스의 다양한 제약 조건에 따라 결정될 수 있다. 본 발명의 다른 엘리먼트(제4 엘리먼트)는 스마트 카드 통신 프레임워크이다. 스마트 카드 통신 프레임워크에 서, 스마트 카드 로직 엔진에 외부 리소스와의 통신을 허용하는 후크가 제공된다. 가장 간단한 케이스에서, 이 것은 사용자가 카드를 보는 동안 카드가 동적으로 업데이트될 수 있도록 백엔드 서버 사용자 애플리케이션과의 통신일 수 있다. 이는 비디오가 라이브 스트리밍되고 있거나 스트리밍되는 데이터(예컨대, 주가) 또는 임의의다른 실시간 기능이 있는 경우일 수 있다. 더 복잡한 케이스는, 상이한 디바이스들 상의 스마트 카드들이 서로 상호작용하는 경우이다. 이것은 내장된 화상 통화 또는 일대일 통신의 경우에 원격 디바이스들의 카드 간에 직 접 발생할 수 있다. 연결해야 하는 스마트 카드가 2개 이상인 경우, 통신 프레임워크는 서버 역할을 하는 마스 터 카드를 선택하고 다른 카드는 연결하여 메시를 생성할 수 있다. 이 선택이 불안정하거나 실패하는 경우, 백 엔드 서버가 원격 마스터 역할을 하도록 생성될(spawned) 수 있으며 이를 통해 프록시로 통신이 발생할 수 있다. 본 발명의 다양한 실시형태가 설명되었지만, 본 발명의 범위 내에 있는 더 많은 실시형태 및 구현예 가능하다는 것이 당업자에게 명백할 것이다. 또한, 여기에 설명된 다양한 피쳐, 엘리먼트 및 실시형태는 임의의 조합 또는 배열로 청구되거나 결합될 수 있다. 도 2는 사용자 디바이스 상에서 실행되는 사용자 애플리케이션에 대한 스마트 카드를 생성하기 위한 시스템의 예시적 실시형태를 도시한다. 도 2에서, 사용자 디바이스는 디스플레이 스크린 등의 사용자 인터페이스 및 하나 이상의 메모리 디바이스에 저장될 수 있는 사용자 데이터를 제공한다. 스마트 카드 기능 (smart card capability)을 갖는 사용자 애플리케이션은 사용자 디바이스에서 실행될 수 있다. 사용 자 디바이스는 사용자 애플리케이션이 액세스하여 사용할 수 있는 사용자 디바이스 트랜스시버(220 A)와 같은 원격 통신을 위한 수단을 제공할 수 있다. 사용자 애플리케이션은 전술한 4개의 핵심 엘리먼트, 즉 제1 렌더링 프레임워크(224A), 스마트 카드 로직 엔진, 스마트 카드 최적화 시스템, 및 제1 스마트 카드 통신 프레임워크(236A)를 포함할 수 있다. 추가적인 지원 소프트웨어 및 하드웨어는 당업자에 의해 이해될 것이며, 따라서 여기에서 상세하게 설명되지 않는다. 사용자 디바이스 트랜스시버(220A)는 근거리 통신망(local area network), 광역 통신망(wide area network), 개인 통신망(personal area network), 인터넷 등과 같은 임의의 전자 통신 네트워크에 액세스할 수 있다. 네트워크를 통해, 사용자 애플리케이션은 백엔드 서버에 액세스할 수 있다. 백엔드 서버 는, 제2 렌더링 프레임워크(224B), 제2 스마트 카드 통신 프레임워크(236B), 및 컨텍스트 주입 엔진를 더 포함하는, 스마트 카드 번들 생성기를 포함할 수 있다. 백엔드 서버는 네트워크를 통한 통신을 용이하게 하기 위해 사용되는 백엔드 트랜스시버를 포함할 수도 있다. 백엔드 서버는, 네트워크를 통해, 스마트 카드 레지스트리, 하나 이상의 정보 서버, 및 여 기에서 설명한 바와 같은 또는 구성될 수 있는 다른 디바이스 또는 위치(location)에 액세스할 수 있다. 스마 트 카드 레지스트리는 카드 요청의 도메인에 기초하여 이용 가능한 카드의 하나 이상의 데이터베이스이다. 도메인은 카드의 기반이 되는 토픽(topic)이다. 도메인의 예로는 주식, 조리법, 레스토랑, 및 기타 활동이나 사용자 관심사항이 있다. 사용자 애플리케이션이 백엔드 서버에 카드 요청을 전송할 때 스마트 카드가 생성될 수 있다. 이어 서, 백엔드 서버는 스마트 카드 레지스트리 내의 실행 가능한(viable) 스마트 카드를 검색하여 탑 카 드를 리트리브할 수 있다. 탑 카드는 백엔드 서버에 저장된 사용자 정보 및 도메인에 기초하여 결정된다. 이 단계는 이하에서 도 5에 관하여 더 상세히 설명될 것이다. 최적 스마트 카드를 리트리브할 때, 렌더링 프레임워크와 스마트 카드 통신 프레임워크가 협업하여 사용자 애플리케이션과 사용자 디바이스에 대하여 호환 가능한 스마트 카드 포맷을 생성한다. 컨텍 스트 주입 엔진은 사용자 요청에 대하여 최적 스마트 카드를 맞춤화하기 위해 정보 서버로부터 컨텍 스트 데이터(보조 메타데이터 등)를 리트리브할 수 있다. 위에 나열된 예시적 도메인에 기초하여, 컨텍스트는 주가, 레시피의 재료, 레스토랑 리스트 등이 될 수 있다. 스마트 카드 로직 엔진을 사용한 추가적인 맞춤 화(customization)를 위해, 스마트 카드 번들이 생성되어 사용자 애플리케이션에 리턴될 수 있다. 스마트 카드 번들은 하나 이상의 정보 서버로부터의 컨텍스트를 가진 탑 카드이다. 예를 들어, 카드 요청이 주식 도메인에 대한 것인 경우, 탑 카드는 이 사용자가 한 번에 3개의 주식을 보고 싶어하는 서버에 저장된 사용자 정보를 기반으로 3개 이상의 주식을 디스플레이하는 카드일 수 있다. 컨텍스트는 사용자가 사용자 애플리케이 션에서 마지막으로 본 3개의 마지막 주식일 수 있다. 이러한 맞춤화는 사용자 데이터 또는 정보 서버로부터의 사용자 정보와 같은 사용자 정보에 기초할 수 있으며, 이 정보 서버는 AI 엔진을 사용하여 프로세싱되어 사용자가 카드에서 예상하는 최적의 정보 및 이러 한 정보의 디스플레이를 제공하는 방식으로 사용자를 위해 카드를 자동으로 맞춤화한다. 예컨대, 사용자 애플리케이션은 영화 플레이어일 수 있고, 사용자 요청은 사용자 애플리케이션을 여 는 수동적 요청이고, 카드 요청은 사용자에게 영화를 디스플레이하는 사용자 인터페이스에 대한 요청일 수 있다. 최적의 스마트 카드는, 특정 사용자의 과거 히스토리 및 이전 카드와의 사용자의 과거 상호작용을 기반 으로, 특정 사용자에 대한 최적의 포맷으로 특정 사용자에 대한 최적의 정보를 제공하는 영화 정보를 디스플레 이하기 위한 템플릿일 수 있다. 각각의 사용자 경험은 AI 엔진에 의해 상이하게 만들어질 수 있다. 컨텍스트 는 사용자가 선택할 수 있는 영화 결과의 일반 리스트일 수 있다. 스마트 카드 번들을 수신하면, 카드 로직 엔 진은 사용자 데이터로부터 사용자의 마지막으로 본 영화가 절반만 완료되었다고 결정할 수 있고, 마 지막으로 본 영화 타이틀을 디스플레이된 리스트의 상단으로 이동시킬 수 있다. 카드 로직 엔진은 또한, 정보 서버로부터 사용자 히스토리가, 이 사용자가 액션 영화를 자주 검색하고 디스플레이된 리스트의 상단 으로 액션 영화 타이틀을 이동시킨다는 것을 보여주는 것을 결정할 수 있다. 또한, 웹 브라우저 검색 히스토리 는, 사용자가 자동차에 관심이 있고 오래된 클래식 머슬카를 소유하고 있으며 여자 무술에 관심이 있음을 보여 줄 수 있으므로 이에 따라 카드 로직 엔진은 무술 싸움을 주도하는 여성을 포함하는 클래식 머슬카를 포함하는 액션 영화를 보여줄 것이다. 일 실시형태에서, 사용자 애플리케이션은 또한, 네트워크 또는 추가 스마트 카드 맞춤화를 위한 개별 네트워크를 통해 정보 서버에 액세스할 수 있다. 마찬가지로, 백엔드 서버는 개별 네트워크를 통해 또는 직접 정보 서버(268_ 및/또는 스마트 카드 레지스트리에 액세스할 수 있다. 도 3은, 동일 사용자 쿼리에 기초하여 4명의 상이한 사용자에게 디스플레이되는 예시적 스마트 카드를 도시한다. 본 실시예에서, 사용자 애플리케이션은 레시피 찾기 애플리케이션일 수 있고, 4명의 상이한 사용자 들이 \"이탈리아 레시피를 찾아주세요\"라는 동일한 오디오 명령 요청을 입력했을 수 있다. 도 2에서 논의된 바 와 같이 이탈리아 레시피의 일반적 세트를 가진 사용자 애플리케이션으로 스마트 카드 번들을 리턴시키면, 4명 의 사용자에 대한 레시피 찾기 애플리케이션에서의 개별 카드 로직 엔진은, 사용자 디바이스 상의 사용자 데이 터의 분석(사용자의 사용 히스토리, 관심, 과거 행동, 미래 행동, 또는 사용자 선호도 등) 및/또는 정보 서버 상의 사용자 데이터(사용자의 검색 히스토리 또는 시청 결과 등)에 기초하여 하기의 결정을 내릴 수 있다: a) 사용자 1은 채식주의자이며 일반적으로 제2 후속 요청을 요구하지 않는다; b) 사용자 2는 다이어트 중이고 파스 타를 먹지 않으며 일반적으로 결정을 내리기 위해 둘 이상의 결과가 필요하다; c) 사용자 3은 간단하고 빠른 식 사를 요리하는 것을 좋아하는 부모이며 자녀에게 보여주기 위해 한 번에 둘 이상의 결과를 보는 것을 좋아한다; 그리고 d) 사용자 n은 매운 음식을 좋아하며 일반적으로 매운 레시피를 요구한다. 결과적으로, 사용자 애플리케이션의 동일한 스마트 카드 번들은 4명의 사용자를 위해 매우 상이한 스마트 카드 로 맞춤화될 수 있다: a) 사용자 1은 추가 레시피 추천 없이 하나의 채식 레시피를 가진 카드를 수신할 수 있다; b) 사용자 2는 저지방 단백질이 포함된 2개의 탑 레시피(top recipe)와 저지방 단백질을 포함하는 레시피 에 대한 3개의 추가 추천을 수신할 수 있다; c) 사용자 3은 조리 시간이 15분 미만인 하나의 레시피와 조리 시 간이 15분 미만인 레시피에 대한 3개의 추가 추천을 수신할 수 있으며 레시피가 어린이가 볼 수 있도록 결정되 었기 때문에 영양 성분 표시가 제거된다; 그리고 d) 사용자 4는 매운 음식이 포함된 하나의 레시피와 매운 음식 레시피에 대한 3개의 추가 추천을 수신할 수 있다. 각 카드는 특정 사용자에게 맞춤화되어 해당 사용자에게 최 적의 관심 정보를 제공한다. 도 4는 스마트 카드를 생성하기 위한 예시적 프로세스를 도시한 동작 플로우 다이어그램이다. 단계 404에서, 사용자 디바이스 또는 사용자 애플리케이션은 사용자 요청을 수신한다. 위에서 논의된 바와 같이, 사용자 요청 은 능동적 입력(음성 명령을 입력하는 등) 또는 수동적 입력(사용자 애플리케이션 또는 사용자 애플리케이션에 서의 피쳐 페이지를 오픈하는 것 등)일 수 있다. 사용자 요청에 응답하는 카드(검색을 위한 사용자 입력에 응 답하는 검색 결과의 리스트, 또는 사용자 애플리케이션을 여는 사용자의 수동적 동작에 응답하는 사용자 애플리 케이션의 메인 페이지 등)를 생성하기 위해, 단계 408에서, 사용자 애플리케이션은 백엔드 서버에 대한 카드 요 청을 만들 수 있다. 카드 요청을 수신하면, 단계 412에서, 백엔드 서버는 사용자 애플리케이션에 스마트 카드 번들을 리턴할 수 있다. 이 단계는 도 5에 관하여 더 상세히 설명될 것이다. 단계 416에서, 스마트 카드 번들은 사용자 디바이스에 대하여 맞춤화될 수 있고, 사용자의 디바이스의 기능들 (폰 타입, 스크린 사이즈, 배터리 수명 등) 및 사용자 설정들(다크/라이트 모드, 명도, 위치 온/오프 등)에 기 초하여, 사용자 애플리케이션이 동작한다. 단계 420에서, 사용자 정보에 기초하여 (용어집에 규정된 바와 같이, 도 2 및 도 3에서 논의되고 도 6 내지 도 9에서의 상세한 설명에서 논의되는 바와 같이) 스마트 카드 번 들이 추가로 맞춤화된다. 단계 424에서, 스마트 카드 번들은 단계 416 및 420에 기초하여 렌더링되어 사용자에게 디스플레이된다. 디스 플레이시에, 스마트 카드는 동적 맞춤화의 기능을 유지한다. 단계 428에서, 사용자 애플리케이션에서의 최적화 시스템은 추가 컨텍스트가 필요한지 여부를 결정할 수 있다. 이러한 결정은 사용자가 스마트 카드의 디스플레 이를 종료할 때까지 지속적으로 이루어질 수도 있고 또는 자원을 절약하기 위해 설정된 간격으로 이루어질 수도 있다. 위에서 논의된 사용자 애플리케이션이 레시피 찾기 애플리케이션인 실시예를 사용하여, 스마트 카드가 사용자를 위해 선택한 상단 레시피를 이미 디스플레이했을 수 있지만 최적화 시스템은 사용자에게 추가 추천이 필요하다고 결정했다. 따라서, 단계 432에서, 최적화 시스템은 추가 맞춤화가 요구되는 추가 컨텍스트를 리트리 브할 수 있다. 추가 컨텍스트를 리트리브하는 프로세스는 도 10에서 더 상세히 논의된다. 단계 436에서, 스마 트 카드는 리트리브된 추가 컨텍스트를 사용하여 업데이트될 수 있다. 단계 440에서, 사용자 애플리케이션의 최적화 시스템은 가입을 결정할 수 있고 데이터의 진행 중인 스트림(on- going stream)이 필요할 수 있다. 이러한 결정은 사용자가 스마트 카드의 디스플레이를 종료할 때까지 지속적 으로 이루어질 수도 있고 또는 자원을 절약하기 위해 설정된 간격으로 이루어질 수도 있다. 예를 들어, 사용자 애플리케이션이 온라인 주식 거래 애플리케이션인 경우 최적화 시스템은 사용자가 주식 값의 실시간 업데이트를 필요로 한다고 결정할 수 있다. 따라서, 단계 444에서, 최적화 시스템은 추가 맞춤화가 요구되는 가입 데이터 를 리트리브할 수 있다. 가입 데이터를 리트리브하는 프로세스는 도 17에서 더 상세히 논의된다. 단계 436에 서, 이미 디스플레이된 스마트 카드는 추가 가입 데이터를 사용하여 업데이트될 수 있다. 스마트 카드가 추가 컨텍스트(단계 428-432) 및 가입(단계 440-444) 둘 다를 기반으로 업데이트될 수 있는 경우, 이러한 업데이트는 동시에 또는 어느 하나의 순서(컨텍스트 우선 또는 가입 우선)의 시퀀스로 발생할 수 있다. 도 5는 백엔드 렌더링 프레임워크(backend rendering framework)의 구조를 도시한다. 도 4에서, 사용자 애플리 케이션은 도 2에서 설명된 방법을 사용하여 백엔드 서버와 통신한다. 백엔드 서버는 차례로 스마트 카드 레지스트리 및 하나 이상의 정보 서버와 통신한다. 사용자 요청에 응답하여, 사용자 애플리케이션은 백엔드 서버에 카드 요청을 전송할 수 있다. 카드 요청은 도메인 및 다양한 사용자 특정 정보를 포함할 수 있다. 예컨대, 사용자 애플리케이션이 주식 거래 플랫폼이고, 지난 24시간 동안 3개의 특정 주식을 보기를 사용자가 요청하는 경우에, 카드 요청은 지난 24시간 동안의 사용자 특정의 3개의 주식 및 도메인(주식)을 포함할 수 있다. 카드 요청에 응답하여, 백엔드 서버는 이용 가능한 스마트 카드 패키지에 대해 스마트 카드 레지스트리를 검색할 수 있다. 스마트 카드 패키지는 사용자 데이터를 프로세싱하고 사용자를 위한 최적의 템플릿을 자동으 로 선택하고 템플릿 내의 데이터를 맞춤화하여 맞춤화된 사용자 특정 카드를 생성하는 AI 엔진을 기반으로 동적 으로 수정될 수 있는 동적 엘리먼트가 있는 스마트 카드 템플릿이다. 카드 요청이 지난 24시간 동안의 3개의 주식의 디스플레이를 위한 것인 상기 실시예에서, 이용 가능한 스마트 카드 패키지는 주식 값에 대한 적어도 3 개의 디스플레이 엘리먼트가 있는 템플릿을 포함할 수 있다. 백엔드 서버는 탑 카드를 선택하기 위해 이용 가능한 사용자 정보를 사용할 수 있다. 예를 들어, 백엔드 서버는 사용자가 다크 모드에서 사용자 애플리케이션만을 사용하고 큰 폰트(font)를 사용한다는 것을 나타내기 위해 저장된 사용자 선호도를 가질 수 있다. 따라서, 백엔드 서버는 다크 템플릿 및 큰 폰트를 가진 탑 카드를 선택할 수 있다. 사용자 선호도와 도메인을 기반으로 탑 카드를 선택하는 이 프로세스는 고유 한 사용자 선호도에 기반한 수정이 거의 또는 전혀 없이 일반적으로 모든 사용자에게 동일한 템플릿을 제공하는 선행 기술의 정적 카드를 개선하는 동적 수정의 제1 레이어이다. 백엔드 서버는 스마트 카드 패키지에 컨텍스트를 주입하기 위해 정보 서버로부터의 데이터를 사용할 수 있다. 정보 서버로부터의 컨텍스트는 사용자 요청에 응답하여 스마트 카드를 생성하기 위해 탑 카드를 채우는(populate) 데 필요한 임의의 데이터 또는 정보를 포함한다. 예컨대, 탑 카드를 선택할 때, 백엔드 서버 는 3개의 선택된 주식에 대한 마지막 24시간의 주식 가격을 리트리브하고 리트리브된 데이터의 시각적 디 스플레이로 3개의 주식 디스플레이 엘리먼트를 채울 수 있다. AI 엔진은 사용자에 대하여 카드를 맞춤화할 수 있다. 예를 들어, 사용자가 1년의 기간동안 S&P 500 퍼포먼스와 함께 표시될(plotted) 주식 퍼포먼스를 역사적 으로(historically) 선택한 경우, 사용자에게 제공된 카드는 과거 브라우징 히스토리를 사용하여 구성될 수 있 다. 사용자의 히스토리, 활동, 검색, 위치 데이터, 거래 히스토리, 또는 기타 사용자 데이터에 액세스할 수 있 는 AI 엔진을 사용하여, 수많은 다른 카드 맞춤화가 발생할 수 있다. 이어서, 백엔드 서버는 사용자 애플리케이션에 스마트 카드 번들을 리턴할 수 있다. 스마트 카드 번 들은 주입된 컨텍스트 및 탑 카드 둘다를 포함할 수 있다. 상기 실시예에서, 스마트 카드 번들은 큰 폰트를 가 진 다크 카드 템플릿 상에 디스플레이된 지난 24시간 동안의 3개의 주식 가격을 포함할 수 있다. 도 6은 사용자 애플리케이션 렌더링 프레임워크(user application rendering framework)의 구조를 도시한다. 도 5에 계속해서, 스마트 카드 번들은 백엔드 서버로부터 사용자 애플리케이션으로 전달되며, 여기서 스마트 카드 번들은 사용자에 대한 출력을 위해 스마트 카드가 생성될 때까지 로컬 컨텍스트 주입 엔진 , 프리미티브 컨버젼 엔진, 로직 주입 엔진, 및 디스플레이 디바이스를 사용하여 추가로 프로세싱된다. 로컬 컨텍스트 주입 엔진은 폰 타입(안드로이드 대 iOS), 폰 디스플레이(다크 모드 대 라이트 모드), 스크 린 사이즈, 배터리 수정(전체 디스플레이 대 전력 절약 디스플레이) 등의 로컬 사용자 애플리케이션 컨텍스트 데이터에 기초하여 스마트 카드 번들을 수정하도록 구성된 사용자 애플리케이션의 일부인 소프트웨어 모듈이다. 프리미티브 컨버젼 엔진은 더 높은 디스플레이 성능 및 품질을 달성하기 위해 디바이스에서 이용 가능한 모든 구현을 사용하여 스마트 카드 번들을 최적화한다. 예컨대, 프리미티브 컨버젼 엔진은 “맵” 아이템 을 상호작용 맵의 시스템 특정 구현으로 컨버팅할 수 있다. 로직 주입 엔진은 스마트 카드의 동적 수정의 다음 레이어를 수행한다. 사용자 디바이스, 사용자 애플리 케이션, 및 임의의 보조 메타데이터에 대한 사용자 정보를 분석하여, 로직 주입 엔진은 사용자, 사용 자 히스토리, 및 사용자 작업/활동에 대한 과거 사용자 선호도의 분석에 기초하여 사용자의 요구에 가장 적합하 도록 스마트 카드 번들의 디스플레이 엘리먼트를 재정렬하고(reorder) 그리고/또는 카드에 포함시킬 정보를 결 정한다. 예컨대, 스마트 카드 번들은 마지막 24시간 동안의 3개의 주식 수직 A, B, C의 주식 가격 차트인 경우, 로직 주입 엔진은 사용자가 주식 B 및 C를 보면서 주식 A를 현재 거래하고(또는 조사하거나 작업 중 이거나 열중하고 있거나) 있다고 결정할 수 있다. 따라서, 주식 A는 주식 B 및 C보다 더 큰 디스플레이 윈도우 에 디스플레이될 수 있고, 주식 가격 변동에 대한 시각적 표시 또는 경고를 포함할 수 있다. 로직 주입 엔진 은 또한 주식 C가 지난 24시간 동안 많은 변동성을 보인 반면 주식 B는 안정적으로 유지되었다고 결정할 수 있다. 따라서, 로직 주입 엔진은 주식 B의 차트 이전에 주식 C의 차트를 디스플레이하기 위해 주식 B 및 C 을 재배열할 수 있다. 로직 주입 엔진은, 카드가 생성되면 AI 검출 사용자 선호도 및 사용자 히스토리에 기초하여 정적 카드가 추가 맞춤화를 위한 여지를 남기지 않는 종래 기술에 대한 또 다른 개선 사항이다. 또한, 상기 실시예에서 나타낸 바와 같이, 스마트 카드는 디스플레이된 엘리먼트의 순서뿐만 아니라 맞춤화 가 능하다. 오히려 윈도우 사이즈 및 데이터 자체의 특성과 같은 디스플레이 파라미터는 사용자 요구에 따라 맞춤 화 가능할 수 있다. 또한, 핵심 개선 사항은 이러한 맞춤화의 AI 특성이다. 사용자가 맞춤화를 위한 특정 요 청을 입력할 수 있다고 생각되지만, 로직 주입 엔진은 또한 자동으로 그리고 동적으로 이러한 맞춤화를 수 행할 수 있다. 디스플레이 디바이스는, 디스플레이를 위해 맞춤화된 스마트 카드 번들을 스마트 카드로 렌더링하고, 사용자에게 스마트 카드를 출력한다. 도 7은 프리미티브 컨버젼 엔진(primitive conversion engine)을 도시한다. 도 7에서, 사용자 디바이스 는 사용자 애플리케이션 및 로컬 프리미티브 스토어(local primitive store)를 포함한다. 로컬 프리 미티브 스토어는 사용자 디바이스 상의 모든 사용자 애플리케이션이 사용할 수 있는 사용자 인터페이 스 엘리먼트를 포함한다. 예를 들어, 모든 iOS 스마트폰은, 디스플레이 윈도우의 둥근 모서리나 특정 폰트 또 는 색 구성표(color scheme)와 같은 모든 AppleTM 애플리케이션이 균일하게 보이도록 사용할 수 있는 사용자 인 터페이스 엘리먼트를 포함할 수 있다. 사용자 애플리케이션은 다른 것들 중 로컬 컨텍스트 주입 엔진 , 프리미티브 컨버젼 엔진, 커스텀 프리미티브 스토어(custom primitive store), 폴백 캔버스 프리미티브(fallback canvas primitive), 및 로직 주입 엔진을 포함한다. 도 6에서 논의된 바와 같이, 스마트 카드 번들은 우선 로컬 컨텍스트 주입 엔진에 의해 프로세싱될 수 있 다. 이어서, 로컬 컨텍스트 주입 엔진은 프리미티브 사양을 가진 스마트 카드 번들을 프리미티브 컨버젼 엔진으로 전송한다. 프리미티브 사양은 로컬 컨텍스트와 함께 스마트 카드의 전체 예상 엘리먼트에 대한 정의 집합(set of definitions)이다(그림 6에서 논의됨). 예를 들어, 스마트 카드 번들은 지난 24시간 동안의 3개의 주식 가격을 표시하는 3개의 디스플레이 엘리먼트와 큰 폰트가 있는 다크 템플릿일 수 있다. 로컬 컨텍 스트는 iPhone 12의 스크린 사이즈에 맞는 카드일 수 있다. 프리미티브 사양은 위의 모든 설명을 렌더링하는 데 필요한 <div> 엘리먼트, <span> 태그 등에 대한 사양일 수 있다. 프리미티브 컨버젼 엔진은, 특정 특성 사용자 애플리케이션으로 확장되는 커스텀 프리미티브의 세트를 형성하기 위해, 프리미티브 사용을 자연적으로 미리 구현된 프리미티브와 결합한다. 프리미티브 사양을 수신하면, 프리미티브 컨버젼 엔진은 사양을 충족시키기 위해 이용 가능한 사용자 인터페이스 엘리먼트에 대한 로컬 프리 미티브 스토어를 먼저 검색할 수 있다. 로컬 프리미티브 스토어가 프리미티브 사양을 충족시키기 위 해 요구되는 모든 엘리먼트를 포함하는 경우, 프리미티브 컨버젼 엔진은 프로세싱을 완료하고 로직 주입 엔진에 렌더링 사양을 전달할 수 있다. 렌더링 사양은 지정된 프리미티브를 사용하여 로컬 컨텍스트로 스 마트 카드 번들을 렌더링하는 데 필요한 사양 세트이다. 예를 들어, 맵 애플리케이션은 맵의 스마트 카드를 렌 더링하기 위해 먼저 기본적으로 구현된 버전의 맵 및 유사한 컴포넌트를 사용할 수 있다. 바람직한 실시형태에 서, 로컬 프리미티브 스토어의 엘리먼트는 퍼포먼스를 최적화하기 위해 먼저 사용된다(프로세싱 속도를 증 가시키고 메모리 및 배터리 수명과 같은 리소스를 보존하는 것을 포함하지만 이에 제한되지 않음). 로컬 프리미티브 스토어가 필요한 모든 엘리먼트를 포함하지 않는 경우, 프리미티브 컨버젼 엔진은 다음으로 추가 엘리먼트에 대한 커스텀 프리미티브 스토어를 검색할 수 있다. 커스텀 프리미티브 스토어 는 특히 사용자 애플리케이션에 의해 그리고 사용자 애플리케이션을 위해 제공된 사용자 인터페 이스 엘리먼트를 포함한다. 예컨대, 주식 애플리케이션은 주식 가격 차트 및 테이블의 디스플레이를 위해 필요 한 엘리먼트를 포함할 수 있다. 커스텀 프리미티브 스토어가 프리미티브 사양을 충족시키기 위해 요구되 는 모든 엘리먼트를 포함하는 경우, 프리미티브 컨버젼 엔진은 프로세싱을 완료하고 로직 주입 엔진 에 렌더링 사양을 전달할 수 있다. 반면에 로컬 프리미티브 스토어도 커스텀 프리미티브 스토어도 필요한 모든 엘리먼트를 포함하지 않 는 경우, 프리미티브 컨버젼 엔진은 갭(gap)을 채우기 위해 그리고 스마트 카드가 여전히 모든 사용자 애 플리케이션에서 렌더링될 수 있도록 보장하기 위해 폴백 캔버스 프리미티브를 이용할 수 있다. 도 8은 폴 백 캔버스 프리미티브가 어떻게 사용되는지에 대한 상세한 논의를 포함한다. 다른 실시형태에서, 프리미티브 컨버젼 엔진은 로컬 프리미티브 스토어, 커스텀 프리미티브 스토어 , 및 폴백 캔버스 프리미티브의 임의의 조합을 사용하여 프리미티브 사양을 임의의 순서로 프로세싱 할 수 있다. 도 8은 폴백 캔버스 프리미티브(fallback canvas primitive)를 도시한다. 도 8에서, 사용자 디바이스는 사용자 애플리케이션 및 디바이스 정보 스토어를 포함한다. 사용자 애플리케이션은 프리미티브 엔진 및 폴백 캔버스 엔진을 포함한다. 폴백 캔버스 엔진은 클라우드 또는 원격 클라우드 기반 서버 내에 저장될 수 있는 렌더 데이터베이스(render database)에 연결된다. 렌더링 데이터베이스는 카드 사 양의 정적 렌더링을 제공할 수 있다. 도 7에서 논의된 바와 같이, 프리미티브 엔진은 로컬 프리미티브 스토어 또는 커스텀 프리미티브 스토어로 부터의 적절한 프리미티브가 이용가능하지 않을 수 있는 프리미티브 사양을 렌더링하기 위해 폴백 캔버스 프리 미티브를 사용할 수 있다. 이 경우에, 프리미티브 엔진은 폴백 캔버스 프리미티브에 스마트 카 드 사양의 세트를 전송할 수 있다. 스마트 카드 사양은 스마트 카드에서 정적 카드 또는 정적(상호 작용할 수 없는) 엘리먼트를 렌더링하는 데 사용되는 파라미터이다. 폴백 캔버스 프리미티브는 정적 렌더링을 제공 할 수 있는 원격 데이터베이스에 원격 요청을 트리거할 수 있다. 원격 데이터베이스는 원격 렌더 결 과(remote render results)를 리턴할 수 있다. 폴백 캔버스 프리미티브는 스마트 카드에서의 정적 카드 또는 정적 엘리먼트를 생성하기 위해 원격 렌더 결과를 사용자 디바이스 디스플레이 데이터와 결합할 수 있다. 사용자 디바이스 디스플레이 데이터는 디바이스 정보 스토어로부터 획득될 수 있는 지원되는 픽셀의 수, 픽셀 강도, 블랙/화이트 또는 컬러 디스플레이 등의 사용자 디바이스의 디스플레이 기능을 규정하는 데이 터이다. 이어서, 도 6에서 설명된 바와 같이, 사용자 애플리케이션에서의 디스플레이 디바이스로 정적 렌더가 전달될(passed) 수 있다. 도 6에서 논의된 바와 같이, 스마트 카드 번들이 프리미티브 컨버젼 엔진에 의해 프로세싱된 후에, 스마트 카드 를 사용자에 대해 추가로 맞춤화하기 위해 로직 주입 엔진은 스마트 카드 번들을 프로세싱할 수 있다. 이 단계 는, 사용자의 고유 요구사항에 맞추기 위해 카드에서의 사용자 데이터 및 AI 엔진을 사용하여, 최소의 맞춤화를 포함하고 엘리먼트를 재배열할 수 없는 종래 카드에 대한 개선점이다. 도 3은 \"이탈리아 레시피를 찾아주세 요\"라는 오디오 명령을 입력한 4명의 상이한 사용자가 4개의 상이한 스마트 카드 디스플레이를 수신하는 방법의 실시예를 도시한다. 도 9는 도 3에서의 4개의 상이한 스마트 카드가 로직 주입 엔진을 사용하여 달성될 수 있는 방법을 도시한다. 단계 908에서, 로직 주입 엔진은 우선 사용자 요청을 하는 사용자 계정을 식별 할 수 있다. 단계 912에서, 식별된 사용자 계정의 고유 사용자 프로파일이 수집될 수 있다. 고유 사용자 프로 파일은, 사용자 디바이스, 사용자 애플리케이션, 또는 임의의 다른 연결된 디바이스들, 데이터베이스, 또는 서버에서 이용 가능한 임의의 사용자 정보(사용자 계정 정보, 사용자 히스토리, 사용자 선호도 등)를 포함할 수 있다. 단계 916에서, 스마트 카드를 맞춤화하는데 필요한 핵심 사용자 특성을 결정하기 위해 고유 사용자 프로파일의 분석이 수행될 수 있다. 도 3의 실시예에서 논의된 바와 같이, 로직 주입 엔진은 단계 916A에서 사용자 1 이 채식주의자이고 일반적으로 제2 후속 요청을 요구하지 않는다고 결정할 수 있다. 로직 주입 엔진은 단 계 916B에서 사용자 2가 다이어트 중이고 파스타를 먹고 있지 않으며 일반적으로 결정을 내리기 위해 하나 이상 의 결과를 필요로 한다고 결정할 수 있다. 로직 주입 엔진은 단계 916C에서 사용자 3이 부모이고 간단하 고 빠른 식사를 요리하는 것을 좋아하고, 또한 한 번에 하나 이상의 결과를 보고 자녀에게 보여주기를 좋아한다 고 결정할 수 있다. 그리고, 로직 주입 엔진은 단계 916D에서 사용자 n이 매운 음식을 즐기고 일반적으로 매운 레시피를 요구한다고 결정할 수 있다. 결정 단계는, 카드를 생성하기 위한 맞춤화된 그리고 고유한 경험 을 생성하기 위해 사용자에 관한 모든 데이터를 프로세싱하는 AI 엔진에 의한 임의의 수의 팩터(factor)에 기초 할 수 있다. 단계 920에서, 스마트 카드 번들은 단계 916에서의 결정에 기초하여 맞춤화될 수 있다. 예컨대, 단계 920A에서, 사용자 1에 대한 스마트 카드는 추가 레시피 추천 없이 하나의 채식 레시피를 나타내도록 맞춤화될 수 있다. 단계 920B에서, 저지방 단백질을 가진 2개의 탑 레시피 및 저지방 단백질을 포함하는 레시피에 대한 3개의 추가 추천을 나타내도록 사용자 2에 대한 스마트 카드가 맞춤화될 수 있다. 단계 920C에서, 15분 미만의 요리 시간을 가진 하나의 레시피 및 15분 미만의 요리 시간을 가진 레시피에 대한 3개의 추가 추천을 나타내도 록 사용자 3에 대한 스마트 카드가 맞춤화될 수 있고, 레시피는 자녀가 볼 수 있도록 결정되기 때문에 영양 성 분 표시(nutrition facts label)가 제거된다. 그리고, 단계 920D에서, 매운 음식을 가진 하나의 레시피 및 매 운 음식 레시피에 대한 3개의 추가 추천을 나타내도록 사용자 4에 대한 스마트 카드가 맞춤화될 수 있다. 이러한 레벨의 맞춤화, 특히 사용자 애플리케이션의 사용 히스토리를 넘어 사용자 정보의 포괄적인 수집 분석 및 개별 사용자의 요구에 맞게 사용되는 다양한 맞춤화된 사용자 특정 카드 엘리먼트는 정적 카드를 렌더링하는 기존의 방법으로 달성되지 않을 수 있다. 도 10은 도 3에서의 4개의 상이한 스마트 카드가 추가적으로 사용자 특정 프롬프트로 맞춤화될 수 있는 방법을 도시한다. 도 9의 단계들에 이어서, 그리고 고유 사용자 프로파일의 동일 결정에 기초하여, 각 사용자는 대체 레시피 타입(예컨대, 채식주의자 대 육류 레시피), 식사 옵션(예컨대, 배달), 음료 추천, 또는 사용자 관심의 추가 개발(예컨대, 사용자 2를 위한 운동 계획 설정 프롬프트)에 대한 프롬프트를 수신할 수 있다. 도 10에 도 시된 바와 같이, 사용자 특정 프롬프트의 콘텐트는 사용자 애플리케이션의 펑션 및 기능을 넘어 확장될 수 있으 며, 이는 사용자 애플리케이션 특정 콘텐트로 제한될 수 있는 정적 카드를 렌더링하는 기존 방법에 대한 추가적 인 개선이다. 이와 대조적으로, 스마트 카드의 사용자 특정 프롬프트는, 특정 사용자에게 맞춤화된 더 나은 정 보를 요구하고 받을 수 있도록 사용자를 안내하고 탐색하는 데 도움이 되도록, 각 사용자에게 고유한 사용자 경 험을 제공한다. 사용자가 요청할 때마다 완전히 새롭고 고유한 프롬프트가 스마트 카드에 디스플레이될 수 있 다. 이것은 과거 및 현재 컨텍스트를 분석하여 사용자의 선호도, 좋아하는 것, 싫어하는 것을 결정할 수 있는 AI 서비스를 통해서만 가능하다. 사용자가 이러한 고유한 프롬프트에 응답하면 스마트 카드에 렌더링 후 최적화가 필요할 수 있다. 예를 들어, 도 10에 도시된 바와 같이, 사용자 1에 대한 채식 음식 배달 제안 2에 대한 응답으로, 사용자 1은 제안된 배달 을 요청할 수 있다. 이어서, 스마트 카드는 사용자 1의 후속 요청에 응답하여 디스플레이로 업데이트될 수 있 다. 이것은 더 이상 업데이트되거나 맞춤화될 수 없는 기존의 정적 카드에서 또 다른 개선 사항이다. 사용자 애플리케이션에 의한 카드 요청에 응답하여 생성된 스마트 카드는 초기에 사용자 애플리케이션의 기능을 활용하는 엘리먼트로 컴파일될 수 있음이 명백해야 한다. 예컨대, 레시피 찾기를 위해 생성된 스마트 카드는 레시피를 디스플레이하는 엘리먼트를 포함하고, 영화 스트리밍 애플리케이션을 위해 생성된 스마트 카드는 영화 제목 또는 영화를 디스플레이하는 엘리먼트를 포함하고, 주식 거래 플랫폼을 위해 생성된 스마트 카드는 주식을 디스플레이하는 엘리먼트를 포함한다. 도 11은 렌더링 후 최적화를 달성할 수 있는 스마트 카드 최적화 시스템 을 도시한다. 예컨대, 이전에 논의된 바와 같이, 최적화 시스템은 사용자 애플리케이션의 기능을 넘는 스마트 카드의 동적 맞춤화에 기여하는 4개의 핵심 엘리먼트 중 하나이다. 최적화 시스템은 원격 데이터베이스이거나 보조 메타데이터 요청을 해결할 수 있는 서버일 수 있는 데이터 스토어로부터 데이터를 가져올(fetching) 수 있 는 서버에서 실행되는 컨텍스트 주입 엔진을 포함할 수 있다. 도 11에서, 렌더링된 스마트 카드는 사용자 애플리케이션에 또는 사용자 애플리케이션이 실행되는 사용자 디바이스에 디스플레이될 수 있다. 사용자 애플리케이션은 최적화 시스템을 포함할 수 있다. 최적화 시 스템은 도 2에서 논의된 다수의 방법을 통해, 하나 이상의 정보 서버와 통신할 수 있다. 도 10에 서 논의된 예를 사용하여, 사용자 애플리케이션은 배달 옵션에 대한 고유한 프롬프트를 사용자에게 제공하는 레 시피 찾기 애플리케이션일 수 있다. 배달 옵션 자체는 사용자 애플리케이션이 기본적으로 제공하는 피쳐가 아 닐 수 있다. 사용자 요청(위에서 논의된 바와 같이, 수동 동작 또는 능동 입력일 수 있음)에 응답하여, 스마트 카드는, 디스플레이할, 기존 엘리먼트를 업데이트하거나 새로운 엘리먼트를 제공하기 위해, 추가 컨텍스 트를 요청할 수 있다. 필요한 추가 데이터를 식별하고 획득하기 위한 요청을 프로세싱하는 최적화 시스템 으로 컨텍스트 요청이 라우팅될 수 있다. 예를 들어, 채식주의 음식 배달을 요청하는 사용자에 대한 컨 텍스트 요청은 배달 서비스를 제공하는 반경 5마일 내에서 이용 가능한 채식 레스토랑 리스트를 검색하는 것일 수 있다. 컨텍스트 요청을 수신하면, 최적화 시스템은 하나 이상의 정보 서버에 데이터를 요청할 수 있다. 본 실시예에서, 최적화 시스템은 구글 맵 또는 옐프(Yelp)와 같은 써드 파티 서버를 사용하여, 운영 시간, 배달 비용, 메뉴 및 온라인 주문 양식에 대한 링크와 같은 추가 정보 및 인근 채식 식당을 식별한다. 데이터를 수신하면, 최적화 시스템은 스마트 카드가 디스플레이할 수 있는 렌더링 가능 사양으로 컨텍스 트를 패키징할 수 있다. 위에서 논의된 바와 같이, 사용자 애플리케이션은 기본적으로 배달 옵션(식당 나열, 메뉴 리트리빙, 주문 양식 디스플레잉과 같이 위에서 논의된 많은 피쳐를 포함할 수 있음)을 지원하지 않을 수 있다. 종래의 정적 카드는 사용자 애플리케이션에 의해 지원되지 않는 엘리먼트를 디스플레이할 능력을 가지지 않을 수 있다. 대조적으로, 스마트 카드는 이 피쳐들을 디스플레이하는 엘리먼트를 생성할 수 있다. 백엔드 서버와의 상호작용에 기초하여 라이브 데이터(live data)로 디스플레이를 업데이트하는 스마트 카드의 능력이 종래 정적 카드로부터의 다른 개선 사항이다. 도 12는 라이브 데이터 업데이트가 있는 예시적 주식 시 장 스마트 카드를 도시한다. 이 실시예에서 스마트 카드의 주식 가격에 대한 데이터는 실시간으로 업데이트되 므로 거래자는 스마트 카드를 통해 매수/매도할 수 있다. 도 13은 도 12의 예시적인 스마트 카드가 달성될 수 있는 방법을 보여주기 위한 스마트 카드와 백엔드 서버 사 이의 통신 프레임워크를 도시한다. 도 13에서, 스마트 카드는 도 2에서 논의된 방법 중 하나를 사용하여 백엔드 서버와 통신할 수 있다. 백엔드 서버는 하나 이상의 정보 서버와 통신할 수 있다. 스마트 카드에서의 디스플레이가 도 12에서의 예시적 스마트 카드에서의 주식 가격 변동과 같은 실시간 업데이트를 요구하는 경우, 스마트 카드는 업데이트된 상태에서 카드를 유지하기 위해 백엔드 서버로부터 업데 이트를 수신하도록 백엔드 서버에 가입할 수 있다. 가입은 결과 스트림에 대한 요청이다. 스트림은 데이터가 지속적으로 제공되는 통신 모드이다. 주식 시장 카드의 실시예에서 가입은 주식 가격에 대한 것이다. 백엔드 서버는 차례로 업데이트를 위해 하나 이상의 정보 서버를 모니터링하기 시작할 수 있다. 주식 시장 카드의 실시예에서, 정보 서버는 주식 가격을 디스플레이하는 써드 파티 웹사이트일 수 있다. 백엔드 서버은 이 웹사이트를 모니터링할 수 있고, 주식 가격에서의 변동이 검출되면 이 변동을 스마트 카드에 스트리밍하고, 가격은 임의이 변동에 무관하게 주기적으로 업데이트될 수 있다. 다른 실시형태에서, 개별 스마트 카드는 정보 서버를 모니터링할 수 있고, 써드 파티 데이터를 직접 획득할 수 있다. 그러나, 써드 파티 데이터는 가입 비용을 필요로 할 수 있으므로 백엔드 서버를 사용하는 실시형태가 바 람직하다. 백엔드 서버는 하나의 구독료로 임의의 수의 스마트 카드의 가입 필요를 서비스할 수 있다. 또한, 개별 스마트 카드가 일시적으로 오프라인 상태가 될 수 있는 경우(예컨대, 사용자 디바이스의 잘못된 신호 수신 으로 인해) 백엔드 서버는 실시간으로 써드 파티 데이터를 계속 수신하고 스마트 카드가 다시 온라인 상태가 되 면 스마트 카드에 결과를 소급해서 스트리밍할 수 있다. 백엔드 서버의 라이브 데이터로 디스플레이를 업데이트하는 스마트 카드의 능력은 단순한 결과 스트림 이상으로 확장된다. 스마트 카드는 또한 턴 기반 방식(turn-based fashion)으로 사용자와 상호 작용하고 여러 턴에 걸쳐 상태를 유지할 수 있다. 상태는 특정 시점의 이전 이벤트 또는 사용자 상호 작용의 모음(collection)이다. 일 반적으로 사용자 대 사용자 애플리케이션은 제1 사용자 요청이 제1 응답을 생성하고 제2 사용자 요청이 제2 응 답을 생성한다는 의미에서만 턴 기반이고, 제1 요청의 상태가 유지되지 않기 때문에 제2 응답은 제2 요청뿐만 아니라 제1 요청에 대해서도 응답할 수 있다. 이미 렌더링된 스마트 카드에 대한 각각의 새로운 사용자 요청이 이전 사용자 요청의 컨텍스트에서 분석 및 프로세싱될 수 있도록, AI 서비스를 스마트 카드 및/또는 백엔드 서버에 통합함으로써 상태가 유지될 수 있다. 도 14는 AI 백엔드 서버에 의해 사용자가 실시간 체스 게임을 플레이할 수 있는 예시적 체스 스마트 카드를 도 시한다. 도 14의 체스 게임과 기존의 체스 게임 사용자 애플리케이션에서 플레이되는 체스 게임의 차이점은 도 14의 체스 게임 스마트 카드가 임의의 사용자 애플리케이션에서 사용자에게 디스플레이될 수 있다는 점이다. 예를 들어, 사용자는 레시피 찾기 애플리케이션에서 레시피를 보고 있을 수 있지만 물이 끓기를 기다리는 동안 체스 게임의 플레이를 요청할 수 있다. 이어서, 레시피를 디스플레이하는 이미 렌더링된 스마트 카드는 동일한 카드에 체스 게임을 위한 엘리먼트를 통합할 수 있다. 또한, 게임 플레이는 카드 자체 내에서 발생할 수 있으 며 별도의 체스 플레이 전용의 프로그램이나 소프트웨어 애플리케이션이 필요하지 않다. 도 15는 스마트 카드 템플릿이 스마트 카드 레지스트리에 업로드되고 탑 카드(top card)로 식별되는 방법을 도 시한다. 도 2 및 도 5에서 논의된 바와 같이, 카드 요청에 응답하여, 스마트 카드 레지스트리와 백엔드 서버는 카드 요청에 응답하는 탑 카드를 식별하기 위해 함께 동작한다. 도 15에서, 스마트 카드 사양을 제공함으로써 스마트 카드 템플릿이 생성된다. 스마트 카드 사양 은 렌더링 중에 스마트 카드 번들이 요청할 로직, 컨텍스트, 및 렌더 메타데이터를 규정한다. 로직 요청은 코드의 일부로 모든 로직 및 프로그램 루틴에 대한 프로그램 사양을 포함한다. 이것은 카드가 사용 자가 다른 배우보다 더 좋아하는 배우 또는 특정 장르에 할당하는 순위를 판단하는 기능을 필요로할 수 있다. 필요한 컨텍스트는 사용자 애플리케이션에서 렌더링을 수행하는 일부로 외부 데이터스토어로부터 가져와야 (fetched) 하는 관련 메타데이터이다. 실시예는 카드 사양이 특정 영화의 배우들의 리스트를 요구하는 것일 수 있다. 렌더 메타데이터는 렌더링 프로세스를 달성하기 위해 필요한 사용자 애플리케이션 정보의 정의이다. 이것은 일 반적인 하드웨어 디바이스 정보뿐만 아니라 스크린 사이즈 또는 해상도 및 품질에 대한 정보일 수 있다. 스마트 카드 사양은 스마트 카드 패키지로 컨버팅되고, 등록 요청을 통해 스마트 카드 레지스트리 에 전송된다. 백엔드 서버는 사용자 애플리케이션 및 사용자 디바이스와 가장 호환 가능한 스마트 카드 사양의 세트를 식별함으로써 이용 가능한 스마트 카드 패키지를 검색한다. 탑 카드를 발견하면, 스마트 카드 레지스트리는 백 엔드 서버로 스마트 카드 패키지를 전달하고, 백엔드 서버는 정보 서버로부터 주입된 컨텍스트와 함께 스 마트 카드 번들로 전환된다(turned). 스마트 카드의 또 다른 고유한 피쳐는 카드 대 카드 상호작용을 통한 디바이스 대 디바이스 통신이다. 종래의 정적 카드는 다른 정적 카드와 통신할 수 없다. 디바이스간 통신의 통상적으로 사용자 애플리케이션 등의 외부 수단을 통해 달성된다. 카드 대 카드 상호작용을 통해 사용자는 다른 디바이스 또는 사용자와 통신하기 위해 써드 파티 애플리케이션을 다운로드할 필요가 없다. 예를 들어, 사용자는 일반적으로 화상 회의에 참여하기 위 해 써드 파티 애플리케이션을 다운로드(예컨대, Zoom 또는 Microsoft Team 다운로드)해야 한다. 한편, 스마트 카드는 비디오 및 오디오 피드의 디스플레이를 단순히 렌더링하여 화상 회의를 용이하게 하므로 임의의 써드 파 티 애플리케이션이 필요하지 않다. 또한, 써드 파티 애플리케이션은 모바일 폰, 컴퓨터, 태블릿, 랩탑, 또는 텔레비젼 등의 모든 비디오 스크린 디바이스와 보편적으로 호환되지 않는다. 한편, 스마트 카드는 디스플레이 포맷과 파라미터를 각각의 상이한 타입의 물리적 디스플레이 스크린 및 관련 시스템에 맞게 동적으로 맞춤화할 수 있다. 도 16a는 스마트 카드가 카드 대 카드 상호작용에서 렌더링되는 사용자 디바이스의 디스플레이 스크린에 맞도록 각각의 스마트 카드가 어떻게 맞춤화될 수 있는지를 도시한다. 도 16a에서, 사용자 A의 스마트 카드(1604A)는 화상 회의를 디스플레이하는 것 등에 의해 사용자 B의 스마트 카드(1608A)와 상호작용할 수 있다. 각각의 스마 트 카드(1604A, 1608A)는 자신의 스마트 카드 로직 엔진을 갖는다. 위에서 논의된 바와 같이, 스마트 카 드 로직 엔진은 스마트 카드에 AI 서비스를 구현하는 역할을 한다. 사용자 A 및 B의 스마트 카드(1604A, 1608A)에서의 개별 스마트 카드 로직 엔진은 스마트 카드를 디스플레이하는데 사용된 비디오 스크린 디바 이스를 각각 식별할 수 있다. 사용자 A의 경우에, 스마트 카드 로직 엔진은 비디오 스크린 디바이스를 모바일 폰으로 식별하고 폰 스크린에 맞추기 위해 스마트 카드(1604A)를 맞춤화할 수 있다. 사용자 B의 경우에, 스마트 카드 로직 엔진은 비디오 스크린 디바이스를 컴퓨터로 식별하고 컴퓨터 스크린에 맞추기 위해 스마트 카드(1608A)를 맞춤화할 수 있다.도 16b는 사용자 A 및 B에 대한 예시적 스마트 카드를 도시한다. 사용자 A의 스마트 카드는 폰 스크린에 맞춤 화되고, 사용자 B의 스마트 카드는 컴퓨터 스크린에 맞춤화된다. 맞춤화는 다른 스크린 사이즈에 맞게 스크린 을 자르는 것 이상으로 확장된다. 2개의 스마트 카드(1604B, 1608B)의 비교는 비디오 디스플레이 윈도우가 전 체적으로 상이할 수 있다는(인물 대 풍경) 것을 나타낸다. 텍스트 기반 윈도우 등의 추가 디스플레이 엘리먼트 가 포함될 수도 있다. 도 16a 및 16b는 비디오 디스플레이를 사용하는 하나의 예시적 카드 대 카드 상호작용을 도시한다. 스마트 카 드를 사용하여 임의의 타입의 카드 대 카드 상호작용이 달성될 수 있음이 고려된다. 예를 들어, 사용자 A와 B 는 스마트 카드에 체스 게임 디스플레이 엘리먼트를 요청하여 턴 기반 체스 게임에 참여하거나 선택한 주식 가 격을 나란히 검토하여 거래를 비교하거나 스마트 카드를 통해 요리 레시피를 교환할 수 있다. 스마트 카드 경험은 각각의 고유한 사용자에 대해 추가로 맞춤화될 수 있다는 것이 또한 고려된다. 예를 들어, 사용자 A의 스마트 카드에서의 화상 회의는 풀 스크린일 수 있으며, 이는 화상 회의 및 텍스트 추적 채팅 이 스마트 카드의 유일한 엘리먼트일 수 있음을 의미한다. 한편, 사용자 B의 스마트 카드에 있는 화상 회의 및 채팅 박스는 단일 스마트 카드에 있는 많은 다른 엘리먼트 중 두 개일 수 있다. 도 17은 2개보다 많은 스마트 카드에 걸친 카드 대 카드 상호작용을 도시한다. 도 16a에서 논의된 동일 방법을 사용하여, 스마트 카드 로직 엔진은, 모바일 폰, 컴퓨터, 및 태블릿을 포함하지만, 이것에 한정되지 않는 임의 의 사용자 디바이스에 이 디바이스들에서의 스마트 카드가 서로 상호작용하는 동안 동일 카드의 디스플레이를 맞춤화할 수 있다. 멀티 카드 상호작용에서, 모든 카드의 안정성과 동기화를 보장하기 위해 하나의 스마트 카드가 호스트로 선택될 수 있다. 도 18은 호스트 역할을 할 스마트 카드를 결정하기 위한 선택 프레임워크(election framework)를 도 시한다. 도 18에서, 제1 스마트 카드, 제2 스마트 카드, 및 제3 스마트 카드는 라운드 로빈 방식(round robin fashion)으로 서로 통신하여 어떤 카드가 호스트 역할을 하기에 가장 안정적인지 휴리스틱 투 표 프로세스(heuristic voting process)를 통해 결정한다. 호스트는 사용자 디바이스의 안정성(이용 가능한 전 력, 복잡한 AI 서비스 요청을 프로세싱할 능력 등)과 해당 네트워크 연결의 안정성(신호 강도, 대역폭 등), 또 는 디바이스를 호스트로 적합하게 만들 수 있는 임의의 다른 팩터에 기초하여 선택된다. 이 선택 프레임워크는 디바이스 수에 관계없이 2개보다 많은 스마트 카드에서 확장될(scaled) 수 있다. Raft 합의 알고리즘을 실행하 여 안정성이 결정된다. 다른 실시형태에서, 백엔드 서버가 호스트로서 사용될 수 있다. 도 19는 이 대안적인 멀티 카드 통신 프레임워 크를 도시한다. 도 19에서, 제1 스마트 카드, 제2 스마트 카드, 및 제3 스마트 카드는 백엔 드 서버를 통해 서로 통신한다. 백엔드 서버는 다양한 원격 스마트 카드, 사용자 애플리케이션, 또는 서버 사이에서 메시지를 라우팅할 수 있는 원격 서버 운영 소프트웨어일 수 있다. 따라서, 백엔드 서버 는 호스트로서 서버가 될 수 있다. 도 20은 모바일일 수도 있고 아닐 수도 있는 사용자 디바이스라고도 하는 모바일 디바이스의 예시적 실시 형태를 도시한다. 이것은 하나의 가능한 모바일 디바이스 구성에 불과하며, 따라서 통상의 기술자는 모바일 디 바이스를 다르게 구성할 수 있다고 생각된다. 모바일 디바이스는 아래에 설명된 바와 같이 수행할 수 있 는 임의의 타입의 모바일 통신 디바이스를 포함할 수 있다. 모바일 디바이스는 PDA, 휴대폰, 스마트폰, 태블릿 PC, 무선 전자 패드, IoT 디바이스, \"웨어러블\" 전자 디바이스, 또는 임의의 다른 컴퓨팅 디바이스를 포함할 수 있다. 본 예시적 실시형태에서, 모바일 디바이스는 후술하는 컴포넌트를 보호하고 포함하도록 구성된 외부 하우 징을 가지고 구성된다. 하우징 내에 프로세서 및 제1 및 제2 버스(2012A, 2012B)(집합적으 로 2012)가 있다. 프로세서는 버스를 통해 모바일 디바이스의 다른 컴포넌트와 통신한다. 프로세서는 아래에 설명된 바와 같이 수행할 수 있는 임의의 타입의 프로세서 또는 컨트롤러를 포함할 수 있다. 프로세서는 범용 프로세서, ASIC, ARM, DSP, 컨트롤러, 또는 임의의 다른 타입의 프로세싱 디바이 스를 포함할 수 있다. 프로세서 및 모바일 디바이스의 다른 엘리먼트는 배터리 또는 다른 전력 소스로부터의 전력을 수신한다. 전기 인터페이스는 제2 전자 디바이스, 컴퓨터, 의료 디바이스, 또 는 전력 공급부/충전 디바이스 등의 모바일 디바이스와 전기적으로 인터페이싱하기 위한 하나 이상의 전기적 포 트(electrical port)를 제공한다. 인터페이스는 임의의 타입의 전기적 인터페이스 또는 커넥터 포맷을 포함할 수 있다.하나 이상의 메모리는 이미지 데이터, 오디오 데이터, 사용자 데이터, 위치 데이터, 가속도계 데이터, 또 는 임의의 다른 타입의 데이터 등의 데이터의 저장을 위한 그리고 프로세서 상에서의 실행을 위한 머신 판독 가능 코드의 저장을 위한 모바일 디바이스의 일부이다. 메모리는 RAM, ROM, 플래시 메모리, 광학 메모리, 또는 마이크로 드라이브 메모리를 포함할 수 있다. 여기에서 설명된 머신 판독 가능 코드(소프트 웨어 모듈 및/또는 루틴)는 비일시적(non-transitory)이다. 본 실시형태의 일부로서, 프로세서는 사용자 인터페이스에 연결된다. 사용자 인터페이스는 모바일 디바이스를 제어하기 위한 사용자 입력을 수락하도록 구성된 임의의 시스템 또는 디바이스를 포함할 수 있다. 사용자 인터페이스는 마이크로폰, 키보드, 롤러 볼(roller ball), 버튼, 휠, 포인터 키, 터치 패 드, 및 터치 스크린 중 하나 이상을 포함할 수 있다. 또한, 터치 스크린 컨트롤러가 제공되어 버스 를 통해 인터페이싱하고 디스플레이에 연결된다. 디스플레이는 사용자에게 시각 정보를 디스플레이하도록 구성된 임의의 타입의 디스플레이 스크린을 포함한다. 스크린은, LED, LCD, 박막 트랜지스터 스크린(thin film transistor screen), OEL CSTN(color super twisted nematic), TFT(thin film transistor), TFD(thin film diode), OLED(organic light-emitting diode), AMOLED(active-matrix organic light-emitting diode) 디스플레이, 용량성 터치 스크린(capacitive touch screen), 저항성 터치 스크린(resistive touch screen), 또는 이 기술들의 임의의 조합을 포함할 수 있다. 디 스플레이는 프로세서로부터 신호를 수신하고, 이 신호는 해당 기술 분야에서 이해되는 바와 같이 텍스트 및 이미지로 디스플레이에 의해 변환된다. 디스플레이는 디스플레이 프로세서(미도시) 또는 프로 세서와 인터페이싱하는 컨트롤러를 더 포함할 수 있다. 터치 스크린 컨트롤러는 디스플레이 상에 오버레이되는(overlaid) 터치 스크린으로부터 신호를 수신하도록 구성된 모듈을 포함할 수 있다. 또한, 이러한 예시적 모바일 디바이스의 일부는 스피커 및 마이크로폰이다. 스피커 및 마이 크로폰은 프로세서에 의해 제어될 수 있다. 마이크로폰은 프로세서 제어에 기초하여 오디오 신호를 수신하여 전기 신호로 변환하도록 구성된다. 마찬가지로, 프로세서는 오디오 신호를 생성 하기 위해 스피커를 활성화할(activate) 수 있다. 이들 디바이스는 당업계에서 이해되는 바와 같이 동작 하며, 이에 대해서는 여기서 상세히 설명하지 않는다. 또한, 개별 안테나(2048, 2052)에 각각 연결된 제1 무선 트랜스시버 및 제2 무선 트랜스시버가 버스 들 중 하나 이상에 연결된다. 제1 및 제2 트랜스시버(2040, 2044)는 원격 송신기로부터 인커밍 신호를 수신하도록 그리고 아날로그 기저대역 신호를 생성하기 위해 신호에 아날로그 프론트엔드 프로세싱을 수행하도 록 구성된다. 인커밍 신호는 프로세서에 의한 후속 프로세싱을 위해 아날로그 대 디지털 컨버터와 같은 디지털 포맷으로의 변환에 의해 추가로 프로세싱될 수 있다. 마찬가지로, 제1 및 제2 트랜스시버(2040, 2044) 는 프로세서 또는 모바일 디바이스의 다른 컴포넌트로부터 아웃고잉 신호를 수신하고 이 신호를 개 별 안테나(2048, 2052)를 통한 송신을 위해 기저대역으로부터 RF 주파수로 상향 변화(up convert)하도록 구성된 다. 제1 무선 트랜스시버 및 제2 무선 트랜스시버로 도시되어 있지만, 모바일 디바이스는 오직 하나의 시스템 또는 2개 이상의 트랜스시버를 가질 수 있는 것이 고려된다. 예컨대, 일부 디바이스는 트 라이 밴드(tri-band) 또는 쿼드 밴드(quad-band)를 지원하거나 Bluetooth®, NFC, 또는 기타 통신 기능을 갖는 다. 모바일 디바이스 이에 따라 제1 무선 트랜스시버 및 제2 무선 트랜스시버는, 블루투스, IEEE 802.11 a,b,g,n과 같은 WI-FI, 무선 LAN, WMAN, 광대역 고정 액세스(broadband fixed access), WiMAX, CDMA, GSM, EDGE, 3G, 4G, 5G, TDMA, AMPS, FRS, GMRS, 시티즌 밴드 라디오(citizen band radio), VHF, AM, FM, 및 무선 USB를 포함하는 임의의 셀룰러 기술을 포함하지만, 이것에 한정되지 않는 현재 존재하거나 향후 개발될 무 선 표준에 따라 동작하도록 구성될 수 있음이 고려된다. 또한, 모바일 디바이스의 일부는 또한 프로세서와 인터페이싱하는 제2 버스(2012B)에 연결된 하나 이상의 시스템이다. 이 디바이스는 연관된 안테나를 가진 GPS(global positioning system) 모듈을 포함 한다. GPS 모듈은 GPS 모듈의 위치, 이동 방향, 및 속도에 관한 위치 데이터를 생성하기 위해 위 성 또는 다른 트랜스폰더(transponder)로부터 신호를 수신하고 프로세싱할 수 있다. GPS는 일반적으로 해당 기 술 분야에서 이해되고 있으므로 여기에서 자세히 설명하지 않는다. 자이로스코프는 모바일 디바이스 의 배향에 관한 배향 데이터를 생성하고 제공하기 위해 버스(2012B)에 연결된다. 모바일 디바이스(200 4)에 방향 정보를 제공하기 위해 자력계가 제공된다. 가속도계는 버스(2012B)에 연결되어 모바일 디바이스가 겪는 충격 또는 힘에 관한 정보 또는 데이터를 제공한다. 일 구성에서, 가속도계 및 자이로스코프는 데이터를 생성하여 프로세서에 제공하여 모바일 디바이스의 이동 경로 및 배향을 표시한 다. 메모리에 저장하기 위해 및/또는 무선 또는 유선 링크를 통한 가능한 송신을 위해 또는 나중에 보기 위해, 이미지 데이터를 캡처하기 위한 하나 이상의 카메라(스틸, 비디오 또는 둘 모두)가 제공된다. 하 나 이상의 카메라는 가시광 및/또는 근적외선을 사용하여 이미지를 검출하도록 구성될 수 있다. 카메라 는 또한 어두운 환경에서 이미지를 얻기 위해 이미지 강화, 능동 조명, 또는 열화상을 활용하도록 구성될 수 있다. 프로세서는 여기에서 설명된 기능을 수행하기 위해 메모리에 저장된 머신 판독 가능 코드를 프 로세싱할 수 있다. LED 라이트와 같은 플래셔(flasher) 및/또는 플래시라이트(flashlight)가 제공되고 프로세서 제어 가능하 다. 플래셔 또는 플래시라이트는 스트로브 또는 종래의 플래시라이트로서 기능할 수 있다. 플래셔 또는 플래시라이트는 또한, 근적외선을 방출하도록 구성될 수 있다. 전력 관리 모듈은 전력 소비를 관 리하기 위해 배터리와 인터페이싱하거나 배터리를 모니터링하고, 배터리 충전을 제어하고, 상이한 전력 요구를 요청할 수 있는 다수의 디바이스에 공급 전압을 제공한다. 도 21은 예시적 일 실시형태에 따라, 위에서 설명한 디바이스 중 하나와 같은 컴퓨팅 또는 모바일 디바이스 또 는 서버의 개략도이다. 컴퓨팅 디바이스는 스마트폰, 태블릿, 키오스크, 랩탑, 데스크탑, 워크스테이션, 퍼스널 디지털 어시스턴트, 서버, 블레이드 서버(blade server), 메인프레임, 및 다른 적합한 컴퓨터와 같은 다 양한 형태의 디지털 컴퓨터를 나타내기 위한 것이다. 컴퓨팅 디바이스는 퍼스널 디지털 어시스턴트, 휴대 폰, 스마트폰, 및 다른 유사한 컴퓨팅 디바이스 등의 다양한 형태의 모바일 디바이스를 나타내기 위한 것이다. 여기에 표시된 컴포넌트, 연결과 관계, 및 기능은 예시일 뿐이며 본 명세서에서 설명 및/또는 청구된 구현예를 제한하지 않는다. 컴퓨팅 디바이스는 프로세서, 메모리, 스토리지 디바이스, 메모리와 고속 확장 포트에 연결된 고속 인터페이스 또는 컨트롤러, 및 저속 버스와 스토리지 디바이스에 연결된 저속 인터페이스 또는 컨트롤러를 포함한다. 각각의 컴포넌트(2102, 2104, 2106, 2108, 2110, 및 2112)는 다수의 버스를 사용하여 상호연결되고, 공통 마더보드 상에 또는 적합한 다른 방식으로 장착될 수 있다. 프로세서는, 고속 컨트롤러에 커플링된 디스플레이와 같은 외부 입력/출력 디바이스 상의 GUI를 위한 그래픽 정보를 디스플레이하기 위해 메모리 내에 또는 스토리지 디바이스 상에 저 장된 명령어를 포함하는, 컴퓨팅 디바이스 내에서의 실행을 위한 명령어를 프로세싱할 수 있다. 다른 구 현예에서, 다수의 프로세서들 및/또는 다수의 버스들이 다수의 메모리들 및 다수의 타입의 메모리와 함께 적합 하게 사용될 수 있다. 또한, 다수의 컴퓨팅 디바이스들이 (예컨대, 서버 뱅크, 블레이드 서버의 그룹, 또 는 다중 프로세서 시스템으로서) 필수 동작들의 일부를 제공하는 각각의 디바이스와 연결될 수 있다. 메모리는 컴퓨팅 디바이스 내에 정보를 저장한다. 일 구현예에서, 메모리는 휘발성 메모리 유닛 또는 유닛들이다. 다른 구현예에서, 메모리는 비휘발성 메모리 유닛 또는 유닛들이다. 메모리(210 4)는 또한, 자기 또는 광학 디스크와 같은 다른 형태의 컴퓨터 판독 가능 매체일 수 있다. 스토리지 디바이스는 컴퓨팅 디바이스를 위한 대용량 스토리지(mass storage)를 제공할 수 있다. 일 구현예에서, 스토리지 디바이스는 하드 디스크 디바이스, 광학 디스크 디바이스, 또는 테이프 디바이 스, 플래시 메모리 또는 다른 유사한 고체 상태 메모리 디바이스, 또는 스토리지 영역 네트워크 내의 디바이스 들 또는 다른 구성들을 포함하는 디바이스들의 어레이와 같은 컴퓨터 판독 가능 매체이거나 이들을 포함할 수 있다. 컴퓨터 프로그램 제품은 정보 캐리어(information carrier)에 가시적으로(tangibly) 구현될 수 있다. 컴 퓨터 프로그램 제품은 또한, 실행될 때 여기에 설명된 바와 같은 하나 이상의 방법을 수행하는 명령어들을 포함 할 수 있다. 정보 캐리어는 메모리, 스토리지 디바이스, 또는 프로세서 상의 메모리와 같은 컴퓨터 또는 머신 판독 가능 매체이다. 고속 컨트롤러는 컴퓨팅 디바이스에 대한 대역폭 집중 동작(bandwidth-intensive operation)을 관 리하는 반면, 저속 컨트롤러는 낮은 대역폭 집중 동작을 관리한다. 이러한 기능의 할당은 단지 예시이다. 일 구현예에서, 고속 컨트롤러는 메모리, 디스플레이(예컨대, 그래픽 프로세서 또는 가속기 를 통해), 및 다수 확장 카드(미도시)를 받을 수 있는 고속 확장 포트에 커플링된다. 구현예에서, 저속 컨트롤러는 스토리지 디바이스 및 저속 버스에 커플링된다. 다수의 통신 포트(예컨대, USB, 블루투스, 이더넷 무선 이더넷)를 포함할 수 있는 저속 버스는 키보드, 포인팅 디바이스, 스캐너, 또는 스위치 또는 라우터 등의 네트워킹 디바이스(예컨대, 네트워크 어뎁터를 통함)에 커플링될 수 있다.컴퓨팅 디바이스는 도면에 도시된 바와 같이 여러 가지 다른 형태로 구현될 수 있다. 예를 들어, 표준 서 버로 구현되거나 이러한 서버 그룹에서 여러 번 구현될 수 있다. 랙 서버 시스템의 일부로 구현될 수도 있다. 또한, 랩탑 컴퓨터와 같은 퍼스널 컴퓨터로 구현될 수 있다. 대안적으로, 컴퓨팅 디바이스 로부터의 컴포넌트는 디바이스와 같은 모바일 디바이스(미도시)의 다른 컴포넌트와 결합될 수 있다. 이러한 디바이스 각각은 컴퓨팅 디바이스(2100, 2150) 중 하나 이상을 포함할 수 있으며 전체 시스템은 서로 통신하는 여러 컴퓨팅 디바이스(2100, 2150)로 만들어질 수 있다. 컴퓨팅 디바이스는 다른 컴포넌트 중에서 프로세서, 메모리, 디스플레이와 같은 입력/ 출력 디바이스, 통신 인터페이스, 및 트랜스시버를 포함한다. 디바이스에는 추가 스토리지를 제공하기 위해 마이크로 드라이브 또는 기타 디바이스와 같은 스토리지 디바이스가 제공될 수도 있다. 각각의 컴포넌트(2150, 2152, 2164, 2154, 2166, 및 2168)는 다수의 버스를 사용하여 상호연결되고, 몇몇 컴포넌트가 공통 마더보드 상에 또는 적합한 다른 방식으로 장착될 수 있다. 프로세서는 메모리에 저장된 명령어들을 포함하는 컴퓨팅 디바이스 내의 명령어들을 실행할 수 있다. 프로세서는 개별 및 멀티플 아날로그 및 디지털 프로세서들을 포함하는 칩들의 칩셋으로서 구현될 수 있다. 프로세서는 예를 들어 사용자 인터페이스의 제어, 디바이스에 의해 실행되는 애플리케이션, 및 디 바이스에 의한 무선 통신과 같은 디바이스의 다른 컴포넌트의 조정(coordination)을 제공할 수 있 다. 프로세서는 디스플레이에 커플링된 디스플레이 인터페이스 및 제어 인터페이스를 통해 사용자와 통신할 수 있다. 디스플레이는 예컨대, TFT LCD(Thin-Film-Transistor Liquid Crystal Display) 또는 OLED(Organic Light Emitting Diode) 디스플레이, 또는 다른 적합한 디스플레이 기술일 수 있다. 디스플레이 인터페이스는 그래픽 및 다른 정보를 사용자에게 제시하기 위해 디스플레이를 구 동하기 위한 적합한 회로를 포함할 수 있다. 제어 인터페이스는 사용자로부터 명령을 수신하고 프로세서 에 제출하기 위해 명령을 변환할 수 있다. 또한, 프로세서와 통신하는 외부 인터페이스가 제 공되어 다른 디바이스와 디바이스의 근거리 통신을 가능하게 할 수 있다. 외부 인터페이스는 예를 들어, 일부 구현예에서는 유선 통신을 위해, 또는 다른 구현예에서는 무선 통신을 위해 제공될 수 있으며, 다중 인터페이스가 또한 사용될 수 있다. 메모리는 컴퓨팅 디바이스 내에 정보를 저장한다. 컴퓨터 판독 가능 매체 또는 매체들, 휘발성 메 모리 유닛 또는 유닛들, 또는 비휘발성 메모리 유닛 또는 유닛들 중 하나 이상으로서 메모리가 구현될 수 있다. 예컨대 SIMM(Single In Line Memory Module) 카드 인터페이스를 포함할 수 있는 확장 인터페이스(217 2)를 통해 디바이스에 확장 메모리92174)가 제공되고 연결될 수도 있다. 이러한 확장 메모리는 디 바이스를 위한 추가 스토리지 공간을 제공하거나 디바이스를 위한 애플리케이션 또는 기타 정보를 저장할 수도 있다. 구체적으로, 확장 메모리는 위에서 설명한 프로세스를 수행하거나 보완하기 위한 명 령어를 포함할 수 있으며 보안 정보도 포함할 수 있다. 따라서, 예를 들어, 확장 메모리는 디바이스 를 위한 보안 모듈로서 제공될 수 있고 디바이스의 안전한 사용을 허용하는 명령어로 프로그래밍될 수 있다. 또한, 보안 애플리케이션은 SIMM 카드를 통해 해킹 불가능한 방식으로 SIMM 카드에 식별 정보를 배치 하는 것과 같은 추가 정보와 함께 제공될 수 있다. 메모리는 예컨대 후술하는 바와 같은 플래시 메모리 및/또는 NVRAM 메모리를 포함할 수 있다. 일 구현예에서, 컴퓨터 프로그램 제품은 정보 캐리어에 가시적으로(tangibly) 구현된다. 컴퓨터 프로그램 제품은 실행될 때 여 기에 설명된 바와 같은 하나 이상의 방법을 수행하는 명령어들을 포함한다. 정보 캐리어는, 예컨대 트랜스시버 또는 외부 인터페이스를 통해 수신될 수 있는 메모리, 확장 메모리, 또는 프로세서 상의 메모리와 같은 컴퓨터 또는 머신 판독 가능 매체이다. 디바이스는 필요한 경우 디지털 신호 프로세싱 회로를 포함할 수 있는 통신 인터페이스를 통해 무 선으로 통신할 수 있다. 통신 인터페이스는 특히 GSM 음성 통화, SMS, EMS 또는 MMS 메시징, CDMA, TDMA, PDC, WCDMA, CDMA2000, 또는 GPRS와 같은 다양한 모드 또는 프로토콜 하에서 통신을 제공할 수 있다. 이러한 통신은 예컨대 무선 주파수 트랜스시버를 통해 발생할 수 있다. 또한, 블루투스, Wi-Fi 또는 기 타 트랜스시버(미도시)를 사용하는 것과 같은 근거리 통신(short-range communication)이 발생할 수 있다. 또 한, GPS(Global Positioning System) 수신기 모듈은 디바이스에서 실행되는 애플리케이션에 의해 적절하게 사용될 수 있는 추가적인 내비게이션 및 위치 관련 무선 데이터를 디바이스에 제공할 수 있다. 디바이스는 또한 사용자로부터 음성 정보를 수신하고 이를 사용 가능한 디지털 정보로 변환할 수 있는 오 디오 코덱을 사용하여 음성으로 통신할 수 있다. 마찬가지로 오디오 코덱은 예를 들어 스피커를 통해(예를 들어, 디바이스의 핸드셋에서) 사용자를 위한 가청 사운드를 생성할 수 있다. 이러한 사운드 는 음성 전화 통화로부터의 사운드를 포함할 수 있고, 녹음된 사운드(예를 들어, 음성 메시지, 음악 파일 등)를 포함할 수 있고, 또한 디바이스에서 동작하는 애플리케이션에 의해 생성된 사운드를 포함할 수 있다. 컴퓨팅 디바이스는 도면에 도시된 바와 같이 다수의 상이한 형태로 구현될 수 있다. 예를 들어, 휴대폰 으로 구현될 수 있다. 또한 스마트폰, 퍼스널 디지털 어시스턴트, 컴퓨터 태블릿, 또는 기타 유사 한 모바일 디바이스의 일부로 구현될 수 있다. 따라서, 여기에 설명된 시스템 및 기술의 다양한 구현예는 디지털 전자 회로, 집적 회로, 특히 디자인된 ASIC(application specific integrated circuit), 컴퓨터 하드웨어, 펌웨어, 소프트웨어 및/또는 이들의 조합 으로 실현될 수 있다. 이러한 다양한 구현예는 스토리지 시스템, 적어도 하나의 입력 디바이스, 및 적어도 하 나의 출력 디바이스로부터 또는 데이터 및 명령어를 수신하고 스토리지 시스템, 적어도 하나의 입력 디바이스, 및 적어도 하나의 출력 디바이스에 데이터를 송신하도록 커플링된 특수 또는 범용일 수 있는 적어도 하나의 프 로그래밍 가능한 프로세서를 포함하는 프로그래밍 가능한 시스템에서 실행 가능 및/또는 해석 가능한 하나 이상 의 컴퓨터 프로그램에서의 구현을 포함할 수 있다. 이러한 컴퓨터 프로그램(프로그램, 소프트웨어, 소프트웨어 애플리케이션 또는 코드라고도 함)은 프로그래밍 가 능한 프로세서용 머신 명령어를 포함하며 고급 절차 및/또는 객체 지향 프로그래밍 언어 및/또는 어셈블리/머신 랭귀지로 구현될 수 있다. 여기에서 사용되는 바와 같이, \"머신 판독 가능 매체\" 및 \"컴퓨터 판독 가능 매체\" 라는 용어는 머신 판독 가능 신호로서 머신 명령어를 수신하는 머신 판독 가능 매체를 포함하는 프로그램 가능 프로세서에 머신 명령어 및/또는 데이터를 제공하기 위해 사용되는 임의의 컴퓨터 프로그램 제품, 장치 및/또는 디바이스(예를 들어, 자기 디스크, 광학 디스크, 메모리, 프로그램 가능 로직 디바이스(PLD))를 지칭한다. \"머 신 판독 가능 신호\"라는 용어는 프로그램 가능한 프로세서에 머신 명령어 및/또는 데이터를 제공하는 데 사용되 는 임의의 신호를 의미한다. 사용자와의 상호 작용을 제공하기 위해, 여기에 설명된 시스템 및 기술은 사용자에게 정보를 디스플레이하기 위 한 디스플레이 디바이스[예를 들어, CRT(cathod ray tube) 또는 LCD(liquid crystal display) 모니터] 및 사용 자가 컴퓨터에 입력을 제공할 수 있는 키보드 및 포인팅 디바이스(예컨대, 마우스, 조이스틱, 트랙볼, 또는 유 사 디바이스)를 갖는 컴퓨터에서 구현될 수 있다. 예를 들어, 다른 종류의 디바이스를 사용하여 사용자와의 상 호 작용도 제공할 수 있고; 사용자에게 제공되는 피드백은 모든 형태의 감각 피드백(예컨대, 시각적 피드백, 청 각 피드백, 또는 촉각 피드백)일 수 있고; 사용자로부터의 입력은 음향, 음성, 또는 촉각 입력을 포함한 모든 형태로 수신될 수 있다. 여기에 설명된 시스템 및 기술은 백엔드 컴포넌트 (예컨대, 데이터 서버, 슬롯 어카운팅 시스템, 플레이어 추적 시스템 등)을 포함하거나, 미들웨어 컴포넌트(예컨대, 애플리케이션 서버)를 포함하거나, 프론트엔드 컴포넌트 (예컨대, 사용자가 여기에서 설명된 시스템 및 기술의 구현예와 상호 작용할 수 있는 웹 브라우저 또는 그래픽 사용자 인터페이스를 가진 사용자 애플리케이션 컴퓨터)를 포함하거나, 이러한 백엔드, 미들웨어, 또는 프론트 엔드 컴포넌트의 임의의 조합을 포함하는 컴퓨팅 시스템(예컨대, 컴퓨팅 디바이스(2100 및/또는 2150)으로 구현 될 수 있다. 시스템의 컴포넌트는 디지털 데이터 통신의 모든 형태 또는 매체(예컨대, 통신 네트워크)에 의해 상호 연결될 수 있다. 통신 네트워크의 실시예에는 LAN(Local Area Network), WAN(Wide Area Network) 및 인 터넷이 포함된다. 컴퓨팅 시스템은 사용자 애플리케이션 및 서버를 포함할 수 있다. 사용자 애플리케이션 및 서버는 일반적으로 서로 원격이고 통신 네트워크를 통해 통상적으로 상호작용한다. 사용자 애플리케이션과 서버의 관계는 각 컴퓨 터에서 실행되고 서로 사용자 애플리케이션-서버 관계를 갖는 컴퓨터 프로그램에 의해 발생한다. 본 발명의 다양한 실시형태가 설명되었지만, 본 발명의 범위 내에 있는 더 많은 실시형태 및 구현예 가능하다는 것이 당업자에게 명백할 것이다. 또한, 여기에 설명된 다양한 피쳐, 엘리먼트 및 실시형태는 임의의 조합 또는 배열로 청구되거나 결합될 수 있다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12 도면13 도면14 도면15 도면16a 도면16b 도면17 도면18 도면19 도면20 도면21"}
{"patent_id": "10-2022-7040718", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 정적 카드(static card)를 생성하기 위해 백엔드 서버와 상호작용하는 종래 기술의 사용자 애플리케이션 을 도시한다. 도 2는 사용자 디바이스 상에서 실행되는 사용자 애플리케이션에 대한 스마트 카드를 생성하기 위한 시스템의 예시적 실시형태를 도시한다. 도 3은, 동일 사용자 쿼리에 기초하여 4명의 상이한 사용자에게 디스플레이되는 예시적 스마트 카드를 도시한다.도 4는 스마트 카드를 생성하기 위한 예시적 프로세스를 도시한 동작 플로우 다이어그램이다. 도 5는 백엔드 렌더링 프레임워크(backend rendering framework)의 구조를 도시한다. 도 6은 사용자 애플리케이션 렌더링 프레임워크(user application rendering framework)의 구조를 도시한다. 도 7은 프리미티브 컨버젼 엔진(primitive conversion engine)을 도시한다. 도 8은 폴백 캔버스 프리미티브(fallback canvas primitive)를 도시한다. 도 9는 로직 주입 엔진(logic injection engine)이 동일한 사용자 요청에 기초하여 상이한 스마트 카드를 생성 할 수 있는 방법을 도시한다. 도 10은 로직 주입 엔진이 동일한 사용자 요청에 기초하여 상이한 사용자 프롬프트를 생성할 수 있는 방법을 도 시한다. 도 11은 렌더링 후 최적화(post-render optimization)를 달성할 수 있는 스마트 카드 최적화 시스템을 도시한다. 도 12는 라이브 데이터 업데이트가 있는 예시적 주식 시장 스마트 카드를 도시한다. 도 13은 스마트 카드와 백엔드 서버 사이의 통신 프레임워크를 도시한다. 도 14는 AI 백엔드 서버에 의해 사용자가 실시간 체스 게임을 플레이할 수 있는 예시적 체스 스마트 카드를 도 시한다. 도 15는 스마트 카드 템플릿이 스마트 카드 레지스트리에 업로드되고 탑 카드(top card)로 식별되는 방법을 도 시한다. 도 16a는 스마트 카드가 카드 대 카드 상호작용에서 렌더링되는 사용자 디바이스의 디스플레이 스크린에 맞도록 각각의 스마트 카드가 어떻게 맞춤화될(customized) 수 있는지를 도시한다. 도 16b는 상이한 사용자 디바이스에 대하여 맞춤화되는 예시적 스마트 카드를 도시한다. 도 17은 2개보다 많은 스마트 카드에 걸친 카드 대 카드 상호작용을 도시한다. 도 18은 호스트 역할을 할 스마트 카드를 결정하기 위한 선택 프레임워크(election framework)를 도시한다. 도 19는 백엔드 서버를 호스트로 사용하는 대안적인 멀티 카드 통신 프레임워크를 도시한다. 도 20은 여기에 설명된 스마트 카드 시스템의 예시적인 사용 환경을 도시한다. 도 21은 모바일일 수도 있고 아닐 수도 있는 사용자 디바이스라고도 하는 모바일 디바이스의 예시적 실시형태를 도시한다."}
