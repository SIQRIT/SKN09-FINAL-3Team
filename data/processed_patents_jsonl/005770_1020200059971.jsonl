{"patent_id": "10-2020-0059971", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0143048", "출원번호": "10-2020-0059971", "발명의 명칭": "상이한 엔디언 포맷에 따른 데이터 변환을 위한 인터페이스 회로를 갖는 메모리 장치", "출원인": "삼성전자주식회사", "발명자": "오성일"}}
{"patent_id": "10-2020-0059971", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "메모리 장치에 있어서,메모리 뱅크;상기 메모리 뱅크와 결합하고, 연산 처리를 수행하는 프로세싱 소자;상기 메모리 장치 외부의 호스트 장치로부터 수신되는 직렬 데이터 스트림을 병렬화 하는 동작을 수행하도록,그리고 상기 메모리 뱅크 또는 상기 프로세싱 소자에서 출력되는 병렬 데이터 스트림을 직렬화 하는 동작을 수행하도록 구성되는 직렬화기/역직렬화기(SERDES)를 포함하는 SERDES 영역; 및상기 메모리 뱅크, 상기 프로세싱 소자 및 상기 SERDES와 관련된 데이터 전달 경로를 포함하고, 상기 메모리 장치로 하여금 상기 호스트 장치의 엔디언 포맷을 고려하여 설정되는 제어 신호에 기초하여 상기 데이터 전달 경로에서 데이터 변환을 수행할 수 있게 하는 인터페이스 회로를 포함하는 메모리 장치."}
{"patent_id": "10-2020-0059971", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 인터페이스 회로는,제1 바이트를 수신하는 제1 입력 데이터 버스;제2 바이트를 수신하는 제2 입력 데이터 버스;상기 제어 신호를 수신하는 제어 신호 라인;제1 출력 데이터 버스;제2 출력 데이터 버스; 및상기 제1 및 상기 제2 입력 데이터 버스들, 상기 제어 신호 라인 그리고 상기 제1 및 상기 제2 출력 데이터 버스들에 연결되는 데이터 버스 변환부를 포함하고,상기 데이터 버스 변환부는, 상기 제어 신호의 제1 로직 상태에 응답하여 상기 제1 입력 데이터 버스의 상기 제1 바이트를 상기 제1 출력 데이터 버스로 패스하고 상기 제2 입력 데이터 버스의 상기 제2 바이트를 상기 제2출력 데이터 버스로 패스하고, 상기 제어 신호의 상기 제1 로직 상태의 반대인 제2 로직 상태에 응답하여 상기제1 입력 데이터 버스의 상기 제1 바이트를 상기 제2 출력 데이터 버스로 변경하여 전달하고 상기 제2 입력 데이터 버스의 상기 제2 바이트를 상기 제1 출력 데이터 버스로 변경하여 전달하는 것을 특징으로 하는 메모리 장치."}
{"patent_id": "10-2020-0059971", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 메모리 장치는,상기 호스트 장치와 통신하는 메모리 물리 계층 인터페이스(PHY) 영역을 더 포함하고,상기 인터페이스 회로는 상기 메모리 PHY 영역과 상기 SERDES 영역 사이에 배치되고,상기 인터페이스 회로는,상기 호스트 장치에서 상기 메모리 장치로 데이터가 입력될 때, 상기 제1 및 상기 제2 입력 데이터 버스는 상기메모리 PHY 영역과 결합하고, 상기 제1 및 상기 제2 출력 데이터 버스는 상기 SERDES 영역과 결합하도록 구성되고,상기 메모리 장치에서 상기 호스트 장치로 데이터가 출력될 때, 상기 제1 및 상기 제2 입력 데이터 버스는 상기SERDES 영역과 결합하고, 상기 제1 및 상기 제2 출력 데이터 버스는 상기 메모리 PHY 영역과 결합하도록 구성되는 것을 특징으로 하는 메모리 장치.공개특허 10-2021-0143048-3-청구항 4 제2항에 있어서,상기 인터페이스 회로는 상기 SERDES 영역과 상기 메모리 뱅크 또는 상기 프로세싱 소자 사이에 배치되고,상기 인터페이스 회로는,상기 호스트 장치에서 상기 메모리 장치로 데이터가 입력될 때, 상기 제1 및 상기 제2 입력 데이터 버스는 상기SERDES 영역과 결합하고, 상기 제1 및 상기 제2 출력 데이터 버스는 상기 메모리 뱅크 또는 상기 프로세싱 소자와 결합하도록 구성되고, 상기 메모리 장치에서 상기 호스트 장치로 데이터가 출력될 때, 상기 제1 및 상기 제2 입력 데이터 버스는 상기 메모리 뱅크 또는 상기 프로세싱 소자와 결합하고, 상기 제1 및 상기 제2 출력 데이터 버스는 상기 SERDES영역과 결합하도록 구성되는 것을 특징으로 하는 메모리 장치."}
{"patent_id": "10-2020-0059971", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서, 상기 메모리 장치는,상기 메모리 뱅크를 다수개 포함하는 뱅크 그룹;상기 뱅크 그룹에 결합되어, 상기 메모리 장치 외부의 호스트 장치와 상기 뱅크 그룹 사이에서 데이터를 전송하는 뱅크 그룹 입출력 라인;제1 메모리 뱅크에 결합되어, 제1 메모리 뱅크로 제공되는 데이터 및 상기 제1 메모리 뱅크로부터 독출되는 데이터를 전달하는 제1 뱅크 로컬 입출력 라인; 및제2 메모리 뱅크에 결합되어, 제2 메모리 뱅크로 제공되는 데이터 및 상기 제2 메모리 뱅크로부터 독출되는 데이터를 전달하는 제2 뱅크 로컬 입출력 라인을 더 포함하는 것을 특징으로 하는 메모리 장치."}
{"patent_id": "10-2020-0059971", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 프로세싱 소자는 상기 제1 및 상기 제2 메모리 뱅크들에 공유되고,상기 인터페이스 회로는 상기 SERDES 영역과 상기 뱅크 그룹 입출력 라인 사이에 배치되고,상기 인터페이스 회로는,상기 호스트 장치에서 상기 메모리 장치로 데이터가 입력될 때, 상기 제1 및 상기 제2 입력 데이터 버스는 상기SERDES 영역과 결합하고, 상기 제1 및 상기 제2 출력 데이터 버스는 상기 뱅크 그룹 입출력 라인과 결합하도록구성되고, 상기 메모리 장치에서 상기 호스트 장치로 데이터가 출력될 때, 상기 제1 및 상기 제2 입력 데이터 버스는 상기 뱅크 그룹 입출력 라인과 결합하고, 상기 제1 및 상기 제2 출력 데이터 버스는 상기 SERDES 영역과 결합하도록 구성되는 것을 특징으로 하는 메모리 장치."}
{"patent_id": "10-2020-0059971", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제5항에 있어서, 상기 메모리 장치는,상기 제1 메모리 뱅크에 결합되는 제1 프로세싱 소자; 및상기 제2 메모리 뱅크에 결합되는 제2 프로세싱 소자를 더 포함하고,상기 인터페이스 회로는 상기 제1 및 상기 제2 프로세싱 소자들과 상기 제1 및 상기 제2 뱅크 로컬 입출력 라인들 사이에 각각 배치되고,상기 인터페이스 회로 각각은,상기 호스트 장치에서 상기 메모리 장치로 데이터가 입력될 때, 상기 제1 및 상기 제2 입력 데이터 버스는 상기제1 및 상기 제2 프로세싱 소자들 각각과 결합하고, 상기 제1 및 상기 제2 출력 데이터 버스는 상기 제1 및 상공개특허 10-2021-0143048-4-기 제2 뱅크 로컬 입출력 라인들과 결합하도록 구성되고, 상기 메모리 장치에서 상기 호스트 장치로 데이터가 출력될 때, 상기 제1 및 상기 제2 입력 데이터 버스는 상기 제1 및 상기 제2 뱅크 로컬 입출력 라인들 각각과 결합하고, 상기 제1 및 상기 제2 출력 데이터 버스는 상기제1 및 상기 제2 프로세싱 소자들 각각과 결합하도록 구성되는 것을 특징으로 하는 메모리 장치."}
{"patent_id": "10-2020-0059971", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 제어 신호는 상기 메모리 장치의 모드 레지스터 셋트(MRS)에서 제공되거나 또는 상기 메모리 장치 내부의비휘발성 메모리 소자의 특정 상태에 따라 제공되는 것을 특징으로 하는 메모리 장치."}
{"patent_id": "10-2020-0059971", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "메모리 장치에 있어서,메모리 뱅크;상기 메모리 장치 외부의 호스트 장치로부터 수신되는 직렬 데이터 스트림을 병렬화 하는 동작을 수행하도록,그리고 상기 메모리 뱅크에서 출력되는 병렬 데이터 스트림을 직렬화 하는 동작을 수행하도록 구성되는 직렬화기/역직렬화기(SERDES)를 포함하는 SERDES 영역; 및상기 메모리 뱅크 및 상기 SERDES와 관련된 데이터 전달 경로를 포함하고, 상기 SERDES 영역에 결합되어, 상기메모리 장치로 하여금 상기 호스트 장치의 엔디언 포맷을 고려하여 설정되는 제어 신호에 기초하여 상기 데이터전달 경로에서 데이터 변환을 수행할 수 있게 하는 인터페이스 회로를 포함하는 메모리 장치."}
{"patent_id": "10-2020-0059971", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "호스트 장치와 메모리 장치 사이의 엔디언 포맷을 조정하는 인터페이스 회로를 포함하는 메모리 장치의 동작 방법에 있어서,상기 호스트 장치로부터 제1 엔디언 포맷의 직렬 데이터 스트림을 수신하는 단계;상기 직렬 데이터 스트림을 제1 데이터로 병렬화 하는 단계; 및상기 인터페이스 회로에서, 제어 신호에 기초하여 상기 직렬 데이터 스트림을 상기 메모리 장치의 제2 엔디언포맷으로 변환하거나 또는 상기 병렬화된 제1 데이터를 상기 제2 엔디언 포맷으로 변환하는 단계를 포함하는 방법."}
{"patent_id": "10-2020-0059971", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "상이한 엔디언 포맷에 따른 데이터 변환을 위한 인터페이스 회로를 갖는 메모리 장치가 개시된다. 메모리 장치 는 메모리 뱅크, 프로세싱 소자, 그리고 호스트 장치의 엔디언 포맷을 고려해서 메모리 장치 내부의 데이터 전달 경로에서 하드웨어적으로 데이터 변환을 수행하는 인터페이스 회로를 포함한다. 인터페이스 회로는 (i) 메모리 물리 계층 인터페이스(PHY) 영역과 직렬화기/역직렬화기(SERDES) 영역 사이에 배치되거나, (ii) SERDES 영역과 메모리 뱅크 또는 프로세싱 소자 사이에 배치되거나, (iii) SERDES 영역과 메모리 뱅크를 다수개 포함한 뱅크 그 룹과 결합하는 뱅크 그룹 입출력 라인 사이에 배치되거나, (iv) 프로세싱 소자와 메모리 뱅크에 결합하는 뱅크 로컬 입출력 라인들 사이에 배치된다."}
{"patent_id": "10-2020-0059971", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 메모리 장치에 관한 것으로서, 더욱 상세하게는 엔디언 포맷에 따른 데이터 변환을 위한 인터페이스 회로를 갖는 메모리 장치에 관한 것이다."}
{"patent_id": "10-2020-0059971", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "고성능 및/또는 그래픽스 알고리즘들과 같은 어플리케이션들은 데이터- 및 컴퓨터-집약적(data- and compute- intensive) 이다. 뉴럴 네트워크들(Neural Networks)과 같은 머신 러닝 어플리케이션들은 많은 양의 계산 및 메모리 요건들을 포함하는 많은 수의 동작들을 포함할 수 있다. 따라서, 머신 러닝 어플리케이션들은 보다 정 확하게 상이한 데이터 셋트들을 훈련(train) 또는 학습(learn)하기 위하여, 대용량 연산 및 메모리 능력을 갖는 컴퓨팅 시스템을 필요로 한다. 컴퓨팅 시스템의 연산 동작들(computation operations) 중 일부를 내부 프로세 싱으로 수행하도록 하는 프로세서-인-메모리(Processor In Memory: PIM) 타입의 메모리 장치가 개발되고 있다. 메모리 장치의 내부 프로세싱을 통하여 컴퓨팅 시스템의 연산 동작 부담이 감소될 수 있다. 고대역폭 메모리(High Bandwidth Memory: HBM)은 3차원 적층된 다이나믹 랜덤 억세스 메모리(Dynamic Random Access Memory: DRAM)을 위한 고성능 RAM 인터페이스이다. HBM은 메모리 중심적이고 그리고 연산이 무거운 뉴 럴 네트워크 또는 다른 인공지능(Artificial Intelligence: AI)에 사용될 수 있다. 이는 훈련 데이터 세트 사이즈의 증가, 모델 파라미터들의 증가, 그리고 프로세싱의 중간 결과들의 증가 때문이다. 또한, HBM은 PIM 기 능을 실행하도록 구성되어, 내부 프로세싱, 예컨대 덧셈, 곱셈 등과 같은 산술 연산과 배타적 논리합(XOR)와 같 은 논리 연산을 수행하는 프로세싱 요소들(Processing Elements: PEs)를 포함할 수 있다. HBM은 HBM을 이용하는 호스트의 명령에 기초하여 데이터 버스를 통해 데이터를 송수신할 수 있다. 데이터 버스 는 바이트가 원자적인 단위로 간주되어 바이트-와이드-레인(byte-wide lane)으로 분할되는, 예컨대 64 비트들의 버스로 구성될 수 있다. 그런데, 호스트에서 데이터 버스를 사용하는 버스 엔디언(Endian)은 HBM이 사용하는 버스 엔디언과 다를 수 있다. 예시적으로, 호스트는 빅-엔디언(Big-Endian) 버스를 사용하는데 반해, HBM은 리 틀-엔디언(Little-Endian) 버스를 사용할 수 있다. 이에 따라, 데이터 불변성(invariance)을 위하여 상이한 버스 엔디언 포맷 사이에 데이터 변환이 필요하다."}
{"patent_id": "10-2020-0059971", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명의 목적은 상이한 엔디언 포맷에 따른 데이터 변환을 위한 인터페이스 회로를 갖는 메모리 장치를 제공 하는 데 있다."}
{"patent_id": "10-2020-0059971", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 실시예들에 따른 메모리 장치는, 메모리 뱅크, 메모리 뱅크와 결합하고 연산 처리를 수행하는 프로세 싱 소자, 메모리 장치 외부의 호스트 장치로부터 수신되는 직렬 데이터 스트림을 병렬화 하는 동작을 수행하도 록 그리고 메모리 뱅크 또는 프로세싱 소자에서 출력되는 병렬 데이터 스트림을 직렬화 하는 동작을 수행하도록 구성되는 직렬화기/역직렬화기(SERDES)를 포함하는 SERDES 영역, 및 메모리 뱅크, 프로세싱 소자 및 SERDES와 관련된 데이터 전달 경로를 포함하고, 메모리 장치로 하여금 호스트 장치의 엔디언 포맷을 고려하여 설정되는 제어 신호에 기초하여 데이터 전달 경로에서 데이터 변환을 수행할 수 있게 하는 인터페이스 회로를 포함한다. 본 발명의 실시예들에 따른 메모리 장치는, 메모리 뱅크, 메모리 장치 외부의 호스트 장치로부터 수신되는 직렬 데이터 스트림을 병렬화 하는 동작을 수행하도록 그리고 메모리 뱅크에서 출력되는 병렬 데이터 스트림을 직렬 화 하는 동작을 수행하도록 구성되는 직렬화기/역직렬화기(SERDES)를 포함하는 SERDES 영역, 그리고 메모리 뱅 크 및 SERDES와 관련된 데이터 전달 경로를 포함하고 SERDES 영역에 결합되어 메모리 장치로 하여금 호스트 장 치의 엔디언 포맷을 고려하여 설정되는 제어 신호에 기초하여 데이터 전달 경로에서 데이터 변환을 수행할 수 있게 하는 인터페이스 회로를 포함한다. 본 발명의 실시예들에 따른 호스트 장치와 메모리 장치 사이의 엔디언 포맷을 조정하는 인터페이스 회로를 포함 하는 메모리 장치의 동작 방법은, 호스트 장치로부터 제1 엔디언 포맷의 직렬 데이터 스트림을 수신하는 단계, 직렬 데이터 스트림을 제1 데이터로 병렬화 하는 단계, 그리고 인터페이스 회로에서 제어 신호에 기초하여 직렬 데이터 스트림을 메모리 장치의 제2 엔디언 포맷으로 변환하거나 또는 병렬화된 제1 데이터를 제2 엔디언 포맷 으로 변환하는 단계를 포함한다."}
{"patent_id": "10-2020-0059971", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 실시예들은, 메모리 장치에서 인터페이스 회로를 이용하여 하드웨어적으로 호스트 장치의 엔디언 포 맷을 고려한 데이터 변환은 메모리 장치의 향상된 성능을 가능하게 한다."}
{"patent_id": "10-2020-0059971", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 1, "content": "도 1은 본 발명의 실시예에 따른 데이터 변환을 설명하는 블록 다이어그램이다. 도 1을 참조하면, 빅-엔디언 버스와 리틀-엔디언 버스를 포함하는 2 타입의 버스 엔디언들을 보여준 다. 예시적으로, 64 비트들의 데이터가 데이터 버스(230, 도 2)를 통해 전송된다고 가정한다. 도 1에는 간략 하게 도시하기 위하여, 데이터 64 비트들, 즉 8 바이트들 구성이 도시되어 있으나, 이에 한정되지 않으며 다른 구성들도 가능하다. 데이터 64 비트들은 도 2 및 도 7에서 설명될 호스트 장치(또는 CPU, 210)에서 전송되는 데이터 사이즈에 해당한다. 데이터 8 바이트들 각각에 헥사 코드 0x0 내지 0x7로 인덱싱할 수 있다. 데이터 버스 구조에서, 가장 오른쪽에 위치한 바이트 또는 디지트들(digits)에 0x0 인덱싱의 제1 바이트가 배 치되고(placed), 가장 왼쪽에 위치한 바이트 또는 디지트들에 0x7 인덱싱의 제 8 바이트가 배치될 수 있다. 설 명의 편의를 위하여, 데이터 8 바이트들 각각은 0x0A 코드 비트들로 구성되는 1 바이트 또는 0x0B 코드 비트들 로 구성된 1 바이트, 즉 0x0A, 0x0B 코드 비트들의 2 바이트들 중 어느 하나로 구성되는 예로 설명한다. 본 발 명의 실시예들에서는 2 바이트들이 데이터 변환 단위로 설명될 것이다. 빅-엔디언 버스에서, 0x0A, 0x0B 코드 비트들의 2 바이트들이 데이터 변환 단위의 오른쪽에 위치한 디지트들부터 배치되는데, 즉, 0x0 인덱싱에 0x0A 코드 비트들이, 그리고 0x1 인덱싱에 0x0B 코드 비트들이 배 치된다. 이와 유사하게, 0x2 인덱싱에 0x0A 코드 비트들이 배치되고, 0x3 인덱싱에 0x0B 코드 비트들이 배치된 다. 그리고, 0x4 인덱싱에 0x0A 코드 비트들이 배치되고, 0x5 인덱싱에 0x0B 코드 비트들이 0x6 인덱싱에 0x0A 코드 비트들이 배치되고, 0x7 인덱싱에 0x0B 코드 비트들이 배치된다. 리틀-엔디언 버스에서, 0x0A, 0x0B 코드 비트들의 2 바이트들이 데이터 버스 변환 단위의 왼쪽에 위 치한 디지트들부터 배치되는데, 즉, 0x1 인덱싱에 0x0A 코드 비트들이, 그리고 0x0 인덱싱에 0x0B 코드 비트들 이 배치된다. 이와 유사하게, 0x3 인덱싱에 0x0A 코드 비트들이 배치되고, 0x2 인덱싱에 0x0B 코드 비트들이 배 치된다. 그리고, 0x5 인덱싱에 0x0A 코드 비트들이 배치되고, 0x4 인덱싱에 0x0B 코드 비트들이 0x7 인덱싱에 0x0A 코드 비트들이 배치되고, 0x6 인덱싱에 0x0B 코드 비트들이 배치된다. 빅-엔디언 버스와 리틀-엔디언 버스가 혼재(mix)된 환경에서, 엔디언 일치를 위하여 데이터 변환 이 필요하다. 만약, 호스트의 프로세서가 빅-엔디언 버스를 사용하고, 프로세서와 연결되는 메모리 장치는 리틀-엔디언 버스를 사용하는 경우, 데이터 변환은 메모리 장치에서 소프트웨어적으로 수행될 수 있다. 왜냐하면, 프로세서는 그 자신의 빅-엔디언 버스 포맷으로 데이터를 처리하기 때문이다. 메모 리 장치에서 데이터 변환을 수행하는 동안 일련의 시프트들 및 스왑들(a series of shifts and swaps)이 요구되는데, 이러한 소프트웨어 처리(software manipulation)는 메모리 공간과 시간을 많이 소비하므로, 메모리 장치의 성능 저하를 유발할 수 있다. 이에 따라, 메모리 장치에서 하드웨어적으로 데이터 변환을 수행할 수 있 다면, 이러한 기능(facility)이 가능하다면, 메모리 장치의 성능 향상에 유익할 것이다. 도 2는 본 발명의 실시예에 따른 데이터 변환을 갖는 시스템의 블록 다이어그램이다. 도 2를 참조하면, 시스템에서 호스트 장치와 메모리 장치는 다양한 프로토콜을 사용하여 통신할 수 있으며, 예컨대 PCI-E(Peripheral Component Interconnect - Express), ATA(Advanced Technology Attachment), SATA(Serial ATA), PATA(Parallel ATA) 또는 SAS(serial attached SCSI)와 같은 인터페이스 프로 토콜을 사용하여 통신할 수 있다. 이외에도, USB(Universal Serial Bus), MMC(Multi-Media Card), ESDI(Enhanced Small Disk Interface) 또는 IDE(Integrated Drive Electronics) 등과 같은 다른 다양한 인터페 이스 프로토콜들이 호스트 장치와 메모리 장치 사이의 프로토콜에 적용될 수 있다.호스트 장치와 메모리 장치 사이의 데이터 전송은, 데이터 버스의 병렬 채널들에 구동되는 데이터 신호들, 즉 데이터 비트들의 형태로 이루어진다. 호스트 장치는 데이터 비트들을 발생시켜 데이터 버스를 통해 메모리 장치에 전송할 수 있다. 호스트 장치는 시스템 내 컴퓨터 동작을 수 행하는 기능 블락(functional block)으로서, 중앙 처리 유닛(Central Processing Unit: CPU), 그래픽 처리 유 닛(Graphic Processing Unit: GPU), 디지털 신호 프로세서(Digital Signal Processor: DSP) 또는 어플리케이션 프로세서(Application Processor: AP)에 해당될 수 있다. 본 명세서에서 호스트 장치는 CPU로 지칭 될 수 있다. CPU는 하나 또는 그보다 많은 기계로 실행 가능한 명령들 또는 소프트웨어, 펌웨어 또는 이들의 조합의 조 각들을 실행하도록 구성될 수 있다. CPU는 임의의 숫자의 프로세서 코어를 포함할 수 있다. 예를 들어, CPU는 단일 코어(Single-Core)를 포함하거나 듀얼 코어(Dual-Core), 쿼드 코어(Quad-Core), 헥사 코어 (Hexa-Cire) 등의 멀티 코어(Multi-Core)를 포함할 수 있다. 도 2에는 하나의 CPU를 포함하는 시스템 이 도시되어 있으나, 실시예에 따라, 시스템은 복수의 CPU들을 포함할 수 있다. 데이터 버스는 양방향 데이터 버스일 수 있고, 이 경우, 메모리 장치는 데이터 비트들을 발생시켜 데 이터 버스를 통해 호스트 장치에 전송할 수 있다. 데이터 버스는 채널이라 불리는 병렬인 도전성 라인들(conductive lines)을 포함하고, 이들 채널은 그 각각의 단부에서 장치들, 220) 각각의 핀에 결합된다. \"핀\"이라는 용어는 집적 회로에 대한 전기적 상호 접속을 폭넓게 가리키는 것으로서, 예를 들 어, 패드 또는 집적 회로 상의 다른 전기적 접촉점을 포함할 수 있다. 데이터 버스는 임의 개수의 채널 을 포함할 수 있고, 그 개수는 예컨대, 2, 4, 8, 16, 32 또는 64 개의 채널들을 포함할 수 있다. 채널은 CPU와 메모리 장치 사이의 독립된 인터페이스들을 구성할 수 있다. 예컨대, 메모리 장 치가 HBM으로 구현되는 경우, HBM에 스택된 DRAM 다이들(621~624, 도 6) 각각은 2 채널들을 포함하고, 각 채널(예, CH6, 도 6)은 2개의 의사 채널들(Pseudo Channel, 예, CH6a, CH6b, 도 6)로 구성되고, 각 의사 채널 은 64개의 도전성 라인들을 포함할 수 있다. 이에 따라, HBM DRAM 다이들(621~624) 각각은 4 의사 채널들로 구 성되어 256개의 도전성 라인들을 포함할 수 있다. 데이터 버스는 HBM 아키텍쳐와 연관된 구조 (organization)를 통하여 8 채널들과 결합될 수 있다. 일부 예는 \"연결된(connected)\" 및/또는 \"결합된(coupled)\" 이라는 표현을 그들의 파생어들과 함께 사용하여 설 명될 수 있다. 이들 용어가 서로에 대해 꼭 동의어로서 의도된 것은 아니다. 예를 들어, \"연결된\" 및/또는 \" 결합된\" 이라는 용어들을 이용한 설명은, 2개 이상의 요소가 서로 직접적으로 물리적 또는 전기적 접촉하는 것 을 나타낼 수 있다. 또한, 용어 \"연결\" 및/또는 \"결합\"은 2개 이상의 요소가 서로 직접 접촉하고 있지 않지만 여전히 서로 협력하거나 상호 작용하는 것도 의미할 수 있다. 데이터 버스는 데이터 비트들을 메모리 장치의 하드웨어 구성들 중 하나인 인터페이스 회로에 전달하도록 결합될 수 있다. 인터페이스 회로는 데이터 버스의 데이터를 수신하고, 수신된 데이터에 대하여 호스트 장치의 빅-엔디언 포맷을 고려해서 데이터 변환을 할 수 있게 한다. 메모리 장치는 그 내부에 다양한 데이터 경로들을 포함하는데, 인터페이스 회로는 소정의 데이터 경로에서 제어 신호 (BE_SEL)에 기초하여 데이터 변환을 수행할 수 있다. 제어 신호(BE_SEL)는 메모리 장치의 모드 레지스터 세트(Mode Register Set: MRS, 224)에서 제공될 수 있 다. MRS는 CPU로부터 MRS 커맨드가 발행될 때 메모리 인터페이스의 어드레스 버스로 제공되는 적절 한 비트 값들로 프로그램될 수 있다. MRS에는 메모리 장치의 복수개 동작 옵션들, 다양한 기능들, 특성들 그리고 모드들이 설정될 수 있다. 본 개시에서, MRS는 빅-엔디언 포맷으로의 변경 여부를 설정하 는 특별한 제어 신호(BE_SEL)를 포함할 수 있다. 예컨대, MRS는 빅-엔디언 포맷으로의 변경을 나타낼 때, 로직 하이레벨의 제어 신호(BE_SEL)를 제공할 수 있다. 몇몇 실시예에 따라, 제어 신호(BE_SEL)는 메모리 장치 내 비휘발성 메모리 소자, 예컨대, 안티 퓨즈를 이 용하여 제공될 수 있다. 안티 퓨즈는 퓨즈 소자와 반대되는 전기적 특성을 갖는 것으로서, 프로그램되지 않은 상태에서는 높은 저항 값을 갖는 반면, 프로그램된 상태에서는 낮은 저항 값을 갖는 저항성 퓨즈 소자이다. 예 시적으로, 안티 퓨즈가 프로그램된 상태일 때, 제어 신호(BE_SEL)는 빅-엔디언 포맷으로의 변경을 나타낼 수 있 다. 도 3은 본 발명의 실시예들에 따른 인터페이스 회로를 설명하는 블락 다이어그램이다. 도 2 및 도 3을 참조하면, 인터페이스 회로는 제1 데이터 버스와 제2 데이터 버스 사이에 연결 되는 데이터 변환기를 포함한다. 제1 데이터 버스는 CPU와 결합되는 데이터 라인들 (D_BUS[15:0])을 나타내고, 제2 데이터 버스는 메모리 장치와 결합되는 데이터 라인들(DQ[0:15])을 나타낸다. 데이터 변환기는 제어 신호들(BE_SEL, BE_SELB)에 따라 선택적으로 제1 데이터 버스의 특정 엔디언 포맷에 맞추어 제2 데이터 버스의 엔디언 포맷을 변경(reconfigure)하여 전송(transfer)한다. 데이터 변 환기는 제어 신호들(BE_SEL, BE_SELB)에 응답하여 제1 데이터 버스가 빅-엔디언 포맷이면 제2 데이터 버스의 엔디언 포맷을 빅-엔디언으로 변경하고, 제1 데이터 버스가 리틀-엔디언 포맷이면 제2 데이터 버스를 리틀-엔디언 포맷으로 변경할 수 있다. 제어 신호(BE_SEL)는 데이터 변환기가 빅-엔디언 포맷으로 변경할 것인지 여부를 결정할 수 있다. 제어 신호(BE_SELB)는 제어 신호(BE_SEL)와 반대의 로직 레벨을 갖는 신호이다. 제1 데이터 버스는 제1 바이트를 전송하는 D_BUS0 ~ D_BUS7 라인들과 제2 바이트를 전송하는 D_BUS8 ~ D_BUS15 라인들로 구성되고, 제2 데이터 버스는 제1 바이트를 전송하는 DQ0 ~ DQ7 라인들 과 제2 바이트를 전송하는 DQ8 ~ DQ15 라인들로 구성된다. 만약, 제1 데이터 버스가 리틀-엔디언 포 맷이고 제어 신호(BE_SEL)가 빅-엔디언 포맷으로의 변경을 지시하지 않는다면, 데이터 변환기는 제1 데이 터 버스의 제1 바이트를 제2 데이터 버스의 제1 바이트로 패스하고, 제1 데이터 버스(31 0)의 제2 바이트를 제2 데이터 버스의 제2 바이트로 패스할 수 있다. 또한, 데이터 변환기 는 제2 데이터 버스의 제1 바이트를 제1 데이터 버스의 제1 바이트로 패스하고, 제2 데이터 버스의 제2 바이트를 제1 데이터 버스의 제2 바이트로 패스할 수 있다. 만약, 제1 데이터 버스가 빅-엔디언 포맷이고 제어 신호(BE_SEL)가 빅-엔디언 포맷으로의 변경을 지시한다 면, 데이터 변환기는 제1 데이터 버스의 제1 바이트를 제2 데이터 버스의 제2 바이트(32 2)로 변경하여 전송하고, 제1 데이터 버스의 제2 바이트를 제2 데이터 버스의 제1 바이트 로 변경하여 전송할 수 있다. 또한, 데이터 변환기는 제2 데이터 버스의 제1 바이트를 제1 데 이터 버스의 제2 바이트로 변경하여 전송하고, 제2 데이터 버스의 제2 바이트를 제1 데이 터 버스의 제1 바이트로 변경하여 전송할 수 있다. 데이터 변환기는 제1 데이터 버스의 제1 바이트 및 제2 바이트와 제2 데이터 버스의 제1 바이트 및 제2 바이트를 선택적으로 교환(exchange)하는 기능을 수행하는데, 이를 수행하는 실제 물리적 구현은 데이터-투-데이터 멀티플렉서(D2D MUX) 형태를 취할 수 있다. 이하, 설명의 편의를 위하여, 데 이터 변환기는 D2D MUX로 지칭되어 D2D MUX로 설명될 것이다. 그리고, 제1 데이터 버스는 빅- 엔디언 포맷으로 데이터를 전송하고, 제2 데이터 버스는 리틀-엔디언 포맷으로 데이터를 전송한다고 가정 하고, 제어 신호(BE_SEL)의 로직 하이레벨은 D2D MUX가 빅-엔디언 포맷으로의 변경을 제어한다고 가정한다. 도 4는 도 3의 D2D MUX를 구현하는 회로 다이어그램을 예시하는 도면이다. 도 3 및 도 4를 참조하면, D2D MUX는 16개 전송 게이트 회로들을 포함할 수 있다. 각각의 전송 게이 트 회로는 제1 데이터 버스의 제1 바이트 중 1 비트 라인, 제1 데이터 버스의 제2 바이트 중 1 비트 라인, 그리고 제2 데이터 버스의 제1 또는 제2 바이트(321, 322) 중 1 비트 라인에 배분 (partition) 된다. 예를 들어, 전송 게이트 회로는 D_BUS0 라인과 DQ0 라인 사이에 연결되는 제1 전송 게 이트와 D_BUS8 라인과 DQ0 라인 사이에 연결되는 제2 전송 게이트를 포함한다. 제1 전송 게이트는 제어 신호(BE_SEL)의 로직 로우레벨에 응답하여 D_BUS0 라인과 DQ0 라인을 연결하고, 제2 전송 게이트는 제 어 신호(BE_SEL)의 로직 하이레벨에 응답하여 D_BUS8 라인과 DQ0 라인을 연결한다. 나머지 다른 전송 회로들 도 이와 유사하게 동작된다. 이에 따라, 만약, 제어 신호(BIG_SEL)가 로직 로우레벨인 경우, D2D MUX는 제1 데이터 버스의 제1 바 이트가 제2 데이터 버스의 제1 바이트로 패스되고 제1 데이터 버스의 제2 바이트가 제2 데이터 버스의 제2 바이트로 패스되도록 하고, 제2 데이터 버스의 제1 바이트가 제1 데이터 버스의 제1 바이트로 패스되고, 제2 데이터 버스의 제2 바이트가 제1 데이터 버스 의 제2 바이트로 패스되도록 한다. 만약, 제어 신호(BIG_SEL)가 로직 하이레벨인 경우, D2D MUX는 제1 데이터 버스의 제2 바이트가 제2 데이터 버스의 제1 바이트로 변경되어 전 송되고 제1 데이터 버스의 제1 바이트가 제2 데이터 버스의 제2 바이트로 변경되어 전송되도록 하고, 제2 데이터 버스의 제2 바이트가 제1 데이터 버스의 제1 바이트로 변경되어 전 송되고, 제2 데이터 버스의 제1 바이트가 제2 데이터 버스의 제2 바이트로 변경되어 전송 되도록 한다. 도 5a 내지 도 5c는 도 3의 D2D MUX를 구현하는 회로 다이어그램을 예시하는 도면이다. 도 5a의 D2D MUX 는 도 5b 및 도 5c로 구성된다. 도 3 및 도 5b를 참조하면, D2D MUX는 16개의 제1 멀티플렉서들을 포함할 수 있다. 각각의 제1 멀티 플렉서들은 제1 데이터 버스의 제1 바이트 중 1 비트 라인, 제1 데이터 버스의 제2 바이트 중 1 비트 라인, 그리고 제2 데이터 버스의 제1 또는 제2 바이트(321, 322) 중 1 비트 라인에 배분 된다. 예를 들어, 제1 멀티플렉서는 D_BUS0 라인, D_BUS8 라인 및 DQ0 라인 사이에 연결되고, 제어 신호 (BE_SEL)의 로직 로우레벨에 응답하여 D_BUS0 라인의 비트를 DQ0 라인으로 전송하고, 제어 신호(BE_SEL)의 로직 하이레벨에 응답하여 D_BUS8 라인의 비트를 DQ0 라인으로 전송한다. 나머지 다른 제1 멀티플렉서들도 이와 유사하게 동작된다. 이에 따라, 만약 제어 신호(BIG_SEL)가 로직 로우레벨이면, D2D MUX는 제1 데이터 버스의 제1 바이트 가 제2 데이터 버스의 제1 바이트로 패스되고 제1 데이터 버스의 제2 바이트가 제2 데이터 버스의 제2 바이트로 패스되도록 한다. 만약 제어 신호(BIG_SEL)가 로직 하이레벨이면, D2D MUX는 제1 데이터 버스의 제2 바이트가 제2 데이터 버스의 제1 바이트로 변경되어 전 송되고 제1 데이터 버스의 제1 바이트가 제2 데이터 버스의 제2 바이트로 변경되어 전송되 도록 한다. 도 3 및 도 5c를 참조하면, D2D MUX는 16개의 제2 멀티플렉서들을 포함할 수 있다. 각각의 제2 멀티 플렉서들은 제2 데이터 버스의 제1 바이트 중 1 비트 라인, 제2 데이터 버스의 제2 바이트 중 1 비트 라인, 그리고 제1 데이터 버스의 제1 또는 제2 바이트(311, 312) 중 1 비트 라인에 배분 된다. 예를 들어, 제2 멀티플렉서는 DQ0 라인, DQ8 라인 및 D_BUS0 라인 사이에 연결되고, 제어 신호 (BE_SEL)의 로직 로우레벨에 응답하여 DQ0 라인의 비트를 D_BUS0 라인으로 전송하고, 제어 신호(BE_SEL)의 로직 하이레벨에 응답하여 DQ8 라인의 비트를 D_BUS0 라인으로 전송한다. 나머지 다른 제2 멀티플렉서들도 이와 유사하게 동작된다. 이에 따라, 만약 제어 신호(BIG_SEL)가 로직 로우레벨이면, D2D MUX는 제2 데이터 버스의 제1 바이트 가 제1 데이터 버스의 제1 바이트로 패스되고, 제2 데이터 버스의 제2 바이트가 제1 데이터 버스의 제2 바이트로 패스되도록 한다. 만약 제어 신호(BIG_SEL)가 로직 하이레벨이면, D2D MUX는 제2 데이터 버스의 제2 바이트가 제1 데이터 버스의 제1 바이트로 변경되어 전 송되고, 제2 데이터 버스의 제1 바이트가 제2 데이터 버스의 제2 바이트로 변경되어 전송 되도록 한다. 도 6은 본 발명의 실시예들에 따른 메모리 장치를 설명하는 도면이다. 도 2 및 도 6을 참조하면, 메모리 장치는 서로 독립된 인터페이스를 갖는 다수의 채널들(CH1~CH8)을 포함 하는 HBM 일 수 있다. 메모리 장치는 다수 개의 다이들을 포함할 수 있는데, 버퍼 다이와 버퍼 다이 상에 적층된 적어도 하나의 DRAM 다이를 포함할 수 있다. 예컨대, 제1 DRAM 다이가 제1 채널 (CH1) 및 제3 채널(CH3)을 포함하고, 제2 DRAM 다이가 제2 채널(CH2) 및 제4 채널(CH4)을 포함하며, 제3 DRAM 다이가 제5 채널(CH5) 및 제7 채널(CH7)을 포함하며, 제4 DRAM 다이가 제6 채널(CH6) 및 제8 채널(CH8)을 포함할 수 있다. 버퍼 다이는 메모리 장치의 외면에 형성된 도전 수단들, 예컨대 범프들 또는 솔더볼들을 통해 CPU와 통신할 수 있다. 버퍼 다이는 CPU로부터 커맨드, 어드레스 및 데이터를 수신할 수 있으 며, 수신된 커맨드, 어드레스 및 데이터를 적어도 하나의 DRAM 다이의 채널로 제공할 수 있다. 또한, 버 퍼 다이는 적어도 하나의 DRAM 다이의 채널에서 출력되는 데이터를 CPU로 제공할 수 있다. 메모리 장치는 DRAM 다이들(621~624)을 관통하는 복수 개의 스루 실리콘 비아(TSV; 630)들을 포함할 수 있 다. 각각의 채널(CH1~CH8)이 128 비트의 대역폭(bandwidth)을 갖는 경우, TSV들은 1024 비트의 데이터 입출력을 위한 구성들을 포함할 수 있다. 채널들(CH1~CH8) 각각은 좌우로 분리되어 배치될 수 있는데, 예시적 으로, 제4 DRAM 다이에서 제6 채널(CH6)은 의사 채널들(CH6a, CH6b)로 분리되고 제8 채널(CH8)은 의사 채 널들(CH8a, CH8b)로 분리될 수 있다. TSV들은 제6 채널(CH6)의 의사 채널들(CH6a, CH6b) 사이에, 그리고제8 채널(CH8)의 의사 채널들(CH8a~CH8b) 사이에 배치될 수 있다. 버퍼 다이는 TSV 영역, 직렬화기/역직렬화기(SERializer/DESerializer: SERDES) 영역 및 HBM 물리 계층 인터페이스(PHYsical layer interface) 즉, HBM PHY 영역을 포함할 수 있다. TSV 영역은 적어도 하나의 DRAM 다이와의 통신을 위한 TSV가 형성되는 영역이다. SERDES 영역은 CPU의 프로세싱 스루풋이 증가함에 따라, 그리고 메모리 대역폭에 대한 요구들이 증가 함에 따라, JEDEC(Joint Electron Device Engineering Council) 표준의 SERDES 인터페이스를 제공하는 영역이 다. SERDES 영역은 SERDES 송신기 부분, SERDES 수신기 부분 및 제어기 부분을 포함할 수 있다. SERDES 송신기 부분은 병렬-투-직렬 회로 및 송신기를 포함하고, 병렬 데이터 스트림을 수신하고, 수신된 병렬 데이터 스트림을 직렬화 할 수 있다. SERDES 수신기 부분은 수신기 증폭기, 등화기, 클럭 및 데이터 복원(CDR) 회로 및 직렬-투-병렬 회로를 포함하고, 직렬 데이터 스트림을 수신하고, 수신된 직렬 데이터 스트림을 병렬화 할 수 있다. 제어기 부분은 에러 검출 회로, 에러 정정 회로 및 FIFO(First In First Out)와 같은 레지스터들을 포함 한다. HBM PHY 영역은 CPU와 메모리 장치 사이의 효율적인 통신에 요구되는 신호들, 주파수, 타이밍, 구동, 상세 동작 파라미터 및 기능성(functionality)을 위해 제공되는 물리적 또는 전기적 계층과 논리적 계층 을 포함할 수 있다. HBM PHY 영역은 메모리 셀에 대응하는 로우 및 칼럼을 선택하는 것, 메모리 셀에 데 이터를 기입하는 것, 또는 기입된 데이터를 독출하는 것과 같은 메모리 인터페이싱을 수행할 수 있다. HBM PHY 영역은 JEDEC 표준의 HBM 프로토콜의 특징들을 지원할 수 있다. 예시적으로, HBM PHY 영역은 CPU와 64 비트 사이즈의 데이터 통신을 수행할 수 있다. 도 7은 본 발명의 실시예들에 따른 메모리 장치(220a) 내 D2D MUX(330a)의 배치를 예시적으로 설명하는 도면이 다. 이하, 참조 번호에 붙은 첨자(예컨대, 220a 의 a, 330a의 a)는 동일한 기능을 하는 다수의 회로를 구분하 기 위한 것이다. 도 6 및 도 7을 참조하면, 메모리 장치(220a)에서, D2D MUX(330a)는 HBM PHY 영역과 SERDES 영역 사 이에 배치될 수 있다. HBM PHY 영역은 CPU로부터 64 비트 입력 데이터를 수신하고 바이트 와이드로 분할하여 D2D MUX(330a)으로 전달할 수 있다. D2D MUX(330a)는 제어 신호(BE_SEL)에 응답하여 64 비트 입력 데이터에 대하여 2 바이트 단위로 데이터 패스 또는 변환 동작에 기반하여 데이터 변환을 수행하고, 64 비트 출 력 데이터를 출력할 수 있다. D2D MUX(330a)는 앞서 설명된 도 4 및 도 5a 내지 도 5c의 D2D MUX로 구현 될 수 있으며, 64 비트 입력 데이터는 8 바이트로 분할되어 제1 데이터 버스에 실리고, 64 비트 출력 데이 터는 8 바이트로 분할되어 제2 데이터 버스에 실릴 것이다. D2D MUX(330a)는, 로직 하이레벨의 제어 신호(BE_SEL)에 따라, 도 1에 도시된 데이터 변환처럼, 제1 데이 터 버스의 제1 바이트를 제2 데이터 버스의 제2 바이트로 변경하여 전송하고, 제1 데이터 버스 의 제2 바이트를 제2 데이터 버스의 제1 바이트로 변경하여 전송할 수 있다. 이와 유사하게, 제1 데이터 버스의 제3 바이트를 제2 데이터 버스의 제4 바이트로 변경하고, 제1 데이터 버스의 제4 바이트 를 제2 데이터 버스의 제3 바이트로 변경하고, 제1 데이터 버스의 제5 바이트를 제2 데이터 버스 의 제6 바이트로 변경하고, 제1 데이터 버스의 제6 바이트를 제2 데이터 버스의 제5 바이트로 변경하고, 제1 데이터 버스의 제7 바이트를 제2 데이터 버스의 제8 바이트로 변경하고, 그리고, 제1 데이터 버스의 제8 바이트를 제2 데이터 버스의 제7 바이트로 변경하여 전송할 수 있다. 즉, D2D MUX(330a)는 로직 하이레벨의 제어 신호(BE_SEL)에 따라 제1 데이터 버스와 제2 데이터 버스의 2 바 이트끼리 교환할 수 있다. D2D MUX(330a)는 로직 로우레벨의 제어 신호(BE_SEL)에 따라, 제1 데이터 버스의 제1 내지 제8 바이트를 제2 데이터 버스의 제1 내지 제8 바이트로 변함없는(unchanged) 데이터를 패스할 수 있다. D2D MUX(330a)에 의해 데이터 변환이 수행된 후, 제2 데이터 버스는 SERDES 영역과 결합될 수 있다. SERDES 영역는 제2 데이터 버스의 64 비트 데이터를 연속적으로 수신하고, 직렬-투-병렬 회로를 통하 여 256 비트 병렬 데이터로 변환하여 출력할 수 있다. SERDES 영역에서 출력되는 256 비트 병렬 데이터는 TSV 영역을 통해 적어도 하나의 DRAM 다이로 제공될 수 있다. 도 8은 본 발명의 실시예들에 따른 메모리 장치(220b) 내 D2D MUX(330b)의 배치를 예시적으로 설명하는 도면이 다. 도 8의 D2D MUX(330b)는 도 7의 D2D MUX(330a)와 비교하여, SERDES 영역과 TSV 영역 사이에 배 치된다는 점에서 차이가 있다. 이하, 도 7과의 차이점을 중심으로 설명된다.도 6 및 도 8을 참조하면, CPU로부터 HBM PHY 영역으로 연속적으로 수신되는 64 비트 입력 데이터는, SERDES 영역으로 제공되어 256 비트 병렬 데이터로 변환될 수 있다. SERDES 영역에서 출력되는 256 비트 병렬 데이터는 제1 데이터 버스를 통해 D2D MUX(330b)로 전달될 수 있다. D2D MUX(330b)는 제어 신 호(BE_SEL)에 응답하여 256 비트 입력 데이터에 대하여 2 바이트 단위로 수행되는 데이터 패스 또는 변환 동작 에 기반하여 데이터 변환을 수행하고, 제2 데이터 버스를 통해 256 비트 출력 데이터를 출력할 수 있다. D2D MUX(330b)는 앞서 설명된 도 4 및 도 5a 내지 도 5c의 D2D MUX로 구현될 수 있으며, 256 비트 입력 데이터는 16 바이트들로 분할되어 제1 데이터 버스에 실리고, 64 비트 출력 데이터는 16 바이트들로 분할 되어 제2 데이터 버스에 실릴 것이다. D2D MUX(330b)는 로직 하이레벨의 제어 신호(BE_SEL)에 따라 제1 데이터 버스와 제2 데이터 버스의 2 바이트끼리, 즉, 제1 및 제2 바이트끼리, 제3 및 제4 바이트끼리, 제5 및 제6 바이트끼리, 제7 및 제8 바이트 끼리, 제9 및 제10 바이트끼리, 제11 및 제12 바이트끼리, 제13 및 제14 바이트끼리, 그리고 제15 및 제16 바이 트끼리 교환할 수 있다. D2D MUX(330b)는 로직 로우레벨의 제어 신호(BE_SEL)에 따라, 제1 데이터 버스의 제1 내지 제16 바이트를 제2 데이터 버스의 제1 내지 제16 바이트로 변함없는 데이터를 패스할 수 있다. D2D MUX(330b)에 의해 데이터 버스 변환이 수행된 후, 제2 데이터 버스는 TSV 영역과 결합될 수 있다. 도 7의 D2D MUX(330a)는 CPU의 동작 속도, 예컨대 1.2GHz에 맞추어 통신하는 HBM PHY 영역과 결합되 기 때문에, HBM PHY 영역의 고속 동작에 적합한 고주파수 동작의 데이터 버스 변환이 요구될 수 있다. 이 에 반해, 도 8의 D2D MUX(330b)는 HBM PHY 영역와 SERDES 영역에서 고속 동작으로 수행 처리된 256 비트 병렬 데이터에 대해 데이터 버스 변환을 수행하기 때문에, 도 8의 D2D MUX(330b)는 도 7의 D2D MUX(330a) 보다 상대적으로 낮은 주파수 동작의 데이터 버스 변환으로도 충분할 수 있다. 한편, 도 7의 D2D MUX(330a)는 제1 및 제1 데이터 버스(310, 320)의 64 비트 데이터에 대하여 데이터 버스 변환 을 수행하는데 대해, 도 8의 D2D MUX(330b)는 제1 및 제2 데이터 버스(310, 320)의 256 비트 데이터에 대하여 데이터 버스 변환을 수행한다. 도 7의 D2D MUX(330a) 사이즈가 도 8의 D2D MUX(330b) 사이즈 보다 상대적으로 작을 것이므로, 도 7의 D2D MUX(330a)가 면적 면에서 이롭다. 도 9는 본 발명의 실시예들에 따른 메모리 장치(220c) 내 D2D MUX(330c)의 배치를 예시적으로 설명하는 도면이 다. 도 9의 메모리 장치(220c)의 구성 및 동작을 설명함에 있어서, 이 구성은 도 6의 HBM에서 적어도 하나의 DRAM 다이에 해당할 수 있다. 적어도 하나의 DRAM 다이을 설명할 다수의 하드웨어 구성이 도시되어 있으나, 이에 한정되지 않으며 다른 구성들도 가능하다. 도 2, 도 6 및 도 9를 참조하면, 메모리 장치(220c)의 적어도 하나의 DRAM 다이는 제1 내지 제4 뱅크들 (BANK0~BANK3)이 하나의 뱅크 그룹(BG)으로 정의되고, 제1 내지 제4 뱅크들(BANK0~BANK3)이 뱅크 그룹 입출력 라인(IO)를 공유하는 예가 도시된다. 뱅크 그룹 IO(BGIO)는 CPU와 뱅크 그룹(BG) 사이에서 데이터를 양방 향으로 전달할 수 있다. 도면의 간결성을 위하여, 뱅크 그룹 IO(BGIO) 및 뱅크 로컬 IO (BLIO)는 하나의 신호 라인으로 도시되고 있으나, 실제로는 복수의 신호 라인들로 구현될 수 있다. 프로세싱 소자(PE, 906)는 두 개 이상의 뱅크들에 대응하여 배치될 수 있는데, 제1 및 제2 뱅크들(BANK0, BANK1)에 대응하여, 그리고 제3 및 제4 뱅크들(BNAK2, BANK3)에 대응하여 배치될 수 있다. PE는 PIM 기 능을 수행하는 개념적인 구성 요소로서, 산술 연산 및/또는 논리 연산 처리에 관련된 다른 다양한 구성 요소들 을 포함하는 것으로 정의될 수 있다. 예컨대, 연산 처리의 전반적인 동작을 제어하는 제어기, 명령어들을 저장 하는 명령어 메모리(또는, 명령어 큐) 및/또는 명령어 디코딩 등 다양한 기능을 수행하는 구성 요소들이 PE에 구비될 수 있다. 제1 뱅크(BANK0)에 대응하여 센스 앰프, 기록 드라이버 및 뱅크 그룹 입출력 게이팅 회로(이하, BGIO 게이팅 회로로 지칭됨)가 결합할 수 있다. 또한, 센스 앰프 및 기록 드라이버는 뱅크 로컬 IO (BLIO) 상에 배치될 수 있고, BGIO 게이팅 회로는 뱅크 로컬 IO (BLIO) 의 데이터 전달 방향을 선택하기 위하여 배치될 수 있다. 도 9에서는 BGIO 게이팅 회로가 기록 드라이버를 통해 데이터가 전달되는 경로에 배치되는 예가 도시되었으나, 이에 국한될 필요가 없다. 다른 예로서, BGIO 게이팅 회로는 센스 앰프를 통해 데이터가 출력되는 경로에 배치될 수도 있다.제1 뱅크(BANK0)에 대응하여 제1 프로세싱 소자 입출력(PEIO) 게이팅 회로가 배치되고, 제2 뱅크(BANK1)에 대응하여 제2 PEIO 게이팅 회로가 배치될 수 있다. 제1 및 제2 PEIO 게이팅 회로들(904, 905)은 메모리 동작과 연산 처리 동작에서 데이터의 이동 경로를 제어하기 위해 배치될 수 있다. 메모리 동작 시, 제1 PEIO 게이팅 회로는 뱅크 로컬 IO (BLIO)와 뱅크 그룹 IO(BGIO)을 전기적으로 연결시켜 CPU와 제1 뱅크 (BANK0) 사이에서 데이터가 송수신되도록 하고, 제2 PEIO 게이팅 회로에 의하여 CPU와 제2 뱅크 (BANK1) 사이에서 데이터가 송수신될 수 있다. 반면에, 연산 처리시에는, 제1 및 제2 PEIO 게이팅 회로들(904, 905)이 뱅크 로컬 IO (BLIO)와 뱅크 그룹 IO(BGIO)를 전기적으로 차단하고, CPU와 프로세싱 소자(PE, 906) 사이에서 데이터가 송수신되도록 하고, 또는 PE와 제1 및 제2 뱅크들(BANK0, BANK1) 사이에서 데이터 가 송수신되도록 한다. PE는 제1 및 제2 뱅크들(BANK0, BANK1)에 대응하여 배치될 수 있다. PE는 CPU로부터 제공되는 데이터, 제1 및 제2 뱅크들(BANK0, BANK1)로부터 독출된 데이터, PE 내에 구비되는 레지스터에 저장된 정 보 중 적어도 하나를 이용하여 연산 처리를 수행할 수 있다. 일 실시예로, PE가 제1 뱅크(BANK0)로부터의 데이터를 이용하여 연산 처리를 수행하는 경우, 제2 뱅크(BANK1)에 대응하여 배치되는 제2 PEIO 게이팅 회로 는 뱅크 그룹 IO(BGIO)와 제2 뱅크(BANK1)에 대응하는 뱅크 로컬 IO (BLIO)의 전기적 연결을 차단할 수 있 다. 다른 실시예로, PE가 제1 및 제2 뱅크들(BANK0, BANK1)에 공유되는 경우, 어느 하나의 뱅크의 데이터 를 이용한 연산 처리 결과는 다른 뱅크에 저장될 수도 있을 것이다. 일 예로서, 제1 뱅크(BANK0)로부터 독출된 데이터가 피연산자로서 PE로 제공되고, PE로부터의 연산 결과는 제2 뱅크(BANK1)에 저장될 수 있다. 뱅크 그룹 IO(BGIO)는 데이터 버스 드라이버를 통해 D2D MUX(330c)와 결합되고, D2D MUX(330c)는 TSV와 결합될 수 있다. 적어도 하나의 DRAM 다이의 TSV로 전달되는 데이터는 제1 데이터 버스 를 통해 D2D MUX(330c)로 전달될 수 있다. D2D MUX(330c)는 제어 신호(BE_SEL)에 응답하여 256 비트 입 력 데이터에 대하여 2 바이트 단위로 데이터 패스 또는 변환 동작에 기반하여 데이터 버스 변환을 수행하고, 제 2 데이터 버스를 통해 256 비트 출력 데이터를 출력할 수 있다. D2D MUX(330c)는 앞서 설명된 도 4 및 도 5a 내지 도 5c의 D2D MUX로 구현될 수 있으며, 256 비트 입력 데이터는 16 바이트들로 분할되어 제1 데이터 버스에 실리고, 256 비트 출력 데이터는 16 바이트들로 분할 되어 제2 데이터 버스에 실릴 것이다. D2D MUX(330c)는 로직 하이레벨의 제어 신호(BE_SEL)에 따라 제1 데이터 버스와 제2 데이터 버스의 258 비트들의 16 바이트들에서 2 바이트끼리, 즉, 제1 및 제2 바이 트끼리, 제3 및 제4 바이트끼리, 제5 및 제6 바이트끼리, 제7 및 제8 바이트끼리, 제9 및 제10 바이트끼리, 제 11 및 제12 바이트끼리, 제13 및 제14 바이트끼리, 그리고 제15 및 제16 바이트끼리 교환할 수 있다. D2D MUX(330c)는 로직 로우레벨의 제어 신호(BE_SEL)에 따라, 제1 데이터 버스의 제1 내지 제16 바이트를 제2 데이터 버스의 제1 내지 제16 바이트로 변함없는 데이터를 패스할 수 있다. D2D MUX(330c)에 의해 데이터 버스 변환이 수행된 후, 제2 데이터 버스는 데이터 버스 드라이버를 통 해 뱅크 그룹 IO(BGIO)와 결합될 수 있다. 도 9에 도시된 DRAM 다이 구성은 예로서 제공되며, 반드시 실제의 DRAM 다이 구성은 아니라는 것을 밝혀 둔다. 또한, 도 9에 도시된 예시적인 DRAM 다이 구성은 본 개시 내용에 대한 제한을 나타내거나 암시하지 않는다. 도 10은 본 발명의 실시예들에 따른 메모리 장치(220d) 내 D2D MUX(330d)의 배치를 예시적으로 설명하는 도면이 다. 도 10의 메모리 장치(220d)는 도 9의 메모리 장치(220c)와 비교하여, 프로세싱 소자들(PEs)이 뱅크들 (BANK0~BANK3) 각각에 대응하여 배치된다는 점에서 차이가 있다. 이하, 도 9와의 차이점을 중심으로 설명된다. 도 10을 참조하면, 제1 및 제2 뱅크들(BANK0, BANK1) 각각에 대응하여 제1 및 제2 PE(906a, 906b)가 개별적으 로 배치된다. 제1 PEIO 게이팅 회로(904a)는 뱅크 그룹 IO(BGIO)와 제1 뱅크(BANK0)의 뱅크 로컬 IO (BLIO)의 연결을 제어하기 위해 배치되고, 제2 PEIO 게이팅 회로(905b)는 뱅크 그룹 IO(BGIO)와 제2 뱅크(BANK1)의 뱅크 로컬 IO (BLIO)의 연결을 제어하기 위해 배치될 수 있다. D2D MUX(330d)는 제1 PE(906a)와 제1 PEIO 게이팅 회로(904a) 사이에, 그리고 제2 PE(906b)와 제2 PEIO 게이팅 회로(905b) 사이에 각각 연결될 수 있다. 제1 및 제2 PE(906a, 906b)로부터 전달되는 데이터는 제1 데이터 버스를 통해 D2D MUX(330d)로 전달될 수 있다. D2D MUX(330d)는 제어 신호(BE_SEL)에 응답하여 256 비트 입력 데이터에 대하여 2 바이트 단위로 데이터 패스 또는 변환 동작에 기반하여 데이터 버스 변환을 수행하고, 제2 데이터 버스를 통해 256 비트 출력 데이터 를 제1 및 제2 PEIO 게이팅 회로(904a, 905b)로 출력할 수 있다. D2D MUX(330d)는 앞서 설명된 도 4 및 도 5a 내지 도 5c의 D2D MUX로 구현될 수 있으며, 256 비트 입력 데이터는 16 바이트들로 분할되어 제1 데이터 버스에 실리고, 256 비트 출력 데이터는 16 바이트들로 분할 되어 제2 데이터 버스에 실릴 것이다. D2D MUX(330d)는 로직 하이레벨의 제어 신호(BE_SEL)에 따라 제1 데이터 버스와 제2 데이터 버스의 256 비트들의 16 바이트들에서 2 바이트끼리, 즉, 제1 및 제2 바이 트끼리, 제3 및 제4 바이트끼리, 제5 및 제6 바이트끼리, 제7 및 제8 바이트끼리, 제9 및 제10 바이트끼리, 제 11 및 제12 바이트끼리, 제13 및 제14 바이트끼리, 그리고 제15 및 제16 바이트끼리 교환할 수 있다. D2D MUX(330c)는 로직 로우레벨의 제어 신호(BE_SEL)에 따라, 제1 데이터 버스의 제1 내지 제16 바이트를 제2 데이터 버스의 제1 내지 제16 바이트로 변함없는 데이터를 패스할 수 있다. 도 11은 본 발명의 실시예들에 따른 메모리 장치(220d) 내 D2D MUX(330d)의 배치를 예시적으로 설명하는 도면이 다. 도 11의 메모리 장치(220d)는 단독(stand-alone) 타입의 DDR(Dual Data Rate) DRAM이고, 그 내부에 PIM 기능을 수행하는 프로세싱 소자들(PEs)를 포함할 수 있다. 도 2 및 도 11을 참조하면, 메모리 장치(220e)에서, D2D MUX(330e)는 SERDES 영역(614a)과 뱅크(BANK) 사이에 배치될 수 있다. DDR PHY 영역(616a)은 CPU로부터 4 비트 입력 데이터를 수신하여 SERDES 영역(614a)로 전달할 수 있다. DDR PHY 영역(616a)은 JEDEC 표준의 DDR 또는 LPDDR 프로토콜의 특징들을 지원할 수 있다. SERDES 영역(614a)은 DDR PHY 영역(616a)을 통해 전달되는 CPU의 4 비트 데이터를 연속적으로 수신하고, 직렬-투-병렬 회로를 통하여 32 비트 병렬 데이터로 변환하여 출력할 수 있다. SERDES 영역(614a)에서 출력되 는 32 비트 병렬 데이터는 바이트 와이드로 분할되어 제1 데이터 버스를 통해 D2D MUX(330e)으로 전달할 수 있다. D2D MUX(330e)는 제어 신호(BE_SEL)에 응답하여 32 비트 입력 데이터에 대하여 2 바이트 단위로 데이 터 패스 또는 변환 동작에 기반하여 데이터 버스 변환을 수행하고, 32 비트 출력 데이터를 출력할 수 있다. D2D MUX(330e)는 앞서 설명된 도 4 및 도 5a 내지 도 5c의 D2D MUX로 구현될 수 있으며, 32 비트 입력 데 이터는 4 바이트로 분할되어 제1 데이터 버스에 실리고, 32 비트 출력 데이터는 4 바이트로 분할되어 제2 데이터 버스에 실릴 것이다. D2D MUX(330e)는 로직 하이레벨의 제어 신호(BE_SEL)에 따라 제1 데이터 버 스와 제2 데이터 버스의 32 비트들의 4 바이트들에서 2 바이트끼리, 즉, 제1 및 제2 바이트끼리, 그 리고 제3 및 제4 바이트끼리 교환할 수 있다. D2D MUX(330e)는 로직 로우레벨의 제어 신호(BE_SEL)에 따라, 제 1 데이터 버스의 제1 내지 제4 바이트를 제2 데이터 버스의 제1 내지 제4 바이트로 변함없는 데이터 를 패스할 수 있다. D2D MUX에 의해 데이터 버스 변환이 수행된 후, 제2 데이터 버스는 뱅크(BANK)와 결합될 수 있다. 도 12는 본 발명의 실시예들에 따른 메모리 장치(220f) 내 D2D MUX(330f)의 배치를 예시적으로 설명하는 도면이 다. 도 12의 D2D MUX(330f)는 도 11의 D2D MUX(330e)와 비교하여, DDR PHY 영역(616b)과 SERDES 영역(614b) 사이에 배치된다는 점에서 차이가 있다. 이하, 도 11과의 차이점을 중심으로 설명된다. 도 2 및 도 12를 참조하면, 메모리 장치(220f)에서, DDR PHY 영역(616b)은 CPU로부터 4 비트 입력 데이터 를 수신하고 제1 데이터 버스를 통해 D2D MUX(330f)으로 전달할 수 있다. 예시적으로, 빅-엔디언 포맷의 제1 데이터 버스에서는 제1 어드레스가 제1 데이터 버스의 최상위 (most significant, 즉, 가장 왼쪽) 비트를 참조하고, 증가하는 어드레스들은 점점 하위(increasingly less significant) 비트들을 참조한다. 이에 반해, 리틀-엔디언 포맷의 제2 데이터 버스에서는 동일한 제1 어드레스가 제2 데이터 버스의 최 하위 (least significant, 즉, 가장 오른쪽) 비트를 참조하고, 증가하는 어드레스들은 점점 상위(increasingly more significant) 비트들을 참조한다. D2D MUX(330f)는, 도 13에 도시된 바와 같이, 제어 신호(BE_SEL)에 응답하여 제1 데이터 버스의 4 비트 입력 데이터에 대하여 비트 패스 또는 비트 변환 동작을 수행할 수 있다. D2D MUX(330f)는, 로직 하이레벨의 제어 신호(BE_SEL)에 따라 비트 스왑을 수행하여 제1 데이터 버스의 b3-b2-b1-b0 비트들이 b0-b1- b2-b3 비트들로 변환되어 제2 데이터 버스로 출력될 수 있다. 이에 반해, D2D MUX(330f)는, 로직 로우레 벨의 제어 신호(BE_SEL)에 따라 비트 패스를 수행하여 제1 데이터 버스의 b3-b2-b1-b0 비트들이 변 함없이 b3-b2-b1-b0 비트들로 제2 데이터 버스로 출력될 수 있다. D2D MUX(330f)에 의해 데이터 버스 변환이 수행된 후, 제2 데이터 버스는 SERDES 영역(614b)과 결합될 수 있다. SERDES 영역(614b)는 제2 데이터 버스의 4 비트 데이터를 연속적으로 수신하고, 직렬-투-병렬 회로 를 통하여 32 비트 병렬 데이터로 변환하여 출력할 수 있다. SERDES 영역(614b)에서 출력되는 32 비트 병렬 데 이터는 뱅크(BANK)와 결합될 수 있다. 본 발명은 도면에 도시된 제한된 수의 실시예들과 관련하여 설명되었으나 이는 예시적인 것에 불과하며, 본 기 술 분야의 통상의 지식을 가진 자라면 이로부터 다양한 변경들 및 변형들, 그리고 균등한 다른 실시예들이 가능 하다는 점을 인식할 것이다. 따라서, 첨부된 청구항들은 본 발명의 진정한 사상 및 범위 내에 속하는 바와 같 은 모든 그러한 변경들 및 변형들을 커버하는 것을 의도한다."}
{"patent_id": "10-2020-0059971", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 실시예에 따른 데이터 변환을 설명하는 블록 다이어그램이다. 도 2는 본 발명의 실시예에 따른 데이터 변환을 갖는 시스템의 블록 다이어그램이다. 도 3은 본 발명의 실시예들에 따른 인터페이스 회로를 설명하는 블락 다이어그램이다. 도 4는 도 3의 데이터 변환기(D2D MUX)를 구현하는 회로 다이어그램을 예시하는 도면이다. 도 5a 내지 도 5c는 도 3의 D2D MUX를 구현하는 회로 다이어그램을 예시하는 도면이다. 도 6은 본 발명의 실시예들에 따른 메모리 장치를 설명하는 도면이다.도 7은 본 발명의 실시예들에 따른 메모리 장치 내 D2D MUX의 배치를 예시적으로 설명하는 도면이다. 도 8은 본 발명의 실시예들에 따른 메모리 장치 내 D2D MUX의 배치를 예시적으로 설명하는 도면이다. 도 9는 본 발명의 실시예들에 따른 메모리 장치 내 D2D MUX의 배치를 예시적으로 설명하는 도면이다. 도 10은 본 발명의 실시예들에 따른 메모리 장치 내 D2D MUX의 배치를 예시적으로 설명하는 도면이다. 도 11은 본 발명의 실시예들에 따른 메모리 장치 내 D2D MUX의 배치를 예시적으로 설명하는 도면이다. 도 12는 본 발명의 실시예들에 따른 메모리 장치 내 D2D MUX의 배치를 예시적으로 설명하는 도면이다. 도 13은 도 12의 D2D MUX의 동작을 설명하는 도면이다."}
