{"patent_id": "10-2022-7004858", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0031115", "출원번호": "10-2022-7004858", "발명의 명칭": "에너지-효율적인 입력 피연산자 고정 가속기에서 소규모 채널 카운트 컨볼루션들을 수행하기", "출원인": "페이스북 테크놀로지스, 엘엘씨", "발명자": "벤카테쉬 가네쉬"}}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "신경망의 계층에 대한 복수의 출력들을 생성하기 위한 방법에 있어서,프로세서에 의해, 상기 신경망의 계층에 대한 복수의 출력들을 생성하기 위해 입력 데이터를 수신하는단계로서, 상기 복수의 출력들은 제1 어레이에 배열되는, 상기 입력 데이터 수신 단계;상기 프로세서에 의해, 상기 제1 어레이의 차원들을 복수의 처리 유닛(PE)들을 포함하는 상기 PE 어레이의 차원들과 비교하는 단계;상기 프로세서에 의해, 상기 비교의 결과에 따라, 상기 제1 어레이를 상기 PE 어레이의 차원들 이하의 차원들을각각 갖는 서브어레이들로 분할하는 단계; 상기 프로세서에 의해, 상기 PE 어레이의 제1 그룹의 PE들을 상기 서브어레이들 중 제1 서브어레이에 할당하는단계; 및상기 서브어레이들 중 상기 제1 서브어레이에 할당된 상기 제1 그룹의 PE들의 각각의 PE에 의해, 상기 입력 데이터의 일부를 사용하여 상기 복수의 출력들의 대응하는 출력을 생성하는 단계를 포함하는, 신경망의 계층에 대한 복수의 출력들 생성 방법."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 PE 어레이는 2차원 M × N 어레이이고, M 및 N 각각은 1보다 큰 정수이고,상기 제1 어레이의 상기 분할 단계는 상기 제1 어레이를 M × N 어레이, M × N/2 어레이, M/2 × N 어레이, 또는 M/2 × N/2 어레이 중 하나 이상으로 분할하는 단계를 포함하는, 신경망의 계층에 대한 복수의 출력들 생성방법."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,제1 차원의 상기 제1 어레이의 크기가 상기 제1 차원의 상기 PE 어레이의 크기보다 큰지 여부를 결정하는 단계;및상기 제1 차원의 상기 제1 어레이의 상기 크기가 상기 제1 차원의 상기 PE 어레이의 상기 크기보다 크다는 결정에 응답하여:상기 제1 어레이를 상기 서브어레이들 중 제1 서브어레이 및 제2 서브어레이로 분할하는 단계와;상기 제1 서브어레이를 상기 PE 어레이의 상기 제1 그룹의 PE들에, 그리고 상기 제2 서브어레이를 상기 PE 어레이의 제2 그룹의 PE들에 할당하는 단계로서, 상기 제1 차원과 상이한 제2 차원의 상기 제1 그룹의 PE들의 위치들이 상기 제2 차원의 상기 제2 그룹의 PE들의 위치들과 상이한, 상기 할당 단계를 더 포함하는, 신경망의 계층에 대한 복수의 출력들 생성 방법."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 3 항에 있어서, 상기 제1 및 제2 그룹들 모두의 PE들에 의해 사용될 상기 입력 데이터의 공통 부분을 식별하는 단계; 및상기 입력 데이터의 상기 공통 부분을 상기 제1 및 제2 그룹들의 PE들로 시프트하는 단계를 더 포함하는, 신경망의 계층에 대한 복수의 출력들 생성 방법.공개특허 10-2022-0031115-3-청구항 5 제 3 항에 있어서,상기 제1 그룹의 PE들에 의해 사용될 상기 입력 데이터의 제1 부분과, 상기 제2 그룹의 PE들에 의해 사용될 상기 입력 데이터의 제2 부분을 식별하는 단계;상기 입력 데이터의 상기 제1 부분을 상기 제1 그룹의 PE들로 시프트하는 단계; 및상기 입력 데이터의 상기 제2 부분을 상기 제2 그룹의 PE들로 시프트하는 단계를 더 포함하는, 신경망의 계층에대한 복수의 출력들 생성 방법."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1 항에 있어서,상기 복수의 출력들은 상기 신경망의 상기 계층에 대한 컨볼루션 연산들의 출력들이고;상기 입력 데이터는 제1 복수의 입력 값들 및 제2 복수의 입력 값들을 포함하고,상기 제1 그룹의 PE들의 각각의 PE에 의해, 상기 복수의 출력들의 대응하는 출력을 생성하는 단계는:상기 각각의 PE에 의해, 상기 제1 복수의 입력 값들의 제1 값들 및 상기 제2 복수의 입력 값들의 제2 값들을 수신하는 단계;상기 각각의 PE에 의해, 상기 제1 값들 및 상기 제2 값들을 상기 각각의 PE의 제1 버퍼 메모리 및 제2 버퍼 메모리에 각각 저장하는 단계; 및상기 각각의 PE의 곱셈기 및 누산기(MAC: multiplier and accumulator) 회로에 의해, 상기 제1 값들과 상기 제2 값들의 제1 내적(dot product)을 생성하는 단계를 포함하고;상기 제1 복수의 입력 값들은 상기 신경망의 상기 계층에 대한 입력 데이터 스트림들 및 가중치들 중 하나를 나타내고,상기 제2 복수의 입력 값들은 상기 신경망의 상기 계층에 대한 입력 데이터 스트림들 및 가중치들 중 다른 하나를 나타내는, 신경망의 계층에 대한 복수의 출력들 생성 방법."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 6 항에 있어서,상기 제1 복수의 입력 값들 중 제1 수의 세트들의 값들이 상기 각각의 PE의 상기 제1 버퍼 메모리에 저장되고,(ⅰ) 상기 각각의 PE의 상기 제1 버퍼 메모리에 저장된 상기 제1 수의 세트들의 값들의 각각과 (ⅱ) 상기 각각의 PE의 상기 제2 버퍼 메모리에 저장된 상기 제2 값들의 내적이 상기 MAC 회로에 의해 계산되고, 제1 수의 계산된 내적들이 상기 신경망의 상기 계층에 대한 컨볼루션 연산들의 출력들인, 신경망의 계층에 대한복수의 출력들 생성 방법."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 6 항에 있어서,상기 복수의 제2 입력 값들 중 제2 수의 세트들의 값들이 상기 각각의 PE의 상기 제2 버퍼 메모리에 저장되고,(ⅰ) 상기 각각의 PE의 상기 제1 버퍼 메모리에 저장된 상기 제1 값들과 (ⅱ) 상기 각각의 PE의 상기 제2 버퍼메모리에 저장된 상기 제2 수의 세트들의 값들의 각각의 내적이 상기 MAC 회로에 의해 계산되고,제2 수의 계산된 내적들이 상기 신경망의 상기 계층에 대한 컨볼루션 연산들의 출력들인, 신경망의 계층에 대한복수의 출력들 생성 방법."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "신경망의 계층에 대한 복수의 출력들을 생성하기 위한 디바이스에 있어서,공개특허 10-2022-0031115-4-프로세서; 및복수의 PE들을 포함하는 처리 유닛(PE) 어레이를 포함하고, 상기 프로세서는:신경망의 계층에 대한 복수의 출력들을 생성하기 위해 입력 데이터를 수신하는 것으로서, 상기 복수의 출력들은제1 어레이에 배열되는, 상기 입력 데이터를 수신하고;상기 제1 어레이의 차원들을 상기 PE 어레이의 차원들과 비교하고;상기 비교의 결과에 따라, 상기 제1 어레이를 상기 PE 어레이의 차원들 이하의 차원들을 각각 갖는 서브어레이들로 분할하고; 상기 PE 어레이의 제1 그룹의 PE들을 상기 서브어레이들 중 제1 서브어레이에 할당하도록 구성되고;상기 서브어레이들 중 상기 제1 서브어레이에 할당된 상기 제1 그룹의 PE들의 각각의 PE는, 상기 입력 데이터의일부를 사용하여 상기 복수의 출력들의 대응하는 출력을 생성하도록 구성되는, 신경망의 계층에 대한 복수의 출력들 생성 디바이스."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 9 항에 있어서,상기 PE 어레이는 2차원 M × N 어레이이고, M 및 N 각각은 1보다 큰 정수이고,상기 프로세서는 상기 제1 어레이를 M × N 어레이, M × N/2 어레이, M/2 × N 어레이, 또는 M/2 × N/2 어레이 중 하나 이상으로 분할하도록 구성되는, 신경망의 계층에 대한 복수의 출력들 생성 디바이스."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 9 항에 있어서,상기 프로세서는, 제1 차원의 상기 제1 어레이의 크기가 상기 제1 차원의 상기 PE 어레이의 크기보다 큰지 여부를 결정하도록 구성되고,상기 제1 차원의 상기 제1 어레이의 상기 크기가 상기 제1 차원의 상기 PE 어레이의 상기 크기보다 크다는 결정에 응답하여, 상기 프로세서는:상기 제1 어레이를 상기 서브어레이들 중 제1 서브어레이 및 제2 서브어레이로 분할하고;상기 제1 서브어레이를 상기 PE 어레이의 상기 제1 그룹의 PE들에 할당하고 상기 제2 서브어레이를 상기 제1 그룹의 PE들과 상이한 상기 PE 어레이의 제2 그룹의 PE들에 할당하도록 구성되는, 신경망의 계층에 대한 복수의출력들 생성 디바이스."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 11 항에 있어서, 상기 프로세서는:상기 제1 및 제2 그룹들 모두의 PE들에 의해 사용될 상기 입력 데이터의 공통 부분을 식별하고;상기 입력 데이터의 상기 공통 부분을 상기 제1 및 제2 그룹들의 PE들로 시프트하도록 추가로 구성되는, 신경망의 계층에 대한 복수의 출력들 생성 디바이스."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 11 항에 있어서, 상기 프로세서는: 상기 제1 그룹의 PE들에 의해 사용될 상기 입력 데이터의 제1 부분과, 상기 제2 그룹의 PE들에 의해 사용될 상기 입력 데이터의 제2 부분을 식별하고;상기 입력 데이터의 상기 제1 부분을 상기 제1 그룹의 PE들로 시프트하고;상기 입력 데이터의 상기 제2 부분을 상기 제2 그룹의 PE들로 시프트하도록 추가로 구성되는, 신경망의 계층에대한 복수의 출력들 생성 디바이스.공개특허 10-2022-0031115-5-청구항 14 제 9 항에 있어서, 상기 복수의 출력들은 상기 신경망의 상기 계층에 대한 컨볼루션 연산들의 출력들이고;상기 입력 데이터는 제1 복수의 입력 값들 및 제2 복수의 입력 값들을 포함하고,상기 제1 그룹의 PE들의 각각의 PE는 제1 버퍼 메모리, 제2 버퍼 메모리 및 곱셈기 및 누산기(MAC) 회로를 포함하고,상기 복수의 출력들의 대응하는 출력을 생성할 때, 상기 제1 그룹의 PE들의 각각의 PE는:상기 제1 복수의 입력 값들의 제1 값들 및 상기 제2 복수의 입력 값들의 제2 값들을 수신하고;상기 제1 값들 및 상기 제2 값들을 상기 제1 버퍼 메모리 및 상기 제2 버퍼 메모리에 각각 저장하고;상기 MAC 회로를 통해, 상기 제1 값들과 상기 제2 값들의 제1 내적을 생성하도록 구성되고;상기 제1 복수의 입력 값들은 상기 신경망의 상기 계층에 대한 입력 데이터 스트림들 및 가중치들 중 하나를 나타내고,상기 제2 복수의 입력 값들은 상기 신경망의 상기 계층에 대한 입력 데이터 스트림들 및 가중치들 중 다른 하나를 나타내는, 신경망의 계층에 대한 복수의 출력들 생성 디바이스."}
{"patent_id": "10-2022-7004858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 14 항에 있어서, 상기 각각의 PE는:상기 복수의 제1 입력 값들 중 제1 수의 세트들의 값들을 상기 제1 버퍼 메모리에 저장하고,상기 MAC 회로를 통해, (ⅰ) 상기 제1 버퍼 메모리에 저장된 상기 제1 수의 세트들의 값들의 각각과 (ⅱ) 상기제2 버퍼 메모리에 저장된 상기 제2 값들의 내적을 계산하고, 제1 수의 계산된 내적들이 상기 신경망의 상기 계층에 대한 컨볼루션 연산들의 출력들로서 출력되도록구성되는, 신경망의 계층에 대한 복수의 출력들 생성 디바이스."}
{"patent_id": "10-2022-7004858", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 명세서의 개시내용은 신경망의 계층에 대한 복수의 출력들을 생성하기 위해 입력 데이터를 수신하기 위한 시 스템, 방법, 및 디바이스를 포함한다. 복수의 출력들은 제1 어레이에 배열된다. 제1 어레이의 차원들은 복수의 PE들을 포함하는 처리 유닛(PE) 어레이의 차원들과 비교될 수 있다. 비교 결과에 따르면, 제1 어레이는 프로세서 에 의해 서브어레이들로 분할된다. 각각의 서브어레이들은 PE 어레이의 차원들 이하인 차원들을 갖는다. PE 어레 이의 제1 그룹의 PE들은 서브어레이들 중 제1 서브어레이에 할당된다. 복수의 출력들의 대응하는 출력은 서브어 레이들 중 제1 서브어레이에 할당된 제1 그룹의 PE들의 각각의 PE에 의한 입력 데이터의 일부를 사용하여 생성된 다."}
{"patent_id": "10-2022-7004858", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 일반적으로, 출력들의 어레이를 서브어레이들로 분할하고 처리 요소들을 서브어레이들 중 하나에 할 당함으로써 출력들을 생성하기 위한 시스템 및 방법을 포함하지만 이에 제한되지 않는, 신경망의 계층에 대한 출력들을 생성하기 위한 시스템 및 방법에 관한 것이다."}
{"patent_id": "10-2022-7004858", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공 지능(AI: artificial intelligence) 가속기들에서 한 가지 과제는 신경망에 대한 AI 처리를 수행할 때 전 력 소비를 제어하거나 줄이는 것과 관련이 있다. 예를 들어, 신경망은 컨볼루션 계층들을 포함할 수 있는 컨볼 루션 신경망일 수 있다. 컨볼루션 계층에서, AI 가속기는 기존의 완전 연결 피드포워드 신경망에 비해 파라미터 들의 수를 줄이는 방식으로 입력 계층에 컨볼루션 연산을 적용하여 결과를 다음 계층으로 전달할 수 있다. 그러 나 점점 더 복잡한 다차원(예를 들어, 다중 채널들) 입력/출력 구조들이 컨볼루션 신경망에서 사용됨에 따라, 에너지 및 대기시간을 줄이는 방법들이 바람직할 수 있다. 또한, 입력 데이터 및 커널들을 사용하여 컨볼루션 연산을 수행할 때 처리 범위의 관점에서, 중복 연산들을 피하는 것이 바람직할 수 있다. 본 발명에 따르면 신경망의 계층에 대한 복수의 출력들을 생성하기 위한 디바이스가 제공되며, 이 디바이스는 프로세서, 및 복수의 PE들을 포함하는 처리 유닛(PE) 어레이를 포함하고, 프로세서는: 신경망의 계층에 대한 복 수의 출력들을 생성하기 위해 입력 데이터를 수신하고, 상기 복수의 출력들은 제1 어레이에 배열되고; 제1 어레 이의 차원들을 상기 PE 어레이의 차원들과 비교하고; 비교의 결과에 따라, 제1 어레이를 PE 어레이의 차원들 이하의 차원들을 각각 갖는 서브어레이들로 분할하고; PE 어레이의 제1 그룹의 PE들을 서브어레이들 중 제1 서브 어레이에 할당하도록 구성되고; 서브어레이들 중 제1 서브어레이에 할당된 제1 그룹의 PE들의 각각의 PE는, 입 력 데이터의 일부를 사용하여 복수의 출력들의 대응하는 출력을 생성하도록 구성된다. 일부 실시예들에서, PE 어레이는 2차원 M × N 어레이일 수 있다. M 및 N 각각은 1보다 큰 정수이다. 프로세서 는 제1 어레이를 M × N 어레이, M × N/2 어레이, M/2 × N 어레이, 또는 M/2 × N/2 어레이 중 하나 이상으로 분할하도록 구성될 수 있다. 일부 실시예들에서, 프로세서는, 제1 차원의 제1 어레이의 크기가 제1 차원의 PE 어레이의 크기보다 큰지 여부 를 결정하도록 구성될 수 있다. 제1 차원의 제1 어레이의 크기가 제1 차원의 PE 어레이의 크기보다 크다는 결정 에 응답하여, 프로세서는 제1 어레이를 서브어레이들 중 제1 서브어레이 및 제2 서브어레이로 분할하도록 구성 될 수 있다. 프로세서는 제1 서브어레이를 PE 어레이의 제1 그룹의 PE들에 할당하고 제2 서브어레이를 제1 그룹 의 PE들과 상이한 PE 어레이의 제2 그룹의 PE들에 할당하도록 구성될 수 있다. 일부 실시예들에서, 프로세서는 제1 및 제2 그룹들 모두의 PE들에 의해 사용될 입력 데이터의 공통 부분을 식별 하도록 추가로 구성될 수 있다. 프로세서는 입력 데이터의 공통 부분을 복수의 PE들의 적어도 일부를 통해 제1 및 제2 그룹들의 PE들로 시프트하도록 추가로 구성될 수 있다. 일부 실시예들에서, 프로세서는 제1 그룹의 PE들에 의해 사용될 입력 데이터의 제1 부분과, 제2 그룹의 PE들에 의해 사용될 입력 데이터의 제2 부분을 식별하도록 추가로 구성될 수 있다. 프로세서는 입력 데이터의 제1 부분 을 제1 차원을 따라 제1 그룹의 PE들로 시프트하도록 추가로 구성될 수 있다. 프로세서는 입력 데이터의 제2 부 분을 제1 차원을 따라 제2 그룹의 PE들로 시프트하도록 추가로 구성될 수 있다. 일부 실시예들에서, 복수의 출력들은 신경망의 계층에 대한 컨볼루션 연산들의 출력들일 수 있다. 일부 실시예들에서, 입력 데이터는 제1 복수의 입력 값들 및 제2 복수의 입력 값들을 포함할 수 있다. 제1 그룹 의 PE들의 각각의 PE는 제1 버퍼 메모리, 제2 버퍼 메모리 및 곱셈기 및 누산기(MAC: multiplier and accumulator) 회로를 포함할 수 있다. 복수의 출력들의 대응하는 출력을 생성할 때, 제1 그룹의 PE들의 각각의 PE는 제1 복수의 입력 값들의 제1 값들 및 제2 복수의 입력 값들의 제2 값들을 수신하도록 구성될 수 있다. 제1 그룹의 PE들의 각각의 PE는 제1 값들 및 제2 값들을 제1 버퍼 메모리 및 제2 버퍼 메모리에 각각 저장하도록 구 성될 수 있다. 제1 그룹의 PE들의 각각의 PE는 MAC 회로를 통해, 제1 값들과 제2 값들의 제1 내적(dot produc t)을 생성하도록 구성될 수 있다. 일부 실시예들에서, 각각의 PE는 제1 버퍼 메모리에 복수의 제1 입력 값들 중에서 제1 수의 세트들의 값들을 저 장하도록 구성될 수 있다. 각각의 PE는 MAC 회로를 통해 (ⅰ) 제1 버퍼 메모리에 저장된 제1 수의 세트들의 값 들의 각각과 (ⅱ) 제2 버퍼 메모리에 저장된 제2 값들의 내적을 계산하도록 구성될 수 있다. 각각의 PE는 제1 수의 계산된 내적들을 신경망의 계층에 대한 컨볼루션 연산들의 출력들로서 출력하도록 구성될 수 있다. 각각의 PE는 제2 버퍼 메모리에 복수의 제2 입력 값들 중에서 제2 수의 세트들의 값들을 저장하도록 구성될 수 있다. 각각의 PE는 MAC 회로를 통해 (ⅰ) 제1 버퍼 메모리에 저장된 제1 값들과 (ⅱ) 제2 버퍼 메모리에 저장된 제2 수의 세트들의 값들 각각의 내적을 계산하도록 구성될 수 있다. 각각의 PE는 제2 수의 계산된 내적들을 신 경망의 계층에 대한 컨볼루션 연산들의 출력들로서 출력하도록 구성될 수 있다. 일부 실시예들에서, 제1 복수의 입력 값들은 신경망의 계층에 대한 입력 데이터 스트림들 및 가중치들 중 하나 를 나타낼 수 있다. 제2 복수의 입력 값들은 신경망의 계층에 대한 입력 데이터 스트림들 및 가중치들 중 다른 하나를 나타낼 수 있다. 본 발명에 따르면, 신경망의 계층에 대한 복수의 출력들을 생성하기 위한 방법이 제공되며, 상기 방법은 프로세 서에 의해, 신경망의 계층에 대한 복수의 출력들을 생성하기 위해 입력 데이터를 수신하는 단계로서, 복수의 출 력들은 제1 어레이에 배열되는, 상기 데이터 수신 단계; 프로세서에 의해, 제1 어레이의 차원들을 복수의 PE들 을 포함하는 처리 유닛(PE) 어레이의 차원들과 비교하는 단계; 프로세서에 의해 비교의 결과에 따라, 제1 어레 이를 PE 어레이의 차원들 이하의 차원들을 각각 갖는 서브어레이들로 분할하는 단계; 프로세서에 의해, PE 어레 이의 제1 그룹의 PE들을 서브어레이들 중 제1 서브어레이에 할당하는 단계; 및 서브어레이들 중 제1 서브어레이 에 할당된 제1 그룹의 PE들의 각각의 PE에 의해, 입력 데이터의 일부를 사용하여 복수의 출력들의 대응하는 출 력을 생성하는 단계를 포함한다. 일부 실시예들에서, PE 어레이는 2차원 M × N 어레이일 수 있다. M 및 N 각각은 1보다 큰 정수일 수 있다. 제1 어레이를 분할할 때, 제1 어레이는 M × N 어레이, M × N/2 어레이, M/2 × N 어레이, 또는 M/2 × N/2 어레이 중 하나 이상으로 분할될 수 있다. 일부 실시예들에서, 제1 차원의 제1 어레이의 크기가 제1 차원의 PE 어레이의 크기보다 큰지 여부가 결정될 수 있다. 제1 차원의 제1 어레이의 크기가 제1 차원의 PE 어레이의 크기보다 크다는 결정에 응답하여, 제1 어레이 는 서브어레이들 중 제1 서브어레이 및 제2 서브어레이로 분할될 수 있다. 제1 서브어레이는 PE 어레이의 제1 그룹의 PE들에 할당하고 제2 서브어레이는 PE 어레이의 제2 그룹의 PE들에 할당될 수 있다. 제1 차원과 상이한 제2 차원의 제1 그룹의 PE들의 위치들은 제2 차원의 제2 그룹의 PE들의 위치들과 상이할 수 있다. 일부 실시예들에서, 제1 및 제2 그룹들 모두의 PE들에 의해 사용될 입력 데이터의 공통 부분이 식별될 수 있다. 입력 데이터의 공통 부분은 복수의 PE들의 적어도 일부를 통해 제1 및 제2 그룹들의 PE들로 시프트될 수 있다. 일부 실시예들에서, 제1 그룹의 PE들에 의해 사용될 입력 데이터의 제1 부분이 식별될 수 있고, 제2 그룹의 PE 들에 의해 사용될 입력 데이터의 제2 부분이 식별될 수 있다. 입력 데이터의 제1 부분은 제1 차원을 따라 제1 그룹의 PE들을 통해 시프트될 수 있다. 입력 데이터의 제2 부분은 제1 차원을 따라 제2 그룹의 PE들을 통해 시 프트될 수 있다. 일부 실시예들에서, 복수의 출력들은 신경망의 계층에 대한 컨볼루션 연산들의 출력들일 수 있다. 일부 실시예들에서, 입력 데이터는 제1 복수의 입력 값들 및 제2 복수의 입력 값들을 포함할 수 있다. 제1 그룹 의 PE들의 각각의 PE에 의해 복수의 출력들의 대응하는 출력을 생성할 때, 제1 복수의 입력 값들의 제1 값들 및 제2 복수의 입력 값들의 제2 값들이 상기 각각의 PE에 의해 수신될 수 있다. 제1 값들 및 제2 값들은 각각의 PE 에 의해 상기 각각의 PE의 제1 버퍼 메모리 및 제2 버퍼 메모리에 각각 저장될 수 있다. 제1 값들과 제2 값들의 제1 내적은 각각의 PE의 곱셈기 및 누산기(MAC) 회로에 의해 생성될 수 있다. 일부 실시예들에서, 제1 복수의 입력 값들 중에서 제1 수의 세트들의 값들이 각각의 PE의 제1 버퍼 메모리에 저 장될 수 있다. (ⅰ) 각각의 PE의 제1 버퍼 메모리에 저장된 제1 수의 세트들의 값들의 각각과 (ⅱ) 각각의 PE의 제2 버퍼 메모리에 저장된 제2 값들의 내적이 MAC 회로를 통해 계산될 수 있다. 제1 수의 계산된 내적들은 신경 망의 계층에 대한 컨볼루션 연산들의 출력들일 수 있다. 일부 실시예들에서, 복수의 제2 입력 값들 중에서 제2 수의 세트들의 값들이 각각의 PE의 제2 버퍼 메모리에 저 장될 수 있다. (ⅰ) 상기 각각의 PE의 제1 버퍼 메모리에 저장된 제1 값들과 (ⅱ) 각각의 PE의 제2 버퍼 메모리 에 저장된 제2 수의 세트들의 값들 각각의 내적이 MAC 회로를 통해 계산될 수 있다. 제1 내적 및 제2수의 계산 된 내적들은 신경망의 계층에 대한 컨볼루션 연산들의 출력들일 수 있다. 일부 실시예들에서, 제1 복수의 입력 값들은 신경망의 계층에 대한 입력 데이터 스트림들 및 가중치들 중 하나 를 나타낼 수 있다. 제2 복수의 입력 값들은 신경망의 계층에 대한 입력 데이터 스트림들 및 가중치들 중 다른 하나를 나타낼 수 있다. 이들 및 다른 양태들 및 구현들이 하기에 상세히 논의된다. 전술한 정보 및 다음의 상세한 설명은 다양한 양태 들 및 구현들의 예시적인 예들을 포함하고, 청구된 양태들 및 구현들의 특징 및 특성을 이해하기 위한 개요 또 는 체계를 제공한다. 도면들은 다양한 양태들 및 구현들에 대한 예시와 추가적인 이해를 제공하고, 본 명세서에 통합되고 본 명세서의 일부를 구성한다. 첨부된 도면들은 축척하여 그리려는 의도가 아니다. 다양한 도면들에서 동일한 참조 번호들 및 명칭들은 동일한 요소들을 나타낸다. 명확성을 위해 모든 도면에서 모든 구성요소에 라벨을 붙일 수 있는 것은 아니다."}
{"patent_id": "10-2022-7004858", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "특정 실시예들을 상세히 예시하는 도면들로 돌아가기 전에, 본 개시내용은 설명에 제시되거나 도면들에 예시된 세부사항들 또는 방법에 제한되지 않음을 이해해야 한다. 또한, 본 명세서에서 사용된 용어는 단지 설명의 목적 을 위한 것이며 제한적인 것으로 간주되어서는 안됨을 이해해야 한다. 하기에 본 발명의 다양한 실시예들의 설명을 읽을 목적으로, 명세서의 섹션들 및 각각의 내용들에 대한 다음 설 명이 도움이 될 수 있다: - 섹션 A는 본 시스템들, 방법들 및 디바이스들의 실시예를 실행하거나 구현하는데 유용한 환경, 시스템, 구성 및/또는 기타 양태들을 설명하고; - 섹션 B는 신경망의 계층에 대한 복수의 출력들을 생성하기 위한 디바이스들, 시스템들 및 방법들의 실시예들 을 설명한다. A. 인공지능 관련 처리를 위한 환경 섹션 B에서 시스템들, 디바이스들 및/또는 방법들의 실시예들의 세부사항들을 논의하기 전에, 시스템들, 디바이 스들 및/또는 방법들의 특정 실시예들을 실행하거나 구현하는데 유용한 환경들, 시스템들, 구성들 및/또는 기타 양태들을 논의하는 것이 도움이 될 수 있다. 이제 도 1a를 참조하면, 인공 지능(AI) 관련 처리를 수행하기 위한 시스템의 실시예가 도시된다. 간략한 개요에서, 시스템은 입력 데이터를 사용하여 AI 관련 처리를 수행할 수 있는 하나 이상의 AI 가속기들을 포함한다. AI 가속기로 언급되지만, 때때로 신경망 가속기(NNA: neural network accelerator), 신경망 칩 또는 하드웨어, AI 프로세서, AI 칩 등으로 지칭된다. AI 가속기 (들)는 AI 관련 처리를 수행하여 입력 데이터 및/또는 파라미터(예를 들어, 가중치 및/또는 바 이어스 정보)에 따라 출력 데이터를 출력하거나 제공할 수 있다. AI 가속기는 하나 이상의 신경망들 (예를 들어, 인공 신경망들), 하나 이상의 프로세서(들) 및/또는 하나 이상의 저장 디바이스들을 포함 및/또는 구현할 수 있다. 위에서 언급한 소자들 또는 구성요소들 각각은 하드웨어 또는 하드웨어와 소프트웨어의 조합으로 구현된다. 예 를 들어, 이러한 소자들 또는 구성요소들 각각은 디지털 및/또는 아날로그 소자들(예를 들어, 하나 이상의 트랜 지스터들, 논리 게이트들, 레지스터들, 메모리 디바이스들, 저항 소자들, 도전 소자들, 용량 소자들)을 포함할 수 있는 회로와 같이 하드웨어 상에서 실행되는 임의의 애플리케이션, 프로그램, 라이브러리, 스크립트, 작업, 서비스, 프로세스 또는 임의의 타입 및 형태의 실행 가능한 명령을 포함할 수 있다. 입력 데이터는 AI 가속기(들)의 신경망을 구성, 조정, 훈련 및/또는 활성화하기 위한 및/또는 프로세서(들)에 의해 처리하기 위한 임의의 타입 또는 형태의 데이터를 포함할 수 있다. 신경망은 때 때로 인공 신경망(ANN)으로 지칭된다. 신경망을 구성, 조정 및/또는 훈련하는 것은 이력 데이터와 같은 훈련 데 이터 세트들(예를 들어, 입력 데이터로서)이 처리를 위해 신경망에 제공되는 기계 학습 프로세스를 참조하 거나 포함할 수 있다. 조정 또는 구성은 신경망이 정확도를 향상시킬 수 있도록 신경망의 훈련 또는 처리 를 참조하거나 포함할 수 있다. 신경망을 조정하거나 구성하는 것은 예를 들어 신경망에 대해 원하는 타입의 문제 또는 목표에 대해 성공적인 것으로 입증된 아키텍처들을 사용하여 신경망을 설계, 형성, 구축, 합 성 및/또는 설정하는 것을 포함할 수 있다. 일부 경우에, 하나 이상의 신경망들이 동일하거나 유사한 기준 선 모델에서 개시할 수 있지만, 조정, 훈련 또는 학습 프로세스 동안, 신경망들의 결과들이 충분히 상이할수 있어서, 각각의 신경망은, 기준선 모델에 있거나 상이한 목표 또는 목적을 위해 조정되거나 훈련되는 상이한 신경망과 비교하여 더 높은 레벨의 정확도와 신뢰도로 특정 타입의 입력을 처리하고 특정 타입의 출력을 생성하도록 조정될 수 있다. 신경망을 조정하는 것은 각각의 신경망에 대해 상이한 파라미터들 을 설정하는 것, 각각의 신경망에 대해 상이하게 파라미터들을 미세-조정하는 것, 또는 상이한 가중 치들(예를 들어, 하이퍼파라미터들 또는 학습률들), 텐서 흐름들(tensor flows) 등을 할당하는 것을 포함할 수 있다. 따라서, 신경망(들) 및/또는 시스템의 조정 및 훈련 프로세스와 목표에 기초하여 신경망(들)에 대해 적절한 파라미터들을 설정하는 것은 전체 시스템의 성능을 개선할 수 있다. AI 가속기의 신경망은, 예를 들어, 컨볼루션 신경망(CNN), 딥 컨볼루션 신경망, 피드 포워드 신경망 (예를 들어, 다중 계층 퍼셉트론(MLP: multilayer perceptron)), 딥 피드 포워드 신경망, 방사형 기저 기능 신 경망, 코호넨 자기-조직 신경망(Kohonen self-organizing neural network), 순환 신경망, 모듈식 신경망, 장기 /단기 기억 신경망 등을 포함하는 임의의 타입의 신경망을 포함할 수 있다. 신경망(들)은 자연어 처리와 같이, 데이터(예를 들어, 이미지, 오디오, 비디오) 처리, 객체 또는 특징 인식, 추천 기능들, 데이터 또는 이미 지 분류, 데이터(예를 들어, 이미지) 분석 등을 수행하기 위해 배포되거나 사용된다. 예로서, 및 하나 이상의 실시예들에서, 신경망은 컨볼루션 신경망으로 구성되거나 이를 포함할 수 있다. 컨볼루션 신경망은 각각 상이한 목적을 수행할 수 있는 하나 이상의 컨볼루션 셀들(또는 풀링 계층들)과 커널들 을 포함할 수 있다. 컨볼루션 신경망은 컨볼루션 커널(때로 간단히 \"커널(kernel)\"로 지칭됨)을 포함, 통합 및/ 또는 사용할 수 있다. 컨볼루션 커널은 입력 데이터를 처리할 수 있고 풀링 계층들은 예를 들어 최대값과 같은 비선형 함수들을 사용하여 데이터를 단순화함으로써 불필요한 특징들을 줄일 수 있다. 컨볼루션 신경망을 포함 하는 신경망은 이미지, 오디오 또는 임의의 데이터 인식 또는 기타 처리를 용이하게 할 수 있다. 예를 들 어, 입력 데이터(예를 들어, 센서로부터)는 커널을 형성하는 컨볼루션 신경망의 컨볼루션 계층들로 전달되 어 입력 데이터에서 검출된 특징을 압축할 수 있다. 컨볼루션 신경망의 제1 계층은 제1 특성들, 제2 계층 은 제2 특성들 등을 검출할 수 있다. 컨볼루션 신경망은 시각적 이미지, 오디오 정보, 및/또는 임의의 다른 타입 또는 형태의 입력 데이터를 분 석하도록 구성된 일종의 딥 피드-포워드 인공 신경망일 수 있다. 컨볼루션 신경망은 최소한의 전처리를 사용하 도록 설계된 다중 계층 퍼셉트론들을 포함할 수 있다. 컨볼루션 신경망은 공유-가중치 아키텍처 및 변환 불변 특성들(translation invariance characteristics)에 기초하여 시프트 불변 또는 공간 불변 인공 신경망들을 포 함하거나 이를 참조할 수 있다. 컨볼루션 신경망들이 다른 데이터 분류/처리 알고리즘들에 비해 상대적으로 전 처리를 덜 사용하기 때문에, 컨볼루션 신경망은 다른 데이터 분류/처리 알고리즘들을 위해 수동-조작(hand- engineered)될 수 있는 필터들을 자동으로 학습할 수 있어, 신경망을 구성, 확립 또는 설정하는 것과 연관 된 효율성을 개선할 수 있음으로써, 다른 데이터 분류/처리 기술들에 비해 기술적 이점을 제공한다. 신경망은 뉴런들 또는 노드들의 입력층 및 출력층을 포함할 수 있다. 신경망은 또한 뉴런 들 또는 노드들의 컨볼루션 계층들, 풀링 계층들, 완전 연결 계층들, 및/또는 정규화 계층들을 포함할 수 있는 하나 이상의 은닉 계층들(118, 119)을 가질 수 있다. 신경망에서, 각각의 뉴런은 이전 계층의 몇몇 위치들 로부터 입력을 수신할 수 있다. 완전 연결 계층에서, 각각의 뉴런은 이전 계층의 모든 요소로부터 입력을 수신 할 수 있다. 신경망에서 각각의 뉴런은 이전 계층의 수신 필드로부터 나오는 입력 값들에 일부 함수를 적용함으로써 출 력 값을 계산할 수 있다. 입력 값들에 적용되는 함수는 가중치 벡터와 바이어스(통상적으로 실수)에 의해 지정 된다. 신경망에서의 학습(예를 들어, 훈련 단계 동안)은 바이어스들 및/또는 가중치들을 점진적으로 조정 함으로써 진행될 수 있다. 가중치 벡터 및 바이어스는 필터로 칭해질 수 있고 입력의 일부 특징(예를 들어, 특 정 형상)을 나타낼 수 있다. 컨볼루션 신경망들의 두드러진 특징은 많은 뉴런들이 동일한 필터를 공유할 수 있 다는 점이다. 이는, 각각의 수신 필드에 자체 바이어스 및 가중치 벡터가 있는 것이 아니라 단일 바이어스 및 단일 가중치 벡터가 그 필터를 공유하는 모든 각각의 필드들에 걸쳐 이용될 수 있기 때문에 메모리 풋프린트를 감소시킨다. 예를 들어, 컨볼루션 계층에서, 시스템은 입력 계층에 컨볼루션 연산을 적용하여 결과를 다음 계층으로 전 달할 수 있다. 컨볼루션은 입력 자극에 대한 개별 뉴런의 응답을 에뮬레이트한다(emulates). 각각의 컨볼루션 뉴런은 수신 필드에 대한 데이터만 처리할 수 있다. 컨볼루션 연산을 사용하면 완전 연결 피드포워드 신경망과 비교하여 신경망에서 사용되는 뉴런들의 수를 줄일 수 있다. 따라서 컨볼루션 연산은 자유 파라미터들의 수를 줄여 신경망이 더 적은 파라미터들로 더 심화되도록 할 수 있다. 예를 들어, 입력 데이터(예를 들어, 이미지 데이터) 크기에 관계없이, 동일한 공유 가중치들을 각각 갖는 5 × 5 크기의 타일링 영역들은 25개의 학습 가능한 파라미터들만 사용할 수 있다. 이러한 방식으로, 컨볼루션 신경망을 갖는 제1 신경망은 역전파 (backpropagation)를 사용하여 많은 계층들을 갖는 통상적인 다층 신경망들을 훈련할 때 소멸하는 또는 폭발하 는 그라디언트 문제를 해결할 수 있다. 신경망(예를 들어, 컨볼루션 신경망으로 구성)은 하나 이상의 풀링 계층들을 포함할 수 있다. 하나 이상의 풀링 계층들은 로컬 풀링 계층들 또는 글로벌 풀링 계층들을 포함할 수 있다. 풀링 계층들은 한 계층의 뉴런 클 러스터들의 출력들을 다음 계층의 단일 뉴런에 결합할 수 있다. 예를 들어, 최대 풀링은 이전 계층의 뉴런 클러 스터 각각으로부터 최대값을 사용할 수 있다. 다른 예는 평균 풀링(average pooling)이며, 이전 계층의 뉴런 클 러스터 각각으로부터 평균값을 사용할 수 있다. 신경망(예를 들어, 컨볼루션 신경망으로 구성)은 완전 연결 계층들을 포함할 수 있다. 완전 연결 계층들은 한 계층의 모든 뉴런을 다른 계층의 모든 뉴런에 연결할 수 있다. 신경망은 컨볼루션 계층들에서 공유된 가중치들로 구성될 수 있으며, 이는 계층의 각각의 수신 필드에 사용되는 동일한 필터를 의미할 수 있으므로 메 모리 풋프린트를 줄이고 제1 신경망의 성능을 개선할 수 있다. 은닉 계층들(118, 119)은 입력 데이터(예를 들어, 가상 현실 시스템으로부터의 센서 데이터)에 기초하여 정보를 검출하도록 조정되거나 구성된 필터들을 포함할 수 있다. 시스템이 신경망(예를 들어, 컨볼루션 신경망)의 각각의 계층을 차근차근 통과함에 따라, 시스템은 제1 계층으로부터의 입력을 변환하고 변환된 입력을 제2 계층 등으로 출력할 수 있다. 신경망은 검출, 처리 및/또는 계산되는 객체 또는 정보의 타입과 입력 데이터 의 타입에 기초하여 하나 이상의 은닉층들(118, 119)을 포함할 수 있다. 일부 실시예들에서, 컨볼루션 계층은 신경망(예를 들어, CNN으로 구성)의 코어 빌딩 블록이다. 계층의 파 라미터들은, 작은 수신 필드를 갖지만 입력 볼륨의 전체 깊이를 통해 확장되는 학습 가능한 필터들(또는 커널들)의 세트를 포함할 수 있다. 순방향 통과 동안, 각각의 필터는 입력 볼륨의 너비와 높이에 걸쳐 컨볼루션 되어 필터의 엔트리들과 입력 사이의 내적을 계산하고 그 필터의 2차원 활성화 맵을 생성한다. 결과적으로, 신 경망은 입력의 어떤 공간적 위치에서 어떤 특정한 타입의 특징을 검출할 때 활성화되는 필터들을 학습할 수 있다. 깊이 차원을 따라 모든 필터들에 대한 활성화 맵들을 적층하면 컨볼루션 계층의 전체 출력 볼륨을 형 성한다. 따라서 출력 볼륨의 모든 엔트리는, 입력의 작은 영역을 보고 동일한 활성화 맵의 뉴런들과 파라미터들 을 공유하는 뉴런의 출력으로 해석될 수도 있다. 컨볼루션 계층에서 뉴런들은 이전 계층의 제한된 하위 영역에 서 입력을 수신할 수 있다. 통상적으로 하위 영역은 정사각형 모양이다(예를 들어, 크기 5 × 5). 뉴런의 입력 영역은 수신 필드로 칭해진다. 따라서 완전 연결 계층에서 수신 필드는 전체 이전 계층이다. 컨볼루션 계층에서 수신 영역은 전체 이전 계층보다 작을 수 있다. 제1 신경망은 (예를 들어, 입력 데이터에 기초하여 객체들, 이벤트들, 단어들 및/또는 다른 특징들의 확률들을 검출하거나 결정함으로써) 입력 데이터를 검출, 분류, 분할 및/또는 변환하도록 훈련될 수 있다. 예를 들어, 신경망의 제1 입력 계층은 입력 데이터를 수신하고, 입력 데이터를 처리하여 데이터를 제1 중간 출력으로 변환하고, 제1 중간 출력을 제1 은닉 계층에 전달할 수 있다. 제1 은닉 계층 은 제1 중간 출력을 수신하고, 제1 중간 출력을 처리하여 제1 중간 출력을 제2 중간 출력으로 변환하고, 제2 중간 출력을 제2 은닉층에 전달할 수 있다. 제2 은닉층은 제2 중간 출력을 수신하고, 제2 중간 출력을 처리하여 제2 중간 출력을 제3 중간 출력으로 변환하고, 제3 중간 출력을 예를 들어 출력 계층에 전달할 수 있다. 출력 계층은 제3 중간 출력을 수신하고, 제3 중간 출력을 처리하여 제3 중간 출력을 출력 데이터로 변환하고, 출력 데이터를 (예를 들어, 사용자에게 렌더링하기 위해, 저장하기 위해 등, 가 능하다면 후처리 엔진에) 전달할 수 있다. 출력 데이터는 예로서 객체 검출 데이터, 강화/변환/증강 데이 터, 추천, 분류, 및/또는 분할 데이터를 포함할 수 있다. 다시 도 1a를 참조하면, AI 가속기는 하나 이상의 저장 디바이스들을 포함할 수 있다. 저장 디바이스 는 AI 가속기(들)와 연관된 임의의 타입 또는 형태의 데이터를 저장, 보유 또는 유지하도록 설계되거 나 구현될 수 있다. 예를 들어, 데이터는 AI 가속기(들)에 의해 수신되는 입력 데이터 및/또는 출력 데이터(예를 들어, 다음 디바이스 또는 처리단에 출력되기 전)를 포함할 수 있다. 데이터는 신경망 (들) 및/또는 프로세서(들)의 임의의 처리단들을 위해 또는 그로부터 사용되는 중간 데이터를 포함할 수 있다. 데이터는 신경망(들)의 뉴런에 대한 입력 및 처리를 위한 하나 이상의 피연산자들을 포함할 수 있으며, 이는 저장 디바이스로부터 판독되거나 액세스될 수 있다. 예를 들어, 데이터는, 신경망(들) 의 하나 이상의 뉴런들(또는 노드들) 및/또는 계층들에 대한 입력 데이터, 가중치 정보 및/또는 바이어스 정보,활성화 함수 정보, 및/또는 파라미터들을 포함할 수 있으며, 이는 저장 디바이스에 저장되고 판독되 거나 액세스될 수 있다. 데이터는 신경망(들)의 뉴런으로부터의 출력 데이터를 포함할 수 있으며, 이는 저 장 디바이스에 기록되고 저장될 수 있다. 예를 들어, 데이터는 신경망(들)의 하나 이상의 뉴런들(또 는 노드들) 및/또는 계층들에 대한 활성화 데이터, 정제되거나 업데이트된 데이터(예를 들어, 훈련 단계로부터 의 가중치 정보 및/또는 바이어스 정보, 예를 들어 활성화 함수 정보 및/또는 다른 파라미터들)를 포함할 수 있으며, 이는 저장 디바이스에 전송되거나 기록될 수 있고 저장될 수 있다. 일부 실시예들에서, AI 가속기는 하나 이상의 프로세서들을 포함할 수 있다. 하나 이상의 프로세서들 은 임의의 하나 이상의 신경망(들) 또는 AI 가속기(들)에 대한 전처리 입력 데이터에 대한, 및/ 또는 임의의 하나 이상의 신경망(들) 또는 AI 가속기(들)에 대한 후처리 출력 데이터에 대한 임의의 논리, 회로 및/또는 처리 구성요소(예를 들어, 마이크로프로세서)를 포함할 수 있다. 하나 이상의 프로세서들 은 신경망 또는 AI 가속기(들)의 하나 이상의 동작들을 구성, 제어 및/또는 관리하기 위한 논리, 회로, 처리 구성요소 및/또는 기능을 제공할 수 있다. 예를 들어, 프로세서는 전력 소비를 제어하거 나 감소시키기 위해 (예를 들어, 신경망의 동작들을 구현하는 회로에 대한 클록-게이팅 제어들을 통해) 신 경망과 연관된 데이터 또는 신호들을 수신할 수 있다. 다른 예로서, 프로세서는 개별 처리(예를 들어, AI 가속기의 다양한 구성요소들에서, 예를 들어 병렬로), 순차적 처리(예를 들어, AI 가속기의 동일한 구성요소에 대해, 상이한 시간들 또는 단계들에서)를 위해, 또는 저장 디바이스의 상이한 메모리 슬라이 스들에 또는 상이한 저장 디바이스들에 저장하기 위해, 데이터를 분할 및/또는 재배열할 수 있다. 일부 실시예 들에서, 프로세서(들)는 예를 들어, 신경망의 뉴런들 및/또는 계층들에 특정 가중치, 활성화 함수 및 /또는 파라미터 정보를 식별, 선택 및/또는 로딩함으로써, 특정 컨텍스트에 대해 동작하고, 특정 타입의 처리를 제공하고 및/또는 특정 타입의 입력 데이터를 어드레싱하도록 신경망을 구성할 수 있다. 일부 실시예들에서, AI 가속기는 딥 러닝 및/또는 AI 워크로드들을 다루거나 처리하도록 설계 및/또는 구 현된다. 예를 들어, AI 가속기는 인공 신경망들, 기계 시각(machine vision) 및 기계 학습을 포함하는 인 공 지능 애플리케이션들을 위한 하드웨어 가속을 제공할 수 있다. AI 가속기는 로봇 공학 관련, 사물 인터 넷(IoT) 관련, 및 기타 데이터-집약적 또는 센서-구동식 작업들을 다루는 동작을 위해 구성될 수 있다. AI 가속 기는 다중-코어 또는 다중 처리 요소(PE: processing element) 설계를 포함할 수 있으며, 인공 현실(예를 들어, 가상, 증강 또는 혼합 현실) 시스템들, 스마트폰들, 태블릿들 및 컴퓨터들과 같은 다양한 타입들 및 형태 들의 디바이스들로 통합될 수 있다. AI 가속기의 특정 실시예들은 적어도 하나의 디지털 신호 프로세서 (DSP: digital signal processor), 코-프로세서(co-processor), 마이크로프로세서, 컴퓨터 시스템, 프로세서들 의 이종 컴퓨팅 구성, 그래픽 처리 장치(GPU: graphics processing unit), 필드-프로그래밍 가능한 게이트 어레 이(FPGA: field-programmable gate array) 및/또는 주문형 반도체(ASIC: application-specific integrated circuit)를 포함하거나 이를 사용하여 구현될 수 있다. AI 가속기는 트랜지스터 기반, 반도체 기반 및/또 는 양자 컴퓨팅 기반 디바이스일 수 있다. 이제 도 1b를 참조하면, AI 관련 처리를 수행하기 위한 디바이스의 예시적인 실시예가 도시된다. 간략한 개요에 서, 디바이스는 예를 들어 도 1a와 관련하여 상술된 하나 이상의 특징들을 갖는 AI 가속기를 포함하거나 이에 대응할 수 있다. AI 가속기는 하나 이상의 저장 디바이스들(예를 들어, 정적 랜덤-액세스 메모 리(SRAM: static random-access memory) 디바이스와 같은 메모리), 하나 이상의 버퍼들, 복수의 또는 어레이의 처리 요소(PE) 회로들, 기타 논리 또는 회로(예를 들어, 가산기 회로), 및/또는 다른 구조들 또는 구성들(예를 들어, 상호연결들, 데이터 버스들, 클록 회로, 전력 네트워크(들))을 포함할 수 있다. 상술한 소자들 또는 구성 요소들 각각은 하드웨어로 구현되거나, 또는 적어도 하드웨어와 소프트웨어의 조합으로 구현된다. 하드웨어는 예를 들어 회로 소자들(예를 들어, 하나 이상의 트랜지스터들, 논리 게이트들, 레지스터들, 메모리 디바이스들, 저항 소자들, 도전 소자들, 용량 소자들, 및/또는 와이어 또는 도전성 커넥터들)을 포함할 수 있다. AI 가속기에 구현된 신경망(예를 들어, 인공 신경망)에서, 뉴런들은 다양한 형태들을 취할 수 있고, 처리 요소들(PE들) 또는 PE 회로들로 지칭될 수 있다. 뉴런은 해당 PE 회로로 구현될 수 있으며, 뉴런에서 발생 할 수 있는 처리/활성화는 PE 회로에서 수행될 수 있다. PE들은 특정 네트워크 패턴 또는 어레이에 연결되며, 상이한 패턴들이 상이한 기능적 목적들을 제공한다. 인공 신경망의 PE는 전기적으로 작동하고(예를 들어, 반도 체 구현의 실시예에서) 아날로그, 디지털 또는 하이브리드일 수 있다. 생물학적 시냅스의 효과를 병행하기 위해, PE들 사이의 연결들에 곱셈 가중치들이 할당될 수 있으며, 이는 적절한 시스템 출력을 생성하도록 보정되 거나 \"훈련(trained)\"될 수 있다.PE는 다음 수학식들로 규정될 수 있다(예를 들어, 뉴런의 맥컬럭-피츠(McCulloch-Pitts) 모델을 나타낸다): 수학식 1"}
{"patent_id": "10-2022-7004858", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "수학식 2"}
{"patent_id": "10-2022-7004858", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "여기서 는 입력들의 가중된 합(예를 들어, 입력 벡터와 탭-가중치 벡터의 내적)이고, 는 가중된 합의 함 수이다. 가중치 및 입력 요소들이 벡터들 w 및 x를 형성할 때, z 가중된 합은 간단한 내적이 된다: 수학식 3"}
{"patent_id": "10-2022-7004858", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "이것은 활성화 함수(예를 들어, 임계값 비교의 경우) 또는 전달 함수로 지칭될 수 있다. 일부 실시예들에서, 하 나 이상의 PE들은 내적 엔진으로 지칭될 수 있다. 신경망에 대한 입력(예를 들어, 입력 데이터), x는 입력 공간으로부터 나올 수 있고 출력(예를 들어, 출력 데이터)은 출력 공간의 일부이다. 일부 신경망들에 대해, 출력 공간 Y는 {0, 1}만큼 단순하거나 복잡한 다-차원(예를 들어, 다중 채널) 공간(예를 들어, 컨볼루션 신경망에 대해)일 수 있다. 신경망들은 입력 공간의 자유도당 하나의 입력을 갖고 출력 공간의 자유도당 하나의 출력을 갖는 경향이 있다. 일부 실시예들에서, PE들은 시스톨릭 어레이(systolic array)로서 배열 및/또는 구현될 수 있다. 시스톨릭 어레 이는 셀들 또는 노드들이라고 하는 PE들과 같은 결합된 데이터 처리 유닛들(DPU)의 네트워크(예를 들어, 동종 네트워크)일 수 있다. 각각의 노드 또는 PE는 예를 들어 업스트림 이웃들에서 수신된 데이터의 함수로 부분 결 과를 독립적으로 계산할 수 있고, 결과를 자체 내에 저장할 수 있으며, 결과 다운스트림을 전달할 수 있다. 시 스톨릭 어레이는 특정 애플리케이션에 대해 고정 배선되거나 소프트웨어로 구성될 수 있다. 노드들 또는 PE들은 고정되고 동일할 수 있으며 시스톨릭 어레이의 상호 연결을 프로그래밍할 수 있다. 시스톨릭 어레이들은 동기식 데이터 전송에 의존할 수 있다. 다시 도 1b를 참조하면, PE에 대한 입력 x는 저장 디바이스(예를 들어, SRAM)로부터 판독되거나 액세 스되는 입력 스트림의 일부일 수 있다. 입력 스트림은 PE들의 하나의 로우(수평 뱅크 또는 그룹)로 향할 수 있고, 하나 이상의 PE들에 걸쳐 공유될 수 있거나, 각각의 PE들에 대한 입력들로서 데이터 부분들(중첩 또는 비중첩 데이터 부분들)로 분할될 수 있다. 가중치 스트림의 가중치들(또는 가중치 정보)(예를 들어, 저장 디바이스로부터 판독된)은 PE들의 컬럼(수직 뱅크 또는 그룹)으로 향하거나 제공될 수 있다. 컬럼의 PE들 각각은 동일한 가중치를 공유하거나 대응하는 가중치를 수신할 수 있다. 각각의 타겟 PE에 대한 입력 및/또는 가중치는 타겟 PE에 직접(예를 들어, 저장 디바이스로부터) 라우팅될 수 있거나(예를 들어, 다른 PE(들)를 통과하지 않고), 하나 이상의 PE들을 통해(예를 들어, PE들의 로우 또는 컬럼을 따라) 타겟 PE에 라우팅될 수 있다. 각각의 PE의 출력은 PE 어레이 외부로 직접 라우팅될 수 있거나(예를 들어, 다른 PE(들)를 통과하지 않고), 하나 이상의 PE들을 통해(예를 들어, PE들의 컬럼을 따라) 라우팅되어 PE 어레이를 종료할 수 있다. PE들의 각각의 컬럼에 대한 출력들은 각각의 컬럼의 가산기 회로에서 합산되거나 가산될 수 있고, PE들의 각각의 컬럼에 대한 버퍼에 제공될 수 있다. 버퍼(들)는 수신된 출력들을 저장 디바이스에 제공, 전송, 라우팅, 기록 및/또는 저장할 수 있다. 일부 실시예들에서, 저장 디바이스에 의해 저장되는 출력들(예를 들어, 신경망의 한 계층으로부터의 활성화 데이터)은 저장 디바이스로부터 검색되거나 판독될 수 있고, 나중에 (신경망의 후속 계층의) 처리를 위해 PE들의 어레이에 대한 입력들로서 사용될 수 있다. 특정 실시예들에서, 저장 디바이스에 의해 저장되는 출력들은 AI 가속기에 대한 출력 데이터로서 저장 디바이스로부터 검색되거나 판독될 수 있다. 이제 도 1c를 참조하면, AI 관련 처리를 수행하기 위한 디바이스의 예시적인 일 실시예가 도시된다. 간략한 개 요에서, 디바이스는 예를 들어, 도 1a 및 도 1b와 관련하여 상술한 하나 이상의 특징들을 갖는 AI 가속기 를 포함하거나 이에 대응할 수 있다. AI 가속기는 하나 이상의 PE들, 다른 논리 또는 회로(예를 들어, 가산기 회로), 및/또는 다른 구조들 또는 구성들(예를 들어, 상호연결들, 데이터 버스들, 클록 회로, 전 력 네트워크(들))을 포함할 수 있다. 상술한 소자들 또는 구성요소들 각각은 하드웨어로 구현되거나, 또는 적어 도 하드웨어와 소프트웨어의 조합으로 구현된다. 하드웨어는 예를 들어 회로 소자들(예를 들어, 하나 이상의 트 랜지스터들, 논리 게이트들, 레지스터들, 메모리 디바이스들, 저항 소자들, 도전 소자들, 용량 소자들, 및/또는 와이어 또는 도전성 커넥터들)을 포함할 수 있다. 일부 실시예들에서, PE는 하나 이상의 곱셈-누산(MAC) 유닛들 또는 회로들을 포함할 수 있다. 하나 이상의 PE들은 때때로 MAC 엔진으로 (단독으로 또는 집합적으로) 지칭될 수 있다. MAC 유닛은 곱셈-누산 연산 (들)을 수행하도록 구성된다. MAC 유닛은 곱셈기 회로, 가산기 회로 및/또는 누산기 회로를 포함할 수 있다. 곱 셈-누산 연산은 두 숫자의 곱을 계산하고 그 곱을 누산기에 가산한다. MAC 연산은 누산기 피연산자 a, 입력들 b 및 c와 관련하여 다음과 같이 나타낼 수 있다: 수학식 4"}
{"patent_id": "10-2022-7004858", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "일부 실시예들에서, MAC 유닛은, 결과를 저장하는 가산기(예를 들어, 조합 논리를 포함) 및 누산기 레지스 터(예를 들어, 순차 및/또는 조합 논리를 포함)가 뒤따르는 조합 논리로 구현되는 곱셈기를 포함할 수 있다. 누 산기 레지스터의 출력은 가산기의 한 입력으로 피드백될 수 있으므로, 각각의 클록 사이클 상에서 곱셈기의 출 력이 누산기 레지스터에 추가될 수 있다. 위에서 논의된 바와 같이, MAC 유닛은 곱셈 및 가산 기능들 모두를 수행할 수 있다. MAC 유닛은 두 단계로 동작할 수 있다. MAC 유닛은 먼저 제1 단계에서 주어진 숫자들(입력들)의 곱을 계산할 수 있고, 제 2 단계 연산(예를 들어, 가산 및/또는 누산)에 대한 결과를 전달할 수 있다. n-비트 MAC 유닛은 n-비트 곱 셈기, 2n-비트 가산기 및 2n-비트 누산기를 포함할 수 있다. 어레이 또는 복수의 MAC 유닛들(예를 들어, PE들에서)은 병렬 통합, 컨볼루션, 상관, 행렬 곱셈, 데이터 분류, 및/또는 데이터 분석 작업들을 위해 시스톨 릭 어레이로 배열될 수 있다. 본 명세서에 설명된 다양한 시스템들 및/또는 디바이스들은 컴퓨팅 시스템(에서 구현될 수 있다. 도 1d는 대표 적인 컴퓨팅 시스템의 블록도를 도시한다. 일부 실시예들에서, 도 1a의 시스템은 컴퓨팅 시스템의 처 리 유닛(들)(또는 프로세서들)의 적어도 일부를 형성할 수 있다. 컴퓨팅 시스템은 스마트폰, 다 른 휴대 전화, 태블릿 컴퓨터, 웨어러블 컴퓨팅 디바이스(예를 들어, 스마트 워치, 안경, 헤드 마운트 디스플레 이), 데스크탑 컴퓨터, 랩탑 컴퓨터와 같은 디바이스(예를 들어, 소비자 디바이스)로서 구현될수 있거나, 또는 분산 컴퓨팅 디바이스들로 구현될 수 있다. 컴퓨팅 시스템은 VR, AR, MR 경험을 제공하도록 구현될 수 있 다. 일부 실시예들에서, 컴퓨팅 시스템은 프로세서들, 저장 디바이스, 네트워크 인터페이스 , 사용자 입력 디바이스, 및 사용자 출력 디바이스와 같은 통상적인, 특수화된 또는 맞춤형 컴 퓨터 구성요소들을 포함할 수 있다. 네트워크 인터페이스는 (로컬/원격) 서버 또는 백-엔드 시스템(back-end system)의 네트워크 인터페이스에 도 연결되는 근거리/광역 네트워크(예를 들어, 인터넷)에 대한 연결을 제공할 수 있다. 네트워크 인터페이스 는 유선 인터페이스(예를 들어, 이더넷) 및/또는 Wi-Fi, 블루투스 또는 셀룰러 데이터 네트워크 표준들(예 를 들어, 3G, 4G, 5G, LTE 등)과 같은 다양한 RF 데이터 통신 표준을 구현하는 무선 인터페이스를 포함할 수 있 다. 사용자 입력 디바이스는 사용자가 이를 통해 컴퓨팅 시스템에 신호들을 제공할 수 있는 임의의 디바 이스(또는 디바이스들)를 포함할 수 있고; 컴퓨팅 시스템은 신호들을 특정 사용자 요청들 또는 정보를 나 타내는 것으로 해석할 수 있다. 사용자 입력 디바이스는 키보드, 터치 패드, 터치 스크린, 마우스 또는 기 타 포인팅 디바이스, 스크롤 휠, 클릭 휠, 다이얼, 버튼, 스위치, 키패드, 마이크로폰, 센서들(예를 들어, 모션센서, 시선 추적 센서 등) 등 중 일부 또는 전부를 포함할 수 있다. 사용자 출력 디바이스는 컴퓨팅 시스템이 사용자에게 정보를 제공할 수 있는 임의의 디바이스를 포함 할 수 있다. 예를 들어, 사용자 출력 디바이스는 컴퓨팅 시스템에 의해 생성되거나 컴퓨팅 시스템 에 전달되는 이미지들을 디스플레이하기 위한 디스플레이를 포함할 수 있다. 디스플레이는 지원 전자장치 들(예를 들어, 디지털-아날로그 또는 아날로그-디지털 변환기들, 신호 프로세서들 등)과 함께, 다양한 이미지 생성 기술들, 예를 들어 액정 디스플레이(LCD), 유기 발광 다이오드들(OLED)을 포함하는 발광 다이오드(LED), 프로젝션 시스템, 음극선관(CRT) 등을 통합할 수 있다. 입력 및 출력 디바이스 둘다로 기능하는 터치스크린과 같은 디바이스가 사용될 수 있다. 사용자 출력 디바이스는 디스플레이에 추가로 또는 디스플레이 대신에 제공될 수 있다. 예들로서, 표시등들, 스피커들, 촉각 \"디스플레이(display)\" 디스플레이들, 프린터들 등을 포 함한다. 일부 구현들은 비일시적 컴퓨터 판독 가능한 저장 매체에 컴퓨터 프로그램 명령들을 저장하는 마이크로프로세서, 저장장치 및 메모리와 같은 전자 구성요소들을 포함한다. 본 명세서에 설명된 많은 특징들은 컴퓨터 판독 가능한 저장 매체 상에 인코딩된 프로그램 명령들의 세트로 지정된 프로세스들로서 구현될 수 있다. 이러한 프로그램 명령들이 하나 이상의 프로세서들에 의해 실행될 때, 이들은 프로세서들이 프로그램 명 령들에 표시된 다양한 동작들을 수행하도록 한다. 프로그램 명령들 또는 컴퓨터 코드의 예들로는 컴파일러에 의 해 생성된 것과 같은 기계식 코드, 및 컴퓨터, 전자 구성요소 또는 마이크로 프로세서에 의해 인터프리터를 사 용하여 실행되는 상위-수준 코드를 포함하는 파일들이 있다. 적절한 프로그래밍을 통해, 프로세서는 서버 또는 클라이언트에 의해 수행되는 것으로 본 명세서에 설명된 임의의 기능, 또는 메시지 관리 서비스들과 연관 된 다른 기능을 포함하여 컴퓨팅 시스템을 위한 다양한 기능을 제공할 수 있다. 컴퓨팅 시스템은 예시적이며 변형들 및 수정들이 가능함을 알 것이다. 본 개시내용과 관련하여 사용되는 컴퓨터 시스템들은 본 명세서에 구체적으로 설명되지 않은 다른 능력들을 가질 수 있다. 또한, 컴퓨팅 시스템 이 특정 블록들을 참조하여 설명되지만, 이러한 블록들은 설명의 편의를 위해 규정되고 구성요소 부품들의 특정 물리적 배치를 내포하도록 의도되지 않음을 이해한다. 예를 들어, 동일한 시설에, 동일한 서버 랙에 또는 동일한 마더보드 상에 상이한 블록들이 배치될 수 있다. 또한, 블록들은 물리적으로 구별되는 구성요소들에 대 응할 필요가 없다. 블록들은, 예를 들어 프로세서를 프로그래밍하거나 적절한 제어 회로를 제공함으로써 다양한 동작들을 수행하도록 구성될 수 있고, 다양한 블록들은 초기 구성을 얻는 방법에 따라 재구성할 수도 있고 그렇 지 않을 수도 있다. 본 개시내용의 구현들은 회로 및 소프트웨어의 임의의 조합을 사용하여 구현되는 전자 디바 이스들을 포함하는 다양한 장치에서 실현될 수 있다. B. 신경망의 계층에 대한 복수의 출력들을 생성하기 위한 방법들 및 장치들 본 명세서의 개시내용은 신경망의 계층에 대한 복수의 출력들을 생성하기 위한 시스템, 방법 및 디바이스의 실 시예들을 포함하며, 이에는 어레이를 서브어레이들로 분할하고 처리 요소들의 그룹을 서브어레이들 중 하나에 할당함으로써 어레이에 배열된 복수의 출력들을 생성하기 위한 시스템 및 방법을 포함하지만, 이에 제한되지 않 는다. 일부 실시예들에서, AI 가속기들은 더 소규모의 컨볼루션들에 대해서는 열악한 효율성을 제공하지만 대규 모 컨볼루션들에 대해서는 최적화된다. 낮은 에너지 및 대기시간에서 높은 정확도를 달성하기 위해, AI 가속기 들은 높은 처리량을 제공하면서 소규모 컨볼루션들을 효율적으로 처리하도록 구성될 수 있다. 따라서, 대규모 컨볼루션들에 대해 최적화된 AI 가속기들을 구현하는 대신에, 본 시스템, 방법 및 디바이스에 따라 구현된 AI 가속기는 더 소규모의 컨볼루션들에서 효율성을 유지하면서 높은 처리량 및/또는 낮은 대기시간을 제공할 수 있 다. 예시로서, AI 가속기는 AcclX × outY × AcclY(예를 들어, GEMM 용어로 M × N × K)의 크기 또는 차원들 의 일반 행렬 곱셈(GEMM) 연산을 지원할 수 있다. 입력 피연산자 및/또는 대응하는 출력에 따라 다음 컨볼루션 매핑들이 유연하게 채택될 수 있다: 1. 컨볼루션 GEMM 연산들을 디폴트로 매핑: 출력은 AcclX × outY 블록들로 타일링될 수 있고 입력 피연산자의 AcclX × AcclY 및 outY × AcclY 청크들을 사용하여 업데이트될 수 있다. 2. 특징 카운트가 적은(small input feature count) 컨볼루션 GEMM 연산들을 매핑: 출력은 AcclX/2 × OutY/2 블록들로 타일링될 수 있고 입력 피연산자의 AcclX/2 × AcclY/2 및 OutY/2 × AcclY/2 청크들을 사용하여 업데 이트될 수 있다. 3. 입력 특징 카운트가 적은 컨볼루션 GEMM 연산들을 매핑: 출력은 AcclX × OutY/2 블록들로 타일링될 수 있고 입력 피연산자의 AcclX × AcclY/2 및 OutY/2 × AcclY/2 청크들을 사용하여 업데이트될 수 있다.4. 출력 특징 카운트가 적은 컨볼루션 GEMM 연산들을 매핑: 출력은 AcclX/2 × OutY 블록들로 타일링될 수 있고 입력 피연산자의 AcclX/2 × AcclY/2 및 OutY × AcclY/2 청크들을 사용하여 업데이트될 수 있다. 다양한 컨볼루션 매핑들은 대규모 컨볼루션들에 대해 최적화된 단일 컨볼루션 구성과 비교하여, AI 가속기의 컴 퓨팅 처리량이 광범위한 GEMM/컨볼루션 차원들에 대해 높은 수준이 되도록 할 수 있다. 일부 양태들에서, CNN-기반 AI 가속기들에서 컨볼루션/GEMM 연산을 수행할 때 에너지 비효율성의 한 원인은 입 력 피연산자들의 반복적인 페칭이다. 일부 실시예들에서, 'r' 레지스터들 또는 플립플롭들은 호출들 전반에 지 속되는 고정 피연산자(들)를 유지하기 위해 각각의 처리 요소(PE)에 추가될 수 있다. 이것은 예를 들어 컨볼루 션/GEMM의 축소 차원이 AcclY × r보다 작거나 같을 때 시스템이 고정 피연산자(들)의 중복 페치들을 방지하도 록 하는데 도움이 된다. 고정 피연산자(들)의 다중 페칭을 방지하는 위의 기술과 유사하게, GEMMM이 AcclX보다 크지만 입력 특징 카운트 가 AcclY × 'r'보다 작은 경우 스트리밍 피연산자가 페치되어야 하는 횟수가 줄어들 수 있다. 이 경우, 스트리 밍 피연산자의 재사용 카운트는 최대 'r'배 증가될 수 있다. 도 2a는 본 개시내용의 예시적인 구현에 따른 AI 관련 처리를 수행하기 위한 데이터의 표현이다. 도 2a를 참조 하면, AI 가속기(또는 \"가속기(accelerator)\")는 (M × K) 입력 행렬을 입력 데이터로, (K × N) 커널 행 렬을 커널 정보로 수신하고, 컨볼루션을 수행하여 (M × N) 컨볼루션 출력 행렬을 출력 데이터로서 생성할 수 있다. 일부 실시예들에서, AI 가속기는 입력 행렬로부터의 한 로우와 커널 행렬로부터의 대응하는 컬럼에 대해 내적 연산들을 수행함으로써 (M × N) 컨볼루션 출력 행렬을 생성할 수 있다. 일부 실시예들에서, 가속기는 GEMM 알고리즘을 사용하여 (M × N) 컨볼루션 출력 행렬을 생성한다. 일부 실시예들에서, 입력 행렬은 신경망의 계층에 대해 크기 K를 갖는 M개의 데이터 청크들로 분할된 입력 데이 터 스트림들(예를 들어, 이미지 데이터)을 나타낼 수 있다. 일부 실시예들에서, 입력 데이터는 다수의 채널들과 연관될 수 있다(예를 들어, RGB 데이터의 경우, 채널들의 수는 3이다). 일부 실시예들에서, 커널 행렬은 각각이 신경망의 계층에 대한 K개의 가중치들로 구성된 N개의 커널들을 나타낼 수 있다. AI 가속기들을 설계할 때 대규모 컨볼루션들(예를 들어, 도 2a에 도시된 출력 크기 (M × N)가 큰 컨볼루션들) 에 대해 최적화가 수행될 수 있다. 한 가지 접근 방식에서, AI 가속기는 크기들이 큰 데이터(예를 들어, 큰 데 이터 배열 형상들 및/또는 차원들)를 가진 컨볼루션들에 대해서는 최적화를 제공하지만 더 소규모의 컨볼루션들 (예를 들어, (M × N)보다 작은 출력 크기를 가진 컨볼루션들)에 대해서는 열악한 효율성 또는 활용성을 제공한 다. 예를 들어, AI 가속기에서 입력 데이터 청크들의 수 M 및/또는 커널들의 수 N이 상대적으로 작은 경우, AI 가속기의 일부(예를 들어, 처리 요소들(PE들)을 포함하는 회로 또는 곱셈기 및 누산기(MAC) 회로)는 실제 또는 유효한 출력들을 처리하지 않을 수 있어 중복 처리에 해당하므로, 전력 소비를 증가시킨다. 이 문제를 해결하기 위해, 일부 구현들에서, 대규모 컨볼루션들에만 최적화된 가속기들을 구축하는 대신에, 가 속기가 더 대규모의 컨볼루션들에 대해 높은 처리량과 낮은 대기시간을 제공하는 동시에 더 소규모의 컨볼루션 들에 대한 효율성을 유지할 수 있다. 예를 들어, 대규모 컨볼루션 출력은 처리 요소들(PE)의 어레이의 고정된 차원들에 적합할 수 있는 더 소규모의 컨볼루션 출력들로 분할되거나 쪼개어질 수 있다(도 1b의 PE(들) 참 조). 더 소규모의 컨볼루션 출력 각각은 더 소규모의 컨볼루션 출력에 할당된 PE들의 그룹에 의해 생성될 수 있 다. 이러한 방식으로 더 소규모의 컨볼루션 출력들이 PE 어레이의 고정 차원에 적합할 수 있기 때문에, PE 어레 이의 모든 PE들을 실행하지 않고도 이러한 더 소규모의 출력들에 대한 컨볼루션들이 수행될 수 있다. 일부 실시 예들에서, M 및 N 각각이 1보다 큰 정수인 (M × N) 차원의 PE 어레이에 대해, 대규모 컨볼루션 출력은 다음의 예시적인 타입들의 더 소규모의 출력들 중 하나로 분할될(또는 쪼개어지거나 나누어질) 수 있다: (M × N) 컨볼루션 출력 행렬; (M/2 × N) 컨볼루션 출력 행렬; (M × N/2) 컨볼루션 출력 행렬; 및 (M/2 × N/2) 컨볼루션 출력 행렬. 일부 실시예들에서, 더 소규모의 컨볼루션 출력의 각각의 타입은 다음과 같이 생 성되거나 업데이트될 수 있다: (M × N) 컨볼루션 출력 행렬을 생성하기 위해, 출력은 PE 어레이(예를 들어, 전체 어레이)의 (M × N) 블록들에 할당되거나 타일링되고 가속기에 대한 피연산자들로서 (M × K) 입력 행렬 및 (K × N) 커널 행렬을 사용하여 업데이트되고; (M/2 × N) 컨볼루션 출력 행렬을 생성하기 위해, 출력은 PE 어레이의 (M/2 × N) 블록들에 할당되거나 타일링되고 가속기에 대한 피연산자들로서 (M/2 × K/2) 입력 행렬과 (K/2 × N) 커널 행렬을 사용하여 업데이트되고; (M × N/2) 컨볼루션 출력 행렬을 생성하기 위해, 출력은 PE 어레이의 (M × N/2) 블록들에 할당되거나 타일링되고 가속기에 대한 피연산자들로서 (M × K/2) 입력 행렬과 (K/2 × N/2) 커널 행렬을 사용하여 업데이트되고; (M/2 × N/2) 컨볼루션 출력 행렬을 생성하기 위해, 출력은 PE 어레이의 (M/2 × N/2) 블록들에 할당되거나 타일링되고 가속기에 대한 피연산자들로서 (M/2 × K/2) 입력 행렬과 (K/2 × N/2) 커널 행렬을 사용하여 업데이트된다. PE 어레이의 각각의 블록은 하 나의 PE(또는 다수의 PE들)를 포함할 수 있다. 또한, 컨볼루션 연산을 수행할 때 입력 데이터 및 커널들의 반복적인 액세스 및/또는 처리로 인해 소비 전력 및 지연이 증가할 수 있다. 호출들(예를 들어, 컨볼루션 연산들의 호출들) 전반에 지속되는 가속기에 대한 피연산 자는 \"고정(stationary)\" 피연산자로 지칭될 수 있다. 도 2a를 참조하면, 커널 행렬의 각각의 커널(예를 들어, 커널 값 또는 커널 요소)은 (커널에 대응하는 컨볼루션 출력 행렬의 컬럼을 출력하기 위해) 컨볼루션 연산 동안 고정 피연산자가 될 수 있는데, 이는 행렬의 각각의 커널이 컨볼루션 연산 동안 변하지 않기 때문이다. 예를 들 어, 도 2a를 참조하면, 커널 행렬의 커널은 컨볼루션 연산 동안에 커널에 대응하는 컨볼루션 출 력 행렬의 컬럼을 출력하기 위한 고정 피연산자이다. 반면, AI-관련 처리의 특정 연산(예를 들어, 컨 볼루션 연산) 동안 변하는 가속기에 대한 피연산자는 스트리밍 피연산자로 지칭될 수 있다. 예를 들어, 입력 행 렬의 M개의 데이터 청크들은 컨볼루션 연산 동안 컨볼루션 출력 행렬의 컬럼을 출력하기 위한 스트리밍 피연산자들일 수 있다. 중복 연산들의 문제를 해결하기 위해, 일부 실시예들에서, 고정 피연산자를 유지하기 위해 메모리(예를 들어, 다수의 레지스터들, 플립플롭 회로들(예를 들어, FLOP들) 또는 래치들)가 각각(PE-120)에 추가될 수 있으며, 그 에 의해 저장 디바이스로부터 저장 디바이스(예를 들어, SRAM)에서 페치들의 수를 감소시켜 에너지를 줄일 수 있다. 일부 실시예들에서, 캐시 또는 버퍼 메모리는 고정 피연산자를 유지하는 메모리로 사용될 수 있다. 일 부 실시예들에서, R개의 FLOP들은 컨볼루션/GEMM의 축소된 크기(예를 들어, 차원들)가 K × R보다 작거나 같을 때 고정 피연산자의 중복 페치들을 방지하기 위해, 커널 데이터(예를 들어, 커널 행렬)를 고정 피연산자로 유지하기 위해 각각의 PE에 추가될 수 있다. 본 개시내용에 설명된 시스템들 및 방법들은 공지된 시스템들 및 방법들에 비해 여러 이점들을 포함한다. 먼저, 일부 실시예들에서, 본 개시내용은 높은 처리량을 제공하면서 낮은 에너지 및 대기시간을 달성하기 위해 소규모 컨볼루션들(예를 들어, 이에 비해 상대적으로 더 소규모의 출력을 생성하는 컨볼루션들)을 처리하기 위한 솔루 션을 제공한다. 둘째, 일부 실시예들에서, 본 개시내용은 더 대규모의 컨볼루션 출력이 분할될 수 있는 다양한 타입들(예를 들어, 4개의 타입들) 또는 구성들의 더 소규모의 컨볼루션 출력들을 제공한다. 이 분할을 통해, AI 가속기의 컴퓨팅 처리량이 광범위한 GEMM/컨볼루션 차원들에 대해 상대적으로 높일 수 있다. 셋째, 각각의 PE에 로컬 메모리(또는 버퍼)를 추가하면 모듈식 구조를 사용할 수 있으므로, 더 적은 수의 PE들이 배치되어 충분한 처리량을 제공하고 에너지도 절감할 수 있다. 더욱이, 이러한 로컬 메모리의 추가는 메모리(예를 들어, 도 1b의 SRAM)로부터 중복 페치들(예를 들어, 고정 데이터의) 을 방지함으로써 데이터 이동 비용을 절감할 수 있다. 도 2b 내지 도 2e는 본 개시내용의 하나 이상의 예시적인 구현들에 따른, 신경망의 계층에 대한 복수의 출력들 을 생성하기 위해 AI 관련 처리를 수행하기 위한 복수의 처리 요소들(PE들)을 포함하는 디바이스의 실시예들의 블록도들이다. 도 2b를 참조하면, 그리고 일부 실시예들에서, 가속기는 가속기의 하나 이상의 소자들(도 1b 참조)을 포함할 수 있고, (M × N) PE 어레이 또는 행렬을 포함할 수 있다. 일부 실시예들에서, PE 어레이의 PE들의 수 는 1k 또는 2k일 수 있다. 일부 실시예들에서, 가속기의 프로세서(예를 들어, 도 1a의 프로세서의 하나 이 상의 특징들을 가짐)는 최적의 에너지 소비를 고려하여 PE들의 수 및/또는 어레이 차원들을 결정할 수 있다. 일 부 실시예들에서, 프로세서는 상이한 입력 스트림들 및 상이한 피연산자 데이터에 따른 가속기 의 전력 소비의 추정 및/또는 측정 데이터에 기초하여 PE들의 수 및/또는 어레이 차원을 결정할 수 있다. 일부 실시예들에서, 가속기에서, 입력 스트림은 저장 디바이스로부터 판독, 출력 또는 액세스될 수 있다(예를 들어, 도 1b 참조). 일부 실시예들에서, 입력 스트림은 (M × K) 입력 행렬로 표현 및/또는 배열되는 데이터를 포함하거나 제공할 수 있다(도 2a 참조). 일부 실시예들에서, 입력 스트림은 PE들(22 2)의 각각의 로우에 대한 버퍼에 저장될 수 있다. 예를 들어, 각각의 버퍼는 PE들의 대응하는 로우에 대한 입력 스트림의 일부를 저장할 수 있다. PE들의 하나의 로우(수평 뱅크 또는 그룹)에 향 할 수 있거나, 하나 이상의 PE들에 걸쳐 공유될 수 있거나, 각각의 PE들에 대한 입력들로서 데이터 부분들로 분 할될 수 있다. 피연산자 데이터는 PE들의 컬럼(수직 뱅크 또는 그룹)으로 향하거나 제공될 수 있다. 일부 실시예들에서, 피연산자 데이터는 (K × N) 커널 행렬로 표현 및/또는 배열될 수 있다(도 2a 참조). 일부 실시예들에서, 피연산자 데이터는 가중치 스트림에 가중치들(또는 가중치 정보)을 포함할 수 있는 커널 데 이터를 포함할 수 있다. 컬럼의 각각의 PE들은 동일한 피연산자 정보를 공유하거나 대응하는 피연산자 정보를수신할 수 있다. (입력 스트림으로부터의) 입력 및/또는 각각의 타겟 PE에 대한 가중치는 (예를 들어, 저 장 디바이스로부터) 타겟 PE에 직접(예를 들어, 다른 PE(들)를 통과하지 않고) 라우팅될 수 있거나, 하나 이상의 PE들을 통해(예를 들어, PE들의 로우 또는 컬럼을 따라) 타겟 PE에 라우팅될 수 있다. 각각의 PE의 출력 은 PE 어레이 외부로 직접 라우팅될 수 있거나(예를 들어, 다른 PE(들)를 통과하지 않고), PE 어레이를 종료하 기 위해 하나 이상의 PE들을 통해(예를 들어, PE들의 컬럼을 따라) 라우팅될 수 있다. PE들의 각각의 컬럼의 출 력들은 각각의 컬럼의 가산기 회로에서 합산되거나 가산될 수 있고, 출력 데이터로서 출력될 수 있다. 일 부 실시예들에서, 출력 데이터는 (M × N) 컨볼루션 출력 행렬로 표현 및/또는 배열될 수 있다(도 2a 참조). 일부 실시예들에서, 출력 데이터는 PE들의 각각의 컬럼에 대한 버퍼(예를 들어, 도 1b의 버퍼 )에 저장될 수 있다. 버퍼(들)는 수신된 출력들을 저장 디바이스에 제공, 전송, 라우팅, 기록 및/또 는 저장할 수 있다(예를 들어, 도 1b 참조). 일부 실시예들에서, 저장 디바이스에 저장된 출력들(예를 들 어, 신경망의 한 계층으로부터의 활성화 데이터)(도 1b 참조)은 저장 디바이스로부터 검색되거나 판독될 수 있고 나중에 (신경망의 후속 계층의) 처리를 위해 PE들의 어레이에 대한 입력들로서 사용될 수 있다. 일부 실시예들에서, (M × N)의 차원을 갖는 PE 어레이는 신경망의 계층에 대한 복수의 출력들을 생성하기 위해 입력 데이터를 수신할 수 있다. 일부 실시예들에서, 복수의 출력들은 제1 어레이(미도시)에 배열된 복수의 컨볼 루션 출력들(예를 들어, PE들에 의해 수행되는 컨볼루션 연산들에 의해 생성된 출력들)일 수 있다. 프로세서는 출력들의 제1 어레이의 차원들을 PE 어레이의 차원들(예를 들어, 도 2b의 PE 어레이에 대한 (M × N))과 비교할 수 있다. 프로세서는 (예를 들어, 제1 어레이의 하나의 차원이 PE 어레이의 대응하는 차원보다 크거나 같다는 결정에 응답하여) 비교 결과에 따라, 제1 어레이를 PE 어레이의 차원들 이하의 차원들을 각각 갖는 서브어레이 들로 분할할 수 있다. 일부 실시예들에서, 제1 어레이의 분할은 정적으로 구성될 수 있다. 예를 들어, 프로세서는 제1 어레이를 적어 도 하나의 다음의 예시적인 타입들의 서브어레이들(예를 들어, 제1 어레이보다 큰 것과 비교하여 더 소규모의 컨볼루션 출력들을 지원함)로 분할(또는 쪼개거나 나누거나 매핑)할 수 있다: (M × N) 컨볼루션 출력 행렬 (도 2b 참조); (M/2 × N) 컨볼루션 출력 행렬(도 2c 참조); (M × N/2) 컨볼루션 출력 행렬(예를 들 어, 도 2d 참조); 및 (M/2 × N/2) 컨볼루션 출력 행렬(도 2b 참조). 일부 실시예들에서, 분할들은 예를 들 어 상태 머신을 사용하여 예를 들어 프로세서에 의해 동적으로 구성될 수 있다. 도 2b를 참조하면, (M × N) 서브어레이를 제공하기 위해 제1 어레이를 분할(또는 쪼개거나 나누거나 매핑)하는 것에 응답하여, 프로세서는 (M × N) 컨볼루션 출력 행렬을 PE 어레이(예를 들어, 전체 어레이)의 (M × N) 블 록들에 할당할 수 있다. PE 어레이의 각각의 블록은 하나 이상의 PE들을 포함할 수 있다. 일부 실시예들에 서, (M × N) 컨볼루션 출력 행렬은 (M × N) 블록으로 타일링되거나 매핑될 수 있고 (M × K) 입력 스트 림 및 (K × N) 피연산자 데이터를 사용하여 업데이트될 수 있다. 일부 실시예들에서, (M × N) 컨볼 루션 출력 행렬에 할당된 (M × N) 블록들의 각각의 PE는 입력 스트림 및 (K × N) 피연산자 데이터 의 일부를 사용하여 (M × N) 컨볼루션 출력 행렬의 대응하는 출력을 생성하거나 업데이트할 수 있다. 일 부 실시예들에서, (M × N) 블록들의 각각의 PE는 대응하는 버퍼(예를 들어, 도 1b의 버퍼)에 대응하 는 생성된 또는 업데이트된 출력을 저장할 수 있다. 일부 실시예들에서, 버퍼들은 (M × N) 어레이 또는 행렬로 배열될 수 있고 및/또는 N개의 버퍼들, 예를 들어 PE들의 각각의 컬럼에 대해 하나씩 포함할 수 있 다. 일부 실시예들에서, 가속기는 버퍼들에 저장된 (M × N) 출력 데이터를 저장 디바이스에 기 록할 수 있다(도 1b 참조). 도 2c를 참조하면, (M/2 × N) 서브어레이를 제공하기 위해 제1 어레이를 분할(또는 쪼개거나 나누거나 매핑)하 는 것에 응답하여, 프로세서는 (M/2 × N) 컨볼루션 출력 행렬을 PE 어레이의 (M/2 × N) 블록에 할당할 수 있다. PE 어레이의 각각의 블록은 하나 이상의 PE들을 포함할 수 있다. 일부 실시예들에서, (M/2 × N) 컨볼 루션 출력 행렬은 (M/2 × N) 블록들로 타일링되거나 매핑될 수 있고 (M/2 × K/2) 입력 스트림 및 (K/2 × N) 피연산자 데이터를 사용하여 업데이트될 수 있다. 일부 실시예들에서, (M/2 × N) 컨볼루션 출 력 행렬에 할당된 (M × N) 블록들의 각각의 PE는 (M/2 × K/2) 입력 스트림 및 (K/2 × N) 피연산 자 데이터의 일부를 사용하여 (M/2 × N) 컨볼루션 출력 행렬의 대응하는 출력을 생성하거나 업데이트할 수 있다. 일부 실시예들에서, (M/2 × N) 블록들의 각각의 PE는 대응하는 버퍼(예를 들어, 도 1b의 버퍼 )에 대응하는 생성된 또는 업데이트된 출력을 저장할 수 있다. 일부 실시예들에서, 가속기는 버퍼들 에 유지되거나 저장된 (M/2 × N) 차원의 출력 데이터를 저장 디바이스에 기록할 수 있다(도 1b 참조). 도 2d를 참조하면, (M × N/2) 서브어레이를 제공하기 위해 제1 어레이를 분할(또는 쪼개거나 나누거나 매핑)하 는 것에 응답하여, 프로세서는 (M × N/2) 컨볼루션 출력 행렬을 PE 어레이의 (M × N/2) 블록들에 할당할 수 있다. PE 어레이의 각각의 블록은 하나 이상의 PE들을 포함할 수 있다. 일부 실시예들에서, (M × N/2) 컨볼 루션 출력 행렬은 (M × N/2) 블록들로 타일링되고 (M × K/2) 입력 스트림 및 (K/2 × N/2) 피연산 자 데이터를 사용하여 업데이트될 수 있다. 일부 실시예들에서, (M × N/2) 컨볼루션 출력 행렬에 할당된 (M × N/2) 블록들의 각각의 PE는 (M × K/2) 입력 스트림 및 (K/2 × N/2) 피연산자 데이터의 일부를 사용하여 (M × N/2) 컨볼루션 출력 행렬의 대응하는 출력을 생성하거나 업데이트할 수 있다. 일부 실시 예들에서, (M × N/2) 블록들의 각각의 PE는 대응하는 생성된 또는 업데이트된 출력을 대응하는 버퍼(예를 들어, 도 1b의 버퍼)에 저장할 수 있다. 일부 실시예들에서, 가속기는 버퍼들에 유지되거나 저장된 (M × N/2) 차원의 출력 데이터를 저장 디바이스에 기록할 수 있다(도 1b 참조). 도 2e를 참조하면, (M/2 × N/2) 서브어레이를 제공하기 위해 제1 어레이를 분할(또는 쪼개거나 나누거나 매 핑)하는 것에 응답하여, 프로세서는 (M/2 × N/2) 컨볼루션 출력 행렬을 PE 어레이의 (M/2 × N/2) 블록들(25 7)에 할당할 수 있다. PE 어레이의 각각의 블록은 하나 이상의 PE들을 포함할 수 있다. 일부 실시예들에서, (M/2 × N/2) 컨볼루션 출력 행렬은 (M/2 × N/2) 블록들로 타일링되고 (M/2 × K/2) 입력 스트림 및 (K/2 × N/2) 피연산자 데이터를 사용하여 업데이트될 수 있다. 일부 실시예들에서, (M/2 × N/2) 컨볼 루션 출력 행렬에 할당된 (M/2 × N/2) 블록들의 각각의 PE는 (M/2 × K/2) 입력 스트림 및 (K/2 × N/2) 피연산자 데이터의 일부를 사용하여 (M/2 × N/2) 컨볼루션 출력 행렬의 대응하는 출력을 생성하거나 업데이트할 수 있다. 일부 실시예들에서, (M/2 × N/2) 블록들의 각각의 PE는 대응하는 버퍼(예를 들어, 도 1b의 버퍼)에 대응하는 생성된 또는 업데이트된 출력을 저장할 수 있다. 일부 실시예들에서, 가속기 는 버퍼들에 유지되거나 저장된 (M/2 × N/2) 차원의 출력 데이터를 저장 디바이스에 기록할 수 있다(도 1b 참조). 도 2f는 본 개시내용의 예시적인 구현에 따른, 신경망의 계층에 대한 복수의 출력들을 생성하기 위해 AI 관련 처리를 수행하기 위한 처리 유닛들(PE들)의 실시예의 블록도이다. 도 2f를 참조하면, 일부 실시예들에서, PE는 제1 메모리 및 제2 메모리를 포함할 수 있다. 일부 실시예들에서, PE는 제1 메모리에 저장된 입력 스트림 데이터의 제1 벡터 및 피연산자 데이터의 제2 벡터의 내적을 수행하거나 계산하기 위하여 MAC 유닛(예를 들어, 도 2c의 MAC 유닛 의 하나 이상의 특징들을 가짐)을 포함할 수 있다. PE의 MAC 유닛은 내적 연산의 결과를 저장하기 위 한 누산기를 포함할 수 있다. 다른 PE도 유사한 구성을 가진다. 각각의 PE에 대응하는 입력 스트림 및 피연산자 데이터에 대한 컨볼루션 연산 완료(예를 들어, 입력 스트림에서의 벡터와 피연산자 데이터에서의 벡터의 내적 계산 완료)에 응답하여, PE(도 2f에서 260 또는 265)는 아웃 플롭의 대응하는 컬럼 위치에 컨 볼루션 연산의 대응하는 결과를 출력할 수 있다. 일부 실시예들에서, 동일한 로우에 있는 PE들로부터의 컨볼루 션 연산 결과들을 출력하는 것에 응답하여, 아웃 플롭(예를 들어, 하나 이상의 레지스터 또는 플롭플롭 디 바이스들)은 버퍼들(267 및 268)의 대응하는 컬럼 위치들(또는 컬럼 뱅크들)에 컨볼루션 연산들의 결과들을 기 록할 수 있다. 일부 실시예들에서, 제1 메모리 및 제2 메모리 각각은 고정 피연산자를 유지하기 위한 다수의 FLOP들 (플립플롭들 또는 레지스터들) 또는 래치들을 포함할 수 있으므로, (예를 들어, 저장 디바이스로부터) 페 치들의 수를 감소시켜 에너지를 절감할 수 있다. 일부 실시예들에서, 캐시 또는 버퍼 메모리(예를 들어, SRAM) 는 제1 메모리 및 제2 메모리 각각으로 사용될 수 있다. 일부 실시예들에서, 제2 메모리는 최대 (K × R) 차원의 피연산자를 저장할 수 있으며, 여기서 R은 N 이하일 수 있다. 예를 들어, 제1 메모리 및 제2 메모리 각각은 최대 32바이트의 데이터를 저장할 수 있다. 이 구성으로 각각의 PE는 컨볼루션/GEMM의 축소 된 크기 또는 차원들이 K × R 이하일 때 고정 피연산자(예를 들어, SRAM으로부터)의 중복 페치들을 방지하기 위해 고정 피연산자로서 최대 (K × R) 차원의 커널 데이터(예를 들어, 커널 행렬)를 유지할 수 있다. 유사하게, 일부 실시예들에서, 제1 메모리는 최대 (S × K) 입력 스트림을 저장할 수 있으며, 여기서 S는 M 이하이다. 이러한 구성으로, 각각의 PE는 S가 1보다 클 때 입력 스트림 데이터가 페치되어야 하는(예를 들어, SRAM으로부터) 횟수를 줄이기 위해 최대 (S × K) 입력 스트림 데이터(예를 들어, 입력 행렬)를 유지할 수 있다. 이 경우, 입력 스트림 데이터는 예를 들어 SRAM으로부터 새 입력 스트림 데이터를 페치하지 않고 최대 S 번까지 재사용될 수 있다. 도 2g는 본 개시내용의 예시적인 구현에 따른, AI 관련 처리의 출력들의 서브어레이들에 PE들을 할당하기 위한 방법의 실시예의 블록도이다. 도 2g를 참조하면, 그리고 일부 실시예들에서, 가속기는 (M × N) PE 어레이또는 행렬, 및 입력 스트림 버퍼를 포함할 수 있다. 일부 실시예들에서, 가속기의 각각의 PE는 도 2f의 PE의 것과 유사한 구성을 가질 수 있다. 일부 실시예들에서, (M × N)의 차원들을 갖는 PE 어레이 에 대해, 프로세서는 신경망의 계층에 대한 복수의 출력들을 생성하기 위해 입력 데이터를 수신할 수 있다. 예 를 들어, 도 2g를 참조하면, 복수의 출력들이 (M/2 × 2N) 어레이(미도시)로 배열되면, 프로세서는 (M/2 × 2N) 어레이의 차원들을 (M × N) 차원의 PE 어레이의 차원들과 비교할 수 있다. (M/2 × 2N) 어레이의 컬럼 차원, 즉 2N이 PE의 대응하는 차원, 즉 N 이하라는 결정에 응답하여, 프로세서는 (M/2 × 2N) 어레이를 (M × N) PE 어레이에 적합하도록 2개의 서브어레이들, 예를 들어 제1 서브어레이 및 제2 서브어레이로 분할하여, 제1 서브 어레이 및 제2 서브어레이 각각이 PE 어레이의 차원들(M × N) 이하의 (M/2 × N)의 차원들을 갖도록 할 수 있 다. 다시 도 2g를 참조하면, (M/2 × 2N) 어레이를 (M/2 × N) 제1 서브어레이 및 (M/2 × N) 제2 서브어레이로 분 할(또는 쪼개거나 나누거나 매핑)하는 것에 응답하여, 프로세서는 (M/2 × N) 제1 서브어레이를 PE 어레이의 (M/2 × N) 블록들에 할당하고 (M/2 × N) 제2 서브어레이를 PE 어레이의 (M/2 × N) 블록에 할당한 다. 일부 실시예들에서, (M/2 × N) 제1 서브어레이는 (M/2 × N) 블록들로 타일링되거나 매핑될 수 있고 (M/2 × K) 입력 스트림 및 (K × N) 피연산자 데이터를 사용하여 업데이트될 수 있다. 일부 실시예 들에서, (M/2 × N) 제1 서브어레이에 할당된 (M/2 × N) 블록들의 각각의 PE는 (M/2 × K) 입력 스트림 및 (K × N) 피연산자 데이터의 일부를 사용하여 (M/2 × N) 제1 서브어레이의 대응하는 출력을 생 성하거나 업데이트할 수 있다. 일부 실시예들에서, (M/2 × N) 블록들의 각각의 PE는 대응하는 생성되거나 업데이트된 출력을 (M/2 × N) 출력 데이터로서 대응하는 버퍼(예를 들어, 도 1b의 버퍼)에 저장할 수 있다. 유사하게, 일부 실시예들에서, (M/2 × N) 제2 서브어레이는 (M/2 × N) 블록들로 타일링되거나 매핑될 수 있고 (M/2 × K) 입력 스트림 및 (K × N) 피연산자 데이터를 사용하여 업데이트될 수 있 다. 일부 실시예들에서, (M/2 × N) 제2 서브어레이에 할당된 (M/2 × N) 블록들의 각각의 PE는 (M/2 × K) 입력 스트림 및 (K × N) 피연산자 데이터의 일부를 사용하여 (M/2 × N) 제2 서브어레이의 대응 하는 출력을 생성하거나 업데이트할 수 있다. 일부 실시예들에서, (M/2 × N) 블록들의 각각의 PE는 대응 하는 생성되거나 업데이트된 데이터를 (M/2 × N) 출력 데이터로서 대응하는 버퍼(예를 들어, 도 1b의 버 퍼)에 저장할 수 있다. 일부 실시예들에서, (M/2 × N) 블록들 및 (M/2 × N) 블록들의 PE들에 대한 입력 데이터 구조는 프 로세서에 의해 결정될 수 있다. 프로세서는 분할에 따라, 입력 데이터의 특정 부분들을 다양한 서브어레이들의 PE들에 향하게 하거나 라우팅하는 방법을 결정할 수 있다. 일부 실시예들에서, 프로세서는 (M/2 × N) 블록들 및 (M/2 × N) 블록들 사이에서 공유되고 처리되어야 하는 입력 데이터의 공통 부분을 식별할 수 있 다. 예를 들어, 프로세서는 (M/2 × K) 입력 스트림을 공통 부분으로 식별하고 가속기가 (M/2 × K) 입력 스트림을 (M/2 × N) 블록들 및 (M/2 × N) 블록들 모두에 향하게 하거나, 시프트하거나 또는 라우팅하도록 할 수 있다. 일부 실시예들에서, 프로세서는 (M/2 × N) 블록들에 사용되는 입력 데이 터의 일부를 식별할 수 있다. 예를 들어, 프로세서는 (K × N) 피연산자 데이터를 (M/2 × N) 블록들(27 7)에 사용되는 입력 데이터의 일부로서 식별할 수 있고, 가속기가 (K × N) 피연산자 데이터를 (M/2 × N) 블록들에 향하게 하거나, 시프트하거나 또는 라우팅하도록 할 수 있다. 유사하게, 프로세서는 (K × N) 피연산자 데이터를 (M/2 × N) 블록들에 사용되는 입력 데이터의 일부로 식별할 수 있고 가속기 가 (K × N) 피연산자 데이터를 (M/2 × N) 블록들에 향하게 하거나, 시프트하거나 또는 라우팅 하도록 할 수 있다. 일부 실시예들에서, (M/2 × N) 블록들에서 각각의 PE의 제2 메모리(도 2f 참조)는 SRAM으로부터 고 정 피연산자의 중복 페치들을 방지하기 위해, (K × N) 피연산자 데이터로부터 최대 (K × R)개의 피연산 자(R은 N 이하임)를 저장할 수 있다. 유사하게, (M/2 × N) 블록들에서 각각의 PE의 제2 메모리(도 2f 참조)는 RAM으로부터 고정 피연산자의 중복 페치들을 방지하기 위해, (K × R) 피연산자 데이터로부터 최대 (K × R)개의 피연산자(R은 N 이하임)를 저장할 수 있다. 일부 실시예들에서, (M/2 × N) 블록들에서 각각의 PE의 제1 메모리(도 2f 참조)는 (M/2 × K) 차원 의 또는 크기의 입력 스트림으로부터 최대 (S × K) 차원의 또는 크기의 입력 스트림(S는 M 이하임)을 저 장할 수 있음으로써, SRAM으로부터 새로운 입력 스트림 데이터를 페치하지 않고 입력 스트림 데이터를 최대 S번 까지 재사용할 수 있다. 유사하게, (M/2 × N) 블록들에서 각각의 PE의 제1 메모리(도 2f 참조)는 (M/2 × K) 차원의 또는 크기의 입력 스트림으로부터 최대 (S × K) 차원의 또는 크기의 입력 스트림(S는 M 이하임)을 저장할 수 있음으로써, SRAM으로부터 새로운 입력 스트림 데이터를 페치하지 않고 입력 스트림 데이터를 최대 S번까지 재사용할 수 있다. 도 2h는 본 개시내용의 예시적인 구현에 따른, AI 관련 처리의 출력들에, 상이한(예를 들어, 분리된 또는 개별 의) 위치들에 있는 2개의 그룹들의 PE들을 할당하기 위한 방법의 실시예의 블록도이다. 도 2h를 참조하면, 그리 고 일부 실시예들에서, (M × N)의 차원들을 갖는 PE 어레이에 대해, 프로세서는 (입력 스트림들(281, 282)에 대응하는) 2개의 개별 입력 데이터를 수신할 수 있고, 이들 각각은 신경망의 계층에 대해 어레이로 배열된 각각 의 복수의 출력들을 생성하는데 사용된다. 예를 들어, 도 2h를 참조하면, 프로세서는 (M/2 × N/2) 제1 출력 어 레이(미도시) 및 (M/2 × N/2) 제2 출력 어레이들(미도시)에 각각 대응하는 2개의 입력 데이터를 수신할 수 있 고, 이들 둘다 PE 어레이의 차원들(M × N) 이하의 차원들을 가진다. (M/2 × N/2) 제1 출력 어레이 및 (M/2 × N/2) 제2 서브어레이를 식별하는 것에 응답하여, 프로세서는 (M/2 × N/2) 제1 출력 어레이를 PE 어레이의 (M/2 × N/2) 블록들에 할당할 수 있고 (M/2 × N/2) 제2 출력 어레이를 PE 어레이의 (M/2 × N/2) 블록들 에 할당할 수 있다. 일부 실시예들에서, (M/2 × N/2) 제1 출력 어레이는 (M/2 × N/2) 블록들로 타 일링되거나 매핑될 수 있고 (M/2 × K/2) 입력 스트림 및 (K/2 × N/2) 피연산자 데이터를 사용하여 업데이트될 수 있다. 일부 실시예들에서, (M/2 × N/2) 제1 출력 어레이에 할당된 (M/2 × N/2) 블록들의 각각의 PE는 (M/2 × K/2) 입력 스트림 및 (K/2 × N/2) 피연산자 데이터의 일부를 사용하여 (M/2 × N/2) 제1 출력 어레이의 대응하는 출력을 생성 또는 업데이트할 수 있다. 일부 실시예들에서, (M/2 × N/2) 블록들의 각각의 PE는 대응하는 생성된 또는 업데이트된 출력을 (M/2 × N/2) 출력 데이터로서 대응 하는 버퍼(예를 들어, 도 1b의 버퍼)에 저장할 수 있다. 유사하게, 일부 실시예들에서, (M/2 × N/2) 제2 출력 어레이는 (M/2 × N/2) 블록들로 타일링되거나 매핑될 수 있고 (M/2 × K/2) 입력 스트림 및 (K/2 × N/2) 피연산자 데이터를 사용하여 업데이트될 수 있다. 일부 실시예들에서, (M/2 × N/2) 제2 출 력 어레이에 할당된 (M/2 × N/2) 블록들의 각각의 PE는 (M/2 × K/2) 입력 스트림 및 (K/2 × N/2) 피연산자 데이터의 일부를 사용하여 (M/2 × N/2) 제2 출력 어레이의 대응하는 출력을 생성하거나 업데이 트할 수 있다. 일부 실시예들에서, (M/2 × N/2) 블록들의 각각의 PE는 대응하는 생성된 또는 업데이트된 출력을 (M/2 × N/2) 출력 데이터로서 대응하는 버퍼(예를 들어, 도 1b의 버퍼)에 저장할 수 있다. 일부 실시예들에서, (M/2 × N/2) 블록들 및 (M/2 × N/2) 블록들의 PE들에 대한 입력 데이터 구조는 프로세서에 의해 결정될 수 있다. 일부 실시예들에서, 제1 및 제2 출력 어레이들에 대한 2개의 입력 데이터가 서로 분리되어 있음을 식별하는 것에 응답하여, 프로세서는 (예를 들어, PE들의 서브어레이들로서) (M/2 × N/2) 블록들 및 (M/2 × N/2) 블록들 중에서 입력 데이터의 공통 부분이 없다고 결정할 수 있다. 일 부 실시예들에서, (M/2 × N/2) 블록들 및 (M/2 × N/2) 블록들 중에서 입력 데이터의 공통 부분이 없다는 결정에 응답하여, 프로세서는 (M/2 × N/2) 제1 출력 어레이 및 (M/2 × N/2) 제2 출력 어레이를 상이한 (예를 들어, 개별 또는 분리된) 위치들에 있는 PE들의 2개의 서브어레이들에, 예를 들어 PE 어레이의 (M/2 × N/2) 블록들 및 PE 어레이의 (M/2 × N/2) 블록들에 할당할 수 있다. 본 개시내용의 일부 실시예들에 서, 디바이스(예를 들어, 도 2b의 가속기)는 디바이스의 프로세서(예를 들어, 도 1a의 프로세서) 및 처리 유닛(PE) 어레이(예를 들어, 도 2b의 (M × N) PE 어레이)를 포함할 수 있다. PE 어레이는 복수의 PE들(예 를 들어, 도 2b의 PE들)을 포함할 수 있다. 프로세서는 입력 데이터를 수신하여 신경망의 계층의 하나 이 상의 뉴런들/노드들에 대한 복수의 출력들을 생성하도록 구성될 수 있으며, 복수의 출력들은 제1 어레이에 배열 된다. 일부 실시예들에서, 복수의 출력들은 신경망의 계층에 대한 컨볼루션 연산들의 출력들(도 2a 참조)일 수 있다. 프로세서는 제1 어레이의 차원들을 PE 어레이의 차원들(예를 들어, 도 2b의 (M × N))과 비교하도록 구성 될 수 있다. 프로세서는, 비교 결과에 따라, 제1 어레이를 각각이 PE 어레이의 차원들 이하의 차원들을 갖는 서 브어레이들로 분할하도록 구성될 수 있다. 프로세서는 PE 어레이의 제1 그룹의 PE들(예를 들어, 도 2g의 PE들의 (M/2 × N) 블록들)을 서브어레이들 중 제1 서브어레이에 할당하도록 구성될 수 있다. 서브어레이들 중 제 1 서브어레이(예를 들어, 도 2g의 PE들의 (M/2 × N) 블록들)에 할당된 제1 그룹의 PE들의 각각의 PE는 입 력 데이터의 일부(예를 들어, 도 2g의 (M/2 × K) 입력 스트림, (K × N) 피연산자 데이터)를 사용하 여 복수의 출력들의 대응하는 출력을 생성하도록 구성될 수 있다. 일부 실시예들에서, PE 어레이는 2차원 M × N 어레이일 수 있다(도 2b 내지 도 2e 및 도 2g 내지 도 2h 참조). M 및 N 각각은 1보다 큰 정수이다. 프로세서는 M × N 어레이(도 2b 참조), M × N/2 어레이(도 2d 참조), M/2 × N 어레이(도 2c 참조), M/2 × N/2 어레이(도 2e 참조), 및/또는 다양한 차원들의 다른 어레이 중 하나 이상 을 제공하기 위해 제1 어레이를 분할하도록 구성될 수 있다. 일부 실시예들에서, 프로세서는 제1 차원에서의 제1 어레이의 크기(예를 들어, 도 2g의 (M/2 × 2N) 어레이에서 2N)가 제1 차원에서의 PE 어레이의 크기(예를 들어, 도 2g의 (M × N) PE 어레이에서 N)보다 큰지 여부를 결정하도록 구성될 수 있다. 제1 차원의 제1 어레이의 크기가 제1 차원의 PE 어레이의 크기보다 크다는 결정에 응답 하여, 프로세서는 제1 어레이를 서브어레이들 중 제1 서브어레이 및 제2 서브어레이로 분할하도록 구성될 수 있 다. 프로세서는 제1 서브어레이를 PE 어레이의 제1 그룹의 PE들(예를 들어, 도 2g의 (M/2 × N) 블록들)에 할당하고 제2 서브어레이를 제1 그룹의 PE들과 상이한 PE 어레이에서의 제2 그룹의 PE들(예를 들어, 도 2g의 M/2 × N) 블록들)에 할당하도록 구성될 수 있다. 일부 실시예들에서, 프로세서는 PE들의 제1 및 제2 그룹들 모두에 의해 사용될 입력 데이터의 공통 부분(예를 들어, 도 2g의 (M/2 × K) 입력 스트림)을 식별하도록 추가로 구성될 수 있다. 프로세서는 입력 데이터의 공통 부분(예를 들어, 도 2g의 (M/2 × K) 입력 스트림)을 제1 및 제2 그룹들의 PE들(예를 들어, 도 2g의 (M/2×N) 블록들 및 (M/2×N) 블록들에 향하게 하거나, 라우팅하거나 또는 시프트하도록 추가로 구성 될 수 있다. 일부 실시예들에서, 프로세서는 제1 그룹의 PE들에 의해 사용될 입력 데이터의 제1 부분(예를 들어, 도 2g의 (K × N) 피연산자 데이터) 및 제2 그룹의 PE들에 의해 사용될 입력 데이터의 제2 부분(예를 들어, 도 2g의 (K × N) 피연산자 데이터)을 식별하도록 추가로 구성될 수 있다. 프로세서는 입력 데이터의 제1 부분(예 를 들어, 도 2g의 (K × N) 피연산자 데이터)을 제1 그룹의 PE들(예를 들어, 도 2g의 (M/2 × N) 블록들 )에 향하거나, 라우팅하거나 또는 시프트하도록 추가로 구성될 수 있다. 프로세서는 입력 데이터의 제2 부 분(예를 들어, 도 2g의 (K × N) 피연산자 데이터)을 제2 그룹의 PE들(예를 들어, 도 2g의 (M/2 × N) 블 록들)에 향하거나, 라우팅하거나 또는 시프트하도록 추가로 구성될 수 있다. 일부 실시예들에서, 입력 데이터는 제1 복수의 입력 값들(예를 들어, 도 2a의 입력 행렬의 요소들을 나타 냄) 및 제2 복수의 입력 값들(예를 들어, 도 2a의 커널 행렬의 요소들을 나타냄)을 포함할 수 있다. 제1 그룹의 PE들(예를 들어, 도 2f의 PE)의 각각의 PE는 제1 버퍼 메모리(예를 들어, 도 2f의 제1 메모리 ), 제2 버퍼 메모리(예를 들어, 도 2f의 제1 메모리), 및/또는 곱셈기 및 누산기(MAC) 회로(예를 들 어, 도 1c의 MAC 유닛)를 포함할 수 있다. 복수의 출력들의 대응하는 출력을 생성할 때, 제1 그룹의 PE들 의 각각의 PE는 제1 복수의 입력 값들의 제1 값들(예를 들어, 도 2f의 제1 벡터) 및 제2 복수의 입력 값들의 제 2 값들(예를 들어, 도 2f의 제2 벡터)을 수신하도록 구성될 수 있다. 제1 그룹의 PE들(예를 들어, 도 2f의 PE)의 각각의 PE는 제1 값들 및 제2 값들(예를 들어, 도 2f의 제1 벡터 및 제2 벡터)을 제1 버퍼 메모리 및 제2 버퍼 메모리(예를 들어, 도 2f의 제1 메모리 및 제2 메모리)에 각각 저장하도록 구성될 수 있 다. 제1 그룹의 PE들의 각각의 PE는 MAC 회로를 통해 제1 값들과 제2 값들 사이의 제1 내적(예를 들어, 도 2f의 내적) 연산의 결과를 생성하도록 구성될 수 있다. 일부 실시예들에서, 각각의 PE는 복수의 제1 입력 값들 중 제1 수의 세트들의 값들(예를 들어, 도 2f의 S 수의 제1 벡터들)을 제1 버퍼 메모리(예를 들어, 도 2f의 메모리)에 저장하도록 구성될 수 있다. 각각의 PE는 MAC 회로를 통해, (ⅰ) 제1 버퍼 메모리에 저장된 제1 수의 세트들의 값들 및 (ⅱ) 제2 버퍼 메모리에 저장된 제2 값들(예를 들어, 도 2f의 제2 메모리에 저장된 제2 벡터)의 내적(예를 들어, 내적 연산의 결과)을 계 산하도록 구성될 수 있다. 각각의 PE는 신경망의 계층에 대한 컨볼루션 연산들의 출력들로서 제1 수의 계산된 내적들(예를 들어, 도 2f의 S 수의 내적들)을 출력하도록 구성될 수 있다. 일부 실시예들에서, 각각의 PE는 복수의 제2 입력 값들 중에서 제2 수의 세트들의 값들(예를 들어, 도 2f의 R 수의 제2 벡터들)을 제2 버퍼 메모리(예를 들어, 도 2f의 제2 메모리)에 저장하도록 구성될 수 있다. 각각 의 PE는 MAC 회로를 통해 (ⅰ) 제1 버퍼 메모리에 저장된 제1 값들(예를 들어, 도 2f의 제2 메모리에 저장 된 제1 벡터) 및 (ⅱ) 제2 버퍼 메모리에 저장된 제2 수의 세트들의 값들의 각각의 내적(예를 들어, 내적 연산 의 결과)을 계산하도록 구성될 수 있다. 각각의 PE는 신경망의 계층에 대한 컨볼루션 연산들의 출력들로서 제2 수의 계산된 내적들(예를 들어, 도 2f의 R 수의 내적들)을 출력하도록 구성될 수 있다. 일부 실시예들에서, 제1 복수의 입력 값들은: 신경망의 계층에 대한 입력 데이터 스트림들(예를 들어, 도 2a의 입력 행렬) 및 가중치들(예를 들어, 도 2a의 커널 행렬) 중 하나를 나타낼 수 있다. 제2 복수의 입력 값들은: 신경망의 계층에 대한 입력 데이터 스트림들 및 가중치들 중 다른 하나를 나타낼 수 있다. 도 2i는 본 개시내용의 예시적인 구현에 따른, 신경망의 계층에 대한 복수의 출력들을 생성하기 위한 프로세스 를 예시하는 흐름도이다. 일부 실시예들에서, 이 방법은 프로세서에 의해 신경망의 계층에 대한 복수의 출력들 을 생성하기 위해 입력 데이터를 수신하는 단계를 포함하고, 복수의 출력들은 제1 어레이에 배열된다. 이 방법은 프로세서에 의해 복수의 PE들을 포함하는 처리 유닛(PE) 어레이의 차원들과 제1 어레이의 차원들을 비교 하는 단계를 포함할 수 있다. 이 방법은 프로세서에 의해 비교 결과에 따라 제1 어레이를 서브어레이들로분할하는 단계를 포함할 수 있다. 각각의 서브어레이들은 PE 어레이의 차원들 이하의 차원들을 가질 수 있 다. 이 방법은 프로세서에 의해 PE 어레이의 제1 그룹의 PE들을 서브어레이들 중 제1 서브어레이에 할당하는 단 계를 포함할 수 있다. 이 방법은 서브어레이들 중 제1 서브어레이에 할당된 제1 그룹의 PE들의 각각의 PE 에 의해, 입력 데이터의 일부를 사용하여 복수의 출력들의 대응하는 출력을 생성하는 단계를 포함할 수 있다. 291의 추가 세부사항들에서, 그리고 일부 실시예들에서, 가속기의 프로세서(예를 들어, 도 1a의 프로세서(12 4))는 신경망의 계층에 대한 복수의 출력들을 생성하기 위해 입력 데이터를 수신하고, 복수의 출력들은 제1 어 레이에 배열된다. 일부 실시예들에서, 복수의 출력들은 신경망의 계층에 대한 컨볼루션 연산들의 출력들(도 2a 참조)일 수 있다. 예를 들어, 도 2g를 참조하면, 제1 어레이는 (M/2 × 2N)의 차원들을 가질 수 있다. 292의 추가 세부사항들에서, 그리고 일부 실시예들에서, 프로세서는 복수의 PE들(예를 들어, 도 2b의 PE들 )를 포함하는 처리 유닛(PE) 어레이(예를 들어, 도 2b의 (M × N) PE 어레이)의 차원들(예를 들어, 도 2b 의 (M × N))과 제1 어레이의 차원들을 와 비교한다. 일부 실시예들에서, PE 어레이는 2차원 M × N 어레이(도 2b 내지 도 2e 및 도 2g 내지 도 2h 참조)일 수 있고, M 및 N 각각은 1보다 큰 정수일 수 있다. 일부 실시예들 에서, 프로세서는 제1 차원의 제1 어레이의 크기(예를 들어, 도 2g의 (M/2 × 2N) 어레이의 2N)가 제1 차원의 PE 어레이의 크기(예를 들어, 도 2g의 (M × N) PE 어레이의 N)보다 큰지의 여부를 결정할 수 있다. 293의 추가 세부사항들에서, 그리고 일부 실시예들에서, 비교 결과에 따라, 프로세서는 제1 어레이를 서브어레 이들로 분할할 수 있다. 일부 실시예들에서, 서브어레이들의 각각은 PE 어레이의 차원들 이하의 차원들을 가질 수 있다. 예를 들어, 도 2g에서, 제1 서브어레이 및 제2 서브어레이 각각은 PE 어레이의 차원들(즉, M × N) 이 하의 (M/2 × N) 차원들을 갖는다. 일부 실시예들에서, 제1 차원의 제1 어레이의 크기(예를 들어, 도 2g의 (M/2 × 2N) 어레이의 2N)가 제1 차원의 PE 어레이의 크기(예를 들어, 도 2g의 (M × N) PE 어레이의 N)보다 크다는 결정에 응답하여, 프로세서는 제1 어레이를 서브어레이들 중 제1 서브어레이와 제2 서브어레이로 분할할 수 있 다(예를 들어, (M/2 × 2N) 어레이는 도 2g의 2개의 (M/2 × N) 서브어레이들로 분할된다). 294의 추가 세부사항들에서, 그리고 일부 실시예들에서, 프로세서는 PE 어레이의 제1 그룹의 PE들(예를 들어, 도 2g의 PE들의 (M/2 × N) 블록들)을 서브어레이들 중 제1 서브어레이(예를 들어, 도 2g의 (M/2 × N) 어 레이)에 할당할 수 있다. 일부 실시예들에서, 프로세서는 제1 서브어레이를 PE 어레이의 제1 그룹의 PE들에 할 당하고, 제2 서브어레이(예를 들어, 도 2g의 (M/2 × N) 어레이)를 PE 어레이에서의 제2 그룹의 PE들(예를 들어, 도 2g의 PE들의 (M/2 × N) 블록들)에 할당할 수 있다. 제1 차원과 상이한 제2 차원에서의 제1 그룹 의 PE들(예를 들어, 도 2g의 PE들의 (M/2 × N) 블록들)의 위치들은 제2 차원의 제2 그룹의 PE들(예를 들 어, 도 2g의 PE들의 (M/2 × N) 블록들)의 위치들과 상이할 수 있다. 일부 실시예들에서, 프로세서는 제1 및 제2 그룹들의 PE들 모두에 의해 사용될 입력 데이터의 공통 부분(예를 들어, 도 2g의 (M/2 × K) 입력 스트림)을 식별할 수 있다. 프로세서는 입력 데이터의 공통 부분(예를 들 어, 도 2g의 (M/2 × K) 입력 스트림)을 제1 및 제2 그룹들의 PE들(예를 들어, 도 2g의 (M/2 × N) 블록 들 및 (M/2 × N) 블록들)에 향하게 하거나, 라우팅하거나 또는 시프트할 수 있다. 일부 실시예들에서, 프로세서는 제1 그룹의 PE들(예를 들어, 도 2g의 (M/2 × N) 블록들)에 의해 사용될 입력 데이터의 제1 부분(예를 들어, 도 2g의 (K × N) 피연산자 데이터), 및 제2 그룹의 PE들(예를 들어, 도 2g의 (M/2 × N) 블록들)에 의해 사용될 입력 데이터의 제2 부분(예를 들어, 도 2g의 (K × N) 피연산 자 데이터)를 식별할 수 있다. 프로세서는 입력 데이터의 제1 부분(예를 들어, 도 2g의 (K × N) 피연산자 데이터)을 제1 그룹의 PE들(예를 들어, 도 2g의 (M/2 × N) 블록들)에 향하게 하거나, 라우팅하거나 또는 시프트할 수 있다. 프로세서는 입력 데이터의 제2 부분(예를 들어, 도 2g의 (K × N) 피연산자 데이터 )을 제2 그룹의 PE들(예를 들어, 도 2g의 (M/2 × N) 블록들)에 향하게 하거나, 라우팅하거나 또는 시프트할 수 있다. 295의 추가 세부사항들에서, 서브어레이들 중 제1 서브어레이(예를 들어, 도 2g의 PE들의 (M/2 × N) 블록들 )에 할당된 제1 그룹의 PE들의 각각의 PE는 입력 데이터(예를 들어, 도 2g의 (M/2 × K) 입력 스트림 및 (K × N) 피연산자 데이터)의 일부를 사용하여 복수의 출력들의 대응하는 출력을 생성할 수 있다. 일부 실시예들에서, 입력 데이터는 제1 복수의 입력 값들(예를 들어, 도 2a의 입력 행렬) 및 제2 복수의 입력 값들(예를 들어, 도 2a의 커널 행렬)을 포함할 수 있다. 일부 실시예들에서, 제1 복수의 입력 값들은 신경 망의 계층에 대한 입력 데이터 스트림들(예를 들어, 도 2a의 입력 행렬) 및 가중치들(예를 들어, 도 2a의 커널 행렬) 중 하나를 나타낼 수 있다. 일부 실시예들에서, 제2 복수의 입력 값들은 신경망의 계층에 대한 입력 데이터 스트림들 및 가중치들 중 다른 하나를 나타낼 수 있다. 제1 그룹의 PE들의 각각의 PE에 의해 복수의 출력들의 대응하는 출력을 생성할 때, 각각의 PE는 제1 복수의 입력 값들의 제1 값들(예를 들어, 도 2f의 제 1 벡터) 및 제2 복수의 입력 값들의 제2 값들(예를 들어, 예를 들어, 도 2f의 제2 벡터)을 수신할 수 있다. 각 각의 PE는 제1 값들 및 제2 값들을 상기 각각의 PE의 제1 버퍼 메모리 및 제2 버퍼 메모리(예를 들어, 도 2f의 제1 메모리 및 제2 메모리)에 각각 저장할 수 있다. 각각의 PE(예를 들어, 도 1c의 MAC 유닛)의 곱셈기 및 누산기(MAC) 회로는 제1 값들과 제2 값들의 제1 내적(예를 들어, 도 2f의 내적)을 생성하거나 계산할 수 있다. 일부 실시예들에서, 각각의 PE의 제1 버퍼 메모리(예를 들어, 도 2f의 제1 메모리)는 제1 복수의 입력 값 들 중에서 제1 수의 세트들의 값들(예를 들어, 도 2f의 S 수의 제1 벡터들)을 저장할 수 있다. MAC 회로는 (ⅰ) 각각의 PE의 제1 버퍼 메모리에 저장된 제1 수의 세트들의 값들의 각각과 (ⅱ) 각각의 PE의 제2 버퍼 메모리에 저장된 제2 값들(예를 들어, 도 2f의 제2 메모리에 저장된 제 2 벡터)의 내적을 계산할 수 있다. 제1 수의 계산된 내적들(예를 들어, 도 2f의 S 수의 내적들)은 신경망의 계층에 대한 컨볼루션 연산들의 출력들일 수 있 다. 일부 실시예들에서, 각각의 PE의 제2 버퍼 메모리(예를 들어, 도 2f의 제2 메모리)는 복수의 제2 입력 값 들 중에서 제2 수의 세트들의 값들(예를 들어, 도 2f의 R 수의 제 2벡터들)을 저장할 수 있다. MAC 회로는 (ⅰ) 상기 각각의 PE의 제1 버퍼 메모리에 저장된 제1 값들(예를 들어, 도 2f의 제1 메모리에 저장된 제1 벡 터)과 (ⅱ) 각각의 PE의 제2 버퍼 메모리에 저장된 제2 수의 세트들의 값들 각각의 내적을 계산하여 출력할 수 있다. 제2 수의 계산된 내적들(예를 들어, 도 2f의 R 수의 내적들)은 신경망의 계층에 대한 컨볼루션 연산들의 출력들일 수 있다. 이제 일부 예시적인 구현들을 설명했지만, 전술한 내용은 예시적인 것이며 제한적이지 않다는 것이 명백하다. 특히, 본 명세서에 제시된 많은 예들이 방법 동작들 또는 시스템 요소들의 특정 조합들을 수반하지만, 그러한 동작들 및 이러한 요소들은 동일한 목적들을 달성하기 위해 다른 방식들로 조합될 수 있다. 하나의 구현과 관련 하여 논의된 동작들, 요소들 및 특징들이 다른 구현들에서 유사한 역할에서 배제하려는 것은 아니다. 본 명세서에 개시된 실시예들과 관련하여 설명된 다양한 프로세스들, 동작들, 예시적인 논리들, 논리 블록들, 모듈들 및 회로들을 구현하는 데 사용되는 하드웨어 및 데이터 처리 구성요소들은 범용 단일- 또는 다중-칩 프 로세서, 디지털 신호 프로세서(DSP: digital signal processor), 주문형 반도체(ASIC: Application Specific Integrated Circuit), 필드 프로그래머블 게이터 어레이(FPGA: Field Programmable Gate Array) 또는 기타 프 로그램 가능한 논리 디바이스, 이산 게이트 또는 트랜지스터 논리, 이산 하드웨어 구성요소들 또는 본 명세서의 기능들을 수행하도록 설계된 이들의 임의의 조합으로 구현되거나 수행될 수 있다. 범용 프로세서는 마이크로프 로세서, 또는 임의의 기존 프로세서, 컨트롤러, 마이크로컨트롤러 또는 상태 머신일 수 있다. 프로세서는 또한 DSP와 마이크로프로세서의 조합, 복수의 마이크로프로세서들, DSP 코어와 조합된 하나 이상의 마이크로프로세서 들, 또는 임의의 다른 그러한 구성과 같은 컴퓨팅 디바이스들의 조합으로서 구현될 수 있다. 일부 실시예들에서, 특정 프로세스들 및 방법들은 주어진 기능에 특정한 회로에 의해 수행될 수 있다. 메모리(예를 들어, 메모리, 메모리 유닛, 저장 디바이스 등)는 본 개시내용에 설명된 다양한 프로세스들, 계층들 및 모듈들 을 완료하거나 용이하게 하는 데이터 및/또는 컴퓨터 코드를 저장하기 위한 하나 이상의 디바이스들(예를 들어, RAM, ROM, 플래시 메모리, 하드 디스크 저장장치 등)을 포함할 수 있다. 메모리는 휘발성 메모리 또는 비휘발성 메모리이거나 이를 포함할 수 있고, 데이터베이스 구성요소들, 객체 코드 구성요소들, 스크립트 구성요소들, 또 는 본 개시내용에 설명된 다양한 활동들 및 정보 구조들을 지원하기 위한 임의의 다른 타입의 정보 구조를 포함 할 수 있다. 예시적인 실시예에 따르면, 메모리는 처리 회로를 통해 프로세서에 통신 가능하게 연결되고 본 명 세서에 설명된 하나 이상의 프로세스들을 (예를 들어, 처리 회로 및/또는 프로세서에 의해) 실행하기 위한 컴퓨 터 코드를 포함한다. 본 개시내용은 다양한 동작들을 달성하기 위한 임의의 기계-판독가능 매체 들 상의 방법들, 시스템들 및 프로그 램 제품들을 고려한다. 본 개시내용의 실시예들은 기존의 컴퓨터 프로세서들을 사용하여, 또는 이 목적 또는 다 른 목적을 위해 통합된 적절한 시스템을 위한 특수 목적 컴퓨터 프로세서에 의해, 또는 하드와이어드 시스템에 의해 구현될 수 있다. 본 개시내용의 범위 내의 실시예들은 기계-실행 가능한 명령들 또는 데이터 구조들이 저 장되거나 이를 운반하기 위한 기계-판독 가능한 매체들을 포함하는 프로그램 제품들을 포함한다. 이러한 기계- 판독 가능한 매체들은 범용 또는 특수 목적 컴퓨터 또는 프로세서를 가진 기타 기계에 의해 액세스될 수 있는 임의의 사용 가능한 매체들일 수 있다. 예를 들어, 이러한 기계-판독 가능한 매체들은 RAM, ROM, EPROM, EEPROM, 또는 기타 광 디스크 저장장치, 자기 디스크 저장장치 또는 기타 자기 저장 디바이스들, 또는 원하는 프로그램 코드를 기계-실행 가능한 명령들 또는 데이터 구조들의 형태로 운반하거나 저장하는데 사용될 수 있고범용 또는 특수 목적 컴퓨터 또는 프로세서를 가진 기타 기계에 의해 액세스될 수 있는 임의의 다른 매체를 포 함할 수 있다. 위의 조합들도 기계-판독 가능한 매체들의 범위 내에 포함된다. 기계-실행 가능한 명령들에는 예 를 들어 범용 컴퓨터, 특수 목적 컴퓨터 또는 특수 목적 처리 기계가 특정 기능 또는 기능들의 그룹을 수행하도 록 하는 명령들 및 데이터를 포함한다. 본 명세서에 사용된 어구 및 용어는 설명을 위한 것이며 제한하는 것으로 간주되어서는 안 된다. 본 명세서에서 \"포함하는(including 및 comprising)\", \"갖는(having)\", \"포함하는(containing)\", \"수반하는(involving)\", \"에 의해 특징지어지는(characterized by)\" \"하는 것을 특징으로 하는(characterized in that)\" 및 그 변형들의 사 용은 이후에 나열된 항목들, 그 등가물 및 추가 항목들뿐만 아니라, 그 이후에 독점적으로 나열된 항목들로 구 성된 대안적인 구현들을 포함하는 것을 의미한다. 일 구현에서, 본 명세서에 설명된 시스템들 및 방법들은 설명 된 요소들, 동작들 또는 구성요소들 중 하나 이상, 또는 모두의 각각의 조합으로 구성된다. 본 명세서에서 단수로 언급된 시스템들 및 방법들의 구현들 또는 요소들 또는 동작들에 대한 임의의 참조들은 또한 복수의 이러한 요소들을 포함하는 구현들을 포함할 수 있고, 본 명세서에서 임의의 구현 또는 요소들 또는 동작들에 대한 복수의 참조들은 또한 단일 요소만을 포함하는 구현들을 포함할 수 있다. 단수 또는 복수 형태의 참조들은 현재 개시된 시스템들 또는 방법들, 그 구성요소들, 동작들 또는 요소들을 단일 또는 복수 구성들로 제한하려는 것이 아니다. 임의의 정보, 동작 또는 요소에 기초하는 임의의 동작 또는 요소에 대한 참조들은 동 작 또는 요소가 임의의 정보, 동작 또는 요소에 적어도 부분적으로 기초하는 구현들을 포함할 수 있다. 본 명세서에 개시된 임의의 구현은 임의의 다른 구현 또는 실시예와 조합될 수 있으며, \"구현(an implementation)\", \"일부 구현들(some implementations)\", \"일 구현(one implementation)\" 등에 대한 참조들은 반드시 상호 배타적이지 않으며 구현과 관련하여 설명된 특정 특징, 구조 또는 특성이 적어도 하나의 구현 또는 실시예에 포함될 수 있음을 나타내려는 것이다. 본 명세서에 사용된 이러한 용어들은 반드시 모두 동일한 구현 을 지칭하는 것은 아니다. 임의의 구현은 본 명세서에 개시된 양태들 및 구현들과 일치하는 임의의 방식으로 포 괄적으로 또는 배타적으로 임의의 다른 구현과 조합될 수 있다. 도면들, 상세한 설명 또는 임의의 청구범위의 기술적 특징들에 참조 부호들이 뒤따르는 경우, 참조 부호들은 도 면들, 상세한 설명 또는 청구범위의 명료성을 높이기 위해 포함되었다. 따라서 참조 부호들이나 참조 부호들의 부재는 임의의 청구범위 요소들의 범위를 제한하는 어떠한 효과도 없다. 본 명세서에 설명된 시스템들 및 방법들은 그 특성들을 벗어나지 않고 다른 특정 형태들로 구현될 수 있다. \"대 략(approximately)\", \"약(about)\" \"실질적으로(substantially)\" 또는 다른 정도의 용어에 대한 참조들은 달리 명시적으로 표시되지 않는 한 주어진 측정, 단위 또는 범위로부터 +/-10%의 변동들을 포함한다. 결합된 요소들 은 전기적으로, 기계적으로 또는 물리적으로 서로 직접 결합되거나 중간 요소들과 결합될 수 있다. 따라서, 본 명세서에 설명된 시스템들 및 방법들의 범위는 전술한 설명보다는 첨부된 청구범위에 의해 표시되고, 청구범위 의 등가의 의미 및 범위 내에 있는 변경들은 본 명세서에 포함된다. 용어 \"결합된(coupled)\" 및 그 변형들은 서로 직접 또는 간접적으로 2개의 부재들의 결합을 포함한다. 이러한 결합은 고정식(예를 들어, 영구적 또는 고정적) 또는 이동식(예를 들어, 제거 가능한 또는 해제 가능한)일 수 있다. 이러한 결합은 2개의 부재들이 직접 결합되거나 서로 결합되거나, 2개의 부재들이 별도의 중간 부재 및 서로 결합된 임의의 추가적인 중간 부재들을 사용하여 서로 결합되거나, 또는 2개의 부재들 중 하나와 함께 단 일체로 일체로 형성되는 중간 부재를 사용하여 서로 결합되어 달성될 수 있다. \"결합된\" 또는 그 변형들이 추가 용어에 의해 수정된(예를 들어, 직접 결합된) 경우, 위에 제공된 \"결합된\"의 일반적인 규정은 추가 용어의 일반 적인 언어 의미로 수정하여(예를 들어, \"직접 결합된(directly coupled)\"은 별도의 중간 부재 없이 2개의 부재 들의 결합을 의미), 위에서 제공된 \"결합된\"의 일반적인 규정보다 좁은 규정이 된다. 이러한 결합은 기계적, 전 기적 또는 유체적일 수 있다. \"또는(or)\"에 대한 참조들은 \"또는\"을 사용하여 설명된 임의의 용어들이 단일, 하나 이상 및 설명된 모든 용어 들 중 임의의 것을 나타낼 수 있도록 포괄적으로 해석될 수 있다. \"'A' 및 'B' 중 적어도 하나(at least one of 'A' and 'B')\"에 대한 참조는 'A'만, 'B'만 뿐만 아니라 'A'와 'B' 둘다를 포함할 수 있다. \"포함하는\" 또는 기 타 개방 용어와 함께 사용되는 이러한 참조들은 추가적인 항목들을 포함할 수 있다. 다양한 요소들의 크기들, 차원들, 구조들, 형상들 및 비율들의 변화들, 파라미터들의 값들, 장착 배치들, 재료 들의 사용, 색상들, 방향들과 같은 설명된 요소들 및 동작들의 수정들은 본 명세서에 개시된 요지의 교시들 및 이점들에서 크게 벗어나지 않고 발생할 수 있다. 예를 들어, 일체로 형성된 것으로 도시된 요소들은 다수의 부분들 또는 요소들로 구성될 수 있고, 요소들의 위치는 역전되거나 달리 변경될 수 있으며, 개별 요소들 또는 위 치들의 특징 또는 수는 달라지거나 변경될 수 있다. 본 개시내용의 범위를 벗어나지 않고 개시된 요소들 및 동 작들의 설계, 동작 조건들 및 배치에서 다른 대체들, 수정들, 변경들 및 생략들도 또한 이루어질 수 있다. 요소들의 위치들(예를 들어, \"상부(top)\", \"하부(bottom)\", \"위(above)\", \"아래(below)\")에 대한 본 명세서의 참조들은 단지 도면들에서 다양한 요소들의 방향을 설명하는데 사용된다. 다양한 요소들의 방향은 다른 예시적 인 실시예들에 따라 상이할 수 있으며, 이러한 변형들은 본 개시내용에 포함되도록 의도된다."}
{"patent_id": "10-2022-7004858", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1a는 본 개시내용의 예시적인 구현에 따른, 인공 지능(AI) 관련 처리를 수행하기 위한 시스템의 실시예의 블 록도. 도 1b는 본 개시내용의 예시적인 구현에 따른, AI 관련 처리를 수행하기 위한 디바이스의 실시예의 블록도. 도 1c는 본 개시내용의 예시적인 구현에 따른, AI 관련 처리를 수행하기 위한 디바이스의 실시예의 블록도. 도 1d는 본 개시내용의 예시적인 구현에 따른 컴퓨팅 환경의 블록도. 도 2a는 본 개시내용의 예시적인 구현에 따른, AI 관련 처리를 수행하기 위한 데이터의 표현을 포함한 도면.도 2b 내지 도 2e는 본 개시내용의 하나 이상의 예시적인 구현들에 따른, 신경망의 계층에 대한 복수의 출력들 을 생성하기 위한 디바이스의 실시예들의 블록도들. 도 2f는 본 개시내용의 예시적인 구현에 따른, 신경망의 계층에 대한 복수의 출력들을 생성하기 위한 처리 유닛 들(PE들)의 실시예의 블록도. 도 2g는 본 개시내용의 예시적인 구현에 따른, PE들을 출력들의 서브어레이들에 할당하기 위한 방법의 실시예의 블록도. 도 2h는 본 개시내용의 예시적인 구현에 따른, 2개의 그룹들의 PE들을 2개의 어레이들의 출력들에 할당하기 위 한 방법의 실시예의 블록도. 도 2i은 본 개시내용의 예시적인 구현에 따른, 신경망의 계층에 대한 복수의 출력들을 생성하기 위한 프로세스 를 예시하는 흐름도."}
