{"patent_id": "10-2024-7006849", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0036693", "출원번호": "10-2024-7006849", "발명의 명칭": "화면 디스플레이 방법, 장치, 전자 기기, 컴퓨터 판독 가능한 저장 매체 및 컴퓨터 프로그램", "출원인": "텐센트 테크놀로지", "발명자": "양, 광둥"}}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "화면 디스플레이 방법으로서, 상기 화면 디스플레이 방법은 전자 기기에 의해 실행되고, 상기 화면 디스플레이 방법은,모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를생성하는 단계 - 상기 모니터 정보 획득 요청은 타깃 인스턴스에 의해 발송되고, 상기 타깃 인스턴스는 복수 개의 인스턴스 중 임의의 하나의 인스턴스이며, 상기 타깃 인스턴스에 대응되는 타깃 모니터는 프라이머리 모니터또는 보조 모니터임 - ; 및상기 타깃 인스턴스가 상기 타깃 인스턴스에 대응되는 타깃 모니터를 상기 프라이머리 모니터로 결정하고, 랜더링된 화면이 상기 타깃 모니터에 디스플레이되도록 상기 프라이머리 모니터 가상 정보를 상기 타깃 인스턴스에피드백하는 단계를 포함하는 것을 특징으로 하는 화면 디스플레이 방법."}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 모니터 정보 획득 요청은 모니터 개수 획득 요청을 포함하고, 상기 프라이머리 모니터 가상 정보는 모니터개수 또는 프라이머리 모니터 식별자 특징으로 포함하며, 상기 모니터 정보 획득 요청이 수신될 때, 프라이머리모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하는 단계는, 상기 모니터 개수 획득 요청이 수신될 때, 상기 모니터 격리 장치로부터 상기 모니터 개수 또는 상기 프라이머리 모니터 식별자 특징을 판독하는 단계를 포함하고, 상기 모니터 개수는 제1 타깃 경우, 피드백해야 하는 모니터 개수이며, 상기 제1 타깃 경우는 상기 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터에 디스플레이하는 경우이고, 상기 프라이머리 모니터 식별자 특징은 상기 타깃 모니터가 프라이머리 모니터인 것을 표징하기위한 것을 특징으로 하는 화면 디스플레이 방법."}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 모니터 정보 획득 요청은 프라이머리 모니터 위치 특징 요청을 포함하고, 상기 프라이머리 모니터 가상 정보는 프라이머리 모니터 위치 특징을 포함하며, 상기 모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하는 단계는, 상기 프라이머리 모니터 위치 특징 요청이 수신될 때, 상기 모니터 격리 장치로부터 상기 프라이머리 모니터 위치 특징을 획득하는 단계를 포함하고, 상기 모니터 격리 장치는 제2 타깃 경우, 피드백해야 하는 상기 프라이머리 모니터 위치 특징을 결정하기 위한 것이며, 상기 제2 타깃 경우는 상기 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터로 전송하는 경우인 것을 특징으로 하는 화면 디스플레이 방법."}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항 또는 제3항에 있어서, 상기 프라이머리 모니터가 유일한 모니터인 경우인 것을 특징으로 하는 화면 디스플레이 방법."}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서, 랜더링된 화면을 상기 타깃 모니터에 디스플레이하기 전, 상기 화면 디스플레이 방법은, 공개특허 10-2024-0036693-3-상기 타깃 인스턴스가 상기 타깃 모니터에 대응되는 타깃 그래픽 카드에서 화면 랜더링을 수행하는 단계를 더포함하는 것을 특징으로 하는 화면 디스플레이 방법."}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 타깃 인스턴스가 상기 타깃 인스턴스에 대응되는 타깃 모니터를 상기 프라이머리 모니터로 결정하는 단계는, 상기 타깃 인스턴스가 상기 프라이머리 모니터 가상 정보에 따라, 상기 타깃 모니터를 프라이머리 모니터로 결정하는 단계를 포함하고; 상기 랜더링된 화면을 상기 타깃 모니터에 디스플레이하는 단계는, 상기 타깃 모니터에 상기 화면에 대응되는 윈도우 위치를 설정하고, 상기 화면을 상기 타깃 모니터의 상기 윈도우 위치로 전송하는 단계를 포함하는 것을 특징으로 하는 화면 디스플레이 방법."}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "화면 디스플레이 장치로서, 상기 화면 디스플레이 장치는,모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를생성하도록 구성된 시뮬레이션 모듈 - 상기 모니터 정보 획득 요청은 타깃 인스턴스에 의해 발송되고, 상기 타깃 인스턴스는 복수 개의 인스턴스 중 임의의 하나의 인스턴스이며, 상기 타깃 인스턴스에 대응되는 타깃 모니터는 프라이머리 모니터 또는 보조 모니터임 - ; 및상기 타깃 인스턴스가 상기 타깃 인스턴스에 대응되는 타깃 모니터를 상기 프라이머리 모니터로 결정하고, 랜더링된 화면이 상기 타깃 모니터에 디스플레이되도록 상기 프라이머리 모니터 가상 정보를 상기 타깃 인스턴스에피드백하도록 구성된 피드백 모듈을 포함하는 것을 특징으로 하는 화면 디스플레이 장치."}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "컴퓨터 판독 가능한 저장 매체로서, 상기 컴퓨터 판독 가능한 저장 매체에는 적어도 하나의 명령어 또는 적어도 하나의 프로그램이 저장되며, 상기적어도 하나의 명령어 또는 적어도 하나의 프로그램은 프로세서에 의해 로딩 및 실행되어 제1항 내지 제6항 중어느 한 항에 따른 화면 디스플레이 방법을 구현하는 것을 특징으로 하는 컴퓨터 판독 가능한 저장 매체."}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "전자 기기로서, 적어도 하나의 프로세서, 및 상기 적어도 하나의 프로세서와 통신 연결된 메모리를 포함하고; 상기 메모리에는상기 적어도 하나의 프로세서에 의해 실행 가능한 명령어가 저장되며, 상기 적어도 하나의 프로세서는 상기 메모리에 저장된 명령어를 실행하는 것을 통해 제1항 내지 제6항 중 어느 한 항에 따른 화면 디스플레이 방법을구현하는 것을 특징으로 하는 전자 기기."}
{"patent_id": "10-2024-7006849", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "컴퓨터 프로그램 제품으로서, 컴퓨터 프로그램 또는 명령어를 포함하며, 상기 컴퓨터 프로그램 또는 명령어가프로세서에 의해 실행될 때 제1항 내지 제6항 중 어느 한 항에 따른 화면 디스플레이 방법을 구현하는 것을 특징으로 하는 컴퓨터 프로그램 제품."}
{"patent_id": "10-2024-7006849", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 출원의 실시예는 화면 디스플레이 방법, 장치, 전자 기기, 컴퓨터 판독 가능한 저장 매체 및 컴퓨터 프로그램 제품을 제공하고, 방법은 전자 기기에 의해 실행되며, 클라우드 기술 또는 지능형 교통 등 분야에 적용될 수 있 다. 방법은, 모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하는 단계 - 모니터 정보 획득 요청은 타깃 인스턴스에 의해 발송되고, 타깃 인스턴스는 복수 개의 인스턴스 중 임의의 어느 하나의 인스턴스이며, 타깃 인스턴스에 대응되는 타깃 모니터는 프라이머리 모니 터 또는 보조 모니터임 - ; 및 타깃 인스턴스가 타깃 인스턴스에 대응되는 타깃 모니터를 프라이머리 모니터로 결정하고, 대응되는 화면을 타깃 모니터에 디스플레이하도록 프라이머리 모니터 가상 정보를 타깃 인스턴스로 피 드백하는 단계를 포함한다."}
{"patent_id": "10-2024-7006849", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "관련 출원의 상호 참조 본 출원은 출원 번호가 202210060285.2이고, 출원일이 2022년 1월 19일인 중국 특허 출원에 기반하여 제출하였 으며, 상기 중국 특허 출원의 우선권을 주장하는 바, 상기 중국 특허 출원의 모든 내용은 참조로서 본 출원에 인용된다. 본 출원의 실시예는 컴퓨터 기술 분야에 관한 것이고, 특히 화면 디스플레이 방법, 장치, 전자 기기, 컴퓨터 저 장 매체 및 컴퓨터 프로그램 제품에 관한 것이다."}
{"patent_id": "10-2024-7006849", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "컴퓨터 기술이 보급됨에 따라, 멀티 프로세스의 동시 화면 디스플레이를 지원하는 화면 디스플레이 기술은 빠르 게 발전하였다. 그러나 관련 기술에서 멀티 화면의 디스플레이는 현저히 프라이머리 모니터에 의존하며, 구체적 으로, 이러한 디스플레이 기술은 비록 동시의 방식을 통해 화면 랜더링을 수행하지만, 최종적으로 화면이 모두 프라이머리 모니터에 디스플레이된다. 이는 프라이머리 모니터의 하중이 너무 높음으로써, 동시 개수를 줄이는 것을 초래할 수 있고, 또한, 화면 디스플레이가 비정상적이고, 심지어 화면 디스플레이의 실패를 초래할 수 있 다."}
{"patent_id": "10-2024-7006849", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "상기 적어도 하나의 기술적 과제를 해결하기 위해, 본 출원의 실시예는 타깃 인스턴스가 모니터에 대해 감지를 수행하는 과정에서의 이상률을 감소시킬 수 있는 화면 디스플레이 방법, 장치, 전자 기기, 컴퓨터 저장 매체 및 컴퓨터 프로그램 제품을 제공한다."}
{"patent_id": "10-2024-7006849", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일부 실시예에 있어서, 본 출원의 실시예는 화면 디스플레이 방법을 제공하고, 상기 방법은 전자 기기에 의해 실행되며, 상기 방법은, 모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하는 단계 - 상기 모니터 정보 획득 요청은 타깃 인스턴스에 의해 발송되고, 상기 타깃 인스턴스는 복수 개 의 인스턴스 중 임의의 하나의 인스턴스이며, 상기 타깃 인스턴스에 대응되는 타깃 모니터는 프라이머리 모니터 또는 보조 모니터임 - ; 및 상기 타깃 인스턴스가 상기 타깃 인스턴스에 대응되는 타깃 모니터를 상기 프라이머리 모니터로 결정하고, 랜더 링된 화면이 상기 타깃 모니터에 디스플레이되도록 상기 프라이머리 모니터 가상 정보를 상기 타깃 인스턴스에 피드백하는 단계를 포함한다. 일부 실시예에 있어서, 본 출원의 실시예는 화면 디스플레이 장치를 제공하고, 상기 장치는, 모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하도록 구성된 시뮬레이션 모듈 - 상기 모니터 정보 획득 요청은 타깃 인스턴스에 의해 발송되고, 상기 타 깃 인스턴스는 복수 개의 인스턴스 중 임의의 하나의 인스턴스이며, 상기 타깃 인스턴스에 대응되는 타깃 모니 터는 프라이머리 모니터 또는 보조 모니터임 - ; 및 상기 타깃 인스턴스가 상기 타깃 인스턴스에 대응되는 타깃 모니터를 상기 프라이머리 모니터로 결정하고, 랜더 링된 화면이 상기 타깃 모니터에 디스플레이되도록 상기 프라이머리 모니터 가상 정보를 상기 타깃 인스턴스에 피드백하도록 구성된 피드백 모듈을 포함한다. 일부 실시예에 있어서, 본 출원의 실시예는 컴퓨터 판독 가능한 저장 매체를 제공하고, 상기 컴퓨터 판독 가능 한 저장 매체에는 적어도 하나의 명령어 또는 적어도 하나의 프로그램이 저장되며, 상기 적어도 하나의 명령어 또는 적어도 하나의 프로그램은 프로세서에 의해 로딩 및 실행되어 상기 화면 디스플레이 방법을 구현한다. 일부 실시예에 있어서, 본 출원의 실시예는 전자 기기를 제공하고, 전자 기기는 적어도 하나의 프로세서, 및 상 기 적어도 하나의 프로세서와 통신 연결된 메모리를 포함하며; 여기서, 상기 메모리에는 상기 적어도 하나의 프 로세서에 의해 실행될 수 있는 명령어가 저장되고, 상기 적어도 하나의 프로세서는 상기 메모리에 저장된 명령 어를 실행하는 것을 통해 상기 화면 디스플레이 방법을 구현한다.일부 실시예에 있어서, 본 출원의 실시예는 컴퓨터 프로그램 제품을 제공하고, 컴퓨터 프로그램 제품은 컴퓨터 프로그램 또는 명령어를 포함하며, 상기 컴퓨터 프로그램 또는 명령어가 프로세서에 의해 실행될 때 상기 화면 디스플레이 방법을 구현한다."}
{"patent_id": "10-2024-7006849", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 출원의 실시예는 프라이머리 모니터 가상 정보를 시뮬레이션하고, 프라이머리 모니터 가상 정보를 타깃 인스 턴스에 송신하는 것을 통해, 타깃 인스턴스가 타깃 인스턴스에 대응되는 타깃 모니터를 프라이머리 모니터로 결 정하고, 랜더링된 화면을 타깃 모니터에 디스플레이하도록 함으로써, 상이한 모니터 사이, 상이한 인스턴스 사 이의 격리를 구현한다. 타깃 인스턴스는 다만 그에 대응되는 타깃 모니터를 볼 수 있고, 다른 모니터의 존재를 감지할 수 없음으로써, 타깃 인스턴스가 다른 모니터의 존재를 감지하는 경우, 생성될 수 있는 각 이상, 작업하 지 않는 문제를 피함으로써, 동시 성능 병목을 돌파할 수 있다."}
{"patent_id": "10-2024-7006849", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "아래에 본 발명의 실시예의 첨부 도면을 결부하여, 본 발명의 실시예에서의 기술 방안에 대해 명확하고, 완전하 게 설명하고, 설명된 실시예는 본 발명의 실시예의 일부 실시예일 뿐 전부 실시예가 아님은 분명하다. 본 출원"}
{"patent_id": "10-2024-7006849", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "의 실시예에서의 실시예에 기반하면, 본 기술분야의 기술자가 창조성 노동을 부여하지 않는 전제 하에서 얻은 다른 실시예는 모두 본 출원의 청구 범위에 속한다. 설명해야 할 것은, 본 출원의 실시예의 명세서와 청구범위 및 상기 도면에서의 용어 \"제1\", \"제2\" 등은 유사한 대상을 구별하기 위해 사용되며, 특정 순서 또는 선후순서를 설명하기 위해 사용되는 것은 아니다. 이해해야 할 것은, 이와 같이 사용된 데이터는 적당한 경우 호환되어, 여기서 설명된 본 출원의 실시예의 실시예가 여기에서 도시되거나 설명된 것을 제외한 순서로 실시될 수 있도록 한다. 또한, 용어 \"포함\"과 \"갖는\" 및 이들의 어떤 변 형은, 이를 제외하지 않는 포함을 커버하기 위한 의도이며, 예를 들어, 일련의 단계 또는 유닛을 포함하는 과정, 방법, 시스템, 제품 또는 기기는 반드시 명백하게 나열된 해당 단계 또는 유닛으로만 한정되지 않으며, 명백하게 나열되지 않거나 이러한 과정, 방법, 제품 또는 서버에 대해 고유한 다른 단계 또는 유닛을 포함할 수있다. 본 출원의 실시예에 의해 개시된 목적, 기술방안 및 장점이 더욱 뚜렷해지도록 하기 위해, 아래에 도면 및 실시 예를 결합하여, 본 출원의 실시예를 추가로 상세하게 설명한다. 이해해야 할 것은, 여기서 설명된 구체적인 실 시예는 다만 본 출원의 실시예를 해석하기 위한 것이고, 본 출원의 실시예를 한정하려는 것이 아니다. 아래에, 용어 \"제1\", \"제2\"는 다만 목적을 설명하기 위한 것이고, 상대적 중요성을 지시하거나 암시하는 것 또 는 지시된 기술적 특징의 개수를 암시하는 것으로 이해될 수 없다. 이와 같이, \"제1\", \"제2\"로 한정된 특징은 하나 또는 더 많은 상기 특징에 명시적으로 또는 암시적으로 포함될 수 있다. 본 실시예의 설명에서, 달리 언급 되지 않는 한, \"복수 개\"는 두 개 또는 두 개 이상을 의미한다. 본 출원의 실시예의 상기의 기술 방안 및 생성 된 기술적 효과를 용이하게 이해하기 위해, 본 출원의 실시예는 먼저 관련된 기술적 용어에 대해 설명한다. 1) 지능형 교통 시스템(Intelligent Traffic System, ITS)은 또한 지능형 운송 시스템(Intelligent Transportation System)으로 지칭되며, 첨단 과학 기술(정보 기술, 컴퓨터 기술, 데이터 통신 기술, 센서 기술, 전자 제어 기술, 자동 제어 이론, 운영 연구, 인공 지능 등)을 교통 운송, 서비스 제어와 차량 제조에 효과적이 고 종합적으로 운영하고, 차량, 도로, 사용자인 삼자 사이의 관계를 가강함으로써, 안전을 보장하고, 효율을 향 상시키며, 환경을 개선하고, 에너지를 절약시키는 종합 운송 시스템을 형성한다. 2) 지능형 차량 인프라 협력 시스템(Intelligent Vehicle Infrastructure Cooperative Systems, IVICS)에 있어 서, 차량 인프라 협력 시스템으로 약칭되며, 지능형 교통 시스템의 하나의 발전 방향이다. 차량 인프라 협력 시 스템은 무선 통신과 신세대 인터넷 등 첨단기술을 채택하여, 차량간 및 차량 동적 실시간 정보 교환 인터랙션을 전방위로 실시하고, 전 시공간 동적 교통 정보 수집과 융합의 기초 위에서 차량 능동적 안전 제어 및 도로 협력 관리를 전개하여, 사람-차량-도로의 효과적인 협력을 충분히 구현하고, 교통 안전을 보장하며, 통행 효율을 향 상시킴으로써, 형성된 안전하고 고효율적이며 환경 친화적인 도로 교통 시스템이다. 3) 클라우드 게임에 있어서, 클라우드 컴퓨팅을 기반으로 하는 게임 방식이고, 클라우드 게임의 작동 모드에서, 모든 게임은 서버에서 작동되고, 랜더링 완료된 후의 게임 화면을 압축된 후 네트워크를 통해 클라이언트에 전 송된다. 클라이언트의 게임 기기는 어떤 고사양의 프로세서와 그래픽 카드도 수요로 하지 않으며, 다만 게임 작 동 지원을 구현하는 기본적인 비디오 압축 해제 능력이 수요된다. 4) 애플리케이션 프로그래밍 인터페이스(Application Programming Interface, API)에 있어서, 일부 사전 정의 된 함수이고, 목적은 애플리케이션 프로그램과 개발자가 특정된 소프트웨어 또는 하드웨어에 기반하여 하나의 그룹의 루틴에 액세스할 수 있는 능력을 제공하는 것이며, 소스 코드에 액세스하거나 내부 작업 매커니즘의 세 부사항을 이해할 필요가 없다. 5) 그래픽 카드 가상화에 있어서, 상응하는 기술을 통해, 한 장의 그래픽 카드를 복수 개의 가상 머신(VM)이 사 용하도록 제공하는 방안을 가리킨다. 상기 기술은 하드웨어와 소프트웨어를 통해 구현하는 두 가지의 방식으로 나뉘고, 여기서, 하드웨어로 구현된 그래픽 카드 가상화는 보통 그래픽 카드 제조사의 기술 지원이 수요된다. 6) 가상 머신(Virtual Machine, VM)에 있어서, 소프트웨어를 통해 시뮬레이션된 완전한 하드웨어 시스템 기능을 갖고, 하나의 완전히 격리된 환경에서 작동되는 완전한 컴퓨터 시스템을 가리킨다. VM은 가상화 플랫폼 위에서 작동되어야 한다. Guest 머신으로도 지칭될 수 있다. 7) 컨테이너(Container)에 있어서, 컨테이너 기술은 단일 운영 체제의 리소스를 격리된 그룹에 효과적으로 분할 하여, 격리된 그룹 사이의 충돌되는 리소스 사용 요구의 균형을 더욱 용이하게 잘 맞추는, 이런 기술이 컨테이 너이다. 8) 그래픽 프로세스 유닛(Graphics Processing Unit, GPU)에 있어서, 디스플레이 코어, 시각 프로세서, 디스플 레이 칩으로도 지칭되며, 전문적으로 개인용 컴퓨터, 워크 스테이션, 게임 콘솔 및 일부 모바일 기기(예를 들어 태블릿 PC, 스마트폰 등)에서 이미지와 그래픽 관련 연산 작업을 수행하는 마이크로 프로세서이다. 본 출원의 실시예에서 GPU는 그래픽 카드로 사용될 수 있다. 9) 주변 컴포넌트 상호접속 익스프레스(Peripheral Component Interconnect Express, PCIe)에 있어서, 고속 직 렬 컴퓨터 확장 버스 표준이며, PCIe은 고속 직렬 포인트 투 포인트 듀얼 채널 고대역 전송에 속하고, 연결된 기기는 전용 채널 대역폭을 할당하며, 버스 대역폭을 공유하지 않고, 능동 전원 관리, 오류 보고, 엔드 투 엔드 의 신뢰성 전송, 핫 플러그 및 서비스 품질 등 기능을 주로 지원한다. 10) 초당 프레임 수(Frame Per Second, FPS)에 있어서, FPS는 이미지 분야에서의 정의이며, 화면의 초당 프레임 수를 가리키고, 통상적으로 애니메이션 또는 비디오의 화면 수를 가리킨다. FPS는 동적 비디오를 저장 및 디스 플레이하기 위한 정보 개수를 측정한다. 초당 프레임 수가 많을수록, 디스플레이되는 동작이 더 매끄럽다. 일반 적으로, 동작이 매끄럽지 못한 것을 피하려면 가장 적어서 30개이다. 특정된 일부 컴퓨터 비디오 포맷은, 초당 15개의 프레임만 제공할 수 있다. 11) RGBA 컬러 스페이스에 있어서, 레드(Red), 그린(Green), 블루(Blue)와 Alpha를 대표하는 컬러 스페이스이다. 12) 인스턴스에 있어서, 객체 지향 프로그래밍에 있어서, 인스턴스화된 이후 클래스를 인스턴스라고 하며, 클래 스는 정적이고, 프로세스 내장 메모리를 차지하지 않고, 인스턴스는 동적 내장 메모리를 갖는다. 데이터 베이스 에 있어서, 일부 프로그램의 집합을 대표하며, 데이터 베이스의 작동을 지지할 수 있는 데이터 베이스 프로그램 을 가리킨다. 관련 기술에서는 화면 디스플레이를 수행하는 여러가지 방안을 제공할 수 있다. 물론, 본 출원의 실시예는 화면 디스플레이의 적용 시나리오를 한정하지 않으며, 예를 들어, 클라우드 게임, 클라우드 커뮤니티, 클라우드 이커 머스, 지능형 주행 등 시나리오에서 화면 디스플레이를 수행할 수 있다. 클라우드 게임을 예로 들어, 클라우드 게임은 클라우드 컴퓨팅에 기반한 게임 방식이며, 클라우드 게임의 작동 모드에서, 모든 게임은 서버에서 작동 되고, 랜더링 완료된 후의 게임 화면은 압축된 후 네트워크를 통해 클라이언트에 전송된다. 클라이언트를 작동 시키는 전자 기기는 어떤 고사양의 프로세서와 그래픽 카드도 수요로 하지 않으며, 다만 게임 작동 지원을 구현 하는 기본적인 비디오 압축 해제 능력이 수요된다. 클라우드 게임 시나리오에서, 서버에서, 하나의 운영 체제는 하나의 게임 인스턴스를 작동시킬 수 있고, 각 게 임 인스턴스는 하나의 클라이언트에 대응될 수 있으며, 서버에서 게임 인스턴스를 작동시키는 것을 통해, 디스 플레이된 화면을 압축하여 클라이언트로 전송함으로써, 클라이언트가 압축 해제를 통해 화면을 디스플레이할 수 있도록 한다. 본 출원의 실시예는 게임 인스턴스에 대해 한정하지 않는다. 본 출원의 실시예는 또한, 가상 기술에 기반하여 작동될 수 있으며, 서버에서, 하나의 운영 체제는 하나의 가상 화 애플리케이션을 작동시킬 수 있고, 각 가상화 애플리케이션은 하나의 클라이언트에 대응될 수 있으며, 서버 에서 가상화 애플리케이션을 작동시키는 것을 통해, 디스플레이된 가상화 애플리케이션의 화면을 압축하여 클라 이언트로 전송함으로써, 클라이언트가 압축 해제를 통해 화면을 디스플레이할 수 있도록 한다. 일부 실시예에 있어서, 클라우드 게임 시나리오에서, 또한, 서버의 하나의 운영 체제를 위해 복수 개의 그래픽 카드를 배치할 수 있으며, 복수 개의 게임 인스턴스를 작동시킨다. 클라우드 게임의 작동 환경에 대한 요구는, 멀티 그래픽 카드 시스템에서, 각 그래픽 카드는 하나의 모니터에 연결되어야 하며, 즉 그래픽 카드는 모니터와 일대일 맵핑을 구성해야 하는 것이다. 서버는 보통 가상 또는 시뮬레이션의 방식을 채택하여 가상 모니터를 제 공하여 그래픽 카드에 연결한다. 도 1을 참조하면, 도 1은 관련 기술에서 멀티 화면 디스플레이의 흐름 예시도 를 도시한다. 단계 01에 있어서, 클라우드 게임을 작동시킨다. 단계 02에 있어서, 클라우드 게임의 게임 엔진은 프라이머리 모니터의 메시지를 열거하고, 구체적으로, 상기 모 니터의 정보는 모니터의 거시적 개수 정보일 수 있다. 단계 03에 있어서, 각 모니터 정보를 획득하며, 구체적으로, 거시적 개수 정보를 얻을 때, 서버 환경에서의 각 모니터를 획득하고, 이러한 모니터는 진실된 것이거나 가상의 모니터일 수 있다. 단계 04에 있어서, 게임 윈도우의 위치를 프라이머리 모니터에 설정한다. 단계 05에 있어서, 게임 윈도우에 랜더링된 화면을 디스플레이한다. 단계 04를 실행하는 중 게임 윈도우의 위치를 프라이머리 모니터에 설정한 후, 컴퓨팅을 시작하고, 게임 화면을 랜더링하여, 상기 게임 화면을 상기 윈도우에 출력한다. 각 게임 인스턴스는 하나의 모니터(프라이머리 모니터 또는 보조 모니터 모두 가능하고, 보조 모니터는 비프라이머리 모니터임)에 대응될 수 있고, 상기 모니터에 대 응되는 그래픽 카드에 의해 관련된 컴퓨팅과 게임 화면의 랜더링이 수행되며, 랜더링 결과를 프라이머리 모니터 의 게임 윈도우에 디스플레이한다. 상기 클라우드 게임의 화면 디스플레이 기술을 설명하는 전제하에서, 클라우드 게임 서버는 멀티 그래픽 카드 및 멀티 게임 인스턴스의 동시 시나리오에서, 게임 중 다양한 인터랙션 조작으로 인해, 아래와 같은 기술적 문제가 초래될 수 있음을 알 수 있다. 먼저, 성능 및 비용 문제가 존재한다. 복수 개의 게임 인스턴스는 모두 윈도우를 프라이머리 모니터 위치에 설 정하고, 최종적으로 게임 화면은 동일한 모니터로 출력되므로, 프라이머리 모니터와 연결된 GPU의 PCIe가 병목 상태에 진입되는 것을 초래하고, 디스플레이 성능 문제를 유발하거나 게임 이론 동시 개수가 비교적 적어, 게임 작동 비용이 증가되는 것을 초래한다. 도 2를 참조하면, 도 2는 관련 기술에서 화면 동시 디스플레이의 하중 분 포 예시도를 도시한다. GPU0, GPU1, GPU2, GPUN은 각각 그래픽 카드이며, 여기서 GPU0은 프라이머리 모니터에 대응되는 그래픽 카드이다. 각 그래픽 카드는 그에 대응되는 게임 인스턴스를 위해 컴퓨팅 및 화면 랜더링의 서 비스를 제공할 수 있지만, 최종적으로 랜더링된 화면은 GPU0에 대응되는 프라이머리 모니터 중의 윈도우에서만 디스플레이될 수 있으므로, 이로 인해 GPU0에서의 하중이 비교적 높은 것이 초래된다. 예를 들면, 하나의 게임 인스턴스의 해상도 요구가 1920*1080이고, 프레임 레이트 요구가 60FPS이며, RGBA 그래픽 데이터 크기가 1920*1080*4*60/(1024*1024)=475 메가바이트(MB)이고, PCIe Gen3 x16의 이론 전송 속도는 초당 16기가바이트 (GB/s)이면, 상기 구성에 기반하여 구현될 수 있는 이론 동시 개수는 약 30 개이며, 동시 개수는 심하게 한정된 다. 또한, 호환성 문제가 존재할 수 있으며, 일부 게임에는 게임 스타팅 실패, 윈도우 위치 이상 등 호환성 문제가 나타날 수 있고, 상이한 게임 인스턴스는 행위 표현에서 차이가 존재할 수 있다. 상기 성능, 비용 및 호환성 문제를 해결하기 위해, 본 출원의 실시예는 화면 디스플레이 방법을 제공하며, 그래 픽 카드와 그래픽 카드 사이, 인스턴스와 인스턴스 사이의 완전한 격리를 구현할 수 있고, 화면 랜더링 레벨에 서의 동시를 구현할 뿐만 아니라, 화면 디스플레이에서의 분리를 구현할 수 있고, 동일한 프라이머리 모니터에 복수 개의 화면이 디스플레이되는 것을 피함으로써, 성능 병목 및 동시 개수의 한정을 돌파하고, 호환성 문제가 나타나는 것을 피할 수 있다 본 출원의 실시예는 클라우드 기술에 관한 것일 수 있다. 클라우드 기술은 광역 네트워크 또는 근거리 네트워크 내에서 하드웨어, 소프트웨어, 네트워크 등 일련의 리소스를 통일하여, 데이터의 컴퓨팅, 저장, 처리 및 공유를 구현하는 호스팅 기술을 가리킨다. 클라우드 기술은 클라우드 컴퓨팅 비지니스 모드 애플리케이션에 기반한 네 트워크 기술, 정보 기술, 통합 기술, 관리 플랫폼 기술, 애플리케이션 기술 등의 총칭이며, 리소스 풀을 조성할 수 있고, 수요에 따라 사용하며, 유연하고 편리하다. 클라우드 컴퓨팅 기술은 중요한 지지가 될 것이다, 기술 네트워크 시스템의 백그라운드 서비스는 비디오 웹 사이트, 이미지 타입 웹 사이트 및 더욱 많은 포털 웹 사이 트와 같은 대량의 컴퓨팅, 저장 리소스가 수요된다. 인터넷 사업의 고도 발전과 응용에 따라, 향후 각 아이템은 모두 고유의 식별 마크가 존재할 수 있고, 모두 백그라운드 시스템으로 전송되어 논리 처리를 수행해야 하며, 상이한 수준의 데이터는 별도로 처리될 수 있고, 각 종류의 산업 데이터는 강력한 시스템 백업 지지를 수요로 하며, 클라우드 컴퓨팅을 통해야만 구현될 수 있다. 본 출원의 실시예는 클라우드 기술에 기반하여 제공되는 각 클라우드 애플리케이션에 적용될 수 있다. 예를 들 어, 의료용 클라우드이다. 의료용 클라우드(Medical cloud)에 있어서, 클라우드 컴퓨팅, 모바일 기술, 멀티 미 디어, 4G 통신, 빅 데이터 및 사물 인터넷 등 새로운 기술의 기초 위에서, 의료 기술을 결합하고, \"클라우드 컴 퓨팅\"을 사용하여 의료 보건 서비스 플랫폼을 생성하여, 의료 리소스의 공유와 의료 범위의 확대를 구현하는 것 을 가리킨다. 클라우드 컴퓨팅 기술의 운용과 결합으로 인해, 의료용 클라우드는 의료 기관의 서비스 효율을 향 상시킬 수 있고, 주민들이 의료 자문함에 있어서 용이하다. 예를 들어, 병원의 진료 예약, 의료 보험 회계 등은 모두 클라우드 컴퓨팅과 의료 분야 결합의 산물이며, 의료용 클라우드는 또한 데이터 보안, 정보 공유, 동적 확 장, 글로벌 레이아웃 등의 장점을 구비한다. 도 3을 참조하면, 도 3은 본 명세서의 실시예에서 제공하는 화면 디스플레이 방법의 실행 가능한 실시 아키텍처 예시도이며, 도 3에 도시된 바와 같이, 상기 실시 아키텍처는 단말 기기, 화면 디스플레이 서버를 적어 도 포함할 수 있다. 여기서, 단말 기기는 인터넷에 위치하는 전자 기기일 수 있고, 사용자를 위해 다양한 인터넷 기반의 서비스를 제공할 수 있으며, 상기 서비스는 본 출원의 실시예에서의 클라이언트에 의해 제공된다. 단말 기기는 노트북, 태블릿 PC, 데스크톱 컴퓨터, 셋탑 박스, 모바일 기기, 차량 탑재 단말(예 를 들어, 휴대폰, 휴대용 음악 플레이어, 개인 정보 단말기, 전용 메시징 기기, 휴대용 게임 기기) 등 다양한 타입의 사용자 단말을 포함하지만 이에 한정되지 않는다. 본 출원의 실시예의 클라이언트는 다양한 시나리오에 서의 애플리케이션을 제공할 수 있으며, 클라우드 기술, 클라우드 게임, 클라우드 랜더링, 인공 지능, 지능형 교통, 보조 운전, 비디오 미디어, 지능형 커뮤니티, 인스턴트 메시징 등을 포함하지만 이에 한정되지 않는다. 화면 디스플레이 서버는 단말 기기와 인터랙션하는 것을 통해 사용자에게 서비스를 제공한다. 구체적으 로, 단말 기기는 화면 디스플레이 서버를 향해 화면을 요청할 수 있다. 이러한 경우, 상기 단말 기기 에 대응되고, 화면 디스플레이 서버에서 작동되는 타깃 인스턴스는 모니터 정보 획득 요청을 발송할 수 있 다. 모니터 정보 획득 요청이 수신된 경우, 화면 디스플레이 서버는 프라이머리 모니터 가상 정보를 시뮬레 이션하고, 상기 모니터 정보 획득 요청은 타깃 모니터에 대응되는 타깃 인스턴스에 의해 발송되며, 상기 타깃 모니터는 프라이머리 모니터 또는 보조 모니터이다. 상기 타깃 인스턴스가 상기 타깃 모니터를 상기 프라이머리 모니터로 결정하고, 랜더링된 화면을 상기 타깃 모니터에 디스플레이하도록 상기 프라이머리 모니터 가상 정보 를 상기 타깃 인스턴스에 피드백한다. 단말 기기가 압축 해제의 방식을 통해 상기 화면을 디스플레이하도록 타 깃 인스턴스는 디스플레이된 화면을 압축하여 단말 기기에 전송한다. 이와 같이, 클라이언트는 화면 컴퓨팅 또 는 화면 랜더링의 기능을 구비할 필요가 없으며, 기본적인 압축 해제 기능만을 구비하면 된다. 아래에, 본 출원의 실시예의 화면 디스플레이 방법을 설명하며, 본 출원의 실시예에 언급된 정보는 사용자의 그 랜트를 거쳤거나 각 방면의 충분한 그랜트를 거친 정보일 수 있다. 도 4는 본 출원의 실시예에서 제공하는 화면 디스플레이 방법의 흐름 예시도를 도시하며, 본 출원의 실시예는 실시예 또는 흐름도와 같은 상기 화면 디스플레이 방법의 조작 단계를 제공하지만, 통상적이거나 창조성이 없는 노동에 기반한 더욱 많거나 더욱 적은 조작 단계를 포함할 수 있다. 실시예에서 나열된 단계 순서는 다만 많은 단계의 실행 순서 중의 한 가지 방식일 뿐, 유일한 실행 순서를 대표하지 않는다. 실제에서의 시스템, 단말 기 기 또는 서버 제품이 실행될 때, 실시예 또는 도면에 도시된 방법 순서에 따라 실행하거나 병렬로 실행(예를 들 어, 병렬 프로세서 또는 멀티 스레드의 환경)할 수 있으며, 상기 화면 디스플레이 방법은 아래의 단계를 포함할 수 있다. 단계 S101에 있어서, 모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를 시뮬레이션하기 위한 프라이머 리 모니터 가상 정보를 생성하고, 모니터 정보 획득 요청은 타깃 인스턴스에 의해 발송되며, 타깃 인스턴스는 복수 개의 인스턴스 중 임의의 하나의 인스턴스이고, 타깃 인스턴스에 대응되는 타깃 모니터는 프라이머리 모니 터 또는 보조 모니터이다. 예로서, 모니터 정보 획득 요청이 수신된 경우, 프라이머리 모니터 가상 정보를 시뮬레이션하고, 상기 모니터 정보 획득 요청은 타깃 모니터에 대응되는 타깃 인스턴스에 의해 발송되며, 상기 타깃 모니터는 프라이머리 모 니터 또는 비프라이머리 모니터이다. 멀티 인스턴스 시나리오에서, 각 인스턴스는 하나의 그래픽 카드에 할당될 수 있고, 대응되는 그래픽 카드에 의 해 관련된 컴퓨팅 또는 화면 랜더링이 수행된다. 각 인스턴스를 위해 대응되는 그래픽 카드 리소스를 할당하는 것을 통해, 각 인스턴스 사이에 컴퓨팅 또는 화면 랜더링이 모두 서로 영향을 주지 않으며 각각 독립적으로 동 시 실행되도록 한다. 그러나 각 그래픽 카드가 컴퓨팅 또는 화면 랜더링을 실행하는 전제는 그에 대응되는 모니 터를 연관시키는 것이다. 본 출원의 실시예는 그래픽 카드에 관련된 모니터에 대해 한정하지 않으며, 관련된 모 니터는 실제 모니터 또는 가상 모니터일 수 있다. 본 출원의 실시예에서 타깃 인스턴스는 서버에서 작동되는 어 느 하나의 인스턴스일 수 있다. 타깃 인스턴스의 경우, 서버는 타깃 인스턴스에 그에 적합한 타깃 그래픽 카드 및 타깃 모니터를 할당할 수 있으며, 이 타깃 모니터는 프라이머리 모니터 또는 보조 모니터일 수 있다. 이와 같이, 서버에는 A, B, C, D인 네 개의 그래픽 카드가 구성되며, 각각 A1, B1, C1, D1인 네 개의 모니터에 대응 되고, 여기서 A1은 프라이머리 모니터이며, B1, C1, D1은 보조 모니터이다. 그래픽 카드 B는 인스턴스 B-10과 연관될 수 있고, 인스턴스 B-10이 타깃 인스턴스이면, 타깃 모니터는 B1이며, 이는 명백하게 보조 모니터이다. 그래픽 카드 A가 인스턴스 A-10과 연관될 수 있고, 인스턴스 A-10이 타깃 인스턴스이면, 타깃 모니터는 A1이고, 이는 명백하게 프라이머리 모니터이다. 타깃 인스턴스는 대응되는 클라이언트와 통신을 수행할 수 있고, 클라이언트가 클라이언트에 대응되는 타깃 인 스턴스를 향해 화면 요청을 송신한 것에 응답하여, 클라이언트에 대응되는 타깃 인스턴스는 화면 디스플레이 서 버에 모니터 정보 획득 요청을 발송한다. 일부 실시예에 있어서, 모니터 정보 획득 요청은 모니터 개수 획득 요청을 포함하고, 프라이머리 모니터 가상 정보는 모니터 개수 또는 프라이머리 모니터 식별자 특징을 포함하며, 모니터 정보 획득 요청이 수신될 때, 프 라이머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하고, 모니터 개수 획득 요청이 수 신될 때, 모니터 격리 장치로부터 모니터 개수 또는 프라이머리 모니터 식별자 특징을 획득하는 기술 방안을 통 해 구현될 수 있으며, 여기서, 모니터 개수는 제1 타깃 경우, 피드백해야 하는 모니터 개수이고, 제1 타깃 경우 는 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터에 디스플레이한 경우이며, 프라이머리 모니터 식별자 특징은 타깃 모니터가 프라이머리 모니터인 것을 표징하기 위한 것이다.예로서, 상기 모니터 개수 획득 요청이 수신된 경우, 모니터 격리 장치에 액세스하여 상기 모니터 격리 장치에 의해 출력된 상기 모니터 개수 또는 상기 프라이머리 모니터 식별자 특징을 획득하며, 상기 모니터 격리 장치는 상기 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터에 디스플레이한 경우, 피드백해야 하는 모니터 개수 를 출력하기 위한 것이고, 또는 상기 타깃 모니터가 프라이머리 모니터인 것을 표징하기 위한 프라이머리 모니 터 식별자 특징을 출력하기 위한 것이다. 예로서, 모니터 격리 장치는, 모니터 총수를 획득할 때, 실제로 매번 1개를 리턴시키면 되는 핵심적인 능력을 구비해야 한다. 모니터의 데이터를 진짜로 쿼리하지 않지만, 물론, 실제 경우, 모니터 개수는 1보다 클 수 있고, 이는 서버 환경 중 그래픽 카드와 모니터의 진실된 개수에 의해 결정된다. 현재 모니터가 프라이머리 모 니터인지 여부를 표징하는 판단 정보가 획득될 때, 현재 모니터가 프라이머리 모니터인 것을 표징하는 판단 메 시지만 리턴되고, 판단 메시지는 프라이머리 서버의 식별자 특징이며, 타깃 인스턴스가 프라이머리 서버의 식별 자 특징에 대응되는 모니터를 프라이머리 모니터로 오인하도록 한다. 일부 실시예에 있어서, 상기 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터로 전송하는 경우는, 타깃 인 스턴스에 대응되는 화면을 프라이머리 모니터로 전송하고, 프라이머리 모니터가 유일한 모니터인 경우를 포함한 다. 이는 타깃 인스턴스가 서버 환경에 하나의 모니터만 존재하고, 이 모니터가 프라이머리 모니터라고 오인하 는 것과 같다. 본 출원의 실시예는 피드백된 모니터 개수 또는 프라이머리 모니터 식별자 특징을 한정하지 않고, 다만 시뮬레 이션된 모니터 개수 또는 프라이머리 모니터 특징 식별자를 통해 타깃 인스턴스를 혼동시키는 목적을 달성하면 된다. 타깃 인스턴스를 혼동시키는 것을 통해, 타깃 인스턴스가 그에 대응되는 타깃 모니터가 프라이머리 모니 터라고 간주하도록 하여, 혼동시키는 목적을 달성한다. 예를 들어, 피드백된 모니터 개수가 1이고, 프라이머리 모니터 식별자 특징이 현재 타깃 인스턴스에 연관된 모니터가 프라이머리 모니터인 것을 표징하면, 타깃 인스턴 스는 현재 서버의 환경에 다만 하나의 모니터가 존재하고, 이 모니터는 프라이머리 모니터라고 간주할 수 있으 며, 타깃 인스턴스는 현재 서버의 환경에 타깃 모니터가 존재하는 것을 알고 있으면, 타깃 인스턴스는 타깃 모 니터가 프라이머리 모니터라고 필연적으로 간주함으로써, 혼동시키는 목적을 달성한다. 일부 실시예에 있어서, 모니터 정보 획득 요청은 프라이머리 모니터 위치 특징 요청을 포함하고, 프라이머리 모 니터 가상 정보는 프라이머리 모니터 위치 특징을 포함하며, 상기 모니터 정보 획득 요청이 수신될 때, 프라이 머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하는 단계는, 프라이머리 모니터 위치 특징 요청이 수신될 때, 모니터 격리 장치로부터 프라이머리 모니터 위치 특징을 획득하는 기술 방안을 통해 구 현될 수 있고, 여기서, 모니터 격리 장치는 제2 타깃 경우, 피드백해야 하는 프라이머리 모니터 위치 특징을 결 정하기 위한 것이고, 제2 타깃 경우는 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터에 전송하는 경우이 다. 예로서, 상기 프라이머리 모니터 위치 특징 요청이 수신된 경우, 모니터 격리 장치에 액세스하여 상기 모니터 격리 장치에 의해 출력된 프라이머리 모니터 위치 특징을 획득하고, 상기 모니터 격리 장치는 상기 타깃 인스턴 스에 대응되는 화면을 프라이머리 모니터에 전송하는 경우, 피드백해야 하는 상기 프라이머리 모니터 위치 특징 을 결정하기 위한 것이다. 구체적으로, 상기 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터로 전송하는 경우는, 타깃 인스턴스에 대 응되는 화면을 프라이머리 모니터로 전송하고, 프라이머리 모니터가 유일한 모니터인 경우를 포함한다. 이는 타 깃 인스턴스가 서버 환경에 하나의 모니터만 존재하고, 이 모니터가 프라이머리 모니터라고 오인하는 것과 같다. 본 출원의 실시예는 피드백된 프라이머리 모니터 위치 특징에 대해 한정하지 않고, 다만 시뮬레이션된 프라이머 리 모니터 위치 특징이 타깃 인스턴스를 혼동시키는 목적을 달성하면 된다. 타깃 인스턴스를 혼동시키는 것을 통해, 타깃 인스턴스가 그에 대응되는 타깃 모니터가 프라이머리 모니터라고 간주하도록 하여, 혼동시키는 목적 을 달성한다. 예를 들어, 피드백된 프라이머리 모니터 위치 특징이 서버 환경에 다만 하나의 프라이머리 모니터 가 존재하고 다른 모니터가 존재하지 않는 경우에서의 프라이머리 모니터의 위치이면, 타깃 인스턴스는 현재 서 버의 환경에 다만 하나의 모니터가 존재하고, 이 모니터는 프라이머리 모니터라고 간주할 수 있으며, 타깃 인스 턴스가 현재 서버의 환경에 타깃 모니터가 존재하는 것을 이미 알고 있고, 타깃 인스턴스는 타깃 모니터가 프라 이머리 모니터라고 필연적으로 간주함으로써, 혼동시키는 목적에 달성된다. 상기 두 개의 실시예는 프라이머리 모니터 식별자 시뮬레이션, 위치 시뮬레이션을 수행하고 모니터 개수를 시뮬 레이션하였으며, 본 출원의 실시예는 다른 혼동 방식을 한정하지 않으며, 이는 타깃 인스턴스가 획득해야 하는 프라이머리 모니터와 관련된 정보가 구체적으로 어떤 것인지에 의해 결정되며, 본 출원의 실시예에서는 다만 타 깃 인스턴스가 서버 환경에 하나의 모니터만 존재하고, 이 모니터는 프라이머리 모니터라고 오인하도록 프라이 머리 모니터 가상 정보를 시뮬레이션하는 것을 통해 혼동시키는 목적에 달성되면 된다. 클라우드 게임을 예로 들면, 보통 클라우드 게임은 아래와 같은 단계를 통해 모니터 정보를 획득한다. 먼저, 모니터 개수를 획득하며, 예를 들어, 타깃 게임 인스턴스는 애플리케이션 프로그래밍 인터페이스를 통해 모니터 개수를 획득할 수 있고, 예로서, 이 곳에서의 애플리케이션 프로그래밍 인터페이스는 \"컴퓨터에만 보이 는 모니터 함수(GetSystemMetrics(SM_CMONITORS))\" 및 \"멀티 모니터 함수 (EnumDisplayMonitors/EnumDisplayDevices)\"일 수 있으며, 이러한 경우, 상기 API를 하이재킹하는 것을 통해 상기 API 호출을 인터셉트할 수 있음으로써, 모니터 격리 장치에 액세스하여 모니터 개수를 획득하며, 실제로 매번 1개를 리턴시키면 되고, 이는 타깃 인스턴스가 실제의 서버 환경의 모니터의 관련 데이터를 알 수 없게 함 으로써, 혼동시킨다. 두 번째에 있어서, 모니터 개수를 획득한 후, 타깃 게임 인스턴스는 API를 사용할 수 있고; EnumDisplaySetting 은 모니터 정보를 획득하며, 이러한 경우, 상기 API를 인터셉트할 수 있으며, 다음, 모니터 격리 장치와 통신을 수행하는 것을 통해, 대응되는 정보를 획득하고, 예를 들어, 프라이머리 모니터, 좌표, 해상도인지 여부 등이다. 격리 장치는 각 모니터의 좌표를 모두 (0, 0)으로 가상화시킬 수 있고, 각 모니터를 모두 프라이머리 모니터로 가상화시킨다. 서버에서의 모니터 정보를 진짜로 열거하지는 않는다. 본 출원의 실시예에서 클라우드 게임 시나리오에서의 모니터 격리 장치는 아래와 같은 핵심 기능을 구비해야 한 다. 클라우드 게임이 모니터 총수를 획득할 때, 실제로 매번 1개를 리턴시키면 된다. 모니터의 데이터를 진짜로 쿼 리하지 않으며, 물론, 실제 경우, 서버 환경의 모니터 개수는 1보다 클 수 있고, 이는 서버 환경 중 그래픽 카 드와 모니터의 진실된 개수에 의해 결정된다. 클라우드 게임이 현재 모니터가 프라이머리 모니터인지 여부를 획득할 때, 현재 모니터가 프라이머리 모니터인 것만 통지하며, 즉, 프라이머리 서버의 식별자 특징을 피드백하여, 타깃 인스턴스가 프라이머리 서버의 식별자 특징에 대응되는 모니터를 프라이머리 모니터로 오인하도록 한다. 클라우드 게임이 현재 모니터 좌표 정보를 획득할 때, 그 좌표 정보는 (0, 0)이고, 진실된 좌표 정보는 (0, 0) 이 아니라고 통지한다. 물론, 다른 관련된 프라이머리 모니터 특성은 모두 수요에 따라 대응되는 시뮬레이션을 수행할 수 있음으로써, 타깃 인스턴스를 혼동시키는 목적에 달성된다. 상기 단계를 실행하는 것을 통해, 타깃 인스턴스가 다만 자체적으로 작동시키는 그래픽 카드의 모니터를 볼 수 있고, 이를 프라이머리 모니터라고 간주하는 반면, 현재의 서버 환경에 다른 모니터가 더 존재하는 것을 알지 못하고, 자연스럽게 다른 모니터와 인터랙션이 생성되지도 않음으로써, 타깃 인스턴스를 혼동시키는 방식을 통 해 모니터 사이의 완전한 격리를 구현한다. 단계 S102에 있어서, 타깃 인스턴스가 타깃 인스턴스에 대응되는 타깃 모니터를 프라이머리 모니터로 결정하고, 랜더링된 화면이 타깃 모니터에 디스플레이되도록 프라이머리 모니터 가상 정보를 타깃 인스턴스에 피드백한다. 예로서, 상기 타깃 인스턴스가 상기 타깃 모니터를 상기 프라이머리 모니터로 결정하고, 랜더링된 화면을 상기 타깃 모니터에 디스플레이하도록 상기 프라이머리 모니터 가상 정보를 상기 타깃 인스턴스에 피드백한다. 타깃 인스턴스는 다만 프라이머리 모니터를 향해 랜더링된 데이터를 송신하고, 그의 랜더링된 화면을 디스플레 이하도록 프라이머리 모니터를 트리거하는 반면, 타깃 인스턴스는 그에 대응되는 타깃 모니터를 프라이머리 모 니터로 오인하며, 이와 같이, 타깃 인스턴스가 다만 랜더링된 화면을 타깃 모니터에 디스플레이할 수 있고, 이 러한 화면을 진실된 프라이머리 모니터에 전송 및 디스플레이하지 않도록 하여, 모니터의 완전한 격리를 구현한 다. 클라우드 게임 시나리오에서 서버는 서버에서 작동되는 타깃 인스턴스에 다만 하나의 모니터가 존재하고, 상기 모니터는 프라이머리 모니터이며 상기 모니터의 위치, 속성 정보 등을 알려 줄 수 있음으로써, 타깃 인스턴스를 혼동시켜, 타깃 인스턴스가 그에 연관된 타깃 모니터가 프라이머리 모니터라고 오인하여, 타깃 모니터를 향해랜더링된 화면을 송신하도록 한다. 도 5를 참조하면, 본 출원의 실시예 중 화면 디스플레이 예시도를 도시하며, 여기서 GPU0, GPU1, GPU2, GPUN은 각 그래픽 카드를 나타내고, 각 그래픽 카드는 그에 대응되는 모니터를 가지며, 여기서 Primiary display는 프 라이머리 모니터이고, 다른 것은 모두 보조 모니터이다. 프라이머리 모니터든, 보조 모니터든, 그에 대응되는 인스턴스는 화면을 디스플레이할 때 본 출원의 실시예에서의 방법을 실행하는 것을 통해 모두 혼동됨으로써, 상 기 인스턴스에 대응되는 모니터가 유일한 프라이머리 모니터이고, 다른 모니터가 존재하지 않는다고 간주함으로 써, 랜더링된 화면을 상기 인스턴스에 대응되는 모니터에 디스플레이하고, 도 2에서와 같이 진실된 프라이머리 모니터에 전송되어 디스플레이를 수행할 필요가 없음으로써, 하중 평형을 구현하고, 진실된 프라이머리 모니터 하중이 보다 높은 것을 피하며, 도 2와 도 5를 비교하여 본 출원의 실시예와 관련기술의 디스플레이 효과에서의 구별을 명백하게 발견할 수 있다. 각 GPU에서 작동되는 게임 인스턴스는, 현재의 GPU에 연결된 가상 모니터와만 연관되고, 프라이머리 모니터와 연결된 GPU의 PCIe 하중이 보다 무거운 문제를 야기하지 않으며, 각 GPU와 가상 모니터는 완전히 독립적이다. 본 출원의 실시예에 있어서, 타깃 인스턴스는 타깃 모니터에 대응되는 타깃 그래픽 카드에서 화면 랜더링을 수 행하며, 랜더링하여 얻은 화면을 프라이머리 모니터 가상 정보에 따라 결정된 모니터에 디스플레이한다. 본 출 원의 실시예에 있어서, 프라이머리 모니터 가상 정보에 따라 결정된 모니터는 타깃 인스턴스에 연관된 타깃 모 니터이므로, 타깃 인스턴스에 연관된 그래픽 카드에서 화면 컴퓨팅과 랜더링을 수행한 후, 직접 그에 연관된 타 깃 모니터에 상기 화면을 디스플레이할 수 있으며, 상기 화면을 진실된 프라이머리 모니터에 전송하여 디스플레 이를 수행할 필요가 없음으로써, 디스플레이 속도를 향상시키고, 모니터의 화면 격리를 구현하며, 진실된 프라 이머리 모니터의 하중을 감소시킨다. 구체적으로, 단계 S102에서 타깃 인스턴스는 타깃 인스턴스에 대응되는 타깃 모니터를 프라이머리 모니터로 결 정하고, 실제로는 타깃 인스턴스는 프라이머리 모니터 가상 정보에 따라, 타깃 모니터를 프라이머리 모니터로 결정한다. 단계 S102에서 랜더링된 화면을 타깃 모니터에 디스플레이하고, 실제로는 타깃 모니터에 화면에 대응 되는 윈도우 위치를 설정하며, 화면을 타깃 모니터의 윈도우 위치로 전송한다. 도 6을 참조하면, 화면 디스플레이 효과 비교 예시도를 도시한다. 도 6의 윗 도면은 관련기술에서의 화면 디스 플레이 효과 예시도이고, 자명한 것은, 각 인스턴스에 대응되는 화면은 모두 프라이머리 모니터에 디스플레이되 며, 비록 화면은 각 그래픽 카드에서 동시에 랜더링될 수 있지만, 최종적으로 모두 프라이머리 모니터에서의 윈 도우로 전송되어 디스플레이를 수행해야 한다. 이는 프라이머리 모니터와 연결된 PCIe의 대역폭 하중이 아주 무 거운 것을 초래할 수 있다. 도 7을 참조하면, 하중 테스트 데이터 예시도를 도시한다. 도 7은 PCIe3.0x8 버전의 하나의 테스트 데이터이며, 이론적인 PCIe 양방향 대역폭은 8GB/s이지만, 실제로 가장 높아야 6GB/s이며, 현재 점유율은 이미 5Gb/s 이상이고, 이는 관련 기술의 대역폭 점유에 대한 병목 현상을 충분히 설명한다. 도 6은 본 출원의 실시예 중 화면 디스플레이 효과 예시도를 도시한다. 자명한 것은, 각 인스턴스가 랜더링하여 얻은 화면은 상기 인스턴스에 대응되는 모니터에 디스플레이되고, 각 화면을 모두 프라이머리 모니터에 전송하 여 디스플레이를 수행할 필요가 없다. 모니터 사이의 격리를 구현한다. 구체적으로, 이는 본 출원의 실시예에서 가상 모니터의 구현 원리에 따라, 구현한 멀티 그래픽 카드-멀티 모니터 시나리오에서, 그래픽 카드와 그래픽 카드 사이, 상이한 클라이언트, 서버 중 상이한 클라이언트에 대응되는 상이한 인스턴스 사이의 완전한 격리이 다. 도 8을 참조하면, 본 출원의 실시예 중 화면 디스플레이의 논리 예시도를 도시한다. 단계 11에 있어서, 클라우드 게임을 작동시킨다. 단계 12에 있어서, 모니터 정보를 열거한다. 단계 13에 있어서, 모니터 격리 장치에 액세스한다. 단계 14에 있어서, 모니터 격리 장치는 프라이머리 모니터 가상 정보를 출력한다. 단계 15에 있어서, 프라이머리 모니터 가상 정보에 따라, 타깃 모니터를 프라이머리 모니터로 결정하고, 프라이 머리 모니터에 윈도우 위치를 설정한다. 단계 16에 있어서, 윈도우 위치에서 랜더링된 화면을 디스플레이한다. 화면 디스플레이를 수행하기 전, 모니터 정보 획득 요청을 획득하고, 상기 요청을 인터셉트한 후 모니터 격리 장치에 액세스할 수 있으며, 액세스 결과에 기반하여 모니터 정보를 리턴시키고, 상기 모니터 정보는 타깃 인스 턴스를 혼동시켜, 타깃 인스턴스가 그에 대응되는 타깃 모니터를 프라이머리 모니터로 오인하여, 상기 타깃 모 니터에 윈도우 위치를 설정하고, 랜더링된 화면을 상기 타깃 모니터의 윈도우 위치에 디스플레이하도록 한다. 더 나아가, 디스플레이된 화면을 압축하여 클라이언트로 전송할 수 있으며, 클라이언트도 상기 화면을 디스플레 이할 수 있도록 한다. 본 출원의 실시예는 화면 디스플레이 방안을 제공하고, 프라이머리 모니터 가상 정보를 시뮬레이션하는 것을 통 해 타깃 인스턴스를 혼동시켜, 타깃 인스턴스가 그에 대응되는 타깃 모니터를 프라이머리 모니터로 오인하여, 랜더링된 화면을 타깃 모니터에 디스플레이하도록 함으로써, 상이한 모니터 사이, 상이한 인스턴스 사이의 격리 를 구현한다. 구체적으로, 이 방안은, 타깃 인스턴스가 다만 그에 대응되는 타깃 모니터를 볼 수 있고, 다른 모 니터의 존재를 감지할 수 없음으로써, 타깃 인스턴스가 다른 모니터의 존재를 감지하는 경우, 생성될 수 있는 각 이상, 작업하지 않는 문제를 피하도록 함으로써, 동시 성능 병목을 돌파할 수 있다. 클라우드 게임을 예로 들어, 본 출원의 실시예는 모니터의 완전한 격리를 구현할 수 있고, 게임에 의해 출력된 데이터가 모니터로 전송될 때, 데이터는 다만 자체의 PCIe을 거칠 뿐, 특정된 하나의 그래픽 카드 PCIe 대역폭 병목 문제를 야기하지 않으며, 고성능과 고병목 개수를 보장할 수 있다. 클라우드 게임 시나리오에 있어서, 게 임은 로컬에서 작동되는 것과 같이, 호환성이 좋고, 더욱 많은 게임을 지원한다. 물론, 본 출원의 실시예는 응 용 시나리오를 한정하지 않으며, 클라우드 게임 시나리오에 적용될 뿐만 아니라, 종래 게임 모드의 멀티 그래픽 카드 및 멀티 모니터 시나리오에도 적용된다. 본 출원의 실시예는 운영 체제도 한정하지 않으며, Windows 운영 체제를 지원할 뿐만 아니라, Linux 운영 체제 또는 다른 멀티 그래픽 카드 및 멀티 모니터 플랫폼도 지원한다. 도 9를 참조하면, 본 실시예에서의 화면 디스플레이 장치의 블록도를 도시하며, 장치는, 모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하도록 구성된 시뮬레이션 모듈 - 모니터 정보 획득 요청은 타깃 인스턴스에 의해 발송되고, 타깃 인 스턴스는 복수 개의 인스턴스 중 임의의 하나의 인스턴스이며, 타깃 인스턴스에 대응되는 타깃 모니터는 프라이 머리 모니터 또는 보조 모니터임 - ; 및 타깃 인스턴스가 타깃 인스턴스에 대응되는 타깃 모니터를 프라이머리 모니터로 결정하고, 랜더링된 화면이 타 깃 모니터에 디스플레이되도록 프라이머리 모니터 가상 정보를 타깃 인스턴스에 피드백하도록 구성된 피드백 모 듈을 포함한다. 일부 실시예에 있어서, 모니터 정보 획득 요청은 모니터 개수 획득 요청을 포함하고, 프라이머리 모니터 가상 정보는 모니터 개수 또는 프라이머리 모니터 식별자 특징을 포함하며, 시뮬레이션 모듈은, 모니터 개수 획득 요 청이 수신될 때, 모니터 격리 장치로부터 모니터 개수 또는 프라이머리 모니터 식별자 특징을 획득하는 조작을 실행하도록 구성되고, 여기서, 모니터 개수는 제1 타깃 경우, 피드백해야 하는 모니터 개수이고, 제1 타깃 경우 는 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터에 디스플레이한 경우이며, 프라이머리 모니터 식별자 특징은 타깃 모니터가 프라이머리 모니터인 것을 표징하기 위한 것이다. 일부 실시예에 있어서, 모니터 정보 획득 요청은 프라이머리 모니터 위치 특징 요청을 포함하고, 프라이머리 모 니터 가상 정보는 프라이머리 모니터 위치 특징을 포함하며, 시뮬레이션 모듈은, 프라이머리 모니터 위치 특징 요청이 수신될 때, 모니터 격리 장치로부터 프라이머리 모니터 위치 특징을 획득하는 조작을 실행하도록 구성되 고, 여기서, 모니터 격리 장치는 제2 타깃 경우, 피드백해야 하는 프라이머리 모니터 위치 특징을 결정하기 위 한 것이고, 제2 타깃 경우는 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터에 전송하는 경우이다. 도 10을 참조하면, 시뮬레이션 모듈에 의해 액세스된 모니터 격리 장치 예시도를 도시한다. 모니터 격리 장치는 프라이머리 모니터 특징 시뮬레이션 모듈과 모니터 위치 정보 시뮬레이션 모듈을 포함한다. 여기서, 프라이머리 모니터 특징 시뮬레이션 모듈은 출력된 모니터 개수 또는 프라이머리 모니터 식별자 특징으로 구성된다. 모니터 위치 정보 시뮬레이션 모듈은 프라이머리 모니터 위치 특징을 출력하도록 구성된다. 일부 실시예에 있어서, 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터로 전송하는 경우는, 타깃 인스턴스 에 대응되는 화면을 프라이머리 모니터로 전송하고, 프라이머리 모니터가 유일한 모니터인 경우를 포함한다. 일부 실시예에 있어서, 타깃 인스턴스는 타깃 모니터에 대응되는 타깃 그래픽 카드에서 화면 랜더링을 수행하고, 랜더링하여 얻은 화면을 프라이머리 모니터 가상 정보에 따라 결정된 모니터에 디스플레이하기 위한 것이다.일부 실시예에 있어서, 타깃 인스턴스는 또한, 타깃 인스턴스는 프라이머리 모니터 가상 정보에 따라, 타깃 모 니터를 프라이머리 모니터로 결정하고; 타깃 모니터에 화면에 대응되는 윈도우 위치를 설정하며, 화면을 타깃 모니터의 윈도우 위치로 출력하는 조작을 실행하기 위한 것이다. 본 출원의 장치 실시예와 방법 실시예는 동일한 기술 사상에 기반하며, 여기서 더 이상 반복하지 않는다. 본 출원의 실시예는 컴퓨터 프로그램 제품 또는 컴퓨터 프로그램을 더 제공하고, 상기 컴퓨터 프로그램 제품 또 는 컴퓨터 프로그램은 컴퓨터 명령어를 포함하며, 상기 컴퓨터 명령어는 컴퓨터 판독 가능한 저장 매체에 저장 된다. 컴퓨터 기기의 프로세서는 컴퓨터 판독 가능한 저장 매체로부터 상기 컴퓨터 명령어를 판독하고, 프로세 서가 상기 컴퓨터 명령어를 실행하여, 상기 컴퓨터 기기가 화면 디스플레이 방법을 실행하도록 한다. 본 출원의 실시예는 컴퓨터 판독 가능한 저장 매를 더 제공하고, 컴퓨터 판독 가능한 저장 매체는 복수 개의 명 령어를 저장할 수 있다. 명령어는 프로세서에 의해 로딩 및 실행되어 본 출원의 실시예의 화면 디스플레이 방법 을 구현하기 위한 것이다. 일부 실시예에 있어서, 화면 디스플레이 방법은, 모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를 시 뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하는 단계 - 모니터 정보 획득 요청은 타깃 인스턴스에 의해 발송되고, 타깃 인스턴스는 복수 개의 인스턴스 중 임의의 어느 하나의 인스턴스이며, 타깃 인스턴스에 대 응되는 타깃 모니터는 프라이머리 모니터 또는 보조 모니터임 - ; 및 타깃 인스턴스가 타깃 인스턴스에 대응되 는 타깃 모니터를 프라이머리 모니터로 결정하고, 랜더링된 화면을 타깃 모니터에 디스플레이하도록 프라이머리 모니터 가상 정보를 타깃 인스턴스로 피드백하는 단계를 포함한다. 일부 실시예에 있어서, 모니터 정보 획득 요청은 모니터 개수 획득 요청을 포함하고, 프라이머리 모니터 가상 정보는 모니터 개수 또는 프라이머리 모니터 식별자 특징을 포함하며, 모니터 정보 획득 요청이 수신될 때, 프 라이머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하는 단계는, 모니터 개수 획득 요 청이 수신될 때, 모니터 격리 장치로부터 모니터 개수 또는 프라이머리 모니터 식별자 특징을 획득하는 단계를 포함하며, 여기서, 모니터 개수는 제1 타깃 경우, 피드백해야 하는 모니터 개수이고, 제1 타깃 경우는 타깃 인 스턴스에 대응되는 화면을 프라이머리 모니터에 디스플레이한 경우이며, 프라이머리 모니터 식별자 특징은 타깃 모니터가 프라이머리 모니터인 것을 표징하기 위한 것이다. 일부 실시예에 있어서, 모니터 정보 획득 요청은 프라이머리 모니터 위치 특징 요청을 포함하고, 프라이머리 모 니터 가상 정보는 프라이머리 모니터 위치 특징을 포함하며, 모니터 정보 획득 요청이 수신될 때, 프라이머리 모니터를 시뮬레이션하기 위한 프라이머리 모니터 가상 정보를 생성하는 단계는, 프라이머리 모니터 위치 특징 요청이 수신될 때, 모니터 격리 장치로부터 프라이머리 모니터 위치 특징을 획득하는 단계를 포함하며, 여기서, 모니터 격리 장치는 제2 타깃 경우, 피드백해야 하는 프라이머리 모니터 위치 특징을 결정하기 위한 것이고, 제 2 타깃 경우는 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터에 전송하는 경우이다. 일부 실시예에 있어서, 타깃 인스턴스에 대응되는 화면을 프라이머리 모니터로 전송하는 경우는, 타깃 인스턴스 에 대응되는 화면을 프라이머리 모니터로 전송하고, 프라이머리 모니터가 유일한 모니터인 경우를 포함한다. 일부 실시예에 있어서, 랜더링된 화면을 타깃 모니터에 디스플레이하기 전, 화면 디스플레이 방법은, 타깃 인스 턴스가 타깃 모니터에 대응되는 타깃 그래픽 카드에서 화면 랜더링을 수행하는 단계를 더 포함한다. 일부 실시예에 있어서, 타깃 인스턴스가 타깃 인스턴스에 대응되는 타깃 모니터를 프라이머리 모니터로 결정하 는 단계는, 타깃 인스턴스가 프라이머리 모니터 가상 정보에 따라, 타깃 모니터를 프라이머리 모니터로 결정하 는 단계를 포함하고; 랜더링된 화면을 타깃 모니터에 디스플레이하는 단계는, 타깃 모니터에 화면에 대응되는 윈도우 위치를 설정하고, 화면을 타깃 모니터의 윈도우 위치로 전송하는 단계를 포함한다. 일부 실시예에 있어서, 도 11은 본 출원의 실시예에서 제공하는 방법을 구현하기 위한 기기의 하드웨어 구조 예 시도를 도시하고, 기기는 본 출원의 실시예에서 제공하는 장치 또는 시스템을 구성하거나 포함한다. 도 11에 도 시된 바와 같이, 기기는 하나 또는 복수 개의(도 중 102a, 102b, ……, 102n으로 도시함) 프로세서(프 로세서는 마이크로 프로세서 MCU 또는 프로그래머블 게이트 어레이 FPGA 등의 처리 장치를 포함할 수 있지 만 이에 한정되지 않음), 데이터를 저장하기 위한 메모리, 및 통신 기능을 위한 전송 장치를 포함할 수 있다, 이외에 또한, 모니터, 입력/출력 인터페이스(I/O 인터페이스), 유니버셜 시리얼 버스(USB) 포트(I/O 인터페이스의 포트 중의 하나의 포트로서 포함될 수 있음), 네트워크 인터페이스, 전원부 및/또는 카메라를 더 포함할 수 있다. 당업자는 도 11에 도시된 구조는 다만 예시적인 것이며, 전자 장치의 구조를 한정하려는 것은아니라는 것을 이해할 수 있다. 예를 들어, 기기는 또한 도 11에 도시된 것보다 더 많거나 더 적은 컴포넌 트를 포함할 수 있으며, 또는 도 11에 도시된 것과 상이한 구성을 갖는다. 유의해야할 것은, 하나 또는 복수 개의 프로세서 및/또는 다른 데이터 처리 회로는 본 문에서 통상적으로 \"데이터 처리 회로\"로 지칭될 수 있다. 상기 데이터 처리 회로는 전체적으로 또는 부분적으로 소프트웨어, 하드 웨어, 펌웨어, 또는 다른 임의의 조합으로 구현될 수 있다. 또한, 데이터 처리 회로는 단일 독립적인 처리 모듈 일 수 있고, 또는 기기(또는 모바일 기기)에서의 다른 요소 중의 임의의 하나에 전체적으로 또는 부분적으 로 결합될 수 있다. 본 출원의 실시예에서 언급한 바와 같이, 상기 데이터 처리 회로는 프로세서 제어(예를 들 어, 인터페이스와 연결된 가변 저항기 경로의 선택)로 사용된다. 메모리는 애플리케이션 소프트웨어의 소프트웨어 프로그램/모듈, 예를 들어, 본 출원의 실시예에서의 자원 구성 방법에 대응하는 프로그램 명령어/데이터 저장 장치를 저장하기 위한 것이며, 프로세서는 메모리 내의 소프트웨어 프로그램/모듈을 작동함으로써, 다양한 기능적 애플리케이션 및 데이터 처리를 실행하며, 즉 화면 디스플레이 방법을 구현한다. 메모리는 고속 랜덤 액세스 메모리를 포함할 수 있고, 또 한 비휘발성 메모리를 포함할 수 있으며, 예를 들어, 하나 또는 복수 개의 자기 저장 장치, 플래시 메모리, 또 는 다른 비휘발성 솔리드 스테이트 메모리를 포함할 수 있다. 일부 실시예에 있어서, 메모리는 프로세서 에 대해 원격 설치된 메모리를 포함할 수 있고, 이러한 원격 메모리는 네트워크를 통해 기기에 연결될 수 있다. 네트워크의 인스턴스는 인터넷, 인트라넷, 근거리 통신망, 이동 통신망 및 이들의 조합을 포함하지만 이에 한정되지 않는다. 전송 장치는 하나의 네트워크를 통해 데이터를 수신 또는 송신하기 위한 것이다. 네트워크의 구체적인 실 예는 기기의 통신 공급업체에서 제공하는 무선 네트워크를 포함할 수 있다. 하나의 예에 있어서, 전송 장치 는 하나의 네트워크 인터페이스 컨트롤러(Network Interface Controller, NIC)를 포함하고, 이는 기지국 을 통해 다른 네트워크 기기에 연결될 수 있음으로써 인터넷과 통신할 수 있다. 하나의 예에 있어서, 전송 장치 는 무선 주파수(Radio Frequency, RF) 모듈일 수 있고, 이는 무선 방식으로 인터넷과 통신할 수 있다. 모니터는 예를 들어, 터치 스크린 형태의 액정 모니터(LCD)일 수 있고, 상기 액정 모니터는 사용자가 기기 (또는 모바일 기기)의 사용자 인터페이스와 인터랙션을 수행하도록 할 수 있다. 도 12는 본 발명의 실시예의 다른 전자 기기의 블록도를 도시한다. 예를 들어, 전자 기기는 하나의 서버 로 제공될 수 있다. 도 12를 참조하면, 전자 기기는 하나 또는 복수 개의 프로세서를 더 포함하는 처리 컴포넌트, 및 처리 컴포넌트에 의해 실행되는 명령어를 저장하기 위한 메모리로 대표되는 메 모리 리소스를 포함한다. 메모리에 저장된 애플리케이션은 하나 또는 하나 이상의 한 세트의 명령어에 각 각 대응되는 모듈을 포함할 수 있다. 또한, 처리 컴포넌트는 명령어를 실행하여, 화면 디스플레이 방법을 실행하도록 구성된다. 전자 기기는 전자 기기의 전원 관리를 실행하도록 구성된 하나의 전원 컴포넌트, 전자 기기 를 네트워크에 연결하도록 구성된 하나의 유선 또는 무선 네트워크 인터페이스 및 하나의 입력 출 력(I/O) 인터페이스를 더 포함할 수 있다. 전자 기기는 메모리에 저장된 Windows ServerTM, Mac OSXTM, UnixTM, LinuxTM, FreeBSDTM 또는 유사한 운영체제를 실행시킬 수 있다. 예시적 실시예에 있어서, 컴퓨터 프로그램 명령어를 포함하는 메모리와 같은 비휘발성 컴퓨터 판독 가능 한 저장 매체를 제공하며, 컴퓨터 프로그램 명령어는 화면 디스플레이 방법을 완료하도록 전자 기기의 처 리 컴포넌트에 의해 실행된다. 설명해야 할 것은, 본 출원의 실시예의 선후 순서는 다만 설명을 위한 것일 뿐, 실시예의 우열을 나타내는 것이 아니다. 또한 본 출원의 실시예의 특정된 실시예를 설명한다. 다른 실시예는 첨부된 청구항의 범위 내에 존재한 다. 일부 경우에, 첨부된 청구항에서 기재된 동작 또는 단계는 실시예와 다른 순서에 따라 실행될 수 있고 여전 히 원하는 결과를 구현할 수 있다. 또한, 첨부 도면에서 도시된 과정은 원하는 결과를 구현하기 위해 도시된 특 정한 순서 또는 연속적인 순서를 반드시 요구하지 않는다. 일부 실시형태에 있어서, 멀티 작업 처리 및 병렬 처 리는 가능할 수 있거나 유리할 수도 있다. 본 출원의 실시예에서의 각 실시예는 점진적인 방식을 사용하여 설명되고, 각 실시예 사이의 동일하고 유사한 부분은 서로 참조하면 되며, 각 실시예는 다른 실시예와의 상이한 점을 설명하는데 중점을 두고 있다. 특히, 장 치와 서버 실시예의 경우, 방법 실시예와 대체적으로 유사하므로, 설명된 것이 비교적 간단하고, 관련된 부분은 방법 실시예의 일부 설명을 참조하면 된다.본 분야의 통상적인 기술자는 실시예를 구현하는 전부 또는 일부 단계가 하드웨어를 통해 완료될 수 있고, 프로 그램 명령어와 관련된 하드웨어를 통해 완료될 수도 있으며, 전술한 프로그램은 컴퓨터 판독 가능 저장 매체에 저장될 수 있으며, 언급된 저장 매체는 판독 전용 메모리, 자기 디스크 또는 광 디스크 등일 수 있음을 이해할 수 있을 것이다. 이상의 내용은 본 출원의 실시예의 바람직한 실시예일 뿐, 본 출원의 실시예들을 한정하기 위한 것이 아니며, 본 출원의 실시에의 사상 및 원칙 내에서 이루어진 임의의 수정, 동등한 교체, 개선 등은, 본 출원의 실시예의 보호 범위에 포함되어야 한다."}
{"patent_id": "10-2024-7006849", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 출원의 실시예 또는 관련 기술에서의 기술 방안과 장점을 더욱 명확하게 설명하기 위해, 아래에 실시예 또는 관련 기술에 대한 설명에 필요한 도면을 간략하게 소개하며, 아래의 설명에서의 도면은 본 출원의 실시예의 일 부 실시예일 뿐, 본 기술 분야의 통상의 기술자는, 창조적 작업 없이도, 이러한 도면에 따라 다른 도면을 획득 할 수 있는 것은 자명한 것이다. 도 1은 관련 기술에서 멀티 화면 디스플레이의 흐름 예시도이다. 도 2는 관련 기술에서 화면 동시 디스플레이의 하중 분포 예시도이다. 도 3은 본 출원의 실시예에서 제공하는 화면 디스플레이 방법의 실행 가능한 실시 아키텍처 예시도이다. 도 4는 본 출원의 실시예에서 제공하는 화면 디스플레이 방법의 흐름 예시도이다. 도 5는 본 출원의 실시예에서 제공하는 본 출원의 실시예 중 화면 디스플레이 예시도이다. 도 6은 본 출원의 실시예에서 제공하는 화면 디스플레이 효과 비교 예시도이다. 도 7은 본 출원의 실시예에서 제공하는 하중 테스트 데이터 예시도이다. 도 8은 본 출원의 실시예에서 제공하는 본 출원의 실시예 중 화면 디스플레이의 논리 예시도이다. 도 9는 본 출원의 실시예에서 제공하는 화면 디스플레이 장치의 블록도이다. 도 10은 본 출원의 실시예에서 제공하는 시뮬레이션 모듈에 의해 액세스된 모니터 격리 장치 예시도이다. 도 11은 본 출원의 실시예에서 제공하는 본 출원의 실시예에서 제공하는 방법을 구현하기 위한 기기의 하드웨어 구조 예시도이다. 도 12는 본 출원의 실시예에서 제공하는 다른 본 출원의 실시예에서 제공하는 방법을 구현하기 위한 기기의 하 드웨어 구조 예시도이다."}
