{"patent_id": "10-2021-7031377", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0134359", "출원번호": "10-2021-7031377", "발명의 명칭": "시맨틱 지능형 태스크 학습 및 적응형 실행 방법 및 시스템", "출원인": "삼성전자주식회사", "발명자": "진 홍샤"}}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "방법으로서,전자 장치에서, 상기 전자 장치에 의해 동작되는 제1 애플리케이션에 대한 명령을 수신하는 단계;상기 전자 장치에서, 상기 제1 애플리케이션과의 상호 작용에 응답하여 상기 제1 애플리케이션에 의해 제시된복수의 특징을 캡처하는 단계;상기 전자 장치에서, 상기 제1 애플리케이션과의 상호 작용을 통해 상기 제1 애플리케이션과 통신된 데이터를캡처하는 단계; 및캡처된 복수의 특징과 통신된 데이터를 기반으로 태스크를 학습하는 단계를 포함하는, 방법."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 통신된 데이터 사이의 상관 관계를 나타내는 그래프를 구성하는 단계로서, 상기 통신된 데이터는 음성 데이터를 포함하는, 상기 구성하는 단계; 및상기 그래프에 기초하여 캡처된 복수의 특징의 시맨틱 의미를 결정하는 단계로서, 상기 복수의 특징은 텍스트특징 또는 아이콘 특징 중 적어도 하나를 포함하는, 상기 결정하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,상기 명령에 기초하여 태스크 세트로부터 태스크를 선택하고;상기 제2 애플리케이션과의 상호 작용의 일부를 수행하기 위한 상기 태스크를 적용하며;상기 제2 애플리케이션과의 나머지 상호 작용을 보충하기 위해 상이한 태스크 세트로부터 다른 태스크를 적용함으로써,상기 태스크에 기초하여 제2 애플리케이션에 상기 명령을 적용하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 태스크는 상기 제1 애플리케이션과 상호 작용하는 일련의 동작을 나타내는 데이터 세트, 및 상기 일련의동작과 연관된 시맨틱 블록 큐를 포함하는, 방법."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1 항에 있어서,상기 복수의 특징은 사용자 인터페이스 요소를 포함하는 시각적 특징을 포함하는, 방법.공개특허 10-2021-0134359-3-청구항 6 제 1 항에 있어서,상기 제1 애플리케이션과의 상호 작용으로부터 슬롯 타입 및 슬롯 값을 추출하는 단계를 포함하며;음성 명령어 없이 상기 제1 애플리케이션과의 상호 작용을 위해, 상기 추출하는 단계는 상기 전자 장치에 의해표시된 인터페이스로부터 텍스트 데이터 또는 하나 이상의 시각적 아이콘 중 하나를 추출하는 단계를 포함하고;상기 텍스트 데이터는 슬롯 타입으로서 직접 사용되며;상기 하나 이상의 시각적 아이콘은 시맨틱 의미를 추출하기 위해 처리되고, 상기 시맨틱 의미는 다른 슬롯 타입으로서 사용되는, 방법."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 6 항에 있어서,음성 명령어를 사용한 상기 제1 애플리케이션과의 상호 작용을 위해, 상기 음성 명령어의 적어도 일부는 상기슬롯 타입으로서 사용되고, 상기 음성 명령어의 다른 부분은 상기 슬롯 값으로서 사용되는, 방법."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 6 항에 있어서,상기 슬롯 타입 및 상기 슬롯 값에 기초하여 NLU(natural language understanding) 엔진 개발을 위한 라벨링된발화 샘플을 구성하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "전자 장치로서,명령어를 저장하는 메모리; 및상기 명령어를 실행하는 적어도 하나의 프로세서를 포함하는데, 상기 프로세서는,상기 전자 장치에서, 상기 전자 장치에 의해 동작되는 제1 애플리케이션에 대한 명령을 수신하고;상기 전자 장치에서, 상기 제1 애플리케이션과의 상호 작용에 응답하여 상기 제1 애플리케이션에 의해 제시된복수의 특징을 캡처하고;상기 전자 장치에서, 상기 제1 애플리케이션과의 상호 작용을 통해 상기 제1 애플리케이션과 통신된 데이터를캡처하며;캡처된 복수의 특징과 통신된 데이터를 기반으로 태스크를 학습하도록 구성되는 프로세스를 포함하는, 전자 장치."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 9 항에 있어서,상기 프로세서는,상기 통신된 데이터- 상기 통신된 데이터는 음성 데이터를 포함함 -사이의 상관 관계를 나타내는 그래프를 구성하고;상기 그래프에 기초하여- 상기 복수의 특징은 텍스트 특징 또는 아이콘 특징 중 적어도 하나를 포함함 -캡처된공개특허 10-2021-0134359-4-복수의 특징의 시맨틱 의미를 결정하도록 더 구성되는 전자장치."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 9 항에 있어서,상기 프로세스는,상기 명령에 기초하여 태스크 세트로부터 태스크를 선택하고;상기 제2 애플리케이션과의 상호 작용의 일부를 수행하기 위한 상기 태스크를 적용하며;상기 제2 애플리케이션과의 나머지 상호 작용을 보충하기 위해 상이한 태스크 세트로부터 다른 태스크를 적용함으로써,상기 태스크에 기초하여 제2 애플리케이션에 상기 명령을 적용하도록 더 구성되는, 전자 장치."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 9 항에 있어서,상기 태스크는 상기 제1 애플리케이션과 상호 작용하는 일련의 동작을 나타내는 데이터 세트, 및 상기 일련의동작과 연관된 시맨틱 블록 큐를 포함하며;상기 복수의 특징은 사용자 인터페이스 요소를 포함하는 시각적 특징을 포함하는, 전자 장치."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 9 항에 있어서,상기 프로세스는,상기 제1 애플리케이션과의 상호 작용으로부터 슬롯 타입 및 슬롯 값을 추출하며;음성 명령어 없이 상기 제1 애플리케이션과의 상호 작용을 위해, 상기 전자 장치에 의해 표시된 인터페이스로부터 텍스트 데이터 또는 하나 이상의 시각적 아이콘 - 상기 텍스트 데이터는 슬롯 타입으로서 직접 사용되고, 상기 하나 이상의 시각적 아이콘은 시맨틱 의미를 추출하기 위해 처리되며, 상기 시맨틱 의미는 다른 슬롯 타입으로서 사용됨 - 중 하나를 추출하도록 더 구성되며;음성 명령어를 사용한 상기 제1 애플리케이션과의 상호 작용을 위해, 상기 음성 명령어의 적어도 일부는 상기슬롯 타입으로서 사용되고, 상기 음성 명령어의 다른 부분은 상기 슬롯 값으로서 사용되는, 전자 장치."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 13 항에 있어서,상기 프로세스는,상기 슬롯 타입 및 상기 슬롯 값에 기초하여 NLU(natural language understanding) 엔진 개발을 위한 라벨링된발화 샘플을 설정하도록 더 구성되는, 전자 장치."}
{"patent_id": "10-2021-7031377", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "비일시적 프로세서 판독 가능한 매체로서,프로세서에 의해 실행될 때 제 1 항의 방법을 수행하는 프로그램을 포함하는, 비일시적 프로세서 판독 가능한공개특허 10-2021-0134359-5-매체."}
{"patent_id": "10-2021-7031377", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "방법은, 전자 장치에서, 전자 장치에 의해 동작되는 제1 애플리케이션에 대한 명령을 수신하는 단계를 포함한다. 제1 애플리케이션과의 상호 작용에 응답하여 제1 애플리케이션에 의해 제시된 특징은 전자 장치에서 캡처된다. 제1 애플리케이션과의 상호 작용을 통해 제1 애플리케이션과 통신된 데이터는 전자 장치에서 캡처된다. 캡처된 특징과 통신된 데이터를 기반으로 태스크는 학습된다."}
{"patent_id": "10-2021-7031377", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원은 2019년 3월 29일에 출원된 미국 출원 제16/370,411호에 관한 것이며, 이는 전체가 참조로 포함된다. 하나 이상의 실시예는 일반적으로 전자 장치 상의 설명(demonstration)을 통한 태스크 학습(task learning)에 관한 것으로서, 특히, 제1 애플리케이션에 대한 명령에 기초한 태스크 학습 및 태스크에 기초하여 명령을 제2 애플리케이션에 적용하는 것에 관한 것이다."}
{"patent_id": "10-2021-7031377", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "PA(Personal Assistants) 및 스마트 에이전트(smart agent)는 모바일 장치, 텔레비젼 장치, 가정용 스피커, 가 전 제품 등에 걸쳐 제공되어 멀티모달(multi-modal) 장치 상에서 사용자 태스크를 수행한다. 모바일 장치에서, PA 및 스마트 에이전트는 대부분 하나 이상의 애플리케이션(앱)과 함께 작동하여 음성 명령, 단축 키 버튼 (shortcut button) 또는 제스처(gesture)를 사용하여 사용자 요청 상에서 특정 태스크를 수행한다. 예를 들어, 태스크는 \"캘린더 이벤트 부가(Adding a Calendar Event)\" \"메시지 보내기(Sending a Message),\" \"티켓 예약 (Booking Tickets)\" \"라이드 예약(Booking a ride)\"등과 같은 사용자 요청과 연관될 수 있다."}
{"patent_id": "10-2021-7031377", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "하나 이상의 실시예는 일반적으로 제1 애플리케이션에 대한 명령에 기초한 태스크 학습 및 태스크에 기초하여 명령을 제2 애플리케이션에 적용하는 것에 관한 것이다."}
{"patent_id": "10-2021-7031377", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시예에서, 방법은, 전자 장치에서, 전자 장치에 의해 동작되는 제1 애플리케이션에 대한 명령을 수신하는 단계를 포함한다. 제1 애플리케이션과의 상호 작용에 응답하여 제1 애플리케이션에 의해 제시된 특징(feature) 은 전자 장치에서 캡처(capture)된다. 제1 애플리케이션과의 상호 작용을 통해 제1 애플리케이션과 통신된 데이 터는 전자 장치에서 캡처된다. 캡처된 특징과 통신된 데이터를 기반으로 태스크는 학습된다. 일부 실시예에서, 전자 장치는 명령어를 저장하는 메모리를 포함한다. 적어도 하나의 프로세서는, 전자 장치에 서, 전자 장치에 의해 동작되는 제1 애플리케이션에 대한 명령을 수신하고; 전자 장치에서, 제1 애플리케이션과 의 상호 작용에 응답하여 제1 애플리케이션에 의해 제시된 복수의 특징을 캡처하고; 전자 장치에서, 제1 애플리 케이션과의 상호 작용을 통해 제1 애플리케이션과 통신된 데이터를 캡처하며; 캡처된 복수의 특징 및 통신된 데 이터를 기반으로 태스크를 학습하도록 구성된 프로세스를 포함하는 명령어를 실행한다. 하나 이상의 실시예에서, 비일시적(non-transitory) 프로세서 판독 가능한 매체는 프로세서에 의해 실행될 때, 방법을 수행하는 프로그램을 포함하며, 방법은, 전자 장치에서, 전자 장치에 의해 동작되는 제1 애플리케이션에 대한 명령을 수신하는 단계를 포함한다. 제1 애플리케이션과의 상호 작용에 응답하여 제1 애플리케이션에 의해 제시된 특징은 전자 장치에서 캡처되고; 제1 애플리케이션과의 상호 작용을 통해 제1 애플리케이션과 통신된 데 이터는 전자 장치에서 캡처된다. 캡처된 특징 및 통신된 데이터를 기반으로 태스크는 학습된다. 일부 실시예에서, 전자 장치는 명령어를 저장하는 메모리; 및 명령어를 실행하는 적어도 하나의 프로세서를 포 함하며, 적어도 하나의 프로세서는, 전자 장치에서, 전자 장치에 의해 동작되는 제1 애플리케이션에 대한 명령 을 수신하고; 전자 장치에서, 제1 애플리케이션과의 상호 작용을 캡처하며; 제1 애플리케이션과의 상호 작용으 로부터, 명령의 이해를 위해 슬롯 타입 및 슬롯 값을 추출하도록 구성된다. 하나 이상의 실시예의 이들 및 다른 양태 및 이점은, 도면과 관련하여 취해질 때, 하나 이상의 실시예의 원리를 예로서 예시하는 다음의 상세한 설명으로부터 명백해질 것이다."}
{"patent_id": "10-2021-7031377", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "하나 이상의 실시예는 일반적으로 제1 애플리케이션에 대한 명령에 기초한 태스크 학습 및 태스크에 기초하여 명령을 제2 애플리케이션에 적용하는 것에 관한 것이다."}
{"patent_id": "10-2021-7031377", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "다음의 설명은 하나 이상의 실시예의 일반적인 원리를 예시하기 위한 목적으로 이루어지며, 본 명세서에서 청구 된 발명의 개념을 제한하려는 것이 아니다. 또한, 본 명세서에 설명된 특정 특징은 다양한 가능한 조합 및 순열 의 각각에서 다른 설명된 특징과 조합하여 사용될 수 있다. 본 명세서에서 달리 구체적으로 정의되지 않는 한, 모든 용어는 명세서에서 암시된 의미뿐만 아니라 통상의 기술자가 이해하는 의미 및/또는 사전, 논문 등에 정의 된 의미를 포함하는 가능한 가장 넓은 해석이 주어져야 한다. \"적어도 하나(at least one of)\"라는 용어는 뒤따르는 요소 중 하나 이상을 지칭한다는 것이 주목되어야 한다. 예를 들어, \"a, b, c 또는 이들의 조합 중 적어도 하나\"는 \"a\", \"b\" 또는 \"c\"로 개별적으로; 또는 \"a\" 및 \"b\"로 함께 조합하고, \"b\" 및 \"c\"로 함께 조합하고; \"a\" 및 \"c\"로 함께 조합하거나; \"a\", \"b\" 및 \"c\"로 함께 조합하는 것으로서 해석될 수 있다. 하나 이상의 실시예는 일반적으로 제1 애플리케이션에 대한 명령에 기초한 태스크 학습 및 학습된 태스크에 기 초하여 명령을 제1 애플리케이션 및/또는 제2 애플리케이션에 적용하는 것에 관한 것이다. 일부 실시예는 2019 년 3월 29일에 출원된 미국 출원 제16/370,411호에 설명된 바와 같이 지능형 학습 시스템(intelligent learning system; ILS)을 사용하여 생성된 바이트코드 태스크(bytecode task)의 사용을 포함하는 지능형 태스크 학습 및 적응형 실행 시스템 처리를 제공하며, 이는 전체가 참고로 포함된다. 일부 실시예에서, 방법은, 전자 장치에서, 전자 장치에 의해 동작되는 제1 애플리케이션에 대한 명령을 수신하는 단계를 포함한다. 제1 애플리 케이션과의 상호 작용에 응답하여 제1 애플리케이션에 의해 제시된 시각적 특징을 포함하는 특징은 전자 장치에 서 캡처된다. 제1 애플리케이션과의 상호 작용을 통해 제1 애플리케이션과 통신된 데이터는 전자 장치에서 캡처 된다. 캡처된 특징과 통신된 데이터를 기반으로 태스크는 학습된다. 일부 실시예에서, 명령은 학습된 태스크에 기초하여 제2 애플리케이션에 적용된다. 일부 실시예에서, 시맨틱 지능형 태스크 학습 및 적응형 실행 시스템(STaLES)(예를 들어, STaLES(300, 도 3)은 티켓 예약((ticket booking), 개인 통신, 비즈니스 검색, 소셜 네트워크 상의 공유(sharing on social network) 등과 같은 상이한 애플리케이션 소스로부터 다양한 태스크를 수행하는 것을 학습할 수 있는 인공 지능 (artificial intelligence; AI) 처리를 포함한다. 예를 들어, '티켓 예약 태스크(ticket booking task)'은 여 행 애플리케이션(예를 들어, EXPEDIA®) 상에서 학습되고, 태스크 학습 지식(task learning knowledge)은 동일 한 애플리케이션 상에서 태스크를 반복적으로 수행하는 데 사용될 수 있다. 사용자가 TRAVELOCITY®, PRICELINE ®, ORBITZ® 등과 같은 다른 여행 애플리케이션을 사용하는 경우, STALES는 EXPEDIA®로부터 학습되는 지식을 적용하여, 이러한 애플리케이션 상에서도 태스크를 수행할 수 있다. STaLES는 하나의 애플리케이션으로부터 태 스크를 수행하고, 입력 파라미터가 상이한 애플리케이션을 통해 학습된 태스크를 다시 실행하고 수행하는 방법 을 학습한다. 일부 실시예에서, 시스템은 자연어(natural language), 이벤트, 시각적 데이터 등과 같은 다양한 데이터 요소로부터 학습한다. 이벤트는 사용자 동작; 알림, 경고와 같은 시스템 이벤트; Wi-Fi 연결 변경 등과 같은 하드웨어 상태 변경 이벤트; 백그라운드에서 실행 중인 다른 애플리케이션의 서비스 이벤트; 및 학습 애플 리케이션의 컨텍스트 외 이벤트(out of context events of learning application) 등에 기초하여 생성된 장치 응답을 포함한다. 예를 들어, 사용자는 출발 날짜, 귀국 날짜, 출발 장소, 목적지 장소 등의 선택을 설명함으로 써 제1 여행 애플리케이션을 사용할 수 있다. 사용자에 의한 제1 여행 애플리케이션의 사용은 텍스트 입력, 버 튼 선택, 드롭 다운 메뉴(drop down menus) 등을 포함한다. 데이터를 입력하거나 선택하는 방법이 두 여행 애플 리케이션 간에 상이할지라도, 제1 여행 애플리케이션의 설명 사용은 제2 여행 애플리케이션에 대한 정보로서 사 용될 수 있다. 애플리케이션이 개인(또는 가상) 비서(assistant)를 통해 태스크를 지원하기 위해, 이러한 태스크는 적용 가능 한 모든 애플리케이션 상에서 명시적으로 구현되어야 한다. 예를 들어, \"항공권 예약(book the flight tickets)\"의 발언을 기반으로 하는 태스크는 EXPEDIA®, KAYAK®, PRICELINE®, BOOKING® 등과 같은 다수의 애플리케이션 상에서 실행되어야 하는 태스크이다. 그러나, 사용자는 전자 장치(예를 들어, 전자 장치(120, 도 2)) 상에 상이한 앱/애플리케이션을 설치했을 수 있다. 모든 사용자를 위한 태스크를 수행하기 위해, 개발자는 일반적으로 각각의 개별 앱/애플리케이션에 대해 특정 API(애플리케이션 프로그래밍 인터페이스)를 구현했다. 다수의 애플리케이션 상에서 중복 및 구현 노력을 줄이기 위해, 하나 이상의 실시예는 하나의 앱/애플리케이션 으로부터 하나의 태스크를 학습하고 다른 많은 관련된 앱/애플리케이션 상에서 실행하거나 수행함으로써 효과적 으로 작동하는 지능형 시스템을 제공한다. STaLES는 시맨틱 이해를 위해 사용자 인터페이스(UI) 동작, 이벤트, 자연어 및 시각적 요소로부터의 모든 입력을 효과적으로 취한다. 하나 이상의 실시예에서, STaLES는 태스크를 지능적으로 식별하고, 최소(모델(model)) 트레이닝으로 관련된 앱/ 애플리케이션을 통해 학습하고 수행한다. STaLES는 태스크의 다수의 파라미터를 식별하고, 높은 정확도로 태스 크를 효과적으로 이해하고 실행한다. 일부 실시예에서, STaLES는 다음과 같은 것을 제공한다: 학습된 태스크는 태스크가 초기에 학습된 소스 앱/애플리케이션 상에서 실행되고; 시맨틱 태스크 실행은 시각적 요소, 텍스트, 아이콘 및 동작으로부터 제공되며; STaLES는 소스 애플리케이션과 상이한 타겟 앱/애플리케이션 상에서 학습된 태스크를 실행할 때 동적 애플리케이션 적응을 제공하고, 이는 원래의 앱/애플리케이션 상의 원래의 태스크와 의미상(semantically) 유사한 각각의 요소(예를 들어, 텍스트, 선택, 버튼, 드롭 다운 메뉴 엔트리 등)를 동적 으로 선택하고; 일회 학습된 태스크는 다양한 동적 상태, 컨텍스트 스크린 등의 다수의 애플리케이션 상에서 실행될 수 있고; STaLES는 태스크 실행 시 사용자 피드백을 사용함으로써 일관된 성능과 정확성을 제공하고; STaLES는 다양한 앱/애플리케이션을 통해 태스크가 실행된 후 태스크 식별 및 권장(recommendation)을 제공하며; STaLES는 의미상 동일한 카테고리로 분류된 다른 앱/애플리케이션 상에서 학습된 태스크를 실행하는 다중 앱/애플리케이션, 다중 장치 및 다중 플랫폼 모델링 시스템을 제공한다. 일 실시예에서, 태스크 식별은 입 력 값, 애플리케이션 도메인, 태스크 실행에서 수행되는 동작의 수 등에 기초하여 수행된다. 일 실시예에서, 애 플리케이션 도메인 분류기(classifier)는 다수의 애플리케이션 상에서 태스크를 실행하기 위해 적합한 타겟 애 플리케이션을 식별한다. 애플리케이션의 상태는 다양한 조건으로부터 적재되는 애플리케이션의 현재 UI 및/또는 활동을 기반으로 결정될 수 있다. 애플리케이션이 백그라운드(예를 들어, 백그라운드 상태)에서 실행되지 않은 경우, 이는 애플리케이션 의 디폴트 상태(default state)를 결정하는 새로운 애플리케이션 프로세스로서 시작한다. 사용자가 태스크를 실 행하기 전에 애플리케이션으로 작동되고, 애플리케이션이 백그라운드에 남아 있는 경우, 이는 '활동 저장된 인 스턴스(activity saved instance)' 또는 '영구 상태(persistent state)'로부터 시작하여, 사용자가 중지한 위 치로부터 다시 시작한다. FACEBOOK®, TWITTER®, LINKEDIN® 등과 같은 일부 애플리케이션에서, UI 요소는 사 용자 동작에 기초하여 변경된다. 예를 들어, 사용자가 UI 상에서 스크롤 다운(scroll down)될 때, 새로운 콘텐 츠가 렌더링(rendering)된다. 따라서, 이는 사용자 동작에 기초하여 자주 변경되는 동적 UI 요소를 식별하는 데 도움을 준다. '윈도우 콘텐츠 변경됨(Window content changed)', '윈도우 상태 변경됨(Window state changed)', '윈도우 변경됨(Window changed)' 및 'onActivitySaveInstanceState'와 같은 이벤트는 또한 애플리 케이션 상태를 식별하는 데 중요하다. 도 1은 하나 이상의 실시예에 따른 통신 시스템의 개략도이다. 통신 시스템은 나가는(outgoing) 통신 동작을 개시하는 통신 장치(송신 장치) 및 통신 네트워크를 포함할 수 있으며, 송신 장치는 통신 네트워크 내의 다른 통신 장치와의 통신 동작을 개시하고 수행하는 데 사용할 수 있다. 예를 들어, 통신 시스템은 송신 장치(수신 장치)로부터 통신 동작을 수신하는 통신 장치를 포함할 수 있다. 통신 시 스템은 다수의 송신 장치 및 수신 장치를 포함할 수 있지만, 각각의 하나만이 도 1에서 도시되어 도면을 단순화한다. 통신 네트워크를 생성하기 위해 동작하는 임의의 적절한 회로, 장치, 시스템 또는 이들의 조합(예를 들어, 통신 타워 및 원격 통신 서버를 포함하는 무선 통신 인프라)은 통신 네트워크를 생성하는 데 사용될 수 있다. 통신 네트워크는 임의의 적절한 통신 프로토콜을 사용하여 통신을 제공할 수 있다. 일부 실시예에서, 통신 네트워크는 예를 들어, 전통적인 전화선, 케이블 텔레비전, Wi-Fi(예를 들어, IEEE 802.11 프로토콜), BLUETOOTH®, 고주파 시스템(예를 들어, 900MHz, 2.4GHz 및 5.6GHz 통신 시스템), 적외선, 상대적으로 국부화 된 다른 무선 통신 프로토콜 또는 이들의 임의의 조합을 지원할 수 있다. 일부 실시예에서, 통신 네트워크(11 0)는 무선 및 셀룰러 전화 및 개인 이메일 장치(예를 들어, BLACKBERRY®)에 의해 사용되는 프로토콜을 지원할 수 있다. 이러한 프로토콜은 예를 들어 GSM, GSM + EDGE, CDMA, 쿼드밴드(quadband) 및 다른 셀룰러 프로토콜을 포함할 수 있다. 다른 예에서, 장거리 통신 프로토콜은 VOIP, LAN, WAN 또는 다른 TCP-IP 기반 통신 프로토콜을 사용하여 전화를 걸거나 받기 위한 프로토콜 및 Wi-Fi를 포함할 수 있다. 송신 장치 및 수신 장치는, 통신 네트워크 내에 위치될 때, 경로와 같은 양방향 통신 경로 또는 2개의 단방향 통신 경로를 통해 통신할 수 있다. 송신 장치 및 수신 장치는 모두 통신 동작을 개시하고 개시된 통신 동작을 수신할 수 있다. 송신 장치 및 수신 장치는 통신 동작을 송수신하기 위한 임의의 적절한 장치를 포함할 수 있다. 예를 들어, 송신 장치 및 수신 장치는 이동 전화 장치, 텔레비전(TV) 시스템, 스마트 TV 시스템, 카메라, 캠 코더, 오디오 비디오 능력을 가진 장치, 태블릿, 웨어러블 장치, 스마트 기기, 스마트 사진 프레임(smart picture frame), 및 (무선 지원 액세서리 시스템(wireless-enabling accessory system)의 도움을 갖거나 갖지 않고) 무선으로 또는 유선 경로(예를 들어, 전통적인 전화선을 사용함)를 통해 통신할 수 있는 임의의 다른 장 치와 같은 음성 비서(개인 비서, 가상 비서 등)를 포함하는 장치를 포함할 수 있지만, 이에 제한되지 않는다. 통신 동작은 예를 들어 음성 통신(예를 들어, 전화 통화), 데이터 통신(예를 들어, 데이터 및 제어 메시징, 이 메일, 문자 메시지, 미디어 메시지), 비디오 통신 또는 이들의 조합(예를 들어, 비디오 회의)을 포함하는 임의 의 적절한 형태의 통신을 포함할 수 있다. 도 2는 전자 장치(예를 들어, 이동 전화 장치, TV 시스템, 카메라, 캠코더, 오디오 비디오 능력을 가진 장 치, 태블릿, 패드 장치, 웨어러블 장치, 스마트 기기, 스마트 사진 프레임, 스마트 조명 등), 클라우드 또는 서 버, 또는 전자 장치와 클라우드 컴퓨팅(예를 들어, 설정 가능한 컴퓨팅 시스템 자원 및 상위 레벨 서비스 등의 공유 풀(shared pool)) 또는 서버(예를 들어, 네트워크 자원 등을 관리하는 컴퓨터, 장치 또는 프로 그램)의 조합을 사용하는 적어도 하나의 애플리케이션에 대한 사용자 설명을 사용하여 가상 비서 또는 스 마트 에이전트에 대한 지능형 태스크 학습 및 적응형 처리를 수행할 수 있는 시스템용 아키텍처의 블록도 를 도시한다. 송신 장치(도 1) 및 수신 장치는 모두 전자 장치의 특징의 일부 또는 전부를 포함할 수 있다. 일부 실시예에서, 전자 장치는 디스플레이, 마이크로폰, 오디오 출력, 입력 메커 니즘, 통신 회로, 제어 회로, 카메라, 처리 및 메모리, 지능형 태스크 학습 및 적응 형(예를 들어, STaLES를 사용함, 도 3) 처리(130 및/또는 131)(전자 장치, 클라우드/서버, 전 자 장치 및 클라우드/서버의 조합 상에서 처리하고, 클라우드 또는 서버로 정보를 획득/제공하 기 위해 통신 회로와 통신하며; 아래에 설명되는 바와 같은 예에 대한 임의의 처리를 포함할 수 있지만, 이에 제한되지 않음) 및 임의의 다른 적절한 구성 요소를 포함할 수 있다. 애플리케이션 1-N이 제공되고, 클라우드 또는 서버, 통신 네트워크(도 1) 등으로부터 획득될 수 있으며, 여기서 N은 1보다 크거나 같은 양의 정수이다. 일부 실시예에서, 오디오 출력, 디스플레이, 입력 메커니즘, 통신 회로 및 마이크로폰 에 의해 사용되는 모든 애플리케이션은 제어 회로에 의해 상호 연결되고 관리될 수 있다. 일 예에서, 음악을 다른 튜닝 장치로 송신할 수 있는 휴대용 음악 플레이어는 전자 장치에 통합될 수 있다. 일부 실시예에서, 오디오 출력은 전자 장치의 사용자에게 오디오를 제공하기 위한 임의의 적절한 오 디오 구성 요소를 포함할 수 있다. 예를 들어, 오디오 출력은 전자 장치에 내장된 하나 이상의 스피 커(예를 들어, 모노 또는 스테레오 스피커)를 포함할 수 있다. 일부 실시예에서, 오디오 출력은 전자 장치 에 원격으로 결합되는 오디오 구성 요소를 포함할 수 있다. 예를 들어, 오디오 출력은 유선(예를 들 어, 잭(jack)을 가진 전자 장치에 결합됨) 또는 무선(예를 들어, BLUETOOTH® 헤드폰 또는 BLUETOOTH® 헤드셋)으로 통신 장치에 결합될 수 있는 헤드셋, 헤드폰 또는 이어버드(earbud)를 포함할 수 있다. 일부 실시예에서, 디스플레이는 사용자에게 가시적인 디스플레이를 제공하기 위한 임의의 적절한 스크린 또는 프로젝션 시스템(projection system)을 포함할 수 있다. 예를 들어, 디스플레이는 전자 장치에 통합되는 스크린(예를 들어, LCD 스크린, LED 스크린, OLED 스크린 등)을 포함할 수 있다. 다른 예로서, 디스플 레이는 전자 장치(예를 들어, 비디오 프로젝터)로부터 떨어진 표면 상에 콘텐츠의 디스플레이를 제공 하기 위한 이동식 디스플레이 또는 투사 시스템(projecting system)을 포함할 수 있다. 디스플레이는 제어 회로의 방향에 따라 콘텐츠(예를 들어, 통신 동작에 관한 정보 또는 이용 가능한 미디어 선택에 관한 정보)를 표시하도록 동작할 수 있다. 일부 실시예에서, 입력 메커니즘은 사용자 입력 또는 명령어를 전자 장치에 제공하기 위한 임의의 적 절한 메커니즘 또는 사용자 인터페이스일 수 있다. 입력 메커니즘은 버튼, 키패드, 다이얼, 클릭 휠(click wheel), 마우스, 시각적 포인터(visual pointer), 원격 제어, 하나 이상의 센서(예를 들어, 카메라 또는 시각적 센서, 광 센서, 근접 센서 등), 터치 스크린, 제스처 인식, 음성 인식 등과 같은 다양한 형태를 취할 수 있다. 입력 메커니즘은 멀티 터치 스크린을 포함할 수 있다. 일부 실시예에서, 통신 회로는 통신 네트워크(예를 들어, 통신 네트워크, 도 1))에 연결하고, 전자 장치로부터 통신 네트워크 내의 다른 장치로 통신 동작 및 미디어를 송신하도록 동작하는 임의의 적절한 통신 회로일 수 있다. 통신 회로는 예를 들어, Wi-Fi(예를 들어, IEEE 802.11 프로토콜), Bluetooth®, 고주파 시스템(예를 들어, 900MHz, 2.4GHz 및 5.6GHz 통신 시스템), 적외선, GSM, GSM + EDGE, CDMA, 쿼드밴드 및 다른 셀룰러 프로토콜, VOIP, TCP-IP 또는 임의의 다른 적절한 프로토콜과 같은 임의의 적절한 통신 프로토 콜을 사용하여 통신 네트워크와 인터페이스하도록 동작할 수 있다. 일부 실시예에서, 통신 회로는 임의의 적절한 통신 프로토콜을 사용하여 통신 네트워크를 생성하도록 동작 할 수 있다. 예를 들어, 통신 회로는 다른 통신 장치에 연결하기 위해 단거리 통신 프로토콜을 사용하여 단거리 통신 네트워크를 생성할 수 있다. 예를 들어, 통신 회로는 전자 장치를 BLUETOOTH® 헤드셋과 결합하기 위해 BLUETOOTH® 프로토콜을 사용하여 로컬 통신 네트워크를 생성하도록 동작할 수 있다. 일부 실시예에서, 제어 회로는 전자 장치의 동작 및 성능을 제어하도록 동작할 수 있다. 제어 회로 는 예를 들어 프로세서, (예를 들어, 명령어를 전자 장치의 다른 구성 요소에 송신하기 위한) 버스, 메모리, 스토리지, 또는 전자 장치의 동작을 제어하기 위한 임의의 다른 적절한 구성 요소를 포함할 수 있 다. 일부 실시예에서, 하나 이상의 프로세서(예를 들어, 처리 및 메모리 129에서)는 디스플레이를 구동하고, 사 용자 인터페이스로부터 수신된 입력을 처리할 수 있다. 메모리 및 스토리지는 예를 들어 캐시, 플래시 메모리,ROM 및/또는 RAM/DRAM을 포함할 수 있다. 일부 실시예에서, 메모리는 (예를 들어, 운영 체제, 사용자 인터페이 스 기능 및 프로세서 기능과 같은 장치 애플리케이션을 위한) 펌웨어를 저장하는데 특별히 전용될 수 있다. 일 부 실시예에서, 메모리는 전자 장치가 통신 동작을 수행하는 다른 장치와 관련된 정보를 저장하도록 동작 할 수 있다(예를 들어, 통신 동작과 관련된 연락처 정보(contact information)를 저장하거나 사용자에 의해 선 택된 상이한 미디어 타입 및 미디어 엔트리와 관련된 정보를 저장함). 일부 실시예에서, 제어 회로는 전자 장치 상에서 구현된 하나 이상의 애플리케이션의 동작을 수행하 도록 동작할 수 있다. 임의의 적절한 수 또는 타입의 애플리케이션이 구현될 수 있다. 다음의 논의가 상이한 애 플리케이션을 열거하지만, 애플리케이션의 일부 또는 전부는 하나 이상의 애플리케이션으로 조합될 수 있다는 것이 이해될 것이다. 예를 들어, 전자 장치는 자동 음성 인식(automatic speech recognition; ASR) 애플 리케이션, OCR 애플리케이션, 대화 애플리케이션, PA(또는 스마트 에이전트) 앱, 지도 애플리케이션, 미디어 애 플리케이션(예를 들어, 갤러리 앱, QuickTime, Mobile Music 앱 또는 Mobile Video 앱), 소셜 네트워킹 애플리 케이션(예를 들어, FACEBOOK®, INSTAGRAM®, TWITTER® 등), 캘린더 애플리케이션(예를 들어, 이벤트, 약속 등 을 관리하기 위한 캘린더), 인터넷 브라우징 애플리케이션, 추천 애플리케이션 등을 포함하지만 이에 제한되지 않는 애플리케이션 1-N을 포함할 수 있다. 일부 실시예에서, 전자 장치는 통신 동작을 수행하도록 동 작하는 하나 또는 다수의 애플리케이션을 포함할 수 있다. 예를 들어, 전자 장치는 메시징 애플리케이션, 이메일 애플리케이션, 음성 메일 애플리케이션, 인스턴트 메시징 애플리케이션(예를 들어, 채팅용), 비디오 회 의 애플리케이션, 팩스 애플리케이션, 또는 임의의 적절한 통신 동작을 수행하기 위한 임의의 다른 적절한 애플 리케이션을 포함할 수 있다. 일부 실시예에서, 전자 장치는 마이크로폰을 포함할 수 있다. 예를 들어, 전자 장치는 통신 동 작 중 또는 통신 동작을 설정하는 수단으로서 또는 물리적 사용자 인터페이스를 사용하는 대안으로서 사용자가 애플리케이션 1-N의 음성 제어 및 내비게이션(navigation)을 위한 오디오(예를 들어, 음성 오디오)를 송신 하도록 허용하기 위한 마이크로폰을 포함할 수 있다. 마이크로폰은 전자 장치에 통합될 수 있거 나 전자 장치에 원격적으로 결합될 수 있다. 예를 들어, 마이크로폰은 유선 헤드폰에 통합될 수 있고, 마이크로폰은 무선 헤드셋에 통합될 수 있으며, 마이크로폰은 원격 제어 장치 등에 통합될 수 있다. 일부 실시예에서, 카메라 모듈은 정지 및 비디오 이미지(still and video image)를 캡처하기 위한 기능, 편집 기능, 사진/비디오 등을 송신, 공유하기 위한 통신 상호 운용성(communication interoperability)을 포함 하는 하나 이상의 카메라 장치를 포함한다. 일부 실시예에서, 전자 장치는 통신 동작을 수행하기에 적합한 임의의 다른 구성 요소를 포함할 수 있다. 예를 들어, 전자 장치는 호스트 장치, 2차 입력 메커니즘(예를 들어, ON/OFF 스위치), 또는 임의의 다른 적절한 구성 요소에 결합하기 위한 전원 장치, 포트 또는 인터페이스를 포함할 수 있다. 도 3은 일부 실시예에 따른 STaLES 및 그 동작에 대한 하이 레벨 블록도를 도시한다. 일부 실시예에서, STaLES 및 연관된 동작에 대한 하이 레벨 블록도는 제1 장치(장치 1, 예를 들어, 전자 장치, 도 2), 앱(또는 애플리케이션)(예를 들어, 모바일 앱, 스피커 앱, TV 앱 등), 음성 명령 발화(voice command utterance)(예를 들어, \"항공권 예약\" 등과 같이 PA로 향하는 발화), STaLES 장치: x, y 및 z(예를 들어, STaLES 처리를 실행하는 전자 장치, 도 2), 동적 앱 적응 및 대화형 태스크 실행 (DynAmITE) 처리를 포함한다. 하나 이상의 실시예에서, ILS 서비스는 2019년 3월 29일에 출원된 미국 출원 제16/370,411호에 설명된 바와 같이 바이트코드 태스크, 및 클라우드/서버에 저장되는 훈련된 태스크 (trained task)를 생성 및 제공하기 위해 사용되며, 이는 전체가 참조로 통합된다. 일부 실시예에서, STaLES는 장치 1에 의해 생성되는 사용자 UI 동작 및 이벤트로부터 자동으로 태스 크를 학습한다. STaLES는 사용자가 태스크를 수행하기 위해 음성 명령을 제공할 때 트리거링 (triggering)된다. ILS는 훈련된 태스크를 생성하여, 이를 클라우드에 저장한다. 예를 들어, 사 용자가 음성 명령을 \"이벤트 생성(create an event)\"으로서 제공하고, 시스템이 태스크를 수행하는 방법을 알지 못할 때, STaLES는 ILS을 호출하여 태스크를 학습한다. STaLES는 텍스트, 이미지, 이벤트 상태 및 UI 요소, 시스템 이벤트, 앱/애플리케이션(예를 들어, 앱)의 컨텍스트 및 상태와 같은 각각의 사용자 UI 동작의 다양한 데이터로부터 학습한다. 하나 이상의 실시예에서, STaLES는 태스크가 한번만 학습될 때 다른 유사한 앱/애플리케이션 상에서 학습된 태스크를 수행할 수 있다. STaLES는 모바일 장치에서 PA의 능 력을 개선하여 최소의 훈련(training)으로 여러 도메인의 앱/애플리케이션에서 광범위한 태스크를 수행한다.일부 실시예에서, STaLES는 동일한 시맨틱 데이터를 갖는 임의의 동일하거나 유사한 카테고리 애플리케이 션 상에서 하나의 특정 태스크를 학습할 수 있다. 태스크 실행을 수행하는 동안 STaLES는 인위적으로 인간 의 지능을 모방하여 앱/애플리케이션의 각각의 스크린 상에서 특정 요소와 기호/아이콘을 식별한다. 동일한 학 습된 태스크는 단일 앱/애플리케이션의 다수의 버전(예를 들어, 소프트웨어 업그레이드 등) 상에서 실행될 수 있다. STaLES는 동일한 앱/애플리케이션의 상이한 버전이 태스크를 실행할 수 있는 DynAmITE 처리(또 한 도 4를 참조함)와 함께 작동한다. 일부 실시예에서, STaLES는 사용자 피드백에 기초하여 태스크 실행의 정확성 및 안정성을 개선한다. STaLES는 훈련된 태스크로부터 동작을 실행할 때, 이는 임의의 동작이 올바 른지를 나타내는 피드백을 사용자에게 재촉할 수 있다. 예를 들어, STaLES는 \"보내기(send)\"로서 라벨링 (labeling)된 보내기 버튼(send button)을 가진 하나의 애플리케이션으로부터 \"Send SMS\"의 태스크를 학습했다. 다른 애플리케이션을 가진 시스템에서 동일한 태스크를 수행할 때, 해당 애플리케이션의 보내기 버튼은 아이콘 이미지로 라벨링된다. STaLES는 \"보내기\" 동작을 수행하기 위해 가능한 보내기 버튼을 식별했지만 진행하 기 전에, 사용자 피드백이 높은 정확도로 동작을 수행하는 데 도움이 되도록 사용자 확인을 요청한다. 하나 이 상의 실시예에서, 태스크 실행이 더 많은 입력 데이터를 필요로 했다면, STaLES는 사용자로부터 피드백 또는 입 력을 재촉한다. 다수의 사용자 입력을 기반으로, STaLES는 태스크 특성, 실행 타겟 애플리케이션을 이해할 수 있으며, 따라서 지속적인 개선을 위해 STaLES에 큰 유연성을 제공한다. 하나 이상의 실시예에서, 사용자가 음성 명령을 사용하여 태스크를 실행하도록 요청할 때, 태스크를 실행하기 위한 타겟 애플리케이션이 존재하지 않는 경우, STaLES는 태스크 시퀀스를 식별하고, 과거 발화 및 과거 훈련 지식을 기반으로 사용 가능한 앱 /애플리케이션을 타겟화할 수 있다. 예를 들어, 과거에는 여행 애플리케이션(예를 들어, PRICELINE®) 상에서 항공권을 예약하기 위해 PA에 발화를 제공하는 사용자 태스크가 포함되었다. 사용자는 이제 자신의 장치 또는 시스템에 의해 지원되지 않는 TRAVELOCITY® 상의 티켓 예약 태스크에 대한 발화를 제공한다. 시스템은 이러한 태스크를 여행 애플리케이션을 사용하여 티켓 예약을 수행하는 태스크로서 식별할 수 있다. 이에 상응하여, 이 는 과거 태스크 시퀀스 정보를 사용하고, 태스크를 실행하기 위해 사용 가능한 대안적인 여행 애플리케이션(예 를 들어, ORBITZ®)을 선택한다. 일부 실시예에서, STaLES는 음성 입력 및 인간 설명(예를 들어, 터치, 클릭, 타이핑, 제스처 등)을 통해 새로운 태스크를 학습한다. STaLES는 PA 및 스마트 비서(Smart assistant)와 통합하기 위한 API 인터페이 스가 거의 없으며, 이러한 인터페이스는 태스크를 실행하기 위한 사용자로부터의 의도로서 입력을 취한다. 하나 이상의 실시예에서, STaLES는 소스 애플리케이션과 상이한 동일한 도메인에 속하는 다양한 앱/애플리케이 션을 통해 태스크를 수행할 수 있다. STaLES는 하나의 태스크에 대한 지식을 사용하여 유사한 애플리케이 션 또는 태스크에서 많은 부가적인 태스크를 지원할 수 있다. 예를 들어, STaLES는 '연락처(contact)' 및 '텍스트'로서 태스크를 실행하기 위해 2개의 입력 파라미터를 필요로 하는 \"SMS 보내기\" 태스크를 학습했다. 이 는 SMS 기능을 지원하는 다른 애플리케이션 상에서 동일한 태스크를 수행할 수 있다. 이러한 태스크와 함께, \" 트윗 게시(post tweet)\", \"Facebook/LinkedIn 상의 게시물 공유(share post on Facebook/LinkedIn)\", \"WhatsApp 상의 메시지 보내기(send message on WhatsApp)\" 등과 같은 상이한 애플리케이션의 유사한 태스크를 수행하기 위해 지식은 공유될 수 있다. 이러한 모든 경우에, 태스크는 태스크를 성공적으로 수행하기 위해 '연 락처' 및 '텍스트'로서의 2개의 입력 파라미터만을 필요로 한다. 작은 태스크는 큰 태스크 실행의 작은 청크(chunk)일 수 있다. STaLES는 학습의 능력을 한번 제공하고, 학 습된 태스크를 다중 장치, 다중 시스템(AndroidTM, TizenTM 등) 및 다중 사용자와 연관된 여러 곳에 적용하며, 이는 개발 노력과 시간, 비용, 및 PA의 능력을 지원하기 위한 특정 태스크를 구현하기 위한 자원을 상당히 감소 시킨다. 애플리케이션 상의 PA의 이행 동작은 사용자가 음성 또는 텍스트에 의해 명령을 호출(invoke)할 때 복수의 태스 크를 수행하거나 자동화할 수 있다. 일반적으로, 이러한 태스크는 특정 앱/애플리케이션 상에서 정적으로 구현 된다. 사용자는 태스크의 실행 시퀀스를 선택하기 위한 옵션을 갖지 않는다. 일부 실시예에서, STaLES는 사용자 UI 동작의 시퀀스를 학습하고, 이를 타겟 앱/애플리케이션 상에서 실행 가능하거나 수행 가능한 태스크 로 변환할 수 있는 앱/애플리케이션 상에서 작동한다. 타겟 애플리케이션은 태스크가 학습된 동일한 앱/애플리 케이션 또는 동일한 카테고리의 유사한 앱/애플리케이션(예를 들어, 여행 앱/애플리케이션, 레스토랑 앱/애플리 케이션, 교통 앱/애플리케이션 등)일 수 있다. 일 예에서, '항공권 예약'은 다양한 앱/애플리케이션 상에서 완 료될 수 있는 태스크이다. STaLES는 티켓을 예약하기 위해 하나의 앱/애플리케이션으로부터 태스크를 학습 하고, 학습된 태스크는 동일한 장치 또는 상이한 디바이스 상의 다른 항공권 앱/애플리케이션 상에서 실행될 수 있다.일부 실시예에서, 사용자가 UI 상호 작용으로 태스크를 설명하기 시작할 때, 사용자가 수행하는 각각의 동작은 하나 이상의 아이콘 이미지, 텍스트(표시되거나 입력됨) 등, 및 이러한 요소의 타입을 포함하는 STaLES 에 의해 캡처된다. 요소의 타입은 실행 프로세스 중에 수행될 수 있는 동작을 식별하고 예측하는 데 도움을 준다. 예를 들어, \"도시(city)\"에 대한 \"호텔 찾기(find hotel)\" 태스크를 학습할 때, UI 요소 상에서 타입 입력 슬롯 값은 \"텍스트 편집(edit text)\"이며, 따라서 사용자는 모든 값을 도시로서 입력할 수 있다. 태스크가 다시 실행 될 때, 이는 텍스트 값을 '텍스트 편집'에 입력할 수 있다. '호텔 찾기' 태스크가 특정 도시만이 사용자에 의해 선택될 수 있는 UI 요소와 동일한 도시 슬롯 값 'ListView'에 대해 상이한 버전 또는 다른 장치 애플리케이션 상에서 실행된다. 따라서, UI 요소 상에서 수행될 수 있는 유일한 동작은 \"선택(select)\"이다. STaLES는 태스크를 실행하는 동안 UI 요소 상에서 태스크를 식별할 수 있다. STaLES는 다수의 폼 팩터(form facto r)의 모바일, TV, 웨어러블, 스마트 냉장고 등과 같은 상이한 전자 장치 상에서 실행되는 동일한 애플리케이션 의 인터페이스 변형을 이해하도록 맥락적 이해(contextual understanding)와 함께 멀티모달 GUI를 지원한다. 예 를 들어, \"Netflix로부터의 영화 검색(searching a movie from Netflix)\"은 모바일 장치와 TV 장치 상에서 상 이하다. 둘 다 동일한 태스크 실행을 수행하지만, 환경과 GUI가 상이하다. STaLES는 수행될 수 있는 동작, 속성 및 UI 요소의 타입을 기반으로 UI 요소를 인식한다. UI 요소가 상이하지만 공통 기능을 공유하는 경우, STaLES는 태스크가 크로스 플랫폼 또는 장치 상에서 실행되는 경우에도 적절한 요소를 분류하고 예측할 수 있다. 이러한 GUI의 일부는 각각 많은 상이한 속성, 시맨틱 의미 및 다른 객체와의 관계를 가진 수백 개의 객체 로 매우 복잡해질 수 있다. 도 4는 일부 실시예에 따른 DynAmITE 처리에 대한 하이 레벨 흐름을 도시한다. DynAmITE 처리는 태스 크가 타겟 앱/애플리케이션에서 실행되는 STaLES에서의 태스크 실행 프로세스이다. 타겟 앱/애플리케이션 은 태스크가 학습된 소스 앱/애플리케이션 또는 유사한 카테고리의 상이한 앱/애플리케이션일 수 있다. DynAmITE 처리는 각각의 이벤트를 이해하고, 가능한 정확도가 가장 높은 앱/애플리케이션 컨텍스트를 사용 하여 실행한다. 하나 이상의 실시예에서, DynAmITE 처리는 태스크의 일부로서 동작을 실행할 때 타겟 앱/ 애플리케이션과 함께 작동하도록 컨텍스트를 염두에 두고 설계된다. 일부 실시예에서, DynAmITE 처리는 2 개의 실시간 서비스 스레드(thread)를 포함할 수 있으며: 하나의 스레드는 이벤트 또는 동작 실행 스레드 이고, 이는 타겟 애플리케이션 상에서 동작을 수행하는 것을 의미하는 타겟 애플리케이션 실행 컨텍스트에서 실 행된다. 이벤트 실행 스레드는 타겟 애플리케이션의 메모리 컨텍스트에서 실행되고, 다른 하나는 STaLES 컨텍스트에서 실행되는 이벤트 디스패치 스레드이다. 태스크 바이트코드가 태스크의 시맨틱 이벤트를 읽기 위한 protobuf(Protocol Buffer) 파일 판독기인 태스크 동작 추출기에 입력될 때, 일 실시예에서, 시 맨틱 이벤트는 이벤트 실행 스레드 및 이벤트 디스패치 스레드에 입력된다. 하나 이상의 실시예에서, 타겟 애플리케이션 컨텍스트에서의 이벤트 실행 스레드는 각각의 이벤트/동작이 실행되어야 하는 현재 UI 활동 스크린인 활동 스크린, 아이콘/이미지를 포함하는 UI 요소 분류기인 요소 분류기, 및 활동 스크린에 존재하는 각각의 요소를 분류하고 모든 UI 요소의 요소 시맨틱 데이터 를 생성하는 텍스트 분류기를 포함한다. UI 요소 파인더(finder)는 특정 UI 요소 상에서 동작을 수행 하기 위해 이벤트/동작 디스패치 스레드로부터 디스패치된 이벤트 및/또는 동작을 검색한다. 생성기, 실행기 및 검증자를 포함하는 동작 관리자는 하나 이상의 UI 요소 상에서 동작을 수행한다. 생 성기는 마우스 또는 커서의 클릭, 마우스 또는 커서의 긴 클릭, UI 요소 상의 선택 또는 스와이프(swipe) 등과 같은 이벤트/동작 디스패치 스레드로부터 디스패치된 이벤트/동작과 동등한 특정 동작을 생성한다. 실행기는 요소 상에서 동작을 실행하고, 검증자는 동작을 수행한 후 시스템으로부터의 응답에 기초하 여 검증한다. 예를 들어, '버튼 클릭(Button Click)' 동작이 실행기에 의해 수행될 때, 시스템은 검증자 가 동작을 검증하는 응답 이벤트 'BUTTON_CLICKED'를 생성한다. 이벤트/동작 디스패치 스레드는 태스 크 바이트코드로부터 추출되는 이벤트 또는 동작을 포함한다. 각각의 동작은 이벤트/동작 실행 스레 드로 디스패치되며, 여기서 검증자는 버튼 선택, 입력 UI 요소 등과 같은 동작 또는 이벤트의 타입을 검증한다. 선택적인 사용자 입력 및 이벤트 이미터는 UI 요소가 사용자가 태스크를 실행하기 위해 데 이터를 입력할 필요가 있는 입력 타입일 때에 프롬프트(prompt)만을 생성하거나 제공한다. 일부 실시예에서, DynAmITE 처리(도 3)는 훈련된 태스크과 같은 이용 가능한 태스크 리스트(예를 들 어, 클라우드, 도 3, 또는 장치 1와 같은 장치, 도 3)로부터 태스크를 먼저 론칭(launching)함으로써 실행된다. 이러한 태스크는 분류된 태스크를 포함한다. 활동 스크린은 태스크를 위해 사용되는 전자 장치 (예를 들어, 장치 1, 도 3)의 UI 스크린을 포함할 수 있다. 요소 시맨틱 데이터는 아이콘 또는 텍스 트를 기반으로 이해의 UI 요소 일반적 의미(generic meaning)를 결정하기 위해 사용되는 텍스트 및 이미지의 등가 분류 값(equivalent classification value)이다. 예를 들어, \"보내기 버튼(send button)\"은 \"보내기\" 텍스 트 또는 \"보내기\"에 대한 아이콘 표현(icon representation)으로서 애플리케이션 스크린 활동에 보여질 수 있다. 두 경우, STaLES(도 3)는 두 값으로부터 일반적인 의미를 결정해야 한다. UI 요소 파인더는 현 재 명령(예를 들어, 음성 명령 발화, 도 3))을 실행하기 위한 적절한 요소를 결정한다. 이벤트 디스패치 스레드는 검증자로 이벤트를 검증하고, 음성, 키보드, 제스처 등을 통해 입력된 사용자로부터의 데이터인 사용자 입력에 대한 프롬프트를 생성(또는 획득)한다. 사용자 입력은 이벤트 이미터가 최종 명령을 실행하기 전에 태스크 검토 측면에서 사용자로부터 피드백을 제공한다. 일부 실시예에서, 이벤트 실행 스레드는 제한된 앱/애플리케이션 컨텍스트에서 태스크를 실행한다. 일부 실시예에서, 앱 컨텍스트의 이벤트 실행 스레드는 요소 시맨틱 데이터에 의해 분류되는 분류된 시맨 틱 데이터에 기초하여 상응하는 UI 요소를 찾는 데 사용될 수 있는 UI 요소 파인더 및 특정 UI 요소 상에 서 동작을 수행하는 동작 관리자를 포함한다. 동작 관리자는 각각의 수행된 이벤트의 피드백을 수집 한다. 이벤트 디스패치 스레드로부터 이벤트가 수신될 때, UI 요소 파인더는 'Resource Id'를 기반으 로 특정 UI 요소를 검색하여 동작을 수행한다. AndroidTM 시스템에서, 고유 ID에 의해 식별되는 활동 스크린 상에 배치된 각각의 UI 요소는 'ResourceId'라고 한다. ResourceId는 애플리케이션 개발자에 의해 UI 요 소에 할당된 고유 문자열(string)이며, 상응하는 애플리케이션에 걸쳐 액세스할 수 있다. UI 요소 파인더 는 트리 포맷(tree format)으로 생성되고 구조화되는 생성된 UI 요소 시맨틱 데이터에서 데이터의 검색을 수행하여, 액세스할 필요가 있을 때 검색 동작을 효과적으로 수행한다(일 예는 도 6a에 예시됨). 이벤트/동작 실행 스레드는 수행할 이벤트/동작 디스패치 스레드로부터 동작을 수신한다. UI 요소 파인더는 텍스트 또는 이미지 아이콘을 기반으로 유사한 요소의 그룹을 식별하기 위해 분류되는 고유 코드인 'UI 요소의 시맨틱 코드'를 기반으로 UI 요소를 찾는다. 활동 스크린 UI 시맨틱 데이터가 동일한 카테고리의 하나 이 상의 요소를 포함하는 경우, UI 요소 파인더는 요소의 설명에 기초하여 UI 요소를 찾는다. 예를 들어, \"보 내기\" 및 \"트윗(tweet)\"은 의미상 동일한 카테고리에 있지만, 둘 다 UI 요소 파인더가 고유 시맨틱 코드, UI 요소 카테고리, 요소 설명, 스크린의 요소 좌표, 및 UI 요소 상에서 수행할 수 있는 동작을 기반으로 찾는 상이한 설명 UI 요소를 갖는다. 일부 실시예에서, 요소 UI 요소 파인더는 적절한 UI 요소를 찾기 위해 다양한 파라미터 상에서 상이하게 동작한다. 일 예인 케이스 1은 소스(학습된) 앱/애플리케이션 UI가 변경되지 않을 때, 즉, 태스크 학습 및 실행 이 동일한 애플리케이션 상에서 발생할 때 발생할 수 있다. 다른 예인 케이스 2는 소스 앱/애플리케이션 UI가 변경되지 않았지만 'ResourceId'가 사용할 수 없거나 변경되었을 때 발생할 수 있다. 'ResourceId'는 애플리케 이션을 개발하는 동안 개발자가 할당한 각각의 UI 요소의 고유 식별자이다. 케이스 2에서, 앱/애플리케이션 활 동 UI가 변경되지 않았지만, ResourceId가 사용할 수 없거나(예를 들어, FACEBOOK® 난독화(obfuscation)), ResourceId가 변경된 경우(가장 높은 정밀도로 새로운 태스크를 학습할 때, UI 요소 ResourceId는 이용할 수 없 음), 이벤트/동작 실행 스레드(타겟 애플리케이션 컨텍스트에서)는 앱/애플리케이션의 UI 활동의 요소 시 맨틱 데이터로부터 UI 요소의 x, y 좌표를 사용함으로써 UI 요소를 획득한다. 또 다른 예인 케이스 3에서, 태스크는 하나의 소스 앱/애플리케이션 상에서 학습되고, 애플리케이션 UI는 태스크 실행 중에 업데이트되었고, UI 요소 파인더는 UI 요소 시맨틱 데이터로부터 UI 요소에 대한 시맨틱 데이터 고유 시맨틱 코드를 사용하여 활동으로부터 올바른 요소를 식별한다. 일부 실시예에서, 현재 활동 스크린에서 적절한 UI 요소가 발견되지 않으면, UI 요소 파인더는 애플 리케이션에서 이용 가능한 활동에 기초하여 적절한 활동 스크린을 식별한다. 모든 활동은 애플리케이션의 매니페스토 파일(manifesto file)에 선언된다. 매니페스토 파일은 모든 허가(permission), 활동, 데이터베이스 및 다른 자원이 애플리케이션에서 사용되기 전에 선언되는 애플리케이션과 연관된 설정 파일이다. 스크린 상태 변경기(Screen State Changer)는 참여한 전체 활동의 활동 데이터와 관련된 태스크 학습 데이터를 기반으 로 매니페스토 파일로부터 인출된(fetched) 활동의 리스트로부터 적절한 활동을 선택하여 스크린 상에 적재한다. 활동 데이터는 활동에 대한 설명, UI 요소의 총 수, 요소의 타입, 활동이 태스크 학습 프로세스에 참 여했는지 여부 등을 포함한다. 사용 가능한 활동으로부터 올바른 활동 스크린을 식별하기 위해, UI 요소 파인더는 '활동의 총 UI 요소', '활동 설명으로부터의 활동 스크린의 타입', 매니페스토 파일에서 애플리 케이션의 개발자에 의해 부가되는 활동 스크린의 메타데이터와 같은 파라미터를 사용한다. 일 실시예에서, DynAmITE 처리는 최상의 가능한 활동을 결정하고, 태스크를 정확하고 올바르게 수행하기 위해 UI 요소를 선택하는 'Right Activity-Right Element'라고 하는 로직(logic)과 함께 작동한다. 사용자가 마지막으로 닫은 상태로부터 애플리케이션을 복원하는 지속성 상태로 애플리케이션을 론칭(launching)할 때, 애플리케이션은 다 음 론치(launch)에서 닫혀 있던 저장된 상태로부터 복원될 것이다. 따라서, 애플리케이션이 지속성 상태로부터론칭되면, DynAmITE 처리는'Right Activity-Right Element'이라는 접근 방식에 뒤따라 태스크 실행의 일 부로서 동작을 수행하기 위한 소스 활동 스크린 및 올바른 요소를 식별한다. 하나 이상의 실시예에서, 활 동 인식 코드는 애플리케이션의 이용 가능한 활동의 리스트로부터 활동을 식별하기 위해 생성기에 의해 생 성된 고유 식별자이다. 타겟 활동이 학습 활동으로부터 변경되지 않으면, 타겟 활동은 ResourceId를 사용하는 UI 요소로 찾아질 수 있다. 일부 실시예의 경우, 동작을 수행할 요소를 찾기 위해 UI 요소 파인더를 사용 하여 검색이 올바르지 않은 활동을 찾을 수 있는 예시적인 케이스가 아래에서 설명된다. 도 5는 일부 실시예에 따른 이벤트 디스패치 스레드에 대한 하이 레벨 흐름을 도시한다. 일부 실시예에서, 이벤트 디스패치 스레드는 검증자에 의한 이벤트의 검증 후에 태스크 큐(queue)로부터 각각의 이벤트 를 디스패치한다. 검증자는 UI 요소 및 UI 요소 클래스에 대한 시맨틱 데이터로 이벤트를 검증 한다. STaLES(300 처리(도 3)는 동작을 수행하기 위한 UI 요소를 검증하기 위해 UI 요소 클래스 데이터의 사전 정의된 전체 리스트를 갖는다. 각각의 이벤트는 특정 동작을 수행하기 위한 UI 요소의 타입에 따라 분류된 다. (음성 또는 키보드 입력 중 어느 하나를 사용하여) 사용자 입력으로부터 원하는 값을 선택하기 위해 EditText, OptionButton, ListView, DropdownListView 타입에 대한 UI 요소가 입력될 필요가 있다. 이러한 UI 요소는 태스크를 성공적으로 완료하기 위해 사용자로부터의 값을 수락한다(accept). 이러한 UI 요소는 입력 프 롬프트으로 이벤트/동작 디스패치 스레드(도 4)에 의해 사용자에게 동적으로 발행되는 사용자 발화 또는 프롬프트로부터 획득되는 사용자 특정 값으로 채워지거나 선택된다. 성공적인 입력 후, 이벤트는 이 벤트 이미 터에 의해 애플리케이션 컨텍스트(도 4)에서의 이벤트/동작 실행 스레드로 방출되며, 여기 서 동작은 앱/애플리케이션 컨텍스트로 수행된다. 도 6a는 일부 실시예에 따른 메모 앱/애플리케이션의 제1 버전에 대한 예시적인 스크린 상태 및 입력 데이터 요 소를 도시한다. 예시적인 메모 앱/애플리케이션의 제1 버전은 제목(Title) 및 설명으로서 입력 값을 수락하는 2 개의 스크린과 2개의 UI 요소, 및 새로운 메모(예를 들어, 텍스트 메모 또는 노트, 오디오 메모 또는 노트 등) 를 생성하기 위한 2개의 동작 UI 요소 \"부가(add)\" 및 \"저장(save)\"을 포함한다. 제1 스크린은 UI \"부가\" 버튼을 포함한다. 제2 스크린은 제목 UI 엔트리, 설명 UI 엔트리 및 UI 저장 버튼을 포함한다. 일부 실시예에서, STaLES 처리는 앱/애플리케이션의 요소 분류기(도 4)를 사용하여 UI 시맨틱 요소를 분류하거나 인식한다. 트리(tree)에서의 UI 요소 시맨틱 데이터 구조는 요소 시맨틱 데이터(도 4)에 의해 생성된다. 생성된 시맨틱 UI 요소 데이터는 SEM-ADD, SEM_TITLE, SEM_DATA 및 SEM_SAVE 요소로서 도 6a에 도시되어 있다. 스크린에서의 부가 버튼에 대한 UI 시맨틱 요소 데이터는 SEM_ADD 이다. 스크린에서의 제목 UI 엔트리에 대한 UI 시맨틱 요소 데이터는 SEM_TITLE이다. 스크린 에서의 설명 UI 엔트리에 대한 UI 시맨틱 요소 데이터는 SEM_DATA이다. 스크린에서의 UI 저장 버튼에 대한 UI 시맨틱 요소 데이터는 SEM_SAVE이다. 도 6b는 일부 실시예에 따른 메모 앱/애플리케이션의 제2 버전에 대한 예시적인 스크린 상태를 도시한다. 예시 적인 메모 앱/애플리케이션의 제2 버전은 입력 값을 수락하는 3개의 스크린 상태와 3개의 UI 요소, 및 마우스 또는 커서 \"클릭(click)\"과 같은 동작을 수행하는 3개의 UI 요소를 포함한다. 스크린은 메모 앱/애플리케 이션의 제1 버전에서와 동일한 UI 부가 버튼을 포함한다. 스크린은 제1 버전과 상이하며, 다음 UI 스크린 을 시작하기 위한 UI 메모 버튼을 포함한다. 스크린은 UI 제목 엔트리, UI 설명 엔트리, UI 위치 엔트리의 부가; 및 앱/애플리케이션의 제1 버전에서와 같이 \"저장\"이라는 단어 대신에 아이콘을 가진 UI \"저장\" 버튼을 포함한다. 일부 실시예에서, UI 요소 파인더는 생성된 트리로부터 시맨틱 요소를 찾고, 앱/애플리케이션의 제2 버전에 대한 유사한 UI 요소에 대해 이러한 시맨틱 요소를 사용한다. UI 요소 트 리는 UI 요소의 텍스트, 아이콘 및 이미지 타입의 3가지 주요 파라미터를 기반으로 생성된다. 텍스트 분류기 는 텍스트 분류기가 훈련된 동일한 관련 키워드에 대한 시맨틱 코드를 생성한다. 예를 들어, '보내기 (send)', '게시물(post)', '디스패치' 및 '쓰기(write)'는 모두 SMS, FACEBOOK, ® LINKEDIN® 및 다른 소셜 미디어 앱과 같은 유사한 애플리케이션에서 동작을 위해 의미상 동일한 목적으로 사용된다. 아이콘 분류기(70 2)는 모바일 장치의 다수의 애플리케이션으로부터 수집되는 다수(~4000)의 아이콘 이미지 상에서 훈련한다. 애 플리케이션에 걸친 동일한 보내기 동작은 사용자가 이해하기 위한 다양한 아이콘 이미지를 사용한다. 텍스트, 이미지 또는 둘 다 의미상 동일한 의미를 공유한다. 보내기 동작과 같은 특정 동작을 수행하기 위해 고유한 UI 요소의 타입은 UI 요소로서 버튼만을 사용한다. 애플리케이션에 버튼 동작을 배치하기 위해, 개발자는 ImageButton, TextView 및 Button과 같은 UI 요소를 사용한다. 모든 UI 요소는 버튼 동작을 수행하기 위해 유 사한 속성을 공유한다. 동작이 활성 스크린 상에서 수행될 필요가 있을 때, UI 요소 파인더는 시맨틱 데이 터로부터 모든 속성에서 유사한 동일한 UI 요소를 검색한다.도 7은 일부 실시예에 따른 이벤트/동작 실행 스레드의 흐름도를 도시한다. 일부 실시예에서, 태스크 바이 트코드는 타겟 애플리케이션이 태스크를 수행할 필요가 있는 애플리케이션 패키지 데이터와 함께 태 스크 데이터를 추출하기 위해 사용된다. 태스크 추출기는 활성 스크린(활동)으로 메모리에 대한 타겟 애플리케이션을 론칭한다. (요소) 분류기는 각각의 UI 요소를 UI 요소 데이터 텍스트, 아이콘 이미지, 요소의 설명 및 타입에 따라 활성 스크린에서 사용자가 볼 수 있거나 그렇지 않은 것으로 분류한 다. 분류기는 텍스트 분류기 및 아이콘 분류기를 포함한다. 분류기는 활성 스크린의 UI 요소 시맨틱 데이터를 생성한다. 실행 스레드가 스크린 상에서 수행할 태스크 바이트코드로부터의 동작을 수신할 때, 특정 동작 UI 요소는 활성 스크린 UI 요소 시맨틱 데이터로부터 찾아져야 한다. 일부 실시예에서, UI 요소 파인더는 태스크 바이트코드에서 현재 동작을 수행하기 위해 의미상 동등 한 UI 요소를 찾기 위해 검색 동작을 수행한다. UI 요소 파인더는 검색 결과를 태스크 바이트코드 로부터의 동작과 의미상 동일한 '찾아진 동작 UI 요소(action UI element found)' 또는 '찾아지지 않은 동작 요소(action element not found)'로서 출력한다. 검색 결과가 찾아지지 않은 경우, 동작 생성기는 UI 요소 상에서 수행할 동작을 생성한다. 동작 생성기는 태스크 바이트코드로부터 이 용 가능한 데이터에 기초하여 적절한 동작을 생성한다. 동작은 클릭, 긴 클릭, 스와이프, 선택 등과 같은 UI 동 작을 포함할 수 있다. 예를 들어, 동작이 \"event_scroll\"이고, 방향이 위로 였으면, 동작 생성기는 \"swipe_gesture\" 동작을 생성하고, 방향은 (UI의) 아래에서 위로이다. 동작 생성기는 적절한 입력 UI 요소 타입 상에서 현재 활성 스크린에 대한 입력 UI 요소 상에서 수행되는 동작을 위해 동작을 '동작 실행기'에 제공한다. 동작 검증자는 태스크가 (학습된 버전 이외의) 앱의 상이한 버전 상에서 실행할 때 동작 및 UI 요소를 검증한다. 동작 검증자는 동작(UI 요소 상에서 수행되는 동작)을 수행 하기 전에 피드백을 위해 사용자에게 프롬프트(음성/타입 입력 프롬프트)를 제공한다. 동작이 실행되는 것 을 보장하기 위해, 동작 검증자는 시스템에 의해 자동으로 생성되는 동작(입력 UI 요소 상에서 수행 되는 동작)을 수행한 후 피드백 이벤트를 검증한다. 동작 실행기가 ListView, Edit Text, Calendar 등과 같은 UI 요소 상에서 수행되는 동작을 수행하는 경우, 모든 태스크 실행은 태스크를 완료하기 위한 입력 값을 필요로 하며, 이는 음성/타입 입력 프롬프트에 의한 음성 또는 텍스트를 사용하여 사용자로부터 획득 되었다. 검색 결과가 '찾아지지 않은 동작 요소'로서의 결과를 생성하면, 현재 활성 스크린은 동작을 수행할 적절한 시맨틱 UI 요소를 가지고 있지 않고, 앱의 현재 활성 스크린을 변경하기 위해 스크린 상태 변경기에 입력된다. 현재 활성 스크린 데이터는 태스크를 학습하는 동안 태스크 바이트 코드로부터 이용 가능하다. 스크린 상태가 변경될 때, 프로세스는 분류기로부터 UI 요소 시맨틱 데이 터로 반복되고, 시맨틱 데이터 검색은 새로운 스크린 등에서 수행된다. 도 8a-c는 항공편 검색을 포함하는 태스크를 학습하는 예시를 위해 EXPEDIA® 앱에 대한 예시적인 스크린(810, 820 및 830)을 도시한다. 이러한 예에서, STaLES 처리(도 3)는 사용자 설명으로부터의 EXPEDIA® 애플리케 이션으로부터 (사용 가능한 항공권 예약 또는 보기의) 태스크를 학습한다. STaLES 처리는 상이한 입력 파 라미터를 사용하여 PRICELINE® 앱 상에서 동일한 태스크를 실행할 것이다. 도 9a-c는 일부 실시예에 따라 항공편을 검색하기 위해 학습된 태스크를 사용하기 위한 PRICELINE® 앱에 대한 예시적인 스크린(910, 920 및 930)을 도시한다. STaLES 처리는 학습으로부터 획득된 시맨틱 UI 요소를 사 용하여 PRICELINE® 앱/애플리케이션 상의 EXPEDIA® 앱으로부터 학습된 동일한 태스크를 실행하고, EXPEDIA® 앱 스크린(810, 820, 830)(도 8a-c)으로부터의 이러한 UI 요소는 스크린을 생성하기 위해 PRICELINE® 앱 스크린(910 및 920)에 입력된다. 도 10은 일부 실시예에 따라 제2 여행 애플리케이션과 함께 사용하기 위한 제1 여행 애플리케이션 에 대한 태스크를 학습하기 위한 예를 도시한다. 제1 여행 애플리케이션에서, 사용자는 다수의 타입의 7 개의 UI 요소: 동작 UI 요소(왕복 여행/단일 여행(round trip/single trip)), 입력 UI 요소 (from, to, date (from, to), 여행자 및 클래스), 및 동작 UI 요소(검색)를 사용함으 로써 \"항공편 검색\"이라는 태스크를 설명했다. STaLES 처리(도 3)는 UI 요소의 타입, 시맨틱 텍스트 또는 아이콘 값, '왕복 여행/단일 여행으로부터의 요소 UI 좌표, from, date, 여행자, 클래스, 동작 검 색과 같은 메타데이터 정보를 캡처하였다. 제1 여행 애플리케이션에서, \"왕복/단일 여행\"으 로부터의 스크린은 사용자가 동작을 수행하는 데 사용되는 UI 요소 '버튼'으로 인해 '동작 요소'로서 학습된다. 제2 여행 애플리케이션은 입력 UI 요소(from, to, date (from, to), 여행자 및 클래스를 왕 복 여행/단일 여행) 및 동작 UI 요소(검색)를 갖는 스크린을 포함한다. 동일한 태스크 \"항공 편 검색\"이 제2 여행 애플리케이션 상에서 실행될 때, '왕복/단일 여행' 값은 STaLES 처리가제2 여행 애플리케이션의 스크린 상의 2개의 옵션 버튼 상에서 '선택' 동작을 수행해야 하는 입력 값으로 서 취급되는 \"옵션 버튼\"으로서 마크된다. 일반적으로, 개인 비서로 태스크를 가능하게 하기 위해, NLU/NLP에서의 전문 지식이 필요하고, 프로그래밍 기술 이 필요하며, 통합된 개발 환경(integrated development environment; IDE) 도구의 사용에 대한 지식이 필요하 다. 일부 실시예는 이러한 통상의 요구 사항을 제거하고, 대신에 최종 사용자가 자신의 PA에 대한 태스크를 교 육할 수 있도록 한다. 이것은 PA를 쉽게 개인화하고, 최종 사용자에게 확장할 수 있다. 도 11은 일부 실시예에 따라 사용자 설명을 통해 새로운 태스크에 대한 사용자 개시된 NLU 개발을 위한 프로세 스의 흐름도를 도시한다. 하나 이상의 실시예에서, 프로세스는 STaLES(도 3)로 구현될 수 있 다. 블록에서, 사용자는 새로운 태스크에 대한 음성 명령을 나타내는 자연 발화(natural utterance)를 제 공한 다음, (음성을 포함하거나 포함하지 않은) 설명을 통해 전자 장치(예를 들어, 장치 1, 도 3) 상에서 새로운 태스크를 수행하는 방법을 교육하기 시작할 수 있다. 설명은 전자 장치의 스크린 상에서의 동작(예를 들 어, 클릭, 입력 타이핑 등)을 포함할 수 있고, 선택적으로 자연어의 음성 명령어도 포함한다. 블록에서, 프로세스는 태스크 실행 설명 상에서 스크린 추적을 수행한다. 하나 이상의 실시예에서, STaLES는 사용자가 태스크를 수행하는 방법을 \"감시한다(watch)\". 프로세스는 사용자가 스크린 상에서 어디에서 무 엇을 설명하는지를 자동으로 식별하고, 스크린 상호 작용을 음성 명령 발화의 단어/구문에 매핑한다. 블록 에서, 프로세스는 UI 슬롯 타입을 결정하고, UI 슬롯 값 추출을 수행한다. 프로세스를 통해 추출되는 정보는 \"슬롯 타입\"과 샘플 \"슬롯 값\"이다. 사용자는 태스크를 한 번 또는 여러 번 설명할 수 있다. 추출된 슬롯 타입과 슬롯 값을 입력으로서 사용하여, 사용자의 발화는 라벨링된 발화로 변환되어, NL 훈련을 수 행하기 위해 제공된다. 블록에서, 프로세스는 추출된 슬롯 정보에 기초하여 NLU 엔진 개발을 위한 훈련 샘플로서 라벨링된 발화를 구성한다. NL 엔진이 훈련된 후, 다음 번에 사용자가 동일하거나 의미상 유사한 음성 명령을 내릴 때, NLU 엔진은 태스크를 실행하기 위해 음성 명령을 이해할 수 있다. 도 12는 일부 실시예에 따라 사용자 교육으로부터 (프로세스, 도 11의) 슬롯 타입 및 슬롯 값 추출을 위 한 프로세스의 흐름도를 도시한다. 하나 이상의 실시예에서, 블록에서, (블록으로부터, 도 11) 사 용자 발화가 획득된다. 블록에서, (블록으로부터, 도 11) 사용자의 설명이 획득된다. 사용자 교육 으로부터의 슬롯 타입 및 슬롯 값 추출을 위해, 프로세스는 음성 명령어가 없는 사용자 교육 또는 음성 명령어가 있는 사용자 교육을 지원할 수 있다(즉, 블록). 일부 실시예에서, 블록에서, 프로세스 는 블록에서의 사용자 발화에 응답하여 수행되는 태스크 상의 설명의 스크린 추적을 제공한다. 블 록에서, 프로세스는 사용자 동작(예를 들어, 텍스트 단어 또는 아이콘)에서 어디에/무엇이 있는지, UI 스크린에서 이들이 어디에 위치하는지 추출한다. 텍스트 단어/구문 또는 시각적 아이콘 UI 요소는 (예를 들 어, OCR 등을 사용하여) 전자 장치의 스크린으로부터 추출된다. 블록에서, 추출된 UI 요소가 텍스트 단어 /구문이면, STaLES(도 3)은 UI 요소를 슬롯 타입으로서 직접 사용할 수 있다. 블록에서, 추출된 UI 요소가 시각적 아이콘인 경우, STaLES는 임의의 접근 방식을 사용하여 그 시맨틱 의미를 추출하고, 그 시 맨틱 의미의 텍스트 단어를 슬롯 타입으로서 사용할 수 있다. 사용자가 UI 요소에 타이핑하는 입력(발화의 일부)은 \"슬롯 값\"으로서 추출된다. 일부 실시예에서, 음성 명령어를 사용한 사용자 교육을 위해, 프로세스는 사용자 명령어를 사용한다. 사 용자 명령어에서, 사용자는 자연어를 사용하여 그 동작의 시맨틱을 나타낸다. 블록에서 사용자 발화로부 터의 시맨틱 단어는 슬롯 타입으로서 사용되며, 블록은 블록으로 진행하기 위해 스킵(skip)될 수 있다. 이러한 경로에서, 사용자가 UI 요소에 타이핑하는 입력(발화의 일부)은 \"슬롯 값\"으로서 사용된다. 도 13a-c는 일부 실시예에 따라 특정 태스크를 설명하는 데 사용되는 메시지 앱에 대한 예시적인 스크린 샷 (1310, 1320 및 1330)을 도시한다. 일 실시예에서, 사용자는 \"send a message to Mary: Happy Birthday\"의 특 정 태스크를 설명함으로써 \"누군가에게 메시지 보내기(sending a message to someone)\"의 태스크를 수행하는 방 법을 교육한다. 하나 이상의 실시예에 대해, 사용자는 음성이 있거나 없이 교육할 수 있다. 도 13a에서, 사용자 는 자신의 전자 장치 스크린 상에서 메시지(예를 들어, 클래식 메시지 앱) 앱을 연다. 메시지 앱은 사용 자의 입력을 기다리는 하나 이상의 필드를 포함하는 UI 요소를 제공한다. 예를 들어, 메시지 맵은 메시지의 수 신자를 요청하는 하나의 필드와 메시지 본문에 대한 다른 필드를 가질 수 있다. 도 13b에서, \"번호 또는 연락처 로 검색(to search by a number or contact)\"을 나타내는 스크린 상의 메시지 앱 라인 상에서, 사용자는 \"Mary\"를 타이핑한다. \"Message\"를 나타내는 라인 상에서, 사용자는 \"Happy Birthday\"를 타이핑한다. 도 13c에 서, 사용자는 스크린 상에서 메시지를 송신하기 위해 \"보내기\" 버튼을 클릭한다. 도 11-12를 참조하면, 프로세스는 스크린 추적을 수행하고(블록에서), 블록에서 \"수신자\"의 하나의 슬롯 타입으로서 \"번호 또는 연락처\"를 추출하고; 이러한 슬롯 타입에 대한 하나의 잠재적 슬롯 값으로서 \"Mary\"를 추출한다. 유사하게, 블록은 \" Message\"를 하나의 슬롯 타입으로서 추출하고; 이러한 슬롯에 대한 하나의 잠재적 슬 롯 값으로서 \"Happy Birthday\"를 추출한다. 하나 이상의 실시예에서, 교육은 여러 번 수행될 수 있다. 하나의 예시적인 실시예에서, 사용자가 \"send message to Mary: Happy Birthday\"를 수행하는 것을 교육한 후, 사용자 는 다른 발화, 예를 들어 \"Tell Amy that I am running late\"로 교육할 수 있다. \"번호 또는 연락처로 검색(to search by a number or contact)\"을 나타내는 스크린의 라인 상에서, 사용자는 \"Amy\"를 타이핑한다. \"Messag e\"를 나타내는 스크린의 라인 상에서, 사용자는 “I am running late\"를 타이핑한다. 그런 다음, 사용자는 메시 지를 보내기 위해 스크린 상의 \"보내기\" 버튼을 클릭한다. 이들 2개의 교육 예에 기초하여, 블록은 슬롯 타입 \"수신자\"로서 \"번호 또는 연락처\"를 추출하고; 이러한 슬롯 타입에 대한 하나의 잠재적 슬롯 값으로서 \"Mary\"를 추출하고 다른 잠재적 슬롯 값으로서 \"Amy\"를 추출한다. 유사하게, 블록 처리는 \"Message\"를 하 나의 슬롯 타입으로서 추출하고; 이러한 슬롯 타입에 대한 하나의 잠재적 슬롯 값으로서 \"Happy Birthday\"를 추 출하고, 이러한 슬롯 타입에 대한 다른 잠재적 슬롯 값으로서 \"I am run late\"를 추출한다. 다른 실시예에서, 사용자는 음성 명령어로 \"send message to Mary Happy Birthday\"를 보내는 방법을 설명함으 로써 \"누군가에게 메시지 보내기\"의 태스크를 수행하는 방법을 교육한다. 사용자는 전자 장치 스크린 상에서 Message (Classic) 앱을 연다. \"번호 또는 연락처로 검색\"을 나타내는 스크린의 라인 상에서, 사용자는 “I am typing in Mary as recipient\" 또는 단순히 \"Recipient\"의 음성 명령어를 내면서 \"Mary\"를 타이핑한다. \"Message\"를 나타내는 스크린의 라인 상에서, 사용자는 “I am typing in Happy Birthday as message\" 또는 단 순히 \"Message\"의 음성 명령어를 내면서 \"Happy Birthday\"를 타이핑한다. 그런 다음, 사용자는 메시지를 보내기 위해 스크린 상에서 \"보내기\" 버튼을 클릭한다. 블록에서, 프로세스는 \"수신자\"를 하나의 슬롯 타 입으로서 추출하고; NLU를 통해 이러한 슬롯 타입에 대한 하나의 잠재적 슬롯 값으로서 \"Mary\"를 추출한다. 프 로세스는 \"수신자\"가 스크린 상에서 \"번호 또는 연락처로 검색\" 라인에 매핑된다는 것을 알고 있다. 유사 하게, 블록에서, 프로세스는 \" Message\"를 하나의 슬롯 타입으로서 추출하고; 이러한 슬롯에 대한 하나의 잠재적 슬롯 값으로서 \"Happy Birthday\"를 추출한다. 하나 이상의 실시예에서, 교육은 여러 번 수행될 수 있다. 사용자가 \"send message to Mary Happy Birthday\"를 수행함으로써 교육한 후, 사용자는 \"Tell Amy that I am running late\"의 다른 발화로 다시 교육할 수 있다. \"번호 또는 연락처로 검색\"을 나타내는 스크린의 라인 상에서, 사용자는 “I am typing in Amy as recipient\"의 음성 명령어를 내면서 \"Amy\"를 타이핑한다. \"Message\"를 나타내는 스크린의 라인 상에서, 사용자는 “I am typing in I am running late as message\"의 음 성 명령어를 내면서 “I am running late\"를 타이핑한다. 그런 다음, 사용자는 메시지를 보내기 위해 \"보내기\" 버튼을 클릭한다. 이들 2개의 교육 사례(instance)에 기초하여, 블록은 하나의 슬롯 타입으로서 \"수신 자\"를 추출하고, 이러한 슬롯 타입에 대한 하나의 잠재적 슬롯 값으로서 \"Mary\"를 추출하며, 다른 잠재적 슬롯 값으로서 \"Amy\"를 추출한다. 유사하게, \"Message\"는 하나의 슬롯 타입으로서 추출되고, 이러한 슬롯 타입에 대 한 하나의 잠재적 슬롯 값으로서 \"Happy Birthday\"를 추출하며, 이러한 슬롯 타입에 대한 다른 잠재적 슬롯 값 으로서 \"I am running late\"를 추출한다. 이러한 프로세스는 또한 태스크를 형성하기 위해 메시지 앱을 결정된 슬롯 타입 및 슬롯 값과 연관시킬 것이다. 도 14는 일부 실시예에 따라 (프로세스, 도 11의) NLU 엔진 개발을 위한 라벨링된 발화 샘플을 구성하는 프로세스의 흐름도를 도시한다. 하나 이상의 실시예에서, 새로운 태스크와 연관된 사용자 발화는 블록에 입력된다. 추출된 슬롯 타입 및 슬롯 값은 블록으로부터 블록에 입력된다(또한, 도 12 참조). 블록 은 상술한 추출된 슬롯 타입 및 슬롯 값을 사용하여 추가로 라벨링된/주석이 달린 사용자 교육 발화 (annotated user taught utterance)를 구성한다. NLU 엔진 개발을 위한 발화 샘플은 추출된 슬롯 타입 및 슬롯 값을 기반으로 라벨링된 발화 샘플을 구성한다. 블록에서, 원한다면, 프로세스는 패러프레이징 (paraphrasing)을 통해 주어진 슬롯 타입 및 슬롯 값으로 동일한 태스크에 대한 유사한 발화를 구성한다. 블록 에서, 더 많은 주석이 달린 발화는 1330으로부터, 또는 사용자 입력 또는 다른 적용 가능한 소스로부터의 결과로서 획득된다. 블록에서, 프로세스는 NLU 모델을 훈련시킨다. 추출된 슬롯 타입 및 슬롯 값은 라벨링된 발화와 함께 NL 훈련(블록에서) 및 NLU 엔진의 개발을 수행하기 위해 필요하다. 하나 이상의 실 시예에서, 임의의 알려진 NL 훈련 접근 방식은 구현될 수 있다. NLU 엔진이 훈련된 후, NLU 엔진은 새롭게 교육 된 이러한 태스크에 대해 사용자로부터 향후 새로운 발화를 이해할 수 있다. 예를 들어, 훈련된 NLU 엔진은 수 신자로서 \"David\"를 구문 분석(parsing)하고, 메시지로서 \"where are you\"를 구문 분석함으로써 “Write a message to David: where are you?\"라는 새로운 발화를 이해할 수 있을 것이다. 일 실시예에서, PA는 이러한 사용자 발화에 응답하여 메시지 앱을 호출하고, 이에 따라 메시지를 보낼 수 있다. 하나의 예시적인 실시예에서, 사용자는 “send a message to Mary: Happy Birthday\"를 보내는 방법을 설명함으 로써 “send a message to someone\"이라는 태스크를 수행하는 방법을 교육한다. 블록에서, 프로세스 는 사용자 교육에 기초하여 NLU 엔진 훈련을 위한 라벨링된 데이터 포인트를 구성한다. “send a message to Mary: Happy Birthday\"의 원래의 교육 발화는 라벨링되지 않는다. 블록(도 12) 및 블록에서 사 용자 설명 및 처리 후, 라벨링되지 않은 발화는 \"수신자\" 슬롯 타입으로서 라벨링된 \"Mary\"를 갖는 라벨링된 발 화가 되고; \"Happy Birthday\"는 \"메시지\" 슬롯 타입으로서 라벨링된다. “Tell Amy that I am running late\"의 다른 교육 발화는 이제 \"수신자\" 슬롯 타입으로서 라벨링된 \"Amy\"으로 라벨링되고; \"I am running late\"는 \"메 시지\" 슬롯 타입으로서 라벨링된다. 교육된 라벨링되지 않은 발화는 모두 이제 라벨링된 데이터 포인트가 되며, 블록에서 NLU 엔진을 훈련하는 데 사용될 수 있다. 하나 이상의 실시예에서, 모든 사용자 교육 발화는 이제 라벨링되고, 라벨링된 사용자 교육 발화만이 블록 에서 NL 훈련을 위해 다시 제공된다. 일부 실시예에서, 임의의 패러프레이즈 생성기(paraphrase generato)는 (블록에서) 더 많은 발화를 생성하여, 추출된 슬롯 타입으로 라벨링하기 위해 구현될 수 있 다. 패러프레이즈 생성기는 클라우드/서버(도 2) 또는 전자 장치(예를 들어, 전자 장치, 도 2, 장치 1, 도 3 등) 상에서 실행/수행될 수 있다. 라벨링된 모든 발화는 NL 훈련에 제공할 수 있다. 도 15는 일부 실시예에 따른 지능형 태스크 학습 및 적응형 처리를 위한 프로세스의 블록도를 도시한다. 일부 실시예에서, 블록에서, 프로세스는, 전자 장치(예를 들어, 전자 장치, 도 2, 장치 1, 도 3, 시스템, 도 16 등)에서, 전자 장치에 의해 운영되는 제1 애플리케이션(또는 앱)으로 향한 명령(예를 들어, PA 등에 의해 수신된 음성 명령)을 수신하는 단계를 포함한다. 블록에서, 프로세스 는 전자 장치에서 (예를 들어, STaLES(도 3)을 사용하여) 제1 애플리케이션과의 상호 작용에 응답하 여 제1 애플리케이션에 의해 제시된 다수의 특징(예를 들어, 제1 애플리케이션에 의해 표시되는 특징, UI 요 소)을 캡처한다. 블록에서, 프로세스는, 전자 장치에서 (STaLES를 사용하여) 제1 애플리케이 션과의 상호 작용을 통해 제1 애플리케이션과 통신된 데이터(예를 들어, 텍스트, 음성, 아이콘 등, UI 요소)를 캡처한다. 블록에서, 프로세스는 캡처된 다수의 특징 및 통신된 데이터를 기반으로 태스크를 학습 한다. 블록에서, 프로세스는 태스크에 기초하여 명령을 제2 애플리케이션(예를 들어, 제1 애플리케 이션의 상이한 버전, 유사한 타입의 애플리케이션 등)에 적용한다. 일부 실시예에서, 프로세스는 통신된 데이터 간의 상관 관계(correlation)를 나타내는 그래프(예를 들어, 요소 시맨틱 데이터(도 3)의 UI 트리)를 구성하는 단계를 포함할 수 있다. 통신된 데이터는 사용자 음성 데이터를 포함한다. 프로세스는 그래프에 기초하여 캡처된 다수의 특징의 시맨틱 의미를 결정하는 단계를 더 포함할 수 있다. 다수의 특징은 텍스트 특징, 아이콘 특징 또는 둘 다를 포함할 수 있다. 하나 이상의 실시예에서, 프로세스에서, 태스크에 기초하여 제2 애플리케이션에 명령을 적용하는 단계는 명령에 기초하여 태스크 세트로부터 태스크를 선택하는 단계, 제2 애플리케이션과의 상호 작용의 일부를 수행하 기 위한 태스크를 적용하는 단계, 및 제2 애플리케이션과의 나머지 상호 작용을 보충하기 위해 상이한 태스크 세트로부터 다른 태스크를 적용하는 단계를 더 포함할 수 있다. 일부 실시예에서, 태스크는 제1 애플리케이션과 상호 작용하는 일련의 동작을 나타내는 데이터 세트, 및 일련의 동작과 연관된 시맨틱 블록 큐를 포함한다. 다수의 특징은 UI 요소를 포함한 시각적 특징을 포함한다. 하나 이상의 실시예에서, 프로세스는 제1 애플리케이션과의 상호 작용으로부터 슬롯 타입(예를 들어, UI 엔트리 슬롯 타입) 및 슬롯 값(예를 들어, UI 엔트리 데이터 값)을 추출하는 단계를 포함할 수 있다. 음성 명령 어 없이 제1 애플리케이션과의 상호 작용을 위해, 추출하는 단계는 전자 장치에 의해 표시된 인터페이스로부터 텍스트 데이터 UI 요소 또는 하나 이상의 시각적 아이콘을 추출하는 단계를 포함하고; 텍스트 데이터는 슬롯 타 입으로서 직접 사용된다. 하나 이상의 시각적 아이콘은 시맨틱 의미를 추출하기 위해 처리되고, 시맨틱 의미는 다른 슬롯 타입으로서 사용된다. 일부 실시예에서, 음성 명령어를 사용한 제1 애플리케이션과의 상호 작용을 위한 프로세스에서, 음성 명 령어의 적어도 일부는 슬롯 값으로서 사용된다. 하나 이상의 실시예에서, 프로세스는 슬롯 타입 및 슬롯 값에 기초하여 NLU 엔진 개발을 위한 라벨링된 발화 샘플을 구성하는 단계를 더 포함할 수 있다. 도 16은 하나 이상의 실시예를 구현하는 컴퓨팅 시스템을 포함하는 정보 처리 시스템을 도시하는 예시적인 하이 레벨 블록도이다. 시스템은 하나 이상의 프로세서(예를 들어, ASIC, CPU 등)를 포함하고, (그래픽, 텍스트 및 다른 데이터를 표시하기 위한) 전자 디스플레이 장치, 메인 메모리(예를 들어, 랜덤 액세스 메모리(RAM), 캐시 장치 등), 저장 장치(예를 들어, 하드 디스크 드라이브), 이동식 저장 장치 (예를 들어, 이동식 저장 드라이브, 이동식 메모리, 자기 테이프 드라이브, 광학 디스크 드라이브, 컴퓨 터 소프트웨어 및/또는 데이터를 저장한 컴퓨터 판독 가능한 매체), 사용자 인터페이스 장치(예를 들어, 키보드, 터치 스크린, 키패드, 포인팅 장치), 및 통신 인터페이스(예를 들어, 모뎀, 무선 송수신기(예를 들어, Wi-Fi, 셀룰러), 네트워크 인터페이스(예를 들어, 이더넷 카드), 통신 포트 또는 PCMCIA 슬롯 및 카드)를 더 포함할 수 있다. 통신 인터페이스는 인터넷, 모바일 전자 장치, 서버, 네트워크 등을 통해 컴퓨 터 시스템과 외부 장치 간에 소프트웨어 및 데이터를 전송할 수 있도록 한다. 시스템은 상술한 장치(1611 내지 1617)가 연결되는 통신 인프라(예를 들어, 통신 버스, 크로스바 또는 네트워크)를 더 포함한다. 통신 인터페이스를 통해 전송되는 정보는 신호를 반송하는 통신 링크를 통해 통신 인터페이스에 의 해 수신될 수 있는 전자, 전자기, 광학 또는 다른 신호와 같은 신호의 형태일 수 있고, 유선 또는 케이블, 광섬 유, 전화선, 셀룰러 폰 링크, 무선 주파수(RF) 링크 및/또는 다른 통신 채널을 사용하여 구현될 수 있다. 전자 장치(예를 들어, 전자 장치, 도 2)에서의 하나 이상의 실시예의 일 구현에서, 시스템은 카메라 (도 2)와 같은 이미지 캡처 장치 및 마이크로폰(도 2)과 같은 오디오 캡처 장치를 더 포 함한다. 시스템은 MMS, SMS, 이메일, 소셜 네트워크 인터페이스(social network interface; SNI), 오디오/비디오(AV) 플레이어, 웹 브라우저, 이미지 캡처 등으로서 애플리케이션 처리 또는 프로세서를 더 포함할 수 있다. 일부 실시예에서, 시스템은 ILS 처리(도 3), 흐름 처리(도 4), 흐름 처리(도 5), 흐름 처리(도 6), 흐름 처리(도 7), 흐름 처리(도 8) 및 프로세스(도 13)에 관해 설명된 것 과 유사한 처리를 구현할 수 있는 지능형 학습 처리를 포함한다. 일 실시예에서, 운영 체제(operating system; O/S)와 함께 지능형 학습 처리는 시스템의 메모리에 상주하는 실행 코드로서 구현될 수 있다. 다른 실시예에서, 지능형 학습 처리는 하드웨어, 펌웨어 등에 제공될 수 있다. 일 실시예에서, 메인 메모리, 저장 장치 및 이동식 저장 장치는 각각 단독으로 또는 임의의 조합으로 하나 이상의 프로세서에 의해 실행될 수 있는 상술한 실시예에 대한 명령어를 저장할 수 있다. 통상의 기술자에게 알려진 바와 같이, 상술한 아키텍처에 따라 상술한 예시적인 아키텍처는, 소프트웨어 모듈, 마이크로코드, 컴퓨터 판독 가능한 매체 상의 컴퓨터 프로그램 제품, 아날로그/논리 회로, 애플리케이션 특정 집적 회로, 펌웨어, 소비자 전자 장치, AV 장치, 무선/유선 송신기, 무선/유선 수신기, 네트워크, 멀티미디어 장치 등으로서 프로세서에 의한 실행을 위한 프로그램 명령어와 같이 다양한 방식으로 구현될 수 있다. 또한, 상기 아키텍처의 실시예는 전체 하드웨어 실시예, 전체 소프트웨어 실시예 또는 하드웨어 및 소프트웨어 요소 모두를 포함하는 실시예의 형태를 취할 수 있다. 하나 이상의 실시예는 하나 이상의 실시예에 따른 방법, 장치(시스템) 및 컴퓨터 프로그램 제품의 흐름도 예시 및/또는 블록도를 참조하여 설명되었다. 이러한 예시/다이어그램의 각각의 블록, 또는 이들의 조합은 컴퓨터 프 로그램 명령어에 의해 구현될 수 있다. 프로세서에 제공될 때 컴퓨터 프로그램 명령어는 프로세서를 통해 실행 되는 명령어가 흐름도 및/또는 블록도에 명시된 기능/동작을 구현하는 수단을 생성하도록 하는 머신을 생성한다. 흐름도/블록도의 각각의 블록은 하나 이상의 실시예를 구현하는 하드웨어 및/또는 소프트웨어 모듈 또는 로직을 나타낼 수 있다. 대안적인 구현에서, 블록에 언급된 기능은 도면에 언급된 순서와 다르게 동시에 발생할 수 있다. \"컴퓨터 프로그램 매체\", \"컴퓨터 사용 가능한 매체\", \"컴퓨터 판독 가능한 매체\"및 \"컴퓨터 프로그램 제품\"이 라는 용어는 일반적으로 메인 메모리, 보조 메모리, 이동식 저장 드라이브, 하드 디스크 드라이브에 설치된 하 드 디스크와 같은 매체를 지칭하는 데 사용된다. 이러한 컴퓨터 프로그램 제품은 컴퓨터 시스템에 소프트웨어를 제공하는 수단이다. 컴퓨터 판독 가능한 매체는 컴퓨터 시스템이 컴퓨터 판독 가능한 매체로부터 데이터, 명령 어, 메시지 또는 메시지 패킷 및 다른 컴퓨터 판독 가능한 정보를 판독할 수 있게 한다. 예를 들어, 컴퓨터 판 독 가능한 매체는 플로피 디스크, ROM, 플래시 메모리, 디스크 드라이브 메모리, CD-ROM 및 다른 영구 저장소 (storage)와 같은 비휘발성 메모리를 포함할 수 있다. 이는, 예를 들어, 컴퓨터 시스템 간에 데이터 및 컴퓨터 명령어와 같은 정보를 전송하는 데 유용하다. 컴퓨터 프로그램 명령어는 컴퓨터, 다른 프로그램 가능한 데이터 처리 장치 또는 다른 장치가 특정 방식으로 기능하도록 지시할 수 있는 컴퓨터 판독 가능한 매체에 저장될 수 있음으로써, 컴퓨터 판독 가능한 매체에 저장된 명령어는 명령어를 포함하는 제조품을 생성하며, 이는 흐름도및/또는 블록도 다이어그램 블록에 명시된 기능/동작을 구현한다. 본 명세서에서 블록도 및/또는 흐름도를 나타내는 컴퓨터 프로그램 명령어는 컴퓨터, 프로그램 가능한 데이터 처리 장치 또는 처리 장치 상에 적재되어, 그 상에서 수행되는 일련의 동작이 컴퓨터 구현 프로세스를 생성하게 할 수 있다. 컴퓨터 프로그램(즉, 컴퓨터 제어 로직)은 메인 메모리 및/또는 보조 메모리에 저장된다. 컴퓨터 프로그램은 또한 통신 인터페이스를 통해 수신될 수 있다. 이러한 컴퓨터 프로그램은, 실행될 때, 컴퓨터 시스 템이 본 명세서에서 논의된 바와 같이 실시예의 특징을 수행할 수 있게 한다. 특히, 컴퓨터 프로그램은, 실행될 때, 프로세서 및/또는 다중 코어 프로세서가 컴퓨터 시스템의 특징을 수행할 수 있게 한다. 이러한 컴퓨터 프로 그램은 컴퓨터 시스템의 제어부를 나타낸다. 컴퓨터 프로그램 제품은 컴퓨터 시스템에 의해 판독 가능하고, 하 나 이상의 실시예의 방법을 수행하기 위해 컴퓨터 시스템에 의해 실행되는 명령어를 저장하는 유형의(tangible) 저장 매체를 포함한다. 실시예는 특정 버전을 참조하여 설명되었지만; 다른 버전도 가능하다. 따라서, 첨부된 청구항의 사상 및 범위는 본 명세서에 포함된 바람직한 버전의 설명으로 제한되지 않아야 한다."}
{"patent_id": "10-2021-7031377", "section": "도면", "subsection": "도면설명", "item": 1, "content": "바람직한 사용 모드뿐만 아니라 실시예의 특성 및 이점에 대한 완전한 이해를 위해, 첨부된 도면과 함께 읽혀진 다음의 상세한 설명에 대한 참조가 이루어져야 한다. 도 1은 일부 실시예에 따른 통신 시스템의 개략도를 도시한다. 도 2는 일부 실시예에 따라 지능형 태스크 학습 및 적응형 처리(adaptive processing)를 개별적으로 또는 조합 하여 수행할 수 있는 전자 장치 및 클라우드 또는 서버 환경을 포함하는 시스템에 대한 아키텍처의 블록도를 도 시한다. 도 3은 일부 실시예에 따른 시맨틱 지능형 태스크 학습 및 적응형 실행 시스템(semantic intelligent task learning and adaptive execution system; STaLES) 및 그 동작에 대한 하이 레벨 블록도를 도시한다. 도 4는 일부 실시예에 따른 동적 앱 적응 및 대화형 태스크 실행(dynamic app adaption and interactive task execution; DynAmITE) 처리를 위한 하이 레벨 흐름을 도시한다. 도 5는 일부 실시예에 따른 STaLES 실행 블록도에 대한 하이 레벨 흐름을 도시한다. 도 6a는 일부 실시예에 따른 메모 앱/애플리케이션의 제1 버전에 대한 예시적인 스크린 상태 및 입력 데이터 요 소를 도시한다. 도 6b는 일부 실시예에 따른 메모 앱/애플리케이션의 제2 버전에 대한 예시적인 스크린 상태를 도시한다. 도 7은 일부 실시예에 따른 이벤트/동작 실행 스레드(event/action execution thread)의 흐름도를 도시한다. 도 8a-c는 항공편 검색(searching for flights)을 포함하는 태스크를 학습하는 예시를 위한 EXPEDIA® 앱에 대 한 예시적인 스크린을 도시한다. 도 9a-c는 일부 실시예에 따라 항공편 검색을 위해 학습된 태스크를 사용하기 위한 PRICELINE® 앱에 대한 예시 적인 스크린을 도시한다. 도 10은 일부 실시예에 따른 제2 여행 애플리케이션(travel application)과 함께 사용하기 위한 제1 여행 애플 리케이션에 대한 태스크를 학습하기 위한 예를 도시한다. 도 11은 일부 실시예에 따른 사용자 설명을 통해 새로운 태스크에 대한 사용자 개시(user initiated) NLU(natural language understanding) 개발을 위한 프로세스 흐름도를 도시한다. 도 12는 일부 실시예에 따라 사용자 교육(user teaching)으로부터 슬롯 타입 및 슬롯 값 추출을 위한 프로세스 흐름도를 도시한다. 도 13a-c는 일부 실시예에 따라 특정 태스크를 설명하는 데 사용되는 메시지 앱에 대한 예시적인 스크린 샷 (screen shot)을 도시한다. 도 14는 일부 실시예에 따라 NLU 엔진 개발을 위한 라벨링된 발화 샘플(labeled utterances sample)을 구성하기 위한 프로세스 흐름도를 도시한다. 도 15는 일부 실시예에 따라 지능형 태스크 학습 및 적응형 처리를 위한 프로세스의 블록도를 도시한다. 도 16은 하나 이상의 실시예를 구현하는 컴퓨팅 시스템을 포함하는 정보 처리 시스템을 도시하는 하이 레벨 블 록도이다."}
