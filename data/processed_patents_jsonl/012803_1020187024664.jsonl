{"patent_id": "10-2018-7024664", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2018-0132044", "출원번호": "10-2018-7024664", "발명의 명칭": "재구성 가능한 알고리즘 파이프라인 코어 및 알고리즘 매칭 파이프라인 컴파일러를 갖는 프로", "출원인": "아이씨에이티 엘엘씨", "발명자": "카틸러 로버트"}}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "재사용 가능한 알고리즘 파이프라인 코어로서,프로세싱 유닛; 재구성 가능한 필드 프로그래머블 게이트들의 어레이를 포함하고, 상기 필드 프로그래머블 게이트들은 알고리즘 매칭 파이프라인 컴파일러 (algorithmic matching pipelinedcompiler)에 의해 프로그램되어, 상기 알고리즘 매칭 파이프라인 컴파일러가 상기 프로세싱 유닛에 의한 처리를위해 병렬 처리 없이 표준 프로세서상에서의 동작을 위해 설계된 소스 코드를 프리 컴파일하고, 그리고상기 프로세싱 유닛 및 상기 알고리즘 매칭 파이프라인 컴파일러는 상기 필드 프로그래머블 게이트들을 파이프라인 병렬 프로세서로서 동작하도록 구성하는 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인형 코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 알고리즘 매칭 파이프라인 컴파일러는 프리 컴파일러인 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인 코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 프리 컴파일러는 상기 코어용으로 작성된 것이 아니라 종래의 비-재구성 가능한 프로세서용으로 작성된 표준 상위 레벨 소프트웨어 언어를 프리 컴파일하도록 구성되고, 상기 프리 컴파일러는 상기 표준 상위 레벨 소프트웨어 언어가 재구성 가능한 필드 프로그래머블 게이트들의 어레이를 구성하는 기계 코드를 생성하기 위해 작성되는 종래의 비-재구성 가능 프로세서의 타입을 이용하여 상기코어에 대한 기계 코드를 생성하는 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인 코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 표준 상위 레벨 소프트웨어 언어는 C 또는 C++인 것인 특징으로 하는 재사용 가능한 알고리즘 파이프라인코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서, 상기 코어는 상기 프리 컴파일러로부터의 출력에 기초하여, 특정 계산을 위해 필요에 따라 알고리즘들을 처리하도록 구성된 컴퓨터들의 풀(pool)을 포함하는 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인 코어.[청구항 5]제1항에 있어서, 상기 필드 프로그래머블 게이트들은 상기 프로세싱 유닛으로부터의 임의의 추가 오버헤드 없이 태스크들을 완료하도록 구성되는 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인 코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서, 공개특허 10-2018-0132044-3-지능형 버스 제어기 또는 논리 프로세서를 더 포함하고, 상기 지능형 버스 제어기 또는 논리 프로세서는 상기코어에 의해 처리된 논리 기능 전부를 수행하는 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인 코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제5항에 있어서, 논리 프로세서 및 마스터 버스 스위치를 더 포함하고, 상기 논리 프로세서는 상기 마스터 버스 스위치를 제어하기 위한 재구성 가능한 논리 기능을 포함하는 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인 코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서, 디지털 신호 프로세서를 더 포함하며, 상기 디지털 신호 프로세서는 수학적 계산을 수행하기 위한 재구성 가능한 수학 프로세서를 포함하는 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인 코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서, 상기 마스터 버스 스위치는 알고리즘을 처리하는 동안 중앙 프로세서 또는 주변 장치 프로세서로부터의 추가 개입없이 알고리즘을 완료하기 위해 데이터 및 결과가 상기 코어로부터 다른 코어로 라우팅되도록 상기 프리 컴파일러 및 상기 프로세싱 유닛에 의해 재구성 가능하게 프로그램 가능한 회로를 포함하는 매트릭스 버스 라우터또는 스위치를 포함하여, 연산 처리 장치 안팎으로 데이터 및 결과를 전달하기 위해 중앙 프로세서 또는 주변프로세서에 의한 개입을 필요로 하는 정적인 비-재구성 가능 하드웨어에 비해 파이프라이닝에 의해 오버 헤드를줄이는 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인형 코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 논리 프로세서는 논리 결정들 및 반복 루프들을 처리하고, 결과 메모리는 알고리즘 학습을 위해 상기 논리프로세서에 의해 제공되는 것을 특징으로 하는 재사용 가능한 알고리즘 파이프라인 코어."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제1항에 따른 복수의 코어들을 포함하는 시스템으로서, 복수의 코어들 중 하나 이상의 코어의 디지털 신호 프로세서를 사용하여 모든 수학적 연산을 처리하는 동작; 및상기 복수의 코어들 중 하나 이상의 코어의 하나 이상의 논리 프로세서를 사용하여 모든 로직 기능 모두를 처리하는 동작을 포함하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서, 상기 복수의 코어를 코어 풀(pool)로서 구성하는 동작을 더 포함하고, 상기 각 코어 풀은 상기 하드웨어를 변경하지 않고 프로그래밍만으로 재구성 가능한 것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서, 상기 구성하는 단계는 중앙 프로세서 또는 주변 프로세서로부터의 추가 개입없이 병렬로 알고리즘을 처리하도록상기 복수의 코어 모두를 구성하여 연산 처리 장치의 내부 및 외부로 데이터 및 결과를 전달하는 것을 특징으로하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서, 공개특허 10-2018-0132044-4-상기 알고리즘 매칭 파이프라인 컴파일러는 프리 컴파일러이고, 상기 복수의 코어 각각의 논리 프로세서는 룩업테이블 및 상수 또는 학습 값을 위한 레지스터로서 상기 프리 컴파일러에 의해 구성된 메모리 블록을 사용하는것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서, 상기 논리 프로세서에 의해 상기 룩업 테이블을 설정하는 동작을 더 포함하고, 상기 룩업 테이블은 n-비트 룩업테이블이고, 상기 n-비트 룩업 테이블은 n-비트 부울 논리 함수를 진리표로서 인코딩하기 위해 사용되는 것을특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제11항에 있어서, 상기 복수의 코어들 중 하나 이상에 대한 상기 알고리즘 매칭 파이프라인 컴파일러를 사용하여, 종래의 비-재구성 가능하고 비-파인프라인된 범용 컴퓨터 프로세서용으로 작성된 표준 고급(higher level) 소프트웨어 언어로부터 기계 코드를 생성하는 동작을 더 포함하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서, 상기 표준 상위 레벨 소프트웨어 언어는 일 유형의 종래의 비-재구성 가능 프로세서용으로 작성되고, 상기 기계 코드를 생성하는 동작은 프리 컴파일러로서 상기 알고리즘 매칭 파이프라인 컴파일러를 포함하고, 상기 유형의 종래의 비-재구성 가능 프로세서를 이용하여 상기 복수의 코어 각각의 재구성 가능한 필드 프로그래머블 게이트들의 어레이를 구성하는 동작을 포함하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서, 상기 시스템은 상기 표준 상위 레벨 소프트웨어 언어가 작성되는 상기 유형의 종래의 비-재구성 가능 프로세서의 적어도 하나의 프로세서를 포함하고,상기 표준 상위 레벨 소프트웨어 언어가 작성되는 상기 유형의 종래의 비-재구성 가능 프로세서의 적어도 하나의 프로세서는 복수의 코어 각각의 재구성 가능 필드 프로그래머블 게이트의 어레이를 구성하기 위한 기계 코드를 생성하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서, 상기 복수의 코어 각각은, 상기 표준 상위 레벨 소프트웨어 언어가 작성되는 상기 유형의 종래의 비-재구성 가능 프로세서의 적어도 하나의 프로세서에 의한 추가 개입없이 복잡한 수학적 및 논리 알고리즘을 독립적으로 해결하도록 구성되는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제19항에 있어서, 상기 시스템에 값들을 입력하는 동작을 더 포함하고, 상기 시스템은 추가 개입 없이 솔루션을 상기 시스템의 마스터 버스 스위치로 출력하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제20항에 있어서, 상기 복수의 코어는 2000개의 코어를 포함하는 것을 특징으로 하는 시스템.공개특허 10-2018-0132044-5-청구항 22 제21항에 있어서, 상기 시스템은 500MHz 클럭 속도로 초당 360조 명령을 처리하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제22항에 있어서, 상기 시스템은 데이터 입력을 위한 대기시간(latency)을 가지지만, 파이프 라이닝은 상기 시스템이 계산을 실행하여, 상기 레이턴시가 개시된 후에 각 코어의 각 클럭에서 결과를 출력하도록 상기 시스템이 구성되도록 오버헤드를 감소시키는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2018-7024664", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "알고리즘 매칭 파이프라인 컴파일러 및 재사용 가능한 알고리즘 파이프라인(형) 코어가 시스템을 구성한다. 재사 용 가능한 알고리즘 파이프라인 코어는 설정 데이터에 의해 결정된 바와 같은 복수의 동작들 중 임의의 동작을 프로그래밍하기 위한 설정 인터페이스를 갖는 프로세서, 룩업 테이블을 프로그래밍하기 위한 논리 결정 프로세서, 루프 카운터와 상수 레지스터 및 메모리 블록을 포함한다. 이것은 기능을 수행하는데 사용될 수 있다. 재구성 가능 프로그래머블 회로는 알고리즘 처리 중에 중앙 프로세서 또는 주변 장치 프로세서의 추가 개입없이 알고리즘을 완료하는데 필요한대로 하나의 코어에서 다른 코어 및/또는 10개의 컨트롤러 및/또는 인터럽트 발생 기로 데이터 및 결과를 라우팅한다."}
{"patent_id": "10-2018-7024664", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원은 \"재구성 가능한 알고리즘 파이프라인 코어 및 알고리즘 매칭 파이프라인 컴파일러를 갖는 프로세서\" 라는 명칭으로 2016년 1월 26일자로 출원된 미국 가출원 제62/287,265 호에 대한 우선권을 주장하며, 그 전체 내용은 본원에 참조로서 통합되어 있다. 본 출원의 분야는 컴퓨터 프로그래밍 및 마이크로 프로세서 설계 및 프로그래밍, 특히 범용 소프트웨어 명령어 의 재구성 가능한, 파이프라인 및 병렬 처리와 관련된다."}
{"patent_id": "10-2018-7024664", "section": "발명의_설명", "subsection": "배경기술", "item": 1, "content": "도 1a는 기존 프로세서의 컴파일러를 나타낸다.인텔 마이크로 프로세서 및 ARM 마이크로 프로세서와 같은 종래 의 프로세서는 잘 알려져 있다. 예를 들어, 종래의 프로세서의 개념적 예시가 도 1b에 도시되어 있다. 이들 프 로세서는 최신 컴퓨터들 및 디바이스들에 대한 중앙 처리 장치의 핵심으로 알고리즘을 처리하는데 사용된다. 종 래의 프로세서들의 문제점은 이러한 유형의 프로세서이 범용이며 특정 애플리케이션에 대해 그들의 성능을 향상 시킬 수 있는 임의의 실용적인 방법으로 재구성할 수 없다는 점이다. 또 다른 문제점은 프로그램 실행 제어가 프로세싱의 흐름을 수정하는 수학적 연산 및 논리적 결정과 같은 알고리즘 기능을 처리하는데 상당한 오버헤드 를 추가한다는 점이다. 보다 상위 레벨의 프로그래밍 언어가 종래의 프로세서를 프로그램하는데 사용될 수 있고, 컴파일러는 상위 레벨의 프로그래밍 언어의 명령을 특정 프로세서 아키텍처를 위한 기계 코드로 변환한다. 이 기계 코드는 프로세서가 액세스할 수 있는 메모리 위치에 제공되어, 시스템 아키텍처가 제공하는 BIOS 또는 기타 호출과 함께 상기 프로세서 하드웨어 작동에 대한 명령을 제공한다. 대부분의 경우 수학 및 논 리적 프로세싱 방향은, 수학적 알고리즘, 논리 결정, 데이터 처리 등을 해결하는 올바른 순서로 프로세서를 가 이드하는 등의 오버헤드를 관리하는 프로세서의 프로그램 실행 제어 부분에 솔루션을 반환하는 산술 논리 장치 (ALU)로 전달된다. 기계 코드 명령들은 데이터의 처리를 제어하기 위해 프로그램 저장 장치로부터 연속적으로 페치(fetch)된다. 이 오버 헤드는 기계 성능을 상당히 제한한다. 예를 들어, 다음은 특정 종래 프로세서에 대한 기계 코드를 생성하도록 컴파일될 수 있는 상위 레벨 프로그래밍 언어의 일 예인 \"C\"프로그래밍 언어로 수학 연산을 컴파일하는 종래의 컴파일러의 단계를 도시한다. 간단한 수 학 연산은 \"var il;\" \"var i2;\" 및 \"var s;\"를 할당하여 변수 il, i2 및 결과 s에 대한 데이터 저장 위치를 정 의한다. 그런 다음, 명령들(\"s = il + i2;\")을 사용하여 데이터 위치(i1 및 i2)에 할당된 변수를 합산할 수 있 다. 컴파일러는 (a) 먼저 데이터 저장 위치(예컨대, il, i2 및 s)를 할당하고 (b) 소스 코드를 기계 코드로 생 성한다. 종래의 프로세서는 코드가 저장된 메모리 위치로부터 상기 기계 코드의 전부 또는 일부를 검색할 것이다. 그런 다음, 컴퓨터 코드를 실행한다. 이 예의 경우, 중앙 처리 장치(CPU)는 메모리 위치에 데이터(i1)를 로 드하여 ALU로 보내고, 메모리 위치에 데이터(i2)를 로드한 다음 ALU로 보내고, 상기 ALU에 il 및 i2에 위치하는 데이터를 추가하도록 지시한다. 그런 다음만 ALU가 il 및 i2에 대한 데이터 위치에 있는 값을 추가한다. 이것은 CPU의 오버 헤드로 인한 설정과 함께 유용한 작업 단계이다. 그런 다음, CPU는 \"s\"에 대한 데이터 위치로부터 ALU 결과를 가져와서 그것을 입력 및 출력 컨트롤러로 전송할 수 있다. 이것은 상기 결과가 계산의 중간 단계가 아닌 경우 결과를 제시하는데 필요한 단계이다. 종래의 프로세서는 중앙 처리 장치 및 주변 장치의 다양한 아키 텍처에 대해 상위 레벨의 프로그래밍 언어를 컴파일할 수 있게 하여, 컴퓨터 프로그램개발에 소요되는 시간을 절약하고자 하는 바람에서 진화했다. 또한, CPU에 의해 실행되는 모든 프로세스는 시스템 환경에서 동작하는 다양한 프로그램 사이에서 ALU를 시분할함으로써 공통의 ALU를 공유할 수 있다. 특정 기능에 대한 계산을 신속하게 수행할 수 있는 하드웨어 전자 회로를 구축하는 ASIC들(Application Specific Integrated Circuit)이 알려져 있다. 이들은 특정 기능을 하드웨어에 하드 와이어링하여(hard wiring) 오버 헤드를 줄인다. 다수의 로직 게이트 및 랜덤 액세스 메모리(RAM) 블록을 갖는 몇몇 필드 프로그래머블 게이트 어레이(FPGA)가 공지되어 있다. 이들 FGPA는 복잡한 디지털 계산을 구현하는데 사용된다. 이러한 FPGA 설계는 매우 빠른 입/출 력 및 양방향 데이터 버스를 사용할 수 있지만, 설정 시간 및 대기 시간(hold time) 내에 유효 데이터의 정확한 타이밍을 검증하기가 어렵다. 플로어 플래닝(Floor planning)은 이러한 시간 제약을 충족시키기 위해 FPGA 내의 자원 할당을 가능하게 한다. FPGA는 ASIC 칩이 수행할 수 있는 모든 논리적 기능을 구현하는데 사용할 수 있다. 선적 후 기능의 일부를 재구성하고 ASIC 설계에 비해 비 반복적인 엔지니어링 비용을 낮추는 기능은 일반적으로 더 높은 단가를 고려한 경우에도 일부 애플리케이션에 이점을 제공한다. 그러나, FPGA 아키텍처의 보급은 좁은 틈새 제품으로 제한되어 왔다. 이러한 명령들에 응답하여 FPGA 그룹을 연 속적으로 재구성함으로써 프로그램 명령들의 시퀀스를 실행하기 위한 FPGA 가상 컴퓨터가 미국 특허 번호 5,684,980호에 특허가 있다. 도 2는 이 FGPA 아키텍처의 구조를 보여준다. 이 발행된 특허는 연속적인 알고리즘 이나 명령어를 수행하는 동안 연속적으로 구성을 변경하는 FPGA의 어레이를 포함한다. FPGA의 어레이의 구성은 각 계산 단계를 수행할 때 각 명령이 다운로드될 때까지 기다리지 않고 전체 알고리즘 또는 명령 세트가 수행되 도록 허용한다. FGPA의 발전 및 프로세서와의 통합은 \"런타임\"에 재 프로그래밍할 수 있는 가능성을 제공하지만, 실제로는 재구 성 가능한 컴퓨팅 또는 재구성 가능한 시스템이 현재 이러한 목적을 위해 이러한 아키텍처들을 프로그래밍하고 구성하는데 어려움이 있어 실용적인 애플리케이션에서 구현되는 것과는 거리가 멀다. 도 2는 미국 특허 제5,684,980호에 개시된 바와 같이, 임의의 외부 접속 태스크(task)로부터 필드 프로그래머블 게이트 어레이의 내부 리소스를 경감시키는 필드 프로그래머블 게이트 어레이 및 필드 프로그래머블 상호 접속 디바이스(FPIN) 또는 크로스바 스위치의 어레이를 포함하는 가상 컴퓨터의 블록도를 도시하며, 그 개시 및 도면 은 FPGA에 익숙한 숙련된 기술자의 지식을 개시할 목적으로 그의 전체 내용이 본 명세서에 포함된다. 도 2는 호스트 컴퓨터의 성능을 향상 시키거나 연속적인 알고리즘을 수행하기 위한 가상 컴퓨터 프로세서 내에 서 코 프로세서(co-processor)로서 배열되고 사용되는 필드 프로그래머블 게이트 어레이 및 필드 프로그래머블 상호 접속 장치의 어레이를 도시한다. 상기 연속적인 알고리즘은 통상적으로 종래의 마이크로 프로세서에서 실 행될 일련의 종래의 명령들에 대응하도록 프로그래밍되어야 한다. 그런 다음, FPGA/FPIN 어레이에 의해 연속적 인 알고리즘의 특정한 계산 작업을 수행하는 속도는 종래의 마이크로 프로세서에 의해 수행되는 대응하는 명령 의 속도보다 훨씬 작다. 도 2의 가상 컴퓨터에는 FPGA/FPIN 어레이의 재구성을 관리하는 재구성 가능 제어 섹션 (control section)이 있어야 한다. 구성 비트 파일은 해당 용도로 설계된 소프트웨어 패키지를 사용하여 상기 재구성 가능 제어 섹션에 대해 생성되어야 한다. 그런 다음, 상기 구성 비트 파일을 가상 컴퓨터의 대응하는 FPGA/FPIN 어레이로 전송해야 한다. 도 2는 어레이와 듀얼 포트 랜덤 액세스 메모리(RAM)가 핀들에 의해 상기 재구성 가능 제어 섹션, 버스 인터페이스 및 컴퓨터 메인 메모리에 연결되는 방법을 보여준다. 상기 버스 인터 페이스는 시스템 버스에 연결된다. 미국 특허 제5,684,980호는 상기 핀들이 클럭 핀 및 상기 재구성 가능 제어 섹션을 FPGA/FPIN 어레이들에 연결 하는 핀을 제공하는 방법을 도시하고, 재구성 가능 제어 섹션의 예를 도시한다. 미국 특허 제4,291,372 호에는 주변 장치와의 데이터 전송에 대한 특정 요구 사항을 처리하는 외부 애플리케이 션 의존 논리 모듈과 함께 작동하는 특수한 (specialized) 명령 포맷을 갖는 마이크로 프로세서 시스템이 개시 되어 있다. 마이크로 프로세서는 특수한 명령 포맷을 갖는 프로그램 메모리를 제공한다. 명령 워드 포맷은 메모 리 어드레스의 소스로서 프로그램 카운터 또는 메모리 기준 레지스터를 선택하기 위한 단일 비트 필드, 수행될 데이터 전송의 경로를 정의하는 기능 필드 및 소스 및 목적지 위치를 어드레싱하기 위한 소스 및 목적지 필드를 제공한다. 이전에는, 주변 컨트롤러 장치(peripheral controller units)는 특정 요구 사항을 처리하기 위해 기 본 모듈에 프로세서 및 제어 회로가 있는 시스템에 부담을 주었다. DSP(Digital Signal Processing) 장치 또는 DSP 프로세서의 어레이는 모니터 및 TV와 같은 출력 화면에서 이미 지를 생성하기 위한 픽셀 처리와 같은 일부 그래픽 집약적인 작업의 성능을 최적화하는 병렬 배열로 하드와이어 (hardwired)될 수 있다. 이는 맞춤형이며 디지털 신호 프로세서가 작업을 수행하기 위해 만든 그래픽 가속 환경에 특정한 BIOS를 포함한다. 매트릭스 버스 스위칭(MBS)이 공지되어 있다. 예를 들어, ARM DUI 0534B, 1D072312로 언급된, 저작권 2010, 2012의 사용자 가이드 \"AMBA® 4 AXI4 ™, AXI4-Lite ™ 및 AXI4-Stream ™ 프로토콜 어설션, 개정판: rOpl, 사용 가이드\"는, 본 기술 분야에서 통상의 지식을 가진 자에 의해 고속이고 구현 가능한 매트릭스 버스 스위칭 을 위한 시스템을 개시(teach)한다. 상기 사용자 가이드는 디자인이 관련 AMBA 4 프로토콜을 준수하는지 확인하 고자 하는 시스템 설계자, 시스템 통합자 및 검증 엔지니어들을 대상으로 작성되었다. 이것은 예를 들어, AXI4, AXI4-Lite 또는 AXI4-Stream일 수 있다. 모든 상표는 EU 및 기타 국가에서 ARM의 등록 상표이다. 제외된 경우, 이 참고 문헌은 그 전체가 참고 문헌으로 인용된다. MBS는 데이터 입출력을 위한 고속 버스이며 이 참고 문헌은 시스템 엔지니어가 프로세서 시스템 아키텍처에서 MBS의 예를 통합하는 방법과 하드웨어를 개시한다. 이 모든 것은 당해 기술 분야에서 공지되어 있지만, 선행 기술의 예는 광범위한 알고리즘을 처리할 수 있는 유 연성을 유지하고 프로세싱 시스템을 위한 소프트웨어 개발을 위해 \"C\"와 같은 표준보다 높은 상위 레벨의 프로 그래밍 언어를 사용하면서 종래의 프로세싱 시스템에 의해 생성된 거의 모든 오버 헤드를 제거한다. 칩상의 파이프라인된 병렬 프로세서는 프로세싱 유닛 및 프리 컴파일러일 수 있는 알고리즘 매칭 파이프라인 컴 파일러에 의해 프로그램된 재구성 가능한 필드 프로그래머블 게이트의 어레이를 포함하여, 상기 알고리즘 매칭 파이프라인 컴파일러는 상기 프로세싱 유닛에 의한 처리를 위해 병렬 처리 없이 표준 프로세서상에서 동작하도 록 설계된 소스 코드를 프리 컴파일하고, 상기 프로세싱 유닛 및 알고리즘 매칭 파이프라인 컴파일러(AMPC 또는 ASML로 지칭된)는 파이프라인 병렬 프로세서들로서 동작하도록 상기 필드 프로그래머블 게이트들을 구성한다. 예를 들어, 상기 프로세서는 재사용 가능한 알고리즘 파이프라인 코어(reusabe algorithmic pipelined core : RAPC)로 지칭될 수 있다. 상기 병렬 프로세서들은 연산 처리 유닛을 제어하기 위한 오버 헤드와 같은 상기 프로 세싱 유닛으로부터 임의의 추가 오버 헤드없이 작업(task)을 완료하도록 구성된다. 일 예에서, 재사용 가능 알고리즘 파이프라인 프로세서는 \"C\", \"C++\"등과 같은 표준 고급(higher level) 소프트 웨어 언어를 사용하여 병렬로 알고리즘을 처리하도록 구성된 컴퓨터 풀(pool)을 포함한다. 예를 들어, 상기 컴 퓨터 풀은 AMPC의 출력에 기초하여, 사용 가능한 RAPC 리소스들로 설정되는 특정 계산에 필요한 다른 알고리즘 을 실행하도록 재프로그래밍된다. 예를 들어, 재사용 가능한 알고리즘 파이프라인 코어(RAPC)는 지능형 버스 제어기 또는 논리 결정 프로세서 (LDP), 디지털 신호 프로세서(DSP) 및 매트릭스 버스 스위치의 3개의 모듈로 구성될 수 있다. 논리 결정 프로세 서(LDP)는 필요에 따라 재 프로그래밍 가능하며 마스터 버스 스위치(MBS)를 제어하는 재구성 가능한 논리 기능 을 포함한다. DSP는 수학 연산을 수행하기 위한 재구성 가능한 수학 프로세서를 포함한다. 일 예에서, RAPC에 의해 처리된 모든 수학 연산은 DSP에 의해 처리된다. 일 예에서, RAPC에 의해 처리된 모든 논리 기능은 LDP에 의해 처리된다. 매트릭스 버스 라우터 또는 스위치(MBR 또는 MBS)는 알고리즘 처리 중에 중앙 프로세서 또는 주 변 장치 프로세서로부터의 추가 개입 없이, 필요에 따라 하나의 RAPC로부터 다른 RAPC로 및 입력/출력 컨트롤러 로부터/로 및/또는 인터럽트 발생기로 데이터와 결과를 라우팅하여 알고리즘을 완료하는 재구성 가능한 프로그 램 가능 회로로서 정의된다. 따라서, 오버헤드는, 연산 처리 장치의 안팎으로 데이터 및 결과를 전달하기 위해 중앙 프로세서 또는 주변 장치 프로세서의 개입을 필요로 하는 정적인 비-구성 가능 하드웨어에 비해 파이프라 이닝에 의해 크게 감소된다. 일 예에서, LDP는 논리 결정 및 반복 루프를 처리하고, 결과 메모리는 학습 알고리 즘에 대해 LDP에 의해 제공된다. 일 예에서, RAPC에 의해 처리된 모든 수학 연산은 DSP에 의해 처리되고, 모든 논리 함수는 LDP에 의해 처리된다. 일 예에서, 복수의 RAPC는 코들의 풀(pool)로서 구성되고, 상기 코어들의 풀 각각은 하드웨어에 대한 어떠한 변경없이 프로그래밍만으로 재구성 가능하다. 예를 들어, 모든 RAPC는 병렬로 알고리즘을 처리하도록 구 성될 수 있다. 일 예에서, LDP는 메모리 블록들을 룩업 테이블(LUT)로서 사용하여 상수 또는 학습 값을 등록한 다. n-비트 LUT는 LDP에 의해 설정된 LUT를 사용하여 모든 n-입력 부울 논리 함수를 진리표로서 인코딩하는데 사용될 수 있다. 일 예에서, 알고리즘 매칭 파이프라인 컴파일러(AMPC)는 \"C\", \"C++\", 파스칼, 베이직 등과 같은 고급(higher level) 컴파일 가능한 소프트웨어 언어로부터 기계 코드를 생성한다. 종래의 비-재구성 가능 및 비-파이프라인 범용 컴퓨터 프로세서에 대해 작성된 표준 소스 코드는, 하나 이상의 RAPC를 구성하기 위한 기계 코드를 생성하 기 위해 AMPC에 의해 처리될 수 있다. 예를 들어, AMPC는 종래의 ARM 프로세서 또는 종래의 인텔 프로세서에 대한 표준 기존 코드(preexisting code)로부터 기계 코드를 생성하며, 이 AMPC 프리 컴파일러에 의해 생성된 기계 코드는 ARM 프로세서 또는 인텔 프로세서를 사용하여 RAPC를 구성한다. 따라서, 새로운 컴퓨터 시스템은 기존의 ARM 프로세서, 인텔 프로세서, AMD 프로세서 등과 같은 종래의 프로세서 및 복수의 RAPC를 포함하고, 각 RAPC는 예를 들어 DSP, LDM 및 MBS를 포함한다. 그러나, 기존 코-프로세서 또는 가속기와 달리, RAPC는 단지 주변 코프 로세서가 아니다. 대신, RAPC는 프리 컴파일러 또는 AMPC가 RAPC가 자신의 작업을 수행하도록 구성한 후 종래의 프로세서의 추가 개입 없이도 복잡한 수학 및 논리 알고리즘을 독립적으로 해결하도록 재구성된다. 값들은 상기 구성된 RAPC로의 입력이고 솔루션이 MBS로 출력된다. 일 예에서, 복수의 RAPC는 재구성 가능한 ASIC와 같은 단 일 칩 상에 배치된다. 재구성 가능한 ASIC은, 각각의 RAPC가 ARM 프로세서, AMD 프로세서 및 인텔 프로세서 등 과 같은 AMPC 및 범용의 기존 프로세서 아키텍처에 의해 특정 연산을 위해 재프로그래밍될 수 있도록 RAPC를 포 함하도록 설계된 칩을 의미한다. 이러한 방식으로, 단일 재구성 가능 ASIC은 2000 RAPC를 포함할 수 있으며 500 MHz 클럭 속도로 초당 360조 명령을 수행할 수 있다. 따라서, 2000개의 RAPC로 구성된 단일 재구성 가능 ASIC은 오늘날 어떠한 종래의 일반 범용 프로세서보다 100배 이상 빠르게 작동할 수 있다. 모든 RAPC는 데이터가 이용 가능한 동안에 파이프라인 구성으로 병렬로 작동할 수 있다. 단일 RAPC는 표준 프로세서보다 100 배 이상 빠르 게 명령을 실행할 수 있다. 500MHz의 클럭 속도로 동작하는 20개의 RAPC를 포함하는 재구성 가능 ASIC은 초당 300억개의 명령을 실행할 수 있다. 단일 칩은 종래의 크기의 ASIC에 최대 2000개의 RAPC를 포함할 수 있다. 따 라서, 2000개의 RAPC를 포함하는 종래의 크기의 ASIC은 특수한 프로그래밍 언어에 의존하지 않고도 종래의 처리 시스템보다 20만 배 더 빠르게 명령을 실행할 수 있다. 대신에, 기존의 프로그램은 복수의 RAPC를 포함하는 재 구성 가능 ASIC으로 동작하도록 이식 (port)될 수 있고, 기존의 고급 프로그래밍을 실질적으로 재작성하지 않고 병렬로 명령들의 파이프라인 실행으로부터 이익을 얻을 수 있다. 일 예에서, AMPC는 복수의 RAPC를 포함하는 재 구성 가능 ASIC 상에 내장된 ARM 범용 프로세서 아키텍처에 대한 기존 코드를 프리 컴파일한다. 이 새로운 프로 세서 아키텍처(ICAT)는 ARM 프로세서 아키텍처와 복수의 RAPC를 하나의 칩에 결합함으로써 예상치 못한 놀라운 성능을 제공한다. ICAT 칩상에 내장 ARM 프로세서는 \"C\"와 같은 상위 레벨 프로그래밍 언어로 작성된 기존 프로 그램으로부터 AMPC에 의해 생성된 기계 코드 명령을 실행하며, 이는 ICAT 칩상의 복수의 RAPC를 구성하여 초당 명령들의 놀랍도록 빠른 실행을 수행하도록 구성한다. ARM 프로세서는 또한 지능형 모니터링, 진단 및 ICAT 칩 외부의 주변 장치와의 통신을 제어한다. 따라서, ICAT 칩은 외부 세계에 수학 코프로세서를 필요로하지 않는 매 우 빠른 ARM 프로세서로 인식된다. 대안적인 예에서, ICAT 칩은 AMD 프로세서를 내장할 수 있으며 외부 세계에 AMD 프로세서로 인식될 수 있다. 또 다른 예에서, ICAT 칩은 인텔 프로세서를 내장할 수 있으며, 외부 세계에 인텔 프로세서로 인식될 수 있다. 놀랍게도, ICAT 칩이 외부 세계에 표준의 비-재구성 가능 및 비-파이프라인 프로세서로 인식되지만 표준 프로세 서와 동등한 속도로 명령들을 실행할 수 있는 경우에도, ICAT 칩은 표준 프로세서용으로 작성된 프로그램을 다 시 작성하지 않고도 전 세계의 표준 프로세서보다 100 내지 20만 배 빠른 예기치 않은 속도로 명령을 실행한다. FPGA상에서 기능하도록 코드를 재작성하는 번거로움에 대한 이러한 단순화는 일반 프로그래머가 FPGA에 액세스 할 수 있게 만든다. 하나의 예에서, AMPC는 ICAT 칩에 대한 런타임 코드를 생성하지 않는다. 대신, 프로그램을 프리 컴파일하여 RAPC에 가장 적합한 명령을 분리한다. 그런 다음, AMPC는 ICAT 칩(또는 일 예로, 병렬로 동작 하는 다수의 ICAT 칩을 사용하여)상의 복수의 RAPC 각각을 설정하기 위한 코드를 생성하고, 그런 다음 RAPC는 파이프라인 방식으로 병렬로 동작한다. 대안적으로, RAPC는 ICAT에 의해 수신된 명령들 또는 이전에 ICAT 칩에 의해 수신된 이력 명령들에 기초하여 실시간으로 재구성될 수 있다. 따라서, ICAT 칩은 상기 ICAT 칩이 일관되 게 유사한 목적으로 사용된다면 시간이 지남에 따라 더 빠른 속도로 동작하도록 학습할 수 있다. 이 것은 RAPC 가 실시간으로 구성되어 새로운 논리 및 수학 방정식을 풀도록 구성하는 경우, 예를 들어, 선입 선출 또는 마지 막으로 사용된 마지막 재구성 기반에서 이전 논리적 및 수학적 구성을 그대로 유지하면서 자연스럽게 발생한다. 특정 용도로 재구성된 RAPC 세트는 자주 사용되는 경우, 마지막으로 사용된 마지막 재구성 알고리즘이 채택된 경우 RAPC를 필요로 하는 새로운 알고리즘에 사용할 수 있는 다른 RAPC가 없을 때까지 다른 용도로 재구성되지 않는다. 이런 식으로, 가장 많이 사용되는 알고리즘은 구성할 필요가 없지만 이전의 사용에 의해 이미 사전 구 성될 것이다. RAPC는 중앙 처리 장치에 의해 구성될 때 오버 헤드없이 동작하며 상기 RAPC가 구성한 수학, 논리 및 반복 명령 이 완료될 때까지 명령을 실행한다. 일 예에서, ICAT 칩은 설정 레지스터를 포함하고, AMPC는 특정 명령을 완료하기 위해 RAPC를 구성하는 ICAT 칩 의 설정 레지스터를 설정하기 위한 명령을 생성한다. RAPC는 초기화될 때 중앙 처리 장치에 의한 추가 감시 (oversight)없이 지속적으로 작동한다. 일 예에서, AMPC는 Verilog 또는 Vivado 하드웨어 컴파일러와 같은 하드웨어 컴파일러로부터 RAPC 하드웨어 데이터를 수신한다. 하드웨어 파일은 하드웨어 컴파일러에 의해 생성될 수 있으며, AMPC가 ICAT 칩의 설정 레지스터(또는 일 예에서, 복수의 ICAT 칩의 설정 레지스터)에 대한 구성 데이 터를 작성하는 코드를 생성하는데 사용될 수 있다. 일 예로, AMPC는 \"C\"와 같은 상위 레벨 프로그래밍 언어로 표준 프로세싱 아키텍처용으로 작성된 프로그램으로 부터 ICAT 칩의 설정 레지스터에 대한 구성 데이터를 추출한다. 예를 들어, AMPC는 오버 헤드 명령을 무시하고, 1) 산술 명령 및 데이터; 2) 논리 결정 및 데이터; 3) 분기 또는 호출/복귀 명령 및 목적지; 4) 반복 루프, 결 정 및 데이터; 5) DSP 설정 루틴 및 데이터; 6) 루프 및 분기에 대한 코드 진입점 레이블(code entry point labels)에 대한 프로그램으로부터 ICAT 칩의 설정 레지스터에 대한 코드를 생성한다. 예를 들어, AMPC는 이들 명령을 사용하여, 수학 알고리즘 완료를 위한 DSP, LDP의 록업 테이블에 대한 논리 결정 및 데이터를 위한 LDP 및 ICAT 하드웨어의 다양한 처리 알고리즘 및 할당된 주소의 진입점에 대한 분기, 호출 및 복귀 대상 (destination) 레이블 패핑을 위한 MBS를 구성하는 ICAT의 설정 레지스터를 구성한다. 예를 들어, RAPC 하드웨 어 테이블은 각 RAPC에 대해 구축되며, DSP, LDP 및 MBS 구성 테이블을 포함한다. 예를 들어, DSP, LDP 및 MBS 는 RAPC에서 자주 사용되는 것으로 구성되지만 DSP 또는 LDP가 필요하지 않은 경우, 상기 RAPC는 AMPC 및 ICAT 아키텍처에 의한 이러한 공통 구조를 생략하도록 재구성될 수 있다. 따라서, 일부 RAPC에는 DSP, LDP 및 MBS가 있지만 다른 RAPC에는 ICAT 프로세서에서 실행될 코드에 특정된 다른 구조가 있을 수 있다. 일 예에서, ICAT 아키텍처 및 AMPC는 AMPC에 의해 재구성될 수 있는 하드웨어에 대해 서로 의존적이다. 예를 들 어, AMPC는 대상(destination) RAPC가 근처에 있거나 데이터가 DSP에서 LDP로 또는 그 반대로 라우팅되는 경우, 예를 들어 오버 헤드없이 명령의 실행에 즉시 결과 또는 데이터를 사용할 수 있게 하는 경우, 결과 또는 데이터 를 상기 대상에 직접 연결함으로써 ICAT 아키텍처 내에서 대상의 분기 또는 호출을 구현할 수 있다. 대안적으로, AMPC는 MBS를 사용하여 대상의 분기 또는 호출을 구현할 수 있으며, 결과 및 데이터는 고속 스트리 밍 인터페이스를 통해 다른 RAPC 또는 다른 목적지일 수 있는 대상으로 전송되어, 상기 데이터가 대상으로의 고 속 스트리밍 인터페이스를 통해 명령의 추가 실행을 위해 이용될 수 있게 한다. 하나의 예에서, AMPC는 상위 레벨 프로그래밍 언어로 작성된 코드를 컴파일하는 동안 AMPC에 의해 할당된 RAPC 리소들을 인식한다. 따라서, ICAT 아키텍처는 복수의 RAPC에 의해 실행되는 명령들 사이의 상호 접속 길이를 최 소화하는 것과 같은, RAPC 리소스들의 사용을 최적화하도록 AMPC에 의해 구성될 수 있다. 이러한 최적화는 반복 접근법 또는 시행착오(trial and error) 접근법에 의해 완료될 수 있다. 일 예에서, AMPC는 분기에 대한 MBS의 사용을 최소화하거나 공통 명령 세트에 대한 대상의 분기 또는 호출을 최소화하는 것과 같은, 수학적 알고리즘, 논리 알고리즘 또는 수학적 및 논리 알고리즘의 조합 여부에 관계없이 특정 명령의 사용의 이력 패턴에 기초하 여 최적화를 향상시키는 학습 알고리즘을 포함한다. MBS 구현 예는 백그라운드에서 ARM MBS 예제를 참조하십시 오. 일 예에서, RAPC는 RAPC를 구성하기 위한 종래의 프로세서 및 종래의 고급 소스 코드를 컴파일하여 종래의 프로 세서가 RAPC를 설정하기 위한 명령으로 컴파일하는 AMPC와 함께 칩에 통합된다. RAPC는 DSP, LDP 및 MBS를 포함 한다. 이 예에서, 각 DSP는 곱셈, 나눗셈, 덧셈, 뺄셈 및 다른 수학적 기능과 같은 정수 및 부동 소수점 연산과 같은 복수의 연산 중 임의의 것을 프로그래밍하기 위한 설정 인터페이스를 갖는다. DSP는 설정 데이터에 의해 결정되는 수학 함수의 다양한 조합으로 연접되거나 연산될 수 있는 피연산자 데이터에 대한 입력을 가질 수 있 다. 이 예에서 각 DSP는 상태 데이터와 함께 결과 데이터로 출력되는 48 비트 누산기를 가진다. 상태 데이터는 예를 들어, 수행하다(carry out), 동등한(equal), 보다 큰(greater) 및 미만(less than)을 포함한다. 이 예에 서 각 LDP는 룩업 테이블, 루프 카운터 및 상수 레지스터를 프로그래밍하기 위한 설정 인터페이스를 갖는다. 각 LDP는 반복 알고리즘이 완료될 때를 검출하는 \"루프 카운터\"를 갖는다. 각 LDP는 룩업 테이블로의 입력을 위해 상수 데이터를 저장할 수 있는 레지스터를 가지고 있다. 각 LDP에는 기능을 수행하는데 사용할 수 있는 메모리 블록이 있다. 룩업 테이블 기능은 루프 카운터를 사용하여 구현되고 순차적으로 액세스될 수 있는 룩업 데이블, 제어 목적을 위해 DSP 상태, 상수 레지스터 또는 DSP 결과 데이터에 의해 구현되고 액세스될 수 있는 룩업 테이 블, 및 예를 들어 제어 목적을 위해 구현될 수 있고 기타 논리 신호를 출력할 수 있는 논리 룩업 테이블을 포함 할 수 있다. LDP는 결과 데이터를 입력으로부터 출력으로 전달할 수 있다. LDP는 예를 들어 그의 출력에서 결과 데이터에 대한 하나의 파이프라인 레지스터를 가질 수 있다. 대안으로, LDP는 그 출력에서 결과 데이터에 대한 동기 클리어 인에이블(synchronous clear enables)을 갖는 2개의 파이프라인 레지스터를 가질 수 있다. 예를 들 어, 상기 칩은 DSP, LDP 및 MBS를 각각 포함하는 복수의 RAPC를 포함하는 ICAT 칩일 수 있으며, 각각은 AMPC에 의해 종래의 프로세서에 제공된 코드에 의해 설정된다. 일 예에서, AMPC는 복수의 RAPC의 수 및 복수의 RAPC의 위치를 정의하는 입력 아키텍처를 갖는 컴파일러를 포함 한다. AMPC는 고급 소스 코드를 필터링하여, 복수의 RAPC 중 하나 이상의 구성에 의해 최적화될 수 있는 수학적 및 논리적 알고리즘을 식별한다. 예를 들어, 비디오 처리, 수학적 또는 논리적 알고리즘이 식별되면, AMPC는 비 디오 처리, 수학적 또는 논리 알고리즘을 수행하도록 하나 이상의 RAPC의 DSP, LDP 및 MBS를 설정한다. 예를 들 어, AMPC는 ARM 프로세서와 같은 종래의 프로세서의 작동을 위한 \"C\"언어 소스 코드로부터 기계 코드를 생성하 고, ARM 프로세서는 프로세서로의 데이터 입력을 처리하고 프로세서로부터 데이터를 출력하는데 사용될 각각의 RAPC의 DSP, LDP 및 MBS 부분을 설정한다. 상기 프로세서 외부의 시스템들에 대해, ICAT 프로세서는 비정상적으로 빠른 종래의 프로세서인 것처럼 보일 것 이다. 프로세서 내에서, RAPC의 DSP, LDP 및 MBS는 종래의 단일 코어 프로세서보다 수십 배, 수백 배, 심지어 수천 배 빠른 속도로데이터를 처리할 것이다. 각 RPAC에 대해, DSP는 제1 클럭에서 연산을 수행하고, LDP는 결 과를 테스트하고 제2 클럭에서 제어 결정 및 결과 데이터를 출력할 것이며, MBS는 제3클럭에서 상기 제어 데이 터에 기초하여 두 대상들 중 하나로 결과 데이터를 라우팅한다. 따라서, 각 RAPC는 DSP에서 MBS까지 3 클럭의 대기 시간을 갖는다. 스트리밍 데이터의 경우 일단 시작되면, MBS는 대기 시간 이후의 각 후속 클럭에서 데이터 를 출력할 수 있다. 하나의 예에서, 재구성 가능 프로세서를 구성하기 위한 시스템은, 비-재구성 가능 프로세서, 복수의 재구성 가 능한 코어 및 비-재구성 가능 프로세서에 대한 상위 레벨 프로그래밍 언어로 작성된 코드를 수용할 수 있는 알 고리즘 매칭 파이프라인 컴파일러를 포함하며, 상기 컴파일러는 상기 복수의 재구성 가능 코어 중 하나 이상에 서 이용 가능한 파이프라이닝으로부터 이익을 얻을 수 있는 상위 레벨 프로그래밍 언어로 작성된 코드를 식별하 여, 상기 복수의 비-재구성 가능 프로세서 중 하나 이상을 설정하기 위해 상기 비-재구성 가능 프로세서에 대한 코드를 출력한다. 일 예시에서, 프로세서는 비-재구성 가능 프로세서 코어 및 상기 비-재구성 가능 프로세서 코어에 결합된 복수 의 재사용 가능한 알고리즘 파이프라인 코어를 포함하여, 상기 비-재구성 가능 프로세서 코어가 알고리즘 매칭 파이프라인 컴파일러(Algorithmic Matching Pipelined Compiler)로부터 수신된 명령들의 결과로서 상기 복수의 재사용 가능한 알고리즘 파이프라인 코어들 각각을 구성 및 재구성할 수 있다. 예를 들어, 상기 프로세서는 단 일 칩에 포함된다. 일 예에서, 각각의 재사용 가능한 알고리즘 파이프라인 코어는 DSP, LDP 및 MBS를 포함하고, 상기 DSP는 LDP로 파이프라인되고, 상기 LDP는 MBS로 파이프라인되어, 비-재구성 가능 프로세서는 각 재사용 가 능한 알고리즘 파이프라인 코어내에서 발생하는 어떠한 처리도 제어하지 않는다. 정의. 알고리즘 매칭 파이프라인 컴파일러 또는 AMPC는 종래의 비-재구성 가능 프로세서에 대한 상위 레벨 프로 그래밍 언어로 작성된 코드를 수용할 수 있는 컴파일러이며, 상기 AMPC는 RAPC 또는 필드 프로그래머블 게이트 어레이와 같은 재구성 가능 코어 또는 프로세서상에서 이용 가능한 파이프라이닝으로부터 이익을 얻을 수 있는 상위 레벨 프로그래밍 언어로 작성된 코드를 식별하여, 상기 재구성 가능 코어 또는 프로세서를 사용하기 위한 명령들을 제공하기 전에, 상기 재구성 가능 코어 또는 프로세서를 구성하도록 상기 비-재구성 가능프로세서에 명령하는 비-재구성 가능 포로세서에 대한 코드를 출력한다. 재사용 가능(또는 재구성 가능) 알고리즘 파이프라 인 코어(또는 컴퓨터) 또는 RAPC는, 설정 데이터에 의해 결정된 수학 함수의 다양한 조합으로 연접되거나 연산 될 수 있는 피연산자 데이터에 대한 4개의 입력 및 상태 데이터와 함께 결과 데이터로서 출력되는 48비트 누산 기를 갖는, 정수 및 부동 소수점 연산과 같은 복수의 연산 중 임의의 연산을 프로그래밍하기 위한 설정 인터페 이스를 포함하는 DSP; 룩업 테이블을 프로그래밍하기 위한 설정 인터페이스, 루프 카운터 및 상수 레지스터 및 기능들을 수행하는데 사용될 수 있는 메모리 블록을 갖는 LDP; 및 MBS로서 정의된다. MBS는 알고리즘 처리 중에 중앙 프로세서 또는 주변 프로세서로부터의 추가 개입 없이, 필요에 따라 하나의 RAPC로부터 다른 RAPC로 및 입 력/출력 컨트롤러로부터/로 및/또는 인터럽트 발생기로 데이터와 결과를 라우팅하여 알고리즘을 완료하는 재구 성 가능한 프로그램 가능 회로로서 정의된다."}
{"patent_id": "10-2018-7024664", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "예를 들어, ICAT 아키텍처는 임의의 표준 마이크로 프로세서 유닛 아키텍처를 모방한다. 이 아키텍처는 동일한 클럭 속도를 가진 단일 표준 마이크로 프로세서 아키텍처와 1:1로 비교될 때 MIPS에서 100:1 이점을 얻기 위한 하나 이상의 FPGA(Field Programmable Gate Array)와 같이 제조 후 고객이나 설계자가 구성하도록 설계된 집적 회로에서 파이프라이닝(pipelining) 및 더욱 풍부한 게이트 밀도를 이용한다. FPGA는 프로그래머블 논리 블록들 의 어레이 및 다양한 구성에서 상호 연결(inter-wired)될 수 있는 많은 논리 게이트들처럼 블록들을 \"함께 배선 (wired together)\"할 수 있는 재구성 가능한 상호연결의 계층(hierarchy)을 포함한다. 논리 블록들은 복잡한 조 합 함수 또는 AND 및 XOR과 같은 단순한 논리 게이트를 수행하도록 구성될 수 있다. 대부분의 FPGA에서, 논리 블록들은 또한 단순한 플립-플롭이거나 완전한 메모리 블록일 수 있는 메모리 요소를 포함한다. 매우 큰 성능 향상으로 인해 프로세서는 예를 들어, 머신 비젼, 비디오 프로세싱, 오디오 프로세싱, 로봇 제어 시스템, 다-축 제어 시스템, 이동 통신, 가상 현실, 인공 지능, 라이브스트리밍(livestreaming), 생체 인식, 사 물 인터넷, 수터컴퓨팅, 양자 컴퓨팅, 항공 우주 제어 시스템, 복잡한 시스템의 시뮬레이션 및 모델링 및 신호 처리 애플리케이션 등과 같은 데이터 집약적인 애플리케이션에 사용될 수 있다. 일 예에서, 알고리즘의 계산 집약적인 처리를 위해 더 적은 전력이 사용된다. 예를 들어, ICAT 아키텍처는 표준 마이크로-프로세싱 유닛상에 구현된 동일한 계산, 더 바람직하게는 1000:1의 이점으로 열 및 전력 소비를 줄임 으로써 에너지 사용량을 100 대 1로 감소시킨다. 일 예에서, ICAT는 애플리케이션에 필요한 만큼 많은 병렬 프로세서의 구성으로 실행될 수 있으므로 표준 마이 크로 프로세서에 비해 성능을 더욱 향상시킬 수 있다. 예를 들어, 복수의 프로세서 아키텍처들이 동시에 실행될 수 있다. 예를 들어 레거시 코드(legacy code)는 레거시 코드와 호환되는 가상 머신에서 실행될 수 있지만 새로 운 가상 머신은 새로운 아키텍처를 위해 특별히 작성된 코드를 실행한다. 하나의 예에서, 이는 레거시 코드를 새로운 시스템 아키텍처에 적용하는데 필요한 대규모 회귀 검증(regression testing)의 필요성을 줄여 준다. 하나의 애플리케이션에서, ICAT 아키텍처의 속도 및 확장성은 코드 및/또는 하드웨어가 한계에 처한 고객들의 원시 속도(raw speed) 및 확장 가능성에 필요한 대량의 데이터를 처리할 수 없는 레거시 시스템에 적용된다. 일 예시에서, 재구성은 전원을 켤 때 또는 그 전에 컴파일되므로, 최종 제품 성능에 거의 영향을 미치지 않고 계획(planning)을 크게 단순화한다. 예를 들어, FPGA는 이 아키텍처의 호스트 하드웨어이다. 기존 코드를 대폭 수정하지 않고도 MIPS(수백만 명령들/초)를 쉽게 추가할 수 있다. 기존 코드는 상기 기존 코드의 재 컴파일을 제외하고는 거의 수정되지 않고 실행될 수 있다. 예를 들어, 많은 수의 공통 입력을 병렬 처리해야 하는 알고리 즘은 이 ICAT 아키텍처를 위한 이상적인 후보이다. 일 예에서, 오래된 프로세서와 새로운 프로세서가 병렬로 동작한다. 기존 코드는 변경 사항이 발생하지 않았는 지 확인하기 위한 최소한의 회귀 검증으로 재컴파일되어 거의 변경되지 않는다. 타이밍이 아키텍처의 동작에 영 향을 주는 경우 및 하드웨어 주변 장치가 변경되는 부분은 예외이다. 예를 들어, ICAT 아키텍처는 원시 연산 속 도를 높이기 위해 사용될 수 있으며, 코드의 가속은 필요할 때 하드웨어를 변환함으로써 구현될 수 있다. 일 예에서, ICAT 아키텍처는 잠재적인 코드 비 호환성 문제를 포착하는 프론트 엔드 프리-컴파일러를 포함한다. 이 프런트 엔드 프리-컴파일러는 이러한 잠재적인 코드 비 호환성 문제를 자동으로 해결한다. 예를 들어, ICAT 아키텍처는 여러 개발자에게 친숙한 다양한 프로세서 아키텍처를 에뮬레이트할 수 있다. 예를 들어, ICAT 아키 텍처는 둘 이상의 프로세서를 에뮬레이트할 수 있어, 프로젝트가 복수의 개발자가 선호하는 프로세서에 대해 코 딩되고 복수의 상이한 가상 프로세서상에서 동시에 코드를 실행할 수 있게 한다. 일 예에서, 복수의 상이한 프로세서는 멀티 프로세싱 환경에서 상이한 코드 세트를 실행하고, 프로그램 개발자는 코드와 호환 가능한 복수의 도메인 중 하나에 대한 코드를 컴파일한다. 일 예에서, 프리-컴파일러는 다양한 처리 알고리즘에 필요한 하드웨어 구성 코드를 생성하는 알고리즘 매칭 파 이프라인(형) 컴파일러(algorithmic matching pipelined compiler)이다. ICAT 아키텍처를 구성하기 위한 펌웨 어는 복수의 처리 작업을 위한 논리적 및 수학적 방정식으로부터 생성될 수 있다. 예를 들어, 복수의 프로세서 는 저 성능 및 고성능 작업의 혼합을 실행하기 위해 매트릭스 어레이로 구성될 수 있다. ICAT 아키텍처는 상위 레벨 언어를 사용하여 개발된 프로세싱 코드를 포함하며, 상기 ICAT 아키텍처는 하나의 특정 멀티프로세싱 환경에만 적용 가능한 기계어로 프로그래밍함으로써 얻을 수 있는 속도 이점을 능가하는 원 시 속도 이점을 제공하므로 개발 프로젝트를 완료하는데 소요되는 시간이 크게 단축된다. ICAT 아키텍처에는 레거시 코드에서 하드웨어 특정 명령을 확인하는 컴파일러 또는 프리 컴파일러가 포함되어 있으며, C 또는 C++와 같은 상위 레벨 프로그래밍 언어와 함께 사용하도록 최적화되어 있다. 도 1 및 도 3의 비 교는 AMPC (Algorithmic Matching Pipelining Compiler)에 포함된 추가 단계를 나타낸다. 일 예에서, ICAT 아키텍처는 내장형 조정 기능을 갖춘 일련의 표준 다중 처리/멀티 태스킹 주변 장치를 제공한 다. 실시간 운영 체제(RTOS)가 채택될 수 있다. 예를 들어, 멀티 태스킹, 실시간 운영 체제는 ICAT 아키텍처에 통합된다. 예를 들어 마이크로 컨트롤러 운영 체제(MicroC/OS)는 1991년 임베디드 소프트웨어 개발자인 Jean J. Labrosse가 설계한 실시간 운영 체제이다. 이것은 주로 C 프로그래밍 언어로 작성된 마이크로 프로세서 용 우선 순위 기반 선제 실시간 운영 체제 (priority-based pre-emptive real-time operating system)로, 상위 레벨 프 로그래밍 언어이다. ICAT 아키텍처의 원시 속도는 그러한 RTOS의 사용을 허용한다. MicroC/OS는 C 언어로 여러 함수를 정의할 수 있으며, 각각의 함수는 독립적인 스레드 또는 태스크로 실행될 수 있다. 각 태스크는 다른 우 선 순위에서 실행되며, 각 태스크는 ICAT 아키텍처의 가상 프로세서를 소유하고 있다고 생각한다. 우선 순위가 낮은 태스크는 우선 순위가 높은 태스크에 의해 언제든지 선점될 수 있다. 우선 순위가 높은 태스크는 지연이나 이벤트와 같은 운영 체제 서비스를 사용하여 우선 순위가 낮은 태스크를 실행할 수 있다. 태스크 관리, 태스크 간 통신, 메모리 관리 및 MicroC/OS 타이밍을 위한 운영 체제 서비스들이 제공된다. MicroC/OS는 오픈 소스이며 여러 상이한 프로세서 아키텍처에 적용할 수 있다. 기존 디자인을 ICAT 아키텍처로 변환할 수 있도록 PCBA 레이아웃 소프트웨어 및 엔지니어링 툴(tool)이 ICAT 아 키텍처에 제공된다. 일 예에서, 파이프라인 아키텍처는 표준 Verilog 또는 VHDL 코드를 사용하여 구현된다. 예를 들어, 1024 워드 명령어 캐시, 데이터 캐시 및 다중-레벨 메모리 캐시 아키텍처가 ICAT 아키텍처에 제공될 수 있다. ICAT 아키텍 처의 파이프 라이닝에는 결정 처리에서의 분기(branching)가 발생하는 경향을 감지하여 미래에 해당 경로를 학 습 알고리즘을 통과하는 기본 경로로 만드는 학습 알고리즘이 포함될 수 있다. 다른 예에서, 인터럽트 코드는 고립되어 있으며, 인터럽트 처리기는 개인 (private) 코드 위치와 함께 특정 입력 전용으로 사용된다. 일 예에 서, ICAT 아키텍처는 멀티 프로세서 디버거를 포함한다. 예를 들어, 기존 코드는 사전 처리 디버거(pre- processing debugger)에 의해 처리되어 기존 코드가 잘 분할되어 함수들이 분리되도록 할 수 있다. 그런 다음, 단일 디버거가 동작의 각 독립 스레드에서 실행될 수 있다. 예를 들어, 재구성 가능한 알고리즘 파이프라인 코어(RAPC)는 1000개 이상의 Intel i7 마이크로-프로세서, 보다 바람직하게는 10,000개 이상의 Intel i7 마이크로-프로세서에 상응하는 MIPS 및 메가 FLOPS를 제공하는 2인치 칩 패키지에 제공될 수 있다. 일 예에서, ICAT 아키텍처는 기존의 디버그 도구와 호환 가능하다. 다른 예에서, ICAT 아키텍처는 프로세서 간 통신을 포함하지 않는 기존의 레거시 코드를 실행하도록 구현된다. ICAT 특정 하드웨어는 모든 레거시 코드에 공통된 단일 디버깅 블록으로 통일된다. 예를 들어, 일반적인 멀티-프로세싱 장치의 주요 기능을 정확히 모방한 주변 장치들이 ICAT 아키텍처 용으로 복제된다. 예를 들어, 수퍼셋 주변 장치(superset peripherals)를 사용하 면 고객이 손쉽게 배열할 수 있다. 일 예에서, ICAT 아키텍처 컴파일러 또는 프리-컴파일러는 클럭 사이클을 카운트하는 하위 레벨 코드 타이밍 루 프, 명령 페치를 허용하는 지연 및 다른 비호환 타이밍 코드를 검출하고, ICAT 아키텍처 내에서 제공되는 호환 가능한 상위 레벨 프로그래밍을 통해 수동 또는 자동으로 수리 또는 교체용으로 플래그를 지정한다. 일 예에서, ICAT 아키텍처는 전통적인 아키텍처에 비해 4:1 MIPS 이점을 제공한다. 다른 예에서, 이점은 적어도 100:1이다. 일 예에서, ICAT 아키텍처는 AMPC(algorithmic matching pipeline compiler)를 포함하는데, 이는 표준 소스 코 드 포맷으로 처리 알고리즘을 수용하는 컴파일러이다. AMPC는 ICAT 아키텍처로 동작 가능한 종래의 처리 시스템 을 위한 펌웨어를 생성한다. 컴파일러는 아키텍처가 ICAT 하드웨어를 구성하는 명령들을 생성하여, 상기 아키텍 처가 AMPC에 의해 재구성할 수 없는 기존의 마이크로-프로세서에 비해 향상된 성능으로 알고리즘을 처리한다. 특히 AMPC는 파이프라인을 사용하여 알고리즘 집약적인 연산 처리가 필요한 애플리케이션들을 위해 프로세서 성 능을 최적화한다. 예를 들어, 이 펌웨어는 알고리즘을 최적의 성능으로 처리하는 ICAT(s) 하드웨어 아키텍처를 구성하기 위해 종래의 프로세싱 시스템상에서 실행될 수 있다. 일 예시에서, AMPC는 알고리즘을 직접 처리하기 위해 ICAT 아키텍처의 프로세서 리소스들을 구성하는 ICAT 하드 웨어를 작동하기 위한 코드를 생성할 수 있는 종래의 컴파일러 소스 코드를 컴파일하는 컴파일러를 제공한다. 예를 들어, AMPC는 C, C#, C++, Matlab 또는 기타 일반 컴파일러와 같은 종래의 컴파일러와 호환되는 소스 코드 를 사용한다. 일 예에서, AMPC에 의해 생성된 펌웨어는 ICAT 아키텍처의 메인 처리 시스템상에서 실행된다. 예를 들어 메인 처리 시스템은 ICAT 아키텍처의 나머지 부분과 동일한 칩에 있는 종래의 프로세서이며 ICAT 아키텍처와 원활하 게 작동한다. 이 예에서 AMPC는 C, C#, C++와 같은 소스 코드의 상위 레벨 프로그래밍 언어로 작성된 코드를 허 용하며, AMPC는 메인 처리 시스템에서 실행되는 ICAT 아키텍처 용 펌웨어를 출력한다. 이는 ICAT 아키텍처의 펌 웨어를 개발자가 친숙한 상위 레벨 프로그래밍 언어로 프로그래밍할 수 있게 함으로써 ICAT 아키텍처의 작동을 위한 코딩을 단순화한다. ICAT 아키텍처의 원시 속도는 패널티를 없애고 속도 최적화를 위한 기계 레벨 코드를 프로그래밍할 필요성을 줄여준다. 대신, 상위 레벨 프로그래밍 언어는 특정 애플리케이션에서 해결할 알고리즘 에 기초하여 성능을 최적화하기 위해 펌웨어를 최적화한다. 예를 들어, ICAT 아키텍처는 예를 들어 로봇 시각 시스템을 위해 펌웨어에 정의된 적어도 하나의 가상 컴퓨터에서 최적의 성능을 구현할 수 있도록 재구성 가능하 다. 일 예에서, 전통적인 마이크로-프로세서와는 달리, ICAT 아키텍처의 AMPC는 if-then-else 프로세스와 같은 소프 트웨어 구문(syntax)을, 예를 들어 파이프 라이닝을 사용하여 더 적은 클럭 사이클에서 프로세스를 최적으로 실 행하기 위해 상기 ICAT 아키텍처의 하드웨어를 재구성하는 펌웨어로 컴파일할 수 있다. 상기 펌웨어를 실행하면 ICAT 아키텍처가 구성된다. 대조적으로, 종래의 컴파일러는 모든 종래의 프로세서가 사용하는 펌웨어를 구축하 지만, 종래의 프로세서는 펌웨어에 의해 재구성되지 않는다. AMPC는 특정 애플리케이션에서 최적의 작동을 위해 ICAT 아키텍처를 구성하여 ICAT 아키텍처용 펌웨어를 작성한다. 일 예에서, AMPC는 ICAT 아키텍처의 프로세서 하드웨어에 대한 입력 구조로서 상기 알고리즘을 사용하여 ICAT 하드웨어의 구성을 선택하고 구조화한다. 예를 들어, ICAT 아키텍처의 하드웨어 아키텍처는 AMPC를 생성한 펌웨어에 의해 구성될 때, 특정 애플리케이션 에 대한 속도 성능을 처리하기 위해 AMPC에 의해 최적화된다. AMPC는 종래의 컴파일러가 ICAT 또는 임의의 마이 크로-프로세서의 하드웨어를 재구성할 수 없는 ICAT 아키텍처의 하드웨어를 재구성할 수 있다. 표준 시스템 컴파일러는 종래의 프로세서 시스템에서 하드웨어의 아키텍처를 변경할 수 없다. 그러나, 일 예에 서, AMPC는 ICAT 아키텍처 프로세서가 하드웨어의 이전 결과에 기초하여 파이프라인 처리 및 데이터의 라우팅을 직접 수행하도록 구성하는 펌웨어를 생성한다. 예를 들어, if-then-else 논리문(logic statement)을 AMPC에 입 력하면 ICAT 아키텍처의 하드웨어가 구조화되어 데이터 결과가 다음 ICAT로 라우팅된다. 이 예에서, AMPC는 코 드 페칭(code fetching), 데이터 로딩, 데이터 저장, 분기 및 동일한 if-then-else 논리에 대한 서브 루틴과 같 은 종래의 처리 시스템의 오버 헤드를 제거하는 하드웨어 구성을 생성한다. 도 4는 ICAT 아키텍처의 예를 도시한다. 하나의 예에서, Visual Studio와 같은 종래의 컴파일러는 메인 처리 시 스템상에서 실행되는 ICAT 구성 프로그램을 생성하는데 사용될 수 있다. 이는 칩에서 다양한 타입 처리 알 고리즘을 실행 및 처리하도록 재구성 가능한 하드웨어의 재 프로그램 가능한 풀을 구성하고 재구성하는 방법을 제공한다. 하드웨어가 아닌 소프트웨어만 종래의 프로세싱 시스템에서 변경될 수 있기 때문에, 종래의 처리 시 스템(예를 들어, 인텔, ARM, IBM, AMD 마이크로프로세서들)은 다양한 알고리즘을 실행하도록 재구성될 수 없다. ICAT 아키텍처를 사용함으로써, 종래의 처리 시스템의 모든 페치 및 실행 코드 명령 오버 헤드가 제거된다. 도 4의 ICAT 아키텍처는 시스템 온 칩(SOC) 디바이스에 구현된 병렬 프로세서 리소스들의 풀을 이용하여 데이 터의 효율적인 처리를 수행하기 위해 구성 가능한 재구성 가능 하드웨어(re-configurable hardware)를 제공한다 예를 들어, 논리 프로세서들 및 구성 가능한 행렬 라우팅이 뒤 따르는 수학 프로세서들(pool)의 풀은 병렬 처리 리소스들의 풀을 구현한다. 이 아키텍처는 파이프라인 처리 리소스들을 처리하여 특정 애 플리케이션의 처리 성능을 최적화할 수 있다. 일 예에서, 프로세서의 풀은 메인 프로세서 로부터 추 가 명령을 수신하지 않고 메인 프로세서와 독립적으로 다수의 처리 태스크들을 수행한다. 각 ICAT는 전체 알고리즘을 독립형 프로세서 시스템으로 처리하도록 구성될 수 있다. 따라서, ICAT는 그 자체 내에서 시스템으 로 간주될 수 있으며, 일단 알고리즘을 수행하도록 구성된 알고리즘의 처리를 완료하는데 오버 헤드가 필요하지 않다. 예를 들어, ICAT는 if-then-else 명령 세트를 수행하도록 구성될 수 있으며, 나중에 고속 푸리에 변환 또 는 다른 수학적 알고리즘 솔루션과 같이 완전히 다른 명령 세트를 수행하도록 재구성될 수 있다. 불필요한 활동(activity)의 순환을 줄임으로써, ICAT 아키텍처는 종래의 프로세서에 비해 전력 소비를 줄이고 열 발생률을 낮추며 데이터 처리 속도를 높인다. 상기 ICAT 리소스들은 데이터가 그들의 입력에서 처리될 준비가 되었을 때, 구성될 때까지 유휴(idle) 상태이다. 모든 프로세서는 필요하지 않을 때 유휴 상태로 유지되 므로 불필요한 오버 헤드로부터 발생하는 열을 줄일 수 있다. ICAT 리소스들의 풀에 있는 각 프로세서는, ICAT 가 코드를 페치하고 실행하지 않기 때문에 종래의 프로세서보다 적은 오버 헤드를 갖는다. 대신, 상기 하드웨어 는 특정 동작을 수행하도록 구성되며 ICAT 아키텍처에 의해 제공되는 상기 구성된 알고리즘으로 처리되어야 하 는 데이터가 제공될 때만 활성화된다. 일 예시에서, 단일 ICAT 프로세서는 수학 프로세서들의 풀, 논리 프 로세서들의 풀 및 구성 가능 매트릭스 라우팅에 의해 조정되는 출력을 사용한다. 이 동일한 ICAT 프로세서는 if-then-else와 같은 단순 처리 태스크를 위해 또는 안면 인식에 사용되는 알고리즘 과 같은 매우 진보된 복잡한 알고리즘을 위해 사용될 수 있다. ICAT 리소스들의 복수의 그룹 또는 풀, 수 학 프로세서들의 풀, 논리 프로세서들, 및 구성 가능 매트릭스 라우팅에 의해 조정된 출력을 사 용함으로써, ICAT 아키텍처는 예를 들어 모션, 형상 또는 신원 검출과 같은 파이프라인 아키텍처에서 복수의 계 산을 요구하는 태스크를 처리하는데 사용될 수 있다. 하나의 예에서, 알고리즘은 ICAT 프로세서들의 상호연결 버스 구조를 제어하고, ICAT 아키텍처는 비디오, 센서 또는 이전 프로세스 단계로부터의 데이터와 같은 출력 디바이스들로부터의 입력 데이터 스트림을 처리한다. 예를 들어, 이전 결과는 데이터 메모리 버퍼들, 라이브 입력데이터 또는 다른 처리된 단계(110, 11 1)로부터의 임의의 데이터로부터 스트리밍될 수 있다. 처리 결과는 예를 들어 제어 출력 또는 비디오 출력과 같 은 디바이스로 직접 출력될 수 있다. 프로그래머는 도 5의 예에 도시된 바와 같이 AMPC를 이용하여 복수의 RAPC를 구성할 수 있다. 대안적으로, AMPC 의 사용은 예컨대 칩상의 시스템에 의해 자동화되고 제어될 수 있다. 도 5는 최초의 컴파일러에 원래의 상위 레 벨 프로그래밍 언어 소스 코드를 삽입하는 프로그래머를 위한 6단계 흐름도를 나타낸다(AMPC는 ASML이라고 함). ASML 프리-컴파일러는 자동으로 발생하는 2단계에서 오리지날 소스로부터 코드를 추출한다. 그런 다음, 프리-컴 파일러는 새로운 소스 코드를 두 번째 컴파일러로 출력한다. 이 단계는, 프로그래머가 새로운 소스가 디버깅되 고 최적화되었다고 만족한 후에 자동으로 또는 프로그래머에 의해 별도의 단계로서 수행할 수 있다. 이 두 번째 컴파일러는 ICAT 아키텍처 용 펌웨어 빌드(firmware build)를 컴파일한다. 그런 다음, 펌웨어가 ICAT 아키텍처 로 로드되어, 상기 펌웨어는 ICAT 아키텍처의 RAPC를 구성한다. 프로그래머는 상기 펌웨어가 디버깅되고 최적화 된 것으로 만족한 후 이 펌웨어를 ICAT 아키텍처로 업로드할 수 있다. 대안적으로, 각각의 단계는, 오리지날 소스 코드를 ICAT 아키텍처로 로딩하는 것을 제외하고, 자동화될 수 있고 인간의 개입없이 발생할 수 있다. 종래의 프로세서를 복수의 RAPC 및 AMPC와 조합함으로써, 전체 프로세스는 종 래의 프로세서가 AMPC를 실행하여 오리지날 소스 코드를 재컴파일하여, 오리지날 소스 코드에 포함된 명령들에 기초하여 RAPC를 설정하기 위해 종래의 프로세서에 의해 사용되는 펌웨어를 생성하도록 자동화될 수 있다. ICAT 리소스 풀에는 예를 들어 수학 모듈, 논리 모듈 및 결과 라우팅 모듈과 같은 세 가지 타입의 프로세서 모 듈이 포함될 수 있다. 수학 모듈은 수학 함수를 수행한다. 논리 모듈은 논리 기능을 수행한다. 결과 라우팅 모 듈은 분기 및 데이터 라우팅 기능을 수행한다. 예를 들어, 도 6에서, 재사용 가능한 알고리즘 파이프라인 컴퓨 터(RAPC)가 개략적으로 설명된다. 설정(setup) 버스는 AMPC에 의한 ICAT 아키텍처의 설정 레지스터의 구성 에 의해 확립(estabilish)된다. 피연산자는 디지털 신호 프로세서(DSP)상의 메모리 위치들(A, B, C 및 D) 로 전달된다. DSP는 수학적 알고리즘을 실행하도록 구성된다. 알고리즘의 결과는 논리 의사 결정 프로세서(LDP : logical decision processor)로 전달된다. LDP는 논리 명령들을 실행한다. 논리 명령의 결과는 직접 또 는 매트릭스 버스 스위치(MBS)를 통해 다음 RAPC로 전달된다. 상기 MBS는 결과를 다음 RAPC로 보내거나 고속 스 트리밍 인터페이스에서 상기 결과를 전달하기 위해 입력 및 출력 및 인터럽트를 제어한다. 하드웨어 리소스는 최적의 성능을 위해 파이프라인 구조로 상호 연결된 ICAT 코(co)-프로세서 시스템에 구성될 수 있다. 일 예에서, 재구성 가능한 하드웨어 리소스의 재 프로그램 가능한 풀을 설계하는 방법은 칩에서 복수 의 처리 알고리즘을 실행 및 처리한다. ICAT 프로세서를 구성하기 위한 하드웨어 리소스는 칩에 설계될 수 있으 며, 칩의 하드웨어 리소스는 AMPC를 통해 재구성될 수 있다. ICAT 처리 시스템의 아키텍처는 예를 들어 알고리 즘 처리를 위한 소스 코드로 구성된다. 따라서, 따라서, 종래의 프로세서용으로 생성된 코드는 ICAT 아키텍처상 에서 훨씬 효율적으로 실행될 수 있는데, 그 이유는 ICAT 프로세서의 하드웨어가 예를 들어 AMPC를 사용하는 프 로세서와 독립적으로 알고리즘을 수행하기 위해 소스 코드에 의해 구성되기 때문이다. 따라서, ICAT 아키텍처는 당 업계에 공지되지 않은 종래의 마이크로 프로세서 용으로 생성된 소스 코드로부터 ICAT 하드웨어 아키텍처를 구성할 수 있다. 일 예에서, 프로세서에 의해 알고리즘 매트릭스 구조로 구성 가능하고 재구성 가능한 하드웨어 리소스의 풀이 생성되고, 상기 하드웨어 리소스의 풀은 칩에서 복수의 프로세싱 알고리즘을 실제로 처리한다. 일 예에서, 하드웨어 리소스는 파이프 라이닝을 사용하여 다른 프로세서와 독립적으로 복수의 명령을 통해 데이 터를 처리한다. 일 예에서, ICAT 아키텍처 및 알고리즘 매칭 파이프라이닝 컴파일러는 결합되어, 계산 속도와 효율성을 모두를 달성하면서 당 업계에 알려지지 않은 결과를 달성한다. 예를 들어, AMPC는 복수의 처리 알고리즘을 실행하기 위 한 하드웨어 리소스를 구성한다. AMPC는 ICAT 칩의 ICAT 리소스의 풀로부터 처리 알고리즘을 구성하는데 사용되 는 구성 설정 펌웨어를 생성한다. 이를 통해 프로그래머는 ICAT 아키텍처 내에서 개별 하드웨어 처리 알고리즘 을 생성하기 위해 ICAT 하드웨어 리소스를 매칭 및 할당하도록 설계된 종래의 프로세서 및 새로운 소스 코드용 으로 설계된 기존 애플리케이션 소스 코드를 수용할 수 있는 풀을 제공한다. AMPC는 메인 프로세서를 구동하는 펌웨어를 생성하여, ICAT 하드웨어가 특정 목적을 위해 SOC의 동작 중에 상기 메인 프로세서와 독립적인 복수의 알고리즘을 수행하도록 구성한다. 종래의 프로세서는 프로그램 메모리, 프로그램 명령의 단계별 실행에 사용되는 페치 및 실행 하드웨어; 벌크(힙) 데이터 및 프로그램 스택 구조의 저장에 필요한 데이터 메모리; 및 종래의 프로세서 아키텍처에서 모 두 상당한 오버 헤드를 발생시키는 명령 페치 & 실행 사이클, 프로그램 스택 관리 및 데이터 힙 저장 관리를 포 함하는 유사한 아키텍처를 사용한다. 대조적으로, 일 예에서, ICAT 아키텍처는 종래의 프로세서 시스템의 거의 모든 오버 헤드를 제거한다. ICAT 하 드웨어 풀은 AMPC에 의해 구성되며 ICAT 코-프로세서 아키텍처와 파이프라인된 스트리밍 데이터 구조를 사용하 여 알고리즘을 처리하는데 사용된다. 따라서, 일 예에서, ICAT 아키텍처를 사용하는 방법은, 칩에서 이용 가능 한 리소스를 정의하는 ICAT 하드웨어 컴파일러 테이블에 액세스하는 AMPC; 주어진 프로세서에 대해, Verilog와 같은 하드웨어 설계 언어가 ICAT 하드웨어의 풀을 컴파일하는데 사용되고; 하드웨어 컴파일은 칩 내의 ICAT 리소스 풀의 구조를 정의하는 테이블을 출력하고; 상기 AMPC는 하드웨어 컴파일러에 의해 생성된 데이터의 테이블을 사용하여 상기 칩의 ICAT 리소스의 위치 및 수량을 결정하고; AMPC는 하드웨어 리소스를 할당하고, 수 학 및 논리 연산을 구성하고 그리고 다양한 알고리즘에 대한 상호 연결을 생성하며, 상기 AMPC에 대한 소스 입 력 구문 (syntax)은 C# 구문 또는 Matlab과 같은 표준 수학 구문을 포함할 수 있고; 상기 AMPC는 사용 가능한 (103...111) ICAT 하드웨어 리소스의 풀로부터 각 알고리즘에 대한 파이프라인 구조를 구성하고; 이들 파이프라 인 구조는 예를 들어 각 알고리즘에 대한 ICAT 코-프로세서를 형성한다. 예를 들어, AMPC는 병렬 ICAT(들) 코- 프로세서상의 알고리즘을 실행하는 리소스들의 제어 레지스터(103, 104, 105, 106)를 구성하는 메인 처리 시스템에서 실행되는 코드를 출력한다. 코-프로세서 시스템 구조는 예를 들어 메인 프로세서로부터의 입력에 응답하는 ICAT 리소스들의 풀로 부터 구성될 수 있다. 선택적으로, ICAT 리소스들의 풀은, 메인 프로세서 구조가 상기 메인 프로세서와 분 리된 입/출력 디바이스를 포함하는 경우, 인터럽트를 생성하여 메인 프로세서 또는 메인 프로세서의 입력/출력 디바이스로 데이터를 출력할 수 있다. 일 예에서, ICAT 리소스들의 풀은 종래의 프로세서 에 의해 구성되고, 그런 다음 ICAT 리소스는 재구성될 때까지 자체적으로 실행될 수 있다. ICAT 프로세서의 프로세서는 일단 ICAT 프로세서가 펌웨어에 의해 구성되면, 자체적으로 데이터 스트림을 병렬 로 연속적으로 처리할 것이다. 대조적으로, 종래의 시스템은 각 처리 단계에서 프로세스 흐름을 결정하기 위해 메모리를 끊임없이 이동하고 명령들 페치할 것을 요구한다. AMPC는 예를 들어 특정 알고리즘의 처리를위한 처리 단계들을 실행하기 위해 ICAT 아키텍처의 특정 ICAT 프로세서 구조에 예를 들어, 수학 논리 및 라우팅과 같은 리소들의 하드웨어 그룹을 할당할 수 있다. 종래의 컴파일러는 마이크로프로세서의 하드웨어 구조를 선택 및 구 성하지 않는다. 예를 들어, AMPC가 ICAT 아키텍처의 하드웨어 구조를 구축할 때 처리 성능을 향상시키는 파이프 라인 아키텍처에서 ICAT 아키텍처에 대한 하드웨어 리소스를 구성할 수 있다. 종래의 컴파일러는 이것을 할 수없다. 도 4의 예에서, ICAT 제어 레지스터는 처리 기능을 제어하기 위한 레지스터 세트이다. 예를 들어, 디지털 신호 프로세서(DSP) 입력 모드 레지스터는 스플릿 입력 워드(Split Input Words), 사전-가산기(Pre-Adder) 제 어, 입력 레지스터 뱅크 선택 및 다른 DSP 입력 기능을 포함할 수 있으며, DSP ALU 모드 레지스터는 더하기, 뺄 기, 곱하기, 나누기, 오른쪽 시프트, 왼쪽 시프트, 회전, and, or, xor, nor, nand 및 다른 논리 프로세스를 제 어할 수 있으며, DSP 멀티플렉서 선택(DSP Multiplexor Selects)은 시프트 및 입력 선택을 제어할 수 있다. 상 기 DSP는 각 ICAT에 대해 하나의 DSP48E1을 사용할 수 있다. 예를 들어, DSP48E1 디바이스들은 자일링스 7(Xilinx 7) 시리즈의 필드 프로그래머블 게이트 어레이에 제공될 수 있다. 예를 들어, ICAT 메모리 및 로직 동 작들은 메모리 및 메모리 로직 동작들을 제어하는데 사용될 수 있다. 일 예에서, 움직임 검출 알고리즘은 범용 컴퓨터에서 사용하기 위해 C 언어로 작성된다. 코드 예 1 : C 언어로 작성된 움직임 검출 알고리즘(상위 레벨 프로그래밍 언어) int noise threshold = 3; int live_video_pixel = 0; int black_video_pixel = 0; boolean motion_detected = false; int live_red_pixel = 0; int live_green_pixel = 0; int live_blue_pixel = 0; int frame_delayed_pixel; int frame_delayed_red_pixel = 0; int frame_delayed_green_pixel = 0; int frarne_delayed_blue_pixel = 0; int red_mask = 255; // OOOOFF hex, 00000000000000001111111 1 binary, extracts bits 0 thru 7 int green mask = 65,2280; // OOFFOO hex, 000000001111 111100000000 binary, extracts bits thrul5 int green_divisor = 256 int blue_mask = 16,711,680; // FFOOOO hex, 11 1111110000000000000000 binary, extracts bits 3 thru 16 int blue_divisor = 65,536 // Procedure to extract red, green, and blue pixels from live _video_pixel void extract_live_red_green_blue(int live_video_pixel) { live_red_pixel =(live_video_pixel) ; // extract red pixel from live video live_red_pixel = live_red_pixel & red mask live_red_pixel =(live_red_pixel / red divisor) live green pixel =(live_video_pixel) ; // extract green pixel from live video live_green_pixel = live_ green_pixel & green_mask live_green_pixel =(live_green_pixel / green_divisor) live blue pixel =(live_video_pixel) ; // extract blue pixel from live video live_blue_pixel = live_ blue_pixel & blue_mask live_blue_pixel =(live_blue_pixel / blue_divisor) } //Procedure to extract red, green, and blue pixels from delayed_frame_video_pixel void extract_delayed_red_green_blue(int frame_delayed_video_pixel) ; { frame_delayed_red_pixel =(live_video_pixel) ; // extract red pixel; frame_delayed_red_pixel =(frame_delayed_red_pixel & red_mask) ; frame_delayed_red_pixel =(frame_delayed_red_pixel / red_divisor); frame_delayed_green_pixel =(live_video_pixel) ; // extract green pixel frame_delayed_green_pixel =(frame_delayed_green_pixel & green mask) ; frame_delayed_green_pixel =(frame_delayed_green_pixel / green_divisor); frame_delayed_blue_pixel =(frame_delayed_video_pixel) ; // extract blue pixel frame_delayed_blue_pixel =(frame_delayed_ blue_pixel & blue_mask) frame_delayed_blue_pixel =(frame_delayed_blue_pixel / blue_divisor) } // Procedure for motion detection algorithm boolean motion_detected detect_motion() ; { motion detect = false; //get ready to detect motion result_red_pixel =(frame_delayed_red_pixel - live_red_pixel) ; // subtract red pixels if(result_red_pixel > noise_threshold) // test if red_result is greater than noise threshold { motion detected = true; // motion was detected on red pixel } // end if(result_red_pixel > noise_threshold) result_green_pixel = frame_delayed_green_pixel - live_green_pixel; // subtract green pixels if(result greenjpixel > noise threshold) // test if green_result is greater than noise threshold { motion_detected = true; // motion was detected on green pixel } // end if(result_green_pixel > noise threshold) result_blue_pixel = frame_delayed_green_pixel - live_green_pixel; // subtract green pixels if(result_blue_pixel > noise_threshold) // test if bluejresult is greater than noise threshold { motion detected = true; } // end if(result_blue_pixel > noise_threshold) return motion_detected; // motion was detected on blue pixel } // end of motion detection algorithm // Procedure for one frame of video,(Executed for each frame of video) do // process all pixels for each frame(hd = 777,600 pixels per frame) //(31 instructions executed for each pixel) { if(pixel_clock = true) ; // pixel_clock is from the live video stream, hd = 46.656 MHz, { // extract red, green, and blue pixels from live video and delayed video pixels frame_delayed_pixel = delay_buffer_output_pixel; // get a frame delayed video pixel live_video_pixel = live_video_input_pixel; // get a live video pixel extract_live_red_green_blue(int live_video_pixel) ; // extract live color pixels,(9 instructions/pixel) extract_delayed_red_green_blue(int frame_delayed_pixel); // extract delayed color pixels,(9 instructions/pixel) } //end if(pixel_clock = true) motion_detect = detect_motion(); // call function to detect motion(11 instructions/pixel) if(motion detect = true); // motion_detect swaps the processing of video outputs 1 and 2 { output 1 ; // Only moving video is displayed. Non-moving video is black. output2; // Only non-moving video is displayed. Moving video is black. } // end if(motion_detect = true) if(motion detect = false); // motion detect swaps the processing of video outputs 1 and 2 { output 1 ; // Only non-moving video is displayed. Moving video is black. output2; // Only moving video is displayed. Non-moving video is black. } // end if motion_detect = false) until(end_of_frame = true) ; // end_of_frame is a signal in the video stream 도 7은 AMPC 컴파일러를 사용하여 코드 예 1을 컴파일한 결과로 나타나는 하드웨어 구성 다이어그램의 개략도를 나타낸다. 비디오 디바이스는 라이브 비디오 픽셀의 스트림 및 프레임 지연 버퍼 스트림의 2개 의 출력을 갖는다. RGB 출력에 대해, 각 픽셀은 적색, 녹색 및 청색으로 구성된다. 상기 DSP는 라이브 피 드(live feed)와 지연된 피드의 비교를 수행하고, 그 결과는 움직임이 검출되는지 결정하는 LDP로 파이프 라인된다. 상기 결과는 RAPC1의 MBS에 의해 출력된다. 단일 RPAC은 매 클럭 사이클마다 병렬로 실행되 는 3개의 처리 블록을 구현하도록 구성된다. 이와 대조적으로, 종래의 처리 시스템은 움직임을 검출하기 위해 비디오의 각 픽셀을 처리하기 위해 37개의 명령의 실행을 필요로 한다. 이들 명령의 대부분은 재구성이 불가능 한 비-파이프라인 프로세서에서 실행될 때 3 클럭 사이클 이상 소요된다. 그럼에도 불구하고, 최적화되지 않은 범용 프로세서의 경우 3 클럭 사이클 동안 평균 명령을 실행하더라도, 각 픽셀을 처리하는데 111 CPU 클럭 사이 클이 소요될 것이다. 현대 카메라에서 픽셀 수가 증가함에 따라 모뎀 단일 및 멀티 코어 프로세서에서 사용할 수 있는 사이클 시간이 작업에 부적합하다는 것은 분명하다. 대조적으로, 코드 예 1으로부터 AMPC 컴파일러에 의해 구성된 단일 RAPC 프로세서의 구성 예는 비디오의 픽셀 클럭을 사용하여 연속적인 픽셀 스트림을 처리한다. 3개의 처리 블록(DSP, LDP 및 MBS)은 3 클럭 사이클의 대기 시간(latency)을 갖는 FPGA의 파이프라인된 스트리밍 구성으로 구현되지만, 파이프라인이 채워진 후(비디오의 픽셀 클럭의 처음 3 클럭 사이클 이후)의 각 클럭 사이클은 111 클럭 사이클 당 하나의 픽셀과 비교하여 클럭 사이클 당 하나의 픽셀인 픽셀의 출력을 처리한다. 결과적으로, 단일 RAPC는 종래의 처리 시스템의 단일 코어보 다 적어도 111배 이상 빠르게 수행한다. 즉, 픽셀은 명령 당 37 명령 × 3 클럭 사이클 또는 종래의 프로세서에 대한 픽셀 당 111 클럭 사이클과 비교하여 ICAT에서 각 클럭 사이클을 처리한다. 단일 ICAT 칩에 2천개(이상의) RAPC 프로세서가 구현될 수 있기 때문에 결합된 처리 능력은 단일 코어 종래 프로세서보다 적어도 222,000배 빠 르다. 현재의 종래의 프로세서는 쿼드 코어 등으로 제한되지만, 종래의 프로세서에 코어를 추가하는 것은 추가 적인 오버 헤드가 없다. 종래의 프로세싱 코어보다 더 많은 RAPC를 추가할 수 있으며, 각 RAPC는 단독으로 또는 다른 RAPC와 함께 파이프라인으로 재구성될 수 있다.코드 예 1과 도 7의 요점은 RAPC를 추가하는 것은 단순히 칩의 밀도와 크기의 문제이며 오버 헤드를 추가하지 않고 수천개가 ASIC에 추가될 수 있다는 것이다. 각 RAPC는 파이프라인된 병렬 프로세서이다. 따라서, 코어 추 가, 캐시 메모리 추가 및 종래 프로세서의 오버 클럭킹(overclocking)을 통해 수십 개의 RAPC가 있는 단일 ICAT 칩의 성능에 가까운 종래의 프로세서는 얻을 수 없었다. 또한 종래의 프로세서를 밀어 넣으려는 노력의 전부는 재구성이 불가능한 비-파이프라인 프로세서의 과열, 비용 및 크기를 초래한다. ICAT 아키텍처의 RAPC 성능을 높 이기 위해 이러한 동일한 방법이 사용될 수도 있다. 그럼에도 불구하고, ICAT 아키텍처에 RAPC를 추가하면 프로 그래머가 ICAT 아키텍처를 위해 특별히 프로그램할 필요없이 종래의 프로세서 아키텍처와 비교하여 항상 성능이 크게 향상될 것이다. 이것은 놀랄만하고 예기치 않은 결과이다. 범용 프로세서의 성능을 향상시키기 위해 프로 그래밍 가능하고 재구성 가능한 아키텍처를 종래의 프로세서에 추가하는 것에는 거의 관심을 기울이지 않았지만 모든 관심은 종래의 프로세서를 더 많이 사용하는데 초점을 맞추고 있다. 또한, 표준 FPGA에서 코드 예 1에 대해 동일한 솔루션을 구현하려면 이 예에 제공된 것처럼, 표준 상위 레벨 프 로그래밍 언어를 재컴파일하는 것 이상의 것이 필요하하. 예를 들어, 자일링스 FPGA에서 행렬 곱셈기, PID 또는 임의의 복잡한 알고리즘을 성공적으로 개발하려면 다음과 같은 기술들: RTL 및 Verilog 언어로 회로 설계에 대 한 실무 지식; 진보된(advanced) 아키텍처 기술(병렬 처리, 파이프라이닝, 데이터 스트리밍, 리소스/성능 절충 등); 산술, 논리적 의사 결정, 메모리 디바이스, 컨트롤러 디바이스, 주변 장치 인터페이스 등과 같은 다양한 하드웨어 구축 블록을 사용한 설계 경험; 소프트웨어 설계; 상위 레벨 프로그래밍 언어의 다양한 버전에 대한 실무 지식; 모니터링 및 제어 애플리케이션에 사용되는 수학 알고리즘에 대한 실무 지식; 자일링스 하드웨어에 \"C\"코드를 컴파일하는 것과 같은 자일링스 소프트웨어 툴을 사용하는 방법에 대한 지식; 하드웨어 디자인 검증 및 성능 목표를 달성하기 위해 필요한 경우의 아키텍처 수정; \"C\"코드 테스트 벤치(test bench) 구축; 테스트 벤치 결과에 대한 하드웨어 시뮬레이션 결과 검증; 하드웨어에서 디자인을 구현하고 그에 대한 테스트들이 필요 하다. 이 모든 것들은 일반적인 고급 프로그래밍 기술을 가진 사람의 능력을 훨씬 뛰어 넘는 적시성 및 비용으 로 일반적인 FPGA 프로젝트를 만든다. 기술의 현재 상태는 성능이 무엇보다 중요하고 맞춤 설계 및 프로그래밍 의 지연 및 비용이 수용되는 니치 처리(niche processing)를 위해 FPGA를 예비한다. 대조적으로, 프론트 엔드인 상기 마이크로 프로세서 아키텍처는 익숙한 범용 아키텍처이므로 어떤 우수한 고급 언어 프로그래머라도 ICAT 기술을 프로그래밍할 수 있다. RAPC는 범용 프로세서 및 AMPC에 의해 구성되며, 상기 AMPC는 각 RAPC의 표준 구조를 사용하여 예를 들어, 도 7의 다이어그램에 도시된 바와 같이 프론트 엔드 프로세 서에 대한 표준 코드에 기초하여 하나 이상의 RAPC를 재구성한다. 따라서, 세계를 향한 표준 프로세서 아키텍처 를 사용하여 RAPC를 구성 및 재구성하기 위한 RAPC 및 AMPC를 포함하는 ICAT 기술은 종래의 프로세서 및 모든 알려진 FPGA 프로세서에 비해 놀랍고 예기치 못한 발전이다. 도 8은 재사용 가능한 알고리즘 파이프라인 코어와 알고리즘 매칭 파이프라인 컴파일러를 결합하는 마이크로 프 로세서의 응용을 나타낸다. 종래의 마이크로 프로세서의 비디오 프로세싱 속도의 부족은 특수하고 값 비싼 칩 세트 또는 사후 처리를 필요로 한다. 도면에 도시된 바와같이, RAPC 및 AMPC 기능을 갖춘 범용 프로세서는 수백 만 픽셀을 실시간으로 처리하여, 움직임 감지, 비디오 압축 및 예를 들어 소비자 전자 디바이스에 탑재된 범용 ICAT 칩으로부터의 비디에 대한 보다 빠른 업로드 및 다운로드 속도를 제공하는 솔루션을 제공한다. 각각의 RAPC는 DSP, LDP 및 MBS를 포함할 수 있다. DSP는 필요한 연산 타입(즉, 정수 및 부동 소수점, 곱셈, 나 눗셈, 더하기, 빼기 등)을 프로그래밍하기 위한 설정 인터페이스를 가질 수 있다. DSP는 도 8에 도시된 바와 같 이, 설정 데이터에 의해 결정되는 수학 함수의 다양한 조합으로 연접(concatenated)되거나 연산될 수 있는 피연 산자 데이터에 대한 4개의 입력을 가질 수 있다. DSP는 상태 데이터와 함께 결과 데이터로서 출력되는 48 비트 누산기를 가질 수 수 있다. 상태 데이터에는 예를 들어, 수행하다(carry out), 동등하다(equal), 보다 큰 (greater than) 및 미만(less than)이 포함된다. LDP는 예를 들어, 룩업 테이블, 루프 카운터 및 상수 레지스터를 프로그래밍하기 위한 설정 인터페이스를 가질 수 있다. LDP는 반복 알고리즘이 완료될 때를 감지하는 루프 카운터를 가질 수 있다. LDP는 룩업 테이블에 대한 입력을 위한 상수 데이터를 유지할 수 있는 레지스터를 가질 수 있다. LDP는 기능을 수행하는데 사용할 수 있는 메모리 블록을 가질 수 있다. LUT 함수는, 구현될 수 있고 루프 카운터를 사용하여 순차적으로 액세스될 수 있 는 룩업 테이블; 제어 목적을 위해 DSP 상태, 상수 레지스터 또는 DSP 결과 데이터에 의해 구현되고 액세스될 수 있는 룩업 테이블; 및 제어 목적을 위해 기타 논리 신호를 구현하고 출력할 수 있는 논리 룩업 테이블을 포 함할 수 있다. LDP는 결과 데이터를 입력으로부터 출력으로 전달할 수 있다. LDP는 예를 들어 그의 출력에서 결 과 데이터에 대한 하나의 파이프라인 레지스터를 가질 수 있다. 대안적으로, LDP는 그의 출력에서 결과 데이터에 대한 동기 클리어 인에이블(synchronous clear enables)을 갖는 2개의 파이프라인 레지스터를 가질 수 있다. 이 상세한 설명은 당해 기술 분야의 통상적인 기술자가 청구 범위에 기재된 발명을 제작하고 사용할 수 있도록 하기 위해 청구 범위의 특징 및 요소를 포함하는 예들을 제공한다. 그러나, 이러한 예들은 청구 범위를 직접적 으로 제한하지는 않는다. 대신에, 상기 예들은 이들 설명, 청구 범위 및 도면에 개시된 청구 범위의 특징 및 요 소를 제공하며, 당해 기술 분야에 공지된 방식으로 변경 및 조합될 수 있다. 예를 들어, 임의의 방식으로 제한됨 없이 3325 RAPC는 단일 Xilinx® Zynq® FPGA 칩상에서 구성될 수 있고, 여 기서 Xilinx® 및 Zync®는 Xilinx, Inc.의 상표이며 100MHz의 적정 클록 속도로 실행된다. 각각의 클럭에서, RAPC는 각각 1 또는 2개의 논리 연산 및 수학 연산을 처리할 수 있다. 따라서, 이 구성은 332 기가플롭스 (GigaFLOPS)를 생성한다. 예를 들어, 이 구성은 4개의 수학 연산(예컨대, 더하기, 빼기, 곱하기, 나누기)과 4개 의 논리 연산(예컨대, 보다 큼, 작음, 같음, 같지 않음) 각각에 대해 록업 데이블(LUT)을 사용한다. 표준 LUT 메모리 크기는 512바이트이다. 게다가, 다른 로직 연산 LUT에 추가하여, \"구성 가능한 상수 값보다 큰\" LUT가 제공될 수 있다. 일 예에서, LUT의 출력 신호는 RAPC들간의 조정 결과를 위한 버스 멀티플렉서 스위치를 제어하 는데 사용된다. AMPC 컴파일러는 폰 노이만 (von Neuman) 아키텍처용으로 작성된 고급 프로그램 언어의 소스 코 드를 프리컴파일하고, AMPC 컴파일러는 RAPC에 의해 수행되는 각 연산에 대해 LUT을 선택하여, 폰 노이만 아키 텍처용으로 작성된 소스 코드에서 비-폰 노이만 프로세서를 생성한다. 종래의 폰 노이만 프로세서와 비교할 때, GigaFLOPS가 초당 10억 부동 소수점 연산으로 정의되는 332 GigaFLOPS 는, 칩에 대한 특별한 냉각(cooling) 요구 사항 없이도 얻을 수 있는 것으로 이해될 때 특히 존경받을 만한 가 치가 있다. 비교해 보면, 종래의 폰 노이만 처리 시스템은 각 수학, 논리 및 분기 연산에 대해 별도의 페치 및 실행 사이클이 필요로 하는 반면 RAPC는 각 수학, 논리 및 분기 연산에 대해 별도의 페치 및 실행 사이클을 요 구하지 않는다. 일 예로서, 계산은 자일링스(Xilinx) 및 버텍스(Virtex)가 자일링스(Xilinx, Inc.)의 상표이고 741MHz 클럭 속 도를 갖는 Xilinx® Virtex ZU13 칩은 236,250 RAPC로 구성될 수 있음을 보여주면, 이 칩에 175,000gigaFLOPS 보다 큰 성능을 부여하는 것은 놀라운 결과이며, 당업자에게는 예기치 못한 놀라운 일이다. 이러한 결과는 RAPC 가 수행된 각 수학, 논리 및 분기 연산에 대해 별도의 페치 및 실행 사이클을 요구하지 않기 때문에 가능하다. 범용 컴퓨터 프로세서의 폰 노이만 아키텍처에 의해 제기된 이 문제 및 기타 문제는 본 명세서에 개시된 RAPC 및 아키텍처를 사용하여 해결된다. 폰 노이만 아키텍처를 갖는 프로세서(즉, 모든 알려진 최신 범용 프로세서) 용으로 작성된 프로그램은 기술된 아키텍처에서 실행하기 위해 재작성될 필요가 없으며, 이는 본 기술 분야의 당업자 및 당 업계의 전문가에게 있어서 매우 놀랍고 예기치 않은 결과이다.도면 도면1a 도면1b 도면2 도면3 도면4 도면5 도면6 도면7 도면8"}
{"patent_id": "10-2018-7024664", "section": "도면", "subsection": "도면설명", "item": 1, "content": "다음 도면은 예시적인 예이며, 최종적으로 발행될 수 있는 청구 범위를 더 제한하지 않는다. 도 1a는 종래의 컴파일러에 대한 종래 기술의 흐름도를 도시한다. 도 1b는 종래의 컴퓨터에 대한 종래 기술의 프로세서를 도시한다. 도 2는 미국 특허 제5,684,980호의 블록도를 도시한다. 도 3은 도 1a의 흐름도와 비교하기 위한 AMPC 컴파일러의 예를 도시하는 흐름도이다.도 4는 IC AT 아키텍처의 일 예이다. 도 5는 프로그래머가 어떻게 AMPC를 사용할 수 있는지의 일 예의 흐름도를 도시한다. 도 6은 재사용 가능한 알고리즘 파이프라인 컴퓨터의 개략적인 예이다. 도 7은 AMPC 컴파일러를 갖는 코드 예시 1의 컴파일로부터 생성된 하드웨어 구성의 개략도를 도시한다. 도 8은 소비자 전자 디바이스에서 실시간 무손실 데이터 압축에 의한 도 7의 예의 원시 처리 능력의 극적인 이 점을 도시한다. 동일한 참조 문자가 사용되는 경우, 이들 라벨은 도면에 도시된 예에서 유사한 부분을 지칭한다."}
