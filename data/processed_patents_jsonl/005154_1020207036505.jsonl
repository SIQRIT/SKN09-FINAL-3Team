{"patent_id": "10-2020-7036505", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0002743", "출원번호": "10-2020-7036505", "발명의 명칭": "데이터 처리방법과 장치 및 관련 제품", "출원인": "캠브리콘 테크놀로지스 코퍼레이션 리미티드", "발명자": "리우 사올리"}}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "데이터 처리 방법으로서, 디코딩된 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에따라 상기 제1 처리 명령의 실행 가능 여부를 판단하는 단계 - 상기 디스크립터는 텐서의 형상을 지시함 - ; 및 상기 제1 처리 명령이 실행 가능한 경우, 상기 디스크립터의 식별자에 따라 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계를 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 디스크립터의 식별자에 따라 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계는, 상기 디스크립터의 식별자에 따라 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하는 단계; 상기 디스크립터의 콘텐츠에 따라, 상기 피연산자에 대응되는 데이터의 데이터 저장공간 중에서의 데이터 어드레스를 결정하는 단계; 및 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계를 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 디스크립터의 식별자에 따라 상기 제1 처리 명령의 실행 가능 여부를 판단하는 단계는, 상기 디스크립터의 식별자에 따라 처리가 완료되지 않은 제2 처리 명령이 존재하는지 여부를 판단하여, 상기 제2 처리 명령은 명령 큐 중 상기 제1 처리 명령 이전의 처리 명령을 포함하고, 피연산자에 상기 디스크립터의 식별자의 처리 명령이 구비되는 단계; 및 제2 처리 명령이 존재하지 않는 경우, 상기 제1 처리 명령이 실행 가능한 것으로 결정하는 단계를 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 제1 처리 명령과 상기 제2 처리 명령 중의 적어도 하나는 상기 디스크립터에 대한 쓰기 연산을 포함하는것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포함하되, 상기 디스크립터의 식별자에 따라 상기 제1 처리 명령의 실행 가능 여부를 판단하는 단계는, 상기 적어도 하나의 디스크립터의 식별자에 따라, 각 디스크립터의 제1 상태를 각각 결정하고, 상기 제1 상태는등록 상태 또는 미등록 상태를 포함하는 단계; 및 각 디스크립터의 제1 상태가 모두 등록 상태인 경우, 상기 제1 처리 명령이 실행 가능한 것으로 결정하는 단계공개특허 10-2021-0002743-3-를 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포함하되, 상기 디스크립터의 식별자에 따라 상기 제1 처리 명령의 실행 가능 여부를 판단하는 단계는, 상기 적어도 하나의 디스크립터의 식별자에 따라, 각 디스크립터의 제2 상태를 각각 결정하고, 상기 제2 상태는연산 가능 상태 또는 연산 불가 상태를 포함하는 단계; 및 각 디스크립터의 제2 상태가 모두 연산 가능 상태인 경우, 상기 제1 처리 명령이 실행 가능한 것으로 결정하는단계를 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서, 상기 제1 처리 명령이 디스크립터 취소 명령인 경우, 상기 제1 처리 명령 중 디스크립터의 식별자에 따라, 처리가 완료되지 않은 제4 처리 명령이 존재하는 여부를 판단하는 단계 - 상기 제4 처리 명령은 명령 큐 중에서 피연산자에 상기 디스크립터의 식별자를 포함하는 처리 명령임 - ; 및 처리가 완료되지 않은 제4 처리 명령이 존재하지 않을 경우, 상기 제1 처리 명령을 실행하는 단계를 더 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 상기 제1 처리 명령이 디스크립터 등록 명령인 경우, 상기 제1 처리 명령 중 상기 디스크립터의 식별자, 텐서형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나를 포함하는 디스크립터의 등록 파라미터를 획득하는 단계; 상기 디스크립터의 등록 파라미터에 따라, 상기 제1 처리 명령이 실행 가능한 여부를 판단하는 단계; 및 상기 제1 처리 명령이 실행 가능한 경우, 상기 제1 처리 명령을 실행하는 단계를 더 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서, 상기 디스크립터의 등록 파라미터에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하는 단계는, 상기 디스크립터의 식별자가 점용되지 않은 경우, 상기 디스크립터의 콘텐츠를 저장하는 제1 저장영역이 점용되지 않은 경우, 또는 상기 디스크립터가 지시하는 텐서 데이터를 저장하는 제2 저장영역이 점용되지 않은 경우중의 적어도 하나를 만족시키는 경우, 상기 제1 처리 명령이 실행 가능한 것으로 결정하는 단계를 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1항 내지 제9항 중 어느 한 항에 있어서, 상기 제1 처리 명령을 실행할 수 없는 경우, 상기 제1 처리 명령을 차단하거나 또는 캐시하는 단계를 더 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "공개특허 10-2021-0002743-4-제1항에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것이고, N은 0 이상의 정수이며, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되며, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 더 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 상기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함하며, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향 중 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향 중 적어도 한 방향상에서의 상기 텐서 데이터 저장영역의 크기, N개 차원 방향 중 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 차원방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함하는 것을 특징으로 하는 데이터 처리 방법."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "데이터 처리 장치로서,디코딩된 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에따라 상기 제1 처리 명령의 실행 가능 여부를 판단하기 위한 판단모듈 - 상기 디스크립터는 텐서의 형상을 지시하기 위한 것임 - ; 및 상기 제1 처리 명령이 실행 가능한 경우, 상기 디스크립터의 식별자에 따라 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하기 위한 실행모듈을 포함하는 것을 특징으로 하는 데이터 처리 장치."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 따른 데이터 처리장치를 포함하는 것을 특징으로 하는 인공지능 칩."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 따른 인공지능 칩을 포함하는 것을 특징으로 하는 전자 장치."}
{"patent_id": "10-2020-7036505", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "메모리 소자, 인터페이스 장치와 제어 소자 및 제15항에 따른 인공지능 칩을 포함하는 보드로서, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터링하기 위한 것을 특징으로 하는 보드. 공개특허 10-2021-0002743-5-"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 데이터 처리방법과 장치 및 관련 제품에 관한 것으로서, 방법은 디코딩 후의 제1 처리 명령의 피연산 자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 디스크립터의 식별자에 따라 디 스크립터의 콘텐츠를 획득하는 단계(S11a)와, 디스크립터의 콘텐츠에 따라, 제1 처리 명령을 실행하는 단계 (S12a)를 포함한다. 이상의 방법을 통해, 본 발명은 관련 제품이 신경망 모델의 연산을 수행 시의 연산 효율을 향상시킬 수 있다."}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 컴퓨터 기술 분야에 관한 것으로서, 특히 데이터 처리방법과 장치 및 관련 제품에 관한 것이다."}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능 기술이 지속적으로 발전함에 따라, 응용분야가 갈수록 광범위해졌으며, 이미지 인식, 음성 인식, 자연 어 처리 등 분야에서 모두 활발하게 응용되고 있다. 그러나 인공지능 알고리즘의 복잡도가 높아지면서, 처리해 야 할 데이터량과 데이터 차원이 지속적으로 증가하고 있다. 관련 기술 중, 프로세서는 통상적으로 명령 파라미 터를 통해 데이터 어드레스를 결정한 후, 데이터 어드레스에 따라 데이터의 독취와 사용을 완수한다. 이는 기술 자가 파라미터를 설계 시 데이터 액세스의 관련 파라미터(예를 들어 데이터 간 또는 데이터 차원 간의 상호관계 등)를 설정하여, 명령을 생성하고 프로세서로 전달하여 데이터의 액세스를 완수하도록 요구하며, 상기 방식은 프로세서의 처리 효율을 저하시킨다."}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "이를 감안하여, 본 발명은 데이터 처리 기술방안을 제시한다."}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 일 측면에 따르면, 디코딩 후의 제1 처리 명령의 피연산자(operand)에 텐서(tensor)의 형상을 지시하 기 위한 디스크립터(descriptor)의 식별자가 포함되어 있을 경우, 상기 디스크립터의 식별자에 따라 상기 디스 크립터의 콘텐츠를 획득하고; 상기 디스크립터의 콘텐츠에 따라 상기 제1 처리 명령을 실행하는 데이터 처리방 법을 제공한다. 본 발명의 다른 일 측면에 따르면, 디코딩 후의 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스 크립터의 식별자가 포함되어 있을 경우, 상기 디스크립터의 식별자에 따라 상기 디스크립터의 콘텐츠를 획득하 는 콘텐츠 획득 모듈; 상기 디스크립터의 콘텐츠에 따라 상기 제1 처리 명령을 실행하기 위한 명령 실행 모듈을 포함하는 데이터 처리장치를 제공한다. 본 발명의 다른 일 측면에 따르면, 상기 데이터 처리장치를 포함하는 신경망 칩을 제공한다. 본 발명의 다른 일 측면에 따르면, 상기 신경망 칩을 포함하는 전자장치를 제공한다. 본 발명의 다른 일 측면에 따르면, 메모리 소자, 인터페이스 장치와 제어 소자 및 상기 신경망 칩을 포함하는 보드를 포함하며, 그 중, 상기 신경망 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 신경망 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 신경망 칩의 상태를 모니터링하기 위한 것이다."}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 실시예에 따르면, 텐서 형상을 지시하기 위한 디스크립터의 도입을 통해, 디코딩 처리 명령의 피연산 자에 디스크립터 식별자가 포함되어 있는 경우, 대응되는 디스크립터의 콘텐츠를 결정하고, 디스크립터 콘텐츠 에 따라 상기 처리 명령을 실행시킬 수 있어, 데이터 액세스의 복잡도가 감소하고, 데이터 액세스 효율이 향상 된다. 이하 도면을 참고하여 예시적인 실시예에 대해 상세하게 설명함으로써, 본 발명의 기타 특징 및 측면이 명확해 질 것이다."}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하 첨부도면을 참조하여 본 발명의 각종 예시적인 실시예, 특징 및 방면에 대해 상세히 설명할 것이다. 첨부 도면 중 동일한 부호는 기능이 동일하거나 또는 유사한 소자를 표시한다. 비록 첨부도면에서 실시예의 각 측면 을 도시하였으나, 특별히 언급하지 않는 한, 비율대로 도면을 제작할 필요는 없다. 여기에 전문적으로 사용되는 \"예시적\"이라는 용어의 의미는 \"예시, 실시예 또는 설명성\"으로 사용되는 것을 뜻 한다. 여기서 \"예시적\"으로 설명되는 모든 실시예는 다른 실시예보다 뛰어나거나 또는 양호한 것으로 해석할 필 요는 없다. 또한, 본 발명을 보다 확실히 설명하기 위하여, 아래의 구체적인 실시방식에서는 다양한 구체적인 세부 내용을 제공한다. 당업자라면 모종의 구체적인 내용이 없더라도, 본 발명을 마찬가지로 실시할 수 있음을 이해하여야 한다. 일부 실시예에서, 본 발명의 요지가 두드러질 수 있도록 당업자가 숙지하는 방법, 수단, 소자 및 회로에 대해서는 상세한 묘사를 하지 않는다. 본 발명의 실시예에 따르면, 데이터 처리방법을 제공한다. 도 1a는 본 발명의 실시예에 따른 데이터 처리방법의 흐름도이다. 도 1a에 도시된 바와 같이, 상기 데이터 처리방법은 이하 단계를 포함한다:단계 S11a에서, 디코딩 후의 제1 처리 명령의 피연산자(operand)에 텐서(tensor)의 형상을 지시하기 위한 디스 크립터(discriptor)의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라 상기 디스크립터의 콘텐 츠를 획득한다. 단계 S12a에서, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령을 실행한다. 본 발명의 실시예에 따르면, 텐서 형상을 지시하는 디스크립터의 도입을 통해, 디코딩된 처리 명령의 피연산자 에 디스크립터 식별자가 포함된 경우, 대응되는 디스크립터의 콘텐츠를 결정하고, 디스크립터의 콘텐츠에 따라 상기 처리 명령을 실행시킬 수 있어, 데이터 액세스의 복잡도가 감소하고 데이터 액세스의 효율이 향상된다. 예를 들어 설명하면, 상기 데이터 처리방법은 프로세서에 응용될 수 있으며, 상기 프로세서는 범용 프로세서(예 를 들어 중앙처리장치(CPU), 그래픽 프로세서(GPU))와 전용 프로세서(예를 들어 인공지능 프로세서, 공학용 컴 퓨터 프로세서 또는 디지털 신호 프로세서 등)를 포함할 수 있다. 본 발명은 프로세서의 유형에 대해서는 제한 을 두지 않는다. 일종의 가능한 구현 방식에서, 처리할 데이터는 N차원의 텐서 데이터(N은 0 이상의 정수이며, 예를 들어 N=1, 2 또는 3이다)를 포함할 수 있으며, 그 중 텐서는 다양한 형식의 데이터 구성 방식을 포함할 수 있고, 텐서는 상 이한 차원일 수 있다. 예를 들어 스칼라(scalar)는 0차원의 텐서로 간주할 수 있고, 벡터는 1차원의 텐서로 간 주할 수 있으며, 매트릭스는 2차원 또는 2차원 이상의 텐서일 수 있다. 텐서의 형상은 텐서의 차원, 텐서 각 차 원의 크기 등 정보를 포함한다. 예를 들어 설명하면, 텐서의 경우: 이며, 상기 텐서의 형상은 디스크립터에 의해 (2,4)로 기술된다. 즉 2개의 파라미터를 통해 상기 텐서가 2차원 텐서임 을 나타내며, 또한 상기 텐서의 제1 차원(열)의 크기는 2이고, 제2 차원(행)의 크기는 4이다. 설명해두어야 할 점으로, 본 출원은 디스크립터가 텐서의 형상을 지시하는 방식에 대해서는 한정하지 않는다. 메모리에 텐서 데 이터를 저장 시, 그 데이터 어드레스(또는 저장영역)로는 텐서 데이터의 형상을 결정할 수 없고, 나아가 다수의 텐서 데이터 간의 상호관계 등 관련 정보를 결정할 수도 없어, 텐서 데이터에 대한 프로세서의 액세스 효율이 저하된다. 이러한 경우, 디스크립터(텐서 디스크립터)의 도입을 통해 텐서(N차원의 텐서 데이터)의 형상을 지시할 수 있다. 그 중, N의 취득값은 텐서 데이터의 차원수(급수)에 따라 결정할 수도 있고, 텐서 데이터의 사용 필요에 따라 설정할 수도 있다. 예를 들어, n의 취득값이 3일 때, 텐서 데이터는 3차원의 텐서 데이터이며, 디스크립터 는 상기 3차원 텐서 데이터의 3개 차원 방향상의 형상(예를 들어 오프셋, 크기 등)을 지시하는데 사용될 수 있 다. 이해해두어야 할 점으로, 당업자라면 실제 필요에 따라 N의 취득값을 설정할 수 있으며, 본 발명은 이에 대 해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터는 디스크립터를 번호와 같이 구분하는 식별자와; 텐서 데이터의 형상 의 적어도 하나의 형상(예를 들어 텐서의 각 차원 방향상의 크기 등)을 표시하는 콘텐츠 등을 포함할 수 있으며, 텐서 데이터의 어드레스를 표시하는 적어도 하나의 어드레스 파라미터(예를 들어 데이터 기준점의 기준 어드레스)를 더 포함할 수도 있다. 디스크립터를 이용하여 텐서 데이터를 지시하는 방식을 통해, 텐서 데이터의 형상을 표현할 수 있고, 나아가 다 수의 텐서 데이터 간의 상호관계 등 관련 정보를 결정할 수 있어, 텐서 데이터에 대한 액세스 효율이 향상된다. 일종의 가능한 구현 방식에서, 처리 명령을 수신 시, 먼저 처리 명령에 대해 디코딩(디사이퍼링)을 수행할 수 있다. 그 중, 상기 방법은 수신된 제1 처리 명령에 대해 디코딩 처리를 수행하여 디코딩 후의 제1 처리 명령을 획득하는 단계를 더 포함하며, 그 중, 디코딩 후의 제1 처리 명령은 상기 제1 처리 명령에 대응되는 처리 유형을 지시하기 위한 연산코드 (operation code) 및 하나 또는 다수의 피연산자를 포함한다. 이러한 경우, 제1 처리 명령이 디코딩을 거친 후, 디코딩 후의 제1 처리 명령(마이크로 코드)을 획득할 수 있다. 제1 처리 명령은 데이터 액세스 명령, 연산 명령, 디스크립터 관리 명령 및 동기화 명령 등을 포함할 수 있다. 본 발명은 제1 처리 명령의 구체적인 유형 및 디코딩의 구체적인 방식에 대해서는 제한을 두지 않는다. 상기 디코딩 후의 제1 처리 명령은 제1 처리 명령에 대응하는 처리 유형을 지시하기 위한 연산코드 및 처리할 데이터를 지시하기 위한 하나 또는 다수의 피연산자를 포함할 수 있다. 예를 들어, 상기 명령은 Add; A; B를 표 시할 수 있으며, 그 중 Add는 연산코드이고, A와 B는 피연산자며, 상기 명령은 A와 B를 더하기 위한 것이다. 본 발명은 디코딩 후의 명령의 피연산자의 수량 및 명령의 표시 형식에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디코딩 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함된 경우, 상기 디스크립터의 식별자를 통해 디스크립터에 대응되는 디스크립터 저장공간을 결정할 수 있고, 디스크립터 저장공간으로부터 디스크립터의 콘텐츠(텐서 데이터의 형상, 어드레스 등을 특징화하는 정보 포함)을 획득할 수 있으며; 이후, 디스크립터의 콘텐츠에 따라 제1 처리 명령을 실행할 수 있다. 일종의 가능한 구현 방식에서, 단계 S12a는, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응하는 데이터의 데이터 저장공간 중에 서의 데이터 어드레스를 결정하는 단계; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행시키는 단계를 포함할 수 있 다. 예를 들어 설명하면, 디스크립터의 콘텐츠에 따라, 제1 처리 명령 중 디스크립터 식별자가 포함된 피연산자에 대응되는 데이터의 데이터 저장공간 중에서의 데이터 어드레스를 계산할 수 있으며, 나아가 상기 데이터 어드레 스에 따라 상응하는 처리를 실행할 수 있다. 예를 들어, 명령 Add; A; B의 경우, 만약 피연산자 A와 B 중 각각 디스크립터의 식별자 TR1과 TR2가 포함되어 있다면, 즉 프로세서는 디스크립터의 식별자 TR1과 TR2에 따라 각각 TR1과 TR2에 대응되는 디스크립터 저장공간을 결정하고, 디스크립터 저장공간 중의 콘텐츠(예를 들어 형상 파라 미터와 어드레스 파라미터)을 독취하며; 디스크립터의 콘텐츠에 따라 데이터 A와 B의 데이터 어드레스를 계산할 수 있다. 예를 들어 A의 메모리 중에서의 데이터 어드레스 1은 ADDR64-ADDR127이고, B의 메모리 중에서의 데이 터 어드레스 2는 ADDR1023-AADR1087이다. 이후, 프로세서는 어드레스 1과 어드레스 2에서 각각 데이터를 독취하 고, 가법(Add) 연산을 실행하여 연산 결과(A+B)를 획득할 수 있다. 일종의 가능한 구현 방식에서, 본 발명의 실시예에 따른 방법은 관련 기술의 하드웨어 구조를 통해 구현될 수 있다. 이러한 경우, 상기 방법을 응용하는 프로세서는 메모리 또는 외부에서 입력되는 명령을 독취하여, 명령에 대해 디코딩(디사이퍼링)을 수행하고, 상응하는 부재로 마이크로 코드 제어 신호를 송출하는 등의 제어를 수행 하기 위한 제어유닛 및 구체적인 명령을 실행하기 위한 실행유닛을 포함할 수 있으며, 실행유닛은 예를 들어 산 술 논리 유닛(arithmetic and logic unit, ALU), 메모리 액세스 유닛(memory access unit, MAU), 인공지능 연 산 유닛(neural funcional unit, NFU) 등일 수 있다. 본 발명은 실행유닛의 구체적인 하드웨어 유형에 대해서는 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제어유닛을 통해 명령에 대해 디코딩을 수행하여 디코딩 후의 제1 처리 명령을 획득할 수 있으며; 디코딩 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 즉 제 어유닛은 디스크립터에 대응되는 디스크립터 저장공간을 결정하고, 디스크립터 저장공간으로부터 디스크립터의 콘텐츠(형상, 어드레스 등 정보)을 획득할 수 있으며; 이후, 제어유닛이 디스크립터의 콘텐츠 및 제1 처리 명령 을 실행유닛으로 전송하면, 실행유닛이 디스크립터의 콘텐츠에 따라 제1 처리 명령을 실행한다. 실행유닛이 디 스크립터의 콘텐츠 및 제1 처리 명령을 수신 시, 디스크립터의 콘텐츠에 따라, 제1 처리 명령 중 디스크립터 식 별자가 포함된 피연산자에 대응되는 데이터의 데이터 저장공간 중에서의 데이터 어드레스를 계산하고, 나아가 상기 데이터 어드레스에 따라 대응하는 처리를 실행할 수 있다. 예를 들어, 명령 Add; A; B에 대하여, 만약 피연산자 A와 B 중 각각 디스크립터의 식별자 TR1과 TR2가 포함되어 있다면, 즉 제어유닛은 TR1과 TR2에 대응되는 디스크립터 저장공간을 결정하고, 디스크립터 저장공간 중의 콘텐 츠(예를 들어 형상 파라미터와 어드레스 파라미터)을 독취하여 이를 실행유닛으로 전송한다. 실행유닛은 디스크 립터의 콘텐츠를 수신한 후, 데이터 A와 B의 데이터 어드레스를 계산할 수 있으며, 예를 들어 A의 메모리 중에 서의 데이터 어드레스 1은 ADDR64-ADDR127이고, B의 메모리 중에서의 데이터 어드레스 2는 ADDR1023- AADR1087이다. 이후, 실행유닛은 어드레스 1과 어드레스 2에서 각각 데이터를 독취하고, 가법(Add) 연산을 실행 하여 연산 결과(A+B)를 획득할 수 있다. 일종의 가능한 구현 방식에서, 관련 기술의 하드웨어 구조에 대한 개선을 통해, 본 발명의 실시예의 방법을 구 현할 수 있다. 예를 들어, 제어유닛에 텐서 제어모듈을 설치하여 디스크립터와 관련된 연산, 예를 들어 디스크 립터의 등록(log on), 수정 및 취소(log off); 디스크립터 콘텐츠에 대한 읽기 쓰기를 구현할 수 있다. 텐서 제 어모듈은 예를 들어 텐서 인터페이스 유닛(Tensor interface Unit，TIU)일 수 있으며, 본 발명은 텐서 제어모듈의 구체적인 하드웨어 유형에 대해서는 제한을 두지 않는다. 이러한 방식을 통해, 전용 하드웨어로 디스크립터 와 관련된 연산을 구현할 수 있어, 텐서 데이터의 액세스 효율이 더욱 향상된다. 이러한 경우, 제어유닛이 디코딩한 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있다면, 즉 텐서 제어모듈을 통해 디스크립터에 대응되는 디스크립터 저장공간을 결정할 수 있고; 디스크립터 저장공간 을 결정한 후, 디스크립터 저장공간으로부터 디스크립터의 콘텐츠(형상, 어드레스 등 정보)을 획득할 수 있다. 이후, 제어유닛은 실행유닛이 디스크립터의 콘텐츠에 따라 제1 처리 명령을 실행하도록 디스크립터의 콘텐츠 및 제1 처리 명령을 실행유닛으로 전송한다. 일종의 가능한 구현 방식에서, 텐서 제어모듈은 디스크립터와 관련된 연산 및 명령의 실행, 예를 들어 디스크립 터의 등록, 수정 및 취소; 디스크립터 콘텐츠에 대한 읽기 쓰기; 데이터 어드레스의 계산 및 데이터 액세스 명 령의 실행 등을 더 구현할 수 있다. 이러한 경우, 제어유닛이 디코딩한 후의 제1 처리 명령의 피연산자에 디스 크립터의 식별자가 포함되어 있다면, 즉 텐서 제어모듈을 통해 디스크립터에 대응되는 디스크립터 저장공간을 결정할 수 있으며; 디스크립터의 저장공간을 결정한 후, 디스크립터 저장공간으로부터 디스크립터의 콘텐츠를 획득할 수 있고; 디스크립터의 콘텐츠에 따라, 텐서 제어모듈을 통해 제1 처리 명령의 피연산자에 대응되는 데 이터의 데이터 저장공간 중에서의 데이터 어드레스를 결정하고; 데이터 어드레스에 따라, 텐서 제어모듈을 통해 상기 제1 처리 명령에 대응되는 데이터 처리를 실행할 수 있다. 본 발명은 본 발명의 실시예를 구현하는 방법에서 사용되는 구체적인 하드웨어 구조에 대해 제한을 두지 않는다. 이러한 방식을 통해, 디스크립터 저장공간으로부터 디스크립터의 콘텐츠를 획득하고, 나아가 데이터 어드레스를 획득할 수 있어, 매번 액세스할 때마다 명령을 통해 어드레스를 입력할 필요가 없어 프로세서의 데이터 액세스 효율이 향상된다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자와 콘텐츠는 디스크립터 저장공간에 저장될 수 있다. 상기 디스크립터 저장공간은 제어유닛의 내부 메모리(예를 들어 레지스터, 온칩 SRAM 또는 기타 매체의 캐시(cache) 등) 중의 저장공간일 수 있다. 디스크립터가 지시하는 텐서 데이터의 데이터 저장공간은 제어유닛의 내부 메모 리(예를 들어 온칩 캐시) 또는 제어유닛과 연결되는 외부 메모리(오프칩 메모리) 중의 저장공간일 수 있다. 데 이터 저장공간 중의 데이터 어드레스는 실제의 물리 어드레스 또는 가상 어드레스일 수 있다. 본 발명은 디스크 립터 저장공간 및 데이터 저장공간의 위치와 데이터 어드레스의 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 동일한 영역에 위치할 수 있다. 예를 들어, 온칩 캐시의 연속되는 영역을 사용하여 디스크립터의 관련 콘텐츠를 저장할 수 있으며, 그 어드레스는 ADDR0-ADDR1023이다. 그 중, 어드레스 ADDR0-ADDR31은 디스크립터의 식별자를 저장하 기 위한 것이고, 어드레스 ADDR32-ADDR63은 디스크립터의 콘텐츠를 저장하기 위한 것이며, 어드레스 은 디스크 립터가 지시하는 텐서 데이터를 저장하기 위한 것일 수 있다. 그 중, 어드레스 ADDR은 1비트 또는 하나의 바이 트로 한정되지 않으며, 여기서는 하나의 어드레스를 표시하기 위한 하나의 어드레스 단위이다. 당업자라면 실제 상황에 따라 저장영역 및 그 어드레스를 결정할 수 있을 것이며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 내부 메 모리의 상이한 영역에 각각 저장될 수 있으며, 예를 들어 레지스터를 디스크립터 저장공간으로 하여, 레지스터 에 디스크립터의 식별자와 콘텐츠를 저장할 수 있고, 온칩 캐시를 데이터 저장공간으로 하여 디스크립터가 지시 하는 텐서 데이터를 저장할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터에 전문적으로 사용되는 전용 레지스터(SR)를 설치할 수도 있으며, 디 스크립터 중의 데이터는 즉치(immediate)일 수도 있고 전용 레지스트로부터 획득될 수도 있다. 레지스터를 사용 하여 디스크립터의 식별자와 콘텐츠를 저장 시, 레지스터의 번호를 사용하여 디스크립터의 식별자를 표시할 수 있다. 예를 들어 레지스터의 번호가 0일 때, 저장되는 디스크립터의 식별자는 0이다. 레지스터 중의 디스크립터 가 유효할 때, 디스크립터가 지시하는 텐서 데이터의 크기에 따라 캐시 공간에 하나의 영역(예를 들어 캐시 중 각 텐서 데이터마다 텐서 캐시유닛을 생성한다)을 할당하여 상기 텐서 데이터를 저장할 수 있다. 이해해두어야 할 점으로, 미리 설치된 캐시공간을 사용하여 상기 텐서 데이터를 저장할 수도 있으며, 본 발명은 이에 대해 제 한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자 및 콘텐츠는 내부 메모리에 저장될 수 있고, 디스크립터가 지시하는 텐서 데이터는 외부 메모리에 저장될 수 있다. 예를 들어, 디스크립터의 식별자 및 콘텐츠는 온칩 저장하고, 디스크립터가 지시하는 텐서 데이터는 오프칩 저장하는 방식을 채택할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터에 대응되는 데이터 저장공간의 데이터 어드레스는 고정 어드레스일 수 있다. 예를 들어 텐서 데이터를 위해 별도의 데이터 저장공간을 분할할 수 있으며, 각 텐서 데이터의 데이터 저장공간에서의 시작 어드레스는 디스크립터의 식별자와 일일이 대응될 수 있다. 이 경우, 실행유닛은 디스크립 터의 콘텐츠에 따라 피연산자에 대응되는 데이터의 데이터 어드레스를 즉시 결정한 후, 제1 처리 명령을 실행할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자에 대응되는 데이터 저장공간의 데이터 어드레스가 가변 어 드레스일 때, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용될 수 있으며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 더 포함할 수 있다. 예를 들어, 텐서 데이터가 3차원 데이터이고, 디스크립터가 상기 텐서 데이터의 어드레스를 지향하는 경우, 디스크립터의 콘텐츠는 상기 텐서 데이터의 어드레스를 나타내는 하나의 어드레스 파라미터, 예를 들어 텐서 데이터의 시작 어드레스를 포함할 수 있고, 상기 텐서 데이터의 어드레스 중 다수의 어드레스 파라미터, 예를 들어 텐서 데이터의 시작 어드레스+어드레스 오프셋을 포함할 수도 있으며, 또는 텐서 데이터는 각 차원의 어드레스 파라미터를 바탕으로 한다. 당업자라면 실제 필요에 따라 어드레스 파라미터를 설정할 수 있을 것이므 로, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 상 기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함한다. 그 중, 기준 어드레스는 데이터 기준점 의 변화에 따라 달라진다. 본 발명은 데이터 기준점의 선택에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 기준 어드레스는 상기 데이터 저장공간의 시작 어드레스를 포함할 수 있다. 디스크립터의 데이터 기준점이 데이터 저장공간의 첫 번째 데이터블록일 때, 디스크립터의 기준 어드레스는 즉 데이터 저장공간의 시작 어드레스이다. 디스크립터의 데이터 기준점이 데이터 저장공간 중 첫 번째 데이터블록 이외의 다른 데이터인 경우, 디스크립터의 기준 어드레스는 즉 상기 데이터블록의 데이터 저장공간 중에서의 물 리 어드레스이다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 크기, N개의 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개의 차원 방향의 대각 위치에 놓이는 적 어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크 립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. 그 중, 데이터 디스크립션 위치는 디스크립터가 지시하는 텐서 데이터 중의 점 또는 영역의 매핑 위치이며, 예를 들어 텐서 데이터가 3차원 데이 터일 때, 디스크립터는 3차원 공간 좌표(x, y, z)를 사용하여 상기 텐서 데이터의 형상을 표시할 수 있다. 상기 텐서 데이터의 데이터 디스크립션 위치는 3차원 공간 좌표(x, y, z)로 표시될 수 있으며, 상기 텐서 데이터는 3 차원 공간 중의 점 또는 영역의 위치에 매핑된다. 이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 텐서 데이터를 나타내는 형상 파라미터를 선택할 수 있 으며, 본 발명은 이에 대해 제한을 두지 않는다. 도 2는 본 발명의 일 실시예에 따른 데이터 저장공간의 설명도이다. 도 2에 도시된 바와 같이, 데이터 저장공간 은 우선적인 방식으로 2차원 데이터가 저장되며, (x, y)를 통해 표시한다(그 중, X축은 수평으로 우측을 향 하고, Y축은 수직으로 아래를 향한다). X축 방향상의 크기(매 행의 크기)는 ori_x이고(미도시), Y 축의 방향상 의 크기(총 행수)는 ori_y이며(미도시), 데이터 저장공간의 시작 어드레스 PA_start(기준 어드레스)는 첫 번째 데이터블록의 물리 어드레스이다. 데이터블록은 데이터 저장공간 중의 일부 데이터로서, 그것 의 X축 방향상의 오프셋은 offset_x로 표시하고, Y축 방향상의 오프셋은 offset_y로 표시하며, X축 방 향상의 크기는 size_x로 표시하고, Y축 방향상의 크기는 size_y로 표시한다. 일종의 가능한 구현 방식에서, 디스크립터를 사용하여 데이터블록을 정의 시, 디스크립터의 데이터 기준점 은 데이터 저장공간의 첫 번째 데이터블록을 사용할 수 있으며, 디스크립터의 기준 어드레스는 데이터 저장 공간의 시작 어드레스(PA_start)이다. 이후 데이터 저장공간의 X축상에서의 크기(ori_x), Y축 상에서의 크기(ori_y), 및 데이터블록의 Y축 방향상의 오프셋(offset_y), X축 방향상의 오프셋(offset_x), X축 방향 상의 크기(size_x) 및 Y축 방향상의 크기(size_y)를 결합하여 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있다.일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "이해하여야 할 점으로, 비록 상기 예시에서, 디스크립터가 설명하는 것은 이차원 공간이나, 당업자라면 실제 상 황에 따라 디스크립터의 콘텐츠가 나타내는 차원을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현방식에서, 상기 디스크립터의 데이터 기준점의 상기 데이터 저장공간 중에서의 기준 어드레 스, N개 차원 방향의 대각 위치에 놓이는 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치에 따라, 상기 텐서 데이터의 디스크립터의 콘텐츠를 결정할 수 있다. 예를 들어 설명하면, 디스크립터의 데이터 기준점의 데이터 저장공간 중에서 의 기준 어드레스(PA_base), 및 대 각 위치의 2개의 꼭지점의 데이터 기준점에 대한 위치를 사용하여, 도 2 중 데이터블록의 디스크립터의 콘 텐츠를 결정할 수 있다. 먼저, 디스크립터의 데이터 기준점 및 그것의 데이터 저장공간 중에서의 기준 어드레스 (PA_base)를 결정한다. 예를 들어, 데이터 저장공간에서 하나의 데이터(예를 들어 위치가 (2,2)인 데이터) 를 선택하여 데이터 기준점으로 삼고, 데이터 저장공간 중에서 상기 데이터의 물리 어드레스를 기준 어드레스 (PA_base)로 삼은 다음; 데이터블록의 대각 위치의 적어도 2개의 꼭지점의 데이터 기준점에 대한 위치를 결 정한다. 예를 들어 좌상으로부터 우하 방향인 대각 위치의 꼭지점의 데이터 기준점에 대한 위치를 사용하며, 그 중 좌상각 꼭지점의 상대위치는 (x_min，y_min)이고, 우하각 꼭지점의 상대 위치는 (x_max，y_max)이다. 이후 기준 어드레스(PA_base), 좌상각 꼭지점의 상대 위치(x_min，y_min) 및 우하각 꼭지점의 상대 위치(x_max， y_max)에 따라 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 를 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "이해해두어야 할 점으로, 비록 상기 예시에서 좌상각과 우하각 2개의 꼭지점을 사용하여 디스크립터의 콘텐츠를 결정하였으나, 당업자라면 실제 필요에 따라 적어도 2개의 꼭지점 중 구체적인 꼭지점을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 디스크립터의 데이터 기준점의 상기 데이터 저장공간 중에서의 기준 어드레 스, 및 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 에 따라, 상기 텐서 데이터의 디스크립터의 콘텐츠를 결정할 수 있다. 그 중, 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계는 실제 필요에 따라 설정할 수 있으며, 예를 들어, 디스크립터가 지시하는 텐서 데이 터가 3차원 공간 데이터인 경우, 함수 를 사용하여 데이터 디스크립션 위치와 데이터 어드레스 간의 매 핑 관계를 정의할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계를 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 공식 로 디스크립터의 콘텐츠를 나타내는 경우, 텐서 데이터 중의 어느 하나의 데이터점에 대해, 그 데이터 디스크립션 위치를 라 설정한다면, 상기 데이터 저장공간 중에서 상기 데이터점의 데이터 어드레스 ( )는 하기 공식 를 사용하여 결정할 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "이러한 방식을 통해, 실행유닛은 디스크립터의 콘텐츠에 따라 디스크립터가 지시하는 텐서 데이터의 데이터 저 장공간 중에서의 데이터 어드레스를 계산할 수 있으며, 나아가 상기 어드레스에 따라 처리 명령에 대응되는 처 리를 실행할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 관리 명령을 통해 디스크립터의 등록, 수정 및 취소 등의 관리를 구현하고, 이러한 관리 명령에 상응하는 연산코드(operation code)를 설정할 수 있다. 예를 들어 디스크립터 등 록 명령(TRCreat)를 통해 디스크립터를 등록(생성)하고; 디스크립터 수정 명령을 통해 디스크립터의 각 파라미 터(형상, 어드레스 등)를 수정하며; 디스크립터 취소 명령(TRRelease)를 통해 디스크립터를 취소(삭제)하는 등 을 포함한다. 본 발명은 디스크립터의 관리 명령의 종류 및 연산코드의 구체적인 설정에 대해 제한을 두지 않는 다. 일종의 가능한 구현 방식에서, 상기 방법은 상기 제1 처리 명령이 디스크립터 등록 명령인 경우, 상기 제1 처리 명령 중 상기 디스크립터의 식별자, 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나인 디스크립터의 등록 파라미터를 획득 하는 단계; 상기 디스크립터의 등록 파라미터에 따라, 디스크립터 저장공간 중에서 상기 디스크립터 콘텐츠의 제1 저장영역, 및 상기 데이터 저장공간 중에서 상기 디스크립터가 지시하는 텐서 데이터 콘텐츠의 제2 저장영역을 결정하는 단계; 상기 디스크립터의 등록 파라미터 및 상기 제2 저장영역에 따라, 상기 디스크립터의 콘텐츠를 결정하여, 상기 디스크립터와 상기 제2 저장영역 간의 대응관계를 구축하는 단계; 상기 디스크립터의 콘텐츠를 상기 제1 저장영역에 저장하는 단계를 더 포함한다. 예를 들어 설명하면, 디스크립터 등록 명령은 디스크립터를 등록하기 위한 것일 수 있으며, 상기 명령은 디스크 립터의 등록 파라미터를 포함할 수 있다. 상기 등록 파라미터는 디스크립터의 식별자(ID), 텐서 형상 및 디스크 립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나를 포함할 수 있다. 예를 들어, 상기 등록 파라미터는 식별자가 TR0이고, 텐서 형상(차원 수량, 각 차원의 크기, 오프셋, 시작 데이터 어드레스 등)을 포함할 수 있다. 본 발명은 등록 파라미터의 구체적인 내용에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디코딩 후의 제1 처리 명령의 연산코드에 따라 상기 명령을 디스크립터 등록 명 령으로 결정 시, 제1 처리 명령 중의 등록 파라미터에 따라, 상응하는 디스크립터를 생성할 수 있다. 그 중, 제 어유닛 또는 텐서 제어모듈을 통해 상응하는 디스크립터를 생성할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 먼저 디스크립터 콘텐츠의 디스크립터 저장공간 중에서의 제1 저장영역, 및 상기 디스크립터가 지시하는 텐서 데이터 콘텐츠의 데이터 저장공간 중에서의 제2 저장영역을 결정할 수 있다. 예를 들어 설명하면, 만약 저장영역 중의 적어도 하나를 이미 미리 설정하였다면, 즉 제1 저장영역 및/또는 제2 저장영역을 직접 결정할 수 있다. 예를 들어 디스크립터 콘텐츠와 텐서 데이터 콘텐츠를 동일한 저장공간에 저 장하도록 미리 설정하고, 디스크립터의 식별자(TR0)에 대응되는 디스크립터 콘텐츠의 저장 어드레스를 ADDR32- ADDR63으로, 텐서 데이터 콘텐츠의 저장 어드레스를 ADDR64-ADDR1023으로 미리 설정하였다면, 즉 이 두 어드레 스를 제1 저장영역과 제2 저장영역으로 직접 결정할 수 있다. 일종의 가능한 구현 방식에서, 만약 미리 설정된 저장영역이 없다면, 즉 디스크립터 콘텐츠에 디스크립터 저장 공간 중의 제1 저장영역을 할당하고, 텐서 데이터 콘텐츠에 데이터 저장공간 중의 제2 저장영역을 할당할 수 있 다. 그 중, 제어유닛 또는 텐서 제어모듈을 통해 저장영역을 할당할 수 있으며, 본 발명은 이에 대해 제한을 두 지 않는다. 일종의 가능한 구현 방식에서, 등록 파라미터 중의 텐서 형상 및 상기 제2 저장영역의 데이터 어드레스에 따라, 텐서 형상과 어드레스 간의 대응관계를 구축하고, 나아가 디스크립터의 콘텐츠를 결정함으로써, 데이터 처리 시 디스크립터의 콘텐츠에 따라 대응되는 데이터 어드레스를 결정할 수 있다. 디스크립터의 콘텐츠를 결정 후, 이 를 제1 저장영역에 저장하고, 디스크립터의 등록 과정을 완료할 수 있다. 예를 들어, 도 2에 도시된 텐서 데이터에 대하여, 등록 파라미터는 데이터 저장공간의 시작 어드레스 (PA_start)(기준 어드레스), X축 방향상의 오프셋(offset_x로 표시), Y축 방향상의 오프셋(offset_y로 표시), X축 방향상의 크기(size_x로 표시), Y축 방향상의 크기(size_y로 표시)를 포함할 수 있다. 이러한 파라미터를 통해, 디스크립터의 콘텐츠를 공식 로 나타내고, 이를 제1 저장영역에 저장할 수 있으며, 이에 따라 디스크립터의 등록 과정을 완료할 수 있다. 이러한 방식을 통해, 디스크립터 등록 명령에 따라 디스크립터를 자동으로 생성하고, 디스크립터가 지시하는 텐 서와 데이터 어드레스 간의 대응을 구현함으로써, 데이터 처리 시 디스크립터 콘텐츠를 통해 데이터 어드레스를 획득할 수 있으며, 프로세서의 데이터 액세스 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 방법은 상기 제1 처리 명령이 디스크립터 취소 명령인 경우, 상기 제1 처리 명령 중 디스크립터의 식별자를 획득하는 단계; 상기 디스크립터의 식별자에 따라, 상기 디스크립터의 디스크립터 저장공간중에서의 저장영역 및 상기 디스크립 터가 지시하는 텐서 데이터 콘텐츠의 데이터 저장공간 중에서의 저장영역을 각각 해제하는 단계를 포함한다. 예를 들어 설명하면, 디스크립터 취소 명령은 디스크립터가 차지하는 공간을 해제하도록 디스크립터를 취소(삭 제)하기 위한 것일 수 있으며, 상기 명령은 적어도 디스크립터의 식별자를 포함할 수 있다. 일종의 가능한 구현 방식에서, 디코딩 후의 제1 처리 명령의 연산코드에 따라 상기 명령을 디스크립터 취소 명 령로 결정 시, 제1 처리 명령 중의 디스크립터 식별자에 따라, 상응하는 디스크립터를 취소할 수 있다. 제어유 닛 또는 텐서 제어모듈을 통해 상응하는 디스크립터를 취소할 수 있으며, 본 발명은 이에 대해 제한을 두지 않 는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자에 따라, 상기 디스크립터의 디스크립터 저장공간 중에서의 저장영역, 및/또는 상기 디스크립터가 지시하는 텐서 데이터 콘텐츠의 데이터 저장공간 중에서의 저장영역을 해 제함으로써, 각 저장영역에 대한 상기 디스크립터의 점용을 해제할 수 있다. 이러한 방식을 통해, 디스크립터의 사용이 종료된 후 디스크립터가 차지하는 공간을 해제함으로써, 제한적인 저 장 리소스를 반복 사용할 수 있어, 리소스의 이용 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 방법은 상기 제1 처리 명령이 디스크립터 수정 명령인 경우, 상기 제1 처리 명령 중 상기 디스크립터의 식별자, 수정할 텐서 형상 및 디스크립터가 지시하는 텐서 데이터 콘텐츠 중의 적어도 하나를 포함하는 디스크립터의 수정 파라 미터를 획득하는 단계; 상기 디스크립터의 수정 파라미터에 따라, 상기 디스크립터의 업데이트할 콘텐츠를 결정하는 단계; 업데이트할 콘텐츠에 따라, 상기 디스크립터 저장공간 중의 상기 디스크립터의 콘텐츠 및/또는 데이터 저장공간 중 텐서 데이터의 콘텐츠를 업데이트하는 단계를 더 포함한다. 예를 들어 설명하면, 디스크립터 수정 명령은 디스크립터의 각종 파라미터, 예를 들어 식별자, 텐서 형상 등을 수정하기 위한 것일 수 있다. 상기 명령은 수정 파라미터를 포함할 수 있으며, 상기 수정 파라미터는 상기 디스 크립터의 식별자, 수정할 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나를 포함 한다. 본 발명은 수정 파라미터의 구체적인 내용에 대해서는 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디코딩 후의 제1 처리 명령의 연산코드에 따라 상기 명령을 디스크립터 수정 명 령으로 결정 시, 제1 처리 명령 중의 수정 파라미터에 따라, 디스크립터의 업데이트할 콘텐츠, 예를 들어 텐서 의 차원을 3차원에서 2차원으로 변경하거나, 텐서의 하나 또는 다수의 차원 방향에서의 크기 변경 등을 결정할 수 있다. 일종의 가능한 구현 방식에서, 업데이트할 콘텐츠를 결정 후, 디스크립터 저장공간 중의 디스크립터 콘텐츠 및/ 또는 데이터 저장공간 중 텐서 데이터의 콘텐츠를 업데이트함으로써, 텐서 데이터를 수정하고 업데이트 후의 디 스크립터 콘텐츠로 수정된 후의 텐서 데이터의 형상을 지시한다. 본 발명은 업데이트할 콘텐츠의 범위 및 구체 적인 업데이트 방식에 대해 제한을 두지 않는다. 이러한 방식을 통해, 디스크립터가 지시하는 텐서 데이터에 변화가 발생 시, 디스크립터와 텐서 데이터 간의 대 응이 유지되도록 디스크립터를 직접 수정할 수 있어, 리소스의 이용 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 방법은 상기 디스크립터의 식별자에 따라, 명령 큐(instruction queue) 중 상기 제1 처리 명령 이전에 위치하면서, 피 연산자에 상기 디스크립터의 식별자를 구비한 처리 명령을 포함하는 처리가 완료되지 않은 제2 처리 명령이 존 재하는지 여부를 결정하는 단계; 처리가 완료되지 않은 제2 처리 명령이 존재 시, 상기 제1 처리 명령을 차단하거나 캐시하는 단계를 더 포함한 다. 예를 들어 설명하면, 디스크립터를 설정한 후, 디스크립터에 따라 명령 간의 의존관계를 판단할 수 있다. 디코 딩 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있다면, 즉 상기 제1 처리 명령 이전의 명령에 상기 제1 처리 명령과 의존관계를 갖는 명령이 존재하는지 여부를 결정할 수 있다. 이러한 경우, 명령 큐 중의 제1 처리 명령 이전의 명령(전위(preorder) 명령)에 대해, 만약 전위 명령의 피연산 자에 상기 디스크립터의 식별자가 구비되어 있다면, 상기 전위 명령은 상기 제1 처리 명령과 의존관계를 갖는 제2 처리 명령으로 간주할 수 있다. 제1 처리 명령의 피연산자에 다수의 디스크립터의 식별자가 구비된 경우, 각 디스크립터에 대응하는 의존관계를 각각 판단할 수 있으며, 다시 말해, 피연산자에 다수의 디스크립터 중의 적어도 하나의 디스크립터의 식별자가 구비된 전위 명령을 의존관계를 지닌 제2 처리 명령으로 삼을 수 있다. 제어유닛에 의존관계 판단 모듈을 설치하여 처리 명령 간의 의존관계를 판단할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 처리가 완료되지 않은 제2 처리 명령이 존재한다면, 즉 제1 처리 명령은 제2 처 리 명령이 완료된 후 실행해야 한다. 예를 들어, 제1 처리 명령이 디스크립터(TR0)에 대한 연산 명령이고, 제2 처리 명령은 디스크립터(TR0)에 대한 쓰기 명령이라면, 즉 제2 처리 명령과 제1 처리 명령 사이는 의존관계를 지니며, 상기 제2 처리 명령이 실행되는 동안, 제1 명령을 실행시킬 수 없다. 또한, 제2 처리 명령에 제1 처리 명령에 대한 동기화 명령(sync)이 포함되어 있다면, 즉 제2 처리 명령과 제1 처리 명령 사이는 의존관계를 지녀, 상기 제2 처리 명령의 실행을 완료한 다음 제1 처리 명령을 실행시켜야 한다. 일종의 가능한 구현 방식에서, 처리가 완료되지 않은 제2 처리 명령이 존재한다면, 즉 제1 처리 명령을 차단할 수 있으며, 다시 말해 제1 처리 명령 및 이후의 다른 명령의 실행을 제2 처리 명령의 실행이 완료될 때까지 정 지시킨 후, 제2 처리 명령의 실행이 완료된 후 제1 처리 명령 및 이후의 다른 명령을 실행시킨다. 일종의 가능한 구현 방식에서, 처리가 완료되지 않은 제2 처리 명령이 존재한다면, 즉 제1 처리 명령을 캐시할 수 있으며, 다시 말해, 다른 명령의 실행에 영향을 주지 않고 제1 처리 명령을 미리 설정된 캐시 공간에 저장하 고, 제2 처리 명령의 실행이 완료된 후, 다시 캐시 공간 중의 제1 처리 명령을 실행시킨다. 본 발명은 처리가 완료되지 않은 제2 처리 명령이 존재할 경우 제1 처리 명령의 처리 방식에 대해 제한을 두지 않는다. 이러한 방식을 통해, 명령 유형에 의해 발생되는 명령 사이의 의존관계 및 동기화 명령에 의해 발생되는 의존관 계를 결정할 수 있고, 의존관계를 지닌 전위 명령의 처리가 완료되지 않았을 때 제1 처리 명령을 차단하거나 캐 시함으로써, 명령의 실행 순서를 보장하고, 데이터 처리의 정확성을 확실히 보장할 수 있다. 일종의 가능한 구현 방식에서, 상기 방법은 상기 디스크립터의 식별자에 따라, 연산 가능(operable) 상태 또는 연산 불가(not operable) 상태를 포함하는 상기 디스크립터의 현재 상태를 결정하는 단계; 상기 디스크립터가 현재 연산 불가 상태에 처한 경우, 상기 제1 처리 명령을 차단하거나 또는 캐시하는 단계를 더 포함한다. 예를 들어 설명하면, 디스크립터의 상태 대응표를 설치함으로써(예를 들어 텐서 제어모듈에 디스크립터의 상태 대응표를 저장한다), 디스크립터의 현재 상태를 표시할 수 있으며, 디스크립터의 상태는 연산 가능 상태 또는 연산 불가 상태를 포함한다. 일종의 가능한 구현 방식에서, 제1 처리 명령의 전위 명령이 현재 디스크립터에 대해 연산(예를 들어 쓰기 또는 읽기)을 실행 중인 경우, 디스크립터의 현재 상태를 연산 불가 상태로 설정할 수 있다. 상기 상태에서는 제1 처 리 명령을 실행시킬 수 없으며, 제1 처리 명령을 차단하거나 또는 캐시할 수 있다. 반대로, 현재 디스크립터에 대해 연산을 수행하는 전위 명령이 없는 경우, 디스크립터의 현재 상태를 연산 가능 상태로 설정할 수 있으며, 상기 상태에서는 제1 처리 명령을 실행시킬 수 있다. 일종의 가능한 구현 방식에서, 디스크립터 콘텐츠가 레지스터(TR)(텐서 레지스터, Tensor Register)에 저장되어 있는 경우, 디스크립터의 상태 대응표에 TR의 사용 상황을 저장하여, TR이 점용되었는지 아니면 해제되었는지 결정함으로써, 제한적인 레지스터 리소스의 관리를 구현할 수도 있다. 이러한 방식을 통해, 디스크립터의 상태에 따라 명령 간의 의존관계를 판단함으로써, 명령의 실행 순서를 보장 하고, 데이터 처리의 정확성을 확실히 보장할 수 있다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하며, 상기 피연산자는 소스 데 이터(source data)와 타겟 데이터(target data)를 포함한다. 그 중, 단계 S11a는 상기 소스 데이터와 상기 타겟 데이터 중의 적어도 하나에 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하는 단계를 포함하고; 그 중, 단계 S12a는 상기 디스크립터의 콘텐츠에 따라, 상기 소스 데이터의 제1 데이터 어드레스 및/또는 상기 타겟 데이터의 제2 데이터 어드레스를 각각 결정하고; 상기 제1 데이터 어드레스로부터 데이터를 독취하여 상기 제2 데이터 어드레스에 입력(write)하는 단계를 포함한다. 예를 들어 설명하면, 데이터 액세스 명령의 피연산자는 소스 데이터의 데이터 어드레스로부터 데이터를 독취하 여 타겟 데이터의 데이터 어드레스에 입력하기 위한 소스 데이터와 타겟 데이터를 포함한다. 제1 처리 명령이 데이터 액세스 명령일 경우, 디스크립터를 통해 텐서 데이터의 액세스를 구현할 수 있다. 데이터 액세스 명령의 소스 데이터와 타겟 데이터 중의 적어도 하나에 디스크립터의 식별자가 포함되어 있는 경우, 디스크립터의 디스 크립터 저장공간을 결정할 수 있다. 일종의 가능한 구현 방식에서, 소스 데이터에 제1 디스크립터의 식별자가 포함되고, 타겟 데이터에 제2 디스크 립터의 식별자가 포함되어 있는 경우, 즉 제1 디스크립터의 제1 디스크립터 저장공간과 제2 디스크립터의 제2 디스크립터 저장공간을 각각 결정할 수 있으며; 이후 제1 디스크립터 저장공간과 제2 디스크립터 저장공간으로 부터 각각 제1 디스크립터의 콘텐츠와 제2 디스크립터의 콘텐츠를 독취하고; 제1 디스크립터와 제2 디스크립터 의 콘텐츠에 따라, 소스 데이터의 제1 데이터 어드레스와 타겟 데이터의 제2 데이터 어드레스를 각각 계산할 수 있으며; 제1 데이터 어드레스로부터 데이터를 독취하여 제2 데이터 어드레스에 입력함으로써 전체적인 액세스 과정을 완료한다. 예를 들어, 소스 데이터는 오프칩의 독취할 데이터일 수 있고, 그 첫 번째 디스크립터의 식별자는 1이며, 타겟 데이터는 온칩인 하나의 저장공간이고, 그 두 번째 디스크립터의 식별자는 2일 수 있다. 소스 데이터 중 제1 디 스크립터의 식별자 1 및 타겟 데이터 중 제2 디스크립터의 식별자 2에 따라, 디스크립터 저장공간으로부터 제1 디스크립터의 콘텐츠(D1)과 제2 디스크립터의 콘텐츠(D2)을 각각 획득할 수 있다. 그 중, 제1 디스크립터의 콘 텐츠(D1)과 제2 디스크립터의 콘텐츠는 각각 다음과 같이 나타낼 수 있다: D1:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "D2:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "제1 디스크립터의 콘텐츠(D1)과 제2 디스크립터의 콘텐츠(D2)에 따라, 소스 데이터의 시작 물리 어드레스(PA3) 와 타겟 데이터의 시작 물리 어드레스(PA4)를 각각 획득할 수 있으며, 각각 다음과 같이 나타낸다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "소스 데이터의 시작 물리 어드레스(PA3)와 타겟 데이터의 시작 물리 어드레스(PA4), 및 제1 디스크립터의 콘텐 츠(D1)과 제2 디스크립터의 콘텐츠(D2)에 따라, 제1 데이터 어드레스와 제2 데이터 어드레스를 각각 결정하고, 제1 데이터 어드레스로부터 데이터를 독취하여 제2 데이터 어드레스에 입력함으로써(IO 채널을 통할 수 있다), D1이 지시하는 텐서 데이터를 D2가 지시하는 저장공간에 로드(load)할 수 있다. 일종의 가능한 구현 방식에서, 소스 데이터에만 제1 디스크립터의 식별자가 포함되어 있다면, 즉 제1 디스크립 터의 제1 디스크립터 저장공간을 결정할 수 있으며; 이후 제1 디스크립터 저장공간으로부터 제1 디스크립터의 콘텐츠를 독취하고; 제1 디스크립터의 콘텐츠에 따라, 소스 데이터의 제1 데이터 어드레스를 계산할 수 있으며; 명령의 피연산자 중 타겟 데이터의 제2 데이터 어드레스에 따라, 제1 데이터 어드레스로부터 데이터를 독취하여 제2 데이터 어드레스에 입력함으로써 전체적인 액세스 과정을 완료할 수 있다. 일종의 가능한 구현 방식에서, 타겟 데이터에만 제2 디스크립터의 식별자가 포함되어 있다면, 즉 제2 디스크립 터의 제2 디스크립터 저장공간을 결정할 수 있으며; 이후 제2 디스크립터 저장공간으로부터 제2 디스크립터의 콘텐츠를 독취하고; 제2 디스크립터의 콘텐츠에 따라, 타겟 데이터의 제2 데이터 어드레스를 계산할 수 있으며; 명령의 피연산자 중 소스 데이터의 제1 데이터 어드레스에 따라, 제1 데이터 어드레스로부터 데이터를 독취하여 제2 데이터 어드레스에 입력함으로써 전체적인 액세스 과정을 완료할 수 있다. 이러한 방식을 통해, 디스크립터를 사용하여 데이터의 액세스를 완료할 수 있으며, 매번 액세스할 때마다 명령 을 통해 데이터 어드레스를 입력할 필요가 없어 데이터 액세스 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 연산 명령을 포함하며, 단계 S12a는 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응되는 데이터의 데이터 저장공간 중에 서의 데이터 어드레스를 결정하는 단계; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 연산을 실행하는 단계를 포함한다. 예를 들어 설명하면, 제1 처리 명령이 연산 명령인 경우, 디스크립터를 통해 텐서 데이터의 연산을 구현할 수 있다. 연산 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 디스크립터의 디스크립터 저장공간 을 결정할 수 있으며, 이후 디스크립터 저장공간으로부터 디스크립터의 콘텐츠를 독취하고; 디스크립터의 콘텐 츠에 따라, 피연산자에 대응하는 데이터의 어드레스를 계산하고, 나아가 데이터 어드레스로부터 데이터를 독취 하여 연산을 수행함으로써, 전체적인 연산 과정을 완료할 수 있다. 이러한 방식을 통해, 연산 시 디스크립터를 사용하여 데이터의 독취를 완료할 수 있으며, 명령을 통해 데이터 어드레스를 입력할 필요가 없어 데이터 연산 효율이 향상된다. 본 발명의 실시예에 따른 데이터 처리방법은 텐서 형상을 지시할 수 있는 디스크립터를 도입하여, 데이터 처리 명령의 운용 과정에서 디스크립터를 통해 데이터의 어드레스를 결정할 수 있어, 하드웨어 측면으로부터 명령 생 성 방식을 단순화함으로써, 데이터 액세스의 복잡도가 감소하고, 또한 프로세서가 데이터를 액세스하는 효율이 향상된다. 도 3a는 본 발명의 실시예에 따른 데이터 처리장치의 블록도이다. 도 3a에 도시된 바와 같이, 본 발명은 데이터 처리장치를 더 제공하며, 이는 디코딩 후의 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 상기 디스크립터의 콘텐츠를 획득하기 위한 콘텐츠 획득 모듈(31a); 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령을 실행시키기 위한 명령 실행 모듈(32a)을 포함한다. 일종의 가능한 구현 방식에서, 상기 명령 실행 모듈은, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령 의 피연산자에 대응되는 데이터의 데이터 저장공간 중에서의 데이터 어드레스를 결정하기 위한 어드레스 결정 서브모듈; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행시키기 위한 데이 터 처리 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 처리 명령이 디스크립터 등록 명령인 경우, 상기 제1 처 리 명령 중 상기 디스크립터의 식별자, 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중 적어도 하나를 포함하는 디스크립터의 등록 파라미터를 획득하기 위한 제1 파라미터 획득 모듈; 상기 디스크립터의 등 록 파라미터에 따라, 상기 디스크립터의 콘텐츠의 디스크립터 저장공간 중에서의 제1 저장영역, 및 상기 디스크 립터가 지시하는 텐서 데이터 콘텐츠의 데이터 저장공간 중에서의 제2 저장영역을 결정하기 위한 영역 결정 모 듈; 상기 디스크립터의 등록 파라미터 및 상기 제2 저장영역에 따라, 상기 디스크립터의 콘텐츠를 결정하여, 상 기 디스크립터와 상기 제2 저장영역 간의 대응관계를 구축하기 위한 콘텐츠 결정 모듈; 상기 디스크립터의 콘텐 츠를 상기 제1 저장영역에 저장하기 위한 콘텐츠 저장 모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 처리 명령이 디스크립터 취소 명령인 경우, 상기 제1 처 리 명령 중 디스크립터의 식별자를 획득하기 위한 식별자 획득 모듈; 상기 디스크립터의 식별자에 따라, 상기 디스크립터의 디스크립터 저장공간 중에서의 저장영역 및 상기 디스크립터가 지시하는 텐서 데이터 콘텐츠의 데이터 저장공간 중에서의 저장영역을 각각 해제하기 위한 공간 해제 모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 처리 명령이 디스크립터 수정 명령인 경우, 상기 제1 처 리 명령 중 상기 디스크립터의 식별자, 수정할 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나를 포함하는 디스크립터의 수정 파라미터를 획득하기 위한 제2 파라미터 획득 모듈; 상기 디스크립 터의 수정 파라미터에 따라, 상기 디스크립터의 업데이트할 콘텐츠를 결정하기 위한 업데이트 콘텐츠 결정 모듈; 업데이트할 콘텐츠에 따라, 디스크립터 저장공간 중의 상기 디스크립터의 콘텐츠 및/또는 데이터 저장공 간 중 텐서 데이터의 콘텐츠를 업데이트하기 위한 콘텐츠 업데이트 모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 디스크립터의 식별자에 따라, 명령 큐 중 상기 제1 처리 명령 의 이전에 위치하면서, 피연산자에 상기 디스크립터의 식별자를 갖는 처리 명령을 포함하는 처리가 완료되지 않 은 제2 처리 명령이 존재하는지 여부를 결정하기 위한 명령 결정 모듈; 처리가 완료되지 않은 제2 처리 명령이 존재하는 경우, 상기 제1 처리 명령을 차단하거나 또는 캐시하기 위한 제1 명령 캐시 모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 디스크립터의 식별자에 따라, 연산 가능 상태 또는 연산 불가 상태를 포함하는 상기 디스크립터의 현재 상태를 결정하기 위한 상태 결정 모듈; 상기 디스크립터가 현재 연산 불가 상태인 경우, 상기 제1 처리 명령을 차단하거나 캐시하기 위한 제2 명령 캐시 모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데 이터와 타겟 데이터를 포함하며, 그 중, 상기 콘텐츠 획득 모듈은, 상기 소스 데이터와 상기 타겟 데이터 중의 적어도 하나가 디스크립터의 식별자를 포함하고 있는 경우, 디스크립터 저장공간으로부터 상기 디스크립터의 콘 텐츠를 획득하기 위한 콘텐츠 획득 서브모듈을 포함하고; 상기 명령 실행 모듈은, 상기 디스크립터의 콘텐츠에 따라 상기 소스 데이터의 제1 데이터 어드레스 및/또는 상기 타겟 데이터의 제2 데이터 어드레스를 각각 결정하 기 위한 제1 어드레스 결정 서브모듈; 상기 제1 데이터 어드레스로부터 데이터를 독취하여 상기 제2 데이터 어 드레스에 입력(write)하기 위한 액세스 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 연산 명령을 포함하고, 그 중, 상기 명령 실행 모듈은, 상 기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응하는 데이터의 데이터 저장공간 중에서 의 데이터 어드레스를 결정하기 위한 제2 어드레스 결정 서브모듈; 상기 데이터 어드레스에 따라, 상기 제1 처 리 명령에 대응되는 연산을 실행하기 위한 연산 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것으로서, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파 라미터를 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 더 포함한다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 텐서 데이터의 데이터 저장공간 중에서 상기 디스크립터의 데이터 기준점의 기준 어드레스를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미 터는, N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향 상에서의 상기 텐서 데이터 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 차원방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스 크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나 를 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 수신된 제1 처리 명령에 대해 디코딩 처리를 수행하여, 디코딩 후 의 제1 처리 명령을 획득하기 위한 디코딩 모듈을 더 포함하며, 그 중 디코딩 후의 제1 처리 명령은 상기 제1 처리 명령에 대응하는 처리 유형을 지시하기 위한 연산코드 및 하나 또는 다수의 피연산자를 포함한다. 일종의 가능한 구현 방식에서, 상기 데이터 처리장치를 포함하는 신경망 칩을 더 공개한다. 일종의 가능한 구현 방식에서, 메모리 소자, 인터페이스 장치와 제어 소자 및 상기 신경망 칩을 포함하는 보드 를 더 공개하며; 그 중, 상기 신경망 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 신경망 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 신경망 칩의 상태를 모니터링하기 위한것이다. 도 4는 본 발명의 실시예에 따른 보드의 구조 블록도로서, 도 4를 참조하면, 상기 보드는 상기 칩 이외에, 메모리 소자, 인터페이스 장치와 제어 소자를 포함하되, 단 이에 한정되지 않는 기타 보조 부재 를 더 포함할 수 있으며; 상기 메모리 소자와 상기 신경망 칩은 버스(bus)를 통해 연결되어 데이터를 저장하는데 사용된다. 상기 메 모리 소자는 다수 그룹의 저장유닛을 포함할 수 있다. 각 그룹의 상기 저장유닛과 상기 신경망 칩은 버스 를 통해 연결된다. 각 그룹의 상기 저장유닛은 DDR SDRAM(영문: Double Data Rate SDRAM, 2배속 동기식 동적 랜덤 메모리)일 수 있음은 이해할 수 있을 것이다. DDR은 클럭 주파수를 높일 필요 없이 SDRAM의 속도를 배가시킬 수 있다. DDR은 클럭 펄스의 상승 에지(rising edge)와 하강 에지(falling edge)에서 데이터를 독취하도록 허용한다. DDR의 속도는 표준 SDRAM의 2배이다. 일 실시예에서, 상기 저장장치는 4개 그룹의 상기 저장유닛을 포함할 수 있다. 각 그룹의 상기 저장유닛은 다수의 DDR4(칩)을 포함할 수 있다. 일 실시예에서, 상기 신경망 칩의 내부에 4개의 72비트의 DDR4 컨트롤러가 포함될 수 있으며, 상기 72비트 DDR4 컨트롤러 중 64비트는 데이터 전송에 사용되고, 8비트는 ECC 검출교정에 사용된다. 각 그룹의 상기 저장장치 중 DDR4-3200 칩을 사용할 경우, 데이터 전송의 이론 밴드폭이 25600MB/s에 달할 수 있음을 이해할 수 있을 것이다. 일 실시예에서, 각 그룹의 상기 저장유닛은 다수의 병렬 설치되는 2배속 동기식 동적 랜덤 메모리를 포함한다. DDR은 하나의 클럭 주기 내에서 데이터를 2회 전송할 수 있다. 상기 칩에 DDR을 제어하는 컨트롤러가 설치되어, 각각의 상기 저장유닛에 대한 데이터 전송과 데이터 저장을 제어한다. 상기 인터페이스 장치는 상기 신경망 칩과 전기적으로 연결된다. 상기 인터페이스 장치는 상기 신경망 칩과 외 부 장치(예를 들어 서버 또는 컴퓨터) 간의 데이터 전송을 구현하기 위한 것이다. 예를 들어 일 실시예에서, 상 기 인터페이스 장치는 표준 PCIE 인터페이스일 수 있다. 예컨대, 처리할 데이터는 서버로부터 표준 PCIE 인터페 이스를 통해 상기 칩에 전송되어 데이터의 이동을 구현한다. 바람직하게는 PCIE 3.0 X 16 인터페이스로 전송 시, 이론 대역폭은 16000MB/s에 달할 수 있다. 다른 일 실시예에서, 상기 인터페이스 장치는 다른 인터페이스일 수도 있다. 본 출원은 상기 다른 인터페이스의 구체적인 표현 형식을 제한하지 않으며, 상기 인터페이스 유닛이 전달 기능을 구현할 수만 있으면 된다. 또한, 상기 신경망 칩의 계산 결과 역시 상기 인터페이스 장치에 의해 외부 장치(예를 들어 서버)로 전송된다. 상기 제어 소자는 상기 신경망 칩과 전기적으로 연결된다. 상기 제어 소자는 상기 신경망 칩의 상태를 모니터링 하기 위한 것이다. 구체적으로, 상기 신경망 칩과 상기 제어 소자는 SPI 인터페이스를 통해 전기적으로 연결된 다. 상기 제어 소자는 마이크로컨트롤러(Micro Controller Unit，MCU)를 포함할 수 있다. 상기 신경망 칩은 다 수의 프로세서 칩, 다수의 프로세서 코어 또는 다수의 처리회로를 포함할 수 있으며, 다수의 부하를 구동시킬 수 있다. 따라서, 상기 신경망 칩은 다부하와 경부하 등 상이한 작동 상태에 처할 수 있다. 상기 제어장치를 통 해 상기 신경망 칩 중 다수의 프로세서 칩, 다수의 프로세서 코어 또는 다수의 처리회로의 작동 상태의 제어를 구현할 수 있다. 일종의 가능한 구현 방식에서, 상기 신경망 칩을 포함하는 전자장치를 공개한다. 전자장치는 데이터 처리장치, 로봇, 컴퓨터, 프린터, 스캐너, 태블릿 컴퓨터, 스마트 단말, 핸드폰, 주행기록장치, 네비게이션, 센서, 웹캠, 서버, 클라우드 서버, 카메라, 비디오카메라, 영사기, 손목시계, 이어폰, 이동식 메모리, 웨어러블장치, 교통수 단, 가정용 전자제품, 및/또는 의료장치를 포함한다. 상기 교통수단은 비행기, 선박 및/또는 차량을 포함하며; 상기 가정용 전자제품은 TV, 에어콘, 전자레인지, 냉 장고, 전기밥솥, 가습기, 세탁기, 전등, 가스레인지, 환풍기를 포함하고; 상기 의료장치는 핵자기공명장치, B형 초음파기 및/또는 심전도기를 포함한다. A1: 데이터 처리방법에 있어서, 상기 방법은 디코딩 후의 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라 디스크립터의 콘텐츠를 획득하는 단계; 상기 디스크립터의 콘텐츠에 따라 상기 제1 처리 명령을 실행시키는 단계를 포함한다. A2: A1에 따른 방법에 있어서, 상기 디스크립터의 콘텐츠에 따라 상기 제1 처리 명령을 실행시키는 단계는, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응되는 데이터의 데이터 저장공간 중에 서의 데이터 어드레스를 결정하는 단계; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계를 포함한다. A3: A1 또는 A2 항에 따른 방법에 있어서, 상기 방법은, 상기 제1 처리 명령이 디스크립터 등록 명령인 경우, 상기 제1 처리 명령 중 상기 디스크립터의 식별자, 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나를 포함하는 디스크립터의 등록 파라미 터를 획득하는 단계; 상기 디스크립터의 등록 파라미터에 따라, 상기 디스크립터의 콘텐츠의 디스크립터 저장공간 중에서의 제1 저장 영역, 및 상기 디스크립터가 지시하는 텐서 데이터 콘텐츠의 데이터 저장공간 중에서의 제2 저장영역을 결정하 는 단계; 상기 디스크립터의 등록 파라미터 및 상기 제2 저장영역에 따라, 상기 디스크립터의 콘텐츠를 결정하여, 상기 디스크립터와 상기 제2 저장영역 간의 대응관계를 구축하는 단계; 상기 디스크립터의 콘텐츠를 상기 제1 저장영역에 저장하는 단계를 더 포함한다. A4: A1-A3 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은 상기 제1 처리 명령이 디스크립터 취소 명령인 경우, 상기 제1 처리 명령 중 디스크립터의 식별자를 획득하는 단계; 상기 디스크립터의 식별자에 따라, 상기 디스크립터의 디스크립터 저장공간 중에서의 저장영역 및 상기 디스크 립터가 지시하는 텐서 데이터 콘텐츠의 데이터 저장공간 중에서의 저장영역을 각각 해제하는 단계를 더 포함한 다. A5: A1-A4 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은 상기 제1 처리 명령이 디스크립터 수정 명령인 경우, 상기 제1 처리 명령 중 상기 디스크립터의 식별자, 수정할 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나를 포함하는 디스크립터의 수정 파 라미터를 획득하는 단계; 상기 디스크립터의 수정 파라미터에 따라, 상기 디스크립터의 업데이트할 콘텐츠를 결정하는 단계; 업데이트할 콘텐츠에 따라, 디스크립터 저장공간 중의 상기 디스크립터의 콘텐츠 및/또는 데이터 저장공간 중의 텐서 데이터의 콘텐츠를 업데이트하는 단계를 더 포함한다. A6: A1-A5 중 어느 한 항에 따른 방법에 있어서, 상기 방법은 상기 디스크립터의 식별자에 따라, 명령 큐에 상기 제1 처리 명령의 이전에 위치하면서, 피연산자에 상기 디스 크립터의 식별자를 구비한 처리 명령을 포함하는 처리가 완료되지 않은 제2 처리 명령이 존재하는지 여부를 결 정하는 단계; 처리가 완료되지 않은 제2 처리 명령이 존재 시, 상기 제1 처리 명령을 차단하거나 또는 캐시하는 단계를 더 포 함한다. A7: A1-A6 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은 상기 디스크립터의 식별자에 따라, 상기 디스크립터의 연산 가능 상태 또는 연산 불가 상태를 포함하는 현재 상 태를 결정하는 단계; 상기 디스크립터가 연산 불가 상태에 처한 경우, 상기 제1 처리 명령을 차단하거나 또는 캐시하는 단계를 더 포 함한다. A8: A1-A7 중의 어느 한 항에 따른 방법에 있어서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데이터와 타겟 데이터를 포함하며, 그 중, 상기 디스크립터의 식별자에 따라, 상기 디스크립터의 콘텐츠를 획득하는 단계는, 상기 소스 데이터와 상기 타겟 데이터 중의 적어도 하나에 디스크립터의 식별자가 포함되어 있는 경우, 디스크 립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하며; 그 중 상기 디스크립터의 콘텐츠에 따라 상기 제1 처리 명령을 실행시키는 단계는, 상기 디스크립터의 콘텐츠에 따라, 상기 소스 데이터의 제1 데이터 어드레스 및/또는 상기 타겟 데이터의 제2 데이터 어드레스를 각각 결정하는 단계; 상기 제1 데이터 어드레스로부터 데이터를 독취하여 상기 제2 데이터 어드레스에 기입하는 단계를 포함한다. A9: A1-A7 중의 어느 한 항에 따른 방법에 있어서, 상기 제1 처리 명령은 연산 명령을 포함하며, 그 중, 상기 디스크립터의 콘텐츠에 따라 상기 제1 처리 명령을 실행시키는 단계는, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응되는 데이터의 데이터 저장공간 중에 서의 데이터 위치를 결정하는 단계; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 연산을 실행시키는 단계를 포함한다. A10: A1-A9 중의 어느 한 항에 따른 방법에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것이고, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A11: A10항에 따른 방법에 있어서, 상기 디스크립터는 또한 N차원의 텐서 데이터의 어드레스를 지시하기 위한 것이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내기 위한 적어도 하나의 어드레스 파라미터를 더 포함한다. A12: A11항에 따른 방법에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점 의 상기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함하고; 그 중, 상기 텐서 데이터의 형상 파라미터는 N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터의 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N 개 차원방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한 다. A13. A1-A12 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은 수신된 제1 처리 명령에 대해 디코딩 처리를 수행하여, 디코딩 후의 제1 처리 명령을 획득하는 단계를 더 포함 하며, 그 중, 디코딩 후의 제1 처리 명령은 연산코드 및 하나 또는 다수의 피연산자를 포함하고, 상기 연산코드는 상 기 제1 처리 명령에 대응되는 처리 유형을 지시하기 위한 것이다. A14: 데이터 처리장치에 있어서, 상기 장치는 디코딩 후의 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 상기 디스크립터의 콘텐츠를 획득하기 위한 콘텐츠 획득 모듈; 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령을 실행시키기 위한 명령 실행 모듈을 포함한다. A15: A14항에 따른 장치에 있어서, 상기 명령 실행 모듈은, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응되는 데이터의 데이터 저장공간 중에 서의 데이터 어드레스를 결정하기 위한 어드레스 결정 서브모듈; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행시키기 위한 데이터 처리 서 브모듈을 포함한다. A16: A14 또는 A15항에 따른 장치에 있어서, 상기 장치는, 상기 제1 처리 명령이 디스크립터 등록 명령인 경우, 상기 제1 처리 명령 중 상기 디스크립터의 식별자, 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중 적어도 하나를 포함하는 디스크립터의 등록 파라미터를 획득하기 위한 제1 파라미터 획득 모듈; 상기 디스크립터의 등록 파라미터에 따라, 상기 디스크립터의 콘텐츠의 디스크립터 저장공간 중에서의 제1 저장 영역, 및 상기 디스크립터가 지시하는 텐서 데이터 콘텐츠의 데이터 저장공간 중에서의 제2 저장영역을 결정하 기 위한 영역 결정 모듈; 상기 디스크립터의 등록 파라미터 및 상기 제2 저장영역에 따라, 상기 디스크립터의 콘텐츠를 결정하여, 상기 디스크립터와 상기 제2 저장영역 간의 대응관계를 구축하기 위한 콘텐츠 결정 모듈; 상기 디스크립터의 콘텐츠를 상기 제1 저장영역에 저장하기 위한 콘텐츠 저장 모듈을 더 포함한다. A17: A14-A16 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 상기 제1 처리 명령이 디스크립터 취소 명령인 경우, 상기 제1 처리 명령 중 디스크립터의 식별자를 획득하기 위한 식별자 획득 모듈; 상기 디스크립터의 식별자에 따라, 상기 디스크립터의 디스크립터 저장공간 중에서의 저장영역 및 상기 디스크 립터가 지시하는 텐서 데이터 콘텐츠의 데이터 저장공간 중에서의 저장영역을 각각 해제하기 위한 공간 해제 모 듈을 더 포함한다. A18: A14-A17 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는 상기 제1 처리 명령이 디스크립터 수정 명령인 경우, 상기 제1 처리 명령 중 상기 디스크립터의 식별자, 수정할 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나를 포함하는 디스크립터의 수정 파 라미터를 획득하기 위한 제2 파라미터 획득 모듈; 상기 디스크립터의 수정 파라미터에 따라, 상기 디스크립터의 업데이트할 콘텐츠를 결정하기 위한 업데이트 콘 텐츠 결정 모듈; 업데이트할 콘텐츠에 따라, 디스크립터 저장공간 중의 상기 디스크립터의 콘텐츠 및/또는 데이터 저장공간 중 텐서 데이터의 콘텐츠를 업데이트하기 위한 콘텐츠 업데이트 모듈을 더 포함한다. A19: A14-A18 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 상기 디스크립터의 식별자에 따라, 명령 큐 중 상기 제1 처리 명령의 이전에 위치하면서, 피연산자에 상기 디스 크립터의 식별자를 갖는 처리 명령을 포함하는 처리가 완료되지 않은 제2 처리 명령이 존재하는지 여부를 결정 하기 위한 명령 결정 모듈; 처리가 완료되지 않은 제2 처리 명령이 존재하는 경우, 상기 제1 처리 명령을 차단하거나 또는 캐시하기 위한 제1 명령 캐시 모듈을 더 포함한다. A20: A14-A19 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 상기 디스크립터의 식별자에 따라, 연산 가능 상태 또는 연산 불가 상태를 포함하는 상기 디스크립터의 현재 상 태를 결정하기 위한 상태 결정 모듈; 상기 디스크립터가 현재 연산 불가 상태인 경우, 상기 제1 처리 명령을 차단하거나 캐시하기 위한 제2 명령 캐 시 모듈을 더 포함한다. A21: A14-A20 중의 어느 한 항에 따른 장치에 있어서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데이터와 타겟 데이터를 포함하며, 그 중, 상기 콘텐츠 획득 모듈은, 상기 소스 데이터와 상기 타겟 데이터 중의 적어도 하나가 디스크립터의 식별자를 포함하고 있는 경우, 디스크 립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하기 위한 콘텐츠 획득 서브모듈을 포함하고; 상기 명령 실행 모듈은, 상기 디스크립터의 콘텐츠에 따라 상기 소스 데이터의 제1 데이터 어드레스 및/또는 상기 타겟 데이터의 제2 데 이터 어드레스를 각각 결정하기 위한 제1 어드레스 결정 서브모듈; 상기 제1 데이터 어드레스로부터 데이터를 독취하여 상기 제2 데이터 어드레스에 입력하기 위한 액세스 서브모 듈을 포함한다. A22: A14-A20 중의 어느 한 항에 따른 장치에 있어서, 상기 제1 처리 명령은 연산 명령을 포함하고, 그 중, 상 기 명령 실행 모듈은, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응되는 데이터의 데이터 저장공간 중에 서의 데이터 어드레스를 결정하기 위한 제2 어드레스 결정 서브모듈; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 연산을 실행하기 위한 연산 서브모듈을 포함한다. A23: A14-A22 중의 어느 한 항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하 기 위한 것으로서, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A24: A23항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되 며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터 를 더 포함한다. A25: A24항에 따른 장치에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점 의 데이터 저장공간 중에서의 기준 어드레스를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미터는 N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터의 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N 개 차원방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한 다. A26: A14-A25 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 수신된 제1 처리 명령에 대해 디코딩 처리를 수행하여, 디코딩 후의 제1 처리 명령을 획득하기 위한 디코딩 모 듈을 더 포함하며, 그 중 디코딩 후의 제1 처리 명령은 연산코드 및 하나 또는 다수의 피연산자를 포함하고, 상기 연산코드는 상기 제1 처리 명령에 대응되는 처리 유형을 지시하기 위한 것이다. A27: 신경망 칩에 있어서, 상기 칩은 A14-A26 중의 어느 한 항에 따른 데이터 처리장치를 포함한다. A28: 전자장치에 있어서, 상기 전자장치는 A27항에 따른 신경망 칩을 포함한다. A29: 보드에 있어서, 상기 보드는 메모리 소자, 인터페이스 장치와 제어 소자 및 A27항에 따른 신경망 칩을 포 함하며; 그 중, 상기 신경망 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 신경망 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 신경망 칩의 상태를 모니터링하기 위한 것이다. A30: A29에 따른 보드에 있어서, 상기 메모리 소자는 다수 그룹의 저장유닛을 포함하고, 각 그룹의 상기 저장유닛과 상기 신경망 칩은 버스를 통 해 연결되며, 상기 저장유닛은 DDR SDRAM이고; 상기 칩은 각각의 상기 저장유닛의 데이터 전송과 데이터 저장을 제어하기 위한 DDR 컨트롤러를 포함하며; 상기 인터페이스는 표준 PCIE 인터페이스이다. 본 발명의 실시예에 따르면, 데이터 처리장치를 제공한다. 도 1b는 본 발명의 실시예에 따른 데이터 처리장치의 블록도이다. 도 1b에 도시된 바와 같이, 상기 데이터 처리장치는 제어유닛(11b) 및 실행유닛(12b)을 포함하며,상기 제어유닛(11b)은 디코딩 후의 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하고; 상기 실행유닛으로 상기 디스크립터의 콘텐츠 및 상기 제1 처리 명령을 전송하여, 상기 실행유닛이 상기 디스크 립터의 콘텐츠에 따라 상기 제1 처리 명령을 실행하도록 하기 위한 것이다. 본 발명의 실시예에 따르면, 제어유닛은 제1 처리 명령 피연산자 중의 디스크립터의 식별자를 통해 디스크립터 의 콘텐츠를 획득하고, 실행유닛으로 디스크립터의 콘텐츠를 전송하여 제1 처리 명령을 실행시킴으로써, 처리 명령을 실행 시 디스크립터를 통해 피연산자를 획득할 수 있어, 데이터 액세스의 복잡도가 감소되고, 프로세서 의 데이터 액세스 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 데이터 처리장치는 프로세서에 응용될 수 있으며, 상기 프로세서는 범용 프 로세서(예를 들어 중앙처리장치(CPU), 그래픽 프로세서(GPU))와 전용 프로세서(예를 들어 인공지능 프로세서, 공학용 컴퓨터 프로세서 또는 디지털 신호 프로세서 등)를 포함할 수 있다. 본 발명은 프로세서의 유형에 대해 서는 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 제어유닛(11b)은 수신된 제1 처리 명령에 대해 디코딩 처리를 수행하여, 디 코딩 후의 제1 처리 명령을 획득하기 위한 것일 수 있으며, 그 중, 디코딩 후의 제1 처리 명령은 상기 제1 처리 명령에 대응되는 처리 유형을 지시하기 위한 연산코드 및 하나 또는 다수의 피연산자를 포함한다. 그 중, 제1 처리 명령은 데이터 액세스 명령, 연산 명령, 디스크립터 관리 명령 및 동기화 명령 등을 포함할 수 있으며, 본 발명은 제1 처리 명령의 구체적인 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 제어유닛(11b)은 수신된 제1 처리 명령에 대해 디코딩 처리를 수행한 후, 상기 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 디스크립터의 식별자에 따라 디스크립터 저장공간으로부터 디스크립터의 콘텐츠를 획득하고, 디스크립터의 콘텐츠 및 제1 처리 명령을 실행유닛(12b)으 로 전송하며; 실행유닛(12b)은 디스크립터의 콘텐츠 및 제1 처리 명령을 수신한 후, 먼저 디스크립터의 콘텐츠 에 따라, 상기 제1 처리 명령의 피연산자에 대응하는 데이터의 데이터 저장공간 중에서의 데이터 어드레스를 결 정한 다음, 데이터 어드레스에 따라, 제1 처리 명령에 대응되는 데이터 처리를 실행시킨다. 그 중, 데이터 저장 공간 중의 데이터 어드레스는 실제의 물리 어드레스 또는 가상의 어드레스일 수 있으며, 본 발명은 데이터 어드 레스의 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터 저장공간은 제어유닛(11b)의 내부 메모리 중의 저장공간일 수 있고, 데이터 저장공간은 제어유닛(11b)의 내부 메모리 또는 제어유닛(11b)과 연결되는 외부 메모리 중의 저장공간일 수 있다. 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것으로서, N은 양의 정수, 예를 들어 N=1, 2 또는 3이다. 그 중 텐서는 다양한 형식의 데이터 구성 방식을 포함할 수 있고, 텐서는 상이한 차원일 수 있으며, 예를 들어 스칼라는 0차원의 텐서로 간주할 수 있고, 벡터는 1차원의 텐서로 간주할 수 있으며, 매트릭스는 2차원 또는 2차원 이상의 텐서일 수 있다. 텐서의 형상은 텐서의 차원, 텐서의 각 차원 의 크기 등 정보를 포함한다. 예를 들어 설명하면, 텐서의 경우: 이며, 상기 텐서의 형상은 디스크립터에 의해 (2,4)로 기술된다. 즉 2개의 파라미터를 통해 상기 텐서가 2차원 텐서임 을 나타내며, 또한 상기 텐서의 제1 차원(열)의 크기는 2이고, 제2 차원(행)의 크기는 4이다. 설명해두어야 할 점으로, 본 출원은 디스크립터가 텐서의 형상을 지시하는 방식에 대해서는 한정하지 않는다. 일종의 가능한 구현 방식에서, N의 취득값은 텐서 데이터의 차원수(급수)에 따라 결정할 수도 있고, 텐서 데이 터의 사용 필요에 따라 설정할 수도 있다. 예를 들어 N의 취득값이 3일 경우, 텐서 데이터는 3차원의 텐서 데이 터이고, 디스크립터는 상기 3차원의 텐서 데이터의 3개 차원 방향상의 형상(예를 들어 오프셋, 크기 등)을 지시 하는데 사용될 수 있다. 이해해두어야 할 점으로, 당업자라면 실제 필요에 따라 N의 취득값을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 디스크립터의 식별자와 디스크립터의 콘텐츠를 포함할 수 있 다. 그 중, 디스크립터의 식별자는 디스크립터를 구분하기 위한 것으로서, 예를 들어 디스크립터의 식별자는 그번호이며; 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. 예 를 들어 텐서 데이터가 3차원 데이터이면, 상기 텐서 데이터 중의 3개 차원 중, 2개의 차원의 형상 파라미터는 고정 불변하고, 그 디스크립터의 콘텐츠는 상기 텐서 데이터의 다른 차원을 나타내는 형상 파라미터를 포함할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자와 콘텐츠는 레지스터, 온칩 SRAM 또는 기타 매체의 캐시 (cache)등과 같은 디스크립터 저장공간(내부 메모리)에 저장될 수 있다. 디스크립터가 지시하는 텐서 데이터는 온칩 캐시 또는 오프칩 메모리등과 같은 데이터 저장공간(내부 메모리 또는 외부 메모리)에 저장될 수 있다. 본 발명은 디스크립터 저장공간 및 데이터 저장공간의 구체적인 위치에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 동일한 영역에 저장될 수 있다. 예를 들어, 온칩 캐시의 연속되는 영역을 사용하여 디스크립터의 관련 콘텐츠를 저장할 수 있으며, 그 어드레스는 ADDR0-ADDR1023이다. 그 중, 어드레스 ADDR32-ADDR63은 디스크립터 저장공간으로서, 디스크립터의 식별자와 콘텐츠가 저장되고, 어드레스 ADDR64-ADDR1023은 데이터 저장공간으로서, 디스크립터가 지시하는 텐서 데이터가 저장된다. 디스크립터 저장공간에서, 어드레스 ADDR0-ADDR31을 사용하여 디스크립터의 식별자를 저장할 수 있고, 어드레스 ADDR32-ADDR63을 사용하여 디스크립터의 콘텐츠를 저장할 수 있다. 이해해 두어야 할 점으로, 어드레스 ADDR은 1비트 또는 하나의 바이트로 한정되지 않으며, 여기서는 하나의 어드레스를 표시하기 위한 하나의 어드레스 단위이다. 당업자라면 실제 상황에 따라 디스크립터 저장공간, 데이터 저장공간 및 구체적인 어드레스를 결정할 수 있을 것이며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 내부 메 모리의 상이한 영역에 각각 저장될 수 있다. 예를 들어 레지스터를 디스크립터 저장공간으로 하여, 레지스터에 디스크립터의 식별자와 콘텐츠를 저장할 수 있고, 온칩 캐시를 데이터 저장공간으로 하여 디스크립터가 지시하 는 텐서 데이터를 저장할 수 있다. 일종의 가능한 구현 방식에서, 레지스터를 사용하여 디스크립터의 식별자와 콘텐츠를 저장 시, 레지스터의 번호 를 사용하여 디스크립터의 식별자를 표시할 수 있다. 예를 들어 레지스터의 번호가 0일 때, 저장되는 디스크립 터의 식별자는 0으로 설정된다. 레지스터 중의 디스크립터가 유효할 때, 디스크립터가 지시하는 텐서 데이터의 크기에 따라 캐시 공간에 하나의 영역을 할당하여 상기 텐서 데이터를 저장할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자 및 콘텐츠는 내부 메모리에 저장될 수 있고, 디스크립터가 지시하는 텐서 데이터는 외부 메모리에 저장될 수 있다. 예를 들어, 디스크립터의 식별자 및 콘텐츠는 온칩 저 장하고, 디스크립터가 지시하는 텐서 데이터는 오프칩 저장하는 방식을 채택할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자에 대응되는 데이터 저장공간의 데이터 어드레스는 고정 어 드레스일 수 있다. 예를 들어 텐서 데이터를 위해 별도의 데이터 저장공간을 분할할 수 있으며, 각 텐서 데이터 의 데이터 저장공간에서의 시작 어드레스는 디스크립터의 식별자와 일일이 대응될 수 있다. 이러한 경우, 실행 유닛은 디스크립터의 콘텐츠에 따라 피연산자에 대응하는 데이터의 데이터 저장공간 중에서의 데이터 어드레스 를 즉시 결정할 수 있으며, 이 후 제1 처리 명령을 실행할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자에 대응되는 데이터 저장공간의 데이터 어드레스가 가변 어 드레스일 때, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용될 수 있으며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 더 포함할 수 있다. 예를 들어, 텐서 데이터가 3차원 데이터이고, 디스크립터가 상기 텐서 데이터의 어드레스를 지향하는 경우, 디스크립터의 콘텐츠는 상기 텐서 데이터의 어드레스를 나타내는 하나의 어드레스 파라미터, 예를 들어 텐서 데이터의 시작 물리 어드레스를 포함할 수 있고, 상기 텐서 데이터 어드레스의 다수의 어드레스 파라미터, 예를 들어 텐서 데이터의 시작 어드레스+어드레스 오프셋을 포함할 수도 있으며, 또는 텐서 데이터는 각 차원의 어드레스 파라미터를 바탕으로 한다. 당업자라면 실제 필요에 따라 어드레스 파라미터를 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 상 기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함한다. 그 중, 기준 어드레스는 데이터 기준점 의 변화에 따라 달라진다. 본 발명은 데이터 기준점의 선택에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 기준 어드레스는 상기 데이터 저장공간의 시작 어드레스를 포함할 수 있다. 디스크립터의 데이터 기준점이 데이터 저장공간의 첫 번째 데이터블록일 때, 디스크립터의 기준 어드레스는 즉데이터 저장공간의 시작 어드레스이다. 디스크립터의 데이터 기준점이 데이터 저장공간 중 첫 번째 데이터블록 이외의 다른 데이터인 경우, 디스크립터의 기준 어드레스는 즉 상기 데이터블록의 데이터 저장공간 중에서의 물 리 어드레스이다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 크기, N개 차원 방향 의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. 그 중, 데이터 디스크립션 위치는 디스크립터가 지시하 는 텐서 데이터 중의 점 또는 영역의 매핑 위치이며, 예를 들어 텐서 데이터가 3차원 데이터이면, 디스크립터는 3차원 공간 좌표(x, y, z)를 사용하여 상기 텐서 데이터의 형상을 나타낼 수 있으며, 상기 텐서 데이터의 데이 터 디스크립터의 위치는 3차원 공간 좌표(x, y, z)로 표시될 수 있고, 상기 텐서 데이터는 3차원 공간 중의 점 또는 영역의 위치에 매핑된다. 이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 텐서 데이터를 나타내는 형상 파라미터를 선택할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 데이터 액세스 과정에서 디스크립터를 사용하는 방식을 통해 데이터 간의 관련성을 구축할 수 있으며, 이에 따 라 데이터 액세스의 복잡도가 감소되고, 명령 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 디스크립터의 데이터 기준점의 상기 텐서 데이터의 데이터 저장공간 중에서 의 기준 어드레스, N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적 어도 한 방향상에서의 상기 저장영역의 크기 및/또는 N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋에 따라 상기 텐서 데이터의 디스크립터 콘텐츠를 결정할 수 있다. 도 2는 본 발명의 일 실시예에 따른 데이터 저장공간의 설명도이다. 도 2에 도시된 바와 같이, 데이터 저장공간 은 우선적인 방식으로 2차원 데이터가 저장되며, (x, y)를 통해 표시한다(그 중, X축은 수평으로 우측을 향 하고, Y축은 수직으로 아래를 향한다). X축 방향상의 크기(매 행의 크기)는 ori_x이고(미도시), Y 축의 방향상 의 크기(총 행수)는 ori_y이며(미도시), 데이터 저장공간의 시작 어드레스 PA_start(기준 어드레스)는 첫 번째 데이터블록의 물리 어드레스이다. 데이터블록은 데이터 저장공간 중의 일부 데이터로서, 그것 의 X축 방향상의 오프셋은 offset_x로 표시하고, Y축 방향상의 오프셋은 offset_y로 표시하며, X축 방 향상의 크기는 size_x로 표시하고, Y축 방향상의 크기는 size_y로 표시한다. 일종의 가능한 구현 방식에서, 디스크립터를 사용하여 데이터블록을 정의 시, 디스크립터의 데이터 기준점 은 데이터 저장공간의 첫 번째 데이터블록을 사용할 수 있으며, 디스크립터의 기준 어드레스는 데이터 저장 공간의 시작 어드레스(PA_start)이다. 이후 데이터 저장공간의 X축상에서의 크기(ori_x), Y축 상에서의 크기(ori_y), 및 데이터블록의 Y축 방향상의 오프셋(offset_y), X축 방향상의 오프셋(offset_x), X축 방향 상의 크기(size_x) 및 Y축 방향상의 크기(size_y)를 결합하여 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "이해하여야 할 점으로, 비록 상기 예시에서, 디스크립터가 설명하는 것은 이차원 공간이나, 당업자라면 실제 상 황에 따라 디스크립터의 콘텐츠가 나타내는 구체적인 차원을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두 지 않는다. 일종의 가능한 구현방식에서, 상기 디스크립터의 데이터 기준점의 상기 데이터 저장공간 중에서의 기준 어드레 스, N개 차원 방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치에 따라, 상기 텐서 데이터의 디스크립터의 콘텐츠를 결정할 수 있다. 예를 들어 설명하면, 디스크립터의 데이터 기준점의 데이터 저장공간 중에서의 기준 어드레스(PA_base), 및 대 각 위치의 2개의 꼭지점의 데이터 기준점에 대한 위치를 사용하여, 도 2 중 데이터블록의 디스크립터의 콘 텐츠를 결정할 수 있다. 먼저, 디스크립터의 데이터 기준점 및 그것의 데이터 저장공간 중에서의 기준 어드레스 (PA_base)를 결정한다. 예를 들어, 데이터 저장공간에서 하나의 데이터(예를 들어 위치가 (2,2)인 데이터) 를 선택하여 데이터 기준점으로 삼고, 데이터 저장공간 중에서 상기 데이터의 물리 어드레스를 기준 어드레스(PA_base)로 삼은 다음; 데이터블록의 대각 위치의 적어도 2개의 꼭지점의 데이터 기준점에 대한 위치를 결 정한다. 예를 들어 좌상으로부터 우하 방향인 대각 위치의 꼭지점의 데이터 기준점에 대한 위치를 사용하며, 그 중 좌상각 꼭지점의 상대위치는 (x_min，y_min)이고, 우하각 꼭지점의 상대 위치는 (x_max，y_max)이며, 이후 기준 어드레스(PA_base), 좌상각 꼭지점의 상대 위치(x_min，y_min) 및 우하각 꼭지점의 상대 위치(x_max， y_max)에 따라 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 를 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 10, "content": "이해해두어야 할 점으로, 비록 상기 예시에서 좌상각과 우하각 2개의 꼭지점을 사용하여 디스크립터의 콘텐츠를 결정하였으나, 당업자라면 실제 필요에 따라 적어도 2개의 꼭지점 중 구체적인 꼭지점을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 디스크립터의 데이터 기준점의 상기 데이터 저장공간 중에서의 기준 어드레 스, 및 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 에 따라, 상기 텐서 데이터의 디스크립터의 콘텐츠를 결정할 수 있다. 그 중, 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계는 실제 필요에 따라 설정할 수 있으며, 예를 들어, 디스크립터가 지시하는 텐서 데이 터가 3차원 공간 데이터인 경우, 함수 를 사용하여 데이터 디스크립션 위치와 데이터 어드레스 간의 매 핑 관계를 정의할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 11, "content": "이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계를 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 실행유닛이 제어유닛이 송신한 디스크립터의 콘텐츠 및 제1 처리 명령을 수신 시, 디스크립터의 콘텐츠에 따라, 제1 처리 명령의 피연산자에 대응되는 데이터의 데이터 저장공간 중에서 의 데이터 어드레스를 결정할 수 있다. 그 중, 데이터 어드레스의 계산은 하드웨어를 통해 자동으로 완료하며, 또한 디스크립터 콘텐츠의 표시 방식이 다를 경우, 데이터 어드레스의 계산 방법 역시 달라질 수 있다. 본 발명 은 데이터 어드레스의 구체적인 계산 방법에 대해서는 제한을 두지 않는다. 예를 들어, 피연산자 중 디스크립터의 콘텐츠는 공식 로 나타내며, 디스크립터가 지시하는 텐서 데이터의 데 이터 저장공간 중에서의 오프셋이 각각 offset_x와 offset_y이고, 크기는 size_x*size_y라면, 상기 디스크립터 가 지시하는 텐서 데이터의 데이터 저장공간 중에서의 시작 데이터 어드레스( )는 하기 공식을 사용하여 결정할 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 12, "content": "상기 공식 에 따라 결정된 데이터 시작 어드레스( )에, 오프셋 offset_x와 offset_y, 및 저장영역의 크 기 size_x와 size_y를 결합하면, 디스크립터가 지시하는 텐서 데이터의 데이터 저장공간 중에서의 저장영역을 결정할 수 있다. 일종의 가능한 구현 방식에서, 실행유닛은 제어유닛이 송신한 디스크립터의 콘텐츠 및 제1 처리 명령을 수신하며, 피연산자에 디스크립터에 대한 데이터 디스크립션 위치가 더 포함되어 있는 경우, 디스크립터의 콘텐 츠 및 데이터 디스크립션 위치에 따라, 피연산자에 대응되는 데이터의 데이터 저장공간 중에서의 데이터 어드레 스를 결정할 수 있다. 이러한 방식을 통해, 디스크립터가 지시하는 텐서 데이터 중의 일부 데이터(예를 들어 하 나 또는 다수의 데이터)에 대해 처리를 수행할 수 있다. 예를 들어, 피연산자 중 디스크립터의 콘텐츠는 공식 을 사용하여 나타내며, 디스크립터가 지시하는 텐서 데 이터의 데이터 저장공간 중에서의 오프셋이 각각 offset_x와 offset_y이고, 크기는 size_x*size_y이며, 피연산 자에 포함된 디스크립터에 대한 데이터 디스크립션 위치가 이면, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 저장공간 중에서의 데이터 어드레스( )는 하기 공식 를 사용하여 결정할 수 있다."}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 13, "content": "일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데 이터와 타겟 데이터를 포함하며, 그 중, 상기 제어유닛(11b)은 상기 소스 데이터에 제1 디스크립터의 식별자가 포함되고, 또한 상기 타겟 데이터 에 제2 디스크립터의 식별자가 포함 시, 상기 디스크립터 저장공간으로부터 상기 제1 디스크립터의 콘텐츠와 상 기 제2 디스크립터의 콘텐츠를 각각 획득하고; 상기 실행유닛(12b)으로 상기 제1 디스크립터의 콘텐츠, 상기 제 2 디스크립터의 콘텐츠 및 상기 제1 처리 명령을 전송하며; 그 중, 상기 실행유닛(12b)은 수신된 상기 제1 디스크립터의 콘텐츠와 상기 제2 디스크립터의 콘텐츠에 따라, 상기 소스 데이터의 제1 데이터 어드레스와 상기 타겟 데이터의 제2 데이터 어드레스를 각각 획득하고; 상기 제 1 데이터 어드레스로부터 데이터를 독취하여 상기 제2 데이터 어드레스에 입력한다. 예를 들어 설명하면, 소스 데이터와 타겟 데이터에 모두 디스크립터의 식별자가 포함되어 있는 경우, 소스 데이 터는 오프칩의 한 그룹의 독취할 데이터일 수 있고, 그 첫 번째 디스크립터의 식별자는 1이며, 타겟 데이터는 온칩인 하나의 저장공간이고, 그 두 번째 디스크립터의 식별자는 2이다. 제어유닛(11b)은 소스 데이터 중 제1 디스크립터의 식별자 1 및 타겟 데이터 중 제2 디스크립터의 식별자 2에 따라, 디스크립터 저장공간으로부터 제 1 디스크립터의 콘텐츠(D1)과 제2 디스크립터의 콘텐츠(D2)을 각각 획득하고, 제1 디스크립터의 콘텐츠(D1), 제 2 디스크립터의 콘텐츠(D2) 및 제1 처리 명령을 실행유닛(12b)으로 전송한다. 그 중, 제1 디스크립터의 콘텐츠 (D1)과 제2 디스크립터의 콘텐츠(D2)은 각각 다음과 같이 나타낼 수 있다: D1:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 14, "content": "D2:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 15, "content": "실행유닛(12b)은 수신된 제1 디스크립터의 콘텐츠(D1)과 제2 디스크립터의 콘텐츠(D2)에 따라, 소스 데이터의 시작 물리 어드레스(PA3)와 타겟 데이터의 시작 물리 어드레스(PA4)를 각각 획득할 수 있으며, 각각 다음과 같 이 나타낸다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 16, "content": "실행유닛(12b)은 소스 데이터의 시작 물리 어드레스(PA3)와 타겟 데이터의 시작 물리 어드레스(PA4), 및 제1 디 스크립터의 콘텐츠(D1)과 제2 디스크립터의 콘텐츠(D2)에 따라, 제1 데이터 어드레스와 제2 데이터 어드레스를 각각 결정한 후, 제1 데이터 어드레스로부터 데이터를 독취하여 제2 데이터 어드레스에 입력함으로써(IO 채널을 통할 수 있다), D1이 지향하는 텐서 데이터를 D2가 지향하는 저장공간에 로드(load)할 수 할 수 있으며, 즉, 오 프칩으로부터 온칩으로의 데이터의 로드를 완료한다. 이해하여야 할 점으로, 온칩으로부터 오프칩으로의 데이터 의 전송은 상기 과정과 유사하므로, 여기서는 중복 설명을 생략한다. 일종의 가능한 구현 방식에서, 데이터를 로드 시 로드 데이터의 규모를 설정할 수 있으며, 그 중, 로드 데이터 의 규모는 사용의 필요 또는 저장공간의 크기에 따라 설정할 수 있다. 예를 들어, 사용의 필요에 따라, 데이터 를 로드 시, D1에 로드되는 이전 10개의 데이터를 설정할 수 있으며, 본 발명은 로드 데이터의 구체적인 규모에 대해서는 제한을 두지 않는다. 이러한 방식을 통해 디스크립터를 사용하여 데이터의 액세스를 완료하고, 디스크립터의 콘텐츠를 디스크립터 저 장공간에 저장할 수 있으며, 매번 액세스할 때마다 명령을 통해 데이터 어드레스에 입력할 필요가 없어, 프로세 서의 데이터 액세스 효율이 향상될 수 있다.일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데 이터와 타겟 데이터를 포함한다. 그 중, 상기 제어유닛(11b)은 상기 소스 데이터에 제3 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크 립터 저장공간으로부터 상기 제3 디스크립터의 콘텐츠를 획득하고; 상기 실행유닛으로 상기 제3 디스크립터 의 콘텐츠 및 상기 제1 처리 명령을 전송하기 위한 것이고; 그 중, 상기 실행유닛(12b)은 수신된 상기 제3 디스크립터의 콘텐츠에 따라, 상기 소스 데이터의 제3 데이터 어 드레스를 획득하여; 상기 제3 데이터 어드레스로부터 데이터를 독취하여 상기 타겟 데이터의 데이터 어드레스에 기입하기 위한 것이다. 예를 들어 설명하면, 소스 데이터와 타겟 데이터에 모두 디스크립터의 식별자가 포함되어 있는 경우, 소스 데이 터는 오프칩의 한 그룹의 독취할 데이터일 수 있고, 그 첫 번째 디스크립터의 식별자는 3이며, 타겟 데이터는 온칩인 하나의 저장공간이다. 제어유닛(11b)은 소스 데이터 중 제3 디스크립터의 식별자 3에 따라, 디스크립터 저장공간으로부터 제3 디스크립터의 콘텐츠(D3)을 획득하고, 제3 디스크립터의 콘텐츠(D3) 및 제1 처리 명령을 실행유닛(12b)으로 전송한다. 그 중, 제3 디스크립터의 콘텐츠(D3)은 다음과 같이 나타낼 수 있다: D3:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 17, "content": "실행유닛(12b)은 수신된 제3 디스크립터의 콘텐츠(D3)에 따라, 소스 데이터의 시작 물리 어드레스(PA5)를 획득 할 수 있으며, 다음과 같이 나타낸다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 18, "content": "실행유닛(12b)은 제1 처리 명령 중 타겟 데이터의 어드레스 정보에 따라, 타겟 데이터의 시작 물리 어드레스 및 타겟 데이터의 데이터 어드레스를 계산할 수 있다. 예를 들어 타겟 데이터의 어드레스 정보에 시작 어드레스, 오프셋의 범용 레지스터 번호가 포함되어, 먼저 범용 레지스터에 액세스하여 오프셋을 획득한 다음, 시작 어드 레스와 오프셋을 서로 더하여 타겟 데이터의 시작 물리 어드레스를 획득하고; 이후 타겟 데이터의 크기에 따라 타겟 데이터의 데이터 어드레스를 결정할 수 있다. 실행유닛(12b)은 소스 데이터의 시작 물리 어드레스(PA5) 및 제3 디스크립터의 콘텐츠(D3)에 따라, 제3 데이터 어드레스를 결정한 후 제3 데이터 어드레스로부터 데이터를 독취하여 타겟 데이터의 데이터 어드레스에 입력함 으로써(IO 채널을 통할 수 있다), D3가 지향하는 텐서 데이터를 타겟 데이터의 저장공간에 로드할 수 있으며, 즉 오프칩으로부터 온칩으로의 데이터의 로드(load)를 완료한다. 이해하여야 할 점으로, 온칩으로부터 오프칩으 로의 데이터의 전송은 상기 과정과 유사하므로, 여기서는 중복 설명을 생략한다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데 이터와 타겟 데이터를 포함한다. 그 중, 상기 제어유닛(11b)은 상기 타겟 데이터에 제4 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크 립터 저장공간으로부터 상기 제4 디스크립터의 콘텐츠를 획득하여; 상기 실행유닛으로 상기 제4 디스크립터 의 콘텐츠 및 상기 제1 처리 명령을 전송하기 위한 것이고; 그 중, 상기 실행유닛(12b)은 수신된 상기 제4 디스크립터의 콘텐츠에 따라, 상기 타겟 데이터의 제4 데이터 어 드레스를 획득하고; 상기 소스 데이터의 데이터 어드레스로부터 데이터를 독취하여 상기 제4 데이터 어드레스에 입력하기 위한 것이다. 예를 들어 설명하면, 타겟 데이터에 디스크립터의 식별자가 포함되어 있는 경우, 소스 데이터는 오프칩의 한 그 룹의 독취할 데이터일 수 있고, 타겟 데이터는 온칩인 하나의 저장공간이고, 그 제4 디스크립터의 식별자는 4이 다. 제어유닛(11b)은 타겟 데이터 중 제4 디스크립터의 식별자 4에 따라, 디스크립터 저장공간으로부터 제4 디 스크립터의 콘텐츠(D4)을 획득하고, 제4 디스크립터의 콘텐츠(D4) 및 제1 처리 명령을 실행유닛(12b)으로 전송 한다. 그 중, 제4 디스크립터의 콘텐츠(D4)은 다음과 같이 나타낼 수 있다:D4:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 19, "content": "실행유닛(12b)은 수신된 제4 디스크립터의 콘텐츠(D4)에 따라, 타겟 데이터의 시작 물리 어드레스(PA6)를 획득 할 수 있으며, 다음과 같이 나타낸다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 20, "content": "실행유닛(12b)은 제1 처리 명령 중 소스 데이터의 어드레스 정보에 따라, 소스 데이터의 시작 물리 어드레스 및 소스 데이터의 데이터 어드레스를 계산할 수 있다. 예를 들어 소스 데이터의 어드레스 정보에 시작 어드레스, 오프셋의 범용 레지스터 번호가 포함되어, 먼저 범용 레지스터에 액세스하여 오프셋을 획득한 다음, 시작 어드 레스와 오프셋을 서로 더하여 소스 데이터의 시작 물리 어드레스를 획득하고; 이후 소스 데이터의 크기에 따라 소스 데이터의 데이터 어드레스를 결정할 수 있다. 실행유닛(12b)은 타겟 데이터의 시작 물리 어드레스(PA6) 및 제4 디스크립터의 콘텐츠(D4)에 따라, 제4 데이터 어드레스를 결정한 후 소스 데이터의 데이터 어드레스로부터 데이터를 독취하여 제4 데이터 어드레스에 입력함 으로써(IO 채널을 통할 수 있다), 소스 데이터를 D4가 지향하는 저장공간에 로드할 수 있으며, 즉 오프칩으로부 터 온칩으로의 데이터의 로드(load)를 완료한다. 이해하여야 할 점으로, 온칩으로부터 오프칩으로의 데이터의 전송은 상기 과정과 유사하므로, 여기서는 중복 설명을 생략한다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 연산 명령을 포함하며, 그 중, 상기 실행유닛이 상기 데이 터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계는, 상기 데이터 어드레스로 부터 데이터를 독취하여 상기 연산 명령에 대응되는 연산을 실행하는 단계를 포함할 수 있다. 예를 들어 설명하면, 제1 처리 명령이 연산 명령이고, 연산 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 제어유닛은 디스크립터의 식별자에 따라, 디스크립터 저장공간으로부터 디스크립터의 콘텐츠를 획득하고, 디스크립터의 콘텐츠 및 연산 명령을 실행유닛으로 전송할 수 있으며; 실행유닛은 수신된 디 스크립터의 콘텐츠에 따라 연산할 데이터의 데이터 어드레스를 결정하고, 상기 데이터 어드레스로부터 연산할 데이터를 독취하여, 연산 명령에 대응되는 연산을 실행한다. 예를 들어, 연산 명령이 ADD 명령이고, 그 피연산 자에 디스크립터의 식별자가 포함되어 있는 경우, 제어유닛은 디스크립터의 식별자에 따라 디스크립터의 콘 텐츠를 획득하고, 디스크립터의 콘텐츠 및 ADD 명령을 실행유닛(12b)으로 전송할 수 있고, 실행유닛(12b)은 디 스크립터의 콘텐츠에 따라 연산할 데이터의 데이터 어드레스를 결정하여, ADD 연산을 실행할 수 있다. 피연산자 가 오프칩 데이터인 경우, 실행유닛(12b)은 데이터 어드레스에 따라, IO 채널을 통해 데이터를 온칩에 로드한 후, 피연산자의 온칩상의 데이터 어드레스로부터 데이터를 독취하여 ADD 연산을 실행할 수 있다. 이러한 방식을 통해, 디스크립터를 사용하여 데이터의 전송을 완료할 수 있어 프로세서의 데이터 액세스 효율 이 향상된다. 본 발명의 실시예의 데이터 처리장치에 따르면, 데이터의 형상을 기술할 수 있는 디스크립터를 도입하여, 제1 처리 명령의 운행 과정에서 디스크립터를 통해 데이터의 어드레스를 결정할 수 있으며, 하드웨어 측면에서 명령 생성 방식을 단순화함으로써, 데이터 액세스의 복잡도가 감소되고, 프로세서의 데이터 액세스 효율이 향상된다. 설명해두어야 할 점으로, 비록 이상의 실시예를 예시로서 데이터 처리장치를 위와 같이 소개하였으나, 단 당업 자라면, 본 발명이 이에 한정되지 않는다는 것을 이해할 것이다. 사실상, 사용자는 개인의 선호 및/또는 실제 응용 상황에 따라 각 모듈을 완전히 자유롭게 설정할 수 있으며, 본 발명의 기술방안에 부합되기만 하면 된다. 도 3b는 본 발명의 실시예에 따른 데이터 처리방법의 흐름도이다. 도 3b에 도시된 바와 같이, 상기 데이터 처리 방법은 프로세서에 응용되며, 상기 방법은 이하 단계를 포함한다: 단계 S41b: 디코딩 후의 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함 되어 있는 경우, 상기 디스크립터의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하고; 단계 S42b: 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응되는 데이터의 데이터 저 장공간 중에서의 데이터 어드레스를 결정하며;단계 S43b: 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행한다. 일종의 가능한 구현 방식에서, 단계 S42b는 상기 피연산자에 상기 디스크립터에 대한 데이터 디스크립션 위치가 더 포함되어 있는 경우, 상기 디스크립터의 콘텐츠 및 상기 데이터 디스크립션 위치에 따라, 상기 피연산자에 대응되는 데이터의 상기 데이터 저장공간 중 에서의 데이터 어드레스를 결정하는 단계를 포함할 수 있다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것으로서, N은 양의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 더 포함한다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 상 기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함하고; 그 중, 상기 텐서 데이터의 형상 파라미터는 N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 의 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한 다. 일종의 가능한 구현 방식에서, 상기 기준 어드레스는 상기 데이터 저장공간의 시작 어드레스를 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데 이터와 타겟 데이터를 포함하며, 그 중, 디코딩 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 단계 S41b는, 상 기 소스 데이터에 제1 디스크립터의 식별자가 포함되고, 상기 타겟 데이터에 제2 디스크립터의 식별자가 포함되 어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 제1 디스크립터의 콘텐츠와 상기 제2 디스크립터의 콘텐 츠를 각각 획득하는 단계를 포함할 수 있으며; 그 중, 단계 S42b는 상기 제1 디스크립터의 콘텐츠와 상기 제2 디스크립터의 콘텐츠에 따라, 상기 소스 데이터 의 제1 데이터 어드레스와 상기 타겟 데이터의 제2 데이터 어드레스를 각각 획득하는 단계를 포함하고; 그 중, 단계 S43b는 상기 제1 데이터 어드레스로부터 데이터를 독취하여 상기 제2 데이터 어드레스에 입력하는 단계를 포함할 수 있다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데 이터와 타겟 데이터를 포함하며, 그 중, 디코딩 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 단계 S41b는, 상 기 소스 데이터에 제3 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 제3 디스크립터의 콘텐츠를 획득하는 단계를 포함할 수 있으며; 그 중, 단계 S42b는 상기 제3 디스크립터의 콘텐츠에 따라, 상기 소스 데이터의 제3 데이터 어드레스를 획득하 는 단계를 포함하고; 그 중, 단계 S43b는 상기 제3 데이터 어드레스로부터 데이터를 독취하여 상기 타겟 데이터의 데이터 어드레스에 입력하는 단계를 포함할 수 있다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데 이터와 타겟 데이터를 포함하며, 그 중, 디코딩 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 단계 S41b는, 상 기 타겟 데이터에 제4 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 제4디스크립터의 콘텐츠를 획득하는 단계를 포함할 수 있으며; 그 중, 단계 S42b는 상기 제4 디스크립터의 콘텐츠에 따라, 상기 타겟 데이터의 제4 데이터 어드레스를 획득하 는 단계를 포함하고; 그 중, 단계 S43b는 상기 소스 데이터의 데이터 어드레스로부터 데이터를 독취하여 상기 제4 데이터 어드레스에 입력하는 단계를 포함할 수 있다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령은 연산 명령을 포함하고, 그 중, 단계 S43b는 상기 데이터 어드레스로부터 데이터를 독취하여 상기 연산 명령에 대응되는 연산을 실행하 는 단계를 포함할 수 있다. 일종의 가능한 구현 방식에서, 상기 방법은 수신된 제1 처리 명령에 대해 디코딩 처리를 수행하여, 디코딩 후의 제1 처리 명령을 획득하는 단계를 더 포함 하며, 그 중, 디코딩 후의 제1 처리 명령은 상기 제1 처리 명령에 대응되는 처리 유형을 지시하기 위한 연산코드 및 하나 또는 다수의 피연산자를 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 저장공간은 상기 프로세서의 내부 메모리 중의 저장공간이고, 상기 데이터 저장공간은 상기 프로세서의 내부 메모리 또는 외부 메모리 중의 저장공간이다. 일종의 가능한 구현 방식에서, 상기 데이터 처리장치를 포함하는 인공지능 칩을 더 공개한다. 일종의 가능한 구현 방식에서, 메모리 소자, 인터페이스 장치와 제어 소자 및 상기 인공지능 칩을 포함하는 보 드를 더 공개하며; 그 중, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩 과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터 링하기 위한 것이다. 도 4는 본 발명의 실시예에 따른 보드의 구조 블록도로서, 도 4를 참조하면, 상기 보드는 상기 칩 이외에, 메모리 소자, 인터페이스 장치와 제어 소자를 포함하되, 단 이에 한정되지 않는 기타 보조 부재 를 더 포함할 수 있으며; 상기 메모리 소자와 상기 인공지능 칩은 버스를 통해 연결되어 데이터를 저장하는데 사용된다. 상기 메모 리 소자는 다수 그룹의 저장유닛을 포함할 수 있다. 각 그룹의 상기 저장유닛과 상기 인공지능 칩은 버스 를 통해 연결된다. 각 그룹의 상기 저장유닛은 DDR SDRAM(영문: Double Data Rate SDRAM, 2배속 동기식 동적 랜덤 메모리)일 수 있음은 이해할 수 있을 것이다. DDR은 클럭 주파수를 높일 필요 없이 SDRAM의 속도를 배가시킬 수 있다. DDR은 클럭 펄스의 상승 에지(rising edge)와 하강 에지(falling edge)에서 데이터를 읽도록 허용한다. DDR의 속도는 표준 SDRAM의 2배이다. 일 실시 예에서, 상기 저장장치는 4개 그룹의 상기 저장유닛을 포함할 수 있다. 각 그룹의 상기 저장유닛은 다수의 DDR4(칩)를 포함할 수 있다. 일 실시예에서, 상기 인공지능 칩의 내부에 4개의 72비트의 DDR4 컨트롤러가 포함 될 수 있으며, 상기 72비트 DDR4 컨트롤러 중 64비트는 데이터 전송에 사용되고, 8비트는 ECC 검출교정에 사용 된다. 각 그룹의 상기 저장장치에 DDR4-3200 칩을 사용할 경우, 데이터 전송의 이론 밴드폭이 25600MB/s에 달할 수 있음을 이해할 수 있을 것이다. 일 실시예에서, 각 그룹의 상기 저장유닛은 다수의 병렬 설치되는 2배속 동기식 동적 랜덤 메모리를 포함한다. DDR은 하나의 클럭 주기 내에서 데이터를 2회 전송할 수 있다. 상기 칩에 DDR을 제어하는 컨트롤러가 설치되어, 각각의 상기 저장유닛에 대한 데이터의 전송과 데이터의 저장을 제어한다. 상기 인터페이스 장치는 상기 인공지능 칩과 전기적으로 연결된다. 상기 인터페이스 장치는 상기 인공지능 칩과 외부 장치(예를 들어 서버 또는 컴퓨터) 간의 데이터 전송을 구현하기 위한 것이다. 예를 들어 일 실시예에서, 상기 인터페이스 장치는 표준 PCIE 인터페이스일 수 있다. 예컨대, 처리할 데이터가 서버로부터 표준 PCIE 인터 페이스를 통해 상기 칩에 전송되어 데이터의 이동을 구현한다. 바람직하게는 PCIE 3.0 X 16 인터페이스로 전송 시, 이론 대역폭은 16000MB/s에 달할 수 있다. 다른 일 실시예에서, 상기 인터페이스 장치는 다른 인터페이스일 수도 있다. 본 출원은 상기 다른 인터페이스의 구체적인 표현 형식을 제한하지 않으며, 상기 인터페이스 유닛이전달 기능을 구현할 수만 있으면 된다. 또한, 상기 인공지능 칩의 계산 결과 역시 상기 인터페이스장치에 의해 외부 장치(예를 들어 서버)로 전송된다. 상기 제어 소자는 상기 인공지능 칩과 전기적으로 연결된다. 상기 제어 소자는 상기 인공지능 칩의 상태를 모니 터링하기 위한 것이다. 구체적으로, 상기 인공지능 칩과 상기 제어 소자는 SPI 인터페이스를 통해 전기적으로 연결된다. 상기 제어 소자는 마이크로컨트롤러(Micro Controller Unit，MCU)를 포함할 수 있다. 상기 인공지능 칩은 다수의 프로세서 칩, 다수의 프로세서 코어 또는 다수의 처리회로를 포함할 수 있으며, 다수의 부하를 구 동시킬 수 있다. 따라서, 상기 인공지능 칩은 다부하와 경부하 등 상이한 작동 상태에 처할 수 있다. 상기 제어 장치를 통해 상기 인공지능 칩 중 다수의 프로세서 칩, 다수의 프로세서 코어 또는 다수의 처리회로의 작동 상 태의 제어를 구현할 수 있다. 일종의 가능한 구현 방식에서, 상기 인공지능 칩을 포함하는 전자장치를 공개한다. 전자장치는 데이터 처리장치, 로봇, 컴퓨터, 프린터, 스캐너, 태블릿 컴퓨터, 스마트 단말, 핸드폰, 주행기록장치, 네비게이션, 센 서, 웹캠, 서버, 클라우드 서버, 카메라, 비디오카메라, 영사기, 손목시계, 이어폰, 이동식 메모리, 웨어러블장 치, 교통수단, 가정용 전자제품, 및/또는 의료장치를 포함한다. 상기 교통수단은 비행기, 선박 및/또는 차량을 포함하며; 상기 가정용 전자제품은 TV, 에어콘, 전자레인지, 냉 장고, 전기밥솥, 가습기, 세탁기, 전등, 가스레인지, 환풍기를 포함하고; 상기 의료장치는 핵자기공명장치, B형 초음파기 및/또는 심전도기를 포함한다. A1: 데이터 처리장치에 있어서, 상기 장치는 제어유닛과 실행유닛을 포함하고, 상기 제어유닛은 디코딩 후의 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하고; 상기 실행유닛으로 상기 디스크립터의 콘텐츠 및 상기 제1 처리 명령을 전송하여, 상기 실행유닛이 상기 디스크 립터의 콘텐츠에 따라 상기 제1 처리 명령을 실행하도록 하기 위한 것이다. A2: A1항에 따른 장치에 있어서, 상기 실행유닛은 수신된 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응되는 데이터의 데이터 저장공간 중 에서의 데이터 어드레스를 결정하고; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하기 위한 것이다. A3: A2항에 따른 장치에 있어서, 수신된 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응되 는 데이터의 데이터 저장공간 중에서의 데이터 어드레스를 결정하는 단계는, 상기 피연산자에 상기 디스크립터에 대한 데이터 디스크립션 위치가 더 포함되는 경우, 상기 디스크립터의 콘텐 츠 및 상기 데이터 디스크립션 위치에 따라, 상기 피연산자에 대응되는 데이터의 상기 데이터 저장공간 중에서 의 데이터 어드레스를 결정하는 단계를 포함한다. A4: A1-A3 중의 어느 한 항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것이고, N은 양의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A5: A4항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파 라미터를 포함한다. A6: A5항에 따른 장치에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 상기 텐서 데이터의 데이터 저장공간 중에서의 기준 위치를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미터는 N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시 하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. A7: A6항에 따른 장치에 있어서, 상기 기준 어드레스는 상기 데이터 저장공간의 시작 어드레스를 포함한다. A8: A2-A7 중의 어느 한 항에 따른 장치에 있어서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데이터와 타겟 데이터를 포함하며, 그 중, 제어유닛은 상기 소스 데이터에 제1 디스크립터의 식별자가 포함되고, 상기 타겟 데이터에 제2 디스크립터의 제2 식별자가 포함되어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 제1 디스크립터의 콘텐츠와 상기 제2 디스크립터 의 콘텐츠를 각각 획득하고; 상기 실행유닛으로 상기 제1 디스크립터의 콘텐츠, 상기 제2 디스크립터의 콘텐츠 및 상기 제1 처리 명령을 전 송하기 위한 것이고; 그 중, 상기 실행유닛은 수신된 상기 제1 디스크립터의 콘텐츠와 상기 제2 디스크립터의 콘텐츠에 따라, 상기 소스 데이터의 제1 데이터 어드레스와 상기 타겟 데이터의 제2 데이터 어드레스를 각각 획득하고; 상기 제1 데이터 어드레스로부터 데이터를 독취하여 상기 제2 데이터 어드레스에 입력하기 위한 것이다. A9: A2-A7 중의 어느 한 항에 따른 장치에 있어서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데이터와 타겟 데이터를 포함하며, 그 중, 상기 제어유닛은 상기 소스 데이터에 제3 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 제3 디스크립터의 콘텐츠를 획득하고; 상기 실행유닛으로 상기 제3 디스크립터의 콘텐츠 및 상기 제1 처리 명령을 전송하기 위한 것이고; 그 중, 상기 실행유닛은 수신된 상기 제3 디스크립터의 콘텐츠에 따라, 상기 소스 데이터의 제3 데이터 어드레스를 획득하고; 상기 제3 데이터 어드레스로부터 데이터를 독취하여 상기 타겟 데이터의 데이터 어드레스에 입력하기 위한 것이다. A10: A2-A7 중의 어느 한 항에 따른 장치에 있어서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상 기 피연산자는 소스 데이터와 타겟 데이터를 포함하며, 그 중, 상기 제어유닛은 상기 타겟 데이터에 제4 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 제4 디스크립터의 콘텐츠를 획득하고; 상기 실행유닛으로 상기 제4 디스크립터의 콘텐츠 및 상기 제1 처리 명령을 전송하기 위한 것이며; 그 중, 상기 실행유닛은 수신된 상기 제4 디스크립터의 콘텐츠에 따라, 상기 타겟 데이터의 제4 데이터 어드레스를 획득하고; 상기 소스 데이터의 데이터 어드레스로부터 데이터를 독취하여 상기 제4 데이터 어드레스에 입력하기 위한 것이다. A11: A2항에 따른 장치에 있어서, 상기 제1 처리 명령은 연산 명령을 포함하며, 그 중, 상기 실행유닛이 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계는, 상기 데이터 어드레스로부터 데이터를 독취하여 상기 연산 명령에 대응되는 연산을 실행시키는 단계를 포함한다. A12: A1-A11 중의 어느 한 항에 따른 장치에 있어서, 상기 제어유닛은 또한 수신된 제1 처리 명령에 대해 디코딩 처리를 수행하여, 디코딩 후의 제1 처리 명령을 획득하기 위한 것이며, 그 중, 디코딩 후의 제1 처리 명령은 상기 제1 처리 명령에 대응되는 처리 유형을 지시하기 위한 연산코드 및 하나 또는 다수의 피연산자를 포함한다. A13: A1-A12 중의 어느 한 항에 따른 장치에 있어서, 상기 디스크립터 저장공간은 상기 제어유닛의 내부 메모리 중의 저장공간이고, 상기 데이터 저장공간은 상기 제어유닛의 내부 메모리 또는 상기 제어유닛과 연결되는 외부 메모리 중의 저장공간이다. A14: 프로세서에 응용되는 데이터 처리방법에 있어서, 상기 방법은 디코딩 후의 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하는 단계; 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응하는 데이터의 데이터 저장공간 중에 서의 데이터 어드레스를 결정하는 단계; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행시키는 단계를 포함한다. A15: A14에 따른 방법에 있어서, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응하는 데이터의 데이터 저장공간 중에서의 데이터 어드레스를 결정하는 단계는, 상기 피연산자에 상기 디스크립터에 대한 데이터 디스크립션 위치가 더 포함되는 경우, 상기 디스크립터의 콘텐 츠 및 상기 데이터 디스크립션 위치에 따라, 상기 피연산자에 대응되는 데이터의 데이터 저장공간 중에서의 데 이터 어드레스를 결정하는 단계를 포함한다. A16: A14 또는 A15항에 따른 방법에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것이고, N은 양의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A17: A16항에 따른 방법에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되 며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터 를 더 포함한다. A18: A17항에 따른 방법에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점 의 상기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함하고; 그 중, 상기 텐서 데이터의 형상 파라미터는 N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시 하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. A19: A18항에 따른 방법에 있어서, 상기 기준 어드레스는 상기 데이터 저장공간의 시작 어드레스를 포함한다. A20: A14-A19 중의 어느 한 항에 따른 방법에 있어서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상기 피연산자는 소스 데이터와 타겟 데이터를 포함하며, 그 중, 디코딩 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하는 단계는, 상기 소스 데이 터에 제1 디스크립터의 식별자가 포함되고, 상기 타겟 데이터에 제2 디스크립터의 제2 식별자가 포함되어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 제1 디스크립터의 콘텐츠와 상기 제2 디스크립터의 콘텐츠를 각 각 획득하는 단계를 포함하며; 그 중, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응하는 데이터의 데이터 저장공 간 중에서의 데이터 어드레스를 결정하는 단계는, 상기 제1 디스크립터의 콘텐츠와 상기 제2 디스크립터의 콘텐 츠에 따라, 상기 소스 데이터의 제1 데이터 어드레스와 상기 타겟 데이터의 제2 데이터 어드레스를 각각 획득하는 단계를 포함하며; 그 중, 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계는, 상기 제 1 데이터 어드레스로부터 데이터를 독취하여 상기 제2 데이터 어드레스에 입력하는 단계를 포함한다. A21: A14-A19 중 어느 한 항에 따른 방법에 있어서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상 기 피연산자는 소스 데이터와 타겟 데이터를 포함하며, 그 중, 디코딩 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하는 단계는, 상기 소스 데이 터에 제3 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 제3 디스크립터 의 콘텐츠를 획득하는 단계를 포함하고; 그 중, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응하는 데이터의 데이터 저장공 간 중에서의 데이터 어드레스를 결정하는 단계는, 상기 제3 디스크립터의 콘텐츠에 따라, 상기 소스 데이터의 제3 데이터 어드레스를 획득하는 단계를 포함하며; 그 중, 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계는, 상기 제 3 데이터 어드레스로부터 데이터를 독취하여 상기 타겟 데이터의 데이터 어드레스에 입력하는 단계를 포함한다. A22: A14-A19 중 어느 한 항에 따른 방법에 있어서, 상기 제1 처리 명령은 데이터 액세스 명령을 포함하고, 상 기 피연산자는 소스 데이터와 타겟 데이터를 포함하며, 그 중, 디코딩 후의 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하는 단계는, 상기 타겟 데이 터에 제4 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터 저장공간으로부터 상기 제4 디스크립터 의 콘텐츠를 획득하는 단계를 포함하고; 그 중, 상기 디스크립터의 콘텐츠에 따라, 상기 제1 처리 명령의 피연산자에 대응하는 데이터의 데이터 저장공 간 중에서의 데이터 어드레스를 결정하는 단계는, 상기 제4 디스크립터의 콘텐츠에 따라, 상기 타겟 데이터의 제4 데이터 어드레스를 획득하는 단계를 포함하며; 그 중, 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계는, 상기 소 스 데이터의 데이터 어드레스로부터 데이터를 독취하여 상기 제4 데이터 어드레스에 입력하는 단계를 포함한다. A23: A14항에 따른 방법에 있어서, 상기 제1 처리 명령은 연산 명령을 포함하고, 그 중, 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계는, 상기 데이터 어드레스로부터 데이터를 독취하여 상기 연산 명령에 대응되는 연산을 실행하는 단계를 포함한다. A24: A14-A23 중 어느 한 항에 따른 방법에 있어서, 상기 방법은 수신된 제1 처리 명령에 대해 디코딩 처리를 수행하여, 디코딩 후의 제1 처리 명령을 획득하는 단계를 더 포함 하며, 그 중, 디코딩 후의 제1 처리 명령은 상기 제1 처리 명령에 대응되는 처리 유형을 지시하기 위한 연산코드 및 하나 또는 다수의 피연산자를 포함한다. A25: A14-A24 중 어느 한 항에 따른 방법에 있어서, 상기 디스크립터 저장공간은 상기 프로세서의 내부 메모리 중의 저장공간이고, 상기 데이터 저장공간은 상기 프로세서의 내부 메모리 또는 외부 메모리 중의 저장공간이다. A26: 인공지능 칩에 있어서, 상기 칩은 A1-A13 중의 어느 한 항에 따른 데이터 처리장치를 포함한다. A27: 전자장치에 있어서, 상기 전자장치는 A26항에 따른 인공지능 칩을 포함한다. A28: 보드에 있어서, 상기 보드는 메모리 소자, 인터페이스 장치와 제어 소자 및 A26항에 따른 인공지능 칩을 포함하며; 그 중, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터링하기 위한 것이다. A29: A28항에 따른 보드에 있어서, 상기 메모리 소자는 다수 그룹의 저장유닛을 포함하고, 각 그룹의 상기 저장유닛과 상기 신경망 칩은 버스를 통 해 연결되며, 상기 저장유닛은 DDR SDRAM이고; 상기 칩은 각각의 상기 저장유닛의 데이터 전송과 데이터 저장을 제어하기 위한 DDR 컨트롤러를 포함하며; 상기 인터페이스는 표준 PCIE 인터페이스이다. 인공지능 알고리즘의 복잡도가 증가함에 따라, 처리해야 할 데이터량과 데이터 차원이 모두 지속적으로 증가하 고 있으며, 통상적으로 다중 코어 및/또는 다중 칩으로 데이터 처리를 수행해야 한다. 코어간 또는 칩간의 데이 터 동기화를 수행 시, 관련 기술의 동기화 방식을 이용하는 동기화는 오버헤드(overhead)가 비교적 크고, 처리 효율이 낮다. 본 발명의 실시예에 따르면, 데이터 동기화 방법을 제공한다. 도 1c는 본 발명의 실시예에 따른 데이터 동기화 방법의 흐름도이다. 상기 데이터 동기화 방법은 제1 프로세서에 응용될 수 있으며, 상기 제1 프로세서는 범용 프로세서(예를 들어 중앙처리장치(CPU), 그래픽 프로세서(GPU))와 전용 프로세서(예를 들어 인공지능 프로세서, 공학용 컴퓨터 프로세서 또는 디지털 신호 프로세서 등)를 포함할 수 있다. 본 발명은 제1 프로세서의 유형에 대해서는 제한을 두지 않는다. 도 1c에 도시된 바와 같이, 상기 데이터 동기화 방법은 이하 단계를 포함한다: 단계 S11c에서, 동기화할 텐서 데이터의 형상을 지시하기 위한 디스크립터에 따라, 상기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립터 동기화 명령을 생성하고; 단계 S12c에서, 제2 프로세서가 상기 디스크립터 동기화 명령에 따라 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위한 상기 디스크립터 동기화 명령을 제2 프로세서로 전송한다. 예를 들어 설명하면, 동기화할 데이터는 N차원의 텐서 데이터(N은 0 이상의 정수이며, 예를 들어 N=1, 2 또는 3 이다)를 포함할 수 있으며, 그 중 텐서는 다양한 형식의 데이터 구성 방식을 포함할 수 있고, 텐서는 상이한 차 원일 수 있다. 예를 들어 스칼라(scalar)는 0차원의 텐서로 간주할 수 있고, 벡터는 1차원의 텐서로 간주할 수 있으며, 매트릭스는 2차원 또는 2차원 이상의 텐서일 수 있다. 텐서의 형상은 텐서의 차원, 텐서의 각 차원의 크기 등 정보를 포함한다. 예를 들어 설명하면, 텐서의 경우: 이며, 상기 텐서의 형상은 디스크립터에 의해 (2,4)로 기술된다. 즉 2개의 파라미터를 통해 상기 텐서가 2차원 텐서임 을 나타내며, 또한 상기 텐서의 제1 차원(열)의 크기는 2이고, 제2 차원(행)의 크기는 4이다. 설명해두어야 할 점으로, 본 출원은 디스크립터가 텐서의 형상을 지시하는 방식에 대해서는 한정하지 않는다. 메모리에 텐서 데 이터를 저장 시, 그 데이터 어드레스(또는 저장영역)로는 텐서 데이터의 형상을 결정할 수 없고, 나아가 다수의 텐서 데이터 간의 상호관계 등 관련 정보를 결정할 수도 없어, 텐서 데이터에 대한 프로세서의 액세스 효율이 저하되고, 데이터 동기화 수행 시의 복잡도 역시 비교적 크다. 이러한 경우, 디스크립터(텐서 디스크립터)의 도입을 통해 텐서 데이터(N차원의 텐서 데이터)의 형상을 지시할 수 있다. 그 중, N의 취득값은 텐서 데이터의 차원수(급수)에 따라 결정할 수도 있고, 텐서 데이터의 사용 필요 에 따라 설정할 수도 있다. 예를 들어, N의 취득값이 3일 때, 텐서 데이터는 3차원의 텐서 데이터이며, 디스크 립터는 상기 3차원 텐서 데이터의 3개의 차원 방향상의 형상(예를 들어 오프셋, 크기 등)을 지시하는데 사용될 수 있다. 이해해두어야 할 점으로, 당업자라면 실제 필요에 따라 N의 취득값을 설정할 수 있으며, 본 발명은 이 에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터는 식별자와 콘텐츠 등을 포함할 수 있고, 디스크립터의 식별자는 디 스크립터를 구분하는데 사용될 수 있으며, 예를 들어 번호이고; 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터(예를 들어 텐서의 각 차원 방향상의 크기 등)를 포함할 수 있고, 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터(예를 들어 데이터 기준점의 기준 어드레스)를포함할 수도 있다. 본 발명은 디스크립터의 콘텐츠에 포함되는 구체적인 파라미터에 대해 제한을 두지 않는다. 디스크립터로 텐서 데이터를 지시하는 방식을 통해, 텐서 데이터의 형상을 표현할 수 있고, 나아가 다수의 텐서 데이터 간의 상호관계 등 관련 정보를 결정할 수도 있어, 텐서 데이터의 액세스 효율이 향상되고, 이에 따라 데 이터 동기화 시의 복잡도가 감소된다. 일종의 가능한 구현 방식에서, 데이터 처리 과정에서, 다수의 프로세서(예를 들어 인공지능 칩의 다수의 코어) 간의 데이터 동기화를 수행할 필요가 있을 수 있으며, 예를 들어 프로세서(A1)의 연산 결과를 프로세서 (A2)에 동기화시켜 또 다른 연산의 입력 데이터로 삼을 수 있다. 상기 상황에서, 디스크립터의 데이터 동기화 메커니즘 에 기초하여 데이터 동기화를 구현할 수 있다. 일종의 가능한 구현 방식에서, 제1 프로세서는 데이터 동기화의 송신측이고, 제2 프로세서는 데이터 동기화의 수신측이다. 동기화할 텐서 데이터가 존재 시, 제1 프로세서는 단계 S11c에서 상기 텐서 데이터의 디스크립터에 따라, 디스크립터 동기화 명령을 생성하고, 단계 S12c에서 동기화할 제2 프로세서로 상기 디스크립터 동기화 명 령을 송신할 수 있다. 그 중, 제2 프로세서는 범용 프로세서(예를 들어 중앙처리장치(CPU), 그래픽 프로세서 (GPU))와 전용 프로세서(예를 들어 인공지능 프로세서, 공학용 컴퓨터 프로세서 또는 디지털 신호 프로세서 등)를 포함할 수 있다. 제2 프로세서는 제1 프로세서의 유형과 동일하거나 또는 상이할 수 있으며, 본 발명은 제2 프로세서의 유형에 대해서는 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제1 프로세서는 제2 프로세서에 대한 데이터 동기화를 능동적으로 개시할 수 있 다. 예를 들어 제1 프로세서가 한 항의 연산을 완료하여 연산 결과(텐서 데이터)를 획득 시, 상기 연산 결과를 사용해야 하는 제2 프로세서에 대한 데이터 동기화를 능동적으로 개시한다. 다른 일 예시에서, 제1 프로세서는 제2 프로세서의 동기화 요청에 응답하여, 제2 프로세서에 대한 데이터 동기화를 개시할 수도 있으며, 예를 들어 제2 프로세서의 동기화 요청 명령을 수신 시, 제2 프로세서에 대한 데이터 동기화를 개시한다. 본 발명은 데이 터 동기화의 개시 시기에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제1 프로세서가 동기화할 텐서 데이터가 존재한다고 결정 시, 상기 텐서 데이터 의 디스크립터를 획득할 수 있다. 상기 디스크립터는 이미 등록(생성)된 상기 텐서 데이터의 형상을 지시하기 위한 디스크립터일 수도 있고, 상기 텐서 데이터의 형상 파라미터에 따라 새로운 디스크립터를 등록(생성)할 수 도 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 디스크립터에 따라 디스크립터 동기화 명령을 생성할 수 있 으며, 상기 디스크립터 동기화 명령은 상기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함한다. 제2 프로세서에 상기 동기화할 텐서 데이터의 디스크립터가 이미 등록되어 있는 경우, 즉 디스크립터 동기화 명령은 디스크립터의 식별자만 포함함으로써(예를 들어 디스크립터의 식별자가 TR1일 때, 디스크립터 동 기화 명령은 Send TR1로 표시한다), 제2 프로세서가 상기 디스크립터의 식별자(TR1)에 따라 텐서 데이터의 동기 화를 구현하도록 지시할 수 있고; 만약 제2 프로세서 중 상기 동기화할 텐서 데이터의 디스크립터가 등록되어 있지 않다면, 즉 디스크립터 동기화 명령은 디스크립터의 콘텐츠를 포함하거나, 또는 디스크립터의 식별자와 콘 텐츠를 동시에 포함함으로써, 제2 프로세서가 상기 디스크립터의 콘텐츠에 따라 텐서 데이터의 동기화를 구현하 도록 지시할 수 있다. 본 발명은 디스크립터 동기화 명령에 포함되는 구체적인 내용에 대해서는 제한을 두지 않 는다. 일종의 가능한 구현 방식에서, 디스크립터 동기화 명령이 생성된 후, 제2 프로세서로 상기 디스크립터 동기화 명령을 전송하여, 제2 프로세서가 상기 디스크립터 동기화 명령에 따라 상기 동기화할 텐서 데이터를 획득하도 록 지시할 수 있다. 만약 디스크립터 동기화 명령에 디스크립터의 식별자가 포함되어 있다면, 즉 제2 프로세서 는 디스크립터의 식별자에 따라 디스크립터의 콘텐츠를 획득한 다음, 디스크립터의 콘텐츠에 따라 디스크립터가 지시하는 텐서 데이터를 획득함으로써, 텐서 데이터의 동기화를 구현할 수 있다. 만약 디스크립터 동기화 명령 에 디스크립터의 콘텐츠가 포함되어 있다면, 즉 제2 프로세서는 디스크립터의 콘텐츠에 따라 디스크립터가 지시 하는 텐서 데이터를 직접 획득함으로써, 텐서 데이터의 동기화를 구현할 수 있다. 본 발명의 실시예에 따른 데이터 동기화 방법은 텐서 데이터의 형상을 지시하는 디스크립터의 설정을 통해, 데 이터 동기화가 필요 시, 동기화할 텐서 데이터의 디스크립터에 따라 디스크립터 동기화 명령을 생성하고 제2 프 로세서로 상기 명령을 전송함으로써 제2 프로세서가 디스크립터 동기화 명령에 따라 동기화할 텐서 데이터를 획 득하도록 지시할 수 있으며, 이에 따라 동기화 오버헤드가 감소되고, 데이터 동기화의 복잡도가 감소되며, 데이 터 동기화의 효율이 향상된다.일종의 가능한 구현 방식에서, 상기 방법은, 제2 프로세서로부터의 디스크립터 동기화 요청 명령에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하는 단계를 더 포함한다. 예를 들어 설명하면, 제1 프로세서는 제2 프로세서의 동기화 요청에 응답하여, 제2 프로세서에 대한 데이터 동 기화를 개시할 수 있다. 그 중, 제2 프로세서로부터의 디스크립터 동기화 요청 명령은 동기화할 텐서 데이터의 정보, 예를 들어 상기 동기화할 텐서 데이터를 지시하는 디스크립터의 식별자, 상기 동기화할 텐서 데이터의 데 이터 특징 등을 포함할 수 있다. 그 중, 텐서 데이터의 데이터 특징은 텐서 데이터의 형상, 출처, 어드레스 등 정보를 포함할 수 있으며, 본 발명은 디스크립터 동기화 요청 명령의 구체적인 내용에 대해 제한을 두지 않는다. 디스크립터 동기화 요청 명령 중의 정보에 따라, 제1 프로세서는 동기화할 텐서 데이터의 디스크립터를 결정하고, 나아가 디스크립터 동기화 명령을 생성할 수 있다. 이러한 방식을 통해, 제2 프로세서의 동기화 요청에 따라 동기화할 텐서 데이터의 디스크립터를 결정함으로써, 디스크립터 동기화 명령을 생성하며, 이에 따라 불필요한 데이터 동기화를 피할 수 있어, 데이터 동기화의 효율 이 향상된다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 요청 명령은 디스크립터의 식별자를 포함한다. 그 중, 상기 제2 프로세서로부터의 디스크립터 동기화 요청 명령에 따라, 상기 동기화할 텐서 데이터의 디스크 립터를 결정하는 단계는, 상기 디스크립터 동기화 요청 명령을 해석하여, 상기 디스크립터의 식별자를 획득하는 단계; 상기 디스크립터의 식별자에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하는 단계를 포함할 수 있다. 예를 들어 설명하면, 만약 제1 프로세서와 제2 프로세서에 모두 상기 텐서 데이터를 지시하는 디스크립터가 이 미 등록되어 있고, 디스크립터의 식별자가 동일하거나 또는 대응관계를 지닌다면, 즉 디스크립터 동기화 요청 명령에는 디스크립터의 식별자가 포함될 수 있으며, 예를 들어 디스크립터의 식별자가 TR1일 때, 디스크립터 동 기화 요청 명령은 Receive TR1로 표시된다. 제1 프로세서는 제2 프로세서로부터의 디스크립터 동기화 요청 명령 을 해석하여, 디스크립터의 식별자를 획득할 수 있으며; 나아가 디스크립터의 식별자에 따라, 상기 동기화할 텐 서 데이터의 디스크립터를 결정하여 디스크립터 동기화 명령을 생성할 수 있다. 이러한 방식을 통해, 요청 명령 중의 디스크립터 식별자에 따라 동기화할 텐서 데이터의 디스크립터를 결정함으 로써, 텐서 데이터의 동기화를 구현할 수 있으며, 이에 따라 동기화 시 전송되는 데이터량이 감소되어 처리 효 율이 향상된다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 요청 명령은 상기 동기화할 텐서 데이터의 데이터 특징 을 포함하며, 그 중, 상기 제2 프로세서로부터의 디스크립터 동기화 요청 명령에 따라, 상기 동기화할 텐서 데이터의 디스크 립터를 결정하는 단계는, 상기 디스크립터 동기화 요청 명령을 해석하여, 동기화할 텐서 데이터의 데이터 특징 을 획득하는 단계; 동기화할 텐서 데이터의 데이터 특징에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결 정하는 단계를 포함할 수 있다. 예를 들어 설명하면, 만약 제2 프로세서에 상기 텐서 데이터를 지시하기 위한 디스크립터가 등록되어 있지 않거 나, 또는 상기 텐서 데이터를 지시하기 위한 디스크립터가 이미 등록되어 있으나 단 디스크립터의 식별자가 대 응관계를 지니지 않는다면, 즉 디스크립터 동기화 요청 명령은 동기화할 텐서 데이터의 데이터 특징을 포함할 수 있다. 제1 프로세서는 제2 프로세서로부터의 디스크립터 동기화 요청 명령을 해석하여, 동기화할 텐서 데이 터의 데이터 특징을 획득할 수 있으며; 나아가 동기화할 텐서 데이터의 데이터 특징에 따라 상기 동기화할 텐서 데이터 및 그것의 디스크립터를 결정함으로써, 디스크립터 동기화 명령을 생성할 수 있다. 일종의 가능한 구현 방식에서, 동기화할 텐서 데이터의 데이터 특징은 텐서 데이터의 형상, 출처, 어드레스 등 정보를 포함할 수 있다. 예를 들어, 상기 텐서 데이터의 데이터 출처는 K번째 송신측(K번째 프로세서)이고, 상 기 텐서 데이터의 데이터의 출처는 번호가 200인 컨볼루션(Convolution) 연산의 연산 결과이며, 상기 텐서 데이 터의 어드레스는 특정한 어드레스 영역(예를 들어 어드레스 ADDR0-ADDR127)이고, 상기 텐서 데이터의 형상은 지 정된 형상(예를 들어 20*10인 2차원 텐서) 등이다. 당업자라면 실제 상황에 따라 동기화할 텐서 데이터의 데이 터 특징을 설정할 수 있을 것이며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 데이터 특징에 따라, 제1 프로세서는 동기화할 텐서 데이터를 검색하여, 상 기 동기화할 텐서 데이터의 디스크립터를 결정할 수 있으며, 예를 들어 디스크립터를 직접 획득하거나 또는 대응되는 디스크립터를 새롭게 등록할 수 있다. 상기 동기화할 텐서 데이터의 디스크립터에 따라, 디스크립터 동 기화 명령을 생성 및 전송함으로써, 제2 프로세서가 상기 텐서 데이터의 동기화를 구현하도록 지시할 수 있다. 이러한 방식을 통해, 요청 명령 중의 데이터 특징에 따라 동기화할 텐서 데이터의 디스크립터를 결정함으로써, 텐서 데이터의 동기화를 구현할 수 있으며, 이에 따라 동기화 시 텐서 데이터 자체를 전송할 필요가 없어 전송 되는 데이터량과 동기화 오버헤드가 감소되고, 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령은 동기화할 텐서 데이터의 디스크립터의 콘텐츠를 포함하며. 그 중 단계 S11c는, 동기화할 텐서 데이터의 저장 어드레스가 공용 저장공간에 놓인 경우, 상기 동기화할 텐서 데이터의 디스크립터 의 콘텐츠에 따라, 디스크립터 동기화 명령을 생성함으로써, 상기 제2 프로세서가 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지시하는 단계를 포함할 수 있다. 예를 들어 설명하면, 다수의 프로세서(다수의 코어)는 공용 저장공간, 예를 들어 제1 프로세서와 제2 프로세서 가 모두 액세스할 수 있는 오프칩 메모리를 구비할 수 있다. 상기 공용 저장공간은 다수의 코어(다수의 프로세 서)가 모두 데이터를 액세스할 수 있는 저장공간일 수도 있고, 일부 코어(일부 프로세서)가 데이터를 액세스할 수 있는 저장공간일 수도 있으며, 코어간의 공용 저장공간을 미리 설치할 수 있다. 본 발명은 공용 저장공간의 설정 방식에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 동기화할 텐서 데이터의 저장 어드레스가 공용 저장공간에 놓여 있다면, 즉 제2 프로세서 역시 공용 저장공간으로부터 데이터를 액세스할 수 있기 때문에, 제2 프로세서는 디스크립터의 콘텐츠 에 따라 텐서 데이터를 직접 독취하여 동기화를 구현할 수 있다. 상기 상황에서, 디스크립터 동기화 명령은 동 기화할 텐서 데이터의 디스크립터의 콘텐츠를 포함할 수 있으며, 다시 말해, 상기 동기화할 텐서 데이터의 디스 크립터의 콘텐츠에 따라, 디스크립터 동기화 명령을 생성할 수 있다. 제2 프로세서는 디스크립터 동기화 명령을 수신 후, 명령을 해석하여 디스크립터의 콘텐츠를 획득할 수 있고; 디스크립터의 콘텐츠에 따라, 제2 프로세서 는 동기화할 텐서 데이터의 데이터 어드레스를 결정하여, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득할 수 있으며, 이에 따라 전체적인 동기화 과정을 구현할 수 있다. 이러한 방식을 통해, 불필요한 데이터 전송을 피할 수 있어, 텐서 데이터의 액세스 횟수가 감소하며, 동기화의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 단계 S11c는, 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠를 동기화 데이터 저장공간에 저장하는 단계; 상기 디스크립터의 콘텐츠의 상기 동기화 데이터 저장공간 중에서의 어드레스에 따라, 디스크립터 동기화 명령 을 생성함으로써, 상기 제2 프로세서가 상기 동기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디 스크립터의 콘텐츠를 획득하도록 지시하는 단계를 포함할 수 있다. 예를 들어 설명하면, 다수의 프로세서(다수의 코어)는 동기화 데이터를 전문으로 저장하기 위한 동기화 데이터 저장공간을 가질 수 있다. 상기 동기화 데이터 저장공간은 상기 공용 저장공간일 수도 있고, 공용 저장공간의 일부분일 수도 있으며, 공용 저장공간과 다른 저장공간일 수도 있다. 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 동기화 데이터 저장공간은 다수의 코어(다수의 프로세서)가 모두 동기화 데이터 에 액세스할 수 있는 저장공간일 수도 있고, 일부 코어(일부 프로세서)가 동기화 데이터에 액세스할 수 있는 저 장공간일 수도 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제1 프로세서가 동기화할 텐서 데이터의 디스크립터를 결정한 후, 디스크립터의 콘텐츠를 동기화 데이터 저장공간에 저장하고; 디스크립터 콘텐츠의 동기화 데이터 저장공간에서의 어드레스에 따라, 디스크립터 동기화 명령을 생성 및 전송할 수 있다. 제2 프로세서가 디스크립터 동기화 명령을 수신 후, 명령을 해석하여 디스크립터의 콘텐츠의 저장 어드레스를 획득할 수 있으며; 상기 저장 어드레스에 따라, 제2 프로세서는 동기화 데이터 저장공간으로부터 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하고, 나아가 디 스크립터의 콘텐츠에 따라 동기화할 텐서 데이터의 데이터 어드레스를 결정하여, 상기 동기화할 텐서 데이터를 획득함으로써 전체적인 동기화 과정을 구현할 수 있다. 이러한 방식을 통해, 동기화 시 프로세서간의 데이터 전송을 추가적으로 감소시킬 수 있어, 동기화의 처리 효율 이 향상된다. 일종의 가능한 구현 방식에서, 단계 S11c는, 동기화할 텐서 데이터의 저장 어드레스가 비공용 저장공간에 놓여 있는 경우, 상기 동기화할 텐서 데이터를 공 용 저장공간에 저장하는 단계; 상기 동기화할 텐서 데이터의 공용 저장공간 중에서의 어드레스에 따라, 상기 동기화할 텐서 데이터의 디스크립 터를 생성하는 단계; 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로 세서가 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지시하는 단계를 포함할 수 있다. 예를 들어 설명하면, 제1 프로세서는 비공용 저장공간을 구비할 수 있고, 제1 프로세서는 상기 비공용 저장공간 중의 데이터에 액세스할 수 있는 반면, 제2 프로세서는 제1 프로세서의 비공용 저장공간에 액세스할 수 없고, 상기 비공용 저장공간 중의 데이터에 액세스할 수 없다. 만약 동기화할 텐서 데이터의 저장 어드레스가 비공용 저장공간에 있다면, 즉 제2 프로세서는 상기 텐서 데이터를 직접 획득할 수 없다. 상기 상황에서, 제1 프로세서 는 제2 프로세서가 상기 텐서 데이터에 액세스할 수 있도록 동기화할 텐서 데이터를 공용 저장공간으로 옮겨 저 장할 수 있다. 이동 저장이 완료된 후, 제1 프로세서에 상기 동기화할 텐서 데이터를 지시하는 디스크립터가 등 록되지 않았거나, 또는 비공용 저장공간 중의 상기 텐서 데이터를 지시하는 디스크립터가 이미 등록되어 상기 디스크립터를 수정할 수 없는 경우(예를 들어 연산되고 있는 중인), 즉 제1 프로세서는 상기 동기화할 텐서 데 이터의 디스크립터를 생성할 수 있으며, 다시 말해, 새로운 디스크립터를 등록함으로써, 공용 저장공간 중의 상 기 텐서 데이터를 지시할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터를 생성 후, 제1 프로세서는 디스크립터의 콘텐츠에 따라 디스크립터 동기화 명령을 생성할 수 있다. 제2 프로세서는 디스크립터 동기화 명령을 수신한 후, 명령을 해석하여 디스크 립터의 콘텐츠를 획득할 수 있으며; 디스크립터의 콘텐츠에 따라, 제2 프로세서는 동기화할 텐서 데이터의 데이 터 어드레스를 결정하여, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득함으로써 전체적인 동기화 과정을 구현할 수 있다. 이러한 방식을 통해, 비공용 저장공간 중 동기화할 텐서 데이터를 능동적으로 공용 저장공간에 옮겨 저장함으로 써, 제2 프로세서가 동기화할 텐서 데이터를 획득할 수 있도록 하며, 이에 따라 동기화 시 프로세서간의 데이터 전송이 감소되어 동기화 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 단계 S11c는 동기화할 텐서 데이터의 저장 어드레스가 비공용 저장공간에 놓여 있는 경우, 상기 동기화할 텐서 데이터를 공 용 저장공간에 저장하는 단계; 상기 동기화할 텐서 데이터의 공용 저장공간 중에서의 어드레스에 따라, 상기 동기화할 텐서 데이터의 디스크립 터를 수정하는 단계; 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로 세서가 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐 서 데이터를 획득하도록 지시하는 단계를 포함할 수 있다. 예를 들어 설명하면, 위의 설명과 유사하게, 동기화할 텐서 데이터가 제1 프로세서의 비공용 저장공간에 놓여있 는 경우, 즉 제1 프로세서는 동기화할 텐서 데이터를 공용 저장공간으로 옮겨 저장할 수 있다. 이동 저장이 완 료된 후, 제1 프로세서에 비공용 저장공간 중의 상기 텐서 데이터를 지시하는 디스크립터가 이미 등록되어 있으 면서 상기 디스크립터를 수정 가능하다면(예를 들어 디스크립터가 연산되지 않은 경우), 즉 제1 프로세서는 상 기 디스크립터가 공용 저장공간 중에서의 상기 텐서 데이터를 지시하도록 동기화할 텐서 데이터의 디스크립터를 직접 수정할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터를 수정한 후, 제1 프로세서는 디스크립터의 콘텐츠에 따라 디스크립 터 동기화 명령을 생성할 수 있다. 제2 프로세서는 디스크립터 동기화 명령을 수신한 후, 명령을 해석하여 디스 크립터의 콘텐츠를 획득할 수 있으며; 디스크립터의 콘텐츠에 따라, 제2 프로세서는 동기화할 텐서 데이터의 데 이터 어드레스를 결정하여, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득함으로써, 전체적인 동기화 과정을 구현할 수 있다. 이러한 방식을 통해, 비공용 저장공간 중 동기화할 텐서 데이터를 공용 저장공간으로 능동적으로 옮겨 저장할 수 있어, 동기화 시 프로세서 간의 데이터 전송이 감소하여, 동기화의 처리 효율이 향상되며; 또한, 제1 프로세 서는 새로운 디스크립터를 생성할 필요가 없어 제한적인 디스크립터 리소스가 절약된다. 도 3ca은 본 발명의 실시예에 따른 데이터 동기화 방법의 흐름도이다. 상기 데이터 동기화 방법은 제2 프로세서 에 응용될 수 있다. 도 3ca에 도시된 바와 같이, 상기 데이터 동기화 방법은 이하 단계를 포함한다: 단계 S21c에서, 제1 프로세서로부터 수신되는 상기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립터 동기화 명령을 해석하여, 동기화할 텐서 데이터의 형상을 지시하기 위한 디스크립터를 획 득하고; 단계 S22c에서, 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득한다. 예를 들어 설명하면, 제1 프로세서(송신측)는 제2 프로세서(수신측)에 대한 데이터 동기화를 능동적으로 개시할 수 있으며, 예를 들어 제1 프로세서가 한 항의 연산을 완료하여 연산 결과(텐서 데이터)를 획득 시, 상기 연산 결과를 사용해야 하는 제2 프로세서에 대한 데이터 동기화를 능동적으로 개시할 수 있다. 일종의 가능한 구현 방식에서, 제2 프로세서는 제1 프로세서로부터의 디스크립터 동기화 명령을 수신 시, 상기 디스크립터 동기화 명령을 해석하여, 동기화할 텐서 데이터의 디스크립터(예를 들어 디스크립터의 식별자 및/또 는 상기 디스크립터의 콘텐츠)를 획득할 수 있다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령에 디스크립터의 식별자만 포함되어 있다면, 즉 제2 프로세서는 상기 디스크립터의 식별자에 대응하는 디스크립터 콘텐츠를 내부 검색하고, 나아가 상기 디스크립터 동기화 명령에 따라 동기화할 텐서 데이터를 획득함으로써, 텐서 데이터의 동기화를 구현할 수 있다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령에 디스크립터의 식별자와 콘텐츠가 포함되어 있다 면, 즉 제2 프로세서는 상기 디스크립터의 식별자에 대응하는 디스크립터를 검색하고, 디스크립터 동기화 명령 중의 디스크립터의 콘텐츠에 따라 원래의 디스크립터 콘텐츠를 업데이트하며; 업데이트된 후의 디스크립터의 콘 텐츠에 따라 동기화할 텐서 데이터를 획득함으로써, 텐서 데이터의 동기화를 구현할 수 있다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령에 디스크립터의 콘텐츠가 포함되어 있다면, 즉 제2 프로세서는 디스크립터의 콘텐츠에 따라, 상기 동기화할 텐서 데이터를 지시하는 디스크립터를 등록하고, 디스 크립터의 콘텐츠에 따라 동기화할 텐서 데이터를 획득함으로써, 텐서 데이터의 동기화를 구현할 수 있다. 본 발명의 실시예에 따른 데이터 동기화 방법은, 텐서 데이터의 형상을 지시하는 디스크립터의 설정을 통해, 디 스크립터 동기화 명령 중의 동기화할 텐서 데이터를 지시하는 디스크립터에 따라, 동기화할 텐서 데이터를 획득 함으로써, 텐서 데이터의 동기화를 구현할 수 있으며, 이에 따라 동기화 오버헤드가 감소하고, 데이터 동기화의 복잡도가 감소되어, 데이터의 동기화 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령에 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠 가 포함되며, 그 중 단계 S22c는 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하는 단계를 포함한다. 예를 들어 설명하면, 동기화할 텐서 데이터의 저장 어드레스가 공용 저장공간에 놓여 있는 경우, 즉 제2 프로세 서는 공용 저장공간으로부터 데이터에 액세스할 수 있다. 상기 상황에서, 디스크립터 동기화 명령은 동기화할 텐서 데이터의 디스크립터의 콘텐츠를 포함할 수 있다. 제2 프로세서는 디스크립터 동기화 명령을 수신 후, 명 령을 해석하여 디스크립터의 콘텐츠를 획득할 수 있으며; 디스크립터의 콘텐츠에 따라, 제2 프로세서는 동기화 할 텐서 데이터의 데이터 어드레스를 결정하여, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득함으 로써, 전체적인 동기화 과정을 구현할 수 있다. 이러한 방식을 통해, 불필요한 데이터 전송을 피할 수 있으며, 텐서 데이터 액세스 횟수가 감소되어, 동기화의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠 의 동기화 데이터 저장공간 중에서의 어드레스를 포함하며, 그 중, 단계 S22c는상기 동기화할 텐서 데이터의 디스크립터 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 상기 동 기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하는 단계; 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하는 단계를 포함한다. 예를 들어 설명하면, 제1 프로세서는 동기화할 텐서 데이터의 디스크립터가 결정된 후, 디스크립터의 콘텐츠를 동기화 데이터 저장공간에 저장하고; 디스크립터의 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 디스크립터 동기화 명령을 생성 및 전송할 수 있다. 제2 프로세서는 디스크립터 동기화 명령을 수신 후, 명령을 해석하여 디스크립터 콘텐츠의 저장 어드레스를 획득할 수 있으며; 상기 저장 어드레스에 따라, 제2 프 로세서는 동기화 데이터 저장공간으로부터 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하고, 나아가 디스 크립터의 콘텐츠에 따라 동기화할 텐서 데이터의 데이터 어드레스를 결정하여, 동기화할 텐서 데이터를 획득함 으로써, 전체적인 동기화 과정을 구현한다. 이러한 방식을 통해, 동기화 시 프로세서 간의 데이터 전송을 추가적으로 감소시킬 수 있어, 동기화의 처리 효 율이 향상된다. 도 3cb는 본 발명의 실시예에 따른 데이터 동기화 방법의 흐름도이다. 상기 데이터 동기화 방법은 제2 프로세서 에 응용된다. 도 3cb에 도시된 바와 같이, 상기 데이터 동기화 방법은 단계 S31c에서, 동기화할 텐서 데이터가 존재하는 경우, 디스크립터 동기화 요청 명령을 생성하는 단계로서, 상 기 디스크립터 동기화 요청 명령은 제1 프로세서가 상기 디스크립터 동기화 요청 명령에 따라 동기화할 텐서 데 이터의 디스크립터를 전송하도록 지시하기 위한 것이고, 상기 디스크립터는 동기화할 텐서 데이터의 형상을 지 시하기 위한 것이며; 단계 S32c에서, 상기 제1 프로세서로 상기 디스크립터 동기화 요청 명령을 전송하는 단계를 포함한다. 예를 들어 설명하면, 제2 프로세서에 동기화할 텐서 데이터가 존재하는 경우, 상기 동기화할 텐서 데이터를 획 득하도록, 제1 프로세서로 디스크립터 동기화 요청 명령을 능동적으로 전송할 수 있다. 제2 프로세서는 동기화 할 텐서 데이터의 정보, 예를 들어 상기 동기화할 텐서 데이터의 디스크립터의 식별자, 상기 동기화할 텐서 데 이터의 데이터 특징 등에 따라, 디스크립터 동기화 요청 명령을 생성한다. 본 발명은 디스크립터 동기화 요청 명령의 구체적인 내용에 대해서는 제한을 두지 않는다. 디스크립터 동기화 요청 명령 중의 정보에 따라, 제1 프 로세서는 동기화할 텐서 데이터의 디스크립터를 결정하고, 나아가 디스크립터 동기화 명령을 생성할 수 있다. 이러한 방식을 통해, 동기화 필요 시 동기화 요청을 능동적으로 개시할 수 있어 데이터 동기화의 효율이 향상된 다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 요청 명령은 제1 프로세서가 동기화할 텐서 데이터를 결 정할 수 있도록, 디스크립터의 식별자 및/또는 상기 동기화할 텐서 데이터의 데이터 특징을 포함한다. 그 중, 텐서 데이터의 데이터 특징은 텐서 데이터의 형상, 출처, 어드레스 등 정보를 포함할 수 있다. 당업자라면 실제 상황에 따라 동기화할 텐서 데이터의 데이터 특징을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는 다. 일종의 가능한 구현 방식에서, 상기 방법은 제1 프로세서로부터 수신된 상기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립 터 동기화 명령을 해석하여, 동기화할 텐서 데이터의 디스크립터를 획득하는 단계; 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득하는 단계를 더 포함한다. 예를 들어 설명하면, 만약 제1 프로세서와 제2 프로세서에 모두 상기 텐서 데이터를 지시하는 디스크립터가 이 미 등록되어 있고, 또한 디스크립터의 식별자가 동일하거나 또는 대응관계를 지닌다면, 즉 디스크립터 동기화 요청 명령은 디스크립터의 식별자를 포함할 수 있으며, 예를 들어 디스크립터의 식별자가 TR1일 때, 디스크립터 동기화 요청 명령은 Receive TR1로 표시된다. 제1 프로세서는 제2 프로세서로부터의 디스크립터 동기화 요청 명 령을 해석하여, 디스크립터의 식별자를 획득할 수 있고; 나아가 디스크립터의 식별자에 따라, 상기 동기화할 텐 서 데이터의 디스크립터를 결정하여, 디스크립터 동기화 명령을 생성할 수 있다. 일종의 가능한 구현 방식에서, 제2 프로세서는 디스크립터 동기화 명령을 수신 시, 상기 디스크립터 동기화 명 령을 해석하여, 동기화할 텐서 데이터의 디스크립터(디스크립터의 식별자 및/또는 디스크립터의 콘텐츠)를 획득할 수 있다. 만약 상기 디스크립터 동기화 명령에 디스크립터의 식별자만 포함되어 있는 경우, 즉 제2 프로세서 는 상기 디스크립터의 식별자에 대응되는 디스크립터 콘텐츠를 내부 검색하여, 디스크립터의 콘텐츠에 따라 동 기화할 텐서 데이터를 획득함으로써, 텐서 데이터의 동기화를 구현할 수 있다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령에 디스크립터의 식별자와 콘텐츠가 포함되어 있다 면, 즉 제2 프로세서는 상기 디스크립터의 식별자에 대응하는 디스크립터를 검색하고, 디스크립터 동기화 명령 중의 디스크립터의 콘텐츠에 따라 원래의 디스크립터 콘텐츠를 업데이트하며; 업데이트된 후의 디스크립터의 콘 텐츠에 따라 동기화할 텐서 데이터를 획득함으로써, 텐서 데이터의 동기화를 구현할 수 있다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령에 디스크립터의 콘텐츠가 포함되어 있다면, 즉 제2 프로세서는 디스크립터의 콘텐츠에 따라, 상기 동기화할 텐서 데이터를 지시하는 디스크립터를 등록하고, 디스 크립터의 콘텐츠에 따라 동기화할 텐서 데이터를 획득함으로써, 텐서 데이터의 동기화를 구현할 수 있다. 이러한 방식을 통해 데이터 동기화의 복잡도를 감소할 수 있으며, 데이터 동기화의 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령에 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠 가 포함되며, 그 중, 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득하는 단계는, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하는 단계를 포함할 수 있다. 예를 들어 설명하면, 동기화할 텐서 데이터의 저장 어드레스가 공용 저장공간에 놓여 있는 경우, 즉 제2 프로세 서는 공용 저장공간으로부터 데이터에 액세스할 수 있다. 상기 상황에서, 디스크립터 동기화 명령은 동기화할 텐서 데이터의 디스크립터의 콘텐츠를 포함할 수 있다. 제2 프로세서는 디스크립터 동기화 명령을 수신 후, 명 령을 해석하여 디스크립터의 콘텐츠를 획득할 수 있으며; 디스크립터의 콘텐츠에 따라, 제2 프로세서는 동기화 할 텐서 데이터의 데이터 어드레스를 결정하여, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득함으 로써, 전체적인 동기화 과정을 구현할 수 있다. 이러한 방식을 통해, 불필요한 데이터 전송을 피할 수 있으며, 텐서 데이터 액세스 횟수가 감소되어, 동기화의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령은 동기화할 텐서 데이터의 디스크립터 콘텐츠의 동 기화 데이터 저장공간 중에서의 어드레스를 포함하며, 그 중, 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득하는 단계는, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 상기 동 기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하는 단계; 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하는 단계를 포함한다. 제1 프로세서는 동기화할 텐서 데이터의 디스크립터가 결정된 후, 디스크립터의 콘텐츠를 동기화 데이터 저장공 간에 저장하고; 디스크립터의 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 디스크립터 동기화 명령을 생성 및 전송할 수 있다. 제2 프로세서는 디스크립터 동기화 명령을 수신 후, 명령을 해석하여 디스크립 터 콘텐츠의 저장 어드레스를 획득할 수 있으며; 상기 저장 어드레스에 따라, 제2 프로세서는 동기화 데이터 저 장공간으로부터 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하고, 나아가 디스크립터의 콘텐츠에 따라 동 기화할 텐서 데이터의 데이터 어드레스를 결정하여, 동기화할 텐서 데이터를 획득함으로써, 전체적인 동기화 과 정을 구현한다. 이러한 방식을 통해, 동기화 시 프로세서 간의 데이터 전송을 추가적으로 감소시킬 수 있어, 동기화의 처리 효 율이 향상된다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자와 콘텐츠는 디스크립터 저장공간에 저장될 수 있으며, 상기 디스크립터 저장공간은 프로세서의 내부 메모리(예를 들어 레지스터, 온칩 SRAM 또는 기타 매체의 캐시(cache) 등) 중의 저장공간일 수 있다. 디스크립터가 지시하는 텐서 데이터는의 데이터 저장공간은 프로세서의 내부 메 모리(예를 들어 온칩 캐시) 또는 프로세서와 연결되는 외부 메모리(오프칩 메모리) 중의 저장공간일 수 있다. 데이터 저장공간 중의 데이터 어드레스는 실제 물리 어드레스이거나 또는 가상 어드레스일 수 있다. 본 발명은디스크립터 저장공간 및 데이터 저장공간의 위치 및 데이터 어드레스의 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 동일한 영역에 위치할 수 있다. 예를 들어, 온칩 캐시의 연속되는 영역을 사용하여 디스크립터의 관련 콘텐츠를 저장할 수 있으며, 그 어드레스는 ADDR0-ADDR1023이다. 그 중, 어드레스 ADDR0-ADDR31은 디스크립터의 식별자를 저장하 는데 사용될 수 있고, 어드레스 ADDR32-ADDR63은 디스크립터의 콘텐츠를 저장하는데 사용될 수 있으며, 어드레 스 ADDR64-ADDR1023은 디스크립터가 지시하는 텐서 데이터를 저장하는데 사용될 수 있다. 그 중, 어드레스 ADDR 은 1비트 또는 하나의 바이트로 한정되지 않으며, 여기서는 하나의 어드레스를 표시하기 위한 하나의 어드레스 단위이다. 당업자라면 실제 상황에 따라 저장영역 및 그 어드레스를 결정할 수 있을 것이며, 본 발명은 이에 대 해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 내부 메 모리의 상이한 영역에 각각 저장될 수 있다. 예를 들어 레지스터를 디스크립터 저장공간으로 하여, 레지스터에 디스크립터의 식별자와 콘텐츠를 저장할 수 있고, 온칩 캐시를 데이터 저장공간으로 하여 디스크립터가 지시하 는 텐서 데이터를 저장할 수 있다. 일종의 가능한 구현 방식에서, 전문적으로 디스크립터가 사용할 전용 레지스터(SR)를 더 설치할 수 있으며, 디 스크립터 중의 데이터는 즉치(immediate)일 수도 있고 전용 레지스터로부터 획득될 수도 있다. 레지스터를 사용 하여 디스크립터의 식별자와 콘텐츠를 저장 시, 레지스터의 번호를 사용하여 디스크립터의 식별자를 표시할 수 있다. 예를 들어 레지스터의 번호가 0일 때, 저장되는 디스크립터의 식별자는 0이다. 레지스터 중의 디스크립터 가 유효할 때, 디스크립터가 지시하는 텐서 데이터의 크기에 따라 캐시 공간에 하나의 영역을 할당하여(예를 들 어 캐시 중 각 텐서 데이터마다 하나의 텐서 캐시유닛을 생성한다) 상기 텐서 데이터를 저장할 수 있다. 미리 설정된 캐시 공간을 이용하여 상기 텐서 데이터를 저장할 수도 있음을 이해하여야 하며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자 및 콘텐츠는 내부 메모리에 저장될 수 있고, 디스크립터가 지시하는 텐서 데이터는 외부 메모리에 저장될 수 있다. 예를 들어, 디스크립터의 식별자 및 콘텐츠는 온칩 저 장하고, 디스크립터가 지시하는 텐서 데이터는 오프칩 저장하는 방식을 채택할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터에 대응되는 데이터 저장공간의 데이터 어드레스는 고정 어드레스일 수 있다. 예를 들어 텐서 데이터를 위해 별도의 데이터 저장공간을 분할할 수 있으며, 각 텐서 데이터의 데이터 저장공간에서의 시작 어드레스는 디스크립터의 식별자와 일일이 대응될 수 있다. 이 경우, 프로세서는 디스크립 터의 콘텐츠에 따라 텐서 데이터의 데이터 어드레스를 즉시 결정할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자에 대응되는 데이터 저장공간의 데이터 어드레스가 가변 어 드레스일 때, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용될 수 있으며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 더 포함할 수 있다. 예를 들어, 텐서 데이터가 3차원 데이터이고, 디스크립터가 상기 텐서 데이터의 어드레스를 지향하는 경우, 디스크립터의 콘텐츠는 상기 텐서 데이터의 어드레스를 나타내는 하나의 어드레스 파라미터, 예를 들어 텐서 데이터의 시작 물리 어드레스를 포함할 수 있고, 상기 텐서 데이터 어드레스의 다수의 어드레스 파라미터, 예를 들어 텐서 데이터의 시작 어드레스+어드레스 오프셋을 포함할 수도 있으며, 또는 텐서 데이터는 각 차원의 어드레스 파라미터를 바탕으로 한다. 당업자라면 실제 필요에 따라 어드레스 파라미터를 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 상 기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함한다. 그 중, 기준 어드레스는 데이터 기준점 의 변화에 따라 달라질 수 있다. 본 발명은 데이터 기준점의 선택에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 기준 어드레스는 상기 데이터 저장공간의 시작 어드레스를 포함할 수 있다. 디스크립터의 데이터 기준점이 데이터 저장공간의 첫 번째 데이터블록일 때, 디스크립터의 기준 어드레스는 즉 데이터 저장공간의 시작 어드레스이다. 디스크립터의 데이터 기준점이 데이터 저장공간 중 첫 번째 데이터블록 이외의 다른 데이터인 경우, 디스크립터의 기준 어드레스는 즉 상기 데이터블록의 데이터 저장공간 중에서의 물 리 어드레스이다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 데이터 저장공간의 크기, N개의 차원 방향의 적어도 한 방향상에서의 상기 저장영역의크기, N개의 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개의 차원 방향의 대각 위치에 놓 이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. 그 중, 데이터 디스크립션 위치는 디스크립터가 지시하는 텐서 데이터 중의 점 또는 영역의 매핑 위치이며, 예를 들어 텐서 데이터가 3차 원 데이터일 때, 디스크립터는 3차원 공간 좌표(x, y, z)를 사용하여 상기 텐서 데이터의 형상을 나타낼 수 있 으며, 상기 텐서 데이터의 데이터 디스크립터의 위치는 3차원 공간 좌표(x, y, z)로 표시될 수 있고, 상기 텐서 데이터는 3차원 공간 중의 점 또는 영역의 위치에 매핑된다. 이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 텐서 데이터를 나타내는 형상 파라미터를 선택할 수 있 으며, 본 발명은 이에 대해 제한을 두지 않는다. 도 2는 본 발명의 일 실시예에 따른 데이터 저장공간의 설명도이다. 도 2에 도시된 바와 같이, 데이터 저장공간 은 우선적인 방식으로 2차원 데이터가 저장되며, (x, y)를 통해 표시한다(그 중, X축은 수평으로 우측을 향 하고, Y축은 수직으로 아래를 향한다). X축 방향상의 크기(매 행의 크기)는 ori_x이고(미도시), Y 축의 방향상 의 크기(총 행수)는 ori_y이며(미도시), 데이터 저장공간의 시작 어드레스 PA_start(기준 어드레스)는 첫 번째 데이터블록의 물리 어드레스이다. 데이터블록은 데이터 저장공간 중의 일부 데이터로서, 그것 의 X축 방향상의 오프셋은 offset_x로 표시하고, Y축 방향상의 오프셋은 offset_y로 표시하며, X축 방 향상의 크기는 size_x로 표시하고, Y축 방향상의 크기는 size_y로 표시한다. 일종의 가능한 구현 방식에서, 디스크립터를 사용하여 데이터블록을 정의 시, 디스크립터의 데이터 기준점 은 데이터 저장공간의 첫 번째 데이터블록을 사용할 수 있으며, 디스크립터의 기준 어드레스는 데이터 저장 공간의 시작 어드레스(PA_start)이다. 이후 데이터 저장공간의 X축상에서의 크기(ori_x), Y축 상에서의 크기(ori_y), 및 데이터블록의 Y축 방향상의 오프셋(offset_y), X축 방향상의 오프셋(offset_x), X축 방향 상의 크기(size_x) 및 Y축 방향상의 크기(size_y)를 결합하여 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 21, "content": "이해하여야 할 점으로, 비록 상기 예시에서, 디스크립터가 설명하는 것은 이차원 공간이나, 당업자라면 실제 상 황에 따라 디스크립터의 콘텐츠가 나타내는 차원을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현방식에서, 상기 디스크립터의 데이터 기준점의 상기 데이터 저장공간 중에서의 기준 어드레 스, N개 차원 방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치에 따라, 상기 텐서 데이터의 디스크립터의 콘텐츠를 결정할 수 있다. 예를 들어 설명하면, 디스크립터의 데이터 기준점의 데이터 저장공간 중에서의 기준 어드레스(PA_base), 및 대 각 위치의 2개의 꼭지점의 데이터 기준점에 대한 위치를 사용하여, 도 2 중 데이터블록의 디스크립터의 콘 텐츠를 결정할 수 있다. 먼저, 디스크립터의 데이터 기준점 및 그것의 데이터 저장공간 중에서의 기준 어드레스 (PA_base)를 결정한다. 예를 들어, 데이터 저장공간에서 하나의 데이터(예를 들어 위치가 (2,2)인 데이터) 를 선택하여 데이터 기준점으로 삼고, 데이터 저장공간 중에서 상기 데이터의 물리 어드레스를 기준 어드레스 (PA_base)로 삼은 다음; 데이터블록의 대각 위치의 적어도 2개의 꼭지점의 데이터 기준점에 대한 위치를 결 정한다. 예를 들어 좌상으로부터 우하 방향인 대각 위치의 꼭지점의 데이터 기준점에 대한 위치를 사용하며, 그 중 좌상각 꼭지점의 상대위치는 (x_min，y_min)이고, 우하각 꼭지점의 상대 위치는 (x_max，y_max)이며, 이후 기준 어드레스(PA_base), 좌상각 꼭지점의 상대 위치(x_min，y_min) 및 우하각 꼭지점의 상대 위치(x_max， y_max)에 따라 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 를 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다: 이해해두어야 할 점으로, 비록 상기 예시에서 좌상각과 우하각 2개의 꼭지점을 사용하여 디스크립터의 콘텐츠를 결정하였으나, 당업자라면 실제 필요에 따라 적어도 2개의 꼭지점 중 구체적인 꼭지점을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 디스크립터의 데이터 기준점의 상기 데이터 저장공간 중에서의 기준 어드레 스, 및 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 에 따라, 상기 텐서 데이터의 디스크립터의 콘텐츠를 결정할 수 있다. 그 중, 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계는 실제 필요에 따라 설정할 수 있으며, 예를 들어, 디스크립터가 지시하는 텐서 데이 터가 3차원 공간 데이터인 경우, 함수 를 사용하여 데이터 디스크립션 위치와 데이터 어드레스 간의 매 핑 관계를 정의할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 22, "content": "이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계를 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 공식 로 디스크립터의 콘텐츠를 나타내는 경우, 텐서 데이터 중의 어느 하나의 데이터점에 대해, 그 데이터 디스크립션 위치를 라 설정한다면, 상기 데이터 저장공간 중에서 상기 데이터점의 데이터 어드레스 ( )는 하기 공식 를 사용하여 결정할 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 23, "content": "이러한 방식을 통해, 프로세서는 디스크립터의 콘텐츠에 따라 디스크립터가 지시하는 텐서 데이터의 데이터 저 장공간 중에서의 데이터 어드레스를 계산할 수 있으며, 나아가 상기 어드레스에 따라 처리 명령에 대응되는 처 리(예를 들어 데이터 연산, 데이터 동기화 등)를 실행함으로써, 데이터 액세스의 복잡도를 감소시킬 수 있어, 프로세서의 처리 효율이 향상된다. 도 3cc은 본 발명의 실시예에 따른 데이터 동기화 장치의 블록도이다. 상기 데이터 동기화 장치는 제1 프로세서 에 응용되며, 도 3cc에 도시된 바와 같이, 상기 데이터 동기화 장치는 동기화할 텐서 데이터의 디스크립터에 따라, 동기화할 텐서 데이터의 형상을 지시하기 위한 상기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립터 동기화 명령을 생성하는 동기화 명령 생성모 듈(51c); 제2 프로세서가 상기 디스크립터 동기화 명령에 따라 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위한 상기 디스크립터 동기화 명령을 상기 제2 프로세서로 전송하는 동기화 명령 송신 모듈(52c)을 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 제2 프로세서로부터의 디스크립터 동기화 요청 명령에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하 기 위한 제1 디스크립터 결정모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 요청 명령은 디스크립터의 식별자를 포함하며, 그 중, 상기 제1 디스크립터 결정모듈은 상기 디스크립터 동기화 요청 명령을 해석하여, 상기 디스크립터의 식별자를 획득하기 위한 제1 해석 서브모듈; 상기 디스크립터의 식별자에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하기 위한 제1 결정 서브모 듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 요청 명령은 상기 동기화할 텐서 데이터의 데이터 특징 을 포함하며, 그 중, 상기 제1 디스크립터 결정모듈은 상기 디스크립터 동기화 요청 명령을 해석하여, 동기화할 텐서 데이터의 데이터 특징을 획득하기 위한 제2 해석 서브모듈; 상기 동기화할 텐서 데이터의 데이터 특징에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하기 위한 제2 결정 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠 를 포함하며, 그 중, 상기 동기화 명령 생성모듈은 동기화할 텐서 데이터의 저장 어드레스가 공용 저장공간에 놓여 있는 경우, 상기 동기화할 텐서 데이터의 디스 크립터의 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화할 텐서 데이터 의 디스크립터 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위한 제1 생성 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 동기화 명령 생성모듈은 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠를 동기화 데이터 저장공간에 저장하기 위한 제1 저장 서브모 듈; 상기 디스크립터 콘텐츠의 상기 동기화 데이터 저장공간 중에서의 어드레스에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하도록 지시하기 위한 제2 생성 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 동기화 명령 생성모듈은 동기화할 텐서 데이터의 저장 어드레스가 비공용 저장공간에 놓여 있는 경우, 상기 동기화할 텐서 데이터를 공 용 저장공간에 저장하기 위한 제2 저장 서브모듈; 상기 동기화할 텐서 데이터의 공용 저장공간 중에서의 어드레스에 따라, 상기 동기화할 텐서 데이터의 디스크립 터를 생성하기 위한 디스크립터 생성 서브모듈; 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로 세서가 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위한 제3 생성 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 동기화 명령 생성모듈은 동기화할 텐서 데이터의 저장 어드레스가 비공용 저장공간에 놓여 있는 경우, 상기 동기화할 텐서 데이터를 공 용 저장공간에 저장하기 위한 제3 저장 서브모듈; 상기 동기화할 텐서 데이터의 공용 저장공간 중에서의 어드레스에 따라, 상기 동기화할 텐서 데이터의 디스크립 터를 수정하기 위한 디스크립터 수정 서브모듈; 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로세 서가 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위한 제4 생성 서브모듈을 포함한다. 도 3cd는 본 발명의 실시예에 따른 데이터 동기화 장치의 블록도이다. 상기 데이터 동기화 장치는 제2 프로세서 에 응용되며, 도 3cd에 도시된 바와 같이, 상기 데이터 동기화 장치는 제1 프로세서로부터 수신된 상기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립 터 동기화 명령을 해석하여, 동기화할 텐서 데이터의 형상을 지시하는 디스크립터를 획득하기 위한 제1 해석모 듈(61c); 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득하기 위한 제1 데이터 획득 모듈(62c)을 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠 를 포함하고, 그 중, 상기 제1 데이터 획득모듈은 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하기 위한 제1 데이터 획득 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠 의 동기화 데이터 저장공간 중에서의 어드레스를 포함하며, 그 중, 상기 제1 데이터 획득모듈은상기 동기화할 텐서 데이터의 디스크립터 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 상기 동 기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하기 위한 제1 콘텐츠 획 득 서브모듈; 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하기 위한 제2 데이터 획득 서브모듈을 포함한다. 도 3ce는 본 발명의 실시예에 따른 데이터 동기화 장치의 블록도이다. 상기 동기화 장치는 제2 프로세서에 응용 되며, 도 3ce에 도시된 바와 같이, 상기 데이터 동기화 장치는 동기화할 텐서 데이터가 존재하는 경우, 동기화할 텐서 데이터의 형상을 지시하는 디스크립터를 전송하도록 제1 프로세서에게 지시하는데 사용되는 디스크립터 동기화 요청 명령을 생성하기 위한 요청 명령 생성모듈(71c); 상기 제1 프로세서로 상기 디스크립터 동기화 요청 명령을 전송하기 위한 요청 명령 송신모듈(72c)을 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 요청 명령은 디스크립터의 식별자 및/또는 상기 동기화 할 텐서 데이터의 데이터 특징을 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는 제1 프로세서로부터 수신된 상기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립 터 동기화 명령을 해석하여, 동기화할 텐서 데이터의 디스크립터를 획득하기 위한 제2 해석모듈; 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득하기 위한 제2 데이터 획득 모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터의 콘텐 츠를 포함하며, 그 중, 상기 제2 데이터 획득모듈은, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하기 위한 제3 데이터 획득 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠 의 동기화 데이터 저장공간 중에서의 어드레스를 포함하며, 그 중, 상기 제2 데이터 획득모듈은 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 상기 동 기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하기 위한 제2 콘텐츠 획 득 서브모듈; 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하기 위한 제4 데이터 획득 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 데이터 동기화 장치를 포함하는 인공지능 칩을 더 공개한다. 일종의 가능한 구현 방식에서, 메모리 소자, 인터페이스 장치와 제어 소자 및 상기 인공지능 칩을 포함하는 보 드를 더 공개하며; 그 중 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각 각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터링하 기 위한 것이다. A1: 데이터 동기화 방법에 있어서, 상기 방법은 제1 프로세서에 응용되며, 이는 동기화할 텐서 데이터의 형상을 지시하기 위한 디스크립터에 따라, 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크 립터 동기화 명령을 생성하는 단계; 제2 프로세서가 상기 디스크립터 동기화 명령에 따라 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위한 디스크립터 동기화 명령을 제2 프로세서로 전송하는 단계를 포함한다. A2: A1항에 따른 방법에 있어서, 상기 방법은 제2 프로세서로부터의 디스크립터 동기화 요청 명령에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하는 단계를 더 포함한다. A3: A2항에 따른 방법에 있어서, 상기 디스크립터 동기화 요청 명령은 디스크립터의 식별자를 포함하며, 그 중 상기 제2 프로세서로부터의 디스크립터 동기화 요청 명령에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하는 단계는, 상기 디스크립터 동기화 요청 명령을 해석하여, 상기 디스크립터의 식별자를 획득하는 단계;상기 디스크립터의 식별자에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하는 단계를 포함한다. A4: A2항에 따른 방법에 있어서, 상기 디스크립터 동기화 요청 명령은 상기 동기화할 텐서 데이터의 데이터 특 징을 포함하며, 그 중, 상기 제2 프로세서로부터의 디스크립터 동기화 요청 명령에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하는 단계는, 상기 디스크립터 동기화 요청 명령을 해석하여, 동기화할 텐서 데이터 의 데이터 특징을 획득하는 단계; 동기화할 텐서 데이터의 데이터 특징에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하는 단계를 포함한다. A5: A1-A4 중의 어느 한 항에 따른 방법에 있어서, 상기 디스크립터 동기화 명령은 동기화할 텐서 데이터의 디 스크립터 콘텐츠를 포함하며, 그 중, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 디스크립터 동기 화 명령을 생성하는 단계는, 동기화할 텐서 데이터의 저장 어드레스가 공용 저장공간에 놓여 있는 경우, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이 터를 획득하도록 지시하는 단계를 포함한다. A6: A1-A4 중의 어느 한 항에 따른 방법에 있어서, 상기 동기화할 텐서 데이터의 디스크립터에 따라, 디스크립 터 동기화 명령을 생성하는 단계는, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 동기화 데이터 저장공간 에 저장하는 단계; 상기 디스크립터의 콘텐츠의 상기 동기화 데이터 저장공간 중에서의 어드레스에 따라, 디스 크립터 동기화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화 데이터 저장공간으로부터 상기 동기화할 텐 서 데이터의 디스크립터 콘텐츠를 획득하도록 지시하는 단계를 포함한다. A7: A1-A4 중의 어느 한 항에 따른 방법에 있어서, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 디 스크립터 동기화 명령을 생성하는 단계는, 동기화할 텐서 데이터의 저장 어드레스가 비공용 저장공간에 놓인 경 우, 상기 동기화할 텐서 데이터를 공용 저장공간에 저장하는 단계; 상기 동기화할 텐서 데이터의 공용 저장공간 중에서의 어드레스에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 생성하는 단계; 상기 동기화할 텐서 데 이터의 디스크립터 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화할 텐 서 데이터의 디스크립터 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지시하는 단계를 포함한다. A8: A1-A4 중의 어느 한 항에 따른 방법에 있어서, 상기 동기화할 텐서 데이터의 디스크립터에 따라, 디스크립 터 동기화 명령을 생성하는 단계는, 동기화할 텐서 데이터의 저장 어드레스가 비공용 저장공간에 놓인 경우, 상 기 동기화할 텐서 데이터를 공용 저장공간에 저장하는 단계; 상기 동기화할 텐서 데이터의 공용 저장공간 중에 서의 어드레스에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 수정하는 단계; 상기 동기화할 텐서 데이터 의 디스크립터 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지 시하는 단계를 포함한다. A9: 데이터 동기화 방법에 있어서, 상기 방법은 제2 프로세서에 응용되며, 이는 제1 프로세서로부터 수신되는 상기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립터 동기화 명령을 해석하여, 동기화할 텐서 데이터의 형상을 지시하기 위한 디스크립터를 획득하는 단계; 상기 동기화할 텐서 데이터의 디스 크립터에 따라, 상기 동기화할 텐서 데이터를 획득하는 단계를 포함한다. A10: A9항에 따른 방법에 있어서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘 텐츠를 포함하며, 그 중, 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득 하는 단계는, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하는 단계를 포함한다. A11: A9항에 따른 방법에 있어서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘 텐츠의 동기화 데이터 저장공간 중에서의 어드레스를 포함하며, 그 중, 상기 동기화할 텐서 데이터의 디스크립 터에 따라, 상기 동기화할 텐서 데이터를 획득하는 단계는, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 상기 동기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하는 단계; 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 동기화할 텐서 데이터를 획득하는 단계를 포함한다. A12: 데이터 동기화 방법에 있어서, 상기 방법은 제2 프로세서에 응용되며, 이는 동기화할 텐서 데이터가 존재 할 경우, 제1 프로세서가 상기 디스크립터 동기화 요청 명령에 따라, 동기화할 텐서 데이터의 형상을 지시하는디스크립터를 송신하도록 지시하기 위한 디스크립터 동기화 요청 명령을 생성하는 단계; 상기 제1 프로세서로 상기 디스크립터 동기화 요청 명령을 송신하는 단계를 포함한다. A13: A12항에 따른 방법에 있어서, 상기 디스크립터 동기화 요청 명령은 디스크립터의 식별자 및/또는 상기 동 기화할 텐서 데이터의 데이터 특징을 포함한다. A14: A12 또는 A13항에 따른 방법에 있어서, 상기 방법은, 제1 프로세서로부터 수신되는 상기 디스크립터의 식 별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립터 동기화 명령을 해석하여, 동기화할 텐서 데이터 의 디스크립터를 획득하는 단계; 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터 를 획득하는 단계를 더 포함한다. A15. A14항에 따른 방법에 있어서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘 텐츠를 포함하며, 그 중, 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득 하는 단계는, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하는 단계를 포함한다. A16: A14항에 따른 방법에 있어서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘 텐츠의 동기화 데이터 저장공간 중에서의 어드레스를 포함하며, 그 중, 상기 동기화할 텐서 데이터의 디스크립 터에 따라, 상기 동기화할 텐서 데이터를 획득하는 단계는, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 상기 동기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하는 단계; 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하는 단계를 포함한다. A17: 데이터 동기화 장치에 있어서, 상기 장치는 제1 프로세서에 응용되며, 이는 동기화할 텐서 데이터의 디스 크립터에 따라, 동기화할 텐서 데이터의 형상을 지시하기 위한 상기 디스크립터의 식별자 및/또는 상기 디스크 립터의 콘텐츠를 포함하는 디스크립터 동기화 명령을 생성하는 동기화 명령 생성모듈; 제2 프로세서가 상기 디 스크립터 동기화 명령에 따라 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위한 상기 디스크립터 동기화 명령을 상기 제2 프로세서로 전송하는 동기화 명령 송신 모듈을 포함한다. A18: A17항에 따른 장치에 있어서, 상기 장치는, 제2 프로세서로부터의 디스크립터 동기화 요청 명령에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하기 위한 제1 디스크립터 결정모듈을 더 포함한다. A19: A18항에 따른 장치에 있어서, 상기 디스크립터 동기화 요청 명령은 디스크립터의 식별자를 포함하며, 그 중, 상기 제1 디스크립터 결정모듈은, 상기 디스크립터 동기화 요청 명령을 해석하여, 상기 디스크립터의 식별 자를 획득하기 위한 제1 해석 서브모듈; 상기 디스크립터의 식별자에 따라, 상기 동기화할 텐서 데이터의 디스 크립터를 결정하기 위한 제1 결정 서브모듈을 포함한다. A20: A18항에 따른 장치에 있어서, 상기 디스크립터 동기화 요청 명령은 상기 동기화할 텐서 데이터의 데이터 특징을 포함하며, 그 중, 상기 제1 디스크립터 결정모듈은, 상기 디스크립터 동기화 요청 명령을 해석하여, 동 기화할 텐서 데이터의 데이터 특징을 획득하기 위한 제2 해석 서브모듈; 상기 동기화할 텐서 데이터의 데이터 특징에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 결정하기 위한 제2 결정 서브모듈을 포함한다. A21: A17-A20 중의 어느 한 항에 따른 장치에 있어서, 상기 디스크립터 동기화 명령은 동기화할 텐서 데이터의 디스크립터 콘텐츠를 포함하며, 그 중, 상기 동기화 명령 생성모듈은, 동기화할 텐서 데이터의 저장 어드레스가 공용 저장공간에 놓여 있는 경우, 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠에 따라, 디스크립터 동기 화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위한 제1 생성 서브모듈을 포함한다. A22: A17-A20 중의 어느 한 항에 따른 장치에 있어서, 상기 동기화 명령 생성모듈은, 상기 동기화할 텐서 데이 터의 디스크립터의 콘텐츠를 동기화 데이터 저장공간에 저장하기 위한 제1 저장 서브모듈; 상기 디스크립터 콘 텐츠의 상기 동기화 데이터 저장공간 중에서의 어드레스에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하도 록 지시하기 위한 제2 생성 서브모듈을 포함한다. A23: A17-A20 중의 어느 한 항에 따른 장치에 있어서, 상기 동기화 명령 생성모듈은, 동기화할 텐서 데이터의 저장 어드레스가 비공용 저장공간에 놓여 있는 경우, 상기 동기화할 텐서 데이터를 공용 저장공간에 저장하기 위한 제2 저장 서브모듈; 상기 동기화할 텐서 데이터의 공용 저장공간 중에서의 어드레스에 따라, 상기 동기화할 텐서 데이터의 디스크립터를 생성하기 위한 디스크립터 생성 서브모듈; 상기 동기화할 텐서 데이터의 디스크 립터의 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위한 제3 생성 서브모듈을 포함한다. A24: A17-A20 중의 어느 한 항에 따른 장치에 있어서, 상기 동기화 명령 생성모듈은, 동기화할 텐서 데이터의 저장 어드레스가 비공용 저장공간에 놓여 있는 경우, 상기 동기화할 텐서 데이터를 공용 저장공간에 저장하기 위한 제3 저장 서브모듈; 상기 동기화할 텐서 데이터의 공용 저장공간 중에서의 어드레스에 따라, 상기 동기화 할 텐서 데이터의 디스크립터를 수정하기 위한 디스크립터 수정 서브모듈; 상기 동기화할 텐서 데이터의 디스크 립터 콘텐츠에 따라, 디스크립터 동기화 명령을 생성하여, 상기 제2 프로세서가 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 상기 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하도록 지시하기 위 한 제4 생성 서브모듈을 포함한다. A25: 데이터 동기화 장치에 있어서, 상기 장치는 제2 프로세서에 응용되며, 이는 제1 프로세서로부터 수신된 상 기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립터 동기화 명령을 해석하여, 동 기화할 텐서 데이터의 형상을 지시하는 디스크립터를 획득하기 위한 제1 해석모듈; 상기 동기화할 텐서 데이터 의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득하기 위한 제1 데이터 획득모듈을 포함한다. A26: A25항에 따른 장치에 있어서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘 텐츠를 포함하며, 그 중, 상기 제1 데이터 획득모듈은, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하기 위한 제1 데이터 획득 서브모듈을 포함한 다. A27: A25항에 따른 장치에 있어서, 상기 디스크립터 동기화 명령은 동기화할 텐서 데이터의 디스크립터 콘텐츠 의 동기화 데이터 저장공간 중에서의 어드레스를 포함하며, 그 중, 상기 제1 데이터 획득모듈은 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 상기 동 기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하기 위한 제1 콘텐츠 획 득 서브모듈; 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하기 위한 제2 데이터 획득 서브모듈을 포함한다. A28: 데이터 동기화 장치에 있어서, 상기 장치는 제2 프로세서에 응용되며, 이는, 동기화할 텐서 데이터가 존재 하는 경우, 동기화할 텐서 데이터의 형상을 지시하는 디스크립터를 전송하도록 제1 프로세서에게 지시하는데 사 용되는 디스크립터 동기화 요청 명령을 생성하기 위한 요청 명령 생성모듈; 상기 제1 프로세서로 상기 디스크립 터 동기화 요청 명령을 전송하기 위한 요청 명령 송신모듈을 포함한다. A29: A28항에 따른 장치에 있어서, 상기 디스크립터 동기화 요청 명령은 디스크립터의 식별자 및/또는 상기 동 기화할 텐서 데이터의 데이터 특징을 포함한다. A30: A28 또는 A29항에 따른 장치에 있어서, 상기 장치는 제1 프로세서로부터 수신된 상기 디스크립터의 식별자 및/또는 상기 디스크립터의 콘텐츠를 포함하는 디스크립 터 동기화 명령을 해석하여, 동기화할 텐서 데이터의 디스크립터를 획득하기 위한 제2 해석모듈; 상기 동기화할 텐서 데이터의 디스크립터에 따라, 상기 동기화할 텐서 데이터를 획득하기 위한 제2 데이터 획득모듈을 더 포함 한다. A31: A30항에 따른 장치에 있어서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터의 콘텐츠를 포함하며, 그 중, 상기 제2 데이터 획득모듈은, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따 라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하기 위한 제3 데이터 획득 서브모듈을 포함한다. A32: A30항에 따른 장치에 있어서, 상기 디스크립터 동기화 명령은 상기 동기화할 텐서 데이터의 디스크립터 콘 텐츠의 동기화 데이터 저장공간 중에서의 어드레스를 포함하며, 그 중, 상기 제2 데이터 획득모듈은, 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스에 따라, 상기 동 기화 데이터 저장공간으로부터 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하기 위한 제2 콘텐츠 획 득 서브모듈; 상기 동기화할 텐서 데이터의 디스크립터 콘텐츠에 따라, 공용 저장공간으로부터 상기 동기화할 텐서 데이터를 획득하기 위한 제4 데이터 획득 서브모듈을 포함한다.A33: 인공지능 칩에 있어서, 상기 칩은 A17-A32 중의 어느 한 항에 따른 데이터 동기화 장치를 포함한다. A34: 전자장치에 있어서, 상기 전자장치는 A33항에 따른 인공지능 칩을 포함한다. A35: 보드에 있어서, 상기 보드는 메모리 소자, 인터페이스 장치와 제어 소자 및 A33항에 따른 인공지능 칩을 포함하며; 그 중 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결 되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터링하기 위 한 것이다. A36: A35항에 따른 보드에 있어서, 상기 메모리 소자는 다수 그룹의 저장유닛을 포함하며, 각 그룹의 상기 저장 유닛과 상기 인공지능 칩은 버스를 통해 연결되고, 상기 저장유닛은 DDR SDRAM이며; 상기 칩은 각각의 상기 저 장유닛의 데이터 전송과 데이터 저장을 제어하기 위한 DDR 컨트롤러를 포함하고; 상기 인터페이스 장치는 표준 PCIE 인터페이스이다. 인공지능 기술이 지속적으로 발전함에 따라, 처리해야 할 데이터량과 데이터 차원이 모두 지속적으로 커지고 있 다. 관련 기술에서, 다수의 연산이 동일한 저장영역에 대해 연산을 수행 시, 앞줄의 연산이 완료되어야만, 다음 줄의 연산을 실행할 수 있어, 프로세서의 처리 효율이 저하된다. 본 발명의 실시예에 따르면, 프로세서 연산 방법을 제공한다. 도 1da은 본 발명의 실시예에 따른 응용 시나리오 의 설명도이다. 그 중, 프로세서는 범용 프로세서(예를 들어 중앙처리장치(CPU), 그래픽 프로세서(GPU))와 전용 프로세서(예를 들어 인공지능 프로세서, 공학용 컴퓨터 프로세서 또는 디지털 신호 프로세서 등)를 포함할 수 있다. 본 발명은 프로세서의 유형에 대해서는 제한을 두지 않는다. 저장장치는 적어도 하나의 타겟 저 장영역을 포함하며, 그 중, 타겟 저장영역은 디스크립터가 지시하는 텐서 데이터의 저장영역일 수 있 다. 프로세서는 읽기 연산 또는 쓰기 연산의 실행을 통해 어떤 타겟 저장영역에 액세스할 수 있으며, 프로 세서가 실행하는 어떤 타겟 저장영역에 대한 읽기 연산은, 프로세서가 디스크립터를 통해 상기 타겟 저장 영역 중의 텐서 데이터를 획득하는 것일 수 있다. 프로세서가 실행하는 어떤 타겟 저장영역에 대한 쓰기 연산은, 프로세서가 디스크립터가 지시하는 텐서 데이터를 상기 타겟 저장영역에 입력(write)하는 것 일 수 있다. 관련 기술에서, 프로세서는 다수의 연산을 병행하여 실행할 수 있기 때문에, 충돌을 피하기 위하여, 프로세서가 병행 실행하는 다수의 연산이 모두 어떤 타겟 저장영역에 대한 연산일 때, 프로세서는 상기 다수의 연산 중의 하나만 실행하고, 이와 동시에 다른 연산은 차단함으로써, 프로세서의 효율 저하를 초래 한다. 본 발명이 제공하는 프로세서 연산 방법은 타겟 저장영역을 다수의 파인-그레인드(fine-grained) 영 역으로 더 분할하여, 프로세서가 병행 실행하는 다수의 연산이 모두 어떤 타겟 저장영역에 대한 연산 일 때, 프로세서가 상기 다수의 연산이 대상으로 하는 파인-그레인드 영역이 중첩되는지 여부를 판단할 수 있으며, 만약 각 연산이 대상으로 하는 파인-그레인드 영역이 중첩되지 않으면, 상기 다수의 연산을 병행 실행할 수 있으며, 따라서, 프로세서의 효율이 대폭 향상된다. 설명해두어야 할 점으로, 저장장치는 프로 세서 내부(예를 들어 온칩 캐시 또는 레지스터 등)에 설치될 수도 있고, 프로세서의 외부에 설치될 수 있으면서 프로세서와 데이터 통신을 할 수도 있다(예를 들어 오프칩 메모리 등). 본 발명은 저장장치의 유형에 대해서는 제한을 두지 않는다. 본 발명이 다루는 연산은, 프로세서 하드웨어가 지원하는 기본 연산일 수도 있고, 상기 기 본 연산을 해석한 후의 마이크로 코드(예를 들어 요청 신호 등)일 수도 있다. 본 발명은 연산의 구체적인 유형 에 대해 제한을 두지 않는다. 본 발명의 프로세서는 2개의 연산을 병행 실행할 수도 있고, 2개 이상의 연산을 병행 실행할 수도 있으며, 본 발명은 병행 실행하는 연산의 수량에 대해 한정하지 않는다. 도 1db는 본 발명의 실시예에 따른 프로세서 연산 방법의 흐름도이다. 상기 프로세서 연산 방법은 프로세서에 응용될 수 있다. 도 1db에 도시된 바와 같이, 상기 프로세서 연산 방법은 이하 단계를 포함한다: 단계 S11d: 제1 연산이 디스크립터에 대한 연산인 경우, 상기 디스크립터가 지시하는 텐서 데이터의 타겟 저장 영역을 획득한다. 제1 연산은 디스크립터에 대한 읽기 연산 또는 쓰기 연산일 수 있다. 본 발명은 제1 연산의 구체적인 유형에 대 해서는 제한을 두지 않는다. 디스크립터는 텐서 데이터의 형상을 지시하기 위한 것일 수 있다. 그 중, 텐서는 다양한 형식의 데이터 구성 방식을 포함할 수 있고, 텐서는 상이한 차원일 수 있으며, 예를 들어 스칼라는 0차 원의 텐서로 간주할 수 있고, 벡터는 1차원의 텐서로 간주할 수 있으며, 매트릭스는 2차원 또는 2차원 이상의 텐서일 수 있다. 텐서의 형상은 텐서의 차원, 텐서 각 차원의 크기 등 정보를 포함한다. 예를 들어 설명하면, 텐서의 경우:이다. 상기 텐서의 형상은 디스크립터에 의해 (2,4)로 기술된다. 즉 2개의 파라미터를 통해 상기 텐서가 2차원 텐서임 을 나타내며, 또한 상기 텐서의 제1 차원(열)의 크기는 2이고, 제2 차원(행)의 크기는 4이다. 설명해두어야 할 점으로, 본 출원은 디스크립터가 텐서의 형상을 지시하는 방식에 대해서는 한정하지 않는다. 일종의 가능한 구현 방식에서, 제1 연산의 피연산자는 하나 또는 다수의 디스크립터일 수 있다. 타겟 저장영역 은 제1 연산의 피연산자 중 하나 또는 다수의 디스크립터가 지시하는 텐서 데이터의 저장영역일 수도 있고, 제1 연산의 피연산자 중 어느 하나의 디스크립터가 지시하는 텐서 데이터의 저장공간일 수도 있다. 타겟 저장영역이 소재하는 전체 저장영역은 프로세서의 내부 메모리(예를 들어 온칩 캐시 또는 레지스터 등)일 수도 있고, 프로 세서에 연결되는 외부 메모리(예를 들어 오프칩 메모리 등)일 수도 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역은 적어도 하나의 파인-그레인드 영역을 포함할 수 있다. 그 중, 파인-그레인드 영역의 크기 및/또는 수량의 결정 방식은, 하드웨어 설계에 따라 결정하는 방식, 디스크립터가 지시하는 텐서 데이터의 관련 연산에 따라 결정하는 방식, 연산 중 관련 파라미터에 따라 정의하는 방식 중의 하나 또는 임의의 조합을 포함할 수 있다. 그 중, 하드웨어 설계에 따라 결정하는 방식은, 즉 하드웨어를 설계 시 파인-그레인드 영역의 크기를 결정하는 것으로서, 예컨대 타겟 저장영역의 1행 또는 다수 행을 하나의 파인- 그레인드 영역으로 결정한다. 디스크립터가 지시하는 텐서 데이터의 관련 연산에 따라 결정하는 방식은 디스크 립터가 지시하는 텐서 데이터의 처리 수요, 저장방식, 또는 전송방식 등에 따라 결정하는 방식을 포함하며, 예 를 들어 디스크립터가 지시하는 텐서 데이터는 하나의 2차원 매트릭스 데이터이고, 그 규모는 M*Q(M, Q는 모두 양의 정수)이며, 저장하는데 차지하는 바이트 수, 즉 1행은 M바이트이고, 총 Q행이 있음을 나타내며, M바이트를 하나의 파인-그레인드 영역으로 결정할 수 있다. 상기 디스크립터가 지시하는 텐서 데이터에 대응되는 타겟 저 장영역은 Q개의 파인-그레인드 영역을 포함한다. 연산 중 관련 파라미터에 따라 정의하는 방식은, 연산에 드는 파인-그레인드의 크기 및/또는 수량에 따라, 타겟 저장영역을 다수의 파인-그레인드 영역으로 분할하는 방식을 포함한다. 설명해두어야 할 점으로, 다수의 파인-그레인드 영역의 크기는 동일할 수도 있고 다를 수도 있다. 예 를 들어, 각 파인-그레인드 영역의 데이터 비트수는 각각 64비트, 256비트, 512비트 등일 수 있다. 필요에 따라 각 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제1 연산이 디스크립터에 대한 연산일 경우, 제1 연산이 대상으로 하는 디스크립 터를 통해, 상기 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역을 획득함으로써, 제1 연산이 대상으로 하 는 타겟 저장영역을 결정할 수 있다. 단계 S12d: 상기 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단한다. 그 중, 제2 연산은 읽기 연산 또는 쓰기 연산일 수 있으며, 본 발명은 제2 연산의 구체적인 유형에 대해 제한을 두지 않는다. 제2 연산은 하나 또는 다수의 피연산자를 포함할 수 있고, 제2 연산의 피연산자는 디스크립터, 즉 치(immidiate), 텐서 데이터 등의 각종 데이터일 수 있으며, 본 발명은 제2 연산의 피연산자의 구체적인 수량과 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역의 점용 상태를 통해, 타겟 저장영역에 대해 실행되고 있는 제2 연산이 존재하는지 여부를 판단할 수 있다. 예를 들어, 프로세서는 점용 상태 테이블의 조회를 통해 타겟 저장영역의 점용 여부를 판단할 수 있으며, 점용되고 있다면, 즉 판단 결과는 타겟 저장영역에 대해 실행되고 있는 제2 연산이 존재한다는 것이다. 그 중, 상기 점용 상태 테이블은 메모리에 미리 설치되어 저장될 수도 있 고, 프로세서가 어떤 임무를 실행하기 시작하기 전에 생성되고, 상기 임무가 완료된 후 취소되는 것일 수도 있 다. 각 저장영역의 점용 상태에 변화가 발생 시, 프로세서는 상기 점용 상태 테이블의 콘텐츠를 업데이트하여, 각 저장영역의 점용상태를 기록한다. 일종의 가능한 구현 방식에서, 각 연산의 실행 상태 조회를 통해 상기 타겟 저장영역에 대해 실행되고 있는 제2 연산이 존재하는지 여부를 판단할 수 있다. 예를 들어, 각 연산의 피연산자에 대응되는 저장영역을 기록하고, 각 연산의 실행 상태를 기록할 수 있다. 타겟 저장영역에 대한 연산이 완료되지 않은 상태라면, 즉 판단 결과는 상기 타겟 저장영역에 대해 실행 중인 제2 연산이 존재한다는 것이다. 피연산자의 점용 상태 판단을 통해서도, 피연산자에 대응되는 타겟 저장영역이 점용되고 있는지 여부를 결정하여, 상기 타겟 저장영역에 대해 실행 중인 제2 연산이 존재하는지 여부를 결정할 수 있다. 본 발명은 상기 타겟 저장영역에 대해 실행 중인 제2 연산이 존 재하는지 여부를 판단하는 판단 근거에 대해 한정하지 않는다.일종의 가능한 구현 방식에서, 제2 연산은 디스크립터에 대한 연산일 수 있고, 제2 연산이 대상으로 하는 디스 크립터는 제1 연산이 대상으로 하는 디스크립터와 일치할 수 있다. 즉 제2 연산이 대상으로 하는 디스크립터의 저장영역이 타겟 저장영역과 일치하여, 제2 연산이 완료되지 않았을 때, 타겟 저장영역에 대한 제2 연산이 존재 하거나; 또는 제2 연산이 대상으로 하는 디스크립터의 저장영역과 타겟 저장영역에 중첩 영역이 있어, 제2 연산 이 중첩 영역에 대해 연산을 실행 시, 즉 타겟 저장영역에 대한 제2 연산이 존재할 수 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역에 대한 제1 연산을 실행하기 전, 상기 타겟 저장영역에 대해 실행 되고 있는 제2 연산이 존재하는지 여부를 판단할 수 있다. 일종의 가능한 구현 방식에서, 제1 연산의 타겟 저장영역에 대한 실행 과정에서도 타겟 저장영역에 대해 실행되 고 있는 제2 연산이 존재하는지 여부를 판단할 수 있다. 단계 S13d: 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파인- 그레인드 영역과 상기 제2 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역 사이의 중첩 여부를 판단한다. 제1 파인-그레인드 영역과 제2 파인-그레인드 영역은 타겟 저장영역 중 다수의 파인-그레인드 영역 중의 임의의 파인-그레인드 영역일 수 있다. 타겟 저장영역이 소재하는 전체 저장영역을 파인-그레인드로 분할한 것일 수 있 으며, 즉 전체 저장영역에 대해 각 연산이 대상으로 하는 파인-그레인드 영역의 크기는 일치한다. 또한 각 연산이 피연산자가 대상으로 하는 저장영역을 각 연산에 수반되는 파인-그레인드 분할 정보에 따라 파 인-그레인드 분할을 한 것일 수도 있으며, 즉, 동일한 저장영역에 대하여, 상이한 연산으로 각기 다른 입도의 파인-그레인드 분할을 수행할 수 있다. 제1 파인-그레인드 영역은 제1 연산이 타겟 저장영역을 다수의 파인-그 레인드 영역으로 분할한 임의의 파인-그레인드 영역일 수 있고, 제2 파인-그레인드 영역은 제2 연산이 그것의 피연산자가 소재하는 저장영역을 파인-그레인드 분할한 후 획득되는 임의의 파인-그레인드 영역일 수 있다. 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 크기는 다를 수 있다. 예를 들어, 제1 연산은 제1 파인-그레인드의 크기(각 파인-그레인드 영역의 데이터 비트수)를 수반(carry)할 수 있고, 상기 제1 파인-그레인드의 크기를 64비트로 설정할 수 있으며, 제2 연산은 제2 파인-그레인드의 크기(각 파인-그레인드 영역의 데이터 비트수)를 수반할 수 있고, 상기 제2 파인-그레인드의 크기를 256비트로 설정할 수 있다. 즉 제1 연산을 실행 시, 각 64비트마다 하나의 파인-그레인드 영역으로 삼고, 제2 연산을 실행 시, 각 256비트마다 하나의 파인-그레인드 영역으로 삼는다. 또한, 제1 연산과 제2 연산에 수반되는 파인-그레인드의 크기(각 파인-그레인드 영역의 데이터 비트수)는 모두 512비트이다. 마찬가지로, 제1 연산은 제1 파인-그레인드 의 수량(예를 들어 4개로 설정)을 수반할 수 있고, 제2 연산은 제2 파인-그레인드의 수량(예를 들어 8개로 설정)을 수반할 수 있다. 즉 제1 연산을 실행 시, 타겟 저장영역을 4개의 파인-그레인드 영역으로 분할하고, 제 2 연산을 실행시, 타겟 저장영역을 8개의 파인-그레인드 영역으로 분할한다. 연산에는 파인-그레인드의 크기와 수량인 2개의 파라미터를 동시에 수반할 수도 있음을 이해할 수 있을 것이다. 필요에 따라 각 파인-그레인드 영 역의 크기 및/또는 수량을 결정할 수 있으며, 본 발명은 이에 대해 한정하지 않는다. 타겟 저장영역에 대한 연산은 즉 타겟 저장영역 중 각 파인-그레인드 영역에 대한 연산임을 이해할 수 있을 것 이다. 예를 들어 타겟 저장영역 A는 제1행 내지 제10행이고, 각 1행은 하나의 파인-그레인드 영역이며, 타겟 저 장영역 A는 10개의 파인-그레인드 영역을 포함한다. 타겟 저장영역 A에 대한 쓰기 연산은 이 10개의 파인-그레 인드 영역에 대한 쓰기 연산으로 간주할 수 있다. 그 실행 과정은, 첫 번째 파인-그레인드 영역(제1행)을 쓰고, 첫 번째 파인-그레인드 영역의 쓰기가 완료된 후, 두 번째 파인-그레인드 영역(제2행)을 쓰며, 두 번째 파인-그 레인드 영역의 쓰기가 완료된 후 세 번째 파인-그레인드 영역(제3행)을 쓰며, 이와 같이 유추하여, 열 번째 파 인-그레인드 영역(제10행)까지 쓰기를 완료하면, 타겟 저장영역 A의 쓰기 연산이 완료된다. 타겟 저장영역에 대한 연산이 존재 시, 연산이 실행됨에 따라, 타겟 저장영역 중의 파인-그레인드 영역의 상태 는 이미 연산이 완료된 상태, 연산이 진행 중인 상태와 미연산 상태를 포함할 수 있다. 현재 대상으로 하는 파 인-그레인드 영역을 연산하는 상태는 연산이 진행 중인 상태이다. 이에 따라, 타겟 저장영역에 대한 연산이 존 재 시, 타겟 저장영역 중의 하나의 파인-그레인드 영역에 대한 연산이 존재하는 것으로 여길 수 있으며, 연산 중인 파인-그레인드 영역이 즉, 연산이 현재 대상으로 하는 파인-그레인드 영역이다. 일종의 가능한 구현 방식에서, 제1 연산이 현재 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역은 실행할 제1 연산이 대상으로 하는 타겟 저장영역 중의 파인-그레인드 영역, 통상적으로는 첫 번째 파인-그레인 드 영역을 포함할 수 있다. 실행 중인 제1 연산이 현재 대상으로 하는 타겟 저장영역 중의 파인-그레인드 영역을 포함할 수도 있으며, 어느 하나의 파인-그레인드 영역일 수 있다. 제2 연산이 현재 대상으로 하는 타겟 저장 영역 중의 제2 파인-그레인드 영역은 실행 중인 제2 연산이 현재 대상으로 하는 타겟 저장영역 중의 파인-그레 인드 영역일 수 있으며, 어느 하나의 파인-그레인드 영역일 수 있다. 일종의 가능한 구현 방식에서, 물리 어드레스, 포인터 위치, 파인-그레인드 영역 식별자 등에 따라, 제1 연산이 현재 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역과 제2 연산이 현재 대상으로 하는 타겟 저장영 역 중의 제2 파인-그레인드 영역 간의 중첩 여부를 판단할 수 있다. 예를 들어, 각 연산의 현재 물리 어드레스 를 기록할 수 있으며, 제1 연산의 현재의 물리 어드레스 및 제2 연산의 현재의 물리 어드레스, 및 물리 어드레 스와 파인-그레인드 영역 간의 대응관계에 따라, 제1 연산이 현재 대상으로 하는 타겟 저장영역 중의 제1 파인- 그레인드 영역과 제2 연산이 현재 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영역을 각각 결정하고, 나아가 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 판단할 수 있다. 물리 어드레스는 파 인-그레인드 영역의 시작 어드레스, 종료 어드레스, 설정위치의 어드레스 또는 실시간 연산 어드레스 중의 하나 또는 임의의 조합을 포함할 수 있다. 또한, 각 연산에 포인터를 설치할 수 있으며, 포인터는 연산이 현재 대상 으로 하는 파인-그레인드 영역을 가리킨다. 제1 연산의 포인터 위치와 제2 연산의 포인터 위치에 따라 제1 연산 이 현재 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역과 제2 연산이 현재 대상으로 하는 타겟 저 장영역 중의 제2 파인-그레인드 영역을 각각 결정하고, 나아가 제1 파인-그레인드 영역과 제2 파인-그레인드 영 역의 중첩 여부를 판단할 수 있다. 또한 예를 들어, 각 파인-그레인드 영역에 식별자를 설치할 수도 있으며, 연 산이 현재 대상으로 하는 파인-그레인드 영역의 식별자를 기록함으로써 제1 파인-그레인드 영역과 제2 파인-그 레인드 영역의 중첩 여부를 판단할 수 있다. 식별자는 알파벳, 숫자 또는 부호의 임의의 조합을 포함할 수 있다. 또한 기타 방식을 통해 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 판단할 수도 있 으며, 본 발명은 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간의 중첩 여부의 판단 근거에 대해 제한을 두지 않는다. 단계 S14d: 상기 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간이 중첩되지 않을 경우, 상기 제1 연산을 실행하는 단계. 일종의 가능한 구현 방식에서, 만약 제1 연산이 현재 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영 역과 제2 연산이 현재 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영역이 중첩되지 않으면, 즉 제1 파인-그레인드 영역은 제2 연산이 이미 연산을 완료한 파인-그레인드 영역일 수도 있고, 제2 연산이 연산을 실 행할 필요가 없는 파인-그레인드 영역일 수도 있으며, 이때 제1 연산을 실행하더라도 제2 연산에 대한 연산 과 정 및 연산 결과에 영향을 미치지 않아, 제1 연산을 실행할 수 있다. 본 실시예에 따르면, 제1 연산을 디스크립터에 대한 연산으로 삼을 때, 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역을 획득하여, 타겟 저장영역에 대해 실행되고 있는 제2 연산이 존재 시, 현재 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역과 제2 연산이 현재 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인 드 영역 간의 중첩 여부를 판단할 수 있으며, 양자가 중첩되지 않을 때, 제1 연산을 실행한다. 이와 같이 하면, 제1 연산과 제2 연산은 현재 연산하는 파인-그레인드 영역에 중첩이 없으면 즉시 실행 가능하므로, 제1 연산과 제2 연산이 동시에 타겟 저장영역에 대해 연산을 수행하도록 함으로써, 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 방법은, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역에 중 첩이 있는 경우, 상기 제1 연산을 차단하는 단계를 더 포함할 수 있다. 일종의 가능한 구현 방식에서, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩은, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 완전 중첩 또는 부분 중첩을 포함한다. 제1 파인-그레인드 영역과 제2 파인- 그레인드 영역이 중첩 시, 제1 연산을 실행한다면, 즉 제1 연산은 중첩 부분의 영역에 대한 연산으로서, 제2 연 산의 실행에 영향을 미쳐 제2 연산의 연산 결과가 부정확해질 수도 있고, 제1 연산의 실행에 영향을 미쳐 제1 연산의 연산 결과가 부정확해질 수도 있다. 이때, 제1 연산을 차단하여, 즉 제1 연산의 실행을 임시 정지시킬 수 있으며, 제2 연산이 현재 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영역에 대한 연산을 완료한 후, 제1 연산을 실행할 수 있다. 즉 제1 파인-그레인드 영역과 제2 파인-그레인드 영역이 중첩되지 않을 때 제1 연산을 실행한다. 본 실시예에서, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역이 중첩 시, 제1 연산을 차단하여, 각 연산의 파인-그레인드 영역의 중첩으로 인한 연산 에러, 연산 결과의 부정확성을 피하고, 각 연산의 정확성을 보장할 수 있다. 도 5a와 도 5b는 본 발명의 실시예에 따른 프로세서 연산 방법의 응용 시나리오 설명도이다. 도 5a와 도 5b에 도시된 바와 같이, 전체 저장영역(20d)은 타겟 저장영역(21d)을 포함하며, 그 중, 타겟 저장영역(21d)은 4개의 파인-그레인드 영역으로 분할되며, 순차적으로 파인-그레인드 영역(22d), 파인-그레인드 영역(23d), 파인-그레 인드 영역(24d)과 파인-그레인드 영역(25d)이다. 도 5a에 도시된 바와 같이, 현재 쓰기 연산만 포함한다면, 쓰기 포인터(wp)로 쓰기 연산이 현재 대상으로 하는 타겟 저장영역(21d) 중의 파인-그레인드 영역을 표시한다. 쓰기 연산이 막 시작되면, 쓰기 포인터(wp)는 파인- 그레인드 영역(22d)을 가리키며, 먼저 타겟 저장영역(21d)에 대해 진행 중인 제2 연산이 존재하는지 여부를 판 단할 수 있다. 만약 판단 결과 제2 연산이 존재하지 않는다면, 즉 파인-그레인드 영역(22d)에 대한 쓰기 연산을 시작한다. 파인-그레인드 영역(22d)에 대한 쓰기 연산이 완료된 후, 쓰기 포인터(wp)가 증가되어, 즉 wp++이며, 다음 파인-그레인드 영역(23d)을 가리킨다. 동일한 판단을 수행한 후, 파인-그레인드 영역(23d)에 대한 쓰기 연 산을 시작하며, 파인-그레인드 영역(23d)에 대한 쓰기 연산이 완료된 후, 쓰기 포인터(wp)가 증가하여, 다음 파 인-그레인드 영역(24d)을 가리키고, 동일한 판단을 수행한 후, 파인-그레인드 영역(24d)에 대한 쓰기 연산을 시 작한다. 또한 도 5b에 도시된 바와 같이, 현재 2개의 연산인 읽기 연산과 쓰기 연산을 포함하며, 그 중 읽기 연산은 제1 연산이고, 쓰기 연산은 제2 연산이다. 또한 쓰기 연산의 쓰기 포인터(wp)와 읽기 연산의 읽기 포인터(rp)로 쓰 기 연산과 읽기 연산이 현재 대상으로 하는 파인-그레인드 영역을 표시한다. 읽기 연산(제1 연산)을 실행 시, 타겟 저장영역(21d)에 대해 진행되고 있는 제2 연산이 존재하는지 여부를 판단 한다. 판단을 통해, 현재 타겟 저장영역(21d)에 대해 진행 중인 제2 연산인 쓰기 연산이 존재하면, 읽기 연산 (제1 연산)이 현재 대상으로 하는 타겟 저장영역(21d) 중의 제1 파인-그레인드 영역(도 5b 중의 파인-그레인드 영역(22d))과 쓰기 연산(제2 연산)이 현재 대상으로 하는 타겟 저장영역(21d) 중의 제2 파인-그레인드 영역(도 5b 중의 파인-그레인드 영역(24d)) 간의 중첩 여부를 더 판단한다. 예를 들어 파인-그레인드 영역의 번호(22d와 24d), 또는 rp와 wp 간의 관계(rp=0，wp=2，rp<wp)에 따라, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 사이가 중첩되지 않는 것을 결정한 후, 읽기 연산(제1 연산)을 실행할 수 있다. 파인-그레인드 영역(22d)에 대한 읽기 연산이 완료된 후, rp가 증가하여, 즉 rp++이고, 다음 파인-그레인드 영 역(23d)을 가리키며, 동일한 판단을 수행한 후, 제1 연산이 파인-그레인드 영역(23d)에 대한 연산을 시작한다. 파인-그레인드 영역(23d)에 대한 읽기 연산이 완료된 후, rp가 증가하여 다음 파인-그레인드 영역(24d)을 가리 킨다. 이러한 경우, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간의 중첩 여부를 계속 판단하며, 파인- 그레인드 영역의 번호가 동일하거나 또는 포인터가 rp=wp라면, 즉 제1 연산이 현재 대상으로 하는 타겟 저장영 역(21d) 중의 제1 파인-그레인드 영역과 제2 연산이 현재 대상으로 하는 타겟 저장영역(21d) 중의 제2 파인-그 레인드 영역이 중첩된다고 판단할 수 있으며, 즉 제1 연산을 실행할 수 없어, 제1 연산을 차단한다. 제2 연산이 파인-그레인드 영역(24d)에 대한 연산을 완료한 후, wp가 증가하여, 다음 파인-그레인드 영역(25d)을 가리킬 때, 파인-그레인드 영역의 번호는 상이하거나(24d와 25d) 또는 포인터는 rp<wp이며, 제1 연산을 실행할 수 있다. 일종의 가능한 구현 방식에서, 상기 제1 연산과 상기 제2 연산 중의 적어도 하나의 연산은 쓰기 연산이다. 즉, 피연산자에 대한 연산이 쓰기 후 읽기(제2 연산은 쓰기 연산이고, 제1 연산은 읽기 연산이다), 읽기 후 쓰기(제 2 연산은 읽기 연산이고, 제1 연산은 쓰기 연산이다) 또는 쓰기 후 쓰기(제2 연산과 제1 연산은 모두 쓰기 연산 이다)일 때, 본 발명의 실시예 중의 방법을 사용할 수 있다. 예를 들어, 만약 제1 연산이 디스크립터에 대한 읽기 연산이고, 제2 연산이 쓰기 연산이면, 제1 연산이 읽어야 할 디스크립터가 지시하는 텐서 데이터는 제2 연산인 쓰기 연산 이후의 데이터여야 하고, 제2 연산이 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영역의 번호가 8이면, 죽 제1 연산은 번호가 8 이전인 파인-그레인 드 영역의 데이터만 독취할 수 있다. 다시 말해, 만약 제1 연산이 현재 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역이 번호가 1~7인 파인-그레인드 영역 중의 어느 하나이면, 즉 제1 연산을 실행할 수 있다. 일종의 가능한 구현 방식에서, 만약 제1 연산과 제2 연산이 모두 읽기 연산이면, 제1 연산과 제2 연산의 파인- 그레인드 영역 간의 관계는 연산 결과에 영향을 미치지 않아 본 발명의 실시예 중의 방법을 사용할 수 있으며, 파인-그레인드 영역의 판단 없이 직접 제1 연산을 실행할 수도 있다. 본 실시예에서, 제1 연산과 제2 연산 중의 적어도 하나의 연산이 쓰기 연산일 경우, 본 발명의 실시예 중의 방 법을 사용하여, 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역을 하나 또는 다수의 파인-그레인드 영역으로 분할하고, 파인-그레인드 영역을 단위로 연산을 실행함으로써, 읽기 후 쓰기, 쓰기 후 읽기, 쓰기 후 쓰기 등 연산이 정확하게 실행될 수 있을 뿐만 아니라, 정확한 실행 결과를 획득할 수 있고, 또한 연산 간의 대기 시 작을 감소시킬 수도 있어, 프로세서의 실행 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 설정 길이의 데이터 소재 영역, 설정 차원의 데이터 소재 영역 중의 적어도 하나에 따라 결정할 수 있다. 상기 파인-그레인드 영역의 크기 및/또는 수량 결정은 연산이 생성되기 전 미리 설정된 것일 수도 있고, 매 줄 의 연산이 생성 시 실시간으로 결정되는 것일 수도 있음을 이해할 수 있을 것이다. 그 중, 연산 전 파인-그레인 드 영역의 크기 및/또는 수량을 미리 결정하는 방법은, 길이를 미리 설정하는 데이터가 소재하는 영역, 차원을 미리 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라, 파인-그레인드 영역의 크기 및/또는 수량을 결정하는 것을 포함할 수 있다. 길이를 설정하는 데이터와 차원을 설정하는 데이터는 각 연산의 피연산자와 무 관할 수도 있고, 미리 각 연산의 피연산자에 따라 종합적으로 결정할 수도 있으며, 필요에 따라 결정할 수도 있 다. 각 줄의 연산이 생성될 때 실시간으로 파인-그레인드 영역의 크기 및/또는 수량을 결정하는 방법은 각 연산 의 피연산자에 따라, 길이를 설정하는 데이터 또는 차원을 설정하는 데이터를 결정하는 단계를 포함할 수 있으 며, 즉 각 연산의 피연산자의 차이에 따라, 길이를 설정하는 데이터가 소재하는 영역, 차원을 설정하는 데이터 가 소재하는 영역 중의 적어도 하나를 실시간으로 결정하여, 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있다. 예를 들어 설명하면, 길이를 설정하는 데이터가 소재하는 영역의 크기에 따라, 파인-그레인드 영역의 크기 및/ 또는 수량을 결정할 수 있다. 예를 들어 디스크립터가 지시하는 텐서 데이터 중 길이를 설정하는 데이터가 소재 하는 영역의 크기에 따라, 파인-그레인드 영역의 크기를 설정할 수 있으며, 상기 영역은 고정된 비트폭일 수 있 다. 예를 들어, 디스크립터가 지시하는 텐서 데이터 B는 20*10*5인 3차원 데이터이고, 그것이 타겟 저장영역에 저장되는 방식은 40*25(즉 매 행마다 40비트의 데이터로, 총 25행)이면, 즉 설정 길이를 40비트로 설정하고, 타 겟 저장영역의 각 1행을 하나의 파인-그레인드 영역으로 설정할 수 있으며, 디스크립터가 지시하는 텐서 데이터 B의 타겟 저장영역은 25개의 파인-그레인드 영역으로 분할할 수 있다. 타겟 저장영역의 각 5행마다 하나의 파인 -그레인드 영역으로 설정할 수도 있으며, 디스크립터가 지시하는 텐서 데이터 B의 타겟 저장영역은 5개의 파인- 그레인드 영역으로 분할할 수 있다. 본 발명은 이에 대해 제한을 두지 않는다. 길이를 설정하는 데이터가 소재하는 영역, 차원을 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라, 타겟 저장영역에서 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수도 있고, 타겟 저장영역이 소재하는 전 체 저장영역에서 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수도 있으며, 전체 저장영역 중의 기타 영 역에서도 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있음을 이해할 수 있을 것이다. 상기 예시는 단 지 그 중 하나의 상황을 제공하는 것일 뿐이며, 본 발명은 길이를 설정하는 데이터가 소재하는 영역, 차원을 설 정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라, 파인-그레인드 영역의 크기 및/또는 수량을 결정하는 적용 분할 범위를 한정하지 않는다. 일종의 가능한 구현 방식에서, 차원을 설정하는 데이터가 소재하는 영역의 크기에 따라, 파인-그레인드 영역의 크기 및/또는 수량을 더 결정할 수 있다. 예를 들어, 디스크립터가 지시하는 텐서 데이터 C는 20*10인 2차원 데 이터이며, 설정 차원수가 1차원이고, 길이가 20인 데이터에 따라, 디스크립터가 지시하는 텐서 데이터 C의 타겟 저장영역을 10개의 파인-그레인드 영역으로 분할할 수 있다. 또한, 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역 중 길이를 설정하는 데이터가 소재하는 영역의 크기 와 차원을 설정하는 데이터가 소재하는 영역의 크기에 따라, 파인-그레인드 영역의 크기 및/또는 수량을 동시에 결정할 수도 있다. 예를 들어, 디스크립터가 지시하는 텐서 데이터 C에 대하여, 설정 차원이 2차원이고, 크기가 4*2인 데이터에 따라 파인-그레인드 영역을 분할함으로써, 디스크립터가 지시하는 텐서 데이터 C의 타겟 저장영 역을 25개의 파인-그레인드 영역으로 분할할 수 있다. 당업자라면 실제 상황에 따라 파인-그레인드 영역을 분할하는 크기 및/또는 수량을 설정할 수 있음을 이해하여 야 하며, 본 발명은 이에 대해 제한을 두지 않는다. 본 실시예에서, 길이를 설정하는 데이터가 소재하는 영역의 크기 및/또는 차원을 설정하는 데이터가 소재하는 영역의 크기에 따라, 파인-그레인드 영역의 크기 및/또는 수량을 결정함으로써, 데이터 특성에 따라 파인-그레 인드 영역에 대한 분할을 완료할 수 있어, 파인-그레인드 영역 분할의 유연성을 향상시킬 수 있으며, 따라서 다 중 연산의 실행 효율이 향상되고, 파인-그레인드 영역의 분할 결과가 상이한 피연산자 특성에 더욱 부합될 수있어, 상이한 유형의 피연산자의 처리 요구에 적응할 수 있으며, 다중 연산의 전체적인 실행 효율이 더욱 향상 된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 하드웨어의 계산 능력, 하드웨 어의 대역폭 중의 적어도 하나에 따라 결정될 수 있다. 그 중, 하드웨어의 계산 능력은 하드웨어가 하나의 계산 주기 내에 병행 처리하는 데이터량일 수 있고, 하드웨 어 대역폭은 데이터 전송 능력, 예를 들어 단위시간 내에 전송하는 데이터량일 수 있다. 예를 들어 설명하면, 상기 프로세서 연산 방법을 응용한 프로세서에서, 그 하드웨어 계산 능력은 하나의 계산 주기 내에 100비트의 데이터를 병행 처리하고, 하드웨어 대역폭은 단위시간 내에 200비트의 데이터를 전송한다 면, 크기가 1000비트인 타겟 저장영역의 경우, 하드웨어 계산 능력에 따라 상기 타겟 저장영역을 10개의 파인- 그레인드 영역으로 분할할 수 있으며, 그 중 각 파인-그레인드 영역은 100비트의 데이터를 포함한다. 하드웨어 대역폭에 따라 상기 타겟 저장영역을 5개의 파인-그레인드 영역으로 분할할 수도 있으며, 그 중 각 파인-그레인 드 영역은 200비트의 데이터를 포함한다. 하드웨어의 계산 능력과 하드웨어의 대역폭은 프로세서 하드웨어마다 다르다는 것을 이해하여야 하며, 본 발명 은 하드웨어의 계산 능력, 하드웨어의 대역폭에 대해 제한을 두지 않는다. 하드웨어의 계산 능력, 하드웨어의 대역폭 중의 적어도 하나에 따라, 타겟 저장영역에서 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수도 있고, 타겟 저장영역이 소재하는 전체 저장영역에서 파인-그레인드 영역의 크 기 및/또는 수량을 결정할 수도 있으며, 및 전체 저장영역 중의 기타 영역에서 파인-그레인드 영역의 크기 및/ 또는 수량을 결정할 수도 있음을 이해할 수 있을 것이다. 상기 예시는 단지 그 중의 한 가지 상황만 제공한 것 일 뿐 본 발명은 하드웨어의 계산 능력, 하드웨어의 대역폭 중의 적어도 하나에 따라, 파인-그레인드 영역의 크 기 및/또는 수량을 결정하는 적용 분할 범위를 한정하지 않는다. 이러한 방식을 통해, 프로세서의 처리 능력(하드웨어의 계산 능력 및/또는 하드웨어의 대역폭)에 따라 상기 파 인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있어, 파인-그레인드 영역의 분할 결과가 각기 다른 하드웨 어 사용 환경의 요구에 더욱 부합될 수 있으며, 파인-그레인드 영역에서 실행되는 연산과 프로세서의 처리 능력 이 동기화됨으로써, 하드웨어의 실행 효율이 최대한으로 발휘될 수 있어, 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 제1 연산은 제1 처리 명령 중의 연산일 수 있고, 상기 제2 연산은 제2 처리 명령 중의 연산일 수 있으며, 상기 제2 처리 명령은 명령 큐 중 상기 제1 처리 명령 이전의 처리 명령이다. 그 중, 제1 처리 명령과 제2 처리 명령은 데이터 액세스 명령, 연산 명령, 동기화 명령 및 통신 명령 등의 하나 이상을 포함할 수 있으며, 예컨대 상기 명령은 쓰기이면서 연산 명령이다. 본 발명은 제1 처리 명령과 제2 처리 명령의 구체적인 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제1 명령은 제2 명령과 의존관계를 지니며, 예를 들어 제1 명령은 제2 명령의 계 산 결과를 사용해야 하는 등의 의존관계다. 제1 명령은 제2 명령과 의존관계가 없을 수도 있다. 제1 명령과 제2 명령이 의존관계인 경우, 본 발명의 실시예 중의 방법을 통해, 제1 명령과 제2 명령을 병행 실행할 수 있다. 본 실시예에서, 제1 연산과 제2 연산은 상이한 명령 중의 연산일 수 있으며, 본 발명의 실시예 중의 방법을 이 용하면 명령 실행 효율이 향상될 수 있다. 일종의 가능한 구현 방식에서, 제1 연산과 제2 연산은 동일한 처리 명령 중의 2개의 연산일 수도 있으며, 제2 연산은 제1 연산과 무관하거나, 또는 제2 연산은 제1 연산을 바탕으로 한 결과일 수 있다. 그 중, 상기 처리 명 령은 데이터 액세스 명령, 연산 명령, 동기화 명령과 통신 명령 등의 하나 이상을 포함할 수 있으며, 예컨대 상 기 명령이 \"읽기와 더하기\" 연산 명령이면, 즉 제1 연산은 읽기 연산이고, 제2 연산은 가법 연산이다. 본 발명 은 처리 명령의 구체적인 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 방법은 상기 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위치 정보와 상기 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제2 위치정보를 기록하는 단계를 더 포함하며, 단계 S14d는 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 때, 상기 제1 연산을 실행하는 단계를 포 함할 수 있다. 일종의 가능한 구현 방식에서, 위치정보는 파인-그레인드 영역의 식별자 정보를 포함할 수 있다. 식별자 정보는 숫자, 알파벳 부호의 임의의 조합을 포함할 수 있으며, 본 발명은 이에 대해 한정하지 않는다. 예를 들어, 위치정보는 파인-그레인드 영역의 번호 정보를 사용하여 표시할 수 있으며, 타겟 저장영역을 6개의 파인-그레인드 영역으로 분할할 수 있고, 그 번호는 순차적으로 0-5이다. 타겟 저장영역에 대한 제1 연산과 제2 연산을 실행 시, 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위치정보(예를 들어 번호 2)와 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제2 위치정보(예를 들어 번호 5)를 각각 기록하고; 이후 번호 정보 간의 관계에 따라(2<5), 제1 위치정보와 제2 위치정보가 일치하지 않는다는 것을 알 수 있으며; 이때 제1 연산을 실행할 수 있다. 일종의 가능한 구현 방식에서, 위치정보는 파인-그레인드 영역의 어드레스 정보를 포함할 수 있다. 어드레스 정 보는 파인-그레인드 영역의 시작 어드레스 정보, 종료 어드레스 정보, 파인-그레인드 영역 중 미리 설정된 위치 의 어드레스 정보, 어드레스 오프셋 정보 중의 적어도 하나를 포함할 수 있다. 예를 들어 파인-그레인드 영역의 위치정보는 ADDR1515-ADDR1531이다. 이러한 방식을 통해, 위치정보를 사용하여 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 효 율적으로 직접 판단하여, 제1 연산의 실행 여부를 결정할 수 있으며, 프로세서의 실행 효율이 향상될 수 있다. 일종의 가능한 구현 방식에서, 상기 제1 위치정보는 제1 연산이 이미 완료된 파인-그레인드 영역의 제1 수량을 포함할 수 있고, 상기 제2 위치정보는 제2 연산이 이미 완료된 파인-그레인드 영역의 제2 수량을 포함할 수 있 다. 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 때, 상기 제1 연산을 실행하는 단계는, 상기 제1 연산 이 상기 제2 연산 이후의 연산이고, 또한 상기 제1 수량이 상기 제2 수량보다 작을 때, 상기 제1 연산을 실행하 는 단계를 포함할 수 있다. 예를 들어 설명하면, 제1 연산이 제2 연산 이후의 연산이고, 그 타겟 저장영역이 6개의 파인-그레인드 영역으로 분할된다면, 그 위치정보는 이미 연산이 완료된 파인-그레인드 영역의 수량을 사용하여 표시할 수 있다. 타겟 저장영역에 대한 제1 연산과 제2 연산을 실행 시, 제1 연산이 이미 완료된 파인-그레인드 영역의 제1 수량(예를 들어 제1 수량은 3이고)과 제2 연산이 이미 완료된 파인-그레인드 영역의 제2 수량(예를 들어 제1 수량은 5이며)을 각각 기록할 수 있고; 이후 제1 연산과 제2 연산의 실행 순서, 및 제1 수량과 제2 수량의 관계에 따라, 제1 연산이 제2 연산 이후의 연산이고, 제1 수량 3은 제2 수량 5보다 작다는 것을 알 수 있으며, 이때 제 1 연산을 실행할 수 있다. 이러한 방식을 통해, 이미 연산이 완료된 파인-그레인드 영역의 수량에 따라 제1 파인-그레인드 영역과 제2 파 인-그레인드 영역의 중첩 여부를 직관적으로 판단할 수 있고, 제1 연산의 실행 여부를 더 판단할 수 있어, 판단 과정이 단순해질 수 있으며, 프로세서의 실행 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 연산 가능 영역과 연산 불가 영역을 포함할 수 있으며, 단 계 S13d는 상기 제2 연산이 존재하면서, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파 인-그레인드 영역이 상기 연산 가능 영역 내에 위치 시, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영 역 중의 제1 파인-그레인드 영역과 상기 제2 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그 레인드 영역 간에 중첩이 있는지 여부를 판단하는 단계를 포함할 수 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역은 하나 또는 다수의 연산 불가 영역을 포함할 수 있으며, 연속 또 는 불연속 연산 불가 영역을 포함할 수도 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역은 하나 또는 다수의 연산 가능 영역을 포함할 수 있으며, 연속 또 는 불연속 연산 가능 영역을 포함할 수도 있다. 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제1 연산이 디스크립터에 대한 연산인 경우, 먼저 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역을 획득한 다음, 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단할 수 있고; 제2 연산이 존재 시, 제1 연산이 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역이 연산 가능 영역 내에 위치하는지 여부를 판단하며; 제2 연산이 존재하면서, 제1 연산이 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역이 연산 가능 영역 내에 위치 시, 제1 연산이 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역과 제2 연산이 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영역 간의 중첩 여 부를 더 판단하고; 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간에 중첩이 없는 경우, 제1 연산을 실행 한다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 연산금지 영역과 비 연산금지 영역을 포함할 수 있다. 제 1 연산이 디스크립터에 대한 쓰기 연산이라면, 디스크립터가 지시하는 텐서 데이터 중의 일부 데이터의 수정이 불가능할 때, 상기 일부 데이터가 소재하는 저장영역을 연산금지 영역으로 설정하여, 상기 일부 데이터의 수정 오류를 방지할 수 있고; 진행 중인 제2 연산이 제1 연산 이전의 데이터를 독취하는 읽기 연산(읽기 후 쓰기)이 라면, 즉 제2 연산이 소재하는 하나 또는 다수의 파인-그레인드 영역을 비 연산금지 영역으로 설정하여, 제2 연 산이 비 연산금지 영역에 대한 독취를 완료한 후, 상기 비 연산금지 영역을 연산 가능 영역으로 변경할 수 있다. 본 발명은 연산 불가 영역의 분류 및 분할 방식에 대해 제한을 두지 않는다. 본 실시예에서, 먼저 제1 연산의 파인-그레인드 영역이 연산 가능인지 여부를 판단한 다음, 상이한 연산의 파인 -그레인드 영역 간의 관계를 판단할 수 있어, 한편으로는 판단 효율이 향상되고, 다른 한편으로는 지정된 데이 터를 보호하여 연산 오류의 발생을 방지할 수 있으며, 지정된 공간에 대해 읽기와 쓰기를 금지함으로써, 상기 공간을 다른 연산을 실행하기 위해 예비로 남겨둘 수 있어 프로세서가 파인-그레인드 동기화 실행 시의 유연성 이 향상된다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그 레인드 영역일 수 있으며, 또한 상기 제2 파인-그레인드 영역의 상기 연산 불가 영역 내에서의 위치는 상기 제2 연산의 연산위치에 따라 업데이트된다. 상기 방법은, 상기 제2 연산이 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역에서 상기 연산 불가 영역을 제거한 후, 상기 연산 불가 영역의 위치를 업데이트하는 단 계를 더 포함할 수 있다. 다시 말해, 제2 파인-그레인드 영역을 포함하는 다수의 파인-그레인드 영역의 연산 불가 영역은 제2 연산이 대 상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영역의 업데이트를 따라 업데이트되지 않고, 상기 제2 연산 이 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영역에서 상기 연산 불가 영역을 제거 후, 상기 연산 불가 영역의 위치를 업데이트할 수 있다. 예를 들어 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 R개의 파인-그레인드 영역(R은 1보다 큰 정수이다)일 수 있으며, 현재의 연산 불가 영역은 제2 내지 제2+R-1개 의 파인-그레인드 영역을 포함할 수 있다. 제2 연산이 연산 불가 영역 내에서 R개의 파인-그레인드 영역을 실행 완료한 후, 연산 불가 영역을 제거하면, 즉 연산 불가 영역의 위치가 제2 연산이 대상으로 하는 파인-그레인드 영역의 위치에 따라 업데이트되며, 업데이트 후의 연산 불가 영역은 제2+R개 내지 2+R+R-1개의 파인-그레인드 영역을 포함한다. 그 중, R의 크기는 필요에 따라 임의로 결정할 수 있다. 도 6a와 도 6b는 본 발명의 실시예에 따른 프로세서 연산 방법의 응용 시나리오 설명도이다. 도 6a에 도시된 바 와 같이, 타겟 저장영역(30d)은 8개의 파인-그레인드 영역을 포함하며, 그 중, 연산가능 영역은 5개의 파인-그 레인드 영역(파인-그레인드 영역(31d), 파인-그레인드 영역(35d), 파인-그레인드 영역(36d), 파인-그레인드 영 역(37d)과 파인-그레인드 영역(38d))을 포함하고, 연산 불가 영역(M0)은 3개의 파인-그레인드 영역(파인-그레인 드 영역(32d), 파인-그레인드 영역(33d)과 파인-그레인드 영역(34d))을 포함한다. 그 중, 제2 연산이 현재 대상 으로 하는 타겟 저장영역(30d) 중의 제2 파인-그레인드 영역은 파인-그레인드 영역(32d)이다. 제2 연산이 파인-그레인드 영역(32d)에 대한 연산을 실행 완료한 후, 제2 연산이 현재 대상으로 하는 타겟 저장 영역(30d) 중의 제2 파인-그레인드 영역은 파인-그레인드 영역(33d)이며, 이때, 제2 연산이 현재 대상으로 하는 타겟 저장영역(30d) 중의 제2 파인-그레인드 영역(파인-그레인드 영역(33d))은 연산 불가 영역이 제거되지 않아, 연산 불가 영역의 위치를 업데이트하지 않는다. 제2 연산이 파인-그레인드 영역(33d)에 대한 연산을 실행 완료한 후, 제2 연산이 현재 대상으로 하는 타겟 저장영역(30d) 중의 제2 파인-그레인드 영역은 파인-그레인드 영역(34d)이며, 이때, 제2 연산이 현재 대상으로 하는 타겟 저장영역(30d) 중의 제2 파인-그레인드 영역(파인- 그레인드 영역(34d))은 아직 연산 불가 영역을 제거하지 않아, 연산 불가 영역의 위치를 업데이트하지 않는다. 제2 연산이 파인-그레인드 영역(34d)에 대한 연산을 실행 완료한 후, 제2 연산이 현재 대상으로 하는 타겟 저장 영역(30d) 중의 제2 파인-그레인드 영역은 파인-그레인드 영역(35d)이며, 이때, 제2 연산이 현재 대상으로 하는 타겟 저장영역(30d) 중의 제2 파인-그레인드 영역(파인-그레인드 영역(35d))은 이미 연산 불가 영역이 제거되어, 연산 불가 영역의 위치를 파인-그레인드 영역(35d, 36d와 37d)으로 업데이트한다. 설명해두어야 할 점으로, 본 발명은 연산 불가 영역의 크기에 대해 한정하지 않는다. 도 6b에 도시된 바와 같이, 연산 불가 영역의 위치가 업데이트된 후, 타겟 저장영역(30d)에서, 연산가능 영역은 5개의 파인-그레인드 영역(파인-그레인드 영역(31d), 파인-그레인드 영역(32d), 파인-그레인드 영역(33d), 파인 -그레인드 영역(34d)과 파인-그레인드 영역(38d))을 포함하고, 연산 불가 영역(M0)은 3개의 파인-그레인드 영역 (파인-그레인드 영역(35d), 파인-그레인드 영역(36d)과 파인-그레인드 영역(37d))을 포함한다.이러한 방식을 통해, 연산 불가 영역의 위치를 실시간으로 업데이트할 필요가 없어, 연산 불가 영역을 업데이트 하여 발생하는 오버헤드를 감소시킬 수 있다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그 레인드 영역일 수 있고, 또한 상기 제2 파인-그레인드 영역은 상기 연산 불가 영역 내의 설정위치에 위치하여, 상기 연산 불가 영역의 위치가 상기 제2 연산의 연산위치에 따라 업데이트된다. 다시 말해, 연산 불가 영역이 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그레인드 영역인 경우, 제2 파인-그레인드 영역을 연산 불가 영역 중의 위치(예를 들어 중간 위치, 마지막 위치 등)로 설정할 수 있으며, 연산 불가 영역의 위치는 제2 연산의 연산위치에 따라 업데이트된다. 예를 들어, 연산 불가 영역은 상기 제2 파 인-그레인드 영역을 포함하는 R개의 파인-그레인드 영역일 수 있으며, 현재의 연산 불가 영역은 제2 내지 제 2+R-1개의 파인-그레인드 영역을 포함하고, 제2 파인-그레인드 영역의 연산 불가 영역 내에서의 설정위치는 제S 번째(그 중 S≤R)이다. 제2 연산이 현재 대상으로 하는 파인-그레인드 영역에 대한 연산을 실행 완료한 후, 제2 연산은 다음 파인-그레인드 영역에 대한 연산을 실행하기 시작하며, 이때, 연산 불가 영역의 위치는 제2 연산의 연산위치에 따라 업데이트되고, 업데이트 후의 연산 불가 영역은 제2+1 내지 제2+R개의 파인-그레인드 영역을 포함한다. 그 중, R의 크기 및 S의 취득값은 필요에 따라 결정할 수 있다. 본 발명은 연산 불가 영역에 포함되 는 파인-그레인드 영역의 수량, 제2 파인-그레인드 영역이 연산 불가 영역 내에 위치하는 위치에 대해 모두 제 한을 두지 않는다. 도 7a와 도 7b는 본 발명의 실시예에 따른 프로세서 연산 방법의 응용 시나리오 설명도이다. 도 7a에 도시된 바 와 같이, 타겟 저장영역에는 8개의 파인-그레인드 영역이 포함되며, 그 중, 연산가능 영역은 5개의 파인-그 레인드 영역(파인-그레인드 영역, 파인-그레인드 영역, 파인-그레인드 영역, 파인-그레인드 영역 과 파인-그레인드 영역)을 포함하고, 연산 불가 영역(M1)은 3개의 파인-그레인드 영역(파인-그레인드 영역, 파인-그레인드 영역과 파인-그레인드 영역)을 포함한다. 그 중, 제2 연산이 현재 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영역은 연산 불가 영역(M1)에 위치하는 두 번째 파인-그레인드 영역, 즉 파인-그레인드 영역으로 설정된다. 제2 연산이 파인-그레인드 영역에 대한 연산의 실행을 완료한 후, 제2 연산이 현재 대상으로 하는 타겟 저 장영역 중의 제2 파인-그레인드 영역은 파인-그레인드 영역이며, 이때, 연산 불가 영역의 위치가 제2 연산의 연산위치에 따라 업데이트됨으로써, 제2 연산이 현재 대상으로 하는 타겟 저장영역 중의 제2 파인- 그레인드 영역이 연산 불가 영역(M1)의 두 번째 파인-그레인드 영역에 위치하게 된다. 도 7b에 도시된 바와 같이, 연산 불가 영역의 위치가 업데이트된 후, 타겟 저장영역에서, 연산가능 영역은 5개의 파인-그레인드 영역(파인-그레인드 영역, 파인-그레인드 영역, 파인-그레인드 영역, 파인-그 레인드 영역과 파인-그레인드 영역)을 포함하고, 연산 불가 영역(M1)은 3개의 파인-그레인드 영역(파인 -그레인드 영역, 파인-그레인드 영역과 파인-그레인드 영역)을 포함한다. 이러한 방식을 통해, 연산 불가 영역의 위치를 실시간으로 업데이트할 수 있어, 파인-그레인드 처리의 동기화율 이 향상되며, 이에 따라 데이터의 동기화 처리 효율이 추가적으로 향상된다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 순환 버퍼(circular buffer) 저장영역을 포함할 수 있다. 상기 순환 버퍼 저장영역은 데이터를 순환 저장하는데 사용될 수 있다. 도 8은 본 발명의 실시예에 따른 프로세서 연산 방법의 순환 버버 저장영역의 설명도이다. 도 8에 도시된 바와 같이, 타겟 저장영역 중에 순환 버퍼 저장영역이 포함되며, 그 어드레스는 start_addr~end_addr이다. 예를 들어, 제2 연산은 쓰기 연산이고, 피연산자를 순환 버퍼 저장영역에 입력할 수 있으며, 그 어드레스 포인터(point)는 시작 어드레스 start_addr로부터 시작하여, 순차적으로 아래로 데이터를 저장하며, 종료 어드 레스 end_addr에 도달하면, 즉 순환 버퍼 저장영역의 저장공간이 가득 차게 된다. 이때, 어드레스 포인트 (point)는 start_addr로 복귀하여, 상기 어드레스가 동기화되어야 할 제1 연산에 의해 사용이 완료되었는지 판 단하며, 사용이 완료되었다면, 즉 데이터를 상기 어드레스에 저장하고, 원래의 데이터를 덮어쓴 후, 어드레스 포인터(point)가 end_addr에 도달할 때까지 순차적으로 하향 이동하며, 이때, 데이터를 다시 덮어쓸 수 있으며, 상기 과정을 순환 반복한다. 본 실시예에서, 순환 버퍼 저장영역을 이용하여 데이터를 저장하면, 데이터 저장공간을 절약할 수 있을 뿐만 아 니라, 저장공간의 이율률도 향상될 수 있다.일종의 가능한 구현 방식에서, 순환 버퍼 저장영역을 다수의 파인-그레인드 영역으로 분할할 수 있다. 각 파인- 그레인드 영역에 대해, 테이블 또는 플래그 비트(flag bit) 또는 기타 방식을 통해 파인-그레인드 영역 중의 데 이터의 덮어쓰기 가능 여부에 대한 관리를 수행할 수 있으며, 예를 들어 덮어쓰기(overwrite) 플래그 비트를 설 치하여 파인-그레인드 영역 중의 데이터의 덮어쓰기 가능 여부를 표시할 수 있다. 예를 들어 설명하면, 제1 연산이 읽기 연산이고, 제2 연산이 쓰기 연산, 즉 선 쓰기 후 읽기이면, 쓰기 포인터 (wp)와 읽기 포인터(rp)를 사용하여 제2 연산과 제1 연산이 현재 대상으로 하는 파인-그레인드 영역을 각각 표 시할 수 있다. 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역의 덮어쓰기 플래그 비트의 덮어쓰기가 가능할 경우, 제2 연산을 실행할 수 있어, 데이터를 입력하며, 데이터 입력이 완료된 후, 상기 제2 파인-그레인 드 영역의 덮어쓰기 플래그 비트를 덮어쓰기 불가로 설정하면, wp++이 되고, 제2 연산이 현재 대상으로 하는 제 2 파인-그레인드 영역은 다음 파인-그레인드 영역이 되며, 만약 wp>end_addr이면, 즉 wp=start_addr이다. 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간이 중첩되지 않으면서, 제1 파 인-그레인드 영역의 덮어쓰기 플래그 비트의 덮어쓰기가 불가한 경우, 제1 연산을 실행할 수 있어, 데이터를 독 취하며, 데이터의 독취가 완료된 후, 상기 제1 파인-그레인드 영역의 덮어쓰기 플래그 비트를 덮어쓰기 가능으 로 설정할 수 있으며, rp++이 되고, 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역은 다음 파인-그레 인드 영역이 되며, rp>end_addr라면 즉 rp=start_addr이며; 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 에 중첩이 있는 경우, 즉 rp=wp일 때, 제1 연산은 실행될 수 없어, 제2 연산이 현재 대상으로 하는 상기 제2 파 인-그레인드 영역에 대한 연산을 완료해야만 제1 연산을 실행할 수 있다. 본 실시예에서, 순환 버퍼 저장영역을 다수의 파인-그레인드 영역으로 분할하여, 다수의 연산이 동시에 순환 버 퍼 저장영역에 대해 연산하도록 함으로써, 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역은 상태 식별자를 포함할 수 있으며, 상기 상태 식별자 는 상기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함한다. 단계 S14d는 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 간이 중첩되지 않는 경우, 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하여; “예”이면, 즉 상기 제1 연산을 실행하는 단계를 포함할 수 있다. 일종의 가능한 구현 방식에서, 파인-그레인드 영역은 상태 식별자를 포함할 수 있으며, 상태 식별자는 파인-그 레인드 영역의 연산이 이미 완료된 상태 또는 미완료 상태를 포함할 수 있다. 예를 들어, 상태 식별자는 0과 1 로 표시할 수 있으며, 그 중, 0은 파인-그레인드 영역의 연산이 미완료된 상태를 나타내고, 1은 파인-그레인드 영역의 연산이 이미 완료된 상태를 나타내며, 또는 0은 파인-그레인드 영역의 연산이 이미 완료된 상태를 나타 내고, 1은 파인-그레인드 영역의 연산이 미완료 상태를 나타낸다. 본 발명은 상태 식별자의 표시 방식에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제2 연산은 타겟 저장영역에 이미 연산이 완료된 파인-그레인드 영역의 상태 식 별자를 이미 완료 상태로 설정하고, 미연산 또는 연산 중인 파인-그레인드 영역의 상태 식별자는 미완료 상태로 설정할 수 있다. 또한 이미 연산이 완료된 파인-그레인드 영역의 일부 파인-그레인드 영역의 상태 식별자를 이 미 완료된 상태로 설정하고, 다른 파인-그레인드 영역은 미완료 상태로 설정할 수도 있다. 예를 들어 제2 연산 이 5개의 파인-그레인드 영역의 연산을 이미 완료하였다면, 이전 3개의 파인-그레인드 영역의 상태 식별자를 이 미 완료된 상태로 설정하고, 다른 파인-그레인드 영역은 미완료 상태로 설정할 수 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역에 대해 진행 중인 제2 연산이 존재할 경우, 제1 연산이 현재 대상 으로 하는 제1 파인-그레인드 영역과 제2 연산이 대상으로 하는 제2 파인-그레인드 영역에 대해, 제1 파인-그레 인드 영역과 제2 파인-그레인드 영역 간이 중첩되지 않은 것을 결정한 후, 제1 파인-그레인드 영역의 상태 식별 자가 이미 완료된 상태인지 여부를 판단할 수 있고; 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태 라면, 제1 연산을 실행할 수 있다. 본 실시예에서, 파인-그레인드 영역은 상태 식별자를 포함하며, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 제1 파인-그레인드 영역의 상태 식별자에 따라 제1 연산의 실행 가능 여부를 결정할 수 있어, 프로세서의 처리 효율이 향상될 수 있음과 동시에, 데이터 처리의 정확성이 향상된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역은 상태 식별자를 포함할 수 있으며, 상기 상태 식별자 는 상기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함할 수 있다.단계 S14d는 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하여; “예”이면, 즉 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 때, 상기 제1 연산을 실행하는 단계를 포함할 수 있다. 다시 말해, 타겟 저장영역에 대해 진행 중인 제2 연산이 존재할 경우, 제1 연산이 현재 대상으로 하는 제1 파인 -그레인드 영역과 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역에 대해, 제1 파인-그레인드 영역의 상태 식별자를 이미 완료된 상태로 결정한 후, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간의 중첩 관 계에 따라, 제1 연산의 실행 가능 여부를 결정한다. 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 사이가 중첩되지 않을 때, 제1 연산을 실행할 수 있다. 본 실시예에서, 파인-그레인드 영역은 상태 식별자를 포함하며, 제1 파인-그레인드 영역의 상태 식별자를 이미 완료된 상태로 결정한 후, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간의 중첩 관계에 따라, 제1 연산 의 실행 가능 여부를 결정할 수 있어, 데이터 처리의 정확성이 향상될 수 있는 동시에, 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 제2 연산은 상기 디스크립터에 대한 연산이다. 다시 말해, 제2 연산의 피연산자는 제1 연산의 피연산자와 동일하여, 제2 연산과 제1 연산은 동일한 디스크립터 에 대한 연산이며, 제2 연산의 피연산자의 저장영역과 타겟 저장영역이 완전히 중첩된다. 디스크립터가 지시하 는 텐서 데이터의 타겟 저장영역을 다수의 파인-그레인드 영역으로 분할한 후, 본 발명의 실시예 중의 방법에 따라, 각 연산의 실행 결과에 영향을 미치지 않고 동일한 디스크립터를 연산하는 2개의 연산이 병행 실행되도록 할 수 있다. 일종의 가능한 구현 방식에서, 제2 연산의 피연산자와 제1 연산의 피연산자가 같을 때, 연산의 실행 진도에 따 라 제1 파인-그레인드 영역과 제2 파인-그레인드 영역을 각각 결정할 수 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역에 대한 제1 연산을 실행하기 전, 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단 시, 제1 연산이 대상으로 하는 타겟 저장영역에 대한 제1 파인-그레인드 영 역은 제1 연산이 실행하려고 하는 타겟 저장영역 중의 파인-그레인드 영역이다. 예를 들어 타겟 저장영역에 대 한 제1 연산을 실행하기 전, 제1 연산이 현재 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역은 통 상적으로 타겟 저장영역의 첫 번째 파인-그레인드 영역이다. 이때, 제1 파인-그레인드 영역에 대한 제1 연산은 아직 실행되지 않았으며, 진행 중인 제2 연산이 현재 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영 역은 제2 연산의 실행 진도와 관련이 있을 수 있다. 만약 제2 연산 역시 막 실행을 시작했다면, 즉 제2 파인-그 레인드 영역 역시 타겟 저장영역의 첫 번째 파인-그레인드 영역일 수 있다. 이때, 제1 파인-그레인드 영역과 제 2 파인-그레인드 영역은 중첩된다. 만약 제2 연산이 첫 번째 파인-그레인드 영역의 연산을 이미 완료했다면, 현 재 대상으로 하는 타겟 저장영역 중의 제2 파인-그레인드 영역은 제P번째 파인-그레인드 영역(P는 1보다 큰 정 수)이며, 즉 제1 파인-그레인드 영역과 제2 파인-그레인드 영역이 중첩되지 않는다. 일종의 가능한 구현 방식에서, 제1 연산이 타겟 저장영역에 대한 연산 실행 과정에서, 타겟 저장영역에 대해 진 행 중인 제2 연산이 존재하는지 여부를 판단 시, 제1 연산의 실행 진도에 따라 제1 파인-그레인드 영역을 결정 하고, 제2 연산의 실행 진도에 따라 제2 파인-그레인드 영역을 결정하며, 나아가 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 판단할 수 있다. 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 사이가 중첩되지 않을 때, 제1 연산을 실행할 수 있다. 일종의 가능한 구현 방식에서, 만약 각 연산을 실행하는 과정의 속도가 일치하면, 타겟 저장영역에 대한 제1 연 산을 실행하기 전에만 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단하고, 제1 파인-그레 인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 판단할 수 있다. 그 중, 속도가 일치한다 함은 파인-그레인 드 영역의 크기가 동일한 경우, 2개의 연산이 하나의 파인-그레인드 영역에 대한 실행하는 연산 시간이 동일함 을 의미한다. 일종의 가능한 구현 방식에서, 만약 각 연산을 실행하는 과정의 속도가 일치하지 않거나 또는 일치 여부를 결정 할 수 없는 경우, 제1 연산이 타겟 저장영역에 대해 연산을 실행하는 과정에서, 현재 대상으로 하는 타겟 저장 영역 중의 제1 파인-그레인드 영역에 대한 연산을 완료할 때마다, 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 계속 판단하고, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 계속 판단 함으로써, 제1 연산을 계속 실행할 수 있는지 여부를 결정한다.본 실시예에서, 제2 연산의 피연산자와 제1 연산의 피연산자가 동일한 경우, 본 발명의 실시예에 따른 방법을 사용하여, 동일한 디스크립터에 대한 2개 또는 다수의 연산을 병행 실행하거나, 또는 각 연산의 실행 과정에 각 연산이 현재 대상으로 하는 파인-그레인드 영역을 결정할 수 있으며, 제1 파인-그레인드 영역과 제2 파인-그레 인드 영역 사이가 중첩되지 않을 때, 제1 연산을 실행하여, 동일한 디스크립터에 대한 2개 또는 다수의 연산이 각 연산의 실행 결과에 영향을 주지 않으면서 병행 실행될 수 있어, 프로세서의 실행 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 제2 연산의 피연산자의 저장영역과 상기 타겟 저장영역은 중첩된다. 일종의 가능한 구현 방식에서, 제2 연산의 피연산자의 저장영역과 타겟 저장영역이 중첩되고, 제2 연산이 중첩 영역에 대해 연산을 진행 중인 경우, 제2 연산의 피연산자의 저장영역과 타겟 저장영역을 각각 다수의 파인-그 레인드 영역으로 분할하거나, 또는 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역로 분 할한 다음, 본 발명의 실시예 중의 방법에 따라, 중첩 영역 중의 파인-그레인드 영역에 대해 판단하여, 제1 연 산의 실행 가능 여부를 결정함으로써, 피연산자의 저장영역 중 중첩 영역의 2개의 연산을 각 연산의 실행 결과 에 영향을 주지 않고 병행 실행할 수 있다. 일종의 가능한 구현 방식에서, 제2 연산이 디스크립터에 대한 연산이고, 제2 연산이 대상으로 하는 디스크립터 와 제1 연산이 대상으로 하는 디스크립터가 상이할 경우, 디스크립터를 생성 시 디스크립터가 지시하는 텐서 데 이터의 저장영역의 중첩이 허용되는지 여부에 따라, 제2 연산의 피연산자 저장영역과 타겟 저장영역의 중첩 가 능 여부를 결정할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터를 생성 시, 디스크립터가 지시하는 텐서 데이터의 저장영역의 중첩을 허용하지 않는다면, 즉 제2 연산이 대상으로 하는 디스크립터와 제1 연산이 대상으로 하는 디스크립터가 상이할 경우, 제2 연산이 대상으로 하는 디스크립터가 지시하는 텐서 데이터의 저장영역과 타겟 저장영역이 중첩되지 않으며, 제1 연산과 제2 연산의 파인-그레인드 영역 사이가 중첩되지 않으므로, 상이한 디스크립터를 대상으로 하는 연산에 대해 파인-그레인드 영역의 판단을 할 필요가 없다. 일종의 가능한 구현 방식에서, 디스크립터를 생성 시, 디스크립터가 지시하는 텐서 데이터의 저장영역의 중첩을 허용한다면, 즉 제2 연산이 대상으로 하는 디스크립터와 제1 연산이 대상으로 하는 디스크립터가 상이할 경우, 제2 연산이 대상으로 하는 디스크립터의 저장영역이 제1 연산이 대상으로 하는 디스크립터가 지시하는 타겟 저 장영역과 중첩될 가능성이 있으며, 이때, 본 발명의 실시예 중의 방법에 따라, 중첩 영역을 갖는 상이한 디스크 립터에 대한 2개의 연산을 병행 실행할 수 있다. 본 실시예에서, 제2 연산의 피연산자의 저장영역과 타겟 저장영역이 중첩 시, 본 발명의 실시예 중의 방법을 사 용하여 2개 또는 다수의 연산의 병행 실행을 구현할 수 있어, 프로세서의 실행 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 방법은, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하는 단계를 더 포함할 수 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역은 저장장치의 전체 저장영역 중의 일부 저장영역이거나 또는 전체 저장영역일 수 있으며, 상기 전체 저장영역은 미리 설정된 다수의 파인-그레인드 영역을 포함한다. 예를 들어 타겟 저장영역이 소재하는 전체 저장영역이 RAM1이면, RAM1은 미리 설정된 m개의 파인-그레인드 영역 (m은 양의 정수)을 포함할 수 있다. 타겟 저장영역은 RAM1에서 RAM1 중의 n개의 파인-그레인드 영역(n은 양의 정수이며, n≤m)을 점유할 수 있다. 설명해두어야 할 점으로, 타겟 저장영역은 어떤 파인-그레인드 영역 중의 일부 영역을 포함할 수도 있다. 상기 예시의 RAM1에서, 각 파인-그레인드 영역이 전체 저장영역 RAM1 중에서의 1행이고, 각 행은 100비트라고 가정하면, 타겟 저장영역은 이전(n-1)의 완전한 파인-그레인드 영역을 포함하면 서 또한 마지막 파인-그레인드 영역의 일부 영역도 포함할 수 있으며, 예를 들어 RAM1 중 제n번째 행(제n번째 파인-그레인드 영역) 중의 이전 80개의 비트를 포함할 수 있다. 일종의 가능한 구현 방식에서, 저장장치의 전체 저장영역을 다수의 파인-그레인드 영역으로 분할 시, 전체 저장 영역 중 임의의 타겟 저장영역에 대한 임의의 연산은, 제1 연산이 대상으로 하는 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역 또는 제2 연산의 피연산자의 저장영역과 타겟 저장영역의 중복 영역을 막론하고, 모두 전체 저장영역의 파인-그레인드 영역의 분할 결과에 따라, 타겟 저장영역 또는 중첩 영역 중의 파인-그레인드 영역을 결정할 수 있다. 임의 연산의 임의의 피연산자의 전체 저장영역 중에서의 저장영역은 동일한 크기의 파 인-그레인드 영역을 갖는다. 일종의 가능한 구현 방식에서, 저장장치의 하드웨어 특성에 따라, 전체 저장영역의 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있으며, 즉 저장장치의 하드웨어 계산능력, 하드웨어 대역폭 중의 적어도 하나에 따 라, 전체 저장영역의 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있다. 본 실시예에서, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하여, 전체 저 장영역 중 임의의 타겟 저장영역에 대해 실행되는 임의의 연산은 모두 동일한 파인-그레인드 크기에 따라 실행 할 수 있으며, 상이한 연산을 본 발명의 실시예 중의 방법에 따라 병행 시, 더욱 편리하게 동기화할 수 있어, 연산의 병행률이 향상되고, 나아가 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 방법은, 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 상기 타겟 저장영역을 다수의 파인-그레인드 영역으 로 분할하는 단계, 및 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 상기 제2 연산의 피연산자의 저장영역을 다수의 파 인-그레인드 영역으로 분할하는 단계를 더 포함할 수 있다. 일종의 가능한 구현 방식에서, 연산에 파인-그레인드 분할 정보가 수반될 수 있으며, 파인-그레인드 분할 정보 는 파인-그레인드의 크기 및/또는 수량을 포함할 수 있다. 상이한 연산은 상이한 파인-그레인드 분할 정보를 수 반할 수 있고, 동일한 유형의 연산은 동일한 파인-그레인드 분할 정보를 수반할 수 있다. 연산 중 피연산자의 설정위치에 파인-그레인드 분할 정보가 수반될 수도 있고, 연산코드 또는 피연산자에 파인-그레인드 분할 수행 여부의 식별자 정보가 수반될 수도 있다. 본 발명은 파인-그레인드 분할 정보 중의 내용 및 표현 방식에 대해 한정하지 않는다. 일종의 가능한 구현 방식에서, 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 타겟 저장영역을 다 수의 제1 파인-그레인드 영역으로 분할한다. 제1 연산이 대상으로 하는 디스크립터가 지시하는 텐서 데이터가 소재하는 전체 저장영역 중의 다른 영역은 파인-그레인드 분할을 실시하지 않고, 다른 연산에 수반되는 파인-그 레인드 분할 정보에 따라 파인-그레인드 분할을 실시할 수도 있다. 본 발명은 이에 대해 한정하지 않는다. 제2 연산의 피연산자와 제1 연산이 대상으로 하는 디스크립터가 지시하는 텐서 데이터가 일치 시, 제2 연산의 피연산자의 저장영역과 타겟 저장영역이 완전히 중복된다는 것을 이해할 수 있을 것이다. 제1 파인-그레인드 분 할 정보와 제2 파인-그레인드 분할 정보는 일치할 수도 있고, 일치하지 않을 수도 있다. 제1 파인-그레인드 분 할 정보와 제2 파인-그레인드 분할 정보가 일치하지 않을 경우, 타겟 저장영역은 제2 파인-그레인드 분할 정보 에 따라 동시에 파인-그레인드 분할을 실시할 수 있다. 즉, 타겟 저장영역에 대해, 상이한 연산은 이를 상이한 크기 또는 수량의 다수의 파인-그레인드 영역으로 분할할 수 있다. 이때, 제1 연산이 현재 대상으로 하는 타겟 저장영역 중의 제1 파인-그레인드 영역의 물리 어드레스, 및 제2 연산이 현재 대상으로 하는 타겟 저장영역 중 의 제2 파인-그레인드 영역 간의 물리 어드레스에 따라, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 판단하고, 판단 결과에 따라 제1 연산과 제2 연산의 병행 실행을 수행할 수 있다. 일종의 가능한 구현 방식에서, 각 연산에 수반되는 파인-그레인드 분할 정보는 길이를 설정하는 연산 피연산자 가 소재하는 영역, 차원을 설정하는 피연산자가 소재하는 영역 중의 적어도 하나를 포함할 수 있으며, 결정된 상기 파인-그레인드 영역의 크기 및/또는 수량을 통해, 파인-그레인드 분할 결과가 연산 중의 피연산자 유형과 속성에 더욱 부합되도록 할 수 있다. 본 실시예에서, 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 타겟 저장영역을 다수의 파인-그레 인드 영역으로 분할하고, 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 제2 연산의 피연산자 저장 영역을 다수의 파인-그레인드 영역으로 분할한다. 연산에 수반되는 파인-그레인드 분할 정보에 따라 파인-그레 인드 분할을 실시함으로써, 파인-그레인드 분할 결과를 각 연산의 처리 요구에 더욱 부합되도록 할 수 있어, 연 산의 병행이 더욱 유연해진다. 당업자라면 실제 상황에 따라 타겟 저장영역을 파인-그레인드 영역으로 분할 및 설치할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것일 수 있으며, N은 0 이상의 정수이다. 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하 나의 형상 파라미터를 포함할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것일 수 있다. 그 중, N의 취득값은 텐서 데이터의 차원수(급수)에 따라 결정될 수도 있고, 텐서 데이터의 사용 필요에 따라 설정될 수도 있다. 예를 들어, 텐서 데이터가 3차원 데이터이면, N의 취득값은 3일 수 있으며(차원에 따라 결정함), 디스크립터는 상기 텐서 데이터의 3개 차원 방향상의 형상(예를 들어 오프셋, 크기 등)을 지시하는데 사용될 수 있다. 당업자라면 실제 필요에 따라 N의 취득값을 설정할 수 있음을 이해할 것이며, 본 발명은 이에 대해 제한 을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터는 식별자와 콘텐츠 등을 포함할 수 있고, 디스크립터의 식별자는 디 스크립터를 구분하는데 사용될 수 있으며, 예를 들어 번호이다. 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터(예를 들어 텐서의 각 차원 방향상의 크기 등)를 포함할 수 있다. 본 발 명은 디스크립터의 콘텐츠에 포함되는 구체적인 형상 파라미터에 대해 제한을 두지 않는다. 본 실시예에서, 디스크립터를 사용하여 텐서 데이터의 형상을 지시할 수 있으며, 디스크립터가 지시하는 텐서 데이터의 형상을 통해 다수의 텐서 데이터 간의 상호관계를 결정할 수 있어, 프로세서의 액세스 효율이 향상된 다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자와 콘텐츠는 디스크립터 저장공간에 저장될 수 있으며, 상기 디스크립터 저장공간은 제어유닛의 내부 메모리(예를 들어 레지스터, 온칩 SRAM 또는 기타 매체의 캐시(cache) 등) 중의 저장공간일 수 있다. 디스크립터가 지시하는 텐서 데이터의 데이터 저장공간은 상기 제어유닛의 내부 메모리(예를 들어 온칩 캐시) 또는 상기 제어유닛과 연결되는 외부 메모리(오프칩 메모리) 중의 저장공간일 수 있다. 데이터 저장공간 중의 데이터 어드레스는 실제의 물리 어드레스 또는 가상 어드레스일 수 있다. 본 발명 은 디스크립터 저장공간 및 데이터 저장공간의 위치와 데이터 어드레스의 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 동일한 영역에 위치할 수 있다. 예를 들어, 온칩 캐시의 연속되는 영역을 사용하여 디스크립터의 관련 콘텐츠를 저장할 수 있으며, 그 어드레스는 ADDR0-ADDR1023이다. 그 중, 어드레스 ADDR0-ADDR31은 디스크립터의 식별자를 저장하 기 위한 것이고, 어드레스 ADDR32-ADDR63은 디스크립터의 콘텐츠를 저장하기 위한 것이며, 어드레스 ADDR64- ADDR1023은 디스크립터가 지시하는 텐서 데이터를 저장하기 위한 것일 수 있다. 그 중, 어드레스 ADDR은 1비트 또는 하나의 바이트로 한정되지 않으며, 여기서는 하나의 어드레스를 표시하기 위한 하나의 어드레스 단위이다. 당업자라면 실제 상황에 따라 저장영역 및 그 어드레스를 결정할 수 있을 것이며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 내부 메 모리의 상이한 영역에 각각 저장될 수 있으며, 예를 들어 레지스터를 디스크립터 저장공간으로 하여, 레지스터 에 디스크립터의 식별자와 콘텐츠를 저장할 수 있고, 온칩 캐시를 데이터 저장공간으로 하여 디스크립터가 지시 하는 텐서 데이터를 저장할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터에 전문적으로 사용되는 전용 레지스터(SR)를 설치할 수도 있으며, 디 스크립터 중의 데이터는 즉치(immediate)일 수도 있고 전용 레지스트로부터 획득할 수도 있다. 레지스터를 사용 하여 디스크립터의 식별자와 콘텐츠를 저장 시, 레지스터의 번호를 사용하여 디스크립터의 식별자를 표시할 수 있다. 예를 들어 레지스터의 번호가 0일 때, 저장되는 디스크립터의 식별자는 0이다. 레지스터 중의 디스크립터 가 유효할 때, 디스크립터가 지시하는 텐서 데이터의 크기에 따라 캐시 공간에 하나의 영역(예를 들어 캐시 중 각 텐서 데이터마다 텐서 캐시유닛을 생성한다)을 할당하여 상기 텐서 데이터를 저장할 수 있다. 이해해두어야 할 점으로, 미리 설치된 캐시공간을 사용하여 상기 텐서 데이터를 저장할 수도 있으며, 본 발명은 이에 대해 제 한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자 및 콘텐츠는 내부 메모리에 저장될 수 있고, 디스크립터가 지시하는 텐서 데이터는 외부 메모리에 저장될 수 있다. 예를 들어, 디스크립터의 식별자 및 콘텐츠는 온칩 저 장하고, 디스크립터가 지시하는 텐서 데이터는 오프칩 저장하는 방식을 채택할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자에 대응되는 저장공간의 데이터 어드레스는 고정 어드레스일 수 있다. 예를 들어 텐서 데이터를 위해 별도의 데이터 저장공간을 분할할 수 있으며, 각 텐서 데이터의 저장공 간에서의 시작 어드레스는 디스크립터의 식별자와 일일이 대응될 수 있다. 이 경우, 디스크립터의 식별자 및 대 응관계에 따라 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역을 직접 결정할 수 있다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하기 위한 것일 수도 있으며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라 미터를 더 포함할 수 있다.일종의 가능한 구현 방식에서, 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용될 수 있으 며, 그 중, 어드레스는 예를 들어 텐서 데이터의 시작 어드레스, 어드레스 오프셋, 레지스터 어드레스 또는 기 타 어드레스일 수 있다. 본 발명은 어드레스의 유형에 대해서는 제한을 두지 않는다. 예를 들어 어드레스는 텐 서 데이터의 시작 어드레스일 수 있으며, 디스크립터의 식별자에 대응되는 저장영역의 데이터 어드레스가 고정 어드레스일 경우, 디스크립터가 지시하는 N차원 텐서 데이터의 시작 어드레스는 고정 어드레스이고; 디스크립터 의 식별자에 대응되는 저장영역의 데이터 어드레스가 가변 어드레스일 경우, 디스크립터가 지시하는 N차원 텐서 데이터의 시작 어드레스는 그 구체적인 저장영역에 따라 결정할 수 있다. 본 발명은 이에 대해 제한을 두지 않 는다. 일종의 가능한 구현 방식에서, 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드 레스 파라미터를 더 포함할 수 있다. 예를 들어, 텐서 데이터가 3차원 데이터이면, 디스크립터를 사용하여 상기 텐서 데이터의 어드레스를 지시할 수 있으며, 디스크립터의 콘텐츠는 상기 텐서 데이터의 어드레스를 나타내는 하나의 어드레스 파라미터(예를 들어 텐서 데이터의 시작 어드레스)를 포함할 수 있고, 상기 텐서 데이터의 어 드레스 중 다수의 어드레스 파라미터(예를 들어 텐서 데이터의 시작 어드레스+어드레스 오프셋, 또는 텐서 데이 터는 각 차원의 어드레스 파라미터를 바탕으로 한다)를 포함할 수도 있다. 당업자라면 실제 필요에 따라 어드레 스 파라미터를 설정할 수 있으므로, 본 발명은 이에 대해 제한을 두지 않는다. 본 실시예에서, 디스크립터를 사용하여 텐서 데이터의 어드레스를 지시할 수 있어, 디스크립터가 지시하는 텐서 데이터의 어드레스를 통해, 다수의 텐서 데이터 간의 상호관계를 결정할 수 있으며, 이에 따라 프로세서의 액세 스 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 상 기 텐서 데이터가 소재하는 전체 저장영역 중에서의 기준 어드레스를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미터는 N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터가 소재하는 전체 저장영역의 크기, N개의 차원 방향 의 적어도 한 방향상에서의 상기 텐서 데이터의 저장영역의 크기, N개의 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 저장영역의 오프셋, N개의 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이 터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중 적어도 하나를 포함한다. 일종의 가능한 구현 방식에서, 텐서 데이터의 어드레스 파라미터는 텐서 데이터가 소재하는 전체 저장영역 중에 서 디스크립터의 데이터 기준점의 기준 어드레스를 포함한다. 그 중, 기준 어드레스는 데이터 기준점의 변화에 따라 달라진다. 본 발명은 데이터 기준점의 선택에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 기준 어드레스는 전체 저장영역의 시작 어드레스를 포함할 수 있다. 디스크립터 의 데이터 기준점이 전체 저장영역의 첫 번째 데이터블록일 때, 디스크립터의 기준 어드레스는 즉 전체 저장영 역의 시작 어드레스이다. 디스크립터의 데이터 기준점이 전체 저장영역 중 첫 번째 데이터블록 이외의 다른 데 이터인 경우, 디스크립터의 기준 어드레스는 즉 상기 데이터블록의 전체 저장영역 중에서의 물리 어드레스이다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 형상 파라미터는, N개의 차원 방향의 적어도 한 방향상에서 의 텐서 데이터가 소재하는 전체 저장영역의 크기, N개의 차원 방향의 적어도 한 방향상에서의 텐서 데이터의 저장영역의 크기, N개의 차원 방향의 적어도 한 방향상에서의 텐서 데이터의 저장영역의 오프셋, N개의 차원 방 향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 디스크립터가 지시하는 텐서 데 이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. 그 중, 데이 터 디스크립션 위치는 디스크립터가 지시하는 텐서 데이터 중의 점 또는 영역의 매핑 위치이며, 예를 들어 텐서 데이터가 3차원 데이터일 때, 디스크립터는 3차원 공간 좌표(x, y, z)를 사용하여 상기 텐서 데이터의 형상을 표시할 수 있고, 상기 텐서 데이터의 데이터 디스크립터의 위치는 3차원 공간 좌표(x, y, z)로 표시될 수 있으 며, 상기 텐서 데이터는 3차원 공간 중의 점 또는 영역의 위치에 매핑된다. 이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 텐서 데이터를 나타내는 형상 파라미터를 선택할 수 있 으며, 본 발명은 이에 대해 제한을 두지 않는다. 도 2에 도시된 바와 같이, 전체 저장영역은 우선적인 방식으로 2차원 데이터를 저장하였으며, (x, y)를 통 해 표시한다(그 중, X축은 수평으로 우측을 향하고, Y축은 수직으로 아래를 향한다). X축 방향상의 크기(매 행의 크기)는 ori_x이고(미도시), Y 축의 방향상의 크기(총 행수)는 ori_y이며(미도시), 전체 저장영역의 시 작 어드레스 PA_start(기준 어드레스)는 첫 번째 데이터블록의 물리 어드레스이다. 데이터블록은 전체 저장영역 중의 텐서 데이터로서, 그것의 X축 방향상의 오프셋은 offset_x로 표시하고, Y축 방향상의 오 프셋은 offset_y로 표시하며, X축 방향상의 크기는 size_x로 표시하고, Y축 방향상의 크기는 size_y로 표시 한다. 일종의 가능한 구현 방식에서, 디스크립터를 사용하여 데이터블록을 정의 시, 디스크립터의 데이터 기준점 은 전체 저장영역의 첫 번째 데이터블록을 사용할 수 있으며, 디스크립터의 기준 어드레스는 전체 저장영역 의 시작 어드레스(PA_start)이다. 이후 전체 저장영역의 X축상에서의 크기(ori_x), Y축 상에서의 크기 (ori_y), 및 데이터블록의 Y축 방향상의 오프셋(offset_y), X축 방향상의 오프셋(offset_x), X축 방향상의 크기(size_x) 및 Y축 방향상의 크기(size_y)를 결합하여 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있 다. 일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 24, "content": "이해하여야 할 점으로, 비록 상기 예시에서, 디스크립터가 설명하는 것은 2차원 공간이나, 당업자라면 실제 상 황에 따라 디스크립터의 콘텐츠가 나타내는 차원을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현방식에서, 디스크립터의 데이터 기준점의 전체 저장영역 중에서의 기준 어드레스, N개 차원 방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 데이터 기준점에 대한 위치에 따라, 상기 텐서 데이터의 디스 크립터의 콘텐츠를 결정할 수 있다. 예를 들어 설명하면, 디스크립터의 데이터 기준점의 전체 저장영역 중에서의 기준 어드레스(PA_base), 및 대각 위치의 2개의 꼭지점의 데이터 기준점에 대한 위치를 사용하여, 도 2 중 데이터블록의 디스크립터의 콘텐츠 를 결정할 수 있다. 먼저, 디스크립터의 데이터 기준점 및 그것의 전체 저장영역 중에서의 기준 어드레스 (PA_base)를 결정한다. 예를 들어, 전체 저장영역에서 하나의 데이터(예를 들어 위치가 (2,2)인 데이터)를 선택하여 데이터 기준점으로 삼고, 상기 데이터의 전체 저장영역 중에서의 물리 어드레스를 기준 어드레스 (PA_base)로 삼은 다음; 데이터블록의 대각 위치의 적어도 2개의 꼭지점의 데이터 기준점에 대한 위치를 결 정한다. 예를 들어 좌상으로부터 우하 방향인 대각 위치의 꼭지점의 데이터 기준점에 대한 위치를 사용하며, 그 중 좌상각 꼭지점의 상대위치는 (x_min，y_min)이고, 우하각 꼭지점의 상대 위치는 (x_max，y_max)이며, 이후 기준 어드레스(PA_base), 좌상각 꼭지점의 상대 위치(x_min，y_min) 및 우하각 꼭지점의 상대 위치(x_max， y_max)에 따라 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 를 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 25, "content": "이해해두어야 할 점으로, 비록 상기 예시에서 좌상각과 우하각 2개의 꼭지점을 사용하여 디스크립터의 콘텐츠를 결정하였으나, 당업자라면 실제 필요에 따라 적어도 2개의 꼭지점 중 구체적인 꼭지점을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 데이터 기준점의 전체 저장영역 중에서의 기준 어드레스, 및 디스 크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 위치에 따라, 상기 텐 서 데이터의 디스크립터의 콘텐츠를 결정할 수 있다. 그 중, 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계는 실제 필요에 따라 설정할 수 있으며, 예를 들어, 디스크립터가 지시하는 텐서 데이터가 3차원 공간 데이터인 경우, 함수 를 사용하여 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계를 정의할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다: 이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계를 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 본 실시예에서, 텐서 데이터의 기준 어드레스와 적어도 하나의 형상 파라미터에 따라 디스크립터의 콘텐츠를 결 정함으로써, 각 연산의 처리 필요에 따라 상이한 디스크립터를 사용할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자에 따라, 디스크립터의 디스크립터 저장공간 중에서의 위치 를 결정하고, 나아가 디스크립터 저장공간으로부터 디스크립터의 콘텐츠를 획득할 수 있으며; 이후 디스크립터 의 콘텐츠에 따라, 디스크립터가 지시하는 텐서 데이터의 전체 저장영역 중에서의 데이터 어드레스를 결정할 수 있다. 그 중, 데이터 어드레스의 계산은 하드웨어를 통해 자동으로 완료하거나 또는 소프트웨어 방식을 통해 구 현될 수 있다. 디스크립터의 콘텐츠가 다를 경우, 디스크립터가 지시하는 텐서 데이터의 전체 저장영역 중에서 의 데이터 어드레스의 계산 방식 역시 상이할 수 있다. 예를 들어, 공식 을 사용하여 디스크립터의 콘텐츠를 나타내는 경우, 디스크립터가 지시하는 텐서 데이터의 전체 저장영역 중에서의 오프셋이 각각 offset_x와 offset_y이고, 크기는 size_x*size_y라면, 상기 디스크립터 가 지시하는 텐서 데이터의 전체 저장영역 중에서의 시작 데이터 어드레스( )는 하기 공식을 사용하여 결정할 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 26, "content": "디스크립터가 지시하는 텐서 데이터 중의 어느 하나의 데이터점에 대해, 데이터 디스크립션 위치를 로 설 정하면, 상기 데이터점의 전체 저장영역 중에서의 데이터 어드레스( )는 하기 공식 를 사용하여 결정할 수 있다."}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 27, "content": "당업자는 실제 상황에 따라 데이터 어드레스의 계산 방법을 결정할 수 있음을 이해할 것이므로, 본 발명은 이에 대해 제한을 두지 않는다. 본 실시예에서, 디스크립터의 식별자에 따라, 디스크립터의 콘텐츠를 획득할 수 있고; 디스크립터의 콘텐츠에 따라 디스크립터가 지시하는 텐서 데이터의 전체 저장영역 중에서의 데이터 어드레스를 결정할 수 있으며; 데이 터 어드레스에 따라, 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역을 결정할 수 있다. 이러한 방식을 통 해, 데이터 액세스 과정에서 디스크립터를 사용할 수 있으며, 데이터 액세스의 복잡도를 감소시킬 수 있어 프로 세서의 처리 효율이 향상된다. 설명해두어야 할 점으로, 이상의 실시예는 예시로서 프로세서 연산 방법을 위와 같이 소개하였으나, 당업자라면, 본 발명이 이에 한정되지 않는다는 것을 이해할 수 있을 것이다. 사실상, 사용자는 전적으로 개인 의 선호 및/또는 실제 응용 시나리오에 따라 각 단계를 유연하게 설정할 수 있으며, 본 발명의 기술방안에 부합 되기만 하면 된다. 도 3d는 본 발명의 실시예에 따른 프로세서 연산 장치의 블록도이다. 도 3d에 도시된 바와 같이, 상기 프로세서 연산장치는 제1 연산이 디스크립터에 대한 연산일 때, 상기 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역을 획득하 기 위한 영역 결정모듈; 상기 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단하기 위한 연산 판단모듈; 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파인-그레인드 영 역과 상기 제2 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역 간의 중첩 여부를 판단하기 위한 중첩 판단모듈; 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩되지 않을 경우, 상기 제1 연산을 실행하기 위한 실행모듈을 포함한다.일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중 첩 시, 상기 제1 연산을 차단하기 위한 실행 제어모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 연산과 상기 제2 연산 중의 적어도 하나의 연산은 쓰기 연산이다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 길이를 설정하는 데이터가 소재 하는 영역, 차원을 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라 결정된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 하드웨어의 계산 능력, 하드웨 어의 대역폭 중의 적어도 하나에 따라 결정된다. 일종의 가능한 구현 방식에서, 상기 제1 연산을 제1 처리 명령 중의 연산으로 하고, 상기 제2 연산을 제2 처리 명령 중의 연산으로 하며, 상기 제2 처리 명령은 명령 큐 중 상기 제1 처리 명령 이전의 처리 명령이다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위 치정보와 상기 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제2 위치정보를 기록하기 위한 위치 기록 모듈을 더 포함하고, 상기 실행 모듈은 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 경우, 상기 제1 연산을 실행하 기 위한 제1 실행 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 위치정보는 제1 연산이 연산을 이미 완료한 파인-그레인드 영역의 제1 수량을 포함하고, 상기 제2 위치정보는 제2 연산이 연산을 이미 완료한 파인-그레인드 영역의 제2 수량을 포함 한다. 상기 제1 실행 서브모듈은, 상기 제1 연산이 상기 제2 연산 이후의 연산이고, 상기 제1 수량이 상기 제2 수량보 다 작을 경우, 상기 제1 연산을 실행하는데 더 사용된다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 연산 가능 영역과 연산 불가 영역을 포함하며, 상기 중첩 판단모듈은 상기 제2 연산이 존재하면서, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제 1 파인-그레인드 영역이 상기 연산 가능 영역 내에 위치하는 경우, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파인-그레인드 영역과 상기 제2 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역 간의 중첩 여부를 판단하기 위한 판단 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그 레인드 영역이고, 또한 상기 제2 파인-그레인드 영역의 상기 연산 불가 영역 내에서의 위치는 상기 제2 연산의 연산위치에 따라 업데이트되며, 상기 장치는, 상기 제2 연산이 대상으로 하는 상기 타겟 저장영역 중의 제2 파 인-그레인드 영역에서 상기 연산 불가 영역을 제거한 후, 상기 연산 불가 영역의 위치를 업데이트하기 위한 업 데이트 모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그 레인드 영역이고, 또한 상기 제2 파인-그레인드 영역은 상기 연산 불가 영역 내의 설정위치에 위치하며, 상기 연산 불가 영역의 위치는 상기 제2 연산의 연산위치에 따라 업데이트된다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 순환 버퍼 저장영역을 포함한다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 실행모듈은, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 파인-그레 인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하기 위한 제1 상태 판단 서브모듈; 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인 경우, 상기 제1 연산을 실행하기 위한 제2 실행 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 실행모듈은, 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하기 위한 제2 상태 판단 서브 모듈;상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태이고, 또한 상기 제1 파인-그레인드 영역과 상 기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 연산을 실행하기 위한 제3 실행 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 제2 연산은 상기 디스크립터에 대한 연산이다. 일종의 가능한 구현 방식에서, 상기 제2 연산의 피연산자의 저장영역과 상기 타겟 저장영역은 중첩된다. 일종의 가능한 구현 방식에서, 상기 장치는, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하기 위한 제1 설정모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 상기 타겟 저장영역을 다수의 파인-그레인드 영역으 로 분할하기 위한 제2 설정모듈, 및 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 상기 제2 연산의 피연산자의 저장영역을 다수의 파 인-그레인드 영역으로 분할하기 위한 제3 설정모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것이고, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라 미터를 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 포 함한다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터 데이터 기준점의 상기 텐서 데이터가 소재하는 전체 저장영역 중에서의 기준 어드레스를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터가 소재하는 전체 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 저장영역의 크기, N개 차원 방향의 적어도 한 방향상 에서의 상기 텐서 데이터의 저장영역의 오프셋, N개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드 레스 간의 매핑 관계 중의 적어도 하나를 포함한다. 일종의 가능한 구현 방식에서, 상기 프로세서 연산장치를 포함하는 인공지능 칩을 더 공개한다. 일종의 가능한 구현 방식에서, 메모리 소자, 인터페이스 장치와 제어 소자 및 상기 인공지능 칩을 포함하는 보 드를 더 공개하며; 그 중, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩 과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터 링하기 위한 것이다. 일종의 가능한 구현 방식에서, 상기 메모리 소자는 다수 그룹의 저장유닛을 포함하고, 각 그룹의 상기 저장유닛 과 상기 인공지능 칩은 버스를 통해 연결되며, 상기 저장유닛은 DDR SDRAM이고; 상기 칩은 각각의 상기 저장유 닛의 데이터 전송과 데이터 저장을 제어하기 위한 DDR 컨트롤러를 포함하며; 상기 인터페이스는 표준 PCIE 인터 페이스이다. A1: 프로세서 연산 방법에 있어서, 상기 방법은 제1 연산이 디스크립터에 대한 연산인 경우, 상기 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역을 획득 하는 단계; 상기 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단하는 단계; 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파인-그레인드 영 역과 상기 제2 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역 사이의 중첩 여부 를 판단하는 단계; 상기 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간이 중첩되지 않을 경우, 상기 제1 연산을 실행하는 단계를 포함한다. A2: A1항에 따른 방법에 있어서, 상기 방법은 제1 파인-그레인드 영역과 제2 파인-그레인드 영역이 중첩 시, 제1 연산을 차단하는 단계를 더 포함한다. A3: A1항에 따른 방법에 있어서, 상기 제1 연산과 상기 제2 연산 중의 적어도 하나의 연산은 쓰기 연산이다. A4: A1항에 따른 방법에 있어서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 길이를 설정하는 데이터가 소 재하는 영역, 차원을 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라 결정된다. A5: A1항에 따른 방법에 있어서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 하드웨어의 계산 능력, 하드 웨어의 대역 폭 중의 적어도 하나에 따라 결정된다. A6: A1항에 따른 방법에 있어서, 상기 제1 연산은 제1 처리 명령 중의 연산이고, 상기 제2 연산은 제2 처리 명 령 중의 연산이며, 상기 제2 처리 명령은 명령 큐 중 상기 제1 처리 명령 이전의 처리 명령이다. A7: A1-A6 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은 상기 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위치정보와 상기 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제2 위치정보를 기록하는 단계를 더 포함하고, 상기 제1 파인-그레인드 영역과 제2 파인-그레인드 영역이 중첩되지 않을 경우, 상기 제1 연산을 실행하는 단계 는 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 때, 상기 제1 연산을 실행하는 단계를 포함한다. A8: A7항에 따른 방법에 있어서, 상기 제1 위치정보는 제1 연산이 이미 연산을 완료한 파인-그레인드 영역의 제 1 수량을 포함하고, 상기 제2 위치정보는 제2 연산이 이미 연산을 완료한 파인-그레인드 영역의 제2 수량을 포 함하며, 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 때, 상기 제1 연산을 실행하는 단계는, 상기 제1 연산이 상기 제2 연산 이후의 연산이면서, 상기 제1 수량이 상기 제2 수량보다 작을 경우, 상기 제1 연산을 실행하는 단계를 포함한다. A9: A1항에 따른 방법에 있어서, 상기 타겟 저장영역은 연산 가능 영역과 연산 불가 영역을 포함하며, 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파인-그레인드 영역과 상기 제2 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역 간의 중첩 여부를 판단하는 단계는, 상기 제2 연산이 존재하면서, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파인-그레인드 영역이 상기 연산 가능 영역 내에 위치 시, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파인-그레인드 영역과 상기 제2 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역 간의 중첩 여부를 판단하는 단계를 포함한다. A10: A9항에 따른 방법에 있어서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인 -그레인드 영역이고, 또한 상기 제2 파인-그레인드 영역의 상기 연산 불가 영역 내에서의 위치는 상기 제2 연산 의 연산위치에 따라 업데이트되며, 상기 방법은, 상기 제2 연산이 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역에서 상기 연산 불가 영역을 제거한 후, 상기 연산 불가 영역의 위치를 업데이트하는 단계를 더 더 포함한다. A11: A9항에 따른 방법에 있어서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인 -그레인드 영역이고, 또한 상기 제2 파인-그레인드 영역은 상기 연산 불가 영역 내의 설정위치에 위치하며, 상기 연산 불가 영역의 위치는 상기 제2 연산의 연산위치에 따라 업데이트된다. A12: A1항에 따른 방법에 있어서, 상기 타겟 저장영역은 순환 버퍼 저장영역을 포함한다. A13: A1항에 따른 방법에 있어서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상 기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 연산을 실 행하는 단계는; 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 파인-그레 인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하여; “예”이면, 즉 상기 제1 연산을 실행하는 단계를 포함한다. A14: A1항에 따른 방법에 있어서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상 기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 연산을 실 행하는 단계는; 상기 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하여; “예”이면, 즉 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 연산을 실행하는 단계를 포함한다. A15: A1항에 따른 방법에 있어서, 상기 제2 연산은 상기 디스크립터에 대한 연산이다. A16: A1항에 따른 방법에 있어서, 상기 제2 연산의 피연산자의 저장영역과 상기 타겟 저장영역은 중첩된다. A17: A1-A16 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하는 단계를 더 포함한다. A18: A1-A17 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 상기 타겟 저장영역을 다수의 파인-그레인드 영역으 로 분할하는 단계, 및 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 상기 제2 연산의 피연산자의 저장영역을 다수의 파 인-그레인드 영역으로 분할하는 단계를 더 포함한다. A19: A1항에 따른 방법에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것이고, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A20: A19항에 따른 방법에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되 며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터 를 포함한다. A21: A20항에 따른 방법에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터 데이터 기준점의 상기 텐서 데이터가 소재하는 전체 저장영역 중에서의 기준 어드레스를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터가 소재하는 전체 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 저장영역의 오프셋, N개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준 점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. A22: 프로세서 연산장치에 있어서, 상기 장치는 제1 연산이 디스크립터에 대한 연산일 때, 상기 디스크립터가 지시하는 텐서 데이터의 타겟 저장영역을 획득하 기 위한 영역 결정모듈; 상기 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단하기 위한 연산 판단모듈; 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파인-그레인드 영 역과 상기 제2 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역 간의 중첩 여부를 판단하기 위한 중첩 판단모듈;상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩되지 않을 경우, 상기 제1 연산을 실행하기 위한 실행모듈을 포함한다. A23: A22항에 따른 장치에 있어서, 상기 장치는, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩 시, 상기 제1 연산을 차단하기 위한 실행 제어모듈을 더 포함한다. A24: A22항에 따른 장치에 있어서, 상기 제1 연산과 상기 제2 연산 중의 적어도 하나의 연산은 쓰기 연산이다. A25: A22항에 따른 장치에 있어서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 길이를 설정하는 데이터가 소재하는 영역, 차원을 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라 결정된다. A26: A22항에 따른 장치에 있어서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 하드웨어의 계산 능력, 하 드웨어의 대역폭 중의 적어도 하나에 따라 결정된다. A27: A22항에 따른 장치에 있어서, 상기 제1 연산을 제1 처리 명령 중의 연산으로 하고, 상기 제2 연산을 제2 처리 명령 중의 연산으로 하며, 상기 제2 처리 명령은 명령 큐 중 상기 제1 처리 명령 이전의 처리 명령이다. A28: A22-A27 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 상기 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위치정보와 상기 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제2 위치정보를 기록하기 위한 위치 기록모듈을 더 포함하고, 상기 실행 모듈은, 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 경우, 상기 제1 연산을 실행하기 위한 제1 실행 서브 모듈을 포함한다. A29: A28항에 따른 장치에 있어서, 상기 제1 위치정보는 제1 연산이 연산을 이미 완료한 파인-그레인드 영역의 제1 수량을 포함하고, 상기 제2 위치정보는 제2 연산이 연산을 이미 완료한 파인-그레인드 영역의 제2 수량을 포함하며, 상기 제1 실행 서브모듈은, 상기 제1 연산이 상기 제2 연산 이후의 연산이고, 상기 제1 수량이 상기 제2 수량보다 작을 경우, 상기 제1 연 산을 실행하는데 더 사용된다. A30: A22항에 따른 장치에 있어서, 상기 타겟 저장영역은 연산 가능 영역과 연산 불가 영역을 포함하며, 상기 중첩 판단모듈은, 상기 제2 연산이 존재하면서, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제1 파인-그레인드 영역이 상기 연산 가능 영역 내에 위치하는 경우, 상기 제1 연산이 현재 대상으로 하는 상기 타겟 저장영역 중 의 제1 파인-그레인드 영역과 상기 제2 연산이 현재 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역 간의 중첩 여부를 판단하기 위한 판단 서브모듈을 포함한다. A31: A30항에 따른 장치에 있어서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파 인-그레인드 영역이고, 또한 상기 제2 파인-그레인드 영역의 상기 연산 불가 영역 내에서의 위치는 상기 제2 연 산의 연산위치에 따라 업데이트되며, 상기 장치는, 상기 제2 연산이 대상으로 하는 상기 타겟 저장영역 중의 제2 파인-그레인드 영역에서 상기 연산 불가 영역을 제거한 후, 상기 연산 불가 영역의 위치를 업데이트하기 위한 업데이트 모듈을 더 포함한다. A32: A30항에 따른 장치에 있어서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파 인-그레인드 영역이고, 또한 상기 제2 파인-그레인드 영역은 상기 연산 불가 영역 내의 설정위치에 위치하며, 상기 연산 불가 영역의 위치는 상기 제2 연산의 연산위치에 따라 업데이트된다. A33: A22항에 따른 장치에 있어서, 상기 타겟 저장영역은 순환 버퍼 저장영역을 포함한다. A34: A22항에 따른 장치에 있어서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상 기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 실행모듈은, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 파인-그레 인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하기 위한 제1 상태 판단 서브모듈; 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인 경우, 상기 제1 연산을 실행하기 위한 제2 실행 서브모듈을 포함한다. A35: A22항에 따른 장치에 있어서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상 기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 실행모듈은, 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하기 위한 제2 상태 판단 서브 모듈; 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태이고, 또한 상기 제1 파인-그레인드 영역과 상 기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 연산을 실행하기 위한 제3 실행 서브모듈을 포함한다. A36: A22항에 따른 장치에 있어서, 상기 제2 연산은 상기 디스크립터에 대한 연산이다. A37: A22항에 따른 장치에 있어서, 상기 제2 연산의 피연산자의 저장영역과 상기 타겟 저장영역은 중첩된다. A38: A22-A37 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하기 위한 제1 설정모듈을 더 포함한다. A39: A22-A37 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 상기 타겟 저장영역을 다수의 파인-그레인드 영역으 로 분할하기 위한 제2 설정모듈, 및 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 상기 제2 연산의 피연산자의 저장영역을 다수의 파 인-그레인드 영역으로 분할하기 위한 제3 설정모듈을 더 포함한다. A40: A22항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것이고, N 은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A41: A40항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되 며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터 를 포함한다. A42: A41항에 따른 장치에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터 데이터 기준점의 상기 텐서 데이터가 소재하는 전체 저장영역 중에서의 기준 어드레스를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터가 소재하는 전체 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 저장영역의 오프셋, N개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준 점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. A43: 인공지능 칩에 있어서, 상기 칩은 A22-A42 중의 어느 한 항에 따른 프로세서 연산장치를 포함한다. A44: 전자장치에 있어서, 상기 전자장치는 A43에 따른 인공지능 칩을 포함한다. A45: 보드에 있어서, 상기 보드는 메모리 소자, 인터페이스 장치와 제어 소자 및 A43항에 따른 인공지능 칩을 포함하며; 그 중, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터링하기 위한 것이다. A46: A45항에 따른 보드에 있어서, 상기 메모리 소자는 다수 그룹의 저장유닛을 포함하고, 각 그룹의 상기 저장 유닛과 상기 인공지능 칩은 버스를 통해 연결되며, 상기 저장유닛은 DDR SDRAM이고; 상기 칩은 각각의 상기 저장유닛의 데이터 전송과 데이터 저장을 제어하기 위한 DDR 컨트롤러를 포함하며; 상기 인터페이스는 표준 PCIE 인터페이스이다. 인공지능 알고리즘의 복잡도가 증가함에 따라, 처리해야 할 데이터량과 데이터 차원이 모두 지속적으로 증가하 고 있으며, 통상적으로 다중 코어 및/또는 다중 칩으로 데이터 처리를 수행해야 한다. 코어간 또는 칩간의 데이 터 동기화를 수행 시, 관련 기술의 동기화 방식을 이용하는 동기화는 오버헤드(overhead)가 비교적 크고, 처리 효율이 낮다. 본 발명의 실시예에 따르면, 데이터 동기화 방법을 제공한다. 도 1e는 본 발명의 실시예에 따른 데이터 동기화 방법의 흐름도이다. 상기 데이터 동기화 방법은 프로세서에 응용될 수 있으며, 상기 프로세서는 범용 프로세서 (예를 들어 중앙처리장치(CPU), 그래픽 프로세서(GPU))와 전용 프로세서(예를 들어 인공지능 프로세서, 공학용 컴퓨터 프로세서 또는 디지털 신호 프로세서 등)를 포함할 수 있다. 본 발명은 프로세서의 유형에 대해서는 제 한을 두지 않는다. 도 1e에 도시된 바와 같이, 상기 데이터 동기화 방법은 이하 단계를 포함한다: 단계 S11e에서, 디코딩 후의 처리 명령이 디스크립터 동기화 명령일 경우, 상기 처리 명령 중의 디스크립터의 동기화 정보를 획득하며, 상기 디스크립터는 동기화할 텐서 데이터의 형상을 지시하기 위한 것이고; 단계 S12e에서, 상기 동기화 정보에 따라, 상기 처리 명령을 실행한다. 예를 들어 설명하면, 동기화할 데이터는 N차원의 텐서 데이터(N은 0 이상의 정수이며, 예를 들어 N=1, 2 또는 3 이다)를 포함할 수 있으며, 그 중 텐서는 다양한 형식의 데이터 구성 방식을 포함할 수 있고, 텐서는 상이한 차 원일 수 있으며, 예를 들어 스칼라(scalar)는 0차원의 텐서로 간주할 수 있고, 벡터는 1차원의 텐서로 간주할 수 있으며, 매트릭스는 2차원 또는 2차원 이상의 텐서일 수 있다. 텐서의 형상은 텐서의 차원, 텐서 각 차원의 크기 등 정보를 포함한다. 예를 들어 설명하면, 텐서의 경우: 이며, 상기 텐서의 형상은 디스크립터에 의해 (2,4)로 기술된다. 즉 2개의 파라미터를 통해 상기 텐서가 2차원 텐서임 을 나타내고, 또한 상기 텐서의 제1 차원(열)의 크기는 2이며, 제2 차원(행)의 크기는 4이다. 설명해두어야 할 점으로, 본 출원은 디스크립터가 텐서의 형상을 지시하는 방식에 대해서는 한정하지 않는다. 메모리에 텐서 데 이터를 저장 시, 그 데이터 어드레스(또는 저장영역)에 따라서는 텐서 데이터의 형상을 결정할 수 없으며, 나아 가 다수의 텐서 데이터 간의 상호관계 등 관련 정보를 결정할 수도 없어, 텐서 데이터에 대한 프로세서의 액세 스 효율이 저하되고, 데이터 동기화를 수행 시의 복잡도 역시 비교적 크다. 이러한 경우, 디스크립터(텐서 디스크립터)의 설정을 통해 텐서 데이터(N차원의 텐서 데이터)의 형상을 지시할 수 있다. 그 중, N의 취득값은 텐서 데이터의 차원수(급수)에 따라 결정할 수도 있고, 텐서 데이터의 사용 필요 에 따라 설정할 수도 있다. 예를 들어, N의 취득값이 3일 때, 텐서 데이터는 3차원의 텐서 데이터이며, 디스크 립터는 상기 3차원 텐서 데이터의 3개 차원 방향상의 형상(예를 들어 오프셋, 크기 등)을 지시하는데 사용될 수 있다. 이해해두어야 할 점으로, 당업자라면 실제 필요에 따라 N의 취득값을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터는 식별자와 콘텐츠 등을 포함할 수 있고, 디스크립터의 식별자는 디 스크립터를 구분하는데 사용될 수 있으며, 예를 들어 번호이고; 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터(예를 들어 텐서의 각 차원 방향상의 크기 등)를 포함할 수 있고, 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터(예를 들어 데이터 기준점의 기준 어드레스)를포함할 수도 있다. 본 발명은 디스크립터의 콘텐츠에 포함되는 구체적인 파라미터에 대해 제한을 두지 않는다. 디스크립터를 이용하여 텐서 데이터를 지시하는 방식을 통해, 텐서 데이터의 형상을 표현할 수 있고, 나아가 다 수의 텐서 데이터 간의 상호관계 등 관련 정보를 결정할 수도 있어, 텐서 데이터의 액세스 효율이 향상되고, 이 에 따라 데이터 동기화 시의 복잡도가 감소된다. 데이터 처리 과정에서, 현재의 프로세서(A1)(예를 들어 인공지능 칩의 프로세서 코어) 중의 텐서 데이터에 대해 데이터 동기화를 수행해야 할 가능성이 있으며, 예를 들어 또 다른 프로세서(A0) 중의 한 항의 연산된 연산 결 과를 프로세서(A1)에 동기화시켜 또 다른 연산의 입력 데이터로 삼을 수 있다. 이러한 경우, 디스크립터 동기화 명령을 이용하여 데이터의 동기화를 구현할 수 있다. 다시 말해 동기화할 텐서 데이터가 존재 시, 동기화 데이 터의 송신측(예를 들어 또 다른 프로세서(A0))은 프로세서(A1)로 디스크립터 동기화 명령을 전송함으로써, 현재 의 프로세서(A1)가 데이터 동기화를 수행하도록 지시할 수 있다. 일종의 가능한 구현 방식에서, 단계 S11e 이전에, 상기 방법은, 수신된 처리 명령에 대해 디코딩을 수행하여, 디코딩 후의 처리 명령을 획득하는 단계를 더 포함한다. 그 중, 상기 디코딩 후의 처리 명령은 연산코드를 포함하며, 상기 연산코드는 동기화 처리를 수행하도록 지시하 기 위한 것이다. 예를 들어 설명하면, 현재의 프로세서(A1)가 처리 명령을 수신 시, 처리 명령에 대해 디코딩(해석)을 수행하여, 디코딩 후의 처리 명령을 획득할 수 있다. 상기 디코딩 후의 처리 명령은 적어도 연산코드와 피연산자를 포함할 수 있으며, 연산코드는 상기 처리 명령에 대응되는 처리 유형을 지시하기 위한 것이고, 피연산자는 처리할 데이 터를 지시하기 위한 것이다. 처리 명령은 데이터 액세스 명령, 연산 명령, 디스크립터 관리 명령 및 동기화 명 령 등을 포함할 수 있다. 본 발명은 처리 명령의 구체적인 유형 및 디코딩의 구체적인 방식에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디코딩 후의 처리 명령의 연산코드가 디스크립터 동기화 처리를 수행하도록 지시 한다면, 즉 상기 처리 명령을 디스크립터 동기화 명령으로 결정할 수 있다. 디코딩 후의 처리 명령이 디스크립 터 동기화 명령인 경우, 프로세서는 단계 S11e에서 상기 처리 명령 중의 디스크립터 동기화 정보를 획득하여, 디스크립터가 지시하는 동기화할 텐서 데이터에 대해 동기화를 수행할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 동기화 정보는 예를 들어 상기 디스크립터의 식별자 및 상기 디스 크립터의 콘텐츠 중의 적어도 하나를 포함할 수 있다. 프로세서에 상기 동기화할 텐서 데이터를 지시하는 디스 크립터가 이미 등록되어 있고 수정할 필요가 없다면, 즉 디스크립터 동기화 명령 중의 동기화 정보는 디스크립 터의 식별자만 포함하여(예를 들어 디스크립터의 식별자가 TR1일 때, 디스크립터 동기화 명령은 Send TR1로 표 시한다), 프로세서가 처리 명령 중의 상기 디스크립터의 식별자(TR1)에 따라 텐서 데이터의 동기화를 구현할 수 있고; 만약 프로세서 중 상기 동기화할 텐서 데이터의 디스크립터가 등록되어 있지 않다면, 즉 디스크립터 동기 화 명령 중의 동기화 정보는 디스크립터의 콘텐츠를 포함할 수 있으며, 프로세서는 처리 명령 중의 디스크립터 의 콘텐츠에 따라 텐서 데이터의 동기화를 구현할 수 있다. 프로세서에 상기 동기화할 텐서 데이터를 지시하는 디스크립터가 이미 등록되어 있으나 단 디스크립터의 콘텐츠를 수정해야 하는 경우, 즉 디스크립터 동기화 명령 중의 동기화 정보는 디스크립터의 식별자와 콘텐츠를 동시에 포함할 수 있으며, 프로세서는 처리 명령 중의 디 스크립터 식별자와 콘텐츠에 따라 텐서 데이터의 동기화를 구현할 수 있다. 본 발명은 디스크립터 동기화 정보 에 포함되는 구체적인 내용에 대해서는 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터 동기화 명령의 동기화 정보를 획득한 후, 프로세서는 단계 S12e에서 동기화 정보에 따라 상기 처리 명령(디스크립터 동기화 명령)을 실행하여, 텐서 데이터의 동기화를 구현할 수 있다. 본 발명의 실시예의 데이터 동기화 방법에 따르면, 텐서 데이터의 형상을 지시하는 디스크립터의 설정을 통해, 디코딩 후의 처리 명령이 디스크립터 동기화 명령일 때, 처리 명령 중의 디스크립터 동기화 정보를 획득하고, 디스크립터의 동기화 정보에 따라 명령을 실행함으로써 텐서 데이터의 동기화를 구현할 수 있으며, 이에 따라 동기화 오버헤드가 감소하여 데이터 동기화 효율이 향상된다. 일종의 가능한 구현 방식에서, 단계 S12e는 상기 디스크립터가 지시하는 텐서 데이터의 저장영역이 공용 저장공간에 놓여 있는 경우, 상기 동기화 정보에 따라, 상기 공용 저장공간으로부터 상기 텐서 데이터를 획득하는 단계를 포함할 수 있다. 예를 들어 설명하면, 다수의 프로세서(다수의 코어)는 공용 저장공간, 예를 들어 프로세서(A0)와 프로세서(A1) 가 모두 액세스할 수 있는 오프칩 메모리를 구비할 수 있다. 상기 공용 저장공간은 다수의 코어(다수의 프로세 서)가 모두 데이터를 액세스할 수 있는 저장공간일 수도 있고, 일부 코어(일부 프로세서)가 데이터를 액세스할 수 있는 저장공간일 수도 있으며, 코어 간의 공용 저장공간을 미리 설치할 수 있다. 본 발명은 공용 저장공간의 설정 방식에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 동기화할 텐서 데이터의 저장 어드레스가 공용 저장공간에 놓여 있다면, 즉 현재 의 프로세서(A1) 역시 공용 저장공간으로부터 데이터를 액세스할 수 있기 때문에, 프로세서(A1)는 디스크립터의 콘텐츠에 따라 텐서 데이터를 직접 독취하여 동기화를 구현할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터 동기화 요청 명령 중의 동기화 정보에 디스크립터의 식별자만 포함되 어 있다면, 예를 들어 디스크립터의 식별자가 TR1이고, 디스크립터 동기화 요청 명령이 Send TR1로 표시될 경우, 즉 프로세서(A1)는 상기 디스크립터의 식별자에 대응되는 디스크립터 콘텐츠를 내부 검색하고, 나아가 디 스크립터의 콘텐츠에 따라 공용 저장공간으로부터 동기화할 텐서 데이터를 획득함으로써, 전체적인 동기화 과정 을 구현한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 요청 명령 중의 동기화 정보에 디스크립터의 식별자와 콘텐츠가 포함되어 있다면, 즉 프로세서(A1)는 상기 디스크립터의 식별자에 대응되는 디스크립터를 검색하고, 디스크립터 동기화 요청 명령 중의 디스크립터 콘텐츠에 따라, 원래의 디스크립터 콘텐츠를 업데이트하며; 나아 가 업데이트 후의 디스크립터 콘텐츠에 따라 공용 저장공간으로부터 동기화할 텐서 데이터를 획득함으로써, 전 체적인 동기화 과정을 구현한다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령 중의 동기화 정보에 디스크립터의 콘텐츠만 포함되 어 있다면, 즉 프로세서(A1)는 디스크립터 콘텐츠에 따라, 상기 동기화할 텐서 데이터를 지시하는 디스크립터를 등록하고, 디스크립터 콘텐츠에 따라 공용 저장공간으로부터 동기화할 텐서 데이터를 획득함으로써, 전체적인 동기화 과정을 구현한다. 이러한 방식을 통해, 상기 디스크립터 동기화 명령 중의 디스크립터의 동기화 정보에 따라, 디스크립터가 지시 하는 동기화할 텐서 데이터를 획득하여, 텐서 데이터의 동기화를 구현하므로, 불필요한 데이터 전송을 피할 수 있으며, 텐서 데이터 액세스 횟수가 감소하여 동기화의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 다수의 프로세서(다수의 코어)는 전문적으로 동기화 데이터를 저장하기 위한 동 기화 데이터 저장공간을 구비할 수 있다. 상기 동기화 데이터 저장공간은 상기 공용 저장공간일 수도 있고, 공 용 저장공간의 일부분일 수도 있으며, 공용 저장공간과 다른 저장공간일 수도 있다. 본 발명은 이에 대해 제한 을 두지 않는다. 일종의 가능한 구현 방식에서, 동기화 데이터 저장공간은 다수의 코어(다수의 프로세서)가 동기화 데이터에 액 세스할 수 있는 저장공간일 수도 있고, 일부 코어(일부 프로세서)가 동기화 데이터에 액세스할 수 있는 저장공 간일 수도있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 디스크립터 동기화 명령 중의 동기화 정보에 동기화할 텐서 데이터의 디스 크립터 콘텐츠의 동기화 데이터 저장공간 중에서의 어드레스가 포함되어 있는 경우, 즉 프로세서(A1)는 상기 어 드레스에 따라, 동기화 데이터 저장공간으로부터 동기화할 텐서 데이터의 디스크립터 콘텐츠를 획득하고, 디스 크립터의 콘텐츠에 따라 디스크립터를 등록하고 동기화할 텐서 데이터의 데이터 어드레스를 결정할 수 있으며, 나아가 상기 동기화할 텐서 데이터를 획득함으로써, 전체적인 동기화 과정을 구현한다. 이러한 방식을 통해, 동기화 시 프로세서 간의 데이터 전송을 추가적으로 감소시킬 수 있어, 동기화의 처리 효 율이 향상된다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자와 콘텐츠는 디스크립터 저장공간에 저장될 수 있으며, 상기 디스크립터 저장공간은 프로세서의 내부 메모리(예를 들어 레지스터, 온칩 SRAM 또는 기타 매체의 캐시(cache) 등) 중의 저장공간일 수 있다. 디스크립터가 지시하는 텐서 데이터의 데이터 저장공간은 프로세서의 내부 메모 리(예를 들어 온칩 캐시) 또는 프로세서와 연결되는 외부 메모리(오프칩 메모리) 중의 저장공간일 수 있다. 데 이터 저장공간 중의 데이터 어드레스는 실제 물리 어드레스이거나 또는 가상 어드레스일 수 있다. 본 발명은 디 스크립터 저장공간 및 데이터 저장공간의 위치 및 데이터 어드레스의 유형에 대해 제한을 두지 않는다.일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 동일한 영역에 위치할 수 있다. 예를 들어, 온칩 캐시의 연속되는 영역을 사용하여 디스크립터의 관련 콘텐츠를 저장할 수 있으며, 그 어드레스는 ADDR0-ADDR1023이다. 그 중, 어드레스 ADDR0-ADDR31은 디스크립터의 식별자를 저장하 는데 사용될 수 있고, 어드레스 ADDR32-ADDR63은 디스크립터의 콘텐츠를 저장하는데 사용될 수 있으며, 어드레 스 ADDR64-ADDR1023은 디스크립터가 지시하는 텐서 데이터를 저장하는데 사용될 수 있다. 그 중, 어드레스 ADDR 은 1비트 또는 하나의 바이트로 한정되지 않으며, 여기서는 하나의 어드레스를 표시하기 위한 하나의 어드레스 단위이다. 당업자라면 실제 상황에 따라 저장영역 및 그 어드레스를 결정할 수 있을 것이며, 본 발명은 이에 대 해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 내부 메 모리의 상이한 영역에 각각 저장될 수 있다. 예를 들어 레지스터를 디스크립터 저장공간으로 하여, 레지스터에 디스크립터의 식별자와 콘텐츠를 저장할 수 있고, 온칩 캐시를 데이터 저장공간으로 하여 디스크립터가 지시하 는 텐서 데이터를 저장할 수 있다. 일종의 가능한 구현 방식에서, 전문적으로 디스크립터가 사용할 전용 레지스터(SR)를 더 설치할 수 있으며, 디 스크립터 중의 데이터는 즉치(immediate)일 수도 있고 전용 레지스터로부터 획득될 수도 있다. 레지스터를 사용 하여 디스크립터의 식별자와 콘텐츠를 저장 시, 레지스터의 번호를 사용하여 디스크립터의 식별자를 표시할 수 있다. 예를 들어 레지스터의 번호가 0일 때, 저장되는 디스크립터의 식별자는 0이다. 레지스터 중의 디스크립터 가 유효할 때, 디스크립터가 지시하는 텐서 데이터의 크기에 따라 캐시 공간에 하나의 영역을 할당하여(예를 들 어 캐시 중 각 텐서 데이터마다 하나의 텐서 캐시유닛을 생성한다) 상기 텐서 데이터를 저장할 수 있다. 미리 설정된 캐시 공간을 이용하여 상기 텐서 데이터를 저장할 수도 있음을 이해하여야 하며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자 및 콘텐츠는 내부 메모리에 저장될 수 있고, 디스크립터가 지시하는 텐서 데이터는 외부 메모리에 저장될 수 있다. 예를 들어, 디스크립터의 식별자 및 콘텐츠는 온칩 저 장하고, 디스크립터가 지시하는 텐서 데이터는 오프칩 저장하는 방식을 채택할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터에 대응되는 데이터 저장공간의 데이터 어드레스는 고정 어드레스일 수 있다. 예를 들어 텐서 데이터를 위해 별도의 데이터 저장공간을 분할할 수 있으며, 각 텐서 데이터의 데이터 저장공간에서의 시작 어드레스는 디스크립터의 식별자와 일일이 대응될 수 있다. 이 경우, 프로세서는 디스크립 터의 콘텐츠에 따라 텐서 데이터의 데이터 어드레스를 즉시 결정할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터에 대응되는 데이터 저장공간의 데이터 어드레스가 가변 어드레스일 때, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용될 수 있으며, 그 중, 상기 디스 크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 더 포함할 수 있다. 예를 들어, 텐서 데이터가 3차원 데이터이고, 디스크립터가 상기 텐서 데이터의 어드레스를 지향하는 경우, 디 스크립터의 콘텐츠는 상기 텐서 데이터의 어드레스를 나타내는 하나의 어드레스 파라미터, 예를 들어 텐서 데이 터의 시작 물리 어드레스를 포함할 수 있고, 상기 텐서 데이터 어드레스의 다수의 어드레스 파라미터, 예를 들 어 텐서 데이터의 시작 어드레스+어드레스 오프셋을 포함할 수도 있으며, 또는 텐서 데이터는 각 차원의 어드레 스 파라미터를 바탕으로 한다. 당업자라면 실제 필요에 따라 어드레스 파라미터를 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 상 기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함한다. 그 중, 기준 어드레스는 데이터 기준점 의 변화에 따라 달라진다. 본 발명은 데이터 기준점의 선택에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 기준 어드레스는 상기 데이터 저장공간의 시작 어드레스를 포함할 수 있다. 디스크립터의 데이터 기준점이 데이터 저장공간의 첫 번째 데이터블록일 때, 디스크립터의 기준 어드레스는 즉 데이터 저장공간의 시작 어드레스이다. 디스크립터의 데이터 기준점이 데이터 저장공간 중 첫 번째 데이터블록 이외의 다른 데이터인 경우, 디스크립터의 기준 어드레스는 즉 상기 데이터블록의 데이터 저장공간 중에서의 물 리 어드레스이다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 저 장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데 이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중 적어도 하나를 포함한다. 그 중, 데이터 디스크립 션 위치는 디스크립터가 지시하는 텐서 데이터 중의 점 또는 영역의 매핑 위치이며, 예를 들어 텐서 데이터가 3 차원 데이터일 때, 디스크립터는 3차원 공간 좌표(x, y, z)를 사용하여 상기 텐서 데이터의 형상을 나타낼 수 있으며, 상기 텐서 데이터의 데이터 디스크립터의 위치는 3차원 공간 좌표(x, y, z)로 표시되는 것일 수 있고, 상기 텐서 데이터는 3차원 공간 중의 점 또는 영역의 위치에 매핑된다. 이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 텐서 데이터를 나타내는 형상 파라미터를 선택할 수 있 으며, 본 발명은 이에 대해 제한을 두지 않는다. 도 2는 본 발명의 일 실시예에 따른 데이터 저장공간의 설명도이다. 도 2에 도시된 바와 같이, 데이터 저장공간 은 우선적인 방식으로 2차원 데이터를 저장하였으며, (x, y)를 통해 표시한다(그 중, X축은 수평으로 우측 을 향하고, Y축은 수직으로 아래를 향한다). X축 방향상의 크기(매 행의 크기)는 ori_x이고(미도시), Y 축의 방 향상의 크기(총 행수)는 ori_y이며(미도시), 데이터 저장공간의 시작 어드레스 PA_start(기준 어드레스)는 첫 번째 데이터블록의 물리 어드레스이다. 데이터블록은 데이터 저장공간 중의 일부 데이터로서, 그것의 X축 방향상의 오프셋은 offset_x로 표시하고, Y축 방향상의 오프셋은 offset_y로 표시하며, X축 방향상의 크기는 size_x로 표시하고, Y축 방향상의 크기는 size_y로 표시한다. 일종의 가능한 구현 방식에서, 디스크립터를 사용하여 데이터블록을 정의 시, 디스크립터의 데이터 기준점 은 데이터 저장공간의 첫 번째 데이터블록을 사용할 수 있으며, 디스크립터의 기준 어드레스는 데이터 저장 공간의 시작 어드레스(PA_start)이다. 이후 데이터 저장공간의 X축상에서의 크기(ori_x), Y축 상에서의 크기(ori_y), 및 데이터블록의 Y축 방향상의 오프셋(offset_y), X축 방향상의 오프셋(offset_x), X축 방향 상의 크기(size_x) 및 Y축 방향상의 크기(size_y)를 결합하여 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 28, "content": "이해하여야 할 점으로, 비록 상기 예시에서, 디스크립터가 설명하는 것은 이차원 공간이나, 당업자라면 실제 상 황에 따라 디스크립터의 콘텐츠가 나타내는 차원을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현방식에서, 상기 디스크립터의 데이터 기준점의 상기 데이터 저장공간 중에서의 기준 어드레 스, N개 차원 방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치에 따라, 상기 텐서 데이터의 디스크립터의 콘텐츠를 결정할 수 있다. 예를 들어 설명하면, 디스크립터의 데이터 기준점의 데이터 저장공간 중에서의 기준 어드레스(PA_base), 및 대 각 위치의 2개의 꼭지점의 데이터 기준점에 대한 위치를 사용하여, 도 2 중 데이터블록의 디스크립터의 콘 텐츠를 결정할 수 있다. 먼저, 디스크립터의 데이터 기준점 및 그것의 데이터 저장공간 중에서의 기준 어드레스 (PA_base)를 결정한다. 예를 들어, 데이터 저장공간에서 하나의 데이터(예를 들어 위치가 (2,2)인 데이터) 를 선택하여 데이터 기준점으로 삼고, 데이터 저장공간 중에서 상기 데이터의 물리 어드레스를 기준 어드레스 (PA_base)로 삼은 다음; 데이터블록의 대각 위치의 적어도 2개의 꼭지점의 데이터 기준점에 대한 위치를 결 정한다. 예를 들어 좌상으로부터 우하 방향인 대각 위치의 꼭지점의 데이터 기준점에 대한 위치를 사용하며, 그 중 좌상각 꼭지점의 상대위치는 (x_min，y_min)이고, 우하각 꼭지점의 상대 위치는 (x_max，y_max)이며, 이후 기준 어드레스(PA_base), 좌상각 꼭지점의 상대 위치(x_min，y_min) 및 우하각 꼭지점의 상대 위치(x_max， y_max)에 따라 데이터블록의 디스크립터의 콘텐츠를 결정할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 를 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 29, "content": "이해해두어야 할 점으로, 비록 상기 예시에서 좌상각과 우하각 2개의 꼭지점을 사용하여 디스크립터의 콘텐츠를 결정하였으나, 당업자라면 실제 필요에 따라 적어도 2개의 꼭지점 중 구체적인 꼭지점을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 디스크립터의 데이터 기준점의 상기 데이터 저장공간 중에서의 기준 어드레 스, 및 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 에 따라, 상기 텐서 데이터의 디스크립터의 콘텐츠를 결정할 수 있다. 그 중, 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계는 실제 필요에 따라 설정할 수 있으며, 예를 들어, 디스크립터가 지시하는 텐서 데이 터가 3차원 공간 데이터인 경우, 함수 를 사용하여 데이터 디스크립션 위치와 데이터 어드레스 간의 매 핑 관계를 정의할 수 있다. 일종의 가능한 구현 방식에서, 하기 공식 을 사용하여 디스크립터의 콘텐츠를 나타낼 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 30, "content": "이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계를 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 공식 로 디스크립터의 콘텐츠를 나타내는 경우, 텐서 데이터 중의 어느 하나의 데이터점에 대해, 그 데이터 디스크립션 위치를 라 설정한다면, 상기 데이터 저장공간 중에서 상기 데이터점의 데이터 어드레스 ( )는 하기 공식 를 사용하여 결정할 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 31, "content": "이러한 방식을 통해, 프로세서는 디스크립터의 콘텐츠에 따라 디스크립터가 지시하는 텐서 데이터의 데이터 저 장공간 중에서의 데이터 어드레스를 계산할 수 있으며, 나아가 상기 어드레스에 따라 처리 명령에 대응되는 처 리(예를 들어 데이터 연산, 데이터 동기화 등)를 실행함으로써, 데이터 액세스의 복잡도를 감소시킬 수 있어, 프로세서의 처리 효율이 향상된다. 도 3e는 본 발명의 실시예에 따른 데이터 동기화 장치의 블록도이다. 상기 데이터 동기화 장치는 프로세서에 응 용될 수 있으며, 도 3e에 도시된 바와 같이, 상기 데이터 동기화 장치는, 디코딩 후의 처리 명령이 디스크립터 동기화 명령인 경우, 상기 처리 명령 중의 동기화할 텐서 데이터의 형상을 지시하는 디스크립터의 동기화 정보를 획득하기 위한 동기화 정보 획득모듈(31e); 상기 동기화 정보에 따라, 상기 처리 명령을 실행하기 위한 명령 실행 모듈(32e)을 포함한다. 일종의 가능한 구현 방식에서, 상기 동기화 정보는, 상기 디스크립터의 식별자 및 상기 디스크립터의 콘텐츠 중 의 적어도 하나를 포함한다. 일종의 가능한 구현 방식에서, 상기 명령 실행 모듈은, 상기 디스크립터가 지시하는 텐서 데이터의 저장영역이 공용 저장공간에 놓여 있는 경우, 상기 동기화 정보에 따라, 상기 공용 저장공간으로부터 상기 텐서 데이터를 획득하기 위한 데이터 획득 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것으로서, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파 라미터를 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 더 포함한다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 데 이터 저장공간 중에서의 기준 어드레스를 포함한다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 형상 파라미터는 N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개차원방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시 하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 수신된 처리 명령에 대해 디코딩 처리를 수행하여, 디코딩 후의 처 리 명령을 획득하기 위한 디코딩 모듈을 더 포함하며, 그 중 상기 디코딩 후의 처리 명령은 동기화 처리를 수행 하도록 지시하기 위한 연산코드를 포함한다. 일종의 가능한 구현 방식에서, 상기 데이터 동기화 장치를 포함하는 인공지능 칩을 더 공개한다. 일종의 가능한 구현 방식에서, 메모리 소자, 인터페이스 장치와 제어 소자 및 상기 인공지능 칩을 포함하는 보 드를 더 공개하며; 그 중, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩 과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터 링하기 위한 것이다. A1: 데이터 동기화 방법에 있어서, 상기 방법은 디코딩 후의 처리 명령이 디스크립터 동기화 명령인 경우, 상기 처리 명령 중의 동기화할 텐서 데이터의 형상을 지시하는 디스크립터의 동기화 정보를 획득하는 단계; 상기 동기화 정보에 따라, 상기 처리 명령을 실행하는 단계를 포함한다. A2: A1항에 따른 방법에 있어서, 상기 동기화 정보는, 상기 디스크립터의 식별자 및 상기 디스크립터의 콘텐츠 중의 적어도 하나를 포함한다. A3: A1 또는 A2항에 따른 방법에 있어서, 상기 처리 명령을 실행하는 단계는, 상기 디스크립터가 지시하는 텐서 데이터의 저장영역이 공용 저장공간에 놓여 있는 경우, 상기 동기화 정보에 따라, 상기 공용 저장공간으로부터 상기 텐서 데이터를 획득하는 단계를 포함한다. A4: A1-A3 중의 어느 한 항에 따른 방법에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것으로서, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A5: A4항에 따른 방법에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파 라미터를 더 포함한다. A6: A5항에 따른 방법에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점의 상기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함한다. A7: A6항에 따른 방법에 있어서, 상기 텐서 데이터의 형상 파라미터는 N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 차원방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시 하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. A8: A1-A7 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은, 수신된 처리 명령에 대해 디코딩 처리를 수행하여, 디코딩 후의 처리 명령을 획득하는 단계를 더 포함하며, 그 중 상기 디코딩 후의 처리 명령은 동기화 처리를 수행하도록 지시하기 위한 연산코드를 포함한다. A9: 데이터 동기화 장치에 있어서, 상기 장치는 디코딩 후의 처리 명령이 디스크립터 동기화 명령인 경우, 상기 처리 명령 중의 동기화할 텐서 데이터의 형상을 지시하는 디스크립터의 동기화 정보를 획득하기 위한 동기화 정보 획득모듈; 상기 동기화 정보에 따라, 상기 처리 명령을 실행하기 위한 명령 실행 모듈을 포함한다. A10: A9항에 따른 장치에 있어서, 상기 동기화 정보는, 상기 디스크립터의 식별자 및 상기 디스크립터의 콘텐츠 중의 적어도 하나를 포함한다. A11: A9 또는 A10항에 따른 장치에 있어서, 상기 명령 실행 모듈은, 상기 디스크립터가 지시하는 텐서 데이터의 저장영역이 공용 저장공간에 놓여 있는 경우, 상기 동기화 정보에 따라, 상기 공용 저장공간으로부터 상기 텐서 데이터를 획득하기 위한 데이터 획득 서브모듈을 포함한다. A12: A9-A11 중의 어느 한 항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하 기 위한 것으로서, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A13: A12항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되 며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터 를 더 포함한다. A14: A13항에 따른 장치에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점 의 상기 텐서 데이터의 데이터 저장공간 중에서의 기준 어드레스를 포함한다. A15: A14항에 따른 장치에 있어서, 상기 텐서 데이터의 형상 파라미터는 N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 차원방향의 대각 위치에 놓인 적어도 2개의 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시 하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다."}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 32, "content": "A16: A9-A15 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 수신된 처리 명령에 대해 디코딩 처리를 수행하여, 디코딩 후의 처리 명령을 획득하기 위한 디코딩 모듈을 더 포함하며, 그 중 디코딩 후의 처리 명령은 동기화 처리를 수행하도록 지시하기 위한 연산코드를 포함한다. A17: 인공지능 칩에 있어서, 상기 칩은 A9-A16 중의 어느 한 항에 따른 데이터 동기화 장치를 포함한다. A18: 전자장치에 있어서, 상기 전자장치는 A1항에 따른 인공지능 칩을 포함한다. A19: 보드에 있어서, 상기 보드는 메모리 소자, 인터페이스 장치와 제어 소자 및 A17항에 따른 상기 인공지능 칩을 포함하며; 그 중, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩과 외 부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터링하기 위한 것이다. A20: A19항에 따른 보드에 있어서, 상기 메모리 소자는 다수 그룹의 저장유닛을 포함하며, 각 그룹의 상기 저장유닛은 버스를 통해 상기 인공지능 칩과 연결되고, 상기 저장유닛은 DDR SDRAM이며; 상기 칩은 각각의 상기 저장유닛에 대한 데이터 전송과 데이터 저장을 제어하기 위한 DDR 컨트롤러를 포함하고; 상기 인터페이스 장치는 표준 PCIE 인터페이스이다. 인공지능 기술이 지속적으로 발전함에 따라, 처리해야 할 데이터량과 데이터 차원이 모두 지속적으로 증가하고 있다. 관련 기술에서, 프로세서는 통상적으로 명령을 획득하는 파라미터를 통해 데이터 어드레스를 결정한 후, 데이터 어드레스에 따라 명령 간의 의존관계를 판단하는데, 이러한 명령 간의 의존관계를 판단하려면 먼저 피연 산자의 데이터 어드레스를 계산하는 방식이므로, 프로세서의 처리 효율이 저하된다. 본 발명의 실시예에 따르면, 데이터 처리방법을 제공한다. 도 1f는 본 발명의 실시예에 따른 데이터 처리방법의 흐름도이다. 도 1f에 도시된 바와 같이, 상기 데이터 처리방법은, 단계 S11f에서, 디코딩된 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포 함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하며; 단계 S12f에서, 상기 제1 처리 명령이 실행 가능한 경우, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명 령에 대응되는 데이터 처리를 실행한다. 일종의 가능한 구현 방식에서, 상기 처리방법은 프로세서에 응용될 수 있다. 상기 프로세서는 범용 프로세서(예 를 들어 중앙처리장치(CPU), 그래픽 프로세서(GPU))와 전용 프로세서(예를 들어 인공지능 프로세서, 공학용 컴 퓨터 프로세서 또는 디지털 신호 프로세서 등)를 포함할 수 있다. 본 발명은 프로세서의 유형에 대해서는 제한 을 두지 않는다. 일종의 가능한 구현 방식에서, 디코딩 후의 제1 처리 명령은 상기 제1 처리 명령에 대응되는 처리 유형을 지시 하기 위한 연산코드(operation code) 및 하나 또는 다수의 피연산자를 포함한다. 그 중, 제1 처리 명령은 데이 터 액세스 명령, 연산 명령, 디스크립터 관리 명령 및 동기화 명령 등을 포함할 수 있다. 본 발명은 제1 처리 명령의 구체적인 유형에 대해서는 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 처리할 데이터는 N차원의 텐서 데이터(N은 0 이상의 정수이며, 예를 들어 N=1, 2 또는 3이다)를 포함할 수 있으며, 그 중 텐서는 다양한 형식의 데이터 구성 방식을 포함할 수 있고, 텐서는 상 이한 차원일 수 있으며, 예를 들어 스칼라(scalar)는 0차원의 텐서로 간주할 수 있고, 벡터는 1차원의 텐서로 간주할 수 있으며, 매트릭스는 2차원 또는 2차원 이상의 텐서일 수 있다. 텐서의 형상은 텐서의 차원, 텐서 각 차원의 크기 등 정보를 포함한다. 예를 들어 설명하면, 텐서의 경우: 이며 상기 텐서의 형상은 디스크립터에 의해 (2,4)로 기술된다. 즉 2개의 파라미터를 통해 상기 텐서가 2차원 텐서임 을 나타내며, 또한 상기 텐서의 제1 차원(열)의 크기는 2이고, 제2 차원(행)의 크기는 4이다. 설명해두어야 할 점으로, 본 출원은 디스크립터가 텐서의 형상을 지시하는 방식에 대해서는 한정하지 않는다. 메모리에 텐서 데 이터를 저장 시, 그 데이터 어드레스(또는 저장영역)에 따라서는 텐서 데이터의 형상을 결정할 수 없으며, 나아 가 다수의 텐서 데이터 간의 상호관계 등 관련 정보를 결정할 수도 없어, 텐서 데이터에 대한 프로세서의 액세 스 효율이 저하된다. 일종의 가능한 구현 방식에서, 디스크립터는 N차원의 텐서 데이터의 형상을 지시할 수 있으며, N은 0 이상의 정 수이다. 그 중, N의 취득값은 텐서 데이터의 차원수(급수)에 따라 결정할 수도 있고, 텐서 데이터의 사용 필요 에 따라 설정할 수도 있다. 예를 들어, n의 취득값이 3일 때, 텐서 데이터는 3차원의 텐서 데이터이며, 디스크 립터는 상기 3차원 텐서 데이터의 3개의 차원 방향상의 형상(예를 들어 오프셋, 크기 등)을 지시하는데 사용될 수 있다. 이해해두어야 할 점으로, 당업자라면 실제 필요에 따라 N의 취득값을 설정할 수 있으며, 본 발명은 이 에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터는 식별자와 콘텐츠를 포함할 수 있다. 그 중, 디스크립터의 식별자는 디스크립터를 구분하기 위한 것으로서, 예를 들어 그 번호이며; 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다(예를 들어 텐서의 각 차원 방향상의 크기 등), 텐서 데이터 의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터(예를 들어 데이터 기준점의 기준 어드레스)를 더 포 함할 수도 있다. 본 발명은 디스크립터의 콘텐츠에 포함되는 구체적인 파라미터에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자와 콘텐츠는 디스크립터 저장공간에 저장될 수 있으며, 상기 디스크립터 저장공간은 제어유닛의 내부 메모리(예를 들어 레지스터, 온칩 SRAM 또는 기타 매체의 캐시(cache) 등) 중의 저장공간일 수 있다. 디스크립터가 지시하는 텐서 데이터의 데이터 저장공간은 상기 제어유닛의 내부 메모리(예를 들어 온칩 캐시) 또는 상기 제어유닛과 연결되는 외부 메모리(예를 들어 오프칩 메모리) 중의 저장 공간일 수 있다. 데이터 저장공간 중의 데이터 어드레스는 실제의 물리 어드레스이거나 또는 가상 어드레스일 수 있다. 본 발명은 디스크립터 저장공간 및 데이터 저장공간의 위치 및 데이터 어드레스의 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 동일한 영역에 위치할 수 있다. 예를 들어, 온칩 캐시의 연속되는 영역을 사용하여 디스크립터의 관련 콘텐츠를 저장할 수 있으며, 그 어드레스는 ADDR0-ADDR1023이다. 그 중, 어드레스 ADDR0-ADDR31은 디스크립터의 식별자를 저장하 기 위한 것이고, 어드레스 ADDR32-ADDR63은 디스크립터의 콘텐츠를 저장하기 위한 것이며, 어드레스 ADDR64- ADDR1023은 디스크립터가 지시하는 텐서 데이터를 저장하기 위한 것일 수 있다. 그 중, 어드레스 ADDR은 1비트또는 하나의 바이트로 한정되지 않으며, 여기서는 하나의 어드레스를 표시하기 위한 것으로서 하나의 어드레스 단위이다. 당업자라면 실제 상황에 따라 저장영역 및 그 어드레스를 결정할 수 있을 것이며, 본 발명은 이에 대 해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자, 콘텐츠 및 디스크립터가 지시하는 텐서 데이터는 내부 메 모리의 상이한 영역에 각각 저장될 수 있으며, 예를 들어 레지스터를 디스크립터 저장공간으로 하여, 레지스터 에 디스크립터의 식별자와 콘텐츠를 저장할 수 있고, 온칩 캐시를 데이터 저장공간으로 하여 디스크립터가 지시 하는 텐서 데이터를 저장할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터에 전문적으로 사용되는 전용 레지스터(SR)를 설치할 수도 있으며, 디 스크립터 중의 데이터는 즉치(immediate)일 수도 있고 전용 레지스트로부터 획득할 수도 있다. 레지스터를 사용 하여 디스크립터의 식별자와 콘텐츠를 저장 시, 레지스터의 번호를 사용하여 디스크립터의 식별자를 표시할 수 있다. 예를 들어 레지스터의 번호가 0일 때, 저장되는 디스크립터의 식별자는 0이다. 레지스터 중의 디스크립터 가 유효할 때, 디스크립터가 지시하는 텐서 데이터의 크기에 따라 캐시 공간에 하나의 영역(예를 들어 캐시 중 각 텐서 데이터마다 텐서 캐시유닛을 생성한다)을 할당하여 상기 텐서 데이터를 저장할 수 있다. 이해해두어야 할 점으로, 미리 설치된 캐시공간을 사용하여 상기 텐서 데이터를 저장할 수도 있으며, 본 발명은 이에 대해 제 한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자 및 콘텐츠는 내부 메모리에 저장될 수 있고, 디스크립터가 지시하는 텐서 데이터는 외부 메모리에 저장될 수 있다. 예를 들어, 디스크립터의 식별자 및 콘텐츠는 온칩 저 장하고, 디스크립터가 지시하는 텐서 데이터는 오프칩 저장하는 방식을 채택할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터에 대응되는 데이터 저장공간의 데이터 어드레스는 고정 어드레스일 수 있다. 예를 들어 텐서 데이터를 위해 별도의 데이터 저장공간을 분할할 수 있으며, 각 텐서 데이터의 데이터 저장공간에서의 시작 어드레스는 디스크립터의 식별자와 일일이 대응될 수 있다. 이 경우, 제어유닛은 디스크립 터의 콘텐츠에 따라 텐서 제어모듈을 통해 피연산자에 대응하는 데이터의 데이터 어드레스를 결정한 후, 제1 처 리 명령을 실행할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자에 대응되는 데이터 저장공간의 데이터 어드레스가 가변 어 드레스일 때, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용될 수 있으며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 더 포함할 수 있다. 예를 들어, 텐서 데이터가 3차원 데이터이고, 디스크립터가 상기 텐서 데이터의 어드레스를 지시하는 경우, 디스크립터의 콘텐츠는 상기 텐서 데이터의 어드레스를 나타내는 하나의 어드레스 파라미터, 예를 들어 텐서 데이터의 시작 어드레스를 포함할 수 있고, 상기 텐서 데이터의 어드레스 중 다수의 어드레스 파라미터, 예를 들어 텐서 데이터의 시작 어드레스+어드레스 오프셋을 포함할 수도 있으며, 또는 텐서 데이터는 각 차원의 어드레스 파라미터를 바탕으로 한다. 당업자라면 실제 필요에 따라 어드레스 파라미터를 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 텐서 데이터의 데이터 저장공간 중에서 상기 디스크립터의 데이터 기준점의 기준 어드레스를 포함한다. 그 중, 기준 어드레스는 데이터 기준점 의 변화에 따라 달라진다. 본 발명은 데이터 기준점의 선택에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 기준 어드레스는 상기 데이터 저장공간의 시작 어드레스를 포함할 수 있다. 디스크립터의 데이터 기준점이 데이터 저장공간의 첫 번째 데이터블록일 때, 디스크립터의 기준 어드레스는 즉 데이터 저장공간의 시작 어드레스이다. 디스크립터의 데이터 기준점이 데이터 저장공간 중 첫 번째 데이터블록 이외의 다른 데이터인 경우, 디스크립터의 기준 어드레스는 즉 상기 데이터블록의 데이터 저장공간 중에서의 물 리 어드레스이다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 데이터의 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기텐서 데이터의 저장영역 의 크기, N개의 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개의 차원 방향의 대각 위치에 놓이는 적어도 두 꼭짓점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이 터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중 적어도 하나를 포함한다. 그 중, 데이터 디스크립션 위치는 디스크립터가 지시하는 텐서 데이터 중의 점 또는 영역의 매핑 위치이며, 예를 들어 텐서 데이터가 3차 원 데이터일 때, 디스크립터는 3차원 공간 좌표(x, y, z)를 사용하여 상기 텐서 데이터의 형상을 표시할 수 있으며, 상기 텐서 데이터의 데이터 디스크립터의 위치는 3차원 공간 좌표(x, y, z)로 표시되는 것일 수 있고, 상 기 텐서 데이터는 3차원 공간 중의 점 또는 영역의 위치에 매핑된다. 이해해두어야 할 점으로, 당업자라면 실제 상황에 따라 텐서 데이터를 나타내는 형상 파라미터를 선택할 수 있 으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 단계 S11f에서, 디코딩된 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포 함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단할 수 있다. 그 중, 디스크립터의 식별자가 동일한지 여부는 디스크립터가 지시하는 텐서 데이터가 동일한지 여부를 나타낼 수 있다. 데이터의 저장 어드레스와 비교하여, 디스크립터의 식별자는 더욱 간단하기 때문에, 디스크립터의 식 별자를 통해 이 디스크립터의 이전 순서의 명령을 동일하게 연산하는 과정이 존재하는지 여부를 판단하는 방식 이, 데이터의 저장 어드레스를 통해 이전 순서의 명령을 연산하는 과정이 존재하는지 여부를 판단하는 방식에 비해 훨씬 간단하고 효율이 높으며, 그 중 이전 순서의 명령은 제1 처리 명령과 의존관계를 지닌 처리 명령일 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자 및 미리 설정된 실행 조건에 따라 제1 처리 명령의 실행 가 능 여부를 판단할 수 있다. 예를 들어, 레지스터를 사용하여 디스크립터의 식별자를 저장 시, 그 중, 각 레지스 터에 하나의 디스크립터 식별자를 저장하면, 동일한 레지스터에 액세스하는 다수의 명령은 명령 제출 순서대로 실행될 수 있기 때문에, 명령 큐 중 제1 처리 명령 이전이면서, 동일한 레지스터에 액세스하는 명령의 실행이 모두 이미 완료되었는지 여부를 판단할 수 있으며; 동일한 레지스터에 액세스하는 명령의 실행이 완료된 후, 제 1 처리 명령을 실행 가능함을 결정할 수 있다. 미리 설정되는 실행 조건은, 필요한 디스크립터를 먼저 등록하기, 디스크립터의 사용이 완료되지 않은 경우 취소 불가 등일 수 있다. 본 발명은 미리 설정되는 실행 조 건에 대해 제한하지 않는다. 일종의 가능한 구현 방식에서, 단계 S11f는, 상기 디스크립터의 식별자에 따라, 명령 큐 중 상기 제1 처리 명령 이전에 위치하며 피연산자에 상기 디스크립터의 식별자를 갖는 처리 명령을 포함하는 처리가 완료되지 않은 제2 처리 명령이 존재하는지 여부를 판단하여; 제2 처리 명령이 존재하지 않을 경우, 상기 제1 처리 명령이 실행 가 능한 것으로 결정하는 단계를 포함할 수 있다. 다시 말해, 제1 처리 명령의 피연산자에 디스크립터의 식별자가 포함되어 있을 경우, 디스크립터의 식별자에 따 라, 명령 큐 중 제1 처리 명령 이전이면서, 피연산자에 상기 디스크립터의 식별자를 구비한 제2 처리 명령이 존 재하는지 여부를 결정하여, 검색된 제2 처리 명령을 제1 처리 명령과 의존관계를 갖는 처리 명령으로 삼을 수 있다. 제1 처리 명령의 피연산자가 다수의 디스크립터의 식별자를 가지는 경우, 각 디스크립터에 대응되는 의존 관계를 각각 판단할 수 있으며, 다시 말해, 피연산자에 다수의 디스크립터 중의 적어도 하나의 디스크립터의 식 별자가 구비된 이전 순서의 명령을 의존관계를 갖는 제2 처리 명령으로 삼는다. 처리가 완료되지 않은 제2 처리 명령이 존재 시, 제1 처리 명령은 실행될 수 없으며; 제2 처리 명령이 존재하지 않을 경우, 제1 처리 명령은 실행 가능하다. 예를 들어 설명하면, 제1 처리 명령의 피연산자에 적어도 하나의 디스크립터 식별자가 포함되어 있을 경우, 실 행이 완료되지 않은 제2 처리 명령의 존재 여부를 판단 시, 피연산자에 포함된 모든 디스크립터의 식별자에 대 해 판단을 수행하고, 제1 처리 명령의 피연산자 중의 적어도 하나의 디스크립터의 식별자가 제2 처리 명령의 피 연산자 중의 디스크립터의 식별자와 동일할 경우, 제1 처리 명령과 제2 처리 명령은 의존관계를 지니며, 제2 처 리 명령의 실행이 완료되지 않은 경우, 제1 처리 명령을 실행할 수 없다. 예를 들어, 제1 처리 명령이 ADD；TR10；TR11；TR12이고, 제2 처리 명령이 ADD；TR10；TR11；TR12인 경우, 제1 처리 명령과 제2 연산 명령의 피연산자 중의 디스크립터의 식별자는 완전히 동일하여. 즉 제1 처리 명령과 제2 처리 명령은 의존관계를 지닌다. 따라서 제2 처리 명령의 실행이 완료되지 않으면, 제1 처리 명령을 실행할 수 없다. 제1 처리 명령이 ADD；TR10；TR11；TR13이고; 제2 처리 명령이 ADD；TR10；TR11；TR12인 경우, 제1 처리 명령 과 제2 연산 명령의 피연산자 중 2개의 디스크립터의 식별자(TR10과 TR11)가 동일하여, 즉 제1 처리 명령과 제2 처리 명령은 의존관계를 지닌다. 따라서 제2 처리 명령의 실행이 완료되지 않으면, 제1 처리 명령을 실행할 수 없다. 제1 처리 명령이 ADD；TR10；TR12；TR13이고; 제2 처리 명령이 ADD；TR10；TR14；TR15인 경우, 제1 처리 명령 과 제2 연산 명령의 피연산자 중 1개의 디스크립터의 식별자(TR10)가 동일하여, 즉 제1 처리 명령과 제2 처리명령은 의존관계를 지닌다. 따라서 제2 처리 명령의 실행이 완료되지 않으면, 제1 처리 명령을 실행할 수 없다. 예를 들어, 제1 처리 명령이 ADD；TR10；TR11；TR12이고, 제2 처리 명령이 ADD；TR13；TR14；TR15인 경우, 제1 처리 명령과 제2 연산 명령의 피연산자 중의 디스크립터의 식별자는 완전히 상이하여. 즉 제1 처리 명령과 제2 처리 명령은 의존관계가 없다. 따라서 제2 처리 명령의 실행이 완료되지 않았을 때, 제1 처리 명령을 실행할 수 있다. 제1 처리 명령이 SUM；TR10이고; 제2 처리 명령이 SUM；TR10인 경우, 제1 처리 명령과 제2 연산 명령의 피연산 자 중 디스크립터의 식별자가 완전히 동일하여, 즉 제1 처리 명령과 제2 처리 명령은 의존관계를 지닌다. 따라 서 제2 처리 명령의 실행이 완료되지 않으면, 제1 처리 명령을 실행할 수 없다. 이러한 방식을 통해, 디스크립터의 식별자에 따라 명령을 실행할 수 있는지 여부를 직접 판단할 수 있어, 명령 중 관련된 피연산자의 기준 어드레스와 연산 범위를 여러 번 획득하여, 명령 중 피연산자의 데이터 어드레스와 연산 범위를 계산할 필요가 없기 때문에, 프로세스가 명령의 실행 가능 여부를 판단하는 복잡도가 감소되어, 명 령 중 피연산자의 데이터 어드레스의 분석 과정이 단순해짐으로써, 프로세서의 실행 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령과 상기 제2 처리 명령 중의 적어도 하나는 상기 디스크립터 에 대한 쓰기 연산을 포함한다. 예를 들어, 제1 처리 명령이 디스크립터 TR2에 대한 읽기 명령이고, 제2 처리 명령 역시 디스크립터 TR2에 대한 읽기 명령으로, 제1 처리 명령과 제2 처리 명령에 모두 디스크립터 TR2에 대한 쓰기 연산이 포함되어 있지 않으 면, 즉 제1 처리 명령을 실행할 수 있다. 제2 처리 명령이 TR2에 대한 쓰기 명령일 경우, 즉 제2 처리 명령의 처리가 완료되지 않으면, 제1 처리 명령은 실행할 수 없다. 이러한 방식을 통해, 하나의 디스크립터는 다수의 명령 연산을 동시에 허용하여, 명령의 병행 실행 효율이 향상 될 수 있으며, 이에 따라 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포함할 수 있으며, 단계 S11f는, 상기 적어도 하나의 디스크립터의 식별자에 따라, 등록 상태 또는 미등록 상태를 포함 하는 각 디스크립터의 제1 상태를 각각 결정하는 단계; 각 디스크립터의 제1 상태가 모두 등록 상태인 경우, 상 기 제1 처리 명령이 실행 가능함을 결정하는 단계를 포함할 수 있다. 다시 말해, 피연산자에 포함되는 모든 디 스크립터의 상태가 모두 등록 상태인 경우, 제1 처리 명령을 실행할 수 있다. 예를 들어, 제1 처리 명령의 피연산자에 2개의 디스크립터의 식별자 TR3과 TR4가 포함되어 있다면, 디스크립터 의 식별자 TR3과 TR4에 따라, TR3과 TR4의 상태(등록 또는 미등록)를 결정할 수 있으며, TR3과 TR4 중 적어도 하나의 상태가 미등록일 때, 제1 처리 명령은 실행할 수 없다. 이때, 디스크립터 등록 명령을 호출하여 TR3 및/ 또는 TR4에 대한 등록을 수행하고, 등록이 이루어진 후 TR3 및/또는 TR4의 상태를 등록으로 변경한다. 디스크립 터 TR3과 TR4의 상태가 모두 등록인 경우, 제1 처리 명령을 실행할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 제1 상태는 다양한 표시 방식이 있을 수 있다. 예를 들어, 디스크 립터에 제1 플래그 비트를 설치하여 제1 상태를 표시할 수 있으며, 예를 들어, 레지스터에 디스크립터의 식별자 를 저장하고, 레지스터의 최고 비트를 제1 플래그 비트로 사용하여, 차상위 비트로부터 디스크립터의 관련 정보 를 저장한다. 상태 대응표를 설치하여, 디스크립터의 제1 상태를 상태 대응표에 입력할 수도 있다. 당업자라면 실제 필요에 따라 제1 상태의 표시 방식을 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 이러한 방식을 통해, 디스크립터의 제1 상태에 따라 명령 실행 가능 여부를 판단할 수 있어, 프로세서가 명령 실행 가능 여부를 판단하는 복잡도를 감소시킬 수 있다. 취소 연산을 예로 들면, 상기 디스크립터를 곧 취소시 킬 때, 상기 상태를 변경해주기만 하면, 즉시 연산을 완료할 수 있어, 디스크립터의 관련 저장영역을 비울 필요 가 없으며, 이 공간을 사용하는 다른 디스크립터가 있을 경우, 상기 영역을 직접 덮어쓰기만 하면 된다. 연산 조작을 예로 들면, 먼저 상기 연산자의 상태를 직접 판단하여, 상기 연산자가 무효할 때, 제1 상태를 통해 상기 명령을 실행할 수 없음을 즉시 판단할 수 있으며, 따라서 추가적인 판단이 필요 없이 상기 명령을 즉시 차단할 수 있다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포함할 수 있으며, 단계 S11f는, 상기 적어도 하나의 디스크립터의 식별자에 따라, 연산 가능 상태 또는 연산 불가 상 태를 포함하는 각 디스크립터의 제2 상태를 각각 결정하며; 각 디스크립터의 제2 상태가 모두 연산 가능 상태인 경우, 상기 제1 처리 명령이 실행 가능함을 결정하는 단계를 더 포함할 수 있다.예를 들어 설명하면, 제1 처리 명령 이전 순서의 명령이 현재 디스크립터에 대해 연산을 수행하고 있는(예를 들 어 쓰기 또는 읽기) 상황에서, 디스크립터의 현재 상태는 연산 불가 상태이다. 상기 상태에서는 제1 처리 명령 을 실행할 수 없으며, 제1 처리 명령을 차단하거나 캐시할 수 있다. 반대로, 현재 디스크립터에 대해 연산을 수 행하는 이전 순서의 명령이 없는 경우, 디스크립터의 현재 상태를 연산 가능 상태로 설정할 수 있다. 상기 상태 에서는 제1 처리 명령을 수행할 수 있다. 일종의 가능한 구현 방식에서, 상기 디스크립터에 대해 연산을 수행하는 이전 단계의 명령이 두 줄 이상인 경우, 연산 가능 상태를 \"0\"으로 표시하고, 연산 불가 상태를 \"1\"로 표시한다. 이전 단계 명령의 모든 연산이 완료된 후, 제2 상태의 플래그 위치는 “0”이고, 아닌 경우는 “1”이다; 혹은, 연산 가능 상태는 “0”으로 표시하고, 연산 불가 상태를 “N”으로 표시하며, N은 상기 디스크립터를 연산하는 이전 단계 명령의 수량으로 서, 각각의 이전 단계의 명령의 연산이 완료되면 즉 N-1이며, 플래그 비트의 값이 0이 되면, 상기 디스크립터의 제2 상태는 연산 가능 상태가 된다. 본 발명은 상태의 구체적인 표시 방식에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 디스크립터의 제2 상태는 연산 가능 상태 또는 연산 불가 상태를 포함할 수 있으 며, 그 중, 제2 상태는 다양한 방식을 통해 나타낼 수 있다. 예를 들어, 디스크립터에 제2 플래그 비트를 설치 하여 제2 상태를 표시할 수도 있고, 디스크립터의 제2 상태를 상태 대응표에 입력할 수도 있다. 그 중, 상태 대 응표는 레지스터에 저장할 수 있으며, 하드웨어 방식을 통해 상태 대응표 중 제1 상태와 제2 상태에 대한 판단 을 구현할 수 있다. 당업자는 실제 필요에 따라 제2 상태의 표시 방식을 설정할 수 있으며, 본 발명은 이에 대 해 제한을 두지 않는다. 이러한 방식을 통해, 디스크립터의 제2 상태에 따라 명령의 연산 가능 여부를 판단할 수 있어, 프로세서가 명령 의 연산 가능 여부를 판단하는 복잡도를 감소시킬 수 있다. 연산 조작을 예로 들면 상기 명령과 관련된 디스크 립터의 제2 상태가 연산 가능 상태인지 여부를 직접 판단하므로, 상기 명령과 관련된 연산 데이터에 대해 피연 산자의 기준 어드레스와 연산 범위를 획득함으로써 연산의 실제 연산 범위을 획득한 다음, 영역 사이의 중첩 여 부를 판단하여, 상기 명령이 연산 가능 상태인지 여부의 결론을 획득할 필요가 없다. 일종의 가능한 구현 방식에서, 단계 S11f를 통해 제1 처리 명령을 실행할 수 있음을 결정 시, 단계 S12f에서, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행할 수 있다. 다시 말해, 제1 처리 명령이 실행 가능할 경우, 디스크립터의 식별자에 따라, 계산을 통해 디스크립터가 지시하는 텐서 데 이터의 데이터 어드레스를 획득한 후, 데이터 어드레스로부터 텐서 데이터를 독취하고 제1 처리 명령에 대응되 는 데이터 처리를 실행할 수 있다. 일종의 가능한 구현 방식에서, 디스크립터의 식별자에 따라, 디스크립터가 지시하는 텐서 데이터의 데이터 어드 레스를 직접 획득할 수 있으며, 예를 들어, 디스크립터의 콘텐츠가 텐서 데이터의 데이터 어드레스인 경우, 계 산할 필요 없이, 직접 디스크립터 저장공간으로부터 데이터 어드레스를 독취하고, 데이터 어드레스로부터 텐서 데이터를 독취하여, 제1 처리 명령에 대응되는 데이터 처리를 실행할 수 있다. 일종의 가능한 구현 방식에서, 단계 S12f는, 상기 디스크립터의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하는 단계; 상기 디스크립터의 콘텐츠에 따라, 상기 피연산자에 대응되는 데이 터의 데이터 저장공간 중에서의 데이터 어드레스를 결정하는 단계; 상기 데이터 어드레스에 따라, 상기 제1 처 리 명령에 대응되는 데이터 처리를 실행하는 단계를 포함할 수 있다. 본 실시예에서, 제1 처리 명령이 실행 가능할 경우, 피연산자 중 디스크립터의 식별자에 따라, 디스크립터 저장 공간으로부터 상기 디스크립터의 콘텐츠를 획득할 수 있다. 다시 말해, 디스크립터의 식별자에 따라, 디스크립 터의 디스크립터 저장공간 중에서의 위치를 결정하고, 나아가 디스크립터 저장공간으로부터 디스크립터의 콘텐 츠를 획득할 수 있다. 따라서, 소프트웨어 프로그래밍의 복잡도를 감소시킬 수 있으며, 소프트웨어측에서 하드 웨어측의 데이터 저장방식을 이해하여, 하드웨어의 실제 저장 어드레스를 계산할 필요가 없는 동시에, 명령의 복잡도 역시 감소시킬 수 있으며, 여러 번 사용하는 파라미터(예를 들어 디스크립터 중의 콘텐츠)를 매번 사용 시마다 명령에 입력할 필요가 없다. 디스크립터의 콘텐츠를 획득한 후, 디스크립터의 콘텐츠에 따라, 피연산자에 대응하는 데이터의 데이터 저장공 간 중에서의 데이터 어드레스를 결정할 수 있다. 그 중, 데이터 어드레스의 계산은 하드웨어를 통해 자동으로 완료하거나 또는 소프트웨어 방식으로 구현할 수 있다. 디스크립터의 콘텐츠가 다를 경우, 피연산자에 대응하는 데이터의 데이터 저장공간 중에서의 데이터 어드레스의 계산방식은 다를 수도 있다. 본 발명은 데이터 어드레스 의 계산방식에 대해 제한을 두지 않는다.예를 들어, 공식 로 디스크립터의 콘텐츠를 나타내는 경우, 텐서 데이터 중의 어느 하나의 데이터점에 대해, 그 데이터 디스크립션 위치를 라 설정한다면, 상기 데이터 저장공간 중에서 상기 데이터점의 데이터 어드 레스( )는 하기 공식 를 사용하여 결정할 수 있다:"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 33, "content": "피연산자에 대응하는 데이터의 데이터 저장공간 중에서의 데이터 어드레스를 획득한 후, 데이터 어드레스에 따 라, 제1 처리 명령에 대응하는 데이터 처리를 실행할 수 있다. 예를 들어 설명하면, 제1 처리 명령이 연산 명령 ADD；A；B인 경우, 피연산자 A와 B 중 각각 디스크립터의 식별 자 TR5와 TR6이 포함되어 있다면, 즉 TR5와 TR6에 따라, 각각 디스크립터 저장공간으로부터 디스크립터 TR5와 TR6의 콘텐츠(예를 들어 형상 파라미터와 어드레스 파라미터)을 획득하고; 이후 디스크립터 TR5와 TR6의 콘텐츠 에 따라, 데이터 A와 B의 데이터 어드레스를 각각 계산하며, 데이터 A의 데이터 저장공간 중에서의 어드레스 1 은 ADDR64-ADDR127이고, 데이터 B의 데이터 저장공간 중에서의 어드레스 2는 ADDR1023-ADDR1087이다. 이후, 어 드레스 1과 어드레스 2로부터 데이터를 각각 독취하고, 가법(ADD) 연산을 실행하여 연산 결과(A+B)를 획득한다. 일종의 가능한 구현 방식에서, 상기 방법은, 상기 제1 처리 명령이 디스크립터 등록 명령일 경우, 상기 제1 처 리 명령 중 디스크립터의 식별자, 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중 적어도 하나를 포함하는 등록 파라미터를 획득하는 단계; 상기 디스크립터의 등록 파라미터에 따라, 상기 제1 처리 명령의 실 행 가능 여부를 판단하는 단계; 상기 제1 처리 명령이 실행 가능 시, 상기 제1 처리 명령을 실행하는 단계를 더 포함할 수 있다. 본 실시예에서, 제1 처리 명령이 디스크립터 등록 명령인 경우, 제1 처리 명령으로부터 디스크립터의 등록 파라 미터를 획득할 수 있으며, 그 중, 등록 파라미터는 디스크립터의 식별자, 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중 적어도 하나를 포함할 수 있다. 이후 디스크립터의 등록 파라미터에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하면, 디스크립터의 등록 파라미터에 따라 디스크립터의 등록 가능 여부를 즉시 판단할 수 있다. 예를 들어, 디스크립터의 식별자가 점용되었거나 또는 디스크립터 저장공간이 부족한 경 우, 디스크립터는 등록에 성공할 수 없다. 당업자라면 실제 상황에 따라 등록 파라미터의 판단에 대해 설정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 디스크립터의 등록 파라미터에 따라, 상기 제1 처리 명령의 실행 가능 여부 를 판단하는 단계는, 상기 디스크립터의 식별자가 점용되지 않은 경우, 상기 디스크립터의 콘텐츠를 저장하는 제1 저장영역이 점용되지 않은 경우, 및 상기 디스크립터가 지시하는 텐서 데이터를 저장하는 제2 저장영역이 점용되지 않은 경우 중의 적어도 하나를 만족 시, 상기 제1 처리 명령의 실행 가능함을 결정하는 단계를 포함할 수 있다. 다시 말해, 등록 파라미터가 디스크립터의 식별자가 점용되지 않은 경우, 제1 저장영역이 점용되지 않 은 경우 또는 제2 저장영역이 점용되지 않은 경우 중의 적어도 하나를 만족시키는 경우, 제1 처리 명령을 실행 할 수 있다. 제1 처리 명령을 실행 가능한 경우, 상기 제1 처리 명령(디스크립터 등록 명령)을 실행한다. 예를 들어, 먼저 디스크립터의 콘텐츠의 디스크립터 저장공간 중에서의 제1 저장영역 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠의 데이터 저장영역 중에서의 제2 저장영역을 결정한 다음, 등록 파라미터 및 제2 저장영역에 따라, 디스 크립터의 콘텐츠를 결정하여, 디스크립터와 제2 저장영역 간의 대응관계를 구축하며; 이후, 디스크립터의 콘텐 츠를 제1 저장영역에 저장하여 디스크립터의 등록을 완료한다. 일종의 가능한 구현 방식에서, 상기 방법은, 상기 제1 처리 명령이 디스크립터 취소 명령인 경우, 상기 제1 처 리 명령 중 디스크립터의 식별자에 따라, 명령 큐 중에 있으면서, 피연산자에 상기 디스크립터의 식별자의 처리 명령이 포함된, 처리가 미완료된 제4 처리 명령이 존재하는지 여부를 판단하는 단계; 처리가 미완료된 제4 처리 명령이 존재하지 않는 경우, 상기 제1 처리 명령을 실행하는 단계를 더 포함한다. 본 실시예에서, 제1 처리 명령이 디스크립터 취소 명령인 경우, 디스크립터의 식별자에 따라 명령 큐 중 피연산 자에 디스크립터의 식별자가 포함된 제4 처리 명령이 있는지 여부를 판단하여, 처리가 완료되지 않은 제4 처리 명령이 존재할 경우, 제1 처리 명령을 실행할 수 없고; 처리가 완료되지 않은 제4 처리 명령이 존재하지 않을 경우, 제1 처리 명령인 디스크립터 취소 명령을 실행할 수 있으며, 이때, 디스크립터의 디스크립터 저장공간 중 에서의 저장영역 및 디스크립터가 지시하는 데이터의 데이터 저장공간에서의 저장영역을 각각 해제할 수 있다.예를 들어 설명하면, 제1 처리 명령이 디스크립터 취소 명령이고, 취소하는 디스크립터의 식별자가 TR7이면, 먼 저 TR7에 대한 연산 명령과 읽기 명령인 2개의 제4 처리 명령이 있는 명령 큐에서 피연산자에 TR7의 제4 처리 명령이 포함되어 있는지 여부를 검색할 수 있으며; 이후 이 2개의 제4 처리 명령(TR7에 대한 연산 명령과 읽기 명령)의 실행이 완료되었는지 여부를 판단한다. 이 2개의 제4 처리 명령이 모두 실행이 완료되지 않은 경우, 제 1 처리 명령(디스크립터 취소 명령)은 실행할 수 없고; 2개의 제4 처리 명령이 모두 실행 완료된 경우, 제1 처 리 명령을 실행할 수 있다. 이후, 제1 처리 명령(디스크립터 취소 명령)을 실행하여, TR7의 디스크립터 저장공 간 중에서의 저장영역 및 TR6이 지시하는 데이터의 데이터 저장공간에서의 저장영역을 각각 해제할 수 있다. 일종의 가능한 구현 방식에서, 제1 처리 명령이 디스크립터 취소 명령인 경우, 디스크립터의 식별자에 따라, 디 스크립터의 제1 상태가 등록인지 여부를 결정할 수 있다. 디스크립터의 제1 상태가 등록인 경우, 제1 처리 명령 (디스크립터 취소 명령)을 실행할 수 있다. 그렇지 않으면, 제1 처리 명령(디스크립터 취소 명령)은 실행할 수 없다. 즉, 피연산자 중의 디스크립터가 이미 등록 상태여야, 비로소 디스크립터 취소 명령을 실행할 수 있다. 일종의 가능한 구현 방식에서, 상기 방법은, 상기 제1 처리 명령을 실행할 수 없을 경우, 상기 제1 처리 명령을 차단하거나 또는 캐시하는 단계를 더 포함할 수 있다. 다시 말해, 제1 처리 명령을 실행할 수 없을 때, 제1 처 리 명령을 차단하여, 제1 처리 명령 및 이후의 다른 명령의 실행을 임시 정지시켜, 제2 처리 명령의 실행이 완 료된 다음 다시 제1 처리 명령 및 이후의 다른 명령을 실행할 수 있다. 제1 처리 명령을 캐시하여, 다른 명령의 실행에 영향을 주지 않고, 제1 처리 명령을 미리 설정된 캐시 공간에 저장하여, 제2 처리 명령의 실행이 완료된 다음, 캐시 공간 중의 제1 처리 명령을 실행할 수도 있다. 본 발명은 제1 처리 명령을 실행할 수 없을 때의 처 리 방식에 대해 제한을 두지 않는다. 본 발명의 실시예의 데이터 처리방법에 따르면, 디코딩된 처리 명령의 피연산자에 디스크립터의 식별자가 포함 되어 있는 경우, 디스크립터의 식별자를 통해 명령의 실행 가능 여부를 판단할 수 있고, 명령을 실행 가능할 때, 디스크립터의 식별자에 따라 명령에 대응되는 데이터 처리를 실행할 수 있으며, 이에 따라 프로세서가 명령 의 실행 가능 여부를 판단하는 복잡도를 감소시킬 수 있어, 프로세서의 처리 효율이 향상된다. 설명해두어야 할 점으로, 비록 상기 실시예를 예시로 데이터 처리방법을 소개하였으나, 단 당업자라면, 본 발명 이 이에 한정되지 않음을 이해할 수 있을 것이다. 사실상, 사용자가 전적으로 개인의 선호 및/또는 실제 응용 시나리오에 따라 각 단계를 유연하게 설정할 수 있으며, 본 발명의 기술방안에 부합되기만 하면 된다. 도 3f는 본 발명의 실시예에 따른 데이터 처리장치의 블록도이다. 도 3f에 도시된 바와 같이, 상기 데이터 처리 장치는 디코딩된 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하기 위한 판단 모듈 (31f); 상기 제1 처리 명령이 실행 가능한 경우, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령에 대응되는 데 이터 처리를 실행하기 위한 실행 모듈(32f)을 포함한다. 일종의 가능한 구현 방식에서, 상기 실행 모듈(32f)은 상기 디스크립터의 식별자에 따라, 디스크립터 저장공간 으로부터 상기 디스크립터의 콘텐츠를 획득하기 위한 콘텐츠 획득 서브모듈; 상기 디스크립터의 콘텐츠에 따라, 상기 피연산자에 대응되는 데이터의 데이터 저장공간 중에서의 데이터 어드레스를 결정하기 위한 어드레스 결정 서브모듈; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하기 위한 제1 실 행 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 판단 모듈(31f)은, 상기 디스크립터의 식별자에 따라, 명령 큐 중 상기 제1 처리 명령의 이전에 위치하면서, 피연산자에 상기 디스크립터의 식별자를 구비한 처리 명령을 포함하는 처리가 완료되지 않은 제2 처리 명령이 존재하는지 여부를 판단하기 위한 명령 판단 서브모듈; 제2 처리 명령이 존재하 지 않을 경우, 상기 제1 처리 명령이 실행 가능한 것으로 결정하기 위한 제1 실행 결정 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령과 상기 제2 처리 명령 중의 적어도 하나는 상기 디스크립터 에 대한 쓰기 연산을 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포함하 며, 그 중, 상기 판단 모듈(31f)은, 상기 적어도 하나의 디스크립터의 식별자에 따라, 각 디스크립터의 등록 상 태 또는 미등록 상태를 포함하는 제1 상태를 각각 결정하기 위한 제1 상태 결정 서브모듈; 각 디스크립터의 제1상태가 모두 등록 상태인 경우, 상기 제1 처리 명령을 실행 가능한 것으로 결정하기 위한 제2 실행 결정 서브모 듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포함하 며, 그 중, 상기 판단 모듈(31f)은, 상기 적어도 하나의 디스크립터의 식별자에 따라, 각 디스크립터의 연산 가 능 상태 또는 연산 불가 상태를 포함하는 제2 상태를 각각 결정하기 위한 제2 상태 결정 서브모듈; 각 디스크립 터의 제2 상태가 모두 연산 가능 상태인 경우, 상기 제1 처리 명령을 실행 가능한 것으로 결정하기 위한 제3 실 행 결정 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 처리 명령이 디스크립터 취소 명령일 경우, 상기 제1 처 리 명령 중 디스크립터의 식별자에 따라, 명령 큐 중에 위치하면서, 피연산자에 상기 디스크립터의 식별자를 포 함하는 처리 명령인 처리가 완료되지 않은 제4 처리 명령이 존재하는지 여부를 판단하기 위한 취소 판단 모듈; 처리가 완료되지 않은 제4 처리 명령이 존재하지 않을 경우, 상기 제1 처리 명령을 실행하기 위한 취소 실행 모 듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 처리 명령이 디스크립터 등록 명령일 경우, 상기 제1 처 리 명령 중 디스크립터의 식별자, 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나 를 포함하는 등록 파라미터를 획득하기 위한 파라미터 획득 모듈; 상기 디스크립터의 등록 파라미터에 따라, 상 기 제1 처리 명령의 실행 가능 여부를 판단하기 위한 등록 판단 모듈; 상기 제1 처리 명령이 실행 가능할 경우, 상기 제1 처리 명령을 실행하기 위한 등록 실행 모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 등록 판단 모듈은, 상기 디스크립터의 식별자가 점용되지 않은 경우, 상기 디스 크립터의 콘텐츠를 저장하는 제1 저장영역이 점용되지 않은 경우, 및 상기 디스크립터가 지시하는 텐서 데이터 를 저장하는 제2 저장영역이 점용되지 않은 경우 중의 적어도 하나를 만족시킬 때, 상기 제1 처리 명령을 실행 가능한 것으로 결정하기 위한 조건 판단 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 처리 명령을 실행할 수 없는 경우, 상기 제1 처리 명령을 차단하거나 또는 캐시하기 위한 실행 제어모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것으로서, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파 라미터를 포함한다. 일종의 가능한 구현 방식에서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터를 포 함한다. 일종의 가능한 구현 방식에서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터 데이터 기준점의 상기 텐서 데이터의 데이터 저장영역 중에서의 기준 어드레스를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미터 는, N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간 크기, N개 차원 방향의 적어도 한 방향상에 서의 상기 텐서 데이터의 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한 다. 일종의 가능한 구현 방식에서, 상기 데이터 처리장치를 포함하는 인공지능 칩을 더 공개한다. A1: 데이터 처리방법에 있어서, 상기 방법은 디코딩된 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하는 단계; 상기 제1 처리 명령이 실행 가능한 경우, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령에 대응되는 데 이터 처리를 실행하는 단계를 포함한다. A2: A1항에 따른 방법에 있어서, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령에 대응되는 데이터 처 리를 실행하는 단계는, 상기 디스크립터의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하는 단계; 상기 디스크립터의 콘텐츠에 따라, 상기 피연산자에 대응되는 데이터의 데이터 저장공간 중에서의 데이터 어드 레스를 결정하는 단계; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하는 단계를 포함한다. A3: A1항에 따른 방법에 있어서, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판 단하는 단계는, 상기 디스크립터의 식별자에 따라, 명령 큐 중 상기 제1 처리 명령의 이전에 위치하면서, 피연산자에 상기 디스 크립터의 식별자를 구비한 처리 명령을 포함하는 처리가 완료되지 않은 제2 처리 명령이 존재하는지 여부를 판 단하는 단계; 제2 처리 명령이 존재하지 않을 경우, 상기 제1 처리 명령을 실행 가능한 것으로 결정하는 단계를 포함한다. A4: A3항에 따른 방법에 있어서, 상기 제1 처리 명령과 상기 제2 처리 명령 중의 적어도 하나는 디스크립터에 대한 쓰기 연산을 포함한다. A5: A1항에 따른 방법에 있어서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포함 하며, 그 중, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하는 단계는, 상기 적어도 하나의 디스크립터의 식별자에 따라, 각 디스크립터의 등록 상태 또는 미등록 상태를 포함하는 제1 상태를 각각 결정하는 단계; 각 디스크립터의 제1 상태가 모두 등록 상태인 경우, 상기 제1 처리 명령을 실행 가능한 것으로 결정하는 단계 를 포함한다.. A6: A1항에 따른 방법에 있어서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포함 하며, 그 중, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하는 단계는, 상기 적어도 하나의 디스크립터의 식별자에 따라, 각 디스크립터의 연산 가능 상태 또는 연산 불가 상태를 포함 하는 제2 상태를 각각 결정하는 단계; 각 디스크립터의 제2 상태가 모두 연산 가능 상태인 경우, 상기 제1 처리 명령을 실행 가능한 것으로 결정하는 단계를 포함한다. A7: A1-A6 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은 상기 제1 처리 명령이 디스크립터 취소 명령일 경우, 상기 제1 처리 명령 중 디스크립터의 식별자에 따라, 명령 큐 중에 위치하면서, 피연산자에 상기 디스크립터의 식별자를 포함하는 처리 명령인 처리가 완료되지 않은 제4 처리 명령이 존재하는지 여부를 판단하는 단계; 처리가 완료되지 않은 제4 처리 명령이 존재하지 않을 경우, 상기 제1 처리 명령을 실행하는 단계를 더 포함한 다. A8: A1-A7 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은, 상기 제1 처리 명령이 디스크립터 등록 명령일 경우, 상기 제1 처리 명령 중 디스크립터의 식별자, 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나를 포함하는 등록 파라미터를 획득하는 단계; 상기 디스크립터의 등록 파라미터에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하는 단계; 상기 제1 처리 명령이 실행 가능할 경우, 상기 제1 처리 명령을 실행하는 단계를 더 포함한다. A9: A8항에 따른 방법에 있어서, 상기 디스크립터의 등록 파라미터에 따라, 상기 제1 처리 명령의 실행 가능 여 부를 판단하는 단계는, 상기 디스크립터의 식별자가 점용되지 않았거나, 상기 디스크립터의 콘텐츠를 저장하는 제1 저장영역이 점용되 지 않았거나, 및 상기 디스크립터가 지시하는 텐서 데이터를 저장하는 제2 저장영역이 점용되지 않은 경우 중의 적어도 하나를 만족시킬 때, 상기 제1 처리 명령을 실행 가능한 것으로 결정하는 단계를 포함한다.A10: A1-A9 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은, 상기 제1 처리 명령을 실행할 수 없는 경우, 상기 제1 처리 명령을 차단하거나 또는 캐시하는 단계를 더 포함한 다. A11: A1항에 따른 방법에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것으로서, N 은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A12: A11항에 따른 방법에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되 며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터 를 포함한다. A13: A12항에 따른 방법에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터의 데이터 기준점 의 상기 텐서 데이터의 데이터 저장영역 중에서의 기준 어드레스를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 데이커 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터의 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 텐서 데이터의 저장영 역의 오프셋, N개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가 지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한다. A14: 데이터 처리장치에 있어서, 상기 장치는 디코딩된 제1 처리 명령의 피연산자에 텐서의 형상을 지시하기 위한 디스크립터의 식별자가 포함되어 있는 경우, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하기 위한 판단 모듈; 상기 제1 처리 명령이 실행 가능한 경우, 상기 디스크립터의 식별자에 따라, 상기 제1 처리 명령에 대응되는 데 이터 처리를 실행하기 위한 실행 모듈을 포함한다. A15: A14항에 따른 장치에 있어서, 상기 실행 모듈은, 상기 디스크립터의 식별자에 따라, 디스크립터 저장공간으로부터 상기 디스크립터의 콘텐츠를 획득하기 위한 콘 텐츠 획득 서브모듈; 상기 디스크립터의 콘텐츠에 따라, 상기 피연산자에 대응되는 데이터의 데이터 저장공간 중에서의 데이터 어드 레스를 결정하기 위한 어드레스 결정 모듈; 상기 데이터 어드레스에 따라, 상기 제1 처리 명령에 대응되는 데이터 처리를 실행하기 위한 제1 실행 서브모듈 을 포함한다. A16: A14항에 따른 장치에 있어서, 상기 판단 모듈은, 상기 디스크립터의 식별자에 따라, 명령 큐 중 상기 제1 처리 명령의 이전에 위치하면서, 피연산자에 상기 디스 크립터의 식별자를 구비한 처리 명령을 포함하는 처리가 완료되지 않은 제2 처리 명령이 존재하는지 여부를 판 단하기 위한 명령 판단 서브모듈; 제2 처리 명령이 존재하지 않을 경우, 상기 제1 처리 명령이 실행 가능한 것으로 결정하기 위한 제1 실행 결정 서브모듈을 포함한다. A17: A16항에 따른 장치에 있어서, 상기 제1 처리 명령과 상기 제2 처리 명령 중의 적어도 하나는 상기 디스크 립터에 대한 쓰기 연산을 포함한다. A18: A14항에 따른 장치에 있어서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포 함하며, 그 중, 상기 판단 모듈은, 상기 적어도 하나의 디스크립터의 식별자에 따라, 각 디스크립터의 등록 상태 또는 미등록 상태를 포함하는 제1 상태를 각각 결정하기 위한 제1 상태 결정 서브모듈; 각 디스크립터의 제1 상태가 모두 등록 상태인 경우, 상기 제1 처리 명령을 실행 가능한 것으로 결정하기 위한 제2 실행 결정 서브모듈을 포함한다. A19: A14항에 따른 장치에 있어서, 상기 제1 처리 명령의 피연산자는 적어도 하나의 디스크립터의 식별자를 포 함하며, 그 중, 상기 판단 모듈은, 상기 적어도 하나의 디스크립터의 식별자에 따라, 각 디스크립터의 연산 가능 상태 또는 연산 불가 상태를 포함 하는 제2 상태를 각각 결정하기 위한 제2 상태 결정 서브모듈; 각 디스크립터의 제2 상태가 모두 연산 가능 상태인 경우, 상기 제1 처리 명령을 실행 가능한 것으로 결정하기 위한 제3 실행 결정 서브모듈을 포함한다. A20: A14-A19 중의 어느 한 항에 있어서, 상기 장치는, 상기 제1 처리 명령이 디스크립터 취소 명령일 경우, 상기 제1 처리 명령 중 디스크립터의 식별자에 따라, 명령 큐 중에 위치하면서, 피연산자에 상기 디스크립터의 식별자를 포함하는 처리 명령인 처리가 완료되지 않은 제4 처리 명령이 존재하는지 여부를 판단하기 위한 취소 판단 모듈; 처리가 완료되지 않은 제4 처리 명령이 존재하지 않을 경우, 상기 제1 처리 명령을 실행하기 위한 취소 실행 모 듈을 더 포함한다. A21: A14-A20 중의 어느 한 항에 있어서, 상기 장치는, 상기 제1 처리 명령이 디스크립터 등록 명령일 경우, 상기 제1 처리 명령 중 디스크립터의 식별자, 텐서 형상 및 디스크립터가 지시하는 텐서 데이터의 콘텐츠 중의 적어도 하나를 포함하는 등록 파라미터를 획득하기 위한 파라미터 획득 모듈; 상기 디스크립터의 등록 파라미터에 따라, 상기 제1 처리 명령의 실행 가능 여부를 판단하기 위한 등록 판단 모 듈; 상기 제1 처리 명령이 실행 가능할 경우, 상기 제1 처리 명령을 실행하기 위한 등록 실행 모듈을 더 포함한다. A22: A21항에 따른 장치에 있어서, 상기 등록 판단 모듈은, 상기 디스크립터의 식별자가 점용되지 않은 경우, 상기 디스크립터의 콘텐츠를 저장하는 제1 저장영역이 점용되 지 않은 경우, 및 상기 디스크립터가 지시하는 텐서 데이터를 저장하는 제2 저장영역이 점용되지 않은 경우 중 의 적어도 하나를 만족시킬 때, 상기 제1 처리 명령을 실행 가능한 것으로 결정하기 위한 조건 판단 서브모듈을 포함한다. A23: A14-A22 중의 어느 한 항에 있어서, 상기 장치는, 상기 제1 처리 명령을 실행할 수 없는 경우, 상기 제1 처리 명령을 차단하거나 또는 캐시하기 위한 실행 제어모 듈을 더 포함한다. A24: A14항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 형상을 지시하기 위한 것으로서, N은 0 이상의 정수이며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 형상을 나타내는 적어도 하나의 형상 파라미터를 포함한다. A25: A24항에 따른 장치에 있어서, 상기 디스크립터는 N차원의 텐서 데이터의 어드레스를 지시하는데 더 사용되 며, 그 중, 상기 디스크립터의 콘텐츠는 텐서 데이터의 어드레스를 나타내는 적어도 하나의 어드레스 파라미터 를 포함한다. A26: A25항에 따른 장치에 있어서, 상기 텐서 데이터의 어드레스 파라미터는 상기 디스크립터 데이터 기준점의 상기 텐서 데이터의 데이터 저장영역 중에서의 기준 어드레스를 포함하며; 그 중, 상기 텐서 데이터의 형상 파라미터는, N개 차원 방향의 적어도 한 방향상에서의 상기 데이터 저장공간의 크기, N개 차원 방향의 적어도 한 방향상에서 의 상기 텐서 데이터의 저장영역의 크기, N개 차원 방향의 적어도 한 방향상에서의 상기 저장영역의 오프셋, N 개 차원 방향의 대각 위치에 놓이는 적어도 두 꼭지점의 상기 데이터 기준점에 대한 위치, 상기 디스크립터가지시하는 텐서 데이터의 데이터 디스크립션 위치와 데이터 어드레스 간의 매핑 관계 중의 적어도 하나를 포함한 다. A27: 인공지는 칩에 있어서, 상기 칩은 A14-A26 중의 어느 한 항에 따른 상기 데이터 처리장치를 포함한다. A28: 전자장치에 있어서, 상기 전자장치는 A27항에 따른 인공지능 칩을 포함한다. A29: 보드에 있어서, 상기 보드는 메모리 소자, 인터페이스 장치와 제어 소자 및 상기 인공지능 칩을 포함하며; 그 중, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터링하기 위한 것이다. A30: A29항에 따른 보드에 있어서, 상기 메모리 소자는 다수 그룹의 저장유닛을 포함하며, 각 그룹의 상기 저장 유닛은 버스를 통해 상기 인공지능 칩과 연결되고, 상기 저장유닛은 DDR SDRAM이며; 상기 칩은 각각의 상기 저장유닛의 데이터 전송과 데이터 저장을 제어하기 위한 DDR 컨트롤러를 포함하고; 상기 인터페이스 장치는 표준 PCIE 인터페이스이다. 인공지능 기술이 지속적으로 발전함에 따라, 처리해야 할 데이터량과 데이터 차원이 모두 지속적으로 커지고 있 다. 관련 기술에서, 다수의 연산이 동일한 저장영역에 대해 연산을 수행 시, 앞줄의 연산이 완료되어야만, 다음 줄의 연산을 실행할 수 있어, 프로세서의 처리 효율이 저하된다. 본 발명의 실시예에 따르면, 프로세서 연산 방법을 제공한다. 도 1g는 본 발명의 실시예에 따른 프로세서 연산방법의 흐름도이다. 상기 프로세서 연산방법은 프로세서에 응용 될 수 있다. 도 1g에 도시된 바와 같이, 상기 프로세서 연산방법은 이하 단계를 포함한다: 단계 S11g: 제1 연산이 적어도 하나의 파인-그레인드 영역을 포함하는 타겟 저장영역에 대한 연산인 경우, 상기 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단한다. 그 중, 제1 연산은 읽기 연산 또는 쓰기 연산일 수 있고, 유사하게, 제2 연산 역시 읽기 연산 또는 쓰기 연산일 수 있다. 본 발명은 제1 연산과 제2 연산의 구체적인 유형에 대해 한정하지 않는다. 하나의 연산은 하나 또는 다수의 피연산자를 포함할 수 있다. 타겟 저장영역은 제1 연산과 제2 연산의 하나 또는 다수의 피연산자에 대응 되는 저장영역일 수 있다. 타겟 저장영역이 소재하는 전체 저장영역은 프로세서의 내부 메모리(예를 들어 온칩 캐시 또는 레지스터 등)일 수도 있고, 프로세서에 연결되는 외부 메모리(예를 들어 오프칩 메모리 등)일 수도 있다. 일종의 가능한 구현 방식에서, 제1 연산 및/또는 제2 연산은 하나 또는 다수의 피연산자를 포함할 수 있으며, 타겟 저장영역은 제1 연산과 제2 연산 중의 임의의 피연산자에 대응되는 저장영역일 수 있다. 타겟 저장영역은 제1 연산 중의 적어도 하나의 피연산자와 제2 연산 중의 적어도 하나의 피연산자에 공동으로 대응되는 저장영역 이다. 예를 들어, 제1 연산 중의 제1 피연산자와 제2 연산 중의 제2 피연산자의 경우, 제1 피연산자는 제1 연산 중의 임의의 피연산자일 수 있고, 제2 피연산자는 제2 연산 중의 임의의 피연산자일 수 있다. 제1 피연산자와 제2 피연산자가 동일한 피연산자인 경우, 타겟 저장영역은 제1 피연산자의 저장영역 또는 제2 피연산자의 저장 영역일 수 있다. 제1 피연산자의 저장영역과 제2 피연산자의 저장영역에 중첩 영역이 있는 경우, 타겟 저장영역 은 중첩 영역이다. 일종의 가능한 구현 방식에서, 타겟 저장영역은 적어도 하나의 파인-그레인드 영역을 포함한다. 그 중, 파인-그 레인드 영역의 크기 및/또는 수량의 결정 방식은, 하드웨어 설계에 따라 결정하는 방식, 타겟 피연산자의 관련 연산에 따라 결정하는 방식, 연산 중 관련 파라미터에 따라 정의하는 방식 중의 하나 또는 임의의 조합을 포함 할 수 있다. 그 중 하드웨어 설계에 따라 결정하는 방식은, 즉 하드웨어 설계시 파인-그레인드 영역의 크기를 결정하는 것으로서, 예컨대 저장영역의 1행 또는 다수 행을 하나의 파인-그레인드 영역으로 결정한다. 타겟 피 연산자의 관련 연산에 따라 결정하는 방식은, 타겟 피연산자의 처리 요구, 저장방식, 또는 전송방식 등에 따라 결정하는 방식을 포함하며, 예를 들어, 타겟 피연산자가 하나의 2차원 매트릭스 데이터라면, 그 규모는 M*N(M,N는 모두 양의 정수)이며, 저장하는데 차지하는 바이트 수, 즉 1행은 M바이트이고, 총 N행이 있음을 나타내며, M바이트를 하나의 파인-그레인드 영역으로 결정할 수 있다. 상기 타겟 피연산자에 대응되는 타겟 저장영역은 N 개의 파인-그레인드 영역을 포함한다. 연산 중 관련 파라미터에 따라 정의하는 방식은, 연산에 수반되는 파인- 그레인드의 크기 및/또는 수량에 따라, 타겟 저장영역을 다수의 파인-그레인드 영역으로 분할하는 방식을 포함 한다. 제1 연산 중의 제1 피연산자와 제2 연산 중의 제2 피연산자가 이 타겟 저장영역에 공동으로 대응될 경우, 제1 연산과 제2 연산은 타겟 저장영역 중 분할된 다수의 파인-그레인드 영역에 따라, 본 발명의 실시예의 방법 을 채택할 수 있다. 설명해두어야 할 점으로, 다수의 파인-그레인드 영역의 크기는 동일할 수도 있고 다를 수도 있다. 예를 들어, 제1 연산은 제1 파인-그레인드의 크기(각 파인-그레인드 영역의 데이터 비트수)를 수반할 수 있고, 상기 제1 파 인-그레인드의 크기는 64비트로 설정할 수 있으며, 제2 연산은 제2 파인-그레인드의 크기(각 파인-그레인드 영 역의 데이터 비트수)를 수반할 수 있고, 상기 제2 파인-그레인드의 크기는 256비트로 설정할 수 있다. 즉 제1 연산을 실행 시, 각 64비트를 하나의 파인-그레인드 영역으로 하고, 제2 연산을 실행 시, 각 256비트를 하나의 파인-그레인드 영역으로 한다. 또한, 제1 연산과 제2 연산이 수반하는 파인-그레인드의 크기(예를 들어 각 파인 -그레인드 영역의 데이터 비트수)는 모두 512비트이다. 마찬가지로, 제1 연산은 제1 파인-그레인드의 수량(예를 들어 4개로 설정)을 수반할 수 있고, 제2 연산은 제2 파인-그레인드의 수량(예를 들어 8개로 설정)을 수반할 수 있다. 즉 제1 연산을 실행 시, 타겟 저장영역을 4개의 파인-그레인드 영역으로 분할하고, 제2 연산을 실행 시, 타겟 저장영역을 8개의 파인-그레인드 영역으로 분할한다. 연산 중 파인-그레인드의 크기, 수량 두 파라미터를 동시에 수반할 수도 있음을 이해할 수 있을 것이다. 필요에 따라 각 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역의 점용 상태를 통해, 상기 타겟 저장영역에 대해 실행되고 있는 제2 연산이 존재하는지 여부를 판단할 수 있다. 예를 들어, 프로세서는 점용 상태 테이블 조회를 통해 타 겟 저장영역의 점용 여부를 판단할 수 있으며, 점용되고 있다면, 즉 판단 결과는 상기 타겟 저장영역에 대해 실 행되고 있는 제2 연산이 존재한다는 것이다. 그 중, 상기 점용 상태 테이블은 메모리에 미리 설치되어 저장될 수도 있고, 프로세서가 어떤 임무를 실행하기 시작하기 전에 생성되고, 상기 임무가 완료된 후 취소되는 것일 수도 있다. 각 저장영역의 점용 상태에 변화가 발생 시, 프로세서는 상기 점용 상태 테이블의 내용을 업데이트 하여, 각 저장영역의 점용상태를 기록한다. 일종의 가능한 구현 방식에서, 각 연산의 실행 상태 조회를 통해 타겟 저장영역에 대해 실행되고 있는 제2 연산 이 존재하는지 여부를 판단할 수 있다. 예를 들어, 각 연산의 피연산자에 대응되는 저장영역을 기록하고, 각 연 산의 실행 상태를 기록할 수 있다. 타겟 저장영역에 대한 연산이 완료되지 않은 실행 상태라면, 즉 판단 결과는 타겟 저장영역에 대해 실행되고 있는 제2 연산이 존재하는 것이다. 피연산자의 점용 상태 판단을 통해서도, 피 연산자에 대응되는 타겟 저장영역이 점용되고 있는지 여부를 결정하여, 상기 타겟 저장영역에 대해 실행되고 있 는 제2 연산이 존재하는지 여부를 결정할 수 있다. 본 발명은 타겟 저장영역에 대해 실행되고 있는 제2 연산이 존재하는지 여부를 판단하는 판단 근거에 대해 한정하지 않는다. 일종의 가능한 구현 방식에서, 타겟 저장영역에 대한 제1 연산을 실행하기 전, 타겟 저장영역에 대해 실행되고 있는 제2 연산이 존재하는지 여부를 판단할 수 있다. 일종의 가능한 구현 방식에서, 제1 연산의 타겟 저장영역에 대한 실행 과정에서도 타겟 저장영역에 대해 실행되 고 있는 제2 연산이 존재하는지 여부를 판단할 수 있다. 단계 S12g: 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 상기 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역 사이의 중첩 여부를 판단한다. 제1 파인-그레인드 영역과 제2 파인-그레인드 영역은 타겟 저장영역 중 다수의 파인-그레인드 영역 중의 임의의 파인-그레인드 영역일 수 있다. 타겟 저장영역에 대한 연산은 즉 타겟 저장영역 중 각 파인-그레인드 영역에 대 한 연산임을 이해할 수 있을 것이다. 예를 들어 타겟 저장영역 A가 제1행 내지 제10행이면, 각 1행은 하나의 파 인-그레인드 영역이고, 타겟 저장영역 A는 10개의 파인-그레인드 영역을 포함한다. 타겟 저장영역 A에 대한 쓰 기 연산은 이 10개의 파인-그레인드 영역에 대한 쓰기 연산으로 간주할 수 있다. 그 실행 과정은, 첫 번째 파인 -그레인드 영역(제1행)을 쓰고, 첫 번째 파인-그레인드 영역의 쓰기가 완료된 후, 두 번째 파인-그레인드 영역 (제2행)을 쓰며, 두 번째 파인-그레인드 영역의 쓰기가 완료된 후 세 번째 파인-그레인드 영역(제3행)을 쓰며, 이와 같이 유추하여, 열 번째 파인-그레인드 영역(제10행)까지 쓰기를 완료하면, 타겟 저장영역 A의 쓰기 연산 이 완료된다.타겟 저장영역에 대한 연산이 존재 시, 연산이 실행됨에 따라, 타겟 저장영역 중의 파인-그레인드 영역의 상태 는 이미 연산이 완료된 상태, 연산이 진행 중인 상태와 미연산 상태를 포함할 수 있다. 연산이 현재 대상으로 하는 파인-그레인드 영역의 상태는 연산이 진행 중인 상태이다. 이에 따라, 타겟 저장영역에 대한 연산이 존재 시, 타겟 저장영역 중의 하나의 파인-그레인드 영역에 대한 연산이 존재하는 것으로 여길 수 있으며, 연산되고 있는 파인-그레인드 영역이 즉, 연산이 현재 대상으로 하는 파인-그레인드 영역이다. 일종의 가능한 구현 방식에서, 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역은, 실행할 제1 연산이 대상으로 하는 파인-그레인드 영역, 통상적으로는 첫 번째 파인-그레인드 영역을 포함할 수 있고, 실행 중인 제 1 연산이 현재 대상으로 하는 파인-그레인드 영역을 포함할 수도 있으며, 어느 하나의 파인-그레인드 영역일 수 도 있다. 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역은 실행 중인 제2 연산이 현재 대상으로 하는 파인-그레인드 영역일 수 있으며, 어느 하나의 파인-그레인드 영역일 수 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역에 대한 제1 연산을 실행하기 전, 타겟 저장영역에 대해 실행 중인 제2 연산이 존재하는지 여부를 판단 시, 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역은, 제1 연산이 실행할 파인-그레인드 영역이다. 예를 들어, 타겟 저장영역에 대한 제1 연산을 실행하기 전, 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역은 통상적으로 타겟 저장영역의 첫 번째 파인-그레인드 영역이다. 이때, 제1 연산은 아직 제1 파인-그레인드 영역에 대해 연산을 실행하지 않은 상태이다. 실행 중인 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역은, 제2 연산의 실행 진도와 관련이 있을 수 있다. 만약 제2 연산 역시 막 실행이 시작되었다면, 즉 제2 파인-그레인드 영역 역시 타겟 저장영역의 첫 번째 파인-그레인드 영역일 수 있다. 이때, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역은 중첩된다. 제2 연산이 첫 번째 파인-그레인드 영역의 연산을 완료하여, 현재 대상으로 하는 제2 파인-그레인드 영역은 제P번째 파인-그레인드 영역(P는 1보다 큰 정수)이면, 즉 제1 파인-그레인드 영역과 제2 파인-그레인드 영역은 중첩되지 않는다. 일종의 가능한 구현 방식에서, 제1 연산의 타겟 저장영역에 대한 연산 과정에서, 타겟 저장영역에 대해 진행 중 인 제2 연산이 존재하는지 여부를 판단 시, 제1 연산의 실행 진도에 따라 제1 파인-그레인드 영역을 결정하고, 제2 연산의 실행 진도에 따라 제2 파인-그레인드 영역을 결정하며, 나아가 제1 파인-그레인드 영역과 제2 파인- 그레인드 영역의 중첩 여부를 판단할 수 있다. 일종의 가능한 구현 방식에서, 만약 각 연산을 실행하는 과정의 속도가 일치하면, 타겟 저장영역에 대한 제1 연 산을 실행하기 전에만 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단하고, 제1 파인-그레 인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 판단할 수 있다. 그 중, 속도가 일치한다 함은 파인-그레인 드 영역의 크기가 동일한 경우, 2개의 연산이 하나의 파인-그레인드 영역에 대해 실행하는 연산 시간이 동일함 을 의미한다. 일종의 가능한 구현 방식에서, 만약 각 연산을 실행하는 과정의 속도가 일치하지 않거나 또는 일치 여부를 결정 할 수 없는 경우, 제1 연산이 타겟 저장영역에 대해 연산을 실행하는 과정에서, 현재 대상으로 하는 제1 파인- 그레인드 영역에 대한 연산을 완료할 때마다, 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 계속 판단하고, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 계속 판단함으로써, 제1 연산 을 계속 실행할 수 있는지 여부를 결정한다. 일종의 가능한 구현 방식에서, 물리 어드레스, 포인터 위치, 파인-그레인드 영역 식별자 등에 따라, 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역 간의 중 첩 여부를 판단할 수 있다. 예를 들어, 각 연산의 현재 물리 어드레스를 기록할 수 있으며, 제1 연산의 현재의 물리 어드레스 및 제2 연산의 현재의 물리 어드레스, 및 물리 어드레스와 파인-그레인드 영역 간의 대응관계에 따라, 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 제2 연산이 현재 대상으로 하는 제2 파인-그레 인드 영역을 각각 결정하고, 나아가 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 판단할 수 있다. 물리 어드레스는 파인-그레인드 영역의 시작 어드레스, 종료 어드레스, 설정위치의 어드레스 또는 실 시간 연산 어드레스 중의 하나 또는 임의의 조합을 포함할 수 있다. 또한, 각 연산에 포인터를 설치할 수 있으 며, 포인터는 연산이 현재 대상으로 하는 파인-그레인드 영역을 가리킨다. 제1 연산의 포인터 위치와 제2 연산 의 포인터 위치에 따라 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 제2 연산이 현재 대상으로 하 는 제2 파인-그레인드 영역을 각각 결정하고, 나아가 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 판단할 수 있다. 또한 예를 들어, 각 파인-그레인드 영역에 식별자를 설치할 수도 있으며, 연산이 현재 대상으로 하는 파인-그레인드 영역의 식별자를 기록함으로써 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 의 중첩 여부를 판단할 수 있다. 식별자는 알파벳, 숫자 또는 부호의 임의의 조합을 포함할 수 있다. 또한 기타방식을 통해 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 판단할 수도 있으며, 본 발명은 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간의 중첩 여부의 판단 근거에 대해 제한을 두지 않는다. 단계 S13g: 상기 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간이 중첩되지 않을 경우, 상기 제1 연산을 실행한다. 일종의 가능한 구현 방식에서, 만약 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역이 중첩되지 않으면, 즉 제1 파인-그레인드 영역은 제2 연산이 이미 연산 을 완료한 파인-그레인드 영역일 수도 있고, 제2 연산이 연산을 수행할 필요가 없는 파인-그레인드 영역일 수도 있으며, 이때 제1 연산을 실행하더라도 제2 연산에 대한 연산 과정 및 연산 결과에 영향을 미치지 않아, 제1 연 산을 실행할 수 있다. 본 실시예에 따르면, 제1 연산이 대상으로 하는 타겟 저장영역에 적어도 하나의 파인-그레인드 영역이 포함되고, 또한 타겟 저장영역에 대해 실행 중인 제2 연산이 존재 시, 제1 연산이 현재 대상으로 하는 제1 파인 -그레인드 영역과 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역 사이의 중첩 여부를 판단할 수 있으 며, 양자가 중첩되지 않을 때, 제1 연산을 실행한다. 이와 같이 하면, 제1 연산과 제2 연산은 현재 연산하는 파 인-그레인드 영역에 중첩이 없으면 즉시 실행 가능하므로, 제1 연산과 제2 연산이 동시에 타겟 저장영역에 대해 연산을 수행하도록 함으로써, 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 방법은, 상기 제1 파인-그레인드 영역과 제2 파인-그레인드 영역에 중첩이 있는 경우, 상기 제1 연산을 차단하는 단계를 더 포함할 수 있다. 일종의 가능한 구현 방식에서, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩은, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 완전 중첩 또는 부분 중첩을 포함한다. 제1 파인-그레인드 영역과 제2 파인- 그레인드 영역이 중첩 시, 제1 연산을 실행한다면, 즉 제1 연산은 중첩 부분의 영역에 대한 연산으로서, 제2 연 산의 실행에 영향을 미쳐 제2 연산의 연산 결과가 부정확해질 수도 있고, 제1 연산의 실행에 영향을 미쳐 제1 연산의 연산 결과가 부정확해질 수도 있다. 이때, 제1 연산을 차단하여, 즉 제1 연산의 실행을 임시 정지시킬 수 있으며, 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역에 대한 연산을 완료한 후, 제1 연산을 실행 할 수 있다. 즉 제1 파인-그레인드 영역과 제2 파인-그레인드 영역이 중첩되지 않을 때 제1 연산을 실행한다. 본 실시예에서, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역이 중첩 시, 제1 연산을 차단하여, 각 연산의 파인-그레인드 영역의 중첩으로 인한 연산 에러, 연산 결과의 부정확성을 피하고, 각 연산의 정확성을 보장할 수 있다. 도 5a와 도 5b는 본 발명의 실시예에 따른 프로세서 연산 방법의 응용 시나리오 설명도이다. 도 5a와 도 5b에 도시된 바와 같이, 전체 저장영역(20d)은 타겟 저장영역(21d)을 포함하며, 그 중, 타겟 저장영역(21d)은 4개의 파인-그레인드 영역으로 분할되며, 순차적으로 파인-그레인드 영역(22d), 파인-그레인드 영역(23d), 파인-그레 인드 영역(24d)과 파인-그레인드 영역(25d)이다. 도 5a에 도시된 바와 같이, 현재 쓰기 연산만 포함한다면, 쓰기 포인터(wp)로 쓰기 연산이 현재 대상으로 하는 파인-그레인드 영역을 표시한다. 쓰기 연산을 막 시작할 때, 쓰기 포인터(wp)는 파인-그레인드 영역(22d)을 가 리키며, 먼저 타겟 저장영역(21d)에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단할 수 있다. 만약 판단 결과 제2 연산이 존재하지 않는다면, 즉 파인-그레인드 영역(22d)에 대한 쓰기 연산을 시작하고; 파인-그레인드 영역(22d)에 대한 쓰기 연산이 완료된 후, 쓰기 포인터(wp)가 증가되어, 즉 wp++이며, 다음 파인-그레인드 영역 (23d)을 가리킨다. 동일한 판단을 수행한 후, 파인-그레인드 영역(23d)에 대한 쓰기 연산을 시작하며, 파인-그 레인드 영역(23d)에 대한 쓰기 연산이 완료된 후, 쓰기 포인터(wp)가 증가하여, 다음 파인-그레인드 영역(24d) 을 가리키고, 동일한 판단을 수행한 후, 파인-그레인드 영역(24d)에 대한 쓰기 연산을 시작한다. 또한 도 5b에 도시된 바와 같이, 현재 2개의 연산인 읽기 연산과 쓰기 연산을 포함하며, 그 중 읽기 연산은 제1 연산이고, 쓰기 연산은 제2 연산이다. 또한 쓰기 연산의 쓰기 포인터(wp)와 읽기 연산의 읽기 포인터(rp)로 쓰 기 연산과 읽기 연산이 현재 대상으로 하는 파인-그레인드 영역을 표시한다. 읽기 연산(제1 연산)을 실행 시, 타겟 저장영역(21d)에 대해 진행되고 있는 제2 연산이 존재하는지 여부를 판단 한다. 판단을 통해, 현재 제2 연산인 쓰기 연산이 존재하면, 읽기 연산(제1 연산)이 현재 대상으로 하는 제1 파 인-그레인드 영역(도 5b 중의 파인-그레인드 영역(22d))과 쓰기 연산(제2 연산)이 현재 대상으로 하는 제2 파인 -그레인드 영역(도 5b 중의 파인-그레인드 영역(24d)) 간의 중첩 여부를 더 판단한다. 예를 들어 파인-그레인드 영역의 번호(22d와 24d), 또는 rp와 wp 간의 관계(rp=0，wp=2，rp<wp)에 따라, 제1 파인-그레인드 영역과 제2파인-그레인드 영역 사이가 중첩되지 않는 것을 결정한 후, 읽기 연산(제1 연산)을 실행할 수 있다. 파인-그레인드 영역(22d)에 대한 읽기 연산이 완료된 후, rp가 증가하여, 즉 rp++이고, 다음 파인-그레인드 영 역(23d)을 가리키며, 동일한 판단을 수행한 후, 제1 연산이 파인-그레인드 영역(23d)에 대한 연산을 시작한다. 파인-그레인드 영역(23d)에 대한 읽기 연산이 완료된 후, rp가 증가하여 다음 파인-그레인드 영역(24d)을 가리 킨다. 이러한 경우, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간의 중첩 여부를 계속 판단하며, 파인- 그레인드 영역의 번호가 동일하거나 또는 포인터가 rp=wp라면, 즉 제1 연산이 현재 대상으로 하는 제1 파인-그 레인드 영역과 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역이 중첩된다고 판단할 수 있으며, 즉 제1 연산을 실행할 수 없어, 제1 연산을 차단한다. 제2 연산이 파인-그레인드 영역(24d)에 대한 연산을 완료한 후, wp가 증가하여, 다음 파인-그레인드 영역(25d)을 가리킬 때, rp<wp이며, 제1 연산을 실행할 수 있다. 일종의 가능한 구현 방식에서, 상기 제1 연산과 상기 제2 연산 중의 적어도 하나의 연산은 쓰기 연산일 수 있다. 즉, 타겟 데이터에 대한 연산이 쓰기 후 읽기(제2 연산은 쓰기 연산이고, 제1 연산은 읽기 연산이다), 읽 기 후 쓰기(제2 연산은 읽기 연산이고, 제1 연산은 쓰기 연산이다) 또는 쓰기 후 쓰기(제2 연산과 제1 연산은 모두 쓰기 연산이다)일 때, 본 발명의 실시예 중의 방법을 사용할 수 있다. 예를 들어, 제1 연산이 읽기 연산이고, 제2 연산은 쓰기 연산이면, 제1 연산이 독취해야 할 타겟 피연산자는 제 2 연산인 쓰기 연산 이후의 데이터여야 하고, 제2 연산이 대상으로 하는 제2 파인-그레인드 영역의 번호가 8이 면, 즉 제1 연산은 번호가 8 이전인 파인-그레인드 영역의 데이터만 독취할 수 있다. 다시 말해, 만약 제1 연산 이 현재 대상으로 하는 제1 파인-그레인드 영역이 번호가 1~7인 파인-그레인드 영역 중의 어느 하나이면, 즉 제 1 연산을 실행할 수 있다. 일종의 가능한 구현 방식에서, 만약 제1 연산과 제2 연산이 모두 읽기 연산이면, 제1 연산과 제2 연산의 파인- 그레인드 영역 간의 관계는 연산 결과에 영향을 미치지 않아 본 발명의 실시예 중의 방법을 사용할 수 있으며, 파인-그레인드 영역의 판단 없이 직접 제1 연산을 직접 실행할 수 있다. 본 실시예에서, 제1 연산과 제2 연산 중의 적어도 하나의 연산이 쓰기 연산일 경우, 본 발명의 실시예 중의 방 법을 사용하여, 타겟 저장영역을 하나 또는 다수의 파인-그레인드 영역으로 분할하고, 파인-그레인드 영역을 단 위로 연산을 실행함으로써, 읽기 후 쓰기, 쓰기 후 읽기, 쓰기 후 쓰기 등 연산을 정확하게 실행할 수 있어, 정 확한 실행 결과를 획득할 수 있으며, 또한 연산 간의 대기 시간을 단축시킬 수도 있어, 프로세서의 실행 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 설정 길이의 데이터 소재 영역, 설정 차원의 데이터 소재 영역 중의 적어도 하나에 따라 결정할 수 있다. 상기 파인-그레인드 영역의 크기 및/또는 수량 결정은 연산이 생성되기 전 미리 설정된 것일 수도 있고, 매 줄 의 연산이 생성 시 실시간으로 결정되는 것일 수도 있다는 점을 이해할 수 있다. 그 중, 연산 전 파인-그레인드 영역의 크기 및/또는 수량을 미리 설정하는 방법은, 길이를 미리 설정하는 데이터가 소재하는 영역, 차원을 미 리 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라, 파인-그레인드 영역의 크기 및/또는 수량을 결 정하는 것을 포함할 수 있다. 길이를 설정하는 데이터와 차원을 설정하는 데이터는 각 연산의 피연산자와 무관 할 수도 있고, 미리 각 연산의 피연산자에 따라 종합적으로 결정할 수도 있으며, 필요에 따라 결정할 수도 있다. 각 줄의 연산이 생성될 때 실시간으로 파인-그레인드 영역의 크기 및/또는 수량을 결정하는 방법은 각 연 산의 피연산자에 따라, 길이를 설정하는 데이터 또는 차원을 설정하는 데이터를 결정하는 것을 포함할 수 있으 며, 즉 각 연산의 피연산자의 차이에 따라, 길이를 설정하는 데이터가 소재하는 영역, 차원을 설정하는 데이터 가 소재하는 영역 중의 적어도 하나를 실시간으로 결정하여, 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있다. 예를 들어 설명하면, 길이를 설정하는 데이터가 소재하는 영역의 크기에 따라, 파인-그레인드 영역의 크기 및/ 또는 수량을 결정할 수 있다. 예를 들어 타겟 피연산자 중 길이를 설정하는 데이터가 소재하는 영역의 크기에 따라, 파인-그레인드 영역의 크기를 설정할 수 있으며, 상기 영역은 고정된 비트폭일 수 있다. 예를 들어, 타겟 피연산자 B는 20*10*5인 3차원 데이터이고, 그것이 타겟 저장영역에 저장되는 방식은 40*25(즉 매 행마다 40비 트의 데이터로, 총 25행)이면, 즉 설정 길이를 40비트로 설정하고, 타겟 저장영역의 각 1행을 하나의 파인-그레 인드 영역으로 설정할 수 있으며, 타겟 피연산자 B의 저장영역은 25개의 파인-그레인드 영역으로 분할할 수 있 다. 저장영역의 각 5행마다 하나의 파인-그레인드 영역으로 설정할 수도 있으며, 타겟 피연산자 B의 저장영역은 5개의 파인-그레인드 영역으로 분할할 수 있다. 본 발명은 이에 대해 제한을 두지 않는다.길이를 설정하는 데이터가 소재하는 영역, 차원을 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라, 타겟 저장영역에서 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수도 있고, 타겟 저장영역이 소재하는 전 체 저장영역에서 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수도 있으며, 전체 저장영역 중의 기타 영 역에서도 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있음을 이해할 수 있을 것이다. 상기 예시는 단 지 그 중 하나의 상황을 제공하는 것일 뿐이며, 본 발명은 길이를 설정하는 데이터가 소재하는 영역, 차원을 설 정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라, 파인-그레인드 영역의 크기 및/또는 수량을 결정하는 적용 분할 범위를 한정하지 않는다. 일종의 가능한 구현 방식에서, 차원을 설정하는 데이터가 소재하는 영역의 크기에 따라, 파인-그레인드 영역의 크기 및/또는 수량을 더 결정할 수 있다. 예를 들어, 타겟 피연산자 C는 20*10인 2차원 데이터이며, 설정 차원 수가 1차원이고, 길이가 20인 데이터에 따라, 타겟 피연산자 C의 저장영역을 10개의 파인-그레인드 영역으로 분 할할 수 있다. 또한, 타겟 피연산자의 저장영역 중 길이를 설정하는 데이터가 소재하는 영역의 크기 및 차원을 설정하는 데이 터가 소재하는 영역의 크기에 따라, 파인-그레인드 영역의 크기 및/또는 수량을 동시에 결정할 수도 있다. 예를 들어, 타겟 피연산자 C에 대하여, 설정 차원이 2차원이고, 크기가 4*2인 데이터에 따라 파인-그레인드 영역을 분할함으로써, 타겟 피연산자 C의 저장영역을 25개의 파인-그레인드 영역으로 분할할 수 있다. 당업자라면 실제 상황에 따라 파인-그레인드 영역을 분할하는 크기 및/또는 수량을 설정할 수 있음을 이해하여 야 하며, 본 발명은 이에 대해 제한을 두지 않는다. 본 실시예에서, 길이를 설정하는 데이터가 소재하는 영역의 크기 및/또는 차원을 설정하는 데이터가 소재하는 영역의 크기에 따라, 상기 파인-그레인드 영역의 크기 및/또는 수량을 결정함으로써, 데이터 특성에 따라 파인- 그레인드 영역에 대한 분할을 완료할 수 있어, 파인-그레인드 영역 분할의 유연성을 향상시킬 수 있으며, 따라 서 다중 연산의 실행 효율이 향상되고, 파인-그레인드 영역의 분할 결과가 상이한 피연산자 특성에 더욱 부합될 수 있어, 상이한 유형의 피연산자의 처리 요구에 적응할 수 있으며, 다중 연산의 전체적인 실행 효율이 더욱 향 상된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 하드웨어의 계산 능력, 하드웨 어의 대역폭 중의 적어도 하나에 따라 결정될 수 있다. 그 중, 하드웨어의 계산 능력은 하드웨어가 하나의 계산 주기 내에 병행 처리하는 데이터량일 수 있고, 하드웨 어 대역폭은 데이터 전송 능력, 예를 들어 단위시간 내에 전송하는 데이터량일 수 있다. 예를 들어 설명하면, 상기 프로세서 연산 방법을 응용한 프로세서에서, 그 하드웨어 계산 능력이 하나의 계산 주기 내에 100비트의 데이터를 병행 처리하고, 하드웨어 대역폭은 단위시간 내에 200비트의 데이터를 전송한다 면, 크기가 1000비트인 타겟 저장영역의 경우, 하드웨어 계산 능력에 따라 상기 타겟 저장영역을 10개의 파인- 그레인드 영역으로 분할할 수 있으며, 그 중 각 파인-그레인드 영역은 100비트의 데이터를 포함한다. 하드웨어 대역폭에 따라 상기 타겟 저장영역을 5개의 파인-그레인드 영역으로 분할할 수도 있으며, 그 중 각 파인-그레인 드 영역은 200비트의 데이터를 포함한다. 하드웨어의 계산 능력, 하드웨어의 대역폭은 프로세서 하드웨어마다 다르다는 것을 이해하여야 하며, 본 발명은 하드웨어의 계산 능력, 하드웨어의 대역폭에 대해 제한을 두지 않는다. 하드웨어의 계산 능력, 하드웨어의 대역폭 중의 적어도 하나에 따라, 타겟 저장영역에서 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수도 있고, 타겟 저장영역이 소재하는 전체 저장영역에서 파인-그레인드 영역의 크 기 및/또는 수량을 결정할 수도 있으며, 및 전체 저장영역 중의 기타 영역에서 파인-그레인드 영역의 크기 및/ 또는 수량을 결정할 수도 있음을 이해할 수 있을 것이다. 상기 예시는 단지 그 중의 한 가지 상황만 제공한 것 일 뿐 본 발명은 하드웨어의 계산 능력, 하드웨어의 대역폭 중의 적어도 하나에 따라, 파인-그레인드 영역의 크 기 및/또는 수량을 결정하는 적용 분할 범위를 한정하지 않는다. 이러한 방식을 통해, 프로세서의 처리 능력(하드웨어의 계산 능력 및/또는 하드웨어의 대역폭)에 따라 상기 파 인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있어, 파인-그레인드 영역의 분할 결과가 각기 다른 하드웨 어 사용 환경의 요구에 더욱 부합될 수 있으며, 파인-그레인드 영역에서 실행되는 연산과 프로세서의 처리 능력 이 동기화됨으로써, 하드웨어의 실행 효율이 최대한으로 발휘될 수 있어, 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 제1 연산은 제1 처리 명령 중의 연산일 수 있고, 상기 제2 연산은 제2 처리 명령 중의 연산일 수 있으며, 상기 제2 처리 명령은 명령 큐 중 상기 제1 처리 명령 이전의 처리 명령이다. 그 중, 제1 처리 명령과 제2 처리 명령은 데이터 액세스 명령, 연산 명령, 동기화 명령 및 통신 명령 등의 하나 이상을 포함할 수 있으며, 예컨대 상기 명령은 읽기이면서 연산 명령이다. 본 발명은 제1 처리 명령과 제2 처리 명령의 구체적인 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제1 명령은 제2 명령과 의존관계를 가지며, 예를 들어 제1 명령은 제2 명령의 계 산 결과를 사용해야 하는 등의 의존관계다. 제1 명령은 제2 명령과 의존관계가 없을 수도 있다. 제1 명령과 제2 명령이 의존관계인 경우, 본 발명의 실시예 중의 방법을 통해, 제1 명령과 제2 명령을 병행 실행할 수 있다. 본 실시예에서, 제1 연산과 제2 연산은 상이한 명령 중의 연산일 수 있으며, 본 발명의 실시예 중의 방법을 이 용하면 명령 실행 효율이 향상될 수 있다. 일종의 가능한 구현 방식에서, 제1 연산과 제2 연산은 동일한 처리 명령 중의 2개의 연산일 수도 있으며, 제2 연산은 제1 연산과 무관하거나, 또는 제2 연산은 제1 연산을 바탕으로 한 결과일 수 있다. 그 중, 상기 처리 명 령은 데이터 액세스 명령, 연산 명령, 동기화 명령과 통신 명령 등의 하나 이상을 포함할 수 있으며, 예컨대 상 기 명령이 \"읽기와 더하기\" 연산 명령이면, 즉 제1 연산은 읽기 연산이고, 제2 연산은 가법 연산이다. 본 발명 은 상기 처리 명령의 구체적인 유형에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 상기 방법은 상기 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위치 정보와 상기 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제2 위치정보를 기록하는 단계를 더 포함하며, 단계 S13g는 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 때, 상기 제1 연산을 실행하는 단계를 포 함할 수 있다. 일종의 가능한 구현 방식에서, 위치정보는 파인-그레인드 영역의 식별자 정보를 포함할 수 있다. 식별자 정보는 숫자, 알파벳 부호의 임의의 조합을 포함할 수 있으며, 본 발명은 이에 대해 한정하지 않는다. 예를 들어, 위치정보는 파인-그레인드 영역의 번호 정보를 사용하여 표시할 수 있으며, 타겟 저장영역을 6개의 파인-그레인드 영역으로 분할할 수 있고, 그 번호는 순차적으로 0-5이다. 타겟 저장영역에 대한 제1 연산과 제2 연산을 실행 시, 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위치정보(예를 들어 번호 2)와 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제2 위치정보(예를 들어 번호 5)를 각각 기록하고; 이후 번호 정보 간의 관계에 따라(2<5), 제1 위치정보와 제2 위치정보가 일치하지 않는다는 것을 알 수 있으며; 이때 제1 연산을 실행할 수 있다. 일종의 가능한 구현 방식에서, 위치정보는 파인-그레인드 영역의 어드레스 정보를 포함할 수 있다. 어드레스 정 보는 파인-그레인드 영역의 시작 어드레스 정보, 종료 어드레스 정보, 파인-그레인드 영역 중 미리 설정된 위치 의 어드레스 정보, 어드레스 오프셋 정보 중의 적어도 하나를 포함할 수 있다. 예를 들어 파인-그레인드 영역의 위치정보는 ADDR15-ADDR31이다. 이러한 방식을 통해, 위치정보를 사용하여 제1 파인-그레인드 영역과 제2 파인-그레인드 영역의 중첩 여부를 효 율적으로 직접 판단하여, 제1 연산의 실행 여부를 결정할 수 있으며, 프로세서의 실행 효율이 향상될 수 있다. 일종의 가능한 구현 방식에서, 상기 제1 위치정보는 제1 연산이 이미 완료된 파인-그레인드 영역의 제1 수량을 포함할 수 있고, 상기 제2 위치정보는 제2 연산이 이미 완료된 파인-그레인드 영역의 제2 수량을 포함할 수 있 다. 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 때, 상기 제1 연산을 실행하는 단계는, 상기 제1 연산 이 상기 제2 연산 이후의 연산이고, 또한 상기 제1 수량이 상기 제2 수량보다 작을 때, 상기 제1 연산을 실행하 는 단계를 포함할 수 있다. 예를 들어 설명하면, 제1 연산이 제2 연산 이후의 연산이고, 그 타겟 저장영역이 6개의 파인-그레인드 영역으로 분할된다면, 그 위치정보는 이미 연산이 완료된 파인-그레인드 영역의 수량을 사용하여 표시할 수 있다. 타겟 저장영역에 대한 제1 연산과 제2 연산을 실행 시, 제1 연산이 이미 완료된 파인-그레인드 영역의 제1 수량(예를 들어 제1 수량은 3이고)과 제2 연산이 이미 완료된 파인-그레인드 영역의 제2 수량(예를 들어 제1 수량은 5이며)을 각각 기록할 수 있으며; 이후 제1 연산과 제2 연산의 실행 순서, 및 제1 수량과 제2 수량의 관계에 따 라, 제1 연산이 제2 연산 이후의 연산이고, 제1 수량 3은 제2 수량 5보다 작다는 것을 알 수 있으며, 이때 제1연산을 실행할 수 있다. 이러한 방식을 통해, 이미 연산이 완료된 파인-그레인드 영역의 수량에 따라 제1 파인-그레인드 영역과 제2 파 인-그레인드 영역의 중첩 여부를 직관적으로 판단할 수 있고, 제1 연산의 실행 여부를 더 판단할 수 있어, 판단 과정이 단순해질 수 있으며, 프로세서의 실행 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 연산 가능 영역과 연산 불가 영역을 포함할 수 있으며, 단 계 S12g는 상기 제2 연산이 존재하면서, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역이 상기 연산 가능 영역 내에 위치 시, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 상기 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역 간에 중첩이 있는지 여부를 판단하는 단계를 포함할 수 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역은 하나 또는 다수의 연산 불가 영역을 포함할 수 있으며, 연속되 거나 또는 연속되지 않는 연산 불가 영역을 포함할 수도 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역은 하나 또는 다수의 연산 가능 영역을 포함할 수 있으며, 연속되 거나 또는 연속되지 않는 연산 가능 영역을 포함할 수도 있다. 본 발명은 이에 대해 한정하지 않는다. 일종의 가능한 구현 방식에서, 제1 연산이 타겟 저장영역에 대한 연산인 경우, 먼저 타겟 저장영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단할 수 있고; 제2 연산이 존재 시, 제1 연산이 대상으로 하는 제1 파인- 그레인드 영역이 연산 가능 영역 내에 위치하는지 여부를 판단하며; 제2 연산이 존재하면서, 제1 연산이 대상으 로 하는 제1 파인-그레인드 영역이 연산 가능 영역 내에 위치 시, 제1 연산이 대상으로 하는 제1 파인-그레인드 영역과 제2 연산이 대상으로 하는 제2 파인-그레인드 영역 간의 중첩 여부를 더 판단하고; 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간에 중첩이 없는 경우, 제1 연산을 실행한다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 연산금지 영역과 비 연산금지 영역을 포함할 수 있다. 제 1 연산이 쓰기 연산이라면, 타겟 피연산자 중의 일부 데이터의 수정이 불가능할 때, 상기 일부 데이터가 소재하 는 저장영역을 연산금지 영역으로 설정하여, 상기 일부 데이터의 수정 오류를 방지할 수 있고; 진행 중인 제2 연산이 제1 연산 이전의 데이터를 독취하는 읽기 연산(읽기 후 쓰기)이라면, 즉 제2 연산이 소재하는 하나 또는 다수의 파인-그레인드 영역을 비 연산금지 영역으로 설정하여, 제2 연산이 비 연산금지 영역에 대한 독취를 완 료한 후, 상기 비 연산금지 영역을 연산 가능 영역으로 변경할 수 있다. 본 발명은 연산 불가 영역의 분류 및 분할 방식에 대해 제한을 두지 않는다. 본 실시예에서, 먼저 제1 연산의 파인-그레인드 영역이 연산 가능한지 여부를 판단한 다음, 상이한 연산의 파인 -그레인드 영역 간의 관계를 판단할 수 있어, 한편으로는 판단 효율이 향상되고, 다른 한편으로는 지정된 데이 터를 보호하여 연산 오류의 발생을 방지할 수 있고, 지정된 공간에 대해 읽기와 쓰기를 금지함으로써, 상기 공 간을 다른 연산을 실행하기 위해 예비로 남겨둘 수 있어 프로세서가 파인-그레인드 동기화 실행 시의 유연성이 향상된다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그 레인드 영역일 수 있으며, 또한 상기 제2 파인-그레인드 영역의 상기 연산 불가 영역 내에서의 위치는 상기 제2 연산의 연산위치에 따라 업데이트된다. 상기 방법은, 상기 제2 연산이 대상으로 하는 제2 파인-그레인드 영역에 서 상기 연산 불가 영역을 제거한 후, 상기 연산 불가 영역의 위치를 업데이트하는 단계를 더 포함할 수 있다. 다시 말해, 제2 파인-그레인드 영역을 포함하는 다수의 연산 불가 영역은 제2 연산이 대상으로 하는 제2 파인- 그레인드 영역의 업데이트를 따라 업데이트되지 않고, 상기 제2 연산이 대상으로 하는 제2 파인-그레인드 영역 에서 연산 불가 영역을 제거한 후, 연산 불가 영역의 위치를 업데이트할 수 있다. 예를 들어 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 Q개의 파인-그레인드 영역(Q는 1보다 큰 정수)일 수 있으며, 현재의 연산 불가 영역은 제2 내지 제2+Q-1개의 파인-그레인드 영역을 포함한다. 제2 연산이 연산 불가 영역 내에서 Q 개의 파인-그레인드 영역을 실행 완료한 후, 연산 불가 영역을 제거하면, 즉 연산 불가 영역의 위치가 제2 연산 이 대상으로 하는 파인-그레인드 영역의 위치에 따라 업데이트되며, 업데이트 후의 연산 불가 영역은 제2+Q개 내지 2+Q+Q-1개의 파인-그레인드 영역을 포함한다. 그 중, Q의 크기는 필요에 따라 임의로 결정할 수 있다. 도 6a와 도 6b는 본 발명의 실시예에 따른 프로세서 연산 방법의 응용 시나리오 설명도이다. 도 6a에 도시된 바 와 같이, 타겟 저장영역(30d)은 8개의 파인-그레인드 영역을 포함하며, 그 중, 연산가능 영역은 5개의 파인-그 레인드 영역(파인-그레인드 영역(31d), 파인-그레인드 영역(35d), 파인-그레인드 영역(36d), 파인-그레인드 영 역(37d)과 파인-그레인드 영역(38d))을 포함하고, 연산 불가 영역(M0)은 3개의 파인-그레인드 영역(파인-그레인 드 영역(32d), 파인-그레인드 영역(33d)과 파인-그레인드 영역(34d))을 포함한다. 그 중, 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역은 파인-그레인드 영역(32d)이다. 제2 연산이 파인-그레인드 영역(32d)에 대한 연산을 실행 완료한 후, 제2 연산이 현재 대상으로 하는 제2 파인- 그레인드 영역은 파인-그레인드 영역(33d)이며, 이때, 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역 (파인-그레인드 영역(33d))은 연산 불가 영역이 제거되지 않아, 연산 불가 영역의 위치를 업데이트하지 않고; 제2 연산이 파인-그레인드 영역(33d)에 대한 연산을 실행 완료한 후, 제2 연산이 현재 대상으로 하는 제2 파인- 그레인드 영역은 파인-그레인드 영역(34d)이며, 이때, 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역 (파인-그레인드 영역(34d))은 아직 연산 불가 영역을 제거하지 않아, 연산 불가 영역의 위치를 업데이트하지 않 으며; 제2 연산이 파인-그레인드 영역(34d)에 대한 연산을 실행 완료한 후, 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역은 파인-그레인드 영역(35d)이며, 이때, 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역(파인-그레인드 영역(35d))은 이미 연산 불가 영역이 제거되어, 연산 불가 영역의 위치를 파인-그레인드 영 역(35d, 36d와 37d)으로 업데이트한다. 설명해두어야 할 점으로, 본 발명은 연산 불가 영역의 크기에 대해 한정 하지 않는다. 도 6b에 도시된 바와 같이, 연산 불가 영역의 위치가 업데이트된 후, 타겟 저장영역(30d)에서, 연산가능 영역은 5개의 파인-그레인드 영역(파인-그레인드 영역(31d), 파인-그레인드 영역(32d), 파인-그레인드 영역(33d), 파인 -그레인드 영역(34d)과 파인-그레인드 영역(38d))을 포함하고, 연산 불가 영역(M0)은 3개의 파인-그레인드 영역 (파인-그레인드 영역(35d), 파인-그레인드 영역(36d)과 파인-그레인드 영역(37d))을 포함한다. 이러한 방식을 통해, 연산 불가 영역의 위치를 실시간으로 업데이트할 필요가 없어, 연산 불가 영역을 업데이트 하여 발생하는 오버헤드를 감소시킬 수 있다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그 레인드 영역일 수 있고, 또한 상기 제2 파인-그레인드 영역은 상기 연산 불가 영역 내의 설정위치에 위치하여, 상기 연산 불가 영역의 위치가 상기 제2 연산의 연산위치에 따라 업데이트된다. 다시 말해, 연산 불가 영역이 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그레인드 영역인 경우, 제2 파인-그레인드 영역을 연산 불가 영역 중의 위치(예를 들어 중간 위치, 마지막 위치 등)로 설정할 수 있으며, 연산 불가 영역의 위치는 제2 연산의 연산위치에 따라 업데이트된다. 예를 들어, 연산 불가 영역은 상기 제2 파 인-그레인드 영역을 포함하는 Q개의 파인-그레인드 영역일 수 있으며, 현재의 연산 불가 영역은 제2 내지 제 2+Q-1개의 파인-그레인드 영역을 포함하고, 제2 파인-그레인드 영역의 연산 불가 영역 내에서의 설정위치는 제R 번째(그 중 R≤Q)이다. 제2 연산이 현재 대상으로 하는 파인-그레인드 영역에 대한 연산을 실행 완료한 후, 제2 연산은 다음 파인-그레인드 영역에 대한 연산을 실행하기 시작하며, 이때, 연산 불가 영역의 위치는 제2 연산의 연산위치에 따라 업데이트되고, 업데이트 후의 연산 불가 영역은 제2+1 내지 제2+ Q개의 파인-그레인드 영역을 포함한다. 그 중, Q의 크기 및 R의 취득값은 필요에 따라 결정할 수 있다. 본 발명은 연산 불가 영역에 포함되 는 파인-그레인드 영역의 수량, 제2 파인-그레인드 영역이 연산 불가 영역 내에 위치하는 위치에 대해 모두 제 한을 두지 않는다. 도 7a와 도 7b는 본 발명의 실시예에 따른 프로세서 연산 방법의 응용 시나리오 설명도이다. 도 7a에 도시된 바 와 같이, 타겟 저장영역에는 8개의 파인-그레인드 영역이 포함되며, 그 중, 연산가능 영역은 5개의 파인-그 레인드 영역(파인-그레인드 영역, 파인-그레인드 영역, 파인-그레인드 영역, 파인-그레인드 영역 과 파인-그레인드 영역)을 포함하고, 연산 불가 영역(M1)은 3개의 파인-그레인드 영역(파인-그레인드 영역, 파인-그레인드 영역과 파인-그레인드 영역)을 포함한다. 그 중, 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역은 연산 불가 영역(M1)에 위치하는 두 번째 파인-그레인드 영역, 즉 파인-그레인드 영역으로 설정된다. 제2 연산이 파인-그레인드 영역에 대한 연산의 실행을 완료한 후, 제2 연산이 현재 대상으로 하는 제2 파인 -그레인드 영역은 파인-그레인드 영역이며, 이때, 연산 불가 영역의 위치가 제2 연산의 연산위치에 따라 업 데이트됨으로써, 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역이 연산 불가 영역(M1)의 두 번째 파인 -그레인드 영역에 위치하게 된다. 도 7b에 도시된 바와 같이, 연산 불가 영역의 위치가 업데이트된 후, 타겟 저장영역에서, 연산가능 영역은 5개의 파인-그레인드 영역(파인-그레인드 영역, 파인-그레인드 영역, 파인-그레인드 영역, 파인-그 레인드 영역과 파인-그레인드 영역)을 포함하고, 연산 불가 영역(M1)은 3개의 파인-그레인드 영역(파인 -그레인드 영역, 파인-그레인드 영역과 파인-그레인드 영역)을 포함한다.이러한 방식을 통해, 연산 불가 영역의 위치를 실시간으로 업데이트할 수 있어, 파인-그레인드 처리의 동기화율 이 향상되며, 이에 따라 데이터의 동기화 처리 효율이 추가적으로 향상된다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 순환 버퍼(circular buffer) 저장영역을 포함할 수 있다. 상기 순환 버퍼 저장영역은 데이터를 순환 저장하는데 사용될 수 있다. 도 8은 본 발명의 실시예에 따른 프로세서 연산 방법의 순환 버퍼 저장영역의 설명도이다. 도 8에 도시된 바와 같이, 타겟 저장영역 중에 순환 버퍼 저장영역이 포함되며, 그 어드레스는 start_addr~end_addr이다. 예를 들어, 제2 연산은 쓰기 연산이고, 타겟 피연산자를 순환 버퍼 저장영역에 입력할 수 있으며, 그 어드 레스 포인터(point)는 시작 어드레스 start_addr로부터 시작하여, 순차적으로 아래로 데이터를 저장하며, 종료 어드레스 end_addr에 도달하면, 즉 순환 버퍼 저장영역의 저장공간이 가득 차게 된다. 이때, 어드레스 포인 트(point)는 start_addr로 복귀하여, 상기 어드레스가 동기화되어야 할 제1 연산에 의해 사용이 완료되었는지 판단하며, 사용이 완료되었다면, 즉 데이터를 상기 어드레스에 저장하고, 원래의 데이터를 덮어쓴 후, 어드레스 포인터(point)가 end_addr에 도달할 때까지 순차적으로 하향 이동하며, 이때, 데이터를 다시 덮어쓸 수 있으며, 상기 과정을 순환 반복한다. 본 실시예에서, 순환 버퍼 저장영역을 이용하여 데이터를 저장하면, 데이터 저장공간을 절약할 수 있을 뿐만 아 니라, 저장공간의 이율률도 향상될 수 있다. 일종의 가능한 구현 방식에서, 순환 버퍼 저장영역을 다수의 파인-그레인드 영역으로 분할할 수 있다. 각 파인- 그레인드 영역에 대해, 테이블 또는 플래그 비트(flag bit) 또는 기타 방식을 통해 파인-그레인드 영역 중의 데 이터의 덮어쓰기 가능 여부에 대한 관리를 수행할 수 있으며, 예를 들어 덮어쓰기 플래그 비트를 설치하여 파인 -그레인드 영역 중의 데이터의 덮어쓰기 가능 여부를 표시할 수 있다. 예를 들어 설명하면, 제1 연산이 읽기 연산이고, 제2 연산이 쓰기 연산, 즉 선 쓰기 후 읽기이면, 쓰기 포인터 (wp)와 읽기 포인터(rp)를 사용하여 제2 연산과 제1 연산이 현재 대상으로 하는 파인-그레인드 영역을 각각 표 시할 수 있다. 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역의 덮어쓰기 플래그 비트가 덮어쓰기 가 능할 경우, 제2 연산을 실행할 수 있어, 데이터를 입력하며, 데이터 입력이 완료된 후, 상기 제2 파인-그레인드 영역의 덮어쓰기 플래그 비트를 덮어쓰기 불가로 설정하여, wp++이 되고, 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역은 다음 파인-그레인드 영역이 되며, 만약 wp>end_addr이면, 즉 wp=start_addr이다. 제1 연 산이 현재 대상으로 하는 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간이 중첩되지 않으면서, 제1 파인 -그레인드 영역의 덮어쓰기 플래그 비트를 덮어쓰기 할 수 없는 경우, 제1 연산을 실행할 수 있어, 데이터를 독 취하며, 데이터의 독취가 완료된 후, 상기 제1 파인-그레인드 영역의 덮어쓰기 플래그 비트를 덮어쓰기 가능으 로 설정할 수 있으며, rp++이 되고, 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역은 다음 파인-그레 인드 영역이 되며, rp>end_addr라면 즉 rp=start_addr이며; 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 에 중첩이 있는 경우, 즉 rp=wp일 때, 제1 연산은 실행될 수 없어, 제2 연산이 상기 제2 파인-그레인드 영역에 대한 연산을 완료해야만 제1 연산을 실행할 수 있다. 본 실시예에서, 순환 버퍼 저장영역을 다수의 파인-그레인드 영역으로 분할하여, 다수의 연산이 동시에 순환 버 퍼 저장영역에 대해 연산하도록 함으로써, 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역은 상태 식별자를 포함할 수 있으며, 상기 상태 식별자 는 상기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함한다. 단계 S13g는 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 간이 중첩되지 않는 경우, 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하여; “예”이면, 즉 상기 제1 연산을 실행하는 단계를 포함할 수 있다. 일종의 가능한 구현 방식에서, 파인-그레인드 영역은 상태 식별자를 포함할 수 있으며, 상태 식별자는 파인-그 레인드 영역의 이미 완료된 상태 또는 미완료 상태를 포함할 수 있다. 예를 들어, 상태 식별자는 0과 1로 표시 할 수 있으며, 그 중, 0은 파인-그레인드 영역의 연산이 미완료된 상태를 나타내고, 1은 파인-그레인드 영역의 연산이 이미 완료된 상태를 나타내며, 또는 0은 파인-그레인드 영역의 연산이 이미 완료된 상태를 나타내고, 1 은 파인-그레인드 영역의 연산이 미완료 상태를 나타낸다. 본 발명은 상태 식별자의 표시 방식에 대해 제한을 두지 않는다. 일종의 가능한 구현 방식에서, 제2 연산은 타겟 저장영역에 이미 연산이 완료된 파인-그레인드 영역의 상태 식 별자를 이미 완료 상태로 설정하고, 미연산 또는 연산 중인 파인-그레인드 영역의 상태 식별자는 미완료 상태로 설정할 수 있다. 또한 이미 연산이 완료된 파인-그레인드 영역의 일부 파인-그레인드 영역의 상태 식별자를 이 미 완료된 상태로 설정하고, 다른 파인-그레인드 영역은 미완료 상태로 설정할 수도 있다. 예를 들어 제2 연산 이 5개의 파인-그레인드 영역의 연산을 이미 완료하였다면, 이전 3개의 파인-그레인드 영역의 상태 식별자를 이 미 완료된 상태로 설정하고, 다른 파인-그레인드 영역은 미완료 상태로 설정할 수 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역에 대해 진행 중인 제2 연산이 존재할 경우, 제1 연산이 현재 대상 으로 하는 제1 파인-그레인드 영역과 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역에 대해, 제1 파인 -그레인드 영역과 제2 파인-그레인드 영역 간이 중첩되지 않은 것을 결정한후, 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단할 수 있고; 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태라면, 제1 연산을 실행할 수 있다. 본 실시예에서, 파인-그레인드 영역은 상태 식별자를 포함하며, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 제1 파인-그레인드 영역의 상태 식별자에 따라 제1 연산의 실행 가능 여부를 결정할 수 있어, 프로세서의 처리 효율이 향상될 수 있음과 동시에, 데이터 처리의 정확성이 향상된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역은 상태 식별자를 포함할 수 있으며, 상기 상태 식별자 는 상기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태이거나 또는 미완료 상태를 포함할 수 있다. 단계 S13g는, 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하여; “예”이면, 즉 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 때, 상기 제1 연산을 실행 하는 단계를 포함할 수 있다. 다시 말해, 타겟 저장영역에 대해 진행 중인 제2 연산이 존재할 경우, 제1 연산이 현재 대상으로 하는 제1 파인 -그레인드 영역과 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역에 대해, 제1 파인-그레인드 영역의 상태 식별자를 이미 완료된 상태로 결정한 후, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간의 중첩 관 계에 따라, 제1 연산의 실행 가능 여부를 결정한다. 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 사이가 중첩되지 않을 때, 제1 연산을 실행할 수 있다. 본 실시예에서, 파인-그레인드 영역은 상태 식별자를 포함하며, 제1 파인-그레인드 영역의 상태 식별자를 이미 완료된 상태로 결정한 후, 제1 파인-그레인드 영역과 제2 파인-그레인드 영역 간의 중첩 관계에 따라, 제1 연산 의 실행 가능 여부를 결정할 수 있어, 데이터 처리의 정확성이 향상될 수 있는 동시에, 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 제1 연산과 상기 제2 연산의 타겟 피연산자는 일치하며, 상기 타겟 저장영 역은 상기 타겟 피연산자의 저장영역이다. 일종의 가능한 구현 방식에서, 제1 연산의 타겟 피연산자와 제2 연산의 타겟 피연산자가 일치 시, 상기 타겟 저 장영역은 하나의 타겟 피연산자의 저장영역일 수 있으며, 이 타겟 피연산자의 저장영역이 즉 타겟 저장영역이다. 타겟 저장영역을 다수의 파인-그레인드 영역으로 분할한 후, 본 발명의 실시예 중의 방법에 따라, 동일한 타겟 피연산자를 연산하는 2개의 연산을 각 연산의 실행 결과에 영향을 주지 않고 병행 실행할 수 있다. 본 실시예에서, 본 발명의 실시예 중의 방법을 사용하여, 동일한 피연산자에 대한 2개의 연산의 병행 실행을 구 현할 수 있어, 프로세서의 실행 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 제1 연산 중 제1 피연산자의 제1 저장영역과 제2 연산 중 제2 피연산자의 제2 저장영역 간의 중첩 영역이다. 일종의 가능한 구현 방식에서, 2개의 피연산자의 저장영역에 중첩 영역이 존재 시, 타겟 저장영역이 즉 중첩 영 역이다. 2개의 피연산자의 저장영역 중의 중첩 영역을 다수의 파인-그레인드 영역으로 분할하고, 본 발명의 실 시예 중의 방법에 따라, 피연산자의 저장영역 중 중첩 영역이 있는 2개의 연산을 각 연산의 실행 결과에 영향을 주지 않고 병행 실행할 수 있다. 본 실시예에서, 두 연산의 피연산자의 저장영역이 중첩 시, 본 발명의 실시예 중의 방법을 사용하여 두 연산의 병행 실행을 구현할 수 있어, 프로세서의 실행 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 방법은, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하는 단계를 더 포함할 수 있다. 일종의 가능한 구현 방식에서, 타겟 저장영역은 저장장치의 전체 저장영역 중의 일부 저장영역이거나 또는 전체 저장영역일 수 있으며, 상기 전체 저장영역은 미리 설정된 다수의 파인-그레인드 영역을 포함한다. 예를 들어 타겟 저장영역이 소재하는 전체 저장영역이 RAM1이면, RAM1은 미리 설정된 m개의 파인-그레인드 영역 (m은 양의 정수)을 포함할 수 있다. 타겟 저장영역은 RAM1에서 RAM1 중의 n개의 파인-그레인드 영역(n은 양의 정수이며, n≤m)을 점유할 수 있다. 설명해두어야 할 점으로, 타겟 저장영역은 어떤 파인-그레인드 영역 중의 일부 영역을 포함할 수도 있다. 상기 예시의 RAM1에서, 각 파인-그레인드 영역이 전체 저장영역 RAM1 중에서의 1행이고, 각 행은 100비트라고 가정하면, 타겟 저장영역은 이전(n-1)의 완전한 파인-그레인드 영역을 포함하면 서 또한 마지막 파인-그레인드 영역의 일부 영역도 포함할 수 있으며, 예를 들어 RAM1 중 제n번째 행(제n번째 파인-그레인드 영역) 중의 이전 80개의 비트를 포함할 수 있다. 일종의 가능한 구현 방식에서, 저장장치의 전체 저장영역을 다수의 파인-그레인드 영역으로 분할 시, 전체 저장 영역 중 임의의 타겟 저장영역에 대한 임의의 연산은, 타겟 저장영역이 제1 연산과 제2 연산의 동일한 타겟 피 연산자의 저장영역이거나, 또는 타겟 저장영역이 제1 연산 중 제1 피연산자의 저장영역 및 제2 연산 중 제2 피 연산자의 저장영역의 중첩 영역이거나를 막론하고, 모두 전체 저장영역의 파인-그레인드 영역의 분할 결과에 따 라, 타겟 저장영역 중의 파인-그레인드 영역을 결정할 수 있다. 임의 연산의 임의의 피연산자의 전체 저장영역 중에서의 저장영역은 동일한 크기의 파인-그레인드 영역을 갖는다. 일종의 가능한 구현 방식에서, 저장장치의 하드웨어 특성에 따라, 전체 저장영역의 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있으며, 즉 저장장치의 하드웨어 계산능력, 하드웨어 대역폭 중의 적어도 하나에 따 라, 전체 저장영역의 파인-그레인드 영역의 크기 및/또는 수량을 결정할 수 있다. 본 실시예에서, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하여, 전체 저 장영역 중 임의의 타겟 저장영역에 대해 실행되는 임의의 연산은 모두 동일한 파인-그레인드 크기에 따라 실행 할 수 있으며, 상이한 연산을 본 발명의 실시예 중의 방법에 따라 병행 시, 더욱 편리하게 동기화할 수 있어, 연산의 병행률이 향상되고, 나아가 프로세서의 처리 효율이 향상된다. 일종의 가능한 구현 방식에서, 상기 방법은, 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 상기 제1 연산 중 제1 피연산자의 제1 저장영역을 다수의 파인-그레인드 영역으로 분할하는 단계, 및 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 상기 제2 연산 중 제2 피연산자의 제2 저장영역을 다수의 파인-그레인드 영역으로 분할하는 단계를 더 포함할 수 있다. 일종의 가능한 구현 방식에서, 연산에 파인-그레인드 분할 정보가 수반될 수 있으며, 파인-그레인드 분할 정보 는 파인-그레인드의 크기 및/또는 수량을 포함할 수 있다. 상이한 연산은 상이한 파인-그레인드 분할 정보를 수 반할 수 있고, 동일한 유형의 연산은 동일한 파인-그레인드 분할 정보를 수반할 수 있다. 연산 중 피연산자의 설정위치에 파인-그레인드 분할 정보가 수반될 수도 있고, 연산코드 또는 피연산자에 파인-그레인드 분할 수행 여부의 식별자 정보가 수반될 수도 있다. 본 발명은 파인-그레인드 분할 정보 중의 내용 및 표현 방식에 대해 한정하지 않는다. 일종의 가능한 구현 방식에서, 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 제1 피연산자의 제1 저장영역을 다수의 제1 파인-그레인드 영역으로 분할한다. 제1 피연산자가 소재하는 전체 저장영역 중의 다른 영역은 파인-그레인드 분할을 실시하지 않을 수 있고, 다른 연산에 수반되는 파인-그레인드 분할 정보에 따라 파인-그레인드 분할을 실시할 수도 있다. 본 발명은 이에 대해 한정하지 않는다. 제2 연산의 피연산자와 제1 연산의 제1 피연산자가 일치 시, 제1 저장영역과 제2 저장영역이 완전히 중복된다는 것을 이해할 수 있을 것이다. 제1 파인-그레인드 분할 정보와 제2 파인-그레인드 분할 정보는 일치할 수도 있고, 일치하지 않을 수도 있다. 제1 파인-그레인드 분할 정보와 제2 파인-그레인드 분할 정보가 일치하지 않을 경우, 제1 저장영역은 제2 파인-그레인드 분할 정보에 따라 동시에 파인-그레인드 분할을 실시할 수 있다. 즉, 동일한 저장영역에 대해, 상이한 연산은 이를 상이한 크기 또는 수량의 다수의 파인-그레인드 영역으로 분할할 수 있다. 이때, 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역의 물리 어드레스, 및 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역 간의 물리 어드레스에 따라, 제1 파인-그레인드 영역과 제2 파인-그레인 드 영역의 중첩 여부를 판단하고, 판단 결과에 따라 제1 연산과 제2 연산의 병행 실행을 수행할 수 있다.일종의 가능한 구현 방식에서, 각 연산에 수반되는 파인-그레인드 분할 정보는 길이를 설정하는 연산 피연산자 가 소재하는 영역, 차원을 설정하는 피연산자가 소재하는 영역 중의 적어도 하나를 포함할 수 있으며, 결정된 상기 파인-그레인드 영역의 크기 및/또는 수량을 통해, 파인-그레인드 분할 결과가 연산 중의 피연산자 유형과 속성에 더욱 부합되도록 할 수 있다. 본 실시예에서, 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 제1 연산 중 제1 피연산자의 제1 저 장영역을 다수의 파인-그레인드 영역으로 분할하고, 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 상기 제2 연산 중 제2 피연산자의 제2 저장영역을 다수의 파인-그레인드 영역으로 분할한다. 연산에 수반되는 파인-그레인드 분할 정보에 따라 파인-그레인드 분할을 실시함으로써, 파인-그레인드 분할 결과를 각 조작의 처 리 요구에 더욱 부합되도록 할 수 있어, 연산의 병행이 더욱 유연해진다. 당업자라면 실제 상황에 따라 타겟 저장영역을 파인-그레인드 영역으로 분할 및 설치할 수 있으며, 본 발명은 이에 대해 제한을 두지 않는다. 설명해두어야 할 점으로, 이상의 실시예는 예시로서 프로세서 연산 방법을 위와 같이 소개하였으나, 당업자라면, 본 발명이 이에 한정되지 않는다는 것을 이해할 수 있을 것이다. 사실상, 사용자는 전적으로 개인 의 선호 및/또는 실제 응용 시나리오에 따라 각 단계를 유연하게 설정할 수 있으며, 본 발명의 기술방안에 부합 되기만 하면 된다. 도 3g는 본 발명의 실시예에 따른 프로세서 연산장치의 블록도이다. 도 3g에 도시된 바와 같이, 상기 프로세서 연산장치는, 제1 연산이 타겟 저장영역에 대한 연산일 경우, 적어도 하나의 파인-그레인드 영역을 포함하는 상기 타겟 저장 영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단하기 위한 연산 판단모듈(71g); 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 상기 제2 연산이 현 재 대상으로 하는 제2 파인-그레인드 영역 간의 중첩 여부를 판단하기 위한 중첩 판단모듈(72g); 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩되지 않을 경우, 상기 제1 연산을 실행하기 위한 실행모듈(73g)을 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중 첩 시, 상기 제1 연산을 차단하기 위한 실행 제어모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 연산과 상기 제2 연산 중의 적어도 하나의 연산은 쓰기 연산이다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 길이를 설정하는 데이터가 소재 하는 영역, 차원을 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라 결정된다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 하드웨어의 계산 능력, 하드웨 어의 대역폭 중의 적어도 하나에 따라 결정된다. 일종의 가능한 구현 방식에서, 상기 제1 연산은 제1 처리 명령 중의 연산이고, 상기 제2 연산은 제2 처리 명령 중의 연산이며, 상기 제2 처리 명령은 명령 큐 중 상기 제1 처리 명령 이전의 처리 명령이다. 일종의 가능한 구현 방식에서, 상기 장치는, 상기 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위 치정보와 상기 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제2 위치정보를 기록하기 위한 위치 기록모 듈을 더 포함하고, 상기 실행 모듈은, 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 경우, 상기 제1 연산을 실행하기 위한 제1 실행 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 위치정보는 제1 연산이 연산을 이미 완료한 파인-그레인드 영역의 제1 수량을 포함하고, 상기 제2 위치정보는 제2 연산이 연산을 이미 완료한 파인-그레인드 영역의 제2 수량을 포함 하며, 상기 제1 실행 서브모듈은, 상기 제1 연산이 상기 제2 연산 이후의 연산이고, 상기 제1 수량이 상기 제2 수량보다 작을 경우, 상기 제1 연산을 실행하는데 더 사용된다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 연산 가능 영역과 연산 불가 영역을 포함하며, 상기 중첩 판단모듈은, 상기 제2 연산이 존재하면서, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역이 상기 연산 가능 영역 내에 위치하는 경우, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 상기 제2 연산이 현재 대상으로 하는 제2 파인-그레인드 영역 간의 중첩 여부를 판단하기 위한 판단 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그 레인드 영역이고, 또한 상기 제2 파인-그레인드 영역의 상기 연산 불가 영역 내에서의 위치는 상기 제2 연산의 연산위치에 따라 업데이트되며, 상기 장치는, 상기 제2 연산이 대상으로 하는 제2 파인-그레인드 영역에서 상기 연산 불가 영역을 제거한 후, 상기 연산 불가 영역의 위치를 업데이트하기 위한 업데이트 모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인-그 레인드 영역이고, 또한 상기 제2 파인-그레인드 영역은 상기 연산 불가 영역 내의 설정위치에 위치하며, 상기 연산 불가 영역의 위치는 상기 제2 연산의 연산위치에 따라 업데이트된다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 순환 버퍼 저장영역을 포함한다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 실행모듈(73g)은, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경 우, 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하기 위한 제1 상태 판단 서브모듈; 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인 경우, 상기 제1 연산을 실행하기 위한 제2 실행 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 실행모듈(73g)은, 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하기 위한 제2 상태 판단 서브모듈; 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태이고, 또한 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 연산을 실행하기 위한 제3 실행 서브모듈을 포함한다. 일종의 가능한 구현 방식에서, 상기 제1 연산과 상기 제2 연산의 타겟 피연산자는 일치하며, 상기 타겟 저장영 역은 상기 타겟 피연산자의 저장영역이다. 일종의 가능한 구현 방식에서, 상기 타겟 저장영역은 제1 연산 중 제1 피연산자의 제1 저장영역과 제2 연산 중 제2 피연산자의 제2 저장영역 간의 중첩 영역이다. 일종의 가능한 구현 방식에서, 상기 장치는, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하기 위한 제1 설정모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 장치는, 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 상기 제1 연산 중 제1 피연산자의 제1 저장영역을 다수의 파인-그레인드 영역으로 분할하기 위한 제2 설정모듈, 및 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 상기 제2 연산 중 제2 피연산자의 제2 저장영역을 다수의 파인-그레인드 영역으로 분할하기 위한 제3 설정모듈을 더 포함한다. 일종의 가능한 구현 방식에서, 상기 프로세서 연산장치를 포함하는 인공지능 칩을 더 공개한다. 일종의 가능한 구현 방식에서, 보드는 메모리 소자, 인터페이스 장치와 제어 소자 및 상기 인공지능 칩을 포함 하는 보드를 더 공개하며; 그 중, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공 지능 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터링하기 위한 것이다. 일종의 가능한 구현 방식에서, 상기 메모리 소자는 다수 그룹의 저장유닛을 포함하고, 각 그룹의 상기 저장유닛 은 버스를 통해 상기 인공지능 칩과 연결되며, 상기 저장유닛은 DDR SDRAM이고; 상기 인공지능 칩은 각각의 상 기 저장유닛의 데이터 전송과 데이터 저장을 제어하기 위한 DDR 컨트롤러를 포함하며; 상기 인터페이스는 표준 PCIE 인터페이스이다.A1: 프로세서 연산방법에 있어서, 상기 방법은, 제1 연산이 타겟 저장영역에 대한 연산일 경우, 적어도 하나의 파인-그레인드 영역을 포함하는 상기 타겟 저장 영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단하는 단계; 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 상기 제2 연산이 현 재 대상으로 하는 제2 파인-그레인드 영역 간의 중첩 여부를 판단하는 단계; 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩되지 않을 경우, 상기 제1 연산을 실행하는 단계를 포함한다. A2: A1항에 따른 방법에 있어서, 상기 방법은, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩 시, 상기 제1 연산을 차단하는 단계를 더 포함한다. A3: A1항에 따른 방법에 있어서, 상기 제1 연산과 상기 제2 연산 중의 적어도 하나의 연산은 쓰기 연산이다. A4: A1항에 따른 방법에 있어서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 길이를 설정하는 데이터가 소 재하는 영역, 차원을 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라 결정된다. A5: A1항에 따른 방법에 있어서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 하드웨어의 계산 능력, 하드 웨어의 대역폭 중의 적어도 하나에 따라 결정된다. A6: A1항에 따른 방법에 있어서, 상기 제1 연산은 제1 처리 명령 중의 연산이고, 상기 제2 연산은 제2 처리 명 령 중의 연산이며, 상기 제2 처리 명령은 명령 큐 중 상기 제1 처리 명령 이전의 처리 명령이다. A7: A1-A6 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은, 상기 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위치정보와 상기 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제1 위치정보를 기록하는 단계를 더 포함하고, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩되지 않을 경우, 상기 제1 연산을 실행하는 단계는, 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 경우, 상기 제1 연산을 실행하는 단계를 포함한다. A8: A7항에 따른 방법에 있어서, 상기 제1 위치정보는 제1 연산이 연산을 이미 완료한 파인-그레인드 영역의 제 1 수량을 포함하고, 상기 제2 위치정보는 제2 연산이 연산을 이미 완료한 파인-그레인드 영역의 제2 수량을 포 함하며, 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 경우, 상기 제1 연산을 실행하는 단계는, 상기 제1 연산이 상기 제2 연산 이후의 연산이고, 상기 제1 수량이 상기 제2 수량보다 작을 경우, 상기 제1 연 산을 실행하는 단계를 더 포함한다. A9: A1항에 따른 방법에 있어서, 상기 타겟 저장영역은 연산 가능 영역과 연산 불가 영역을 포함하며, 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 상기 제2 연산이 현재 대상으 로 하는 제2 파인-그레인드 영역 간의 중첩 여부를 판단하는 단계는, 상기 제2 연산이 존재하면서, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역이 상기 연산 가능 영역 내에 위치하는 경우, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 상기 제2 연산이 현 재 대상으로 하는 제2 파인-그레인드 영역 간의 중첩 여부를 판단하는 단계를 포함한다. A10: A9항에 따른 방법에 있어서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인 -그레인드 영역이고, 또한 상기 제2 파인-그레인드 영역의 상기 연산 불가 영역 내에서의 위치는 상기 제2 연산 의 연산위치에 따라 업데이트되며, 상기 방법은, 상기 제2 연산이 대상으로 하는 제2 파인-그레인드 영역에서 상기 연산 불가 영역을 제거한 후, 상기 연산 불가 영역의 위치를 업데이트하는 단계를 더 포함한다. A11: A9항에 따른 방법에 있어서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파인 -그레인드 영역이고, 또한 상기 제2 파인-그레인드 영역은 상기 연산 불가 영역 내의 설정위치에 위치하며, 상기 연산 불가 영역의 위치는 상기 제2 연산의 연산위치에 따라 업데이트된다. A12: A1항에 따른 방법에 있어서, 상기 타겟 저장영역은 순환 버퍼 저장영역을 포함한다. A13: A1항에 따른 방법에 있어서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상 기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩되지 않을 경우, 상기 제1 연산을 실행하는 단계는, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 파인-그레 인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하는 단계; “예”이면, 상기 제1 연산을 실행하는 단계를 포함한다. A14: A1항에 따른 방법에 있어서, 상기 파인-그레인드 영역은 상태 식별자를 포함하고, 상기 상태 식별자는 상 기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하며, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩되지 않을 경우, 상기 제1 연산을 실행하는 단계는, 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하는 단계; “예”이면, 즉 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않으면, 상기 제 1 연산을 실행하는 단계를 포함한다. A15: A1항에 따른 방법에 있어서, 상기 제1 연산과 상기 제2 연산의 타겟 피연산자는 일치하며, 상기 타겟 저장 영역은 상기 타겟 피연산자의 저장영역이다. A16: A1항에 따른 방법에 있어서, 상기 타겟 저장영역은 제1 연산 중 제1 피연산자의 제1 저장영역과 제2 연산 중 제2 피연산자의 제2 저장영역 간의 중첩 영역이다. A17: A1-A16 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하는 단계를 더 포함한다. A18: A1-A17 중의 어느 한 항에 따른 방법에 있어서, 상기 방법은, 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 상기 제1 연산 중 제1 피연산자의 제1 저장영역을 다수의 파인-그레인드 영역으로 분할하는 단계, 및 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 상기 제2 연산 중 제2 피연산자의 제2 저장영역을 다수의 파인-그레인드 영역으로 분할하는 단계를 더 포함한다. A19: 프로세서 연산장치에 있어서, 상기 장치는 제1 연산이 타겟 저장영역에 대한 연산일 경우, 적어도 하나의 파인-그레인드 영역을 포함하는 상기 타겟 저장 영역에 대해 진행 중인 제2 연산이 존재하는지 여부를 판단하기 위한 연산 판단모듈; 상기 제2 연산이 존재 시, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 상기 제2 연산이 현 재 대상으로 하는 제2 파인-그레인드 영역 간의 중첩 여부를 판단하기 위한 중첩 판단모듈; 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩되지 않을 경우, 상기 제1 연산을 실행하기 위한 실행모듈을 포함한다. A20: A19항에 따른 장치에 있어서, 상기 장치는, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역이 중첩 시, 상기 제1 연산을 차단하기 위한 실행 제어모듈을 더 포함한다. A21: A19항에 따른 장치에 있어서, 상기 제1 연산과 상기 제2 연산 중의 적어도 하나의 연산은 쓰기 연산이다. A22: A19항에 따른 장치에 있어서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 길이를 설정하는 데이터가 소재하는 영역, 차원을 설정하는 데이터가 소재하는 영역 중의 적어도 하나에 따라 결정된다.A23: A19항에 따른 장치에 있어서, 상기 파인-그레인드 영역의 크기 및/또는 수량은 하드웨어의 계산 능력, 하 드웨어의 대역폭 중의 적어도 하나에 따라 결정된다. A24: A19항에 따른 장치에 있어서, 상기 제1 연산은 제1 처리 명령 중의 연산이고, 상기 제2 연산은 제2 처리 명령 중의 연산이며, 상기 제2 처리 명령은 명령 큐 중 상기 제1 처리 명령 이전의 처리 명령이다. A25: A19-A24 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 상기 제1 연산이 현재 연산하는 제1 파인-그레인드 영역의 제1 위치정보와 상기 제2 연산이 현재 연산하는 제2 파인-그레인드 영역의 제2 위치정보를 기록하기 위한 위치 기록모듈을 더 포함하고, 상기 실행 모듈은, 상기 제1 위치정보와 상기 제2 위치정보가 일치하지 않을 경우, 상기 제1 연산을 실행하기 위한 제1 실행 서브모듈을 포함한다. A26: A25항에 따른 장치에 있어서, 상기 제1 위치정보는 제1 연산이 연산을 이미 완료한 파인-그레인드 영역의 제1 수량을 포함하고, 상기 제2 위치정보는 제2 연산이 연산을 이미 완료한 파인-그레인드 영역의 제2 수량을 포함하며, 상기 제1 실행 서브모듈은, 상기 제1 연산이 상기 제2 연산 이후의 연산이고, 상기 제1 수량이 상기 제2 수량보다 작을 경우, 상기 제1 연 산을 실행하는데 더 사용된다. A27: A19항에 따른 장치에 있어서, 상기 타겟 저장영역은 연산 가능 영역과 연산 불가 영역을 포함하며, 상기 중첩 판단모듈은, 상기 제2 연산이 존재하면서, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역이 상기 연산 가능 영역 내에 위치하는 경우, 상기 제1 연산이 현재 대상으로 하는 제1 파인-그레인드 영역과 상기 제2 연산이 현 재 대상으로 하는 제2 파인-그레인드 영역 간의 중첩 여부를 판단하기 위한 판단 서브모듈을 포함한다. A28: A27항에 따른 장치에 있어서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파 인-그레인드 영역이고, 또한 상기 제2 파인-그레인드 영역의 상기 연산 불가 영역 내에서의 위치는 상기 제2 연 산의 연산위치에 따라 업데이트되며, 상기 장치는, 상기 제2 연산이 대상으로 하는 제2 파인-그레인드 영역에서 상기 연산 불가 영역을 제거한 후, 상기 연산 불가 영역의 위치를 업데이트하기 위한 업데이트 모듈을 더 포함한다. A29: A27항에 따른 장치에 있어서, 상기 연산 불가 영역은 상기 제2 파인-그레인드 영역을 포함하는 다수의 파 인-그레인드 영역이고, 또한 상기 제2 파인-그레인드 영역은 상기 연산 불가 영역 내의 설정위치에 위치하며, 상기 연산 불가 영역의 위치는 상기 제2 연산의 연산위치에 따라 업데이트된다. A30: A19항에 따른 장치에 있어서, 상기 타겟 저장영역은 순환 버퍼 저장영역을 포함한다. A31: A19항에 따른 장치에 있어서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상 기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 실행모듈은, 상기 제1 파인-그레인드 영역과 상기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 파인-그레 인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하기 위한 제1 상태 판단 서브모듈; 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인 경우, 상기 제1 연산을 실행하기 위한 제2 실행 서브모듈을 포함한다. A32: A19항에 따른 장치에 있어서, 상기 파인-그레인드 영역은 상태 식별자를 포함하며, 상기 상태 식별자는 상 기 파인-그레인드 영역에 대한 연산이 이미 완료된 상태 또는 미완료 상태를 포함하고, 상기 실행모듈은, 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태인지 여부를 판단하기 위한 제2 상태 판단 서브 모듈; 상기 제1 파인-그레인드 영역의 상태 식별자가 이미 완료된 상태이고, 또한 상기 제1 파인-그레인드 영역과 상 기 제2 파인-그레인드 영역 사이가 중첩되지 않을 경우, 상기 제1 연산을 실행하기 위한 제3 실행 서브모듈을 포함한다. A33: A19항에 따른 장치에 있어서, 상기 제1 연산과 상기 제2 연산의 타겟 피연산자는 일치하며, 상기 타겟 저 장영역은 상기 타겟 피연산자의 저장영역이다. A34: A19항에 따른 장치에 있어서, 상기 타겟 저장영역은 제1 연산 중 제1 피연산자의 제1 저장영역과 제2 연산 중 제2 피연산자의 제2 저장영역 간의 중첩 영역이다. A35: A19-A24 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 타겟 저장영역이 소재하는 전체 저장영역을 다수의 파인-그레인드 영역으로 분할하기 위한 제1 설정모듈을 더 포함한다. A36: A19-A24 중의 어느 한 항에 따른 장치에 있어서, 상기 장치는, 제1 연산에 수반되는 제1 파인-그레인드 분할 정보에 따라, 상기 제1 연산 중 제1 피연산자의 제1 저장영역을 다수의 파인-그레인드 영역으로 분할하기 위한 제2 설정모듈, 및 제2 연산에 수반되는 제2 파인-그레인드 분할 정보에 따라, 상기 제2 연산 중 제2 피연산자의 제2 저장영역을 다수의 파인-그레인드 영역으로 분할하기 위한 제3 설정모듈을 더 포함한다. A37: 인공지능 칩에 있어서, 상기 인공지능 칩은 A19-A36 중의 어느 한 항에 따른 상기 프로세서 연산장치를 포 함한다. A38: 전자장치에 있어서, 상기 전자장치는 A37항에 따른 인공지능 칩을 포함한다. A39: 보드에 있어서, 상기 보드는 메모리 소자, 인터페이스 장치와 제어 소자 및 A37항에 따른 상기 인공지능 칩을 포함하며; 그 중, 상기 인공지능 칩은 상기 메모리 소자, 상기 제어 소자 및 상기 인터페이스 장치와 각각 연결되고; 상기 메모리 소자는 데이터를 저장하기 위한 것이며; 상기 인터페이스 장치는 상기 인공지능 칩과 외부 장치 간의 데이터 전송을 구현하기 위한 것이고; 상기 제어 소자는 상기 인공지능 칩의 상태를 모니터링하기 위한 것이다. A40: A39항에 따른 보드에 있어서, 상기 메모리 소자는 다수 그룹의 저장유닛을 포함하고, 각 그룹의 상기 저장 유닛은 버스를 통해 상기 인공지능 칩과 연결되며, 상기 저장유닛은 DDR SDRAM이고; 상기 인공지능 칩은 각각의 상기 저장유닛의 데이터 전송과 데이터 저장을 제어하기 위한 DDR 컨트롤러를 포함 하며; 상기 인터페이스는 표준 PCIE 인터페이스이다. 이상, 본 발명의 각 실시예를 설명하였으나 상기 설명은 제한적이 아닌 예시적인 것이고, 또한 개시된 각 실시"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 34, "content": "예에 한정되는 것도 아니다. 설명한 각 실시예의 범위와 사상을 벗어나지 않는 한, 본 기술분야의 통상의 기술 자에게 있어 다양한 수정과 변경은 자명한 것이다. 본 명세서에서 사용된 용어는, 각 실시예의 원리, 실제 응용"}
{"patent_id": "10-2020-7036505", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 35, "content": "또는 시중의 기술에 대한 개선을 가장 잘 해석하기 위한 것이며, 또는 본 기술분야의 기타 통상의 기술자가 본 문에 공개된 각 실시예를 이해할 수 있도록 하기 위한 것이다. 도면 도면1a 도면1b 도면1c 도면1da 도면1db 도면1e 도면1f 도면1g 도면2 도면3a 도면3b 도면3ca 도면3cb 도면3cc 도면3cd 도면3ce 도면3d 도면3e 도면3f 도면3g 도면4 도면5a 도면5b 도면6a 도면6b 도면7a 도면7b 도면8"}
{"patent_id": "10-2020-7036505", "section": "도면", "subsection": "도면설명", "item": 1, "content": "명세서에 포함되어 명세서의 일부를 구성하는 도면은 명세서와 함께 본 발명의 예시적인 실시예, 특징과 방면을 도시하며, 또한 본 발명의 원리를 설명하기 위한 것이다.도 1a는 본 발명의 실시예에 따른 데이터 처리방법의 흐름도이다. 도 1b는 본 발명의 실시예에 따른 데이터 처리장치의 블록도이다. 도 1c는 본 발명의 실시예에 따른 데이터 동기화 방법의 흐름도이다. 도 1da은 본 발명의 실시예에 따른 응용 시나리오 설명도이다. 도 1db는 본 발명의 실시예에 따른 프로세서 연산방법의 흐름도이다. 도 1e는 본 발명의 실시예에 따른 데이터 동기화 방법의 흐름도이다. 도 1f는 본 발명의 실시예에 따른 데이터 처리방법의 흐름도이다. 도 1g는 본 발명의 실시예에 따른 프로세서 연산방법의 흐름도이다. 도 2는 본 발명의 실시예에 따른 데이터 저장공간의 설명도이다. 도 3a는 본 발명의 실시예에 따른 데이터 처리장치의 블록도이다. 도 3b는 본 발명의 실시예에 따른 데이터 처리방법의 흐름도이다. 도 3ca은 본 발명의 실시예에 따른 데이터 동기화 방법의 흐름도이다. 도 3cb는 본 발명의 실시예에 따른 데이터 동기화 방법의 흐름도이다. 도 3cc은 본 발명의 실시예에 따른 데이터 동기화 장치의 블록도이다. 도 3cd는 본 발명의 실시예에 따른 데이터 동기화 장치의 블록도이다. 도 3ce는 본 발명의 실시예에 따른 데이터 동기화 장치의 블록도이다. 도 3d는 본 발명의 실시예에 따른 프로세서 연산장치의 블록도이다. 도 3e는 본 발명의 실시예에 따른 데이터 동기화 장치의 블록도이다. 도 3f는 본 발명의 실시예에 따른 데이터 처리장치의 블록도이다. 도 3g는 본 발명의 실시예에 따른 프로세서 연산장치의 블록도이다. 도 4는 본 발명의 실시예에 따른 보드의 구조 블록도이다. 도 5a와 5b는 본 발명의 실시예에 따른 프로세서 연산방법의 응용 시나리오 설명도이다. 도 6a와 6b는 본 발명의 실시예에 따른 프로세서 연산방법의 응용 시나리오 설명도이다. 도 7a와 7b는 본 발명의 실시예에 따른 프로세서 연산방법의 응용 시나리오 설명도이다. 도 8은 본 발명의 실시예에 따른 프로세서 연산방법의 순환 버퍼 저장영역의 설명도이다."}
