{"patent_id": "10-2023-0033432", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0097671", "출원번호": "10-2023-0033432", "발명의 명칭": "인공지능 연산 시스템 및 방법", "출원인": "한국전자통신연구원", "발명자": "권현정"}}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "복수의 연산기; 및트랜스포머 모델에서 특정 어텐션 레이어를 이루는 노드들을 병합하고, 상기 병합된 노드의 데이터 중에서 특정행렬 데이터를 전처리하며, 상기 전처리된 데이터와 전처리되지 않은 데이터를 상기 복수의 연산기에 분배하고,상기 복수의 연산기의 연산 결과를 합하여 정규화하는 호스트를 포함하되, 상기 복수의 연산기는, 상기 분배된 데이터를 이용하여 GEMM(GEneral Matrix Matrix multiplication) 연산을 병렬로 수행하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 호스트는,GEMV(GEneral Matrix Vector multiplication), softmax, 및 GEMV로 이어지는 어텐션 레이어를 이루는 노드들을하나의 노드로 병합하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 병합된 노드의 데이터는, 쿼리 특성 맵 데이터(query feature map), 키 특성 맵 데이터(key feature map), 및 값 특성 맵 데이터(valuefeature map) 중 적어도 하나의 데이터를 포함하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 호스트는, 상기 병합된 노드의 데이터 중에서 상기 값 특성 맵 데이터를 전처리하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서, 상기 호스트는, 상기 값 특성 맵 데이터의 각 요소를 로그 연산하고, 상기 로그 연산된 값을 상기 쿼리 특성 맵 데이터의 각 요소의 합으로 나누는 것으로 전처리를 수행하는 것을 특징으로 하는 인공지능 연산 시스템.공개특허 10-2024-0097671-3-청구항 6 제1항에 있어서, 메모리를 더 포함하고, 상기 호스트는, 상기 전처리된 데이터와 전처리되지 않은 데이터를 상기 메모리에 저장하고, 각 연산기에서 필요로 하는 데이터를 상기 메모리로부터 추출하여 분배하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서, 상기 호스트는,상기 노드의 병합으로 생성된 새로운 연산을 서로 의존성이 없는 연산들로 나누고, 상기 나누어진 연산들을 상기 복수의 연산기에 분배하며, 상기 전처리된 데이터와 전처리되지 않은 데이터 중에서 각 연산기에서 수행할연산에 필요한 데이터를 각 연산기에 분배하는 것을 특징으로 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 상기 복수의 연산기 각각은, 상기 분배된 데이터를 저장하는 내부 메모리;복수의 프로세싱 엘리먼트(processing element)를 포함하는 프로세싱 엘리먼트 어레이; 및상기 호스트의 요청에 따라 상기 프로세싱 엘리먼트의 동작 및 프로세싱 엘리먼트들 사이의 데이터 이동을 제어하는 제어기를 포함하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서, 상기 복수의 프로세싱 엘리먼트는, 상기 내부 메모리에 저장된 데이터 중에서 행 방향 데이터와 열 방향의 데이터를 상기 제어기를 통해 수신받아덧셈 연산하는 복수의 덧셈기;상기 내부 메모리에 저장된 데이터 중에서 행 방향 데이터를 상기 제어기를 통해 수신받고, 상기 행 방향 데이터와 상기 복수의 덧셈기의 출력 값을 곱 연산하는 복수의 곱셈기; 및상기 복수의 곱셈기의 출력 값에 대해 지수(exponent) 연산을 수행하고, 지수 출력 값들을 누적 곱 연산하는 복수의 지수 연산 및 곱셈기를 포함하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 복수의 지수 연산 및 곱셈기 각각은, 각 곱셈기의 출력 값에 대해 지수를 출력하도록 하는 룩업테이블을 포함하는 것을 특징으로 하는 인공지능 연산시스템.공개특허 10-2024-0097671-4-청구항 11 제8항에 있어서, 상기 프로세싱 엘리먼트 어레이는, 시스톨릭 어레이(systolic array)에 기반하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "복수의 연산기; 트랜스포머 모델에서 특정 어텐션 레이어를 이루는 노드들을 병합하고, GEMV를 GEMM으로 변환하기 위해 상기 병합된 노드의 데이터 중에서 특정 행렬 데이터를 전처리하며, 상기 복수의 연산기에서 GEMM 병렬 수행을 위해 상기 전처리된 데이터와 전처리되지 않은 데이터를 상기 복수의 연산기에 분배하고, 상기 복수의 연산기의 연산결과를 합하여 정규화하는 호스트; 및상기 전처리된 데이터와 전처리되지 않은 데이터를 저장하는 메모리를 포함하되, 상기 복수의 연산기 각각은, 상기 분배된 데이터에 기초하여 행/열 방향의 데이터를 입력받아 덧셈 연산을 수행하고, 상기 분배된 데이터에기초하여 행 방향의 데이터를 입력받아 상기 덧셈 연산 값과 곱 연산을 수행하며, 곱 연산 값에 대해 지수(exponent) 연산을 수행하며, 지수 연산 값에 대해 누적 곱 연산을 수행함으로써, GEMM 연산을 병렬로 수행하는것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서,상기 호스트는,GEMV, softmax, 및 GEMV로 이어지는 어텐션 레이어를 이루는 노드들을 하나의 노드로 병합하는 것을 특징으로하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제12항에 있어서, 상기 병합된 노드의 데이터는, 쿼리 특성 맵 데이터(query feature map), 키 특성 맵 데이터(key feature map), 및 값 특성 맵 데이터(valuefeature map) 중 적어도 하나의 데이터를 포함하고, 상기 호스트는, 상기 병합된 노드의 데이터 중에서 상기 값 특성 맵 데이터의 각 요소를 로그 연산하고, 상기 로그 연산된 값을상기 쿼리 특성 맵 데이터의 각 요소의 합으로 나누는 것으로 전처리를 수행하는 것을 특징으로 하는 인공지능연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제12항에 있어서, 상기 복수의 연산기 각각은, 상기 분배된 데이터를 저장하는 내부 메모리;공개특허 10-2024-0097671-5-복수의 프로세싱 엘리먼트(processing element)를 포함하는 프로세싱 엘리먼트 어레이; 및상기 호스트의 요청에 따라 상기 프로세싱 엘리먼트의 동작 및 프로세싱 엘리먼트들 사이의 데이터 이동을 제어하는 제어기를 포함하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서, 상기 복수의 프로세싱 엘리먼트는, 상기 내부 메모리에 저장된 데이터 중에서 행 방향 데이터와 열 방향의 데이터를 상기 제어기를 통해 수신받아덧셈 연산하는 복수의 덧셈기;상기 내부 메모리에 저장된 데이터 중에서 행 방향 데이터를 상기 제어기를 통해 수신받고, 상기 행 방향 데이터와 상기 복수의 덧셈기의 출력 값을 곱 연산하는 복수의 곱셈기; 및상기 복수의 곱셈기의 출력 값에 대해 지수(exponent) 연산을 수행하고, 지수 출력 값들을 누적 곱 연산하는 복수의 지수 연산 및 곱셈기를 포함하는 것을 특징으로 하는 인공지능 연산 시스템."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "호스트가, 트랜스포머 모델에서 특정 어텐션 레이어를 이루는 노드들을 병합하는 단계;상기 호스트가, 상기 병합된 노드의 데이터 중에서 특정 행렬 데이터를 전처리하는 단계;상기 호스트가, 상기 전처리된 데이터와 전처리되지 않은 데이터를 복수의 연산기에 분배하는 단계;상기 복수의 연산기가, 상기 분배된 데이터를 이용하여 병렬 연산을 수행하는 단계; 및 상기 호스트가, 상기 복수의 연산기의 연산 결과를 합하여 정규화하는 단계를 포함하는, 인공지능 연산 방법."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서,상기 노드들을 병합하는 단계에서, 상기 호스트는, GEMV, softmax, 및 GEMV로 이어지는 어텐션 레이어를 이루는 노드들을 하나의 노드로 병합하는것을 특징으로 하는 인공지능 연산 방법."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제17항에 있어서, 상기 특정 행렬 데이터를 전처리하는 단계에서, 상기 호스트는, 쿼리 특성 맵 데이터, 키 특성 맵 데이터, 및 값 특성 맵 데이터 중 적어도 하나를 포함하는 병합된 노드의 데이터 중에서 상기 값 특성 맵 데이터의 각 요소를 로그 연산하고, 상기 로그 연산된 값을 상기쿼리 특성 맵 데이터의 각 요소의 합으로 나누는 것으로 전처리를 수행하는 것을 특징으로 하는 인공지능 연산방법."}
{"patent_id": "10-2023-0033432", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "공개특허 10-2024-0097671-6-제17항에 있어서, 상기 병렬 연산을 수행하는 단계는, 각 연산기의 제어기가, 상기 분배된 데이터를 내부 메모리에 저장하는 단계;각 연산기의 복수의 덧셈기가, 상기 내부 메모리에 저장된 데이터 중에서 행 방향 데이터와 열 방향의 데이터를상기 제어기를 통해 수신받아 덧셈 연산하는 단계;각 연산기의 복수의 곱셈기가, 상기 내부 메모리에 저장된 데이터 중에서 행 방향 데이터를 상기 제어기를 통해수신받고, 상기 행 방향 데이터와 상기 복수의 덧셈기의 출력 값을 곱 연산하는 단계; 및각 연산기의 복수의 지수 연산 및 곱셈기가, 상기 복수의 곱셈기의 출력 값에 대해 지수(exponent) 연산을 수행하고, 지수 출력 값들을 누적 곱 연산하는 단계를 포함하는 것을 특징으로 하는 인공지능 연산 방법."}
{"patent_id": "10-2023-0033432", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 인공지능 연산 시스템에 관한 것으로, 복수의 연산기, 및 트랜스포머 모델에서 특정 어텐션 레이어를 이루는 노드들을 병합하고, 상기 병합된 노드의 데이터 중에서 특정 행렬 데이터를 전처리하며, 상기 전처리된 데이터와 전처리되지 않은 데이터를 상기 복수의 연산기에 분배하고, 상기 복수의 연산기의 연산 결과를 합하여 정규화하는 호스트를 포함하되, 상기 복수의 연산기는, 상기 분배된 데이터를 이용하여 GEMM(GEneral Matrix Matrix multiplication) 연산을 병렬로 수행할 수 있다."}
{"patent_id": "10-2023-0033432", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 인공지능 연산 시스템 및 방법에 관한 것으로, 보다 상세하게는 시스톨릭 어레이 기반 연산기의 시간 당 리소스 사용량을 증가시킬 수 있도록 하는 인공지능 연산 시스템 및 방법에 관한 것이다."}
{"patent_id": "10-2023-0033432", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "셀프 어텐션 연산을 기반으로 하는 트랜스포머 모델은 처음 적용된 분야인 텍스트 및 음성과 같은 시퀀스 기반 응용뿐만 아니라 최근에는 비전 및 음성 기반의 다양한 응용 상황에 성공적으로 적용된 모델이다. 트랜스포머 모델은 응용 범위가 점차 증가할 뿐만 아니라 트랜스포머 모델의 크기 또한 점점 커져 트랜스포머 모델 연산 가 속에 대한 필요성이 대두되고 있다. 그러나 시스톨릭 어레이에서 트랜스포머 모델 추론을 가속할 때 GEMV(GEneral Matrix Vector multiplication) 연산으로 인하여 연산기 리소스 사용량이 저하되는 단점이 있다."}
{"patent_id": "10-2023-0033432", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "본 발명의 배경기술은 대한민국 등록특허 제10-2335955호(2021.12.08)에 개시되어 있다."}
{"patent_id": "10-2023-0033432", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 상기와 같은 문제점을 해결하기 위한 것으로서, 시스톨릭 어레이 기반 연산기의 시간당 리소스 사용 량을 증가시킬 수 있도록 하는 인공지능 연산 시스템 및 방법을 제공하는데 그 목적이 있다."}
{"patent_id": "10-2023-0033432", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 일부 실시 예에 따른 인공지능 연산 시스템은, 복수의 연산기, 및 트랜스포머 모델에서 특정 어텐션 레이어를 이루는 노드들을 병합하고, 상기 병합된 노드의 데이터 중에서 특정 행렬 데이터를 전처리하며, 상기 전처리된 데이터와 전처리되지 않은 데이터를 상기 복수의 연산기에 분배하고, 상기 복수의 연산기의 연산 결과 를 합하여 정규화하는 호스트를 포함하되, 상기 복수의 연산기는, 상기 분배된 데이터를 이용하여 GEMM(GEneral Matrix Matrix multiplication) 연산을 병렬로 수행할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 호스트는, GEMV(GEneral Matrix Vector multiplication), softmax, 및 GEMV로 이어지는 어텐션 레이어를 이루는 노드들을 하나의 노드로 병합할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 병합된 노드의 데이터는, 쿼리 특성 맵 데이터(query feature map), 키 특성 맵 데이터(key feature map), 및 값 특성 맵 데이터(value feature map) 중 적어도 하나의 데이터를 포함 할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 호스트는, 상기 병합된 노드의 데이터 중에서 상기 값 특성 맵 데이터 를 전처리할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 호스트는, 상기 값 특성 맵 데이터의 각 요소를 로그 연산하고, 상기 로그 연산된 값을 상기 쿼리 특성 맵 데이터의 각 요소의 합으로 나누는 것으로 전처리를 수행할 수 있다. 본 발명의 일부 실시 예에 있어서, 인공지능 연산 시스템은 메모리를 더 포함하고, 상기 호스트는, 상기 전처리 된 데이터와 전처리되지 않은 데이터를 상기 메모리에 저장하고, 각 연산기에서 필요로 하는 데이터를 상기 메 모리로부터 추출하여 분배할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 호스트는, 상기 노드의 병합으로 생성된 새로운 연산을 서로 의존성이 없는 연산들로 나누고, 상기 나누어진 연산들을 상기 복수의 연산기에 분배하며, 상기 전처리된 데이터와 전처 리되지 않은 데이터 중에서 각 연산기에서 수행할 연산에 필요한 데이터를 각 연산기에 분배할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 복수의 연산기 각각은, 상기 분배된 데이터를 저장하는 내부 메모리, 복수의 프로세싱 엘리먼트(processing element)를 포함하는 프로세싱 엘리먼트 어레이, 및 상기 호스트의 요청 에 따라 상기 프로세싱 엘리먼트의 동작 및 프로세싱 엘리먼트들 사이의 데이터 이동을 제어하는 제어기를 포함 할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 복수의 프로세싱 엘리먼트는, 상기 내부 메모리에 저장된 데이터 중에 서 행 방향 데이터와 열 방향의 데이터를 상기 제어기를 통해 수신받아 덧셈 연산하는 복수의 덧셈기, 상기 내 부 메모리에 저장된 데이터 중에서 행 방향 데이터를 상기 제어기를 통해 수신받고, 상기 행 방향 데이터와 상 기 복수의 덧셈기의 출력 값을 곱 연산하는 복수의 곱셈기, 및 상기 복수의 곱셈기의 출력 값에 대해 지수 (exponent) 연산을 수행하고, 지수 출력 값들을 누적 곱 연산하는 복수의 지수 연산 및 곱셈기를 포함할 수 있 다. 본 발명의 일부 실시 예에 있어서, 상기 복수의 지수 연산 및 곱셈기 각각은, 각 곱셈기의 출력 값에 대해 지수 를 출력하도록 하는 룩업테이블을 포함할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 프로세싱 엘리먼트 어레이는, 시스톨릭 어레이(systolic array)에 기반 할 수 있다. 본 발명의 일부 실시 예에 따른 인공지능 연산 시스템은, 복수의 연산기, 트랜스포머 모델에서 특정 어텐션 레 이어를 이루는 노드들을 병합하고, GEMV를 GEMM으로 변환하기 위해 상기 병합된 노드의 데이터 중에서 특정 행 렬 데이터를 전처리하며, 상기 복수의 연산기에서 GEMM 병렬 수행을 위해 상기 전처리된 데이터와 전처리되지 않은 데이터를 상기 복수의 연산기에 분배하고, 상기 복수의 연산기의 연산 결과를 합하여 정규화하는 호스트, 및 상기 전처리된 데이터와 전처리되지 않은 데이터를 저장하는 메모리를 포함하되, 상기 복수의 연산기 각각은, 상기 분배된 데이터에 기초하여 행/열 방향의 데이터를 입력받아 덧셈 연산을 수행하고, 상기 분배된 데이터에 기초하여 행 방향의 데이터를 입력받아 상기 덧셈 연산 값과 곱 연산을 수행하며, 곱 연산 값에 대해 지수(exponent) 연산을 수행하며, 지수 연산 값에 대해 누적 곱 연산을 수행함으로써, GEMM 연산을 병렬로 수행 할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 호스트는, GEMV, softmax, 및 GEMV로 이어지는 어텐션 레이어를 이루는 노드들을 하나의 노드로 병합할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 병합된 노드의 데이터는, 쿼리 특성 맵 데이터(query feature map), 키 특성 맵 데이터(key feature map), 및 값 특성 맵 데이터(value feature map) 중 적어도 하나의 데이터를 포함 하고, 상기 호스트는, 상기 병합된 노드의 데이터 중에서 상기 값 특성 맵 데이터의 각 요소를 로그 연산하고, 상기 로그 연산된 값을 상기 쿼리 특성 맵 데이터의 각 요소의 합으로 나누는 것으로 전처리를 수행할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 복수의 연산기 각각은, 상기 분배된 데이터를 저장하는 내부 메모리, 복수의 프로세싱 엘리먼트(processing element)를 포함하는 프로세싱 엘리먼트 어레이, 및 상기 호스트의 요청 에 따라 상기 프로세싱 엘리먼트의 동작 및 프로세싱 엘리먼트들 사이의 데이터 이동을 제어하는 제어기를 포함 할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 복수의 프로세싱 엘리먼트는, 상기 내부 메모리에 저장된 데이터 중에 서 행 방향 데이터와 열 방향의 데이터를 상기 제어기를 통해 수신받아 덧셈 연산하는 복수의 덧셈기, 상기 내 부 메모리에 저장된 데이터 중에서 행 방향 데이터를 상기 제어기를 통해 수신받고, 상기 행 방향 데이터와 상 기 복수의 덧셈기의 출력 값을 곱 연산하는 복수의 곱셈기, 상기 복수의 곱셈기의 출력 값에 대해 지수 (exponent) 연산을 수행하고, 지수 출력 값들을 누적 곱 연산하는 복수의 지수 연산 및 곱셈기를 포함할 수 있 다. 본 발명의 일부 실시 예에 따른 인공지능 연산 방법은, 호스트가, 트랜스포머 모델에서 특정 어텐션 레이어를 이루는 노드들을 병합하는 단계, 상기 호스트가, 상기 병합된 노드의 데이터 중에서 특정 행렬 데이터를 전처리 하는 단계, 상기 호스트가, 상기 전처리된 데이터와 전처리되지 않은 데이터를 복수의 연산기에 분배하는 단계, 상기 복수의 연산기가, 상기 분배된 데이터를 이용하여 병렬 연산을 수행하는 단계, 및 상기 호스트가, 상기 복 수의 연산기의 연산 결과를 합하여 정규화하는 단계를 포함한다. 본 발명의 일부 실시 예에 있어서, 상기 노드들을 병합하는 단계에서, 상기 호스트는, GEMV, softmax, 및 GEMV 로 이어지는 어텐션 레이어를 이루는 노드들을 하나의 노드로 병합할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 특정 행렬 데이터를 전처리하는 단계에서, 상기 호스트는, 쿼리 특성 맵 데이터, 키 특성 맵 데이터, 및 값 특성 맵 데이터 중 적어도 하나를 포함하는 병합된 노드의 데이터 중에서 상기 값 특성 맵 데이터의 각 요소를 로그 연산하고, 상기 로그 연산된 값을 상기 쿼리 특성 맵 데이터의 각 요 소의 합으로 나누는 것으로 전처리를 수행할 수 있다. 본 발명의 일부 실시 예에 있어서, 상기 병렬 연산을 수행하는 단계는, 각 연산기의 제어기가, 상기 분배된 데 이터를 내부 메모리에 저장하는 단계, 각 연산기의 복수의 덧셈기가, 상기 내부 메모리에 저장된 데이터 중에서 행 방향 데이터와 열 방향의 데이터를 상기 제어기를 통해 수신받아 덧셈 연산하는 단계, 각 연산기의 복수의 곱셈기가, 상기 내부 메모리에 저장된 데이터 중에서 행 방향 데이터를 상기 제어기를 통해 수신받고, 상기 행 방향 데이터와 상기 복수의 덧셈기의 출력 값을 곱 연산하는 단계, 및 각 연산기의 복수의 지수 연산 및 곱셈기 가, 상기 복수의 곱셈기의 출력 값에 대해 지수(exponent) 연산을 수행하고, 지수 출력 값들을 누적 곱 연산하 는 단계를 포함할 수 있다."}
{"patent_id": "10-2023-0033432", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 일부 실시 예에 따른 인공지능 연산 시스템 및 방법은, GEMV, Softmax, 및 GEMV로 이어지는 어텐션 레이어의 노드들을 병합함으로써, 시스톨릭 어레이에서 연산하기에 비효율적인 GEMV 연산을 GEMM 연산으로 변환 하여 시간당 리소스 사용량을 증가시킬 수 있도록 하는 효과가 있다. 본 발명의 일부 실시 예에 따른 인공지능 연산 시스템 및 방법은, 변환 과정에서 독립적인 여러 개의 GEMM 연산 으로 나누어 여러 개의 연산기에서 병렬적으로 GEMM을 수행하는 것을 가능하게 함으로써 연산 효율을 극대화시 킬 수 있도록 하는 효과가 있다."}
{"patent_id": "10-2023-0033432", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하에서는 본 발명의 일 실시 예에 따른 인공지능 연산 시스템 및 방법을 첨부된 도면들을 참조하여 상세하게 설명한다. 이러한 과정에서 도면에 도시된 선들의 두께나 구성요소의 크기 등은 설명의 명료성과 편의상 과장되 게 도시되어 있을 수 있다. 또한 후술되는 용어들은 본 발명에서의 기능을 고려하여 정의된 용어들로서, 이는 이용자, 운용자의 의도 또는 관례에 따라 달라질 수 있다. 그러므로 이러한 용어들에 대한 정의는 본 명세서 전 반에 걸친 내용을 토대로 내려져야 할 것이다. 딥러닝 모델은 이전의 컨볼루션 기반 모델, 순환 신경망 기반 모델을 거쳐 트랜스포머 모델로 개발 트렌드가 변 화하고 있다. 트랜스포머 모델은 어텐션 레이어 기반이며 모델의 사이즈가 매우 커 가속의 필요성이 매우 큰 모 델 중 하나이다. 트랜스포머 모델은 BERT(Bidirectional Encoder Representationsfrom Transformers), GPT(Generative PretrainedTransformer) 등 다양하게 존재한다. 트랜스포머 모델 중 GPT2 모델은 도 1의 (a)에 도시된 바와 같 이 Matmul, Softmax, 및 Matmul로 이루어지는 어텐션 레이어가 12번 반복되고, 이로 인해 512번의 연산을 반복 하게 된다. 그리고, 어텐션 레이어 고유의 연산 특성으로 인하여, Matmul 연산자는 512번의 연산 중 첫 번째 연 산에서는 행렬과 행렬의 곱인 GEMM(GEneral Matrix Matrix multiplication)이지만, 나머지 511번의 연산은 벡 터와 행렬의 곱인 GEMVGEMV(GEneral Matrix Vector multiplication) 연산이 된다. 이러한 GEMV 연산은 전통적인 NPU 구조인 시스톨릭 어레이에서 처리할 경우 시간당 리소스 사용량이 낮아 가속 의 효과를 저해시키는 요인이 되는데, 도 1의 (b)에 도시된 바와 같이, 행렬과 다르게 벡터는 연산기의 일부분 에 데이터를 공급하므로 리소스 사용량이 매우 낮으며, 이는 시간당 처리할 수 있는 연산량을 감소시키기 때문 이다. 이에, 본 발명은 트랜스포머 모델의 어텐션 레이어를 재구성함으로써 시스톨릭 어레이에서 트랜스포머 모델을 가속할 때 시간당 리소스 사용량을 늘려 가속 효과를 증가시키는 기술을 제안한다. 본 발명은 시스톨릭 어레이에서 트랜스포머 모델 추론을 가속할 때 GEMV 연산으로 인하여 연산기 리소스 사용량 이 저하되는 기술적 과제를 해결하기 위하여 트랜스포머 모델의 어텐션 레이어 재구성 및 데이터 분배 방법을 제안하여 연산 효율을 높이고자 하는 기술이다. 본 발명은 텍스트, 이미지, 음성 기반의 다양한 응용 시스템에 적용될 수 있는 트랜스포머 모델의 근간을 이루 는 어텐션 레이어를 시스톨릭 어레이 기반 가속기에서 효율적으로 구동하기 위하여 어텐션 레이어를 재구성하고 연산기 내부 메모리에 데이터를 분배하는 기술에 관한 것이다. 본 발명은 GEMV(행렬과 벡터의 곱), softmax, GEMV로 이어지는 트랜스포머 모델의 어텐션 레이어를 효율적으로 연산하기 위한 방법에 관한 것이다. 도 2는 본 발명의 일 실시 예에 따른 인공지능 연산 시스템을 설명하기 위한 블록 구성도, 도 3은 본 발명의 일 실시 예에 따른 GEMV, softmax 및 GEMV로 이루어지는 어텐션 레이어를 이루는 노드들의 병합을 설명하기 위한 예시도, 도 4는 종래의 GEMV, softmax 및 GEMV 연산을 설명하기 위한 예시도, 도 5는 본 발명의 일 실시 예에 따른 행렬 데이터의 전처리를 설명하기 위한 예시도, 도 6은 본 발명의 일 실시 예에 따른 연산기를 설명하기 위한 도면, 도 7은 본 발명의 일 실시 예에 따른 프로세싱 엘리먼트의 구성을 설명하기 위한 도면, 도 8a 및 도 8b는 본 발명의 일 실시 예에 따른 복수의 연산기에서 GEMM 연산을 병렬로 수행하는 방법을 설명하기 위한 예시도, 도 9는 본 발명의 일 실시 예에 따른 복수의 연산기의 연산 결과를 합하여 정규화하는 방법을 설명하기 위 한 예시도이다. 도 2를 참조하면, 본 발명의 일 실시 예에 따른 인공지능 연산 시스템은 호스트, 메모리, 및 복수의 연산기(300a, 300b,,, 300n, 이하 '300'이라 칭함)를 포함한다. 호스트는 인공지능 연산 시스템의 전반적인 동작을 제어할 수 있다. 예를 들어, 호스트는 커맨드 및 데이터를 제공하여 복수의 연산기를 제어할 수 있다. 호스트는 트랜스포머 모델에서 특정 어텐션 레이어를 이루는 노드들을 병합하고, 병합된 노드의 데이터 중 에서 특정 행렬 데이터를 전처리하며, 전처리된 데이터와 전처리되지 않은 데이터를 복수의 연산기에 분배 하고, 복수의 연산기의 연산 결과를 합하여 정규화할 수 있다. 이하, 호스트의 동작에 대해 구체적으로 설명하기로 한다. 호스트는 트랜스포머 모델에서 GEMV, softmax, 및 GEMV로 이어지는 어텐션 레이어를 이루는 노드들을 하나 의 노드로 병합할 수 있다. 이때, 병합된 노드의 데이터는 쿼리 특성 맵 데이터(query feature map; q), 키 특 성 맵 데이터(key feature map; K), 및 값 특성 맵 데이터(value feature map; V)를 포함할 수 있다. 즉, 호스트는 처음 트랜스포머 모델을 읽고, 트랜스포머 모델 그래프를 점점 단순화 하면서 lowering 단계 를 수행할 수 있다. 예를 들어, 호스트는 불필요한 노드를 삭제하고, 한번에 연산할 수 있는 여러 개의 노 드를 병합하면서 그래프를 점점 단순화시킬 수 있다. 이때, 모델 그래프에 GEMV, softmax, 및 GEMV가 있는 것으 로 확인되면, 호스트는 GEMV, softmax 및 GEMV을 하나의 노드로 병합하여, 같은 입력(input)을 받아들이고, 같은 출력(output)을 출력하는 새로운 이름의 연산자(MSM)를 생성할 수 있다. 이처럼, 호스트는 여러 개의 노드를 병합하여 같은 입력(input)을 받아들이고, 같은 출력(output)을 출력 하는 새로운 이름의 연산자를 생성할 수 있다. 즉, 호스트는 도 3의 (a)에 도시된 바와 같이 GEMV, softmax, 및 GEMV로 이어지는 어텐션 레이어를 이루는 노드들을 병합하여 도 3의 (b)에 도시된 바와 같이 같은 입력(input)을 받아들이고, 같은 출력(output)을 출력하는 새로운 이름의 연산자를 생성할 수 있다. 그러면, 호 스트의 컴파일러(미도시)의 하단에서는 GEMV, softmax, 및 GEMV를 읽는 것이 아니라 MSM을 읽게 되고, MSM 에 맞는 연산을 출력하게 된다. 예를 들어, 도 3의 (a)에 도시된 바와 같이 Matmul(제1 GEMV), softmax, 및 Matmul(제2 GEMV) 연산을 차례로 수행하는 경우에 대해 설명하기로 한다. 이때, 쿼리 특성 맵 데이터(q)가 a, b이고, 키 특성 맵 데이터(K)가 c, d, e, f이며, 값 특성 맵 데이터(V)가 g, h, i, j라고 가정하여 설명하기로 한다. 제1 GEMV 연산은 도 4의 (a)와 같이 수행될 수 있고, 제1 GEMV 연산 결과 벡터의 각 요소는 ac+be와 ad+bf 일 수 있다. softmax 연산은 도 4의 (b)와 같이 수행될 수 있고, softmax 연산 결과 벡터의 각 요소는 eac+be/(eac+be + ead+bf) 및 ead+bf/(eac+be + ead+bf) 일 수 있다. 제2 GEMV 연산은 도 4의 (c)와 같이 수행될 수 있고, 제2 GEMV 연산 결과 벡터의 각 요소 는 g·eac+be/(eac+be + ead+bf) + i·ead+bf/(eac+be + ead+bf) 및 h·eac+be/(eac+be + ead+bf) + j·ead+bf/(eac+be + ead+bf)일 수 있다. 이처럼, GEMV 연산, softmax 연산, 및 GEMV 연산을 차례로 수행하는 것은 시스톨릭 어레이 기반의 연 산기에서 연산을 할 때 연산기 리소스 사용량 면에서 비효율적이다. 이에, 본 발명은 GEMV 연산, softmax 연산, 및 GEMV 연산의 세 노드를 병합하여 GEMV 연산을 GEMM 연산화함으로 써, 시스톨릭 어레이의 시간당 리소스 사용량을 증가시킬 수 있다. 이를 위해, 호스트는 GEMV 연산, softmax 연산, 및 GEMV 연산으로 이어지는 어텐션 레이어를 이루는 노드들을 병합할 수 있다. 그런 후, 호스트는 GEMV 연산을 GEMM으로 변환하기 위해 필요한 행렬 데이터를 전처리할 수 있다. 이때, 호스트는 병합된 노드의 데이터 중에서 값 특성 맵 데이터(V)를 전처리할 수 있다. 즉, 호스트는 값 특성 맵 데이터(V)의 각 요소를 로그 연산하고, 로그 연산된 값을 쿼리 특성 맵 데이터(q) 각 요소의 합으로 나 누는 것으로 전처리를 수행할 수 있다. 예를 들면, 호스트는 도 5에 도시된 바와 같이 값 특성 맵 데이터(V)를 전처리할 수 있다. 즉, 호스트 는 값 특성 맵 데이터(V)인 g, h, i, 및 j를 각각 로그 연산하여, log(g), log(h), log(i), 및 log(j)를 획득할 수 있다. 그런 후, 호스트는 log(g), log(h), log(i), 및 log(j) 각각을 쿼리 특성 맵 데이터(q) 인 a, b의 합(k'=1/a+b)으로 나누어, g'=log(g)/k', h'=log(h)/k', i'=log(i)/k', j'=log(j)/k'과 같은 전처리 된 행렬 데이터를 획득할 수 있다.이처럼, 호스트는 쿼리 특성 맵 데이터(q), 키 특성 맵 데이터(K), 및 값 특성 맵 데이터(V)를 포함하는 병합된 노드의 데이터 중에서 값 특성 맵 데이터(V)만을 그대로 사용하지 않고 전처리하여 연산기에 전달 할 수 있다. 호스트는 쿼리 특성 맵 데이터(q)와 키 특성 맵 데이터(K)를 전처리하지 않고 그대로 사용할 수 있다. 특정 행렬 데이터의 전처리가 완료되면, 호스트는 전처리된 데이터와 전처리되지 않은 데이터를 메모리 에 저장하고, 각 연산기에서 필요로 하는 데이터(요소(elements))를 메모리로부터 추출하여 분 배할 수 있다. 즉, 호스트는 노드들의 병합으로 생성된 새로운 연산(MSM)을 서로 의존성이 없는 연산들로 나누고, 나누어진 연산들을 각 연산기에 분배하며, 전처리된 데이터와 전처리되지 않은 데이터 중에서 각 연산기에서 수행할 연산에 필요한 데이터를 각 연산기에 분배할 수 있다. 다시 말하면, 호스트 는 쿼리 특성 맵 데이터(q), 키 특성 맵 데이터(K), 및 전처리된 값 특성 맵 데이터(V') 중 각 연산기에서 수행할 연산에 필요한 데이터를 각 연산기에 분배할 수 있다. 호스트는 노드들의 병합으로 생성된 병합된 연산(MSM)을 서로 의존성이 없는 연산들로 나누고, 각 연산들 을 각 연산기에서 독립적으로 수행할 수 있도록 한다. 이때, 각 연산기에서 수행하는 연산에 따라 연 산에 필요한 데이터가 달라질 수 있다. 따라서, 호스트는 전처리된 데이터와 전처리되지 않은 데이터를 메 모리에 저장해 놓고, 각 연산기에서 필요로 하는 elements를 분배할 수 있다. 또한, 호스트는 복수의 연산기의 연산 결과를 합한 후, 정규화할 수 있다. 정규화가 수행되면, 호스 트는 GEMV, softmax, 및 GEMV 연산을 차례로 수행한 결과와 동일한 연산 결과를 획득할 수 있다. 정규화하 는 방법은 종래의 방법과 동일하므로 이에 대한 설명은 생략하기로 한다. 메모리는 호스트에서 전처리된 데이터와 전처리되지 않은 데이터를 저장할 수 있다. 즉, 메모리(20 0)에는 쿼리 특성 맵 데이터(query feature map; q), 키 특성 맵 데이터(key feature map; K), 및 전처리된 값 특성 맵 데이터(V')가 저장될 수 있다. 메모리는 호스트의 제어에 따라 데이터를 기록하거나 데이터를 독출할 수 있다. 예를 들어, 메모리 는 호스트로부터 제공된 커맨드 및 어드레스에 응답하여 데이터를 기록하거나, 독출된 데이터를 연산 기로 제공할 수 있다. 이러한 메모리는 DRAM, SRAM 등과 같이 전원이 차단되면 데이터가 소실되는 휘발성 메모리이거나 또는 플 래시 메모리, PRAM, ReRAM, MRAM, FRAM 등과 같이 전원이 차단되더라도 데이터가 유지되는 불휘발성 메모리 중 어느 하나일 수 있다. 복수의 연산기는 호스트에서 분배된 데이터를 내부 메모리에 로딩하고, 분배된 데이터를 이용하 여 병렬 연산을 수행할 수 있다. 이때, 복수의 연산기는 분배된 데이터를 이용하여 GEMM 연산을 병렬로 수 행할 수 있다. 각 연산기는 행 방향의 데이터와 열 방향의 데이터를 받아 덧셈 연산을 수행하고, 행 방향의 데이터를 받 아 덧셈 연산 값과 곱 연산을 수행하며, 곱 연산 값에 대해 지수(exponent) 연산을 수행하며, 지수 연산 값에 대해 누적 곱 연산 후 저장할 수 있다. 이러한 연산기는 도 6에 도시된 바와 같이 내부 메모리, 제어기 및 프로세싱 엘리먼트 어레이 를 포함할 수 있다. 내부 메모리에는 호스트에 의해 분배된 데이터가 저장될 수 있다. 제어기는 내부 메모리 및 프로세싱 엘리먼트 어레이의 동작을 제어할 수 있다. 또한, 제어기는 프로세싱 엘리먼트들의 동작 및 복수의 연산 모드에 대응하여 프로세싱 엘리먼트 들 사이의 데이터 이동을 제어할 수 있다. 제어기는 컨트롤 경로(control path)를 통하여 프로세싱 엘리먼트들을 제어할 수 있다. 프로세싱 엘리먼트 어레이는 복수의 프로세싱 엘리먼트(Processing Element, PE, 340)를 포함할 수 있다. 프로세싱 엘리먼트 어레이는 시스톨릭 어레이(systolic array) 구조를 가질 수 있다. 복수의 프로세싱 엘리먼트(PE, 340)는 어레이 형태로 연결되어, 이웃 프로세싱 엘리먼트(PE, 340) 간의 데이터 를 주고받으며 연산을 수행할 수 있다. 입력 데이터는 호스트에 의해 분배되어 내부 메모리에 저장된 데이터일 수 있다. 각각의 프로세싱 엘리먼트(PE, 340)는 입력 데이터를 수신하고, 주변의 프로세싱 엘리먼트(PE, 340)들로 입력 데이터를 전달할 수 있다. 프로세싱 엘리먼트(PE, 340)는 프로세싱 엘리먼트 어레이의 행(row) 방향으로 입력 데이터를 전달할 수 있다. 또는, 프로세싱 엘리먼트(PE, 340)는 프로세싱 엘리먼트 어레 이의 열(column) 방향으로 입력 데이터를 전달할 수 있다. 이와 같이, 프로세싱 엘리먼트(PE, 340)는 특정 방향(예를 들어, 행 및 열 방향 중 적어도 하나)으로 입력 데이터를 순차적으로 전달할 수 있다. 프로세싱 엘리 먼트(PE, 340)는 내부 메모리 또는 다른 프로세싱 엘리먼트(PE, 340)로부터 전달된 입력 데이터를 기반으 로 연산을 수행할 수 있다. 프로세싱 엘리먼트는 제어기의 제어에 의해 내부 메모리로부터 제공되는 입력 데이터를 기반으 로 연산을 수행할 수 있다. 예를 들어, 프로세싱 엘리먼트는 입력 데이터를 기반으로 덧셈 연산, 곱셈 연 산, 지수 연산 등을 수행할 수 있다. 복수의 프로세싱 엘리먼트는 도 7에 도시된 바와 같이 복수의 덧셈기, 복수의 곱셈기, 복수의 누적기(미도시) 및 복수의 지수 연산 및 곱셈기를 포함할 수 있다. 여기서, 복수의 지수 연산 및 곱셈기 는 프로세싱 엘리먼트 어레이의 행 방향과 열 방향의 끝에 위치할 수 있고, 지수 연산과 누적 곱 연 산을 수행할 수 있다. 각 덧셈기는 내부 메모리에 저장된 데이터 중에서 행 방향 데이터와 열 방향 데이터를 제어기를 통해 입력받고, 입력받은 행 방향 데이터와 열 방향 데이터를 덧셈 연산할 수 있다. 이때, 행 방향 데이터와 열 방향 데이터는 컴파일러 설계 시 미리 결정된 연산 방법에 따라 선택된 데이터(값)일 수 있다. 호스트는 연산자를 읽고, 연산기에 전달할 명령어를 출력하는 컴파일러를 실행할 수 있다. 이때 컴파 일러가 생성하는 명령어에 따라 행 방향 데이터와 열 방향 데이터에 어떤 값들을 입력할지 달라질 수 있다. 따 라서, 각 덧셈기에 입력되는 행 방향 데이터와 열 방향 데이터는 컴파일러 설계 시 미리 결정된 연산 방법 에 따라 선택될 수 있다. 이때, 행 방향 데이터와 열 방향 데이터의 방향이 바뀌더라도 연산의 결과는 동일하므 로, 연산기에 입력되는 행 데이터와 열 데이터의 방향은 고려하지 않아도 된다. 또한, 행 방향 데이터와 열 방향 데이터의 선택은 미리 디자인된 컴파일러의 결과일 수 있다. 컴파일러를 설계할 때 미리 GEMV, softmax, 및 GEMV를 순차적으로 연산한 결과와 이를 병합한 MSM 연산 결과를 동일하게 출력하기 위하여 어떤 순 서로 연산해야 하는지 컴파일러 설계 단계에서 결정될 수 있다. 따라서, 각 덧셈기에 입력되는 행 방향 데 이터와 열 방향 데이터는 미리 결정된 연산 방법에 따라 배치된 값일 수 있다. 각 곱셈기는 내부 메모리에 저장된 데이터 중에서 행 방향 데이터를 제어기를 통해 입력받고, 입력받은 행 방향 데이터와 각 덧셈기의 출력 값을 곱 연산할 수 있다. 이때, 입력되는 행 방향 데이터는 컴파일러 설계 시 미리 결정된 연산 방법에 따라 선택된 데이터(값)일 수 있다. 행 방향 데이터를 열 방향으로 입력해도 같은 결과를 획득할 수 있다. 각 지수 연산 및 곱셈기는 각 곱셈기의 출력 값에 대해 지수(exponent)를 출력하고, 그 지수 출력 값 을 누적 곱 연산할 수 있다. 즉, 각 지수 연산 및 곱셈기는 각 곱셈기의 출력 값에 대해 지수를 출력 하도록 하는 룩업테이블을 포함하고 있어서, 각 곱셈기의 출력 값에 대해 지수(exponent) 연산을 수행할 수 있다. 각 누적기는 각 지수 연산 및 곱셈기의 출력 값을 저장할 수 있다. 예를 들어, 연산기가 도 8에 도시된 바와 같이 제1 연산기(300a) 및 제2 연산기(300b)로 구성된 경우 GEMM 연산 병렬 처리 방법에 대해 설명하기로 한다. 메모리에 도 8의 (a)와 같이 데이터가 저장된 경우, 호스트는 제1 연산기(300a)에 a, b, c, e, g', h'의 데이터를 분배하고, 제2 연산기(300b)에 a, b, d, f, i', j'의 데이터를 분배할 수 있다. 즉, a, b로 이 루어진 벡터인 q는 제1 연산기(300a) 및 제2 연산기(300b)에 모두 분배되어 사용되고, c, d, e, f로 이루어진 행렬 K에서 첫 번째 열인 c, e는 제1 연산기(300a)에 분배되며 두 번째 열인 d, f는 제2 연산기(300b)에 분배될 수 있다. 마찬가지로, 전처리된 g', h', i', j'로 이루어진 V' 행렬은 첫 번째 행인 g', h'가 제1 연산기(300 a)에 분배되고, 두 번째 행인 i', j'가 제2 연산기(300b)에 분배될 수 있다. 그러면, 도 8의 (b)에 도시된 바와 같이 제1 연산기(300a)의 제1 내부 메모리(320a)에는 a, b, c, e, g', h'의 데이터를 저장되고, 제2 연산기(300b)의 제2 내부 메모리(320b)에는 a, b, d, f, i', j'의 데이터가 저장될 수 있다. 제1 연산기(300a)의 제1 제어기(310a)는 제1 내부 메모리(320a)에 저장된 데이터에서 행열 방향의 데이터(c, e, g', h', 0)를 복수의 덧셈기(342a)에 입력시킬 수 있다. 그러면, 제1 연산기(300a)의 각 덧셈기(342a)는 도 8의 (c)에 도시된 바와 같이 행 방향 데이터(c, e)와 열 방향 데이터(g', h', 0)를 더할 수 있다. 또한, 제2 연산기 (300b)의 제2 제어기(310b)는 제2 내부 메모리(320b)에 저장된 데이터에서 행열 방향의 데이터(d, f, i', j', 0)를 복수의 덧셈기(342b)로 입력시킬 수 있다. 그러면, 제2 연산기(300b)의 각 덧셈기(342b)는 도 8의 (c)에 도시된 바와 같이 행 방향 데이터(d, f)와 열 방향 데이터(i', j', 0)를 더할 수 있다. 제1 연산기(300a) 및 제2 연산기(300b)의 각 덧셈기(342a, 342b)의 출력 값은 제1 연산기(300a) 및 제2 연산기 (300b)의 곱셈기(344a, 344b)의 열 방향 데이터로 입력될 수 있고, 제1 연산기(300a) 및 제2 연산기(300b) 각 각의 곱셈기(344a, 344b)는 제1 제어기(310a) 및 제2 제어기(310b)에 의해 제1 내부 메모리(320a) 및 제2 내부 메모리(320b)에 저장된 데이터 중에서 행 방향 데이터를 입력받을 수 있다. 그러면, 제1 연산기(300a) 및 제2 연산기(300b) 각각의 곱셈기(344a, 344b)는 입력받은 행 방향 데이터와 열 방향 데이터를 곱할 수 있다. 예를 들면, 제1 연산기(300a)의 각 덧셈기(342a)의 출력 값(c+g', c+h', c, e+g', e+h', e)은 제1 연산기(300a)의 곱셈기(344b)의 열 방향 데이터로 입력될 수 있고, 제1 내부 메모리(320a)에 저장된 데이터 중에서 특정 데이터 (a,b)는 제1 연산기(300a)의 곱셈기(344a)의 행 방향 데이터로 입력될 수 있다. 그러면, 제1 연산기(300a)의 각 곱셈기(344a)는 도 8의 (d)에 도시된 바와 같이 행 방향 데이터(a,b)와 열 방향 데이터(c+g', c+h', c, e+g', e+h', e)를 곱할 수 있다. 그러면, 제1 연산기(300a)의 각 곱셈기(344a)는 ac+ag', ac+ah', ac, be+bg', be+bh', be를 출력할 수 있다. 또한, 제2 연산기(300b)의 각 덧셈기(342b)의 출력 값(d+i', d+j', d, f+i', f+j', f)은 제2 연산기(300b)의 곱셈기(344b)의 열 방향 데이터로 입력될 수 있고, 제2 내부 메모리(320b)에 저장된 데이터 중에서 특정 데이터 (a,b)는 제2 연산기(300b)의 곱셈기(344b)의 행 방향 데이터로 입력될 수 있다. 그러면, 제2 연산기(300b)의 각 곱셈기(344b)는 도 8의 (d)에 도시된 바와 같이 행 방향 데이터(a,b)와 열 방향 데이터(d+i', d+j', d, f+i', f+j', f)를 곱할 수 있다. 그러면, 제2 연산기(300b)의 각 곱셈기(344b)는 ad+ai', ad+aj', ad, bf+bi', bf+bj', bf를 출력할 수 있다. 제1 연산기(300a) 및 제2 연산기(300b) 각각의 곱셈기(344a, 344b)의 출력 값은 제1 연산기(300a) 및 제2 연산 기(300b) 각각의 지수 연산 및 곱셈기(346a, 346b)로 입력될 수 있다. 그러면, 제1 연산기(300a) 및 제2 연산기 (300b)의 지수 연산 및 곱셈기(346a, 346b)는 입력받은 곱셈기(344a, 344b)의 출력 값에 대해 지수(exponent) 를 출력하고, 그 지수 출력 값을 누적 곱 연산할 수 있다. 예를 들면, 도 8의 (e)에 도시된 바와 같이 제1 연산기(300a)의 곱셈기(344a)의 출력 값인 ac+ag', ac+ah', ac, be+bg', be+bh', be이 제1 연산기(300a)의 지수 연산 및 곱셈기(346a)로 입력되면, 제1 연산기(300a)의 지 수 연산 및 곱셈기(346a)는 geac+be, heac+be, eac+be를 출력할 수 있다. 구체적으로, 제1 연산기(300a)의 곱셈기 (344a)의 출력 값인 ac+ag' 및 be+bg'는 차례로 프로세싱 엘리먼트 어레이의 하단에 위치하는 지수 연산 및 곱셈기(346a)로 내려올 수 있다. be+bg'가 내려와 ebe+bg'가 연산되고 저장된 후, ac+ag'가 내려와 eac+ag'가 연 산되고, ebe+bg와 ac+ag'는 누적 곱 연산되어, 도 8의 (f)에 도시된 바와 같이 eac+ag'x ebe+bg'를 출력할 수 있다. eac+ag'x ebe+bg'는 geac+be와 동일할 수 있다. 또한, 제2 연산기(300b)의 곱셈기의 출력 값인 ad+ai', ad+aj', ad, bf+bi', bf+bj', bf이 제2 연산기 (300b)의 지수 연산 및 곱셈기(346b)에 입력되면, 제2 연산기(300b)의 지수 연산 및 곱셈기(346b)는 iead+bf, jead+bf, ead+bf를 출력할 수 있다. 제2 연산기(300b)의 지수 연산 및 곱셈기(346b)의 동작은 제1 연산기(300a)의 지수 연산 및 곱셈기(346a)의 동작과 동일하므로, 상세한 설명은 생략하기로 한다. 제1 연산기(300a)와 제2 연산기(300b)의 연산이 완료되면, 호스트는 제1 연산기(300a)의 연산 결과와 제2 연산기(300b)의 연산 결과를 합한 후, 정규화할 수 있다. 예를 들면, 호스트는 도 8의 (f)에 도시된 제1 연산기(300a)의 연산 결과인 geac+be, heac+be, eac+be과 제2 연산기(300b)의 연산 결과인 iead+bf, jead+bf, ead+bf를 각 각 합할 수 있다. 즉, 호스트는 도 9의 (a)에 도시된 바와 같이 geac+be과 iead+bf를 합하고, heac+be과 jead+bf 를 합하며, eac+be과 ead+bf를 합할 수 있다. 그런 후, 호스트는 합한 결과에 대해 정규화를 수행할 수 있다. 그러면, 호스트는 도 9의 (b)에 도시된 바와 같이 g·eac+be/(eac+be + ead+bf) + i·ead+bf/(eac+be + ead+bf) 및 h ·eac+be/(eac+be + ead+bf) + j·ead+bf/(eac+be + ead+bf)를 출력할 수 있다. 이 연산 결과는 GEMV, softmax, 및 GEMV연산을 순서대로 수행한 결과와 동일할 수 있다. 도 10은 본 발명의 일 실시 예에 따른 인공지능 연산 방법을 설명하기 위한 도면이다. 도 10을 참조하면, 호스트는 트랜스포머 모델에서 GEMV, softmax, 및 GEMV로 이어지는 어텐션 레이어를 이 루는 노드들을 하나의 노드로 병합한다(S1002). 호스트는 GEMV, softmax 및 GEMV을 하나의 노드로 병합하 여, 같은 입력(input)을 받아들이고, 같은 출력(output)을 출력하는 새로운 이름의 연산자(MSM)를 생성할 수 있 다. 이때, 병합된 노드의 데이터는 쿼리 특성 맵 데이터(query feature map; q), 키 특성 맵 데이터(key feature map; K), 및 값 특성 맵 데이터(value feature map; V)를 포함할 수 있다. S1002 단계가 수행되면, 호스트는 병합된 노드의 데이터 중에서 값 특성 맵 데이터(V)를 전처리한다 (S1004). 즉, 호스트는 값 특성 맵 데이터(V)의 각 요소를 로그 연산하고, 로그 연산된 값을 쿼리 특성 맵 데이터(q) 각 요소의 합으로 나누는 것으로 전처리를 수행할 수 있다. S1004 단계가 수행되면, 호스트는 전처리된 데이터와 전처리되지 않은 데이터를 메모리에 저장하고 (S1006), 각 연산기에서 필요로 하는 데이터(요소(elements))를 메모리로부터 추출하여 분배한다 (S1008). 즉, 호스트는 노드들의 병합으로 생성된 새로운 연산(MSM)을 서로 의존성이 없는 연산들로 나누 고, 나누어진 연산들을 각 연산기에 분배하며, 전처리된 데이터와 전처리되지 않은 데이터 중에서 각 연산 기에서 수행할 연산에 필요한 데이터를 각 연산기에 분배할 수 있다. 다시 말하면, 호스트는 쿼 리 특성 맵 데이터(q), 키 특성 맵 데이터(K), 및 전처리된 값 특성 맵 데이터(V') 중 각 연산기에서 수행 할 연산에 필요한 데이터를 각 연산기에 분배할 수 있다. S1008 단계가 수행되면, 복수의 연산기 각각은 호스트에 의해 분배된 데이터를 이용하여 GEMM 연산을 병렬로 수행한다(S1010). 연산기가 GEMM 연산하는 방법에 대해서는 도 11을 참조하기로 한다. S1010 단계가 수행되면, 호스트는 복수의 연산기의 연산 결과를 수신하고(S1012), 각 연산기의 연산 결과를 합한 후, 정규화한다(S1014). 정규화가 수행되면, 호스트는 GEMV, softmax, 및 GEMV 연산을 차례로 수행한 결과와 동일한 연산 결과를 획득할 수 있다 도 11은 본 발명의 일 실시 예에 따른 연산기의 GEMM 연산 방법을 설명하기 위한 흐름도이다. 도 11을 참조하면, 연산기의 제어기는 호스트에 의해 분배된 데이터를 내부 메모리에 저장 한다(S1102). S1102 단계가 수행되면, 연산기의 덧셈기는 내부 메모리에 저장된 데이터 중에서 행 방향 데이 터와 열 방향의 데이터를 제어기를 통해 수신받아 덧셈 연산한다(S1104). 이때, 행 방향 데이터와 열 방향 데이터는 컴파일러 설계 시 미리 결정된 연산 방법에 따라 선택된 데이터(값)일 수 있다. S1104 단계가 수행되면, 연산기의 곱셈기는 내부 메모리에 저장된 데이터 중에서 행 방향 데이 터를 제어기를 통해 수신받고, 행 방향 데이터와 덧셈기의 출력 값을 곱 연산한다(S1106). 이때, 입 력되는 행 방향 데이터는 컴파일러 설계 시 미리 결정된 연산 방법에 따라 선택된 데이터(값)일 수 있다. S1106 단계가 수행되면, 연산기의 지수 연산 및 곱셈기는 곱셈기의 출력 값에 대해 지수 (exponent)를 출력하고, 그 지수 출력 값을 누적 곱 연산한다(S1108). 즉, 지수 연산 및 곱셈기는 곱셈기 의 출력 값에 대해 지수를 출력하도록 하는 룩업테이블을 포함하고 있어서, 곱셈기의 출력 값에 대해 지수(exponent) 연산을 수행할 수 있다. 본 발명의 일부 실시 예에 따른 인공지능 연산 시스템 및 방법은, GEMV, Softmax, 및 GEMV로 이어지는 어텐션 레이어의 노드들을 병합함으로써, 시스톨릭 어레이에서 연산하기에 비효율적인 GEMV 연산을 GEMM 연산으로 변환 하여 시간당 리소스 사용량을 증가시킬 수 있도록 하는 효과가 있다. 본 발명의 일부 실시 예에 따른 인공지능 연산 시스템 및 방법은, 변환 과정에서 독립적인 여러 개의 GEMM 연산 으로 나누어 여러 개의 연산기에서 병렬적으로 GEMM을 수행하는 것을 가능하게 함으로써 연산 효율을 극대화시 킬 수 있도록 하는 효과가 있다. 본 발명은 도면에 도시된 실시 예를 참고로 하여 설명되었으나, 이는 예시적인 것에 불과하며, 당해 기술이 속 하는 분야에서 통상의 지식을 가진 자라면 이로부터 다양한 변형 및 균등한 타 실시 예가 가능하다는 점을 이해 할 것이다. 따라서 본 발명의 기술적 보호범위는 아래의 특허청구범위에 의해서 정하여져야 할 것이다."}
{"patent_id": "10-2023-0033432", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 종래 Matmul, Softmax 및 Matmul로 이루어지는 어텐션 레이어를 설명하기 위한 예시도이다. 도 2는 본 발명의 일 실시 예에 따른 인공지능 연산 시스템을 설명하기 위한 블록 구성도이다. 도 3은 본 발명의 일 실시 예에 따른 GEMV, softmax 및 GEMV로 이루어지는 어텐션 레이어를 이루는 노드들의 병 합을 설명하기 위한 예시도이다. 도 4는 종래의 GEMV, softmax 및 GEMV 연산을 설명하기 위한 예시도이다. 도 5는 본 발명의 일 실시 예에 따른 행렬 데이터의 전처리를 설명하기 위한 예시도이다. 도 6은 본 발명의 일 실시 예에 따른 연산기를 설명하기 위한 도면이다. 도 7은 본 발명의 일 실시 예에 따른 프로세싱 엘리먼트의 구성을 설명하기 위한 도면이다. 도 8a 및 도 8b는 본 발명의 일 실시 예에 따른 복수의 연산기에서 GEMM 연산을 병렬로 수행하는 방법을 설명하 기 위한 예시도이다. 도 9는 본 발명의 일 실시 예에 따른 복수의 연산기의 연산 결과를 합하여 정규화하는 방법을 설명하기 위한 예 시도이다. 도 10은 본 발명의 일 실시 예에 따른 인공지능 연산 방법을 설명하기 위한 도면이다. 도 11은 본 발명의 일 실시 예에 따른 연산기의 GEMM 연산 방법을 설명하기 위한 흐름도이다."}
