{"patent_id": "10-2008-7001465", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2008-0032099", "출원번호": "10-2008-7001465", "출원인": "마이크로소프트 코포레이션", "발명자": "메이저, 헨리쿠스, 요하네스, 마리아"}}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨터 프로그래밍 코드를 위한 번역 시스템(translation system)으로서,프로그래밍 코드를 수신하는 구문 분석(parser) 컴포넌트; 및제1 소스 언어의 구문(syntax), 연산(operation) 및 식별자 이름과, 제2 대상 언어의 식별자 구문, 연산 및 이름 간의 맵에 기초하여 코드의 구문론적(syntactic) 번역을 수행하는 번역 컴포넌트를 포함하는 번역 시스템."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 번역 컴포넌트는 상기 대상 언어 시맨틱(semantic)을 반영하기 위해, 상기 구문, 연산, 식(expression) 및/또는 스테이트먼트(statement)의 적어도 일부를 상기 대상 언어에 매핑하는 번역 시스템."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 번역 컴포넌트는 소스 언어 시맨틱을 반영하기 위해 상기 구문, 연산, 식 및/또는 스테이트먼트의 일부를매핑하는 번역 시스템."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 번역 컴포넌트는 식별자 이름을 축어적(verbatim)으로 상기 소스 언어로부터 상기 대상 언어로 매핑하는번역 시스템."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 소스 언어는 개체-지향 언어이고, 상기 대상 언어는 데이터베이스 쿼리 언어인 번역 시스템."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제4항에 있어서,상기 소스 언어는 XML 쿼리 또는 변환 언어(transformation language)이고, 상기 대상 언어는 데이터베이스 쿼리 언어인 번역 시스템."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 시스템의 외부로부터 맵을 수신하는 수신기 컴포넌트 및 상기 맵을 컴퓨터 판독가능 매체에 저장하는 레지스트레이션(registration) 컴포넌트를 더 포함하는 번역 시스템."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,소스 및 대상 언어를 식별하는 언어 식별 컴포넌트 및 상기 소스로부터 상기 대상 언어로의 번역을 용이하게 하는 상기 맵의 위치를 찾는 맵 검색 컴포넌트를 더 포함하는 번역 시스템."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서,- 3 -공개특허 10-2008-0032099상기 소스 언어 및 상기 대상 언어의 프로그래밍 요소들 사이에서 가장 밀접하게 관련된 구문, 연산, 및 식별자이름을 식별하는 구문 매치 컴포넌트; 및상기 소스 언어 및 상기 대상 언어의 상기 구문, 연산, 및 식별자 이름을 관련시키는 상기 맵을 생성하는 생성컴포넌트를 더 포함하는 번역 시스템."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "컴퓨터로 구현된 프로그래밍 확장 방법으로서,제1 프로그램 언어로 된 적어도 하나의 부분식(sub-expression)을 포함하는 식을 얻는 단계;상기 식을 제2 프로그램 언어의 대응하는 구문으로 번역하는 단계; 및상기 제1 언어의 시맨틱을 고려하지 않고 상기 부분식 논리를 상기 제1 프로그램 언어로부터 상기 제2 프로그램언어로 축어적으로 번역하는 단계를 포함하는 방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서,상기 제1 및 제2 언어를 식별하고 대응하는 구문 맵의 위치를 찾는 단계를 더 포함하는 방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,번역 중에, 대응하는 구문을 식별하기 위해 상기 맵을 사용하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제10항에 있어서,상기 제1 프로그램 언어 식은 쿼리이고, 상기 제2 프로그램 언어는 데이터 소스 쿼리 언어인 방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서,상기 제1 프로그램 언어는 개체-지향인 방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제13항에 있어서,상기 제1 프로그램 언어는 XML 쿼리 또는 변환 언어이고, 상기 제2 언어는 구조화(structured)된 쿼리 언어인방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제13항에 있어서,상기 제1 프로그래밍 언어는 XPath/XQuery이고, 상기 제2 프로그래밍 언어는 SQL이고 상기 식은 경로이고 상기부분식은 Select 스테이트먼트의 Where 절로 곧바로 번역되는 술어(predicate) 또는 필터 식(filterexpression)인 방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "구문 번역 방법으로서,제1 프로그램 언어의 구문을 얻는 단계;- 4 -공개특허 10-2008-0032099제2 프로그램 언어의 구문을 얻는 단계; 및대응하는 구문의 컴퓨터 판독가능 맵을 생성하는 단계를 포함하는 방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서,컨텍스트 정보를 얻고, 상기 맵을 생성하는 데 그 정보를 사용하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제17항에 있어서,프로그래밍 식 및 부분식을 상기 제1 언어의 구문으로부터 상기 제2 언어의 구문으로 번역하는 시스템에 상기맵을 제공하는 단계 -상기 부분식은 변환 없이 일 대 일로 매핑됨-를 더 포함하는 방법."}
{"patent_id": "10-2008-7001465", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제17항의 방법을 수행하기 위한 컴퓨터 실행가능 명령어들이 저장된 컴퓨터 판독가능 매체.명 세 서배 경 기 술컴퓨터 프로그램은 컴퓨터 또는 프로세서-기반 장치에 의해 수행될 동작들을 설명하는 명령어들의 목록이다. <1>컴퓨터 프로그램이 컴퓨터 하드웨어에 로드되어 실행될 때, 컴퓨터는 컴퓨터 프로그램의 명령어들을 따름으로써미리 결정된 방식으로 동작할 것이다. 따라서, 컴퓨터는 명령어들에 의해 미리 정해진 태스크들을 수행하는 특수화된 기계가 된다. 프로그래밍 언어를 사용하는 프로그래머는 컴퓨터 프로그램을 구성하는 명령어들을 생성한다. 컴퓨터 프로그램들이 더 정교해짐에 따라, 프로그래밍 언어는, 컴퓨터에 의해 쉽게 이해되는 낮은 수준의 기계 코드 언어로부터 사람들에게 더 쉽게 이해되는 높은 수준의 소스 코드 언어들로 발전하였다.프로그래밍 언어는 통상적으로 언어의 특성 및 특징에 기초한 범주들로 분류된다. 예를 들어, C는 절차형 <2>(procedural) 프로그래밍 언어로 설명되는데, 이는 그것이 모듈성(modularity)의 개념 및 프로그램 코드의 범위에 기초하기 때문이다. C# 및 Java는 개체 클래스와 같은 프로그램 코드의 생성 및 조작에 맞춰진 개체-지향프로그래밍 언어들이다. SQL(Structured Query Language) 및 XPath를 포함하는 데이터-중심 언어들은 관계형또는 XML(Extensible Markup Language) 데이터와 같은 저장된 데이터의 검색 및 조작에 맞춰진 것이다. 이러한특수화의 결과로서, 개별 프로그래밍 언어들은 특정한 강점 및 약점들을 갖는다.현재의 프로그래머들은 종종 그들이 광범한 경험을 갖고 있는 특정 언어로 또는 프로젝트의 큰 부분에 가장 적 <3>합한 특정 언어로 컴퓨터 프로그램을 개발하는 것을 선호한다. 하지만, 프로그래머들은 프로그래밍 언어들 사이의 특수화를 이해하며, 특정 태스크들을 위해 최상의 언어를 사용하기를 바란다. 예를 들어, C# 프로그래머는 SQL을 사용하여 관계형 데이터베이스와 인터페이스하기를 바랄 수 있으며, 따라서 SQL의 데이터-중심 양상들및 효율로부터 이득을 얻을 수 있다. 이것을 이루기 위한 한 방법은 C# 쿼리 식을 SQL 쿼리 식으로 번역하는것일 수 있다. 프로그래밍 언어들의 통합은 제1 언어로부터 제2 언어로의 시맨틱 번역(semantic translation)을 필요로 한다. 이것은 제1 언어에 지정된 모든 프로그래밍 스테이트먼트(programmatic statement), 식 및 이와 유사한 것 등의 의미가, 제1 언어에 의해 지정된 것과 동일한 의미를 갖는 제2 언어의 구문으로 번역되도록보장한다. 종종 이것은 매우 다른 구문을 포함할 뿐 아니라 제1 언어 시맨틱을 보존하기 위한 많은 데이터 변환을 포함한다.<발명의 개요> <4>청구된 본 발명의 몇몇 양상들에 대한 기본적인 이해를 제공하기 위해 아래에서 간략한 개요를 제시한다. 이 <5>개요는 광범한 개관이 아니다. 이것은 청구된 본 발명의 주요/본질적 요소들을 식별하거나 청구된 본 발명의범위의 범위를 나타내기 위한 것이 아니다. 단 하나의 목적은, 이후에 제시되는 더 상세한 설명에 대한 서두로- 5 -공개특허 10-2008-0032099서 몇몇 개념들을 간략한 형태로 나타내는 것이다.간략히 설명해서, 프로그래밍 언어 번역 시스템 및 방법들이 여기에 제공된다. 구체적으로, 식(expression)들 <6>을 포함하는, 하지만 이에 제한되지 않는, 언어 요소 또는 구성체(construct)들이, 제1 소스 언어에서 제2 대상(target) 언어로의 구문 번역을 겪을 수 있다. 번역 또는 확장은 완전히 시맨틱하기보다는 맵 또는 매핑에 의해 안내를 받는 구문론적(syntatic)인 것일 수 있다. 식 또는 부분식(sub-expression)의 적어도 일부는, 예를들어, 일 대 일로 번역되어 소스 언어 식에 나타난 것이 대상 언어로 축어적(verbatim)으로 번역될 수 있다.이러한 유형의 번역은, 무엇보다도, 시맨틱이 소스보다는 대상 언어에 의해 정의되도록 하며 예상가능한 번역을제공한다.더 나아가, 구문 번역에서 사용되는 맵을 생성하기 위한 시스템 및 방법들이 제공된다. 맵은 소스 및 대상 언 <7>어의 매칭 프로그램 구문(matching program syntax)뿐 아니라 컨텍스트 또는 구현 특정 정보(implementationspecific information)에 기초하여 채워질 수 있다. 맵은 번역 시스템 작성자(author) 또는 벤더에 의해 생성될 수 있다. 추가적으로 또는 대안적으로, 논-네이티브(non-native) 맵은 접속한 이들에 의해 제공되고, 플러그-인되고, 네이티브 맵과 같이 사용되어 한 언어에서 다른 언어로의 번역 또는 확장을 용이하게 할 수 있다.상기한 목적 및 관련 목적을 달성하기 위해, 청구된 본 발명의 특정 예시적인 양상들은 이어지는 설명 및 첨부 <8>된 도면과 관련하여 설명된다. 이 양상들은 본 발명이 실행될 수 있는 다양한 방법들을 나타내며, 이들은 모두청구된 본 발명의 범위 내에 포함된다. 이어지는 상세한 설명을 도면과 함께 숙고함으로써 다른 이점들 및 참신한 특징들이 분명해질 것이다. 실 시 예이제 청구된 본 발명의 다양한 양상들이 첨부된 도면을 참조하여 설명되며, 같은 번호는 전체 걸쳐 유사한 또는 <23>대응하는 요소들을 나타낸다. 하지만, 그것과 관련된 도면 및 상세한 설명은 청구된 본 발명을 개시된 특정 형태로 제한하기 위한 것이 아니다. 오히려, 그 의도는 청구된 본 발명의 정신 및 범위 내에 포함되는 모든변경, 동등물, 및 대안들을 포함하기 위한 것이다.여기에 사용되는 \"컴포넌트\", \"시스템\" 및 이와 유사한 용어들은 컴퓨터-관련 엔티티를 나타내기 위한 것으로, <24>하드웨어, 하드웨어 및 소프트웨어의 조합, 소프트웨어, 또는 실행 중인 소프트웨어를 나타낸다. 예를 들어,컴포넌트는 프로세서에 실행 중인 프로세스, 프로세서, 개체, 실행 파일, 실행의 스레드(thread), 프로그램, 및/또는 컴퓨터일 수 있지만, 이에 제한되는 것은 아니다. 예로서, 컴퓨터에 실행되는 애플리케이션 및 컴퓨터모두 컴포넌트일 수 있다. 하나 이상의 컴포넌트가 프로세스 및/또는 실행의 스레드에 존재할 수 있고, 컴포넌트는 하나의 컴퓨터에 위치하고/거나 둘 이상의 컴퓨터 사이에 분산될 수 있다.\"예시적인\"이라는 단어는 예(example), 실례(instance), 또는 예시(illustration)로서 사용되는 것을 의미하는 <25>것으로 여기에 사용된다. 여기에 \"예시적인\"것으로 설명된 모든 양상 또는 설계가 반드시 다른 양상 또는 설계보다 바람직하거나 유리한 것으로 이해되어서는 안된다.또한, 개시된 본 발명은 여기에 설명된 양상들을 구현하기 위해 컴퓨터 또는 프로세서 기반 장치를 제어하는 소 <26>프트웨어, 펌웨어, 하드웨어, 또는 이들의 임의의 조합을 제공하기 위해 표준 프로그래밍 및/또는 엔지니어링기술들을 사용하는 시스템, 방법, 장치, 또는 제조의 물품(article of manufacture)으로서 구현될 수 있다. 여기에 사용된 \"제조의 물품\" (또는 대안적으로 \"컴퓨터 프로그램 제품\")이라는 용어는 임의의 컴퓨터 판독가능장치, 통신 회사, 또는 매체로부터 액세스 가능한 컴퓨터 프로그램을 포괄하기 위한 것이다. 예를 들어, 컴퓨터 판독가능 매체는 자기 저장 장치(예를 들어, 하드 디스크, 플로피 디스크, 자기 스트립(magneticstrip)...), 광학 디스크(예를 들어, 컴팩트 디스크(CD), DVD(digital versatile disk)...), 스마트 카드, 및플래시 메모리 장치(예를 들어, 카드, 스틱)를 포함할 수 있지만, 이에 제한되는 것은 아니다. 추가적으로, 전자 메일을 전송하고 수신하는 데 사용되거나, 인터넷 또는 LAN(local area network)과 같은 네트워크를 액세스하는 데 사용되는 컴퓨터 판독가능 전자 데이터를 운반하도록 반송파가 사용될 수 있다는 것을 이해해야 한다.물론, 당업자들은 청구된 본 발명의 범위 또는 정신을 벗어나지 않으면서 이러한 구성에 많은 변경이 만들어질수 있음을 이해할 것이다.먼저 도 1을 참조하면, 프로그램 코드 번역 시스템(100)이 도시된다. 시스템(100)은 구문 분석 컴포넌트(110), <27>번역 컴포넌트(120) 및 맵(130)을 포함한다. 구문 분석 컴포넌트(110)는 프로그래밍 코드를 수신하고, 이를 기호, 연산자(예를 들어, +, -, *, =, 〓, &, %...), 타입(types) 및 이와 유사한 것 등과 같은 언어의 기본 요소들을 나타내는 토큰 및 파스 트리(parse tree)로 구문 분석한다. 이 토큰들은 개별적으로 또는 모음, 즉 파- 6 -공개특허 10-2008-0032099스 트리로 번역 컴포넌트(120)에 전달된다. 번역 컴포넌트(120)는 토큰 또는 토큰의 모음을 수신하고, 이들을제1 소스 프로그램 언어로부터 대응하는 제2 대상 언어의 요소들로 확장 또는 번역한다. 예를 들어, 제1 언어의 등호 \"=\"는 제2 언어의 등호로 매핑될 수 있다. 이러한 번역 또는 확장을 용이하게 하기 위해, 번역 컴포넌트(120)는 맵(130)과 상호작용하고 맵(130)에 의해 안내될 수 있다. 맵(130)은 제1 언어의 구문, 연산 및 이름과, 제2 언어의 구문, 연산 및 이름 사이에 맵 또는 매핑을 제공한다. 맵(130)은 프로그래밍 언어들에 공통인기본 요소들에 대한 기록뿐 아니라, 필드, 변수 및/또는 테이블 이름과 같은 컨텍스트 또는 구현 특정 정보를포함할 수 있다. 따라서, 구문 분석 컴포넌트(110)로부터 특정 토큰 또는 언어 요소를 수신하면, 번역 컴포넌트(120)는 맵(130)에서 그러한 요소를 식별하고 제2 언어에서 대응하는 요소 또는 요소들을 검색할 수 있다.입력 또는 소스 코드로부터 대상 코드로의 변환 또는 번역은 완전히 구문론적일 수 있다. 하지만, 맵(130)은적어도 몇몇 언어 시맨틱을 구현할 수 있다.도 2a는 도 1의 시스템(100)에 의해 제공된 번역에 대한 이해의 명확성을 원활하게 하기 위해 간단한 예시적인 <28>번역(200a)을 도시한다. C#로부터 SQL로의 번역으로 표현되었지만, 본 발명은 결코 이에 제한되지 않는다는 것을 주의해야 한다. 이 예는 이와 마찬가지로 다른 언어들(예를 들어, XPath/XQuery에서 SQL로...)도 쉽게 사용할 수 있다. 예로서, 개체-지향 언어 식 또는 코드는, 예를 들어, 구문 분석 컴포넌트(110)에 의해 수신될 수있고, 번역 컴포넌트(120)에 의해 궁극적으로 SQL 코드로 번역되거나 확장될 수 있다. 여기에서, 식은cs.where (｜c｜c.name = \"Jones\")에 대응되는 쿼리 식이다. 예시적인 식은 통상적인 개체-지향 도트(dot) 연산자뿐 아니라, 람다 필터(lambda filter) 식 또는 부분식을 포함한다. 스테이트먼트 선언(statementdeclare)은 고객의 이름이 Jones인 모든 고객(customer, cs)을 찾는다. 여기에서 두 가지 주(main) 확장이 일어난다. 먼저, 주 식(main expression) \"cs.where\"는 구문 맵(130)에 기초하여 \"Select * From CustomersWhere\"로 번역 또는 확장될 수 있다. 개체-지향 스테이트먼트는, 고객 또는 고객 테이블에 대응될 수 있는\"cs\"로부터 선택을 하는 것과 대응된다. 다음, 부분식, 즉 여기에서의 람다 식이 확장된 주 식을 채우도록 번역되고 사용될 수 있다. 이 경우에서, 필터 또는 선택 식은 고객들(cs)로부터 이름이 Jones인 고객(c)을 선택하라고 말한다. 이것은 간단히 name = \"Jones\"로 번역되고 Select 스테이트먼트의 Where 매개변수에 인수로 입력될 수 있다. 시맨틱 의미에 대한 고려없이, 소스 언어의 name = \"Jones\"에서 대상 또는 목적지(destination)언어로의 직접적인 번역이 있다는 것을 주의해야 한다.도 2b는 도 1의 시스템(100)의 연산에 대한 이해의 명확성을 원할하게 하기 위해 예시적인 번역 또는 확장 <29>(200b)을 도시한다. 확장(200b)은 다른 결과가 생성된다는 것을 제외하고 번역(200a)과 유사하다. 다시, 식\"cs.where(｜c｜c.name = \"Jones\")\"이 있다. 주 식은 SQL 유형의 식, 즉 \"Select * From Customers Where\"로확장된다. 이것은 고객 테이블에서 조건이 만족되는 것을 선택하는 것을 의미한다. 조건은 부분식에지정되며, 여기에서는 람다 식으로 지정되어 있다. 이 경우에서, 조건 name = \"Jones\"는 다른 소정의 조건 식으로 번역 또는 확장되어 소정의 함수가 name에 수행되고 소정의 변환이 문자열 Jones에 실행되는데, 예를들어, 유니코드 문자열이 ASCⅡ 문자열 또는 이와 유사한 것 등으로 변환될 수 있다. 다시 말해, 같은 조건 식이 Where 절(clause) 또는 매개변수에 조건 인수로 놓이지 않는다. 오히려, 이 경우의 확장된 식 또는 부분식이 소스 언어에 지정된 것과 동일한 의미를 갖는 것을 보장하기 위해, 소정의 시맨틱 변환 또는 번역이 수행된다. 여기에서, 소스 언어의 시맨틱이 유지된다.확장(200b)이 소스 언어 식을 대상 언어 식, 스테이트먼트 등으로 번역하기 위한 실행가능한 옵션을 <30>나타내지만, 그것과 관련된 적어도 하나의 문제가 있다. 구체적으로, 프로그래머는 소스 언어를 사용하여 프로그래밍을 할 수 있는데, 여러 이유 중에서도, 프로그래머를 목적지 언어의 상세로부터 격리시키기 위해 소스 언어는 나중에 대상 또는 목적지 언어로 번역된다. 예를 들어, 사용자는 속기(short hand)로서 C# 또는XQuery/XPath로 프로그램할 수 있지만 관계형 데이터 액세스를 위한 대상 언어는 SQL일 수 있다. 프로그래머들은 특정 식이 특정 대상 언어로 번역될 것이라는 것을 안다. 따라서, 그들은 종종 무엇이 생성되는지 보지만,놀랍게도, 그들이 예상했던 것과 전혀 다를 수 있다. 확장(200b)으로 설명된 것과 같이, 소스 언어의 시맨틱을유지하기 위해 다양한 변환 및 데이터 조작이 필요할 수 있다. 놀라운 결과들에 더해, 시맨틱 보전(preservation)을 지원하는 기능성 때문에 변환된 식으로 인해 실행이 느리고 비효율적이 되기 쉽다. 그리고또한, 소스 언어 식에서의 아주 작은 변화가 대상 언어에 엄청난 변화가 발생하도록 할 수 있는 것과 같이, 이러한 번역은 디버그 프로세스를 엉망으로 만들 수 있다. 또한, 소스 언어 코드의 변경에 응하여 대상 언어의변경들이 비선형(non-linear)일 뿐 아니라 예측가능하지 않기 때문에, 프로그래머들은 생성된 결과들을 어떻게미조정(tweak)해야 하는지 모를 수 있다. 번역 또는 확장은 본질적으로 사용자 또는 프로그래머들에게 블랙 박스(black box)이다.- 7 -공개특허 10-2008-0032099확장(200a)은 같은 문제들을 겪지 않는다. 여기서, 적어도 식의 일부, name = \"Jones\"가 일 대 일로 번역되거 <31>나, 또는 다른 관점에서 전혀 번역되지 않고 소스에 지정된 것과 같이 복사될 수 있다. 이것은 프로그래머들에게 예측가능성을 제공하기 때문에, 그들은 그들이 name = \"Jones\"를 지정할 때 이 조건이 목적지 언어에서 name= \"Jones\"로 번역될 것이라는 것을 안다. 소스 언어의 시맨틱을 유지하기 위해, 예상치 못한 변환들이 생성되지 않는다. 사실, 시맨틱은 소스보다는 대상 언어로부터 비롯되는 것으로 이해된다. 이것은, 무엇보다도, 대상 언어로부터 시맨틱 확장성을 제공한다. 따라서, 번역은 소스 언어의 임의의 시맨틱 규칙을 강요하지 않는일종의 매크로 확장이다. 예로서, 만약 식 a * b + c가 소스 언어로 작성되면, 목적지 언어의 전례 및 결합 규칙들이 적용된다. 따라서, 소스 언어 시맨틱이 승산(multiplication)이 먼저 행해지고 이어서 가산(addition)이 이루어지도록 지정하고, 목적지 언어 시맨틱이 가산이 먼저 수행되도록 지정하면, 소스 언어의 시맨틱을 유지하기 위해, (a * b) +c와 같이 식에 대한 어떠한 변환 또는 변경도 없을 것이다.도 3을 보면, 맵 제작 시스템(300)이 도시된다. 시스템은 구문 매치 컴포넌트(310), 사용자 인터페이스 컴포넌 <32>트(320) 및 맵 생성 컴포넌트(330)를 포함한다. 매핑을 위해 탐색되는 두 언어가 구문 매치 컴포넌트(310)에제공된다. 여기서, 언어 A 및 B는 구문 매치 컴포넌트(310)에 입력을 공급한다. 구문 매치 컴포넌트(310)는언어 A 및 언어 B의 구문이 매치되도록 하는 메커니즘을 제공한다. 예를 들어, 언어 A의 숫자, 기호, 및 연산자는 같은 또는 대응되는 언어 B의 숫자, 기호, 및 연산자들에 매치(match)될 수 있다. 또한, 구문 매치 컴포넌트는 필드, 테이블, 변수 등의 이름과 같은 컨텍스트 정보를 수신할 수 있다. 이와 같은 방식으로, 예를 들어, \"cs\"와 같이 언어 A로 된 이름은 언어 B의 \"customer\" 테이블에 매치될 수 있다. 더 나아가, 사용자 인터페이스 컴포넌트(320)는 통신상 구문 매치 컴포넌트와 연결될 수 있다. 사용자 인터페이스 컴포넌트(320)는 사용자에게, 아마도 관리 유형(administrative type)의, 제어, 조정(coordinate), 또는 다른 방식으로 언어 구문의 매칭에 영향을 줄 수 있는 메커니즘을 제공한다. 예를 들어, 사용자는 적절한 컨텍스트 정보가 매치되고/거나 유사한 기능 또는 동작들이 적절하게 매치됨 보장할 수 있다. 매치 정보는 맵 생성 컴포넌트(330)에 제공될수 있다. 맵 생성 컴포넌트는 매치 정보로부터 맵을 생성할 수 있다. 예를 들어, 맵은 매칭 구문을 포함하는컴퓨터 판독가능 맵 또는 매핑 파일일 수 있다. 맵은 임의의 형태로 제공될 수 있음을 이해해야 하지만, 한 실례로 맵은 XML 파일일 수 있다.도 4는 논-네이티브 또는 플러그-인 맵을 얻는 언어 번역 시스템(400)이다. 도 1에서와 같은 번역 시스템은 복 <33>수의 언어들에 대해 하나 이상의 맵을 포함할 수 있다. 하지만, 시스템은 새로운 언어, 확장, 다른 언어 및/또는 다른 컨텍스트의 대안적인 버전(version)에 대해 새로운 논-네이티브 맵을 얻을 수 있다는 점에서 확장성을갖는다. 시스템(400)은 수신기 컴포넌트(410), 레지스트레이션 컴포넌트(420) 및 저장소(430)를 포함한다. 수신기 컴포넌트(410)는 수신, 검색하거나 다른 방식으로 컴퓨터 판독가능 맵을 얻는다. 맵은, XQuery에서 SQL로의 매핑과 같은, 제1 언어 구문의 제2 언어 구문으로의 매핑을 포함할 수 있다. 수신되고 나면, 맵은 레지스트레이션 컴포넌트(420)에 제공될 수 있다. 레지스트레이션 컴포넌트(420)는 맵을 수신하고, 컴퓨터 판독가능 저장소(430)로의 맵의 저장을 개시할 수 있다. 레지스트레이션 컴포넌트(420)는 또한, 예를 들어, 소스 및 대상언어, 및 그의 저장소(430) 내의 위치에 의해, 맵을 식별하기 위해 레지스트리 또는 로그(440)에 항목(entry)을생성 및 저장할 수 있다. 등록(registeration) 후에, 맵은 도 1과 관련하여 상술된 시스템(100)과 같은 번역또는 확장 시스템이 사용할 수 있게 된다.도 5를 보면, 사용을 위해 맵을 찾아내는 언어 번역 시스템(500)이 제공된다. 시스템(500)은 언어 식별 컴포넌 <34>트(510), 맵 검색 컴포넌트(520), 및 저장소(430)를 포함한다. 언어 식별 컴포넌트(510)는 당면한(inquestion) 언어를 식별하기 위해, 그에 제공된 복수의 언어들을 분석한다. 언어 식별 컴포넌트(510)는 언어들의 ID를 맵 검색 컴포넌트(520)에 제공한다. 언어들의 ID 및 선택적으로 몇몇 컨텍스트 정보가 주어진 맵 검색컴포넌트는 이어서 적절한 맵을 식별할 수 있다. 예를 들어, 맵 검색 컴포넌트는 특정 소스 및 대상 언어들을가진 맵을 식별하기 위해 레지스트리(440)와 상호작용할 수 있다. 또한, 레지스트리(440)는 위치를 식별하거나적절한 맵에 대한 지시자를 제공할 수 있다. 다음, 맵은 컴퓨터 판독가능 저장소(430)로부터 검색되어 언어 번역 또는 확장 시스템에 제공될 수 있다.도 6은 번역 또는 확장 시스템과 상호작용하기 위한 인터페이스 시스템(600)을 도시한다. 시스템(600)은 애플 <35>리케이션 인터페이스 컴포넌트(610) 및 번역 인터페이스 컴포넌트를 포함한다. 애플리케이션 인터페이스 컴포넌트(610)는 제1 컴퓨터 언어 애플리케이션과 상호작용할 수 있다. 예를 들어, 애플리케이션 인터페이스 컴포넌트(610)는 식, 스테이트먼트, 블록 등과 같은 프로그래밍 요소들을 수신할 수 있다. 애플리케이션 인터페이스(610)는 이러한 프로그래밍 요소들을 번역 인터페이스 컴포넌트(620)에 전송 또는 제공할 수 있다. 번역 또는 확장을 위해 이러한 프로그래밍 요소들을 제공할 수 있도록, 번역 인터페이스 컴포넌트(620)는 번역 시스템- 8 -공개특허 10-2008-0032099과 통신상 연결되거나 번역 시스템에 포함될 수 있다. 번역된 프로그래밍 요소 및/또는 쿼리의 결과와 같은 기타 데이터는 번역 인터페이스 컴포넌트(620)로부터 애플리케이션 인터페이스 컴포넌트(610)로 다시 전송될 수있다. 애플리케이션 인터페이스 컴포넌트(610) 및/또는 번역 인터페이스(620)는 번역 시스템과 상호작용하기위한 애플리케이션-프로그래밍 인터페이스(API) 전체 또는 일부를 형성할 수 있다는 것을 이해해야 한다. 따라서, 인터페이스는 프로그래밍 코드의 번역 또는 확장과 관련된 임의의 및 모든 정보를 전송할 수 있다.개시된 본 발명의 양상들에 대한 이해를 더욱 용이하게 하기 위해, 예시적인 시나리오 및 솔루션이 제공된다. <36>이 시나리오 및 솔루션은 단지 여기에 개시된 특정한 본 발명과 관련하여 명확성을 제공하기 위한 목적으로 제공된 것이며, 어떠한 방식으로도 개시된 본 발명의 범위를 제한하기 위한 것이 아니다. 여기에 제공된 시스템및 방법들은 여러 다양한 상황들에 적용될 수 있으며, 이 중 하나만이 아래에 설명된다. 종종 XML과 같은 관계형 데이터를, 예를 들어, 웹 서비스 또는 다른 유형의 응용을 통해 데이터베이스 사용자 <37>에게 제공하는 것이 필요하다. 다시 말해, 제공된 XML은 관계형 데이터를 보여준다(view over). 관계형 데이터에 대한 XML의 뷰를 사용하는 것의 주요 이점(attraction)은, 그것이 사용자들에게 그들의 평면적인 관계형데이터에 대한 계층적 뷰를 제공하고, 이로써 더 쉽게 이 계층 구조를 탐색할 수 있게 한다는 것이다. 이러한시나리오에서, 사용자들이 이러한 기술을 사용할지를 결정하는 여러 중요한 특징들이 있다는 것이 발견되었다.먼저, 간단한 검색, 업데이트, 및 XML 데이터의 조작을 위한 메커니즘이 사용자들에게 중요하다. 데이터베이스 <38>제공자 또는 소유자들은 통상적으로 어떤 XML 스키마(XSD-XML 스키마 정의)를 통해 사용자들과 계약을구축하며, 사용자들이 XSD 스키마 내에 설명된 XML과 같은 백 엔드로부터 다시 데이터를 받을 수 있도록 한다.사용자들은 복잡한 SQL 쿼리를 수동으로 작성할 필요없이 데이터베이스와 빨리 상호작용할 수 있는 권한을 얻기를 바란다.또한, 사용자들에게 고성능(high performance)뿐 아니라 단정가능한(predicable) 비헤비어를 가진 효율적 쿼리 <39>를 제공하는 것이 중요하다. 사용자들은 성능을 해치는 변환이 적용되지 않을 것이라고 정당하게 기대한다.예를 들어, 사용자들은 인덱스(indexed)된 열(column)들은 변환되지 않을 것이라 예상하는데, 이러한 변환은 실질적으로 성능을 손상시키기 때문이다. 또한, 사용자들은 종종, 예를 들어, 작은 변화에 따라 쿼리가 완전히다르게 행동하는, 비결정적(non-deterministic) 또는 비단조(non-monotonic) 비헤비어를 제공하는 애플리케이션또는 기술을 사용하지 않는다.또한, 사용자들은 그들의 데이터가 관계형 데이터베이스에 저장되어 있으므로, 데이터베이스에 의해 제공되는 <40>고유한 기능성을 그들이 사용할 수 있어야 한다는 강한 견해를 갖는다. XQuery 및 SQL에서 유사한 기능이 사용가능할 때, 사용자는 종종 SQL 기능이 대응하는 XQuery 기능에 곧바로 매핑되기를 기대한다. 다시 말해, 쿼리가 실행될 때 SQL 기능이 사용된다.앞서 언급된 문제들과 관련하여, 매핑 정보에 기초하여 경로 및 필터 식을 데이터 소스의 쿼리 언어로 번역 <41>(transliterate)함으로써, 데이터에 대한 XML 뷰가 쿼리될 수 있도록 언어는 설계되거나 번역될 수 있다. 예를들어, XPath/XQuery 또는 이들의 부분집합을 사용함으로써, XML 노드와 같은 맵 대상(map target)의 위치를 찾고 이 노드에 술어(predicate)를 적용할 수 있는 능력이 제공될 수 있다. 이 술어에서, 자신 및 자식 축(selfand child axes) 상의 임의의 상대 XML 노드는 필터 식에 사용될 수 있다. 식들은 XPath/XQuery로부터 SQL로번역될 수 있으며, 여기서 XML 항목은 매핑된 SQL 엔티티(예를 들어, 테이블, 열)로 대체되고 자식 및 특성 트래버설(traversal)은 매핑된 테이블 사이의 적절한 관계를 통해 조인(join)으로 번역된다. 술어에 사용된 위치경로 및 노드 정보에 기초한 적절한 테이블/열을 참조하기 위해, 쿼리는 XML 맵 또는 매핑으로의 관계(relational)에 따라 SQL로 번역될 수 있다. 다음, SQL 쿼리의 실행에 의해 발생하는 기록들이 매핑된 XML 노드에 구체화될 수 있다.위치 경로는 XQuery 문법 또는 BNF(배커스 나우어 형식(Backus-Naur Form) 또는 배커스 정규형(Backus Normal <42>Form))의 일부로, SQL로의 번역을 용이하게 하는 데 필요한 정보를 경로 및 술어에 갖는다. 상대 위치 경로는\"/\"와 같은 구분 기호로 분리된 하나 이상의 위치 단계들의 시퀀스를 포함할 수 있다. 상대 위치 경로의 단계들은 좌에서 우로 함께 구성된다. 각 단계들은, 선행 단계의 노드의 자식인 노드를 차례로 선택한다. 절대 위치 경로는, 선택적으로 상대 위치 경로가 이어지는 \"/\"을 포함한다. \"/\"는 홀로 컨텍스트 노드를 포함하는 문서의 루트 노드(root node)를 선택한다. 만약 상대 위치 경로가 이어진다면, 컨텍스트 노드를 포함하는 문서의루트 노드와 관련하여 상대 위치 경로에 의해 선택될 노드의 집합을 위치 경로가 선택한다. BNF 형식으로:- 9 -공개특허 10-2008-0032099<43>위치 단계는 명명된 자식, 특성 또는 자신을 선택한다. 예를 들어, 다음의 BNF를 보면: <44><45>술어는 새로운 노드 집합을 생성할 경로와 관련하여 노드 집합을 필터링한다. 술어 식은, 경로가 컨텍스트 노 <46>드로서 역할한다고 지정하는 노드에 기초하여 SQL로 번역된다. BNF로:<47>필터 식을 위해 식들이 필요하다. 그루핑을 위해 괄호가 사용될 수 있다. 식에 대한 다음의 BNF를 보면: <48><49>연산자의 선행(precedence) 및 결합(associatively)은 SQL에서와 동일하다는 것을 주의해야 한다. 위의 문법의 <50>효과는 선행의 순서가(높은 순위 먼저) 다음과 같다는 것이다.:<51>식의 두 연산자가 동일한 연산자 선행 레벨을 갖고 있으면, 식 내에서의 그들의 위치에 기초하여 왼쪽에서 오른 <52>쪽으로 평가된다.아래에 제시되는 예를 보자. 아래의 예는 SQL 쿼리를 XML 데이터 유형으로 나타낸다. <53><54>관련된 매핑 파일은 다음과 같다.: <55><56>- 10 -공개특허 10-2008-0032099적용할 수 있는 쿼리: <57><58>가 아래의 SQL 스테이트먼트를 생성한다. <59><60>앞서 언급된 시스템들은 여러 컴포넌트 간의 상호작용과 관련하여 설명되었다. 이러한 시스템 및 컴포넌트는 <61>거기에 지정된 컴포넌트 또는 서브-컴포넌트(sub-component), 몇몇의 지정된 컴포넌트 또는 서브-컴포넌트, 및/또는 부가적인 컴포넌트를 포함할 수 있다는 것을 이해해야 한다. 예를 들어, 시스템은 구문 분석 컴포넌트(110), 번역 컴포넌트(120), 구문 매치 컴포넌트(310), 사용자 인터페이스 컴포넌트(320), 맵 생성 컴포넌트(330), 수신기 컴포넌트(410), 레지스트레이션 컴포넌트(420), 언어 식별 컴포넌트(510), 및 맵 검색 컴포넌트(520), 또는 이들의 조합을 포함할 수 있다. 또한, 하나 이상의 컴포넌트가 집합적인 기능을 제공하는 하나의컴포넌트로 결합되거나, 여러 서브-컴포넌트들로 나누어질 수 있다는 것을 주의해야 한다. 또한, 컴포넌트들은여기에 명확하게 설명되지는 않았지만 당업자들에게 잘 알려진 하나 이상의 컴포넌트들과 상호작용할 수 있다.더 나아가, 위에 개시된 시스템의 다양한 부분들 및 아래의 방법들은 인공 지능 또는 지식 또는 규칙 기반 컴포 <62>넌트, 서브-컴포넌트, 프로세스, 수단, 방법론, 또는 메커니즘(예를 들어, 서포트 벡터 머신(support vectormachine, SVM), 뉴럴 네트워크(neural network), 전문가 시스템, 베이지안 신뢰 네트워크(Bayesian beliefnetwork), 퍼지 논리(fuzzy logic), 데이터 융합 엔진(data fusion engine), 분류자(classifier)...)을 포함하거나 이들로 구성될 수 있다. 이러한 컴포넌트들은, 특히, 특정 메커니즘 또는 수행되는 프로세스를 자동화할수 있으며, 이로써 시스템 및 방법의 부분들이 더 적응적일 뿐 아니라 효율적이고 지능적이 되도록 한다. 예를들어, 번역 컴포넌트(120)는 코드의 확장 또는 번역을 용이하게 하기 위해 인공 지능, 기계 학습 또는 유사한메커니즘들을 사용할 수 있다. 추가적으로 또는 대안적으로, 구문 매치 컴포넌트(310)는 이러한 지능형 기계들을 사용하여 복수의 언어들의 구문 매칭을 원활하게 할 수 있다.위 설명된 예시적인 시스템에서, 개시된 본 발명에 따라 구현될 수 있는 방법론들은 도 7-11의 흐름도를 참조하 <63>여 더 잘 이해될 것이다. 설명의 간단함을 위해, 방법론은 일련의 블록들로 도시되고 설명되며, 몇몇 블록들은여기에 도시되고 설명된 것과 달리 다른 순서로 발생하고/거나 다른 블록들과 동시에 발생할 수 있으므로, 청구된 본 발명은 블록들의 순서에 제한되지 않는다는 것을 이해해야 한다. 또한, 이후에 설명되는 방법론을 구현하기 위해 모든 도시된 블록들이 필요하지 않을 수 있다.이에 더해, 명세서 전체에 걸쳐 개시된 방법론들은, 컴퓨터로의 방법론의 전달 및 전송을 용이하게 하기 위해, <64>제조의 물품에 저장되는 것이 가능하다. 여기에 사용된 제조의 물품이라는 용어는 임의의 컴퓨터 판독가능 장치, 통신 회사, 또는 매체로부터 액세스 가능한 컴퓨터 프로그램을 포함하도록 의도된다.도 7을 보면, 언어 번역 방법론(700)이 도시된다. 단계(710)에서, 코드가 제1 또는 소스 언어로 얻어진다. 예 <65>로서, 제1 언어는 개체-지향 언어 또는 마크업(markup) 쿼리 언어일 수 있지만, 이에 제한되는 것은 아니다.단계(720)에서, 번역 또는 구문 맵의 위치가 찾아진다. 맵은 제1 소스 언어의 구문으로부터 제2 대상 언어의구문으로의 번역에 관한 구문 정보를 제공할 수 있다. 맵은 컴퓨터 판독가능 매체에 저장되거나 번역 시스템내에 저장될 수 있다. 단계(730)에서, 제1 언어로부터 얻어진 코드는 구문 맵을 사용하여 제2 언어의 코드로확장된다. 방법론(700)은, 예를 들어, XML 기반 쿼리를, SQL일 수 있는, 관계 기반 쿼리로 번역하는 데 이용될수 있다. 쿼리는 쿼리 프로세서에 의해 실행될 수 있고 관계형 결과들이 생성된다. 이어서 결과들을 다시 XML로 넘기기 위해 유사한 방법론이 사용될 수 있다. 예를 들어, 같은 맵이 사용되거나, SQL이 소스이고 XML이 대상 언어인 다른 맵이 사용될 수 있다. 다음, 결과는 맵을 이용하여 다시 XML로 번역될 수 있다.도 8은 식 번역 방법(800)에 대한 흐름도이다. 참조 번호(810)에서, 소스 언어의 식(예를 들어, 쿼리 식)이 수 <66>신, 검색되거나 다른 방식으로 얻어진다. 식은 인수로서 부분식을 포함할 수 있다. 예를 들어, 식은 데이터의경로 또는 위치를 지정할 수 있고, 부분식은 어떤 필터 논리 또는 술어를 지정할 수 있다. 단계(820)에서, 식은 관련된 대상 언어의 구문의 식으로 번역된다. 이 번역 동작은 주 식과 관련될 수 있는데, 예를 들어, 개체-지향 또는 마크업 언어 식은 쿼리될 데이터를 식별하여, SQL과 같은 대상 언어로 식이 번역되도록 한다. 예를들어, \"cs.where(｜c｜c.name = \"Jones\")\"의 식 \"cs.where\"는 Select * From Customers Where로 번역될 수 있- 11 -공개특허 10-2008-0032099다. 이 경우에, Where 절은 어떤 논리 또는 식을 포함하지 않는데, 이는 부분식에 의해 제공되기 때문이다.단계(820)에서, 부분식의 구문이 소스 언어에서 대상 언어로 번역되어 주 식으로부터 생성된 구문 또는 구조를채운다. 부분식의 번역은 소스 언어의 시맨틱을 보존할 필요가 없다. 따라서, 부분식 또는 이의 부분은 축어적으로 번역될 수 있고, 이로써 부분식의 구문만을 보존한다. 앞선 예에서, 부분식 \"｜c｜c.name = \"Jones\"은간단히 \"name = \"Jones\"로 번역되고 Where 절에 인수로 제공될 수 있다.도 9는 번역 또는 확장 맵 방법(900)을 도시한다. 참조 번호(910)에서, 제1 언어의 프로그램 구문이 제2 언어 <67>의 프로그램과 매치된다. 이 동작은 자동, 반자동 또는 수동일 수 있다. 맵은 연산자와 같은 대응하는 기본요소들의 매핑을 포함할 수 있고, 또한 데이터 또는 구현 특정 정보를 포함할 수 있는데, 예를 들어, \"cs\"는\"customers\"라고 명명된 테이블에 대응된다. 단계(930)에서, 생성된 맵은 사용을 위해 언어 확장/번역 시스템에 제공될 수 있다. 방법(900)은 네이티브 및 논-네이티브 맵 모두를 생성하도록 이용될 수 있다. 따라서, 번역 시스템 벤더는 시스템에 포함될 맵을 생성하기 위해 방법(900)을 이용할 수 있다. 추가적으로 또는 대안적으로, 제3자는 그들 자신의 맵을 생성할 수 있고, 이는 시스템에 추가되거나 플러그-인 될 수 있다.도 10은 확장 또는 번역 시스템 맵 레지스트레이션 방법(1000)을 도시한다. 예로서, 방법(1000)은 플러그-인 <68>또는 논-네이티브 맵의 지원을 위해 이용될 수 있다. 단계(1010)에서, 구문 맵이 수신, 검색되거나 다른 방식으로 얻어진다. 앞서 설명된 것과 같이, 맵은, 무엇보다도, 연산자 및 컨텍스트 특정 정보(예를 들어, 데이터스키마)를 포함하는 복수의 언어들로부터 대응하는 구문을 기록할 수 있다. 단계(1020)에서, 맵이 컴퓨터 판독가능 저장소에 저장된다. 단계(1030)에서, 맵이 등록된다. 레지스트레이션은, 특히, 맵의 위치 또는 지시자를기록하는 것뿐 아니라 맵이 동작할 수 있는 언어들과 관련된 정보를 기록할 수 있다. 맵이 등록되고 나면, 맵이 사용가능해진다. 방법(1000)은 네이티브뿐 아니라 논-네이티브 맵을 수신하고 이에 동작하기 위한 수단을제공한다.도 11을 보면, 번역 방법론(1100)의 흐름도가 도시된다. 참조 번호(1110)에서, 소스 및 대상 언어가 식별된다. <69>예를 들어, XPath가 소스이고 SQL이 대상이거나, 이와 반대일 수 있다. 단계(1120)에서, 소스 및 대상 언어를매핑하는 구문 맵의 위치를 찾는다. 이것은 레지스트리를 참고하고 확장을 수행하기에 적합한 맵의 위치에 대한 지시자를 검색함으로써 이루어질 수 있다. 마지막으로, 맵을 사용하여 하나 이상의 식 또는 기타 프로그램유닛 또는 요소들이 번역된다. 이 번역은 소스 언어의 시맨틱에 대한 완전한 강제(enforcment) 없이 일어나는,소스의 구문으로부터 대상의 구문으로의 번역이다. 시맨틱은 대상 언어에 의해 정의될 수 있다. 개시된 본 발명의 다양한 양상들을 위한 컨텍스트를 제공하기 위해서, 도 12 및 도 13뿐 아니라 아래의 논의는 <70>개시된 본 발명의 다양한 양상들이 구현될 수 있는 적합한 환경에 대한 간략하고 일반적인 설명을 제공하기 위한 것이다. 위에서 본 발명이 컴퓨터 및/또는 컴퓨터들에 실행되는 컴퓨터 프로그램의 컴퓨터 실행가능 명령어와 관련하여 설명되었지만, 당업자들은 본 발명이 또한 기타 프로그램 모듈과 함께 구현될 수 있다는 것을 이해할 것이다. 일반적으로, 프로그램 모듈은 특정 태스크를 수행하고/거나 특정 추상 데이터 유형을 구현하는 루틴, 프로그램, 컴포넌트, 데이터 구조 등을 포함한다. 또한, 당업자들은 독창적 방법들이 단일 프로세서 또는멀티프로세서 컴퓨터 시스템, 미니 컴퓨팅 장치, 메인프레임 컴퓨터뿐 아니라 개인용 컴퓨터, 핸드-헬드 컴퓨팅장치(예를 들어, PDA(personal digital assistant), 전화, 시계...), 마이크로프로세서 기반 또는 프로그램 가능한 소비자 또는 산업 전자 제품 등을 포함하는 기타 컴퓨터 시스템 구성과 함께 실행될 수 있다는 것을 이해할 것이다. 또한, 설명된 양상들은 통신 네트워크를 통해 연결된 원격 프로세싱 장치들에 의해 태스크가 수행되는 분산된 컴퓨팅 환경에서 실행될 수 있다. 하지만, 본 발명의 모든 양상들은 아니더라도 몇몇은 독립 실행형 컴퓨터에서 실행될 수 있다. 분산된 컴퓨팅 환경에서, 프로그램 모듈은 로컬 및 원격 메모리 저장 장치 둘다에 위치할 수 있다.도 12를 참조하면, 여기에 개시된 다양한 양상들을 구현하기 위한 예시적인 환경(1210)은 컴퓨터(1212)(예를 들 <71>어, 데스크톱, 랩톱, 서버, 핸드-헬드, 프로그램 가능한 소비자 또는 산업 전자 제품...)를 포함한다. 컴퓨터(1212)는 처리 장치(1214), 시스템 메모리(1216), 및 시스템 버스(1218)를 포함한다. 시스템 버스(1218)는 시스템 컴포넌트들을 연결시키며, 시스템 메모리(1216)를 처리 장치(1214)와 연결시키는 것을 포함하지만 이에 제한되지는 않는다. 처리 장치(1214)는 임의의 다양한 사용가능한 마이크로프로세서일 수 있다. 2중 마이크로프로세서 및 다른 멀티프로세서 아키텍처 또한 처리 장치(1214)로서 사용될 수 있다.시스템 버스(1218)는 메모리 버스 또는 메모리 컨트롤러, 주변 장치 버스 또는 외부 버스, 및/또는 11-비트 버 <72>스, ISA(Industrial Standard Architecture) 버스, MCA(Micro-Channel Architecture), EISA(Extended ISA),IDE(Intelligent Drive Electronics), VESA 로컬 버스(VLB), PCI(Peripheral Component Interconnect),- 12 -공개특허 10-2008-0032099USB(Universal Serial Bus), AGP(Advanced Graphics Port), PCMCIA(Personal Computer Memory CardInternational Association bus), 및 SCSI(Small Computer Systems Interface)를 포함하지만 이에 제한되지 않는 각종 버스 아키텍처 중 임의의 것을 이용하는 로컬 버스를 비롯한 여러 유형의 버스 구조(들) 중 어느 것이라도 될 수 있다. 시스템 메모리(1216)는 휘발성 메모리(1220) 및 비휘발성 메모리(1222)를 포함한다. 시동 중과 같은 때에, 컴 <73>퓨터(1212) 내의 구성요소들 사이의 정보 전송을 돕는 기본 루틴을 포함하는 기본 입/출력 시스템(BIOS)은 비휘발성 메모리(1222)에 저장되어 있다. 예로서, 비휘발성 메모리(1222)는 ROM(read only memory),PROM(programmable Rom), EPROM(electrically programmable ROM), EEPROM(electrically erasable ROM), 또는플래시 메모리를 포함할 수 있지만, 이에 제한되는 것은 아니다. 휘발성 메모리(1220)는 외부 캐시 메모리로동작하는 RAM(random access memory)을 포함한다. 예로서, RAM은 SRAM(synchronous RAM), DRAM(dynamic RAM),SDRAM(synchronous DRAM), 2배속 SDRAM(DDR SDRAM), ESDRAM(enhanced SDRAM), SLDRAM(Synchlink DRAM), 및DRRAM(direct Rambus RAM)과 같은, 하지만 이에 제한되지 않는, 여러 형태로 사용가능하다.컴퓨터(1212)는 또한 이동식/비이동식, 휘발성/비휘발성 컴퓨터 저장 매체도 포함한다. 도 12는, 예를 들어, <74>디스크 저장 장치(1224)를 포함한다. 디스크 저장 장치(1224)는 자기 디스크 드라이브, 플로피 디스크 드라이브, 테이프 드라이브, 재즈(Jaz) 드라이브, 집(Zip) 드라이브, LS-100 드라이브, 플래쉬 메모리 카드, 또는 메모리 스틱을 포함하지만, 이에 한정되는 것은 아니다. 그에 부가하여, 디스크 저장 장치(1224)는 CD-ROM(compact disk ROM) 장치, CD-R 드라이브(CD readable drive), CD-RW 드라이브(CD rewritable drive), 또는DVD-ROM 드라이브(digital versatile disk ROM drive) 등의 광 디스크 드라이브(이에 한정되지 않음)를 비롯한다른 저장 매체와 별도로 또는 그와 결합하여 저장 매체를 포함할 수 있다. 디스크 저장 장치(1224)를 시스템버스(1218)에 접속하는 것을 용이하게 해주기 위해, 통상적으로 인터페이스(1226) 등의 이동식 또는 비이동식인터페이스가 사용된다. 도 12가 사용자와 적당한 운영 환경(1210)에 기술된 기본적인 컴퓨터 자원 간의 매개체로서 기능하는 소프트웨 <75>어를 기술하고 있다는 것을 잘 알 것이다. 이러한 소프트웨어는 운영 체제(1228)를 포함한다. 디스크 저장 장치(1224) 상에 저장되어 있을 수 있는 운영 체제(1228)는 컴퓨터 시스템(1212)의 자원을 제어 및 할당하는 동작을 한다. 시스템 애플리케이션(1230)은 시스템 메모리(1216)에 또는 디스크 저장 장치(1224) 상에 저장된 프로그램 모듈(1232) 및 프로그램 데이터(1234)를 통해 운영 체제(1228)에 의한 자원의 관리를 이용한다. 본 시스템 및 방법이 다양한 운영 체제 또는 운영 체제들의 조합으로 구현될 수 있다는 것을 잘 알 것이다.사용자는 입력 장치(들)(1236)를 통해 컴퓨터(1212)에 명령 또는 정보를 입력한다. 입력 장치(1236)는 마우스 <76>등의 포인팅 장치, 트랙볼, 스타일러스, 터치 패드, 키보드, 마이크, 조이스틱, 게임 패드, 위성 안테나, 스캐너, TV 튜너 카드, 디지털 카메라, 디지털 비디오 카메라, 웹 카메라, 기타 등등을 포함하지만, 이에 한정되는것은 아니다. 이들 및 다른 입력 장치들은 인터페이스 포트(들)(1238)를 거쳐 시스템 버스(1218)를 통해 처리장치(1214)에 연결된다. 인터페이스 포트(들)(1238)는, 예를 들어, 직렬 포트, 병렬 포트, 게임 포트, 및USB(universal serial bus)를 포함한다. 출력 장치(들)(1240)는 입력 장치(들)(1236)와 동일한 유형의 포트를사용한다. 이에 따라, 예를 들어, USB 포트는 컴퓨터(1212)에 입력을 제공하고 컴퓨터(1212)로부터의 정보를출력 장치(1240)로 출력하는 데 사용될 수 있다. 특수한 어댑터를 필요로 하는 출력 장치(1240) 중에서도특히, 디스플레이(예를 들어, 평판(flat panel) 및 CRT, LED, LCD...), 스피커, 및 프린터와 같은 어떤 출력장치(1240)가 있다는 것을 나타내기 위해 출력 어댑터(1242)가 제공되어 있다. 출력 어댑터(1242)는, 제한이아닌 예로서, 출력 장치(1240) 및 시스템 버스(1218) 간의 연결 수단을 제공하는 비디오 및 사운드 카드를 포함한다. 유의해야 할 점은 원격 컴퓨터(들)(1244) 등의 기타 장치 및/또는 장치들의 시스템이 입력 및 출력 기능둘 다를 제공한다는 것이다.컴퓨터(1212)는 원격 컴퓨터(들)(1244) 등의 하나 이상의 원격 컴퓨터로의 논리적 접속을 사용하여 네트워크화 <77>된 환경에서 동작할 수 있다. 원격 컴퓨터(들)(1244)는 퍼스널 컴퓨터, 서버, 라우터, 네트워크 PC, 워크스테이션, 마이크로프로세서 기반 가전기기, 피어 장치 또는 기타 통상의 네트워크 노드, 기타 등등일 수 있으며,통상적으로 컴퓨터(1212)에 대해 기술된 구성요소들의 대부분 또는 그 전부를 포함한다. 간략함을 위해, 원격컴퓨터(들)(1244)에 메모리 저장 장치(1246)만이 도시되어 있다. 원격 컴퓨터(들)(1244)는 네트워크 인터페이스(1248)를 통해 컴퓨터(1212)에 논리적으로 접속되어 있고, 통신 접속(1250)을 통해 물리적으로 접속되어있다. 네트워크 인터페이스(1248)는 근거리 통신망(LAN) 및 원거리 통신망(WAN) 등의 통신 네트워크를 포괄한다. LAN 기술은 FDDI(Fiber Distributed Data Interface), CDDI(Copper Distributed Data Interface), 이더넷/IEEE 802.3, 토큰링/IEEE 802.5, 기타 등등을 포함한다. WAN 기술은 포인트-투-포인트 링크(point-to-- 13 -공개특허 10-2008-0032099point link), ISDN(Integrated Services Digital Network) 및 그의 변형과 같은 회선-교환 네트워크, 패킷 교환 네트워크, 및 DSL(Digital Subscriber Line)을 포함하지만, 이에 한정되지 않는다.통신 접속(들)(1250)은 네트워크 인터페이스(1248)를 버스(1218)에 접속시키는 데 이용되는 하드웨어/소프트웨 <78>어를 말한다. 통신 접속(1250)이 설명의 명확함을 위해 컴퓨터(1212) 내부에 도시되어 있지만, 이는 컴퓨터(1212)의 외부에 있을 수도 있다. 네트워크 인터페이스(1248)에의 접속을 위해 필요한 하드웨어/소프트웨어는,단지 예로서, 통상의 전화급 모뎀, 케이블 모뎀, 전력 모뎀(power modem) 및 DSL 모뎀을 비롯한 모뎀, IDSN 어댑터, 및 이더넷 카드 또는 컴포넌트 등의 내장형 및 외장형 기술을 포함한다.도 13은 개시된 본 발명이 상호작용할 수 있는 샘플-컴퓨팅 환경(1300)의 개략 블록도이다. 시스템(1300)은 하 <79>나 이상의 클라이언트(들)(1310)를 포함한다. 클라이언트(들)(1310)는 하드웨어 및/또는 소프트웨어(예를들어, 스레드, 프로세스, 컴퓨팅 장치)일 수 있다. 시스템(1200)은 또한 하나 이상의 서버(들)(1330)를 포함한다. 따라서, 시스템(1300)은, 그 중에서도 특히, 2-계층(two-tier) 클라이언트 서버 모델 또는 다층 모델(multi-tier model)(예를 들어, 클라이언트, 중간 계층 서버, 데이터 서버)에 대응할 수 있다. 서버(들)(1330)는 또한 하드웨어 및/또는 소프트웨어(예를 들어, 스레드, 프로세스, 컴퓨팅 장치)일 수 있다. 예를 들어,본 발명을 사용하여 변환을 수행하기 위해 서버(1330)들은 스레드를 포함할 수 있다. 클라이언트(1310)와 서버(1330) 간의 한가지 가능한 통신은 2개 이상의 컴퓨터 프로세스 간에 전송되도록 구성되어 있는 데이터 패킷의형태로 되어 있을 수 있다. 환경(1300)은 클라이언트(들)(1310)와 서버(들)(1330) 간의 통신을 용이하게 해주기 위해 이용될 수 있는 통신 <80>프레임워크(1350)를 포함한다. 클라이언트(들)(1310)는 클라이언트(들)(1310)에 로컬인 정보를 저장하는 데 이용될 수 있는 하나 이상의 클라이언트 데이터 저장소(들)(1360)에 연결되어 동작한다. 이와 유사하게,서버(들)(1330)는 서버들(1330)에 로컬인 정보를 저장하는 데 이용될 수 있는 하나 이상의 서버 데이터 저장소(들)(1340)에 연결되어 동작한다.이상에 기술된 것은 청구된 발명의 여러 측면들의 예를 포함한다. 물론, 청구된 발명을 기술하기 위해 모든 생 <81>각할 수 있는 컴포넌트 또는 방법의 조합을 기술할 수는 없지만, 당업자라면 개시된 발명의 많은 추가의 조합및 치환이 가능하다는 것을 잘 알 것이다. 그에 따라, 개시된 발명은 첨부된 청구항의 정신 및 범위 내에 속하는 모든 이러한 변경, 수정 및 변형을 포괄하는 것으로 보아야 한다. 게다가, 용어 \"포함한다\", \"갖는다\" 또는\"갖는\"이 상세한 설명 또는 청구항에서 사용되는 한, 이러한 용어는 \"포함하는\"이 청구항에서 이행구로서 이용될 때 용어 \"포함하는\"과 유사한 방식으로 포함적(inclusive)인 것으로 보아야 한다.도면의 간단한 설명도 1은 프로그램 코드 번역 시스템의 블록도이다. <9>도 2a는 언어 번역 또는 확장의 예시적인 도(diagram)를 도시한다. <10>도 2b는 언어 번역 또는 확장의 예시적인 도를 도시한다. <11>도 3은 맵 제작 시스템의 블록도이다. <12>도 4는 논-네이티브 맵을 얻는 언어 번역 시스템의 블록도이다. <13>도 5는 사용을 위해 맵을 식별하는 언어 번역 시스템의 블록도이다. <14>도 6은 번역 또는 확장 시스템과의 상호작용을 용이하게 하는 인터페이스 시스템의 블록도이다. <15>도 7은 언어 번역 방법론의 흐름도이다. <16>도 8은 식 번역의 방법에 대한 흐름도이다. <17>도 9는 번역 맵 방법의 흐름도이다. <18>도 10은 맵 레지스트레이션 방법론의 흐름도이다. <19>도 11은 번역 또는 확장 방법론의 흐름도이다. <20>도 12는 적합한 운영 환경을 도시하는 개략적인 블록도이다. <21>도 13은 샘플-컴퓨팅 환경의 개략적인 블록도이다. <22>- 14 -공개특허 10-2008-0032099도면 도면1 도면2a 도면2b- 15 -공개특허 10-2008-0032099 도면3 도면4- 16 -공개특허 10-2008-0032099 도면5 도면6- 17 -공개특허 10-2008-0032099 도면7 도면8- 18 -공개특허 10-2008-0032099 도면9 도면10- 19 -공개특허 10-2008-0032099 도면11 도면12- 20 -공개특허 10-2008-0032099 도면13- 21 -공개특허 10-2008-0032099"}
{"patent_id": "10-2008-7001465", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 명세서는 컴퓨터 프로그래밍 언어 및 이들의 번역 또는 변환에 관한 것이다. 제1 소스 언어로부터 제2 대상 언어로의 번역 또는 변환을 보존하는 복잡한 시맨틱보다, 변환은 구문의 변환일 수 있다. 변환은, 예를 들어, 제1 언어 및 제2 언어의 구문 사이의 관계를 정의하는 맵을 사용함으로써 이루어질 수 있다. 적어도 제1 언어의 일부의 시맨틱이 제2 대상 언어에 의해 정의될 수 있다. 따라서, 제1 언어는 확장 가능(open-ended)하고/거나 제2 언어에 기초하여 의미상(semantically) 확장가능할 수 있다."}
{"patent_id": "10-2008-7001465", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "컴퓨터 프로그램은 컴퓨터 또는 프로세서-기반 장치에 의해 수행될 동작들을 설명하는 명령어들의 목록이다. <1> 컴퓨터 프로그램이 컴퓨터 하드웨어에 로드되어 실행될 때, 컴퓨터는 컴퓨터 프로그램의 명령어들을 따름으로써 미리 결정된 방식으로 동작할 것이다. 따라서, 컴퓨터는 명령어들에 의해 미리 정해진 태스크들을 수행하는 특 수화된 기계가 된다. 프로그래밍 언어를 사용하는 프로그래머는 컴퓨터 프로그램을 구성하는 명령어들을 생성 한다. 컴퓨터 프로그램들이 더 정교해짐에 따라, 프로그래밍 언어는, 컴퓨터에 의해 쉽게 이해되는 낮은 수준 의 기계 코드 언어로부터 사람들에게 더 쉽게 이해되는 높은 수준의 소스 코드 언어들로 발전하였다. 프로그래밍 언어는 통상적으로 언어의 특성 및 특징에 기초한 범주들로 분류된다. 예를 들어, C는 절차형 <2> (procedural) 프로그래밍 언어로 설명되는데, 이는 그것이 모듈성(modularity)의 개념 및 프로그램 코드의 범위 에 기초하기 때문이다. C# 및 Java는 개체 클래스와 같은 프로그램 코드의 생성 및 조작에 맞춰진 개체-지향 프로그래밍 언어들이다. SQL(Structured Query Language) 및 XPath를 포함하는 데이터-중심 언어들은 관계형 또는 XML(Extensible Markup Language) 데이터와 같은 저장된 데이터의 검색 및 조작에 맞춰진 것이다. 이러한 특수화의 결과로서, 개별 프로그래밍 언어들은 특정한 강점 및 약점들을 갖는다. 현재의 프로그래머들은 종종 그들이 광범한 경험을 갖고 있는 특정 언어로 또는 프로젝트의 큰 부분에 가장 적 <3> 합한 특정 언어로 컴퓨터 프로그램을 개발하는 것을 선호한다. 하지만, 프로그래머들은 프로그래밍 언어들 사 이의 특수화를 이해하며, 특정 태스크들을 위해 최상의 언어를 사용하기를 바란다. 예를 들어, C# 프로그래머 는 SQL을 사용하여 관계형 데이터베이스와 인터페이스하기를 바랄 수 있으며, 따라서 SQL의 데이터-중심 양상들 및 효율로부터 이득을 얻을 수 있다. 이것을 이루기 위한 한 방법은 C# 쿼리 식을 SQL 쿼리 식으로 번역하는 것일 수 있다. 프로그래밍 언어들의 통합은 제1 언어로부터 제2 언어로의 시맨틱 번역(semantic translation) 을 필요로 한다. 이것은 제1 언어에 지정된 모든 프로그래밍 스테이트먼트(programmatic statement), 식 및 이 와 유사한 것 등의 의미가, 제1 언어에 의해 지정된 것과 동일한 의미를 갖는 제2 언어의 구문으로 번역되도록 보장한다. 종종 이것은 매우 다른 구문을 포함할 뿐 아니라 제1 언어 시맨틱을 보존하기 위한 많은 데이터 변 환을 포함한다. <발명의 개요> <4> 청구된 본 발명의 몇몇 양상들에 대한 기본적인 이해를 제공하기 위해 아래에서 간략한 개요를 제시한다. 이 <5> 개요는 광범한 개관이 아니다. 이것은 청구된 본 발명의 주요/본질적 요소들을 식별하거나 청구된 본 발명의 범위의 범위를 나타내기 위한 것이 아니다. 단 하나의 목적은, 이후에 제시되는 더 상세한 설명에 대한 서두로 - 5 -공개특허 10-2008-0032099서 몇몇 개념들을 간략한 형태로 나타내는 것이다. 간략히 설명해서, 프로그래밍 언어 번역 시스템 및 방법들이 여기에 제공된다. 구체적으로, 식(expression)들 <6> 을 포함하는, 하지만 이에 제한되지 않는, 언어 요소 또는 구성체(construct)들이, 제1 소스 언어에서 제2 대상 (target) 언어로의 구문 번역을 겪을 수 있다. 번역 또는 확장은 완전히 시맨틱하기보다는 맵 또는 매핑에 의 해 안내를 받는 구문론적(syntatic)인 것일 수 있다. 식 또는 부분식(sub-expression)의 적어도 일부는, 예를 들어, 일 대 일로 번역되어 소스 언어 식에 나타난 것이 대상 언어로 축어적(verbatim)으로 번역될 수 있다. 이러한 유형의 번역은, 무엇보다도, 시맨틱이 소스보다는 대상 언어에 의해 정의되도록 하며 예상가능한 번역을 제공한다. 더 나아가, 구문 번역에서 사용되는 맵을 생성하기 위한 시스템 및 방법들이 제공된다. 맵은 소스 및 대상 언 <7> 어의 매칭 프로그램 구문(matching program syntax)뿐 아니라 컨텍스트 또는 구현 특정 정보(implementation specific information)에 기초하여 채워질 수 있다. 맵은 번역 시스템 작성자(author) 또는 벤더에 의해 생성 될 수 있다. 추가적으로 또는 대안적으로, 논-네이티브(non-native) 맵은 접속한 이들에 의해 제공되고, 플러 그-인되고, 네이티브 맵과 같이 사용되어 한 언어에서 다른 언어로의 번역 또는 확장을 용이하게 할 수 있다. 상기한 목적 및 관련 목적을 달성하기 위해, 청구된 본 발명의 특정 예시적인 양상들은 이어지는 설명 및 첨부 <8> 된 도면과 관련하여 설명된다. 이 양상들은 본 발명이 실행될 수 있는 다양한 방법들을 나타내며, 이들은 모두 청구된 본 발명의 범위 내에 포함된다. 이어지는 상세한 설명을 도면과 함께 숙고함으로써 다른 이점들 및 참 신한 특징들이 분명해질 것이다. 실 시 예 이제 청구된 본 발명의 다양한 양상들이 첨부된 도면을 참조하여 설명되며, 같은 번호는 전체 걸쳐 유사한 또는 <23> 대응하는 요소들을 나타낸다. 하지만, 그것과 관련된 도면 및 상세한 설명은 청구된 본 발명을 개시된 특정 형 태로 제한하기 위한 것이 아니다. 오히려, 그 의도는 청구된 본 발명의 정신 및 범위 내에 포함되는 모든 변경, 동등물, 및 대안들을 포함하기 위한 것이다. 여기에 사용되는 \"컴포넌트\", \"시스템\" 및 이와 유사한 용어들은 컴퓨터-관련 엔티티를 나타내기 위한 것으로, <24> 하드웨어, 하드웨어 및 소프트웨어의 조합, 소프트웨어, 또는 실행 중인 소프트웨어를 나타낸다. 예를 들어, 컴포넌트는 프로세서에 실행 중인 프로세스, 프로세서, 개체, 실행 파일, 실행의 스레드(thread), 프로그램, 및 /또는 컴퓨터일 수 있지만, 이에 제한되는 것은 아니다. 예로서, 컴퓨터에 실행되는 애플리케이션 및 컴퓨터 모두 컴포넌트일 수 있다. 하나 이상의 컴포넌트가 프로세스 및/또는 실행의 스레드에 존재할 수 있고, 컴포넌 트는 하나의 컴퓨터에 위치하고/거나 둘 이상의 컴퓨터 사이에 분산될 수 있다. \"예시적인\"이라는 단어는 예(example), 실례(instance), 또는 예시(illustration)로서 사용되는 것을 의미하는 <25> 것으로 여기에 사용된다. 여기에 \"예시적인\"것으로 설명된 모든 양상 또는 설계가 반드시 다른 양상 또는 설계 보다 바람직하거나 유리한 것으로 이해되어서는 안된다. 또한, 개시된 본 발명은 여기에 설명된 양상들을 구현하기 위해 컴퓨터 또는 프로세서 기반 장치를 제어하는 소 <26> 프트웨어, 펌웨어, 하드웨어, 또는 이들의 임의의 조합을 제공하기 위해 표준 프로그래밍 및/또는 엔지니어링 기술들을 사용하는 시스템, 방법, 장치, 또는 제조의 물품(article of manufacture)으로서 구현될 수 있다. 여 기에 사용된 \"제조의 물품\" (또는 대안적으로 \"컴퓨터 프로그램 제품\")이라는 용어는 임의의 컴퓨터 판독가능 장치, 통신 회사, 또는 매체로부터 액세스 가능한 컴퓨터 프로그램을 포괄하기 위한 것이다. 예를 들어, 컴퓨 터 판독가능 매체는 자기 저장 장치(예를 들어, 하드 디스크, 플로피 디스크, 자기 스트립(magnetic strip)...), 광학 디스크(예를 들어, 컴팩트 디스크(CD), DVD(digital versatile disk)...), 스마트 카드, 및 플래시 메모리 장치(예를 들어, 카드, 스틱)를 포함할 수 있지만, 이에 제한되는 것은 아니다. 추가적으로, 전 자 메일을 전송하고 수신하는 데 사용되거나, 인터넷 또는 LAN(local area network)과 같은 네트워크를 액세스 하는 데 사용되는 컴퓨터 판독가능 전자 데이터를 운반하도록 반송파가 사용될 수 있다는 것을 이해해야 한다. 물론, 당업자들은 청구된 본 발명의 범위 또는 정신을 벗어나지 않으면서 이러한 구성에 많은 변경이 만들어질 수 있음을 이해할 것이다. 먼저 도 1을 참조하면, 프로그램 코드 번역 시스템이 도시된다. 시스템은 구문 분석 컴포넌트, <27> 번역 컴포넌트 및 맵을 포함한다. 구문 분석 컴포넌트는 프로그래밍 코드를 수신하고, 이를 기 호, 연산자(예를 들어, +, -, *, =, 〓, &, %...), 타입(types) 및 이와 유사한 것 등과 같은 언어의 기본 요 소들을 나타내는 토큰 및 파스 트리(parse tree)로 구문 분석한다. 이 토큰들은 개별적으로 또는 모음, 즉 파 - 6 -공개특허 10-2008-0032099스 트리로 번역 컴포넌트에 전달된다. 번역 컴포넌트는 토큰 또는 토큰의 모음을 수신하고, 이들을 제1 소스 프로그램 언어로부터 대응하는 제2 대상 언어의 요소들로 확장 또는 번역한다. 예를 들어, 제1 언어 의 등호 \"=\"는 제2 언어의 등호로 매핑될 수 있다. 이러한 번역 또는 확장을 용이하게 하기 위해, 번역 컴포넌 트는 맵과 상호작용하고 맵에 의해 안내될 수 있다. 맵은 제1 언어의 구문, 연산 및 이름 과, 제2 언어의 구문, 연산 및 이름 사이에 맵 또는 매핑을 제공한다. 맵은 프로그래밍 언어들에 공통인 기본 요소들에 대한 기록뿐 아니라, 필드, 변수 및/또는 테이블 이름과 같은 컨텍스트 또는 구현 특정 정보를 포함할 수 있다. 따라서, 구문 분석 컴포넌트로부터 특정 토큰 또는 언어 요소를 수신하면, 번역 컴포넌 트는 맵에서 그러한 요소를 식별하고 제2 언어에서 대응하는 요소 또는 요소들을 검색할 수 있다. 입력 또는 소스 코드로부터 대상 코드로의 변환 또는 번역은 완전히 구문론적일 수 있다. 하지만, 맵은 적어도 몇몇 언어 시맨틱을 구현할 수 있다. 도 2a는 도 1의 시스템에 의해 제공된 번역에 대한 이해의 명확성을 원활하게 하기 위해 간단한 예시적인 <28> 번역(200a)을 도시한다. C#로부터 SQL로의 번역으로 표현되었지만, 본 발명은 결코 이에 제한되지 않는다는 것 을 주의해야 한다. 이 예는 이와 마찬가지로 다른 언어들(예를 들어, XPath/XQuery에서 SQL로...)도 쉽게 사용 할 수 있다. 예로서, 개체-지향 언어 식 또는 코드는, 예를 들어, 구문 분석 컴포넌트에 의해 수신될 수 있고, 번역 컴포넌트에 의해 궁극적으로 SQL 코드로 번역되거나 확장될 수 있다. 여기에서, 식은 cs.where (｜c｜c.name = \"Jones\")에 대응되는 쿼리 식이다. 예시적인 식은 통상적인 개체-지향 도트(dot) 연 산자뿐 아니라, 람다 필터(lambda filter) 식 또는 부분식을 포함한다. 스테이트먼트 선언(statement declare)은 고객의 이름이 Jones인 모든 고객(customer, cs)을 찾는다. 여기에서 두 가지 주(main) 확장이 일 어난다. 먼저, 주 식(main expression) \"cs.where\"는 구문 맵에 기초하여 \"Select * From Customers Where\"로 번역 또는 확장될 수 있다. 개체-지향 스테이트먼트는, 고객 또는 고객 테이블에 대응될 수 있는 \"cs\"로부터 선택을 하는 것과 대응된다. 다음, 부분식, 즉 여기에서의 람다 식이 확장된 주 식을 채우도록 번 역되고 사용될 수 있다. 이 경우에서, 필터 또는 선택 식은 고객들(cs)로부터 이름이 Jones인 고객(c)을 선택 하라고 말한다. 이것은 간단히 name = \"Jones\"로 번역되고 Select 스테이트먼트의 Where 매개변수에 인수로 입 력될 수 있다. 시맨틱 의미에 대한 고려없이, 소스 언어의 name = \"Jones\"에서 대상 또는 목적지(destination) 언어로의 직접적인 번역이 있다는 것을 주의해야 한다. 도 2b는 도 1의 시스템의 연산에 대한 이해의 명확성을 원할하게 하기 위해 예시적인 번역 또는 확장 <29> (200b)을 도시한다. 확장(200b)은 다른 결과가 생성된다는 것을 제외하고 번역(200a)과 유사하다. 다시, 식 \"cs.where(｜c｜c.name = \"Jones\")\"이 있다. 주 식은 SQL 유형의 식, 즉 \"Select * From Customers Where\"로 확장된다. 이것은 고객 테이블에서 조건이 만족되는 것을 선택하는 것을 의미한다. 조건은 부분식에 지정되며, 여기에서는 람다 식으로 지정되어 있다. 이 경우에서, 조건 name = \"Jones\"는 다른 소정의 조건 식 으로 번역 또는 확장되어 소정의 함수가 name에 수행되고 소정의 변환이 문자열 Jones에 실행되는데, 예를 들어, 유니코드 문자열이 ASCⅡ 문자열 또는 이와 유사한 것 등으로 변환될 수 있다. 다시 말해, 같은 조건 식 이 Where 절(clause) 또는 매개변수에 조건 인수로 놓이지 않는다. 오히려, 이 경우의 확장된 식 또는 부분식 이 소스 언어에 지정된 것과 동일한 의미를 갖는 것을 보장하기 위해, 소정의 시맨틱 변환 또는 번역이 수행된 다. 여기에서, 소스 언어의 시맨틱이 유지된다. 확장(200b)이 소스 언어 식을 대상 언어 식, 스테이트먼트 등으로 번역하기 위한 실행가능한 옵션을 <30> 나타내지만, 그것과 관련된 적어도 하나의 문제가 있다. 구체적으로, 프로그래머는 소스 언어를 사용하여 프로 그래밍을 할 수 있는데, 여러 이유 중에서도, 프로그래머를 목적지 언어의 상세로부터 격리시키기 위해 소스 언 어는 나중에 대상 또는 목적지 언어로 번역된다. 예를 들어, 사용자는 속기(short hand)로서 C# 또는 XQuery/XPath로 프로그램할 수 있지만 관계형 데이터 액세스를 위한 대상 언어는 SQL일 수 있다. 프로그래머들 은 특정 식이 특정 대상 언어로 번역될 것이라는 것을 안다. 따라서, 그들은 종종 무엇이 생성되는지 보지만, 놀랍게도, 그들이 예상했던 것과 전혀 다를 수 있다. 확장(200b)으로 설명된 것과 같이, 소스 언어의 시맨틱을 유지하기 위해 다양한 변환 및 데이터 조작이 필요할 수 있다. 놀라운 결과들에 더해, 시맨틱 보전 (preservation)을 지원하는 기능성 때문에 변환된 식으로 인해 실행이 느리고 비효율적이 되기 쉽다. 그리고 또한, 소스 언어 식에서의 아주 작은 변화가 대상 언어에 엄청난 변화가 발생하도록 할 수 있는 것과 같이, 이 러한 번역은 디버그 프로세스를 엉망으로 만들 수 있다. 또한, 소스 언어 코드의 변경에 응하여 대상 언어의 변경들이 비선형(non-linear)일 뿐 아니라 예측가능하지 않기 때문에, 프로그래머들은 생성된 결과들을 어떻게 미조정(tweak)해야 하는지 모를 수 있다. 번역 또는 확장은 본질적으로 사용자 또는 프로그래머들에게 블랙 박 스(black box)이다. - 7 -공개특허 10-2008-0032099확장(200a)은 같은 문제들을 겪지 않는다. 여기서, 적어도 식의 일부, name = \"Jones\"가 일 대 일로 번역되거 <31> 나, 또는 다른 관점에서 전혀 번역되지 않고 소스에 지정된 것과 같이 복사될 수 있다. 이것은 프로그래머들에 게 예측가능성을 제공하기 때문에, 그들은 그들이 name = \"Jones\"를 지정할 때 이 조건이 목적지 언어에서 name = \"Jones\"로 번역될 것이라는 것을 안다. 소스 언어의 시맨틱을 유지하기 위해, 예상치 못한 변환들이 생성되 지 않는다. 사실, 시맨틱은 소스보다는 대상 언어로부터 비롯되는 것으로 이해된다. 이것은, 무엇보다도, 대 상 언어로부터 시맨틱 확장성을 제공한다. 따라서, 번역은 소스 언어의 임의의 시맨틱 규칙을 강요하지 않는 일종의 매크로 확장이다. 예로서, 만약 식 a * b + c가 소스 언어로 작성되면, 목적지 언어의 전례 및 결합 규 칙들이 적용된다. 따라서, 소스 언어 시맨틱이 승산(multiplication)이 먼저 행해지고 이어서 가산(addition) 이 이루어지도록 지정하고, 목적지 언어 시맨틱이 가산이 먼저 수행되도록 지정하면, 소스 언어의 시맨틱을 유 지하기 위해, (a * b) +c와 같이 식에 대한 어떠한 변환 또는 변경도 없을 것이다. 도 3을 보면, 맵 제작 시스템이 도시된다. 시스템은 구문 매치 컴포넌트, 사용자 인터페이스 컴포넌 <32> 트 및 맵 생성 컴포넌트를 포함한다. 매핑을 위해 탐색되는 두 언어가 구문 매치 컴포넌트에 제공된다. 여기서, 언어 A 및 B는 구문 매치 컴포넌트에 입력을 공급한다. 구문 매치 컴포넌트는 언어 A 및 언어 B의 구문이 매치되도록 하는 메커니즘을 제공한다. 예를 들어, 언어 A의 숫자, 기호, 및 연산 자는 같은 또는 대응되는 언어 B의 숫자, 기호, 및 연산자들에 매치(match)될 수 있다. 또한, 구문 매치 컴포 넌트는 필드, 테이블, 변수 등의 이름과 같은 컨텍스트 정보를 수신할 수 있다. 이와 같은 방식으로, 예를 들 어, \"cs\"와 같이 언어 A로 된 이름은 언어 B의 \"customer\" 테이블에 매치될 수 있다. 더 나아가, 사용자 인터 페이스 컴포넌트는 통신상 구문 매치 컴포넌트와 연결될 수 있다. 사용자 인터페이스 컴포넌트는 사 용자에게, 아마도 관리 유형(administrative type)의, 제어, 조정(coordinate), 또는 다른 방식으로 언어 구문 의 매칭에 영향을 줄 수 있는 메커니즘을 제공한다. 예를 들어, 사용자는 적절한 컨텍스트 정보가 매치되고/거 나 유사한 기능 또는 동작들이 적절하게 매치됨 보장할 수 있다. 매치 정보는 맵 생성 컴포넌트에 제공될 수 있다. 맵 생성 컴포넌트는 매치 정보로부터 맵을 생성할 수 있다. 예를 들어, 맵은 매칭 구문을 포함하는 컴퓨터 판독가능 맵 또는 매핑 파일일 수 있다. 맵은 임의의 형태로 제공될 수 있음을 이해해야 하지만, 한 실 례로 맵은 XML 파일일 수 있다. 도 4는 논-네이티브 또는 플러그-인 맵을 얻는 언어 번역 시스템이다. 도 1에서와 같은 번역 시스템은 복 <33> 수의 언어들에 대해 하나 이상의 맵을 포함할 수 있다. 하지만, 시스템은 새로운 언어, 확장, 다른 언어 및/또 는 다른 컨텍스트의 대안적인 버전(version)에 대해 새로운 논-네이티브 맵을 얻을 수 있다는 점에서 확장성을 갖는다. 시스템은 수신기 컴포넌트, 레지스트레이션 컴포넌트 및 저장소를 포함한다. 수 신기 컴포넌트는 수신, 검색하거나 다른 방식으로 컴퓨터 판독가능 맵을 얻는다. 맵은, XQuery에서 SQL로 의 매핑과 같은, 제1 언어 구문의 제2 언어 구문으로의 매핑을 포함할 수 있다. 수신되고 나면, 맵은 레지스트 레이션 컴포넌트에 제공될 수 있다. 레지스트레이션 컴포넌트는 맵을 수신하고, 컴퓨터 판독가능 저 장소로의 맵의 저장을 개시할 수 있다. 레지스트레이션 컴포넌트는 또한, 예를 들어, 소스 및 대상 언어, 및 그의 저장소 내의 위치에 의해, 맵을 식별하기 위해 레지스트리 또는 로그에 항목(entry)을 생성 및 저장할 수 있다. 등록(registeration) 후에, 맵은 도 1과 관련하여 상술된 시스템과 같은 번역 또는 확장 시스템이 사용할 수 있게 된다. 도 5를 보면, 사용을 위해 맵을 찾아내는 언어 번역 시스템이 제공된다. 시스템은 언어 식별 컴포넌 <34> 트, 맵 검색 컴포넌트, 및 저장소를 포함한다. 언어 식별 컴포넌트는 당면한(in question) 언어를 식별하기 위해, 그에 제공된 복수의 언어들을 분석한다. 언어 식별 컴포넌트는 언어들 의 ID를 맵 검색 컴포넌트에 제공한다. 언어들의 ID 및 선택적으로 몇몇 컨텍스트 정보가 주어진 맵 검색 컴포넌트는 이어서 적절한 맵을 식별할 수 있다. 예를 들어, 맵 검색 컴포넌트는 특정 소스 및 대상 언어들을 가진 맵을 식별하기 위해 레지스트리와 상호작용할 수 있다. 또한, 레지스트리는 위치를 식별하거나 적절한 맵에 대한 지시자를 제공할 수 있다. 다음, 맵은 컴퓨터 판독가능 저장소로부터 검색되어 언어 번 역 또는 확장 시스템에 제공될 수 있다. 도 6은 번역 또는 확장 시스템과 상호작용하기 위한 인터페이스 시스템을 도시한다. 시스템은 애플 <35> 리케이션 인터페이스 컴포넌트 및 번역 인터페이스 컴포넌트를 포함한다. 애플리케이션 인터페이스 컴포 넌트는 제1 컴퓨터 언어 애플리케이션과 상호작용할 수 있다. 예를 들어, 애플리케이션 인터페이스 컴포 넌트는 식, 스테이트먼트, 블록 등과 같은 프로그래밍 요소들을 수신할 수 있다. 애플리케이션 인터페이 스는 이러한 프로그래밍 요소들을 번역 인터페이스 컴포넌트에 전송 또는 제공할 수 있다. 번역 또 는 확장을 위해 이러한 프로그래밍 요소들을 제공할 수 있도록, 번역 인터페이스 컴포넌트는 번역 시스템 - 8 -공개특허 10-2008-0032099과 통신상 연결되거나 번역 시스템에 포함될 수 있다. 번역된 프로그래밍 요소 및/또는 쿼리의 결과와 같은 기 타 데이터는 번역 인터페이스 컴포넌트로부터 애플리케이션 인터페이스 컴포넌트로 다시 전송될 수 있다. 애플리케이션 인터페이스 컴포넌트 및/또는 번역 인터페이스는 번역 시스템과 상호작용하기 위한 애플리케이션-프로그래밍 인터페이스(API) 전체 또는 일부를 형성할 수 있다는 것을 이해해야 한다. 따라 서, 인터페이스는 프로그래밍 코드의 번역 또는 확장과 관련된 임의의 및 모든 정보를 전송할 수 있다. 개시된 본 발명의 양상들에 대한 이해를 더욱 용이하게 하기 위해, 예시적인 시나리오 및 솔루션이 제공된다. <36> 이 시나리오 및 솔루션은 단지 여기에 개시된 특정한 본 발명과 관련하여 명확성을 제공하기 위한 목적으로 제 공된 것이며, 어떠한 방식으로도 개시된 본 발명의 범위를 제한하기 위한 것이 아니다. 여기에 제공된 시스템 및 방법들은 여러 다양한 상황들에 적용될 수 있으며, 이 중 하나만이 아래에 설명된다. 종종 XML과 같은 관계형 데이터를, 예를 들어, 웹 서비스 또는 다른 유형의 응용을 통해 데이터베이스 사용자 <37> 에게 제공하는 것이 필요하다. 다시 말해, 제공된 XML은 관계형 데이터를 보여준다(view over). 관계형 데이 터에 대한 XML의 뷰를 사용하는 것의 주요 이점(attraction)은, 그것이 사용자들에게 그들의 평면적인 관계형 데이터에 대한 계층적 뷰를 제공하고, 이로써 더 쉽게 이 계층 구조를 탐색할 수 있게 한다는 것이다. 이러한 시나리오에서, 사용자들이 이러한 기술을 사용할지를 결정하는 여러 중요한 특징들이 있다는 것이 발견되었다. 먼저, 간단한 검색, 업데이트, 및 XML 데이터의 조작을 위한 메커니즘이 사용자들에게 중요하다. 데이터베이스 <38> 제공자 또는 소유자들은 통상적으로 어떤 XML 스키마(XSD-XML 스키마 정의)를 통해 사용자들과 계약을 구축하며, 사용자들이 XSD 스키마 내에 설명된 XML과 같은 백 엔드로부터 다시 데이터를 받을 수 있도록 한다. 사용자들은 복잡한 SQL 쿼리를 수동으로 작성할 필요없이 데이터베이스와 빨리 상호작용할 수 있는 권한을 얻기 를 바란다. 또한, 사용자들에게 고성능(high performance)뿐 아니라 단정가능한(predicable) 비헤비어를 가진 효율적 쿼리 <39> 를 제공하는 것이 중요하다. 사용자들은 성능을 해치는 변환이 적용되지 않을 것이라고 정당하게 기대한다. 예를 들어, 사용자들은 인덱스(indexed)된 열(column)들은 변환되지 않을 것이라 예상하는데, 이러한 변환은 실 질적으로 성능을 손상시키기 때문이다. 또한, 사용자들은 종종, 예를 들어, 작은 변화에 따라 쿼리가 완전히 다르게 행동하는, 비결정적(non-deterministic) 또는 비단조(non-monotonic) 비헤비어를 제공하는 애플리케이션 또는 기술을 사용하지 않는다. 또한, 사용자들은 그들의 데이터가 관계형 데이터베이스에 저장되어 있으므로, 데이터베이스에 의해 제공되는 <40> 고유한 기능성을 그들이 사용할 수 있어야 한다는 강한 견해를 갖는다. XQuery 및 SQL에서 유사한 기능이 사용 가능할 때, 사용자는 종종 SQL 기능이 대응하는 XQuery 기능에 곧바로 매핑되기를 기대한다. 다시 말해, 쿼리 가 실행될 때 SQL 기능이 사용된다. 앞서 언급된 문제들과 관련하여, 매핑 정보에 기초하여 경로 및 필터 식을 데이터 소스의 쿼리 언어로 번역 <41> (transliterate)함으로써, 데이터에 대한 XML 뷰가 쿼리될 수 있도록 언어는 설계되거나 번역될 수 있다. 예를 들어, XPath/XQuery 또는 이들의 부분집합을 사용함으로써, XML 노드와 같은 맵 대상(map target)의 위치를 찾 고 이 노드에 술어(predicate)를 적용할 수 있는 능력이 제공될 수 있다. 이 술어에서, 자신 및 자식 축(self and child axes) 상의 임의의 상대 XML 노드는 필터 식에 사용될 수 있다. 식들은 XPath/XQuery로부터 SQL로 번역될 수 있으며, 여기서 XML 항목은 매핑된 SQL 엔티티(예를 들어, 테이블, 열)로 대체되고 자식 및 특성 트 래버설(traversal)은 매핑된 테이블 사이의 적절한 관계를 통해 조인(join)으로 번역된다. 술어에 사용된 위치 경로 및 노드 정보에 기초한 적절한 테이블/열을 참조하기 위해, 쿼리는 XML 맵 또는 매핑으로의 관계 (relational)에 따라 SQL로 번역될 수 있다. 다음, SQL 쿼리의 실행에 의해 발생하는 기록들이 매핑된 XML 노 드에 구체화될 수 있다. 위치 경로는 XQuery 문법 또는 BNF(배커스 나우어 형식(Backus-Naur Form) 또는 배커스 정규형(Backus Normal <42> Form))의 일부로, SQL로의 번역을 용이하게 하는 데 필요한 정보를 경로 및 술어에 갖는다. 상대 위치 경로는 \"/\"와 같은 구분 기호로 분리된 하나 이상의 위치 단계들의 시퀀스를 포함할 수 있다. 상대 위치 경로의 단계 들은 좌에서 우로 함께 구성된다. 각 단계들은, 선행 단계의 노드의 자식인 노드를 차례로 선택한다. 절대 위 치 경로는, 선택적으로 상대 위치 경로가 이어지는 \"/\"을 포함한다. \"/\"는 홀로 컨텍스트 노드를 포함하는 문 서의 루트 노드(root node)를 선택한다. 만약 상대 위치 경로가 이어진다면, 컨텍스트 노드를 포함하는 문서의 루트 노드와 관련하여 상대 위치 경로에 의해 선택될 노드의 집합을 위치 경로가 선택한다. BNF 형식으로: - 9 -공개특허 10-2008-0032099<43> 위치 단계는 명명된 자식, 특성 또는 자신을 선택한다. 예를 들어, 다음의 BNF를 보면: <44> <45> 술어는 새로운 노드 집합을 생성할 경로와 관련하여 노드 집합을 필터링한다. 술어 식은, 경로가 컨텍스트 노 <46> 드로서 역할한다고 지정하는 노드에 기초하여 SQL로 번역된다. BNF로: <47> 필터 식을 위해 식들이 필요하다. 그루핑을 위해 괄호가 사용될 수 있다. 식에 대한 다음의 BNF를 보면: <48> <49> 연산자의 선행(precedence) 및 결합(associatively)은 SQL에서와 동일하다는 것을 주의해야 한다. 위의 문법의 <50> 효과는 선행의 순서가(높은 순위 먼저) 다음과 같다는 것이다.: <51> 식의 두 연산자가 동일한 연산자 선행 레벨을 갖고 있으면, 식 내에서의 그들의 위치에 기초하여 왼쪽에서 오른 <52> 쪽으로 평가된다. 아래에 제시되는 예를 보자. 아래의 예는 SQL 쿼리를 XML 데이터 유형으로 나타낸다. <53> <54> 관련된 매핑 파일은 다음과 같다.: <55> <56> - 10 -공개특허 10-2008-0032099적용할 수 있는 쿼리: <57> <58> 가 아래의 SQL 스테이트먼트를 생성한다. <59> <60> 앞서 언급된 시스템들은 여러 컴포넌트 간의 상호작용과 관련하여 설명되었다. 이러한 시스템 및 컴포넌트는 <61> 거기에 지정된 컴포넌트 또는 서브-컴포넌트(sub-component), 몇몇의 지정된 컴포넌트 또는 서브-컴포넌트, 및/ 또는 부가적인 컴포넌트를 포함할 수 있다는 것을 이해해야 한다. 예를 들어, 시스템은 구문 분석 컴포넌트 , 번역 컴포넌트, 구문 매치 컴포넌트, 사용자 인터페이스 컴포넌트, 맵 생성 컴포넌트 , 수신기 컴포넌트, 레지스트레이션 컴포넌트, 언어 식별 컴포넌트, 및 맵 검색 컴포넌트 , 또는 이들의 조합을 포함할 수 있다. 또한, 하나 이상의 컴포넌트가 집합적인 기능을 제공하는 하나의 컴포넌트로 결합되거나, 여러 서브-컴포넌트들로 나누어질 수 있다는 것을 주의해야 한다. 또한, 컴포넌트들은 여기에 명확하게 설명되지는 않았지만 당업자들에게 잘 알려진 하나 이상의 컴포넌트들과 상호작용할 수 있다. 더 나아가, 위에 개시된 시스템의 다양한 부분들 및 아래의 방법들은 인공 지능 또는 지식 또는 규칙 기반 컴포 <62> 넌트, 서브-컴포넌트, 프로세스, 수단, 방법론, 또는 메커니즘(예를 들어, 서포트 벡터 머신(support vector machine, SVM), 뉴럴 네트워크(neural network), 전문가 시스템, 베이지안 신뢰 네트워크(Bayesian belief network), 퍼지 논리(fuzzy logic), 데이터 융합 엔진(data fusion engine), 분류자(classifier)...)을 포함하 거나 이들로 구성될 수 있다. 이러한 컴포넌트들은, 특히, 특정 메커니즘 또는 수행되는 프로세스를 자동화할 수 있으며, 이로써 시스템 및 방법의 부분들이 더 적응적일 뿐 아니라 효율적이고 지능적이 되도록 한다. 예를 들어, 번역 컴포넌트는 코드의 확장 또는 번역을 용이하게 하기 위해 인공 지능, 기계 학습 또는 유사한 메커니즘들을 사용할 수 있다. 추가적으로 또는 대안적으로, 구문 매치 컴포넌트는 이러한 지능형 기계들 을 사용하여 복수의 언어들의 구문 매칭을 원활하게 할 수 있다. 위 설명된 예시적인 시스템에서, 개시된 본 발명에 따라 구현될 수 있는 방법론들은 도 7-11의 흐름도를 참조하 <63> 여 더 잘 이해될 것이다. 설명의 간단함을 위해, 방법론은 일련의 블록들로 도시되고 설명되며, 몇몇 블록들은 여기에 도시되고 설명된 것과 달리 다른 순서로 발생하고/거나 다른 블록들과 동시에 발생할 수 있으므로, 청구 된 본 발명은 블록들의 순서에 제한되지 않는다는 것을 이해해야 한다. 또한, 이후에 설명되는 방법론을 구현 하기 위해 모든 도시된 블록들이 필요하지 않을 수 있다. 이에 더해, 명세서 전체에 걸쳐 개시된 방법론들은, 컴퓨터로의 방법론의 전달 및 전송을 용이하게 하기 위해, <64> 제조의 물품에 저장되는 것이 가능하다. 여기에 사용된 제조의 물품이라는 용어는 임의의 컴퓨터 판독가능 장 치, 통신 회사, 또는 매체로부터 액세스 가능한 컴퓨터 프로그램을 포함하도록 의도된다. 도 7을 보면, 언어 번역 방법론이 도시된다. 단계에서, 코드가 제1 또는 소스 언어로 얻어진다. 예 <65> 로서, 제1 언어는 개체-지향 언어 또는 마크업(markup) 쿼리 언어일 수 있지만, 이에 제한되는 것은 아니다. 단계에서, 번역 또는 구문 맵의 위치가 찾아진다. 맵은 제1 소스 언어의 구문으로부터 제2 대상 언어의 구문으로의 번역에 관한 구문 정보를 제공할 수 있다. 맵은 컴퓨터 판독가능 매체에 저장되거나 번역 시스템 내에 저장될 수 있다. 단계에서, 제1 언어로부터 얻어진 코드는 구문 맵을 사용하여 제2 언어의 코드로 확장된다. 방법론은, 예를 들어, XML 기반 쿼리를, SQL일 수 있는, 관계 기반 쿼리로 번역하는 데 이용될 수 있다. 쿼리는 쿼리 프로세서에 의해 실행될 수 있고 관계형 결과들이 생성된다. 이어서 결과들을 다시 XML 로 넘기기 위해 유사한 방법론이 사용될 수 있다. 예를 들어, 같은 맵이 사용되거나, SQL이 소스이고 XML이 대 상 언어인 다른 맵이 사용될 수 있다. 다음, 결과는 맵을 이용하여 다시 XML로 번역될 수 있다. 도 8은 식 번역 방법에 대한 흐름도이다. 참조 번호에서, 소스 언어의 식(예를 들어, 쿼리 식)이 수 <66> 신, 검색되거나 다른 방식으로 얻어진다. 식은 인수로서 부분식을 포함할 수 있다. 예를 들어, 식은 데이터의 경로 또는 위치를 지정할 수 있고, 부분식은 어떤 필터 논리 또는 술어를 지정할 수 있다. 단계에서, 식 은 관련된 대상 언어의 구문의 식으로 번역된다. 이 번역 동작은 주 식과 관련될 수 있는데, 예를 들어, 개체- 지향 또는 마크업 언어 식은 쿼리될 데이터를 식별하여, SQL과 같은 대상 언어로 식이 번역되도록 한다. 예를 들어, \"cs.where(｜c｜c.name = \"Jones\")\"의 식 \"cs.where\"는 Select * From Customers Where로 번역될 수 있 - 11 -공개특허 10-2008-0032099다. 이 경우에, Where 절은 어떤 논리 또는 식을 포함하지 않는데, 이는 부분식에 의해 제공되기 때문이다. 단계에서, 부분식의 구문이 소스 언어에서 대상 언어로 번역되어 주 식으로부터 생성된 구문 또는 구조를 채운다. 부분식의 번역은 소스 언어의 시맨틱을 보존할 필요가 없다. 따라서, 부분식 또는 이의 부분은 축어 적으로 번역될 수 있고, 이로써 부분식의 구문만을 보존한다. 앞선 예에서, 부분식 \"｜c｜c.name = \"Jones\"은 간단히 \"name = \"Jones\"로 번역되고 Where 절에 인수로 제공될 수 있다. 도 9는 번역 또는 확장 맵 방법을 도시한다. 참조 번호에서, 제1 언어의 프로그램 구문이 제2 언어 <67> 의 프로그램과 매치된다. 이 동작은 자동, 반자동 또는 수동일 수 있다. 맵은 연산자와 같은 대응하는 기본 요소들의 매핑을 포함할 수 있고, 또한 데이터 또는 구현 특정 정보를 포함할 수 있는데, 예를 들어, \"cs\"는 \"customers\"라고 명명된 테이블에 대응된다. 단계에서, 생성된 맵은 사용을 위해 언어 확장/번역 시스템 에 제공될 수 있다. 방법은 네이티브 및 논-네이티브 맵 모두를 생성하도록 이용될 수 있다. 따라서, 번 역 시스템 벤더는 시스템에 포함될 맵을 생성하기 위해 방법을 이용할 수 있다. 추가적으로 또는 대안적 으로, 제3자는 그들 자신의 맵을 생성할 수 있고, 이는 시스템에 추가되거나 플러그-인 될 수 있다. 도 10은 확장 또는 번역 시스템 맵 레지스트레이션 방법을 도시한다. 예로서, 방법은 플러그-인 <68> 또는 논-네이티브 맵의 지원을 위해 이용될 수 있다. 단계에서, 구문 맵이 수신, 검색되거나 다른 방식 으로 얻어진다. 앞서 설명된 것과 같이, 맵은, 무엇보다도, 연산자 및 컨텍스트 특정 정보(예를 들어, 데이터 스키마)를 포함하는 복수의 언어들로부터 대응하는 구문을 기록할 수 있다. 단계에서, 맵이 컴퓨터 판독 가능 저장소에 저장된다. 단계에서, 맵이 등록된다. 레지스트레이션은, 특히, 맵의 위치 또는 지시자를 기록하는 것뿐 아니라 맵이 동작할 수 있는 언어들과 관련된 정보를 기록할 수 있다. 맵이 등록되고 나면, 맵 이 사용가능해진다. 방법은 네이티브뿐 아니라 논-네이티브 맵을 수신하고 이에 동작하기 위한 수단을 제공한다. 도 11을 보면, 번역 방법론의 흐름도가 도시된다. 참조 번호에서, 소스 및 대상 언어가 식별된다. <69> 예를 들어, XPath가 소스이고 SQL이 대상이거나, 이와 반대일 수 있다. 단계에서, 소스 및 대상 언어를 매핑하는 구문 맵의 위치를 찾는다. 이것은 레지스트리를 참고하고 확장을 수행하기에 적합한 맵의 위치에 대 한 지시자를 검색함으로써 이루어질 수 있다. 마지막으로, 맵을 사용하여 하나 이상의 식 또는 기타 프로그램 유닛 또는 요소들이 번역된다. 이 번역은 소스 언어의 시맨틱에 대한 완전한 강제(enforcment) 없이 일어나는, 소스의 구문으로부터 대상의 구문으로의 번역이다. 시맨틱은 대상 언어에 의해 정의될 수 있다. 개시된 본 발명의 다양한 양상들을 위한 컨텍스트를 제공하기 위해서, 도 12 및 도 13뿐 아니라 아래의 논의는 <70> 개시된 본 발명의 다양한 양상들이 구현될 수 있는 적합한 환경에 대한 간략하고 일반적인 설명을 제공하기 위 한 것이다. 위에서 본 발명이 컴퓨터 및/또는 컴퓨터들에 실행되는 컴퓨터 프로그램의 컴퓨터 실행가능 명령어 와 관련하여 설명되었지만, 당업자들은 본 발명이 또한 기타 프로그램 모듈과 함께 구현될 수 있다는 것을 이해 할 것이다. 일반적으로, 프로그램 모듈은 특정 태스크를 수행하고/거나 특정 추상 데이터 유형을 구현하는 루 틴, 프로그램, 컴포넌트, 데이터 구조 등을 포함한다. 또한, 당업자들은 독창적 방법들이 단일 프로세서 또는 멀티프로세서 컴퓨터 시스템, 미니 컴퓨팅 장치, 메인프레임 컴퓨터뿐 아니라 개인용 컴퓨터, 핸드-헬드 컴퓨팅 장치(예를 들어, PDA(personal digital assistant), 전화, 시계...), 마이크로프로세서 기반 또는 프로그램 가 능한 소비자 또는 산업 전자 제품 등을 포함하는 기타 컴퓨터 시스템 구성과 함께 실행될 수 있다는 것을 이해 할 것이다. 또한, 설명된 양상들은 통신 네트워크를 통해 연결된 원격 프로세싱 장치들에 의해 태스크가 수행 되는 분산된 컴퓨팅 환경에서 실행될 수 있다. 하지만, 본 발명의 모든 양상들은 아니더라도 몇몇은 독립 실행 형 컴퓨터에서 실행될 수 있다. 분산된 컴퓨팅 환경에서, 프로그램 모듈은 로컬 및 원격 메모리 저장 장치 둘 다에 위치할 수 있다. 도 12를 참조하면, 여기에 개시된 다양한 양상들을 구현하기 위한 예시적인 환경은 컴퓨터(예를 들 <71> 어, 데스크톱, 랩톱, 서버, 핸드-헬드, 프로그램 가능한 소비자 또는 산업 전자 제품...)를 포함한다. 컴퓨터 는 처리 장치, 시스템 메모리, 및 시스템 버스를 포함한다. 시스템 버스는 시 스템 컴포넌트들을 연결시키며, 시스템 메모리를 처리 장치와 연결시키는 것을 포함하지만 이에 제 한되지는 않는다. 처리 장치는 임의의 다양한 사용가능한 마이크로프로세서일 수 있다. 2중 마이크로프 로세서 및 다른 멀티프로세서 아키텍처 또한 처리 장치로서 사용될 수 있다. 시스템 버스는 메모리 버스 또는 메모리 컨트롤러, 주변 장치 버스 또는 외부 버스, 및/또는 11-비트 버 <72> 스, ISA(Industrial Standard Architecture) 버스, MCA(Micro-Channel Architecture), EISA(Extended ISA), IDE(Intelligent Drive Electronics), VESA 로컬 버스(VLB), PCI(Peripheral Component Interconnect), - 12 -공개특허 10-2008-0032099USB(Universal Serial Bus), AGP(Advanced Graphics Port), PCMCIA(Personal Computer Memory Card International Association bus), 및 SCSI(Small Computer Systems Interface)를 포함하지만 이에 제한되지 않 는 각종 버스 아키텍처 중 임의의 것을 이용하는 로컬 버스를 비롯한 여러 유형의 버스 구조(들) 중 어느 것이 라도 될 수 있다. 시스템 메모리는 휘발성 메모리 및 비휘발성 메모리를 포함한다. 시동 중과 같은 때에, 컴 <73> 퓨터 내의 구성요소들 사이의 정보 전송을 돕는 기본 루틴을 포함하는 기본 입/출력 시스템(BIOS)은 비휘 발성 메모리에 저장되어 있다. 예로서, 비휘발성 메모리는 ROM(read only memory), PROM(programmable Rom), EPROM(electrically programmable ROM), EEPROM(electrically erasable ROM), 또는 플래시 메모리를 포함할 수 있지만, 이에 제한되는 것은 아니다. 휘발성 메모리는 외부 캐시 메모리로 동작하는 RAM(random access memory)을 포함한다. 예로서, RAM은 SRAM(synchronous RAM), DRAM(dynamic RAM), SDRAM(synchronous DRAM), 2배속 SDRAM(DDR SDRAM), ESDRAM(enhanced SDRAM), SLDRAM(Synchlink DRAM), 및 DRRAM(direct Rambus RAM)과 같은, 하지만 이에 제한되지 않는, 여러 형태로 사용가능하다. 컴퓨터는 또한 이동식/비이동식, 휘발성/비휘발성 컴퓨터 저장 매체도 포함한다. 도 12는, 예를 들어, <74> 디스크 저장 장치를 포함한다. 디스크 저장 장치는 자기 디스크 드라이브, 플로피 디스크 드라이 브, 테이프 드라이브, 재즈(Jaz) 드라이브, 집(Zip) 드라이브, LS-100 드라이브, 플래쉬 메모리 카드, 또는 메 모리 스틱을 포함하지만, 이에 한정되는 것은 아니다. 그에 부가하여, 디스크 저장 장치는 CD- ROM(compact disk ROM) 장치, CD-R 드라이브(CD readable drive), CD-RW 드라이브(CD rewritable drive), 또는 DVD-ROM 드라이브(digital versatile disk ROM drive) 등의 광 디스크 드라이브(이에 한정되지 않음)를 비롯한 다른 저장 매체와 별도로 또는 그와 결합하여 저장 매체를 포함할 수 있다. 디스크 저장 장치를 시스템 버스에 접속하는 것을 용이하게 해주기 위해, 통상적으로 인터페이스 등의 이동식 또는 비이동식 인터페이스가 사용된다. 도 12가 사용자와 적당한 운영 환경에 기술된 기본적인 컴퓨터 자원 간의 매개체로서 기능하는 소프트웨 <75> 어를 기술하고 있다는 것을 잘 알 것이다. 이러한 소프트웨어는 운영 체제를 포함한다. 디스크 저장 장 치 상에 저장되어 있을 수 있는 운영 체제는 컴퓨터 시스템의 자원을 제어 및 할당하는 동작 을 한다. 시스템 애플리케이션은 시스템 메모리에 또는 디스크 저장 장치 상에 저장된 프로 그램 모듈 및 프로그램 데이터를 통해 운영 체제에 의한 자원의 관리를 이용한다. 본 시스 템 및 방법이 다양한 운영 체제 또는 운영 체제들의 조합으로 구현될 수 있다는 것을 잘 알 것이다. 사용자는 입력 장치(들)를 통해 컴퓨터에 명령 또는 정보를 입력한다. 입력 장치는 마우스 <76> 등의 포인팅 장치, 트랙볼, 스타일러스, 터치 패드, 키보드, 마이크, 조이스틱, 게임 패드, 위성 안테나, 스캐 너, TV 튜너 카드, 디지털 카메라, 디지털 비디오 카메라, 웹 카메라, 기타 등등을 포함하지만, 이에 한정되는 것은 아니다. 이들 및 다른 입력 장치들은 인터페이스 포트(들)를 거쳐 시스템 버스를 통해 처리 장치에 연결된다. 인터페이스 포트(들)는, 예를 들어, 직렬 포트, 병렬 포트, 게임 포트, 및 USB(universal serial bus)를 포함한다. 출력 장치(들)는 입력 장치(들)와 동일한 유형의 포트를 사용한다. 이에 따라, 예를 들어, USB 포트는 컴퓨터에 입력을 제공하고 컴퓨터로부터의 정보를 출력 장치로 출력하는 데 사용될 수 있다. 특수한 어댑터를 필요로 하는 출력 장치 중에서도 특히, 디스플레이(예를 들어, 평판(flat panel) 및 CRT, LED, LCD...), 스피커, 및 프린터와 같은 어떤 출력 장치가 있다는 것을 나타내기 위해 출력 어댑터가 제공되어 있다. 출력 어댑터는, 제한이 아닌 예로서, 출력 장치 및 시스템 버스 간의 연결 수단을 제공하는 비디오 및 사운드 카드를 포함 한다. 유의해야 할 점은 원격 컴퓨터(들) 등의 기타 장치 및/또는 장치들의 시스템이 입력 및 출력 기능 둘 다를 제공한다는 것이다. 컴퓨터는 원격 컴퓨터(들) 등의 하나 이상의 원격 컴퓨터로의 논리적 접속을 사용하여 네트워크화 <77> 된 환경에서 동작할 수 있다. 원격 컴퓨터(들)는 퍼스널 컴퓨터, 서버, 라우터, 네트워크 PC, 워크스테 이션, 마이크로프로세서 기반 가전기기, 피어 장치 또는 기타 통상의 네트워크 노드, 기타 등등일 수 있으며, 통상적으로 컴퓨터에 대해 기술된 구성요소들의 대부분 또는 그 전부를 포함한다. 간략함을 위해, 원격 컴퓨터(들)에 메모리 저장 장치만이 도시되어 있다. 원격 컴퓨터(들)는 네트워크 인터페이 스를 통해 컴퓨터에 논리적으로 접속되어 있고, 통신 접속을 통해 물리적으로 접속되어 있다. 네트워크 인터페이스는 근거리 통신망(LAN) 및 원거리 통신망(WAN) 등의 통신 네트워크를 포괄한 다. LAN 기술은 FDDI(Fiber Distributed Data Interface), CDDI(Copper Distributed Data Interface), 이더 넷/IEEE 802.3, 토큰링/IEEE 802.5, 기타 등등을 포함한다. WAN 기술은 포인트-투-포인트 링크(point-to- - 13 -공개특허 10-2008-0032099point link), ISDN(Integrated Services Digital Network) 및 그의 변형과 같은 회선-교환 네트워크, 패킷 교 환 네트워크, 및 DSL(Digital Subscriber Line)을 포함하지만, 이에 한정되지 않는다. 통신 접속(들)은 네트워크 인터페이스를 버스에 접속시키는 데 이용되는 하드웨어/소프트웨 <78> 어를 말한다. 통신 접속이 설명의 명확함을 위해 컴퓨터 내부에 도시되어 있지만, 이는 컴퓨터 의 외부에 있을 수도 있다. 네트워크 인터페이스에의 접속을 위해 필요한 하드웨어/소프트웨어는, 단지 예로서, 통상의 전화급 모뎀, 케이블 모뎀, 전력 모뎀(power modem) 및 DSL 모뎀을 비롯한 모뎀, IDSN 어 댑터, 및 이더넷 카드 또는 컴포넌트 등의 내장형 및 외장형 기술을 포함한다. 도 13은 개시된 본 발명이 상호작용할 수 있는 샘플-컴퓨팅 환경의 개략 블록도이다. 시스템은 하 <79> 나 이상의 클라이언트(들)를 포함한다. 클라이언트(들)는 하드웨어 및/또는 소프트웨어(예를 들어, 스레드, 프로세스, 컴퓨팅 장치)일 수 있다. 시스템은 또한 하나 이상의 서버(들)를 포함한 다. 따라서, 시스템은, 그 중에서도 특히, 2-계층(two-tier) 클라이언트 서버 모델 또는 다층 모델 (multi-tier model)(예를 들어, 클라이언트, 중간 계층 서버, 데이터 서버)에 대응할 수 있다. 서버(들)(133 0)는 또한 하드웨어 및/또는 소프트웨어(예를 들어, 스레드, 프로세스, 컴퓨팅 장치)일 수 있다. 예를 들어, 본 발명을 사용하여 변환을 수행하기 위해 서버들은 스레드를 포함할 수 있다. 클라이언트와 서버 간의 한가지 가능한 통신은 2개 이상의 컴퓨터 프로세스 간에 전송되도록 구성되어 있는 데이터 패킷의 형태로 되어 있을 수 있다. 환경은 클라이언트(들)와 서버(들) 간의 통신을 용이하게 해주기 위해 이용될 수 있는 통신 <80> 프레임워크를 포함한다. 클라이언트(들)는 클라이언트(들)에 로컬인 정보를 저장하는 데 이 용될 수 있는 하나 이상의 클라이언트 데이터 저장소(들)에 연결되어 동작한다. 이와 유사하게, 서버(들)는 서버들에 로컬인 정보를 저장하는 데 이용될 수 있는 하나 이상의 서버 데이터 저장소 (들)에 연결되어 동작한다. 이상에 기술된 것은 청구된 발명의 여러 측면들의 예를 포함한다. 물론, 청구된 발명을 기술하기 위해 모든 생 <81> 각할 수 있는 컴포넌트 또는 방법의 조합을 기술할 수는 없지만, 당업자라면 개시된 발명의 많은 추가의 조합 및 치환이 가능하다는 것을 잘 알 것이다. 그에 따라, 개시된 발명은 첨부된 청구항의 정신 및 범위 내에 속하 는 모든 이러한 변경, 수정 및 변형을 포괄하는 것으로 보아야 한다. 게다가, 용어 \"포함한다\", \"갖는다\" 또는 \"갖는\"이 상세한 설명 또는 청구항에서 사용되는 한, 이러한 용어는 \"포함하는\"이 청구항에서 이행구로서 이용 될 때 용어 \"포함하는\"과 유사한 방식으로 포함적(inclusive)인 것으로 보아야 한다."}
