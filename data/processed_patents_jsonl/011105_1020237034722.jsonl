{"patent_id": "10-2023-7034722", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0147761", "출원번호": "10-2023-7034722", "발명의 명칭": "블록체인 기반 데이터의 인증된 수정", "출원인": "카노비츠 마이클 이라", "발명자": "카노비츠 마이클 이라"}}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "블록체인을 운영하는 노드들의 네트워크의 노드로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의해 수행되는 방법으로서,상기 블록체인에 엔트리를 배치하기 위한 요청 메시지를 수신하는 단계로서, 상기 요청 메시지는, (i) 액션 및상기 액션의 대상이 되는 적어도 하나의 당사자의 아이덴티티를 포함하는 엔트리에 대한 요청 사양, (ii) 상기엔트리가 신뢰 엔티티(trusted entity)에 의해 승인되었음을 지정하는 인디케이터, 및 (iii) 대응하는 복수의신뢰 검증자들에 의해 생성된 복수의 암호화 검증 코드들 ― 각각의 암호화 검증 코드는, 상기 신뢰 엔티티에의해 제공되고 상기 신뢰 검증자들의 각각에 의해 암호화 방식으로 서명된 인코딩된 액션 페이로드를 포함함 ―을 포함하는 상기 수신하는 단계;대응하는 상기 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적용하여 대응하는 인코딩된 액션페이로드를 해독하는 단계;적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 단계; 및적어도 상기 제1 검증을 수행하는 단계에 응답하여 상기 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 단계를 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 요청 사양에 페이로드 인코더 함수를 적용하여 로컬 버전의 인코딩된 액션 페이로드를 도출하는 단계; 및상기 로컬 버전의 인코딩된 액션 페이로드가, 동일한 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계를 더 포함하고,적어도 상기 제1 검증을 수행하는 단계에 응답하여 상기 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 단계는 상기 제1 검증 및 상기 제2 검증 모두를 수행하는 것에 응답하여 상기 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 단계를 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항 또는 제2항에 있어서, 상기 임계 수는 복수의 총 수, 상기 복수의 총 수의 다수, 또는 상기 복수의 총 수의 지정된 분율에 가장 가까운 정수 중 하나와 동일한 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항 또는 제2항에 있어서, 상기 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 단계는,비교를 위해 미리 결정된 수의 해독된 대응하는 인코딩된 액션 페이로드들을 선택하는 단계를 포함하고,상기 임계 수는 미리 결정된 수와 동일하고,상기 선택은 무작위 중 하나이거나 대응하는 상기 복수의 신뢰 검증자들 중의 특정 신뢰 검증자들의 규정된 아이덴티티들에 기초하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항 내지 제4항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는 해시를 포함하고, 상기 페이로드 인코더 함수는공개특허 10-2023-0147761-3-해시 함수를 포함하고,각각의 대응하는 인코딩된 액션 페이로드는 대응하는 해시값을 포함하고, 상기 로컬 버전의 인코딩된 액션 페이로드는 로컬 해시값을 포함하고,상기 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 단계는,적어도 임계 수의 대응하는 해시값들이 동일하다는 것을 검증하는 단계를 포함하고,상기 로컬 버전의 인코딩된 액션 페이로드가, 동일한 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계는, 상기 로컬 해시값이, 동일한 적어도 임계 수의 대응하는 해시값들의 것과 동일하다는 것을 검증하는 단계를 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항 내지 제4항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는, 상기 신뢰 엔티티에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항 내지 제4항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는, 상기 요청 사양의 자연어 디스크립션에 기초하여인공 지능 엔진에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항 내지 제7항 중 어느 한 항에 있어서, 상기 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 단계는 채굴 절차에 입력되는 엔트리를 후보 블록에 포함시키는 단계를 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항 내지 제8항 중 어느 한 항에 있어서, 상기 적어도 하나의 당사자는 상기 블록체인에 기록된 특정 디지털 자산들과 연관되고,상기 액션은,상기 특정 디지털 자산들의 지정된 금액을 상기 적어도 하나의 당사자로부터 블록체인과 연관된 다른 당사자에게 이전하는 것;상기 특정 디지털 자산들의 지정된 금액을 동결하는 것;상기 특정 디지털 자산들의 지정된 금액을 동결 해제하는 것;상기 특정 디지털 자산들의 지정된 금액을 적어도 하나의 당사자로부터 상기 블록체인과 연관된 에스크로(escrow) 계정으로 이전하는 것; 또는상기 특정 디지털 자산들의 지정된 금액을 상기 적어도 하나의 당사자로부터 상기 블록체인과 연관된 특정 계정으로 이전하는 것 중 적어도 하나인 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1항 내지 제9항 중 어느 한 항에 있어서, 상기 액션의 실행은, 지정된 날짜 및 시간으로부터 지정된 시간량만큼 지연되는 것 또는 특정 날짜 및 시간으로스케줄링되는 것 중 하나인 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "블록체인을 운영하는 노드들의 네트워크의 노드로서 동작하기 위해 구성되는 컴퓨팅 시스템으로서,공개특허 10-2023-0147761-4-적어도 하나의 프로세서; 및상기 적어도 하나의 프로세서에 의한 실행 시, 노드로 하여금 제1항 내지 제10항 중 어느 한 항에 기재된 방법을 수행하게 하는 명령어들을 저장하는 메모리를 포함하는 컴퓨팅 시스템."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "블록체인을 운영하는 노드들의 네트워크의 노드로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의한 실행 시, 노드로 하여금 제1항 내지 제10항 중 어느 한 항에 기재된 방법을 수행하게 하는 프로그램 명령어들이 저장된 비일시적인 컴퓨터 판독 가능한 매체를 포함하는 제조 물품."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "블록체인을 운영하는 노드들의 네트워크의 노드로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의해 수행되는 방법으로서,상기 블록체인에 이전에 입력된 스마트 계약의 비상 액션을 호출하기 위해 구성되는 블록체인에 엔트리를 배치하기 위한 요청 메시지를 수신하는 단계로서, 상기 요청 메시지는, (i) 상기 스마트 계약에 대한 링크, 상기 비상 액션의 식별자, 및 상기 비상 액션을 호출하도록 승인된 지정된 액션 호출자의 아이덴티티를 포함하는 요청사양, (ii) 상기 엔트리가 신뢰 엔티티에 의해 승인되었음을 지정하는 인디케이터, 및 (iii) 대응하는 복수의신뢰 검증자들에 의해 생성된 복수의 암호화 검증 코드들 ― 각각의 암호화 검증 코드는, 상기 신뢰 엔티티에의해 제공되고 상기 신뢰 검증자들의 각각에 의해 암호화 방식으로 서명된 인코딩된 액션 페이로드를 포함함 ―을 포함하는 상기 수신하는 단계;대응하는 상기 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적용하여 대응하는 인코딩된 액션페이로드를 해독하는 단계;적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 단계;적어도 상기 제1 검증을 수행하는 단계에 응답하여 트랜잭션 사양을 생성하고 상기 트랜잭션 사양을 상기 엔트리에 배치하는 단계 ― 상기 생성된 트랜잭션 사양은 지정된 액션 호출자의 인증된 에일리어스(alias)로서 활동하는 상기 신뢰 엔티티에 의해 승인된 식별된 비상 액션을 실행하라는 지시문을 포함함 ―; 및상기 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 단계를 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서, 상기 요청 사양에 페이로드 인코더 함수를 적용하여 로컬 버전의 인코딩된 액션 페이로드를 도출하는 단계; 및상기 로컬 버전의 인코딩된 액션 페이로드가, 동일한 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계를 더 포함하고,상기 적어도 상기 제1 검증을 수행하는 단계에 응답하여 상기 트랜잭션 사양을 생성하고 상기 트랜잭션 사양을상기 엔트리에 배치하는 단계는 상기 제1 검증과 상기 제2 검증 모두를 수행하는 것에 응답하여 상기 트랜잭션사양을 생성하고 상기 트랜잭션 사양을 상기 엔트리에 배치하는 단계를 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제13항 또는 제14항에 있어서, 상기 블록체인에 이전에 입력된 스마트 계약의 식별된 비상 액션이 실행되게 하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제13항 내지 제15항 중 어느 한 항에 있어서, 상기 요청 사양은 상기 식별된 비상 액션의 하나 이상의 파라미터를 더 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "공개특허 10-2023-0147761-5-제13항 내지 제16항 중 어느 한 항에 있어서, 상기 임계 수는 복수의 총 수, 상기 복수의 총 수의 다수, 또는 상기 복수의 총 수의 지정된 분율에 가장 가까운 정수 중 하나와 동일한 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제13항 내지 제16항 중 어느 한 항에 있어서, 상기 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 단계는,비교를 위해 미리 결정된 수의 해독된 대응하는 인코딩된 액션 페이로드들을 선택하는 단계를 포함하고,상기 임계 수는 미리 결정된 수와 동일하고,상기 선택은 무작위 중 하나이거나 대응하는 상기 복수의 신뢰 검증자들 중의 특정 신뢰 검증자들의 규정된 아이덴티티들에 기초하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제14항 내지 제18항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는 해시를 포함하고, 상기 페이로드 인코더 함수는해시 함수를 포함하고,각각의 대응하는 인코딩된 액션 페이로드는 대응하는 해시값을 포함하고, 상기 로컬 버전의 인코딩된 액션 페이로드는 로컬 해시값을 포함하고,상기 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 단계는,적어도 임계 수의 대응하는 해시값들이 동일하다는 것을 검증하는 단계를 포함하고,상기 로컬 버전의 인코딩된 액션 페이로드가, 동일한 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계는, 상기 로컬 해시값이, 동일한 적어도 임계 수의 대응하는 해시값들의 것과 동일하다는 것을 검증하는 단계를 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제13항 내지 제18항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는, 상기 신뢰 엔티티에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제13항 내지 제18항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는, 상기 요청 사양의 자연어 디스크립션에 기초하여인공 지능 엔진에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제13항 내지 제21항 중 어느 한 항에 있어서, 상기 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 단계는 채굴 절차에 입력되는 엔트리를 후보 블록에 포함시키는 것을 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제15항 내지 제22항 중 어느 한 항에 있어서, 상기 블록체인에 이전에 입력된 스마트 계약의 식별된 비상 액션이 실행되게 하는 단계는, 실행이 지정된 날짜및 시간으로부터 지정된 시간량만큼 지연되는 것 또는 지정된 날짜 및 시간으로 스케줄링되는 것 중 하나이게하는 단계를 포함하는 방법.공개특허 10-2023-0147761-6-청구항 24 블록체인을 운영하는 노드들의 네트워크의 노드로서 동작하기 위해 구성되는 컴퓨팅 시스템으로서,적어도 하나의 프로세서; 및상기 적어도 하나의 프로세서에 의한 실행 시, 노드로 하여금 제13항 내지 제23항 중 어느 한 항에 기재된 방법을 수행하게 하는 명령어들을 저장하는 메모리를 포함하는 컴퓨팅 시스템."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "블록체인을 운영하는 노드들의 네트워크의 노드로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의한 실행 시, 노드로 하여금 제13항 내지 제23항 중 어느 한 항에 기재된 방법을 수행하게 하는 프로그램 명령어들이 저장된 비일시적인 컴퓨터 판독 가능한 매체를 포함하는 제조 물품."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "블록체인 네트워크에 입력되는 디지털 자산들에 대한 인코딩된 액션 트리거들을 검증하고 저장하기 위한 데이터베이스 서버로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의해 수행되는 방법으로서,상기 블록체인 네트워크에 입력되는 디지털 트랜잭션에 대한 검증 액션 트리거를 검증하고 저장하기 위한 요청메시지를 수신하는 단계 ― 상기 요청 메시지는 액션 및 상기 액션의 대상이 되는 디지털 자산과 연관된 적어도하나의 당사자의 아이덴티티를 포함하는 요청 사양을 포함함 ―;대응하는 복수의 신뢰 검증자들에 의해 독립적으로 생성된 복수의 암호화 검증 코드들을 수신하는 단계 ― 각각의 암호화 검증 코드는 신뢰 엔티티로부터 소싱(sourcing)되고 상기 신뢰 검증자들의 각각에 의해 암호화 방식으로 서명된 트리거 코드를 포함함 ―;대응하는 상기 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적용하여 대응하는 트리거 코드를해독하는 단계;적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증을 수행하는 단계;상기 요청 사양에 인코더 함수를 적용하여 상기 액션과 연관된 로컬 버전의 트리거 코드를 도출하는 단계;상기 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트리거 코드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계; 및상기 트리거 코드를 상기 검증 액션 트리거로서 상기 컴퓨팅 시스템과 연관된 데이터베이스에 저장하는 단계를포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "제26항에 있어서, 상기 임계 수는 복수의 총 수, 상기 복수의 총 수의 다수, 또는 상기 복수의 총 수의 지정된 분율에 가장 가까운 정수 중 하나와 동일한 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "제26항 또는 제27항에 있어서, 상기 적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증을 수행하는 단계는, 비교를 위해미리 결정된 수의 해독된 대응하는 트리거 코드들을 선택하는 단계를 포함하고,상기 임계 수는 미리 결정된 수와 동일하고,상기 선택은 무작위 중 하나이거나 대응하는 상기 복수의 신뢰 검증자들 중의 특정 신뢰 검증자들의 규정된 아이덴티티들에 기초하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "제26항 내지 제28항 중 어느 한 항에 있어서, 공개특허 10-2023-0147761-7-상기 신뢰 엔티티에 의해 제공되는 트리거 코드는 해시를 포함하고, 상기 인코더 함수는 해시 함수를 포함하고,각각의 대응하는 트리거 코드는 대응하는 해시값을 포함하고, 상기 로컬 버전의 트리거 코드는 로컬 해시값을포함하고,상기 적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증을 수행하는 단계는, 적어도 임계수의 대응하는 해시값들이 동일하다는 것을 검증하는 단계를 포함하고,상기 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트리거 코드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계는, 상기 로컬 해시값이, 동일한 적어도 임계 수의 대응하는 해시값들의 것과동일하다는 것을 검증하는 단계를 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "제26항 내지 제29항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 트리거 코드는 상기 신뢰 엔티티에 의해 생성되고 컴퓨팅 장치에 의해 해석가능한 요청 사양의 의미론적 표현을 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "제26항 내지 제29항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 트리거 코드는, 상기 요청 사양의 자연어 디스크립션에 기초하여 인공 지능엔진에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제26항 내지 제31항 중 어느 한 항에 있어서, 상기 적어도 하나의 당사자는 상기 블록체인에 기록된 특정 디지털 자산들과 연관되고,상기 액션은,상기 디지털 자산의 지정된 금액을 상기 적어도 하나의 당사자로부터 블록체인과 연관된 다른 당사자에게 이전하는 것;상기 디지털 자산의 지정된 금액을 동결하는 것;상기 디지털 자산의 지정된 금액을 동결 해제하는 것;상기 디지털 자산의 지정된 금액을 상기 적어도 하나의 당사자로부터 상기 블록체인과 연관된 에스크로 계정으로 이전하는 것; 또는상기 디지털 자산의 지정된 금액을 상기 적어도 하나의 당사자로부터 상기 블록체인과 연관된 특정 계정으로 이전하는 것 중 적어도 하나인 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "제26항 내지 제32항 중 어느 한 항에 있어서, 상기 액션의 실행은 지정된 날짜 및 시간으로부터 지정된 시간량만큼 지연되는 것 또는 특정 날짜 및 시간으로스케줄링되는 것 중 하나인 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제26항 내지 제33항 중 어느 한 항에 있어서,상기 블록체인 네트워크의 노드 장치로부터 요청을 수신하는 것에 응답하여, 검증된 트리거 코드의 사본을 상기노드 장치에 송신하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "블록체인 네트워크에 입력되는 디지털 자산들에 대한 인코딩된 액션 트리거들을 검증하고 저장하기 위한 데이터공개특허 10-2023-0147761-8-베이스 서버로서 동작하기 위해 구성되는 컴퓨팅 시스템으로서,적어도 하나의 프로세서; 및상기 적어도 하나의 프로세서에 의한 실행 시, 노드로 하여금 제26항 내지 제34항 중 어느 한 항에 기재된 방법을 수행하게 하는 명령어들을 저장하는 메모리를 포함하는 컴퓨팅 시스템."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "블록체인 네트워크에 입력되는 디지털 자산들에 대한 인코딩된 액션 트리거들을 검증하고 저장하기 위한 데이터베이스 서버로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의한 실행 시, 노드로 하여금 제26항 내지 제34항 중어느 한 항에 기재된 방법을 수행하게 하는 프로그램 명령어들이 저장된 비일시적인 컴퓨터 판독 가능한 매체를포함하는 제조 물품."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "블록체인 네트워크에 입력되는 스마트 계약들에 대한 인코딩된 액션 트리거들을 검증하고 저장하기 위한 데이터베이스 서버로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의해 수행되는 방법으로서,상기 블록체인 네트워크에 입력되는 스마트 계약에 대한 검증 액션 트리거를 검증하고 저장하기 위한 요청 메시지를 수신하는 단계 ― 상기 요청 메시지는 상기 스마트 계약에 대한 링크 및 상기 스마트 계약의 비상 액션의식별자를 포함하는 요청 사양을 포함함 ―;대응하는 복수의 신뢰 검증자들에 의해 독립적으로 생성된 복수의 암호화 검증 코드들을 수신하는 단계 ― 각각의 암호화 검증 코드는 신뢰 엔티티로부터 소싱되고 신뢰 검증자들의 각각에 의해 암호화 방식으로 서명된 트리거 코드를 포함함 ―;대응하는 상기 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적용하여 대응하는 트리거 코드를해독하는 단계;적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증을 수행하는 단계;상기 요청 사양에 인코더 함수를 적용하여 상기 비상 액션과 연관된 로컬 버전의 트리거 코드를 도출하는 단계;상기 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트리거 코드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계; 및상기 트리거 코드를 상기 검증 액션 트리거로서 상기 컴퓨팅 시스템과 연관된 데이터베이스에 저장하는 단계를포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "제37항에 있어서, 상기 임계 수는 복수의 총 수, 상기 복수의 총 수의 다수, 또는 상기 복수의 총 수의 지정된 분율에 가장 가까운 정수 중 하나와 동일한 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_39", "content": "제37항 또는 제38항에 있어서, 상기 적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증을 수행하는 단계는, 비교를 위해미리 결정된 수의 해독된 대응하는 트리거 코드들을 선택하는 단계를 포함하고,상기 임계 수는 미리 결정된 수와 동일하고,상기 선택은 무작위 중 하나이거나 대응하는 상기 복수의 신뢰 검증자들 중의 특정 신뢰 검증자들의 규정된 아이덴티티들에 기초하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "제37항 내지 제39항 중 어느 한 항에 있어서, 공개특허 10-2023-0147761-9-상기 신뢰 엔티티에 의해 제공되는 트리거 코드는 해시를 포함하고, 상기 인코더 함수는 해시 함수를 포함하고,각각의 대응하는 트리거 코드는 대응하는 해시값을 포함하고, 상기 로컬 버전의 트리거 코드는 로컬 해시값을포함하고,상기 적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증을 수행하는 단계는, 적어도 임계수의 대응하는 해시값들이 동일하다는 것을 검증하는 단계를 포함하고,상기 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트리거 코드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계는, 상기 로컬 해시값이, 동일한 적어도 임계 수의 대응하는 해시값들의 것과동일하다는 것을 검증하는 단계를 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "제37항 내지 제40항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 트리거 코드는 상기 신뢰 엔티티에 의해 생성되고 컴퓨팅 장치에 의해 해석가능한 요청 사양의 의미론적 표현을 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "제37항 내지 제40항 중 어느 한 항에 있어서, 상기 신뢰 엔티티에 의해 제공되는 트리거 코드는, 상기 요청 사양의 자연어 디스크립션에 기초하여 인공 지능엔진에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_43", "content": "제37항 내지 제42항 중 어느 한 항에 있어서, 상기 액션의 실행은, 지정된 날짜 및 시간으로부터 지정된 시간량만큼 지연되는 것 또는 특정 날짜 및 시간으로스케줄링되는 것 중 하나인 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_44", "content": "제37항 내지 제43항 중 어느 한 항에 있어서,상기 블록체인 네트워크의 노드 장치로부터 요청을 수신하는 것에 응답하여, 검증된 트리거 코드의 사본을 상기노드 장치에 송신하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_45", "content": "블록체인 네트워크에 입력되는 스마트 계약들에 대한 인코딩된 액션 트리거들을 검증하고 저장하기 위한 데이터베이스 서버로서 동작하기 위해 구성되는 컴퓨팅 시스템으로서,적어도 하나의 프로세서; 및상기 적어도 하나의 프로세서에 의한 실행 시, 노드로 하여금 제37항 내지 제44항 중 어느 한 항에 기재된 방법을 수행하게 하는 명령어들을 저장하는 메모리를 포함하는 컴퓨팅 시스템."}
{"patent_id": "10-2023-7034722", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_46", "content": "블록체인 네트워크에 입력되는 스마트 계약들에 대한 인코딩된 액션 트리거들을 검증하고 저장하기 위한 데이터베이스 서버로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의한 실행 시, 노드로 하여금 제37항 내지 제44항 중어느 한 항에 기재된 방법을 수행하게 하는 프로그램 명령어들이 저장된 비일시적인 컴퓨터 판독 가능한 매체를포함하는 제조 물품."}
{"patent_id": "10-2023-7034722", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "블록체인의 노드에 대한 예시적인 시스템들 및 방법들이 개시된다. 노드는 블록체인에 엔트리를 배치하기 위한 요청 메시지를 수신할 수 있고, 메시지는, 액션 및 액션의 대상이 되는 당사자의 아이덴티티를 포함하는 요청 사 양, 엔트리가 신뢰 엔티티(trusted entity)에 의해 승인되었다는 인디케이터, 및 복수의 신뢰 검증자들에 의해 생성된 복수의 암호화 검증 코드들 ― 각 암호화 검증 코드는 신뢰 엔티티로부터 제공되고 신뢰 검증자들의 하나 에 의해 암호화 방식으로 서명된 인코딩된 액션 페이로드를 포함함 ― 을 포함한다. 노드는 암호화 검증 코드에 각 신뢰 검증자의 공개 암호화 키를 적용하여 인코딩된 액션 페이로드를 해독하고, 이어서 적어도 임계 수의 해 독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 것을 검증할 수 있다. 이어서, 노드는 적어도 검증에 응 답하여 블록체인에 추가될 처리를 위한 엔트리를 제출할 수 있다."}
{"patent_id": "10-2023-7034722", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "관련 출원에 대한 상호 참조 본 출원은, 2022년 3월 8일에 출원된 미국 가특허출원 제63/317,750호, 2022년 3월 7일에 출원된 미국 가특허출 원 제63/317,370호, 2022년 2월 16일에 출원된 미국 가특허출원 제63/268,095호, 2021년 11월 9일에 출원된 미 국 가특허출원 제63/263,789호, 2021년 7월 23일에 출원된 미국 가특허출원 제63/225,053호, 및 2021년 3월 12 일에 출원된 미국 가특허출원 제63/160,317호에 기초하여 우선권을 주장하고, 이들 모두는 그 전체 내용이 참조 에 의해 본원에 포함된다."}
{"patent_id": "10-2023-7034722", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "분산형, 비집중형 네트워크는 일반적으로 \"노드들\"이라고 불리는 엔티티들의 네트워크이고, 그들 각각은 다른 가능한 정보 중에서 네트워크 전체의 현재 상태를 저장 또는 기록한다. 네트워크 전체의 상태는 개별 상태들로 구성될 수 있고, 각 상태는 개별 상태를 \"소유\"하는 엔티티와 연관된다. 상태의 소유 엔티티는 일반적으로 \"소 유자\"라고 지칭된다. 분산형, 비집중형 네트워크의 특성들 및 속성들 중에는, 개별 상태들이 어떻게 및 어떤 상황에서 변경될 수 있는지를 관리하는 규칙 및/또는 프로토콜 세트에 각 노드가 구속되거나 합의한다는 원칙이 있다. 예를 들면, 제안되는 변경들이 다수의 노드들에 의해 합의될 필요가 있고, 하나 이상의 제안되는 상태 변경의 집단에 대해 임의의 형태의 작업 증명 또는 지분 증명이 수행될 필요가 있다. 또 다른 규칙은, 상태의 소유자만이 해당 상태에 대한 제안 변경을 호출하거나 시작할 수 있도록 요구할 수도 있다. 블록체인 네트워크는 분산형, 비집중형 네트워크의 일례이다. 구체적으로, 블록체인 네트워크는 데이터 구조들 또는 \"블록들\"의 시퀀스를 포함할 수 있고, 그 각각의 블록은, 각각의 블록이 시퀀스에 추가된 시점까지 네트워 크 상태들의 전체 이력을 기록한다. 블록들의 시퀀스는 연결된 체인을 형성하고, 각 블록은, 실제로는 아닐지 라도, 실질적으로 체인에 입력되면 수정이 불가능한 방식으로 인코딩된다. 업데이트된 상태를 기록(시간적 스 냅샷)하는 새 블록들을 추가할 수 있지만, 기존 블록들을 변경할 수 없다. 즉, 블록체인은 역방향으로 불변적 이다. 블록체인들의 역방향 불변성은, 블록체인들의 분산형, 비집중형 특성과 함께, 블록들에 기록된 잘못되거나 달리 결함이 있는 네트워크 상태들을 수정하는 데 장애가 될 수 있다. 발명자들은 분산형, 비집중형 네트워크들에서 문제가 있는 네트워크 상태 기록을 교정할 수 있으면서도, 분산형, 비집중형 특성을 훼손하지 않고 이를 행할 수 있는 능력이 필요함을 인식했다. 따라서, 발명자들은 이 바람직한 목표들을 달성하기 위한 기술, 방법, 및 시스템을 고안했다. 따라서, 제1 예시적인 실시형태는 블록체인을 운영하는 노드들의 네트워크의 노드로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의해 수행되는 방법을 포함할 수 있다. 이 방법은, 상기 블록체인에 엔트리를 배치하기 위한 요청 메시지를 수신하는 단계로서, 상기 요청 메시지는, (i) 액션 및 상기 액션의 대상이 되는 적어도 하나의 당사자의 아이덴티티를 포함하는 엔트리에 대한 요청 사양, (ii) 상기 엔트리가 신뢰 엔티티(trusted entity)에 의해 승인되었음을 지정하는 인디케이터, 및 (iii) 대응하는 복수의 신뢰 검증자들에 의해 생성된 복수의 암호 화 검증 코드들 ― 각각의 암호화 검증 코드는, 상기 신뢰 엔티티에 의해 제공되고 상기 신뢰 검증자들의 각각 에 의해 암호화 방식으로 서명된 인코딩된 액션 페이로드를 포함함 ― 을 포함하는 상기 수신하는 단계; 대응하 는 상기 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적용하여 대응하는 인코딩된 액션 페이로 드를 해독하는 단계; 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수 행하는 단계; 및 적어도 상기 제1 검증을 수행하는 단계에 응답하여 상기 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 단계를 포함하는 동작들을 포함할 수 있다. 제2 예시적인 실시형태는 블록체인을 운영하는 노드들의 네트워크의 노드로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의해 수행되는 방법을 포함할 수 있다. 이 방법은, 상기 블록체인에 이전에 입력된 스마트 계약의 비 상 액션을 호출하기 위해 구성되는 블록체인에 엔트리를 배치하기 위한 요청 메시지를 수신하는 단계로서, 상기 요청 메시지는, (i) 상기 스마트 계약에 대한 링크, 상기 비상 액션의 식별자, 및 상기 비상 액션을 호출하도록 승인된 지정된 액션 호출자의 아이덴티티를 포함하는 요청 사양, (ii) 상기 엔트리가 신뢰 엔티티에 의해 승인 되었음을 지정하는 인디케이터, 및 (iii) 대응하는 복수의 신뢰 검증자들에 의해 생성된 복수의 암호화 검증 코 드들 ― 각각의 암호화 검증 코드는, 상기 신뢰 엔티티에 의해 제공되고 상기 신뢰 검증자들의 각각에 의해 암 호화 방식으로 서명된 인코딩된 액션 페이로드를 포함함 ― 을 포함하는 상기 수신하는 단계; 대응하는 상기 암 호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적용하여 대응하는 인코딩된 액션 페이로드를 해독하 는 단계; 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는단계; 적어도 상기 제1 검증을 수행하는 단계에 응답하여 트랜잭션 사양을 생성하고 상기 트랜잭션 사양을 상기 엔트리에 배치하는 단계 ― 상기 생성된 트랜잭션 사양은 지정된 액션 호출자의 인증된 에일리어스(alias)로서 활동하는 상기 신뢰 엔티티에 의해 승인된 식별된 비상 액션을 실행하라는 지시문을 포함함 ―; 및 상기 블록체 인에 추가될 블록 처리를 위한 엔트리를 제출하는 단계를 포함하는 동작들을 포함할 수 있다. 제3 예시적인 실시형태는 블록체인 네트워크에 입력되는 디지털 자산들에 대한 인코딩된 액션 트리거들을 검증 하고 저장하기 위한 데이터베이스 서버로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의해 수행되는 방법을 포 함할 수 있다. 이 방법은, 상기 블록체인 네트워크에 입력되는 디지털 트랜잭션에 대한 검증 액션 트리거를 검 증하고 저장하기 위한 요청 메시지를 수신하는 단계 ― 상기 요청 메시지는 액션 및 상기 액션의 대상이 되는 디지털 자산과 연관된 적어도 하나의 당사자의 아이덴티티를 포함하는 요청 사양을 포함함 ―; 대응하는 복수의 신뢰 검증자들에 의해 독립적으로 생성된 복수의 암호화 검증 코드들을 수신하는 단계 ― 각각의 암호화 검증 코드는 신뢰 엔티티로부터 소싱(sourcing)되고 상기 신뢰 검증자들의 각각에 의해 암호화 방식으로 서명된 트리 거 코드를 포함함 ―; 대응하는 상기 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적용하여 대 응하는 트리거 코드를 해독하는 단계; 적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증 을 수행하는 단계; 상기 요청 사양에 인코더 함수를 적용하여 상기 액션과 연관된 로컬 버전의 트리거 코드를 도출하는 단계; 상기 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트리거 코드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계; 및 상기 트리거 코드를 상기 컴퓨팅 시스템과 연관된 데이 터베이스에 상기 검증 액션 트리거로서 저장하는 단계를 포함하는 동작들을 포함할 수 있다. 제4 예시적인 실시형태는, 블록체인 네트워크에 입력되는 스마트 계약들에 대한 인코딩된 액션 트리거들을 검증 하고 저장하기 위한 데이터베이스 서버로서 동작하기 위해 구성되는 컴퓨팅 시스템에 의해 수행되는 방법을 포 함할 수 있다. 이 방법은, 상기 블록체인 네트워크에 입력되는 스마트 계약에 대한 검증 액션 트리거를 검증하 고 저장하기 위한 요청 메시지를 수신하는 단계 ― 상기 요청 메시지는 상기 스마트 계약에 대한 링크 및 상기 스마트 계약의 비상 액션의 식별자를 포함하는 요청 사양을 포함함 ―; 대응하는 복수의 신뢰 검증자들에 의해 독립적으로 생성된 복수의 암호화 검증 코드들을 수신하는 단계 ― 각각의 암호화 검증 코드는 신뢰 엔티티로부 터 소싱되고 신뢰 검증자들의 각각에 의해 암호화 방식으로 서명된 트리거 코드를 포함함 ―; 대응하는 상기 암 호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적용하여 대응하는 트리거 코드를 해독하는 단계; 적 어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증을 수행하는 단계; 상기 요청 사양에 인 코더 함수를 적용하여 상기 비상 액션과 연관된 로컬 버전의 트리거 코드를 도출하는 단계; 상기 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트리거 코드들의 각각의 것과 동일하다는 제2 검증을 수행하는 단계; 및 상기 트리거 코드를 상기 컴퓨팅 시스템과 연관된 데이터베이스에 검증 액션 트리거로서 저 장하는 단계를 포함하는 동작들을 포함할 수 있다. 제5 실시형태에서, 컴퓨팅 시스템은 적어도 하나의 프로세서뿐만 아니라, 메모리 및 프로그램 명령어들을 포함 할 수 있다. 프로그램 명령어들은 메모리에 저장될 수 있고, 적어도 하나의 프로세서에 의한 실행 시, 컴퓨팅 시스템으로 하여금 제1, 제2, 제3, 및 제4 예시적인 실시형태들 중 어느 하나 이상에 따른 동작들을 수행하게 할 수 있다. 제6 예시적인 실시형태에서, 제조 물품은, 컴퓨팅 시스템에 의한 실행 시, 컴퓨팅 시스템으로 하여금 제1, 제2, 제3, 및 제4 예시적인 실시형태들 중 어느 하나 이상에 따라 동작들을 수행하게 하는 프로그램 명령어들이 저장 된 비일시적인 컴퓨터 판독 가능한 매체를 포함할 수 있다. 제7 예시적인 실시형태에서, 시스템은 제1, 제2, 제3, 및 제4 예시적인 실시형태들 중 어느 하나 이상의 각 동 작을 수행하기 위한 다양한 수단을 포함할 수 있다. 이들뿐만 아니라 다른 실시형태, 양태, 이점, 및 대안이 첨부 도면을 적절하게 참조하여 다음의 상세한 설명을"}
{"patent_id": "10-2023-7034722", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "읽음으로써 당업자에게 명백해질 것이다. 또한, 본원에서 제공되는 해당 요약 및 다른 설명 및 도면은 단지 예 로서 실시형태들을 설명하기 위한 것이며, 이에 따라 다양한 변형들이 가능하다. 예를 들면, 구조적 요소들 및 프로세스 단계들은, 청구되는 실시형태의 범위 내에 있으면서 재배치, 결합, 분산, 제거, 또는 달리 변경될 수 있다."}
{"patent_id": "10-2023-7034722", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "예시적인 방법들, 장치들, 및 시스템들이 여기에서 설명된다. 본원에서 \"예\" 및 \"예시적인\"이라는 단어는 \"예, 실례, 또는 예시로서 제공됨\"을 의미하는 것으로 사용되고 있을 이해해야 한다. 본원에서 \"예\" 또는 \"예시적인\"으로서 설명된 임의의 실시형태 또는 특징은, 명시되어 있지 않는 한, 반드시 다른 실시형태들 또는 특징들에 비해 바람직하거나 유리한 것으로 해석되어서는 안 된다. 따라서, 본원에서 제시된 요지의 범위에서 벗어나지 않고 다른 실시형태들이 활용될 수 있고 다른 변경이 이루어질 수 있다. 따라서, 본원에서 설명되는 예시적인 실시형태들은 제한을 의미하지 않는다. 일반적으로 본원에서 설명되고 도 면에 나타난 본 개시의 양태들이 매우 다양한 다른 구성들로 배치, 대체, 결합, 분리, 및 설계될 수 있음이 쉽 게 이해될 것이다. 예를 들면, 특징부들을 \"클라이언트\"와 \"서버\" 컴포넌트들로 분리하는 방법이 다양한 방식 으로 일어날 수 있다. 또한, 문맥상 달리 제시되지 않는 한, 각 도면에 나타난 특징부들은 서로 조합하여 사용될 수 있다. 따라서, 도면은 일반적으로 하나 이상의 전체 실시형태들의 구성 요소 양태들로서 간주되어야 하고, 도시된 모든 특징부 들이 각 실시형태에 필요한 것은 아님을 이해해야 한다. 또한, 본 명세서 또는 특허청구범위에서의 요소들, 블록들, 또는 단계들의 임의의 열거는 명확성을 위한 것이다. 따라서, 이러한 열거가 이 요소들, 블록들, 또는 단계들이 특정 배치를 따르거나 특정 순서로 수행됨 을 요구하거나 암시하는 것으로 해석되어서는 안 된다. I. 소개 블록체인 기반 기술은, 다른 많은 응용 중에서, 암호화폐, 스마트 계약, NFT(non-fungible token), 아이덴티티 보호, 및 보안 투표를 제공하는 데 사용된 새로운 형태의 비집중형 컴퓨팅을 뒷받침하고 촉진한다. 적어도 일 부 소스에서는, 새로운 버전의 월드와이드 웹(\"웹 3.0\")이 하나 이상의 블록체인 위에서 구축될 수 있다는 추측 이 있다. 여하간에, 블록체인 기반 기술이 실제 형태로 존재한 지 10년이 조금 넘었음에도 불구하고, 컴퓨터 네트워크 및 사회의 다른 측면에 영향을 미쳤다는 점은 부인할 수 없는 것처럼 보인다. 여기서 \"블록체인 기반\" 기술은 블록체인 기술의 모든 변형 또는 블록체인 메커니즘을 사용하거나 이에 의존하 는 모든 기술을 지칭한다. 이것은 블록체인 기술의 현재 및 미래 변형을 포함한다. 간단히 말해서, 블록체인은, 블록체인 노드들에 의해 수행되는 합의 프로토콜들에 기초하여 시간이 지남에 따라 증가할 수 있는 분산 데이터베이스로서 저장되는 엔트리들의 리스트이다. 엔트리들의 그룹들은 블록들의 형태 를 취하는 데이터 구조들 내에서 블록체인에 추가되고, 순차적 블록들이 암호화 방식으로 서로 연결된다. 블록 체인 노드들은, 블록체인 소프트웨어를 사용하여 P2P(Peer-to-Peer) 방식으로 서로 통신할 수 있는 컴퓨팅 장치 들 또는 컴퓨팅 시스템들이므로, 서로 다른 위치에 있을 수 있고 서로 다른 엔티티들에 의해 운영될 수 있다. 블록체인 노드들은 기존 컴퓨터 네트워크(예를 들면, 인터넷) 상에 오버레이를 형성할 수 있고, 통칭하여 블록 체인 네트워크라고 지칭될 수 있다. 블록체인의 독립성 및 비집중형 특성을 유지하도록, 각 블록체인 노드는 전체 블록체인의 자신 소유의 사본을 저장할 수 있다. 각 블록은 블록체인에서의 이전 블록의 암호화 해시, 타임스탬프, 및 데이터를 포함한다. 암호화 해시는 SHA- 256과 같이 수학적으로 및/또는 계산적으로 되돌릴 수 없는 임의의 단방향 (해시) 함수에 의해 생성될 수 있다. 암호화 해시 체인을 통해 블록을 순차적으로 연결하면 어떤 당사자도 최근에 배치된 블록을 수정하기가 매우 어 렵고 이전 블록들을 수정하는 것은 사실상 불가능하다. 각 블록체인 사용자는 블록체인에 사용할 고유한 주소를 갖는다. 또한 각 사용자는 암호화 방식으로 연관된 공 개 키/개인 키 쌍을 가져서, 공개 키로 인코딩된 데이터를 대응하는 개인 키에 의해서만 디코딩할 수 있으며, 그 반대의 경우도 마찬가지이다. 따라서, 사용자의 공개 키로 인코딩된 데이터는 사용자의 개인 키로만 해독될 수 있도록 효과적으로 암호화되고, 사용자의 개인 키로 인코딩된 데이터는 사용자의 공개 키로 검증 가능한 디 지털 서명이 된다. 엔트리는, 일반적으로 \"송신하는\" 사용자의 주소, \"송신되는\" 정보, 및 하나 이상의 \"수신하는\" 사용자의 주소 를 포함하는 둘 이상의 사용자들 간의 일부 형태의 트랜잭션이고, 이 모두는 송신하는 사용자의 디지털 서명으 로 서명된다. 따라서, 엔트리는 송신하는 사용자(송신하는 사용자가 인증되어 있음)로부터인지 무결성(서명 후 엔트리가 변경되지 않았음) 및 부인 방지(송신자가 엔트리에 서명했음을 나중에 부인할 수 없음)를 갖는지 쉽게 검증될 수 있다. 송신되는 정보는 일정 금액의 암호화폐, 스마트 계약, 또는 일부 다른 토큰일 수 있다. 제안되는 새로운 엔트리들이 하나 이상의 블록체인 노드들에 의해 수신되고 그들의 디지털 서명들이 인증된다. 일부 경우에, 엔트리의 유효성도 검증될 수 있다(예를 들면, 암호화폐 블록체인에의 엔트리로 인해 송신자가 보 유한 암호화폐의 금액이 0보다 작아질 수는 없다). 이러한 엔트리들은 블록들로 형성된 다음, 이 블록들은 블 록체인 네트워크를 통해 다른 블록체인 노드들로 배포된다. 각 블록은 하나 이상의 엔트리들을 포함할 수 있다. 각 블록체인 노드는 동의된 합의 프로토콜을 통해 수신된 블록들을 독립적으로 승인한다. 이러한 프로토콜의 예는, 블록체인 노드들이 시행착오를 통해 수학적 퍼즐을 풀려고 시도하는 \"작업 증명\"이다. 예를 들면, 합의 프로토콜은, 논스가 추가되는 블록에 대해 수행되는 암호화 해시 함수가 지정된 수의 선행 0들을 갖는 해시값을 생성하도록, 블록체인 노드들이 논스(예를 들면, 미지값)를 찾으려고 시도하는 것을 요할 수 있다. 이 프로토 콜을 수행하는 프로세스는 종종 \"채굴\"이라고 지칭되며 상당한 양의 계산 능력이 필요하다. 적절한 논스를 발견한 제1 블록체인 노드는 이 논스 및 결과 해시값을 블록체인 네트워크의 나머지 부분에 브로 드캐스트한다. 다른 블록체인 노드들이 논스 및 해시값이 올바른지 유효성확인하는 것은 어렵지 않다. 이러한 블록은 \"채굴\"되었다고 하고, 프로토콜에 참여하도록 동기를 부여하기 위해 발견자는 그에 따라 (예를 들면, 소 량의 암호화폐로) 보상을 받을 수 있다. 블록체인 노드들의 단순 다수가 블록이 채굴되었음에 동의하면, 그 블 록은 모든 블록체인 노드들에 의해 블록체인에 추가된다. 모든 블록체인 노드들이 이러한 방식으로 채굴자로서 역할을 할 필요는 없음에 유의한다. 블록들의 암호화 연결 및 합의에 사용되는 작업 증명으로 인해, 공격자가 한 블록의 수정들이 수락되게 하려면 모든 후속 블록들을 수정해야 하기 때문에, 블록체인의 불법 수정들을 실질적으로 불가능하게 된다. 따라서, 블록체인에서의 블록들은 효과적으로 역방향으로 불변적이다. 그렇지만, 지분 증명을 기반으로 하는 것과 같은 다른 합의 프로토콜들을 대신 사용할 수 있다. 때때로, 블록체인은 포크를 거쳐 그 성격을 효과적으로 바꾸거나 2개의 다른 블록체인들로 될 수 있다. 특히, 블록체인의 무결성은, 블록들을 추가하고 이력을 유지하는 데 사용되는 규칙에 동의하는 블록체인 노드들에 달 려 있다. 이 노드들이 규칙에 동의하지 않거나 동의할 수 없거나 새로운 규칙 세트를 채택하는 데 집합적으로 동의할 수 없을 경우, 포크가 발생했다고 한다. 일부 포크들은 우발적이고 수명이 짧다. 예를 들면, 두 채굴자들이 거의 동시에 블록 채굴을 성공적으로 완료 할 수 있다. 이 채굴자들이 블록에 대한 그들의 솔루션들을 브로드캐스팅하기 시작한 후, 서로 다른 블록체인노드들은 이 블록들 중의 하나 또는 다른 것을 블록체인의 그들의 로컬 사본들에 추가할 수 있다. 결국, 후속 블록들을 추가하면 블록체인의 이 버전들 중 하나가 다른 버전보다 길어지고, 블록체인 노드들은 더 짧은 버전 을 포기(고아로 되게)하게 된다. 한편, 블록체인 노드들 중 적어도 일부에 대해 규칙이 변경될 경우, 의도적인 포크가 발생할 수 있다. 소프트 포크는 다수의 블록체인 노드들에 대해 이전 버전과 호환 가능한 방식으로 규칙이 변경될 경우 발생한다(예를 들면, 새로운 유형들의 엔트리들 추가하도록). 따라서, 단일 블록체인은, 규칙이 업데이트되지 않은 블록체인 노드들이 여전히 새로운 블록들을 유효한 것으로 인식하게 남아 있다. 결국, 모든 블록체인 노드들이 새로운 규칙으로 업데이트될 수 있다. 하드 포크는, 다수의 블록체인 노드들이 새로운 규칙에 의해 생성된 블록들을 이전 규칙 하에서 유효하지 않은 것으로 간주하는 새로운 규칙을 채택할 때, 발생한다. 모든 블록체인 노드들이 새로운 규칙으로 업그레이드되 지 않는다면, 단일 블록체인이 2개의 독립적인 블록체인들(하나는 새로운 규칙에 따라 동작하고 다른 하나는 이 전 규칙에 따라 동작함)로 갈라지는 영구적인 분할이 발생할 수 있다. 암호화폐 지원 외에도, 블록체인 기술의 주요 용도 중 하나는 스마트 계약들의 형성 및 실행이다. 스마트 계약 들은 엔트리들에 배치되는 실행 가능한 로직(예를 들면, 프로그램들 또는 스니펫들)이다. 스마트 계약의 로직 은 특정 미리 결정된 조건이 충족될 경우 실행된다. 간단한 스마트 계약은 \"if-X-then-Y\" 로직으로 구성될 수 있으며, 여기서 X는 하나 이상의 조건의 세트이고 Y는 X가 참이 될 경우 수행되는 하나 이상의 동작들의 세트이 다. 예를 들면, 스마트 계약 로직은, 배송물이 수취인의 위치(X)에 도착하면 수취인이 송신자에게 금액(Y)을 지불하 는 것을 지정할 수 있다. 스마트 계약은, X가 참인지의 여부 및 X가 참인 경우를 결정하는 데 사용될 하나 이 상의 외부 데이터 소스들(예를 들면, 다른 컴퓨팅 시스템들의 센서들 또는 애플리케이션 프로그래밍 인터페이스 들로부터의 출력)을 지정할 수도 있다. 이 소스들은 \"오라클\"이라고 지칭되며 스마트 계약의 모든 당사자들에 의해 신뢰된다. 예를 들면, 위에 언급된 배송물에 대한 오라클은 GPS(Global Positioning System) 데이터를 제 공하는 배송물에 부착된 무선 위치 센서이거나, 배송물의 위치를 추적하는 컴퓨팅 장치의 REST(Representational State Transfer) 인터페이스일 수 있다. 스마트 계약들을 포함하는 블록체인에서의 엔트리를 수정할 수 없으므로, 스마트 계약의 실행으로 Y의 동작들을 수행하도록 블록체인에 추가 엔트리들을 배치할 수 있다. 또는, 오프블록 소프트웨어 도구를 사용하여 스마트 계약의 상태를 체크하고 그런 다음 Y에 대해 필요에 따라 엔트리들을 추가할 수 있다. 일부 경우에, 이 추가 엔트리들은 조건부로 실행 가능한 로직의 다양한 세트들을 갖는 스마트 계약들일 수도 있다. 따라서, 스마트 계약들을 체인연결하여 복잡한 일련의 동작들을 수행할 수 있다. 이 모든 것을 감안할 경우, 현재의 블록체인들은 일반적으로 바람직한 속성들의 세트를 갖는다. 이들은 비집중 화되므로 그 운영을 위해 단일 정부 또는 사회 기관에 의존하지 않다. 블록체인은 일반적으로 누구나 저장하고, 보고, 분석할 수 있는 공개 문서이다. 누구나 채굴자가 될 수 있지만, 블록체인을 손상시키려면 모 든 채굴 엔티티들에 대한 다수의 통제가 필요하다. 임의의 사용자는 스스로 고유한 주소를 생성함으로써 블록 체인 \"계정\"을 생성할 수 있고, 이에 따라 사전 승인 필요없이 블록체인을 통해 다른 사용자와 상호 작용할 수 있다. 유효하지 않은 트랜잭션들은 블록체인 노드들에 의해 자동으로 폐기된다. 언급한 바와 같이, 블록들은 일단 블록체인에 배치되면 효과적으로 역방향으로 불변적이므로(기존 블록들은 변경될 수 없음), 후속 블록들이 추가됨에 따라 경시적으로 변경하기가 더 어려워진다. 그렇지만, 현재의 블록체인 기술에는 여러 가지 한계가 있다. 첫째, 절도, 사기, 돈세탁, 또는 기만적 행위에 대한 내재적 구제 수단이 없다. 결과적으로, 블록체인들은 이들 및 다른 유형의 불법 활동들의 온상이 되었으 며, 중앙 권한이 없기 때문에 범죄자들이 블록체인에 적극적으로 매력을 느낀다는 증거가 있다. 또한, 블록체 인에 배치된 저작권 또는 기밀 정보를 제거하는 것은 사실상 불가능하다. 더욱이, 분실, 오배치, 또는 도난당 한 개인 키를 복구할 방법이 없으며, 그러한 개인 키의 소유자는 자신의 블록체인 계정에 접근할 수 없을 것이다. 이 요인들은, 궁극적으로 일반 사용자에게, 블록체인 기반 기술이 몇 가지 틈새 영역을 넘어서는 유용성을 갖지 못할 수 있다는 충분한 위험을 초래한다. 예를 들면, 실수로 암호화폐를 잘못된 주소로 보내는 블록체인 사용자(또는 사기꾼의 유인으로 그러한 트랜잭션 을 제출하거나 해커에 의해 개인 키를 도난당한 사람)와 전통적인 은행 채널들을 통해 명목화폐를 보내는 동일 사용자가 직면하는 상황을 비교해 본다. 전자의 경우, 현재의 블록체인들은, 수취인이 자금에 대한 법적 자격이 없고 자금을 획득하기 위해 법을 확실히 위반했을지라도, 암호화폐를 정당한 소유자에게 회복시킬 수 있는 메커니즘을 제공하지 않는다. 대조적으로, 후자는 다양한 보호들을 누리고 있고, 이 모두는, 중개 은행들의 체 인이나 위치가 확인 가능하고 보증을 위반하거나 배경법을 준수하도록 트랜잭션들을 변경하지 못하는 경우, 법 원 집행을 받는 기타 엔티티들을 통해 트랜잭션이 발생한다는 사실로 인해 가능해진다. 본원에서의 예시적인 실시형태들은 블록체인 기술의 불변성 및 비집중형 특성의 핵심 원칙을 변경하지 않고 블 록체인 기술의 이러한 근본적인 단점을 극복한다. 특히, 블록체인 사용자들이 사전에 합의했거나 법률이나 규 정에 의해 지정될 수 있는 제3자가 사후에 특정 블록체인 트랜잭션들을 수정하도록 허용될 수 있다. 이러한 수 정들은 기존 블록들에 대한 것이 아니라, 대신 예를 들면 제3자가 사전 확립된 합의, 규정, 또는 사법 결정을 집행 및/또는 강제하는 새로운 블록들을 블록체인에 추가할 수 있게 한다. 따라서, 이전 블록들 자체가 불변적 이더라도, 이전 블록에 표현된 트랜잭션들 또는 합의들의 효과들 및/또는 결과들은 새 블록들을 추가하여 수정 (예를 들면, 정정, 조정, 또는 역전)될 수 있다. 동시에, 예시적인 실시형태들에 따르면, 제3자가 블록체인에 서 액션을 강제할 수 있는 절차는 그렇게 할 수 있는 제3자의 권한이 오용되거나 손상되지 않을 수 있음을 보장 한다. 절차는 또한 블록체인의 분산형, 비집중형 특성에 따라 동작하므로, 블록체인 기반 기술의 바람직한 측 면을 손상시키거나 상실시키지 않는다. 제1 가능한 실시형태는, 블록체인 자체(엔트리들에 저장된 데이터 및/또는 블록체인 노드들에 의해 수행되는 규 칙)에 대한 변경들을 수반하기 때문에, 본원에서는 \"시스템 레벨\" 구현이라 지칭된다. 이것은 새로운 블록체인 의 배치나 기존 블록체인의 소프트 또는 하드 포크를 포함할 수 있다. 이 블록체인에 참여하는 모든 사용자들 은, 자신의 엔트리들이 하나 이상의 제3자(예를 들면, 중재자, 법원, 기타 정부 단체, 또는 일반적으로 신뢰할 수 있는 다른 사람이나 엔티티)에 있는 일련의 통제 및 이 통제의 집행에 의해 관리받는다는 점에 명시적으로 (또는 블록체인의 사용을 통해 암묵적으로) 동의할 수 있다. 예를 들면, 제3자는 사법 법원일 수 있다. 예를 들면, 자신이 관련된 엔트리와 관련하여 하나 이상의 사용자들 간에 분쟁이 있는 경우, 이 사용자들 중 누 구라도 이 제3자에게 판결을 요청할 수 있다. 제3자는 일련의 통제 및/또는 적용 가능한 법적 원칙을 고려하여 요청을 고려할 수 있다. 제3자가 엔트리가 수정될 필요가 있다고 결정하면, 이러한 수정의 표현을 기록한다. 이 표현은 블록체인에 직접 제출되는 새 엔트리, 또는 특정 위치(예를 들면, 웹 사이트 또는 REST 인터페이스) 에 공개된 코드, 토큰, 또는 기타 문서일 수 있다. 표현은, 분쟁이 발생한 엔트리, 관련 사용자들, 특정 위치 (예를 들면, URL(Uniform Resource Locator) 형태), 및 제3자가 한 명 이상의 사용자에게 가해진 임의의 피해 를 수정하거나 완화하는 데 적합하다고 결정한 트랜잭션을 식별할 수 있다. 이 표현은 적법성을 확립하기 위해 제3자에 의해 디지털 서명될 수 있지만, 모든 구현 및/또는 사용 시나리오에서 디지털 서명이 반드시 요구될 필 요는 없다. 표현이 블록체인에 직접 제공되지 않는 경우, 하나 이상의 서버 장치를 제어하는 중개 오프체인 엔티티가 제3자 로부터 표현들을 얻어 제3자를 대신하여 블록체인에 제출할 수 있다. 예를 들면, 중개 엔티티는 제3자로부터의 새로운 표현들에 대한 알림들을 구독하거나 및/또는 제3자를 주기적으로 폴링할 수 있다(예를 들면, 해당 웹 사 이트 또는 REST 인터페이스를 스크랩). 블록체인 노드들에 제출되면, 이 노드들은 위에서 설명한 바와 같이 블록을 승인하고 합의 프로토콜을 수행할 수 있다. 추가적인 승인 단계들은, 제3자의 디지털 서명을 검증하고, 표현이 특정 위치에 실제로 존재하는지 검증하고, 식별된 제3자가 실제로 이 블록체인에서의 엔트리들을 수정할 권한이 있는지 검증하는 것을 포함할 수 있다. 블록체인 노드들은 일반적인 방식으로 엔트리의 블록을 채굴하고, 다수의 노드들이 블록이 유효하고 채굴에 성공했다고 합의하면, 블록이 블록체인에 추가된다. 예를 들면, 블록체인에의 엔트리는 사용자 A가 C 단위의 암호화폐를 사용자 B에게 이전하는 것을 포함한다고 상 정해 본다. 사용자 A는 나중에 이 트랜잭션을 수행하는데 그들의 블록체인 계정이 해킹되었음을 알게 된다. 사용자 A는 제3자(예를 들면, 법원)에 연락하여, 해킹의 증거(예를 들면, 서버 로그들, 목격자 증언, 전문가 증 언 등)를 제공할 수 있다. 그러면, 제3자는 사용자 A에게 유리하게 판결하고 해당 웹 사이트의 특정 URL에 해 당 판결의 표현을 공개할 수 있다. 표현은 사용자 B가 블록체인에서 사용자 A에게 C 단위의 암호화폐(또는 사용자 B가 가해자이고 징벌적 손해배상 이 포함된 경우 C보다 일부 높은 금액)를 이전하는 것이 강제된다는 것을 나타낼 수 있다. 표현은 URL, 유효 날짜, 및 제3자의 아이덴티티를 포함할 수 있고, 예를 들면 필요할 경우 제3자에 의해 디지털 서명될 수 있다. 유효 날짜는 표현을 포함하는 블록이 채굴되는 시점이거나, 미래의 특정 시점(예를 들면, 사용자 B에게 판결에 대해 항소하거나 이의를 제기할 수 있는 기회 제공하기 위함)일 수 있다. 또는, 유효 날짜가 블록체인 프로토콜에 지정되어 자동으로 뒤따를 수 있다. 일부 경우에는, 표현은 블록체인에서 사용자 B의 자산들을 일시적으 로 동결하거나 압수하여, 사용자 B가 사용자 A에게 보상하도록 강제되기 전에 해당 자산들을 청산할 수 없게 할 수 있다. 일단 공개되면, 중개 엔티티는 표현을 획득하고 이를 엔트리로 형성하여 블록체인에 제출할 수 있다. 채굴 프 로세스 중에, 블록체인 노드들은 제3자가 이 액션을 강제할 권한이 있는지 독립적으로 결정할 수 있고(예를 들 면, 제3자의 이러한 능력은 블록체인 동작에 내장될 수 있음), 또한 URL에 저장된 정보가 표현과 일치하는지를 검증할 수 있다. 언급한 바와 같이, 다수의 블록체인 노드들이 블록이 유효하고 채굴이 성공했음에 합의하면, 그 블록은 블록체인에 추가될 수 있다. 유리하게도, 이 메커니즘은 블록체인 노드들, 블록체인 사용자들, 또는 제3자가 중개 엔티티를 신뢰할 것을 요 구하지 않다. 또한, 블록체인은, 해결할 수 있는 분쟁 유형, 사용되는 교정 방안, 및 제3자가 권한을 갖는 사 용자와 관련하여 제3자에게 특정 권한만을 부여할 수 있다. 또한, 합의 프로토콜을 사용하면 제3자 권한을 불 법적인 방식으로 전복하거나 사용하려는 시도에는 다수의 블록체인 노드들에 대한 통제가 필요함을 보장한다. 위에서 논의한 바와 같이, 이 채굴 프로세스는 대부분의 행위자에게 계산상 실행 불가능하게 만든다. 위의 예는 트랜잭션의 경우를 나타내지만, 시스템 레벨 구현은 또한 스마트 계약들의 경우에도 동작들을 제공한 다. 보다 구체적으로, 스마트 계약에 규정된 의무 액션의 이행에 관한 분쟁과 같은 스마트 계약을 포함하는 시 나리오에서, 시스템 레벨 구현은 사법 법원과 같은 신뢰 제3자가 의무 액션을 호출하기 위해 승인된 에일리어스 로서 활동하는 절차를 제공한다. 트랜잭션 케이스와 같이, 절차는 이 새로운 능력이 실행되는 임의의 인스턴스 가 해킹, 손상, 또는 임의의 다른 형태의 오용으로부터 보안되고 안전함을 보장한다. 제2 가능한 실시형태는, 미리 결정된 비상 액션들을 엔트리별로 개별 블록체인 엔트리들에 코딩하고, 합의 또는 이러한 각 해당 엔트리에 기록된 트랜잭션에 참여하는 당사자들만의 사전 승인을 받기 때문에 \"엔트리 레벨\" 구 현이라고 지칭된다. 엔트리 레벨 구현은, 개별 블록체인 엔트리들에 코딩된 액션들을 내포하는 스마트 계약과 유사한 특징들을 포함할 수 있으므로, \"스마트 계약\"이라고도 지칭될 수 있지만, 임의의 주어진 엔트리의 코딩 된 액션들은, 주어진 엔트리의 합의의 당사자들에 의해 신뢰되는 제3자로 코딩된 액션들을 집행하는 권한을 부 여함으로써, 합의에 따라 수행될 것이라는 믿음을 강화한다. 제1 실시형태와는 달리, 엔트리 레벨 구현은 스마 트 계약을 지원하는 기존 블록체인들을 사용하여 전개될 수 있다. 그렇지만, 이 실시형태는 새로운 블록체인이 나 기존 블록체인의 포크를 통해 수행될 수 있다. 여기서, 블록체인 전체가 반드시 임의의 제3자의 기관에 종속될 필요는 없다. 대신, 사용자의 쌍들 또는 그룹 들은 다자간으로 다음 두 가지 새로운 메커니즘들을 제공하는 스마트 계약들에 의해 구속된다고 결정할 수 있다. (i) 특정 조건이 참이 될 경우 취해져야 하는 하나 이상의 교정(또는 비상) 액션들의 리스트, (ii) 사용 자들이 합의한 제3자가 스마트 계약에 대한 권한을 가질 것이다. 따라서, 제3자 통제는 블록체인의 엔트리별로 부여될 수 있고, 모든 블록체인 엔트리들이 이러한 통제의 대상이 되는 것은 아니다. 교정 액션들은 블록체인 에서 표현될 수 있는 임의의 유형의 상태 변경일 수 있다. 스마트 계약은 전술한 \"if-X-then-Y\" 로직을 사용하여 하나 이상의 조건 및 연관된 교정 액션들을 지정할 수 있 다. 각 조건은, 고유한 이진수 문자열, QR 코드이거나, 또는 일부 다른 형태를 취할 수 있는 코드와 연관될 수 있다. 예를 들면, 사용자 A 및 사용자 B는 사용자 A가 사용자 B에게 10개의 위젯들을 제공하고 사용자 B는 그 대가로 사용자 A에게 500달러(디지털 자산에 반영)를 제공할 것이라는 스마트 계약에 참여할 수 있다. 이 사용 자들은 스마트 계약이 각각 교정 액션을 갖는 다음 두 가지 조건에 의해 추가 관리된다는 데 합의할 수 있다. (i) 위젯들이 특정 시간 및 날짜까지 사용자 B에게 모두 전달되지 않으면, 사용자 A는 사용자 B에게 100달러를 환불하고, (ii) 위젯들이 업계에서 이해되는 제작 품질이 아닐 경우, 사용자 A는 사용자 B에게 500달러를 모두 환불할 것이다. 마찬가지로, A에 대한 지불 금액은 제3자에 의해 할당 가능한 변수로서 남겨질 수 있다. 일부 경우들에는, 사용자들은 분쟁을 일으키는 임의의 다른 지정되지 않은 조건이 제3자에 의해 교정되도록 스마트 계약에 조항을 포함시킬 수 있다. 이 스마트 계약은 블록체인에 제출되고 나서, 위에서 설명한 대로 유효성확인 및 채굴된다. 사용자 B가, 제1 교정 액션이 트리거되었으며 사용자들이 스스로 분쟁을 해결할 수 없다고 주장한다고 상정해 본다. 그러면, 사 용자 B는 사전 확립된 제3자를 참여시키고, 제3자에게 늦은 전달의 증거(예를 들면, 위젯들이 일주일 늦게 전달 되었음을 나타내는 선하 증권)를 제공할 수 있다. 제3자는 사용자 B에게 유리하게 판결하고 자신의 웹사이트의 특정 URL에 그 판결의 표현을 공개할 수 있다.표현은 스마트 계약, URL, 유효 날짜, 제3자의 아이덴티티, 및 조건을 식별하는 코드를 포함할 수 있고, 제3자 에 의해 디지털 서명될 수 있다. 일단 공개되면, 중개 엔티티는 제1 실시형태에 대해 설명한 바와 같이 채굴을 위해 블록체인에 엔트리를 제출할 수 있다. 여기서, 블록체인 노드들은 코드가 스마트 계약으로부터의 코드와 일치하는지 추가로 유효성확인할 수 있다. 블록체인에 배치되면, 이 엔트리는 스마트 계약을 \"수정\"하는 역할 을 하고, 특히 제3자에 의해 서명된 엔트리에 코드가 있으면 스마트 계약의 교정 조건이 호출되어 사용자 A로부 터 사용자에게 100달러가 이전된다. 또한 이 메커니즘은 블록체인 노드들, 블록체인 사용자들, 또는 제3자들이 중개 엔티티를 신뢰하는 것을 요구하 지 않는다. 또한, 스마트 계약에 관련된 각 사용자들의 세트는 독립적으로 그들 자신의 제3자를 선택할 수 있 어, 다양한 스마트 계약들에 대한 권한을 더욱 분산시킬 수 있다. 더욱이, 제3자의 판결은 이미 스마트 계약에 존재하는 로직을 호출하기 때문에 모호하지 않고 해석의 여지가 없다. 스마트 계약과 유사한 동작들의 관점에서 엔트리 레벨 구현에 대한 설명을 시스템 레벨 구현의 스마트 계약 시 나리오와 혼동해서는 안 된다. 특히, 각 시스템 레벨 구현 및 엔트리 레벨 구현은 트랜잭션 시나리오들과 스마 트 계약 시나리오들 모두에 대한 동작들 및 기능을 제공한다. 제3 가능한 실시형태는 제1 및 제2 실시형태들을 혼합한 것이다. 제1 실시형태와 마찬가지로, 블록체인은 모든 엔트리들이 일련의 통제에 의해 관리되고 이 통제의 집행이 하나 이상의 제3자에 있도록 초기에 구성 또는 포크 된다. 그러나, 이 스마트 계약들이 제2 실시형태의 사전 확립된 조건 및 연관된 교정 액션들이 없더라도, 이 통제는 블록체인에서의 스마트 계약들에도 적용된다. 그렇지만, 제2 실시형태와 마찬가지로, 제3자들은 트랜잭 션들을 트리거하거나 스마트 계약들 자체를 포함하는 새로운 엔트리들을 추가함으로써 스마트 계약들을 \"수정\" 할 수 있다. 그 외에는, 제2 실시형태와 유사한 방식으로 동작이 일어난다. 이 실시형태는 각 스마트 계약에 관련된 사용자들이 계약 조항을 집행하기 위해 상호 신뢰하는 제3자를 식별해 야 하는 것을 피하게 하고, 제3자들은 블록체인에 의해 결정된다. 이로 인해 스마트 계약에의 엔트리를 더 간 단하게 할 수 있는 한편, 사용자들은 블록체인의 확립된 제3자들에게 의존할 것을 요구한다. 마찬가지로, 이 실시형태는 스마트 계약의 비당사자들(예를 들면, 정부 기관 또는 피해를 입은 비당사자)이 지정된 제3자가 승 인하는 스마트 계약 실행을 \"수정\"하게 할 수 있다. 이 실시형태들 중 어느 것에서, 제3자의 판결을 집행하는 엔트리는 \"수정\"하는 이전 엔트리와는 다른 블록체인 에 배치될 수 있다. 따라서, 두 가지 유형의 엔트리에 동일한 블록체인을 사용할 필요가 없으며, 하나의 블록 체인에서의 트랜잭션을 사용하여 다른 블록체인들에서의 트랜잭션들과 관련하여 발생하는 분쟁을 교정할 수 있 다. 특히, 세 가지 실시형태 모두는 현재 블록체인 기반 기술에 의해 지원되지 않는 동작을 용이하게 한다 ― 제3자 는, 이 트랜잭션이 송신 사용자 또는 수신 사용자 또는 스마트 계약의 소유자(예를 들면, 스마트 계약 등의 경 우)에 의해 디지털 서명되는 것을 요구하지 않고, 송신 사용자로부터 수신 사용자에게의 트랜잭션을 강제하거나, 스마트 계약 동작을 강제하는 엔트리를 추가한다. 대신, 제3자로부터의 엔트리는 제3자에 의해 합 법적으로 소싱되거나 및/또는 제3자로부터 유래된 것으로 유효성확인될 수 있는 한, 블록체인에 추가된다. 유 리하게도, 이러한 기능은 블록체인 기반 기술을 향상시키고 발전시켜 바람직한 비집중형 및 분산 특징들 모두를 유지하면서 일반적인 용도로 충분히 신뢰성 있게 될 수 있다. II. 예시적인 컴퓨팅 장치들 및 클라우드 기반 컴퓨팅 환경 도 1은 본원에서의 실시형태들에 따라 동작하도록 배치된 컴퓨팅 장치에 포함될 수 있는 컴포넌트들 중의 일부 를 나타내는 컴퓨팅 장치를 예시하는 단순화된 블록도이다. 컴퓨팅 장치는 클라이언트 장치(예를 들 면, 사용자에 의해 능동적으로 동작되는 장치), 서버 장치(예를 들면, 클라이언트 장치들에 계산 서비스들을 제 공하는 장치), 또는 일부 다른 유형의 계산 플랫폼일 수 있다. 일부 서버 장치들은 특정 동작들을 수행하기 위 해 때때로 클라이언트 장치들로서 동작할 수 있고, 일부 클라이언트 장치들은 서버 특징들을 통합할 수 있다. 이 예에서, 컴퓨팅 장치는 프로세서, 메모리, 네트워크 인터페이스, 및 입출력 유닛 을 포함하고, 그 모두는 시스템 버스 또는 유사한 메커니즘에 의해 연결될 수 있다. 일부 실시형태들에서, 컴퓨팅 장치는 다른 컴포넌트들 및/또는 주변 장치들(예를 들면, 분리형 스토리지, 프린 터들 등)을 포함할 수 있다. 프로세서는, 중앙 처리 장치(CPU), 보조 프로세서(예를 들면, 수학, 그래픽, 또는 암호화 보조 프로세서), 디지털 신호 프로세서(DSP), 네트워크 프로세서, 및/또는 프로세서 동작들을 수행하는 집적 회로 또는 컨트롤러 의 형태와 같은 하나 이상의 임의의 유형의 컴퓨터 처리 요소일 수 있다. 일부 경우들에, 프로세서는 하 나 이상의 단일 코어 프로세서일 수 있다. 다른 경우들에, 프로세서는 다수의 독립적인 처리 유닛들을 갖 는 하나 이상의 멀티 코어 프로세서일 수 있다. 프로세서는 또한 실행 중인 명령어들 및 관련 데이터를 일시적으로 저장하기 위한 레지스터 메모리뿐만 아니라 최근에 사용된 명령어들 및 데이터를 일시적으로 저장하 기 위한 캐시 메모리도 포함할 수 있다. 메모리는 RAM(Random Access Memory), ROM(Read-Only Memory), 및 비휘발성 메모리(예를 들면, 플래시 메 모리, 하드 디스크 드라이브들, 솔리드 스테이트 드라이브들, 컴팩트 디스크들(CD), 디지털 비디오 디스크들 (DVD), 및/또는 테이프 스토리지)를 포함하되 이에 제한되지 않는 임의의 형태의 컴퓨터 사용 가능한 메모리일 수 있다. 따라서, 메모리는 메인 메모리 유닛들뿐만 아니라 장기 스토리지 모두를 나타낸다. 다른 유형 의 메모리로는 생물학적 메모리를 포함할 수 있다. 메모리는 프로그램 명령어들 및/또는 프로그램 명령어들이 동작할 수 있는 데이터를 저장할 수 있다. 예 를 들면, 메모리는 이 프로그램 명령어들을 비일시적인 컴퓨터 판독 가능한 매체에 저장할 수 있으므로, 명령어들은 프로세서에 의해 본 명세서 또는 첨부 도면에 개시된 방법들, 프로세스들, 또는 동작들의 어느 것을 수행하도록 실행 가능하다. 도 1에 나타난 바와 같이, 메모리는 펌웨어(104A), 커널(104B), 및/또는 애플리케이션들(104C)을 포함할 수 있다. 펌웨어(104A)는 컴퓨팅 장치의 일부 또는 전부를 부팅하거나 달리 시작하는데 사용되는 프로그 램 코드일 수 있다. 커널(104B)은 메모리 관리와, 스케줄링과, 프로세스들, 입출력, 및 통신의 관리를 위한 모 듈들을 포함하는 운영 체제일 수 있다. 커널(104B)은 또한 운영 체제가 컴퓨팅 장치의 하드웨어 모듈들 (예를 들면, 메모리 유닛들, 네트워킹 인터페이스들, 포트들, 및 버스들)과 통신 가능하게 하는 장치 드라이버 들을 포함할 수 있다. 애플리케이션들(104C)은, 웹 브라우저들 또는 이메일 클라이언트들과 같은 하나 이상의 사용자 공간 소프트웨어 프로그램들뿐만 아니라 이 프로그램들에 의해 사용되는 임의의 소프트웨어 라이브러리 들일 수도 있다. 메모리는 또한 이 프로그램과 다른 프로그램 및 애플리케이션들에 의해 사용되는 데이터 를 저장할 수 있다. 네트워크 인터페이스는 이더넷(예를 들면, 패스트 이더넷, 기가비트 이더넷 등)과 같은 하나 이상의 유선 인터페이스들의 형태를 취할 수 있다. 네트워크 인터페이스는 또한 동축 케이블이나 전력선과 같은 하나 이상의 비이더넷 매체를 통한 통신, 또는 SONET(Synchronous Optical Networking) 또는 DSL(Digital Subscriber Line) 기술들과 같은 광역 매체를 통한 통신을 지원할 수도 있다. 네트워크 인터페이스는, 추 가적으로 IEEE 802.11(Wifi), BLUETOOTH®, GPS(Global Positioning System), 또는 광역 무선 인터페이스와 같 은 하나 이상의 무선 인터페이스들의 형태를 취할 수 있다. 그러나, 다른 형태의 물리 계층 인터페이스들 및 다른 유형의 표준 또는 독점 통신 프로토콜들이 네트워크 인터페이스를 통해 사용될 수 있다. 또한, 네트 워크 인터페이스는 다수의 물리적 인터페이스들을 포함할 수 있다. 예를 들면, 컴퓨팅 장치의 일부 실시형태들은 Ethernet, BLUETOOTH®, 및 Wifi 인터페이스들을 포함할 수 있다. 입출력 유닛은 컴퓨팅 장치와의 사용자 및 주변 장치 상호 작용을 용이하게 할 수 있다. 입출력 유 닛은 키보드, 마우스, 터치스크린 등과 같은 하나 이상의 유형의 입력 장치들을 포함할 수 있다. 마찬가 지로, 입출력 유닛은 스크린, 모니터, 프린터, 및/또는 하나 이상의 발광 다이오드들(LED)과 같은 하나 이 상의 유형의 출력 장치들을 포함할 수 있다. 추가적으로 또는 대안적으로, 컴퓨팅 장치는, 예를 들면 USB(Universal Serial Bus) 또는 HDMI(High-Definition Multimedia Interface) 포트 인터페이스를 사용하여 다 른 장치와 통신할 수 있다. 일부 실시형태들에서, 컴퓨팅 장치와 같은 하나 이상의 컴퓨팅 장치들은 블록체인 및/또는 블록체인 관련 아키텍처를 지원하도록 배치될 수 있다. 이 컴퓨팅 장치들의 정확한 물리적 위치, 연결, 및 구성은 클라이언트 장치들에게 알려지지 않거나 중요하지 않을 수 있다. 따라서, 컴퓨팅 장치들은 다양한 원격 데이터 센터 위치 들에 수용될 수 있는 \"클라우드 기반\" 장치들이라고 지칭될 수 있다. 도 2는 예시적인 실시형태들에 따른 클라우드 기반 서버 클러스터를 나타낸다. 도 2에서, 컴퓨팅 장치(예 를 들면, 컴퓨팅 장치)의 동작들은 서버 장치들, 데이터 스토리지들, 및 라우터들 사이에 분산될 수 있고, 이 모두는 로컬 클러스터 네트워크에 의해 연결될 수 있다. 서버 클러스터의 서버 장치들, 데이터 스토리지들, 및 라우터들의 수는 서버 클러스터에 할당된 컴퓨팅 작업(들) 및/또는 애플리케이션들에 따라 달라질 수 있다.예를 들면, 서버 장치들은 컴퓨팅 장치의 다양한 컴퓨팅 작업들을 수행하도록 구성될 수 있다. 따라 서, 컴퓨팅 작업들은 하나 이상의 서버 장치들에 분산될 수 있다. 이 컴퓨팅 작업들을 병렬로 수행할 수 있는 만큼, 이러한 작업들의 분산이 이 작업들을 완료하고 결과를 반환하기 위한 총 시간을 줄일 수 있다. 단 순화를 위해, 서버 클러스터와 개별 서버 장치들은 모두 \"서버 장치\"라 지칭될 수 있다. 이 명명법 은, 하나 이상의 개별 서버 장치들, 데이터 저장 장치들, 및 클러스터 라우터들이 서버 장치 동작들에 동반될 수 있음을 의미하는 것으로 이해되어야 한다. 데이터 스토리지는 하드 디스크 드라이브들 및/또는 솔리드 스테이트 드라이브들의 그룹들에 대한 읽기 및 쓰기 액세스를 관리하도록 구성되는 드라이브 어레이 컨트롤러들을 포함하는 데이터 스토리지 어레이들일 수 있 다. 드라이브 어레이 컨트롤러들은, 단독으로 또는 서버 장치들과 함께, 드라이브 고장 또는 하나 이상의 서버 장치가 데이터 스토리지의 유닛들에 액세스하는 것을 막는 다른 유형의 고장에 대해 보호하도록, 데이터 스토리지에 저장된 데이터의 백업 또는 리던던트 사본들을 관리하도록 구성될 수도 있 다. 드라이브들 외에 다른 유형의 메모리를 사용할 수도 있다. 라우터들은 서버 클러스터에 대한 내부 및 외부 통신을 제공하도록 구성되는 네트워킹 장비를 포함할 수 있다. 예를 들면, 라우터들은, (i) 로컬 클러스터 네트워크를 통한 서버 장치들과 데이터 스토리지 사이의 네트워크 통신, 및/또는 (ii) 네트워크에 대한 통신 링크를 통한 서버 클러스 터와 다른 장치들 사이의 네트워크 통신을 제공하도록 구성되는 하나 이상의 패킷 교환 및/또는 라우팅 장 치들(스위치들 및/또는 게이트웨이들을 포함함)을 포함할 수 있다. 추가적으로, 라우터들의 구성은 서버 장치들과 데이터 스토리지들의 데이터 통신 요구 사항, 로 컬 클러스터 네트워크의 대기 시간 및 처리량, 통신 링크의 대기 시간, 처리량, 및 비용, 및/또는 시 스템 아키텍처의 비용, 속도, 내결함성, 탄력성, 효율성, 및/또는 다른 설계 목표들에 기여할 수 있는 다른 요 소들에 적어도 부분적으로 기초할 수 있다. 가능한 예로서, 데이터 스토리지는 구조화된 질의 언어(SQL) 데이터베이스와 같은 임의의 형태의 데이터베 이스를 포함할 수 있다. 다양한 유형의 데이터 구조들이 이러한 데이터베이스에 정보를 저장할 수 있으며, 이 는 테이블, 배치, 목록, 트리, 및 튜플을 포함하되 이에 국한되지 않는다. 또한, 데이터 스토리지의 임의 의 데이터베이스들은 모놀리식이거나 다수의 물리적 장치들에 걸쳐 분산될 수 있다. 서버 장치들은 데이터 스토리지에 데이터를 전송하고 데이터 스토리지로부터 데이터를 수신하도 록 구성될 수 있다. 이러한 전송 및 검색은 SQL 쿼리들 또는 다른 유형의 데이터베이스 쿼리들, 및 이러한 쿼 리들의 출력의 형태를 각각 취할 수 있다. 추가적인 텍스트, 이미지들, 비디오, 및/또는 오디오도 포함될 수 있다. 또한, 서버 장치들은 수신된 데이터를 웹 페이지 또는 웹 애플리케이션 표현들로 조직화할 수 있다. 이러한 표현은 HTML, XML(eXtensible Markup Language), 또는 일부 다른 표준화된 또는 독점 포맷과 같 은 마크업 언어의 형태를 취할 수 있다. 더욱이, 서버 장치들은 Perl, Python, PHP(PHP Hypertext Preprocessor), ASP(Active Server Pages), JAVASCRIPT® 등과 같은(이에 제한되지는 않음) 다양한 유형의 컴 퓨터 스크립팅 언어들을 실행할 능력을 가질 수 있다. 이 언어들로 작성된 컴퓨터 프로그램 코드는 클라이언트 장치들에 웹페이지들을 제공하는 것뿐만 아니라 웹 페이지들과의 클라이언트 장치 상호 작용을 용이하게 할 수 있다. 대안으로 또는 추가적으로, JAVA®를 사용하여 웹 페이지들의 생성을 용이하게 하거나 및/또는 웹 애플 리케이션 기능을 제공할 수 있다. III. 예시적인 시스템 레벨 블록체인 실시형태 예시적인 시스템 레벨 실시형태에 따르면, 지정된 신뢰 오프체인 기관은, 둘 이상의 당사자들 간의 블록체인 기 록 액션을 블록체인에 이전에 기록된 엔트리로 강제하는 엔트리가 블록체인에 생성되게 할 수 있다. 종래, 둘 이상의 당사자들 간의 액션 또는 약정(예를 들면, 합의 또는 계약)을 지정하는 블록체인 엔트리는, 액션을 검증 하고 새로운 엔트리를 유효성확인하기 위해 디지털 서명과 같은 일부 암호화 검증 가능한 형태의 사용자의 아이 덴티티가 필요하다. 대조적으로, 시스템 레벨 구현의 지정된 신뢰 오프체인 기관은 제3자이며 이전 엔트리의 당사자들 중의 하나가 아니다. 예시적인 시스템 레벨 실시형태들은, 블록체인 기록 액션을 강제하기 위해 임의 의 지시문의 무결성 및 유효성을 보호하는 동시에 블록체인의 분산 및 비집중 동작 원칙을 그대로 유지하고 방 해하지 않는 절차 및 프로토콜의 세트를 실행한다. 예를 들면, 블록체인 기록 액션은 송신 당사자 또는 송신자로부터 수신 당사자 또는 수신자에게 디지털 자산들 의 이전을 지정하는 트랜잭션일 수 있다. 트랜잭션이 유효한 것으로 간주되어 블록체인의 블록에 엔트리로서기록되기 위해서는, 모든 블록체인 노드가 디지털 자산에 대한 송신자의 권리, 이에 따라 디지털 자산을 이전할 송신자의 권리를 확인할 수 있도록, 송신자의 암호화 키 또는 디지털 자산의 송신자의 소유권의 다른 형태의 증 명이 트랜잭션에 수반되어야 한다. 시스템 레벨 실시형태의 예시적인 사용 경우에, 지정된 신뢰 오프체인 기관 은, 디지털 자산들을 수신자로부터 송신자에게 다시 이전하는 교정 액션이 블록체인에 입력되게 함으로써, 트랜 잭션의 결과를 역전시키도록 요청받을 수 있다. 또한 예를 들면, 둘 이상의 당사자들 간의 블록체인 기록 약정(예를 들면, 합의 또는 계약)은, 임의의 하나 이 상의 비상 액션들이 스마트 계약에서 호출(즉, 비상 액션(들)의 호출) 권한이 부여된 \"지정된 호출자\"에 의해 호출되거나 \"콜\"되면 및 그러할 때 수행될 하나 이상의 비상 액션을 내포하는 스마트 계약일 수 있다. 블록체 인에 엔트리로서 기록되는 스마트 계약은 통상적으로 각 비상 액션의 실행 코드뿐만 아니라 비상 액션(들)을 호 출하고 연관 코드가 실행되게 하도록 권한이 부여된 지정된 호출자(또는 호출자들)의 아이덴티티를 포함한다. 호출이 유효한 것으로 간주되어 비상 액션이 실행되게 하기 위해서는, 블록체인에의 제출 시 호출 요청이나 명 령이 이루어질 수 있다. 요청은 문제의 스마트 계약에 대한 링크, 요청되는 비상 액션의 식별, 및 비상 액션이 취하거나 요구할 수 있는 임의의 파라미터들, 및 호출할 요청자의 권한을 입증하는 호출자의 암호화 키(또는 일 부 다른 형태의 인증)를 포함한다. 시스템 레벨 실시형태의 예시적인 사용 경우에, 블록체인 동작은, 신뢰 오 프체인 기관을 호출하기 위한 비상 액션의 지정된 호출자의 \"승인된 에일리어스\"로서 인식하여, 신뢰 오프체인 기관에 의해 그렇게 하도록 요청받거나 명령받을 경우 스마트 계약의 비상 액션이 실행되게 하도록 구성될 수 있다. 지정된 신뢰 오프체인 기관이 액션 또는 에일리어스 호출에 대한 요청을 승인한다고 상정하면, 신뢰 오프체인 기관에 의해 인증된 액션 또는 호출의 사양은 보안 웹사이트 또는 기타 서버에 \"신뢰할 수 있는 명령\"으로서 전 자적으로 공개 또는 게시되어, 복수의 독립적인 신뢰 검증자들이 이용 가능하게 할 수 있다. 그러면 각 신뢰 검증자는 신뢰할 수 있는 명령을 별개로 및 독립적으로 검색하고, 각각의 개인 암호화 키를 이용하여 암호화 방 식으로 서명할 수 있고, 그 각각의 서명된 신뢰할 수 있는 명령을 보안 데이터베이스에 별개로 독립적으로 저장 할 수 있다. 그러면 복수의 서명된 신뢰할 수 있는 명령들을 보안 데이터베이스로부터 검색하여 교정 액션의 사양과 함께 블록체인에 제공할 수 있다. 논의의 목적으로, 예를 들면, 신뢰할 수 있는 명령은 명령에 내포된 요청을 지정하는 정보의 해시로서 생성되거나 만들어질 수 있다. 마찬가지로, 신뢰 검증자 기능은 노드 프로토 콜들에 통합되어 노드 전체 또는 복수의 노드에 할당될 수 있다. 마찬가지로, 서명된 신뢰 명령들의 보안 데이 터베이스는 블록체인에 수용되거나 다른 위치에 저장될 수 있다. 블록체인의 하나 이상의 노드들의 각각은 각각의 신뢰 검증자들의 공개 키들을 사용하여 복수의 서명된 해시들 을 인증하고 해독할 수 있고, 해독된 해시들이 모두 동일하다는 것을 확인할 수 있다. 이는 해시의 유효성을 증명한다. 그러면 하나 이상의 노드들의 각각은 교정 액션 또는 요청된 에일리어스 호출의 사양을 사용하여 자 신의 로컬 버전의 해시를 생성할 수 있다. 로컬 버전의 해시가 검색되고 유효성확인된 해시와 동일하다는 것을 검증할 경우, 이에 따라 하나 이상의 노드들의 각각은 교정 액션 또는 에일리어스 호출의 무결성 및 신뢰성을 확신하고 이를 일반적인 블록체인 절차에 따라 유효한 블록체인 액션으로 인코딩할 수 있다. 마찬가지로, 검증 기능이 노드 프로토콜에 통합될 경우, 노드는 신뢰 명령에 서명하고 저장하는 대신 체인에서의 교정 트랜잭션에 직접 서명할 수 있다. 그러면, 블록체인의 엔트리는, 교정 액션 또는 에일리어스 호출이 효과적으로 수행되고 블록체인에 기록되게 한다. 시스템 레벨 구현이라 지칭되는 시스템 레벨 실시형태의 예시적인 구현이 아래에서 더 자세히 설명된다. A. 예시적인 시스템 아키텍처 및 기술 설명 도 3은 예시적인 실시형태들에 따른 블록체인 기반 트랜잭션들의 인증된 오프체인 수정의 시스템 레벨 구현의 컴포넌트들의 예시적인 배치를 나타내는 단순화된 블록도이다. 도 3의 블록도는 시스템 레벨 구현의 동작 아키 텍처의 측면들을 묘사하는 것으로 간주될 수도 있다. 나타낸 바와 같이, 예시적인 실시형태들은 다양한 컴포넌 트들을 포함할 수 있고, 이들 중 어느 하나 이상은 하나 이상의 컴퓨팅 장치들로서 또는 그 안에서 구현될 수 있다. 이와 같이, 도 3에 나타난 컴포넌트들은 그 자체로 하드웨어, 소프트웨어, 펌웨어, 또는 그 조합이거나 이를 포함할 수 있다. 컴포넌트들 중 일부는 데이터베이스들 또는 다른 형태의 데이터 스토리지 및 관리와 같 이 구조적으로 식별될 수 있고, 다른 컴포넌트들은 동작 또는 기능의 관점에서 식별될 수 있다. 동작 및/또는 기능 컴포넌트들은 예를 들면 소프트웨어 및/또는 하드웨어 모듈들로서 구현될 수 있고, 본 논의의 목적으로 \" 모듈들\"이라고도 지칭될 수 있다. 예시적인 시스템 레벨 구현은 다양한 컴포넌트들을 연결하는 하나 이상의 연결 메커니즘도 포함할 수 있다. 예 를 들면, 연결 메커니즘은 컴포넌트들 간의 화살표로서 표시된다. 화살표의 방향은 정보 흐름의 방향을 나타낼 수 있지만, 이 해석이 제한적인 것으로 간주되어서는 안 된다. 본 개시에서, \"연결 메커니즘\"이라는 용어는 둘 이상의 컴포넌트들, 장치들, 시스템들, 또는 기타 엔티티들을 연결하고 그들 간의 통신을 용이하게 하는 메커니 즘을 의미한다. 연결 메커니즘은 케이블 또는 시스템 버스와 같은 비교적 간단한 메커니즘, 및/또는 패킷 기반 통신 네트워크(예를 들면, 인터넷)와 같은 비교적 복잡한 메커니즘을 포함할 수 있다. 일부 사례들에서, 연결 메커니즘은 연결이 적어도 부분적으로 무선인 경우와 같이 비유형의(non-tangible) 매체를 포함할 수 있다. 연 결 메커니즘은 또한, 예를 들면 API(application program interface)와 같이 소프트웨어 및/또는 하드웨어 모 듈들 또는 애플리케이션들 간의 프로그래밍된 통신을 포함할 수 있다. 본 개시에서, 연결은 직접 연결 또는 간 접 연결일 수 있고, 후자는 라우터, 스위치, 또는 다른 네트워크 장치와 같은 하나 이상의 엔티티를 통과 및/또 는 횡단하는 연결이다. 마찬가지로, 본 개시에서, 통신(예를 들면, 데이터의 전송 또는 수신)은 직접 또는 간 접 통신일 수 있다. 예를 들면, 도 3의 예시적인 시스템 레벨 구현의 다양한 컴포넌트들 및 엔티티들은 연결된 노드들(302-1, 302- 2, ..., 302-N)을 갖는 블록체인 네트워크를 포함하고, 여기서 노드(302-N)에 대한 연결들에서의 생략 부 호는 가능하게는 추가적인 연결된 노드들을 나타낸다. 예시적인 시스템 레벨 구현의 다른 예시적인 컴포넌트들 및 엔티티들은 사용자 인터페이스(UI)(304-I/F)를 갖는 오프체인 요청 애플리케이션, 오프체인 신뢰 기관 서버, 공개 집행 액션 서버, 이벤트 감시자, 신뢰 검증자 A(312-A), 신뢰 검증자 B(312-B), 신 뢰 검증자 C(312-C), 검증된 요청 데이터베이스, 요청 폴러, 오프체인 트랜잭션 서버, 및 신뢰 검증자 공개 키들을 포함한다. 신뢰 검증자 C(312-C) 뒤에 오는 생략 부호는 추가적인 신뢰 검증자들이 있을 수 있음을 나타낸다. 예시적인 실시형태에서, 오프체인 요청 애플리케이션은 다른 가능한 장치들 중 에서 PC, 랩탑, 스마트폰, 또는 서버와 같은 컴퓨팅 장치에서의 실행을 위해 구성되는 애플리케이션 프로그램일 수 있다. 예시적인 컴포넌트들 및 엔티티들의 계산적 및/또는 기능적 역할은 블록체인에서의 트랜잭션들 및 블록체인에서 의 스마트 계약들과 관련된 예시적인 동작 시나리오들을 고려함으로써 이해될 수 있다. 두 유형의 시나리오들 은 유사하고 일부 양태에서는 동일한 동작들을 포함한다. 그러나, 두 시나리오들의 구별되는 측면들을 명확히 유지하는 것을 돕기 위해, 두 시나리오들의 동작 예들이 아래에 별개로 설명된다. 1. 블록체인에서의 트랜잭션들에 대한 예시적인 시스템 레벨 시나리오 예시적인 트랜잭션 시나리오에서, 이전 트랜잭션의 당사자들은 각각 블록체인 사용자들일 수 있고, 지정된 신뢰 오프체인 기관은 개별 판사들로 대표되는 사법 법원일 수 있다. 이전 트랜잭션의 송신자는 트랜잭션의 수신자 에 의해 사기를 당했다고 주장하고, 역이전의 교정 액션을 요청할 수 있다. 이에 대한 요청은 송신자 또는 송 신자의 법적 대리인(예를 들면, 변호사)에 의해 제출될 수 있고, 판사가 요청을 승인하는 결정을 내릴 수 있게 하는 특정 정보 및 증거를 포함할 수 있다. 다른 트랜잭션 시나리오들도 가능하다. 예시적인 트랜잭션 시나리오에 대해 보다 구체적으로 설명하면, 수신자에게의 디지털 화폐와 같은 디지털 자산 의 송신자는 디지털 자산을 송신자의 계정으로부터 수신자의 계정으로 이전한 트랜잭션을 취소하려고 할 수 있 다. 예를 들면, 송신자가 수신자에 의해 속았거나 사기를 당했을 수 있고, 이에 따라 교정을 위해 사법 법원을 찾을 수 있다. 송신자 또는 송신자의 법적 대리인(예를 들면, 변호사)은 UI(304-I/F)에 요청 액션 입력을 입력할 수 있다. 요청 액션 입력은 송신자, 수신자를 식별하는 정보, 송신자로부터 수신자로의 원래 이전 에 대한 세부 정보, 요청되는 교정 액션, 및 송신자가 속았거나 사기를 당해서 원래 트랜잭션에 참여하게 된 증 거를 제공하거나 및/또는 증거로서 기능하는 특정 정보를 포함할 수 있다. 예시적인 실시형태에 따르면, UI(304-I/F)는, 예를 들면 공식 요청을 구성하는데 필요한 특정 정보에 대해 송신자(또는 기타 보다 일반적으로 는 사용자)에게 촉구하고 요청을 평가 및 승인하거나 거부하기 위한 필수 정보를 법원에 제공하는 드롭다운 메 뉴 등을 갖는 온라인 형태이거나 이를 포함할 수 있다. 위에 나열된 요청 액션 입력의 특정 내용은 본 예 시의 목적을 위한 일례일뿐이며 다른 사용 시나리오들 및/또는 구현들에서는 더 많은 정보, 더 적은 정보, 및/ 또는 다른 정보를 포함할 수 있다는 점을 이해해야 한다. UI(304-I/F)는 요청 액션 입력을 오프체인 요청 애플리케이션에 제공할 수 있고, 이는 이후 사법 법 원뿐만 아니라 (가능하게는 조건적으로) 오프체인 트랜잭션 서버에의 전달 요청을 처리할 수 있다. 따라 서, 예시적인 실시형태들에 따르면, 오프체인 요청 애플리케이션은 요청 액션 입력의 모두 또는 어떤 특정 항목들 또는 요소들을 규정된 방식으로 본원에서 편의상 \"요청 사양\"이라 지칭되는 구성으로 배치 및/또는 포맷하고 이어서 요청 사양의 단방향 해시를 생성할 수 있다. 논의의 명확화를 위해, 요청 사양의 단방향 해시는, 해시 함수의 특정 인스턴스로 식별해서 해시들, 해시 함수들 등에 대한 다른 일반적인 참조와 구별하도록, 모두 대문자로 \"HASH\"로서 라벨이 부여된다. 예를 들면 HASH는 다음과 같은 텍스트열 또는 문자열로서 인코딩 될 수 있다. 0xc8c48f65db62af1cea5e804e99f0139d5173cb0f 또한 논의의 목적으로, HASH 및 요청 사양은 HASH + 요청 사양이라고 지칭되는 데이터 엔티티로서 함께 간 주될 수 있다. 이 그룹화는 동작 설명의 편의를 위한 것이며 반드시 실제로 구현될 필요는 없다는 점을 이해해 야 한다(단, 그룹화가 또한 반드시 제외되는 것은 아님). 요청 사양의 인코딩 및/또는 표현의 다른 형태도 이 해되어야 한다. 대안의 일부 비제한적인 예들이 아래에 논의된다. 이어서, HASH + 요청 사양이 오프체인 신뢰 기관 서버에 제공될 수 있다. 신뢰 기관이 사법 법원인 예에서, 오프체인 신뢰 기관 서버는, 법원과 연관되고 블록체인에 입력되는 액션들을 강제하기 위한 요청 들을 수신하기 위해 구성되는 서버일 수 있다. 예를 들면, 오프체인 신뢰 기관 서버는 적절한 포맷의 HASH + 요청 사양 메시지들 또는 직접 입력을 수신하기 위해 구성되는 API를 구현할 수 있다. 다른 예들 에서, 오프체인 신뢰 기관 서버는 법원과 연관된 보다 일반적인 서버일 수 있고 변론 제출과 같은 다양한 법원/사건 관련 입력을 수신하기 위해 구성되거나, 판사에 대한 통신을 위한 별개의 서버일 수 있다. 다른 배 치들도 가능하다. 일부 예들에서, HASH + 요청 사양은, 예를 들면 선택적으로 송신자의 법적 대리인에 의 해 요청에 대한 뒷받침 증거와 함께 사법 법원에 \"수동으로\" 제공될 수 있다. HASH + 요청 사양이 오프체인 신뢰 기관 서버에 의해 수신된 후, 요청 액션을 승인할지의 여부에 대 해 평가가 이루어질 수 있다. 다시 말하면, 신뢰 기관이 사법 법원인 예를 고려하면, 평가는 판사 또는 법원의 다른 권한 있는 대리인에 의해 이루어질 수 있다. 이는 판사가 정보 및 증거를 평가한 후 결정을 내리는 것을 수반할 수 있다. 다른 예들에서는, HASH + 요청 사양에서 제공된 정보의 평가가 컴퓨터 기반 알고리즘에 의해 자율적으로 수행될 수 있다. 결정이 어떻게 이루어지는지, 및 그것이 송신자(액션 요청자)에게 유리한지 의 여부는 예시적인 실시형태들의 범위 내에 있지 않다. 그러나, 유리한 결정인 결과의 추가 처리 및 그와 관 련된 절차는 예시적인 실시형태들의 범위 내에 있다. (예를 들면, 사람에 의해 또는 알고리즘에 의해) 요청을 승인한다는 결정이 내려진다고 상정하면, HASH + 집행 사양이 공개 집행 액션 서버에 게시 또는 공개될 수 있다. 사법적 예에서, HASH + 집행 사양은, 결정을 명확히 표현하고 HASH의 내포된 영숫자 표현을 포함하는 사람이 판독 가능한 전자 파일일 수 있다. 예를 들면, HASH + 집행 사양은 법원에 의해 디지털 서명되거나 그렇게 할 권한을 갖는 법원 직 원에 의해 업로드된 PDF 파일일 수 있다. 공개 집행 액션 서버는 법원 업무의 다른 형태 중에서 그러한 결정이 게시되는 공개적으로 액세스 가능한 서버일 수 있다. 사법 법원의 예에서, 공개 집행 액션 서버는 예를 들면 PACER(Public Access to Court Electronic Records) 서버와 같은 서버일 수 있고, 디지털 서명은 PACER에 액세스하기 위한 서기의 비밀번호일 수 있다. 그러나, 다른 배치들도 가능하다. 또한 요청을 승인하는 결정으로, 오프체인 신뢰 기관 서버는 오프체인 요청 애플리케이션에 확인 ID를 제공 또는 송신(예를 들면, 전송)하고(이는 오프체인 요청 애플리케이션에 결정을 알리는 역할 을 할 수 있음) 공개 집행 액션 서버에서 현재 공개된 HASH + 집행 사양에 액세스하기 위한 식별 정 보를 제공한다. 예시적인 실시형태들에 따르면, 오프체인 요청 애플리케이션은 확인 ID를 수신한 후, 이어서 이벤트 감시자에게 확인 ID를 송신할 수 있다. 그렇게 하면 공개 집행 액션 서버에서의 HASH + 집행 사양의 이용 가능성을 이벤트 감시자에게 알릴 수 있다. 그러면 오프체인 요청 애플리케이션은 또한 HASH + 요청 사양을 오프체인 트랜잭션 서버에 제공하거나 송신(예를 들면, 전송)하여 또한 공 개 집행 액션 서버에서의 HASH + 집행 사양의 이용 가능성을 인식하게 할 수 있고 요청 액션이 블록 체인에 입력되게 하는 공식 요청의 생성을 시작하게 할 수 있다. 마찬가지로, 결정의 통지를 수신한 당사 자 또는 변호사는 이벤트 감시자에게 메시지를 표시하거나 트랜잭션들이 이벤트 감시자 또는 신뢰 검증자들에 의해 직접 모니터링되는 확인 ID를 사용하여 블록체인에 메시지를 입력할 수 있다. 도 3에 나타난 바와 같이, 확인 ID로 알림을 받은 이벤트 감시자는 이후 각 신뢰 검증자 A, B, C(312-A, 312-B, 312-C)뿐만 아니라 임의의 추가적인 신뢰 검증자들에게 독립적으로 통지할 수 있다. 각 신뢰 검증자는, 예를 들면 설립 은행, 중개업체, 또는 네트워크 서비스 프로바이더와 같은 각각의 조직 또는 기관과 연관된 보 안 서버 또는 다른 네트워킹된 보안 컴퓨팅 시스템일 수 있다. 도면에 반드시 도시되는 것은 아니지만, 각 신뢰 검증자에 대한 통지는 또한 확인 ID 또는 공개 집행 액션 서버에서의 HASH + 집행 사양에 대한 액 세스를 가능하게 하는 기타 정보도 포함할 수 있다. 통지를 받은 각 신뢰 검증자 A, B, C(312-A, 312-B, 및 312-C)뿐만 아니라 임의의 추가적인 신뢰 검증자들(일부 예들에서는 블록체인 네트워크의 노드들 중의 하나 이상일 수 있음)은 각각의 보안 링크들을 통해 공개 집행 액 션 서버로부터 HASH를 독립적으로 검색할 수 있다. 각 독립적인 검색은 현재 논의의 목적으로 HASH 라는 라벨로 나타나며, 다시 말하지만, 생략 부호는 추가적인 신뢰 검증자들로부터의 HASH의 추가적인 검 색들을 나타낸다. 보안 검색과 함께 신뢰 검증자들의 신뢰 특성을 통해 각 신뢰 검증자는 검색된 HASH의 신뢰성을 독립적으로 보증할 수 있다. 각 신뢰 검증자는 또한 검색된 HASH를 인증 디지털 서명으로서 역 할을 하는 개인 암호화 키로 암호화함으로써 이를 행할 수 있다. 따라서, 신뢰 검증자 A(312-A)는 A- Signed(HASH)(311-A)를 생성하고; 신뢰 검증자 B(312-B)는 B-Signed(HASH)(311-B)를 생성하고; 신뢰 검증자 C(312-C)는 C-Signed(HASH)(311-C)를 생성한다. 그러면 각 신뢰 검증자는 검증된 요청 데이터베이스에 각각 서명된 HASH를 저장 또는 배치할 수 있다. 추가적인 서명된 HASH들이 생성되어 검증된 요청 데이터베이스 에 저장될 수 있고, 이는 생략 부호로 표시된다. 마찬가지로, 노드 자체는 신뢰 검증자로서 역할할 수 있 어 주어진 트랜잭션을 검증하기 위해 무작위로 선택될 수 있다(예를 들면, 마지막 블록을 채굴한 노드 또는 마 지막 블록에 포함된 데이터를 기반으로 한 무작위 함수). 또한 예시적인 실시형태들에 따르면, HASH + 요청 사양을 수신한 오프체인 트랜잭션 서버는 요청 폴 러와 통신하여 신뢰 검증자들로부터의 서명된 HASH들의 존재 및/또는 이용 가능성에 대해 검증된 요청 데 이터베이스를 모니터링할 수 있다. 이는 검증된 요청 데이터베이스를 폴링하거나 일부 다른 배치 또 는 프로토콜에 의해 행해질 수 있다. 일부 예들에서, 검증된 요청 데이터베이스는, 그 자체가 HASH들이 블록들에 입력되거나 블록체인 또는 스마트 계약에 수용되고 요청 폴러 또는 유사한 기능 요소에 의해 모 니터링될 수 있는 블록체인일 수 있다. 마찬가지로, 요청은 블록체인에 송신되는 메시지의 형태를 취할 수 있 고, 폴러는 블록체인의 메시지 풀에서의 메시지들을 모니터링하는 노드일 수 있다. 마찬가지로, 검증자들은 자 신의 개인 키들을 사용하여 메시지에 직접 공동 서명할 수 있다. HASH들이 검증된 요청 데이터베이스에 추가되었고 이용 가능하다고 결정하면, 요청 폴러는 A- Signed(HASH)(311-A), B-Signed(HASH)(311-B), 및 C-Signed(HASH)(311-C)(또한 임의의 추가적인 서명된 HASH들)을 검색하여 오프체인 트랜잭션 서버에 제공할 수 있고 이는 도 3에 나타나 있다. 그러면 오프체인 트랜잭션 서버는 액션 엔트리 요청을 생성하고 이를 블록체인 네트워크로 송신 할 수 있다. 실제로, 액션 엔트리 요청은 노드들 중의 하나로 전달되거나 송신될 수 있고, 거기서부터 다 른 노드들 중의 일부 또는 모두로 전파될 수 있다. 이하 설명되는 바와 같이, 액션 엔트리 요청은, 요청 되는 액션과 관련된 다른 정보에 추가하여, 요청 사양 및 모든 검색된 암호화 방식으로 서명된 HASH들을 포함할 수 있다. 특히, 최종적으로 액션 엔트리 요청을 수신하는 블록체인 네트워크의 각 노드는 공개적으 로 이용 가능한 신뢰 검증자 공개 키를 사용하여 각 서명된 HASH를 해독하여 각 서명된 HASH를 독립적으로 검증할 수 있다. 그러면 각 노드는 HASH가 모두 동일하다는 것을 확인함으로써 각 HASH를 유효성확인할 수 있 다. 임의의 일치하지 않는 HASH 값은 지금까지 설명한 시퀀스의 어딘가에서 위반 또는 해킹이 있음을 나타낼 수 있고, 이로 인해 요청의 추가 처리가 중단될 수 있다. 각 수신 노드는 수신된 액션 엔트리 요청에서의 요청 사양에 단방향 해시 함수를 적용함으로써 자신의 로 컬 버전의 HASH를 추가로 생성할 수 있다. 로컬 버전의 HASH가 각 검증자로부터의 HASH와 동일하다는 것을 체 크함으로써, 각 노드는 이제 요청 액션이 인증 및 승인되었을 뿐만 아니라 지정된 오프체인 신뢰 기관에 의해 요청 및 승인된 액션과 정확히 일치함을 확인할 수 있다. 그러면 각 수신 노드는, 블록체인 사용자들에 의해 제출된 임의의 요청 액션 또는 트랜잭션과 같이 요청을 처리하고 블록체인에의 엔트리를 위해 요청 액션을 제출 할 수 있다. 이러한 방식으로, 요청 액션이 효과적으로 수행되고 블록체인에 기록될 수 있다. 특히, HASH의 값에 동의하는 적어도 다수의 신뢰 검증자들이 모든 신뢰 검증자들에 걸쳐 집단적 레벨의 신뢰를 제공하므로, 각 신뢰 검증자가 개별적으로 신뢰될 필요가 없다. 도 4a는 예시적인 실시형태들에 따른 트랜잭션 시나리오에 대한 블록체인 노드에 의한 시스템 레벨 액션 엔트리 요청의 예시적인 처리의 표현을 나타낸다. 이 예에서는, 액션 엔트리 요청에 313-A라는 라벨이 부여된다. 예 시로서 및 설명을 위해, 단 하나의 노드인 노드(302-2)가 고려된다. 액션 엔트리 요청(313-A)을 수신하는 임의 의 노드가 요청을 처리하는데 동일한 규칙을 적용할 것임을 이해해야 한다. 도면에는, 액션 엔트리 요청(313- A)의 확장되었지만 여전히 단순화된 보기가 제시된다. 예를 들면, 트랜잭션 시나리오에 대한 확장된 액션 엔트리 요청(313-A)은 요청 사양, 오프체인 요청 인디케이터, 액션 날짜, 및 서명된 HASH들 A-Signed(HASH)(311- A), B-Signed(HASH)(311-B), C-Signed(HASH)(311-C)(또한 생략 부호로 표시된 임의의 추가적인 서명된 HASH)를 포함한다. 추가적인 정보도 포함될 수 있고 요청의 포맷은 개념적으로 표현된 것이며 실제 구현의 포맷과 반드 시 일치하는 것은 아님을 이해해야 한다. 또한 예를 들면, 요청 사양은 자산 소유자의 아이덴티티 및 소유자의 자산(들)에 적용될 액션의 설명을 포함하 는 것으로 나타나고, 예를 들면 액션이 소유자로부터 수신자로의 이전일 경우 수신자가 선택적으로 제공받을 수 있다. 소유자로부터 수신자로의 \"X\"의 이전에 대한 예시적인 액션을 설명한다. 이 예시적인 요청 사양에서는, 수신자가 이전에 디지털 자산들의 일부를 소유자에게 이전했고, 이제 요청 액션을 통해 해당 이전의 X 금액을 반환하도록 요청하고 있다고 상정한다. 나타낸 바와 같이, 오프체인 요청 인디케이터는 \"참(True)\"으로 설정되 는데, 이는 이것이 시스템 레벨 구현의 예시적인 실시형태들에 따라 확립된 규칙을 따르는 오프체인 요청임을 의미한다. 액션 날짜는 요청 액션을 수행할 미래 날짜/시간을 설정하는 파라미터이다. 액션을 수행하기 위한 미래 날짜를 규정하면, 액션 엔트리 요청(313-A)을 생성하고 이를 블록체인 네트워크에 전달한 시스템 레벨 절차의 가 능한 부정 행위 또는 오용에 대한 추가 보호 조치가 도입될 수 있다. 예를 들면, 불법적인 요청이 어떻게든 유 효성확인되어 블록체인에 입력되면, 노드 프로토콜에 내포된 액션 수행의 지연으로 액션이 이루어기 전에 오류 를 발견하고 정정할 시간이 마련된다. 또한 미래 날짜를 통해 요청 액션의 임의의 당사자가 해당 액션을 실시 하기 위한 허가에 대해 이의를 제기할 수 있다. 예를 들면, 액션이 미래 역이전을 강제함으로써 수신인으로부 터 소유자로의 이전의 결과를 역전시키는 것을 목적으로 하고 소유자가 역이전에 대한 요청을 승인하기로 결정 한 법원에 제시된 조건 또는 증거에 대해 이의를 제기하려는 경우, 내포된 지연은 소유자가 요청을 거부할 사례 를 제시할 시간을 마련한다. 액션 날짜는 특정 날짜 이후의 시간량으로서 지정될 수 있다. 예를 들면, 시간량 은 72시간, 7일, 또는 30일일 수 있다. 다른 시간량을 사용할 수도 있다. 일부 사용 시나리오들에서는, 둘 이상의 액션 날짜가 지정될 수 있다. 예를 들면, 액션 요청의 정확성 및/또는 적법성을 완전히 해결하기 위해 수신자의 계정에 72시간의 즉각적인 동결이 적용되고 후속 날짜는 추가로 30일 일 수 있다. 다른 타이밍 배치도 가능하고, 예시적인 실시형태들은 임의의 특정 타이밍 배치로 제한되지 않는 다. 오히려, 임의의 다양한 타이밍 배치들이 예시적인 실시형태들의 범위 내에 있다. \"참고(Notes)\"로 라벨이 부여된 박스에 나타낸 바와 같은 요청 사양에 포함된 예시적인 액션은 제한이 없다. 다른 비제한적인 예들은 X에 대한 소유자의 액세스를 동결 또는 동결 해제, X의 일부만을 이전, X를 소유자로부 터 에스크로 계정으로 이전하는 것 등을 포함한다. 다른 액션들도 가능할 수 있다. 또한 참고에 나타낸 바와 같이, 액션 날짜(또는 액션들 날짜)가 요청 사양에 추가로 또는 대안으로 포함될 수 있다. 요청 사양에 추가적 으로 포함된 경우, 다수의 액션 날짜들 중 어느 날짜가 우선하는지 결정하기 위해 규정된 규칙이 적용될 수 있 거나, 또는 노드 프로토콜에 변경할 수 없는 최소 지연이 필요할 수 있다. 또는 다수의 액션 날짜들이 요청 사 양에 포함되는지, 아니면 외부에 위치하는지에 따라 다른 결과들을 가질 수 있다. 노드(302-2)에 의한 액션 엔트리 요청(313-A)의 예시적인 처리는 노드(302-2) 아래에 나타난 흐름도(400-A)에 표현된다. 액션 엔트리 요청(313-A)을 수신할 경우, 노드(302-2)는 요청이 강제 액션을 실시하는 강제 엔트리 를 생성하기 위한 것임을 즉시 알지 못할 수 있다. 예시적인 실시형태들에 따르면, 요청이 오프체인 요청인지 기존 요청인지의 여부를 결정하기 위해 초기 체크가 이루어진다. 이는, 예를 들면 오프체인 요청 인디케이터를 체크함으로써 수행될 수 있다. 거짓인 경우, 노드(302-2)는 블록체인 절차에 따라 요청을 처리할 수 있다. 오 프체인 요청 인디케이터가 참인 이 예의 경우, 노드(302-2)는 오프체인 요청 처리를 계속할 수 있다. 예시적인 실시형태들에 따르면, 오프체인 요청 처리를 위해, 노드(302-2)는 다음으로 액션 엔트리 요청(313- A)이 필요한 최소 수의 서명된 HASH들을 포함하는지를 결정할 수 있다. 특히, 최소 수의 서명된 HASH들을 포함 하는 것을 요구하는 것으로 신뢰 검증자들의 성공적인 해킹이나 부정 행위의 가능성을 크게 줄일 수 있다. 예 를 들면, 간단한 분석에서, 신뢰 검증자의 성공적인 해킹의 확률을 예를 들면 0.01(1%)이라고 하면, 그들 중 N 명이 해킹을 당할 확률은 (0.01)N이고, 이는 N이 증가함에 따라 희미하게 작아진다. 따라서, 최소 수 요구 사 항은 프로세스의 성공적인 해킹이나 다른 형태의 부정 행위에 대한 다수의 보호 조치들 중 하나로 간주될 수 있 다. 도시한 바와 같이, 최소 수 요구 사항이 만족되지 않으면, 요청이 \"잘못\"으로 간주되어 처리가 중단될 수 있다. 그렇지 않으면, 처리가 계속된다. 추가 예시적인 실시형태들에 따르면, 최소 수 요구 사항이 충족(만족)되면, 노드(302-2)는 신뢰 검증자들 각각 의 공개 키(노드(302-2)가 알고 있고/있거나 이용 가능한 것으로 상정됨)를 사용하여 각 서명된 HASH를 해독할 수 있다. 도 3 및 도 4a에 나타난 예에서, 해독된 HASH들은 다음과 같이 표현된다. HASHA=Decrypt[A-Signed(HASH),A-Key] HASHB=Decrypt[B-Signed(HASH),B-Key] HASHC=Decrypt[C-Signed(HASH),C-Key], 여기서 A-Key는 신뢰 검증자 A(312-A)의 공개 키이고, 신뢰 검증자 B 및 C(312-B 및 312-C)에 대해서는 마찬가 지이다. 세로 생략 부호는 액션 엔트리 요청(313-A)에 포함될 수 있는 추가적인 서명된 HASH들의 유사한 해독 을 나타낸다. 예시적인 실시형태들에 따르면, 노드(302-2)는 다음으로 모든 해독된 HASH들이 동일한지 확인하도록 테스트할 수 있다. 즉, 체크는 다음과 같다. HASHA=HASHB=HASHC 모든 HASH들이 동일함을 요구하면 임의의 신뢰 검증자들의 성공적인 해킹 또는 부정 행위의 가능성이 더 줄어든 다. 이는 모든 신뢰 검증자들보다 임의의 적은 수에 의해 제공되는 HASH를 성공적으로 해킹하면 이 테스트가 실패하여 해킹을 노출시키게 되기 때문이다. 모든 신뢰 검증자들의 동일한 해킹만이 테스트를 통과할 수 있다. 그러나, 언급한 바와 같이 최소 수 요구 사항은 사실상 불가능하지는 않더라도 이를 극히 가능하지 않게 만드는 데 도움이 된다. 표시된 바와 같이, 동일 HASH 테스트가 실패하면, 요청은 \"잘못\"으로 간주되어 처리가 중단될 수 있다. 그렇지 않으면, 처리가 계속된다. 추가 예시적인 실시형태들에 따르면, 동일 HASH 테스트를 통과할 경우(즉, 모든 해독된 HASH들이 동일한 경우), 노드(302-2)는 각각의 동일한 해독된 값을 HASH의 참 값으로 취할 수 있다. 따라서, 노드(302-2)는 HASHA(또는 동등하게는, HASHB또는 HASHC등)의 값을 예를 들면 \"HASHis\"라는 변수에 할당할 수 있다. 예시적인 실시형태들에 따르면, 노드(302-2)는 다음으로 HASH의 \"로컬\" 값을 결정하도록 액션 엔트리 요청(313- A)에서의 요청 사양에 적용되는 단방향 해시 함수의 그 자신의 계산을 수행할 수 있다. 이 계산은 위에서 설명 한 바와 같이 오프체인 요청을 시작한 오프체인 요청 애플리케이션에 의해 수행된 것과 동일한 것이다. 계산은 지정된 복잡성 레벨을 만족하는 임의의 표준 및/또는 알려진 단방향 해시 함수를 활용할 수 있다. 이러 한 단방향 해시 함수들의 비제한적인 예들은 SHA-256, SHA-512, RIPEMD-320, 및 Whirlpool을 포함한다. 흐름 도(400-A)에 나타난 바와 같이, 로컬 HASH는 \"ThisHASH\"라 지칭된다. 추가 예시적인 실시형태들에 따르면, 노드(302-2)는 ThisHASH가 HASHis와 동일하다는 것을 테스트할 수 있다. 즉, 로컬 계산된 HASH는 모든 신뢰 검증자들에 의해 독립적으로 제공되는 HASH와 동일하다. ThisHASH는 요청 사양으로부터 검증 가능하게 도출되고 각 신뢰 검증자로부터의 HASH와 합치하므로, 이제 이 테스트의 성공적인 결과가 요청 사양을 유효성확인해준다. 도시한 바와 같이, ThisHASH가 HASHis와 동일하지 않으면, 요청은 \"잘 못\"으로 간주되어 처리가 중단될 수 있다. 그렇지 않으면, 처리가 계속된다. 마지막으로, ThisHASH가 HASHis와 동일하다고 확인될 경우, 노드(302-2)는, 액션 엔트리 요청(313-A)에 지정되 어 있는 액션에 대한 유효 날짜와 함께 요청된 강제 엔트리를 블록체인에 제출할 수 있다. 상기 설명은 단 하나의 예시적인 노드(302-2)의 처리에 적용되고 있지만, 액션 엔트리 요청(313-A)이 노드들 중 의 하나를 통해 블록체인 네트워크에 제출될 경우, 모든 노드 또는 몇몇 노드에 전파될 수 있다. 액션 엔 트리 요청(313-A)을 수신하는 각 노드는 이를 노드(302-2)에 대해 설명한 바와 같이 처리할 수 있다. 다수의 노드들은 요청된 엔트리가 유효하다고 합의하면 모두 \"후보\" 엔트리들의 풀(예를 들면, 후보 트랜잭션들)에 제 출할 수 있다. 기존 처리에서, 엔트리는 채굴자에 의해 처리될 예정의 새 블록에 배치될 수 있다. 성공적인 채굴은 블록체인의 새로운 블록에서 효과적으로 수행되는 것으로 액션을 기록할 수 있다. 2. 블록체인에서의 스마트 계약들에 대한 예시적인 시스템 레벨 시나리오 예시적인 스마트 계약 시나리오에서, 이전 스마트 계약의 당사자들은 각각 다시 블록체인 사용자들일 수 있고, 지정된 신뢰 오프체인 기관은 다시 개별 판사로 대표되는 사법 법원일 수 있다. 설명을 위한 간단한 예로서, 당사자들은 \"사용자 A\" 및 \"사용자 B\"일 수 있고, 이전 스마트 계약은 사용자 A가 사용자 B에게 서비스를 제공 하는 합의, 및 서비스 제공 시 사용자 B가 사용자 A에게 디지털 자산 화폐를 이전하는 합의를 적용할 수 있다.스마트 계약의 제1 비상 액션은 A가 서비스를 완료했다는 통지일 수 있고, 제2 비상 액션은 B로부터 A로의 자금 의 이전일 수 있다. 제1 비상 액션의 지정된 호출자는 A일 수 있고, 제2 비상 액션의 지정된 호출자는 B일 수 있다. 일례에서, A가 서비스 완료 액션을 호출한 후, B는 지불 액션의 호출을 거부하여 A에게 서비스에 대해 지불하는 것을 거부할 수 있다. 그러면, 사용자 A 또는 사용자 A의 법적 대리인(예를 들면, 변호사)은, 사용자 B가 제2 비상 액션을 실행하게 하도록, 법원이 승인된 에일리어스로서 활동할 것을 요청할 수 있다. 예시적인 트랜잭션 시나리오에 대해 더 구체적으로 말하면, 요청 액션 입력은 스마트 계약에 대한 링크, 요청 비상 액션의 식별, 및 호출자(이 예에서는 사용자 B)의 식별을 포함할 수 있다. 필요할 경우, 사용자 A의 아이덴티티뿐만 아니라 필요할 수 있는 비상 액션의 임의의 파라미터들도 포함될 수 있다. 도 3과 관련하여 위 에서 설명한 트랜잭션 시나리오의 모든 동작들은 스마트 계약 시나리오에도 적용될 수 있다. 요청 액션 입력 외에도, 주요 차이점은 요청 사양의 콘텐츠(및 가능한 포맷), 집행 액션 사양, 및 액션 엔트리 요청(31 3)의 콘텐츠와 관련된다. 이 예시적인 스마트 계약 시나리오에서, 법원은 스마트 계약의 지불 비상 액션을 강제하는 명령을 발부하라고 요청받을 것이다. 법원이 동의한다고 상정하면, 트랜잭션 시나리오에 대해 위에서 설명한 검증 절차가 동일한 방식으로 수행될 것이다. 생성되어 블록체인 네트워크에 송신(입력)된 액션 입력 요청은, 블록체인 의 노드(들)가 법원이 지불 비상 액션을 호출하기 위한 승인된 에일리어로서 역할하는 것을 받아들이거나 허용하도록 구성될 것이다. 액션 엔트리 요청을 수신하는 각 노드는, 수신된 액션 엔트리 요청에서의 요청 사양에 단방향 해시 함수를 적용함으로써, 자신의 로컬 버전의 HASH를 추가 생성할 수 있다. 다시 말하면, 이를 통해 노드는 요청 액션이 인증되고 승인되었을 뿐만 아니라 지정된 오프체인 신뢰 기관에 의해 요청되고 승인된 액션과 정확히 일 치하는지 확인할 수 있다. 이어서, 각 노드는, 블록체인 사용자들에 의해 제출된 임의의 요청 액션 또는 트랜 잭션과 마찬가지로, 요청을 처리하고 블록체인에의 엔트리를 위해 요청 액션을 제출할 수 있다. 이 방식으로, 요청 액션이 효과적으로 수행되고 블록체인에 기록될 수 있다. 다시 말하면, 적어도 다수의 신뢰 검증자들이 HASH의 값에 동의하면 모든 신뢰 검증자들에 걸쳐 집단적 레벨의 신뢰를 제공하므로, 각 신뢰 검증자가 개별적 으로 신뢰될 필요가 없다. 도 4b는 예시적인 실시형태에 따른 스마트 계약 시나리오에 대한 블록체인 노드에 의한 시스템 레벨 액션 엔트 리 요청의 예시적인 처리의 표현을 나타낸다. 예시적인 스마트 계약 시나리오의 경우, 액션 엔트리 요청에는 313-B라는 라벨이 부여된다. 예로서 및 설명을 위해, 단 하나의 노드인 노드(302-2)만이 고려된다. 액션 엔트 리 요청(313-B)을 수신하는 어떠한 노드도 요청을 처리할 때 동일한 규칙을 적용한다는 점을 이해해야 한다. 도면에는, 액션 엔트리 요청(313-B)의 확장되지만 여전히 단순화된 뷰가 제시된다. 예를 들면, 스마트 계약 시 나리오에 대한 확장된 액션 엔트리 요청(313-B)은 요청 사양, 오프체인 요청 인디케이터, 액션 날짜, 및 서명된 HASH들(A-Signed(HASH)(311-A), B-Signed(HASH)(311-B), C-Signed(HASH)(311-C)(또한 생략 부호로 표시된 임의 의 추가적인 서명된 HASH들)를 포함한다. 추가적인 정보도 포함될 수 있고, 요청의 포맷은 개념적으로 표현된 것이며, 실제 구현의 포맷과 반드시 대응하는 것은 아님을 이해해야 한다. 예를 들면, 예시적인 스마트 계약 시나리오에 대한 요청 사양은 스마트 계약에 대한 링크, 비상 액션의 식별, 비상 액션의 지정된 호출자의 식별, 및 (가능하게는 선택적으로) 비상 액션의 파라미터들을 포함하는 것으로 나 타난다. 예를 들면, 스마트 계약의 하나 이상의 다른 당사자들의 식별과 같은 기타 정보도 포함될 수 있다. 자산 소유자의 아이덴티티와 소유자뿐만 아니라 수신자의 자산(들)에 적용될 액션의 설명은 선택적으로, 액션이 소유자로부터 수신자로의 이전일 경우, 제공될 수 있다. 도시한 바와 같이, 오프체인 요청 인디케이터가 \"참\" 으로 설정되는데, 이는 이것이 시스템 레벨 구현들의 예시적인 실시형태들에 따라 확립된 규칙을 따르는 오프체 인 요청임을 의미한다. 액션 날짜는 요청 액션을 수행할 미래 날짜/시간을 설정하는 파라미터이다. 예시적인 스마트 계약 시나리오에 서, 요청 액션은 비상 액션이다. \"참고\"로 라벨이 부여된 박스에 나타내는 바와 같이, 액션 날짜(또는 하나 이 상의 액션들의 날짜들)가 요청 사양에 추가로 또는 대안으로 포함될 수 있다. 요청 사양에 추가적으로 포함될 경우, 다수의 액션 날짜들 중 어느 날짜가 우선하는지 결정하도록 규정된 규칙이 적용될 수 있다. 또는 다수의 액션 날짜들이 요청 사양에 포함되는지, 아니면 외부에 위치하는지에 따라 다른 결과들을 가질 수 있다. 노드(302-2)에 의한 액션 엔트리 요청(313-B)의 예시적인 처리는 노드(302-2) 아래에 나타난 흐름도(400-B)에 표현된다. 이 예시적인 예시에서, 스마트 계약 시나리오에 대한 흐름도(400-B)의 모든 단계들은 최종 단계를 제외하고 트랜잭션 시나리오에 대한 흐름도(400-A)에서의 단계들과 동일하다. 구체적으로, 스마트 계약 시나리오의 경우, ThisHASH가 HASHis와 동일하다고 확인되면, 노드(302-2)는 지정된 호출자에 대해 승인된 에일리어스 로서 활동하는 신뢰 엔티티(예를 들면, 법원)에 의해 비상 액션이 호출되도록 지시하는 트랜잭션을 생성할 수 있다. 트랜잭션은 엔트리에 배치될 수 있고, 이는 액션 엔트리 요청(313-B)에서 지정된 액션에 대한 유효 날짜 와 함께 블록체인에의 엔트리로 제출될 수 있다. 요청 트랜잭션을 갖는 엔트리가 블록체인에 배치되면(예를 들 면, 엔트리가 배치된 블록을 채굴한 후), 트랜잭션이 실행되어 비상 액션이 실행되게 된다. 3. 예시적인 변형들 위에서 논의한 바와 같이, 시스템 레벨 구현은, 예시를 통해 설명한 액션 엔트리 요청들의 처리를 수행할 수 있 도록 모든 블록체인 노드들의 거동 및/또는 동작들을 수정하는 것을 수반하기 때문에 그렇게 지정된다. 블록체 인 기반 기술들의 맥락에서, 이러한 수정들은 모든 노드들이 따르기로 동의하는(또는 구속되는) 규칙을 조정 및 /또는 업데이트하는 것을 수반할 수 있다. 따라서, 기존 블록체인에 시스템 레벨 구현의 기능들 및 동작들을 도입하려면 기존 블록체인의 하드포크를 필요로 할 수 있다. 사법 기관과 같은 신뢰 오프체인 엔티티가 되돌릴 수 없는 블록체인 액션들 및/또는 트랜잭션들을 수정하는 교정 액션들을 일으키고 이를 안전하고, 신뢰성 있고, 해킹 또는 부정 행위에 매우 강한 방식으로 행하면서도 블록체인 기술의 비집중형 분산 특성을 유지할 수 있게 하는 장점 및 이점은 프리포크(prefork) 블록체인을 선호하여 이러한 하드포크를 채택하거나 채굴자 커뮤니티가 소프트포크를 통해 시스템 레벨 구현을 채택하도록 적절한 자극 그 이상을 제공할 수 있다. 시스템 레벨 실시형태들을 구현하는데 다수의 추가적인 및/또는 대안적인 양태들이 있을 수 있다. 일부 비제한 적인 예들이 다음으로 설명된다. 요청 사양의 해시를 이용하는 대신 또는 이에 추가하여, 오프체인 요청 애플리케이션 또는 오프체인 신뢰 기관 서버는 일부 다른 방식으로 요청 액션을 나타내는 인코딩된 \"액션 페이로드\"의 형태를 생성할 수 있 다. 비제한적인 예들은 예를 들면, 규정된 공식(formula) 또는 애플리케이션 프로그램에 따라 오프체인 신뢰 기관에 의해 생성된 요청 사양의 의미론적 표현; 및 요청 사양을 입력으로 사용하여 인공 지능 엔진에 의해 생 성된 요청 사양의 의미론적 표현을 포함한다. 보다 구체적으로, 요청 사양의 의미론적 표현은 컴퓨팅 장치에 의해 해석 가능한 심볼 형태로 요청 액션을 표현할 수 있다. 예를 들면 의미론적 표현은 다음과 같이 텍스트열 또는 문자열로서 인코딩될 수 있다. {\"judicialEventId\":\"0x4176cd550cb468ed686d0462df28b4a162c7a743\", \"judicialDistrict\":\"USDC-NDOI\",\"caseNumber\":\"09-cv-05453\", \"judicialAction\":\"freeze\", \"fromWallet\":\"0xF0b874003ECF7fb973a71B2Dbd0F656666809F35\", \"toWallet\":\"0x05113E5A814b6162D85322f3D86868e36FB18E34\", \"coinId\":\"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\", \"amount\":25.0}. 신뢰 기관이 사법 법원이라고 상정하는 이 예시적인 예에서는, 요청 사양의 태그 파라미터들에 대한 다양한 식 별자가 노드 처리에 의해 인식 가능하다. 의미론적 표현 실시형태의 경우, 노드는 반드시 해시를 생성할 필요는 없지만, 대신 의미론적 표현을 재생성했 음을 확인할 수 있어야 한다. 확인되면, 노드는 의미론적 표현을 해석하여 어떤 액션 또는 액션들이 요청되고 있는지 결정하고 그에 따라 트랜잭션을 준비할 수 있다. 또 다른 예시적인 변형으로서, 오프체인 신뢰 검증자들 대신에 또는 이에 더하여, 하나 이상의 노드들의 각각은 신뢰 검증자의 기능을 통합할 수 있다. 이 실시형태에서, 노드는 공개 집행 액션 서버로부터 HASH 또는 다른 형태의 액션 페이로드의 자체 검색이 검색된 데이터의 신뢰성을 검증하는 데 충분하도록 \"자기 신뢰\"할 수 있다. 결과적으로, 액션 엔트리 요청은 반드시 다수의 서명된 HASH들 또는 다른 액션 페이로드들을 포함 할 필요는 없다. 다른 엔티티들에 의한 공개 집행 액션 서버(또는 이와 유사한 것)로부터의 다수의 검색 들의 결과는 모든 또는 임계 수의 다수의 노드들이 그들 각각의 검색들이 합치함을 동의함에 의해 대신 실현될 수 있다. 예를 들면, 이는 블록체인 노드들의 \"다수결\" 규칙을 따를 수 있다. 또 다른 예시적인 변형에서는, HASH 또는 다른 액션 페이로드의 다수의 검색들이 반드시 만장일치의 합의를 요 할 필요는 없다. 대신, 다수 합의로 충분할 수 있다. 또는 합의의 임계 수를 지정할 수도 있다. 임계값은 다 수의 수 또는 일부 다른 특정 수에 대응할 수 있다. 또한, 검색되고 서명된 HASH들을 비교하여 동일 값들에 대 해 테스트하는 특정 신뢰 검증자들(또는 노드들과 같은 다른 검색자들)은 구체적으로 식별되거나 무작위로 선택 될 수 있다. 다른 배치들도 가능하다. 다른 예시적인 변형은 블록체인 네트워크의 하나 이상의 채굴자에 있어서 위에서 예시적으로 설명한 것과 같은 노드들의 검증 액션들을 구현하는 것을 포함할 수 있다. 이러한 방식으로, 채굴자들에 의한 처리가, 노드들 또 는 신뢰 검증자들이 블록에의 엔트리에 대한 요청 액션을 검증하고 유효성확인한 후에만 발생하더라도, 채굴자 는 채굴에 시간 및 노력을 들이기 전에 또 다른 체크를 수행할 수 있다. 이는 해킹이나 부정 행위에 대한 추가 적인 보호 조치로서 역할할 수 있다. 이러한 유효성확인/검증이 블록체인 동작의 일부일 수 있으므로, 여기서 예시적인 실시형태들의 트랜잭션들 및/또는 스마트 계약을 위한 시스템 레벨 동작들은 해킹 및 그러한 동작과 같은 부정 행위에 대해 최소한 그 이상은 아니더라도 보안적이고 안전할 것이다. 또 다른 예시적인 변형에서, 블록체인에의 엔트리를 강제하는 권한은, 블록체인 사용자에 의해 이루어지는 어떠 한 요청과 관계없이 액션 엔트리 요청 등을 생성하기 위한 절차를 시작할 수 있는 엔티티에 부여될 수 있 다. 이러한 각 요청은 위에서 설명한 사례별 보호 조치들이 적용되지만, 엔티티로부터 직접 발생할 수도 있다. 또 다른 예시적인 변형에서, 노드 절차는 모든 스마트 계약들에 규정된 세트의 특별한 비상 액션들을 자율적으 로 삽입하도록 수정될 수 있다. 이것은 모든 스마트 계약들에 대해 의무적이라고 간주되는 액션일 수 있고, 모 든 스마트 계약에 이러한 비상 액션들을 적용할 수 있는 기능을 제공할 것이다. 도 3, 도 4a, 및 도 4b에 예시된 동작들 및 절차들은 위에서 설명한 예시적인 변형들에 대한 임의의 하나 이상 에 대응하도록 간단하게 수정, 적응, 및/또는 확장될 수 있음이 이해될 것이다. 즉, 도 3, 도 4a, 및 도 4b의 특정 형태 및 내용은 시스템 레벨 실시형태의 동작의 단지 일례에 적용되고 있는 것이며, 다른 가능한 실시형태 들에 대해 제한하고자 하는 것은 아니다. B. 예시적인 동작들 시스템 레벨 구현의 예시적인 동작들은 메시지 흐름도로 예시될 수 있다. 이러한 다이어그램의 예가 도 5에 나 타나 있다. 더 구체적으로, 도 5의 메시지 흐름도는 도 3에 나타난 예시적인 시스템 레벨 구현 예시 시스템의 다양한 컴포넌트들 및 요소들의 예시적인 동작 시퀀스 타임라인들을 이들 사이를 전달하는 정보(예를 들면, 메 시지들)의 맥락에서 나타낸다. 예시적인 메시지 흐름도는 트랜잭션 시나리오와 스마트 계약 시나리오 모두의 시스템 레벨 구현 예들에 적용되는 것으로 간주될 수 있다. 차이점은 다시 말하면 요청 액션 입력, 요청 사양, 집행 액션 사양, 및 액션 엔트리 요청의 내용 및 포맷이다. 도 3의 각 컴포넌트는 도 5의 상단에 라벨이 부여된 박스로 표현된다. 수직 타임라인은 각 컴포넌트 아래로 확 장되고 시간이 아래쪽으로 증가한다. 타임라인들은 정확한 타이밍을 전달하거나 표현하기 위한 것이 아니라 동 작들의 순서나 시퀀스를 나타내고자 하는 것이다. 동작들은 컴포넌트 쌍 사이에 수평 방향 화살표들로서 표시 되고, \"S<n>\"이라는 라벨이 부여되고 그 뒤로 컴포넌트들 간에 전달되는 정보의 설명이 표시된다(여기서 <n>은 숫자 라벨임). 일부 동작들은, 반드시 다른 컴포넌트에 정보를 전달하는 것을 수반하지 않고, 하나의 컴포넌트 에서 수행되는 동작들에 대해 자신 방향의 화살표로 나타나 있다. 도 5에 나타난 특정 시퀀스들은 동작 흐름의 일례를 나타내고, 동일한 결과들을 달성할 수 있는 다른 시퀀스들 또는 시퀀스 순서들을 제한하거나 배제하는 것으로 간주되어서는 안 됨을 이해해야 한다. 예시적인 사용 시나리오는, 사용자가 도 3의 요청 액션 입력과 같은 입력을 오프체인 요청 애플리케이션 에 제공하는 것으로 시작될 수 있다(UI(304-I/F)는 명확성을 위해 도 5에서는 생략되었음). 단계 S1에서, 오프체인 요청 애플리케이션은 HASH + 요청 사양을 생성하고, 단계 S2에서, HASH + 요청 사양을 오프체인 신뢰 기관 서버에 송신(예를 들면, 전송 또는 제공)한다. 요청이 승인된다고 상정하면(예를 들면, 판사에 의한 평가 후; 이 액션을 도면에는 명시적으로 나타내지는 않음), 오프체인 신뢰 기관 서버는 단계 S3에서 HASH + 집행 액션 사양을 공개 집행 액션 서버에 게시 또는 공개할 수 있다. 단계 S4에서, 오프체인 신뢰 기관 서버는 오프체인 요청 애플리케이션에 확인 ID를 송신 또는 제공할 수 있다. 그러면 오프체인 요청 애플리케이션은 단계 S5에서 HASH + 요청 사양을 오프체인 트랜잭션 서버에 송 신(또는 제공)하고, 단계 S6에서 이벤트 감시자에게 확인 ID를 송신(또는 제공)할 수 있다. 확인 ID를 수신한 것에 응답하여, 이벤트 감시자는 단계들 S7-A, S7-B, 및 S7-C에서 각 신뢰 검증자 A, B, C(312-A, 312-B, 및 312-C)에게 각각 통지할 수 있다. 각 통지는 또한 확인 ID, 또는 공개 집행 액션 서버로부터 정보를 검색하는 데 적합한 일부 다른 식별자를 포함할 수 있다(또는 그 자체일 수 있다). 단계 S8-A, S8-B, 및 S8-C에서, 신뢰 검증자 A, B, 및 C는 별개로 및 독립적으로 공개 집행 액션 서버와 상호 작용하여, 별개로 및 독립적으로 HASH를 검색한다. 이 상호 작용들의 이중 화살표들은 이 검색 프로세스 와 관련된 가능한 양방향 통신을 표현한다. 단계 S9-A에서, 신뢰 검증자 A는 자신의 개인 키로 HASH에 서명하고, 단계 S10-A에서, A-signed(HASH)를 기록 또는 저장을 위해 검증된 요청 데이터베이스에 송신(제공)한다. 마찬가지로, 단계 S9-B에서, 신뢰 검증자 B는 자신의 개인 키로 HASH에 서명하고, 단계 S10-B에서, B-signed(HASH)를 기록 또는 저장을 위해 검증된 요청 데이터베이스에 송신(제공)하고; 단계 S9-C에서, 신뢰 검증자 C는 자신의 개인 키로 HASH에 서명하고, 단 계 S10-C에서, C-signed(HASH)를 기록 또는 저장을 위해 검증된 요청 데이터베이스에 송신(제공)한다. 신 뢰 검증자들이 독립적으로 활동하므로, 나타낸 시퀀스 순서는 단지 하나의 가능한 예라고 간주되어야 한다. 처 리 로직의 관점에서, 단계 S9-<A,B,C>에서 HASH에 암호화 서명하는 것이 단계 S10-<A,B,C>에서 서명된 HASH를 검증된 요청 데이터베이스에 송신하는 것을 선행하는 것만이 필요할 수 있다. 단계 S11은 요청 폴러의 폴링 활동들 및 오프체인 트랜잭션 서버와의 통신을 나타낸다. 이 맥락에서, 오프체인 트랜잭션 서버는 서명된 HASH들의 존재 및/또는 이용 가능성에 대해 검증된 요청 데이 터베이스를 폴링하도록 요청 폴러에 조언할 수 있다. 따라서, 단계들 S12 및 S13에서, 요청 폴러 는 이 폴링에 참여할 수 있고, 최종적으로 서명된 HASH들이 검증된 요청 데이터베이스로부터 검색에 이용 가능한 시기를 결정할 수 있다. 단계 S14에서, 오프체인 트랜잭션 서버는, 예를 들면 \"풀링(pull)\" 액션으로 검증된 요청 데이터베이스 로부터 서명된 HASH들을 검색할 수 있다. 이는 요청 폴러가 서명된 HASH들을 검색하여 오프체인 트 랜잭션 서버에 제공하는 것을 제안하는 도 3과 다소 다르다는 점에 유의할 수 있다. 이는 동일하거나 유 사한 결과를 얻는데 사용될 수 있는 처리의 변형 유형의 예를 나타낸다. 단계 S15에서, 오프체인 트랜잭션 서버는 오프체인 액션 엔트리 요청을 생성(또는 발생)하고, 단계 S16에 서, 요청을 블록체인 네트워크에 송신한다. 블록체인 네트워크의 노드들은 도 4a 및/또는 도 4b와 관련하여 위의 예를 통해 설명한 바와 같이 요청을 처리할 수 있다. 오프체인 액션 엔트리 요청의 구조 및 내용, 및 블록체인 규칙 및 노드 동작들에 대한 수정은, 시스템 레벨 구 현의 많은 장점 및 이점을 도입하는 시스템 레벨 구현의 예시적인 실시형태의 특별한 새로운 측면들을 포함하지 만, 오프체인 액션 엔트리 요청을 생성하고 이를 블록체인 네트워크에 전달하는 것과 관련하여 위의 예를 통해 설명한 동작들은 기존 블록체인 동작들의 보안 및 보호 조치를 능가하지는 않더라도 적어도 동일하게 용이하게 한다. 또한 언급한 바와 같이, 이는 블록체인 기반 기술들의 분산 및 비집중형 동작 아키텍처를 희생하지 않고 달성된다. 도 3, 도 4a, 및 도 4b와 마찬가지로, 도 5는 위에서 설명한 예시적인 변형들에 대한 어느 하나 이상에 대응하 도록 수정, 적응, 및/또는 확장될 수 있다. 즉, 도 5의 특정 형태 및 내용은 시스템 레벨 실시형태의 동작의 단지 일례에 적용된다. 그러나, 도 5의 특정 형태 및 내용을 다른 가능한 실시형태들에 대해 제한하고자 하는 것은 아니다. IV. 예시적인 엔트리 레벨 구현 예시적인 엔트리 레벨 실시형태들에 따르면, 블록체인 스마트 계약들의 비상 액션들의 기능은, 신뢰 오프체인 기관에 의해 제공되고 블록체인의 노드들이 알고 액세스할 수 있는 신뢰할 수 있는 보안 데이터베이스에 인증, 검증 및 저장되는 오프체인 트리거 코드들에 의해 실행되는 방향을 갖도록 확장될 수 있다. 특히, 예시적인 엔 트리 레벨 실시형태들에 따라 도입된 능력들은 시스템 레벨에서 노드 동작들을 수정하는 것을 포함하거나 요구 하지 않는다. 오히려, 신뢰 오프체인 기관에 의해 공급되는 트리거 코드들의 일종의 스토리지로서 역할하는 신 뢰할 수 있는 데이터베이스에 특정 노드 동작들을 \"연결\"함으로써 능력들이 도입된다. 예시적인 엔트리 레벨 실시형태들은 저장소의 트리거 코드들의 무결성 및 유효성을 보호하는 일련의 절차 및 프로토콜을 마련하는 동 시에 노드 동작을 변경하지 않고 블록체인의 분산 및 비집중형 동작 원칙을 그대로 방해 없이 유지한다. 위에서 설명한 바와 같이, 블록체인 트랜잭션의 기존 모델은 일부 형태의 디지털 토큰(들) 및 디지털 토큰(들) 을 사용하거나 그것으로 \"트랜잭션\"할 권한을 갖는 토큰(들)의 소유자를 포함한다. 토큰은 트랜잭션에서의 유 용성으로 인해 일부 고유한 가치를 갖거나 가치가 부여될 수 있다. 예를 들면, 디지털 토큰들은 실제 상품 및 서비스에 대해 거래될 수 있다. 이러한 맥락에서의 디지털 토큰들의 비제한적인 예는 디지털 화폐 및 NFT를 포함한다. \"토큰\"이라는 용어는 블록체인에서의 트랜잭션들을 설명하는 데 있어서 어느 정도의 일반성을 수용하 지만, 여기에서의 예시는 주로 가치를 더 구체적으로 암시하는 용어로 예를 들어 설명한다. 따라서, 나머지 논 의에서는 트랜잭션들에서의 일종의 유용성을 일깨워주는 것으로서 \"토큰\" 대신 \"자산\"이라는 용어를 사용한다. 그러나, 이러한 특정 용어 선택으로 인해 일반성이 손실되는 것은 아니라는 점을 이해해야 한다. 따라서, 자산 또는 자산들의 소유자는 블록체인에서의 트랜잭션에서 해당 자산들을 사용할 권한을 갖는 자이다. 즉, 여기서 \"기존\" (디지털) 자산들이라고 지칭되는 이 자산들은 구매 등의 사용 가능한 가치를 보유하거나 나 타낼 수 있지만, 그 자체로는 어떤 기능과도 연관되어 있지 않다. 예시적인 실시형태들에 따르면, 기존 디지털 자산은, 그 가치를 유지하고 트랜잭션들과 연관된 특정 기능적 능력들을 추가하는 형태로 효과적으로 \"변환\"될 수 있다. 따라서, 변환된 자산들은 변환되지 않은 기존 인스턴스화와 동일한 방식으로 트랜잭션들에서 사용될 수 있지만, 인증, 유효성확인, 및 검증된 트리거 코드들을 적용해야만 호출 가능한 하나 또는 다른 세트의 특정 액션들이 적용될 수도 있다. 또한, 실제 트리거 코드들의 모든 인스턴스들은 오프체인 신뢰 기관에 의해 사례 별로 생성되어야 하고 변환된 자산들의 특정 소유자에게 특정되어야 한다. 기존 디지털 자산들은, 원하는 기능을 구현하는 실행 가능한 코드로 기존 자산들을 \"래핑(wrapping)\"함으로써 변환될 수 있다. 따라서, 변환된 디지털 자산들은 본원에서 \"래퍼 자산들\"이라 지칭되고, 래퍼 자산들이 받게 되는 액션들은 본원에서 \"래퍼 액션들\"이라 지칭된다. 래퍼 액션들의 비제한적인 예들은 소유자로부터 특정 수 신자(예를 들면, 다른 사용자 또는 다른 계정)로의 이전, 동결, 및 동결 해제를 포함한다. 예시적인 실시형태 들에 따르면, 기존 자산들의 소유자는 그 일부를 래퍼 자산들로 변환한 후, 기존 자산들을 사용할 수 있는 것과 동일한 방식으로 트랜잭션들에서 사용할 수 있다. 그러면, 이것은 엔트리 레벨 실시형태의 트랜잭션 시나리오 에 대응한다. 래퍼 자산들과 마찬가지로, 스마트 계약의 임의의 비상 액션이 특정 트리거 코드에 의해 실행되도록 구성될 수 있다. 이 경우, 트리거 코드는 스마트 계약에 대한 링크, 특정 비상 액션의 식별, 및 비상 액션의 가능한 파라 미터들을 지정할 수 있다. 엔트리 레벨 실시형태의 트랜잭션 시나리오, 엔트리 레벨 실시형태의 스마트 계약 시나리오에서와 마찬가지로, 트리거 코드들은 오프체인 신뢰 기관에 의해 사례별로 생성되어야 하지만, 이 경우 에는 특정 스마트 계약에만 특정된다. 그러면, 이것은 엔트리 레벨 실시형태의 스마트 계약에 대응한다. 트랜잭션 시나리오와 스마트 계약 시나리오 모두에 대해, 엔트리 레벨 실시형태들의 예의 구현들은 인증, 유효 성확인, 및 검증된 트리거 코드들의 안전하고 보안된 생성 및 저장을 보장하기 위한 컴포넌트들 및 절차를 포함 한다. 따라서, 예시적인 실시형태들은 래퍼 디지털 자산들 및 트리거된 스마트 계약들에 의해 도입된 유연하고 다재다능한 기능이 해킹 및/또는 다른 형태의 오용 또는 부정 행위로부터 보호됨을 보장한다. 엔트리 레벨 구현이라 지칭되는 엔트리 레벨 실시형태의 예시적인 구현이 아래에서 더 자세히 설명된다. A. 예시적인 시스템 아키텍처 및 기술 설명 도 6은 예시적인 실시형태에 따른 블록체인 기반 트랜잭션들의 인증된 오프체인 수정의 엔트리 레벨 구현의 컴 포넌트들의 예시적인 배치를 나타내는 단순화된 블록도이다. 도 6의 블록도는 엔트리 레벨 구현의 동작 아키텍 처 측면들을 나타내는 것으로 간주될 수도 있다. 나타낸 바와 같이, 예시적인 실시형태들은 다양한 컴포넌트들 을 포함할 수 있고, 이들 중 어느 하나 이상은 하나 이상의 컴퓨팅 장치들로서 또는 그 안에 구현될 수 있다. 이와 같이, 도 6에 나타난 컴포넌트들은 그 자체로 하드웨어, 소프트웨어, 펌웨어, 또는 그 조합들이거나 이를 포함할 수 있다. 컴포넌트들 중의 일부는 데이터베이스들 또는 다른 형태의 데이터 스토리지 및 관리와 같이 구조적으로 식별될 수 있고, 다른 것들은 동작 또는 기능의 관점에서 식별될 수 있다. 동작적 및/또는 기능적 컴포넌트들은 예를 들면 소프트웨어 및/또는 하드웨어 모듈들로서 구현될 수 있고, 본 논의의 목적을 위해 \"모 듈들\"이라고도 지칭될 수 있다. 예시적인 엔트리 레벨 구현은 다양한 컴포넌트들을 연결하는 하나 이상의 연결 메커니즘도 포함할 수 있다. 예 를 들면, 연결 메커니즘은 컴포넌트들 간에서 화살표로서 표시된다. 화살표의 방향은 정보 흐름의 방향을 나타 낼 수 있지만, 이 해석이 제한으로서 간주되어서는 안 된다. 본 개시에서, \"연결 메커니즘\"이라는 용어는 둘 이상의 컴포넌트들, 장치들, 시스템들, 또는 기타 엔티티들을 연결하고 그들 간의 통신을 용이하게 하는 메커니 즘을 의미한다. 연결 메커니즘은 케이블 또는 시스템 버스와 같은 비교적 간단한 메커니즘, 및/또는 패킷 기반 통신 네트워크(예를 들면, 인터넷)와 같은 비교적 복잡한 메커니즘을 포함할 수 있다. 일부 사례들에서, 연결 메커니즘은 연결이 적어도 부분적으로 무선인 경우에서와 같이 비유형의(non-tangible) 매체를 포함할 수 있다. 연결 메커니즘은 또한, 예를 들면 API(application program interface)와 같이 소프트웨어 및/또는 하드웨어모듈들 또는 애플리케이션들 간의 프로그래밍된 통신을 포함할 수 있다. 본 개시에서, 연결은 직접 연결 또는 간접 연결일 수 있고, 후자는 라우터, 스위치, 또는 다른 네트워크 장치와 같은 하나 이상의 엔티티를 통과 및/ 또는 횡단하는 연결이다. 마찬가지로, 본 개시에서, 통신(예를 들면, 데이터의 전송 또는 수신)은 직접 또는 간접 통신일 수 있다. 예를 들면, 도 3의 예시적인 시스템 레벨 구현의 다양한 컴포넌트들 및 엔티티들은 연결된 노드들(602-1, 602- 2, ..., 602-N)을 갖는 블록체인 네트워크를 포함하고, 여기서 노드(602-N)에 대한 연결들에서의 생략 부 호는 가능한 추가적인 연결된 노드들을 나타낸다. 예시적인 시스템 레벨 구현의 다른 예시적인 컴포넌트들 및 엔티티들은 사용자 인터페이스(UI)(604-I/F)를 갖는 오프체인 요청 애플리케이션, 오프체인 신뢰 기관 서 버, 공개 집행 액션 서버, 이벤트 감시자, 신뢰 검증자 A(612-A), 신뢰 검증자 B(612-B), 신뢰 검증자 C(612-C), 요청 검증 서버, 검증된 요청 데이터베이스, 및 신뢰 검증자 공개 키들을 포 함한다. 신뢰 검증자 C(612-C) 뒤에 오는 생략 부호는 추가적인 신뢰 검증자들이 있을 수 있음을 나타낸다. 예시적인 실시형태에서, 오프체인 요청 애플리케이션은 다른 가능한 장치들 중에서 PC, 랩탑, 스마트폰, 또는 서버와 같은 컴퓨팅 장치에서의 실행을 위해 구성되는 애플리케이션 프로그램일 수 있다. 예시적인 컴포넌트들 및 엔티티들의 계산적 및/또는 기능적 역할들은 블록체인에서의 트랜잭션들 및 블록체인에 서의 스마트 계약들과 관련된 예시적인 동작 시나리오들을 고려함으로써 이해될 수 있다. 두 유형의 시나리오 들 모두는 유사하고 일부 측면에서는 동일한 동작들을 포함한다. 그러나, 두 시나리오들의 구별되는 측면들을 명확하게 유지하는 것을 돕기 위해 두 시나리오들의 동작 예들을 아래에 별개로 설명한다. 1. 블록체인에서의 트랜잭션들에 대한 예시적인 엔트리 레벨 시나리오 엔트리 레벨 실시형태의 예시적인 트랜잭션 시나리오에서, 수신자에게의 래퍼 디지털 자산의 송신자는 래퍼 디 지털 자산을 송신자의 계정으로부터 수신자의 계정으로 이전한 트랜잭션의 결과를 반전시키려고 할 수 있다. 시스템 레벨의 예시에서와 같이, 송신자가 수신자에 의해 속았거나 사기를 당했을 수 있고, 이에 따라 교정을 위해 사법 법원을 찾을 수 있다. 엔트리 레벨 실시형태의 예시적인 트랜잭션 시나리오에서, 교정 액션은 래퍼 디지털 자산의 적절한 비상 액션과 연관된 트리거 코드의 발생 또는 생성에 의해 명령될 수 있다. 현재 예에서, 교정 비상 액션은 래퍼 디지털 자산을 수신자로부터 송신자에게 다시 이전하는 것일 수 있다. 따라서, 트리거 코드는 수신자를 래퍼 디지털 자산의 소유자로서 지정하고, 이전 액션을 비상 액션으로서 지정하고, 원 래 송신자를 요청된 이전의 대상으로서 지정할 수 있다. 이 정보는, 예를 들면 요청 액션 입력으로서 제 공될 수 있다. 따라서, 송신자 또는 송신자의 법적 대리인(예를 들면, 변호사)은 UI(604-I/F)에 요청 액션 입력을 입력할 수 있다. 요청 액션 입력은 송신자, 수신자를 식별하는 정보, 송신자로부터 수신자로의 원래 이전에 대한 세부 정보, 요청되는 교정 액션, 및 송신자가 속았거나 사기를 당해서 원래 트랜잭션에 참여하게 된 증거를 제 공하거나 및/또는 증거로서 기능하는 특정 정보를 포함할 수 있다. 예시적인 실시형태들에 따르면, UI(604- I/F)는, 예를 들면 공식적인 요청을 구성하는데 필요한 특정 정보에 대해 송신자(또는 기타 보다 일반적으로는 사용자)에게 촉구하고, 요청을 평가 및 승인하거나 거부하기 위한 필수 정보를 법원에 제공하는 드롭다운 메뉴 등을 갖는 온라인 양식이거나 이를 포함할 수 있다. UI(604-I/F)는 요청 액션 입력을 오프체인 요청 애플리케이션에 제공할 수 있고, 이것은 사법 법원에 의 전달을 위한 요청을 처리할 수 있다. 따라서, 예시적인 실시형태들에 따르면, 오프체인 요청 애플리케이션 은 요청 액션 입력의 모든 또는 일부 특정 항목들 또는 요소들을 \"요청 사양\"으로 배치 및/또는 포맷 하고, 요청 사양의 단방향 해시를 생성할 수 있다. 시스템 레벨 실시형태의 논의에서와 같이, 요청 사양의 단 방향 해시는 모두 대문자로 HASH로 라벨이 부여된다. 또한 논의의 목적으로, HASH 및 요청 사양은 HASH + 요청 사양이라고 지칭되는 데이터 엔티티로서 함께 간주될 수 있다. 이 그룹화는 동작 설명의 편의를 위한 것 이며 실제로 반드시 구현될 필요는 없다는 점을 이해해야 한다(단, 그룹화가 반드시 제외되는 것은 아니다). 그러면 HASH + 요청 사양이 오프체인 신뢰 기관 서버에 제공될 수 있다. 신뢰 기관이 사법 법원인 예에서, 오프체인 신뢰 기관 서버는, 법원과 연관되고 블록체인에 입력되는 액션들을 강제하기 위한 요청 을 수신하기 위해 구성되는 서버일 수 있다. 예를 들면, 오프체인 신뢰 기관 서버는 적절한 포맷의 HASH + 요청 사양 메시지들 또는 직접 입력을 수신하기 위해 구성되는 API를 구현할 수 있다. 다른 예에서, 오 프체인 신뢰 기관 서버는, 법원과 연관되고 오프체인 신뢰 기관 서버를 포함하여 다양한 법원/사건 관련 입력을 수신하기 위해 구성되는 보다 일반적인 서버일 수 있다. 다른 배치들도 가능하다. 일부 예들에서, HASH + 요청 사양은, 예를 들면 송신자의 법적 대리인에 의해 요청에 대한 뒷받침 증거와 함께사법 법원에 \"수동으로\" 제공될 수 있다. HASH + 요청 사양이 오프체인 신뢰 기관 서버에 의해 수신된 후, 요청 액션을 승인할지의 여부에 대 해 평가가 이루어질 수 있다. 신뢰 기관이 사법 법원인 예를 다시 고려하면, 평가는 판사 또는 법원의 다른 권 한 있는 대리인에 의해 이루어질 수 있다. 이 양태는 시스템 레벨 실시형태에 대해 설명한 것과 동일할 수 있 다. (예를 들면, 사람에 의해 또는 알고리즘에 의해) 요청을 승인한다는 결정이 내려진다고 상정하면, HASH + 집행 사양이 공개 집행 액션 서버에 게시 또는 공개될 수 있다. 사법적 예에서, HASH + 집행 사양은, 결정을 명확히 표현하고 HASH의 내포된 영숫자 표현을 포함하는 사람이 판독 가능한 전자 파일일 수 있다. 예를 들면, HASH + 집행 사양은 법원에 의해 디지털 서명된 PDF 파일일 수 있다. 공개 집행 액 션 서버는 법원 업무의 다른 형태 중에서 그러한 결정들이 게시되는 공개적으로 액세스 가능한 서버일 수 있다. 사법 법원의 예에서, 공개 집행 액션 서버는, 예를 들면 PACER 서버와 같은 서버일 수 있다. 그러 나, 다른 배치들도 가능하다. 또한 요청을 승인한다는 결정으로, 오프체인 신뢰 기관 서버는 오프체인 요청 애플리케이션에 확인 ID를 제공 또는 송신(예를 들면, 전송)하고(오프체인 요청 애플리케이션에 긍정적 결정을 알리는 역 할을 할 수 있음) 공개 집행 액션 서버에서 현재 공개된 HASH + 집행 사양에 액세스하기 위한 식별 정보를 제공한다. 예시적인 실시형태들에 따르면, 오프체인 요청 애플리케이션은 확인 ID를 수신한 후, 이어서 확인 ID를 이벤트 감시자에게 송신할 수 있다. 그렇게 하면 공개 집행 액션 서버에서의 HASH + 집행 사양의 이용 가능성을 이벤트 감시자에게 알릴 수 있다. 그러면 오프체인 요청 애플리케이션은 또한 HASH + 요청 사양을 요청 검증 서버에 제공하거나 송신(예를 들면, 전송)하여 또한 공개 집행 액션 서버에서의 HASH + 집행 사양의 이용 가능성을 인식하게 할 수 있고 대응하는 트리거 코드의 생 성을 시작하게 할 수 있다. 도 6에 나타난 바와 같이, 확인 ID로 알림을 받은 이벤트 감시자는 이후 각 신뢰 검증자 A, B, C(612-A, 612-B, 612-C)뿐만 아니라 임의의 추가적인 신뢰 검증자들 각각에게 독립적으로 통지할 수 있다. 각 신뢰 검증 자는, 예를 들면 설립된 은행, 중개업체, 또는 네트워크 서비스 프로바이더와 같은 각각의 조직이나 기관과 연 관된 보안 서버 또는 기타 네트워킹된 보안 컴퓨팅 시스템일 수 있다. 도면에 반드시 도시되는 것은 아니지만, 각 신뢰 검증자에 대한 통지는 확인 ID 또는 공개 집행 액션 서버에서의 HASH + 집행 사양에 대한 액 세스를 가능하게 하는 기타 정보도 포함할 수 있다. 통지를 받은 각 신뢰 검증자 A, B, C(612-A, 612-B, 및 612-C)뿐만 아니라 임의의 추가적인 신뢰 검증자들은 각 각의 보안 링크들을 통해 공개 집행 액션 서버로부터 HASH를 독립적으로 검색할 수 있다. 각 독립적인 검 색은 본 논의의 목적을 위해 HASH라는 라벨로 나타나며, 다시 말하면, 생략 부호는 추가적인 신뢰 검증자 들로부터의 HASH의 추가적인 검색들을 나타낸다. 보안 검색과 함께 신뢰 검증자들의 신뢰할 수 있는 특성 을 통해 각 신뢰 검증자는 검색된 HASH의 신뢰성을 독립적으로 보증할 수 있다. 각 신뢰 검증자는 검색된 HASH를 인증 디지털 서명으로서도 역할을 하는 개인 암호화 키로 암호화함으로써 이를 수행할 수 있다. 따라서, 신뢰 검증자 A(612-A)는 A-Signed(HASH)(611-A)를 생성하고; 신뢰 검증자 B(612-B)는 B- Signed(HASH)(611-B)를 생성하고; 신뢰 검증자 C(612-C)는 C-Signed(HASH)(611-C)를 생성한다. 그러면 각각의 신뢰 검증자는 요청 검증 서버에 각각 서명된 HASH를 제공(예를 들면, 송신 또는 전송)할 수 있다. 추가 적인 서명된 HASH들이 요청 검증 데이터베이스에 제공될 수 있고, 이는 (한번 더) 생략 부호로 표시되어 있다. 그러면 요청 검증 서버는 HASH와 인증, 검증, 및 유효성확인된 트리거 코드를 검증 및 유효성확인하고 이 를 검증 요청 데이터베이스에 저장하는 동작들을 수행할 수 있다. 이 시점에서, 요청 액션 입력과 연관된 액션을 트리거하는 트리거 코드가 이용 가능하다. 이 예에서, 위에서 설명한 바와 같이, 트리거 코드는 수신자 를 래퍼 디지털 자산의 소유자로서 지정하고, 이전 액션을 비상 액션으로서 지정하고, 원래의 송신자를 요청된 이전의 대상으로서 지정할 수 있다. 예시적인 실시형태에서, 검증된 HASH는 트리거 코드로서 역할할 수 있고, 요청 검증 서버에 의한 유효성확인 및 검증 처리는 트리거 코드의 유효성확인 및 검증으로 간주될 수 있다. 예시적인 후속 시나리오는 도 6의 오른쪽 상단에 있는 블록체인 네트워크를 둘러싸는 박스에 나타난다. \"1\"로 라벨이 부여된 제1 단계에서는, 노드(602-2)에 HASH + 액션 요청을 제공함으로써 요청 액션이 이루 어진다. HASH + 액션 요청은 동작 요청에서 지정된 대로 소유자의 래퍼 자산들과 연관된 트리거 코드의 존재 및 이용 가능성을 노드(602-2)에 알릴 수 있다. \"2\"로 라벨이 부여된 제2 단계에서는, 노드(602-2)는 트 리거 코드를 풀링할 수 있고, 이것은 이 예에서 검증된 요청 데이터베이스로부터의 검증된 HASH이다. 데 이터베이스가 블록체인 네트워크에 의해 신뢰받기 때문에, 노드(602-2)는 트리거 코드와 연관된 비상 액션 을 실행할 수 있다. 이 예에서, 액션으로 인해 분쟁이 발생한 트랜잭션의 소유자로부터 원래의 송신자에게 래 퍼 자산들의 일부 금액이 이전되게 된다. 노드 처리의 일부 또는 전부는 블록체인 동작에 따를 수 있다. 따라 서, HASH + 액션 요청은 노드들의 전체 또는 몇몇에 전파될 수 있고, 이를 수신한 전체가 방금 설명된 처 리에 참여할 수 있다. 도 7a는 예시적인 실시형태들에 따른 트랜잭션 시나리오에 대한 엔트리 레벨 액션 엔트리의 요청 검증 서버 의 예시적인 처리의 표현을 나타낸다. 도 6 및 다시 도 7a에 나타난 바와 같이, 요청 검증 서버는 서명된 HASH들 A-Signed(HASH)(611-A), B-Signed(HASH)(611-B), C-Signed(HASH)(611-C)(또한 세로 생략 부호로 표시된 임의의 추가적인 서명된 HASH들)도 수신한다. 도면에는, HASH + 요청 사양(603-A)의 확장되지만 여전히 단순화된 뷰가 제시된다. 예를 들면, 트랜잭션 시나리오에 대한 확장된 HASH + 요청 사양(603-A)은 요청 사양, 오프체인 요청 인디케이터, 및 액션 날짜를 포함한다. 추가적인 정보도 포함될 수 있고, 요청의 포맷은 개념적 으로 표현된 것이며, 실제 구현의 포맷과 반드시 대응하는 것은 아님을 이해해야 한다. 또한 예를 들면, 요청 사양은 자산 소유자의 아이덴티티 및 소유자의 자산(들)에 적용될 액션의 설명을 포함하 는 것으로 나타나고, 예를 들면 액션이 소유자로부터 수신자로의 이전인 경우 수신자는 선택적으로 제공받을 수 있다. 다시 말하면, 이 경우 자산은 래퍼 자산이다. 소유자로부터 수신자로의 \"X\"의 이전에 대한 예시적인 액 션을 설명한다. 이 예시적인 요청 사양에서는, 수신자가 이전에 디지털 자산들의 일부를 소유자에게 이전했고, 이제 요청 액션을 통해 해당 이전의 X 금액을 반환하도록 요청하고 있다고 상정한다. 도시한 바와 같이, 오프 체인 요청 인디케이터는 \"참\"으로 설정된다. 액션 날짜는 요청 액션을 수행할 미래 날짜/시간을 설정하는데 사용될 수 있는 파라미터이다. 액션을 수행하기 위한 미래 날짜를 규정하면, 트리거 코드(이 예에서는 검증된 HASH)를 생성하고 이를 검증된 요청 데이터 베이스에 전달한 엔트리 레벨 절차의 가능한 부정 행위 또는 오용에 대한 추가 보호 조치를 도입할 수 있 다. 예를 들면, 불법적인 요청이 어떻게든 유효성확인되어 트리거 코드에 입력되면, 액션을 수행하는데 내포된 지연이 액션이 이루어지기 전에 오류를 발견하고 정정할 시간을 마련한다. 또한 미래 날짜를 통해 요청 액션의 임의의 당사자가 액션을 실시하기 위한 허가에 대해 이의를 제기할 수 있다. 예를 들면, 액션이 미래 역이전을 강제함으로써 수신자로부터 소유자로의 이전의 결과를 역전시키는 것을 목적으로 하고 소유자가 역이전에 대한 요청을 승인하기로 결정하게 된 법원에 제시된 조건 또는 증거에 대해 이의를 제기하려는 경우, 내포된 지연은 소유자가 요청을 거부할 사례를 제시할 시간을 마련한다. 마찬가지로, 법원 명령에 대한 항소를 제기하는 시간 과 같이 미래 날짜를 규정하는 것은 신뢰 기관이 액션을 취하는 데 필요한 절차일 수도 있다. 액션 날짜는 특 정 날짜 이후의 시간량으로서 지정될 수 있다. 예를 들면, 시간량은 72시간, 7일, 또는 30일일 수 있다. 다른 시간량을 사용할 수도 있다. \"참고\" 라벨이 부여된 박스에 나타낸 요청 사양에 포함된 예시적인 액션은 제한이 없다. 다른 비제한적인 예는 X에 대한 소유자의 액세스를 동결 또는 동결 해제, X의 일부만을 이전, X를 소유자로부터 에스크로 계정으로 이 전하는 것을 포함한다. 다른 액션들도 가능할 수 있다. 또한 참고에 나타낸 바와 같이, 액션 날짜(또는 액션 들 날짜)가 요청 사양에 추가로 또는 대안으로 포함될 수 있다. 요청 사양에 추가적으로 포함될 경우, 다수의 액션 날짜들 중 어느 날짜가 우선하는지 결정하도록 규정된 규칙이 적용될 수 있다. 또는 다수의 액션 날짜들 이 요청 사양에 포함되는지, 아니면 외부에 위치하는지에 따라 다른 결과들을 가질 수 있다. 요청 검증 서버에 의한 예시적인 처리는 요청 검증 서버 아래에 나타난 흐름도에 표현된다. 예 시적인 실시형태들에 따르면, 요청 검증 서버는, 요구되는 최소 수의 서명된 HASH들을 수신했는지의 여부 를 결정할 수 있다. 위에서 설명한 바와 같이, 최소 수의 서명된 HASH들을 포함하는 것을 요구하면 신뢰 검증 자들의 성공적인 해킹이나 부정 행위의 가능성을 크게 줄일 수 있다. 도시한 바와 같이, 최소 수 요구 사항이 만족되지 않으면, 요청이 \"잘못\"된 것으로 간주되어 처리가 중단될 수 있다. 그렇지 않으면, 처리가 계속된다. 예시적인 실시형태들에 따르면, 최소 수 요구 사항이 충족되면(만족되면), 요청 검증 서버는 신뢰 검증자 들 각각의 공개 키(요청 검증 서버가 알고 있고/있거나 요청 검증 서버가 이용 가능한 것으로 상정됨)를 사용하여 각 서명된 HASH를 해독할 수 있다. 도 6 및 도 7a에 나타난 예에서, 해독된 HASH들은 다음과 같이 표현된다. HASHA=Decrypt[A-Signed(HASH),A-Key] HASHB=Decrypt[B-Signed(HASH),B-Key] HASHC=Decrypt[C-Signed(HASH),C-Key], 여기서 A-Key는 신뢰 검증자 A(612-A)의 공개 키이고, 신뢰 검증자 B 및 C(612-B 및 612-C)에 대해서도 마찬가 지이다. 세로 생략 부호는 수행될 수 있는 추가적인 서명된 HASH들의 유사한 해독들을 나타낸다. 예시적인 실시형태들에 따르면, 요청 검증 서버는 다음으로 모든 해독된 HASH들이 동일한지 확인하도록 테 스트할 수 있다. 즉, 체크는 다음과 같다. HASHA=HASHB=HASHC 모든 HASH들이 동일함을 요구하면 임의의 신뢰 검증자들의 성공적 해킹 또는 부정 행위의 가능성이 더 줄어든다. 이는, 모든 신뢰 검증자들보다 임의의 적은 수에 의해 제공되는 HASH를 성공적으로 해킹하면 이 테 스트가 실패하여 해킹을 노출시키게 되기 때문이다. 모든 신뢰 검증자들의 동일한 해킹만이 테스트를 통과할 수 있다. 그러나, 언급한 바와 같이, 최소 수 요구 사항은 사실상 불가능하지는 않더라도 이를 극히 가능하지 않게 만드는 데 도움이 된다. 도시된 바와 같이, 동일한 HASH 테스트가 실패하면, 요청은 \"잘못\"으로 간주되어 처리가 중단될 수 있다. 그렇지 않을 경우는, 처리가 계속된다. 추가 예시적인 실시형태들에 따르면, 동일 HASH 테스트가 통과될 경우(즉, 모든 해독된 HASH들이 동일한 경우), 요청 검증 서버는 각각의 동일한 해독된 값을 HASH의 참 값으로 취할 수 있다. 따라서, 요청 검증 서버 는 HASHA(또는 동등하게, HASHB또는 HASHC 등)의 값을 예를 들면 \"HASHis\"라는 변수에 할당할 수 있다. 예시적인 실시형태들에 따르면, 요청 검증 서버는 다음으로 HASH의 \"로컬\" 값을 결정하도록 HASH + 요청 사양(603-A)의 요청 사양에 적용되는 단방향 해시 함수의 그 자신의 계산을 수행할 수 있다. 이 계산은 위에서 설명한 바와 같이 오프체인 요청을 시작한 오프체인 요청 애플리케이션에 의해 수행된 것과 동일한 것이다. 계산은 지정된 복잡성 레벨을 만족하는 임의의 표준 및/또는 알려진 단방향 해시 함수를 활용할 수 있 다. 이러한 단방향 해시 함수들의 비제한적인 예들은 SHA-256, SHA-512, RIPEMD-320, 및 Whirlpool을 포함한 다. 흐름도에 나타난 바와 같이, 로컬 HASH는 \"ThisHASH\"라 지칭된다. 추가 예시적인 실시형태에 따르면, 요청 검증 서버는 ThisHASH가 HASHis와 동일하다는 것을 테스트할 수 있다. 즉, 로컬 계산된 HASH는 모든 신뢰 검증자들에 의해 독립적으로 제공되는 HASH와 동일하다. ThisHASH는 요청 사양으로부터 검증 가능하게 도출되고 각 신뢰 검증자로부터의 HASH와 합치하므로, 이 테스트의 성공적인 결과는 이제 요청 사양을 유효성확인한다. 도시한 바와 같이, ThisHASH가 HASHis와 동일하지 않으면, 요청은 \"잘못\"으로 간주되어 처리가 중단될 수 있다. 그렇지 않을 경우는, 처리가 계속된다. 마지막으로, ThisHASH가 HASHis와 동일한 것으로 확인되면, 요청 검증 서버는 검증된 HASH를 검증된 요청 데이터베이스에 저장할 수 있다. 2. 블록체인에서의 스마트 계약에 대한 예시적인 엔트리 레벨 시나리오 예시적인 스마트 계약 시나리오에서, 비상 액션들이 검증된 요청 데이터베이스에 저장되거나 다른 방식으로 계 약에 제공되는 트리거 코드들에 의해 트리거될 수 있도록, 스마트 계약이 구성될 수 있다. 이전 스마트 계약의 당사자들은 각각 다시 블록체인 사용자들일 수 있고, 지정된 신뢰 오프체인 기관은 다시 개별 판사로 대표되는 사법 법원일 수 있다. 시스템 레벨 예에서와 같이, 당사자들은 \"사용자 A\" 및 \"사용자 B\"일 수 있고, 이전 스 마트 계약은 사용자 A가 사용자 B에게 서비스를 제공하는 합의, 및 서비스 제공 시 사용자 B가 사용자 A에게 화 폐를 이전하는 합의를 적용할 수 있는 간단한 예를 고려한다. 스마트 계약의 제1 비상 액션은 A가 서비스를 완 료했다는 통지일 수 있고, 제2 비상 액션은 B로부터 A로의 자금의 이전일 수 있다. 제1 비상 액션의 지정된 호 출자는 A일 수 있고, 제2 비상 액션의 지정된 호출자는 B일 수 있다. 일례에서, A가 서비스 완료 액션을 호출 한 후, B는 지불 액션의 호출을 거부하여 A에게 서비스에 대해 지불하는 것을 거부할 수 있다. 그러면, 사용자 A 또는 사용자 A의 법적 대리인(예를 들면, 변호사)은, 사용자 B가 제2 비상 액션을 실행하게 하도록, 법원이 승인된 에일리어스로서 활동하는 것을 요청할 수 있다. 예시적인 트랜잭션 시나리오에 대해 더 구체적으로 말하면, 요청 액션 입력은 스마트 계약에 대한 링크, 요청된 비상 액션의 식별뿐만 아니라 필요할 수 있는 비상 액션의 임의의 파라미터들을 포함할 수 있다. 도 6 과 관련하여 위에서 설명한 트랜잭션 시나리오의 모든 동작들은 스마트 계약 시나리오에도 적용될 수 있다. 요 청 액션 입력 외에도, 주요 차이점은 요청 사양의 콘텐츠(및 가능한 포맷), 집행 액션 사양, 및 호출될 수 있는 비상 액션들의 보다 일반적인 콘텐츠(예를 들면, 금액 또는 사실 발견에 대한 변수)와 관련된다. 이 예시적인 스마트 계약 시나리오에서, 법원은 스마트 계약의 지불 비상 액션을 강제하는 명령을 발부하라고 요청받을 것이다. 법원이 동의한다고 상정하면, 트랜잭션 시나리오에 대해 위에서 설명한 검증 절차가 동일한 방식으로 수행될 것이다. 검증된 HASH는 요청된 비상 액션에 대한 트리거일 것이다. 도 6의 오른쪽 상단 의 박스에 나타난 예시적인 후속 액션은 스마트 계약 시나리오에서도 적용된다. 도 7b는 예시적인 실시형태들에 따른 트랜잭션 시나리오에 대한 엔트리 레벨 액션 엔트리의 요청 검증 서버 의 예시적인 처리의 표현을 나타낸다. 도 7a의 논의는, 사양 요청이 상이한 정보를 제공한다는 점을 제외 하고, 도 7b에 동일하게 적용된다. 특히 HASH + 사양 요청(603-B)에서, 예시적인 스마트 계약 시나리오에 대한 요청 사양은 스마트 계약에 대한 링크, 비상 액션의 식별, 및 (가능하게는 선택적으로) 비상 액션의 파라미터들 을 포함하는 것으로 나타난다. 예를 들면, 스마트 계약의 하나 이상의 다른 당사자들의 식별과 같은 다른 정보 도 포함될 수 있다. 자산 소유자의 아이덴티티와 소유자뿐만 아니라 수신자의 자산(들)에 적용될 액션의 설명 은, 액션이 소유자로부터 수신자로의 이전일 경우, 선택적으로 제공될 수 있다. 3. 예시적인 변형들 엔트리 레벨 실시형태들을 구현하는데 다수의 추가적인 및/또는 대안적인 양태들이 있을 수 있다. 대부분은 시 스템 레벨 실시형태와 동일하므로, 여기서는 다시 반복하지 않는다. 도 6, 도 7a, 및 도 7b에 예시된 동작들 및 절차들은 위에서 설명한 예시적인 변형들에 대한 임의의 하나 이상 에 대응하도록 간단하게 수정, 적응, 및/또는 확장될 수 있음이 이해될 것이다. 즉, 도 6, 도 7a, 및 도 7b의 특정 형태 및 내용은 엔트리 레벨 실시형태의 동작의 단지 일례에 적용되고, 다른 가능한 실시형태들에 대해 제 한하고자 하는 것은 아니다. B. 예시적인 동작들 엔트리 레벨 구현의 예시적인 동작들은 메시지 흐름도로 예시될 수 있다. 엔트리 레벨 구현을 위한 예시적인 메시지 흐름도가 도 8에 나타나 있다. 포맷은 일부 컴포넌트들이 다른 점을 제외하고 도 5와 관련하여 설명한 것과 동일하다. 도 6의 각 컴포넌트는 도 8의 상단에 라벨이 부여된 박스로 표현된다. 도 5에서와 같이, 수직 타임라인은 각 컴포넌트 아래로 확장되고 시간이 아래쪽으로 증가한다. 타임라인들은 정확한 타이밍을 전달하거나 표현하기 위한 것이 아니라 동작들의 순서나 시퀀스를 나타내고자 하는 것이다. 동작들은 컴포넌트 쌍 사이에 수평 방향 화살표들로서 표시되고, \"T<n>\"이라는 라벨이 부여되고 그 뒤로 컴포넌트들 간에 전달되는 정보의 설명이 이어 진다(여기서 <n>은 숫자 라벨임). 일부 동작들은, 반드시 다른 컴포넌트에 정보를 전달하는 것을 수반하지 않 고, 하나의 컴포넌트에서 수행되는 동작들에 대해 자신 방향의 화살표로 나타난다. 도 8에 나타난 특정 시퀀스 들은 동작 흐름의 일례를 나타내고, 동일한 결과들을 달성할 수 있는 다른 시퀀스들 또는 시퀀스 순서들을 제한 하거나 배제하는 것으로 간주되어서는 안 됨을 이해해야 한다. 예시적인 사용 시나리오는, 사용자가 도 6의 요청 액션 입력과 같은 입력을 오프체인 요청 애플리케이션 에 제공하는 것으로 시작될 수 있다(UI(304-I/F)는 명확성을 위해 도 8에서는 생략되었음). 단계 T1에서, 오프체인 요청 애플리케이션은 HASH + 요청 사양을 생성하고, 단계 T2에서, HASH + 요청 사양을 오프체인 신뢰 기관 서버에 송신(예를 들면, 전송 또는 제공)한다. 요청이 승인되었다고 상정하면(예를 들면, 판사 에 의한 평가 후; 이 액션을 도면에는 명시적으로 나타내지는 않음), 오프체인 신뢰 기관 서버는 단계 T3 에서 HASH + 집행 액션 사양을 공개 집행 액션 서버에 게시 또는 공개할 수 있다. 단계 T4에서, 오프체인 신뢰 기관 서버는 오프체인 요청 애플리케이션에 확인 ID를 송신 또는 제공할 수 있다. 그러면 오프체인 요청 애플리케이션은 단계 T5에서 HASH + 요청 사양을 요청 검증 서버에 송신(또는 제공)하고, 단계 T6에서 이벤트 감시자에게 확인 ID를 송신(또는 제공)할 수 있다. 확인 ID를 수신한 것에 응답하여, 이벤트 감시자는 단계들 T7-A, T7-B, 및 T7-C에서 각 신뢰 검증자 A, B, C(612-A, 612-B, 및 612-C)에게 각각 통지할 수 있다. 각 통지는 또한 확인 ID, 또는 공개 집행 액션 서버 로부터 정보를 검색하는 데 적합한 일부 다른 식별자를 포함할 수 있다(또는 그 자체일 수 있다).단계 T8-A, T8-B, 및 T8-C에서, 신뢰 검증자들 A, B, 및 C는 별개로 및 독립적으로 공개 집행 액션 서버와 상호 작용하여, 별개로 및 독립적으로 HASH를 검색한다. 이 상호 작용들의 이중 화살표들은 이 검색 프로세스 와 관련된 가능한 양방향 통신을 표현한다. 단계 T9-A에서, 신뢰 검증자 A는 자신의 개인 키로 HASH에 서명하고, 단계 T10-A에서, A-signed(HASH)를 기록 또는 저장을 위해 요청 검증 데이터베이스에 송신(제공)한다. 마찬가지로, 단계 T9-B에서, 신뢰 검증자 B 는 자신의 개인 키로 HASH에 서명하고, 단계 T10-B에서, B-signed(HASH)를 기록 또는 저장을 위해 요청 검증 서 버에 송신(제공)하고; 단계 T9-C에서, 신뢰 검증자 C는 자신의 개인 키로 HASH에 서명하고, 단계 T10-C에 서, C-signed(HASH)를 기록 또는 저장을 위해 요청 검증 서버에 송신(제공)한다. 신뢰 검증자들이 독립적 으로 활동하므로, 나타낸 시퀀스 순서는 단지 하나의 가능한 예라고 간주되어야 한다. 처리 로직의 관점에서, 단계 T9-<A,B,C>에서 HASH의 암호화 서명이 단계 T10-<A,B,C>에서 서명된 HASH를 요청 검증 서버에 송신 하는 것에 선행하는 것만이 필요할 수 있다. 단계 T11에서, 요청 검증 서버는 위에서 설명한 바와 같이 HASH를 검증할 수 있다. 단계 T12에서, 요청 검증 서버는 검증된 HASH를 검증된 트리거 코드로서 검증된 요청 데이터베이스에 저장할 수 있다. 예시적인 후속 시나리오가 도 8의 오른쪽 하단의 점선 박스에 나타나 있다. 나타난 바와 같이, 입력된 HASH + 요청 액션은 단계 T13에서 블록체인 네트워크에 입력된다. 이는, 사용자 또는 사용자의 법적 대리인이 검 증된 요청 데이터베이스에서의 트리거 코드의 존재 및 이용 가능성을 알리는 엔트리를 블록체인에 제출하 는 것을 나타낼 수 있다. 이어서 단계 T14에서, 블록체인의 하나 이상의 노드들이 트리거 코드(이 예에서는 검 증된 HASH)를 풀링해서 위에서 설명한 바와 같이 그것에 작업을 행한다. 도 6, 도 7a, 및 도 7b와 마찬가지로, 도 8은 위에서 설명한 예시적인 변형에 대한 어느 하나 이상에 대응하도 록 수정, 적응, 및/또는 확장될 수 있다. 즉, 도 8의 특정 형태 및 내용은 엔트리 레벨 실시형태의 동작의 단 지 일례에 적용되고 있다. 그러나, 도 8의 특정 형태 및 내용을 다른 가능한 실시형태에 대해 제한하고자 하는 것은 아니다. V. 예시적인 방법들 A. 예시적인 시스템 레벨 방법들 도 9 및 도 10은 예시적인 시스템 레벨 실시형태의 각각의 예시적인 방법들(900 및 1000)을 나타내는 흐름도이 다. 도 9 및 도 10에 의해 나타난 방법은 모두 블록체인을 운영하는 노드들의 네트워크의 노드로서 동작하기 위해 구성되는 컴퓨팅 시스템 또는 컴퓨팅 장치에 의해 수행될 수 있다. 컴퓨팅 시스템 또는 컴퓨팅 장치의 비 제한적인 예는, 예를 들면 컴퓨팅 장치 또는 서버 클러스터를 포함한다. 그러나, 이 방법은 다른 유 형의 장치들 또는 장치 서브시스템들에 의해 수행될 수 있다. 예를 들면, 프로세스는 랩톱 또는 태블릿 장치와 같은 휴대용 컴퓨터에 의해 수행될 수 있다. 방법들(900 및 1000)의 실시형태들은 거기에 나타난 특징부들 중 어느 하나 이상을 제거함으로써 단순화될 수 있다. 또한, 이 실시형태들은 이전 도면들 중의 임의의 것의 특징부들, 양태들, 및/또는 구현들 또는 본원에서 달리 설명되는 것과 결합될 수 있다. 예시적인 방법들(900 및 1000)은 또한 시스템이나 가상 머신 또는 컨테이너의 하나 이상의 서버 장치의 하나 이 상의 프로세서에 의해 실행 가능한 명령어들로서 구현될 수 있다. 예를 들면, 명령어들은 소프트웨어 및/또는 하드웨어 및/또는 펌웨어 명령어들의 형태를 취할 수 있다. 예시적인 실시형태에서, 명령어들은 비일시적인 컴 퓨터 판독 가능한 매체에 저장될 수 있다. 하나 이상의 서버의 하나 이상의 프로세서에 의한 실행 시, 명령어 들은 하나 이상의 서버로 하여금 예시적인 방법의 다양한 동작들을 수행하게 할 수 있다. 시스템 레벨 실시형태의 트랜잭션 시나리오에 관한 예시적인 방법이 먼저 설명된다. 예시적인 방법의 블록은 블록체인에 엔트리를 배치하기 위한 요청 메시지를 수신하는 것을 포함할 수 있다. 예를 들면, 요청 메시지는 UI(304-I/F)에서 수신될 수 있다. 요청 메시지는, (i) 액션 및 액션의 대상 이 되는 적어도 하나의 당사자의 아이덴티티를 포함하는 엔트리에 대한 요청 사양, (ii) 엔트리가 신뢰 엔티티 에 의해 승인되었음을 지정하는 인디케이터, 및 (iii) 대응하는 복수의 신뢰 검증자들에 의해 생성된 복수의 암 호화 검증 코드들을 포함할 수 있다. 각 암호화 검증 코드는 신뢰 엔티티에 의해 제공되고 신뢰 검증자들의 각 각에 의해 암호화 방식으로 서명된 인코딩된 액션 페이로드를 포함할 수 있다. 일부 예들에서, 적어도 하나의 당사자의 실제 아이덴티티는 알려져 있지 않을 수 있다. 대신, 예를 들면 주소 또는 암호화 키 등 당사자에 대한 일부 다른 형태의 링크가 이용 가능할 수 있다. 이들은 실제 아이덴티티를 대신하여 사용될 수 있다. 예시적인 방법의 블록은, 대응하는 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적용 하여 대응하는 인코딩된 액션 페이로드를 해독하는 것을 포함할 수 있다. 예시적인 방법의 블록은 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 것을 포함할 수 있다. 마지막으로, 예시적인 방법의 블록은 적어도 제1 검증을 수행하는 것에 응답하여 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 것을 포함할 수 있다. 예시적인 실시형태들에 따르면, 예시적인 방법은 요청 사양에 페이로드 인코더 함수를 적용하여 로컬 버전 의 인코딩된 액션 페이로드를 도출하고, 이어서 로컬 버전의 인코딩된 액션 페이로드가, 동일한 적어도 임계 수 의 해독된 대응하는 인코딩된 액션 페이로드들의 각각의 것과 동일하다는 제2 검증을 수행하는 것을 더 포함할 수 있다. 이 배치에서, 블록 처리를 위한 엔트리를 제출하는 것은 제1 검증과 제2 검증 모두를 수행하는 것에 응답하여 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 것을 수반할 수 있다. 예시적인 실시형태들에 따르면, 임계 수는 복수의 총 수, 복수의 총 수의 다수, 또는 복수의 총 수의 지정된 분 율에 가장 가까운 정수일 수 있다. 예시적인 실시형태들에 따르면, 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 것은 비교를 위해 미리 결정된 수의 해독된 대응하는 인코딩된 액션 페이로드들을 선택하는 것 을 수반할 수 있다. 또한, 임계 수는 미리 결정된 수와 동일할 수 있다. 이 배치로, 선택은 무작위 중 하나일 수 있고/있거나 대응하는 복수의 신뢰 검증자들 중의 특정 검증자들의 규정된 아이덴티티들에 기초할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는 해시일 수 있고, 페이 로드 인코더 함수는 해시 함수일 수 있다. 이 배치에서, 각각의 대응하는 인코딩된 액션 페이로드는 대응하는 해시값일 수 있고, 로컬 버전의 인코딩된 액션 페이로드는 로컬 해시값일 수 있다. 또한, 이 배치에서, 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 것은 적어도 임계 수 의 대응하는 해시값들이 동일하다는 것을 검증하는 것을 포함하고, 로컬 버전의 인코딩된 액션 페이로드가, 동 일한 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들의 각각의 것과 동일하다는 제2 검증을 수행 하는 것은 로컬 해시값이, 동일한 적어도 임계 수의 대응하는 해시값들과 동일하다는 것을 검증하는 것을 포함 할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는, 신뢰 엔티티에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는, 요청 사양의 자연어 디스크립션에 기초하여 인공 지능 엔진에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함할 수 있다. 예시적인 실시형태들에 따르면, 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 것은 채굴 절차에 입력 되는 엔트리를 후보 블록에 포함시키는 것을 포함할 수 있다. 예시적인 실시형태들에 따르면, 적어도 하나의 당사자는 블록체인에 기록된 특정 디지털 자산들과 연관될 수 있 다. 액션은, 특정 디지털 자산들의 지정된 금액을 적어도 하나의 당사자로부터 블록체인과 연관된 다른 당사자 에게 이전하는 것; 특정 디지털 자산들의 지정된 금액을 동결하는 단계; 특정 디지털 자산들의 특정 금액을 동 결 해제하는 것; 특정 디지털 자산들의 지정된 금액을 적어도 하나의 당사자로부터 블록체인과 연관된 에스크로 계정으로 이전하는 것; 및/또는 특정 디지털 자산들의 지정된 금액을 적어도 하나의 당사자로부터 블록체인과 연관된 특정 계정으로 이전하는 것일 수 있다. 예시적인 실시형태들에 따르면, 액션의 실행은 지정된 날짜 및 시간으로부터 지정된 시간량만큼 지연되거나 특 정 날짜 및 시간으로 스케줄링될 수 있다. 시스템 레벨 실시형태의 스마트 계약 시나리오에 관한 예시적인 방법이 다음으로 설명된다. 예시적인 방법의 블록은 블록체인에 이전에 입력된 스마트 계약의 비상 액션을 호출하기 위해 구성 되는 블록체인에 엔트리를 배치하기 위한 요청 메시지를 수신하는 것을 포함할 수 있다. 예를 들면, 요청 메시 지는 UI(304-I/F)에서 수신될 수 있다. 요청 메시지는, (i) 스마트 계약에 대한 링크, 비상 액션의 식별자, 및비상 액션을 호출하도록 승인된 지정된 액션 호출자의 아이덴티티를 포함하는 요청 사양, (ii) 엔트리가 신뢰 엔티티에 의해 승인되었음을 지정하는 인디케이터, 및 (iii) 대응하는 복수의 신뢰 검증자들에 의해 생성된 복 수의 암호화 검증 코드들을 포함할 수 있다. 각 암호화 검증 코드는, 신뢰 엔티티에 의해 제공되고 신뢰 검증 자들의 각각에 의해 암호화 방식으로 서명된 인코딩된 액션 페이로드를 포함할 수 있다. 스마트 계약에 대한 링크에 대한 비제한적인 예는 위치에 대한 주소(예를 들면, URL), 데이터베이스 엔트리에 대한 포인터, 및 블록 체인 상의 주소를 포함한다. 일부 예들에서, 지정된 액션 호출자의 실제 아이덴티티는 알려져 있지 않을 수 있 다. 대신, 예를 들면 주소나 암호화 키 등 지정된 액션 호출자에 대한 일부 다른 형태의 링크가 이용 가능할 수 있다. 이들은 실제 아이덴티티를 대신하여 사용될 수 있다. 일부 예들에서, 지정된 액션 호출자의 아이덴 티티는 생략될 수 있다. 예시적인 방법의 블록은, 대응하는 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적 용하여 대응하는 인코딩된 액션 페이로드를 해독하는 것을 포함할 수 있다. 예시적인 방법의 블록은 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다 는 제1 검증을 수행하는 것을 포함할 수 있다. 예시적인 방법의 블록은 적어도 제1 검증을 수행하는 것에 응답하여 트랜잭션 사양을 생성하고 이 를 엔트리에 배치하는 것을 포함할 수 있다. 생성된 트랜잭션 사양은 지정된 액션 호출자의 인증된 에일리어스 로서 활동하는 신뢰 엔티티에 의해 승인된 식별된 비상 액션을 실행하라는 지시문을 포함할 수 있다. 마지막으로, 예시적인 방법의 블록은 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 것을 포함할 수 있다. 예시적인 실시형태들에 따르면, 예시적인 방법은 요청 사양에 페이로드 인코더 함수를 적용하여 로컬 버 전의 인코딩된 액션 페이로드를 도출하는 것, 및 이어서 로컬 버전의 인코딩된 액션 페이로드가, 동일한 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들의 각각의 것과 동일하다는 제2 검증을 수행하는 것을 더 포함할 수 있다. 이 배치에서, 트랜잭션 사양을 생성하고 이를 엔트리에 배치하는 것은 트랜잭션 사양을 생성 하고 제1 검증과 제2 검증 모두를 수행하는 것에 응답하여 이를 엔트리에 배치하는 것을 수반할 수 있다. 예시적인 실시형태들에 따르면, 예시적인 방법은 블록체인에 이전에 입력된 스마트 계약의 식별된 비상 액션이 실행되게 하는 것을 더 포함할 수 있다. 예시적인 실시형태들에 따르면, 요청 사양은 식별된 비상 액션의 하나 이상의 파라미터들을 더 포함할 수 있다. 예시적인 실시형태들에 따르면, 임계 수는 복수의 총 수, 복수의 총 수의 다수, 또는 복수의 총 수의 지정된 분 율에 가장 가까운 정수일 수 있다. 예시적인 실시형태들에 따르면, 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 것은 비교를 위해 미리 결정된 수의 해독된 대응하는 인코딩된 액션 페이로드들을 선택하는 것 을 수반할 수 있다. 또한, 임계 수는 미리 결정된 수와 동일할 수 있다. 이러한 배치로, 선택은 무작위 중 하 나일 수 있고/있거나 대응하는 복수의 신뢰 검증자들 중의 특정 검증자들의 규정된 아이덴티티들에 기초할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는 해시일 수 있고, 페이 로드 인코더 함수는 해시 함수일 수 있다. 이 배치에서, 각각의 대응하는 인코딩된 액션 페이로드는 대응하는 해시값일 수 있고, 로컬 버전의 인코딩된 액션 페이로드는 로컬 해시값일 수 있다. 또한, 이 배치에서, 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 것은 적어도 임계 수 의 대응하는 해시값들이 동일하다는 것을 검증하는 것을 포함하고, 로컬 버전의 인코딩된 액션 페이로드가, 동 일한 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들의 각각의 것과 동일하다는 제2 검증을 수행 하는 것은, 동일한 적어도 임계 수의 대응하는 해시값들과 동일하다는 것을 검증하는 것을 포함할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는, 신뢰 엔티티에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 인코딩된 액션 페이로드는, 요청 사양의 자연어 디스크립션에 기초하여 인공 지능 엔진에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함할 수 있다.예시적인 실시형태들에 따르면, 블록체인에 추가될 블록 처리를 위한 엔트리를 제출하는 것은 채굴 절차에 입력 되는 엔트리를 후보 블록에 포함시키는 것을 포함할 수 있다. 예시적인 실시형태들에 따르면, 블록체인에 이전에 입력된 스마트 계약의 식별된 비상 액션이 실행되게 하는 것 은 실행이 지정된 날짜 및 시간으로부터 지정된 시간량만큼 지연되거나 특정 날짜 및 시간으로 스케줄링되는 것 을 수반할 수 있다. B. 예시적인 엔트리 레벨 방법들 도 11 및 도 12는 예시적인 엔트리 레벨 실시형태의 방법들(1100 및 1200)의 각각의 예시적인 실시형태를 나타 내는 흐름도이다. 도 11 및 12에 의해 설명된 방법들은 모두 블록체인 네트워크에 입력되는 디지털 자산들에 대한 인코딩된 액션 트리거들을 검증하고 저장하기 위한 데이터베이스 서버로서 동작하기 위해 구성되는 컴퓨팅 시스템 또는 컴퓨팅 장치에 의해 수행될 수 있다. 컴퓨팅 시스템 또는 컴퓨팅 장치의 비제한적인 예들은, 예를 들면 컴퓨팅 장치 또는 서버 클러스터를 포함한다. 그러나, 이 방법은 다른 유형의 장치들 또는 장 치 서브시스템들에 의해 수행될 수 있다. 예를 들면, 프로세스는 랩톱 또는 태블릿 장치와 같은 휴대용 컴퓨터 에 의해 수행될 수 있다. 방법(1100 및 1200)의 실시형태들은 여기에 나타난 특징부들 중 어느 하나 이상을 제거함으로써 단순화될 수 있 다. 또한, 이 실시형태들은 이전 도면들 중의 임의의 것의 특징부들, 양태들, 및/또는 구현들 또는 본원에서 달리 설명되는 것과 결합될 수 있다. 예시적인 방법들(1100 및 1200)은 또한 시스템이나 가상 머신 또는 컨테이너의 하나 이상의 서버 장치의 하나 이상의 프로세서에 의해 실행 가능한 명령어들로서 구현될 수 있다. 예를 들면, 명령어들은 소프트웨어 및/또 는 하드웨어 및/또는 펌웨어 명령어들의 형태를 취할 수 있다. 예시적인 실시형태에서, 명령어들은 비일시적인 컴퓨터 판독 가능한 매체에 저장될 수 있다. 하나 이상의 서버들의 하나 이상의 프로세서들에 의한 실행 시, 명령어들은 하나 이상의 서버로 하여금 예시적인 방법의 다양한 동작들을 수행하게 할 수 있다. 엔트리 레벨 실시형태의 트랜잭션 시나리오에 관한 예시적인 방법이 먼저 설명된다. 예시적인 방법의 블록은 블록체인 네트워크에 입력되는 디지털 트랜잭션에 대한 검증 액션 트리거 를 검증하고 저장하기 위한 요청 메시지를 수신하는 것을 포함할 수 있다. 요청은 액션 및 액션의 대상이 되는 디지털 자산과 연관된 적어도 하나의 당사자의 아이덴티티를 포함하는 요청 사양을 포함하는 요청 메시지를 포 함할 수 있다. 스마트 계약에 대한 링크에 대한 비제한적인 예는 위치에 대한 주소(예를 들면, URL), 데이터베 이스 엔트리에 대한 포인터, 및 블록체인 상의 주소를 포함한다. 일부 예들에서, 적어도 하나의 당사자의 실제 아이덴티티는 알려져 있지 않을 수 있다. 대신, 예를 들면 주소나 암호화 키 등 당사자에 대한 일부 다른 형태 의 링크가 이용 가능할 수 있다. 이들은 실제 아이덴티티를 대신하여 사용될 수 있다. 예시적인 방법의 블록은 대응하는 복수의 신뢰 검증자들에 의해 독립적으로 생성된 복수의 암호화 검증 코드들을 수신하는 것을 포함할 수 있다. 각각의 암호화 검증 코드는 신뢰 엔티티로부터 소싱(sourcing) 되고 신뢰 검증자들의 각각에 의해 암호화 방식으로 서명된 트리거 코드를 포함할 수 있다. 예시적인 방법의 블록은, 대응하는 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적 용하여 대응하는 트리거 코드를 해독하는 것을 포함할 수 있다. 예시적인 방법의 블록은 적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증 을 수행하는 것을 포함할 수 있다. 예시적인 방법의 블록은 요청 사양에 인코더 함수를 적용하여 액션과 연관된 로컬 버전의 트리거 코드를 도출하는 것을 포함할 수 있다. 예시적인 방법의 블록은 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트 리거 코드들의 각각의 것과 동일하다는 제2 검증을 수행하는 것을 포함할 수 있다. 마지막으로, 예시적인 방법의 블록은 트리거 코드를 컴퓨팅 시스템과 연관된 데이터베이스에 검증 액션 트리거로서 저장하는 것을 포함할 수 있다. 예시적인 실시형태들에 따르면, 임계 수는 복수의 총 수, 복수의 총 수의 다수, 또는 복수의 총 수의 지정된 분 율에 가장 가까운 정수일 수 있다.예시적인 실시형태들에 따르면, 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 것은 비교를 위해 미리 결정된 수의 해독된 대응하는 인코딩된 액션 페이로드들을 선택하는 것 을 수반할 수 있다. 또한, 임계 수는 미리 결정된 수와 동일할 수 있다. 이러한 배치로, 선택은 무작위 중 하 나일 수 있고/있거나 대응하는 복수의 신뢰 검증자들 중의 특정 검증자들의 규정된 아이덴티티들에 기초할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 트리거 코드는 해시일 수 있고, 인코더 함수는 해 시 함수일 수 있다. 이 배치에서, 각각의 대응하는 트리거 코드는 대응하는 해시값일 수 있고, 로컬 버전의 트 리거 코드는 로컬 해시값일 수 있다. 또한 이 배치에서, 적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증을 수행하는 것은 적어도 임계 수의 대응하는 해시값들이 동일하다는 것을 검증하는 것을 포함할 수 있고, 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트리거 코드들의 각각 의 것과 동일하다는 제2 검증을 수행하는 것은 로컬 해시값이, 동일한 적어도 임계 수의 대응하는 해시값들과 동일하다는 것을 검증하는 것을 포함할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 트리거 코드는, 신뢰 엔티티에 의해 생성되고 컴 퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 트리거 코드는, 요청 사양의 자연어 디스크립션에 기초하여 인공 지능 엔진에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함 할 수 있다. 예시적인 실시형태들에 따르면, 적어도 하나의 당사자는 블록체인에 기록된 특정 디지털 자산들과 연관될 수 있 다. 액션은, 디지털 자산의 지정된 금액을 적어도 하나의 당사자로부터 블록체인과 연관된 다른 당사자에게 이 전하는 것; 디지털 자산의 지정된 금액을 동결하는 단계; 디지털 자산의 특정 금액을 동결 해제하는 것; 디지털 자산의 지정된 금액을 적어도 하나의 당사자로부터 블록체인과 연관된 에스크로 계정으로 이전하는 것; 및/또는 디지털 자산의 지정된 금액을 적어도 하나의 당사자로부터 블록체인과 연관된 특정 계정으로 이전하는 것일 수 있다. 실시형태들에 따르면, 액션의 실행은 지정된 날짜 및 시간으로부터 지정된 시간량만큼 지연되거나 특정 날짜 및 시간으로 스케줄링될 수 있다. 예시적인 실시형태들에 따르면, 예시적인 방법은 블록체인 네트워크의 노드 장치로부터 요청을 수신하는 것에 응답하여 검증된 트리거 코드의 사본을 노드 장치에 송신하는 것을 더 포함할 수 있다. 엔트리 레벨 실시형태의 스마트 계약 시나리오에 관한 예시적인 방법은 다음으로 설명된다. 예시적인 방법의 블록은 블록체인 네트워크에 입력되는 스마트 계약에 대한 검증 액션 트리거를 검 증하고 저장하기 위한 요청 메시지를 수신하는 것을 포함할 수 있다. 요청 메시지는 스마트 계약에 대한 링크 및 스마트 계약의 비상 액션의 식별자를 포함하는 요청 사양을 포함할 수 있다. 스마트 계약에 대한 링크에 대 한 비제한적인 예는 위치에 대한 주소(예를 들면, URL), 데이터베이스 엔트리에 대한 포인터, 및 블록체인 상의 주소를 포함한다. 예시적인 방법의 블록은 대응하는 복수의 신뢰 검증자들에 의해 독립적으로 생성된 복수의 암호화 검증 코드들을 수신하는 것을 포함할 수 있다. 각각의 암호화 검증 코드는 신뢰 엔티티로부터 소싱되고 신뢰 검증자들의 각각에 의해 암호화 방식으로 서명된 트리거 코드를 포함할 수 있다. 예시적인 방법의 블록은 대응하는 암호화 검증 코드에 각각의 신뢰 검증자의 공개 암호화 키를 적 용하여 대응하는 트리거 코드를 해독하는 것을 포함할 수 있다. 예시적인 방법의 블록은 적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증 을 수행하는 것을 포함할 수 있다. 예시적인 방법의 블록은 요청 사양에 인코더 함수를 적용하여 비상 액션과 연관된 로컬 버전의 트 리거 코드를 도출하는 것을 포함할 수 있다. 예시적인 방법의 블록은 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트 리거 코드들의 각각의 것과 동일하다는 제2 검증을 수행하는 것을 포함할 수 있다. 마지막으로, 예시적인 방법의 블록은 트리거 코드를 컴퓨팅 시스템과 연관된 데이터베이스에 검증 액션 트리거로서 저장하는 것을 포함할 수 있다. 예시적인 실시형태들에 따르면, 임계 수는 복수의 총 수, 복수의 총 수의 다수, 또는 복수의 총 수의 지정된 분 율에 가장 가까운 정수일 수 있다. 예시적인 실시형태들에 따르면, 적어도 임계 수의 해독된 대응하는 인코딩된 액션 페이로드들이 동일하다는 제1 검증을 수행하는 것은 비교를 위해 미리 결정된 수의 해독된 대응하는 인코딩된 액션 페이로드들을 선택하는 것 을 수반할 수 있다. 또한, 임계 수는 미리 결정된 수와 동일할 수 있다. 이러한 배치로, 선택은 무작위 중 하 나일 수 있고/있거나 대응하는 복수의 신뢰 검증자들 중의 특정 검증자들의 규정된 아이덴티티들에 기초할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 트리거 코드는 해시일 수 있고, 인코더 함수는 해 시 함수일 수 있다. 이 배치에서, 각각의 대응하는 트리거 코드는 대응하는 해시값일 수 있고, 로컬 버전의 트 리거 코드는 로컬 해시값일 수 있다. 또한, 이 배치에서, 적어도 임계 수의 해독된 대응하는 트리거 코드들이 동일하다는 제1 검증을 수행하는 것은 적어도 임계 수의 대응하는 해시값들이 동일하다는 것을 검증하는 것을 포함할 수 있고, 로컬 버전의 트리거 코드가, 동일한 적어도 임계 수의 해독된 대응하는 트리거 코드들의 각각 의 것과 동일하다는 제2 검증을 수행하는 것은 로컬 해시값이, 동일한 적어도 임계 수의 대응하는 해시값들과 동일하다는 것을 검증하는 것을 포함할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 트리거 코드는, 신뢰 엔티티에 의해 생성되고 컴 퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함할 수 있다. 예시적인 실시형태들에 따르면, 신뢰 엔티티에 의해 제공되는 트리거 코드는, 요청 사양의 자연어 디스크립션에 기초하여 인공 지능 엔진에 의해 생성되고 컴퓨팅 장치에 의해 해석 가능한 요청 사양의 의미론적 표현을 포함 할 수 있다. 예시적인 실시형태들에 따르면, 액션의 실행은 지정된 날짜 및 시간으로부터 지정된 시간량만큼 지연되거나 특 정 날짜 및 시간으로 스케줄링될 수 있다. 예시적인 실시형태들에 따르면, 예시적인 방법은 블록체인 네트워크의 노드 장치로부터 요청을 수신하는 것에 응답하여 검증된 트리거 코드의 사본을 노드 장치에 송신하는 것을 더 포함할 수 있다. VI. 마무리 본 개시는, 다양한 양태들의 예시로서 의도되는 본 출원에서 설명된 특정 실시형태들의 관점으로 제한되지 않는 다. 당업자에게 명백한 바와 같이, 그 범위를 벗어나지 않고 많은 수정 및 변경이 이루어질 수 있다. 본원에 기술된 것 외에도 본 개시의 범위 내에서 기능적으로 동등한 방법들 및 장치들은 전술한 설명으로부터 당업자에 게 명백할 것이다. 이러한 수정 및 변형은 첨부된 특허청구범위의 범주 내에 속하는 것이다. 위의 상세한 설명은 첨부된 도면을 참조하여 개시된 시스템들, 장치들, 및 방법들의 다양한 특징부들 및 동작들 을 설명한다. 본원 및 도면에 설명된 예시적인 실시형태들은 제한을 의도하는 것은 아니다. 본원에서 제시된 요지의 범위에서 벗어나지 않고 다른 실시형태들이 활용될 수 있고 다른 변경들이 이루어질 수 있다. 본원에서 일반적으로 설명되고 도면에 나타난 본 개시의 양태들이 매우 다양한 서로 다른 구성들로 배치, 치환, 결합, 분 리, 및 설계될 수 있음이 쉽게 이해될 것이다. 도면에 있고 본원에서 설명된 메시지 흐름도들, 시나리오들, 및 흐름도들 중 일부 또는 전부와 관련하여, 각 단 계, 블록, 및/또는 통신은 예시적인 실시형태들에 따라 정보의 처리 및/또는 정보의 전송을 나타낼 수 있다. 대안적인 실시형태들은 이들 예시적인 실시형태들의 범위 내에 포함된다. 이 대안적인 실시형태들에서, 예를 들면 단계들, 블록들, 전송들, 통신, 요청들, 응답들, 및/또는 메시지들로서 설명된 동작들은 도시되거나 논의 된 순서와 다르게 실행될 수 있고, 이것에는 관련 기능에 따라 실질적으로 동시에 또는 역순이 포함된다. 또한, 더 많거나 적은 블록들 및/또는 동작들이 본원에서 논의된 임의의 메시지 흐름도들, 시나리오들, 및 흐름 도들과 함께 사용될 수 있고, 이 메시지 흐름도들, 시나리오들, 및 흐름도들은 부분적으로 또는 전체적으로 서 로 결합될 수 있다. 정보의 처리를 나타내는 단계 또는 블록은 본원에서 설명된 방법 또는 기술의 특정 로직 기능들을 수행하도록 구성될 수 있는 회로에 대응할 수 있다. 대안적으로 또는 추가적으로, 정보의 처리를 나타내는 단계 또는 블록 은 모듈, 세그먼트, 또는 프로그램 코드(관련 데이터를 포함함)의 일부에 대응할 수 있다. 프로그램 코드는 방 법 또는 기술에서 특정 로직 동작들 또는 액션들을 구현하기 위해 프로세서에 의해 실행 가능한 하나 이상의 명령어를 포함할 수 있다. 프로그램 코드 및/또는 관련 데이터는, RAM, 디스크 드라이브, 솔리드 스테이트 드라 이브, 또는 다른 저장 매체를 포함하는 저장 장치와 같은 임의의 유형의 컴퓨터 판독 가능한 매체에 저장될 수 있다. 컴퓨터 판독 가능한 매체는 또한, 레지스터 메모리 및 프로세서 캐시와 같이 단기간 동안 데이터를 저장하는 비 일시적인 컴퓨터 판독 가능한 매체와 같은 비일시적인 컴퓨터 판독 가능한 매체를 포함할 수 있다. 비일시적인 컴퓨터 판독 가능한 매체는 장기간 동안 프로그램 코드 및/또는 데이터를 저장하는 비일시적인 컴퓨터 판독 가 능한 매체를 더 포함할 수 있다. 따라서, 비일시적인 컴퓨터 판독 가능한 매체는, 예를 들면 ROM, 광학 또는 자기 디스크들, 솔리드 스테이트 드라이브들, 또는 컴팩트 디스크 읽기 전용 메모리(CD-ROM)와 같은 2차 또는 영구 장기 스토리지를 포함할 수 있다. 비일시적인 컴퓨터 판독 가능한 매체는 또한 임의의 다른 휘발성 또는 비휘발성 저장 시스템들일 수 있다. 비일시적인 컴퓨터 판독 가능한 매체는 예를 들면 컴퓨터 판독 가능한 저 장 매체, 또는 유형의 저장 장치로 간주될 수 있다. 또한, 하나 이상의 정보 전송을 나타내는 단계 또는 블록은 동일한 물리적 장치의 소프트웨어 및/또는 하드웨어 모듈들 간의 정보 전송에 대응할 수 있다. 그러나, 다른 정보 전송은 서로 다른 물리적 장치들의 소프트웨어 모듈들 및/또는 하드웨어 모듈들 간일 수 있다. 도면에 나타난 특정 배치들은 제한으로 간주되어서는 안 된다. 다른 실시형태들이 주어진 도면에 나타난 각 요 소를 더 많거나 적게 포함할 수 있음을 이해해야 한다. 또한, 예시된 요소들 중의 일부는 결합되거나 생략될 수 있다. 또한, 예시적인 실시형태는 도면에 도시되지 않은 요소들을 포함할 수 있다. 다양한 양태들 및 실시형태들이 본원에 개시되어 있지만, 다른 양태들 및 실시형태들이 당업자에게 자명할 것이다. 본원에 개시된 다양한 양태들 및 실시형태들은 설명을 위한 것으로 제한을 의도하는 것은 아니며, 그 참된 범위는 다음 특허청구범위에 의해 지시된다."}
{"patent_id": "10-2023-7034722", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 예시적인 실시형태들에 따른 컴퓨팅 장치의 개략도를 나타낸다. 도 2는 예시적인 실시형태들에 따른 서버 장치 클러스터의 개략도를 나타낸다. 도 3은 예시적인 실시형태들에 따른 시스템 레벨 구현의 다양한 동작들이 수행될 수 있는 예시적인 시스템의 단 순화된 블록도를 나타낸다. 도 4a 및 도 4b는 예시적인 실시형태들에 따른 액션 엔트리 요청의 시스템 레벨 구현에 의한 예시적인 처리의 두 가지 표현을 나타낸다. 도 5는 예시적인 실시형태들에 따른 시스템 레벨 동작들의 다양한 양태들과 연관된 예시적인 메시지 흐름도를 나타낸다. 도 6은 예시적인 실시형태들에 따른 엔트리 레벨 구현의 다양한 동작들이 수행될 수 있는 또 다른 예시적인 시 스템의 단순화된 블록도를 나타낸다. 도 7a 및 도 7b는 예시적인 실시형태들에 따른 액션 요청 검증의 엔트리 레벨 구현에 의한 예시적인 처리의 두 가지 표현을 나타낸다. 도 8은 예시적인 실시형태들에 따른 엔트리 레벨 동작들의 다양한 양태들과 연관된 예시적인 메시지 흐름도를 나타낸다. 도 9는 예시적인 실시형태들에 따른 트랜잭션들에 대한 예시적인 시스템 레벨 방법의 흐름도를 나타낸다. 도 10은 예시적인 실시형태들에 따른 스마트 계약들에 대한 예시적인 시스템 레벨 방법의 흐름도를 나타낸다. 도 11은 예시적인 실시형태들에 따른 트랜잭션들에 대한 예시적인 엔트리 레벨 방법의 흐름도를 나타낸다. 도 12는 예시적인 실시형태에 따른 스마트 계약들에 대한 예시적인 엔트리 레벨 방법의 흐름도를 나타낸다."}
