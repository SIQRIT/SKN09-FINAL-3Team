{"patent_id": "10-2025-7005290", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0030521", "출원번호": "10-2025-7005290", "발명의 명칭": "DMVR 기반의 인터 예측 방법 및 장치", "출원인": "엘지전자 주식회사", "발명자": "박내리"}}
{"patent_id": "10-2025-7005290", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "디코딩 장치에 의해 수행되는 영상 디코딩 방법에 있어서,비트스트림으로부터 레지듀얼 정보를 포함하는 영상 정보를 획득하는 단계;현재 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출하는 단계;상기 현재 블록에 대해 DMVR(Decoder-side Motion Vector Refinement)을 적용할지 여부에 관련된 DMVR 플래그정보를 도출하는 단계;상기 DMVR 플래그 정보를 기반으로 상기 현재 블록의 상기 L0 움직임 벡터 및 상기 L1 움직임 벡터에 대한 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 도출하는 단계; 상기 리파인된 L0 움직임 벡터 및 상기 리파인된 L1 움직임 벡터를 기반으로 상기 현재 블록에 대한 예측 샘플들을 도출하는 단계;상기 레지듀얼 정보를 기반으로 양자화된 변환 계수들을 도출하는 단계;상기 양자화된 변환 계수들을 기반으로 변환 계수들을 도출하는 단계;상기 변환 계수들을 기반으로 상기 현재 블록에 대한 레지듀얼 샘플들을 도출하는 단계; 및상기 예측 샘플들 및 상기 레지듀얼 샘플들을 기반으로 상기 현재 블록에 대한 복원 샘플들을 생성하는 단계를포함하며,L0 참조 픽처 및 L1 참조 픽처 기반 쌍예측이 상기 현재 블록에 적용되는 경우, 현재 픽처와 상기 L0 참조 픽처사이의 거리가 상기 현재 픽처와 상기 L1 참조 픽처 사이의 거리와 동일한 경우, L0 루마 가중 예측 플래그 정보의 값 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우, L0 크로마 가중 예측 플래그 정보의 값 및L1 크로마 가중 예측 플래그 정보의 값이 모두 0인 경우, 쌍예측 가중치 인덱스(bi-prediction weight index)정보의 값이 0인 경우, 및 상기 현재 블록의 높이가 8 이상인 경우를 기반으로, 상기 현재 블록에 대해 상기DMVR 플래그 정보를 도출하는 것을 특징으로 하는 영상 디코딩 방법."}
{"patent_id": "10-2025-7005290", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "인코딩 장치에 의해 수행되는 영상 인코딩 방법에 있어서,현재 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출하는 단계;상기 현재 블록에 대해 DMVR(Decoder side Motion Vector Refinement)을 적용할지 여부에 관련된 DMVR 플래그정보를 도출하는 단계;상기 DMVR 플래그 정보를 기반으로 상기 현재 블록의 상기 L0 움직임 벡터 및 상기 L1 움직임 벡터에 대한 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 도출하는 단계; 상기 리파인된 L0 움직임 벡터 및 상기 리파인된 L1 움직임 벡터를 기반으로 상기 현재 블록에 대한 예측 샘플들을 도출하는 단계;상기 예측 샘플들을 기반으로 레지듀얼 샘플들을 도출하는 단계; 상기 레지듀얼 샘플들을 기반으로 변환 계수들을 도출하는 단계;상기 변환 계수들을 기반으로 양자화된 변환 계수들을 도출하는 단계;상기 양자화된 변환 계수들을 기반으로 레지듀얼 정보를 생성하는 단계; 및상기 레지듀얼 정보를 포함하는 영상 정보를 인코딩하는 단계를 포함하며,공개특허 10-2025-0030521-3-L0 참조 픽처 및 L1 참조 픽처 기반 쌍예측이 상기 현재 블록에 적용되는 경우, 현재 픽처와 상기 L0 참조 픽처사이의 거리가 상기 현재 픽처와 상기 L1 참조 픽처 사이의 거리와 동일한 경우, L0 루마 가중 예측 플래그 정보의 값 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우, L0 크로마 가중 예측 플래그 정보의 값 및L1 크로마 가중 예측 플래그 정보의 값이 모두 0인 경우, 쌍예측 가중치 인덱스(bi-prediction weight index)정보의 값이 0인 경우, 및 상기 현재 블록의 높이가 8 이상인 경우를 기반으로, 상기 현재 블록에 대해 상기DMVR 플래그 정보를 도출하는 것을 특징으로 하는 영상 인코딩 방법."}
{"patent_id": "10-2025-7005290", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "컴퓨터 판독 가능한 디지털 저장 매체로서, 특정 방법에 의하여 생성된 비트스트림을 저장하고, 상기 특정 방법은,현재 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출하는 단계;상기 현재 블록에 대해 DMVR(Decoder side Motion Vector Refinement)을 적용할지 여부에 관련된 DMVR 플래그정보를 도출하는 단계;상기 DMVR 플래그 정보를 기반으로 상기 현재 블록의 상기 L0 움직임 벡터 및 상기 L1 움직임 벡터에 대한 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 도출하는 단계; 상기 리파인된 L0 움직임 벡터 및 상기 리파인된 L1 움직임 벡터를 기반으로 상기 현재 블록에 대한 예측 샘플들을 도출하는 단계;상기 예측 샘플들을 기반으로 레지듀얼 샘플들을 도출하는 단계; 상기 레지듀얼 샘플들을 기반으로 변환 계수들을 도출하는 단계;상기 변환 계수들을 기반으로 양자화된 변환 계수들을 도출하는 단계;상기 양자화된 변환 계수들을 기반으로 레지듀얼 정보를 생성하는 단계; 및상기 비트스트림을 생성하기 위해서 상기 레지듀얼 정보를 포함하는 영상 정보를 인코딩하는 단계를 포함하며,상기 L0 참조 픽처 및 L1 참조 픽처 기반 쌍예측이 상기 현재 블록에 적용되는 경우, 현재 픽처와 상기 L0 참조픽처 사이의 거리가 상기 현재 픽처와 상기 L1 참조 픽처 사이의 거리와 동일한 경우, L0 루마 가중 예측 플래그 정보의 값 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우, L0 크로마 가중 예측 플래그 정보의 값및 L1 크로마 가중 예측 플래그 정보의 값이 모두 0인 경우, 쌍예측 가중치 인덱스(bi-prediction weightindex) 정보의 값이 0인 경우, 및 상기 현재 블록의 높이가 8 이상인 경우를 기반으로, 상기 현재 블록에 대해상기 DMVR 플래그 정보를 도출하는 것을 특징으로 하는 컴퓨터 판독 가능한 디지털 저장 매체."}
{"patent_id": "10-2025-7005290", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "영상에 대한 데이터의 전송 방법에 있어서,상기 영상에 대한 비트스트림을 획득하되, 상기 비트스트림은, 현재 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출하는 단계, 상기 현재 블록에 대해 DMVR(Decoder side Motion Vector Refinement)을 적용할지 여부에관련된 DMVR 플래그 정보를 도출하는 단계, 상기 DMVR 플래그 정보를 기반으로 상기 현재 블록의 상기 L0 움직임 벡터 및 상기 L1 움직임 벡터에 대한 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 도출하는단계, 상기 리파인된 L0 움직임 벡터 및 상기 리파인된 L1 움직임 벡터를 기반으로 상기 현재 블록에 대한 예측샘플들을 도출하는 단계, 상기 예측 샘플들을 기반으로 레지듀얼 샘플들을 도출하는 단계, 상기 레지듀얼 샘플들을 기반으로 변환 계수들을 도출하는 단계, 상기 변환 계수들을 기반으로 양자화된 변환 계수들을 도출하는단계, 상기 양자화된 변환 계수들을 기반으로 레지듀얼 정보를 생성하는 단계, 및 상기 레지듀얼 정보를 포함하는 영상 정보를 인코딩하는 단계를 기반으로 생성되는 단계; 및상기 비트스트림을 포함하는 상기 데이터를 전송하는 단계를 포함하며,L0 참조 픽처 및 L1 참조 픽처 기반 쌍예측이 상기 현재 블록에 적용되는 경우, 현재 픽처와 상기 L0 참조 픽처사이의 거리가 상기 현재 픽처와 상기 L1 참조 픽처 사이의 거리와 동일한 경우, L0 루마 가중 예측 플래그 정보의 값 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우, L0 크로마 가중 예측 플래그 정보의 값 및L1 크로마 가중 예측 플래그 정보의 값이 모두 0인 경우, 쌍예측 가중치 인덱스(bi-prediction weight index)공개특허 10-2025-0030521-4-정보의 값이 0인 경우, 및 상기 현재 블록의 높이가 8 이상인 경우를 기반으로, 상기 현재 블록에 대해 상기DMVR 플래그 정보를 도출하는 것을 특징으로 하는 전송 방법."}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 문서에 따른 영상 디코딩 방법은 현재 블록의 L0 및 L1 움직임 벡터를 도출하는 단계, 현재 블록에 대해 DMVR(Decoder-side Motion Vector Refinement)을 적용할지 여부를 지시하는 DMVR 플래그 정보를 유도하는 단계, DMVR 플래그 정보가 현재 블록에 대해 DMVR을 적용하는 것으로 지시하는 경우, 현재 블록에 대해 DMVR을 적용하 여 L0 및 L1 움직임 벡터를 기반으로 리파인된 L0 및 L1 움직임 벡터를 도출하는 단계, 리파인된 L0 및 L1 움직 임 벡터를 기반으로 현재 블록의 예측 샘플들을 도출하는 단계, 예측 샘플들을 기반으로 현재 블록의 복원 샘플 들을 생성하는 단계를 포함하며, DMVR 플래그 정보를 유도하는 단계는, 현재 블록의 높이(Height)가 8 이상인 경 우와, L0 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우, 현재 블록에 대해 DMVR을 적용하는 것으로 DMVR 플래그 정보를 유도하는 것을 특징으로 한다."}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 문서는 영상 코딩 기술에 관한 것으로서, 보다 상세하게는 DMVR(Decoder-side Motion Vector Refinement)에 기반하여 인터 예측을 수행하는 방법 및 장치에 관한 것이다."}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "최근 4K 또는 8K 이상의 UHD(Ultra High Definition) 영상/비디오와 같은 고해상도, 고품질의 영상/비디오에 대 한 수요가 다양한 분야에서 증가하고 있다. 영상/비디오 데이터가 고해상도, 고품질이 될수록 기존의 영상/비디 오 데이터에 비해 상대적으로 전송되는 정보량 또는 비트량이 증가하기 때문에 기존의 유무선 광대역 회선과 같 은 매체를 이용하여 영상 데이터를 전송하거나 기존의 저장 매체를 이용해 영상/비디오 데이터를 저장하는 경우, 전송 비용과 저장 비용이 증가된다. 또한, 최근 VR(Virtual Reality), AR(Artificial Realtiy) 컨텐츠나 홀로그램 등의 실감 미디어(Immersive Media)에 대한 관심 및 수요가 증가하고 있으며, 게임 영상과 같이 현실 영상과 다른 영상 특성을 갖는 영상/비 디오에 대한 방송이 증가하고 있다. 이에 따라, 상기와 같은 다양한 특성을 갖는 고해상도 고품질의 영상/비디오의 정보를 효과적으로 압축하여 전 송하거나 저장하고, 재생하기 위해 고효율의 영상/비디오 압축 기술이 요구된다."}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 문서의 기술적 과제는 영상 코딩 효율을 높이는 방법 및 장치를 제공함에 있다. 본 문서의 다른 기술적 과제는 효율적인 인터 예측 방법 및 장치를 제공함에 있다. 본 문서의 또 다른 기술적 과제는 DMVR(Decoder-side Motion Vector Refinement)에 기반하여 인터 예측을 수행 하는 방법 및 장치를 제공함에 있다. 본 문서의 또 다른 기술적 과제는 BDOF(Bi-directional optical flow)에 기반하여 인터 예측을 수행하는 방법 및 장치를 제공함에 있다. 본 문서의 또 다른 기술적 과제는 영상 코딩 효율을 향상시키기 위한 DMVR의 적용 여부를 결정하기 위한 조건 및/또는 BDOF의 적용 여부를 결정하기 위한 조건을 제공함으로써 예측 성능을 향상시키는 방법 및 장치를 제공 함에 있다."}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 문서의 일 실시예에 따르면, 디코딩 장치에 의하여 수행되는 영상 디코딩 방법이 제공된다. 상기 방법은 현 재 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출하는 단계, 상기 현재 블록에 대해 DMVR(Decoder-side Motion Vector Refinement)을 적용할지 여부를 지시하는 DMVR 플래그 정보를 유도하는 단계, 상기 DMVR 플래그 정보가 상기 현재 블록에 대해 DMVR을 적용하는 것으로 지시하는 경우, 상기 현재 블록에 대해 DMVR을 적용하여, 상기 L0 움직임 벡터 및 상기 L1 움직임 벡터를 기반으로 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 도출하는 단계, 상기 리파인된 L0 움직임 벡터 및 상기 리파인된 L1 움직임 벡터를 기반으로 상 기 현재 블록에 대한 예측 샘플들을 도출하는 단계, 및 상기 예측 샘플들을 기반으로 상기 현재 블록에 대한 복 원 샘플들을 생성하는 단계를 포함하며, 상기 DMVR 플래그 정보를 유도하는 단계는, 상기 현재 블록의 높이 (Height)가 8 이상인 경우와, L0 루마 가중 예측 플래그 정보 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0 인 경우, 상기 현재 블록에 대해 DMVR을 적용하는 것으로 상기 DMVR 플래그 정보를 유도하되, 상기 L0 루마 가 중 예측 플래그 정보의 값이 0인 경우는, L0 예측의 루마 성분에 대해 가중 팩터(weight factor)가 존재하지 않 음을 나타내고, 상기 L1 루마 가중 예측 플래그 정보의 값이 0인 경우는, L1 예측의 루마 성분에 대해 가중 팩 터(weight factor)가 존재하지 않음을 나타내는 것을 특징으로 한다. 본 문서의 다른 일 실시예에 따르면, 인코딩 장치에 의하여 수행되는 영상 인코딩 방법이 제공된다. 상기 방법 은 현재 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출하는 단계, 상기 현재 블록에 대해 DMVR(Decoder-side Motion Vector Refinement)을 적용할지 여부를 지시하는 DMVR 플래그 정보를 유도하는 단계, 상기 DMVR 플래그 정보가 상기 현재 블록에 대해 DMVR을 적용하는 것으로 지시하는 경우, 상기 현재 블록에 대해 DMVR을 적용하여, 상기 L0 움직임 벡터 및 상기 L1 움직임 벡터를 기반으로 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 도출하는 단계, 상기 리파인된 L0 움직임 벡터 및 상기 리파인된 L1 움직임 벡터를 기반으로 상 기 현재 블록에 대한 예측 샘플들을 도출하는 단계, 상기 예측 샘플들을 기반으로 레지듀얼 샘플들을 도출하는 단계, 및 상기 레지듀얼 샘플들에 관한 정보를 포함하는 영상 정보를 인코딩하는 단계를 포함하며, 상기 DMVR 플래그 정보를 유도하는 단계는, 상기 현재 블록의 높이(Height)가 8 이상인 경우와, L0 루마 가중 예측 플래그 정보 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우, 상기 현재 블록에 대해 DMVR을 적용하는 것으로 상기 DMVR 플래그 정보를 유도하되, 상기 L0 루마 가중 예측 플래그 정보의 값이 0인 경우는, L0 예측의 루마 성분에 대해 가중 팩터(weight factor)가 존재하지 않음을 나타내고, 상기 L1 루마 가중 예측 플래그 정보의 값 이 0인 경우는, L1 예측의 루마 성분에 대해 가중 팩터(weight factor)가 존재하지 않음을 나타내는 것을 특징 으로 한다."}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 문서에 따르면 전반적인 영상/비디오 압축 효율을 높일 수 있다. 본 문서에 따르면 효율적인 인터 예측을 통하여 계산 복잡도를 줄일 수 있고, 전반적인 코딩 효율을 향상시킬 수 있다. 본 문서에 따르면 움직임 보상 과정에서 움직임 정보를 리파인먼트하는 DMVR 및/또는 BDOF를 적용함에 있어 다 양한 적용 조건들을 제안함으로써, 복잡도 및 성능 면에서의 효율성을 향상시킬 수 있다."}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 문서는 다양한 변경을 가할 수 있고 여러 가지 실시예를 가질 수 있는 바, 특정 실시예들을 도면에 예시하고 상세하게 설명하고자 한다. 그러나, 이는 본 문서를 특정 실시예에 한정하려고 하는 것이 아니다. 본 명세서에 서 상용하는 용어는 단지 특정한 실시예를 설명하기 위해 사용된 것으로, 본 문서의 기술적 사상을 한정하려는 의도로 사용되는 것은 아니다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서 \"포함하다\" 또는 \"가지다\" 등의 용어는 명세서상에 기재된 특징, 숫자, 단계, 동작, 구성 요소, 부품 또는 이들을 조합한 것이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성 요소, 부품 도는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 한편, 본 문서에서 설명되는 도면상의 각 구성들은 서로 다른 특징적인 기능들에 관한 설명의 편의를 위해 독립 적으로 도시된 것으로서, 각 구성들이 서로 별개의 하드웨어나 별개의 소프트웨어로 구현된다는 것을 의미하지 는 않는다. 예컨대, 각 구성 중 두 개 이상의 구성이 합쳐져 하나의 구성을 이룰 수도 있고, 하나의 구성이 복 수의 구성으로 나뉘어질 수도 있다. 각 구성이 통합 및/또는 분리된 실시예도 본 문서의 본질에서 벗어나지 않 는 한 본 문서의 권리범위에 포함된다. 이하, 첨부한 도면들을 참조하여, 본 문서의 바람직한 실시예를 보다 상세하게 설명하고자 한다. 이하, 도면상 의 동일한 구성 요소에 대해서는 동일한 참조 부호를 사용하고 동일한 구성 요소에 대해서 중복된 설명은 생략 될 수 있다. 도 1은 본 문서의 실시예들에 적용될 수 있는 비디오/영상 코딩 시스템의 예를 개략적으로 나타낸다. 도 1을 참조하면, 비디오/영상 코딩 시스템은 제1 장치(소스 디바이스) 및 제2 장치(수신 디바이스)를 포함할 수 있다. 소스 디바이스는 인코딩된 비디오(video)/영상(image) 정보 또는 데이터를 파일 또는 스트리밍 형태로 디지털 저장매체 또는 네트워크를 통하여 수신 디바이스로 전달할 수 있다. 상기 소스 디바이스는 비디오 소스, 인코딩 장치, 전송부를 포함할 수 있다. 상기 수신 디바이스는 수신부, 디 코딩 장치 및 렌더러를 포함할 수 있다. 상기 인코딩 장치는 비디오/영상 인코딩 장치라고 불릴 수 있고, 상기 디코딩 장치는 비디오/영상 디코딩 장치라고 불릴 수 있다. 송신기는 인코딩 장치에 포함될 수 있다. 수신기는 디코딩 장치에 포함될 수 있다. 렌더러는 디스플레이부를 포함할 수도 있고, 디스플레이부는 별개의 디바이스 또는 외부 컴포넌트로 구성될 수도 있다. 비디오 소스는 비디오/영상의 캡쳐, 합성 또는 생성 과정 등을 통하여 비디오/영상을 획득할 수 있다. 비디오 소스는 비디오/영상 캡쳐 디바이스 및/또는 비디오/영상 생성 디바이스를 포함할 수 있다. 비디오/영상 캡쳐 디 바이스는 예를 들어, 하나 이상의 카메라, 이전에 캡쳐된 비디오/영상을 포함하는 비디오/영상 아카이브 등을 포함할 수 있다. 비디오/영상 생성 디바이스는 예를 들어 컴퓨터, 타블렛 및 스마트폰 등을 포함할 수 있으며 (전자적으로) 비디오/영상을 생성할 수 있다. 예를 들어, 컴퓨터 등을 통하여 가상의 비디오/영상이 생성될 수 있으며, 이 경우 관련 데이터가 생성되는 과정으로 비디오/영상 캡쳐 과정이 갈음될 수 있다. 인코딩 장치는 입력 비디오/영상을 인코딩할 수 있다. 인코딩 장치는 압축 및 코딩 효율을 위하여 예측, 변환, 양자화 등 일련의 절차를 수행할 수 있다. 인코딩된 데이터(인코딩된 비디오/영상 정보)는 비트스트림 (bitstream) 형태로 출력될 수 있다. 전송부는 비트스트림 형태로 출력된 인코딩된 비디오/영상 정보 또는 데이터를 파일 또는 스트리밍 형태로 디지 털 저장매체 또는 네트워크를 통하여 수신 디바이스의 수신부로 전달할 수 있다. 디지털 저장 매체는 USB, SD, CD, DVD, 블루레이, HDD, SSD 등 다양한 저장 매체를 포함할 수 있다. 전송부는 미리 정해진 파일 포멧을 통하 여 미디어 파일을 생성하기 위한 엘리먼트를 포함할 수 있고, 방송/통신 네트워크를 통한 전송을 위한 엘리먼트 를 포함할 수 있다. 수신부는 상기 비트스트림을 수신/추출하여 디코딩 장치로 전달할 수 있다. 디코딩 장치는 인코딩 장치의 동작에 대응하는 역양자화, 역변환, 예측 등 일련의 절차를 수행하여 비디오/영상 을 디코딩할 수 있다. 렌더러는 디코딩된 비디오/영상을 렌더링할 수 있다. 렌더링된 비디오/영상은 디스플레이부를 통하여 디스플레 이될 수 있다. 이 문서는 비디오/영상 코딩에 관한 것이다. 예를 들어 이 문서에서 개시된 방법/실시예는 VVC (versatile video coding) 표준, EVC (essential video coding) 표준, AV1 (AOMedia Video 1) 표준, AVS2 (2nd generation of audio video coding standard) 또는 차세대 비디오/영상 코딩 표준(ex. H.267 or H.268 등)에 개시되는 방법에 적용될 수 있다. 이 문서에서는 비디오/영상 코딩에 관한 다양한 실시예들을 제시하며, 다른 언급이 없는 한 상기 실시예들은 서 로 조합되어 수행될 수도 있다. 이 문서에서 비디오(video)는 시간의 흐름에 따른 일련의 영상(image)들의 집합을 의미할 수 있다. 픽처 (picture)는 일반적으로 특정 시간대의 하나의 영상을 나타내는 단위를 의미하며, 슬라이스(slice)/타일(tile) 는 코딩에 있어서 픽처의 일부를 구성하는 단위이다. 슬라이스/타일은 하나 이상의 CTU(coding tree unit)을 포 함할 수 있다. 하나의 픽처는 하나 이상의 슬라이스/타일로 구성될 수 있다. 하나의 픽처는 하나 이상의 타일 그룹으로 구성될 수 있다. 하나의 타일 그룹은 하나 이상의 타일들을 포함할 수 있다. 브릭은 픽처 내 타일 이 내의 CTU 행들의 사각 영역을 나타낼 수 있다(a brick may represent a rectangular region of CTU rows within a tile in a picture). 타일은 다수의 브릭들로 파티셔닝될 수 있고, 각 브릭은 상기 타일 내 하나 이상 의 CTU 행들로 구성될 수 있다(A tile may be partitioned into multiple bricks, each of which consisting of one or more CTU rows within the tile). 다수의 브릭들로 파티셔닝되지 않은 타일은 또한 브릭으로 불릴 수 있다(A tile that is not partitioned into multiple bricks may be also referred to as a brick). 브릭 스캔은 픽처를 파티셔닝하는 CTU들의 특정한 순차적 오더링을 나타낼 수 있으며, 상기 CTU들은 브릭 내에서 CTU 래스터 스캔으로 정렬될 수 있고, 타일 내 브릭들은 상기 타일의 상기 브릭들의 래스터 스캔으로 연속적으로 정 렬될 수 있고, 그리고 픽처 내 타일들은 상기 픽처의 상기 타일들의 래스터 스캔으로 연속적으로 정렬될 수 있 다(A brick scan is a specific sequential ordering of CTUs partitioning a picture in which the CTUs are ordered consecutively in CTU raster scan in a brick, bricks within a tile are ordered consecutively in a raster scan of the bricks of the tile, and tiles in a picture are ordered consecutively in a raster scan of the tiles of the picture). 타일은 특정 타일 열 및 특정 타일 열 이내의 CTU들의 사각 영역이다(A tile is a rectangular region of CTUs within a particular tile column and a particular tile row in a picture). 상기 타일 열은 CTU들의 사각 영역이고, 상기 사각 영역은 상기 픽처의 높이와 동일한 높이를 갖고, 너비는 픽처 파라미터 세트 내의 신택스 요소들에 의하여 명시될 수 있다(The tile column is a rectangular region of CTUs having a height equal to the height of the picture and a width specified by syntax elements in the picture parameter set). 상기 타일 행은 CTU들의 사각 영역이고, 상기 사각 영역은 픽처 파 라미터 세트 내의 신택스 요소들에 의하여 명시되는 너비를 갖고, 높이는 상기 픽처의 높이와 동일할 수 있다 (The tile row is a rectangular region of CTUs having a height specified by syntax elements in the picture parameter set and a width equal to the width of the picture). 타일 스캔은 픽처를 파티셔닝하는 CTU들의 특정 순차적 오더링을 나타낼 수 있고, 상기 CTU들은 타일 내 CTU 래스터 스캔으로 연속적으로 정렬될 수 있고, 픽처 내 타일들은 상기 픽처의 상기 타일들의 래스터 스캔으로 연속적으로 정렬될 수 있다(A tile scan is a specific sequential ordering of CTUs partitioning a picture in which the CTUs are ordered consecutively in CTU raster scan in a tile whereas tiles in a picture are ordered consecutively in a raster scan of the tiles of the picture). 슬라이스는 픽처의 정수개의 브릭들을 포함할 수 있고, 상기 정수 개의 브릭들은 하나의 NAL 유닛에 포함될 수 있다(A slice includes an integer number of bricks of a picture that may be exclusively contained in a single NAL unit). 슬라이스는 다수의 완전한 타일들로 구성 될 수 있고, 또는 하나의 타일의 완전한 브릭들의 연속적인 시퀀스일 수도 있다(A slice may consists of either a number of complete tiles or only a consecutive sequence of complete bricks of one tile). 이 문서에서 타일 그룹과 슬라이스는 혼용될 수 있다. 예를 들어 본 문서에서 tile group/tile group header는 slice/slice header로 불리 수 있다. 픽셀(pixel) 또는 펠(pel)은 하나의 픽처(또는 영상)을 구성하는 최소의 단위를 의미할 수 있다. 또한, 픽셀에 대응하는 용어로서 '샘플(sample)'이 사용될 수 있다. 샘플은 일반적으로 픽셀 또는 픽셀의 값을 나타낼 수 있 으며, 루마(luma) 성분의 픽셀/픽셀값만을 나타낼 수도 있고, 크로마(chroma) 성분의 픽셀/픽셀 값만을 나타낼 수도 있다. 또는 샘플은 공간 도메인에서의 픽셀값을 의미할 수도 있고, 이러한 픽셀값이 주파수 도메인으로 변환되면 주파수 도메인에서의 변환 계수를 의미할 수도 있다. 유닛(unit)은 영상 처리의 기본 단위를 나타낼 수 있다. 유닛은 픽처의 특정 영역 및 해당 영역에 관련된 정보 중 적어도 하나를 포함할 수 있다. 하나의 유닛은 하나의 루마 블록 및 두개의 크로마(ex. cb, cr) 블록을 포함 할 수 있다. 유닛은 경우에 따라서 블록(block) 또는 영역(area) 등의 용어와 혼용하여 사용될 수 있다. 일반적 인 경우, MxN 블록은 M개의 열과 N개의 행으로 이루어진 샘플들(또는 샘플 어레이) 또는 변환 계수(transform coefficient)들의 집합(또는 어레이)을 포함할 수 있다. 이 문서에서 \"/\"와 \",\"는 \"및/또는\"으로 해석된다. 예를 들어, \"A/B\"는 \"A 및/또는 B\"로 해석되고, \"A, B\"는 \"A 및/또는 B\"로 해석된다. 추가적으로, \"A/B/C\"는 \"A, B 및/또는 C 중 적어도 하나\"를 의미한다. 또한, \"A, B, C\"도 \"A, B 및/또는 C 중 적어도 하나\"를 의미한다. (In this document, the term \"/\" and \",\" should be interpreted to indicate \"and/or.\" For instance, the expression \"A/B\" may mean \"A and/or B.\" Further, \"A, B\" may mean \"A and/or B.\" Further, \"A/B/C\" may mean \"at least one of A, B, and/or C.\" Also, \"A/B/C\" may mean \"at least one of A, B, and/or C.\") 추가적으로, 본 문서에서 \"또는\"는 \"및/또는\"으로 해석된다. 예를 들어, \"A 또는 B\"은, 1) \"A\" 만을 의미하고, 2) \"B\" 만을 의미하거나, 3) \"A 및 B\"를 의미할 수 있다. 달리 표현하면, 본 문서의 \"또는\"은 \"추가적으로 또는 대체적으로(additionally or alternatively)\"를 의미할 수 있다. (Further, in the document, the term \"or\" should be interpreted to indicate \"and/or.\" For instance, the expression \"A or B\" may comprise 1) only A, 2) only B, and/or 3) both A and B. In other words, the term \"or\" in this document should be interpreted to indicate \"additionally or alternatively.\") 도 2는 본 문서의 실시예들에 적용될 수 있는 비디오/영상 인코딩 장치의 구성을 개략적으로 설명하는 도면이다. 이하 비디오 인코딩 장치라 함은 영상 인코딩 장치를 포함할 수 있다. 도 2를 참조하면, 인코딩 장치는 영상 분할부(image partitioner, 210), 예측부(predictor, 220), 레지듀 얼 처리부(residual processor, 230), 엔트로피 인코딩부(entropy encoder, 240), 가산부(adder, 250), 필터링 부(filter, 260) 및 메모리(memory, 270)를 포함하여 구성될 수 있다. 예측부는 인터 예측부 및 인 트라 예측부를 포함할 수 있다. 레지듀얼 처리부는 변환부(transformer, 232), 양자화부(quantizer 233), 역양자화부(dequantizer 234), 역변환부(inverse transformer, 235)를 포함할 수 있다. 레지듀얼 처리부 은 감산부(subtractor, 231)를 더 포함할 수 있다. 가산부는 복원부(reconstructor) 또는 복원 블록 생성부(recontructged block generator)로 불릴 수 있다. 상술한 영상 분할부, 예측부, 레지듀얼 처 리부, 엔트로피 인코딩부, 가산부 및 필터링부는 실시예에 따라 하나 이상의 하드웨어 컴 포넌트(예를 들어 인코더 칩셋 또는 프로세서)에 의하여 구성될 수 있다. 또한 메모리는 DPB(decoded picture buffer)를 포함할 수 있고, 디지털 저장 매체에 의하여 구성될 수도 있다. 상기 하드웨어 컴포넌트는 메모리을 내/외부 컴포넌트로 더 포함할 수도 있다. 영상 분할부는 인코딩 장치에 입력된 입력 영상(또는, 픽쳐, 프레임)를 하나 이상의 처리 유닛 (processing unit)으로 분할할 수 있다. 일 예로, 상기 처리 유닛은 코딩 유닛(coding unit, CU)이라고 불릴 수 있다. 이 경우 코딩 유닛은 코딩 트리 유닛(coding tree unit, CTU) 또는 최대 코딩 유닛(largest coding unit, LCU)으로부터 QTBTTT (Quad-tree binary-tree ternary-tree) 구조에 따라 재귀적으로(recursively) 분할 될 수 있다. 예를 들어, 하나의 코딩 유닛은 쿼드 트리 구조, 바이너리 트리 구조, 및/또는 터너리 구조를 기반 으로 하위(deeper) 뎁스의 복수의 코딩 유닛들로 분할될 수 있다. 이 경우 예를 들어 쿼드 트리 구조가 먼저 적 용되고 바이너리 트리 구조 및/또는 터너리 구조가 나중에 적용될 수 있다. 또는 바이너리 트리 구조가 먼저 적 용될 수도 있다. 더 이상 분할되지 않는 최종 코딩 유닛을 기반으로 본 문서에 따른 코딩 절차가 수행될 수 있 다. 이 경우 영상 특성에 따른 코딩 효율 등을 기반으로, 최대 코딩 유닛이 바로 최종 코딩 유닛으로 사용될 수 있고, 또는 필요에 따라 코딩 유닛은 재귀적으로(recursively) 보다 하위 뎁스의 코딩 유닛들로 분할되어 최적 의 사이즈의 코딩 유닛이 최종 코딩 유닛으로 사용될 수 있다. 여기서 코딩 절차라 함은 후술하는 예측, 변환, 및 복원 등의 절차를 포함할 수 있다. 다른 예로, 상기 처리 유닛은 예측 유닛(PU: Prediction Unit) 또는 변환 유닛(TU: Transform Unit)을 더 포함할 수 있다. 이 경우 상기 예측 유닛 및 상기 변환 유닛은 각각 상술한 최 종 코딩 유닛으로부터 분할 또는 파티셔닝될 수 있다. 상기 예측 유닛은 샘플 예측의 단위일 수 있고, 상기 변 환 유닛은 변환 계수를 유도하는 단위 및/또는 변환 계수로부터 레지듀얼 신호(residual signal)를 유도하는 단 위일 수 있다. 유닛은 경우에 따라서 블록(block) 또는 영역(area) 등의 용어와 혼용하여 사용될 수 있다. 일반적인 경우, MxN 블록은 M개의 열과 N개의 행으로 이루어진 샘플들 또는 변환 계수(transform coefficient)들의 집합을 나타낼 수 있다. 샘플은 일반적으로 픽셀 또는 픽셀의 값을 나타낼 수 있으며, 휘도(luma) 성분의 픽셀/픽셀값만을 나 타낼 수도 있고, 채도(chroma) 성분의 픽셀/픽셀 값만을 나타낼 수도 있다. 샘플은 하나의 픽처(또는 영상)을 픽셀(pixel) 또는 펠(pel)에 대응하는 용어로서 사용될 수 있다. 인코딩 장치는 입력 영상 신호(원본 블록, 원본 샘플 어레이)에서 인터 예측부 또는 인트라 예측부 로부터 출력된 예측 신호(예측된 블록, 예측 샘플 어레이)를 감산하여 레지듀얼 신호(residual signal, 잔 여 블록, 잔여 샘플 어레이)를 생성할 수 있고, 생성된 레지듀얼 신호는 변환부로 전송된다. 이 경우 도시 된 바와 같이 인코더 내에서 입력 영상 신호(원본 블록, 원본 샘플 어레이)에서 예측 신호(예측 블록, 예 측 샘플 어레이)를 감산하는 유닛은 감산부라고 불릴 수 있다. 예측부는 처리 대상 블록(이하, 현재 블록 이라 함)에 대한 예측을 수행하고, 상기 현재 블록에 대한 예측 샘플들을 포함하는 예측된 블록(predicted block)을 생성할 수 있다. 예측부는 현재 블록 또는 CU 단위로 인트라 예측이 적용되는지 또는 인터 예측이 적 용되는지 결정할 수 있다. 예측부는 각 예측모드에 대한 설명에서 후술하는 바와 같이 예측 모드 정보 등 예측 에 관한 다양한 정보를 생성하여 엔트로피 인코딩부로 전달할 수 있다. 예측에 관한 정보는 엔트로피 인코 딩부에서 인코딩되어 비트스트림 형태로 출력될 수 있다. 인트라 예측부는 현재 픽처 내의 샘플들을 참조하여 현재 블록을 예측할 수 있다. 상기 참조되는 샘플들은 예측 모드에 따라 상기 현재 블록의 주변(neighbor)에 위치할 수 있고, 또는 떨어져서 위치할 수도 있다. 인트 라 예측에서 예측 모드들은 복수의 비방향성 모드와 복수의 방향성 모드를 포함할 수 있다. 비방향성 모드는 예 를 들어 DC 모드 및 플래너 모드(Planar 모드)를 포함할 수 있다. 방향성 모드는 예측 방향의 세밀한 정도에 따 라 예를 들어 33개의 방향성 예측 모드 또는 65개의 방향성 예측 모드를 포함할 수 있다. 다만, 이는 예시로서 설정에 따라 그 이상 또는 그 이하의 개수의 방향성 예측 모드들이 사용될 수 있다. 인트라 예측부는 주변 블록에 적용된 예측 모드를 이용하여, 현재 블록에 적용되는 예측 모드를 결정할 수도 있다. 인터 예측부는 참조 픽처 상에서 움직임 벡터에 의해 특정되는 참조 블록(참조 샘플 어레이)을 기반으로, 현재 블록에 대한 예측된 블록을 유도할 수 있다. 이때, 인터 예측 모드에서 전송되는 움직임 정보의 양을 줄이 기 위해 주변 블록과 현재 블록 간의 움직임 정보의 상관성에 기초하여 움직임 정보를 블록, 서브블록 또는 샘 플 단위로 예측할 수 있다. 상기 움직임 정보는 움직임 벡터 및 참조 픽처 인덱스를 포함할 수 있다. 상기 움직 임 정보는 인터 예측 방향(L0 예측, L1 예측, Bi 예측 등) 정보를 더 포함할 수 있다. 인터 예측의 경우에, 주 변 블록은 현재 픽처 내에 존재하는 공간적 주변 블록(spatial neighboring block)과 참조 픽처에 존재하는 시 간적 주변 블록(temporal neighboring block)을 포함할 수 있다. 상기 참조 블록을 포함하는 참조 픽처와 상기 시간적 주변 블록을 포함하는 참조 픽처는 동일할 수도 있고, 다를 수도 있다. 상기 시간적 주변 블록은 동일 위치 참조 블록(collocated reference block), 동일 위치 CU(colCU) 등의 이름으로 불릴 수 있으며, 상기 시간 적 주변 블록을 포함하는 참조 픽처는 동일 위치 픽처(collocated picture, colPic)라고 불릴 수도 있다. 예를 들어, 인터 예측부는 주변 블록들을 기반으로 움직임 정보 후보 리스트를 구성하고, 상기 현재 블록의 움 직임 벡터 및/또는 참조 픽처 인덱스를 도출하기 위하여 어떤 후보가 사용되는지를 지시하는 정보를 생성할 수 있다. 다양한 예측 모드를 기반으로 인터 예측이 수행될 수 있으며, 예를 들어 스킵 모드와 머지 모드의 경우에, 인터 예측부는 주변 블록의 움직임 정보를 현재 블록의 움직임 정보로 이용할 수 있다. 스킵 모드 의 경우, 머지 모드와 달리 레지듀얼 신호가 전송되지 않을 수 있다. 움직임 정보 예측(motion vector prediction, MVP) 모드의 경우, 주변 블록의 움직임 벡터를 움직임 벡터 예측자(motion vector predictor)로 이용하고, 움직임 벡터 차분(motion vector difference)을 시그널링함으로써 현재 블록의 움직임 벡터를 지시할 수 있다. 예측부는 후술하는 다양한 예측 방법을 기반으로 예측 신호를 생성할 수 있다. 예를 들어, 예측부는 하나 의 블록에 대한 예측을 위하여 인트라 예측 또는 인터 예측을 적용할 수 있을 뿐 아니라, 인트라 예측과 인터 예측을 동시에 적용할 수 있다. 이는 combined inter and intra prediction (CIIP)라고 불릴 수 있다. 또한, 예측부는 블록에 대한 예측을 위하여 인트라 블록 카피(intra block copy, IBC) 예측 모드에 기반할 수도 있고 또는 팔레트 모드(palette mode)에 기반할 수도 있다. 상기 IBC 예측 모드 또는 팔레트 모드는 예를 들어 SCC(screen content coding) 등과 같이 게임 등의 컨텐츠 영상/동영상 코딩을 위하여 사용될 수 있다. IBC는 기 본적으로 현재 픽처 내에서 예측을 수행하나 현재 픽처 내에서 참조 블록을 도출하는 점에서 인터 예측과 유사 하게 수행될 수 있다. 즉, IBC는 본 문서에서 설명되는 인터 예측 기법들 중 적어도 하나를 이용할 수 있다. 팔 레트 모드는 인트라 코딩 또는 인트라 예측의 일 예로 볼 수 있다. 팔레트 모드가 적용되는 경우 팔레트 테이블 및 팔레트 인덱스에 관한 정보를 기반으로 픽처 내 샘플 값을 시그널링할 수 있다. 상기 예측부 (인터 예측부 및/또는 상기 인트라 예측부 포함)를 통해 생성된 예측 신호는 복원 신호 를 생성하기 위해 이용되거나 레지듀얼 신호를 생성하기 위해 이용될 수 있다. 변환부는 레지듀얼 신호에 변환 기법을 적용하여 변환 계수들(transform coefficients)를 생성할 수 있다. 예를 들어, 변환 기법은 DCT(Discrete Cosine Transform), DST(Discrete Sine Transform), KLT( ), GBT(Graph-Based Transform), 또는 CNT(Conditionally Non-linear Transform) 중 적어도 하나를 포함할 수 있 다. 여기서, GBT는 픽셀 간의 관계 정보를 그래프로 표현한다고 할 때 이 그래프로부터 얻어진 변환을 의미한다. CNT는 이전에 복원된 모든 픽셀(all previously reconstructed pixel)를 이용하여 예측 신호를 생성 하고 그에 기초하여 획득되는 변환을 의미한다. 또한, 변환 과정은 정사각형의 동일한 크기를 갖는 픽셀 블록에 적용될 수도 있고, 정사각형이 아닌 가변 크기의 블록에도 적용될 수 있다. 양자화부는 변환 계수들을 양자화하여 엔트로피 인코딩부로 전송되고, 엔트로피 인코딩부는 양 자화된 신호(양자화된 변환 계수들에 관한 정보)를 인코딩하여 비트스트림으로 출력할 수 있다. 상기 양자화된 변환 계수들에 관한 정보는 레지듀얼 정보라고 불릴 수 있다. 양자화부는 계수 스캔 순서(scan order)를 기반으로 블록 형태의 양자화된 변환 계수들을 1차원 벡터 형태로 재정렬할 수 있고, 상기 1차원 벡터 형태의 양자화된 변환 계수들을 기반으로 상기 양자화된 변환 계수들에 관한 정보를 생성할 수도 있다. 엔트로피 인코 딩부는 예를 들어 지수 골롬(exponential Golomb), CAVLC(context-adaptive variable length coding), CABAC(context-adaptive binary arithmetic coding) 등과 같은 다양한 인코딩 방법을 수행할 수 있다. 엔트로 피 인코딩부는 양자화된 변환 계수들 외 비디오/이미지 복원에 필요한 정보들(예컨대 신택스 요소들 (syntax elements)의 값 등)을 함께 또는 별도로 인코딩할 수도 있다. 인코딩된 정보(ex. 인코딩된 비디오/영상 정보)는 비트스트림 형태로 NAL(network abstraction layer) 유닛 단위로 전송 또는 저장될 수 있다. 상기 비디 오/영상 정보는 어댑테이션 파라미터 세트(APS), 픽처 파라미터 세트(PPS), 시퀀스 파라미터 세트(SPS) 또는 비 디오 파라미터 세트(VPS) 등 다양한 파라미터 세트에 관한 정보를 더 포함할 수 있다. 또한 상기 비디오/영상 정보는 일반 제한 정보(general constraint information)을 더 포함할 수 있다. 본 문서에서 인코딩 장치에서 디코딩 장치로 전달/시그널링되는 정보 및/또는 신택스 요소들은 비디오/영상 정보에 포함될 수 있다. 상기 비 디오/영상 정보는 상술한 인코딩 절차를 통하여 인코딩되어 상기 비트스트림에 포함될 수 있다. 상기 비트스트 림은 네트워크를 통하여 전송될 수 있고, 또는 디지털 저장매체에 저장될 수 있다. 여기서 네트워크는 방송망 및/또는 통신망 등을 포함할 수 있고, 디지털 저장매체는 USB, SD, CD, DVD, 블루레이, HDD, SSD 등 다양한 저 장매체를 포함할 수 있다. 엔트로피 인코딩부로부터 출력된 신호는 전송하는 전송부(미도시) 및/또는 저장 하는 저장부(미도시)가 인코딩 장치의 내/외부 엘리먼트로서 구성될 수 있고, 또는 전송부는 엔트로피 인 코딩부에 포함될 수도 있다. 양자화부로부터 출력된 양자화된 변환 계수들은 예측 신호를 생성하기 위해 이용될 수 있다. 예를 들어, 양자화된 변환 계수들에 역양자화부 및 역변환부를 통해 역양자화 및 역변환을 적용함으로써 레지듀 얼 신호(레지듀얼 블록 or 레지듀얼 샘플들)를 복원할 수 있다. 가산부는 복원된 레지듀얼 신호를 인터 예 측부 또는 인트라 예측부로부터 출력된 예측 신호에 더함으로써 복원(reconstructed) 신호(복원 픽처, 복원 블록, 복원 샘플 어레이)가 생성될 수 있다. 스킵 모드가 적용된 경우와 같이 처리 대상 블록에 대 한 레지듀얼이 없는 경우, 예측된 블록이 복원 블록으로 사용될 수 있다. 가산부는 복원부 또는 복원 블록 생성부라고 불릴 수 있다. 생성된 복원 신호는 현재 픽처 내 다음 처리 대상 블록의 인트라 예측을 위하여 사용 될 수 있고, 후술하는 바와 같이 필터링을 거쳐서 다음 픽처의 인터 예측을 위하여 사용될 수도 있다. 한편 픽처 인코딩 및/또는 복원 과정에서 LMCS (luma mapping with chroma scaling)가 적용될 수도 있다. 필터링부는 복원 신호에 필터링을 적용하여 주관적/객관적 화질을 향상시킬 수 있다. 예를 들어 필터링부 은 복원 픽처에 다양한 필터링 방법을 적용하여 수정된(modified) 복원 픽처를 생성할 수 있고, 상기 수정 된 복원 픽처를 메모리, 구체적으로 메모리의 DPB에 저장할 수 있다. 상기 다양한 필터링 방법은 예 를 들어, 디블록킹 필터링, 샘플 적응적 오프셋(sample adaptive offset), 적응적 루프 필터(adaptive loop filter), 양방향 필터(bilateral filter) 등을 포함할 수 있다. 필터링부은 각 필터링 방법에 대한 설명에 서 후술하는 바와 같이 필터링에 관한 다양한 정보를 생성하여 엔트로피 인코딩부로 전달할 수 있다. 필터 링 관한 정보는 엔트로피 인코딩부에서 인코딩되어 비트스트림 형태로 출력될 수 있다. 메모리에 전송된 수정된 복원 픽처는 인터 예측부에서 참조 픽처로 사용될 수 있다. 인코딩 장치는 이를 통하여 인터 예측이 적용되는 경우, 인코딩 장치와 디코딩 장치에서의 예측 미스매치를 피할 수 있고, 부호화 효율도 향상시킬 수 있다. 메모리 DPB는 수정된 복원 픽처를 인터 예측부에서의 참조 픽처로 사용하기 위해 저장할 수 있다. 메 모리는 현재 픽처 내 움직임 정보가 도출된(또는 인코딩된) 블록의 움직임 정보 및/또는 이미 복원된 픽처 내 블록들의 움직임 정보를 저장할 수 있다. 상기 저장된 움직임 정보는 공간적 주변 블록의 움직임 정보 또는 시간적 주변 블록의 움직임 정보로 활용하기 위하여 인터 예측부에 전달할 수 있다. 메모리는 현재 픽처 내 복원된 블록들의 복원 샘플들을 저장할 수 있고, 인트라 예측부에 전달할 수 있다. 도 3은 본 문서의 실시예들에 적용될 수 있는 비디오/영상 디코딩 장치의 구성을 개략적으로 설명하는 도면이다. 도 3을 참조하면, 디코딩 장치는 엔트로피 디코딩부(entropy decoder, 310), 레지듀얼 처리부(residual processor, 320), 예측부(predictor, 330), 가산부(adder, 340), 필터링부(filter, 350) 및 메모리(memoery, 360)를 포함하여 구성될 수 있다. 예측부는 인터 예측부 및 인트라 예측부를 포함할 수 있다. 레지듀얼 처리부는 역양자화부(dequantizer, 321) 및 역변환부(inverse transformer, 321)를 포함할 수 있다. 상술한 엔트로피 디코딩부, 레지듀얼 처리부, 예측부, 가산부 및 필터링부는 실시예에 따라 하나의 하드웨어 컴포넌트(예를 들어 디코더 칩셋 또는 프로세서)에 의하여 구성될 수 있다. 또 한 메모리는 DPB(decoded picture buffer)를 포함할 수 있고, 디지털 저장 매체에 의하여 구성될 수도 있 다. 상기 하드웨어 컴포넌트는 메모리을 내/외부 컴포넌트로 더 포함할 수도 있다. 비디오/영상 정보를 포함하는 비트스트림이 입력되면, 디코딩 장치는 도 2의 인코딩 장치에서 비디오/영상 정보가 처리된 프로세스에 대응하여 영상을 복원할 수 있다. 예를 들어, 디코딩 장치는 상기 비트스트림으 로부터 획득한 블록 분할 관련 정보를 기반으로 유닛들/블록들을 도출할 수 있다. 디코딩 장치는 인코딩 장치에서 적용된 처리 유닛을 이용하여 디코딩을 수행할 수 있다. 따라서 디코딩의 처리 유닛은 예를 들어 코딩 유닛일 수 있고, 코딩 유닛은 코딩 트리 유닛 또는 최대 코딩 유닛으로부터 쿼드 트리 구조, 바이너리 트리 구 조 및/또는 터너리 트리 구조를 따라서 분할될 수 있다. 코딩 유닛으로부터 하나 이상의 변환 유닛이 도출될 수 있다. 그리고, 디코딩 장치를 통해 디코딩 및 출력된 복원 영상 신호는 재생 장치를 통해 재생될 수 있다. 디코딩 장치는 도 2의 인코딩 장치로부터 출력된 신호를 비트스트림 형태로 수신할 수 있고, 수신된 신호 는 엔트로피 디코딩부를 통해 디코딩될 수 있다. 예를 들어, 엔트로피 디코딩부는 상기 비트스트림을 파싱하여 영상 복원(또는 픽처 복원)에 필요한 정보(ex. 비디오/영상 정보)를 도출할 수 있다. 상기 비디오/영 상 정보는 어댑테이션 파라미터 세트(APS), 픽처 파라미터 세트(PPS), 시퀀스 파라미터 세트(SPS) 또는 비디오 파라미터 세트(VPS) 등 다양한 파라미터 세트에 관한 정보를 더 포함할 수 있다. 또한 상기 비디오/영상 정보는 일반 제한 정보(general constraint information)을 더 포함할 수 있다. 디코딩 장치는 상기 파라미터 세트에 관한 정보 및/또는 상기 일반 제한 정보를 더 기반으로 픽처를 디코딩할 수 있다. 본 문서에서 후술되는 시그널 링/수신되는 정보 및/또는 신택스 요소들은 상기 디코딩 절차를 통하여 디코딩되어 상기 비트스트림으로부터 획 득될 수 있다. 예컨대, 엔트로피 디코딩부는 지수 골롬 부호화, CAVLC 또는 CABAC 등의 코딩 방법을 기초 로 비트스트림 내 정보를 디코딩하고, 영상 복원에 필요한 신택스 엘리먼트의 값, 레지듀얼에 관한 변환 계수의 양자화된 값 들을 출력할 수 있다. 보다 상세하게, CABAC 엔트로피 디코딩 방법은, 비트스트림에서 각 구문 요 소에 해당하는 빈을 수신하고, 디코딩 대상 구문 요소 정보와 주변 및 디코딩 대상 블록의 디코딩 정보 혹은 이 전 단계에서 디코딩된 심볼/빈의 정보를 이용하여 문맥(context) 모델을 결정하고, 결정된 문맥 모델에 따라 빈 (bin)의 발생 확률을 예측하여 빈의 산술 디코딩(arithmetic decoding)를 수행하여 각 구문 요소의 값에 해당하 는 심볼을 생성할 수 있다. 이때, CABAC 엔트로피 디코딩 방법은 문맥 모델 결정 후 다음 심볼/빈의 문맥 모델 을 위해 디코딩된 심볼/빈의 정보를 이용하여 문맥 모델을 업데이트할 수 있다. 엔트로피 디코딩부에서 디 코딩된 정보 중 예측에 관한 정보는 예측부(인터 예측부 및 인트라 예측부)로 제공되고, 엔트로피 디 코딩부에서 엔트로피 디코딩이 수행된 레지듀얼 값, 즉 양자화된 변환 계수들 및 관련 파라미터 정보는 레 지듀얼 처리부로 입력될 수 있다. 레지듀얼 처리부는 레지듀얼 신호(레지듀얼 블록, 레지듀얼 샘플들, 레지듀얼 샘플 어레이)를 도출할 수 있다. 또한, 엔트로피 디코딩부에서 디코딩된 정보 중 필터링 에 관한 정보는 필터링부으로 제공될 수 있다. 한편, 인코딩 장치로부터 출력된 신호를 수신하는 수신부 (미도시)가 디코딩 장치의 내/외부 엘리먼트로서 더 구성될 수 있고, 또는 수신부는 엔트로피 디코딩부 의 구성요소일 수도 있다. 한편, 본 문서에 따른 디코딩 장치는 비디오/영상/픽처 디코딩 장치라고 불릴 수 있고, 상기 디코딩 장치는 정보 디코더(비디오/영상/픽처 정보 디코더) 및 샘플 디코더(비디오/영상/픽처 샘 플 디코더)로 구분할 수도 있다. 상기 정보 디코더는 상기 엔트로피 디코딩부를 포함할 수 있고, 상기 샘 플 디코더는 상기 역양자화부, 역변환부, 가산부, 필터링부, 메모리, 인터 예측부 및 인트라 예측부 중 적어도 하나를 포함할 수 있다.역양자화부에서는 양자화된 변환 계수들을 역양자화하여 변환 계수들을 출력할 수 있다. 역양자화부 는 양자화된 변환 계수들을 2차원의 블록 형태로 재정렬할 수 있다. 이 경우 상기 재정렬은 인코딩 장치에서 수 행된 계수 스캔 순서를 기반하여 재정렬을 수행할 수 있다. 역양자화부는 양자화 파라미터(예를 들어 양자 화 스텝 사이즈 정보)를 이용하여 양자화된 변환 계수들에 대한 역양자화를 수행하고, 변환 계수들(transform coefficient)를 획득할 수 있다. 역변환부에서는 변환 계수들를 역변환하여 레지듀얼 신호(레지듀얼 블록, 레지듀얼 샘플 어레이)를 획득하 게 된다. 예측부는 현재 블록에 대한 예측을 수행하고, 상기 현재 블록에 대한 예측 샘플들을 포함하는 예측된 블록 (predicted block)을 생성할 수 있다. 예측부는 엔트로피 디코딩부로부터 출력된 상기 예측에 관한 정보를 기반으로 상기 현재 블록에 인트라 예측이 적용되는지 또는 인터 예측이 적용되는지 결정할 수 있고, 구체적인 인트라/인터 예측 모드를 결정할 수 있다. 예측부는 후술하는 다양한 예측 방법을 기반으로 예측 신호를 생성할 수 있다. 예를 들어, 예측부는 하나 의 블록에 대한 예측을 위하여 인트라 예측 또는 인터 예측을 적용할 수 있을 뿐 아니라, 인트라 예측과 인터 예측을 동시에 적용할 수 있다. 이는 combined inter and intra prediction (CIIP)라고 불릴 수 있다. 또한, 예측부는 블록에 대한 예측을 위하여 인트라 블록 카피(intra block copy, IBC) 예측 모드에 기반할 수도 있고 또는 팔레트 모드(palette mode)에 기반할 수도 있다. 상기 IBC 예측 모드 또는 팔레트 모드는 예를 들어 SCC(screen content coding) 등과 같이 게임 등의 컨텐츠 영상/동영상 코딩을 위하여 사용될 수 있다. IBC는 기 본적으로 현재 픽처 내에서 예측을 수행하나 현재 픽처 내에서 참조 블록을 도출하는 점에서 인터 예측과 유사 하게 수행될 수 있다. 즉, IBC는 본 문서에서 설명되는 인터 예측 기법들 중 적어도 하나를 이용할 수 있다. 팔 레트 모드는 인트라 코딩 또는 인트라 예측의 일 예로 볼 수 있다. 팔레트 모드가 적용되는 경우 팔레트 테이블 및 팔레트 인덱스에 관한 정보가 상기 비디오/영상 정보에 포함되어 시그널링될 수 있다. 인트라 예측부는 현재 픽처 내의 샘플들을 참조하여 현재 블록을 예측할 수 있다. 상기 참조되는 샘플들은 예측 모드에 따라 상기 현재 블록의 주변(neighbor)에 위치할 수 있고, 또는 떨어져서 위치할 수도 있다. 인트 라 예측에서 예측 모드들은 복수의 비방향성 모드와 복수의 방향성 모드를 포함할 수 있다. 인트라 예측부(33 1)는 주변 블록에 적용된 예측 모드를 이용하여, 현재 블록에 적용되는 예측 모드를 결정할 수도 있다. 인터 예측부는 참조 픽처 상에서 움직임 벡터에 의해 특정되는 참조 블록(참조 샘플 어레이)을 기반으로, 현재 블록에 대한 예측된 블록을 유도할 수 있다. 이때, 인터 예측 모드에서 전송되는 움직임 정보의 양을 줄이 기 위해 주변 블록과 현재 블록 간의 움직임 정보의 상관성에 기초하여 움직임 정보를 블록, 서브블록 또는 샘 플 단위로 예측할 수 있다. 상기 움직임 정보는 움직임 벡터 및 참조 픽처 인덱스를 포함할 수 있다. 상기 움직 임 정보는 인터 예측 방향(L0 예측, L1 예측, Bi 예측 등) 정보를 더 포함할 수 있다. 인터 예측의 경우에, 주 변 블록은 현재 픽처 내에 존재하는 공간적 주변 블록(spatial neighboring block)과 참조 픽처에 존재하는 시 간적 주변 블록(temporal neighboring block)을 포함할 수 있다. 예를 들어, 인터 예측부는 주변 블록들 을 기반으로 움직임 정보 후보 리스트를 구성하고, 수신한 후보 선택 정보를 기반으로 상기 현재 블록의 움직임 벡터 및/또는 참조 픽처 인덱스를 도출할 수 있다. 다양한 예측 모드를 기반으로 인터 예측이 수행될 수 있으며, 상기 예측에 관한 정보는 상기 현재 블록에 대한 인터 예측의 모드를 지시하는 정보를 포함할 수 있다. 가산부는 획득된 레지듀얼 신호를 예측부(인터 예측부 및/또는 인트라 예측부 포함)로부터 출력 된 예측 신호(예측된 블록, 예측 샘플 어레이)에 더함으로써 복원 신호(복원 픽처, 복원 블록, 복원 샘플 어레 이)를 생성할 수 있다. 스킵 모드가 적용된 경우와 같이 처리 대상 블록에 대한 레지듀얼이 없는 경우, 예측된 블록이 복원 블록으로 사용될 수 있다. 가산부는 복원부 또는 복원 블록 생성부라고 불릴 수 있다. 생성된 복원 신호는 현재 픽처 내 다음 처리 대상 블록의 인트라 예측을 위하여 사용될 수 있고, 후술하는 바와 같이 필터링을 거쳐서 출력될 수도 있고 또 는 다음 픽처의 인터 예측을 위하여 사용될 수도 있다. 한편, 픽처 디코딩 과정에서 LMCS (luma mapping with chroma scaling)가 적용될 수도 있다. 필터링부는 복원 신호에 필터링을 적용하여 주관적/객관적 화질을 향상시킬 수 있다. 예를 들어 필터링부 는 복원 픽처에 다양한 필터링 방법을 적용하여 수정된(modified) 복원 픽처를 생성할 수 있고, 상기 수정 된 복원 픽처를 메모리, 구체적으로 메모리의 DPB에 전송할 수 있다. 상기 다양한 필터링 방법은 예 를 들어, 디블록킹 필터링, 샘플 적응적 오프셋(sample adaptive offset), 적응적 루프 필터(adaptive loopfilter), 양방향 필터(bilateral filter) 등을 포함할 수 있다. 메모리의 DPB에 저장된 (수정된) 복원 픽처는 인터 예측부에서 참조 픽쳐로 사용될 수 있다. 메모리 는 현재 픽처 내 움직임 정보가 도출된(또는 디코딩된) 블록의 움직임 정보 및/또는 이미 복원된 픽처 내 블록들의 움직임 정보를 저장할 수 있다. 상기 저장된 움직임 정보는 공간적 주변 블록의 움직임 정보 또는 시 간적 주변 블록의 움직임 정보로 활용하기 위하여 인터 예측부에 전달할 수 있다. 메모리는 현재 픽 처 내 복원된 블록들의 복원 샘플들을 저장할 수 있고, 인트라 예측부에 전달할 수 있다. 본 명세서에서, 인코딩 장치의 필터링부, 인터 예측부 및 인트라 예측부에서 설명된 실시 예들은 각각 디코딩 장치의 필터링부, 인터 예측부 및 인트라 예측부에도 동일 또는 대응 되도록 적용될 수 있다. 상술한 바와 같이 비디오 코딩을 수행함에 있어 압축 효율을 높이기 위하여 예측을 수행한다. 이를 통하여 코딩 대상 블록인 현재 블록에 대한 예측 샘플들을 포함하는 예측된 블록을 생성할 수 있다. 여기서 상기 예측된 블 록은 공간 도메인(또는 픽셀 도메인)에서의 예측 샘플들을 포함한다. 상기 예측된 블록은 인코딩 장치 및 디코 딩 장치에서 동일하게 도출되며, 상기 인코딩 장치는 원본 블록의 원본 샘플 값 자체가 아닌 상기 원본 블록과 상기 예측된 블록 간의 레지듀얼에 대한 정보(레지듀얼 정보)를 디코딩 장치로 시그널링함으로써 영상 코딩 효 율을 높일 수 있다. 디코딩 장치는 상기 레지듀얼 정보를 기반으로 레지듀얼 샘플들을 포함하는 레지듀얼 블록 을 도출하고, 상기 레지듀얼 블록과 상기 예측된 블록을 합하여 복원 샘플들을 포함하는 복원 블록을 생성할 수 있고, 복원 블록들을 포함하는 복원 픽처를 생성할 수 있다. 상기 레지듀얼 정보는 변환 및 양자화 절차를 통하여 생성될 수 있다. 예를 들어, 인코딩 장치는 상기 원본 블 록과 상기 예측된 블록 간의 레지듀얼 블록을 도출하고, 상기 레지듀얼 블록에 포함된 레지듀얼 샘플들(레지듀 얼 샘플 어레이)에 변환 절차를 수행하여 변환 계수들을 도출하고, 상기 변환 계수들에 양자화 절차를 수행하여 양자화된 변환 계수들을 도출하여 관련된 레지듀얼 정보를 (비트스트림을 통하여) 디코딩 장치로 시그널링할 수 있다. 여기서 상기 레지듀얼 정보는 상기 양자화된 변환 계수들의 값 정보, 위치 정보, 변환 기법, 변환 커널, 양자화 파라미터 등의 정보를 포함할 수 있다. 디코딩 장치는 상기 레지듀얼 정보를 기반으로 역양자화/역변환 절차를 수행하고 레지듀얼 샘플들(또는 레지듀얼 블록)을 도출할 수 있다. 디코딩 장치는 예측된 블록과 상기 레지듀얼 블록을 기반으로 복원 픽처를 생성할 수 있다. 인코딩 장치는 또한 이후 픽처의 인터 예측을 위한 참 조를 위하여 양자화된 변환 계수들을 역양자화/역변환하여 레지듀얼 블록을 도출하고, 이를 기반으로 복원 픽처 를 생성할 수 있다. 한편, 상술한 바와 같이 현재 블록에 대한 예측을 수행함에 있어 인트라 예측 또는 인터 예측을 적용할 수 있다. 이하에서는 현재 블록에 인터 예측을 적용하는 경우에 관하여 설명한다. 인코딩/디코딩 장치의 예측부(보다 구체적으로 인터 예측부)는 블록 단위로 인터 예측을 수행하여 예측 샘플들 을 도출할 수 있다. 인터 예측은 현재 픽처 이외의 픽처(들)의 데이터 요소들(예: 샘플값들, 또는 움직임 정보 등)에 의존적인 방법으로 도출되는 예측을 나타낼 수 있다. 현재 블록에 인터 예측이 적용되는 경우, 참조 픽처 인덱스가 가리키는 참조 픽처 상에서 움직임 벡터에 의해 특정되는 참조 블록(참조 샘플 어레이)을 기반으로, 현재 블록에 대한 예측된 블록(예측 샘플 어레이)을 유도할 수 있다. 이때, 인터 예측 모드에서 전송되는 움직 임 정보의 양을 줄이기 위해 주변 블록과 현재 블록 간의 움직임 정보의 상관성에 기초하여 현재 블록의 움직임 정보를 블록, 서브블록 또는 샘플 단위로 예측할 수 있다. 움직임 정보는 움직임 벡터 및 참조 픽처 인덱스를 포함할 수 있다. 움직임 정보는 인터 예측 타입(L0 예측, L1 예측, Bi 예측 등) 정보를 더 포함할 수 있다. 인 터 예측이 적용되는 경우, 주변 블록은 현재 픽처 내에 존재하는 공간적 주변 블록(spatial neighboring bloc k)과 참조 픽처에 존재하는 시간적 주변 블록(temporal neighboring block)을 포함할 수 있다. 상기 참조 블록 을 포함하는 참조 픽처와 상기 시간적 주변 블록을 포함하는 참조 픽처는 동일할 수도 있고, 다를 수도 있다. 상기 시간적 주변 블록은 동일 위치 참조 블록(collocated reference block), 동일 위치 CU(colCU) 등의 이름 으로 불릴 수 있으며, 상기 시간적 주변 블록을 포함하는 참조 픽처는 동일 위치 픽처(collocated picture, colPic)라고 불릴 수도 있다. 예를 들어, 현재 블록의 주변 블록들을 기반으로 움직임 정보 후보 리스트가 구성 될 수 있고, 현재 블록의 움직임 벡터 및/또는 참조 픽처 인덱스를 도출하기 위하여 어떤 후보가 선택(사용)되 는지를 지시하는 플래그 또는 인덱스 정보가 시그널링될 수 있다. 다양한 예측 모드를 기반으로 인터 예측이 수 행될 수 있으며, 예를 들어 스킵 모드와 머지 모드의 경우에, 현재 블록의 움직임 정보는 선택된 주변 블록의 움직임 정보와 같을 수 있다. 스킵 모드의 경우, 머지 모드와 달리 레지듀얼 신호가 전송되지 않을 수 있다. 움 직임 정보 예측(motion vector prediction, MVP) 모드의 경우, 선택된 주변 블록의 움직임 벡터를 움직임 벡터예측자(motion vector predictor)로 이용하고, 움직임 벡터 차분(motion vector difference)은 시그널링될 수 있다. 이 경우 상기 움직임 벡터 예측자 및 움직임 벡터 차분의 합을 이용하여 현재 블록의 움직임 벡터를 도출 할 수 있다. 상기 움직임 정보는 인터 예측 타입(L0 예측, L1 예측, Bi 예측 등)에 따라 L0 움직임 정보 및/또는 L1 움직임 정보를 포함할 수 있다. L0 방향의 움직임 벡터는 L0 움직임 벡터 또는 MVL0라고 불릴 수 있고, L1 방향의 움직 임 벡터는 L1 움직임 벡터 또는 MVL1이라고 불릴 수 있다. L0 움직임 벡터에 기반한 예측은 L0 예측이라고 불릴 수 있고, L1 움직임 벡터에 기반한 예측을 L1 예측이라고 불릴 수 있고, L0 움직임 벡터 및 L1 움직임 벡터 둘 다에 기반한 예측을 쌍(Bi) 예측이라고 불릴 수 있다. 여기서 L0 움직임 벡터는 참조 픽처 리스트 L0 (L0)에 연 관된 움직임 벡터를 나타낼 수 있고, L1 움직임 벡터는 참조 픽처 리스트 L1 (L1)에 연관된 움직임 벡터를 나타 낼 수 있다. 참조 픽처 리스트 L0는 현재 픽처보다 출력 순서상 이전 픽처들을 참조 픽처들로 포함할 수 있고, 참조 픽처 리스트 L1은 현재 픽처보다 출력 순서상 이후 픽처들을 포함할 수 있다. 이전 픽처들은 순방향 (참조) 픽처라고 불릴 수 있고, 이후 픽처들은 역방향 (참조) 픽처라고 불릴 수 있다. 참조 픽처 리스트 L0은 현재 픽처보다 출력 순서상 이후 픽처들을 참조 픽처들로 더 포함할 수 있다. 이 경우 참조 픽처 리스트 L0 내 에서 이전 픽처들이 먼저 인덱싱되고 이후 픽처들은 그 다음에 인덱싱될 수 있다. 참조 픽처 리스트 L1은 현재 픽처보다 출력 순서상 이전 픽처들을 참조 픽처들로 더 포함할 수 있다. 이 경우 참조 픽처 리스트 L1 내에서 이후 픽처들이 먼저 인덱싱되고 이전 픽처들은 그 다음에 인덱싱 될 수 있다. 여기서 출력 순서는 POC(picture order count) 순서(order)에 대응될 수 있다. 또한, 현재 블록에 인터 예측을 적용함에 있어, 다양한 인터 예측 모드가 사용될 수 있다. 예를 들어, 머지 모 드, 스킵 모드, MVP(motion vector prediction) 모드, 어파인(Affine) 모드, HMVP(historical motino vector prediction) 모드 등 다양한 모드가 사용될 수 있다. DMVR (Decoder side motion vector refinement) 모드, AMVR(adaptive motion vector resolution) 모드, Bi-directional optical flow (BDOF) 등이 부수적인 모드로 더 사용될 수 있다. 어파인 모드는 어파인 움직임 예측(affine motion prediction) 모드라고 불릴 수도 있다. MVP 모드는 AMVP(advanced motion vector prediction) 모드라고 불릴 수도 있다. 본 문서에서 일부 모드 및/또 는 일부 모드에 의하여 도출된 움직임 정보 후보는 다른 모드의 움직임 정보 관련 후보들 중 하나로 포함될 수 도 있다. 현재 블록의 인터 예측 모드를 가리키는 예측 모드 정보가 인코딩 장치로부터 디코딩 장치로 시그널링될 수 있 다. 이때, 예측 모드 정보는 비트스트림에 포함되어 디코딩 장치에 수신될 수 있다. 예측 모드 정보는 다수의 후보 모드들 중 하나를 지시하는 인덱스 정보를 포함할 수 있다. 또는, 플래그 정보의 계층적 시그널링을 통하 여 인터 예측 모드를 지시할 수도 있다. 이 경우 예측 모드 정보는 하나 이상의 플래그들을 포함할 수 있다. 예 를 들어, 스킵 플래그를 시그널링하여 스킵 모드 적용 여부를 지시하고, 스킵 모드가 적용 되지 않는 경우에 머 지 플래그를 시그널링하여 머지 모드 적용 여부를 지시하고, 머지 모드가 적용 되지 않는 경우에 MVP 모드가 적 용되는 것으로 지시하거나 추가적인 구분을 위한 플래그를 더 시그널링할 수도 있다. 어파인 모드는 독립적인 모드로 시그널링될 수도 있고, 또는 머지 모드 또는 MVP 모드 등에 종속적인 모드로 시그널링될 수도 있다. 예 를 들어, 어파인 모드는 어파인 머지 모드 및 어파인 MVP 모드를 포함할 수 있다. 또한, 현재 블록에 인터 예측을 적용함에 있어, 현재 블록의 움직임 정보를 이용할 수 있다. 인코딩 장치는 움 직임 추정(motion estimation) 절차를 통하여 현재 블록에 대한 최적의 움직임 정보를 도출할 수 있다. 예를 들 어, 인코딩 장치는 현재 블록에 대한 원본 픽처 내 원본 블록을 이용하여 상관성이 높은 유사한 참조 블록을 참 조 픽처 내의 정해진 탐색 범위 내에서 분수 픽셀 단위로 탐색할 수 있고, 이를 통하여 움직임 정보를 도출할 수 있다. 블록의 유사성은 위상(phase) 기반 샘플 값들의 차를 기반으로 도출할 수 있다. 예를 들어, 블록의 유 사성은 현재 블록(or 현재 블록의 템플릿)과 참조 블록(or 참조 블록의 템플릿) 간 SAD(sum of absolute differences)를 기반으로 계산될 수 있다. 이 경우 탐색 영역 내 SAD가 가장 작은 참조 블록을 기반으로 움직임 정보를 도출할 수 있다. 도출된 움직임 정보는 인터 예측 모드 기반으로 여러 방법에 따라 디코딩 장치로 시그 널링될 수 있다. 상기와 같이 인터 예측 모드에 따라 도출된 움직임 정보를 기반으로 현재 블록에 대한 예측된 블록을 도출할 수 있다. 예측된 블록은 현재 블록의 예측 샘플들(예측 샘플 어레이)를 포함할 수 있다. 현재 블록의 움직임 벡터 (MV)가 분수 샘플 단위를 가리키는 경우, 보간(interpolation) 절차가 수행될 수 있으며, 이를 통하여 참조 픽 처 내에서 분수 샘플 단위의 참조 샘플들을 기반으로 현재 블록의 예측 샘플들이 도출될 수 있다. 현재 블록에 어파인(Affine) 인터 예측이 적용되는 경우, 샘플/서브블록 단위 MV를 기반으로 예측 샘플들을 생성할 수 있다. 쌍예측이 적용되는 경우, L0 예측(즉, 참조 픽처 리스트 L0 내 참조 픽처와 MVL0를 이용한 예측)을 기반으로 도출된 예측 샘플들과 L1 예측(즉, 참조 픽처 리스트 L1 내 참조 픽처와 MVL1을 이용한 예측)을 기반으로 도출된 예측 샘플들의 (위상에 따른) 가중합 또는 가중평균을 통하여 도출된 예측 샘플들이 현재 블록의 예측 샘플들로 이용될 수 있다. 쌍예측이 적용되는 경우, L0 예측에 이용된 참조 픽처와 L1 예측에 이용된 참조 픽처가 현재 픽처를 기준으로 서로 다른 시간적 방향에 위치하는 경우, (즉, 쌍예측이면서 양방향 예측에 해당하는 경우) 이를 true 쌍예측이라고 부를 수 있다. 도출된 예측 샘플들을 기반으로 복원 샘플들 및 복원 픽처가 생성될 수 있고, 이후 인루프 필터링 등의 절차가 수행될 수 있음은 전술한 바와 같다. 한편, 스킵 모드 및/또는 머지 모드는 MVD(Motion Vector Difference) 없이 주변 블록의 움직임 벡터를 기반으 로 현재 블록의 움직임을 예측하므로, 움직임 예측에 있어서 한계를 나타낸다. 스킵 모드 및/또는 머지 모드의 한계를 개선하기 위해, DMVR(Decoder-side Motion Vector Refinement), BDOF(Bi-directional optical flow) 모드 등을 적용하여 움직임 벡터를 리파인(refine)할 수 있다. DMVR, BDOF 모드는 현재 블록에 true 쌍예측이 적용되는 경우에 사용될 수 있다. 도 4는 true 쌍예측에서 DMVR(Decoder-side Motion Vector Refinement)을 수행하는 과정의 일 실시예를 설명하 기 위한 도면이다. DMVR은 디코더 측에서 주변 블록의 움직임 정보를 리파인(refinement)하여 움직임 예측을 수행하는 방법이다. DMVR이 적용되는 경우, 디코더는 머지(merge)/스킵(skip) 모드에서 주변 블록의 움직임 정보을 이용하여 생성된 템플릿(template)을 기반으로 cost 비교를 통해 리파인된 움직임 정보를 유도할 수 있다. 이 경우, 부가적인 시 그널링 정보 없이 움직임 예측의 정밀도를 높이고 압축 성능을 향상시킬 수 있다. 본 문서에서, 설명의 편의를 위해 디코딩 장치를 위주로 설명하나, 본 문서의 실시예에 따른 DMVR은 인코딩 장 치에서도 동일한 방법으로 수행될 수 있다. 도 4를 참조하면, 디코딩 장치는 list0 및 list1 방향의 초기 움직임 벡터(또는 움직임 정보)(예: MV0 및 MV1) 에 의해 식별되는 예측 블록들(즉, 참조 블록들)을 도출하고, 도출된 예측 블록들을 가중합(예컨대, 평균)하여 템플릿(또는 bilateral template)을 생성할 수 있다(step 1). 여기서, 초기 움직임 벡터(MV0 및 MV1)는 머지/ 스킵 모드에서 주변 블록의 움직임 정보를 이용하여 유도된 움직임 벡터를 나타낼 수 있다. 그리고, 디코딩 장치는 템플릿 매칭(template matching) 동작을 통해 템플릿과 참조 픽처의 샘플 영역간 차분값 을 최소화하는 움직임 벡터(예: MV0' 및 MV1')를 유도할 수 있다(step 2). 여기서, 샘플 영역은 참조 픽쳐 내에 서 초기 예측 블록의 주변 영역을 나타내며, 샘플 영역은 주변 영역, 참조 영역, 탐색 영역, 탐색 범위, 탐색 공간 등으로 지칭될 수 있다. 템플릿 매칭 동작은 템플릿과 참조 픽처의 샘플 영역간의 cost 측정 값을 계산하 는 동작을 포함할 수 있다. 예를 들어, cost 측정에는 SAD(sum of absolute differences)가 이용될 수 있다. 일 예로, cost 함수로서 정규화된 SAD가 사용될 수 있다. 이때, matching cost는 SAD(T - mean(T), 2 * P[x] - 2 * mean(P[x]))로 주어질 수 있다. 여기서 T는 템플릿을 나타내고, P[x]는 탐색영역 내 블록을 나타낸다. 그리 고, 2개의 참조 픽처 각각에 대하여 최소 템플릿 cost를 산출하는 움직임 벡터는 갱신된 움직임 벡터(초기 움직 임 벡터를 대체하는)로서 고려될 수 있다. 도 4에 도시된 바와 같이, 디코딩 장치는 갱신된 움직임 벡터 MV0' 및 MV1'를 이용하여 최종 양방향 예측 결과(즉, 최종 양방향 예측 블록)를 생성할 수 있다. 일 실시예로서, 갱 신된(또는 새로운) 움직임 벡터 유도를 위한 multi-iteration이 최종 양방향 예측 결과 획득에 사용될 수 있다. 일 실시예에서, 디코딩 장치는 초기 움직임 보상 예측(즉, 종래의 머지/스킵 모드를 통한 움직임 보상 예측)의 정확도를 향상시키기 위하여 DMVR 프로세스를 호출할 수 있다. 예를 들어, 디코딩 장치는 현재 블록의 예측 모 드가 머지 모드 또는 스킵 모드이고, 현재 블록에 디스플레이 순서상 현재 픽처를 기준으로 양방향의 참조 픽처 가 반대 방향에 있는 양방향 쌍예측이 적용되는 경우, DMVR 프로세스를 수행할 수 있다. 도 5는 SAD(sum of absolute differences)를 사용하여 DMVR(Decoder-side Motion Vector Refinement)을 수행하 는 과정의 일 실시예를 설명하기 위한 도면이다. 상술한 바와 같이 디코딩 장치는 DMVR을 수행함에 있어서, SAD를 이용하여 matching cost를 측정할 수 있다. 일 실시예로, 도 5에서는 템플릿을 생성하지 않고 두 참조 픽처 내 예측 샘플간 MRSAD(Mean Sum of Absolute Difference)를 계산하여 움직임 벡터를 리파인하는 방법을 설명한다. 즉, 도 5의 방법은 MRSAD를 이용하는 양방 향 매칭(bilateral matching)의 일 실시예를 나타낸다. 도 5를 참조하면, 디코딩 장치는 list0(L0) 방향의 움직임 벡터(MV0)에 의해 지시되는 화소(샘플)의 인접 화소 를 L0 참조 픽처 상에서 도출하고, list1(L1) 방향의 움직임 벡터(MV1)에 의해 지시되는 화소(샘플)의 인접 화 소를 L1 참조 픽처 상에서 도출할 수 있다. 그리고, 디코딩 장치는 L0 참조 픽처 상에서 도출된 인접 화소를 지 시하는 움직임 벡터에 의해 식별되는 L0 예측 블록(즉, L0 참조 블록)과, L1 참조 픽처 상에서 도출된 인접 화 소를 지시하는 움직임 벡터에 의해 식별되는 L1 예측 블록(즉, L1 참조 블록) 간의 MRSAD를 계산하여 matching cost를 측정할 수 있다. 이때, 디코딩 장치는 최소 cost를 갖는 탐색 지점(즉, L0 예측 블록과 L1 예측 블록 간 의 최소 SAD를 갖는 탐색 영역)을 리파인된 움직임 벡터 쌍으로 선택할 수 있다. 즉, 리파인된 움직임 벡터 쌍 은 L0 참조 픽처에서 최소 cost를 갖는 화소 위치(L0 예측 블록)를 가리키는 리파인된 L0 움직임 벡터와, L1 참 조 픽처에서 최소 cost를 갖는 화소 위치(L1 예측 블록)를 가리키는 리파인된 L1 움직임 벡터를 포함할 수 있다. 실시예로, matching cost를 계산함에 있어, 참조 픽처의 탐색 영역이 설정된 후 단방향 예측은 regular 8 tap DCTIF interpolation filter를 사용하여 수행될 수 있다. 또한, 일 예로, MRSAD 계산은 16 비트 정밀도가 사용 될 수 있고, 내부 버퍼를 고려하여 MRSAD 계산 이전에 클리핑 및/또는 반올림 연산이 적용되지 않을 수 있다. 상술한 바와 같이 현재 블록에 true 쌍예측이 적용되는 경우, 쌍예측 신호를 리파인하기 위하여 BDOF가 사용될 수 있다. BDOF(Bi-directional optical flow)는 현재 블록에 쌍예측이 적용되는 경우 개선된 움직임 정보를 계 산하고 이를 기반으로 예측 샘플들을 생성하기 위해 사용될 수 있다. 예를 들어, BDOF는 4x4 서브블록(sub- block) 레벨에서 적용될 수 있다. 즉, BDOF는 현재 블록 내 4x4 서브블록 단위로 수행될 수 있다. 또는, BDOF는 루마 성분에 대하여만 적용될 수 있다. 또는, BDOF는 크로마 성분에 대하여만 적용될 수도 있고, 루마 성분 및 크로마 성분에 대하여 적용될 수도 있다. BDOF 모드는 그 명칭에서 나타내는 바와 같이 오브젝트의 움직임이 smooth하다고 가정하는 광학 흐름(optical flow) 개념을 기반으로 한다. 4x4 서브블록 각각에 대해, L0 및 L1 예측 샘플들 간의 차이값을 최소화함으로써 움직임 리파인먼트 (vx, vy)가 계산될 수 있다. 그리고 움직임 리파인먼트는 4x4 서브블록에서 쌍예측 샘플 값들 을 조정하기 위해 사용될 수 있다. 보다 구체적으로, BDOF를 적용하여 예측 신호를 리파인먼트함에 있어서, 먼저 L0 예측 샘플들 및 L1 예측 샘플 들의 수평 및 수직 그라디언트(gradient)를 계산할 수 있다. 이때, 수평 및 수직 그라디언트는 예측 샘플 (i, j)의 주변에 위치한 2개의 주변 샘플들 간의 차이를 기반으로 계산될 수 있고, 다음 수학식 1과 같이 계산될 수 있다. 수학식 1"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "여기서, 는 수평 그라디언트이고, 는 수직 그라디언트이다. 또한, 는 리스트 k (k= 0, 1)에서 예측 샘플의 좌표 (i, j)에서의 예측 값이다. 다음으로, 수평 및 수직 그라디언트의 auto-correlation과 cross-correlation을 다음 수학식 2 및 수학식 3과 같이 계산할 수 있다. 수학식 2"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "수학식 3"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "여기서, 는 4x4 서브블록 주변의 6x6 윈도우이다. 다음으로, 움직임 리파인먼트 (vx, vy)가 auto-correlation과 cross-correlation을 이용하여 계산될 수 있고, 다음 수학식 4와 같이 계산될 수 있다. 수학식 4"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "여기서, 이고, 이고, 이고, 은 바닥 함수 (floor function)이다. 다음으로, 상기 그라디언트와 움직임 리파인먼트를 기반으로 다음 수학식 5에서와 같이 BDOF 예측 샘플의 리파 인먼트를 위한 b(x, y)가 계산될 수 있다. 수학식 5"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "그리고 마지막으로, BDOF 예측 샘플들(즉, BDOF를 적용하여 리파된 예측 샘플 값들)이 다음 수학식 6과 같이 계 산될 수 있다. 수학식 6"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "한편, 상술한 DMVR 및 BDOF은 true 쌍예측을 적용하는 경우 (이때, true 쌍예측은 현재 블록의 픽처를 기준으로 다른 방향의 참조 픽처에서 움직임 예측/보상하는 경우를 나타낸다) 움직임 정보를 리파인하여 예측을 수행하는 기술로서, 픽처 내 오브젝트의 움직임이 일정 속도, 일정한 방향으로 이루어지는 경우를 가정하고 있다는 점에 서 유사한 개념의 리파인먼트 기술임을 알 수 있다. 다만, true 쌍예측이 수행되는 경우, DMVR을 적용하기 위한 조건과 BDOF를 적용하기 위한 조건이 다르기 때문에, 각 기술별로 반복적으로 여러 번의 조건 체크를 수행하는 과정을 거쳐야 한다. 이에, 본 문서에서는 현재 블록에 적용되는 예측 모드를 결정함에 있어서 조건 체크를 수 행하는 과정을 개선함으로써, 디코더 복잡도 및 성능 면에서 효율을 향상시킬 수 있는 방법을 제안한다. 다음 표 1은 기존의 true 쌍예측 시에 DMVR을 적용하기 위한 조건을 나타낸 것이다. 아래 나열한 조건들을 모두 만족할 때 DMVR을 적용할 수 있다. 표 1 상기 표 1을 참조하면, 1) SPS(Sequence Parameter Set) 신택스에서 시그널링되는 플래그 정보(예: sps_dmvr_enabled_flag)를 기반으로 DMVR 적용 여부를 결정할 수 있다. 여기서, 플래그 정보(예: sps_dmvr_enabled_flag)는 true 쌍예측 기반 DMVR이 가용(enable)한지 여부를 나타낼 수 있다. 예컨대, sps_dmvr_enabled_flag가 1인 경우 (즉, true 쌍예측 기반 DMVR이 가용한 경우), DMVR 가용 여부 조건을 만족 하는 것으로 판단할 수 있다. 2) 머지 모드/스킵 모드를 사용하여 인터 예측을 수행하는지를 나타내는 플래그 정보(예: merge_flag)를 기반으 로 DMVR 적용 여부를 결정할 수 있다. 예컨대, merge_flag가 1인 경우 (즉, 머지 모드/스킵 모드를 사용하여 인 터 예측을 수행하는 경우), 머지 모드/스킵 모드 적용 여부 조건을 만족하는 것으로 판단할 수 있다. 3) MMVD(merge mode with motion vector difference) 모드를 사용하여 인터 예측을 수행하는지 여부를 나타내 는 플래그 정보(예: mmvd_flag)를 기반으로 DMVR 적용 여부를 결정할 수 있다. 예컨대, mmvd_flag가 0인 경우 (즉, MMVD 모드를 사용하지 않는 경우), MMVD 모드 적용 여부 조건을 만족하는 것으로 판단할 수 있다. 4) 양방향 예측(쌍예측)을 사용하는지 여부를 기반으로 DMVR 적용 여부를 결정할 수 있다. 여기서, 양방향 예측 은 현재 픽처를 기준으로 서로 다른 방향에 존재하는 참조 픽처들을 기반으로 수행되는 인터 예측을 나타낼 수 있다. 예를 들어, predFlagL0[0][0]=1이고 predFlagL0[1][1]=1인 경우 양방향 예측이 적용되는 것으로 판단할 수 있고, 양방향 예측 여부 조건을 만족하는 것으로 판단할 수 있다. 5) true 쌍예측이고 현재 픽처와 양방향의 참조 픽처 간의 거리가 상호 동일한지 여부를 기반으로 DMVR 적용 여 부를 결정할 수 있다. 즉, 현재 픽처와 LO 참조 픽처(즉, 참조 픽처 리스트 L0 내의 참조 픽처) 간의 거리와, 현재 픽처와 L1 참조 픽처(즉, 참조 픽처 리스트 L1 내의 참조 픽처) 간의 거리가 상호 동일한지 여부를 판단할 수 있다. 예를 들어, DiffPicOrderCnt(currPic, RefPicList0 [refIdxL0]) - DiffPicOrderCnt(currPic, RefPicList1 [ refIdxL1 ] ) = 0인 경우, true 쌍예측이고 현재 픽처와 양방향의 참조 픽처 간의 거리가 상호 동일하다고 판단하여, 양방향의 참조 픽처 거리가 동일한지 여부 조건을 만족하는 것으로 판단할 수 있다. 6) 현재 블록의 길이(Height)가 임계값(threshold)보다 큰지 여부를 기반으로 DMVR 적용 여부를 결정할 수 있다. 예를 들어, 현재 블록의 길이가 8 이상인 경우, 현재 블록 크기(길이) 조건을 만족하는 것으로 판단할 수 있다. 7) 현재 블록의 크기가 임계값(threshold)보다 큰지 여부를 기반으로 DMVR 적용 여부를 결정할 수 있다. 예를 들어, 현재 블록의 크기, 즉 길이(Height)*너비(Width)가 64 이상인 경우, 현재 블록 크기(길이*너비) 조건을 만족하는 것으로 판단할 수 있다. 디코딩 장치는 상기 표 1의 조건들 1) 내지 7)을 만족하는지 여부에 따라 DMVR 적용 여부를 결정할 수 있다. 즉, 디코딩 장치는 상기 표 1의 조건들 1) 내지 7)이 모두 만족되는 경우에 DMVR을 적용하여 true 쌍예측을 수 행할 수 있고, 상기 표 1의 조건들 중 하나라도 만족되지 못하는 경우에 DMVR을 적용하지 않는다. 다음 표 2는 기존의 true 쌍예측 시에 BDOF를 적용하기 위한 조건을 나타낸 것이다. 아래 나열한 조건들을 모두 만족할 때 BDOF를 적용할 수 있다.표 2"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "상기 표 2를 참조하면, 1) SPS(Sequence Parameter Set) 신택스에서 시그널링되는 플래그 정보(예: sps_bdof_enabled_flag)를 기반으로 BDOF 적용 여부를 결정할 수 있다. 여기서, 플래그 정보(예: sps_bdof_enabled_flag)는 true 쌍예측 기반 BDOF가 가용(enable)한지 여부를 나타낼 수 있다. 예컨대, sps_bdof_enabled_flag가 1인 경우 (즉, true 쌍예측 기반 BDOF이 가용한 경우), BDOF 가용 여부 조건을 만족 하는 것으로 판단할 수 있다. 2) 양방향 예측을 사용하는지 여부를 기반으로 BDOF 적용 여부를 결정할 수 있다. 여기서, 양방향 예측은 현재 픽처를 기준으로 서로 다른 방향에 존재하는 참조 픽처들을 기반으로 수행되는 인터 예측을 나타낼 수 있다. 예 를 들어, predFlagL0 및 predFlagL1이 모두 1인 경우 양방향 예측이 적용되는 것으로 판단할 수 있고, 양방향 예측 여부 조건을 만족하는 것으로 판단할 수 있다. 3) true 쌍예측인지 여부를 기반으로 BDOF 적용 여부를 결정할 수 있다. 즉, 현재 픽처를 기준으로 LO 참조 픽 처(즉, 참조 픽처 리스트 L0 내의 참조 픽처)와 L1 참조 픽처(즉, 참조 픽처 리스트 L1 내의 참조 픽처)가 시간 적으로 서로 다른 방향에 위치하는지 여부를 판단할 수 있다. 예를 들어, DiffPicOrderCnt( currPic, refPicList0[refIdxL0] ) * DiffPicOrderCnt( currPic, refPicList1[refIdxL1] )가 0보다 작은 경우, 현재 픽 처를 기준으로 양방향의 참조 픽처가 서로 다른 방향에 위치하는 것으로 판단하여, true 쌍예측 여부 조건을 만 족하는 것으로 판단할 수 있다. 4) 어파인 모드가 사용되는지 여부를 기반으로 BDOF 적용 여부를 결정할 수 있다. 여기서, 어파인 모드가 사용 되는지 여부는 MotionModelIdc를 유도함으로써 판단할 수 있다. 예를 들어, 유도된 MotionModelIdc가 0인 경우 어파인 모드가 사용되지 않는 것으로 판단할 수 있고, 이 경우 어파인 모드 적용 여부 조건을 만족하는 것으로 판단할 수 있다. 5) 머지 모드에서의 인터 예측이 서브블록 단위로 수행되는지 여부를 나타내는 플래그 정보(예: merge_subblock_flag)를 기반으로 BDOF 적용 여부를 결정할 수 있다. 예컨대, merge_subblock_flag가 0인 경우 (즉, 서브블록 단위로 머지 모드가 적용되지 않는 경우), 서브블록 기반 머지 모드 여부 조건을 만족하는 것으 로 판단할 수 있다. 6) GBi가 존재하는지 여부를 기반으로 BDOF 적용 여부를 결정할 수 있다. 여기서, GBi가 존재하는지 여부는 GBi 인덱스 정보(예: GbiIdx)를 기반으로 판단할 수 있다. 예를 들어, GbiIdx가 0인 경우 (즉, GbiIdx가 디폴트인 경우), GBi 여부 조건을 만족하는 것으로 판단할 수 있다. 7) 현재 블록이 루마(Luma) 성분을 포함하는 루마 블록인지 여부를 기반으로 BDOF 적용 여부를 결정할 수 있다. 예컨대, 루마 블록인지를 나타내는 인덱스(예: cIdx)가 0인 경우 (즉, 루마 블록인 경우), 루마 블록 여부 조건 을 만족하는 것으로 판단할 수 있다. 디코딩 장치는 상기 표 2의 조건들 1) 내지 7)을 만족하는지 여부에 따라 BDOF 적용 여부를 결정할 수 있다. 즉, 디코딩 장치는 상기 표 2의 조건들 1) 내지 7)이 모두 만족되는 경우에 BDOF을 적용하여 true 쌍예측을 수 행할 수 있고, 상기 표 2의 조건들 중 하나라도 만족되지 못하는 경우에 BDOF을 적용하지 않는다. 여기서, 상술한 GBi는 L0 예측 및 L1 예측에 다른 가중치(weight)를 적용할 수 있는 일반적인 쌍예측 (generalized bi-prediction)를 나타낼 수 있으며, 예컨대 GbiIdx를 사용하여 나타낼 수 있다. GbiIdx는 쌍예 측인 경우에 존재할 수 있으며, 쌍예측 가중치 인덱스(bi-prediction weight index)를 나타낼 수 있다. 본 문서 에서 움직임 정보는 GbiIdx를 더 포함할 수 있다. 예를 들어, GbiIdx는 머지 모드의 경우에 주변 블록으로부터 도출될 수 있고, 또는 MVP 모드의 경우 GbiIdx 신택스 요소(예: gbi_idx)를 통하여 인코딩 장치에서 디코딩 장 치로 시그널링될 수 있다. 일례로, GbiIdx는 L1 예측에 적용되는 가중치 w를 지시할 수 있고, 이 경우 L0 예측 에는 (1-w)의 가중치가 적용될 수 있다. 다른 예로, GbiIdx는 L0 예측에 적용되는 가중치 w를 지시할 수 있고, 이 경우 L1 예측에는 (1-w)의 가중치가 적용될 수 있다. GbiIdx가 가리키는 가중치는 다양하게 구성될 수 있으 며, 예를 들어 다음 표 3 및 표 4와 같이 구성될 수 있다. 표 3"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "표 4"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 10, "content": "상기 표 3 및 상기 표 4를 참조하면, w1의 가중치는 L1 예측에 적용되는 가중치를 나타낼 수 있으며, GbiIdx 값 을 통해 L1 예측에 적용되는 가중치 w1를 지시할 수 있다. 예를 들어, 표 3의 실시예에 따르면, GbiIdx의 값이 0을 나타내는 경우, L1 예측에는 1/2 가중치를 적용하고, L0 예측에는 (1 - w1) 의 값인 1/2 가중치를 적용할 수 있다. 실시예에 따라, w1의 가중치는 L0 예측에 적용되는 가중치를 나타낼 수도 있으며, 이 경우 GbiIdx 값 을 통해 L0 예측에 적용되는 가중치 w1를 지시할 수 있다. 상술한 바와 같이, DMVR과 BDOF의 적용 조건이 일부는 동일하고 일부는 유사하거나 다르다. 기존의 방식에서는 조건이 동일한 경우에도 각 기술별로 조건 체크를 수행하게 되므로, 쌍예측 수행을 위한 복잡도가 증가하게 된 다. 이에, 본 문서에서는 쌍예측 시에 DMVR과 BDOF을 적용하기 위한 효율적인 조건을 제안한다. 머지/스킵 모드는 AMVP 모드와 비교할 때 상대적으로 움직임 정확도가 낮으므로, DMVR 방법을 이용하여 움직임 정보를 리파인하는 것이 성능 면에서 효과적이다. 그러나, BDOF 모드는 DMVR과 달리 머지/스킵 모드뿐만 아니라 AMVP 모드일 때도 적용하고 있는데, 이와 같이 AMVP 모드에서 BDOF를 적용하는 경우 성능 대비 BDOF 수행을 위 한 복잡도가 증가할 수 있다. 따라서, 본 실시예에서는 DMVR과 동일하게 BDOF의 경우도 머지/스킵 모드에서 적 용하는 방안을 제안한다. 이 경우 본 문서에서 제안하는 일 실시예로, BDOF의 적용 조건은 다음 표 5에 제시된 조건들을 포함할 수 있다. 표 5"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 11, "content": "상기 표 5를 참조하면, 머지 모드/스킵 모드를 사용하여 인터 예측을 수행하는지를 나타내는 플래그 정보(예: merge_flag)를 기반으로 BDOF 적용 여부를 결정할 수 있다. 예컨대, merge_flag가 1인 경우 (즉, 머지 모드/스 킵 모드를 사용하여 인터 예측을 수행하는 경우), 머지 모드/스킵 모드 적용 여부 조건을 만족하는 것으로 판단 할 수 있다. 따라서, DMVR과 동일하게 BDOF의 경우도 머지/스킵 모드일 때 적용될 수 있다. 즉, 본 실시예에서는 상기 머지/스킵 모드인 경우에 적용하는 조건과 함께, BDOF가 가용한 경우에 적용하는 조 건, 양방향 예측인 경우에 적용하는 조건, true 쌍예측인 경우에 적용하는 조건, 어파인 예측이 아닌 경우에 적 용하는 조건, 서브블록 기반 머지 모드가 아닌 경우에 적용하는 조건, GBi 인덱스가 디폴트인 경우에 적용하는 조건, 루마 블록인 경우에 적용하는 조건을 기반으로 BDOF 적용 여부를 판단할 수 있다. 따라서, 디코딩 장치는 상기 표 5에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 5에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 5의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 5에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 한편, 본 실시예에서 나열한 조건들 중 상기 표 1 및 표 2에서 설명한 조건과 동일한 경우에는 구체적인 동작이 나 의미가 동일하게 적용되므로, 각 조건에 대한 구체적인 설명을 생략하도록 한다. 또한 후술하는 실시예들에 서도 중복되는 내용은 생략하도록 한다. 인코딩/디코딩 장치의 경우 다양한 하드웨어를 사용하여 구성될 수 있으며, 성능 대비 복잡도 비율의 선호가 다 를 수 있다. 이에, 본 실시예에서는 머지/스킵 모드뿐만 아니라 AMVP 모드에서도 DMVR을 적용하여 움직임 정보 를 리파인할 수 있는 방안을 제안한다. 이 경우 본 문서에서 제안하는 일 실시예로, DMVR의 적용 조건은 다음 표 6에 제시된 조건들을 포함할 수 있다. 표 6"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 12, "content": "상기 표 6을 참조하면, 머지 모드/스킵 모드를 사용하여 인터 예측을 수행하는지를 나타내는 플래그 정보(예: merge_flag)를 기반으로 DMVR 적용 여부를 결정하는 과정이 생략될 수 있다. 이와 같이, 머지 모드/스킵 모드의 적용 여부 조건을 생략함으로써, 머지 모드/스킵 모드인 경우뿐만 아니라 AMVP 모드에서도 DMVR을 적용할 수 있 다. 상기 표 6에 따르면, DMVR이 가용한 경우에 적용하는 조건, MMVD 모드가 사용되지 않는 경우에 적용하는 조건, 양방향 예측인 경우에 적용하는 조건, 현재 픽처와 양방향 참조 픽처와의 거리가 상호 동일한 true 쌍예측인 경 우에 적용하는 조건, 현재 블록의 길이가 8이상인 경우에 적용하는 조건, 현재 블록의 크기(길이*너비)가 64 이 상인 경우에 적용하는 조건을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 6에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경 우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 6에 나열된 조건 중 하나라도 만족되지 못하 는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 6의 조건들은 인코딩 장치에서도 적용 될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 6에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 한편, 본 문서의 일 실시예로, DMVR 및 BDOF는 모두 일반적인 머지(normal merge) 모드에 적용될 수 있다. 즉, ATMVP(advanced temporal motion vector prediction) 모드가 아니고 어파인 모드가 아니고 CPR이 아닌 경우 DMVR 및 BDOF을 적용할 수 있다. 이 경우 DMVR의 적용 조건은 다음 표 7에 제시된 조건들을 포함할 수 있다. 표 7"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 13, "content": "상기 표 7을 참조하면, 어파인 모드가 사용되지 않는 경우에 적용하는 조건(예: MotionModelIdc가 0인 경우), 서브블록 기반 머지 모드가 아닌 경우에 적용하는 조건(예: merge_subblock_flag가 0인 경우)을 만족하는지를 판단함으로써, DMVR을 일반적인 머지 모드인 경우에 한해 적용할 수 있다. 또한, 본 실시예에서는 상기 어파인 모드 여부 조건, 서브블록 기반 머지 모드 여부 조건과 함께, DMVR이 가용 한 경우에 적용하는 조건, 머지 모드/스킵 모드인 경우에 적용하는 조건, MMVD 모드가 사용되지 않는 경우에 적 용하는 조건, 양방향 예측인 경우에 적용하는 조건, 현재 픽처와 양방향 참조 픽처와의 거리가 상호 동일한 true 쌍예측인 경우에 적용하는 조건, 현재 블록의 길이가 8이상인 경우에 적용하는 조건, 현재 블록의 크기(길 이*너비)가 64 이상인 경우에 적용하는 조건을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 7에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경 우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 7에 나열된 조건 중 하나라도 만족되지 못하 는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 7의 조건들은 인코딩 장치에서도 적용 될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 7의 적용 조건들 중에서 서브블록 기반 머지 모드 적용 여부 조건(예: merge_subblock_flag)은 기존의 DMVR 적용 조건들 중 중복되는 조건을 포함하고 있다. 따라서, 본 문서의 일 실시예로, 서브블록 기반 머지 모 드 적용 여부 조건(예: merge_subblock_flag)과 중복되는 조건을 제거할 수 있다. 이 경우 다음 표 8에 제안된 것과 같이 해당 조건이 제거될 수 있다. 표 8"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 14, "content": "상기 표 8을 참조하면, 서브블록 기반 머지 모드는 현재 블록의 크기가 8X8 이상인 경우에 적용될 수 있다. 따 라서, 서브블록 기반 머지 모드 적용 여부 조건(예: merge_subblock_flag = 0)은 현재 블록의 크기와 관련된 조 건을 포함하고 있는 것이므로, 기존의 DMVR의 적용 조건들 중에서 현재 블록의 크기와 관련된 조건(예: CbHeight, CbHeight*CbWidth)을 제외시킬 수 있다. 예를 들어, 현재 블록의 길이가 8 이상인지 여부 조건, 현재 블록의 길이*너비가 64 이상인지 여부 조건은 생략하고 상기 표 8에 나열된 나머지 조건들을 이용하여 DMVR 적 용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 8에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경 우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 8에 나열된 조건들 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 8의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 7 또는 상기 표 8에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독립 적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 본 문서의 일 실시예로, 저복잡도에서 움직임 벡터의 정확도를 높이기 위해서 블록의 크기가 작은 경우에는 DMVR 및 BDOF와 같은 리파인 기술을 적용하지 않을 수 있다. 기존의 방식에서는 현재 블록이 8X8보다 크거나 같 은 블록인 경우에 리파인 기술을 적용하고 있는데, 이 중 DMVR의 경우 현재 블록의 크기가 클 때 16X16 단위로 나누어 리파인을 적용하므로 16X16보다 작은 블록에 대해서는 DMVR을 적용하지 않을 수 있다. 이 경우 DMVR의 적용 조건은 다음 표 9에 제시된 조건들을 포함할 수 있다. 표 9"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 15, "content": "상기 표 9를 참조하면, 현재 블록의 크기와 관련된 조건들(예: CbHeight, CbWidth)을 변경함으로써, 16X16보다 작은 블록에 대해서 DMVR을 적용하지 않도록 할 수 있다. 예를 들어, 현재 블록의 길이(예: CbHeight)가 16 이 상인 경우에 적용하는 조건과 현재 블록의 너비(예: CbWidth)가 16 이상인 경우에 적용하는 조건을 사용할 수 있다. 이러한 현재 블록의 크기와 관련된 적용 조건들을 만족한 경우 (즉, 현재 블록의 크기가 16X16 이상인 경 우) DMVR을 적용하고, 상기와 같은 현재 블록의 크기와 관련된 적용 조건들을 만족하지 않는 경우 (즉, 현재 블 록의 크기가 16X16 보다 작은 경우) DMVR을 적용하지 않을 수 있다. 또한, 본 실시예에서는 현재 블록의 크기와 관련된 조건들(예: CbHeight, CbWidth)과 함께, 상기 표 9에서 나열 된 나머지 적용 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 9에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경 우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 9에 나열된 조건 중 하나라도 만족되지 못하 는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 9의 조건들은 인코딩 장치에서도 적용 될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 본 문서의 일 실시예로, 현재 블록이 16X16보다 작은 블록인 경우 DMVR뿐만 아니라 BDOF를 적용하지 않을 수 있 다. 이 경우 BDOF의 적용 조건은 다음 표 10에 제시된 조건들을 포함할 수 있다. 표 10"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 16, "content": "상기 표 10을 참조하면, 현재 블록의 크기와 관련된 조건들(예: CbHeight, CbWidth)을 변경함으로써, 16X16보다 작은 블록에 대해서 BDOF을 적용하지 않도록 할 수 있다. 예를 들어, 현재 블록의 길이(예: CbHeight)가 16 이 상인 경우에 적용하는 조건과 현재 블록의 너비(예: CbWidth)가 16 이상인 경우에 적용하는 조건을 사용할 수 있다. 이러한 현재 블록의 크기와 관련된 적용 조건들을 만족한 경우 (즉, 현재 블록의 크기가 16X16 이상인 경 우) BDOF을 적용하고, 상기와 같은 현재 블록의 크기와 관련된 적용 조건들을 만족하지 않는 경우 (즉, 현재 블 록의 크기가 16X16 보다 작은 경우) BDOF을 적용하지 않을 수 있다. 또한, 본 실시예에서는 현재 블록의 크기와 관련된 조건들(예: CbHeight, CbWidth)과 함께, 상기 표 10에서 나 열된 나머지 적용 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 10에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 10에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 10의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 9 또는 상기 표 10에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독립 적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 상술한 바와 같이 DMVR은 현재 픽처와 양방향의 참조 픽처간의 거리가 상호 동일한 경우에 적용하는 반면, BDOF 는 현재 픽처와 양방향의 참조 픽처간의 거리가 다르더라도 true 쌍예측인 경우 항상 적용된다. 따라서, 본 문 서에서는 코딩 효율을 높이기 위해 상기 양방향의 참조 픽처 거리와 관련된 조건을 DMVR 및 BDOF에 통일하여 적 용할 수 있는 방안을 제안한다. 본 문서의 일 실시예로, BDOF의 적용 조건은 다음 표 11에 제시된 조건들을 포함할 수 있다. 표 11"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 17, "content": "상기 표 11을 참조하면, BDOF의 적용 조건들 중 참조 픽처 거리와 관련된 조건(예: DiffPicOrderCnt)을 변경함 으로써, DMVR과 BDOF에 해당 조건을 동일하게 적용할 수 있다. 예를 들어, DiffPicOrderCnt(currPic, RefPicList0 [refIdxL0]) - DiffPicOrderCnt(currPic, RefPicList1 [ refIdxL1 ] )이 0인지 여부를 판단함으로 써, 현재 픽처와 LO 참조 픽처(즉, 참조 픽처 리스트 L0 내의 참조 픽처) 간의 거리와, 현재 픽처와 L1 참조 픽 처(즉, 참조 픽처 리스트 L1 내의 참조 픽처) 간의 거리가 상호 동일한지 여부를 결정할 수 있다. 즉, 현재 픽 처와 양방향의 참조 픽처간의 거리가 상호 동일한 경우에 한해 BDOF를 적용할 수 있다. 이와 같이, true 쌍예측 이면서 양방향의 참조 픽처 거리가 동일한 조건이 추가됨에 따라, BDOF 적용 범위가 제한되므로 디코딩 복잡도 를 절감할 수 있다. 또한, 본 실시예에서는 참조 픽처 거리와 관련된 조건(예: DiffPicOrderCnt)과 함께, 상기 표 11에서 나열된 나 머지 적용 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 11에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 11에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 11의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 본 문서의 일 실시예로, DMVR의 적용 조건은 다음 표 12에 제시된 조건들을 포함할 수 있다. 표 12"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 18, "content": "상기 표 12를 참조하면, DMVR의 적용 조건들 중 참조 픽처 거리와 관련된 조건(예: DiffPicOrderCnt)을 변경함 으로써, DMVR과 BDOF에 해당 조건을 동일하게 적용할 수 있다. 예를 들어, DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt( currPic, refPicList1[ refIdxL1 ] )이 0보다 작은지 여부를 판단함으로써, 현재 픽처를 기준으로 양방향의 참조 픽처(즉, LO 참조 픽처 및 L1 참조 픽처)가 서로 다른 방향 에 위치하는 true 쌍예측인지를 결정할 수 있다. 즉, 현재 픽처와 양방향의 참조 픽처간의 거리가 동일하지 않 더라도 true 쌍예측인 경우에는 항상 DMVR을 적용할 수 있다. 이와 같이, true 쌍예측 여부 조건이 적용됨에 따 라 양방향의 참조 픽처 거리가 다른 경우에도 디코딩 복잡도를 고려하여 유도된 움직임 벡터는 스케일링 (scaling) 하지 않고 사용할 수 있다. 또한, 본 실시예에서는 참조 픽처 거리와 관련된 조건(예: DiffPicOrderCnt)과 함께, 상기 표 12에서 나열된 나 머지 적용 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 12에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 12에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 12의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 11 또는 상기 표 12에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 한편, 각 참조 블록은 빛의 변화 등에 의해 가중합(weighted sum)으로 움직임 보상을 하는 경우가 발생할 수 있 다. 이때 GBi나 LIC(local illumination compensation)로 그 현상을 파악할 수 있으므로, GBi나 LIC 조건을 고 려하여 DMVR과 BDOF의 적용 조건을 정할 수 있다. 본 문서의 일 실시예로, GBi 및 LIC 조건을 고려하여 DMVR의 적용 여부를 결정하는 방안을 제안한다. 이 경우 DMVR의 적용 조건은 다음 표 13에 제시된 조건들을 포함할 수 있다. 표 13"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 19, "content": "상기 표 13을 참조하면, GBi 조건(예: GbiIdx) 및 LIC 조건(예: LICFlag)을 추가하여 DMVR의 적용 여부를 결정 할 수 있다. 예를 들어, GbiIdx가 0인 경우 (즉, GbiIdx가 디폴트인 경우), GBi 여부 조건을 만족하는 것으로 정하고, LICFlag가 0인 경우 (즉, LIC가 존재하는 경우), LIC 여부 조건을 만족하는 것으로 정할 수 있다. 또한, 본 실시예에서는 GBi 조건(예: GbiIdx) 및 LIC 조건(예: LICFlag)과 함께, 상기 표 13에 나열된 나머지 적용 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 13에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 13에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 13의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 본 문서의 일 실시예로, GBi 및 LIC 조건을 고려하여 BDOF의 적용 여부를 결정하는 방안을 제안한다. 이 경우 BDOF의 적용 조건은 다음 표 14에 제시된 조건들을 포함할 수 있다. 표 14"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 20, "content": "상기 표 14에 따르면, 기존의 GBi 조건(예: GbiIdx)과 함께 LIC 조건(예: LICFlag)을 추가하여 BDOF의 적용 여 부를 결정할 수 있다. 예를 들어, GbiIdx가 0인 경우 (즉, GbiIdx가 디폴트인 경우), GBi 여부 조건을 만족하는 것으로 정하고, LICFlag가 0인 경우 (즉, LIC가 존재하는 경우), LIC 여부 조건을 만족하는 것으로 정할 수 있 다. 따라서, 본 실시예에서는 GBi 조건(예: GbiIdx) 및 LIC 조건(예: LICFlag)과 함께, 상기 표 14에 나열된 나머지 적용 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 14에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 14에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 14의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 13 또는 상기 표 14에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 한편, DMVR과 BDOF는 디코딩 장치에서 리파인먼트 과정을 통해 움직임 정보를 유도하므로, 디코딩 복잡도 문제 가 발생한다. 따라서, 본 문서에서는 머지 인덱스를 사용하여 DMVR 및 BDOF의 적용 여부를 결정할 수 있게 함으 로써, 디코딩 복잡도를 줄일 수 있는 방법을 제안한다. 이때, DMVR과 BDOF는 모두 제한적인 범위 내에서 움직임 벡터의 리파인을 수행하므로 움직임 벡터가 부정확한 경우 라파인의 효과가 줄어들 수 있다. 따라서, 본 문서에 서는 리파인의 효율을 고려하여 머지 인덱스가 나타내는 값이 작은 경우에만 제한적으로 적용할 수 있는 방안을 제안한다. 여기서, 머지 인덱스는 인코딩 장치에서 디코딩 장치로 시그널링되는 신택스 요소일 수 있다. 예를 들어, 인코 딩/디코딩 장치는 현재 블록에 머지 모드/스킵 모드가 적용되는 경우 현재 블록의 주변 블록들을 기반으로 머지 후보 리스트를 구성할 수 있다. 이때, 인코딩 장치는 RD(rate-distortion) cost 기반으로 머지 후보 리스트에 포함된 머지 후보들 중 최적의 머지 후보를 선택하고, 선택된 머지 후보를 가리키는 머지 인덱스 정보를 디코딩 장치로 시그널링할 수 있다. 디코딩 장치는 머지 후보 리스트 및 머지 인덱스 정보를 기반으로 현재 블록에 적 용되는 머지 후보를 선택할 수 있다. 본 문서의 일 실시예로, 머지 인덱스를 사용하여 DMVR의 적용 여부를 결정하는 방법은 다음 표 15에 제시된 조 건들을 포함할 수 있다. 표 15"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 21, "content": "상기 표 15를 참조하면, 머지 인덱스 조건(예: merge_idx)을 추가하여 DMVR의 적용 여부를 결정할 수 있다. 예 를 들어, 머지 인덱스(예: merge_idx)가 2보다 작은 경우, 머지 인덱스 조건을 만족하는 것으로 정할 수 있다. 여기서 머지 인덱스의 값(threshold)을 2로 설정하였으나, 이는 하나의 예시일 뿐이며 코딩 효율에 따라 해당 값은 변경될 수 있다. 따라서, 본 실시예에서는 머지 인덱스 조건(예: merge_idx)과 함께, 상기 표 15에 나열된 나머지 적용 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 15에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 15에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 15의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 본 문서의 일 실시예로, 머지 인덱스를 사용하여 BDOF의 적용 여부를 결정하는 방법은 다음 표 16에 제시된 조 건들을 포함할 수 있다. 표 16"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 22, "content": "상기 표 16을 참조하면, 머지 모드/스킵 모드 여부 조건(예: merge_flag)과 머지 인덱스 조건(예: merge_idx)을 추가하여 BDOF의 적용 여부를 결정할 수 있다. 예를 들어, merge_flag가 1이고 (즉, 머지 모드/스킵 모드를 사 용하여 인터 예측을 수행하는 경우) merge_idx가 2 이상인 경우에 해당하지 않으면, 머지 인덱스의 값이 작은 경우에만 제한적으로 BDOF를 적용하는 조건을 만족하는 것으로 정할 수 있다. 다시 말해, merge_flag가 1이고 (즉, 머지 모드/스킵 모드를 사용하여 인터 예측을 수행하는 경우) merge_idx가 2보다 작은 경우, 머지 인덱스 조건을 만족하는 것으로 판단하고 BDOF를 적용할 수 있다. 여기서 머지 인덱스의 값(threshold)을 2로 설정하였 으나, 이는 하나의 예시일 뿐이며 코딩 효율에 따라 해당 값은 변경될 수 있다. 즉, 본 실시예에서는 머지 모드/스킵 모드 여부 조건(예: merge_flag), 머지 인덱스 조건(예: merge_idx)과 함 께, 상기 표 16에 나열된 나머지 적용 조건들을 기반으로 BDOF의 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 16에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 16에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 16의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 15 또는 상기 표 16에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 한편, 머지/스킵 모드에서 MMVD를 통해 움직임 정보를 리파인할 수 있는데, 이 경우 디코더 복잡도가 증가하므 로 MMVD가 적용될 때 DMVR을 수행하지 않도록 하고 있다. 그러나, MMVD를 고려하지 않고 적용되는 경우 성능 향 상을 고려하여 MMVD 조건 없이도 DMVR을 적용할 수 있다. 이 경우 본 문서의 일 실시예에 따르면, DMVR의 적용 조건은 다음 표 17에 제시된 조건들을 포함할 수 있다. 표 17"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 23, "content": "상기 표 17을 참조하면, 기존의 DMVR의 적용 조건들 중 MMVD 모드 적용 여부 조건(예: mmvd_flag)을 제외시킬 수 있다. 즉, mmvd_flag가 0인 경우 (즉, MMVD 모드를 사용하지 않는 경우)인지를 판단하는 과정을 생략하고,상기 표 17에 나열된 조건들을 기반으로 DMVR의 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 (MMVD 모드 적용 여부 조건(예: mmvd_flag)을 제외한) 상기 표 17에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만 일 상기 표 17에 나열된 조건들 중 하나라도 만족되지 못하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있 다. 이러한 상기 표 17의 조건들은 인코딩 장치에서도 적용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 또한, 상술한 표 17의 실시예에서와 반대로, 머지/스킵 모드에서 MMVD를 통해 움직임 정보를 리파인할 때, 디코 더 복잡도를 고려하여 BDOF의 수행 여부를 결정할 수 있다. 따라서, 본 문서에서는 MMVD 조건을 고려하여 BDOF 의 적용 여부를 결정하는 방법을 제안한다. 이 경우 본 문서의 일 실시예에 따르면, BDOF의 적용 조건은 다음 표 18에 제시된 조건들을 포함할 수 있다. 표 18"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 24, "content": "상기 표 18을 참조하면, MMVD 모드 적용 여부 조건(예: mmvd_flag)을 추가함으로써, MMVD를 통해 움직임 정보를 리파인하는 경우 BDOF를 적용하지 않을 수 있다. 예를 들어, mmvd_flag가 0인 경우 (즉, MMVD 모드를 사용하지 않는 경우), MMVD 모드 적용 여부 조건을 만족하는 것으로 판단할 수 있다. 따라서, 본 실시예에서는 MMVD 모드 적용 여부 조건(예: mmvd_flag)과 함께, 상기 표 18에 나열된 나머지 적용 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 18에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 18에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 18의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 17 또는 상기 표 18에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 한편, AMVP 모드일 때 AMVR(Adaptive Motion Vector Resolution) 기술이 적용될 수 있다. 이때, 움직임 벡터의 해상도(resolution)가 큰 경우, 즉 정수 샘플 단위 라운딩(integer-pel rounding), 4 샘플 단위 라운딩(4 integer-pel rounding)을 갖는 경우, 제한된 영역 내에서 리파인을 수행하는 BDOF의 경우 이러한 기술을 적용하 기 적합하지 않을 수 있다. 따라서, 본 문서에서는 AMVR 조건에 따라 BDOF의 수행을 결정할 수 있는 방안을 제 안한다. 이 경우 본 문서의 일 실시예에 따르면, BDOF의 적용 조건은 다음 표 19에 제시된 조건들을 포함할 수 있다. 표 19"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 25, "content": "상기 표 19를 참조하면, AMVR 조건(예: amvr_flag)을 추가하여 BDOF의 적용 여부를 결정할 수 있다. 여기서, amvr_flag는 움직임 벡터 차이(MVD)의 해상도를 나타내는 정보일 수 있다. 예를 들어, amvr_flag가 0인 경우 MVD의 해상도가 1/4 샘플(quarter-luma-sample) 단위로 유도되는 것을 나타내고, amvr_flag가 0이 아닌 경우 정수 샘플(integer-luma-sample) 단위 또는 4 샘플(four-luma-sample) 단위로 유도되는 것을 나타낼 수 있다. 또는, 그 반대의 경우로 정해질 수도 있다. 실시예에 따라, 상기 표 19에 제시된 바와 같이, amvr_flag가 0이 아닌 경우 BDOF가 적용되는 것으로 조건을 설정할 수 있다. 다시 말해, amvr_flag가 0인 경우 BDOF가 적용되지 않도록 제한할 수 있다. 따라서, 본 실시예에서는 AMVR 조건(예: amvr_flag)과 함께, 상기 표 19에 나열된 나머지 조건들을 기반으로 BDOF의 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 19에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 19에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 19의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 한편, 상술한 바와 같은 DMVR과 BDOF는 SPS(Sequence Parameter Set) 신택스에서 각각 시그널링될 수 있다. 다 음 표 20은 SPS 신택스를 통해 시그널링되는 DMVR이 가용한지 여부와 BDOF가 가용한지 여부를 나타내는 신택스 요소의 일 예를 나타낸다. 표 20"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 26, "content": "상기 표 20을 참조하면, SPS 신택스에서 sps_dmvr_enabled_flag를 시그널링할 수 있고, 이 신택스 요소를 기반 으로 true 쌍예측 기반 DMVR이 가용(enable)한지 여부를 나타낼 수 있다. 예컨대, sps_dmvr_enabled_flag가 1 인 경우 true 쌍예측 기반 DMVR이 가용한 것을 나타내고, sps_dmvr_enabled_flag가 0인 경우 true 쌍예측 기반 DMVR이 가용하지 않은 것을 나타낼 수 있다. 또한, SPS 신택스에서 sps_bdof_enabled_flag를 시그널링할 수 있고, 이 신택스 요소를 기반으로 true 쌍예측 기반 BDOF가 가용(enable)한지 여부를 나타낼 수 있다. 예컨대, sps_bdof_enabled_flag가 1인 경우 true 쌍예 측 기반 BDOF이 가용한 것을 나타내고, sps_bdof_enabled_flag가 0인 경우 true 쌍예측 기반 BDOF이 가용하지않은 것을 나타낼 수 있다. 상기 표 20에서와 같이 DMVR의 가용 여부를 나타내는 신택스 요소(예: sps_dmvr_enabled_flag)와 BDOF의 가용 여부를 나타내는 신택스 요소(예: sps_bdof_enabled_flag)를 이용하여 DMVR 및 BDOF의 적용 조건을 체크할 수 있다. 도 6은 DMVR 및 BDOF의 적용 조건을 체크하여 디코딩 과정을 수행하는 방법을 나타내는 일 예이다. 도 6의 방법은 상기 표 20에서와 같이 DMVR의 가용 여부를 나타내는 신택스 요소(예: sps_dmvr_enabled_flag)와 BDOF의 가용 여부를 나타내는 신택스 요소(예: sps_bdof_enabled_flag)를 이용하는 경우에 적용될 수 있다. 도 6을 참조하면, 디코딩 장치는 현재 블록에 대한 움직임 정보(예: 움직임 벡터, 참조 픽처 인덱스 등)를 유도 할 수 있다(S600). 디코딩 장치는 DMVR의 적용 조건을 체크할 수 있다(S610). 이때 DMVR의 가용 여부를 나타내는 신택스 요소(예: sps_dmvr_enabled_flag)를 기반으로 DMVR의 적용 조건을 체크할 수 있다. 예를 들어, DMVR이 가용한 경우(예컨 대, sps_dmvr_enabled_flag가 1인 경우)에 DMVR의 적용 조건을 체크할 수 있다. 디코딩 장치는 DMVR의 적용 조건을 만족하는지 여부에 따라 DMVR 과정을 적용할지를 판단할 수 있다(S620). DMVR의 적용 조건을 모두 만족한 경우, 디코딩 장치는 DMVR 과정을 적용하여 리파인된 움직임 정보를 도출할 수 있다(S630). DMVR의 적용 조건 중 하나 이상 만족하지 못한 경우, 디코딩 장치는 DMVR 과정을 적용하지 않을 수 있다. 디코딩 장치는 DMVR을 적용한 경우에 도출된 리파인된 움직임 정보 또는 DMVR을 적용하지 않은 경우에 도출된 (리파인되지 않은) 움직임 정보를 기반으로 현재 블록의 예측 샘플들을 유도할 수 있다(S640). 그리고, 디코딩 장치는 BDOF의 적용 조건을 체크할 수 있다(S650). 이때, BDOF의 가용 여부를 나타내는 신택스 요소(예: sps_bdof_enabled_flag)를 기반으로 BDOF의 적용 조건을 체크할 수 있다. 예를 들어, BDOF이 가용한 경우(예컨대, sps_bdof_enabled_flag가 1인 경우)에 BDOF의 적용 조건을 체크할 수 있다. BDOF의 적용 조건을 모두 만족한 경우, 디코딩 장치는 BDOF 과정을 적용하여 예측 샘플들에 대해 리파인을 수행 할 수 있다(S670). BDOF의 적용 조건 중 하나 이상 만족하지 못한 경우, 디코딩 장치는 BDOF 과정을 적용하지 않을 수 있다. 디코딩 장치는 현재 블록에 대한 레지듀얼 샘플들을 유도하고(S680), 상기 레지듀얼 샘플들과 상기 BDOF를 적용 한 경우에 도출된 리파인된 예측 샘플들 또는 BDOF를 적용하지 않은 경우에 도출된 (리파인되지 않은) 예측 샘 플들을 기반으로 복원된 샘플들을 유도할 수 있다(S690). 본 문서에서는 상술한 바와 같이 DMVR과 BDOF를 적용함에 있어 상호 간의 적용 조건을 일치(harmonization)시켜 코딩 효율을 향상시키고 복잡도를 감소시킬 수 있는 다양한 실시예들을 제안한 바 있다. 이와 같은 본 문서의 실시예들에 따른 DMVR과 BDOF의 적용 조건을 체크하여 디코딩 과정에 적용함에 있어, 각각의 조건을 따로 체크 하여 적용할 수도 있으나 코딩 효율을 향상시키기 위해서 한번에 적용 조건을 체크할 수도 있다. 즉, 본 문서에 서는 DMVR과 BDOF의 적용 조건을 한번에 통합하여 체크할 수 있는 방안을 제안한다. 본 문서의 일 실시예로, SPS(Sequence Parameter Set) 신택스에서 디코딩 장치에서의 리파인 적용 여부를 나타 내는 정보(예: sps_refinement_enabled_flag)를 시그널링함으로써 DMVR/BDOF의 적용 조건 체크 과정을 수행할 수 있다. 다음 표 21은 SPS 신택스를 통해 시그널링되는 디코딩 장치에서의 리파인 적용 여부를 나타내는 신택 스 요소(예: sps_refinement_enabled_flag)의 일 예를 나타낸다.표 21"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 27, "content": "상기 표 21을 참조하면, SPS 신택스에서 sps_refinement_enabled_flag를 시그널링할 수 있고, 이 신택스 요소 를 기반으로 디코딩 장치에서의 리파인 적용이 가능한지 여부를 나타낼 수 있다. 예컨대, sps_refinement_enabled_flag가 존재할 때 (즉, sps_refinement_enabled_flag가 true인 경우), 디코딩 장치에 서의 리파인 적용이 가능한 것으로 판단될 수 있다. 이 경우, 디코딩 장치는 DMVR이 가용(enable)한지 여부를 나타내는 sps_dmvr_enabled_flag 신택스 요소 및 BDOF가 가용(enable)한지 여부를 나타내는 sps_bdof_enabled_flag 신택스 요소를 획득하여, DMVR과 BDOF의 적용 조건을 판단할 수 있다. 도 7 및 도 8은 DMVR 및 BDOF의 적용 조건을 체크하여 디코딩 과정을 수행하는 방법을 나타내는 다른 예이다. 도 7의 방법 및 도 8의 방법은 상기 표 21에서와 같이 디코딩 장치에서의 리파인 적용이 가능한지 여부를 나타 내는 신택스 요소(예: sps_refinement_enabled_flag)를 이용하는 경우에 적용될 수 있다. 또한, 도 7 및 도 8 은 상술한 도 6과 중복되는 내용에 관해서는 설명을 생략한다. 도 7을 참조하면, 상기 도 6의 과정과 비교하여 DMVR 및 BDOF의 적용 조건을 각각 체크하지 않고, 앞 단에서 한 번에 체크하는 것을 알 수 있다. 일 실시예로, 도 7의 단계 S710에서, 디코딩 장치는 리파인 적용 조건을 체크 할 수 있다. 이때, 리파인 적용 조건 체크는, 상기 표 21에서와 같은 sps_refinement_enabled_flag를 기반으로 수행될 수 있다. 예를 들어, sps_refinement_enabled_flag가 1인 경우, DMVR이 가용(enable)한지 여부를 나타 내는 sps_dmvr_enabled_flag 신택스 요소 또는 BDOF가 가용(enable)한지 여부를 나타내는 sps_bdof_enabled_flag 신택스 요소를 획득하고, 이를 기반으로 DMVR 및 BDOF의 적용 조건을 체크할 수 있다. 또한, 도 8을 참조하면, 상기 도 6의 과정과 비교하여 DMVR 및 BDOF의 적용 조건을 각각 체크하지 않고, 앞 단 에서 한번에 체크하되 다른 조건에 대해서는 간단한 체크 과정(BDOF의 적용 조건)을 수행할 수 있다. 일 실시예 로, 도 8의 단계 S810에서, 디코딩 장치는 리파인 적용 조건을 체크할 수 있다. 이후 도 8의 단계 S850에서, 디 코딩 장치는 상기 리파인 적용 조건과 다른 조건을 가지는 BDOF의 적용 조건에 대해서 추가적으로 간단히 체크 를 수행할 수 있다. 한편, 현재 블록의 길이(Height) 또는 크기(Height*Width)가 특정 길이 또는 특정 크기보다 작은 경우, 움직임 보상(Motion Compensation)을 위한 multiplication/addition의 계산 비율이 증가하게 된다. 따라서, 본 문서의 일 실시예에서는 worst case를 줄이기 위해 DMVR의 적용 조건에서와 같이, 작은 길이 또는 작은 크기의 블록에 대해 BDOF의 적용을 제한할 수 있다. 이 경우 BDOF의 적용 조건은 다음 표 22에 제시된 조건들을 포함할 수 있 다. 표 22"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 28, "content": "상기 표 22를 참조하면, 현재 블록의 크기와 관련된 조건들(예: CbHeight, CbWidth)을 추가함으로써, 특정 크기 보다 작은 블록에 대해서 BDOF을 적용하지 않도록 할 수 있다. 예를 들어, 현재 블록의 길이(예: CbHeight)가 8 이상인 경우에 적용하는 조건과, 현재 블록의 크기(예: CbHeight* CbWidth)가 64 이상인 경우에 적용하는 조건 을 사용할 수 있다. 이러한 현재 블록의 크기와 관련된 적용 조건들을 만족한 경우 (즉, 현재 블록의 길이가 8 이상이고 현재 블록의 길이*너비가 64 이상인 경우) BDOF을 적용하고, 상기와 같은 현재 블록의 크기와 관련된 적용 조건들을 만족하지 않는 경우 BDOF을 적용하지 않을 수 있다. 또한, 본 실시예에서는 현재 블록의 크기와 관련된 조건들(예: CbHeight, CbHeight*CbWidth)과 함께, 상기 표 22에서 나열된 나머지 적용 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 22에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 22에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 22의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 한편, 현재 블록에 MMVD가 적용되는 경우 MMVD에 대한 정보(예: mmvd index)를 기반으로 움직임 정보를 유도할 수 있다. 여기서, MMVD에 대한 정보는 베이스(base) MV의 인덱스, 거리 인덱스(distance index), 방향 인덱스 (direction index) 등을 포함할 수 있다. 특히, 거리 인덱스(보다 구체적으로, mmvd_distance_index[xCb][yCb])는 베이스 MV와의 거리를 나타내기 위해 사용되는데, 예를 들어 거리 인덱스 0 내지 7은 각각 {1/4, 1/2, 1, 2, 4, 8, 16, 32} 등으로 나타낼 수 있다. DMVR 및 BDOF에서 움직임 정보의 리파 인먼트를 결정함에 있어, 인접 픽셀(인접 샘플)을 고려하여 리파인먼트 여부를 결정하는데, 이때 인접 픽셀과 베이스 MV와의 거리가 먼 경우 거리 인덱스의 값도 커지게 된다. 이와 같은 경우 인접 픽셀을 고려하는 것이 DMVR 및 BDOF의 성능 향상에 도움을 주기 어렵다. 따라서, 본 문서에서는 거리 인덱스(보다 구체적으로, mmvd_distance_index[xCb][yCb]) 값에 따라 DMVR 및 BDOF의 적용 여부를 결정할 수 있는 방안을 제안한다. 본 문서의 일 실시예로, 거리 인덱스를 고려하여 DMVR의 적용 여부를 결정할 수 있으며, 이 경우 DMVR의 적용 조건은 다음 표 23에 제시된 조건들을 포함할 수 있다. 표 23"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 29, "content": "상기 표 23을 참조하면, DMVR의 적용 조건들 중 MMVD과 관련된 조건(예: mmvd_flag)을 변경함으로써, MMVD 모드 시에 제한적으로 DMVR을 적용할 수 있다. 예를 들어, mmvd_flag가 1이고 mmvd_distance_index가 4보다 큰 경우, MMVD의 거리 인덱스 조건을 만족하는 것으로 정할 수 있다. 따라서, MMVD 모드가 적용될 때 거리 인덱스 (예: mmvd_distance_index[xCb][yCb]) 값에 따라 DMVR의 적용 여부를 결정할 수 있다. 여기서 mmvd_distance_index를 위한 임계값(threshold)을 4로 설정하였으나, 이는 하나의 예시일 뿐이며 성능 및 코딩 효율에 따라 다양한 수치로 변경될 수 있다. 따라서, 본 실시예에서는 MMVD 적용 여부 조건(예: mmvd_flag), MMVD의 거리 인덱스 조건(예: mmvd_distance_index)과 함께, 상기 표 23에 나열된 나머지 적용 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 23에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 23에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 23의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 또한, 본 문서의 일 실시예로, 거리 인덱스를 고려하여 BDOF의 적용 여부를 결정할 수 있으며, 이 경우 BDOF의 적용 조건은 다음 표 24에 제시된 조건들을 포함할 수 있다. 표 24"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 30, "content": "상기 표 24를 참조하면, 머지 모드/스킵 모드 여부 조건(예: merge_flag), MMVD과 관련된 조건(예: mmvd_flag, mmvd_distance_index)을 추가함으로써, MMVD 모드 시에 제한적으로 BDOF을 적용할 수 있다. 예를 들어, merge_flag가 존재하지 않거나 (즉, merge_flag가 1이 아닌 경우), 또는 merge_flag가 1이고 mmvd_flag가 1이 고 mmvd_distance_index가 4보다 큰 경우, MMVD 모드 시에 제한적으로 BDOF을 적용하는 조건을 만족하는 것으로정할 수 있다. 따라서, MMVD 모드가 적용될 때 거리 인덱스(예: mmvd_distance_index[xCb][yCb]) 값에 따라 BDOF의 적용 여부를 결정할 수 있다. 여기서 mmvd_distance_index를 위한 임계값(threshold)을 4로 설정하였으나, 이는 하나의 예시일 뿐이며 성능 및 코딩 효율에 따라 다양한 수치로 변경될 수 있다. 따라서, 본 실시예에서는 머지 모드/스킵 모드 여부 조건(예: merge_flag), MMVD과 관련된 조건(예: mmvd_flag, mmvd_distance_index)과 함께, 상기 표 24에 나열된 나머지 적용 조건들을 기반으로 BDOF의 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 24에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 24에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 24의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 23 또는 상기 표 24에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 한편, 상술한 바와 같이 현재 블록에 인트라 예측과 인터 예측을 동시에 수행하는 CIIP(Combined intra-inter prediction) 모드가 적용될 수 있다. 이 경우, 인터 예측이 수행된 예측 블록(인터 블록)은 인트라 예측 방법과 결합(combine)되어 최종적으로 예측 샘플 값들이 생성되므로, 예측 정확도가 향상될 수 있다. 그러나, DMVR 및 BDOF는 인터 블록에 대해 리파인먼트하는 기술이므로, 복잡도 대비 성능 면에서 CIIP 모드의 적용이 필요하지 않을 수 있다. 따라서, 본 문서에서는 CIIP를 고려하여 DMVR 및 BDOF의 적용 여부를 결정할 수 있는 방안을 제 안한다. 본 문서의 일 실시예로, CIIP을 고려하여 DMVR의 적용 여부를 결정할 수 있으며, 이 경우 DMVR의 적용 조건은 다음 표 25에 제시된 조건들을 포함할 수 있다. 표 25"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 31, "content": "상기 표 25를 참조하면, CIIP 모드 적용 여부 조건(예: ciip_flag)을 추가함으로써, CIIP 적용 여부에 따라 DMVR을 제한적으로 적용할 수 있다. 예를 들어, ciip_flag가 0인 경우 (즉, CIIP 모드가 적용되지 않는 경우), CIIP 모드 적용 여부 조건을 만족하는 것으로 판단하여 DMVR을 적용할 수 있다. 따라서, 본 실시예에서는 CIIP 모드 적용 여부 조건(예: ciip_flag)과 함께, 상기 표 25에 나열된 나머지 적용 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 25에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 25에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 25의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 또한, 본 문서의 일 실시예로, CIIP을 고려하여 BDOF의 적용 여부를 결정할 수 있으며, 이 경우 BDOF의 적용 조 건은 다음 표 26에 제시된 조건들을 포함할 수 있다. 표 26"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 32, "content": "상기 표 26을 참조하면, CIIP 모드 적용 여부 조건(예: ciip_flag)을 추가함으로써, CIIP 적용 여부에 따라 BDOF을 제한적으로 적용할 수 있다. 예를 들어, ciip_flag가 0인 경우 (즉, CIIP 모드가 적용되지 않는 경우), CIIP 모드 적용 여부 조건을 만족하는 것으로 판단하여 BDOF을 적용할 수 있다. 따라서, 본 실시예에서는 CIIP 모드 적용 여부 조건(예: ciip_flag)과 함께, 상기 표 26에 나열된 나머지 적용 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 26에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 26에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 26의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 25 또는 상기 표 26에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 상술한 본 문서의 실시예에 따른 표 5 내지 표 26에서 나열된 방법은 조합하여 적용될 수 있다. 즉, 리파인 적 용 조건을 체크함으로써 DMVR 및 BDOF의 적용 여부를 판단할 수 있으며, 다음 표 27에서과 같은 조건들을 적용 할 수 있다. 표 27"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 33, "content": "상기 표 27을 참조하면, DMVR 또는 BDOF가 적용될 때 양방향 예측인 경우에 적용하는 조건, 현재 픽처와 양방향 참조 픽처와의 거리가 상호 동일한 true 쌍예측인 경우에 적용하는 조건, MMVD 모드가 사용되지 않는 경우에 적 용하는 조건, 어파인 예측이 아닌 경우에 적용하는 조건, 서브블록 기반 머지 모드가 아닌 경우에 적용하는 조 건, GBi 인덱스가 디폴트인 경우에 적용하는 조건을 이용할 수 있다. 즉, 상기 조건들을 만족하는지 여부에 따 라 DMVR 또는 BDOF의 적용 여부를 판단할 수 있다. 또한, 상술하였듯 DMVR을 위해 머지 모드인지 여부를 판단하거나, BDOF를 위해 루마 블록인지 여부를 판단하는 등의 조건이 추가될 수도 있다. 상기 표 27에서 나열된 적용 조건들은 하나의 예시이며, 전술한 실시예들(상기 표 5 내지 표 26의 실시예들)에 서 나열한 다양한 조건들을 조합하여 사용될 수 있음은 자명하다. 한편, DMVR에서는 디코딩 복잡도를 고려하여 MRSAD(mean-removed SAD) 함수 대신 SAD 함수를 비용 함수로 채택 하고 있다. 그러나, GBi 인덱스가 디폴트(예: GbiIdx가 0인 경우)가 아닌 경우 두 개의 참조 블록이 서로 다른 가중치(weighting factor)를 가질 수 있기 때문에, SAD를 사용하는 DMVR은 바람직하지 않을 수 있다. 따라서, GBi 인덱스를 고려하여 DMVR의 조건이 고정될 수 있다. 실험 결과에 따르면 VTM4.0(VVC Test Model)과 비교하여 100% 인코딩 및 디코딩 런타임(run-time)으로 0.00% RD-rate 변화가 나타났다. VVC(versatile video coding)의 경우 DMVR 과정은 다음 표 28에 나열된 조건들이 모두 충족될 때 수행될 수 있 다. 표 28"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 34, "content": "현재 DMVR은, 나중에 가중 평균될 참조 블록들의 SAD를 비교하여 매칭되지 않는 블록을 검색할 수 있다. 본 문 서에서는 두 개의 참조 블록이 서로 다른 가중치를 가질 수 있기 때문에, 이러한 경우를 고려하여 DMVR의 조건 을 정할 수 있다. 본 문서의 일 실시예에 따르면, GBi 인덱스가 디폴트가 아닌 블록에 대해서는 DMVR을 수행하 지 않도록 할 수 있다. 이 경우 DMVR의 적용 조건은 다음 표 29와 같을 수 있다. 표 29"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 35, "content": "상기 표 29에서와 같이, GBi 인덱스(예: GbiIdx)의 값이 0인 경우 DMVR을 수행하는 조건을 추가할 수 있다. 다 시 말해, GBi 인덱스(예: GbiIdx)의 값이 0이 아닌 경우에는 두 개의 참조 블록(즉, L0 예측에 참조되는 참조 블록과 L1 예측에 참조되는 참조 블록)에 서로 다른 가중치가 적용되기 때문에, 이 경우 DMVR을 수행하지 않도 록 제한할 수 있다. 한편, BDOF는 현재 블록(즉, 현재 코딩 유닛; 현재 CU)이 true 쌍예측 조건을 만족하는 경우에 수행된다. 광학 흐름 수식(optical flow equation)은 일정한 속도(즉, 운동량)로 움직이는 오브젝트의 움직임을 예측하기 위해 설계되었다는 점을 고려할 때, 현재 true 쌍예측 조건은 BDOF를 적용하기 위한 최적의 조건은 아니다. 따라서, 참조 픽처의 거리를 고려하여 BDOF의 조건이 고정될 수 있다. 실험 결과에 따르면 VTM4.0(VVC Test Model)과 비 교하여 100% 인코딩 및 디코딩 런타임(run-time)으로 0.01% RD-rate 변화가 나타났다. 도 9는 BDOF의 개념을 설명하기 위해 도시된 도면이다. 상술한 바와 같이 BDOF는 광학 흐름 개념을 사용하여 움직임 보상(motion compensation)의 성능을 향상시키도록 설계되었다. BDOF에 따르면, 도 9에 도시된 바와 같이, 오브젝트가 일정한 속도(일정한 움직임)로 움직이고 또 한 오브젝트가 움직이는 동안 각 픽셀의 휘도는 변하지 않는다고 가정할 수 있다. 이러한 가정을 할 경우 광학 흐름의 수식은 다음 수학식 7과 같이 나타낼 수 있다. 수학식 7"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 36, "content": "상술하였듯, 현재 CU가 true 쌍예측 조건을 만족하는 경우에 BDOF가 수행된다. 그러나, 이 true 쌍예측 조건이 오브젝트가 일정한 속도로 움직이는 경우를 의미하는 것은 아니다. 따라서, 본 문서에서는 오브젝트가 일정한 움직임을 가지는 경우에 BDOF를 적용할 수 있도록 하는 방안을 제안하고, 움직임 보상의 성능을 향상시킬 수 있 도록 한다. 본 문서의 일 실시예에 따르면, 상기 수학식 7에서 δt로서 현재 픽처를 기준으로 LO 참조 픽처(도 9의 Reference 0)와의 거리와 L1 참조 픽처(도 9의 Reference 1)와의 거리가 서로 동일한 경우 BDOF를 적용할 수 있다. 이 경우 BDOF의 적용 조건은 다음 표 30과 같이 변경될 수 있다. 표 30"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 37, "content": "상기 표 30을 참조하면, BDOF의 적용 조건들 중 참조 픽처 거리와 관련된 조건(예: DiffPicOrderCnt)을 변경함 으로써, 일정한 움직임 속도를 가진 경우에 한정하여 BDOF를 적용할 수 있다. 예를 들어, DiffPicOrderCnt( currPic, RefPicList[ 0 ][ refIdxL0 ])과 DiffPicOrderCnt( RefPicList[ 1 ][ refIdxL1 ], currPic )이 동일 한지를 판단함으로써, 현재 픽처와 LO 참조 픽처(즉, 참조 픽처 리스트 L0 내의 참조 픽처) 간의 거리와, 현재 픽처와 L1 참조 픽처(즉, 참조 픽처 리스트 L1 내의 참조 픽처) 간의 거리가 상호 동일한지 여부를 판단할 수 있다. 즉, 현재 픽처를 기준으로 LO 참조 픽처와의 거리와 L1 참조 픽처와의 거리가 서로 동일한 경우에 한해 BDOF를 적용할 수 있다. 이와 같이, 현재 픽처를 기준으로 양방향의 참조 픽처 거리가 동일한 조건이 사용됨으 로써, true 쌍예측이면서 일정 속도로 움직이고 있는 오브젝트를 포함하고 있는 블록인지를 판별할 수 있다. 이 러한 조건을 만족하는 블록에 대해 BDOF를 적용함으로써, 보다 향상된 움직임 정보 리파인먼트 결과를 얻을 수 있다. 또한, 본 실시예에서는 참조 픽처 거리와 관련된 조건(예: DiffPicOrderCnt)과 함께, 상기 표 30에서 나열된 나 머지 적용 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 30에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 30에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 30의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 한편, 본 문서는 블록 크기에 따라 BDOF의 적용 여부를 결정하는 방안을 제안한다. 다음 표 31은 본 문서의 일 실시예에 따른 블록 크기 제한을 적용 조건으로 포함하는 경우를 나타낸다. 표 31"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 38, "content": "상기 표 31을 참조하면, BDOF를 적용함에 있어, 현재 블록의 길이(예: CbHeight)가 8 이상인 경우, 현재 블록의 크기(길이*너비)(예: CbHeight* CbWidth)가 64 이상인 경우를 조건으로 추가할 수 있다. 따라서, 본 실시예에서는 현재 블록의 길이가 8 이상인 조건, 현재 블록의 길이*너비가 64 이상인 조건과 함께, 상기 표 31에 나열된 나머지 적용 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 31에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 31에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 31의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 본 문서에서 전술된 DMVR 과정은 다음 표 32과 같은 스펙(spec)에 따라 구현될 수 있다. 다음 표 32는 본 문서 의 일 실시예로 SAD를 기반으로 움직임 벡터 리파인먼트 과정의 일례를 나타낸다.표 32"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 39, "content": "한편, 상술한 바와 같이 DMVR에서는 디코딩 복잡도를 고려하여 MRSAD(mean-removed SAD) 함수 대신 SAD 함수를 비용 함수로 채택하고 있다. 그러나, GBi 인덱스가 디폴트(예: GbiIdx가 0인 경우)가 아니고 명시적 가중 예측 (explicit weighted prediction)에 의한 가중치 플래그(weighting flag)가 0이 아닌 경우, SAD를 사용하는 DMVR은 바람직하지 않을 수 있다. 따라서, GBi 인덱스와 명시적 가중 예측의 가중치 플래그를 고려하여 DMVR의 조건이 고정될 수 있다. 또한, BDOF에도 동일한 조건이 적용될 수 있다. 실험 결과에 따르면 VTM4.0(VVC Test Model)과 비교하여 100% 인코딩 및 디코딩 런타임(run-time)으로 0.00% RD-rate 변화가 나타났다. 현재 DMVR은, 나중에 가중 평균되는 참조 블록들의 SAD를 비교하여 매칭되지 않는 블록을 검색할 수 있다. 본 문서에서는 두 개의 참조 블록이 서로 다른 가중치를 가질 수 있기 때문에, 이러한 경우를 고려하여 DMVR의 조 건을 정할 수 있다. 본 문서의 일 실시예에 따르면, GBi 인덱스가 디폴트가 아닌 블록에 대해서는 DMVR을 수행 하지 않도록 할 수 있다. 또한, 명시적 가중 예측에 의한 가중치 플래그가 0이 아닌 블록에 대해서는 DMVR을 수 행하지 않도록 할 수 있다. 본 문서의 일 실시예에서는 가중 쌍예측 여부를 고려하여 DMVR의 적용 여부를 결정할 수 있는 방안을 제안한다. 이 경우 DMVR의 적용 조건은 다음 표 33에 제시된 조건들을 포함할 수 있다. 표 33"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 40, "content": "상기 표 33을 참조하면, L0 예측 및 L1 예측에 대해 명시적으로 가중치 적용 여부를 나타내는 조건(예: luma_weight_l0_flag, luma_weight_l1_flag), L0 예측 및 L1 예측에 적용되는 가중치를 나타내는 인덱스 조건 (예: GbiIdx)을 추가함으로써, 가중 쌍예측 여부에 따라 DMVR을 적용할지를 결정할 수 있다. 예를 들어, L0 예측에 대해 명시적으로 가중치를 적용할지 여부를 나타내는 플래그 정보(예: luma_weight_l0_flag) 및 L1 예측에 대해 명시적으로 가중치를 적용할지 여부를 나타내는 플래그 정보(예:luma_weight_l1_flag)를 기반으로, 현재 블록에 명시적 가중 예측이 적용되는지 여부를 판단할 수 있다. 즉, luma_weight_l0_flag의 값이 0이고 luma_weight_l1_flag의 값이 0인 경우, 제한적으로 DMVR을 적용할 수 있다. 다시 말해, L0 및 L1 예측에 대해 명시적으로 가중 예측을 적용하지 않는 경우, DMVR을 적용하는 것으로 결정할 수 있다. 또한, L0 예측 및 L1 예측에 적용되는 가중치를 나타내는 쌍예측 가중치 인덱스(예: GbiIdx)의 값을 기반으로, 현재 블록에 서로 다른 가중치를 사용하는 쌍예측(즉, L0 예측 및 L1 예측)이 적용되는지를 판단할 수 있다. 즉, 쌍예측 가중치 인덱스(예: GbiIdx)의 값이 0인 경우는 상기 표 3의 실시예에서 설명한 바와 같이 L0 예측 및 L1 예측에 서로 다른 가중치가 적용되지 않는 디폴트인 경우일 수 있다. 따라서, 쌍예측 가중치 인덱스(예: GbiIdx)의 값이 0일 때, 제한적으로 DMVR을 적용할 수 있다. 실시예에 따라, L0 및 L1 예측에 대해 명시적으로 가중 예측을 적용하지 않는 경우 (luma_weight_l0_flag의 값 이 0이고 luma_weight_l1_flag의 값이 0인 경우), 쌍예측 가중치 인덱스(예: GbiIdx) 정보를 더 획득하여 쌍예 측 가중치 인덱스(예: GbiIdx)의 값이 0인지를 판단할 수 있다. 본 실시에에서는 L0 예측 및 L1 예측에 대해 명시적으로 가중치 적용 여부를 나타내는 조건(예: luma_weight_l0_flag, luma_weight_l1_flag), L0 예측 및 L1 예측에 적용되는 가중치를 나타내는 인덱스 조건 (예: GbiIdx)과 함께, 상기 표 33에 나열된 나머지 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 33에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 33에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 33의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 한편 BDOF의 경우, GBi 인덱스는 고려되고 있으나 명시적 가중 예측의 가중치 플래그는 고려되지 않고 있다. 따 라서, 본 문서에서는 BDOF에 대해서도 GBi 인덱스와 명시적 가중 예측의 가중치 플래그를 고려하여 적용 여부를 결정하는 방안을 제안한다. 본 문서의 일 실시예로, 가중 쌍예측 여부를 고려하여 BDOF의 적용 여부를 결정할 수 있도록 하며, 이 경우 BDOF의 적용 조건은 다음 표 34에 제시된 조건들을 포함할 수 있다. 표 34"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 41, "content": "상기 표 34를 참조하면, L0 예측 및 L1 예측에 대해 명시적으로 가중치 적용 여부를 나타내는 조건(예: luma_weight_l0_flag, luma_weight_l1_flag)을 추가함으로써, 가중 쌍예측 여부에 따라 BDOF을 적용할지를 결 정할 수 있다. 예를 들어, L0 예측에 대해 명시적으로 가중치를 적용할지 여부를 나타내는 플래그 정보(예: luma_weight_l0_flag) 및 L1 예측에 대해 명시적으로 가중치를 적용할지 여부를 나타내는 플래그 정보(예: luma_weight_l1_flag)를 기반으로, 현재 블록에 명시적 가중 예측이 적용되는지 여부를 판단할 수 있다. 즉, luma_weight_l0_flag의 값이 0이고 luma_weight_l1_flag의 값이 0인 경우, 제한적으로 BDOF을 적용할 수 있다. 다시 말해, L0 및 L1 예측에 대해 명시적으로 가중 예측을 적용하지 않는 경우, BDOF을 적용하는 것으로 결정할수 있다. 본 실시에에서는 L0 예측 및 L1 예측에 대해 명시적으로 가중치 적용 여부를 나타내는 조건(예: luma_weight_l0_flag, luma_weight_l1_flag)과 함께, 상기 표 34에 나열된 나머지 조건들을 기반으로 BDOF 적 용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 34에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 34에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 34의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 33 또는 상기 표 34에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 상술한 바와 같이 GBi 인덱스뿐만 아니라 명시적 가중 예측의 가중 인자(weight factor)를 고려하여 DMVR 및 BDOF의 적용 여부를 판단할 수 있다. 이때, 명시적 가중 예측의 적용 여부를 판단하기 위해, luma_weight_lX_flag(여기서, X는 0 또는 1)를 이용하여 루마 성분에 대해 가중 예측 여부를 고려하였으나, 크 로마 성분에 대해서도 가중 예측 여부를 고려할 수 있다. 따라서, 본 문서에서는 루마 성분의 가중 인자뿐만 아 니라 크로마 성분의 가중 인자를 함께 고려하여 DMVR 및 BDOF의 적용 여부를 판단하는 방안을 제안한다. 본 문서의 일 실시예로, 현재 블록의 루마 성분 및 크로마 성분에 대해 명시적 가중 예측의 가중 인자를 고려하 여 DMVR의 적용 여부를 결정할 수 있으며, 이 경우 DMVR의 적용 조건은 다음 표 35에 제시된 조건들을 포함할 수 있다. 표 35"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 42, "content": "상기 표 35를 참조하면, L0 예측의 루마 성분(루마 예측 값) 및 L1 예측의 루마 성분(루마 예측 값)에 대해 명 시적으로 가중치 적용 여부를 나타내는 조건(예: luma_weight_l0_flag, luma_weight_l1_flag), L0 예측의 크로 마 성분(크로마 예측 값) 및 L1 예측의 크로마 성분(크로마 예측 값)에 대해 명시적으로 가중치 적용 여부를 나 타내는 조건(예: chroma_weight_l0_flag, chroma_weight_l1_flag), L0 예측 및 L1 예측에 적용되는 가중치를 나타내는 인덱스 조건(예: GbiIdx)을 추가함으로써, 루마 및 크로마 성분 둘 다에 대해 가중치(즉, 가중 인자) 가 명시적으로 적용되지 않는 경우에 한해 제한적으로 DMVR을 적용하도록 할 수 있다. 예를 들어, L0 예측의 루마 성분(루마 예측 값)에 대해 명시적으로 가중치를 적용하는지 여부를 나타내는 플래 그 정보(예: luma_weight_l0_flag) 및 L1 예측의 루마 성분(루마 예측 값)에 대해 명시적으로 가중치를 적용하 는지 여부를 나타내는 플래그 정보(예: luma_weight_l1_flag)를 기반으로, 현재 블록의 루마 성분에 대해 명시 적 가중 예측의 가중 인자가 적용되는지 여부를 판단할 수 있다. 또한, L0 예측의 크로마 성분(크로마 예측 값)에 대해 명시적으로 가중치를 적용하는지 여부를 나타내는 플래그 정보(예: chroma_weight_l0_flag) 및 L1 예측의 크로마 성분(크로마 예측 값)에 대해 명시적으로 가중치를 적용 하는지 여부를 나타내는 플래그 정보(예: chroma_weight_l1_flag)를 기반으로, 현재 블록의 크로마 성분에 대해명시적 가중 예측의 가중 인자가 적용되는지 여부를 판단할 수 있다. 즉, luma_weight_l0_flag의 값이 0이고 luma_weight_l1_flag의 값이 0인 경우 루마 성분에 대해 명시적으로 가 중 인자가 존재하지 않음을 판단할 수 있고, chroma_weight_l0_flag의 값이 0이고 chroma_weight_l1_flag의 값 이 0인 경우 크로마 성분에 대해 명시적으로 가중 인자가 존재하지 않음을 판단할 수 있다. 이와 같이 루마 성 분 및 크로마 성분 둘 다에 대해 명시적 가중 인자가 존재하지 않는 경우, 제한적으로 DMVR을 적용할 수 있다. 또한, L0 예측 및 L1 예측에 적용되는 가중치를 나타내는 쌍예측 가중치 인덱스(예: GbiIdx)의 값을 기반으로, 현재 블록에 서로 다른 가중치를 사용하는 쌍예측(즉, L0 예측 및 L1 예측)이 적용되는지를 판단할 수 있다. 즉, 쌍예측 가중치 인덱스(예: GbiIdx)의 값이 0인 경우는 상기 표 3의 실시예에서 설명한 바와 같이 L0 예측 및 L1 예측에 서로 다른 가중치가 적용되지 않는 디폴트인 경우일 수 있다. 따라서, 쌍예측 가중치 인덱스(예: GbiIdx)의 값이 0일 때, 제한적으로 DMVR을 적용할 수 있다. 실시예에 따라, 루마 성분의 L0 및 L1 예측에 대해 명시적으로 가중 예측을 적용하지 않는 경우 (luma_weight_l0_flag의 값이 0이고 luma_weight_l1_flag의 값이 0인 경우)와, 크로마 성분의 L0 및 L1 예측에 대해 명시적으로 가중 예측을 적용하지 않는 경우 (chroma_weight_l0_flag의 값이 0이고 chroma_weight_l1_flag의 값이 0인 경우)일 때, 쌍예측 가중치 인덱스(예: GbiIdx) 정보를 더 획득하여 쌍예측 가중치 인덱스(예: GbiIdx)의 값이 0인지를 판단할 수 있다. 본 실시에에서는 루마 성분의 L0 예측 및 L1 예측에 대해 명시적으로 가중치 적용 여부를 나타내는 조건(예: luma_weight_l0_flag, luma_weight_l1_flag), 크로마 성분의 L0 예측 및 L1 예측에 대해 명시적으로 가중치 적 용 여부를 나타내는 조건(예: chroma_weight_l0_flag, chroma_weight_l1_flag), L0 예측 및 L1 예측에 적용되 는 가중치를 나타내는 인덱스 조건(예: GbiIdx)과 함께, 상기 표 35에 나열된 나머지 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 35에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 35에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 35의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 또한, 본 문서의 일 실시예로, 현재 블록의 루마 성분 및 크로마 성분에 대해 명시적 가중 예측의 가중 인자를 고려하여 BDOF의 적용 여부를 결정할 수 있으며, 이 경우 BDOF의 적용 조건은 다음 표 36에 제시된 조건들을 포 함할 수 있다. 표 36"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 43, "content": "상기 표 36을 참조하면, L0 예측의 루마 성분(루마 예측 값) 및 L1 예측의 루마 성분(루마 예측 값)에 대해 명 시적으로 가중치 적용 여부를 나타내는 조건(예: luma_weight_l0_flag, luma_weight_l1_flag), L0 예측의 크로 마 성분(크로마 예측 값) 및 L1 예측의 크로마 성분(크로마 예측 값)에 대해 명시적으로 가중치 적용 여부를 나 타내는 조건(예: chroma_weight_l0_flag, chroma_weight_l1_flag)을 추가함으로써, 루마 및 크로마 성분 둘 다 에 대해 가중치(즉, 가중 인자)가 명시적으로 적용되지 않는 경우에 한해 제한적으로 BDOF을 적용하도록 할 수있다. 예를 들어, L0 예측의 루마 성분(루마 예측 값)에 대해 명시적으로 가중치를 적용하는지 여부를 나타내는 플래 그 정보(예: luma_weight_l0_flag)의 값이 0이고, L1 예측의 루마 성분(루마 예측 값)에 대해 명시적으로 가중 치를 적용하는지 여부를 나타내는 플래그 정보(예: luma_weight_l1_flag)의 값이 0인 경우, 현재 블록의 루마 성분에 대한 L0 예측 및 L1 예측의 가중 인자가 명시적으로 존재하지 않음을 판단할 수 있다. 또한, L0 예측의 크로마 성분(크로마 예측 값)에 대해 명시적으로 가중치를 적용하는지 여부를 나타내는 플래그 정보(예: chroma_weight_l0_flag)의 값이 0이고, L1 예측의 크로마 성분(크로마 예측 값)에 대해 명시적으로 가 중치를 적용하는지 여부를 나타내는 플래그 정보(예: chroma_weight_l1_flag)의 값이 0인 경우, 현재 블록의 크 로마 성분에 대한 L0 예측 및 L1 예측의 가중 인자가 명시적으로 존재하지 않음을 판단할 수 있다. 이와 같이 루마 성분 및 크로마 성분 둘 다에 대해 L0 예측 및 L1 예측 시에 가중 인자가 존재하지 않는 경우, 제한적으로 BDOF을 적용할 수 있다. 본 실시에에서는 루마 성분의 L0 예측 및 L1 예측에 대해 명시적으로 가중치 적용 여부를 나타내는 조건(예: luma_weight_l0_flag, luma_weight_l1_flag), 크로마 성분의 L0 예측 및 L1 예측에 대해 명시적으로 가중치 적 용 여부를 나타내는 조건(예: chroma_weight_l0_flag, chroma_weight_l1_flag)과 함께, 상기 표 36에 나열된 나머지 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 36에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 36에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 36의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 35 또는 상기 표 36에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 한편, 상술한 바와 같이 본 문서의 실시예들에 따르면 명시적 가중 예측을 고려하여 DMVR 및 BDOF의 적용 여부 를 판단할 수 있다. 이때, 명시적 가중 예측의 적용 여부를 판단하기 위해, 슬라이스의 종류를 고려할 수 있다. 따라서, 본 문서에서는 슬라이스 종류와 그에 따른 가중 예측의 적용 여부를 고려하여 DMVR 및 BDOF의 적용 여 부를 판단하는 방안을 제안한다. 본 문서의 일 실시예로, 현재 슬라이스의 종류에 따라 가중 예측의 적용 여부를 나타내는 플래그 정보를 이용하 여 DMVR 및 BDOF의 적용 여부를 판단할 수 있다. 여기서, 현재 슬라이스의 종류에 따라 가중 예측의 적용 여부 를 나타내는 플래그 정보는 PPS(Picture Parameter Set) 또는 SPS(Sequence Parameter Set) 신택스를 통해 인 코딩 장치에서 디코딩 장치로 시그널링될 수 있다. 일례로, 다음 표 37은 PPS 신택스를 통해 시그널링되는 상기 플래그 정보를 나타낸다. 표 37"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 44, "content": "상기 표 37을 참조하면, weighted_pred_flag 및 weighted_bipred_flag가 인코딩 장치에서 디코딩 장치로 시그 널링될 수 있다. 여기서, weighted_pred_flag는 가중 예측이 P 슬라이스에 적용되는지 여부를 나타내는 정보이 고, weighted_bipred_flag는 가중 예측이 B 슬라이스에 적용되는지 여부를 나타내는 정보일 수 있다. 예를 들어, weighted_pred_flag의 값이 0이면 가중 예측이 P 슬라이스에 적용되지 않음을 나타내고, weighted_pred_flag의 값이 1이면 가중 예측이 P 슬라이스에 적용됨을 나타낼 수 있다. 또한, weighted_bipred_flag의 값이 0이면 가중 예측이 B 슬라이스에 적용되지 않음을 나타내고, weighted_bipred_flag의 값이 1이면 가중 예측이 B 슬라이스에 적용됨을 나타낼 수 있다. 여기서, P 슬라이스(predictive slice)라 함은 하나의 움직임 벡터 및 참조 픽처 인덱스를 이용한 인터 예측(단)을 기반으로 디코딩되는 슬라이스를 의미할 수 있다. B 슬라이스(bi-predictive slice)라 함은 하나 이 상, 예컨대 두개의 움직임 벡터 및 참조 픽처 인덱스를 이용한 인터 예측을 기반으로 디코딩되는 슬라이스를 의 미할 수 있다. 본 문서의 일 실시예로, 가중 예측이 P 슬라이스에 적용되는지 여부를 나타내는 플래그 정보(예: weighted_pred_flag) 및 가중 예측이 B 슬라이스에 적용되는지 여부를 나타내는 플래그 정보(예: weighted_bipred_flag)를 기반으로, DMVR의 적용 여부를 결정할 수 있으며, 이 경우 DMVR의 적용 조건은 다음 표 38에 제시된 조건들을 포함할 수 있다. 표 38"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 45, "content": "상기 표 38을 참조하면, 가중 예측이 P 슬라이스에 적용되는지 여부를 나타내는 조건(예: weighted_pred_flag), 가중 예측이 B 슬라이스에 적용되는지 여부를 나타내는 조건(예: weighted_bipred_flag), L0 예측 및 L1 예측에 적용되는 가중치를 나타내는 인덱스 조건(예: GbiIdx)을 추가함으로써, P 슬라이스 및 B 슬라이스에 대해 가중 예측이 적용되지 않는 경우에 한해 제한적으로 DMVR을 적용하도록 할 수 있다. 예를 들어, weighted_pred_flag의 값이 1이면서 P 슬라이스인 경우가 아니고, 또한 weighted_bipred_flag의 값 이 1이면서 B 슬라이스인 경우가 아닐 때, DMVR을 적용할 수 있다. 다시 말해, P 슬라이스에 가중 예측이 적용 되지 않고 B 슬라이스에 가중 예측이 적용되지 않는 경우, DMVR을 적용하는 것으로 판단할 수 있다. 또한, L0 예측 및 L1 예측에 적용되는 가중치를 나타내는 쌍예측 가중치 인덱스(예: GbiIdx)의 값을 기반으로, 현재 블록에 서로 다른 가중치를 사용하는 쌍예측(즉, L0 예측 및 L1 예측)이 적용되는지를 판단할 수 있다. 즉, 쌍예측 가중치 인덱스(예: GbiIdx)의 값이 0인 경우는 상기 표 3의 실시예에서 설명한 바와 같이 L0 예측 및 L1 예측에 서로 다른 가중치가 적용되지 않는 디폴트인 경우일 수 있다. 따라서, 쌍예측 가중치 인덱스(예: GbiIdx)의 값이 0일 때, 제한적으로 DMVR을 적용할 수 있다. 본 실시예에서는 가중 예측이 P 슬라이스에 적용되는지 여부를 나타내는 조건(예: weighted_pred_flag), 가중 예측이 B 슬라이스에 적용되는지 여부를 나타내는 조건(예: weighted_bipred_flag), L0 예측 및 L1 예측에 적용 되는 가중치를 나타내는 인덱스 조건(예: GbiIdx)과 함께, 상기 표 38에 나열된 나머지 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 38에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 38에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 38의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 또한, 본 문서의 일 실시예로, 가중 예측이 P 슬라이스에 적용되는지 여부를 나타내는 플래그 정보(예: weighted_pred_flag) 및 가중 예측이 B 슬라이스에 적용되는지 여부를 나타내는 플래그 정보(예: weighted_bipred_flag)를 기반으로, BDOF의 적용 여부를 결정할 수 있으며, 이 경우 BDOF의 적용 조건은 다음 표 39에 제시된 조건들을 포함할 수 있다.표 39"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 46, "content": "상기 표 39를 참조하면, 가중 예측이 P 슬라이스에 적용되는지 여부를 나타내는 조건(예: weighted_pred_flag), 가중 예측이 B 슬라이스에 적용되는지 여부를 나타내는 조건(예: weighted_bipred_flag)을 추가함으로써, P 슬 라이스 및 B 슬라이스에 대해 가중 예측이 적용되지 않는 경우에 한해 제한적으로 BDOF을 적용하도록 할 수 있 다. 예를 들어, weighted_pred_flag의 값이 1이면서 P 슬라이스인 경우가 아니고, 또한 weighted_bipred_flag의 값 이 1이면서 B 슬라이스인 경우가 아닐 때, BDOF을 적용할 수 있다. 다시 말해, P 슬라이스에 가중 예측이 적용 되지 않고 B 슬라이스에 가중 예측이 적용되지 않는 경우, BDOF을 적용하는 것으로 판단할 수 있다. 본 실시예에서는 가중 예측이 P 슬라이스에 적용되는지 여부를 나타내는 조건(예: weighted_pred_flag), 가중 예측이 B 슬라이스에 적용되는지 여부를 나타내는 조건(예: weighted_bipred_flag)과 함께, 상기 표 39에 나열 된 나머지 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 즉, 디코딩 장치는 상기 표 39에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 39에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 39의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 38 또는 상기 표 39에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 한편, 블록 사이즈에 따라 쌍예측(bi-prediction) 또는 단예측(uni-prediction)을 수행할지 여부를 결정할 수 있다. 예를 들어, 현재 블록의 사이즈가 작은 경우(예: 4x8 또는 8x4 크기의 블록)에는 단예측만 가능하도록 제 한하고, 현재 블록의 사이즈가 큰 경우에는 쌍예측이 가능하도록 할 수 있다. 이와 같이 블록 사이즈가 작은 경 우 단예측만 수행하도록 제한할 경우, 쌍예측인 경우에 수행되는 DMVR 및 BDOF 역시 단예측 시 제한되는 블록 사이즈를 고려하여야 한다. 예컨대, 현재 블록의 크기가 4x8 또는 8x4인 경우 단예측만 가능하도록 제한할 경우, 현재 블록의 높이 또는 너비 중 적어도 하나가 4보다 큰 경우에 쌍예측이 수행될 수 있다. 따라서, 본 문 서에서는 쌍예측 또는 단예측 시에 적용되는 블록 사이즈를 고려하여 DMVR 및 BDOF를 적용하는 방안을 제안한다. 본 문서의 일 실시예로, 현재 블록의 높이(및/또는 너비)를 고려하여 BDOF의 적용 여부를 결정하는 방안을 제안 한다. 이 경우 BDOF의 적용 조건은 다음 표 40에 제시된 조건들을 포함할 수 있다. 표 40"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 47, "content": "상기 표 40을 참조하면, 현재 블록의 높이(및/또는 너비)와 관련된 조건들(예: cbHeight)을 변경함으로써, 특정 크기보다 큰 블록에 대해서만 제한적으로 BDOF를 적용할 수 있다. 예를 들어, 현재 블록의 높이(예: CbHeight) 가 4보다 큰 경우에 BDOF를 적용하는 조건을 사용할 수 있다. 또는 현재 블록의 너비(예: CbWidth)가 4보다 큰 경우에 BDOF를 적용하는 조건을 사용할 수도 있다. 이러한 현재 블록의 크기(예: CbHeight 또는 CbWidth)와 관 련된 조건을 만족한 경우 (즉, 현재 블록의 높이가 4보다 큰 경우) BDOF를 적용하고, 상기와 같은 현재 블록의 크기와 관련된 조건을 만족하지 않는 경우 (즉, 현재 블록의 높이가 4 이하인 경우) BDOF를 적용하지 않을 수 있다. 또한, 본 실시예에서는 현재 블록의 크기와 관련된 조건들(예: CbHeight, CbWidth)과 함께, 상기 표 40에서 나 열된 나머지 조건들을 기반으로 BDOF 적용 여부를 판단할 수 있다. 이때, 상기 표 40에 나열된 조건들을 만족하 는지 여부에 따라 bdofFlag를 유도할 수 있다. 이때, 상기 표 40에 나열된 조건들을 모두 만족한 경우, bdofFlag의 값은 1(true)로 유도되고, 그렇지 않은 경우 bdofFlag이 값은 0(false)로 유도될 수 있다. 여기서, bdofFlag는 현재 블록에 대한 BDOF를 적용하는지 여부를 나타내는 플래그 정보일 수 있다. 즉, 디코딩 장치는 상기 표 40에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 BDOF을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 40에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 BDOF을 적용하지 않을 수 있다. 이러한 상기 표 40의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 또한, 본 문서의 일 실시예로, 현재 블록의 높이(및/또는 너비)를 고려하여 DMVR의 적용 여부를 결정하는 방안 을 제안한다. 이 경우 DMVR의 적용 조건은 다음 표 41에 제시된 조건들을 포함할 수 있다. 표 41"}
{"patent_id": "10-2025-7005290", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 48, "content": "상기 표 41을 참조하면, 현재 블록의 높이(및/또는 너비)와 관련된 조건들(예: cbHeight)을 변경함으로써, 특정 크기보다 큰 블록에 대해서만 제한적으로 DMVR를 적용할 수 있다. 예를 들어, 현재 블록의 높이(예: CbHeight) 가 4보다 큰 경우에 DMVR를 적용하는 조건을 사용할 수 있다. 또는 현재 블록의 너비(예: CbWidth)가 4보다 큰 경우에 DMVR를 적용하는 조건을 사용할 수도 있다. 이러한 현재 블록의 크기(예: CbHeight 또는 CbWidth)와 관 련된 조건을 만족한 경우 (즉, 현재 블록의 높이가 4보다 큰 경우) DMVR를 적용하고, 상기와 같은 현재 블록의 크기와 관련된 조건을 만족하지 않는 경우 (즉, 현재 블록의 높이가 4 이하인 경우) DMVR를 적용하지 않을 수 있다. 또한, 본 실시예에서는 현재 블록의 크기와 관련된 조건들(예: CbHeight, CbWidth)과 함께, 상기 표 41에서 나 열된 나머지 조건들을 기반으로 DMVR 적용 여부를 판단할 수 있다. 이때, 상기 표 41에 나열된 조건들을 만족하 는지 여부에 따라 dmvrFlag를 유도할 수 있다. 이때, 상기 표 41에 나열된 조건들을 모두 만족한 경우, dmvrFlag의 값은 1(true)로 유도되고, 그렇지 않은 경우 dmvrFlag이 값은 0(false)로 유도될 수 있다. 여기서, dmvrFlag는 현재 블록에 대한 DMVR를 적용하는지 여부를 나타내는 플래그 정보일 수 있다. 즉, 디코딩 장치는 상기 표 41에 나열된 모든 조건들이 만족되는지 여부를 결정하고, 모든 조건들이 만족되는 경우 DMVR을 적용하여 true 쌍예측을 수행할 수 있다. 만일 상기 표 41에 나열된 조건 중 하나라도 만족되지 못 하는 경우, 디코딩 장치는 DMVR을 적용하지 않을 수 있다. 이러한 상기 표 41의 조건들은 인코딩 장치에서도 적 용될 수 있으며, 인코딩 장치에서는 디코딩 장치에서와 대응되는 방법으로 수행될 수 있다. 상기 표 40 또는 상기 표 41에서 나열된 조건들을 기반으로 true 쌍예측을 수행하는 방법은 DMVR 및 BDOF에 독 립적으로 적용될 수 있으며, 또는 DMVR 및 BDOF을 위한 동일 조건으로 적용될 수 있다. 본 문서는 상술한 표 1 내지 표 41의 적용 조건들을 기반으로 DMVR의 적용 여부를 나타내는 DMVR 플래그 정보 및 BDOF의 적용 여부를 나타내는 BDOF 플래그 정보를 유도할 수 있다. 예를 들어, DMVR의 적용 조건들(예컨대, 표 1 내지 표 41의 적용 조건들 중 적어도 하나 또는 적용 조건들의 조 합)을 기반으로 DMVR 플래그 정보(예: dmvrFlag)를 유도할 수 있다. 이때, dmvrFlag의 값이 1(또는 true)인 경 우 DMVR이 적용됨을 지시하고, dmvrFlag의 값이 0(또는 false)인 경우 DMVR이 적용되지 않음을 지시할 수 있다. 또한, BDOF의 적용 조건들(예컨대, 표 1 내지 표 41의 적용 조건들 중 적어도 하나 또는 적용 조건들의 조합)을 기반으로 BDOF 플래그 정보(예: bdofFlag)를 유도할 수 있다. 이때, bdofFlag의 값이 1(또는 true)인 경우 BDOF가 적용됨을 지시하고, bdofFlag의 값이 0(또는 false)인 경우 BDOF가 적용되지 않음을 지시할 수 있다. 도 10은 본 문서의 일 실시예에 따른 인코딩 장치에 의하여 수행될 수 있는 인코딩 방법을 개략적으로 나타내는 흐름도이다. 도 10에 개시된 방법은 도 2에서 개시된 인코딩 장치에 의하여 수행될 수 있다. 구체적으로, 도 10의 단계 S1000 ~ S1030은 도 2에 개시된 예측부 및 인터 예측부에 의하여 수행될 수 있고, 도 10의 단계S1040은 도 2에 개시된 레지듀얼 처리부에 의하여 수행될 수 있고, 도 10의 단계 S1050은 도 2에 개시된 엔트로피 인코딩부에 의하여 수행될 수 있다. 또한, 도 10에서 개시된 방법은 본 문서에서 상술한 실시예 들을 포함할 수 있다. 따라서, 도 10에서는 상술한 실시예들과 중복되는 내용에 관해서 구체적인 설명을 생략하 거나 간단히 하기로 한다. 도 10을 참조하면, 인코딩 장치는 현재 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출할 수 있다(S1000). 일 실시예로, 현재 블록에 대해 인터 예측을 수행하는 경우, 인코딩 장치는 현재 블록의 움직임 정보(움직임 벡 터, 참조 픽처 인덱스 등)를 도출할 수 있다. 예를 들어, 인코딩 장치는 움직임 추정(motion estimation)을 통 하여 참조 픽처들의 일정 영역(서치 영역) 내에서 현재 블록과 유사한 블록을 서치하고, 현재 블록과의 차이가 최소 또는 일정 기준 이하인 참조 블록을 도출할 수 있다. 이를 기반으로 참조 블록이 위치하는 참조 픽처를 가 리키는 참조 픽처 인덱스를 도출하고, 참조 블록과 현재 블록의 위치 차이를 기반으로 움직임 벡터를 도출할 수 있다. 또한, 인코딩 장치는 다양한 예측 모드들 중 현재 블록에 대하여 적용되는 인터 예측 모드를 결정할 수 있다. 인코딩 장치는 다양한 예측 모드들에 대한 RD cost를 비교하고 현재 블록에 대한 최적의 예측 모드를 결정할 수 있다. 예를 들어, 인코딩 장치는 현재 블록에 대한 최적의 예측 모드로서 머지 모드를 적용할지 여부를 판단할 수 있 다. 인코딩 장치는 현재 블록에 머지 모드를 적용하는 경우, 현재 블록의 주변 블록들을 기반으로 머지 후보 리 스트를 구성하고, 머지 인덱스 정보를 생성할 수 있다. 구체적으로, 머지 후보 리스트에 포함된 머지 후보들이 가리키는 참조 블록들(즉, 주변 블록들) 중 현재 블록과의 차이가 최소 또는 일정 기준 이하인 참조 블록을 도 출할 수 있다. 이 경우 도출된 참조 블록과 연관된 머지 후보가 선택되며, 선택된 머지 후보를 가리키는 머지 인덱스 정보가 생성되어 디코딩 장치로 시그널링될 수 있다. 선택된 머지 후보의 움직임 정보를 이용하여 현재 블록의 움직임 정보가 도출될 수 있다. 여기서, 움직임 정보는 움직임 벡터, 참조 픽처 인덱스 등의 정보를 포함할 수 있고, 인터 예측 타입(L0 예측, L1 예측, Bi 예측 등)에 따라 L0 움직임 정보 및/또는 L1 움직임 정보를 포함할 수 있다. 현재 블록에 쌍예측 (Bi 예측)이 적용되는 경우, 움직임 정보는 L0 방향의 움직임 벡터(L0 움직임 벡터) 및 L1 방향의 움직임 벡터 (L1 움직임 벡터)를 포함할 수 있다. 또한, 움직임 정보는 L0 참조 픽처 인덱스 및 L0 참조 픽처 리스트 내에서 L0 참조 픽처 인덱스에 의해 지시되는 L0 참조 픽처와, L1 참조 픽처 인덱스 및 L1 참조 픽처 리스트 내에서 L1 참조 픽처 인덱스에 의해 지시되는 L1 참조 픽처를 포함할 수 있다. 즉, 인코딩 장치는 머지 모드가 적용될 경우 현재 블록의 주변 블록들 중 머지 인덱스 정보에 의해 지시되는 주 변 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출하고, 이를 현재 블록의 L0 및 L1 움직임 벡터로 사용할 수 있다. 인코딩 장치는 현재 블록에 대해 DMVR을 적용할지 여부를 지시하는 DMVR 플래그 정보를 유도할 수 있다(S1010). 인코딩 장치는 코딩 효율, 복잡도, 예측 성능 등을 고려하여 현재 블록에 대해 DMVR을 적용할지 여부를 결정할 수 있다. 즉, 인코딩 장치는 현재 블록에 대해 DMVR의 적용 조건을 만족하는지 여부를 기반으로, 현재 블록에 DMVR을 적용할 수 있다. 여기서, DMVR의 적용 조건은 상기 표 1 내지 표 41에서 설명한 다양한 적용 조건들 중 일부(또는 전부) 혹은 특정 조합들로 구성될 수 있다. 또한, 인코딩 장치는 DMVR의 적용 조건을 만족하는지 여 부에 따라 DMVR 플래그 정보를 유도할 수 있다. DMVR 플래그 정보는 현재 블록에 대해 DMVR을 적용할지 여부를 나타내는 정보(예컨대, 상술한 dmvrFlag)일 수 있다. 일 실시예로, DMVR의 적용 조건은 현재 블록의 높이(Height)가 8 이상인 경우를 조건으로 포함할 수 있다. 이 경우, 인코딩 장치는 현재 블록의 높이가 8 이상인 경우를 만족하면, 현재 블록에 대해 DMVR을 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 예컨대, 현재 블록의 높이가 8 이상인 경우, DMVR 플래그 정보는 현재 블 록에 DMVR을 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우(즉, 현재 블록의 높이가 8 보다 작은 경우), DMVR 플래그 정보는 현재 블록에 DMVR을 적용하지 않는 것으로 지시하는 값 (예: 0 또는 false)으로 유도될 수 있다. 또한, 실시예에 따라, DMVR의 적용 조건은 L0 루마 가중 예측 플래그 정보 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우를 조건으로 포함할 수 있다. 이 경우, 인코딩 장치는 L0 루마 가중 예측 플래그 정보(예: luma_weight_l0_flag) 및 L1 루마 가중 예측 플래그 정보(예: luma_weight_l1_flag)의 값이 모두 0인 경우를 만족하면, 현재 블록에 대해 DMVR을 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 예컨대,luma_weight_l0_flag 및 luma_weight_l1_flag가 모두 0인 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용 하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도될 수 있다. 여기서, L0 루마 가중 예측 플래그 정보는 현재 블록의 루마 성분에 대한 L0 예측의 가중 팩터(weight factor) 가 존재하는지 여부를 지시하는 정보이고, L1 루마 가중 예측 플래그 정보는 현재 블록의 루마 성분에 대한 L1 예측의 가중 팩터가 존재하는지 여부를 지시하는 정보일 수 있다. 예를 들어, L0 루마 가중 예측 플래그 정보의 값이 0인 경우는 L0 예측의 루마 성분에 대해 가중 팩터가 존재하지 않음을 나타내고, L0 루마 가중 예측 플래 그 정보의 값이 1인 경우는 L0 예측의 루마 성분에 대해 가중 팩터가 존재함을 나타낼 수 있다. 또한, L1 루마 가중 예측 플래그 정보의 값이 0인 경우는 L1 예측의 루마 성분에 대해 가중 팩터가 존재하지 않음을 나타내고, L1 루마 가중 예측 플래그 정보의 값이 1인 경우는 L1 예측의 루마 성분에 대해 가중 팩터가 존재함을 나타낼 수 있다. 또한, 실시예에 따라, 인코딩 장치는 상술한 현재 블록의 높이가 8 이상인 경우와, L0 루마 가중 예측 플래그 정보 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우를 DMVR의 적용 조건으로 포함할 수 있다. 이때 상기 두 조건을 모두 만족시키는 경우, 인코딩 장치는 현재 블록에 DMVR를 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 또한, 실시예에 따라, DMVR의 적용 조건은 현재 블록에 인터 예측과 인트라 예측이 결합된 예측 모드(CIIP 모드)가 적용되지 않는 경우인 조건을 포함할 수 있다. 이때, 인코딩 장치는 현재 블록에 인터 예측과 인트라 예측이 결합된 예측 모드가 적용되지 않는 경우(예: ciip_flag가 0인 경우)를 만족하면, 현재 블록에 대해 DMVR 를 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 예컨대, ciip_flag가 0인 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. ciip_flag가 1인 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도 될 수 있다. 또한, 실시예에 따라, DMVR의 적용 조건은 현재 블록의 쌍예측 가중치 인덱스(bi-prediction weight index) 정 보의 값이 0인 경우 조건을 포함할 수 있다. 이때, 인코딩 장치는 쌍예측 가중치 인덱스 정보(예: GbiIdx)의 값 이 0인 경우를 만족하면, 현재 블록에 대해 DMVR를 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 예컨 대, GbiIdx가 0인 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도될 수 있다. 여기서, 쌍예측 가중치 인덱스 정보(예: GbiIdx)의 값이 0 인 경우는 L0 예측 및 L1 예측에 서로 다른 가중치를 적용하지 않는 디폴트인 경우일 수 있다. 일례로, 상기 표 3에 나타난 바와 같이, 쌍예측 가중치 인덱스 정보의 값이 0인 경우, L0 예측 및 L1 예측에 각각 1/2 가중치를 적용하는 경우일 수 있다. 또한, 실시예에 따라, DMVR의 적용 조건은 DMVR 기반 인터 쌍예측(inter bi-prediction)이 가용한(enable) 경 우인 조건, 현재 블록에 L0 참조 픽처 및 L1 참조 픽처를 기반으로 수행되는 쌍예측(bi-prediction)이 적용되는 경우인 조건, 현재 픽처를 기준으로 L0 참조 픽처와의 거리와 L1 참조 픽처와의 거리가 서로 동일한 경우인 조 건, 현재 블록에 머지 모드가 적용되는 경우인 조건, 현재 블록에 MMVD(merge mode with motion vector difference) 모드가 적용되지 않는 경우인 조건 등을 포함할 수 있다. 인코딩 장치는 상술한 DMVR의 적용 조건들 중 적어도 하나를 포함할 수 있으며, 이러한 DMVR의 적용 조건들을 기반으로 DMVR 플래그 정보를 유도할 수 있다. 이때, DMVR 적용 조건으로서 하나 이상의 조건을 포함하는 경우, 인코딩 장치는 DMVR의 적용 조건을 모두 만족하는 경우 DMVR 플래그 정보의 값을 true 또는 1로 유도할 수 있고, 그렇지 않은 경우 DMVR 플래그 정보의 값을 flase 또는 0으로 유도할 수 있다. 여기서, DMVR 플래그 정보를 유도함에 있어, 상기 나열된 DMVR 적용 조건들은 하나의 예시일 뿐이며, 전술한 표 1 내지 표 41의 조건들을 다양하게 조합하여 사용할 수 있다. DMVR 플래그 정보가 현재 블록에 대해 DMVR을 적용하는 것으로 지시하는 경우(예컨대, DMVR 플래그 정보가 true 또는 1 값으로 유도된 경우), 인코딩 장치는 현재 블록에 대해 DMVR을 적용하여, L0 움직임 벡터 및 L1 움직임 벡터를 기반으로 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 도출할 수 있다(S1020). 일 실시예로, 인코딩 장치는 L0 움직임 벡터를 기반으로 도출되는 L0 예측 샘플들과 L1 움직임 벡터를 기반으로 도출되는 L1 예측 샘플들을 기반으로, 최소 SAD(Sum of Absolute Differences)를 계산할 수 있다. 그리고, 인코딩 장치는 최소 SAD에 대응하는 샘플 위치를 기반으로, L0 움직임 벡터에 대한 리파인된 L0 움직임 벡터 및 L1 움직임 벡터에 대한 리파인된 L1 움직임 벡터를 도출할 수 있다. 여기서, L0 예측 샘플들은 L0 참조 픽처에서 L0 움직임 벡터에 의해 지시되는 참조 샘플들을 기반으로 도출되고, L1 예측 샘플들은 L1 참조 픽처에서 L1 움직임 벡터에 의해 지시되는 참조 샘플들을 기반으로 도출될 수 있다. 상술한 바와 같이, L0 참조 픽처는 L0 참조 픽처 리스트 내에 포함된 참조 픽처들 중에서 L0 참조 픽 처 인덱스에 의해 지시되는 참조 픽처이고, L1 참조 픽처는 L1 참조 픽처 리스트 내에 포함된 참조 픽처들 중에 서 L1 참조 픽처 인덱스에 의해 지시되는 참조 픽처일 수 있다. 또한, 리파인된 L0 움직임 벡터는 L0 참조 픽처에서 최소 SAD에 대응하는 샘플 위치를 가리키는 움직임 벡터일 수 있고, 리파인된 L1 움직임 벡터는 L1 참조 픽처에서 최소 SAD에 대응하는 샘플 위치를 가리키는 움직임 벡터 일 수 있다. DMVR을 적용하여 리파인된 움직임 벡터를 도출하는 과정은 도 4 및 도 5에서 상세히 설명한바 있으 므로, 여기서는 설명을 생략하도록 한다. 인코딩 장치는 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 기반으로 현재 블록에 대한 예측 샘플들 을 도출할 수 있다(S1030). 일 실시예로, 인코딩 장치는 리파인된 L0 움직임 벡터를 기반으로 도출되는 L0 예측 샘플들과 리파인된 L1 움직 임 벡터를 기반으로 도출되는 L1 예측 샘플들을 가중 합하여 현재 블록의 예측 샘플들을 도출할 수 있다. 이때, 예측 샘플들을 도출함에 있어서, 인코딩 장치는 코딩 효율, 복잡도, 예측 성능 등을 고려하여 현재 블록 에 대해 BDOF를 적용할지 여부를 결정할 수 있다. 즉, 인코딩 장치는 현재 블록에 대해 BDOF의 적용 조건을 만 족하는지 여부를 기반으로, 현재 블록에 BDOF를 적용할 수 있다. 여기서, BDOF의 적용 조건은 상기 표 1 내지 표 41에서 설명한 다양한 적용 조건들 중 일부(또는 전부) 혹은 특정 조합들로 구성될 수 있다. 또한, 인코딩 장치는 BDOF의 적용 조건을 만족하는지 여부에 따라 BDOF 플래그 정보를 유도할 수 있다. BDOF 플래그 정보는 현재 블록에 대해 BDOF를 적용할지 여부를 나타내는 정보(예컨대, 상술한 bdofFlag)일 수 있다. 일 실시예로, BDOF의 적용 조건은 L0 루마 가중 예측 플래그 정보 및 L1 루마 가중 예측 플래그 정보의 값이 모 두 0인 경우 조건을 포함할 수 있다. 이때, 인코딩 장치는 L0 루마 가중 예측 플래그 정보(예: luma_weight_l0_flag) 및 L1 루마 가중 예측 플래그 정보(예: luma_weight_l1_flag)의 값이 모두 0인 경우를 만족하면, 현재 블록에 대해 BDOF를 적용하는 것으로 BDOF 플래그 정보를 유도할 수 있다. 예컨대, luma_weight_l0_flag 및 luma_weight_l1_flag가 모두 0인 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용 하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도될 수 있다. 또한, 실시예에 따라, BDOF의 적용 조건은 현재 블록에 인터 예측과 인트라 예측이 결합된 예측 모드(CIIP 모드)가 적용되지 않는 경우인 조건을 포함할 수 있다. 이때, 인코딩 장치는 현재 블록에 인터 예측과 인트라 예측이 결합된 예측 모드가 적용되지 않는 경우(예: ciip_flag가 0인 경우)를 만족하면, 현재 블록에 대해 BDOF 를 적용하는 것으로 BDOF 플래그 정보를 유도할 수 있다. 예컨대, ciip_flag가 0인 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. ciip_flag가 1인 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도 될 수 있다. 또한, 실시예에 따라, BDOF의 적용 조건은 현재 픽처와 L0 참조 픽처 간의 제1 POC(picture order count) 차이 와 현재 픽처와 L1 참조 픽처 간의 제2 POC 차이가 동일한 경우인 조건을 포함할 수 있다. 이때, 인코딩 장치는 제1 POC 차이(예: DiffPicOrderCnt(currPic, RefPicList0 [refIdxL0]))와 제2 POC 차이(예: DiffPicOrderCnt(currPic, RefPicList1 [ refIdxL1 ] ))가 동일한 경우를 만족하면, 현재 블록에 대해 BDOF를 적용하는 것으로 BDOF 플래그 정보를 유도할 수 있다. 예컨대, DiffPicOrderCnt(currPic, RefPicList0 [refIdxL0]) - DiffPicOrderCnt(currPic, RefPicList1 [ refIdxL1 ] )가 0인 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우, BDOF 플 래그 정보는 현재 블록에 BDOF를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도될 수 있다. 또한, 실시예에 따라, BDOF의 적용 조건은 BDOF 기반 인터 예측이 가용한(enable) 경우인 조건, 현재 블록에 L0 참조 픽처 및 L1 참조 픽처를 기반으로 수행되는 쌍예측(bi-prediction)이 적용되는 경우인 조건, 현재 블록의 쌍예측 가중치 인덱스(bi-prediction weight index) 정보의 값이 0인 조건, 현재 블록에 어파인 모드가 적용되 지 않는 경우인 조건, 현재 블록에 서브블록 기반 머지 모드가 적용되지 않는 경우인 조건, 현재 블록이 루마성분인 조건, 현재 블록의 높이가 8 이상인 경우 등을 포함할 수 있다. 인코딩 장치는 상술한 BDOF의 적용 조건들 중 적어도 하나를 포함할 수 있으며, 이러한 BDOF의 적용 조건들을 기반으로 BDOF 플래그 정보를 유도할 수 있다. 이때, BDOF 적용 조건으로서 하나 이상의 조건을 포함하는 경우, 인코딩 장치는 BDOF의 적용 조건을 모두 만족하는 경우 BDOF 플래그 정보의 값을 true 또는 1로 유도할 수 있고, 그렇지 않은 경우 BDOF 플래그 정보의 값을 flase 또는 0으로 유도할 수 있다. 여기서, BDOF 플래그 정보를 유도함에 있어, 상기 나열된 BDOF 적용 조건들은 하나의 예시일 뿐이며, 전술한 표 1 내지 표 41의 조건들을 다양하게 조합하여 사용할 수 있다. BDOF 플래그 정보가 현재 블록에 BDOF를 적용하는 것으로 지시하는 경우(예컨대, BDOF 플래그 정보가 true 또는 1 값으로 유도된 경우), 인코딩 장치는 현재 블록에 대해 BDOF를 적용하여, 예측 샘플들을 도출할 수 있다. 일 실시예로, 인코딩 장치는 리파인된 L0 움직임 벡터를 기반으로 도출되는 L0 예측 샘플들에 대한 제1 그라디 언트(gradient) 및 리파인된 L1 움직임 벡터를 기반으로 도출되는 L1 예측 샘플들에 대한 제2 그라디언트 (gradient)를 계산할 수 있다. 그리고, 인코딩 장치는 L0 예측 샘플들, L1 예측 샘플들, 제1 그라디언트, 제2 그라디언트를 기반으로 현재 블록에 대한 예측 샘플들을 최종적으로 도출할 수 있다. 일례로, BDOF를 적용하여 예측 샘플들을 도출하는 과정은 상술한 수학식 1 내지 수학식 6과 같은 계산을 이용할 수 있다. 인코딩 장치는 예측 샘플들을 기반으로 현재 블록에 대한 레지듀얼 샘플들을 도출하고(S1040), 레지듀얼 샘플들 에 관한 정보를 포함하는 영상 정보를 인코딩할 수 있다(S1050). 즉, 인코딩 장치는 현재 블록에 대한 원본 샘플들과 현재 블록의 예측 샘플들을 기반으로 레지듀얼 샘플들을 도 출할 수 있다. 그리고, 인코딩 장치는 레지듀얼 샘플들에 대한 정보를 생성할 수 있다. 여기서, 레지듀얼 샘플 들에 대한 정보는, 레지듀얼 샘플들에 변환 및 양자화를 수행하여 도출된 양자화된 변환 계수들의 값 정보, 위 치 정보, 변환 기법, 변환 커널, 양자화 파라미터 등의 정보를 포함할 수 있다. 인코딩 장치는 레지듀얼 샘플들에 관한 정보를 인코딩하여 비트스트림으로 출력하고, 이를 네트워크 또는 저장 매체를 통하여 디코딩 장치로 전송할 수 있다. 또한, 인코딩 장치는 상술한 단계 S1000 내지 S1050에서 도출된 영상 정보를 인코딩하여 비트스트림으로 출력할 수 있다. 예를 들어, 머지 플래그 정보, 머지 인덱스 정보, L0 참조 픽처 인덱스, L1 참조 픽처 인덱스, L0 루 마 가중 예측 플래그 정보, L1 루마 가중 예측 플래그 정보, 쌍예측 가중치 인덱스 정보 등이 영상 정보에 포함 되어 인코딩될 수 있고, 이러한 인코딩된 영상 정보는 디코딩 장치로 시그널링될 수 있다. 도 11은 본 문서의 일 실시예에 따라 디코딩 장치에 의하여 수행될 수 있는 디코딩 방법을 개략적으로 나타내는 흐름도이다. 도 11에 개시된 방법은 도 3에서 개시된 디코딩 장치에 의하여 수행될 수 있다. 구체적으로, 도 11의 단계 S1100 ~ S1130은 도 3에 개시된 예측부 및 인터 예측부에 의하여 수행될 수 있고, 도 11의 단계 S1140은 도 3에 개시된 가산부에 의하여 수행될 수 있다. 또한, 도 11에서 개시된 방법은 본 문서에서 상 술한 실시예들을 포함할 수 있다. 따라서, 도 11에서는 상술한 실시예들과 중복되는 내용에 관해서 구체적인 설 명을 생략하거나 간단히 하기로 한다. 도 11을 참조하면, 디코딩 장치는 현재 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출할 수 있다(S1100). 일 실시예로, 디코딩 장치는 인코딩 장치로부터 시그널링되는 예측 정보를 기반으로 현재 블록에 대한 예측 모 드를 결정할 수 있다. 그리고, 디코딩 장치는 예측 모드를 기반으로 현재 블록의 움직임 정보(움직임 벡터, 참 조 픽처 인덱스 등)를 도출할 수 있다. 여기서 예측 모드는 스킵 모드, 머지 모드, (A)MVP 모드 등을 포함할 수 있다. 예를 들어, 디코딩 장치는 현재 블록에 머지 모드가 적용되는 경우, 현재 블록의 주변 블록들을 기반으로 머지 후보 리스트를 구성하고, 머지 후보 리스트에 포함된 머지 후보들 중 하나의 머지 후보를 선택할 수 있다. 이때, 상술한 머지 인덱스 정보(merge index)를 기반으로 머지 후보 리스트에서 하나의 머지 후보가 선택될 수 있다. 디코딩 장치는 선택된 머지 후보의 움직임 정보를 이용하여 현재 블록의 움직임 정보를 도출할 수 있다. 즉, 머지 후보 리스트에 포함된 머지 후보들 중 머지 인덱스에 의해 선택된 머지 후보의 움직임 정보가 현재 블 록의 움직임 정보로 이용될 수 있다. 여기서, 움직임 정보는 움직임 벡터, 참조 픽처 인덱스 등의 정보를 포함할 수 있고, 인터 예측 타입(L0 예측, L1 예측, Bi 예측 등)에 따라 L0 움직임 정보 및/또는 L1 움직임 정보를 포함할 수 있다. 현재 블록에 쌍예측 (Bi 예측)이 적용되는 경우, 움직임 정보는 L0 방향의 움직임 벡터(L0 움직임 벡터) 및 L1 방향의 움직임 벡터 (L1 움직임 벡터)를 포함할 수 있다. 또한, 움직임 정보는 L0 참조 픽처 인덱스 및 L0 참조 픽처 리스트 내에서 L0 참조 픽처 인덱스에 의해 지시되는 L0 참조 픽처와, L1 참조 픽처 인덱스 및 L1 참조 픽처 리스트 내에서 L1 참조 픽처 인덱스에 의해 지시되는 L1 참조 픽처를 포함할 수 있다. 즉, 디코딩 장치는 현재 블록의 예측 모드 정보(예: 머지 모드인지 여부를 지시하는 머지 플래그(merge_flag)) 를 기반으로, 현재 블록에 머지 모드가 적용되는지 여부를 판단할 수 있다. 머지 플래그를 기반으로 현재 블록 에 머지 모드가 적용되는 경우, 디코딩 장치는 머지 인덱스 정보를 획득할 수 있다. 그리고, 디코딩 장치는 머 지 후보 리스트에 포함된 주변 블록들 중 머지 인덱스 정보에 의해 지시되는 주변 블록의 L0 움직임 벡터 및 L1 움직임 벡터를 도출하고, 이를 현재 블록의 L0 및 L1 움직임 벡터로 사용할 수 있다. 디코딩 장치는 현재 블록에 대해 DMVR을 적용할지 여부를 지시하는 DMVR 플래그 정보를 유도할 수 있다(S1110). 디코딩 장치는 코딩 효율, 복잡도, 예측 성능 등을 고려하여 현재 블록에 대해 DMVR을 적용할지 여부를 결정할 수 있다. 즉, 디코딩 장치는 현재 블록에 대해 DMVR의 적용 조건을 만족하는지 여부를 기반으로, 현재 블록에 DMVR을 적용할 수 있다. 여기서, DMVR의 적용 조건은 상기 표 1 내지 표 41에서 설명한 다양한 적용 조건들 중 일부(또는 전부) 혹은 특정 조합들로 구성될 수 있다. 또한, 디코딩 장치는 DMVR의 적용 조건을 만족하는지 여 부에 따라 DMVR 플래그 정보를 유도할 수 있다. DMVR 플래그 정보는 현재 블록에 대해 DMVR을 적용할지 여부를 나타내는 정보(예컨대, 상술한 dmvrFlag)일 수 있다. 일 실시예로, DMVR의 적용 조건은 현재 블록의 높이(Height)가 8 이상인 경우를 조건으로 포함할 수 있다. 이 경우, 디코딩 장치는 현재 블록의 높이가 8 이상인 경우를 만족하면, 현재 블록에 대해 DMVR을 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 예컨대, 현재 블록의 높이가 8 이상인 경우, DMVR 플래그 정보는 현재 블 록에 DMVR을 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우(즉, 현재 블록의 높이가 8 보다 작은 경우), DMVR 플래그 정보는 현재 블록에 DMVR을 적용하지 않는 것으로 지시하는 값 (예: 0 또는 false)으로 유도될 수 있다. 또한, 실시예에 따라, DMVR의 적용 조건은 L0 루마 가중 예측 플래그 정보 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우를 조건으로 포함할 수 있다. 이 경우, 디코딩 장치는 L0 루마 가중 예측 플래그 정보(예: luma_weight_l0_flag) 및 L1 루마 가중 예측 플래그 정보(예: luma_weight_l1_flag)의 값이 모두 0인 경우를 만족하면, 현재 블록에 대해 DMVR을 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 예컨대, luma_weight_l0_flag 및 luma_weight_l1_flag가 모두 0인 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용 하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도될 수 있다. 여기서, L0 루마 가중 예측 플래그 정보는 현재 블록의 루마 성분에 대한 L0 예측의 가중 팩터(weight factor) 가 존재하는지 여부를 지시하는 정보이고, L1 루마 가중 예측 플래그 정보는 현재 블록의 루마 성분에 대한 L1 예측의 가중 팩터가 존재하는지 여부를 지시하는 정보일 수 있다. 예를 들어, L0 루마 가중 예측 플래그 정보의 값이 0인 경우는 L0 예측의 루마 성분에 대해 가중 팩터가 존재하지 않음을 나타내고, L0 루마 가중 예측 플래 그 정보의 값이 1인 경우는 L0 예측의 루마 성분에 대해 가중 팩터가 존재함을 나타낼 수 있다. 또한, L1 루마 가중 예측 플래그 정보의 값이 0인 경우는 L1 예측의 루마 성분에 대해 가중 팩터가 존재하지 않음을 나타내고, L1 루마 가중 예측 플래그 정보의 값이 1인 경우는 L1 예측의 루마 성분에 대해 가중 팩터가 존재함을 나타낼 수 있다. 또한, 실시예에 따라, 디코딩 장치는 상술한 현재 블록의 높이가 8 이상인 경우와, L0 루마 가중 예측 플래그 정보 및 L1 루마 가중 예측 플래그 정보의 값이 모두 0인 경우를 DMVR의 적용 조건으로 포함할 수 있다. 이때 상기 두 조건을 모두 만족시키는 경우, 디코딩 장치는 현재 블록에 DMVR를 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 또한, 실시예에 따라, DMVR의 적용 조건은 현재 블록에 인터 예측과 인트라 예측이 결합된 예측 모드(CIIP 모드)가 적용되지 않는 경우인 조건을 포함할 수 있다. 이때, 디코딩 장치는 현재 블록에 인터 예측과 인트라 예측이 결합된 예측 모드가 적용되지 않는 경우(예: ciip_flag가 0인 경우)를 만족하면, 현재 블록에 대해 DMVR 를 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 예컨대, ciip_flag가 0인 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. ciip_flag가 1인경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도 될 수 있다. 또한, 실시예에 따라, DMVR의 적용 조건은 현재 블록의 쌍예측 가중치 인덱스(bi-prediction weight index) 정 보의 값이 0인 경우 조건을 포함할 수 있다. 이때, 디코딩 장치는 쌍예측 가중치 인덱스 정보(예: GbiIdx)의 값 이 0인 경우를 만족하면, 현재 블록에 대해 DMVR를 적용하는 것으로 DMVR 플래그 정보를 유도할 수 있다. 예컨 대, GbiIdx가 0인 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우, DMVR 플래그 정보는 현재 블록에 DMVR를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도될 수 있다. 여기서, 쌍예측 가중치 인덱스 정보(예: GbiIdx)의 값이 0 인 경우는 L0 예측 및 L1 예측에 서로 다른 가중치를 적용하지 않는 디폴트인 경우일 수 있다. 일례로, 상기 표 3에 나타난 바와 같이, 쌍예측 가중치 인덱스 정보의 값이 0인 경우, L0 예측 및 L1 예측에 각각 1/2 가중치를 적용하는 경우일 수 있다. 또한, 실시예에 따라, DMVR의 적용 조건은 DMVR 기반 인터 쌍예측(inter bi-prediction)이 가용한(enable) 경 우인 조건, 현재 블록에 L0 참조 픽처 및 L1 참조 픽처를 기반으로 수행되는 쌍예측(bi-prediction)이 적용되는 경우인 조건, 현재 픽처를 기준으로 L0 참조 픽처와의 거리와 L1 참조 픽처와의 거리가 서로 동일한 경우인 조 건, 현재 블록에 머지 모드가 적용되는 경우인 조건, 현재 블록에 MMVD(merge mode with motion vector difference) 모드가 적용되지 않는 경우인 조건 등을 포함할 수 있다. 디코딩 장치는 상술한 DMVR의 적용 조건들 중 적어도 하나를 포함할 수 있으며, 이러한 DMVR의 적용 조건들을 기반으로 DMVR 플래그 정보를 유도할 수 있다. 이때, DMVR 적용 조건으로서 하나 이상의 조건을 포함하는 경우, 디코딩 장치는 DMVR의 적용 조건을 모두 만족하는 경우 DMVR 플래그 정보의 값을 true 또는 1로 유도할 수 있고, 그렇지 않은 경우 DMVR 플래그 정보의 값을 flase 또는 0으로 유도할 수 있다. 여기서, DMVR 플래그 정보를 유도함에 있어, 상기 나열된 DMVR 적용 조건들은 하나의 예시일 뿐이며, 전술한 표 1 내지 표 41의 조건들을 다양하게 조합하여 사용할 수 있다. DMVR 플래그 정보가 현재 블록에 대해 DMVR을 적용하는 것으로 지시하는 경우(예컨대, DMVR 플래그 정보가 true 또는 1 값으로 유도된 경우), 디코딩 장치는 현재 블록에 대해 DMVR을 적용하여, L0 움직임 벡터 및 L1 움직임 벡터를 기반으로 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 도출할 수 있다(S1120). 일 실시예로, 디코딩 장치는 L0 움직임 벡터를 기반으로 도출되는 L0 예측 샘플들과 L1 움직임 벡터를 기반으로 도출되는 L1 예측 샘플들을 기반으로, 최소 SAD(Sum of Absolute Differences)를 계산할 수 있다. 그리고, 디 코딩 장치는 최소 SAD에 대응하는 샘플 위치를 기반으로, L0 움직임 벡터에 대한 리파인된 L0 움직임 벡터 및 L1 움직임 벡터에 대한 리파인된 L1 움직임 벡터를 도출할 수 있다. 여기서, L0 예측 샘플들은 L0 참조 픽처에서 L0 움직임 벡터에 의해 지시되는 참조 샘플들을 기반으로 도출되고, L1 예측 샘플들은 L1 참조 픽처에서 L1 움직임 벡터에 의해 지시되는 참조 샘플들을 기반으로 도출될 수 있다. 상술한 바와 같이, L0 참조 픽처는 L0 참조 픽처 리스트 내에 포함된 참조 픽처들 중에서 L0 참조 픽 처 인덱스에 의해 지시되는 참조 픽처이고, L1 참조 픽처는 L1 참조 픽처 리스트 내에 포함된 참조 픽처들 중에 서 L1 참조 픽처 인덱스에 의해 지시되는 참조 픽처일 수 있다. 또한, 리파인된 L0 움직임 벡터는 L0 참조 픽처에서 최소 SAD에 대응하는 샘플 위치를 가리키는 움직임 벡터일 수 있고, 리파인된 L1 움직임 벡터는 L1 참조 픽처에서 최소 SAD에 대응하는 샘플 위치를 가리키는 움직임 벡터 일 수 있다. DMVR을 적용하여 리파인된 움직임 벡터를 도출하는 과정은 도 4 및 도 5에서 상세히 설명한바 있으 므로, 여기서는 설명을 생략하도록 한다. 디코딩 장치는 리파인된 L0 움직임 벡터 및 리파인된 L1 움직임 벡터를 기반으로 현재 블록에 대한 예측 샘플들 을 도출할 수 있다(S1130). 일 실시예로, 디코딩 장치는 리파인된 L0 움직임 벡터를 기반으로 도출되는 L0 예측 샘플들과 리파인된 L1 움직 임 벡터를 기반으로 도출되는 L1 예측 샘플들을 가중 합하여 현재 블록의 예측 샘플들을 도출할 수 있다. 이때, 예측 샘플들을 도출함에 있어서, 디코딩 장치는 코딩 효율, 복잡도, 예측 성능 등을 고려하여 현재 블록 에 대해 BDOF를 적용할지 여부를 결정할 수 있다. 즉, 디코딩 장치는 현재 블록에 대해 BDOF의 적용 조건을 만 족하는지 여부를 기반으로, 현재 블록에 BDOF를 적용할 수 있다. 여기서, BDOF의 적용 조건은 상기 표 1 내지 표 41에서 설명한 다양한 적용 조건들 중 일부(또는 전부) 혹은 특정 조합들로 구성될 수 있다. 또한, 디코딩장치는 BDOF의 적용 조건을 만족하는지 여부에 따라 BDOF 플래그 정보를 유도할 수 있다. BDOF 플래그 정보는 현재 블록에 대해 BDOF를 적용할지 여부를 나타내는 정보(예컨대, 상술한 bdofFlag)일 수 있다. 일 실시예로, BDOF의 적용 조건은 L0 루마 가중 예측 플래그 정보 및 L1 루마 가중 예측 플래그 정보의 값이 모 두 0인 경우 조건을 포함할 수 있다. 이때, 디코딩 장치는 L0 루마 가중 예측 플래그 정보(예: luma_weight_l0_flag) 및 L1 루마 가중 예측 플래그 정보(예: luma_weight_l1_flag)의 값이 모두 0인 경우를 만족하면, 현재 블록에 대해 BDOF를 적용하는 것으로 BDOF 플래그 정보를 유도할 수 있다. 예컨대, luma_weight_l0_flag 및 luma_weight_l1_flag가 모두 0인 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용 하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도될 수 있다. 또한, 실시예에 따라, BDOF의 적용 조건은 현재 블록에 인터 예측과 인트라 예측이 결합된 예측 모드(CIIP 모드)가 적용되지 않는 경우인 조건을 포함할 수 있다. 이때, 디코딩 장치는 현재 블록에 인터 예측과 인트라 예측이 결합된 예측 모드가 적용되지 않는 경우(예: ciip_flag가 0인 경우)를 만족하면, 현재 블록에 대해 BDOF 를 적용하는 것으로 BDOF 플래그 정보를 유도할 수 있다. 예컨대, ciip_flag가 0인 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. ciip_flag가 1인 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도 될 수 있다. 또한, 실시예에 따라, BDOF의 적용 조건은 현재 픽처와 L0 참조 픽처 간의 제1 POC(picture order count) 차이 와 현재 픽처와 L1 참조 픽처 간의 제2 POC 차이가 동일한 경우인 조건을 포함할 수 있다. 이때, 디코딩 장치는 제1 POC 차이(예: DiffPicOrderCnt(currPic, RefPicList0 [refIdxL0]))와 제2 POC 차이(예: DiffPicOrderCnt(currPic, RefPicList1 [ refIdxL1 ] ))가 동일한 경우를 만족하면, 현재 블록에 대해 BDOF를 적용하는 것으로 BDOF 플래그 정보를 유도할 수 있다. 예컨대, DiffPicOrderCnt(currPic, RefPicList0 [refIdxL0]) - DiffPicOrderCnt(currPic, RefPicList1 [ refIdxL1 ] )가 0인 경우, BDOF 플래그 정보는 현재 블록에 BDOF를 적용하는 것으로 지시하는 값(예: 1 또는 true)으로 유도될 수 있다. 그렇지 않은 경우, BDOF 플 래그 정보는 현재 블록에 BDOF를 적용하지 않는 것으로 지시하는 값(예: 0 또는 false)으로 유도될 수 있다. 또한, 실시예에 따라, BDOF의 적용 조건은 BDOF 기반 인터 예측이 가용한(enable) 경우인 조건, 현재 블록에 L0 참조 픽처 및 L1 참조 픽처를 기반으로 수행되는 쌍예측(bi-prediction)이 적용되는 경우인 조건, 현재 블록의 쌍예측 가중치 인덱스(bi-prediction weight index) 정보의 값이 0인 조건, 현재 블록에 어파인 모드가 적용되 지 않는 경우인 조건, 현재 블록에 서브블록 기반 머지 모드가 적용되지 않는 경우인 조건, 현재 블록이 루마 성분인 조건, 현재 블록의 높이가 8 이상인 경우 등을 포함할 수 있다. 디코딩 장치는 상술한 BDOF의 적용 조건들 중 적어도 하나를 포함할 수 있으며, 이러한 BDOF의 적용 조건들을 기반으로 BDOF 플래그 정보를 유도할 수 있다. 이때, BDOF 적용 조건으로서 하나 이상의 조건을 포함하는 경우, 디코딩 장치는 BDOF의 적용 조건을 모두 만족하는 경우 BDOF 플래그 정보의 값을 true 또는 1로 유도할 수 있고, 그렇지 않은 경우 BDOF 플래그 정보의 값을 flase 또는 0으로 유도할 수 있다. 여기서, BDOF 플래그 정보를 유도함에 있어, 상기 나열된 BDOF 적용 조건들은 하나의 예시일 뿐이며, 전술한 표 1 내지 표 41의 조건들을 다양하게 조합하여 사용할 수 있다. BDOF 플래그 정보가 현재 블록에 BDOF를 적용하는 것으로 지시하는 경우(예컨대, BDOF 플래그 정보가 true 또는 1 값으로 유도된 경우), 디코딩 장치는 현재 블록에 대해 BDOF를 적용하여, 예측 샘플들을 도출할 수 있다. 일 실시예로, 디코딩 장치는 리파인된 L0 움직임 벡터를 기반으로 도출되는 L0 예측 샘플들에 대한 제1 그라디 언트(gradient) 및 리파인된 L1 움직임 벡터를 기반으로 도출되는 L1 예측 샘플들에 대한 제2 그라디언트 (gradient)를 계산할 수 있다. 그리고, 디코딩 장치는 L0 예측 샘플들, L1 예측 샘플들, 제1 그라디언트, 제2 그라디언트를 기반으로 현재 블록에 대한 예측 샘플들을 최종적으로 도출할 수 있다. 일례로, BDOF를 적용하여 예측 샘플들을 도출하는 과정은 상술한 수학식 1 내지 수학식 6과 같은 계산을 이용할 수 있다. 디코딩 장치는 예측 샘플들을 기반으로 현재 블록에 대한 복원 샘플들을 생성할 수 있다(S1140). 일 실시예로, 디코딩 장치는 예측 모드에 따라 예측 샘플들을 바로 복원 샘플들로 이용할 수도 있고, 또는 상기 예측 샘플들에 레지듀얼 샘플들을 더하여 복원 샘플들을 생성할 수도 있다. 디코딩 장치는 현재 블록에 대한 레지듀얼 샘플이 존재하는 경우, 현재 블록에 대한 레지듀얼에 관한 정보를 수 신할 수 있다. 레지듀얼에 관한 정보는 레지듀얼 샘플들에 관한 변환 계수를 포함할 수 있다. 디코딩 장치는 레 지듀얼 정보를 기반으로 현재 블록에 대한 레지듀얼 샘플들(또는 레지듀얼 샘플 어레이)을 도출할 수 있다. 디 코딩 장치는 예측 샘플들과 레지듀얼 샘플들을 기반으로 복원 샘플들을 생성할 수 있고, 상기 복원 샘플들을 기 반으로 복원 블록 또는 복원 픽처를 도출할 수 있다. 상술한 실시예에서, 방법들은 일련의 단계 또는 블록으로써 순서도를 기초로 설명되고 있지만, 본 문서의 실시 예들은 단계들의 순서에 한정되는 것은 아니며, 어떤 단계는 상술한 바와 다른 단계와 다른 순서로 또는 동시에 발생할 수 있다. 또한, 당업자라면 순서도에 나타내어진 단계들이 배타적이지 않고, 다른 단계가 포함되거나 순 서도의 하나 또는 그 이상의 단계가 본 문서의 범위에 영향을 미치지 않고 삭제될 수 있음을 이해할 수 있을 것 이다. 상술한 본 문서에 따른 방법은 소프트웨어 형태로 구현될 수 있으며, 본 문서에 따른 인코딩 장치 및/또는 디코 딩 장치는 예를 들어 TV, 컴퓨터, 스마트폰, 셋톱박스, 디스플레이 장치 등의 영상 처리를 수행하는 장치에 포 함될 수 있다. 본 문서에서 실시예들이 소프트웨어로 구현될 때, 상술한 방법은 상술한 기능을 수행하는 모듈(과정, 기능 등) 로 구현될 수 있다. 모듈은 메모리에 저장되고, 프로세서에 의해 실행될 수 있다. 메모리는 프로세서 내부 또는 외부에 있을 수 있고, 잘 알려진 다양한 수단으로 프로세서와 연결될 수 있다. 프로세서는 ASIC(application- specific integrated circuit), 다른 칩셋, 논리 회로 및/또는 데이터 처리 장치를 포함할 수 있다. 메모리는 ROM(read-only memory), RAM(random access memory), 플래쉬 메모리, 메모리 카드, 저장 매체 및/또는 다른 저 장 장치를 포함할 수 있다. 즉, 본 문서에서 설명한 실시예들은 프로세서, 마이크로 프로세서, 컨트롤러 또는 칩 상에서 구현되어 수행될 수 있다. 예를 들어, 각 도면에서 도시한 기능 유닛들은 컴퓨터, 프로세서, 마이크 로 프로세서, 컨트롤러 또는 칩 상에서 구현되어 수행될 수 있다. 이 경우 구현을 위한 정보(ex. information on instructions) 또는 알고리즘이 디지털 저장 매체에 저장될 수 있다. 또한, 본 문서가 적용되는 디코딩 장치 및 인코딩 장치는 멀티미디어 방송 송수신 장치, 모바일 통신 단말, 홈 시네마 비디오 장치, 디지털 시네마 비디오 장치, 감시용 카메라, 비디오 대화 장치, 비디오 통신과 같은 실시 간 통신 장치, 모바일 스트리밍 장치, 저장 매체, 캠코더, 주문형 비디오(VoD) 서비스 제공 장치, OTT 비디오 (Over the top video) 장치, 인터넷 스트리밍 서비스 제공 장치, 3차원(3D) 비디오 장치, VR(virtual reality) 장치, AR(argumente reality) 장치, 화상 전화 비디오 장치, 운송 수단 단말 (ex. 차량(자율주행차량 포함) 단 말, 비행기 단말, 선박 단말 등) 및 의료용 비디오 장치 등에 포함될 수 있으며, 비디오 신호 또는 데이터 신호 를 처리하기 위해 사용될 수 있다. 예를 들어, OTT 비디오(Over the top video) 장치로는 게임 콘솔, 블루레이 플레이어, 인터넷 접속 TV, 홈시어터 시스템, 스마트폰, 태블릿 PC, DVR(Digital Video Recoder) 등을 포함할 수 있다. 또한, 본 문서가 적용되는 처리 방법은 컴퓨터로 실행되는 프로그램의 형태로 생산될 수 있으며, 컴퓨터가 판독 할 수 있는 기록 매체에 저장될 수 있다. 본 문서에 따른 데이터 구조를 가지는 멀티미디어 데이터도 또한 컴퓨 터가 판독할 수 있는 기록 매체에 저장될 수 있다. 상기 컴퓨터가 판독할 수 있는 기록 매체는 컴퓨터로 읽을 수 있는 데이터가 저장되는 모든 종류의 저장 장치 및 분산 저장 장치를 포함한다. 상기 컴퓨터가 판독할 수 있 는 기록 매체는, 예를 들어, 블루레이 디스크(BD), 범용 직렬 버스(USB), ROM, PROM, EPROM, EEPROM, RAM, CD- ROM, 자기 테이프, 플로피 디스크 및 광학적 데이터 저장 장치를 포함할 수 있다. 또한, 상기 컴퓨터가 판독할 수 있는 기록 매체는 반송파(예를 들어, 인터넷을 통한 전송)의 형태로 구현된 미디어를 포함한다. 또한, 인코 딩 방법으로 생성된 비트스트림이 컴퓨터가 판독할 수 있는 기록 매체에 저장되거나 유무선 통신 네트워크를 통 해 전송될 수 있다. 또한, 본 문서의 실시예는 프로그램 코드에 의한 컴퓨터 프로그램 제품으로 구현될 수 있고, 상기 프로그램 코 드는 본 문서의 실시예에 의해 컴퓨터에서 수행될 수 있다. 상기 프로그램 코드는 컴퓨터에 의해 판독가능한 캐 리어 상에 저장될 수 있다. 도 12는 본 문서에서 개시된 실시예들이 적용될 수 있는 컨텐츠 스트리밍 시스템의 예를 나타낸다. 도 12를 참조하면, 본 문서의 실시예들에 적용되는 컨텐츠 스트리밍 시스템은 크게 인코딩 서버, 스트리밍 서버, 웹 서버, 미디어 저장소, 사용자 장치 및 멀티미디어 입력 장치를 포함할 수 있다. 상기 인코딩 서버는 스마트폰, 카메라, 캠코더 등과 같은 멀티미디어 입력 장치들로부터 입력된 컨텐츠를 디지 털 데이터로 압축하여 비트스트림을 생성하고 이를 상기 스트리밍 서버로 전송하는 역할을 한다. 다른 예로, 스마트폰, 카메라, 캠코더 등과 같은 멀티미디어 입력 장치들이 비트스트림을 직접 생성하는 경우, 상기 인코딩 서버는 생략될 수 있다. 상기 비트스트림은 본 문서의 실시예들에 적용되는 인코딩 방법 또는 비트스트림 생성 방법에 의해 생성될 수 있고, 상기 스트리밍 서버는 상기 비트스트림을 전송 또는 수신하는 과정에서 일시적으로 상기 비트스트림을 저 장할 수 있다. 상기 스트리밍 서버는 웹 서버를 통한 사용자 요청에 기초하여 멀티미디어 데이터를 사용자 장치에 전송하고, 상기 웹 서버는 사용자에게 어떠한 서비스가 있는지를 알려주는 매개체 역할을 한다. 사용자가 상기 웹 서버에 원하는 서비스를 요청하면, 상기 웹 서버는 이를 스트리밍 서버에 전달하고, 상기 스트리밍 서버는 사용자에게 멀티미디어 데이터를 전송한다. 이때, 상기 컨텐츠 스트리밍 시스템은 별도의 제어 서버를 포함할 수 있고, 이 경우 상기 제어 서버는 상기 컨텐츠 스트리밍 시스템 내 각 장치 간 명령/응답을 제어하는 역할을 한다. 상기 스트리밍 서버는 미디어 저장소 및/또는 인코딩 서버로부터 컨텐츠를 수신할 수 있다. 예를 들어, 상기 인 코딩 서버로부터 컨텐츠를 수신하게 되는 경우, 상기 컨텐츠를 실시간으로 수신할 수 있다. 이 경우, 원활한 스 트리밍 서비스를 제공하기 위하여 상기 스트리밍 서버는 상기 비트스트림을 일정 시간동안 저장할 수 있다. 상기 사용자 장치의 예로는, 휴대폰, 스마트 폰(smart phone), 노트북 컴퓨터(laptop computer), 디지털방송용 단말기, PDA(personal digital assistants), PMP(portable multimedia player), 네비게이션, 슬레이트 PC(slate PC), 태블릿 PC(tablet PC), 울트라북(ultrabook), 웨어러블 디바이스(wearable device, 예를 들어, 워치형 단말기 (smartwatch), 글래스형 단말기 (smart glass), HMD(head mounted display)), 디지털 TV, 데스 크탑 컴퓨터, 디지털 사이니지 등이 있을 수 있다. 상기 컨텐츠 스트리밍 시스템 내 각 서버들은 분산 서버로 운영될 수 있으며, 이 경우 각 서버에서 수신하는 데 이터는 분산 처리될 수 있다. 한편, 본 문서의 실시예가 적용되는 디코딩 장치 및 인코딩 장치는 디지털 기기(digital device)에 포함될 수 있다. \"디지털 기기(digital device)\"라 함은 예를 들어, 데이터, 컨텐트, 서비스 등을 송신, 수신, 처리 및 출력 중 적어도 하나를 수행 가능한 모든 디지털 기기를 포함한다. 여기서, 디지털 기기가 데이터, 컨텐트, 서 비스 등을 처리하는 것은, 데이터, 컨텐트, 서비스 등을 인코딩 및/또는 디코딩하는 동작을 포함한다. 이러한 디지털 기기는, 유/무선 네트워크(wire/wireless network)를 통하여 다른 디지털 기기, 외부 서버(external server) 등과 페어링 또는 연결(pairing or connecting)(이하 '페어링')되어 데이터를 송수신하며, 필요에 따라 변환(converting)한다. 디지털 기기는 예를 들어, 네트워크 TV(network TV), HBBTV(Hybrid Broadcast Broadband TV), 스마트 TV(Smart TV), IPTV(internet protocol television), PC(Personal Computer) 등과 같은 고정형 기기(standing device) 와, PDA(Personal Digital Assistant), 스마트 폰(Smart Phone), 태블릿 PC(Tablet PC), 노트북, VR/AR 기기 등과 같은 모바일 기기(mobile device or handheld device)를 모두 포함한다. 또한, 상기 디지털 기기는 멀티 미디어 방송 송수신 장치, 모바일 통신 단말, 홈 시네마 비디오 장치, 디지털 시네마 비디오 장치, 감시용 카메 라, 비디오 대화 장치, 비디오 통신과 같은 실시간 통신 장치, 모바일 스트리밍 장치, 저장 매체, 캠코더, 주문 형 비디오(VoD) 서비스 제공 장치, OTT 비디오(Over the top video) 장치, 인터넷 스트리밍 서비스 제공 장치, 3차원(3D) 비디오 장치, VR(virtual reality) 장치, AR(argumente reality) 장치, 화상 전화 비디오 장치, 운 송 수단 단말 (ex. 차량(자율주행차량 포함) 단말, 비행기 단말, 선박 단말 등) 및 의료용 비디오 장치 등을 포 함할 수 있다. 본 명세서에서는 편의상 후술하는 도 16에서는 디지털 TV를, 도 15에서는 모바일 기기를 디지털 기기의 실시예로 도시하고 설명한다. 한편, 본 문서에서 기술되는 \"유/무선 네트워크\"라 함은, 디지털 기기들 또는 디지털 기기와 외부 서버 사이에 서 상호 연결 또는/및 데이터 송수신을 위해 다양한 통신 규격 내지 프로토콜을 지원하는 통신 네트워크를 통칭 한다. 이러한 유/무선 네트워크는 규격에 의해 현재 또는 향후 지원될 통신 네트워크와 그를 위한 통신 프로토 콜을 모두 포함할 수 있는바 예컨대, USB(Universal Serial Bus), CVBS(Composite Video Banking Sync), 컴포 넌트, S-비디오(아날로그), DVI(Digital Visual Interface), HDMI(High Definition Multimedia Interface), RGB, D-SUB와 같은 유선 연결을 위한 통신 규격 내지 프로토콜과, 블루투스(Bluetooth), RFID(Radio Frequency Identification), 적외선 통신(IrDA, infrared Data Association), UWB(Ultra Wideband), 지그비(ZigBee), DLNA(Digital Living Network Alliance), WLAN(Wireless LAN)(Wi-Fi), Wibro(Wireless broadband), Wimax(World Interoperability for Microwave Access), HSDPA(High Speed Downlink Packet Access), LTE(LongTerm Evolution), Wi-Fi 다이렉트(Direct)와 같은 무선 연결을 위한 통신 규격에 의하여 형성될 수 있다. 이하 본 문서에서 단지 디지털 기기로 명명하는 경우에는 문맥에 따라 고정형 기기 또는 모바일 기기를 의미하 거나 양자를 모두 포함하는 의미일 수도 있다. 한편, 디지털 기기는 예컨대, 방송 수신 기능, 컴퓨터 기능 내지 지원, 적어도 하나의 외부 입력(external input)을 지원하는 지능형 기기로서, 상술한 유/무선 네트워크를 통해 이메일(e-mail), 웹 브라우징(web browsing), 뱅킹(banking), 게임(game), 애플리케이션(application) 등을 지원할 수 있다. 더불어, 상기 디지 털 기기는, 수기 방식의 입력 장치, 터치 스크린(touch screen), 공간 리모콘 등 적어도 하나의 입력 또는 제어 수단(이하 입력수단)을 지원하기 위한 인터페이스(interface)를 구비할 수 있다. 디지털 기기는, 표준화된 범용 OS(operating system)를 이용할 수 있다. 예를 들어, 디지털 기기는 범용의 OS 커널(kernel) 상에 다양한 애플 리케이션(application)을 추가(adding), 삭제(deleting), 수정(amending), 업데이트(updating) 등을 할 수 있 으며, 그를 통해 더욱 사용자 친화적인(user-friendly) 환경을 구성하여 제공할 수 있다. 한편, 본 문서에서 기술되는 외부 입력은, 외부 입력 기기 즉, 상술한 디지털 기기와 유/무선으로 연결되어 그 를 통해 관련 데이터를 송/수신하여 처리 가능한 모든 입력 수단 내지 디지털 기기를 포함한다. 여기서, 상기 외부 입력은 예를 들어, HDMI(High Definition Multimedia Interface), 플레이 스테이션(play station)이나 엑 스 박스(X-Box)와 같은 게임 기기, 스마트 폰, 태블릿 PC, 프린터기, 스마트 TV와 같은 디지털 기기들을 모두 포함한다. 또한, 본 문서에서 기술되는 \"서버(server)\"라 함은, 클라이언트(client) 즉, 상술한 디지털 기기로 데이터를 공급하는 모든 디지털 기기 내지 시스템을 포함하는 의미로, 프로세서(processor)로 불리기도 한다. 이러한 서 버로는 예컨대, 웹 페이지 내지 웹 컨텐트를 제공하는 포털 서버(portal server), 광고 데이터(advertising data)를 제공하는 광고 서버(advertising server), 컨텐트를 제공하는 컨텐트 서버(content server), SNS(Social Network Service) 서비스를 제공하는 SNS 서버(SNS server), 제조업체에서 제공하는 서비스 서버 (service server or manufacturing server) 등이 포함될 수 있다. 그 밖에, 본 문서에서 기술되는 \"채널(channel)\"이라 함은, 데이터를 송수신하기 위한 경로(path), 수단(means) 등을 의미하는 것으로, 방송 채널(broadcasting channel)을 예로 들 수 있다. 여기서, 방송 채널은 디지털 방송 의 활성화에 따라 피지컬 채널(physical channel), 가상 채널(virtual channel), 논리 채널(logical channel) 등의 용어로 표현된다. 방송 채널은 방송망이라 불릴 수 있다. 이와 같이, 방송 채널은 방송국에서 제공하는 방 송 컨텐트를 제공 또는 수신기에서 접근하기 위한 채널을 말하는 것으로, 상기 방송 컨텐트는 주로 실시간 방송 (real-time broadcasting)에 기초하는바 라이브 채널(live channel)이라고도 한다. 다만, 최근에는 방송을 위 한 매체(medium)가 더욱 다양화되어 실시간 방송 이외에 비실시간(non-real time) 방송도 활성화되고 있어 라이 브 채널은 단지 실시간 방송뿐만 아니라 경우에 따라서는 비실시간 방송을 포함한 방송 채널 전체를 의미하는 용어로 이해될 수도 있다. 본 문서에서는 상술한 방송 채널 이외에 채널과 관련하여 \"임의 채널(arbitrary channel)\"를 더 정의한다. 상기 임의 채널은, 방송 채널과 함께 EPG(Electronic Program Guide)와 같은 서비스 가이드(service guide)와 함께 제공될 수도 있고, 임의 채널만으로 서비스 가이드, GUI(Graphic User Interface) 또는 OSD 화면(On-Screen Display screen)를 구성/제공될 수도 있다. 한편, 송수신기 사이에 미리 약속된 채널 넘버를 가지는 방송 채널과 달리, 임의 채널은 수신기에서 임의로 할 당하는 채널로서 상기 방송 채널을 표현하기 위한 채널 넘버와는 기본적으로 중복되지 않는 채널 넘버가 할당된 다. 예컨대, 수신기는 특정 방송 채널을 튜닝하면, 튜닝된 채널을 통하여 방송 컨텐트와 그를 위한 시그널링 정 보(signaling information)를 전송하는 방송 신호를 수신한다. 여기서, 수신기는 상기 시그널링 정보로부터 채 널 정보를 파싱(parsing)하고, 파싱된 채널 정보에 기초하여 채널 브라우저(channel browser), EPG 등을 구성하 여 사용자에게 제공한다. 사용자는 입력 수단을 통해 채널 전환 요청을 하면, 수신기는 그에 대응하는 방식이다. 이와 같이, 방송 채널은 송수신단 사이에 미리 약속된 내용이므로, 임의 채널을 방송 채널과 중복 할당하는 경 우에는 사용자의 혼동을 초래하거나 혼동 가능성이 존재하므로, 전술한 바와 같이 중복 할당하지 않는 것이 바 람직하다. 한편, 상기와 같이 임의 채널 넘버를 방송 채널 넘버와 중복 할당하지 않더라도 사용자의 채널 서핑 과정에서 여전히 혼동 우려가 있는바, 이를 고려하여 임의 채널 넘버를 할당하는 것이 요구된다. 왜냐하면, 본 문서의 실시예에 따른 임의 채널 역시, 종래 방송 채널과 동일하게 입력 수단을 통한 사용자의 채널 전환 요청에 따라 동일한 방식으로 대응하여 방송 채널처럼 접근되도록 구현할 수 있기 때문이다. 따라서, 임의 채널 넘 버는, 사용자의 임의 채널 접근 편의와 방송 채널 넘버와의 구분 내지 식별 편의를 위하여, 방송 채널과 같이 숫자 형태가 아닌 임의 채널-1, 임의 채널-2 등과 같이 문자가 병기된 형태로 정의하고 표시할 수 있다. 한편, 이 경우, 비록 임의 채널 넘버의 표시는 임의 채널-1과 같이 문자가 병기된 형태이나 수신기 내부적으로는 상기 방송 채널의 넘버와 같이 숫자 형태로 인식하고 구현될 수 있다. 그 밖에, 임의 채널 넘버는, 방송 채널과 같이 숫자 형태로 제공될 수도 있으며, 동영상 채널-1, 타이틀-1, 비디오-1 등과 같이 방송 채널과 구분 가능한 다양 한 방식으로 채널 넘버를 정의하고 표시할 수도 있다. 디지털 기기는, 웹 서비스(web service)를 위해 웹 브라우저(web browser)를 실행하여 다양한 형태의 웹 페이지 (web page)를 사용자에게 제공한다. 여기서, 상기 웹 페이지에는 동영상(video content)이 포함된 웹 페이지도 포함되는데, 본 문서의 실시예에서는 동영상을 웹 페이지로부터 별도로 또는 독립적으로 분리하여 처리한다. 그 리고 상기 분리되는 동영상은, 전술한 임의 채널 넘버를 할당하고, 서비스 가이드 등을 통해 제공하고, 사용자 가 서비스 가이드나 방송 채널 시청 과정에서 채널 전환 요청에 따라 출력되도록 구현할 수 있다. 그 밖에, 웹 서비스 이외에도 방송 컨텐트, 게임, 애플리케이션 등의 서비스에 대해서도, 소정 컨텐트, 이미지, 오디오, 항 목 등을 상기 방송 컨텐트, 게임, 애플리케이션 자체로부터 독립적으로 분리 처리하고, 그 재생, 처리 등을 위 해 임의 채널 넘버를 할당하고 상술한 바와 같이, 구현할 수 있다. 도 13은 디지털 기기를 포함한 서비스 시스템(service system)의 일 예를 개략적으로 나타낸 도면이다. 디지털 기기를 포함한 서비스 시스템은, 컨텐트 제공자(Content Provider; CP), 서비스 제공자(Service Provider; SP), 네트워크 제공자(Network Provider; NP) 및 HNED(Home Network End User)(Customer)를 포함한다. 여기서, HNED는 예를 들어, 클라이언트 즉, 디지털 기기이다. 컨텐트 제공자는, 각종 컨텐트를 제작하여 제공한다. 이러한 컨텐트 제공자로 도 13에 도시된 바와 같이, 지상파 방송 송출자(terrestrial broadcaster), 케이블 방송 사업자(cable SO (System Operator)) 또는 MSO (Multiple SO), 위성 방송 송출자(satellite broadcaster), 다양한 인터넷 방송 송출자(Internet broadcaster), 개인 컨텐트 제공자들(Private CPs) 등을 예시할 수 있다. 한편, 컨텐트 제공자는, 방송 컨텐트 외에도 다양한 애플리케이션 등을 제공한다. 서비스 제공자는, 컨텐트 제공자가 제공하는 컨텐트를 서비스 패키지화하여 HNED로 제공한다. 예를 들어, 도 13의 서비스 제공자는, 제1 지상파 방송, 제2 지상파 방송, 케이블 MSO, 위성 방송, 다양한 인터넷 방송, 애플리케이션 등을 패키지화하여 HNED에게 제공한다. 서비스 제공자는, 유니-캐스트(uni-cast) 또는 멀티-캐스트(multi-cast) 방식으로 클라이언트에 서 비스를 제공한다. 한편, 서비스 제공자는 데이터를 미리 등록된 다수의 클라이언트로 한꺼번에 전 송할 수 있는데, 이를 위해 IGMP(Internet Group Management Protocol) 프로토콜 등을 이용할 수 있다. 상술한 컨텐트 제공자와 서비스 제공자는, 동일한 개체(same or single entity)일 수 있다. 예를 들어, 컨텐트 제공자가 제작한 컨텐트를 서비스 패키지화하여 HNED로 제공함으로써 서비스 제공자 의 기능도 함께 수행하거나 그 반대일 수도 있다. 네트워크 제공자는, 컨텐트 제공자 또는/및 서비스 제공자와 클라이언트 사이의 데이 터 교환을 위한 네트워크 망을 제공한다. 클라이언트는, 홈 네트워크를 구축하여 데이터를 송수신할 수 있다. 한편, 서비스 시스템 내 컨텐트 제공자 또는/및 서비스 제공자는 전송되는 컨텐트의 보호를 위해 제한 수신(conditional access) 또는 컨텐트 보호(content protection) 수단을 이용할 수 있다. 이 경우, 클라 이언트는 상기 제한 수신이나 컨텐트 보호에 대응하여 케이블카드(CableCARD)(POD: Point of Deployment), DCAS(Downloadable CAS) 등과 같은 처리 수단을 이용할 수 있다. 그 밖에, 클라이언트도 네트워크 망(또는 통신 망)을 통해, 양방향 서비스를 이용할 수 있다. 이러한 경 우, 오히려 클라이언트가 컨텐트 제공자의 기능을 수행할 수도 있으며, 기존 서비스 제공자는 이를 수신하여 다시 다른 클라이언트로 전송할 수도 있다. 도 14는 디지털 기기의 일 실시예를 설명하기 위해 도시한 구성 블록도이다. 여기서, 도 14는 예를 들어, 도 13 의 클라이언트에 해당할 수 있으며, 전술한 디지털 기기를 의미한다. 디지털 기기는, 네트워크 인터페이스부(Network Interface), TCP/IP 매니저(TCP/IP Manager), 서비스 전달 매니저(Service Delivery Manager), SI 디코더, 역다중화부 (Demux), 오디오 디코더(Audio Decoder), 비디오 디코더(Video Decoder), 디스플레이부 (Display A/V and OSD Module), 서비스 제어 매니저(Service Control Manager), 서비스 디스커버 리 매니저(Service Discovery Manager), SI & 메타데이터 데이터베이스(SI&Metadata DB), 메타데 이터 매니저(Metadata Manager), 서비스 매니저, UI 매니저 등을 포함하여 구성된다. 네트워크 인터페이스부는, 네트워크 망을 통하여 IP 패킷들(internet protocol (IP) packets)을 수신하 거나 전송한다. 즉, 네트워크 인터페이스부는 네트워크 망을 통해 서비스 제공자로부터 서비스, 컨 텐트 등을 수신한다. TCP/IP 매니저는, 디지털 기기로 수신되는 IP 패킷들과 디지털 기기가 전송하는 IP 패킷들에 대하여 즉, 소스(source)와 목적지(destination) 사이의 패킷 전달에 관여한다. 그리고 TCP/IP 매니저는 수신된 패킷(들)을 적절한 프로토콜에 대응되도록 분류하고, 서비스 전달 매니저, 서비스 디스커버리 매 니저, 서비스 제어 매니저, 메타데이터 매니저 등으로 분류된 패킷(들)을 출력한다. 서비스 전달 매니저는, 수신되는 서비스 데이터의 제어를 담당한다. 예를 들어, 서비스 전달 매니저는 실 시간 스트리밍(real-time streaming) 데이터를 제어하는 경우에는 RTP/RTCP를 사용할 수 있다. 상기 실시간 스 트리밍 데이터를 RTP를 사용하여 전송하는 경우, 서비스 전달 매니저는 상기 수신된 데이터 패킷을 RTP에 따라 파싱(parsing)하여 역다중화부에 전송하거나 서비스 매니저의 제어에 따라 SI & 메타데이터 데이터베이스에 저장한다. 그리고 서비스 전달 매니저는 RTCP를 이용하여 상기 네트워크 수신 정보 를 서비스를 제공하는 서버 측에 피드백(feedback) 한다. 역다중화부는, 수신된 패킷을 오디오, 비디오, SI(System Information) 데이터 등으로 역다중화하여 각각 오디오/비디오 디코더(1406/1407), SI 디코더(140 4)에 전송한다. SI 디코더는 예를 들어, PSI(Program Specific Information), PSIP(Program and System Information Protocol), DVB-SI(Digital Video Broadcasting-Service Information) 등의 서비스 정보를 디코딩한다. 또한, SI 디코더는, 디코딩된 서비스 정보들을 예를 들어, SI & 메타데이터 데이터베이스에 저장한 다. 이렇게 저장된 서비스 정보는 예를 들어, 사용자의 요청 등에 의해 해당 구성에 의해 독출되어 이용될 수 있다. 오디오/비디오 디코더(1406/1407)는, 역다중화부에서 역다중화된 각 오디오 데이터와 비디오 데이터를 디 코딩한다. 이렇게 디코딩된 오디오 데이터 및 비디오 데이터는 디스플레이부를 통하여 사용자에게 제공된 다. 애플리케이션 매니저는 예를 들어, UI 매니저와 서비스 매니저를 포함하여 구성될 수 있다. 애플리 케이션 매니저는, 디지털 기기의 전반적인 상태를 관리하고 사용자 인터페이스를 제공하며, 다른 매니저 를 관리할 수 있다. UI 매니저는, 사용자를 위한 GUI(Graphic User Interface)를 OSD(On Screen Display) 등을 이용하여 제 공하며, 사용자로부터 키 입력을 받아 상기 입력에 따른 기기 동작을 수행한다. 예를 들어, UI 매니저는 사용자로부터 채널 선택에 관한 키 입력을 받으면 상기 키 입력 신호를 서비스 매니저에 전송한다. 서비스 매니저는, 서비스 전달 매니저, 서비스 디스커버리 매니저, 서비스 제어 매니저 , 메타데이터 매니저 등 서비스와 연관된 매니저를 제어한다. 또한, 서비스 매니저는, 채널 맵(channel map)을 만들고 사용자 인터페이스 매니저로부터 수신한 키 입력에 따라 상기 채널 맵을 이용하여 채널을 선택하다. 그리고 상기 서비스 매니저는 SI 디코더 로부터 채널의 서비스 정보를 전송받아 선택된 채널의 오디오/비디오 PID(Packet Identifier)를 역다중화 부에 설정한다. 이렇게 설정되는 PID는 상술한 역다중화 과정에 이용된다. 따라서, 역다중화부는 상기 PID를 이용하여 오디오 데이터, 비디오 데이터 및 SI 데이터를 필터링(filtering) 한다. 서비스 디스커버리 매니저는, 서비스를 제공하는 서비스 제공자를 선택하는데 필요한 정보를 제공한다. 상기 서비스 매니저로부터 채널 선택에 관한 신호를 수신하면, 서비스 디스커버리 매니저는 상기 정보를 이용하여 서비스를 찾는다. 서비스 제어 매니저는, 서비스의 선택과 제어를 담당한다. 예를 들어, 서비스 제어 매니저는 사용 자가 기존의 방송 방식과 같은 생방송(live broadcasting) 서비스를 선택하는 경우 IGMP 또는 RTSP 등을 사용하고, VOD(Video on Demand)와 같은 서비스를 선택하는 경우에는 RTSP를 사용하여 서비스의 선택, 제어를 수행한 다. 상기 RTSP 프로토콜은 실시간 스트리밍에 대해 트릭 모드(trick mode)를 제공할 수 있다. 또한, 서비스 제 어 매니저는 IMS(IP Multimedia Subsystem), SIP(Session Initiation Protocol)를 이용하여 IMS 게이트웨 이를 통하는 세션을 초기화하고 관리할 수 있다. 상기 프로토콜들은 일 실시 예이며, 구현 예에 따라 다 른 프로토콜을 사용할 수도 있다. 메타데이터 매니저는, 서비스와 연관된 메타데이터를 관리하고 상기 메타데이터를 SI & 메타데이터 데이 터 베이스에 저장한다. SI & 메타데이터 데이터베이스는, SI 디코더가 디코딩한 서비스 정보, 메타데이터 매니저가 관리하는 메타데이터 및 서비스 디스커버리 매니저가 제공하는 서비스 제공자를 선택하는데 필요한 정보 를 저장한다. 또한, SI & 메타데이터 데이터베이스는 시스템에 대한 세트-업 데이터 등을 저장할 수 있다. SI & 메타데이터 데이터베이스는, 비휘발성 메모리(Non-Volatile RAM: NVRAM) 또는 플래시 메모리(flash memory) 등을 사용하여 구현될 수도 있다. 한편, IMS 게이트웨이는, IMS 기반의 IPTV 서비스에 접근하기 위해 필요한 기능들을 모아 놓은 게이트웨 이이다. 도 15는 디지털 기기의 다른 실시예를 설명하기 위해 도시한 구성 블록도이다. 특히, 도 15는 디지털 기기의 다 른 실시예로서 모바일 기기의 구성 블록도를 예시한 것이다. 도 15를 참조하면, 모바일 기기는, 무선 통신부, A/V(Audio/Video) 입력부, 사용자 입력부 , 센싱부, 출력부, 메모리, 인터페이스부, 제어부 및 전원 공급부 등을 포함할 수 있다. 도 15에 도시된 구성요소들이 필수적인 것은 아니어서, 그보다 많은 구성요소들을 갖거나 그보다 적은 구성요소들을 갖는 모바일 기기가 구현될 수도 있다. 무선 통신부는, 모바일 기기와 무선 통신 시스템 사이 또는 모바일 기기와, 모바일 기기가 위치한 네트워크 사이의 무선 통신을 가능하게 하는 하나 또는 그 이상의 모듈을 포함할 수 있다. 예를 들어, 무선 통 신부는 방송 수신 모듈, 이동통신 모듈, 무선 인터넷 모듈, 근거리 통신 모듈 및 위치 정보 모듈 등을 포함할 수 있다. 방송 수신 모듈은, 방송 채널을 통하여 외부의 방송 관리 서버로부터 방송 신호 및/또는 방송 관련된 정 보를 수신한다. 여기서, 방송 채널은 위성 채널, 지상파 채널을 포함할 수 있다. 상기 방송 관리 서버는, 방송 신호 및/또는 방송 관련 정보를 생성하여 송신하는 서버 또는 기 생성된 방송 신호 및/또는 방송 관련 정보를 제공받아 단말기에 송신하는 서버를 의미할 수 있다. 상기 방송 신호는, TV 방송 신호, 라디오 방송 신호, 데이 터 방송 신호를 포함할 뿐만 아니라, TV 방송 신호 또는 라디오 방송 신호에 데이터 방송 신호가 결합한 형태의 방송 신호도 포함할 수 있다. 방송 관련 정보는, 방송 채널, 방송 프로그램 또는 방송 서비스 제공자에 관련한 정보를 의미할 수 있다. 상기 방송 관련 정보는, 이동통신망을 통하여도 제공될 수 있다. 이러한 경우에는 상기 이동통신 모듈에 의해 수신될 수 있다. 방송 관련 정보는 다양한 형태 예를 들어, EPG(Electronic Program Guide) 또는 ESG(Electronic Service Guide) 등의 형태로 존재할 수 있다. 방송 수신 모듈은 예를 들어, ATSC, DVB-T(Digital Video Broadcasting-Terrestrial), DVB- S(Satellite), MediaFLO(Media Forward Link Only), DVB-H(Handheld), ISDB-T(Integrated Services Digital Broadcast-Terrestrial) 등 디지털 방송 시스템을 이용하여 디지털 방송 신호를 수신할 수 있다. 물론, 방송 수 신 모듈은, 상술한 디지털 방송 시스템뿐만 아니라 다른 방송 시스템에 적합하도록 구성될 수도 있다. 방송 수신 모듈을 통해 수신된 방송 신호 및/또는 방송 관련 정보는, 메모리에 저장될 수 있다. 이동통신 모듈은, 이동 통신망 상에서 기지국, 외부 단말, 서버 중 적어도 하나와 무선 신호를 송수신한 다. 무선 신호는, 음성 신호, 화상 통화 신호 또는 문자/멀티미디어 메시지 송수신에 따른 다양한 형태의 데이 터를 포함할 수 있다. 무선 인터넷 모듈은, 무선 인터넷 접속을 위한 모듈을 포함하여, 모바일 기기에 내장되거나 외장될 수 있다. 무선 인터넷 기술로는 WLAN(Wireless LAN)(Wi-Fi), Wibro(Wireless broadband), Wimax(World Interoperability for Microwave Access), HSDPA(High Speed Downlink Packet Access) 등이 이용될 수 있다. 근거리 통신 모듈은, 근거리 통신을 위한 모듈을 말한다. 근거리 통신(short range communication) 기술 로 블루투스(Bluetooth), RFID(Radio Frequency Identification), 적외선 통신(IrDA, infrared Data Association), UWB(Ultra Wideband), ZigBee, RS-232, RS-485 등이 이용될 수 있다. 위치정보 모듈은, 모바일 기기의 위치정보 획득을 위한 모듈로서, GPS(Global Position System) 모 듈을 예로 할 수 있다. A/V 입력부는, 오디오 또는/및 비디오 신호 입력을 위한 것으로, 이에는 카메라와 마이크 등 이 포함될 수 있다. 카메라는, 화상통화 모드 또는 촬영 모드에서 이미지 센서에 의해 얻어지는 정지영상 또는 동영상 등의 화상 프레임을 처리한다. 처리된 화상 프레임은 디스플레이부에 표시될 수 있다. 카메라에서 처리된 화상 프레임은, 메모리에 저장되거나 무선 통신부를 통하여 외부로 전송 될 수 있다. 카메라는, 사용 환경에 따라 2개 이상이 구비될 수도 있다. 마이크는, 통화 모드 또는 녹음 모드, 음성인식 모드 등에서 마이크로폰(Microphone)에 의해 외부의 음향 신호를 입력받아 전기적인 음성 데이터로 처리한다. 처리된 음성 데이터는, 통화 모드인 경우 이동통신 모듈 을 통하여 이동통신 기지국으로 송신 가능한 형태로 변환되어 출력될 수 있다. 마이크에는 외부의 음향 신호를 입력받는 과정에서 발생하는 잡음(noise)을 제거하기 위한 다양한 잡음 제거 알고리즘이 구현될 수 있다. 사용자 입력부는, 사용자가 단말기의 동작 제어를 위한 입력 데이터를 발생시킨다. 사용자 입력부 는, 키 패드(key pad), 돔 스위치 (dome switch), 터치 패드(정압/정전), 조그 휠(jog wheel), 조그 스위치 (jog switch) 등으로 구성될 수 있다. 센싱부는, 모바일 기기의 개폐 상태, 모바일 기기의 위치, 사용자 접촉 유무, 모바일 기기의 방위, 모바일 기기의 가속/감속 등과 같이 모바일 기기의 현재 상태를 감지하여 모바일 기기의 동작 제어를 위한 센싱 신호를 발생시킨다. 예를 들어, 모바일 기기가 이동되거나 기울어진 경우 모바일 기기 의 위치 내지 기울기 등을 센싱할 수 있다. 또한, 전원 공급부의 전원 공급 여부, 인터페이스부의 외부 기기 결합 여부 등도 센싱할 수도 있다. 한편, 센싱부는, NFC(Near Field Communication)를 포함한 근접 센서를 포함할 수 있다. 출력부는, 시각, 청각 또는 촉각 등과 관련된 출력을 발생시키기 위한 것으로, 디스플레이부, 음향 출력 모듈, 알람부, 및 햅틱 모듈 등이 포함될 수 있다. 디스플레이부는, 모바일 기기에서 처리되는 정보를 표시(출력)한다. 예를 들어, 모바일 기기가 통 화 모드인 경우 통화와 관련된 UI(User Interface) 또는 GUI(Graphic User Interface)를 표시한다. 모바일 기 기가 화상 통화 모드 또는 촬영 모드인 경우에는, 촬영 또는/및 수신된 영상 또는 UI, GUI를 표시한다. 디스플레이부는, 액정 디스플레이(liquid crystal display, LCD), 박막 트랜지스터 액정 디스플레이 (thin film transistor-liquid crystal display, TFT LCD), 유기 발광 다이오드(organic light-emitting diode, OLED), 플렉시블 디스플레이(flexible display), 3차원 디스플레이(3D display) 중에서 적어도 하나를 포함할 수 있다. 이들 중 일부 디스플레이는 그를 통해 외부를 볼 수 있도록 투명형 또는 광투과형으로 구성될 수 있다. 이는 투 명 디스플레이라 호칭될 수 있는데, 상기 투명 디스플레이의 대표적인 예로는 TOLED(Transparant OLED) 등이 있 다. 디스플레이부의 후방 구조 또한 광 투과형 구조로 구성될 수 있다. 이러한 구조에 의하여, 사용자는 단말기 바디의 디스플레이부가 차지하는 영역을 통해 단말기 바디(body)의 후방에 위치한 사물을 볼 수 있다. 모바일 기기의 구현 형태에 따라 디스플레이부가 2개 이상 존재할 수 있다. 예를 들어, 모바일 기 기에는 복수의 디스플레이부들이 하나의 면에 이격되거나 일체로 배치될 수 있고, 또한 서로 다른 면에 각각 배치될 수도 있다. 디스플레이부와 터치 동작을 감지하는 센서(이하 '터치 센서'라 함)가 상호 레이어 구조를 이루는 경우 (이하, '터치 스크린'이라 함)에, 디스플레이부는 출력 장치 이외에 입력 장치로도 사용될 수 있다. 터치센서는, 예를 들어, 터치 필름, 터치 시트, 터치 패드 등의 형태를 가질 수 있다. 터치 센서는 디스플레이부의 특정 부위에 가해진 압력 또는 디스플레이부의 특정 부위에 발생하는 정전 용량 등의 변화를 전기적인 입력신호로 변환하도록 구성될 수 있다. 터치 센서는 터치 되는 위치 및 면적 뿐만 아니라, 터치 시의 압력까지도 검출할 수 있도록 구성될 수 있다. 터치 센서에 대한 터치 입력이 있는 경우, 그에 대응하는 신호(들)는 터치 제어기로 보내진다. 터치 제어기는 그 신호(들)를 처리한 다음 대응하는 데이터를 제어부로 전송한다. 이로써, 제어부는 디스플레이부 의 어느 영역이 터치 되었는지 여부 등을 알 수 있게 된다. 터치스크린에 의해 감싸지는 모바일 기기의 내부 영역 또는 상기 터치 스크린의 근처에 근접 센서가 배치 될 수 있다. 상기 근접 센서는 소정의 검출면에 접근하는 물체, 혹은 근방에 존재하는 물체의 유무를 전자계의 힘 또는 적외선을 이용하여 기계적 접촉이 없이 검출하는 센서를 말한다. 근접 센서는 접촉식 센서보다는 그 수 명이 길며 그 활용도 또한 높다. 상기 근접 센서의 예로는 투과형 광전 센서, 직접 반사형 광전 센서, 미러 반사형 광전 센서, 고주파 발진형 근 접 센서, 정전용량형 근접 센서, 자기형 근접 센서, 적외선 근접 센서 등이 있다. 상기 터치스크린이 정전식인 경우에는 상기 포인터의 근접에 따른 전계의 변화로 상기 포인터의 근접을 검출하도록 구성된다. 이 경우 상기 터치 스크린(터치 센서)은 근접 센서로 분류될 수도 있다. 이하에서는 설명의 편의를 위해, 상기 터치스크린 상에 포인터가 접촉되지 않으면서 근접되어 상기 포인터가 상 기 터치스크린 상에 위치함이 인식되도록 하는 행위를 \"근접 터치(proximity touch)\"라고 칭하고, 상기 터치스 크린 상에 포인터가 실제로 접촉되는 행위를 \"접촉 터치(contact touch)\"라고 칭한다. 상기 터치스크린 상에서 포인터로 근접 터치가 되는 위치라 함은, 상기 포인터가 근접 터치될 때 상기 포인터가 상기 터치스크린에 대해 수직으로 대응되는 위치를 의미한다. 상기 근접 센서는, 근접 터치와, 근접 터치 패턴(예를 들어, 근접 터치 거리, 근접 터치 방향, 근접 터치 속도, 근접 터치 시간, 근접 터치 위치, 근접 터치 이동 상태 등)을 감지한다. 상기 감지된 근접 터치 동작 및 근접 터치 패턴에 상응하는 정보는 터치 스크린상에 출력될 수 있다. 음향 출력 모듈은, 호신호 수신, 통화 모드 또는 녹음 모드, 음성인식 모드, 방송수신 모드 등에서 무선 통신부로부터 수신되거나 메모리에 저장된 오디오 데이터를 출력할 수 있다. 음향 출력 모듈(155 2)은 모바일 기기에서 수행되는 기능(예를 들어, 호신호 수신음, 메시지 수신음 등)과 관련된 음향 신호 를 출력하기도 한다. 이러한 음향 출력 모듈에는 리시버(receiver), 스피커(speaker), 버저(buzzer) 등 이 포함될 수 있다. 알람부는, 모바일 기기의 이벤트 발생을 알리기 위한 신호를 출력한다. 모바일 기기에서 발생 되는 이벤트의 예로는 호 신호 수신, 메시지 수신, 키 신호 입력, 터치 입력 등이 있다. 알람부는, 비디오 신 호나 오디오 신호 이외에 다른 형태, 예를 들어 진동으로 이벤트 발생을 알리기 위한 신호를 출력할 수도 있다. 상기 비디오 신호나 오디오 신호는 디스플레이부나 음성 출력 모듈을 통해서도 출력될 수 있어서, 그들(1551,1552)은 알람부의 일부로 분류될 수도 있다. 햅틱 모듈(haptic module)은, 사용자가 느낄 수 있는 다양한 촉각 효과를 발생시킨다. 햅틱 모듈이 발생시키는 촉각 효과의 대표적인 예로는 진동이 있다. 햅택 모듈이 발생하는 진동의 세기와 패턴 등은 제어 가능하다. 예를 들어, 서로 다른 진동을 합성하여 출력하거나 순차적으로 출력할 수도 있다. 햅틱 모듈은, 진동 외에도, 접촉 피부면에 대해 수직 운동하는 핀 배열, 분사구나 흡입구를 통한 공기의 분사력이나 흡입력, 피부 표면에 대한 스침, 전극(electrode)의 접촉, 정전기력 등의 자극에 의한 효과와, 흡열 이나 발열 가능한 소자를 이용한 냉온감 재현에 의한 효과 등 다양한 촉각 효과를 발생시킬 수 있다. 햅틱 모듈은, 직접적인 접촉을 통해 촉각 효과의 전달할 수 있을 뿐만 아니라, 사용자가 손가락이나 팔 등의 근 감각을 통해 촉각 효과를 느낄 수 있도록 구현할 수도 있다. 햅틱 모듈은, 모바일 기기의 구성 태양에 따라 2개 이상이 구비될 수 있다. 메모리는, 제어부의 동작을 위한 프로그램을 저장할 수 있고, 입/출력되는 데이터들(예를 들어, 폰 북, 메시지, 정지영상, 동영상 등)을 임시 저장할 수도 있다. 상기 메모리는 상기 터치스크린 상의 터치 입력시 출력되는 다양한 패턴의 진동 및 음향에 관한 데이터를 저장할 수 있다.메모리는, 플래시 메모리 타입(flash memory type), 하드디스크 타입(hard disk type), 멀티미디어 카드 마이크로 타입(multimedia card micro type), 카드 타입의 메모리(예를 들어 SD 또는 XD 메모리 등), 램 (Random Access Memory, RAM), SRAM(Static Random Access Memory), 롬(Read-Only Memory, ROM), EEPROM(Electrically Erasable Programmable Read-Only Memory), PROM(Programmable Read-Only Memory), 자기 메모리, 자기 디스크, 광디스크 중 적어도 하나의 타입의 저장매체를 포함할 수 있다. 모바일 기기는 인 터넷(internet)상에서 상기 메모리의 저장 기능을 수행하는 웹 스토리지(web storage)와 관련되어 동작할 수도 있다. 인터페이스부는, 모바일 기기에 연결되는 모든 외부기기와의 통로 역할을 한다. 인터페이스부 는 외부 기기로부터 데이터를 전송받거나, 전원을 공급받아 모바일 기기 내부의 각 구성 요소에 전 달하거나, 모바일 기기 내부의 데이터가 외부 기기로 전송되도록 한다. 예를 들어, 유/무선 헤드셋 포트, 외부 충전기 포트, 유/무선 데이터 포트, 메모리 카드(memory card) 포트, 식별 모듈이 구비된 장치를 연결하는 포트, 오디오 I/O(Input/Output) 포트, 비디오 I/O 포트, 이어폰 포트 등이 인터페이스부에 포함될 수 있 다. 식별 모듈은 모바일 기기의 사용 권한을 인증하기 위한 각종 정보를 저장한 칩으로서, 사용자 인증 모듈 (User Identify Module, UIM), 가입자 인증 모듈(Subscriber Identify Module, SIM), 범용 사용자 인증 모듈 (Universal Subscriber Identity Module, USIM) 등을 포함할 수 있다. 식별 모듈이 구비된 장치(이하 '식별 장 치')는, 스마트 카드(smart card) 형식으로 제작될 수 있다. 따라서 식별 장치는 포트를 통하여 단말기와 연결될 수 있다. 인터페이스부는, 이동단말기가 외부 크래들(cradle)과 연결될 때, 상기 크래들로부터의 전원이 상 기 이동단말기에 공급되는 통로가 되거나, 사용자에 의해 상기 크래들에서 입력되는 각종 명령 신호가 상 기 이동단말기로 전달되는 통로가 될 수 있다. 크래들로부터 입력되는 각종 명령 신호 또는 상기 전원은, 이동 단말기가 상기 크래들에 정확히 장착되었음을 인지하기 위한 신호로 동작될 수도 있다. 제어부는, 통상적으로 모바일 기기의 전반적인 동작을 제어한다. 예를 들어, 음성 통화, 데이터 통신, 화 상 통화 등을 위한 관련된 제어 및 처리를 수행한다. 제어부는, 멀티 미디어 재생을 위한 멀티미디어 모듈 을 구비할 수도 있다. 멀티미디어 모듈은, 제어부 내에 구현될 수도 있고, 제어부와 별도로 구현될 수도 있다. 제어부, 특히 멀티미디어 모듈은 전술한 인코딩 장치 및/또는 디코딩 장 치를 포함할 수 있다. 제어부는, 터치스크린 상에서 행해지는 필기 입력 또는 그림 그리기 입력을 각각 문자 및 이미지로 인식 할 수 있는 패턴 인식 처리를 행할 수 있다. 전원 공급부는, 제어부의 제어에 의해 외부의 전원, 내부의 전원을 인가받아 각 구성요소들의 동작 에 필요한 전원을 공급한다. 여기에 설명되는 다양한 실시예는 예를 들어, 소프트웨어, 하드웨어 또는 이들의 조합된 것을 이용하여 컴퓨터 또는 이와 유사한 장치로 읽을 수 있는 기록매체 내에서 구현될 수 있다. 하드웨어적인 구현에 의하면, 여기에 설명되는 실시예는 ASICs(application specific integrated circuits), DSPs(digital signal processors), DSPDs(digital signal processing devices), PLDs(programmable logic devices), FPGAs(field programmable gate arrays, 프로세서, 제어기, 마이크로 컨트롤러(micro-controllers), 마이크로 프로세서(microprocessors), 기타 기능 수행을 위한 전기적인 유닛 중 적어도 하나를 이용하여 구현될 수 있다. 일부의 경우에 본 명세서에서 설명되는 실시예들이 제어부 자체로 구현될 수 있다. 소프트웨어적인 구현에 의하면, 본 명세서에서 설명되는 절차 및 기능과 같은 실시예들은 별도의 소프트웨어 모 듈들로 구현될 수 있다. 소프트웨어 모듈들 각각은 본 명세서에서 설명되는 하나 이상의 기능 및 작동을 수행할 수 있다. 적절한 프로그램 언어로 쓰여진 소프트웨어 애플리케이션으로 소프트웨어 코드가 구현될 수 있다. 여 기서, 소프트웨어 코드는, 메모리에 저장되고, 제어부에 의해 실행될 수 있다. 도 16은 디지털 기기의 또 다른 실시 예를 설명하기 위해 도시한 구성 블록도이다. 디지털 기기의 다른 예는, 방송 수신부, 외부장치 인터페이스부, 저장부, 사용자 입력 인터페이스부, 제어부, 디스플레이부, 오디오 출력부, 전원공급부 및 촬영부(미 도시)를 포함할 수 있다. 여기서, 상기 방송 수신부는, 적어도 하나의 튜너, 복조부 및 네트워크 인터페이스부를 포함할 수 있다. 다만, 경우에 따라, 상기 방송 수신부는 튜너와 복조 부는 구비하나 네트워크 인터페이스부는 포함하지 않을 수 있으며 그 반대의 경우일 수도 있다. 또 한, 상기 방송 수신부는 도시되진 않았으나, 다중화부(multiplexer)를 구비하여 상기 튜너를 거쳐 복조부에서 복조된 신호와 상기 네트워크 인터페이스부를 거쳐 수신된 신호를 다중화할 수도 있다. 그 밖에 상기 방송 수신부는 역시 도시되진 않았으나, 역다중화부(demultiplexer)를 구비하여 상기 다중 화된 신호를 역다중화 하거나 상기 복조된 신호 또는 상기 네트워크 인터페이스부를 거친 신호를 역다중 화할 수 있다. 튜너는, 안테나를 통해 수신되는 RF(Radio Frequency) 방송 신호 중 사용자에 의해 선택된 채널 또는 기 저장된 모든 채널을 튜닝하여 RF 방송 신호를 수신한다. 또한, 튜너는, 수신된 RF 방송 신호를 중간 주파 수(Intermediate Frequency; IF) 신호 혹은 베이스밴드(baseband) 신호로 변환한다. 예를 들어, 수신된 RF 방송 신호가 디지털 방송 신호이면 디지털 IF 신호(DIF)로 변환하고, 아날로그 방송 신호 이면 아날로그 베이스밴드 영상 또는 음성 신호(CVBS/SIF)로 변환한다. 즉, 튜너는 디지털 방송 신호 또 는 아날로그 방송 신호를 모두 처리할 수 있다. 튜너에서 출력되는 아날로그 베이스 밴드 영상 또는 음성 신호(CVBS/SIF)는 제어부로 직접 입력될 수 있다. 또한, 튜너는, ATSC(Advanced Television System Committee) 방식에 따른 단일 캐리어의 RF 방송 신호 또는 DVB(Digital Video Broadcasting) 방식에 따른 복수 캐리어의 RF 방송 신호를 수신할 수 있다. 한편, 튜너는, 안테나를 통해 수신되는 RF 방송 신호 중 채널 기억 기능을 통하여 저장된 모든 방송 채널 의 RF 방송 신호를 순차로 튜닝 및 수신하여 이를 중간 주파수 신호 혹은 베이스 밴드 신호로 변환할 수 있다. 복조부는, 튜너에서 변환된 디지털 IF 신호(DIF)를 수신하여 복조한다. 예를 들어, 튜너에서 출력되는 디지털 IF 신호가 ATSC 방식인 경우, 복조부는 예컨대, 8-VSB(8-Vestigal Side Band) 복조를 수행한다. 또한, 복조부는 채널 복호화를 수행할 수도 있다. 이를 위해 복조부는 트렐리스 디코더 (Trellis Decoder), 디인터리버(De-interleaver), 및 리드 솔로먼 디코더(Reed-Solomon Decoder) 등을 구비하 여, 트렐리스 복호화, 디인터리빙, 및 리드 솔로먼 복호화를 수행할 수 있다. 예를 들어, 튜너에서 출력되는 디지털 IF 신호가 DVB 방식인 경우, 복조부는 예컨대, COFDMA(Coded Orthogonal Frequency Division Modulation) 복조를 수행한다. 또한, 복조부는, 채널 복호화를 수행할 수도 있다. 이를 위해, 복조부는, 컨벌루션 디코더(convolution decoder), 디인터리버, 및 리드-솔로먼 디코더 등을 구비하여, 컨벌루션 복호화, 디인터리빙, 및 리드 솔로먼 복호화를 수행할 수 있다. 복조부는, 복조 및 채널 복호화를 수행한 후 스트림 신호(TS)를 출력할 수 있다. 이때, 스트림 신호는 영 상 신호, 음성 신호 또는 데이터 신호가 다중화된 신호일 수 있다. 일 예로, 스트림 신호는 MPEG-2 규격의 영상 신호, 돌비(Dolby) AC-3 규격의 음성 신호 등이 다중화된 MPEG-2 TS(Transport Stream)일 수 있다. 구체적으로 MPEG-2 TS는, 4 바이트(byte)의 헤더(header)와 184 바이트의 페이로드(payload)를 포함할 수 있다. 한편, 상술한 복조부는, ATSC 방식과, DVB 방식에 따라 각각 별개로 구비되는 것이 가능하다. 즉, 디지털 기기는 ATSC 복조부와 DVB 복조부를 각각 별개로 구비할 수 있다. 복조부에서 출력한 스트림 신호는 제어부로 입력될 수 있다. 제어부는 역다중화, 영상/음성 신호 처리 등을 제어하고, 디스플레이부를 통해 영상을, 오디오 출력부를 통해 음성의 출력을 제어 할 수 있다. 외부장치 인터페이스부는 디지털 기기에 다양한 외부장치가 인터페이싱 되도록 환경을 제공한다. 이를 위해, 외부장치 인터페이스부는, A/V 입출력부(미도시) 또는 무선 통신부(미도시)를 포함할 수 있다. 외부장치 인터페이스부는, DVD(Digital Versatile Disk), 블루-레이(Blu-ray), 게임기기, 카메라, 캠코 더, 컴퓨터(노트북, 태블릿), 스마트폰, 블루투스 기기(Bluetooth device), 클라우드(Cloud) 등과 같은 외부 장 치와 유/무선으로 접속될 수 있다. 외부장치 인터페이스부는 연결된 외부 장치를 통하여 외부에서 입력되 는 영상, 음성 또는 데이터(이미지 포함) 신호를 디지털 기기의 제어부로 전달한다. 제어부는 처리 된 영상, 음성 또는 데이터 신호를 연결된 외부 장치로 출력되도록 제어할 수 있다. 이를 위해, 외부장치 인터 페이스부는, A/V 입출력부(미도시) 또는 무선 통신부(미도시)를 더 포함할 수 있다. A/V 입출력부는, 외부 장치의 영상 및 음성 신호를 디지털 기기로 입력할 수 있도록, USB 단자, CVBS(Composite Video Banking Sync) 단자, 컴포넌트 단자, S-비디오 단자(아날로그), DVI(Digital Visual Interface) 단자, HDMI(High Definition Multimedia Interface) 단자, RGB 단자, D-SUB 단자 등을 포함할 수 있다. 무선 통신부는, 다른 전자기기와 근거리 무선 통신을 수행할 수 있다. 디지털 기기는 예를 들어, 블루투 스(Bluetooth), RFID(Radio Frequency Identification), 적외선 통신(IrDA, infrared Data Association), UWB(Ultra Wideband), 지그비(ZigBee), DLNA(Digital Living Network Alliance) 등의 통신 프로토콜에 따라 다 른 전자기기와 네트워크 연결될 수 있다. 또한, 외부장치 인터페이스부는, 다양한 셋톱-박스와 상술한 각종 단자 중 적어도 하나를 통해 접속되어, 셋톱-박스와 입력/출력 동작을 수행할 수도 있다. 한편, 외부장치 인터페이스부는, 인접하는 외부장치 내의 애플리케이션 또는 애플리케이션 목록을 수신하 여, 제어부 또는 저장부로 전달할 수 있다. 네트워크 인터페이스부는, 디지털 기기를 인터넷 망을 포함하는 유/무선 네트워크와 연결하기 위한 인터페이스를 제공한다. 네트워크 인터페이스부는, 유선 네트워크와의 접속을 위해 예를 들어, 이더넷 (Ethernet) 단자 등을 구비할 수 있으며, 무선 네트워크와의 접속을 위해 예를 들어, WLAN(Wireless LAN)(Wi- Fi), Wibro(Wireless broadband), Wimax(World Interoperability for Microwave Access), HSDPA(High Speed Downlink Packet Access) 통신 규격 등을 이용할 수 있다. 네트워크 인터페이스부는, 접속된 네트워크 또는 접속된 네트워크에 링크된 다른 네트워크를 통해, 다른 사용자 또는 다른 디지털 기기와 데이터를 송신 또는 수신할 수 있다. 특히, 디지털 기기에 미리 등록된 다른 사용자 또는 다른 디지털 기기 중 선택된 사용자 또는 선택된 디지털 기기에, 디지털 기기에 저장된 일부의 컨텐트 데이터를 송신할 수 있다. 한편, 네트워크 인터페이스부는, 접속된 네트워크 또는 접속된 네트워크에 링크된 다른 네트워크를 통해, 소정 웹 페이지에 접속할 수 있다. 즉, 네트워크를 통해 소정 웹 페이지에 접속하여, 해당 서버와 데이터를 송 신 또는 수신할 수 있다. 그 외, 컨텐트 제공자 또는 네트워크 운영자가 제공하는 컨텐트 또는 데이터들을 수신 할 수 있다. 즉, 네트워크를 통하여 컨텐트 제공자 또는 네트워크 제공자로부터 제공되는 영화, 광고, 게임, VOD, 방송 신호 등의 컨텐트 및 그와 관련된 정보를 수신할 수 있다. 또한, 네트워크 운영자가 제공하는 펌웨어 (firmware)의 업데이트 정보 및 업데이트 파일을 수신할 수 있다. 또한, 인터넷 또는 컨텐트 제공자 또는 네트 워크 운영자에게 데이터들을 송신할 수 있다. 또한, 네트워크 인터페이스부는, 네트워크를 통해, 공중에 공개(open)된 애플리케이션들 중 원하는 애플 리케이션을 선택하여 수신할 수 있다. 저장부는, 제어부 내의 각 신호 처리 및 제어를 위한 프로그램을 저장할 수도 있고, 신호 처리된 영상, 음성 또는 데이터 신호를 저장할 수도 있다. 또한, 저장부는 외부장치 인터페이스부 또는 네트워크 인터페이스부로부터 입력되는 영상, 음성, 또는 데이터 신호의 임시 저장을 위한 기능을 수행할 수도 있다. 저장부는, 채널 기억 기능을 통하 여 소정 방송 채널에 관한 정보를 저장할 수 있다. 저장부는, 외부장치 인터페이스부 또는 네트워크 인터페이스부로부터 입력되는 애플리케이션 또는 애플리케이션 목록을 저장할 수 있다. 또한, 저장부는, 후술하여 설명하는 다양한 플랫폼(platform)을 저장할 수도 있다. 저장부는, 예를 들어 플래시 메모리 타입(flash memory type), 하드디스크 타입(hard disk type), 멀티 미디어 카드 마이크로 타입(multimedia card micro type), 카드 타입의 메모리(예를 들어 SD 또는 XD 메모리 등), 램(RAM), 롬(EEPROM 등) 중 적어도 하나의 타입의 저장매체를 포함할 수 있다. 디지털 기기는, 저장 부 내에 저장되어 있는 컨텐트 파일(동영상 파일, 정지영상 파일, 음악 파일, 문서 파일, 애플리케이션 파일 등)을 재생하여 사용자에게 제공할 수 있다. 도 16은 저장부가 제어부와 별도로 구비된 실시 예를 도시하고 있으나, 본 문서의 실시예의 범위는 이에 한정되지 않는다. 즉, 저장부는 제어부 내에 포함될 수도 있다. 사용자 입력 인터페이스부는, 사용자가 입력한 신호를 제어부로 전달하거나, 제어부의 신호 를 사용자에게 전달한다. 예를 들어, 사용자 입력 인터페이스부는, RF 통신 방식, 적외선(IR) 통신 방식 등 다양한 통신 방식에 따 라, 원격제어장치로부터 전원 온/오프, 채널 선택, 화면 설정 등의 제어 신호를 수신하여 처리하거나, 제 어부의 제어 신호를 원격제어장치로 송신하도록 처리할 수 있다. 또한, 사용자 입력 인터페이스부는, 전원 키, 채널 키, 볼륨 키, 설정치 등의 로컬 키(미도시)에서 입력 되는 제어 신호를 제어부에 전달할 수 있다. 사용자 입력 인터페이스부는, 사용자의 제스처(gesture)를 센싱(sensing)하는 센싱부(미도시)로부터 입력 되는 제어 신호를 제어부에 전달하거나, 제어부의 신호를 센싱부(미도시)로 송신할 수 있다. 여기 서, 센싱부(미도시)는, 터치 센서, 음성 센서, 위치 센서, 동작 센서 등을 포함할 수 있다. 제어부는, 튜너, 복조부 또는 외부장치 인터페이스부를 통하여 입력되는 스트림을 역 다중화하거나 역다중화된 신호들을 처리하여, 영상 또는 음성 출력을 위한 신호를 생성 및 출력할 수 있다. 제 어부는 전술한 인코딩 장치 및/또는 디코딩 장치를 포함할 수 있다. 제어부에서 처리된 영상 신호는, 디스플레이부로 입력되어 해당 영상 신호에 대응하는 영상으로 표 시될 수 있다. 또한, 제어부에서 영상 처리된 영상 신호는 외부장치 인터페이스부를 통하여 외부 출력 장치로 입력될 수 있다. 제어부에서 처리된 음성 신호는 오디오 출력부로 오디오 출력될 수 있다. 또한, 제어부에서 처리된 음성 신호는 외부장치 인터페이스부를 통하여 외부 출력장치로 입력될 수 있다. 도 16에서는 도시되어 있지 않으나, 제어부는 역다중화부, 영상처리부 등을 포함할 수 있다. 제어부는, 디지털 기기의 전반적인 동작을 제어할 수 있다. 예를 들어, 제어부는, 튜너 를 제어하여, 사용자가 선택한 채널 또는 기저장된 채널에 해당하는 RF 방송을 튜닝(tuning)하도록 제어 할 수 있다. 제어부는, 사용자 입력 인터페이스부를 통하여 입력된 사용자 명령 또는 내부 프로그램에 의하여 디지털 기기를 제어할 수 있다. 특히, 네트워크에 접속하여 사용자가 원하는 애플리케이션 또는 애플리케 이션 목록을 디지털 기기 내로 다운로드 받을 수 있도록 할 수 있다. 예를 들어, 제어부는, 사용자 입력 인터페이스부를 통하여 수신한 소정 채널 선택 명령에 따라 선 택한 채널의 신호가 입력되도록 튜너를 제어한다. 그리고 선택한 채널의 영상, 음성 또는 데이터 신호를 처리한다. 제어부는, 사용자가 선택한 채널 정보 등이 처리한 영상 또는 음성신호와 함께 디스플레이부 또는 오디오 출력부를 통하여 출력될 수 있도록 한다. 다른 예로, 제어부는, 사용자 입력 인터페이스부를 통하여 수신한 외부장치 영상 재생 명령에 따라, 외부장치 인터페이스부를 통하여 입력되는 외부 장치, 예를 들어, 카메라 또는 캠코더로부터의, 영 상 신호 또는 음성 신호가 디스플레이부 또는 오디오 출력부를 통해 출력될 수 있도록 한다. 한편, 제어부는, 영상을 표시하도록 디스플레이부를 제어할 수 있다. 예를 들어, 튜너를 통 해 입력되는 방송 영상, 또는 외부장치 인터페이스부를 통해 입력되는 외부 입력 영상, 또는 네트워크 인 터페이스부를 통해 입력되는 영상, 또는 저장부에 저장된 영상을, 디스플레이부에 표시하도록 제어 할 수 있다. 이때, 디스플레이부에 표시되는 영상은, 정지 영상 또는 동영상일 수 있으며, 2D 영상 또는 3D 영상일 수 있다. 또한, 제어부는, 컨텐트를 재생하도록 제어할 수 있다. 이때의 컨텐트는, 디지털 기기 내에 저장된 컨텐트, 또는 수신된 방송 컨텐트, 외부로부터 입력되는 외부 입력 컨텐트일 수 있다. 컨텐트는, 방송 영상, 외 부 입력 영상, 오디오 파일, 정지 영상, 접속된 웹 화면, 및 문서 파일 중 적어도 하나일 수 있다. 한편, 제어부는, 애플리케이션 보기 항목에 진입하는 경우, 디지털 기기 내 또는 외부 네트워크로 부터 다운로드 가능한 애플리케이션 또는 애플리케이션 목록을 표시하도록 제어할 수 있다. 제어부는, 다양한 사용자 인터페이스와 더불어, 외부 네트워크로부터 다운로드 되는 애플리케이션을 설치 및 구동하도록 제어할 수 있다. 또한, 사용자의 선택에 의해, 실행되는 애플리케이션에 관련된 영상이 디스플레 이부에 표시 되도록 제어할 수 있다.한편, 도면에 도시하지 않았지만, 채널 신호 또는 외부 입력 신호에 대응하는 썸네일 이미지를 생성하는 채널 브라우징 처리부가 더 구비되는 것도 가능하다. 채널 브라우징 처리부는, 복조부에서 출력한 스트림 신호(TS) 또는 외부장치 인터페이스부에서 출 력한 스트림 신호 등을 입력받아, 입력되는 스트림 신호로부터 영상을 추출하여 썸네일 영상을 생성할 수 있다. 생성된 썸네일 영상은 그대로 또는 부호화되어 제어부로 입력될 수 있다. 또한, 생성된 썸네일 영상은 스 트림 형태로 부호화되어 제어부로 입력되는 것도 가능하다. 제어부는 입력된 썸네일 영상을 이용하 여 복수의 썸네일 영상을 구비하는 썸네일 리스트를 디스플레이부에 표시할 수 있다. 한편, 이러한 썸네 일 리스트 내의 썸네일 영상들은 차례로 또는 동시에 업데이트 될 수 있다. 이에 따라 사용자는 복수의 방송 채 널의 내용을 간편하게 파악할 수 있게 된다. 디스플레이부는, 제어부에서 처리된 영상 신호, 데이터 신호, OSD 신호 또는 외부장치 인터페이스 부에서 수신되는 영상 신호, 데이터 신호 등을 각각 R, G, B 신호로 변환하여 구동 신호를 생성한다. 디스플레이부는 PDP, LCD, OLED, 플렉시블 디스플레이(flexible display), 3차원 디스플레이(3D display) 등이 가능할 수 있다. 한편, 디스플레이부는, 터치 스크린으로 구성되어 출력 장치 이외에 입력 장치로 사용되는 것도 가능하다. 오디오 출력부는, 제어부에서 음성 처리된 신호, 예를 들어, 스테레오 신호, 3.1 채널 신호 또는 5.1 채널 신호를 입력받아 음성으로 출력한다. 음성 출력부는 다양한 형태의 스피커로 구현될 수 있다. 한편, 사용자의 제스처를 감지하기 위해, 상술한 바와 같이, 터치 센서, 음성 센서, 위치 센서, 동작 센서 중 적어도 하나를 구비하는 센싱부(미도시)가 디지털 기기에 더 구비될 수 있다. 센싱부(미도시)에서 감지된 신호는 사용자입력 인터페이스부를 통해 제어부로 전달될 수 있다. 한편, 사용자를 촬영하는 촬영부(미도시)가 더 구비될 수 있다. 촬영부(미도시)에서 촬영된 영상 정보는 제어부 에 입력될 수 있다. 제어부는, 촬영부(미도시)로부터 촬영된 영상, 또는 센싱부(미도시)로부터의 감지된 신호를 각각 또는 조 합하여 사용자의 제스처를 감지할 수도 있다. 전원 공급부는, 디지털 기기 전반에 걸쳐 해당 전원을 공급한다. 특히, 시스템 온 칩(System On Chip; SOC)의 형태로 구현될 수 있는 제어부와, 영상 표시를 위한 디스플 레이부, 및 오디오 출력을 위한 오디오 출력부에 전원을 공급할 수 있다. 이를 위해, 전원 공급부는, 교류 전원을 직류 전원으로 변환하는 컨버터(미도시)를 구비할 수 있다. 한편, 예를 들어, 디스플레이부가 다수의 백라이트 램프를 구비하는 액정패널로서 구현되는 경우, 휘도 가변 또는 디밍(dimming) 구동을 위해, PWM 동작 가능한 인버터(미도시)를 더 구비할 수도 있다. 원격제어장치는, 사용자 입력을 사용자입력 인터페이스부로 송신한다. 이를 위해, 원격제어장치 는, 블루투스(Bluetooth), RF(Radio Frequency) 통신, 적외선(IR) 통신, UWB(Ultra Wideband), 지그비 (ZigBee) 방식 등을 사용할 수 있다. 또한, 원격제어장치는, 사용자입력 인터페이스부에서 출력한 영상, 음성 또는 데이터 신호 등을 수 신하여, 이를 원격제어장치에서 표시하거나 음성 또는 진동을 출력할 수 있다. 상술한 디지털 기기는, 고정형 또는 이동형의 ATSC 방식 또는 DVB 방식의 디지털 방송 신호의 처리가 가 능한 디지털 방송 수신기일 수 있다. 그 밖에 본 문서의 실시예에 따른 디지털 기기는 도시된 구성 중 필요에 따라 일부 구성을 생략하거나 반대로 도시되진 않은 구성을 더 포함할 수도 있다. 한편, 디지털 기기는 상술한 바와 달리, 튜너와 복조부를 구비하지 않고, 네트워크 인터페이스부 또는 외부장치 인터페이스부를 통해서 컨텐트를 수신하여 재생할 수도 있다. 도 17은 도 14 내지 도 16의 제어부의 상세 구성의 일 실시예를 설명하기 위해 도시한 구성 블록도이다. 제어부의 일 예는, 역다중화부, 영상 처리부, OSD(On-Screen Display) 생성부, 믹서 (mixer), 프레임 레이트 변환부(Frame Rate Conveter; FRC), 및 포맷터(formatter)를 포함 할 수 있다. 그 외 상기 제어부는 도시되진 않았으나 음성 처리부와 데이터 처리부를 더 포함할 수 있다.역다중화부는, 입력되는 스트림을 역다중화한다. 예를 들어, 역다중화부는 입력되는 MPEG-2 TS 영 상, 음성 및 데이터 신호로 역다중화할 수 있다. 여기서, 역다중화부에 입력되는 스트림 신호는, 튜너 또 는 복조부 또는 외부장치 인터페이스부에서 출력되는 스트림 신호일 수 있다. 영상 처리부는, 역다중화된 영상 신호의 영상 처리를 수행한다. 이를 위해, 영상 처리부는, 영상 디코더 및 스케일러를 구비할 수 있다. 영상 디코더는 역다중화된 영상 신호를 복호하며, 스케일러는 복호된 영상 신호의 해상도를 디스플 레이부에서 출력 가능하도록 스케일링(scaling)한다. 영상 디코더는 다양한 규격을 지원할 수 있다. 예를 들어, 영상 디코더는 영상 신호가 MPEG-2 규격 으로 부호화된 경우에는 MPEG-2 디코더의 기능을 수행하고, 영상 신호가 DMB(Digital Multimedia Broadcasting) 방식, H.26x(ex. H.265, H.266, H.267 등), 또는 EVC 등 규격으로 부호화된 경우에는 해당 디코 더의 기능을 수행할 수 있다. 한편, 영상 처리부에서 복호된 영상 신호는, 믹서로 입력된다. OSD 생성부는, 사용자 입력에 따라 또는 자체적으로 OSD 데이터를 생성한다. 예를 들어, OSD 생성부 는 사용자입력 인터페이스부의 제어 신호에 기초하여 디스플레이부의 화면에 각종 데이터를 그래픽 (Graphic)이나 텍스트(Text) 형태로 표시하기 위한 데이터를 생성한다. 생성되는 OSD 데이터는, 디지털 기기의 사용자 인터페이스 화면, 다양한 메뉴 화면, 위젯(widget), 아이콘(Icon), 시청률 정보(viewing rate information) 등의 다양한 데이터를 포함한다. OSD 생성부는, 방송 영상의 자막 또는 EPG에 기반한 방송 정보를 표시하기 위한 데이터를 생성할 수도 있 다. 믹서는, OSD 생성부에서 생성된 OSD 데이터와 영상 처리부에서 영상 처리된 영상 신호를 믹싱하여 포맷터로 제공한다. 복호된 영상 신호와 OSD 데이터가 믹싱됨으로 인하여, 방송 영상 또는 외부 입력 영 상 상에 OSD가 오버레이(overlay) 되어 표시된다. 프레임 레이트 변환부(FRC)는, 입력되는 영상의 프레임 레이트(frame rate)를 변환한다. 예를 들어, 프레 임 레이트 변환부는 입력되는 60Hz 영상의 프레임 레이트를 디스플레이부의 출력 주파수에 따라 예를 들 어, 120Hz 또는 240Hz의 프레임 레이트를 가지도록 변환할 수 있다. 상기와 같이, 프레임 레이트를 변환하는 방 법에는 다양한 방법이 존재할 수 있다. 일 예로, 프레임 레이트 변환부는 프레임 레이트를 60Hz에서 120Hz로 변환하는 경우, 제1 프레임과 제2 프레임 사이에 동일한 제1 프레임을 삽입하거나, 제1 프레임과 제2 프레임으로부터 예측된 제3 프레임을 삽입함으로써 변환할 수 있다. 다른 예로, 프레임 레이트 변환부는 프레임 레이트를 60Hz에서 240Hz로 변환하는 경우, 기존 프레임 사이에 동일한 프레임 또는 예측된 프레임을 3 개 더 삽입하여 변환할 수 있다. 한편, 별도의 프레임 변환을 수행하지 않는 경우에는 프레임 레이트 변환부 를 바이패스(bypass) 할 수도 있다. 포맷터는, 입력되는 프레임 레이트 변환부의 출력을 디스플레이부의 출력 포맷에 맞게 변경한다. 예를 들어, 포맷터는 R, G, B 데이터 신호를 출력할 수 있으며, 이러한 R, G, B 데이터 신호는, 낮은 전 압 차분 신호(Low voltage differential signaling, LVDS) 또는 mini-LVDS로 출력될 수 있다. 또한, 포맷터 는 입력되는 프레임 레이트 변환부의 출력이 3D 영상 신호인 경우에는 디스플레이부의 출력 포맷에 맞게 3D 형태로 구성하여 출력함으로써, 상기 디스플레이부를 통해 3D 서비스를 지원할 수도 있다. 한편, 제어부 내 음성 처리부(미도시)는, 역다중화된 음성 신호의 음성 처리를 수행할 수 있다. 이러한 음성 처 리부(미도시)는 다양한 오디오 포맷을 처리하도록 지원할 수 있다. 일 예로, 음성 신호가 MPEG-2, MPEG-4, AAC, HE-AAC, AC-3, BSAC, EVS 등의 포맷으로 부호화된 경우에도 이에 대응되는 디코더를 구비하여 처리할 수 있다. 또한, 제어부 내 음성 처리부(미도시)는, 베이스(Base), 트레블(Treble), 음량 조절 등을 처리할 수 있다. 제어부 내 데이터 처리부(미도시)는, 역다중화된 데이터 신호의 데이터 처리를 수행할 수 있다. 예를 들어, 데 이터 처리부는 역다중화된 데이터 신호가 부호화된 경우에도 이를 복호할 수 있다. 여기서, 부호화된 데이터 신 호로는, 각 채널에서 방영되는 방송 프로그램의 시작시각, 종료시각 등의 방송 정보가 포함된 EPG 정보일 수 있 다. 한편, 상술한 디지털 기기는 본 문서의 실시예에 따른 예시로서, 각 구성요소는 실제 구현되는 디지털 기기의 사양에 따라 통합, 추가, 또는 생략될 수 있다. 즉, 필요에 따라, 2 이상의 구성요소가 하나의 구성요소로 합쳐 지거나 하나의 구성요소가 2 이상의 구성요소로 세분화될 수 있다. 또한, 각 블록에서 수행하는 기능은 본 문서 의 실시예를 설명하기 위한 것이며, 그 구체적인 동작이나 장치는 본 문서의 실시예의 권리범위를 제한하지 아 니한다. 한편, 디지털 기기는, 장치 내에 저장된 영상 또는 입력되는 영상의 신호 처리를 수행하는 영상신호 처리장치일 수 있다. 영상신호 처리장치의 다른 예로는, 도 16에서 도시된 디스플레이부와 오디오 출력부가 제 외된 셋톱-박스(STB), 상술한 DVD 플레이어, 블루-레이 플레이어, 게임기기, 컴퓨터 등이 더 예시될 수 있다. 도 18은 일 실시예에 따른 디지털 기기의 스크린이 메인 영상(main image)과 보조 영상(sub image)을 동시에 디 스플레이 하는 일 예시를 도시하는 도면이다. 일 실시예에 따른 디지털 기기는 스크린에 메인 영상과 보조 영상을 동시에 디스플레이 할 수 있다. 메인 영상은 제1 영상이라 불릴 수 있고, 보조 영상은 제2 영상이라 불릴 수 있다. 메인 영상과 보조 영상은 동영상, 스틸 이미지, EPG(Electronic Program Guide), GUI(Graphical User Interface), OSD(On-Screen Display) 등을 포함할 수 있고, 이에 한정되지 않는다. 메인 영상은 전자 장 치의 스크린에 보조 영상과 동시에 디스플레이 되면서 전자 장치의 스크린 보다 크기가 상대 적으로 작은 영상을 의미할 수 있으며, PIP(Picture In Picture)로 지칭되기도 한다. 도 18에서는 메인 영상 이 디지털 기기의 스크린의 좌측 상단에 디스플레이 되는 것으로 도시되어 있으나, 메인 영상 이 디스플레이 되는 위치는 이에 한정되지 않고, 메인 영상은 디지털 기기의 스크린 내의 임 의의 위치에서 디스플레이 될 수 있다. 메인 영상과 보조 영상은 상호 직접 또는 간접적으로 관련될 수 있다. 일 예시로, 메인 영상(181 0)은 스트리밍(streaming) 동영상이고, 보조 영상은 스트리밍 동영상과 유사한 정보를 포함하는 동영상들 의 썸네일(thumbnail)들을 순차로 디스플레이 하는 GUI일 수 있다. 다른 예시로, 메인 영상은 방송 영상 (broadcasted image)이고, 보조 영상은 EPG일 수 있다. 또 다른 예시로, 메인 영상은 방송 영상이 고, 보조 영상은 GUI일 수 있다. 메인 영상과 보조 영상의 예시는 이에 한정되지 않는다. 일 실시예에서, 메인 영상은 방송 채널(broadcasting channel)을 통해 수신한 방송 영상(broadcasting image)이고, 보조 영상은 방송 채널을 통해 수신한 방송 영상과 관련된 정보일 수 있다. 방송 채널을 통 해 수신한 방송 영상과 관련된 정보는, 예를 들어 종합 채널 편성표, 방송 프로그램 상세 정보 등을 포함하는 EPG 정보, 방송 프로그램 다시 보기 정보 등을 포함할 수 있으며, 이에 한정되지 않는다. 다른 일 실시예에서, 메인 영상은 방송 채널을 통해 수신한 방송 영상이고, 보조 영상은 디지털 기 기에 기저장된 정보에 기초하여 생성된 영상일 수 있다. 디지털 기기에 기 저장된 정보에 기초하여 생성된 영상 은, 예를 들어 EPG의 기본 UI(User Interface), 기본 채널 정보, 영상 해상도(resolution) 조작 UI, 취침 예약 UI 등을 포함할 수 있으며, 이에 한정되지 않는다. 또 다른 일 실시예에서, 메인 영상은 방송 채널을 통해 수신한 방송 영상이고, 보조 영상은 네트워 크 망을 통해 수신한, 방송 영상과 관련된 정보일 수 있다. 네트워크망을 통해 수신한, 방송 영상과 관련된 정 보는, 예를 들어 네트워크에 기반한 검색 엔진을 통해 획득된 정보일 수 있다. 보다 구체적으로 예를 들면, 네 트워크에 기반한 검색 엔진을 통해 현재 메인 영상에 디스플레이 되고 있는 등장 인물과 관련된 정보가 획득될 수 있다. 그러나 예시는 이에 한정되지 않으며, 네트워크망을 통해 수신한, 방송 영상과 관련된 정보는 예를 들어 인공지 능(Artificial Intelligence, AI) 시스템을 사용함으로써 획득될 수 있다. 보다 구체적으로 예를 들면, 네트워 크에 기반한 딥러닝(deep-learning)을 이용하여 현재 메인 영상에 디스플레이 되고 있는 장소의 지도상 추정 위치(estimated-location in map)가 획득될 수 있고, 디지털 기기는 네트워크 망을 통하여, 현재 메인 영 상에 디스플레이 되고 있는 장소의 지도상 추정 위치에 관한 정보를 수신할 수 있다. 일 실시예에 따른 디지털 기기는 외부로부터 메인 영상의 영상 정보 및 보조 영상의 영상 정보 중 적어도 하나를 수신할 수 있다. 메인 영상의 영상 정보는 예를 들어 방송 채널(broadcasting channel)을 통해 수신한 방송 신호(broadcasting signal), 메인 영상의 소스 코드(source code) 정보, 네트워크 망 을 통해 수신한 메인 영상의 IP 패킷(Internet Protocol packet) 정보 등을 포함할 수 있으며, 이에 한 정되지 않는다. 마찬가지로, 보조 영상의 영상 정보는, 예를 들어 방송 채널을 통해 수신한 방송 신호, 보조 영상의 소스 코드 정보, 네트워크 망을 통해 수신한 보조 영상의 IP 패킷 정보 등을 포함할수 있으며, 이에 한정되지 않는다. 디지털 기기는 외부로부터 수신된 메인 영상의 영상 정보 또는 보조 영상의 영상 정보를 디코딩하여 이용할 수 있다. 다만, 경우에 따라서 디지털 기기는 메인 영상의 영상 정보 또는 보조 영상의 영상 정보를 내부에 자체적으로 저장하고 있을 수도 있다. 디지털 기기는 메인 영상의 영상 정보 및 보조 영상과 관련된 정보에 기초하여, 메인 영상과 보조 영상을 디지털 기기의 스크린에 디스플레이 할 수 있다. 일 예시에서, 디지털 기기의 디코딩 장치는 메인 영상 디코딩 장치와 보조 영상 디코딩 장치를 포함하고, 메인 영상 디코딩 장치와 보조 영상 디코딩 장치는 각각 메인 영상의 영상 정보와 보조 영상의 영 상 정보를 디코딩 할 수 있다. 렌더러는 메인 영상 렌더러(제1 렌더러)와 보조 영상 렌더러(제2 렌더러)를 포함 하고, 메인 영상 렌더러는 메인 영상 디코딩 장치에서 디코딩 된 정보에 기초하여 메인 영상을 디지털 기 기의 스크린의 제1 영역에 디스플레이되도록 할 수 있고, 보조 영상 렌더러는 보조 영상 디코딩 장치에서 디코딩 된 정보에 기초하여 보조 영상을 디지털 기기의 스크린의 제2 영역에 디스플레이되도록 할 수 있다. 또 다른 예시에서, 디지털 기기의 디코딩 장치는 메인 영상의 영상 정보와 보조 영상의 영상 정보를 디코딩 할 수 있다. 디코딩 장치에서 디코딩된 정보에 기초하여, 렌더러는 메인 영상 및 보 조 영상을 함께 처리하여 동시에 디지털 기기의 스크린에 디스플레이되도록 할 수 있다. 즉, 본 문서에 따르면, 디지털 기기에서 영상 서비스 처리 방법을 제공할 수 있다. 상기 영상 서비스 처리 방법 에 따르면, 영상 정보를 수신하는 단계, 상기 영상 정보를 기반으로 (메인) 영상을 디코딩하는 단계, 상기 디코 딩된 영상을 디스플레이 내 제1 영역에 렌더링 또는 디스플레이하는 단계, 상기 디스플레이 내 제2 영역에 보조 영상을 렌더링 또는 디스플레이하는 단계를 포함할 수 있다. 이 경우 상기 제1 영상을 디코딩하는 단계는, 상술 한 도 3에 따른 디코딩 장치에서의 디코딩 절차를 따를 수 있다. 예를 들어, 상술한 바와 같이, 상기 제1 영상을 디코딩하는 단계는 인터 또는 인트라 예측을 기반으로 현재 블록에 대한 예측 샘플들을 도출하는 단계, 수신된 레지듀얼 정보를 기반으로 현재 블록에 대한 레지듀얼 샘플들을 도출하는 단계(생략 가능) 및 상기 예측 샘플들 및/또는 상기 레지듀얼 샘플들을 기반으로 복원 샘플들을 생성하는 단계를 포함할 수 있다. 추가적으로 상기 제1 영상을 디코딩하는 단계는 복원 샘플들을 포함하는 복원 픽처에 인루프 필터링 절차를 수행하는 것을 포함할 수도 있다. 예를 들어, 상기 보조 영상은 EPG(electronic program guide), OSD(on screen display), 또는 GUI (graphic user interface)일 수 있다. 예를 들어, 상기 영상 정보는 방송망(broadcast network)를 통하여 수신되고, 상 기 보조 영상에 관한 정보는 상기 방송망을 통하여 수신될 수 있다. 예를 들어, 상기 영상 정보는 통신망 (communication network)를 통하여 수신되고, 상기 보조 영상에 관한 정보는 상기 통신망을 통하여 수신될 수 있다. 예를 들어, 상기 영상 정보는 방송망을 통하여 수신되고, 상기 보조 영상에 관한 정보는 통신망을 통하여 수신될 수 있다. 예를 들어, 상기 영상 정보는 방송망 또는 통신망을 통하여 수신되고, 상기 보조 영상에 관한 정보는 상기 디지털 기기 내의 저장매체에 저장되어 있을 수 있다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12 도면13 도면14 도면15 도면16 도면17 도면18"}
{"patent_id": "10-2025-7005290", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 문서의 실시예들에 적용될 수 있는 비디오/영상 코딩 시스템의 예를 개략적으로 나타낸다. 도 2는 본 문서의 실시예들에 적용될 수 있는 비디오/영상 인코딩 장치의 구성을 개략적으로 설명하는 도면이다. 도 3은 본 문서의 실시예들에 적용될 수 있는 비디오/영상 디코딩 장치의 구성을 개략적으로 설명하는 도면이다. 도 4는 true 쌍예측에서 DMVR(Decoder-side Motion Vector Refinement)을 수행하는 과정의 일 실시예를 설명하 기 위한 도면이다. 도 5는 SAD(sum of absolute differences)를 사용하여 DMVR(Decoder-side Motion Vector Refinement)을 수행하 는 과정의 일 실시예를 설명하기 위한 도면이다. 도 6은 DMVR 및 BDOF의 적용 조건을 체크하여 디코딩 과정을 수행하는 방법을 나타내는 일 예이다. 도 7 및 도 8은 DMVR 및 BDOF의 적용 조건을 체크하여 디코딩 과정을 수행하는 방법을 나타내는 다른 예이다. 도 9는 BDOF의 개념을 설명하기 위해 도시된 도면이다. 도 10은 본 문서의 일 실시예에 따른 인코딩 장치에 의하여 수행될 수 있는 인코딩 방법을 개략적으로 나타내는 흐름도이다. 도 11은 본 문서의 일 실시예에 따라 디코딩 장치에 의하여 수행될 수 있는 디코딩 방법을 개략적으로 나타내는 흐름도이다. 도 12는 본 문서에서 개시된 실시예들이 적용될 수 있는 컨텐츠 스트리밍 시스템의 예를 나타낸다. 도 13은 디지털 기기를 포함한 서비스 시스템(service system)의 일 예를 개략적으로 나타낸 도면이다. 도 14는 디지털 기기의 일 실시예를 설명하기 위해 도시한 구성 블록도이다. 도 15는 디지털 기기의 다른 실시예를 설명하기 위해 도시한 구성 블록도이다.도 16은 디지털 기기의 또 다른 실시 예를 설명하기 위해 도시한 구성 블록도이다. 도 17은 도 14 내지 도 16의 제어부의 상세 구성의 일 실시예를 설명하기 위해 도시한 구성 블록도이다. 도 18은 일 실시예에 따른 디지털 기기의 스크린이 메인 영상(main image)과 보조 영상(sub image)을 동시에 디 스플레이 하는 일 예시를 도시하는 도면이다."}
