{"patent_id": "10-2024-7041816", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0004387", "출원번호": "10-2024-7041816", "발명의 명칭": "컨테이너 기반의 차량 시스템에서 심리스 컨테이너 업데이트", "출원인": "엘지전자 주식회사", "발명자": "이철희"}}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컨테이너를 실행하는 단계;상기 컨테이너의 업데이트가 필요한 것으로 판단한 경우, 업데이트 대상의 컨테이너 이미지를 클라우드 서버로부터 수신하는 단계;상기 컨테이너에서 생성한 사용자 데이터 커밋(user data commit)과 상기 업데이트 대상의 컨테이너 이미지를결합하여 신규 컨테이너를 생성하는 단계; 및상기 업데이트 대상의 컨테이너를 상기 신규 컨테이너로 스위칭하여 상기 컨테이너를 업데이트하는 단계를 포함하는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 사용자 데이터 커밋은, 상기 컨테이너의 실행 중 런타임 대체(Runtime replace)를 위해 유지되어야 할 데이터로, 파일(File), 디렉토리(directory) 또는 텍스트(text) 중 적어도 하나의 형태로 생성되어 사용자 데이터레지스트리에 저장되는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,상기 차량에 신규 디바이스가 추가된 경우, 상기 차량에서 기존 디바이스가 제거된 경우, 상기 차량에 장착된디바이스에 대해 특정 버전의 펌웨어(Firmware) 또는 특정 버전의 애플리케이션을 요청하는 것을 감지한 경우,클라우드 환경에 연계된 상기 차량에 장착된 디바이스에 대하여 업데이트된 펌웨어(Firmware) 또는 업데이트된애플리케이션이 추가된 경우 또는 상기 클라우드 환경에 연계된 상기 차량에 적어도 둘 이상의 디바이스를 이용하는 신규 기능의 애플리케이션이 추가된 경우 중 적어도 하나를 인식한 경우, 상기 컨테이너의 업데이트가 필요한 것으로 판단하는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 컨테이너를 실행하는 중 컨테이너 업데이트 조건을 만족하는 미리 정해진 이벤트를 감지하는 단계;상기 클라우드 서버로 컨테이너 업데이트 리스트를 요청하는 단계; 및상기 컨테이너 업데이트 리스트를 분석하여 상기 컨테이너의 업데이트 필요 여부를 판단하는 단계를 더 포함하는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4 항에 있어서,제1 컨테이너를 실행하는 중 상기 컨테이너의 업데이트 필요여부 판단 결과, 컨테이너의 교체가 필요한 것으로판단한 경우,상기 컨테이너가 사용하는 데이터의 타입을 상기 클라우드 서버로 전송하는 단계;상기 클라우드 서버로부터 대체 가능한 제2 컨테이너를 수신하는 단계; 및차량 데이터의 접근 경로를 상기 제1 컨테이너에서 상기 제2 컨테이너로 스위칭되도록 제어하는 단계를 더 포함하는 컨테이너 업데이트 방법.공개특허 10-2025-0004387-3-청구항 6 제 5 항에 있어서,상기 제2 컨테이너가 상기 제1 컨테이너가 사용한 데이터를 요청한 경우, 상기 제1 컨테이너는 상기 요청에 응답하여 상기 사용자 데이터 커밋을 생성하는 단계를 더 포함하는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서,상기 컨테이너에 업데이트 준비를 요청하는 단계;상기 컨테이너를 통해 사용자 데이터 커밋을 생성하는 단계; 및상기 생성된 사용자 데이터 커밋을 사용자 데이터 레지스트리에 저장하는 단계를 더 포함하는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1 항에 있어서,상기 컨테이너의 실행을 제어하는 러닝 프로세스(Running Process)를 상기 신규 컨테이너와 연동시키는 단계;및상기 신규 컨테이너에 포함된 사용자 데이터 커밋을 통해 런타임 데이터 동기화를 맞추고 상기 신규 컨테이너로부터 상기 러닝 프로세스를 실행시는 단계를 더 포함하는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 8 항에 있어서,상기 러닝 프로세서의 연동이 완료되면, 상기 신규 컨테이너의 소스 주소를 상기 컨테이너 네임에 매칭되도록상기 컨테이너 관리 테이블을 업데이트하는 단계를 더 포함하는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 9 항에 있어서,상기 컨테이너 관리 테이블을 업데이트 하는 단계는,상기 신규 컨테이너 네임 및 상기 신규 컨테이너 네임에 매칭된 소스 주소를 삭제하는 단계를 더 포함하는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 9 항에 있어서,상기 컨테이너가 업데이트 되기 전의 컨테이너를 삭제하는 단계; 및상기 사용자 데이터 레지스트리에 저장된 상기 사용자 데이터 커밋을 삭제하는 단계를 더 포함하는 컨테이너 업데이트 방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 1 항에 있어서,상기 업데이트 대상의 컨테이너 이미지를 시스템 레지스트리에 저장하는 단계를 더 포함하는 컨테이너 업데이트방법."}
{"patent_id": "10-2024-7041816", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "차량 내에서 실행 가능한 애플리케이션의 실행을 제어하는 컨테이너를 저장하는 컨테이너 저장부;공개특허 10-2025-0004387-4-컨테이너 실행 과정에서 생성된 사용자 데이터를 저장하는 사용자 데이터 레지스트리; 및상기 컨테이너의 업데이트를 제어하는 프로세서를 포함하고,상기 프로세서는,상기 컨테이너를 구동시키고, 상기 컨테이너의 업데이트가 필요한 것으로 판단한 경우, 업데이트 대상의 컨테이너 이미지를 서버로부터 수신하고,상기 컨테이너에서 생성한 사용자 데이터 커밋(user data commit)과 상기 업데이트 대상의 컨테이너 이미지를결합하여 신규 컨테이너를 생성하고, 상기 업데이트 대상의 컨테이너를 상기 신규 컨테이너로 스위칭하여 상기 컨테이너를 업데이트하는 차량시스템."}
{"patent_id": "10-2024-7041816", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법 및 차량 시스템이 개시된다. 본 명세서의 일 실시예에 의하면, 컨테이너를 실행하는 중 업데이트가 필요한 것으로 판단한 경우, 컨테이너 실행 중 생성된 사용자 데이 터를 사용자 데이터 레지스트리에 저장하고, 클라우드 서버로부터 업데이트 대상의 컨테이너 이미지를 수신하여 시스템 레지스트리에 저장한다. 그런 후 사용자 데이터와 업데이트 대상 컨테이너 이미지를 결합하여 신규 컨테 이너를 생성한다. 또한, 관리 테이블의 매칭 관계를 변경함으로써, 기존 컨테이터에서 신규 컨테이너로 심리스한 업데이트가 가능하다."}
{"patent_id": "10-2024-7041816", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 명세서는 컨테이너 기반의 차량 시스템에서 심리스 컨테이너 업데이트 방법 및 장치에 관한 것이다."}
{"patent_id": "10-2024-7041816", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "자율주행자동차(Autonomous Vehicle)란 운전자 또는 승객의 조작 없이 자동차 스스로 운행이 가능한 자동차를 말하며, 자율주행시스템(Automated Vehicle & Highway Systems)은 이러한 자율주행자동차가 스스로 운행될 수 있도록 모니터링하고 제어하는 시스템을 말한다. 자율 주행 차량은 주행 중 사용자에게 여러 편의성을 제공하기 위한 편의 시스템이 제공되고 있다. 나아가 차량 은 클라우드 환경과 연계되어 차량 내에서 다양한 디바이스를 통해 서비스가 제공되고 있다. 차량과 연계되는 이와 같은 디바이스의 실행을 제어하기 위해서는 다양한 플랫폼들이 개발되고 있다. 특히, 차량 내에서 사용자가 특정 디바이스를 통해 특정 애플리케이션을 실행하는 중, 애플리케이션의 업데이트 가 필요한 상황이 발생할 수 있다. 이 경우, 종래의 프로세스 기반의 시스템에서는 업데이트시, 제공중이던 서 비스를 종료한 후에 업데이트를 진행할 수 밖에 없다. 또한, 프로세스 방식을 통해 특정 프로세스에 한하여 시 작 지점에 대하여 기존 구성을 유지할 수는 있지만, 시스템 관점에서 업데이트의 한계점이 존재한다. 또한, 웹 기반의 서비스의 경우, 백엔드에서의 업데이트 방식을 통해 신규 서비스를 제공하고 사용자 화면 전환 시점에 맞추어 GUI 등을 업데이트하지만, 사용자의 화면 전환이 발생되지 않는 경우, 실시간 업데이트에 문제가 있다."}
{"patent_id": "10-2024-7041816", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 명세서는 전술한 필요성 및/또는 문제점을 해결하는 것을 목적으로 한다. 또한, 본 명세서의 일 실시예에 의하면, 컨테이너 실행 과정에서 누적되는 사용자 데이터를 사용자 데이터 레지 스트리에 저장함으로써, 업데이트되는 컨테이너의 실행 과정에서 사용자 데이터를 심리스하게 이용할 수 있는 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법을 제공하는 것을 목적으로 한다. 또한, 본 명세서의 일 실시예에 의하면, 연동된 컨테이너들 간의 인터페이스를 컨테이너 관리 테이블을 이용하 여 조절함으로써, 사용자가 특정 애플리케이션을 사용하는 중에 컨테이너들을 유기적으로 조절함으로써, 심리스 한 컨테이너 업데이트가 가능한 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법을 제공하는 것을 목 적으로 한다."}
{"patent_id": "10-2024-7041816", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 명세서의 일 양상에 따른 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법은 컨테이너를 실행하는 단계; 상기 컨테이너의 업데이트가 필요한 것으로 판단한 경우, 업데이트 대상의 컨테이너 이미지를 클라우드 서버로부터 수신하는 단계; 상기 업데이트 대상의 컨테이너 이미지를 시스템 레지스트리에 저장하는 단계; 상기컨테이너에서 생성한 사용자 데이터 커밋(user data commit)과 상기 업데이트 대상의 컨테이너 이미지를 결합하 여 신규 컨테이너를 생성하는 단계; 및 컨테이너 네임과 소스의 위치를 매핑한 컨테이너 관리 테이블을 이용하 여 상기 컨테이너를 업데이트하는 단계;를 포함한다. 상기 사용자 데이터 커밋은, 상기 컨테이너의 실행 중 런타임 대체(Runtime replace)를 위해 유지되어야 할 데 이터일 수 있다. 상기 사용자 데이터 커밋은, 파일(File), 디렉토리(directory) 또는 텍스트(text) 중 적어도 하나의 형태로 생 성될 수 있다. 상기 사용자 데이터 커밋은, 사용자 데이터 레지스트리에 저장될 수 있다. 상기 차량에 신규 디바이스가 추가된 경우, 상기 차량에서 기존 디바이스가 제거된 경우, 상기 차량에 장착된 디바이스에 대해 특정 버전의 펌웨어(Firmware) 또는 특정 버전의 애플리케이션을 요청하는 것을 감지한 경우, 클라우드 환경에 연계된 상기 차량에 장착된 디바이스에 대하여 업데이트된 펌웨어(Firmware) 또는 업데이트된 애플리케이션이 추가된 경우 또는 상기 클라우드 환경에 연계된 상기 차량에 적어도 둘 이상의 디바이스를 이용 하는 신규 기능의 애플리케이션이 추가된 경우 중 적어도 하나를 인식한 경우, 상기 컨테이너의 업데이트가 필 요한 것으로 판단할 수 있다. 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법은 상기 컨테이너를 실행하는 중 컨테이너 업데이트 조건을 만족하는 미리 정해진 이벤트를 감지하는 단계; 상기 클라우드 서버로 컨테이너 업데이트 리스트를 요청 하는 단계; 및 상기 컨테이너 업데이트 리스트를 분석하여 상기 컨테이너의 업데이트 필요 여부를 판단하는 단 계;를 더 포함할 수 있다. 제1 컨테이너를 실행하는 중 상기 컨테이너의 업데이트 필요여부 판단 결과, 컨테이너의 교체가 필요한 것으로 판단한 경우, 상기 컨테이너가 사용하는 데이터의 타입을 상기 클라우드 서버로 전송하는 단계; 상기 클라우드 서버로부터 대체 가능한 제2 컨테이너를 수신하는 단계; 및 차량 데이터의 접근 경로를 상기 제1 컨테이너에서 상기 제2 컨테이너로 스위칭되도록 제어하는 단계;를 더 포함할 수 있다. 상기 제2 컨테이너가 상기 제1 컨테이너가 사용한 데이터를 요청한 경우, 상기 제1 컨테이너는 상기 요청에 응 답하여 상기 사용자 데이터 커밋을 생성하는 단계;를 더 포함할 수 있다. 상기 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법은 상기 컨테이너에 업데이트 준비를 요청하는 단계; 상기 컨테이너를 통해 사용자 데이터 커밋을 생성하는 단계; 및 상기 생성된 사용자 데이터 커밋을 사용 자 데이터 레지스트리에 저장하는 단계;를 더 포함할 수 있다. 상기 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법은 상기 컨테이너의 실행을 제어하는 러닝 프로 세스(Running Process)를 상기 신규 컨테이너와 연동시키는 단계; 및 상기 신규 컨테이너에 포함된 사용자 데이 터 커밋을 통해 런타임 데이터 동기화를 맞추고 상기 신규 컨테이너로부터 상기 러닝 프로세스를 실행시는 단계;를 더 포함할 수 있다. 상기 러닝 프로세서의 연동이 완료되면, 상기 신규 컨테이너의 소스 주소를 상기 컨테이너 네임에 매칭되도록 상기 컨테이너 관리 테이블을 업데이트하는 단계;를 더 포함할 수 있다. 상기 컨테이너 관리 테이블을 업데이트 하는 단계는, 상기 신규 컨테이너 네임 및 상기 신규 컨테이너 네임에 매칭된 소스 주소를 삭제하는 단계;를 더 포함할 수 있다. 상기 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법은 상기 컨테이너가 업데이트 되기 전의 컨테이 너를 삭제하는 단계; 및 상기 사용자 데이터 레지스트리에 저장된 상기 사용자 데이터 커밋을 삭제하는 단계; 를 더 포함할 수 있다. 본 명세서의 다른 양상에 따른 차량 시스템은, 차량 내에서 실행 가능한 애플리케이션의 실행을 제어하기 위한 적어도 하나의 프로그램, 데이터 및 시스템 라이브러리를 포함하는 컨테이너를 저장하는 컨테이너 저장부; 시스 템 컨테이너 이미지를 저장하는 시스템 레지스트리; 컨테이너 실행 과정에서 생성된 사용자 데이터를 저장하는 사용자 데이터 레지스트리; 및 상기 컨테이너 저장부, 시스템 레지스트리, 사용자 데이터 레지스트리와 기능적 으로 연결되고 컨테이너의 업데이트를 제어하는 프로세서;를 포함하고, 상기 프로세서는, 상기 컨테이너를 구동 시키고, 상기 컨테이너의 업데이트가 필요한 것으로 판단한 경우, 업데이트 대상의 컨테이너 이미지를 클라우드 서버로부터 수신하고, 상기 업데이트 대상의 컨테이너 이미지를 상기 시스템 레지스트리에 저장하고, 상기 컨테이너에서 생성한 사용자 데이터 커밋(user data commit)과 상기 업데이트 대상의 컨테이너 이미지를 결합하여 신규 컨테이너를 생성하고, 컨테이너 네임과 소스의 위치를 매핑한 컨테이너 관리 테이블을 이용하여 상기 컨테 이너를 업데이트한다. 상기 사용자 데이터 커밋은, 상기 컨테이너의 실행 중 런타임 대체(Runtime replace)를 위해 유지되어야 할 데 이터이다. 상기 사용자 데이터 커밋은, 파일(File), 디렉토리(directory) 또는 텍스트(text) 중 적어도 하나의 형태로 생 성될 수 있다. 상기 프로세서는, 상기 컨테이너를 실행하는 중 컨테이너 업데이트 조건을 만족하는 미리 정해진 이벤트를 감지 하고, 상기 클라우드 서버로 컨테이너 업데이트 리스트를 요청하고, 상기 컨테이너 업데이트 리스트를 분석하여 상기 컨테이너의 업데이트 필요 여부를 판단할 수 있다. 상기 프로세서는, 상기 컨테이너에 업데이트 준비를 요청하고, 상기 컨테이너를 통해 사용자 데이터 커밋을 생 성하고, 상기 생성된 사용자 데이터 커밋을 사용자 데이터 레지스트리에 저장할 수 있다. 상기 프로세서는, 상기 컨테이너의 실행을 제어하는 러닝 프로세스(Running Process)를 상기 신규 컨테이너와 연동시키고, 상기 신규 컨테이너에 포함된 사용자 데이터 커밋을 통해 런타임 데이터 동기화를 맞추고 상기 신 규 컨테이너로부터 상기 러닝 프로세스를 실행시킬 수 있다. 상기 프로세서는, 상기 러닝 프로세서의 연동이 완료되면, 상기 신규 컨테이너의 소스 주소를 상기 컨테이너 네 임에 매칭되도록 상기 컨테이너 관리 테이블을 업데이트할 수 있다."}
{"patent_id": "10-2024-7041816", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 명세서의 일 실시예에 의하면, 컨테이너 실행 과정에서 누적되는 사용자 데이터를 사용자 데이터 레지스트리 에 저장함으로써, 업데이트되는 컨테이너의 실행 과정에서 사용자 데이터를 심리스하게 이용할 수 있다. 또한, 본 명세서의 일 실시예에 의하면, 연동된 컨테이너들 간의 인터페이스를 컨테이너 관리 테이블을 이용하 여 조절함으로써, 사용자가 특정 애플리케이션을 사용하는 중에 컨테이너들을 유기적으로 조절함으로써, 심리스 한 컨테이너 업데이트가 가능하다."}
{"patent_id": "10-2024-7041816", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 첨부된 도면을 참조하여 본 명세서에 개시된 실시예를 상세히 설명하되, 도면 부호에 관계없이 동일하거 나 유사한 구성요소는 동일한 참조 번호를 부여하고 이에 대한 중복되는 설명은 생략하기로 한다. 이하의 설명 에서 사용되는 구성요소에 대한 접미사 \"모듈\" 및 \"부\"는 명세서 작성의 용이함만이 고려되어 부여되거나 혼용 되는 것으로서, 그 자체로 서로 구별되는 의미 또는 역할을 갖는 것은 아니다. 또한, 본 명세서에 개시된 실시 예를 설명함에 있어서 관련된 공지 기술에 대한 구체적인 설명이 본 명세서에 개시된 실시예의 요지를 흐릴 수 있다고 판단되는 경우 그 상세한 설명을 생략한다. 또한, 첨부된 도면은 본 명세서에 개시된 실시예를 쉽게 이 해할 수 있도록 하기 위한 것일 뿐, 첨부된 도면에 의해 본 명세서에 개시된 기술적 사상이 제한되지 않으며, 본 명세서의 사상 및 기술 범위에 포함되는 모든 변경, 균등물 내지 대체물을 포함하는 것으로 이해되어야 한다. 제1, 제2 등과 같이 서수를 포함하는 용어는 다양한 구성요소들을 설명하는데 사용될 수 있지만, 상기 구성요소 들은 상기 용어들에 의해 한정되지는 않는다. 상기 용어들은 하나의 구성요소를 다른 구성요소로부터 구별하는 목적으로만 사용된다. 어떤 구성요소가 다른 구성요소에 \"연결되어\" 있다거나 \"접속되어\" 있다고 언급된 때에는, 그 다른 구성요소에 직접적으로 연결되어 있거나 또는 접속되어 있을 수도 있지만, 중간에 다른 구성요소가 존재할 수도 있다고 이 해되어야 할 것이다. 반면에, 어떤 구성요소가 다른 구성요소에 \"직접 연결되어\" 있다거나 \"직접 접속되어\" 있 다고 언급된 때에는, 중간에 다른 구성요소가 존재하지 않는 것으로 이해되어야 할 것이다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 출원에서, \"포함한다\" 또는 \"가지다\" 등의 용어는 명세서상에 기재된 특징, 숫자, 단계, 동작, 구성요소, 부 품 또는 이들을 조합한 것이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되 어야 한다. 1. 주행 차량 외관 도 1은 본 명세서의 실시예에 따른 차량을 도시한 도면이다. 도 1을 참조하면, 본 명세서의 실시예에 따른 차량은, 도로나 선로 위를 주행하는 수송 수단으로 정의된다. 차량은, 자동차, 기차, 오토바이를 포함하는 개념이다. 차량은, 동력원으로서 엔진을 구비하는 내연기 관 차량, 동력원으로서 엔진과 전기 모터를 구비하는 하이브리드 차량, 동력원으로서 전기 모터를 구비하는 전 기 차량등을 모두 포함하는 개념일 수 있다. 차량은 개인이 소유한 차량일 수 있다. 차량은, 공유형 차 량일 수 있다. 차량은 자율 주행 차량일 수 있다. 차량의 구성 요소 도 2는 본 명세서의 실시예에 따른 차량의 제어 블럭도이다. 도 2를 참조하면, 차량은, 사용자 인터페이스 장치, 오브젝트 검출 장치, 통신 장치, 운전 조작 장치, 메인 ECU, 구동 제어 장치, 자율 주행 장치, 센싱부 및 위치 데이터 생성 장치를 포함할 수 있다. 오브젝트 검출 장치, 통신 장치, 운전 조작 장치, 메인 ECU, 구동 제어 장치, 자율 주행 장치, 센싱부 및 위치 데이터 생성 장치는 각각이 전기적 신호를 생성하고, 상호간에 전기적 신호를 교환하는 전자 장치로 구현될 수 있다. 1) 사용자 인터페이스 장치 사용자 인터페이스 장치는, 차량과 사용자와의 소통을 위한 장치이다. 사용자 인터페이스 장치는, 사용자 입력을 수신하고, 사용자에게 차량에서 생성된 정보를 제공할 수 있다. 차량은, 사용자 인터페이스 장치를 통해, UI(User Interface) 또는 UX(User Experience)를 구현할 수 있다. 사용 자 인터페이스 장치는, 입력 장치, 출력 장치 및 사용자 모니터링 장치를 포함할 수 있다. 2) 오브젝트 검출 장치 오브젝트 검출 장치는, 차량 외부의 오브젝트에 대한 정보를 생성할 수 있다. 오브젝트에 대한 정보는, 오브젝트의 존재 유무에 대한 정보, 오브젝트의 위치 정보, 차량과 오브젝트와의 거리 정보 및 차 량과 오브젝트와의 상대 속도 정보 중 적어도 어느 하나를 포함할 수 있다. 오브젝트 검출 장치는, 차 량 외부의 오브젝트를 검출할 수 있다. 오브젝트 검출 장치는, 차량 외부의 오브젝트를 검출할 수 있는 적어도 하나의 센서를 포함할 수 있다. 오브젝트 검출 장치는, 카메라, 레이다, 라이다, 초음파 센서 및 적외선 센서 중 적어도 하나를 포함할 수 있다. 오브젝트 검출 장치는, 센서에서 생성되는 센싱 신호에 기초하여 생성된 오브젝트에 대한 데이터를 차량에 포함된 적어도 하나의 전자 장치에 제공할 수 있다. 2.1) 카메라 카메라는 영상을 이용하여 차량 외부의 오브젝트에 대한 정보를 생성할 수 있다. 카메라는 적어도 하나의 렌즈, 적어도 하나의 이미지 센서 및 이미지 센서와 전기적으로 연결되어 수신되는 신호를 처리하고, 처리되는 신호에 기초하여 오브젝트에 대한 데이터를 생성하는 적어도 하나의 프로세서를 포함할 수 있다. 카메라는, 모노 카메라, 스테레오 카메라, AVM(Around View Monitoring) 카메라 중 적어도 어느 하나일 수 있다. 카메라는, 다양한 영상 처리 알고리즘을 이용하여, 오브젝트의 위치 정보, 오브젝트와의 거리 정보 또는 오브젝트와의 상대 속도 정보를 획득할 수 있다. 예를 들면, 카메라는, 획득된 영상에서, 시간에 따른 오브젝트 크기의 변화를 기초로, 오브젝트와의 거리 정보 및 상대 속도 정보를 획득할 수 있다. 예를 들면, 카메라는, 핀 홀(pin hole) 모델, 노면 프로파일링 등을 통해, 오브젝트와의 거리 정보 및 상대 속도 정보를 획득할 수 있다. 예를 들면, 카메라는, 스테레오 카메라에서 획득된 스테레오 영상에서 디스패러티(disparity) 정보를 기초로 오 브젝트와의 거리 정보 및 상대 속도 정보를 획득할 수 있다. 카메라는, 차량 외부를 촬영하기 위해 차량에서 FOV(field of view) 확보가 가능한 위치에 장착될 수 있다. 카 메라는, 차량 전방의 영상을 획득하기 위해, 차량의 실내에서, 프런트 윈드 쉴드에 근접하게 배치될 수 있다. 카메라는, 프런트 범퍼 또는 라디에이터 그릴 주변에 배치될 수 있다. 카메라는, 차량 후방의 영상을 획득하기 위해, 차량의 실내에서, 리어 글라스에 근접하게 배치될 수 있다. 카메라는, 리어 범퍼, 트렁크 또는 테일 게이 트 주변에 배치될 수 있다. 카메라는, 차량 측방의 영상을 획득하기 위해, 차량의 실내에서 사이드 윈도우 중 적어도 어느 하나에 근접하게 배치될 수 있다. 또는, 카메라는, 사이드 미러, 휀더 또는 도어 주변에 배치될 수 있다. 2.2) 레이다 레이다는 전파를 이용하여 차량 외부의 오브젝트에 대한 정보를 생성할 수 있다. 레이다는, 전자파 송신부, 전자파 수신부 및 전자파 송신부 및 전자파 수신부와 전기적으로 연결되어, 수신되는 신호를 처리하고, 처리되 는 신호에 기초하여 오브젝트에 대한 데이터를 생성하는 적어도 하나의 프로세서를 포함할 수 있다. 레이다는 전파 발사 원리상 펄스 레이다(Pulse Radar) 방식 또는 연속파 레이다(Continuous Wave Radar) 방식으로 구현 될 수 있다. 레이다는 연속파 레이다 방식 중에서 신호 파형에 따라 FMCW(Frequency Modulated Continuous Wave)방식 또는 FSK(Frequency Shift Keyong) 방식으로 구현될 수 있다. 레이다는 전자파를 매개로, TOF(Time of Flight) 방식 또는 페이즈 쉬프트(phase-shift) 방식에 기초하여, 오브젝트를 검출하고, 검출된 오브젝트의 위치, 검출된 오브젝트와의 거리 및 상대 속도를 검출할 수 있다. 레이다는, 차량의 전방, 후방 또는 측방에 위 치하는 오브젝트를 감지하기 위해 차량의 외부의 적절한 위치에 배치될 수 있다. 2.3) 라이다 라이다는, 레이저 광을 이용하여, 차량 외부의 오브젝트에 대한 정보를 생성할 수 있다. 라이다는, 광 송신 부, 광 수신부 및 광 송신부 및 광 수신부와 전기적으로 연결되어, 수신되는 신호를 처리하고, 처리된 신호에 기초하여 오브젝트에 대한 데이터를 생성하는 적어도 하나의 프로세서를 포함할 수 있다. 라이다는, TOF(Time of Flight) 방식 또는 페이즈 쉬프트(phase-shift) 방식으로 구현될 수 있다. 라이다는, 구동식 또는 비구동식 으로 구현될 수 있다. 구동식으로 구현되는 경우, 라이다는, 모터에 의해 회전되며, 차량 주변의 오브젝트 를 검출할 수 있다. 비구동식으로 구현되는 경우, 라이다는, 광 스티어링에 의해, 차량을 기준으로 소정 범위 내에 위치하는 오브젝트를 검출할 수 있다. 차량은 복수의 비구동식 라이다를 포함할 수 있다. 라이다는, 레이저 광 매개로, TOF(Time of Flight) 방식 또는 페이즈 쉬프트(phase-shift) 방식에 기초하여, 오브젝트를 검출하고, 검출된 오브젝트의 위치, 검출된 오브젝트와의 거리 및 상대 속도를 검출할 수 있다. 라이다는, 차량 의 전방, 후방 또는 측방에 위치하는 오브젝트를 감지하기 위해 차량의 외부의 적절한 위치에 배치될 수 있다. 3) 통신 장치 통신 장치는, 차량 외부에 위치하는 디바이스와 신호를 교환할 수 있다. 통신 장치는, 인프라(예 를 들면, 서버, 방송국), 타 차량, 단말기 중 적어도 어느 하나와 신호를 교환할 수 있다. 통신 장치는, 통신을 수행하기 위해 송신 안테나, 수신 안테나, 각종 통신 프로토콜이 구현 가능한 RF(Radio Frequency) 회로 및 RF 소자 중 적어도 어느 하나를 포함할 수 있다. 4) 운전 조작 장치 운전 조작 장치는, 운전을 위한 사용자 입력을 수신하는 장치이다. 메뉴얼 모드인 경우, 차량은, 운전 조작 장치에 의해 제공되는 신호에 기초하여 운행될 수 있다. 운전 조작 장치는, 조향 입력 장치(예 를 들면, 스티어링 휠), 가속 입력 장치(예를 들면, 가속 페달) 및 브레이크 입력 장치(예를 들면, 브레이크 페 달)를 포함할 수 있다. 5) 메인 ECU 메인 ECU는, 차량 내에 구비되는 적어도 하나의 전자 장치의 전반적인 동작을 제어할 수 있다. 6) 구동 제어 장치 구동 제어 장치는, 차량내 각종 차량 구동 장치를 전기적으로 제어하는 장치이다. 구동 제어 장치 는, 파워 트레인 구동 제어 장치, 샤시 구동 제어 장치, 도어/윈도우 구동 제어 장치, 안전 장치 구동 제 어 장치, 램프 구동 제어 장치 및 공조 구동 제어 장치를 포함할 수 있다. 파워 트레인 구동 제어 장치는, 동력 원 구동 제어 장치 및 변속기 구동 제어 장치를 포함할 수 있다. 샤시 구동 제어 장치는, 조향 구동 제어 장치, 브레이크 구동 제어 장치 및 서스펜션 구동 제어 장치를 포함할 수 있다. 한편, 안전 장치 구동 제어 장치는, 안전 벨트 제어를 위한 안전 벨트 구동 제어 장치를 포함할 수 있다. 구동 제어 장치는, 적어도 하나의 전자적 제어 장치(예를 들면, 제어 ECU(Electronic Control Unit))를 포함한다. 구종 제어 장치는, 자율 주행 장치에서 수신되는 신호에 기초하여, 차량 구동 장치를 제어할 수 있다. 예를 들면, 제어 장치는, 자율 주행 장치에서 수신되는 신호에 기초하여, 파워 트레인, 조향 장치 및 브레이크 장치를 제어할 수 있다. 7) 자율 주행 장치 자율 주행 장치는, 획득된 데이터에 기초하여, 자율 주행을 위한 패스를 생성할 수 있다. 자율 주행 장치 는, 생성된 경로를 따라 주행하기 위한 드라이빙 플랜을 생성 할 수 있다. 자율 주행 장치는, 드라이 빙 플랜에 따른 차량의 움직임을 제어하기 위한 신호를 생성할 수 있다. 자율 주행 장치는, 생성된 신호를 구동 제어 장치에 제공할 수 있다. 자율 주행 장치는, 적어도 하나의 ADAS(Advanced Driver Assistance System) 기능을 구현할 수 있다. ADAS는, 적응형 크루즈 컨트롤 시스템(ACC : Adaptive Cruise Control), 자동 비상 제동 시스템(AEB : Autonomous Emergency Braking), 전방 충돌 알림 시스템(FCW : Foward Collision Warning), 차선 유지 보조 시 스템(LKA : Lane Keeping Assist), 차선 변경 보조 시스템(LCA : Lane Change Assist), 타겟 추종 보조 시스템 (TFA : Target Following Assist), 사각 지대 감시 시스템(BSD : Blind Spot Detection), 적응형 하이빔 제어 시스템(HBA : High Beam Assist), 자동 주차 시스템(APS : Auto Parking System), 보행자 충돌 알림 시스템(PD collision warning system), 교통 신호 검출 시스템(TSR : Traffic Sign Recognition), 교통 신호 보조 시스템(TSA : Trafffic Sign Assist), 나이트 비전 시스템(NV : Night Vision), 운전자 상태 모니터링 시스템(DSM : Driver Status Monitoring) 및 교통 정체 지원 시스템(TJA : Traffic Jam Assist) 중 적어도 어느 하나를 구현 할 수 있다. 자율 주행 장치는, 자율 주행 모드에서 수동 주행 모드로의 전환 동작 또는 수동 주행 모드에서 자율 주행 모드로의 전환 동작을 수행할 수 있다. 예를 들면, 자율 주행 장치는, 사용자 인터페이스 장치로부터 수신되는 신호에 기초하여, 차량의 모드를 자율 주행 모드에서 수동 주행 모드로 전환하거나 수동 주행 모 드에서 자율 주행 모드로 전환할 수 있다. 8) 센싱부 센싱부는, 차량의 상태를 센싱할 수 있다. 센싱부는, IMU(inertial measurement unit) 센서, 충돌 센서, 휠 센서(wheel sensor), 속도 센서, 경사 센서, 중량 감지 센서, 헤딩 센서(heading sensor), 포지션 모 듈(position module), 차량 전진/후진 센서, 배터리 센서, 연료 센서, 타이어 센서, 스티어링 센서, 온도 센서, 습도 센서, 초음파 센서, 조도 센서, 페달 포지션 센서 중 적어도 어느 하나를 포함할 수 있다. 한편, IMU(inertial measurement unit) 센서는, 가속도 센서, 자이로 센서, 자기 센서 중 하나 이상을 포함할 수 있 다. 센싱부는, 적어도 하나의 센서에서 생성되는 신호에 기초하여, 차량의 상태 데이터를 생성할 수 있다. 차 량 상태 데이터는, 차량 내부에 구비된 각종 센서에서 감지된 데이터를 기초로 생성된 정보일 수 있다. 센싱부 는, 차량 자세 데이터, 차량 모션 데이터, 차량 요(yaw) 데이터, 차량 롤(roll) 데이터, 차량 피치(pitch) 데이터, 차량 충돌 데이터, 차량 방향 데이터, 차량 각도 데이터, 차량 속도 데이터, 차량 가속도 데이터, 차량 기울기 데이터, 차량 전진/후진 데이터, 차량의 중량 데이터, 배터리 데이터, 연료 데이터, 타이어 공기압 데이 터, 차량 내부 온도 데이터, 차량 내부 습도 데이터, 스티어링 휠 회전 각도 데이터, 차량 외부 조도 데이터, 가속 페달에 가해지는 압력 데이터, 브레이크 페달에 가해지는 압력 데이터 등을 생성할 수 있다. 9) 위치 데이터 생성 장치 위치 데이터 생성 장치는, 차량의 위치 데이터를 생성할 수 있다. 위치 데이터 생성 장치는, GPS(Global Positioning System) 및 DGPS(Differential Global Positioning System) 중 적어도 어느 하나를 포 함할 수 있다. 위치 데이터 생성 장치는, GPS 및 DGPS 중 적어도 어느 하나에서 생성되는 신호에 기초하여 차량의 위치 데이터를 생성할 수 있다. 실시예에 따라, 위치 데이터 생성 장치는, 센싱부의 IMU(Inertial Measurement Unit) 및 오브젝트 검출 장치의 카메라 중 적어도 어느 하나에 기초하여 위치 데이터를 보정할 수 있다. 위치 데이터 생성 장치는, GNSS(Global Navigation Satellite System)로 명명 될 수 있다. 차량은, 내부 통신 시스템을 포함할 수 있다. 차량에 포함되는 복수의 전자 장치는 내부 통신 시스 템을 매개로 신호를 교환할 수 있다. 신호에는 데이터가 포함될 수 있다. 내부 통신 시스템은, 적어도 하나의 통신 프로토콜(예를 들면, CAN, LIN, FlexRay, MOST, 이더넷)을 이용할 수 있다. 자율 주행 장치의 구성 요소 도 3은 본 명세서의 실시예에 따른 자율 주행 장치의 제어 블럭도이다. 도 3을 참조하면, 자율 주행 장치는, 메모리, 프로세서, 인터페이스부 및 전원 공급부 를 포함할 수 있다. 메모리는, 프로세서와 전기적으로 연결된다. 메모리는 유닛에 대한 기본데이터, 유닛의 동작제 어를 위한 제어데이터, 입출력되는 데이터를 저장할 수 있다. 메모리는, 프로세서에서 처리된 데이터 를 저장할 수 있다. 메모리는, 하드웨어적으로, ROM, RAM, EPROM, 플래시 드라이브, 하드 드라이브 중 적 어도 어느 하나로 구성될 수 있다. 메모리는 프로세서의 처리 또는 제어를 위한 프로그램 등, 자율 주행 장치 전반의 동작을 위한 다양한 데이터를 저장할 수 있다. 메모리는, 프로세서와 일체형 으로 구현될 수 있다. 실시예에 따라, 메모리는, 프로세서의 하위 구성으로 분류될 수 있다. 인터페이스부는, 차량 내에 구비되는 적어도 하나의 전자 장치와 유선 또는 무선으로 신호를 교환할 수 있다. 인터페이스부는, 오브젝트 검출 장치, 통신 장치, 운전 조작 장치, 메인 ECU, 구동 제어 장치, 센싱부 및 위치 데이터 생성 장치 중 적어도 어느 하나와 유선 또는 무선으로 신호를 교환할 수 있다. 인터페이스부는, 통신 모듈, 단자, 핀, 케이블, 포트, 회로, 소자 및 장치 중 적어도 어느 하나로 구성될 수 있다. 전원 공급부는, 자율 주행 장치에 전원을 공급할 수 있다. 전원 공급부는, 차량에 포함된 파워 소스(예를 들면, 배터리)로부터 전원을 공급받아, 자율 주행 장치의 각 유닛에 전원을 공급할 수 있 다. 전원 공급부는, 메인 ECU로부터 제공되는 제어 신호에 따라 동작될 수 있다. 전원 공급부는, SMPS(switched-mode power supply)를 포함할 수 있다. 프로세서는, 메모리, 인터페이스부, 전원 공급부와 전기적으로 연결되어 신호를 교환할 수 있다. 프로세서는, ASICs (application specific integrated circuits), DSPs(digital signal processors), DSPDs(digital signal processing devices), PLDs(programmable logic devices), FPGAs(field programmable gate arrays), 프로세서(processors), 제어기(controllers), 마이크로 컨트롤러(micro- controllers), 마이크로 프로세서(microprocessors), 기타 기능 수행을 위한 전기적 유닛 중 적어도 하나를 이 용하여 구현될 수 있다. 프로세서는, 전원 공급부로부터 제공되는 전원에 의해 구동될 수 있다. 프로세서는, 전원 공급 부에 의해 전원이 공급되는 상태에서 데이터를 수신하고, 데이터를 처리하고, 신호를 생성하고, 신호를 제 공할 수 있다. 프로세서는, 인터페이스부를 통해, 차량 내 다른 전자 장치로부터 정보를 수신할 수 있다. 프로 세서는, 인터페이스부를 통해, 차량 내 다른 전자 장치로 제어 신호를 제공할 수 있다. 자율 주행 장치는, 적어도 하나의 인쇄 회로 기판(printed circuit board, PCB)을 포함할 수 있다. 메모 리, 인터페이스부, 전원 공급부 및 프로세서는, 인쇄 회로 기판에 전기적으로 연결될 수 있다. 자율 주행 장치의 동작 도 4는 본 명세서의 실시예에 따른 자율 주행 차량의 신호 흐름도이다. 1) 수신 동작 도 4를 참조하면, 프로세서는, 수신 동작을 수행할 수 있다. 프로세서는, 인터페이스부를 통해, 오브젝트 검출 장치, 통신 장치, 센싱부 및 위치 데이터 생성 장치 중 적어도 어느 하나로 부터, 데이터를 수신할 수 있다. 프로세서는, 오브젝트 검출 장치로부터, 오브젝트 데이터를 수신할 수 있다. 프로세서는, 통신 장치로부터, HD 맵 데이터를 수신할 수 있다. 프로세서는, 센싱부 로부터, 차량 상태 데이터를 수신할 수 있다. 프로세서는, 위치 데이터 생성 장치로부터 위치 데이터를 수신할 수 있다. 2) 처리/판단 동작 프로세서는, 처리/판단 동작을 수행할 수 있다. 프로세서는, 주행 상황 정보에 기초하여, 처리/판단 동작을 수행할 수 있다. 프로세서는, 오브젝트 데이터, HD 맵 데이터, 차량 상태 데이터 및 위치 데이터 중 적어도 어느 하나에 기초하여, 처리/판단 동작을 수행할 수 있다. 2.1) 드라이빙 플랜 데이터 생성 동작 프로세서는, 드라이빙 플랜 데이터(driving plan data)를 생성할 수 있다. 예를 들면, 프로세서(1700는, 일렉트로닉 호라이즌 데이터(Electronic Horizon Data)를 생성할 수 있다. 일렉트로닉 호라이즌 데이터는, 차량 이 위치한 지점에서부터 호라이즌(horizon)까지 범위 내에서의 드라이빙 플랜 데이터로 이해될 수 있다. 호 라이즌은, 기 설정된 주행 경로를 기준으로, 차량이 위치한 지점에서 기설정된 거리 앞의 지점으로 이해될 수 있다. 호라이즌은, 기 설정된 주행 경로를 따라 차량이 위치한 지점에서부터 차량이 소정 시간 이후 에 도달할 수 있는 지점을 의미할 수 있다. 일렉트로닉 호라이즌 데이터는, 호라이즌 맵 데이터 및 호라이즌 패스 데이터를 포함할 수 있다. 2.1.1) 호라이즌 맵 데이터 호라이즌 맵 데이터는, 토폴로지 데이터(topology data), 도로 데이터, HD 맵 데이터 및 다이나믹 데이터 (dynamic data) 중 적어도 어느 하나를 포함할 수 있다. 실시예에 따라, 호라이즌 맵 데이터는, 복수의 레이어 를 포함할 수 있다. 예를 들면, 호라이즌 맵 데이터는, 토폴로지 데이터에 매칭되는 1 레이어, 도로 데이터에매칭되는 제2 레이어, HD 맵 데이터에 매칭되는 제3 레이어 및 다이나믹 데이터에 매칭되는 제4 레이어를 포함 할 수 있다. 호라이즌 맵 데이터는, 스태이틱 오브젝트(static object) 데이터를 더 포함할 수 있다. 토폴로지 데이터는, 도로 중심을 연결해 만든 지도로 설명될 수 있다. 토폴로지 데이터는, 차량의 위치를 대략 적으로 표시하기에 알맞으며, 주로 운전자를 위한 내비게이션에서 사용하는 데이터의 형태일 수 있다. 토폴로지 데이터는, 차로에 대한 정보가 제외된 도로 정보에 대한 데이터로 이해될 수 있다. 토폴로지 데이터는, 통신 장 치를 통해, 외부 서버에서 수신된 데이터에 기초하여 생성될 수 있다. 토폴로지 데이터는, 차량에 구 비된 적어도 하나의 메모리에 저장된 데이터에 기초할 수 있다. 도로 데이터는, 도로의 경사 데이터, 도로의 곡률 데이터, 도로의 제한 속도 데이터 중 적어도 어느 하나를 포 함할 수 있다. 도로 데이터는, 추월 금지 구간 데이터를 더 포함할 수 있다. 도로 데이터는, 통신 장치를 통해, 외부 서버에서 수신된 데이터에 기초할 수 있다. 도로 데이터는, 오브젝트 검출 장치에서 생성된 데 이터에 기초할 수 있다. HD 맵 데이터는, 도로의 상세한 차선 단위의 토폴로지 정보, 각 차선의 연결 정보, 차량의 로컬라이제이션 (localization)을 위한 특징 정보(예를 들면, 교통 표지판, Lane Marking/속성, Road furniture 등)를 포함할 수 있다. HD 맵 데이터는, 통신 장치를 통해, 외부 서버에서 수신된 데이터에 기초할 수 있다. 다이나믹 데이터는, 도로상에서 발생될 수 있는 다양한 동적 정보를 포함할 수 있다. 예를 들면, 다이나믹 데이 터는, 공사 정보, 가변 속도 차로 정보, 노면 상태 정보, 트래픽 정보, 무빙 오브젝트 정보 등을 포함할 수 있 다. 다이나믹 데이터는, 통신 장치를 통해, 외부 서버에서 수신된 데이터에 기초할 수 있다. 다이나믹 데 이터는, 오브젝트 검출 장치에서 생성된 데이터에 기초할 수 있다. 프로세서는, 차량이 위치한 지점에서부터 호라이즌까지 범위 내에서의 맵 데이터를 제공할 수 있다. 2.1.2) 호라이즌 패스 데이터 호라이즌 패스 데이터는, 차량이 위치한 지점에서부터 호라이즌까지의 범위 내에서 차량이 취할 수 있 는 궤도로 설명될 수 있다. 호라이즌 패스 데이터는, 디시전 포인트(decision point)(예를 들면, 갈림길, 분기 점, 교차로 등)에서 어느 하나의 도로를 선택할 상대 확률을 나타내는 데이터를 포함할 수 있다. 상대 확률은, 최종 목적지까지 도착하는데 걸리는 시간에 기초하여 계산될 수 있다. 예를 들면, 디시전 포인트에서, 제1 도로 를 선택하는 경우 제2 도로를 선택하는 경우보다 최종 목적지에 도착하는데 걸리는 시간이 더 작은 경우, 제1 도로를 선택할 확률은 제2 도로를 선택할 확률보다 더 높게 계산될 수 있다. 호라이즌 패스 데이터는, 메인 패스와 서브 패스를 포함할 수 있다. 메인 패스는, 선택될 상대적 확률이 높은 도로들을 연결한 궤도로 이해될 수 있다. 서브 패스는, 메인 패스 상의 적어도 하나의 디시전 포인트에서 분기 될 수 있다. 서브 패스는, 메인 패스 상의 적어도 하나의 디시전 포인트에서 선택될 상대적 확률이 낮은 적어도 어느 하나의 도로를 연결한 궤도로 이해될 수 있다. 3) 제어 신호 생성 동작 프로세서는, 제어 신호 생성 동작을 수행할 수 있다. 프로세서는, 일렉트로닉 호라이즌 데이터에 기 초하여, 제어 신호를 생성할 수 있다. 예를 들면, 프로세서는, 일렉트로닉 호라이즌 데이터에 기초하여, 파워트레인 제어 신호, 브라이크 장치 제어 신호 및 스티어링 장치 제어 신호 중 적어도 어느 하나를 생성할 수 있다. 프로세서는, 인터페이스부를 통해, 생성된 제어 신호를 구동 제어 장치에 전송할 수 있다. 구동 제어 장치는, 파워 트레인, 브레이크 장치 및 스티어링 장치 중 적어도 어느 하나에 제어 신호를 전송할 수 있다. 2. 캐빈 도 5는 본 명세서의 실시예에 따른 차량의 내부를 도시한 도면이다. 도 6은 본 명세서의 실시에에 따른 차량용 캐빈 시스템을 설명하는데 참조되는 블럭도이다. 캐빈의 구성 요소 도 5 내지 도 6을 참조하면, 차량용 캐빈 시스템(이하, 캐빈 시스템)은 차량을 이용하는 사용자를 위 한 편의 시스템으로 정의될 수 있다. 캐빈 시스템은, 디스플레이 시스템, 카고 시스템, 시트 시스템 및 페이 먼트 시스템을 포함하는 최상위 시스템으로 설명될 수 있다. 캐빈 시스템은, 메인 컨트롤러, 메모리, 인터페이스부, 전원 공급부, 입력 장치, 영상 장치, 통신 장치, 디스플레이 시스템, 카고 시스템, 시트 시스템 및 페이먼트 시스템을 포함할 수 있다. 실시예에 따라, 캐빈 시스템은, 본 명세서에서 설명되는 구성 요소외에 다른 구성 요소를 더 포 함하거나, 설명되는 구성 요소 중 일부를 포함하지 않을 수 있다. 1) 메인 컨트롤러 메인 컨트롤러는, 입력 장치, 통신 장치, 디스플레이 시스템, 카고 시스템, 시트 시 스템 및 페이먼트 시스템과 전기적으로 연결되어 신호를 교환할 수 있다. 메인 컨트롤러는, 입 력 장치, 통신 장치, 디스플레이 시스템, 카고 시스템, 시트 시스템 및 페이먼트 시 스템을 제어할 수 있다. 메인 컨트롤러는, ASICs (application specific integrated circuits), DSPs(digital signal processors), DSPDs(digital signal processing devices), PLDs(programmable logic devices), FPGAs(field programmable gate arrays), 프로세서(processors), 제어기(controllers), 마이크로 컨 트롤러(micro-controllers), 마이크로 프로세서(microprocessors), 기타 기능 수행을 위한 전기적 유닛 중 적 어도 하나를 이용하여 구현될 수 있다. 메인 컨트롤러는, 적어도 하나의 서브 컨트롤러로 구성될 수 있다. 실시예에 따라, 메인 컨트롤러는, 복수의 서브 컨트롤러를 포함할 수 있다. 복수의 서브 컨트롤러는 각각이, 그루핑된 캐빈 시스템에 포함된 장치 및 시스템을 개별적으로 제어할 수 있다. 캐빈 시스템에 포함된 장치 및 시스템은, 기능별로 그루핑 되거나, 착좌 가능한 시트를 기준으로 그루핑될 수 있다. 메인 컨트롤러는, 적어도 하나의 프로세서를 포함할 수 있다. 도 6에는 메인 컨트롤러가 하나의 프로세서를 포함하는 것으로 예시되나, 메인 컨트롤러는, 복수의 프로세서를 포함할 수도 있다. 프로 세서는, 상술한 서브 컨트롤러 중 어느 하나로 분류될 수도 있다. 프로세서는, 통신 장치를 통해, 사용자 단말기로부터 신호, 정보 또는 데이터를 수신할 수 있다. 사 용자 단말기는, 캐빈 시스템에 신호, 정보 또는 데이터를 전송할 수 있다. 프로세서는, 영상 장치에 포함된 내부 카메라 및 외부 카메 중 적어도 어느 하나에서 수신되는 영상 데이 터에 기초하여, 사용자를 특정할 수 있다. 프로세서는, 영상 데이터에 영상 처리 알고리즘을 적용하여 사 용자를 특정할 수 있다. 예를 들면, 프로세서는, 사용자 단말기로부터 수신되는 정보와 영상 데이터를 비 교하여 사용자를 특정할 수 있다. 예를 들면, 정보는, 사용자의 경로 정보, 신체 정보, 동승자 정보, 짐 정보, 위치 정보, 선호하는 컨텐츠 정보, 선호하는 음식 정보, 장애 여부 정보 및 이용 이력 정보 중 적어도 어느 하 나를 포함할 수 있다. 메인 컨트롤러는, 인공지능 에이전트(artificial intelligence agent)를 포함할 수 있다. 인공지능 에이전트는, 입력 장치를 통해 획득된 데이터를 기초로 기계 학습(machine learning)을 수행할 수 있 다. 인공지능 에이전트는, 기계 학습된 결과에 기초하여, 디스플레이 시스템, 카고 시스템, 시 트 시스템 및 페이먼트 시스템 중 적어도 어느 하나를 제어할 수 있다. 2) 필수 구성 요소 메모리는, 메인 컨트롤러와 전기적으로 연결된다. 메모리는 유닛에 대한 기본데이터, 유닛의 동 작제어를 위한 제어데이터, 입출력되는 데이터를 저장할 수 있다. 메모리는, 메인 컨트롤러에서 처리 된 데이터를 저장할 수 있다. 메모리는, 하드웨어적으로, ROM, RAM, EPROM, 플래시 드라이브, 하드 드라이 브 중 적어도 어느 하나로 구성될 수 있다. 메모리는 메인 컨트롤러의 처리 또는 제어를 위한 프로그 램 등, 캐빈 시스템 전반의 동작을 위한 다양한 데이터를 저장할 수 있다. 메모리는, 메인 컨트롤러 와 일체형으로 구현될 수 있다. 인터페이스부는, 차량 내에 구비되는 적어도 하나의 전자 장치와 유선 또는 무선으로 신호를 교환할 수 있다. 인터페이스부는, 통신 모듈, 단자, 핀, 케이블, 포트, 회로, 소자 및 장치 중 적어도 어느 하나 로 구성될 수 있다. 전원 공급부는, 캐빈 시스템에 전원을 공급할 수 있다. 전원 공급부는, 차량에 포함된 파워 소스(예를 들면, 배터리)로부터 전원을 공급받아, 캐빈 시스템의 각 유닛에 전원을 공급할 수 있다. 전원 공급부는, 메인 컨트롤러로부터 제공되는 제어 신호에 따라 동작될 수 있다. 예를 들면, 전원 공급부는, SMPS(switched-mode power supply)로 구현될 수 있다. 캐빈 시스템은, 적어도 하나의 인쇄 회로 기판(printed circuit board, PCB)을 포함할 수 있다. 메인 컨 트롤러, 메모리, 인터페이스부 및 전원 공급부는, 적어도 하나의 인쇄 회로 기판에 실장될 수 있다. 3) 입력 장치 입력 장치는, 사용자 입력을 수신할 수 있다. 입력 장치는, 사용자 입력을 전기적 신호로 전환할 수 있다. 입력 장치에 의해 전환된 전기적 신호는 제어 신호로 전환되어 디스플레이 시스템, 카고 시스 템, 시트 시스템 및 페이먼트 시스템 중 적어도 어느 하나에 제공될 수 있다. 메인 컨트롤러 또는 캐빈 시스템에 포함되는 적어도 하나의 프로세서는 입력 장치로부터 수신되는 전기적 신 호에 기초한 제어 신호를 생성할 수 있다. 입력 장치는, 터치 입력부, 제스쳐 입력부, 기계식 입력부 및 음성 입력부 중 적어도 어느 하나를 포함할 수 있다. 터치 입력부는, 사용자의 터치 입력을 전기적 신호로 전환할 수 있다. 터치 입력부는, 사용자의 터치 입력을 감지하기 위해 적어도 하나의 터치 센서를 포함할 수 있다. 실시예에 따라, 터치 입력부는 디스플레이 시스템에 포함되는 적어도 하나의 디스플레이 와 일체형으로 형성됨으로써, 터치 스크린을 구현할 수 있다. 이러한, 터치 스크린은, 캐빈 시스템과 사용자 사이의 입력 인터페이스 및 출력 인터페이스를 함께 제공할 수 있다. 제스쳐 입력부는, 사용자의 제스쳐 입력을 전기적 신호로 전환할 수 있다. 제스쳐 입력부는, 사용자의 제스쳐 입력을 감지하기 위한 적외선 센서 및 이미지 센서 중 적어도 어느 하나를 포함할 수 있다. 실 시예에 따라, 제스쳐 입력부는, 사용자의 3차원 제스쳐 입력을 감지할 수 있다. 이를 위해, 제스쳐 입력부는, 복수의 적외선 광을 출력하는 광출력부 또는 복수의 이미지 센서를 포함할 수 있다. 제스쳐 입력부는, TOF(Time of Flight) 방식, 구조광(Structured light) 방식 또는 디스패러티(Disparity) 방식을 통해 사용자의 3차원 제 스쳐 입력을 감지할 수 있다. 기계식 입력부는, 기계식 장치를 통한 사용자의 물리적인 입력(예를 들면, 누름 또는 회전)을 전기적 신호로 전환할 수 있다. 기계식 입력부는, 버튼, 돔 스위치(dome switch), 조그 휠 및 조 그 스위치 중 적어도 어느 하나를 포함할 수 있다. 한편, 제스쳐 입력부와 기계식 입력부는 일체형으로 형성될 수 있다. 예를 들면, 입력 장치는, 제스쳐 센서가 포함되고, 주변 구조물(예를 들면, 시트, 암레스트 및 도어 중 적어도 어느 하나)의 일부분에서 출납 가능하게 형성된 조그 다이얼 장치를 포함할 수 있다. 조그 다이 얼 장치가 주변 구조물과 평평한 상태를 이룬 경우, 조그 다이얼 장치는 제스쳐 입력부로 기능할 수 있다. 조그 다이얼 장치가 주변 구조물에 비해 돌출된 상태의 경우, 조그 다이얼 장치는 기계식 입력부로 기능할 수 있다. 음성 입력부는, 사용자의 음성 입력을 전기적 신호로 전환할 수 있다. 음성 입력부는, 적어도 하나의 마이크로 폰을 포함할 수 있다. 음성 입력부는, 빔 포밍 마이크(Beam foaming MIC)를 포함할 수 있다. 4) 영상 장치 영상 장치는, 적어도 하나의 카메라를 포함할 수 있다. 영상 장치는, 내부 카메라 및 외부 카메라 중 적어도 어느 하나를 포함할 수 있다. 내부 카메라는, 캐빈 내의 영상을 촬영할 수 있다. 외부 카메라는, 차량 외부 영상을 촬영할 수 있다. 내부 카메라는, 캐빈 내의 영상을 획득할 수 있다. 영상 장치는, 적어도 하 나의 내부 카메라를 포함할 수 있다. 영상 장치는, 탑승 가능 인원에 대응되는 갯수의 카메라를 포함하는 것이 바람직하다. 영상 장치는, 내부 카메라에 의해 획득된 영상을 제공할 수 있다. 메인 컨트롤러 또는 캐빈 시스템에 포함되는 적어도 하나의 프로세서는, 내부 카메라에 의해 획득된 영상에 기초하여 사 용자의 모션을 검출하고, 검출된 모션에 기초하여 신호를 생성하여, 디스플레이 시스템, 카고 시스템 , 시트 시스템 및 페이먼트 시스템 중 적어도 어느 하나에 제공할 수 있다. 외부 카메라는, 차 량 외부 영상을 획득할 수 있다. 영상 장치는, 적어도 하나의 외부 카메라를 포함할 수 있다. 영상 장치 는, 탑승 도어에 대응되는 갯수의 카메라를 포함하는 것이 바람직하다. 영상 장치는, 외부 카메라에 의해 획득된 영상을 제공할 수 있다. 메인 컨트롤러 또는 캐빈 시스템에 포함되는 적어도 하나의 프 로세서는, 외부 카메라에 의해 획득된 영상에 기초하여 사용자 정보를 획득할 수 있다. 메인 컨트롤러 또 는 캐빈 시스템에 포함되는 적어도 하나의 프로세서는, 사용자 정보에 기초하여, 사용자를 인증하거나, 사 용자의 신체 정보(예를 들면, 신장 정보, 체중 정보 등), 사용자의 동승자 정보, 사용자의 짐 정보 등을 획득할 수 있다. 5) 통신 장치 통신 장치는, 외부 디바이스와 무선으로 신호를 교환할 수 있다. 통신 장치는, 네트워크 망을 통해 외부 디바이스와 신호를 교환하거나, 직접 외부 디바이스와 신호를 교환할 수 있다. 외부 디바이스는, 서버, 이 동 단말기 및 타 차량 중 적어도 어느 하나를 포함할 수 있다. 통신 장치는, 적어도 하나의 사용자 단말기 와 신호를 교환할 수 있다. 통신 장치는, 통신을 수행하기 위해 안테나, 적어도 하나의 통신 프로토콜이 구현 가능한 RF(Radio Frequency) 회로 및 RF 소자 중 적어도 어느 하나를 포함할 수 있다. 실시예에 따라, 통 신 장치는, 복수의 통신 프로토콜을 이용할 수도 있다. 통신 장치는, 이동 단말기와의 거리에 따라 통신 프로토콜을 전환할 수 있다. 6) 디스플레이 시스템 디스플레이 시스템은, 그래픽 객체를 표시할 수 있다. 디스플레이 시스템은, 적어도 하나의 디스플 레이 장치를 포함할 수 있다. 예를 들면, 디스플레이 시스템은, 공용으로 이용 가능한 제1 디스플레이 장 치와 개별 이용 가능한 제2 디스플레이 장치를 포함할 수 있다. 6.1) 공용 디스플레이 장치 제1 디스플레이 장치는, 시각적 컨텐츠를 출력하는 적어도 하나의 디스플레이를 포함할 수 있다. 제1 디스플레이 장치에 포함되는 디스플레이는, 평면 디스플레이. 곡면 디스플레이, 롤러블 디스플레이 및 플렉서블 디스플레이 중 적어도 어느 하나로 구현될 수 있다. 예를 들면, 제1 디스플레이 장치는, 시트 후방에 위치하고, 캐빈 내로 출납 가능하게 형성된 제1 디스플레이 및 상기 제1 디스플레이를 이동시 키기 위한 제1 메카니즘를 포함할 수 있다. 제1 디스플레이는, 시트 메인 프레임에 형성된 슬롯에 출납 가 능하게 배치될 수 있다. 실시예에 따라, 제1 디스플레이 장치는, 플렉서블 영역 조절 메카니즘을 더 포함 할 수 있다. 제1 디스플레이는, 플렉서블하게 형성될 수 있고, 사용자의 위치에 따라, 제1 디스플레이의 플렉서 블 영역이 조절될 수 있다. 예를 들면, 제1 디스플레이 장치는, 캐빈내 천장에 위치하고, 롤러블 (rollable)하게 형성된 제2 디스플레이 및 상기 제2 디스플레이를 감거나 풀기 위한 제2 메카니즘을 포함할 수 있다. 제2 디스플레이는, 양면에 화면 출력이 가능하게 형성될 수 있다. 예를 들면, 제1 디스플레이 장치 는, 캐빈내 천장에 위치하고, 플렉서블(flexible)하게 형성된 제3 디스플레이 및 상기 제3 디스플레이를 휘거나 펴기위한 제3 메카니즘을 포함할 수 있다. 실시예에 따라, 디스플레이 시스템은, 제1 디스플레이 장치 및 제2 디스플레이 장치 중 적어도 어느 하나에 제어 신호를 제공하는 적어도 하나의 프로세서를 더 포함할 수 있다. 디스플레이 시스템에 포함되는 프로세서는, 메인 컨트롤러, 입력 장치, 영상 장치 및 통신 장치 중 적어도 어느 하나로부터 수신되는 신호에 기초하여 제어 신호를 생성할 수 있 다. 제1 디스플레이 장치에 포함되는 디스플레이의 표시 영역은, 제1 영역(411a) 및 제2 영역(411b)으로 구분 될 수 있다. 제1 영역(411a)은, 컨텐츠를 표시 영역으로 정의될 수 있다. 예를 들면, 제 1영역은, 엔터테 인먼트 컨텐츠(예를 들면, 영화, 스포츠, 쇼핑, 음악 등), 화상 회의, 음식 메뉴 및 증강 현실 화면에 대응하는 그래픽 객체 중 적어도 어느 하나를 표시할 수 있다. 제1 영역(411a)은, 차량의 주행 상황 정보에 대응하는 그래픽 객체를 표시할 수 있다. 주행 상황 정보는, 주행 상황 정보는, 차량 외부의 오브젝트 정보, 내비게이션 정보 및 차량 상태 정보 중 적어도 어느 하나를 포함할 수 있다. 차량 외부의 오브젝트 정보는, 오브젝트의 존 재 유무에 대한 정보, 오브젝트의 위치 정보, 차량과 오브젝트와의 거리 정보 및 차량과 오브젝트와 의 상대 속도 정보를 포함할 수 있다. 내비게이션 정보는, 맵(map) 정보, 설정된 목적지 정보, 상기 목적지 설 정 따른 경로 정보, 경로 상의 다양한 오브젝트에 대한 정보, 차선 정보 및 차량의 현재 위치 정보 중 적어도 어느 하나를 포함할 수 있다. 차량 상태 정보는, 차량의 자세 정보, 차량의 속도 정보, 차량의 기울기 정보, 차 량의 중량 정보, 차량의 방향 정보, 차량의 배터리 정보, 차량의 연료 정보, 차량의 타이어 공기압 정보, 차량 의 스티어링 정보, 차량 실내 온도 정보, 차량 실내 습도 정보, 페달 포지션 정보 및 차량 엔진 온도 정보 등을 포함할 수 있다. 제2 영역(411b)은, 사용자 인터페이스 영역으로 정의될 수 있다. 예를 들면, 제2 영역(411b)은, 인공 지능 에이전트 화면을 출력할 수 있다. 실시예에 따라, 제2 영역(411b)은, 시트 프레임으로 구분되는 영역에 위치할 수 있다. 이경우, 사용자는, 복수의 시트 사이로 제2 영역(411b)에 표시되는 컨텐츠를 바라볼 수 있다. 실시예에 따라, 제1 디스플레이 장치는, 홀로그램 컨텐츠를 제공할 수 있다. 예를 들면, 제1 디스플레이 장치는, 복수의 사용자별로 홀로그램 컨텐츠를 제공하여 컨텐츠를 요청한 사용자만 해당 컨텐츠를 시청하게 할 수 있다. 6.2) 개인용 디스플레이 장치 제2 디스플레이 장치는, 적어도 하나의 디스플레이을 포함할 수 있다. 제2 디스플레이 장치는, 개개의 탑승자만 디스플레이 내용을 확인할 수 있는 위치에 디스플레이을 제공할 수 있다. 예를 들면, 디스플레이은, 시트의 암 레스트에 배치될 수 있다. 제2 디스플레이 장치는, 사용자의 개인 정보에 대 응되는 그래픽 객체를 표시할 수 있다. 제2 디스플레이 장치는, 탑승 가능 인원에 대응되는 갯수의 디스플 레이을 포함할 수 있다. 제2 디스플레이 장치는, 터치 센서와 상호 레이어 구조를 이루거나 일체형으 로 형성됨으로써, 터치 스크린을 구현할 수 있다. 제2 디스플레이 장치는, 시트 조정 또는 실내 온도 조정 의 사용자 입력을 수신하기 위한 그래픽 객체를 표시할 수 있다. 7) 카고 시스템 카고 시스템은, 사용자의 요청에 따라 상품을 사용자에게 제공할 수 있다. 카고 시스템은, 입력 장치 또는 통신 장치에 의해 생성되는 전기적 신호에 기초하여 동작될 수 있다. 카고 시스템은, 카 고 박스를 포함할 수 있다. 카고 박스는, 상품들이 적재된 상태로 시트 하단의 일 부분에 은닉될 수 있다. 사용 자 입력에 기초한 전기적 신호가 수신되는 경우, 카고 박스는, 캐빈으로 노출될 수 있다. 사용자는 노출된 카고 박스에 적재된 물품 중 필요한 상품을 선택할 수 있다. 카고 시스템은, 사용자 입력에 따른 카고 박스의 노출을 위해, 슬라이딩 무빙 메카니즘, 상품 팝업 메카니즘을 포함할 수 있다. 카고 시스템은은, 다양한 종류의 상품을 제공하기 위해 복수의 카고 박스를 포함할 수 있다. 카고 박스에는, 상품별로 제공 여부를 판단 하기 위한 무게 센서가 내장될 수 있다. 8) 시트 시스템 시트 시스템은, 사용자에 맞춤형 시트를 사용자에게 제공할 수 있다. 시트 시스템은, 입력 장치 또는 통신 장치에 의해 생성되는 전기적 신호에 기초하여 동작될 수 있다. 시트 시스템은, 획득된 사 용자 신체 데이터에 기초하여, 시트의 적어도 하나의 요소를 조정할 수 있다. 시트 시스템은 사용자의 착 좌 여부를 판단하기 위한 사용자 감지 센서(예를 들면, 압력 센서)를 포함할 수 있다. 시트 시스템은, 복 수의 사용자가 각각 착좌할 수 있는 복수의 시트를 포함할 수 있다. 복수의 시트 중 어느 하나는 적어도 다른 하나와 마주보게 배치될 수 있다. 캐빈 내부의 적어도 두명의 사용자는 서로 마주보고 앉을 수 있다. 9) 페이먼트 시스템 페이먼트 시스템은, 결제 서비스를 사용자에게 제공할 수 있다. 페이먼트 시스템은, 입력 장치 또는 통신 장치에 의해 생성되는 전기적 신호에 기초하여 동작될 수 있다. 페이먼트 시스템은, 사용 자가 이용한 적어도 하나의 서비스에 대한 가격을 산정하고, 산정된 가격이 지불되도록 요청할 수 있다. 자율 주행 차량 이용 시나리오 도 7은 본 명세서의 실시예에 따라 사용자의 이용 시나리오를 설명하는데 참조되는 도면이다. 1) 목적지 예측 시나리오 제1 시나리오(S111)는, 사용자의 목적지 예측 시나리오이다. 사용자 단말기는 캐빈 시스템과 연동 가능한 애플리케이션을 설치할 수 있다. 사용자 단말기는, 애플리케이션을 통해, 사용자의 컨텍스트추얼 정보(user's contextual information)를 기초로, 사용자의 목적지를 예측할 수 있다. 사용자 단말기는, 애플리케이션을 통해, 캐빈 내의 빈자리 정보를 제공할 수 있다. 2) 캐빈 인테리어 레이아웃 준비 시나리오 제2 시나리오(S112)는, 캐빈 인테리어 레이아웃 준비 시나리오이다. 캐빈 시스템은, 차량 외부에 위 치하는 사용자에 대한 데이터를 획득하기 위한 스캐닝 장치를 더 포함할 수 있다. 스캐닝 장치는, 사용자를 스 캐닝하여, 사용자의 신체 데이터 및 수하물 데이터를 획득할 수 있다. 사용자의 신체 데이터 및 수하물 데이터 는, 레이아웃을 설정하는데 이용될 수 있다. 사용자의 신체 데이터는, 사용자 인증에 이용될 수 있다. 스캐닝 장치는, 적어도 하나의 이미지 센서를 포함할 수 있다. 이미지 센서는, 가시광 대역 또는 적외선 대역의 광을 이용하여 사용자 이미지를 획득할 수 있다. 시트 시스템은, 사용자의 신체 데이터 및 수하물 데이터 중 적어도 어느 하나에 기초하여, 캐빈 내 레이아 웃을 설정할 수 있다. 예를 들면, 시트 시스템은, 수하물 적재 공간 또는 카시트 설치 공간을 마련할 수 있다. 3) 사용자 환영 시나리오 제3 시나리오(S113)는, 사용자 환영 시나리오이다. 캐빈 시스템은, 적어도 하나의 가이드 라이트를 더 포 함할 수 있다. 가이드 라이트는, 캐빈 내 바닥에 배치될 수 있다. 캐빈 시스템은, 사용자의 탑승이 감지되 는 경우, 복수의 시트 중 기 설정된 시트에 사용자가 착석하도록 가이드 라이트를 출력할 수 있다. 예를 들면, 메인 컨트롤러는, 오픈된 도어에서부터 기 설정된 사용자 시트까지 시간에 따른 복수의 광원에 대한 순차 점등을 통해, 무빙 라이트를 구현할 수 있다. 4) 시트 조절 서비스 시나리오 제4 시나리오(S114)는, 시트 조절 서비스 시나리오이다. 시트 시스템은, 획득된 신체 정보에 기초하여, 사 용자와 매칭되는 시트의 적어도 하나의 요소를 조절할 수 있다. 5) 개인 컨텐츠 제공 시나리오 제5 시나리오(S115)는, 개인 컨텐츠 제공 시나리오이다. 디스플레이 시스템은, 입력 장치 또는 통신 장치를 통해, 사용자 개인 데이터를 수신할 수 있다. 디스플레이 시스템은, 사용자 개인 데이터에 대 응되는 컨텐츠를 제공할 수 있다. 6) 상품 제공 시나리오 제6 시나리오(S116)는, 상품 제공 시나리오이다. 카고 시스템은, 입력 장치 또는 통신 장치를 통해, 사용자 데이터를 수신할 수 있다. 사용자 데이터는, 사용자의 선호도 데이터 및 사용자의 목적지 데이터 등을 포함할 수 있다. 카고 시스템은, 사용자 데이터에 기초하여, 상품을 제공할 수 있다. 7) 페이먼트 시나리오 제7 시나리오(S117)는, 페이먼트 시나리오이다. 페이먼트 시스템은, 입력 장치, 통신 장치 및 카고 시스템 중 적어도 어느 하나로부터 가격 산정을 위한 데이터를 수신할 수 있다. 페이먼트 시스템 은, 수신된 데이터에 기초하여, 사용자의 차량 이용 가격을 산정할 수 있다. 페이먼트 시스템은, 산 정된 가격으로 사용자(예를 들면, 사용자의 이동 단말기)에 요금 지불을 요청할 수 있다. 8) 사용자의 디스플레이 시스템 제어 시나리오 제8 시나리오(S118)는, 사용자의 디스플레이 시스템 제어 시나리오이다. 입력 장치는, 적어도 어느 하나의 형태로 이루어진 사용자 입력을 수신하여, 전기적 신호로 전환할 수 있다. 디스플레이 시스템은, 전기적 신호에 기초하여, 표시되는 컨텐츠를 제어할 수 있다. 9) AI 에이전트 시나리오 제9 시나리오(S119)는, 복수의 사용자를 위한 멀티 채널 인공지능(artificial intelligence, AI) 에이전트 시 나리오이다. 인공 지능 에이전트는, 복수의 사용자 별로 사용자 입력을 구분할 수 있다. 인공 지능 에이전 트는, 복수의 사용자 개별 사용자 입력이 전환된 전기적 신호에 기초하여, 디스플레이 시스템, 카고 시스템, 시트 시스템 및 페이먼트 시스템 중 적어도 어느 하나를 제어할 수 있다. 10) 복수 사용자를 위한 멀티미디어 컨텐츠 제공 시나리오 제10 시나리오(S120)는, 복수의 사용자를 대상으로 하는 멀티미디어 컨텐츠 제공 시나리오이다. 디스플레이 시 스템은, 모든 사용자가 함께 시청할 수 있는 컨텐츠를 제공할 수 있다. 이경우, 디스플레이 시스템은, 시트별로 구비된 스피커를 통해, 동일한 사운드를 복수의 사용자 개별적으로 제공할 수 있다. 디스플레이 시스템은, 복수의 사용자가 개별적으로 시청할 수 있는 컨텐츠를 제공할 수 있다. 이경우, 디 스플레이 시스템는, 시트별로 구비된 스피커를 통해, 개별적 사운드를 제공할 수 있다. 11) 사용자 안전 확보 시나리오 제11 시나리오(S121)는, 사용자 안전 확보 시나리오이다. 사용자에게 위협이되는 차량 주변 오브젝트 정보를 획 득하는 경우, 메인 컨트롤러는, 디스플레이 시스템을 통해, 차량 주변 오브젝트에 대한 알람이 출력 되도록 제어할 수 있다. 12) 소지품 분실 예방 시나리오 제12 시나리오(S122)는, 사용자의 소지품 분실 예방 시나리오이다. 메인 컨트롤러는, 입력 장치를 통 해, 사용자의 소지품에 대한 데이터를 획득할 수 있다. 메인 컨트롤러는, 입력 장치를 통해, 사용자 의 움직임 데이터를 획득할 수 있다. 메인 컨트롤러는, 소지품에 대한 데이터 및 움직임 데이터에 기초하여, 사용자가 소지품을 두고 하차 하는지 여부를 판단할 수 있다. 메인 컨트롤러는, 디스플레이 시스템 을 통해, 소지품에 관한 알람이 출력되도록 제어할 수 있다. 13) 하차 리포트 시나리오 제13 시나리오(S123)는, 하차 리포트 시나리오이다. 메인 컨트롤러는, 입력 장치를 통해, 사용자의 하차 데이터를 수신할 수 있다. 사용자 하차 이후, 메인 컨트롤러는, 통신 장치를 통해, 사용자의 이 동 단말기에 하차에 따른 리포트 데이터를 제공할 수 있다. 리포트 데이터는, 차량 전체 이용 요금 데이터 를 포함할 수 있다. 컨테이너(container) 컨테이너는 프로그램, 데이터, 및 시스템 라이브러리들을 포함하는 컴퓨터 시스템 인스턴스에서 실행되는 경량 가상화 인스턴스일 수 있다. 컨테이너가 실행될 때, 실행 중인 프로그램(즉, 프로세스)은 동일한 컴퓨터 시스템 인스턴스에서 실행 중인 다른 프로세스와는 독립적으로 실행될 수 있다. 컨테이너들 각각은 자신의 고유한 네임스페이스를 가질 수도 있고, 컨테이너들 내에서 실행되는 애플리케이션들 은 컨테이너 네임스페이스 내에서 이용 가능한 자원들에 대해서만 액세스 가능한 상태일 수 있다. 따라서, 컨테 이너들은 고유의 네임 스페이스 내의 적어도 하나의 단일 애플리케이션을 실행하기 위한 효과적인 방식일 수 있 다. 컨테이너 패키지는, 별도의 사용자 공간 인스턴스를 실행하기 위해 가상 머신들을 시작하고, 유지하는 것에 소 요될 수 있는 오버헤드 없이 적어도 하나의 컨테이너가 단일 동작 인스턴스 내에서 실행되게 할 수 있다. 컨테 이너 패키지의 일예가 도커(Docker) 컨테이너 엔진일 수 있다. 컨테이너는 자바 언어를 이용해서 작성될 수 있고, JSP와 Servlet을 이용하는 응용 프로그램을 실행시킬 수 있 는 소프트웨어로 서블릿 컨테이너일 수 있다. 이와 같은 컨테이너는 Servlet 컨테이너, JSP 컨테이너, EJB 컨테이너 등의 종류가 있으며, 대표적인 컨테이터 로는 자카르타 톰캣(JSP), RESIN, 웹 로직, 웹 투비 등을 포함할 수 있다. 컨테이너는 인터넷 망에서 웹 페이지 를 오픈하거나, 웹 페이지를 저장하는 웹 브라우저 형태일 수도 있다. 컨테이너 엔진은 컨테이너 내에 애플리케이션을 배치시킬 수 있다. 컨테이너 엔진은 도커(Docker)일 수 있으나, 반드시 이에 제한되는 것은 아니다. 도 8은 본 명세서의 일 실시예에 적용될 수 있는 컨테이너 기반의 시스템 아키텍처를 설명하기 위한 도면이다. 도 8을 참조하면, 일반적으로 가상 머신은 운영체제 인스턴스 하나를 구획화(Compartmentalizing)가 필요한 애 플리케이션 각각에 할당하는 방식으로 '분리(Isolation)'를 제공한다. 가상 머신에서의 분리는 거의 완전하게 분리시킬 수 있는 방법이지만, 상당한 비용이 수반된다. 각 운영 인스턴스가 애플리케이션 자체에 더 효과적으 로 할당할 수 있는 메모리와 프로세싱 파워를 소비하기 때문이다. 그러나, 컨테이너의 경우 각 애플리케이션과 종속물이 운영체제 리소스의 분리된 세그먼트를 이용한다. 컨테이 터 런타임(container runtime)은 호스트 운영체제가 제공하는 저 수준의 컨테이터 서비스를 사용하여 컨테이터 를 셋업 하거나 삭제할 수 있다. 컨테이터와 호스트에서 실행되는 다른 프로세스 사이에 벽을 만드는 리눅스 커널 기능 중에 cgoups(control group)과 네임스페이스(namespaces)가 있다. cgroup은 분리, CPU, 메모리 등 프로세스 그룹의 시스템 리소스 사 용량을 관리한다. 네임스페이스는 프로세스 하나의 리소스 분리를 처리하고, cgroup은 프로세스 그룹의 리소스 를 관리한다. cgroup과 네임 스페이스가 결합되면서 리눅스 컨테이너(Linux Container, LXC)가 구현될 수 있다. 리눅스 컨테이너는 단일 호스트에서 여러개로 분리된 리눅스 시스템을 실행시키는 리눅스 운영체제 수준의 가상 화 기법이다. 컨테이너는 운영체제에서 애플리케이션을 분리시킨다. 즉, 사용자가 최소화된 리눅스 운영체제를 운영하면서 다른 모든 것을 하나 이상의 분리된 컨테이너에서 실행시킬 수 있음을 의미한다. 도커는 리눅스 컨테이너에 컨테이너의 이동성과 유연성을 높인다. 도커 컨테이너를 이용하는 경우 가상 머신을 사용했을 때 보다 쉽고 빠르게 워크로드를 배포, 복제, 이동, 백업할 수 있다. 도커는 컨테이너를 실행시킬 수 있는 모든 인프라에 클라우드와 같은 유연성을 제공한다. 도커는 특정 컨테이너에서 실행될 소프트웨어 방식에 대한 '사양'에 해당되는 컨테이너 이미지를 생성한다. 도 커의 컨테이너 이미지 도구를 이용하여 이미지 라이브러리가 빌드되고, 이미지들은 새로운 이미지로 변환될 수 있고, 로컬이나 원격 인프라를 통해 이미지로 앱이 실행될 수 있다. 또한, 도커는 컨테이너 간 동작을 조율하고, 이를 통해 컨테이너를 연결해 애플리케이션 스택을 빌드할 수 있다. 이는 서드 파티 제품들이 제공하는 컨테이너 오케스트레이션(container orchestration) 등으로 발전될 수 있다. 또한 리눅스 컨테이너는 API와 생태계를 구축하여 개발자들이 컨테이너를 보다 다양하게 활용할 수 있는데, 예 를 들어, 자체 런타임인 리브컨테이너(Libcontainer)의 형식으로 개발되었다. 리브컨테이너는 컨테이너에 더욱 다양한 서비스 계층을 제공할 수 있다. 도커는 효율적으로 컨테이너를 생성, 출하, 실행할 수 있는 리눅스나 윈 도우 유틸리티이다. 도 8에서 예시적으로 개시된 애플리케이션(App1,App2,App3) 은 내비게이션, 멀티 미디어, 연결성 (connectivity), 음성 지원(Voice Assistance) 등의 서비스를 지원하기 위한 각각의 컨테이너를 의미할 수 있다. 각 컨테이너는 도커 엔진 위에 빌드되고, 리눅스 커널을 공유하고 있다. 도 9는 본 명세서의 일 실시예에 따라 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법을 구현하기 위 한 개략적인 시스템 구성이다. 도 10 내지 도 11은 본 명세서의 일 실시예에 따라 컨테이너를 업데이트하는 시 퀀스 다이어그램이다. 도 9 내지 도 11을 참조하면, 차량 시스템은 컨테이너 매니저, 오리지널 컨테이너, 업데이트된 컨테이너, 시스템 레지스트리 및 사용자 데이터 레지스트리를 포함할 수 있다. 또한, 차량 시스 템은 클라우드 서버와 무선 통신을 통해 컨테이너 업데이트를 수행할 수 있다. 컨테이너 매니저는 차량 환경에서 실행 가능한 애플리케이션을 구동하기 위한 설정 및 파일을 포함한 독립 된 환경을 제공하는 컨테이너의 운영을 관리한다. 오리지널 컨테이너는 차량에 이미 설치되어 애플리케이 션의 실행을 지원하는 컨테이너이고, 업데이트된 컨테이너는 차량이 컨테이너 업데이트가 필요한 것으로 판단한 경우, 클라우드 서버로부터 새로운 컨테이너 이미지를 다운로드 받아서 레지스트리에 저장해놓은 컨테이 너일 수 있다. 다만, 도 9 내지 도 11에 의하면, 오리지널 컨테이너와 업데이트된 컨테이너가 논리적으로 분리되어 존재하는 것으로 표시하였지만, 오리지널 컨테이너는 업데이트 과정을 거친 후 업데이트된 컨테이너 로서의 역할을 수행하는 관계일 수도 있다. 컨테이너 매니저는 오리지널 컨테이너의 실행을 명령하고, 오리지널 컨테이너는 실행결과를 컨 테이너 매니저로 전달할 수 있다. 컨테이너 매니저는 차량 내부 환경 또는 차량 시스템에 장착된 디바이스 조건, 상기 디바이스의 실행에 필 요한 애플리케이션 조건, 상기 디바이스 상에서 애플리케이션 실행을 위한 소프트웨어 조건 등에 기초하여 오리 지널 컨테이너에 대하여 업데이트의 필요성을 확인할 수 있다. 이를 위해, 컨테이너 매니저는 클라우 드 서버로 업데이트 리스트를 요청할 수 있다. 클라우드 서버는 컨테이너 매니저의 요청에 응답하여 업데이트 리스트를 컨테이너 매니저로 전 달한다. 클라우드 서버는 컨테이너 레지스트리를 포함하고, 상기 컨테이너 레지스트리에는 적어 도 하나의 컨테이너 이미지를 포함할 수 있다. 차량이 클라우드 환경에서 구동됨에 따라 클라우드 서버는 차량 시스템을 제어하는 적어도 하나의 애플리케이션 정보, 차량 시스템 운영에 필요한 업데이트 정보가 실시간 으로 반영되어 저장부에 저장될 수 있다. 상기 차량 시스템의 업데이트 정보 중 컨테이너와 관련된 업데이트 정 보는 컨테이너 레지스트리에 위치할 수 있다. 컨테이너 매니저는 클라우드로 부터 전달받은 업데이트 리스트를 분석하여 오리지널 컨테이너의 업데 이트 필요성을 확인할 수 있다. 컨테이너 매니저는 오리지널 컨테이너의 업데이트가 필요한 것으로 판단한 경우, 클라우드 서버로 업데이트된 컨테이너 이미지를 요청하고, 다운로드 받을 수 있다. 한편, 차량 시스템은 컨테이너 이미지를 저장하기 위한 레지스트리를 포함하는데, 상기 레지스트리는 시스 템 레지스트리(System Registry, 940)와 사용자 데이터 레지스트리(User data Resgisytry, 950)가 구분될 수 있다. 시스템 레지스트리는 컨테이너 이미지를 저장한다. 컨테이너 이미지는 실행되는 컨테이너의 원형으로서, 일반적으로 컨테이너 이미지와 컨테이너는 혼용되어 사용될 수 있으며, 본 명세서에서도 컨테이너 이미지와 컨 테이너는 동일 또는 유사한 개념으로 사용됨을 미리 밝혀둔다. 컨테이너 이미지에 포함된 데이터는 개발자들이 처음부터 세팅해놓은 데이터들이다. 따라서 컨테이너가 업데이트 되더라도 세팅 데이터들은 유지된다. 다만, 개 발자들의 의도에 따라 컨테이너에 포함된 데이터들은 추가되거나 변경될 수도 있다. 한편, 컨테이너는 누적되는 데이터를 보유할 수도 있다. 이는 컨테이너 이미지 내부의 초기 세팅 데이터와는 달리 사용자들의 사용에 의해 생성된 데이터들일 수 있다. 따라서, 본 명세서의 일 실시예에 의하면, 사용자 데이터 레지스트리를 별도로 구비하여, 컨테이너의 실행 중 사용자들의 사용에 의해 누적되는 데이터를 저장할 수 있다. 또한, 시스템 레지스트리는 컨테이너 이미 지가 위치할 수 있으며, 사용자의 사용 데이터와는 무관하며 컨테이너의 업데이트와 관계없이 동일한 컨테이너 이미지가 시스템 레지스트리에 유지될 수 있다. 따라서, 컨테이너 매니저는 클라우드 서버로부터 다운로드 받은 업데이트된 컨테이너 이미지를 시스템 레 지스트리에 저장할 수 있다. 도 9 내지 도 11을 참조하면, 컨테이너 매니저는 오리지널 컨테이너에게 업데이트 준비 요청을 전달 할 수 있다. 오리지널 컨테이너는 상기 업데이트 준비 요청에 응답하여 오리지널 컨테이너의 실행 과 정에서 누적된 사용자 데이터가 업데이트되는 컨테이너에 심리스하게 전달될 수 있도록 커밋(commit) 형태의 사 용자 데이터를 생성하여, 사용자 데이터 레지스트리에 저장할 수 있다. 즉, 컨테이너 매니저는 오리 지널 컨테이너가 업데이트될 필요성이 존재하는 것으로 판단하는 경우, 사용자 데이터가 업데이트될 컨테 이너에서도 연속하여 이용될 수 있도록 오리지널 컨테이너로 하여금 사용자 데이터 커밋을 생성하여 별도 공간에 저장함으로써 업데이트 준비과정을 완료할 수 있다. 컨테이너 매니저는 오리지널 컨테이너의 상기 업데이트 준비완료 상태를 전달받을 수 있다. 컨테이너 매니저는 사용자 데이터와 업데이트될 컨테이너 이미지를 결합함으로써, 업데이트될 컨테이너 내에 기존의 사용자 데이터를 연계함으로써 누적된 사용자 데이터가 심리스하게 이용될 수 있도록 한다. 이를 위해 컨테이너 매니저는 사용자 데이터 레지스트리와 시스템 리지스트리로 부터 호출된 User data commit 및 updated container를 결합한다. 컨테이너 매니저는 상기 결합을 통해 신규 컨테이너를 생성할 수 있다. 본 명세서의 일 실시예에 의하면, 상기 신규 컨테이너가 생성되더라도 컨테이너 업데이트 종료 상태는 아니다. 컨테이너 매니저는 상기 신규 컨테이너를 실행시킨 후, 닉네이 테이블 변경을 통해 컨테이너 업데이터를 종료할 수 있다. 상기 닉네임 테이블은 컨테이너 네임과 컨테이터의 위치를 매핑한 컨테이너 관리 테이블이다. 본 명세서의 일 실시예에 의하면, 오리지널 컨테이너와 업데이트된 컨테이너를 상기 컨테이너 관리 테이블을 통해 관 리함으로써, 데이터 사용자의 심리스한 사용 경험을 보장할 수 있다. 도 10 내지 도 11의 시퀀스 다이어그램을 통해 설명한 컨테이너 업데이트 과정을 이하 필요한 도면들을 통해 보 다 구체적으로 설명한다. 한편, 도 9에 개시된 차량 시스템에 포함된 컨테이너 매니저는 차량 시스템의 프로세서에서 동 일한 기능을 수행할 수도 있다. 또한, 도 9에서는 설명의 편의를 위해 오리지널 컨테이너, 업데이트된 컨 테이너로 구분하여 설명하였으나, 본 문서 전체에서 상기 오리지널 컨테이너를 컨테이너로 호칭하기 로 한다. 또한, 본 문서 전체에서 신규 컨테이너라 함은 업데이트 대상 컨테이너 이미지, 업데이트 대상 컨테이너와 동일 한 의미로 해석이 가능하다. 또한, 신규 컨테이너가 생성된 상태에서 컨테이너 관리 테이블이 변경되면, 상기 신규 컨테이너의 상태를 업데이트된 컨테이너 상태로 정의하기로 한다. 도 12는 본 명세서의 일 실시예에 따라 차량 시스템에서 컨테이너 업데이트 조건의 일 예를 설명하기 위한 도면 이다. 도 12를 참조하면, 차량에 신규 디바이스가 추가되거나, 차량에 장착된 기존 디바이스가 제거될 경우 차량 시스 템은 클라우드로 컨테이너 업데이트를 요청할 수 있다. 또한, 차량 시스템이 클라우드 환경과 연계된 경우 차량에 장착된 디바이스에 대해 업데이트된 펌웨어 (Firmware)가 추가된 경우, 클라우드는 차량으로 상기 펌웨어 업데이트 상태를 전달할 수 있고, 차량 시스템은 클라우드로 컨테이너 업데이트를 요청할 수 있다. 또한, 차량에 장착된 디바이스에서 실행되는 애플리케이션에대하여 업데이트된 애플리케이션이 존재하는 경우, 차량에 장착된 적어도 둘 이상의 디바이스를 이용하는 신규 기능의 애플리케이션이 추가된 경우에도 마찬가지로 클라우드가 차량으로 업데이트 정보를 전달하고, 차량 시스 템은 클라우드로 컨테이너 업데이트를 요청할 수 있다. 또한, 차량 시스템 또는 클라우드 서버에서 업데이트 조건을 감지함으로써, 컨테이너 업데이트가 진행되는 경우 외에, 사용자가 차량에 장착되어 있는 디바이스에 대해 수동으로 특정 버전의 펌웨어(Firmware), 특정 버전의 애플리케이션의 업데이트를 요청함에 따라, 차량 또는 클라우드로 컨테이너 업데이트를 요청하는 동작이 수행될 수도 있다. 업데이트 조건은 전술한 예들로 한정되지 않고 다양한 업데이트 환경을 모두 포함할 수 있음을 밝혀둔다. 도 13은 본 명세서의 일 실시예에 따라 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법의 흐름도이다. 도 14는 차량과 클라우드에 각각 구비한 컨테이너 이미지의 예를 나타낸 도면이다. 도 13에 도시된 방법은 차량 시스템의 프로세서에 의해 구현될 수 있다. 또한, 상기 프로세서는 별도로 구비된 컨테이너 매니저(도 9의 910)를 제어함으로써 상기 방법이 구현될 수도 있다. 이하 설명의 편의를 위해 프로세 서가 컨테이너 매니저의 동작을 수행하는 것으로 설명한다. 도 13을 참조하면, 프로세서는 컨테이너를 실행시킴으로써 차량 시스템 환경과 독립된 환경에서 애플리케이션을 구동되도록 제어할 수 있다(S1300). 도 14에서 차량 시스템에서 구동되는 컨테이너는 적어도 하나의 commit(commit1, commit 2, commit 3)과 러닝 프로세서를 포함할 수 있다. 커밋(commit)은 컨테이너 내부에서 추가, 삭제 및 변경된 사항을 의미할 수 있다. 커밋은 동적으로 생성된 메모 리 정보는 저장되지 않는다. 커밋은 컨테이너 이미지에 저장(append)될 수 있으며, 새로운 이미지로도 저장될 수 있다. 러닝 프로세서는 컨테이너를 구동하여 실행되는 애플리케이션을 의미할 수 있다. 한편, 본 명세서는 차량 시스템에서 업데이트 조건을 디텍트한 후, 클라우드와의 연계를 통해 컨테이너 업데이 트 동작이 이루어지는 경우를 가정하는 바, 클라우드 서버 내에서 상기 차량 시스템의 컨테이너에 포함된 적어 도 하나의 커밋(commit1, commit 2, commit 3)을 모두 포함할 수 있으며, 새로운 commit 4 이 추가된 상태일 수 있다. 프로세서는 컨테이너 업데이트 필요 여부를 모니터링할 수 있다(S1310). 상기 컨테이너 업데이트 필요 여부는 도 12에서 설명한 바와 같이, 프로세서가 미리 정해진 업데이트 조건이 만족됨을 디텍트한 경우 컨테이너 업데 이트가 필요한 것으로 판단할 수 있다. 프로세서는 컨테이너 업데이트가 필요한 것으로 판단한 경우(S1310:Y), 업데이트 대상 컨테이너 이미지(commit 1, commit 2, commit 3, commit 4) 를 클라우드로부터 수신할 수 있다(S1320). 프로세서는 컨테이너에서 생성한 user data commit과 업데이트된 컨테이너를 결합함으로써, 신규 컨테이너를 생 성할 수 있다(S1330). 상기 user data commit 은 사용자 데이터 레지스트리에 저장되어 있으며, 사용자 데이터 레지스트리는 사용자의 데이터 변경사항을 저장하는 컨테이너 이미지의 저장영역일 수 있다. 또한, 업데이트된 컨테이너는 시스템 레지 스트리에 저장되어 있으며, 시스템 레지스트리는 시스템의 데이터 변경사항을 저장하는 컨테이너 이미지 저장영 역일 수 있다. 프로세서는 상기 신규 컨테이너가 기존 컨테이너의 사용자 데이터를 이용할 수 있도록 데이터 연계과정을 수행 할 수 있다. 데이터 연계과정은 컨테이너 관리 테이블을 이용하여 수행될 수 있다. 프로세서는 컨테이너 네임과 소스의 위치를 매핑한 테이블를 활용하여 컨테이너를 업데이트할 수 있다(S1340). *기존의 컨테이너와 업데이트 사항이 포함된 신규 컨테이너가 공존하는 상태에서 두 가지 컨테이너가 각각 독립 적으로 실행되는 경우 업데이트 사항을 차량 시스템에서의 애플리케이션 실행에 반영할 수는 있다. 그러나, 컨 테이너는 각각 서로 독립적인 환경에서 실행되는 바, 기존 컨테이너 실행 후, 신규 컨테이너를 실행하는 경우, 기존 컨테이너의 실행으로 누적된 사용자 데이터를 신규 컨테이너는 이용을 할 수 없게 된다. 차량 시스템은 모 든 장치가 유기적으로 연동되어 있기 때문에 기존 컨테이너가 이용되는 중에 기존 컨테이너의 업데이트 사항을심리스하게 반영하기 위해서는 데이터 연계 중심의 테이블 형식의 관리가 필요할 수 있다. 전술한 테이블을 이 용한 컨테이너 업데이트는 도 22 내지 도 24를 참조하여 보다 구체적으로 설명한다. 도 15는 도 13에 도시된 S1310 과정을 보다 구체적으로 설명하기 위한 흐름도이다. 도 15를 참조하면, 차량 시스템의 프로세서는 컨테이너 업데이트 조건이 만족되는지 여부를 판단할 수 있다 (S1311). 예를 들어, 제1 디바이스가 차량에 장착되어 있고, 제1 컨테이너가 구동되어 제1 애플리케이션이 실행되는 중, 프로세서는 제2 디바이스가 장착됨을 감지할 수 있다. 여기서 제2 디바이스는 제1 디바이스와 다른 디바이스이 며 디바이스 구동을 위해 필요한 제2 컨테이너는 제1 컨테이너와 유사한 기능을 수행하는 업데이트된 버전일 수 있다. 이 경우, 프로세서는 제1 컨테이너가 제2 컨테이너로 업데이트가 되어야 함을 인식할 수 있다. 컨테이너 업데이트 조건에 대해서는 도 12를 통해 구체적으로 설명한 바와 같다. 프로세서는 컨테이너 업데이트 조건이 만족되는 경우, 컨테이너 업데이트 리스트를 클라우드 서버로 요청할 수 있다(S1311). 프로세서는 클라우드로 부터 수신된 컨테이너 업데이트 리스트를 분석하여 업데이트 필요 여부를 판단할 수 있 다(S1312). 상기 컨테이너 업데이트 리스트는 기존 컨테이너에 포함된 commit 정보를 포함할 수 있으며, 기존 컨테이너에 포함된 커밋(commit) 정보 외에 클라우드로 부터 수신된 컨테이너 업데이트 리스트에 추가 또는 변경된 커밋이 존재하는 경우 프로세서는 컨테이너 업데이트가 필요한 것으로 판단할 수 있다. 컨테이너 업데이트가 필요한 것으로 판단되면, 프로세서는 기존 컨테이너의 실행과정에서 생성된 런타임 데이터 를 신규 컨테이너와 연계시킬 수 있다. 도 16은 본 명세서의 일 실시예에 따라 컨테이너 업데이트를 위해 기존 컨테이너의 예시적인 동작을 설명하기 위한 흐름도이다. 도 16을 참조하면, 차량 시스템의 프로세서는 업데이트 대상 컨테이너 이미지를 클라우드 서버로 요청할 수 있 다(S1600). 클라우드 서버는 상기 차량의 요청에 응답하여 클라우드 상의 컨테이너 레지스트리(도 9의 961)에서 차량이 요청한 업데이트 대상 컨테이너 이미지를 탐색할 수 있다. 클라우드 서버는 탐색된 업데이트 대상 컨테 이너 이미지를 차량으로 전송할 수 있다(S1610). 프로세서는 클라우드로부터 수신한 업데이트 대상 컨테이너 이미지를 차량의 시스템 레지스트리에 저장할 수 있 다(S1620). 프로세서는 구동 상태의 컨테이너에서 런타임 대체(Runtime Replace)를 위해 유지되어야 할 데이터를 User data commit 으로 생성할 수 있다(S1630). 상기 User data commit 은 사용자 데이터 레지스트리에 저장될 수 있다. 시스템 레지스트리와 사용자 데이터 레지스트리가 구분되어 있으며, 사용자 데이터 레지스트리에 저장되는 데이 터는 애플리케이션을 사용하면서 생성 및/또는 변경된 데이터들로서, 사용자의 개인정보 또는 구매 내역 등의 정보일 수 있다. 프로세서는 사용자 데이터 레지스트리에 저장된 User data commit 과 시스템 레지스트리에 저장된 업데이트 대 상 컨테이너 이미지를 결합함으로써, 신규 컨테이너를 생성할 수 있다(S1640) 도 17 내지 도 19는 도 16에서 설명한 신규 컨테이너를 생성하는 과정을 설명하기 위함 도면들이다. 도 17을 참조하면, 기존에 구동중인 컨테이너는 런타임 시점에 업데이트 요청을 받을 경우 User data 를 commit 으로 생성할 수 있다. 이에 따라, 기존 컨테이너는 시스템 커밋(system commit)과 User data commit 으로 구분 될 수 있다. 도 18을 참조하면, 기존 컨테이너에서 생성된 User data commit 은 사용자 데이터 레지스트리에 저장될 수 있다. 또한, 업데이트 대상 컨테이너 이미지(commit 1, commit 2, commit 3, commit 4)는 클라우로부터 다운로 드 되어 차량의 시스템 레지스트리에 저장될 수 있다. 도 19를 참조하면, 프로세서는 사용자 데이터 레지스트리에 저장된 User Data Commit 과 시스템 레지스트리에 저장된 시스템 commit 을 결합함으로써, 신규 컨테이너 이미지를 생성할 수 있다. 도 19에 도시된 신규 컨테이 너는 기존 컨테이너에서 생성한 User Data Commit을 그대로 포함하고 있다. User Data Commit 은 파일(File),디렉토리(Directory), 텍스트(text) 형태일 수 있다. 이상, 기존 컨테이너 업데이트를 위해 새로운 컨테이너 이미지를 준비하는 과정을 설명하였다. 이하, 새로운 컨 테이너가 기존 컨테이너의 업데이트로 진행되기 위한 과정을 설명한다. 도 20은 본 명세서의 일 실시예에 따라 컨테이너 업데이트의 다른 과정을 설명하기 위한 흐름도이다. 도 21은 도 20에 도시된 실시예를 설명하기 위한 도면이다. 도 20을 참조하면, 프로세서는 기존 컨테이너의 러닝 프로세스를 신규 컨테이너와 연동시킬 수 있다(S2000). 여 기서 러닝 프로세스(running process)는 기존 컨테이너를 구동하여 실행된 애플리케이션을 의미할 수 있다. 프로세서는 상기 신규 컨테이너의 User Data Commit을 통해 런타임(Runtime) 동기화를 진행할 수 있다(S2010). 프로세서는 상기 신규 컨테이너의 러닝 프로세스를 실행시킬 수 있다(S2020). 예를 들어, 기존 컨테이너의 구동을 통해 애플리케이션을 사용하는 중 사용자의 입력을 통해 컨테이너의 업데이 트가 필요한 것으로 판단한 경우, 프로세서는 상기 사용자의 입력 이전 시점까지의 애플리케이션의 사용으로 생 성된 사용자 데이터는, 신규 컨테이너의 구동을 동일한 애플리케이션이 실행되는 시점과 동기화가 이루어져야 사용자 입장에서는 상기 애플리케이션의 이용에 있어서 심리스한 이용이 가능하게 된다. 사용자 데이터의 심리스한 스위칭 관점을 고려할 때, 사용자 입장에서는 신규 컨테이너가 기존 컨테이너를 그대 로 사용하는 것 처럼 인식될 수 있다. 그러나, 본 명세서의 일 실시예에 의하면, 시스템 백그라운드에서 기존 컨테이너의 복제 및 추가적인 시스템 commit 이 모두 반영된 상태에서, User Data commit을 통해 런타임 데이터 동기화가 완료되는 즉시 신규 컨테이너로의 스위칭 동작이 일어나게 된다. 컨테이너 매니저가 애플리케이션 구 동을 위해 기존 컨테이너에서 신규 컨테이너로 스위칭 동작을 제어할 수 있다. 도 21을 참조하면, 신규 컨테이너 이미지는 기존 컨테이너의 러닝 프로세스가 신규 컨테이너의 구동을 통해 실 행될 수 있도록 한다. 그 과정에서 신규 컨테이너에 포함된 User Data commit 을 이용하여 데이터 동기화가 진 행될 수 있다. 한편, 심리스한 컨테이너 스위칭을 위해 닉네임 테이블이 활용될 수 있다. 기존 컨테이너의 user data commit 이 안정적으로 신규 컨테이너로 전달되고, 신규 컨테이너에서 러닝 프로세서까지 연동이 완료되면, 닉네임 테이 블 변경을 통해 기존 컨테이너에서 수신하던 데이터는 신규 컨테이너로 전달될 수 있다. 여기서 닉네임 테이블 은 컨테이너 관리 테이블로 호칭될 수 있다. 도 22는 본 명세서의 일실시예에 따라 데이터 중심의 컨테이너 업데이트 과정을 설명하기 위한 흐름도이다. 도 23 내지 도 26은 도 22에 도시된 실시예를 설명하기 위한 도면들이다. 도 22를 참조하면, 프로세서는 컨테이너 네임과 소스의 위치를 매핑한 테이블을 이용하여 컨테이너를 업데이트 할 수 있다(도 13 S1340 ). 컨테이너 관리 테이블은 적어도 하나의 컨테이너 이름(Container 1, Container 2, Container 3)와 각 컨테이너 의 소스 주소가 매핑된 테이블일 수 있다. 프로세서는, 클라우드로부터 업데이트 대상 컨테이너 이미지를 수신 하여 시스템 레지스트리에 저장한 경우, 업데이트 대상 컨테이너의 이름(예를 들어, Container 1_rep)과 해당 컨테이너의 소스 주소를 매칭하여 상기 컨테이너 관리 테이블에 추가할 수 있다(도 23 참조). 프로세서는 상기 러닝 프로세서의 연동이 완료되면, 상기 신규 컨테이너의 소스 주소를 상기 컨테이너 네임에 매칭되도록 상기 컨테이너 관리 테이블을 업데이트할 수 있다(S2200). 프로세서는 상기 신규 컨테이너 네임 및 상기 신규 컨테이너 네임에 매칭된 소스 주소를 삭제할 수 있다(S2210) 컨테이너 관리 테이블은 업데이트 대상 컨테이너의 이름(예를 들어, Container 1_rep)을 삭제할 수 있고, 그에 대응되는 소스 주소는 기존 컨테이너(Container 1)로 매핑시킬 수 있다. 따라서, 기존 컨테이너의 소스 주소가 변경될 수 있다(도 24참조). 프로세서는 상기 컨테이너가 업데이트 되기 전의 컨테이너를 삭제할 수 있다. 프로세서는 기존 컨테이너의 구동 을 정지시키고, 컨테이너에 포함된 시스템 커밋을 삭제할 수 있다(도 25참조) 프로세서는 상기 사용자 데이터 레지스트리에 저장된 상기 사용자 데이터 커밋을 삭제할 수 있다(S2220). 프로세서는 사용자 데이터 레지스트리에 저장된 User Data Commit을 삭제함으로써, 기존 컨테이너의 업데이트 동작을 완료할 수 있다. 전술한 본 명세서는, 프로그램이 기록된 매체에 컴퓨터가 읽을 수 있는 코드로서 구현하는 것이 가능하다. 컴퓨 터가 읽을 수 있는 매체는, 컴퓨터 시스템에 의하여 읽혀질 수 있는 데이터가 저장되는 모든 종류의 기록장치를 포함한다. 컴퓨터가 읽을 수 있는 매체의 예로는, HDD(Hard Disk Drive), SSD(Solid State Disk), SDD(Silicon Disk Drive), ROM, RAM, CD-ROM, 자기 테이프, 플로피 디스크, 광 데이터 저장 장치 등이 있으며, 또한 캐리어 웨이브(예를 들어, 인터넷을 통한 전송)의 형태로 구현되는 것도 포함한다. 따라서, 상기의 상세한 설명은 모든 면에서 제한적으로 해석되어서는 아니되고 예시적인 것으로 고려되어야 한다. 본 명세서의 범위는 첨부된 청구 항의 합리적 해석에 의해 결정되어야 하고, 본 명세서의 등가적 범위 내에서의 모든 변경은 본 발명의 범위에 포함된다."}
{"patent_id": "10-2024-7041816", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 명세서 실시예에 따른 차량을 도시한 도면이다. 도 2는 본 명세서의 실시예에 따른 차량의 제어 블럭도이다. 도 3은 본 명세서의 실시예에 따른 자율 주행 장치의 제어 블럭도이다. 도 4는 본 명세서의 실시예에 따른 자율 주행 차량의 신호 흐름도이다. 도 5는 본 명세서의 실시예에 따른 차량의 내부를 도시한 도면이다. 도 6은 본 명세서의 실시예에 따른 차량용 캐빈 시스템을 설명하는데 참조되는 블럭도이다. 도 7은 본 명세서의 실시예에 따라 사용자의 이용 시나리오를 설명하는데 참조되는 도면이다. 도 8은 본 명세서의 일 실시예에 적용될 수 있는 컨테이너 기반의 시스템 아키텍처를 설명하기 위한 도면이다. 도 9는 본 명세서의 일 실시예에 따라 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법을 구현하기 위 한 개략적인 시스템 구성이다. 도 10 내지 도 11은 본 명세서의 일 실시예에 따라 컨테이너를 업데이트하는 시퀀스 다이어그램이다. 도 12는 본 명세서의 일 실시예에 따라 차량 시스템에서 컨테이너 업데이트 조건의 일 예를 설명하기 위한 도면 이다. 도 13은 본 명세서의 일 실시예에 따라 컨테이너 기반의 차량 시스템에서 컨테이너 업데이트 방법의 흐름도이다. 도 14는 차량과 클라우드에 각각 구비한 컨테이너 이미지의 예를 나타낸 도면이다.도 15는 도 13에 도시된 S1310 과정을 보다 구체적으로 설명하기 위한 흐름도이다. 도 16은 본 명세서의 일 실시예에 따라 컨테이너 업데이트를 위해 기존 컨테이너의 예시적인 동작을 설명하기 위한 흐름도이다. 도 17 내지 도 19는 도 16에서 설명한 신규 컨테이너를 생성하는 과정을 설명하기 위함 도면들이다. 도 20은 본 명세서의 일 실시예에 따라 컨테이너 업데이트의 다른 과정을 설명하기 위한 흐름도이다. 도 21은 도 20에 도시된 실시예를 설명하기 위한 도면이다. 도 22는 본 명세서의 일실시예에 따라 데이터 중심의 컨테이너 업데이트 과정을 설명하기 위한 흐름도이다. 도 23 내지 도 26은 도 22에 도시된 실시예를 설명하기 위한 도면들이다."}
