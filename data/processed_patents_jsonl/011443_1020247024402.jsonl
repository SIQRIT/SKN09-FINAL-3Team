{"patent_id": "10-2024-7024402", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0116856", "출원번호": "10-2024-7024402", "발명의 명칭": "포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법, 장치 및 저장매체", "출원인": "항저우 히크로봇 씨오., 엘티디.", "발명자": "후 징샹"}}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법으로서, 상기 포그라운드 및 백그라운드 분리 시스템은 포그라운드 및 백그라운드를 포함하고, 상기 포그라운드에는 상호작용 인터페이스가 표시되어 있으며, 상기 상호작용 인터페이스는 복수 개의 모듈을 표시하는 데에 사용되고,상기 백그라운드에는 데이터 센터가 구성되어 있으며, 상기 데이터 센터는 각 상기 복수 개의 모듈의 모듈 데이터를 저장하는 데에 사용되고, 상기 모듈 데이터에는 상기 모듈의 표시 방식, 상기 모듈의 기능 데이터 및 상기모듈과 각 기타 모듈 사이의 논리적 관계가 포함되고; 상기 방법은: 타깃 모듈에 대한 타깃 조작에 응답하여, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 데이터를 업데이트하고, 상기 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트하는 단계 - 상기타깃 모듈은 상기 복수 개의 모듈 중 하나 또는 복수 개의 모듈임 -; 상기 타깃 조작에 대한 언두(undo) 명령을 검출한 경우, 상기 포그라운드가 상기 언두 명령에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 회복하게 하고, 상기 포그라운드가 회복 후의 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트하는 단계를 포함하는 것을 특징으로 하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 포그라운드가 상기 언두 명령에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 회복하게 한 후, 상기 방법은: 상기 타깃 조작에 대한 리두(redo) 명령을 검출할 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 상기 데이터를 업데이트하게 하고, 상기 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를업데이트하는 단계를 더 포함하는 것을 특징으로 하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항 또는 제2항에 있어서, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃모듈에 대응하는 상기 데이터를 업데이트하는 단계는: 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하고, 상기 하나 또는 복수 개의 제1 데이터 업데이트 명령 중 임의의 제1 데이터 업데이트 명령이 상기 백그라운드를 지시하여 상기 타깃 모듈에 대응하는 데이터 중의 일부 데이터를 업데이트하게 하는 단계; 상기 포그라운드가 상기 하나 또는 복수 개의 데이터 업데이트 명령을 전송하는 것에 기초하여 조작 기록을 생성하는 단계를 포함하고; 상기 포그라운드가 상기 언두 명령에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 회복하는 단계는: 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제2 데이터 업데이트 명령을 전송하고, 상기 하나 또는 복수 개의 제2 데이터 업데이트 명령 중임의의 제2 데이터 업데이트 명령이 상기 백그라운드를 지시하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하공개특허 10-2024-0116856-3-는 상기 데이터 중 상기 일부 데이터를 상기 타깃 조작을 수행하기 전의 상태로 회복하게 하는 것을 특징으로하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 추가 조작일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 먼저 상기 백그라운드로 제1 모듈 업데이트 명령을 전송하고, 다시 제1 논리적 관계 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터에 상기 타깃 모듈의 상기 모듈 데이터를 추가하게 하고, 다시 각 상기 기타 모듈의 상기 모듈 데이터에 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 추가하게 하는 단계를 포함하고; 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제2 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 먼저 상기 백그라운드로 제2 논리적 관계 업데이트 명령을 전송하고, 다시 제2 모듈 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 삭제하고, 다시 상기 데이터 센터 내의상기 타깃 모듈의 상기 모듈 데이터를 삭제하게 하는 단계를 포함하는 것을 특징으로 하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제3항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데이터중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 삭제하게 하고, 다시 상기 데이터 센터 내의상기 타깃 모듈의 상기 모듈 데이터를 삭제하게 하는 단계를 포함하고; 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제2 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 먼저 상기 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터를 회복하게 하고, 다시 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 논리적 관계를 회복하게 하는 단계를 포함하는 것을 특징으로 하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서, 상기 포그라운드가 먼저 백그라운드로 상기 제1 논리적 관계 업데이트 명령을 전송하고, 다시 상기 제1 모듈 업데이트 명령을 전송하기 전에, 상기 방법은: 상기 포그라운드가 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를익스포트(export)하여 참조 저장 위치로 백업(backup)하게 하는 단계 - 상기 타깃 모듈에 대응하는 상기 데이터가 상기 타깃 모듈의 모듈 데이터, 및 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타모듈 사이의 상기 논리적 관계를 포함함 -;를 더 포함하고; 상기 포그라운드가 먼저 상기 백그라운드로 상기 제2 모듈 업데이트 명령을 전송하고, 다시 상기 제2 논리적 관계 업데이트 명령을 전송한 후, 상기 방법은: 공개특허 10-2024-0116856-4-수신된 상기 제2 모듈 업데이트 명령에 응답하여, 상기 백그라운드가 상기 참조 저장 위치로부터 상기 타깃 모듈의 상기 모듈 데이터를 상기 데이터 센터로 임포트(import)하고, 수신된 상기 제2 논리적 관계 업데이트 명령에 응답하여, 상기 백그라운드가 상기 참조 저장 위치로부터 상기 타깃 모듈과 각 상기 기타 모듈 사이의 상기논리적 관계를 상기 데이터 센터로 임포트하는 단계를 더 포함하는 것을 특징으로 하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제3항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 상기 제1 논리적 관계 업데이트 명령을 수신할 경우 상기 데이터센터의 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 상기 타깃 모듈 사이의 상기 논리적 관계를삭제하게 하고, 또한 상기 백그라운드를 제어하여 상기 제1 모듈 업데이트 명령을 수신할 경우, 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터에 삭제 표기를 추가하게 하는 단계를 포함하고; 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제2 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 먼저 상기 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 상기 제2 모듈 업데이트 명령을 수신할 경우 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터의 상기 삭제 표기를 삭제하게 하고, 또한 상기 백그라운드를 제어하여 상기 제2 논리적 관계 업데이트 명령을 수신할 경우 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈데이터에 상기 기타 모듈과 상기 타깃 모듈 사이의 상기 논리적 관계를 추가하게 하는 단계를 포함하는 것을 특징으로 하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항 내지 제3항 중 어느 한 항에 있어서, 상기 모듈과 각 상기 기타 모듈 사이의 상기 논리적 관계는 상기 모듈과 각 상기 기타 모듈 사이의 연결 관계,및 상기 모듈과 각 상기 기타 모듈 사이의 구독 관계를 포함하고; 상기 연결 관계가 상기 상호작용 인터페이스 상 상기 모듈과 각 상기 기타 모듈 사이의 선 연결 관계를 가리키고, 상기 구독 관계가 상기 모듈의 내부 파라미터, 입력 중 적어도 하나와 각 상기 기타 모듈의 출력 사이의 연관관계, 및/또는, 상기 모듈의 출력과 각 상기 기타 모듈의 내부 파라미터 또는 입력 중 적어도 하나와의 사이의연관 관계를 가리키는 것을 특징으로 하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 복수 개의 제1 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 상기 백그라운드로 제1 구독 관계 삭제 명령을 전송하는 단계 - 상기 제1 구독 관계 삭제 명령은 상기 백그라운드가 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 엣지(edge) 타깃 모듈 사이의 구독 관계를 삭제하는 것을 지시하고, 상기 엣지 타깃 모듈이 상기 복수 개의 타깃 모듈 중 상기 기타 모듈과 논리적 관계가 존재하는 타깃 모듈임 -; 상기 포그라운드가 상기 백그라운드로 제1 연결 관계 삭제 명령을 전송하는 단계 - 상기 제1 연결 관계 삭제 명령은 상기 백그라운드가 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 상기 엣지 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시함-; 공개특허 10-2024-0116856-5-상기 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송하는 단계 - 상기 제1 모듈 삭제 명령은 상기백그라운드가 상기 복수 개의 타깃 모듈의 상기 모듈 데이터를 삭제하는 것을 지시함 -;를 포함하는 것을 특징으로 하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제8항에 있어서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 복수 개의 제1 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 A를 전송하는 단계 - 상기 구독 관계 삭제 명령 A는상기 백그라운드가 각 상기 타깃 모듈에 대해, 후에 수행하는 모듈 각각과 먼저 수행하는 모듈 및 상기 타깃 모듈 사이의 구독 관계를 삭제하는 것을 지시하고, 상기 후에 수행하는 모듈이 상기 포그라운드에 표시된 흐름도중 상기 타깃 모듈 후에 수행되는 모듈이며, 상기 먼저 수행하는 모듈이 흐름도 중 상기 타깃 모듈 전에 수행되는 모듈임 -; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 B를 전송하는 단계 - 상기 구독 관계 삭제 명령 B는상기 백그라운드가 상기 복수 개의 타깃 모듈 사이의 구독 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 C를 전송하는 단계 - 상기 구독 관계 삭제 명령 C는상기 백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 구독 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 A를 전송하는 단계 - 상기 연결 관계 삭제 명령 A는상기 백그라운드가 상기 후에 수행하는 모듈 각각과 각 상기 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 B를 전송하는 단계 - 상기 연결 관계 삭제 명령 B는상기 백그라운드가 상기 복수 개의 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 C를 전송하는 단계 - 상기 연결 관계 삭제 명령 C는상기 백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 연결 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송하는 단계 - 상기 제1 모듈 삭제 명령은 상기복수 개의 타깃 모듈의 상기 모듈 데이터 중 나머지 데이터를 삭제하는 것을 지시함 -;를 포함하는 것을 특징으로 하는 모듈 처리 방법."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치로서, 상기 포그라운드 및 백그라운드 분리 시스템은 포그라운드 및 백그라운드를 포함하고, 상기 포그라운드에는 상호작용 인터페이스가 표시되어 있으며, 상기 상호작용 인터페이스는 복수 개의 모듈을 표시하는 데에 사용되고,상기 백그라운드에는 데이터 센터가 구성되어 있으며, 상기 데이터 센터는 각 상기 복수 개의 모듈의 모듈 데이터를 저장하는 데에 사용되고, 상기 모듈 데이터에는 상기 모듈의 표시 방식, 상기 모듈의 기능 데이터 및 상기모듈과 각 기타 모듈 사이의 논리적 관계가 포함되고; 상기 장치는 제1 제어 모듈, 제2 제어 모듈을 포함하고: 상기 제1 제어 모듈은, 타깃 모듈에 대한 타깃 조작에 응답하여, 상기 포그라운드가 상기 타깃 조작에 기초하여상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 데이터를 업데이트하게 하고,상기 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트하게 하는 데에 사용되고, 상기 타깃 모듈이 상기 복수 개의 모듈 중 하나 또는 복수 개의 모듈임; 상기 제2 제어 모듈은, 상기 타깃 조작에 대한 언두 명령을 검출한 경우, 상기 포그라운드가 상기 언두 명령에기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 회복하게하고, 또한 상기 포그라운드가 회복 후의 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용인터페이스를 업데이트하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치.공개특허 10-2024-0116856-6-청구항 12 제11항에 있어서, 제3 제어 모듈을 더 포함하고, 상기 제3 제어 모듈은, 상기 타깃 조작에 대한 리두 명령을 검출할 경우, 상기 포그라운드가 상기 타깃 조작에기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 상기 데이터를 업데이트하게 하고, 상기 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제11항 또는 제12항에 있어서, 상기 제1 제어 모듈은: 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하게 하고, 상기 하나 또는 복수 개의 제1 데이터 업데이트 명령 중 임의의 제1 데이터 업데이트 명령이 상기 백그라운드를 지시하여 상기 타깃 모듈에 대응하는 데이터 중의 일부 데이터를 업데이트하게 하고; 상기 포그라운드가 상기 하나 또는 복수 개의 데이터 업데이트 명령을 전송하는 것에 기초하여 조작 기록을 생성하게 하는 데에 사용되며; 상기 제2 제어 모듈은: 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제2 데이터 업데이트 명령을 전송하게 하고, 상기 하나 또는 복수 개의 제2 데이터 업데이트 명령중 임의의 제2 데이터 업데이트 명령이 상기 백그라운드를 지시하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터 중 상기 일부 데이터를 상기 타깃 조작을 수행하기 전의 상태로 회복하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 추가 조작일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 먼저 상기 백그라운드로 제1 모듈 업데이트 명령을 전송하고, 다시 제1 논리적 관계 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터에 상기 타깃 모듈의 상기 모듈 데이터를 추가하게 하고, 다시 상기 각 기타 모듈의 상기 모듈 데이터에 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 추가하게 하는 데에 사용되고; 상기 제2 제어 모듈이: 상기 포그라운드가 먼저 상기 백그라운드로 제2 논리적 관계 업데이트 명령을 전송하고, 다시 제2 모듈 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 삭제하게 하고, 다시 상기 데이터 센터내의 상기 타깃 모듈의 상기 모듈 데이터를 삭제하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제13항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터 내의 상기 각 기타 모듈의 상기 모듈 데이공개특허 10-2024-0116856-7-터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 삭제하게 하고, 다시 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터를 삭제하게 하는 데에 사용되며; 상기 제2 제어 모듈이: 상기 포그라운드가 먼저 상기 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터를 회복하게 하고, 다시 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 논리적 관계를 회복하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제13항에 있어서, 익스포트 모듈 및 임포트 모듈을 더 포함하고: 상기 익스포트 모듈이 상기 포그라운드가 먼저 백그라운드로 상기 제1 논리적 관계 업데이트 명령을 전송하고,다시 상기 제1 모듈 업데이트 명령을 전송하기 전에, 상기 포그라운드가 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 익스포트하여 참조 저장 위치로 백업하게 하는 데에 사용되며, 상기 타깃 모듈에 대응하는 상기 데이터가 상기 타깃 모듈의 모듈 데이터, 및 각 기타 모듈의 상기 모듈데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 포함하고; 상기 임포트 모듈이 상기 포그라운드가 먼저 상기 백그라운드로 상기 제2 모듈 업데이트 명령을 전송하고, 다시상기 제2 논리적 관계 업데이트 명령을 전송한 후, 수신된 제2 모듈 업데이트 명령에 응답하여, 상기 백그라운드가 상기 참조 저장 위치로부터 상기 타깃 모듈의 상기 모듈 데이터를 상기 데이터 센터로 임포트하게 하고,수신된 상기 제2 논리적 관계 업데이트 명령에 응답하여, 상기 백그라운드가 상기 참조 저장 위치로부터 상기타깃 모듈과 각 상기 기타 모듈 사이의 상기 논리적 관계를 상기 데이터 센터로 임포트하게 하는 데에 사용되는것을 특징으로 하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제13항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 상기 제1 논리적 관계 업데이트 명령을 수신할 경우 상기 데이터센터의 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 상기 타깃 모듈 사이의 상기 논리적 관계를삭제하게 하고, 또한 상기 백그라운드를 제어하여 상기 제1 모듈 업데이트 명령을 수신할 경우, 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터에 삭제 표기를 추가하게 하는 데에 사용되고; 상기 제2 제어 모듈이: 상기 포그라운드가 먼저 상기 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 상기 제2 모듈 업데이트 명령을 수신할 경우 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터의 상기 삭제 표기를 삭제하게 하고, 또한 상기 백그라운드를 제어하여 상기 제2 논리적 관계 업데이트 명령을 수신할 경우 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈데이터에 상기 기타 모듈과 상기 타깃 모듈 사이의 상기 논리적 관계를 추가하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제11항 내지 제13항 중 어느 한 항에 있어서, 상기 모듈과 각 상기 기타 모듈 사이의 상기 논리적 관계는 상기 모듈과 각 상기 기타 모듈 사이의 연결 관계,및 상기 모듈과 각 상기 기타 모듈 사이의 구독 관계를 포함하고; 상기 연결 관계가 상기 상호작용 인터페이스 상 상기 모듈과 각 상기 기타 모듈 사이의 선 연결 관계를 가리키공개특허 10-2024-0116856-8-고, 상기 구독 관계가 상기 모듈의 내부 파라미터, 입력 중 적어도 하나와 각 상기 기타 모듈의 출력 사이의 연관관계, 및/또는, 상기 모듈의 출력과 각 상기 기타 모듈의 내부 파라미터 또는 입력 중 적어도 하나와의 사이의연관 관계를 가리키는 것을 특징으로 하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 상기 백그라운드로 제1 구독 관계 삭제 명령을 전송하고 - 상기 제1 구독 관계 삭제 명령은상기 백그라운드가 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 엣지 타깃 모듈 사이의 구독 관계를 삭제하는 것을 지시하고, 상기 엣지 타깃 모듈이 상기 복수 개의 타깃 모듈 중 상기 기타 모듈과 논리적관계가 존재하는 타깃 모듈임 -; 상기 포그라운드가 상기 백그라운드로 제1 연결 관계 삭제 명령을 전송하고 - 상기 제1 연결 관계 삭제 명령은상기 백그라운드가 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 상기 엣지 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송 - 상기 제1 모듈 삭제 명령은 상기 백그라운드가 상기 복수 개의 타깃 모듈의 상기 모듈 데이터를 삭제하는 것을 지시함 -;하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제18항에 있어서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 A를 전송하고, 상기 구독 관계 삭제 명령 A는 상기백그라운드가 각 상기 타깃 모듈에 대해, 후에 수행하는 모듈 각각과 먼저 수행하는 모듈 및 상기 타깃 모듈 사이의 구독 관계를 삭제하는 것을 지시하며, 상기 후에 수행하는 모듈이 상기 포그라운드에 표시된 흐름도 중 상기 타깃 모듈 후에 수행되는 모듈이고, 상기 먼저 수행하는 모듈이 흐름도 중 상기 타깃 모듈 전에 수행되는 모듈이며; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 B를 전송하고, 상기 구독 관계 삭제 명령 B는 상기백그라운드가 상기 복수 개의 타깃 모듈 사이의 구독 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 C를 전송하고, 상기 구독 관계 삭제 명령 C는 상기백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 구독 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 A를 전송하고, 상기 연결 관계 삭제 명령 A는 상기백그라운드가 상기 후에 수행하는 모듈 각각과 각 상기 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 B를 전송하고, 상기 연결 관계 삭제 명령 B는 상기백그라운드가 상기 복수 개의 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 C를 전송하고, 상기 연결 관계 삭제 명령 C는 상기백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 연결 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송하고, 상기 제1 모듈 삭제 명령은 상기 복수개의 타깃 모듈의 상기 모듈 데이터 중 나머지 데이터를 삭제하는 것을 지시하는 데에 사용되는 것을 특징으로하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치로서, 프로세서; 공개특허 10-2024-0116856-9-프로세서 실행가능 명령을 저장하기 위한 메모리를 포함하고; 상기 프로세서가 상술한 제1항 내지 제10항 중 어느 한 항에 따른 상기 방법의 단계를 수행하도록 구성되는 것을 특징으로 하는 모듈 처리 장치."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "비휘발성 컴퓨터 판독가능 저장매체로서, 상기 컴퓨터 판독가능 저장매체에 명령이 저장되어 있고, 상기 명령이 프로세서에 의해 실행될 경우, 상술한 제1항 내지 제10항 중 어느 한 항에 따른 상기 방법의 단계를 구현하는 것을 특징으로 하는 컴퓨터 판독가능 저장매체."}
{"patent_id": "10-2024-7024402", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "명령을 포함하는 컴퓨터 프로그램 제품으로서, 상기 명령이 컴퓨터에서 실행될 경우, 상기 컴퓨터가 상술한 제1항 내지 제10항 중 어느 한 항에 따른 상기 방법의 단계를 실행하게 하는 것을 특징으로 하는 컴퓨터 프로그램 제품."}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 출원의 실시예는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법, 장치 및 저장매체를 개 시하며, 컴퓨터"}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "에 속한다. 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템 중, 백그라운드의 데이터 센터 내에 저장된 각 모듈의 모듈 데이터는 모듈의 표시 방식, 모듈의 기능 데이터 및 모듈 (뒷면에 계속) 대 표 도 - 도2"}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 2, "content": "공개특허10-2024-0116856 사이의 논리적 관계를 포함하는 바, 즉 백그라운드에 포그라운드 데이터 및 백그라운드 데이터를 동시에 저장한 다. 본 출원의 실시예에서, 백그라운드를 전체 데이터의 데이터 센터로 이용한다. 이러한 방법으로, 포그라운드 가 타깃 모듈에 대한 타깃 조작을 검출할 경우, 백그라운드를 제어하여 포그라운드 및 백그라운드 데이터를 업데 이트하게 할 수 있고, 타깃 조작을 취소할 경우, 마찬가지로 백그라운드를 제어하여 포그라운드 및 백그라운드 데이터를 업데이트하게 함으로써, 타깃 조작을 실행하거나 또는 타깃 조작을 언두하는 과정 중 포그라운드 상호 작용 인터페이스 상에 표시된 내용, 및 포그라운드 및 백그라운드 데이터 사이의 일관성을 확보할 수 있다. CPC특허분류 G06F 16/252 (2019.01) G06F 3/0482 (2022.01)명 세 서 청구범위 청구항 1 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법으로서, 상기 포그라운드 및 백그라운드 분리 시스템은 포그라운드 및 백그라운드를 포함하고, 상기 포그라운드에는 상 호작용 인터페이스가 표시되어 있으며, 상기 상호작용 인터페이스는 복수 개의 모듈을 표시하는 데에 사용되고, 상기 백그라운드에는 데이터 센터가 구성되어 있으며, 상기 데이터 센터는 각 상기 복수 개의 모듈의 모듈 데이 터를 저장하는 데에 사용되고, 상기 모듈 데이터에는 상기 모듈의 표시 방식, 상기 모듈의 기능 데이터 및 상기 모듈과 각 기타 모듈 사이의 논리적 관계가 포함되고; 상기 방법은: 타깃 모듈에 대한 타깃 조작에 응답하여, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제 어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 데이터를 업데이트하고, 상기 포그라운드가 업데이트 된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트하는 단계 - 상기 타깃 모듈은 상기 복수 개의 모듈 중 하나 또는 복수 개의 모듈임 -; 상기 타깃 조작에 대한 언두(undo) 명령을 검출한 경우, 상기 포그라운드가 상기 언두 명령에 기초하여 상기 백 그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 회복하게 하고, 상기 포그 라운드가 회복 후의 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트 하는 단계를 포함하는 것을 특징으로 하는 모듈 처리 방법. 청구항 2 제1항에 있어서, 상기 포그라운드가 상기 언두 명령에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모 듈에 대응하는 상기 데이터를 회복하게 한 후, 상기 방법은: 상기 타깃 조작에 대한 리두(redo) 명령을 검출할 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백 그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 상기 데이터를 업데이트하게 하고, 상 기 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트하는 단계를 더 포함하는 것을 특징으로 하는 모듈 처리 방법. 청구항 3 제1항 또는 제2항에 있어서, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 상기 데이터를 업데이트하는 단계는: 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명 령을 전송하고, 상기 하나 또는 복수 개의 제1 데이터 업데이트 명령 중 임의의 제1 데이터 업데이트 명령이 상 기 백그라운드를 지시하여 상기 타깃 모듈에 대응하는 데이터 중의 일부 데이터를 업데이트하게 하는 단계; 상기 포그라운드가 상기 하나 또는 복수 개의 데이터 업데이트 명령을 전송하는 것에 기초하여 조작 기록을 생 성하는 단계를 포함하고; 상기 포그라운드가 상기 언두 명령에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모 듈에 대응하는 상기 데이터를 회복하는 단계는: 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또 는 복수 개의 제2 데이터 업데이트 명령을 전송하고, 상기 하나 또는 복수 개의 제2 데이터 업데이트 명령 중 임의의 제2 데이터 업데이트 명령이 상기 백그라운드를 지시하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터 중 상기 일부 데이터를 상기 타깃 조작을 수행하기 전의 상태로 회복하게 하는 것을 특징으로 하는 모듈 처리 방법. 청구항 4 제3항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 추가 조작일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명 령을 전송하는 단계는: 상기 포그라운드가 먼저 상기 백그라운드로 제1 모듈 업데이트 명령을 전송하고, 다시 제1 논리적 관계 업데이 트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터에 상기 타깃 모듈의 상기 모듈 데이터 를 추가하게 하고, 다시 각 상기 기타 모듈의 상기 모듈 데이터에 상기 타깃 모듈과 상기 기타 모듈 사이의 상 기 논리적 관계를 추가하게 하는 단계를 포함하고; 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또 는 복수 개의 제2 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 먼저 상기 백그라운드로 제2 논리적 관계 업데이트 명령을 전송하고, 다시 제2 모듈 업데이 트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데 이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 삭제하고, 다시 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터를 삭제하게 하는 단계를 포함하는 것을 특징으로 하는 모듈 처리 방법. 청구항 5 제3항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명 령을 전송하는 단계는: 상기 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명 령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 삭제하게 하고, 다시 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터를 삭제하게 하는 단계를 포함하고; 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또 는 복수 개의 제2 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 먼저 상기 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이 트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데 이터를 회복하게 하고, 다시 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이 의 논리적 관계를 회복하게 하는 단계를 포함하는 것을 특징으로 하는 모듈 처리 방법. 청구항 6 제5항에 있어서, 상기 포그라운드가 먼저 백그라운드로 상기 제1 논리적 관계 업데이트 명령을 전송하고, 다시 상기 제1 모듈 업 데이트 명령을 전송하기 전에, 상기 방법은: 상기 포그라운드가 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 익스포트(export)하여 참조 저장 위치로 백업(backup)하게 하는 단계 - 상기 타깃 모듈에 대응하는 상기 데이터 가 상기 타깃 모듈의 모듈 데이터, 및 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 포함함 -;를 더 포함하고; 상기 포그라운드가 먼저 상기 백그라운드로 상기 제2 모듈 업데이트 명령을 전송하고, 다시 상기 제2 논리적 관 계 업데이트 명령을 전송한 후, 상기 방법은: 수신된 상기 제2 모듈 업데이트 명령에 응답하여, 상기 백그라운드가 상기 참조 저장 위치로부터 상기 타깃 모 듈의 상기 모듈 데이터를 상기 데이터 센터로 임포트(import)하고, 수신된 상기 제2 논리적 관계 업데이트 명령 에 응답하여, 상기 백그라운드가 상기 참조 저장 위치로부터 상기 타깃 모듈과 각 상기 기타 모듈 사이의 상기 논리적 관계를 상기 데이터 센터로 임포트하는 단계를 더 포함하는 것을 특징으로 하는 모듈 처리 방법. 청구항 7 제3항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명 령을 전송하는 단계는: 상기 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명 령을 전송하여, 상기 백그라운드를 제어하여 상기 제1 논리적 관계 업데이트 명령을 수신할 경우 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 상기 타깃 모듈 사이의 상기 논리적 관계를 삭제하게 하고, 또한 상기 백그라운드를 제어하여 상기 제1 모듈 업데이트 명령을 수신할 경우, 상기 데이터 센 터 내의 상기 타깃 모듈의 상기 모듈 데이터에 삭제 표기를 추가하게 하는 단계를 포함하고; 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또 는 복수 개의 제2 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 먼저 상기 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이 트 명령을 전송하여, 상기 백그라운드를 제어하여 상기 제2 모듈 업데이트 명령을 수신할 경우 상기 데이터 센 터 내의 상기 타깃 모듈의 상기 모듈 데이터의 상기 삭제 표기를 삭제하게 하고, 또한 상기 백그라운드를 제어 하여 상기 제2 논리적 관계 업데이트 명령을 수신할 경우 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데이터에 상기 기타 모듈과 상기 타깃 모듈 사이의 상기 논리적 관계를 추가하게 하는 단계를 포함하는 것을 특 징으로 하는 모듈 처리 방법. 청구항 8 제1항 내지 제3항 중 어느 한 항에 있어서, 상기 모듈과 각 상기 기타 모듈 사이의 상기 논리적 관계는 상기 모듈과 각 상기 기타 모듈 사이의 연결 관계, 및 상기 모듈과 각 상기 기타 모듈 사이의 구독 관계를 포함하고; 상기 연결 관계가 상기 상호작용 인터페이스 상 상기 모듈과 각 상기 기타 모듈 사이의 선 연결 관계를 가리키 고, 상기 구독 관계가 상기 모듈의 내부 파라미터, 입력 중 적어도 하나와 각 상기 기타 모듈의 출력 사이의 연관 관계, 및/또는, 상기 모듈의 출력과 각 상기 기타 모듈의 내부 파라미터 또는 입력 중 적어도 하나와의 사이의 연관 관계를 가리키는 것을 특징으로 하는 모듈 처리 방법. 청구항 9 제8항에 있어서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 복 수 개의 제1 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 상기 백그라운드로 제1 구독 관계 삭제 명령을 전송하는 단계 - 상기 제1 구독 관계 삭제 명 령은 상기 백그라운드가 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 엣지(edge) 타깃 모듈 사 이의 구독 관계를 삭제하는 것을 지시하고, 상기 엣지 타깃 모듈이 상기 복수 개의 타깃 모듈 중 상기 기타 모 듈과 논리적 관계가 존재하는 타깃 모듈임 -; 상기 포그라운드가 상기 백그라운드로 제1 연결 관계 삭제 명령을 전송하는 단계 - 상기 제1 연결 관계 삭제 명 령은 상기 백그라운드가 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 상기 엣지 타깃 모듈 사이 의 연결 관계를 삭제하는 것을 지시함-; 상기 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송하는 단계 - 상기 제1 모듈 삭제 명령은 상기 백그라운드가 상기 복수 개의 타깃 모듈의 상기 모듈 데이터를 삭제하는 것을 지시함 -;를 포함하는 것을 특징 으로 하는 모듈 처리 방법. 청구항 10 제8항에 있어서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 복 수 개의 제1 데이터 업데이트 명령을 전송하는 단계는: 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 A를 전송하는 단계 - 상기 구독 관계 삭제 명령 A는 상기 백그라운드가 각 상기 타깃 모듈에 대해, 후에 수행하는 모듈 각각과 먼저 수행하는 모듈 및 상기 타깃 모 듈 사이의 구독 관계를 삭제하는 것을 지시하고, 상기 후에 수행하는 모듈이 상기 포그라운드에 표시된 흐름도 중 상기 타깃 모듈 후에 수행되는 모듈이며, 상기 먼저 수행하는 모듈이 흐름도 중 상기 타깃 모듈 전에 수행되 는 모듈임 -; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 B를 전송하는 단계 - 상기 구독 관계 삭제 명령 B는 상기 백그라운드가 상기 복수 개의 타깃 모듈 사이의 구독 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 C를 전송하는 단계 - 상기 구독 관계 삭제 명령 C는 상기 백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 구독 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 A를 전송하는 단계 - 상기 연결 관계 삭제 명령 A는 상기 백그라운드가 상기 후에 수행하는 모듈 각각과 각 상기 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시 함 -; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 B를 전송하는 단계 - 상기 연결 관계 삭제 명령 B는 상기 백그라운드가 상기 복수 개의 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 C를 전송하는 단계 - 상기 연결 관계 삭제 명령 C는 상기 백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 연결 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송하는 단계 - 상기 제1 모듈 삭제 명령은 상기 복수 개의 타깃 모듈의 상기 모듈 데이터 중 나머지 데이터를 삭제하는 것을 지시함 -;를 포함하는 것을 특징으 로 하는 모듈 처리 방법. 청구항 11 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치로서, 상기 포그라운드 및 백그라운드 분리 시스템은 포그라운드 및 백그라운드를 포함하고, 상기 포그라운드에는 상 호작용 인터페이스가 표시되어 있으며, 상기 상호작용 인터페이스는 복수 개의 모듈을 표시하는 데에 사용되고, 상기 백그라운드에는 데이터 센터가 구성되어 있으며, 상기 데이터 센터는 각 상기 복수 개의 모듈의 모듈 데이 터를 저장하는 데에 사용되고, 상기 모듈 데이터에는 상기 모듈의 표시 방식, 상기 모듈의 기능 데이터 및 상기 모듈과 각 기타 모듈 사이의 논리적 관계가 포함되고; 상기 장치는 제1 제어 모듈, 제2 제어 모듈을 포함하고: 상기 제1 제어 모듈은, 타깃 모듈에 대한 타깃 조작에 응답하여, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 데이터를 업데이트하게 하고, 상기 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스 를 업데이트하게 하는 데에 사용되고, 상기 타깃 모듈이 상기 복수 개의 모듈 중 하나 또는 복수 개의 모듈임; 상기 제2 제어 모듈은, 상기 타깃 조작에 대한 언두 명령을 검출한 경우, 상기 포그라운드가 상기 언두 명령에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 회복하게 하고, 또한 상기 포그라운드가 회복 후의 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치.청구항 12 제11항에 있어서, 제3 제어 모듈을 더 포함하고, 상기 제3 제어 모듈은, 상기 타깃 조작에 대한 리두 명령을 검출할 경우, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 상기 데이터를 업데이 트하게 하고, 상기 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작 용 인터페이스를 업데이트하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치. 청구항 13 제11항 또는 제12항에 있어서, 상기 제1 제어 모듈은: 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명 령을 전송하게 하고, 상기 하나 또는 복수 개의 제1 데이터 업데이트 명령 중 임의의 제1 데이터 업데이트 명령 이 상기 백그라운드를 지시하여 상기 타깃 모듈에 대응하는 데이터 중의 일부 데이터를 업데이트하게 하고; 상기 포그라운드가 상기 하나 또는 복수 개의 데이터 업데이트 명령을 전송하는 것에 기초하여 조작 기록을 생 성하게 하는 데에 사용되며; 상기 제2 제어 모듈은: 상기 포그라운드가 상기 조작 기록이 지시하는 상기 타깃 조작의 역조작에 기초하여 상기 백그라운드로 하나 또 는 복수 개의 제2 데이터 업데이트 명령을 전송하게 하고, 상기 하나 또는 복수 개의 제2 데이터 업데이트 명령 중 임의의 제2 데이터 업데이트 명령이 상기 백그라운드를 지시하여 상기 데이터 센터 중 상기 타깃 모듈에 대 응하는 상기 데이터 중 상기 일부 데이터를 상기 타깃 조작을 수행하기 전의 상태로 회복하게 하는 데에 사용되 는 것을 특징으로 하는 모듈 처리 장치. 청구항 14 제13항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 추가 조작일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 먼저 상기 백그라운드로 제1 모듈 업데이트 명령을 전송하고, 다시 제1 논리적 관계 업데이 트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터에 상기 타깃 모듈의 상기 모듈 데이터 를 추가하게 하고, 다시 상기 각 기타 모듈의 상기 모듈 데이터에 상기 타깃 모듈과 상기 기타 모듈 사이의 상 기 논리적 관계를 추가하게 하는 데에 사용되고; 상기 제2 제어 모듈이: 상기 포그라운드가 먼저 상기 백그라운드로 제2 논리적 관계 업데이트 명령을 전송하고, 다시 제2 모듈 업데이 트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데 이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 삭제하게 하고, 다시 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데이터를 삭제하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치. 청구항 15 제13항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명 령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터 내의 상기 각 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 삭제하게 하고, 다시 상기 데이터 센터 내 의 상기 타깃 모듈의 상기 모듈 데이터를 삭제하게 하는 데에 사용되며; 상기 제2 제어 모듈이: 상기 포그라운드가 먼저 상기 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이 트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터 내의 상기 타깃 모듈의 상기 모듈 데 이터를 회복하게 하고, 다시 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이 의 논리적 관계를 회복하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치. 청구항 16 제13항에 있어서, 익스포트 모듈 및 임포트 모듈을 더 포함하고: 상기 익스포트 모듈이 상기 포그라운드가 먼저 백그라운드로 상기 제1 논리적 관계 업데이트 명령을 전송하고, 다시 상기 제1 모듈 업데이트 명령을 전송하기 전에, 상기 포그라운드가 상기 백그라운드를 제어하여 상기 데이 터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 익스포트하여 참조 저장 위치로 백업하게 하는 데에 사용 되며, 상기 타깃 모듈에 대응하는 상기 데이터가 상기 타깃 모듈의 모듈 데이터, 및 각 기타 모듈의 상기 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 상기 논리적 관계를 포함하고; 상기 임포트 모듈이 상기 포그라운드가 먼저 상기 백그라운드로 상기 제2 모듈 업데이트 명령을 전송하고, 다시 상기 제2 논리적 관계 업데이트 명령을 전송한 후, 수신된 제2 모듈 업데이트 명령에 응답하여, 상기 백그라운 드가 상기 참조 저장 위치로부터 상기 타깃 모듈의 상기 모듈 데이터를 상기 데이터 센터로 임포트하게 하고, 수신된 상기 제2 논리적 관계 업데이트 명령에 응답하여, 상기 백그라운드가 상기 참조 저장 위치로부터 상기 타깃 모듈과 각 상기 기타 모듈 사이의 상기 논리적 관계를 상기 데이터 센터로 임포트하게 하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치. 청구항 17 제13항에 있어서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명 령을 전송하여, 상기 백그라운드를 제어하여 상기 제1 논리적 관계 업데이트 명령을 수신할 경우 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 상기 타깃 모듈 사이의 상기 논리적 관계를 삭제하게 하고, 또한 상기 백그라운드를 제어하여 상기 제1 모듈 업데이트 명령을 수신할 경우, 상기 데이터 센 터 내의 상기 타깃 모듈의 상기 모듈 데이터에 삭제 표기를 추가하게 하는 데에 사용되고; 상기 제2 제어 모듈이: 상기 포그라운드가 먼저 상기 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이 트 명령을 전송하여, 상기 백그라운드를 제어하여 상기 제2 모듈 업데이트 명령을 수신할 경우 상기 데이터 센 터 내의 상기 타깃 모듈의 상기 모듈 데이터의 상기 삭제 표기를 삭제하게 하고, 또한 상기 백그라운드를 제어 하여 상기 제2 논리적 관계 업데이트 명령을 수신할 경우 상기 데이터 센터의 각 상기 기타 모듈의 상기 모듈 데이터에 상기 기타 모듈과 상기 타깃 모듈 사이의 상기 논리적 관계를 추가하게 하는 데에 사용되는 것을 특징 으로 하는 모듈 처리 장치. 청구항 18 제11항 내지 제13항 중 어느 한 항에 있어서, 상기 모듈과 각 상기 기타 모듈 사이의 상기 논리적 관계는 상기 모듈과 각 상기 기타 모듈 사이의 연결 관계, 및 상기 모듈과 각 상기 기타 모듈 사이의 구독 관계를 포함하고; 상기 연결 관계가 상기 상호작용 인터페이스 상 상기 모듈과 각 상기 기타 모듈 사이의 선 연결 관계를 가리키고, 상기 구독 관계가 상기 모듈의 내부 파라미터, 입력 중 적어도 하나와 각 상기 기타 모듈의 출력 사이의 연관 관계, 및/또는, 상기 모듈의 출력과 각 상기 기타 모듈의 내부 파라미터 또는 입력 중 적어도 하나와의 사이의 연관 관계를 가리키는 것을 특징으로 하는 모듈 처리 장치. 청구항 19 제18항에 있어서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 상기 백그라운드로 제1 구독 관계 삭제 명령을 전송하고 - 상기 제1 구독 관계 삭제 명령은 상기 백그라운드가 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 엣지 타깃 모듈 사이의 구독 관 계를 삭제하는 것을 지시하고, 상기 엣지 타깃 모듈이 상기 복수 개의 타깃 모듈 중 상기 기타 모듈과 논리적 관계가 존재하는 타깃 모듈임 -; 상기 포그라운드가 상기 백그라운드로 제1 연결 관계 삭제 명령을 전송하고 - 상기 제1 연결 관계 삭제 명령은 상기 백그라운드가 각 상기 기타 모듈의 상기 모듈 데이터 중 상기 기타 모듈과 상기 엣지 타깃 모듈 사이의 연 결 관계를 삭제하는 것을 지시함 -; 상기 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송 - 상기 제1 모듈 삭제 명령은 상기 백그라운 드가 상기 복수 개의 타깃 모듈의 상기 모듈 데이터를 삭제하는 것을 지시함 -;하는 데에 사용되는 것을 특징으 로 하는 모듈 처리 장치. 청구항 20 제18항에 있어서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 제1 제어 모듈이: 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 A를 전송하고, 상기 구독 관계 삭제 명령 A는 상기 백그라운드가 각 상기 타깃 모듈에 대해, 후에 수행하는 모듈 각각과 먼저 수행하는 모듈 및 상기 타깃 모듈 사 이의 구독 관계를 삭제하는 것을 지시하며, 상기 후에 수행하는 모듈이 상기 포그라운드에 표시된 흐름도 중 상 기 타깃 모듈 후에 수행되는 모듈이고, 상기 먼저 수행하는 모듈이 흐름도 중 상기 타깃 모듈 전에 수행되는 모 듈이며; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 B를 전송하고, 상기 구독 관계 삭제 명령 B는 상기 백그라운드가 상기 복수 개의 타깃 모듈 사이의 구독 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 C를 전송하고, 상기 구독 관계 삭제 명령 C는 상기 백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 구독 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 A를 전송하고, 상기 연결 관계 삭제 명령 A는 상기 백그라운드가 상기 후에 수행하는 모듈 각각과 각 상기 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 B를 전송하고, 상기 연결 관계 삭제 명령 B는 상기 백그라운드가 상기 복수 개의 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 C를 전송하고, 상기 연결 관계 삭제 명령 C는 상기 백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 연결 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송하고, 상기 제1 모듈 삭제 명령은 상기 복수 개의 타깃 모듈의 상기 모듈 데이터 중 나머지 데이터를 삭제하는 것을 지시하는 데에 사용되는 것을 특징으로 하는 모듈 처리 장치. 청구항 21 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치로서, 프로세서; 프로세서 실행가능 명령을 저장하기 위한 메모리를 포함하고; 상기 프로세서가 상술한 제1항 내지 제10항 중 어느 한 항에 따른 상기 방법의 단계를 수행하도록 구성되는 것 을 특징으로 하는 모듈 처리 장치. 청구항 22 비휘발성 컴퓨터 판독가능 저장매체로서, 상기 컴퓨터 판독가능 저장매체에 명령이 저장되어 있고, 상기 명령이 프로세서에 의해 실행될 경우, 상술한 제 1항 내지 제10항 중 어느 한 항에 따른 상기 방법의 단계를 구현하는 것을 특징으로 하는 컴퓨터 판독가능 저장 매체. 청구항 23 명령을 포함하는 컴퓨터 프로그램 제품으로서, 상기 명령이 컴퓨터에서 실행될 경우, 상기 컴퓨터가 상술한 제1항 내지 제10항 중 어느 한 항에 따른 상기 방 법의 단계를 실행하게 하는 것을 특징으로 하는 컴퓨터 프로그램 제품. 발명의 설명 기 술 분 야 본 출원은 컴퓨터 기술 분야에 관한 것으로, 특히 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법, 장치 및 저장매체에 관한 것이다."}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "포그라운드 및 백그라운드 분리 시스템은 포그라운드와 백그라운드가 서로 독립된 시스템을 가리킨다. 상기 포 그라운드는 인터페이스 층을 가리킬 수 있고, 상기 백그라운드는 기능 층을 가리킬 수 있다. 여기서, 포그라운드는 상호작용 인터페이스를 제공하는 데에 사용되고, 당해 상호작용 인터페이스 상에 복수 개 의 모듈을 포함한 흐름도가 표시 도어 있고, 사용자가 당해 상호작용 인터페이스를 통해 특정 모듈에 대한 조작 을 트리거할 수 있다. 백그라운드는 당해 조작에 상응하는 데이터 논리적 기능을 수행하고 또한 데이터 저장 기능을 제공하는 데에 사 용된다. 사용자가 포그라운드를 통해 특정 모듈에 대한 조작을 트리거한 후, 일반적으로 사용자가 당해 조작을 언두 (undo)하거나, 또는 당해 조작을 수행한 후 당해 조작을 새로 수행해야 하는 장면이 존재한다. 상술한 장면에서, 어떻게 당해 조작을 언두하거나 또는 리두(redo)하는가 하는 것은 포그라운드 및 백그라운드 데이터의 동기화와 관련될 수 있기에, 포그라운드 및 백그라운드 분리 시스템에 기초한 모듈 처리 방법을 연구 하여, 사용자가 포그라운드 및 백그라운드 분리 시스템에서 모듈에 대한 조작의 언두 또는 리두를 구현할 수 있 게 하는 것이 시급하다."}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 출원의 실시예는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법, 장치 및 저장매체를 제 공하는 바, 포그라운드 및 백그라운드 분리 시스템에서의 사용자 조작의 언두 또는 리두를 구현할 수 있다."}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "제1 양태에 있어서, 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법을 제공하는 바, 상기 포 그라운드 및 백그라운드 분리 시스템은 포그라운드 및 백그라운드를 포함하고, 상기 포그라운드에는 상호작용 인터페이스가 표시되어 있으며, 상기 상호작용 인터페이스는 복수 개의 모듈을 표시하는 데에 사용되고, 상기 백그라운드에는 데이터 센터가 구성되어 있으며, 상기 데이터 센터는 각 상기 복수 개의 모듈의 모듈 데이터를저장하는 데에 사용되고, 상기 모듈 데이터에는 상기 모듈의 표시 방식, 상기 모듈의 기능 데이터 및 상기 모듈 과 각 기타 모듈 사이의 논리적 관계가 포함되고; 상기 방법은: 타깃 모듈에 대한 타깃 조작에 응답하여, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제 어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 데이터를 업데이트하고, 상기 포그라운드가 업데이트 된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트하는 단계 - 상기 타깃 모듈은 상기 복수 개의 모듈 중 하나 또는 복수 개의 모듈임 -; 상기 타깃 조작에 대한 언두 명령을 검출한 경우, 상기 포그라운드가 상기 언두 명령에 기초하여 상기 백그라운 드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 회복하게 하고, 상기 포그라운드 가 회복 후의 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스를 업데이트하는 단계를 포함한다. 제2 양태에 있어서, 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치를 제공하는 바, 상기 포그라운드 및 백그라운드 분리 시스템은 포그라운드 및 백그라운드를 포함하고, 상기 포그라운드에는 상 호작용 인터페이스가 표시되어 있으며, 상기 상호작용 인터페이스는 복수 개의 모듈을 표시하는 데에 사용되고, 상기 백그라운드에는 데이터 센터가 구성되어 있으며, 상기 데이터 센터는 각 상기 복수 개의 모듈의 모듈 데이 터를 저장하는 데에 사용되고, 상기 모듈 데이터에는 상기 모듈의 표시 방식, 상기 모듈의 기능 데이터 및 상기 모듈과 각 기타 모듈 사이의 논리적 관계가 포함되며; 상기 장치는 제1 제어 모듈 및 제2 제어 모듈을 포함하고, 상기 제1 제어 모듈은 타깃 모듈에 대한 타깃 조작에 응답하여, 상기 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 데이터를 업데이트하게 하고, 상기 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페이스 를 업데이트하게 하는 데에 사용되고, 상기 타깃 모듈이 상기 복수 개의 모듈 중 하나 또는 복수 개의 모듈이며; 제2 제어 모듈은 상기 타깃 조작에 대한 언두 명령을 검출한 경우, 상기 포그라운드가 상기 언두 명령에 기초하 여 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 상기 데이터를 회복하게 하고, 또한 상기 포그라운드가 회복 후의 상기 타깃 모듈에 대응하는 상기 데이터에 기초하여, 상기 상호작용 인터페 이스를 업데이트하게 하는 데에 사용된다. 제3 양태에 있어서, 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치를 제공하는 바, 상기 장 치는: 프로세서; 프로세서 실행가능 명령을 저장하기 위한 메모리를 포함하며; 여기서, 상기 프로세서는 상술한 제1 양태에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모 듈 처리 방법 중 임의의 단계를 실행하도록 구성된다. 제4 양태에 있어서, 컴퓨터 판독가능 저장매체를 제공하는 바, 상기 컴퓨터 판독가능 저장매체에 명령이 저장되 어 있고, 상기 명령이 프로세서에 의해 실행될 경우 상술한 제1 양태에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법 중 임의의 단계를 구현한다. 제5 양태에 있어서, 명령을 포함하는 컴퓨터 프로그램 제품을 제공하는 바, 이가 컴퓨터에서 실행될 경우, 컴퓨 터가 상술한 제1 양태에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법 중 임의 의 단계를 실행하게 한다. 본 출원의 실시예에서 제공하는 기술적 해결방안이 가져다주는 유익한 효과는 적어도 아래 효과를 포함한다: 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템 중, 백그라운드의 데이터 센터 내에 저 장된 모듈 데이터는 모듈의 표시 방식, 모듈의 기능 데이터 및 모듈 사이의 논리적 관계를 포함하는 바, 즉 백 그라운드에 포그라운드 데이터 및 백그라운드 데이터를 동시에 저장한다. 이로부터 알 수 있다시피, 본 출원의 실시예에서, 백그라운드를 전체 데이터의 데이터 센터로 이용한다. 이러한 방법으로, 포그라운드가 타깃 모듈에대한 타깃 조작을 검출할 경우, 백그라운드를 제어하여 포그라운드 및 백그라운드 데이터를 업데이트하게 할 수 있고, 타깃 조작을 취소할 경우, 마찬가지로 백그라운드를 제어하여 포그라운드 및 백그라운드 데이터를 업데이 트하게 함으로써, 타깃 조작을 실행하거나 또는 타깃 조작을 언두하는 과정 중 포그라운드 상호작용 인터페이스 상에 표시된 내용, 및 포그라운드 및 백그라운드 데이터 사이의 일관성을 확보할 수 있다."}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 발명의 실시예의 목적, 기술적 해결수단 및 장점이 보다 뚜렷하도록 하기 위하여 이하 도면과 결부하여 본 발명의 실시예 방식에 대해 더 상세하게 설명한다. 포그라운드 및 백그라운드 분리 시스템 중, 포그라운드는 소프트웨어 인터페이스를 표시하여, 사용자에게 조작 의 상호작용 인터페이스를 제공하는 데에 사용되고, 백그라운드는 구체적인 기능 논리 및 기록 데이터를 제공한 다. 전형적인 C/S(client/server, 클라이언트/서버), B/S(browser/server, 브라우저/서버) 시스템은 모두 포그 라운드 및 백그라운드 분리 시스템에 속한다. 현재, 머신 비전 산업 또는 기타 산업에서, 사전에 일부 상이한 기능 모듈(기능 모듈을 기능 유닛이라고도 지칭 함)을 선정하고, 이러한 기능 모듈의 조합을 통해 특정된 조합 기능을 구현한다. 기능 모듈을 일정한 순서로 배 열하고, 이들 사이의 관계를 구성하는 과정이 바로 프로세스 구성이다. 프로세스 구성 기능을 제공하는 소프트 웨어가 바로 프로세스 구성 시스템이다. 프로세스 구성 시스템의 포그라운드가 제공하는 상호작용 인터페이스가 일반적으로 하나의 그래픽(graphical) 흐름도이기에, 따라서 프로세스 구성 시스템을 그래픽 프로세스 구성 시 스템이라고도 지칭한다. 프로세스 구성 시스템은 전형적인 포그라운드 및 백그라운드 분리 시스템이다. 본 출원의 실시예에서 제공하는 모듈 처리 방법은 프로세스 구성 시스템에 사용될 수 있다. 선택 가능하게, 본 출원의 실시예에서 제공하는 모 듈 처리 방법은 기타 포그라운드 및 백그라운드 분리 시스템에도 사용될 수 있으며, 본 출원의 실시예는 이에 대해 제한하지 않는다. 아래 설명의 편의를 위해, 여기서 본 출원의 실시예에 관한 두 개의 개념에 대해 먼저 간단하게 소개한다. 언두: 사용자가 소프트웨어 시스템과 상호작용을 수행할 경우, 사용자의 수요로 인해, 소프트웨어의 상태를 마 지막 조작 이전의 상태로 롤백하는(roll back) 바, 이것이 바로 한 차례의 언두이다. 언두는 연쇄적일 수 있는 바, 즉 언두를 여러 번 수행하여, 여러 번의 조작 이전의 상태로 돌아갈 수 있다. 리두: 언두 동작과 반대로, 소프트웨어가 언두로 인해 특정 상태에 달한 후, 사용자의 수요로 인해, 소프트웨어 상태를 마지막 한번의 언두 이전의 상태로 전진하는 바, 즉 다시 실행하는 것이다. 리두도 연쇄적일 수 있는 바, 즉 리두를 여러 번 수행하여, 여러 번 언두 이전의 상태로 회복한다. 언두 또는 리두의 목적은 소프트웨어의 상태를 마지막 하나의 조작에서 이전 N개 조작 사이의 임의의 하나의 조 작 후의 상태로 리셋하는 것인 바, 즉 사용자에게 자신의 행위에 대해 철회할 기회를 주는 것이다. 포그라운드 및 백그라운드 분리 시스템 중, 포그라운드는 사용자에게 조작을 수행할 수 있는 상호작용 인터페이 스를 제공하고, 백그라운드는 데이터 논리 기능 및 저장을 제공한다. 이러한 시스템 중, 어떻게 언두 또는 리두 를 구현하는 동시에 포그라운드 및 백그라운드 데이터의 동기화를 확보하고, 또한 프로세스 구성 시스템이 단일 기능 모듈의 변화로 인해 복수 개의 기능 모듈이 따라 변화하는 경우, 어떻게 사용자에 의해 트리거된 조작의 언두 또는 리두를 구현할 것인가의 이 두 가지 기술은 모두 현재 연구의 핫토픽(hot topic)이다. 본 출원의 실 시예에서 제공하는 모듈 처리 방법은 상술한 두 가지 기술을 구현할 수 있으며, 구체적인 구현 방식은 아래 실 시예에서 상세하게 설명한다. 도 1은 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템의 아키텍처 모식도이다. 도 1에 도시된 바와 같이, 당해 포그라운드 및 백그라운드 분리 시스템은 포그라운드 및 백그라운드를 포함한다. 여기서, 포그라운드가 제공하는 상호작용 인터페이스 상에는 모듈 1과 모듈 2, 및 모듈 1과 모듈 2 사이의 연결 관계가 표시되어 있다. 동시에 모듈 1은 구체적인 표시 방식에 기초하여 표시되고, 모듈 2도 구체적인 표시 방 식에 기초하여 표시된다. 도 1은 모듈 2의 표시 방식을 도시하며, 당해 표시 방식에 구체적으로 포함되는 모듈 2의 좌상단이 좌표 (200, 300)에 위치하고, 모듈 2의 높이(height)가 30이며, 모듈 2의 너비(width)가 90이고, 모듈 2의 컬러(color)가 오렌지색이다. 상술한 모듈 1 및 모듈 2의 표시 방식을 포그라운드 데이터라고 지칭할 수 있다. 여기서, 포그라운드 데이터를 인터페이스 데이터라고도 지칭한다. 백그라운드는 구체적인 논리 기능을 제공한다. 도 1에 도시된 바와 같이, 백그라운드에 한 세그먼트의 코드가 저장되어 있으며, 당해 코드는 아래와 같다: (프로세스 0: 모듈 1의 기능 데이터 모듈 2의 기능 데이터 연결 관계: 모듈 1이 모듈 2를 포인팅함(point)). 당해 코드가 지시하는 의미는: 포그라운드가 표시하는 것은 하나의 흐름도이고, 당해 흐름도는 두 개의 기능 모 듈을 포함하는 바, 각각 모듈 1 및 모듈 2이고, 또한 연결 관계는 모듈 1이 모듈 2를 포인팅하는 것인 바, 즉, 모듈 1의 출력이 모듈 2의 입력이다. 상술한 코드 중의 모듈 1의 기능 데이터는 모듈 1의 내부 실행 논리를 가리키고, 당해 내부 실행 논리는 어떻게 모듈 1의 입력에 기초하여 모듈 1의 출력을 얻을 것인지를 지시하는 데에 사용된다. 모듈 2의 기능 데이터는 모 듈 2의 내부 실행 논리를 가리키고, 당해 내부 실행 논리는 어떻게 모듈 2의 입력에 기초하여 모듈 2의 출력을 얻을 것인지를 지시하는 데에 사용된다. 상술한 코드는 일반적으로 백그라운드 데이터라고 지칭하는 바, 즉, 본 출원의 실시예에서 백그라운드 데이터는 포그라운드 상호작용 인터페이스 상에 표시된 복수 개의 모듈 중 각 모 듈의 기능 데이터 및 복수 개의 모듈 사이의 논리적 관계를 가리킨다. 여기서, 백그라운드 데이터를 기저 데이 터(underlying data)라고도 지칭하고, 백그라운드를 기저층(underlying layer)이라고도 지칭한다. 도 1에 도시된 바와 같이, 포그라운드의 상호작용 인터페이스에 두 개의 모듈을 배치하고, 여기서 모듈 2의 좌 상단이 좌표 (200, 300)에 위치하고, 너비가 90, 높이가 30이며, 컬러가 오렌지색이다. 백그라운드는 모듈 사이 의 논리적 관계 및 각 모듈의 기능 데이터를 저장한다. 모듈 2를 삭제할 경우, 백그라운드에 대해, 백그라운드 데이터 중 하나의 모듈 2의 기능 데이터, 및 하나의 연결 관계가 적어진다. 언두 조작을 수행할 경우, 백그라운 드에 모듈 2의 기능 데이터, 및 모듈 2와 모듈 1 사이의 연결 관계를 회복해야 할 뿐만 아니라, 포그라운드 상 호작용 인터페이스 상의 위치, 너비, 컬러도 모두 회복해야만이 삭제 조작 이전으로 완전히 회복할 수 있다. 이런 장면에서, 만약 포그라운드 데이터를 포그라운드에 저장하고, 백그라운드 데이터를 백그라운드에 저장하면, 삭제 조작을 언두할 경우, 각각 포그라운드에서 포그라운드 데이터를 회복하고, 백그라운드에서 기능데이터 및 논리적 관계를 회복해야 하는 바, 이는 포그라운드 및 백그라운드 데이터의 불일치함을 쉽게 초래한 다. 따라서, 본 출원의 실시예에서, 모든 데이터를 유일한 센터에 저장하도록 구성하고, 당해 센터가 바로 백그 라운드이다. 이러한 방법으로, 포그라운드 데이터도 백그라운드에 저장하고, 언두 시 단지 백그라운드에 저장된 데이터만 회복하면 되고, 다음에 포그라운드가 다시 백그라운드로부터 포그라운드 데이터를 획득한다. 즉, 포그 라운드가 단지 백그라운드로부터 포그라운드 데이터를 획득하고 전시하는 데에만 사용되며, 데이터의 저장을 수 행하지 않음으로써, 데이터가 가능하게 불일치해지는 문제점을 해결한다. 본 출원의 실시예에서, 포그라운드 데 이터 및 백그라운드 데이터가 모두 백그라운드에 저장되기에, 아래 설명의 편의를 위해, 백그라운드에 저장된 데이터를 모듈 데이터라고 통칭한다. 즉, 모듈 데이터는 포그라운드 데이터 및 백그라운드 데이터를 포함한다. 구체적으로, 임의의 모듈의 모듈 데이터는 당해 모듈의 표시 방식, 당해 모듈의 기능 데이터 및 당해 모듈과 각 기타 모듈 사이의 논리적 관계를 포함한다. 설명해야 할 것은, 도 1에 도시된 포그라운드 및 백그라운드 분리 시스템은 단지 예시일 뿐, 본 출원의 실시예 에 관한 포그라운드 및 백그라운드 분리 시스템을 한정하지 않는다. 도 2는 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법 흐름 도이다. 당해 방법은 포그라운드 및 백그라운드 분리 시스템에 응용되며, 포그라운드 및 백그라운드 분리 시스 템은 포그라운드 및 백그라운드를 포함하고. 포그라운드에는 상호작용 인터페이스가 표시되어 있으며, 상호작용 인터페이스는 복수 개의 모듈을 표시하는 데에 사용된다. 백그라운드에는 데이터 센터가 구성되어 있으며, 당해 데이터 센터는 복수 개의 모듈 중 각 모듈의 모듈 데이터를 저장하는 데에 사용되며, 임의의 모듈의 모듈 데이 터는 당해 모듈의 표시 방식, 당해 모듈의 기능 데이터 및 당해 모듈과 각 기타 모듈 사이의 논리적 관계를 포 함한다. 구체적으로, 도 2에 도시된 바와 같이, 당해 방법은 아래와 같은 몇 개 단계를 포함한다. 단계 201: 타깃 모듈에 대한 타깃 조작에 응답하여, 포그라운드는 타깃 조작에 기초하여 백그라운드를 제어하여 데이터 센터 중 타깃 모듈에 대응하는 데이터를 업데이트하게 하고, 포그라운드가 업데이트된 타깃 모듈에 대응 하는 데이터에 기초하여 상호작용 인터페이스를 업데이트하게 하며, 타깃 모듈은 복수 개의 모듈 중 하나 또는 복수 개의 모듈이고, 타깃 조작은 타깃 모듈에 대한 임의의 조작이다. 여기서, 타깃 모듈에 대응하는 데이터는 데이터 센터 내의 타깃 모듈의 모듈 데이터, 및 기타 모듈의 모듈 데이 터 중 타깃 모듈과 상관되는 데이터를 포함하고, 당해 내용은 나중에 상세하게 설명하며, 여기서는 설명하지 않 는다. 상술한 타깃 조작은 타깃 모듈에 대한 삭제 조작일 수도 있고, 타깃 모듈에 대한 추가 조작일 수도 있거나, 또 는 타깃 모듈의 컬러 표시 등 속성에 대한 수정 조작일 수 있다. 여기서, 삭제 조작은 구체적으로 상호작용 인 터페이스 상에 표시된 타깃 모듈을 삭제하는 것을 가리키며, 추가 조작은 구체적으로 상호작용 인터페이스 상에 타깃 모듈을 추가하는 것을 가리킨다. 예시적으로, 타깃 조작이 타깃 모듈에 대한 삭제 조작일 경우, 단계 201은 구체적으로: 포그라운드가 타깃 조작 에 기초하여 백그라운드를 제어하여 데이터 센터 내의 타깃 모듈의 모듈 데이터, 및 기타 모듈의 모듈 데이터 중 타깃 모듈과 상관되는 데이터를 삭제하고, 데이터를 삭제한 후의 데이터 센터에 기초하여 상호작용 인터페이 스를 다시 표시하는 것을 가리킨다. 또 예시적으로, 타깃 조작이 타깃 모듈에 대한 추가 조작일 경우, 단계 201은 구체적으로: 포그라운드가 타깃 조작에 기초하여 백그라운드를 제어하여 데이터 센터 내에 타깃 모듈의 모듈 데이터를 추가하고, 또한 기타 모 듈의 모듈 데이터에 타깃 모듈과 상관되는 데이터를 추가하며, 데이터를 추가한 후의 데이터 센터에 기초하여, 상호작용 인터페이스를 다시 표시하는 것을 가리킨다. 가능한 구현 방식에서, 상호작용 인터페이스에 모듈 삭제 컨트롤 및 모듈 추가 컨트롤이 표시되어 있으며, 포그 라운드가 사용자의 당해 모듈 삭제 컨트롤 및 모듈 추가 컨트롤에 대한 선택 조작을 검출할 경우, 타깃 모듈에 대한 타깃 조작을 검출한 것으로 결정할 수 있으며, 이때, 단계 201를 통해 타깃 조작을 수행할 수 있다. 포그라운드는 당해 타깃 조작을 검출한 후, 포그라운드가 타깃 조작에 기초하여 백그라운드를 제어하여 데이터 센터 중 타깃 모듈에 대응하는 데이터를 업데이트하고, 업데이트된 데이터 센터 중 타깃 모듈에 대응하는 데이 터에 기초하여, 상호작용 인터페이스를 업데이트함으로써, 상호작용 인터페이스, 포그라운드 및 백그라운드 데 이터의 일관성을 구현한다. 상술한 타깃 모듈에 대응하는 데이터는 타깃 모듈의 모듈 데이터, 및 기타 모듈의 모듈 데이터 중 타깃 모듈과 상관되는 데이터를 포함한다. 여기서, 타깃 모듈의 모듈 데이터는 타깃 모듈의 기능 데이터, 타깃 모듈의 표시방식 및 타깃 모듈과 각 기타 모듈 사이의 논리적 관계를 포함한다. 타깃 모듈의 기능 데이터는 타깃 모듈의 내 부 실행 논리를 가리키며, 당해 내부 실행 논리는 어떻게 타깃 모듈의 입력에 기초하여 타깃 모듈의 출력을 얻 을 것인가를 가리킨다. 타깃 모듈의 표시 방식은 예시적으로 타깃 모듈의 표시 위치, 표시 크기 및 표시 컬러 등을 포함한다. 각 기타 모듈의 모듈 데이터 중 타깃 모듈과 상관되는 데이터는 당해 기타 모듈과 타깃 모듈 사 이의 논리적 관계를 포함한다. 가능한 구현 방식에서, 타깃 모듈과 각 기타 모듈 사이의 논리적 관계는 타깃 모듈과 당해 기타 모듈 사이의 연 결 관계를 포함한다. 당해 연결 관계는 상호작용 인터페이스 상 타깃 모듈과 당해 기타 모듈 사이의 선 연결 관 계를 가리키며, 당해 선 연결 관계는 구체적으로 흐름도의 수행 과정 중 타깃 모듈과 당해 기타 모듈 사이의 실 행 순서를 가리킨다. 예컨대, 타깃 모듈이 도 1에 도시된 모듈 1이고, 기타 모듈이 모듈 2이면, 타깃 모듈과 기 타 모듈의 연결 관계는 먼저 모듈 1의 내부 실행 논리를 수행하고, 다시 모듈 2의 내부 실행 논리를 수행하는 것을 가리킬 수 있다. 포그라운드 및 백그라운드 분리 시스템이 프로세스 구성 시스템일 경우, 도 3은 본 출원의 실시예에서 제공하는 흐름도 모식도이고, 포그라운드에 표시되는 흐름도는 일반적으로 도 3에 도시된 바와 같다. 도 3에 도시된 흐름 도 중 각 모듈 사이의 연결 관계는 단지 실행 순서를 나타낼 뿐이고, 모듈과 모듈 사이는 데이터 상호작용이 존 재하고, 앞의 모듈의 출력을 후속의 모듈의 입력 또는 파라미터로 사용하여 연산에 참여해야 하며, 그렇지 않을 경우 이 프로세스는 의미가 없게 된다. 만약 입력/출력과 모듈 자체의 파라미터를 추가하면, 실제 흐름도는 도 3에 도시된 흐름도보다 많이 복잡하다. 도 4는 본 출원의 실시예에서 제공하는 다른 흐름도 모식도이다. 도 4에 도시된 바와 같이, 모듈과 모듈 사이는 연결 관계 외에, 내부가 복잡한 파라미터, 입력, 출력 사이의 구독 관계가 존재한다. 예컨대, 특정 모듈의 내부 파라미터는 실행 순서 중 이전 하나의 모듈의 출력일 수 있고, 당해 모듈의 출력은 또한 실행 순서 중 다음 하 나의 모듈의 내부 파라미터일 수 있거나, 또는 특정 모듈의 출력이 실행 순서 중 다음 하나의 모듈의 입력 등일 수 있다. 즉, 특정 모듈이 이전의 특정 모듈의 입력 또는 출력을 구독할 수 있다. 따라서 흐름도는 실제로 하나 의 아주 복잡한 단방향 네트워크일 수 있다. 어느 하나의 모듈을 삭제할 경우, 모듈 자체에 영향줄 뿐만 아니라, 흐름도 상의 모든 후속 모듈과 당해 모듈, 및 이의 앞 순서의 모듈의 구독 관계에도 영향준다. 따라서, 다른 가능한 구현 방식에서, 타깃 모듈과 각 기타 모듈 사이의 논리적 관계는 상술한 타깃 모듈과 당해 기타 모듈 사이의 연결 관계를 포함하는 외에, 타깃 모듈과 당해 기타 모듈 사이의 구독 관계를 포함할 수 있다. 당해 구독 관계는 타깃 모듈의 내부 파라미터, 입력 중 적어도 하나와 당해 기타 모듈의 출력 사이의 연 관 관계, 및/또는, 타깃 모듈의 출력과 당해 기타 모듈의 내부 파라미터, 입력 중 적어도 하나와의 사이의 연관 관계, 및/또는, 타깃 모듈의 입력과 당해 기타 모듈의 출력 사이의 연관 관계를 가리킨다. 즉, 본 출원의 실시예에서, 임의의 모듈에 대해, 당해 모듈과 각 기타 모듈 사이의 논리적 관계는 당해 모듈과 당해 기타 모듈 사이의 연결 관계, 및 당해 모듈과 당해 기타 모듈 사이의 구독 관계를 포함한다. 당해 연결 관 계는 표시 인터페이스 상 당해 모듈과 당해 기타 모듈 사이의 선 연결 관계를 가리킨다. 구독 관계는 당해 모듈 의 내부 파라미터와 당해 기타 모듈의 출력 사이의 연관 관계, 및/또는, 당해 모듈의 출력과 당해 기타 모듈의 내부 파라미터 사이의 연관 관계, 및/또는, 당해 모듈의 출력과 당해 기타 모듈의 입력 사이의 연관 관계, 및/ 또는, 당해 모듈의 입력과 당해 기타 모듈의 출력 사이의 연관 관계를 가리킨다. 즉, 구독 관계는 당해 모듈의 내부 파라미터, 입력 중 적어도 하나와 당해 기타 모듈의 출력 사이의 연관 관계, 및/또는, 당해 모듈의 출력과 당해 기타 모듈의 내부 파라미터, 입력 중 적어도 하나와의 사이의 연관 관계를 가리킨다. 설명해야 할 것은, 각 모듈의 내부 파라미터는 1개일 수도 있고, 복수 개일 수도 있다. 추가로, 각 모듈의 출력 은 1개 또는 복수 개일 수 있고, 각 모듈의 입력도 1개 또는 복수 개일 수 있다. 상술한 연관 관계는 하나의 상 위 개념의 연관 관계이고, 구체적인 하나의 파라미터와 다른 하나의 구체적인 파라미터 사이의 연관 관계를 포 함할 수도 있고, 복수 개의 파라미터 각각과 기타 파라미터 사이의 연관 관계를 포함할 수도 있다. 예컨대, 타 깃 모듈의 내부 파라미터와 기타 모듈의 출력 사이의 연관 관계는: 기타 특정 모듈의 하나의 출력이 타깃 모듈 의 하나의 내부 파라미터이거나, 또는, 기타 특정 모듈의 두 개의 출력이 각각 타깃 모듈의 두 개의 내부 파라 미터이거나, 또는, 기타 두 개의 모듈 각자의 하나의 출력이 각각 타깃 모듈의 두 개의 내부 파라미터 중 하나 인 것을 가리킬 수 있다. 전술한 예시는 단지 예를 들어 설명하는 데에 사용되며, 본 출원의 실시예에 관한 연 관 관계를 한정하지 않는다. 단계 202: 타깃 조작에 대한 언두 명령을 검출할 경우, 포그라운드는 언두 명령에 기초하여 백그라운드를 제어 하여 데이터 센터 중 타깃 모듈에 대응하는 데이터를 회복하게 하고, 포그라운드가 회복 후의 타깃 모듈에 대응하는 데이터에 기초하여, 상호작용 인터페이스를 업데이트하게 한다. 가능한 구현 방식에서, 상호작용 인터페이스에 언두 조작 컨트롤이 표시되어 있고, 포그라운드가 사용자의 당해 언두 조작 컨트롤에 대한 선택 조작을 검출할 경우, 타깃 조작에 대한 언두 명령이 검출된 것으로 결정할 수 있 으며, 이때, 단계 202를 통해 타깃 조작에 대한 언두 과정을 수행할 수 있다. 타깃 조작이 타깃 모듈에 대한 삭제 조작인 경우, 상술한 단계 202는 구체적으로: 포그라운드가 언두 명령에 기 초하여 백그라운드를 제어하여 데이터 센터 내에 타깃 모듈에 대응하는 데이터를 다시 추가하게 하는 것을 가리 킨다. 타깃 조작이 타깃 모듈에 대한 추가 조작인 경우, 상술한 단계 202는 구체적으로: 포그라운드가 언두 명령에 기 초하여 백그라운드를 제어하여 데이터 센터 내에 타깃 모듈에 대응하는 데이터를 삭제하게 하는 것을 가리킨다. 본 출원의 실시예에서, 상술한 단계 201와 단계 202는 구체적으로 포그라운드를 조작 센터로 사용할 수도 있고, 백그라운드를 조작 센터로 사용할 수도 있다. 여기서, 포그라운드를 조작 센터로 사용하는 것은 포그라운드에 의해 타깃 조작이 수행하는 각 구체적인 조작을 기록하는 것을 가리키고, 백그라운드를 센터로 사용하는 것은 백그라운드가 타깃 조작이 수행하는 각 구체적인 조작을 기록하는 것을 가리키는 바, 즉 양자의 구별점은 구체 적인 조작을 기록하는 문서가 포그라운드에 저장되는가 아니면 백그라운드에 저장되는가 하는 것이다. 아래 두 가지 구현 방식을 통해 각각 설명한다. 포그라운드를 센터로 사용 이때, 상술한 단계 201의 구현 과정은 아래와 같을 수 있다: 포그라운드가 타깃 조작에 기초하여 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하고, 하나 또는 복수 개의 제1 데이터 업데이트 명령 중 임의의 제1 데이터 업데이트 명령은 백그라운드를 지시하여 타깃 모듈에 대응하는 데이터 중의 일부 데이터를 업데이트하게 하고; 포그라운드가 당해 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하는 것에 기초하 여 조작 기록을 생성하게 한다. 예컨대, 타깃 조작이 모듈 삭제 또는 모듈 추가인 장면에서, 포그라운드가 백그라운드로 제1 논리적 관계 업데 이트 명령 및 제1 모듈 업데이트 명령을 전송하고, 제1 논리적 관계 업데이트 명령 및 제1 모듈 업데이트 명령 을 전송한 조작 기록을 생성한다. 제1 논리적 관계 업데이트 명령은 백그라운드를 지시하여 타깃 조작에 기초하 여 데이터 센터의 각 기타 모듈의 모듈 데이터 중 당해 기타 모듈과 타깃 모듈 사이의 논리적 관계를 업데이트 하게 하고, 제1 모듈 업데이트 명령은 백그라운드를 지시하여 타깃 조작에 기초하여 데이터 센터 내의 타깃 모 듈의 모듈 데이터를 업데이트하게 한다. 설명해야 할 것은, 상술한 조작 기록은 각 제1 데이터 업데이트 명령의 전송 순서, 및 각 명령이 지시하는 데이 터 변화 상황을 가리키는 데에 사용된다. 이때, 상술한 단계 202의 구현 과정은 아래와 같을 수 있다: 포그라운드가 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여 백그라운드로 하나 또는 복수 개의 제2 데이터 업데이트 명령을 전송하고, 하나 또는 복수 개의 제2 데이터 업데이트 명령 중 임의의 제2 데이터 업데이트 명령은 백그라운드를 지시하여 각 기타 모듈의 모듈 데이터 중 당해 기타 모듈과 타깃 모듈 사이의 논리적 관계를 타깃 조작을 수행하기 전의 상태로 회복하게 하거나, 또는 타깃 모듈의 모듈 데이터를 타깃 조작을 수행하기 전의 상태로 회복하게 한다. 예컨대, 타깃 조작이 모듈 삭제 또는 모듈 추가인 장면에서, 포그라운드가 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여 백그라운드로 제2 논리적 관계 업데이트 명령 및 제2 모듈 업데이트 명령을 전송한다. 제2 논리적 관계 업데이트 명령은 백그라운드를 지시하여 데이터 센터의 각 기타 모듈의 모듈 데이터 중 타깃 모듈 과 당해 기타 모듈 사이의 논리적 관계를 타깃 조작을 수행하기 전의 상태로 회복하도록 지시하고, 제2 모듈 업 데이트 명령은 백그라운드를 지시하여 데이터 센터 내의 타깃 모듈의 모듈 데이터를 타깃 조작을 수행하기 전의 상태로 회복하게 함으로써, 후속으로 포그라운드가 백그라운드로부터 업데이트된 타깃 모듈에 대응하는 데이터 를 획득하고, 업데이트된 타깃 모듈에 대응하는 데이터에 기초하여 상호작용 인터페이스를 업데이트하는 데에 편리하게 한다. 구체적으로, 타깃 조작이 타깃 모듈에 대한 삭제 조작인 경우, 타깃 조작을 수행할 때, 포그라운드가 먼저 백그 라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송한다. 이러한 방법으 로, 백그라운드를 제어하여 먼저 각 기타 모듈의 모듈 데이터 중 타깃 모듈과 당해 기타 모듈 사이의 논리적 관 계를 삭제하고, 다시 타깃 모듈의 모듈 데이터를 삭제하며, 또한 먼저 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송하는 조작 기록을 생성하게 하는 데에 편리하게 한다. 타깃 조작을 취 소할 경우, 전술한 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여, 포그라운드가 먼저 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송한다. 이러한 방법으로, 백그라운 드를 제어하여 먼저 데이터 센터 내의 타깃 모듈의 모듈 데이터를 회복하고, 다시 각 기타 모듈의 모듈 데이터 중 타깃 모듈과 당해 기타 모듈 사이의 논리적 관계를 회복하게 할 수 있다. 마찬가지로, 타깃 조작이 타깃 모듈에 대한 추가 조작일 경우, 타깃 조작을 수행할 때, 포그라운드가 먼저 백그 라운드로 제1 모듈 업데이트 명령을 전송하고, 다시 제1 논리적 관계 업데이트 명령을 전송한다. 이러한 방법으 로, 백그라운드를 제어하여 먼저 데이터 센터에 타깃 모듈의 모듈 데이터를 추가하고, 다시 데이터 센터의 각 기타 모듈의 모듈 데이터에 타깃 모듈과 당해 기타 모듈 사이의 논리적 관계를 추가하며, 먼저 제1 모듈 업데이 트 명령을 전송하고, 다시 제1 논리적 관계 업데이트 명령을 전송하는 조작 기록을 생성하게 할 수 있다. 타깃 조작을 취소할 경우, 전술한 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여, 포그라운드가 먼저 백그라 운드로 제2 논리적 관계 업데이트 명령을 전송하고, 다시 제2 모듈 업데이트 명령을 전송한다. 이러한 방법으로, 백그라운드를 제어하여 먼저 데이터 센터의 각 기타 모듈의 모듈 데이터 중 타깃 모듈과 당해 기타 모듈 사이의 논리적 관계를 삭제하고, 다시 데이터 센터 내의 타깃 모듈의 모듈 데이터를 삭제할 수 있다. 상술한 순서대로 명령을 전송하는 목적은: 포그라운드가 타깃 조작을 취소할 경우, 완전히 타깃 조작의 역조작 에 기초하여 구현하여, 타깃 조작 수행 전의 상태로 돌아가지 못하는 것을 피할 수 있다. 예컨대, 타깃 조작이 도 1에 도시된 모듈 2에 대한 삭제 조작일 경우, 만약 포그라운드를 센터로 사용하면, 단 계 201 및 단계 202의 구체적인 과정은 아래와 같다. 타깃 조작을 수행할 때, 아래와 같은 몇 개 과정을 포함한다: 1) 포그라운드가 백그라운드로 모듈 데이터를 획득하는 명령을 전송하고, 포그라운드가 백그라운드에 의해 전송 된 타깃 모듈에 대응하는 데이터를 수신하며, 당해 타깃 모듈에 대응하는 데이터는 타깃 모듈의 모듈 데이터, 및 각 기타 모듈의 모듈 데이터 중 타깃 모듈과 상관되는 데이터를 포함한다; 2) 포그라운드가 획득된 타깃 모듈에 대응하는 데이터에 대해 분석을 수행하여, 타깃 모듈을 삭제하는 것을 결 정하면, 먼저 각 기타 모듈의 모듈 데이터 중 타깃 모듈과 당해 기타 모듈 사이의 논리적 관계를 삭제하고, 다 음에 다시 타깃 모듈의 모듈 데이터를 삭제해야 한다. 당해 분석 결과에 기초하여, 포그라운드가 백그라운드로 연결선을 삭제하는 명령을 전송하는 바, 즉, 상술한 제1 논리적 관계 업데이트 명령을 전송하여, 백그라운드를 지시하여 데이터 센터 내의 당해 기타 모듈의 모듈 데이터 중 타깃 모듈과 당해 기타 모듈 사이의 논리적 관계 를 삭제하고, 또한 당해 제1 논리적 관계 업데이트 명령 전송에 대응하는 조작 기록을 생성하는 바, 아래 설명 의 편의를 위해, 당해 조작 기록을 제1 조작 기록이라고 지칭한다. 여기서, 백그라운드가 논리적 관계를 삭제할 경우, 먼저 타깃 모듈에 상관되는 연결 데이터를 기타 자장 장소로 백업하는 바, 즉 타깃 모듈과 각 기타 모듈 사이의 논리적 관계를 백업한 다음에 다시 백그라운드 데이터 중 타깃 모듈에 상관되는 연결 데이터를 삭제함으 로써, 후에 빠른 속도로 삭제된 데이터를 회복하는 데에 편리하다. 3) 포그라운드가 백그라운드로 모듈 삭제 명령을 전송, 즉, 상술한 제1 모듈 업데이트 명령을 전송하여, 백그라 운드를 지시하여 타깃 모듈의 모듈 데이터를 삭제하고, 당해 제1 논리적 관계 업데이트 명령 전송 에 대응하는 조작 기록을 생성하게 하고, 아래 설명의 편의를 위해, 당해 조작 기록을 제2 조작 기록이라고 지칭한다. 여기 서, 백그라운드가 타깃 모듈의 모듈 데이터를 삭제할 경우, 백그라운드는 타깃 모듈의 모듈 데이터를 기타 자장 장소로 백업하고, 다음에 다시 백그라운드 데이터 중 타깃 모듈의 모듈 데이터를 삭제함으로써, 후에 빠른 속도 로 삭제된 데이터를 회복하는 데에 편리하다. 타깃 조작을 취소할 경우, 아래와 같은 몇 개 과정을 포함한다: 1) 제1 조작 기록이 제2 조작 기록 전에 생성되기에, 상술한 타깃 조작의 역조작을 구현하기 위해, 포그라운드 는 먼저 제2 조작 기록에 기초하여 백그라운드로 모듈 임포트 명령을 전송하는 바, 즉, 상술한 제2 모듈 업데이 트 명령을 전송하여, 백그라운드가 데이터 센터 내에 타깃 모듈의 모듈 데이터를 추가하도록 지시한다. 2) 다음에 포그라운드가 제1 조작 기록에 기초하여 백그라운드로 모듈 1과 모듈 2의 연결 구축 명령을 전송하는 바, 즉, 상술한 제2 논리적 관계 업데이트 명령을 전송하여, 백그라운드가 데이터 센터의 각 기타 모듈의 모듈 데이터에 타깃 모듈과 당해 기타 모듈 사이의 논리적 관계를 추가하도록 지시한다. 3) 포그라운드가 백그라운드로부터 모듈 인터페이스 데이터를 획득하고, 당해 모듈 인터페이스 데이터가 바로 타깃 모듈의 모듈 데이터 중 타깃 모듈의 표시 방식이며, 획득된 표시 방식에 기초하여 상호작용 인터페이스 상 에 타깃 모듈을 다시 표시한다. 상술한 전체 과정은 포그라운드를 드라이브로 이용하고, 백그라운드가 수동적으로 응답하며, 일부 데이터 획득, 임포트의 기본 인터페이스를 제공한다. 현재, 포그라운드가 백그라운드로 명령을 전송하는 것은 백그라운드의 인터페이스를 콜하는 것을 통해 구현되는 바, 즉, 백그라운드가 일련의 인터페이스를 제공한다. 포그라운드가 명령을 전송하는 것을 필요로 할 경우, 백 그라운드의 특정 인터페이스를 콜하여 당해 명령을 전송하고 백그라운드를 제어하여 특정 구체적인 조작을 수행 한다. 예컨대, 백그라운드가 논리적 관계 삭제 인터페이스 및 모듈 삭제 인터페이스를 제공하며, 이러한 장면 하에, 만약 타깃 조작이 모듈 삭제일 경우, 포그라운드가 백그라운드로 전송한 제1 논리적 관계 업데이트 명령 은 당해 논리적 관계 삭제 인터페이스를 콜하는 것을 통해 구현될 수 있으며, 포그라운드가 백그라운드로 전송 한 제1 모듈 업데이트 명령은 당해 모듈 삭제 인터페이스를 콜하는 것을 통해 구현될 수 있다. 상술한 포그라운드를 센터로 사용하는 구현 방식 중, 구체적인 조작에 어떤 것들이 들어 있고, 또한 영향 범위 가 어떠한지는 포그라운드가 가장 잘 알며, 백그라운드는 단지 인터페이스만 제공하고, 구체적인 업무에 대해 관심할 필요가 없으며, 따라서 언두 과정 중 시스템이 더 쉽게 안정될 수 있다. 백그라운드를 센터로 사용 이때, 상술한 단계 201의 구현 과정은 아래와 같을 수 있다: 포그라운드가 타깃 조작에 기초하여 상호작용 인터 페이스를 업데이트하고, 다음에 포그라운드가 백그라운드로 업데이트 명령을 전송하여, 당해 업데이트 명령은 백그라운드를 지시하여 타깃 조작에 기초하여 데이터 센터의 각 기타 모듈의 모듈 데이터 중 당해 기타 모듈과 타깃 모듈 사이의 논리적 관계, 및 데이터 센터 내의 타깃 모듈의 모듈 데이터를 업데이트하게 한다. 동시에 백 그라운드는 전술한 각 조작에 대응하는 조작 기록을 생성한다. 상응하게, 상술한 단계 202의 구현 과정은 아래와 같을 수 있다: 포그라운드가 백그라운드로 회복 명령을 전송 하고, 당해 회복 명령은: 백그라운드가 로컬에 저장된 조작 기록이 지시하는 타깃 조작의 역조작에 기반하여, 데이터 센터의 각 기타 모듈의 모듈 데이터 중 당해 기타 모듈과 타깃 모듈 사이의 논리적 관계, 및 데이터 센 터 내의 타깃 모듈의 모듈 데이터를 타깃 조작을 수행하기 전의 상태로 회복하도록 지시한다. 포그라운드는 백 그라운드로부터 업데이트된 타깃 모듈의 모듈 데이터 중의 표시 방식을 획득하고, 업데이트된 표시 방식에 기초 하여 상호작용 인터페이스를 업데이트한다. 예컨대, 타깃 조작이 도 1에 도시된 모듈 2에 대한 삭제 조작일 경우, 만약 백그라운드를 센터로 사용하면, 단 계 201 및 단계 202의 구체적인 과정은 아래와 같다. 타깃 조작을 수행할 때, 아래와 같은 몇 개 과정을 포함한다: 1) 포그라운드가 모듈 삭제 명령을 검출한 후, 먼저 상호작용 인터페이스 상의 타깃 모듈을 삭제하고, 다음에 백그라운드로 모듈 삭제 명령을 전송하며, 당해 모듈 삭제 명령은 타깃 모듈의 식별자를 휴대한다. 2) 백그라운드가 모듈 삭제 명령을 수신한 후, 먼저 각 기타 모듈의 모듈 데이터 중 타깃 모듈에 상관되는 연결 데이터를 기타 자장 장소로 백업하고, 다음에 다시 데이터 센터 내의 각 기타 모듈의 모듈 데이터 중 타깃 모듈 에 상관되는 연결 데이터를 삭제하고, 또한 당해 연결 데이터 삭제 조작에 대응하는 조작 기록을 생성하며, 제3 조작 기록으로 표기한다. 여기서, 각 기타 모듈의 모듈 데이터 중 타깃 모듈에 상관되는 연결 데이터는 타깃 모 듈과 당해 기타 모듈 사이의 논리적 관계를 가리킨다. 3) 백그라운드는 타깃 모듈의 모듈 데이터를 기타 자장 장소로 백업하고, 또한 데이터 센터 내의 타깃 모듈의 모듈 데이터를 삭제하며, 또한 당해 모듈 데이터삭제 조작에 대응하는 조작 기록을 생성하고, 제4 조작 기록으 로 표기한다. 타깃 조작을 취소할 경우, 아래와 같은 몇 개 과정을 포함한다: 1) 포그라운드가 백그라운드로 언두 명령을 전송한다. 2) 백그라운드가 조작 기록을 쿼리하고(query), 상술한 제4 조작 기록에 기초하여 마지막 하나의 조작이 모듈의 모듈 데이터를 삭제하는 것임을 쿼리하여, 모듈의 모듈 데이터를 삭제하는 역조작을 수행하는 바, 즉 백업된 데 이터로부터 타깃 모듈의 모듈 데이터를 데이터 센터로 임포트한다. 3) 백그라운드가 조작 기록을 쿼리하고, 상술한 제3 조작 기록에 기초하여 모듈 데이터 삭제의 이전 하나의 조 작이 모듈 연결 데이터를 삭제하는 것임을 쿼리하고, 모듈 연결 데이터를 삭제하는 역조작을 수행하는 바, 즉 백업된 데이터 중 각 기타 모듈의 모듈 데이터로부터 타깃 모듈에 상관되는 연결 데이터를 데이터 센터에 추가 한다. 4) 백그라운드는 포그라운드에 언두 완료를 통지하고, 포그라운드는 백그라운드로부터 최신의 타깃 모듈의 표시 방식을 획득하고, 상호작용 인터페이스를 업데이트한다. 전체 과정은 포그라운드가 명령을 전송하는 것을 드라이브로 이용하고, 백그라운드가 전체 데이터 기록과 역조 작(reverse operation)을 제공하는 것을 통해, 데이터 삭제와 회복을 구현한다. 포그라운드는 데이터 쿼리와 업 데이트에 사용된다. 설명해야 할 것은, 전술한 포그라운드를 센터로 사용하는 구현 방식 중 구체적인 조작에 어 떤 것들이 있는지, 또한 영향 범위가 어떠한지는 포그라운드가 가장 잘 알며, 이는 개발자가 수시로 타깃 조작 의 실제 처리 상황을 요해하고 또한 타깃 조작에 대한 실제 처리 상황을 컨트롤하는 데에 편리하다. 따라서, 본 출원의 실시예를 응용할 경우, 포그라운드를 센터로 사용하는 구현 방식을 사용하는 것을 고려할 수 있다. 추가로, 상술한 타깃 모듈 삭제에 대응하는 데이터 실제 구현 방식에는 여러 가지가 있을 수 있다. 도 4에 도시 된 바와 같이, 실제 흐름도는 아주 복잡하며, 이러한 경우, 만약 타깃 조작이 타깃 모듈에 대한 삭제 조작이면, 이러한 복잡한 관계하의 언두 및 리두에 대처하기 위해, 비교적 복잡한 삭제 후에 언두를 수행하는 장면에 대해, 두 가지 책략이 있다. 1) 가짜(false) 삭제 책략. 타깃 조작에 기초하여 타깃 모듈을 삭제할 경우, 단지 이 타깃 모듈의 모듈 데이터 를 삭제 표기로 설정하고, 실제로 삭제하지 않으며, 다음에 각 기타 모듈과 삭제된 타깃 모듈 사이의 논리적 관 계를 제거한다. 타깃 조작을 언두할 경우, 삭제 표기를 제거하고, 또한 데이터 센터 내의 각 기타 모듈과 당해 타깃 모듈 사이의 논리적 관계를 회복한다. 즉, 가짜 삭제 책략 중, 전술한 포그라운드가 타깃 조작에 기초하여 순서대로 백그라운드로 하나 또는 복수 개 의 제1 데이터 업데이트 명령을 전송하는 구체적인 구현 방식은 아래와 같을 수 있다: 포그라운드가 먼저 백그 라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송한 후, 백그라운드가 제1 논리적 관계 업데이트 명령을 수신할 경우, 백그라운드가 각 기타 모듈의 모듈 데이터 중 당해 기타 모듈과 타깃 모듈 사이의 논리적 관계를 삭제하고, 백그라운드가 제1 모듈 업데이트 명령을 수신할 경우, 데이터 센터 내의 타깃 모듈의 모듈 데이터에 삭제 표기를 추가한다. 상응하게, 포그라운드가 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여 순서대로 백그라운드로 하나 또 는 복수 개의 제2 데이터 업데이트 명령을 전송하는 구체적인 구현 방식은 아래와 같을 수 있다: 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여, 포그라운드가 먼저 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송하여, 백그라운드가 제2 모듈 업데이트 명령을 수신할 경 우, 타깃 모듈의 모듈 데이터의 모듈 데이터의 삭제 표기를 삭제하며, 백그라운드가 제2 논리적 관계 업데이트 명령을 수신할 경우, 각 기타 모듈의 모듈 데이터에 당해 기타 모듈과 타깃 모듈 사이의 논리적 관계를 추가한 다. 2) 익스포트 및 임포트 책략. 가 타깃 조작에 기초하여 타깃 모듈을 삭제할 경우, 이 타깃 모듈에 대응하는 데 이터를 익스포트하고, 다음에 다시 당해 타깃 모듈에 대응하는 데이터를 제거한다. 언두를 수행할 경우, 당해 타깃 모듈의 모듈 데이터를 임포트하고, 또한 이전에 익스포트된 데이터에 기초하여 각 기타 모듈과 당해 타깃 모듈 사이의 연결 및 구독 관계를 회복한다. 즉, 데이터를 삭제할 경우, 먼저 상관되는 데이터를 익스포트하고, 다음에 다시 직접 데이터 센터 내의 관련 데이터를 삭제한다. 즉, 익스포트 및 임포트 책략 중, 포그라운드가 타깃 조작에 기초하여 순서대로 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하는 구체적인 구현 방식은 아래와 같을 수 있다: 포그라운드가 먼저 백 그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송하여, 백그라운드 를 제어하여 먼저 데이터 센터의 각 기타 모듈의 모듈 데이터 중 타깃 모듈과 당해 기타 모듈 사이의 논리적 관 계를 삭제하고, 다시 타깃 모듈의 모듈 데이터를 삭제하게 한다. 상응하게, 포그라운드가 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여 순서대로 백그라운드로 하나 또 는 복수 개의 제2 데이터 업데이트 명령을 전송하는 구체적인 구현 방식은 아래와 같을 수 있다: 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여, 포그라운드는 먼저 백그라운드로 제2 모듈 업데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송하여, 백그라운드를 제어하여 먼저 데이터 센터 내의 타깃 모듈의 모듈 데이터를 회복하고, 다시 각 기타 모듈의 모듈 데이터 중 타깃 모듈과 당해 기타 모듈 사이의 논리적 관계를 회복한다. 추가로, 상술한 가짜 삭제 책략 중, 포그라운드 및 백그라운드 데이터의 동기화의 관계로 인해, 하나의 모듈을 삭제한 후, 만약 포그라운드 및 백그라운드가 단지 삭제만 표기하면, 전체 흐름도의 과정을 수행할 때, 삭제 표 기 모듈에 대해 특수 처리를 수행해야 하지만, 이를 생략하고, 수행을 트리거하지 않는다. 이러한 특수한 데이 터가 많아진 후, 포그라운드 및 백그라운드 데이터의 유지보수에 영향을 줄 수 있으며, 불안정성을 초래할 수 있다. 따라서, 본 출원의 실시예를 응용할 경우, 임포트 및 익스포트 책략을 통해 타깃 모듈을 삭제하는 것을 고려할 수 있다. 추가로, 상술한 익스포트 및 임포트 책략 중, 후에 빠른 속도로 삭제된 데이터를 회복하는 데에 편리하기 위해, 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송하기 전에, 포그라운드가 백그라운드를 제어하여 데이터 센터 중 상기 타깃 모듈에 대응하는 데이터를 익스 포트하여 참조 저장 위치로 백업할 수 있다. 후속으로 포그라운드는 먼저 백그라운드로 제2 모듈 업데이트 명령 을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송한 후, 수신된 제2 모듈 업데이트 명령에 응답하여, 백그라운드가 참조 저장 위치로부터 타깃 모듈의 모듈 데이터를 데이터 센터로 임포트하고, 수신된 제2 논리적 관계 업데이트 명령에 응답하여, 백그라운드가 참조 저장 위치로부터 타깃 모듈과 각 기타 모듈 사이의 논리적 관계를 데이터 센터로 임포트한다. 추가로, 본 출원의 실시예에서, 타깃 조작이 모듈 삭제 조작일 경우, 동시에 한 배치(batch)의 모듈에 대해 동 일한 타깃 조작을 수행할 수 있는 바, 즉, 배치 삭제 조작이 존재하는 장면이다. 배치 삭제 조작을 수행할 경우, 단계 201 및 단계 202 중의 타깃 모듈의 수량은 복수 개이다. 이러한 장면 하에, 마찬가지로 두 가지 책략을 통해 상술한 타깃 조작의 수행 및 타깃 조작의 언두를 구현할 수 있다. 한 가지 책략은 조작을 센터로 사용하는 것이고, 또 한 가지 책략은 데이터를 센터로 사용하는 것이다. 첫 번째 책략: 조작을 센터로 사용한다. 여기서, 조작을 센터로 사용하는 것은 아래와 같다: 복수 개의 타깃 모듈에 대한 타깃 조작을 수행할 경우, 타 깃 조작을 단일 모듈에 대한 복수 개의 서브 조작으로 분할, 즉 각 서브 조작은 단지 하나의 모듈에 대한 것이 고, 다음에 복수 개의 서브 조작의 실행 순서에 따라 이 복수 개의 서브 조작을 수행함으로써, 복수 개의 타깃 모듈에 대한 타깃 조작을 구현한다. 복수 개의 타깃 모듈에 대한 타깃 조작을 수행할 경우, 매번 하나의 서브 조작을 수행할 경우, 모두 당해 서브 조작에 대한 하나의 조작 기록을 생성하고 저장한다. 언두가 이 복수 개의 타깃 모듈에 대한 타깃 조작일 경우, 저장된 조작 기록이 지시하는 서브 조작의 역조작에 따라 언두 동작을 완 성한다. 조작을 센터로 사용하는 책략 중, 전술한 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전 송하는 구체적인 구현 방식은 아래와 같을 수 있다: 포그라운드가 백그라운드로 구독 관계 삭제 명령 A를 전송 하고, 구독 관계 삭제 명령 A는 백그라운드를 지시하여 각 타깃 모듈에 대해, 후에 수행하는 모듈 각각과 먼저 수행하는 모듈 및 타깃 모듈 사이의 구독 관계를 삭제하게 하고, 후에 수행하는 모듈이 포그라운드에 표시된 흐 름도 중 타깃 모듈에 위치한 후에 수행하는 모듈이며, 먼저 수행하는 모듈이 흐름도 중 타깃 모듈 앞에 위치한 먼저 수행하는 모듈이고; 포그라운드가 백그라운드로 구독 관계 삭제 명령 B를 전송하며, 구독 관계 삭제 명령 B는 백그라운드를 지시하여 복수 개의 타깃 모듈 사이의 구독 관계를 삭제하게 하고; 포그라운드가 백그라운드 로 구독 관계 삭제 명령 C를 전송하고, 구독 관계 삭제 명령 C는 백그라운드를 지시하여 각 타깃 모듈과 먼저 수행하는 모듈 사이의 구독 관계를 삭제하게 하며; 포그라운드가 백그라운드로 연결 관계 삭제 명령 A를 전송하 고, 연결 관계 삭제 명령 A는 백그라운드를 지시하여 후에 수행하는 모듈 각각과 각 타깃 모듈 사이의 연결 관 계를 삭제하게 하며; 포그라운드가 백그라운드로 연결 관계 삭제 명령 B를 전송하고, 연결 관계 삭제 명령 B는 백그라운드를 지시하여 복수 개의 타깃 모듈 사이의 연결 관계를 삭제하게 하며; 포그라운드가 백그라운드로 연 결 관계 삭제 명령 C를 전송하고, 연결 관계 삭제 명령 C은 백그라운드를 지시하여 각 타깃 모듈과 먼저 수행하 는 모듈 사이의 연결 관계를 삭제하게 한다. 포그라운드가 상술한 구현 방식을 통해 제1 논리적 관계 업데이트 명령을 전송한 후, 다시 백그라운드로 제1 모 듈 업데이트 명령을 전송하여, 백그라운드를 제어하여 복수 개의 타깃 모듈 중 각 타깃 모듈의 모듈 데이터 중 나머지 데이터를 삭제하게 한다. 즉, 조작을 센터로 사용하는 책략 중, 포그라운드는 먼저 복수 개의 타깃 모듈 사이, 및 복수 개의 타깃 모듈 중 각 타깃 모듈과 각 기타 모듈 사이의 구독 관계 및 선 연결 관계에 대해 분석을 수행하고, 복수 개의 제1 논 리적 관계 업데이트 명령을 통해 이러한 구독 관계 및 선 연결 관계를 삭제하고, 다음에 다시 각 타깃 모듈의 모듈 데이터를 삭제한다. 두 번째 책략: 데이터를 센터로 사용한다. 데이터를 센터로 사용하는 책략은 아래와 같다: 복수 개의 타깃 모듈에 대한 타깃 조작을 수행할 경우, 복수 개 의 타깃 모듈을 하나의 전체로 간주하고, 이때, 만약 이 복수 개의 타깃 모듈을 삭제해야 할 필요가 있을 경우, 전체 방식으로 이 복수 개의 타깃 모듈의 모듈 데이터를 삭제하고, 다음에 다시 이 복수 개의 타깃 모듈 중 에 지 타깃 모듈과 기타 모듈 사이의 논리적 관계를 업데이트한다. 여기서, 엣지 타깃 모듈이 이 복수 개의 타깃 모듈 중 기타 모듈과 논리적 관계가 존재하는 타깃 모듈이다. 모듈 데이터를 업데이트하는 경우 및 논리적 관계 를 업데이트하는 경우는 모두 조작 기록을 생성하고, 이 복수 개의 타깃 모듈에 대한 타깃 조작을 언두할 경우, 저장된 조작 기록이 지시하는 타깃 조작의 역조작에 따라 언두 동작을 완료한다. 데이터를 센터로 사용하는 책략 중, 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하 고, 다시 제1 모듈 업데이트 명령을 전송하는 구체적인 구현 방식은 아래와 같을 수 있다: 포그라운드가 백그라 운드로 제1 구독 관계 삭제 명령을 전송하고, 제1 구독 관계 삭제 명령이 백그라운드를 지시하여 각 기타 모듈 의 모듈 데이터 중 당해 기타 모듈과 에지 타깃 모듈 사이의 구독 관계를 삭제하게 하고; 포그라운드가 백그라운드로 제1 연결 관계 삭제 명령을 전송하 며, 제1 연결 관계 삭제 명령이 백그라운드를 지시하여 각 기타 모듈의 모듈 데이터 중 당해 기타 모듈과 에지 타깃 모듈 사이의 연결 관계를 삭제하게 하며; 포그라운드가 백그라운드로 제1 모듈 삭제 명령을 전송하고, 제1 모듈 삭제 명령은 백그라운드를 지시하여 복수 개의 타깃 모듈의 모듈 데이터를 삭제하게 한다. 즉, 데이터를 센터로 사용하는 책략 중, 포그라운드는 복수 개의 타깃 모듈 중 에지 타깃 모듈과 기타 모듈 사 이의 구독 관계 및 선 연결 관계에 대해 분석을 수행하고, 복수 개의 제1 논리적 관계 업데이트 명령을 통해 이 러한 구독 관계 및 선 연결 관계를 삭제하며, 다음에 다시 각 타깃 모듈의 모듈 데이터를 삭제하기만 하면 된다. 각 타깃 모듈 내부의 구독 관계 또는 선 연결 관계에 대해 하나하나씩 삭제를 수행할 필요가 없음으로써, 타깃 조작에 필요한 시간을 절약한다. 도 5는 본 출원의 실시예에서 제공하는 모듈을 삭제하는 모식도인 바, 삭제 조작, 추가 조작 언두, 삭제 조작 리두 등에 적용된다. 도 5에 도시된 바와 같이, 흐름도 중 모듈 2 내지 모듈5를 삭제할 경우, 두 가지 책략이 존재한다. 가, 조작을 센터로 사용하여, 일괄 조작을 단일 모듈에 대한 서브 조작의 조합으로 분해하며, 각 서브 조작은 구체적으로 아래와 같다: 1)순서대로 모듈 6 내지 10과 모듈 1 내지 5의 구독 관계를 삭제, 즉 모듈 6 내지 10 중 각 모듈과 모듈 1 내지 5 중 각 모듈 사이의 구독 관계를 각각 삭제한다; 2)순서대로 모듈3 내지 5와 모듈 1 내지 2의 구독 관계를 삭제, 즉 모듈3 내지 5 중 각 모듈과 모듈 1 내지 2 중 각 모듈 사이의 구독 관계를 각각 삭제한다; 3) 모듈 2와 모듈 1의 구독 관계를 삭제한다; 4) 순서대로 모듈6와 모듈3의 연결선, 모듈7와 모듈4의 연결선, 모듈8와 모듈5의 연결선을 삭제, 즉 모듈6 및 모듈3 사이의 연결 관계, 모듈7 및 모듈4 사이의 연결 관계, 모듈8 및 모듈5 사이의 연결 관계를 각각 삭제한다; 5) 순서대로 모듈3 내지 5와 모듈 2의 연결선을 삭제, 즉 모듈3 내지 5 중 각 모듈과 모듈 2 사이의 연결 관계 를 삭제한다; 6) 모듈 2와 모듈 1의 연결선을 삭제, 즉 모듈 2와 모듈 1 사이의 연결 관계를 삭제한다; 7) 순서대로 모듈3 내지 5를 삭제, 즉 모듈3 내지 5 중 각 모듈의 모듈 데이터를 삭제한다; 8) 모듈 2를 삭제, 즉 모듈 2의 모듈 데이터를 삭제한다. 언두 시, 8)에서 1)로의 순서로 역방향으로 수행하여, 모듈 데이터, 연결 관계, 구독 관계를 하나하나씩 추가함 으로써, 모듈 2 내지 모듈5에 대한 삭제 조작의 언두를 구현한다. 나, 데이터를 센터로 사용하며, 일괄로 임포트 및 익스포트하는 책략: 1) 데이터 센터 내의 모듈 2 내지 5 각자의 모듈 데이터를 하나의 전체로 익스포트하여 참조 위치에 백업한다. 2) 모듈6 내지 10의 모듈 데이터 중 모듈 1 내지 5와의 사이의 구독 관계를 삭제하고, 또한 조작 기록을 생성한 다. 즉, 모듈6 내지 10을 하나의 전체로 간주하고, 모듈 1 내지 5도 하나의 전체로 간주하며, 모듈6 내지 10 이 전체의 모듈 데이터 중 모듈 1 내지 5 이 전체와의 사이의 구독 관계를 삭제하고, 당해 구독 관계는 구체적으로 모듈 2 내지 5 중 에지 모듈3/4/5과 기타 모듈6 내지 10 사이의 구독 관계이다. 3) 기타 모듈의 모듈 데이터 중 모듈 2 내지 5와의 사이의 연결 관계를 삭제하고, 또한 모듈 2 내지 5 각자의 모듈 데이터를 삭제하며, 또한 조작 기록을 생성한다. 언두 시: 1) 모듈 2 내지 5 각자의 모듈 데이터를 하나의 전체로 임포트한다; 2) 조작 기록을 통해 기타 모듈과 모듈 2 내지 5의 연결선을 회복한다. 구체적으로 모듈 1의 모듈 데이터 중 모 듈 2 내지 5와의 사이의 연결 관계, 및 모듈6 내지 10 중 임의의 모듈의 모듈 데이터 중 모듈 2 내지 5와의 사 이의 연결 관계를 포함한다; 3) 조작 기록을 통해 모듈6 내지 10과 모듈 1 내지 5의 구독 관계를 회복한다. 구체적으로 모듈 1의 모듈 데이 터 중 모듈 2 내지 5와의 사이의 구독 관계, 및 모듈6 내지 10 중 임의의 모듈의 모듈 데이터 중 모듈 2 내지 5 와의 사이의 구독 관계를 포함한다. 상술한 첫 번째 책략 중 일괄 조작을 많은 단일 조작으로 전환하는 기술에 있어서, 처리 순서가 언두 순서를 결 정하는 바, 순서에 오류가 생기기만 하면, 연결 관계를 회복할 때 모듈이 아직 회복되지 않아, 에러 발생을 초 래한다. 즉 모두 회복한 후, 특정 모듈과 모듈 사이의 연결 관계가 적을 수도 있으며, 따라서 흐름도를 이전의 상태로 완전히 회복하지 못한다. 상술한 두 번째 책략 중 일괄로 임포트 및 익스포트하는 책략은 익스포트된 전 체와 주변의 관계를 기록하기만 하면 되며, 익스포트된 전체 내부 관계가 이미 익스포트 모듈의 모듈 데이터에 포함된다. 언두 또는 리두 시, 먼저 모듈의 모듈 데이터를 임포트하고, 다시 각 기타 모듈과 당해 전체의 외부 관계를 회복하기만 하면 된다. 추가로, 본 출원의 실시예에서, 첫 번째 책략 중 조작을 센터로 사용하는 책략은 단일 모듈의 데이터 변화의 언 두 리두 장면에 적용된다. 예컨대: 특정 모듈의 위치 또는 컬러를 수정한 후, 위치 또는 컬러 변화의 역조작을 수행하는 것은 가장 경제적이고 유효한 방법이다. 따라서, 가능한 구현 방식에서, 타깃 모듈의 수량이 하나인 경우, 포그라운드가 타깃 조작에 기초하여 백그라운 드로 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하기 전에, 포그라운드가 타깃 조작을 하나 또는 복 수 개의 서브 조작으로 분할할 수 있다. 이러한 장면 하에, 전술한 하나 또는 복수 개의 제1 데이터 업데이트 명령은 하나 또는 복수 개의 서브 조작과 각각 대응하고, 백그라운드가 하나 또는 복수 개의 서브 조작에 기초 하여 타깃 조작을 수행한다. 즉, 타깃 조작을 복수 개의 서브 조작으로 분할한 후, 단계별로 이 복수 개의 서브 조작을 수행하고, 또한 조작 기록을 생성함으로써, 후속으로 이 복수 개의 서브 조작의 조작 기록에 기초하여 타깃 조작을 언두하는 데에 편리하다. 선택 가능하게, 조작을 언두한 후, 사용자가 당해 언두 조작을 철회할 수 있는 바, 즉 당해 조작을 다시 실행할 수 있다. 이때 도 6에 도시된 단계 203를 통해 상술한 리두 과정을 구현할 수 있다. 단계 203: 타깃 조작에 대한 리두 명령을 검출할 경우, 포그라운드는 타깃 조작에 기초하여 백그라운드를 제어 하여 데이터 센터 중 타깃 모듈에 대응하는 데이터를 업데이트하게 하고, 포그라운드는 업데이트된 타깃 모듈에 대응하는 데이터에 기초하여 상호작용 인터페이스를 업데이트한다. 단계 203의 구현 방식은 구체적으로 단계 201의 구현 방식과 거의 동일하며, 여기서 더 이상 설명하지 않는다."}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "요약하면, 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템 중, 백그라운드의 데이터 센 터 내에 저장된 모듈 데이터는 모듈의 표시 방식, 모듈의 기능 데이터 및 모듈 사이의 논리적 관계를 포함하는 바, 즉 백그라운드에 포그라운드 데이터 및 백그라운드 데이터를 동시에 저장한다. 이로부터 알 수 있다시피, 본 출원의 실시예에서, 백그라운드를 전체 데이터의 데이터 센터로 이용한다. 이러한 방법으로, 포그라운드가 타깃 모듈에 대한 타깃 조작을 검출할 경우, 백그라운드를 제어하여 포그라운드 및 백그라운드 데이터를 업데이 트하게 할 수 있고, 타깃 조작을 취소할 경우, 마찬가지로 백그라운드를 제어하여 포그라운드 및 백그라운드 데이터를 업데이트하게 함으로써, 타깃 조작을 실행하거나 또는 타깃 조작을 언두하는 과정 중 포그라운드 상호작 용 인터페이스 상에 표시된 내용, 및 포그라운드 및 백그라운드 데이터 사이의 일관성을 확보할 수 있다."}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "아래 본 출원의 실시예에서 제공하는 각 기술적 효과에 대해 요약하게 설명한다. 본 출원의 실시예의 혁신점은 포그라운드 및 백그라운드 분리 시스템의 언두 또는 리두에 대해 몇 가지 구현 가 능한 구현 책략을 제공하는 것이다. 1) 포그라운드 및 백그라운드에 모두 데이터가 있을 경우, 데이터 싱글 센터 책략을 이용하여, 백그라운드에 의 해 전부 데이터를 저장한다. 2) 포그라운드 및 백그라운드가 분리된 경우, 조작 기록에 대해, 포그라운드를 센터로 사용할 수 있다. 언두 또 는 리두 시, 포그라운드에 의해 전체 언두 과정을 드라이브한다. 3) 복잡하고, 관계가 많은 흐름도에 대해, 언두 삭제 장면 중, 가짜 삭제 책략이 아닌 익스포트 및 임포트 데이 터 방식을 사용할 수 있다. 4) 복잡하고, 관계가 많은 흐름도에 대해, 일괄적으로 데이터 삭제 언두 시, 조작 조합 방식이 아니라 익스포트 및 임포트 데이터 방식을 사용할 수 있다. 5) 흐름도 중, 싱글 데이터 변화에 대해, 조작을 센터로 사용하는 책략을 이용할 수 있다. 상술한 책략을 통해 포그라운드 및 백그라운드 분리 시스템의 언두 또는 리두를 양호하게 구현할 수 있으며, 복 잡도, 메모리 사용, 시스템 안정성을 균형되게 구현한다. 상술한 모든 선택 가능한 기술적 해결방안은, 모두 임의의 결합을 통해 본 출원의 선택 가능한 실시예를 형성할 수 있으며, 본 출원의 실시예는 이에 대해 더 이상 설명하지 않는다. 도 7은 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치의 구 조 모식도로서, 당해 장치는 소프트웨어, 하드웨어 또는 양자의 결합을 통해 구현될 수 있다. 당해 장치는 포그 라운드 및 백그라운드 분리 시스템에 응용되며, 포그라운드 및 백그라운드 분리 시스템은 포그라운드 및 백그라 운드를 포함하고, 포그라운드에는 상호작용 인터페이스가 표시되어 있으며, 상호작용 인터페이스는 복수 개의 모듈을 표시하는 데에 사용되고, 백그라운드에는 데이터 센터가 구성되어 있으며, 데이터 센터는 복수 개의 모 듈의 각 모듈의 모듈 데이터를 저장하는 데에 사용되고, 임의의 모듈의 모듈 데이터는 당해 모듈의 표시 방식, 당해 모듈의 기능 데이터 및 당해 모듈과 각 기타 모듈 사이의 논리적 관계를 포함한다. 도 7에 도시된 바와 같이, 당해 장치는 아래와 같은 몇 개 모듈을 포함한다: 제1 제어 모듈, 이는 타깃 모듈에 대한 타깃 조작에 응답하여, 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제어하여 상기 데이터 센터 내의 상기 타깃 모듈에 대응하는 데이터를 업데이트하게 하고, 또한 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 데이터에 기초하여, 상기 상호작용 인터페이스를 업 데이트하게 하는 데에 사용되며, 상기 타깃 모듈이 상기 복수 개의 모듈 중 하나 또는 복수 개의 모듈이고, 상 기 타깃 조작을 상기 타깃 모듈에 대한 임의의 조작으로 이용한다; 제2 제어 모듈, 이는 상기 타깃 조작에 대한 언두 명령을 검출한 경우, 포그라운드가 상기 언두 명령에 기 초하여 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 데이터를 회복하게 하고, 또한 포그라운드가 회복 후의 상기 타깃 모듈에 대응하는 데이터에 기초하여, 상기 상호작용 인터페이스를 업데 이트하게 하는 데에 사용된다. 상술한 장치에 기초하여, 가능한 구현 방식에서, 도 7에 도시된 바와 같이, 당해 장치는: 제3 제어 모듈을 더 포함하는 바, 상기 제3 제어 모듈은, 상기 타깃 조작에 대한 리두 명령을 검출할 경우, 포그라운드가 상기 타깃 조작에 기초하여 상기 백그라운드를 제어하여 데이터 센터 중 상기 타깃 모듈에 대응하는 데이터를 업데이트하게 하고, 또한 포그라운드가 업데이트된 상기 타깃 모듈에 대응하는 데이터에 기 초하여, 상기 상호작용 인터페이스를 업데이트하게 하는 데에 사용된다. 상술한 장치에 기초하여, 가능한 구현 방식에서, 상기 제1 제어 모듈은: 포그라운가 상기 타깃 조작에 기초하여 순서대로 상기 백그라운드로 하나 또는 복수 개의 제1 데이터 업데이트 명령을 전송하게 하고, 상기 하나 또는 복수 개의 제1 데이터 업데이트 명령 중 임의의 제1 데이터 업데이트 명령이 상기 백그라운드를 지시하여 상기 타깃 모듈에 대응하는 데이터 중의 일부 데이터를 업데이트하게 하고; 포그라운드가 상기 하나 또는 복수 개의 데이터 업데이트 명령을 전송하는 것에 기초하여 조작 기록을 생성하게 하는 데에 사용되며; 상응하게, 상기 제2 제어 모듈은: 포그라운드가 상기 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여 순서대로 상기 백그라운드로 하나 또 는 복수 개의 제2 데이터 업데이트 명령을 전송하게 하고, 상기 하나 또는 복수 개의 제2 데이터 업데이트 명령 중 임의의 제2 데이터 업데이트 명령이 상기 백그라운드를 지시하여 상기 데이터 센터 중 상기 타깃 모듈에 대 응하는 데이터 중의 일부 데이터를 상기 타깃 조작을 수행하기 전의 상태로 회복하게 하는 데에 사용된다. 상술한 장치에 기초하여, 가능한 구현 방식에서, 상기 타깃 조작이 상기 타깃 모듈에 대한 추가 조작일 경우, 상기 제1 제어 모듈은: 포그라운드가 먼저 상기 백그라운드로 제1 모듈 업데이트 명령을 전송하고, 다시 제1 논리적 관계 업데이트 명 령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터 내에 상기 타깃 모듈의 모듈 데이터를 추가 하고, 다시 기타 모듈의 모듈 데이터에 상기 타깃 모듈과 상기 기타 모듈 사이의 논리적 관계를 추가하게 하는 데에 사용되며; 상응하게, 상기 제2 제어 모듈은: 포그라운드가 상기 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여, 먼저 상기 백그라운드로 제2 논리적 관계 업데이트 명령을 전송하고, 다시 제2 모듈 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터의 각 기타 모듈의 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 논리적 관계를 삭 제하고, 다시 상기 데이터 센터 내의 상기 타깃 모듈의 모듈 데이터를 삭제하게 하는 데에 사용된다. 상술한 장치에 기초하여, 가능한 구현 방식에서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 제1 제어 모듈은: 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터의 각 기타 모듈의 모듈 데이터 중 상기 타깃 모 듈과 상기 기타 모듈 사이의 논리적 관계를 삭제하고, 다시 데이터 센터 내의 상기 타깃 모듈의 모듈 데이터를 삭제하게 하는 데에 사용된다; 상응하게, 상기 제2 제어 모듈은: 포그라운드가 상기 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여, 먼저 상기 백그라운드로 제2 모듈 업 데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 먼저 상기 데이터 센터 내의 상기 타깃 모듈의 모듈 데이터를 회복하고, 다시 각 기타 모듈의 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 논리적 관계를 회복하게 하는 데에 사용된다. 상술한 장치에 기초하여, 가능한 구현 방식에서, 상기 타깃 조작이 상기 타깃 모듈에 대한 삭제 조작일 경우, 상기 제1 제어 모듈은: 포그라운드가 먼저 백그라운드로 제1 논리적 관계 업데이트 명령을 전송하고, 다시 제1 모듈 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 상기 제1 논리적 관계 업데이트 명령을 수신할 경우 데이터 센터의 각 기타 모듈의 모듈 데이터 중 상기 기타 모듈과 상기 타깃 모듈 사이의 논리적 관계를 삭제하게 하고, 또한 상기 백그라운드를 제어하여 상기 제1 모듈 업데이트 명령을 수신할 경우, 상기 데이터 센터 내의 상기 타깃 모듈의 모듈 데이터에 삭제 표기를 추가하게 하는 데에 사용된다; 상응하게, 상기 제2 제어 모듈은: 포그라운드가 상기 조작 기록이 지시하는 타깃 조작의 역조작에 기초하여, 먼저 상기 백그라운드로 제2 모듈 업 데이트 명령을 전송하고, 다시 제2 논리적 관계 업데이트 명령을 전송하여, 상기 백그라운드를 제어하여 상기 제2 모듈 업데이트 명령을 수신할 경우 데이터 센터 내의 상기 타깃 모듈의 모듈 데이터의 삭제 표기를 삭제하 게 하고, 또한 상기 백그라운드를 제어하여 상기 제2 논리적 관계 업데이트 명령을 수신할 경우, 데이터 센터의 각 기타 모듈의 모듈 데이터에 상기 기타 모듈과 상기 타깃 모듈 사이의 논리적 관계를 추가하게 하는 데에 사 용된다. 상술한 장치에 기초하여, 가능한 구현 방식에서, 상기 장치는: 익스포트 모듈 및 임포트 모듈을 더 포함하되, 상기익스포트 모듈은, 상기 포그라운드가 먼저 백그라운드로 상 기 제1 논리적 관계 업데이트 명령을 전송하고, 다시 상기 제1 모듈 업데이트 명령을 전송하기 전에, 상기 포그 라운드가 상기 백그라운드를 제어하여 상기 데이터 센터 중 상기 타깃 모듈에 대응하는 데이터를 익스포트하여 참조 저장 위치로 백업하게 하는 데에 사용되고, 상기 타깃 모듈에 대응하는 데이터는 상기 타깃 모듈의 모듈 데이터, 및 각 기타 모듈의 모듈 데이터 중 상기 타깃 모듈과 상기 기타 모듈 사이의 논리적 관계를 포함한다; 상기 임포트 모듈은: 상기 포그라운드가 먼저 상기 백그라운드로 상기 제2 모듈 업데이트 명령을 전송하고, 다시 상기 제2 논리적 관 계 업데이트 명령을 전송한 후, 수신된 제2 모듈 업데이트 명령에 응답하여, 상기 백그라운드가 상기 참조 저장 위치로부터 상기 타깃 모듈의 모듈 데이터를 상기 데이터 센터로 임포트하게 하고, 수신된 제2 논리적 관계 업 데이트 명령에 응답하여, 상기 백그라운드가 상기 참조 저장 위치로부터 상기 타깃 모듈과 각 상기 기타 모듈 사이의 논리적 관계를 상기 데이터 센터로 임포트하는 데에 사용된다. 상술한 장치에 기초하여, 가능한 구현 방식에서, 상기 복수 개의 모듈 중 임의의 모듈과 각 기타 모듈 사이의 논리적 관계는 상기 임의의 모듈과 각 기타 모듈 사이의 연결 관계, 및 상기 임의의 모듈과 상기 각 기타 모듈 사이의 구독 관계를 포함한다. 상기 연결 관계는 상기 상호작용 인터페이스 상 상기 임의의 모듈과 각 기타 모 듈 사이의 선 연결 관계를 가리키고, 상기 구독 관계는 상기 임의의 모듈의 내부 파라미터, 입력 중 적어도 하 나와 각 기타 모듈의 출력 사이의 연관 관계, 및/또는, 상기 임의의 모듈의 출력과 각 기타 모듈의 내부 파라미 터, 입력 중 적어도 하나와의 사이의 연관 관계를 가리킨다. 상술한 장치에 기초하여, 가능한 구현 방식에서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 제1 제어 모듈 은: 상기 포그라운드가 상기 백그라운드로 제1 구독 관계 삭제 명령을 전송하게 하고, 상기 제1 구독 관계 삭제 명 령은 상기 백그라운드를 지시하여 각 기타 모듈의 모듈 데이터 중 상기 기타 모듈과 에지 타깃 모듈 사이의 구 독 관계를 삭제하게 하고, 상기 에지 타깃 모듈이 상기 복수 개의 타깃 모듈 중 상기 기타 모듈과 논리적 관계 가 존재하는 타깃 모듈이며; 상기 포그라운드가 상기 백그라운드로 제1 연결 관계 삭제 명령을 전송하게 하고, 상기 제1 연결 관계 삭제 명 령이 상기 백그라운드를 지시하여 각 기타 모듈의 모듈 데이터 중 상기 기타 모듈과 에지 타깃 모듈 사이의 연 결 관계를 삭제하게 하며; 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송하게 하고, 상기 제1 모듈 삭제 명령이 상기 백그라 운드를 지시하여 상기 복수 개의 타깃 모듈의 모듈 데이터를 삭제하게 하는 데에 사용된다. 상술한 장치에 기초하여, 가능한 구현 방식에서, 상기 타깃 모듈의 수량이 복수 개일 경우, 상기 제1 제어 모듈 은: 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 A를 전송하게 하고, 상기 구독 관계 삭제 명령 A는 상기 백그라운드가 각 상기 타깃 모듈에 대해, 후에 수행하는 모듈 각각과 먼저 수행하는 모듈 및 상기 타깃 모 듈 사이의 구독 관계를 삭제하는 것을 지시하며, 상기 후에 수행하는 모듈이 상기 포그라운드에 표시된 흐름도 중 상기 타깃 모듈 후에 수행되는 모듈이고, 상기 먼저 수행하는 모듈이 흐름도 중 상기 타깃 모듈 전에 수행되 는 모듈이며; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 B를 전송하게 하고, 상기 구독 관계 삭제 명령 B는 상기 백그라운드가 상기 복수 개의 타깃 모듈 사이의 구독 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 구독 관계 삭제 명령 C를 전송하게 하고, 상기 구독 관계 삭제 명령 C는 상기 백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 구독 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 A를 전송하게 하고, 상기 연결 관계 삭제 명령 A는 상기 백그라운드가 후에 수행하는 모듈 각각과 각 상기 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 B를 전송하게 하고, 상기 연결 관계 삭제 명령 B는 상기 백그라운드가 상기 복수 개의 타깃 모듈 사이의 연결 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 연결 관계 삭제 명령 C를 전송하게 하고, 상기 연결 관계 삭제 명령 C는 상기 백그라운드가 각 상기 타깃 모듈과 상기 먼저 수행하는 모듈 사이의 연결 관계를 삭제하는 것을 지시하며; 상기 포그라운드가 상기 백그라운드로 제1 모듈 삭제 명령을 전송하게 하고, 상기 제1 모듈 삭제 명령은 상기 복수 개의 타깃 모듈의 모듈 데이터 중 나머지 데이터를 삭제하는 것을 지시하는 데에 사용된다."}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "요약하면, 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템 중, 백그라운드의 데이터 센 터 내에 저장된 모듈 데이터는 모듈의 표시 방식, 모듈의 기능 데이터 및 모듈 사이의 논리적 관계를 포함하는 바, 즉 백그라운드에 포그라운드 데이터 및 백그라운드 데이터를 동시에 저장한다. 이로부터 알 수 있다시피, 본 출원의 실시예에서, 백그라운드를 전체 데이터의 데이터 센터로 이용한다. 이러한 방법으로, 포그라운드가 타깃 모듈에 대한 타깃 조작을 검출할 경우, 백그라운드를 제어하여 포그라운드 및 백그라운드 데이터를 업데이 트하게 할 수 있고, 타깃 조작을 취소할 경우, 마찬가지로 백그라운드를 제어하여 포그라운드 및 백그라운드 데 이터를 업데이트하게 함으로써, 타깃 조작을 실행하거나 또는 타깃 조작을 언두하는 과정 중 포그라운드 상호작 용 인터페이스 상에 표시된 내용, 및 포그라운드 및 백그라운드 데이터 사이의 일관성을 확보할 수 있다. 설명해야 할 것은: 상술한 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치가 모듈에 대한 조작을 처리할 때, 단지 상술한 각 기능 모듈의 분할에 대해 예를 들어 설명하였지만, 실제 응용 중, 수요에 따라 상술한 기능을 상이한 기능 모듈에 할당하여 완성할 수 있는 바, 즉 기기의 내부 구조를 상이한 기능 모듈로 분할하여, 상술한 전부 또는 일부 기능을 구현할 수 있다. 추가로, 상술한 실시예에서 제공 하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치와 포그라운드 및 백그라운드 분리 시스 템에 사용되는 모듈 처리 방법 실시예는 동일한 구상에 속하며, 그 구체적인 구현 과정은 방법 실시예를 참조하 며, 여기서 더 이상 설명하지 않는다. 도 8은 본 출원의 실시예에서 제공하는 단말의 구조 모식도이다. 전술한 실시예에 언급된 포그라운드는 모 두 도 8에 도시된 구조를 통해 구현될 수 있다. 당해 단말은: 스마트폰, 테블릿, MP3 플레이어(Moving Picture Experts Group Audio Layer III), MP4(Moving Picture Experts Group Audio Layer IV) 플레이어, 노 트북 또는 데스크탑 컴퓨터일 수 있다. 단말은 또한 사용자 기기, 휴대용 단말, 랩탑 단말, 데스크탑 단말 등 기타 명칭으로 지칭될 수 있다. 일반적으로, 단말은: 프로세서 및 메모리를 포함한다. 프로세서는 하나 또는 복수 개의 프로세싱 코어, 예컨대 4 코어 프로세서, 8 코어 프로세서 등을 포함할 수 있다. 프로세서는 DSP(Digital Signal Processing), FPGA(Field－Programmable Gate Array), PLA(Programmable Logic Array) 중 적어도 한 가지 하드웨어 형식을 이용하여 구현될 수 있다. 프로세서 는 메인 프로세서와 코프로세서도 포함할 수 있는바, 메인 프로세서는 깨어 있는 상태(awaken state)의 데이터 에 대해 처리를 수행하는 프로세서이고, CPU(Central Processing Unit)라고도 지칭하며; 코프로세서는 대기 상 태의 데이터에 대해 처리를 수행하는 저전력 프로세서이다. 일부 실시예에서, 프로세서에는 GPU(Graphics Processing Unit)가 집적될 수 있고, GPU는 스크린에 표시될 내용의 랜더링과 드로잉을 담당한다. 일부 실시예 에서, 프로세서는AI(Artificial Intelligence, 인공지능) 프로세서를 더 포함할 수 있는바, 당해 AI 프로 세서는 머신 러닝에 관한 컴퓨팅 조작을 처리한다. 메모리는 하나 또는 복수 개의 컴퓨터 판독가능 저장매체를 포함할 수 있으며, 당해 컴퓨터 판독가능 저장 매체는 비일시적인 것일 수 있다. 메모리는 고속 랜덤 액세스 메모리, 및 비휘발성 메모리, 예컨대 하나 또는 복수 개의 자기 디스크 저장 기기, 플래시 저장 기기를 더 포함할 수 있다. 일부 실시예에서, 메모리 내의 비일시적 컴퓨터 판독가능 저장매체는 적어도 하나의 명령을 저장하며, 당해 적어도 하나의 명령은 프로세 서에 의해 실행되어 본 출원 중 방법 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용 되는 모듈 처리 방법을 구현한다. 일부 실시예에서, 단말은 또한 선택 가능하게: 주변 기기 인터페이스와 적어도 하나의 주변 기기를 포함할 수 있다. 프로세서, 메모리 및 주변 기기 인터페이스 사이는 버스 또는 신호선을 통해 연결될 수 있다. 각 주변 기기는 버스, 신호선 또는 회로 기판을 통해 주변 기기 인터페이스와 연결된다. 구체적으로, 주변 기기는: RF 회로, 디스플레이, 카메라 어셈블리, 오디오 회로, 포지셔닝 컴포넌트 및 전원 중 적어도 하나를 포함한다. 주변 기기 인터페이스는 I/O(Input /Output, 입력/출력)와 관련된 적어도 하나의 주변 기기를 프로세서 및 메모리에 연결시키는 데에 사용될 수 있다. 일부 실시예에서, 프로세서, 메모리 및 주변 기기 인터페이스는 하나의 칩 또는 회로 기판에 집적될 수 있으며; 일부 기타 실시예에서, 프로세서 , 메모리 및 주변 기기 인터페이스 중 임의의 하나 또는 두 개는 독립된 칩 또는 회로 기판에서 구현될 수 있으며, 본 실시예는 이에 대해 한정하지 않는다. RF 회로는 전자기 신호로도 불리는 RF(Radio Frequency) 신호를 수신하고 전송한다. RF 회로는 전자 기 신호를 통해 통신 네트워크 및 기타 통신 기기와 통신을 수행한다. RF 회로는 전기 신호를 전자기 신호 로 변환하여 전송하거나, 또는, 수신된 전자기 신호를 전기 신호로 변환한다. 선택 가능하게, RF 회로는: 안테나 시스템, RF 트랜시버, 하나 이상의 증폭기, 튜너, 발진기, 디지털 신호 프로세서, 코덱 칩셋, 가입자 인 식 모듈 카드 등을 포함한다. RF 회로는 적어도 일종의 무선 통신 프로토콜을 통해 기타 단말과 통신을 수 행할 수 있다. 당해 무선 통신 프로토콜은Metropolitan Area Network, 인트라넷, 다양한 세대의 이동 통신 네트 워크(2G, 3G, 4G 및 5G), 근거리 무선 통신망 및/또는 WiFi(Wireless Fidelity, 무선 충실도) 네트워크를 포함 하지만 이에 한정되지 않는다. 일부 실시예에서, RF 회로는 또한 NFC(Near Field Communication, 근거리 무선 통신)에 관련된 회로도 포함할 수 있으며, 본 출원은 이에 대해 한정하지 않는다. 디스플레이는 UI(User Interface)를 표시한다. 당해 UI는 그래픽, 텍스트, 아이콘, 비디오 및 기타의 임의 의 조합을 포함할 수 있다. 디스플레이가 터치 스크린일 경우, 디스플레이는 디스플레이의 표면 또는 표면 상방의 터치 신호를 수집하는 능력을 더 구비한다. 당해 터치 신호는 제어 신호로서 프로세서에 입력되어 처리될 수 있다. 이때, 디스플레이는 가상 버턴 및/또는 가상 키보드(소프트 버턴 및/또는 소프 트 키보드라고도 치징함)를 더 제공할 수 있다. 일부 실시예에서, 디스플레이는 하나일 수 있고, 단말 의 전면 패널에 배치되며; 다른 일부 실시예에서, 디스플레이는 적어도 두 개일 수 있고, 각각 단말 의 상이한 표면에 배치되거나 또는 폴드식으로 설계될 수 있으며; 다른 일부 실시예에서, 디스플레이(80 5)는 플렉시블 스크린일 수 있고, 단말의 구부러진 표면 또는 접이 면에 배치된다. 심지어, 디스플레이 는 비직사각형인 불규칙적인 도형, 즉 이형 스크린으로도 배치될 수 있다. 디스플레이는 LCD(Liquid Crystal Display), OLED(Organic Light-Emitting Diode)등 재질로 제작될 수 있다. 카메라 어셈블리는 픽처 또는 비디오를 수집한다. 선택 가능하게, 카메라 어셈블리는 전면 카메라와 후면 카메라를 포함한다. 일반적으로, 전면 카메라는 단말의 전면 패널에 배치되고, 후면 카메라는 단말의 뒷면 에 배치된다. 일부 실시예에서, 후면 카메라는 적어도 두 개이고, 각각 메인 카메라, 피사계 심도 카메라 (Depth-of-field camera), 광각 카메라, 텔레포토 카메라 중 임의의 하나로서, 메인 카메라와 피사계 심도 카메 라의 융합을 구현하여 배경 가상화 기능, 메인 카메라와 광각 카메라를 융합하여 파라노마 촬영 및 VR(Virtual Reality, 가상 현실) 촬영 기능 또는 기타 융합 촬영 기능을 구현한다. 일부 실시예에서, 카메라 어셈블리(80 6)는 플래시를 더 포함할 수 있다. 플래시는 싱글 컬러 온도 플래시일 수도 있고, 듀얼 컬러 온도 플래시일 수 도 있다. 듀얼 컬러 온도 플래시는 싱글 컬러 온도 플래시일 수도 있고, 듀얼 컬러 온도 플래시일 수도 있다. 듀얼 컬러 온도 플래시는 웜(warm) 플래시와 쿨(cool) 플래시의 조합을 가리키며, 상이한 컬러 온도에서의 광 보상(light compensation)에 사용될 수 있다. 오디오 회로는 마이크로폰과 스피커를 포함할 수 있다. 마이크로폰은 사용자 및 환경의 음파를 수집하고, 또한 음파를 전기 신호로 변환하여 프로세서에 입력하여 처리를 수행하거나, 또는 RF 회로에 입력하 여 음성 통신을 구현한다. 스테레오 수집 또는 소음 감소의 목적에 따라 마이크로폰은 복수 개일 수 있고, 각각 단말의 상이한 부위에 배치될 수 있다. 마이크로폰은 또한 어레이 마이크로폰 또는 전방향 (Omnidirectional) 수집형 마이크로폰일 수도 있다. 스피커는 프로세서 또는 RF 회로에서 비롯된 전 기 신호를 음파로 변환한다. 스피커는 전통적인 박막 스피커일 수도 있고, 압전 세라믹 스피커일 수도 있다. 스 피커가 압전 세라믹 스피커일 경우, 전기 신호를 인류가 들을 수 있는 음파로 변환할 수 있을 뿐만아니라, 전기 신호를 인류가 들을 수 없는 음파로 변환하여 거리 측정 등 용도에 사용될 수도 있다. 일부 실시예에서, 오디오 회로는 헤드폰 잭을 더 포함할 수도 있다. 포지셔닝 컴포넌트는 단말의 현재 지리적 위치를 포지셔닝하여, 네비게이션 또는 LBS(Location Based Service)를 구현한다. 전원은 단말 중의 각 컴포넌트에 전원을 제공한다. 전원은 교류전, 직류전, 일회용 전지 또는 충전 가능한 전지일 수 있다. 전원에 충전 가능한 전지가 포함될 경우, 당해 충전 가능한 전지는 유선 충 전 또는 무선 충전을 지원할 수 있다. 당해 충전 가능한 전지는 또한 고속 충전을 지원할 수도 있다. 일부 실시예에서, 단말은 하나 또는 복수 개의 센서를 더 포함한다. 당해 하나 또는 복수 개의 센서 는: 가속도 센서, 자이로 센서, 압력 센서, 지문 센서, 광학 센서 및 근접각센서를 포함하나 이에 한정되지 않는다. 가속도 센서는 단말에 의해 구축된 좌표계의 3개 좌표축에서의 가속도 크기를 검출할 수 있다. 예컨 대, 가속도 센서는 중력 가속도의 3개 좌표축에서의 분량을 검출할 수 있다. 프로세서는 가속도 센서 에 의해 수집된 중력 가속도 신호에 기반하여 디스플레이를 제어하여 횡방향 뷰 또는 종방향 뷰로 UI 의 표시를 수행한다. 가속도 센서는 게임 또는 사용자의 모션 데이터의 수집에 사용될 수도 있다. 자이로 센서는 단말의 기기 방향 및 회전 각도를 검출할 수 있으며, 자이로 센서는 가속도 센서 와 함께 협조하여 사용자의 단말에 대한 3D 모션을 수집할 수 있다. 프로세서는 자이로 센서 에 의해 수집된 데이터에 기반하여 이하 기능: 모션 센싱(예컨대 사용자의 경사 조작에 기반하여 UI를 변 경), 촬영 시의 픽처 안정성, 게임 컨트롤 및 관성 항법을 구현할 수 있다. 압력 센서는 단말의 사이드 프레임 및/또는 디스플레이의 하층에 배치될 수 있다. 압력 센서 가 단말의 측면 프레임에 배치될 경우, 사용자의 단말에 대한 그립 신호(grib signal)를 검출할 수 있으며, 프로세서가 압력 센서에 의해 수집된 그립 신호에 기반하여 좌우 손의 인식 또는 단축 조 작(shortcut operation)을 수행할 수 있다. 압력 센서가 디스플레이의 하층에 배치될 경우, 프로세서 가 사용자의 디스플레이에 대한 압력 조작에 기반하여 UI 상의 조작 가능한 컨트롤에 대해 제어를 수 행한다. 조작 가능한 컨트롤은 버튼 컨트롤, 스크롤바 컨트롤, 아이콘 컨트롤, 메뉴 컨트롤 중 적어도 하나를 포함한다. 지문 센서는 사용자의 지문을 수집하며, 프로세서가 지문 센서에 의해 수집된 지문에 기반하여 사용자의 신분을 인식하거나, 또는, 지문 센서가 수집된 지문에 기반하여 사용자의 신분을 인식한다. 인식 된 사용자의 신분이 믿을 수 있는 신분일 경우, 프로세서는 당해 사용자에게 권한을 부여하여 관련된 민감 한 조작을 수행하게 하고, 당해 민감한 조작은 화면 잠금 해제, 암호화 정보 확인, 소프트웨어 다운로드, 지불 및 설정 변경 등을 포함한다. 지문 센서는 단말의 정면, 배면 또는 측면에 배치될 수 있다. 단말 에 물리 버튼이 배치되어 있거나 또는 공급 업체 Logo가 배치되어 있을 경우, 지문 센서는 물리 버튼 또는 공급 업체 Logo와 집적될 수 있다. 광학 센서는 환경 광 강도를 수집한다. 하나의 실시예에서, 프로세서는 광학 센서에 의해 수집 된 환경 광 강도에 기반하여, 디스플레이의 표시 밝기를 제어할 수 있다. 구체적으로, 환경 광 강도가 높 을 경우, 디스플레이의 표시 밝기를 높이고; 환경 광 강도가 낮을 경우, 디스플레이의 표시 밝기를 낮춘다. 다른 하나의 실시예에서, 프로세서는 또한 광학 센서에 의해 수집된 환경 광 강도에 기반하 여 카메라 어셈블리의 촬영 파라미터를 동적으로 조정할 수도 있다. 근접각 센서는 거리 센서라고도 불리며, 이는 일반적으로 단말의 전면 패널에 배치된다. 근접각 센서 는 사용자와 단말의 정면 사이의 거리를 수집한다. 하나의 실시예에서, 근접각 센서가 사용자와 단말의 정면 사이의 거리가 점차적으로 작아지는 것을 검출할 경우, 프로세서가 디스플레이를 밝은 상태로부터 휴식 상태로 전환하도록 제어하며; 근접각 센서가 사용자와 단말의 정면 사이의 거 리가 점차적으로 커지는 것을 검출할 경우, 프로세서가 디스플레이를 휴식 상태로부터 밝은 상태로 전환하도록 제어한다."}
{"patent_id": "10-2024-7024402", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "본 기술분야의 통상업자들은 도 8에 도시된 구조가 단말에 대한 제한을 구성하지 않고, 도시된 것보다 더 많거나 더 적은 구성요소를 포함하거나, 또는 일부 구성요소를 조합하거나, 또는 상이한 구성요소 배치를 채택 할 수 있음을 이해할 수 있다. 본 출원의 실시예는 비일시적 컴퓨터 판독가능 저장매체를 더 제공하는 바, 상기 저장매체 중의 명령이 단말의 프로세서에 의해 수행될 경우, 단말로 하여금 위의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템 에 사용되는 모듈 처리 방법을 수행하게 한다. 본 출원의 실시예는 명령을 포함한 컴퓨터 프로그램 제품을 더 제공하는 바, 이가 단말에서 수행될 경우, 단말 이 상술한 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법을 수행하게 한다. 도 9는 본 출원의 실시예에서 제공하는 서버 구조 모식도이다. 전술한 실시예에 관한 백그라운드는 모두 도 9에 도시된 구조를 통해 구현될 수 있다. 당해 서버는 백그라운드 서버 클러스터 중의 서버일 수 있다. 구체적으로 아래와 같다: 서버는 중앙 처리 장치(CPU), 랜덤 액세스 메모리(RAM)와 리드 온리 메모리(ROM)를 포함 하는 시스템 메모리, 및 시스템 메모리와 중앙 처리 장치를 연결하는 시스템 버스를 포함 한다. 서버는 컴퓨터 내의 각 소자 사이의 정보 전송을 도와주는 기본 입력/출력 시스템(I/O 시스 템), 및 운영 체제, 응용 프로그램과 기타 프로그램 모듈을 저장하는 데에 사용되는 대용 량 저장 기기를 더 포함한다. 기본 입력/출력 시스템은 정보를 표시하기 위한 디스플레이 및 사용자가 정보를 입력하기 위한 마우 스, 키보드 등 종류의 입력 기기를 포함한다. 여기서 디스플레이 및 입력 기기는 모두 시스템 버스에 연결된 입력/출력 컨트롤러를 통해 중앙 처리 장치에 연결된다. 기본 입력/출력 시스템 은 키보드, 마우스, 또는 전자 스타일러스 팬(electronic stylus pen) 등 복수 개의 기타 기기의 입력을 수신하고 처리하기 위한 입력/출력 컨트롤러를 더 포함할 수 있다. 유사하게, 입력/출력 컨트롤러는 또한 표시 스크린, 프린터 또는 기타 타입의 출력 기기로 출력할 수 있다. 대용량 저장 기기는 시스템 버스에 연결된 대용량 저장 컨트롤러(미도시)를 통해 중앙 처리 장치 에 연결된다. 대용량 저장 기기 및 이와 관련된 컴퓨터 판독가능 매체는 서버에 휘발성 메모리 를 제공한다. 즉, 대용량 저장 기기는 하드 디스크 또는 CD-ROM 드라이브와 같은 컴퓨터 판독가능 매체(미 도시)를 포함할 수 있다. 일반적으로, 컴퓨터 판독가능 매체는 컴퓨터 저장매체와 통신 매체를 포함할 수 있다. 컴퓨터 저장매체 컴퓨터 판독가능 명령, 데이터 구조, 프로그램 모듈 또는 기타 데이터 등 정보를 저장하기 위한 임의의 방법 또는 기술 로 구현되는 휘발성 및 비휘발성 매체, 이동 가능 및 이동 불가능 매체를 포함할 수 있다. 컴퓨터 저장매체는 RAM, ROM, EPROM, EEPROM, 플래시 또는 기타 솔리드 저장 기술, CD-ROM, DVD 또는 기타 광학 저장, 테이프 카 트리지(tape cartridge), 자기 테이프, 하드 디스크 저장 또는 기타 자기성 저장 기기를 포함한다. 물론, 본 기 술분야의 통상의 기술자라면 컴퓨터 저장매체가 상술한 몇 가지에 제한되지 않음은 자명한 것이다. 상술한 시스 템 메모리 및 대용량 저장 기기를 메모리라고 통칭할 수 있다. 본 출원의 각 실시예에 기반하여, 서버는 또한 인터넷 등 네트웍을 통해 네트웍 상에 연결된 원격 컴퓨터 를 통해 실행된다. 즉 서버는 시스템 버스상에 연결된 네트워크 인터페이스 유닛을 통해 량 에 연결될 수 있거나, 또는, 네트워크 인터페이스 유닛을 이용하여 기타 유형의 네트웍 또는 원격 컴 퓨터 시스템(미도시)에 연결될 수 있다. 상술한 메모리는 하나 또는 하나 이상의 프로그램을 더 포함하며, 하나 또는 하나 이상의 프로그램은 메모리에 저장되고, CPU에 의해 실행되도록 구성된다. 상기 하나 또는 하나 이상의 프로그램은 본 출원의 실시예에서 제 공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법을 포함한다. 본 출원의 실시예는 비일시적 컴퓨터 판독가능 저장매체를 더 제공하는 바, 상기 저장매체 중의 명령이 서버의 프로세서에 의해 수행될 경우, 서버로 하여금 위의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템 에 사용되는 모듈 처리 방법을 수행하게 한다. 본 출원의 실시예는 명령을 포함하는 컴퓨터 프로그램 제품을 더 제공하는 바, 이가 서버에서 실행될 경우, 서 버로 하여금 상술한 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법을 수행하게 한다. 당업자는, 상기 방법 실시예의 전부 또는 일부 단계의 구현은 하드웨어를 통해 완성될 수도 있고, 프로그램을 통해 관련된 하드웨어를 지시하여 완성될 수도 있으며, 상기 프로그램은 컴퓨터 판독가능 저장매체에 저장될 수 있으며, 상술한 저장매체는 판독 전용 메모리(Read-Only Memory, ROM), 자기 디스크 또는 광 디스크 등일 수 있 다. 전술한 것은 본 출원의 바람직한 예일뿐이고, 본 출원을 한정하기 위해 사용되지 않는다. 본 출원의 사상 및 원 리 내의 임의의 수정, 등가의 대체, 개선 등은 본 출원의 보호 범위에 포함될 것이다. 도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9"}
{"patent_id": "10-2024-7024402", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 출원의 하나 이상의 실시예 또는 관련 기술에서 제공되는 기술적 해결책을 보다 명확하게 설명하기 위해, 실 시예들 또는 관련 기술에서 사용될 필요가 있는 첨부 도면들에 대한 간단한 설명이 이하에 주어진다. 명백하게,"}
{"patent_id": "10-2024-7024402", "section": "도면", "subsection": "도면설명", "item": 2, "content": "이하의 설명에서의 도면들은 단지 본 출원에 설명된 하나 이상의 실시예 중 일부이다. 본 기술분야의 통상의 기 술자들에게는, 창조적 노력 없이 이러한 도면들에 기초하여 다른 도면들이 획득될 수 있다. 도 1은 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템의 아키텍처 모식도이다; 도 2는 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법 흐름 도이다; 도 3은 본 출원의 실시예에서 제공하는 흐름도 모식도이다; 도 4는 본 출원의 실시예에서 제공하는 다른 흐름도 모식도이다; 도 5는 본 출원의 실시예에서 제공하는 모듈을 삭제하는 모식도이다; 도 6은 본 출원의 실시예에서 제공하는 다른 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 방법 흐름도이다; 도 7은 본 출원의 실시예에서 제공하는 포그라운드 및 백그라운드 분리 시스템에 사용되는 모듈 처리 장치의 구 조 모식도이다; 도 8은 본 출원의 실시예에서 제공하는 단말의 구조 모식도이다; 도 9는 본 출원의 실시예에서 제공하는 서버 구조 모식도이다."}
