{"patent_id": "10-2024-7010747", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0056563", "출원번호": "10-2024-7010747", "발명의 명칭": "스트리밍 입력 데이터 프로세싱을 위한 스케일러블 하드웨어 아키텍처 템플릿", "출원인": "구글 엘엘씨", "발명자": "양 양"}}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "방법으로서, 상기 방법은:각각의 스트리밍 입력 데이터에 대한 동작들을 수행하도록 구성된 하드웨어 구성요소들에 대한 하드웨어 아키텍처들을 생성하기 위한 하드웨어 아키텍처 템플릿을 나타내는 데이터를 수신하는 단계, 상기 하드웨어 아키텍처템플릿은 (i) 하드웨어 아키텍처 내의 클러스터들의 수, (ii) 각 클러스터 내의 프로세싱 유닛들의 수, 및(iii) 각 프로세싱 유닛 내의 하드웨어 유닛 어레이의 크기 중 둘 이상을 포함하는 구성가능한 설계 파라미터들의 세트를 포함하고;주어진 하드웨어 구성요소에 대한 주어진 하드웨어 아키텍처에 대해, 주어진 하드웨어 구성요소에 대한 각각의스트리밍 입력 데이터의 특성들에 적어도 부분적으로 기초하여 구성가능한 설계 파라미터들의 세트에 대한 값들을 결정하는 단계, 상기 결정하는 단계는:구성가능한 설계 파라미터들의 세트에 대한 검색 공간에 기초하여, 상기 하드웨어 아키텍처 템플릿을 사용하여주어진 하드웨어 구성요소에 대한 복수의 후보 하드웨어 아키텍처들을 생성하는 단계, 상기 각 후보 하드웨어아키텍처는 구성가능한 설계 파라미터들의 세트에 대한 각각의 설계 파라미터 값들을 포함하고;상기 복수의 후보 하드웨어 아키텍처들 각각에 대해, 성능 모델 및 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터의 특성들에 기초하여 상기 후보 하드웨어 아키텍처와 연관된 성능 측정치들의 세트에 대한각각의 값들을 결정하는 단계;주어진 하드웨어 아키텍처로서, 성능 측정치들의 세트에 대한 각각의 값들에 적어도 부분적으로 기초하여 상기복수의 후보 하드웨어 아키텍처들로부터 후보 하드웨어 아키텍처를 선택하는 단계; 및주어진 하드웨어 아키텍처의 구성가능한 설계 파라미터들의 세트에 대한 값으로서, 상기 선택된 후보 하드웨어아키텍처와 연관된 설계 파라미터 값들을 결정하는 단계를 포함하고; 및주어진 하드웨어 아키텍처의 설계 파라미터들의 세트에 대한 값들을 나타내는 출력 데이터를 생성하는 단계를포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 하드웨어 아키텍처 템플릿에 출력 데이터를 제공하는 단계;주어진 하드웨어 아키텍처의 설계 파라미터들의 세트에 대한 값들에 기초하여 주어진 하드웨어 아키텍처를 인스턴스화하는 단계; 및주어진 하드웨어 아키텍처에 기초하여 주어진 하드웨어 구성요소를 제조하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터의 특성들은 주어진 하드웨어 구성요소에 대한각각의 스트리밍 입력 데이터의 각 프레임의 도달 레이트 및 각 프레임의 크기를 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,성능 측정치들의 세트는 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터를 프로세싱하기 위한레이턴시, 전력 소비, 리소스 사용량, 또는 처리량 중 적어도 하나의 측정치들을 포함하고, 성능 모델은 분석공개특허 10-2024-0056563-3-비용 모델, 기계 학습 비용 모델, 또는 하드웨어 시뮬레이션 모델 중 적어도 하나를 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터는 시간 순서에 따라 이미지 센서에 의해 수집된스트리밍 이미지 프레임들을 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서, 스트리밍 이미지 프레임들의 특성들은 이미지 프레임들에 대한 특정 도달 레이트 및 이미지 프레임들 각각에 대한 각각의 이미지 해상도 중 적어도 하나를 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제5항에 있어서, 스트리밍 이미지 프레임들의 특성들은 수직 블랭킹 기간(blanking period) 또는 수평 블랭킹 기간 중 적어도 하나를 포함하는 블랭킹 기간을 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제5항에 있어서, 스트리밍 이미지 프레임들의 특성들은 픽셀 포맷을 포함하고, 상기 픽셀 포맷은 RGB 또는 YUV 컬러 포맷을 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서,주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터는 오디오 센서에 의해 수집된 스트리밍 오디오를 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,스트리밍 이미지 프레임들의 특성들은 스트리밍 오디오에 대한 특정 샘플 레이트, 스트리밍 오디오의 비트깊이, 스트리밍 오디오의 비트 레이트, 또는 스트리밍 오디오의 오디오 포맷 중 적어도 하나를 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제1항에 있어서,주어진 하드웨어 구성요소를 사용하여 각각의 스트리밍 입력 데이터에 대한 동작들을 수행하는 것은:스트리밍 입력 데이터의 각 프레임에 대해:프레임의 입력 벡터를 상기 입력 벡터의 중첩되지 않는 값들을 각각 포함하는 복수의 부분 벡터들로 분할하는단계; 및상기 복수의 부분 벡터들 중 각 부분 벡터에 대해, 각각이 각각의 프로세싱 유닛들의 수를 갖고 각 프로세싱 유닛이 주어진 하드웨어 아키텍처의 설계 파라미터들세트에 대한 값들에 대응하는 각각의 크기의 하드웨어 유닛 어레이를 갖는 복수의 클러스터들 중 각각의 클러스터에 부분 벡터를 할당하는 단계; 각각의 클러스터에 의해, 각각의 부분 합을 생성하기 위해 부분 벡터의 각 값을 메모리에 저장된 행렬의 부분행의 대응하는 값과 곱하는 단계; 및공개특허 10-2024-0056563-4- 각각의 부분 합을 어큐뮬레이터 어레이에 저장하는 단계를 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서, 주어진 하드웨어 구성요소를 사용하여 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터에 대한동작들을 수행하는 것은 메모리에 저장된 행렬의 희소성(sparsity) 레벨에 기초하여 동작들을 수행하는 것을 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1항에 있어서, 동작들을 수행하는 것은 조밀(dense) 행렬 모드와 희소(sparse) 행렬 모드 사이에서 스위칭되고, 스위칭 프로세스는 제어 및 상태(CSR) 레지스터에 의해 제어되는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제11항에 있어서, 메모리에 저장된 행렬의 부분 행의 대응하는 값들을 생성하는 단계는 희소 행렬 모드에서 수행되고, 상기 생성하는 단계는:메모리에 저장된 행렬의 부분 행에서 제로가 아닌 값들을 결정하는 단계;행렬의 부분 행의 제로가 아닌 값들의 포지션들을 나타내는 식별자들을 생성하는 단계, 상기 식별자들은 인덱스들 또는 비트맵들을 포함하고; 및대응하는 식별자들과 연관된 제로가 아닌 값들의 압축 벡터를 행렬의 부분 행의 대응하는 값들로서 생성하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서,대응하는 식별자들에 기초하여 압축 벡터에 대응하는 부분 벡터의 값들을 선택하는 단계; 및부분 벡터의 선택된 값들 각각을 압축 벡터의 대응하는 제로가 아닌 값과 곱하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제1항에 있어서,주어진 하드웨어 아키텍처는 메모리에 저장된 하나 이상의 행렬들에 대한 상한 희소성 레벨을 나타내는 데이터를 포함하고, 주어진 하드웨어 아키텍처는 하나 이상의 행렬들 중 제1 행렬과 상이한 희소성 레벨을 갖는 하나이상의 행렬들 중 제2 행렬로 스트리밍 입력 데이터를 프로세싱하기 위해 동적으로 다시 인스턴스화되도록 구성되는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제1항에 있어서, 구성가능한 설계 파라미터들의 세트에 대한 검색 공간에 기초하여, 상기 하드웨어 아키텍처 템플릿을 사용하여상기 복수의 후보 하드웨어 아키텍처들을 생성하는 단계는, 랜덤 검색 알고리즘, 완전(exhaustive) 검색 알고리즘 또는 유전(genetic) 알고리즘 중 적어도 하나를 사용하여 설계 파라미터들의 세트에 대한 검색 공간을 탐색하는 단계를 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제1항에 있어서, 구성가능한 설계 파라미터들의 세트에 대한 검색 공간을 탐색하는 단계는:공개특허 10-2024-0056563-5-각 프로세싱 유닛 내의 하드웨어 유닛 어레이의 크기 및 클러스터 내의 프로세싱 유닛들의 수에 대응하는 설계파라미터 값들을 탐색하는 단계;상기 하드웨어 유닛 어레이의 크기 및 클러스터 내의 프로세싱 유닛들의 수에 대응하는 설계 파라미터 값들이클러스터에 대한 확장성 한계에 있다고 결정하는 단계; 및이에 대응하여, 클러스터들의 수에 대응하는 설계 파라미터 값들을 탐색하는 단계를 포함하는, 방법."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "하나 이상의 컴퓨터들에 의해 실행될 때 상기 하나 이상의 컴퓨터들로 하여금 제1항 내지 제18항 중 어느 한 항의 각각의 동작들을 수행하게 하는 명령어들을 저장하는, 하나 이상의 컴퓨터 판독가능 저장 매체."}
{"patent_id": "10-2024-7010747", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "하나 이상의 컴퓨터들, 및 상기 하나 이상의 컴퓨터들에 의해 실행될 때 상기 하나 이상의 컴퓨터들로 하여금제1항 내지 제18항 중 어느 한 항의 각각의 동작들을 수행하게 하는 명령어들을 저장하는 하나 이상의 저장 디바이스를 포함하는, 시스템."}
{"patent_id": "10-2024-7010747", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "스트리밍 입력 데이터를 프로세싱하기 위해 향상된 하드웨어 아키텍처를 생성하기 위해 컴퓨터 저장 매체에 인코 딩된 컴퓨터 프로그램을 포함하는 방법, 시스템 및 장치가 설명된다. 일 측면에서, 방법은 하드웨어 아키텍처 템 플릿을 나타내는 데이터를 수신하는 단계를 포함한다. 하드웨어 아키텍처 템플릿은 구성가능한 설계 파라미터들 (뒷면에 계속)"}
{"patent_id": "10-2024-7010747", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 명세서는 스트리밍 입력 데이터에 대한 동작들을 수행하는 기계 학습 프로세서들과 같은 하드웨어 구성요소 들에 대한 하드웨어 설계 파라미터들을 생성하기 위해 스케일러블(scalable) 하드웨어 아키텍처 템플릿을 사용 하고, 파라미터들을 사용하여 프로세서들을 제조(manufacture)하는 것에 관한 것이다."}
{"patent_id": "10-2024-7010747", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능(AI)은 기계에 의해 구현되는 지능으로, 컴퓨터 프로그램이나 기계가 생각하고 학습하는 능력을 나타낸 다. 하나 이상의 컴퓨터를 사용하여 AI 계산을 수행하여 각각의 태스크에 대해 기계를 트레이닝할 수 있다. AI 계산에는 하나 이상의 기계 학습 모델로 표현되는 계산이 포함될 수 있다. 신경망은 기계 학습 모델의 하위 분야에 속한다. 신경망은 벡터 또는 행렬 연산(operation)과 같은 여러 연산을 나타내는 하나 이상의 노드 계층을 사용할 수 있다. 하나 이상의 컴퓨터는 출력, 예를 들어 수신된 입력에 대한 분류, 예측 또는 분할을 생성하기 위해 신경망의 연산 또는 계산을 수행하도록 구성될 수 있다. 일부 신경망은 출력 계층 외에 하나 이상의 은닉 계층을 포함한다. 각 은닉 계층의 출력은 네트워크의 다음 계층, 즉 다음 은 닉 계층 또는 출력 계층의 입력으로 사용된다. 네트워크의 각 계층은 각 네트워크 파라미터 세트의 현재 값에 따라 수신된 입력으로부터 출력을 생성한다. 다음 명세서에 설명된 기술은 스케일러블 하드웨어 아키텍처 템플릿을 사용하여 스트리밍 입력 데이터에 대한 동작들을 수행하는 기계 학습 프로세서들과 같은 하드웨어 구성요소들에 대한 하드웨어 설계 파라미터들을 생성 하고, 파라미터들을 사용하여 프로세서들을 제조하는 것과 관련된다. 하드웨어 아키텍처 템플릿은 스트리밍 입 력 데이터에 대한 동작들을 수행하도록 구성될 수 있는 하드웨어 구성요소들을 제조하기 위한 구성가능한 설계 파라미터들의 세트를 포함할 수 있으므로, 아키텍처는 스트리밍 입력 데이터의 특성들에 기초하여 확장되거나 축소될 수 있다. 기술은 설계 파라미터들의 세트의 값들을 결정하고 하드웨어 아키텍처 템플릿과 결정된 값들을 사용하여 하드웨어 아키텍처를 인스턴스화하는 데 사용될 수 있다. 하드웨어 아키텍처 표현(hardware architecture representation)이라고도 하는 하드웨어 아키텍처는, 일반적으 로 엔지니어링된(또는 엔지니어링될) 전자 또는 전기 기계 하드웨어 블록, 구성요소 또는 시스템의 표현과 관련 된다. 하드웨어 아키텍처는 하드웨어 블록, 구성요소 또는 시스템을 식별하고, 프로토타입화(prototyping)하고, 제조하기 위한 데이터를 포함할 수 있다. 하드웨어 아키텍처는 블록, 구성요소 또는 시스템에 대한 구조를 나타 내는 데이터, 예를 들어 하드웨어 블록, 구성요소 또는 시스템에 포함된 하위 구성요소 또는 하위 시스템과 이 들의 상호 관계를 식별하는 데이터로 인코딩될 수 있다. 하드웨어 아키텍처에는 하드웨어 블록, 구성요소 또는 시스템을 제조하는 프로세스를 나타내는 데이터나 하드웨어 블록, 구성요소 또는 시스템 또는 둘 다를 위한 설계를 효과적으로 구현하기 위한 규율(discipline)을 나타내는 데이터도 포함될 수 있다. 본 명세서에서 \"하드웨어 아키텍처 템플릿\"이라는 용어는 스트리밍 입력에 대해 기계 학습 계산을 수행하도록 구성된 기계 학습 프로세서와 같은, 하드웨어 구성요소에 대한 설계 파라미터들의 세트를 갖는 템플릿을 나타내 는 데이터를 의미한다. 하드웨어 아키텍처 템플릿은 하드웨어 아키텍처에 포함될 다양한 컴퓨팅 유닛의 유형, 수 또는 계층 구조와 같은 설계 파라미터들의 세트에 기초하여 커스터마이징되거나 사용자 정의될 여러 측면을 갖춘 하드웨어 아키텍처에 대한 미리 설정된 일반 설계일 수 있다. 하드웨어 아키텍처 템플릿은 추상화(abstraction)일 수 있으며 설계 파라미터들의 세트에 대한 값이 결정될 때 까지 인스턴스화되지 않는다. 예를 들어 본 명세서에 설명된 다양한 프로세스를 사용하여 설계 파라미터들의 값 들을 결정한 후, 하드웨어 아키텍처 템플릿은 설계 파라미터들의 세트에 대해 결정된 값들에 기초하여 하드웨어 아키텍처를 인스턴스화하는 데 사용될 수 있다. 일부 구현예에서, 하드웨어 아키텍처 템플릿은 하드웨어 회로로 합성되고 객체 지향 방식(예: C 또는 C++)으로 프로그래밍될 수 있는 고급 컴퓨터 언어로 인코딩된 데이터를 나 타낼 수 있다. 단순화를 위해 본 명세서에서는 \"하드웨어 아키텍처 템플릿\"이라는 용어를 \"템플릿\"이라고도 한 다. 설계 파라미터들의 세트는 특정 설계 요구사항 또는 기준이 주어지면 설계 파라미터들의 세트에 대한 각각의 값 들을 검색하는 다중 차원의 \"검색 공간(search space)\"을 형성하거나 가질 수 있다. 설계 파라미터의 값은 하나 이상의 알고리즘이나 기법을 사용하여 검색 공간을 탐색(exploring)함으로써 결정할 수 있다. 본 문서에서 \"검 색 공간\"이라는 용어는, 예를 들어 하드웨어 아키텍처에 포함된 다양한 컴퓨팅 유닛의 모든 가능한 유형 및 수 와 같은, 이용가능한 리소스가 주어진 설계 파라미터들의 세트에 대한 가능한 솔루션(예: 값) 모두 또는 적어도 한 세트를 포괄하는 솔루션 공간을 의미한다. 템플릿은 계산 동작을 수행하는데 사용되는 데이터의 특성들에 기초하여 재구성될 수 있다. 어떤 경우에는, 예 를 들어 상이한 희소성 레벨을 가진 다른 입력 행렬와 같은, 입력 데이터의 변경으로 인해 템플릿에 의해 생성 된 하드웨어 아키텍처가 즉시 다시 인스턴스화될 수 있다. \"하드웨어 구성요소\"라는 용어는 예를 들어, 스트리밍 입력 데이터에 기초한 벡터 감소, 텐서 곱셈, 기본 산술 연산 및 논리 연산을 수행하도록 구성된 적절한 하드웨어 컴퓨팅 유닛들 또는 컴퓨팅 유닛들의 클러스터들을 포 함하는, 기계 학습 계산과 같은, 컴퓨팅 동작들을 수행하기 위한 하드웨어 구성요소들을 의미한다. 예를 들어, 하드웨어 구성요소들은 하나 이상의 타일들(예를 들어, MAC(multi-accumulate operation) 유닛들), 다수의 MAC 유닛들을 포함하는 하나 이상의 프로세싱 요소들, 다수의 프로세싱 요소들을 포함하는 하나 이상의 클러스터들, 및 그래픽 프로세싱 유닛(GPU)들 및 텐서 프로세싱 유닛(TPU)들과 같은 프로세싱 유닛들을 포함할 수 있다. \"스트리밍 입력 데이터\"라는 용어는 데이터를 프로세싱하기 위해 하드웨어 구성요소에 지속적으로 제공되는 데 이터를 의미한다. 예를 들어, 데이터는 특정 시간 간격으로 생성된 각 프레임을 갖는 다수의 데이터 프레임을 포함할 수 있으며, 각 데이터 프레임은 특정 레이트(rate)로 프로세싱하기 위해 하드웨어 구성요소에 제공된다. \"시간 간격\" 및 \"레이트\"라는 용어는 프레임 및 다음 프레임의 데이터를 생성하거나 수신하는 기간(time period) 또는 빈도를 의미한다. 예를 들어 입력 데이터 스트리밍 레이트는 몇 밀리초, 초, 분 또는 기타 적절한 기간당 데이터 프레임 1개일 수 있다. 스트리밍 입력 데이터는 시간 순서에 따라 이미지 센서에 의해 수집된 스트리밍 이미지 프레임 또는 비디오 프 레임일 수 있다. 이미지 센서는 카메라나 레코더를 포함할 수 있다. 스트리밍 이미지 프레임은 특정 레이트로 이미지 센서에 의해 수집되거나 특정 도달 레이트(arrival rate)로 하드웨어 구성요소에 제공될 수 있다. 스트리밍 입력 데이터의 각 프레임은 특정 크기를 가질 수 있다. 예를 들어, 각 스트리밍 이미지 프레임은 각각 의 이미지 해상도, 예를 들어 50 x 50 픽셀, 640 x 480 픽셀, 1440 x 1080 픽셀, 또는 4096 x 2160 픽셀을 포 함할 수 있다. 하드웨어 구성요소는 특정 레이트로 수신된 스트리밍 입력 데이터를 프로세싱하도록 구성될 수 있다. 전술한 바 와 같이, 스트리밍 입력 데이터는 예를 들어 하나 이상의 소스로부터 프레임 단위로 연속적으로 생성될 수 있으 며 특정 도달 레이트로 하드웨어 구성요소에 제공될 수 있다. 예를 들어, 레이트는 단위 시간당 프레임 또는 단 위 시간당 픽셀 수일 수 있다. 이상적으로, 하드웨어 구성요소는 입력 데이터의 다음 프레임이 도달하기 전에 스트리밍 입력 데이터의 각 프레임을 프로세싱하여 적시에(in time) 출력 데이터를 생성할 수 있다. 그러나 하 드웨어 구성요소가 다음 프레임이 도달하기 전에 프레임을 프로세싱할 수 없는 경우, 하드웨어 구성요소로 인해 스트리밍 입력 데이터의 다음 프레임을 프로세싱는 데 백프레셔(backpressure)가 발생할 수 있다. 백프레셔로인해 출력 데이터 생성이 중단되거나 시간이 지연될 수 있으며, 특히 시스템의 다른 하드웨어 구성요소가 하드 웨어 구성요소에 의해 생성된 출력 데이터를 프로세싱하도록 구성된 경우 시스템 오버헤드가 증가하거나 하드웨 어 구성요소의 동작 및/또는 하드웨어 구성요소에 의해 수행되는 계산에 오류가 발생할 수 있다. 일부 구현예에서, 시스템은 더 큰 프레임 크기, 더 높은 주파수, 또는 두 가지 모두(예를 들어, 이미지당 더 높 은 해상도로 단위 시간당 더 많은 이미지 프레임)를 갖춘 새로운 스트리밍 입력 데이터를 사용하여 더 높은 정 확도로 출력 데이터를 생성할 수 있다. 초기에 적합한 하드웨어 구성요소는 다음 프레임이 도달하기 전에 새로 운 스트리밍 입력 데이터의 각 프레임을 프로세싱할 능력이 없게 될 수 있으며, 이로 인해 나중에 도달하는 스 트리밍 입력 데이터의 프레임을 프로세싱하기 위한 백프레셔가 발생한다. 스트리밍 입력 데이터의 각 프레임이 순차적으로 수신되기 때문에 GEMM(Generalized Matrix Multiplication) 및 GEMV(Generalized Matrix Vector Multiplication)를 수행하는 기법들은 스트리밍 입력 데이터 프로세싱에 적용될 수 없다. 예를 들어, 스트리밍 입력 데이터의 각 프레임은 입력 행렬로 표현될 수 있으며, 입력 행렬는 특정 시간 윈도우 동안 하드웨어 구성요소에 의해 행 단위로(row by row) 수신된다. GEMM 또는 GEMV 기술의 예 는 루프 중첩 최적화(loop nest optimization)라고도 하는 루프 타일링(loop tiling)으로 알려져 있으며, 이는 행렬-행렬 또는 행렬-벡터 계산을 수행하기 위해 루프의 반복 공간을 더 작은 청크 또는 블록으로 분할하여 입 력의 각 더 작은 청크 또는 블록을 병렬로 계산할 수 있다. 그러나 루프 타일링 기법은 입력이 순서에 따라 행 단위로 수신되기 때문에 스트리밍 입력 데이터를 프로세싱하는 데 적합하지 않다. 현재 프레임의 마지막 행 또 는 다음 프레임의 행을 미리 저장하고 현재 프레임의 다른 행을 병렬로 프로세싱하면서 이러한 행에 대한 연산 들을 수행하는 것은 불가능하거나 적어도 비실용적이다. 일부 기법은 스트리밍 입력 데이터의 크기나 빈도가 증가할 때 더 많은 프로세싱 요소(PE)들 또는 컴퓨팅 유닛 들을 포함함으로써 백프레셔 문제를 해결하는 데 의존한다. 그러나 이는 비효율적이고 확장이 불가능할 수 있으 며 프레임 크기나 도달 레이트가 증가하면 곧 하드웨어 구성요소의 최대 전력 요구 사항에 도달할 수 있다. 예 를 들어, 스트리밍 입력 데이터를 프로세싱(예: 입력 데이터의 각 프레임을 사용하여 계산 수행)하도록 구성된 엣지 디바이스(예: 스마트폰, 태블릿, 노트북, 시계)에는 전력 소비율에 대한 상한이 있을 수 있다. 따라서 엣 지 디바이스의 하드웨어 구성요소 내에 통합된 컴퓨팅 유닛들의 총 수 또는 수는 최대 전력 요구 사항이나 충전 당 배터리 수명 요구 사항 또는 두 가지 모두에 의해 제한될 수 있다. 높은 처리량으로 스트리밍 입력 데이터를 보다 효율적이고 강력하게 프로세싱하기 위해, 이 문서에 설명된 기법 은 설계 파라미터들의 세트를 사용하여 하드웨어 아키텍처 템플릿을 구현한다. 설명된 기법을 수행하는 시스템 은 스트리밍 입력 데이터의 특성들에 기초하여 설계 파라미터들의 세트에 대한 값들을 결정하고 결정된 설계 파 라미터 값들을 갖는 하드웨어 아키텍처 템플릿을 사용하여 하드웨어 아키텍처를 인스턴스화할 수 있다. 하드웨 어 아키텍처는 설계 파라미터 값들에 의해 지정된 컴퓨팅 유닛들의 특정 배열을 포함하고, 스트리밍 입력 데이 터를 프로세싱하는 데 적합한 하드웨어 구성요소를 나타낸다. 하드웨어 아키텍처는 하드웨어 구성요소를 제조하 는 데 사용될 수 있다. 일 측면에 따르면, 본 문서는 특정 스트리밍 입력 데이터에 기초하여 하드웨어 아키텍처를 생성하는 방법을 설 명한다. 하드웨어 아키텍처는 특정 스트리밍 입력 데이터를 만족스럽게 프로세싱할 수 있는 하드웨어 구성요소 를 제조하는 데 사용될 수 있다. 이 방법은 구성가능한 설계 파라미터들의 세트를 사용하여 하드웨어 아키텍처 템플릿을 나타내는 데이터를 수신하는 단계를 포함하고, 여기서 설계 파라미터들의 세트는 클러스터들의 수, 각 클러스터 내의 프로세싱 유닛들의 수, 각 프로세싱 유닛 내의 하드웨어 유닛 어레이의 크기 중 둘 이상을 포함 할 수 있다. 방법은 하드웨어 구성요소에 의해 프로세싱될 스트리밍 입력 데이터의 특성들에 적어도 부분적으로 기초하여 구 성가능한 설계 파라미터들의 세트에 대한 값들을 결정하는 단계를 더 포함한다. 결정 프로세스는: 구성가능한 설계 파라미터들에 대한 검색 공간을 사용하여 다수의 후보 하드웨어 아키텍처들을 생성하는 단계, 각 후보 하 드웨어 아키텍처와 연관된 성능 측정치(measure)들의 세트에 대한 각각의 값들을 결정하는 단계, 성능 측정치들 의 세트에 대한 각각의 값들에 적어도 부분적으로 기초하여 다수의 후보 하드웨어 아키텍처들 모두로부터 하나 의 후보 하드웨어 아키텍처를 선택하는 단계, 및 선택된 후보 하드웨어 아키텍처에 기초하여 설계 파라미터들의 값들을 결정하는 단계를 포함한다. 상기 방법에 의해 생성된 출력 데이터는 적어도 하드웨어 아키텍처를 제조하기 위한 설계 파라미터 값들을 포함 할 수 있다.일부 구현예에서, 방법은 하드웨어 아키텍처 템플릿에 출력 데이터를 제공하는 단계, 결정된 설계 파라미터 값 들에 기초하여 하드웨어 아키텍처를 인스턴스화하는 단계, 및 하드웨어 아키텍처를 사용하여 하드웨어 구성요소 를 제조하는 단계를 포함한다. 일부 구현예에서, 스트리밍 입력 데이터의 특성들은 각 프레임의 도달 레이트 및 각 프레임의 크기를 포함할 수 있다. 성능 측정치들의 세트는 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터를 프로세싱하기 위한 레이턴시(latency), 전력 소비, 리소스 사용량 또는 처리량 중 적어도 하나의 측정치들을 포함할 수 있다. 성능 모델은 분석 비용 모델, 기계 학습 비용 모델 또는 하드웨어 시뮬레이션 모델 중 하나 이상을 포함할 수 있다. 스트리밍 입력 데이터는 시간 순서에 따라 이미지 센서에 의해 수집된 스트리밍 이미지 프레임들일 수 있 다. 스트리밍 이미지 프레임들의 특성들은 특정 도달 레이트를 포함할 수 있으며, 여기서 스트리밍 이미지 프레 임들의 각 프레임은 각각의 이미지 해상도를 가질 수 있다. 일부 구현예에서, 스트리밍 이미지 프레임들의 특성 들은 이미지 프레임들에 대한 각각의 이미지 해상도를 포함할 수 있다. 스트리밍 이미지 프레임들의 특성들은 블랭킹 기간(blanking period)(예: 수직(vertical) 블랭킹 기간 및/또는 수평(horizontal) 블랭킹 기간), 픽셀 또는 색상 포맷(예: RGB 또는 YUV 색상 포맷) 및 이미지 프레임들의 도달 순서를 포함할 수 있다. 스트리밍 입 력 데이터는 오디오 센서에 의해 수집된 스트리밍 오디오일 수 있다. 오디오 스트리밍 데이터의 특성들은 스트 리밍 오디오에 대한 특정 샘플 레이트, 스트리밍 오디오의 비트 깊이(bit depth), 스트리밍 오디오의 비트 레이 트, 스트리밍 오디오의 오디오 포맷 중 적어도 하나를 포함할 수 있다. 일부 구현예에서, 스트리밍 입력 데이터는 행렬 또는 벡터 형태로 수신될 수 있다. 방법은 행렬로부터의 입력 프레임을 다수의 벡터들로 분할하는 단계, 행렬 곱셈에 의한 행렬을 행렬 곱셈에 의한 다수의 벡터들로 분해 (decomposing)하는 단계, 행렬(예를 들어, 메모리 유닛에 저장되고 스트리밍 입력 데이터와 곱하는데 사용되는 행렬)의 희소성 레벨을 결정하는 단계, 및/또는 계산 효율성을 향상시키기 위해 저장된 행렬에서 제로(zero)가 아닌 값들을 결정하는 단계를 더 포함한다. 본 명세서에 설명된 주제의 특정 실시예는 다음 이점 중 하나 이상을 실현하도록 구현될 수 있다. 이 문서에 설 명된 기술은 다양한 프레임 크기와 도달 레이트를 가진 다양한 스트리밍 데이터를 프로세싱할 수 있는 하드웨어 구성요소, 예를 들어 기계 학습 프로세서를 생성하는 데 강력할 수 있다. 보다 구체적으로, 설명된 기술을 수행 하는 시스템은 하드웨어 아키텍처 템플릿의 설계 파라미터 값들을 결정함으로써 특정 스트리밍 입력 데이터에 대한 하드웨어 아키텍처를 커스터마이징할 수 있다. 이 기술은 신속하게 파라미터 값들을 결정하여 민첩한 하드 웨어 개발을 가능하게 할 수 있다. 하드웨어 아키텍처 템플릿은 결정된 설계 매개변수 값들에 기초하여 하드웨 어 아키텍처를 인스턴스화하는 데 사용될 수 있으며, 이를 통해 데이터 레이트, 데이터 크기 및/또는 기타 특성 이 다양하게 변화하는 스트리밍 입력 데이터를 지원할 수 있는 확장 가능하고 커스터마이징 가능한 하드웨어 아 키텍처가 가능하다. 인스턴스화된 하드웨어 아키텍처는 특정 스트리밍 입력 데이터를 프로세싱할 때 백프레셔를 줄이고 심지어 제거하도록 향상될 수 있다. 하드웨어 아키텍처는 스트리밍되지 않고 최대 50%의 희소성 레벨까 지 다양한 희소성 레벨을 갖는 다양한 행렬을 프로세싱하기 위해 즉시 다시 인스턴스화되도록 구성될 수 있다. 또한, 본 문서에 설명된 기술은 스트리밍 입력 데이터를 프로세싱하는 효율성을 향상시킨다. 보다 구체적으로, 설명된 기술은 스트리밍 입력 데이터에 대한 계산, 예를 들어 기계 학습 계산을 수행하기 위해 더 적은 계산 리 소스, 더 적은 전력 및 더 적은 메모리를 사용할 수 있다. 템플릿에 대한 설계 파라미터 값들은 하나 이상의 요 인, 요구사항 또는 기준에 기초하여 결정된다. 예를 들어 설계 파라미터 값들은 전력 사용량을 최소화하고 특정 입력 도달 레이트를 유지하도록 결정될 수 있다. 예를 들어, 하드웨어 구성요소에 대한 전력 및/또는 크기 요구 사항을 계속 충족하면서 스트리밍 입력 데이터가 백프레셔 없이 프로세싱될 수 있도록 설계 파라미터들이 결정 될 수 있다. 설명된 기술을 수행하는 시스템은 희소 행렬에 대한 특정 처리를 수행하여 메모리 사용량을 줄일 수도 있다. 예를 들어, 시스템은 스트리밍 입력 데이터를 프로세싱하기 위해 비스트리밍 행렬의 제로 값을 저장 하는 것을 억제(refrain)하고 비스트리밍 행렬의 제로가 아닌 값과 연관된 입력 값에 대해서만 연산을 수행할 수 있으며, 이는 연산 수행을 위한 계산 리소스를 줄이고, 데이터 전송을 위한 메모리 대역폭과 저장을 위한 메 모리 크기를 줄일 수 있다. 또한, 본 문서에 설명된 기술은 높은 처리량 및 성능으로 스트리밍 입력 데이터를 프로세싱할 수 있다. 설명된 기술은 다양한 프로세싱 요구 사항에 따라 프로세싱 속도와 컴퓨팅 유닛 유휴 시간(idle time)의 균형을 유지함 으로써 스트리밍 입력 데이터의 프로세싱 레이턴시를 줄일 수 있다. 예를 들어, 템플릿에 의해 생성된 하드웨어 구성요소는 스트리밍 입력 데이터의 각 프레임을 더 빠른 속도로 프로세싱할 수 있으며 하드웨어 구성요소에 있 는 하나 이상의 컴퓨팅 유닛에 더 많은 유휴 시간이 발생할 수 있다. 대안적으로, 하드웨어 구성요소는 각 프레 임을 감소된 속도로 프로세싱할 수 있지만 여전히 각 프레임을 적시에 프로세싱할 수 있다. 또한 설명된 기술은잠재적인 논리 혼잡이나 하드웨어 클럭 레이트 감소를 방지함으로써 높은 처리량을 보장할 수도 있다. 예를 들 어, 설명된 기술은 생성된 하드웨어 아키텍처가 확장성 한계에 도달할 때까지 설계 파라미터들의 세트의 서브세 트만 탐색할 수 있으며, 여기서 설계 파라미터들의 서브세트에 대한 값들을 더 증강시키면 논리 혼잡이 발생하 거나 하드웨어 클럭 레이트에 부정적인 영향을 미칠 수 있다. 본 명세서의 주제의 하나 이상의 실시예의 세부 사항은 첨부 도면 및 아래 설명에 설명되어 있다. 주제의 다른 특징, 측면 및 이점은 설명, 도면 및 청구범위로부터 명백해질 것이다."}
{"patent_id": "10-2024-7010747", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 1, "content": "도 1은 예시적인 아키텍처 설계 시스템을 도시한다. 아키텍처 설계 시스템은 하나 이상의 위치에 있 는 하나 이상의 컴퓨터에서 구현되는 시스템의 예이며, 여기서 후술되는 시스템, 구성요소 및 기술이 구현될 수 있다. 아키텍처 설계 시스템의 구성요소 중 일부는 하나 이상의 컴퓨터에서 실행되도록 구성된 컴퓨터 프 로그램으로 구현될 수 있다. 도 1에 도시된 바와 같이, 아키텍처 설계 시스템은 하드웨어 구성요소에 대한 향상된 하드웨어 아키텍처와 연관된 출력 데이터를 생성하기 위해 입력 데이터를 프로세싱하도록 구성된 아키텍처 향상 (enhancement) 서브시스템을 포함할 수 있다. 보다 구체적으로, 출력 데이터는 하드웨어 아키텍처를 인스턴스화하는 데 사용될 수 있고, 하드웨어 아키 텍처는 스트리밍 입력 데이터, 예를 들어 이미지 스트리밍을 프로세싱하도록 구성된 하드웨어 구성요소를 제조 하는 데 사용될 수 있다. 하드웨어 구성요소는 스트리밍 입력 데이터를 프로세싱하기 위해 다양한 동작, 예를 들어 구성요소에 저장된 행렬 또는 벡터와 스트리밍 입력 데이터를 사용하는 기계 학습 계산 동작을 수행하도록 구성될 수 있다. 스트리밍 입력 데이터는 벡터, 행렬 또는 텐서 형태일 수 있다. 하드웨어 구성요소는 그래픽 프로세싱 유닛(GPU), 텐서 프로세싱 유닛(TPU), 애플리케이션 특정 집적 회로(ASIC), 또는 이미지 스트리밍을 만족스럽게 프로세싱하도록 구성된 다른 적절한 프로세싱 유닛 또는 회로일 수 있다. 예를 들어, 하드웨어 구성요소는 스트리밍 입력 데이터, 예를 들어 이미지 또는 비디오의 스트리밍을 프로세싱 하도록 구성된 하나 이상의 계산 유닛들로 설계된 스마트폰, 컴퓨터, 휴대용 태블릿 등과 같은 클라이언트 디바 이스 또는 엣지 디바이스의 일부일 수 있다. 스트리밍 입력 데이터는 하드웨어 구성요소에 의해 정의된 시간 간 격으로 프레임 단위로 수신될 수 있으며, 예를 들어 엣지 디바이스에 저장된 다른 데이터를 사용하여 수신 순서 에 따라 엣지 디바이스에 의해 프로세싱될 수 있다. 예를 들어, 엣지 디바이스는 엣지 디바이스에 저장된 네트 워크 가중치를 사용하여 얼굴을 인식하기 위해 프레임 단위로 입력 비디오를 프로세싱하는 신경망의 추론 동작 들을 수행할 수 있다. 입력 데이터는 특정 하드웨어 아키텍처를 갖는 하드웨어 구성요소에 의해 프로세싱될 스트리밍 입력 데이 터의 특성들을 나타내는 데이터를 포함할 수 있다. 특성들은 스트리밍 입력 데이터에 대한 특정 수신 레이트를 포함할 수 있다. 예를 들어, 수신 레이트는 밀리초, 초, 분 또는 기타 적절한 시간 단위당 하나의 프레임일 수 있다. 일부 구현예에서, 스트리밍 입력 데이터는 예를 들어 비디오의 다수의 이미지 프레임들을 포함할 수 있다. 특성들은 시간 단계에서 수신된 각 프레임에 대한 특정 데이터 크기를 더 포함할 수 있다. 예를 들어, 각프레임이 이미지 프레임인 경우, 데이터 크기는 720 x 480 픽셀, 1280 x 720 픽셀, 1920 x 1080 픽셀, 4096 x 2160 픽셀 이상의 픽셀 해상도가 될 수 있다. 또 다른 예에서, 각 프레임의 데이터 크기는 각 프레임의 비트 또 는 바이트의 수일 수 있다. 예를 들어, 프레임이 다른 유형의 데이터인 경우, 데이터 크기는 비트 또는 바이트 로 표현될 수 있다. 입력 데이터는 또한 다른 특성들도 포함할 수 있다. 특성들의 한 예는 스트리밍 입력 데이터를 수신하도록 구성 된 센서의 블랭킹 기간일 수 있다. 블랭킹 기간은 수직 블랭킹 기간, 수평 블랭킹 기간 또는 둘 다를 포함할 수 있다. 블랭킹 기간은 일반적으로 센서가 프레임 또는 필드의 마지막 가시 라인(예: 하단 또는 왼쪽 라인)의 끝 을 수신하는 시간과 센서가 다음 프레임의 첫 번째 가시 라인(예: 상단 또는 오른쪽 라인)의 시작을 수신하는 시간 사이의 기간을 나타낸다. 하나의 특정 예에서, 블랭킹 기간의 주파수(즉, 기간의 역수)는 수직 블랭킹 기 간의 경우 60Hz이고 수평 블랭킹 기간의 경우 15,750Hz일 수 있다. 다른 주파수도 사용할 수 있다. 따라서 하드 웨어 구성요소의 프로세싱 레이트는 이상적으로 스트리밍 이미지 프레임의 블랭킹 기간을 수용하는 것이다. 또 다른 예시적인 특성은 스트리밍 입력 이미지 데이터의 픽셀 포맷(또는 색상 포맷), 예를 들어 RGB 또는 YUV 일 수 있다. 또한, 스트리밍 입력 데이터의 특성은 스트리밍 입력 데이터의 각 프레임별 도달 순서를 포함할 수 있다. 스트리밍 입력 데이터는 오디오 데이터 또는 신호일 수도 있다. 예를 들어, 오디오 데이터는 한 명 이상의 개인 이 생성한 하나 이상의 음성 녹음, 소리 녹음, 배경 소음 또는 기타 적절한 유형의 오디오 데이터를 포함할 수 있다. 스트리밍 오디오 데이터는 스마트 스피커나 기타 유형의 디지털 보조 장치에서 캡처한 오디오를 포함할 수 있다. 스트리밍 오디오 입력는 팟캐스트, 라디오 방송 및/또는 마이크와 같은 오디오 센서에 의해 캡처될 수 있는 다른 유형의 오디오를 포함할 수 있다. 스트리밍 입력 데이터는 스트리밍 오디오 입력 데이터의 다양한 특성들을 포함할 수 있다. 예를 들어, 스트리밍 오디오의 특성들은 샘플링 레이트를 포함할 수 있다. 샘플링 레이트는 일반적으로 오디오 센서를 사용하여 오디 오 신호로부터 샘플링된 아날로그 신호의 샘플링 주파수, 즉 단위 시간당 수집되는 샘플 아날로그 신호의 양을 의미한다. 샘플링 레이트는 44.1kHz, 48kHz, 88.2kHz, 96kHz, 192kHz 이상이 될 수 있다. 또 다른 예로, 스트 리밍 오디오 입력 데이터의 특성들은 비트 깊이를 포함할 수 있다. 비트 깊이는 일반적으로 오디오 샘플당 비트 크기를 나타내며, 때로는 오디오 샘플의 오디오 해상도라고도 한다. 비트 깊이는 4비트, 16비트, 24비트, 64비 트 또는 기타 적절한 비트 깊이일 수 있다. 일부 구현예에서, 스트리밍 오디오 입력 데이터의 특성들은 비트 레 이트를 포함할 수 있다. 비트 레이트는 일반적으로 단위 시간당 전달되거나 프로세싱되는 비트의 양을 나타낸다. 비트 레이트는 샘플링 레이트 및 비트 깊이에 기초하여 계산될 수 있으며, 예를 들어 디지털 오디오 컴팩트 디스크 오디오(CD)는 CD가 44.1kHz의 샘플링 레이트, 16비트의 비트 깊이 및 더블 트랙을 가질 때, 1.4Mbit/s의 비트 레이트를 가질 수 있다. 하드웨어 구성요소의 프로세싱 레이트는 하드웨어 구성요소가 스트리 밍 입력 오디오를 프로세싱할 때 백로깅(backlogging)을 방지하기 위해 오디오 스트리밍 입력 데이터의 비트 레 이트보다 이상적으로 빠르다. 오디오 스트리밍 입력 데이터에 대한 다른 특성들은 데이터에 대한 오디오 포맷을 포함할 수 있다. 예를 들어, 오디오 스트리밍 입력 데이터는 PCM(Pulse-Code Modulation), MP3(MPEG-1 Audio Layer 3), WMA(Windows Media Audio) 또는 기타 적절한 오디오 포맷의 오디오 포맷으로 인코딩될 수 있다. 일부 구현예에서, 입력 데이터는 하드웨어 구성요소, 예를 들어 기계 학습 계산을 수행하는 기계 학습 프 로세서에 의해 프로세싱될 스트리밍 입력 데이터를 포함할 수 있다. 아키텍처 향상 서브시스템은 스트리밍 입력 데이터를 분석하여 스트리밍 입력 데이터의 특성들, 예를 들어 각 프레임의 수신 레이트 또는 도달 레이트 및 각 프레임의 크기를 나타내는 데이터를 생성하도록 구성될 수 있다. 선택적으로, 입력 데이터는 또한 하드웨어 아키텍처 템플릿을 인스턴스화하기 위한 구성가능한 설계 파라 미터들의 세트에 대한 초기 값들을 나타내는 데이터를 포함할 수 있다. 초기 값들은 디폴트(default) 아키텍처, 예를 들어 클러스터당 하나의 MAC 유닛을 포함하는 아키텍처를 인스턴스화하는 데 사용될 수 있다. 디폴트 아키 텍처는 예를 들어 클러스터의 SRAM(Static Random Access Memory) 기반 라인 버퍼 유닛을 포함할 수 있으며, 여기서 라인 버퍼 유닛은 단일 메모리 뱅크를 가지며, 각 프레임의 입력 픽셀의 전체 라인을 저장하도록 구성된 다. 또 다른 예로서, 초기값들은 디폴트 아키텍처에서 제로 어큐뮬레이터(accumulator) 어레이들을 나타내는 데 이터를 포함할 수 있다. 위의 예에서 스트리밍 입력 데이터는 이미지 프레임들의 스트림이지만, 스트리밍 입력 데이터는 오디오 녹음, 벡터 및 텐서와 같은 데이터 구조와 같은 다양한 유형의 데이터를 포함할 수 있음을, 단지 몇 가지 예를 들어, 이해해야 한다. 출력 데이터는 아키텍처 템플릿을 사용하여 하드웨어 아키텍처를 인스턴스화하거나 다시 인스턴스화하기 위한 향상된 파라미터 값들의 세트를 적어도 포함할 수 있다. 향상된 매개변수 값들의 세트는 아키텍처 템플릿 의 설계 파라미터들의 세트에 대해 결정된다. 설계 파라미터들은 적어도 하드웨어 아키텍처 내의 클러스터들의 수, 각 클러스터 내의 PE들의 수, 각 프로세싱 요소(PE) 내의 MAC 어레이 크기, 또는 이들 파라미터들 중 둘 이 상의 조합을 포함할 수 있다. 예를 들어, MAC 어레이의 크기는 1, 4, 10 이상이 될 수 있다. 또 다른 예로, 각 클러스터 내의 PE들의 수는 1, 4, 7, 20, 50개 이상이 될 수 있다. 또 다른 예로, 하드웨어 아키텍처 내의 클러 스터들의 수는 1, 2, 8, 15, 30개 이상이 될 수 있다. 일부 구현예에서, 출력 데이터는 향상된 파라미터 값들의 세트 및 하드웨어 구성요소가 어떻게 제조되어야 하는지를 정의하는 임의의 다른 데이터를 포함하여 향 상된 하드웨어 아키텍처를 정의하는 데이터를 포함할 수 있다. 출력 데이터는 위에서 설명한 바와 같이 하드웨어 회로로 합성되고 객체 지향 방식으로 프로그래밍될 수 있는 고급 컴퓨터 언어, 예를 들어 C 또는 C++로 인코딩될 수 있다. 다른 예에서, 출력 데이터는 향상된 파라미터 값들의 리스트일 수 있다. 출력 데이터는 출력 데이터 내의 파라미터 값들을 사용하여 템플릿에 의해 인스턴스화되는 하드웨어 아키 텍처를 갖는 하드웨어 구성요소를 생성하기 위해 제조 시스템에 제공될 수 있다. 제조 시스템은 하드 웨어 구성요소를 제조하기 위한 임의의 적합한 시스템, 예를 들어 제조 시스템 또는 화학-기계적 연마 (polishing) 시스템일 수 있다. 아키텍처 향상 서브시스템은 입력 데이터에 기초하여 아키텍처 템플릿을 프로세싱함으로써 출력 데이터를 생성하도록 구성된 향상 엔진을 포함할 수 있다. 예를 들어, 아키텍처 향상 서브시스템 은 아키텍처 템플릿을 나타내는 데이터를 저장하고 향상 엔진에 제공하도록 구성된 메모리 유닛 을 포함할 수 있다. 대안적으로, 향상 엔진은 아키텍처 향상 서브시스템 외부에 있는 서버 또는 메모리 유닛으로부터 아키텍처 템플릿을 수신할 수 있다. 아키텍처 템플릿은 다수의 구성가능한 설계 파라미터들을 갖는 하이-레벨 프로그램 코드일 수 있다. 아키 텍처 템플릿은 설계 파라미터 값들의 세트를 수신하도록 구성되고, 일단 시스템에 의해 실행되면, 특정 유 형의 스트리밍 입력 데이터를 프로세싱하기 위한 하드웨어 구성요소를 제조하는 데 사용되는 하드웨어 아키텍처 를 나타내는 출력 데이터를 생성할 수 있다. 예를 들어, 향상 엔진은 다수의 설계 파라미터 값들의 세트를 아키텍처 템플릿에 제공하고 다수의 후보 아키텍처들을 생성할 수 있다. 향상 엔진은 다수의 후보 아키텍처들을 생성하도록 구성된 후보 생성기를 포함한다. 후보 생성 기는 입력 데이터 및 아키텍처 템플릿을 프로세싱하여 다수의 후보 아키텍처들을 생성할 수 있다. 후보 생성기는 특정 기간 동안 주어진 이용가능한 리소스가 설계 파라미터들의 세트에 의해 형성 된 검색 공간에서 다수의 파라미터 값들을 탐색하도록 구성된다. 검색 공간은 스트리밍 입력 데이터를 프로세싱 하기 위한 목표 계산 요구 사항에 따라 10, 수백, 수만 개의 설계 포인트(예: 모든 설계 파라미터들에 대한 각 각의 값들을 포함하는 튜플(tuple)들) 또는 기타 적절한 개수의 설계 포인트 범위의 크기를 가질 수 있다. 탐색 을 통해 획득된 후보 설계 파라미터 값들의 각 세트에 대해, 후보 생성기는 아키텍처 템플릿을 사용 하여 대응하는 하드웨어 아키텍처를 인스턴스화할 수 있다. 검색 공간 탐색에 대한 자세한 내용은 아래에서 설 명된다. 향상 엔진은 또한 후보 아키텍처를 분석하고 하나 이상의 성능 모델들을 사용하여 각 후보 아키 텍처에 대한 성능 값을 생성하도록 구성된 분석 엔진을 포함한다. 예를 들어, 성능 값은 스트리 밍 입력 데이터를 프로세싱할 때 후보 아키텍처의 성능을 나타내는 임의의 적절한 숫자 값, 예를 들어 0부 터 100까지 범위의 스칼라 값을 포함할 수 있다. 예를 들어, 후보 아키텍처에 대한 성능 값은 스트리 밍 입력 데이터를 프로세싱하기 위해 사용될 때 후보 하드웨어 아키텍처가 얼마나 효율적인지 나타낼 수 있다. 예를 들어, 효율성은 계산 속도, 백프레셔 상황에서의 시간 비율, 데이터 프로세싱 레이트 또는 백프레셔 를 방지하기 위한 데이터 프로세싱 레이트 요구 사항을 충족하는 아키텍처의 데이터 프로세싱 레이트와 관련된 전력 또는 공간 소비에 기초할 수 있다. 하드웨어 아키텍처가 제1 스트리밍 입력 데이터를 프로세싱할 때는 높 은 성능 값(예: 100 중 90)을 가지지만, 제1 스트리밍 입력 데이터와 다른 특성을 갖는 제2 스트리밍 입력 데이 터를 프로세싱할 때는 낮은 성능 값(예: 100 중 30)을 가질 것으로 예측되는 것은 드문 일이 아니다. 따라서 특 정 스트리밍 입력 데이터를 프로세싱하기 위한 다수의, 예를 들어 모든 후보 아키텍처들과 연관된 성능 값들을생성함으로써, 시스템은 아키텍처 템플릿을 사용하여 특정 스트리밍 입력 데이터를 프로세싱하기 위 한 최고 성능의 후보 아키텍처 설계 중 하나 이상을 효율적으로 획득할 수 있다. 성능 모델은 특정 유형의 스트리밍 입력 데이터를 프로세싱하기 위해 하드웨어 아키텍처에 대한 성능의 다 양한 측면에 액세스하도록 구성된 분석적, 기계 학습 기반 또는 시뮬레이션 모델일 수 있다. 성능 메트릭은 하 드웨어 아키텍처의 다양한 측면, 예를 들어 전력 소비, 리소스 사용량, 처리량 또는 입력 데이터에 표시된 특성들을 갖는 스트리밍 입력 데이터를 프로세싱할 때 임의의 백프레셔가 있는지 여부를 측정할 수 있다. 성능 모델은 아키텍처 향상 서브시스템의 메모리 유닛에 저장되거나 외부 메모리 유닛 또는 서 버에 의해 제공되는 데이터로 표현될 수 있다. 도 1에 도시된 바와 같이, 선택 엔진은 성능 값들에 기초하여 향상된 하드웨어 아키텍처로서 다수의 후보 아키텍처들로부터 후보 아키텍처를 선택하도록 구성될 수 있다. 예를 들어, 선택 엔진은 가장 높은 성능 값들을 갖는 후보 아키텍처를 향상된 후보 아키텍처로 선택할 수 있다. 다른 예로서, 선택 엔진 은 지정된, 예를 들어 미리 정의된 임계값보다 높은 성능 값을 갖는 후보 아키텍처를 선택할 수 있고 최소 전력이나 리소스, 또는 둘 다를 사용할 수 있다. 예를 들어, 선택 엔진은 지정된 임계값을 충족하거 나 초과하지 않는 성능 값을 갖는 각 후보 아키텍처를 후보 아키텍처들로부터 필터링할 수 있다. 그 런 다음, 선택 엔진은 나머지 후보 아키텍처들로부터 성능 값, 전력 소비 추정치, 필요한 리소스 및/또는 회로 기판(들)의 공간 등에 기초하여 특정 후보 아키텍처를 선택할 수 있다. 예를 들어, 선택 엔진은 최소 한의 전력을 소비하고/하거나 최소한의 공간을 요구하는 나머지 후보 아키텍처를 선택할 수 있다. 다른 예에서, 선택 엔진은 전력 소비 및/또는 필요한 공간에 기초하여 후보 아키텍처들을 필터링할 수 있다. 예를 들어, 하드웨어 구성요소가 설계되는 디바이스는 이용가능한 전력 및/또는 공간이 제한적일 수 있으며, 예를 들어 디바이스가 스마트폰이나 기타 모바일 디바이스인 경우 특히 그렇다. 이 예에서, 선택 엔진 은 후보 아키텍처들로부터 이용가능한 전력 또는 공간을 초과하는 각 후보 아키텍처를 필터링할 수 있다. 그러면 선택 엔진은 예를 들어 가장 높은 성능 값을 갖는 나머지 후보 아키텍처를 선택함으 로써 성능 값들에 기초하여 나머지 후보 아키텍처들로부터 선택할 수 있다. 선택 엔진은 추가 동작을 위해 향상된 하드웨어 아키텍처, 향상된 파라미터 값들, 또는 둘 다를 출력 데이 터로 인코딩할 수 있다. 예를 들어, 향상된 파라미터 값들은 향상된 하드웨어 아키텍처를 병렬로 인스턴스 화하기 위해 다수의 컴퓨터에 제공될 수 있다. 다른 예로서, 향상된 하드웨어 아키텍처는 향상된 하드웨어 아키 텍처에 기초하여, 대응하는 하드웨어 구성요소를 예를 들어 병렬로 제조하기 위해 하나 이상의 제조 장치에 제 공될 수 있다. 도 2-5는 서로 다른 설계를 갖는 예시적인 하드웨어 구성요소들이 스트리밍 입력 데이터의 프레임을 프로세싱하 는 예시적인 시나리오를 도시한다. 편의상, 위에 언급된 프로세스는 하나 이상의 위치에 위치한 하나 이상의 컴 퓨터의 하드웨어 구성요소에 의해 수행되는 것으로 설명된다. 예를 들어, 도 1의 아키텍처 설계 시스템을 사용하여 제조된 하드웨어 구성요소는 적절하게 프로그래밍되어 이러한 프로세스를 수행할 수 있다. 템플릿을 사용하여 제조된 설명된 하드웨어 구성요소는 다양한 레벨의 설계로 스트리밍 입력 데이터를 프로세싱 하도록 구성된다. 예를 들어, 하드웨어 아키텍처는 클러스터에 대한 제1 레벨 설계를 가질 수 있고, 프로세싱 요소(본 문서에서는 프로세싱 유닛이라고도 함)에 대한 제2 레벨 설계, 하드웨어 유닛 어레이(하드웨어 컴퓨팅 유닛 어레이 또는 이하 하드웨어 컴퓨팅 어레이, 예를 들어 MAC 유닛 어레이라고도 함)에 대한 제3 레벨 설계를 가질 수 있다. 설명된 하드웨어 아키텍처는 각 설계 레벨을 결정한 후 템플릿에서 인스턴스화할 수 있다. 예를 들어, 설계 파라미터들은 클러스터들의 수 및/또는 배열, 각 클러스터 내의 PE들의 수 및/또는 배열, 및/또는 각 PE 내의 하드웨어 유닛 어레이들의 수를 포함할 수 있다. 다른 예로서, 설계 파라미터들은 각 하드웨어 유닛 어레이의 차원, 예를 들어 하드웨어 유닛 어레이 내의 하드웨어 유닛들(예: MAC 유닛들)의 차원 또는 수에 대응 한다. 도 2에 도시된 바와 같이, 예시적인 하드웨어 아키텍처는 하나의 프로세싱 유닛을 포함하는 하나의 클러스터를 포함할 수 있다. 프로세싱 유닛은 하드웨어 컴퓨팅 유닛 어레이를 포함할 수 있다. 다른 예로서, 도 3에 도시된 하드웨어 아키텍처에서, 각 클러스터는 다수의 프로세싱 유닛들(340a- c)을 포함할 수 있으며, 각 프로세싱 유닛(340a-c)은 각각 하나의 하드웨어 유닛 어레이(350a-c)를 갖는다. 또 한, 하드웨어 아키텍처의 또 다른 예는 다수의 클러스터들(430a, 430b)을 포함할 수 있다. 각 클러스터 (430a, 430b)는 프로세싱 유닛(440a, 440b)을 포함할 수 있다. 각 프로세싱 유닛(440a, 440b)은 각각 하나의하드웨어 유닛 어레이(450a, 450b)를 포함할 수 있다. 또한, 하드웨어 아키텍처의 또 다른 예는 다수의 클 러스터들(530a-x)을 포함할 수 있으며, 각 클러스터는 다수의 프로세싱 유닛들(540a-x)을 갖고, 각 프로세싱 유 닛(540a-x)은 하드웨어 유닛 어레이(550a-z)를 포함한다. 각 하드웨어 아키텍처(200-500)에 대해 설명의 편의를 위해 단지 2개, 3개 또는 4개의 클러스터, 프로세싱 유닛 또는 하드웨어 유닛 어레이가 도 2-5에 도시되어 있지 만, 하드웨어 아키텍처는 다른 수량의 클러스터, 프로세싱 유닛 및 하드웨어 유닛 어레이를 포함할 수 있음을 이해해야 한다. 하드웨어 아키텍처는 단위 시간당, 예를 들어 각 프레임에 대한 시간 단계에서, 스트리밍 입력 데이터의 프레임 을 프로세싱하도록 구성될 수 있다. 스트리밍 입력 데이터의 각 프레임은 다수의 차원을 갖는 벡터 형태, 예를 들어 2, 5, 10 또는 20개 항목의 벡터로 수신될 수 있다. 입력 벡터의 차원은 이 될 수 있다. 대 안적으로, 스트리밍 입력 데이터의 각 프레임은 행렬 형태로 수신될 수 있으며, 이는 입력 행렬을 다수의 벡터 로 분할하여 벡터로 프로세싱할 수 있다. 일반적으로, 하드웨어 아키텍처는 미리 저장된 행렬 또는 벡터를 사용하여 입력 벡터에 대한 연산들을 수행할 수 있다. 미리 저장된 행렬은 예를 들어, 과 같은 차원을 갖는 행렬로서 구조화될 수 있다. 일부 구현예에서, 연산은 벡터 또는 행렬 곱셈을 포함하므로 하드웨어 아키텍처에 의해 생성된 출력 데이 터는 차원의 벡터 형태일 수 있다. 또는 예를 들어 연산에 행렬-행렬 곱셈이 포함된 경우 출력 은 행렬 형태일 수 있다. 설명된 템플릿을 사용하여 설계 파라미터 값들에 기초하여 하드웨어 아키텍처를 결정한 후, 설명된 하드웨어 아 키텍처에 기초하여 제조된 하드웨어 구성요소 또는 시스템은 스트리밍 입력 데이터(예를 들어, 입력 벡터)의 각 프레임을 하드웨어 유닛 어레이의 차원, 예를 들어 어레이 내의 MAC 유닛들의 수에 기초하여 하나 이상의 부분 타일로 나눌 수 있다. 예를 들어, MAC 유닛 어레이가 어레이 내의 D개의 MAC 유닛들을 포함한다고 가정하면, 각 입력 타일의 차원은 차원 D일 수 있다. 이하 명세서에서는 부분 타일을 부분 세그먼트(partial segment)라고도 한다. 각 부분 타일은 입력 벡터의 중첩되지 않는(non-overlapping) 값들을 포함한다. 도 2-5를 다시 참조하면, 스트리밍 입력은 프레임 단위로 행렬 또는 벡터 형태로 수신될 수 있다. 프레임의 스 트리밍 입력이 행렬 형태로 수신되면, 컨트롤러 또는 스케줄러는 하드웨어 구성요소에 의한 추가 프로세싱을 위 해 입력 행렬을 긴 벡터 또는 다수의 벡터로 다시 매핑하거나 모양을 변경할 수 있다. 예를 들어 스트리밍 입력 데이터의 각 프레임이 행렬 형태로 수신되는 경우, 컨트롤러 또는 스케줄러는 행렬의 각 행을 벡터로 처리하고, 행렬 곱셈에 의한 행렬의 계산을 행렬 곱셈에 의한 벡터로 변환할 수 있다. 입력 행렬 또는 벡터들과 곱해지는 다른 행렬은 추가 스트리밍된 입력 데이터가 아닌 메모리 유닛에 저장되는 행렬이다. 스트리밍 입력 벡터는 다수의 중첩되지 않는 부분 세그먼트들(215a-215c)로 분할될 수 있으며, 각각은 하 드웨어 유닛 어레이의 크기에 대응하는 차원 D를 갖는다. 시스템 내의 컨트롤러 또는 스케줄러(예를 들어, 하드웨어 계층적 상태 머신)는 이러한 세그먼트들(215a-c)을 생성하고 이러한 세그먼트들을 사용하여 서로 다른 클러스터들, PE들 및 MAC 유닛 어레이들에서 동작들이 수행되도록 스케쥴링할 수 있다. 유사하게, 스트리밍 입 력 벡터(310, 410, 510)는 각각 다수의 부분 세그먼트들(315a-c, 415a-c, 515a-c)로 분할될 수 있다. 도 2-5에 는 단지 3개의 부분 세그먼트만이 도시되어 있지만, 시간 단계에 대한 입력 벡터의 각 프레임은 3개 이상의 부 분 세그먼트, 예를 들어 4, 8, 12, 24, 51 또는 다른 적절한 수의 부분 세그먼트로 분할될 수 있다는 것을 이해 해야 한다. 일반적으로, 차원 D는 하드웨어 구성요소에 저장된 입력 행렬의 열 또는 행 길이인 과 같거나 작을 수 있다. 예를 들어, 스트리밍 입력 데이터의 프레임은 입력 차원이 100일 수 있다. 각 부분 타일 및 대응하는 하 드웨어 유닛 어레이는 1, 10, 20, 50, 100의 차원 또는 다른 적절한 차원을 가질 수 있다. 구성요소 또는 시스템은 하나 이상의 버퍼, 예를 들어 하드웨어 유닛 어레이를 포함하는 프로세싱 유닛의 버퍼 에 부분 세그먼트 모두를 저장할 수 있다. 하드웨어 구성요소 또는 시스템은 미리 저장된 행렬의 대응하는 행 또는 열(예를 들어, 부분 타일에 대응하는 행 또는 열)로부터 페치(fetch)되거나 프리페치(pre-fetch)되는 크기 D의 벡터에 기초하여 각 입력 부분 타일에 대한 연산을 수행하도록 구성될 수 있다. 다시 도 2-5를 다시 참조하면, 미리 저장된 행렬은 각각 행렬 데이터 (220, 320, 420, 520)가 될 수 있다. 연산은 예를 들어 내적(dot product) 및 기타 적절한 요소별 산술 연산을 포함할 수 있다. 하드웨어 구성요소 또는 시스템은 이 시간 단계에서 위에 언급된 연산을 수행함으로써 부분 출력(예: 부분 합)을 생성하고 어큐뮬레이터 어레이, 예를 들어 도 2-5에 도시된 어큐뮬레이터 어레이(260, 360, 460 및 560)에 부분 출력을 각각 저장할 수 있다. 하드웨어 구성요소 또는 시스템은 각각의 입력 부분 타일 및 미리 저장된 행렬의 대응하는 부분 행 또는 열에 대해 위에서 언급한 연산들을 반복적으로 수행할 수 있다. 총 반복 횟수는 설계 파라미터들, 예를 들어 클러스 터들, PE들, 하드웨어 유닛 어레이들의 다양한 수량 및 각 하드웨어 유닛 어레이의 차원 D에 기초할 수 있다. 예를 들어, 도 2를 다시 참조하면, 스트리밍 입력 데이터의 각 프레임에 대해 하드웨어 구성요소 또는 시스템은 위에서 언급한 연산들을 시간 동안 반복할 수 있다. 따라서, 어큐뮬레이터 어레이의 크기는 모든 부 분 출력을 저장하기 위해 이 될 수 있다. 어큐뮬레이터 어레이는 저장된 부분 출력을 집계하고 추가 연산을 위해 집계된 출력을 제공할 수 있다. 또 다른 예로서 도 3을 다시 참조하면, 하드웨어 아키텍처는 클러스터 내에 다수의 프로세싱 유닛들 (340a-c)을 포함할 수 있다. 각 프로세싱 유닛(340a-c)이 크기 1의 하드웨어 유닛 어레이(350a-c)(MAC 어레이), 예를 들어 각 하드웨어 유닛 어레이(350a-c) 내에 단일 MAC 유닛만 가질 수 있다고 가정하면, MAC 어레이들의 수는 클러스터 내의 프로세싱 유닛들(340a-c)의 수와 동일하다. 설명된 하드웨어 구성요소 또는 시스템은 하드웨어 유닛 어레이가 1차원을 갖기 때문에 입력 벡터를 각각 1차원의 요소 차원을 갖는 다수의 부분 타일로 나눌 수 있다. 출력 차원이 프로세싱 유닛들의 수보다 크거나 같다고 가정하면, 하나 이상의 프로세싱 유닛들이 하나 이상의 부분 타일, 즉 개의 부분 타일을 수행하는데 사용될 수 있다. 각 프로세싱 유닛은 크 기의 어큐뮬레이터 어레이를 가질 수 있다. 예를 들어, 출력 차원이 10이고 클러스터당 프로세싱 유닛의 수가 5인 경우, 각 프로세싱 유닛은 두 개의 부분 입력 타일을 각각 프로세싱하기 위해 두 번 사용되며, 각 프로세싱 유닛은 크기가 2인 어큐뮬레이터 어레이를 가질 수 있다. 도 3의 프로세싱 유닛들은 계 산 리소스 효율성을 위해 출력 차원들과 같거나 그보다 작도록 설계되었다. 도 4를 참조하면, 예시적인 하드웨어 아키텍처는 다수의 클러스터들, 예를 들어 2개의 클러스터들(430a 및 430b)을 포함할 수 있다. 스트리밍 입력 벡터는 다수의 부분 세그먼트들(415a-c)로 분할된다. 다수의 부분 세그먼트들(415a-c) 각각은 하드웨어 유닛 어레이(들)(450a 및 450b)로서의 차원을 갖는다. 다수의 부분 세그먼트들(415a-c)은 2개의 클러스터들(430a 및 430b) 각각에 균등하게 분포(evenly- distributed)될 수 있다. 예를 들어, 도 4에 도시된 바와 같이, 부분 세그먼트들(415a, 415c)은 클러스터 (430a)에 할당되고, 부분 세그먼트(415b) 및 다른 부분 세그먼트(미도시)는 클러스터(430b)에 할당된다. 클러스터들(430a 및 430b) 각각은 행렬 데이터의 대응하는 부분 행 또는 열을 사용하여 할당된 부분 세그 먼트들을 프로세싱하도록 구성될 수 있다. 각 클러스터에서 수행되는 프로세스 및 동작은 도 2와 관련하여 설명 된 것과 유사하다. 각 클러스터(430a 및 430b)는 할당된 부분 세그먼트들을 프로세싱함으로써 각각의 부분 합을 생성할 수 있으며, 여기서 부분 합은 의 차원을 가질 수 있다. 각 클러스터(430a 및 430b)는 각 각의 부분 합 벡터를 어큐뮬레이터 유닛에 제공하도록 더 구성될 수 있다. 어큐뮬레이터 유닛은 서로 다른 클러스터로부터의 부분 합 벡터를 결합하여 출력 벡터를 생성하고 출력 벡터를 어큐뮬레이터 어레이 에 제공하도록 구성될 수 있다. 일부 구현예에서, 어큐뮬레이터 어레이는 의 차원을 가질 수 있 다. 도 5를 참조하면, 전술한 바와 같이, 예시적인 하드웨어 아키텍처는 다수의 클러스터들(530a-x)을 포함할 수 있고, 각 클러스터는 다수의 프로세싱 유닛들(540a-x)을 갖고, 각 프로세싱 유닛은 각각의 하드웨어 유닛 어 레이(550a-y)를 갖는다. 도 4의 프로세스와 유사하게, 설명된 하드웨어 구성요소 또는 시스템은 시간 단계에서 입력 벡터의 프레임을 다 수의 부분 세그먼트들(5151a-c)로 분할하도록 구성될 수 있다. 각각의 클러스터(530a-x)는 부분 세그먼트들의 각각의 서브세트가 실질적으로 균등하게 할당된다. 예를 들어, 도 5에 도시된 바와 같이, 부분 세그먼트들 (515a, 515c)은 클러스터(530a)에 할당되고, 부분 세그먼트(515b)와 다른 부분 세그먼트(미도시)는 클러스터 (530x)에 할당된다. 각 클러스터(530a-x)는 도 3과 관련하여 설명된 것과 유사한 각각의 프로세스 및 동작을 수행한다. 각 클러스터 (530a-x)는 의 차원을 갖는 각각의 부분 합 벡터를 생성하고 각각의 부분 합을 어큐뮬레이터 유 닛에 제공할 수 있다. 어큐뮬레이터 유닛은 대응하는 부분 합 벡터를 결합하고 추가 동작을 위해 어 큐뮬레이터 어레이에 제공하기 위한 출력 벡터를 생성하도록 구성된다. 어큐뮬레이터 어레이는 의 차원을 포함할 수 있다. 다시 도 1을 참조하면 그리고 도 2-5와 관련하여, 아키텍처 설계 시스템은 서로 다른 스트리밍 입력 데이 터의 특성들에 따라 하드웨어 아키텍처(200, 300, 400, 500)를 생성할 수 있다. 예를 들어, 스트리밍 입력 데이 터의 도달 레이트가 느리거나(예: 초당) 각 프레임의 크기가 작은 경우(예: 이미지 프레임의 경우 120픽셀), 아 키텍처 설계 시스템은 클러스터 내의 단일 프로세싱 유닛을 사용하여 하드웨어 아키텍처와 유사한 하 드웨어 아키텍처를 생성할 수 있다. 또 다른 예로, 스트리밍 입력 데이터의 도달 레이트가 더 빠르거나(예: 밀 리초당) 각 프레임이 하드웨어 아키텍처(300, 400 또는 500)와 유사하게 큰 크기(예: 이미지 프레임의 경우 4000픽셀)인 경우, 클러스터 내에 다수의 프로세싱 요소들을 갖거나 다수의 클러스터들을 갖는다. 전술한 바와 같이, 예시적인 하드웨어 아키텍처는 하드웨어 유닛 어레이들의 차원, 프로세싱 유닛 내의 하드웨 어 유닛 어레이들의 수, 클러스터 내의 프로세싱 유닛들의 수 및 하드웨어 아키텍처 내의 클러스터들의 수 중 적어도 하나와 연관된 설계 파라미터 값들의 세트를 가질 수 있다. 시스템은 입력 데이터 도달 레이트, 처리량, 전력 소비 및 이용가능한 영역 또는 공간의 요구 사항에 대한 제약이 주어지면, 설계 파라미터들의 세트에 의해 형성된 검색 공간을 사용하여 설계 파라미터 값들의 세트를 결정하도록 구성된다. 설계 파라미터 값들의 세트를 결정하는 세부사항은 도 8과 관련하여 설명된다. 입력 벡터 프로세싱에 사용되는 미리 저장된 행렬로 돌아간다. 비스트리밍 행렬이라고도 하는 미리 저장된 행렬 은 온-디바이스 메모리, 예를 들어 온-칩 SRAM(Static Random Access Memory) 유닛에 페치되거나 프리페치된다. 미리 저장된 행렬의 크기는 시간 단계에서 입력 벡터의 크기에 대응하기 때문에, 벡터 입력이 클 수록 미리 저장된 행렬이 더 커야 하며, 이로 인해 온-칩 SRAM 소비가 더 커진다다. 도 6은 비스트리밍 행렬에 대한 예시적인 데이터 액세스 패턴을 도시한다. 편의상, 데이터 액세스 패턴은 하나 이상의 위치에 위치한 하나 이상의 컴퓨터 시스템에 의해 수행되는 프로세스와 연관된다. 예를 들어, 도 1 의 아키텍처 설계 시스템으로부터 생성된 하드웨어 아키텍처에 기초하여 제조되고, 적절하게 프로그래밍된, 하드웨어 구성요소는 데이터 액세스 패턴을 생성하는 프로세스를 수행할 수 있다. 도 5와 관련하여, 하드웨어 아키텍처가 두 개의 클러스터, 예를 들어 클러스터들(630a 및 630b)을 포함하고, 각 클러스터는 3개의 PE들(또는 프로세싱 유닛들)(640a-c)을 갖고, 각 PE들은 크기 4의 MAC 어레이를 갖는다고 가 정하면, 시스템은 예시적인 비스트리밍 행렬을 도 6에 도시된 바와 같이 두 개의 직사각형으로 도시된 두 부분으로 나눌 수 있다. 상단 부분은 클러스터(630a)에 할당될 수 있고 하단 부분은 클러스터(630b)에 할당될 수 있다. 시스템은 대응하는 부분 세그먼트를 프로세싱하기 위해 비스트리밍 행렬의 각각의 부분에 액세스할 수 있 다. 비스트리밍 행렬은 8×9의 차원을 갖는다. 예를 들어, 클러스터(630a)가 PE(640a)에서 크기 4의 부분 세그먼트(615a)를 수신하는 경우이다. 클러스터는 또한 상단 부분의 제1 열(예: 비스트리밍 행렬의 부분 열)에 액세스하고, 부분 세그먼트(615a)의 각 요소에 대해 PE(640a)의 부분 열의 대응하는 요소와 요소별 연산 을 수행하여 제1 부분 합을 생성할 수 있다. 유사하게, 클러스터(630a)는 PE(640b)에서 부분 세그먼트(615a)를 수신하고 상단 부분의 제2 열에 액세스하고, PE(640b)를 사용하여 부분 세그먼트(615a)와 상단 부분의 제2 열의 연산을 수행하여 제2 부분 합을 생성할 수 있다. 클러스터(630a)는 PE(640c)에서 부분 세그먼트(615a)를 수신하 고 상단 부분의 제3 열에 액세스하고, PE(640c)를 사용하여 부분 세그먼트(615a)와 상단 부분의 제3 열의 연산 을 수행하여 제3 부분 합을 생성할 수 있다. 제1, 제2, 제3 부분 합은 차원 3의 부분 합 벡터로 배열될 수 있다. 그런 다음 PE들(640a-c)은 상단 부분의 제4 내지 제6 열에 액세스하여 차원 3의 제2 부분 합 벡터를 생성하고, 상단 부분의 제7 내지 제9 열에 액세스하여 차원 3의 제3 부분 합 벡터를 생성함으로써 동작을 반복할 수 있다. 클러스터(630a)는 제1, 제2 및 제3 부분 합 벡터를 어큐뮬레이터 유닛(예를 들어, 도 5의 어큐뮬레이터 유닛 )에 제공하여, 1x9 차원의 중간 부분 합 벡터를 형성할 수 있다. 비스트리밍 행렬의 하단 부분으로 돌아가면, 클러스터들(630b)과 이에 대응하는 PE들(640d-f)은 하단 부분 의 각 열에 액세스하여 차원 1 x 9의 또 다른 중간 부분 합 벡터를 생성할 수 있다. 일부 구현예에서, 시스템은 두 개의 중간 부분 합 벡터를 출력 데이터로 제공할 수 있다. 또는 시스템에서 부분 합 벡터를 결합하여 1x9 차원의 출력 데이터를 생성할 수 있다. 스트리밍 입력 데이터의 프레임이 행렬 형태일 때, 시스템은 스트리밍 입력 데이터의 프레임을 프로세싱하기 위 해 위에서 설명된 기술과 유사한 프로세스를 따르는 동작을 수행할 수 있다. 예를 들어, 입력 프레임의 차원이 M 행과 K 열이고 하드웨어 구성요소나 시스템에서 행 단위로 수신되고, 비스트리밍 행렬의 차원이 K 행과 N 열 인 경우이다. 시스템은 입력 행렬의 각 행을 프로세싱하고 비스트리밍 행렬을 M 번 로드할 수 있다. 그러나, 입력 프레임의 크기가 크고 비스트리밍 행렬이 특정 희소성 레벨을 갖는 희소 행렬(즉, 특정 퍼센트의 제로 요소들을 갖는 행렬)인 경우, 큰 크기의 비스트리밍 행렬을 여러 번 로드하거나 프리페치하는 것은 전력 소비 및 계산 리소스 측면에서 비효율적이다. 희소 비스트리밍 행렬을 프로세싱하는 기술은 도 7과 관련하여 설 명된다. 도 7은 희소 비스트리밍 행렬을 프로세싱하는 예시적인 프로세스이다. 편의상, 프로세스는 하나 이상 의 위치에 위치한 하나 이상의 컴퓨터 시스템에 의해 수행되는 것으로 설명된다. 예를 들어, 도 1의 아키텍처 설계 시스템으로부터 생성된 하드웨어 아키텍처에 따라 제조되고, 적절하게 프로그래밍된, 하드웨어 구성 요소는 프로세스를 수행할 수 있다. 비스트리밍 행렬이 미리 결정되어 온-칩 메모리에 저장되기 때문에, 시스템은 행렬의 희소성 레벨과 행렬의 제 로 요소들을 결정할 수 있다. 희소성 레벨은 10%, 20%, 50% 또는 다른 적절한 희소성 레벨일 수 있다. 일부 구현예에서, 희소성 레벨은 1×N 벡터의 블록에서 K개의 제로가 아닌 요소들로서 정의된 블록 희소성 비율 일 수 있다. 비스트리밍 행렬의 블록 희소성 비율은 얼굴 검출, 시선 검출, 깊이 맵 생성 등 각각의 태스크에 맞게 조정될 수 있다. 희소성 레벨은 미리 결정될 수 있으므로, 본 명세서에 설명된 하드웨어 구성요소 또는 시 스템은 희소 행렬을 오프라인으로 미리 프로세싱하고 압축할 수 있다. 또한, 설명된 기술은 또한 결정된 희소성 레벨 및 스트리밍 입력 데이터의 특성들에 기초하여 입력 벡터를 분할 하기 위한 분할 크기(차원 크기 D)를 결정할 수 있다. 차원 크기 D를 결정한 후, 시스템은 D 요소의 조밀도 (granularity)로 비스트리밍 행렬에 액세스하고 비스트리밍 행렬의 각 부분 열 또는 행에 대해 제로가 아닌 요 소들을 인코딩할 수 있다. 이러한 방식으로 설명된 기술은, 예를 들어 압축 희소 행(CSR) 포맷 또는 압축 희소 열(CSC) 포맷과 같은 기존 압축 포맷을 사용하는 것보다 하드웨어 유닛 어레이의 활용도를 최대화하고 메타데이 터 저장 오버헤드 및 하드웨어 인덱스 디코딩의 복잡성을 줄일 수 있다. 도 7에 도시된 바와 같이, 예시적인 비스트리밍 행렬(예를 들어, 행렬 데이터)은 음영 영역에 묘사된 제로 가 아닌 요소들과 흰색 영역에 묘사된 제로 요소들을 포함한다. 예를 들어, 벡터 데이터(735a-d) 각 각은 4개의 요소들을 포함한다. 벡터 데이터(735a)의 제1 및 제3 요소는 제로가 아니고, 벡터 데이터(735a)의 제2 및 제4 요소는 제로이다. 벡터 데이터(735b)의 제1 및 제4 요소는 제로가 아니고, 벡터 데이터(735b)의 제2 및 제3 요소는 제로이다. 벡터 데이터(735c)의 제2 및 제3 요소는 제로가 아니고, 벡터 데이터(735c)의 제1 및 제4 요소는 제로이다. 시스템은 각 벡터 데이터(735a-d)를 프로세싱하여 각각의 압축(compressed) 데이터(750a-d)를 생성할 수 있으며, 여기서 각 압축 데이터는 원본 벡터 데이터(735a-d)에 대한 상대적인 위치(relative location)를 나타 내는 식별자들을 갖는 제로가 아닌 요소들만 포함한다. 식별자들은 인덱스 매핑 또는 비트맵에 기초 하여 생성될 수 있다. PE에서 부분 세그먼트를 수신한 후, 시스템은 부분 세그먼트를 프로세싱하기 위해 식별자 들을 사용하여 부분 세그먼트에서 값을 선택할 수 있다. 부분 세그먼트로부터 선택된 값들은 대응하는 압축 데 이터(750a-d)의 제로가 아닌 요소들에 대응한다. 예를 들어, 벡터 데이터(735a)에 기초하여 생성된 압축 데이터는 제로가 아닌 데이터, 즉 제1 및 제3 요소 와 제1 및 제3 요소와 연관된 식별자들만을 포함할 수 있다. 식별자들은 압축 데이터의 제1 요 소가 벡터 데이터(735a)의 제1 위치에 대응되고, 압축 데이터(750a)의 제2 요소가 벡터 데이터(735a)의 제3 위 치에 대응됨을 나타내도록 구성된다. 벡터 데이터(735a)를 대응하는 입력 부분 세그먼트로 프로세싱할 때, 시스 템은 입력 부분 세그먼트의 제1 및 제3 위치에 위치한 부분 세그먼트에서만 값을 선택할 수 있고 압축 데이터 (750a)의 대응하는 제로가 아닌 요소들을 사용하여 선택된 값의 요소별 연산을 수행할 수 있다. 또한, 설명된 기술은 조밀 계산(dense computation) 및 희소 계산(sparse computation)을 모두 지원할 수 있다. 보다 구체적으로, 설명된 기술은 하드웨어 구성요소가 스트리밍 입력 데이터를 프로세싱하기 위한 동작을 수행할 때 하드웨어 구성요소에 저장된 입력 행렬의 변경을 결정하는 것에 응답하여, 하드웨어 구성요소가 스트 리밍 입력 데이터를 조밀 모드와 희소 모드 사이에서 프로세싱하도록 모드를 스위칭할 수 있다. 예를 들어, 제조된 하드웨어 구성요소에는 새로운 비스트리밍 행렬이 희소 행렬 모드에 대한 임계 희소성 값을 충족한다고 결 정하는 것에 응답하여, 조밀 행렬 모드에서 희소 행렬 모드로 새로운 비스트리밍 데이터를 갖는 스트리밍 입력 데이터를 프로세싱하기 위해 하드웨어 구성요소를 스위칭하는 데 사용되는 제어 및 상태 레지스터(CSR)를 포함 할 수 있다. 식별자들은 희소 행렬 모드에만 사용된다. 도 8은 하드웨어 아키텍처 템플릿을 사용하여 출력 데이터를 생성하는 예시적인 프로세스의 흐름도이다. 편의상, 프로세스는 하나 이상의 위치에 위치한 하나 이상의 컴퓨터 시스템에 의해 수행되는 것으로 설명 된다. 예를 들어, 도 1의 아키텍처 설계 시스템은, 적절하게 프로그래밍되어, 프로세스를 수행할 수 있다. 시스템은 하드웨어 아키텍처 템플릿을 나타내는 데이터를 수신한다. 전술한 바와 같이, 하드웨어 아키텍처 템플릿은 구성가능한 설계 파라미터들의 세트를 포함하고 결정된 설계 파라미터 값들에 기초하여 하드웨어 아키 텍처를 인스턴스화하도록 구성된다. 하드웨어 아키텍처는 특정 스트리밍 입력 데이터를 프로세싱하도록 구성된 하드웨어 구성요소를 제조하는 데 사용될 수 있다. 설계 파라미터들의 세트는 (i) 하드웨어 아키텍처 내의 클러 스터들의 수, (ii) 각 클러스터 내의 프로세싱 유닛들의 수, (iii) 각 프로세싱 유닛 내의 하드웨어 유닛 어레 이 크기 중 둘 이상을 포함한다. 시스템은 하드웨어 구성요소를 제조하기 위한 하드웨어 아키텍처에 대해 구성가능한 설계 파라미터들의 세트에 대한 값들을 결정한다. 값들을 결정하는 것은 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데 이터의 특성들에 적어도 부분적으로 기초한다. 결정 프로세스의 세부사항은 단계 840-870과 관련하여 설명된다. 시스템은 값들을 포함하는 출력 데이터를 생성한다. 일부 구현예에서, 출력 데이터는 하드웨어 템플릿에 대해 결정된 값들로 구성가능한 설계 파라미터들의 세트를 설정함으로써 생성된 인스턴스화된 하드웨어 아키텍 처를 포함할 수 있다. 대안적으로, 출력 데이터는 획득된 설계 파라미터 값들과 템플릿으로부터의 값들에 기초 하여 생성된 대응하는 하드웨어 아키텍처를 모두 포함할 수 있다. 시스템은 하드웨어 아키텍처에 기초하여 하드 웨어 구성요소를 제조하기 위한 출력 데이터를 추가로 제공할 수 있다. 구성가능한 설계 파라미터들의 세트에 대한 값들을 생성하기 위해, 시스템은 먼저 구성가능한 설계 파라미터들 의 세트에 대한 검색 공간에 기초하여 다수의 후보 하드웨어 아키텍처들을 생성한다. 위에서 설명한 바와 같이, 검색 공간은 구성가능한 설계 파라미터들의 세트에 기초하며 이용가능한 계산 리소스, 전력 소비 및 온- 칩 영역 사용량에 기초하여 가능한 파라미터 값들로 제한된다. 시스템은 하나 이상의 가능한 설계 파라미터 값 들의 세트 중에서 각각의 설계 파라미터 값들의 세트를 사용하여 다수의 후보 하드웨어 아키텍처들을 생성할 수 있다. 하나 이상의 가능한 설계 파라미터 값들의 세트는 하나 이상의 서로 다른 검색 알고리즘을 사용하여 결정될 수 있다. 예를 들어, 시스템은 랜덤 검색, 완전(exhaustive) 검색, 유전(genetic) 검색 알고리즘을 수행할 수 있다. 설계 파라미터들의 세트에 대한 한 가지 예시적인 범위는 하드웨어 구성요소를 제조하기 위한 5개의 클러스터, 20개의 PE 및 100개의 MAC 유닛 어레이일 수 있다. 즉, 후보 하드웨어 구성요소는 1에서 5까지의 클러스터 수를 가질 수 있고, 각 클러스터는 1에서 20까지의 PE 수를 가질 수 있으며, 각 PE는 각각 해당 크기를 갖는 1-100개 의 MAC 유닛 어레이를 가질 수 있다. 시스템은 위에서 언급한 검색 알고리즘을 사용하여 다수의 후보 하드웨어 아키텍처들을 생성하여 예시 범위에서 다수의 가능한 값들을 검색하고 각 세트를 적용하여 템플릿을 사용하여 각 하드웨어 구성요소를 인스턴스화할 수 있다. 예를 들어, 시스템은 설계 파라미터들의 세트에 대해 가장 작은 값으로 시작하여 하나 이상의 설계 파라미터에 대한 값들을 점차적으로 증가시킬 수 있다. 처리량 요구사항에 적합한 설계 파라미터 값 세트를 획득하면 시스템은 검색을 중지할 수 있다. 일부 구현예에서, 시스템은 하드웨어 유닛 어레이의 크기, PE의 하드웨어 유닛 어레이의 수, 클러스터의 PE의 수와 연관된 파라미터 값을 검색할 수 있지만, 하드웨어 유닛 어레이의 크기 또는 클러스터당 PE의 수를 추가로 증가시키면 계산 클럭 속도에 부정적인 영향을 미치거나 논리 혼잡(logic congestion)을 유발할 수 있는 전환점 (turning point)을 결정할 때까지, 즉 하드웨어 유닛 어레이의 크기와 클러스터당 프로세싱 유닛의 수가 클러스 터의 확장성 한계에 도달할 때까지, 클러스터 수를 검색하거나 증가시키지 않는다. 이러한 방식으로 시스템은 더 많은 하드웨어 유닛과 PE를 배열하고 하드웨어 아키텍처를 인스턴스화하기 위한 클러스터 수를 최소화하여 필요한 처리량을 충족할 수 있다. 시스템은 다수의 후보 하드웨어 아키텍처들 각각에 대해, 성능 측정치들의 세트에 대한 각각의 값을 결정 한다. 성능 값 세트에 대한 각각의 값은 성능 모델(또는 비용 모델)을 사용하여 각 후보 하드웨어 아키텍처에 대해 결정된다. 성능 값은 각각 비용 또는 다수의 비용의 조합을 나타내는 숫자 값과 연관된다. 비용은 레이턴 시, 처리량, 전력 소비, 온-칩 영역 사용량, 계산 리소스 사용량 또는 이들의 적절한 조합 레벨을 나타낼 수 있 다. 성능 모델은 설계 파라미터 값들의 세트를 사용하여 하드웨어 아키텍처를 프로세싱하기 위한 임의의 적합한 모 델일 수 있다. 성능 모델은 분석 모델, 기계 학습 기반 모델, 하드웨어 시뮬레이션 모델 등이 될 수 있다. 분석 모델은 일반적으로 하드웨어 아키텍처의 토폴로지, 예를 들어 인터페이스, 배선(wiring), 승산기 (multiplier), 덧셈기(adder) 및 논리 유닛과 같은 컴퓨팅 유닛의 수를 결정하고 토폴로지에 기초하여 하드웨어 아키텍처에 대한 성능 값을 결정할 수 있다. 분석 모델의 한 예는 기계 최고 성능, 기계 최고 대역폭 및 산술 강도의 함수로 하드웨어 아키텍처에 대한 성능 값을 생성하는 루프라인(roofline) 기반 모델일 수 있다. 루프라 인 기반 모델의 출력은 특정 계산 요구 사항이나 리소스 제한 하에서 하드웨어 아키텍처의 성능 상한(예: \"실링 (ceiling)\")을 나타내는 함수 곡선일 수 있다. 루프라인 기반 모델은 위에서 설명한 대로 레이턴시, 처리량 또 는 전력 소비 레벨을 나타내는 전체 성능 및 출력 성능 값에 대한 \"병목현상(bottleneck)\" 요인을 자동으로 결 정할 수 있다. 대안적으로, 성능 모델은 레이블이 지정된 트레이닝 샘플로 트레이닝된 기계 학습 모델(예: 지도 학습)일 수 있 다. 트레이닝 샘플은 하이-레벨 합성 및 레지스터-전송 레벨 시뮬레이션을 사용하여 생성될 수 있다. 트레이닝 된 기계 학습 모델은 성능 값의 예측을 생성하도록 구성되며 임의의 적합한 기계 학습 모델(예: 다층 퍼셉트론 모델)일 수 있다. 또한, 성능 모델은 시뮬레이션 모델일 수 있다. 시뮬레이션 모델은 하나 이상의 랜덤 입력 자극(stimuli)이 주 어진 하드웨어 아키텍처의 특성에 기초하여 전력 계산 및 처리량의 추정치를 생성할 수 있다. 시스템은 하드웨어 구성요소에 대한 하드웨어 아키텍처로서의 후보 하드웨어 아키텍처를 선택한다. 보다 구체적으로, 시스템은 성능 값에 적어도 부분적으로 기초하여 향상된 하드웨어 아키텍처를 선택할 수 있다. 전 술한 바와 같이, 하드웨어 아키텍처는 가장 높은 성능 값을 갖는 후보 하드웨어 아키텍처가 될 수 있다. 또는 하드웨어 아키텍처는 적절한 성능 값을 가질 수 있지만 최소한의 계산 리소스가 필요하다. 시스템은 선택된 후보 하드웨어 아키텍처와 연관된 설계 파라미터 값들에 기초하여 값들을 결정한다. 결정 된 값들은 템플릿을 사용하여 하드웨어 아키텍처를 인스턴스화하기 위해 제공되는 출력 데이터에 포함될 수도 있고 하드웨어 구성요소를 제조하는 데 사용될 수도 있다. 본 명세서에 설명된 주제 및 기능적 동작의 실시예는 본 명세서에 개시된 구조 및 그 구조적 등가물을 포함하는 디지털 전자 회로, 유형적으로 구현된 컴퓨터 소프트웨어 또는 펌웨어, 컴퓨터 하드웨어, 또는 이들 중 하나 이 상의 조합으로 구현될 수 있다. 본 명세서에 설명된 주제의 실시예는 하나 이상의 컴퓨터 프로그램, 예를 들어 데이터 프로세싱 장치에 의해 실행되거나 데이터 프로세싱 장치의 동작을 제어하기 위해 유형의 비일시적 저장 매체에 인코딩된 컴퓨터 프로그램 명령의 하나 이상의 모듈로 구현될 수 있다. 컴퓨터 저장 매체는 기계 판독가 능 저장 장치, 기계 판독가능 저장 기판, 랜덤 또는 직렬 액세스 메모리 디바이스, 또는 이들 중 하나 이상의 조합일 수 있다. 대안적으로 또는 추가로, 프로그램 명령은 데이터 프로세싱 장치에 의한 실행을 위해 적합한 수신기 장치로 전송하기 위해 정보를 인코딩하도록 생성된 인공적으로 생성된 전파 신호, 예를 들어 기계 생성 전기, 광학 또는 전자기 신호에 인코딩될 수 있다. \"데이터 프로세싱 장치\"라는 용어는 데이터 프로세싱 하드웨어를 의미하며, 예를 들어 프로그래밍 가능한 프로 세서, 컴퓨터, 또는 다중 프로세서 또는 컴퓨터를 포함하여 데이터를 프로세싱하기 위한 모든 종류의 장치, 디 바이스 및 기계를 포함한다. 장치는 또한 특수 목적의 논리 회로, 예를 들어 FPGA(필드 프로그래밍 가능 게이트 어레이) 또는 ASIC(애플리케이션-특정 집적 회로)일 수 있거나 이를 더 포함할 수 있다. 장치는 하드웨어에 추 가하여, 컴퓨터 프로그램에 대한 실행 환경을 생성하는 코드, 예를 들어 프로세서 펌웨어, 프로토콜 스택, 데이 터베이스 관리 시스템, 운영 체제, 또는 이들 중 하나 이상의 조합을 구성하는 코드를 선택적으로 포함할 수 있 다. 프로그램, 소프트웨어, 소프트웨어 애플리케이션, 앱, 모듈, 소프트웨어 모듈, 스크립트 또는 코드라고도 지칭 되거나 설명될 수 있는 컴퓨터 프로그램은 컴파일되거나 또는 해석된 언어, 또는 선언적 또는 절차적 언어를 포 함한 모든 형태의 프로그래밍 언어로 작성될 수 있으며, 독립 실행형 프로그램, 모듈, 구성 요소, 서브루틴 또 는 컴퓨팅 환경에서 사용하기에 적합한 기타 장치를 포함하여 모든 형태로 배포될 수 있다. 프로그램은 파일 시스템의 파일에 대응할 수 있지만 반드시 그럴 필요는 없다. 프로그램은 마크업 언어 문서에 저장된 하나 이상의 스크립트와 같은 다른 프로그램 또는 데이터를 보유하는 파일의 일부, 해당 프로그램 전용 단일 파일 또는 하나 이상의 모듈, 하위 프로그램 또는 코드의 일부를 저장하는 파일과 같은 다수의 조정된 파일에 저장될 수 있다. 컴퓨터 프로그램은 하나의 컴퓨터 또는 한 사이트에 위치하거나 다수의 사이트에 걸쳐 분산되고 데이터 통신 네 트워크로 상호 연결된 다수의 컴퓨터에서 실행되도록 배포될 수 있다. 특정 동작이나 액션을 수행하도록 구성되는 하나 이상의 컴퓨터로 구성된 시스템의 경우, 시스템이 동작 중에 시스템으로 하여금 동작이나 액션을 수행하게 하는 소프트웨어, 펌웨어, 하드웨어 또는 이들의 조합이 시스템에 설치되어 있음을 의미한다. 하나 이상의 컴퓨터 프로그램이 특정 동작 또는 액션을 수행하도록 구성된다는 것은 하나 이상의 프로그램이 데이터 프로세싱 장치에 의해 실행될 때 장치로 하여금 동작 또는 액션을 수행하게 하 는 명령을 포함한다는 것을 의미한다. 본 명세서에 사용된 바와 같이, \"엔진\" 또는 \"소프트웨어 엔진\"은 입력과 다른 출력을 제공하는 소프트웨어 구 현 입력/출력 시스템을 의미한다. 엔진은 라이브러리, 플랫폼, 소프트웨어 개발 키트(\"SDK\") 또는 객체와 같은 인코딩된 기능 블록일 수 있다. 각 엔진은 하나 이상의 프로세서 및 컴퓨터 판독가능 매체를 포함하는, 서버, 휴대폰, 태블릿 컴퓨터, 노트북 컴퓨터, 뮤직 플레이어, 전자책 리더기, 노트북 또는 데스크탑 컴퓨터, PDA, 스 마트폰 또는 기타 고정식 또는 휴대용 디바이스와 같은 적절한 유형의 컴퓨팅 디바이스에서 구현될 수 있다. 추 가적으로, 둘 이상의 엔진은 동일한 컴퓨팅 디바이스 또는 상이한 컴퓨팅 디바이스에 구현될 수 있다. 본 명세서에 설명된 프로세스 및 논리 흐름은 입력 데이터에 대해 동작하고 출력을 생성함으로써 기능을 수행하 는 하나 이상의 컴퓨터 프로그램을 실행하는 하나 이상의 프로그래밍 가능한 컴퓨터에 의해 수행될 수 있다. 프 로세스 및 논리 흐름은 FPGA 또는 ASIC과 같은 특수 목적 논리 회로에 의해 수행되거나 특수 목적 논리 회로와 하나 이상의 프로그래밍된 컴퓨터의 조합에 의해 수행될 수도 있다. 컴퓨터 프로그램의 실행에 적합한 컴퓨터는 범용 또는 특수 목적의 마이크로프로세서 또는 둘 다 또는 임의의 다른 종류의 중앙 프로세싱 유닛에 기초할 수 있다. 일반적으로 중앙 프로세싱 유닛은 읽기 전용 메모리나 랜덤 액세스 메모리 또는 둘 다로부터 명령과 데이터를 수신한다. 컴퓨터의 필수 요소는 명령을 수행하거나 실행하는 중앙 프로세싱 유닛과 명령 및 데이터를 저장하는 하나 이상의 메모리 디바이스이다. 중앙 프로세싱 유닛과 메 모리는 특수 목적 논리 회로에 의해 보완되거나 통합될 수 있다. 일반적으로, 컴퓨터는 또한 데이터를 저장하기 위한 하나 이상의 대용량 저장 디바이스, 예를 들어 자기, 광자기 디스크 또는 광 디스크로부터 데이터를 수신 하거나 전송하거나 둘 모두를 포함하거나 동작 가능하게 결합될 것이다. 그러나 컴퓨터에 그러한 장치가 있을 필요는 없다. 또한, 컴퓨터는 다른 장치, 예를 들어 휴대폰, PDA(Personal Digital Assistant), 모바일 오디오 또는 비디오 플레이어, 게임 콘솔, GPS(Global Positioning System) 수신기 또는 USB(Universal Serial Bus) 플래시 드라이브와 같은 휴대용 저장 디바이스에 내장될 수 있다. 컴퓨터 프로그램 명령 및 데이터를 저장하기에 적합한 컴퓨터 판독가능 매체는 예를 들어, 반도체 메모리 디바 이스, 예를 들어, EPROM, EEPROM 및 플래시 메모리 디바이스; 자기 디스크, 예를 들어, 내부 하드 디스크 또는 착탈식 디스크; 광자기 디스크; 및 CD-ROM 및 DVD-ROM 디스크를 포함하는 모든 형태의 비휘발성 메모리, 매체 및 메모리 디바이스를 포함한다. 사용자와의 상호 작용을 제공하기 위해, 본 명세서에 설명된 주제의 실시예는 사용자에게 정보를 디스플레이하 기 위한 CRT(음극선관) 또는 LCD(액정 디스플레이) 모니터와 같은 디스플레이 디바이스, 마우스, 트랙볼, 존재 감지 디스플레이 또는 사용자가 컴퓨터에 입력을 제공할 수 있는 기타 표면과 같은 키보드 및 포인팅 디바이스 를 갖춘 컴퓨터에서 구현될 수 있다. 사용자와의 상호작용을 제공하기 위해 다른 종류의 디바이스도 사용될 수 있으며; 예를 들어, 사용자에게 제공되는 피드백은 시각적 피드백, 청각적 피드백 또는 촉각적 피드백과 같은 임의의 형태의 감각 피드백일 수 있고; 사용자의 입력은 음향, 음성 또는 촉각 입력을 포함한 모든 형태로 수신 될 수 있다. 또한, 컴퓨터는 사용자가 사용하는 디바이스와 문서를 주고받는 방식으로 사용자와 상호 작용할 수 있으며; 예를 들어, 웹 브라우저에서 받은 요청에 대한 응답으로 사용자 디바이스의 웹 브라우저로 웹 페이지를 보낸다. 또한, 컴퓨터는 문자 메시지 또는 다른 형태의 메시지를 스마트폰과 같은 개인 디바이스에 보내고, 메 시징 애플리케이션을 실행하고, 그 대가로 사용자로부터 응답 메시지를 받음으로써 사용자와 상호 작용할 수 있 다. 본 명세서에 설명된 주제의 실시예는 데이터 서버와 같은 백엔드 구성요소를 포함하거나, 애플리케이션 서버와 같은 미들웨어 구성요소를 포함하거나, 사용자가 본 명세서에 설명된 주제의 구현과 상호 작용할 수 있는 그래 픽 사용자 인터페이스, 웹 브라우저 또는 앱을 갖춘 클라이언트 컴퓨터와 같은 프런트엔드 구성요소를 포함하거나, 또는 백엔드, 미들웨어 또는 프런트엔드 구성요소 중 하나 이상의 조합을 포함하는 컴퓨팅 시스템에서 구현 될 수 있다. 시스템의 구성요소는 통신 네트워크와 같은 디지털 데이터 통신의 모든 형태나 매체를 통해 상호 연결될 수 있다. 통신 네트워크의 예로는 LAN(Local Area Network) 및 WAN(Wide Area Network), 예를 들어 인 터넷이 포함된다. 컴퓨팅 시스템은 클라이언트와 서버를 포함할 수 있다. 클라이언트와 서버는 일반적으로 서로 멀리 떨어져 있으 며 일반적으로 통신 네트워크를 통해 상호작용한다. 클라이언트와 서버의 관계는 각 컴퓨터에서 실행되고 서로 클라이언트-서버 관계를 갖는 컴퓨터 프로그램으로 인해 발생한다. 일부 실시예에서, 서버는 예를 들어 클라이 언트 역할을 하는 디바이스와 상호작용하는 사용자에게 데이터를 디스플레이하고 사용자 입력을 수신할 목적으 로 HTML 페이지와 같은 데이터를 사용자 디바이스에 전송한다. 사용자 디바이스에서 생성된 데이터, 예를 들어 사용자 상호작용의 결과는 디바이스로부터 서버에 수신될 수 있다. 위에 설명된 실시예 외에도, 다음 실시예 또한 혁신적이다. 실시예 1은 각각의 스트리밍 입력 데이터에 대한 동작들을 수행하도록 구성된 하드웨어 구성요소들에 대한 하드 웨어 아키텍처들을 생성하기 위한 하드웨어 아키텍처 템플릿을 나타내는 데이터를 수신하는 단계, 여기서 하드 웨어 아키텍처 템플릿은 (i) 하드웨어 아키텍처 내의 클러스터들의 수, (ii) 각 클러스터 내의 프로세싱 유닛들 의 수, 및 (iii) 각 프로세싱 유닛 내의 하드웨어 유닛 어레이의 크기 중 둘 이상을 포함하는 구성가능한 설계 파라미터들의 세트를 포함하고; 주어진 하드웨어 구성요소에 대한 주어진 하드웨어 아키텍처에 대해, 주어진 하 드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터의 특성들에 적어도 부분적으로 기초하여 구성가능한 설계 파라미터들의 세트에 대한 값들을 결정하는 단계, 여기서 결정하는 단계는: 구성가능한 설계 파라미터들의 세트 에 대한 검색 공간에 기초하여, 상기 하드웨어 아키텍처 템플릿을 사용하여 주어진 하드웨어 구성요소에 대한 복수의 후보 하드웨어 아키텍처들을 생성하는 단계, 여기서 각 후보 하드웨어 아키텍처는 구성가능한 설계 파라 미터들의 세트에 대한 각각의 설계 파라미터 값들을 포함하고; 복수의 후보 하드웨어 아키텍처들 각각에 대해, 성능 모델 및 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터의 특성들에 기초하여 상기 후보 하드웨어 아키텍처와 연관된 성능 측정치들의 세트에 대한 각각의 값들을 결정하는 단계; 주어진 하드웨어 아키 텍처로서, 성능 측정치들의 세트에 대한 각각의 값들에 적어도 부분적으로 기초하여 상기 복수의 후보 하드웨어 아키텍처들로부터 후보 하드웨어 아키텍처를 선택하는 단계; 및 주어진 하드웨어 아키텍처의 구성가능한 설계 파라미터들의 세트에 대한 값으로서, 상기 선택된 후보 하드웨어 아키텍처와 연관된 설계 파라미터 값들을 결정 하는 단계를 포함하고; 및 주어진 하드웨어 아키텍처의 설계 파라미터들의 세트에 대한 값들을 나타내는 출력 데이터를 생성하는 단계를 포함한다. 실시예 2는 실시예 1의 방법으로서, 하드웨어 아키텍처 템플릿에 출력 데이터를 제공하는 단계; 주어진 하드웨 어 아키텍처의 설계 파라미터들의 세트에 대한 값들에 기초하여 주어진 하드웨어 아키텍처를 인스턴스화하는 단 계; 및 주어진 하드웨어 아키텍처에 기초하여 주어진 하드웨어 구성요소를 제조하는 단계를 더 포함한다. 실시예 3은 실시예 1 또는 2의 방법으로서, 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터의 특성들은 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터의 각 프레임의 도달 레이트 및 각 프 레임의 크기를 포함한다. 실시예 4는 실시예 1 내지 3 중 어느 하나의 방법으로서, 성능 측정치들의 세트는 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터를 프로세싱하기 위한 레이턴시, 전력 소비, 리소스 사용량, 또는 처리량 중 적어도 하나의 측정치들을 포함하고, 성능 모델은 분석 비용 모델, 기계 학습 비용 모델, 또는 하드웨어 시뮬레 이션 모델 중 적어도 하나를 포함한다. 실시예 5는 실시예 1 내지 4 중 어느 하나의 방법으로서, 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입 력 데이터는 시간 순서에 따라 이미지 센서에 의해 수집된 스트리밍 이미지 프레임들을 포함한다. 실시예 6은 실시예 5의 방법으로서, 스트리밍 이미지 프레임들의 특성들은 이미지 프레임들에 대한 특정 도달 레이트 및 이미지 프레임들 각각에 대한 각각의 이미지 해상도 중 적어도 하나를 포함한다. 실시예 7은 실시예 5의 방법으로서, 스트리밍 이미지 프레임들의 특성들은 수직 블랭킹 기간(blanking period) 또는 수평 블랭킹 기간 중 적어도 하나를 포함하는 블랭킹 기간을 포함한다. 실시예 8은 실시예 5의 방법으로서, 스트리밍 이미지 프레임들의 특성들은 픽셀 포맷을 포함하고, 상기 픽셀 포 맷은 RGB 또는 YUV 컬러 포맷을 포함한다.실시예 9는 실시예 1 내지 8 중 어느 하나의 방법으로서, 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입 력 데이터는 오디오 센서에 의해 수집된 스트리밍 오디오를 포함한다. 실시예 10은 실시예 9의 방법으로서, 스트리밍 이미지 프레임들의 특성들은 스트리밍 오디오에 대한 특정 샘플 레이트, 스트리밍 오디오의 비트 깊이, 스트리밍 오디오의 비트 레이트, 또는 스트리밍 오디오의 오디오 포맷 중 적어도 하나를 포함한다. 실시예 11은 실시예 1 내지 10 중 어느 하나의 방법으로서, 주어진 하드웨어 구성요소를 사용하여 각각의 스트 리밍 입력 데이터에 대한 동작들을 수행하는 것은: 스트리밍 입력 데이터의 각 프레임에 대해: 프레임의 입력 벡터를 상기 입력 벡터의 중첩되지 않는 값들을 각각 포함하는 복수의 부분 벡터들로 분할하는 단계; 및 복수의 부분 벡터들 중 각 부분 벡터에 대해, 각각이 각각의 프로세싱 유닛들의 수를 갖고 각 프로세싱 유닛이 주어진 하드웨어 아키텍처의 설계 파라미터들 세트에 대한 값들에 대응하는 각각의 크기의 하드웨어 유닛 어레이를 갖 는 복수의 클러스터들 중 각각의 클러스터에 부분 벡터를 할당하는 단계; 각각의 클러스터에 의해, 각각의 부분 합을 생성하기 위해 부분 벡터의 각 값을 메모리에 저장된 행렬의 부분 행의 대응하는 값과 곱하는 단계; 및 각 각의 부분 합을 어큐뮬레이터 어레이에 저장하는 단계를 포함한다. 실시예 12은 실시예 11의 방법으로서, 주어진 하드웨어 구성요소를 사용하여 주어진 하드웨어 구성요소에 대한 각각의 스트리밍 입력 데이터에 대한 동작들을 수행하는 것은 메모리에 저장된 행렬의 희소성(sparsity) 레벨에 기초하여 동작들을 수행하는 것을 포함한다. 실시예 13은 실시예 1 내지 12 중 어느 하나의 방법으로서, 동작들을 수행하는 것은 조밀 행렬 모드와 희소 행 렬 모드 사이에서 스위칭되고, 스위칭 프로세스는 제어 및 상태(CSR) 레지스터에 의해 제어된다. 실시예 14는 실시예 11의 방법으로서, 메모리에 저장된 행렬의 부분 행의 대응하는 값들을 생성하는 단계는 희 소 행렬 모드에서 수행되고, 상기 생성하는 단계는: 메모리에 저장된 행렬의 부분 행에서 제로가 아닌 값들을 결정하는 단계; 행렬의 부분 행의 제로가 아닌 값들의 포지션들을 나타내는 식별자들을 생성하는 단계, 상기 식 별자들은 인덱스들 또는 비트맵들을 포함하고; 및 대응하는 식별자들과 연관된 제로가 아닌 값들의 압축 벡터를 행렬의 부분 행의 대응하는 값들로서 생성하는 단계를 더 포함한다. 실시예 15는 실시예 14의 방법으로서, 대응하는 식별자들에 기초하여 압축 벡터에 대응하는 부분 벡터의 값들을 선택하는 단계; 및 부분 벡터의 선택된 값들 각각을 압축 벡터의 대응하는 제로가 아닌 값과 곱하는 단계를 더 포함한다. 실시예 16은 실시예 1 내지 15 중 어느 하나의 방법으로서, 주어진 하드웨어 아키텍처는 메모리에 저장된 하나 이상의 행렬들에 대한 상한(upper-bound) 희소성 레벨을 나타내는 데이터를 포함하고, 주어진 하드웨어 아키텍 처는 하나 이상의 행렬들 중 제1 행렬과 상이한 희소성 레벨을 갖는 하나 이상의 행렬들 중 제2 행렬로 스트리 밍 입력 데이터를 프로세싱하기 위해 동적으로 다시 인스턴스화되도록 구성된다. 실시예 17은 실시예 1 내지 16 중 어느 하나의 방법으로서, 구성가능한 설계 파라미터들의 세트에 대한 검색 공 간에 기초하여, 상기 하드웨어 아키텍처 템플릿을 사용하여 상기 복수의 후보 하드웨어 아키텍처들을 생성하는 단계는, 랜덤 검색 알고리즘, 완전 검색 알고리즘 또는 유전 알고리즘 중 적어도 하나를 사용하여 설계 파라미 터들의 세트에 대한 검색 공간을 탐색하는 단계를 포함한다. 실시예 18은 실시예 1 내지 17 중 어느 하나의 방법으로서, 구성가능한 설계 파라미터들의 세트에 대한 검색 공 간을 탐색하는 단계는: 각 프로세싱 유닛 내의 하드웨어 유닛 어레이의 크기 및 클러스터 내의 프로세싱 유닛들 의 수에 대응하는 설계 파라미터 값들을 탐색하는 단계; 하드웨어 유닛 어레이의 크기 및 클러스터 내의 프로세 싱 유닛들의 수에 대응하는 설계 파라미터 값들이 클러스터에 대한 확장성 한계(scalability limit)에 있다고 결정하는 단계; 및 이에 대응하여, 클러스터들의 수에 대응하는 설계 파라미터 값들을 탐색하는 단계를 포함한 다. 실시예 19는 하나 이상의 컴퓨터들 및 하나 이상의 컴퓨터들에 의해 실행될 때, 하나 이상의 컴퓨터들로 하여금 실시예 1 내지 18 중 어느 하나의 방법을 수행하게 하는 명령어들을 저장하는 하나 이상의 저장 디바이스를 포 함하는 시스템이다. 실시예 20은 컴퓨터 프로그램으로 인코딩된 컴퓨터 저장 매체이며, 프로그램은 데이터 프로세싱 장치에 의해 실 행될 때, 데이터 프로세싱 장치로 하여금 실시예 1 내지 18 중 어느 하나의 방법을 수행하게 하는 명령어들을 포함한다.본 명세서에는 많은 구체적인 구현 세부 사항이 포함되어 있지만, 이는 임의의 발명의 범위 또는 청구될 수 있 는 범위에 대한 제한으로 해석되어서는 안 되며, 오히려 특정 발명의 특정 실시예에 특정할 수 있는 특징에 대 한 설명으로 해석되어야 한다. 별도의 실시예와 관련하여 본 명세서에 설명된 특정 특징은 단일 실시예에서 조 합하여 구현될 수도 있다. 반대로, 단일 실시예의 맥락에서 설명된 다양한 특징은 다중 실시예에서 개별적으로 또는 임의의 적절한 하위 조합으로 구현될 수도 있다. 더욱이, 위에서는 기능이 특정 조합으로 작용하는 것으로 설명될 수 있고 심지어 처음에는 그렇게 주장되었을 수도 있지만, 청구된 조합의 하나 이상의 특징은 경우에 따 라 조합에서 삭제될 수 있으며, 청구된 조합은 하위 조합 또는 하위 조합의 변형과 관련될 수 있다. 마찬가지로, 동작들이 특정 순서로 도면에 표시되어 있지만, 이는 원하는 결과를 달성하기 위해 그러한 동작이 표시된 특정 순서 또는 순차적인 순서로 수행되거나 모든 예시된 동작이 수행되어야 한다고 요구하는 것으로 이 해되어서는 안 된다. 특정 상황에서는 멀티태스킹과 병렬 프로세싱이 유리할 수 있다. 더욱이, 전술한 실시예에 서 다양한 시스템 모듈 및 구성요소의 분리는 모든 실시예에서 그러한 분리를 요구하는 것으로 이해되어서는 안 되며, 기술된 프로그램 구성요소 및 시스템은 일반적으로 단일 소프트웨어 제품에 함께 통합되거나 여러 소프트 웨어 제품에 패키지될 수 있음을 이해해야 한다. 주제의 특정 실시예가 설명되었다. 다른 실시예는 다음 청구범위의 범위 내에 있다. 예를 들어, 청구범위에 인 용된 작업은 다른 순서로 수행될 수 있으며 여전히 원하는 결과를 얻을 수 있다. 하나의 예로서, 첨부 도면에 도시된 프로세스는 바람직한 결과를 달성하기 위해 도시된 특정 순서 또는 순차적 순서를 반드시 필요로 하는 것은 아니다. 어떤 경우에는 멀티태스킹과 병렬 프로세싱이 유리할 수 있다."}
{"patent_id": "10-2024-7010747", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 예시적인 아키텍처 설계 시스템을 도시한다. 도 2는 스트리밍 입력 데이터의 프레임을 프로세싱하기 위한 예시적인 시나리오를 도시한다. 도 3은 스트리밍 입력 데이터의 프레임을 프로세싱하기 위한 또 다른 예시적인 시나리오를 도시한다. 도 4는 스트리밍 입력 데이터의 프레임을 프로세싱하기 위한 또 다른 예시적인 시나리오를 도시한다. 도 5는 스트리밍 입력 데이터의 프레임을 프로세싱하기 위한 또 다른 예시적인 시나리오를 도시한다. 도 6은 비스트리밍(non-streaming) 행렬에 대한 예시적인 데이터 액세스 패턴을 도시한다. 도 7은 희소 비스트리밍 행렬을 프로세싱하는 예시적인 프로세스이다. 도 8은 하드웨어 아키텍처 템플릿을 사용하여 출력 데이터를 생성하는 예시적인 프로세스의 흐름도이다. 다양한 도면에서의 유사한 참조 번호 및 명칭은 유사한 요소를 나타낸다."}
