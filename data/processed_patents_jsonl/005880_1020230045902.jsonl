{"patent_id": "10-2023-0045902", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0150065", "출원번호": "10-2023-0045902", "발명의 명칭": "코어 매트릭스 구조에서 성능 하베스팅 방법 및 이를 수행하는 디바이스", "출원인": "주식회사 소테리아", "발명자": "김 제임스 종만"}}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "복수의 코어가 매트릭스 구조로 배열된 적어도 하나 이상의 코어그룹을 포함한 디바이스에서 상기 복수의 코어중 적어도 하나 이상에 대한 결함을 감지하는 베드코어 감지 단계; 및상기 복수의 코어 중에서 상기 결함을 감지한 적어도 하나 이상의 코어에 대한 동작을 바이패스하고, 나머지 코어들로 상기 디바이스의 성능을 발휘하도록 하는 성능 하베스팅 단계;를 포함하는 코어 매트릭스 구조에서 성능하베스팅 방법."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "청구항 1에 있어서,상기 베드코어 감지 단계는,BIST(Built-In Self Test), 열화(degradation) 테스트, 기능(functional) 테스트 또는 이들의 조합 중 적어도하나 이상을 포함하는 테스트를 수행하여 각 코어의 결함을 감지하는 것을 포함하는 코어 매트릭스 구조에서 성능 하베스팅 방법."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "청구항 2에 있어서,상기 베드코어 감지 단계는,상기 테스트를 실행하기 위한 테스트 스케줄러를 가동하는 테스트 스케줄링 단계;상기 테스트 스케줄러에 따라 테스트 패턴을 생성하는 테스트 패턴 생성 단계; 및상기 생성한 테스트 패턴을 상기 코어에 입력하고 그 응답을 미리 예상된 응답과 비교하여 감지하는 응답 모니터링 단계;를 포함하는 것을 특징으로 하는 코어 매트릭스 구조에서 성능 하베스팅 방법."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "청구항 3에 있어서,상기 응답 모니터링 단계는,상기 감지한 결함이 소정의 미리 정해진 결함률보다 낮으면 해당 코어는 결함이 없는 것으로 간주하고 상기 성능 하베스팅 단계에서 상기 소정의 태스크를 수행하도록 하거나,상기 감지한 결함이 존재하더라도 기능적으로 소정의 태스크를 올바르게 수행하는 것이 가능하다면 상기 성능하베스팅 단계에서 상기 소정의 태스크를 수행하도록 하는 것을 포함하는 것을 특징으로 하는 코어 매트릭스 구조에서 성능 하베스팅 방법."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "청구항 1에 있어서,상기 성능 하베스팅 단계는,상기 결함을 감지한 베드코어에 대해서 해당 코어에 할당된 태스크의 결과를 무시하고, 나머지 코어들이 독립적으로 할당된 태스크를 수행함으로써 성능을 발휘하도록 하는 것을 특징으로 하는 코어 매트릭스 구조에서 성능하베스팅 방법."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "공개특허 10-2024-0150065-3-청구항 1에 있어서,상기 성능 하베스팅 단계는,상기 결함을 감지한 베드코어에 수정된 클록(modified clock)을 제공함으로써, 해당 코어의 입력데이터가 출력데이터로 바이패스되도록 하며,상기 수정된 클록은, 정상상태에서 해당 코어에 제공하는 클록을 마스킹(masking)하거나, 리셋(reset)하거나,게이팅(gating)하거나 또는 이들의 조합을 수행하여 생성된 클록인 것을 특징으로 하는 코어 매트릭스 구조에서성능 하베스팅 방법."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "복수의 코어가 매트릭스 구조로 배열된 적어도 하나 이상의 코어그룹; 및상기 복수의 코어 중에서 결함이 발생한 적어도 하나 이상의 코어에 대한 동작을 바이패스하고, 나머지 코어들로 성능을 발휘하도록 하는 성능 하베스팅을 수행하도록 제어하는 컨트롤 로직부;를 포함하는 것을 특징으로 하는 코어 매트릭스 구조에서 성능 하베스팅을 수행하는 디바이스."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "청구항 7에 있어서,상기 컨트롤 로직부는,상기 복수의 코어 중 적어도 하나 이상에 대한 결함을 감지하는 테스트 매니저;상기 감지한 결함에 따라 상기 복수의 코어에 태스크의 할당을 관리하는 태스크 매니저; 및상기 감지한 결함을 기록하고 관리하는 베드코어 매니저;를 포함하는 것을 특징으로 하는 코어 매트릭스 구조에서 성능 하베스팅을 수행하는 디바이스."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "청구항 8에 있어서,상기 테스트 매니저는,BIST(Built-In Self Test), 열화(degradation) 테스트, 기능(functional) 테스트 또는 이들의 조합 중 적어도하나 이상을 포함하는 테스트를 수행하여 각 코어의 결함을 감지하는 것을 포함하는 것을 특징으로 하는 코어매트릭스 구조에서 성능 하베스팅을 수행하는 디바이스."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "청구항 8에 있어서,상기 테스트 매니저는,상기 테스트를 실행하기 위한 테스트 스케줄링을 수행하는 테스트 스케줄러;상기 테스트 스케줄러에 따라 테스트 패턴을 생성하는 테스트 패턴 생성부; 및상기 생성한 테스트 패턴을 상기 코어에 입력하고 그 응답을 미리 예상된 응답과 비교하여 감지하는 응답 모니터링부;를 포함하는 것을 특징으로 하는 코어 매트릭스 구조에서 성능 하베스팅을 수행하는 디바이스."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "청구항 10에 있어서,상기 응답 모니터링부는,상기 감지한 결함이 소정의 미리 정해진 결함률보다 낮으면 해당 코어는 결함이 없는 것으로 간주하고 상기 성능 하베스팅을 수행하도록 상기 소정의 태스크를 수행하도록 하거나,상기 감지한 결함이 존재하더라도 기능적으로 소정의 태스크를 올바르게 수행하는 것이 가능하다면 상기 성능공개특허 10-2024-0150065-4-하베스팅을 수행하도록 상기 소정의 태스크를 수행하도록 하는 것을 특징으로 하는 코어 매트릭스 구조에서 성능 하베스팅을 수행하는 디바이스."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "청구항 8에 있어서,상기 태스크 매니저는,상기 결함을 감지한 베드코어에 대해서 해당 코어에 할당된 태스크의 결과를 무시하고, 나머지 코어들이 독립적으로 할당된 태스크를 수행함으로써 성능을 발휘하도록 하는 것을 포함하는 것을 특징으로 하는 코어 매트릭스구조에서 성능 하베스팅을 수행하는 디바이스."}
{"patent_id": "10-2023-0045902", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "청구항 8에 있어서,상기 컨트롤 로직부는,상기 결함을 감지한 베드코어에 수정된 클록(modified clock)을 제공하는 클록 제어부;를 더 포함하며,상기 클록 제어부는,상기 결함을 감지한 베드코어에 수정된 클록(modified clock)을 제공함으로써, 해당 코어의 입력데이터가 출력데이터로 바이패스되도록 하며,상기 수정된 클록은, 정상상태에서 해당 코어에 제공하는 클록을 마스킹(masking)하거나, 리셋(reset)하거나,게이팅(gating)하거나 또는 이들의 조합을 수행하여 생성된 클록인 것을 특징으로 하는 코어 매트릭스 구조에서성능 하베스팅을 수행하는 디바이스."}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 코어 매트릭스 구조에서의 성능 하베스팅 방법 및 이를 수행하는 디바이스에 관한 것으로, 복수의 코 어를 매트릭스 형태로 내장하고 있으면서 상기 복수의 코어가 서로 독립적으로 연산을 수행하도록 구성함에 있어 서, 복수의 각 코어들에 대한 동작을 테스트하여 결함(fail)이 있는 코어를 바이패스하여 연산에서 제외할 수 있 도록 구성함으로써, 일부 코어가 동작하지 않더라도 정상적으로 동작하는 나머지 코어들이 각각 성능을 발휘하여 독립적으로 연산의 결과를 출력하도록 하는 방법과 이를 수행하는 디바이스에 관한 것이다."}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 코어 매트릭스 구조에서의 성능 하베스팅 방법 및 이를 수행하는 디바이스에 관한 것으로, 더욱 상세 하게는 복수의 코어를 매트릭스 형태로 내장하고 있으면서 상기 복수의 코어가 서로 독립적으로 연산을 수행하 도록 구성함에 있어서, 복수의 각 코어들에 대한 동작을 테스트하여 결함(fail)이 있는 코어를 바이패스하여 연 산에서 제외할 수 있도록 구성함으로써, 일부 코어가 동작하지 않더라도 정상적으로 동작하는 나머지 코어들이 각각 성능을 발휘하여 독립적으로 연산의 결과를 출력하도록 하는 방법과 이를 수행하는 디바이스에 관한 것이다."}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "가상화폐, 디지털 서명, 인터넷 뱅킹 등 대규모의 연산을 수행하여 해싱하거나 암호화하는 분야의 수요가 점점 확대되고 있다. 인공지능 학습엔진 및 해시함수나 암호화를 위해서는 매우 방대한 량의 고속연산을 필요로 한다. 방대한 량의 연산이나 태스크를 고속 처리하는 시스템은 핵심 연산(core operation)(또는 태스크)(or task)을 수행하는 코어를 매트릭스 형태로 배열하여 대규모의 연산을 처리하도록 구성된다. 상기 시스템은 경우에 따라 서 하나의 칩으로 구현하거나, 하나의 칩으로 부족하면 복수의 칩을 다시 매트릭스 형태로 배열한 보드를 구성 하여 구현하거나, 또한 다시 복수의 보드를 셀프(shelf)나 랙(rack)에 설치하여 구현하는 경우도 있다. 물론, 연산의 규모에 따라 하나의 단일 칩에 시스템을 구성한 SoC(System on a Chip), 하나의 단일 패키지에 시 스템을 구성한 SoP(System on a Package), 혹은 하나의 단일 웨이퍼에 시스템을 구성한 SoW(System on a Wafer) 등 다양한 형태로 구성하는 것이 가능하다. 따라서 상기 시스템은 디바이스나 칩 등으로 혼용하여 사용 하도 무방하다. 본 발명의 시스템은 복수의 코어가 서로 독립적으로 동작하여 소정의 연산을 수행하도록 구성된 칩이나, 복수개 의 상기 칩이 서로 독립적으로 동작하여 소정의 연산을 수행하도록 구성된 보드나, 복수개의 상기 보드가 서로 독립적으로 동작하여 소정의 연산을 수행하도록 구성된 셀프나 랙을 포함하여 구현될 수 있다. 즉, 본 발명의시스템은 복수의 코어, 복수의 칩, 복수의 보드, 복수의 셀프나 랙을 포함하도록 그 규모를 확장하는 것이 가능 하다. 복수의 코어가 내장된 칩으로 구성한 디바이스의 경우, 칩을 생산하는 과정에서 제작상의 결함(fail)이 발생하 거나 칩을 사용하는 과정에서 결함이 발생할 수 있다. 기존에는 칩을 생산하는 과정에서 칩 테스트를 통해 특정 코어에 결함이 발생한 것을 확인하면 해당 칩 전체를 폐기하였다. 독립적인 연산을 수행하는 코어 매트릭스 구 조의 칩에서는 특정 코어 하나에 오류가 발생하였다고 칩 전체를 폐기하는 것은 칩의 수율을 떨어뜨리는 요인이 되고, 이는 많은 자원의 낭비로 귀결된다. 복수의 칩을 매트릭스 형태로 구성한 보드나 복수의 보드를 셀프나 랙에 장착하여 시스템을 구성한 경우에도, 그 사용 과정에서 특정 코어에 결함이 발생하였다고 해당 칩을 교체하거나 보드를 수리 내지 교체하는 것은 많 은 시간과 자원의 낭비를 초래한다. 즉, 종래의 시스템에서는, 특정 코어가 제조공정이나 사용 중에 결함이 발생할 경우, 해당 칩을 폐기처분하거나, 해당 칩이 포함된 보드를 교체하여야 하였다. 특히 반도체 칩의 회로 선폭이 점점 미세해짐에 따라 선폭이 덜 미세한 칩 제조 공정에 비해서 상대적으로 수율 이 낮아지고, 칩의 사용상에 있어서도 수명(life time)도 짧아지는 문제가 있다. 본 발명은 상기 문제를 해결하기 위해서 칩 내의 각 코어의 상태를 모니터링하고 특정 코어에 문제가 발생하면 해당 코어를 바이패스하도록 함으로써, 상기 칩을 구성하는 복수의 코어 중 어느 하나에 공정상 혹은 사용상 결 함이 발생하더라도 칩 전체로는 특정 연산이나 기능을 수행하는데 문제가 없도록 설계하고자 한다. 본 발명의 칩 설계 방법에 따르면 칩의 수율을 향상시키고 나아가 칩과 보드의 라이프 타임을 확장할 수 있는 장점이 있다. 나아가 보드의 경우에도 특정 칩이나 코어에 결함이 있더라도 전체 보드가 연산기능을 수행하는데 문제가 없도록 한다. 본 발명은 수많은 코어가 상호 독립적으로 연산을 수행하도록 구성되는 인터넷 뱅킹, 가상화폐(비트코인 등)의 작업증명, 디지털 서명 등에 사용하는 해싱이나 암호 알고리즘에 유용하게 사용될 수 있으며, 그 사용범위에 제 한이 없다."}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "다음으로 본 발명의 기술분야에 존재하는 선행발명에 대하여 간단하게 설명하고, 이어서 본 발명이 상기 선행발 명에 비해서 차별적으로 이루고자 하는 기술적 사항에 대해서 기술하고자 한다. 먼저 한국공개특허 제2022-0001222호(2022.01.05.)는 베드 블록을 처리하는 메모리 시스템 및 동작 방법에 관한 것으로, 복수의 메모리 블록을 포함하는 메모리 장치, 및 복수의 메모리 블록 중 베드 블록으로 결정된 제1 메 모리 블록에 대해 재사용 여부를 판단하고, 재사용되는 제1 메모리 블록에 저장된 제1 프로그램 순서 번호 (program sequence number, PSN)와 인접한 제2 프로그램 순서 번호가 저장된 제2 메모리 블록의 블록 정보를 제 1 메모리 블록의 블록 정보로 결정하는 컨트롤러를 포함하는 메모리 시스템을 제공한다. 즉, 한국공개특허 제2022-0001222호는 메모리 시스템에서 베드 블록을 처리하는 방법에 관한 것으로, 메모리 시 스템이 호스트의 요청에 대응하여 데이터 입출력 동작을 수행하는 중 메모리 장치 내 특정 블록을 베드 블록으 로 결정하는 런타임 베드 블록 관리 동작 후 사용 가능한 블록에 대한 정보를 갱신하는 장치와 방법을 제공하며, 런타임 베드 블록 관리 동작을 통해 베드 블록으로 판단된 메모리 블록에 대한 정보가 삭제된 경우, 해당 메모리 블록이 건강하다고 판단되어 다시 사용할 수 있다고 하더라도 이전까지의 사용을 통한 마모도를 추 정 혹은 산출하여 재사용되는 메모리 블록에 대한 상태를 보다 명확히 함으로써 메모리 시스템의 동작 안정성과 신뢰성을 향상시키고자 하는 것이다. 특히, 컨트롤러는 복수의 메모리 블록 중 적어도 하나의 메모리 블록에 대 해 데이터 입출력 동작을 수행하고, 상기 데이터 입출력 동작의 수행 중 기 설정된 조건(프로그램(삭제) 동작에 소요된 시간)에 따라 상기 적어도 하나의 메모리 블록을 상기 베드 블록(bad block)으로 결정할 수 있다. 그러나 본 발명에 따른 메모리에 대한 것이 아니라는 점에서 한국공개특허 제2022-0001222호와 차이점이 있고, 나아가 복수의 코어를 매트릭스 형태로 내장하고 있으면서 상기 복수의 코어가 서로 독립적으로 연산을 수행하 도록 구성된 시스템에서, 복수의 각 코어들에 대한 동작을 테스트하여 결함(fail)이 발생한 코어를 바이패스하 여 연산에서 제외할 수 있도록 구성함으로써, 일부 코어가 동작하지 않더라도 정상적으로 동작하는 나머지 코어 들이 각각 성능(performance)을 발휘하여 해당 전체 연산의 결과를 출력(harvesting)하도록 하는 성능 하베스팅 방법과 이를 적용한 시스템에 관한 것이다. 한편, 일본등록번호 제4746641호(2011.05.20.)는 클러스터(cluster) 이하의 단위로 읽기/쓰기를 실시하는 DRAM 과 페이지 단위로 읽기/쓰기를 실시하는 NAND 메모리가 구비되어 데이터 관리부는 DRAM 및 NAND에 기억된 데이 터의 저장 위치를 포함한 관리 정보에 가세해 NAND에 기억된 데이터를 DRAM에 읽을 때에, ECC 에러가 일어난 데 이터의 기억 위치를 관리하는 베드 클러스터 테이블이 유지하는 관리 정보에 근거하여 DRAM 및 NAND에서 데이터 의 관리를 실시하는 것이다. 즉, 일본등록번호 제4746641호는 NAND 메모리로부터 읽어낼 수 없게 된 클러스터 주소를 베드 클러스터 테이블 에 기록하여 관리하는 것으로, 본 발명의 복수의 코어들 중에서 결함이 있는 코어를 바이패스하여 연산에서 제 외하도록 구성함으로써, 일부 코어가 동작하지 않더라도 칩, 보드 혹은 시스템의 측면에서는 정상적으로 동작하 는 나머지 코어들의 성능을 발휘하여 해당 연산의 결과를 수확하는 것과 그 목적, 구성 및 효과에 있어서 그 차 이가 있다. 이상에서 살펴본 선행기술들은 메모리가 블록이나 클러스터로 나누어 어드레싱 하는 구조에서는 블록이나 클러 스터 단위로 베드 블록 혹은 베드 클러스터가 발생하는 것을 관리하는 것인 반면에, 본 발명은 코어 매트릭스 구조에서 특정 코어가 제조 과정 혹은 사용 중에 결함이 발생하면 해당 코어를 바이패스하도록 설계함으로써, 일부 코어가 동작하지 않더라도 정상적으로 동작하는 나머지 코어들이 성능을 발휘하여 소정의 연산결과를 수확 하도록 하는 방법과 시스템에 관한 것이므로, 선행기술에는 이러한 기술적 특징에 대한 기술적 구성이나 시사 또는 암시도 없다."}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 상기와 같은 문제점을 해결하기 위해 창작된 것으로서, 복수의 코어를 매트릭스 형태로 내장하고 있 으면서 상기 복수의 코어가 각각 서로 독립적으로 연산(혹은 태스크)을 수행하는 디바이스에서, 특정 코어가 결 함이 있어 동작하지 않더라도 나머지 코어들의 동작으로 칩의 성능을 하베스팅하여 소정의 성능을 발휘하도록 하는 방법 및 이를 수행하는 디바이스를 제공하는 것을 목적으로 한다. 또한 본 발명은 복수의 각 코어들에 대한 동작 상태의 감시나 제조과정에서의 칩 테스트를 통해서 발견된 결함 이 있는 코어를 바이패스하여 해당 연산에서 제외하도록 구성함으로써, 일부 코어가 동작하지 않더라도 해당 칩 이 정상적으로 동작하는 나머지 코어들의 성능발휘를 통해서 해당 연산결과를 출력하도록 하는 방법과 그 이를 수행하는 디바이스를 제공하는 것을 목적으로 한다. 또한 본 발명은 복수개의 상기 칩이 서로 독립적으로 소정의 연산을 수행하도록 구성된 보드나, 복수개의 상기 보드가 서로 독립적으로 소정의 연산을 수행하도록 구성된 셀프나 랙을 포함하여 구성된 시스템으로 성능 하베 스팅의 범위를 확대하는 것을 또 다른 목적으로 한다. 또한 본 발명은 생산과정에서 복수의 코어를 매트릭스 형태로 내장하고 있는 칩의 제조공정상 수율을 향상시키 고, 상기 칩의 사용으로 인한 라이프 타임을 확장하는 것을 또 다른 목적으로 한다. 또한 본 발명은 복수의 칩을 매트릭스 구조로 구성한 보드나 복수의 보드를 구비한 셀프나 랙으로 구성된 시스 템에 대해서도 해당 보드나 셀프 혹은 랙의 라이프 타임을 확장하는 것을 또 다른 목적으로 한다. 또한 본 발명은 수많은 코어가 상호 독립적으로 연산을 수행하도록 구성되는 인터넷 뱅킹, 비트코인의 작업증명, 디지털 서명 등에 사용하는 해싱이나 암호 알고리즘과 인공지능 학습엔진에 사용하기에 유용하도록 하는 것을 목적으로 한다."}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 일 실시예에 따른 코어 매트릭스 구조에서 성능 하베스팅 방법은, 복수의 코어가 매트릭스 구조로 배 열된 적어도 하나 이상의 코어그룹을 포함한 디바이스에서 상기 복수의 코어 중 적어도 하나 이상에 대한 결함 을 감지하는 베드코어 감지 단계; 및 상기 복수의 코어 중에서 상기 결함을 감지한 적어도 하나 이상의 코어에 대한 동작을 바이패스하고, 나머지 코어들로 상기 디바이스의 성능을 발휘하도록 하는 성능 하베스팅 단계;를 포함하는 것을 특징으로 한다. 상기 베드코어 감지 단계는, BIST(Built-In Self Test), 열화(degradation) 테스트, 기능(functional) 테스트 또는 이들의 조합 중 적어도 하나 이상을 포함하는 테스트를 수행하여 각 코어의 결함을 감지하는 것을 포함하 는 것을 특징으로 한다.또한 상기 베드코어 감지 단계는, 상기 테스트를 실행하기 위한 테스트 스케줄러를 가동하는 테스트 스케줄링 단계; 상기 테스트 스케줄러에 따라 테스트 패턴을 생성하는 테스트 패턴 생성 단계; 및 상기 생성한 테스트 패 턴을 상기 코어에 입력하고 그 응답을 미리 예상된 응답과 비교하여 감지하는 응답 모니터링 단계;를 포함하는 것을 특징으로 한다. 상기 응답 모니터링 단계는, 상기 감지한 결함이 소정의 미리 정해진 결함률보다 낮으면 해당 코어는 결함이 없 는 것으로 간주하고 상기 성능 하베스팅 단계에서 상기 소정의 태스크를 수행하도록 하거나, 상기 감지한 결함 이 존재하더라도 기능적으로 소정의 태스크를 올바르게 수행하는 것이 가능하다면 상기 성능 하베스팅 단계에서 상기 소정의 태스크를 수행하도록 하는 것을 포함하는 것을 특징으로 한다. 상기 성능 하베스팅 단계는, 상기 결함을 감지한 베드코어에 대해서 해당 코어에 할당된 태스크의 결과를 무시 하고, 상기 나머지 코어들이 독립적으로 할당된 태스크를 수행함으로써 성능을 발휘하도록 하는 것을 특징으로 한다. 또한 상기 성능 하베스팅 단계는, 상기 결함을 감지한 베드코어에 수정된 클록(modified clock)을 제공함으로써, 해당 코어의 입력데이터가 출력데이터로 바이패스되도록 하며, 상기 수정된 클록은, 정상상태에 서 해당 코어에 제공하는 클록을 마스킹(masking)하거나, 리셋(reset)하거나, 게이팅(gating)하거나 또는 이들 의 조합을 수행하여 생성된 클록인 것을 특징으로 한다. 또한 본 발명의 또 다른 일 실시예에 따른 코어 매트릭스 구조에서 성능 하베스팅을 수행하는 디바이스는, 복수 의 코어가 매트릭스 구조로 배열된 적어도 하나 이상의 코어그룹; 및 상기 복수의 코어 중에서 결함이 발생한 적어도 하나 이상의 코어에 대한 동작을 바이패스하고, 나머지 코어들로 성능을 발휘하도록 하는 성능 하베스팅 을 수행하도록 제어하는 컨트롤 로직부;를 포함하는 것을 특징으로 한다. 또한 상기 컨트롤 로직부는, 상기 복수의 코어 중 적어도 하나 이상에 대한 결함을 감지하는 테스트 매니저; 상 기 감지한 결함에 따라 상기 복수의 코어에 태스크의 할당을 관리하는 태스크 매니저; 및 상기 감지한 결함을 기록하고 관리하는 베드코어 매니저;를 포함하는 것을 특징으로 한다. 상기 테스트 매니저는, BIST(Built-In Self Test), 열화(degradation) 테스트, 기능(functional) 테스트 또는 이들의 조합 중 적어도 하나 이상을 포함하는 테스트를 수행하여 각 코어의 결함을 감지하는 것을 포함하는 것 을 특징으로 한다. 또한 상기 테스트 매니저는, 상기 테스트를 실행하기 위한 테스트 스케줄링을 수행하는 테스트 스케줄러; 상기 테스트 스케줄러에 따라 테스트 패턴을 생성하는 테스트 패턴 생성부; 및 상기 생성한 테스트 패턴을 상기 코어 에 입력하고 그 응답을 미리 예상된 응답과 비교하여 감지하는 응답 모니터링부;를 포함하는 것을 특징으로 한 다. 상기 응답 모니터링부는, 상기 감지한 결함이 소정의 미리 정해진 결함률보다 낮으면 해당 코어는 결함이 없는 것으로 간주하고 상기 성능 하베스팅을 수행하도록 상기 소정의 태스크를 수행하도록 하거나, 상기 감지한 결함 이 존재하더라도 기능적으로 소정의 태스크를 올바르게 수행하는 것이 가능하다면 상기 성능 하베스팅을 수행하 도록 상기 소정의 태스크를 수행하도록 하는 것 특징으로 한다. 상기 태스크 매니저는, 상기 결함을 감지한 베드코어에 대해서 해당 코어에 할당된 태스크의 결과를 무시하고, 상기 나머지 코어들이 독립적으로 할당된 태스크를 수행함으로써 성능을 발휘하도록 하는 것을 포함하는 것을 특징으로 한다. 또한 상기 컨트롤 로직부는, 상기 결함을 감지한 베드코어에 수정된 클록(modified clock)을 제공하는 클록 제 어부;를 더 포함하며, 상기 클록 제어부는, 상기 결함을 감지한 베드코어에 수정된 클록(modified clock)을 제 공함으로써, 해당 코어의 입력데이터가 출력데이터로 바이패스되도록 하며, 상기 수정된 클록은, 정상상태에서 해당 코어에 제공하는 클록을 마스킹(masking)하거나, 리셋(reset)하거나, 게이팅(gating)하거나 또는 이들의 조합을 수행하여 생성된 클록인 것을 특징으로 한다."}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "이상에서와 같이 본 발명은 복수의 코어를 매트릭스 형태로 내장하고 있으면서 상기 복수의 코어가 각각 서로 독립적으로 연산을 수행하는 디바이스에서, 특정 코어가 결함으로 인해 동작하지 않더라도 나머지 코어들의 동 작으로 칩의 성능을 하베스팅하여 소정의 성능을 발휘하도록 하는 효과가 있다.또한 본 발명은 복수의 각 코어들에 대한 동작 상태의 감시나 제조과정에서의 칩 테스트를 통해서 발견된 결함 이 발생한 코어를 바이패스하여 해당 연산에서 제외하도록 구성함으로써, 일부 코어가 동작하지 않더라도 해당 칩이 정상적으로 동작하는 나머지 코어들의 성능발휘를 통해서 해당 연산결과를 출력할 수 있으므로, 해당 칩의 수명을 증가시키는 효과가 있다. 또한 본 발명은 복수개의 상기 칩이 서로 독립적으로 소정의 연산을 수행하도록 구성된 보드나, 복수개의 상기 보드가 서로 독립적으로 소정의 연산을 수행하도록 구성된 셀프나 랙을 포함하여 구성된 시스템으로 성능 하베 스팅의 범위를 확대하는 것이 가능하다. 또한 본 발명은 생산과정에서 복수의 코어를 매트릭스 형태로 내장하고 있는 칩의 제조공정상 수율을 향상시키 고, 상기 칩의 사용으로 인한 라이프 타임을 확장하는 효과가 있다. 또한 본 발명은 복수의 칩을 매트릭스 구조로 구성한 보드나 복수의 보드를 구비한 셀프나 랙으로 구성된 시스 템에 대해서도 해당 보드나 셀프 혹은 랙의 수명을 확장하는 효과가 있다. 또한 본 발명은 수많은 코어가 상호 독립적으로 전체적인 연산을 수행하도록 구성되는 인터넷 뱅킹, 비트코인의 작업증명, 디지털 서명 등에 사용하는 해싱이나 암호 알고리즘과 인공지능 학습엔진에 효과적으로 사용될 수 있 다."}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 첨부한 도면을 참조하여 본 발명의 코어 매트릭스 구조에서 성능 하베스팅 방법 및 이를 수행하는 디바이 스에 대한 바람직한 실시예를 상세히 설명한다. 각 도면에 제시된 동일한 참조부호는 동일한 부재를 나타낸다. 또한 본 발명의 실시예들에 대해서 특정한 구조적 내지 기능적 설명들은 단지 본 발명에 따른 실시예를 설명하 기 위한 목적으로 예시된 것으로, 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사"}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "용되는 모든 용어들은 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가지고 있다. 일반적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의미를 가지는 것으로 해석되어야 하며, 본 명세서에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적인 의미로 해석되지 않는 것이 바람직하다. 본 발명에서는 복수의 코어를 매트릭스 구조로 구성한 칩, 복수의 상기 칩을 매트릭스 구조로 구성한 보드, 상 기 보드를 다시 셀프나 랙으로 확대한 시스템을 통칭하여 디바이스로 해석하여도 무방하다. 또한 제어로직 (Control logic)은 제어유니트, 제어부, 제어기, 제어모듈 등의 의미로 사용되며, 코어그룹(core group)은 코어 유니트, 코어부, 코어모듈 등의 의미로 사용된다. 또한 베드코어는 결함이 있는 코어의 의미이나, 상기 결함이란 코어가 완전히 작동 불능인 경우와 오류율이 일 정 수준 이상이어서 사용할 수 없는 경우를 포함한다. 예를 들어, BIST에서 일정 오류율을 보이나 특정 기능 테 스트는 통과한 경우에 결함이 있으나 베드코어로 등록하지 않고, 정상적으로 사용할 수도 있다. 도 1은 본 발명의 일 실시예에 따른 코어 매트릭스 구조에서 성능 하베스팅을 수행하는 디바이스(칩)(이하 성능 하베스팅을 수행하는 디바이스 또는 칩이라고 함)의 구성에 대한 개념을 나타낸 도면이다. 도 1에 도시한 바와 같이, 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스는 복수의 코어 매트릭스로 구성된 적어도 하나 이상의 코어그룹(Core Group)과 컨트롤 로직(Control Logic)(부)을 포함하여 구성된다. 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스는 외부에서 MCU(Main Control Unit)(20 0)에 의해서 운용되며, 상기 MCU는 메모리를 활용하여 컨트롤 로직(부)과 통신하면서 상기 성능 하베스팅을 수행하는 디바이스를 동작시켜 원하는 연산이나 태스크(task)를 효율적으로 수행하도록 한다. 상기 코어그룹은 수많은 코어들을 매트릭스 형태로 배치하여 구성하고, 각 코어는 필요한 연산이나 태스크 를 독립적으로 수행할 수 있도록 운영하도록 되어 있다. 이렇게 복수의 코어가 규칙적으로 배치된 적어도 하나 이상의 코어그룹은 컨트롤 로직부에 의해서 태 스크가 관리되고, 또한 상기 컨트롤 로직부는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바 이스를 위해서 테스트 관리, 태스크 관리, 베드코어 관리 및 클록제어를 수행하도록 구성된다. 이하에서는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스에 대해서 보다 자세하게 설명 하고자 한다. 도 2는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스(칩)의 구성에 대한 상세한 구조를 나타낸 도면이다. 도 2에 도시한 바와 같이, 본 발명에 따른 성능 하베스팅을 수행하는 디바이스는, 적어도 하나 이상의 코 어그룹(110a 내지 110d) 및 컨트롤 로직부를 포함하여 구성된다. 도 2에서는 코어그룹을 4개 도시하 였지만, 실제 코어그룹의 개수는 4개 이하 혹은 그 이상으로 구비하여도 무방함이 당연하다. 즉, 수천 개의 코 어를 구비할 수도 있다. 또한 본 발명의 성능 하베스팅 디바이스는 MCU가 메모리를 이용하여 필요에 따라 다양한 응용분 야에서 활용되고 운용된다. 상기 코어그룹은 적어도 하나 이상으로 구비될 수 있으며(예, 110a 내지 100d), 각 코어그룹은 적어 도 하나 이상의 클러스터를 포함하여 구성된다. 또한 상기 각 클러스터는 적어도 하나 이상의 코어 (112, 112a 내지 112d)를 포함하도록 구성된다. 다만, 클러스터의 구성은 특정 코어의 개수에 한정되지 아니하 고 다양한 목적에 따라 그룹핑하여 그 구성을 설정할 수 있다. 예를 들어 본 발명에 따른 코어그룹은 4개의 코어로 구성된 클러스터 64개를 하나의 코어그룹으로 정할 수 있다. 이렇게 하면 하나의 코어그룹에 256개의 코어가 구비될 수 있다. 또한 예를 들어 4개의 코어그룹(110a, 110b, 110c, 110d)으로 구성된 칩이라고 하면, 총 1024개의 코어를 내장(embedding)할 수 있다. 코어그룹의 구성이나 형태에서 상기 클러스터의 구성, 상기 코어그룹의 개수, 총 코어의 개수 등이 위에서 예시한 것에 한정되지 아니하며, 다양한 클러스터의 구성, 코어그룹의 개수 및 총 코어의 개수로 구성하는 것이 가능하다. 예시한 바와 같이 하나의 단일 칩은 1024개의 코어를 내장될 수 있으므로, 매우 방대한 량의 연산이나 태스크를 수행할 수 있는 시스템이나 디바이스가 된다. 또한 시스템의 규모에 따라 수백 개 내지 수천 개의 코어를 구비한 다양한 디바이스로 구현하는 것도 가능하다. 본 발명에 따른 성능 하베스팅 디바이스를 활용하여 특정 서비스를 구현하기 위해서 상기 서비스를 제공하 는 시스템의 차원에서 MCU와 메모리를 추가로 구비하고, 본 발명에 따른 성능 하베스팅 디바이스 와 통신하고 운용할 수 있다. MCU와 성능 하베스팅 디바이스 간의 통신을 통해서, 매우 복잡한 해싱이나 암호 알고리즘 또는 인공지능 알고리즘을 신속하게 처리할 수 있도록 하는 것이 가능하다. MCU는 디바이스를 동작시킬 때, 베드코어 매니저에 구비된 OTP로부터 결함정보를 읽어온다. OTP에는 칩 공정 테스트과정에서 BIST를 통해서 발견된 결함정보가 저장되어 있다. 이 후 TEST 매니저를 통해서 새로운 결함이 발견되면 해당 결함정보를 NVM에 저장한다. MCU는 OTP에서 읽어온 결함정보와 NVM에 저장된 결함정 보를 비교하여 DRAM에 로딩하고, 이를 UART를 경유하여 베드코어 매니저의 레지스터에 저장한다. 태 스크 매니저와 클록 제어부는 상기 레지스터에 저장된 결함정보를 이용하여 태스크를 관리하고 클록 을 제어한다. 상기 코어그룹에서 각 클러스터나 각 코어는 서로 연결되어 있으나, 만약 특정 코어나 클러스터가 결함이 생겨서 동작하지 않으면, 해당 코어나 클러스터를 동작시키는 클록을 수정하고, 상기 수정한 클록(modified clock)을 해당 코어나 클러스터에 제공하여 연산이나 태스크가 바이패스(bypass)되도록 구성할 수 있다. 논리적으로 상기 코어들 각각은 해당 코어에 제공되는 클록이 마스킹되어나, 리셋되거나 또는 게이팅되어 디스에이블(disable)되면, 앞단에 있는 코어의 출력을 수신 받아 다음단의 코어로 전달하는 역할만 수행하도록 할 수 있다. 만약, 클록이 디스에이블되지 않으면, 해당 코어가 이전단의 코어로부터의 결과를 입력받아 처리한 결과를 다음 단의 코어로 출력하도록 구성한다. 클록이 디스에이블(disable)되면 해당 코어의 RTL(Register transfer level)의 파이프라인(pipeline)은 동작하지 않도록 처리함으로써 불필요한 전력소모를 줄일 수 있다. 상기 클록은 상기 마스킹외에도 클록 게이팅이나 클록 리셋을 통해서 수정될 수 있다. 각 코어는 조합논리회로(combinational logic circuit), 순차논리회로(sequential logic circuit), 레지스터 파일 등을 포함할 수 있다. 이들은 모두 코어에서 지향하는 태스크를 함께 실행하도록 구성된다. 그러나 각 코 어는 특정 어플리케이션의 특수한 니즈에 맞게 맞춤형(customized)으로 구성할 수 있다. 특히 코어를 고성능이 나 저전력과 같은 디바이스의 필요에 따라 맞춤형으로 설계할 수 있다. 따라서 특정 칩에서의 코어의 구조는 설계 요구사항 및 원하는 기능에 따라 다양하게 구성될 수 있으나, 통상적 으로 코어의 구조는 제어부, 연산로직부, 레지스터, 메모리 인터페이스, 입출력 인터페이스, 버스 인터페이스 등을 포함할 수 있다. 여기서 제어부 및 연산로직부는 범용 혹은 맞춤형으로 설계할 수 있으나, 본 발명의 주요 기술적 사상과는 무관하므로 구체적인 설명은 생략한다. 또한 레지스터, 메모리 인터페이스, 입출력 인터페이스, 버스 인터페이스의 역할은 공지기술이므로 상세한 설명을 생략한다. 이상에서 예시한 상기 코어그룹, 클러스터, 코어의 개수는 단지 예시에 불과하며 필요에 따라서 다양하게 설정 하여 운영하는 것이 가능하다. 예컨대, 하나의 클러스터에 하나의 코어를 할당하여 코어와 클러스터를 구분할 필요가 없을 수도 있다. 상기 컨트롤 로직부는 테스트 매니저, 태스크 매니저, 클록 제어부, UART 및 베드코 어 매니저를 포함하여 구성된다. 여기서 테스트 매니저는 코어그룹의 테스트를 위해 테스트 시퀀스를 제어하고, 테스트 벡터를 생성하 며, 응답을 분석하는 역할을 한다. 즉, 테스트 시퀀스에 따라 테스트 패턴을 생성하고, 테스트 결과를 점검하고, 테스트 절차를 제어하는 것과 같은 다양한 태스크를 수행한다. 테스트 매니저는 테스트 절차를 자동화하고, 수동으로 외부에서 테스트 벡터를 입력하여 테스트하는 번거로움을 줄여주며, 코어그룹이 고품질 및 고안정도를 가지고 제조되도록 하는데 도움을 준다. 상기 테스트가 BIST인 경우에는, BIST를 위한 로직이 코 어에 함께 포함되어 있으므로 BIST를 채용한 코어는 그 복잡도가 상당히 늘어나는 단점이 있다. 상기 태스크 매니저는 코어그룹에서 수행하는 태스크를 관리하는 역할을 한다. 즉, 코어그룹에 서 수행되는 연산이나 태스크들에 대한 정보를 MCU에게 제공하여 코어의 리소스를 모니터링하는 것도 가능하도 록 하며, MCU는 태스크 매니저를 통해서 코어에서 처리하는 연산이나 태스크를 할당하거나 우선순위를 설 정할 수 있도록 한다. 상기 클록 제어부는 코어그룹의 각 클러스터나 코어에 클록을 제공하는 것을 제어하는 역 할을 한다. 본 발명의 일 실시예에 따른 성능 하베스팅을 적용한 디바이스에서는 결함이 발생한 코어나 클러스터에 클록의 제공을 차단하여 결함이 발생한 코어나 클러스터가 더 이상 동작하지 않도록 하는 것을 포함한 다. 또한 결함이 발생한 각 코어는 클록이 공급되지 않아 코어가 동작하지 않더라도 다른 인접 코어들이 독립적 으로 연산이나 태스크를 수행하는데 지장이 없도록 해당 코어의 입력데이터가 출력데이터로 바이패스되도록 하 는 것을 포함한다. 또한 상기 클록 제어부는 결함을 감지한 베드코어에 대해서 마스킹(masking), 리셋(reset), 게이팅 (gating), 또는 이들의 조합을 통해서 수정된 클록(modified clock)을 제공하도록 하는 것을 포함한다. 상기 UART(Universal Asynchronous Receiver and Transmitter)는 시리얼 통신 프로토콜의 하나로 디바이 스 간의 통신에 사용된다. 본 발명에 따른 성능 하베스팅을 수행하는 디바이스와 MCU와의 통신을 위 해 사용된다. 상기 베드코어 매니저는 상기 코어그룹의 클러스터나 코어에 대해서 결함(fail)이 발생한 것을 OTP(one-time programmable) 메모리에 프로그램(기록)하여 관리하는 것으로, 테스트 매니저를 통해서 제조 공정상에서 코어그룹의 특정 코어나 클러스터에 결함이 발생한 것을 식별하면, OTP 메모리에 해당 코어의 ID를 기록함으로써, 상기 클록 제어부에서 해당 코어나 클러스터에 클록이 공급되지 않도록 해당 클록을 마스킹 (masking), 리셋(reset), 게이팅(gating), 또는 이들의 조합을 수행하여 수정된 클록(modified clock)을 제공 하여 해당 코어나 클러스터의 동작을 차단하도록 하는 역할을 한다. 또한 상기 베드코어 매니저는 MCU로부터 결함정보를 입력받아 저장할 레지스터를 구비하여, 가장 최신의 결합정보를 태스크 매니저와 클록 제어부에 제공하여, 태스크를 관리하고 클록을 제어하도록 한다. 예를 들어, 코어그룹의 특정 코어(112f)가 고장이 나면 해당 코어에 공급되는 클록을 마스킹, 리셋 혹은 게이팅 하여 해당 코어(112f)가 동작하지 않도록 한다. 한편, 상기 클록이 각 클러스터마다 공급되고 있는 구조라면, 상기 코어(112f)가 포함된 클러스터에 클록의 공급을 제어하여 해당 클러스터를 연산에서 제외시킬 수 있다. 상기 코어그룹에 포함된 코어의 개수가 많으면, 각 코어마다 별도의 클록 라인을 구비하여야 하는데, 이 경우에는 지나치게 많은 클록라인으로 인해서 와이어링(wiring) 면적이나 복잡도가 높아지며 상기 복잡한 클록 라인으로 인해 전력소모가 증가할 수도 있다. 이 경우에는 클록 트리를 구성하여 전체 클록라인으로는 항상 정 상적인 클록이 공급되도록 하고, 각 코어로는 클록라인을 분기시키되, 결함이 발생하면 상기 분기된 클록라인을 개별적으로 차단하는 것이 바람직하다. 이하에서는 특정 코어에 결함이 발생할 경우, 상기 특정 코어의 전. 후단 간의 데이터패스에 대한 바이패스를 위한 구조를 설명하고자 한다. 이하 본 발명에서 제시하는 바이패스 구조는 하나의 예시이다. 본 발명은 결함이 발생한 코어를 연산에서 제외 하고 다른 코어의 연산에 영향을 미치지 않게 각 코어를 운용할 수 있도록 입출력 데이터패스를 구성하는 것이 바람직하다. 도 3은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스(칩)에서 특정 코어에 결함이 발생 할 경우, (a) 인접 코어 간의 입출력 데이터패스 및 (b) 각 코어가 독립적으로 운영되는 경우의 입출력 데이터 패스를 나타낸 도면이다. 도 3의 (a)에 도시한 바와 같이, 본 발명에 따른 각 코어는 각 코어에 대한 연산을 담당하는 핵심 코어(112a- 1)와 입출력 데이터패스에 대한 바이패스 회로(112a-2, AND, 등)를 포함하여 구성될 수 있다. 구체적으로, 각 코어(112b)는 인접 코어 간(112a 및 112c)에 상호 데이터를 송수신하기 위해서 해당 코어에 연 결된 클록(clock)이 마스킹(mask)될 경우, 해당 클록이 동작하지 않도록 하는 AND회로 외에도, 해당 코어가 연 산하는 핵심 코어(112a-1)와 이전 코어에서 입력된 데이터를 다음 코어로 그대로 출력할지 아니면 상기 핵심 코 어(112a-1)의 출력 중 하나를 선택하는 회로(112a-2)를 포함하여 구성할 수 있다. 여기서 핵심 코어(112a-1)는 특정 코어가 실행하는 연산이나 태스크와 관련한 핵심 기능을 수행하는 부분을 말 하며, 그 외에는 마스크(mask)신호가 low일 때 코어(112a-1)의 기능을 수행한 결과를 출력하도록 하고, 마스크 (mask)신호가 high일 때는 입력데이터(Data_in)를 바로 출력데이터(Data_out)로 출력하도록 하는 기능을 수행하 는 회로(112a-2)를 더 포함한다. 본 발명에 따른 코어는 핵심 코어(112a-1) 및 바이패스 회로를 포함하는데, 바이패스 회로를 다양하게 구성할 수 있으며, 필요에 따라 클록 제어부에서 구비될 수도 있고, 각 코어에 구비될 수도 있다. 여기서, 마스크된 클록은 수정된 클록(mclock, modified clock)의 한 종류이며, 마스크 대신에 게이팅이나 리셋 신호를 사용할 수도 있으나, 실제 마스크, 게이팅, 리셋 등은 기능적으로 실질적으로 동일한 의미를 가진다. 또한 도 3의 (b)에 도시한 바와 같이, 각 코어가 독립적으로 태스크 매니저에 의해서 소정의 태스크를 부 여받아 수행하도록 구성할 수도 있다. 이 경우 결함이 발생하면 마스크, 게이티드(gated), 혹은 리셋된 클럭 (mclock)을 사용하여 해당 코어의 동작을 디스에이블(disable) 시키도록 운영할 수 있다. 또한 본 발명에 따른 성능 하베스팅을 수행하는 디바이스(칩)의 컨트롤 로직부에 구비된 태스크 매니 저를 통해 결함이 있는 코어에 대해 태스크를 부여하지 않도록 관리하면, 특정 코어에 결함이 발생할 경우 연산에서 제외할 수 있을 것이다. 기본적으로 각 코어는 입력데이터(Data_in)를 기반으로 주어진 계산을 진행하고, 그 계산 결과가 주어진 조건을 만족하는지 비교하여, 만족하면 이 결과를 출력데이터(Data_out)로 전달한다. 예를 들면, 256-bit의 입력데이터를 입력 받고, 내부적으로 변경 가능한 32-bit를 자체적으로 변경하여 2^32 = \"4,294,967,296\"을 계산하는 작업이 주어지게 되고, 1024개의 코어가 존재한다면, 각 코어에는 2^22개의 작업 (연산)을 수행하도록 하는 명령이 나누어 전달되어 지고, 각 코어가 2^22개의 작업의 수행을 완료하면 다음 256-bit의 입력데이터를 받아 다시 계산을 진행하게 된다. 이중 하나의 코어에 결함(fail)이 발생하게 되면, 태 스크 매니저가 1024개에 할당되어진 2^32의 수행 작업을 1023개에 나누어 진행할 수 있도록 조정한다. 이러한 본 발명의 기술적 특징은 마이닝(mining)이나 AI 연산에 적용하기에 적합하며, 각 응용분야에 따라 코어 를 운영하는 방식에 차이가 있을 수 있다. 메모리의 경우에는 셀(cell)에 결함이 발생하면, 다른 셀로 그 역할을 대체하지만, 본 발명에 따르면 결함이 발 생한 코어에 대해서 업무를 재 할당하거나 결함이 발생한 코어에서 수행한 결과를 무시하는 방식으로 운영할 수 있다. 따라서 본 발명은 메모리의 베드 셀을 관리하는 것과 상이한 개념이다. 본 발명에 따르면 일부 코어에 결함이 발생할 경우 전체적인 컴퓨팅 능력은 그 만큼 떨어지지만 칩의 일부 코어 에 결함이 발생하여도 전체 칩을 사용할 수 있어 칩의 라이프 타임이 늘어나 비용을 낮추고 수율(yield)을 향상 시킬 수 있다. 본 발명은 이러한 코어의 구성에 대한 다양성은 포괄적으로 포함한다고 보는 것이 바람직하다. 즉, 본 발명에 따른 코어는 RTL-레벨의 파이프라인 회로를 포함하는 핵심 코어와 별도의 제어부, 메모리 인터페이스, 입출력 인터페이스 및 버스 인터페이스를 포함하여 설계할 수도 있다. 말하자면 특정 코어의 구조를 특정 구조로 한정 할 필요가 없다. 본 발명의 일 실시예에 따른 결함이 발생한 코어의 바이패스는 클록 제어부에 의해서 실행될 수도 있고, 다른 방식으로 동일한 효과를 내도록 구성될 수도 있으므로, 반드시 도 3에 의해서 한정되지는 아니한다. 또한 하나의 코어마다 별도의 클록을 연결하는 것이 아니라 복수의 코어를 그룹핑한 클러스터마다 별도의 클록을 연 결하는 경우에는 클러스터 단위로 해당 클록의 공급을 디스에이블(disable) 혹은 인에이블(enable) 하도록 마스 크, 케이팅, 혹은 리셋 신호를 발생시킬 수 있다. 또한 본 발명에서는 각 코어가 인접한 코어와 단방향으로 연결된 경우를 예시적으로 설명하였으나, 각 코어 간 에는 쌍방향으로 연결될 수도 있고, 또한 연결되지 않을 수도 있다. 다만, 각 코어는 별도의 독립적인 연산을 수행하여 인접한 코어의 연산 결과에 영향을 받지 않도록 구성하는 것이 바람직하다. 도 4는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스(칩)에서 테스트 매니저(TEST manager)의 구성을 나타낸 도면이고, 도 5는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바 이스(칩)에서 테스트 매니저의 동작을 나타낸 흐름도이다. 본 발명에서는 상기 테스트 매니저는 BIST(Built-In Self Test), 기능(functional) 테스트, 및 열화 (degradation) 테스트 중 적어도 하나 이상을 포함하도록 구성한다. 도 4, 5에 도시한 바와 같이, 테스트(TEST) 매니저는 테스트 스케줄러(121a), 테스트 패턴 생성기(121b), 응답 모니터(121c)를 포함하여 구성할 수 있다. 상기 테스트 스케줄러(121a)는 BIST, 기능 테스트 및 열화 테스트 중 적어도 하나를 사용하여 코어의 내부 구성 요소들에 대한 테스트 동작의 시퀀스를 제어하는 구성이다. 테스트 스케줄러(121a)는 일련의 테스트 패턴을 생 성하고, 코어내의 회로에 적용하여 코어가 올바르게 동작하는지 검증하는 것을 스케줄링 하는 것을 제어하는 역할을 한다. BIST에서는 코어를 작은 부분으로 나누어서 각각의 테스트 패턴을 사용하여 독립적으로 테스트한다. 테스트 스케줄러(121a)는 전체적인 테스트 프로세스가 올바른 순서에 따라서 수행되고 효과적으로 수행되도록 보장하기 위해서 각 테스트들의 타이밍과 실행을 조율한다(S110). 테스트 스케줄러(121a)는 하나의 구성에 대한 오류가 심각한 결과를 초래하는 높은 신뢰성을 가져야 하는 응용 분야에서 수행되며, 코어의 내부 구성들을 테스트하는데 BIST를 이용함으로써, 칩이 실제 적용되기 전에 결함을 감지할 수 있으며, 이를 통해서 전체적인 신뢰성을 높일 수 있고, 결함으로 인한 리스크를 줄일 수 있다. 이어서 테스트 매니저는 테스트 스케줄러(121a)에 따라 테스트 패턴 생성기(121b)를 통해 테스트 패턴을 생성하는 단계를 수행하도록 한다(S120). 상기 테스트 패턴은 각 코어의 내부 구성에 대해서 개별적으로 독립적 으로 테스트를 수행할 수 있도록 작성되는 것이 바람직하다. 또한 본 발명에서는 각 코어가 특정 입력에 대해서 해당하는 결과를 출력하는지 여부에 대한 테스트를 수행하도록 하는 것이 필수적으로 요구된다. 상기 테스트 패턴 생성기(121b)는 칩의 각 코어를 테스트하는데 사용되는 테스트 패턴을 생성하는 것으로, 상기 테스트 패턴은 코어에서 결함이 발행했는지를 감지하기 위해 설계되며, 의사랜덤 패턴, 특정 결정된 규칙에 따 라 생성되는 패턴 혹은 이들의 조합을 포함하는 다양한 방식으로 생성된다. 다음으로 테스트 매니저는 생성한 테스트 패턴을 입력한 경우 응답 모니터(121c)를 통해 그 응답을 모니터 링하는 단계를 수행하도록 한다(S130). 즉, 각 구성 부분에 대해서 독립적으로 테스트 패턴을 입력한 결과 원하 는 응답을 출력하는지 모니터링한다. BIST에서, BIST 로직으로 결함이 있는 코어나 클러스터를 감지할 때, 0.3% 미만의 결함율에 대해서는 테스트 결과가 만족한 것으로 간주할 수도 있다. 그러나 이러한 결함율의 임계값은 수행하는 태스크에 따라 달라지며 전혀 결함을 허용하지 않도록 칩을 운영하는 것도 가능하다. BIST의 결함율은 BIST의 설계 및 구현에 따라 다양한 요인에 의존한다. 즉, 테스트할 회로의 복잡도, 테스트 패 턴의 품질, 테스트의 오류 커버리지에 의존한다. BIST는 디지털 회로에서 오류를 광범위하게 감지할 수 있는 고 신뢰 테스트 기술로 알려져 있다. BIST의 사용은 높은 신뢰성을 요구하는 응용분야에서 감지되지 않을 수 있는 오류를 감지하여 집적회로의 전체적인 신뢰도를 향상시킬 수 있다. 그러나 다른 테스트 기술과 마찬가지로 BIST는 완벽하지 않으며 때때로 특정 결함을 감지하지 못하거나 무결함 을 잘못 생성할 수도 있다. BIST의 실패율은 BIST 기술의 설계 및 구현을 최적화하고, 고품질 테스트 패턴을 사 용하고, 여러 테스트를 수행하여 결함 커버리지를 늘림으로써 줄일 수 있다. 한편 응답 모니터(121c)는 오류 감지 및 정정코드를 사용할 수도 있다. 테스트 매니저는 칩의 기능을 담당하는 코어와 독립적으로 설계되는데, 이는 테스트 매니저가 칩의 정상 작동과 독립적으로 활성화되고 실행될 수 있음을 의미한다. 따라서 칩의 기능에 영향을 미치지 않고 포괄 적인 테스트가 가능하도록 한다. 전반적으로 BIST의 실패율은 특정 상황과 구현에 따라 다르지만 일반적으로 디지털 회로에 대한 신뢰할 수 있고 효과적인 테스트 기술로 간주된다. 도 6은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스(칩)에서 칩의 열화 테스트 및 기 능 테스트를 수행하는 과정을 나타낸 흐름도이다. 도 6에 도시된 바와 같이, 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스에 대해서, 상 기 MCU가 코어의 라이프 타임을 점검하기 위해서 주기적으로 혹은 비주기적 요청으로(S210) 소정의 규칙에 따라 열화 테스트(degradation test)를 수행한다(S220). 또한 상기 MCU는 주기적으로 혹은 비주기적 요청으로(S230), 소정의 규칙에 따라 코어의 기능 테스트 (functional test)를 수행한다(S240). 물론 상기 열화 테스트와 기능 테스트를 요청하지 않으면, 해당 테스트 과정을 스킵한다. 상기 열화 테스트와 상기 기능 테스트는 소정의 테스트 벡터를 이용하여 수행할 수 있다. 각 테스트를 수행하는 규칙은 주기적 혹은 비주기적으로 결정될 수 있다. 예를 들어, 시간을 정해두고 매번 정해진 시간이 도래할 때 마다 테스트를 수행할 수도 있고, 시스템이 새롭게 해당 칩을 가동할 때마다 가동하기 전에 소정의 테스트를 수 행하도록 하는 것이 가능하다. 물론 상기 규칙은 정하기 나름이다. 상기 열화 테스트나 기능 테스트 결과 베드코어(bad core)나 베드 클러스터(bad cluster)가 발생한 것으로 감지 되면(S250), MCU가 해당 베드코어나 베드 클러스터에 대한 결함정보를 비휘발성 메모리인 NVM(Non- Volatile Memory)에 기록하여 상기 결함정보를 업데이트한다(S260). 이렇게 업데이트된 결함정보는 MCU가 해당 칩을 동작시키기 전에 칩의 컨트롤 로직부에 구비된 베드코어 매니저를 경유하여 태스크 매니저와 클록 제어기에게 명령하여 해당 코어나 클러스터를 연산이 나 태스크를 수행하는 것에서 제외하도록 하거나 클록을 매스킹, 리셋, 또는 게이팅하여 해당 코어나 클러스터 의 동작을 차단하게 된다. 도 7은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스(칩)의 BIST 칩 테스트 시퀀스를 나타낸 흐름도이다. 도 7에 도시한 바와 같이, 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스의 칩 제조공정 상의 BIST 칩 테스트를 수행하는 과정은, 먼저 전원을 온(power-up)하는 동작을 수행한다(S310). 이어서 BIST를 통해서 칩 테스트 모드에 진입한다(S320). BIST로 칩 테스트를 수행하는 구체적인 과정은 도 5를 참조하여 설명한 바와 같다. 즉, S310에서 성능 하베스팅을 수행하는 디바이스의 전원을 온(ON) 시키면, 상기 매트릭스 구조의 성능 하 베스팅을 수행하는 디바이스가 동작을 시작하게 된다(S310). 상기 전원을 온 시킨 다음에 성능 하베스팅을 수행하는 디바이스는 BIST를 통해서 칩 테스트 모드에 진입 하고, BIST를 통해서 각 코어나 클러스터에 대한 테스트를 수행하고(S320), 그 결과에 따라 결함이 발견된 코어 가 있으면(S330), 베드코어 매니저에서 결함정보를 구축하게 된다(S340). 상기 결함정보는 OTP(One-Time Programmable) 메모리에 프로그램하여 기록한다. 칩 테스트에서 OTP 메모리에 기 록된 데이터는 칩의 제조과정에서 발생한 테스트 결과를 OTP 메모리에 프로그램한 결함정보이다. OTP 메모리는 비휘발성 메모리의 일종으로 제조과정에서 한번 프로그램되고, 전원이 오프되어도 데이터를 유지 한다. OTP 메모리는 칩에서 복수의 매트릭스 코어에 대한 칩 테스트 결과를 저장하는데 사용된다. 아울러 OTP 메모리에 기록된 데이터는 보정 데이터, 시리얼 번호, 암호키 및 설정정보와 같은 디바이스 특정 정 보일 수 있으며. 이러한 정보를 OTP 메모리에 저장함으로써, 외부 저장소에 대한 필요 없이 칩에 의해서 안전하 게 신뢰성 있게 액세스될 수 있다. 도 8은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스(칩)의 파워-업 시퀀스를 나타낸 흐름도이다. 도 8에 도시한 바와 같이, 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스를 적용한 시스템에 전원을 온(ON) 시키면, MCU, 메모리, 성능 하베스팅을 수행하는 칩이 동작을 하게 된다(S410). 이어서 MCU는 각 칩으로부터 최초로 칩 제조공정의 테스트 과정에서 기록된 OTP 메모리의 결함정보를 읽어 온다(S420). MCU는 OTP에서 읽어온 결함정보와 이전 NVM에 저장된 결함정보를 읽어와 비교한다(S430). 상기 비교한 결과 새로운 베드코어나 클러스터가 존재하는 것으로 판단되면(S440), 상기 MCU는 새로운 베 드코어나 클러스터에 대한 정보를 NVM에 기록하여 업데이트하고 동시에 해당 칩의 레지스터에 저장한다 (S450). 상기 레지스터는 베드코어 매니저에 구비될 수도 있고, 다른 임의의 위치에 마련될 수도 있다. 그 구비된 장소는 중요하지 않다. 이러한 과정을 거쳐 MCU는 본 발명에 따른 성능 하베스팅을 수행하는 디바이스와 상호 교신하면서 칩 에서 베드코어나 클러스터가 발생하였는지 실시간 혹은 비실시간으로 확인 및 관리하면서, 전체적인 성능 하베 스팅을 수행한다. 도 9는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스가 동작하는 도중에 BIST, 열화 테스트, 기능 테스트 중 어느 하나를 수행하여 성능 하베스팅에 활용하는 과정을 보인 흐름도이다. 도 9에 도시한 바와 같이, 외부로부터 칩 테스트 요청이 입력되면(S510), 칩 테스트 요청에 따라 BIST, 열화 테 스트, 기능 테스트 중 적어도 하나를 수행한다(S520). 상기 테스트를 수행한 결과 결함 코어나 클러스터가 발생한 것으로 판단되면(S530), MCU는 결함이 발생한 코어나 클러스터의 결함정보를 NVM에 업데이트하여 기록한다. 이어서 MCU는 결함이 발생한 코어나 클러스터의 결함정보를 해당 칩의 레지스터에 저장하여 업데이트한다 (S550). 이렇게 각 칩의 지정된 레지스터에 기록된 결함정보는 각 칩의 베드코어 매니저에서 읽어와 클록 제 어부를 통해서 해당 결함이 발생한 코어에 공급되는 클록을 리셋, 마스크, 혹은 게이팅을 통해서 수정된 클록을 생성하여 제공한다. 이로써 결함이 있는 코어는 동작이 차단된다. 아울러, MCU는 NVM에 저장된 결함정보(fail info)와 각 칩의 베드코어 매니저에 있는 OTP 메모리에서 읽어 온 결함정보를 비교하여 자체 메모리인 DRAM과 칩의 레지스터에 새로운 결함정보를 업데이트하여 저장하고, 이 를 토대로 각 칩의 태스크 매니저를 통해서 태스크에 대한 관리를 실행한다."}
{"patent_id": "10-2023-0045902", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "위의 도 6 내지 9를 통해서 설명한 각 칩의 결함정보를 관리하는 절차를 요약하면, 먼저 TEST 매니저를 통 해서 BIST를 수행한 결과 결함을 감지한 코어에 대한 결함정보를 OTP에 기록한다. 이어서 칩을 사용하는 과정에 서 MCU는 테스트 매니저를 통해서 추가적으로 결함정보를 감지할 수 있다. 따라서 MCU는 각 칩 으로부터 OTP에 기록된 결함정보를 읽어와 자체 메모리의 NVM에 기록된 결함정보와 비교하여 새로운 결함정보가 발견되면 자체 DRAM에 저장하여 응용분야의 연산에 활용하고, 각 칩의 레지스터에 저장하여 태스크 매니저(12 2)를 통해서 태스크를 관리하고, 클록 제어부를 통해서 결함이 있는 코어의 클록을 리셋하거나, 마스킹하 거나, 게이팅하여 해당 클록을 차단하도록 제어한다. 도 10은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스(칩)에서 보드나 셀프 혹은 랙으로 구성된 시스템으로 확대하여 적용하는 개념을 설명하기 위한 도면이다. 도 10에 도시한 바와 같이, 본 발명에 따른 성능 하베스팅을 수행하는 디바이스는 코어 매트릭스의 구조를 가진 칩 레벨에서 구성된다. 여기서 소정의 개수의 코어를 그룹핑한 클러스터 단위로 성능 하베스팅을 수행하도 록 하는 것도 가능하다. 본 발명의 일 실시예에 따른 복수의 칩을 복수개 사용하여 매트릭스 구조로 보드를 만들어 더 큰 규모의 연산 시스템을 구성할 수 있으며, 나아가 복수의 보드를 사용하여 매트릭스 구조로 셀프를 만들어 더 큰 규모의 연산 시스템을 구성할 수 있으며, 또한 이러한 복수의 셀프를 사용하여 매트릭스의 구조로 구성한 랙을 만들어 더욱 더 큰 규모의 시스템으로 확장하여 구성하는 것이 가능하다. 즉, 본 발명에 따른 성능 하베스팅을 수행하는 디바이스의 제어로직은 보드, 셀프 및 랙으로 구성된 시스 템으로 확장해서 적용하는 것이 가능하다. 이처럼, 본 발명은 복수의 코어를 매트릭스 형태로 내장하고 있으면서 상기 복수의 코어가 각각 서로 독립적으 로 연산을 수행하는 디바이스에서, 특정 코어가 결함으로 인해 동작하지 않더라도 나머지 코어들의 동작으로 칩 의 성능을 하베스팅하여 소정의 성능을 발휘하도록 하는 효과가 있다. 또한 본 발명은 복수의 각 코어들에 대한 동작 상태의 감시나 제조과정에서의 칩 테스트를 통해서 발견된 결함 이 발생한 코어를 바이패스하여 해당 연산에서 제외하도록 구성함으로써, 일부 코어가 동작하지 않더라도 해당 칩이 정상적으로 동작하는 나머지 코어들의 성능발휘를 통해서 해당 연산결과를 출력할 수 있으므로, 해당 칩의 수명을 증가시키는 효과가 있다. 또한 본 발명은 복수개의 상기 칩이 서로 독립적으로 소정의 연산을 수행하도록 구성된 보드나, 복수개의 상기 보드가 서로 독립적으로 소정의 연산을 수행하도록 구성된 셀프나 랙을 포함하여 구성된 시스템으로 성능 하베 스팅의 범위를 확대하는 것이 가능하다. 또한 본 발명은 생산과정에서 복수의 코어를 매트릭스 형태로 내장하고 있는 칩의 수율을 향상시키고, 상기 칩 의 사용으로 인한 수명을 확대하는 효과가 있다. 또한 본 발명은 복수의 칩을 매트릭스 구조로 구성한 보드나 복수의 보드를 구비한 셀프나 랙으로 구성된 시스 템에 대해서도 해당 보드나 셀프 혹은 랙의 수명을 확장하는 효과가 있다. 또한 본 발명은 수많은 코어가 상호 독립적으로 전체적인 연산을 수행하도록 구성되는 인터넷 뱅킹, 비트코인의 작업증명, 디지털 서명 등에 사용하는 해싱이나 암호 알고리즘에 효과적으로 사용될 수 있다. 이상에서와 같이 본 발명은 도면에 도시된 실시예를 참고로 하여 설명되었으나, 이는 예시적인 것에 불과하며, 당해 기술이 속하는 분야에서 통상의 지식을 가진 자라면 이로부터 다양한 변형 및 균등한 타 실시예가 가능하 다는 점을 이해할 것이다. 따라서 본 발명의 기술적 보호범위는 아래의 특허청구범위에 의해서 판단되어야 할 것이다."}
{"patent_id": "10-2023-0045902", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스의 구성에 대한 개념을 나타낸 도 면이다. 도 2는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스의 구성에 대한 상세한 구조를 나 타낸 도면이다. 도 3은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스에서 특정 코어에 결함이 발생할 경우, (a) 인접 코어 간의 데이터패스 및 (b) 각 코어가 독립적으로 운영되는 경우의 데이터패스를 나타낸 도 면이다. 도 4는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스에서 테스트 매니저의 구성을 나타 낸 도면이다. 도 5는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스에서 테스트(TEST) 매니저의 동작 을 나타낸 흐름도이다. 도 6은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스에서 칩의 열화 테스트 및 기능 테 스트를 수행하는 과정을 나타낸 흐름도이다. 도 7은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스의 BIST 칩 테스트 시퀀스를 나타 낸 흐름도이다. 도 8은 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스의 파워-업 시퀀스를 나타낸 흐름 도이다. 도 9는 본 발명의 일 실시예에 따른 성능 하베스팅을 수행하는 디바이스가 동작하는 도중에 BIST, 열화 테 스트, 기능 테스트 중 어느 하나를 수행하여 성능 하베스팅에 활용하는 과정을 보인 흐름도이다. 도 10은 본 발명의 일 실시예에 따른 성능 하베스팅 방법을 디바이스에서 보드나 셀프 혹은 랙 으로 구성된 시스템으로 확대하여 적용하는 개념을 설명하기 위한 도면이다."}
