{"patent_id": "10-2019-0063040", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2020-0002607", "출원번호": "10-2019-0063040", "발명의 명칭": "구분적 선형 근사를 이용한 심층 뉴럴 네트워크 아키텍처", "출원인": "인텔 아이피 코포레이션", "발명자": "필라이, 캄레쉬"}}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "로그 회로를 포함하는 장치로서, 상기 로그 회로는:입력 레지스터를 통해, 로그 연산과 연관된 입력을 식별하고 - 상기 로그 연산은 구분적 선형 근사를 이용하여상기 로그 회로에 의해 수행됨 -;범위 선택 회로를 이용하여, 상기 입력이 속하는 제1 범위를 식별하고 - 상기 제1 범위는 상기 로그 연산에 대한 복수의 구분적 선형 근사(PLA) 방정식과 연관된 복수의 범위로부터 식별되고, 상기 제1 범위는 상기 복수의PLA 방정식 중 제1 방정식에 대응함 -;가산기-감산기 회로를 이용하여, 복수의 피연산자에 기초하여 상기 제1 방정식의 결과를 계산하고;출력 레지스터를 통해, 상기 로그 연산과 연관된 출력을 반환하는 회로를 포함하고, 상기 출력은 상기 제1 방정식의 결과에 적어도 부분적으로 기초하여 생성되는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 로그 연산은 인공 뉴럴 네트워크 연산과 연관되는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 입력은 부동 소수점 수를 포함하고, 상기 부동 소수점 수는 지수 및 가수를 포함하고;상기 출력은 고정 소수점 수를 포함하고, 상기 고정 소수점 수는 정수 및 분수를 포함하는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 복수의 피연산자는 상기 가수 및 하나 이상의 분수 피연산자를 포함하고, 상기 하나 이상의 분수 피연산자 각각은 2의 거듭제곱을 포함하는 분모를 포함하는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서, 상기 로그 회로는 상기 하나 이상의 분수 피연산자를 생성하는 하나 이상의 시프트 회로를 추가로 포함하는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제3항에 있어서, 상기 로그 회로는 바이어스되지 않은 지수를 생성하기 위해 상기 부동 소수점 수의 상기 지수로부터 바이어스를 감산하는 감산기 회로를 추가로 포함하는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서, 상기 출력 레지스터를 통해, 상기 로그 연산과 연관된 출력을 반환하는 상기 회로는 추가로:상기 바이어스되지 않은 지수에 기초하여 상기 고정 소수점 수의 상기 정수를 생성하고;상기 제1 방정식의 결과에 기초하여 상기 고정 소수점 수의 상기 분수를 생성하는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 상기 로그 회로는 상기 제1 방정식과 연관된 상기 복수의 피연산자를 선택하는 하나 이상의 다중화기를 추가로 포함하는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서, 상기 가산기-감산기 회로는 상기 복수의 피연산자에 대해 하나 이상의 가산 또는 감산 연산을공개특허 10-2020-0002607-2-수행하는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1항에 있어서, 안티로그 회로를 추가로 포함하고, 상기 안티로그 회로는:안티로그 연산과 연관된 제2 입력을 식별하고 - 상기 안티로그 연산은 구분적 선형 근사를 이용하여 상기 안티로그 회로에 의해 수행됨 -;상기 제2 입력이 속하는 제2 범위를 식별하고 - 상기 제2 범위는 상기 안티로그 연산에 대한 제2 복수의 구분적선형 근사(PLA) 방정식과 연관된 제2 복수의 범위로부터 식별되고, 상기 제2 범위는 상기 제2 복수의 PLA 방정식 중 제2 방정식에 대응함 -;상기 제2 방정식과 연관된 제2 복수의 피연산자에 기초하여 상기 제2 방정식의 제2 결과를 계산하고;상기 안티로그 연산과 연관된 제2 출력을 생성하는 회로를 포함하고, 상기 제2 출력은 상기 제2 방정식의 상기제2 결과에 적어도 부분적으로 기초하여 생성되는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서, 활성화 함수 회로를 추가로 포함하고, 상기 활성화 함수 회로는 상기 로그 회로 및 상기 안티로그 회로를 포함하고, 상기 활성화 함수 회로는:복수의 이용가능한 활성화 함수로부터 선택된 활성화 함수를 수행하기 위한 명령을 수신하고 - 상기 활성화 함수는 하나 이상의 승산 또는 제산 연산을 포함함 -;하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 하나 이상의 승산 또는 제산 연산을 수행하고- 상기 하나 이상의 로그 연산은 상기 로그 회로를 이용하여 수행되고 상기 하나 이상의 안티로그 연산은 상기안티로그 회로를 이용하여 수행됨 -; 및상기 활성화 함수와 연관된 활성화 출력을 생성하는 회로를 추가로 포함하고, 상기 활성화 출력은 상기 하나 이상의 승산 또는 제산 연산의 하나 이상의 결과에 적어도 부분적으로 기초하여 생성되는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,상기 활성화 함수는 하나 이상의 지수 연산을 추가로 포함하고;상기 활성화 함수 회로는 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하는 지수 회로를 추가로 포함하는, 장치."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "시스템으로서,애플리케이션과 연관된 정보를 저장하는 메모리;상기 애플리케이션과 연관된 하나 이상의 명령어를 실행하는 프로세서; 및복수의 활성화 함수를 수행하는 활성화 함수 회로를 포함하고, 상기 활성화 함수 회로는:상기 애플리케이션과 연관된 활성화 함수를 수행하기 위한 명령을 수신하고 - 상기 활성화 함수는 상기 복수의활성화 함수로부터 선택되고, 상기 활성화 함수는 하나 이상의 승산 또는 제산 연산을 포함함 -;하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 상기 하나 이상의 승산 또는 제산 연산을 수행하고 - 상기 하나 이상의 로그 연산은 구분적 선형 근사를 이용하여 로그 회로에 의해 수행되고, 상기 하나이상의 안티로그 연산은 구분적 선형 근사를 이용하여 안티로그 회로에 의해 수행됨 -; 및상기 활성화 함수와 연관된 출력을 생성하는 회로를 포함하고, 상기 출력은 상기 하나 이상의 승산 또는 제산연산의 하나 이상의 결과에 적어도 부분적으로 기초하여 생성되는, 시스템."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "공개특허 10-2020-0002607-3-제13항에 있어서, 상기 애플리케이션은 인공 뉴럴 네트워크를 포함하고, 상기 활성화 함수는 상기 인공 뉴럴 네트워크의 연산과 연관되는, 시스템."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제13항에 있어서, 상기 하나 이상의 로그 연산 및 상기 하나 이상의 안티로그 연산을 이용하여 상기 하나 이상의 승산 또는 제산 연산을 수행하는 상기 회로는 추가로:상기 하나 이상의 승산 또는 제산 연산과 연관된 하나 이상의 피연산자에 대해 하나 이상의 로그 베이스 2 연산을 수행하고 - 상기 하나 이상의 로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행됨 -;상기 하나 이상의 로그 베이스 2 연산의 하나 이상의 결과에 대해 하나 이상의 가산 또는 감산 연산을수행하고;상기 하나 이상의 가산 또는 감산 연산의 하나 이상의 결과에 대해 하나 이상의 안티로그 베이스 2 연산을 수행하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행되는, 시스템."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제13항에 있어서, 상기 활성화 함수는 하나 이상의 지수 연산을 추가로 포함하고;상기 활성화 함수 회로는 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하는 회로를 추가로포함하는, 시스템."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서, 상기 하나 이상의 지수 연산 각각은 2의 베이스를 포함하고;구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하는 상기 회로는 추가로, 하나 이상의 안티로그 베이스 2 연산을 이용하여 상기 하나 이상의 지수 연산을 수행하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행되는, 시스템."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제13항에 있어서, 상기 복수의 활성화 함수는:sigmoid 함수;쌍곡선 탄젠트 함수;swish 함수; 및정류 선형 유닛 함수를 포함하는, 시스템."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서,상기 sigmoid 함수, 상기 쌍곡선 탄젠트 함수, 또는 상기 swish 함수 중 적어도 하나는 2의 베이스를 배타적으로 포함하는 하나 이상의 지수 연산을 이용하여 정의되고;상기 활성화 함수 회로는 하나 이상의 안티로그 베이스 2 연산을 이용하여 상기 하나 이상의 지수 연산을 수행하는 회로를 추가로 포함하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행되는, 시스템."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "명령어들이 저장된 적어도 하나의 머신 액세스 가능한 저장 매체로서, 상기 명령어들은 머신에서 실행될 때, 상기 머신으로 하여금:공개특허 10-2020-0002607-4-상기 활성화 함수 회로에 의해, 복수의 이용가능한 활성화 함수로부터 선택된 활성화 함수를 수행하기 위한 명령을 수신하고 - 상기 활성화 함수는 하나 이상의 승산 또는 제산 연산을 포함함 -;하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 상기 하나 이상의 승산 또는 제산 연산을 수행하고 - 상기 하나 이상의 로그 연산 및 상기 하나 이상의 안티로그 연산은 구분적 선형 근사를 이용하여 수행됨 -; 및상기 활성화 함수와 연관된 출력을 생성하는 회로를 포함하고, 상기 출력은 상기 하나 이상의 승산 또는 제산연산의 하나 이상의 결과에 적어도 부분적으로 기초하여 생성되는, 저장 매체."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제20항에 있어서, 상기 머신으로 하여금 상기 하나 이상의 로그 연산 및 상기 하나 이상의 안티로그 연산을 이용하여 상기 하나 이상의 승산 또는 제산 연산을 수행하게 하는 상기 명령어들은 추가로 상기 머신으로 하여금:상기 하나 이상의 승산 또는 제산 연산과 연관된 하나 이상의 피연산자에 대해 하나 이상의 로그 베이스 2 연산을 수행하고 - 상기 하나 이상의 로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행됨 -;상기 하나 이상의 로그 베이스 2 연산의 하나 이상의 결과에 대해 하나 이상의 가산 또는 감산 연산을수행하고;상기 하나 이상의 가산 또는 감산 연산의 하나 이상의 결과에 대해 하나 이상의 안티로그 베이스 2 연산을 수행하게 하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행되는, 저장 매체."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제20항에 있어서,상기 활성화 함수는 하나 이상의 지수 연산을 추가로 포함하고;상기 명령어들은 추가로 상기 머신으로 하여금 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하게 하는, 저장 매체."}
{"patent_id": "10-2019-0063040", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제20항에 있어서,상기 복수의 이용가능한 활성화 함수 중 적어도 하나의 활성화 함수는 2의 베이스를 배타적으로 포함하는 하나이상의 지수 연산을 이용하여 정의되고;상기 명령어들은 추가로 상기 머신으로 하여금 하나 이상의 안티로그 베이스 2 연산을 이용하여 상기 하나 이상의 지수 연산을 수행하게 하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행되는, 저장 매체."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "일 실시예에서, 장치는 로그 회로를 포함하고, 이는: 로그 연산과 연관된 입력을 식별하고 - 상기 로그 연산은 구분적 선형 근사를 이용하여 상기 로그 회로에 의해 수행됨 -; 상기 입력이 속하는 제1 범위를 식별하고 - 상기 제1 범위는 상기 로그 연산에 대한 복수의 구분적 선형 근사(PLA) 방정식과 연관된 복수의 범위로부터 식별되고, 상기 제1 범위는 상기 복수의 PLA 방정식 중 제1 방정식에 대응함 -; 상기 제1 방정식과 연관된 복수의 피연산자 에 기초하여 상기 제1 방정식의 결과를 계산하고; 상기 로그 연산과 연관된 출력을 반환하고, 상기 출력은 상기 제1 방정식의 결과에 적어도 부분적으로 기초하여 생성된다. 공개특허10-2020-0002607 명 세 서 청구범위 청구항 1 로그 회로를 포함하는 장치로서, 상기 로그 회로는: 입력 레지스터를 통해, 로그 연산과 연관된 입력을 식별하고 - 상기 로그 연산은 구분적 선형 근사를 이용하여 상기 로그 회로에 의해 수행됨 -; 범위 선택 회로를 이용하여, 상기 입력이 속하는 제1 범위를 식별하고 - 상기 제1 범위는 상기 로그 연산에 대 한 복수의 구분적 선형 근사(PLA) 방정식과 연관된 복수의 범위로부터 식별되고, 상기 제1 범위는 상기 복수의 PLA 방정식 중 제1 방정식에 대응함 -; 가산기-감산기 회로를 이용하여, 복수의 피연산자에 기초하여 상기 제1 방정식의 결과를 계산하고; 출력 레지스터를 통해, 상기 로그 연산과 연관된 출력을 반환하는 회로를 포함하고, 상기 출력은 상기 제1 방정 식의 결과에 적어도 부분적으로 기초하여 생성되는, 장치. 청구항 2 제1항에 있어서, 상기 로그 연산은 인공 뉴럴 네트워크 연산과 연관되는, 장치. 청구항 3 제1항에 있어서, 상기 입력은 부동 소수점 수를 포함하고, 상기 부동 소수점 수는 지수 및 가수를 포함하고; 상기 출력은 고정 소수점 수를 포함하고, 상기 고정 소수점 수는 정수 및 분수를 포함하는, 장치. 청구항 4 제3항에 있어서, 상기 복수의 피연산자는 상기 가수 및 하나 이상의 분수 피연산자를 포함하고, 상기 하나 이상 의 분수 피연산자 각각은 2의 거듭제곱을 포함하는 분모를 포함하는, 장치. 청구항 5 제4항에 있어서, 상기 로그 회로는 상기 하나 이상의 분수 피연산자를 생성하는 하나 이상의 시프트 회로를 추 가로 포함하는, 장치. 청구항 6 제3항에 있어서, 상기 로그 회로는 바이어스되지 않은 지수를 생성하기 위해 상기 부동 소수점 수의 상기 지수 로부터 바이어스를 감산하는 감산기 회로를 추가로 포함하는, 장치. 청구항 7 제6항에 있어서, 상기 출력 레지스터를 통해, 상기 로그 연산과 연관된 출력을 반환하는 상기 회로는 추가로: 상기 바이어스되지 않은 지수에 기초하여 상기 고정 소수점 수의 상기 정수를 생성하고; 상기 제1 방정식의 결과에 기초하여 상기 고정 소수점 수의 상기 분수를 생성하는, 장치. 청구항 8 제1항에 있어서, 상기 로그 회로는 상기 제1 방정식과 연관된 상기 복수의 피연산자를 선택하는 하나 이상의 다 중화기를 추가로 포함하는, 장치. 청구항 9 제1항에 있어서, 상기 가산기-감산기 회로는 상기 복수의 피연산자에 대해 하나 이상의 가산 또는 감산 연산을수행하는, 장치. 청구항 10 제1항에 있어서, 안티로그 회로를 추가로 포함하고, 상기 안티로그 회로는: 안티로그 연산과 연관된 제2 입력을 식별하고 - 상기 안티로그 연산은 구분적 선형 근사를 이용하여 상기 안티 로그 회로에 의해 수행됨 -; 상기 제2 입력이 속하는 제2 범위를 식별하고 - 상기 제2 범위는 상기 안티로그 연산에 대한 제2 복수의 구분적 선형 근사(PLA) 방정식과 연관된 제2 복수의 범위로부터 식별되고, 상기 제2 범위는 상기 제2 복수의 PLA 방정 식 중 제2 방정식에 대응함 -; 상기 제2 방정식과 연관된 제2 복수의 피연산자에 기초하여 상기 제2 방정식의 제2 결과를 계산하고; 상기 안티로그 연산과 연관된 제2 출력을 생성하는 회로를 포함하고, 상기 제2 출력은 상기 제2 방정식의 상기 제2 결과에 적어도 부분적으로 기초하여 생성되는, 장치. 청구항 11 제10항에 있어서, 활성화 함수 회로를 추가로 포함하고, 상기 활성화 함수 회로는 상기 로그 회로 및 상기 안티 로그 회로를 포함하고, 상기 활성화 함수 회로는: 복수의 이용가능한 활성화 함수로부터 선택된 활성화 함수를 수행하기 위한 명령을 수신하고 - 상기 활성화 함 수는 하나 이상의 승산 또는 제산 연산을 포함함 -; 하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 하나 이상의 승산 또는 제산 연산을 수행하고 - 상기 하나 이상의 로그 연산은 상기 로그 회로를 이용하여 수행되고 상기 하나 이상의 안티로그 연산은 상기 안티로그 회로를 이용하여 수행됨 -; 및 상기 활성화 함수와 연관된 활성화 출력을 생성하는 회로를 추가로 포함하고, 상기 활성화 출력은 상기 하나 이 상의 승산 또는 제산 연산의 하나 이상의 결과에 적어도 부분적으로 기초하여 생성되는, 장치. 청구항 12 제11항에 있어서, 상기 활성화 함수는 하나 이상의 지수 연산을 추가로 포함하고; 상기 활성화 함수 회로는 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하는 지수 회로를 추 가로 포함하는, 장치. 청구항 13 시스템으로서, 애플리케이션과 연관된 정보를 저장하는 메모리; 상기 애플리케이션과 연관된 하나 이상의 명령어를 실행하는 프로세서; 및 복수의 활성화 함수를 수행하는 활성화 함수 회로를 포함하고, 상기 활성화 함수 회로는: 상기 애플리케이션과 연관된 활성화 함수를 수행하기 위한 명령을 수신하고 - 상기 활성화 함수는 상기 복수의 활성화 함수로부터 선택되고, 상기 활성화 함수는 하나 이상의 승산 또는 제산 연산을 포함함 -; 하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 상기 하나 이상의 승산 또는 제산 연산을 수 행하고 - 상기 하나 이상의 로그 연산은 구분적 선형 근사를 이용하여 로그 회로에 의해 수행되고, 상기 하나 이상의 안티로그 연산은 구분적 선형 근사를 이용하여 안티로그 회로에 의해 수행됨 -; 및 상기 활성화 함수와 연관된 출력을 생성하는 회로를 포함하고, 상기 출력은 상기 하나 이상의 승산 또는 제산 연산의 하나 이상의 결과에 적어도 부분적으로 기초하여 생성되는, 시스템. 청구항 14 제13항에 있어서, 상기 애플리케이션은 인공 뉴럴 네트워크를 포함하고, 상기 활성화 함수는 상기 인공 뉴럴 네 트워크의 연산과 연관되는, 시스템. 청구항 15 제13항에 있어서, 상기 하나 이상의 로그 연산 및 상기 하나 이상의 안티로그 연산을 이용하여 상기 하나 이상 의 승산 또는 제산 연산을 수행하는 상기 회로는 추가로: 상기 하나 이상의 승산 또는 제산 연산과 연관된 하나 이상의 피연산자에 대해 하나 이상의 로그 베이스 2 연산 을 수행하고 - 상기 하나 이상의 로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행됨 -; 상기 하나 이상의 로그 베이스 2 연산의 하나 이상의 결과에 대해 하나 이상의 가산 또는 감산 연산을 수행하고; 상기 하나 이상의 가산 또는 감산 연산의 하나 이상의 결과에 대해 하나 이상의 안티로그 베이스 2 연산을 수행 하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행되는, 시스템. 청구항 16 제13항에 있어서, 상기 활성화 함수는 하나 이상의 지수 연산을 추가로 포함하고; 상기 활성화 함수 회로는 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하는 회로를 추가로 포함하는, 시스템. 청구항 17 제16항에 있어서, 상기 하나 이상의 지수 연산 각각은 2의 베이스를 포함하고; 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하는 상기 회로는 추가로, 하나 이상의 안티로 그 베이스 2 연산을 이용하여 상기 하나 이상의 지수 연산을 수행하고, 상기 하나 이상의 안티로그 베이스 2 연 산은 구분적 선형 근사를 이용하여 수행되는, 시스템. 청구항 18 제13항에 있어서, 상기 복수의 활성화 함수는: sigmoid 함수; 쌍곡선 탄젠트 함수; swish 함수; 및 정류 선형 유닛 함수를 포함하는, 시스템. 청구항 19 제18항에 있어서, 상기 sigmoid 함수, 상기 쌍곡선 탄젠트 함수, 또는 상기 swish 함수 중 적어도 하나는 2의 베이스를 배타적으 로 포함하는 하나 이상의 지수 연산을 이용하여 정의되고; 상기 활성화 함수 회로는 하나 이상의 안티로그 베이스 2 연산을 이용하여 상기 하나 이상의 지수 연산을 수행 하는 회로를 추가로 포함하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행 되는, 시스템. 청구항 20 명령어들이 저장된 적어도 하나의 머신 액세스 가능한 저장 매체로서, 상기 명령어들은 머신에서 실행될 때, 상 기 머신으로 하여금:상기 활성화 함수 회로에 의해, 복수의 이용가능한 활성화 함수로부터 선택된 활성화 함수를 수행하기 위한 명 령을 수신하고 - 상기 활성화 함수는 하나 이상의 승산 또는 제산 연산을 포함함 -; 하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 상기 하나 이상의 승산 또는 제산 연산을 수 행하고 - 상기 하나 이상의 로그 연산 및 상기 하나 이상의 안티로그 연산은 구분적 선형 근사를 이용하여 수행 됨 -; 및 상기 활성화 함수와 연관된 출력을 생성하는 회로를 포함하고, 상기 출력은 상기 하나 이상의 승산 또는 제산 연산의 하나 이상의 결과에 적어도 부분적으로 기초하여 생성되는, 저장 매체. 청구항 21 제20항에 있어서, 상기 머신으로 하여금 상기 하나 이상의 로그 연산 및 상기 하나 이상의 안티로그 연산을 이 용하여 상기 하나 이상의 승산 또는 제산 연산을 수행하게 하는 상기 명령어들은 추가로 상기 머신으로 하여금: 상기 하나 이상의 승산 또는 제산 연산과 연관된 하나 이상의 피연산자에 대해 하나 이상의 로그 베이스 2 연산 을 수행하고 - 상기 하나 이상의 로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행됨 -; 상기 하나 이상의 로그 베이스 2 연산의 하나 이상의 결과에 대해 하나 이상의 가산 또는 감산 연산을 수행하고; 상기 하나 이상의 가산 또는 감산 연산의 하나 이상의 결과에 대해 하나 이상의 안티로그 베이스 2 연산을 수행 하게 하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행되는, 저장 매체. 청구항 22 제20항에 있어서, 상기 활성화 함수는 하나 이상의 지수 연산을 추가로 포함하고; 상기 명령어들은 추가로 상기 머신으로 하여금 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수 행하게 하는, 저장 매체. 청구항 23 제20항에 있어서, 상기 복수의 이용가능한 활성화 함수 중 적어도 하나의 활성화 함수는 2의 베이스를 배타적으로 포함하는 하나 이상의 지수 연산을 이용하여 정의되고; 상기 명령어들은 추가로 상기 머신으로 하여금 하나 이상의 안티로그 베이스 2 연산을 이용하여 상기 하나 이상 의 지수 연산을 수행하게 하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행 되는, 저장 매체. 발명의 설명"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시내용은 일반적으로 컴퓨터 아키텍처 및 설계의 분야에 관한 것으로, 더 특정하게는, 비록 배타적이지는 않지만, 심층 뉴럴 네트워크(deep neural network)(DNN)를 위한 프로세싱 아키텍처에 관한 것이다."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "많은 상이한 사용 사례들에 대해 개발되고 있는 심층 학습 애플리케이션의 수가 계속해서 증가함으로 인해, 심 층 뉴럴 네트워크(DNN)를 위해 설계된 전문화된 하드웨어에 대한 강한 요구가 있다. 예를 들어, DNN은 전형적 으로 상당한 양의 실시간 프로세싱을 필요로 하는데, 이는 컨볼루션(convolution) 층, 풀링(pooling) 층, 완전 히 연결된 층(fully connected layer) 등과 같은, 부동 소수점 수에 대한 복잡한 연산의 다수의 층을 종종 수반 한다. 그러나, DNN들에 대한 기존 하드웨어 솔루션들은 많은 전력 소비, 높은 레이턴시, 상당한 실리콘 영역 요건들 등을 포함하여, 다양한 제한들을 겪는다."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "다음의 개시내용은 본 개시내용의 상이한 특징들을 구현하기 위한 많은 상이한 실시예들 또는 예들을 제공한다. 본 개시내용을 단순화하기 위해 컴포넌트들 및 배열들의 특정 예들이 아래에 설명된다. 물론, 이들은 단지 예 들에 불과하고, 제한하기 위해 의도된 것이 아니다. 또한, 본 개시내용은 다양한 예들에서 참조 번호들 및/또 는 문자들을 반복할 수 있다. 이러한 반복은 단순성 및 명확성을 위한 것이고, 그 자체가 논의된 다양한 실시 예들 및/또는 구성들 사이의 관계를 지시하지 않는다. 상이한 실시예들은 상이한 이점들을 가질 수 있고, 임의 의 실시예의 특정 이점이 반드시 필요한 것은 아니다. 로그/안티로그 구분적 선형 근사 회로들을 이용한 심층 뉴럴 네트워크(DNN) 추론 기계 학습(예컨대, 심층 학습)에 의존하는 인공 지능 애플리케이션의 수가 계속해서 증가함으로 인해, 인공 뉴 럴 네트워크(예컨대, 심층 뉴럴 네트워크, 컨볼루션 뉴럴 네트워크, 피드포워드 뉴럴 네트워크, 반복 뉴럴 네트 워크 등)를 구현하기 위해 설계되는 전문화된 하드웨어에 대한 강한 요구가 있다. 저전력, 저영역 및 고속 하 드웨어가 심층 학습 애플리케이션들에 이상적이다. 특히, 심층 뉴럴 네트워크(DNN)와 같은 인공 뉴럴 네트워크는 컨볼루션 층, 풀링 층, 완전히 연결된 층 등과 같 은 프로세싱 노드 또는 \"뉴런\"의 다수의 층을 이용하여 구현된다. 각각의 층에서의 노드들은 입력들 및 연관된 가중치들(전형적으로 벡터들로서 표현됨)의 컬렉션에 대한 계산들을 수행하여 출력들을 생성하고, 이 출력들은 그 후 다음 층에서의 노드들에 대한 입력들로서 사용된다. 각각의 층에서의 노드들에 의해 수행되는 계산들은 각각의 노드가 \"활성화\"되어야 하는지를 결정하기 위해 사용되는 활성화 함수들과 함께, 연관된 가중치들에 기초한 입력들의 변환들을 전형적으로 수반한다. 또한, 층들은 전형적으로 전역 최소값들에 도달하기 위해 특정 애플리케이션의 요건들에 기초하여 이러한 방식으로 반복된다. 더욱이, 최신 DNN들은 전형적으로 단정밀도(32-비트) 부동 소수점 포맷을 이용하여 표현되는 수치 값들에 대한 연산들을 이용하여 구현된다. DNN 추론은 일반적으로 컨볼루션 층, 풀링 층, 완전히 연결된 층 등과 같은 복잡 한 연산들의 다수의 층들을 수반하므로 이러한 부동 소수점 수들에 대한 상당한 양의 실시간 프로세싱을 요구한 다. 또한, 이러한 복잡한 연산들은 종종 승산들을 수반하기 때문에, 부동 소수점 승산기들이 기존 DNN 솔루션 들에서의 주요 컴포넌트들 중 하나이다. 그러나, 부동 소수점 승산기들은 전력 소비, 실리콘 영역, 및 레이턴 시에 관하여 매우 고가이다. 또한, 일부 경우들에서 DNN 연산들을 단순화하기 위해 룩업 테이블들(LUT들)이 사 용될 수 있지만, LUT들은 유사하게 고가의 실리콘 영역을 요구한다. 따라서, 일부 경우들에서, DNN들 및 다른 타입들의 인공 뉴럴 네트워크들을 구현하기 위해 사용되는 하드웨어의 필요한 실리콘 영역을 감소시키고/시키거나 성능을 개선하기 위해 DNN 최적화 기법들이 활용될 수 있다. 그러 나, 이러한 DNN 최적화 기법들은 전형적으로 전체 정밀도를 감소시키는 것 및/또는 기저의 연산들의 수를 감소 시키는 것(예컨대, 컨볼루션 층, 풀링 층 등의 수를 제한하는 것)에 의해 연산들의 비용을 감소시키는 것에 중 점을 둔다. 일부 실시예들에서, 예를 들어, DNN들을 구현하기 위해 사용되는 하드웨어는 더 적은 수의 비트를 갖는 부동 소수점 표현들에 대해 동작하고 따라서 더 적은 정밀도(예컨대, 8-비트 양자화된 부동 소수점으로부 터 16-비트 고정 소수점 표현들)를 제공하도록 설계될 수 있다. 그러나, 더 낮은 정밀도 부동 소수점 표현들의 사용은 일부 경우들에서, 특히 더 큰 데이터세트들에 대해 용인할 수 없는 정확도를 야기한다. 더욱이, 기저의 연산들 또는 층들의 수를 감소시키는 DNN 최적화 기법들은 DNN 훈련 동안 전역 최소값들에 도달하기 위한 열악 한 수렴 시간과 같은 악영향들을 가질 수 있다. 또한, 이러한 다양한 최적화들은 여전히 부동 소수점 승산기들 을 요구하기 때문에, 이들은 여전히 승산기 회로들의 전력, 영역, 및 성능 제한들을 겪는다. 일부 경우들에서, DNN들은 승산기 회로의 요건들을 완화하기 위해 룩업 테이블들(LUT들)을 이용하여 로그, 안티 로그 및/또는 지수 계산들을 수행하는 회로를 이용하여 구현될 수 있다. 일부 실시예들에서, 예를 들어, 로그, 안티로그 및/또는 지수 연산의 포물선 곡선을 다수의 세그먼트로 분할할 수 있고, 곡선 피팅 알고리즘을 이용하 여 각각의 계수들의 값들을 미리 계산할 수 있고, 그 후 미리 계산된 계수들을 메모리 컴포넌트(예컨대, ROM)를 이용하여 구현된 룩업 테이블에 저장할 수 있다. 이러한 방식으로, 곡선 상의 임의의 포인트에 대해 ax2+bx+c 를 계산하기 위해, 계수들 a, b, 및 c의 값들이 먼저 룩업 테이블로부터 페칭되고, 그 후 승산기들 및 가산기들 을 이용하여 결과가 계산된다. 그러나, 이 접근법은 연관된 LUT들 및 승산기들에 대한 상당한 실리콘 영역을 요구하고, 이는 또한 상기 방정식을 계산하기 위해 다수의 클록 사이클들(예컨대, 5-8 클록 사이클들)을 소비할 수 있다. 따라서, 본 개시내용은 룩업 테이블들 및/또는 승산기들에 의존하지 않고 DNN 계산들을 효율적으로 수행할 수 있는 하드웨어의 다양한 실시예들을 설명한다. 이제 본 개시내용의 특징들 및 기능성을 구현하는데 사용될 수 있는 예시적인 실시예들이 첨부된 도면들을 더 특정하게 참조하여 설명될 것이다. 도 1은 로그 및 안티로그 구분적 선형 근사 회로들을 이용하여 구현된 심층 뉴럴 네트워크(DNN)의 예시적 인 실시예를 예시한다. 예시된 예에서, DNN은 제1 컨볼루션 층(106a), 최대 풀링 층(106b), 제2 컨볼루션 층(106c), 제3 컨볼루션 층(106d), 및 완전히 연결된 층(106e)을 포함하는 다수의 층들(106a-e)을 이용하여 구 현된다. 더욱이, DNN은 각각의 DNN 층들(106a-e)에 대한 계산들을 수행하기 위해 승산기 회로들보다는 로 그 및 안티로그 회로들(110, 120)을 사용하는 승산기 없는 뉴럴 네트워크 마이크로아키텍처를 이용하여 구현된 다. 특히, 로그 및 안티로그 회로들(110, 120)은 로그 베이스 2(log2) 및 안티로그 베이스 2(antilog2) 계산들 을 수행하는데, 이는 특정 DNN 층들에서 전형적으로 요구되는 승산 연산들을 가산으로 변환하기 위해 활용 될 수 있다. 또한, 로그 및 안티로그 회로들(110, 120)은 구분적 선형 근사를 사용하여 log2 및 antilog2 계산 들을 수행하고, 이는 각각의 계산이 단일 클록 사이클에서 그리고 룩업 테이블들 또는 승산기들의 사용 없이 수 행될 수 있게 한다. 이러한 방식으로, 예시된 실시예는 DNN 프로세싱 레이턴시를 감소시키면서 또한 승산기 회 로 및 룩업 테이블들에 대한 필요성을 제거하고, 이는 하드웨어의 필요한 실리콘 영역을 현저히 감소시킨다. 로그 및 안티로그 회로들의 예시적인 구현들이 도 5a 내지 도 5c 및 도 6a 내지 도 6c와 관련하여 더 예시되고 설명된다. 예로서, DNN의 컨볼루션 층(들)(예컨대, DNN의 층들(106a,c,d))에 관하여, 컨볼루션은 일반적으로 다음의 방정식에 의해 표현될 수 있다(여기서 f(n) 및 g(n)는 부동 소수점 벡터들임): 이 방정식에서, 각각의 합산 항은 승산을 이용하여 계산된다. 그러나, 방정식의 양측에서 log2가 취해지면, 방 정식은 다음과 같이 된다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "또한, 방정식의 좌측이 y(n)로서 정의되어, log2(f*g)(n) = y(n)을 의미하면, 방정식은 다음과 같이 된다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "그러나, log2 계산들의 결과들을 누산함으로써 컨볼루션이 수행될 수 없으므로, 상기 방정식은 더 이상 컨볼루션 의 목적에 부합하지 않는다. 따라서, 각각의 합산 항이 누산되기 전에 그에 대해 antilog2가 취해져야 한다(예 컨대, 각각의 합산 항을 log2 도메인으로부터 다시 원래의 도메인으로 변환하기 위해):"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "컨볼루션을 위한 이 대안 방정식에서, 각각의 합산 항은 이제 가산을 이용하여 계산된다. 따라서, 위에 제시된 원래의 컨볼루션 방정식은 각각의 합산 항을 계산하기 위해 승산을 요구하지만, 이 대안 컨볼루션 방정식은 승 산보다는 가산을 요구한다. 따라서, 이 대안 방정식은 원래의 컨볼루션 방정식에 의해 요구되는 승산들을 가산 들로 변환하기 위해 본질적으로 log2(및 antilog2) 연산들을 활용한다. 예를 들어, 컨볼루션 방정식에서 f(n) 및 g(n)는 부동 소수점 수들(예컨대, IEEE-754 단정밀도 부동 소수점 수들)이므로, 가수 비트들에 대해 log2 및 antilog2가 취해지는 반면, 지수 및 부호 비트들은, 도 5a 내지 도 5c 및 도 6a 내지 도 6c와 관련하여 더 논의 되는 바와 같이, 개별적으로 핸들링된다. 이러한 방식으로, 로그 및 안티로그 회로(110, 120)는 복잡한 부동 소수점 승산 연산들을 회피하기 위해 원래의 방정식 대신에 이 대안 방정식을 이용하여 컨볼루션을 수행하기 위 해 사용될 수 있다. 다른 예로서, 완전히 연결된 층(예컨대, DNN의 층(106e))은 DNN의 마지막 층이고 최종 추론 및 의사 결정 의 수행을 담당한다. 일반적으로, 완전히 연결된 층은 컨볼루션 층과 유사하지만, 전형적으로 단일 차원 벡터 들을 수반한다. 따라서, 완전히 연결된 층은 승산 연산들을 가산으로 변환하기 위해 컨볼루션 층과 유사한 방 식으로 log2 계산들을 활용할 수 있다. 그러나, 완전히 연결된 층은 DNN의 마지막 층이기 때문에, 최종 출력들 은 log2 도메인보다는 정상 도메인에 있어야 한다.예시하자면, 완전히 연결된 층은 일반적으로 다음의 방정식을 이용하여 표현될 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "컨볼루션에서와 같이, 승산을 합산 항들에서의 가산으로 변환하기 위해 방정식의 양측에 대해 log2가 취해질 수 있다. 방정식의 양측에 대해 log2를 취하고, 또한 방정식의 좌측을 yfcl로 치환한 후에, 결과적인 방정식은 다음 과 같이 된다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "그 후, 각각의 합산 항들이 누산되기 전에 이들에 대해 Antilog2가 취해질 수 있고, 따라서 이들을 log2 도메인 으로부터 다시 정상 도메인으로 변환한다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "이러한 방식으로, 완전히 연결된 층의 최종 출력들은 log2 도메인보다는 정상 도메인에 있다. 또한, 원래의 방 정식에 의해 요구되는 승산들은 이 대안 방정식에서 가산들로 변환되었다. 예시된 실시예에서, 예를 들어, DNN은 제1 컨볼루션 층(106a), 최대 풀링 층(106b), 제2 컨볼루션 층 (106c), 제3 컨볼루션 층(106d), 및 완전히 연결된 층(106e)을 포함하는 다수의 층들(106a-e)을 이용하여 구현 된다. 각각의 층(106a-e)은 특정 층들에서 가중치 벡터(W)(103a-d)와 함께 입력(X)(101a-e)을 이용하여 계산들 을 수행하고, 대응하는 출력(Y)(103a-f)을 생성한다. 더욱이, 초기 입력 벡터(X)(101a)가 DNN의 제1 층 (106a)에 공급되는 반면, 각각의 나머지 층(106b-e)에는 그 입력(X)(101b-e)으로서 선행 층의 출력(Y)(103a- d)이 공급된다. 또한, 구분적 선형 근사를 이용하여 구현된 로그 및 안티로그 회로들(110, 120)을 활용하여 DNN의 각각의 층에서의 계산들을 수행하고, 따라서 승산기 회로들 및 룩업 테이블들에 대한 필요성을 제거하면서, 또한 레이턴시를 감소시킨다. 예를 들어, 로그 회로는 부동 소수점 수들을 고정 소수점 수들로 변환하기 위해 log2 계산들을 수행하고, 이는 부동 소수점 승산들과 같은 복잡한 연산들이 고정 소수점 가산들로 변환되는 것을 가능하게 하고, 안티로그 회로는 후속하여 고정 소수점 수들을 다시 부동 소수점 수들로 변환하기 위해 anitlog2 계산들을 수행한다. 더욱이, 로그 및 안티로그 회로들(110, 120)은 구분적 선형 근사를 사용하여 각 각의 log2 및 antilog2 계산들을 수행하고, 이는 각각의 계산이 단일 클록 사이클에서 수행될 수 있게 한다. 예시된 실시예에서, 예를 들어, 로그 회로는 원래의 입력 벡터(X)(101a) 및 각각의 가중치 벡터(W)(103a- d)가 DNN에 공급되기 전에 이들을 log2 도메인으로 변환하기 위해 사용되는 반면, 안티로그 회로는 완전히 연결된 층(106e)의 최종 출력(Y)(103f)을 log2 도메인으로부터 다시 정상 도메인으로 변환하기 위해 사 용된다. 또한, 필요에 따라 log2 도메인과 정상 도메인 사이에서 변환하기 위해 DNN의 은닉 층들(예컨대, 입력 및 출력 층들 사이의 중간 층들) 전체에 걸쳐 추가적인 antilog2 및 log2 연산들(도시되지 않음)이 또한 수 행된다. 예를 들어, 위에서 설명된 바와 같이, 컨볼루션 층은 각각의 합산 항이 누산되기 전에 다시 정상 도메 인으로 변환되도록 요구하고, 따라서 각각의 합산 항을 누산하기 전에 anitlog2 연산이 수행되어야 한다. 그러나, 후속 층들에서의 승산 연산들을 계속 회피하기 위해, 은닉 층의 최종 출력은 후속하여 다음 층에 제공되기 전에 다시 log2 도메인으로 변환된다. 예를 들어, 각각의 은닉 층 노드의 결과는 전형적으로 노드가 \"활성화\"되어야 하는지를 결정하는 활성화 함수로 전달되고, 그 후 활성화 함수의 출력은 다음 층에 입력으로서 공급된다. 따라서, 다음 층에서의 승산 연산들을 회피하기 위해, 은닉 층 노드의 활성화 함수의 log2가 다음 층에 공급된다. 예를 들어, 은닉 층 노드가 컨볼루 션 성분을 계산할 목적으로 antilog2 연산들을 수행한 후에, 결과는 활성화 함수에 전달되기 전에 다시 log2 도 메인으로 변환된다. 이러한 방식으로, 각각의 은닉 층 노드에 의해 계산된 출력(Y)은 다음 층에 입력(X)으로서 제공될 때 이미 log2 도메인에 있다. 따라서, 예시된 실시예는 고도로 확장가능하고 포터블한 유연한 저영역 하드웨어 설계를 이용하여 낮은 레이턴 시, 높은 정밀도, 및 감소된 전력 소비를 포함하는 다수의 이점들을 제공한다. 예를 들어, 예시된 실시예에서, DNN은 구분적 선형 근사를 이용하여 log2 및 antilog2 계산들을 수행하는 로그 및 안티로그 회로들(110, 120)을 이용하여 구현되며, 이는 하드웨어 설계에서의 승산기 회로들 및 룩업 테이블들에 대한 필요성을 제거한 다. 이러한 방식으로, 예시된 실시예는 (예컨대, 승산기들 및 룩업 테이블들을 제거함으로써) 필요한 실리콘 영역, 전력 소비, 및 하드웨어의 레이턴시를 현저히 감소시키면서도, 여전히 높은 정밀도를 제공한다. 특히, 제안된 마이크로아키텍처는 단일 클록 사이클에서 각각의 log2 및 antilog2 계산을 수행하고, 이는 데이터 경로 를 통한 지연을 감소시키고, 따라서 하드웨어의 전체 레이턴시를 감소시킨다. 제안된 마이크로아키텍처는 또한 고도로 확장가능하다. 특히, 제안된 마이크로아키텍처의 유연한 구현은 지원 되는 병렬 연산의 수를 증가시키기 위해 필요에 따라 하드웨어가 복제되는 것을 허용한다. 예를 들어, 제안된 마이크로아키텍처는 임의의 수의 로그 및 안티로그 회로(들)(110, 120)를 이용하여 구현될 수 있다. 이러한 방 식으로, 제안된 마이크로아키텍처는 특정 애플리케이션 또는 사용 사례에 의해 요구되는 병렬 연산의 수를 지원 하도록 용이하게 스케일링될 수 있다. 제안된 마이크로아키텍처의 정밀도는 또한 애플리케이션 요건들에 기초 하여 스케일링될 수 있다. 예를 들어, 애플리케이션이 더 큰 정밀도를 요구하는 경우, 로그 및 안티로그 회로 (110, 120)에 의해 사용되는 구분적 선형 근사 모델에서의 세그먼트의 수는 정밀도 요건들에 부합하도록 증가될 수 있다. 이러한 방식으로, 제안된 마이크로아키텍처는 또한, 어떤 의존이나 수정도 없이 모바일 디바이스(예 컨대, 핸드헬드 또는 웨어러블 디바이스), 드론, 서버, 및/또는 DNN 연산을 요구하는 임의의 다른 인공 지능 솔 루션을 포함하는, 임의의 제품 또는 폼 팩터에 대해 용이하게 포팅 및/또는 스케일링될 수 있기 때문에, 고도로 포터블하다. 구분적 선형 근사를 이용한 DNN 활성화 함수 회로 인공 지능(AI) 능력을 갖도록 설계된 제품의 수가 계속해서 증가함으로 인해, 특히 리소스-제약된 폼 팩터들(예 컨대, 작은, 저전력 에지 디바이스들)에 대해 다양한 상이한 구현들 및 연관된 알고리즘들을 지원하기에 충분히 일반적이면서도, 기본 AI 연산들(예컨대, 뉴럴 네트워크 활성화 함수들)을 가속화할 수 있는 전문화된 하드웨어 에 대한 강한 요구가 있다. 특히, 기계 학습(예컨대, 심층 학습)에 의존하는 AI 솔루션들의 증가하는 인기는 인공 뉴럴 네트워크(예컨대, 심층 뉴럴 네트워크, 컨볼루션 뉴럴 네트워크, 피드포워드 뉴럴 네트워크, 반복 뉴럴 네트워크 등)를 위해 설계 된 하드웨어 가속에 대한 요구로 이어졌다. 예를 들어, 심층 뉴럴 네트워크(DNN)는, 전형적으로 특정 입력에 응답하여 각각 \"활성화\"되어야 하는지를 결정하기 위해 비선형 활성화 함수들을 사용하는 프로세싱 노드들인, \"인공 뉴런들\"의 다수의 층들을 이용하여 구현된다. 활성화 함수는, 예를 들어, 전형적으로 특정 프로세싱 노 드 또는 \"인공 뉴런\"이 활성화되어야 하는지를 결정하기 위해 비선형 변환을 사용하여 출력에 입력을 매핑하는 함수이다. 활성화 함수의 사용은 DNN들의 중요한 양태이지만, 그것은 또한 매우 계산 집약적일 수 있다. 여러 다른 예들 중에서도, Sigmoid, 쌍곡선 탄젠트(Tanh), 정류 선형 유닛(ReLU), Leaky ReLU, 및 Swish를 포 함하여, DNN의 구현에서 사용될 수 있는 많은 상이한 타입의 활성화 함수들이 존재한다. 활성화 함수(들)의 선 택은 DNN의 훈련 역학 및 태스크 성능에 상당한 영향을 미친다. 따라서, 일부 경우들에서, DNN은 훈련 역학 및 성능을 증가시키기 위해 단일 뉴럴 네트워크 내의 다수의 활성화 함수를 이용하여 구현될 수 있다. DNN 계산 엔진은 또한 이러한 활성화 함수들을 구현하기 위한 전문화된 하드웨어에 의존할 수 있는데, 이는 전형적으로 실리콘 상의 상당한 양의 영역을 차지한다. 예를 들어, 최신 DNN들에 대해 설계된 하드웨어는 전형적으로 단정 밀도(32-비트) 부동 소수점 수들에 대해 동작하고 룩업 테이블(LUT) 접근법을 사용하여 활성화 함수들을 구현한다. 그러나, 활성화 함수들을 위한 룩업 테이블(LUT) 접근법의 사용은 실리콘 영역, 전력 소비, 및 레이턴시를 증가시키고, 이들은 각각 DNN 내의 뉴런의 수가 증가함에 따라 계속 커진다. 더욱이, 각각의 활성화 함수가 그 자신의 룩업 테이블을 요구하기 때문에, 단일 DNN에서의 다수의 활성화 함수들의 사용은 필요한 룩업 테이블의 수를 증가시키고, 따라서 실리콘 영역, 전력, 및 레이턴시에 더 영향을 미친다. 예로서, 룩업 테이블 접근법을 이용하면, 활성화 함수의 곡선은 전형적으로 구간 [-m, m] 사이에 제한되고(여기 서, 'm'은 실수임), 제한된 곡선은 그 후 다수의 세그먼트로 분할될 수 있다. 그 후, 곡선 피팅 알고리즘을 이 용하여 각각의 계수들의 값들을 미리 계산할 수 있고, 미리 계산된 계수들은 그 후 메모리 컴포넌트(예컨대, ROM)를 이용하여 구현된 룩업 테이블에 저장될 수 있다. 이러한 방식으로, 곡선 상의 임의의 포인트에 대해 ax2+bx+c를 계산하기 위해, 계수들 a, b, 및 c의 값들이 먼저 룩업 테이블로부터 페칭되고, 그 후 승산기들 및 가산기들을 이용하여 결과가 계산된다. 그러나, 이 접근법은 연관된 룩업 테이블들 및 승산기들에 대한 상당한 실리콘 영역을 요구하고, 그것은 또한 상기 방정식을 계산하기 위해 다수의 클록 사이클(예컨대, 5 - 8개의 클 록 사이클)을 소비할 수 있다. 예시하자면, 64 비트 계수 폭(a: 20 비트, b: 20 비트, c: 24 비트)을 갖는 256개의 균일한 세그먼트로 분할되 는 구간 [-3, 3]에 걸친 제한된 곡선이 IEEE-754 단정밀도 부동 소수점 수들에 대한 21-비트 가수 정밀도를 생 성한다. 특정 실시예들에서, 이 접근법은 각각 41,853개 및 5,574개의 합성 게이트(예컨대, NAND 등가 게이트 들)를 포함하는 256x64 ROM 및 계산 블록을 요구한다. 이 하드웨어를 더 적은 정밀도(예컨대, 12-비트 또는 10-비트 정밀도)로 스케일 다운하는 것은 ROM 영역만을 절약할 것이다. 특정 실시예들에서, 예를 들어, 10-비 트 정밀도를 갖는 Sigmoid 활성화 함수에 요구되는 추정된 실리콘 영역은 17,120개의 합성 게이트이다. 더욱이, 이 영역은 하드웨어가 지원할 필요가 있는 병렬 연산의 수에 기초하여 더 복제되거나 인스턴스화되어야 한다. 따라서, DNN 활성화 함수들을 구현하기 위해 사용되는 기존 하드웨어(예컨대, 룩업 테이블들을 사용하여 구현된 하드웨어)는, 여러 다른 예들 중에서도, 고가의 실리콘 영역 요건들, 열악한 전력 소비, 및 높은 프로세싱 레이 턴시를 포함하는 다양한 단점들을 갖는다. 이러한 단점들은 예컨대 인공 뉴런, 병렬 연산, 및/또는 활성화 함 수의 수를 증가시킴으로써, 하드웨어가 스케일링됨에 따라 더 확대된다. 또한, 각각의 활성화 함수에 대한 개 별 하드웨어 블록들 및/또는 룩업 테이블들을 사용하지 않고 다수의 활성화 함수들을 구현할 수 있는 통일된 하 드웨어 솔루션들이 존재하지 않는다. 따라서, 본 개시내용은, 아래에 더 설명되는 바와 같이, 룩업 테이블들을 사용하지 않고 다수의 DNN 활성화 함 수들을 지원하는 통일된 하드웨어 솔루션의 다양한 실시예들을 설명한다. 도 2a 및 도 2b는 인공 뉴럴 네트워크(예컨대, 심층 뉴럴 네트워크(DNN))을 위한 통일된 활성화 함수(AF) 회로 의 예시적인 실시예를 예시한다. 특히, AF 회로는 룩업 테이블들에 의존하지 않고 단일 하드웨어 컴 포넌트 상에서 다수의 DNN 활성화 함수들에 대한 지원을 제공한다. 예시된 실시예에서, 예를 들어, AF 회로는, 각각의 활성화 함수에 대한 필요한 계산들을 단순화하기 위해, 구분적 선형 근사를 이용하여 구현되는, 지수, 로그 베이스 2(log2), 및 안티로그 베이스 2(antilog2) 계산들을 활용하는 새로운 알고리즘을 이용하여 각각의 활성화 함수들을 구현한다. 예를 들어, 많은 활성화 함수들은 복 잡한 지수, 제산, 및/또는 승산 연산들을 수반하는 비선형 함수들이며, 이들은 전형적으로 고가의 승산기 회로 를 이용하여 구현되다(예컨대, 제산은 분자를 분모의 역수와 곱하는 승산기 회로를 이용하여 구현될 수 있다). 그러나, AF 회로는 특정 활성화 함수들에 의해 요구되는 복잡한 제산 및/또는 승산 연산들을 제거하고 그 대신에 이들을 감산 및/또는 가산으로 변환하기 위해 log2 및 antilog2 계산들을 활용한다. 또한, AF 회로 는 활성화 함수들에 의해 요구되는 필요한 계산들을 더 단순화하기 위해 구분적 선형 근사를 이용하여 지 수, log2 및 antilog2 계산들을 구현한다. 결과적으로, log2 및 antilog2 계산들은 단일 클록 사이클에서 수행 될 수 있는 반면, 지수 계산들은 2개의 클록 사이클에서 수행될 수 있다. 이러한 방식으로, 활성화 함수는 단 지 5개의 클록 사이클에서 계산될 수 있고, 기저의 계산들은 스루풋을 증가시키기 위해 용이하게 파이프라인될 수 있다. 따라서, AF 회로는 구분적 선형 근사를 이용하여 구현된 log2, antilog2, 및 지수 계산들을 활 용하여 활성화 함수에 대한 기저의 계산들을 단순화하고, 이는 룩업 테이블들에 대한 필요성을 제거하고, 승산 기 회로 요건들을 감소시키고, 활성화 함수의 전체 레이턴시를 감소시킨다. 이 접근법은 실리콘 영역의 상당한 절약으로 바로 전환되는데(예컨대, 룩업 테이블들의 제거 및 감소된 승산기 회로로 인해), 그 이유는 그것이 유 사한 정밀도를 갖는 전형적인 룩업 테이블 접근법에 비해 훨씬 적은 수의 합성 게이트를 요구하기 때문이다.예시된 실시예에서, 예를 들어, AF 회로는 구분적 선형 근사를 이용하여 각각의 log2, antilog2, 및 지수 계산들을 수행하기 위한 로그, 안티로그, 및 지수 블록들(210, 220, 230)을 포함한다. 일부 실시예들에서, 예 를 들어, 로그, 안티로그 및 지수 블록들(210, 220, 230)은 IEEE-754 단정밀도 부동 소수점 수(즉, 1 부호 비트 + 8 지수 비트 + 12 가수 비트 = 21-비트 정밀도)의 가수에서 12-비트 정밀도로, 16-세그먼트 구분적 선형 근사 를 이용하여 구현될 수 있다. 로그, 안티로그 및 지수 블록들(210, 220, 230)의 예시적인 구현들은 도 5a 내지 도 5c, 도 6a 내지 도 6c, 및 도 7과 관련하여 더 예시되고 설명된다. AF 회로는 다음의 활성화 함수들을 지원하는 구성 가능한 회로이다: Sigmoid, 쌍곡선 탄젠트(Tanh), 정류 선형 유닛(ReLU), Leaky ReLU, 및 Swish. 그러나, 다른 실시예들에서, AF 회로는 임의의 타입 또는 수의 활성화 함수들을 지원하도록 설계될 수 있다. AF 회로는 연산 코드들을 이용하여 지원되는 활성화 함수들 중 임의의 것을 이용하도록 구성될 수 있다. 예시된 실시예에서, 예를 들어, AF 회로는 DNN의 구현에서 특정 층 또는 노드가 원하는 활성화 함수의 타입을 선택하기 위해 5 비트 연산 코드들을 이용하고, 회로는 단순 히 연산 코드 값을 변경함으로써 다른 타입의 활성화 함수들을 위해 재구성될 수 있다. 예시된 실시예에서, 5 개의 연산 코드 비트(202a 내지 202e)는 Tanh(202a), Sigmoid(202b), Swish(202c), ReLU(202d), 및 Leaky ReLU(202e)로 지정되고, 이러한 각각의 비트 값들은 원하는 타입의 활성화 함수에 기초하여 설정된다. 표 1은 연산 코드 비트들(202a-e)의 값들에 기초하여 다양한 지원되는 활성화 함수들에 대한 AF 회로의 하드웨어 구성을 식별한다."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "AF 회로의 동작은 연산 코드 비트들(202a 내지 202e)을 통해 어느 활성화 함수가 선택되는지에 따라 달라 진다. 따라서, AF 회로의 기능성은 AF 회로에 의해 지원되는 다양한 활성화 함수들을 예시하는 도 3a 내지 도 3e와 관련하여 아래에 더 논의된다. 도 3a는 로서 수학적으로 표현되는 Sigmoid 활성화 함수의 그래프를 예시한다. Sigmoid의 출력 (y축)은 0과 1 사이의 범위를 갖고, 그것의 형상은 매끄러운 계단 함수와 유사하고, 이는 그것을 DNN 활성화 함 수로서 유용하게 만드는 중요한 특성이다. 특히, 이 함수는 매끄럽고 연속적으로 미분가능하며, 기울기는 구간 -4 내지 4 사이에서 매우 가파르다. 이것은 X에서의 작은 변화가 Y에서의 큰 변화를 야기할 것임을 의미하며, 이는 DNN들에서의 역전파(back-propagation)에 대한 중요한 속성이다. 그러나, Sigmoid 함수에 대한 일부 단점 들도 있다. 예를 들어, Sigmoid는 그 함수가 +4 및 -4를 넘은 영역들에서 거의 평탄하기 때문에, 사라지는 기 울기 문제를 겪는데, 이는 매우 작은 기울기를 야기하고 DNN이 코스 정정을 수행하는 것을 어렵게 만든다. 또 한, 출력은 0 내지 1의 범위에 있기 때문에, 출력은 원점을 중심으로 대칭적이지 않고, 이는 양의 방향으로 기 울기 업데이트가 진행되게 한다. 일반적으로, 단일 정밀도 부동 소수점 포맷으로 표현된 주어진 입력 X에 대해, X의 Sigmoid, 또는 Sigmoid(X)는 다음의 방정식을 이용하여 계산될 수 있다: 그러나, 상기 방정식은 고가의 제산 연산을 요구하므로, 제산을 회피하기 위해 log2 및 antilog2 계산들이 활용 될 수 있다. 예를 들어, 로그 함수들의 속성들에 기초하여, 제산을 감산으로 변환하기 위해 방정식의 각 측에 서 log2가 취해질 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "그러나, f(X)에 대한 해를 구하기 위해, 다음 방정식의 각 측에서 또한 antilog2가 취해져야 한다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 10, "content": "Sigmoid 함수에 대한 이 대안 방정식은 제산이 감산 및 log2/antilog2 계산들로 대체되기 때문에 더 이상 제산을 요구하지 않는다. 또한, 지수, log2, 및 antilog2 계산들은 이 대안 방정식에 의해 요구되는 계산들을 더 단순 화하기 위해 구분적 선형 근사를 이용하여 구현될 수 있다. 따라서, 도 2a 및 도 2b를 다시 돌아가서, AF 회로는 위에 설명된 단순화된 접근법을 이용하여 Sigmoid 함 수를 구현한다. 예를 들어, AF 회로가 Sigmoid 함수를 위해 구성될 때, Sigmoid 연산 코드 비트(참조 번 호 202b)는 1로 설정되고, 다른 활성화 함수들에 대한 나머지 연산 코드 비트들(참조 번호들 202a,c,d,e)은 0으 로 설정된다. 이러한 방식으로, 입력 X(참조 번호 201)가 AF 회로로 공급될 때, 그것은 다중화기 (mux)(206a) 및 역다중화기(demux)를 통과하여 바이어스 블록으로 전달되고, 이 바이어스 블록은 입 력 X를 음수(-X)로 변환하기 위해 그것에 바이어스를 가산한다. 그 후 결과 -X는 를 계산하기 위해 지수 블록으로 전달되고, 그 후 그 결과는 를 계산하기 위해 가산기로 전달된다. 의 결과는 다중화기(206d)를 통과하여 로그 블록(210b)으로 전달되고, 이 로그 블록은 그 후 를 계산한다. 개별적으로, 감산기에는 그의 제1 피연산자로서 1의 상수 값이 공급되는 반면, 다중화기(206e)의 출력이 그의 제2 피연산자로서 공급된다. 이 경우, 다중화기(206e)로 공급되는 Sigmoid 연산 코드 비트(202b)는 1로 설정되므로, 다중화기(206e)는 그의 출력으로서 0의 상수 값을 선택한다. 따라서, 1과 0의 상수 값들이 각각의 피연산자들로서 감산기에 공급되고, 따라서 감산기는 1 - 0 = 1을 계산한다. 그 후 결과 값 1은 다 중화기(206f)를 통과하여 로그 블록(210a)으로 전달되고, 이 로그 블록은 그 후 (0과 동일함)을 계 산한다. 따라서, 로그 블록들(210a 및 210b)은 및 의 결과들을 각각 출력하고, 그 결과 들은 그 후 피연산자들로서 가산기/감산기에 전달된다. 이 경우, 가산기/감산기는 를 계산하기 위해 감산을 수행하고, 그 후 그 결과는 antilog2 계산: 을 수행하는 안티로그 블록으로 전달된다. 이러한 방식으로, 안티로그 블록 에 의해 계산된 결과는 Sigmoid 함수의 최종 결과에 대응한다. 예를 들어, 위에서 논의된 로그 함수들의 속성들에 기초하여: 따라서, AF 회로는 Sigmoid 함수의 최종 출력(Y)(참조 번호 203)으로서 안티로그 블록의 결과를 출력 한다. 또한, 위에 언급된 바와 같이, AF 회로의 각각의 지수, 로그, 및 안티로그 블록들(210-230)에 의해 수행되 는 지수, log2, 및 antilog2 계산들은 이 대안 방정식에 의해 요구되는 계산들을 더 단순화하기 위해 구분적 선 형 근사를 이용하여 구현된다. 도 3b는 로서 수학적으로 표현되는 쌍곡선 탄젠트(Tanh) 활성화 함수의 그래프를 예시한다. 이 함수는 -1 내지 1의 범위에 있는 출력을 갖고, 원점을 중심으로 대칭적이고, 그것은 또한 Sigmoid 함수보다 더 가파른 기울기를 갖지만, 그것은 여전히 사라지는 기울기 문제를 겪는다. 일반적으로, 단일 정밀도 부동 소수점 포맷으로 표현된 주어진 입력 X에 대해, X의 쌍곡선 탄젠트, 또는 Tanh(X)는 다음의 방정식을 이용하여 계산될 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 11, "content": "상기 방정식은 고가의 제산 연산을 요구하므로, 도 3a로부터의 Sigmoid 함수에 대해 위에 설명된 바와 유사한 방식으로 log2 및 antilog2 계산들을 활용함으로써 제산이 회피될 수 있다. 예를 들어, 제산을 감산으로 변환하 기 위해 방정식의 각 측에서 log2가 취해질 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 12, "content": "또한, f(X)에 대한 해를 구하기 위해, 그 후 다음 방정식의 각 측에서 antilog2가 취해질 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 13, "content": "제산이 감산 및 log2/antilog2 계산들로 대체되었으므로, Tanh 함수에 대한 이 대안 방정식은 더 이상 제산을 요 구하지 않는다. 또한, 지수, log2, 및 antilog2 계산들은 이 대안 방정식에 의해 요구되는 계산들을 더 단순화 하기 위해 구분적 선형 근사를 이용하여 구현될 수 있다. 따라서, 도 2a 및 도 2b를 다시 돌아가서, AF 회로는 위에 설명된 단순화된 접근법을 이용하여 Tanh 함수 를 구현한다. 예를 들어, AF 회로가 Tanh 함수를 위해 구성될 때, Tanh 연산 코드 비트(참조 번호 202a) 는 1로 설정되고, 다른 활성화 함수들에 대한 나머지 연산 코드 비트들(참조 번호들 202b,c,d,e)은 0으로 설정 된다. 이러한 방식으로, 입력 X(참조 번호 201)가 AF 회로로 공급될 때, 그것은 처음에 시프터를 통 과하고, 이 시프터는 그의 값을 두 배로 만들기 위해 X를 단일 비트만큼 좌측 시프트시키고, 따라서 2X의 출력 을 생성한다. 더욱이, AF 회로가 Tanh 함수를 위해 구성되므로, 시프터로부터의 2X의 출력은 그 후 다중화기(206a) 및 역다중화기를 통과하여 바이어스 블록으로 전달된다. 예를 들어, 다중화기(206 a)의 선택 신호는 1로 설정되는 Tanh 연산 코드 비트(202a)에 기초하므로, 다중화기(206a)는 그것이 역다중화기 로 전달하는 출력으로서 2X를 선택한다. 또한, 역다중화기의 선택 신호는, 양쪽 모두 0으로 설정되 는, ReLU/Leaky ReLU 연산 코드 비트들(202d,e)이 입력으로서 공급되는 OR 게이트의 출력에 기초하므로, 역다중화기는 2X의 값을 바이어스 블록으로 라우팅한다. 그 후 바이어스 블록은 그것을 음수(-2X)로 변환하기 위해 2X에 바이어스를 가산하고, 그 후 -2X의 결과 값이 지수 블록으로 전달되고, 이 지수 블록은 의 값을 출력한다. 그 후 지수 블록으로부터의 출력 는 감산기(다중화기(206e)를 통해) 및 가산기 양쪽 모두에 전달되고, 그 후 감산기 는 의 값을 계산하는 반면, 가산기는 의 값을 계산한다. 감산기 및 가산기로부터의 이러한 출력들은 각각 로그 블록들(210a 및 210b)로 전달되고, 이들은 및 의 값들을 각각 계산한다. 그 후 로그 블록들 (210a 및 210b)로부터의 각각의 출력들은 피연산자들로서 가산기/감산기 에 전달되고, 이 가산기/감산기는 를 계산하기 위해 감산을 수행하고, 그 후 그 결과는 안티로그 블록 으로 전달되고, 이 안티로그 블록은 antilog2 계산을 수행한다: . 이러한 방식으로, 안티로그 블록에 의해 계산된 결과는 Tanh 함수 의 최종 결과에 대응한다. 예를 들어, 위에서 논의된 로그 함수들의 속성들에 기초하여:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 14, "content": "따라서, AF 회로는 Tanh 함수의 최종 출력(Y)(참조 번호 203)으로서 안티로그 블록의 결과를 출력한 다. 또한, 위에 언급된 바와 같이, AF 회로의 각각의 지수, 로그, 및 안티로그 블록들(210-230)에 의해 수행되 는 지수, log2, 및 antilog2 계산들은 이 대안 방정식에 의해 요구되는 계산들을 더 단순화하기 위해 구분적 선 형 근사를 이용하여 구현된다. 도 3c는 로서 수학적으로 표현되는 정류 선형 유닛(ReLU) 활성화 함수의 그래프를 예시한다. ReLU는 다양한 이점들을 제공하는 널리 사용되는 활성화 함수이다. 특히, ReLU는 사라지는 기울기 문제를 회피하는 비선형 함수이고, 그것은 다른 활성화 함수들보다 덜 복잡하고, 따라서 계산적으로 덜 비싸고, 그것은 DNN들을 희소하고 더 효율적으로 만드는 유리한 속성들을 갖는다(예컨대, 그의 입력이 음수일 때, 그의 출력이 0이 되고, 따라서 대응하는 뉴런이 활성화되지 않는다). 다른 한편으로, ReLU 의 출력이 0이 될 때는 역전파 동안 가중치들이 업데이트될 수 없고, ReLU는 뉴럴 네트워크의 은닉 층들에서만 사용될 수 있다. 일반적으로, 단일 정밀도 부동 소수점 포맷으로 표현된 주어진 입력 X에 대해, X의 ReLU, 또는 ReLU(X)는 다음 의 방정식을 이용하여 계산될 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 15, "content": "상기 방정식은 단순하고, 어떤 고가의 계산도 요구하지 않고, 따라서 그것의 구현은 지수, log2, 또는 antilog2 계산들을 활용할 필요가 없기 때문에 비교적 간단하다. 예를 들어, 도 2a 및 도 2b를 다시 돌아가서, AF 회로가 ReLU 함수를 위해 구성될 때, ReLU 연산 코드 비 트(참조 번호 202d)는 1로 설정되고, 다른 활성화 함수들에 대한 나머지 연산 코드 비트들(참조 번호들 202a,b,c,e)은 0으로 설정된다. 이러한 방식으로, 입력 X(참조 번호 201)가 AF 회로로 공급될 때, X는 처 음에 다중화기(206a)를 통과하여 역다중화기로 전달되고, 그 후 역다중화기는 X를 다중화기(206c)로 라우팅한다. 개별적으로, 1의 상수 값이 또한 다중화기(206c)에 공급된다(다중화기(206b)를 통해). 또한, 다 중화기(206c)의 선택 신호는 X의 부호 비트에 기초하므로, 다중화기(206c)는 X가 양수인지 또는 음수인지에 따 라 X 또는 0 중 어느 하나를 그의 출력으로서 선택한다. 다중화기(206c)의 출력은 ReLU 함수의 최종 결과이므 로, AF 회로의 나머지 로직은 바이패스되고 다중화기(206c)의 출력은 결국 ReLU 함수에 대한 AF 회로(20 0)의 최종 출력(Y)(참조 번호 203)으로서 사용된다.도 3d는 (여기서, a = 0.01)로서 수학적으로 표현되는 Leaky 정류 선형 유닛(Leaky ReLU) 활성화 함수의 그래프를 예시한다. Leaky ReLU는 ReLU 의 개선된 변형이다. 예를 들어, ReLU에 관하여, 입력이 음수일 때, 출력과 기울기가 0이 되고, 이는 역전파에서의 가중치 업데이트 동안에 문제들을 야기한다. Leaky ReLU는 작은 선형 성분(0.01)과 입력의 승산을 사용하여 입력이 음수일 때 이 문제를 해결하고, 이는 뉴 런들이 죽게 되는 것을 방지하고 또한 기울기가 0이 되는 것을 방지한다. 일반적으로, 단일 정밀도 부동 소수점 포맷으로 표현된 주어진 입력 X에 대해, X의 Leaky ReLU, 또는 LeakyReLU(X)는 다음의 방정식을 이용하여 계산될 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 16, "content": "ReLU에서와 같이, Leaky ReLU에 대한 방정식은 단순하고, 어떤 고가의 계산도 요구하지 않고, 따라서 그것의 구 현은 지수, log2 또는 antilog2 계산들을 활용할 필요가 없기 때문에 비교적 간단하다. 예를 들어, 도 2a 및 도 2b를 다시 돌아가서, AF 회로가 Leaky ReLU 함수를 위해 구성될 때, Leaky ReLU 연산 코드 비트(참조 번호 202e)는 1로 설정되고, 다른 활성화 함수들에 대한 나머지 연산 코드 비트들(참조 번 호들 202a,b,c,d)은 0으로 설정된다. 이러한 방식으로, 입력 X(참조 번호 201)가 AF 회로로 공급될 때, X 는 처음에 다중화기(206a)를 통과하여 역다중화기로 전달되고, 그 후 역다중화기는 X를 다중화기 (206c)로 라우팅한다. 개별적으로, 0.01의 상수 값이 또한 다중화기(206c)에 공급된다(다중화기(206b)를 통 해). 또한, 다중화기(206c)의 선택 신호는 X의 부호 비트에 기초하므로, 다중화기(206c)는 X가 양수인지 또는 음수인지에 따라 X 또는 0.01 중 어느 하나를 그의 출력으로서 선택한다. 다중화기(206c)의 출력은 Leaky ReLU 함수의 최종 결과이므로, AF 회로의 나머지 로직은 바이패스되고 다중화기(206c)의 출력은 결국 Leaky ReLU 함수에 대한 AF 회로의 최종 출력(Y)(참조 번호 203)으로서 사용된다. 도 3e는 로서 수학적으로 표현되는 Swish 활성화 함수의 그래프를 예시한다. 많 은 경우에, Swish는 다른 활성화 함수들(예컨대, ReLU)보다 더 나은 정확도를 제공하는 것으로 밝혀졌다. 일반적으로, 단일 정밀도 부동 소수점 포맷으로 표현된 주어진 입력 X에 대해, X의 Swish, 또는 Swish(X)는 다 음의 방정식을 이용하여 계산될 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 17, "content": "상기 방정식은 고가의 제산 연산을 요구하므로, 도 3a로부터의 Sigmoid 함수에 대해 위에 설명된 바와 유사한 방식으로 log2 및 antilog2 계산들을 활용함으로써 제산이 회피될 수 있다. 예를 들어, 제산을 감산으로 변환하 기 위해 방정식의 각 측에서 log2가 취해질 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 18, "content": "또한, f(X)에 대한 해를 구하기 위해, 그 후 다음 방정식의 각 측에서 antilog2가 취해질 수 있다:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 19, "content": "Swish 함수에 대한 이 대안 방정식은 제산이 감산 및 log2/antilog2 계산들로 대체되기 때문에 더 이상 제산을 요구하지 않는다. 또한, 지수, log2, 및 antilog2 계산들은 이 대안 방정식에 의해 요구되는 계산들을 더 단순 화하기 위해 구분적 선형 근사를 이용하여 구현될 수 있다. 따라서, 도 2a 및 도 2b를 다시 돌아가서, AF 회로는 위에 설명된 단순화된 접근법을 이용하여 Swish 함수 를 구현한다. 예를 들어, AF 회로가 Swish 함수를 위해 구성될 때, Swish 연산 코드 비트(참조 번호 202c)는 1로 설정되고, 다른 활성화 함수들에 대한 나머지 연산 코드 비트들(참조 번호들 202a,b,d,e)은 0으로 설정된다. 이러한 방식으로, 입력 X(참조 번호 201)가 AF 회로로 공급될 때, X는 처음에 다중화기(206a) 를 통과하여 역다중화기로 전달되고, 그 후 역다중화기는 X를 바이어스 블록으로 라우팅한다. 예를 들어, 다중화기(206a)의 선택 신호는 0으로 설정되는 Tanh 연산 코드 비트(202a)에 기초하므로, 다중화기 (206a)는 그것이 역다중화기로 전달하는 출력으로서 X를 선택한다. 또한, 역다중화기의 선택 신호는, 양쪽 모두 0으로 설정되는, ReLU/Leaky ReLU 연산 코드 비트들(202d,e)이 입력으로서 공급되는 OR 게이 트의 출력에 기초하므로, 역다중화기는 X의 값을 바이어스 블록으로 라우팅한다. 그 후 바이어스 블록은 그것을 음수(-X)로 변환하기 위해 X에 바이어스를 가산하고, 그 후 -X의 결과 값이 지수 블록으로 전달되고, 이 지수 블록은 의 값을 출력한다. 그 후 지수 블록의 출력 는 를 계산하기 위해 가산기로 전달되고, 그 후 그 결과는 다중화기(206d)를 통과하여 로그 블록 (210b)으로 전달되고, 이 로그 블록은 그 후 를 계산한다. 개별적으로, 다중화기(206f)의 선택 신호는 1로 설정되는 Swish 연산 코드 비트(202c)에 기초하므로, 다중화기 (206f)는 로그 블록(210a)으로 전달되는 출력으로서 X를 선택하고, 로그 블록은 그 후 를 계산한다. 그 후 로그 블록들 (210a 및 210b)로부터의 각각의 출력들은 가산기/감산기 에 피연산자들로서 전달되고, 이 가산기/감산기는 를 계산하기 위해 감산을 수행하고, 그 후 그 결과는 안 티로그 블록으로 전달되고, 이 안티로그 블록은 antilog2 계산을 수행한다: . 이러한 방식으로, 안티로그 블록에 의해 계산된 결과는 Swish 함수의 최종 결과에 대응한다. 예를 들어, 위에서 논의된 로그 함수들의 속성들에 기초하여:"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 20, "content": "따라서, AF 회로는 Swish 함수의 최종 출력(Y)(참조 번호 203)으로서 안티로그 블록의 결과를 출력한 다. 또한, 위에 언급된 바와 같이, AF 회로의 각각의 지수, 로그, 및 안티로그 블록들(210-230)에 의해 수행되 는 지수, log2, 및 antilog2 계산들은 이 대안 방정식에 의해 요구되는 계산들을 더 단순화하기 위해 구분적 선 형 근사를 이용하여 구현된다. 따라서, 도 2a 및 도 2b의 AF 회로의 예시된 실시예는 다수의 활성화 함수들을 지원하고 고도로 확장가능 하고 포터블한 유연한 저영역 하드웨어 설계를 이용하여 낮은 레이턴시, 높은 정밀도, 및 감소된 전력 소비를 포함하는 다수의 이점들을 제공한다. 특히, AF 회로는 룩업 테이블들에 의존하지 않고 (예컨대, 각각의 활성화 함수에 대한 개별 하드웨어 컴포넌트들을 사용하기보다는) 단일 하드웨어 컴포넌트 상에서 다수의 DNN 활성화 함수들을 구현하는 통일된 솔루션이다. 예를 들어, 예시된 실시예에서, AF 회로는 구분적 선형 근 사를 이용하여 log2, antilog2, 및 지수계산들을 수행하는 로그, 안티로그, 및 지수 회로들(210, 220, 230)을 이용하여 구현되고, 이는 하드웨어 설계에서의 룩업 테이블들에 대한 필요성을 제거하고, 요구되는 승산기 회로 를 감소시킨다. 이러한 방식으로, 예시된 실시예는 하드웨어의 필요한 실리콘 영역, 전력 소비, 및 레이턴시를 현저히 감소시키 면서도, 여전히 높은 정밀도를 제공한다. 예를 들어, 룩업 테이블들의 제거 및 감소된 승산기 회로는 실리콘 영역의 상당한 절약으로 바로 전환되는데, 그 이유는 유사한 정밀도를 갖는 전형적인 룩업 테이블 접근법에 비 해 훨씬 더 작은 수의 합성 게이트들이 요구되기 때문이다. 또한, log2 및 antilog2 계산들은 단일 클록 사이클 에서 수행될 수 있는 반면, 지수 계산들은 2개의 클록 사이클에서 수행될 수 있으며, 이는 활성화 함수가 단지 5개의 클록 사이클에서 계산될 수 있게 한다. 더욱이, 기저의 계산들은 스루풋을 증가시키기 위해 용이하게 파 이프라인될 수 있다. AF 회로는 또한 상이한 활성화 함수들과 연관된 룩업 테이블들을 로딩/프로그래밍하기 위한 소프트웨어에 대한 의존성도 제거하는데, 그 이유는 AF 회로가 단순히 적절한 연산 코드를 프로그래밍함으로써 상이한 활성화 함수들을 위해 구성될 수 있기 때문이다. AF 회로 상에 연산 코드를 프로그래밍하는 것은 활성화 함수에 대한 룩업 테이블을 프로그래밍하는 것에 비해 훨씬 더 단순하고 더 적은 클록 사이클들을 요구한다. AF 회로는 또한 고도로 확장가능하다. 특히, AF 회로의 유연한 구현은 지원되는 병렬 연산의 수를 증가시키기 위해 필요에 따라 기저의 하드웨어가 복제되는 것을 허용한다. 이러한 방식으로, AF 회로는 특정 애플리케이션 또는 사용 사례에 의해 요구되는 병렬 연산의 수를 지원하도록 용이하게 스케일링될 수 있다. AF 회로의 정밀도는 또한 애플리케이션 요건들에 기초하여 스케일링될 수 있다. 예를 들어, 애플 리케이션이 더 큰 정밀도를 요구하는 경우, 로그, 안티로그, 및 지수 회로(210, 220, 230)에 의해 사용되는 구 분적 선형 근사 모델에서의 세그먼트의 수는 정밀도 요건들에 부합하도록 증가될 수 있다. 이러한 방식으로, AF 회로는 또한 어떤 의존이나 수정도 없이 모바일 디바이스(예컨대, 핸드헬드 또는 웨어러블 디바이스), 드론, 서버, 및/또는 DNN 연산을 요구하는 임의의 다른 인공 지능 솔루션을 포함하는, 임의의 제품 또는 폼 팩 터에 대해 용이하게 포팅 및/또는 스케일링될 수 있기 때문에, 고도로 포터블하다. 도 4는 인공 뉴럴 네트워크(예컨대, 심층 뉴럴 네트워크(DNN))을 위한 통일된 활성화 함수(AF) 회로의 대 안 실시예를 예시한다. 특히, AF 회로는, 특정 활성화 함수들이 지수 상수 e의 거듭제곱들 대신에 2의 거 듭제곱들을 사용하는 수정된 방정식들을 이용하여 구현된 것을 제외하고는, 도 2a 및 도 2b로부터의 AF 회로 와 유사하다. 예시하자면, Sigmoid, Swish, 및 쌍곡선 탄젠트 활성화 함수들에 대한 원래의 및 수정된 방 정식들이 표 2에 제공된다."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 21, "content": "표 2에 도시된 바와 같이, 원래의 방정식들에서의 베이스 e의 지수들은 수정된 방정식들에서 베이스 2의 지수들 로 대체된다. 이러한 방식으로, 활성화 함수들의 중요한 비선형 특성들(예컨대, 곡선의 형상)은 수정된 방정식 들에 의해 여전히 나타나지만, 기저의 활성화 함수 하드웨어는 훨씬 더 효율적으로 구현될 수 있다. 특히, 베 이스 e의 지수들을 베이스 2의 지수들로 대체함으로써, 지수 회로가 수정된 방정식들에 의해 더 이상 필요하지 않는데, 그 이유는 모든 지수 연산들이 이제 안티로그 회로에 의해 수행될 수 있기 때문이다. 예를 들어, 변수 x의 안티로그 베이스 2는 2의 x 거듭제곱(2x)과 등가이므로, 안티로그 베이스 2 연산들을 수행하는 안티로그 회 로는 수정된 활성화 함수 방정식들에 나타나는 베이스 2의 거듭제곱들을 계산하는 데 사용될 수 있다. 더욱이, 지수 회로보다는 안티로그 회로를 이용하여 지수 연산들을 수행하는 것은 AF 회로의 실리콘 영역 및 레이턴시 및 양쪽 모두를 감소시킨다. 비교로써, 예를 들어, 도 2a 및 도 2b의 AF 회로는, 2개의 클록 사이클에서 지수 연산을 수행할 수 있고 적어도 하나의 승산기를 필요로 하는, 구분적 선형 근사를 이용하여 구 현된 지수 회로(예컨대, 도 7의 지수 회로)를 이용하여 지수 연산들을 수행한다. 그러나, AF 회로는, 단 일 클록 사이클에서 안티로그 베이스 2 연산을 수행할 수 있고 승산기를 필요로 하지 않는, 구분적 선형 근사를 이용하여 구현된 안티로그 회로(예컨대, 도 6a 내지 도 6c의 안티로그 회로)를 이용하여 지수 연산들을 수행한다. 따라서, 지수 회로를 안티로그 회로로 대체함으로써, AF 회로의 전체 레이턴시는 하나의 클록 사이클 만큼 감소되고, 따라서 도 2a 및 도 2b의 활성화 함수 회로에 대한 5개의 클록 사이클에 비해, 단지 4개의 클록 사이클에서 활성화 함수가 계산될 수 있게 한다. 또한, AF 회로는 더 이상 어떤 승산기 회로도 요구하지 않아, 상당한 실리콘 영역 절약을 야기하는데, 그 이유는 제거된 지수 회로가 승산기를 필요로 한 유일한 컴포 넌트였기 때문이다. 예를 들어, 도 2a 및 도 2b의 AF 회로는 8,321개의 게이트를 이용하여 구현될 수 있 는 반면, AF 회로는 단지 7,221개의 게이트를 이용하여 구현될 수 있다. 더욱이, 도 2a 및 도 2b의 AF 회로와 유사하게, AF 회로는 특정 활성화 함수들에 대한 필요한 계산들 을 단순화하기 위해 구분적 선형 근사를 이용하여 로그 베이스 2(log2) 및 안티로그 베이스 2(antilog2) 계산들 을 활용한다. 예를 들어, log2 및 antilog2 계산들은 특정 활성화 함수들에 의해 요구되는 복잡한 제산 및/또는 승산 연산들을 제거하고 그 대신에 이들을 감산 및/또는 가산으로 변환하는 데 사용될 수 있다. 표 2로부터의 수정된 Sigmoid, Swish, 및 쌍곡선 탄젠트 활성화 함수들에 대한 로그/안티로그 방정식들(e 대신에 2의 거듭제 곱들을 이용함)이 표 3에 제공된다. 수정된 활성화 함수들에 대한 이러한 로그/안티로그 방정식들은 도 3a 내 지 도 3e와 관련하여 설명된 바와 같이, 원래의 활성화 함수들의 것들과 유사한 방식으로 도출된다."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 22, "content": "예시된 실시예에서, AF 회로는 Sigmoid, Swish, Tanh, ReLU, 및 Leaky ReLU 활성화 함수들을 구현하도록 설계된다. Sigmoid, Swish, 및 Tanh 활성화 함수들은 표 3으로부터의 로그/안티로그 방정식들을 이용하여 구현 되는 반면, ReLU 및 Leaky ReLU 활성화 함수들은 도 3c 및 도 3d로부터의 그들의 원래의 방정식들을 이용하여 구현되는데, 그 이유는 이들은 어떤 복잡한 제산, 승산, 또는 지수 연산도 요구하지 않기 때문이다. AF 회로 의 동작은 그렇지 않으면 도 2a 및 도 2b의 AF 회로와 유사하다. 구분적 선형 근사를 이용하여 구현된 로그, 안티로그, 및 지수 회로들 도 5a 내지 도 5c는 구분적 선형 근사를 이용하여 구현된 로그 회로의 예시적인 실시예를 예시한다. 특히, 도 5a는 로그 회로의 전체 구현을 예시하는 반면, 도 5b 및 도 5c는 로그 회로의 특정 컴포넌 트들의 구현을 예시한다. 로그 회로는 16-세그먼트 구분적 선형 근사를 이용하여 로그 계산들을 수행한다. 이러한 방식으로, 로그 회로에 의해 룩업 테이블 또는 승산기 회로가 요구되지 않고, 로그 계산들은 단일 클록 사이클에서 수행될 수 있다. 로그 계산들을 위한 구분적 선형 근사를 수행하기 위해 로그 회로에 의해 이용되는 방정식들은 아래 표 4에 제시된다. 표 4의 방정식들은 log2(1+m)의 결과를 계산 또는 근사하도록 설계되고, 여기서 m은 단정밀도 부동 소수점 입력 의 가수 부분을 나타낸다. 예를 들어, 가수 m은 항상 0과 1 사이에 제한되므로, 그리고 log2의 결과가 정의되지 않으므로, m이 0일 때 정의되지 않은 결과를 회피하기 위해 log2(m) 대신에 log2(1+m)이 계산된다. 더 욱이, 16-세그먼트 구분적 선형 근사를 이용하여 log2(1+m)를 계산하기 위해, 구간 [0,1]에 걸친 m의 잠재적 값 들은 범위들 0 - 15로서 지정되는 16개의 상이한 범위들 또는 세그먼트들로 분할되고, log2(1+m)의 결과를 근사 하기 위해 각각의 범위에 대해 개별 방정식들이 정의된다. 또한, 각각의 방정식들은 다음의 타입의 피연산자들 중 임의의 것에 대한 가산 및/또는 감산을 이용하여 배타적으로 정의된다: m, 2의 거듭제곱들로 나눈 m의 분수 들, 및/또는 상수 값들. 이러한 방식으로, 방정식들에 의해 요구되는 유일한 제산은 배타적으로 2의 거듭제곱 들에 의한 것이고, 따라서 모든 제산 연산들은 시프터들을 이용하여 구현될 수 있다. 또한, 제한된 \"시프트 기 반\" 제산에 기인하는 정밀도의 손실은 특정 방정식들에서 가산 및/또는 감산되는 상수 값들의 사용을 통해 보상 된다. 따라서, 각각의 방정식들은 가산, 감산, 및/또는 시프트 연산들을 이용하여 배타적으로 구현될 수 있고, 따라서 복잡한 승산/제산 회로에 대한 필요성을 제거한다. 도 5a는 표 4의 방정식들을 구현하도록 설계된 로그 회로의 전체 로직을 예시한다. 예시된 실시예에서, 로그 회로에는 32-비트 단정밀도 부동 소수점 수가 입력(예컨대, 입력 레지스터를 통해 공급됨)으로 서 공급되고, 로그 회로는 대응하는 32-비트 고정 소수점 수를 출력(예컨대, 출력 레지스터를 통해 반환됨)으로서 계산하고, 이 출력은 입력의 log2 값을 나타낸다.입력은 부호 비트(input[31]), 8-비트 지수 e(input[30:23]), 및 23-비트 가수 m(input[22:0])을 포함한 다. 입력의 부호가 항상 출력의 부호와 일치한다고 가정하면, 입력의 부호 비트(input[31])는 출력의 대응 비트(output[31])로 직접 공급된다. 더욱이, 입력의 지수 e(input[30:23])는 8-비트 감산기로 공급되고, 이 감산기는 대응하는 8-비트 바이어스되지 않은 지수를 생성하기 위해 지수 e로부터 0x7F의 바이어스를 감산한다. 수학적 관점에서, 예를 들어, 부동 소수점 수의 지수로부터 바이어스를 감산하는 것은 항상 지수의 log2와 등가인 값을 야기한다. 따라서, 결과로서의 바이어스되지 않은 지수는 출력에 표현된 고정 소수점 수의 정수 부분(output[30:23])으로서 역할한다. 더욱이, 입력의 가수 m은 출력의 분수 필드(output[22:0])를 계산하는 데 사용될 표 4로부터의 대응 하는 범위 및 방정식을 선택하는 데 사용된다. 예를 들어, 가수 m의 4개의 최상위 비트(input[22:19])는 범위 선택 로직에 입력으로서 공급되고, 이 범위 선택 로직은 표 4로부터의 m의 각각의 범위들에 대응하는 16개 의 1-비트 신호(range[0] - range[15])를 출력하고, 따라서 적용가능한 범위에 대응하는 신호는 1로 설정되는 반면 나머지 신호들은 0으로 설정된다. 범위 선택 로직의 출력에 기초하여, 그 후 다중화기들(mux들)(508a-c)이 표 4로부터의 선택된 방정식에 대 응하는 피연산자들을 선택하는 데 사용되고, 그 후 그 피연산자들은 가산기/감산기에 입력으로서 공급된다. 특히, 다중화기들(508a-c)은 가수 m의 다양한 분수들(예컨대, 시프트 연산들을 이용하여 생성됨)뿐 만 아니라 특정 상수 값들 사이에서 선택한다. 예를 들어, 가수 m은 다수의 시프터들로 공급되고, 이 시 프터들 각각은 표 4의 방정식들 전체에 걸쳐 나타나는 2의 거듭제곱들에 대한 m의 다양한 분수들 을 계산하기 위해 특정 수의 비트만큼 m의 우측 시프트를 수행한다. 이러한 시프터들의 출력들은 그 후 도 5a에 도시된 방식으로 각각의 다중화기들(508a-c)에 입력들로서 공 급된다. 0의 상수 값이 추가적으로 다중화기(508b)에 입력들 중 하나로서 공급되는데, 그 이유는 그 값은 다중 화기(508b)로부터의 피연산자를 달리 요구하지 않는 특정 방정식들에 대해 다중화기(508b)에 의해 출력되기 때 문이다. 마지막으로, 표 4로부터의 특정 방정식들에 의해 요구되는 상수 값 은 상수 생성 로직에 의해 생성되고 다중화기(508c)에 입력으로서 더 공급된다. 상수 생성 로직의 구현은 도 5b와 관련하여 아래에 더 예시되고 설명된다. 그 후 각각의 다중화기(508a-c)는 표 4로부터의 적용가능한 방정식에 대한 피연산자들 중 하나에 대응하는 적절 한 출력을 선택하고(예컨대, 범위 선택 로직에 기초하여), 그 출력들은 그 후 가산기/감산기에 입력 들로서 공급된다. 또한, 가수 m이 또한 가산기/감산기에 다른 입력으로서 직접 공급되는데, 그 이유는 가 수는 표 4로부터의 모든 방정식들에 대한 피연산자이기 때문이다. 그 후 가산기/감산기는 입력으로서 공급되는 다양한 피연산자들에 대해 적절한 가산 및/또는 감산 연산들 을 수행하고, 계산된 결과는 그 후 출력의 23-비트 분수 필드(output[22:0])로서 역할한다. 가산기/감산 기의 구현은 도 5c와 관련하여 아래에 더 예시되고 설명된다. 도 5b는 표 4로부터의 특정 방정식들에 의해 요구되는 상수 값(들)을 생성하는 데 사용되는, 도 5a로부터의 로 그 회로의 상수 생성 로직의 예시적인 구현을 예시한다. 예시된 실시예에서, 상수 생성 로직은 표 4로부터의 방정식들 전체에 걸쳐 나타나는 상수 값들의 컬렉션을 생성하기 위한 시프터들, 표 4로부터 의 선택된 방정식에 대한 대응하는 상수 값(들)을 선택하는 다중화기들(mux들)(514a,b), 및 선택된 상수 값들을 가산하는 가산기를 포함한다. 예시된 실시예에서, +1 또는 -1 중 어느 하나의 23-비트 상수 값이 각각의 시프터들에 입력으로서 공급된 다(예컨대, 각각의 시프터가 양의 분수 상수를 생성하는지 또는 음의 분수 상수를 생성하는지에 따라). 예를 들어, +1의 23-비트 상수 값이 양의 결과들을 생성하는 시프터들 중 하나를 제외한 모든 시프터에 입력으 로서 공급되는 반면, -1의 23-비트 부호 있는 표현이 음의 결과를 생성하는 유일한 나머지 시프터(예컨대, 를 생성하기 위해 9-비트 우측 시프트를 수행하는 시프터)에 입력으로서 공급된다. 그 후 각각의 시프 터는 표 4로부터의 방정식들 전체에 걸쳐 나타나는 각각의 분수 상수들을 생성하기 위해 특정 수의 비트만큼 우측 시프트를 수행한다. 더욱이, 표 4로부터의 각각의 방정식들이 이러한 분수 상수를 0개, 1개, 또는 2개 요구하기 때문에, 표 4로부터 의 선택된 방정식에 대한 분수 상수들의 적절한 조합이 2개의 다중화기(514a,b)를 사용하여 선택된다. 특히, 시프터들의 출력들은 도 5b에 도시된 방식으로 2개의 다중화기(514a,b)에 입력들로서 공급되고, 0의 23-비 트 상수 값이 또한 각각의 다중화기(514a,b)에 입력으로서 공급된다. 그 후 각각의 다중화기(514a,b)는 특정 분수 상수 또는 0의 값 중 어느 하나를 출력한다. 이러한 방식으로, 다중화기들(514a,b)은 표 4로부터 선택된 특정 방정식(예컨대, 도 5a로부터의 로그 회로의 범위 선택 로직을 이용하여 결정된)에 따라, 시프터 들에 의해 생성된 각각의 분수 상수를 0개, 1개, 또는 2개 집합적으로 출력할 수 있다. 그 후 다중화기들(514a,b)의 출력들은 그들의 합을 계산하는 가산기에 입력들로서 공급된다. 가산기(51 6)로부터의 결과는 그 후 도 5b의 상수 생성 로직에 의해 출력되는 최종 상수 값으로서 역할한다. 도 5c는 표 4로부터의 선택된 방정식의 피연산자들에 대해 가산 및/또는 감산을 수행하기 위해 사용되는, 도 5a로부터의 로그 회로의 가산기/감산기 로직의 예시적인 구현을 예시한다. 예시된 실시예에서, 가산 기/감산기 로직은 2개의 가산기/감산기(522a,b) 및 2개의 OR 게이트(524a,b)를 포함하며, 이들은 아래에 더 설명된다. 제1 가산기/감산기(522a)에는 그의 피연산자들로서 로그 회로의 다중화기들(508b 및 508c)의 출력 및 가수 m이 공급된다. 더욱이, 가산기/감산기(522a)에 의해 이러한 피연산자들에 대해 수행되는 가산 및/또는 감산의 특정 조합은 OR 게이트(524a)에 의해 좌우된다. 예를 들어, OR 게이트(524a)에는 표 4로부터의 범위 11 및 15 에 대응하는 신호들이 입력으로서 제공되고(예컨대, 로그 회로의 범위 선택 로직에 의해 생성됨), OR 게이트(524a)의 출력은 그 후 가산기/감산기(522a)에 공급된다. 이러한 방식으로, OR 게이트(524a)의 출력이 0 일 때, 가산기/감산기(522a)는 모든 피연산자들을 함께 가산하지만, OR 게이트(524a)의 출력이 1일 때(예컨대, 가수 m은 11 또는 범위 15 범위 내에 있음), 가산기/감산기(522a)는 다중화기(508b)의 출력에 대응하는 피연산 자를 감산하고 나머지 피연산자들을 가산한다. 다시 말해서, 범위 11 및 15 이외의 표 4로부터의 m의 임의의 범위에 대해, 가산기/감산기(522a)는 m + 다중화기(508b)의 출력 + 다중화기(508c)의 출력의 결과를 출력하지만, 범위 및 15에 대해, 가산기/감산기(522a)는 m - 다중화기(508b)의 출력 + 다중화기(508c)의 출 력의 결과를 출력한다. 그 후 제2 가산기/감산기(522b)에는 그 각각의 피연산자들로서 제1 가산기/감산기(522a)의 출력 및 로그 회로 의 다중화기(508a)의 출력이 공급된다. OR 게이트(524b)의 출력은 가산기/감산기(522b)가 이러한 피연산 자들에 대해 가산을 수행하는지 또는 감산을 수행하는지를 좌우한다. 예를 들어, OR 게이트(524b)에는 표 4로 부터의 범위 7 - 15에 대응하는 신호들이 입력으로서 제공되고(예컨대, 로그 회로의 범위 선택 로직 에 의해 생성됨), OR 게이트(524b)의 출력은 그 후 가산기/감산기(522b)에 공급된다. 이러한 방식으로, OR 게 이트(524b)의 출력이 0일 때, 가산기/감산기(522b)는 양쪽 피연산자들을 함께 가산하지만, OR 게이트(524b)의 출력이 1일 때(예컨대, 가수 m은 범위 7 - 15 중 임의의 범위 내에 있음), 다중화기(508a)의 출력은 제1 가산기 /감산기(522a)의 출력으로부터 감산된다. 다시 말해서, m이 표 4로부터 범위 0 - 6 내에 있을 때, 가산기/감산 기(522b)는 제1 가산기/감산기(522a)의 출력 + 다중화기(508a)의 출력을 계산하지만, m이 범위 7 - 15 내에 있 을 때, 가산기/감산기(522b)는 제1 가산기/감산기(522a)의 출력 - 다중화기(508a)의 출력을 계산한다. 제2 가 산기/감산기(522b)로부터의 결과는 도 5c의 가산기/감산기 로직의 최종 출력으로서 역할한다. 로그 회로의 동작을 예시하기 위해, 프로세싱 흐름은 예시적인 입력에 대해 설명될 것이다. 입력 의 부호 및 지수 필드들은 그들의 기저의 값들에 관계없이 항상 동일한 방식으로 프로세싱되므로, 이 예는 입력의 가수 m과 연관된 프로세싱에 초점을 맞춘다. 이 예에서, 입력의 가수 m(input[22:0])은 표 4 의 범위 2에 대응하는 범위 0.125 ≤ m < 0.1875 내에 있는 것으로 가정된다. 따라서, 로그 회로는 표 4 로부터의 범위 2에 대해 대응하는 방정식을 실행할 것이고, 이는 이다. 로그 회로 는 위에 언급된 방정식에 대한 각각의 피연산자들을 생성 및/또는 획득하기 위해 원래의 입력을 프로 세싱함으로써 시작되고, 그 후 로그 회로는 그 피연산자들을 가산기/감산기에 공급하여 방정식의 결과를 계산한다. 입력의 가수 필드(input[22:0])에 대응하는 제1 피연산자 m은 입력의 관련 비트필드들로부터 가산기/ 감산기 로직으로 직접 공급된다. 위에 언급된 방정식에 대한 나머지 피연산자들은 다중화기들(508a-c)에 의해 가산기/감산기 로직에 공급된 다. 특히, 표 4로부터의 다양한 방정식들 전체에 걸쳐 나타나는 피연산자들의 컬렉션은 다중화기들(508a-c)에 입력들로서 공급되고, 다중화기들(508a-c)은 그 후 표 4로부터의 적절한 방정식에 의해 요구되는 특정 피연산자 들을 출력한다. 예를 들어, 가수 m의 4개의 최상위 비트에 기초하여, 범위 선택 로직은 m이 속하는 표 4 로부터의 특정 범위를 식별하는 신호를 출력하고, 그 범위 신호는 그 후 출력할 적절한 피연산자들을 선택하기 위해 다중화기들(508a-c)에 의해 사용된다. 이 예에서, m은 표 4로부터의 범위 2 내에 있으므로, 범위 선택 로 직은, range[2] 신호로서 달리 표시되는, 범위 2에 대응하는 범위 신호를 출력한다. range[2] 신호에 기 초하여, 다중화기(508a)는 그의 출력으로서 를 선택하고, 다중화기(508b)는 그의 출력으로 서 0을 선택하고, 다중화기(508c)는 그의 출력으로서 상수 생성 로직에 의해 생성된 상수를 선택한다. 도 5b의 상수 생성 로직으로 돌아가서, 예를 들어, range[2] 신호는 다중화기들(514a 및 514 b)이 그들 각각의 출력으로서 및 를 선택하게 하고, 그 값들은 그 후 가산기에 의해 함께 가산되고, 결과로서의 상수는 상수 생성 로직에 의해 출력된다. 따라서, 다중화기(508c)는 그의 출력으로서 상수를 선택하고, 이는 의 대응하는 값을 갖는다. 이러한 방식으로, 다음의 피연산자들이 결국 가산기/감산기에 공급된다: m (입력으로부터 직접 공급됨); (다중화기(508a)에 의해 공급됨); 0 (다중화기(508b)에 의해 공급됨); 및 (다중화기(508c)에 의해 공급됨); range[2] 신호는 가산기/감산기가 이러한 피연산자들 모두에 대해 가산을 수행하게 하고, 따라서 표 4로부 터의 범위 2에 대한 방정식인 방정식 의 결 과를 계산한다. 따라서, 결과 값은 로그 회로에 의해 생성된 출력에서의 23-비트 분수 필드 (output[22:0])로서 역할한다. 도 6a 내지 도 6c는 구분적 선형 근사를 이용하여 구현된 안티로그 회로의 예시적인 실시예들을 예시한다. 특히, 도 6a 및 6b는 전체 안티로그 회로의 대안 구현들을 예시하는 반면, 도 6c는 안티로그 회로의 기저의 가산기/감산기 로직을 예시한다. 안티로그 회로는 16-세그먼트 구분적 선형 근사를 이용하여 안티로그 계산들을 수행한다. 이러한 방식으 로, 안티로그 회로에 의해 룩업 테이블 또는 승산기 회로가 요구되지 않고, 안티로그 계산들은 단일 클록 사이클에서 수행될 수 있다. 안티로그 계산들을 위한 구분적 선형 근사를 수행하기 위해 안티로그 회로에 의해 이용되는 방정식들이 아래 표 5에 제시된다. 표 5의 방정식들은 2의 η 거듭제곱, 또는 2η과 등가인 η의 antilog2의 결과를 계산 또는 근사하도록 설계되고, 여기서 η은 고정 소수점 입력 수의 분수 부분(input[22:0])을 나타낸다. 예를 들어, 안티로그 회로의 고정 소수점 입력은 전형적으로 도 5a 내지 도 5c로부터의 로그 회로(들)의 고정 소수점 출력들에 대한 중간 DNN 계산들로부터 도출될 것이다. 더욱이, 위에서 논의된 바와 같이, 로그 회로(50 0)의 고정 소수점 출력의 분수 부분은 m=0일 때 정의되지 않은 결과를 회피하기 위해 log2(m)보다는 log2(1+m)로서 계산된다. 따라서, antilog2(η) = 2η를 계산하기 위한 표 5로부터의 방정식들은, 각각의 방정 식에서 +1의 상수 값에 의해 반영되는 바와 같이, 1+m과 등가인 값을 생성하도록 설계된다. 예를 들어, 16-세그먼트 구분적 선형 근사를 이용하여 antilog2(η) = 2η를 계산하기 위해, 구간 [0,1]에 걸친 η의 잠재적 값들은 범위들 0 - 15로서 지정되는 16개의 상이한 범위들 또는 세그먼트들로 분할되고, antilog2 (η) 또는 2η의 결과를 근사하기 위해 각각의 범위에 대해 개별 방정식들이 정의된다. 또한, 각각의 방정식들 은 다음의 타입의 피연산자들 중 임의의 것에 대한 가산 및/또는 감산을 이용하여 배타적으로 정의된다: η, 2 의 거듭제곱들로 나눈 η의 분수들, 및/또는 상수 값들. 이러한 방식으로, 방정식들에 의해 요구되는 유일한 제산은 배타적으로 2의 거듭제곱들에 의한 것이고, 따라서 모든 제산 연산들은 시프터들을 이용하여 구현될 수 있다. 또한, 제한된 \"시프트 기반\" 제산에 기인하는 정밀도의 손실은 특정 방정식들에서 가산 및/또는 감산되는 상수 값들의 사용을 통해 보상된다. 따라서, 각각의 방정식들은 가산, 감산, 및/또는 시프트 연산들을 이용 하여 배타적으로 구현될 수 있고, 따라서 복잡한 승산/제산 회로에 대한 필요성을 제거한다. 도 6a는 표 5의 방정식을 구현하도록 설계된 안티로그 회로의 전체 로직을 예시한다. 예시된 실시예에서, 안티로그 회로에는 32-비트 고정 소수점 수가 입력(예컨대, 입력 레지스터를 통해 공급됨)으로서 공 급되고, 안티로그 회로는 대응하는 32-비트 부동 소수점 수를 출력(예컨대, 출력 레지스터를 통해 반 환됨)으로서 계산하고, 이 출력은 입력의 antilog2 결과를 나타낸다. 입력은 부호 비트(input[31]), 8-비트 정수(input[30:23]), 및 23-비트 분수(input[22:0])를 포함한다. 입력의 부호가 항상 출력의 부호와 일치한다고 가정하면, 입력의 부호 비트(input[31])는 출력 의 대응 비트(output[31])로 직접 공급된다. 입력의 정수 부분(input[30:23])은 8-비트 가산기 로 공급되고, 이 가산기는 부동 소수점 출력의 지수 필드로서 역할하는 8-비트 바이어스된 지수를 생 성하기 위해 0x7F의 바이어스를 다시 가산한다. 더욱이, 표 5의 η의 값에 대응하는 입력의 분수 부분(input[22:0])은 부동 소수점 출력의 가수 (output[22:0])를 계산하는 데 사용될 표 5로부터의 대응하는 범위 및 방정식을 선택하는 데 사용된다. 예를 들어, 입력의 분수 부분의 4개의 최상위 비트(input[22:19])는 범위 선택 로직에 입력으로서 공급되 고, 이 범위 선택 로직은 표 5로부터의 η의 각각의 범위들에 대응하는 16개의 1-비트 신호(range[0] - range[15])를 출력하고, 따라서 적용가능한 범위에 대응하는 신호는 1로 설정되는 반면 나머지 신호들은 0으로 설정된다. 범위 선택 로직의 출력에 기초하여, 다중화기들(mux들)(608a-d)은 그 후 필요한 η의 분수들 및 분수 상수들과 같은 표 5로부터의 대응하는 방정식에 의해 요구되는 특정 피연산자들을 선택하는 데 사용된 다. 특히, 다중화기들(608a 및 608b)은 표 5로부터의 대응하는 방정식에 의해 요구되는 η의 분수들을 선택하는 데 사용된다. 예를 들어, η의 값(input[22:0])은 시프터들(606a)의 제1 컬렉션에 공급되고, 이 시프터들 각각은 표 5로부터의 방정식들 전체에 걸쳐 나타나는 2의 거듭제곱들에 대한 η의 다양한 분수들 을 계산하기 위해 특정 수의 비트만큼 η의 우측 시프트를 수 행한다. 이러한 시프터들(606a)의 출력들은 그 후 도 6a에 도시된 방식으로 다중화기들(608a 및 608b)에 입력 들로서 공급된다. 그 후 다중화기들(608a 및 608b)은 범위 선택 로직의 출력에 기초하여 결정되는 표 5로 부터의 대응하는 방정식에 의해 요구되는 η의 특정 분수들을 선택한다. 유사하게, 다중화기들(608c 및 608d)은 표 5로부터의 대응하는 방정식에 의해 요구되는 분수 상수들을 선택하는 데 사용된다. 예를 들어, 1의 값을 갖는 23-비트 상수가 시프터들(606b)의 제2 컬렉션에 공급되고, 이 시프터 들 각각은 표 5로부터의 방정식들 전체에 걸쳐 나타나는 각각의 분수 상수들 을 생성하기 위해 특정 수의 비트만큼 우측 시프트를 수행한다. 이러한 시프터들(606b)의 출력들은 그 후 도 6a에 도시된 방식으로 다중화기들(608c 및 608d)에 입 력들로서 공급된다. 그 후 다중화기들(608c 및 608d)은 범위 선택 로직의 출력에 기초하여 결정되는 표 5 로부터의 대응하는 방정식에 의해 요구되는 특정 상수 분수들을 선택한다. 표 5로부터의 대응하는 방정식에 대해 다중화기들(608a-d)에 의해 선택된 각각의 피연산자들은 그 후 가산기/감 산기에 입력들로서 공급된다. η의 값(input[22:0]) 및 1의 상수 값이 또한 가산기/감산기에 입력들 로서 공급되는데, 그 이유는 그 값들은 표 5로부터의 모든 방정식들에서 피연산자들이기 때문이다. 그 후 가산 기/감산기는, 표 5로부터의 대응하는 방정식에 의해 요구되는 바와 같이, 이러한 피연산자들에 대해 적절 한 가산 및/또는 감산 연산들을 수행한다(예컨대, 범위 선택 로직의 출력에 기초하여). 가산기/감산기 로부터의 결과는 그 후 안티로그 회로의 부동 소수점 출력의 23-비트 가수 부분(output[22:0]) 으로서 역할한다. 가산기/감산기의 구현은 도 6c와 관련하여 아래에 더 예시되고 설명된다. 도 6b는 구분적 선형 근사를 이용하여 구현된 안티로그 회로의 대안 구현을 예시한다. 특히, 도 6a의 안 티로그 회로는 입력으로서 고정 소수점 수의 안티로그를 계산하도록 설계되는 반면, 도 6b의 안티로그 회로는 입력으로서 고정 소수점 수 또는 부동 소수점 수 중 어느 하나의 안티로그를 계산할 수 있다. 이러한 방식으로, 도 6b의 안티로그 회로는 log2 도메인에서의 고정 소수점 수(예컨대, 도 5a 내지 도 5c로부터의 로그 회로의 출력으로부터 도출됨) 또는 그의 원래의 도메인에서의 부동 소수점 수 중 어느 하나의 antilog2를계산할 수 있다. 예를 들어, 도 4와 관련하여 설명된 바와 같이, 활성화 함수(AF) 회로는 다음 2가지 목 적을 위해 안티로그 회로들을 이용한다: log2 도메인에서의 고정 소수점 수들을 다시 원래의 도메인에서의 부동 소수점 수들로 변환하는 것; 베이스 2의 부동 소수점 지수 거듭제곱들을 계산하는 것. 따라서, AF 회 로의 안티로그 회로들의 피연산자들은 고정 소수점 수들(예컨대, log2 도메인 변환들을 위한) 및 부동 소 수점 수들(예컨대, 베이스 2의 거듭제곱들을 위한) 양쪽 모두를 포함한다. 따라서, AF 회로의 안티로그 회로들은 고정 소수점 또는 부동 소수점 수로서 표현되는 입력을 프로세싱할 수 있는 도 6b의 안티로그 회로를 이용하여 구현될 수 있다. 도 6b의 안티로그 회로의 동작은, 아래에 더 설명되는 바와 같이, 입력의 정수 또는 지수 필드 (input[30:23])를 어떻게 프로세싱하는지를 제외하고는 도 6a의 것과 유사하다. 특히, 입력이 고정 소수점 수이면, 그것은 정수 필드(input[30:23])를 포함할 것이고, 이것은 다중화기 에 입력들 중 하나로서 공급된다. 다중화기의 선택 신호는 입력이 고정 소수점 수인지를 나타 내는 2진 신호이다. 따라서, 다중화기의 선택 신호는 입력이 고정 소수점 수일 때 1의 값을 가질 것 이고, 이는 다중화기가 입력의 정수 부분(input[30:23])을 그의 출력으로서 선택하게 하고, 이것은 그 후 8-비트 가산기에 피연산자로서 공급된다. 그 후 가산기는 8-비트 바이어스된 지수를 생성하기 위해 입력의 정수 부분(input[30:23])에 0x7F의 바이어스를 다시 가산하고, 8-비트 바이어스된 지수는 그 후 부동 소수점 출력의 지수 부분으로서 역할한다. 대안적으로, 입력이 부동 소수점 수이면, 그것은 지수 필드(input[30:23])를 포함할 것이다. 지수 필드 (input[30:23])는 8-비트 감산기에 공급되고, 이 감산기는 지수의 log2 값을 수학적으로 표현하는 대응하 는 8-비트 바이어스되지 않은 지수를 생성하기 위해 0x7F의 바이어스를 감산한다. 감산기의 출력은 그 후 시프터로 공급되고, 이 시프터는 대응하는 antilog2 값을 계산하기 위해 만큼 좌측 시프트를 수행하고, 대응하는 antilog2 값은 그 후 다중화기에 입력들 중 하나로서 공급된다. 다중화기 의 선택 신호는 입력이 부동 소수점 수일 때 0의 값을 가질 것이고, 이는 다중화기가 그의 출력 으로서 시프터로부터의 값을 선택하게 한다. 그 후 다중화기의 출력은 8-비트 가산기에 피연산 자로서 공급되고, 이 가산기는 8-비트 바이어스된 지수를 생성하기 위해 0x7F의 바이어스를 다시 가산하고, 8- 비트 바이어스된 지수는 그 후 부동 소수점 출력의 지수 부분으로서 역할한다. 도 6c는 표 5로부터의 대응하는 방정식의 피연산자들에 대해 가산 및/또는 감산을 수행하기 위해 사용되는, 도 6a 및 도 6b의 안티로그 회로의 가산기/감산기 로직의 예시적인 구현을 예시한다. 예시된 실시예에 서, 가산기/감산기 로직은 3개의 가산기/감산기(622a-c) 및 3개의 OR 게이트(624a 내지 624c)를 포함하며, 이들은 아래에 더 설명된다. 제1 가산기/감산기(622a)에는 다음의 피연산자들이 입력으로서 공급된다: η의 값(input[22:0]), 1의 상수 값, 및 다중화기(608a)의 출력. 이러한 피연산자들에 대해 수행되는 가산 및/또는 감산의 특정 조합은 OR 게이트 (624a)에 의해 좌우되고, 이 OR 게이트에는 range[0] - range[7]에 대한 신호들이 입력으로서 공급된다. 이러 한 방식으로, η가 표 5로부터의 범위 0 - 7 내에 있을 때, OR 게이트(624a)의 출력은 1일 것이고, 이는 가산기 /감산기(622a)가: η + 1 - 다중화기(608a)의 출력을 계산하게 한다. 대안적으로, η가 범위 8 - 15 내에 있을 때, OR 게이트(624a)의 출력은 0일 것이고, 이는 가산기/감산기(622a)가: η + 1 + 다중화기(608a)의 출력을 계 산하게 한다. 제2 가산기/감산기(622b)에는 다음의 피연산자들이 입력으로서 공급된다: 다중화기(608c)의 출력 및 다중화기 (608d)의 출력. 이러한 피연산자들에 대해 수행되는 가산 및/또는 감산의 특정 조합은 OR 게이트(624b)에 의해 좌우되고, 이 OR 게이트에는 range[4], range[8], range[9], range[11], 및 range[12]에 대한 신호들이 입력으 로서 공급된다. 이러한 방식으로, η가 표 5로부터의 범위 4, 8, 9, 11, 또는 12 내에 있을 때, OR 게이트 (624a)의 출력은 1일 것이고, 이는 가산기/감산기(622b)가: 다중화기(608d)의 출력 - 다중화기(608c) 출력의 계 산하게 한다. 대안적으로, η가 표 5로부터의 나머지 범위들 중 임의의 범위 내에 있을 때, OR 게이트(624a)의 출력은 0일 것이고, 이는 가산기/감산기(622b)가: 다중화기(608d)의 출력 + 다중화기(608c)의 출력을 계산하게 한다. 제3 가산기/감산기(622c)에는 입력으로서 다음의 피연산자들이 공급된다: 가산기/감산기(622a)의 출력, 가산기/ 감산기(622b)의 출력, 및 다중화기(608b)의 출력. 이러한 피연산자들에 대해 수행되는 가산 및/또는 감산의 특정 조합은 OR 게이트(624c)에 의해 좌우되고, 이 OR 게이트에는 range[2], range[10], range[11], range[14], 및 range[15]에 대한 신호들의 역 또는 NOT 값이 입력으로서 공급된다. 이러한 방식으로, η가 범위 2, 10, 11, 14, 및 15 이외의 표 5로부터의 임의의 범위 내에 있을 때, OR 게이트(624c)의 출력은 1일 것이고, 이는 가 산기/감산기(622c)가: 가산기/감산기(622a)의 출력 - 가산기/감산기(622b) 출력 - 다중화기(608b)의 출력을 계 산하게 한다. 대안적으로, η가 표 5로부터의 범위 2, 10, 11, 14, 또는 15 내에 있을 때, OR 게이트(624c)의 출력은 0일 것이고, 이는 가산기/감산기(622c)가: 가산기/감산기(622a)의 출력 - 가산기/감산기(622b)의 출력 + 다중화기(608b)의 출력을 계산하게 한다. 제3 가산기/감산기(622c)로부터의 결과는 도 6c의 가산기/감산기 로직의 최종 출력으로서 역할한다. 도 7은 구분적 선형 근사를 이용하여 구현된 지수 회로의 예시적인 실시예를 예시한다. 특히, 지수 회로 는 16-세그먼트 구분적 선형 근사를 이용하여 지수 계산들을 수행한다. 이러한 방식으로, 지수 회로(70 0)는 룩업 테이블을 요구하지 않고 하나의 승산기만을 요구하고, 지수 계산들은 2개의 클록 사이클에서 수행될 수 있다. 지수 계산들을 위한 구분적 선형 근사를 수행하기 위해 지수 회로에 의해 이용되는 방정식들이 아래 표 6 에 제시된다."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 23, "content": "표 6의 방정식들은 자연 지수 함수 의 결과를 계산 또는 근사하도록 설계되고, 여기서 e는 자연 지수 상수 (예컨대, 오일러의 수)를 나타내고 x는 32-비트 부동 소수점 입력 의 23-비트 가수(input[22:0])를 나타낸 다. 16-세그먼트 구분적 선형 근사를 이용하여 을 계산하기 위해, 예를 들어, 구간 [0,1]에 걸친 x의 잠재 적 값들은 범위들 0 - 15로서 지정되는 16개의 상이한 범위들 또는 세그먼트들로 분할되고, 의 결과를 근사 하기 위해 각각의 범위에 대해 개별 방정식들이 정의된다. 또한, 각각의 방정식들은 다음의 타입의 피연산자들 중 임의의 것에 대한 가산 및/또는 감산을 이용하여 배타적으로 정의된다: x, 2x, 2의 거듭제곱들로 나눈 x의 분수들, 및/또는 상수 값들. 이러한 방식으로, 방정식들에 의해 요구되는 유일한 제산은 배타적으로 2의 거듭 제곱들에 의한 것이고, 따라서 모든 제산 연산들은 시프터들을 이용하여 구현될 수 있다. 또한, 제한된 \"시프 트 기반\" 제산에 기인하는 정밀도의 손실은 특정 방정식들에서 가산 및/또는 감산되는 상수 값들의 사용을 통해 보상된다. 따라서, 에 대한 각각의 방정식들은 가산, 감산, 및/또는 시프트 연산들을 이용하여 배타적으로 구현될 수 있다. 그 후 지수 연산을 완료하기 위해, e의 입력의 가수 부분(input[22:0]) 거듭제곱을 나타내는 의 결과 값이 e의 입력의 지수 부분(input[30:23]) 거듭제곱의 값과 곱해져야 한다. 따라서, 지수 연산을 위해 하 나의 승산 연산만이 요구되고, 따라서 지수 회로는 단일 승산기 회로만을 요구한다. 지수 회로의 전체 로직은 도 7에 예시되어 있다. 예시된 실시예에서, 지수 회로에는 32-비트 부동 소수점 수가 입력으로서 공급되고, 지수 회로는 자연 지수 상수 e의 입력에 의해 표현된 부동 소수점 수 거듭제곱, 또는 에 대응하는 출력으로서 대응하는 32-비트 고정 소수점 수를 계산한다. 부동 소수점 입력은 부호 비트(input[31]), 8-비트 지수(input[30:23]), 및 23-비트 가수(input[22:0])를 포함한다. 입력의 부호가 항상 출력의 부호와 일치한다고 가정하면, 입력의 부호 비트 (input[31])는 출력의 대응 비트(output[31])로 직접 공급된다. 입력의 지수 부분(input[30:23])은 8-비트 감산기로 공급되고, 이 감산기는 8-비트 바이어스되지 않 은 지수를 생성하기 위해 0x7F의 바이어스를 감산한다. 그 후 자연 지수 상수 e의 바이어스되지 않은 지수 거 듭제곱, 또는 의 값이 다중화기)에 의해 출력된다. 예를 들어, 8-비트 바이어스되 지 않은 지수는 -128 내지 +127의 범위에 있는, 28=256개의 잠재적 값을 갖는다. e의 바이어스되지 않은 지수 의 모든 256개의 잠재적 값 거듭제곱의 값들은 미리 계산 되어 다중화기에 상수 입력들로서 공급된다. 감산기에 의해 출력되는 8-비트 바이어스되지 않은 지 수는 다중화기의 선택 신호로서 역할하고, 이것은 다중화기가 에 대응하는 미 리 계산된 상수 입력을 선택하게 한다. 그 후 다중화기의 출력 은, 아래에 더 논 의되는 바와 같이, 승산기로 그의 피연산자들 중 하나로서 공급된다. 입력의 가수 부분(input[22:0])은 표 6으로부터의 방정식들에 따라 프로세싱된다. 예를 들어, 지수 회로 는 자연 지수 상수 e의 가수(input[22:0]) 거듭제곱, 또는 를 계산하도록 설계되고, 여기서 x는 가수 (input[22:0])를 나타낸다. 더욱이, 지수 회로는 표 6으로부터의 방정식들에 기초하여 구분적 선형 근사 를 이용하여 를 계산한다. 특히, 입력의 가수 부분(input[22:0])(표 6의 x의 값에 대응함)은 의 값을 계산하는 데 사용될 표 6으로부터의 대응하는 범위 및 방정식을 선택하는 데 사용된다. 예를 들어, 입력 의 가수 부분의 4개의 최상위 비트(input[22:19])는 범위 선택 로직에 입력으로서 공급되고, 이 범위 선택 로직은 표 6으로부터의 x의 각각의 범위들에 대응하는 16개의 1-비트 신호(range[0] - range[15])를 출력 하고, 따라서 적용가능한 범위에 대응하는 신호는 1로 설정되는 반면 나머지 신호들은 0으로 설정된다. 범위 선택 로직의 출력에 기초하여, 다중화기들(mux들)(708a-d)은 그 후 방정식에서 나타나는 필요한 x의 분수 들 및 상수 값들과 같은 표 6으로부터의 대응하는 방정식에 의해 요구되는 특정 피연산자들을 선택하는 데 사용 된다. 예를 들어, 다중화기들(708a 및 708b)은 표 6으로부터의 대응하는 방정식에 의해 요구되는 x의 분수들을 선택하 는 데 사용된다. 예를 들어, x의 값(input[22:0])은 시프터들(706a)의 제1 컬렉션에 공급되고, 이 시프터들 각 각은 표 6로부터의 방정식들 전체에 걸쳐 나타나는 2의 거듭제곱들에 대한 x의 다양한 분수들 을 계산하기 위해 특정 수의 비트만큼 x의 우측 시프트를 수행한다. 이러한 시프터들(706a)의 출력은 그 후 도 7에 도시된 방식으로 다중화기들(708a 및 708b)에 입력들로서 공급된 다. 그 후 다중화기들(708a 및 708b)은 범위 선택 로직의 출력에 기초하여 결정되는 표 6으로부터의 대응 하는 방정식에 의해 요구되는 x의 특정 분수들을 선택한다. 유사하게, 다중화기들(708c 및 708d)은 특정 방정식들에 의해 요구되는 분수 상수들 및/또는 1의 상수 값과 같 은, 표 6으로부터의 대응하는 방정식에 의해 요구되는 상수 값들을 선택하는 데 사용된다. 예를 들어, 1의 값 을 갖는 23-비트 상수가 시프터들(706b)의 제2 컬렉션에 공급되고, 이 시프터들 각각은 표 6로부터의 방정식들 전체에 걸쳐 나타나는 각각의 분수 상수들 을 생성하기 위해 특 정 수의 비트만큼 우측 시프트를 수행한다. 이러한 시프터(706b)의 출력은 그 후 도 7에 도시된 방식으로 다중 화기들(708c 및 708d)에 입력들로서 공급된다. 또한, (표 6으로부터의 특정 방정식들에 의해 요구되는) 1의 상 수 값이 또한 다중화기(708d)에 입력들 중 하나로서 공급된다. 그 후 다중화기들(708c 및 708d)은 범위 선택 로직의 출력에 기초하여 결정되는 표 6으로부터의 대응하는 방정식에 의해 요구되는 상수들의 특정 조합을 선택한다. 표 6으로부터의 대응하는 방정식에 대해 다중화기들(708a 내지 708d)에 의해 선택된 각각의 피연산자들은 그 후 가산기/감산기에 입력들로서 공급된다. 표 6으로부터의 대응하는 방정식이 x의 피연산자를 요구하는지 또 는 2x의 피연산자를 요구하는지에 따라, 가산기/감산기에 그의 입력들 중 어느 하나 또는 2개를 통해 x의 값(input[22:0])이 또한 공급된다. 예를 들어, x의 값은 항상 가산기/감산기의 입력들 중 하나로서 직접 공급되고, 일부 경우들에서, 그것은 또한 가산기/감산기의 다른 입력으로서 다중화기를 통해 공급될 수 있다. 특히, x의 값 및 0의 23-비트 상수가 다중화기에 입력들로서 공급되고, 다중화기는 그 값 들 중 하나를 가산기/감산기에 입력으로서 공급하기 위해 선택한다. 예를 들어, 표 6으로부터의 대응하는 방정식이 2x보다는 x를 피연산자로서 요구하면, 다중화기는 가산기/감산기로의 그의 출력으로서 0의 상수를 선택하는데, 그 이유는 x의 값은 이미 가산기/감산기의 다른 입력을 통해 직접 공급되었기 때문이 다. 대안적으로, 표 6으로부터의 대응하는 방정식이 x보다는 2x를 피연산자로서 요구하면, 다중화기는 가 산기/감산기로의 그의 출력으로서 x의 값을 선택하는데, 그 이유는 그 결과 x의 값이 가산기/감산기 에 2개의 입력을 통해 공급되기 때문이다. 그 후 가산기/감산기는, 표 6로부터의 대응하는 방정식에 의해 요구되는 바와 같이, 이러한 피연산자들에 대해 적절한 가산 및/또는 감산 연산들을 수행한다(예컨대, 범위 선택 로직의 출력에 기초하여). 이러한 방식으로, 가산기/감산기의 출력은 자연 지수 상수 e의 입력의 가수(input[22:0]) 거듭제곱과 등가인, 에 대한 최종 결과에 대응한다. 그 후 다중화기의 출력(e의 입력의 바이어스되지 않은 지수 거듭제곱), 및 가산기/감산기의 출 력(e의 입력의 가수 거듭제곱)은 승산기에 피연산자들로서 공급되고, 승산기는 지수 회로의 고 정 소수점 출력의 정수 및 분수 부분들을 생성하기 위해 그 값들을 함께 승산한다. 도 8은 인공 뉴럴 네트워크(예컨대, 심층 뉴럴 네트워크(DNN))을 구현하는 데 사용되는 예시적인 프로세싱 아키 텍처에 대한 흐름도 800을 예시한다. 흐름도는, 예를 들어, 본 개시내용 전체에 걸쳐 설명된 실시예들 및 기능성을 이용하여 구현될 수 있다. 예를 들어, 일부 실시예들에서, 흐름도는 도 2a 및 도 2b 또는 도 4 의 활성화 회로, 도 5a 내지 도 5c의 로그 회로, 도 6a 내지 도 6c의 안티로그 회로, 및/또는 도 7의 지수 회로 를 이용하여 구현될 수 있다. 예시된 흐름도에서는, 활성화 함수들의 성능을 가속화하도록 설계된 활성화 함수 회로에 의해 특정한 활성화 함 수가 수행된다. 일부 실시예들에서, 예를 들어, 활성화 함수 회로는 인공 또는 심층 뉴럴 네트워크를 구현하기 위해 일반적으로 사용되는 다수의 타입의 활성화 함수들을 지원하도록 설계될 수 있다. 더욱이, 활성화 함수 회로는 지원되는 활성화 함수들과 연관된 계산들을 가속화하기 위해 구분적 선형 근사를 이용하여 구현된 로그, 안티로그, 및/또는 지수 회로들을 활용할 수 있다.일부 실시예들에서, 예를 들어, 활성화 함수 회로는 인공 뉴럴 네트워크(예컨대, 심층 뉴럴 네트워크, 컨볼루션 뉴럴 네트워크, 피드포워드 뉴럴 네트워크, 반복 뉴럴 네트워크 등)를 갖는 애플리케이션들을 실행하는 프로세 서, 디바이스, 및/또는 시스템 상에 구현되고/되거나 이와 관련하여 사용될 수 있다. 이러한 방식으로, 애플리 케이션들은 인공 뉴럴 네트워크를 구현하기 위해 사용되는 활성화 함수들을 가속화하기 위해 활성화 함수 회로 를 활용할 수 있다. 예를 들어, 인공 뉴럴 네트워크를 갖는 애플리케이션이 메모리에 저장되고 특정 디바이스 또는 시스템 상의 프로세서에 의해 실행될 수 있다. 애플리케이션이 인공 뉴럴 네트워크에서의 연산과 관련하 여 활성화 함수를 수행할 필요가 있을 때, 애플리케이션은 대응하는 명령어 또는 커맨드를 프로세서 및/또는 활 성화 함수 회로에 발행할 수 있고, 그 후 프로세서는 활성화 함수를 수행하기 위해 활성화 함수 회로를 활용할 수 있다. 그 후 활성화 함수의 결과가 프로세서 및/또는 애플리케이션에 다시 제공되고, 후속하여 인공 뉴럴 네트워크에 의해 사용될 수 있다. 흐름도는 블록 802에서 시작되고, 여기서 특정 활성화 함수를 수행하기 위한 명령 또는 커맨드가 수신된다. 명 령 또는 커맨드는, 예를 들어, 애플리케이션에 의해 발행되고 프로세서 및/또는 활성화 함수 회로에 의해 수신 될 수 있다. 일부 실시예들에서, 명령 또는 커맨드는 원하는 활성화 함수, 및 그 활성화 함수와 연관된 임의의 피연산자들 또는 다른 파라미터들을 식별할 수 있다. 또한, 일부 경우들에서, 선택된 활성화 함수는 지수, 승산, 및/또는 제산 연산들의 조합을 포함할 수 있다. 따 라서, 흐름도는 먼저 블록 804로 진행하여, 활성화 함수와 연관된 임의의 지수 연산들을 수행한다. 일부 실시 예들에서, 예를 들어, 지수 연산들은 그 연산들과 연관된 레이턴시를 감소시키기 위해 구분적 선형 근사를 이용 하여 수행될 수 있다(예컨대, 도 7의 지수 회로를 이용하여). 그러나, 일부 실시예들에서, 지수 연산이 2의 베 이스를 포함하면, 그것은 레이턴시를 감소시키기 위해 지수 회로 대신에 안티로그 회로를 이용하여(안티로그 베 이스 2 연산을 이용하여) 계산될 수 있다. 그 후 흐름도는 블록 806으로 진행하여, 활성화 함수와 연관된 임의의 승산 및/또는 제산 연산들을 수행한다. 일부 실시예들에서, 예를 들어, 활성화 함수의 승산 및/또는 제산 연산들은 로그, 안티로그, 및 가산/감산 연산 들의 조합을 이용하여 수행될 수 있다. 예를 들어, 로그 및 안티로그 연산들은, 로그 함수들의 속성들을 활용 함으로써, 비싼 승산/제산 연산들을 가산 및/또는 감산으로 변환하는 데 사용될 수 있다. 또한, 로그 및 안티 로그 연산들은 그 연산들과 연관된 레이턴시를 감소시키기 위해 구분적 선형 근사를 이용하여 수행될 수 있다. 일부 실시예들에서, 예를 들어, 구분적 선형 근사를 이용하여 로그 연산들을 수행하기 위해 로그 회로가 사용될 수 있다(예컨대, 도 5a 내지 도 5c의 로그 회로). 예를 들어, 로그 회로는 부동 소수점 수로서(예컨대, 지수 및 가수로) 표현되는 입력의 로그를 계산하도록 설계될 수 있고, 로그 회로는 결과로서의 출력을 고정 소수점 수로서(예컨대, 정수 및 분수로) 표현할 수 있다. 로그 회로는 먼저 로그 연산과 연관된 입력 또는 피연산자를 식별하고, 그 후 그것은 구분적 선형 근사를 위해 입력이 속하는 특정 범위를 식별 또는 결정한다. 예를 들어, 구분적 선형 근사를 이용하여 로그 연산들을 수행하기 위해, 연관된 방정식들과 함께, 복수의 범위 또는 세그먼 트가 정의된다. 따라서, 입력이 속하는 대응 범위가 식별되고, 그 범위에 대한 방정식에 의해 요구되는 피연산 자들이 획득 및/또는 생성된다. 일부 실시예들에서, 예를 들어, 시프트 회로들을 이용하여 생성될 수 있는(예 컨대, 제산 연산을 수행하기 위해 비트들을 시프트시킴으로써), 2의 거듭제곱들인 분모들을 갖는 분수 피연산자 들뿐만 아니라, 입력의 가수와 같은 입력을 이용하여 특정 피연산자들이 추출, 획득, 및/또는 계산될 수 있다. 그 후 하나 이상의 다중화기를 이용하여 적절한 피연산자들이 선택되고, 선택된 피연산자들을 이용하여 방정식 의 결과가 계산된다. 예를 들어, 결과는 가산기-감산기 회로를 이용하여 각각의 피연산자들에 대해 가산 및/또 는 감산을 수행함으로써 계산될 수 있다. 더욱이, 부동 소수점 입력의 지수는 감산기 회로를 이용하여 바이어 스를 감산함으로써 바이어스되지 않은 지수로 변환될 수 있다. 그 후 로그 연산의 출력은 대응하는 방정식 및 바이어스되지 않은 지수로부터의 결과를 이용하여 생성된다. 예를 들어, 바이어스되지 않은 지수는 결과로서의 고정 소수점 출력의 정수로서 역할하고, 방정식의 결과는 고정 소수점 출력의 분수로서 역할한다. 유사하게, 구분적 선형 근사를 이용하여 안티로그 연산들을 수행하기 위해 안티로그 회로가 사용될 수 있다(예 컨대, 도 6a 내지 도 6c의 안티로그 회로). 안티로그 연산들은 정수/지수 부분에 대한 상이한 계산들 및 구분 적 선형 근사에 대한 상이한 방정식들을 사용하는 것을 제외하고는, 유사한 방식으로 구현될 수 있다. 그 후 흐름도는 블록 808로 진행하여 지수, 승산, 및/또는 제산 연산들의 결과에 기초하여 활성화 함수의 결과 를 출력한다. 이 시점에서, 흐름도가 완료될 수 있다. 그러나, 일부 실시예들에서, 흐름도는 재시작될 수도 있고/있거나 특 정 블록들이 반복될 수도 있다. 예를 들어, 일부 실시예들에서, 흐름도는 블록 802에서 재시작되어 활성화 함수들을 계속 수행할 수 있다. DNN 성능 도 9a 및 도 9b는 지원되는 병렬 연산의 수에 관하여 설명된 실시예들의 확장성을 예시한다. 특히, 설명된 실 시예들은 지원되는 병렬 연산의 수를 증가시키기 위해 기저의 하드웨어가 복제될 수 있게 하는 유연한 설계를 이용하여 구현된다. 이러한 방식으로, 설명된 실시예들은 특정 애플리케이션 또는 사용 사례에 의해 요구되는 병렬 연산의 수를 지원하기 위해 필요에 따라 스케일링될 수 있다. 예를 들어, 도 9a 및 도 9b에 도시된 바와 같이, 제안된 솔루션은 그것을 단일 피연산자로부터 n개의 피연산자로 스케일링하기 위해 단순히 복제될 수 있 다. 특히, 도 9a는 단일 피연산자에 대한 제안된 솔루션을 예시하는 반면, 도 9b는 n개의 피연산자에 대한 동 일한 것을 예시한다. 또한, 제안된 솔루션은 레이턴시를 감소시키고 스루풋을 개선하기 위해 파이프라인될 수 있다. 도 10a는 정밀도에 관하여 설명된 실시예들의 확장성을 예시한다. 특히, 설명된 실시예들은 로그, 안티로그, 및/또는 지수 회로들에 의해 구현되는 구분적 선형 근사 모델들 내의 세그먼트의 수를 단순히 조정함으로써 다 양한 레벨의 정밀도를 제공하도록 스케일링될 수 있다. 이러한 방식으로, 설명된 실시예들은 상이한 애플리케 이션들 및 사용 사례들에 대해 요구되는 정밀도의 레벨을 제공하기 위해 필요에 따라 스케일링될 수 있다. 예 를 들어, 애플리케이션이 더 큰 정밀도를 요구하는 경우, 구분적 선형 근사 모델들에 수반되는 세그먼트의 수는 더 높은 정밀도 요건들에 부합하기 위해 증가될 수 있다. 다양한 레벨의 정밀도에 대해 구분적 선형 근사 모델에서 요구되는 세그먼트의 수가 도 10a에 도시되어 있다. 도 10a에 도시된 바와 같이, 예를 들어, 애플리케이션이 23-비트 가수로부터 23-비트 정밀도를 요구하는 경우, 구분적 선형 근사 모델은 적어도 1,556개의 세그먼트를 이용하여 구현되어야 한다. 구분적 선형 근사를 위해 사용되는 세그먼트의 수는 임의의 필요한 레벨의 정밀도를 제공하기 위해 유사한 방식으로 조정될 수 있다. 도 10b는 로그 및 안티로그 하드웨어의 다양한 구현에 대한 실리콘 영역 요건들을 비교한다. 특히, 도 10b는 (10-비트 또는 12-비트 정밀도를 갖는) 구분적 선형 근사(PLA)를 이용하여 구현된 로그 및 안티로그 회로들 대 비 (12-비트 정밀도를 갖는) 룩업 테이블 방법을 이용하여 구현된 솔루션에서의 합성 게이트의 수를 예시한다. 도 10b에 도시된 바와 같이, 구분적 선형 근사를 이용하여 구현된 로그 및 안티로그 회로들은 룩업 테이블 방법 을 이용하여 구현된 솔루션보다 현저히 더 적은 수의 게이트를 사용한다. 예를 들어, 룩업 테이블 솔루션은 12-비트 정밀도를 위해 8,800개의 게이트를 사용하는 반면, 구분적 선형 근사(PLA) 로그 및 안티로그 회로들은 각각 10-비트 정밀도를 위해 350개 및 450개의 게이트를 사용하고, 12-비트 정밀도를 위해 1,048개 및 1,348개 의 게이트를 사용한다. 도 10c는 (10-비트 정밀도를 갖는) 활성화 함수 하드웨어의 다양한 구현들에 대한 실리콘 영역 요건들을 비교한 다. 특히, 도 10c는 다수의 활성화 함수들을 지원하는 통일된 활성화 함수 회로에 대한 합성 게이트의 수 대비 룩업 테이블들(LUT들)을 이용하여 구현된 다양한 개별 활성화 함수들(예컨대, Sigmoid, 쌍곡선 탄젠트(Tanh), 및 Swish)에 대한 합성 게이트의 수를 예시하고 구분적 선형 근사(PLA)(예컨대, 도 2a 및 도 2b의 활성화 함수 회로)를 이용하여 구현된다. 도 10c에 도시된 바와 같이, 예를 들어, 통일된 회로는 LUT 기반 회로들 중 어느 하나보다 현저히 더 적은 수의 게이트를 사용함에도 불구하고, 그것은 다수의 활성화 함수들을 지원한다. 예를 들어, 통일된 회로는 총 8,321개의 합성 게이트를 이용하여 구현될 수 있는데, 그 이유는 그의 단순화된 방정식들이 지수, 로그, 및 안티로그 블록들이 각각 단지 4,387개, 1,048개, 및 1,348개의 합성 게이트를 이용 하여 구현될 수 있게 하기 때문이다. 비교에 의해, 각각의 LUT 기반 회로는 단일 활성화 함수만을 위해 대략 17,000 - 18,000개의 합성 게이트를 요구한다. 도 10d는 구분적 선형 근사(예컨대, 도 5a 내지 도 5c 및 도 6a 내지 도 6c)를 이용하여 구현된 로그 및 안티로 그 회로들에 대한 근사 오차를 예시하는 반면, 도 10e는 구분적 선형 근사(예컨대, 도 7)를 이용하여 구현된 지 수 회로에 대한 근사 오차를 예시한다. 특히, 이러한 회로들은 각각의 log2, 및 antilog2, 및 지수 계산들에 대 해 0.045%의 절대 오차(ABS)로 구현될 수 있고, 이는 IEEE-754 단정밀도 부동 소수점 수(예컨대, 1개의 부호 비 트 + 8개의 지수 비트+ 12-비트 가수 = 21-비트 정밀도)에 대한 가수에서의 12-비트 정밀도로 전환된다. 로그, 안티로그, 및 지수 회로들을 이용하여 구현된 통일된 활성화 함수 회로(예컨대, 도 2a 및 도 2b의 AF 회 로)의 전체 정밀도는 IEEE-754 단정밀도 부동 소수점 수(예컨대, 1개의 부호 비트 + 8개의 지수 비트 + 10-비트 가수 = 19 비트 정밀도)에 대한 10개의 가수 비트이다. 도 11a 내지 도 11c는 (베이스 2의 거듭제곱들을 이용한) 수정된 활성화 함수 방정식들 대비 (지수 상수 e의 거 듭제곱들을 이용한) 종래의 활성화 함수 방정식들을 이용하여 구현된 심층 뉴럴 네트워크들(DNN들)의 성능 비교 를 예시한다. 예를 들어, 위에서 논의된 바와 같이, 도 2a 및 도 2b의 AF 회로 및 도 4의 AF 회로는 양쪽 모두 활성화 함수들을 구현하기 위해 구분적 선형 근사를 활용한다. 그러나, AF 회로는 종래의 활성 화 함수들을 구현하는 반면, AF 회로는 지수 상수 e의 거듭제곱들 대신에 2의 거듭제곱들을 사용하는 수정 된 활성화 함수들을 구현한다. 이러한 각각의 접근법들의 성능은 도 11a 내지 도 11c에 예시된 예에서 비교된 다. 도 11a는 2개의 입력 뉴런을 갖는 입력 층, 3개의 뉴런을 갖는 단일의 은닉 층, 및 하나의 출력 뉴런을 갖는 완 전히 연결된 층을 포함하는 예시적인 DNN을 예시한다. 단순화를 위해, DNN은 XOR 게이트의 동일한 거동을 갖는 표 7에 도시된 특징 매핑을 구현한다."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 24, "content": "예시된 예는 이러한 특징 세트들 중 하나, 즉 A = 1 및 B = 1에 초점을 맞추고, 이는 0의 출력을 가질 것으로 예상된다. 예시된 예에서, 입력 뉴런 X1은 특징 A에 대응하고, 입력 뉴런 X2는 특징 B에 대응한다. 도 11b는 DNN이 종래의 Sigmoid 활성화 함수: 를 이용하여 구현될 때 수행되는 프로 세싱을 예시한다. 순방향 전파 스테이지 동안, 가중치들은 다음과 같이 랜덤하게 선택된다: W11 = 0.8, W12 = 0.4, W13 = 0.3, W21 = 0.2, W22 = 0.9, WW23 = 0.5, Wh1 = 0.3, Wh2 = 0.5, 및 Wh3 = 0.9. 그 후 은닉 층 노드들(H)의 출력이 다음과 같이 계산된다: H1 = X1*W11 + X2*W21 = 0.8 + 0.2 = 1; H2 = X1*W12 + X2*W22 = 0.4 + 0.9 = 1.3; H3 = X1*W13 + X2*W23 = 0.3 + 0.5 = 0.8. 단순화를 위해 예시된 예에서는 0의 바이어스가 취해진다. Sigmoid 활성화 함수를 적용한 후, 업데이트된 은닉 층 뉴런들은 다음의 값들을 갖는다: H1 = 0.7310; H2 = 0.7858; H3 = 0.6899. 그 후 완전히 연결된(FC) 층이 다음과 같이 계산될 수 있다: FC = H1*Wh1 + H2*Wh2 + H3*Wh3 = 0.7310*0.3 + 0.7858*0.5 + 0.6899*0.9 = 1.235. Sigmoid 활성화 함수를 완전히 연결된 층에 적용한 후에, FC = 0.7746이다. 그 후 오차가 다음과 같이 계산된다: 오차 = 예상 - 계산 = 0 - 0.7746 = -0.7746. 역방향 전파 및 가중치 업데이트 스테이지 동안, Sigmoid 활성화 함수의 도함수 가 사 용되고, 다음의 계산들이 수행된다: ΔFC= f'(활성화 함수가 없는 FC 값) * 오차 = f'(1.235)*(-0.7746) = -0.13439; ΔFC = 은닉 층 뉴런 * 은닉 층 가중치 = H1*Wh1 + H2*Wh2 + H3*Wh3; ΔWh1 = ΔFC/H1 = -0.13439/0.7310 = -0.1838; ΔWh2 = ΔFC/H2 = -0.13439/0.7858 = -0.1710; ΔWh3 = ΔFC/H3 = -0.13439/0.6899 = -0.1920. 그 후 ΔH1, ΔH2, 및 ΔH3에 관하여 다음의 계산이 수행된다: 새로운 은닉 층 값들 = ΔFC * f'(활성화 함수가 없는 은닉 층 뉴런 값들)/은닉 층 가중치들: ΔH1 = ΔFC*f'/Wh1 = -0.13439*0.1966/0.3 = -0.088; ΔH2 = ΔFC*f'(1.3)/Wh2 = -0.13439*0.1683 = -0.0452; ΔH1 = ΔFC*f'(0.8)/Wh3 = -0.13439*0.2139 = -0.0319. 역전파 후에, 새로운 은닉 층 가중치들은 다음의 값들을 갖는다: Wh1 = Wh1+ΔWh1 = 0.3 - 0.1838 = 0.1162; Wh2 = Wh2+ΔWh2 = 0.5 - 0.1710 = 0.392; Wh3 = Wh3+ΔWh3 = 0.9 - 0.1920 = 0.708. 그 후 입력 층과 은닉 층 사이의 가중치 업데이트가 다음과 같이 계산된다: 가중치들의 델타 = 은닉 층의 델타/입력들: ΔW11 = ΔH1/X1 = -0.088/1 = -0.088; ΔW12 = ΔH2/X1 = -0.0452/1 = -0.0452; ΔW13 = ΔH3/X1 = -0.0319/1 = -0.0319; ΔW21 = ΔH1/X2 = -0.088/1 = -0.088; ΔW22 = ΔH2/X2 = -0.0452/1 = -0.0452; ΔW23 = ΔH3/X2 = -0.0319/1 = -0.0319; 새로운 가중치들: W11 = W11 + ΔW11 = 0.8 - 0.088 = 0.712; W12 = W12 + ΔW12 = 0.4 - 0.0452 = 0.3548; W13 = W13 + ΔW13 = 0.3 - 0.0319 = 0.2681; W21 = W21 + ΔW21 = 0.2 - 0.088 = 0.112; W22 = W22 + ΔW22 = 0.9 - 0.0452 = 0.8548; W23 = W23 + ΔW23 = 0.5 - 0.0319 = 0.4681. 도 11b는 위의 계산들에 기초하여 가중치들이 업데이트된 후의 DNN의 상태를 예시한다. DNN의 출력은 이 반복 후에 0.69이고, 이는 제1 반복 후의 0.77의 출력에 비해 개선이다. 반복들은 손실 함수 기울기가 용인가 능한 레벨에 도달할 때까지 이러한 방식으로 계속된다. 도 11c는 e의 베이스 대신에 2의 베이스를 갖는 지수 항을 갖는 수정된 Sigmoid 활성화 함수: 를 이용하여 DNN이 구현될 때 수행되는 프로세싱을 예시한다. 순방향 전파 스테이지 동안, 가중치들은 다음과 같이 랜덤하게 선택된다: W11 = 0.8, W12 = 0.4, W13 = 0.3, W21 = 0.2, W22 = 0.9, WW23 = 0.5, Wh1 = 0.3, Wh2 = 0.5, 및 Wh3 = 0.9. 그 후 은닉 층 노드들(H)의 출력이 다음과 같이 계산된다: H1 = X1*W11 + X2*W21 = 0.8 + 0.2 = 1; H2 = X1*W12 + X2*W22 = 0.4 + 0.9 = 1.3; H3 = X1*W13 + X2*W23 = 0.3 + 0.5 = 0.8. 단순화를 위해 예시된 예에서는 0의 바이어스가 취해진다. 수정된 Sigmoid 활성화 함수를 적용한 후, 업데이트 된 은닉 층 뉴런들은 다음의 값들을 갖는다: H1 = 0.6667; H2 = 0.7117; H3 = 0.6351. 그 후 완전히 연결된(FC) 층이 다음과 같이 계산될 수 있다: FC = H1*Wh1 + H2*Wh2 + H3*Wh3 = 0.6667*0.3 + 0.7117*0.5 + 0.6351*0.9 = 1.1272. 수정된 Sigmoid 활성화 함수를 완전히 연결된 층에 적용한 후에, FC = 0.6859이다. 그 후 오차가 다음과 같이 계산된다: 오차 = 예상 - 계산 = 0 - 0.6859 = -0.6859. 역방향 전파 및 가중치 업데이트 스테이지 동안, 수정된 Sigmoid 활성화 함수의 도함수"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 25, "content": "가 사용되고, 다음의 계산들이 수행된다: ΔFC= f'(활성화 함수가 없는 FC 값) * 오차 = f'(1.1272)*(-0.6859) = 0.1024; ΔFC = 은닉 층 뉴런 * 은닉 층 가중치 = H1*Wh1 + H2*Wh2 + H3*Wh3; ΔWh1 = ΔFC/H1 = -0.1024/0.6667 = -0.15364; ΔWh2 = ΔFC/H2 = -0.1024/0.7117 = -0.14402; ΔWh3 = ΔFC/H3 = -0.1024/0.6351 = -0.16125. 그 후 ΔH1, ΔH2, 및 ΔH3에 관하여 다음의 계산이 수행된다: 새로운 은닉 층 값들 = ΔFC * f'(활성화 함수가 없는 은닉 층 뉴런 값들)/은닉 층 가중치들: ΔH1 = ΔFC*f'/Wh1 = -0.13439*0.1966/0.3 = -0.05259; ΔH2 = ΔFC*f'(1.3)/Wh2 = -0.13439*0.1683 = -0.02917; ΔH1 = ΔFC*f'(0.8)/Wh3 = -0.13439*0.2139 = -0.01828. 역전파 후에, 새로운 은닉 층 가중치들은 다음의 값들을 갖는다: Wh1 = Wh1+ΔWh1 = 0.3 - 0.15364 = 0.1463; Wh2 = Wh2+ΔWh2 = 0.5 - 0.14402 = 0.3559; Wh3 = Wh3+ΔWh3 = 0.9 - 0.16125 = 0.7387. 그 후 입력 층과 은닉 층 사이의 가중치 업데이트가 다음과 같이 계산된다: 가중치들의 델타 = 은닉 층의 델타/입력들: ΔW11 = ΔH1/X1 = -0.05259/1 = -0.05259; ΔW12 = ΔH2/X1 = -0.02917/1 = -0.02917; ΔW13 = ΔH3/X1 = -0.01828/1 = -0.01828; ΔW21 = ΔH1/X2 = -0.02917/1 = -0.05259; ΔW22 = ΔH2/X2 = -0.0452/1 = -0.02917; ΔW23 = ΔH3/X2 = -0.01828/1 = -0.01828; 새로운 가중치들: W11 = W11 + ΔW11 = 0.8 - 0.05259 = 0.7474; W12 = W12 + ΔW12 = 0.4 - 0.02917 = 0.3708; W13 = W13 + ΔW13 = 0.3 - 0.01828 = 0.2817; W21 = W21 + ΔW21 = 0.2 - 0.05259 = 0.1474; W22 = W22 + ΔW22 = 0.9 - 0.02917 = 0.8708; W23 = W23 + ΔW23 = 0.5 - 0.01828 = 0.4817. 도 11c는 위의 계산들에 기초하여(예컨대, 수정된 Sigmoid 활성화 함수를 이용하여) 가중치들이 업데이트된 후 의 DNN의 상태를 예시한다. 도 11c의 DNN의 출력은 이 반복 후에 0.70이고, 이는 도 11b의 DNN에 대한 0.69의 출력과 비슷하다. 반복들은 손실 함수 기울기가 용인가능한 레벨에 도달할 때까지 이러한 방식으로 계 속된다. 도 12a 및 도 12b는 도 11b 및 도 11c의 각각의 DNN들에 대한 훈련 수렴의 비교를 예시한다. 특히, 도 12a는 도 11b의 DNN에 의해 사용되는 원래의 Sigmoid 활성화 함수에 대한 수렴의 레이트를 예시하는 반면, 도 12b는 도 11c의 DNN에 의해 사용되는 수정된 Sigmoid 활성화 함수(예컨대, e 대신 베이스 2의 거듭제곱을 이용함)에 대한 수렴의 레이트를 예시한다. 도 13은 이러한 접근법들의 오차율 또는 정확도를 예시한다. 예시적인 컴퓨팅 아키텍처들 도 14 내지 도 18은 본 명세서에 개시된 실시예들에 따라 사용될 수 있는 컴퓨팅 환경들 및 아키텍처들의 예시 적인 구현들을 예시한다. 다양한 실시예들에서, 예를 들어, 이러한 예시적인 컴퓨터 아키텍처들은 본 개시내용 전체에 걸쳐 설명된 심층 뉴럴 네트워크(DNN) 프로세싱 기능성과 함께 사용되고/되거나 이를 구현하는 데 사용 될 수 있다. 랩톱들, 데스크톱들, 핸드헬드 PC들, 개인용 디지털 단말기들, 엔지니어링 워크스테이션들, 서버들, 네트워크 디바이스들, 네트워크 허브들, 스위치들, 임베디드 프로세서들, 디지털 신호 프로세서(DSP)들, 그래픽 디바이스 들, 비디오 게임 디바이스들, 셋톱 박스들, 마이크로 컨트롤러들, 휴대폰들, 포터블 미디어 플레이어들, 핸드"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 26, "content": "헬드 디바이스들, 및 다양한 다른 전자 디바이스들에 대해 본 기술분야에 알려진 다른 시스템 설계들 및 구성들 이 또한 적합하다. 일반적으로, 본 명세서에 개시된 바와 같은 프로세서 및/또는 다른 실행 로직을 통합할 수 있는 매우 다양한 시스템들 또는 전자 디바이스들이 일반적으로 적합하다. 도 14a는 본 발명의 실시예들에 따른 예시적인 순차적 파이프라인 및 예시적인 레지스터 리네이밍, 비순차적 발 행/실행 파이프라인 양쪽 모두를 예시하는 블록 다이어그램이다. 도 14b는 본 발명의 실시예들에 따른 프로세 서에 포함될 순차적 아키텍처 코어 및 예시적인 레지스터 리네이밍, 비순차적 발행/실행 아키텍처 코어의 의 예 시적인 실시예 양쪽 모두를 예시하는 블록 다이어그램이다. 도 14a 및 도 14b에서의 실선 박스들은 순차적 파 이프라인 및 순차적 코어를 예시하는 반면, 파선 박스들의 옵션의 추가는 레지스터 리네이밍, 비순차적 발행/실 행 파이프라인 및 코어를 예시한다. 순차적 양태가 비순차적 양태의 서브세트라는 점을 고려하여, 비순차적 양 태가 설명될 것이다. 도 14a에서, 프로세서 파이프라인은 페치 스테이지, 길이 디코드 스테이지, 디코드 스테이지 , 할당 스테이지, 리네이밍 스테이지, 스케줄링(디스패치 또는 발행으로도 알려짐) 스테이지 , 레지스터 판독/메모리 판독 스테이지, 실행 스테이지, 후기입/메모리 기입 스테이지 , 예외 핸들링 스테이지, 및 커밋 스테이지를 포함한다. 도 14b은 실행 엔진 유닛에 결합된 프런트 엔드 유닛 - 양쪽 모두는 메모리 유닛에 결합되어 있음 - 을 포함하는 프로세서 코어를 도시한다. 코어는 축소 명령어 세트 컴퓨팅(RISC) 코어, 복 잡 명령어 세트 컴퓨팅(CISC) 코어, 매우 긴 명령어 워드(VLIW) 코어, 또는 하이브리드 또는 대안의 코어 타입 일 수 있다. 또 다른 옵션으로서, 코어는, 예를 들어, 네트워크 또는 통신 코어, 압축 엔진, 코프로세서 코어, 범용 컴퓨팅 그래픽 프로세싱 유닛(GPGPU) 코어, 그래픽 코어 등과 같은 특수 목적 코어일 수 있다. 프런트 엔드 유닛은 명령어 캐시 유닛에 결합된 분기 예측 유닛을 포함하고, 이 명령어 캐시 유닛은 명령어 변환 색인 버퍼(TLB)에 결합되고, 이 명령어 변환 색인 버퍼는 명령어 페치 유닛에 결합되고, 이 명령어 페치 유닛은 디코드 유닛에 결합된다. 디코드 유닛(또는 디코더)은 명령어들 을 디코딩할 수 있으며, 원래의 명령어들로부터 디코딩되거나, 달리 이들을 반영하거나, 또는 이들로부터 도출 되는, 하나 이상의 마이크로-오퍼레이션, 마이크로-코드 엔트리 포인트들, 마이크로명령어들, 다른 명령어들,또는 다른 제어 신호들을 출력으로서 생성할 수 있다. 디코드 유닛은 다양한 상이한 메커니즘들을 이용 하여 구현될 수 있다. 적합한 메커니즘들의 예로는 룩업 테이블, 하드웨어 구현, 프로그램 가능 로직 어레이 (PLA), 마이크로코드 판독 전용 메모리(ROM) 등을 포함하지만, 이에 한정되는 것은 아니다. 일 실시예에서, 코 어는 특정 매크로명령어들을 위한 마이크로코드를 저장하는(예컨대, 디코드 유닛에 또는 달리 프런 트 엔드 유닛 내에) 마이크로코드 ROM 또는 다른 매체를 포함한다. 디코드 유닛은 실행 엔진 유닛 내의 리네임/할당기 유닛에 결합된다. 실행 엔진 유닛은 리타이어먼트 유닛 및 하나 이상의 스케줄러 유닛(들)의 세트에 결합된 리 네임/할당기 유닛을 포함한다. 스케줄러 유닛(들)은 임의의 수의 상이한 스케줄러들을 나타내고, 예약 스테이션, 중앙 명령어 윈도우 등을 포함한다. 스케줄러 유닛(들)은 물리적 레지스터 파일(들) 유 닛(들)에 결합된다. 물리적 레지스터 파일(들) 유닛들 각각은 하나 이상의 물리적 레지스터 파일 을 나타내고, 이러한 중 상이한 것들은 스칼라 정수, 스칼라 부동 소수점, 패킹된 정수, 패킹된 부동 소수점, 벡터 정수, 벡터 부동 소수점, 상태(예컨대, 실행될 다음 명령어의 어드레스인 명령어 포인터) 등과 같은 하나 이상의 상이한 데이터 타입을 저장한다. 일 실시예에서, 물리적 레지스터 파일(들) 유닛은 벡터 레지스 터 유닛, 기입 마스크 레지스터 유닛, 및 스칼라 레지스터 유닛을 포함한다. 이러한 레지스터 유닛은 아키텍처 벡터 레지스터들, 벡터 마스크 레지스터들, 및 범용 레지스터들을 제공할 수 있다. 물리적 레지스터 파일(들) 유닛(들)은 레지스터 리네이밍 및 비순차 실행이 구현될 수 있는 다양한 방식들(예컨대, 재정렬 버퍼(들) 및 리타이어먼트 레지스터 파일(들)을 이용; 미래 파일(들), 이력 버퍼(들), 및 리타이어먼트 레지스터 파일(들)을 이용; 레지스터 맵들 및 레지스터들의 풀을 이용, 등)을 예시하기 위해 리타이어먼트 유닛에 의해 중첩된다. 리타이어먼트 유닛 및 물리적 레지스터 파일(들) 유닛(들)은 실행 클러스터 (들)에 결합된다. 실행 클러스터(들)는 하나 이상의 실행 유닛의 세트 및 하나 이상의 메모 리 액세스 유닛의 세트를 포함한다. 실행 유닛들은 다양한 타입의 데이터(예컨대, 스칼라 부동 소 수점, 패킹된 정수, 패킹된 부동 소수점, 벡터 정수, 벡터 부동 소수점)에 대해 다양한 연산들(예컨대, 시프트, 가산, 감산, 승산)을 수행할 수 있다. 일부 실시예들은 특정 기능들 또는 기능들의 세트들에 전용되는 다수의 실행 유닛들을 포함할 수 있지만, 다른 실시예들은 단지 하나의 실행 유닛, 또는 모두가 모든 기능들을 수행하 는 다수의 실행 유닛들을 포함할 수 있다. 스케줄러 유닛(들), 물리적 레지스터 파일(들) 유닛 (들), 및 실행 클러스터(들)는 가능하게는 복수인 것으로 도시되는데, 그 이유는 특정 실시예들은 특정 타입들의 데이터/연산들에 대해 개별 파이프라인들(예컨대, 스칼라 정수 파이프라인, 스칼라 부동 소수점/ 패킹된 정수/패킹된 부동 소수점/벡터 정수/벡터 부동 소수점 파이프라인, 및/또는 각각이 그들 자신의 스케줄 러 유닛, 물리적 레지스터 파일(들) 유닛, 및/또는 실행 클러스터를 갖는 메모리 액세스 파이프라인 - 개별 메 모리 액세스 파이프라인의 경우에, 이 파이프라인의 실행 클러스터만이 메모리 액세스 유닛(들)을 갖는 특정 실시예들이 구현됨)을 생성하기 때문이다. 개별 파이프라인들이 사용되는 경우, 이러한 파이프라인 중 하 나 이상은 비순차적 발행/실행일 수 있고 나머지는 순차적일 수 있다는 점도 이해해야 한다. 메모리 액세스 유닛들의 세트는 메모리 유닛에 결합되고, 이 메모리 유닛은 레벨 2(L2) 캐시 유닛 에 결합되는 데이터 캐시 유닛에 결합된 데이터 TLB 유닛을 포함한다. 하나의 예시적인 실 시예에서, 메모리 액세스 유닛들은 로드 유닛, 저장 어드레스 유닛, 및 저장 데이터 유닛을 포함할 수 있 고, 이러한 각각은 메모리 유닛 내의 데이터 TLB 유닛에 결합된다. 명령어 캐시 유닛은 메 모리 유닛 내의 레벨 2(L2) 캐시 유닛에 또한 결합된다. L2 캐시 유닛은 하나 이상의 다른 레벨의 캐시에 그리고 궁극적으로는 메인 메모리에 결합된다. 예로서, 예시적인 레지스터 리네이밍, 비순차적 발행/실행 코어 아키텍처는 다음과 같이 파이프라인을 구 현할 수 있다: 1) 명령어 페치는 페치 및 길이 디코딩 스테이지들(1402 및 1404)을 수행하고; 2) 디코드 유닛은 디코드 스테이지를 수행하고; 3) 리네임/할당기 유닛은 할당 스테이지 및 리네 이밍 스테이지를 수행하고; 4) 스케줄러 유닛(들)은 스케줄 스테이지를 수행하고; 5) 물리적 레지스터 파일(들) 유닛(들) 및 메모리 유닛은 레지스터 판독/메모리 판독 스테이지를 수행 하고; 실행 클러스터는 실행 스테이지를 수행하고; 6) 메모리 유닛 및 물리적 레지스터 파일 (들) 유닛(들)은 후기입/메모리 기입 스테이지를 수행하고; 7) 다양한 유닛들이 예외 핸들링 스테 이지에 관여할 수 있고; 8) 리타이어먼트 유닛 및 물리적 레지스터 파일(들) 유닛(들)은 커 밋 스테이지를 수행한다. 코어는 본 명세서에 설명된 명령어(들)를 포함하는 하나 이상의 명령어 세트(예컨대, (더 새로운 버전이 추가된 일부 확장들을 갖는) x86 명령어 세트; 캘리포니아주 서니베일에 있는 MIPS Technologies의 MIPS 명령어세트; 캘리포니아주 서니베일에 있는 ARM Holdings의 (NEON과 같은 옵션의 추가적인 확장을 갖는) ARM 명령어 세트)를 지원할 수 있다. 일 실시예에서, 코어는 패킹된 데이터 명령어 세트 확장(예컨대, AVX1, AVX2) 을 지원하는 로직을 포함하며, 그에 의해 많은 멀티미디어 애플리케이션들에 의해 이용되는 연산들이 패킹된 데 이터를 이용하여 수행되는 것을 허용한다. 코어가 (연산들 또는 스레드들의 2개 이상의 병렬 세트를 실행하는) 멀티스레딩을 지원할 수 있고, 시간 슬라이 싱된 멀티스레딩, 동시 멀티스레딩(이 경우 단일 물리 코어는 물리 코어가 동시에 멀티스레딩하고 있는 스레드 들 각각에 대한 논리 코어를 제공한다), 또는 이들의 조합(예컨대, Intel® 하이퍼스레딩 기술에서와 같은 시간 슬라이싱된 페칭 및 디코딩 및 그 후의 동시 멀티스레딩)을 포함하는 다양한 방식으로 그렇게 할 수 있다는 것 을 이해해야 한다. 레지스터 리네이밍이 비순차적 실행의 컨텍스트에서 설명되었지만, 레지스터 리네이밍은 순차적 아키텍처에서 사용될 수도 있다는 점을 이해해야 한다. 프로세서의 예시된 실시예는 또한 개별 명령어 및 데이터 캐시 유닛 들(1434/1474) 및 공유된 L2 캐시 유닛을 포함하고 있지만, 대안 실시예들은, 예를 들어 레벨 1(L1) 내부 캐시, 또는 다수의 레벨의 내부 캐시와 같은, 명령어들 및 데이터 양쪽 모두에 대한 단일 내부 캐시를 가질 수 있다. 일부 실시예들에서, 시스템은 내부 캐시와, 코어 및/또는 프로세서에 대해 외부에 있는 외부 캐시의 조 합을 포함할 수 있다. 대안적으로, 모든 캐시는 코어 및/또는 프로세서에 대해 외부에 있을 수 있다. 도 15는 본 발명의 실시예들에 따른 하나보다 많은 코어를 가질 수 있고, 통합된 메모리 컨트롤러를 가질 수 있 고, 통합된 그래픽을 가질 수 있는 프로세서의 블록 다이어그램이다. 도 15에서의 실선 박스들은 단일 코어(1502A), 시스템 에이전트, 및 하나 이상의 버스 컨트롤러 유닛들의 세트를 갖는 프로세서 를 예시하는 반면, 파선 박스들의 옵션의 추가는 다수의 코어(1502A-N), 시스템 에이전트 유닛 내 의 하나 이상의 통합된 메모리 컨트롤러 유닛(들)의 세트, 및 특수 목적 로직을 갖는 대안의 프로 세서를 예시한다. 따라서, 프로세서의 상이한 구현들은 다음을 포함할 수 있다: 1) (하나 이상의 코어를 포함할 수 있는) 통합된 그래픽 및/또는 과학(스루풋)로직인 특수 목적 로직, 및 하나 이상의 범용 코어(예컨대, 범용 순 차적 코어들, 범용 비순차적 코어들, 이 둘의 조합)인 코어들(1502A-N)을 갖는 CPU; 2) 주로 그래픽 및/또는 과 학(스루풋)을 위해 의도된 많은 수의 특수 목적 코어들인 코어들(1502A-N)을 갖는 코프로세서; 및 3) 많은 수의 범용 순차적 코어들인 코어들(1502A-N)을 갖는 코프로세서. 따라서, 프로세서는 범용 프로세서, 코프로 세서 또는 특수 목적 프로세서, 예를 들어, 네트워크 또는 통신 프로세서, 압축 엔진, 그래픽 프로세서, GPGPU (범용 그래픽 프로세싱 유닛), 고-스루풋 다수의 집적 코어(MIC) 코프로세서(30개 이상의 코어를 포함함), 임베 디드 프로세서 등일 수 있다. 프로세서는 하나 이상의 칩 상에 구현될 수 있다. 프로세서는, 예를 들어, BiCMOS, CMOS, 또는 NMOS와 같은 다수의 프로세스 기술 중 임의의 것을 이용하여 하나 이상의 기판 상에 구현될 수 있고/있거나 그 일부일 수 있다. 메모리 층구조는 코어들 내의 하나 이상의 레벨의 캐시, 하나 이상의 공유된 캐시 유닛의 세트, 및 통합 된 메모리 컨트롤러 유닛들의 세트에 결합된 외부 메모리(도시되지 않음)를 포함한다. 공유된 캐시 유닛 들의 세트는 레벨 2(L2), 레벨 3(L3), 레벨 4(L4) 또는 다른 레벨들의 캐시와 같은 하나 이상의 중간-레 벨 캐시, 마지막 레벨 캐시(LLC) 및/또는 이들의 조합을 포함할 수 있다. 일 실시예에서, 링 기반 인터커넥트 유닛은 통합된 그래픽 로직, 공유된 캐시 유닛들의 세트, 및 시스템 에이전트 유닛/통 합된 메모리 컨트롤러 유닛(들)을 상호연결하지만, 대안 실시예들은 그러한 유닛들을 상호연결하기 위해 임의의 수의 잘 알려진 기법들을 이용할 수 있다. 일 실시예에서, 하나 이상의 캐시 유닛과 코어들 (1502A-N) 사이에 코히어런시가 유지된다. 일부 실시예들에서, 코어들(1502A-N) 중 하나 이상은 멀티스레딩이 가능하다. 시스템 에이전트는 코어들 (1502A-N)을 조정하고 동작시키는 컴포넌트들을 포함한다. 시스템 에이전트 유닛은 예를 들어 전력 제어 유닛(PCU) 및 디스플레이 유닛을 포함할 수 있다. PCU는 코어들(1502A-N) 및 통합된 그래픽 로직의 전력 상태를 조절하기 위해 필요한 로직 및 컴포넌트들일 수 있거나 이들을 포함할 수 있다. 디스플레이 유닛은 하 나 이상의 외부에서 연결된 디스플레이들을 구동하기 위한 것이다. 코어들(1502A-N)은 아키텍처 명령어 세트에 관하여 동종이거나 이종일 수 있다; 즉, 코어들(1502A-N) 중 2개 이 상은 동일한 명령어 세트를 실행 가능할 수 있는 반면, 다른 것들은 그 명령어 세트의 서브세트만을 또는 상이 한 명령어 세트를 실행 가능할 수 있다. 이제 도 16을 참조하면, 본 발명의 일 실시예에 따른 시스템의 블록 다이어그램이 도시되어 있다. 시스 템은 하나 이상 프로세서(1610 및 1615)를 포함할 수 있고, 이들은 컨트롤러 허브에 결합된다. 일 실시예에서, 컨트롤러 허브는 그래픽 메모리 컨트롤러 허브(GMCH) 및 입력/출력 허브(IOH) (이들은 개별 칩들 상에 있을 수 있음)를 포함하고; GMCH는 메모리 및 코프로세서가 결합되 는 메모리 및 그래픽 컨트롤러들을 포함하고; IOH는 입력/출력(I/O) 디바이스들을 GMCH에 결 합시킨다. 대안적으로, 메모리 및 그래픽 컨트롤러들 중 하나 또는 양쪽 모두는 프로세서 내에 통합되고(본 명 세서에 설명된 바와 같이), 메모리 및 코프로세서는 IOH와 단일 칩에 있는 컨트롤러 허브 및 프로세서에 직접 결합된다. 추가적인 프로세서들의 옵션의 본질은 도 16에서 파선들로 표시되어 있다. 각각의 프로세서(1610, 161 5)는 본 명세서에 설명된 프로세싱 코어들 중 하나 이상을 포함할 수 있고, 프로세서의 일부 버전일 수 있다. 메모리는, 예를 들어, 동적 랜덤 액세스 메모리(DRAM), 상 변화 메모리(PCM), 또는 이 둘의 조합일 수 있 다. 적어도 하나의 실시예에서, 컨트롤러 허브는 프런트사이드 버스(FSB)와 같은 멀티-드롭 버스, QPI(QuickPath Interconnect)와 같은 포인트-투-포인트 인터페이스, 또는 유사한 연결을 통해, 프로세서 (들)(1610 및 1615)와 통신한다. 일 실시예에서, 코프로세서는, 예를 들어, 고-스루풋 MIC 프로세서, 네트워크 또는 통신 프로세서, 압축 엔진, 그래픽 프로세서, GPGPU, 임베디드 프로세서 등과 같은 특수 목적 프로세서이다. 일 실시예에서, 컨트롤 러 허브는 통합된 그래픽 가속기를 포함할 수 있다. 아키텍처, 마이크로아키텍처, 열, 전력 소비 특성 등을 포함하는 다양한 성능 메트릭(metrics of merit)에 관하 여 물리 리소스들(1610, 1615) 사이에는 다양한 차이가 존재할 수 있다. 일 실시예에서, 프로세서는 일반 타입의 데이터 프로세싱 동작들을 제어하는 명령어들을 실행한다. 명령 어들 내에는 코프로세서 명령어들이 임베디드될 수 있다. 프로세서는 이러한 코프로세서 명령어들을 부 착된 코프로세서에 의해 실행되어야 하는 타입인 것으로서 인식한다. 따라서, 프로세서는 코프로 세서 버스 또는 다른 인터커넥트를 통해 이러한 코프로세서 명령어들(또는 코프로세서 명령어들을 나타내는 제 어 신호들)을 코프로세서에 발행한다. 코프로세서(들)는 수신된 코프로세서 명령어들을 수락하여 실행한다. 이제 도 17을 참조하면, 본 발명의 일 실시예에 따른 제1의 더 구체적인 예시적인 시스템의 블록 다이어 그램이 도시되어 있다. 도 17에 도시된 바와 같이, 멀티프로세서 시스템은 포인트-투-포인트 인터커넥트 시스템이고, 포인트-투-포인트 인터커넥트를 통해 결합되는 제1 프로세서 및 제2 프로세서를 포함한다. 프로세서들(1770 및 1780) 각각은 프로세서의 일부 버전일 수 있다. 본 발명의 일 실시예에 서, 프로세서들(1770 및 1780)은 각각 프로세서들(1610 및 1615)인 반면, 코프로세서는 코프로세서(164 5)이다. 다른 실시예에서, 프로세서들(1770 및 1780)은 각각 프로세서 및 코프로세서이다. 프로세서들(1770 및 1780)은 각각 통합된 메모리 컨트롤러(IMC) 유닛들(1772 및 1782)을 포함하는 것으로 도시 되어 있다. 프로세서는 또한, 그의 버스 컨트롤러 유닛들의 일부로서, 포인트-투-포인트(P-P) 인터페이 스들(1776 및 1778)을 포함하고; 유사하게, 제2 프로세서는 P-P 인터페이스들(1786 및 1788)을 포함한다. 프로세서들(1770, 1780)은 포인트-투-포인트(P-P) 인터페이스 회로들(1778, 1788)을 이용하여 P-P 인터페이스 를 통해 정보를 교환할 수 있다. 도 17에 도시된 바와 같이, IMC들(1772 및 1782)은 프로세서들을, 각각 의 프로세서들에 로컬로 부착되어 있는 메인 메모리의 부분들일 수 있는, 각각의 메모리들, 즉 메모리 및 메모리에 결합시킨다. 프로세서들(1770, 1780)은 각각 포인트 투 포인트 인터페이스 회로들(1776, 1794, 1786, 1798)을 이용하여 개별 P-P 인터페이스들(1752, 1754)을 통해 칩셋과 정보를 교환할 수 있다. 칩셋은 옵션으로 고성능 인 터페이스를 통해 코프로세서와 정보를 교환할 수 있다. 일 실시예에서, 코프로세서는, 예를 들어, 고-스루풋 MIC 프로세서, 네트워크 또는 통신 프로세서, 압축 엔진, 그래픽 프로세서, GPGPU, 임베디드 프로세서 등과 같은 특수 목적 프로세서이다. 공유된 캐시(도시되지 않음)는 어느 하나의 프로세서에 포함되거나, 양쪽 모두의 프로세서의 외부이지만 여전히 P-P 인터커넥트를 통해 프로세서들과 연결될 수 있어서, 프로세서가 저전력 모드에 놓이는 경우 어느 하나의 또 는 양쪽 모두의 프로세서의 로컬 캐시 정보가 공유된 캐시에 저장될 수 있다.칩셋은 인터페이스를 통해 제1 버스에 결합될 수 있다. 일 실시예에서, 제1 버스는 주변 컴포넌트 인터커넥트(PCI) 버스이거나, 또는 PCI Express 버스 또는 다른 3세대 I/O 인터커넥트 버스와 같 은 버스일 수 있다(비록 본 발명의 범위는 그렇게 제한되지 않지만). 도 17에 도시된 바와 같이, 제1 버스를 제2 버스에 결합시키는 버스 브리지와 함께, 다양한 I/O 디바이스들이 제1 버스에 결합될 수 있다. 일 실시예에서, 코프로세서들, 고-스루풋 MIC 프로 세서들, GPGPU들, 가속기들(예컨대, 그래픽 가속기들 또는 디지털 신호 프로세싱(DSP) 유닛들과 같은), 필드 프 로그래머블 게이트 어레이들, 또는 임의의 다른 프로세서와 같은 하나 이상의 추가적인 프로세서(들)이 제1 버스에 결합된다. 일 실시예에서, 제2 버스는 LPC(low pin count) 버스일 수 있다. 일 실시 예에서, 예를 들어, 키보드 및/또는 마우스, 통신 디바이스들, 및 명령어들/코드 및 데이터 를 포함할 수 있는 디스크 드라이브나 다른 대용량 스토리지 디바이스와 같은 스토리지 유닛을 포함하는 다양한 디바이스들이 제2 버스에 결합될 수 있다. 또한, 오디오 I/O가 제2 버스에 결합될 수 있다. 다른 아키텍처들도 가능하다는 점에 유의한다. 예를 들어, 도 17의 포인트-투-포인트 아키텍처 대신 에, 시스템은 멀티-드롭 버스 또는 다른 그러한 아키텍처를 구현할 수 있다. 이제 도 18을 참조하면, 본 발명의 실시예에 따른 SoC의 블록 다이어그램이 도시되어 있다. 도 15에서의 유사한 요소들은 유사한 참조 번호들을 지닌다. 또한, 파선 박스들은 더 진보된 SoC들에 대한 옵션의 특징들이 다. 도 18에서, 인터커넥트 유닛(들)은: 하나 이상의 코어(1802A-N)의 세트 및 공유된 캐시 유닛 (들)을 포함하는 애플리케이션 프로세서; 시스템 에이전트 유닛; 버스 컨트롤러 유닛 (들); 통합된 메모리 컨트롤러 유닛(들); 통합된 그래픽 로직, 이미지 프로세서, 오디오 프로세서, 및 비디오 프로세서를 포함할 수 있는 하나 이상의 코프로세서의 세트; 정적 랜덤 액세스 메모리(SRAM) 유닛; 직접 메모리 액세스(DMA) 유닛; 및 하나 이상의 외부 디스플레이에 결합하기 위한 디스플레 이 유닛에 결합된다. 일 실시예에서, 코프로세서(들)는, 예를 들어, 네트워크 또는 통신 프로세서, 압축 엔진, GPGPU, 고-스루풋 MIC 프로세서, 임베디드 프로세서 등과 같은 특수 목적 프로세서를 포 함한다. 본 명세서에 개시된 메커니즘들의 실시예들은 하드웨어, 소프트웨어, 펌웨어, 또는 그러한 구현 접근법들의 조 합으로 구현될 수 있다. 본 발명의 실시예들은 적어도 하나의 프로세서, 스토리지 시스템(휘발성 및 비휘발성 메모리 및/또는 스토리지 요소들을 포함함), 적어도 하나의 입력 디바이스, 및 적어도 하나의 출력 디바이스를 포함하는 프로그램 가능 시스템들 상에서 실행되는 컴퓨터 프로그램들 또는 프로그램 코드로서 구현될 수 있다. 도 17에 예시된 코드와 같은 프로그램 코드는 본 명세서에 설명된 기능들을 수행하고 출력 정보를 생성하 기 위해 입력 명령어들에 적용될 수 있다. 출력 정보는 알려진 방식으로 하나 이상의 출력 디바이스에 적용될 수 있다. 이 애플리케이션의 목적상, 프로세싱 시스템은, 예를 들어; 디지털 신호 프로세서(DSP), 마이크로컨 트롤러, 특정 용도 집적 회로(ASIC), 또는 마이크로프로세서와 같은 프로세서를 갖는 임의의 시스템을 포함한다. 프로그램 코드는 프로세싱 시스템과 통신하기 위해 하이 레벨 절차형 또는 객체 지향형 프로그래밍 언어로 구현 될 수 있다. 프로그램 코드는 또한 원하는 경우 어셈블리 또는 기계어로 구현될 수 있다. 사실상, 본 명세서 에 설명된 메커니즘들은 임의의 특정 프로그래밍 언어로 범위가 제한되지 않는다. 임의의 경우에, 언어는 컴파 일형 또는 해석형 언어일 수 있다. 적어도 하나의 실시예의 하나 이상의 양태는 머신에 의해 판독될 때, 이 머신으로 하여금 본 명세서에 설명된 기법들을 수행하는 로직을 제작하게 하는, 프로세서 내의 다양한 로직을 표현하는 머신 판독가능 매체 상에 저 장된 대표적인 명령어들에 의해 구현될 수 있다. \"IP 코어들\"로 알려진 그러한 표현들은 유형 머신 판독가능 매체 상에 저장될 수 있고 다양한 고객 또는 제조 설비에 공급되어 실제로 로직 또는 프로세서를 만드는 제작 머신들에 로딩된다. 그러한 그러한 머신 판독가능 스토리지 매체는 하드 디스크들, 플로피 디스크들, 광 디스크들, 콤팩트 디스크 판독 전용 메모리(CD-ROM)들, 재기입가능 콤팩트 디스크(CD-RW)들, 및 자기-광 디스크들을 포함하는 임의의 다 른 타입의 디스크, 판독 전용 메모리(ROM)들, 동적 랜덤 액세스 메모리(DRAM)들, 정적 랜덤 액세스 메모리 (SRAM)들과 같은 랜덤 액세스 메모리(RAM)들, 소거가능한 프로그램 가능 판독 전용 메모리(EPROM)들, 플래시 메 모리들, 전기적으로 소거가능한 프로그램 가능 판독 전용 메모리(EEPROM)들과 같은 반도체 디바이스들, 상 변화 메모리(PCM), 자기 또는 광 카드들, 또는 전자 명령어들을 저장하기에 적합한 임의의 다른 타입의 매체와 같은 스토리지 매체를 포함하는, 머신 또는 디바이스에 의해 제조되거나 형성되는 물품들의 비일시적인 유형 배열들을 포함할 수 있는데, 이들로 제한되지는 않는다. 따라서, 본 발명의 실시예들은 명령어들을 포함하거나, 또는 본 명세서에 설명된 구조들, 회로들, 장치들, 프로 세서들 및/또는 시스템 특징들을 정의하는, 하드웨어 기술 언어(HDL)와 같은 설계 데이터를 포함하는 비일시적 인 유형 머신 판독가능 매체를 또한 포함한다. 그러한 실시예들은 프로그램 제품들이라고도 언급될 수 있다. 도면들에서의 흐름도들 및 블록 다이어그램들은 본 개시내용의 다양한 양태들에 따른 시스템들, 방법들 및 컴퓨 터 프로그램 제품들의 가능한 구현들의 아키텍처, 기능성, 및 동작을 예시한다. 이와 관련하여, 흐름도 또는 블록 다이어그램들 내의 각각의 블록은 특정된 논리적 기능(들)을 구현하기 위한 하나 이상의 실행가능 명령어 를 포함하는 모듈, 세그먼트, 또는 코드의 부분을 나타낼 수 있다. 일부 대안 구현들에서, 블록에 언급된 기능 들은 도면들에서 언급된 순서와 다르게 발생할 수 있다는 점에 또한 유의해야 한다. 예를 들어, 연속적으로 도 시된 2개의 블록은 사실상 실질적으로 동시에 실행될 수 있거나, 블록들은 관련된 기능성에 따라 때때로 역순으 로 또는 대안 순서로 실행될 수 있다. 블록 다이어그램들 및/또는 흐름도 예시의 각각의 블록, 및 블록 다이어 그램들 및/또는 흐름도 예시에서의 블록들의 조합들은 특정된 기능들 또는 동작들을 수행하는 특수 목적 하드웨 어 기반 시스템들, 또는 특수 목적 하드웨어와 컴퓨터 명령어들의 조합들에 의해 구현될 수 있다는 점에 또한 유의할 것이다."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 27, "content": "전술한 개시내용은 본 기술분야의 통상의 기술자가 본 개시내용의 다양한 양태들을 더 잘 이해할 수 있도록 수"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 28, "content": "개의 실시예들의 특징들을 설명한다. 본 기술분야의 통상의 기술자들은 이들이 본 개시내용을 본 명세서에 소 개된 실시예들의 동일한 목적들을 수행하고/하거나 동일한 이점들을 달성하기 위한 다른 프로세스들 및 구조들"}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 29, "content": "을 설계하거나 수정하기 위한 기초로서 용이하게 사용할 수 있다는 것을 이해할 것이다. 본 기술분야의 통상의 기술자들은 또한 그러한 등가의 구성들이 본 개시내용의 사상 및 범위로부터 벗어나지 않고, 이들이 본 개시내 용의 사상 및 범위로부터 벗어나지 않고 다양한 변경들, 치환들 및 개조들을 행할 수 있다는 것을 또한 이해해 야 한다. 본 명세서에 개시된 임의의 하드웨어 요소의 전부 또는 일부는 중앙 프로세싱 유닛(CPU) 패키지를 포함하는 시 스템 온 칩(SoC)에서 용이하게 제공될 수 있다. SoC는 컴퓨터 또는 다른 전자 시스템의 컴포넌트들을 단일 칩 에 통합하는 집적 회로(IC)를 나타낸다. SoC는 디지털, 아날로그, 혼합 신호, 및 무선 주파수 함수들을 포함할 수 있고, 이들 모두가 단일 칩 기판 상에 제공될 수 있다. 다른 실시예들은 단일 전자 패키지 내에 위치하고 전자 패키지를 통해 서로 밀접하게 상호작용하도록 구성되는 복수의 칩을 갖는 멀티-칩-모듈(MCM)을 포함할 수 있다. 다양한 다른 실시예들에서, 본 명세서에 개시된 컴퓨팅 기능성들은 특정 용도 집적 회로(ASIC)들, 필드 프로그래머블 게이트 어레이(FPGA)들, 및 다른 반도체 칩들에서 하나 이상의 실리콘 코어에서 구현될 수 있다. 본 명세서 전체에 걸쳐 사용되는 바와 같이, \"프로세서\" 또는 \"마이크로프로세서\" 라는 용어는 종래의 마이크로 프로세서(예컨대, Intel® 산업-선도 x86 및 x64 아키텍처들)뿐만 아니라, 그래픽 프로세서들, 매트릭스 프로세 서들, 및 임의의 ASIC, FPGA, 마이크로컨트롤러들, 디지털 신호 프로세서(DSP), 프로그램 가능 로직 디바이스, 프로그램 가능 로직 어레이(PLA), 마이크로코드, 명령어 세트, 에뮬레이션된 또는 가상 머신 프로세서, 또는 임 의의 유사한 \"터닝 완료(Turing-complete)\" 디바이스, 디바이스들의 조합, 또는 명령어들의 실행을 허용하는 로 직 요소들(하드웨어 또는 소프트웨어)을 포함하는 것으로 이해되어야 한다. 또한, 특정 실시예들에서, 컴포넌트들 중 일부는 생략되거나 통합될 수 있다는 점에 유의한다. 일반적인 의미 에서, 도면들에 묘사된 배열들은 논리적 분할들로서 이해되어야 하는 반면, 물리적 아키텍처는 이러한 요소들의 다양한 치환들, 조합들, 및/또는 하이브리드들을 포함할 수 있다. 본 명세서에 설명된 동작 목적들을 달성하기 위해 무수한 가능한 설계 구성들이 이용될 수 있다는 점에 유의하는 것이 필요하다. 따라서, 연관된 인프라스 트럭처는 무수한 치환 배열, 설계 선택, 디바이스 가능성, 하드웨어 구성, 소프트웨어 구현, 및 장비 옵션을 갖 는다. 일반적인 의미에서, 임의의 적합하게 구성된 프로세서는 본 명세서에 상세히 설명된 동작들을 달성하기 위해 데 이터 또는 마이크로코드와 연관된 명령어들을 실행할 수 있다. 본 명세서에 개시된 임의의 프로세서는 요소 또 는 물품(예를 들어, 데이터)을 하나의 상태 또는 사물로부터 다른 상태 또는 사물로 변환할 수 있다. 다른 예 에서, 본 명세서에서 설명된 일부 동작들은 고정 로직 또는 프로그램 가능 로직(예를 들어, 프로세서에 의해 실 행되는 소프트웨어 및/또는 컴퓨터 명령어들)로 구현될 수 있고, 본 명세서에서 식별된 요소들은 일부 타입의 프로그램 가능 프로세서, 프로그램 가능 디지털 로직(예를 들어, 필드 프로그래머블 게이트 어레이(FPGA), 소거 가능한 프로그램 가능 판독 전용 메모리(EPROM), 전기적으로 소거가능한 프로그램 가능 판독 전용 메모리 (EEPROM), 디지털 로직, 소프트웨어, 코드, 전자 명령어들을 포함하는 ASIC, 플래시 메모리, 광 디스크, CD-ROM, DVD ROM, 자기 또는 광 카드, 전자 명령어들을 저장하기에 적합한 다른 타입의 머신 판독가능 매체, 또는 이들의 임의의 적합한 조합일 수 있다. 동작 시에, 스토리지는 임의의 적합한 타입의 유형 비일시적 저장 매체(예를 들어, 랜덤 액세스 메모리(RAM), 판독 전용 메모리(ROM), 필드 프로그래머블 게이트 어레이(FPGA), 소거가능한 프로그램 가능 판독 전용 메모리 (EPROM), 전기적으로 소거가능한 프로그램 가능 ROM(EEPROM), 또는 마이크로코드), 소프트웨어, 하드웨어(예를 들어, 프로세서 명령어 또는 마이크로코드), 또는 적절한 경우에 그리고 특정 요구에 기초하여 임의의 다른 적 합한 컴포넌트, 디바이스, 요소, 또는 객체에 정보를 저장할 수 있다. 또한, 프로세서에서 추적, 전송, 수신, 또는 저장되는 정보는 특정 요구들 및 구현들에 기초하여 임의의 데이터베이스, 레지스터, 테이블, 캐시, 큐, 제어 리스트, 또는 저장 구조 내에 제공될 수 있으며, 이들 모두는 임의의 적합한 시간 프레임에서 참조될 수 있다. 본 명세서에 개시된 메모리 또는 저장 요소들 중 임의의 것은 적절한 경우 넓은 용어들 '메모리' 및 '스 토리지' 내에 포함되는 것으로 해석되어야 한다. 본 명세서에서 비일시적 저장 매체는 개시된 동작들을 제공하 도록, 프로세서로 하여금 개시된 동작들을 수행하게 하도록 구성된 임의의 비일시적 특수 목적 또는 프로그램 가능 하드웨어를 포함하는 것으로 명백히 의도된다. 비일시적 저장 매체는 또한 하드웨어 코딩된 명령어들이 저장된 프로세서, 및 옵션으로 하드웨어, 펌웨어, 또는 소프트웨어로 인코딩된 마이크로코드 명령어들 또는 시 퀀스들을 명백히 포함한다. 본 명세서에서 설명된 기능성의 전부 또는 일부를 구현하는 컴퓨터 프로그램 로직은 하드웨어 기술 언어, 소스 코드 형태, 컴퓨터 실행가능 형태, 머신 명령어 또는 마이크로코드, 프로그램 가능 하드웨어, 및 다양한 중간 형태(예를 들어, HDL 프로세서, 어셈블러, 컴파일러, 링커 또는 로케이터에 의해 생성되는 형태들)를 포함하지 만 결코 이에 한정되지 않는 다양한 형태들로 구현된다. 일 예에서, 소스 코드는 객체 코드, 어셈블리 언어, 또는 다양한 운영 체제들 또는 운영 환경들에서 사용하기 위한 OpenCL, FORTRAN, C, C++, JAVA, 또는 HTML과 같은 하이-레벨 언어와 같은 다양한 프로그래밍 언어들로, 또는 Spice, Verilog, 및 VHDL과 같은 하드웨어 기술 언어들로 구현되는 일련의 컴퓨터 프로그램 명령어들을 포함한다. 소스 코드는 다양한 데이터 구조들 및 통신 메시지들을 정의하고 사용할 수 있다. 소스 코드는 컴퓨터 실행가능 형태일 수 있거나(예컨대, 인터프리터를 통해), 소스 코드는 (예컨대, 트랜슬레이터, 어셈블러, 또는 컴파일러를 통해) 컴퓨터 실행가능 형태로 변환되 거나, 또는 바이트 코드와 같은 중간 형태로 변환될 수 있다. 적절한 경우, 전술한 것들 중 임의의 것은 순차 적이든, 조합적이든, 상태 머신들이든, 또는 다른 방식이든 관계없이, 적절한 개별 또는 집적 회로들을 구축하 거나 기술하는 데 사용될 수 있다. 일 예에서, 도면들의 임의의 수의 전기 회로들이 연관된 전자 디바이스의 보드 상에 구현될 수 있다. 보드는 전자 디바이스의 내부 전자 시스템의 다양한 컴포넌트들을 유지할 수 있고 또한 다른 주변 디바이스들에 대한 커넥터들을 제공하는 일반적인 회로 보드일 수 있다. 보다 구체적으로, 보드는 시스템의 다른 컴포넌트들이 전 기적으로 통신할 수 있는 전기 연결들을 제공할 수 있다. 임의의 적합한 프로세서 및 메모리는 특정 구성 요구 들, 프로세싱 요구들, 및 컴퓨팅 설계들에 기초하여 보드에 적합하게 결합될 수 있다. 외부 스토리지, 추가적 인 센서들, 오디오/비디오 디스플레이를 위한 컨트롤러들, 및 주변 디바이스들과 같은 다른 컴포넌트들이 플러 그-인 카드들로서, 또는 케이블들을 통해 보드에 부착되거나, 또는 보드 자체에 통합될 수 있다. 다른 예에서, 도면들의 전기 회로들은 독립형 모듈들(예컨대, 특정 애플리케이션 또는 기능을 수행하도록 구성되는 연관된 컴 포넌트들 및 회로를 갖는 디바이스)로서 구현될 수 있거나, 또는 전자 디바이스들의 애플리케이션 특정 하드웨 어로 플러그-인 모듈들로서 구현될 수 있다. 본 명세서에 제공된 다수의 예들에 의해, 2개, 3개, 4개 또는 그 이상의 전기 컴포넌트들에 관하여 상호작용이 설명될 수 있다는 점에 유의한다. 그러나, 이것은 단지 명확성 및 예를 위해 행해졌다. 시스템은 임의의 적합 한 방식으로 통합 또는 재구성될 수 있다는 것을 이해해야 한다. 유사한 설계 대안들을 따라, 도면들의 예시된 컴포넌트들, 모듈들 및 요소들 중 임의의 것은 다양한 가능한 구성들로 조합될 수 있으며, 이들 모두는 본 명세 서의 넓은 범위 내에 있다. 특정 경우들에서, 단지 제한된 수의 전기 요소들을 참조함으로써 주어진 세트의 흐 름들의 기능성들 중 하나 이상을 설명하는 것이 더 용이할 수 있다. 도면들의 전기 회로들 및 그의 교시내용들 은 용이하게 확장가능하고, 많은 수의 컴포넌트들뿐만 아니라, 더 복잡한/정교한 배열들 및 구성들을 수용할 수 있다는 것을 이해해야 한다. 따라서, 제공되는 예들은 범위를 제한하거나 무수한 다른 아키텍처들에 잠재적으 로 적용되는 전기 회로들의 광범위한 교시내용들을 저해해서는 안 된다."}
{"patent_id": "10-2019-0063040", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 30, "content": "다수의 다른 변경들, 치환들, 변형들, 개조들, 및 수정들이 본 기술분야의 통상의 기술자에게 확인될 수 있고, 본 개시내용이 첨부된 청구항들의 범위 내에 속하는 모든 그러한 변경들, 치환들, 변형들, 개조들, 및 수정들을포함하는 것으로 의도된다. 예시적인 구현들 다음의 예들은 본 개시내용 전체에 걸쳐 설명된 실시예들과 관련된다. 하나 이상의 실시예는 장치를 포함할 수 있고, 이는: 로그 회로를 포함하고, 상기 로그 회로는: 입력 레지스터 를 통해, 로그 연산과 연관된 입력을 식별하고 - 상기 로그 연산은 구분적 선형 근사를 이용하여 상기 로그 회 로에 의해 수행됨 -; 범위 선택 회로를 이용하여, 상기 입력이 속하는 제1 범위를 식별하고 - 상기 제1 범위는 상기 로그 연산에 대한 복수의 구분적 선형 근사(PLA) 방정식과 연관된 복수의 범위로부터 식별되고, 상기 제1 범위는 상기 복수의 PLA 방정식 중 제1 방정식에 대응함 -; 상기 제1 방정식과 연관된 복수의 피연산자를 획득 하고; 가산기-감산기 회로를 이용하여, 상기 복수의 피연산자에 기초하여 상기 제1 방정식의 결과를 계산하고; 출력 레지스터를 통해, 상기 로그 연산과 연관된 출력을 반환하는 회로를 포함하고, 상기 출력은 상기 제1 방정 식의 결과에 적어도 부분적으로 기초하여 생성된다. 장치의 하나의 예시적인 실시예에서, 상기 로그 연산은 인공 뉴럴 네트워크 연산과 연관된다. 장치의 하나의 예시적인 실시예에서, 상기 입력은 부동 소수점 수를 포함하고, 상기 부동 소수점 수는 지수 및 가수를 포함하고; 상기 출력은 고정 소수점 수를 포함하고, 상기 고정 소수점 수는 정수 및 분수를 포함한다. 장치의 하나의 예시적인 실시예에서, 상기 복수의 피연산자는 상기 가수 및 하나 이상의 분수 피연산자를 포함 하고, 상기 하나 이상의 분수 피연산자 각각은 2의 거듭제곱을 포함하는 분모를 포함한다. 장치의 하나의 예시적인 실시예에서, 상기 로그 회로는 상기 하나 이상의 분수 피연산자를 생성하는 하나 이상 의 시프트 회로를 추가로 포함한다. 장치의 하나의 예시적인 실시예에서, 상기 로그 회로는 바이어스되지 않은 지수를 생성하기 위해 상기 부동 소 수점 수의 상기 지수로부터 바이어스를 감산하는 감산기 회로를 추가로 포함한다. 장치의 하나의 예시적인 실시예에서, 상기 출력 레지스터를 통해, 상기 로그 연산과 연관된 출력을 반환하는 상 기 회로는 추가로: 상기 바이어스되지 않은 지수에 기초하여 상기 고정 소수점 수의 상기 정수를 생성하고; 상 기 제1 방정식의 결과에 기초하여 상기 고정 소수점 수의 상기 분수를 생성한다. 장치의 하나의 예시적인 실시예에서, 상기 로그 회로는 상기 제1 방정식과 연관된 상기 복수의 피연산자를 선택 하는 하나 이상의 다중화기를 추가로 포함한다. 장치의 하나의 예시적인 실시예에서, 상기 가산기-감산기 회로는 상기 복수의 피연산자에 대해 하나 이상의 가 산 또는 감산 연산을 수행한다. 장치의 하나의 예시적인 실시예에서, 상기 장치는 안티로그 회로를 추가로 포함하고, 상기 안티로그 회로는: 안 티로그 연산과 연관된 제2 입력을 식별하고 - 상기 안티로그 연산은 구분적 선형 근사를 이용하여 상기 안티로 그 회로에 의해 수행됨 -; 상기 제2 입력이 속하는 제2 범위를 식별하고 - 상기 제2 범위는 상기 안티로그 연산 에 대한 제2 복수의 구분적 선형 근사(PLA) 방정식과 연관된 제2 복수의 범위로부터 식별되고, 상기 제2 범위는 상기 제2 복수의 PLA 방정식 중 제2 방정식에 대응함 -; 상기 제2 방정식과 연관된 제2 복수의 피연산자에 기초 하여 상기 제2 방정식의 제2 결과를 계산하고; 상기 안티로그 연산과 연관된 제2 출력을 생성하는 회로를 포함 하고, 상기 제2 출력은 상기 제2 방정식의 상기 제2 결과에 적어도 부분적으로 기초하여 생성된다. 장치의 하나의 예시적인 실시예에서, 상기 장치는 활성화 함수 회로를 추가로 포함하고, 상기 활성화 함수 회로 는 상기 로그 회로 및 상기 안티로그 회로를 포함하고, 상기 활성화 함수 회로는: 복수의 이용가능한 활성화 함 수로부터 선택된 활성화 함수를 수행하기 위한 명령을 수신하고 - 상기 활성화 함수는 하나 이상의 승산 또는 제산 연산을 포함함 -; 하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 하나 이상의 승산 또 는 제산 연산을 수행하고 - 상기 하나 이상의 로그 연산은 상기 로그 회로를 이용하여 수행되고 상기 하나 이상 의 안티로그 연산은 상기 안티로그 회로를 이용하여 수행됨 -; 상기 활성화 함수와 연관된 활성화 출력을 생성 하는 회로를 추가로 포함하고, 상기 활성화 출력은 상기 하나 이상의 승산 또는 제산 연산의 하나 이상의 결과 에 적어도 부분적으로 기초하여 생성된다. 장치의 하나의 예시적인 실시예에서, 상기 활성화 함수는 하나 이상의 지수 연산을 추가로 포함하고; 상기 활성 화 함수 회로는 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하는 지수 회로를 추가로 포함 한다.하나 이상의 실시예는 시스템을 포함할 수 있고, 이는: 애플리케이션과 연관된 정보를 저장하는 메모리; 상기 애플리케이션과 연관된 하나 이상의 명령어를 실행하는 프로세서; 복수의 활성화 함수를 수행하는 활성화 함수 회로를 포함하고, 상기 활성화 함수 회로는: 상기 애플리케이션과 연관된 활성화 함수를 수행하기 위한 명령을 수신하고 - 상기 활성화 함수는 상기 복수의 활성화 함수로부터 선택되고, 상기 활성화 함수는 하나 이상의 승 산 또는 제산 연산을 포함함 -; 하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 상기 하나 이 상의 승산 또는 제산 연산을 수행하고 - 상기 하나 이상의 로그 연산은 구분적 선형 근사를 이용하여 로그 회로 에 의해 수행되고, 상기 하나 이상의 안티로그 연산은 구분적 선형 근사를 이용하여 안티로그 회로에 의해 수행 됨 -; 상기 활성화 함수와 연관된 출력을 생성하는 회로를 포함하고, 상기 출력은 상기 하나 이상의 승산 또는 제산 연산의 하나 이상의 결과에 적어도 부분적으로 기초하여 생성된다. 시스템의 하나의 예시적인 실시예에서, 상기 애플리케이션은 인공 뉴럴 네트워크를 포함하고, 상기 활성화 함수 는 상기 인공 뉴럴 네트워크의 연산과 연관된다. 시스템의 하나의 예시적인 실시예에서, 상기 하나 이상의 로그 연산 및 상기 하나 이상의 안티로그 연산을 이용 하여 상기 하나 이상의 승산 또는 제산 연산을 수행하는 상기 회로는 추가로: 상기 하나 이상의 승산 또는 제산 연산과 연관된 하나 이상의 피연산자에 대해 하나 이상의 로그 베이스 2 연산을 수행하고 - 상기 하나 이상의 로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행됨 -; 상기 하나 이상의 로그 베이스 2 연산의 하나 이 상의 결과에 대해 하나 이상의 가산 또는 감산 연산을 수행하고; 상기 하나 이상의 가산 또는 감산 연산의 하나 이상의 결과에 대해 하나 이상의 안티로그 베이스 2 연산을 수행하고, 상기 하나 이상의 안티로그 베이스 2 연 산은 구분적 선형 근사를 이용하여 수행된다. 시스템의 하나의 예시적인 실시예에서, 상기 활성화 함수는 하나 이상의 지수 연산을 추가로 포함하고; 상기 활 성화 함수 회로는 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하는 회로를 추가로 포함한 다. 시스템의 하나의 예시적인 실시예에서, 상기 하나 이상의 지수 연산 각각은 2의 베이스를 포함하고; 구분적 선 형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하는 상기 회로는 추가로, 하나 이상의 안티로그 베이스 2 연산을 이용하여 상기 하나 이상의 지수 연산을 수행하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분 적 선형 근사를 이용하여 수행된다. 시스템의 하나의 예시적인 실시예에서, 상기 복수의 활성화 함수는: sigmoid 함수; 쌍곡선 탄젠트 함수; swish 함수; 및 정류 선형 유닛 함수를 포함한다. 시스템의 하나의 예시적인 실시예에서, 상기 sigmoid 함수, 상기 쌍곡선 탄젠트 함수, 또는 상기 swish 함수 중 적어도 하나는 2의 베이스를 배타적으로 포함하는 하나 이상의 지수 연산을 이용하여 정의되고; 상기 활성화 함 수 회로는 하나 이상의 안티로그 베이스 2 연산을 이용하여 상기 하나 이상의 지수 연산을 수행하는 회로를 추 가로 포함하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행된다. 하나 이상의 실시예는 명령어들이 저장된 적어도 하나의 머신 액세스 가능한 저장 매체를 포함할 수 있고, 상기 명령어들은 머신에서 실행될 때, 상기 머신으로 하여금: 상기 활성화 함수 회로에 의해, 복수의 이용가능한 활 성화 함수로부터 선택된 활성화 함수를 수행하기 위한 명령을 수신하고 - 상기 활성화 함수는 하나 이상의 승산 또는 제산 연산을 포함함 -; 하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 상기 하나 이상 의 승산 또는 제산 연산을 수행하고 - 상기 하나 이상의 로그 연산 및 상기 하나 이상의 안티로그 연산은 구분 적 선형 근사를 이용하여 수행됨 -; 상기 활성화 함수와 연관된 출력을 생성하게 하고, 상기 출력은 상기 하나 이상의 승산 또는 제산 연산의 하나 이상의 결과에 적어도 부분적으로 기초하여 생성된다. 저장 매체의 하나의 예시적인 실시예에서, 상기 머신으로 하여금 상기 하나 이상의 로그 연산 및 상기 하나 이 상의 안티로그 연산을 이용하여 상기 하나 이상의 승산 또는 제산 연산을 수행하게 하는 상기 명령어들은 추가 로 상기 머신으로 하여금: 상기 하나 이상의 승산 또는 제산 연산과 연관된 하나 이상의 피연산자에 대해 하나 이상의 로그 베이스 2 연산을 수행하고 - 상기 하나 이상의 로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행됨 -; 상기 하나 이상의 로그 베이스 2 연산의 하나 이상의 결과에 대해 하나 이상의 가산 또는 감산 연산 을 수행하고; 상기 하나 이상의 가산 또는 감산 연산의 하나 이상의 결과에 대해 하나 이상의 안티로그 베이스 2 연산을 수행하게 하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행된다. 저장 매체의 하나의 예시적인 실시예에서, 상기 활성화 함수는 하나 이상의 지수 연산을 추가로 포함하고; 상기 명령어들은 추가로 상기 머신으로 하여금 구분적 선형 근사를 이용하여 상기 하나 이상의 지수 연산을 수행하게한다. 저장 매체의 하나의 예시적인 실시예에서, 상기 복수의 이용가능한 활성화 함수 중 적어도 하나의 활성화 함수 는 2의 베이스를 배타적으로 포함하는 하나 이상의 지수 연산을 이용하여 정의되고; 상기 명령어들은 추가로 상 기 머신으로 하여금 하나 이상의 안티로그 베이스 2 연산을 이용하여 상기 하나 이상의 지수 연산을 수행하게 하고, 상기 하나 이상의 안티로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행된다. 하나 이상의 실시예는 방법을 포함할 수 있고, 이는: 활성화 함수 회로에 의해, 복수의 이용가능한 활성화 함수 로부터 선택된 활성화 함수를 수행하기 위한 명령을 수신하는 단계 - 상기 활성화 함수는 하나 이상의 승산 또 는 제산 연산을 포함함 -; 하나 이상의 로그 연산 및 하나 이상의 안티로그 연산을 이용하여 상기 하나 이상의 승산 또는 제산 연산을 수행하는 단계 - 상기 하나 이상의 로그 연산 및 상기 하나 이상의 안티로그 연산은 구 분적 선형 근사를 이용하여 수행됨 -; 상기 활성화 함수와 연관된 출력을 생성하는 단계를 포함하고, 상기 출력 은 상기 하나 이상의 승산 또는 제산 연산의 하나 이상의 결과에 적어도 부분적으로 기초하여 생성된다. 방법의 하나의 예시적인 실시예에서, 상기 방법은 상기 하나 이상의 승산 또는 제산 연산과 연관된 하나 이상의 피연산자에 대해 하나 이상의 로그 베이스 2 연산을 수행하는 단계 - 상기 하나 이상의 로그 베이스 2 연산은 구분적 선형 근사를 이용하여 수행됨 -; 상기 하나 이상의 로그 베이스 2 연산의 하나 이상의 결과에 대해 하나 이상의 가산 또는 감산 연산을 수행하는 단계; 상기 하나 이상의 가산 또는 감산 연산의 하나 이상의 결과에 대 해 하나 이상의 안티로그 베이스 2 연산을 수행하는 단계를 추가로 포함하고, 상기 하나 이상의 안티로그 베이 스 2 연산은 구분적 선형 근사를 이용하여 수행된다.도면 도면1 도면2a 도면2b 도면3a 도면3b 도면3c 도면3d 도면3e 도면4 도면5a 도면5b 도면5c 도면6a 도면6b 도면6c 도면7 도면8 도면9a 도면9b 도면10a 도면10b 도면10c 도면10d 도면10e 도면11a 도면11b 도면11c 도면12a 도면12b 도면13 도면14a 도면14b 도면15 도면16 도면17 도면18"}
{"patent_id": "10-2019-0063040", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시내용은 첨부된 도면들과 함께 읽을 때 다음의 상세한 설명으로부터 가장 잘 이해된다. 산업에서의 표준 관행에 따라, 다양한 특징들이 반드시 축척대로 그려진 것은 아니며, 단지 예시 목적으로 사용된다는 점이 강조 된다. 축척이 명시적으로 또는 암시적으로 도시되는 경우, 그것은 단지 하나의 예시적인 예를 제공한다. 다른 실시예들에서, 다양한 피처들의 치수들은 논의의 명확성을 위해 임의로 증가되거나 감소될 수 있다. 도 1은 로그 및 안티로그 구분적 선형 근사 회로들을 이용하여 구현된 심층 뉴럴 네트워크(DNN)의 예시적인 실 시예를 예시한다. 도 2a 및 도 2b는 심층 뉴럴 네트워크(DNN)를 위한 통일된 활성화 함수 회로의 예시적인 실시예를 예시한다. 도 3a 내지 도 3e는 통일된 활성화 함수 회로에 대한 예시적인 활성화 함수들을 예시한다. 도 4는 베이스 2 지수 항들을 갖는 수정된 활성화 함수 방정식들을 이용하여 구현된 통일된 활성화 함수 회로의 예시적인 실시예를 예시한다. 도 5a 내지 도 5c는 구분적 선형 근사를 이용하여 구현된 로그 회로의 예시적인 실시예를 예시한다. 도 6a 내지 도 6c는 구분적 선형 근사를 이용하여 구현된 안티로그 회로의 예시적인 실시예들을 예시한다. 도 7은 구분적 선형 근사를 이용하여 구현된 지수 회로의 예시적인 실시예를 예시한다. 도 8은 인공 뉴럴 네트워크를 구현하는 데 사용되는 예시적인 프로세싱 아키텍처에 대한 흐름도를 예시한다. 도 9a 및 도 9b는 지원되는 병렬 연산의 수에 관하여 인공 뉴럴 네트워크들에 대한 예시적인 프로세싱 아키텍처 의 확장성을 예시한다. 도 10a 내지 도 10e는 인공 뉴럴 네트워크에 대한 예시적인 프로세싱 아키텍처의 다양한 성능 양태들을 예시한 다. 도 11a 내지 도 11c는 베이스 2 지수 항들을 갖는 수정된 활성화 함수들 대 종래의 활성화 함수들을 이용하여 구현된 DNN들의 예들을 예시한다. 도 12a 및 도 12b 및 도 13은 수정된 활성화 함수들 대 종래의 활성화 함수들을 이용하여 구현된 DNN들의 다양 한 성능 양태들을 예시한다. 도 14a 및 도 14b, 도 15, 도 16, 도 17 및 도 18은 본 명세서에 개시된 실시예들에 따라 사용될 수 있는 컴퓨 터 아키텍처들의 예시적인 구현들을 예시한다."}
