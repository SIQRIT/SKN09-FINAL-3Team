{"patent_id": "10-2023-0081607", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0000144", "출원번호": "10-2023-0081607", "발명의 명칭": "문법 오류 유형을 분석하는 시스템 및 방법", "출원인": "미디어젠", "발명자": "홍연정"}}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "문법 오류 유형을 분석하는 시스템에 있어서,프로세서;및메모리를 포함하고,상기 프로세서는사용자 입력에 기반하여 제 1 문장을 수신하고,오류 문장과 교정 문장이 포함된 빅데이터에 기반하여 수신된 문장에서 문법적으로 오류가 있는지 결정 후 문법적으로 오류가 발견됨에 기반하여 상기 제 1 문장이 수정된 제 2 문장을 출력하며,상기 제 1 문장과 상기 제 2 문장을 형태소 단위로 나눠 토큰(token)화하고,상기 제 1 문장 및 상기 제 2 문장에 대해 각각 토큰 단위로 분석하여 토큰 별로 태그(tag), 품사 정보(part ofspeech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나에 대한 정보를 출력하고,출력된 정보에 기반하여 입력된 문장에서 수정된 부분의 위치를 결정하고,수정된 부분의 위치 및 출력된 정보에 기반하여 문법 오류 유형을 결정하는 시스템."}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1항에 있어서,상기 프로세서는상기 제 1 문장 및 상기 제 2 문장에 대해 각각 토큰 단위로 분석하여 토큰 별로 태그(tag), 품사 정보(part ofspeech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나를 비교하고,상기 제 1 문장 및 상기 제 2 문장에서 대응하는 토큰 중에서 품사 정보(part of speech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나가 일치하지 않음에 기반하여 해당 토큰이위치하는 부분에서 오류가 발생한 것으로 결정하는 시스템."}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,상기 프로세서는수정된 부분의 위치 및 출력된 정보에 따라 문법 오류 유형이 결정됨에 기반하여 사용자에 의해 입력된 문장,수정된 문장, 수정된 부분의 위치 및 문법 오류 유형에 대한 정보를 디스플레이 상에 표시하는 시스템."}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 프로세서는토큰화된 상기 제 1 문장 및 상기 제 2 문장에 대해 단어 간 거리(levenshtein distance)가 지정된 수준을 초과공개특허 10-2025-0000144-3-하는 토큰에 대해 수정이 발생한 것으로 결정하고,수정된 토큰에 대해 삭제(delete), 삽입(insert), 대체(substitute) 또는 변형(transpose) 중 적어도 어느 하나의 동작이 발생한 것인지 결정하는 시스템."}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4 항에 있어서,상기 프로세서는상기 제 1 문장과 상기 제 2 문장을 비교하여 태그(tag), 품사 정보(part of speech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 하나에 있어서 차이가 있는지 결정하고,수정된 토큰에 대해 삭제(delete), 삽입(insert), 대체(substitute) 또는 변형(transpose) 중 적어도 어느 하나의 동작이 발생한 것인지 결정된 부분 및 품사 정보(part of speech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 하나에 있어서 차이가 있는지 결정된 부분에 기반하여 오류 유형을 결정하는시스템."}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 5 항에 있어서,상기 프로세서는품사 정보에서 차이가 있는 것으로 결정됨에 기반하여 상기 제 1 문장과 상기 제 2 문장 상에서 주어 및 동사부분을 확인하고,수 일치 정보가 바뀌었음에 기반하여 오류유형은 동사의 수 일치 부분인 것으로 결정하는 시스템."}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 5 항에 있어서,상기 프로세서는단어 간 의존성(dependency)에서 차이가 있는 것으로 결정됨에 기반하여 변화된 부분이 능동태에서 수동태로 변화되었는지 또는 반대로 수동태에서 능동태로 변화되었는지 결정하고,변화된 부분이 능동태에서 수동태로 변화되었는지 또는 반대로 수동태에서 능동태로 변화되었음에 기반하여 오류유형은 동사의 시제 부분인 것으로 결정하는 시스템."}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 5 항에 있어서,상기 프로세서는표제어 추출(lemmatization)에서 차이가 있는 것으로 결정됨에 기반하여 변화된 부분이 표제어는 동일하고, 동사의 형태만 바뀐 것인지 확인하며,표제어는 동일하고, 동사의 형태만 바뀐 것으로 결정됨에 기반하여 오류 유형은 동사의 형태 부분인 것으로 결정하는 시스템."}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "공개특허 10-2025-0000144-4-전자 장치의 문법 오류 유형 분석 방법에 있어서사용자 입력에 기반하여 제 1 문장을 수신하는 동작;오류 문장과 교정 문장이 포함된 빅데이터에 기반하여 수신된 문장에서 문법적으로 오류가 있는지 결정 후 문법적으로 오류가 발견됨에 기반하여 상기 제 1 문장이 수정된 제 2 문장을 출력하는 동작;상기 제 1 문장과 상기 제 2 문장을 형태소 단위로 나눠 토큰(token)화하는 동작;상기 제 1 문장 및 상기 제 2 문장에 대해 각각 토큰 단위로 분석하여 태그(tag), 토큰 별로 품사 정보(part ofspeech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나에 대한 정보를 출력하는 동작;출력된 정보에 기반하여 입력된 문장에서 수정된 부분의 위치를 결정하는 동작;및수정된 부분의 위치 및 출력된 정보에 기반하여 문법 오류 유형을 결정하는 동작을 더 포함하는 방법."}
{"patent_id": "10-2023-0081607", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 9 항에 있어서,상기 제 1 문장 및 상기 제 2 문장에 대해 각각 토큰 단위로 분석하여 토큰 별로 태그(tag), 품사 정보(part ofspeech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나를 비교하는 동작;및상기 제 1 문장 및 상기 제 2 문장에서 대응하는 토큰 중에서 태그(tag), 품사 정보(part of speech), 단어 간의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나가 일치하지 않음에 기반하여 해당 토큰이 위치하는 부분에서 오류가 발생한 것으로 결정하는 동작을 더 포함하는 방법."}
{"patent_id": "10-2023-0081607", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "문법 오류 유형을 분석하는 시스템은 프로세서 및 메모리를 포함할 수 있다. 프로세서는 사용자 입력에 기반하여 제 1 문장을 수신하고, 오류 문장과 교정 문장이 포함된 빅데이터에 기반하여 수신된 문장에서 문법적으로 오류 가 있는지 결정 후 문법적으로 오류가 발견됨에 기반하여 상기 제 1 문장이 수정된 제 2 문장을 출력하며, 제 1 문장과 상기 제 2 문장을 형태소 단위로 나눠 토큰(token)화하고, 제 1 문장 및 상기 제 2 문장에 대해 각각 토 큰 단위로 분석하여 토큰 별로 품사 정보(part of speech), 단어 간 의존성(dependency) 또는 표제어 추출 (lemmatization) 중 적어도 어느 하나에 대한 정보를 출력하고, 출력된 정보에 기반하여 입력된 문장에서 수정된 부분의 위치를 결정하고, 수정된 부분의 위치 및 출력된 정보에 기반하여 문법 오류 유형을 결정할 수 있다."}
{"patent_id": "10-2023-0081607", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 문서는 사용자의 문장에서 문법 오류 유형을 분석하는 방법을 수행하는 시스템에 관한 것이다. 구체적으로는 사용자의 문장을 토큰화하여 구문을 분석하고, 수정된 문장과 비교하여 사용자 발화의 문법 오류 유형을 결정하 는 방법에 관한 것이다."}
{"patent_id": "10-2023-0081607", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능 시스템은 인간 수준의 지능을 구현하는 컴퓨터 시스템이며, 기계가 스스로 학습하고 판단하는 시스템 이다. 인공지능 시스템은 사용할수록 인식률이 향상되고 사용자 취향을 보다 정확하게 이해할 수 있게 되어, 기 존 규칙 기반 스마트 시스템은 점차 딥러닝 기반 인공지능 시스템으로 대체되고 있다. 인공지능 기술은 기계학 습(딥러닝) 및 기계학습을 활용한 요소 기술들로 구성된다. 기계학습은 입력 데이터들의 특징을 스스로 분류/학 습하는 알고리즘 기술이며, 요소기술은 딥러닝 등의 기계학습 알고리즘을 활용하여 인간 두뇌의 인지, 판단 기 능을 모사하는 기술로서, 언어적 이해, 시각적 이해, 추론/예측, 지식 표현, 동작 제어 등의 기술 분야로 구성 된다. 입력 패턴을 특정 그룹으로 분류하는 문제를 해결하는 방안으로써, 인간이 지니고 있는 효율적인 패턴 인식 방 법을 실제 컴퓨터에 적용시키려는 연구가 활발히 진행되고 있다. 이러한 연구 중 하나로, 인간의 생물학적 신경 세포의 특성을 수학적 표현에 의해 모델링한 인공의 뉴럴 네트워크(neural network)에 대한 연구가 있다. 입력 패턴을 특정 그룹으로 분류하는 문제를 해결하기 위해, 뉴럴 네트워크에서는 인간이 가지고 있는 학습이라는 능 력을 모방한 알고리즘을 이용한다. 이 알고리즘을 통하여 뉴럴 네트워크는 입력 패턴과 출력 패턴들 사이 의 사 상(mapping)을 생성해낼 수 있는데, 이를 뉴럴 네트워크가 학습 능력이 있다고 표현한다. 또한, 뉴럴 네트워크 는 학습된 결과에 기초하여 학습에 이용되지 않았던 입력 패턴에 대하여 비교적 올바른 출력을 생성할 수 있는일반화 능력을 가지고 있다."}
{"patent_id": "10-2023-0081607", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "문법 오류 유형을 분석하는 방법 및 시스템은 오류 문장과 수정 문장을 토큰화화여 분석하고, 오류 위치 및 문 장 구문 분석 정보에 기반하여 문법 오류 유형을 결정하려는 목적을 갖는다."}
{"patent_id": "10-2023-0081607", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "문법 오류 유형을 분석하는 시스템은 프로세서 및 메모리를 포함할 수 있다. 프로세서는 사용자 입력에 기반하 여 제 1 문장을 수신하고, 오류 문장과 교정 문장이 포함된 빅데이터에 기반하여 수신된 문장에서 문법적으로 오류가 있는지 결정 후 문법적으로 오류가 발견됨에 기반하여 상기 제 1 문장이 수정된 제 2 문장을 출력하며, 제 1 문장과 제 2 문장을 형태소 단위로 나눠 토큰(token)화하고, 제 1 문장 및 제 2 문장에 대해 각각 토큰 단 위로 분석하여 토큰 별로 품사 정보(part of speech), 단어 간 의존성(dependency) 또는 표제어 추출 (lemmatization) 중 적어도 어느 하나에 대한 정보를 출력하고, 출력된 정보에 기반하여 입력된 문장에서 수정 된 부분의 위치를 결정하고, 수정된 부분의 위치 및 출력된 정보에 기반하여 문법 오류 유형을 결정할 수 있다."}
{"patent_id": "10-2023-0081607", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "문법 오류 유형을 분석하는 방법 및 시스템은 오류 문장과 수정 문장을 토큰화화여 분석하고, 문법 오류 유형을 결정하여 영어 문장 학습을 수행하는 사용자에게 정확한 솔루션을 제공할 수 있다. 본 문서에 따른 문법 오류 유형을 분석하는 방법 및 시스템은 오류 문장과 수정된 문장을 동시에 표시하고, 수 정된 위치와 문법적인 오류 유형에 대한 정보를 한 번에 제공하여 사용자가 자신이 실수한 부분이 무엇인지 한 눈에 알아보고 개선할 수 있다."}
{"patent_id": "10-2023-0081607", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하에서, 첨부된 도면을 참조하여 실시예들을 상세하게 설명한다. 그러나, 실시예들에는 다양한 변경이 가해질 수 있어서 특허출원의 권리 범위가 이러한 실시예들에 의해 제한되거나 한정되는 것은 아니다. 실시예들에 대한 모든 변경, 균등물 내지 대체물이 권리 범위에 포함되는 것으로 이해되어야 한다. 실시예들에 대한 특정한 구조적 또는 기능적 설명들은 단지 예시를 위한 목적으로 개시된 것으로서, 다양한 형 태로 변경되어 실시될 수 있다. 따라서, 실시예들은 특정한 개시형태로 한정되는 것이 아니며, 본 명세서의 범 위는 기술적 사상에 포함되는 변경, 균등물, 또는 대체물을 포함한다. 제1 또는 제2 등의 용어를 다양한 구성요소들을 설명하는데 사용될 수 있지만, 이런 용어들은 하나의 구성요소 를 다른 구성요소로부터 구별하는 목적으로만 해석되어야 한다. 예를 들어, 제1 구성요소는 제2 구성요소로 명 명될 수 있고, 유사하게 제2 구성요소는 제1 구성요소로도 명명될 수 있다.어떤 구성요소가 다른 구성요소에 \"연결되어\" 있다고 언급된 때에는, 그 다른 구성요소에 직접적으로 연결되어 있거나 또는 접속되어 있을 수도 있지만, 중간에 다른 구성요소가 존재할 수도 있다고 이해되어야 할 것이다. 실시예에서 사용한 용어는 단지 설명을 목적으로 사용된 것으로, 한정하려는 의도로 해석되어서는 안된다. 단수 의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\" 또는 \"가지다\" 등의 용어는 명세서 상에 기재된 특징, 숫자, 단계, 동작, 구성요소, 부품 또는 이들을 조합한 것이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부품 또는 이 들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 실시예가 속 하는 기술 분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가지고 있다. 일반 적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥 상 가지는 의미와 일치하는 의미 를 가지는 것으로 해석되어야 하며, 본 출원에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적인 의미로 해석되지 않는다. 또한, 첨부 도면을 참조하여 설명함에 있어, 도면 부호에 관계없이 동일한 구성 요소는 동일한 참조부호를 부여 하고 이에 대한 중복되는 설명은 생략하기로 한다. 실시예를 설명함에 있어서 관련된 공지 기술에 대한 구체적 인 설명이 실시예의 요지를 불필요하게 흐릴 수 있다고 판단되는 경우 그 상세한 설명을 생략한다. 실시예들은 퍼스널 컴퓨터, 랩톱 컴퓨터, 태블릿 컴퓨터, 스마트 폰, 텔레비전, 스마트 가전 기기, 지능형 자동 차, 키오스크, 웨어러블 장치 등 다양한 형태의 제품으로 구현될 수 있다. 실시예들은 퍼스널 컴퓨터, 랩톱 컴퓨터, 태블릿 컴퓨터, 스마트 폰, 텔레비전, 스마트 가전 기기, 지능형 자동 차, 키오스크, 웨어러블 장치 등 다양한 형태의 제품으로 구현될 수 있다. 인공지능(Artificial Intelligence, AI) 시스템은 인간 수준의 지능을 구현하는 컴퓨터 시스템이며, 기존 규칙 (Rule) 기반의 스마트 시스템과 달리 기계가 스스로 학습하고 판단하는 시스템이다. 인공지능 시스템은 사용할 수록 인식률이 향상되고 사용자 취향을 보다 정확하게 이해할 수 있게 되어, 기존 규칙 기반의 스마트 시스템은 점차 심층 학습(Deep Learning) 기반 인공지능 시스템으로 대체되고 있다. 인공지능 기술은 기계 학습 및 기계 학습을 활용한 요소기술들로 구성된다. 기계 학습은 입력 데이터들의 특징 을 스스로 분류/학습하는 알고리즘 기술이며, 요소기술은 심층 학습 등의 기계 학습 알고리즘을 활용하여 인간 두뇌의 인지, 판단 등의 기능을 모사하는 기술로서, 언어적 이해, 시각적 이해, 추론/예측, 지식 표현, 동작 제 어 등의 기술 분야로 구성된다. 인공지능 기술이 응용되는 다양한 분야는 다음과 같다. 언어적 이해는 인간의 언어/문자를 인식하고 응용/처리 하는 기술로서, 자연어 처리, 기계 번역, 대화시스템, 질의 응답, 음성 인식/합성 등을 포함한다. 시각적 이해 는 사물을 인간의 시각처럼 인식하여 처리하는 기술로서, 객체 인식, 객체 추적, 영상 검색, 사람 인식, 장면이 해, 공간 이해, 영상 개선 등을 포함한다. 추론 예측은 정보를 판단하여 논리적으로 추론하고 예측하는 기술로 서, 지식/확률 기반 추론, 최적화 예측, 선호 기반 계획, 추천 등을 포함한다. 지식 표현은 인간의 경험정보를 지식데이터로 자동화 처리하는 기술로서, 지식 구축(데이터 생성/분류), 지식 관리(데이터 활용) 등을 포함한다. 동작 제어는 차량의 자율 주행, 로봇의 움직임을 제어하는 기술로서, 움직임 제어(항법, 충돌, 주 행),조작 제어(행동 제어) 등을 포함한다. 일반적으로 기계 학습 알고리즘을 실생활에 적용하기 위해서는 기계 학습의 기본 방법론의 특성상 Trial and Error 방식으로 학습을 수행하게 된다. 특히, 심층 학습의 경우 수십만 번의 반복 실행을 필요로 한다. 이를 실 제 물리적인 외부 환경에서 실행하기는 불가능하여 대신 실제 물리적인 외부 환경을 컴퓨터상에서 가상으로 구 현하여 시뮬레이션을 통해 학습을 수행한다. 본 발명에서, 인공지능(Artificial Intelligence, AI)은 인간의 학습능력, 추론능력, 지각능력 등을 모방하고, 이를 컴퓨터로 구현하는 기술을 의미하고, 기계 학습, 심볼릭 로직(Symbolic Logic) 등의 개념을 포함할 수 있 다. 기계 학습(Machine Learning, ML)은 입력 데이터들의 특징을 스스로 분류 또는 학습하는 알고리즘 기술이 다. 인공지능의 기술은 기계 학습의 알고리즘으로써 입력 데이터를 분석하고, 그 분석의 결과를 학습하며, 그 학습의 결과에 기초하여 판단이나 예측을 할 수 있다. 또한, 기계 학습의 알고리즘을 활용하여 인간 두뇌의 인 지, 판단 등의 기능을 모사하는 기술들 역시 인공지능의 범주로 이해될 수 있다. 예를 들어, 언어적 이해, 시 각적 이해, 추론/예측, 지식 표현, 동작 제어 등의 기술 분야가 포함될 수 있다.기계 학습은 데이터를 처리한 경험을 이용해 신경망 모델을 훈련시키는 처리를 의미할 수 있다. 기계 학습을 통 해 컴퓨터 소프트웨어는 스스로 데이터 처리 능력을 향상시키는 것을 의미할 수 있다. 신경망 모델은 데이터 사 이의 상관 관계를 모델링하여 구축된 것으로서, 그 상관 관계는 복수의 파라미터에 의해 표현될 수 있다. 신 경 망 모델은 주어진 데이터로부터 특징들을 추출하고 분석하여 데이터 간의 상관 관계를 도출하는데, 이러한 과 정을 반복하여 신경망 모델의 파라미터를 최적화해 나가는 것이 기계 학습이라고 할 수 있다. 예를 들어, 신경 망 모델은 입출력 쌍으로 주어지는 데이터에 대하여, 입력과 출력 사이의 매핑(상관 관계)을 학습할 수 있다. 또는, 신경망 모델은 입력 데이터만 주어지는 경우에도 주어진 데이터 사이의 규칙성을 도출하여 그 관계를 학 습할 수도 있다. 인공지능 학습모델 또는 신경망 모델은 인간의 뇌 구조를 컴퓨터 상에서 구현하도록 설계될 수 있으며, 인간의 신경망의 뉴런(neuron)을 모의하며 가중치를 가지는 복수의 네트워크 노드들을 포함할 수 있다. 복수의 네트워 크 노드들은 뉴런이 시냅스(synapse)를 통하여 신호를 주고받는 뉴런의 시냅틱(synaptic) 활동을 모의하여, 서 로 간의 연결 관계를 가질 수 있다. 인공지능 학습모델에서 복수의 네트워크 노드들은 서로 다른 깊이의 레이 어에 위치하면서 컨볼루션(convolution) 연결 관계에 따라 데이터를 주고받을 수 있다. 인공지능 학습모델은, 예를 들어, 인공 신경망 모델(Artificial Neural Network), 컨볼루션 신경망 모델(Convolution Neural Network: CNN) 등일 수 있다. 일 실시예로서, 인공지능 학습모델은, 지도학습(Supervised Learning), 비지도 학습(Unsupervised Learning), 강화 학습(Reinforcement Learning) 등의 방식에 따라 기계 학습될 수 있다. 기 계 학습을 수행하기 위한 기계 학습 알고리즘에는, 의사결정트리(Decision Tree), 베이지안 망(Bayesian Network), 서포트 벡터 머신(Support Vector Machine), 인공 신경망(Artificial Neural Network), 에이다부스 트(Ada-boost), 퍼셉트론(Perceptron), 유전자 프로그래밍(Genetic Programming), 군집화(Clustering) 등이 사 용될 수 있다. 이중, CNN은 최소한의 전처리(preprocess)를 사용하도록 설계된 다계층 퍼셉트론(multilayer perceptrons)의 한 종류이다. CNN은 하나 또는 여러 개의 합성곱 계층과 그 위에 올려진 일반적인 인공 신경망 계층들로 이루 어져 있으며, 가중치와 통합 계층(pooling layer)들을 추가로 활용한다. 이러한 구조 덕분에 CNN은 2차원 구조 의 입력 데이터를 충분히 활용할 수 있다. 다른 딥러닝 구조들과 비교해서, CNN은 영상, 음성 분야 모두에서 좋 은 성능을 보여준다. CNN은 또한 표준 역전달을 통해 훈련될 수 있다. CNN은 다른 피드포워드 인공신경망 기법 들보다 쉽게 훈련되는 편이고 적은 수의 매개변수를 사용한다는 이점이 있다. 컨볼루션 네트워크는 묶인 파라미터들을 가지는 노드들의 집합들을 포함하는 신경 네트워크들이다. 사용 가능 한 트레이닝 데이터의 크기 증가와 연산 능력의 가용성이, 구분적 선형 단위 및 드롭아웃 트레이닝과 같은 알고 리즘 발전과 결합되어, 많은 컴퓨터 비전 작업들이 크게 개선되었다. 오늘날 많은 작업에 사용할 수 있는 데이 터 세트들과 같은 엄청난 양의 데이터 세트에서는 초과 맞춤(outfitting)이 중요하지 않으며, 네트워크의 크기 를 늘리면 테스트 정확도가 향상된다. 컴퓨팅 리소스들의 최적 사용은 제한 요소가 된다. 이를 위해, 심층 신 경 네트워크들의 분산된, 확장 가능한 구현예가 사용될 수 있다. 도 1은 일실시예에 따른 문법 오류 유형을 분석하는 시스템의 구성을 블록도로 나타낸 것이다. 일 실시예에 따른 시스템은 프로세서 및 메모리를 포함할 수 있으며, 도시된 구성 중 일부가 생 략 또는 치환 될 수도 있다. 일 실시예에 따른 시스템은 서버 또는 단말일 수 있다. 일 실시예에 따르면, 프로세서는 시스템의 각 구성 요소들의 제어 및/또는 통신에 관한 연산이나 데이터 처리를 수행할 수 있는 구성으로써, 하나 이상의 프로세서들로 구성될 수 있다. 메모리는 상술한 방법과 관련된 정보를 저장 하거나 상술한 방법이 구현된 프로그램을 저장할 수 있다. 메모리는 휘발성 메모리 또는 비휘발성 메모리 일 수 있다. 메모리는 다양한 파일 데이터들을 저장할 수 있으며, 프로세서의 동작에 따라 저장된 파 일 데이터들은 업데이트 될 수 있다. 일 실시예에 따르면, 프로세서는 프로그램을 실행하고, 시스템을 제어할 수 있다. 프로세서에 의하여 실행되는 프로그램의 코드는 메모리에 저장될 수 있다. 프로세서의 동작들은 메모리에 저장된 인스트럭션들을 로딩(loading)함으로써 수행될 수 있다. 시스템은 입출력 장치(도면 미 표시)를 통 하여 외부 장치(예를 들어, 퍼스널 컴퓨터 또는 네트워크)에 연결되고, 데이터를 교환할 수 있다. 일 실시예에 따르면, 프로세서는 사용자 입력에 기반하여 제 1 문장을 수신하고, 문법 교정 모델을 이용하 여 수신된 문장에서 문법적으로 오류가 있는지 결정 후 문법적으로 오류가 발견됨에 기반하여 상기 제 1 문장이수정된 제 2 문장을 출력하며, 제 1 문장과 상기 제 2 문장을 의미있는 단위로 나눠 토큰(token)화하고, 제 1 문장 및 상기 제 2 문장에 대해 각각 토큰 단위로 분석하여 토큰 별로 품사 정보(part of speech), 단어 간 의 존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나에 대한 정보를 출력하고, 출력된 정보 에 기반하여 입력된 문장에서 수정된 부분의 위치를 결정하고, 수정된 부분의 위치 및 출력된 정보에 기반하여 문법 오류 유형을 결정할 수 있다. 품사 분석(Part-of-Speech tagging)은 자연어 처리 분야에서 사용되는 기술 중 하나로, 문장 내의 단어들을 그 들의 언어적 역할에 따라 분류하는 작업을 말한다. 각각의 단어에 해당하는 품사 태그를 할당하여 문장의 구조 와 의미를 이해할 수 있다. 예를 들어, \"고양이가 집으로 뛰어들었다\"라는 문장에서 \"고양이\"는 명사, \"가\"는 조사, \"집으로\"는 부사구, \" 뛰어들었다\"는 동사로 분류될 수 있다. 이러한 품사 정보를 얻으면 문장의 의미를 파악하고 문장 내에서 단어들 간의 관계를 이해하는 데 도움이 될 수 있다. 품사 분석은 다양한 자연어 처리 작업에 활용될 수 있다. 예를 들어, 기계 번역에서는 번역 대상 언어의 문법적 규칙을 적용하기 위해 품사 정보를 활용할 수 있다. 정보 검색에서는 키워드의 품사 정보를 활용하여 검색 쿼리 의 의도를 파악하고 관련 문서를 찾을 수 있다. 또한, 텍스트 분류, 개체명 인식, 구문 분석 등 다양한 자연어 처리 작업에서 품사 분석은 기본적이고 중요한 전처리 단계이다. 품사 분석은 기계학습과 규칙 기반 접근법을 사용하여 수행될 수 있다. 기계학습 방법은 대량의 텍스트 데이터 를 사용하여 단어와 품사 간의 패턴을 학습하고, 규칙 기반 접근법은 언어학적 지식을 기반으로 정의된 규칙을 사용하여 품사를 할당할 수 있다. 일 실시예에 따르면, 프로세서는 제 1 문장 및 상기 제 2 문장에 대해 각각 토큰 단위로 분석하여 토큰 별 로 품사 정보(part of speech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나를 비교하고, 제 1 문장 및 제 2 문장에서 대응하는 토큰 중에서 품사 정보(part of speech), 단어 간 의존 성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나가 일치하지 않음에 기반하여 해당 토큰이 위치하는 부분에서 오류가 발생한 것으로 결정할 수 있다. 일 실시예에 따르면, 프로세서는 수정된 부분의 위치 및 출력된 정보에 기반하여 문법 오류 유형이 결정됨 에 기반하여 사용자에 의해 입력된 문장, 수정된 문장, 수정된 부분의 위치 및 문법 오류 유형에 대한 정보를 디스플레이 상에 표시할 수 있다. 일 실시예에 따르면, 프로세서는 토큰화된 상기 제 1 문장 및 상기 제 2 문장에 대해 단어 간 거리 (levenshtein distance)가 지정된 수준을 초과하는 토큰에 대해 수정이 발생한 것으로 결정하고, 수정된 토큰에 대해 삭제(delete), 삽입(insert), 대체(substitute) 또는 변형(transpose) 중 적어도 어느 하나의 동작이 발 생한 것인지 결정할 수 있다. 도 2는 일 실시예에 따른 문법 오류 유형을 분석하는 방법을 순서대로 나타낸 것이다. 동작 210에서, 프로세서(예: 도 1의 프로세서)는 사용자 입력에 기반하여 문장을 입력받을 수 있다. 사용 자 입력에 따른 문장은 오류 부분을 포함하는 오류 문장일 수 있다. 동작 212에서, 프로세서는 문법 교정 모델을 이용하여 입력된 문장에서 오류가 있는지 결정할 수 있다. 프 로세서는 문법적으로 오류가 발견됨에 기반하여 오류를 수정할 수 있다. 동작 214에서, 프로세서는 오류 문장과 수정된 문장을 출력할 수 있다. 동작 216에서, 프로세서는 오류 문장과 수정된 문장을 토큰(token)화시킬 수 있다. 토큰화는 문법적으로 수정된 부분을 찾아내기 위해 문장을 특정 단위로 분리하는 작업을 의미할 수 있다. 문장을 분리하는 특정 단위 는 설정에 따라 달라질 수 있다. 토큰은 문장을 분리하는 하나의 단위를 포함할 수 있다. 동작 218에서, 프로세서는 토큰화된 각각의 문장들을 구문별로 분석할 수 있다. 프로세서는 토큰화된 오류 문장과 수정 문장에 대해 특정 라이브러리를 사용하여 분석할 수 있다. 프로세서는 각각의 문장들을 구문별로 분석하고 품사 정보, 단어 간 의존성 또는 표제어 추출 중 적어도 어느 하나의 정보를 출력할 수 있다.동작 220에서, 프로세서는 levenshtein 거리에 기반하여 문장 내에서 수정된 부분의 위치를 결정할 수 있 다. levenshtein 거리는 단어 간 거리를 의미할 수 있다. 단어 간 거리는 문자열 간의 편집 거리를 측정하는 방 법으로 두 문자열 사이의 유사도나 차이를 측정하는 데 사용될 수 있다. 프로세서는 철자나 단어의 변경, 추가, 삭제와 같은 편집 연산을 통해 한 문자열을 다른 문자열로 변환하는 최소한의 편집 작업 수를 계산할 수 있다. 삽입(Insertion)은 한 문자열에 새로운 문장열을 추가하는 것을 의미할 수 있다. 삭제(Deletion)는 한 문 자열에서 특정 문자를 제거하는 것을 의미할 수 있다. 대체(Substitution)는 한 문자열에서 특정 문자를 다른 문자로 변경하는 것을 의미할 수 있다. 동작 222에서, 프로세서는 문법 오류 유형을 분류할 수 있다. 프로세서는 문장 구문 분석 정보 및 문 장 내 수정된 부분의 위치 정보에 기반하여 문법 오류 유형을 분류할 수 있다. 프로세서는 문장 구문 분석 정보에 기반하여 문법 오류 유형을 결정할 수 있다. 문법 오류 유형은 예를 들어, 스펠링 오류, 전치사, 동사, 형용사, 명사 또는 수 일치와 같은 오류 유형을 포함할 수 있다. 동작 224에서, 프로세서는 입력된 문장, 수정된 문장, 수정된 부분의 위치 및 문법 오류 유형에 대한 정보 를 디스플레이 상에 표시할 수 있다. 도 3은 일 실시예에 따른 문장의 토큰화 과정을 도시한 것이다. 프로세서(예: 도 1의 프로세서)는 사용자에 의해 입력된 제 1 문장을 수신할 수 있다. 프로세서(12 0)는 제 1 문장에서 오류 부분이 수정된 제 2 문장을 출력할 수 있다. 프로세서는 제 1 문장 및 제 2 문장을 각각 문장 토큰화시킬 수 있다. 토큰화는 문법적으로 수정된 부분을 찾아내기 위해 문장을 특정 단위로 분리하는 작업을 의미할 수 있다. 문장을 분리하는 특정 단위는 설정에 따라 달라질 수 있다. 토큰은 문장을 분리하는 하나의 단위를 포함할 수 있다. 토큰화된 제 1 문장은 'does'와 n't가 토큰 단위로 구분될 수 있다. 마찬가지로 토큰화된 제 2 문장 은 'do'와 n't 가 토큰 단위로 구분될 수 있다. 프로세서는 토큰화된 문장들을 분석하여 'do'와 'does'에 서 차이가 있으며, 수 일치 오류가 발생한 것으로 결정할 수 있다. 도 4는 일 실시예에 따른 문장의 오류 부분을 검출하는 과정을 도시한 것이다. 프로세서(예: 도 1의 프로세서)는 토큰화된 제 1 문장 및 토큰화된 제 2 문장을 이용하여 토큰 단위로 문법 오류를 분석할 수 있다. 프로세서는 토큰화된 제 1 문장 및 토큰화된 제 2 문장을 비교하여 문장 내 두 번째 위치에서 단어 간 거리가 가장 먼 것으로 결정할 수 있다. 프로세서는 두 번째 위치인 'does'의 자리에서 문법적인 오류가 난 것으로 결정하고, 'does'를 대체할 수 있는 'do'라는 단어로 두 번째 위치의 단어를 수정할 수 있다. 프로세서는 라이브러리를 통해 'do'라는 단어로 두 번째 위치의 단어 가 수정되었을 때 문법적으로 오류가 있는지 결정할 수 있다. 프로세서는 문법적으로 오류가 없음에 기반 하여 수정된 문장에서 두 번째 위치의 단어를 'do'인 것으로 결정하고 수 일치 오류인 것으로 결정할 수 있다. 도 5는 일 실시예에 따른 문법 오류 유형을 분석하는 방법의 순서도를 나타낸 것이다. 도 5의 순서도에서 프로세스 단계들, 방법 단계들, 알고리즘들 등이 순차적인 순서로 설명되었지만, 그러한 프 로세스들, 방법들 및 알고리즘들은 임의의 적합한 순서로 작동하도록 구성될 수 있다. 다시 말하면, 본 발명의 다양한 실시예들에서 설명되는 프로세스들, 방법들 및 알고리즘들의 단계들이 본 발명에서 기술된 순서로 수행 될 필요는 없다. 또한, 일부 단계들이 비동시적으로 수행되는 것으로서 설명되더라도, 다른 실시예에서는 이러 한 일부 단계들이 동시에 수행될 수 있다. 또한, 도면에서의 묘사에 의한 프로세스의 예시는 예시된 프로세스 가 그에 대한 다른 변화들 및 수정들을 제외하는 것을 의미하지 않으며, 예시된 프로세스 또는 그의 단계들 중 임의의 것이 본 발명의 다양한 실시예들 중 하나 이상에 필수적임을 의미하지 않으며, 예시된 프로세스가 바람 직하다는 것을 의미하지 않는다. 동작 510에서, 프로세서(예: 도 1의 프로세서)는 제 1 문장을 수신할 수 있다. 제 1 문장은 사용자에 의해 입력된 문장으로 문법적인 오류가 포함될 수 있다. 동작 520에서, 프로세서는 오류가 있는 것으로 결정 후 제 1 문장이 수정된 제 2 문장을 출력할 수 있다. 동작 530에서, 프로세서는 제 1 문장 및 제 2 문장을 토큰화할 수 있다. 토큰화는 문법적으로 수정된 부분 을 찾아내기 위해 문장을 특정 단위로 분리하는 작업을 의미할 수 있다. 문장을 분리하는 특정 단위는 설정에 따라 달라질 수 있다. 토큰은 문장을 분리하는 하나의 단위를 포함할 수 있다. 동작 540에서, 프로세서는 토큰 별로 문장을 분석하여 품사 정보, 의존성 또는 표제어 추출에 대한 정보 중 적어도 어느 하나를 출력할 수 있다. 프로세서는 제 1 문장 및 제 2 문장에 대해 각각 토큰 단위로 분석하여 토큰 별로 품사 정보(part of speech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나를 비교할 수 있다. 프로세서는 제 1 문장 및 제 2 문장에서 대응하는 토큰 중에서 품사 정보(part of speech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 적어도 어느 하나가 일치하지 않음에 기반하여 해당 토 큰이 위치하는 부분에서 오류가 발생한 것으로 결정할 수 있다. 동작 550에서, 프로세서는 출력된 정보에 기반하여 수정 부분의 위치를 결정하고 문법 오류 유형을 결정할 수 있다. 프로세서는 수정된 부분의 위치 및 출력된 정보에 기반하여 문법 오류 유형을 결정할 수 있다. 프로세서는 수정된 부분의 위치 및 출력된 정보에 기반하여 문법 오류 유형이 결정됨에 기반하여 사용자에 의해 입력된 문장, 수정된 문장, 수정된 부분의 위치 및 문법 오류 유형에 대한 정보를 디스플레이 상에 표시할 수 있다. 일 실시예에 따르면, 프로세서는 제 1 문장과 제 2 문장을 비교하여 품사 정보(part of speech), 단어 간 의존성(dependency) 또는 표제어 추출(lemmatization)중 중 적어도 하나에 있어서 차이가 있는지 결정하고, 차 이가 있는 것으로 결정된 부분에 기반하여 오류 유형을 결정할 수 있다. 일 실시예에 따르면, 프로세서는 품사 정보에서 차이가 있는 것으로 결정됨에 기반하여 상기 제 1 문장과 상기 제 2 문장 상에서 주어 및 동사 부분을 확인하고, 수 일치 정보가 바뀌었음에 기반하여 오류유형은 동사의 수 일치 부분인 것으로 결정할 수 있다. 예를 들어, 프로세서는 오류 문장이 'I doesn't like it' 이고, 수정 문장이 'I don't like it' 인 상황에서 does 가 do로 교정된 것으로 결정할 수 있다. 프로세서는 does의 태그 정보는 3인칭 단수이고, do의 태그 정보는 비3인칭 단수인 것으로 결정할 수 있다. 프로세서 는 does 및 do의 태그 정보에 기반하여 동사의 수일치 형태가 바뀐 것으로 결정하고, 오류 유형은 동사의 수 일 치인 것으로 결정할 수 있다. 일 실시예에 따르면, 프로세서는 단어 간 의존성(dependency)에서 차이가 있는 것으로 결정됨에 기반하여 변화된 부분이 능동태에서 수동태로 변화되었는지 또는 반대로 수동태에서 능동태로 변화되었는지 결정하고, 변 화된 부분이 능동태에서 수동태로 변화되었는지 또는 반대로 수동태에서 능동태로 변화되었음에 기반하여 오류 유형은 동사의 시제 부분인 것으로 결정할 수 있다. 예를 들어, 프로세서는 오류 문장이 'I am hit right now.' 이고, 교정된 문장이 'I am being hit right now.' 인 상황에서 am 부분이 am being으로 교정된 것으로 결정할 수 있다. 프로세서는 am 부분이 am being으로 교정됨에 기반하여 조동사가 조동사 수동태 형태로 변화된 것으로 결정하고, 오류 유형은 동사의 시제인 것으로 결정할 수 있다. 일 실시예에 따르면, 프로세서는 표제어 추출(lemmatization)에서 차이가 있는 것으로 결정됨에 기반하여 변화된 부분이 표제어는 동일하고, 동사의 형태만 바뀐 것인지 확인하며, 표제어는 동일하고, 동사의 형태만 바 뀐 것으로 결정됨에 기반하여 오류 유형은 동사의 형태 부분인 것으로 결정할 수 있다. 예를 들어, 프로세서 는 오류 문장이 'I want eating.'이고, 교정된 문장이 'I want to eat.'인 상황에서 eating 부분이 eat으 로 교정된 것으로 결정할 수 있다. 프로세서는 표제어(lemma)는 eat으로 동일한 상태에서 동사의 형태만 바뀌었으므로 오류 유형은 동사의 형태인 것으로 결정할 수 있다. 프로세서는 입력된 제 1 문장과 출력된 제 2 문장의 차이를 비교하고, 비교된 차이 결과에 기반하여 오류 유형을 결정할 수 있다. 프로세서는 결정된 오류 유형에 대한 데이터들을 수집하여 오류 유형 규칙을 정의 하고, 다른 문장이 입력되었을 때 오류 유형을 결정하는데 이용할 수 있다.도면 도면1 도면2 도면3 도면4 도면5"}
{"patent_id": "10-2023-0081607", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일실시예에 따른 문법 오류 유형을 분석하는 시스템의 구성을 블록도로 나타낸 것이다. 도 2는 일 실시예에 따른 문법 오류 유형을 분석하는 방법을 순서대로 나타낸 것이다. 도 3은 일 실시예에 따른 문장의 토큰화 과정을 도시한 것이다. 도 4는 일 실시예에 따른 문장의 오류 부분을 검출하는 과정을 도시한 것이다. 도 5는 일 실시예에 따른 문법 오류 유형을 분석하는 방법의 순서도를 나타낸 것이다."}
