{"patent_id": "10-2023-0144762", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0152645", "출원번호": "10-2023-0144762", "발명의 명칭": "메모리의 지연시간을 최소화하는 인공신경망 메모리 컨트롤러", "출원인": "주식회사 딥엑스", "발명자": "김녹원"}}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "인공신경망모델의 인공신경망 데이터 지역성 정보에 기초하여,상기 인공신경망모델의 데이터가 저장된 메모리가 리드-버스트 모드로 동작하도록,상기 메모리에 저장된 상기 인공신경망모델의 데이터의 재배열을 제어하도록 구성된, 인공신경망 메모리 제어부를 포함하는, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1항에 있어서,상기 인공신경망 메모리 제어부는 기 생성된 인공신경망 데이터 지역성 정보를 제공받도록 구성된, 인공신경망메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1항에 있어서,상기 인공신경망 메모리 제어부는 프로세서가 순차적으로 생성하는 데이터 접근 요청을 모니터링 하여 상기 인공신경망모델의 상기 인공신경망 데이터 지역성 정보를 생성하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1항에 있어서,상기 인공신경망 메모리 제어부는 상기 인공신경망모델을 처리하는 프로세서 및 상기 인공신경망모델의 데이터가 저장된 상기 메모리의 통신을 제어하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1항에 있어서,상기 인공신경망 메모리 제어부는 상기 메모리에 저장된 상기 인공신경망모델의 데이터를 상기 인공신경망 데이터 지역성 정보에 기초하여 순방향으로 재배열 하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 인공신경망 메모리 제어부는 프로세서가 생성하는 연속된 데이터 접근 요청들에 포함된 메모리 주소들을모니터링하여 상기 인공신경망모델의 데이터를 재배열 하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "인공신경망모델의 처리를 위해서 데이터 접근 요청을 생성하도록 구성된, 프로세서; 상기 인공신경망모델의 인공신경망 데이터 지역성 정보에 기초하여 상기 데이터 접근 요청에 대응되는 메모리접근 요청을 생성하도록 구성된, 인공신경망 메모리 제어부; 및상기 메모리 접근 요청에 대응되는 데이터를 상기 인공신경망 데이터 지역성에 기초한 리드-버스트 모드로 상기인공신경망 메모리 제어부에 제공하도록 구성된, 메모리를 포함하는, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 7항에 있어서,공개특허 10-2023-0152645-3-상기 인공신경망 메모리 제어부는 상기 프로세서가 생성하는 연속된 데이터 접근 요청들에 대응되는 상기 메모리의 메모리 주소들에 기초하여 상기 연속된 데이터 접근 요청들이 상기 리드-버스트 모드로 동작 가능한지 여부에 대하여 판단하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 7항에 있어서,상기 인공신경망 메모리 제어부는 상기 프로세서가 생성하는 순차적 데이터 접근 요청들에 의해서 상기 메모리가 상기 리드-버스트 모드로 동작 불가 판단시, 상기 순차적 데이터 접근 요청들에 대응되는 데이터를 상기 리드-버스트 모드로 동작 가능한 메모리 주소들에 저장하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 7 항에 있어서,상기 인공신경망 메모리 제어부는 상기 데이터 접근 요청에 대응되는 메모리 주소에 저장된 데이터를 상기 리드-버스트 모드 동작이 가능한 메모리 주소로 교환하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 7항에 있어서,상기 인공신경망 메모리 제어부는 상기 인공신경망 데이터 지역성 정보에 기초하여 상기 메모리의 특정 메모리영역을 상기 리드-버스트 모드 용으로 설정하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "인공신경망모델을 처리하도록 구성된, 프로세서; 상기 인공신경망모델의 데이터를 저장하도록 구성된 메모리; 및 상기 인공신경망모델의 인공신경망 데이터 지역성 정보에 기초하여 생성되는 순차적인 메모리 접근 요청들의 메모리 주소들의 연속성을 분석하여 상기 데이터의 리드-버스트 모드 동작 비율을 증가시키도록 구성된, 인공신경망 메모리 제어부를 포함하는, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 12항에 있어서,상기 인공신경망 메모리 제어부는 캐시 메모리를 더 포함하고,상기 캐시 메모리는 상기 리드-버스트 모드로 제공된 상기 데이터를 저장하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 12항에 있어서,상기 인공신경망 메모리 제어부는 캐시 메모리를 더 포함하고,상기 캐시 메모리는 상기 인공신경망모델의 인공신경망 데이터 지역성 정보에 기초하여 대응되는 가중치 값을저장하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 12항에 있어서,상기 메모리는 복수의 메모리이고, 상기 인공신경망 메모리 제어부는 상기 인공신경망모델의 데이터를 상기 복수의 메모리에 분산시켜 저장하도록구성된, 인공신경망 메모리 컨트롤러.공개특허 10-2023-0152645-4-청구항 16 제12항에 있어서,상기 인공신경망 메모리 제어부는 상기 인공신경망모델의 인공신경망 데이터 지역성 정보 및 상기 인공신경망모델의 데이터가 저장된 메모리 주소에 기초하여 상기 메모리의 특정 글로벌 비트 라인의 리프레시 타이밍을 제어하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제12항에 있어서,상기 인공신경망 메모리 제어부는 상기 인공신경망 데이터 지역성 정보에 기초하여 상기 프로세서가 생성하는데이터 접근 요청들에 대응되는 메모리 접근 요청들이 서로 매핑(mapping)되는 데이터를 더 포함하도록 구성된,인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제 12항에 있어서,상기 인공신경망 메모리 제어부는 상기 인공신경망 데이터 지역성 정보에 기초하여 상기 메모리에 저장된 상기인공신경망모델의 데이터를 재정렬 하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 12항에 있어서,상기 메모리는 리드-버스트 기능을 가지는 휘발성 또는 비휘발성 메모리인, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제 12항에 있어서,상기 인공신경망 메모리 제어부는 상기 인공신경망모델의 인공신경망 데이터 지역성에 기초하여 상기 메모리에저장된 상기 인공신경망모델의 데이터를 리드-버스트 모드에 최적화되도록 재정렬하고, 상기 인공신경망모델의인공신경망 데이터 지역성을 상기 재정렬된 데이터에 대응되도록 갱신하도록 구성된, 인공신경망 메모리 컨트롤러."}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 명세서의 개시에 따르면 인공신경망 메모리 컨트롤러가 제공된다. 상기 메모리 시스템은 인공신경망모델의 인 공신경망 데이터 지역성 정보에 기초하여, 상기 인공신경망모델의 데이터가 저장된 메모리가 리드-버스트 모드로 동작하도록, 상기 메모리에 저장된 상기 인공신경망모델의 데이터의 재배열을 제어하도록 구성된, 인공신경망 메 모리 제어부를 포함할 수 있다."}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 메모리의 지연시간을 최소화하는 인공신경망 메모리 컨트롤러에 관한 것으로, 보다 상세하게는, 인공 신경망 데이터 지역성(Locality)을 기초로 프로세서의 요청 전에 데이터를 미리 준비할 수 있는 인공신경망 메 모리 컨트롤러에 관한 것이다."}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능 추론 능력이 발전됨에 따라, 인공지능 스피커, 스마트 폰, 스마트 냉장고, VR 장치, AR 장치, 인공지 능 CCTV, 인공지능 로봇 청소기, 태블릿, 노트북 컴퓨터, 자율 주행 자동차, 2족 보행 로봇, 4족 보행 로봇, 산 업용 로봇 등, 다양한 전자 장치들에 인공지능을 활용한 음향 인식, 음성 인식, 영상 인식, 객체 감지, 운전자 졸음 감지, 위험 순간 감지, 및 제스처 감지 등의 다양한 추론 서비스가 탑재되고 있다. 최근 딥러닝 기술이 발달함에 따라 빅 데이터 기반의 학습을 통한 인공신경망 추론 서비스의 성능이 발전하고 있다. 이러한 인공신경망의 학습 및 추론 서비스는 인공신경망에 방대한 양의 학습 데이터를 반복 학습 시키고, 학습된 인공신경망모델을 통해서 다양하고 복잡한 데이터들을 추론한다. 따라서, 인공신경망 기술을 활용하여 다양한 서비스가 상술한 전자 장치들에게 제공되고 있다. 하지만, 인공신경망을 활용하는 추론 서비스에게 요구되는 기능 및 정확도가 점점 증가하고 있다. 이에 따라, 인공신경망모델의 크기, 연산량, 및 학습 데이터의 크기가 기하급수적으로 증가되고 있다. 이러한 인공신경망모델의 추론 연산을 감당할 수 있는 프로세서와 메모리의 요구 성능이 점차 높아지고 있으며, 빅 데이터를 용이하 게 처리할 수 있는 클라우드 컴퓨팅(cloud computing) 기반의 서버에서 인공신경망 추론 서비스가 활발하게 제 공되고 있다. 한편으론, 인공신경망모델 기술을 활용하는 엣지 컴퓨팅(edge computing)이 활발하게 연구되고 있다. 엣지 컴퓨 팅은 컴퓨팅이 일어나는 가장자리, 주변부란 의미이다. 엣지 컴퓨팅은 데이터를 직접 생산하는 단말기나 단말기 와 근접한 위치에 있는 다양한 전자 장치들을 의미한다. 엣지 컴퓨팅은 엣지 디바이스(edge device)로 지칭될 수 있다. 엣지 디바이스는 자율 주행 드론, 자율 주행 로봇이나, 자율 주행 자동차처럼 방대한 양의 데이터를 1/100초 이내로 처리해야하는 것처럼, 즉각적이고 안정적으로 필요한 임무를 수행할 때 활용될 수도 있다. 따라 서, 엣지 디바이스가 적용될 수 있는 분야가 급격하게 증가하고 있다."}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시의 발명자는, 종래의 인공신경망모델의 연산은 높은 소비 전력, 발열, 상대적으로 낮은 메모리 대역폭에 의한 프로세서 연산의 병목 현상, 메모리의 지연시간(latency) 등의 문제들을 가진다는 사실을 인식하였다. 따 라서 인공신경망모델의 연산 처리 성능을 향상시키는데 다양한 어려움들이 존재한다는 사실을 인식하였고, 이러 한 문제들을 개선할 수 있는 인공신경망 메모리 시스템의 개발이 필요하다고 인식하였다. 이에, 본 개시의 발명자는 서버 시스템 및/또는 엣지 컴퓨팅에 적용될 수 있는 인공신경망 메모리 시스템에 대 하여 연구하였다. 더 나아가서, 본 개시의 발명자는 인공신경망모델 처리에 최적화된 인공신경망 메모리 시스템 의 프로세서인, 신경 프로세싱 유닛(neural processing unit; NPU), 또는 신경망 프로세싱 유닛에 대해서도 연 구하였다. 첫째, 본 개시의 발명자는 인공신경망모델의 연산 시 메모리를 효과적으로 제어하는 것이 인공신경망 연산 처리 속도 향상의 핵심이라고 인식하였다. 본 개시의 발명자는 인공신경망모델을 학습 시키거나 또는 추론 할 때 메 모리 제어를 적절히 하지 못할 경우, 필요한 데이터를 사전에 준비하지 못하여 메모리 실효 대역폭 감소 및/또 는 메모리의 데이터 공지 지연이 빈번히 발생할 수 있다는 사실을 인식하였다. 또한 본 개시의 발명자는 이러한 경우 프로세서가 처리할 데이터를 공급받지 못하는 기아(starvation) 또는 대기(idle) 상태가 되어 실제 연산을 할 수 없게 되어 연산 성능이 저하된다는 사실을 인식하였다. 둘째, 본 개시의 발명자는 종래의 알고리즘 레벨에서의 인공신경망모델의 연산 처리 방식의 한계를 인식하였다. 예를 들면, 종래의 프리패치(prefetch) 알고리즘은 인공신경망모델을 개념적인 레이어 단위로 해석하여 각 레이 어 단위로 메모리로부터 데이터를 프로세서가 읽어오는 기술이다. 그러나 프리패치 알고리즘은 프로세서-메모리 레벨, 즉, 하드웨어 레벨에 존재하는 인공신경망모델의 워드 단위 또는 메모리 접근 요청 단위로 인공신경망 데 이터 지역성을 인식할 수 없다. 본 개시의 발명자는 프리패치 기법 만으로는 프로세서-메모리 레벨에서 데이터 송수신 동작을 최적화 할 수 없다는 사실을 인식하였다. 셋째, 본 개시의 발명자는 인공신경망모델이 가지는 고유한 특성인 “인공신경망 데이터 지역성”에 대하여 인 식하였다. 본 개시의 발명자는 프로세서-메모리 레벨에서 워드 단위 또는 메모리 접근 요청 단위로 인공신경망 데이터 지역성이 존재하며 이를 활용하여 실효 메모리 대역폭을 극대화하고, 프로세서에 대한 데이터 공급 지연 을 최소화하여 프로세서의 인공신경망 학습/추론 연산 처리 성능을 향상할 수 있다는 사실을 인식하였다. 구체적으로, 본 개시의 발명자가 인식한 인공신경망모델의 “인공신경망 데이터 지역성”이란 프로세서가 특정 인공신경망모델을 처리할 때 해당 인공신경망모델의 구조 및 연산 알고리즘을 따라 수행되는 프로세서가 해당 인공신경망을 연산 처리하는데 필요한 데이터의 워드(word) 단위의 순서 정보를 의미할 수 있다. 더 나아가서, 본 개시의 발명자는 이러한 인공신경망모델의 연산 처리 순서는 프로세서에게 주어지는 인공신경망모델에 대한 반복적인 학습 및/또는 추론의 연산에 대해서 인공신경망 데이터 지역성이 유지되는 특성이 있다는 사실을 인식 하였다. 따라서 본 개시의 발명자는 인공신경망 데이터 지역성이 유지될 경우, 프로세서가 처리하는 인공신경망 연산에 필요한 데이터의 처리 순서가 워드 단위로 유지된다는 사실을 인식하였으며, 이러한 정보를 제공받거나 또는 분석하여 인공신경망 연산에 활용할 수 있다는 사실을 인식하였다. 부연 설명하면, 프로세서의 워드 단위 는 프로세서가 처리할 수 있는 기본 단위인 엘리먼트 단위를 의미할 수 있다. 예를 들면, 신경 프로세싱 유닛이 N비트의 입력 데이터와 M비트의 커널 가중치를 곱셈을 처리할 경우 프로세서의 입력 데이터 워드 단위는 N비트 이고 가중치 데이터의 워드 단위는 M비트일 수 있다. 또한, 본 개시의 발명자는 프로세서의 워드 단위가 인공신경망모델의 레이어, 특징맵, 커널, 활성화 함수 등에 따라 각각 다르게 설정될 수 있다는 사실도 인식하였다. 따라서 본 개시의 발명자는 각각의 워드 단위의 연산을 위해서는 정교한 메모리 제어 기술이 필요하다는 사실도 인식하였다. 본 개시의 발명자는 컴파일러에 의해서 인공신경망모델이 특정 프로세서에서 실행되도록 컴파일 될 때 인공신경 망 데이터 지역성이 구성된다는 사실에 주목하였다. 그리고 컴파일러, 인공신경망모델에 적용된 알고리즘들, 및 프로세서의 동작 특성에 따라서 인공신경망 데이터 지역성이 구성될 수 있다는 사실을 인식하였다. 부연 설명하 면, 본 개시의 발명자는 동일한 인공신경망모델의 경우에도 프로세서가 해당 인공신경망모델을 연산하는 방식, 예를 들면, 특징맵 타일링, 프로세싱 엘리먼트의 스테이셔너리(Stationary) 기법 등, 프로세서의 프로세싱 엘리 먼트 개수, 프로세서내 특징맵 및 가중치 등의 캐쉬 메모리 용량, 프로세서내의 메모리 계층 구조, 해당 인공신 경망모델을 연산 처리하기 위한 프로세서의 연산 동작의 순서를 결정해 주는 컴파일러의 알고리즘 특성 등에 따 라서 처리하고자 하는 인공신경망모델의 인공신경망 데이터 지역성이 다르게 구성될 수 있다는 사실을 인식하였 다. 왜냐하면, 상술한 각 요인들에 의해서 동일한 인공신경망모델을 연산 처리하더라도 프로세서가 클럭 단위로 매 순간 필요한 데이터의 순서를 상이하게 결정할 수 있기 때문이다. 즉, 본 개시의 발명자는 개념적으로 보면 인공신경망모델의 연산에 필요한 데이터의 순서는 인공신경망의 레이어, 단위 합성곱 및/또는 행렬곱의 연산 순 서라는 것을 인식하였다. 더 나아가서, 본 개시의 발명자는, 물리적인 연산 처리에 필요한 데이터의 순서는 워 드 단위로 프로세서-메모리 레벨, 즉 하드웨어 레벨에서 해당 인공신경망모델의 인공신경망 데이터 지역성이 구 성된다는 사실을 인식하였다. 또한 본 개시의 발명자는, 인공신경망 데이터 지역성은 프로세서와 해당 프로세서 에 사용된 컴파일러에 의존적인 특성을 가진다는 사실을 인식하였다. 넷째, 본 개시의 발명자는 인공신경망 데이터 지역성 정보를 제공받아 활용하도록 구성된 인공신경망 메모리 시 스템을 제공할 경우, 프로세서-메모리 레벨에서 인공신경망모델의 처리 성능을 극대화 할 수 있다는 사실을 인 식하였다. 본 개시의 발명자는 인공신경망 메모리 시스템이 인공신경망모델의 인공신경망 데이터 지역성을 워드 단위까지 정교하게 파악할 수 있는 경우, 프로세서가 인공신경망모델을 처리하는 최소 단위인 워드 단위의 연산 처리 순 서 정보까지도 알 수 있다는 사실을 인식하였다. 즉, 인공신경망 데이터 지역성을 활용할 수 있는 인공신경망 메모리 시스템을 제공할 경우, 인공신경망 메모리 시스템은 워드 단위로 정교하게 특정 데이터를 특정 타이밍에 메모리에서 읽어서 프로세서에게 제공할지 여부 또는 특정 데이터를 프로세서가 연산하여 특정 타이밍에 메모리 에 저장할지 여부를 사전에 예측할 수 있다는 사실을 인식하였다. 이에 본 개시의 발명자는 인공신경망 메모리 시스템을 제공하여 워드 단위로 프로세서가 요청할 데이터를 사전에 준비할 수 있다는 사실을 인식하였다. 부연 설명하면, 본 개시의 발명자는 인공신경망 메모리 시스템이 인공신경망 데이터 지역성을 알면, 프로세서가 특징맵 타일링과 같은 기법을 사용하여 특정 입력 데이터와 특정 커널의 합성곱을 연산 할 때 커널이 특정 방향 으로 이동하면서 처리 되는 합성곱의 연산 처리 순서도 워드 단위로 알 수 있다는 사실을 인식하였다. 즉, 인공신경망 메모리 시스템이 인공신경망 데이터 지역성을 활용하여 프로세서가 어떠한 데이터를 필요로 하 는가를 사전에 예측함으로써, 프로세서가 요청할 메모리 읽기/쓰기 동작을 사전에 예측하고, 프로세서가 처리할 데이터를 사전에 준비하여 메모리 실효 대역폭 증가 및/또는 메모리의 데이터 공급 지연을 최소화 하거나 제거 할 수 있다는 사실을 인식하였다. 또한 인공신경망 메모리 시스템이 프로세서가 처리할 데이터를 필요한 타이밍 에 공급할 수 있다면 프로세서의 기아 또는 대기 상태를 최소화 할 수 있게 된다는 사실을 인식하였다. 따라서, 본 개시의 발명자는 인공신경망 메모리 시스템에 의해서 연산 처리 성능 향상과 전력 소모를 저감 효과가 제공 될 수 있다는 사실을 인식하였다. 다섯째, 본 개시의 발명자는, 인공신경망 메모리 제어부가 인공신경망 데이터 지역성 정보를 제공받지 않더라도, 인공신경망 메모리 제어부를 인공신경망모델을 처리하고 있는 프로세서와 메모리의 사이의 통신 채널 에 배치한 다음, 프로세서가 특정 인공신경망모델의 연산을 처리할 때 메모리에게 요청하는 데이터 접근 요청을 분석하여, 프로세서가 처리중인 인공신경망모델의 인공신경망 데이터 지역성을 프로세서-메모리간 데이터 접근 요청 단위로 유추할 수 있다는 사실을 인식하였다. 즉, 각각의 인공신경망모델에는 고유한 인공신경망 데이터 지역성이 존재하기 때문에, 프로세서-메모리 레벨에서 프로세서는 인공신경망 데이터 지역성에 따라서 특정한 순서로 데이터 접근 요청을 생성한다는 사실을 인식하였다. 또한 프로세서가 해당 인공신경망모델을 학습/추론 연산을 반복적으로 연산 처리하면서 인공신경망 데이터 지역성은 유지된다는 사실에 기초해 프로세서-메모리간 데이터 요청을 위한 메모리에 저장된 데이터의 액세스 순서도 유지됨을 인식하였다. 이에, 본 개시의 발명자는, 인공신경망 메모리 제어부를 인공신경망모델을 연산 처리하고 있는 프로세서와 메모 리의 통신 채널에 배치하였다. 또한, 첫번째 또는 몇차례의 학습 및 추론 연산을 위한 프로세서-메모리간 데이 터 접근 요청을 관찰함으로써 인공신경망 메모리 제어부가 데이터 접근 요청 단위로 인공신경망 데이터 지역성 을 유추할 수 있다는 사실을 인식하였다. 따라서 본 개시의 발명자는, 인공신경망 데이터 지역성 정보가 제공되 지 않더라도, 인공신경망 메모리 제어부에 의해서 인공신경망 데이터 지역성을 유추할 수 있다는 사실을 인식하 였다. 이에, 본 개시의 발명자는, 데이터 접근 요청 단위로 재구성된 인공신경망 데이터 지역성에 기초하여 프로세서 가 요청할 메모리 읽기/쓰기 동작을 사전에 예측하고, 프로세서가 처리할 데이터를 사전에 준비하여 메모리 실 효 대역폭 증가 및/또는 메모리 데이터 공급 지연을 최소화 또는 실질적으로 제거할 수 있다는 사실을 인식하였 다. 또한, 본 개시의 발명자는 인공신경망 메모리 시스템이 프로세서가 처리할 데이터를 필요한 타이밍에 공급 할 수 있다면 프로세서의 기아 또는 대기 상태 발생률을 최소화 할 수 있게 된다는 사실을 인식하였다. 이에 본 개시가 해결하고자 하는 과제는 프로세서-메모리 레벨에서 동작하는 인공신경망모델의 인공신경망 데이 터 지역성을 활용하여, 프로세서의 인공신경망 연산을 최적화할 수 있는 인공신경망 메모리 시스템을 제공하는 것이다. 이에 본 개시가 해결하고자 하는 과제는 프로세서가 생성하는 데이터 접근 요청을 감지하여 프로세서가 처리중 인 인공신경망모델의 데이터 지역성 패턴을 생성하여, 프로세서가 요청할 데이터 접근 요청을 사전에 준비하여 메모리의 지연시간 문제를 개선할 수 있는 인공신경망 메모리 제어부를 포함하는 인공신경망 메모리 시스템을 제공하는 것이다. 단 본 개시는 이에 제한되지 않으며, 또 다른 과제들은 아래의 기재로부터 당업자에게 명확하 게 이해될 수 있을 것이다."}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 명세서의 개시에 따르면 인공신경망 메모리 시스템이 제공된다. 상기 메모리 시스템은 인공신경망모델의 인 공신경망 데이터 지역성 정보에 기초하여, 상기 인공신경망모델의 데이터가 저장된 메모리가 리드-버스트 모드 로 동작하도록, 상기 메모리에 저장된 상기 인공신경망모델의 데이터의 재배열을 제어하도록 구성된, 인공신경 망 메모리 제어부를 포함할 수 있다. 상기 인공신경망 메모리 제어부는 기 생성된 인공신경망 데이터 지역성 정보를 제공받도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 프로세서가 순차적으로 생성하는 데이터 접근 요청을 모니터링 하여 상기 인 공신경망모델의 상기 인공신경망 데이터 지역성 정보를 생성하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망모델을 처리하는 프로세서 및 상기 인공신경망모델의 데이터 가 저장된 상기 메모리의 통신을 제어하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 메모리에 저장된 상기 인공신경망모델의 데이터를 상기 인공신경망 데이 터 지역성 정보에 기초하여 순방향으로 재배열 하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 프로세서가 생성하는 연속된 데이터 접근 요청들에 포함된 메모리 주소들을 모니터링하여 상기 인공신경망모델의 데이터를 재배열 하도록 구성될 수 있다. 본 명세서의 개시에 따르면, 인공신경망 메모리 시스템이 제시된다. 상기 인공신경망 메모리 시스템은 인공신경 망모델의 처리를 위해서 데이터 접근 요청을 생성하도록 구성된, 프로세서; 상기 인공신경망모델의 인공신경망 데이터 지역성 정보에 기초하여 상기 데이터 접근 요청에 대응되는 메모리 접근 요청을 생성하도록 구성된, 인 공신경망 메모리 제어부; 및 상기 메모리 접근 요청에 대응되는 데이터를 상기 인공신경망 데이터 지역성에 기 초한 리드-버스트 모드로 상기 인공신경망 메모리 제어부에 제공하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 프로세서가 생성하는 연속된 데이터 접근 요청들에 대응되는 상기 메모 리의 메모리 주소들에 기초하여 상기 연속된 데이터 접근 요청들이 상기 리드-버스트 모드로 동작 가능한지 여 부에 대하여 판단하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 프로세서가 생성하는 순차적 데이터 접근 요청들에 의해서 상기 메모리 가 상기 리드-버스트 모드로 동작 불가 판단시, 상기 순차적 데이터 접근 요청들에 대응되는 데이터를 상기 리 드-버스트 모드로 동작 가능한 메모리 주소들에 저장하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 데이터 접근 요청에 대응되는 메모리 주소에 저장된 데이터를 상기 리드 -버스트 모드 동작이 가능한 메모리 주소로 교환하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망 데이터 지역성 정보에 기초하여 상기 메모리의 특정 메모리 영역을 상기 리드-버스트 모드 용으로 설정하도록 구성될 수 있다. 본 명세서의 개시에 따르면, 인공신경망 메모리 시스템이 제시된다. 상기 메모리 시스템은 인공신경망모델을 처 리하도록 구성된, 프로세서; 상기 인공신경망모델의 데이터를 저장하도록 구성된 메모리; 및 상기 인공신경망 모델의 인공신경망 데이터 지역성 정보에 기초하여 생성되는 순차적인 메모리 접근 요청들의 메모리 주소들의 연속성을 분석하여 상기 데이터의 읽기-버스트 모드 동작 비율을 증가시키도록 구성된, 인공신경망 메모리 제어 부를 포함할 수 있다. 상기 인공신경망 메모리 제어부는 캐시 메모리를 더 포함할 수 있다. 상기 캐시 메모리는 상기 리드-버스트 모 드로 제공된 상기 데이터를 저장하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 캐시 메모리를 더 포함할 수 있다. 상기 캐시 메모리는 상기 인공신경망모델 의 인공신경망 데이터 지역성 정보에 기초하여 대응되는 가중치 값을 저장하도록 구성될 수 있다. 상기 메모리는 복수의 메모리일 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망모델의 데이터를 상 기 복수의 메모리에 분산시켜 저장하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망모델의 인공신경망 데이터 지역성 정보 및 상기 인공신경망모 델의 데이터가 저장된 메모리 주소에 기초하여 상기 메모리의 특정 글로벌 비트 라인의 리프레시 타이밍을 제어 하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망 데이터 지역성 정보에 기초하여 상기 프로세서가 생성하는 데이터 접근 요청들에 대응되는 메모리 접근 요청들이 서로 매핑(mapping)되는 데이터를 더 포함하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망 데이터 지역성 정보에 기초하여 상기 메모리에 저장된 상기 인공신경망모델의 데이터를 재정렬 하도록 구성될 수 있다. 상기 메모리는 리드-버스트 기능을 가지는 휘발성 또는 비휘발성 메모리일 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망모델의 인공신경망 데이터 지역성에 기초하여 상기 메모리에 저장된 상기 인공신경망모델의 데이터를 리드-버스트 모드에 최적화되도록 재정렬하고, 상기 인공신경망모델의 인공신경망 데이터 지역성을 상기 재정렬된 데이터에 대응되도록 갱신하도록 구성될 수 있다."}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시의 실시예들에 따르면, 인공신경망을 처리하는 시스템에서 인공신경망 데이터 지역성에 의해서 프로세서 에 대한 메모리의 데이터 공급 지연을 실질적으로 제거하거나 저감할 수 있는 효과가 있다. 본 개시의 실시예들에 따르면, 인공신경망 메모리 제어부는 프로세서-메모리 레벨에서 처리되는 인공신경망모델 의 데이터를 프로세서가 요청하기 전에 사전에 준비할 수 있는 효과가 있다. 본 개시의 실시예들에 따르면, 프로세서가 처리하는 인공신경망모델의 학습 및 추론 연산 처리 시간이 단축되어 해당 프로세서의 연산 처리 성능이 향상되며, 시스템 레벨의 연산 처리에 대한 전력 효율성이 향상될 수 있는 효과가 있다. 본 개시에 따른 효과는 이상에서 예시된 내용에 의해 제한되지 않으며, 더욱 다양한 효과들이 본 명세서 내에 포함되어 있다."}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 개시의 이점 및 특징, 그리고 그것들을 달성하는 방법은 첨부되는 도면과 함께 상세하게 후술되어 있는 다양 한 예시들을 참조하면 명확해질 것이다. 그러나 본 개시는 이하에서 설명되는 예시들에 한정되는 것이 아니라"}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "서로 다른 다양한 형태로 구현될 수 있으며, 단지 본 개시의 예시들은 본 개시가 속하는 기술분야에서 통상의 지식을 가진 자에게 발명의 범주를 완전하게 알려주기 위해 제공되는 것이며, 본 발명은 청구항의 범주에 의해 정의될 뿐이다. 본 개시에 대한 상세한 설명은, 본 개시가 실시될 수 있는 특정 예시를 예시로서 설명의 편의를 위해 도면을 참 조하여 설명할 수 있다. 본 개시의 다양한 예시들의 구성요소들이 서로 상이하더라도 특정 예시에 기재되어 있 는 제조 방법, 동작 방법, 알고리즘, 형상, 공정, 구조 및 특성은 다른 예시와 결합하거나 또는 포함될 수 있다. 또한, 각각의 개시된 예시 내의 개별 구성요소의 위치 또는 배치는 본 개시의 정신 및 범위를 벗어나지 않으면서 변경될 수 있다. 본 개시의 여러 예시들의 각각 특징들이 부분적으로 또는 전체적으로 서로 결합 또는 조합 가능하며, 당업자가 충분히 이해할 수 있듯이 기술적으로 다양한 연동 및 작동이 가능하며, 각 예시들이 서로에 대하여 독립적으로 실시 가능할 수도 있고 연관 관계로 함께 실시할 수도 있다. 본 개시의 예시들을 설명하기 위한 도면에 개시된 형상, 크기, 비율, 각도, 개수 등은 예시적인 것이므로 본 개시는 도면을 참조하되 이에 한정되지 않는다. 명세서 전체에 걸쳐 동일 참조 부호는 동일 구성요소를 지칭할 수 있다. 또한, 본 개시를 설명함에 있어서, 관련된 공지 기술에 대한 구체적인 설명이 본 개시의 요지를 불필 요하게 흐릴 수 있다고 결정되는 경우 그 상세한 설명은 생략할 수 있다. 본 명세서 상에서 언급된 '포함한다', '갖는다', '이루어진다' 등이 사용되는 경우 '~만'이 사용되지 않는 이상 다른 구성요소가 추가될 수 있다. 구 성요소를 단수로 표현한 경우에 특별히 명시적인 기재 사항이 없는 한 복수를 포함하는 경우를 포함한다. 구성 요소를 해석함에 있어서, 별도의 명시적 기재가 없더라도 오차 범위를 포함하는 것으로 해석한다. 위치 관계에 대한 설명일 경우, 예를 들면, '~상에', '~상부에', '~하부에', '~옆에', '~인접하여' 등으로 두 구성요소의 위 치 관계가 설명되는 경우, '바로' 또는 '직접'이 사용되지 않는 이상 두 구성요소 사이에 하나의 다른 구성요소 가 위치할 수도 있다. 소자 또는 층이 다른 소자 또는 층 \"위 (on)\"로 지칭되는 것은 다른 소자 바로 위에 또는 중간에 다른 층 또는 다른 소자를 개재한 경우를 모두 포함한다 도 1a는 본 개시의 일 예시에 따른 인공신경망 데이터 지역성에 기초한 인공신경망 메모리 시스템의 프로세서 및 인공신경망 메모리 제어부를 설명하는 개략적인 블록도이다. 도 1a를 참조하면, 인공신경망 메모리 시스템은 적어도 하나의 프로세서 및 적어도 하나의 인공신경 망 메모리 제어부를 포함하도록 구성될 수 있다. 즉, 본 개시의 예시들에 따른 프로세서는 적어도 하 나 이상이며, 복수 개의 프로세서가 활용될 수 있다. 즉, 본 개시의 예시들에 따른 인공신경망 메모리 제어부 는 적어도 하나이며, 복수개의 인공신경망 메모리 제어부가 활용될 수 있다. 이하 설명의 편의를 위해 적어도 하나의 프로세서가 하나의 프로세서일 경우, 프로세서로 지칭할 수 있다. 이하 설명의 편의를 위해 적어도 하나의 인공신경망 메모리 제어부가 하나의 인공신경망 메모리 제어부 일 경우, 인공신경망 메모리 제어부로 지칭할 수 있다. 프로세서는 인공신경망모델을 처리하도록 구성된다. 예를 들어, 프로세서는 특정 추론 기능을 수행하 도록 학습된 인공신경망모델의 추론을 처리하여 입력 데이터에 따른 인공신경망모델의 추론 결과를 제공할 수 있다. 예를 들어, 프로세서는 특정 추론 기능을 수행하기 위한 인공신경망모델의 학습을 처리하여 학습된 인공신경망모델을 제공할 수 있다. 특정 추론 기능은, 객체 인식, 음성 인식, 영상 처리 등 인공신경망이 추론 할 수 있는 다양한 추론 기능들을 포함할 수 있다. 프로세서는 중앙 처리 장치(CPU), 그래픽 처리 장치(GPU), 어플리케이션 프로세서(AP), 디지털 신호 처리 장치(DSP), 산술 논리 연산 장치(ALU) 및 인공신경망 프로세서(NPU) 중 적어도 하나를 포함하도록 구성될 수 있 다. 단, 본 개시의 프로세서는 상술한 프로세서들에 제한되지 않는다. 프로세서는 인공신경망 메모리 제어부와 통신하도록 구성될 수 있다. 프로세서는 데이터 접근 요청을 생성하도록 구성될 수 있다. 데이터 접근 요청은 인공신경망 메모리 제어부로 전송될 수 있다. 여 기서 데이터 접근 요청은 프로세서가 인공신경망모델의 추론 또는 학습을 처리할 때 필요한 데이터에 접근 하는 요청을 의미할 수 있다. 프로세서는 인공신경망 메모리 제어부에 데이터 접근 요청을 전송하여 인공신경망 메모리 제어부 로부터 인공신경망모델의 추론 또는 학습에 필요한 데이터를 제공 받거나, 또는 프로세서가 처리한 인공신경망의 추론 또는 학습 결과를 인공신경망 메모리 제어부에게 제공할 수 있다. 프로세서는 특정 인공신경망모델을 처리한 추론 결과 또는 학습 결과를 제공할 수 있다. 이때 프로세서 는 추론 또는 학습을 하기 위한 인공신경망의 연산들을 특정 순서대로 처리하도록 구성될 수 있다. 프로세서가 특정 순서대로 인공신경망 연산을 처리해야 하는 이유는, 각각의 인공신경망모델이 각각의 고 유한 인공신경망 구조를 가지도록 구성되었기 때문이다. 즉, 각각의 인공신경망모델은 고유한 인공신경망 구조 에 따른 고유한 인공신경망 데이터 지역성을 가지도록 구성된다. 더 나아가서 고유한 인공신경망 데이터 지역성 에 따라서 프로세서가 처리하는 인공신경망모델의 연산 순서가 결정되게 된다. 부연 설명하면, 인공신경망 데이터 지역성은 컴파일러에 의해서 인공신경망모델이 특정 프로세서에서 실행되도 록 컴파일 될 때 구성될 수 있다. 인공신경망 데이터 지역성은 컴파일러, 인공신경망모델에 적용된 알고리즘들, 및 프로세서의 동작 특성에 따라서 구성될 수 있다. 프로세서가 처리할 인공신경망모델은 프로세서와 인공신경망모델의 알고리즘 특성을 고려할 수 있는 컴파일러에 의해서 컴파일될 수 있다. 즉, 인공신경망모델의 구조 및 알고리즘 정보를 알고, 프로세서의 구동 특성을 알면, 컴파일러는 인공신경망 메모리 제어부에게 워드 단위 순서로 인공신경망 데이터 지역성 정보를 제공하도록 구성될 수 있다. 예를 들면, 종래의 알고리즘 레벨의 특정 인공신경망모델의 특정 레이어의 가중치 값은 레이어 단위로 연산 될 수 있다. 하지만, 본 개시의 예시들에 따른 프로세서-메모리 레벨의 특정 인공신경망모델의 특정 레이어의 가중 치 값은 프로세서가 처리하도록 스케줄된 워드 단위로 연산 될 수 있다. 예를 들면, 프로세서의 캐쉬 메모리의 크기가 처리할 인공신경망모델의 특정 레이어의 가중치 값들의 데이 터 크기 보다 작을 경우, 프로세서는 한 번에 특정 레이어의 가중치 값들을 처리하지 않도록 컴파일될 수 있다. 즉, 프로세서가 특정 레이어의 가중치 값들과 노드 값을 연산할 때, 가중치 값이 너무 크기 때문에, 결과 값들을 저장할 캐쉬 메모리 공간이 부족할 수 있다. 이러한 경우, 프로세서가 생성하는 데이터 접근 요청 이 복수의 데이터 접근 요청들로 증가될 수 있다. 따라서 프로세서는 증가된 데이터 접근 요청들을 특정 순서로 처리하도록 구성될 수 있다. 이러한 경우, 알고리즘 레벨의 연산 순서와 프로세서-메모리 레벨의 인공신 경망 데이터 지역성에 따른 연산 순서는 서로 상이해질 수 있다. 즉, 알고리즘 레벨에서의 인공신경망 연산 순서는 해당 인공신경망모델을 처리할 프로세서 및 메모리의 하드웨 어 특성을 고려하여 프로세서-메모리 레벨의 인공신경망 데이터 지역성에 의해 재구성 될 수 있다. 프로세서-메모리 레벨에서 존재하는 인공신경망모델의 인공신경망 데이터 지역성이란 프로세서가 메모리에 요청하는 데이터 접근 요청 순서에 기반하여 프로세서-메모리 레벨에서 프로세서가 처리하는 인공신경망모 델의 연산 순서를 예측하게 하는 정보로 정의될 수 있다. 부연 설명하면 동일한 인공신경망모델의 경우에도 프로세서의 연산 기능, 예를 들면, 특징맵 타일링 (tiling) 기법, 프로세싱 엘리먼트의 스테이셔너리(Stationary) 기법 등, 프로세서의 프로세싱 엘리먼트 개수, 프로세서내 특징맵 및 가중치 등의 캐쉬 메모리 용량, 프로세서 내의 메모리 계층 구조, 인공 신경망모델을 연산 처리하기 위한 프로세서의 연산 동작의 순서를 결정해 주는 컴파일러의 알고리즘 특성 등에 따라서 인공신경망모델의 인공신경망 데이터 지역성이 다르게 구성될 수 있다. 예를 들면, 특징맵 타일링은 합성곱을 분할하는 인공신경망 기법으로, 합성곱 영역이 분할됨에 따라 특징맵이 분할되어 연산된다. 따라서, 타일링 합성곱에 의해서 같은 인공신경망모델이라 할지라도, 인공신경망모델의 인 공신경망 데이터 지역성은 서로 상이할 수 있다. 예를 들면, 스테이셔너리 기법은 신경 프로세싱 유닛에서 프로세싱 엘리먼트들(PE)의 구동 방법을 제어하는 기 법이다. 스테이셔너리 기법에 따르면 처리되는 데이터 종류, 예를 들면, 입력 특징맵, 가중치, 및 출력 특징맵 중 하나가 프로세싱 엘리먼트에 고정되어 재사용될 수 있다. 따라서, 프로세서가 메모리에게 요청하는 데 이터의 종류 및 순서가 달라질 수 있다. 즉, 동일한 인공신경망모델의 경우라도 다양한 알고리즘 및/또는 기법 등 따라 인공신경망 데이터 지역성은 재 구성될 수 있다. 따라서, 인공신경망 데이터 지역성은 프로세서, 컴파일러, 메모리 등 다양한 조건들에 의해서 전체적으로 또는 부분적으로 재구성 될 수 있다. 도 1b는 본 개시의 다양한 예시들에 적용될 수 있는 인공신경망 데이터 지역성 패턴의 재구성에 관한 설명을 위 한 예시적인 신경 프로세싱 유닛의 예시를 나타내는 개략도이다. 도 1b를 참조하면, 프로세서가 신경 프로세싱 유닛(NPU)일 경우 적용될 수 있는 예시적인 스테이셔너리 기 법들이 도시되어 있다. 프로세싱 엘리먼트들(PE)은 어레이 형태로 구성될 수 있으며, 각각의 프로세싱 엘리먼트는 곱셈기(x)와 덧셈기 (＋)를 포함하도록 구성될 수 있다. 프로세싱 엘리먼트들(PE)은 버퍼 메모리 또는 캐쉬 메모리, 예를 들면, 글 로벌 버퍼(global buffer)와 연결될 수 있다. 프로세싱 엘리먼트들(PE)은 입력 특징맵 화소(Ifmap pixel; I), 필터 가중치(Filter weight; W), 및 부분합(Psum; P) 중 하나의 데이터를 프로세싱 엘리먼트들(PE)의 레지스터 에 고정시킬 수 있다. 그리고 나머지 데이터들을 프로세싱 엘리먼트들(PE)의 입력 데이터로 제공될 수 있다. 부 분합(P)의 누산이 완료되면 출력 특징맵 화소가 될 수 있다. 도 1b의 (a)는 가중치 스테이셔너리(Weight-Stationary; WS) 기법을 도시한다. 가중치 스테이셔너리(WS) 기법에 따르면, 프로세싱 엘리먼트들(PE) 각각의 레지스터파일에 필터 가중치들(W0 to W7)이 고정되고, 병렬로 프로세 싱 엘리먼트들(PE)에 입력되는 입력 특징맵 화소(I)를 0번째 입력 특징맵 화소(I0)에서 8번째 입력 특징맵 화소 (I8)로 이동 시키면서 연산을 실행할 수 있다. 부분합들(P0 to P8)은 직렬로 연결된 프로세싱 엘리먼트들(PE)에 누적될 수 있다. 부분합들(P0 to P8)은 순차적으로 다음 프로세싱 엘리먼트로 이동할 수 있다. 고정된 필터 가 중치들(W0 to W7)을 사용하는 모든 MAC(multiply and accumulation) 연산은 직렬 처리를 위해 동일한 프로세싱 엘리먼트들(PE)에 맵핑(mapping) 되어야 한다. 상술한 구성에 따르면, 레지스터파일에서 필터 가중치(W)의 합성곱 연산 시 필터 가중치(W) 재사용을 최대화하 여 필터 가중치(W)의 액세스 에너지 소비를 최소화 할 수 있는 효과가 있다. 주목해야할 점은, 컴파일 단계에서 인공신경망모델에 가중치 스테이셔너리(WS) 기법을 적용함에 따라, 인공신경 망모델의 인공신경망 데이터 지역성은 프로세서-메모리 레벨에서 가중치 스테이셔너리(WS) 기법에 최적화되기 위해서 재구성된다. 예를 들면, 가중치 스테이셔너리(WS) 기법에서는 연산의 효율성을 위해서 프로세싱 엘리먼 트들(PE)에 필터 가중치들(W0 to W7)을 우선적으로 저장하도록 구성될 수 있다. 따라서 인공신경망 데이터 지역 성은 필터 가중치(W), 입력 특징맵 화소(I), 및 부분합(P) 순서대로 재구성될 수 있으며, 이에 프로세서가 생성하는 데이터 접근 요청 순서도 재구성된 인공신경망 데이터 지역성에 따라서 결정될 수 있다. 도 1b의 (b)는 출력 스테이셔너리(Output-Stationary; OS) 기법을 도시한다. 출력 스테이셔너리(OS) 기법에 따 르면, 프로세싱 엘리먼트들(PE)의 각각의 레지스터파일에 부분합들(P0 to P7)이 고정되어 누산되고, 병렬로 프 로세싱 엘리먼트들(PE)에 입력되는 필터 가중치(W)를 0번째 입력 필터 가중치(W0)에서 7번째 필터 가중치(W7)로 이동 시키면서 연산을 실행할 수 있다. 입력 특징맵 화소들(I0 to I7)은 직렬로 연결된 프로세싱 엘리먼트들 (PE)로 이동될 수 있다. 각각의 부분합들(P0 to P7)은 각각의 프로세싱 엘리먼트들(PE)에 고정되어 MAC(multiply and accumulation) 연산을 처리하도록 매핑(mapping) 되어야 한다. 상술한 구성에 따르면, 프로세싱 엘리먼트들(PE)에서 필터 가중치(W)의 합성곱 연산 시 부분합(P)을 프로세싱 엘리먼트들(PE)의 레지스터파일에 고정시켜서 부분합(P)의 재사용을 최대화하고 부분합(P)의 이동에 따른 에너 지 소비를 최소화할 수 있는 효과가 있다. 고정된 부분합(P)의 누산이 완료되면 출력 특징맵이 될 수 있다. 주목해야할 점은, 프로세서가 출력 스테이셔너리(OS) 기법을 적용함에 따라, 인공신경망모델의 인공신경망 데이터 지역성은 프로세서-메모리 레벨에서 출력 스테이셔너리(OS) 기법에 최적화되기 위해서 재구성된다. 예를 들면, 출력 스테이셔너리(OS) 기법에서는 연산의 효율성을 위해서 프로세싱 엘리먼트들(PE)에 부분합들(P0 to P7)을 우선적으로 저장하도록 구성될 수 있다. 따라서 인공신경망 데이터 지역성은 부분합(P), 필터 가중치(W), 및 입력 특징맵 화소(I) 순서대로 재구성될 수 있으며, 이에 프로세서가 생성하는 데이터 접근 요청 순서 도 재구성된 인공신경망 데이터 지역성에 따라서 결정될 수 있다.인공신경망모델 컴파일러는 프로세서와 메모리의 하드웨어 특성정보를 전달받아 인공신경망모델이 프로세서-메모리 레벨에서 동작할 수 있는 코드로 변 환할 수 있다. 이때, 인공신경망모델은 프로세서에 의해서 실행되는 코드로 변환되기 때문에, 로우-레벨의 코드 로 변환될 수 있다. 즉, 상술한 각 요인들에 의하면 동일한 인공신경망모델을 연산 처리하더라도 프로세서가 클럭 단위로 매 순간 필요한 데이터의 순서를 변경할 수 있다. 따라서 인공신경망모델의 인공신경망 데이터 지역성이 하드웨어레벨에서 다르게 구성될 수 있다. 다만, 인공신경망 데이터 지역성의 구성이 완료될 경우, 프로세서의 연산 순서 및 해당 연산에 필요한 데 이터 처리 순서가 해당 인공신경망모델의 학습 연산 또는 추론 연산마다 정확하게 반복될 수 있다. 이하 상술한 본 개시의 일 예시에 따른 인공신경망 메모리 시스템은 인공신경망 데이터 지역성이 제공하는 정확한 연산 순서에 기초하여 프로세서가 요청할 다음 데이터를 사전에 예측하여 메모리 지연 문제 및 메 모리 대역폭 문제를 개선하여 인공신경망 연산 처리 성능을 향상 시키고, 전력소모 등을 저감하도록 구성될 수 있다. 본 개시의 일 예시에 따른 인공신경망 메모리 제어부는 프로세서가 처리할 인공신경망모델의 인공신 경망 데이터 지역성 정보를 제공 받도록 구성되거나 또는 프로세서가 처리중인 인공신경망모델의 인공신경 망 데이터 지역성을 분석하도록 구성된 것을 특징으로 한다. 인공신경망 메모리 제어부는 프로세서에서 생성된 데이터 접근 요청을 수신하도록 구성될 수 있다. 인공신경망 메모리 제어부는 프로세서로부터 수신한 데이터 접근 요청을 모니터링 하거나 또는 기록 하도록 구성될 수 있다. 인공신경망 메모리 제어부는 인공신경망모델을 처리하고 있는 프로세서가 출 력하는 데이터 접근 요청들을 관찰하여 이후에 요청될 데이터 액세스 순서를 정확하게 예측할 수 있는 효과가 있다. 하나의 데이터 접근 요청은 적어도 하나의 워드 단위의 데이터를 포함하도록 구성될 수 있다. 인공신경망 메모리 제어부는 프로세서에서 수신된 데이터 접근 요청을 순차적으로 기록하거나 또는 모니터링하도록 구성될 수 있다. 인공신경망 메모리 제어부가 기록하는 데이터 접근 요청들은 로그 파일(log file), 테이블(table), 리스트 (list) 등 다양한 형태로 저장될 수 있다. 단, 본 개시의 일 예시에 따른 인공신경망 메모리 제어부는 데 이터 접근 요청의 기록된 형태나 양식 등에 제한되지 않는다. 인공신경망 메모리 제어부가 모니터링하는 데이터 접근 요청들은 인공신경망 메모리 제어부 내의 임 의의 메모리에 저장될 수 있다. 단, 본 개시의 일 예시에 따른 인공신경망 메모리 제어부는 데이터 접근 요청의 모니터링 방식에 제한되지 않는다. 인공신경망 메모리 제어부는 데이터 접근 요청의 기록 또는 모니터링을 위한 임의의 메모리를 더 포함하도 록 구성될 수 있다. 단, 본 개시의 일 예시에 따른 인공신경망 메모리 제어부는 이에 제한되지 않으며, 외 부 메모리와 통신하도록 구성될 수 있다. 인공신경망 메모리 제어부는 프로세서로부터 수신한 데이터 접근 요청을 모니터링 하거나 또는 기록 하여 데이터 접근 요청들을 분석하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 수신한 데이터 접근 요청들을 분석하여 프로세서가 처리중인 인공신 경망모델의 인공신경망 데이터 지역성을 분석하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 프로세서-메모리 레벨에서 동작하도록 컴파일 된 인공신경망모델의 인공 신경망 데이터 지역성을 분석하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 프로세서-메모리 레벨의 인공신경망의 데이터 지역성에 기초하여, 인공신 경망의 연산 처리 순서를 프로세서가 생성하는 메모리 접근 요청 단위로 분석하여 인공신경망모델의 인공신경망 데이터 지역성을 분석하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 프로세서-메모리 레벨에서 재구성된 인공신경망 데이 터 지역성을 분석할 수 있는 효과가 있다. 몇몇 예시에서는, 컴파일러는 인공신경망모델의 인공신경망 데이터 지역성을 워드(WORD) 단위까지 분석하도록 구성될 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는 컴파일러가 분석한 인공신경망 데이터 지역성을 워드 단위로 제공받도록 구성될 수 있다. 여기서 워드 단위는 프로세서의 워드 단위에 따라 8bit, 16bit, 32bit, 64bit 등으로 달라질 수 있다. 여기서 워드 단위는 컴파일 된 인공신경망모델의 커널, 특징맵 등의 양자 화 알고리즘에 따라 2bit, 3bit, 5bit 등 각각 다른 워드 단위로 설정될 수 있다. 인공신경망 메모리 제어부는 특수 기능 레지스터(special function register)를 포함하도록 구성될 수 있 다. 특수 기능 레지스터는 인공신경망 데이터 지역성 정보를 저장하도록 구성될 수 있다. 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 정보의 저장 여부에 따라 서로 다른 모드로 동작하 도록 구성될 수 있다. 만약, 인공신경망 메모리 제어부가 인공신경망 데이터 지역성 정보를 저장한 경우, 인공신경망 메모리 제 어부는 프로세서가 처리할 인공신경망모델의 데이터 처리 순서를 워드 단위 순서로 미리 예측할 수 있기 때문에, 별도의 데이터 접근 요청을 기록하지 않도록 구성될 수도 있다. 단, 이에 제한되지 않으며, 인공 신경망 메모리 제어부는 저장된 인공신경망 데이터 지역성 정보와 프로세서가 생성하는 데이터 접근 요청 을 비교하면서, 저장된 인공신경망 데이터 지역성에 오류가 존재하는지 검증하도록 구성될 수 있다. 만약, 인공신경망 메모리 제어부가 인공신경망 데이터 지역성 정보를 제공받지 않은 경우, 인공신경망 메 모리 제어부는 프로세서가 생성하는 데이터 접근 요청을 관찰하여 프로세서가 처리하는 인공신 경망모델의 인공신경망 데이터 지역성을 예측하는 모드로 동작하도록 구성될 수 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템은 프로세서, 메모리 및 캐쉬 메모리를 포함하고, 인공신경망 데이 터 지역성 정보에 기초하여 프로세서가 요청할 데이터를 포함하는 예측된 데이터 접근 요청을 생성하도록 구성 될 수 있다. 인공신경망 메모리 시스템은 메모리로부터 예측된 데이터 접근 요청에 대응되는 데이터를 프로세서 가 요청하기 전에 캐쉬 메모리에 저장하도록 구성될 수 있다. 이때, 인공신경망 메모리 시스템은 인공신경망 데 이터 지역성 정보를 제공 받아 동작하도록 구성된 제1 모드 또는 프로세서가 생성하는 데이터 접근 요청들을 관 찰하여 인공신경망 데이터 지역성 정보를 예측하여 동작하도록 구성된 제2 모드 중 하나의 모드로 동작하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 시스템은 인공신경망 데이터 지역성 정보를 제공 받 을 경우, 워드 단위로 프로세서가 요청할 데이터를 사전에 예측하여 준비할 수 있는 효과가 있으며, 인공신경망 데이터 지역성 정보가 제공되지 않더라도, 프로세서가 생성하는 데이터 접근 요청들을 일정기간 모니터링함으로 써 프로세서가 처리중인 인공신경망 데이터 지역성을 데이터 접근 요청 단위로 예측할 수 있는 효과가 있다. 더 나아가서, 인공신경망 데이터 지역성 정보가 제공되더라도, 인공신경망 메모리 시스템은 자체적으로 데이터 접 근 요청을 모니터링 함으로써 인공신경망 데이터 지역성을 재구성하여 제공된 인공신경망 데이터 지역성을 검증 하는 용도로 활용할 수도 있다. 따라서 인공신경망모델의 변경, 또는 오류 등의 발생을 감지할 수 있는 효과가 제공될 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부와 적어도 하나의 프로세서가 직접 통신하도록 구성 될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 프로세서로부터 직접 데이터 접근 요청을 수신 할 수 있기 때문에, 프로세서와 인공신경망 메모리 제어부 사이의 시스템버스에 의해서 발생될 수 있는 지연시 간을 제거할 수 있는 효과가 있다. 부연 설명하면, 프로세서와 인공신경망 메모리 제어부의 직접 통신을 위해서, 전용 버스를 더 포함하도록 구성될 수 있거나 또는 전용 통신 채널을 더 포함하도록 구성될 수 있다. 단, 이에 제한되지 않는다. 몇몇 예시에서는, 인공신경망 데이터 지역성 정보는 프로세서 및/또는 인공신경망 메모리 제어부에 선택적으로 저장되도록 구성될 수 있다. 인공신경망 데이터 지역성 정보는 프로세서 및/또는 인공신경망 메모리 제어부에 포함된 특수 목적 레지스터(special function register)에 저장되도록 구성될 수 있다. 단, 이에 제한되지 않으며, 인공신경망 데이터 지역성 정보는 인공신경망 메모리 시스템과 통신할 수 있는 임의 의 메모리, 레지스터 등에 저장될 수 있다. 도 2는 본 개시의 일 예시에 따른 인공신경망 데이터 지역성 패턴을 설명하는 개략도이다. 이하 도 2를 참조하여 인공신경망모델의 인공신경망 데이터 지역성 및 인공신경망 데이터 지역성 패턴에 대해서 설명한다. 인공신경망 메모리 제어부는 프로세서로부터 수신된 데이터 접근 요청을 순서대로 기록 또는 모니터 링 하도록 구성된다. 인공신경망 메모리 제어부는 프로세서가 처리중인 인공신경망모델의 데이터 지역성을 포함하는 인공 신경망 데이터 지역성 패턴을 생성하도록 구성된다. 즉, 인공신경망 메모리 제어부는 프로세서가 생 성하는 인공신경망모델과 관련된 데이터 접근 요청들을 분석하여 반복되는 특정 패턴을 생성하도록 구성될 수 있다. 즉, 데이터 접근 요청을 관찰할 경우, 인공신경망 데이터 지역성 정보는 인공신경망 데이터 지역성 패턴 으로 저장될 수 있다. 도 2를 참조하면, 예시적으로 18개의 데이터 접근 요청들이 인공신경망 메모리 제어부에 순차적으로 기록 되어 있다. 각각의 데이터 접근 요청들은 식별 정보를 포함하도록 구성된다. 데이터 접근 요청에 포함된 식별 정보는 다양한 정보를 포함하도록 구성될 수 있다. 예를 들면, 식별 정보는 적어도 메모리 주소 값 및 동작 모드(mode) 값을 포함하도록 구성된다. 예를 들면, 메모리 주소 값은 요청된 데이터에 대응되는 메모리 주소 값들을 포함하도록 구성될 수 있다. 단, 본 개시는 이에 제한되지 않는다. 예를 들면, 메모리 주소 값은 요청된 데이터에 대응되는 메모리 주소의 시작 값과 끝 값을 포함하도록 구성될 수 있다. 상술한 구성에 따르면, 메모리 주소의 시작 값과 끝 값 사이에 데이터가 순차적으로 저장된 것으로 간 주한다. 따라서 메모리 주소 값들을 저장하는 용량을 저감할 수 있는 효과가 있다. 예를 들면, 메모리 주소 값은 요청된 데이터에 대응되는 메모리 주소의 시작 값과 데이터 연속 읽기 트리거 (trigger) 값을 포함하도록 구성될 수 있다. 상술한 구성에 따르면, 메모리 주소의 시작 값부터 연속 읽기 트리 거 값이 바뀔 때까지 연속으로 데이터를 읽을 수 있다. 상술한 구성에 따르면, 데이터를 연속으로 읽을 수 있기 때문에 메모리 실효 대역폭을 증가시킬 수 있는 효과가 있다. 즉, 트리거 값이 활성화가 되면 메모리는 버스트 모드로 동작하는 것도 가능하다. 예를 들면, 메모리 주소 값은 요청된 데이터에 대응되는 메모리 주소의 시작 값과 데이터의 개수 정보를 포함하 도록 구성될 수 있다. 데이터의 개수의 단위는 메모리의 용량의 단위에 기초하여 결정될 수 있다. 단위는 예를 들면, 8비트인 1바이트(byte), 4바이트인 1단어(word), 또는 1024바이트인 1블록(block) 중 하나일 수 있다. 단, 본 개시는 이에 제한되지 않는다. 상술한 구성에 따르면, 메모리 주소의 시작 값부터 설정된 단위 크기의 데이터 개수만큼 연속으로 데이터를 읽을 수 있다. 상술한 구성에 따르면, 데이터를 연속으로 읽을 수 있기 때 문에 메모리 실효 대역폭을 증가시킬 수 있는 효과가 있다. 예를 들면, 메모리가 비휘발성 메모리인 경우, 메모리 주소 값은 물리-논리 주소 매핑 테이블 또는 플래시 변환 계층(flash translation layer) 정보를 더 포함할 수 있다. 단, 본 개시는 이에 제한되지 않는다. 예를 들면, 동작 모드는 읽기(read) 모드 및 쓰기(write) 모드를 포함하도록 구성될 수 있다. 읽기 및 쓰기는 버스트 모드를 더 포함할 수 있다. 예를 들면, 동작 모드는 덮어쓰기(overwrite)를 더 포함하도록 구성될 수 있다. 단, 본 개시는 이에 제한되지 않는다. 인공신경망 메모리 제어부는 데이터 접근 요청들 각각의 식별 정보의 동일 여부를 결정하도록 구성될 수 있다. 예를 들면, 인공신경망 메모리 제어부는 데이터 접근 요청들 각각의 메모리 주소 및 동작 모드의 동일 여 부를 결정하도록 구성될 수 있다. 다르게 설명하면, 인공신경망 메모리 제어부는 동일한 메모리 주소 값 및 동일한 동작 모드를 가지는 데이터 접근 요청 값을 감지하도록 구성될 수 있다. 예를 들면, 제1 데이터 접근 요청의 메모리 주소 값 및 동작 모드와 제10 데이터 접근 요청의 메모리 주소 값 및 동작 모드가 서로 동일할 때, 인공신경망 메모리 제어부는 해당 메모리 주소 값 및 동작 모드에 대응되 는 인공신경망 데이터 지역성 패턴을 생성하도록 구성된다. 인공신경망 데이터 지역성 패턴은, 데이터 접근 요청들의 메모리의 주소들을 순차적으로 기록한 데이터를 포함 하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 동일한 메모리 주소 값 및 동작 모드를 가지는 데이터 접근 요청들의 반 복 주기를 감지하여 반복되는 메모리 주소 값 및 동작 모드를 가지는 데이터 접근 요청들로 구성된 인공신경망 데이터 지역성 패턴을 생성하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 데이터 접근 요청에 포함된 메모리 주소의 반복 패턴을 감지하여 인공신 경망 데이터 지역성 패턴을 생성하도록 구성될 수 있다. 도 2를 참조하여 설명하면, 인공신경망 메모리 제어부가 제1 번째 데이터 접근 요청과 제10 번째 데이터 접근 요청의 메모리 주소 값 및 동작 모드가 동일한 것을 확인할 경우, 인공신경망 메모리 제어부는 동일 한 데이터 접근 요청들 중 시작되는 데이터 접근 요청부터 반복되는 데이터 접근 요청의 이전 데이터 접근 요청까지를 하나의 인공신경망 데이터 지역성 패턴으로 생성하도록 구성될 수 있다. 이러한 경우, 인공신경망 메모 리 제어부는 제1 데이터 접근 요청 내지 제9 데이터 접근 요청을 포함하는 인공신경망 데이터 지역성 패턴 을 생성하도록 구성될 수 있다. 즉, 도 2의 예시에 설명된 인공신경망 데이터 지역성 패턴은 제1 데이터 접근 요청, 제2 데이터 접근 요청, 제3 데이터 접근 요청, 제4 데이터 접근 요청, 제5 데이터 접근 요청, 제6 데이터 접근 요청, 제7 데이터 접근 요청, 제8 데이터 접근 요청 및 제9 데이터 접근 요청 순서로 구성된 메모리 주소 값들 동작 모드 값들을 포함 하도록 구성될 수 있다. 인공신경망 메모리 제어부가 생성한 인공신경망 데이터 지역성 패턴은 로그 파일(log file), 테이블 (table), 리스트(list) 등 다양한 형태로 저장될 수 있으며, 본 개시의 일 예시에 따른 인공신경망 메모리 제어 부는 인공신경망 데이터 지역성 패턴의 기록된 형태나 양식 등에 제한되지 않는다. 인공신경망 메모리 제어부가 생성한 인공신경망 데이터 지역성 패턴은 인공신경망 메모리 제어부의 임의의 메모리에 저장될 수 있으며, 본 개시의 일 예시에 따른 인공신경망 메모리 제어부는 인공신경망 데 이터 지역성 패턴을 저장하는 메모리의 구조 또는 방식 등에 제한되지 않는다. 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴 저장을 위한 임의의 메모리를 더 포함하도록 구성될 수 있다. 단, 본 개시의 일 예시에 따른 인공신경망 메모리 제어부는 이에 제한되지 않으며, 외부 메모리와 통신하도록 구성될 수 있다. 즉, 본 개시의 일 예시에 따른 인공신경망 메모리 시스템은 인공신경망 연산에 대응되는 데이터 접근 요청 을 생성하도록 구성된 적어도 하나의 프로세서 및 데이터 접근 요청을 순차적으로 기록하여 인공신경망 데 이터 지역성 패턴을 생성하도록 구성된 인공신경망 메모리 제어부를 포함하도록 구성될 수 있다. 인공신경망 메모리 제어부가 인공신경망 데이터 지역성 패턴을 생성한 경우, 인공신경망 메모리 제어부 는 프로세서로부터 수신되는 각각의 데이터 접근 요청의 메모리 주소 값 및 동작 모드 값이 기 생성 된 인공신경망 데이터 지역성 패턴에 포함된 메모리 주소 값들 및 동작 모드 값들 중 어느 하나와 일치하는지 결정하도록 구성될 수 있다. 도 2를 참조하여 설명하면, 인공신경망 메모리 제어부가 제10 데이터 접근 요청을 프로세서로부터 수 신할 때, 인공신경망 메모리 제어부는 수신된 데이터 접근 요청이 인공신경망 데이터 지역성 패턴에 포함 된 메모리 주소 값과 동일한 메모리 주소 값을 가지고 있는지를 결정하도록 구성될 수 있다. 도 2의 예시를 참조하여 설명하면, 인공신경망 메모리 제어부가 제10 데이터 접근 요청을 수신 받는 경우, 인공신경망 메모리 제어부는 제10 데이터 접근 요청의 메모리 주소 값인 시작 값 [0] 및 끝 값 [0x1000000]과 제1 데이터 접근 요청의 메모리 주소 값인 시작 값 [0] 및 끝 값 [0x1000000]이 서로 동일하다는 것을 감지하고, 제10 데이터 접근 요청의 동작 모드의 읽기 모드 값과 제1 데이터 접근 요청의 동작 모드의 읽 기 모드 값이 서로 동일하다는 것을 감지하여, 제10 데이터 접근 요청이 제1 데이터 접근 요청과 서로 동일하고, 제10 데이터 접근 요청은 인공신경망 연산이라고 결정하도록 구성될 수 있다. 인공신경망 메모리 제어부가 제11 데이터 접근 요청을 수신 받는 경우, 제11 데이터 접근 요청의 메모리 주소 값인 시작 값 [0x1100000] 끝 값 [0x1110000]과 제2 데이터 접근 요청의 메모리 주소 값인 시작 값 [0x1100000] 끝 값 [0x1110000]이 동일하다는 것을 감지하고, 제11 데이터 접근 요청의 동작 모드의 쓰기 모드 값과 제2 데이터 접근 요청의 동작 모드의 쓰기 모드 값이 서로 동일하다는 것을 감지하여, 제11 데이터 접근 요청이 제2 데이터 접근 요청과 서로 동일하고, 제11 데이터 접근 요청은 인공신경망 연산이라고 결정하도록 구 성될 수 있다. 즉, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴의 시작과 끝을 구분할 수 있다. 또한, 인 공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴의 끝 이후에 특별한 명령이 없으면 인공신경망 데이터 지역성 패턴의 시작을 사전에 준비할 수 있다. 따라서, 동일한 동작이 반복될 때, 추론의 끝을 기초로 다음 추론의 시작을 예측하여 다음 추론의 시작 전에 데이터를 준비할 수 있는 효과가 있다. 따라서, 동일한 인 공신경망 데이터 지역성 패턴이 반복될 경우 시작과 끝에서의 지연 시간을 방지 또는 저감할 수 있다. 도 2를 다시 참조하면, 인공신경망 메모리 제어부는 제1 데이터 접근 요청부터 제9 데이터 접근 요청까지 는 인공신경망 데이터 지역성 패턴을 생성하지 않은 경우를 예시하고 있다. 이러한 경우는, 인공신경망 메모리 제어부이 초기화 되거나, 프로세서가 인공신경망 연산을 수행하지 않은 경우일 수 있다. 따라서 인공신경망 메모리 제어부는 제9 데이터 접근 요청까지 패턴이 일치되는 경우를 감지하지 않는다. 인공신경망 메모리 제어부는 제10 데이터 접근 요청 시 제1 데이터 접근 요청과 동일성을 결정하고 인공신경망 데이터 지역성 패턴을 생성하고, 패턴의 일치 여부를 기록할 수 있다. 제10 데이터 접근 요청내지 제18 데이터 접근 요 청은 제1 데이터 접근 요청내지 제9 데이터 접근 요청과 동일하기 때문에, 인공신경망 메모리 제어부는 제 10 데이터 접근 요청내지 제18 데이터 접근의 패턴은 인공신경망 데이터 지역성 패턴과 일치한다고 결정할 수 있다. 즉, 본 개시의 일 예시에 따른 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴을 활용하여 프 로세서가 처리중인 연산이 인공신경망 연산인지 여부를 결정하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 프로세서가 생성하는 메모리 주소 값 및 동작 모드 값을 포함하 는 데이터 접근 요청만 수신하더라도 프로세서가 인공신경망 연산을 처리중인 것을 결정할 수 있는 효과를 제공할 수 있다. 따라서 인공신경망 메모리 제어부는 별도의 추가적인 식별 정보가 없더라도 인공신경망 데이터 지역성 패턴에 기초하여 프로세서가 현재 인공신경망 연산을 수행하는지 여부를 결정할 수 있는 효 과를 제공할 수 있다. 도 2를 참조하여 부연 설명하면, 각각의 데이터 접근 요청은 토큰으로 저장되도록 구성될 수 있다. 예를 들면, 예를 들면, 인공신경망 각각의 데이터 접근 요청은 데이터 접근 요청을 토큰화(tokenization)하여 저장할 수 있 다. 예를 들면, 인공신경망 각각의 데이터 접근 요청은 식별 정보를 기초로 토큰화 할 수 있다. 예를 들면, 인 공신경망 각각의 데이터 접근 요청은 메모리 주소 값을 기초로 토큰화 할 수 있다. 단, 본 개시의 예시들은 이 에 제한되지 않으며, 토큰은 코드(code) 또는 아이디(ID) 등으로 지칭될 수 있다. 예를 들면, 토큰은 ANN DL 단 위일 수 있다. 예를 들면, 제1 데이터 접근 요청은 토큰(token) [1]로 저장될 수 있다. 제4 데이터 접근 요청은 토큰 [4]로 저 장될 수 있다. 제7 데이터 접근 요청은 토큰 [7]로 저장될 수 있다. 예를 들면, 인공신경망 데이터 지역성 패턴 은 토큰 [1-2-3-4-5-6-7-8-9]로 저장될 수 있다. 예를 들면, 제 10 데이터 접근 요청은 토큰 [1]과 동일한 메모 리 주소 값 및 동일한 동작 모드 값을 가지기 때문에 토큰 [1]로 저장될 수 있다. 제13 데이터 접근 요청은 토 큰 [4]와 동일한 메모리 주소 값 및 동작 모드 값을 가지기 때문에 토큰 [4]로 저장될 수 있다. 따라서 인공신 경망 메모리 제어부는 인공신경망 데이터 지역성 패턴의 토큰과 동일한 토큰을 감지하면, 해당 데이터 접 근 요청이 인공신경망 연산인 것을 결정하도록 구성될 수 있다. 상술한 구성에 따르면 인공신경망 메모리 제어부는 토큰화 된 인공신경망 데이터 지역성 패턴을 활용하여 데이터 접근 요청을 쉽고 빠르게 인식하고 구분할 수 있는 효과가 있으며, 더 나아가서, 데이터 접근 요청에 추 가적인 식별 정보 및/또는 데이터가 더 추가될 경우에도 동일한 토큰을 사용하여, 데이터 접근 요청의 추가 정 보가 증가하는 경우에도 토큰을 활용하여 데이터 접근 요청을 쉽고 빠르게 인식하고 구분할 수 있는 효과를 제 공할 수 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부에 저장된 인공신경망 데이터 지역성 패턴이 삭제되거나 또는 초기 화 될 수 있다. 예를 들어, 인공신경망 데이터 지역성 패턴이 기 설정된 시간을 초과할 동안 활용되지 않을 경 우, 예를 들면, 인공신경망 데이터 지역성 패턴과 매칭되는 데이터 접근 요청이 특정 시간 동안 생성되지 않는 경우, 인공신경망 메모리 제어부는 해당 인공신경망 데이터 지역성 패턴의 활용 빈도가 낮다고 결정하여, 해당 인공신경망 데이터 지역성 패턴을 삭제하거나 또는 초기화 할 수 있다. 상술한 구성에 따르면, 인공신경망 데이터 지역성 패턴을 저장하는 메모리의 저장공간의 활용도를 향상시킬 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴의 갱신된 패턴과 이전의 패턴을 저장하여, 인공신경망모델의 변화 여부를 결정하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 인공신 경망모델의 개수가 복수일 경우, 인공신경망모델의 개수에 대응되는 인공신경망 데이터 지역성 패턴들을 더 생 성하도록 구성될 수 있다. 예를 들면, 제1 인공신경망 데이터 지역성 패턴은 토큰 [1-2-3-4-5-6-7-8-9]이고 제2 인공신경망 데이터 지역성 패턴은 토큰 [11-12-13-14-15-16]일 경우, 프로세서가 토큰 [1]에 대응되는 데이터 접근 요청을 생성하면, 인공 신경망 메모리 제어부는 제1 인공신경망 데이터 지역성 패턴을 선택하도록 구성될 수 있다. 또는 프로세서가 토 큰 [11]에 대응되는 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 제2 인공신경망 데이터 지역성 패턴을 선택하도록 구성될 수 있다. 상술한 구성에 의하면, 인공신경망 메모리 제어부는 복수의 인공신경망 데이터 지역성 패턴을 저장할 수 있으며, 프로세서가 처리하는 인공신경망모델이 다른 인공신경망모델로 바뀔 때, 기 저장된 인공신경망 데이터 지역성 패턴을 빠르게 적용할 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부는 데이터 접근 요청들이 하나의 인공신경망모델의 요청들인지 또는 복수의 인공신경망모델들의 요청들이 혼합된 것인지 여부를 결정하도록 구성될 수 있다. 또한, 인공신경망 메모 리 제어부는 복수의 인공신경망모델들 각각의 인공신경망 데이터 지역성에 대응되는 데이터 접근 요청을 각각 예측하도록 구성될 수 있다. 예를 들면, 프로세서는 복수개의 인공신경망모델을 동시에 처리할 수 있으며, 이러한 경우에 프로세서가 생성하 는 데이터 접근 요청은 복수개의 인공신경망모델에 대응되는 데이터 접근 요청이 혼합될 수 있다. 예를 들면, 제1 인공신경망 데이터 지역성 패턴은 토큰 [1-2-3-4-5-6-7-8-9]이고 제2 인공신경망 데이터 지역성 패턴은 토큰 [11-12-13-14-15-16]일 경우, 프로세서는 [1-11-2-3-12-13-14-4-5-6-15-16-7-8-9]의 순서로 데이터 접근 요청에 대응되는 토큰을 생성할 수 있다. 인공신경망 메모리 제어부는 각각의 인공신경망 데이터 지역성 패턴을 알기 때문에, 토큰[1]이 생성된 다음 토 큰[11]이 생성되더라도, 인공신경망 메모리 제어부는 토큰[2]가 다음에 생성될 것을 예측할 수 있다. 따라서 인 공신경망 메모리 제어부는 토큰[2]에 대응되는 사전 데이터 접근을 생성할 수 있다. 또한 토큰[11]이 생성된 다 음 토큰[2]가 생성되더라도, 인공신경망 메모리 제어부는 토큰 [12]가 다음에 생성될 것을 예측할 수 있다. 따 라서 인공신경망 메모리 제어부는 토큰[12]에 대응되는 사전 데이터 접근을 생성할 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 복수의 인공신경망모델을 처리하는 프로세서가 생성할 데이터 접근 요청을 인공신경망모델 별로 각각 예측하여 프로세서가 요청할 데이터를 사전에 예측 하여 대비할 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부는 복수개의 인공신경망 데이터 지역성 패턴을 저장하도록 구성될 수 있다. 예를 들어, 프로세서가 2개의 인공신경망모델을 처리할 경우, 인공신경망 메모리 제어부는 각각의 인공신경망모 델의 인공신경망 데이터 지역성 패턴을 저장하도록 구성될 수 있다. 상술한 구성에 따르면, 각각의 인공신경망모델의 연산이 처리될 때, 각각의 모델에 대응되는 실제 데이터 접근 요청이 예측될 수 있기 때문에, 본 발명의 예시는 인공신경망 연산의 처리 속도를 향상시킬 수 있는 효과가 있 다. 몇몇 예시에서는, 인공신경망 메모리 제어부는, 인공신경망 데이터 지역성 패턴을 기계학습을 하도록 구성된 인 공신경망모델을 더 포함하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부의 인공신경망모델은 프로세서가 생성하는 데이터 접근 요청을 실시간으로 강화 학습하도록 구성될 수 있다. 또한 인공신경망 메모리 제어부의 인공신경망모델은 종래에 잘 알 려진 인공신경망모델들의 인공신경망 데이터 지역성 패턴들을 학습 자료로 활용하여 학습된 모델일 수 있다. 따 라서 인공신경망 메모리 제어부는 다양한 인공신경망모델들을 인공신경망 데이터 지역성 패턴을 추출해 낼 수 있는 효과가 있다. 특히 서버와 같이 다수의 사용자의 요청에 의해서 다양한 인공신경망모델들을 처리할 때 이 러한 방식이 효과적일 수 있다. 도 2를 참조하여 부연 설명하면, 인공신경망 메모리 제어부는 프로세서가 처리하는 인공신경망모델을 동적으로 또는 실시간으로 모니터링하고, 인공신경망모델의 변경 여부를 결정하도록 구성될 수 있다. 예를 들면, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴의 패턴 일치 빈도를 통계적으로 활용하여 인공신경망 데이터 지역성 패턴의 신뢰도를 결정하도록 구성될 수 있다. 데이터 지역성 패턴의 패턴 일치 빈도가 증가할수록 인공신경망 데이터 지역성 패턴의 신뢰도가 증가하도록 구성되고, 데이터 지역성 패턴 의 패턴 일치 빈도가 저감될수록 인공신경망 데이터 지역성 패턴의 신뢰도가 감소하도록 구성될 수 있다. 상술한 구성에 따르면, 프로세서가 특정 인공신경망모델을 반복 처리할 때 인공신경망 메모리 제어부(12 0)는 특정 인공신경망모델의 인공신경망 데이터 지역성 예측 신뢰도가 향상될 수 있는 효과가 있다. 도 3은 본 개시의 다양한 예시들에 적용될 수 있는 인공신경망 데이터 지역성 패턴의 설명을 위한 예시적인 인 공신경망모델을 나타내는 개략도이다. 도 3에 도시된 프로세서가 처리중인 예시적인 인공신경망모델은 특정 추론 기능을 하도록 학습된 임 의의 인공신경망모델일 수 있다. 단지 설명의 편의를 위해서 각각의 모든 노드(node)가 모두 연결된(fully- connected) 인공신경망모델을 도시하였지만, 본 개시는 이에 제한되지 않는다. 도 3에 도시되지 않았지만, 본 개시에 적용될 수 있는 인공신경망모델은 심층 신경망(DNN, Deep Neural Network)의 한 종류인 컨벌루션 신경망(CNN, Convolutional Neural Network)일 수 있다. 예시적인 인공신경망 모델은 VGG, VGG16, DenseNet 및, encoder-decoder structure를 갖는 FCN (Fully Convolutional Network), SegNet, DeconvNet, DeepLAB V3+, U-net와 같은 DNN (deep neural network), SqueezeNet, Alexnet, ResNet18, MobileNet-v2, GoogLeNet, Resnet-v2, Resnet50, Resnet101, Inception-v3 등의 모델이거나 또는 적어도 두 개 의 서로 다른 모델들에 기초한 앙상블 모델일 수도 있다 수 있다. 단, 본 개시의 인공신경망모델은 이에 제한되 지 않는다. 상술한 예시적인 인공신경망모델들은 인공신경망 데이터 지역성을 가지도록 구성될 수 있다. 다시 도 3을 참조하여 프로세서가 처리하는 인공신경망모델의 인공신경망 데이터 지역성에 대해서 자세히 설명한다. 예시적인 인공신경망모델은 입력 레이어, 제1 연결망, 제1 은닉 레이어, 제2 연결망 , 제2 은닉 레이어, 제3 연결망, 및 출력 레이어을 포함한다. 인공신경망의 연결망은 대응되는 가중치 값을 가진다. 연결망의 가중치 값은 입력 노드 값과 곱해지고, 곱해진 값들의 누산된 값이 대응되는 출력 레이어의 노드에 저장된다. 부연 설명하면, 인공신경망모델의 연결망은 선으로 도시되어 있으며 가중치는 ⓧ로 도시되어 있다. 부연 설명하면, 누산된 값에 비선형성을 부여하기 위한 여러 가지 활성화 함수를 추가적으로 제공하도록 구성될 수 있다. 활성화 함수는 예를 들면, 시그모이드 함수, 하이퍼볼릭 탄젠트 함수, ELU 함수, Hard-Sigmoid 함수, Swish 함수, Hard-Swish 함수, SELU 함수, CELU 함수, GELU 함수, TANHSHRINK 함수, SOFTPLUS 함수, MISH 함수, Piecewise Interpolation Approximation for Non-linear 함수 또는 ReLU 함수 등일 수 있다. 단, 본 개 시는 이에 제한되지 않는다. 예시적인 인공신경망모델의 입력 레이어는 x1 및 x2 입력 노드를 포함한다. 예시적인 인공신경망모델의 제1 연결망은 입력 레이어의 각각의 노드와 제1 은닉 레이어 의 노드들을 연결하는 6개의 가중치 값을 가지는 연결망들을 포함한다. 예시적인 인공신경망모델의 제1 은닉 레이어는 a1, a2, 및 a3 노드를 포함한다. 제1 연결망 의 가중치 값들은 대응되는 입력 레이어의 노드 값과 곱해지고, 곱해진 값들의 누산된 값이 제1 은닉 레 이어에 저장된다. 예시적인 인공신경망모델의 제2 연결망은 제1 은닉 레이어의 노드들과 제2 은닉 레이어 의 노드들을 연결하는 9개의 가중치 값을 가지는 연결망들을 포함한다. 예시적인 인공신경망모델의 제2 은닉 레이어는 b1, b2, 및 b3 노드를 포함한다. 제2 연결망 의 가중치 값은 대응되는 제1 은닉 레이어의 노드 값과 곱해지고, 곱해진 값들의 누산된 값이 제2 은닉 레이어에 저장된다. 예시적인 인공신경망모델의 제3 연결망은 제2 은닉 레이어의 각각의 노드와 출력 레이어 의 각각의 노드를 연결하는 6개의 가중치 값을 가지는 연결망들을 포함한다. 예시적인 인공신경망모델의 출력 레이어는 y1, 및 y2 노드를 포함한다. 제3 연결망의 가중치 값은 대응되는 제2 은닉 레이어의 입력 노드 값과 곱해지고, 곱해진 값들의 누산된 값이 출력 레이어 에 저장된다. 상술한 인공신경망모델의 구조에 의하면, 각 레이어 별 연산은 순차적으로 수행되어야 한다는 사실을 인 식할 수 있다. 즉, 인공신경망모델의 구조가 확정될 경우, 레이어 별 연산순서가 정해져야 하며, 순서를 다르게 연산할 경우, 추론 결과가 부정확해질 수 있는 문제가 발생할 수 있다. 이러한 인공신경망모델의 구조에 따른 연산의 순서 또는 데이터 흐름의 순서를 인공신경망 데이터 지역성으로 정의할 수 있다. 부연 설명하면, 단지 설명의 편의를 위해서 도 2에서 레이어 단위로 설명하였으나, 본 개시의 예시들은 레이어 단위에 제한되지 않는다. 본 개시의 예시들에 따른 프로세서는 인공신경망 데이터 지역성에 기초하여 데이 터를 처리하기 때문에, 레이어 단위가 아닌 워드 단위 또는 데이터 접근 요청 단위로 동작될 수 있다. 여기서 데이터 접근 요청의 데이터의 크기는 대응되는 레이어의 데이터 크기 이하일 수 있다. 다시 도 3을 참조하여 예를 들면, 제1 연결망의 가중치 값들과 입력 레이어의 노드 값의 곱셈 연산 을 위해서 프로세서는 레이어 단위로 데이터 접근 요청을 생성할 수 있다. 하지만 프로세서의 특징맵 분할 합성곱, 프로세싱 엘리먼트의 스테이셔너리 기법, 프로세서의 프로세싱 엘 리먼트 개수, 프로세서의 캐쉬 메모리 용량, 프로세서의 메모리 계층 구조, 및/또는 프로세서의 컴파일러 알고리즘에 따라서 제1 연결망의 가중치 값들과 입력 레이어의 노드 값들의 레이어 연산 은 하나의 데이터 접근 요청으로 처리되지 않고, 복수로 분할된 순차적 데이터 접근 요청들로 처리될 수 있다. 프로세서가 요청할 데이터 접근 요청이 복수로 분할될 경우, 분할된 데이터 접근 요청들을 요청하는 순서 가 인공신경망 데이터 지역성에 의해서 결정될 수 있다. 이때, 인공신경망 메모리 제어부는 인공신경망 데 이터 지역성을 제공 받아서, 프로세서가 요청할 실제 데이터 접근 요청에 대응되는 데이터를 제공할 준비 를 하도록 구성되는 것도 가능하다. 이하 실제 데이터 접근 요청은 실제 데이터 접근 요청으로 지칭되는 것도 가능하다. 또는, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성을 예측하여, 프로세서가 요 청할 실제 데이터 접근 요청에 대응되는 데이터를 제공할 준비를 하도록 구성되는 것도 가능하다. 도 3에 도시된 인공신경망모델의 인공신경망 연산 시 프로세서가 생성하는 데이터 접근 요청들과 인 공신경망 데이터 지역성에 대해여 설명한다. 프로세서는 인공신경망모델의 입력 레이어는 입력 노드 값들을 읽기 위한 제1 데이터 접근 요 청을 생성한다. 제1 데이터 접근 요청은 제1 메모리 주소 값 및 읽기 모드 값을 포함한다. 제1 데이터 접근 요 청은 토큰[1]로 저장될 수 있다. 다음으로, 프로세서는 인공신경망모델의 제1 연결망의 가중치 값들을 읽기 위한 제2 데이터 접근 요청을 생성한다. 제2 데이터 접근 요청은 제2 메모리 주소 값 및 읽기 모드 값을 포함한다. 제2 데이터 접근 요청은 토큰[2]로 저장될 수 있다. 다음으로, 프로세서는 인공신경망모델의 제1 연결망의 가중치 값들과 입력 레이어의 노 드 값들을 곱하고 누산한 제1 은닉 레이어의 노드 값들을 저장하기 위한 제3 데이터 접근 요청을 생성한 다. 제3 데이터 접근 요청은 제3 메모리 주소 값 및 쓰기 모드 값을 포함한다. 제3 데이터 접근 요청은 토큰"}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "[3]으로 저장될 수 있다. 다음으로, 프로세서는 인공신경망모델의 제1 은닉 레이어에 저장된 노드 값들을 읽기 위한 제 4 데이터 접근 요청을 생성한다. 제4 데이터 접근 요청은 제3 메모리 주소 값 및 읽기 모드 값을 포함한다. 제4 데이터 접근 요청은 토큰[4]로 저장될 수 있다. 다음으로, 프로세서는 인공신경망모델의 제2 연결망의 가중치 값들을 읽기 위한 제5 데이터 접근 요청을 생성한다. 제5 데이터 접근 요청은 제5 메모리 주소 값 및 쓰기 모드 값을 포함한다. 제5 데이터 접근 요청은 토큰[5]로 저장될 수 있다. 다음으로, 프로세서는 인공신경망모델의 제2 연결망의 가중치 값들과 제1 은닉 레이어 의 노드 값들을 곱하고 누산한 제2 은닉 레이어의 노드 값들을 저장하기 위한 제6 데이터 접근 요청을 생 성한다. 제6 데이터 접근 요청은 제6 메모리 주소 값 및 쓰기 모드 값을 포함한다. 제6 데이터 접근 요청은 토 큰[6]으로 저장될 수 있다. 다음으로, 프로세서는 인공신경망모델의 제2 은닉 레이어에 저장된 노드 값들을 읽기 위한 제 7 데이터 접근 요청을 생성한다. 제7 데이터 접근 요청은 제6 메모리 주소 값 및 읽기 모드 값을 포함한다. 제7 데이터 접근 요청은 토큰[7]로 저장될 수 있다. 다음으로, 프로세서는 인공신경망모델의 제3 연결망의 가중치 값들을 읽기 위한 제8 데이터 접근 요청을 생성한다. 제8 데이터 접근 요청은 제8 메모리 주소 값 및 읽기 모드 값을 포함한다. 제8 데이터 접근 요청은 토큰[8]로 저장될 수 있다. 다음으로, 프로세서는 인공신경망모델의 제3 연결망의 가중치 값들과 제2 은닉 레이어 의 노드 값들을 곱하고 누산한 출력 레이어의 노드 값들을 저장하기 위한 제9 데이터 접근 요청을 생성한 다. 제9 데이터 접근 요청은 제9 메모리 주소 값 및 쓰기 모드 값을 포함한다. 제9 데이터 접근 요청은 토큰"}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "[9]로 저장될 수 있다. 노드 값들은 특징맵(feature map), 활성화 맵(activation map) 등 일 수 있다. 단, 이 에 제한되지 않는다. 가중치 값들은 커널 윈도우일 수 있다. 단, 이에 제한되지 않는다. 즉, 프로세서는 예시적인 인공신경망모델의 추론을 위해서 제1 내지 제9 데이터 접근 요청을 생성해 야 한다. 만약 프로세서가 생성하는 데이터 접근 요청의 순서가 뒤섞일 경우, 인공신경망모델의 인 공신경망 데이터 지역성이 손상되어 인공신경망모델의 추론 결과에 오류가 발생되거나 정확도가 저해될 수 있다. 예를 들면, 프로세서가 제2 레이어를 먼저 연산하고 제1 레이어를 연산할 경우 등. 따라서 프로 세서는 인공신경망 데이터 지역성에 기초하여 데이터 접근 요청을 순차적으로 생성하도록 구성될 수 있다. 따라서 인공신경망 메모리 제어부는 프로세서가 인공신경망 연산 시 인공신경망 데이터 지역성에 기 초하여 데이터 접근 요청을 순차적으로 생성한다고 가정할 수 있다. 다만, 상술하였듯이, 각각의 데이터 접근 요청은 프로세서의 하드웨어 특성에 따라서 프로세서-메모리 레벨에서 재해석 될 수 있다. 상술한 예는, 프로세서의 캐쉬 메모리의 가용 용량이 충분하고, 노드 값의 데이터 크기와 가중치 값의 데이터 크기가 캐쉬 메모리의 가용 용량보다 작은 경우를 예시로 설명하였다. 따라서, 각각의 레이 어는 한번의 데이터 접근 요청 단위로 처리되는 것으로 설명될 수 있다. 만약, 인공신경망모델의 가중치 값, 특 징맵, 커널, 활성화 맵 등의 데이터 크기가 프로세서의 캐쉬 메모리의 가용 용량보다 클 경우, 대응되는 데이터 접근 요청은 복수개로 분할될 수 있으며, 이러한 경우, 인공신경망모델의 인공신경망 데이터 지역성이 재구성될 수 있다. 본 개시의 일 예시에 따른 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴을 생성할 수 있기 때문에, 능동적으로 프로세서가 처리하는 인공신경망모델의 인공신경망 데이터 지역성에 대응되어 동작될 수 있 는 효과가 있다. 즉, 인공신경망 메모리 제어부는 프로세서가 처리중인 인공신경망모델의 실제 인공신경망 데이터 지 역성을 모르더라도, 기록된 데이터 접근 요청을 분석하여 인공신경망 데이터 지역성을 실질적으로 분석할 수 있 는 효과가 있다. 즉, 인공신경망 메모리 제어부는 프로세서가 처리중인 인공신경망모델의 구조 정보를 제공하지 않더 라도, 기록된 데이터 접근 요청을 분석하여 인공신경망 데이터 지역성을 실질적으로 분석할 수 있는 효과가 있 다. 몇몇 예시에서는, 인공신경망 메모리 제어부는 프로세서-메모리 레벨에서 기 생성된 인공신경망 데이터 지역성 패턴을 제공받도록 구성될 수 있다. 도 4는 본 개시의 일 예시에 따른 인공신경망 메모리 제어부가 도 3의 인공신경망모델을 분석하여 생성한 인공 신경망 데이터 지역성 패턴을 설명하는 개략도이다. 도 5는 도 4의 인공신경망 데이터 지역성 패턴에 대응되는 토큰과 식별 정보를 설명하는 개략도이다. 도 4에 도시된 인공신경망 데이터 지역성 패턴은 단지 설명의 편의를 위해 토큰으로 도시되어 있다. 도 1a 내지 도 4를 참조하여 설명하면, 인공신경망모델의 인공신경망 데이터 지역성 패턴은 토큰 [1- 2-3-4-5-6-7-8-9]으로 저장되어 있다. 도 5에 도시된 인공신경망 데이터 지역성 패턴에 대응되는 토큰과 대응되는 식별 정보가 도시되어 있다. 각각의 데이터 접근 요청은 식별 정보를 포함하도록 구성될 수 있다. 각각의 데이터 접근 요청은 토큰으로 표현 될 수 있다. 단, 이는 단지 설명의 편의를 위한 것이며, 본 개시는 토큰에 제한되지 않는다. 인공신경망 데이터 지역성 패턴에 따르면, 인공신경망 메모리 제어부는 현재의 토큰 이후에 발생될 토큰의 순서를 순차적으로 예측할 수 있는 효과가 있다. 예를 들면, 인공신경망 데이터 지역성 패턴은 마지막 토큰에서 시작 토큰으로 순서가 연결되는 루프 형태 의 패턴을 가지도록 구성될 수 있다. 단, 본 개시는 이에 제한되지 않는다. 예를 들면, 인공신경망 데이터 지역성 패턴은 반복되는 루프 특성을 가지는 메모리 주소들로 구성될 수 있다. 단, 본 개시는 이에 제한되지 않는다. 예를 들면, 인공신경망 데이터 지역성 패턴은 인공신경망모델의 연산의 시작과 끝을 식별할 수 있는 식별 정보를 더 포함하도록 구성될 수 있다. 단, 본 개시는 이에 제한되지 않는다. 예를 들면, 인공신경망 데이터 지역성 패턴의 시작과 끝은 패턴의 시작 토큰과 마지막 토큰으로 구분하도 록 구성될 수 있다. 단, 본 개시는 이에 제한되지 않는다. 상술한 구성에 따르면, 프로세서가 특정 인공신경망모델을 반복하여 추론 할 때, 인공신경망 데이터 지역 성 패턴은 루프 형태의 패턴이기 때문에 특정 인공신경망모델의 현재 추론이 끝나더라도, 다음 추론의 시 작을 예측할 수 있는 효과가 있다. 예를 들면, 초당 30 IPS(inference per second) 속도로 자율 주행 자동차에 장착된 전방 카메라의 영상의 물체 를 인식하는 인공신경망모델의 경우, 연속적으로 동일한 추론이 특정 주기로 계속 반복된다. 따라서 상술한 루 프 형태의 인공신경망 데이터 지역성 패턴을 활용하면, 반복되는 데이터 접근 요청을 예측할 수 있는 효과가 있 다. 식별 정보에 대해서 예를 들어 부연 설명하면, 인공신경망 데이터 지역성 패턴의 토큰 [3]과 토큰 [4]는 동일한 메모리 주소 값을 가지나 동작 모드가 다른 것을 확인할 수 있다. 따라서 인공신경망 메모리 제어부 는 메모리 주소 값이 동일하더라도, 동작 모드가 다르기 때문에 제3 데이터 접근 요청과 제4 데이터 접근 요청을 서로 다른 토큰으로 분류하도록 구성될 수 있다. 단, 본 개시의 예시들의 식별 정보는 동작 모드에 제한 되지 않으며, 메모리 주소 값만으로 인공신경망 데이터 지역성 패턴을 예측하도록 구성될 수 있다. 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 대응되는 예측된 데이터 접 근 요청을 생성하도록 구성될 수 있다. 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 예측된 데이터 접근 요청을 순차적으로 더 생성하도록 구성될 수 있다. 상술한 구성에 따르면, 프로세서가 인공신경망 데이터 지역성 패턴에 포함된 특정 데이터 접근 요청 을 생성하면 인공신경망 메모리 제어부는 특정 데이터 접근 요청 이후의 데이터 접근 요청들을 적어도 하 나 이상 순차적으로 예측할 수 있는 효과가 있다. 예를 들면, 토큰 [1]을 프로세서가 생성하면, 인공신경 망 메모리 제어부는 토큰 [2]에 대응되는 데이터 접근 요청이 다음에 생성될 것을 예측할 수 있는 효과가 있다. 예를 들면, 토큰 [3]을 프로세서가 생성하면, 인공신경망 메모리 제어부는 토큰 [4]에 대응되 는 데이터 접근 요청이 다음에 생성될 것을 예측할 수 있는 효과가 있다. 예를 들면, 토큰 [1]을 프로세서(11 0)가 생성하면, 인공신경망 메모리 제어부는 토큰 [2-3-4-5-6-7-8-9] 순서로 대응되는 데이터 접근 요청들 이 생성될 것을 예측할 수 있는 효과가 있다. 부연 설명하면, 프로세서가 복수의 인공신경망모델들을 처리할 경우, 인공신경망 데이터 지역성 패턴 의 토큰들 사이에 예측하지 못한 데이터 지역성 패턴이 끼어들 수 있다. 예를 들면, 토큰 [2] 이후에 새 로운 토큰[41]이 난입할 수 있다. 하지만 이러한 경우에도, 인공신경망 메모리 제어부는 토큰 [2] 이후에 는 프로세서가 토큰[3]을 생성할 것을 예측하고 준비할 수 있는 효과가 있다. 예를 들면, 프로세서가 토큰[9]를 생성하면, 인공신경망 메모리 제어부는 프로세서가 토큰[1]을 생성할 것을 예측할 수 있다. 도 6은 본 개시의 일 예시에 따른 인공신경망 메모리 제어부가 인공신경망 데이터 지역성 패턴에 기초하여 생성 한 예측된 데이터 접근 요청과 실제 데이터 접근 요청을 설명하는 개략도이다. 본 개시의 일 예시에 따른 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴을 활용하여 프로세 서가 다음에 요청할 실제 데이터 접근 요청을 예측하여 예측된 데이터 접근 요청을 생성하도록 구성될 수 있다. 도 6을 참조하면, 데이터 접근 요청 토큰은 인공신경망 메모리 제어부가 프로세서로부터 수신한 데이 터 접근 요청에 대응되는 토큰을 의미한다. 예측된 데이터 접근 요청 토큰은 프로세서가 다음에 요청할 데 이터 접근 요청을 인공신경망 메모리 제어부가 인공신경망 데이터 지역성 패턴에 기초하여 사전에 예측한 데이터 접근 요청에 대응되는 토큰이다. 실제 데이터 접근 요청 토큰은 예측된 데이터 접근 요청 토큰 생성 후 프로세서가 실제 생성한 데이터 접근 요청 토큰이다. 단, 본 개시의 토큰은 단지 설명의 편의를 위한 예시 일 뿐이며, 본 개시는 토큰에 제한되지 않는다. 데이터 접근 요청 및 사전 데이터 접근은 데이터 접근 요청 토큰에 대응될 수 있다. 이러한 경우, 특정 데이터 접근 요청 토큰에 매칭되는 데이터 접근 요청 및 예측된 데이터 접근 요청은 서로 동일한 메모리 주소를 가지도 록 구성될 수 있다. 즉, 데이터 접근 요청 및 사전 데이터 접근은 서로 동일한 메모리 주소를 포함하도록 구성 될 수 있다. 예를 들면, 데이터 접근 요청 토큰이 [3]이고 예측된 데이터 접근 요청 토큰이 [3]일 경우, 각각의 토큰의 메모 리 주소 값은 서로 동일할 수 있다. 즉, 데이터 접근 요청 및 사전 데이터 접근은 서로 동일한 동작 모드 값을 포함하도록 구성될 수 있다. 예를 들면, 데이터 접근 요청 토큰이 [3]이고 예측된 데이터 접근 요청 토큰이"}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "[3]일 경우, 각각의 토큰의 동작 모드 값은 서로 동일할 수 있다. 도 6을 참조하면, 프로세서가 토큰 [1]에 대응되는 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어 부는 토큰 [2]에 대응되는 예측된 데이터 접근 요청을 생성한다. 프로세서는 예측된 데이터 접근 요 청 생성 후 토큰 [2]에 대응되는 실제 데이터 접근 요청을 생성하였다. 그리고 인공신경망 메모리 제어부 는 예측된 데이터 접근 요청이 실제 데이터 접근 요청을 정확히 예측했는지를 결정하도록 구성된다. 인공신경망 메모리 제어부는 예측된 데이터 접근 요청과 실제 데이터 접근 요청에 대응되는 토큰이 동일하기 때문에 패턴이 일치한다고 결정할 수 있다. 다음으로 예를 들면, 프로세서가 토큰 [2]에 대응되는 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 토큰 [3]에 대응되는 예측된 데이터 접근 요청을 생성한다. 프로세서는 예측된 데이터 접근 요청 생성 후 토큰 [3]에 대응되는 실제 데이터 접근 요청을 생성하였다. 그리고 인공신경망 메모리 제어부 는 예측된 데이터 접근 요청이 실제 데이터 접근 요청을 정확히 예측했는지를 결정하도록 구성된다. 인공 신경망 메모리 제어부는 예측된 데이터 접근 요청과 실제 데이터 접근 요청에 대응되는 토큰이 동일하기 때문에 패턴이 일치한다고 결정할 수 있다. 다시 예를 들면, 프로세서가 토큰 [9]에 대응되는 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어 부는 토큰 [1]에 대응되는 예측된 데이터 접근 요청을 생성한다. 프로세서는 예측된 데이터 접근 요 청 생성 후 토큰 [9]에 대응되는 실제 데이터 접근 요청을 생성하였다. 그리고 인공신경망 메모리 제어부 는 예측된 데이터 접근 요청이 이후 생성될 실제 데이터 접근 요청을 정확히 예측했는지를 확인하도록 구성된 다. 인공신경망 메모리 제어부는 예측된 데이터 접근 요청과 실제 데이터 접근 요청에 대응되는 토큰이 동 일하기 때문에 패턴이 일치한다고 결정할 수 있다. 인공신경망 메모리 제어부가 예측된 데이터 접근 요청을 생성한 이후, 프로세서가 실제 데이터 접근 요청을 생성할 경우, 인공신경망 메모리 제어부는 예측된 데이터 접근 요청과 실제 데이터 접근 요청이 서 로 동일한 요청인지를 판단하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 시스템은 프로세서가 처리하는 인공신경망모델의 인공신경 망 데이터 지역성의 변화를 감지할 수 있는 효과가 있다. 따라서, 인공신경망 메모리 제어부는 인공신경망 모델이 변하더라도 변경된 인공신경망 데이터 지역성을 분석할 수 있는 효과가 있다. 인공신경망 메모리 제어부가 예측된 데이터 접근 요청과 실제 데이터 접근 요청이 동일하다고 결정할 경우, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴을 유지하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 시스템은 프로세서가 처리하는 인공신경망모델이 반복 사 용되는 것을 감지하여, 프로세서가 요구하는 데이터를 보다 더 빠르게 준비하거나 또는 제공할 수 있는 효 과가 있다. 인공신경망 메모리 제어부가 예측된 데이터 접근 요청과 실제 데이터 접근 요청이 상이하다고 결정할 경우, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴을 갱신하거나 또는 신규 인공신경망 데 이터 지역성 패턴을 더 생성하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 시스템은 프로세서가 처리하는 인공신경망모델이 변경된 것을 감지하여, 변경된 인공신경망모델에 대응되는 예측된 데이터 접근 요청을 생성할 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부는 연속된 예측된 데이터 접근 요청들을 생성하도록 구성될 수 있다. 예를 들면, 데이터 접근 요청 토큰이 [2] 일 경우, 인공신경망 메모리 제어부가 생성하는 예측된 데이터 접근 요청은 토큰[3]에 대응되는 데이터 접근 요청일 수 있다. 단, 이에 제한되지 않으며, 예를 들면, 인공신경망 메 모리 제어부가 생성하는 예측된 데이터 접근 요청은 토큰[3-4]에 대응되는 복수의 데이터 접근 요청들일 수 있다. 단, 이에 제한되지 않으며, 예를 들면, 인공신경망 메모리 제어부가 생성하는 예측된 데이터 접근 요청은 토큰[3-4-5-6]에 대응되는 복수의 데이터 접근 요청들일 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여, 계속 반복되는 데이터 접근 요청들의 순서를 모두 예측한 예측된 데이터 접근 요청을 생성할 수 있는 효과가 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여, 적어도 일부의 데이터 접근 요청들의 순서를 사전에 예측한 예측된 데이터 접근 요청을 생성할 수 있는 효과가 있다. 도 7은 본 개시의 일 예시에 따른 인공신경망 메모리 제어부의 동작을 개략적으로 설명하는 순서도이다. 도 7을 참조하면, 인공신경망 연산 처리를 위해서 프로세서는 인공신경망 데이터 지역성에 기초하여 인공 신경망모델에 대응되는 데이터 접근 요청을 생성하도록 구성될 수 있다. 인공신경망 메모리 제어부는 프로세서에서 생성된 데이터 접근 요청들을 순차적으로 기록하여 인공신 경망 데이터 지역성 패턴을 생성한다(S710). 인공신경망 메모리 제어부는 생성된 인공신경망 데이터 지역성 패턴과 프로세서가 생성하는 데이터 접근 요청을 비교하여 프로세서가 생성할 실제 데이터 접근 요청을 예측한 예측된 데이터 접근 요청을 생 성하도록 구성될 수 있다. 본 개시의 일 예시에 따른 인공신경망 메모리 시스템은 인공신경망 연산에 대응되는 데이터 접근 요청을 생성하도록 구성된 적어도 하나의 프로세서 및 데이터 접근 요청을 순차적으로 기록하여 인공신경망 연산 의 인공신경망 데이터 지역성 패턴을 생성한다(S720). 메모리 인공신경망 메모리 시스템은 인공신경망 데 이터 지역성 패턴에 기초하여 적어도 하나의 프로세서가 생성한 데이터 접근 요청의 실제 데이터 접근 요 청을 예측한 예측된 데이터 접근 요청을 생성하도록 구성된, 적어도 하나의 인공신경망 메모리 제어부를 포함하도록 구성될 수 있다. 즉, 적어도 하나의 인공신경망 메모리 제어부는 실제 데이터 접근 요청 생성 전에 예측된 데이터 접근 요 청을 생성한다(S730). 즉, 적어도 하나의 프로세서는 적어도 하나의 인공신경망 메모리 제어부에 데이터 접근 요청을 전송 하도록 구성되고, 적어도 하나의 인공신경망 메모리 제어부는 데이터 접근 요청에 대응하여 예측된 데이터 접근 요청을 출력하도록 구성될 수 있다. 본 개시의 일 예시에 따른 인공신경망 메모리 시스템은 인공신경망 연산에 대응되는 데이터 접근 요청을 생성하도록 구성된 적어도 하나의 프로세서 및 적어도 하나의 프로세서가 생성한 데이터 접근 요청을 순차적으로 기록하여 인공신경망 연산의 인공신경망 데이터 지역성 패턴을 생성하도록 구성되고, 인공신경망 데 이터 지역성 패턴에 기초하여 적어도 하나의 프로세서가 생성한 실제 데이터 접근 요청을 예측된 데이터 접근 요청을 생성하도록 구성된 적어도 하나의 인공신경망 메모리 제어부를 포함하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 프로세서 가 처리중인 인공신경망모델이 생성할 실제 데이터 접근 요청을 사전에 예측할 수 있기 때문에, 프로세서 가 요청하기 전에 해당 데이터를 사전에 제공할 준비를 할 수 있는 장점이 있다. 인공신경망 메모리 제어부는 생성된 예측된 데이터 접근 요청과 예측된 데이터 접근 요청 생성 후 프로세 서가 생성한 실제 데이터 접근 요청을 비교하여 인공신경망 데이터 지역성 패턴이 매칭되는지를 결정하도 록 구성될 수 있다(S740). 상술한 구성에 따르면, 인공신경망 메모리 제어부는 실제 데이터 접근 요청 생성 전에 예측된 데이터 접근 요청을 생성하여 사전에 데이터를 제공할 준비를 할 수 있다. 따라서 인공신경망 메모리 제어부는 프로세 서에 데이터를 제공할 때 발생될 수 있는 지연시간을 실질적으로 제거하거나 또는 저감할 수 있는 효과가 있다. 도 8은 본 개시의 다른 예시에 따른 인공신경망 메모리 시스템을 설명하는 개략적인 블록도이다. 도 8을 참조하면, 인공신경망 메모리 시스템은 프로세서, 인공신경망 메모리 제어부, 및 메모리 를 포함하도록 구성될 수 있다. 본 개시의 다른 예시에 따른 인공신경망 메모리 시스템을 본 개시의 일 예시에 따른 인공신경망 메모리 시 스템과 비교하면, 인공신경망 메모리 시스템이 메모리를 더 포함하는 것을 제외하곤 실질적으로 동일하기 때문에, 이하 단지 설명의 편의를 위해서 중복 설명은 생략할 수 있다. 본 개시의 다른 예시에 따른 인공신경망 메모리 시스템은 인공신경망 메모리 제어부와 통신하도록 구 성된 메모리를 포함하고, 메모리는 인공신경망 메모리 제어부에서 출력되는 메모리 접근 요청에 대응하여 동작하도록 구성될 수 있다. 프로세서는 인공신경망 메모리 제어부와 통신하도록 구성될 수 있다. 프로세서는 인공신경망 메 모리 제어부로 송신할 데이터 접근 요청을 생성하도록 구성될 수 있다. 데이터 접근 요청은 처리중인 인공 신경망모델의 인공신경망 데이터 지역성에 기초하여 생성될 수 있다. 프로세서는 데이터 접근 요청에 대응 되는 데이터를 인공신경망 메모리 제어부로부터 제공받도록 구성된다. 인공신경망 메모리 제어부는 프로세서에서 생성된 데이터 접근 요청을 수신하도록 구성될 수 있다. 인공신경망 메모리 제어부는 프로세서가 처리중인 인공신경망모델의 인공신경망 데이터 지역성을 분 석하여 인공신경망 데이터 지역성 패턴을 생성하도록 구성될 수 있다. 인공신경망 메모리 제어부는 메모리 접근 요청을 생성하여 메모리를 제어하도록 구성될 수 있다. 인 공신경망 메모리 제어부는 데이터 접근 요청에 대응되는 메모리 접근 요청을 생성하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 프로세서가 생성한 데이터 접근 요청에 대응되는 메모리 접근 요청 을 생성하도록 구성될 수 있다. 예를 들면, 인공신경망 메모리 제어부가 인공신경망 데이터 지역성 패턴을 생성하지 않은 경우, 인공신경망 메모리 제어부는 프로세서가 생성한 데이터 접근 요청에 기초하여 메모리 접근 요청을 생성하도록 구성될 수 있다. 이러한 경우 메모리 접근 요청은 데이터 접근 요청에 포함된 식별 정보 중 메모리 주소 값 및 동작 모드 값을 포함하도록 구성될 수 있다. 인공신경망 메모리 제어부는 예측된 데이터 접근 요청에 대응되는 메모리 접근 요청을 생성하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초여 생성된 예측된 데이터 접근 요청에 기초하여 메모리 접근 요청을 생성하도록 구성될 수 있다. 예를 들면, 인공신경망 메모리 제어부 가 인공신경망 데이터 지역성 패턴을 생성한 경우, 인공신경망 메모리 제어부는 예측된 데이터 접근 요청에 기초하여 메모리 접근 요청을 생성하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 메모리 접근 요청을 통해서 메모리와 데이터를 주고 받을 수 있으며, 해당 메모리 접근 요청이 예측된 데이터 접근 요청에 기초하여 생성될 경우, 인공신경망 메모리 시스템은 프로세서에 데이터를 보다 더 빠르게 제공할 수 있는 효과가 있다. 인공신경망 메모리 제어부는 프로세서가 생성한 데이터 접근 요청 및 인공신경망 메모리 제어부(22 0)가 생성한 예측된 데이터 접근 요청 중 하나에 기초하여 메모리 접근 요청을 생성하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부가 생성하는 메모리 접근 요청은 데이터 접근 요청 또는 예측된 데이터 접근 요 청에 기초하여 선택적으로 생성될 수 있다. 인공신경망 메모리 제어부는 데이터 접근 요청 및 예측된 데이터 접근 요청에 포함된 식별 정보 중 적어도 일부를 포함하는 메모리 접근 요청을 생성하도록 구성될 수 있다. 예를 들면, 프로세서가 생성한 데이터 접근 요청은 메모리 주소 값 및 동작 모드 값을 포함할 수 있다. 이때, 인공신경망 메모리 제어부가 생성 한 메모리 접근 요청은 대응되는 데이터 접근 요청의 메모리 주소 값 및 동작 모드 값을 포함하도록 구성될 수 있다. 즉, 데이터 접근 요청, 예측된 데이터 접근 요청 및 메모리 접근 요청 각각은 대응되는 메모리 주소 값 및 동작 모드 값을 각각 포함하도록 구성될 수 있다. 동작 모드는 읽기 모드 및 쓰기 모드를 포함하도록 구성될 수 있다. 예를 들면, 인공신경망 메모리 제어부가 생성하는 메모리 접근 요청은 데이터 접근 요청 또는 예측 된 데이터 접근 요청과 동일한 구조의 데이터 형태로 구성될 수 있다. 따라서 메모리의 입장에서는 데이터 접근 요청과 예측된 데이터 접근 요청을 구분하지 않아도, 인공신경망 메모리 제어부의 지시에 따라서 메 모리 접근 요청 업무를 수행할 수 있다. 상술한 구성에 따르면, 메모리는 인공신경망 메모리 제어부가 생성하는 메모리 접근 요청이 데이터 접근 요청에 기초한 것인지 또는 예측된 데이터 접근 요청에 기초한 것인지 여부와 상관없이 동작할 수 있는 효 과가 있다. 따라서 인공신경망 메모리 제어부는 인공신경망 데이터 지역성에 기초하여 동작하더라도, 다양 한 종류의 메모리와 호환되어 동작할 수 있는 효과가 있다.인공신경망 메모리 제어부는 메모리 접근 요청을 메모리에 전달하고, 메모리는 메모리 접근 요 청에 대응되는 메모리 동작을 수행하도록 구성된다. 본 개시의 예시들에 따른 메모리는 다양한 형태로 구현될 수 있다. 메모리는 휘발성 메모리(volatile memory)와 비휘발성 메모리(non-volatile memory)로 구현될 수 있다. 휘발성 메모리는 DRAM(Dynamic RAM)과 SRAM(Static RAM) 등을 포함할 수 있다. 비휘발성 메모리는 PROM(Programmable ROM), EPROM(Erasable PROM), EEPROM(Electrically EPROM), 플래시 메모리(Flash Memory), 강유전체 램(ferroelectric RAM(FRAM)), 마그네틱 램(magnetic RAM(MRAM)), 및 상 변화 메모리 장치(phase change RAM) 등을 포함할 수 있다. 단, 본 개시는 이에 제한되지 않는다. 메모리는 프로세서가 처리중인 인공신경망모델의 추론 데이터, 가중치 데이터 및 특징맵 데이터 중 적어도 하나를 저장하도록 구성될 수 있다. 추론 데이터는 인공신경망모델의 입력신호일 수 있다. 메모리는 인공신경망 메모리 제어부로부터 메모리 접근 요청을 수신하도록 구성될 수 있다. 메모리 는 수신한 메모리 접근 요청에 대응되는 메모리 동작을 수행하도록 구성될 수 있다. 메모리 동작을 제어하 는 동작 모드는 읽기 모드 또는 쓰기 모드를 포함할 수 있다. 예를 들면, 수신한 메모리 접근 요청의 동작 모드가 쓰기 모드일 경우, 메모리는 대응되는 메모리 주소 값 에 인공신경망 메모리 제어부에서 수신된 데이터를 저장할 수 있다. 예를 들면, 수신한 메모리 접근 요청의 동작 모드가 읽기 모드일 경우, 메모리는 대응되는 메모리 주소 값 에 저장된 데이터를 인공신경망 메모리 제어부에 전달할 수 있다. 인공신경망 메모리 제어부는 전달 받은 데이터를 프로세서에 다시 전달하도록 구성될 수 있다. 메모리는 지연시간(latency)을 가질 수 있다. 메모리의 지연시간은 인공신경망 메모리 제어부가 메모리 접근 요청을 처리할 때 지연되는 시간을 의미할 수 있다. 즉, 메모리가 인공신경망 메모리 제어부 에서 메모리 접근 요청을 수신 하면, 특정 클럭 사이클의 지연시간 이후에 실제로 요구된 데이터가 메모리 에서 출력된다. 메모리가 메모리 접근 요청을 처리하기 위해서, 메모리는 메모리 접근 요청에 포함된 메모리 주소 값 에 접근할 수 있다. 따라서, 메모리 주소 값에 접근하기 위한 시간이 필요하며, 이런 시간을 메모리 지연시간으 로 정의할 수 있다. 예를 들면, DDR4 SDRAM 메모리의 CAS 지연시간은 10ns 정도다. 지연시간이 발생하는 동안 프로세서에 데이터가 공급되지 않을 경우, 프로세서는 대기(IDLE) 상태가 되어 실제 연산을 할 수 없 게 될 수 있다. 부연 설명하면, 메모리의 한 종류인 DRAM의 경우, 메모리의 Row 주소에 따라 word line 및 bit line 을 활성화하는 데 여러 클럭, Column line을 활성화하는 데 여러 클럭, 데이터를 메모리 외부로 전송하는 경로를 통과하는 데 여러 클럭이 소요되며 NAND Flash의 경우에는 한번에 활성화되는 단위가 커서 그 중에서 필 요한 주소의 데이터를 탐색하는 데까지 여러 클럭이 추가로 소요될 수도 있다. 메모리는 대역폭(bandwidth)을 가질 수 있다. 메모리의 데이터 전송률을 메모리 대역폭으로 정의할 수 있다. 예를 들면, DDR4 SDRAM 메모리의 대역폭은 4GBytes/sec 정도다. 메모리 대역폭이 높을수록 메모리 는 프로세서에 데이터를 빠르게 전송할 수 있다. 즉, 인공신경망 메모리 시스템의 처리 속도는 프로세서의 처리 성능 보다, 프로세서가 처리할 데이터를 공급할 때 발생되는 지연시간과 메모리의 대역폭 성능이 상대적으로 더 많은 영향을 끼친다. 부연 설명하면, 메모리의 대역폭은 점진적으로 증가되고 있으나, 메모리의 지연시간은 대역폭의 개선 속도에 비 해서 상대적으로 개선 속도가 느리다. 특히 메모리 접근 요청이 발생될 때마다, 메모리의 지연시간이 발생 되기 때문에, 빈번한 메모리 접근 요청은 인공신경망 처리 속도 저하의 중요한 원인이 될 수 있다. 즉, 프로세서의 연산 처리 속도가 빠르더라도, 연산에 필요한 데이터를 가져올 때 지연이 발생되면, 프로 세서는 연산을 하지 않는 대기 상태가 될 수 있으며, 이러한 경우 프로세서의 연산 처리 속도가 저하 될 수 있다. 이에 본 개시의 예시들에 따른 인공신경망 메모리 시스템은 메모리의 대역폭 및/또는 지연시간을 개선하도 록 구성될 수 있다.도 9는 본 개시의 비교예에 따른 메모리 시스템의 동작을 설명하는 개략도이다. 도 9를 참조하면, 프로세서가 데이터 접근 요청을 생성하고, 종래의 메모리 시스템은 데이터 접근 요청에 대응 되는 메모리 접근 요청을 메모리에 전달할 수 있다. 이때 메모리는 지연시간을 가지기 때문에, 프로세서는 지연 시간 동안 대기한 후 요청한 데이터를 메모리에서 제공받을 수 있다. 예를 들면, 프로세서가 생성한 데이터 접근 요청[1]을 종래의 메모리 시스템이 수신하고, 데이터 접근 요청[1] 에 대응되는 메모리 접근 요청[1']을 메모리에 전달한다. 메모리는 지연시간 이후에 메모리 시스템에 데이터 [1'']를 전달 할 수 있다. 따라서, 프로세서는 하나의 데이터 접근 요청마다 메모리의 지연시간만큼 처리 시간 이 지연될 수 있다. 따라서, 인공신경망 추론 연산의 시간이 메모리 지연시간 만큼 느려 질 수 있다. 특히, 프 로세서가 데이터 접근 요청을 많이 생성할수록, 종래의 메모리 시스템의 인공신경망 추론 연산 시간이 더욱 더 지연될 수 있다. 도 10은 본 개시의 다른 예시에 따른 메모리 시스템의 설명하는 개략도이다. 도 10을 참조하면, 프로세서가 데이터 접근 요청[1]을 생성하고, 인공신경망 메모리 제어부는 인공신 경망 데이터 지역성 패턴에 기초하여 생성된 예측된 데이터 접근 요청에 대응되는 메모리 접근 요청을 메모리 에 전달할 수 있다. 이때 메모리가 지연시간을 가지더라도, 프로세서는 예측된 데이터 접근 요 청에 대응되는 메모리 접근 요청을 생성하였기 때문에, 프로세서가 실제 데이터 접근 요청을 생성할 때 인 공신경망 메모리 제어부는 프로세서가 요청한 데이터를 바로 프로세서에 제공할 수 있다. 예를 들면, 프로세서가 생성한 데이터 접근 요청[1]을 인공신경망 메모리 제어부가 수신하여 예측된 데이터 접근 요청[2]을 생성하고, 예측된 데이터 접근 요청[2]에 대응되는 메모리 접근 요청[2']을 메모리(23 0)에 전달한다. 메모리는 지연시간 이후에 인공신경망 메모리 제어부에 데이터[2'']를 전달할 수 있 다. 하지만, 메모리가 제공한 데이터[2'']는 예측된 데이터 접근 요청[2]에 기초한 메모리 접근 요청[2'] 에 대응되는 데이터이다. 따라서 프로세서가 실제 데이터 접근 요청[2]를 생성하면, 인공신경망 메모리 제 어부는 프로세서에 데이터[2'']를 즉각 제공할 수 있다. 만약, 예측된 데이터 접근 요청에 기초한 메모리 접근 요청과 실제 데이터 접근 요청 사이의 시간이 메모리 의 지연시간 이상일 경우, 인공신경망 메모리 제어부는 프로세서에서 실제 데이터 접근 요청을 수신하자 마자 프로세서에 데이터를 제공할 수 있다. 이러한 경우, 인공신경망 메모리 제어부는 메모 리의 지연시간을 실질적으로 제거할 수 있는 효과가 있다. 다르게 설명하면, 예측된 데이터 접근 요청에 기초한 메모리 접근 요청이 메모리에 전달될 때, 메모리 의 지연시간이 예측된 데이터 접근 요청 생성부터 실제 데이터 접근 요청 생성 까지의 시간 이하일 수 있 다. 이러한 경우, 인공신경망 메모리 제어부는 프로세서가 실제 데이터 접근 요청을 생성하자 마자 지연시간 없이 데이터를 바로 제공할 수 있는 효과가 있다. 만약, 예측된 데이터 접근 요청에 기초한 메모리 접근 요청과 실제 데이터 접근 요청 사이의 시간이 메모리 의 지연시간 미만이더라도, 메모리 접근 요청과 실제 데이터 접근 요청 사이의 시간만큼 메모리의 지 연시간을 실질적으로 감소시킬 수 있는 효과가 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 프로세서에 제공할 데이터의 지연시간을 실질적 으로 제거하거나 또는 저감할 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템의 인공신경망 메모리 제어부는 메모리의 지연시간을 측정하거나 또 는 메모리의 지연시간 값을 메모리로부터 제공받도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 메모리의 지연시간에 기초하여 예측된 데이터 접근 요청에 기초한 메모리 접근 요청의 생성 시기를 결정하도록 구성될 수 있다. 따라서 인공신경망 메모리 제어부가 메모 리의 지연시간을 실질적으로 최소화 시키는 예측된 데이터 접근 요청에 기초한 메모리 접근 요청을 생성 할 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템의 메모리는 메모리 셀의 전압을 갱신할 수 있는 리프레쉬 기능을 포함하도록 구성된 메모리일 수 있다. 인공신경망 메모리 제어부는 예측된 데이터 접근 요청에 대응되는 메모리 접근 요청에 대응되는 메모리의 메모리 주소 영역의 리프레쉬를 선택적으로 제어하도록 구성될 수 있다. 예를 들면, 메모리는 리프레쉬 기능을 포함한 DRAM일 수 있다.DRAM은 메모리 셀의 전압을 리프레쉬하지 않으면 메모리 셀이 서서히 방전되어, 저장된 데이터가 손실될 수 있 다. 따라서 특정 주기마다 메모리 셀의 전압이 리프레쉬되어야 한다. 만약 인공신경망 메모리 제어부가 메모리 접근 요청을 할 때와 리프레쉬 타이밍이 겹칠 경우, 인공신경망 메모리 시스템은 메모리 셀의 전압을 리프레쉬 하는 타이밍을 앞당기거나, 또는 지연시키도록 구성될 수 있다. 인공신경망 메모리 시스템은 인공신경망 데이터 지역성 패턴을 기초로 메모리 접근 요청의 생성 타이밍을 예측 하거나 또는 계산할 수 있다. 따라서, 인공신경망 메모리 시스템은 메모리 접근 요청 동작 시 메모리 셀의 전압 리프레쉬를 제한하도록 구성될 수 있다. 부연 설명하면, 인공신경망 연산의 추론 연산은 정확도 개념으로 동작하기 때문에, 메모리 셀의 전압 리프레쉬 가 지연되어 저장된 데이터에 일부 손실이 발생하더라도, 추론 정확도 저하는 실질적으로 무시할 수 있는 수준 일 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 시스템은 메모리 셀의 전압 리프레쉬 주기와 조절하여 메모리 접근 요청에 따른 데이터를 메모리로부터 제공 받을 수 있는 효과가 있다. 따라서 인공신경망 메모리 시스템은 추론 정확도가 실질적으로 저하되지 않게 하면서 메모리 셀의 전압 리프레쉬에 따른 인공신경망 연산 속도 저하를 개 선할 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템의 메모리는 메모리의 글로벌 비트라인을 특정 전압으로 충전시킬 수 있는 프리차지(Precharge) 기능을 더 포함하도록 구성될 수 있다. 이때, 인공신경망 메모리 제어부는 예측된 데이터 접근 요청에 대응되는 메모리 접근 요청에 대응되는 메모리의 메모리 주소 영역에 프리차지를 선택적으 로 제공하도록 구성될 수 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 예측된 데이터 접근 요청에 대응되는 메모리 작업을 수행할 메모리의 비트라인을 프리차지 시키거나 또는 지연시키도록 구성될 수 있다. 일반적으로 메모리는 메모리 접근 요청을 입력 받아 읽기 동작 또는 쓰기 동작을 수행하는데 프리차지 동작을 수행한다. 한 번의 메모리 동작이 완료되면, 데이터 읽기 쓰기 동작을 수행한 비트라인 및 각 데이터 입출력 라 인에 신호들이 남아 있게 되는데, 이와 같은 라인들을 기 설정된 레벨로 프리차지해야 다음의 메모리 동작을 원 활하게 수행할 수 있다. 다만, 프리차지에 소요되는 시간이 상당히 길기 때문에, 메모리 접근 요청 생성 시기와 프리차지 타이밍이 겹칠 경우, 메모리 동작이 프리차지 시간만큼 지연될 수 있다. 따라서 프로세서가 요청한 데 이터 접근 요청의 처리 시간이 지연될 수 있다. 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 특정 순서에 특정 메모리의 비트라인에 메모리 동작이 수행될 것을 예측할 수 있다. 따라서 인공신경망 메모리 제어부는 특정 비트라인에 메모리 동작 이 수행될 때와 프리차지 타이밍이 겹치지 않게 프리차지 타이밍을 앞당기거나 또는 지연시킬 수 있다. 부연 설명하면, 인공신경망모델의 추론 연산은 정확도 개념으로 동작하기 때문에, 프리차지가 지연되어 저장된 데이터에 일부 손실이 발생하더라도, 추론 정확도 저하는 실질적으로 무시할 수 있는 수준일 수 있다. 부연 설명하면, 인공신경망은 생물학의 뇌 신경망을 모방하여 모델링한 수학적 모델이다. 뉴런(Neuron)이라 불 리는 인간의 신경세포는 시냅스(Synapse)라 불리는 신경세포의 접합부를 통하여 정보를 교환하며 신경세포와 신 경세포 간의 정보교환은 매우 단순하지만, 상당한 수의 신경세포가 모여 지능을 만들어 낸다. 이러한 구조는 몇 몇의 신경세포가 잘못된 정보를 전달하여도 전체 정보에 큰 영향을 끼치지 않으므로 적은 오류에 매우 강인한 장점을 지닌다. 즉, 상술한 특성 때문에, 인공신경망모델의 데이터를 저장하는 메모리의 프리차지 및 리프레쉬 기능을 선택적으로 제한하더라도 인공신경망모델의 정확도는 실질적으로 문제가 발생하지 않을 수 있으며 프리 차지 또는 리프레쉬에 의한 메모리 지연시간을 저감할 수 있는 효과가 있다. 상술한 구성에 따르면, 인공신경망 메모리 시스템은 추론 정확도가 실질적으로 저하되지 않게 하면서 프리차지 에 따른 인공신경망 연산 속도 저하를 개선할 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 메모리의 리프레쉬 기능 및 프리차지 기능을 각각 제어하도록 구성될 수 있다. 도 11은 본 개시의 또 다른 예시에 따른 인공신경망 메모리 시스템을 설명하는 개략적인 블록도이다. 도 11을 참조하면, 인공신경망 메모리 시스템은 프로세서, 캐쉬 메모리를 포함하는 인공신경망 메모리 제어부, 및 메모리를 포함하도록 구성될 수 있다. 프로세서(110, 210, 310)는 도 15a에 도시 된 SFU를 더 포함할 수 있다. 본 개시의 또 다른 예시에 따른 인공신경망 메모리 시스템을 본 개시의 다른 예시에 따른 인공신경망 메모 리 시스템과 비교하면, 인공신경망 메모리 시스템이 캐쉬 메모리를 더 포함하는 것을 제외하곤 실질적으로 동일하기 때문에, 이하 단지 설명의 편의를 위해서 중복 설명은 생략할 수 있다. 본 개시의 또 다른 예시에 따른 인공신경망 메모리 시스템은 예측된 데이터 접근 요청에 기초한 메모리 접 근 요청에 응답하여 메모리가 전송한 데이터를 저장하도록 구성된 캐쉬 메모리를 포함하는 인공신경 망 메모리 제어부를 포함하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 예측된 데이터 접근 요청에 기초한 메모리 접근 요청 에 응답한 데이터를 메모리에서 읽어와서 캐쉬 메모리에 저장할 수 있다. 따라서 프로세서가 실 제 데이터 접근 요청 생성 시, 인공신경망 메모리 제어부는 캐쉬 메모리에 저장된 데이터를 프로세서 에 바로 제공할 수 있는 효과가 있다. 캐쉬 메모리의 지연시간은 메모리의 지연시간보다 상대적으로 훨씬 짧다. 캐쉬 메모리의 대역폭 은 메모리의 대역폭보다 상대적으로 더 높다. 본 개시의 또 다른 예시에 따른 캐쉬 메모리를 포함한 인공신경망 메모리 시스템의 인공신경망모델 처리 성능은 본 개시의 다른 예시에 따른 인공신경망 메모리 시스템보다 상대적으로 더 우수할 수 있는 효 과가 있다. 다시, 도 3의 인공신경망모델을 참조하여 본 개시의 또 다른 예시에 따른 인공신경망 메모리 시스템(30 0)을 설명한다. 인공신경망모델은 특정 컴파일러(compiler)에 의해서 컴파일 되어 프로세서에서 연산 될 수도 있다. 컴파일러는 인공신경망 메모리 제어부에 인공신경망 데이터 지역성 패턴을 제공하도록 구성될 수도 있다. 인공신경망모델을 추론하기 위해서 프로세서는 인공신경망 데이터 지역성에 기초한 순서대로 데이터 접근 요청들을 생성하도록 구성된다. 따라서 인공신경망 메모리 제어부는 데이터 접근 요청들을 모니터링 하여 인공신경망 데이터 지역성 패턴을 생성할 수 있다. 또는, 인공신경망 메모리 제어부는 기 생성 된 인공신경망 데이터 지역성 패턴을 저장하고 있을 수도 있다. 이하 인공신경망 데이터 지역성 패턴이 생성되지 않은 경우를 설명한다. 먼저 프로세서는 입력 레이어의 노드 값 읽기에 대응되는 토큰[1]의 데이터 접근 요청을 생성할 수 있다. 따라서, 인공신경망 메모리 제어부는 토큰[1]의 메모리 접근 요청을 생성하여 메모리에서 전달 받은 입력 레이어의 노드 값을 프로세서에 전달할 수 있다. 이어서, 프로세서는 제1 연결망의 가중치 값 읽기에 대응되는 토큰[2]의 데이터 접근 요청을 생성할 수 있다. 따라서, 인공신경망 메모리 제어부는 토큰[2]의 메모리 접근 요청을 생성하여 메모리에서 전달 받은 제1 연결망의 가중치 값을 프로세서에 전달할 수 있다. 이어서, 프로세서는 입력 레이어의 노드 값과 제1 연결망의 가중치 값을 전달 받아 제1 은닉 레이어의 노드 값을 연산할 수 있다. 즉, 프로세서는 제1 은닉 레이어의 노드 값 쓰기에 대응 되는 토큰[3]의 데이터 접근 요청을 생성 할 수 있다. 따라서, 인공신경망 메모리 제어부는 토큰[3]의 메 모리 접근 요청을 생성하여 제1 은닉 레이어의 노드 값을 메모리에 저장할 수 있다. 이어서, 프로세서는 제1 은닉 레이어의 노드 값 읽기에 대응되는 토큰[4]의 데이터 접근 요청을 생 성할 수 있다. 따라서, 인공신경망 메모리 제어부는 토큰[4]의 메모리 접근 요청을 생성하여 메모리 에서 전달 받은 제1 은닉 레이어의 노드 값을 프로세서에 전달할 수 있다. 이어서, 프로세서는 제2 연결망의 가중치 값 읽기에 대응되는 토큰[5]의 데이터 접근 요청을 생성할 수 있다. 따라서, 인공신경망 메모리 제어부는 토큰[5]의 메모리 접근 요청을 생성하여 메모리에서 전달 받은 제2 연결망의 가중치 값을 프로세서에 전달할 수 있다. 이어서, 프로세서는 제1 은닉 레이어의 노드 값과 제2 연결망의 가중치 값을 전달 받아 제2 은닉 레이어의 노드 값을 연산할 수 있다. 즉, 프로세서는 제2 은닉 레이어의 노드 값 쓰기에대응되는 토큰[6]의 데이터 접근 요청을 생성 할 수 있다. 따라서, 인공신경망 메모리 제어부는 토큰[6]의 메모리 접근 요청을 생성하여 제2 은닉 레이어의 노드 값을 메모리에 저장할 수 있다. 이어서, 프로세서는 제2 은닉 레이어의 노드 값 읽기에 대응되는 토큰[7]의 데이터 접근 요청을 생 성할 수 있다. 따라서, 인공신경망 메모리 제어부는 토큰[7]의 메모리 접근 요청을 생성하여 메모리 에서 전달 받은 제2 은닉 레이어의 노드 값을 프로세서에 전달할 수 있다. 이어서, 프로세서는 제3 연결망의 가중치 값 읽기에 대응되는 토큰[8]의 데이터 접근 요청을 생성할 수 있다. 따라서, 인공신경망 메모리 제어부는 토큰[8]의 메모리 접근 요청을 생성하여 메모리에서 전달 받은 제3 연결망의 가중치 값을 프로세서에 전달할 수 있다. 이어서, 프로세서는 제2 은닉 레이어의 노드 값과 제3 연결망의 가중치 값을 전달 받아 출력 레이어의 노드 값을 연산할 수 있다. 즉, 프로세서는 출력 레이어의 노드 값 쓰기에 대응되는 토큰[9]의 데이터 접근 요청을 생성 할 수 있다. 따라서, 인공신경망 메모리 제어부는 토큰[9]의 메모리 접근 요청을 생성하여 출력 레이어의 노드 값을 메모리에 저장할 수 있다. 따라서, 인공신경망 메모리 시스템은 출력 레이어에 인공신경망모델의 추론 결과를 저장할 수 있다. 상술한 예시는 인공신경망 메모리 제어부에 인공신경망 데이터 지역성 패턴이 생성되지 않은 경우이 다. 따라서 상술한 예시는 예측된 데이터 접근 요청을 생성할 수 없다. 따라서 인공신경망 메모리 제어부 가 사전에 데이터를 제공하지 못했기 때문에 각각의 메모리 접근 요청마다 메모리의 지연시간이 발생할 수 있다. 하지만, 인공신경망 메모리 제어부가 데이터 접근 요청들을 기록하였기 때문에 다시 프로세서가 입력 레이어의 노드 값 읽기에 대응되는 토큰[1]의 데이터 접근 요청을 생성할 경우, 인공신경망 데이터 지역 성 패턴을 생성할 수 있다. 이하에서는 도 4를 다시 참조하여, 인공신경망 데이터 지역성 패턴이 생성된 경우를 설명한다. 이하의 예시는, 인공신경망 데이터 지역성 패턴이 생성되고, 프로세서가 인공신경망모델을 반 복 추론 중인 경우일 수 있다. 단, 이에 제한되지 않는다. 프로세서는 반복된 토큰[1]의 데이터 접근 요청을 감지하여 인공신경망 데이터 지역성 패턴을 생성 할 수 있다. 부연 설명하면, 인공신경망 메모리 제어부가 토큰[1] 부터 토큰[9]를 순차적으로 저장하였기 때문에, 인공신경망 메모리 제어부가 토큰[1]을 다시 감지할 때 인공신경망 데이터 지역성을 결정할 수 있 다. 다만, 상술하였듯이 본 개시의 예시들에 따른 인공신경망 메모리 제어부는 토큰에 제한되지 않으며, 토큰은 단 지 설명의 편의를 위할 뿐이며, 데이터 접근 요청 및 메모리 접근 요청에 포함된 식별 정보에 의해서 본 개시의 예시들은 구현될 수 있다. 예를 들면, 프로세서가 토큰[9]의 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 토큰"}
{"patent_id": "10-2023-0144762", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "[1]의 예측된 데이터 접근 요청을 생성한다. 따라서 인공신경망 메모리 제어부는 토큰[1]의 메모리 접근 요청을 생성하여 입력 레이어의 노드 값을 사전에 캐쉬 메모리에 저장할 수 있다. 즉, 토큰[9]의 데이터 접근 요청이 인공신경망모델의 마지막 단계라면, 인공신경망 메모리 제어부는 인공신경망모델의 시작 단계인 토큰[1]의 데이터 접근 요청이 생성될 것으로 예측할 수 있다. 이어서, 프로세서가 토큰[1]의 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 토큰[1]의 예측된 데이터 접근 요청과 토큰[1]의 데이터 접근 요청이 동일한지를 결정한다. 동일하다고 결정된 경우, 캐쉬 메모리에 저장된 입력 레이어의 노드 값을 프로세서에 바로 제공할 수 있다. 이때, 인공신경망 메모리 제어부는 토큰[2]의 예측된 데이터 접근 요청을 생성한다. 따라서, 인공신경망 메모리 제어부는 토큰[2]의 메모리 접근 요청을 생성하여 제1 연결망의 가중치 값을 사전에 캐쉬 메모리에 저장할 수 있다. 이어서, 프로세서가 토큰[2]의 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 토큰[2]의 예측된 데이터 접근 요청과 토큰[2]의 데이터 접근 요청이 동일한지를 결정한다. 동일하다고 결정된 경우, 캐쉬메모리에 저장된 제1 연결망의 노드 값을 프로세서에 바로 제공할 수 있다. 이때, 인공신경망 메모리 제어부는 토큰[3]의 예측된 데이터 접근 요청을 생성한다. 이어서, 프로세서는 입력 레이어의 노드 값과 제1 연결망의 가중치 값을 전달 받아 제1 은닉 레이어의 노드 값을 연산할 수 있다. 프로세서가 토큰[3]의 데이터 접근 요청을 생성하면, 인공신경 망 메모리 제어부는 토큰[3]의 예측된 데이터 접근 요청과 토큰[3]의 데이터 접근 요청이 동일한지를 결정 한다. 동일하다고 결정된 경우, 연산된 제1 은닉 레이어의 노드 값이 메모리 및/또는 캐쉬 메모리 에 저장될 수 있다. 캐쉬 메모리에 대하여 부연 설명하면, 캐쉬 메모리 없이 동일한 데이터가 토큰[3]의 메모리 접근 요 청으로 메모리에 저장되고, 다시 토큰[4]의 메모리 접근 요청으로 메모리에서 읽어 올 경우, 메모리 의 지연시간이 2배가 될 수 있다. 이러한 경우, 인공신경망 메모리 제어부는 연속된 토큰들의 메모리 주소 값이 동일하고, 앞선 토큰의 동작 모드는 쓰기 모드이고 다음 토큰의 동작 모드는 읽기 모드인 것을 기초로 연산된 레이어의 노드 값을 저장하고, 해당 노드 값을 다음 레이어의 입력 값으로 사용한다고 결정하도록 구성될 수 있다. 즉, 캐쉬 메모리에 토큰[3]의 데이터가 저장되면, 토큰[3] 및 토큰[4]에 대응되는 데이터 접근 요청이 캐 쉬 메모리에서 처리될 수 있다. 따라서 인공신경망 메모리 제어부는 토큰[3]의 데이터 접근 요청과 토큰[4]의 데이터 접근 요청에 대응되는 메모리 접근 요청들을 생성하지 않도록 구성될 수 있다. 상술한 구성에 따르면 토큰[3]의 메모리 접근 요청 및 토큰[4]의 메모리 접근 요청으로 메모리에 의한 메모리의 지 연시간을 제거할 수 있는 효과가 있다. 특히 이러한 캐쉬 메모리 운영 정책은 인공신경망 데이터 지역성 패턴에 기초하여 실행될 수 있다. 이때, 인공신경망 메모리 제어부는 토큰[4]의 예측된 데이터 접근 요청을 생성한다. 이어서, 프로세서가 토큰[4]의 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 토큰[4]의 예측된 데이터 접근 요청과 토큰[4]의 데이터 접근 요청이 동일한지를 결정한다. 동일하다고 결정된 경우, 캐쉬 메모리에 저장된 제1 은닉 레이어의 노드 값을 프로세서에 바로 제공할 수 있다. 이때, 인공신경망 메모리 제어부는 토큰[5]의 예측된 데이터 접근 요청을 생성한다. 따라서, 인공신경망 메모리 제어부는 토큰[5]의 메모리 접근 요청을 생성하여 제2 연결망의 가중치 값을 사전에 캐쉬 메모리에 저장할 수 있다. 이어서, 프로세서가 토큰[5]의 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 토큰[5]의 예측된 데이터 접근 요청과 토큰[5]의 데이터 접근 요청이 동일한지를 결정한다. 동일하다고 결정된 경우, 캐쉬 메모리에 저장된 제2 연결망의 가중치 값을 프로세서에 바로 제공할 수 있다. 이때, 인공신경망 메모리 제어부는 토큰[6]의 예측된 데이터 접근 요청을 생성한다. 이어서, 프로세서는 제1 은닉 레이어의 노드 값과 제2 연결망의 가중치 값을 전달 받아 제2 은닉 레이어의 노드 값을 연산할 수 있다. 프로세서가 토큰[6]의 데이터 접근 요청을 생성하면, 인 공신경망 메모리 제어부는 토큰[6]의 예측된 데이터 접근 요청과 토큰[6]의 데이터 접근 요청이 동일한지 를 결정한다. 동일하다고 결정된 경우, 연산 된 제2 은닉 레이어의 노드 값을 메모리 및/또는 캐쉬 메모리에 저장할 수 있다. 이때, 인공신경망 메모리 제어부는 토큰[7]의 예측된 데이터 접근 요청을 생성한다. 이어서, 프로세서가 토큰[7]의 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 토큰[7]의 예측된 데이터 접근 요청과 토큰[7]의 데이터 접근 요청이 동일한지를 결정한다. 동일하다고 결정된 경우, 캐쉬 메모리에 저장된 제2 은닉 레이어의 노드 값은 프로세서에 바로 제공될 수 있다. 이때, 인공신경망 메모리 제어부는 토큰[8]의 예측된 데이터 접근 요청을 생성한다. 따라서, 인공신경망 메모리 제어부는 토큰[8]의 메모리 접근 요청을 생성하여 제3 연결망의 가중치 값을 사전에 캐쉬 메모리에 저장할 수 있다. 이어서, 프로세서가 토큰[8]의 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 토큰[8]의 예측된 데이터 접근 요청과 토큰[8]의 데이터 접근 요청이 동일한지를 결정한다. 동일하다고 결정된 경우, 캐쉬메모리에 저장된 제3 연결망의 가중치 값을 프로세서에 바로 제공할 수 있다. 이때, 인공신경망 메모리 제어부는 토큰[9]의 예측된 데이터 접근 요청을 생성한다. 이어서, 프로세서는 제2 은닉 레이어의 노드 값과 제3 연결망의 가중치 값을 전달 받아 출력 레이어의 노드 값을 연산할 수 있다. 프로세서가 토큰[9]의 데이터 접근 요청을 생성하면, 인공신경 망 메모리 제어부는 토큰[9]의 예측된 데이터 접근 요청과 토큰[9]의 데이터 접근 요청이 동일한지를 결정 한다. 동일하다고 결정된 경우, 연산 된 출력 레이어의 노드 값을 메모리 및/또는 캐쉬 메모리(32 2)에 저장할 수 있다. 따라서, 인공신경망 메모리 시스템은 출력 레이어에 인공신경망모델의 추론 결과를 저장할 수 있다. 인공신경망 메모리 시스템은 인공신경망 데이터 지역성 패턴에 의해서 인공신경망모델의 추론 이 끝나더라도 다음 추론을 즉각 시작하도록 준비할 수 있는 효과가 있다. 즉, 본 개시의 또 다른 예시에 따른 인공신경망 메모리 시스템은 인공신경망 데이터 지역성에 기초하여 예 측된 데이터 접근 요청을 생성하고, 예측된 데이터 접근 요청과 실제 데이터 접근 요청이 동일한지 결정하고, 동일할 경우 다음 순서의 예측된 데이터 접근 요청을 더 생성하도록 구성될 수 있다. 상술한 구성에 따르면, 인 공신경망 메모리 제어부는 각각의 데이터 접근 요청 처리 시 메모리의 지연시간을 제거 또는 저감할 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부는 예측된 데이터 접근 요청을 적어도 하나 이상 생성하여 캐쉬 메 모리의 여유 공간을 최소화하도록 동작하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 캐쉬 메모리의 메모리 여유 공간과 저장할 데이터 값의 크기를 비교하여, 캐쉬 메모리의 메모리 여유 공간이 있는 경우, 예측된 데이터 접근 요청을 적어도 하나 이상 생성하여 캐쉬 메모리의 여유 공간을 최소화하도록 구성될 수 있다. 즉, 캐쉬 메모리의 용량에 따라 인공신경망 메모리 제어부가 복수개의 예측된 데이터 접근 요청들을 생성하도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는 캐쉬 메모리의 잔여 용량에 기초 하여 메모리 접근 요청을 적어도 하나 이상 순차적으로 생성하여 캐쉬 메모리의 잔여 용량이 최소화되도록 구성될 수 있다. 도 2 내지 도 6을 참조하여 예시를 설명 한다. 프로세서가 토큰[1]의 데이터 접근 요청을 생성하면, 인공신경망 메모리 제어부는 토큰[2]의 예측된 데이터 접근 요청을 생성하여 제1 연결망의 가중치 값을 사전에 캐쉬 메모리에 저장할 수 있다. 이어서, 인공신경망 메모리 제어부는 토큰[3] 및 토큰[4]에 대응되는 제1 은닉 레이 어의 노드 값 연산 처리 결과를 저장하고 읽을 공간을 사전에 캐쉬 메모리에 할당할 수 있다. 이어서 인 공신경망 메모리 제어부는 토큰[5]에 대응되는 제2 연결망의 가중치 값을 사전에 캐쉬 메모리에 저장할 수 있다. 여기서 인공신경망 메모리 제어부는 캐쉬 메모리에 여유가 있을 경우, 인공신경망 데이터 지역성 패턴 에 기초하여 예측된 데이터 접근 요청을 순차적으로 더 생성하도록 구성될 수 있다. 즉, 캐쉬 메모리에 용량의 여유가 있는 경우, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 캐쉬 메모리에 가중 치 값들을 미리 저장하거나 인공신경망 연산 결과를 저장할 영역을 사전에 확보하도록 구성될 수 있다. 만약, 캐쉬 메모리의 용량이 충분할 경우, 인공신경망모델의 모든 연결망들의 가중치 값들을 캐쉬 메모리 에 저장하도록 구성될 수 있다. 특히, 학습이 완료된 인공신경망모델의 경우 가중치 값들은 고정된다. 따라서 가중치 값들이 캐쉬 메모리에 상주할 경우, 가중치 값들을 읽기 위한 메모리 접근 요청에 의한 메모리 지연시간 을 제거할 수 있는 효과가 있다. 상술한 구성에 따르면, 인공신경망 데이터 지역성을 기초로 캐쉬 메모리에 필요한 데이터를 저장함으로 캐쉬 메 모리의 가동 효율을 최적화 하고 인공신경망 메모리 시스템의 처리 속도를 향상시킬 수 있는 효과가 있다. 상술한 구성에 따르면 캐쉬 메모리가 인공신경망 데이터 지역성 패턴 및 캐쉬 메모리의 용량을 모두 고려하여 예측된 데이터 접근 요청을 순차적으로 생성하기 때문에, 인공신경망 메모리 시스템의 처리 속도가 향상될 수 있는 효과가 있다. 상술한 구성에 따르면, 프로세서가 인공신경망 데이터 지역성 패턴에 포함된 특정 데이터 접근 요청을 생 성하면 인공신경망 메모리 제어부는 특정 데이터 접근 요청 이후의 데이터 접근 요청들을 적어도 하나 이상 순차적으로 예측할 수 있는 효과가 있다. 예를 들면, 토큰[1]의 데이터 접근 요청을 프로세서가 생성하면, 인공신 경망 메모리 제어부는 토큰 [2-3-4-5-6-7-8-9] 순서로 대응되는 데이터 접근 요청들이 생성될 것을 예측할 수 있는 효과가 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 특정 가중치 값들은 캐쉬 메모리에 특정 기간동안 상 주 시킬 수 있다. 예를 들어, 프로세서가 초당 30회 속도로 인공신경망모델을 활용해 추론을 할 경우, 특정 레 이어의 가중치 값을 캐쉬 메모리에 상주시킬 수 있다. 이러한 경우, 인공신경망 메모리 제어부는 캐쉬 메모리에 저장된 가중치 값을 각각의 추론마다 재활용할 수 있는 효과가 있다. 따라서 대응되는 메모리 접근 요청을 선택 적으로 삭제할 수 있는 효과가 있다. 따라서 메모리 접근 요청에 따른 지연시간을 제거할 수 있는 효과가 있다. 몇몇 예시에서는, 캐쉬 메모리는 계층화 된 복수의 캐쉬 메모리로 구성될 수 있다. 예를 들면, 가중치 값을 저 장하도록 구성된 캐쉬 메모리 또는 특징맵을 저장하도록 구성된 캐쉬 메모리 등을 포함할 수 있다. 몇몇 예시에서는, 인공신경망 데이터 지역성 패턴이 생성된 경우, 인공신경망 메모리 제어부는 데이터 접 근 요청에 포함된 식별 정보에 기초하여 가중치 값, 노드 값을 예측하도록 구성될 수 있다. 따라서 인공신경망 메모리 제어부는 가중치 값에 대응되는 데이터 접근 요청을 식별하도록 구성될 수 있다. 구체적으로 설명하면, 학습이 완료되어 연결망의 가중치 값이 고정되었다고 가정하면, 인공신경망 데이터 지역성 패턴에서 가중 치 값은 읽기 모드로만 동작하도록 구성될 수 있다. 따라서 인공신경망 메모리 제어부는 토큰[2], 토큰[5], 토 큰[8]를 가중치 값으로 결정할 수 있다. 부연 설명하면, 토큰[1]은 추론의 시작 단계이기 때문에 입력 노드 값 이라고 결정할 수 있다. 부연 설명하면, 토큰[9]는 추론의 마지막 단계이기 때문에 출력 노드 값이라고 결정할 수 있다. 부연 설명하면, 토큰[3][4]는 동일한 메모리 주소 값의 쓰기 모드 및 읽기 모드의 순서를 가지기 때문 에 은닉 레이어의 노드 값이라고 결정할 수 있다. 단, 이는 인공신경망모델의 인공신경망 데이터 지역성에 따라 달라질 수 있다. 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴을 분석하여 각각의 데이터 접근 요청이 인공신경망 모델의 가중치 값, 커널 윈도우 값, 노드 값, 활성화 맵 값 등인지를 결정하도록 구성될 수 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템은 인공신경망 연산에 대응되는 데이터 접근 요청을 생성하도록 구 성된 프로세서, 컴파일러가 생성한 인공신경망 데이터 지역성 패턴을 저장하도록 구성되고, 인공신경망 데이터 지역성 패턴에 기초하여 프로세서가 생성한 데이터 접근 요청의 실제 데이터 접근 요청을 예측한 예측된 데이터 접근 요청을 생성하도록 구성된, 인공신경망 메모리 제어부, 및 인공신경망 메모리 제어부와 통신하도록 구성된 메모리를 포함한다. 메모리는 인공신경망 메모리 제어부에서 출력되는 메모리 접근 요청에 대응하여 동작하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 컴파일러로부터 생성된 인공신경망 데이터 지역성 패턴을 제공받도록 구성될 수 있다. 이러한 경우, 인공신공망 메모리 제어부는 컴파일러가 생성한 인공신경망 데이터 지역성 패턴을 기초로 프로세서가 처리중인 인공신경망모델의 데이터 접근 요청들을 사전에 캐쉬 메모리에 준비 시킬 수 있는 효과가 있다. 특히 컴파일러가 생성한 인공신경망 데이터 지역성 패턴은 인공신경망 데이터 지역 성을 모니터링하여 생성된 인공신경망 데이터 지역성 패턴보다 더 정확할 수 있는 효과가 있다. 부연 설명하면, 인공신경망 메모리 제어부는 컴파일러에 의해 생성된 인공신경망 데이터 지역성 패턴과 자체적 으로 데이터 접근 요청을 모니터링 하여 생성한 인공신경망 데이터 지역성 패턴을 각각 저장하도록 구성될 수 있다. 도 12는 데이터 접근 요청의 예시적인 식별 정보를 설명하는 개략도이다. 본 개시의 예시들에 따른 프로세서가 생성하는 데이터 접근 요청은 적어도 하나의 추가 식별 정보를 더 포함하 도록 구성될 수 있다. 추가 식별 정보는 사이드 밴드 신호 또는 정보로 지칭되는 것도 가능하다. 프로세서가 생성하는 데이터 접근 요청은 특정한 구조의 인터페이스 신호일 수 있다. 즉, 데이터 접근 요청은 프로세서와 인공신경망 메모리 제어부의 통신을 위한 인터페이스 신호일 수 있다. 데이터 접근 요청은 인터페이 스 신호에 추가 비트를 더 포함하여 인공신공망 연산에 필요한 식별 정보를 추가적으로 제공하도록 구성될 수 있다. 단, 본 개시는 이에 제한되지 않으며, 다양한 방식으로 추가 식별 정보를 제공하도록 구성될 수 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템의 데이터 접근 요청은 인공신경망 연산인지 여부를 식별할 수 있는 식별 정보를 더 포함하도록 구성될 수 있다. 단, 본 개시의 예시들은 이에 제한되지 않는다. 예를 들면, 인공신경망 메모리 시스템은 데이터 접근 요청에 1 비트의 식별 코드를 추가하여 인공신경망 메모리 제어부가 수신한 데이터 접근 요청이 인공신경망 연산과 관련된 데이터 접근 요청인지를 식별하도록 구성될 수 있다. 단 본 개시의 예시들에 따른 식별 코드의 비트 수는 제한되지 않으며, 식별하고자 하는 대상의 경우의 수 에 따라 조절될 수 있다. 예를 들면, 식별 코드가 [0]일 경우, 인공신경망 메모리 제어부는 해당 데이터 접근 요청이 인공신경망 연산과 관련 있다고 결정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [1]일 경우 인공신경망 메모리 제어부는 해당 데이터 접근 요청이 인공신경망 연산과 관련 없다고 결정하도록 구성될 수 있다. 이러한 경우, 인공신경망 메모리 제어부는 데이터 접근 요청에 포함된 식별 정보에 기초하여 인공신경망 연산과 관련된 데이터 접근 요청만 기록하여 인공신경망 데이터 지역성 패턴을 생성하도록 구성될 수 있다. 상술한 구 성에 따르면, 인공신경망 메모리 제어부는 인공신경망 연산과 관련 없는 데이터 접근 요청은 기록하지 않을 수 있다. 따라서 데이터 접근 요청들을 기록하여 생성되는 인공신경망 데이터 지역성 패턴의 정확도를 향상시킬 수 있는 효과가 있다. 단, 본 개시의 예시들은 이에 제한되지 않는다. 몇몇 예시에서는, 인공신경망 메모리 시스템의 데이터 접근 요청은 인공신경망 연산이 학습을 위한 연산인지 또 는 추론을 위한 연산인지 여부를 식별할 수 있는 식별 정보를 더 포함하도록 구성될 수 있다. 단, 본 개시의 예 시들은 이에 제한되지 않는다. 예를 들면, 인공신경망 메모리 시스템은 데이터 접근 요청에 1 비트의 식별 코드를 추가하여 인공신경망 메모리 제어부가 수신한 데이터 접근 요청이 인공신경망모델의 동작 유형이 학습인지 또는 추론인지를 식별하도록 구성 될 수 있다. 단 본 개시의 예시들에 따른 식별 코드의 비트 수는 제한되지 않으며, 식별하고자 하는 대상의 경 우의 수에 따라 조절될 수 있다. 예를 들면, 식별 코드가 [0]일 경우, 인공신경망 메모리 제어부는 해당 데이터 접근 요청이 학습 동작으로 결정 하도록 구성될 수 있다. 예를 들면, 식별 코드가 [1]일 경우, 인공신경망 메모리 제어부는 해당 데이터 접근 요청이 추론 동작 결정하도 록 구성될 수 있다. 이러한 경우, 인공신경망 메모리 제어부는 학습 동작의 데이터 접근 요청과 추론 동작의 데이터 접근 요청을 구 분하여 기록하여 인공신경망 데이터 지역성 패턴을 생성하도록 구성될 수 있다. 예를 들면, 학습 모드에선, 인 공신경망모델의 각각의 레이어 및/또는 커널 윈도우의 가중치 값들을 갱신할 수 있고, 학습된 인공신경망모델의 추론 정확도를 결정하는 평가 단계가 더 포함될 수 있다. 따라서 인공신경망모델의 구조가 동일하더라도, 프로 세서가 처리하는 인공신경망 데이터 지역성은 학습 동작 또는 추론 동작 시 서로 상이할 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 특정 인공신경망모델의 학습 모드의 인공신경망 데이터 지 역성 패턴과 추론 모드의 인공신경망 데이터 지역성 패턴을 구분하여 생성하도록 구성될 수 있다. 따라서 인공 신경망 메모리 제어부가 데이터 접근 요청들을 기록하여 생성한 인공신경망 데이터 지역성 패턴의 정확도를 향 상시킬 수 있는 효과가 있다. 단, 본 개시의 예시들은 이에 제한되지 않는다. 몇몇 예시에서는, 인공신경망 메모리 시스템의 데이터 접근 요청은 메모리 읽기 동작 및 메모리 쓰기 동작을 식 별할 수 있는 식별 정보를 포함하는 동작 모드로 구성될 수 있다. 단, 이에 제한되지 않으며, 인공신경망 메모 리 시스템의 데이터 접근 요청은 덮어쓰기 동작 및/또는 보호 동작을 식별할 수 있는 식별 정보를 더 포함하는 동작 모드로 구성될 수 있다. 단, 본 개시의 예시들은 이에 제한되지 않는다. 예를 들면, 인공신경망 메모리 시스템의 데이터 접근 요청에 1 비트의 식별 코드를 추가하여 읽기 동작과 쓰기 동작을 포함하도록 구성될 수 있다. 또는 인공신경망 메모리 시스템의 데이터 접근 요청에 2 비트의 식별 코드 를 추가하여 읽기 동작, 쓰기 동작, 덮어쓰기 동작, 및 보호 동작을 식별하도록 구성될 수 있다. 단 본 개시의 예시들에 따른 식별 코드의 비트 수는 제한되지 않으며, 식별하고자 하는 대상의 경우의 수에 따라 조절될 수 있다. 부연 설명하면, 인공신경망 메모리 시스템의 동작을 위해서 데이터 접근 요청은 적어도 메모리 주소 값과 읽기 동작 및 쓰기 동작을 식별할 수 있는 식별 정보를 포함해야 한다. 인공신경망 메모리 제어부는 데이터 접근 요 청을 수신하여 대응되는 메모리 접근 요청을 생성하여 메모리 동작을 수행하도록 구성될 수 있다. 예를 들면, 식별 코드가 [001]일 경우, 인공신경망 메모리 제어부는 해당 데이터 접근 요청은 쓰기 동작으로 결 정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [010]일 경우, 인공신경망 메모리 제어부는 해당 데이터 접근 요청은 덮어쓰기 동작으 로 결정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [011]일 경우, 인공신경망 메모리 제어부는 해당 데이터 접근 요청은 보호 동작으로 결 정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [100]일 경우, 인공신경망 메모리 제어부는 해당 데이터 접근 요청은 읽기-버스트 동작 으로 결정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [001]일 경우, 인공신경망 메모리 제어부는 해당 데이터 접근 요청은 쓰기-버스트 동작 으로 결정하도록 구성될 수 있다. 단, 본 개시의 예시들은 이에 제한되지 않는다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 읽기 모드 또는 쓰기 모드에 따라 메모리를 제어하여 인공 신경망모델의 다양한 데이터를 메모리로부터 제공받거나 또는 메모리에 저장할 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 인공신경망의 학습 동작 시 덮어쓰기 모드에 의해서 특정 레이어의 가중치 값을 갱신할 수 있다. 특히 갱신된 가중치 값은 동일한 메모리 주소 값에 저장되기 때문에 새 로운 메모리 주소를 할당하지 않을 수 있다. 따라서 쓰기 모드보다 덮어쓰기 모드가 학습 동작 시 더 효율적일 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 보호 모드에 의해서 특정 메모리 주소에 저장된 데이터를 보호할 수 있다. 특히 서버와 같은 다수의 사용자가 접근하는 환경에서 인공신경망모델의 데이터가 임의로 삭제 되는 것을 방지할 수 있는 효과가 있다. 또한 학습이 완료된 인공신경망모델의 가중치 값들을 보호 모드로 보호 하는 것도 가능하다. 몇몇 예시에서는, 인공신경망 메모리 시스템의 데이터 접근 요청은 추론 데이터, 가중치, 특징맵, 학습 데이터 세트, 평가 데이터 세트 및 기타 여부를 식별할 수 있는 식별 정보를 더 포함하도록 구성될 수 있다. 단, 본 개 시의 예시들은 이에 제한되지 않는다. 예를 들면, 인공신경망 메모리 시스템은 데이터 접근 요청에 3 비트의 식별 코드를 추가하여 인공신경망 메모리 제어부가 접근할 데이터의 도메인을 식별하도록 구성될 수 있다. 단 본 개시의 예시들에 따른 식별 코드의 비트 수는 제한되지 않으며, 식별하고자 하는 대상의 경우의 수에 따라 조절될 수 있다. 예를 들면, 식별 코드가 [000]일 경우, 인공신경망 메모리 제어부는 해당 데이터가 인공신경망모델과 관련 없는 데이터로 결정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [001]일 경우, 인공신경망 메모리 제어부는 해당 데이터가 인공신경망모델의 추론 데이 터로 결정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [010]일 경우, 인공신경망 메모리 제어부는 해당 데이터가 인공신경망모델의 특징맵으 로 결정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [011]일 경우, 인공신경망 메모리 제어부는 해당 데이터가 인공신경망모델의 가중치로 결정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [100]일 경우, 인공신경망 메모리 제어부는 해당 데이터가 인공신경망모델의 학습 데이 터 세트로 결정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [101]일 경우, 인공신경망 메모리 제어부는 해당 데이터가 인공신경망모델의 추론 데이 터 세트로 결정하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 인공신경망모델의 데이터의 도메인을 식별하고, 각각의 도 메인에 해당되는 데이터가 저장되는 메모리의 주소를 할당하도록 구성될 수 있다. 예를 들면, 인공신경망 메모 리 제어부는 각각의 도메인에 할당된 메모리 영역의 시작 수조 및 끝 주소를 설정할 수 있다. 상술한 구성에 따 르면, 각각의 도메인에 할당된 데이터를 인공신경망 데이터 지역성 패턴의 순서에 대응되도록 저장할 수 있다. 예를 들면, 인공신경망모델의 각각의 도메인의 데이터들은 각각의 도메인에 할당된 메모리 영역에 순차적으로 저장될 수 있다. 이때 해당 메모리는 읽기-버스트(read-burst) 기능을 지원할 수 있는 메모리일 수 있다. 상술 한 구성에 따르면, 인공신경망 메모리 제어부가 메모리에서 특정 도메인의 데이터를 읽어올 때, 특정 데이터가 인공신경망 데이터 지역성 패턴에 따라 저장되었기 때문에 읽기-버스트 기능에 최적화 되도록 구성될 수 있다. 즉, 인공신경망 메모리 제어부는, 메모리의 저장 영역을 읽기-버스트 기능을 고려하여 설정하도록 구성될 수 있 다. 몇몇 예시에서는, 메모리는 읽기-버스트 기능을 더 포함하고, 적어도 하나의 인공신경망 메모리 제어부는, 적어 도 하나의 메모리의 저장 영역을 읽기-버스트 기능을 고려하여 쓰도록 구성될 수 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템의 데이터 접근 요청은, 인공신경망모델의 양자화를 식별할 수 있는 식별 정보를 더 포함하도록 구성될 수 있다. 단, 본 개시의 예시들은 이에 제한되지 않는다. 예를 들면, 인공신경망 메모리 시스템은 데이터 접근 요청에 적어도 메모리 주소 값, 도메인, 및 양자화 식별 정보가 포함할 경우, 해당 도메인의 데이터의 양자화 정보를 식별하도록 구성될 수 있다. 예를 들면, 식별 코드가 [00001]일 경우, 인공신경망 메모리 제어부는 해당 데이터가 1 비트로 양자화된 데이터 로 결정하도록 구성될 수 있다. 예를 들면, 식별 코드가 [11111]일 경우, 인공신경망 메모리 제어부는 해당 데이터가 32 비트로 양자화된 데이 터로 결정하도록 구성될 수 있다. 몇몇 예시에서는 데이터 접근 요청에 다양한 식별 정보가 선택적으로 포함될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 데이터 접근 요청의 식별 코드를 분석하여, 보다 정확한 인 공신경망 데이터 지역성 패턴을 생성할 수 있는 효과가 있다. 또한 각각의 식별 정보를 파악함으로 써 메모리의 저장 정책을 선택적으로 제어할 수 있게 하는 효과도 있다. 예를 들면, 학습과 추론을 식별 할 수 있으면, 각각의 인공신경망 데이터 지역성 패턴을 생성할 수 있다. 예를 들면, 데이터의 도메인을 식별할 수 있으면, 인공신경망 데이터 지역성 패턴의 데이터를 특정 메모리 영역 에 저장하는 정책을 수립하여, 메모리 동작의 효율성을 향상시킬 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템이 복수의 인공신경망모델을 처리하도록 구성될 경우, 인공신경망 메모리 제어부는 인공신경망모델의 식별 정보, 예를 들면, 제1 인공신경망모델, 제2 인공신경망모델 등의 추가 식별 정보를 더 생성하도록 구성될 수 있다. 이때, 인공신경망 메모리 제어부는 각각의 인공신경망모델의 인공 신경망 데이터 지역성에 기초하여 인공신경망모델을 구분하도록 구성될 수 있다. 단, 이에 제한되지 않는다. 도 12에 도시된 사이드밴드 시그널과 ANN(인공신경망) 데이터 지역성 정보는 선택적으로 통합되거나 또는 분리 될 수 있다. 인공신경망 연산: SAM MEMORY CONTROLLER에서 해당 데이터의 ANN 연산 여부를 판단할 수 있다. 동작 유형 : SAM MEMORY CONTROLLER에서 해당 데이터가 학습인지, 추론인지 여부를 판단할 수 있다. (추론 모드 시 가중치 값 갱신 스케줄) 동작 모드 : SAM MEMORY CONTROLLER에서 RAM을 동작 제어할 수 있음(Kernel의 경우 Domain을 보고 refresh 할 수 있고, 특징 맵의 경우 read-discard 할 수 있다) DOMAIN : SAM MEMORY CONTROLLER에서 MEMORY MAP 설정에 필요한 정보일 수 있다.(ANN 데이터 지역성 정보에 따 라 DOMAIN이 동일한 데이터를 특정 영역에 할당할 수 있다) 양자화 : SAM MEMORY CONTROLLER는 해당 데이터의 양자화 정보를 제공할 수 있다. ANN MODEL # : SAM MEMORY CONTROLLER는 각각의 모델을 ANN 데이터 지역성 정보에 따라서 MEMORY MAP에 각각 할당할 수 있다. 최소 ANN의 전체 DATA 크기는 확보할 수 있다. MULTI-THREAD : SAM MEMORY CONTROLLER는 각각의 ANN MODEL의 THREAD 개수에 따라서, 커널은 공유하고, 특징 맵은 각각 할당할 수 있다. ANN 데이터 지역성(DATA LOCALITY) : ANN의 데이터 지역성 정보의 현재 처리 단계를 의미하는 정보. 한편, 모든 사이드밴드 시그널은 PACKET으로 구현될 수도 있다. 도 13은 인공신경망 메모리 시스템의 단위 동작 당 에너지 소모를 설명하는 개략도이다. 도 13을 참조하면, 인공신경망 메모리 시스템의 단위 동작 당 소비되는 에너지를 개략적으로 설명하는 표 이다. 에너지 소모는 메모리 액세스, 덧셈 연산 및 곱셈 연산으로 구분하여 설명할 수 있다. “8b Add”는 가산기의 8비트 정수 덧셈 연산을 의미한다. 8비트 정수 덧셈 연산은 0.03pj의 에너지를 소비할 수 있다. “16b Add”는 가산기의 16비트 정수 덧셈 연산을 의미한다. 16비트 정수 덧셈 연산은 0.05pj의 에너지를 소비 할 수 있다. “32b Add”는 가산기의 32비트 정수 덧셈 연산을 의미한다. 32비트 정수 덧셈 연산은 0.1pj의 에너지를 소비할 수 있다. “16b FP Add”는 가산기의 16비트 부동소수점 덧셈 연산을 의미한다. 16비트 부동소수점 덧셈 연산은 0.4pj의 에너지를 소비할 수 있다. “32b FP Add”는 가산기의 32비트 부동소수점 덧셈 연산을 의미한다. 32비트 부동소수점 덧셈 연산은 0.9pj의 에너지를 소비할 수 있다. “8b Mult”는 곱셈기의 8비트 정수 곱셈 연산을 의미한다. 8비트 정수 곱셈 연산은 0.2pj의 에너지를 소비할 수 있다. “32b Mult”는 곱셈기의 32비트 정수 곱셈 연산을 의미한다. 32비트 정수 곱셈 연산은 3.1pj의 에너지를 소비 할 수 있다. “16b FP Mult”는 곱셈기의 16비트 부동소수점 곱셈 연산을 의미한다. 16비트 부동소수점 곱셈 연산은 1.1pj의 에너지를 소비할 수 있다. “32b FP Mult”는 곱셈기의 32비트 부동소수점 곱셈 연산을 의미한다. 32비트 부동소수점 곱셈 연산은 3.7pj의 에너지를 소비할 수 있다. “32b SRAM Read”는 인공신경망 메모리 시스템의 캐쉬 메모리가 SRAM(static random access memory)일 경우, 32비트의 데이터 읽기 액세스를 의미한다. 32비트의 데이터를 캐쉬 메모리에서 프로세서 로 읽어오는데 5pj의 에너지를 소비할 수 있다. “32b DRAM Read”는 인공신경망 메모리 시스템의 메모리가 DRAM일 경우, 32비트의 데이터 읽기 액세 스를 의미한다. 32비트 데이터를 메모리에서 프로세서로 읽어오는데 640pj의 에너지를 소비할 수 있 다. 에너지 단위는 피코-줄(pj)을 의미한다. 인공신경망 메모리 시스템이 32비트 부동소수점 곱셈을 하는 경우와 8비트 정수 곱셈을 하는 경우를 비교 하면, 단위 동작 당 에너지 소모는 대략 18.5배 차이가 난다. DRAM으로 구성된 메모리에서 32비트 데이터 를 읽어오는 경우와 SRAM으로 구성된 캐쉬 메모리에서 32비트 데이터를 읽어오는 경우 단위 동작 당 에너 지 소모는 대략 128배 차이가 난다. 즉, 소비전력 관점에서, 데이터의 비트 크기가 증가할수록 소비전력이 증가한다. 또한 부동 소수점 연산을 사용 하면 정수 연산보다 소비전력이 증가한다. 또한 DRAM에서 데이터를 읽어올 경우 소비전력이 급격히 증가한다. 이에 본 개시의 또 다른 예시에 따른 인공신경망 메모리 시스템은 캐쉬 메모리의 용량을 인공신경망 모델의 데이터 값을 모두 저장할 수 있는 정도의 용량으로 구성될 수 있다. 본 개시의 예시들에 따른 캐쉬 메모리는 SRAM에 제한되지 않는다. SRAM과 같은 고속 구동이 가능한 정적 메모리 는 SRAM, MRAM, STT-MRAM, eMRAM, 및 OST-MRAM 등이 있다. 더 나아가서, MRAM, STT-MRAM, eMRAM, 및 OST- MRAM은 정적 메모리이면서 비휘발성 특성을 가지고 있다. 따라서, 인공신경망 메모리 시스템의 전원이 차 단된 후 다시 부팅될 때 메모리에서 인공신경망모델을 다시 제공받지 않아도 될 수 있는 효과가 있 다. 단, 본 개시에 따른 예시들은 이에 제한되지 않는다. 상술한 구성에 따르면, 인공신경망 메모리 시스템은 인공신경망 데이터 지역성 패턴에 기초하여 인 공신경망모델의 추론 연산 시 메모리의 읽기 동작에 의한 소비전력을 대폭 저감할 수 있는 효과가 있다. 도 14는 본 개시의 다양한 예시들에 따른 인공신경망 메모리 시스템을 설명하는 개략도이다. 이하 도 14를 참조하여 본 개시에 따른 다양한 예시들에 대해서 설명한다. 도 14는 본 개시에 따른 다양한 예시 들이 실시될 수 있는 다양한 경우의 수를 설명할 수 있다. 본 개시의 다양한 예시들에 따르면, 인공신경망 메모리 시스템은 적어도 하나의 프로세서, 적어도 하나의 메모리, 및 적어도 하나의 프로세서를 포함하고, 적어도 하나의 프로세서에서 데이터 접근 요청을 수신 받아 적 어도 하나의 메모리에게 메모리 접근 요청을 제공하도록 구성된 적어도 하나의 인공신경망 메모리 제어부(ANN Memory Controller: AMC)를 포함하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부(AMC)는 예시 적인 인공신경망 메모리 제어부들(120, 220, 320)과 실질적으로 동일하게 구성될 수 있다. 단, 이에 제한되지 않으며, 인공신경망 메모리 시스템의 하나의 인공신경망 메모리 제어부는 다른 인공신경망 메모리 제어부 와 서로 상이하게 구성될 수 있다. 이하 인공신경망 메모리 제어부(411, 412, 413, 414, 415, 416, 417)와 상 술한 인공신경망 메모리 제어부들(120, 220, 320)의 중복 설명은 단지 설명의 편의를 위해서 생략할 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 적어도 하나의 프로세서와 적어도 하나의 메모리를 연결하도록 구성 된다. 이때, 적어도 하나의 프로세서와 적어도 하나의 메모리 사이의 데이터 이동 경로에는 대응되는 인공신경 망 데이터 지역성에 존재할 수 있다. 따라서, 해당 데이터 이동 경로에 위치한 인공신경망 메모리 제어부는 대 응되는 인공신경망 데이터 지역성 패턴을 추출하도록 구성될 수 있다. 각각의 인공신경망 메모리 제어부(AMC)는 각각의 데이터 접근 요청을 모니터링해서 각각 인공신경망 데이터 지 역성 패턴을 생성하도록 구성될 수 있다.인공신경망 메모리 시스템은 적어도 하나의 프로세서를 포함하도 록 구성될 수 있다. 적어도 하나의 프로세서는 인공신경망 연산을 단독으로 또는 다른 프로세서와 협력하여 처 리하도록 구성될 수 있다. 인공신경망 메모리 시스템은 적어도 하나의 내부 메모리를 포함하도록 구성될 수 있다. 인공신경망 메모리 시스템은 적어도 하나의 외부 메모리와 연결되도록 구성될 수 있다. 내부 메모리 또는 외부 메모리는 DRAM(Dynamic RAM), HBM(High bandwidth memory), SRAM(Static RAM), PROM(Programmable ROM), EPROM(Erasable PROM), EEPROM(Electrically EPROM), 플래시 메모리(Flash Memory), 강유전체 램 (ferroelectric RAM(FRAM)), 플래쉬 메모리(flash memory), 마그네틱 램(magnetic RAM(MRAM)), 하드 디스크, 및 상 변화 메모리 장치(phase change RAM) 등을 포함할 수 있다. 단, 본 개시는 이에 제한되지 않는다. 인공신경망 메모리 시스템은 외부 메모리(External MEM)와 연결되는 외부 메모리 인터페이스를 포함할 수 있다. 외부 메모리 인터페이스는 메모리 접근 요청을 인공신경망 메모리 시스템의 적어도 하나의 외부 메 모리로 전송하고, 적어도 하나의 외부 메모리로부터 메모리 접근 요청에 응답하는 데이터를 수신할 수 있다. 예 시적인 인공신경망 메모리 제어부들(120, 220, 320)에 개시된 구성과 기능은 복수의 인공신경망 메모리 제어부 (411, 412, 413, 414, 415, 416, 417)로 분산되어 인공신경망 메모리 시스템의 특정 위치에 배치될 수 있 다. 몇몇 예시에서는, 프로세서는 인공신경망 메모리 제어부를 포함하도록 구성될 수 있다. 몇몇 예시에서는, 메모리는 DRAM일 수 있으며, 이때 인공신경망 메모리 제어부는 DRAM 내부에 포함되도록 구성 될 수 있다. 예를 들면, 인공신경망 메모리 제어부들(411, 412, 413, 414, 415, 416, 417) 중 적어도 하나는 캐쉬 메모리를 내장하도록 구성될 수 있다. 또한, 캐쉬 메모리는 프로세서, 내부 메모리, 및/또는 외부 메모리에 포함되도록 구성될 수 있다. 예를 들면, 인공신경망 메모리 제어부들(411, 412, 413, 414, 415, 416, 417) 중 적어도 하나는 메모리와 프로 세서 사이의 데이터의 전송 경로에 분산되어 배치되도록 구성될 수 있다. 예를 들면, 인공신경망 메모리 시스템에 구현될 수 있는 인공신경망 메모리 제어부는 독립된 형태로 구성 된 인공신경망 메모리 제어부, 시스템버스에 포함된 인공신경망 메모리 제어부, 프로세서의 인터페이 스로 구성된 인공신경망 메모리 제어부, 내부 메모리의 메모리 인터페이스와 시스템버스 사이의 Wrapper Block 내에 포함된 인공신경망 메모리 제어부, 내부 메모리의 메모리 인터페이스에 포함된 인공신경망 메 모리 제어부, 내부 메모리 내에 포함된 인공신경망 메모리 제어부, 외부 메모리에 대응하는 메모리 인터페 이스에 포함된 인공신경망 메모리 제어부, 외부 메모리의 메모리 인터페이스와 시스템버스 사이의 Wrapper Block 내에 포함된 인공신경망 메모리 제어부, 및/또는 외부 메모리 내에 포함된 인공신경망 메모리 제어 부 중 하나로 구성될 수 있다. 단, 본 개시의 예시들에 따른 인공신경망 메모리 제어부는 이에 제한되지않는다. 예를 들면, 제1 인공신경망 메모리 제어부와 제2 인공신경망 메모리 제어부가 생성하는 각각의 인공 신경망 데이터 지역성 패턴들은 서로 같거나 또는 서로 상이할 수 있다. 부연 설명하면, 제1 인공신경망 메모리 제어부는 시스템 버스(system bus)를 통해서 제1 프로세서 (processor 1)와 제1 내부 메모리(internal MEM 1)를 연결하도록 구성될 수 있다. 이때 제1 프로세서 (processor 1)와 제1 내부 메모리(internal MEM 1) 사이의 데이터 이동 경로에는 대응되는 제1 인공신경망 데이 터 지역성이 존재할 수 있다. 이때, 해당 경로에는 제3 인공신경망 메모리 제어부가 도시되어 있으나, 이는 단지 예시를 위한 것이며, 제3 인공신경망 메모리 제어부가 삭제될 수 있다. 즉, 프로세서와 메모리 사이에 적어도 하나의 인공신경 망 메모리 제어부가 배치되면 프로세서가 처리하는 인공신경망모델의 인공신경망 데이터 지역성 패턴을 생성할 수 있다. 부연 설명하면, 제2 인공신경망 메모리 제어부는 제2 프로세서(processor 2)와 제1 외부 메모리(external MEM 1)를 연결하도록 구성될 수 있다. 이때 제2 프로세서(processor 2)와 제1 외부 메모리(external MEM 1) 사 이의 데이터 이동 경로에는 대응되는 제2 인공신경망 데이터 지역성이 존재할 수 있다. 예를 들면, 제1 프로세서(processor 1)가 처리하는 제1 인공신경망모델은 객체인식모델일 수 있으며, 제2 프로 세서(processor 2)가 처리하는 제2 인공신경망모델은 음성인식모델일 수 있다. 따라서 각각의 인공신경망모델을 서로 상이하고, 대응되는 인공신경망 데이터 지역성 패턴들도 서로 상이할 수 있다. 즉, 인공신경망 메모리 제어부들(411, 412, 413, 414, 415, 416, 417) 각각이 생성하는 인공신경망 데이터 지역 성 패턴은 대응되는 프로세서가 생성하는 데이터 접근 요청의 패턴 특징에 따라서 결정될 수 있다. 즉, 인공신경망 메모리 시스템의 인공신경망 메모리 제어부는 임의의 프로세서와 임의의 메모리 사이에 배 치되더라도, 해당 위치의 인공신경망 데이터 지역성 패턴을 생성할 수 있는 적응력을 제공할 수 있는 효과가 있 다. 부연 설명하면, 하나의 인공신경망모델을 두 개의 프로세서가 협력해서 병렬로 처리할 경우, 해당 인공신경망모 델의 인공신경망 데이터 지역성 패턴은 각각의 프로세서에게 분할되어 할당될 수 있다. 예를 들면, 제1 레이어 의 컨벌루션 연산은 제1 프로세서가 처리하고 제2 레이어의 컨벌루션 연산은 제2 프로세서가 처리하여 인공신경 망모델의 연산을 분산시킬 수 있다. 이러한 경우, 인공신경망모델이 동일하더라도, 각각의 프로세서가 처리하는 인공신경망모델의 인공신경망 데이터 지역성은 데이터 접근 요청 단위로 재구성될 수 있다. 이러한 경우, 각각 의 인공신경망 메모리 제어부는 각각의 인공신경망 메모리 제어부가 처리하는 프로세서의 데이터 접근 요청에 대응되는 인공신경망 데이터 지역성 패턴을 각각 생성하도록 구성될 수 있는 적응력을 제공할 수 있는 효과가 있다. 데이터 접근 요청 단위는 적어도 하나의 워드 단위로 구성될 수 있다. 인공신경망 데이터 지역성 (ANN DL) 단위 는 적어도 하나의 데이터 접근 요청 단위로 구성될 수 있다. 상술한 구성에 따르면, 복수의 프로세서와 복수의 메모리 사이에 복수의 인공신경망 메모리 제어부가 분산 배치 되더라도, 각각의 상황에 맞게 생성되는 인공신경망 데이터 지역성 패턴들에 의해서 인공신경망 메모리 시스템 의 성능이 최적화 될 수 있는 효과가 있다. 즉, 각각의 인공신경망 메모리 제어부는 각자 위치한 자리에서 인공신경망 데이터 지역성을 분석할 수 있기 때문에 가변적으로 실시간으로 처리되는 인공신경망 연산에 최적화 될 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부들(411, 412, 413, 414, 415, 416, 417) 중 적어도 하나는 메모리 개수, 메모리 종류, 메모리의 실효 대역폭, 메모리의 지연시간, 메모리 크기 중 적어도 하나의 정보를 확인하도 록 구성될 수 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부들(411, 412, 413, 414, 415, 416, 417) 중 적어도 하나는 메모리 접근 요청에 응답하는 메모리의 실효 대역폭을 측정하도록 구성될 수 있다. 여기서 메모리는 적어도 하나 이상 일 수 있으며, 각각의 인공신경망 메모리 제어부는 각각의 메모리와 통신하는 채널의 실효 대역폭을 측정할 수 있다. 실효 대역폭은 인공신경망 메모리 제어부가 메모리 접근 요청을 생성하고, 해당 메모리 접근 요청이 완료 되는 시간과 데이터 전송 비트 레이트(bit rate)를 측정하여 계산될 수 있다.몇몇 예시에서는, 인공신경망 메모리 제어부(411, 412, 413, 414, 415, 416, 417) 중 적어도 하나는 메모리 접 근 요청에 응답하는 적어도 하나의 메모리의 필요 대역폭을 정보를 제공받도록 구성될 수 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템은 복수의 메모리를 포함하고, 적어도 하나의 인공신경망 메모 리 제어부는 복수의 메모리의 실효 대역폭을 각각 측정하도록 구성될 수 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템은 복수의 메모리를 포함하고, 적어도 하나의 인공신경망 메모 리 제어부는, 복수의 메모리의 지연시간을 각각 측정하도록 구성될 수 있다. 즉, 적어도 하나의 인공신경망 메모리 제어부는 자신과 연결된 각각의 메모리들을 오토 캘리브레이션(auto- calibration) 하도록 구성될 수 있다. 오토 캘리브레이션은 인공신경망 메모리 시스템이 시작할 때 또는 특정 주기마다 실행되도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 오토 캘리브레이션을 통해서 자신과 연결된 메모리의 개수, 메모리의 종류, 메모리의 실효 대역폭, 메모리의 지연신간, 메모리의 크기 등의 정보를 수집하도록 구성될 수 있다. 상술한 구성에 따르면, 인공신경망 메모리 시스템은 인공신경망 메모리 제어부에 대응되는 메모리의 지연 시간 및 실효 대역폭을 알 수 있다. 상술한 구성에 따르면, 독립된 형태의 인공신경망 메모리 제어부를 시스템버스에 연결시키더라도, 프로세서가 처리중인 인공신경망모델의 인공신경망 데이터 지역성을 생성하여 메모리를 제어할 수 있는 효과가 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템의 적어도 하나의 인공신경망 메모리 제어부는, 인공신경망 데 이터 지역성 패턴의 1회 반복에 소요되는 시간 및 데이터 크기를 계산하여 인공신경망 연산이 요구하는 실효 대 역폭을 계산하도록 구성될 수 있다. 구체적으로 설명하면, 인공신경망 데이터 지역성 패턴에 포함된 데이터 접 근 요청을 모두 처리할 경우, 프로세서가 인공신경망모델의 추론을 완료했다고 결정할 수 있다. 인공신경망 메 모리 시스템은 인공신경망 데이터 지역성 패턴에 기초하여 1회 추론에 걸리는 시간을 측정하여 초당 추론 횟수(IPS; inference per second)를 계산하도록 구성될 수 있다. 또한, 인공신경망 메모리 시스템은 목포 초당 추론 횟수 정보를 프로세서로부터 제공 받을 수 있다. 예를 들면, 특정 어플리케이션은 특정 인공신경망모 델의 추론 속도를 30 IPS로 요구할 수 있다. 만약 측정된IPS가 목표 IPS보다 낮을 경우, 인공신경망 메모리 제 어부는 프로세서의 인공신경망모델 처리 속도를 향상시키기 위해서 동작하도록 구성될 수 있다. 몇몇 예시에서는, 인공신경망 메모리 시스템은 인공신경망 메모리 제어부, 프로세서, 및 메모리의 통신을 제어하도록 구성된 시스템버스를 포함하도록 구성될 수 있다. 또한, 적어도 하나의 인공신경망 메모리 제어부는 시스템버스의 마스터 권한을 가지도록 구성될 수 있다. 부연 설명하면, 인공신경망 메모리 시스템은 인공신경망 연산을 위한 전용 장치가 아닐 수 있다. 이러한 경우, 인공신경망 메모리 시스템의 시스템버스에는 와이파이, 디스플레이, 카메라, 마이크 등 다양한 주변 장치들이 연결될 수 있다. 이러한 경우, 인공신경망 메모리 시스템은 안정적인 인공신경망 연산을 위해서 시스템버스의 대역폭을 제어하도록 구성될 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는, 메모리 접근 요청의 처리 시간동안 인공신경망 연산을 우선 처리하도록 동작하고, 이외의 시간 동안 인공신경망 연산 이외의 연산을 처리하도록 구성될 수 있 다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는 적어도 하나의 메모리가 메모리 접근 요청을 완료 할 때까지, 시스템버스의 실효 대역폭을 확보하도록 구성될 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는 시스템버스 내부에 배치되고, 시스템버스는 시스 템버스 내에서 생성된 인공신경망 데이터 지역성 패턴에 기초하여 시스템버스의 대역폭을 동적으로 가변 하도록 구성될 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는 시스템버스 내에 배치되고, 적어도 하나의 인공신 경망 메모리 제어부는 적어도 하나의 메모리가 메모리 접근 요청에 대한 응답을 완료할 때까지, 시스템버스의 제어 권한을 메모리 접근 요청이 없을 때보다 상대적으로 더 높게 증가시키도록 구성될 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는, 복수의 프로세서 중 인공신경망 연산을 처리하는 프로세서의 데이터 접근 요청의 우선 순위를 인공신경망 연산 이외의 연산을 처리하는 프로세서보다 더 높게 설 정하도록 구성될 수 있다.몇몇 예시에서는, 인공신경망 메모리 제어부가 메모리를 직접 제어하도록 구성될 수 있다. 몇몇 예시에서는, 메모리에 인공신경망 메모리 제어부가 포함되고, 인공신경망 메모리 제어부는 적어도 하나의 접근 순서(access que)를 생성하도록 구성될 수 있다. 인공신경망 메모리 제어부는 인공신경망 연산 전용 접근 순서를 별도로 생성하도록 구성될 수 있다. 몇몇 예시에서는, 복수의 메모리 중 적어도 하나는 DRAM일 수 있다. 이러한 경우 적어도 하나의 인공신경망 메 모리 제어부는 메모리 접근 요청의 접근 순서를 재조정하도록 구성될 수 있다. 이러한 접근 순서 재조정은 액세 스 큐 리오더(access que re-order)일 수 있다. 몇몇 예시에서는, 인공신경망 메모리 제어부는 복수의 메모리 접근 요청의 접근 순서를 포함하도록 구성될 수 있다. 이러한 경우 제1 접근 순서는 인공신경망 연산 전용 접근 순서일 수 있으며, 제2 접근 순서는 인공신경망 연산 이외의 접근 순서일 수 있다. 인공신경망 메모리 제어부는 우선순위 설정에 따라서 각각의 접근 순서를 선 택하여 데이터를 제공하도록 구성될 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 특정 메모리 접근 요청을 처리하기 위해서 시스템버스에게 요구되는 특정 대역폭을 계산하도록 구성되고, 적어도 하 나의 인공신경망 메모리 제어부는 특정 대역폭에 기초하여 시스템버스의 실효 대역폭을 제어하도록 구성될 수 있다. 상술한 구성들에 따르면, 인공신경망 메모리 시스템은 다양한 주변 장치의 메모리 접근 요청들의 우선 순 위를 낮추거나 또는 인공신경망 데이터 지역성 패턴에 기초한 예측된 데이터 접근 요청의 우선순위를 향상시키 도록 구성될 수 있다. 상술한 구성들에 따르면, 인공신경망 메모리 제어부는 시스템버스의 데이터 접근 요청의 처리 순서를 재조정하 여 인공신경망 연산이 처리되는 동안에는 시스템버스의 대역폭을 최대한 활용하고, 인공신경망 연산이 없는 경 우에는 다른 주변 장치의 데이터를 처리를 위해서 대역폭을 양보할 수 있다. 상술한 구성들에 따르면, 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 데이터 접근 요청의 우선순위를 재조정할 수 있다. 또한 데이터 접근 요청에 포함된 식별 정보에 기초하여 우선순위를 재조 정할 수 있다. 즉, 인공신경망 연산 관점에서 시스템버스의 실효 대역폭이 동적으로 가변 되어 실효 대역폭이 향상 될 수 있다. 따라서 시스템버스의 동작 효율이 향상될 수 있는 효과가 있다. 따라서 인공신경망 메모리 제 어부 입장에서 시스템버스의 실효 대역폭이 향상될 수 있는 효과가 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는 데이터 접근 요청을 기계학습 하도록 구성될 수 있다. 즉, 적어도 하나의 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴을 기계학습 하도록 구성 된 인공신경망모델을 더 포함할 수 있다. 즉 인공신경망 데이터 지역성 패턴은 기계학습되기 때문에, 실제 인공 신경망 데이터 지역성에 따른 데이터 접근 요청 처리 중간에 다른 데이터 접근 요청이 인터럽트 하는 특이 패턴 들도 학습하여 예측하도록 구성될 수 있다. 인공신경망 메모리 제어부에 내장된 인공신경망모델은 예측된 데이터 접근 요청이 생성될 경우, 시스템버스의 제어 권한을 예측된 데이터 접근 요청들의 생성되지 않을 때보다 상대적으로 더 높게 증가시키도록 기계학습 될 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는, 계층화 된 복수의 캐쉬 메모리를 더 포함하고, 적어도 하나의 인공신경망 메모리 제어부는, 계층화 된 복수의 캐쉬 메모리의 계층간 데이터 접근 요청을 기계 학습을 하도록 구성될 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는, 계층화 된 복수의 캐쉬 메모리 각각의 계층의 실 효 대역폭, 소비 전력, 및 지연시간 정보 중 적어도 하나를 더 제공 받도록 구성될 수 있다. 상술한 구성에 의하면, 인공신경망 메모리 제어부는 기계학습을 통해서 인공신경망 데이터 지역성 패턴을 생성 하도록 구성될 수 있으며, 기계학습 된 인공신경망 데이터 지역성 패턴은 인공신경망 연산과 무관한 다양한 데 이터 접근 요청 들이 특정 패턴을 가지고 생성될 때, 이러한 특정 패턴들의 발생 예측 확률을 향상시킬 수 있는 효과가 있다. 또한 강화 학습에 의해서 프로세서가 처리하는 다양한 인공신경망모델 및 다른 연산들의 특성을 예측하여 인공신경망 연산의 효율을 향상시킬 수 있다. 몇몇 예시에서는, 적어도 하나의 인공신경망 메모리 제어부는, 복수의 메모리 각각의 실효 대역폭 및 지연시간 에 기초하여 상기 복수의 메모리에 저장되는 데이터를 분할하여 저장하도록 구성될 수 있다. 예를 들면, 데이터는 L 비트의 비트 그룹으로 구성되고, 복수의 메모리는 제1 메모리 및 제2 메모리를 더 포함 하고, 제1 메모리는 제1 실효 대역폭 또는 제1 지연시간에 기초하여 상기 L 비트의 비트 그룹 중 M 비트의 데이 터를 분할하여 저장하도록 구성되고, 제2 메모리는 제2 실효 대역폭 또는 제2 지연시간에 기초하여 L 비트의 비 트 그룹 중 N 비트의 데이터를 분할하여 저장하도록 구성되고, M 비트와 N 비트의 합은 L 비트와 같거나 또는 작도록 구성될 수 있다. 또한, 복수의 메모리는 제3 메모리를 더 포함하고, 제3 메모리는 제3 실효 대역폭 또는 제3 지연시간에 기초하여 L 비트의 비트 그룹 중 O 비트의 데이터를 저장하도록 구성되고, M 비트, N 비트 및 O 비트의 합은 L 비트와 같도록 구성될 수 있다. 예를 들면, 데이터는 P개의 데이터 묶음으로 구성되고, 복수의 메모리는 제1 메모리 및 제2 메모리를 포함하고, 제1 메모리는 제1 실효 대역폭 또는 제1 지연시간에 기초하여 P개의 데이터 묶음 중 R개의 데이터 묶음을 저장 하도록 구성되고, 제2 메모리는 제2 실효 대역폭 또는 제2 지연시간에 기초하여 P개의 데이터 묶음 중 S개의 데 이터 묶음을 저장하도록 구성되고, R개와 S개의 합은 상기 P개와 같거나 또는 작도록 구성될 수 있다. 또한 복 수의 메모리는 제3 메모리를 더 포함하고, 제3 메모리는 제3 실효 대역폭 또는 제3 지연시간에 기초하여 P개의 데이터 묶음 중 T개의 데이터 묶음을 저장하도록 구성되고, R개, S개 및 T개의 합은 P개와 같도록 구성될 수 있 다. 상술한 구성에 따르면, 인공신경망 메모리 제어부는 하나의 메모리의 대역폭이 낮을 때, 복수의 메모리에 데이 터를 분산시켜 저장하거나 읽을 수 있기 때문에, 메모리의 실효 대역폭을 향상시킬 수 있는 효과가 있다. 예를 들면, 인공신경망 메모리 제어부는 8비트의 양자화된 가중치 값을 제1 메모리에 4비트 제2 메모리에 4비트씩 분 할하여 저장하거나 읽도록 구성될 수 있다. 따라서 인공신경망 메모리 제어부 입장에서 메모리의 실효 대역폭이 향상될 수 있는 효과가 있다. 인공신경망 메모리 제어부는 복수의 메모리에 분할되어 저장된 데이터를 병합하여 저장하도록 구성된 캐쉬 메모 리를 더 포함하도록 구성될 수 있다. 즉, 적어도 하나의 인공신경망 메모리 제어부는 캐쉬 메모리를 더 포함하 고, 적어도 하나의 인공신경망 메모리 제어부는, 복수의 메모리에 분배되어 저장된 데이터를 병합하여 캐쉬 메 모리에 저장하도록 구성될 수 있다. 따라서 프로세서는 병합된 데이터를 제공받을 수 있다. 분할된 데이터를 병합하기 위해서 적어도 하나의 인공신경망 메모리 제어부는 복수의 메모리에 분할되어 저장된 데이터의 분할 정보를 저장하도록 구성될 수 있다.본 계시의 다양한 예시들은 아래와 같이 설명될 수 있다. 본 개시의 예시들에 따르면, 인공신경망 메모리 시스템은 인공신경망 연산에 대응되는 데이터 접근 요청을 생성 하도록 구성된 적어도 하나의 프로세서 및 데이터 접근 요청을 순차적으로 기록하여 상기 인공신경망 연산의 인 공신경망 데이터 지역성 패턴을 생성하도록 구성되고, 인공신경망 데이터 지역성 패턴에 기초하여 적어도 하나 의 프로세서가 생성한 데이터 접근 요청의 실제 데이터 접근 요청을 예측한 예측된 데이터 접근 요청을 생성하 도록 구성된 적어도 하나의 인공신경망 메모리 제어부를 포함하도록 구성될 수 있다. 여기서 인공신경망 데이터 지역성은 프로세서-메모리 레벨에서 재구성된 인공신경망 데이터 지역성일 수 있다. 본 개시의 예시들에 따르면, 인공신경망 메모리 시스템은 인공신경망모델을 처리하도록 구성된 적어도 하나의 프로세서 및 인공신경망모델의 인공신경망 데이터 지역성 정보를 저장하도록 구성되고 인공신경망 데이터 지역 성 정보에 기초하여 적어도 하나의 프로세서가 요청할 데이터를 예측하여 예측된 데이터 접근 요청을 생성하도 록 구성된 적어도 하나의 인공신경망 메모리 제어부를 포함하도록 구성될 수 있다. 인공신경망 메모리 시스템은 적어도 하나의 메모리 및 인공신경망 메모리 제어부, 적어도 하나의 프로세서, 및 적어도 하나의 메모리의 통신을 제어하도록 구성된 시스템 버스를 더 포함하도록 구성될 수 있다.본 개시의 예 시들에 따르면, 인공신경망 메모리 시스템은 프로세서, 메모리 및 캐쉬 메모리를 포함하고, 인공신경망 데이터 지역성 정보에 기초하여 프로세서가 요청할 데이터를 포함하는 예측된 데이터 접근 요청을 생성하도록 구성되고, 그리고 메모리로부터 예측된 데이터 접근 요청에 대응되는 데이터를 상기 프로세서가 요청하기 전에 상기 캐쉬 메모리에 저장하도록 구성될 수 있다. 본 개시의 예시들에 따르면, 인공신경망 메모리 시스템은 인공신경망 데이터 지역성 정보를 제공 받아 동작하도 록 구성된 제1 모드 또는 프로세서가 생성하는 데이터 접근 요청들을 관찰하여 인공신경망 데이터 지역성 정보 를 예측하여 동작하도록 구성된 제2 모드 중 하나의 모드로 동작하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 예측된 데이터 접근 요 청을 순차적으로 더 생성하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 실제 데이터 접근 요청 생성 전에 예측된 데이터 접근 요청을 생성 하도록 구성될 수 있다. 적어도 하나의 프로세서는 적어도 하나의 인공신경망 메모리 제어부에 데이터 접근 요청을 전송하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 데이터 접근 요청에 대응하여 예측된 데이터 접근 요청을 출력하도 록 구성될 수 있다. 데이터 접근 요청은 메모리 주소를 더 포함하도록 구성될 수 있다. 데이터 접근 요청은 메모리의 시작 주소 및 끝 주소를 더 포함하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 적어도 하나의 프로세서가 생성한 데이터 접근 요청 및 인공신경망 메모리 제어부가 생성한 예측된 데이터 접근 요청 중 하나에 기초하여 메모리 접근 요청을 생성하도록 구성될 수 있다. 데이터 접근 요청은 메모리의 시작 주소와 연속되는 데이터 연속 읽기 트리거(trigger)를 더 포함하도록 구성될 수 있다. 데이터 접근 요청은 메모리의 시작 주소와 연속되는 데이터의 개수 정보를 더 포함하도록 구성될 수 있다. 데이터 접근 요청 및 사전 데이터 접근은 매칭되는 동일한 메모리 주소의 데이터 접근 요청 토큰을 더 포함하도 록 구성될 수 있다. 데이터 접근 요청은 메모리 읽기 또는 쓰기 명령 여부를 식별할 수 있는 식별 정보를 더 포함하도록 구성될 수 있다. 데이터 접근 요청은 덮어쓰기 명령 여부를 식별할 수 있는 식별 정보를 더 포함하도록 구성될 수 있다. 데이터 접근 요청은 추론 데이터, 가중치 데이터 및 특징맵 데이터 여부를 식별할 수 있는 식별 정보를 더 포함 하도록 구성 될 수 있다. 데이터 접근 요청은 학습 데이터 및 평가 데이터 여부를 식별할 수 있는 식별 정보를 더 포함하도록 구성될 수 있다. 데이터 접근 요청은 인공신경망 연산이 학습을 위한 연산인지 또는 추론을 위한 연산인지 여부를 식별할 수 있 는 식별 정보를 더 포함하도록 구성될 수 있다. 적어도 하나의 프로세서가 실제 데이터 접근 요청을 생성할 경우, 적어도 하나의 인공신경망 메모리 제어부는, 예측된 데이터 접근 요청과 실제 데이터 접근 요청이 서로 동일한 요청인지를 결정하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 예측된 데이터 접근 요청과 실제 데이터 접근 요청이 동일할 경우, 상기 인공신경망 데이터 지역성 패턴을 유지하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 예측된 데이터 접근 요청과 실제 데이터 접근 요청이 상이할 경우 인공신경망 데이터 지역성 패턴을 갱신하도록 구성될 수 있다. 인공신경망 데이터 지역성 패턴은 데이터 접근 요청들의 메모리의 주소들을 순차적으로 기록한 데이터를 더 포 함하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 데이터 접근 요청에 포함된 메모리 주소의 반복 패턴을 감지하여 인 공신경망 데이터 지역성 패턴을 생성하도록 구성될 수 있다. 인공신경망 데이터 지역성 패턴은 반복되는 루프 특성을 가지는 메모리 주소들로 구성될 수 있다. 인공신경망 데이터 지역성 패턴은 인공신경망모델의 연산의 시작과 끝을 식별할 수 있는 식별 정보를 더 포함하 도록 구성될 수 있다. 적어도 하나의 프로세서는 데이터 접근 요청에 대응되는 데이터를 인공신경망 메모리 제어부로부터 제공받도록 구성될 수 있다.적어도 하나의 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴을 기계학습을 하도록 구성된 인공신 경망모델을 더 포함하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴의 갱신 된 패턴과 이전의 패턴을 저 장하여, 인공신경망모델의 변화 여부를 결정하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 데이터 접근 요청들이 하나의 인공신경망모델의 요청들인지 또는 복 수의 인공신경망모델들의 요청들이 혼합된 것인지 여부를 결정하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 인공신경망모델의 개수가 복수일 경우, 인공신경망모델의 개수에 대 응되는 인공신경망 데이터 지역성 패턴들을 더 생성하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴들에 기초하여, 대응되는 예측된 데 이터 접근 요청들을 각각 생성하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 데이터 접근 요청에 대응되는 메모리 접근 요청을 더 생성하도록 구 성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 예측된 데이터 접근 요청에 대응되는 메모리 접근 요청을 더 생성하 도록 구성될 수 있다. 데이터 접근 요청, 예측된 데이터 접근 요청 및 메모리 접근 요청 각각은 대응되는 메모리 주소 값 및 동작 모 드를 각각 포함하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는, 데이터 접근 요청 및 예측된 데이터 접근 요청에 포함된 정보 중 적어도 일부를 포함하도록 구성된 메모리 접근 요청을 더 생성하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부와 통신하도록 구성된 적어도 하나의 메모리를 더 포함하고, 적어도 하 나의 메모리는 적어도 하나의 인공신경망 메모리 제어부에서 출력되는 메모리 접근 요청에 대응하여 동작하도록 구성될 수 있다. 적어도 하나의 메모리는 추론 데이터, 가중치 데이터 및 특징맵 데이터 중 적어도 하나를 저장하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는, 메모리 접근 요청에 응답하여 적어도 하나의 메모리가 전송한 데이 터를 저장하도록 구성된 캐쉬 메모리를 더 포함하도록 구성될 수 있다. 적어도 하나의 프로세서가 실제 데이터 접근 요청을 출력할 경우, 적어도 하나의 인공신경망 메모리 제어부는 예측된 데이터 접근 요청과 실제 데이터 접근 요청이 서로 동일한 요청인지를 결정하고, 동일할 경우 적어도 하 나의 인공신경망 메모리 제어부는 적어도 하나의 프로세서에 캐쉬 메모리에 저장된 데이터를 제공하도록 구성되 고, 동일하지 않은 경우, 적어도 하나의 인공신경망 메모리 제어부는 실제 데이터 접근 요청에 기초하여 신규 메모리 접근 요청을 생성하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 캐쉬 메모리의 잔여 용량에 기초 하여 메모리 접근 요청을 적어도 하나 이상 순차적으로 생성하여 캐쉬 메모리의 상기 잔여 용량이 최소화되도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는, 메모리 접근 요청에 응답하는 적어도 하나의 메모리의 실효 대역폭 을 측정하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 메모리 접근 요청에 응답하는 적어도 하나의 메모리의 필요 대역폭 을 정보를 제공받도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴의 특정 시간 동안의 반복 횟수를 계 산하여 상기 인공신경망 연산의 1초당 추론 횟수(IPS)를 측정하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴의 1회 반복에 소요되는 시간 및 데 이터 크기를 계산하여 인공신경망 연산이 요구하는 실효 대역폭을 계산하도록 구성될 수 있다. 적어도 하나의 메모리는, 메모리의 셀의 전압을 갱신할 수 있는 리프레쉬 기능을 포함하는 디램(DRAM)을 더 포 함하고, 적어도 하나의 인공신경망 메모리 제어부는 예측된 데이터 접근 요청에 대응되는 메모리 접근 요청에 대응되는 적어도 하나의 메모리의 메모리 주소 영역의 리프레쉬를 선택적으로 제어하도록 구성될 수 있다.적어도 하나의 메모리는 메모리의 글로벌 비트라인을 특정 전압으로 충전시킬 수 있는 프리차지 기능을 더 포함 하고, 적어도 하나의 인공신경망 메모리 제어부는 예측된 데이터 접근 요청에 대응되는 메모리 접근 요청에 대 응되는 적어도 하나의 메모리의 메모리 주소 영역에 프리차지를 선택적으로 제공하도록 구성될 수 있다. 적어도 하나의 메모리는 복수의 메모리를 더 포함하고 적어도 하나의 인공신경망 메모리 제어부는 복수의 메모 리의 실효 대역폭을 각각 측정하도록 구성될 수 있다. 적어도 하나의 메모리는 복수의 메모리를 더 포함하고 적어도 하나의 인공신경망 메모리 제어부는 복수의 메모 리의 레이턴시를 각각 측정하도록 구성될 수 있다. 적어도 하나의 메모리는 복수의 메모리를 더 포함하고, 적어도 하나의 인공신경망 메모리 제어부는 복수의 메모 리 각각의 실효 대역폭 및 지연시간에 기초하여 복수의 메모리에 저장되는 데이터를 분할하여 저장하도록 구성 될 수 있다. 데이터는 L 비트의 비트 그룹으로 구성되고, 복수의 메모리는 제1 메모리 및 제2 메모리를 더 포함하고, 제1 메 모리는 제1 실효 대역폭 또는 제1 지연시간에 기초하여 L 비트의 비트 그룹 중 M 비트의 데이터를 분할하여 저 장하도록 구성되고, 제2 메모리는 제2 실효 대역폭 또는 제2 지연시간에 기초하여 L 비트의 비트 그룹 중 N 비 트의 데이터를 분할하여 저장하도록 구성되고, M 비트와 N 비트의 합은 L 비트와 같거나 또는 작도록 구성될 수 있다 복수의 메모리는 제3 메모리를 더 포함하고, 제3 메모리는 제3 실효 대역폭 또는 제3 지연시간에 기초하여 L 비 트의 비트 그룹 중 O 비트의 데이터를 저장하도록 구성되고, M 비트, N 비트 및 O 비트의 합은 L 비트와 같도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는, 복수의 메모리에 분할되어 저장된 데이터를 병합하여 저장하도록 구성된 캐쉬 메모리를 더 포함하도록 구성될 수 있다. 데이터는 P개의 데이터 묶음으로 구성되고, 복수의 메모리는 제1 메모리 및 제2 메모리를 더 포함하고, 제1 메 모리는 제1 실효 대역폭 또는 제1 지연시간에 기초하여 P개의 데이터 묶음 중 R개의 데이터 묶음을 저장하도록 구성되고, 제2 메모리는 제2 실효 대역폭 또는 제2 지연시간에 기초하여 상기 P개의 데이터 묶음 중 S개의 데이 터 묶음을 저장하도록 구성되고, R개와 상기 S개의 합은 상기 P개와 같거나 또는 작도록 구성될 수 있다. 복수의 메모리는 제3 메모리를 더 포함하고, 제3 메모리는 제3 실효 대역폭 또는 제3 지연시간에 기초하여 P개 의 데이터 묶음 중 T개의 데이터 묶음을 저장하도록 구성되고, R개, 상기 S개 및 상기 T개의 합은 상기 P개와 같도록 구성될 수 있다. 적어도 하나의 메모리는 복수의 메모리를 더 포함하고, 적어도 하나의 인공신경망 메모리 제어부는, 캐쉬 메모 리를 더 포함하고, 적어도 하나의 인공신경망 메모리 제어부는 복수의 메모리에 분배되어 저장된 데이터를 병합 하여 캐쉬 메모리에 저장하도록 구성될 수 있다. 적어도 하나의 메모리는 복수의 메모리를 더 포함하고, 적어도 하나의 인공신경망 메모리 제어부는 복수의 메모 리에 분할되어 저장된 데이터의 분할 정보를 저장하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 예측된 데이터 접근 요청 및 적어도 하나의 메모리의 레이턴시 값에 기초하여 캐쉬 메모리에 레이턴시 만큼 데이터의 일부를 저장하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 예측된 데이터 접근 요청 및 적어도 하나의 메모리의 데이터 대역폭 요구량에 기초하여 캐쉬 메모리에 상기 데이터의 일부를 저장하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 적어도 하나의 프로세서에서 실제 데이터 접근 요청 생성 시, 캐쉬 메모리에 저장된 데이터를 먼저 제공하면서, 데이터의 나머지를 적어도 하나의 메모리로부터 읽기-버스트 모드 로 제어하여, 적어도 하나의 메모리의 레이턴시를 저감하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 예측된 데이터 접근 요청 및 적어도 하나의 메모리의 레이턴시 값에 기초하여 적어도 하나의 프로세서에서 실제 데이터 접근 요청 생성 시, 레이턴시 값만큼 사전에 적어도 하나의 메모리의 읽기-버스트 모드로 시작하여, 적어도 하나의 메모리의 레이턴시를 저감하도록 구성될 수 있다. 인공신경망 메모리 제어부, 상기 적어도 하나의 프로세서, 및 상기 적어도 하나의 메모리의 통신을 제어하도록 구성된 시스템 버스를 더 포함하도록 구성될 수 있다.적어도 하나의 인공신경망 메모리 제어부는 시스템 버스의 마스터 권한을 가지도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 인공신경망모델을 더 포함하고, 인공신경망모델은 예측된 데이터 접 근 요청이 생성될 경우, 시스템 버스의 제어 권한을 예측된 데이터 접근 요청들의 생성되지 않을 때보다 상대적 으로 더 높게 증가시키도록 기계 학습될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 적어도 하나의 메모리가 상기 메모리 접근 요청을 완료할 때까지, 시스템 버스의 실효 대역폭을 확보하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 인공신경망 데이터 지역성 패턴에 기초하여 특정 메모리 접근 요청 을 처리하기 위해서 시스템 버스에게 요구되는 특정 대역폭을 계산하고, 적어도 하나의 인공신경망 메모리 제어 부는 특정 대역폭에 기초하여 시스템 버스의 실효 대역폭을 제어하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 시스템 버스 내부에 배치되고, 시스템 버스는 시스템 버스 내에서 생성된 인공신경망 데이터 지역성 패턴에 기초하여 시스템 버스의 대역폭을 동적으로 가변 하도록 구성될 수 있 다. 적어도 하나의 인공신경망 메모리 제어부는 메모리 접근 요청의 처리 시간동안 인공신경망 연산을 우선 처리하 도록 동작하고, 이외의 시간 동안 인공신경망 연산 이외의 연산을 처리하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부와 적어도 하나의 프로세서는 직접 통신하도록 구성될 수 있다. 인공신경망 메모리 제어부는 인공신경망 연산 전용 접근 순서인 제1 접근 순서 및 인공신경망 연산 이외의 접근 순서인 제2 접근 순서를 더 포함하고, 인공신경망 메모리 제어부는 우선순위 설정에 따라서 각각의 접근 순서를 선택하여 데이터를 제공하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 계층화 된 복수의 캐쉬 메모리를 더 포함하고 적어도 하나의 인공신 경망 메모리 제어부는 계층화 된 복수의 캐쉬 메모리의 계층간 데이터 접근 요청을 기계학습을 하도록 구성된 인공신경망모델을 더 포함하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 계층화 된 복수의 캐쉬 메모리 각각의 계층의 실효 대역폭, 소비 전 력, 및 레이턴시 정보 중 적어도 하나를 더 제공 받도록 구성될 수 있다. 인공신경망 연산에 대응되는 데이터 접근 요청을 생성하도록 구성된 적어도 하나의 프로세서 및 컴파일러로부터 생성된 인공신경망 연산의 인공신경망 데이터 지역성 패턴을 저장하도록 구성되고, 인공신경망 데이터 지역성 패턴에 기초하여 적어도 하나의 프로세서가 생성한 데이터 접근 요청의 실제 데이터 접근 요청을 예측한 예측된 데이터 접근 요청을 생성하도록 구성된 적어도 하나의 인공신경망 메모리 제어부 및 적어도 하나의 인공신경망 메모리 제어부와 통신하도록 구성된 적어도 하나의 메모리를 포함하고, 적어도 하나의 메모리는 적어도 하나의 인공신경망 메모리 제어부에서 출력되는 메모리 접근 요청에 대응하여 동작하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 시스템은 적어도 하나의 메모리 및 인공신경망 메모리 제어부, 적어도 하나의 프로세서, 및 적어도 하나의 메모리의 통신을 제어하도록 구성된 시스템 버스를 더 포함하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 시스템 버스 내에 배치되고, 적어도 하나의 인공신경망 메모리 제어 부는 적어도 하나의 메모리가 메모리 접근 요청에 대한 응답을 완료할 때까지, 상기 시스템 버스의 제어 권한을 상기 메모리 접근 요청이 없을 때보다 상대적으로 더 높게 증가시키도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부의 적어도 일부는 DRAM에 포함되도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부의 적어도 일부는 적어도 하나의 프로세서에 포함되도록 구성될 수 있 다. DRAM을 더 포함하거나 또는 적어도 하나의 메모리는 DRAM이고, 적어도 하나의 인공신경망 메모리 제어부는 메모 리 접근 요청의 접근 순서(access que)를 재조정하도록 구성될 수 있다. 즉, DRAM의 메모리 컨트롤러의 리-오더 큐(Reorder cue)를 제어하도록 구성될 수 있다. 인공신경망 메모리 제어부가 메모리의 메모리 컨트롤러에게 제공하는 인공신경망 연산 관련 메모리 접근 요청에 메모리의 메모리 컨트롤러가 해석할 수 있는 우선순위 정보를 더 포함하도록 구성될 수 있다. 상술한 구성에 따르면, 메모리의 메모리 컨트롤러는 해당 메모리 접근 요청이 인공신경망 연산과 관련된 것인지 여부와 상관없이 인공신경망 메모리 제어부가 생성한 메모리 접근 요청이 포함하는 우선순위 정보에 기초하여 메모리 컨트롤러 내부의 메모리 접근 순서를 재조정(re-order)하도록 구성될 수 있다. 따라서 인공신경망 연산 처리를 위한 메모리 접근 요청의 접근 순서가 다른 종류의 메모리 접근 요청의 접근 순서에 비해 먼저 처리될 수 있다. 따라서 인공신경망 메모리 제어부는 대응되는 메모리의 실효 대역폭을 상승시킬 수 있는 효과가 있다. DRAM의 메모리 컨트롤러가 결정한 메모리 접근 요청 처리 순서를 인공신경망 메모리 제어부가 제공하는 우선순 위 정보에 의해서 재조정하도록 구성될 수 있다. 예를 들면, 인공신경망 메모리 제어부가 생성한 메모리 접근 요청의 우선순위를 긴급으로 설정하면, DRAM의 메 모리 컨트롤러는 해당 메모리 접근 요청의 처리 순서를 제1 순위로 변경할 수도 있다. 인공신경망 메모리 제어부는 적어도 하나의 접근 순서를 생성하도록 구성될 수 있다. 적어도 하나의 메모리에 인공신경망 메모리 제어부가 포함되고, 인공신경망 메모리 제어부는 인공신경망 연산 전용 접근 순서를 별도로 생성하도록 구성될 수 있다. 적어도 하나의 인공신경망 메모리 제어부는 메모리 접근 요청의 접근 순서를 재조정하도록 구성될 수 있다. 적어도 하나의 메모리는 읽기-버스트 기능을 더 포함하고, 적어도 하나의 인공신경망 메모리 제어부는 적어도 하나의 메모리의 저장 영역을 읽기-버스트 기능을 고려하여 설정하도록 구성될 수 있다. 적어도 하나의 메모리는 읽기-버스트 기능을 더 포함하고, 적어도 하나의 인공신경망 메모리 제어부는 적어도 하나의 메모리의 저장 영역을 읽기-버스트 기능을 고려하여 쓰기 동작을 처리 하도록 구성될 수 있다. 적어도 하나의 프로세서는 복수의 프로세서를 더 포함하고, 적어도 하나의 인공신경망 메모리 제어부는 복수의 프로세서 중 인공신경망 연산을 처리하는 프로세서의 데이터 접근 요청의 우선 순위를 인공신경망 연산 이외의 연산을 처리하는 프로세서보다 더 높게 설정하도록 구성될 수 있다. 적어도 하나의 AMC 각각은 내부에 저장된 각각의 ANN DL을 기초로 독립적으로 동작하도록 구성될 수 있다. 각각 의 ANN DL은 서로 동일하거나 또는 서로 상이할 수 있다. 각각의 ANN DL은 각각의 AMC의 배치된 위치에 따라서 서로 다른 ANN DL을 가지도록 구성될 수 있다. 부연 설명하면, ANN DL은 AMC가 위치한 통신 버스에서의 처리되 는 ANN 모델의 ANN DL을 분석하고, 예측된 데이터를 미리 준비하도록 구성되었다. 따라서, 제1 배치 위치에서 제1 AMC가 인식하는 제1 ANN DL은 제2 배치 위치에서 제2 AMC가 인식하는 제2 ANN DL과 서로 상이할 수 있다. 하지만 각각의 AMC는 각각의 ANN DL을 기초로 해당 위치에서 독립적으로 동작할 수 있는 장점이 있다. 예를 들면, 본 개시에 따른 프로세서는 본 개시의 예시적인 NPU들 중 하나로 구성될 수 있다. 예를 들면, 본 개 시에 따른 SoC는 인공신경망 메모리 시스템을 포함할 수 있다. 이하 NPU 및 SoC에 대하여 후술한다. 도 15a는 본 개시의 다양한 예시들에 따른 인공신경망 메모리 시스템을 설명하는 개략도이다. 도 15a를 참조하면, 신경 프로세싱 유닛(NPU)과 하나 이상의 내부 메모리가 시스템온칩(System on Chip: SoC)의 일부에 포함될 수 있다. SoC는 메인 프로세서 및 다양한 통상의 모듈을 필요에 따라 더 포함할 수 있다. 통상의 모듈은 블루투스, USB, PCI 인터페이스, AXI 인터페이스, 비디오 인터페이스, UART 인터페이스, 오디오 인터페이스, DDR 메모리 등일 수 있다. 인터페이스 버스는 SoC 구성 요소 간 데이터를 주고받는 통로로 그 데이터의 특성 및 속도, 필요로 하는 기능에 의해 결정될 수 있다. AXI(Advanced eXtensible Interface) 버스는 높은 성능(high performance), 높은 클럭 주파수 시스템 설계를 목적으로 하여 NPU, DRAM 그리고 USB, PCIe 등의 고속인터페이스 IP 간 데이터 전송에 적 합할 수 있다. NPU는 및/또는 AMC는 SoC에 포함될 수 있다. 예를 들면, SoC는 CPU, BUS 아키텍처, 메모리, CRM(Clock Reset Manager), DMA(Direct Memory Access) 등을 포함할 수 있다. 또한, SoC는 범용 입력출력을 위한 GPIO, 고속데 이터 송수신에 필요한 USB와 PCIe같은 고속 인터페이스, UART, SPI와 같은 시리얼 인터페이스, 영상신호 및 오 디오 신호를 주고받는 비디오 인터페이스 및 오디오 인터페이스 등을 더 포함 할 수 있다. CPU는 타켓 애플리케이션의 용도, 소비 전력·동작 속도와 같은 회로의 특성, 필요로 하는 CPU의 시스템 기능, 그리고 지원하는 연산 기능 혹은 명령어 세트 (instruction set) 등에 의해 선정될 수 있다. SoC의 목적 및 특성에 따라 운영체제(Operating System) 지원의 유무, DSP 연산 및 부동 소수점(Floating Point) 연산기능 가능 여부도, CPU 선정의 요인이 될 수 있다. 또한, 이미 NPU에 구현된 신경망 알고리즘이 아 닌 새로운 신경망 알고리즘의 추가적인 구현을 위해서는 DSP 연산 기능이 필요할 수 있다. SoC가 객체 인식 분야에 응용되기 위해서는 입력 영상의 전처리 및 후처리 등의 작업이 필요하며 CPU는 이런 작 업을 할 수 있는 영상처리용 프레임워크(framework)가 동작할 수 있는 OS를 지원할 수 있다. 상기 내부 메모리와 상기 메인 메모리 사이에는 인공신경망 메모리 제어부(AMC)가 배치될 수 있다. 상기 내부 메모리는 정적 메모리일 수 있다. 예를 들면 상기 내부 메모리는 SRAM일 수 있다. 상기 NPU와 상기 내부 메모리는 SRAM 인터페이스를 통해 연결될 수 있다. SRAM은 DRAM 대비 메모리 셀이 상대적으로 크기 때문에, 대용량 SRAM을 설계하기 어렵다. 따라서, 내부 SRAM 크 기를 최적화하고, 나머지는 DRAM을 사용할 수 있다. 이때, AMC는 ANN 데이터 지역성 정보를 기초로 NPU와 메인 메모리의 대역폭을 최적화 할 수 있다. 상기 내부 메모리는 SoC의 실리콘 기판상에 형성된 메모리를 의미할 수 있다. 상기 내부 메모리는 적어도 하나일 수 있다. 예를 들면, 상기 내부 메모리는 가중치를 저장하는 제1 내부 메모 리, 입력 특징맵을 저장하는 제2 내부 메모리 그리고 출력 특징맵을 저장하는 제3 내부 메모리를 포함할 수 있 다. 상기 제2 내부 메모리와 상기 제3 내부 메모리는 내부 특징맵 메모리로 지칭될 수 있다. 상기 3개의 내부 메모리들은 물리적인 하나의 메모리 내에서 할당된 복수의 논리적 영역들일 수 있다. 상기 NPU는 프로세싱 엘리먼트들(PE)을 포함하는 PE 어레이와 SFU(special function unit)를 포함할 수 있다. SFU는 PE 어레이에서 수행된 합성곱 결과에 활성화 함수를 선택적으로 적용하는 기능을 수행할 수 있다. 상술한 구성에 따르면, PE 어레이는 합성곱 연산을 처리하고, SFU는 활성화 함수 연산을 처리할 수 있다. 상기 NPU는 상기 제1 내부 메모리로부터 가중치를 읽어오고, 상기 제2 내부 메모리로부터 상기 입력 특징맵을 읽어온 후, 상기 입력 특징맵과 상기 가중치에 대해 합성곱 연산을 상기 PE 어레이에서 수행한 후, 상기 SFU에 서 활성화 함수를 선택적으로 적용한 출력 특징맵을 출력한다. 그리고 상기 NPU의 SFU는 상기 출력 특징맵을 상 기 제3 내부 메모리에 저장할 수 있다. 그리고 SoC 내부 및/또는 외부에는 하나 이상의 메인 메모리가 존재할 수 있다. 상기 메인 메모리는 상술한 다 양한 예시들의 메모리일 수 있으며, 예를 들면 DRAM일 수 있다. 이러한 경우 상기 하나 이상의 메인 메모리와 내부 메모리는 DRAM 인터페이스를 통해 연결될 수 있다. 예를 들면 DRAM 인터페이스는 AXI 인터페이스 일 수 있 다. DRAM은 스탠다드 DDR, 모바일 DDR, 그래픽 DDR일 수 있다. 또한 광대역폭 메모리(HBM)를 메인 메모리로 구현하 는 것도 가능하다. PC 또는 서버 급의 기기에서는 스탠다드 DRAM으로 구성된 DRAM 모듈(DIMM) 사용하고 있다. 엣지 디바이스에는 모바일 DDR (LPDDR)을 사용할 수 있다. Mobile DDR은 LPDDR4 또는 LPDDR5일 수 있다. 상기 메인 메모리는 가중치를 저장하기 위한 제1 메인 메모리와 특징맵을 저장하기 위한 제2 메인 메모리를 포 함할 수 있다. 상기 2개의 메인 메모리들은 물리적인 하나의 메모리 내에서 할당된 복수의 영역들일 수 있다. 상기 SoC는 읽기 명령을 통하여 상기 제1 메인 메모리 내의 상기 가중치와 상기 제2 메인 메모리 내의 특징맵을 읽어낸 후 상기 제1 내부 메모리 및 상기 제2 내부 메모리에 각기 저장한다. 또한, 상기 SoC는 쓰기 명령을 통 하여 상기 제3 내부 메모리 내의 출력 특징맵을 상기 제2 메인 메모리에 저장할 수 있다. 그러나, 메인 메모리가 동적 메모리로 구성될 경우, 예를 들면, DRAM일 경우 CAS Latency 및 RAS Latency 등의 Latency가 발생할 수 있다. 특히 메인 메모리에 저장된 데이터가 랜덤(random)하게 파편화되고 이를 가상 메모 리로 처리할 경우, DRAM 입장에서는 버스트(burst) 읽기/쓰기 동작이 어려운 단점이 있다. 특히 데이터량이 방 대한 인공신경망 연산에서는 이러한 문제가 전체 연산 성능을 급격히 저하시키는 핵심 문제가 될 수 있다. 이하 의 예시 들에서는 메인 메모리는 다이나믹 메모리일 수 있다. 도 15b는 도 15a에 도시된 SFU의 상세 동작 구성을 나타낸다. 도 15b에 도시된 SFU(Special Function Unit)는 복수의 서브 모듈을 포함하도록 구성될 수 있다. SFU는 각각의 모듈을 선택하여 필요한 활성화 함수 또는 특수 기능의 연산을 수행할 수 있다. SFU는 NPU 내부에서 처리되는 데이터의 형식을 변경할 수 있다. 예를 들면 정수에서 플로팅 포인트로 변환을 할 수 있다. 예를 들면, 특정 비트수로 양자화를 할 수 있다. 예를 들면 합성곱 결과 값에 활성화 함수를 적용할 수 있다. 도 15a에 도시된 SFU의 각 동작 구성의 예시는 아래와 같은 표로 정리될 수 있다. 표 1 Description Operation Zero point add Filter or Tensor 별 offset addition (Dequantize offset 연산)Int add Int2float Type casting Scale Filter or Tensor 별 Scale Multiply (Dequantize offset 연산)Float mul Bias add Filter 별 bias 값 addition Float add Batch Filter 별 floating point 값과 mul/add. Scale factor와 zero point 가 fusing된 상태Float mul, Float add Skip add Block 이전 output과 element wise add (Skip connection add)Float add Activation Activation Function Se mul SE block output과 이전 output과 channel wise multiplication (SE module output과 multiply)Float mul Avgpool Accumulate 후에 feature dimension divide Float add, Float Mul Quantize Zero point addition, scale multiply Float add, Float Mul Float2Int Type casting 도 16은 도 15a에 도시된 메인 메모리인 DRAM의 구조 및 동작을 나타낸 예시도이다.도 16을 참조하여 알 수 있 는 바와 같이, DRAM은 복수의 뱅크, 예컨대 8개의 뱅크와, 버퍼를 포함할 수 있다. 상기 DRAM의 자세한 구성요 소는 후술될 도 29 및 도 30을 참조할 수 있다. 각 뱅크는 일정 개수의 행(row)과 열(column)로 이루어진 메모리 셀들을 포함할 수 있다. 하나의 셀은 1비트의 데이터를 저장할 수 있다. 특정 위치의 행과 특정 위치의 열로 식별되는 메모리 셀을 제어하기 위해서 컬럼 및 로우 어드레스가 사용될 수 있다. 읽기 명령과 함께 어드레스를 전달받으면, DRAM은 특정 위치의 행의 메모리 셀들의 비트 값들을 센스 앰프에 래 치(latch)한다. 상기 동작을 위해 RAS latency가 1회 발생한다. 이후 특정 위치의 열의 메모리 셀의 정보를 상 기 래치된 센스 앰프에서 읽는다. 상기 동작을 위해서 CAS latency가 1회 발생한다. 즉, DRAM은 행이 바뀔 때마 다 센스 앰프에 래치를 위한 RAS latency가 발생한다. 예를 들어, 어드레스가 첫 번째 행의 두번째 열로 식별되는 셀2를 지시하면, 상기 DRAM은 예컨대 각각의 뱅크에 대응되는 각각의 센스 앰프에 래치 된 두번째 열에 대응되는 비트 값을 읽어서, 센스 앰프에서 버퍼로 전달한다. 예를 들어, 어드레스가 첫번째 행의 세번째 열로 식별되는 셀 3을 지시하면, 상기 DRAM은 예컨대 8개의 센스 앰 프에 래치 된 세번째 열에 대응되는 비트 값을 읽어서, 버퍼로 전달한다. 즉, 상술한 셀2와 셀3의 경우, 센스 앰프에 필요한 데이터가 래치되어 있기 때문에, 별도의 RAS Latency발생이 불필요하다. 따라서 버스트 읽기가 가능하다. 예를 들면, 버퍼는 동일한 행과 열의 어드레스의 각 뱅크의 비트 값을 받아서 조합한다. 예를 들면 하나의 클럭 으로 8개의 뱅크에서 하나의 비트 값을 각각 읽어와서 8 비트 데이터를 조합할 수 있다. 예를 들면 셀 2의 값을 각각의 뱅크에서 읽어와서 8 비트 데이터를 조합하고, 셀3의 값을 각각의 뱅크에서 읽어와서 8비트 데이터를 조 합할 수 있다. 상기 예시들의 경우, 동일한 행과 다른 열의 주소를 가진다. 하지만 각 뱅크에 대응되는 각 센스 앰프는 선택된 행의 모든 메모리 셀의 데이터를 래치하기 때문에 센스 앰프에 래치 된 정보는 순차적으로 읽을 수 있다. 따라 서 동일한 행에 저장된 데이터는 센스 앰프에 래치 될 때 버스트 읽기 동작이 가능하다. 따라서 버스트 읽기에 따른 연산 속도가 향상될 수 있다. 한편, 읽어야하는 메모리 셀의 행이 동일하지 않으면, 버스트 읽기 동작이 불가능하게 된다. 버스트 읽기 동작 이라 함은 한번에 다량의 비트를 읽는 것을 의미한다. 버스트 읽기 동작은 행(row) 내에서만 가능하다. 도 16의 예시에서 1로 표기된 셀과 4로 표기된 셀은 서로 다른 행에 위치한다. 따라서, 각 행에 대응되는 값을 센스 앰프에 래치하기 위해서는 별도의 RAS latency가 발생하며, RAS latency 때문에 DRAM의 실효 대역폭이 저하된다. 따라서, DRAM인 메인 메모리 내에 저장된 데이터는 버스트 읽기 동작이 가능하도록 DRAM의 뱅크의 행과 열을 고 려하여 저장되어 있어야 한다. 버스트 읽기 동작이 가능하기 위해서는, NPU가 연산을 수행하는 순서에 따라 정의되는 인공신경망(ANN) 데이터 지역성 정보가 필요하다. 부연 설명하면, ANN 데이터 지역성 정보가 분석 또는 제공되면, NPU가 요청할 인공신경망 연산에 필요한 데이터 요청 순서를 모두 알 수 있게 된다. 따라서 DRAM에서 버스트 읽기가 가능하도록 DRAM의 어드레스를 직접 제어할 수 있게 된다. 상기 ANN 데이터 지역성 정보는 인공신경망모델의 레이어 별로 정의되는 것이 아니라, NPU 가 요청하는 데이터 의 순서를 나타내는 것일 수 있다. 즉, 인공신경망 메모리 시스템은 NPU가 생성할 데이터 읽기 요청의 업무 순서를 상기 ANN 데이터 지역성 정보를 기초로 결정한다. 만약 메인 메모리가 RAS latency 및 CAS latency를 가지는 동적 메모리일 경우, 인공신경망 메모리 시스템은 동적 메모리의 Latency가 최소화 되도록 상기 동적 메모리에 인공신경망모델의 데이터를 저장 할 수 있다. 도 17은 제1 예시에 따른 아키텍처를 나타낸다. 도 17을 참조하면, NPU, AMC(인공신경망 메모리 제어부), 그리고 외부 메모리인 메인 메모리가 나타나 있다. 경 우에 따라서 메인 메모리는 외부 메모리로 지칭될 수 있다. 이하 설명의 편의를 위해서 본 개시의 다양한 예시들의 인공신경망 메모리 제어부는 AMC로 지칭할 수 있다. 상기 NPU는 NPU 스케줄러, 내부 메모리 그리고 PE 어레이를 포함할 수 있다. 상기 NPU는 도 15a에 도시된 SFU를 더 포함할 수 있다. PE 어레이는 인공신경망을 위한 동작을 수행할 수 있다. 예를 들어, 입력 데이터가 입력되었을 때, PE 어레이는 인공신경망을 통해 추론 결과를 도출하는 동작을 수행할 수 있다. NPU 스케줄러는 NPU의 추론 연산을 위한 PE 어레이의 연산 및 NPU 내부 메모리의 읽기 및 쓰기 순서를 제어하도 록 구성된다. 부연 설명하면, NPU 스케줄러는 ANN(인공신경망) 데이터 지역성 정보에 기초하여 PE 어레이 및 NPU 내부 메모리를 제어하도록 구성될 수 있다. NPU 스케줄러는 PE 어레이에서 작동할 인공신경망모델의 구조를 분석하거나 또는 분석된 정보를 제공받을 수 있 다. 예를 들면, 상기 NPU의 컴파일러는 인공신경망 데이터 지역성을 분석하도록 구성될 수 있다. 인공신경망모 델이 포함할 수 있는 데이터는 적어도 인공신경망 데이터 지역성에 따른 각각의 레이어의 입력 특징맵, 커널 데 이터, 및 출력 특징맵 등이 있다. 각각의 레이어는 레이어의 크기 및 내부 메모리의 크기에 따라서 선택적으로 타일링(tiling) 될 수 있다. ANN 데이터 지역성 정보는 NPU 스케줄러 내부에 제공되는 메모리 또는 NPU 내부 메모리에 저장될 수 있다. NPU 스케줄러는 상기 메인 메모리에 액세스하여 필요한 데이터를 읽거나 쓸 수 있다. 또한, 상기 NPU 스케줄러는 인 공신경망모델의 레이어 별 특징맵 및 커널 데이터 등의 데이터에 기초하여 ANN 데이터 지역성 정보 또는 구조 에 대한 정보를 활용 할 수 있다. 커널은 가중치로 지칭되는 것도 가능하다. 특징맵은 노드 데이터로 지칭되는 것도 가능하다. 예를 들면, ANN 데이터 지역성은 인공신경망모델 설계 시, 학습 완료 시, 또는 컴파일 시 생성 될 수 있다. NPU 스케줄러는 ANN 데이터 지역성 정보를 레지스터 맵 형식으로 저장할 수 있다. 단, 이에 제한 되지 않는다. NPU 스케줄러는 ANN 데이터 지역성 정보에 기초하여 인공신경망모델의 연산 순서를 스케줄링 할 수 있다. NPU 스케줄러는 ANN 데이터 지역성 정보에 기초하여 인공신경망모델의 각 레이어의 특징맵 및 커널 데이터가 저 장된 메모리 어드레스 값을 획득할 수 있다. 예를 들면, NPU 스케줄러는 메모리에 저장된 인공신경망모델의 레 이어의 특징맵 및 커널 데이터가 저장된 메모리 어드레스 값을 획득할 수 있다. 따라서 NPU 스케줄러는 구동할 인공신경망모델의 레이어의 특징맵 및 커널 데이터의 적어도 일부를 메인 메모리에서 미리 가져온 다음, 적시에 NPU 내부 메모리에 제공할 수 있다. 각각의 레이어의 특징맵은 대응되는 각각의 메모리 어드레스 값을 가질 수 있다. 각각의 커널 데이터는 대응되는 각각의 메모리 어드레스 값을 가질 수 있다.NPU 스케줄러는 ANN 데이터 지역성 정보, 예를 들면, 인공신경망모델의 인공 신경망의 레이어들의 배치 데이터 또는 구조에 대한 정보에 기초해서 PE 어레이의 연산 순서를 스케줄링 할 수 있다. NPU 스케줄러는 ANN 데이터 지역성 정보에 기초하여 연산을 스케줄링 하기 때문에, 일반적인 CPU의 스케줄링 개 념과 다르게 동작할 수 있다. 일반적인 CPU의 스케줄링은 공평성, 효율성, 안정성, 반응 시간 등을 고려하여, 최상의 효율을 낼 수 있도록 동작한다. 즉, 우선 순위, 연산 시간 등을 고려해서 동일 시간내에 가장 많은 프로 세싱을 수행하도록 스케줄링 한다. 종래의 CPU는 각 프로세싱의 우선 순서, 연산 처리 시간 등의 데이터를 고려하여 작업을 스케줄링 하는 알고리 즘을 사용하였다. 즉, 일반적인 CPU의 스케줄링은 랜덤하고 예측하기 어렵기 때문에, 통계, 확률, 우선순위를 기초로 결정된다. 이와 반대로 인공신경망 연산은 랜덤하지 않고 예측 가능하기 때문에, 보다 효율적인 스케줄링이 가능하다. 특 히 인공신경망 연산은 데이터 량이 방대하기 때문에, 효율적인 스케줄링에 따라서 인공신경망의 연산 처리 속도 가 상당히 향상될 수 있다. NPU 스케줄러는 ANN 데이터 지역성 정보에 기초하여 연산 순서를 결정할 수 있다. 더 나아가면, NPU 스케줄러는 ANN 데이터 지역성 정보 및/또는 사용하려는 NPU의 데이터 지역성 정보 또는 구조 에 대한 정보에 기초하여 연산 순서를 결정할 수 있다. 인공신경망모델의 구조에 의하면, 각 레이어 별 연산은 순차적으로 수행된다. 즉, 인공신경망모델의 구조가 확 정될 경우, 레이어 별 연산순서가 정해질 수 있다. 이러한 인공신경망모델의 구조에 따른 연산의 순서 또는 데 이터 흐름의 순서를 알고리즘 레벨에서의 인공신경망모델의 데이터 지역성으로 정의할 수 있다. PE 어레이는 인공신경망의 특징맵과 커널 데이터를 연산하도록 구성된 복수의 PE들이 배치된 구성을 의미한다. 각각의 PE는 MAC(multiply and accumulate) 연산기 및/또는 ALU(Arithmetic Logic Unit) 연산기를 포함할 수 있다. 단, 본 개시에 따른 예시들은 이에 제한되지 않는다. 한편, 상기 NPU 내의 내부 메모리는 정적 메모리 일 수 있다. 예를 들면, 내부 메모리는 SRAM 또는 레지스터일 수 있다. 상기 내부 메모리는 읽기 동작과 쓰기 동작을 동시에 처리할 수 있다. 이를 위해 상기 AMC와 상기 NPU 는 듀얼-포트(dual-port) 통신 인터페이스로 연결되어 있을 수 있다. 대안적으로, 원-포트(one-port) 통신 인터 페이스로 상기 AMC와 상기 NPU가 연결되어 있을 경우, TDM 방식으로 읽기 동작과 쓰기 동작을 순차로 수행할 수 있다. 상기 AMC는 ANN 데이터 지역성 정보 관리 유닛 및 버퍼 메모리를 포함할 수 있다. 상기 AMC는 상기 ANN 데이터 지역성 정보 관리 유닛을 통해서 상기 NPU의 연산 순서 정보를 모니터링 할 수 있 다. 상기 ANN 데이터 지역성 정보 관리 유닛은, 상기 NPU의 연산 순서에 따라 상기 PE들에게 제공할 데이터를 순서 를 정하고 관리할 수 있다. 상기 버퍼 메모리는 상기 메인 메모리로부터 읽어온 데이터를 상기 NPU에게 제공하 기 전에 임시 저장할 수 있다. 또한, 상기 버퍼 메모리는 상기 NPU로부터 제공되는 출력 특징맵을 상기 메인 메 모리에 전달하기 전에 임시 저장할 수 있다. 상기 AMC는 ANN 데이터 지역성 정보에 기초하여 상기 NPU가 요청할 데이터를 상기 NPU가 요청하기 전에 메인 메 모리에서 읽어와서 상기 버퍼 메모리에 저장한다. 상기 AMC는 상기 NPU가 해당 데이터를 실제로 요청하면 상기 버퍼 메모리에 저장된 상기 해당 데이터를 바로 제공한다. 따라서 상기 AMC가 제공됨에 따라 상기 NPU가 처리하 는 인공신경망모델의 연산 순서를 모니터링하여 상기 메인 메모리에 의해서 생성될 수 있는 RAS Latency 및 CAS Latency를 실질적으로 제거할 수 있다. 상기 메인 메모리는 동적 메모리일 수 있다. 예를 들면 메인 메모리는 DRAM일 수 있다. 상기 DRAM인 메인 메모 리와 상기 AMC는 시스템 버스(예, AXI 인터페이스)로 연결될 수 있다. 상기 시스템 버스는 원-포트로 구현될 수 있다. 이 경우 상기 DRAM은 읽기 동작과 쓰기 동작을 동시에 처리할 수 없을 수 있다. 한편, 상기 AMC는 상기 ANN 데이터 지역성 정보에 기초하여, 읽기 동작이 버스트 동작이 되도록, 상기 메인 메 모리 내의 데이터를 재정렬할 수 있다. 따라서, 상기 메인 메모리인 DRAM이 상기 버퍼 메모리에 버스트 동작으로 데이터를 공급하면, 상기 버퍼 메모리 는 상기 데이터를 NPU에 스트리밍 할 수 있다. 상기 버퍼 메모리는 FIFO(First Input First Output) 형태로 구현될 수 있다. 상기 AMC는 상기 버퍼 메모리가 다 차면 대기 상태로 전환시킨다. 상기 버퍼 메모리가 데이터를 NPU에 전달하면, 상기 AMC는 상기 ANN 데이터 지역성 정보에 기초하여 상기 메인 메모리로부터 데이터를 읽어와서 상기 버퍼 메모리에 저장시킨다. 만약 상기 버퍼 메모리의 크기가 작을 경우(예컨대, 1KB), 상기 버퍼 메모리는 상기 메인 메모리와 상기 NPU 사 이의 Latency을 감소시키기 위한 캐싱 역할만을 수행할 수 있다. 이 경우, 상기 메인 메모리와 상기 NPU 사이에 는 버스트 동작에 따라 많은 양의 데이터가 한번에 전달될 수 있다. 이와 같이 버스트 동작이 잘 수행되면, 상 기 메인 메모리의 대역폭이 실질적으로 최대가 될 수 있다. 도 17의 변형 예로서, 상기 AMC는 상기 NPU에 내장되거나 혹은 상기 메인 메모리에 내장되거나, 또는 시스템 버 스에 내장될 수도 있다. 도 18은 제2 예시에 따른 아키텍처를 나타낸다. 도 18을 참조하면, NPU, AMC 그리고 메인 메모리가 나타나 있다. 제2 예시에서는 다른 예시 들에서 설명한 중 복 설명은 설명의 편의를 위해 생략할 수 있다. 다른 예시 들의 구성은 본 예시에 선택적으로 적용 가능하다. 상기 NPU는 NPU 스케줄러, 복수의 내부 메모리 그리고 PE 어레이를 포함할 수 있다. 도 17과 달리, 도 18에 도시된 상기 NPU 내의 상기 복수 내부 메모리는 커널 데이터를 위한 제1 내부 메모리와, 입력 특징맵을 위한 제2 내부 메모리와 그리고 출력 특징맵을 위한 제3 내부 메모리를 포함할 수 있다. 상기 제 1 내지 제3 내부 메모리는 하나의 물리적인 메모리 내에 할당된 복수의 영역들일 수 있다. 각각의 내부 메모리 는 PE 어레이와 통신할 수 있는 포트가 각각 제공될 수 있다. 각각의 내부 메모리에 각각의 포트가 제공되면, 각각의 내부 메모리의 대역폭이 보장될 수 있다. 각각의 내부 메모리의 크기는 가변적으로 조절될 수 있다. 예를 들면, 각각의 내부 메모리의 총합은 1 MByte이 고, 각각의 내부 메모리들의 크기는 A:B:C의 비율로 분할될 수 있다. 예를 들면, 각각의 내부 메모리들의 크기 는 1:2:3의 비율로 분할 될 수 있다. 각각의 내부 메모리의 비율은 인공신경망모델의 각 연산 순서마다 입력 특 징맵의 크기, 출력 특징맵의 크기, 커널 데이터의 크기에 따라 조절될 수 있다. 도 17과 달리, 상기 도 18에 도시된 상기 AMC는 DMA(direct memory access) 컨트롤러를 포함할 수 있다. 상기 외부 메인 메모리는 DRAM일 수 있다. 상기 NPU 내의 PE 어레이가 추론을 위한 연산을 수행하는 도중에, 상기 DMA 컨트롤러는 상기 NPU로부터의 명령 이 없더라도, 상기 ANN 데이터 지역성 정보에 기초하여 독자적으로 상기 메인 메모리로부터 데이터를 읽어와서 상기 버퍼 메모리 내에 저장할 수 있다. 상기 DMA 컨트롤러는 ANN 데이터 지역성 정보에 기초하여 상기 NPU가 요청할 데이터를 상기 NPU가 요청하기 전 에 메인 메모리에서 읽어와서 상기 버퍼 메모리에 저장한다. 상기 DMA 컨트롤러는 상기 NPU가 해당 데이터를 실 제로 요청하면 상기 버퍼 메모리에 저장된 상기 해당 데이터를 바로 제공한다. 따라서 상기 DMA 컨트롤러가 제 공됨에 따라 상기 메인 메모리에 의해서 생성될 수 있는 RAS Latency 및 CAS Latency를 실질적으로 제거할 수 있다. 도 19는 제3 예시에 따른 아키텍처를 나타낸다. 도 19를 참조하면, NPU, AMC, 그리고 메인 메모리가 나타나 있다. 제3 예시에서는 다른 예시 들에서 설명한 중 복 설명은 설명의 편의를 위해 생략할 수 있다. 다른 예시 들의 구성은 본 예시에 선택적으로 적용 가능하다. 상기 NPU는 NPU 스케줄러, 복수의 내부 메모리 그리고 PE 어레이를 포함할 수 있다. 도 17과 달리, 도 19에 도시된 상기 NPU 내의 상기 복수 내부 메모리는 커널 데이터를 위한 제1 내부 메모리와, 입력 특징맵을 위한 제2 내부 메모리와 그리고 출력 특징맵을 위한 제3 내부 메모리를 포함할 수 있다. 상기 제 1 내지 제3 내부 메모리는 하나의 물리적인 메모리 내에 할당된 복수의 영역들일 수 있다. 도 17과 달리, 도 19에 도시된 상기 AMC는 ANN 데이터 지역성 정보 관리 유닛과, 스왑 메모리와 그리고 버퍼 메 모리를 포함할 수 있다. 상기 외부 메인 메모리는 DRAM일 수 있다. 상기 AMC 내의 스왑 메모리는 상기 메인 메모리 내의 데이터를 재정렬하기 위해서 사용될 수 있다. 상기 메인 메모리 내에는 데이터가 파편화되어 무작위한 주소에 저장되어 있을 수 있다. 그러나, 이와 같이 데 이터가 무작위로 저장되어 있는 경우, 상기 메인 메모리에서 데이터를 읽어오려면, 비-일련적인 메모리 주소가 사용되어야 한다. 이러한 경우 CAS(Column Address Strobe) Latency 및 RAS(Row Address Strobe) Latency가 빈 번하게 발생할 수 있다. 이러한 문제를 해결하기 위하여, AMC는 상기 메인 메모리 내의 데이터를 상기 ANN 데이터 지역성 정보에 기초하 여 재정렬할 수 있다. 구체적으로, 상기 AMC는 상기 메인 메모리 내에 파편화된 데이터의 적어도 일부를 상기 스왑 메모리 내에 일시 저장한다. 이어서, 상기 ANN 데이터 지역성 정보에 기초하여 버스트 동작이 가능하도록 상기 메인 메모리에 저장된 상기 데이터를 재정렬할 수 있다. 상기 데이터 재정렬 동작은 초기 동작 시 1회만 수행될 수 있다. 단, 이에 제한되지 않는다. 만약 ANN 데이터 지역성 정보가 변경된 다면, 상기 변경된 ANN 데이터 지역성 정보에 기초하여 상기 재정렬 동작이 다시 수행될 수 있다. 한편, 변형예로서, 상기 AMC는 상기 스왑 메모리를 사용하지 않고, 상기 메인 메모리 내에 스왑 영역을 할당한 후, 상기 데이터 재정렬을 수행할 수도 있다. 도 20은 제4 예시에 따른 아키텍처를 나타낸다. 도 20를 참조하면, NPU, AMC, 그리고 메인 메모리가 나타나 있다. 제4 예시에서는 다른 예시 들에서 설명한 중 복 설명은 설명의 편의를 위해 생략할 수 있다. 다른 예시 들의 구성은 본 예시에 선택적으로 적용 가능하다. 상기 NPU는 NPU 스케줄러, 복수의 내부 메모리 그리고 PE 어레이를 포함할 수 있다. 도 17과 달리, 도 20에 도시된 상기 NPU 내의 상기 복수 내부 메모리는 커널 데이터를 위한 제1 내부 메모리와, 입력 특징맵을 위한 제2 내부 메모리와 그리고 출력 특징맵을 위한 제3 내부 메모리를 포함할 수 있다. 상기 AMC는 ANN 데이터 지역성 정보 관리 유닛과 그리고 복수의 버퍼 메모리를 포함할 수 있다. 도 17과 달리, 도 20에 도시된, 상기 복수의 버퍼 메모리는 커널 데이터를 위한 제1 버퍼 메모리와, 입력 특징 맵을 위한 제2 버퍼 메모리와 그리고 출력 특징맵을 위한 제3 버퍼 메모리를 포함할 수 있다. 상기 제1 내지 제 3 버퍼 메모리는 하나의 물리적인 메모리 내에 할당된 복수의 영역들일 수 있다. 상기 NPU 내의 각 내부 메모리는 상기 AMC 내의 각 버퍼 메모리와 연결될 수 있다. 예를 들어, 제1 내부 메모리 는 제1 버퍼 메모리와 직접 연결되고, 제2 내부 메모리는 제2 버퍼 메모리와 직접 연결되고, 제3 내부 메모리는 제3 버퍼 메모리와 연결될 수 있다. 각각의 버퍼 메모리는 상기 NPU의 각각의 내부 메모리와 통신할 수 있는 포트가 각각 제공될 수 있다. 각각의 버퍼 메모리의 크기는 가변적으로 조절될 수 있다. 예를 들면, 각각의 버퍼 메모리의 총합은 1 MByte이 고, 각각의 버퍼 메모리들의 크기는 A:B:C의 비율로 분할될 수 있다. 예를 들면, 각각의 버퍼 메모리들의 크기 는 1:2:3의 비율로 분할 될 수 있다. 각각의 버퍼 메모리의 비율은 인공신경망모델의 각 연산 순서마다 입력 특 징맵의 크기, 출력 특징맵의 크기, 커널 데이터의 크기에 따라 조절될 수 있다. 상기 AMC는 NPU의 연산 동작을 위한 데이터를 상기 ANN 데이터 지역성 정보에 기초하여 상기 각 버퍼 메모리 내 에 개별적으로 저장할 수 있다. 한편, 도 23을 참조하여 알 수 있는 바와 같이 인공신경망모델이 Mobilenet V1.0에 기반한 것일 경우, depth- wise convolution 및/또는 point-wise convolution을 위한 커널(즉, 가중치)의 크기 편차가 상당히 클 수 있다. 따라서, ANN 데이터 지역성 정보에 기초하여, 상기 각 내부 메모리의 크기는 조절될 수 있다. 마찬가지로 상기 각 버퍼 메모리의 크기도 조절될 수 있다. 도 21은 제5 예시에 따른 아키텍처를 나타낸다. 도 21를 참조하면, NPU, AMC, 그리고 메인 메모리가 나타나 있다. 제5 예시에서는 다른 예시 들에서 설명한 중 복 설명은 설명의 편의를 위해 생략할 수 있다. 다른 예시 들의 구성은 본 예시에 선택적으로 적용 가능하다.상기 NPU는 NPU 스케줄러, 복수의 내부 메모리 그리고 PE 어레이를 포함할 수 있다. 도 17과 달리, 도 21에 도시된 상기 NPU 내의 상기 복수 내부 메모리는 커널 데이터를 위한 제1 내부 메모리와, 입력 특징맵을 위한 제2 내부 메모리와 그리고 출력 특징맵을 위한 제3 내부 메모리를 포함할 수 있다. 상기 AMC는 ANN 데이터 지역성 정보 관리 유닛과 그리고 버퍼 메모리를 포함할 수 있다. 다른 예시에서 언급하였듯이 상기 메인 메모리 내에는 데이터가 무작위로 파편화되어 있을 수 있다. 그러나, 이 와 같이 데이터가 무작위로 저장되어 있는 경우, 상기 메인 메모리에서 데이터를 읽어오려면, 비-일련적인 메모 리 주소가 사용되어야 하므로, CAS(Column Address Strobe) Latency 및 RAS(Row Address Strobe) Latency이 발 생할 가능성이 있다. 이러한 문제를 해결하기 위하여, AMC는 상기 메인 메모리 내의 데이터를 상기 ANN 데이터 지역성 정보에 기초하 여 재정렬할 수 있다. 구체적으로, 상기 AMC는 상기 메인 메모리 내에 파편화된 데이터의 적어도 일부를 상기 버퍼 메모리 내에 일시 저장한다. 이어서, 상기 ANN 데이터 지역성 정보에 기초하여 버스트 동작이 가능하도록 상기 메인 메모리에 저장된 상기 데이터를 재정렬할 수 있다. 한편, 데이터가 재정렬되면, 메모리 주소가 변경될 수 있다. 따라서, 상기 AMC 내의 상기 ANN 데이터 지역성 정 보 관리 유닛과 상기 NPU 스케줄러는 서로 통신할 수 있다. 구체적으로, 상기 ANN 데이터 지역성 정보 관리 유 닛은 상기 데이터 재정렬 이후에 갱신된 메모리 주소를 저장한다. 이어서 상기 ANN 데이터 지역성 정보 관리 유 닛은 상기 NPU 스케줄러에 저장된 기존의 메모리 주소를 갱신할 수 있다. 도 22는 제6 예시에 따른 아키텍처를 나타낸다. 도 22를 참조하면, NPU, AMC, 그리고 메인 메모리가 나타나 있다. 제6 예시에서는 다른 예시 들에서 설명한 중 복 설명은 설명의 편의를 위해 생략할 수 있다. 다른 예시 들의 구성은 본 예시에 선택적으로 적용 가능하다. 상기 NPU는 NPU 스케줄러, 복수의 내부 메모리 그리고 PE 어레이를 포함할 수 있다. 도 17과 달리, 도 22에 도시된 상기 NPU 내의 상기 복수 내부 메모리는 가중치를 위한 제1 내부 메모리와, 입력 특징맵을 위한 제2 내부 메모리와 그리고 출력 특징맵을 위한 제3 내부 메모리를 포함할 수 있다. 상기 제1 내 지 제3 내부 메모리는 하나의 물리적인 메모리 내에 할당된 복수의 영역들일 수 있다. 상기 AMC는 ANN 데이터 지역성 정보 관리 유닛과 그리고 TLB(translation lookaside buffer) 그리고 버퍼 메모 리를 포함할 수 있다. 상기 메인 메모리 내에는 데이터가 무작위로 저장되어 있을 수 있다. 그러나, 이와 같이 데이터가 무작위로 저 장되어 있는 경우, 상기 메인 메모리에서 데이터를 읽어오려면, 비-일련적인 메모리 주소가 사용되어야 하므로, CAS(Column Address Strobe) Latency 및 RAS(Row Address Strobe) Latency이 발생할 가능성이 있다. 이러한 문제를 해결하기 위하여, AMC는 상기 메인 메모리 내의 데이터를 상기 ANN 데이터 지역성 정보에 기초하 여 재정렬할 수 있다. 구체적으로, 상기 AMC는 상기 메인 메모리 내에 저장된 데이터들을 상기 버퍼 메모리 내 에 일시 저장한 후, 상기 ANN 데이터 지역성 정보에 기초하여 버스트 동작이 가능하도록 상기 메인 메모리에 저 장된 상기 데이터를 재정렬할 수 있다. 한편, 데이터가 재정렬되면, 메모리 주소가 변경될 수 있다. 따라서, 상기 AMC 내의 TLB는 재정렬 이전의 구 메 모리 주소와 상기 재정렬 이후의 신 메모리 주소를 테이블 형태로 저장할 수 있다. 상기 NPU 내의 스케줄러가 구 메모리 주소를 사용하여 데이터를 요청하는 경우, 상기 AMC 내의 TLB는 상기 구 메모리 주소를 상기 신 메모리 주소로 변환하여 상기 메인 메모리 내에서 데이터를 읽어온 후, 상기 버퍼 메모 리 내에 저장할 수 있다. 따라서, 도 21과 달리, 상기 TLB를 통해서 NPU 스케줄러에 저장된 메모리 어드레스를 갱신할 필요가 없어도 메인 메모리가 버스트 모드로 동작할 수 있게 된다. 상술한 다양한 예시들에서 AMC와 NPU는 분리된 구성으로 도시되어 있지만, AMC는 NPU에 포함되도록 구성되는 것 도 가능하다. 도 23은 인공신경망모델로서 Mobilenet V1.0이 사용될 경우, 데이터의 예를 나타낸 예시도이다. 도 23을 참조하면, 인공신경망모델의 구조 및 알고리즘이 정의되어 있다. 본 개시의 다양한 예시들에 따르면, 컴파일러, AMC 또는 NPU 스케줄러는 상기 인공신경망모델의 ANN 데이터 지역성 정보를 모니터링, 갱신, 생성 및/또는 저장하도록 구성될 수 있다. Mobilenet V1.0은 예를 들면, 28개의 레이어로 구성될 수 있다. 각각의 레이어의 입력 특징맵, 커널, 출력 특징 맵은 각각의 크기를 가지고, 각각의 레이어에 적용되는 활성화 함수가 정의되어 있다 도 23을 참조하여 알 수 있는 바와 같이, 인공신경망모델로서 Mobilenet V1.0이 사용될 경우, 커널의 데이터 크 기 그리고 입력 특징맵(IFMAP)의 데이트 크기 그리고 출력 특징맵(OFMAP)의 데이터 크기의 편차는 레이어 별로 상당히 클 수 있다. 도 24는 메인 메모리 내의 데이터를 버퍼 메모리에 캐싱한 후, 연산을 수행하는 예를 나타낸다. 도 24를 참조하여 알 수 있는 바와 같이, DRAM을 적용한 메인 메모리의 메모리 맵(memory map)과 AMC 내의 버퍼 메모리의 메모리 맵이 나타나 있다. 상기 메인 메모리와 상기 버퍼 메모리는 시스템 버스(예, AXI 인터페이스) 로 연결될 수 있다. 버퍼 메모리는 캐쉬 메모리로 지칭될 수 있다. 상기 메인 메모리의 상기 메모리 맵은 인공신경망 데이터 지역성 정보를 기초로 상기 메인 메모리가 버스트 모 드로 동작하도록 설정될 수 있다. 버스트 모드는 읽기 버스트 또는 쓰기 버스트 일 수 있다. 상기 버퍼 메모리의 상기 메모리 맵은 상기 인공신경망 데이터 지역성 정보를 기초로 상기 NPU가 순차적으로 요 청할 데이터에 대응하는 데이터를 순차적으로 캐싱할 수 있다. 상기 메인 메모리의 상기 메모리 맵과 상기 AMC내의 상기 버퍼 메모리의 메모리 맵은 상기 인공신경망 데이터 지역성 정보를 기초로 서로 대응된다. 제1 커널(Kernel_1), 제1 입력 특징맵(IFMAP_1), 및 제1 출력 특징맵(OFMAP_1)을 상기 메인 메모리의 상기 메 모리 맵에 할당할 수 있다. 제1 커널(Kernel_1)은 도 23의 인공신경망의 제1 레이어(Conv1)의 커널일 수 있다. 제1 입력 특징맵(IFMAP_1)은 도 23의 인공신경망의 제1 레이어(Conv1)의 입력 특징맵일 수 있다. 제1 출력 특징맵(OFMAP_1)은 도 23의 인공 신경망의 제1 레이어(Conv1)의 출력 특징맵일 수 있다. 제2 커널(Kernel_2), 제2 출력 특징맵(OFMAP_2)을 상기 메인 메모리의 상기 메모리 맵에 할당할 수 있다. 이때, 상기 제1 출력 특징맵(OFMAP_1)은 제2 입력 특징맵(IFMAP_2)으로 상기 메모리 맵에 할당될 수 있다. 즉, 인공신 경망의 특정 레이어의 출력 특징맵은 다음 레이어의 입력 특징맵이 될 수 있다. 제2 커널(Kernel_2)은 도 23의 인공신경망의 제2 레이어(Conv2)의 커널일 수 있다. 제2 입력 특징맵(IFMAP_2)은 도 23의 인공신경망의 제2 레이어(Conv2)의 입력 특징맵일 수 있다. 제2 출력 특징맵(OFMAP_2)은 도 23의 인공 신경망의 제2 레이어(Conv2)의 출력 특징맵일 수 있다. 상술하였듯이, 상기 제2 출력 특징맵(OFMAP_2)은 제3 입력 특징맵(IFMAP_3)으로 상기 메모리 맵에 할당될 수 있 다. 또한 도시된 바와 같이 상기 메인 메모리는 복수의 커널과 복수의 출력 특징맵을 상기 메모리 맵에 할당할 수 있다. 각 출력 특징맵은 다음 입력 특징맵으로 이용될 수 있다. 따라서, 상기 인공신경망 데이터 지역성 정 보에 기초하여 설정된 메모리 맵은 상기 메인 메모리가 버스트 모드에 최적화 되도록 할 수 있다. 상기 AMC내의 버퍼 메모리는 상기 ANN 데이터 지역성 정보와 상기 버퍼 메모리의 크기에 기초하여 상기 메인 메 모리에 저장된 커널들과 출력 특징맵들을 사전에 캐싱할 수 있다. 만약 상기 버퍼 메모리의 크기가 부족할 경우, 캐싱할 데이터는 타일링 될 수 있다. 예를 들면, 타일링은 컴파일러 또는 AMC에 의해서 ANN 데이터 지역 성 정보를 기초로 사전에 또는 실시간으로 결정될 수 있다. NPU의 NPU 스케줄러는 상기 버퍼 메모리로부터 입력 특징맵과 커널을 읽어와서 NPU의 내부 메모리에 저장한다. NPU의 PE 어레이는 상기 내부 메모리로부터 상기 입력 특징맵과 상기 커널을 읽어와서 합성 곱 연산을 수행한다. 상기 PE 어레이에서 합성곱 연산을 위해서는 커널과 입력 특징맵의 적어도 일부가 모두 내부 메모리에 준비되어 야 한다. 이하의 도 24는 도 23의 제1 레이어(Conv1)의 커널, 입력 특징맵, 및 출력 특징맵의 합성곱을 예시로 설명한다. 이하 설명의 편의를 위해 커널과 입력 특징맵의 크기는 임의로 설명한다.이하 제1 커널(Kernel_1)의 크기가 3x3x1이고 제1 입력 특징맵(IFMAP_1)의 크기가 9x9x1인 경우를 예시로 설명 한다. 제1 입력 특징맵(IFMAP_1)보다 크기가 상대적으로 작은 제1 커널(Kernel_1)을 상기 메인 메모리에서 상기 제1 입력 특징맵(IFMAP_1)보다 먼저 읽도록 상기 메인 메모리의 메모리 맵을 설정할 수 있다. 만약 상술한 메모리 맵의 어드레스를 순차적으로 읽으면, 상기 메모리 맵에 순차적으로 할당된 제1 커널 (Kernel_1)을 먼저 읽고, 다음으로 제1 입력 특징맵(IFMAP_1)을 읽게 된다. 따라서 메인 메모리는 버스트 모드 동작이 가능해질 수 있다. 한편, 상기 커널과 상기 입력 특징맵을 상기 메인 메모리에서 상기 내부 메모리로 읽어오지 않는다면, 상기 NPU 는 상기 합성곱 연산을 수행할 수 없게 된다. 하지만 작은 크기의 커널을 먼저 읽고, 도 24에 도시된 화살표 방향으로 상기 입력 특징맵의 데이터를 메인 메 모리에서 읽어올 경우, 입력 특징맵 적어도 일부만 읽더라도, 합성곱 연산을 시작할 수 있게 된다. 도 24에서는 커널과 중첩되는 9개의 입력 특징맵의 데이터가 준비되면 합성곱 연산의 시작이 가능해진다. 따라서, 상기 NPU 는 상기 커널을 상기 내부 메모리로부터 먼저 읽도록 구성될 수 있다. 예를 들어, 도시된 바와 같이, 제1 레이어를 위한 제1 입력 특징맵(IFMAP_1)이 9x9x1의 크기이고, 제1 커널 (Kernel_1)은 3x3x1의 크기이라고 가정하자. 먼저 상기 NPU는 상기 제1 커널(Kernel_1)을 상기 내부 메모리로부 터 읽어온다. 다음으로, 도시된 바와 같이 커널의 시작 위치와 중첩되는 제1 입력 특징맵(IFMAP_1)의 적어도 일 부를 읽으면서 합성곱 연산을 시작할 수 있다. 그 다음에는 상기 NPU는 상기 제1 입력 특징맵(IFMAP_1)을 첫 번째 열의 4번째 행부터 시작해서 두번째 열의 4 번째 행의 순서로 합성곱을 수행한다. 상기 순서는 제1 화살표(AR1)에 도시 되어 있다. 그 다음에는, 상기 NPU는 상기 제1 입력 특징맵(IFMAP_1)을 네 번째 열의 첫번째 행부터 시작해서 네번째 열의 두번째 행의 순서로 합성곱을 수행한다. 상기 순서는 제2 화살표(AR2)에 도시 되어 있다. 상술한 동작에 따르면, 제1 출력 특징맵(OFMAP_1)이 생성된다. 상기 제1 출력 특징맵(OFMAP_1)이 생성되는 순서 는 제3 화살표(AR3)에 도시되어 있다. 상기 합성곱 연산에 따른 제1 출력 특징맵(OFMAP_1)은 도시된 바와 같이 7x7x1의 크기일 수 있다. 즉, 메인 메모리에서 입력 특징맵을 읽어오는 순서는 도 24의 화살표 방향에 대응될 수 있다. 따라서 메인 메모 리에 저장된 입력 특징맵의 메모리 맵은 버스트 모드 동작을 위해서 커널의 이동방향을 고려한 어드레스 값을 가지도록 설정될 수 있다. 도 24에서는 상기 버퍼 메모리가 FIFO 형태로 구현되어 있다. 도 24에서는 상기 버퍼 메모리에는 시간의 흐름에 따른 2개의 메모리 맵이 도시되어 있다. 상단의 메모리 맵은 초기의 메모리 맵이고, 화살표 아래의 메모리 맵은 일정 시간이 지난 이후의 메모리 맵이다. 상기 버퍼 메모리의 상측 메모리 맵을 참조하면, 제1 커널(Kernel_1)이 입력되고, 다음으로 제1 입력 특징맵 (IFMAP_1)이 입력되는 방식으로 상기 버퍼 메모리가 지속적으로 채워진다. 상기 버퍼 메모리의 하측 메모리 맵을 참조하면, 특정 연산 마다 상기 메모리 맵이 갱신될 수 있다. 즉, 제3 출 력 특징맵(OFMAP_3)이 입력되고, 다음으로 제4 커널(Kernel_4)이 입력되는 방식으로 상기 버퍼 메모리가 지속적 으로 채워질 수 있다. 도 25는 메인 메모리 내의 데이터를 버퍼 메모리에 캐싱한 후, 타일링 기법에 기초하여 연산을 수행하는 다른 예를 나타낸다. 도 25를 참조하면, 메인 메모리와 AMC 내의 버퍼 메모리(캐쉬 메모리)가 나타나 있다. 상기 메인 메모리와 상기 버퍼 메모리는 시스템 버스로 연결될 수 있다. 도 25의 예시는 도 24의 예시에 타일링 개념이 적용된 예시이다. 이하 타일링 예시에 대하여 설명한다. 도 24의 예시에서는 입력 특징맵이 타일링 된 경우를 도시한다. 상기 메인 메모리에 저장되는 커널, 입력 특징맵 및 출력 특징맵 중 적어도 하나가 타일링 될 수 있다. 상기 메 인 메모리의 메모리 맵은 타일링 될 수 있다. 상기 버퍼 메모리에 저장되는 커널, 입력 특징맵 및 출력 특징맵 중 적어도 하나는 타일링 될 수 있다. 상기 버 퍼 메모리의 메모리 맵은 타일링 될 수 있다. 도시된 바와 같이 제1 레이어(Conv1)를 위한 입력 특징맵은 단지 설명의 편의를 위해서 18x18x1 크기로 가정한 다. 상기 입력 특징맵은 9x9x1 크기인 4개의 입력 특징맵으로 타일링 될 수 있다. 즉, 제1 레이어(Conv1)를 위한 제1 입력 특징맵 은 제1 입력 특징맵 타일(IFMAP_1-1), 제2 입력 특징맵 타일 (IFMAP_1-2), 제3 입력 특징맵 타일(IFMAP_1-3), 및 제4 입력 특징맵 타일(IFMAP_1-4)로 타일링 될 수 있다. 상기 4개의 입력 특징맵 타일은 조합되어 제1 입력 특징맵이 될 수 있다. 이때, 제1 레이어(Conv1)의 제1 커널(Kernel_1)은 재사용 될 수 있다. 따라서 각각의 타일의 합성곱에는 동일한 커널이 사용될 수 있다. 이러한 경우, 상기 제1 커널(Kernel_1)은 상기 4개의 타일링이 완료될 때 까지, NPU 내 부 메모리에서 재사용 될 수 있다. 즉, 제1 커널(Kernel_1)과 제1 입력 특징맵 타일(IFMAP_1-1)을 합성곱 하면 제1 출력 특징맵 타일(OFMAP_1- 1)이 생성 된다. 제1 커널(Kernel_1)과 제2 입력 특징맵 타일(IFMAP_1-2)을 합성곱 하면 제2 출력 특징맵 타일 (OFMAP_1-2)이 생성 된다. 제1 커널(Kernel_1)과 제3 입력 특징맵 타일(IFMAP_1-3)을 합성곱 하면 제3 출력 특 징맵 타일(OFMAP_1-3)이 생성 된다. 제1 커널(Kernel_1)과 제4 입력 특징맵 타일(IFMAP_1-4)을 합성곱 하면 제 4 출력 특징맵 타일(OFMAP_1-4)이 생성 된다. 상기 4개의 출력 특징맵 타일은 조합되어 제1 출력 특징맵이 될 수 있다. 이때, 상기 메인 메모리의 메모리 맵은 타일링 된 인공신경망 데이터 지역성 정보에 기초하여 버스트 모드로 동 작 가능하도록 설정될 수 있다. 즉, 타일링 방식에 따라서 인공신경망 데이터 지역성 정보는 변경될 수 있다. 타일링 규칙은 다양하게 변형될 수 있다. 즉, ANN 데이터 지역성 정보는 NPU가 메인 메모리에 요청할 데이터의 순서를 포함하며, 타일링에 따른 순서도 포함된다. 예를 들면, ANN 데이터 지역성 정보는, 제1 입력 특징맵 타일(IFMAP_1-1), 제2 입력 특징맵 타일(IFMAP_1-2), 제3 입력 특징맵 타일(IFMAP_1-3), 및 제4 입력 특징맵 타일(IFMAP_1-4) 순서를 포함할 수 있다. 예를 들면, ANN 데이터 지역성 정보는, 제4 입력 특징맵 타일(IFMAP_1-4), 제3 입력 특징맵 타일(IFMAP_1-3), 제2 입력 특징맵 타일(IFMAP_1-2), 및 제1 입력 특징맵 타일(IFMAP_1-1) 순서를 포함할 수 있다. 즉, AMC의 버퍼 메모리는 ANN 데이터 지역성 정보를 제공받거나 또는 생성하여 NPU가 요청할 순서를 예측하고, 상기 순서에 대응되는 데이터를 순차적으로 캐싱 할 수 있다. 도 26은 메인 메모리 내의 데이터를 재정렬하는 예를 나타낸다. 도 26의 예시는 ANN 데이터 지역성에 따라 메인 메모리의 메모리 맵을 재설정하는 방법을 설명하는 예시이다. 도 26을 참조하면, 메인 메모리는 하나 또는 복수의 가중치와 하나 또는 복수의 입력 특징맵 그리고 하나 또는 복수의 출력 특징맵을 저장할 수 있다. 도 25에서 상술하였듯이, 타일링이 적용될 경우, ANN 데이터 지역성이 재설정 될 수 있다. 예를 들면, 타일링 된 각 타일의 처리 순서가 변경될 수 있다. 이러한 경우, 메인 메모리가 버스트 모드로 동작하기 위해서, ANN 데이터 지역성에 따라서 메인 메모리의 메모리 맵을 재설정할 수 있다. 도 25에서 설명하였듯이, 제1 레이어의 입력 특징맵은 4개의 입력 특징맵 타일로 분할될 수 있다. 즉, 제1 레이 어의 입력 특징맵은 제1 입력 특징맵 타일(IFMAP_1-1), 제2 입력 특징맵 타일(IFMAP_1-2), 제3 입력 특징맵 타 일(IFMAP_1-3), 제4 입력 특징맵 타일(IFMAP_1-4)로 분할될 수 있다. 도 25에서 설명하였듯이, 제1 레이어의 출력 특징맵은 4개의 출력 특징맵 타일로 분할 될 수 있다. 즉, 제1 레 이어의 출력 특징맵은 제1 출력 특징맵 타일(OFMAP_1-1), 제2 출력 특징맵 타일(OFMAP_1-2), 제3 출력 특징맵 타일(OFMAP_1-3), 제4 출력 특징맵 타일(OFMAP_1-4)로 분할될 수 있다. 이때, 기 설정된 메인 메모리의 메모리 맵이 리드 버스트 동작 관점에서 ANN 데이터 지역성 정보와 대응되지 않 을 경우, 메인 메모리에서 불필요한 RAS Latency 및 CAS Latency가 발생할 수 있고, 버스트 모드 동작 효율이 현저히 저하될 수 있다. 또한 불필요한 소비 전력이 증가될 수 있다. 이러한 경우, 메인 메모리의 메모리 맵은 AMC 내의 ANN 데이터 지역성 정보에 기초하여 재정렬될 수 있다. 이때, AMC는 메인 메모리를 직접 제어하여 버스트 모드 동작이 가능한 메모리 맵을 재설정하도록 구성될 수 있다. 도 27은 NPU의 연산을 위한 메인 메모리의 메모리 맵을 나타낸 예시도이다. 도 27을 참조하면, 메인 메모리의 메모리 맵은 커널, 입력 특징맵, 및 출력 특징맵을 포함 할 수 있다. 상기 메인 메모리의 메모리 맵은 NPU가 처리하는 인공신경망모델의 ANN 데이터 지역성에 기초하여 버스트 모드 동작에 최적화된 어드레스를 가지도록 구성될 수 있다. 도 27에 도시된 메모리 맵을 참조하면, 제1 레이어(Conv1)의 제1 커널(Kernel_1)의 데이터 크기는 864 Byte이고, 시작 어드레스는 0x00000000000이고 끝 어드레스는 0x00000000099일 수 있다. 제1 입력 특징맵 (IFMAP_1)의 데이터 크기는 150,528 Byte이고, 시작 어드레스는 0x00000000100이고 끝 어드레스는 0x00000000199일 수 있다. 제2 레이어(Conv1)의 제2 커널(Kernel_2)의 데이터 크기는 401,408 Byte이고, 시작 어드레스는 0x00000000200이고 끝 어드레스는 0x00000000299일 수 있다. 단, 도 27의 데이터 크기 및 어드레스 는 임의의 숫자일 뿐이며, 특별한 의미를 가지지 않는다. 상기 어드레스는 상기 메인 메모리의 어드레스를 의미 한다. 상기 메인 메모리의 어드레스가 증가하는 방식으로 ANN 데이터 지역성에 기초한 메모리 맵이 설정될 수 있다. 부연 설명하면, ANN 데이터 지역성에 따른다는 의미는 NPU가 메인 메모리에 요청할 메모리 오퍼레이션의 순서를 따른다는 것을 의미할 수 있다. 즉, 상기 ANN 데이터 지역성에 따르면, NPU는 제1 커널(Kernel_1)을 먼저 요청하고, 다음으로 제1 입력 특징맵 (IFMAP_1)을 요청할 것을 알 수 있다. 따라서 제1 커널(Kernel_1)과 제1 입력 특징맵(IFMAP_1)을 읽기 버스트 모드로 동작하기 위해서는 메인 메모리의 메모리 맵이 ANN 데이터 지역성에 대응되도록 설정되어야 한다. 도 27을 참조하면, 상기 메모리 맵은 상기 NPU가 상기 메인 메모리에게 요청하는 인공신경망모델의 모든 메모리 읽기 및 쓰기 작업 순서(즉, ANN 데이터 지역성)를 기초로, 상기 메인 메모리가 버스트 모드로 상기 AMC에 데이 터를 공급할 수 있도록 구성될 수 있다. 따라서 상기 메인 메모리와 상기 AMC 사이의 시스템 버스의 실효 대역폭을 최대화 할 수 있다. 또한 불필요한 Latency가 제거되어 소비 전력을 저감할 수 있다. 또한 AMC의 버퍼 메모리는 NPU가 요청하기 전에 상기 NPU가 요청할 데이터를 캐싱 할 수 있기 때문에 캐쉬 미스가 실질적으로 제거될 수 있다. 또한, 제1 출력 특징맵(OFMAP_1)과 제2 입력 특징맵(IFMAP_2)은 동일한 어드레스를 가질 수 있다는 것을 볼 수 있다. 특정 레이어의 출력 특징맵과 다음 레이어의 입력 특징맵의 어드레스를 동일하게 설정하는 것은 ANN 데이 터 지역성을 기초로 설정될 수 있다. 따라서, 메인 메모리의 메모리 사용량을 저감할 수 있다. 도 28은 ANN 데이터 지역성 정보에 기초하여 AMC가 메인 메모리의 버스트 동작을 제어하는 예를 나타낸다. 도 28을 설명할 때, 도 23 및 도 4를 같이 참조할 수 있다. 도 28에는 인공신경망모델의 각 레이어의 이름, 대 응되는 메인 메모리의 버스트 동작 명령, 대응되는 메모리 맵, 대응되는 ANN 데이터 지역성 정보(ANN DL), 및 데이터 크기가 나타나 있다. 예를 들면, 제1 레이어(Conv1)는 제1 커널(Kernel_1), 제1 입력 특징맵(IFMAP_1), 및 제1 출력 특징맵 (OFMAP_1)을 포함할 수 있다. 제1 커널(Kernel_1)은 도 27에 도시된 제1 커널(Kernel_1)에 대응되는 메모리 맵 어드레스를 포함할 수 있다. 제1 입력 특징맵(IFMAP_1)은 도 27에 도시된 제1 입력 특징맵(IFMAP_1)에 대응되는 메모리 맵 어드레스를 포함 할 수 있다. 제1 출력 특징맵(OFMAP_1)은 도 27에 도시된 제1 출력 특징맵(OFMAP_1)에 대응되는 메모리 맵 어드 레스를 포함할 수 있다. 다른 예시들에서 상술하였듯이, ANN 데이터 지역성 정보(ANN DL)는 NPU가 메인 메모리에게 명령하는 데이터 접 근 요청 순서를 포함할 수 있다. 그리고 상기 데이터 접근 요청 순서는 도 4에 설명한 토근에 대응되는 것도 가 능하다. 상기 ANN 데이터 지역성 정보(ANN DL)는 다른 예시들의 NPU의 NPU 스케줄러 및/또는 AMC의 ANN 데이터 지역성 정보 관리 유닛에 저장될 수 있다. AMC는 메인 메모리와 통신하는 시스템 버스가 버스트 모드를 지원하는 버스로 구성될 경우, 각각의 데이터 접근 요청을 버스트 모드로 메인 메모리에 명령하도록 구성될 수 있다. 예를 들면, DRAM 버스 중 하나인 AdvancedeXtensible Interface 4(AXI4)는 버스트 모드를 지원한다. 상술하였듯이, 메인 메모리에 저장된 인공신경망모델은 연속되는 버스트 모드를 고려하여 생성된 메모리 맵을 가지기 때문에, 시스템 버스는 실효 대역폭 증가, 소비 전력 저감 효과를 가질 수 있다. 도 29는 ANN 데이터 지역성 정보에 기초하여 메인 메모리의 주소를 매핑하는 방식의 일 예를 나타낸 예시도이다. 도 29를 참조하면, DRAM의 기본 구조가 도시 되어 있다. DRAM은 행(row)과 열(column)의 주소를 가지는 매트릭 스 구조의 복수의 메모리 셀을 포함한다. 상기 매트릭스 구조의 복수의 메모리 셀의 하단에는 센스 앰프가 배치 된다. 로우 어드레스 디코더는 특정 행을 선택한다. 해당 동작을 수행하기 위해서 RAS Latency가 소요된다. 선 택된 행의 메모리 셀들의 데이터는 센스 앰프에 래치된다. 컬럼 어드레스 디코더는 센스 앰프에 래치된 데이터 에서 필요한 데이터를 선택하여 데이터 버퍼로 전송한다. 해당 동작을 수행하기 위해서 CAS Latency가 소요된다. 상기 구조는 DRAM의 뱅크로 지칭될 수 있다. DRAM은 복수의 뱅크를 포함할 수 있다. 이때, 버스트 모드로 DRAM이 동작하면, 메모리 셀의 어드레스가 순차적으로 증가되면서 데이터를 읽거나 쓰게 된다. 따라서 파편화된 어드레스의 데이터를 읽는 경우와 비교할 때 RAS Latency와 CAS Latency 발생이 최소화 된다. 부연 설명하면, AMC 또는 NPU가 메인 메모리에 버스트 모드를 지시하더라도, DRAM에 저장된 데이터가 실질적으 로 파편화 된 경우, 파편화 된 만큼의 RAS Latency와 CAS Latency가 발생하게 된다. 따라서 단순히 버스트 모드 명령을 하는 것으로 실질적인 RAS Latency와 CAS Latency 저감을 하기는 어렵다. 이와 반대로, SRAM의 경우 데이터의 파편화 여부가 실질적으로 Latency를 발생시키지 않는다. 따라서, SRAM으로 구성된 버퍼 메모리 또는 내부 메모리는 데이터의 파편화에 따른 Latency 발생이 치명적이지 않을 수 있다. 도 29를 참조하면 ANN 데이터 지역성 정보(ANN DL)를 기초로 DRAM의 메모리 셀에 NPU가 요청할 데이터의 순서와 크기를 고려하여 메모리 맵을 설정할 수 있다. 상기 메모리 맵은 각 데이터 사이즈를 기초로 시작 주소와 끝 주 소를 기초로 설정될 수 있다. 따라서 DRAM에서 ANN 데이터 지역성 정보(ANN DL) 순서대로 메모리 오퍼레이션을 수행하면, 모든 메모리 오퍼레이션이 버스트 모드로 동작 가능해질 수 있다. 따라서, 도 29에 도시된 메인 메모리는 표 2에 나타난 메모리 주소와 동작 모드를 기초로 제어될 수 있다. 도 29 및 표 2에 대응되는 ANN 데이터 지역성 정보(ANN DL)는 NPU가 입력 특징맵, 커널, 및 출력 특징맵 순서로 메인 메모리에 데이터를 요청하도록 설정된 경우의 예시이다. 표 2 레이어 시작 주소 끝 주소 동작 모드 도메인 ANN DL 크기 (Byte) 1 0 A=A' Read-Burst IFMAP 1 A 1 A'+1 A+1+B=B' Read-Burst Kernel 2 B 1 B'+1 B'+1+C=C' Write-Burst OFMAP 3 C 2 B'+1 B'+1+C=C' Read-Burst IFMAP 4 C 2 C'+1 C'+1+D=D' Read-Burst Kernel 5 D 2 D'+1 D'+1+E=E' Write-Burst OFMAP 6 E 3 D'+1 D'+1+E=E' Read-Burst IFMAP 7 E 3 E'+1 E'+1+F=F' Read-Burst Kernel 8 F 3 F'+1 F'+1+G=G' Write-Burst OFMAP 9 G 4 F'+1 F'+1+G=G' Read-Burst IFMAP 10 G 4 G'+1 G'+1+H=H' Read-Burst Kernel 11 H 4 H'+1 H'+1+I=I' Write-Burst OFMAP 12 I 5 H'+1 H'+1+I=I' Read-Burst IFMAP 13 I 5 I'+1 I'+1+J=J' Read-Burst Kernel 14 J 5 J'+1 J'+1+K=K' Write-Burst OFMAP 15 K 부연 설명하면, 표 2의 도메인은 도 12에서 설명한 도메인 정보를 활용하는 것도 가능하다. 부연 설명하면, 표 2의 동작 모드는 도 12에서 설명한 동작 모드 정보를 활용 하는 것도 가능하다데이터는 ANN 데이터 지역성 정보 (ANN DL)에 따라서 순차적인 주소에 매핑되기 때문에, 상기 데이터는 버스트 모드 명령어로 처리될 수 있다. 순차적인 주소란 메모리 셀 어레이의 행과 열의 주소가 순차적으로 증가한다는 것을 의미할 수 있다. 즉, AMC는 ANN 데이터 지역성 정보(ANN DL)를 기초로 NPU가 요청하기 전에 필요한 데이터를 캐싱 할 수 있고, 모든 요청 순서를 파악할 수 있다. 따라서, AMC의 버퍼 메모리의 캐쉬 히트 확률은 이론적으로 100%가 되는 것 도 가능하다. 또한 ANN 데이터 지역성 정보(ANN DL)를 기초로 메인 메모리의 메모리 맵이 설정되기 때문에 모든 메모리 오퍼 레이션이 버스트 모드로 동작하는 것도 가능하다. 도 29에서는 단일 메모리 뱅크가 예시적으로 나타나 있지만, 메모리의 뱅크, 랭크, 채널의 구성에 따라 주소 매 핑은 뱅크 인터리빙(bank interleaving) 방식으로 수행될 수도 있다. 만약, ANN 데이터 지역성 정보(ANN DL)가 없다면, DRAM에는 NPU가 요청할 데이터를 순차적으로 저장하는 것이 실질적으로 불가능하다. 즉, 도 23에 도시된 인공신경망모델 정보가 있다고 하더라도, 다양한 예시들에서 설명 한 ANN 데이터 지역성 정보(ANN DL)가 없다면, NPU가 메인 메모리에 요청할 데이터 오퍼레이션의 모든 순서를 모두 알 수가 없다. 만약 AMC가 ANN 데이터 지역성 정보(ANN DL)를 가지고 있지 않다면, AMC 입장에서 NPU가 인공신경망모델의 제1 레이어의 커널을 먼저 요청할지 또는 입력 특징맵을 먼저 요청할지 알기 어렵다. 따라서, 메인 메모리에 버스트 모드를 고려한 메모리 맵을 설정하는 것이 실질적으로 어렵게 된다. 도 30은 ANN 데이터 지역성 정보에 기초하여 메인 메모리의 주소를 매핑하는 방식의 일 예를 나타낸 예시도이다. 도 30에 도시된 메인 메모리의 구조는 도 29에 도시된 메인 메모리와 실질적으로 동일하므로, 중복 설명은 생략 한다. 도 30을 참조하면 ANN 데이터 지역성 정보(ANN DL)를 기초로 DRAM의 메모리 셀에 NPU가 요청할 데이터의 순서와 크기를 고려하여 메모리 맵을 설정할 수 있다. 상기 메모리 맵은 각 데이터 사이즈를 기초로 시작 주소와 끝 주 소를 기초로 설정될 수 있다. 따라서 DRAM에서 ANN 데이터 지역성 정보(ANN DL) 순서대로 메모리 오퍼레이션을 수행하면, 모든 메모리 오퍼레이션이 버스트 모드로 동작 가능해질 수 있다. 따라서 도 30에 도시된 메인 메모리는 표 3에 나타난 메모리 주소와 동작 모드에 기초하여 제어될 수 있다. 도 30 및 표 3에 대응되는 ANN 데이터 지역성 정보(ANN DL)는 NPU가 입력 특징맵과 출력 특징맵을 공용으로 사 용하도록 설정된 경우의 예시이다. 표 3 레이어 이 름시작 주소 끝 주소 동작 모드 도메인 ANN DL 크기 (Byte) 1 0 M_FMAP=A' Read-Burst IFMAP 1 M_FMAP 1 A'+1 A'+1+B=B' Read-Burst Kernel 2 B 1 0 C Write-Burst OFMAP 3 C 2 0 C Read-Burst IFMAP 4 C 2 B'+1 B'+1+D=D' Read-Burst Kernel 5 D 2 0 E Write-Burst OFMAP 6 E 3 0 E Read-Burst IFMAP 7 E 3 D'+1 D'+1+F=F' Read-Burst Kernel 8 F 3 0 G Write-Burst OFMAP 9 G 4 0 G Read-Burst IFMAP 10 G 4 F'+1 F'+1+H=H' Read-Burst Kernel 11 H 4 0 I Write-Burst OFMAP 12 I 5 0 I Read-Burst IFMAP 13 I 5 H'+1 H'+1+J=J' Read-Burst Kernel 14 J 5 0 K Write-Burst OFMAP 15 K 커널은 인공신경망모델의 학습이 완료된 경우 그 값이 고정된다. 따라서 커널의 값은 고정된 특성을 가진다. 이 에 반해서 입력 특징맵과 출력 특징맵은 영상 데이터, 카메라, 마이크, 레이더, 라이다 등의 입력이기 때문에한번 사용되면 더 이상 재사용되지 않을 수 있다.도 23을 예를 들어 참조하면, 인공신경망모델의 입력 특징맵 과 출력 특징맵의 크기가 정의되어 있다. 따라서 상기 인공신경망모델의 입력 특징맵과 출력 특징맵 중 가장 큰 데이터 크기(M_FMAP)를 선택할 수 있다. 도 23의 인공신경망모델의 경우 최대 크기의 특징맵(M_FMAP)은 802,816 Byte 이다. 따라서 표 3의 인공신경망모델의 각 레이어의 입력 특징맵과 출력 특징맵들은 동일한 시작 주소를 가지도록 설정된다. 즉, 입력 특징맵과 출력 특징맵은 동일한 메모리 주소에 덮어쓰기 형식으로 동작할 수 있다. 상술하였듯이, 인공신경망모델의 특성 상, 입력 특징맵과 커널을 합성곱 연산하면 출력 특징맵이 생성되 고, 해당 출력 특징맵은 다음 레이어의 입력 특징맵이 된다. 따라서 이전 레이어의 특징맵은 재사용되지 않으며, 삭제 되어도 무방할 수 있다. 상술한 구성에 따르면, 최대 특징맵을 기준으로 설정된 메모리 영역을 입력 특징맵과 출력 특징맵의 공용 영역 으로 설정함으로 써, 메인 메모리의 메모리 맵의 크기를 저감할 수 있다. 이하 표 4를 참조하여 본 개시의 일 예시를 설명한다. 표 4는 ANN 데이터 지역성 정보(ANN DL)에 기초하여 NPU가 요청할 메모리 오퍼레이션 순서에 따라서 커널, 입력 특징맵 및 출력 특징맵이 메인 메모리 내에 특정 주소의 메모리 맵을 이용하여 저장되어 있는 예를 나타낸다. 표 4는 표 3 및 도 30의 예시와 실질적으로 동일한 방식을 사용한 예시로, eh 23에 도시된 인공신경망모델의 인 공신경망 데이터 지역성 정보에 따라 메모리 맵을 설정하는 예시이다. 아래의 표에 따르면, 입력 특징맵이 상기 메인 메모리로부터 먼저 읽어진 후, 그 다음 커널이 읽어지고 합성곱 이 수행된 후, 출력 특징맵이 상기 메인 메모리에 저장된다. NPU의 데이터 요청 순서는 상기 ANN 데이터 지역성 정보(ANN DL)에 기초하여 정해질 수 있다. AMC는 상기 ANN 데이터 지역성 정보(ANN DL)를 기초로, NPU가 요청할 데이터를 연속되게 DRAM에 정렬한다. 따라서 상기 NPU는 버스트 읽기 및 쓰기 동작을 효과적으로 수행할 수 있 게 된다. 표 4에 정의된 메모리 맵의 인공신경망모델은 ANN 데이터 지역성 정보(ANN DL) 1 부터 84 까지의 메모리 오퍼레 이션이 완료되면 상기 인공신경망모델의 추론 결과를 생성할 수 있다. 표 4 레이어 시작 주소 끝 주소 동작 모드 도메인ANN DL크기 (Byte) 1 0x000000 0x024C00 Read-Burst IFMAP 1 150,528 1 0x024C01 0x024F60 Read-Burst Kernel 2 864 1 0x024F61 0x086F60 Write-Burst OFMAP 3 401,408 2 0x024F61 0x086F60 Read-Burst IFMAP 4 401,408 2 0x086F61 0x087080 Read-Burst Kernel 5 288 2 0x087081 0x0E9080 Write-Burst OFMAP 6 401,408 3 0x087081 0x0E9080 Read-Burst IFMAP 7 401,408 3 0x0E9081 0x0E9880 Read-Burst Kernel 8 2,048 3 0x0E9881 0x1AD880 Write-Burst OFMAP 9 802,816 4 0x0E9881 0x1AD880 Read-Burst IFMAP 10802,816 4 0x1AD881 0x1ADAC0 Read-Burst Kernel 11 576 4 0x1ADAC1 0x1DEAC0 Write-Burst OFMAP 12200,704 5 0x1ADAC1 0x1DEAC0 Read-Burst IFMAP 13200,704 5 0x1DEAC1 0x1E0AC0 Read-Burst Kernel 14 8,192 5 0x1E0AC1 0x242AC0 Write-Burst OFMAP 15401,408 6 0x1E0AC1 0x242AC0 Read-Burst IFMAP 16401,408 6 0x242AC1 0x242F40 Read-Burst Kernel 17 1,152 6 0x242F41 0x2A4F40 Write-Burst OFMAP 18401,408 7 0x242F41 0x2A4F40 Read-Burst IFMAP 19401,408 7 0x2A4F41 0x2A8F40 Read-Burst Kernel 20 16,384 7 0x2A8F41 0x30AF40 Write-Burst OFMAP 21401,408 8 0x2A8F41 0x30AF40 Read-Burst IFMAP 22401,408 8 0x30AF41 0x30B3C0 Read-Burst Kernel 23 1,152 8 0x30B3C1 0x323BC0 Write-Burst OFMAP 24100,352 9 0x30B3C1 0x323BC0 Read-Burst IFMAP 25100,352 9 0x323BC1 0x32BBC0 Read-Burst Kernel 26 32,7689 0x32BBC1 0x35CBC0 Write-Burst OFMAP 27200,704 10 0x32BBC1 0x35CBC0 Read-Burst IFMAP 28200,704 10 0x35CBC1 0x35D4C0 Read-Burst Kernel 29 2,304 10 0x35D4C1 0x38E4C0 Write-Burst OFMAP 30200,704 11 0x35D4C1 0x38E4C0 Read-Burst IFMAP 31200,704 11 0x38E4C1 0x39E4C0 Read-Burst Kernel 32 65,536 11 0x39E4C1 0x3CF4C0 Write-Burst OFMAP 33200,704 12 0x39E4C1 0x3CF4C0 Read-Burst IFMAP 34200,704 12 0x3CF4C1 0x3CFDC0 Read-Burst Kernel 35 2,304 12 0x3CFDC1 0x3DC1C0 Write-Burst OFMAP 36 50,176 13 0x3CFDC1 0x3DC1C0 Read-Burst IFMAP 37 50,176 13 0x3DC1C1 0x3FC1C0 Read-Burst Kernel 38131,072 13 0x3FC1C1 0x4149C0 Write-Burst OFMAP 39100,352 14 0x3FC1C1 0x4149C0 Read-Burst IFMAP 40100,352 14 0x4149C1 0x415BC0 Read-Burst Kernel 41 4,608 14 0x415BC1 0x42E3C0 Write-Burst OFMAP 42100,352 15 0x415BC1 0x42E3C0 Read-Burst IFMAP 43100,352 15 0x42E3C1 0x46E3C0 Read-Burst Kernel 44262,144 15 0x46E3C1 0x486BC0 Write-Burst OFMAP 45100,352 16 0x46E3C1 0x486BC0 Read-Burst IFMAP 46100,352 16 0x486BC1 0x487DC0 Read-Burst Kernel 47 4,608 16 0x487DC1 0x4A05C0 Write-Burst OFMAP 48100,352 17 0x487DC1 0x4A05C0 Read-Burst IFMAP 49100,352 17 0x4A05C1 0x4E05C0 Read-Burst Kernel 50262,144 17 0x4E05C1 0x4F8DC0 Write-Burst OFMAP 51100,352 18 0x4E05C1 0x4F8DC0 Read-Burst IFMAP 52100,352 18 0x4F8DC1 0x4F9FC0 Read-Burst Kernel 53 4,608 18 0x4F9FC1 0x5127C0 Write-Burst OFMAP 54100,352 19 0x4F9FC1 0x5127C0 Read-Burst IFMAP 55100,352 19 0x5127C1 0x5527C0 Read-Burst Kernel 56262,144 19 0x5527C1 0x56AFC0 Write-Burst OFMAP 57100,352 20 0x5527C1 0x56AFC0 Read-Burst IFMAP 58100,352 20 0x56AFC1 0x56C1C0 Read-Burst Kernel 59 4,608 20 0x56C1C1 0x5849C0 Write-Burst OFMAP 60100,352 21 0x56C1C1 0x5849C0 Read-Burst IFMAP 61100,352 21 0x5849C1 0x5C49C0 Read-Burst Kernel 62262,144 21 0x5C49C1 0x5DD1C0 Write-Burst OFMAP 63100,352 22 0x5C49C1 0x5DD1C0 Read-Burst IFMAP 64100,352 22 0x5DD1C1 0x5DE3C0 Read-Burst Kernel 65 4,608 22 0x5DE3C1 0x5F6BC0 Write-Burst OFMAP 66100,352 23 0x5DE3C1 0x5F6BC0 Read-Burst IFMAP 67100,352 23 0x5F6BC1 0x636BC0 Read-Burst Kernel 68262,144 23 0x636BC1 0x64F3C0 Write-Burst OFMAP 69100,352 24 0x636BC1 0x64F3C0 Read-Burst IFMAP 70100,352 24 0x64F3C1 0x6505C0 Read-Burst Kernel 71 4,608 24 0x6505C1 0x6567C0 Write-Burst OFMAP 72 25,088 25 0x6505C1 0x6567C0 Read-Burst IFMAP 73 25,088 25 0x6567C1 0x6D67C0 Read-Burst Kernel 74524,288 25 0x6D67C1 0x6E2BC0 Write-Burst OFMAP 75 50,176 26 0x6D67C1 0x6E2BC0 Read-Burst IFMAP 76 50,176 26 0x6E2BC1 0x6E4FC0 Read-Burst Kernel 77 9,216 26 0x6E4FC1 0x6F13C0 Write-Burst OFMAP 78 50,176 27 0x6E4FC1 0x6F13C0 Read-Burst IFMAP 79 50,176 27 0x6F13C1 0x7F13C0 Read-Burst Kernel 801,048,576 27 0x7F13C1 0x7F17C0 Write-Burst OFMAP 81 1,024 28 0x7F13C1 0x7F17C0 Read-Burst IFMAP 82 1,024 28 0x7F17C1 0x8EB7C0 Read-Burst Kernel 831,024,000 28 0x8EB7C1 0x8EBBA8 Write-Burst OFMAP 84 1,000이하 표 5를 참조하여 본 개시의 일 예시를 설명한다.표 5는 ANN 데이터 지역성 정보(ANN DL)에 기초하여 NPU가 요청할 메모리 오퍼레이션 순서에 따라서 커널, 입력 특징맵 및 출력 특징맵이 메인 메모리 내에 특정 주소의 메모리 맵을 이용하여 저장되어 있는 예를 나타낸다. 아래의 표에 따르면, 커널이 상기 메인 메모리로부터 먼저 읽어진 후, 그 다음 입력 특징맵이 읽어지고 합성곱 이 수행된 후, 출력 특징맵이 상기 메인 메모리에 저장된다. NPU의 데이터 요청 순서는 상기 ANN 데이터 지역성 정보(ANN DL)에 기초하여 정해질 수 있다. AMC는 상기 ANN 데이터 지역성 정보(ANN DL)를 분석하고, NPU가 요청 할 데이터를 연속되게 정렬한다. 따라서 상기 NPU는 버스트 읽기 및 쓰기 동작을 효과적으로 수행할 수 있도록 한다. 표 5에 정의된 메모리 맵의 인공신경망모델은 ANN 데이터 지역성 정보(ANN DL) 1 부터 84 까지의 메모리 오퍼레 이션이 완료되면 상기 인공신경망모델의 추론 결과를 생성할 수 있다. 표 5 레이어 시작 주소 끝 주소 동작 모드 도메인ANN DL 크기 (Byte) 1 0x000000 0x000360 Read-Burst Kernel 1 864 1 0x000361 0x024F60 Read-Burst IFMAP 2 150,528 1 0x024F61 0x086F60 Write-Burst OFMAP 3 401,408 2 0x086F61 0x087080 Read-Burst Kernel 4 288 2 0x024F61 0x086F60 Read-Burst IFMAP 5 401,408 2 0x087081 0x0E9080 Write-Burst OFMAP 6 401,408 3 0x0E9081 0x0E9880 Read-Burst Kernel 7 2,048 3 0x087081 0x0E9080 Read-Burst IFMAP 8 401,408 3 0x0E9881 0x1AD880 Write-Burst OFMAP 9 802,816 4 0x1AD881 0x1ADAC0 Read-Burst Kernel 10 576 4 0x0E9881 0x1AD880 Read-Burst IFMAP 11 802,816 4 0x1ADAC1 0x1DEAC0 Write-Burst OFMAP 12 200,704 5 0x1DEAC1 0x1E0AC0 Read-Burst Kernel 13 8,192 5 0x1ADAC1 0x1DEAC0 Read-Burst IFMAP 14 200,704 5 0x1E0AC1 0x242AC0 Write-Burst OFMAP 15 401,408 6 0x242AC1 0x242F40 Read-Burst Kernel 16 1,152 6 0x1E0AC1 0x242AC0 Read-Burst IFMAP 17 401,408 6 0x242F41 0x2A4F40 Write-Burst OFMAP 18 401,408 7 0x2A4F41 0x2A8F40 Read-Burst Kernel 19 16,384 7 0x242F41 0x2A4F40 Read-Burst IFMAP 20 401,408 7 0x2A8F41 0x30AF40 Write-Burst OFMAP 21 401,408 8 0x30AF41 0x30B3C0 Read-Burst Kernel 22 1,152 8 0x2A8F41 0x30AF40 Read-Burst IFMAP 23 401,408 8 0x30B3C1 0x323BC0 Write-Burst OFMAP 24 100,352 9 0x323BC1 0x32BBC0 Read-Burst Kernel 25 32,768 9 0x30B3C1 0x323BC0 Read-Burst IFMAP 26 100,352 9 0x32BBC1 0x35CBC0 Write-Burst OFMAP 27 200,704 10 0x35CBC1 0x35D4C0 Read-Burst Kernel 28 2,304 10 0x32BBC1 0x35CBC0 Read-Burst IFMAP 29 200,704 10 0x35D4C1 0x38E4C0 Write-Burst OFMAP 30 200,704 11 0x38E4C1 0x39E4C0 Read-Burst Kernel 31 65,536 11 0x35D4C1 0x38E4C0 Read-Burst IFMAP 32 200,704 11 0x39E4C1 0x3CF4C0 Write-Burst OFMAP 33 200,704 12 0x3CF4C1 0x3CFDC0 Read-Burst Kernel 34 2,304 12 0x39E4C1 0x3CF4C0 Read-Burst IFMAP 35 200,704 12 0x3CFDC1 0x3DC1C0 Write-Burst OFMAP 36 50,176 13 0x3DC1C1 0x3FC1C0 Read-Burst Kernel 37 131,072 13 0x3CFDC1 0x3DC1C0 Read-Burst IFMAP 38 50,176 13 0x3FC1C1 0x4149C0 Write-Burst OFMAP 39 100,352 14 0x4149C1 0x415BC0 Read-Burst Kernel 40 4,60814 0x3FC1C1 0x4149C0 Read-Burst IFMAP 41 100,352 14 0x415BC1 0x42E3C0 Write-Burst OFMAP 42 100,352 15 0x42E3C1 0x46E3C0 Read-Burst Kernel 43 262,144 15 0x415BC1 0x42E3C0 Read-Burst IFMAP 44 100,352 15 0x46E3C1 0x486BC0 Write-Burst OFMAP 45 100,352 16 0x486BC1 0x487DC0 Read-Burst Kernel 46 4,608 16 0x46E3C1 0x486BC0 Read-Burst IFMAP 47 100,352 16 0x487DC1 0x4A05C0 Write-Burst OFMAP 48 100,352 17 0x4A05C1 0x4E05C0 Read-Burst Kernel 49 262,144 17 0x487DC1 0x4A05C0 Read-Burst IFMAP 50 100,352 17 0x4E05C1 0x4F8DC0 Write-Burst OFMAP 51 100,352 18 0x4F8DC1 0x4F9FC0 Read-Burst Kernel 52 4,608 18 0x4E05C1 0x4F8DC0 Read-Burst IFMAP 53 100,352 18 0x4F9FC1 0x5127C0 Write-Burst OFMAP 54 100,352 19 0x5127C1 0x5527C0 Read-Burst Kernel 55 262,144 19 0x4F9FC1 0x5127C0 Read-Burst IFMAP 56 100,352 19 0x5527C1 0x56AFC0 Write-Burst OFMAP 57 100,352 20 0x56AFC1 0x56C1C0 Read-Burst Kernel 58 4,608 20 0x5527C1 0x56AFC0 Read-Burst IFMAP 59 100,352 20 0x56C1C1 0x5849C0 Write-Burst OFMAP 60 100,352 21 0x5849C1 0x5C49C0 Read-Burst Kernel 61 262,144 21 0x56C1C1 0x5849C0 Read-Burst IFMAP 62 100,352 21 0x5C49C1 0x5DD1C0 Write-Burst OFMAP 63 100,352 22 0x5DD1C1 0x5DE3C0 Read-Burst Kernel 64 4,608 22 0x5C49C1 0x5DD1C0 Read-Burst IFMAP 65 100,352 22 0x5DE3C1 0x5F6BC0 Write-Burst OFMAP 66 100,352 23 0x5F6BC1 0x636BC0 Read-Burst Kernel 67 262,144 23 0x5DE3C1 0x5F6BC0 Read-Burst IFMAP 68 100,352 23 0x636BC1 0x64F3C0 Write-Burst OFMAP 69 100,352 24 0x64F3C1 0x6505C0 Read-Burst Kernel 70 4,608 24 0x636BC1 0x64F3C0 Read-Burst IFMAP 71 100,352 24 0x6505C1 0x6567C0 Write-Burst OFMAP 72 25,088 25 0x6567C1 0x6D67C0 Read-Burst Kernel 73 524,288 25 0x6505C1 0x6567C0 Read-Burst IFMAP 74 25,088 25 0x6D67C1 0x6E2BC0 Write-Burst OFMAP 75 50,176 26 0x6E2BC1 0x6E4FC0 Read-Burst Kernel 76 9,216 26 0x6D67C1 0x6E2BC0 Read-Burst IFMAP 77 50,176 26 0x6E4FC1 0x6F13C0 Write-Burst OFMAP 78 50,176 27 0x6F13C1 0x7F13C0 Read-Burst Kernel 791,048,576 27 0x6E4FC1 0x6F13C0 Read-Burst IFMAP 80 50,176 27 0x7F13C1 0x7F17C0 Write-Burst OFMAP 81 1,024 28 0x7F17C1 0x8EB7C0 Read-Burst Kernel 821,024,000 28 0x7F13C1 0x7F17C0 Read-Burst IFMAP 83 1,024 28 0x8EB7C1 0x8EBBA8 Write-Burst OFMAP 84 1,000 이하 표 6을 참조하여 본 개시의 일 예시를 설명한다.표 6은 ANN 데이터 지역성 정보(ANN DL)에 기초하여 NPU가 요청할 메모리 오퍼레이션 순서에 따라서 커널, 특징맵 및 출력 특징맵이 메인 메모리 내에 특정 주소의 메모리 맵을 이용하여 저장되어 있는 예를 나타낸다. 표 6은 표 3 및 도 30의 예시와 실질적으로 동일한 방식을 사용한 예시로, eh 23에 도시된 인공신경망모델의 인 공신경망 데이터 지역성 정보에 따라 메모리 맵을 설정하는 예시이다. 아래의 표에 따르면, 입력 특징맵이 상기 메인 메모리로부터 먼저 읽어진 후, 그 다음 커널이 읽히고 합성곱이 수행된 후, 출력 특징맵이 상기 메인 메모리에 저장된다. NPU의 데이터 요청 순서는 상기 ANN 데이터 지역성 정 보(ANN DL)에 기초하여 정해질 수 있다. AMC는 상기 ANN 데이터 지역성 정보(ANN DL)를 분석하고, NPU가 요청할 데이터를 연속되게 정렬한다. 따라서 상기 NPU가 버스트 읽기 및 쓰기 동작을 수행할 수 있도록 한다. AMC는 버스트 동작이 가능하도록, 상기 메인 메모리의 주소 할당을 제어한다. 아래의 표 5에서는 데이터 크기가 가장 큰 특징맵에 기초하여, 모든 레이어의 입력 특징맵 및 출력 특징맵을 덮어쓰는 공용 메모리 영역이 할당된 다. 해당 영역 내에서 각 레이어별 합성곱 결과가 갱신된다. 따라서, 상기 공용 메모리 영역의 시작 주소가 동 일하더라도, 특징 맵의 크기에 따라서 끝 주소가 변경될 수 있다. 표 6 레이어 시작 주소 끝 주소 동작 모드 도메인ANN DL크기 (Byte) 1 0x000000 0x0C4000 Read-Burst IFMAP 1 802,816 1 0x0C4001 0x0C4360 Read-Burst Kernel 2 864 1 0x000000 0x062000 Write-Burst OFMAP 3 401,408 2 0x000000 0x062000 Read-Burst IFMAP 4 401,408 2 0x0C4361 0x0C4480 Read-Burst Kernel 5 288 2 0x000000 0x062000 Write-Burst OFMAP 6 401,408 3 0x000000 0x062000 Read-Burst IFMAP 7 401,408 3 0x0C4481 0x0C4C80 Read-Burst Kernel 8 2,048 3 0x000000 0x0C4000 Write-Burst OFMAP 9 802,816 4 0x000000 0x0C4000 Read-Burst IFMAP 10 802,816 4 0x0C4C81 0x0C4EC0 Read-Burst Kernel 11 576 4 0x000000 0x031000 Write-Burst OFMAP 12 200,704 5 0x000000 0x031000 Read-Burst IFMAP 13 200,704 5 0x0C4EC1 0x0C6EC0 Read-Burst Kernel 14 8,192 5 0x000000 0x062000 Write-Burst OFMAP 15 401,408 6 0x000000 0x062000 Read-Burst IFMAP 16 401,408 6 0x0C6EC1 0x0C7340 Read-Burst Kernel 17 1,152 6 0x000000 0x062000 Write-Burst OFMAP 18 401,408 7 0x000000 0x062000 Read-Burst IFMAP 19 401,408 7 0x0C7341 0x0CB340 Read-Burst Kernel 20 16,384 7 0x000000 0x062000 Write-Burst OFMAP 21 401,408 8 0x000000 0x062000 Read-Burst IFMAP 22 401,408 8 0x0CB341 0x0CB7C0 Read-Burst Kernel 23 1,152 8 0x000000 0x018800 Write-Burst OFMAP 24 100,352 9 0x000000 0x018800 Read-Burst IFMAP 25 100,352 9 0x0CB7C1 0x0D37C0 Read-Burst Kernel 26 32,768 9 0x000000 0x031000 Write-Burst OFMAP 27 200,704 10 0x000000 0x031000 Read-Burst IFMAP 28 200,704 10 0x0D37C1 0x0D40C0 Read-Burst Kernel 29 2,304 10 0x000000 0x031000 Write-Burst OFMAP 30 200,704 11 0x000000 0x031000 Read-Burst IFMAP 31 200,704 11 0x0D40C1 0x0E40C0 Read-Burst Kernel 32 65,536 11 0x000000 0x031000 Write-Burst OFMAP 33 200,704 12 0x000000 0x031000 Read-Burst IFMAP 34 200,704 12 0x0E40C1 0x0E49C0 Read-Burst Kernel 35 2,304 12 0x000000 0x00C400 Write-Burst OFMAP 36 50,176 13 0x000000 0x00C400 Read-Burst IFMAP 37 50,176 13 0x0E49C1 0x1049C0 Read-Burst Kernel 38 131,072 13 0x000000 0x018800 Write-Burst OFMAP 39 100,352 14 0x000000 0x018800 Read-Burst IFMAP 40 100,352 14 0x1049C1 0x105BC0 Read-Burst Kernel 41 4,608 14 0x000000 0x018800 Write-Burst OFMAP 42 100,352 15 0x000000 0x018800 Read-Burst IFMAP 43 100,352 15 0x105BC1 0x145BC0 Read-Burst Kernel 44 262,144 15 0x000000 0x018800 Write-Burst OFMAP 45 100,352 16 0x000000 0x018800 Read-Burst IFMAP 46 100,352 16 0x145BC1 0x146DC0 Read-Burst Kernel 47 4,608 16 0x000000 0x018800 Write-Burst OFMAP 48 100,352 17 0x000000 0x018800 Read-Burst IFMAP 49 100,352 17 0x146DC1 0x186DC0 Read-Burst Kernel 50 262,14417 0x000000 0x018800 Write-Burst OFMAP 51 100,352 18 0x000000 0x018800 Read-Burst IFMAP 52 100,352 18 0x186DC1 0x187FC0 Read-Burst Kernel 53 4,608 18 0x000000 0x018800 Write-Burst OFMAP 54 100,352 19 0x000000 0x018800 Read-Burst IFMAP 55 100,352 19 0x187FC1 0x1C7FC0 Read-Burst Kernel 56 262,144 19 0x000000 0x018800 Write-Burst OFMAP 57 100,352 20 0x000000 0x018800 Read-Burst IFMAP 58 100,352 20 0x1C7FC1 0x1C91C0 Read-Burst Kernel 59 4,608 20 0x000000 0x018800 Write-Burst OFMAP 60 100,352 21 0x000000 0x018800 Read-Burst IFMAP 61 100,352 21 0x1C91C1 0x2091C0 Read-Burst Kernel 62 262,144 21 0x000000 0x018800 Write-Burst OFMAP 63 100,352 22 0x000000 0x018800 Read-Burst IFMAP 64 100,352 22 0x2091C1 0x20A3C0 Read-Burst Kernel 65 4,608 22 0x000000 0x018800 Write-Burst OFMAP 66 100,352 23 0x000000 0x018800 Read-Burst IFMAP 67 100,352 23 0x20A3C1 0x24A3C0 Read-Burst Kernel 68 262,144 23 0x000000 0x018800 Write-Burst OFMAP 69 100,352 24 0x000000 0x018800 Read-Burst IFMAP 70 100,352 24 0x24A3C1 0x24B5C0 Read-Burst Kernel 71 4,608 24 0x000000 0x006200 Write-Burst OFMAP 72 25,088 25 0x000000 0x006200 Read-Burst IFMAP 73 25,088 25 0x24B5C1 0x2CB5C0 Read-Burst Kernel 74 524,288 25 0x000000 0x00C400 Write-Burst OFMAP 75 50,176 26 0x000000 0x00C400 Read-Burst IFMAP 76 50,176 26 0x2CB5C1 0x2CD9C0 Read-Burst Kernel 77 9,216 26 0x000000 0x00C400 Write-Burst OFMAP 78 50,176 27 0x000000 0x00C400 Read-Burst IFMAP 79 50,176 27 0x2CD9C1 0x3CD9C0 Read-Burst Kernel 801,048,576 27 0x000000 0x000400 Write-Burst OFMAP 81 1,024 28 0x000000 0x000400 Read-Burst IFMAP 82 1,024 28 0x3CD9C1 0x4C79C0 Read-Burst Kernel 831,024,000 28 0x000000 0x0003E8 Write-Burst OFMAP 84 1,000 표 7은 메인 메모리에 저장되어 있는 커널 도메인을 위한 메모리 맵을 나타낸다. 표 8은 메인 메모리에 저장되 어 있는 입력 특징맵 도메인을 위한 메모리 맵을 나타낸다. 표 9는 메인 메모리에 저장되어 있는 출력 특징맵 도메인을 위한 메모리 맵을 나타낸다. 표 7 내지 표 9의 주소 순서를 보면, 커널 도메인을 순차적으로 저장하고, 입력 특징맵 도메인을 순차적으로 저 장하고, 출력 특징맵 도메인을 순차적으로 저장하는 방식으로 메인 메모리의 메모리 맵을 설정하는 것도 가능하 다. ANN 데이터 지역성 정보(ANN DL)는 각각의 도메인에 대응되는 메모리 맵을 설정하고, 기 설정된 순서로 특정 도 메인의 메모리 오퍼레이션을 수행하도록 구성될 수 있다. 예를 들면, ANN 데이터 지역성 정보(ANN DL)는 커널 도메인, 입력 특징맵 도메인, 및 출력 특징맵 도메인 순으 로 설정될 수 있다. 예를 들면, ANN 데이터 지역성 정보(ANN DL)는 입력 특징맵 도메인, 커널 도메인, 및 출력 특징맵 도메인 순으 로 설정될 수 있다. AMC는 상기 메인 메모리가 버스트 모드로 동작하도록, 각 도메인별 메모리 주소를 할당 및 관리할 수 있다. 상기 NPU의 데이터 요청 순서는 ANN 데이터 지역성 정보(ANN DL)에 기초하여 정해질 수 있다. 표 7 내지 표 9의 설명을 위해서 도 15a, 도18, 도 19, 도 20, 도 21, 및 도 22의 제1 내부 메모리 내지 제3 내부 메모리를 참조할 수 있다.SoC 또는 NPU는 제1 내부 메모리, 제2 내부 메모리, 및 제3 내부 메모리를 포함하도록 구성될 수 있다. 제1 내 부 메모리는 커널 도메인에 대응될 수 있다. 제2 내부 메모리는 입력 특징맵 도메인에 대응될 수 있다. 제3 내 부 메모리는 출력 특징맵 도메인에 대응될 수 있다. 제1 내부 메모리를 예시로 설명한다. 예를 들면, 제1 내부 메모리의 크기는 1.5 Mbyte일 수 있다. 표 7을 참조 하면, 커널(Kernel) 도메인에서 가장 큰 데이터의 크기는 1,024,000 byte이다. 따라서 타일링이 불필요할 수 있 다. 제2 내부 메모리를 예시로 설명한다. 예를 들면, 제2 내부 메모리의 크기는 0.5 Mbyte일 수 있다. 표 8을 참조 하면, 입력 특징맵(IFMAP) 도메인에서 가장 큰 데이터는 802,816 byte이다. 따라서 타일링이 필요할 수 있다. 표 8의 입력 특징맵(IFMAP) 도메인의 제1 레이어 및 제4 레이어에 해당하는 인공신경망 데이터 지역성(ANN DL) 을 참조하면, 각각의 레이어는 2개의 타일로 분리될 수 있다. 예를 들면, 제1 레이어 및 제4 레이어는 401,408 byte인 제1 타일(In-1-1), 제2 타일(In-1-2), 제3 타일(In-4-1) 및 제4 타일(In-4-2)로 분리될 수 있다. 따라 서 제2 내부 메모리의 크기가 0.5 Mbyte의 경우에도 메모리 오버 플로우가 방지될 수 있다. 부연 설명하면, 표 6의 예시는 타일링이 없는 경우로써, 제1 레이어 및 제4 레이어의 입력 특징맵(IFMAP)의 각각의 크기는 타일링 안된 802,816 byte를 설명하고 있다. 표 6의 경우, 제2 내부 메모리의 크기가 입력 특징맵 도메인의 최대 데이 터 크기보다 더 클 수 있으며, 이러한 경우는 타일링이 불필요 할 수 있다. 제3 내부 메모리를 예시로 설명한다. 예를 들면, 제3 내부 메모리의 크기는 1 Mbyte일 수 있다. 표 9을 참조하 면, 출력 특징맵(OFMAP) 도메인에서 가장 큰 데이터의 크기는 1,024,000 byte이다. 따라서 타일링이 불필요할 수 있다. 부연 설명하면, 상기 타일링(tiling)의 기준은 AMC의 버퍼 메모리 기준 또는 NPU 내부 메모리 기준에 따라 달라 질 수 있다. 입력 특징맵의 크기 나누기 레이어 번호의 입력 특징맵 메모리 크기를 나눈 값에 따라, 입력 특징맵의 타일링 개수가 결정될 수 있다. 표 7 내지 표 9의 예시에서는, 데이터 크기가 가장 큰 특징맵의 데이터 크기 만큼의 메모리 영역이 설정되고, 해당 영역 내에서 각 레이어 별 합성곱 결과가 갱신된다. 이에 따라, ANN 데이터 지역성 정보(ANN DL)가 갱신될 수 있다. 특징맵의 크기에 따라, 메모리 내의 마지막 주소(end address)가 바뀔 수 있다. 예컨대, 최대로 고정된 영역 내 에만 마지막 주소(end address)가 바뀔 수 있다. 사이가 작은 가중치들은 복수개를 버스트로 한번에 AMC 내의 캐쉬 메모리에 캐싱할 수도 있다. 예) 최대 버스트 길이 = 16Kb일 경우 (K-1 ~ K-6)가 총 13Kb이며, 버스트로 한번에 AMC 내의 캐쉬 메모리에 캐 싱할 수 있다. 이러한 경우, AMC는 (K-1 ~ K-6)까지는 메인 메모리에 (In-1 ~ In-6)만 요청할 수 있다. 표 7 레이어 시작 주소 끝 주소 동작 모드 도메인ANN DL크기 (Byte) 1 0x000000 0x000360 Read-Burst KernelK-1 864 2 0x000361 0x000480 Read-Burst KernelK-2 288 3 0x000481 0x000C80 Read-Burst KernelK-3 2,048 4 0x000C81 0x000EC0 Read-Burst KernelK-4 576 5 0x000EC1 0x002EC0 Read-Burst KernelK-5 8,192 6 0x002EC1 0x003340 Read-Burst KernelK-6 1,152 7 0x003341 0x007340 Read-Burst KernelK-7 16,384 8 0x007341 0x0077C0 Read-Burst KernelK-8 1,152 9 0x0077C1 0x00F7C0 Read-Burst KernelK-9 32,768 10 0x00F7C1 0x0100C0 Read-Burst KernelK-10 2,304 11 0x0100C1 0x0200C0 Read-Burst KernelK-1165,536 12 0x0200C1 0x0209C0 Read-Burst KernelK-12 2,304 13 0x0209C1 0x0409C0 Read-Burst KernelK-13131,072 14 0x0409C1 0x041BC0 Read-Burst KernelK-14 4,60815 0x041BC1 0x081BC0 Read-Burst KernelK-15262,144 16 0x081BC1 0x082DC0 Read-Burst KernelK-16 4,608 17 0x082DC1 0x0C2DC0 Read-Burst KernelK-17262,144 18 0x0C2DC1 0x0C3FC0 Read-Burst KernelK-18 4,608 19 0x0C3FC1 0x103FC0 Read-Burst KernelK-19262,144 20 0x103FC1 0x1051C0 Read-Burst KernelK-20 4,608 21 0x1051C1 0x1451C0 Read-Burst KernelK-21262,144 22 0x1451C1 0x1463C0 Read-Burst KernelK-22 4,608 23 0x1463C1 0x1863C0 Read-Burst KernelK-23262,144 24 0x1863C1 0x1875C0 Read-Burst KernelK-24 4,608 25 0x1875C1 0x2075C0 Read-Burst KernelK-25524,288 26 0x2075C1 0x2099C0 Read-Burst KernelK-26 9,216 27 0x2099C1 0x3099C0 Read-Burst KernelK-271,048,576 28 0x3099C1 0x4039C0 Read-Burst KernelK-281,024,000 표 8 레이어 시작 주소 끝 주소 동작 모드 도메인 ANN DL 크기 (Byte) 1 0x4039C1 0x4659C0 Read-Burst IFMAP In-1-1401,408 1 0x4039C0 0x4C79C0 Read-Burst IFMAP In-1-2401,408 2 0x4039C1 0x4659C0 Read-Burst IFMAP In-2 401,408 3 0x4039C1 0x4659C0 Read-Burst IFMAP In-3 401,408 4 0x4039C1 0x4C79C0 Read-Burst IFMAP In-4-1401,408 4 0x4039C1 0x4C79C0 Read-Burst IFMAP In-4-2401,408 5 0x4039C1 0x4349C0 Read-Burst IFMAP In-5 200,704 6 0x4039C1 0x4659C0 Read-Burst IFMAP In-6 401,408 7 0x4039C1 0x4659C0 Read-Burst IFMAP In-7 401,408 8 0x4039C1 0x4659C0 Read-Burst IFMAP In-8 401,408 9 0x4039C1 0x41C1C0 Read-Burst IFMAP In-9 100,352 10 0x4039C1 0x4349C0 Read-Burst IFMAP In-10 200,704 11 0x4039C1 0x4349C0 Read-Burst IFMAP In-11 200,704 12 0x4039C1 0x4349C0 Read-Burst IFMAP In-12 200,704 13 0x4039C1 0x40FDC0 Read-Burst IFMAP In-13 50,176 14 0x4039C1 0x41C1C0 Read-Burst IFMAP In-14 100,352 15 0x4039C1 0x41C1C0 Read-Burst IFMAP In-15 100,352 16 0x4039C1 0x41C1C0 Read-Burst IFMAP In-16 100,352 17 0x4039C1 0x41C1C0 Read-Burst IFMAP In-17 100,352 18 0x4039C1 0x41C1C0 Read-Burst IFMAP In-18 100,352 19 0x4039C1 0x41C1C0 Read-Burst IFMAP In-19 100,352 20 0x4039C1 0x41C1C0 Read-Burst IFMAP In-20 100,352 21 0x4039C1 0x41C1C0 Read-Burst IFMAP In-21 100,352 22 0x4039C1 0x41C1C0 Read-Burst IFMAP In-22 100,352 23 0x4039C1 0x41C1C0 Read-Burst IFMAP In-23 100,352 24 0x4039C1 0x41C1C0 Read-Burst IFMAP In-24 100,352 25 0x4039C1 0x409BC0 Read-Burst IFMAP In-25 25,088 26 0x4039C1 0x40FDC0 Read-Burst IFMAP In-26 50,176 27 0x4039C1 0x40FDC0 Read-Burst IFMAP In-27 50,176 28 0x4039C1 0x403DC0 Read-Burst IFMAP In-28 1,024 표 9 레이어 시작 주소 끝 주소 동작 모드 도메인ANN DL 크기 (Byte) 1 0x4039C1 0x4659C0 Write-Burst OFMAPOut-1401,408 2 0x4039C1 0x4659C0 Write-Burst OFMAPOut-2401,408 3 0x4039C1 0x4C79C0 Write-Burst OFMAPOut-3802,816 4 0x4039C1 0x4349C0 Write-Burst OFMAPOut-4200,704 5 0x4039C1 0x4659C0 Write-Burst OFMAPOut-5401,408 6 0x4039C1 0x4659C0 Write-Burst OFMAPOut-6401,408 7 0x4039C1 0x4659C0 Write-Burst OFMAPOut-7401,408 8 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-8100,352 9 0x4039C1 0x4349C0 Write-Burst OFMAPOut-9200,704 10 0x4039C1 0x4349C0 Write-Burst OFMAPOut-10200,704 11 0x4039C1 0x4349C0 Write-Burst OFMAPOut-11200,704 12 0x4039C1 0x40FDC0 Write-Burst OFMAPOut-1250,176 13 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-13100,352 14 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-14100,352 15 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-15100,352 16 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-16100,352 17 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-17100,352 18 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-18100,352 19 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-19100,352 20 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-20100,352 21 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-21100,352 22 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-22100,352 23 0x4039C1 0x41C1C0 Write-Burst OFMAPOut-23100,352 24 0x4039C1 0x409BC0 Write-Burst OFMAPOut-2425,088 25 0x4039C1 0x40FDC0 Write-Burst OFMAPOut-2550,176 26 0x4039C1 0x40FDC0 Write-Burst OFMAPOut-2650,176 27 0x4039C1 0x403DC0 Write-Burst OFMAPOut-27 1,024 28 0x4039C1 0x403DA8 Write-Burst OFMAPOut-28 1,000 도 31은 버퍼 메모리(캐시)와 메인 메모리 간에 데이터 버스의 대역폭을 측정한 그래프를 나타낸다.도 31에 나 타난 그래프는 버퍼 메모리(캐시)와 메인 메모리가 AXI4 인터페이스로 연결되어 있을 때, 대역폭을 측정한 결과 를 나타낸다. 상기 대역폭의 측정은 2 Mbyte의 데이터를 메인 메모리인 DRAM에서 버퍼 메모리 인 SRAM으로 읽어 내는 상황에 서 수행되었고, AXI 버스트 길이 별(1~16)로 각기 10번 수행되었다. AXI 인터페이스는 버스트 길이를 조절할 수 있다. 도 31에 도시된 그래프를 표로 정리하면 아래와 같다. 표 10 버스트 길이 1 2 4 8 16 Linear AddressTime (ns) 2,310,440 1,198,699 654,484 378,766242,023 Bandwidth (Gb/sec) 6.93 13.35 24.45 42.2466.11 Random AddressTime (ns) 6,108,015 1,738,665 983,017 617,457363,018 Bandwidth (Gb/sec) 2.62 9.20 16.28 25.9144.07 버스트 길이와 상관없이 주소(ADDRESS)가 선형(linear)일 때, 전송 대역폭, 즉 전송 속도가 향상된다. 버스트 길이가 동일하다면, 선형 주소를 사용하는 것이 전송 속도가 더 빠를 수 있다. read-burst가 되도록 메인 메모 리인 DRAM의 주소를 효율적으로 할당하는 것이 유리할 수 있다.버스트 길이란 버스트로 한 번에 읽어오는 길이 를 의미한다. 선형인 경우, 버스트 길이가 짧더라도, DRAM 주소가 연속되기 때문에, RAS 지연 및/또는 CAS 지연 을 감소시킬 수 있다. 즉, ANN 데이터 지역성 정보를 기초로 메인 메모리의 메모리 맵을 선형으로 설정하면, 랜덤 한 경우보다 대역폭 이 증가한다. 따라서 메인 메모리와 버퍼 메모리 사이의 실효 대역폭을 증가시킬 수 있다. 도 32은 컴파일러를 포함하는 아키텍처를 나타낸 예시도이다. 컴파일러는 인공신경망모델을 NPU에서 구동할 수 있는 머신 코드로 변환시킨다. 컴파일러는 전단(Frontend)과 후단(backend)을 포함할 수 있다. IR(Intermediate representation)은 전단과 후 단 사이에 존재할 수 있다. 이러한 IR은 프로그램의 추상적 개념이며 프로그램 최적화에 사용된다. 인공신경망 모델은 다양한 레벨의 IR로 변환될 수 있다. 상위-레벨 IR은 컴파일러의 전단 측에 존재할 수 있다. 상기 컴파일러의 전단은 인공신경망모델에 대한 정보를 입력 받는다. 예를 들면, 인공신경망모델에 대한 정보는 도 23에 예시된 정보일 수 있다. 상기 컴파일러의 전단 은 하드웨어 비종속적인(hardware-independent) 변환과 최적화 작업을 수행할 수 있다. 상위-레벨 IR은 그래프 레벨이고, 계산과 제어 흐름(Control flow)을 최적화할 수 있다. 하위-레벨 IR은 컴파일 러의 후단에 위치할 수 있다. 컴파일러의 후단은 상위-레벨의 IR을 하위-레벨의 IR로 변환할 수 있다. 컴파일러의 후단은 NPU 최적화, CODE 생성, Compilation 작업을 수행한다. 상기 컴파일러 후단은 하드웨어 고유한(intrinsic) 매핑, 메모리-할당 등의 최적화 작업을 수행할 수 있다. ANN 데이터 지역성 정보는 하위-레벨 IR에서 생성되거나 정의될 수 있다. ANN 데이터 지역성 정보는 NPU가 메인 메모리에 요청할 모든 메모리 오퍼레이션 순서 정보를 포함할 수 있다. 따라서 AMC는 NPU가 요청할 모든 메모리 오퍼레이션 순서를 알 수 있다. 상술하였듯이, ANN 데이터 지역성 정보 는 컴파일러에서 생성될 수 있으며, 또는 AMC가 NPU가 메인 메모리에게 요청하는 메모리 오퍼레이션의 반복 패 턴을 분석하여 생성될 수 있다. ANN 데이터 지역성 정보는 레지스터 맵 또는 룩업 테이블 형식으로 생성될 수 있다. 컴파일러는 ANN 데이터 지역성 정보(ANN DL)를 분석 또는 제공받은 후, ANN DL에 기초하여, AMC 및/또는 NPU의 캐싱 스케쥴을 생성할 수 있다. 상기 캐싱 스케쥴은 NPU의 온-칩 메모리의 캐싱 스케쥴 및/또는 AMC의 버퍼 메 모리의 캐싱 스케쥴을 포함할 수 있다. 한편, 상기 컴파일러는 최적화 알고리즘(예컨대, Quantization, Pruning, Retraining, Layer fusion, Model Compression, Transfer Learning, AI Based Model Optimization, Other Model Optimization)을 반영한 인공신 경망모델을 컴파일할 수 있다. 또한, 컴파일러는 NPU에 최적화된 인공신경망모델의 ANN 데이터 지역성 정보를 생성할 수 있다. 상기 ANN 데이 터 지역성 정보는 AMC에 별로도 제공될 수 있으며, NPU와 AMC는 동일한 ANN 데이터 지역성 정보를 각각 제공받 는 것도 가능하다. 또한 도 14에서 상술하였듯이 AMC는 적어도 하나 이상일 수 있다. 상기 ANN 데이터 지역성 정보는 NPU의 메모리 오퍼레이션 요청 단위로 구성된 동작 시퀀스, 데이터 도메인, 데 이터 크기, 순차 주소 지정을 위해 구성된 메모리 주소 맵(memory map configured for sequential addressin g)을 포함할 수 있다. 도시된 NPU 내의 스케줄러는 상기 컴파일러로부터 바이너리(Binary) 형태의 Machine Code를 제공받아서 인공신 경망 연산을 수행할 수 있다. 컴파일러는 인공신경망 메모리 제어부(ANN Memory Controller, AMC)인 DMA 에 순차적으로(Sequential) 정렬된 메인 메모리의 메모리 주소 맵 정보를 제공하고, AMC는 순차적인 메모리 주소 맵(Sequential memory address map)에 기초하여 메인 메모리 내의 인공신경망모델 데이터를 배치, 또는 재정렬할 수 있다. AMC는 NPU의 초기화 또는 런타임 중 메인 메모리의 데이터 재정렬 동작을 수행할 수 있다. 이때, 상기 AMC는 상기 배치 또는 재정렬을 수행함에 있어서, read-burst 동작이 최적화하도록 할 수 있다. 상 기 배치 또는 재정렬은 NPU 동작 초기화시 수행될 수 있다. 또한, ANN DL의 변동 감지 시 상기 배치 또는 재정 렬이 수행될 수 있다. 이러한 기능은, 컴파일러와 무관하게 NPU 동작 중 AMC에서 독립적으로 수행될 수 있다. 상기 AMC와 NPU는 서로 ANN 데이터 지역성 정보를 제공받거나 제공할 수 있다. 즉, 컴파일러는 상기 AMC와 NPU 에게 ANN 데이터 지역성 정보를 제공할 수 있다. 상기 AMC는 NPU가 처리중인 ANN 데이터 지역성 정보의 연산 단 계 정보를 실시간으로 제공받을 수 있다. 또한, 상기 AMC는 ANN 데이터 지역성 정보를 상기 NPU와 동기화할 수 있다. 현재 NPU가 ANN 데이터 지역성 정보 토큰(Token) #N에 대응되는 데이터를 처리중이면, AMC는 데이터 지역성 정 보 토큰 #(N+1)에 대응되는 데이터가 NPU로부터 요청될 것을 예측하고, 메인 메모리의 지연을 고려하여, ANN 데 이터 지역성 정보 토큰 #(N+1)에 대응되는 데이터를 메인 메모리에게 요청한다. 해당 동작은 NPU의 메모리 오퍼레이션 요청 전에, AMC가 독자적으로 수행할 수 있다. 상기 컴파일러는 ANN 데이터 지역성에 따른 예측 동작에 필요한 데이터를 상기 AMC 내의 버퍼 메모리에 저장하 도록 캐싱 정책을 생성할 수 있다. 상기 컴파일러는 DMA의 버퍼 크기에 따라서 가능한 많은 데이터를 NPU가 요 청하기 전에 사전에 캐싱한다. 예를 들면, 컴파일러는 ANN 데이터 지역성 정보 토큰 #(N+M) 만큼 캐싱 하도록 AMC에 캐싱 정책을 제공한다. 여 기서 M은 ANN 데이터 지역성 정보 토큰 #(N+1)부터 #(N+M)까지를 합친 데이터 크기가 AMC의 캐쉬 용량(Cache capacity)과 같거나 또는 작은 경우를 만족하는 정수 값일 수 있다. 상기 컴파일러는 AMC의 캐쉬 메모리 잔여 용량이 ANN 데이터 지역성 정보 토큰 #(N+M+1)의 데이터 크기보다 클 경우, ANN 데이터 지역성 정보 토큰 #(N)에 대응되는 데이터가 저장된 영역에 ANN 데이터 지역성 정보 토큰 #(N+M+1) 데이터를 저장할 수 있다. 부연 설명하면, 상기 캐싱은 AMC의 ANN 데이터 지역성 정보 관리 유닛에 저장된 ANN DL에 기초하여 NPU의 명령 없이 AMC에 의해서 독립적으로 수행될 수 있다. 컴파일러는 모델 경량화 기능을 제공할 수 있다. 컴파일러는 대응되는 NPU 아키텍처에 맞도록 딥러닝 모델을 추 가적으로 최적화 그리고 경량화 할 수 있다. 본 명세서의 개시에 따르면 인공신경망 메모리 시스템이 제공된다. 상기 메모리 시스템은 인공신경망모델의 인 공신경망 데이터 지역성 정보에 기초하여, 상기 인공신경망모델의 데이터가 저장된 메모리가 리드-버스트 모드 로 동작하도록, 상기 메모리에 저장된 상기 인공신경망모델의 데이터의 재배열을 제어하도록 구성된, 인공신경 망 메모리 제어부를 포함할 수 있다. 상기 인공신경망 메모리 제어부는 기 생성된 인공신경망 데이터 지역성 정보를 제공받도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 프로세서가 순차적으로 생성하는 데이터 접근 요청을 모니터링 하여 상기 인 공신경망모델의 상기 인공신경망 데이터 지역성 정보를 생성하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망모델을 처리하는 프로세서 및 상기 인공신경망모델의 데이터 가 저장된 상기 메모리의 통신을 제어하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 메모리에 저장된 상기 인공신경망모델의 데이터를 상기 인공신경망 데이 터 지역성 정보에 기초하여 순방향으로 재배열 하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 프로세서가 생성하는 연속된 데이터 접근 요청들에 포함된 메모리 주소들을 모니터링하여 상기 인공신경망모델의 데이터를 재배열 하도록 구성될 수 있다. 본 명세서의 개시에 따르면, 인공신경망 메모리 시스템이 제시된다. 상기 인공신경망 메모리 시스템은 인공신경 망모델의 처리를 위해서 데이터 접근 요청을 생성하도록 구성된, 프로세서; 상기 인공신경망모델의 인공신경망 데이터 지역성 정보에 기초하여 상기 데이터 접근 요청에 대응되는 메모리 접근 요청을 생성하도록 구성된, 인 공신경망 메모리 제어부; 및 상기 메모리 접근 요청에 대응되는 데이터를 상기 인공신경망 데이터 지역성에 기 초한 리드-버스트 모드로 상기 인공신경망 메모리 제어부에 제공하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 프로세서가 생성하는 연속된 데이터 접근 요청들에 대응되는 상기 메모 리의 메모리 주소들에 기초하여 상기 연속된 데이터 접근 요청들이 상기 리드-버스트 모드로 동작 가능한지 여 부에 대하여 판단하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 프로세서가 생성하는 순차적 데이터 접근 요청들에 의해서 상기 메모리 가 상기 리드-버스트 모드로 동작 불가 판단 시, 상기 순차적 데이터 접근 요청들에 대응되는 데이터를 상기 리 드-버스트 모드로 동작 가능한 메모리 주소들에 저장하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 데이터 접근 요청에 대응되는 메모리 주소에 저장된 데이터를 상기 리드 -버스트 모드 동작이 가능한 메모리 주소로 교환하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망 데이터 지역성 정보에 기초하여 상기 메모리의 특정 메모리 영역을 상기 리드-버스트 모드 용으로 설정하도록 구성될 수 있다. 본 명세서의 개시에 따르면, 인공신경망 메모리 시스템이 제시된다. 상기 메모리 시스템은 인공신경망모델을 처 리하도록 구성된, 프로세서; 상기 인공신경망모델의 데이터를 저장하도록 구성된 메모리; 및 상기 인공신경망모델의 인공신경망 데이터 지역성 정보에 기초하여 생성되는 순차적인 메모리 접근 요청들의 메모리 주소들의 연속성을 분석하여 상기 데이터의 읽기-버스트 모드 동작 비율을 증가시키도록 구성된, 인공신경망 메모리 제어 부를 포함할 수 있다. 상기 인공신경망 메모리 제어부는 캐시 메모리를 더 포함할 수 있다. 상기 캐시 메모리는 상기 리드-버스트 모 드로 제공된 상기 데이터를 저장하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 캐시 메모리를 더 포함할 수 있다. 상기 캐시 메모리는 상기 인공신경망모델 의 인공신경망 데이터 지역성 정보에 기초하여 대응되는 가중치 값을 저장하도록 구성될 수 있다. 상기 메모리는 복수의 메모리일 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망모델의 데이터를 상 기 복수의 메모리에 분산시켜 저장하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망모델의 인공신경망 데이터 지역성 정보 및 상기 인공신경망모 델의 데이터가 저장된 메모리 주소에 기초하여 상기 메모리의 특정 글로벌 비트 라인의 리프레시 타이밍을 제어 하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망 데이터 지역성 정보에 기초하여 상기 프로세서가 생성하는 데이터 접근 요청들에 대응되는 메모리 접근 요청들이 서로 매핑(mapping)되는 데이터를 더 포함하도록 구성될 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망 데이터 지역성 정보에 기초하여 상기 메모리에 저장된 상기 인공신경망모델의 데이터를 재정렬 하도록 구성될 수 있다. 상기 메모리는 리드-버스트 기능을 가지는 휘발성 또는 비휘발성 메모리일 수 있다. 상기 인공신경망 메모리 제어부는 상기 인공신경망모델의 인공신경망 데이터 지역성에 기초하여 상기 메모리에 저장된 상기 인공신경망모델의 데이터를 리드-버스트 모드에 최적화되도록 재정렬하고, 상기 인공신경망모델의 인공신경망 데이터 지역성을 상기 재정렬된 데이터에 대응되도록 갱신하도록 구성될 수 있다. 이상에서 예시들에 설명된 특징, 구조, 효과 등은 본 개시의 하나의 예시에 포함되며, 반드시 하나의 예시에만 한정되는 것은 아니다. 나아가, 각 예시에서 예시된 특징, 구조, 효과 등은 예시들이 속하는 분야의 통상의 지 식을 가지는 자에 의해 다른 예시들에 대해서도 조합 또는 변형되어 실시 가능하다. 따라서 이러한 조합과 변형 에 관계된 내용들은 본 개시의 범위에 포함되는 것으로 해석되어야 할 것이다. 또한, 이상에서 예시를 중심으로 설명하였으나 이는 단지 예시일 뿐 본 발명을 한정하는 것이 아니며, 본 개시 가 속하는 분야의 통상의 지식을 가진 자라면 본 예시의 본질적인 특성을 벗어나지 않는 범위에서 이상에 예시 되지 않은 여러 가지의 변형과 응용이 가능함을 알 수 있을 것이다. 예를 들어, 예시에 구체적으로 나타난 각 구성요소는 변형하여 실시할 수 있는 것이다. 그리고 이러한 변형과 응용에 관계된 차이점들은 첨부된 청구 범 위에서 규정하는 본 발명의 범위에 포함되는 것으로 해석되어야 할 것이다."}
{"patent_id": "10-2023-0144762", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1a는 본 개시의 일 예시에 따른 인공신경망 데이터 지역성에 기초한 인공신경망 메모리 시스템의 프로세서 및 인공신경망 메모리 제어부를 설명하는 개략적인 블록도이다. 도 1b는 본 개시의 다양한 예시들에 적용될 수 있는 인공신경망 데이터 지역성 패턴의 재구성의 설명을 위한 예 시적인 신경 프로세싱 유닛의 예시를 나타내는 개략도이다. 도 2는 본 개시의 일 예시에 따른 인공신경망 데이터 지역성 패턴을 설명하는 개략도이다.도 3은 본 개시의 다양한 예시들에 적용될 수 있는 인공신경망 데이터 지역성 패턴의 설명을 위한 예시적인 인 공신경망모델을 나타내는 개략도이다. 도 4는 본 개시의 일 예시에 따른 인공신경망 메모리 제어부가 도 3a의 인공신경망모델을 분석하여 생성한 인공 신경망 데이터 지역성 패턴을 설명하는 개략도이다. 도 5는 도 4의 인공신경망 데이터 지역성 패턴에 대응되는 토큰과 식별 정보를 설명하는 개략도이다. 도 6은 본 개시의 일 예시에 따른 인공신경망 메모리 제어부가 인공신경망 데이터 지역성 패턴에 기초하여 생성 한 예측된 데이터 접근 요청과 실제 데이터 접근 요청을 설명하는 개략도이다. 도 7은 본 개시의 일 예시에 따른 인공신경망 메모리 제어부의 동작을 개략적으로 설명하는 순서도이다. 도 8은 본 개시의 다른 예시에 따른 인공신경망 메모리 시스템을 설명하는 개략적인 블록도이다. 도 9는 본 개시의 비교예에 따른 메모리 시스템의 동작을 설명하는 개략도이다. 도 10은 본 개시의 다른 예시에 따른 메모리 시스템의 설명하는 개략도이다. 도 11은 본 개시의 또 다른 예시에 따른 인공신경망 메모리 시스템을 설명하는 개략적인 블록도이다. 도 12는 데이터 접근 요청의 예시적인 식별 정보를 설명하는 개략도이다. 도 13은 인공신경망 메모리 시스템의 단위 동작 당 에너지 소모를 설명하는 개략도이다. 도 14는 본 개시의 다양한 예시들에 따른 인공신경망 메모리 시스템을 설명하는 개략도이다. 도 15a는 본 개시의 다양한 예시들에 따른 인공신경망 메모리 시스템을 설명하는 개략도이다. 도 15b는 도 15a에 도시된 SFU의 상세 동작 구성을 나타낸다. 도 16은 도 15a에 도시된 메인 메모리인 DRAM의 구조 및 동작을 나타낸 예시도이다. 도 17은 제1 예시에 따른 아키텍처를 나타낸다. 도 18은 제2 예시에 따른 아키텍처를 나타낸다. 도 19는 제3 예시에 따른 아키텍처를 나타낸다. 도 20은 제4 예시에 따른 아키텍처를 나타낸다. 도 21은 제5 예시에 따른 아키텍처를 나타낸다. 도 22는 제6 예시에 따른 아키텍처를 나타낸다. 도 23은 인공신경망모델로서 Mobilenet V1.0이 사용될 경우, 데이터의 예를 나타낸 예시도이다. 도 24는 메인 메모리 내의 데이터를 버퍼 메모리에 캐싱한 후, 연산을 수행하는 예를 나타낸다. 도 25는 메인 메모리 내의 데이터를 캐쉬 메모리에 캐싱한 후, 타일링 기법에 기초하여 연산을 수행하는 다른 예를 나타낸다. 도 26은 메인 메모리 내의 데이터를 재정렬하는 예를 나타낸다. 도 27은 NPU의 연산을 위한 메인 메모리의 주소 체계를 나타낸 예시도이다. 도 28은 ANN 데이터 지역성 정보에 기초하여 AMC가 메인 메모리의 버스트 동작을 제어하는 예를 나타낸다. 도 29는 ANN 데이터 지역성 정보에 기초하여 메인 메모리의 주소를 매핑하는 방식의 일 예를 나타낸 예시도이다. 도 30은 ANN 데이터 지역성 정보에 기초하여 메인 메모리의 주소를 매핑하는 방식의 다른 예를 나타낸 예시도이 다. 도 31는 버퍼 메모리(캐시)와 메인 메모리 간에 데이터 버스의 대역폭을 측정한 그래프를 나타낸다. 도 32은 컴파일러를 포함하는 아키텍처를 나타낸 예시도이다."}
