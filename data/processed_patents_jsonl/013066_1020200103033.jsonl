{"patent_id": "10-2020-0103033", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0022170", "출원번호": "10-2020-0103033", "발명의 명칭": "애플리케이션 악성 코드 분석 시스템 및 방법", "출원인": "아주대학교산학협력단", "발명자": "곽진"}}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "애플리케이션의 실행 코드로부터, 루프 정보를 포함하는 제어 흐름 그래프(CFG)를 생성하는 CFG 생성기;생성된 CFG로부터 API 호출 흐름을 나타내는 API 호출 그래프를 생성하는 API 호출 그래프 생성기;생성된 API 호출 그래프에 포함된 적어도 하나의 API 블록 각각의 특징 벡터를 생성하는 특징 벡터 생성기; 및생성된 적어도 하나의 특징 벡터로부터, 상기 애플리케이션의 악성 코드를 분석하는 악성 코드 분석기를 포함하는,애플리케이션 악성 코드 분석 시스템."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 CFG는 상기 애플리케이션의 실행 코드의 분기에 기초하여 구분되는 적어도 하나의 기본 블록을 포함하고,상기 적어도 하나의 기본 블록 각각은,루프에 포함되어 있는지 여부, 및 루프 유형 중 적어도 하나의 정보를 포함하는,애플리케이션 악성 코드 분석 시스템."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 루프 유형은,루프의 종료 지점 존재 여부, 및 루프의 반복과 관련된 레지스터값의 변화 유형 중 적어도 하나를 통해 정의되는,애플리케이션 악성 코드 분석 시스템."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서, 상기 적어도 하나의 기본 블록 각각은,인덱스, 이전 연결된 기본 블록의 인덱스, 및 다음 연결되는 기본 블록의 인덱스 중 적어도 하나를 더포함하는,애플리케이션 악성 코드 분석 시스템."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서, 상기 API 호출 그래프 생성기는,상기 CFG에 포함된 상기 적어도 하나의 기본 블록 중, API 호출이 수행되는 적어도 하나의 API 블록을 연결한상기 API 호출 그래프를 생성하는,애플리케이션 악성 코드 분석 시스템."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "공개특허 10-2022-0022170-3-제5항에 있어서, 상기 적어도 하나의 API 블록 각각은,루프에 포함되어 있는지 여부, 루프에 포함 시 루프의 시작점에 대응하는 API 블록의 인덱스, 및 루프 유형 중적어도 하나의 정보를 포함하는,애플리케이션 악성 코드 분석 시스템."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,상기 적어도 하나의 API 블록 각각은,인덱스, 이전 연결된 API 블록의 인덱스, 및 다음 연결되는 API 블록의 인덱스 중 적어도 하나를 더 포함하는,애플리케이션 악성 코드 분석 시스템."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 상기 특징 벡터 생성부는,상기 적어도 하나의 API 블록 각각에 포함된 정보에 대해 feature hashing을 수행함으로써, 상기 적어도 하나의API 블록 각각에 대응하는 기 설정된 길이의 특징 벡터를 생성하는,애플리케이션 악성 코드 분석 시스템."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서, 상기 악성 코드 분석기는, 상기 적어도 하나의 특징 벡터로부터 악성 코드의 유무, 및 악성 코드의 유형을 분류하는 인공지능 기반의 신경망을 포함하고,상기 신경망은 LSTM(long short-term memory)을 포함하는,애플리케이션 악성 코드 분석 시스템."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "애플리케이션의 실행 코드로부터, 적어도 하나의 기본 블록 및 상기 적어도 하나의 기본 블록 각각에 대한 루프정보를 포함하는 제어 흐름 그래프(CFG)를 생성하는 단계;생성된 CFG로부터, API의 호출 흐름을 나타내는 API 호출 그래프를 생성하는 단계;생성된 API 호출 그래프에 포함된 적어도 하나의 API 블록 각각의 특징 벡터를 생성하는 단계; 및생성된 적어도 하나의 특징 벡터로부터, 상기 애플리케이션의 악성 코드를 분석하는 단계를 포함하는,애플리케이션 악성 코드 분석 방법."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서,상기 루프 정보는,대응하는 기본 블록이 루프에 포함되어 있는지 여부, 및 루프 유형 중 적어도 하나의 정보를 포함하고,상기 루프 유형은,루프의 종료 지점 존재 여부, 및 루프의 반복과 관련된 레지스터값의 변화 유형 중 적어도 하나를 통해 정의되공개특허 10-2022-0022170-4-는,애플리케이션 악성 코드 분석 방법."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제10항에 있어서,상기 적어도 하나의 기본 블록 각각은,인덱스, 이전 연결된 기본 블록의 인덱스, 및 다음 연결되는 기본 블록의 인덱스 중 적어도 하나에 대한 정보를더 포함하는,애플리케이션 악성 코드 분석 방법."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제10항에 있어서, 상기 API 호출 그래프를 생성하는 단계는,상기 CFG에 포함된 상기 적어도 하나의 기본 블록 중, API 호출이 수행되는 적어도 하나의 API 블록을 연결하여상기 API 호출 그래프를 생성하는 단계를 포함하고,상기 적어도 하나의 API 블록 각각은,루프에 포함되어 있는지 여부, 루프에 포함 시 루프의 시작점에 대응하는 API 블록의 인덱스, 및 루프 유형 중적어도 하나의 정보를 포함하는,애플리케이션 악성 코드 분석 방법."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서, 상기 특징 벡터를 생성하는 단계는,상기 적어도 하나의 API 블록 각각에 포함된 정보에 대해 feature hashing을 수행함으로써, 상기 적어도 하나의API 블록 각각에 대응하는 기 설정된 길이의 특징 벡터를 생성하는 단계를 포함하는,애플리케이션 악성 코드 분석 방법."}
{"patent_id": "10-2020-0103033", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제10항에 있어서,상기 악성 코드를 분석하는 단계는,상기 적어도 하나의 특징 벡터를, 대응하는 API 블록의 흐름에 따라 인공지능 기반의 신경망에 순차적으로 입력하여, 상기 애플리케이션의 악성 코드 유무 및 악성 코드의 유형을 분류하는 단계를 포함하고,상기 신경망은 LSTM(long short-term memory)을 포함하는,애플리케이션 악성 코드 분석 방법."}
{"patent_id": "10-2020-0103033", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 개시의 기술적 사상에 의한 일 양태에 따른 애플리케이션 악성 코드 분석 시스템은, 애플리케이션의 실행 코 드로부터, 루프 정보를 포함하는 제어 흐름 그래프(CFG)를 생성하는 CFG 생성기, 생성된 CFG로부터 API 호출 흐 름을 나타내는 API 호출 그래프를 생성하는 API 호출 그래프 생성기, 생성된 API 호출 그래프에 포함된 적어도 하나의 API 블록 각각의 특징 벡터를 생성하는 특징 벡터 생성기, 및 생성된 적어도 하나의 특징 벡터로부터, 상 기 애플리케이션의 악성 코드를 분석하는 악성 코드 분석기를 포함한다."}
{"patent_id": "10-2020-0103033", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시(disclosure)의 기술적 사상은 애플리케이션의 악성 코드를 분석하는 시스템 및 방법에 관한 것이다."}
{"patent_id": "10-2020-0103033", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "애플리케이션의 악성 코드는 기존의 악성 코드를 재활용하거나, 새로운 악성 기능을 추가하면서 지속적으로 발 전하고 있다. 이러한 악성 코드를 단순히 탐지하는 것이 아니라 악성 코드 군을 분류하는 것은, 신종 또는 변종악성 코드의 행위 및 위험 수준을 이해하고 악성 코드의 공격에 대응할 때 도움이 될 수 있다. 악성 코드의 분석 방법으로는 정적 분석과 동적 분석이 존재한다. 동적 분석의 경우 애플리케이션을 실제 구동 하면서 악성 코드를 분석하는 방법으로서, 실행된 행위에 대해서만 분석하게 되는 한계가 존재한다. 반면, 정적 분석의 경우 애플리케이션을 구동하지 않고, 애플리케이션에 포함된 명령어나 코드를 전반적으로 분석함으로써, 악성 코드가 수행할 수 있는 가능한 모든 행위에 대해 분석할 수 있는 장점이 있다. 일례로, 안드로이드 애플리케이션의 악성 코드의 정적 분석 기반 분류 기법에는 Opcode 기반 분류 기법과 CFG(control flow graph) 기반 분류 기법이 존재한다. CFG 내에는 API 간의 호출 관계나 코드 분기 등의 실행 흐름 정보가 포함되므로, CFG 기반 분류 기법은 악성 코드의 행위 기반 분류 시 Opcode 기반 분류 기법에 비해 높은 정확도를 가질 수 있다. 다만, 종래의 CFG 기반 분류 기법들은 루프를 고려하지 않고 악성 코드의 행위 분석을 수행하고 있는 바, 루프 정보가 악성 행위를 의미하는 경우 행위 분석의 정확도가 급격히 감소하는 문제가 있다."}
{"patent_id": "10-2020-0103033", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명이 해결하고자 하는 일 과제는, 루프 정보를 활용하여 애플리케이션의 악성 코드를 분석할 수 있는 시스 템 및 방법을 제공하는 것이다. 본 발명이 해결하고자 하는 일 과제는, 신종 또는 변종 악성 코드에 대해서도 악성 코드의 유무 및 특성 등을 검출해낼 수 있는 악성 코드 분석 시스템 및 방법을 제공하는 것이다."}
{"patent_id": "10-2020-0103033", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "상기와 같은 목적을 달성하기 위하여, 본 개시의 기술적 사상에 의한 일 양태(aspect)에 따른 애플리케이션 악 성 코드 분석 시스템은, 애플리케이션의 실행 코드로부터, 루프 정보를 포함하는 제어 흐름 그래프(CFG)를 생성 하는 CFG 생성기, 생성된 CFG로부터 API 호출 흐름을 나타내는 API 호출 그래프를 생성하는 API 호출 그래프 생 성기, 생성된 API 호출 그래프에 포함된 적어도 하나의 API 블록 각각의 특징 벡터를 생성하는 특징 벡터 생성 기, 및 생성된 적어도 하나의 특징 벡터로부터, 상기 애플리케이션의 악성 코드를 분석하는 악성 코드 분석기를 포함한다. 실시 예에 따라, 상기 CFG는 상기 애플리케이션의 실행 코드의 분기에 기초하여 구분되는 적어도 하나의 기본 블록을 포함하고, 상기 적어도 하나의 기본 블록 각각은, 루프에 포함되어 있는지 여부, 및 루프 유형 중 적어 도 하나의 정보를 포함할 수 있다. 실시 예에 따라, 상기 루프 유형은 루프의 종료 지점 존재 여부, 및 루프의 반복과 관련된 레지스터값의 변화 유형 중 적어도 하나를 통해 정의될 수 있다. 실시 예에 따라, 상기 적어도 하나의 기본 블록 각각은 인덱스, 이전 연결된 기본 블록의 인덱스, 및 다음 연결 되는 기본 블록의 인덱스 중 적어도 하나를 더 포함할 수 있다. 실시 예에 따라, 상기 API 호출 그래프 생성기는 상기 CFG에 포함된 상기 적어도 하나의 기본 블록 중, API 호 출이 수행되는 적어도 하나의 API 블록을 연결한 상기 API 호출 그래프를 생성할 수 있다. 실시 예에 따라, 상기 적어도 하나의 API 블록 각각은 루프에 포함되어 있는지 여부, 루프에 포함 시 루프의 시 작점에 대응하는 API 블록의 인덱스, 및 루프 유형 중 적어도 하나의 정보를 포함할 수 있다. 실시 예에 따라, 상기 적어도 하나의 API 블록 각각은 인덱스, 이전 연결된 API 블록의 인덱스, 및 다음 연결되 는 API 블록의 인덱스 중 적어도 하나를 더 포함할 수 있다. 실시 예에 따라, 상기 특징 벡터 생성부는 상기 적어도 하나의 API 블록 각각에 포함된 정보에 대해 feature hashing을 수행함으로써, 상기 적어도 하나의 API 블록 각각에 대응하는 기 설정된 길이의 특징 벡터를 생성할 수 있다. 실시 예에 따라, 상기 악성 코드 분석기는 상기 적어도 하나의 특징 벡터로부터 악성 코드의 유무, 및 악성 코 드의 유형을 분류하는 인공지능 기반의 신경망을 포함하고, 상기 신경망은 LSTM을 포함할 수 있다.본 개시의 기술적 사상에 의한 일 양태에 따른 애플리케이션 악성 코드 분석 방법은, 애플리케이션의 실행 코드 로부터, 적어도 하나의 기본 블록 및 상기 적어도 하나의 기본 블록 각각에 대한 루프 정보를 포함하는 제어 흐 름 그래프(CFG)를 생성하는 단계; 생성된 CFG로부터, API의 호출 흐름을 나타내는 API 호출 그래프를 생성하는 단계; 생성된 API 호출 그래프에 포함된 적어도 하나의 API 블록 각각의 특징 벡터를 생성하는 단계; 및 생성된 적어도 하나의 특징 벡터로부터, 상기 애플리케이션의 악성 코드를 분석하는 단계를 포함한다."}
{"patent_id": "10-2020-0103033", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시의 기술적 사상에 따르면, 애플리케이션 악성 코드 분석 시스템은 애플리케이션의 실행 코드로부터 루프 정보를 포함하는 CFG를 생성하고, 생성된 CFG를 기반으로 특징 벡터를 생성하여 악성 코드를 분류함으로써, 루 프에 의한 악성 행위까지도 원활히 검출할 수 있다. 또한, 애플리케이션 악성 코드 분석 시스템은 LSTM 등의 신경망을 통해 상기 특징 벡터로부터 악성 코드를 분류 하도록 구현됨으로써, 신종 또는 변종 악성 코드의 유무 및 특성까지도 효과적으로 검출해낼 수 있다. 본 개시의 기술적 사상에 따른 효과는 이상에서 언급한 효과들로 제한되지 않으며, 언급하지 않은 또 다른 효과"}
{"patent_id": "10-2020-0103033", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 2, "content": "들은 아래의 기재로부터 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2020-0103033", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 개시의 기술적 사상에 따른 예시적인 실시예들은 당해 기술 분야에서 통상의 지식을 가진 자에게 본 개시의 기술적 사상을 더욱 완전하게 설명하기 위하여 제공되는 것으로, 아래의 실시예들은 여러 가지 다른 형태로 변 형될 수 있으며, 본 개시의 기술적 사상의 범위가 아래의 실시예들로 한정되는 것은 아니다. 오히려, 이들 실시 예들은 본 개시를 더욱 충실하고 완전하게 하며 당업자에게 본 발명의 기술적 사상을 완전하게 전달하기 위하여 제공되는 것이다. 본 개시에서 제1, 제2 등의 용어가 다양한 부재, 영역, 층들, 부위 및/또는 구성 요소들을 설명하기 위하여 사 용되지만, 이들 부재, 부품, 영역, 층들, 부위 및/또는 구성 요소들은 이들 용어에 의해 한정되어서는 안 됨은 자명하다. 이들 용어는 특정 순서나 상하, 또는 우열을 의미하지 않으며, 하나의 부재, 영역, 부위, 또는 구성 요소를 다른 부재, 영역, 부위 또는 구성 요소와 구별하기 위하여만 사용된다. 따라서, 이하 상술할 제1 부재, 영역, 부위 또는 구성 요소는 본 개시의 기술적 사상의 가르침으로부터 벗어나지 않고서도 제2 부재, 영역, 부 위 또는 구성 요소를 지칭할 수 있다. 예를 들면, 본 개시의 권리 범위로부터 이탈되지 않은 채 제1 구성 요소 는 제2 구성 요소로 명명될 수 있고, 유사하게 제2 구성 요소도 제1 구성 요소로 명명될 수 있다. 달리 정의되지 않는 한, 여기에 사용되는 모든 용어들은 기술 용어와 과학 용어를 포함하여 본 개시의 개념이 속하는 기술 분야에서 통상의 지식을 가진 자가 공통적으로 이해하고 있는 바와 동일한 의미를 지닌다. 또한, 통상적으로 사용되는, 사전에 정의된 바와 같은 용어들은 관련되는 기술의 맥락에서 이들이 의미하는 바와 일관 되는 의미를 갖는 것으로 해석되어야 하며, 여기에 명시적으로 정의하지 않는 한 과도하게 형식적인 의미로 해 석되어서는 아니 될 것이다.어떤 실시예가 달리 구현 가능한 경우에 특정한 공정 순서는 설명되는 순서와 다르게 수행될 수도 있다. 예를 들면, 연속하여 설명되는 두 공정이 실질적으로 동시에 수행될 수도 있고, 설명되는 순서와 반대의 순서로 수행 될 수도 있다. 첨부한 도면에 있어서, 예를 들면, 제조 기술 및/또는 공차에 따라, 도시된 형상의 변형들이 예상될 수 있다. 따라서, 본 개시의 기술적 사상에 의한 실시예들은 본 개시에 도시된 영역의 특정 형상에 제한된 것으로 해석되 어서는 아니 되며, 예를 들면, 제조 과정에서 초래되는 형상의 변화를 포함하여야 한다. 도면 상의 동일한 구성 요소에 대해서는 동일한 참조부호를 사용하고, 이들에 대한 중복된 설명은 생략한다. 여기에서 사용된 '및/또는' 용어는 언급된 부재들의 각각 및 하나 이상의 모든 조합을 포함한다. 이하에서는 첨부한 도면들을 참조하여 본 개시의 기술적 사상에 의한 실시예들에 대해 상세히 설명한다. 도 1은 본 개시의 예시적 실시 예에 따른 애플리케이션 악성 코드 분석 시스템의 개략적인 블록도이다. 애플리케이션 악성 코드 분석 시스템(100; 이하 '악성 코드 분석 시스템')은 적어도 하나의 컴퓨팅 장치로 구현 될 수 있다. 도 1에 도시된 구성들(110, 120, 130, 140)은 하나의 컴퓨팅 장치 내에 모두 구현되거나, 복수의 컴퓨팅 장치들에 서로 분산되어 구현될 수도 있다. 예컨대, 상기 적어도 하나의 컴퓨팅 장치는 스마트폰, 태블 릿 PC 등의 이동 단말기를 포함할 수 있으나, 이에 한정되는 것은 아니고 PC나 서버 등의 고정형 단말기를 포함 할 수도 있다. 이하 본 명세서에서, 악성 코드 분석 시스템은 안드로이드 OS에서 구동되는 애플리케이션의 악성 코드를 분석하는 것으로 가정하여 설명한다. 다만, 본 개시의 실시 예들이 안드로이드 OS에서 구동되는 애플리케이션에"}
{"patent_id": "10-2020-0103033", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "한정되어 적용되는 것은 아니며, 당해 기술분야에서 통상의 지식을 가진 자에 의해 용이하게 변형 가능한 범위 에서 다른 다양한 OS(windows, linux 등)의 애플리케이션에 대해서도 적용될 수 있음은 당연하다. 한편, 본 개시의 실시 예에 따른 악성 코드 분석 시스템은 정적 분석 기반으로 악성 코드를 분석함으로써, 악성 코드가 수행할 수 있는 가능한 모든 행위에 대해 분석할 수 있다. 안드로이드 애플리케이션의 정적 분석 기법에는 Opcode 기반 분류 기법과 제어 흐름 그래프(control flow graph(CFG)) 기반 분류 기법이 존재한다. CFG 내에는 API 간의 호출 관계나 코드 분기 등의 실행 흐름 정보가 포함되므로, 악성 코드의 행위를 기반한 분 류 시 높은 정확도를 보일 수 있다. 도 1을 참조하면, 악성 코드 분석 시스템은 CFG 생성기, API(application programming interface) 호출 그래프 생성기, 특징 벡터(feature vector) 생성기, 및 악성 코드 분석기를 포함할 수 있 다. 본 개시의 실시 예에 따른 악성 코드 분석 시스템이 상술한 구성들에 반드시 한정되는 것은 아닌 바, 악성 코드 분석 시스템은 보다 많거나 적은 구성들을 포함할 수도 있다. 악성 코드 분석 시스템에 포 함된 구성들(110, 120, 130, 140) 각각은 하드웨어, 소프트웨어, 또는 이들의 조합으로 구현될 수 있다. CFG 생성기는, 애플리케이션의 실행 코드(소스 코드)로부터 제어 흐름 그래프(CFG)를 추출 및 생성할 수 있다. 상기 CFG는 코드의 분기가 일어나지 않는 명령어의 가장 작은 단위인 기본 블록으로 구성되고, 기본 블록 이 다른 블록으로 분기되면 블록 간에 선으로 연결될 수 있다. 기본 블록들 각각에는 인덱스가 설정될 수 있고, 초기 기본 블록을 기준으로 분기되는 블록들의 인덱스는 순차적으로 증가하도록 설정될 수 있다. 이 때, 코드가 이전에 실행된 다른 코드로 분기될 경우 루프가 생성되는데, 루프 및 루프의 반복 횟수는 코드 실행 흐름을 반영하는 주된 요소에 해당한다. 그러나, 종래의 CFG 기반의 안드로이드 애플리케이션 악성 코드 분류 기법들은 루프를 고려하지 않고 CFG를 생성하여 악성 코드의 행위 분석을 수행하므로, 루프 정보가 악성 행위를 의미하는 경우 행위 분석의 정확도가 감소하는 문제가 발생할 수 있다. 본 개시의 실시 예에 따른 CFG 생성기는, CLAPP(characterizing loops in android application) 프레임워 크를 이용하여, 애플리케이션의 디컴파일 시 생성되는 기계어 실행 코드로부터 루프 정보를 포함하는 CFG를 추 출 및 생성할 수 있다. 상기 CLAPP 프레임워크는 상기 기계어 실행 코드인 Smali 코드로부터 CFG를 추출하고, 추출된 CFG 내의 루프 유형을 정의할 수 있다. 예컨대, 상기 루프 유형은 루프의 종료 지점의 존재 여부에 따라 '무한(infinite)' 또는 '유한(finite)'으로 정 의될 수 있다. 또한, 유한 루프의 경우 루프 반복 횟수를 결정하는 레지스터값의 변화 유형에 따라 루프 유형이 추가로 정의될 수 있다. 예컨대 레지스터값의 변화 유형은 '고정(fixed)', '증가(increasing)', '감소 (decreasing)', '제한적(bounded)', 및 레지스터값이 네트워크 입력으로 결정되어 알 수 없는 경우인 '알 수 없음(unknown)' 등으로 정의될 수 있다. 이를 종합하면, 본 개시의 실시 예에 따른 CFG 생성기에 의해 생성되는 CFG는 적어도 하나의 기본 블록을 포함할 수 있다. 상기 적어도 하나의 기본 블록 각각은, 자신의 인덱스, 이전 호출되는 기본 블록의 인덱스, 분 기 후(다음 호출되는) 기본 블록의 인덱스, 루프 포함 여부, 및/또는 루프 유형 등의 정보를 포함하도록 구성될 수 있다. API 호출 그래프 생성기는, CFG 생성기에 의해 생성된 CFG로부터, 적어도 하나의 API 블록의 호출 정 보를 나타내는 API 호출 그래프를 생성할 수 있다. 악성 코드는 특정 행위를 수행하기 위해 API를 호출하므로, API 호출 정보는 악성 코드의 행위를 반영하는 중요 정보에 해당한다. 따라서, 본 개시의 실시 예에 따르면, API 호출 그래프 생성기는 상기 생성된 CFG로부터 API 호출이 수행되는 기본 블록만을 연결하여 API 호출 그래프를 생성할 수 있다. 이에 따르면, 상기 API 블록 은 API 호출이 수행되는 기본 블록을 의미할 수 있다. API 호출 그래프는 적어도 하나의 API 블록으로 구성될 수 있다. API 블록 각각은, 자신의 인덱스, 이전 호출된 API 블록의 인덱스, 분기 후(다음 호출되는) API 블록의 인덱스, 루프 포함 여부, 루프 포함 시 루프의 시작점 에 해당하는 API 블록의 인덱스 및 루프 유형 등의 정보를 포함하도록 구성될 수 있다. 특징 벡터 생성기는, 상기 API 호출 그래프에 포함된 적어도 하나의 API 블록 각각에 저장된 정보에 기초 하여, 기 설정된 길이를 갖는 적어도 하나의 특징 벡터(feature vector)를 생성할 수 있다. 예컨대, 특징 벡터 생성기는 API 블록에 저장된 정보에 대해 feature hashing을 수행하여, 기 설정된 길이의 값(또는 문자열 등)을 갖는 특징 벡터를 생성할 수 있다. 악성 코드 분석기는, 특징 벡터 생성기에 의해 생성된 적어도 하나의 특징 벡터에 기초하여, 애플리 케이션에 대한 악성 코드 분석을 수행할 수 있다. 예컨대, 악성 코드 분석기는 상기 애플리케이션에 악성 코드가 포함되어 있는지 여부를 분석할 수 있고, 악성 코드가 포함된 경우 악성 코드의 유형(종류)을 분류할 수 있다. 악성 코드 분석기는 분석 결과에 기초하여 바이러스(virus), 웜(warm), 트로이목마(trojan), 랜섬웨 어(ransomware), 스미싱(smithing), 무한 루프 등의 공지된 다양한 유형으로 상기 애플리케이션에 포함된 악성 코드를 분류할 수 있다. 예컨대, 악성 코드 분석기는 심층학습(deep learning)에 따라 구현된 신경망으로 구현되거나 상기 신경망 을 포함하도록 구성될 수 있다. 한편, 상기 특징 벡터는 제어 흐름(또는 API 호출 흐름)에 따라 변화하는 벡터 에 해당할 수 있고, 악성 코드의 특성은 특정 API의 특징 벡터만이 아니라 애플리케이션의 실행 흐름에 따른 특 징 벡터의 변화를 고려하여 분류될 수 있는 정보이다. 따라서, 본 개시의 실시 예에 따른 악성 코드 분석기 는, 기존의 피드포워드(feedforward) 방식의 신경망보다는, 순환신경망(Recurrent Neural Network (RNN)), 장단기 기억 신경망(Long Short-Term Memory (LSTM)), 게이트 순환 유닛(Gate Recurrent Unit (GRU)) 등에 기반한 심층 기계학습에 따라 구현될 수 있다. 또한, 악성 코드 분석기는 입력된 특징 벡터에 기초한 분석 결과를 이용한 지속적 학습을 통해 신경망을 업데이트하도록 구현될 수 있다. 이에 따라, 신종 또는 변종 악성 코드가 애플리케이션에 포함된 경우에도, 악 성 코드의 유무나 특성에 대해 보다 효과적으로 분석할 수 있다. 도 2는 본 개시의 예시적 실시 예에 따른 애플리케이션 악성 코드 분석 방법을 설명하기 위한 플로우차트이다. 도 3은 애플리케이션의 제어 흐름을 보여주는 예시도이다. 도 4는 도 3의 실시 예에 따른 애플리케이션으로부터 생성되는 CFG를 나타낸다. 도 5는 도 4의 CFG에 기초하여 생성되는 API 호출 그래프를 나타낸다. 도 6은 API 호 출 그래프로부터 API 특징 벡터를 생성하는 방법에 대한 일례를 설명하는 표이다. 도 7은 생성된 API 특징 벡터 들로부터 악성 코드를 분석 및 분류하는 악성 코드 분석기의 일 구현 예를 설명하기 위한 도면이다. 도 2를 참조하면, 악성 코드 분석 시스템은 분석 대상이 되는 애플리케이션으로부터, 루프 정보를 포함하 는 제어 흐름 그래프(CFG)를 생성할 수 있다(S200). CFG 생성기는 애플리케이션의 디컴파일을 통해 획득되는 실행 코드로부터(예컨대 Smali 코드 등) CFG를 추 출 및 생성할 수 있다. 도 1에서 상술한 바와 같이, CFG 생성기는 CLAPP 프레임워크를 기반으로 루프 정보 가 포함된 CFG를 추출 및 생성할 수 있다. 이와 관련하여 도 3을 참조하면, CFG 생성기는 상기 실행 코드로부터 코드의 분기 형태에 따라 복수의 기 본 블록들(B0, B1, B2, B3)을 구분한 CFG를 생성할 수 있다. 복수의 기본 블록들(B0, B1, B2, B3) 각각은 코드의 분기에 의해 서로 구분될 수 있다. 이에 따라, 특정 기본 블록 내의 코드는 분기되지 않고 순차적으로 처리 및 실행될 수 있다. 예컨대, 사용자는 애플리케이션의 UI 인터페이스인 Activity를 통해 애플리케이션을 사용할 수 있고, Activity 의 사용 시 onCreate API가 가장 먼저 호출될 수 있다. 따라서, onCreate API가 포함된 제1 기본 블록(B0)이 가 장 낮은 인덱스(예컨대 '0')를 가질 수 있다. 또한, if 조건에 따라 코드 분기가 발생하는 위치에서 인덱스가 '1'로 증가한 제2 기본 블록(B1)이 정의되고, 분기된 코드 위치에 따라 각각 인덱스가 '2' 및 '3'인 제3 기본 블록 및 제4 기본 블록(B2, B3)이 정의될 수 있 다. 한편, 인덱스가 '2'인 제3 기본 블록(B2)은 인덱스가 '0'인 제1 기본 블록(B0)으로 분기되므로, 기본 블록 들(B0, B1, B2)을 연결하는 루프(L0)가 정의될 수 있다. CFG 생성기는 루프의 종료 지점 존재 여부 및 루프 반복과 관련된 레지스터값의 변화 유형을 통해, 루프 (L0)의 유형을 정의할 수 있다. 도 3의 실시 예에서, 제2 기본 블록(B1)에서 루프(L0)가 종료될 수 있으므로, CFG 생성기는 루프(L0)가 유한 루프인 것으로 정의할 수 있다. 또한, CFG 생성기는 루프의 반복에 따 른 레지스터값(R3, R4)의 변화를 통해, 루프의 변화 유형이 '고정', '증가', '감소', '제한적', '알 수 없음' 중 어느 하나인 것으로 정의할 수 있다. 정리하면, CFG 생성기에 의해 생성된 CFG는 코드의 분기에 따라 서로 연결되는 복수의 기본 블록들(B0, B1, B2, B3)을 포함한다. 복수의 기본 블록들(B0, B1, B2, B3) 각각은 이전 연결된 블록의 인덱스, 자신의 인덱스, 다 음 연결되는 블록의 인덱스, 루프에 포함되어 있는지 여부, 루프 유형에 대한 정보를 포함할 수 있다. 일례로 제3 기본 블록(B2)은 이전 연결된 블록의 인덱스('1'), 자신의 인덱스('2'), 다음 연결되는 블록의 인덱스 ('0'), 루프 포함 여부('포함됨'), 및 루프 유형('유한', '증가')을 나타내는 정보를 포함할 수 있을 것이다. 다시 도 2를 설명한다. 악성 코드 분석 시스템은 생성된 CFG로부터 API 호출 그래프를 생성할 수 있다(S210). API 호출 그래프 생성기는, 생성된 CFG에 포함된 기본 블록들 중, API 호출이 수행되는 기본 블록들을 연 결하여 API 호출 그래프를 생성할 수 있다. 도 4에 도시된 CFG의 일례를 참조하면, 기본 블록들(B0, B1, B2, B3) 중 제1 기본 블록(B0), 제3 기본 블록 (B2), 및 제4 기본 블록(B3) 각각은 API의 호출 코드를 포함하고, 제2 기본 블록(B1)은 API의 호출 코드를 포함 하지 않을 수 있다. 기본 블록들 각각이 호출하는 API는 동일하거나 다를 수 있다. 도 5를 참조하면, API 호출 그래프 생성기는, API의 호출 코드를 포함하는 제1 기본 블록(B0), 제3 기본 블록(B2), 및 제4 기본 블록(B3)을 연결하여 API 호출 그래프를 생성할 수 있다. 이 때, 제1 기본 블록(B 0)은 제1 API 블록(A0)에 대응하고, 제3 기본 블록(B2)은 제2 API 블록(A1)에 대응하며, 제4 기본 블록(B3)은 제 3 API 블록(A2)에 대응할 수 있다. 제1 API 블록(A0) 및 제2 API 블록(A1)은 루프(L0)에 포함되는 블록이고, 제3 API 블록(A2)은 루프(L0)에 포함되지 않는 블록에 해당한다. API 호출 그래프에 포함되는 API 블록들(A0, A1, A2)은 API명, 이전 연결된 API 블록의 인덱스, 자신의 인 덱스, 다음 연결되는 API 블록의 인덱스, 루프에 포함되어 있는지 여부, 루프에 포함 시 루프의 시작점에 해당 하는 API 블록의 인덱스, 및 루프 유형에 대한 정보 등을 포함할 수 있다. 일례로, 제2 API 블록(A1)은 이전 연 결된 블록의 인덱스('0'), 자신의 인덱스('1'), 다음 연결되는 블록의 인덱스('0'), 루프 포함 여부('포함됨'), 루프 시작점에 해당하는 API 블록의 인덱스('1'), 및 루프 유형('유한', '증가'등)을 나타내는 정보를 포함할 수 있을 것이다. 다시 도 2를 설명한다. 악성 코드 분석 시스템은 생성된 API 호출 그래프에 기초하여, 상기 API 호출 그래프에 포함되는 API 블록 들의 특징 벡터를 생성할 수 있다(S220). 특징 벡터 생성기는, API 호출 그래프의 API 블록들이 포함하는 정보를 기반으로, API 블록들 각각에 대응 하는 기 설정된 길이의 특징 벡터를 생성할 수 있다. 구체적으로, 특징 벡터 생성기는 feature hashing을 수행함으로써, API 블록에 포함된 정보 각각을 기 설정된 길이의 값(또는 문자열 등)으로 변환할 수 있다. 도 6에는 특징 벡터 생성 방법의 일 실시 예가 도시되어 있으나, 본 실시 예는 설명의 편의를 위한 것에 불과하 므로, 본 개시의 실시 예에 따른 악성 코드 분석 시스템에 적용되는 특징 벡터 생성 방법은 다양하게 변형 될 수 있다. 도 6의 예를 참조하면, 특징 벡터 생성기는 API 블록들(A0, A1, A2) 각각의 API명에 feature hashing을 수 행하여, API 블록들 각각에 대한 16 바이트 길이의 제1 부분 특징 벡터를 생성할 수 있다. 특징 벡터 생성기 는 API 블록들 각각이 루프에 포함된 경우, 루프 시작 지점의 API명에 feature hashing을 수행하여 16 바 이트 길이의 제2 부분 특징 벡터를 생성할 수 있다. API 블록이 루프에 포함되지 않은 경우(예컨대 제3 API 블 록(A2)), 해당 API 블록에 대한 제2 부분 특징 벡터는 0의 값을 가질 수 있다. 실시 예에 따라, 특징 벡터 생성기는 API 블록들 각각이 루프에 포함된 경우, 루프 유형 정보에 대해 feature hashing을 수행하여 32 바이트 길이의 제3 특징 벡터를 생성할 수 있다. 예컨대, 루프 유형 정보는 루 프 종료 지점에 기반하여 '무한' 또는 '유한'을 나타내는 단어, 및 레지스터값의 변화 유형에 기반한 '고정', '증가', '감소', '제한적', '알 수 없음' 등의 단어를 포함할 수 있다. 특징 벡터 생성기는 루프 유형 정 보에 포함된 단어들에 대해 feature hashing을 수행하여 상기 제3 특징 벡터를 생성할 수 있다. 실시 예에 따라 API 블록이 루프에 포함되지 않은 경우(예컨대 제3 API 블록(A2)), 해당 API 블록에 대한 제3 부분 특징 벡터는 0의 값을 가질 수 있다. 실시 예에 따라, 특징 벡터 생성기는 API 블록이 루프에 포함된 경우, 루프에 포함된 모든 API명을 이은 문자열에 feature hashing을 수행하여 64 바이트 길이의 제4 특징 벡터를 생성할 수 있다. 반면 API 블록이 루 프에 포함되지 않은 경우, 해당 API 블록에 대한 제4 부분 특징 벡터는 0의 값을 가질 수 있다. 특징 벡터 생성기는 상기 제1 부분 특징 벡터 내지 제4 부분 특징 벡터를 연결함으로써, API 블록에 대응 하는 특징 벡터를 생성할 수 있다. 도 3 내지 도 5의 실시 예에 따라 3개의 API 블록이 존재하는 경우, 특징 벡 터 생성기는 API 블록마다 특징 벡터를 생성함으로써 총 3개의 특징 벡터를 생성할 수 있다. 다만, 특징 벡터의 수는 다양하게 변경될 수 있다. 다시 도 2를 설명한다. 악성 코드 분석 시스템은 생성된 특징 벡터에 기초하여, 애플리케이션에 대한 악성 코드를 분석할 수 있다 (S230). 악성 코드 분석기는 API 호출 그래프로부터 획득되는 특징 벡터들(API 특징 벡터들)로부터 애플리케이션의 악성 코드를 분석할 수 있다. 도 1에서 상술한 바와 같이, 악성 코드 분석기는 인공지능 기반의 심층 학습 (딥러닝)에 따라 구현될 수 있고, 하드웨어, 소프트웨어, 또는 이들의 조합으로 구현될 수 있다. 또한, 상술한 바와 같이 악성 코드 분석기는 기존의 피드포워드(feedforward) 방식의 신경망이 아닌, RNN, LSTM, GRU 등에 기반한 심층 기계학습에 따라 구현될 수 있다. 이하 본 명세서에서는 악성 코드 분석기가 LSTM에 따라 구현된 것으로 가정하여 설명한다. 도 7을 참조하면, LSTM에 따라 구현된 악성 코드 분석기는 특징 벡터들(API 특징 벡터들)이 입력되는 입력 계층(input layer), 입력된 특징 벡터들을 이용한 학습이 수행되는 LSTM 계층(LSTM layer), 입력된 특징 벡터들 로부터 악성 코드들 및 정상 코드 각각에 대한 확률을 결정하는 fully connected 계층 및 softmax 계층, 및 결 정된 확률에 기초하여 애플리케이션에 대한 악성 코드 유형 또는 정상 코드를 분류하는 분류 계층 (classification layer)을 포함할 수 있다. LSTM은 일반적인 RNN에 비해 길이가 긴 시계열 데이터에 대해서도 효과적인 처리가 가능하다. 악성 코드 분석기 로 입력되는 특징 벡터들은, API 호출 그래프에 포함된 API 블록들의 인덱스에 기초하여 순차적으로 입력 될 수 있다. 따라서, 본 개시의 실시 예에 따른 악성 코드 분석기는 LSTM 기반으로 구현되어, 가변적이고 길이가 긴 악성 코드의 API 호출 특성을 나타내는 특징 벡터들로부터 높은 정확도의 악성 코드 분석 결과를 제 공할 수 있다.예컨대, 악성 코드 분석기로부터 출력되는 분석 결과는 정상 코드 및 악성 코드로 분류될 수 있다. 또한, 악성 코드의 경우 바이러스(virus), 웜(warm), 트로이목마(trojan), 랜섬웨어(ransomware), 스미싱(smithing), 무한루프 등으로 분류되어, 이들 중 어느 하나가 분석 결과로서 제공될 수 있다. 즉, 본 개시의 실시 예들에 따르면, 악성 코드 분석 시스템은 애플리케이션의 실행 코드의 루프 정보를 활 용하여 악성 코드를 분석할 수 있으므로, 루프 반복 패턴이나 횟수에 따른 악성 행위까지도 정확히 분석할 수 있다. 상기한 실시 예들의 설명은 본 개시의 더욱 철저한 이해를 위하여 도면을 참조로 예를 든 것들에 불과하므로, 본 개시의 기술적 사상을 한정하는 의미로 해석되어서는 안될 것이다. 또한, 본 개시가 속하는 기술 분야에서 통상의 지식을 가진 자에게 있어 본 개시의 기본적 원리를 벗어나지 않 는 범위 내에서 다양한 변화와 변경이 가능함은 명백하다 할 것이다."}
{"patent_id": "10-2020-0103033", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시에서 인용되는 도면을 보다 충분히 이해하기 위하여 각 도면의 간단한 설명이 제공된다. 도 1은 본 개시의 예시적 실시 예에 따른 애플리케이션 악성 코드 분석 시스템의 개략적인 블록도이다. 도 2는 본 개시의 예시적 실시 예에 따른 애플리케이션 악성 코드 분석 방법을 설명하기 위한 플로우차트이다. 도 3은 애플리케이션의 제어 흐름을 보여주는 예시도이다. 도 4는 도 3의 실시 예에 따른 애플리케이션으로부터 생성되는 CFG를 나타낸다. 도 5는 도 4의 CFG에 기초하여 생성되는 API 호출 그래프를 나타낸다. 도 6은 API 호출 그래프로부터 API 특징 벡터를 생성하는 방법에 대한 일례를 설명하는 표이다. 도 7은 생성된 API 특징 벡터들로부터 악성 코드를 분석 및 분류하는 악성 코드 분석기의 일 구현 예를 설명하 기 위한 도면이다."}
