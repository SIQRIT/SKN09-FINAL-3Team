{"patent_id": "10-2021-0033233", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0036874", "출원번호": "10-2021-0033233", "발명의 명칭": "개발 키트 조작 임무 처리 방법, 장치, 기기 및 저장매체", "출원인": "베이징 바이두 넷컴 사이언스 테크놀로지 컴퍼니", "발명자": "뤄, 바오통"}}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "클라이언트에서 개시한 임무 작성 요청을 수신하는 단계;상기 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성하는 단계;상기 개발 키트 조작 임무를 위해 상기 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당하는 단계;클러스터 노드 중의 마스터 노드로 상기 개발 키트 조작 임무 요청을 발송하되, 상기 임무 요청은 상기 목표GPU 상에서 상기 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것인 단계;를 포함하는 개발 키트 조작 임무 처리 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 개발 키트 조작 임무를 위해 상기 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당하는 상기 단계는,상기 개발 키트 조작 임무가 소속되는 사용자 그룹을 결정하되, 서로 다른 상기 사용자 그룹은 서로 다른 리소스 사용 권한에 대응되는 단계;상기 개발 키트 조작 임무가 소속되는 사용자 그룹에 대응되는 리소스 사용 권한, 및 상기 개발 키트 조작 임무에 필요한 리소스를 기초로, 상기 개발 키트 조작 임무의 수행에 필요한 목표 GPU를 할당하는 단계를 포함하는방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 개발 키트 조작 임무가 소속되는 사용자 그룹을 결정하는 상기 단계 후에, 상기 방법은,상기 개발 키트 조작 임무가 소속되는 사용자 그룹의 리소스 사용 한도를 결정하는 단계;를 더 포함하고상기 개발 키트 조작 임무를 위해 상기 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당하는 상기 단계는,상기 사용자 그룹의 리소스 사용 한도가 상기 개발 키트 조작 임무에 필요한 리소스량 이상이면, 상기 개발 키트 조작 임무의 수행에 필요한 목표 GPU를 할당하는 단계를 포함하고,상기 개발 키트 조작 임무의 수행에 필요한 목표 GPU를 할당하는 단계 이후에, 상기 방법은, 상기 사용자 그룹의 리소스 사용 한도에서 상기 개발 키트 조작 임무에 필요한 리소스량을 감산하는 단계를 더포함하는 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서, 상기 방법은, 임무 데이터베이스에서 상기 목표 GPU에 대한 상기 개발 키트 조작 임무의 리소스 이용율을 조회하는 단계;상기 목표 GPU에 대한 상기 개발 키트 조작 임무의 리소스 이용율이 제1 임계값보다 낮으면, 상기 마스터 노드로 임무 릴리스 지시를 발송하되, 상기 임무 릴리스 지시는 목표 GPU 상에서 상기 개발 키트 조작 임무를 릴리스하는 단계;를 더 포함하는 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "공개특허 10-2021-0036874-3-제1항에 있어서, 상기 방법은,임무 데이터베이스에서 상기 목표 GPU의 리소스 이용율을 조회하는 단계;상기 목표 GPU의 리소스 이용율이 제2 임계값을 초과하면, 상기 개발 키트 조작 임무를 위해 목표 GPU를 재할당하는 단계;재할당된 GPU를 기초로 상기 마스터 노드로 상기 개발 키트 조작 임무 요청을 발송하는 단계;를 더 포함하는 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 클러스터 노드 중의 마스터 노드로 상기 개발 키트 조작 임무 요청을 발송하는 단계 후에, 상기 방법은, 상기 개발 키트 조작 임무에 대응되는 개발 키트의 스냅 사진을 업데이트하되, 상기 스냅 사진은 상기 개발 키트의 데이터 사이의 논리 관계인 단계를 더 포함하는 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서, 상기 클러스터 노드 중 마스터 노드로 상기 개발 키트 조작 임무 요청을 발송하는 단계 후에, 상기 방법은,상기 개발 키트 조작 임무에 필요한 블록 기기를 결정하되, 상기 블록 기기는 상기 개발 키트 조작 임무를 위해저장 리소스를 요청하기 위한 것인 단계를 더 포함하는 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 상기 개발 키트 조작 임무는, 상기 개발 키트의 구축, 상기 개발 키트의 삭제, 상기 개발 키트의 재부팅 및 상기 개발 키트의 재설치 중 적어도 하나를 포함하는 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "임무 관리 서버에서 발송한 개발 키트 조작 임무 요청을 수신하되, 상기 임무 요청은 목표 그래픽 프로세서(GPU) 상에서 상기 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것인 단계;클러스터 노드 중 복수의 동작 노드의 실행 상태를 기초로, 목표 동작 노드를 결정하는 단계;상기 목표 동작 노드의 docker 컨테이너를 스케줄링하여 상기 목표 GPU 상에서 상기 개발 키트 조작 임무를 수행하도록 하는 단계;를 포함하는 개발 키트 조작 임무 처리 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 목표 동작 노드의 docker 컨테이너를 스케줄링하여 상기 목표 GPU 상에서 상기 개발 키트 조작 임무를 수행하도록 하는 단계 후에, 상기 방법은,상기 목표 동작 노드의 개발 키트 조작 임무의 수행 진도와 상기 개발 키트 조작 임무에 대응되는 개발 키트의상태를 모니터링하는 단계;상기 개발 키트 조작 임무의 수행 진도와 상기 개발 키트 조작 임무에 대응되는 개발 키트의 상태를 임무 데이터베이스로 발송하는 단계;를 더 포함하는 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제9항에 있어서, 상기 목표 동작 노드의 docker 컨테이너를 스케줄링하여 상기 목표 GPU 상에서 상기 개발 키트 조작 임무를 수행하도록 하는 단계 후에, 상기 방법은,공개특허 10-2021-0036874-4-상기 목표 GPU에 대한 상기 개발 키트 조작 임무의 리소스 이용율을 모니터링하는 단계;상기 목표 GPU의 리소스 이용율을 임무 데이터베이스로 발송하는 단계;를 더 포함하는 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제9항에 있어서, 상기 개발 키트 조작 임무는, 상기 개발 키트의 구축, 상기 개발 키트의 삭제, 상기 개발 키트의 재부팅 및 상기 개발 키트 재설치 중 적어도 하나를 포함하는 방법."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "적어도 하나의 프로세서; 및 상기 적어도 하나의 프로세서와 통신 연결되는 메모리;를 포함하되,상기 메모리에 상기 적어도 하나의 프로세서에 의해 실행될 수 있는 명령이 저장되어 있고, 상기 명령은 상기적어도 하나의 프로세서에 의해 실행되어, 상기 적어도 하나의 프로세서가 제1항 내지 제12항 중 어느 한 항에따른 방법을 수행하도록 하는 전자기기."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "컴퓨터 명령이 저장된 비일시적 컴퓨터 판독 가능 저장매체에 있어서, 상기 컴퓨터 명령은 상기 컴퓨터가 제1항내지 12중 어느 한 항에 따른 방법을 수행하도록 하는 저장매체."}
{"patent_id": "10-2021-0033233", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "컴퓨터 판독 가능 저장매체에 저장된 컴퓨터 프로그램에 있어서,상기 컴퓨터 프로그램 중의 명령이 프로세서에 의해 실행될 경우, 제1항 내지 제12항 중 어느 한 항에 따른 방법을 구현하는 컴퓨터 프로그램."}
{"patent_id": "10-2021-0033233", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 출원은 개발 키트 조작 임무 처리 방법, 장치, 기기 및 저장매체에 관한 것으로서, 인공지능의 딥러닝 분야에 관한 것이다. 구체적인 구현방안에 따르면, 클라이언트에서 개시한 임무 작성 요청을 수신하고; 임무 작성 요청 을 기초로, 개발 키트 조작 임무를 생성하고; 개발 키트 조작 임무를 위해 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당하고; 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하 고, 임무 요청은 목표 GPU 상에서 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것이다. 종래기술에 비해, 본 출원은 docker 컨테이너를 사용하여 GPU 상에서 개발 키트 조작 임무를 수행하며, 이에 따라 직접 로컬 호스 트의 운영체제를 이용할 수 있으므로, 물리적 머신의 하드웨어 이용율을 향상시킨다."}
{"patent_id": "10-2021-0033233", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원은 데이터 처리 중 인공지능의 딥러닝 분야에 관한 것으로, 특히는 개발 키트 조작 임무 처리 방법, 장 치, 기기 및 저장매체에 관한 것이다."}
{"patent_id": "10-2021-0033233", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "딥러닝 개념이 제안된 이후로부터, 딥러닝은 이론과 실제 응용 측면에서 모두 큰 발전을 가져왔다. 종래의 딥러 닝 트레이닝 임무는 모두 고성능 그래픽 프로세서(graphics processing unit, GPU) 클러스터 상에서 실행된다. 개발, 트레이닝 환경 일치의 목적을 달성하기 위하여, 개발자는 대부분 GPU 개발 키트를 사용하여 개발 디버깅 작업을 수행한다. 현재 개발 키트의 주요한 방식은 플랫폼 가상화 기술을 통해 컴퓨터, 및 네트워크 하드웨어 사이에 하나의 추상 적인 가상화 플랫폼을 구축하여, 물리적 머신의 모든 하드웨어가 하나의 가상화 계층에 통합되도록 한다. 가상 화 플랫폼 상단에 물리적 머신과 동일한 하드웨어 구조를 가진 가상 머신이 구축되어 있으며, 개발자는 가상 머 신 상에서 개발 키트 조작 임무를 수행할 수 있다. 가상 머신은 서로 간섭하지 않으므로, 시스템 리소스를 보호 할 수 있다. 하지만, 가상 머신은 물리적 머신의 실제 하드웨어 계층에 대해 패키징하여야 하며, 가상화도 당연히 부분의 물 리적 머신의 리소스를 점용하게 되므로, 부분 물리적 머신의 성능이 손실되며, 이에 따라 물리적 머신의 하드웨 어 이용율이 보다 낮다."}
{"patent_id": "10-2021-0033233", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 출원은 개발 키트 조작 임무 처리 방법, 장치, 기기 및 저장매체를 제공한다."}
{"patent_id": "10-2021-0033233", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 출원의 제1 측면에 따르면, 개발 키트 조작 임무 처리 방법을 제공하며, 클라이언트에서 개시한 임무 작성 요청을 수신하고; 상기 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성하고; 상기 개발 키트 조작 임무를 위해 상기 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할 당하고; 클러스터 노드 중의 마스터 노드로 상기 개발 키트 조작 임무 요청을 발송하되, 상기 임무 요청은 상기 목표 GPU 상에서 상기 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것이다. 본 출원의 제2 측면에 따르면 개발 키트 조작 임무 처리 방법을 제공한다. 해당 방법은, 임무 관리 서버에서 발송한 개발 키트 조작 임무 요청을 수신하되, 상기 임무 요청은 목표 GPU 상에서 상기 개 발 키트 조작 임무를 수행할 것을 요청하기 위한 것인 단계; 클러스터 노드 중 복수의 동작 노드의 실행 상태를 기초로, 목표 동작 노드를 결정하는 단계; 상기 목표 동작 노드의 docker 컨테이너를 스케줄링하여 상기 목표 GPU 상에서 상기 개발 키트 조작 임무를 수 행하도록 하는 단계;를 포함한다. 본 출원의 제3 측면에 따르면, 개발 키트 조작 임무 처리 장치를 제공한다. 해당 장치는, 클라이언트에서 개시한 임무 작성 요청을 수신하는 수신모듈; 상기 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성하고; 상기 개발 키트 조작 임무를 위해 상기 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당하는 처리모듈; 클러스터 노드 중의 마스터 노드로 상기 개발 키트 조작 임무 요청을 발송하되, 상기 임무 요청은 상기 목표 GPU 상에서 상기 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것인 발송모듈;을 포함한다. 본 출원의 제4 측면에 따르면, 개발 키트 조작 임무 처리 장치를 제공한다. 해당 장치는, 임무 관리 서버에서 발송한 개발 키트 조작 임무 요청을 수신하되, 상기 임무 요청은 목표 GPU 상에서 상기 개 발 키트 조작 임무를 수행할 것을 요청하기 위한 것인 수신모듈; 클러스터 노드 중 복수의 동작 노드의 실행 상태를 기초로, 목표 동작 노드를 결정하고; 상기 목표 동작 노드의 docker 컨테이너를 스케줄링하여 상기 목표 GPU 상에서 상기 개발 키트 조작 임무를 수행하는 처리모듈;을 포함 한다. 본 출원의 제5 측면에 따르면, 전자기기를 제공한다. 해당 전자기기는, 적어도 하나의 프로세서; 및 상기 적어도 하나의 프로세서와 통신 연결되는 메모리;를 포함하되, 상기 메모리에 상기 적어도 하나의 프로세서에 의해 실행될 수 있는 명령이 저장되어 있고, 상기 명령은 상기 적어도 하나의 프로세서에 의해 실행되어, 상기 적어도 하나의 프로세서가 제1 측면에 따른 방법을 수행할 수 있도록 한다. 본 출원의 제6 측면에 따르면, 컴퓨터 명령이 저장된 비일시적 컴퓨터 판독 가능 저장매체를 제공하며, 상기 컴 퓨터 명령은 상기 컴퓨터가 상술한 제1 측면에 따른 방법을 수행하도록 한다. 본 출원의 제7 측면에 따르면, 컴퓨터 프로그램을 제공한다. 상기 컴퓨터 프로그램은 판독 가능 저장 매체에 저 장되어, 상기 전자기기의 적어도 하나의 프로세서는 상기 판독 가능 저장매체로부터 상기 컴퓨터 프로그램을 판 독할 수 있으며, 상기 컴퓨터 프로그램이 상기 적어도 하나의 프로세서에 의해 실행될 경우, 전자기기가 제1 측 면 및 제2 측면에 따른 방법을 수행하도록 한다."}
{"patent_id": "10-2021-0033233", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 출원의 기술은 물리적 머신의 하드웨어의 이용율이 보다 낮은 문제점을 해결한다. 종래기술에 비해, 본 출원 은 Docker 컨테이너를 사용하여 그래픽 프로세서(GPU) 상에서 개발 키트 조작 임무를 수행한다. 이에 따라 직접 로컬 호스트의 운영체제를 이용할 수 있으므로, 물리적 머신의 하드웨어 이용율을 향상시킬 수 있다. 본 부분에 기재되는 내용은 본 출원의 실시예의 핵심 또는 중요 특징을 특정하려는 목적이 아니며, 본 출원의 범위를 한정하는 것도 아님을 이해하여야 한다. 본 출원의 기타 특징은 아래의 명세서로부터 쉽게 이해할 수 있 다."}
{"patent_id": "10-2021-0033233", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "아래에서는 첨부되는 도면을 결합하여 본 출원의 예시적 실시에 대해 설명하되, 여기에는 본 출원의 실시예의 다양한 세부 내용을 포함하여 쉽게 이해할 수 있도록 하며, 이들은 단지 예시적인 것으로 간주되어야 한다. 따 라서, 본 분야의 통상의 지식을 가진 자라면, 여기에 기재된 실시예에 대해 다양한 변경과 수정을 가할 수 있으 며, 이들은 본 출원의 범위와 정신을 벗어나지 않는다. 마찬가지로, 명확성과 간략성을 위하여, 아래의 기재에 서 공지 기능과 구조에 대한 설명을 생략한다. 현재 개발 키트의 주요한 방식은 플랫폼 가상화 기술을 통해 컴퓨터, 및 네트워크 하드웨어 사이에 하나의 추상 적인 가상화 플랫폼을 구축하여, 물리적 머신의 모든 하드웨어가 하나의 가상화 계층에 통합되도록 한다. 가상 화 플랫폼 상단에 물리적 머신과 동일한 하드웨어 구조를 가진 가상 머신이 구축되어 있으며, 개발자는 가상 머 신 상에서 개발 키트 조작 임무를 수행할 수 있다. 가상 머신은 서로 간섭하지 않으므로, 시스템 리소스를 보호 할 수 있다. 하지만, 가상 머신은 물리적 머신의 실제 하드웨어 계층에 대해 패키징하여야 하며, 가상화도 당연히 부분의 물 리적 머신의 리소스를 점용하게 되므로, 부분 물리적 머신의 성능이 손실되며, 이에 따라 물리적 머신의 하드웨 어 이용율이 보다 낮다. 본 출원은 개발 키트 조작 임무 처리 방법 및 장치에 관한 것으로서, 데이터 처리 중 인공지능의 딥러닝 분야에 속하며, 물리적 머신의 하드웨어 이용율이 낮은 기술문제를 해결하고, 물리적 머신의 하드웨어 이용율을 향상시 키는 효과를 달성한다. 본 출원의 발명 사상은, 개발 키트 조작 임무를 위해 개발 키트 조작 임무에 필요한 목 표 GPU를 할당하고, 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하고, 마스터 노드는 목표 동작 노드의 docker 컨테이너를 스케줄링하여 목표 GPU 상에서 개발 키트 조작 임무를 수행한다. 본 출원의 기술적 해결수단을 명확하게 이해할 수 있도록, 아래에서는 본 출원에 관련된 명사에 대해 해석한다. 개발 키트 : 개발자에게 제공되며, 소프트웨어 개발 과정에서 자체의 코드를 이용하여 소프트웨어 코드를 획득 하고, 획득한 코드에 대해 컴파일 및 디버그를 수행하는 소프트웨어 프로그램이다. Docker 컨테이너 : 오픈 소스인 애플리케이션 컨테이너 엔진으로서, 개발자가 통일된 방식으로 애플리케이션을 패키징하고 패키지를 이식 가능한 컨테이너로 이동시킨 다음, docker 엔진이 설치된 임의의 서버 상에 배포할 수 있다.스냅 사진 : 소정 데이터 집합에 대한 하나의 완전한 사용 가능 사본으로서, 해당 사본은 특정 시점에서의 해당 데이터의 이미지를 포함한다. 블록 기기 : 일종의 입출력(in/out, i/o) 장치로서, 정보를 고정된 크기의 블록에 저장한다. 아래에서는 본 출원의 사용 시나리오에 대해 설명한다. 도 1은 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 방법의 시나리오를 나타내는 도면이다. 도 1에 도시 된 바와 같이, 사용자는 개발 키트 구축, 개발 키트 삭제와 같은 개발 키트 조작 임무의 수행이 필요할 때, 클 라이언트를 통해 개발 키트 임무 처리 시스템의 임무 관리 서버로 임무 작성 요청을 발송할 수 있다. 임무 관리 서버는 클라이언트에서 발송한 임무 작성 요청을 수신한 후, 임무 작성 요청 중의 개발 키 트 조작 임무를 위해 개발 키트 조작 임무의 수행에 필요한 GPU를 할당한 다음, 클러스터 노드 중의 마스터 노 드로 개발 키트 조작 임무 요청을 발송하고, 마스터 노드는 동작 노드의 docker 컨테이너를 스 케줄링하여 목표 GPU 상에서 개발 키트 조작 임무를 수행한다. 여기서, 클라이언트는 태블릿, 개인용 컴퓨터(personal computer, PC), 노트북, 개인 휴대 단말(personal digital assistant, PDA), 핸드폰 등의 기기를 포함할 수 있지만, 이에 한정되지 않는다. 특별히 설명하면, 본 출원의 기술적 해결수단의 응용 시나리오는 도 1 중의 개발 키트 조작 임무의 처리 시나리 오일 수 있지만, 이에 한정되지 않으며, 기타 관련 시나리오에 응용될 수도 있다. 도 2는 본 출원의 실시예에 따른 일 개발 키트 조작 임무의 시스템 아키텍처 도면이다. 도 2는, 클라이언트, 임 무 관리 서버, 클러스터 노드, GPU 및 임무 데이터베이스를 나타낸다. 상기 클라이언트는 UI 인터페이스와 플랫 폼 계층을 포함하고, 사용자는 UI 인터페이스 상에서 조작하여 플랫폼 계층 중의 모듈이 Open API를 통해 임무 데이터베이스로 임무 작성 요청을 발송하도록 트리거한다. 임무 데이터베이스는 임무 작성 요청을 수신한 후, 임무 작성 요청을 임무 관리 서버로 발송한다. 임무 관리 서버는 복수의 서비스 유닛을 포함하며, 임무 관리 서 버는 임무 작성 요청에 대해 처리하고, 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송한 다. 클러스터 노드 중의 마스터 노드는 개발 키트 조작 임무 요청을 수신한 후, 목표 동작 노드의 docker 컨테 이너를 스케줄링하여 목표 GPU 상에서 개발 키트 조작 임무를 수행한다. 상술한 개발 키트 조작 임무 처리 방법은 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 장치를 통해 구현 될 수 있으며, 개발 키트 조작 임무 처리 장치는 어느 기기의 부분 또는 전부일 수 있고, 예를 들어 상기 임무 관리 서버와 클러스터 마스터 노드일 수 있음을 이해할 수 있다. 아래에서는 관련 수행 코드가 통합 또는 설치된 임무 관리 서버와 클러스터 마스터 노드를 예로 들어, 구체적인 실시예를 통해 본 출원의 실시예의 기술적 해결수단에 대해 상세하게 설명한다. 아래의 몇몇 구체적인 실시예는 서로 결합될 수 있고, 동일하거나 유사한 개념 또는 과정은 부분 실시예에서 상세한 설명을 생략할 수도 있다. 도 3은 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 방법의 시그널링 인터랙션 도면이다. 본 출원은 개 발 키트 조작 임무를 처리하는 것에 관한 것으로서, 도 3에 도시된 바와 같이, 해당 방법은 아래의 단계들을 포 함할 수 있다. S201, 임무 관리 서버는 클라이언트에서 개시한 임무 작성 요청을 수신한다. 여기서, 개발 키트 조작 임무는 개발 키트 구축, 개발 키트 삭제, 개발 키트 부팅 및 개발 키트 재설치 중 적어 도 하나를 포함하기 위한 것이다. 본 출원에서, 사용자는 개발 키트에 대해 조작해야 할 때, 클라이언트 상에서 조작하여, 클라이언트가 임무 작 성 요청을 발송하도록 할 수 있다. 일부 실시예에서, 클라이언트는 직접 임무 관리 서버로 임무 작성 요청을 발 송할 수 있다. 다른 일부 실시예에서, 클라이언트는 먼저 임무 데이터베이스로 임무 작성 요청을 발송할 수 있 다. 이어서, 임무 데이터베이스는 임무 작성 요청을 임무 관리 서버로 발송한다. S202, 임무 관리 서버는 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성한다. 본 단계에서, 임무 관리 서버는 클라이언트에서 개시한 임무 작성 요청을 수신한 후, 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성할 수 있다. 본 출원의 실시예는 어떻게 개발 키트 조작 임무를 생성하는지에 대해 한정하지 않는다. 예시적으로, 임무 작성 요청은 사용자가 입력한 임무 수요 데이터를 포함할 수 있다. 사용자가 입력한 임무 수요 데이터를 기초로, 임무 관리 서버는 개발 키트 조작 임무를 생성할 수 있다. 본 출원에서, 임무 관리 서버는 개발 키트 조작 임무를 생성한 후, 임무 대기 행렬에 개발 키트 조작 임무를 추 가할 수 있다. 본 출원의 실시예에서는 어떻게 임무 대기 행렬에 개발 키트 조작 임무를 추가하는지에 대해 한정하지 않는다는 점을 이해하여야 한다. 일부 실시예에서, 임무 관리 서버 중의 임무 스케줄링 프로그램(task scheduler) 서비스 유닛은 개발 키트 조작 임무를 스케줄링하고, 개발 키트 조작 임무의 유형을 기초로, 개발 키트 조작 임무를 대 응되는 임무 대기 행렬에 추가할 수 있다. S203, 임무 관리 서버는 개발 키트 조작 임무를 위해 개발 키트 조작 임무에 필요한 목표 GPU를 할당한다. 일부 실시예에서, 임무 관리 서버는 개발 키트 조작 임무에 필요한 리소스를 기초로, 조작 임무의 수행에 필요 한 목표 GPU를 할당할 수 있다. 다른 일부 실시예에서, 클러스터 중의 GPU의 실행 상황도 목표 GPU를 결정하기 위한 근거가 될 수 있다. 임무 수행 중인 GPU, 또는 고장 중인 GPU에 대하여, 임무 관리 서버는 이를 목표 GPU로 하는 것을 방지할 수 있다. 목표 GPU를 결정하는 과정에서, 임무 관리 서버는 또한 사용자의 권한을 체크할 수 있다는 것을 이해하여야 한 다. 예시적으로, 임무 관리 서버는 개발 키트 조작 임무가 소속되는 사용자 그룹을 결정할 수 있으며, 서로 다 른 사용자 그룹은 서로 다른 리소스 사용 권한에 대응된다. 이어서, 소속되는 사용자 그룹에 대응되는 리소스 사용 권한, 및 개발 키트 조작 임무에 필요한 리소스를 기초로, 임무 관리 서버는 조작 임무의 수행에 필요한 목표 GPU를 할당할 수 있다. 사용자 그룹은 직접 사용자와 묶여지지 않는다. 즉 사용자 그룹에 대해 특정 사용자를 수여함으로써, 해당 사용 자 그룹에 포함되는 사용자가 권한을 갖도록 하는 것이 아니다. 본 출원에서, 시스템 관리 모듈은 기설정된 엔 티티 테이블 및 관련 테이블을 조회하여, 사용자의 권한을 결정할 수 있다. 여기서, 엔티티 테이블은 권한 테이 블, 캐릭터 테이블, 사용자 테이블과 사용자 그룹 테이블 등을 포함할 수 있으며, 관련 테이블은 사용자 - 사용 자 그룹 관련 테이블, 캐릭터 - 사용자 그룹 관련 테이블과 권한 - 캐릭터 관련 테이블 등을 포함할 수 있다. 본 출원에서, 서로 다른 사용자 그룹을 위해 서로 다른 리소스 사용 권한을 설정한다. 이에 따라, 사용자 그룹 에 대응되는 리소스 사용 권한을 기초로 개발 키트 조작 임무에 필요한 목표 GPU를 할당할 수 있다. 이에 따라 사용자 그룹이 사용할 수 있는 리소스에 대해 합리적으로 관리 제어할 수 있다. 다른 일부 실시예에서, 임무 작성 요청은 개발 키트 조작 임무의 수행에 필요한 리소스 한도를 포함한다. 대응 되게, 임무 관리 서버는 개발 키트 조작 임무가 소속되는 사용자 그룹의 리소스 사용 한도를 결정한 후, 개발 키트 조작 임무에 필요한 리소스 한도와 사용자 그룹의 리소스 사용 한도를 비교할 수 있다. 만약 사용자 그룹 의 리소스 사용 한도가 개발 키트 조작 임무에 필요한 리소스량 이상이면, 조작 임무의 수행에 필요한 목표 GPU 를 할당한다. 만약 사용자 그룹의 리소스 사용 한도가 개발 키트 조작 임무에 필요한 리소스량보다 작으면, 클 라이언트로 에러 알림을 발송한다. 대응되게, 개발 키트 조작 임무 완성 후, 임무 관리 서버는 사용자 그룹의 리소스 사용 한도에서 개발 키트 조작 임무에 필요한 리소스량을 감산할 수 있다. 본 출원에서, 사용자 그룹을 위해 리소스 사용 한도를 설정함으로써, 사용자 그룹이 일정한 시간 동안에 리소스 사용 한도 이하의 리소스량만 사용하여 개발 키트 조작 임무를 수행할 수 있도록 함으로써, 사용자 그룹이 리소 스를 지나치게 사용하는 것을 방지한다. 사용자 그룹 관리자는 또한 오픈 애플리케이션 프로그래밍 인터페이스(open application programming interface, Open Api)를 호출하여, 사용자 그룹의 리소스 한도를 결정할 수도 있으며, 이로써 사용자 그룹이 사 용할 수 있는 리소스에 대해 제한한다. 일부 실시예에서, GPU 이용율이 높지 않은 개발 키트에 대하여, 시스템 관리 모듈은 또한 GPU의 이용율을 기초 로, 통보 심지어 리소스를 릴리스할 수도 있다. 예시적으로, 임무 관리 서버는 임무 데이터베이스에서 목표 GPU에 대한 개발 키트 조작 임무의 리소스 이용율을 조회할 수 있다. 만약 GPU에 대한 개발 키트 조작 임무의 리소스 이용율이 제1 임계값보다 낮으면, 임무 관리 서버는 마스터 노드로 임무 릴리스 지시를 발송하며, 임무 릴리스 지시는 목표 GPU 상에서 개발 키트 조작 임무 를 릴리스하도록 지시한다. 일부 실시예에서, GPU 이용율이 보다 높은 개발 키트에 대하여, 임무 관리 서버는 개발 키트 조작 임무를 위해 목표 GPU를 재할당할 수도 있다. 예시적으로, 임무 관리 서버는 임무 데이터베이스에서 목표 GPU의 리소스 이용율를 조회할 수 있다. 만약 목표 GPU의 리소스 이용율이 제2 임계값을 초과하면, 개발 키트 조작 임무를 위해 목표 GPU를 재할당한다. 재할당된 GPU를 기초로 마스터 노드로 개발 키트 조작 임무 요청을 발송한다. 본 출원에서, 상술한 방식을 통해, 임무 관리 서버는 개발 키트 조작 임무, 사용자 그룹 등에 대한 효율적인 관 리를 구현할 수 있으며, 이에 따라 개발자가 수동으로 개발 키트 유지 관리 문제를 처리할 필요가 없게 된다. S204, 임무 관리 서버는 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하되, 임무 요청은 목표 GPU 상에서 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것이다. 본 출원에서, 임무 관리 서버는 개발 키트 조작 임무를 위해 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당한 후, 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하며, 이에 따 라 목표 GPU 상에서 개발 키트 조작 임무를 수행한다. 본 출원의 실시예는 어떻게 개발 키트 조작 임무 요청을 클러스터 노드 중 마스터 노드로 발송하는지에 대해 한 정하지 않는다. 일부 실시예에서, 임무 처리(task worker) 서비스 유닛을 통해 개발 키트 조작 임무를 마스터 노드로 발송할 수 있다. 여기서, 클러스터 노드 사이는 구체적으로 Kubernetes(K8S) 아키텍처일 수 있다. 아래에서는 K8S 아키텍처에 대해 설명한다. K8S 아키텍처는 GPU를 하나의 마스터 노드(K8S Master)와 복수의 동 작 노드로 구분할 수 있다. 마스터 노드는 클러스터의 목표 상태를 유지하고, 클러스터 관리에 관한 한 세트의 프로세스를 실행시키는 기능을 수행한다. 해당 프로세스는 예를 들어 kube-apiserver, controller-manager와 scheduler일 수 있다. 상기 프로세스는 클러스터의 리소스 관리 및 동작 노드 상의 Pod(프로그래밍 언어임) 스 케줄링 등을 구현할 수 있다. 여기서, 동작 노드는 실제 애플리케이션 프로그램, 동작 노드 상의 K8S에서 관리 하는 최소 실행 유닛 pod, 및 kubelet, kube-proxy 프로세스를 실행한다. Kubelet와 kube-proxy 프로세스는 pod 작성, 부팅, 모니터링, 재부팅, 삭제 및 클러스터 내 서비스의 발견 및 부하 균형 등을 담당한다. 일부 선택적인 실시형태에서, 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하는 단계 이 후에, 임무 관리 서버는 또한 개발 키트 조작 임무에 대응되는 개발 키트의 스냅 사진에 대해 업데이트할 수 있 다. 스냅 사진은 개발 키트의 데이터 사이의 논리 관계이다. 특별히 설명하면, 개발 키트의 스냅 사진의 업데이트는 개발 키트의 스냅 사진의 작성과 개발 키트의 스냅 사진 의 삭제를 포함할 수 있다. 개발 키트의 스냅 사진에 대해 업데이트하는 것은 구체적으로 task worker 서비스 유닛을 통해 완성될 수 있다. 일부 선택적인 실시형태에서, 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하는 단계 이 후에, 임무 관리 서버는 또한 개발 키트 조작 임무에 필요한 블록 기기를 결정할 수 있으며, 블록 기기는 개발 키트 조작 임무를 위해 저장 리소스를 요청하기 위한 것이다. 개발 키트 조작 임무에 필요한 블록 기기에 대해 업데이트하는 것은 구체적으로 임무 관리 모듈 중의 임무 상태 동기화(task status sync) 서비스 유닛을 통해 완성될 수 있다. 한편, task status sync 서비스 유닛은 또한 클러스터 노드에 대해 모니터링할 수 있다. S205, 마스터 노드는 클러스터 노드 중 복수의 동작 노드의 실행 상태를 기초로, 목표 동작 노드를 결정한다. 본 출원의 실시예는 마스터 노드가 어떻게 클러스터 노드 중 복수의 동작 노드의 실행 상태를 기초로 목표 동작 노드를 결정하는지에 대해 한정하지 않는다. 예시적으로, 마스터 노드는 우선 요구를 만족하는 동작 노드의 실행 상태를 결정한 후, 이로부터 목표 동작 노 드를 선택할 수 있다. 예시적으로, 마스터 노드는 우선 고장이 발생한 동작 노드를 결정한 후, 고장이 발생한 동작 노드 이외의 동작 노드로부터 목표 동작 노드를 결정할 수 있다. S206, 마스터 노드는 목표 동작 노드의 docker 컨테이너를 스케줄링하여 목표 GPU 상에서 개발 키트 조작 임무 를 수행하도록 한다. 본 단계에서, 마스터 노드는 클러스터 노드 중 복수의 동작 노드의 실행 상태를 기초로, 목표 동작 노드를 결정 한 후, 목표 동작 노드의 docker 컨테이너를 스케줄링하여 목표 GPU 상에서 개발 키트 조작 임무를 수행하도록할 수 있다. 일부 실시예에서, 마스터 노드는 목표 동작 노드의 개발 키트 조작 임무의 수행 진도와 개발 키트 조작 임무에 대응되는 개발 키트의 상태를 모니터링하고, 개발 키트 조작 임무의 수행 진도와 개발 키트 조작 임무에 대응되 는 개발 키트의 상태를 임무 데이터베이스로 발송할 수도 있다. 일부 실시예에서, 마스터 노드는 목표 GPU에 대한 개발 키트 조작 임무의 리소스 이용율을 모니터링하고, 목표 GPU의 리소스 이용율을 임무 데이터베이스로 발송할 수도 있다. 일부 실시예에서, 마스터 노드는 또한 개발 키트 조작 임무에 대응되는 개발 키트의 실행 환경과 실행 데이터를 원격 마운트하는 방식으로 백업 서버 상에 저장한다. 목표 GPU에 고장이 발생한 후, 백업 서버에 저장된 개발 키트의 실행 환경과 실행 데이터를 기초로, 기타 GPU 상에서 신속하게 개발 키트에 대해 복구하여, 계속하여 개 발 키트 조작 임무를 수행할 수 있다. 이해해야 할 바로는, 마스터 노드가 목표 동작 노드의 docker 컨테이너를 스케줄링하여 개발 키트 조작 임무를 수행할 때, 직접 로컬 호스트의 운영체제를 이용할 수 있으므로, 시스템 리소스에 대한 이용율이 더 높다. 애플 리케이션 수행 속도가 더 빠르고, 메모리 소모가 더 낮으며 파일 저장 속도가 더 빠르게 된다. 동시에, docker 컨테이너를 사용하여 MB 수준의 자기 디스크만 점용함으로써, 가상 머신의 GB 수준의 자기 디스크 점용에 비해, 물리적 머신 리소스에 대한 점용이 더 적고, 머신 당 지원 수량이 천여개에 달할 수 있다. docker 컨테이너 애플리케이션은 직접 호스트 커널에서 실행되므로, 완전한 운영체제를 부팅시킬 필요가 없게 된다. 따라서, 종래기술에 따른 가상 머신에 비해, 컨테이너화 관리 모듈이 docker 컨테이너를 사용함으로써 개 발 키트의 조작 시간을 대폭 절약할 수 있으며, 그 조작 시간은 초 수준 심지어 밀리초 수준에 도달할 수 있다. 이해해야 할 바로는, 개발 키트의 스냅 사진 중 docker의 이미지를 통해, 커널 이외의 완전한 실행 시 환경을 제공할 수 있으며, 이에 따라 환경 일치성을 확보한다. 동시에, 맞춤형 애플리케이션의 docker 이미지를 통해 개발 키트 환경 배포가 복잡하고 어려운 문제점을 해결할 수 있다. 이해해야 할 바로는, 컨테이너화 관리 모듈은 개발 키트 조작 임무를 수행하는 동시에, 또한 개발 키트 조작 임 무에 대응되는 개발 키트의 실행 환경과 실행 데이터를 원격 마운트 방식으로 백업 서버 상에 저장할 수 있다. 백업 서버를 통해, 만약 개발 키트 임무 처리 시스템 중 물리적 머신에 다운, 고장 등의 문제가 발생할 경우, 신속하게 개발 키트 인스턴스를 기타 물리적 머신 상으로 옮겨, 데이터 안전을 확보함과 동시에, 개발자가 기계 고장으로 인하여 대기하는 시간을 줄일 수 있다. 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 방법에 따르면, 임무 관리 서버는 클라이언트에서 개시한 임무 작성 요청을 수신한 후, 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성한다. 다음, 임무 관리 서 버는 개발 키트 조작 임무를 위해 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당하고, 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하며, 해당 임무 요청은 목표 GPU 상에서 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것이다. 종래기술에 비해, 본 출원은 docker 컨 테이너를 사용하여 GPU 상에서 개발 키트 조작 임무를 수행한다. 이에 따라 직접 로컬 호스트의 운영체제를 이 용할 수 있으므로, 물리적 머신의 하드웨어 이용율을 향상시킨다. 상술한 실시예의 기초 상에서, 아래에서는 어떻게 개발 키트 조작 임무를 위해 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당하는지에 대해 설명한다. 도 4는 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 방법의 흐름도이다. 해당 방법은 아래의 단계들을 포함한다. S301, 임무 관리 서버는 클라이언트에서 개시한 임무 작성 요청을 수신한다. S302, 임무 관리 서버는 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성한다. S301 - S302의 기술 명사, 기술 효과, 기술 특징, 및 선택적인 실시형태는, 도 3에 도시된 S201 - S202를 참조 하여 이해할 수 있으며, 여기서는 중복되는 내용에 대한 설명을 생략한다. S303, 임무 관리 서버는 개발 키트 조작 임무가 소속되는 사용자 그룹을 결정하되, 서로 다른 사용자 그룹은 서 로 다른 리소스 사용 권한에 대응된다. 예시적으로, 임무 관리 서버는 클라이언트에 로그인된 사용자 정보를 기초로, 개발 키트 조작 임무가 소속되는 사용자 그룹을 결정할 수 있다.사용자 그룹은 직접 사용자와 묶여지지 않는다. 즉 사용자 그룹에 대해 특정 사용자를 수여함으로써, 해당 사용 자 그룹에 포함되는 사용자가 권한을 갖도록 하는 것이 아니다. 본 출원에서, 시스템 관리 모듈은 기설정된 엔 티티 테이블 및 관련 테이블을 조회하여, 사용자의 권한을 결정할 수 있다. 여기서, 엔티티 테이블은 권한 테이 블, 캐릭터 테이블, 사용자 테이블과 사용자 그룹 테이블 등을 포함할 수 있으며, 관련 테이블은 사용자 - 사용 자 그룹 관련 테이블, 캐릭터 - 사용자 그룹 관련 테이블과 권한 - 캐릭터 관련 테이블 등을 포함할 수 있다. S304, 임무 관리 서버는 개발 키트 조작 임무가 소속되는 사용자 그룹에 대응되는 리소스 사용 권한, 및 개발 키트 조작 임무에 필요한 리소스를 기초로, 조작 임무의 수행에 필요한 목표 GPU를 할당한다. 본 단계에서, 서로 다른 사용자 그룹은 서로 다른 리소스 사용 권한이 대응되게 존재한다. 임무 관리 서버는 리 소스 사용 권한을 가진 GPU에서 조작 임무에 필요한 목표 GPU를 결정할 수 있다. S305, 임무 관리 서버는 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하되, 임무 요청은 목표 GPU 상에서 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것이다. S305의 기술 명사, 기술 효과, 기술 특징, 및 선택적인 실시형태는, 도 3에 도시된 S204를 참조하여 이해할 수 있으며, 여기서는 중복되는 내용에 대한 설명을 생략한다. 상술한 실시예의 기초 상에서, 도 5는 본 출원의 실시예에 따른 다른 개발 키트 조작 임무 처리 방법의 흐름도 이다. 해당 방법은 아래의 단계들을 포함한다. S401, 임무 관리 서버는 클라이언트에서 개시한 임무 작성 요청을 수신한다. S402, 임무 관리 서버는 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성한다. S403, 임무 관리 서버는 개발 키트 조작 임무가 소속되는 사용자 그룹을 결정하되, 서로 다른 사용자 그룹은 서 로 다른 리소스 사용 권한에 대응된다. S401 - S402의 기술 명사, 기술 효과, 기술 특징, 및 선택적인 실시형태는, 도 4에 도시된 S301 - S303을 참조 하여 이해할 수 있으며, 여기서는 중복되는 내용에 대한 설명을 생략한다. S404, 임무 관리 서버는 개발 키트 조작 임무가 소속되는 사용자 그룹의 리소스 사용 한도를 결정한다. 여기서, 사용자 그룹의 리소스 사용 한도는 사용자 그룹에서 신청하고, 관리자가 동의한 후 결정될 수 있다. 사 용자 그룹의 리소스 사용 한도가 결정된 후, 사용자 그룹이 리소스를 사용할 때마다, 임무 관리 서버는 모두 사 용자 그룹의 리소스 사용 한도로부터 사용한 리소스량을 감산한다. S405, 만약 사용자 그룹의 리소스 사용 한도가 개발 키트 조작 임무에 필요한 리소스량 이상이면, 임무 관리 서 버는 조작 임무의 수행에 필요한 목표 GPU를 할당한다. 본 출원에서, 임무 관리 서버는 개발 키트 조작 임무가 소속되는 사용자 그룹의 리소스 사용 한도를 결정한 후, 개발 키트 조작 임무에 필요한 리소스 한도와 사용자 그룹의 리소스 사용 한도를 비교할 수 있다. 만약 사용자 그룹의 리소스 사용 한도가 개발 키트 조작 임무에 필요한 리소스량 이상이면, 조작 임무 수행에 필요한 목표 GPU를 할당한다. 만약 사용자 그룹의 리소스 사용 한도가 개발 키트 조작 임무에 필요한 리소스량보다 작으면, 클라이언트로 에러 알림를 발송한다. S406, 임무 관리 서버는 사용자 그룹의 리소스 사용 한도에서 개발 키트 조작 임무에 필요한 리소스량을 감산한 다. 본 출원의 실시예에 따른 개발 키트 조작 임무의 처리 방법에 따르면, 임무 관리 서버는 클라이언트에서 개시한 임무 작성 요청을 수신한 후, 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성한다. 다음, 임무 관리 서 버는 개발 키트 조작 임무를 위해 개발 키트 조작 임무의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당하고, 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하며, 해당 임무 요청은 목표 GPU 상에서 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것이다. 종래기술에 비해, 본 출원은 docker 컨 테이너를 사용하여 GPU 상에서 개발 키트 조작 임무를 수행한다. 이에 따라 직접 로컬 호스트의 운영체제를 이 용할 수 있으므로, 물리적 머신의 하드웨어 이용율을 향상시킨다. 본 분야의 통상의 지식을 가진 자라면, 상기 방법 실시예를 구현하는 전부 또는 부분 단계는 프로그램 정보 관 련 하드웨어를 통해 완성될 수 있음을 이해할 수 있다. 상기 프로그램은 컴퓨터 판독 가능 저장매체에 저장될 수 있다. 해당 프로그램은 수행될 때, 상술한 방법 실시예의 단계를 수행하고; 상기 저장매체는 ROM, RAM, 자기디스크 또는 광 디스크와 같은 프로그램 코드를 저장할 수 있는 다양한 매체를 포함할 수 있다. 도 6은 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 장치의 구성도이다. 해당 개발 키트 조작 임무 처리 장치는 소프트웨어, 하드웨어 또는 이들의 결합으로 구현될 수 있다. 예를 들어 상술한 임무 관리 서버 또는 임 무 관리 서버 중의 칩은 상술한 개발 키트 조작 임무 처리 방법을 수행하기 위한 것이다. 도 6에 도시된 바와 같이, 해당 개발 키트 조작 임무 처리 장치는, 클라이언트에서 개시한 임무 작성 요청을 수신하는 수신모듈; 임무 작성 요청을 기초로, 개발 키트 조작 임무를 생성하고; 개발 키트 조작 임무를 위해 개발 키트 조작 임무 의 수행에 필요한 목표 그래픽 프로세서(GPU)를 할당하는 처리모듈; 클러스터 노드 중의 마스터 노드로 개발 키트 조작 임무 요청을 발송하되, 임무 요청은 목표 GPU 상에서 개발 키트 조작 임무를 수행할 것을 요청하기 위한 것인 발송모듈;을 포함한다. 일 가능한 실시형태에서, 여기서, 처리모듈은 구체적으로 개발 키트 조작 임무가 소속되는 사용자 그룹을 결정하되, 서로 다른 사용자 그룹은 서로 다른 리소스 사용 권한에 대응되고; 개발 키트 조작 임무가 소속되는 사용자 그룹에 대응되는 리소스 사용 권한, 및 개발 키트 조작 임무에 필요한 리소스를 기초로, 조작 임무 수행 에 필요한 목표 GPU를 할당한다. 일 가능한 실시형태에서, 처리모듈은 또한 개발 키트 조작 임무가 소속되는 사용자 그룹의 리소스 사용 한 도를 결정하고; 만약 사용자 그룹의 리소스 사용 한도가 개발 키트 조작 임무에 필요한 리소스량 이상이면, 조 작 임무 수행에 필요한 목표 GPU를 할당한다. 일 가능한 실시형태에서, 처리모듈은 또한 사용자 그룹의 리소스 사용 한도로부터 개발 키트 조작 임무에 필요한 리소스량을 감산한다. 일 가능한 실시형태에서, 여기서, 처리모듈은 또한 임무 데이터베이스에서 목표 GPU에 대한 개발 키트 조 작 임무의 리소스 이용율을 조회하고; 만약 목표 GPU에 대한 개발 키트 조작 임무의 리소스 이용율이 제1 임계 값보다 낮으면, 마스터 노드로 임무 릴리스 지시를 발송하되, 임무 릴리스 지시는 목표 GPU 상에서 개발 키트 조작 임무를 릴리스할 것을 지시한다. 일 가능한 실시형태에서, 여기서, 처리모듈은 또한 임무 데이터베이스에서 목표 GPU의 리소스 이용율을 조 회하고; 만약 목표 GPU의 리소스 이용율이 제2 임계값을 초과하면, 개발 키트 조작 임무를 위해 목표 GPU를 재 할당하고; 재할당된 GPU를 기초로 마스터 노드로 개발 키트 조작 임무 요청을 발송한다. 일 가능한 실시형태에서, 처리모듈은 또한 개발 키트 조작 임무에 대응되는 개발 키트의 스냅 사진에 대해 업데이트하되, 스냅 사진은 개발 키트의 데이터 사이의 논리 관계이다. 일 가능한 실시형태에서, 처리모듈은 또한 개발 키트 조작 임무에 필요한 블록 기기를 결정하되, 블록 기 기는 개발 키트 조작 임무를 위해 저장 리소스를 요청한다. 일 가능한 실시형태에서, 개발 키트 조작 임무는 개발 키트 구축, 개발 키트 삭제, 개발 키트 재부팅 및 개발 키트 재설치 중 적어도 하나를 포함한다. 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 장치는, 상술한 방법 실시예 중 개발 키트 조작 임무 처리 방법 중 임무 관리 서버 측의 동작을 수행할 수 있으며, 그 구현원리 기술효과는 유사하므로, 여기서는 중복되 는 설명을 생략한다. 도 7은 본 출원의 실시예에 따른 다른 개발 키트 조작 임무 처리 장치의 구성도이다. 해당 개발 키트 조작 임무 처리 장치는 소프트웨어, 하드웨어 또는 이들의 결합으로 구현될 수 있다. 예를 들어 상술한 마스터 노드 또는 마스터 노드 중 칩은 상술한 개발 키트 조작 임무 처리 방법을 수행한다. 도 7에 도시된 바와 같이, 해당 개발 키트 조작 임무 처리 장치는, 임무 관리 서버에서 발송한 개발 키트 조작 임무 요청을 수신하되, 임무 요청은 목표 GPU 상에서 개발 키트 조 작 임무를 수행할 것을 요청하기 위한 것인 수신모듈; 클러스터 노드 중 복수의 동작 노드의 실행 상태를 기초로, 목표 동작 노드를 결정하고; 목표 동작 노드의 docker 컨테이너를 스케줄링하여 목표 GPU 상에서 개발 키트 조작 임무를 수행하는 처리모듈을 포함한다. 일 가능한 실시형태에서, 처리모듈은 또한 목표 동작 노드의 개발 키트 조작 임무의 수행 진도와 개발 키 트 조작 임무에 대응되는 개발 키트의 상태를 모니터링한다. 장치는, 개발 키트 조작 임무의 수행 진도와 개발 키트 조작 임무에 대응되는 개발 키트의 상태를 임무 데이터 베이스로 발송하는 발송모듈을 더 포함한다. 일 가능한 실시형태에서, 처리모듈은 또한 목표 GPU에 대한 개발 키트 조작 임무의 리소스 이용율을 모니 터링한다. 발송모듈은 또한 목표 GPU의 리소스 이용율을 임무 데이터베이스로 발송한다. 일 가능한 실시형태에서, 개발 키트 조작 임무는 개발 키트 구축, 개발 키트 삭제, 개발 키트 재부팅, 개발 키 트 재설치 중 적어도 하나를 포함한다. 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 장치는 상술한 방법 실시예 중의 개발 키트 조작 임무 처리 방법 중 마스터 노드 측의 동작을 수행할 수 있으며, 그 구현원리 기술효과는 유사하므로, 여기서는 중복되는 설명을 생략한다. 본 출원의 실시예에 따르면, 본 출원은 전자기기와 판독 가능 저장매체를 더 제공한다. 도 8에 도시된 바와 같이, 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 방법을 구현할 수 있는 전자기기 의 블록도이다. 전자기기는 다양한 형태의 디지털 컴퓨터, 예컨대, 랩톱 컴퓨터, 데스크톱 컴퓨터, 워크 스테이 션, 개인 휴대 단말, 서버, 블레이드 서버, 대형 컴퓨터, 및 기타 적합한 컴퓨터를 의미한다. 전자기기는 다양 한 형태의 이동장치, 예컨대, 개인 디지털 처리, 셀폰, 스마트 폰, 웨어러블 기기 및 기타 유사한 컴퓨팅 장치 를 의미할 수도 있다. 본문에 개시된 부재, 이들의 연결 및 관계, 및 이들의 기능은 단지 예시적인 것이며, 본 문에 개시된 것 및/또는 요구하는 본 출원의 구현을 한정하려는 의도가 아니다. 도 8에 도시된 바와 같이, 해당 전자기기는 하나 또는 복수의 프로세서, 메모리, 및 각 부재를 연결 시키기 위한 고속 인터페이스와 저속 인터페이스를 포함하는 인터페이스를 포함한다. 각각의 부재는 서로 다른 버스를 통해 서로 연결되며, 공통 메인보드에 장착되거나 수요에 따라 기타 방식으로 장착될 수 있다. 프로세서 는 전자기기 내에서 실행되는 명령을 처리할 수 있으며, 메모리 내 또는 메모리 상에 저장되어 외부 입력/출력 장치(예컨대, 인터페이스에 커플링된 디스플레이 기기) 상에 GUI의 그래픽 정보를 표시하는 명령을 포함할 수 있다. 기타 실시형태에서, 수요에 따라, 복수의 프로세서 및/또는 복수의 버스와 복수의 메모리를 같이 사용할 수 있다. 마찬가지로, 복수의 전자기기를 연결할 수 있으며, 각각의 기기는 부분 필요한 조작을 제공한다(예를 들어, 서버 어레이, 한 세트의 블레이드 서버, 또는 멀티 프로세서 시스템으로서). 도 8은 하나의 프로세서 를 예로 든다. 메모리는 바로 본 출원에 따른 비일시적 컴퓨터 판독 가능 저장매체이다. 여기서, 메모리는 적어도 하나의 프로세서에 의해 실행될 수 있는 명령이 저장되어, 적어도 하나의 프로세서가 본 출원에 따른 개발 키트 조작 임무 처리 방법을 수행하도록 한다. 본 출원의 비일시적 컴퓨터 판독 가능 저장매체는 컴퓨터 명령을 저장하고, 해당 컴퓨터 명령은 컴퓨터가 본 출원에 따른 개발 키트 조작 임무 처리 방법을 수행하도록 한다. 메모리는 비일시적 컴퓨터 판독 가능 저장매체로서, 비일시적 소프트웨어 프로그램, 비일시적 컴퓨터 실행 가능 프로그램 및 모듈, 예컨대 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 방법에 대응되는 프로그램 명령/모듈(예를 들어, 도 5 및 도6에 도시된 수신모듈, 처리모듈 및 발송모듈)을 저장할 수 있다. 프로세서 는 메모리에 저장된 비일시적 소프트웨어 프로그램, 명령 및 모듈을 실행하여, 서버의 다양한 기능 응용 및 데이터 처리를 수행한다. 즉, 상술한 방법 실시예 중 개발 키트 조작 임무 처리 방법을 구현한다. 메모리는 프로그램 저장 영역과 데이터 저장 영역을 포함할 수 있다. 여기서, 프로그램 저장 영역은 운영 체제, 적어도 하나의 기능에 필요한 응용 프로그램을 저장할 수 있다. 데이터 저장 영역은 개발 키트 조작 임무 의 처리에 따른 전자기기의 사용에 따라 작성되는 데이터 등을 저장할 수 있다. 한편, 메모리는 고속 랜덤 액세스 메모리를 포함할 수 있고, 예를 들어 적어도 하나의 자기 저장 장치, 플래시 메모리, 또는 기타 비일시 적 솔리드 스테이트 저장 장치와 같은 비일시적 메모리를 포함할 수도 있다. 일부 실시예에서, 메모리는 선택적으로 프로세서에 대해 원격으로 설치되는 메모리를 포함할 수 있다. 이러한 원격 메모리는 네트워크 를 통해 개발 키트 조작 임무를 처리하는 전자기기에 연결될 수 있다. 상술한 네트워크의 실예로서 인터넷, 인 트라넷, 근거리 통신망, 이동 통신망 및 그 조합을 포함하지만 이에 한정되지 않는다. 개발 키트 조작 임무 처리 방법의 전자기기는 입력장치와 출력장치를 더 포함할 수 있다. 프로세서 , 메모리, 입력장치 및 출력장치는 버스 또는 기타 방식으로 연결될 수 있으며, 도 8에서는 버스를 통해 연결되는 것을 예시하고 있다. 입력장치는 입력되는 숫자 또는 문자 부호 정보를 수신할 수 있고, 개발 키트 조작 임무를 처리하는 전자 기기의 사용자 설정 및 기능 제어에 대한 키 신호 입력을 생성할 수 있다. 예를 들어 터치 스크린, 키패드, 마 우스, 트랙패드, 터치패널, 지시레버, 하나 또는 복수의 마우스 버튼, 트랙 볼, 조종 레버 등의 입력장치가 있 다. 출력장치는 디스플레이 기기, 보조 조명 장치(예를 들어, LED) 및 촉각 피드백 장치(예를 들어, 진동 모터) 등을 포함할 수 있다. 해당 디스플레이 기기는, 액정 디스플레이(LCD), 발광 다이오드(LED) 디스플레이와 플라즈마 디스플레이 등을 포함할 수 있지만 이에 한정되지 않는다. 일부 실시형태에서, 디스플레이 기기는 터 치 스크린일 수 있다. 여기에 기재되는 시스템 및 기술의 다양한 실시형태는 디지털 전자 회로 시스템, 집적 회로 시스템, ASIC(전용 집적 회로), 컴퓨터 하드웨어, 펌웨어, 소프트웨어, 및/또는 이들의 조합에서 구현될 수 있다. 이러한 다양한 실시형태는 하나 또는 복수의 컴퓨터 프로그램에서 구현되는 것을 포함할 수 있고, 해당 하나 또는 복수의 컴퓨 터 프로그램은 적어도 하나의 프로그래머블 프로세서를 포함하는 프로그래머블 시스템 상에서 실행 및/또는 해 석될 수 있으며, 해당 프로그래머블 프로세서는 전용 또는 범용 프로그래머블 프로세서일 수 있고, 저장 시스템, 적어도 하나의 입력장치, 및 적어도 하나의 출력장치로부터 데이터와 명령을 수신할 수 있으며, 데이터 와 명령을 해당 저장 시스템, 해당 적어도 하나의 입력장치, 및 해당 적어도 하나의 출력장치로 전송한다. 이러한 컴퓨터 프로그램(프로그램, 소프트웨어, 소프트웨어 응용, 또는 코드라고도 지칭)은 프로그래머블 프로 세서의 기계적 명령을 포함하고, 고급 프로세스 및/또는 객체 지향 프로그래밍 언어, 및/또는 어셈블리/기계적 언어를 이용하여 이러한 컴퓨터 프로그램을 실행할 수 있다. 예컨대 본문에서 사용되는 용어 \"기계 판독 가능 매체\"와 \"컴퓨터 판독 가능 매체\"는 기계적 명령 및/또는 데이터를 프로그래머블 프로세서로 제공하기 위한 임 의의 컴퓨터 프로그램 제품, 기기, 및/또는 장치(예를 들어, 자기 디스크, 광 디스크, 메모리, 프로그래머블 논 리 디바이스(PLD))를 가리키고, 기계 판독 가능 신호인 기계적 명령을 수신하는 기계 판독 가능 매체를 포함한 다. 용어 \"기계 판독 가능 신호\"는 기계적 명령 및/또는 데이터를 프로그래머블 프로세서로 제공하기 위한 임의 의 신호를 가리킨다. 사용자와의 인터랙션을 제공하기 위하여, 컴퓨터 상에서 여기에 기재되는 시스템 및 기술을 실시할 수 있으며, 해당 컴퓨터는 사용자에게 정보를 표시하기 위한 표시장치(예를 들어, CRT(캐소드레이 튜브) 또는 LCD(액정 디 스플레이) 모니터); 및 키보드와 지향 장치(예를 들어, 마우스 또는 트랙볼)를 구비하고, 사용자는 해당 키보드 와 해당 지향 장치를 통해 입력을 컴퓨터로 제공할 수 있다. 기타 종류의 장치는 사용자와의 인터랙션을 제공할 수도 있다. 예를 들어, 사용자에게 제공되는 피드백은 임의의 형태의 센싱 피드백(예를 들어, 시각적 피드백, 청각적 피드백, 또는 촉각적 피드백)일 수 있고; 임의의 형태(사운드 입력, 음성 입력 또는 촉각 입력)을 통해 사용자로부터의 입력을 수신할 수 있다. 여기에 기재되는 시스템과 기술은 백그라운드 부재를 포함하는 컴퓨팅 시스템(예를 들어, 데이터 서버로서), 또 는 중간부재를 포함하는 컴퓨팅 시스템(예를 들어, 응용 서버), 또는 프론트 엔드 부재를 포함하는 컴퓨팅 시스 템(예를 들어, 그래픽 유저 인터페이스 또는 인터넷 브라우저를 구비하는 사용자 컴퓨터, 사용자는 해당 그래픽 유저 인터페이스 또는 해당 인터넷 브라우저를 통해 여기에 기재되는 시스템 및 기술의 실시형태와 인터랙션할 수 있다), 또는 이러한 백그라운드 부재, 중간 부재, 또는 프론트 엔드 부재를 포함하는 임의의 조합의 컴퓨팅 시스템에서 실시될 수 있다. 임의의 형태 또는 매체의 디지털 데이터 통신(예를 들어, 통신 네트워크)을 통해 시스템의 부재를 서로 연결시킬 수 있다. 통신 네트워크의 예시로서, 근거리 통신망(LAN), 광역 통신망(WAN) 및 인터넷을 포함한다. 컴퓨터 시스템은 클라이언트와 서버를 포함할 수 있다. 클라이언트와 서버는 일반적으로 서로 멀리 떨어져 있으 며, 통상적으로 통신 네트워크를 통해 인터랙션한다. 상응한 컴퓨터 상에서 실행되며 서로 클라이언트 - 서버 관계를 가지는 컴퓨터 프로그램을 통해 클라이언트와 서버의 관계를 생성한다. 본 출원의 실시예는 칩을 더 제공하며, 프로세서와 인터페이스를 포함한다. 여기서 인터페이스는 프로세서에 의 해 처리되는 데이터 또는 명령을 입출력하기 위한 것이다. 프로세서는 상술한 방법 실시예에서 제공하는 방법을 수행한다. 해당 칩은 애플리케이션 서버에 응용될 수 있다. 본 출원은 컴퓨터 판독 가능 저장매체를 더 제공한다. 해당 컴퓨터 판독 가능 저장매체는, U 디스크, 이동 하드 디스크, 판독 전용 메모리(ROM, Read-Only Memory), 랜덤 액세스 메모리(RAM, Random Access Memory), 자기 디 스크 또는 광 디스크와 같은 다양한 프로그램 코드를 저장할 수 있는 매체를 포함할 수 있으며, 구체적으로 해당 컴퓨터 판독 가능 저장매체는 프로그램 정보가 저장되며, 프로그램 정보는 상술한 방법에 사용된다. 본 출원의 실시예는 프로그램을 더 제공하며, 해당 프로그램은 프로세서에서 실행될 때 상술한 방법 실시예에 따른 방법을 수행하기 위한 것이다. 본 출원의 실시예는 프로그램 제품, 예를 들어 컴퓨터 판독 가능 저장매체를 더 제공한다. 해당 프로그램 제품 에 명령이 저장되어 있으며, 컴퓨터상에서 실행될 때, 컴퓨터가 상술한 방법 실시예에 따른 방법을 수행하도록 한다. 본 출원의 실시예의 기술적 해결수단은 물리적 머신의 하드웨어 이용율이 보다 낮은 문제점을 해결한다. 종래기 술에 비해, 본 출원은 Docker 컨테이너를 통해 그래픽 프로세서(GPU) 상에서 개발 키트 조작 임무를 수행한다. 이에 따라 직접 로컬 호스트의 운영체제를 이용할 수 있으므로, 물리적 머신의 하드웨어의 이용율을 향상시킬 수 있다. 상술한 다양한 형태의 프로세스를 사용하여 단계를 재배열, 추가 또는 삭제할 수 있다. 예를 들어, 본 출원에 기재된 각 단계는 병열로 수행될 수 있고 순차적으로 수행될 수도 있고 서로 다른 순서로 수행될 수도 있으며, 본 출원에 개시된 기술적 해결수단이 원하는 결과를 얻을 수만 있다면, 본문은 이에 대해 한정하지 않는다. 상술한 구체적인 실시형태는 본 출원의 보호범위에 대한 한정이 아니다. 본 분야의 통상의 지식을 가진 자라면, 설계 요구와 기타 요소를 기초로, 다양한 수정, 조합, 서브 조합 및 대체를 가할 수 있음을 이해할 수 있을 것 이다. 본 출원의 정신과 원칙 내에서 이루어진 모든 수정, 동등한 치환 및 개선 등은 모두 본 출원의 보호 범위 내에 속하는 것으로 간주하여야 한다."}
{"patent_id": "10-2021-0033233", "section": "도면", "subsection": "도면설명", "item": 1, "content": "첨부되는 도면은 본 해결수단을 더 충분히 이해하기 위한 것으로서, 본 출원에 대한 한정은 아니다. 도 1은 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 방법의 시나리오를 나타내는 도면이다. 도 2는 본 출원의 실시예에 따른 개발 키트 조작 임무의 시스템 아키텍처 도면이다. 도 3은 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 방법의 시그널링 상호 작용 도면이다. 도 4는 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 방법의 흐름도이다. 도 5는 본 출원의 실시예에 따른 다른 개발 키트 조작 임무 처리 방법의 흐름도이다. 도 6은 본 출원의 실시예에 따른 개발 키트 조작 임무 처리 장치의 구성도이다. 도 7은 본 출원의 실시예에 따른 다른 개발 키트 조작 임무 처리 장치의 구성도이다. 도 8은 본 출원의 실시예의 개발 키트 조작 임무 처리 방법을 구현할 수 있는 전자기기의 블록도이다."}
