{"patent_id": "10-2022-0123200", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0053509", "출원번호": "10-2022-0123200", "발명의 명칭": "딥러닝 프로그램 실행 방법 및 장치", "출원인": "서울대학교산학협력단", "발명자": "김태범"}}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "명령형 딥러닝 프로그램(imperative deep learning program)에 대응하는 심볼릭 그래프(symbolic graph)를 생성하는 단계;상기 명령형 딥러닝 프로그램을 딥러닝 연산(computation)과 관련된 제1 부분과 상기 딥러닝 연산과 관련없는제2 부분으로 구분하는 단계; 및그래프 실행기(graph runner)를 이용하여 상기 제1 부분에 대한 연산을 수행하는 동시에 언어 실행기(languagerunner)를 이용하여 상기 제2 부분에 대한 연산을 수행하는 단계를 포함하는 명령형 딥러닝 프로그램 실행 방법."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 심볼릭 그래프를 생성하는 단계는명령형 딥러닝 프로그램(imperative deep learning program)에 대하여 명령형 수행(imperative execution)을반복하는 단계; 및상기 반복된 명령형 수행 각각에 대응하는 복수의 트레이스들(traces)을 수집(collect)하는 단계를 더 포함하는, 명령형 딥러닝 프로그램 실행 방법."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 심볼릭 그래프를 생성하는 단계는그래프 생성기(graph generator)를 이용하여, 상기 수집된 트레이스들에 대응하는 트레이스 그래프(tracegraph)를 생성하는 단계; 및상기 그래프 생성기를 이용하여, 상기 트레이스 그래프에 기초하여 상기 심볼릭 그래프를 생성하는 단계를 더 포함하는, 명령형 딥러닝 프로그램 실행 방법."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 트레이스 그래프를 생성하는 단계는상기 수집된 트레이스들 사이에 동일한 노드가 있는지 판단하는 단계; 및상기 판단 결과에 기초하여, 상기 수집된 트레이스들을 병합(merge)하는 단계를 포함하는, 명령형 딥러닝 프로그램 실행 방법."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "공개특허 10-2023-0053509-3-제1항에 있어서,상기 심볼릭 그래프를 생성하는 단계는상기 그래프 실행기와 상기 언어 실행기 사이의 통신을 위한 하나 이상의 통신 포인트(communication point)를생성하는 단계를 더 포함하는, 명령형 딥러닝 프로그램 실행 방법."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 심볼릭 그래프를 생성하는 단계는트레이스 그래프에 피드 포인트(feed point) 및 펫치 포인트(fetch poing)를 포함하는 통신 포인트를 어노테이트(annotate)하는 단계;상기 피드 포인트에 기초하여, 피딩 오퍼레이션(feeding operation)을 생성하는 단계; 및상기 펫치 포인트에 기초하여, 펫칭 오퍼레이션(fetching operation)을 생성하는 단계를 포함하는, 딥러닝 프로그램 실행 방법."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,상기 연산을 수행하는 단계는상기 피딩 오퍼레이션에 기초하여, 상기 언어 실행기가 상기 그래프 실행기로 외부 텐서(external tensor)를 입력하는 단계를 포함하는, 딥러닝 프로그램 실행 방법."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제6항에 있어서,상기 연산을 수행하는 단계는상기 펫칭 오퍼레이션에 기초하여, 상기 그래프 실행기가 상기 언어 실행기로 상기 그래프 실행기에서 구체화된텐서(materialized tensor)를 저장하는 단계를 포함하는, 딥러닝 프로그램 실행 방법."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서,상기 심볼릭 그래프가 처리할 수 없는 트레이스가 있는지 판단하는 단계; 및상기 심볼릭 그래프가 처리할 수 없는 트레이스가 있다는 판단에 기초하여, 상기 심볼릭 그래프를 업데이트하는단계를 더 포함하는, 딥러닝 프로그램 실행 방법.공개특허 10-2023-0053509-4-청구항 10 하드웨어와 결합되어 제1항 내지 제9항 중 어느 하나의 항의 방법을 실행시키기 위하여 매체에 저장된 컴퓨터프로그램."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "적어도 하나의 명령어를 저장하는 메모리; 및상기 메모리에 저장된 명령어를 실행함으로써,명령형 딥러닝 프로그램(imperative deep learning program)에 대응하는 심볼릭 그래프(symbolic graph)를 생성하고,상기 명령형 딥러닝 프로그램을 딥러닝 연산(computation)과 관련된 제1 부분과 상기 딥러닝 연산과 관련없는제2 부분으로 구분하고,그래프 실행기(graph runner)를 이용하여 상기 제1 부분에 대한 연산을 수행하는 동시에 언어 실행기(languagerunner)를 이용하여 상기 제2 부분에 대한 연산을 수행하는프로세서를 포함하는 전자 장치."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,상기 프로세서는명령형 딥러닝 프로그램(imperative deep learning program)에 대하여 명령형 수행(imperative execution)을반복하고,상기 반복된 명령형 수행 각각에 대응하는 복수의 트레이스들(traces)을 수집(collect)하는, 전자 장치."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서,상기 프로세서는그래프 생성기(graph generator)를 이용하여, 상기 수집된 트레이스들에 대응하는 트레이스 그래프(tracegraph)를 생성하고,상기 그래프 생성기를 이용하여, 상기 트레이스 그래프에 기초하여 상기 심볼릭 그래프를 생성하는, 전자 장치."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서,상기 프로세서는상기 수집된 트레이스들 사이에 동일한 노드가 있는지 판단하고,상기 판단 결과에 기초하여, 상기 수집된 트레이스들을 병합(merge)하는, 전자 장치."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "공개특허 10-2023-0053509-5-제14항에 있어서,상기 프로세서는상기 그래프 실행기와 상기 언어 실행기 사이의 통신을 위한 하나 이상의 통신 포인트(communication point)를생성하는, 전자 장치."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제11항에 있어서,상기 프로세서는트레이스 그래프에 피드 포인트(feed point) 및 펫치 포인트(fetch poing)를 포함하는 통신 포인트를 어노테이트(annotate)하고,상기 피드 포인트에 기초하여, 피딩 오퍼레이션(feeding operation)을 생성하고,상기 펫치 포인트에 기초하여, 펫칭 오퍼레이션(fetching operation)을 생성하는, 전자 장치."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서,상기 프로세서는상기 피딩 오퍼레이션에 기초하여, 상기 언어 실행기가 상기 그래프 실행기로 외부 텐서(external tensor)를 입력하는, 전자 장치."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제16항에 있어서,상기 프로세서는상기 펫칭 오퍼레이션에 기초하여, 상기 그래프 실행기가 상기 언어 실행기로 상기 그래프 실행기에서 구체화된텐서(materialized tensor)를 저장하는, 전자 장치."}
{"patent_id": "10-2022-0123200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제11항에 있어서,상기 프로세서는상기 심볼릭 그래프가 처리할 수 없는 트레이스가 있는지 판단하고,상기 심볼릭 그래프가 처리할 수 없는 트레이스가 있다는 판단에 기초하여, 상기 심볼릭 그래프를업데이트하는, 전자 장치."}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "딥러닝 프로그램 실행 방법이 개시된다. 일 실시예에 따른 딥러닝 프로그램 실행 방법은 명령형 딥러닝 프로그 램(imperative deep learning program)에 대응하는 심볼릭 그래프(symbolic graph)를 생성하는 단계, 명령형 딥 러닝 프로그램을 딥러닝 연산(computation)과 관련된 제1 부분과 딥러닝 연산과 관련없는 제2 부분으로 구분하는 단계 및 그래프 실행기(graph runner)를 이용하여 제1 부분에 대한 연산을 수행하는 동시에 언어 실행기 (language runner)를 이용하여 제2 부분에 대한 연산을 수행하는 단계를 포함한다."}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "아래 실시예들은 딥러닝 프로그램 실행 방법 및 장치에 관한 것으로, 보다 구체적으로는 딥 러닝 프로그램의 명 령형-심볼릭 공동 실행 방법에 관한 것이다."}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공 지능(Artificial Intelligence; AI) 기술이 발전함에 따라 인공 지능만을 위한 독자적인 하드웨어의 필요 성이 증가하고 있다. 인공 지능은 예를 들어, 특정한 연산을 통해 추론과 학습을 수행할 수 있다. 이와 같이 인공 지능을 구현하고 실행하기 위한 전용 하드웨어로서 다양한 장치들이 개발되고 있다. 인공 지능을 위한 전용 하드웨어는 예를 들어, CPU(Central Processing Unit), GPU(Graphics Processing Unit) 등에 의해 구현될 수도 있고, 용도 변경이 가능한 FPGA(Field Programmable Gate Array), 및 ASIC(Application Specific Integrated Circuit) 등에 의해 구현될 수도 있다."}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "위에서 설명한 배경기술은 발명자가 본원의 개시 내용을 도출하는 과정에서 보유하거나 습득한 것으로서, 반드 시 본 출원 전에 일반 공중에 공개된 공지기술이라고 할 수는 없다."}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시예에 따른 명령형 딥러닝 프로그램 실행 방법은 명령형 딥러닝 프로그램(imperative deep learning program)에 대응하는 심볼릭 그래프(symbolic graph)를 생성하는 단계; 상기 명령형 딥러닝 프로그램을 딥러닝 연산(computation)과 관련된 제1 부분과 상기 딥러닝 연산과 관련없는 제2 부분으로 구분하는 단계; 및 그래프 실행기(graph runner)를 이용하여 상기 제1 부분에 대한 연산을 수행하는 동시에 언어 실행기(language runne r)를 이용하여 상기 제2 부분에 대한 연산을 수행하는 단계를 포함할 수 있다. 일 실시예에 따른 명령형 딥러닝 프로그램 실행 방법은 상기 심볼릭 그래프를 생성하는 단계는 명령형 딥러닝 프로그램(imperative deep learning program)에 대하여 명령형 수행(imperative execution)을 반복하는 단계; 및 상기 반복된 명령형 수행 각각에 대응하는 복수의 트레이스들(traces)을 수집(collect)하는 단계를 더 포함 할 수 있다. 상기 심볼릭 그래프를 생성하는 단계는 그래프 생성기(graph generator)를 이용하여, 상기 수집된 트레이스들에 대응하는 트레이스 그래프(trace graph)를 생성하는 단계; 및 상기 그래프 생성기를 이용하여, 상기 트레이스 그래프에 기초하여 상기 심볼릭 그래프를 생성하는 단계를 더 포함할 수 있다. 상기 트레이스 그래프를 생성하는 단계는 상기 수집된 트레이스들 사이에 동일한 노드가 있는지 판단하는 단계; 및 상기 판단 결과에 기초하여, 상기 수집된 트레이스들을 병합(merge)하는 단계를 포함할 수 있다. 상기 심볼릭 그래프를 생성하는 단계는 상기 그래프 실행기와 상기 언어 실행기 사이의 통신을 위한 하나 이상 의 통신 포인트(communication point)를 생성하는 단계를 더 포함할 수 있다. 상기 심볼릭 그래프를 생성하는 단계는 트레이스 그래프에 피드 포인트(feed point) 및 펫치 포인트(fetch point)를 포함하는 통신 포인트를 어노테이트(annotate)하는 단계; 상기 피드 포인트에 기초하여, 피딩 오퍼레 이션(feeding operation)을 생성하는 단계; 및 상기 펫치 포인트에 기초하여, 펫칭 오퍼레이션(fetching operation)을 생성하는 단계를 포함할 수 있다. 상기 연산을 수행하는 단계는 상기 피딩 오퍼레이션에 기초하여, 상기 언어 실행기가 상기 그래프 실행기로 외 부 텐서(external tensor)를 입력하는 단계를 포함할 수 있다. 상기 연산을 수행하는 단계는 상기 펫칭 오퍼레이션에 기초하여, 상기 그래프 실행기가 상기 언어 실행기로 상 기 그래프 실행기에서 구체화된 텐서(materialized tensor)를 저장하는 단계를 포함할 수 있다. 일 실시예에 따른 명령형 딥러닝 프로그램 실행 방법은 상기 심볼릭 그래프가 처리할 수 없는 트레이스가 있는 지 판단하는 단계; 및 상기 심볼릭 그래프가 처리할 수 없는 트레이스가 있다는 판단에 기초하여, 상기 심볼릭 그래프를 업데이트하는 단계를 포함할 수 있다. 일 실시예에 따른 전자 장치는 적어도 하나의 명령어를 저장하는 메모리; 및 상기 메모리에 저장된 명령어를 실 행함으로써, 명령형 딥러닝 프로그램(imperative deep learning program)에 대응하는 심볼릭 그래프(symbolic graph)를 생성하고, 상기 명령형 딥러닝 프로그램을 딥러닝 연산(computation)과 관련된 제1 부분과 상기 딥러 닝 연산과 관련없는 제2 부분으로 구분하고, 그래프 실행기(graph runner)를 이용하여 상기 제1 부분에 대한 연 산을 수행하는 동시에 언어 실행기(language runner)를 이용하여 상기 제2 부분에 대한 연산을 수행하는 프로세 서를 포함할 수 있다. 상기 프로세서는 명령형 딥러닝 프로그램(imperative deep learning program)에 대하여 명령형 수행 (imperative execution)을 반복하고, 상기 반복된 명령형 수행 각각에 대응하는 복수의 트레이스들(traces)을 수집(collect)할 수 있다. 상기 프로세서는 그래프 생성기(graph generator)를 이용하여, 상기 수집된 트레이스들에 대응하는 트레이스 그 래프(trace graph)를 생성하고, 상기 그래프 생성기를 이용하여, 상기 트레이스 그래프에 기초하여 상기 심볼릭 그래프를 생성할 수 있다. 상기 프로세서는 상기 수집된 트레이스들 사이에 동일한 노드가 있는지 판단하고, 상기 판단 결과에 기초하여, 상기 수집된 트레이스들을 병합(merge)할 수 있다. 상기 프로세서는 상기 그래프 실행기와 상기 언어 실행기 사이의 통신을 위한 하나 이상의 통신 포인트 (communication point)를 생성할 수 있다. 상기 프로세서는 트레이스 그래프에 피드 포인트(feed point) 및 펫치 포인트(fetch point)를 포함하는 통신 포 인트를 어노테이트(annotate)하고, 상기 피드 포인트에 기초하여, 피딩 오퍼레이션(feeding operation)을 생성 하고, 상기 펫치 포인트에 기초하여, 펫칭 오퍼레이션(fetching operation)을 생성할 수 있다. 상기 프로세서는 상기 피딩 오퍼레이션에 기초하여, 상기 언어 실행기가 상기 그래프 실행기로 외부 텐서 (external tensor)를 입력할 수 있다. 상기 프로세서는 상기 펫칭 오퍼레이션에 기초하여, 상기 그래프 실행기가 상기 언어 실행기로 상기 그래프 실 행기에서 구체화된 텐서(materialized tensor)를 저장할 수 있다. 상기 프로세서는 상기 심볼릭 그래프가 처리할 수 없는 트레이스가 있는지 판단하고, 상기 심볼릭 그래프가 처 리할 수 없는 트레이스가 있다는 판단에 기초하여, 상기 심볼릭 그래프를 업데이트할 수 있다."}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 명세서에서 개시되어 있는 특정한 구조적 또는 기능적 설명들은 단지 기술적 개념에 따른 실시예들을 설명하 기 위한 목적으로 예시된 것으로서, 실제로 구현된 형태는 다양한 다른 모습을 가질 수 있으며 본 명세서에 설 명된 실시예로만 한정되지 않는다. 제1 또는 제2 등의 용어는 다양한 구성요소들을 설명하는데 사용될 수 있지만, 이런 용어들은 하나의 구성요소 를 다른 구성요소로부터 구별하는 목적으로만 이해되어야 한다. 예를 들어 제1 구성요소는 제2 구성요소로 명명 될 수 있고, 유사하게 제2 구성요소는 제1 구성요소로도 명명될 수 있다. 어떤 구성요소가 다른 구성요소에 \"연결되어\" 있다거나 \"접속되어\" 있다고 언급된 때에는, 그 다른 구성요소에 직접적으로 연결되어 있거나 또는 접속되어 있을 수도 있지만, 중간에 다른 구성요소가 존재할 수도 있다고 이 해되어야 할 것이다. 반면에, 어떤 구성요소가 다른 구성요소에 \"직접 연결되어\" 있다거나 \"직접 접속되어\" 있 다고 언급된 때에는, 중간에 다른 구성요소가 존재하지 않는 것으로 이해되어야 할 것이다. 구성요소들 간의 관계를 설명하는 표현들, 예를 들어 \"~간의\"와 \"바로~간의\" 또는 \"~에 이웃하는\"과 \"~에 직접 이웃하는\" 등도 마찬가지로 해석되어야 한다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\" 또는 \"가지다\" 등의 용어는 실시된 특징, 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것이 존재함 을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 해당 기술 분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가진다. 일반적으로 사용되 는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의미를 갖는 것으로 해석되어야 하며, 본 명세서에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적인 의미로 해석되지 않는다. 실시예들은 퍼스널 컴퓨터, 랩톱 컴퓨터, 태블릿 컴퓨터, 스마트 폰, 텔레비전, 스마트 가전 기기, 지능형 자동 차, 키오스크, 웨어러블 장치 등 다양한 형태의 제품으로 구현될 수 있다. 이하, 실시예들을 첨부된 도면을 참 조하여 상세하게 설명한다. 각 도면에 제시된 동일한 참조 부호는 동일한 부재를 나타낸다. 도 1은 인공 신경망을 이용한 딥러닝 연산 방법을 설명하기 위한 도면이다. 딥러닝(Deep Learning) 등을 포함하는 인공지능(AI) 알고리즘은 인공 신경망(Artificial Neural Network, AN N)에 입력 데이터를 입력시키고, 컨볼루션 등의 연산을 통해 출력 데이터를 학습하고, 학습된 인공 신경망을 이 용하여 특징을 추출할 수 있다. 인공 신경망은 생물학적 뇌를 모델링한 컴퓨터 과학적 아키텍쳐(Computational Architecture)를 의미할 수 있다. 인공 신경망 내에서, 뇌의 뉴런들에 해당되는 노드들은 서로 연결되어 있고, 입력 데이터를 처리하기 위하여 집합적으로 동작한다. 다양한 종류의 뉴럴 네트워크들을 예로 들면, 컨볼루션 뉴럴 네트워크(Convolutional Neural Network, CNN), 회귀 뉴럴 네트워크(Recurrent Neural Network, RNN), 딥 빌리프 네트워크(Deep Belief Network, DBN), 제한된 볼츠만 기계(Restricted Boltzman Machine, RBM) 방식 등 이 있으나, 이에 제한되지 않는다. 피드-포워드(feed-forward) 뉴럴 네트워크에서, 뉴럴 네트워크의 뉴런들은 다른 뉴런들과의 연결들(links)을 갖는다. 이와 같은 연결들은 뉴럴 네트워크를 통해, 한 방향으로, 예를 들어 순방향(forward direction)으로 확장될 수 있다. 도 1은 입력 데이터를 입력 받아 출력 데이터를 출력하는 인공 신경망(예를 들어, 컨볼루션 뉴럴 네트워크 (Convolution Neural Network, CNN))의 구조를 도시한다. 인공 신경망은 2개 이상의 레이어(layer)를 보유한 딥 뉴럴 네트워크(deep neural network)일 수 있다. 딥러닝 프레임워크(framework)는 인공 신경망 모델을 구축 및 실행하기 위한 프로그래밍 계층을 사용자에게 제 공할 수 있다. 예를 들어, 딥러닝 프레임워크(framework)는 파이썬(Python)을 호스트 언어로 채택하는 인공 신 경망 모델을 구축 및 실행하기 위한 프로그래밍 계층을 제공할 수 있다. 일반적으로 명령형 실행(imperative execution) 또는 심볼릭 실행(symbolic execution)이라는 두 가지 실행 모 델 중 하나로 딥러닝 프로그램을 실행할 수 있다. 예를 들어, 명령형 실행에서 파이썬 인터프리터(Python Interpreter)는 딥러닝 프로그램을 일반 프로그램으로 실행하여 딥러닝 오퍼레이션(DL operation)을 즉석에서 호출할 수 있다. 호출된 딥러닝 오퍼레이션은 별도의 딥러닝 가속기(DL accelerator)에서 비동기적으로 실행되고, 파이썬 인터프리터는 프로그램을 계속 실행할 수 있다. 딥러닝 오퍼레이션의 동적 제어 흐름은 프로그램의 해석에 의해 자연스럽게 표현되며, 사용자는 딥러닝오퍼레이션을 실행하는 동안 프로그래밍 언어(예를 들어, 파이썬)의 모든 기능(예를 들어, 동적 타이핑(dynamic typing), 3rd 파티 라이브러리(third-party libraries))을 활용할 수 있다. 심볼링 실행 모델에서 파이썬 인터프리터는 딥러닝 작업을 인공 신경망 모델의 전체 데이터 흐름을 나타내는 심 볼릭 그래프(symbolic graph)에 임베드(embed)한다. 따라서 사용자는 딥러닝 프레임워크가 지원하는 기존 심볼 릭 오퍼레이션으로만 딥러닝 프로그램을 정의해야 한다. 다시 말해, 인공 신경망 모델의 동적 제어 흐름은 제어 흐름 오퍼레이션(control ow operations)(예를 들어, 텐서플로우(TensorFlow)의 tf.cond, tf.while)을 통해 명 시적으로 표현되어야 한다. 심볼릭 그래프에는 인공 신경망 모델 아키텍처의 전체 계산 계보(computation lineage)가 포함되어 있기 때문에 심볼릭 실행은 다양한 최적화 기술의 이점을 얻을 수 있습니다. 심볼릭 실행 모델은 명령형 실행 모델에 비해 더 높은 성능을 달성하지만, 그 유용성 때문에 명령형 실행 모델 이 선호되었다. 이에, 명령형 실행 모델의 이점을 누리면서 심볼릭 실행 모델의 속도를 맞추기 위한 여러 방법 들이 제안되었다. 이러한 방법들은 먼저 전체 명령형 프로그램을 나타내는 심볼릭 그래프를 생성하고, 프로그램을 명령적으로 실 행하는 대신 그래프를 실행할 수 있다. 심볼릭 그래프를 생성하는 방법은 크게 단일 경로 트레이싱(single path tracing)과 정적 컴파일(static compilation)의 두 가지 접근 방식으로 분류할 수 있다. 단일 경로 트레 이싱 방법을 채택하는 시스템은 프로그램의 단일 반복(single iteration)을 명령형으로 실행하고 실행된 인공 신경망 모델 작업을 기록하여 심볼릭 그래프를 생성할 수 있다. 정적 컴파일 방법을 채택하는 시스템은 프로그 램의 추상 구문 트리(AST, abstract syntax tree)를 심볼릭 그래프로 변환할 수 있다. 그러나, 전술한 두 가지 방법 모두 명령형 딥러닝 프로그램의 서브셋(subset)만 올바르게 처리할 수 있다. 예 를 들어, 명령형 프로그램의 동적 제어 흐름은 단일 경로 트레이싱 방법으로 캡처되지 않을 수 있다. 또한, 대 상 프로그램에 try-except, 생성기, Python 개체 변형 및 타사 라이브러리 호출과 같은 해당 심볼릭 오퍼레이션 (symbolic operation)이 없는 AST 노드가 포함된 경우, 정적 컴파일 접근 방법은 심볼릭 그래프를 올바르게 생 성할 수 없다. 아래에서 상세히 설명하겠지만, 이전 접근 방식이 명령형 실행을 심볼릭 실행으로 대체하는 방법을 사용한 반면, 일 실시예에 따른 딥러닝 프로그램의 명령형-심볼릭 공동 실행 방법은 딥러닝 오퍼레이션이 심볼릭 실행 으로 위임되는 모든 언어(예를 들어, 파이썬) 기능을 지원하기 위해 명령형 실행을 유지할 수 있다. 일 실시예에 따른 딥 러닝 프로그램의 명령형-심볼릭 공동 실행 방법은 명령형 딥러닝 프로그램에 대응하는 심 볼릭 그래프를 생성하고, 명령형 딥러닝 프로그램을 딥러닝 연산과 관련된 제1 부분과 이외의 제2 부분(예를 들 어, 파이썬 언어 피쳐들(Python language features) 부분)으로 구분하고, 그래프 실행기(graph runner)를 이용 하여 제1 부분에 대한 연산을 수행하는 동시에 언어 실행기(language runner)를 이용하여 제2 부분에 대한 연산 을 수행할 수 있다. 따라서, 일 실시예에 따른 딥 러닝 프로그램의 명령형-심볼릭 공동 실행 방법은 이전 접근 방식이 처리할 수 없는 파이썬 기능이 포함되어 있더라도 모든 명령형 딥러닝 프로그램을 정확하고 효율적으로 실행할 수 있다. 도 2는 일 실시예에 따른 딥 러닝 프로그램의 명령형-심볼릭 공동 실행 방법을 설명하기 위한 도면이다. 도 2를 참조하면, 일 실시예에 따른 딥 러닝 프로그램의 명령형-심볼릭 공동 실행 방법(이하에서, 설명의 편의 를 위해 공동 실행 방법이라 지칭할 수 있다)은 트레이싱 단계(tracing phase)와 공동 실행 단계(co-execution phase)로 구성될 수 있다. 일 실시예에 따른 공동 실행 방법은 공동 실행 시스템에 의해 수행될 수 있고, 해당 시스템은 '테라(Terra)'로 지칭될 수도 있다. 일 실시예에 따른 트레이싱 단계는 복수의 트레이스들(traces)을 수집(collect)하는 단계, 수집된 트레이스들에 대응하는 트레이스 그래프(trace graph)를 생성하는 단계, 생성된 트레이스 그래프에 기초하여 심볼릭 그래프를 생성하는 단계를 포함할 수 있다. 보다 구체적으로, 일 실시예에 따른 트레이싱 단계에서는 명령형 딥러닝 프로그램(imperative deep learning program)에 대하여 명령형 수행(imperative execution)을 반복할 수 있다. 동시에, 일 실시예에 따른 그래프 생성기(graph generator)는 반복된 명령형 수행 각각에 대응하는 복수의 트레이스들을 수집할 수 있다. 일 실시예에 따른 그래프 생성기는 수집된 모든 트레이스들을 병합하여 트레이스 그래프를 생성할 수 있다. 일 실시예에 따른 트레이스 그래프는 수집된 모든 트레이스들을 캡슐화(encapsulate)하는 방향성 비순환 그래프 (DAG, directed acyclic graph)일 수 있다.명령형 실행 동안 가능한 트레이스들의 수를 결정할 수 없기 때문에 일 실시예에 따른 그래프 생성기는 마지막 반복(iteration)의 트레이스가 트레이스 그래프에 완전히 포함될 때까지 트레이스들을 수집할 수 있다. 일 실 시예에 따른 그래프 생성기는 생성된 트레이스 그래프에 기초하여 심볼릭 그래프를 생성할 수 있다. 일 실시예에 따른 공동 실행 단계에서는 그래프 실행기(graph runner)와 언어 실행기(language runner)(예를 들 어, 파이썬 실행기(Python Runner))를 사용할 수 있다. 일 실시예에 따른 언어 실행기는 딥러닝 오퍼레이션은 수행하지 않는 스켈레톤 명령형 프로그램(skeleton imperative program)을 실행할 수 있다. 동시에, 일 실시예에 따른 그래프 실행기는 심볼릭 그래프를 이용하여 딥러닝 오퍼레이션을 수행할 수 있다. 각 딥러닝 오퍼레이션에 대하여 일 실시예에 따른 언어 실행기는 실제 연산을 건너뛰고 작업의 출력으로 빈 텐서 오브젝트(empty tensor object)를 생성할 수 있다. 일 실시예에 따른 공동 실행 단계에서는 통신을 통해 그래프 실행기와 언어 실행기 사이에 필요한 데이터를 주 고 받을 수 있다. 보다 구체적으로, 일 실시예에 따른 언어 실행기가 빈 텐서를 구체화해야 하는 경우(예를 들 어, 손실 값(loss value)을 프린트(print))에는 그래프 실행기에서 실제 데이터를 가져올 수 있다. 마찬가지로, 일 실시예에 따른 그래프 실행기는 언어 실행기의 외부 텐서(예를 들어, 입력 데이터, 파이썬 기본 값(Python primitive value))가 필요할 수 있고, 이 경우 일 실시예에 따른 그래프 실행기는 언어 실행기로부터 해당 데이터를 가져올 수 있다. 공동 실행 단계의 모든 반복에 대해 언어 실행기는 현재 반복의 딥러닝 오퍼레이션에 의해 만들어진 트레이스를 유지할 수 있다. 보다 구체적으로, 일 실시예에 따른 언어 실행기는 트레이스를 트레이스 그래프와 지속적으로 비교하여 그래프 실행기에 현재 제어 흐름(current control ow)을 알리고 그래프 실행기에서 심볼릭 그래프의 유효성을 확인할 수 있다. 트레이스의 최신 딥러닝 오퍼레이션이 언어 실행기가 특정 경로를 사용한다는 것을 나타내면, 심볼릭 그래프에 서 해당 제어 흐름 오퍼레이션(control ow operation)의 조건부 입력을 설정하는 새로운 심볼릭 오퍼레이션 (symbolic operation)으로 그래프 실행기에 경로를 알릴 수 있다. 예를 들어, 언어 실행기가 스켈레톤 명령형 프로그램의 실제 경로를 취하면(예를 들어, x > 0인 경우), 그래프 실행기는 언어 실행기에서 이러한 정보를 수신하고 실제 경로의 오퍼레이션을 실행할 수 있다. 또한, 최신 딥러닝 오퍼레이션이 트레이스 그래프에 표현되지 않은 경우, 일 실시예에 따른 공동 실행 방법은 현재 트레이스를 기존 기호 그래프가 처리할 수 없는 새운 트레이스로 간주할 수 있다. 이후, 일 실시예에 따 른 공동 실행 방법은 그래프 실행기의 실행을 취소하고 트레이싱 단계로 되돌아갈 수 있다. 이후 그래프 생성 기는 더 많은 트레이스들을 수집하고 공동 실행을 계속하기 위해 이전보다 더 많은 트레이스들을 포함하는 새로 운 심볼릭 그래프를 생성할 수 있다. 일 실시예에 따른 새로운 심볼릭 그래프를 생성하는 것은 심볼릭 그래프 를 업데이터하는 것으로 지칭될 수도 있다. 도 3a는 일 실시예에 따른 트레이스들을 수집하고, 트레이스 그래프를 생성하는 방법을 설명하기 위한 도면이다. 도 3a를 참조하면, 일 실시예에 따른 그래프 생성기는 명령형 딥러닝 프로그램에 대하여 명령형 수행을 반 복하여, 반복된 명령형 수행 각각에 대응하는 복수의 트레이스들를 수집하고, 수집된 트레이스들에 대응하 는 트레이스 그래프를 생성할 수 있다. 일 실시예에 따른 트레이스 그래프는 복수의 노드들과 노드들을 연결하는 엣지들로 구성되며, 각 노드는 딥러닝 오퍼레이션을 의미하고 각 엣지는 두 노드 간의 실행 순서를 의미할 수 있다. 일 실시예에 따른 그래프 생성기는 수집된 트레이스들 사이에 동일한 노드가 있는지 판단하고, 판단 결과에 기 초하여, 수집된 트레이스들을 병합할 수 있다. 일 실시예에 따른 동일한 노드 여는 오퍼레이션의 유형(예를 들 어, Conv2D, MatMul), 오퍼레이션의 속성(예를 들어, 필터 크기, 커널 크기) 및 프로그램의 동일한 위치에서 두 개의 오퍼레이션이 실행되었는지 여부에 기초하여 결정될 수 있다. 일 실시예에 따른 오퍼레이션의 유형은 오퍼 레이션의 종류를 의미하고, 오퍼레이션의 속성은 오퍼레이션의 행위를 결정하는 정보일 수 있다. 예를 들어, 텐서플로우의 MatMul 연산은 오퍼레이션의 유형으로 'MatMul'을 가지며 연산 오퍼레이션 속성으로 transpose_a 및 transpose_b를 갖을 수 있다. 이에, 그래프 생성기가 transpose_a가 true인 MatMul 오퍼레이션과transpose_a가 false인 MatMul 오퍼레이션은 동일하지 않다고 판단할 수 있다. 일 실시예에 따른 오퍼레이션의 실행 위치는 해당 오퍼레이션이 실제로 실행되는 프로그램 위치를 의미할 수 있 다. 오퍼레이션의 실행 위치는 런타임에 결정되므로 일 실시예에 따른 그래프 생성기는 JIT(Just-In-Time) 컴 파일을 활용하여 위치를 평가할 수 있다. 도 3b는 일 실시예에 따른 호출 ID 및 루프 ID를 추적하기 위하여 JIT 컴파일을 적용하는 방법을 설명하기 위한 도면이다. 도 3b를 참조하면, 도면은 오리지널 프로그램에 관한 도면이고, 도면은 변환된 프로그램에 관한 도면 이다. 일 실시예에 따른 공동 실행 시스템은 주어진 명령형 딥러닝 프로그램의 모든 함수 호출(function cal l)에 고유한 호출 ID(call id)를 할당하고 모든 루프에 고유한 루프 ID를 할당할 수 있다. 각 함수 호출에 대 해 함수의 호출 ID는 호출 ID 스택에 푸시되어 호출 ID를 누적할 수 있다. 공동 실행 시스템은 트레이싱 단계 와 공동 실행 단계를 포함하여 전체 프로그램 실행에 대한 호출 ID 스택을 관리할 수 있다. 푸시된 호출 ID는 함수가 반환될 때 표시될 수 있고, 호출 ID 스택에는 중첩된 함수 호출에 대한 모든 정보가 포함될 수 있다. 유사하게, 루프의 쌍(루프 ID, 루프 카운터=0)은 각 루프의 루프 ID 스택으로 푸시될 수 있다. 루프의 새로운 이터레이션마다 루프 카운터가 증가하고 루프를 종료한 후 (루프 ID, 루프 카운터) 쌍이 생성될 수 있다. 호출 ID 스택과 마찬가지로 일 실시예에 따른 공동 실행 시스템은 전체 프로그램 실행에 대한 루프 ID 스택을 관리할 수 있다. 다시 도 3a를 참조하면, 수집된 트레이스들에서 일 실시예에 따른 그래프 생성기는 두 개의 트레이스들을 수집할 수 있다. 일 실시예에 따른 그래프 생성기가 두 번째 트레이스를 첫 번째 트레이스를 포함하는 트레이 스 그래프에 병합하려고 시도할 때 두 번째 트레이스의 Op2는 첫 번째 트레이스의 Op1과 일치할 수 없으며 두 개의 Op2가 다른 위치에서 실행되었기 때문에, 두 번째 트레이스의 Op2는 첫 번째 트레이스의 Op2로 병합될 수 없다. 반면에, 두 번째 트레이스의 Op3는 첫 번째 트레이스의 Op3과 일치하기 때문에, 그래프 생성기는 두 번 째 트레이스의 Op3을 첫 번째 트레이스의 Op3에 병합할 수 있다. 나아가, 일 실시예에 따른 그래프 생성기는 프로그램의 동일한 루프(loop)에서 실행되는 노드를 병합할 수 있 다. 그래프 생성기는 딥러닝 오퍼레이션이 실행된 프로그램 위치를 비교하기 때문에 루프를 인식할 수 있다. 그런 다음 추가 루프 노드 내에서 해당 노드를 그룹화하고 노드를 별도로 병합할 수 있다. 예를 들어, 트레이 스 그래프의 루프 1은 명령형 딥러닝 프로그램의 라인 12-13에 대응하는 루프에 대한 루프 노드일 수 있다. 그래프 생성기는 첫 번째 트레이스의 두 번째 Op4를 동일한 루프에서 실행했기 때문에 첫 번째 트레이스 의 첫 번째 Op4와 병합할 수 있고, 또한 두 번째 트레이스의 Op4도 동일한 노드에 병합될 수 있다. 일 실시예에 따른 그래프 생성기는 언어 실행기와 그래프 실행기 간의 데이터 통신을 위한 심볼릭 오퍼레이션을 생성하기 위해 통신 포인트들(communication points)을 캡처하고 트레이스 그래프에서 해당 포인트에 주석을 추 가할 수 있다. 일 실시예에 따른 통신 포인트는 피드 포인트(feed point)와 페치 포인트(fetch point)를 포함 할 수 있다. 일 실시예에 따른 피드 포인트는 오퍼레이션이 학습 데이터 및 파이썬 기본 값과 같은 파이썬 인터프리터에서 입력을 받는 위치를 의미할 수 있다. 일 실시예에 따른 페치 포인트는 파이썬 인터프리터가 딥러닝 텐서 값을 필요로 하는 곳을 의미할 수 있다. 예를 들어, 명령형 딥러닝 프로그램을 참조하면, Op1은 입력으로 rval을 수신하고(5행), 파이썬 인터프리 터는 이를 출력하기 위해 x2 값(11행)이 필요할 수 있다. 이에, 일 실시예에 따른 그래프 생성기는 명령형 딥 러닝 프로그램의 5행에 대응하는 노드를 피드 포인트로 결정하고, 명령형 딥러닝 프로그램의 11행에 대응하는 노드를 펫치 포인트로 결정하고, 각각의 노드에 주석을 추가할 수 있다. 도 3c는 일 실시예에 따른 교착 상태(deadlock)가 발생하는 예시를 도시한 도면이다. 도 3c를 참조하면, 일 실시예에 따른 언어 실행기는 스켈레톤 명령형 프로그램을 순차적으로 실행하지만 그래프 실행기는 비순차적으로 연산을 수행할 수 있다. 이에, 언어 실행기와 그래프 실행기가 동시에 연산을 수행하면 교착 상태가 발생할 수 있다. 예를 들어, 일 실시예에 따른 언어 실행기가 도면에 표시된 명령형 프로그램을 실행하고, 일 실시예에 따 른 그래프 실행기 도면과 같은 심볼릭 그래프 연산을 수행한다고 가정하자. 일 실시예에 따른 두 오퍼레 이션은 심볼릭 그래프에서 데이터 및 제어 종속성이 없기 때문에(즉, opB는 opA의 출력을 소비(consume)하지 않음), 그래프 실행기는 오퍼레이션 사이의 실행 순서를 자유롭게 선택할 수 있다. 일 실시예에 따른 그래프 실행기가 opB를 실행한 다음 opA를 실행하면 언어 실행기가 그래프 실행기의 opB에 값 k를 공급하기 전에 해당 값을 프리트(print)하기 위해 opA의 출력을 수신해야 하기 때문에 교착 상태가 발생할 수 있다. 교착 상태를 방지하기 위해 일 실시예에 따른 그래프 생성기는 심볼릭 그래프를 생성하기 전에 실행해야 하는 출력 펫칭 오퍼레이션과 심볼릭 그래프를 생성한 후 입력 피딩 오퍼레이션 사이의 제어 종속성(control dependencies)(예를 들어, TensorFlow에서 정의될 수 있다)을 추가할 수 있다. 도 4a는 일 실시예에 따른 심볼릭 그래프를 생성하는 방법을 설명하기 위한 도면이다. 일 실시예에 따른 그래프 생성기는 트레이스 그래프의 노드들을 해당 딥러닝 오퍼레이션으로 변환하고, 추가로 공동 실행 중에 데이터 통신을 위한 입력 피딩 오퍼레이션 및 출력 펫칭 오퍼레이션을 생성할 수 있다. 일 실시예에 따른 입력 피딩 오퍼레이션은 트레이스 그래프의 피드 포인트에 대응되고, 언어 실행기는 외부 텐 서를 그래프 실행기에 공급할 수 있다. 일 실시예에 따른 펫칭 오퍼레이션은 트레이스 그래프의 페치 포인트에 대응되고, 언어 실행기는 그래프 실행기 로부터 구체화된 딥러닝 텐서를 가져올 수 있다. 일 실시예에 따른 그래프 생성기는 통신 오퍼레이션과 함께 단일 그래프(single graph)의 전체 계산 계보 (entire computation lineage)를 나타낼 수 있다. 이러한 작업이 없으면 그래프 생성기는 모든 피드-페치 포인 트에서 심볼릭 그래프를 작은 서브그래프(subgraph)로 나누어 잠재적 최적화 기회(potential optimization opportunities)를 놓칠 수 있다. 트레이스 그래프의 다양한 제어 흐름을 처리하기 위해 일 실시예에 따른 그래프 생성기는 특정 조건에 따라 단 일 케이스만 실행할 수 있는 스위치 케이스(Switch-Case) 연산(예를 들어, 텐서 프로우(TensorFlow)의 tf.case)을 사용할 수 있다. 도 4b는 일 실시예에 따른 일 실시예에 따른 트레이스 그래프를 수신하여 스위치 케이스의 정렬된 목록을 출력 하는 예시를 도시한 도면이다. 일 실시예에 따른 공동 실행 시스템은 트레이스 그래프를 수신하여 스위치 케이스들의 정렬된 목록(ordered list of switch-cases)을 출력할 수 있다. 일 실시예에 따른 스위치 케이스는 (베이직 블록, 컨트롤 엣지) 집 합으로, 베이직 블록은 노드의 선형 체인(linear chain)이고 컨트롤 엣지는 베이직 블록을 가리키는 엣지일 수 있다. 일 실시예에 따른 트레이스 그래프의 모든 겹치지 않는 노드의 선형 체인은 베이직 블록에 고유하게 할당되므 로, 스위치 케이스들의 정렬된 목록이 트레이스 그래프의 모든 트레이스들을 포함할 수 있다. 트레이스 그래프 에 루프 노드가 있는 경우, 루프 노드가 심볼릭 그래프에서 While 연산으로 변환되기 때문에 알고리즘은 이를 단일 노드로 처리할 수 있다. 예를 들어, 도 4b의 일 실시예에 따른 공동 실행 시스템은 트레이스 그래프(41 0)를 수신하여 스위치 케이스의 정렬된 목록을 출력할 수 있다. 스위치 케이스 오퍼레이션에 알려주는 조건부 입력에 대해 그래프 생성기는 스위치 케이스 오퍼레이션과 함께 케이스 선택(case select) 오퍼레이션을 생성할 수 있다. 언어 실행기가 특정 경로를 선택하면 케이스 선택 오 퍼레이션을 통해 그래프 실행기에 알릴 수 있다. 여기에서, 그래프 생성기는 트레이스 그래프를 입력으로 사용 하고, 트레이스 그래프를 횡단하며 제어 흐름을 올바르게 나타내는 스위치 케이스 작업을 반환하는 케이스 할당 알고리즘(case assignment algorithm)을 사용할 수 있다. 도 4c는 일 실시예에 따른 케이스 할당 알고리즘을 설명하기 위한 도면이고, 도 4d는 일 실시예에 따른 케이스 할당 알고리즘을 적용하는 예시를 도시한 도면이다. 일 실시예에 따른 케이스 할당 알고리즘은 지정된 트레이스 그래프를 토폴로지 순서로 탐색하고, 각 베이직 블 록에 가능한 한 긴 노드의 선형 체인을 포함하록 할 수 있다. 도 4c에서, 'G'는 시작 노드, 종료 노드를 포함하는 노드와 엣지로 구성된 트레이스 그래프를, 'V'는 v1 내지 vn 을 원소로 포함하는 노드 집합을, 'E'는 e1내지 em을 원소로 포함하는 엣지 집합을 의미할 수 있다. 일 실시예에 따른 시작 노드는 인 차수(in-degree)가 '0'인 고유한 소스 노드(unique source node)를 의미할 수 있고, 일 실시예에 따른 종료 노드는 아웃 차수(out-degree)가 '0'인 고유한 싱크 노드(unique sink node)를 의미할 수 있다. 일 실시예에 따른 노드의 선형 체인 집합 'L'은 2 ≤ i ≤ l, (vi-1, vi) ∈ E에 대하여 인 차수가 '1'인(단, v1 은 제외)이고, 아웃 차수가 '1'(단, vl는 제외)인 {v1, . . . , vl} ⊆ V를 의미할 수 있다. 나아가, 엣지의 선형 체인 집합 I(L)인{ (vi-1, vi) | 2 ≤ i ≤ l }을 만족하는 집합일 수 있다. 일 실시예에 따른 케이스 c는 (베이직 블록(Lc), 컨트롤 엣지(Ec)) 쌍을 의미할 수 있고, 베이직 블록은 노드의 선형 체인 집합을, 컨트롤 엣지는 베이직 블록을 가리키는 엣지일 수 있다. 일 실시예에 따른 스위치 케이스 s 는 아래 수학식 1을 만족하는 케이스들의 집합일 수 있다. 수학식 1"}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "일 실시예에 따른 트레이스 t는 아래 수학식 2를 만족하는 (Vt ∪ {start, end}, Et)일 수 있다. 수학식 2"}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "일 실시예에 따른 트레이스 t의 오퍼레이션 노드 Op(t)는 Vt일 수 있고, 트레이스 t의 경로 Path(t)는 Et일 수 있다. 일 실시예에 따른 스위치 케이스의 정렬된 목록 S는 s1 내지 sp 를 원소로 갖을 수 있고, 각각의 스위치 케이스 는 일 실시예에 따른 조건(condition)이 유지되는 경우 트레이스 t를 커버할 수 있다. 일 실시예에 따른 조건은 1)모든 si에 대하여, {di} = Eci ∩ Path(t)를 만족하는 유일한 di를 갖는 유일한 ci = (Lci, Eci) ∈ si가 존재하는 조건 1과, 2)트레이스의 오퍼레이션은 ci의 선형 체인으로 표시되고, 트레이스의 모 든 엣지는 체인 내 엣지 di들과 ek의 합집합인 조건 2를 포함할 수 있고, 조건 은 아래 수학식 3과 같이 표현될 수 있다. 수학식 3"}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "일 실시예에 따른 그래프 Gs = (Vs ∪ {start, end}, Es)는 아래 수학식 4를 만족할 경우 서브 트레이스 그래프 (sub-TraceGraph)일 수 있다.수학식 4"}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 5, "content": "도 4c 및 도 4d를 참조하면, 일 실시예에 따른 케이스 할당 알고리즘에 따르면 'next_edges'는 2행에서 {edge a}로 초기화되고, 12행의 ' '에서 노드 1의 차수를 계산할 수 있다. 노드 1은 에지 a를 제외 하고 더 이상 들어오는 에지가 없기 때문에 14행에서 베이직 블록의 첫 번째 노드가 될 수 있다. 이후, 일 실시예에 따른 케이스 할당 알고리즘은 가능한 한 베이직 블록을 확장하려고 시도하지만 노드 1의 아 웃 차수(out-degree)가 3이므로 노드 1이 선형 체인의 끝이 되도록 확장할 수 없다(16행 참조). 따라서 첫 번 째 스위치 케이스는 25행에서 ({노드 1}, {엣지 a})가 될 수 있다. 다음 이터레이션에서 다음 엣지는 {엣지 b, 엣지 c, 엣지 d}가 되고 단일 스위치 케이스에서 3개의 베이직 블록 이 생성될 수 있다. 그 중 두 개의 베이직 블록은 각각 두 개의 노드{노드 2, 노드 3} 및 {노드 4, 노드 5}가 있는 선형 체인을 포함하고 마지막 베이직 블록은 {노드 6}을 포함할 수 있다. 일 실시예에 따른 케이스 할당 알고리즘이 {엣지 g, 엣지 h}와 함께 엣지 i를 처리할 때 노드 8의 인 차수(in- degree)가 에지 j로 인해 0이 아니기 때문에(12행 참조), 노드 8을 기본 블록에 넣지 않을 수 있고, 따라서 베 이직 블록은 공 집합(empty set)이 될 수 있다. 일 실시예에 따른 케이스 할당 알고리즘은 노드 8과 노드 9로 기본 블록을 생성한 후 스위치 케이스의 정렬된 목록을 출력할 수 있다. 일 실시예에 따른 케이스 할당 알고리즘의 결과 내의 각 스위치 케이스는 심볼릭 그래프에서 스위치 케이스 오 페리이션이 될 수 있다. 스위치 케이스에 베이직 블록이 하나만 포함된 경우, 그래프 생성기는 중복 스위치 케 이스 오퍼레이션(redundant Switch-Case operation)을 생성하지 않다. 일 실시예에 따른 그래프 생성기는 각 스위치 케이스 오퍼레이션에 대해 케이스 선택 오퍼레이션(Case Select operation)을 생성할 수 있다. 공동 실행 단계에서, 언어 실행기는 케이스 선택 오퍼레이션을 통해 얻은 컨트 롤 에지(control edge)를 그래프 실행기에 알릴 수 있다. 예를 들어, 언어 실행기가 도 4c의 엣지 c를 따른다 면, 그래프 실행기는 첫 번째 스위치 케이스 오페리이션의 '오퍼레이션 2'를 실행할 수 있다. 다시 도 4a를 참조하면, 그래프 생성기는 트레이스 그래프의 루프 노드에 대한 while 오퍼레이션(예를 들어, 텐 서플로우의 tf.while)을 생성할 수 있다. 케이스 선택 연산으로, 그래프 생성기는 while 작업과 함께 반복 조 건 오퍼레이션(Loop Cond operation)을 생성할 수 있다. 일 실시예에 따른 언어 실행기는 언어 실행기가 다음 루프 반복으로 이동하는지 또는 루프 콘 오퍼레이션을 통 해 루프를 종료하는지에 대해 그래프 실행기에게 알려줄 수 있다. 그래프 생성기는 루프 노드가 수집된 트레이 스에서 동일한 수의 반복을 가져 오면 while 오퍼레이션을 풀어줄 수 있다. 도 5은 일 실시예에 따른 전자 장치의 구성을 도시하는 도면이다. 도 5을 참조하면, 일 실시예에 따른 전자 장치는 하나 이상의 프로세서 및 메모리를 포함할 수 있다. 일 실시예에 따른 메모리는 컴퓨터에서 읽을 수 있는 명령어들(instructions)을 저장할 수 있다. 메모리 에 저장된 명령어들이 프로세서에 의해 실행되면, 프로세서는 명령어들에 의해 정의되는 동작들 을 처리할 수 있다. 메모리는 예를 들어 RAM(random access memories), DRAM(dynamic random access memories), SRAM(static random access memories) 또는 이 기술 분야에서 알려진 다른 형태의 비휘발성 메모리 를 포함할 수 있다. 메모리는 기 학습된 인공 신경망 기반의 생성 모델을 저장할 수 있다. 일 실시예에 따른 하나 이상의 프로세서는 전자 장치의 전체적인 동작을 제어한다. 프로세서는 목적하는 동작들(desired operations)을 실행시키기 위한 물리적인 구조를 갖는 회로를 가지는 하드웨어로 구현 된 장치일 수 있다. 목적하는 동작들은 프로그램에 포함된 코드(code) 또는 명령어들을 포함할 수 있다. 하드 웨어로 구현된 장치는 마이크로프로세서(microprocessor), 중앙 처리 장치(Central Processing Unit; CPU), 그 래픽 처리 장치(Graphic Processing Unit; GPU), 프로세서 코어(processor core), 멀티-코어 프로세서(multi- core processor), 멀티프로세서(multiprocessor), ASIC(Application-Specific Integrated Circuit), FPGA(Field Programmable Gate Array), NPU(Neural Processing Unit) 등을 포함할 수 있다 일 실시예에 따른 프로세서는 전자 장치가 실행하기 위한 기능 및 명령어들을 실행함으로써 전자 장 치를 제어할 수 있다. 프로세서는 도 2 내지 도 4을 통해 전술한 적어도 하나의 동작 및/또는 기능 을 수행하도록 전자 장치를 제어할 수 있다. 일 실시예에 따른 프로세서의 제어에 의해 전자 장치는 명령형 딥러닝 프로그램(imperative deep learning program)에 대응하는 심볼릭 그래프(symbolic graph)를 생성하고, 명령형 딥러닝 프로그램을 딥러닝 연산(computation)과 관련된 제1 부분과 딥러닝 연산과 관련없는 제2 부분으로 구분하고, 그래프 실행기(graph runner)를 이용하여 제1 부분에 대한 연산을 수행하는 동시에 언어 실행기(language runner)를 이용하여 제2 부 분에 대한 연산을 수행할 수 있다. 이상에서 설명된 실시예들은 하드웨어 구성요소, 소프트웨어 구성요소, 및/또는 하드웨어 구성요소 및 소프트웨 어 구성요소의 조합으로 구현될 수 있다. 예를 들어, 실시예들에서 설명된 장치, 방법 및 구성요소는, 예를 들 어, 프로세서, 콘트롤러, ALU(arithmetic logic unit), 디지털 신호 프로세서(digital signal processor), 마 이크로컴퓨터, FPGA(field programmable gate array), PLU(programmable logic unit), 마이크로프로세서, 또는 명령(instruction)을 실행하고 응답할 수 있는 다른 어떠한 장치와 같이, 범용 컴퓨터 또는 특수 목적 컴퓨터를 이용하여 구현될 수 있다. 처리 장치는 운영 체제(OS) 및 상기 운영 체제 상에서 수행되는 소프트웨어 애플리 케이션을 수행할 수 있다. 또한, 처리 장치는 소프트웨어의 실행에 응답하여, 데이터를 접근, 저장, 조작, 처 리 및 생성할 수도 있다. 이해의 편의를 위하여, 처리 장치는 하나가 사용되는 것으로 설명된 경우도 있지만,"}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "해당 기술분야에서 통상의 지식을 가진 자는, 처리 장치가 복수 개의 처리 요소(processing element) 및/또는 복수 유형의 처리 요소를 포함할 수 있음을 알 수 있다. 예를 들어, 처리 장치는 복수 개의 프로세서 또는 하 나의 프로세서 및 하나의 콘트롤러를 포함할 수 있다. 또한, 병렬 프로세서(parallel processor)와 같은, 다른 처리 구성(processing configuration)도 가능하다. 소프트웨어는 컴퓨터 프로그램(computer program), 코드(code), 명령(instruction), 또는 이들의 조합을 포함 할 수 있으며, 원하는 대로 동작하도록 처리 장치를 구성하거나 독립적으로 또는 결합적으로(collectively) 처 리 장치를 명령할 수 있다. 소프트웨어 및/또는 데이터는, 처리 장치에 의하여 해석되거나 처리 장치에 명령 또는 데이터를 제공하기 위하여, 어떤 유형의 기계, 구성요소(component), 물리적 장치, 가상 장치(virtual equipment), 컴퓨터 저장 매체 또는 장치, 또는 전송되는 신호 파(signal wave)에 영구적으로, 또는 일시적으로 구체화(embody)될 수 있다. 소프트웨어는 네트워크로 연결된 컴퓨터 시스템 상에 분산되어서, 분산된 방법으로 저장되거나 실행될 수도 있다. 소프트웨어 및 데이터는 컴퓨터 판독 가능 기록 매체에 저장될 수 있다. 실시예에 따른 방법은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등을 단독 으로 또는 조합하여 포함할 수 있다. 매체에 기록되는 프로그램 명령은 실시예를 위하여 특별히 설계되고 구성 된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판독 가능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD-ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체(magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다."}
{"patent_id": "10-2022-0123200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "이상과 같이 실시예들이 비록 한정된 도면에 의해 설명되었으나, 해당 기술분야에서 통상의 지식을 가진 자라면 상기를 기초로 다양한 기술적 수정 및 변형을 적용할 수 있다. 예를 들어, 설명된 기술들이 설명된 방법과 다 른 순서로 수행되거나, 및/또는 설명된 시스템, 구조, 장치, 회로 등의 구성요소들이 설명된 방법과 다른 형태 로 결합 또는 조합되거나, 다른 구성요소 또는 균등물에 의하여 대치되거나 치환되더라도 적절한 결과가 달성될 수 있다.그러므로, 다른 구현들, 다른 실시예들 및 특허청구범위와 균등한 것들도 후술하는 특허청구범위의 범위에 속한 다."}
{"patent_id": "10-2022-0123200", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 인공 신경망을 이용한 딥러닝 연산 방법을 설명하기 위한 도면이다. 도 2는 일 실시예에 따른 딥러닝 프로그램의 명령형-심볼릭 공동 실행 방법을 설명하기 위한 도면이다. 도 3a는 일 실시예에 따른 트레이스들을 수집하고, 트레이스 그래프를 생성하는 방법을 설명하기 위한 도면이다. 도 3b는 일 실시예에 따른 호출 ID 및 루프 ID를 추적하기 위하여 JIT 컴파일을 적용하는 방법을 설명하기 위한 도면이다. 도 3c는 일 실시예에 따른 교착 상태(deadlock)가 발생하는 예시를 도시한 도면이다. 도 4a는 일 실시예에 따른 심볼릭 그래프를 생성하는 방법을 설명하기 위한 도면이다. 도 4b는 일 실시예에 따른 일 실시예에 따른 트레이스 그래프를 수신하여 스위치 케이스의 정렬된 목록을 출력 하는 예시를 도시한 도면이다. 도 4c는 일 실시예에 따른 케이스 할당 알고리즘을 설명하기 위한 도면이고, 도 4d는 일 실시예에 따른 케이스 할당 알고리즘을 적용하는 예시를 도시한 도면이다. 도 5은 일 실시예에 따른 전자 장치의 구성을 도시하는 도면이다."}
