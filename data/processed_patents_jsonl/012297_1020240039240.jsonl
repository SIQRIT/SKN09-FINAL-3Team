{"patent_id": "10-2024-0039240", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0041307", "출원번호": "10-2024-0039240", "발명의 명칭": "프로그램된 활성화 함수 실행 유닛을 포함하는 신경 프로세싱 유닛", "출원인": "주식회사 딥엑스", "발명자": "김녹원"}}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "입력 특징맵 데이터를 입력 받아, 합성곱 신경망 연산에 해당하는 인공신경망 연산을 통해 연산 값을 출력하도록 구성된 적어도 하나의 프로세싱 엘리먼트;복수의 프로그래머블 세그먼트들을 포함하는 적어도 하나의 프로그램된 활성화 함수를 상기 연산 값에 적용하여활성화 값을 생성하도록 구성된 프로그램된 활성화 함수 실행 유닛; 및 상기 적어도 하나의 프로세싱 엘리먼트 및 상기 프로그램된 활성화 함수 실행 유닛의 동작을 제어하도록 구성된제어기를 포함하고,상기 프로그램된 활성화 함수 실행 유닛은 복수의 비교기, 선택기, 적어도 하나의 곱셈기 및 적어도 하나의 가산기가 하드-와이어되고, 상기 복수의 비교기는 상기 연산 값을 입력된 복수의 세그먼트 경계값 각각과 비교하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 복수의 프로그래머블 세그먼트들의 구간에 대한 정보를 저장하는 세그먼트 레지스터를 더 포함하는, 신경프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,상기 복수의 프로그래머블 세그먼트들의 세그먼트 경계값을 저장하는 세그먼트 레지스터를 더 포함하는, 신경프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 복수의 비교기는 상기 연산 값을 입력된 복수의 세그먼트 경계값 각각과 비교하여 구간 결정 데이터를 출력하도록 구성된, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1 항에 있어서,상기 복수의 비교기는 비교기 인에이블 신호에 의해서 동작여부가 결정되도록 구성된, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 4 항에 있어서,상기 구간 결정 데이터에 따라, 상기 복수의 프로그래머블 세그먼트들 중 대응되는 세그먼트의 기울기 및 오프공개특허 10-2024-0041307-3-셋을 상기 연산 값에 적용하여 상기 활성화 값을 생성하도록 구성된, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서,상기 적어도 하나의 곱셈기는,상기 선택기에서 출력된 프로그래머블 세그먼트에 대한 기울기와 입력 값을 곱하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 7 항에 있어서,상기 적어도 하나의 가산기는,상기 적어도 하나의 곱셈기에서 출력된 프로그래머블 세그먼트에 대한 기울기를 입력 값에 곱한값에 프로그래머블 세그먼트에 대한 오프셋을 더하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1 항에 있어서,상기 선택기는 복수의 구간 결정 데이터에 따라, 복수의 프로그래머블 세그먼트들에 대한 기울기 중 입력 값이속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 2 차항 기울기와 1 차항 기울기 및 오프셋을출력하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 9 항에 있어서,상기 적어도 하나의 곱셈기는,입력 값에 상기 선택기에서 출력된 프로그래머블 세그먼트에 대한 2차항의 계수를 곱하는 제1 곱셈기; 제1 곱셈기에서 출력된 출력 값과 입력 값을 곱하는 제2 곱셈기 및 입력 값에 상기 선택기에서 출력된 프로그래머블 세그먼트에 대한 1차항의 계수를 곱하는 제3 곱셈기를 포함하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 10 항에 있어서,상기 제2 곱셈기 및 상기 제3 곱셈기는 제1 인에이블 신호에 의해서 동작이 제어되는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 11 항에 있어서,상기 적어도 하나의 가산기는,상기 제2 곱셈기의 출력 값에 상기 제3 곱셈기의 출력 값을 더하는 제1 가산기; 상기 제1 가산기의 출력 값에 상기 선택기에서 출력된 프로그래머블 세그먼트에 대한 오프셋을 더하는 제2 가산공개특허 10-2024-0041307-4-기를 포함하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 12 항에 있어서,상기 제2 가산기는 제1 인에이블 신호에 의해서 동작이 제어되는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 1 항에 있어서,상기 프로그램된 활성화 함수 실행 유닛은 상기 적어도 하나의 가산기의 출력 값을 로그 연산하는 로그 연산기를 더 포함하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 14 항에 있어서,상기 로그 연산기는 제2 인에이블 신호에 의해서 동작이 제어되는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 1 항에 있어서,프로그래머블 활성화 함수를 구성하는 복수의 프로그래머블 세그먼트들에 대한 기울기 및 오프셋 정보를 저장하는 프로그래머블 활성화 함수 라이브러리를 더 포함하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제 1 항에 있어서,상기 적어도 하나의 프로세싱 엘리먼트는 멀티플렉서를 통해 프로그램된 활성화 함수 실행 유닛에 연결되는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제 1 항에 있어서,활성화 함수를 상기 적어도 하나의 프로그램된 활성화 함수로 프로그램하는 활성화 함수 변환 프로그램 유닛을더 포함하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 18 항에 있어서,상기 활성화 함수 변환 프로그램 유닛은,기울기 변화 데이터에 따라, 상기 적어도 하나의 프로그램된 활성화 함수의 선형 구간 및 비선형 구간을 우선적으로 결정하는, 신경 프로세싱 유닛.공개특허 10-2024-0041307-5-청구항 20 제 19 항에 있어서,상기 활성화 함수 변환 프로그램 유닛은,기울기 변화 데이터 중 2차 미분값이 임계값보다 낮은 구간을 상기 선형 구간으로 결정하는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제 19 항에 있어서,상기 활성화 함수 변환 프로그램 유닛은,기울기 변화 데이터 중 2차 미분값이 임계값보다 높은 구간을 상기 비선형 구간으로 결정하는, 신경 프로세싱유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제 21 항에 있어서,상기 활성화 함수 변환 프로그램 유닛은,상기 2차 미분값의 적분 값에 기초하여, 상기 비선형 구간을 복수개로 분리시키는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제 18 항에 있어서,상기 활성화 함수 변환 프로그램 유닛은,상기 적어도 하나의 프로그램된 활성화 함수의 선형 구간을 1차 함수로 근사된 프로그래머블 세그먼트로 변환시키는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제 18 항에 있어서,상기 활성화 함수 변환 프로그램 유닛은,상기 적어도 하나의 프로그램된 활성화 함수의 비선형 구간을 2차 함수로 근사된 프로그래머블 세그먼트로 변환시키는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제 18 항에 있어서,상기 활성화 함수 변환 프로그램 유닛은,상기 적어도 하나의 프로그램된 활성화 함수의 비선형 구간을 로그 함수로 근사된 프로그래머블 세그먼트로 변환시키는, 신경 프로세싱 유닛."}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법이 제공된다. 상기 방법은 활성화 함수를 세그먼팅하기 위한 세그먼트 데이터를 생성하는 단계; 생성된 세그먼트 데이터를 이용하여 활성화 함수를 복수의 세그먼트들로 세그먼팅하는 단계; 및 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화 하는 단계를 포함한다."}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 프로그래밍 가능 활성화 함수 실행 유닛을 포함하는 신경 프로세싱 유닛(NPU)에 관한 것이다."}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인간은 인식(recognition), 분류(classification), 추론(inference), 예측(predict), 조작/의사결정 (control/decision making) 등을 할 수 있는 지능을 갖추고 있다. 인공지능(artificial Intelligence, AI)은 인간의 지능을 인공적으로 모방하는 것을 의미한다. 인간의 뇌는 뉴런(neuron)이라는 수많은 신경세포로 이루어져 있다. 각각의 뉴런은 시냅스(synapse)라고 불리는 연결부위를 통해 수백 개에서 수천 개의 다른 뉴런들과 연결되어 있다. 인간의 지능을 모방하기 위하여, 생물학 적 뉴런의 동작원리와 뉴런 간의 연결 관계를 모델링한 것을, 인공신경망(artificial neural network, ANN) 모 델이라고 한다. 즉, ANN은 뉴런들을 모방한 노드들을 레이어(layer: 계층) 구조로 연결시킨 시스템이다. ANN의 연산을 가속화하기 위해 개발된 ANN 전용 프로세서는 신경 프로세싱 유닛(neural processing unit; NP U)이다."}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "ANN은 레이어 수에 따라 '단층 신경망'과 '다층 신경망'으로 구분된다. 일반적인 다층 신경망은 입력 레이어와 은닉 레이어, 출력 레이어로 구성된다. 입력 레이어(input layer)는 입력 값을 받아들이는 레이어다 입력 레이어의 수는 입력되는 변수의 수와 동일하다. 은닉 레이어(hidden layer)는 입력 레이어와 출력 레이어 사이에 위치하며 입력 레이어로부터 신호를 받아 특징을 추출하여 출력층으로 전달하는 레이어이다. 출력 레이어(output layer)는 은닉 레이어로부터 신호를 받아 외부로 출력하는 레이어이다. 인간의 뇌에서 뉴런 간에 신호가 전달될 때, 신호의 전달 강도가 달라진다. 이를 모방하여, ANN에서 활성화 함 수(activation function)에 의해 레이어 간에 전달되는 신호의 전달 강도, 즉 활성화 여부가 결정된다. NPU에서 구현된 활성화 함수의 특성에 따라 ANN의 추론 정확도가 달라질 수 있다. 즉, NPU의 활성화 함수의 처 리 회로의 하드웨어 구현 특성에 따라 ANN의 성능 및 효율이 결정된다. 또한 복잡한 수식의 활성화 함수를 처리 하는 ANN은 하드웨어 가속기로 처리될 수 있다. 하드웨어로 ANN 전용 프로세서를 구현할 경우, ANN 전용 프로세 서는 상당한 칩 면적(i.e., 다수의 로직 게이트 개수)이 필요로 할 수 있다. 또한 이러한 칩은 전력소모가 상당 할 수 있다. 보다 높은 인공 지능을 구현하기 위해 은닉 레이어의 개수를 늘린 심층신경망(deep neural network, DNN)이 개 시되었다. DNN의 활성화 함수는 가중치(weight)와 바이아스(bias)가 적용된 연산 값에 대한 전달 강도를 결정하 기 위해 사용된다. DNN은 다양한 구조로 개발되고 있다. 예를 들면, DNN의 일 예시인 합성곱 신경망(convolutional neural network, CNN)은 입력 값 (i.e., 영상 또는 이미지)의 특징들을 추출하고, 추출된 특징들의 패턴을 파악하기에 용이한 것으로 알려져 있다. CNN은 합성곱 연산, 활성화 함수 연산, 풀링(pooling) 연산 등이 특정 순서로 처리되는 형태로 구성될 수 있다. 예를 들면, DNN의 레이어 각각에서, 입력 값과 파라미터(i.e., 가중치 또는 커널)는 복수의 채널로 구성된 행렬 일 수 있다. 입력 값과 파라미터는 합성곱 또는 행렬 곱셈으로 NPU에서 처리될 수 있다. 각 레이어에서 연산이 처리된 연산 값이 생성된다. 이러한 연산 값에 활성화 함수가 적용될 수 있다. 예를 들면, 트랜스포머(transformer)는 어텐션(attention) 기술에 기반한 DNN이다. 트랜스포머는 행렬 곱셈 (matrix multiplication) 연산을 다수 활용한다. 트랜스포머는 입력 값과 쿼리(query; Q), 키(key; K), 및 값 (value; V) 등의 파라미터를 사용하여 연산 값인 어텐션(Q,K,V)를 획득할 수 있다. 트랜스포머는 연산 값 (i.e., 어텐션(Q,K,V))에 기초하여 다양한 추론 연산을 처리할 수 있다. 트랜스포머는 CNN 보다 더 우수한 추론 성능을 보여주는 경향이 있다. 상술한 신경망들은 DNN으로 지칭할 수 있다. 한편, DNN의 복수의 레이어들 중 특정 레이어의 연산 값에 활성화 함수가 선택적으로 적용될 수 있다. 활성화 함수의 입력 값 (i.e., 특정 레이어의 연산 값)에 대응되는 X-축 값과 활성화 함수의 활성화 값에 대응 되는 Y-축 값을 포함하도록 구성될 수 있다. 활성화 함수는 입력 값들의 수학적 선형 결합을 다양한 형태의 선 형 결합 또는 비선형 결합으로 변환하는 역할을 수행한다. 따라서, DNN은 특정 레이어의 연산 값에 적절한 활성 화 함수를 적용하여 다양한 추론 기능을 수행하도록 설계될 수 있다. DNN에서 해결하고자 하는 복잡한 기능들은 대부분 비선형성을 갖는다. 이러한 문제를 해결하기 위해 활성화 함 수는 대부분 비선형성을 가지는 함수(Nonlinear Function)이다. NPU가 처리하는 적어도 하나의 DNN 모델에 적용되는 활성화 함수의 비선형성의 특징에 따라 하드웨어에서 처리 되는 DNN 모델의 성능 및 효율이 달라질 수 있다. 활성화 함수는 활성화 함수의 입력 값의 특정 영역의 특징을 더 부각하고 다른 영역의 특징을 덜 부각시킴으로 써 추론 정확도를 향상시키거나 또는 저하시킬 수 있다. 다양한 활성화 함수들 중 적어도 일부의 활성화 함수의 비선형성은 로그(log) 연산, 지수(exponential) 연산 등 을 포함할 수 있다. 이러한 로그 및 지수 연산이 포함된 활성화 함수를 하드웨어로 구현하는 것은 디지털 로직 설계 측면에서 매우 복잡하다. 예를 들면, 로그 및 지수 연산을 위해서는 하드웨어 연산기의 구성이 매우 복잡 하게 된다. 따라서, 하드웨어의 소비전력이 증가하고 연산 처리 속도가 느려질 수 있다는 사실을 본 개시의 발 명자들은 인식하였다. NPU의 경우, 각 활성화 함수 처리를 위한 각각의 활성화 함수 처리 모듈을 설계해야 할 수 있다. 또한, 하드-와 이어(hard-wired)된 프로세서는 하드-와이어 된 각각의 전용 활성화 함수 처리 로직 유닛들을 이용하여 미리 정 의된 활성화 함수들만 처리할 수 있다. 이때, 활성화 함수의 연산 복잡도에 따라 하드-와이어 된 프로세서에서 게이트 개수가 급격하게 증가하는 단점이 있다는 사실을 본 개시의 발명자들은 인식하였다. 하드-와이어 된 프로세서는 하드웨어 수정 없이 새로운 활성화 함수를 독립적으로 처리할 수 없다. 하드-와이어 된 프로세서가 처리할 수 없는 활성화 함수는 별도의 소프트웨어로 연산해야 한다. 예를 들면, 하드-와이어 된 프로세서는 인공지능 전용 Application Specific Integrated Circuit (ASIC)일 수 있다. 즉, 하드-와이어 된 프로세서는 NPU일 수 있다. 다양한 종류의 활성화 함수들을 하드-와이어 된 프로세서에서 처리하기 위해 다양한 방법들이 제시되었다. 예를 들면, 종래에는 활성화 함수를 룩업 테이블(Look-Up Table; LUT)을 이용하는 방법, 비선형 근사식을 이용하는 방법, 다항식 근사(polynomial approximation)를 이용하는 방법 등을 활용하여 처리하였다. 하지만, 다항식 근사 등을 이용하여 하드웨어에서 활성화 함수를 처리하는 종래의 활성화 함수 근사화 방법은 추론 정확도 향상을 위해 프로세서에게 많은 계산량을 요구한다는 사실을 본 개시의 발명자들은 인식하였다. 이에, 종래의 활성화 함수 근사화 기술이 적용된 DNN 모델의 추론 정확도 열화 문제, 프로세서의 활성화 함수 처리부의 게이트 개수 증가 문제, 및 프로세서의 소비 전력 증가 문제를 개선해야 한다는 사실을 본 개시의 발 명자들은 인식하였다. 더 나아가서, 1)종래의 활성화 함수 처리 방법이 적용된 프로세서가 처리할 수 없는 룩업 테이블 등 미리결정된 데이터에 포함되지 않은 활성화 함수, 2)신규 활성화 함수, 및/또는 3)종래의 일부가 수정된 활성화 함수들;을 프로세서가 독립적으로 처리하기 위해서, 어떠한 활성화 함수도 근사화 할 수 있는 프로그래밍 방법 및 이를 구 동하는 하드웨어 설계가 필요하다는 사실을 본 개시의 발명자들은 인식하였다. 더 나아가서, 활성화 함수의 특징들에 최적화된 근사화 알고리즘을 구동할 수 있는 NPU의 설계가 필요하다는 사 실을 본 개시의 발명자들은 인식하였다. 더 나아가서, 이러한 프로그래밍 방법에 최적화된 하드웨어가 제공되면 하드웨어에서 효율적이고 유연하게 활성 화 함수를 프로그래밍 할 수 있다는 사실을 본 개시의 발명자들은 인식하였다. 더 나아가서, 프로그래밍하고자 하는 활성화 함수의 형태에 기초하여 각 영역을 설정하고, 설정된 영역 별로 근 사화 파라미터가 프로그래밍 될 수 있다. 활성화 함수의 각 영역별 특성을 고려하면, 효율적이고 낮은 근사화 에러로 활성화 함수를 프로그래밍 할 수 있다는 사실을 본 개시의 발명자들은 인식하였다. 더 나아가서, 프로그래머블 활성화 함수(programmable activation function; PAF)는 프로그램된 활성화 함수 실행 유닛(programmed activation function execution unit; PAFE Unit)을 포함하는 하드-와이어된 프로세서에제공될 수 있다는 사실을 본 개시의 발명자들은 인식하였다. 이에, 본 개시가 해결하고자 하는 과제는 종래의 근사화 방법보다 상대적으로 우수하고 다양한 하드웨어 옵션으 로 비선형 활성화 함수를 하드웨어에서 처리 가능하게 프로그래밍할 수 있는 방법을 제공하는 것이다. 나아가, 본 개시가 해결하고자 하는 과제는 활성화 함수 자체의 특성, 근사화 에러, 하드웨어의 옵션 정보 등을 고려하여 보다 커스터마이즈된(customized) 방식으로 비선형 활성화 함수를 근사화 하는 방법을 제공하는 것이다. 더 나아가, 본 개시가 해결하고자 하는 과제는 PAFE 유닛을 포함하는 하드-와이어된 프로세서를 제공하는 것이다. *더 나아가, 본 개시가 해결하고자 하는 과제는 적어도 하나의 프로그램된 활성화 함수를 처리하도록 구성된 PAFE 유닛을 포함하는 하드-와이어된 프로세서를 제공하는 것이다. 다만, 본 개시의 과제들은 이상에서 언급한 과제들로 제한되지 않으며, 언급되지 않은 또 다른 과제들은 아래의 기재로부터 통상의 기술자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "기타 예시의 구체적인 사항들은 상세한 설명 및 도면들에 포함된다."}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시에 따르면, NPU는 활성화 함수의 프로그램된 파라미터를 입력 받아 활성화 함수를 처리할 수 있다. 본 개시에 따르면, 세그먼트 데이터를 이용함으로써, 다양한 비선형 활성화 함수, 특히 새롭게 제안되거나 알려 졌으나 일부가 수정된 활성화 함수들을 하드웨어에서 처리 가능하게 프로그래밍할 수 있다. 또한, 본 개시에 따르면, 다양한 비선형 활성화 함수를 근사화 할 때, 활성화 함수 자체의 특성, 근사화 에러, 하드웨어의 옵션 정보 등이 포함된 세그먼트 데이터를 이용할 수 있다. 이에, DNN의 높은 성능 및 높은 효율을 확보하면서 보다 커스터마이즈된 방식으로 비선형 활성화 함수를 프로그래밍할 수 있다. 또한, 본 개시에 따르면, 다양한 비선형 활성화 함수를 근사화 할 때, 활성화 함수 자체의 특성, 근사화 에러, 하드웨어의 옵션 정보 등이 포함된 세그먼트 데이터를 이용함으로써, 하드웨어 비용을 최소화하면서 근사화 에 러를 최소화할 수 있다. 또한, 본 개시에 따르면, 활성화 함수의 각각의 세그먼트를 다양한 알고리즘으로 각각 프로그래밍 할 수 있다. NPU는 프로그램된 활성화 함수의 각각의 세그먼트의 알고리즘을 처리할 수 있는 하드웨어 옵션을 제공할 수 있 다. 또한, 본 개시에 따르면, PAFE 유닛을 포함하는 하드-와이어된 프로세서를 구현할 수 있다. 따라서 프로세서는 하드웨어 변경 없이 프로그래밍 가능한 파라미터만 변경함으로써 어떠한 활성화 함수를 처리할 수 있다. 또한, 본 개시에 따르면 적어도 하나의 프로그램된 활성화 함수를 처리하도록 구성된 PAFE 유닛을 포함하는 하 드-와이어된 프로세서를 구현할 수 있다. 따라서 프로세서는 하드웨어 변경 없이 PAFE 유닛으로 서로 다른 활성 화 함수들을 동시에 또는 순차적으로 처리할 수 있다. 개시에 따른 효과는 이상에서 예시된 내용에 의해 제한되지 않으며, 더욱 다양한 효과들이 본 개시 내에 포함된 다."}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 개시에 개시되어 있는 본 개시의 개념에 따른 예시들에 대해서 특정한 구조적 내지 단계적 설명들은 단지 본 개시의 개념에 따른 예시를 설명하기 위한 목적으로 예시된 것이다. 본 개시의 개념에 따른 실시 예들은 다양한 형태로 실시될 수 있다. 본 개시는 본 개시에 설명된 실시 예들에 한정되는 것으로 해석되어서는 아니 된다. 본 개시의 개념에 따른 실시 예는 다양한 변경을 가할 수 있다. 본 개시는 여러 가지 형태를 가질 수 있다. 따 라서 특정 예시들을 도면에 예시하고 본 개시에서 상세하게 설명하고자 한다. 그러나, 이는 본 개시의 개념에 따른 예시를 특정한 개시 형태에 대해 한정하려는 것이 아니다. 따라서 본 개시의 사상 및 기술 범위에 포함되 는 모든 변경, 균등물 내지 대체물은 본개시에 포함되는 것으로 이해되어야 한다. 제 1 및/또는 제 2 등의 용어는 다양한 구성 요소들을 설명하는데 사용될 수 있다. 다만 본 개시는 상기 용어들 에 의해 한정되어서는 안 된다. 상기 용어들은 하나의 구성 요소를 다른 구성 요소로부터 구별하는 목적으로만 사용된다. 예컨대 본 개시의 개 념에 따른 권리 범위로부터 이탈되지 않은 채, 제 1 구성요소는 제 2 구성요소로 명명될 수 있고, 유사하게 제 2 구성요소는 제 1 구성요소로도 명명될 수 있다. 어떤 구성요소가 다른 구성요소에 \"연결되어\" 있다거나 \"접속되어\" 있다고 언급된 때에는, 그 다른 구성요소에 직접적으로 연결되어 있거나 또는 접속되어 있을 수도 있지만, 중간에 다른 구성요소가 존재할 수도 있다고 이 해되어야 할 것이다. 반면에, 어떤 구성요소가 다른 구성요소에 \"직접 연결되어\" 있다거나 \"직접 접속되어\" 있 다고 언급된 때에는, 중간에 다른 구성요소가 존재하지 않는 것으로 이해되어야 할 것이다. 구성요소들 간의 관계를 설명하는 다른 표현들, 즉 \"~사이에\"와 \"바로 ~사이에\" 또는 \"~에 이웃하는\"과 \"~에 직 접 이웃하는\" 등도 마찬가지로 해석되어야 한다. 본 문서에서, \"A 또는 B,\" \"A 또는/및 B 중 적어도 하나,\" 또는 \"A 또는/및 B 중 하나 또는 그 이상\" 등의 표현 은 함께 나열된 항목들의 모든 가능한 조합을 포함할 수 있다. 예를 들면, \"A 또는 B,\" \"A 및 B 중 적어도 하나,\" 또는 \"A 또는 B 중 적어도 하나\"는, 적어도 하나의 A를 포함, 적어도 하나의 B를 포함, 또는 적어도 하나의 A 및 적어도 하나의 B 모두를 포함하는 경우를 모두 지칭할 수 있다. 본 개시에서 사용된 \"제 1,\" \"제 2,\" \"첫째,\" 또는 \"둘째,\" 등의 표현들은 다양한 구성요소들을, 순서 및/또는 중요도에 상관없이 수식할 수 있다. 상기 표현들은 한 구성요소를 다른 구성요소와 구분하기 위해 사용될 뿐 해 당 구성요소들을 한정하지 않는다. 예를 들면, 제 1 사용자 기기와 제 2 사용자 기기는, 순서 또는 중요도와 무 관하게, 서로 다른 사용자 기기를 나타낼 수 있다. 예를 들면, 본 문서에 기재된 권리범위를 벗어나지 않으면서 제 1 구성요소는 제 2 구성요소로 명명될 수 있고, 유사하게 제 2 구성요소도 제 1 구성요소로 바꾸어 명명될 수 있다. 본 개시에서 사용된 용어들은 단지 특정한 실시 예를 설명하기 위해 사용된 것으로, 다른 예시의 범위를 한정하 려는 의도가 아닐 수 있다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함할 수 있다. 기술적이거나 과학적인"}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "용어를 포함해서 여기서 사용되는 용어들은 본 문서에 기재된 기술분야에서 통상의 지식을 가진 자에 의해 일반 적으로 이해되는 것과 동일한 의미를 가질 수 있다. 본 개시에 사용된 용어들 중 일반적인 사전에 정의된 용어들은, 관련 기술의 문맥상 가지는 의미와 동일 또는 유사한 의미로 해석될 수 있다. 본 개시에 사용된 용어들은 본 문서에서 명백하게 정의되지 않는 한, 이상적이 거나 과도하게 형식적인 의미로 해석되지 않는다. 경우에 따라서, 본 문서에서 정의된 용어일지라도 본 문서의 실시 예들을 배제하도록 해석될 수 없다. 본 개시에서 사용한 용어는 단지 특정한 실시 예를 설명하기 위해 사용된 것으로, 본 개시를 한정하려는 의도가 아니다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\" 또는 \"가지다\" 등의 용어는 서술된 특징, 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것이 존재함 을 지정하려는 것이다. 따라서 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 본 개시가 속하는 기술 분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가지고 있다. 일 반적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의미 를 가지는 것으로 해석되어야 한다. 본 개시에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적인 의미로 해석되지 않는다. 본 개시의 여러 예시들의 각각 특징들이 부분적으로 또는 전체적으로 서로 결합 또는 조합 가능하다. 본 개시의 여러 예시들은 당업자가 충분히 이해할 수 있듯이 기술적으로 다양한 연동 및 구동이 가능하다. 본 개시의 각 예시들이 서로에 대하여 독립적으로 실시 가능할 수도 있고 연관 관계로 함께 실시 가능할 수도 있다. 각 예시를 설명함에 있어서 본 개시가 속하는 기술 분야에 익히 알려져 있고 본 개시와 직접적으로 관련이 없는 기술 내용에 대해서는 설명을 생략한다. 이는 불필요한 설명을 생략함으로써 본 개시의 요지를 흐리지 않고 더 욱 명확히 전달하기 위함이다. 이하, 첨부한 도면을 참조하여 본 개시의 예시를 상세하게 설명한다. 도 1은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치를 설명하는 개략적인 개 념도이다. 도 1을 참조하면, 활성화 함수 프로그래밍 방법을 수행하기 위한 장치(A)는 신경 프로세싱 유닛(Neural Processing Unit, NPU), 및 활성화 함수 변환 프로그램 유닛(Activation Function Programming Unit)을 포함할 수 있다. 여기서 장치(A)는 시스템을 의미할 수 있다. 장치(A)는 프로세서 (Processor), 메인 메모리(Main Memory), 이미지 센서(Image Sensor), 및 디코더 (Decoder)를 더 포함할 수 있다. 이에, 장치(A)는 다양한 인공신경망 추론 기능을 수행하도록 구성될 수 있다. 장치(A)에 포함될 수 있는 각각의 구성요소들은 버스를 통해 데이터를 주고받을 수 있다. 여기서, NPU, 프로세서, 메인 메모리, 이미지 센서, 및 디코더는 전기 회로로 구성될 수 있다. 활성화 함수 변환 프로그램 유닛은 기록 매체에 저장된 컴퓨터 프로그램, 소프트웨어, 펌웨어, 어플리케이션, 또는 실행 코드 등 일 수 있다. 단 본 개시는 이에 제한되지 않는다. 활성화 함수 변환 프로그램 유닛은 활성화 함수를 프로그래머블 파라미터로 표현된 PAF로 변환하는 명령 을 수행하도록 구성된 컴퓨터 프로그램일 수 있다. 활성화 함수 변환 프로그램 유닛은 컴퓨터로 판독 가 능한 기록 매체에 저장될 수 있다. 컴퓨터로 판독 가능한 기록 매체는 ROM, RAM, SSD, HDD, CD-ROM, flash memory, 자기 테이프, 플로피디스크, 광데이터 저장장치 등을 포함할 수 있다. NPU는 프로세서와 별개로 심층신경망(deep neural network, DNN)을 위한 동작을 위해 특화된 프로 세서이다. 특히, NPU는 DNN의 대부분의 연산량을 차지하는 합성곱 및 행렬 곱셈을 위해 특화된 연산기를 포함할 수 있다. NPU와 프로세서는 전기 회로를 포함하는 반도체 칩일 수 있다. NPU는 제어기(controller), 다이렉트 메모리 액세스(direct memory access; DMA), 메모리 (memory), 적어도 하나의 프로세싱 엘리먼트(at least one processing element), 및 프로그램된 활 성화 함수 실행 유닛(programmed activation function execution unit; PAFE Unit)을 포함할 수 있다. 이 하 프로그램된 활성화 함수 실행 유닛은 PAFE 유닛으로 지칭하여 설명한다. 제어기는 DMA, 메모리, 적어도 하나의 프로세싱 엘리먼트, 및 PAFE 유닛과 전기적으 로 연결될 수 있다. 제어기는 NPU에서 DNN의 연산과 관련된 동작을 제어하도록 구성될 수 있다. 단, 본 개시는 이에 제한되지 않으며, 적어도 하나의 프로세싱 엘리먼트는 프로세싱 엘리먼트 어레이 (예 를 들면, 시스톨릭(systolic) 어레이)로 변형 실시될 수 있다. DMA는 NPU가 NPU 외부의 메인 메모리 등에 직접 접근하여 읽기/쓰기를 하도록 구성된다. NPU는 DMA을 통해 메인 메모리로부터 DNN과 관련된 다양한 데이터를 읽어올 수 있 다. DMA는 내부 메모리의 어드레스의 설정, 생성 및 제어 등의 업무를 수행하도록 구성될 수 있다. 메모리는 NPU의 온칩 영역에 배치된 메모리로 온칩 영역에서 처리되는 데이터를 캐싱(caching)하거 나 저장하기 위한 메모리일 수 있다. 메모리는 메인 메모리로부터 DNN의 연산에 필요한 데이터를 읽 어 들여 저장할 수 있다. 메모리는 ROM, SRAM, DRAM, Resistive RAM, Magneto-resistive RAM, Phase- change RAM, Ferroelectric RAM, Flash Memory, HBM 등과 같은 메모리 중 하나의 메모리를 포함할 수 있다. 메 모리는 적어도 하나의 메모리 유닛으로 구성될 수 있다. 메모리는 단일(homogeneous) 메모리 유닛 또 는 이종(heterogeneous) 메모리 유닛으로 구성될 수 있다. 적어도 하나의 프로세싱 엘리먼트는 DNN의 입력 데이터와 대응되는 파라미터(e.g., 가중치, 커널, 쿼리 (Q), 키(K), 값(V) 등)의 연산을 처리하도록 구성될 수 있다. 적어도 하나의 프로세싱 엘리먼트는 MAC(Multiply And Accumulate) 연산기 및/또는 ALU(Arithmetic Logic Unit) 연산기 등을 포함할 수 있다. PAFE 유닛은 활성화 함수를 변환한 프로그래머블 활성화 함수(programmable activation function; PAF)에 대한 데이터(i.e., 프로그래머블 파라미터)를 수신하도록 구성된다. 이하 설명의 편의를 위해 프로그래머블 활성화 함수는 PAF로 지칭하여 설명한다. 프로그래머블 파라미터는 활성화 함수 변환 프로그램 유닛에서 생성된 데이터일 수 있다. 프로그래머블 파라미터는 NPU의 PAFE 유닛의 회로와 호환되는 형태를 가지도록 구성될 수 있다. 프로그래머블 파 라미터는 적어도 하나의 PAF를 구현하도록 구성될 수 있다. 즉, PAFE 유닛은 활성화 함수 변환 프로그램 유닛에서 생성된 적어도 하나의 PAF에 대응되는 프로그래머블 파라미터를 제공받도록 구성될 수 있다. 부 연 설명하면, 활성화 함수 변환 프로그램 유닛을 통해 프로그램된 PAF는 적어도 하나의 프로그래머블 세 그먼트를 포함할 수 있다. 즉, 프로그래머블 파라미터는 적어도 하나의 프로그래머블 세그먼트를 구현할 수 있 다. NPU는 활성화 함수와 관련하여 PAF에 대한 데이터를 수신해서 DNN의 연산을 수행할 수 있다. PAFE 유닛 은 적어도 하나의 프로세싱 엘리먼트에서 출력된 연산 값(e.g., 특징맵)에 활성화 함수 변환 프로그 램 유닛에서 생성된 PAF를 적용하여 활성화 값(activation value)(e.g., 활성화맵)을 생성할 수 있다. PAFE 유닛은 적어도 하나의 PAF에 대응하여 생성된 적어도 하나의 프로그래머블 파라미터를 이용한다. 따 라서 PAFE 유닛은 다양한 활성화 함수, 특히 새롭게 제안되거나 알려졌으나 일부가 수정된 활성화 함수들 을 NPU에서 처리 가능하게 한다. PAFE 유닛은 적어도 하나의 프로세싱 엘리먼트와 파이프라인화 될 수 있다. 상술한 구성에 따르면, 적어도 하나의 프로세싱 엘리먼트에서 연산한 값을 파이프라인을 통해 입력 받도록 구성될 수 있다. 따라 서 파이프라인 된 적어도 하나의 프로세싱 엘리먼트와 PAFE 유닛은 적어도 하나의 프로세싱 엘리먼트 로부터 연산 값을 입력 받아 PAF가 적용된 활성화 값을 출력하도록 구성될 수 있다. 이러한 경우, 적어도 하나의 프로세싱 엘리먼트와 PAFE 유닛에서 발생할 수 있는 병목 현상을 최소화하거나 또는 실질적으 로 제거할 수 있다. 단, 본 개시의 예시들은 파이프라인 구조에 제한되지 않으며, PAFE 유닛은 적어도 하나의 프로세싱 엘리먼트와 병합되어 구현되는 것도 가능하다. 활성화 함수 변환 프로그램 유닛은 프로세서에 의해서 동작될 수 있으나 이에 제한되지 않는다. 프 로세서는 본 개시에서 개시된 활성화 함수 프로그래밍 방법을 수행할 수 있는 CPU(Central Processing Unit), AP(Application Processor)와 같은 연산 장치일 수 있다. 활성화 함수 변환 프로그램 유닛은 컴퓨터로 판독 가능한 기록 매체에 저장될 수 있다. 활성화 함수 변환 프로그램 유닛은 하드웨어에 포함된 펌웨어 또는 소프트웨어로 구현될 수 있다. 활성화 함수 변환 프로그 램 유닛의 구동을 위해서 별도의 컴퓨팅 시스템과 오퍼레이팅 시스템이 제공될 수 있다. 활성화 함수 변 환 프로그램 유닛은 PAFE 유닛이 포함된 NPU동작을 위한 프로그램일 수 있다. 활성화 함수 변 환 프로그램 유닛은 활성화 함수 프로그래밍 방법을 수행하도록 구성될 수 있다. 활성화 함수 변환 프로 그램 유닛은 프로세서 또는 장치(A) 외부의 프로세서에 의해 실행될 수 있다. 활성화 함수 변환 프 로그램 유닛은 장치(A) 내에서 DNN을 컴파일하도록 구성된 컴파일러와 별개로 구성될 수 있다. 또는 활성 화 함수 변환 프로그램 유닛은 컴파일러와 통합되어 구성될 수 있다. 활성화 함수 변환 프로그램 유닛은 적어도 하나의 활성화 함수를 프로그래밍 하도록 구성될 수 있다. 활 성화 함수 변환 프로그램 유닛은 적어도 하나의 PAF에 대응되는 프로그래머블 파라미터를 PAFE 유닛(50 0)에 제공하도록 구성될 수 있다.활성화 함수 변환 프로그램 유닛은 NPU가 처리하고자 하는 DNN에 포함된 활성화 함수 정보를 제공 받도록 구성될 수 있다. 활성화 함수 변환 프로그램 유닛은 제공받은 적어도 하나의 활성화 함수의 정보 에 기초하여 NPU가 처리할 모든 활성화 함수에 대한 정보를 획득할 수 있다. 따라서, 활성화 함수 변환 프로그램 유닛은 NPU가 처리할 DNN에 필요한 적어도 하나의 활성화 함수를 프로그래밍할 수 있다. 다양한 예시들에서, 활성화 함수 변환 프로그램 유닛은 활성화 함수를 세그먼팅하기 위한 세그먼트 데이 터를 생성하고, 생성된 세그먼트 데이터를 이용하여 활성화 함수를 복수의 세그먼트들로 세그먼팅하고, 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화 할 수 있다. 프로그래머블 파라미터 의 값이 결정되면 프로그래머블 세그먼트의 근사화 수준이 결정될 수 있다. 활성화 함수 변환 프로그램 유닛 은 세그먼트 데이터를 기초로 상기 복수의 세그먼트들의 개수 및 폭을 결정할 수 있다. 활성화 함수 변환 프로그램 유닛은 활성화 함수의 특성을 분석하도록 구성될 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 활성화 함수의 기울기 변화를 분석하도록 구성될 수 있다. 활성화 함수의 기 울기 변화 데이터는 활성화 함수의 기울기 변화를 판단할 수 있는 모든 종류의 데이터를 지칭할 수 있다. 활성화 함수 변환 프로그램 유닛은 기울기 변화 데이터를 기초로 활성화 함수의 특성을 분석할 수 있다. 부연 설명하면 활성화 함수의 기울기 변화가 심할 영역일수록, 근사화 에러가 커지는 경향이 있고, 기울기 변화 가 없는 영역의 경우, 근사화 에러가 0이 될 수 있다. 따라서, 활성화 함수 변환 프로그램 유닛은 기울기 변화 데이터를 분석하여 활성화 함수를 최적의 조건으로 근사화 하도록 구성될 수 있다. 예를 들면, 활성화 함수의 기울기 변화 데이터는 활성화 함수의 미분 데이터일 수 있다. 기울기 변화 데이터는: 기울기 변화 값, 1차 미분 값, 2차 미분 값, 3차 미분 값 등 중 적어도 하나를 포함할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 활성화 함수의 기울기 변화 데이터를 기초로 PAF의 선형 구간 및 비선형 구간을 결정할 수 있다. 몇몇 예시에서는, 활성화 함수 변환 프로그램 유닛은 PAF의 비선형 구간 중 기울기 변화가 실질적으로 미 미한 구간을 실질적 선형 구간으로 결정할 수 있다. 활성화 함수 변환 프로그램 유닛은 적어도 하나의 세그먼트를 특정 수학식으로 근사화 된 프로그래머블 세그먼트로 변환시킬 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 활성화 함수의 특정 세그먼트를 1차 함수로 근사화 된 프 로그래머블 세그먼트로 변환 시킬 수 있다. 자세히 설명하면, 활성화 함수 변환 프로그램 유닛은 적어도 하나의 세그먼트를 특정 기울기 및 특정 오 프셋 값으로 근사화 된 프로그래머블 세그먼트로 변환시킬 수 있다. 활성화 함수 변환 프로그램 유닛은 복수의 세그먼트들 중 적어도 하나의 세그먼트를 특정 비선형 근사식을 이용하여 프로그래머블 세그먼트로 변환 시킬 수 있다. 활성화 함수 변환 프로그램 유닛은 적어도 하나의 세그먼트를 1차 함수에 대응되는 프로그 래머블 세그먼트로 근사화 하기 위한 기울기 및 오프셋을 결정할 수 있다. 활성화 함수 변환 프로그램 유닛은 프로그래머블 세그먼트의 기울기 값과 오프셋 값을 변환하면서 최소 에러 값을 탐색할 수 있다. 또는 활성화 함수 변환 프로그램 유닛은 비용 함수(cost function)를 수행하 여 최소 에러 값을 탐색할 수 있다. 활성화 함수 변환 프로그램 유닛은 변환하고자 하는 활성화 함수의 적어도 하나의 세그먼트와 후보 기울 기 및 후보 오프셋을 갖는 적어도 하나의 후보 세그먼트 사이의 에러 값을 계산할 수 있다. 활성화 함수 변환 프로그램 유닛은 계산된 에러 값에 기초하여 적어도 하나의 후보 세그먼트를 프로그래머블 세그먼트를 결 정할 수 있다. 활성화 함수 변환 프로그램 유닛은 서로 대응되는 프로그래머블 세그먼트와 활성화 함수의 세그먼트 사이의 적어도 하나의 최소 에러 값을 탐색할 수 있다. 활성화 함수 변환 프로그램 유닛은 탐색 된 적어도 하나의 최소 에러 값에 기초하여 프로그래머블 세그먼트의 프로그래머블 파라미터를 결정할 수 있다. 여기서 결정된 에러 값은 최소 에러 값일 수 있다. 활성화 함수 변환 프로그램 유닛이 최소 에러 값을 기 준으로 프로그래머블 파라미터를 결정하면, DNN의 추론 정확도 열화를 예방 또는 최소화할 수 있다. 단 본 개시의 예시들은 최소 에러 값에 제한되지 않으며, 연산량, 전력 소비량, 근사화 에러 값 중 다른 우선 순위에 따라 프로그래머블 파라미터를 다르게 결정할 수 있다. 부연 설명하면, 활성화 함수 변환 프로그램 유닛은 특정 세그먼트를 특정 근사화 함수로 변환된 프로그래 머블 세그먼트의 근사화 에러 값을 측정할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 특정 세그먼트를 1차 함수의 프로그래머블 세그먼트로 근사화 하여 프로그래머블 세그먼트의 제1 에러 값을 측정할 수 있다. 추가적으로 활성화 함수 변환 프로그램 유닛은 상기 특정 세그먼트를 2차 함수의 프로그래머블 세그먼트로 근사화 하여 프로그래머블 세그먼트의 제2 에러 값을 측정할 수 있다. 활성화 함수 변환 프로그램 유닛은 제1 에러 값과 제2 에러 값을 비교하여 에러 값이 상대적으로 더 작은 근사화 함수를 프로그래머 블 세그먼트로 선택할 수 있다. 상술한 과정을 통해 활성화 함수 변환 프로그램 유닛은 인공신경망 연산 을 위한 활성화 함수를 선택하고, 활성화 함수를 PAF로 변환할 수 있다. 즉, 프로그래머블 세그먼트의 근사화 함수가 결정되면, 프로그래머블 파라미터의 형태도 결정될 수 있다. 예를 들면, 특정 세그먼트가 1차 함수의 프로그래머블 세그먼트로 근사화 되면, 대응되는 프로그래머블 파라미터는 기울기 및 오프셋 값을 포함할 수 있다. 예를 들면, 특정 세그먼트가 2차 함수의 프로그래머블 세그먼트로 근사 화 되면, 대응되는 프로그래머블 파라미터는 2차 함수의 계수들(coefficients of the quadratic term)을 포함 할 수 있다. 각각의 프로그래머블 세그먼트의 근사화 함수는 선택적으로 결정될 수 있다. 즉, 제1 프로그래머블 세그먼트와 제2 프로그래머블 세그먼트의 근사화 함수들은 서로 동일하거나 또는 서로 상이할 수 있다. 각각의 프로그래머블 세그먼트의 근사화 함수의 특성을 결정하는 기준은 PAFE 유닛의 연산량, 전력 소비량, 근사화 에러 값 중 어느 하나에 기초하여 결정될 수 있다. 예를 들면, 프로그래머블 세그먼트의 근사화 함수의 특성을 결정하는 기준은 연산량, 전력 소비량, 및 근사화 에러 값들의 상대적인 우선순위에 따라 달라질 수 있다. 상기 우선순위는 활성화 함수 변환 프로그램 유닛 에서 설정될 수 있다. 다르게 설명하면, 활성화 함수 변환 프로그램 유닛은 고속 연산, 저전력, 추 론 정확도 열화 방지 중 특정 성능을 달성할 수 있도록 프로그래머블 세그먼트의 근사화 함수를 구현하는 프로 그래머블 파라미터를 탐색할 수 있다. 단 본 개시의 예시들은 특정한 근사화 판단 기준에 제한되지 않는다. 메인 메모리는 DNN의 연산에 필요한 데이터를 저장할 수 있다. 메인 메모리는 ROM, SRAM, DRAM, Resistive RAM, Magneto-resistive RAM, Phase-change RAM, Ferroelectric RAM, Flash Memory, HBM 등과 같은 메모리 중 하나의 메모리를 포함할 수 있다. 메인 메모리는 적어도 하나의 메모리 유닛으로 구성될 수 있 다. 메인 메모리는 단일(homogeneous) 메모리 유닛 또는 이종(heterogeneous) 메모리 유닛으로 구성될 수 있다. 이미지 센서는 렌즈를 통해 들어오는 빛을 이미지 또는 영상 데이터로 생성한다. NPU는 상기 이미 지 또는 영상 데이터를 NPU에서 처리되는 DNN의 입력 데이터로 사용할 수 있다. 디코더는 인코딩 된 비트 스트림의 입력 데이터를 디코딩하고, 디코딩 된 입력 데이터는 DNN의 입력으로 사용될 수 있다. 비트 스트림은 적어도 하나의 태스크(task)를 수행하도록 인코딩 된 비트 스트림일 수 있다. 비트 스트림에 포함될 수 있는 태스크는 객체 인식(Object Detection), 객체 세그먼테이션(Object Segmentation), 영상 복원(Image/Video Reconstruction), 영상 향상(Image/Video Enhancement), 객체 추적 (Object Tracking), 이벤트 인식(Event Recognition), 이벤트 감지(Event Prediction), 이상 감지(Anomaly Detection), 밀도 추정(Density Estimation), 이벤트 검색(Event Search), 측정(Measurement) 등일 수 있다. 비트 스트림은 복수의 태스크를 처리할 수 있는 복수의 인코딩 된 연산 값들을 포함할 수 있다. 디코더의 출력 데이터는 이미지, 영상, DNN의 특정 레이어의 연산 값 등 일 수 있다. 이하, 도 2 내지 도 4를 참조하여, 활성화 함수 프로그래밍 방법을 상세하게 설명한다. 도 2는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법을 설명하는 개략적인 순서도이다. 도 2를 참조하면, 활성화 함수 프로그래밍 방법은 활성화 함수를 세그먼팅하기 위한 세그먼트 데이터를 생성하 는 단계(S200), 생성된 세그먼트 데이터를 이용하여 상기 활성화 함수를 복수의 세그먼트들로 세그먼팅하는 단 계(S210), 및 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화 하는 단계 (S220)를 포함한다. 단계(S200)에서 세그먼트 데이터가 생성된다. 세그먼트 데이터는 활성화 함수를 복수의 세그먼트들로 세그먼팅 하기 위해 생성되는 데이터이다. 세그먼트 데이터에 대해서는 후술한다.단계(S210)에서는 생성된 세그먼트 데이터를 이용하여 활성화 함수를 복수의 세그먼트들로 세그먼팅한다. 본 개 시에서, '세그먼트(segment)'라는 용어는 복수의 구간으로 나누어진 활성화 함수의 일부를 의미하고, 활성화 함 수의 근사화와 관련된 용어인 '후보 세그먼트' 또는 '프로그래머블 세그먼트'와 구별된다. 다양한 예시들에서, 단계(S210)는 세그먼트 데이터를 기초로 복수의 세그먼트들의 개수 및 폭(width)을 결정하 는 단계를 포함할 수 있다. 단계(S210)에서 세그먼트 데이터를 이용하여 변환하고자 하는 활성화 함수를 세그먼 팅하는 복수의 세그먼트들의 개수 및 복수의 세그먼트들 각각의 폭이 결정될 수 있다. 복수의 세그먼트들 중 적 어도 하나의 세그먼트는 다른 세그먼트와 같거나 또는 상이한 폭을 갖을 수 있다. 본 개시에서, 복수의 세그먼트들의 구간을 X 축의 시점 및 종점의 좌표로 표현할 수도 있다. 한편으로, 복수의 세그먼트들의 개수와 복수의 세그먼트들 각각의 폭이 결정되면 복수의 세그먼트들의 구간의 좌표가 복수의 세그 먼트들의 개수와 폭을 이용하여 획득될 수 있다는 것이 이해되어야 한다. 단계(S220)에서 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화 한다. 프로그 래머블 세그먼트는 PAFE 유닛의 하드웨어 구성에 따라 프로그램 될 수 있다. 즉, 활성화 함수 변환 프로그 램 유닛은 PAFE 유닛의 하드웨어 구성을 기초로 NPU에서 처리하고자 하는 활성화 함수를 PAF 로 프로그래밍 하도록 구성될 수 있다. 예를 들면, PAFE 유닛은 각 프로그래머블 세그먼트를 특정 기울기 및 특정 오프셋으로 연산하도록 구성된 하드웨어를 가지도록 구성될 수 있다. 활성화 함수 변환 프로그램 유닛은 PAFE 유닛의 구성 정보를 제공받도록 구성될 수 있다. 이러한 경우, 활성화 함수 변환 프로그램 유닛은 기울기(slope) 및 오프셋(offset)을 갖는 1차 함수 또는 2차 함수 이상의 형태로 프로그래머블 세그먼트를 프로그래밍할 수 있다. 예를 들면, 프로그래머블 세그먼트는 특정 판단 기준에 따라 1차 함수로 근사화 될 수 있다. 이러한 경우 활성화 함수 변환 프로그램 유닛은 '(기울기 a)*(입력 값 x)+(오프셋 b)'의 형태로 표현된 프로그래머블 세그먼트를 생성할 수 있다. 상술한 특정 기울기 및 특정 오프셋은 프로그래머블 파라미터일 수 있다. 1차 함수로 근사화 되도록 결정된 프로그래머블 세 그먼트의 경우, 단계(S220)는 선택된 하나의 세그먼트를 특정 기울기 및 특정 오프셋 값으로 근사화 하는 단계 를 포함할 수 있다. 부연 설명하면, 몇몇 예시에서는, 단계과 단계은 실질적으로 하나의 단계로 수행되는 것도 가능하다. 이는, 세그먼트를 세그먼팅 하는 단계와 대응되는 프로그래머블 세그먼트의 프로그래머블 파라미터를 생성하는 단계가 동시에 수행될 수 있기 때문이다. 부연 설명하면, 몇몇 예시에서는, 단계 및 단계는 생성된 세그먼트 데이터를 이용하여 활성화 함수를 복수의 세그먼트들로 세그먼팅하고, 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화 하는 단계로 변형 실시될 수 있다. 도 3은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에 의해 활성화 함수가 근사화 되는 과정을 설명 하는 그래프이다. 도 3(a)에 도시된 활성화 함수는 도 3(b)에 도시된 바와 같이 세그먼트 데이터를 이용하여 복수의 세그먼트들 (s1, s2, s3, s4)로 세그먼팅된다. 복수의 세그먼트들(s1, s2, s3, s4)은 도 3(c)에 도시된 바와 같이 프로그 래머블 세그먼트들(a1x+b1, a2x+b2, a3x+b3, a4x+b4)로 근사화 된다. 여기서 활성화 함수 변환 프로그램 유닛 이 모든 프로그래머블 세그먼트들이 1차 함수에 대응되도록 프로그래머블 파라미터를 생성한 예시를 설명 한다. 각 프로그래머블 세그먼트는 대응되는 프로그래머블 파라미터를 포함한다. 도 3(c)에서는 복수의 세그먼트들 모 두가 1차 함수 형태의 프로그래머블 세그먼트들로 근사화 되었다. 하지만, 다양한 예시들에서 복수의 세그먼트 들 중 일부 세그먼트는 다른 형태의 프로그래머블 세그먼트로 근사화 될 수도 있다. 예를 들면, 활성화 함수 변 환 프로그램 유닛은 각각의 프로그래머블 세그먼트를 1차 함수, 2차 함수, 3차 함수, 로그 함수 등의 형 태로 프로그래밍 할 수 있다. 예를 들면, 세그먼트들(s1, s3, s4)만이 프로그래머블 세그먼트로 근사화 되고, 세그먼트(s2)는 활성화 함수가 처리될 장치에서 이용가능한 다양한 방식을 이용하여 근사화 될 수 있다. 구체적으로, 세그먼트(s2)의 구간에서 미리결정되어 저장된 룩업 테이블, 비선형 근사식 등이 하드웨어에서 이용가능한 경우, 이러한 미리결정되어 저 장된 룩업 테이블, 비선형 근사식 등을 이용하여 세그먼트(s2)가 근사화 될 수 있다. 다르게 설명하면, 활성화 함수 변환 프로그램 유닛은 각각의 세그먼트들(s1, s2, s3, s4)을 독립적으로 프로그래밍하도록 구성될 수 있다. 이때, 활성화 함수 변환 프로그램 유닛은 PAFE 유닛의 하드웨어 구성 정보를 제공받는다. 활성화 함수 변환 프로그램 유닛은 PAFE 유닛의 하드웨어 구성 정보에 기 초하여 세그먼트들(s1, s2, s3, s4) 각각에 대한 근사화 방법을 독립적으로 결정하도록 구성될 수 있다. 예를 들면, PAFE 유닛은 1차 함수 연산을 지원하는 회로를 포함하도록 구성될 수 있다. 이러한 경우, 활성 화 함수 변환 프로그램 유닛은 각각의 세그먼트들(s1, s2, s3, s4)을 1차 함수의 형태로 프로그래밍 할 수 있다. 예를 들면, PAFE 유닛은 1차 함수 및 2차 함수 연산을 지원하는 회로를 포함하도록 구성될 수 있다. 이러 한 경우, 활성화 함수 변환 프로그램 유닛은 각각의 세그먼트들(s1, s2, s3, s4)을 1차 함수 또는 2차 함 수의 형태로 프로그래밍 할 수 있다. 예를 들면, PAFE 유닛은 1차 함수, 2차 함수 및 로그(log) 함수 연산을 지원하는 회로를 포함하도록 구성 될 수 있다. 이러한 경우, 활성화 함수 변환 프로그램 유닛은 각각의 세그먼트들(s1, s2, s3, s4)을 1차 함수, 2차 함수 또는 로그 함수의 형태로 선택적으로 프로그래밍 할 수 있다. 예를 들면, PAFE 유닛은 1차 함수, 2차 함수, 로그 함수 및 지수(exponential) 함수 연산을 지원하는 회로 를 포함하도록 구성될 수 있다. 이러한 경우, 활성화 함수 변환 프로그램 유닛은 각각의 세그먼트들(s1, s2, s3, s4)을 1차 함수, 2차 함수, 로그 함수 또는 지수 함수의 형태로 선택적으로 프로그래밍 할 수 있다. 예를 들면, PAFE 유닛이 적어도 하나의 특정 함수 연산을 지원하도록 구성된 회로를 포함하도록 구성될 경 우, 활성화 함수 변환 프로그램 유닛은 각각의 세그먼트들(s1, s2, s3, s4)을 대응되는 특정 함수의 형태 로 프로그래밍 할 수 있다. 예를 들면, PAFE 유닛은 하드웨어로 설계된 1차 함수 연산 회로, 2차 함수 연산 회로, 3차 함수 연산 회로, 로그 함수 연산 회로, 지수 함수 연산 회로 또는 이와 유사한 함수 연산 회로 중 적어도 하나를 포함하도 록 구성될 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 동일한 활성화 함수도 상이한 방법으로 프로그래밍 할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 특정 활성화 함수를 1차 함수로만 프로그래밍 할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 특정 활성화 함수를 2차 함수로만 프로그래밍 할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 특정 활성화 함수를 3차 함수로만 프로그래밍 할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 특정 활성화 함수를 로그 함수로만 프로그래밍 할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 특정 활성화 함수를 지수 함수로만 프로그래밍 할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 특정 활성화 함수의 복수의 세그먼트 각각을 대응되는 근 사화 함수로 프로그래밍 할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 특정 활성화 함수의 복수의 세그먼트들을 상이한 수식의 근사화 함수들의 집합으로 프로그래밍 할 수 있다. 도 4는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에 의해 활성화 함수를 복수의 세그먼트들로 세 그먼팅하는 다양한 경우를 설명하는 그래프이다. 도 4(a)를 참조하면, PAF는 4개의 세그먼트 수를 가지고 균일한 폭을 갖게 세그먼팅 될 수 있다. 도 4(b)를 참조하면, PAF는 4개의 세그먼트 수를 가지고 상이한 폭을 갖게 세그먼팅 될 수 있다. 도 4(c)를 참조하면, PAF는 4개의 세그먼트 수를 가지고 상이한 폭을 갖게 세그먼팅 될 수 있다. 도 4(d)를 참조하면, PAF는 6개의 세그먼트 수를 가지고 상이한 폭을 갖게 세그먼팅 될 수 있다. 복수의 세그먼트들의 개수 및 복수의 세그먼트들 각각의 폭은 세그먼트 데이터를 이용하여 결정될 수 있다. 활성화 함수 변환 프로그램 유닛은 활성화 함수의 비선형성을 분석하여 복수의 세그먼트들이 상이한 폭으 로 세그먼팅 하도록 구성될 수 있다. 단, 본 개시는 이에 제한되지 않는다. 활성화 함수 변환 프로그램 유닛은 활성화 함수의 비선형성을 분석하여 복수의 세그먼트들 각각이 최적의 폭으로 세그먼팅 되도록 구성될 수 있다. 단, 본 개시는 이에 제한되지 않는다. 본 개시에서 활성화 함수는 특징적인 구간들을 포함하는 다양한 형태로 실시될 수 있다. 활성화 함수를 복수의 세그먼트들로 세그먼팅하는 경우, 활성화 함수가 갖는 다양한 형태에 따라 복수의 세그먼트의 개수와 폭이 다양 하게 결정될 수 있다. 예를 들면, 스위시(swish) 함수, Mish 함수, 시그모이드(sigmoid) 함수, 하이퍼볼릭 탄젠트(tanh) 함수, SELU 함수, GELU(Gaussian Error Linear Unit) 함수, SOFTPLUS 함수, ReLU 함수, Leaky ReLU 함수, Maxout 함수, ELU 함수 등과 같은 다양한 활성화 함수들은 (실질적) 선형 구간 및/또는 비선형 구간을 포함하는 복수의 특징 적인 구간들로 구분되는 다양한 형태를 가진다. 이에 따라, 비선형 활성화 함수를 하드웨어에서 처리 가능하게 근사화 할 때, 이러한 특징적인 구간들을 고려하여 세그먼팅하면, 즉 (실질적) 선형 구간, 비선형 구간 등을 고 려하여 세그먼트의 개수 및 폭을 결정하면, 각각의 활성화 함수의 특징에 대응하여 보다 효율적으로 활성화 함 수를 근사화 할 수 있다. 이에 따라, 본 개시에 따른 활성화 함수를 근사화 하는 방법에서는 활성화 함수의 이러한 특징적인 구간들을 고 려하여 활성화 함수를 세그먼팅하기 위해 세그먼트 데이터라는 개념을 제안한다. 세그먼트 데이터는 활성화 함 수의 불연속성 정보, 미분 데이터, 활성화 함수가 처리되는 하드웨어의 정보 등을 포함하고, 이들을 가공한 데 이터도 포함한다. 이하, 도 5 내지 도 7을 참조하여, 세그먼트 데이터 중 불연속성 정보를 이용하여 활성화 함수를 복수의 세그먼 트들로 세그먼팅하는 구체적인 과정을 설명한다. 도 5는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 세그먼트 데이터 중 기울기 변화 데이터를 이용하여 활성화 함수를 선형 구간과 비선형 구간을 구분해서 세그먼팅하는 일 예시를 설명하는 그래프이다. 활성화 함수의 기울기 변화 지점이란 활성화 함수의 기울기가 바뀌는 지점을 의미할 수 있다. 예를 들면, 활성 화 함수 변환 프로그램 유닛은 활성화 함수의 기울기 변화 지점 분석을 위해서 기울기 변화 데이터(e.g., 미분 데이터)를 생성하도록 구성될 수 있다. 단, 본 개시의 기울기 변화 데이터는 미분 데이터에 제한되지 않으 며, 이와 유사한 데이터를 포함할 수 있다. 본 개시의 예시들에 따른 기울기 변화 데이터는 활성화 함수의 n차 미분값, 예를 들면 1차 미분값, 2차 미분값, 3차 미분값 등을 포함할 수 있다. 여기서 기울기 변화 데이터는 활성화 함수와 관련된 기울기 변화율 및 기울기 변화 지점을 나타낼 수 있다. 부연 설명하면, 기울기 변화 지점은 기울기 변화 데이터가 불연속 되는 지점(d1, d2, d3)을 의미할 수 있다. 즉, 기울기 변화 데이터가 불연속 되는 지점(d1, d2, d3)에서는 반드시 활성화 함수의 기울기가 바뀐다. 따라서, 본 개시의 기울기 변화 지점은 활성화 함수의 n차 미분값, 예를 들면 1차 미분값, 2차 미분값, 3차 미분값 등의 불 연속 지점을 의미할 수 있다. 이하 도 5를 참조하여 기울기 변화 지점 탐색 과정에 대해서 설명한다. 도 5(a)에 도시된 활성화 함수 f(x)에 대한 미분 데이터 중 1차 미분값 f'(x)가 도 5(b)에 도시된다. 그리고, 도 5(a)에 도시된 활성화 함수 f(x)에 대한 미분 데이터 중 2차 미분값 f''(x)가 도 5(c)에 도시된다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 1차 미분값이 변하지 않는 구간의 시작점과 끝점을 추출하 도록 구성될 수 있다. 도 5(b)에 도시된 바와 같이, 활성화 함수 변환 프로그램 유닛은 1차 미분 값에 해 당하는 기울기 변화 데이터를 생성한다. 그리고, 활성화 함수 변환 프로그램 유닛은 w2 구간 및 w3 구간 각각에서의 1차 미분값은 상이하나 1차 미분값의 변화가 없는 것을 파악한다. 이에, 활성화 함수 변환 프로그램 유닛은 w2 구간 및 w3 구간 각각을 선형 구간으로 판단할 수 있다. 즉, 선형 구간내에서 1차 미분값에 해 당하는 기울기 변화 데이터은 변하지 않는다. 다만, w2 구간 및 w3 구간 각각에서 1차 미분 값은 상이하므로, w2 구간 및 w3 구간 각각의 경계에서의 1차 미분값에 해당하는 기울기 변화 데이터는 불연속 지점(d1, d2)을 갖 는다. 즉, w2 구간 및 w3 구간 각각의 경계에서의 1차 미분값에 해당하는 기울기 변화 데이터는 불연속 지점이 므로, w2 구간 및 w3 구간 각각의 경계는 기울기 변화 지점에 해당할 수 있다. 이러한 경우, 활성화 함수 변환 프로그램 유닛은 상기 선형 구간을 대응되는 1차 함수 형태의 프로그래머 블 파라미터로 변환시킬 수 있다. 따라서 프로그래밍하고자 하는 활성화 함수의 선형 구간을 특정 기울기와 특 정 오프셋을 가지는 1차 함수로 세그먼팅 할 수 있다. 선형 구간의 1차 미분값은 상수(constant)값일 수 있다. 부연 설명하면, 선형 구간은 1차 함수로 근사화 하여도 근사화 에러 값이 0이 될 수 있다. 따라서 활성화 함수 변환 프로그램 유닛은 w2 및 w3 구간 각각에서 실질적으로 근사화 에러가 없다고 판단할 수 있다. 즉, 활 성화 함수 변환 프로그램 유닛이 w2 및 w3 구간 각각을 1차 함수로 근사화 할 경우, PAFE 유닛의 연 산량, 전력 소비량이 최소화되면서 근사화 에러 값 또한 0이 될 수 있다. 활성화 함수 변환 프로그램 유닛은 활성화 함수의 1차 미분값이 상수 또는 0이 아닌 구간을 2차 함수 이 상 또는 곡선(비선형 함수)인 구간으로 판단하도록 구성될 수 있다. 본 개시에서, 미분 데이터와 관련하여 '선형 구간(linear interval)'이라는 용어는 활성화 함수의 1차 미분값이 정수 또는 0인 구간, 또는 활성화 함수가 1차 함수로 표현되는 구간을 의미하고, '비선형 구간(non-linear interval)'이라는 용어는 활성화 함수의 1차 미분값이 정수 또는 0이 아닌 구간을 의미할 수 있다. 단, 본 개시 의 예시들의 선형 구간의 판단은 미분값에 의해서만 결정되지 않는다. 즉, 활성화 함수 변환 프로그램 유닛 은 활성화 함수를 입력 받아 다양한 방식으로 선형 구간을 판단 또는 구분하도록 구성될 수 있다. 활성화 함수 변환 프로그램 유닛은 선형 구간의 존재 여부를 우선적으로 판단하도록 구성될 수 있다. 활 성화 함수 변환 프로그램 유닛은 선형 구간을 1차 함수 형태의 프로그래머블 파라미터로 변환하고, 나머 지 비선형 구간을 특정 함수 형태의 프로그래머블 파라미터로 변환하도록 구성될 수 있다. 부연 설명하면, 본 개시의 예시들에서 설명하는 미분 데이터는 활성화 함수의 기울기를 계산하기 위한 하나의 수학적 계산 방법일 뿐이다. 따라서 본 개시는 미분값에 제한되지 않으며, 실질적으로 유사한 기울기 계산 방법 을 활용하는 것도 가능하다. 기울기 변화 지점의 탐색은 상술한 방법에 한정되지 않고, 활성화 함수 변환 프로그램 유닛은 활성화 함 수의 1차 미분값의 변화가 X 축을 따라 특정 임계값 이상으로 커질 때 해당 지점을 기울기 변화 지점으로 판단 하도록 구성될 수 있다. 이후, 활성화 함수 변환 프로그램 유닛은 2차 미분값이 변하지 않는 구간의 시작점과 끝점을 추출하도록 구성될 수 있다. 도 5(c)에 도시된 바와 같이, 활성화 함수 변환 프로그램 유닛은 2차 미분 값에 해당하 는 기울기 변화 데이터를 생성한다. 그리고, 활성화 함수 변환 프로그램 유닛은 w1-1 구간 및 w1-2 구간 각각에서의 2차 미분값은 상이하나 2차 미분값의 변화가 없는 것을 파악한다. 다만, w1-1 구간 및 w1-2 구간 각 각에서 2차 미분 값은 상이하므로, w1-1 구간 및 w1-2 구간 각각의 경계에서의 2차 미분값에 해당하는 기울기 변화 데이터는 불연속 지점(d3)을 갖는다. 즉, w1-1 구간 및 w1-2 구간 각각의 경계에서의 2차 미분값에 해당하 는 기울기 변화 데이터는 불연속 지점(d3)이므로, w1-1 구간 및 w1-2 구간 각각의 경계는 기울기 변화 지점에 해당할 수 있다. 이러한 경우, 활성화 함수 변환 프로그램 유닛은 상기 비선형 구간을 대응되는 2차 함수 형태의 프로그래 머블 파라미터로 변환시킬 수 있다. 따라서 프로그래밍하고자 하는 활성화 함수의 비선형 구간을 2차항의 계수 및 1차항의 계수를 포함하는 특정 기울기와 특정 오프셋을 가지는 2차 함수로 세그먼팅 할 수 있다. 비선형 구 간의 2차 미분값은 상수(constant)값일 수 있다. 부연 설명하면, 비선형 구간은 2차 함수로 근사화 하여도 근사 화 에러 값이 0이 될 수 있다. 따라서 활성화 함수 변환 프로그램 유닛은 w1-1 및 w1-2 구간 각각에서 실 질적으로 근사화 에러가 없다고 판단할 수 있다. 즉, 활성화 함수 변환 프로그램 유닛이 w1-1 및 w1-2 구 간 각각을 2차 함수로 근사화 할 경우, PAFE 유닛의 연산량, 전력 소비량이 최소화되면서 근사화 에러 값 또한 0이 될 수 있다. 단 본 개시의 예시들은 이에 제한되지 않으며, w1-1 및 w1-2 구간은 1차 함수로 근사화 되는 것도 가능하다. 이 러한 경우 근사화 에러 값이 증가할 수 있으나, NPU의 PAFE 유닛 연산량 감소에 의해서 NPU의 소비 전력이 저감될 수 있다. 즉, 활성화 함수 변환 프로그램 유닛은 연산량, 전력 소비량, 근사화 에러 값 중 다른 우선 순위에 따라 프로그래머블 파라미터를 다르게 결정할 수 있다. 상술한, 활성화 함수의 2차 미분값은 활성화 함수의 기울기의 변화율을 나타낼 수 있다. 활성화 함수의 2차 미 분값이 상대적으로 큰 구간은 기울기의 변화율이 큰 구간이기 때문에, 이러한 구간에 대응하는 활성화 함수의 세그먼트는 기울기가 크게 변화하여 증감의 폭이 큰 형태를 갖게 된다. 반대로, 활성화 함수의 2차 미분값이 상 대적으로 작은 구간은 기울기의 변화율이 작은 구간이기 때문에, 이러한 구간에 대응하는 활성화 함수의 세그먼트는 기울기가 작게 변화하여 증감의 폭이 작은 형태를 갖게 된다. 특히, 활성화 함수의 2차 미분값이 특정 임계값 이하로 매우 작은 구간은 기울기의 변화율이 매우 작은 구간이 다. 이에 따라, 활성화 함수 변환 프로그램 유닛은 이러한 구간의 활성화 함수를 기울기가 거의 변화하지 않 는 실질적인 1차 함수 구간으로 판단하도록 구성될 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 활성화 함수의 2차 미분값이 임계값 이하로 매우 작은 구 간은 '실질적 선형 구간(substantially linear interval)'으로 판단하도록 구성될 수 있다. 활성화 함수의 2차 미분값에 대한 임계값에 대해서는 후술한다. 활성화 함수의 미분값이 0 또는 정수가 되는 미분차수는 활성화 함수의 기울기 변화의 정도를 나타낼 수 있다. 구체적으로, 일반적으로 함수의 최고차항의 차수가 높을수록 함수의 기울기 변화가 급격하기 때문에, 활성화 함 수의 최고차항의 차수가 높은 구간은 기울기 변화가 급격한 구간으로 다른 구간과 구별하여 보다 많은 세그먼트 의 수를 가지도록 세그먼팅될 수 있다. 특정 구간에서 활성화 함수의 최고차항의 차수는 특정 구간에서 미분값이 0 또는 정수가 되는 미분차수를 통해 결정될 수 있다. 예를 들면, 특정 구간에서 최고차항이 3차인 활성화 함수의 경우, 특정 구간에서 활성화 함수의 3차 미분값이 정수(i.e., 최고차항의 계수)가 되고 활성화 함수의 4차 미분값이 0이 되기 때문에, 특정 구간에서 3차 미분값 이 정수이거나 4차 미분값이 0이 되는 활성화 함수는 특정 구간에서 최고차항의 차수가 3차로 결정될 수 있다. 다양한 예시에서 활성화 함수의 최고차항의 차수가 3차 이상인 구간은 다른 구간들과 구별하여 보다 많은 세그 먼트의 개수를 가지도록 세그먼팅될 수 있다. 예를 들면, 활성화 함수의 최고차항의 차수가 3차 이상인 구간에 서 세그먼트들의 개수는 활성화 함수가 처리될 하드웨어에서 해당 구간에 대해 세그먼팅가능한 최대 세그먼트의 개수로 결정될 수 있다. 기울기 변화 데이터(i.e., 1차 미분값 f'(x))를 이용하여, 활성화 함수의 기울기 변화 지점을 확인할 수 있다. 기울기 변화 데이터(i.e., 1차 미분값 f'(x))를 이용하여, 활성화 함수 f(x)가 2개의 선형 구간(w2, w3)을 포함 하는 3 개의 구간들(w1, w2, w3)로 세그먼팅 될 수 있다. 즉, 활성화 함수 변환 프로그램 유닛은 프로그래밍하고자 하는 활성화 함수 f(x)의 기울기 변화 데이터를 이용하여 선형 구간(w2, w3)과 비선형 구간(w3)을 결정하여 세그먼팅 할 수 있다. 즉, 활성화 함수 f(x)는 1차 미분값 f'(x)이 (0이 아닌) 상수, 0, 임계점 이하의 곡선(비선형 함수), 또는 곡선 (비선형 함수)인 지점 또는 구간에 따라 세그먼팅될 수 있다. 다르게 설명하면, 활성화 함수 f(x)는 활성화 함 수 f(x)가 미분 가능하지 않은 지점 또는 1차 미분값 f'(x)이 불연속한 지점에 따라 세그먼팅될 수 있다. 도 5(b)에서 3개의 구간으로 세그먼팅 된 결과를 도시하나, 이는 선형 구간과 비선형 구간으로 세그먼팅 되는 과정을 간략하게 설명하기 위한 것으로, 활성화 함수 f(x)는 세그먼트 데이터를 이용하여 4개 이상의 구간, 즉 적어도 4개 이상의 세그먼트들로 세그먼팅 될 수 있음이 이해되어야 한다. 예를 들면, 선형 구간(w1)은 본 개시의 예시들에 따른 활성화 함수 프로그래밍 방법에 따라 세그먼트 데이터를 이용하여 복수의 구간으로 더 세그먼팅 될 수 있다. 선형 구간(w1)의 추가적인 세그먼팅에 의해 활성화 함수가 보다 많은 개수의 세그먼트들로 세그먼팅되어 근사화 될 수 있어, 근사화 에러(approximation error)가 감소될 수 있다. 본 개시에서 '근사화 에러'라는 용어는 활성화 함수의 특정 세그먼트와 특정 세그먼트를 근사화 한 프 로그래머블 세그먼트 사이의 차이를 의미한다. 도 6은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 세그먼트 데이터 중 기울기 변화 데이터를 이용하여 활성화 함수를 실질적 선형 구간과 비선형 구간을 구분해서 세그먼팅하는 일 예시를 설명하는 그래프 이다. 도 6(a)에 도시된 활성화 함수 f(x)에 대한 미분 데이터 중 2차 미분값 f''(x)의 절대값이 도 6(b)에 도시된다. 활성화 함수 변환 프로그램 유닛은 2차 미분값 f”(x)에 실질적 선형 구간의 임계값을 설정하여 실질적 선형 구간을 결정하도록 구성될 수 있다. 도 6(b)를 참조하면, 활성화 함수 f(x)의 2차 미분값 f''(x)의 절대값 의 최대값(Max)은 0.5일 경우, 최대값(Max)의 10%인 0.05가 실질적 선형 구간의 임계값(Th)으로 설정될 수 있다. 부연 설명하면, 활성화 함수의 2차 미분값 f”(x)이 작을수록 선형적이고, 2차 미분값 f”(x)이 클수록비선형적인 특징을 가진다고 판단할 수 있다. 즉, 실질적 선형 구간의 임계값(Th)은 활성화 함수 f(x)의 2차 미분값 f''(x)의 절대값의 최대값(Max)에 대한 상대적인 비율로 결정될 수 있다. 실질적 선형 구간의 임계값(Th)은 선형 구간은 아니지만 선형으로 근사화 하 는 경우 발생하는 에러가 허용가능한 정도인지를 기준으로 결정될 수 있다. 예를 들면, 실질적 선형 구간의 임 계값은 PAF가 적용되는 DNN의 추론 정확도 열화 정도를 결정하는 각 세그먼트의 에러 값의 수준에 따라 결정되 는 것도 가능하다. 부연 설명하면, 실질적 선형 구간의 임계값이 증가할수록 선형 구간의 세그먼트가 좀더 넓게 프로그램 될 수 있 다. 한편 세그먼트의 폭이 넓어질수록 세그먼트의 개수는 저감될 수 있다. 즉, 실질적 선형 구간의 임계값에 따 라서 PAF의 세그먼트의 총 개수와 폭이 상이해질 수 있다. 실질적 선형 구간의 탐색은 선형 구간의 탐색 이후에 수행될 수 있다. 단 본 개시는 선형 구간 탐색과 실질적 선형 구간 탐색의 순서에 제한되지 않는다. 도 6(b)의 예시들에서는 실질적 선형 구간의 임계값(Th)은 2차 미분 값 최대 값(max)의 10%로 결정될 수 있다. 단, 본 개시는 이에 제한되지 않으며 DNN의 허용가능한 에러에 따라 최대 값(max)의 5%로 결정될 수 있다. 미분 데이터, 즉 2차 미분값 f''(x)를 이용하여 활성화 함수 f(x)는 2차 미분값 f''(x)가 실질적 선형 구간의 임계값 (Th) 이하인 구간(w1, w3) 및 2차 미분값 f''(x)가 실질적 선형 구간의 임계값(Th) 이상인 구간(w2)으로 세그먼 팅 될 수 있다. 활성화 함수 f(x)에서 기울기 변화 데이터를 이용하여 실질적 선형(w1, w3) 구간 및 비선형 구 간(w2)이 결정되어 세그먼팅 될 수 있다. 제1 내지 제3 구간(w1, w2, w3)이 결정되면, 제1 내지 제3 세그먼트 (s1, s2, s3)는 대응되는 프로그래머블 파라미터를 이용하여 프로그래머블 세그먼트로 프로그래밍 될 수 있다. 도 6(b)에서 3개의 구간들(w1, w2, w3)에 대응되는 3개의 세그먼트들(s1, s2, s3)로 세그먼팅 된 결과를 도시하 나, 이는 실질적 선형 구간과 비선형 구간으로 세그먼팅 되는 과정을 간략하게 설명하기 위한 것이다. 즉, 활성 화 함수 f(x)는 세그먼트 데이터를 이용하여 4개 이상의 구간, 즉 4개 이상의 세그먼트들로 세그먼팅 될 수 있 음이 이해되어야 한다. 예를 들면, 비선형 구간(w2)은 본 개시의 예시들에 따른 활성화 함수 프로그래밍 방법에 따라 세그먼트 데이터 를 이용하여 복수의 구간으로 더 세그먼팅 될 수 있다. 비선형 구간(w2)의 추가적인 세그먼팅에 의해 근사화 에 러가 감소될 수 있다. 도 7은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 세그먼트 데이터 중 기울기 변화 데이터를 이용하여 활성화 함수를 실질적 선형 구간과 비선형 구간을 구분해서 세그먼팅하는 다른 예시를 설명하는 그래 프이다. 도 7을 참조하면, 활성화 함수 f(x)에서 비선형 구간이 세그먼트 데이터, 즉 2차 미분값 f''(x)의 절대값의 실 질적 선형 구간의 임계값(Th)을 기준으로 결정될 수 있다. 즉, 실질적 선형 구간의 임계값(Th) 이상의 영역은 비선형 구간으로 판단될 수 있다. 구체적으로, 도 7(b)를 참조하면, 활성화 함수 변환 프로그램 유닛은 미분 데이터, 즉 2차 미분값 f''(x)를 이용하여 활성화 함수 f(x)를 실질적 선형 구간 및 비선형 구간으로 세그 먼팅할 수 있다. 나아가 활성화 함수 변환 프로그램 유닛은 활성화 함수 f(x)의 비선형 구간을 예를 들면 2개의 구간들(w2, w3)에 대응되는 세그먼트들(s2, s3)로 세그먼팅 할 수 있다. 즉, 활성화 함수 변환 프로그램 유닛은 활성화 함수 f(x)의 기울기 변화 데이터를 이용하여 실질적 선형 (w1, w4) 구간 및 비선형 구간(w2, w3)을 구분하고 비선형 구간(w2, w3)을 세그먼팅 될 수 있다. 활성화 함수 변환 프로그램 유닛은 다양한 방법으로 각각의 세그먼트에 대응되는 최적의 프로그래머블 파 라미터를 탐색하도록 구성될 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 고속 연산, 저전력, 추론 정확도 열화 방지 중 특정 성능을 달성할 수 있는 최적의 프로그래머블 파라미터를 탐색할 수 있다. 도 7(b)에서 4개의 구간(w1, w2, w3, w4)으로 세그먼팅 된 세그먼트들(s1, s2, s3, s4)을 도시하나, 이는 실질 적 선형 구간과 비선형 구간으로 세그먼팅 되는 과정을 간략하게 설명하기 위한 것이다. 따라서, 활성화 함수 f(x)는 세그먼트 데이터를 이용하여 5개 이상의 구간, 즉 5개 이상의 세그먼트들로 세그먼팅 될 수 있음이 이해 되어야 한다. 예를 들면, 비선형 구간들(w2, w3)은 본 개시의 예시에 따른 활성화 함수 프로그래밍 방법에 따라 세그먼트 데 이터를 이용하여 복수의 구간으로 더 세그먼팅 될 수 있다. 구체적으로 비선형 구간들(w2, w3)은 2차 미분값 f''(x)의 최대값(Max)를 기준으로 세그먼팅될 수 있다. 즉, 실질적 선형 구간의 임계값(Th)에서부터 2차 미분값f''(x)의 최대값(Max) 까지의 영역은 w2 구간으로 세그먼팅된다. 그리고, 2차 미분값 f''(x)의 최대값(Max)부터 실질적 선형 구간의 임계값(Th)은 w3 구간으로 세그먼팅된다. 비선형 구간들(w2, w3)에서 추가적인 세그먼팅이 실시될 경우 근사화 에러가 더 감소될 수 있다. 도 8는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 세그먼트 데이터 중 기울기 변화 데이터를 이용하여 활성화 함수를 비선형 구간을 구분해서 세그먼팅하는 또 다른 예시를 설명하는 그래프이다. 도 8을 참조하면, 활성화 함수 f(x)에서 비선형 구간이 세그먼트 데이터, 즉 2차 미분값 f''(x)의 절대값의 실 질적 선형 구간의 임계값(Th)을 기준으로 결정될 수 있다. 즉, 실질적 선형 구간의 임계값(Th) 이상의 영역은 비선형 구간으로 판단될 수 있다. 구체적으로, 도 8(b)를 참조하면, 활성화 함수 변환 프로그램 유닛은 미분 데이터, 즉 2차 미분값 f''(x)를 이용하여 활성화 함수 f(x)를 실질적 선형 구간 및 비선형 구간으로 세그 먼팅할 수 있다. 나아가 활성화 함수 변환 프로그램 유닛은 활성화 함수 f(x)의 비선형 구간을 예를 들면 3개의 구간들(w2, w3, w4)에 대응되는 세그먼트들(s2, s3, s4)로 세그먼팅 할 수 있다. 즉, 활성화 함수 변환 프로그램 유닛은 활성화 함수 f(x)의 기울기 변화 데이터를 이용하여 실질적 선형 (w1, w5) 구간 및 비선형 구간(w2, w3, w4)을 구분하고 비선형 구간(w2, w3, w4)을 세그먼팅 될 수 있다. 단, 본 개시의 예시는 실질적 선형 구간에 제한되지 않으며, 실질적 선형 구간도 비선형 구간으로 세그먼팅 될 수 있다. 즉, 실질적 선형 구간을 판단하는 단계는 경우에 따라서 실시되지 않을 수 있다. 활성화 함수 변환 프로그램 유닛은 다양한 방법으로 각각의 세그먼트에 대응되는 최적의 프로그래머블 파 라미터를 탐색하도록 구성될 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 고속 연산, 저전력, 추론 정확도 열화 방지 중 특정 성능을 달성할 수 있는 최적의 프로그래머블 파라미터를 탐색할 수 있다. 도 8(b)에서 5개의 구간(w1, w2, w3, w4, w5)으로 세그먼팅 된 세그먼트들(s1, s2, s3, s4, s5)을 도시하나, 이는 실질적 선형 구간과 비선형 구간으로 세그먼팅 되는 과정을 간략하게 설명하기 위한 것이다. 따라서, 활성 화 함수 f(x)는 세그먼트 데이터를 이용하여 6개 이상의 구간, 즉 6개 이상의 세그먼트들로 세그먼팅 될 수 있 음이 이해되어야 한다. 단, 본 개시의 예시는 실질적 선형 구간에 제한되지 않으며, 실질적 선형 구간도 비선형 구간으로 세그먼팅 될 수 있다. 예를 들면, 비선형 구간들(w2, w3, w4)은 본 개시의 예시에 따른 활성화 함수 프로그래밍 방법에 따라 세그먼트 데이터를 이용하여 복수의 구간으로 더 세그먼팅 될 수 있다. 구체적으로 비선형 구간들(w2, w3, w4)은 2차 미분값 f''(x)의 적분값( )을 기준으로 세그먼팅될 수 있다. 다르게 설명하면, 활성화 함수 변환 프로그램 유닛은 기울기 변화 데이터의 적분값을 기준으로 비 선형 구간들을 세그먼팅 할 수 있다. 2차 미분값 f''(x)의 적분값( )값이 높을 경우 PAF와 활성화 함수 사이에 근사화 에러값이 증가할 수 있다. 즉, 2차 미분값 f''(x)의 적분값( )값이 높을 경우 에러가 발생하여 추론 정확도 열화가 발생할 수 있다. 한편, 2차 미분값 f''(x)의 적분값( )값이 클수록 세그먼트의 폭이 넓어질 수 있다. 반대로 2차 미분값 f''(x)의 적분값( )값이 작을수록 세그먼트의 폭이 좁아질 수 있다. 이에, 활성화 함수 변환 프로그램 유닛은 특정한 2차 미분값 f''(x)의 적분값( )값을 세그먼트 근사화 에러의 적분 임계값으로 설정할 수 있다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 w1 구간 의 끝부터 2차 미분값 f''(x)을 적분할 수 있다. 따라서, w2 구간은 w1 구간의 끝부터 기 설정된 세그먼트 근사 화 에러의 적분 임계값이 특정 값이 될 때 까지가 될 수 있다.보다 구체적으로, w2 구간에서 2차 미분값 f''(x)의 적분값( )이 세그먼트 근사화 에러의 적분 임 계값에 대응하도록 s2로 세그먼팅될 수 있다. 그리고, w3 구간에서 2차 미분값 f''(x)의 적분값 ( )이 세그먼트 근사화 에러의 적분 임계값에 대응하도록 s3로 세그먼팅될 수 있다. 그리고, w4 구 간에서 2차 미분값 f''(x)의 적분값( )이 세그먼트 근사화 에러의 적분 임계값에 대응하도록 s4로 세그먼팅될 수 있다. *즉, w2 구간에서 2차 미분값 f''(x)의 적분값( )과 w3 구간에서 2차 미분값 f''(x)의 적분값 ( )과 w4 구간에서 2차 미분값 f''(x)의 적분값( )은 모두 세그먼트 근사화 에러의 적 분 임계값과 동일한 값일 수 있다. 다만, 세그먼트 근사화 에러의 적분 임계값은 NPU의 PAFE 유닛의 비교기(comparator)의 개수, PAFE 유닛의 회로의 구현에 사용된 게이트 개수, 구현된 연산 회로 종류 (1차 함수 회로, 2차 함수 회로, 3차 함수 회로, 지수 회로, 로그 회로, 안티로그 회로 등) 중 적어도 하나를 포함하는 하드웨어 데이터에도 영향을 받을 수 있다. 즉, 활성화 함수 변환 프로그램 유닛은 세그먼트 근사화 에러의 적분 임계값을 상기 하드 웨어 데이터를 고려하여 결정하도록 구성될 수 있다. 즉, 세그먼트 근사화 에러의 적분 임계값이 작을수록 PAF가 활성화 함수에 보다 근접할 수 있다. 다시 말하면, 세그먼트 근사화 에러의 적분 임계값이 작아질 경우, 프로그래머블 세그먼트의 개수가 증가하게 되어, PAF의 근 사화 에러값이 보다 더 감소될 수 있다. 다만, 하드웨어 데이터에 의해 프로그래머블 세그먼트의 개수가 제한되므로, 세그먼트 근사화 에러의 적분 임계 값이 작아지는데 한계가 있다. 즉, 하드웨어 데이터에 따라 세그먼트 근사화 에러의 적분 임계값의 하한이 결정 될 수 있다. 상술한 비선형 구간들(w2, w3, w4)에서 추가적인 세그먼팅이 실시될 경우 근사화 에러가 더 감소될 수 있다. 단, 본 개시의 예시는 실질적 선형 구간에 제한되지 않으며, 실질적 선형 구간도 비선형 구간으로 세그먼팅 될 수 있다. 즉, 실질적 선형 구간을 판단하는 단계는 경우에 따라서 실시되지 않을 수 있다. 도 5 내지 도 8에 도시된 바와 같이, 활성화 함수 변환 프로그램 유닛은 기울기 변화 데이터를 이용하여 활성화 함수를 세그먼팅하면, 활성화 함수를 근사화 하기 전에 활성화 함수로부터 선형 구간을 판단할 수 있다. 활성화 함수 변환 프로그램 유닛은 기울기 변화 데이터를 이용하여 활성화 함수를 세그먼팅하면, 활성화 함수를 근사화 하기 전에 활성화 함수로부터 비선형 구간을 판단할 수 있다. 활성화 함수 변환 프로그램 유닛 은 기울기 변화 데이터를 이용하여 활성화 함수를 세그먼팅하면, 활성화 함수를 근사화 하기 전에 활성화 함수로부터 실질적 선형 구간을 판단할 수 있다. 구별된 선형 구간 또는 실질적 선형 구간을 갖는 세그먼트는 '(기울기 a)*(입력 값 x)+(오프셋 b)'의 형태로 표 현된 프로그래머블 세그먼트로 근사화 될 수 있다. 이때, 선형 구간 또는 실질적 선형 구간을 갖는 세그먼트는 1차 함수 또는 기울기가 거의 일정한 실질적인 1차 함수 형태이다. 따라서 활성화 함수를 기울기 및 오프셋으로 표현된 프로그래머블 세그먼트와 비교하면, 프로그 램 된 세그먼트는 근사화 에러가 없거나 또는 최소화될 수 있다. 따라서, 기울기 변화 데이터를 이용하여 활성화 함수를 프로그래밍하면, 선형 구간 또는 실질적 선형 구간에 대 한 연산량 및 전력 소비량이 매우 줄어들 수 있다. 따라서 본 개시의 예시들에 따른 선형 또는 실질적 선형 구간을 프로그래밍한 활성화 함수는 효율적이면서도 근 사화 에러가 최소화되어 NPU에서 처리되는 DNN의 연산 속도 향상, 추론 정확도 열화 최소화, 및NPU의 소비 전력 저감을 제공할 수 있다. 다양한 예시들에서, 단계(S210)은 활성화 함수의 기울기 변화 데이터를 기초로 활성화 함수의 선형 구간을 결정 하는 단계를 더 포함할 수 있다. 다양한 예시들에서, 단계(S210)은 활성화 함수의 기울기 변화 데이터를 기초로 활성화 함수의 비선형 구간을 결 정하는 단계를 더 포함할 수 있다. 다양한 예시들에서, 단계(S210)은 활성화 함수의 기울기 변화 데이터를 기초로 활성화 함수의 실질적 선형 구간 을 결정하는 단계를 더 포함할 수 있다. 다양한 예시들에서, 단계(S210)은 활성화 함수의 기울기 변화 데이터를 기초로 활성화 함수의 선형 구간 및 비 선형 구간을 결정하는 단계를 더 포함할 수 있다. 다양한 예시들에서, 단계(S210)은 활성화 함수의 기울기 변화 데이터를 기초로 활성화 함수의 실질적 선형 구간 및 비선형 구간을 결정하는 단계를 더 포함할 수 있다. 다양한 예시들에서, 단계(S210)은 활성화 함수의 미분 데이터를 기초로 활성화 함수의 선형 구간, 실질적 선형 구간 및 비선형 구간을 결정하는 단계를 더 포함할 수 있다. 단, 본 계시의 예시들은 활성화 함수의 미분 데이터에 제한되지 않으며, 활성화 함수의 기울기 변화, 선형성 분 석이 가능한 다양한 수학적 분석을 통해 실시되는 것도 가능하다. 다양한 예시들에서, 세그먼트 데이터는 활성화 함수가 처리되는 하드웨어의 정보를 포함할 수 있다. 본 개시의 예시들에 따른 활성화 함수 프로그래밍 방법에서 하드웨어의 정보를 이용하여 활성화 함수를 세그먼팅 할 수 있 다. 하드웨어 데이터는 서 NPU의 PAFE 유닛의 비교기(comparator)의 개수, PAFE 유닛의 회로 의 구현에 사용된 게이트 개수, 구현된 연산 회로 종류 (1차 함수 회로, 2차 함수 회로, 3차 함수 회로, 지수 회로, 로그 회로, 안티로그 회로 등) 중 적어도 하나를 포함할 수 있다. 예를 들면, NPU의 PAFE 유닛의 비교기의 개수에 따라 활성화 함수를 세그먼팅하는 복수의 세그먼트 들의 개수가 제한될 수 있다. 이에 활성화 함수는 활성화 함수가 처리될 NPU가 처리할 수 있는 세그먼트 들의 최대 개수 또는 할당된 NPU의 자원에 대응하는 세그먼트들의 개수로 세그먼팅 될 수 있다. 이에 따 라, 활성화 함수 변환 프로그램 유닛은 미리결정된 하드웨어 자원을 보다 효율적이거나 보다 커스터마이 즈된 방식으로 사용하여 활성화 함수를 프로그래밍할 수 있다. 다양한 예시들에서, 단계는 기울기 변화 지점에 기초하여 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화 하는 단계를 더 포함할 수 있다. 다양한 예시들에서, 단계는 에러 값에 기초하여 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래 머블 세그먼트로 근사화 하는 단계를 더 포함할 수 있다. 본 개시에서, ' 에러 값' 또는 '근사화 에러 값'이라는 용어는 활성화 함수의 특정 세그먼트와 상기 특정 세그 먼트가 근사화 된 프로그래머블 세그먼트 사이의 차이를 의미한다. 근사화 에러 값은 평균 값, 최소 값, 최대 값, 누적 값 등을 더 포함할 수 있다. 부연 설명하면, 활성화 함수 변환 프로그램 유닛은 특정 세그먼트 와 근사화 된 프로그래머블 세그먼트 사이의 평균 에러 값, 최소 에러 값, 최대 에러 값, 누적 에러 값 등을 계 산하도록 구성될 수 있다. 누적 에러 값은 특정 세그먼트와 근사화 된 프로그래머블 세그먼트 사이의 에러 값들 을 적분한 값일 수 있다. 에러 값과 관련하여, 다양한 활성화 함수들이 (실질적) 선형 구간 및/또는 비선형 구간을 포함하는 복수의 특 징적인 구간들로 구분될 수 있으며, 이러한 특징적인 구간들을 동일한 폭의 세그먼트로 세그먼팅하면 각 세그먼 트별로 에러 값이 크게 달라지게 된다. 이에 따라, 본 개시의 예시들에 따른 활성화 함수 프로그래밍 방법에서, 근사화 에러를 감소시키기 위해 다양한 방식으로 이러한 특징적인 구간들 중 적어도 하나의 특징을 고려하여 프 로그래머블 세그먼트들로 근사화 할 수 있다. 다양한 예시들에서, 단계(S220)는 프로그래머블 세그먼트의 기울기 및 오프셋과 활성화 함수의 대응되는 세그먼 트를 비교하여 에러 값을 계산하는 단계를 더 포함할 수 있다. 다양한 예시들에서, 단계(S220)는 활성화 함수의 적어도 하나의 세그먼트를 상기 프로그래머블 세그먼트로 변환 하기 위한 프로그래머블 파라미터를 결정하는 단계를 더 포함할 수 있다. 다르게 설명하면, 단계(S220)는 활성화 함수의 적어도 하나의 세그먼트를 상기 프로그래머블 세그먼트로 변환하기 위한 최적의 프로그래머블 파라미 터를 탐색하는 단계를 더 포함할 수 있다. 여기서 상기 프로그래머블 세그먼트가 1차 함수일 경우, 프로그래머 블 파라미터는 1차 함수에 대응되는 기울기 및 오프셋을 포함할 수 있다. 여기서 상기 프로그래머블 세그먼트가 2차 함수일 경우, 프로그래머블 파라미터는 대응되는 2차 함수의 계수들(Coefficients of the quadratic ter m)를 포함할 수 있다. 2차 함수의 계수들은 2차 계수, 선형 계수 및 상수를 포함할 수 있다. 프로그래머블 파라 미터의 근사화 함수는 고속 연산, 저전력, 추론 정확도 열화 방지 등의 성능을 고려하여 결정될 수 있다. 예를 들면, 근사화 함수의 수식이 복잡해질수록, 연산 속도가 저하되고 소비 전력이 증가할 수 있다. 근사화 에러가 적어질수록 추론 정확도 열화가 저감될 수 있다. 다양한 예시들에서, 단계(S220)는 활성화 함수의 적어도 하나의 세그먼트와 (임시) 기울기 및 (임시) 오프셋을 갖는 적어도 하나의 후보 세그먼트(candidate segment) 사이의 에러 값을 계산하는 단계를 더 포함할 수 있다. 후보 세그먼트의 개수가 많을수록, 최적의 프로그래머블 파라미터 값을 탐색할 가능성이 증가하나, 탐색 시간이 증가될 수 있다. 다양한 예시들에서, 단계(S220)는 계산된 에러 값들에 기초하여 적어도 하나의 후보 세그먼트의 파라미터를 프 로그래머블 세그먼트의 프로그래머블 파라미터로 결정하는 단계를 포함할 수 있다. 따라서, 활성화 함수 변환 프로그램 유닛은 프로그램된 활성화 함수 데이터를 NPU에 제공할 수 있 다. 여기서 프로그램된 활성화 함수 데이터는 적어도 하나의 프로그램된 활성화 함수를 포함할 수 있다. 여기서 프로그램된 활성화 함수 데이터는 적어도 하나의 프로그램된 활성화 함수의 각각의 프로그래머블 세그먼트와 대 응되는 프로그래머블 파라미터를 포함할 수 있다. 이하, 도 9 내지 도 11을 참조하여, 에러 값에 기초하여 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로 그래머블 세그먼트로 근사화 하는 과정을 구체적으로 설명한다. 활성화 함수의 프로그래밍 과정에서는, 프로그래머블 세그먼트들 사이의 접점에서 단차가 나타날 수 있다. 본 개시의 예시들에 따른 활성화 함수 프로그래밍 방법에서 프로그래머블 세그먼트들 사이의 또는 일 프로그래머블 세그먼트의 시점 및/또는 종점에서 소정의 단차를 발생시켜 근사화 에러를 크게 감소시킬 수 있다. 이에 따라, 본 개시에서는 활성화 함수를 세그먼트 데이터를 이용하여 복수의 세그먼트들로 세그먼팅하고 에러 값에 기초하여 이러한 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화 하는 과정에서, 프로그래머블 세그먼트들 사이의 단차를 허용함으로써 에러 값을 크게 감소시킬 수 있다. 도 9을 참조하면, 비선형 활성화 함수의 세그먼트(s)에 대한 복수의 후보 세그먼트들(Sc1, Sc2, Sc3)이 도시된다. 본 개시의 예시들에서, '후보 세그먼트'라는 용어는 활성화 함수 프로그래밍 방법을 이용하여 '프로그래머블 파 라미터'에 의해 표현된 프로그래머블 세그먼트가 될 수 있는 함수를 의미한다. 예를 들면, 프로그래머블 세그먼트가 1차 함수로 표현되는 경우, 프로그래머블 세그먼트는 '(기울기 a)*(입력 값 x)+(오프셋 b)'로 표현될 수 있다. 여기서 프로그래머블 파라미터는 기울기 a 및 오프셋 b를 포함한다. 예를 들면, 프로그래머블 세그먼트가 2차 함수로 표현될 경우, 프로그래머블 세그먼트는 '(2차 계수 a)*(입력 값 x2)+(선형 계수 b)*(입력 값 x)+(상수 c)'로 표현될 수 있다. 여기서 프로그래머블 파라미터는 2차 계수 a, 선형 계수 b, 및 상수 c를 포함한다. 따라서, 프로그래머블 파라미터는 1차 함수 및 2차 함수를 모두 표현할 수 있는 형식을 가지도록 구성될 수 있 다. 단, 본 개시는 프로그래머블 파라미터의 형식에 제한되지 않는다. 이하, 1차 함수를 예를 들면 설명한다. 후보 세그먼트는 세그먼트 데이터를 이용하여 세그먼팅 된 프로그래머블 세그먼트에 대응하는 1차 함수의 형태일 수 있다. 일 세그먼트에 대한 후보 세그먼트는 일 세그먼트의 시점 및 종점을 지나는 1차 함수로 결정될 수 있다. 예를 들면, 일 세그먼트에 대한 후보 세그먼트는 일 세그먼트의 시점 및 종점을 지나는 1차 함수와 같은 기울기 를 가지면서 오프셋이 조정된 1차 함수일 수 있다. 예를 들면, 일 세그먼트에 대한 후보 세그먼트는 일 세그먼트의 시점 및 종점을 지나는 1차 함수와 상이한 기울 기를 가지면서 오프셋이 조정된 1차 함수일 수 있다. 예를 들면, 일 세그먼트에 대한 후보 세그먼트는 일 세그먼트의 접선들 중 하나로 결정될 수 있다. 도 9에서는 복수의 후보 세그먼트들 중 프로그래머블 세그먼트를 결정하는 과정을 간략하게 설명하기 위해, 세 그먼트(s)의 시점과 종점을 지나는 기울기를 공통으로 갖는 3개의 후보 세그먼트들이 도시된다. 제1 후보 세그 먼트(Sc1)는 세그먼트(s)의 시점 및 종점을 지나는 1차 함수이고, 제2 후보 세그먼트(Sc2) 및 제3 후보 세그먼트 (Sc3)는 제1 후보 세그먼트(Sc1)와 공통된 기울기를 가지면서 오프셋이 조정된 1차 함수이고, 제3 후보 세그먼트 (Sc3)는 후보 세그먼트(Sc3)가 세그먼트(s)의 접선이 되게 하는 오프셋을 갖는다. 도 9에 도시된 후보 세그먼트 들은 근사화 된 프로그래머블 세그먼트가 될 수 있는 세그먼트들을 간략하게 설명하기 위한 것으로, 실제 후보 세그먼트들은 에러 값을 감소시키기 위해 다양한 방식으로 기울기 및/또는 오프셋이 조정될 수 있다. 다양한 예시들에서, 에러 값(△y)을 탐색하여 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세 그먼트로 근사화 할 수 있다. 이때, 활성화 함수 변환 프로그램 유닛은 복수의 세그먼트들 각각의 폭을 균일한 폭으로 결정할 수 있다. 이어서 활성화 함수 변환 프로그램 유닛은 적어도 하나의 세그먼트의 에 러 값(△y)을 탐색하여 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화 할 수 있다. 단, 본 개시는 이에 제한되지 않는다. 도 10는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 에러 값(△y) 중 가장 큰 값인 최대 에러 값(max(△y))을 탐색하여 일 세그먼트를 프로그래머블 세그먼트로 근사화 하는 예시를 설명하는 그래프이다. 도 10(a)는 활성화 함수 f(x)를 세그먼팅하는 세그먼트들(s1, s2), 제1 세그먼트(s1)에 대응하는 제1 후보 세그 먼트(sc1(x)), 및 제2 세그먼트(s2)에 대응하는 제2 후보 세그먼트(sc2(x))를 도시한다. 도 10(a)에서는 각각의 후보 세그먼트들(sc1(x), sc2(x))은 각각의 세그먼트들(s1, s2)의 시점 및 종점을 지나는 각각의 1차 함수를 표 현하는 최적의 프로그래머블 파라미터(i.e., 기울기 및 오프셋)를 탐색한다. 도 10(a)에 도시된 일 예시와 같이, 활성화 함수 변환 프로그램 유닛은 제2 세그먼트(s2)와 제2 후보 세 그먼트(sc2(x)) 사이에 에러 값(△y), 즉 'f(x)-sc2(x)'의 절대값( )을 계산한다. 활성화 함수 변 환 프로그램 유닛은 에러 값(△y) 중에서 가장 큰 값인 최대 에러 값(max(△y))도 계산할 수 있다. 제2 세그먼트(s2)의 최대 에러 값(max(△y))을 감소시키기 위해, 도 10(b)에 도시된 바와 같이 후보 세그먼트 (sc2(x))를 최대 에러 값(max(△y))의 절반인 max(△y)/2 값만큼 y축 방향으로 조정(i.e., 오프셋 조정)한 제2 후보 세그먼트가 제2 세그먼트(s2)를 근사화 한 제2 프로그래머블 세그먼트(sp2(x))로 결정될 수 있다. 제1 세그먼트(s1)를 근사화 한 제1 프로그래머블 세그먼트(sp1(x))가 도 10(b)에서와 같이 도시되면, 제1 프로그 래머블 세그먼트(sp1(x))와 제2 프로그래머블 세그먼트(sp2(x)) 사이에는 Y 축으로 단차가 발생할 수 있다. 도 10(b)에서 이러한 인접한 프로그래머블 세그먼트들의 접점에서의 Y 축으로 단차는 활성화 함수 f(x)의 제2 세그먼트(s2)를 에러 값( )에 기초하여 프로그래머블 세그먼트로 근사화 하는 과정에서 의도적으 로 유도된 것일 수 있다. 즉, 특정 프로그래머블 세그먼트 내의 최대 에러 값을 감소시키도록 특정 프로그래머 블 세그먼트를 근사화하는 과정에서 인접한 프로그래머블 세그먼트들 사이의 접점에 Y 축으로 단차가 발생될 수 있다. 부연 설명하면, 각각의 프로그래머블 세그먼트는 서로 독립적을 근사화 될 수 있다. 부연 설명하면, PAF의 근사화 에러 값이 증가할수록, PAF를 활용하는 NPU의 추론 정확도의 열화가 증가될 수 있다. 이와 반대로, PAF의 근사화 에러 값이 감소할수록, PAF를 활용하는 NPU의 추론 정확도의 열화가 저감될 수 있다. 다양한 예시들에서, 에러 값에 대한 적분값(∫[sc(x)-f(x)]dx)을 이용하여 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화 할 수 있다. 활성화 함수 변환 프로그램 유닛은 각 세그먼트 의 근사화 에러 값을 적분 또는 누적하도록 구성될 수 있다. 부연 설명하면, 제1 프로그래머블 세그먼트(sp1(x))와 제2 프로그래머블 세그먼트(sp2(x))는 각각 다른 방법으로 프로그래밍 될 수 있다. 즉, 각각의 프로그래머블 세그먼트는 1차 함수, 2차 함수, 로그 함수, 지수 함수 등의방법을 각각 선택하여 프로그램 될 수 있다. 따라서, 각각의 프로그래머블 세그먼트는 동일한 함수로 프로그램 되거나 또는 상이한 함수로 프로그램 될 수 있다. 도 11은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 에러 값에 대한 적분값(∫[sc(x)f(x)]dx) 을 이용하여 일 세그먼트를 프로그래머블 세그먼트로 근사화 하는 예시를 설명하는 그래프이다. 도 11(a)는 활성화 함수 f(x)를 세그먼팅하는 세그먼트들(s1, s2), 제1 세그먼트(s1)에 대응하는 제1 후보 세그 먼트(sc1(x)), 및 제2 세그먼트(s2)에 대응하는 제2 후보 세그먼트(sc2(x))를 도시한다. 도 11(a)에서는 각각의 후보 세그먼트들(sc1(x), sc2(x))은 각각의 세그먼트들(s1, s2)의 시점 및 종점을 각각의 1차 함수를 표현하는 최적의 프로그래머블 파라미터(i.e., 기울기 및 오프셋)를 탐색한다. 실제 제2 후보 세그먼트(sc2(x))는 제2 세 그먼트(s2)의 시점 및 종점을 지나는 1차 함수와 같은 기울기를 가지면서 오프셋이 조정될 수 있다. 또는, 제2 세그먼트(s2)의 시점 및 종점을 지나는 1차 함수와 상이한 기울기를 가지면서 오프셋이 조정될 수 있다. 도 10 및 도 11을 참조하면, 제1 세그먼트(s1)는 시점(x0) 및 종점(x1)을 포함한다. 여기서 시점(x0) 및 종점 (x1)은 세그먼트 경계값을 의미할 수 있다. 도 10 및 도 11을 참조하면, 제2 세그먼트(s2)는 시점(x1) 및 종점(x2)을 포함한다. 여기서 시점(x0) 및 종점 (x1)은 세그먼트 경계값을 의미할 수 있다. 예를 들면, 제1 세그먼트(s1)는 시점(x0)이상 종점(x1) 미만으로 설정될 수 있다. 예를 들면, 제2 세그먼트(s2)는 시점(x1)이상 종점(x2) 미만으로 설정될 수 있다. 프로그래머블 파라미터는 세그먼트 경계값을 포함하도록 구성될 수 있다. 도 11(a)에 도시된 바와 같이, 활성화 함수 변환 프로그램 유닛은 제2 세그먼트(s2)와 후보 세그먼트 (sc1(x)) 사이에 적분값( )을 근사화 에러 값으로 계산하고, 적분값( ) 중 에서 가장 크기가 작은, 즉 적분값( )의 절대값이 가장 작은 후보 세그먼트를 탐색한다. 에러 값을 감소시키기 위해, 도 11(b)에 도시된 바와 같이, 적분값( 의 절대값이 가장 작은, 즉 min( )인 후보 세그먼트가 제2 프로그래머블 세그먼트(sp2(x))로 결정될 수 있다. 제1 세그먼트(s1)를 근사화 한 제1 프로그래머블 세그먼트(sp1(x))가 도 11(b)에서와 같이 도시되면, 제1 프로그 래머블 세그먼트(sp1(x))와 제2 프로그래머블 세그먼트(sp2(x)) 사이에는 Y 축으로 소정의 단차가 나타날 수 있 다. 도 11(b)에서 이러한 단차는 활성화 함수 f(x)의 제2 세그먼트(s2)를 근사화 에러 값( ) 에 기초하여 제2 프로그래머블 세그먼트(sp2(x))로 근사화 하는 과정에서 발생할 수 있다. 하지만 단차가 존재하 더라도 각각의 프로그래머블 세그먼트의 근사화 에러 값이 최소화되면 PAF를 활용하는 NPU의 추론 정확도 의 열화가 저감될 수 있다. 다양한 예시들에서, 단계(S220)은 프로그래머블 세그먼트와 대응되는 활성화 함수의 세그먼트 사이의 최소 근사 화 에러 값을 탐색(search)하는 단계를 더 포함할 수 있다. 근사화 에러 값은 평균 에러 값, 최소 에러 값, 최 대 에러 값, 누적 에러 값 등 중 적어도 하나일 수 있다. 예를 들면, 단계(S220)은 적어도 하나의 프로그래머블 세그먼트와 대응되는 적어도 하나의 활성화 함수의 세그 먼트 사이의 적어도 하나의 최소 에러 값을 탐색(search)하는 단계를 더 포함할 수 있다. *예를 들면, 단계(S220)은 탐색된 적어도 하나의 최소 에러 값에 기초하여 프로그래머블 세그먼트의 기울기 및 오프셋을 결정하는 단계를 더 포함할 수 있다. 예를 들면, 단계(S220)은 결정된 기울기 및 오프셋에 따라 상기 적어도 하나의 세그먼트를 상기 프로그래머블 세그먼트로 근사화 하는 단계를 포함할 수 있다. 다양한 예시들에서, 단계(S220)는 손실함수(loss function)를 이용한 머신 러닝을 이용하여 프로그래머블 세그 먼트를 결정하는 단계를 더 포함할 수 있다. 도 12는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 머신 러닝을 이용하여 일 세그먼트를 최적 프로그래머블 세그먼트로 근사화 하는 예시를 설명하는 그래프이다. 도 12을 참조하면, 활성화 함수 변환 프로그램 유닛은 활성화 함수 f(x)에 대한 후보 세그먼트(sc(x))를 손실함수의 초기값으로 설정한다. 활성화 함수 변환 프로그램 유닛은 머신 러닝을 통해 손실 함수의 값이 가장 작은 후보 세그먼트를 최적 프로그래머블 세그먼트(sop(x))로 결정할 수 있다. 이에 따라, 최적화된 프로그 래머블 파라미터가 탐색될 수 있다. 최적화된 파라미터 탐색을 위해, 학습을 반복 수행할 수 있다. 1회 학습은 1 이폭(epoch)을 의미할 수 있다. 학 습 횟수가 증가할수록 에러 값이 저감될 수 있다. 학습 횟수가 너무 적으면 언더피팅(under-fitting)이 될 수 있다. 학습 횟수가 너무 많으면 오버피팅(over-fitting)이 될 수 있다. 손실함수는 MSE(Mean Squared Error), RMSE(Root Mean Squared Error) 등이 사용될 수 있으나 이에 제한되지 않는다. 본 개시에서 손실함수에 초기값으로 이용되는 후보 세그먼트는 예시적으로 세그먼트 데이터를 이용하여 세그먼팅 된 세그먼트들에 대응하여 근사화 된 1차 함수, 2차 함수 또는 3차 함수 등일 수 있다. 단, 본 개시에 따른 예시들은 상술한 함수들에 제한되지 않는다. 즉, 손실함수는 활성화 함수 f(x)가 세그먼트 데이터를 이용 하여 복수의 세그먼트들로 세그먼팅 된 이후에 사용될 수 있다. 이에 따라, 손실함수를 이용한 머신 러닝은 활성화 함수의 (실질적) 선형 구간 및/또는 비선형 구간을 포함하는 복수의 특징적인 구간과 같은 활성화 함수 자체의 특성, 근사화 에러 등이 이미 고려된 이후에 수행될 수 있다. 따라서 최적화된 프로그래머블 파라미터 탐색의 계산 량 및 탐색 시간이 저감될 수 있으며 PAF 사용에 따른 NPU의 추론 정확도 열화를 최소화 할 수 있다. 또한 본 개시의 예시들에 따르면, 불필요한 세그먼트의 개수를 저감할 수 있는 효과도 제공할 수 있다. 즉, 본 개시의 예시들에 따르면, 세그먼트 개수를 최소화하는 것도 가능하다. 부연 설명하면, 두개의 인접한 프로그래 머블 세그먼트들의 근사화 에러 값의 총합이 기 설정된 임계값보다 적으면, 두개의 프로그래머블 세그먼트는 하 나의 프로그래머블 세그먼트로 통합되는 것도 가능하다. 다양한 예시들에서, 단계(S210)는 활성화 함수의 2차 미분값의 적분값(누적값)을 이용하여 활성화 함수를 복수 의 세그먼트들로 세그먼팅하는 단계를 더 포함할 수 있다. 여기서 2차 미분값의 누적값이 세그먼트 데이터로 이 용될 수 있다. 예를 들면, 단계(S210)는 활성화 함수의 2차 미분값의 누적값을 계산하는 단계를 더 포함할 수 있다. 예를 들면, 단계(S210)은 세그먼트 근사화 에러의 적분 임계값(i.e., 2차 미분값의 누적값의 임계값)을 기초로 활성화 함수를 복수의 세그먼트들로 세그먼팅하는 단계를 더 포함할 수 있다. 나아가, 본 개시에 따른 활성화 함수 프로그래밍 방법은 일차적으로 2차 미분값의 누적값을 이용하여 활성화 함 수를 복수의 세그먼트들로 세그먼팅하여 결정된 복수의 세그먼트들의 개수가 목표 개수보다 많거나 적은 경우, 세그먼트 근사화 에러의 적분 임계값을 조정하고, 조정된 임계값을 기초로 다시 활성화 함수를 복수의 세그먼트 들로 세그먼팅하는 단계를 포함할 수 있다. 구체적으로, 결정된 복수의 세그먼트들의 개수가 목표 개수보다 많은 경우, 임계값이 증가되게 조정되고, 결정된 복수의 세그먼트들의 개수가 목표 개수보다 적은 경우, 임 계값이 감소되게 조정될 수 있다. 다양한 예시에서, 활성화 함수 변환 프로그램 유닛은 세그먼트 근사화 에러의 적분 임계값을 기초로 활성 화 함수를 복수의 세그먼트들로 세그먼팅할 수 있다. 이때, 활성화 함수 변환 프로그램 유닛은 활성화 함 수의 모든 구간을 세그먼트 근사화 에러의 적분 임계값을 기초로 세그먼팅하거나 또는 활성화 함수의 일부 구간 을 세그먼트 근사화 에러의 적분 임계값을 기초로 세그먼팅할 수 있다. 특히, 활성화 함수 변환 프로그램 유닛 은 활성화 함수의 일부 구간을 (실질적) 선형 구간이 아닌 비선형 구간으로 결정하고, 비선형 구간인 일 부 구간에 대해서만 세그먼트 근사화 에러의 적분 임계값을 기초로 세그먼팅할 수 있다. 활성화 함수 변환 프로 그램 유닛은 본 개시의 다양한 예시에서 기술된 활성화 함수 프로그래밍 방법에 의해 비선형 구간이 아닌나머지 구간들을 세그먼팅할 수 있다. 도 13는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 활성화 함수의 세그먼트 근사화 에러의 적 분 임계값을 이용하여 활성화 함수를 세그먼팅하는 예시를 설명하는 그래프이다. 도 13을 참조하면, 활성화 함수 f(x)의 2차 미분값의 누적값, 즉 ∫f''(x)dx을 이용하여 활성화 함수 f(x)가 세 그먼팅 될 수 있다. 활성화 함수 f(x)의 X축의 최소값(min) 지점이 시작 지점으로 결정되거나 또는 X축의 최대 값(max) 지점이 시작 지점으로 결정될 수 있다. 단, 본 개시는 이에 제한되지 않으며, 시작 지점은 특점 지점이 되는 것도 가능하다. PAF는 예를 들면, 복수의 세그먼트 경계값(x1, x2, x3, x4, x5)를 포함하도록 프로그래밍 될 수 있다. PAF는 예를 들면, 최소값(min)과 최대값(max)을 더 포함하도록 프로그래밍 될 수 있다. 최소값(min)과 최대값 (max)은 본 개시의 예시들에 따른 활성화 함수의 프로그래밍 효율의 향상을 위한 클리핑(clipping)을 구현할 때 활용될 수 있다. 최소값 이하의 값은 최소값으로 출력될 수 있다. 최대값 이상의 값은 최대값으로 출력될 수 있 다. 시작 지점으로부터 활성화 함수 f(x)의 2차 미분값의 누적값이 임계값(ETh) (i.e., 세그먼트 근사화 에러의 적분 임계값)에 도달하는 구간마다, 활성화 함수 f(x)를 세그먼팅한다. 예를 들면, 활성화 함수 변환 프로그램 유닛은 =ETh가 되게 w1을 결정하고, =ETh가 되게 w2를 결정하고, =ETh가 되게 w3를 결정하고, =ETh가 되게 w4를 결정하고, =ETh가 되게 w5를 결정하고, =ETh가 되게 w6를 결정할 수 있다. 부연 설명하면, 각 세그 먼트 마다 ETh값을 다르게 설정하는 것도 가능하다. 즉, ETh값은 경우에 따라서 ETh1, ETh2값 등으로 복수 개 설정 되는 것도 가능하다. 부연 설명하면, 인공신경망 연산에 활용되는 PAF는 한정된 범위의 입력 값만 처리하도록 구성되는 것도 가능하 다. 예를 들면, PAF의 입력 값인 X축의 최소값(min)이 -6이 될 수 있고, 최대값(max)은 6이 될 수 있다. 입력 범위 밖의 X축의 입력 값에 대응되는 Y축의 출력 값은 포화된 값으로 표현될 수 있다. 상술한 구성에 따르면, 프로그램된 활성화 함수 데이터의 크기를 저감할 수 있는 효과가 있다. 단, 본 개시는 이에 제한되지 않는다. 도 13를 참조하면, 활성화 함수의 2차 미분값의 누적값은 활성화 함수의 기울기의 변화율이기 때문에, 활성 화 함수 f(x)에서 기울기의 변화율이 상대적으로 큰 구간들에 대응하는 세그먼트들의 폭들(w2, w3, w4)은 상대 적으로 좁게 결정되고, 활성화 함수 f(x)에서 기울기의 변화율이 없는 1차 함수인 부분을 포함하는 세그먼 트들의 폭들(w1, w6)은 상대적으로 넓게 결정될 수 있다. 도 14, 15는 ELU 활성화 함수 및 Hardswish 활성화 함수를 도시하는 그래프이다. ELU 활성화 함수 f(x)는 x>0인 경우 x이고, x≤0 경우 α(ex-1)이다(α는 하이퍼파리미터). 도 14에 도시된 바와 같이, ELU 활성화 함수는 x값이 0 이상인 경우 선형 구간에 갖고, x값이 0 미만인 경우 비 선형 구간을 갖는다. 즉, ELU 활성화 함수는 선형 구간과 비선형 구간으로 구분되는 특징을 갖는다. Hardswish 활성화 함수 f(x)는 x≤-3인 경우 0이고, x≥+3인 경우 x이고, -3<x<+3인 경우 x·(x+3)/6이다. 도 14에 도시된 바와 같이, Hardswish 활성화 함수는 x값이 -3보다 작거나 +3보다 큰 경우 선형 구간을 갖고, 그렇지 않은 경우 비선형 구간을 갖는다. 즉, Hardswish 활성화 함수는 선형 구간과 비선형 구간으로 구분되는 특징을 갖는다. 단, 본 개시는 ELU 활성화 함수 및 Hardswish 활성화 함수에 제한되지 않고, 선형 구간 및 비선형 구간으로 구 분되는 특징을 갖는 다양한 활성화 함수가 존재한다. 특히, 인공신경망의 영역에서는 인공신경망의 정확도 향상을 위해서 다양한 선형 함수와 비선형 함수가 조합된 다양한 맞춤형 활성화 함수가 제시되고 있다. 이러한 경우, 본 개시의 예시들에 따른 활성화 함수 프로그래밍 방법이 더욱 더 효과적일 수 있다. 본 개시에 따른 활성화 함수 프로그래밍 방법에서는 활성화 함수 변환 프로그램 유닛가 활성화 함수의 선 형 구간 및 비선형 구간, 나아가 실질적 선형 구간 및 비선형 구간을 구분하여, 활성화 함수를 복수의 세그먼트 들로 선택적으로 세그먼팅할 수 있다. 이에 따라, 본 개시에 따른 활성화 함수 프로그래밍 방법은 특히 (실질적) 선형 구간 및 비선형 구간을 갖는 활성화 함수를 근사화하는 프로그래밍에 있어서 효율적이면서도 근 사화 에러가 최소화되어 NPU에서 처리되는 DNN의 연산 속도 향상, 추론 정확도 열화 최소화, 및 NPU의 소비 전력 저감을 제공할 수 있다. 본 개시에 따른 활성화 함수 프로그래밍 방법에서는 활성화 함 수 변환 프로그램 유닛가 적어도 하나의 세그먼트의 프로그래머블 파라미터를 생성할 수 있다. NPU(100 0)는 상기 정보를 기초로 적어도 하나의 프로그램된 활성화 함수를 처리할 수 있다. NPU는 상기 정보를 제공받아 적어도 하나의 프로그램된 활성화 함수를 처리할 수 있다. 복수의 세그먼트들의 구간의 시점 및 종점의 좌표는 세그먼트 경계값으로 정의될 수 있다. 즉, 각각의 세그먼트 들은 세그먼트 경계값으로 표시될 수 있다. 즉, 본 개시에 따른 활성화 함수 프로그래밍 방법에 따르면, 프로그 래머블 파라미터는 세그먼트 경계값을 포함 할 수 있다. 다양한 예시들에서, 본 개시에 따른 활성화 함수 프로 그래밍 방법은 상기 복수의 세그먼트들 중 적어도 하나의 세그먼트를 미리결정된 룩업 테이블, 비선형 근사식 등을 이용하여 근사화 하는 단계를 더 포함할 수 있다. 본 개시에 따른 활성화 함수 프로그래밍 방법에서는 세그먼트 데이터를 이용하여 복수의 세그먼트들이 세그먼팅 되고, 세그먼팅 된 복수의 세그먼트들은 선택적으로 프로그래머블 세그먼트로 근사화가 가능하기 때문에, PAF로 근사화하지 않기로 결정된 구간이 존재할 수 있다. 이러한 구간에 대해서 미리결정되어 저장된 룩업 테이블, 비 선형 근사식 등이 하드웨어에서 이용가능한 경우라면, 이러한 구간은 미리결정되어 저장된 룩업 테이블, 비선형 근사식 등을 이용하여 근사화 될 수 있다. 다양한 예시들에서, 본 개시에 따른 활성화 함수 프로그래밍 방법은 복수의 세그먼트들 중 적어도 하나의 세그 먼트를 프로그래머블 세그먼트로 근사화하지 않기로 결정하는 단계를 더 포함할 수 있다. 예를 들면, 매우 복잡 한 형태를 갖는 세그먼트나 DNN에서 중요도가 낮은 세그먼트는 프로그래머블 세그먼트로 근사화하지 않기로 결 정될 수 있다. 이러한 세그먼트는 미리결정된 다른 방식으로 처리되거나 이러한 세그먼트의 개수가 많은 경우라 면 통합되어 미리결정된 다른 방식으로 처리될 수 있다. 다양한 예시들에서, 본 개시에 따른 활성화 함수 프로그래밍 방법은 각각의 세그먼트에 대한 프로그래밍 방법을 개별적인 방식으로 처리할 수 있다. 본 개시의 예시들에 따른 활성화 함수 프로그래밍 방법은 인공신경망 연산을 위한 활성화 함수를 선택하는 단계, 및 활성화 함수를 PAF로 변환하는 단계를 포함할 수 있다. 도 13를 참조하면, 예시적으로 프로그래밍 된 활성화 함수는 특정 폭을 갖는 복수의 세그먼트들을 포함하고, 특정 폭은 특정 임계값을 기초로, 즉 선택된 활 성화 함수의 2차 미분값의 누적값이 임계값에 도달하는 구간마다 결정될 수 있다. 본 개시의 다른 예시에 따른 활성화 함수 변환 프로그램을 포함하는 장치가 제공될 수 있다. 활성화 함수 변환 프로그램은, 활성화 함수를 세그먼팅하기 위한 세그먼트 데이터를 생성하고, 생성된 세그먼트 데이터를 이용하 여 활성화 함수를 복수의 세그먼트들로 세그먼팅하고, 복수의 세그먼트들 중 적어도 하나의 세그먼트를 프로그 래머블 세그먼트로 변환하도록 구성될 수 있다. 복수의 세그먼트들 중 적어도 하나의 세그먼트는 다른 세그먼트와 상이한 폭을 갖을 수 있다. 활성화 함수 변환 프로그램은 세그먼트 데이터를 기초로 복수의 세그먼트들의 개수 및 폭을 결정하고, 결정된 개수 및 폭에 기초하여 상기 활성화 함수를 복수의 세그먼트들로 세그먼팅하도록 구성될 수 있다. 세그먼트 데이터는 활성화 함수의 기울기 변화 데이터(e.g., 미분 데이터)를 포함할 수 있다. 세그먼트 데이터는 활성화 함수가 처리될 수 있는 하드웨어의 정보를 포함할 수 있다. 활성화 함수 변환 프로그 램은 하드웨어 정보를 제공받도록 구성될 수 있다. 활성화 함수 변환 프로그램은 활성화 함수의 기울기 변화 데이터를 기초로 상기 활성화 함수의 실질적 선형 구 간 및 비선형 구간을 결정하고, 결정된 실질적 선형 구간 및 비선형 구간에 따라 활성화 함수를 복수의 세그먼 트들로 세그먼팅하도록 구성될 수 있다. 활성화 함수 변환 프로그램은 적어도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화하기 위한 프로그래머 블 파라미터를 탐색한다. 활성화 함수 변환 프로그램은 탐색 완료된 최적의 프로그래머블 파라미터에 따라 적어 도 하나의 세그먼트를 프로그래머블 세그먼트로 근사화하도록 구성될 수 있다. 장치는 PAFE 유닛을 더 포함하고, PAFE 유닛은 적어도 하나의 세그먼트를 미리결정된 비선형 근사식을 이용하여 근사화하도록 구성될 수 있다. 이하에서는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법으로 프로그램된 활성화 함수를 처리하도록 구성된 NPU에 대해서 구체적으로 설명한다. 이하 설명의 편의를 위해, 도 1을 참조하여 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU을 설명한다. 도 16은 본 개시의 일 예시에 따른 프로그램된 활성화 함수를 처리하도록 구성된 PAFE 유닛을 설명하는 개념도 이다. 본 개시의 일 예시에 따른 PAFE 유닛은 1차 함수로 활성화 함수를 프로그래밍하도록 구성된 회로의 예시이 다. 활성화 함수의 프로그래밍 방법은 상술한 본 개시의 다양한 프로그래밍 예시들 중 하나에 의해 될 수 있다. 이하에서, PAFE 유닛은 PAFE 유닛으로 지칭될 수 있다. 활성화 함수 변환 프로그램 유닛은 제 공받은 하드웨어 정보를 기초로 프로그래머블 파라미터의 형태를 결정하도록 구성될 수 있다. 예를 들면, PAFE 유닛이 1차 함수 연산 회로만 포함할 경우, 활성화 함수 변환 프로그램 유닛은 모든 프로그래머블 세그먼트가 1차 함수가 되도록 동작할 수 있다. 예를 들면, PAFE 유닛이 1차 함수 연산 회로 및 2차 함수 연산 회로를 포함할 경우, 활성화 함수 변환 프로그램 유닛은 모든 프로그래머블 세그먼트가 1차 함수 또 는 2차 함수가 되도록 동작할 수 있다. 메모리는 세그먼트 레지스터(Segment Register), 제1 레지스터(First Register), 제2 레지스터 (Second Resister)를 포함할 수 있다. 예를 들면, 적어도 하나의 레지스터는 적어도 하나의 메모리의 어드 레스 또는 레지스터 맵 등을 설정하여 구현될 수 있다. 예를 들면, 적어도 하나의 레지스터는 전용 메모리 또는 적어도 하나의 전용 레지스터를 할당하여 구현될 수 있다. 즉, PAFE 유닛의 메모리는 프로그램된 활 성화 함수 데이터를 저장하도록 구성될 수 있다. 세그먼트 레지스터는 복수의 세그먼트들의 구간에 대한 정보를 저장한다. 구체적으로, 활성화 함수 변환 프로그램 유닛에서 제시하는 방법 중 하나로 결정된 복수의 세그먼트들의 구간의 X 축의 시점 및 종점의 좌표는 세그먼트 레지스터에 저장될 수 있다. 복수의 세그먼트들의 구간의 시점 및 종점의 좌표는 세그먼트 경계값(Segment Boundary Value; SB)으로 정의될 수 있다. 즉, 세그먼트 경계 값(SB0 내지 SB(N-2))에 의해, 복수의 세그먼트들의 구간이 각각 결정될 수 있다. 예를 들면, N개의 세그먼트들의 구간을 정의하기 위하여는, N-1개의 세그먼트 경계값(SB0 내지 SB(N-2))이 필요 할 수 있다. 예를 들면, 첫번째 세그먼트 경계값(SB0)을 이용하여, X축의 좌표를 기준으로 음의 무한대(-∞)부터 첫번째 세 그먼트 경계값(SB0) 까지의 구간을 정의할 수 있다. 그리고, 마지막 세그먼트 경계값(SB(N-2))을 이용하여 X축 의 좌표를 기준으로 마지막 세그먼트 경계값(SB(N-2))부터 양의 무한대(∞)의 구간을 정의할 수 있다. 단, 이에 제한되지 않으며, 무한대의 구간 최대값과 최소값을 설정하여 적절히 클리핑(clipping)하는 것도 가능하다. 그리고, 첫번째 세그먼트 경계값(SB0)과 마지막 세그먼트 경계값(SB(N-2)) 사이의 세그먼트 경계값(SB1, SB2, … )을 이용하여, 첫번째 세그먼트 경계값(SB0)과 마지막 세그먼트 경계값(SB(N-2)) 사이에 존재하는 N-1개의 세그먼트들의 구간을 정의할 수 있다. 그리고, 세그먼트 레지스터는 복수의 세그먼트 경계값(SB0 내지 SB(N-2))을 PAFE 유닛에 제공한다. 이에, PAFE 유닛은 복수의 세그먼트들의 구간에 대한 정보를 획득 할 수 있다. PAFE 유닛은 세그먼트 레지스터로부터 데이터를 입력 받도록 구성될 수 있다. 즉, 프로그램된 활성화 함수의 세그먼트들의 구간이 PAFE 유닛에서 설정될 수 있다. 1차 다항식의 경우, 제1 레지스터는 복수의 프로그래머블 세그먼트들에 대한 기울기(A0 내지 A(N-1))를 저 장하도록 구성될 수 있다. 예를 들면, 1차 다항식의 경우에는 제1 레지스터는 기울기 레지스터로 활용될 수 있다. 부연 설명하면, 제1 레지스터는 프로그래밍 방법에 따라서 기울기와 같은 특정 값을 저장하게 설정될 수 있다. 1차 다항식의 경우, 제2 레지스터는 복수의 프로그래머블 세그먼트들에 대한 오프셋(B0 내지 B(N-1))을 저 장하도록 구성될 수 있다. 예를 들면, 1차 다항식의 경우에는 제2 레지스터는 오프셋 레지스터로 활용될 수 있다. 부연 설명하면, 제2 레지스터는 프로그래밍 방법에 따라서 오프셋과 같은 특정 값을 저장하게 설정될 수 있다. 구체적으로, 활성화 함수 변환 프로그램 유닛에 의해 N개의 세그먼트들의 구간들은 N개의 프로그래머블 세그먼트들로 근사화 될 수 있다. 그리고, 각각의 프로그래머블 세그먼트들은 특정 기울기(A) 및 특정 오프셋 (B) 값을 포함한다. 즉, 메모리의 특정 레지스터는 특정 값을 선택적으로 저장할 수 있다. 부연 설명하면, 1차 함수로 근사화 된 예시에서, 최소값부터 첫번째 세그먼트 경계값(SB0)의 구간에서, 프로그 래머블 세그먼트의 기울기는 첫번째 기울기(A0)으로 표현될 수 있고, 프로그래머블 세그먼트의 오프셋은 첫번째 오프셋(B0)으로 표현될 수 있다. 여기서 최소값(Min)은 음의 무한대(-∞)일 수 있다. 마지막 세그먼트 경계값(SB(N-2))부터 최대값의 구간의 구간에서, 프로그래머블 세그먼트의 기울기는 마지막 기 울기(A(N-1))으로 표현될 수 있고, 프로그래머블 세그먼트의 오프셋은 마지막 오프셋(B(N-1))으로 표현될 수 있 다. 여기서 최대값(Max)은 양의 무한대(∞)일 수 있다. 이에, 제1 레지스터는 N개의 프로그래머블 세그먼트들 각각에 대한 기울기(A0 내지 A(N-1))를 저장할 수 있다. 그리고, 제2 레지스터는 N개의 프로그래머블 세그먼트들 각각에 대한 오프셋(B0 내지 B(N-1))을 저 장할 수 있다. 활성화 함수 변환 프로그램 유닛은 메모리에 NPU에서 처리할 프로그램된 활성화 함수 데이터를 제공 하도록 구성될 수 있다. <표1>"}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "<표1>을 참조하면, 프로그램된 활성화 함수의 구동을 위한 데이터는 활성화 함수 변환 프로그램 유닛에서 생성되어 NPU의 메모리, 예를 들면, 세그먼트 레지스터, 제1 레지스터, 및 제2 레지스터에 저장되도록 구성될 수 있다. 예를 들면, 세그먼트 레지스터는 <표1>의 세그먼트 경계값(SB)을 저장하도록 구성될 수 있다. 예를 들면, 제1 레지스터는 <표1>의 기울기(A)을 저장하도록 구성될 수 있다. 기울기(A)는 1차항의 계수로 지칭될 수 있다. 예를 들면, 제2 레지스터는 <표1>의 오프셋(B)을 저장하도록 구성될 수 있다. 오프셋(B)은 바이아스(bia s)로 지칭될 수 있다. 제어기 및/또는 DMA는 <표1>의 프로그램된 활성화 함수의 데이터를 메모리에 저장하도록 지시할 수 있다. 단, 본 개시의 예시들은 이에 제한되지 않으며, 프로그램된 활성화 함수의 데이터는 제어기 내부 의 레지스터, PAFE 유닛 내부의 레지스터, 별도의 메모리, 및 별도의 레지스터 중 적어도 하나에 저장되도 록 구성될 수 있다. 즉, 프로그램된 활성화 함수의 데이터의 저장장소는 특정 장소에 제한되지 않는다. <표1>을 참조하면, 프로그램된 활성화 함수 데이터의 일 예시가 개시된다. 예를 들면, 프로그램된 활성화 함수 데이터는 세그먼트 경계값(SB)을 포함하도록 구성될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트(S)의 범위를 포함하도록 구성될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트(S) 별 기울기(A)를 포함하도록 구성될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트(S) 별 오프셋(B)을 포함하도록 구성될 수 있다. 그리고, 제어기의 제어에 따라, 제1 레지스터는 N개의 프로그래머블 세그먼트들 각각에 대한 기울기 (A0 내지 A(N-1))를 PAFE 유닛에 출력할 수 있다. 그리고, 제어기의 제어에 따라, 제2 레지스터 는 N개의 프로그래머블 세그먼트들 각각에 대한 오프셋(B0 내지 B(N-1))을 PAFE 유닛에 출력할 수 있 다. 이에, PAFE 유닛은 프로그래머블 세그먼트들 각각에 대한 기울기(A0 내지 A(N-1)) 및 오프셋(B0 내지 B(N- 1))을 수신할 수 있다. 즉, PAFE 유닛은 제1 레지스터 및 제2 레지스터를 통해 복수의 프로그래 머블 세그먼트들에 대한 정보를 수신할 수 있다. <표2>"}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "<표2>를 참조하면, 프로그램된 ReLU의 구동을 위한 데이터는 활성화 함수 변환 프로그램 유닛에서 생성되 어 NPU의 메모리, 예를 들면, 세그먼트 레지스터, 제1 레지스터, 및 제2 레지스터에 저장 되도록 구성될 수 있다. 예를 들면, 세그먼트 레지스터는 <표2>의 세그먼트 경계값(SB)을 저장하도록 구성될 수 있다. 예를 들면, 제1 레지스터는 <표2>의 기울기(A)을 저장하도록 구성될 수 있다. 예를 들면, 제2 레지스터는 <표2>의 오프셋(B)을 저장하도록 구성될 수 있다. 프로그램된 ReLU의 경우, 하나의 세그먼트 경계값(SB)만 가지도록 프로그래밍 될 수 있다. 상술하였듯이, 하나 의 세그먼트 경계값(SB)만 가지도록 판단하는 것은 본 개시의 다양한 예시들에 따른 근사화 방법들에 의해서 수 행될 수 있다. 프로그램된 ReLU의 경우, 첫번째 세그먼트 경계값(SB1)만 프로그램 되었기 때문에, PAFE 유닛의 동작을 위 해서 하나의 비교기만 필요할 수 있다. 따라서 불필요한 비교기들은 비활성화 할 수 있다. <표2>의 비교기 활성화(En) 신호가 PAFE 유닛에 입력됨으로써, 불필요한 비교기의 전력 소모를 저감할 수 있다.<표3>"}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "<표3>을 참조하면, 클리핑(clipping)이 적용된 프로그램된 ReLU의 구동을 위한 데이터는 활성화 함수 변환 프로 그램 유닛에서 생성되어 NPU의 메모리, 예를 들면, 세그먼트 레지스터, 제1 레지스터, 및 제2 레지스터에 저장되도록 구성될 수 있다. 예를 들면, 세그먼트 레지스터는 <표3>의 세그먼트 경계값(SB)을 저장하도록 구성될 수 있다. 예를 들면, 제1 레지스터는 <표3>의 기울기(A)을 저장하도록 구성될 수 있다. 예를 들면, 제2 레지스터는 <표3>의 오프셋(B)을 저장하도록 구성될 수 있다. 클리핑이 적용될 경우 활성 화 함수 입력 값의 최소값과 최대값을 제한할 수 있다. 부연 설명하면, PAFE 유닛은 <표2>의 프로그램된 ReLU의 구동을 위한 데이터와 <표3>의 프로그램된 ReLU with clipping의 구동을 위한 데이터는 NPU에 모두 저장될 수 있다. 또한 활성화 함수 변환 프로그램 유 닛은 프로그램된 ReLU의 구동을 위한 데이터와 프로그램된 ReLU with clipping의 구동을 위한 데이터를 모두 NPU에 제공하도록 구성될 수 있다. NPU는 컴파일 된 DNN의 정보에 따라서 NPU에 저장된 복수의 프로그램된 활성화 함수를 선택적으로 PAFE 유닛에 입력하도록 구성될 수 있다. 예를 들면, NPU는 제1 인공신경망 연산에는 <표2>의 프로그램된 활성화 함수의 데이터를 사용할 수 있고, 연속되는 제2 인공신경망 연산에는 <표3>의 프로그램된 활성화 함수의 데이터를 사용하도록 PAFE 유닛을 제어할 수 있다. <표4>"}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "<표4>를 참조하면, 프로그램된 ReLU6의 구동을 위한 데이터는 활성화 함수 변환 프로그램 유닛에서 생성 되어 NPU의 메모리, 예를 들면, 세그먼트 레지스터, 제1 레지스터, 및 제2 레지스터에 저 장되도록 구성될 수 있다. 예를 들면, 세그먼트 레지스터는 <표4>의 세그먼트 경계값(SB)을 저장하도록 구성될 수 있다. 예를 들면, 제1 레지스터는 <표4>의 기울기(A)을 저장하도록 구성될 수 있다. 예를 들면, 제2 레지스터는 <표4>의 오프셋(B)을 저장하도록 구성될 수 있다. 프로그램된 ReLU6의 경우, 두개의 세그먼트 경계값(SB)을 가지도록 프로그래밍 될 수 있다. 상술하였듯이, 두개 의 세그먼트 경계값(SB)을 가지도록 판단하는 것은 본 개시의 다양한 예시들에 따른 근사화 방법들에 의해서 수 행될 수 있다. 부연 설명하면, PAFE 유닛은 <표2>의 프로그램된 ReLU의 구동을 위한 데이터, <표3>의 프로그램된 ReLU with clipping의 구동을 위한 데이터, 및 <표4>의 프로그램된 ReLU6의 구동을 위한 데이터는 NPU에 모두 저장될 수 있다. 또한 활성화 함수 변환 프로그램 유닛은 프로그램된 ReLU의 구동을 위한 데이터, 프로그 램된 ReLU with clipping, 및 프로그램된 ReLU6의 구동을 위한 데이터를 모두 NPU에 제공하도록 구성될 수 있다. NPU는 컴파일 된 DNN의 정보에 따라서 NPU에 저장된 복수의 프로그램된 활성화 함수를 선택적으로 PAFE 유닛에 입력하도록 구성될 수 있다. 예를 들면, NPU는 제1 인공신경망 연산에는 <표2>의 프로그램된 활성화 함수의 데이터를 사용할 수 있고, 연속되는 제2 인공신경망 연산에는 <표3>의 프로그램된 활성화 함수의 데이터를 사용할 수 있고, 연속되는 제3 인공신경망 연산에는 <표4>의 프로그램된 활성화 함수의 데이터를 사용하도록 PAFE 유닛을 제어할 수 있다.프로그램된 ReLU6의 경우, 첫번째 세그먼트 경계값(SB1)과 두번째 세그먼트 경계값(SB2)만 프로그램 되었 기 때문에, PAFE 유닛의 동작을 위해서 두개의 비교기만 필요할 수 있다. 따라서 불필요한 비교기들은 비 활성화 할 수 있다. 정리하면, NPU는 복수의 프로그램된 활성화 함수를 저장할 수 있다. NPU는 PAFE 유닛에 특정 한 프로그램된 활성화 함수의 데이터를 선택적으로 입력하여 특정한 인공신경망 연산을 처리할 수 있다. 또한, PAFE 유닛은 하드웨어 변경 없이 실시간으로 다양하게 프로그램된 활성화 함수의 데이터를 입력 받아 인공 신경망 연산을 처리할 수 있다. 도 17은 본 개시의 일 예시에 따른 프로그램된 활성화 함수를 처리하도록 구성된 장치의 NPU의 PAFE 유닛을 설 명하는 개념도이다. 1차 함수로 프로그래밍 된 활성화 함수를 처리하도록 구성된 예시적인 PAFE 유닛은 복수의 비교기 (Comparator 0 내지 Comparator (N-2))(510 내지 51(N-2)), 선택기(Selector, 520), 곱셈기(Multiplier) 및 가산기(Adder)를 포함하도록 구성될 수 있다. 단 본 개시의 예시들은 이에 제한되지 않으며, 다양한 방 식으로 회로를 구성하여 각 세그먼트들의 영역을 구분하는 것도 가능하다. 또한 1차 함수 이외의 다른 프로그래 밍 방법으로 활성화 함수를 처리하기 위해 추가적인 회로 구성을 더 포함하도록 PAFE 유닛이 변형 실시되 는 것도 가능하다. 본 개시의 일 예시에서는 PAFE 유닛은 1차 함수를 처리하도록 구성된 예시이기 때문에, 세그먼트 레지스터 , 제1 레지스터, 및 제2 레지스터를 입력으로 하여 PAFE 유닛이 1차 함수를 처리하도록 구 성될 수 있다. 단, PAFE 유닛은 다양한 근사화 함수를 처리하도록, 추가적인 레지스터를 더 포함하도록 변 형 실시될 수 있다. 복수의 비교기(510 내지 51(N-2)) 각각은 적어도 하나의 프로세싱 엘리먼트에서 계산된 입력 값(X)을 복수 의 세그먼트 경계값(SB0 내지 SB(N-2)) 각각과 비교한다. 예를 들면, 입력 값(X)이 복수의 세그먼트 경계값(SB0 내지 SB(N-2)) 각각보다 클 경우, 복수의 비교기(510 내 지 51(N-2)) 각각은 제1 레벨의 출력 값을 출력할 수 있다. 이와 반대로, 입력 값(X)이 복수의 세그먼트 경계값 (SB0 내지 SB(N-2)) 각각보다 작거나 같을 경우, 복수의 비교기(510 내지 51(N-2)) 각각은 제2 레벨의 출력 값 을 출력할 수 있다. 상술한 제1 레벨은 하이 레벨을 의미할 수 있고, 상술한 제2 레벨은 로우 레벨을 의미할 수 있다. 또는 상술한 제1 레벨은 로우 레벨을 의미할 수 있고, 상술한 제2 레벨은 하이 레벨을 의미할 수 있다. 이에, 복수의 비교기(510 내지 51(N-2)) 각각에서 출력된 출력 값을 통해 복수의 세그먼트들의 구간 중 입력 값 (X)이 속하는 세그먼트의 구간이 결정될 수 있다. 상술한, 복수의 비교기(510 내지 51(N-2)) 각각에서 출력된 출력 값을 구간 결정 데이터(SDD)(Section Determine Data; SDD)로 칭할 수 있다.예를 들면, 첫번째 세그먼트 경계값(SB0)이 -4일 경우, 첫번째 비교기에는 첫번째 세그먼트 경계값(SB0)이 입력된다. 첫번째 비교기에는 프로세싱 엘리먼트에서 계산된 입력 값(X)이 입력된다. 예를 들면, 두번째 세그먼트 경계값(SB1)이 -2일 경우, 두번째 비교기에는 두번째 세그먼트 경계값(SB1)이 입력된다. 두번째 비교기에는 프로세싱 엘리먼트에서 계산된 입력 값(X)이 입력된다. 즉, 프로세싱 엘리먼트에서 계산된 입력 값(X)은 복수의 비교기들에 동시에 입력될 수 있다. 예를 들면, 첫번째 세그먼트 경계값(SB0)이 -4이고, 두번째 세그먼트 경계값(SB1)이 -2이고, 입력 값(X)이 -3일 경우에, 첫번째 비교기(Comparator 0, 510)의 출력 값인 첫번째 구간 결정 데이터(SDD1)는 제1 레벨로 출력되고, 나머지 비교기(Comparator 1 내지 Comparator (N-2))의 출력 값인 첫번째 구간 결정 데이터(SDD1)를 제외한 복수의 구간 결정 데이터(SDD1 내지 SDD(N-2))는 제2 레벨로 출력될 수 있다. 이에, 복수의 비교기(510 내지 51(N-2)) 각각에서 출력된 출력 값인 구간 결정 데이터(SDD)를 통해 입력 값(X)은 세그먼트 경계값(SB)이 -4 및 -2 사이의 세그먼트의 구간에 해당한다고 결정할 수 있다. 구간 결정 데이터(SDD1 내지 SDD(N-2))는 상술한 표1 내지 표4에서 상술한 세그먼트(S)에 대응될 수 있다. <표5>는 구간 결정 데이터(SDD1 내지 SDD(N-2))의 결과에 따른 프로그램된 활성화 함수의 세그먼트(S)의 영역이 결정되는 것을 설명한다. <표5>"}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "<표5>를 참조하면, 구간 결정 데이터(SDD0, SDD1, SDD2, … SDD(N-2))의 출력에 따라 <표1> 내지 <표4>에 예시 된 세그먼트(S)가 결정될 수 있다. 특정 세그먼트(S)가 결정되면, 대응되는 기울기(A)와 오프셋(B)이 선택될 수 있다. 단 본 개시의 예시들은 이에 제한되지 않으며, 다양한 방식으로 세그먼트를 결정하는 회로를 구성하여 대 응되는 세그먼트를 판단하는 것도 가능하다. 또한 비교기 이외의 다른 방식으로 활성화 함수를 처리하기 위해 회로를 구성하여 PAFE 유닛이 변형 실시되는 것도 가능하다. 한편, 복수의 비교기(510 내지 51(N-2)) 각각은 복수의 비교기 인에이블 신호(Comp En 1 내지 Comp En (N-2)) 각각에 의해서 동작여부가 결정될 수 있다. 즉, 복수의 비교기 인에이블 신호(Comp En 1 내지 Comp En (N-2)) 각각이 제1 레벨인 경우, 복수의 비교기(510 내지 51(N-2)) 각각은 입력 값(X)과 세그먼트 경계값(SB0 내지 SB(N-2))을 비교하도록 동작할 수 있다. 이와 반 대로, 복수의 비교기 인에이블 신호(Comp En 1 내지 Comp En (N-2)) 각각이 제2 레벨인 경우, 복수의 비교기 (510 내지 51(N-2)) 각각은 입력 값(X)과 세그먼트 경계값(SB0 내지 SB(N-2))을 비교하지 않을 수 있다. 즉, 각 각의 비교기는 비활성화될 수 있다. 전술한 바와 같이, 프로그램된 활성화 함수의 복수의 세그먼트들의 개수에 따라, 세그먼트 경계값(SB0 내지 SB(N-2))의 개수가 결정된다. 예를 들면, 복수의 세그먼트들의 개수가 N개일 경우 세그먼트 경계값(SB0 내지 SB(N-2))의 개수는 N-1개이다. 예를 들면, 활성화 함수 변환 프로그램 유닛가 동일한 활성화 함수를 프로그래밍하는 경우에도, 제1 프로 그램된 활성화 함수는 10개의 세그먼트 개수를 가지도록 프로그래밍 될 수 있고, 제2 프로그램된 활성화 함수는 5개의 세그먼트 개수를 가지도록 프로그래밍 될 수 있다. 따라서, PAFE 유닛은 동일한 활성화 함수라도 각 각의 프로그램된 활성화 함수 데이터에 따라 PAFE 유닛에서 활성화되는 비교기의 개수를 다르게 제어할 수 있다. 따라서 프로그래밍에 따라 인공신경망 연산의 정확도 및 NPU의 소비 전력 사용량도 달라질 수 있다. 즉, 사용자의 요구사항에 따라 동일한 활성화 함수라도, 고성능의 활성화 함수 연산 기능을 제공하거나 또는 저전력의 활성화 함수 연산 기능을 제공하는 것도 가능하다. 한편, 세그먼트 경계값(SB)의 최대 개수에 따라, 이를 입력으로 하는 복수의 비교기의 개수도 변동되어야 한다. 예를 들면, 세그먼트 경계값(SB)의 최대 개수가 10일 경우, 비교기는 적어도 11개 이상이 구비되어야 할 수 있 다. 즉, 비교기의 최소 개수는 세그먼트 경계값의 최대 개수가 될 수 있다. 이에, 복수의 비교기(510 내지 51(N-2)) 각각은 복수의 비교기 인에이블 신호(Comp En 1 내지 Comp En (N-2)) 각각에 의해서 동작 여부를 결정할 수 있다. 따라서, 복수의 세그먼트의 개수에 따라 불필요한 비교기의 동작을 제어함으로써, NPU의 소비 전력을 저감할 수 있다. 다만, 하드웨어적인 한계로 인하여, 비교기의 개수는 제한될 수 있다. 이에, PAFE 유닛의 비교기의 개수에 따라 활성화 함수를 세그먼팅하는 복수의 세그먼트들의 개수가 제한될 수 있다. 즉, 활성화 함수는 활성화 함수 가 처리될 NPU가 처리할 수 있는 세그먼트들의 최대 개수 또는 할당된 NPU의 자원에 대응하는 세그 먼트들의 개수로 세그먼팅 될 수 있다. 한편, 본 개시의 예시들에 따른 프로그래밍 방법에 따르면, 활성화 함수의 선형 구간 및 비선형 구간을 구분하 는 것이 가능하고, 에러 값을 최소화하면서 가변적인 세그먼트 폭을 제공하여 세그먼트의 개수를 최소화하는 것 이 가능하다. 따라서 비교기의 개수를 최소화하여 NPU의 PAFE 유닛의 하드웨어의 게이트 카운트 수 를 최소화할 수 있는 장점이 있다. 또한 본 개시의 예시들에 따른 활성화 함수 프로그래밍 방법은 지원 가능한 최대 비교기의 정보를 기초로 특정 활성화 함수를 프로그래밍하도록 구성될 수 있다. 그리고, 선택기는 구간 결정 데이터(SDD0 내지 SDD(N-2))에 따라, 복수의 프로그래머블 세그먼트들에 대한 복수의 기울기(A0 내지 A(N-1)) 중 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 기울기(A)를 출력한다. 구체적으로, 제1 레지스터는 복수의 프로그래머블 세그먼트들 각각에 대한 복수의 기울기(A0 내지 A(N- 1))를 선택기에 제공한다. 그리고, 선택기는 복수의 비교기(510 내지 51(N-2)) 각각에서 출력된 구간 결정 데이터(SDD0 내지 SDD(N-2))에 따라 복수의 세그먼트들의 구간 중 입력 값(X)이 속하는 세그먼트의 구간을 결정할 수 있다. 그리고, 선택기는 복수의 프로그래머블 세그먼트들에 대한 복수의 기울기(A0 내지 A(N- 1)) 중 결정된 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 기울기(A)를 출력할 수 있다. 선택기는 구간 결정 데이터(SDD0 내지 SDD(N-2))에 따라, 복수의 프로그래머블 세그먼트들에 대한 복수의 오프셋(B0 내지 B(N-1)) 중 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 오 프셋(B)을 출력한다. 구체적으로, 제2 레지스터는 복수의 프로그래머블 세그먼트들 각각에 대한 복수의 오프셋(B0 내지 B(N- 1))을 선택기에 제공한다. 그리고, 선택기는 복수의 비교기(510 내지 51(N-2)) 각각에서 출력된 구간 결정 데이터(SDD0 내지 SDD(N-2))에 따라 복수의 세그먼트들의 구간 중 입력 값(X)이 속하는 세그먼트의 구간을 결정할 수 있다. 그리고, 선택기는 복수의 프로그래머블 세그먼트들에 대한 복수의 오프셋(B0 내지 B(N- 1)) 중 결정된 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 오프셋(B)을 출력할 수 있다. 이에, 선택기는 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 기울기 (A) 및 오프셋(B)을 출력할 수 있다. 한편, 선택기는 구간 결정 데이터(SDD0 내지 SDD(N-2))에 따라 제어되는 복수의 스위칭 소자로 구성되는 멀티플렉서(multiplexer)일 수 있으나, 선택기의 구성은 다양하게 변경될 수 있다. PAFE 유닛의 프로그램된 활성화 함수 연산부는 입력 값(X), 기울기(A) 및 오프셋(B)을 입력 받아 출력 값 (Y)를 연산하도록 구성된 회로부를 의미할 수 있다. PAFE 유닛의 프로그램된 활성화 함수 연산부는 적어도 하나의 곱셈기와 가산기를 포함하도록 구성될 수 있다. PAFE 유닛의 프로그램된 활성화 함수 연산부는 하드-와이어된 회로일 수 있다. 프로그램된 활성화 함수 연산부의 곱셈기는 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프로그래머 블 세그먼트에 대한 기울기(A)와 입력 값(X)을 곱한다. 구체적으로 곱셈기는 적어도 하나의 프로세싱 엘리먼트에서 계산된 입력 값(X)에 선택기에서 출 력된 프로그래머블 세그먼트에 대한 기울기(A)를 곱한다. 즉, 입력 값(X)는 적어도 하나의 프로세싱 엘리먼트 의 연산 값일 수 있다. 단, 본 개시는 이에 제한되지 않는다.이에, 곱셈기는 프로그래머블 세그먼트에 대한 기울기(A)를 입력 값(X)에 곱하여 출력할 수 있다. 즉, 곱 셈기의 출력은 로 표현될 수 있다. 그리고, 프로그램된 활성화 함수 연산부의 가산기는 프로그램된 활성화 함수 연산부의 곱셈기의 출력 값에 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 오프셋(B)을 더한다. 구체적으로, 가산기는 프로그래머블 세그먼트에 대한 기울기(A)를 입력 값(X)에 곱한값에 프로그래머블 세 그먼트에 대한 오프셋(B)을 더한다. 즉, 가산기의 출력은 로 표현될 수 있다. 이에, 가산기는 입력 값(X)인 연산 값에 PAF가 적용된 활성화 값을 출력할 수 있다. 즉, 본 개시의 일 예시에 따른 PAFE 유닛은 1차 함수로 프로그램된 활성화 함수를 구현하도록 구성된 회로 구성일 수 있다. 예를 들면, 본 개시의 일 예시에 따른 적어도 하나의 프로세싱 엘리먼트와 파이프라인 된 PAFE 유닛 은 1차 함수로 프로그램된 활성화 함수를 구현하도록 구성된 하드-와이어된 회로로 구성되는 것도 가능하다. 상술한 바와 같이, 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU의 PAFE 유닛은 복수의 비교기(511 내지 51(N-2)), 선택기, 곱셈기 및 가산기만으로 구성되어, 모 든 활성화 함수를 프로그래밍하여 입력 값(X)에 적용할 수 있다. 상술한, 복수의 비교기(511 내지 51(N-2)), 선택기, 곱셈기 및 가산기 각각은 상대적으로 간소 화된 하드웨어이므로, 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치는 간소화 된 하드웨어만으로도 모든 활성화 함수를 처리할 수 있는 효과가 있다. 한편, 종래의 활성화 함수 처리 장치는 미리 정의된 활성화 함수들만 처리할 수 있었다. 그러나, 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치는 미리 정의되지 않은 활성화 함수도 프로그래 밍하여, 적용할 수 있어, 프로그램된 모든 활성화 함수를 적용할 수 있는 효과가 있다. 특히, PAFE 유닛은 다양한 활성화 함수의 특성에 따라 세그먼트의 개수도 조절 가능하기 때문에, 최소 개수의 비교기를 사용하여 근사화 에러를 최소화 할 수 있다. 특히, PAFE 유닛은 다양한 활성화 함수의 특성에 따라 각각의 세그먼트 의 폭도 조절 가능하기 때문에, 최소 개수의 비교기를 사용하여 근사화 에러를 최소화 할 수 있다. 특히, PAFE 유닛은 다양한 활성화 함수의 특성에 따라 세그먼트의 폭 및 개수도 조절 가능하기 때문에, 최소 개수의 비교기를 사용하여 근사화 에러를 최소화 할 수 있다. 이하에서는 본 개시의 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU에 대해서 구 체적으로 설명한다. 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU과 본 개시의 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU는 PAFE 유닛의 분리되는 기술적 특징만 차이점 이 존재하므로, 이를 중심으로 설명한다. 도 18은 본 개시의 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU를 설명하는 개념도이 다. 도 19는 본 개시의 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU의 PAF유닛을 설명하 는 개념도이다. 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU의 PAF유닛(500-1 내지 500-N)은 복수 개로 분리될 수 있다. 구체적으로, PAF유닛은 제1 PAFE 유닛(500-1) 내지 제N PAF 유닛(500-N)을 포함할 수 있다. 그리고, 제1 PAFE 유닛(500-1) 내지 제N PAF 유닛(500-N) 각각은 서로 다른 활성화 함수를 처리하거나 또는 같은 활성화 함 수를 처리할 수 있다. 즉, 제1 PAFE 유닛(500-1) 내지 제N PAF 유닛(500-N) 각각에 프로그램된 활성화 함수는 서로 같거나 또는 상이할 수 있다. 부연 설명하면, 프로세싱 엘리먼트의 개수가 증가하면, PAFE 유닛(500-1 내지 500-N)이 처리해야할 데이터 량이 증가할 수 있다. 따라서 PAFE 유닛(500-1 내지 500-N)의 개수는 프로세싱 엘리먼트의 개수를 고려하 여 결정될 수 있다.즉, 프로세싱 엘리먼트의 출력 값인 입력 값(X)에 대응되는 프로세싱 엘리먼트의 최대 데이터 대역폭 이 PAFE 유닛이 처리할 수 있는 최대 데이터 대역폭보다 클 경우, PAFE 유닛(500-1 내지 500-N)의 개수가 증가될 수 있다. 따라서, PAFE 유닛(500-1 내지 500-N)의 부족한 데이터 대역폭에 따른 병목 현상을 해결할 수 있다. 예를 들면, 도 19에 도시된 바와 같이, PAFE 유닛은 디멀티플렉서(demultiplexer; DEMUX)와 멀티플렉서 (multiplexer; MUX)와 복수의 PAFE 유닛을 포함할 수 있다. 디멀티플렉서(DEMUX)는 입력 값(X)을 비선형의 PAF가 적용되어야 하는 입력 값과 선형의 PAF가 적용되어야 하는 입력 값을 구분한다. 그리고, 비선형의 PAF가 적용되어야 하는 입력 값을 제1 PAFE 유닛(500-1)에 분배한다. 그리고, 선형의 PAF가 적용되어야 하는 입력 값을 제2 PAFE 유닛(500-2)에 분배할 수 있다. 그리고, 제1 PAFE 유닛(500-1)은 비선형의 활성화 함수를 프로그래밍한 활성화 함수가 저장된다. 이에, 제1 PAFE 유닛(500-1)은 비선형의 PAF를 처리할 수 있다. 그리고, 제2 PAFE 유닛(500-2)은 선형의 활성화 함수를 프로그래밍한 활성화 함수가 저장된다. 이에, 제2 PAFE 유닛(500-2)은 비선형의 PAF를 처리할 수 있다. 부연 설명하면, 제1 PAFE 유닛(500-1)은 비선형의 활성화 함수를 처리하도록 구성될 수 있기 때문에, 제2 PAFE 유닛(500-2)보다 상대적으로 더 많은 개수의 비교기를 가지도록 구성될 수 있다. 한편으로, 제2 PAFE 유닛(500- 2)은 , 제1 PAFE 유닛(500-1)보다 상대적으로 더 적은 개수의 비교기를 가지도록 구성될 수 있기 때문에, 상대 적으로 더 적은 소비 전력으로 동작할 수 있다. 제1 PAFE 유닛(500-1)과 제2 PAFE 유닛(500-2) 중 하나는 NPU가 처리하는 프로그램된 활성화 함수의 종 류에 따라 선택적으로 비활성화 될 수 있다. 그리고, 멀티플렉서(MUX)는 제1 PAFE 유닛(500-1)으로부터 비선형의 PAF가 적용된 출력 값 및 제2 PAFE 유닛 (500-2)으로부터 선형의 PAF가 적용된 출력 값을 입력 받을 수 있다. 그리고, 멀티플렉서(MUX)는 제1 PAFE 유닛(500-1)으로부터 비선형의 PAF가 적용된 출력 값 및 제2 PAFE 유닛 (500-2)으로부터 선형의 PAF가 적용된 출력 값을 취합하여 출력할 수 있다. 이에, 멀티플렉서(MUX)는 입력 값(X)인 연산 값에 선형의 PAF 및 비선형의 PAF가 적용된 활성화 값을 출력할 수 있다. 본 개시의 일 예시에 따르면, 선형 구간과 비선형 구간을 모두 가지는 활성화 함수를 처리하기 위해 제1 PAFE 유닛(500-1)과 제2 PAFE 유닛(500-2)은 각각 활성화 함수의 특정 영역을 처리하도록 구성될 수 있다. 예를 들면, 도 14에 도시된 ELU 활성화 함수는 x값이 0 이상인 경우 선형 구간에 갖고, x값이 0 미만인 경우 비 선형 구간을 갖는다. 즉, ELU 활성화 함수는 선형 구간과 비선형 구간으로 구분되는 특징을 갖는다. 여기서 제1 PAFE 유닛(500-1)는 ELU 활성화 함수의 비선형 구간을 처리하도록 구성될 수 있다. 제2 PAFE 유닛(500-2)는 ELU 활성화 함수의 선형 구간을 처리하도록 구성될 수 있다. 이하에서는 본 개시의 또 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU에 대해서 구체적으로 설명한다. 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU과 본 개시의 또 다른 예시 에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU은 PAF 라이브러리에서만 차이점이 존재 하므로, 이를 중심으로 설명한다. 도 20은 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU를 설명하는 개념 도이다. NPU는 제어기, 메모리, 적어도 하나의 프로세싱 엘리먼트, 및 PAFE 유닛을 포함할 뿐만 아 니라, PAF 라이브러리를 더 포함할 수 있다. PAF 라이브러리는 활성화 함수를 근사화 한 PAF를 저장할 수 있다. 구체적으로, PAF 라이브러리는 PAF를 구성하는 복수의 프로그래머블 세그먼트들에 대한 기울기(A0 내지 A(N-1)) 및 오프셋(B0 내지 B(N-1)) 정보를 저장할 수 있다. 부연 설명하면, PAF 라이브러리는 복수의 PAF를 저장할 수 있다. 그리고, PAF 라이 브러리는 복수의 PAF 각각에 대한 복수의 프로그래머블 세그먼트들에 대한 기울기(A0 내지 A(N-1)) 및 오 프셋(B0 내지 B(N-1)) 정보를 저장할 수 있다. 단, 활성화 함수 변환 프로그램에 의해서 복수의 PAF는 1차 함수 에 제한되지 않으며 2차 다항식, 3차 다항식, 로그 함수 등을 선택적으로 조합하여 근사화 될 수 있다.예를 들 면, PAF 라이브러리는 표 2 내지 표 4에 도시된 각각의 프로그램된 활성화 함수 데이터를 저장하도록 구성 될 수 있다. 따라서 PAF 라이브러리는 프로그램된 ReLU, 클리핑이 적용된 프로그램된 ReLU, 프로그램된 ReLU6 활성화 함수를 모두 저장하도록 구성되는 것도 가능하다. 또한 제어기는 필요에 따라서, 특정 활성 화 함수를 PAF 라이브러리에서 선택하여 PAFE 유닛에 입력시키도록 제어하는 것도 가능하다. PAF 라이브러리에 저장된 복수의 프로그램된 활성화 함수는 대표적인 활성화 함수를 근사화 한 것일 수 있 다. 예를 들면, 대표적인 활성화 함수는 스위시(swish) 함수, Mish 함수, 시그모이드(sigmoid) 함수, 하이퍼볼 릭 탄젠트(tanh) 함수, SELU 함수, GELU(Gaussian Error Linear Unit) 함수, SOFTPLUS 함수, ReLU 함수, Leaky ReLU 함수, Maxout 함수, ELU 함수 일 수 있다. 이에, PAFE 유닛은 제어기의 제어에 따라, PAF 라이브러리에 저장된 복수의 PAF 중 필요로 하는 PAF를 선택할 수 있다. 그리고, PAFE 유닛은 선택된 PAF에 대한 복수의 프로그래머블 세그먼트들에 대한 기울기(A0 내지 A(N-1)) 및 오프셋(B0 내지 B(N-1)) 등의 정보를 PAF 라이브러리로부터 불러들일 수 있다. 상술한 바와 같이, 본 개시의 또 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치는 자주 사용되는 활성화 함수를 프로그래밍하여 PAF 라이브러리에 저장할 수 있다. 이에, 본 개시의 또 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치에서, 활성화 함수 변 환 프로그램이 모든 활성화 함수를 프로그래밍할 필요없이 PAF 라이브러리가 PAF를 저장할 수 있다. 따라서, 본 개시의 또 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 처리 속도는 향 상될 수 있을 뿐만 아니라, 활성화 함수 변환 프로그램을 구동 시키기 위한 소비 전력 또한 저감 시킬 수 있는 이점이 있다. 이하에서는 본 개시의 또 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU에 대해서 구체적으로 설명한다. 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU과 본 개시의 또 다른 예시 에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 NPU은 적어도 하나의 프로세싱 엘리먼트(PE Array) 및 PAFE 유닛(Unit)에서 차이점이 존재하므로, 이를 중심으로 설명한다. 도 21은 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU를 설명하는 개념 도이다. 도 21에 도시된 바와 같이, 본 개시의 또 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치 의 NPU에서, 복수의 프로세싱 엘리먼트(PROCESSING ELEMENTS #0 내지 PROCESSING ELEMENTS #N-1)는 그룹핑 (grouping) 될 수 있다. 그룹핑 된 프로세싱 엘리먼트들은 적어도 하나의 프로세싱 엘리먼트로 지칭될 수 있다. 즉, 복수의 프로세싱 엘리먼트는 제0 프로세싱 엘리먼트들(PROCESSING ELEMENTS #0) 내지 제N-1 프로세싱 엘리 먼트들(PROCESSING ELEMENTS #N-1)를 포함할 수 있다. 복수의 프로세싱 엘리먼트들(PROCESSING ELEMENTS #0 내 지 PROCESSING ELEMENTS #N-1) 각각은 PE 스레드(Processing Element Thread) 혹은 PE 코어(Processing Element Core)로 지칭될 수 있다. 이하에서는 복수의 적어도 하나의 프로세싱 엘리먼트를 PE 코어로 지칭하여 설명한다. 한편, 복수의 PE 코어 각각의 구조는 서로 상이할 수 있다. 예를 들면, 복수의 PE 코어 각각은 동작은 입력 스 테이셔너리 방식(Input stationary), 가중 스테이셔너리 방식(Weight stationary) 및 출력 스테이셔너리 방식 (Output stationary) 중 어느 하나일 수 있다. 그리고, 구동의 최적화에 따라 복수의 PE 코어 각각은 개별적으로 구동될 수 있다. 즉, 복수의 PE 코어 각각은 동시에 구동되지 않고, PAFE 유닛의 동작에 따라 순차적으로 구동될 수 있다. *그리고, 복수의 PE 코어 각각에 포함되는 프로세싱 엘리먼트인 MAC(Multiply And Accumulate) 연산기, ALU(Arithmetic Logic Unit) 연산기 등의 개수는 상이할 수 있다. 이에, 복수의 PE 코어 각각의 크기는 상이할수 있다. 그리고, 복수의 PE 코어 각각은 멀티플렉서(multiplexer; MUX)를 통해 PAFE 유닛에 연결될 수 있다.구체적으로, 멀티플렉서(MUX)는 복수의 PE 코어 각각에서 출력된 복수의 연산 값을 입력 받아, 복수의 연산 값 중 어느 하나 이상을 PAFE 유닛에 출력한다. PAFE 유닛과 복수의 PE 코어 사이에는 버퍼 메모리가 더 배치되도록 구성되는 것도 가능하다. 단, 이에 제 한되지 않는다. 이에, 하나의 PAFE 유닛은 복수의 PE 코어 각각에서 출력된 복수의 연산 값을 처리할 수 있을 수 있다. 따라서, 또 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치에 구비되는 PAFE 유닛의 개수는 최소 화될 수 있다. 결국, 이는 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 제조 비용을 최소화 시킬 수 있다. 도 22는 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하도록 구성된 PAFE 유닛을 설명하는 개 념도이다. 도 23은 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU의 PAFE 유닛을 설 명하는 개념도이다. 도 22 내지 도 23에 도시된 PAFE 유닛에서 적용되는 PAF의 복수의 프로그래머블 세그먼트 각각은 1차 함수 또는 2차 함수로 동작할 수 있다. 이에, 상술한 프로그래머블 세그먼트에 대한 계수(A, B, C)는 2차항의 계수 (Coefficient of quadratic term, A), 1차항의 계수(Coefficient of linear term, B) 및 오프셋(Offset, C)을 포함할 수 있다. 이에 맞춰, 활성화 함수 변환 프로그램 유닛은 메모리에 PU에서 처리할 프로그램된 활성화 함수 데 이터를 제공하도록 구성될 수 있다. <표6>"}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "<표6>을 참조하면, 프로그램된 활성화 함수의 구동을 위한 데이터는 활성화 함수 변환 프로그램 유닛에서 생성되어 NPU의 메모리, 예를 들면, 세그먼트 레지스터, 제1 레지스터, 제2 레지스터 및 제3 레지스터에 저장되도록 구성될 수 있다. 예를 들면, 세그먼트 레지스터는 <표6>의 세그먼트 경계값(SB)을 저장하도록 구성될 수 있다. 예를 들면, 제1 레지스터는 <표6>의 2차항의 계수(A)를 저장하도록 구성될 수 있다. 예를 들면, 제2 레지스터는 <표6>의 1차항의 계수(B)를 저장하도록 구성될 수 있다. 예를 들면, 제3 레지 스터는 <표6>의 오프셋(C)을 저장하도록 구성될 수 있다. 제어기 및/또는 DMA는 <표6>의 프로그램된 활성화 함수의 데이터를 메모리에 저장하도록 지시할 수 있다. 본 개시의 예시들은 이에 제한되지 않으며, 프로그램된 활성화 함수의 데이터는 제어기 내부의 레지스터, PAFE 유닛(500') 내부의 레지스터, 별도의 메모리, 및 별도의 레지스터 중 적어도 하나에 저장되도록 구성될 수 있다. 즉, 프로그램된 활성화 함수의 데이터의 저장장소는 특정 장소에 제한되지 않는다. <표6>을 참조하면, 프로그램된 활성화 함수 데이터의 일 예시가 개시된다. 예를 들면, 프로그램된 활성화 함수 데이터는 세그먼트 경계값(SB)을 포함하도록 구성될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트 별 세그먼트(S)의 범위를 포함하도록 구성될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트 별 2차항의 계수(A)와 1차항의 계수(B)를 포함하도록 구성될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트 별 오프셋(C)을 포함하도록 구성될 수 있다. 2차 함수로 프로그래밍 된 활성화 함수를 처리하도록 구성된 예시적인 PAFE 유닛은 복수의 비교기(Comparator 0 to Comparator (N-2))(511 내지 51(N-2)), 선택기(Selector, 520), 복수의 곱셈기(Multiplier)(531, 532, 533) 및 복수의 가산기(Adder)(541, 542)를 포함하도록 구성될 수 있다. 복수의 비교기(510 내지 51(N-2)) 각각은 적어도 하나의 프로세싱 엘리먼트에서 계산된 입력 값(X)을 복수 의 세그먼트 경계값(SB0 내지 SB(N-2)) 각각과 비교한다. 예를 들면, 입력 값(X)이 복수의 세그먼트 경계값(SB0 내지 SB(N-2)) 각각보다 클 경우, 복수의 비교기(510 내지 51(N-2)) 각각은 제1 레벨의 출력 값을 출력할 수 있 다. 이와 반대로, 입력 값(X)이 복수의 세그먼트 경계값(SB0 내지 SB(N-2)) 각각보다 작거나 같을 경우, 복수의 비교기(510 내지 51(N-2)) 각각은 제2 레벨의 출력 값을 출력할 수 있다. 이에, 복수의 비교기(510 내지 51(N-2)) 각각에서 출력된 출력 값을 통해 복수의 세그먼트들의 구간 중 입력 값 (X)이 속하는 세그먼트의 구간이 결정될 수 있다. 한편, 복수의 비교기(510 내지 51(N-2)) 각각은 복수의 비교기 인에이블 신호(Comp En 1 내지 Comp En (N-2)) 각각에 의해서 동작여부가 결정될 수 있다. 그리고, 선택기는 구간 결정 데이터(SDD0 내지 SDD(N-2))에 따라, 복수의 프로그래머블 세그먼트들에 대한 계수들(A0 내지 A(N-1), (B0 내지 B(N-1)), (C0 내지 C(N-1)) 중 입력 값(X)이 속하는 세그먼트의 구간에 해당 하는 프로그래머블 세그먼트에 대한 계수(A, B, C)를 출력한다. 구체적으로, 제1 레지스터는 복수의 프로그래머블 세그먼트들 각각에 대한 2차항의 계수(A0 내지 A(N-1)), 1차항의 계수(B0 내지 B(N-1)) 및 오프셋(C0 내지 C(N-1))를 선택기에 제공한다. 그리고, 선택기는 복수의 비교기(510 내지 51(N-2)) 각각에서 출력된 구간 결정 데이터(SDD0 내지 SDD(N- 2))에 따라 복수의 세그먼트들의 구간 중 입력 값(X)이 속하는 세그먼트의 구간을 결정할 수 있다. 그리고, 선택기는 복수의 프로그래머블 세그먼트들에 대한 2차항의 계수(A0 내지 A(N-1)), 1차항의 계수 (B0 내지 B(N-1)), 및 오프셋(C0 내지 C(N-1)) 중 결정된 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 2차항의 계수(A), 1차항의 계수(B), 및 오프셋(C)를 출력할 수 있다. 이에, 선택기는 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 2차항의 계수(A), 1차항의 계수(B) 및 오프셋(C)을 출력할 수 있다. 한편, 선택기는 구간 결정 데이터(SDD)에 따라 제어되는 복수의 스위칭 소자로 구성되는 멀티플렉서 (multiplexer)일 수 있으나, 선택기의 구성은 다양하게 변경될 수 있다. PAFE 유닛(500')의 프로그램된 활성화 함수 연산부는 입력 값(X), 2차항의 계수(A), 1차항의 계수(B) 및 오프셋 (C)을 입력 받아 출력 값(Y)를 연산하도록 구성된 회로부를 의미할 수 있다. PAFE 유닛(500')의 프로그램된 활성화 함수 연산부는 2차 함수 또는 1차 함수를 처리하기 위해서 복수의 곱셈 기(531, 532, 533)와 복수의 가산기(541, 542)를 포함하도록 구성될 수 있다. PAFE 유닛(500')의 프로그램된 활성화 함수 연산부는 하드-와이어된 회로일 수 있다. 프로그램된 활성화 함수 연산부의 복수의 곱셈기는 제1 곱셈기, 제2 곱셈기 및 제3 곱셈기를 포 함할 수 있다. 제1 곱셈기는 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 2차항의 계 수(A)와 입력 값(X)을 곱한다. 구체적으로 제1 곱셈기는 적어도 하나의 프로세싱 엘리먼트에서 계산된 입력 값(X)에 선택기에 서 출력된 프로그래머블 세그먼트에 대한 2차항의 계수(A)를 곱한다. 이에, 제1 곱셈기는 프로그래머블 세그먼트에 대한 2차항의 계수(A)를 입력 값(X)에 곱하여 출력할 수 있 다. 즉, 제1 곱셈기의 출력은 로 표현될 수 있다. 그리고, 제2 곱셈기는 제1 곱셈기에서 출력된 출력 값과 입력 값(X)을 곱한다. 구체적으로 제2 곱셈기는 적어도 하나의 프로세싱 엘리먼트에서 계산된 입력 값(X)에 제2 곱셈기 에서 출력된 출력 값을 곱한다. 이에, 제2 곱셈기의 출력은 로 표현될 수 있다. 단, 상술한 구성은 를 구현하기 위한 일 예 시일 뿐이며, 다양한 회로 조합을 통해서 변형 실시되는 것도 가능하다. 제3 곱셈기는 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 1차항의 계 수(B)와 입력 값(X)을 곱한다. 구체적으로 제3 곱셈기는 적어도 하나의 프로세싱 엘리먼트에서 계산된 입력 값(X)에 선택기에 서 출력된 프로그래머블 세그먼트에 대한 1차항의 계수(B)를 곱한다. 이에, 제3 곱셈기는 프로그래머블 세그먼트에 대한 1차항의 계수(B)를 입력 값(X)에 곱하여 출력할 수 있 다. 즉, 제3 곱셈기의 출력은 로 표현될 수 있다. 복수의 가산기는 제1 가산기 및 제2 가산기를 포함할 수 있다. 제1 가산기는 제2 곱셈기의 출력 값에 제3 곱셈기의 출력 값을 더한다. 구체적으로, 제1 가산기는 2차항으로 구성된 복수의 프로그래머블 세그먼트 각각의 2차항과 1차항의 합을 출력할 수 있다. 즉, 제1 가산기의 출력은 로 표현될 수 있다. 그리고, 제2 가산기는 제1 가산기의 출력 값에 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프 로그래머블 세그먼트에 대한 오프셋(C)을 더한다. 구체적으로, 가산기는 2차항으로 구성된 프로그래머블 세그먼트의 2차항과 1차항의 합에 프로그래머블 세 그먼트에 대한 오프셋(C)을 더한다. 즉, 제2 가산기의 출력은 로 표현될 수 있다. 이에, 가산기는 입력 값(X)인 연산 값에 2차 함수로 프로그램된 활성화 함수가 적용된 활성화 값을 출력할 수 있다. 상술한 구성에 따르면 PAFE 유닛(500')은 2차 다항식을 처리 가능하게끔 동작한다. 한편, 제2 곱셈기, 제3 곱셈기 및 제2 가산기는 제1 인에이블 신호(EN1)에 의해서 동작이 제어 될 수 있다. 구체적으로 제1 인에이블 신호(EN1)에 의해서 제2 곱셈기, 제3 곱셈기 및 제2 가산기가 동작하 기 않을 경우, 동작은 아래의 설명과 같다. 제1 곱셈기는 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 2차항의 계 수(A)와 입력 값(X)을 곱한다. 구체적으로 제1 곱셈기는 적어도 하나의 프로세싱 엘리먼트에서 계산된 입력 값(X)에 선택기에 서 출력된 프로그래머블 세그먼트에 대한 2차항의 계수(A)를 곱한다. 이에, 제1 곱셈기는 프로그래머블 세그먼트에 대한 2차항의 계수(A)를 입력 값(X)에 곱하여 출력할 수 있 다. 즉, 제1 곱셈기의 출력은 로 표현될 수 있다. 그리고, 제2 곱셈기 및 제3 곱셈기는 동작하지 않아, 제1 가산기에 제1 곱셈기의 출력이 그대로 입력된다. 즉, 제1 인에이블 신호(EN1)에 의해서 비활성화된 연산기는 우회(bypass) 될 수 있다. 그리고, 제1 가산기는 제1 곱셈기의 출력 값에 입력 값(X)이 속하는 세그먼트의 구간에 해당하는 프 로그래머블 세그먼트에 대한 1차항의 계수(B)를 더한다. 구체적으로, 제1 가산기는 프로그래머블 세그먼트에 대한 2차항의 계수(A)를 입력 값(X)에 곱한값에 프로 그래머블 세그먼트에 대한 1차항의 계수(B)를 더한다. 즉, 제1 가산기의 출력은 로 표현될 수 있다. 그리고, 제2 가산기는 동작하지 않아, 제1 가산기의 출력이 그대로 출력된다. 즉, 제1 인에이블 신호 (EN1)에 의해서 비활성화된 연산기는 우회(bypass) 될 수 있다. 즉, 제1 가산기는 입력 값(X)인 연산 값에 1차 함수로 프로그램된 활성화 함수가 적용된 활성화 값을 출력 할 수 있다. 상술한 구성에 따르면 PAFE 유닛(500')은 1차 다항식을 처리 가능하게끔 동작한다. 전술한 바와 같이, 복수의 곱셈기 및 복수의 가산기의 일부 구성은 제1 인에이블 신호(EN1)에 의해서 제어될 수 있다. 이에, 제1 인에이블 신호(EN1)에 따라, PAFE 유닛은 프로그래머블 세그먼트 각각이 2차 다항식일 경우 뿐 만 아니라, 프로그래머블 세그먼트 각각은 1차 다항식 경우에도 모두 구동될 수 있다. 부연 설명하면, 본 개시의 일 예시에 따른 적어도 하나의 프로세싱 엘리먼트와 파이프라인 된 PAFE 유닛 (500')은 2차 함수 및 1차 함수로 프로그램된 활성화 함수를 모두 구현하도록 구성된 하드-와이어된 회로로 구 성되는 것도 가능하다. 따라서, 하나의 PAFE 유닛으로 다양한 경우의 PAF를 처리할 수 있는 이점이 있다. 도 24는 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치가 Sigmoid 활성화 함수 를 프로그래머블 활성화 함수로 근사화 하는 예시를 설명하는 그래프이다 전술한 바와 같이, 본 개시의 또 다른 예시에 따른 활성화 함수 프로그래밍 방법을 수행하기 위한 장치의 PAFE 유닛에서 적용되는 PAF의 복수의 프로그래머블 세그먼트 각각은 2차 다항식이다. 부연 설명하면, Sigmoid 함수 의 적어도 일부 영역, 예를 들면 -6.0 내지 2.0 영역만 3개의 세그먼트로 구분하여 근사화 할 수 있다. *예를 들면, Sigmoid 활성화 함수를 PAF로 근사화 할 경우, 아래와 같이 근사화 할 수 있다. 입력 값(X)이 -6.0 크거나 -2.6 보다 작거나 같은 구간(S0)에서, 프로그래머블 세그먼트는 으로 근사화 할 수 있다. 그리고, 입력 값(X)이 -2.6 크거나 -0.6 보다 작거나 같은 구 간(S1)에서, 프로그래머블 세그먼트는 으로 근사화 할 수 있다. 그리고, 입력 값(X)이 -0.6 크거나 2 보다 작거나 같은 구간(S2)에서, 프로그래머블 세그먼트는 으로 근사화 할 수 있다. 따라서, 상기 프로그래머블 파라미터들을 <표 6>의 형식에 맞게 대응시킬 수 있다. 예를 들면, <표6>의 A0은 0.07일 수 있다. <표6>의 B0은 0.08일 수 있다. <표6>의 C0은 0.23일 수 있다. 예를 들면, <표6>의 A1은 0.05일 수 있다. <표6>의 B1은 0.3일 수 있다. <표6>의 C1은 0.52일 수 있다. 예를 들면, <표6>의 A2은 -0.03일 수 있다. <표6>의 B2은 0.26일 수 있다. <표6>의 C2은 0.5일 수 있다. 예를 들면, <표6>의 SB0은 -2.6일 수 있다. 표6>의 SB1은 -0.6일 수 있다. SB0은 일 수 있다. 예를 들면, <표6>의 Min은 -6.0일 수 있다. <표6>의 Max는 2.0일 수 있다. 예를 들면, 상기 세그먼트의 세그먼트 경계값(SB), 2차항의 계수(A), 1차항의 계수(B) 및 오프셋(C)은 도 12의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 머신 러닝을 이용하여 각각의 세그먼트를 최적 프로그래머블 세그먼트로 근사화 하는 방식으로 도출되는 것도 가능하다. 도 24에서 계수들은 머신 러닝으로 도출된 일 예시에 불과할 뿐, 다양하게 변형될 수 있다. 예를 들면, 프로그 래머블 세그먼트 중 일부(S0 및 S2)는 선형 구간에 해당할 수 있고, 프로그래머블 세그먼트 중 다른 일부(S1)는 비선형 구간에 해당할 수 있다. 이에, 프로그래머블 세그먼트 중 일부(S0 및 S2)는 1차함수로 근사화 될 수 있고, 프로그래머블 세그먼트 중 다 른 일부(S1)는 2차 함수로 근사화 될 수 있다. 몇몇의 예시에서는 PAFE 유닛의 출력단에 로그 연산기를 더 포함할 수 있다. 도 25를 참조하여, 로그 연산기를 포함한 PAFE 유닛에 대해서 구체적으로 설명한다. 도 25는 본 개시의 또 다른 예시에 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU의 PAFE 유닛을 설명하 는 개념도이다. 도 25를 참조하면, PAFE 유닛(500'')은 복수의 비교기(Comparator 0 to Comparator (N-2))(511 내지 51(N-2)), 선택기(Selector, 520), 복수의 곱셈기(Multiplier)(531, 532, 533) 및 복수의 가산기(Adder)(541, 542)를 포 함할 뿐만 아니라, 로그 연산기를 포함할 수 있다. 도 23에서 도시된 PAFE 유닛과 도 25의 PAFE 유닛은 로그 연산기 동작여부에 대해서만 차이점이 존재하므 로, 이에 대해서 구체적으로 설명한다. 로그 연산기는 제2 인에이블 신호(EN2)에 의해서 동작이 제어될 수 있다. 로그 연산기에 제2 인에이 블 신호(EN2)가 인가되면 로그 계수(D)가 로그 연산기에 입력될 수 있다. 로그 연산기가 활성화되면 2차항의 계수(A), 1차항의 계수(B) 및 오프셋(C)와 관련된 연산기들(531, 532, 533, 541, 542)는 비활성화 되 도록 구성될 수 있다. 즉, 로그 연산기의 출력은 로 표현될 수 있다. 즉, 로그 연산기는 입력 값(X)인 연산 값에 로그 연산을 포함하는 PAF가 적용된 활성화 값을 출력할 수 있 다. 도 25에 도시된 PAFE 유닛에서 적용되는 PAF의 복수의 프로그래머블 세그먼트 각각은 1차 함수, 2차 함수, 또는 로그 함수로 동작할 수 있다. 이에, 상술한 프로그래머블 세그먼트에 대한 계수(A, B, C, D)는 2차항의 계수 (A), 1차항의 계수(B), 오프셋(C), 및 로그(D)를 포함할 수 있다. <표7>"}
{"patent_id": "10-2024-0039240", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "<표7>을 참조하면, 프로그램된 활성화 함수의 구동을 위한 데이터는 활성화 함수 변환 프로그램 유닛에서 생성되어 NPU의 메모리, 예를 들면, 세그먼트 레지스터, 제1 레지스터, 제2 레지스터, 제3레지스터, 및 제4 레지스터에 저장되도록 구성될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 세그먼트 경계값(SB)을 포함하도록 구성될 수 있다. 세그먼트 경 계값(SB)은 메모리의 제1 레지스터에 저장될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트 별 세그먼트(S)의 범위를 포함하도록 구성될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트 별 2차항의 계수(A)를 포함하도록 구성될 수 있다. 2 차항의 계수(A)는 메모리의 제2 레지스터에 저장될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트 별 1차항의 계수(B)를 포함하도록 구성될 수 있다. 1 차항의 계수(B)는 메모리의 제3 레지스터에 저장될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트 별 오프셋(C)을 포함하도록 구성될 수 있다. 오프셋 (C)은 메모리의 제4 레지스터에 저장될 수 있다. 예를 들면, 프로그램된 활성화 함수 데이터는 각 세그먼트 별 로그 계수(D)를 포함하도록 구성될 수 있다. 로그 계수(D)는 메모리의 제5 레지스터에 저장될 수 있다. 상술한 바와 같이, PAFE 유닛에 로그 연산기를 추가하여, 로그 연산을 포함하는 PAF를 적용하는 것을 설명 하였다. 다만, PAFE 유닛의 출력단에 더해지는 연산기는 로그 연산기 뿐만 아니라 다양한 형태의 연산기가 추가될 수 있다. 부연 설명하면, 프로그램된 활성화 함수 데이터는 PAFE 유닛의 프로그램된 활성화 함수 연산부의 연산자 회로 구성과 지원 가능한 수식들에 따라 결정될 수 있다. 본 개시의 일 실시예에 따른 신경 프로세싱 유닛은 인공신경망 연산을 통해 연산 값을 출력하도록 구성된 적어 도 하나의 프로세싱 엘리먼트, 복수의 프로그래머블 세그먼트들을 포함하는 적어도 하나의 프로그램된 활성화 함수를 상기 연산 값에 적용하여 활성화 값을 생성하도록 구성된 프로그램된 활성화 함수 실행 유닛 및 적어도 하나의 프로세싱 엘리먼트 및 상기 프로그램된 활성화 함수 실행 유닛의 동작을 제어하도록 구성된 제어기를 포 함할 수 있다. 본 개시의 다른 특징에 따르면, 신경 프로세싱 유닛은 복수의 프로그래머블 세그먼트들의 구간에 대한 정보를 저장하는 세그먼트 레지스터를 더 포함할 수 있다. 본 개시의 또 다른 특징에 따르면, 신경 프로세싱 유닛은 복수의 프로그래머블 세그먼트들의 세그먼트 경계값을 저장하는 세그먼트 레지스터를 더 포함할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 프로그램된 활성화 함수 실행 유닛은 복수의 비교기, 선택기, 적어도 하나의 곱셈기 및 적어도 하나의 가산기가 하드-와이어 될 수 있다. 본 개시의 또 다른 특징에 따르면, 신경 프로세싱 유닛은 상기 연산 값을 입력된 복수의 세그먼트 경계값 각각 과 비교하여 구간 결정 데이터를 출력하도록 구성된 복수의 비교기를 더 포함할 수 있다. 본 개시의 또 다른 특징에 따르면, 신경 프로세싱 유닛은 비교기 인에이블 신호에 의해서 동작여부가 결정되도 록 구성된 복수의 비교기를 더 포함할 수 있다. 본 개시의 또 다른 특징에 따르면, 신경 프로세싱 유닛은 구간 결정 데이터를 출력하도록 구성된 복수의 비교기 를 더 포함하고, 프로그램된 활성화 함수 실행 유닛은 상기 구간 결정 데이터에 따라, 상기 복수의 프로그래머 블 세그먼트들 중 대응되는 세그먼트의 기울기 및 오프셋을 상기 연산 값에 적용하여 상기 활성화 값을 생성하 도록 될 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 적어도 하나의 곱셈기는 선택기에서 출력된 프로그래머블 세그먼트에 대한 기울기와 입력 값을 곱할 수 있다. 본 개시의 또 다른 특징에 따르면, 적어도 하나의 가산기는, 적어도 하나의 곱셈기에서 출력된 프로그래머블 세 그먼트에 대한 기울기를 입력 값에 곱한값에 프로그래머블 세그먼트에 대한 오프셋을 더할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 선택기는 복수의 구간 결정 데이터에 따라, 복수의 프로그래머블 세그 먼트들에 대한 기울기 중 입력 값이 속하는 세그먼트의 구간에 해당하는 프로그래머블 세그먼트에 대한 2 차항기울기와 1 차항 기울기 및 오프셋을 출력할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 적어도 하나의 곱셈기는, 입력 값에 상기 선택기에서 출력된 프로그래 머블 세그먼트에 대한 2차항의 계수를 곱하는 제1 곱셈기; 제1 곱셈기에서 출력된 출력 값과 입력 값을 곱하는 제2 곱셈기 및 입력 값에 상기 선택기에서 출력된 프로그래머블 세그먼트에 대한 1차항의 계수를 곱하는 제3 곱 셈기를 포함할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 제2 곱셈기 및 상기 제3 곱셈기는 제1 인에이블 신호에 의해서 동작이 제어될 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 적어도 하나의 가산기는, 제2 곱셈기의 출력 값에 상기 제3 곱셈기의 출력 값을 더하는 제1 가산기, 제1 가산기의 출력 값에 상기 선택기에서 출력된 프로그래머블 세그먼트에 대한 오프셋을 더하는 제2 가산기를 포함할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 제2 가산기는 제1 인에이블 신호에 의해서 동작이 제어될 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 프로그램된 활성화 함수 실행 유닛은 상기 적어도 하나의 가산기의 출 력 값을 로그 연산하는 로그 연산기를 더 포함할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 로그 연산기는 제2 인에이블 신호에 의해서 동작이 제어될 수 있다. 본 개시의 또 다른 특징에 따르면, 신경 프로세싱 유닛은 프로그래머블 활성화 함수를 구성하는 복수의 프로그 래머블 세그먼트들에 대한 기울기 및 오프셋 정보를 저장하는 프로그래머블 활성화 함수 라이브러리를 더 포함 할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 적어도 하나의 프로세싱 엘리먼트들은 멀티플렉서를 통해 프로그램된 활성화 함수 실행 유닛에 연결될 수 있다. 본 개시의 또 다른 특징에 따르면, 장치는 활성화 함수를 상기 적어도 하나의 프로그램된 활성화 함수로 프로그 램하는 활성화 함수 변환 프로그램 유닛을 더 포함할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 활성화 함수 변환 프로그램 유닛은, 기울기 변화 데이터에 따라, 상기 적어도 하나의 프로그램된 활성화 함수의 선형 구간 및 비선형 구간을 우선적 으로 결정할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 활성화 함수 변환 프로그램 유닛은, 기울기 변화 데이터 중 2차 미분값이 임계값보다 낮은 구간을 상기 선형 구간으로 결정할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 활성화 함수 변환 프로그램 유닛은, 기울기 변화 데이터 중 2차 미분값이 임계값보다 높은 구간을 상기 비선형 구간으로 결정할 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 활성화 함수 변환 프로그램 유닛은 상기 2차 미분값의 적분 값에 기초 하여, 상기 비선형 구간을 복수개로 분리시킬 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 활성화 함수 변환 프로그램 유닛은, 상기 적어도 하나의 프로그램된 활 성화 함수의 선형 구간을 1차 함수로 근사된 프로그래머블 세그먼트로 변환시킬 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 활성화 함수 변환 프로그램 유닛은, 상기 적어도 하나의 프로그램된 활 성화 함수의 비선형 구간을 2차 함수로 근사된 프로그래머블 세그먼트로 변환시킬 수 있다. 본 개시의 또 다른 특징에 따르면, 상기 활성화 함수 변환 프로그램 유닛은, 적어도 하나의 프로그램된 활성화 함수의 비선형 구간을 로그 함수로 근사된 프로그래머블 세그먼트로 변환시킬 수 있다. 본 명세서와 도면에 게시된 본 개시의 예시들은 본 개시의 기술내용을 쉽게 설명하고 본 개시의 이해를 돕기 위 해 특정 예를 제시한 것뿐이며, 본 명의 범위를 한정하고자 하는 것은 아니다. 여기에 게시된 예시들 이외에도 발명의 기술적 사상에 바탕을 둔 다른 변형 예들이 실시 가능하다는 것은 본 개시가 속하는 기술 분야에서 통상 의 지식을 가진 자에게 자명한 것이다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12 도면13 도면14 도면15 도면16 도면17 도면18 도면19 도면20 도면21 도면22 도면23 도면24 도면25"}
{"patent_id": "10-2024-0039240", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 개시의 일 예시에 따른 활성화 함수의 프로그래밍 방법을 수행하기 위한 장치를 설명하는 개략적인 개념도이다. 도 2는 본 개시의 일 예시에 따른 활성화 함수의 프로그래밍 방법을 설명하는 개략적인 순서도이다. 도 3은 본 개시의 일 예시에 따른 활성화 함수의 프로그래밍 방법에 의해 활성화 함수가 프로그램 되는 과정을 설명하는 그래프이다.도 4은 본 개시의 일 예시에 따른 활성화 함수의 프로그래밍 방법에 의해 활성화 함수를 복수의 세그먼트들로 세그먼팅하는 다양한 경우를 설명하는 그래프이다. 도 5는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 세그먼트 데이터 중 기울기 변화 데이터를 이용하여 활성화 함수를 선형 구간과 비선형 구간을 구분해서 세그먼팅하는 일 예시를 설명하는 그래프이다. 도 6은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 세그먼트 데이터 중 기울기 변화 데이터를 이용하여 활성화 함수를 실질적 선형 구간과 비선형 구간을 구분해서 세그먼팅하는 일 예시를 설명하는 그래프 이다. 도 7은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 세그먼트 데이터 중 기울기 변화 데이터를 이용하여 활성화 함수를 실질적 선형 구간과 비선형 구간을 구분해서 세그먼팅하는 다른 예시를 설명하는 그래 프이다. 도 8은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 세그먼트 데이터 중 기울기 변화 데이터를 이용하여 활성화 함수를 실질적 선형 구간과 비선형 구간을 구분해서 세그먼팅하는 또 다른 예시를 설명하는 그 래프이다. 도 9는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 에러 값을 이용하여 하나의 세그먼트를 하 나의 프로그래머블 세그먼트로 변환하는 예시를 설명하는 그래프이다. 도 10은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 최대 에러 값을 이용하여 하나의 세그먼트 를 하나의 프로그래머블 세그먼트로 변환하는 예시를 설명하는 그래프이다. 도 11은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 에러 값에 대한 적분값을 이용하여 하나의 세그먼트를 하나의 프로그래머블 세그먼트로 변환하는 예시를 설명하는 그래프이다. 도 12는 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 머신 러닝(Machine Learning)을 이용하여 하나의 세그먼트를 하나의 최적 프로그래머블 세그먼트로 근사화 하는 예시를 설명하는 그래프이다. 도 13은 본 개시의 일 예시에 따른 활성화 함수 프로그래밍 방법에서 활성화 함수의 2차 미분값의 누적값 및 임 계값을 이용하여 활성화 함수를 세그먼팅하는 예시를 설명하는 그래프이다. 도 14, 15는 ELU 활성화 함수 및 Hardswish 활성화 함수를 도시하는 그래프이다. 도 16은 본 개시의 일 예시에 따른 프로그램된 활성화 함수를 처리하도록 구성된 PAFE 유닛을 설명하는 개념도 이다. 도 17은 본 개시의 일 예시에 따른 프로그램된 활성화 함수를 처리하도록 구성된 장치의 NPU의 PAFE 유닛을 설 명하는 개념도이다. 도 18은 본 개시의 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU를 설명하는 개념도이 다. 도 19는 본 개시의 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU의 PAFE 유닛을 설명 하는 개념도이다. 도 20은 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU를 설명하는 개념 도이다. 도 21은 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU를설명하는 개념도 이다. 도 22는 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하도록 구성된 PAFE 유닛을 설명하는 개 념도이다. 도 23은 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU의 PAFE 유닛을 설 명하는 개념도이다. 도 24는 본 개시의 또 다른 예시에 따른 프로그램된 활성화 함수를 처리하기 위한 장치가 Sigmoid 활성화 함수 를 프로그래머블 활성화 함수로 근사화 하는 예시를 설명하는 그래프이다도 25는 본 개시의 또 다른 예시에 프로그램된 활성화 함수를 처리하기 위한 장치의 NPU의 PAFE 유닛을 설명하 는 개념도이다."}
