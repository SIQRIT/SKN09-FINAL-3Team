{"patent_id": "10-2019-0077200", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0001305", "출원번호": "10-2019-0077200", "발명의 명칭": "위노그라드 알고리즘에 기반한 행렬 곱셈 방법 및 장치", "출원인": "에스케이텔레콤 주식회사", "발명자": "황석중"}}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산장치에 있어서,복수의 제2누적값 연산부를 구비하되, 하나의 제2누적값 연산부는 제2행렬 원소값쌍을 서로 곱한 제2곱셈값을누적하고, 인접한 제2누적값 연산부의 출력값과 누적된 제2곱셈값 중 하나를 선택하여 제2누적값을 출력하는 제2누적값 출력부;복수의 제3누적값 연산부를 구비하되, 하나의 제3누적값 연산부는 제1행렬 원소값쌍 중 하나의 원소값과 상기제2행렬 원소값쌍 중 하나의 원소값을 더한 제1값을 생성하고 상기 제1행렬 원소값쌍 중 다른 하나의 원소값과상기 제2행렬 원소값쌍 중 다른 하나의 원소값을 더한 제2값을 생성하고 상기 제1값 및 상기 제2값을 곱한 값인제3곱셈값을 누적하고 인접한 제3누적값 연산부의 출력값과 상기 누적된 제3곱셈값 중 하나를 선택하여 제3누적값을 생성하는 제3누적값 출력부; 및하나 이상의 행 원소값 산출부를 구비하되, 하나의 행 원소값 산출부는 상기 제1행렬 원소값쌍을 서로 곱한 제1행렬원소 곱셈값을 누적하고, 상기 제3누적값에서 상기 누적된 제1행렬원소 곱셈값 및 상기 제2누적값을 각각감산하여 상기 제3행렬의 원소값을 산출하는 원소값 산출부를 포함하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 하나의 제3누적값 연산부의 위치는, 상기 하나의 제2누적값 연산부의 위치 및 상기 하나의 행 원소값 산출부의 위치에 대응하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 복수의 제3누적값 연산부는 2차원의 시스톨릭 배열 구조로 형성되고, 상기 복수의 제2누적값 연산부 및 상기 하나 이상의 행 원소값 산출부는 각각 1차원의 시스톨릭 배열 구조로 형성되는 것을 특징으로 하는연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 복수의 제2누적값 연산부는 상기 복수의 제3누적값 연산부의 상측 위치에 형성되고, 상기 하나 이상의 행원소값 산출부는 상기 복수의 제3누적값 연산부의 측면에 형성되는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,상기 제2누적값 선택출력부에서 출력된 제2누적값을 저장하는 제2누적값 저장부를 더 포함하는 것을 특징으로하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 제2누적값 저장부는 상기 제2누적값 선택출력부와 상기 하나 이상의 행 원소값 산출부 사이에 위치하는 것을 특징으로 하는 연산장치.공개특허 10-2021-0001305-2-청구항 7 제5항에 있어서,상기 하나의 행 원소값 산출부는, 상기 제2누적값 저장부에 저장된 상기 제2누적값을 이용하여 상기 제3행렬의원소값을 산출하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 하나의 행 원소값 산출부는, 상기 제3행렬의 행 중에서 상기 하나 이상의 행 원소값 산출부의 위치에 해당하는 행의 원소값을 순차적으로 생성하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 하나의 행 원소값 산출부는, 상기 제3행렬의 원소값의 산출에 필요한 상기 제3누적값을 인접하는 제3누적값 연산부로부터 전달받는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제2항에 있어서,상기 제3누적값 연산부는, 입력분할부, 제1가산부, 제2가산부, 곱셈부 및 누적부를 포함하며,상기 입력분할부는 상기 제1행렬의 하나의 원소값, 상기 제2행렬의 하나의 원소값, 상기 제1행렬의 다른 하나의원소값 및 상기 제2행렬의 다른 하나의 원소값을 나타내는 각각의 비트맵을 상기 제1가산부의 입력단 비트 길이인 N 비트 단위로 상위 분할비트맵 및 하위 분할비트맵으로 분할하고,상기 제1가산부는 상기 제1행렬의 하나의 원소값, 상기 제2행렬의 하나의 원소값에 대해 각각 선택된 동일 위치분할 비트맵별로 서로 가산하고,상기 제2가산부는 상기 제1행렬의 다른 하나의 원소값 및 상기 제2행렬의 다른 하나의 원소값에 대해 각각 선택된 동일 위치 분할 비트맵별로 선택하여 서로 가산하고,상기 곱셈부는 상기 제1가산부의 가산결과와 상기 제2가산부의 가산결과를 곱하여 상기 제3곱셈값을 산출하고,상기 누적부는 상기 곱셈부에서 산출되는 제3곱셈값을 누적하여 상기 제3누적값을 생성하는 것을 특징으로 하는연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제2항에 있어서,상기 제3누적값 연산부는, 4개의 전처리부, 제1가산부, 제2가산부, 곱셈부, 제3가산부 및 누적부를 포함하며,각 전처리부는 N 비트(단, N은 자연수) 길이의 행렬 원소값쌍을 수신하고 상기 행렬 원소값쌍 중 하나의 원소값은 기설정 길이의 비트맵 상의 상위 비트맵에 위치시키고 상기 행렬 원소값쌍 중 다른 하나의 원소값은 상기 기설정 길이의 비트맵 상의 하위 비트맵에 위치시키되, 상기 다른 하나의 원소값의 부호 비트를 상기 기설정 길이의 비트맵 상의 (N+1)번째 비트에 복사하여 상기 하위 비트맵에 위치하는 원소값의 부호를 확장하여 2N+1 길이의 비트맵 데이터를 생성하고,제1가산부는 상기 4개의 전처리부 중 2개의 전처리부에서 생성된 기설정 길이의 비트맵 상의 데이터를 서로 합산하여 제1결과값을 생성하고,제2가산부는 상기 4개의 전처리부 중 다른 2개의 전처리부에서 생성된 기설정 길이의 비트맵 상의 데이터를 서로 합산하여 제2결과값을 생성하고,곱셈부는 상기 제1결과값의 상위 비트맵에 해당하는 값과 상기 제2결과값의 상위 비트맵에 해당하는 값을 서로곱하여 제11곱셈값을 생성하고, 상기 제1결과값의 하위 비트맵에 해당하는 값과 상기 제2결과값의 하위 비트맵공개특허 10-2021-0001305-3-에 해당하는 값을 서로 곱하여 제12곱셈값을 생성하고,상기 제3가산부는 상기 제11곱셈값과 상기 제12곱셈값을 서로 더하여 상기 제3곱셈값을 생성하고,상기 누적부는 상기 제3곱셈값을 누적하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1항에 있어서,상기 하나 이상의 행 원소값 산출부는,상기 제1행렬 원소값쌍을 각각 상위 비트그룹과 하위 비트그룹으로 분할하고 하나의 제1행렬 원소값쌍의 비트그룹과 다른 하나의 제1행렬 원소값쌍의 비트그룹의 조합을 순차적으로 선택하여 서로 곱하여 조합곱셈값을 생성하고, 선택된 조합에 대응하는 승수를 순차적으로 조합곱셈값에 곱하여 상기 제1행렬원소 곱셈값을 생성하는 곱셈부를 포함하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1항에 있어서,상기 하나 이상의 행 원소값 산출부는,상위 비트그룹에 상기 제1행렬의 제1원소를, 상기 제1비트맵의 하위 비트그룹에 상기 제1행렬의 제2원소의 부호및 상기 제2원소를 각각 복사하여 제1비트맵을 형성하는 제1전처리부;상위 비트그룹에 상기 제1행렬의 제3원소를, 상기 제2비트맵의 하위 비트그룹에 상기 제1행렬의 제4원소의 부호및 상기 제4원소를 각각 복사하여 제1비트맵을 형성하는 제2전처리부;상기 제1비트맵의 상위 비트그룹과 상기 제2비트맵의 상위 비트그룹을 서로 곱하여 제1곱셈결과를 생성하고, 상기 제1비트맵의 하위 비트그룹과 상기 제2비트맵의 하위 비트그룹을 서로 곱하여 제2곱셈결과를 생성하는 곱셈부; 및상기 제1곱셈결과와 상기 제1곱셈결과를 서로 더하여 상기 제1행렬원소 곱셈값을 생성하는 가산부를 포함하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "입력분할부, 제1가산부, 제2가산부, 곱셈부 및 누적부를 구비하고, 위노그라드 알고리즘에 기반하여 제1행렬과제2행렬을 곱하여 제3행렬을 생성하는 연산장치에 있어서,상기 입력분할부는 상기 제1행렬의 하나의 원소값, 상기 제2행렬의 하나의 원소값, 상기 제1행렬의 다른 하나의원소값 및 상기 제2행렬의 다른 하나의 원소값을 나타내는 각각의 비트맵을 상기 제1가산부의 입력단 비트 길이인 N 비트 단위로 상위 분할비트맵 및 하위 분할비트맵으로 분할하고,상기 제1가산부는 상기 제1행렬의 하나의 원소값, 상기 제2행렬의 하나의 원소값에 대해 각각 선택된 동일 위치분할 비트맵별로 서로 가산하고,상기 제2가산부는 상기 제1행렬의 다른 하나의 원소값 및 상기 제2행렬의 다른 하나의 원소값에 대해 각각 선택된 동일 위치 분할 비트맵별로 선택하여 서로 가산하고,상기 곱셈부는 상기 제1가산부의 가산결과와 상기 제2가산부의 가산결과를 곱하여 곱셈값을 산출하고,상기 누적부는 상기 곱셈부에서 산출되는 곱셈값을 누적하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서상기 곱셈부는 상기 제1가산부의 가산결과와 상기 제2가산부의 가산결과를 곱하여 곱셈결과를 산출하고, 상기곱셈결과에 상기 제1가산부의 가산결과와 상기 제1가산부의 가산결과에 대응하는 승수를 곱하여 상기 곱셈값을산출하는 것을 특징으로 하는 연산장치.공개특허 10-2021-0001305-4-청구항 16 제14항에 있어서상기 제1가산부 및 상기 제2가산부 중 적어도 하나는, N 비트 양수 덧셈기 및 (N+1) 비트 정수 덧셈기 중 어느하나로서 선택적으로 동작하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서상기 제1가산부 및 상기 제2가산부 중 적어도 하나는, 상기 하위 분할비트맵별로 가산하는 경우는 N 비트 양수덧셈기로서 동작하고 상기 상위 분할비트맵별로 가산하는 경우는 (N+1) 비트 정수 덧셈기 중 어느 하나로서 선택적으로 동작하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "4개의 전처리부, 제1가산부, 제2가산부, 곱셈부, 제3가산부 및 누적부를 구비하고, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산장치에 있어서,각 전처리부는 N 비트(단, N은 자연수) 길이의 행렬 원소값쌍을 수신하고 상기 행렬 원소값쌍 중 하나의 원소값은 기설정 길이의 비트맵 상의 상위 비트맵에 위치시키고 상기 행렬 원소값쌍 중 다른 하나의 원소값은 상기 기설정 길이의 비트맵 상의 하위 비트맵에 위치시키되, 상기 다른 하나의 원소값의 부호 비트를 상기 기설정 길이의 비트맵 상의 (N+1)번째 비트에 복사하여 상기 하위 비트맵에 위치하는 원소값의 부호를 확장하여 2N+1 길이의 비트맵 데이터를 생성하고,상기 제1가산부는 상기 4개의 전처리부 중 2개의 전처리부에서 생성된 기설정 길이의 비트맵 상의 데이터를 서로 합산하여 제1결과값을 생성하고,상기 제2가산부는 상기 4개의 전처리부 중 다른 2개의 전처리부에서 생성된 기설정 길이의 비트맵 상의 데이터를 서로 합산하여 제2결과값을 생성하고,상기 곱셈부는 상기 제1결과값의 상위 비트맵에 해당하는 값과 상기 제2결과값의 상위 비트맵에 해당하는 값을서로 곱하여 제11곱셈값을 생성하고, 상기 제1결과값의 하위 비트맵에 해당하는 값과 상기 제2결과값의 하위 비트맵에 해당하는 값을 서로 곱하여 제12곱셈값을 생성하고,상기 제3가산부는 상기 제11곱셈값과 상기 제12곱셈값을 서로 더하여 곱셈결과값을 생성하고,상기 누적부는 상기 곱셈결과값을 누적하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서,상기 각 전처리부는, 복수의 2N 비트 길이의 행렬 원소값을 수신하여 저장하고 상기 복수의 2N 비트 길이의 행렬 원소값의 부호 비트를 (2N+1)번째 비트에 복사하여 상기 2N 비트 길이의 행렬 원소값의 부호가 확장된 복수의 피가산 데이터를 생성하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제19항에 있어서,상기 제3누적값 연산부는, 상기 2N+1 길이의 비트맵 데이터와 상기 피가산 데이터 중에서 하나를 선택하여 상기제1가산부 또는 상기 제2가산부로 입력시키는 입력선택부를 더 포함하는 것을 특징으로 하는 연산장치."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "복수의 제2누적값 연산부, 복수의 제3누적값 연산부 및 하나 이상의 행 원소값 산출부를 구비하는연산장치에서, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산방법에 있어서,하나의 제2누적값 연산부에서 제2행렬 원소값쌍을 서로 곱한 제2곱셈값을 누적하고, 인접한 제2누적값 연산부의공개특허 10-2021-0001305-5-출력값과 누적된 제2곱셈값 중 하나를 선택하여 제2누적값을 출력하는 과정;상기 하나의 제2누적값 연산부의 위치에 대응하는 하나의 제3누적값 연산부에서 제1행렬 원소값쌍 중 하나의 원소값과 상기 제2행렬 원소값쌍 중 하나의 원소값을 더한 제1값을 생성하고 상기 제1행렬 원소값쌍 중 다른 하나의 원소값과 상기 제2행렬 원소값쌍 중 다른 하나의 원소값을 더한 제2값을 생성하는 과정;상기 하나의 제3누적값 연산부에서 상기 제1값 및 상기 제2값을 곱한 값인 제3곱셈값을 누적하고 인접한 제3누적값 연산부의 출력값과 상기 누적된 제3곱셈값 중 하나를 선택하여 제3누적값을 생성하는 과정; 및상기 하나의 제3누적값 연산부의 위치에 대응하는 하나의 행 원소값 산출부에서 상기 제1행렬 원소값쌍을 서로곱한 제1행렬원소 곱셈값을 누적하고, 상기 제3누적값에서 상기 누적된 제1행렬원소 곱셈값 및 상기 제2누적값을 각각 감산하여 상기 제3행렬의 원소값을 산출하는 과정을 포함하는 연산방법."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "입력분할부, 제1가산부, 제2가산부, 곱셈부 및 누적부를 구비하는 연산장치에서, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산방법에 있어서,상기 입력분할부에서 상기 제1행렬의 하나의 원소값, 상기 제2행렬의 하나의 원소값, 상기 제1행렬의 다른 하나의 원소값 및 상기 제2행렬의 다른 하나의 원소값을 나타내는 각각의 비트맵을 상기 제1가산부의 입력단 비트길이인 N 비트 단위로 상위 분할비트맵 및 하위 분할비트맵으로 분할하는 과정;상기 제1가산부에서 상기 제1행렬의 하나의 원소값 및 상기 제2행렬의 하나의 원소값에 대해 각각 선택된 동일위치 분할 비트맵별로 서로 가산하는 과정;상기 제2가산부에서 상기 제1행렬의 다른 하나의 원소값 및 상기 제2행렬의 다른 하나의 원소값에 대해 각각 선택된 동일 위치 분할 비트맵별로 선택하여 서로 가산하는 과정;상기 곱셈부에서 상기 제1가산부의 가산결과와 상기 제2가산부의 가산결과를 곱하여 곱셈값을 산출하는 과정;및상기 누적부에서 상기 곱셈부에서 산출되는 곱셈값을 누적하는 과정을 포함하는 연산방법."}
{"patent_id": "10-2019-0077200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "4개의 전처리부, 제1가산부, 제2가산부, 곱셈부, 제3가산부 및 누적부를 구비하는 연산장치에서, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산방법에 있어서,각 전처리부에서, N 비트(단, N은 자연수) 길이의 행렬 원소값쌍을 수신하고 상기 행렬 원소값쌍 중 하나의 원소값은 기설정 길이의 비트맵 상의 상위 비트맵에 위치시키고 상기 행렬 원소값쌍 중 다른 하나의 원소값은 상기 기설정 길이의 비트맵 상의 하위 비트맵에 위치시키되, 상기 다른 하나의 원소값의 부호 비트를 상기 기설정길이의 비트맵 상의 (N+1)번째 비트에 복사하여 상기 하위 비트맵에 위치하는 원소값의 부호를 확장하여 2N+1길이의 비트맵 데이터를 생성하는 과정;상기 제1가산부에서 상기 4개의 전처리부 중 2개의 전처리부에서 생성된 기설정 길이의 비트맵 상의 데이터를서로 합산하여 제1결과값을 생성하는 과정;상기 제2가산부에서, 상기 4개의 전처리부 중 다른 2개의 전처리부에서 생성된 기설정 길이의 비트맵 상의 데이터를 서로 합산하여 제2결과값을 생성하는 과정;상기 곱셈부에서 상기 제1결과값의 상위 비트맵에 해당하는 값과 상기 제2결과값의 상위 비트맵에 해당하는 값을 서로 곱하여 제11곱셈값을 생성하고, 상기 제1결과값의 하위 비트맵에 해당하는 값과 상기 제2결과값의 하위비트맵에 해당하는 값을 서로 곱하여 제12곱셈값을 생성하는 과정;상기 제3가산부에서, 상기 제11곱셈값과 상기 제12곱셈값을 서로 더하여 곱셈결과값을 생성하는 과정; 및상기 누적부에서 상기 곱셈결과값을 누적하는 과정공개특허 10-2021-0001305-6-을 포함하는 연산방법."}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 실시예는, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산장치에 있어 서, 복수의 제2누적값 연산부를 구비하되, 하나의 제2누적값 연산부는 제2행렬 원소값쌍을 서로 곱한 제2곱셈값 을 누적하고, 인접한 제2누적값 연산부의 출력값과 누적된 제2곱셈값 중 하나를 선택하여 제2누적값을 출력하는 제2누적값 출력부; 및 하나 이상의 행 원소값 산출부를 구비하되, 하나의 행 원소값 산출부는 제1행렬 원소값쌍 을 서로 곱한 제1행렬원소 곱셈값을 누적하고, 상기 누적된 제1행렬원소 곱셈값 및 상기 제2누적값을 이용하여 상기 제3행렬의 원소값을 산출하는 원소값 산출부를 포함하는 연산장치를 제공한다. 또한 복수의 정밀도를 제공 함에 있어 저정밀 연산에서의 성능 증대 혹은 고정밀 연산을 지원함에 있어 하드웨어 면적을 절약할 수 있는 연 산장치 설계 방법을 제공한다."}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 실시예는 위노그라드 알고리즘에 기반한 행렬 곱셈 방법 및 장치에 관한 것이다."}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "이하에 기술되는 내용은 단순히 본 실시예와 관련되는 배경 정보만을 제공할 뿐 종래기술을 구성하는 것이 아니 다. 행렬 곱셈은 인공지능, 신호처리, 그래픽스 등 많은 분야에 널리 사용되는 핵심 연산이다. 많은 ASIC(Application Specific Integrated Circuit) 제품들에서 행렬 곱셈을 효율적으로 처리하기 위해 행렬 곱셈 에 특화된 하드웨어 연산기가 사용되고 있다. 예컨대, NVIDIA의 최신 GPU(Graphics Processing Unit)의 경우 행렬 곱셈을 처리하는 텐서 코어(tensor core)를 내장하고 있다. 행렬 곱셈을 위한 연산기에서 행렬 곱셈 수행시 필요한 연산 비용을 줄이는 다양한 알고리즘들이 존재한다. 그 중에서 위노그라드(Winograd) 알고리즘에 기반한 행렬 곱셈 알고리즘은 일반적인 행렬 곱셈에 비해 곱셈 연산의 수를 절반 정도 절감시킨다. 현재 위노그라드 알고리즘의 장점을 활용한 기본적인 하드웨어 설계들은 존재하지만, 하드웨어 설계면적의 최소 화, 고속 연산 및 복수 정밀도 지원 등 다양한 측면에서 개선된 설계가 필요하다."}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 실시예는 위노그라드 알고리즘에 기반한 행렬 곱셈기에서 하드웨어 면적 축소, 연산 속도 개선 및 복수의 연 산 정밀도 제공을 목적으로 한다."}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 실시예에 의하면, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산장치에 있어서, 복수의 제2누적값 연산부를 구비하되, 하나의 제2누적값 연산부는 제2행렬 원소값쌍을 서로 곱한 제2곱셈값을 누적하고, 인접한 제2누적값 연산부의 출력값과 누적된 제2곱셈값 중 하나를 선택하여 제2누 적값을 출력하는 제2누적값 출력부; 복수의 제3누적값 연산부를 구비하되, 하나의 제3누적값 연산부는 제1행렬 원소값쌍 중 하나의 원소값과 상기 제2행렬 원소값쌍 중 하나의 원소값을 더한 제1값을 생성하고 상기 제1행렬 원소값쌍 중 다른 하나의 원소값과 상기 제2행렬 원소값쌍 중 다른 하나의 원소값을 더한 제2값을 생성하고 상 기 제1값 및 상기 제2값을 곱한 값인 제3곱셈값을 누적하고 인접한 제3누적값 연산부의 출력값과 상기 누적된 제3곱셈값 중 하나를 선택하여 제3누적값을 생성하는 제3누적값 출력부; 및 하나 이상의 행 원소값 산출부를 구 비하되, 상기 하나의 행 원소값 산출부는 제1행렬 원소값쌍을 서로 곱한 제1행렬원소 곱셈값을 누적하고, 상기 제3누적값에서 상기 누적된 제1행렬원소 곱셈값 및 상기 제2누적값을 각각 감산하여 상기 제3행렬의 원소값을 산출하는 원소값 산출부를 포함하는 연산장치를 제공한다. 본 발명의 다른 실시예에 의하면, 입력분할부, 제1가산부, 제2가산부, 곱셈부 및 누적부를 구비하고, 위노그라 드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산장치에 있어서, 상기 입력분할부 는 상기 제1행렬의 하나의 원소값, 상기 제2행렬의 하나의 원소값, 상기 제1행렬의 다른 하나의 원소값 및 상기 제2행렬의 다른 하나의 원소값을 나타내는 각각의 비트맵을 상기 제1가산부의 입력단 비트 길이인 N-비트 단위 로 상위 분할비트맵 및 하위 분할비트맵으로 분할하고, 상기 제1가산부는 상기 제1행렬의 하나의 원소값, 상기 제2행렬의 하나의 원소값에 대해 각각 선택된 동일 위치 분할 비트맵별로 서로 가산하고, 상기 제2가산부는 상 기 제1행렬의 다른 하나의 원소값 및 상기 제2행렬의 다른 하나의 원소값에 대해 각각 선택된 동일 위치 분할 비트맵별로 선택하여 서로 가산하고, 상기 곱셈부는 상기 제1가산부의 가산결과와 상기 제2가산부의 가산결과를 곱하여 곱셈값을 산출하고, 상기 누적부는 상기 곱셈부에서 산출되는 곱셈값을 누적하는 연산장치를 제공한다. 본 발명의 다른 실시예에 의하면, 4개의 전처리부, 제1가산부, 제2가산부, 곱셈부, 제3가산부 및 누적부를 구비 하고, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산장치에 있어서, 각 전처리부는 N 비트(단, N은 자연수) 길이의 행렬 원소값쌍을 수신하고 상기 행렬 원소값쌍 중 하나의 원소값은 기설정 길이의 비트맵 상의 상위 비트맵에 위치시키고 상기 행렬 원소값쌍 중 다른 하나의 원소값은 상기 기설 정 길이의 비트맵 상의 하위 비트맵에 위치시키되, 상기 다른 하나의 원소값의 부호 비트를 상기 기설정 길이의 비트맵 상의 (N+1)번째 비트에 복사하여 상기 하위 비트맵에 위치하는 원소값의 부호를 확장하여 2N+1 길이의 비트맵 데이터를 생성하고, 상기 제1가산부는 상기 4개의 전처리부 중 2개의 전처리부에서 생성된 기설정 길이 의 비트맵 상의 데이터를 서로 합산하여 제1결과값을 생성하고, 상기 제2가산부는 상기 4개의 전처리부 중 다른 2개의 전처리부에서 생성된 기설정 길이의 비트맵 상의 데이터를 서로 합산하여 제2결과값을 생성하고, 상기 곱 셈부는 상기 제1결과값의 상위 비트맵에 해당하는 값과 상기 제2결과값의 상위 비트맵에 해당하는 값을 서로 곱 하여 제11곱셈값을 생성하고, 상기 제1결과값의 하위 비트맵에 해당하는 값과 상기 제2결과값의 하위 비트맵에 해당하는 값을 서로 곱하여 제12곱셈값을 생성하고, 상기 제3가산부는 상기 제11곱셈값과 상기 제12곱셈값을 서 로 더하여 곱셈결과값을 생성하고, 상기 누적부는 상기 곱셈결과값을 누적하는 것을 특징으로 하는 연산장치를 제공한다. 본 발명의 다른 실시예에 의하면, 복수의 제2누적값 연산부, 복수의 제3누적값 연산부 및 하나 이상의 행 원소 값 산출부를 구비하는 연산장치에서, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산방법에 있어서, 하나의 제2누적값 연산부에서 제2행렬 원소값쌍을 서로 곱한 제2곱셈값을 누적하 고, 인접한 제2누적값 연산부의 출력값과 누적된 제2곱셈값 중 하나를 선택하여 제2누적값을 출력하는 과정; 상 기 하나의 제2누적값 연산부의 위치에 대응하는 하나의 제3누적값 연산부에서 제1행렬 원소값쌍 중 하나의 원소 값과 상기 제2행렬 원소값쌍 중 하나의 원소값을 더한 제1값을 생성하고 상기 제1행렬 원소값쌍 중 다른 하나의 원소값과 상기 제2행렬 원소값쌍 중 다른 하나의 원소값을 더한 제2값을 생성하는 과정; 상기 하나의 제3누적값 연산부에서 상기 제1값 및 상기 제2값을 곱한 값인 제3곱셈값을 누적하고 인접한 제3누적값 연산부의 출력값과 상기 누적된 제3곱셈값 중 하나를 선택하여 제3누적값을 생성하는 과정; 및 상기 하나의 제3누적값 연산부의 위 치에 대응하는 하나의 행 원소값 산출부에서 상기 제1행렬 원소값쌍을 서로 곱한 제1행렬원소 곱셈값을 누적하 고, 상기 제3누적값에서 상기 누적된 제1행렬원소 곱셈값 및 상기 제2누적값을 각각 감산하여 상기 제3행렬의 원소값을 산출하는 과정을 포함하는 연산방법을 제공한다. 본 발명의 다른 실시예에 의하면, 입력분할부, 제1가산부, 제2가산부, 곱셈부 및 누적부를 구비하는 연산장치에 서, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산방법에 있어서, 상기 입력분할부에서 상기 제1행렬의 하나의 원소값, 상기 제2행렬의 하나의 원소값, 상기 제1행렬의 다른 하나의 원 소값 및 상기 제2행렬의 다른 하나의 원소값을 나타내는 각각의 비트맵을 상기 제1가산부의 입력단 비트 길이인 N 비트 단위로 상위 분할비트맵 및 하위 분할비트맵으로 분할하는 과정; 상기 제1가산부에서 상기 제1행렬의 하 나의 원소값 및 상기 제2행렬의 하나의 원소값에 대해 각각 선택된 동일 위치 분할 비트맵별로 서로 가산하는 과정; 상기 제2가산부에서 상기 제1행렬의 다른 하나의 원소값 및 상기 제2행렬의 다른 하나의 원소값에 대해 각각 선택된 동일 위치 분할 비트맵별로 선택하여 서로 가산하는 과정; 상기 곱셈부에서 상기 제1가산부의 가산 결과와 상기 제2가산부의 가산결과를 곱하여 곱셈값을 산출하는 과정; 및 상기 누적부에서 상기 곱셈부에서 산 출되는 곱셈값을 누적하는 과정을 포함하는 연산방법을 제공한다. 본 발명의 다른 실시예에 의하면, 4개의 전처리부, 제1가산부, 제2가산부, 곱셈부, 제3가산부 및 누적부를 구비 하는 연산장치에서, 위노그라드 알고리즘에 기반하여 제1행렬과 제2행렬을 곱하여 제3행렬을 생성하는 연산방법 에 있어서, 각 전처리부에서, N 비트(단, N은 자연수) 길이의 행렬 원소값쌍을 수신하고 상기 행렬 원소값쌍 중 하나의 원소값은 기설정 길이의 비트맵 상의 상위 비트맵에 위치시키고 상기 행렬 원소값쌍 중 다른 하나의 원 소값은 상기 기설정 길이의 비트맵 상의 하위 비트맵에 위치시키되, 상기 다른 하나의 원소값의 부호 비트를 상 기 기설정 길이의 비트맵 상의 (N+1)번째 비트에 복사하여 상기 하위 비트맵에 위치하는 원소값의 부호를 확장 하여 2N+1 길이의 비트맵 데이터를 생성하는 과정; 상기 제1가산부에서 상기 4개의 전처리부 중 2개의 전처리부 에서 생성된 기설정 길이의 비트맵 상의 데이터를 서로 합산하여 제1결과값을 생성하는 과정; 상기 제2가산부에 서, 상기 4개의 전처리부 중 다른 2개의 전처리부에서 생성된 기설정 길이의 비트맵 상의 데이터를 서로 합산하 여 제2결과값을 생성하는 과정; 상기 곱셈부에서 상기 제1결과값의 상위 비트맵에 해당하는 값과 상기 제2결과 값의 상위 비트맵에 해당하는 값을 서로 곱하여 제11곱셈값을 생성하고, 상기 제1결과값의 하위 비트맵에 해당 하는 값과 상기 제2결과값의 하위 비트맵에 해당하는 값을 서로 곱하여 제12곱셈값을 생성하는 과정; 상기 제3 가산부에서, 상기 제11곱셈값과 상기 제12곱셈값을 서로 더하여 곱셈결과값을 생성하는 과정; 및 상기 누적부에 서 상기 곱셈결과값을 누적하는 과정을 포함하는 연산방법을 제공한다."}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 실시예에 의하면, 시스톨릭 배열(systolic array) 구조의 핵심 유닛들의 일부 기능을 분리하여 이를 담당하 는 추가적인 유닛들을 연산장치의 전체 시스톨릭 배열 상에서 1차원적으로 배치함으로써 단일 형태의 유닛들을 전체 시스톨릭 배열 상 2차원적으로 배열하는 종래의 연산장치에 비해 하드웨어 설계면적이 줄어드는 효과가 있 다. 또한, 핵심 하드웨어 유닛들이 평면상에서 인접한 유닛들과 연산결과 데이터 수신이 가능하도록 하여 핵심 하드 웨어 유닛들이 생성한 연산 데이터를 다른 유닛으로 전달하는 경로의 수를 종래의 연산장치에 비해 대폭 줄임으 로써 본 연산장치가 고속으로 동작하는 효과가 있다. 그리고, 다중 정밀도의 행렬 데이터에 대한 연산을 가능하게 함으로써 복수의 정밀도의 행렬 데이터를 처리하고 자 하는 경우 효율적인 행렬 곱셈기의 설계를 제공하는 효과가 있다."}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 본 발명의 일부 실시예들을 예시적인 도면을 통해 상세하게 설명한다. 각 도면의 구성요소들에 참조부호 를 부가함에 있어서, 동일한 구성요소들에 대해서는 비록 다른 도면상에 표시되더라도 가능한 한 동일한 부호를 가지도록 하고 있음에 유의해야 한다. 또한, 본 발명을 설명함에 있어, 관련된 공지 구성 또는 기능에 대한 구 체적인 설명이 본 발명의 요지를 흐릴 수 있다고 판단되는 경우에는 그 상세한 설명은 생략한다. 도 1은 행렬 X와 Y를 곱셈하여 행렬 Z를 산출하는 행렬 곱셈을 나타낸 것이다. 도 1에 도시한 바와 같이, 행렬 X의 크기가 n×p이고 행렬 Y의 크기가 p×m인 경우, 행렬 Z의 크기는 n×m으로 서 행렬 Z의 각 원소(element) zij 값은 수학식 1과 같이 산출될 수 있다.수학식 1"}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "수학식 1의 곱셈식은 수학식 2와 같이 위노그라드 알고리즘을 이용한 곱셈식으로 나타낼 수 있다. 수학식 2"}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "수학식 2에서, 두번째 ∑항의 계산식은 행렬 Z의 원소의 각 행별로 계산식이 동일하며, 세번째 ∑항의 계산식은 Z의 원소의 각 열별로 계산식이 동일하다. 따라서 수학식 2의 두번째 ∑항은 Z의 원소에 대하여 행별로 한번만 계산하고 수학식 2의 세번째 ∑항은 Z의 원소에 대하여 열별로 한번만 계산하더라도 행렬 Z의 전체 구성 원소 값들을 계산할 수 있다. 또한, 행렬 X나 Y가 그 원소가 항상 일정한 상수값을 갖는 경우 수학식 2의 두번째 또 는 세번째 ∑항의 계산식은 미리 계산된 값을 사용할 수 있다. 이렇게 위노그라드 알고리즘의 특징을 활용하여 수학식 2와 같이 행렬 곱셈을 수행하면 전체 곱셈 횟수는 수학 식 1의 행렬 곱셈에 비하여 감소하며, 그 감소폭은 Z가 커질수록 수학식 1의 행렬 곱셈 연산 횟수의 1/2배에 가 깝게 감소폭이 커진다. 위노그라드 알고리즘에서 곱셈식 계산 외의 추가적인 비용은 수학식 2의 첫번째 ∑항에서, 곱셈의 입력을 위한 덧셈 연산과 이에 따른 1비트 더 큰 입력을 처리하기 위한 곱셈기의 사용이다. 일반적으로 정수 입력에 대한 연 산의 경우 덧셈 연산기에 비하여 곱셈 연산기의 비용이 상대적으로 크고, 정수 곱셈기의 연산 비용은 입력 비트 길이의 제곱에 비례하기 때문에 입력 비트 길이가 길수록 1비트 더 큰 곱셈 입력에 의한 상대적인 추가비용은 감소한다. 따라서, 수학식 2의 첫번째 ∑항에서 발생하는 추가적인 덧셈 연산 및 1비트 더 큰 곱셈 입력의 발생에도 불구 하고 수학식 2의 행렬 곱셈에 소요되는 전체 연산 비용은 수학식 1의 행렬 곱셈에 비해 대폭 감소한다. 도 2는 위노그라드 알고리즘 기반 행렬 곱셈을 위한 시스톨릭 배열(systolic array) 형태의 종래의 행렬곱셈기 의 구성을 예시한 도면이다. 도 2의 행렬곱셈기는 4×4 행렬 X와 Y를 서로 곱하여 4×4 행렬 Z의 각 원소값을 산출하는 경우를 예시한 행렬 곱셈기로서, 제1연산부, 제2연산부 및 제3연산부를 포함한다. 제1연산부는 복수의 X원소 처리유닛(211, 212, 213, 214)을 포함하며, X원소 처리유닛(211, 212, 213, 214)의 개수는 동시에 처리할 수 있는 행렬 X의 최대 행의 개수와 동일하며, 이 보다 큰 행렬은 행렬을 분할하 여 처리할 수 있다. 행렬 분할 처리는 수학적으로 자명한 사항이므로 상세한 기술을 생략하며, 본 실시예에서는 편의를 위해 연산기가 동시에 처리할 수 있는 최대 행렬 크기와 일치하는 행렬에 대해서만 기술한다. 각 X원소 처리유닛(211, 212, 213, 214)은 행렬 X의 한 쌍의 원소값들을 입력받아 곱셈연산 값을 산출하고 이 한 쌍의 X 원소값 및 곱셈연산 값을 저장한다. 제2연산부는 복수의 Y원소 처리유닛(221, 222, 223, 224)을 포함하며, Y원소 처리유닛(221, 222, 223, 224)의 개수는 동시에 처리할 수 있는 행렬 Y의 열의 개수와 동일하다. 각 Y원소 처리유닛(221, 222, 223, 22 4)은 행렬 Y의 한 쌍의 원소값들을 입력받아 곱셈연산 값을 산출하고 이 한 쌍의 Y원소값 및 곱셈연산 값을 각 각 저장한다. 제3연산부는 제1연산부에 저장된 한 쌍의 X원소값 및 그 곱셈연산 값을 수신하고 제2연산부에 저장된 한 쌍의 Y원소값 및 그 곱셈연산 값을 수신하여 행렬 Z의 원소 값들을 산출한다.제3연산부는 복수의 Z원소 처리유닛(231, 232, ... , 246)을 포함하며, Z원소 처리유닛(231, 232, ... , 246)의 개수는 동시에 처리할 수 있는 최대 행렬 X의 행의 개수와 동시에 처리할 수 있는 최대 행렬 Y의 열의 개수를 서로 곱한 값과 동일하다. 도 3은 도 2의 제1 X원소 처리유닛, 제1 Y원소 처리유닛 및 제1 Z원소 처리유닛의 내부 구성을 나타낸 도면이다. 제1 X원소 처리유닛은 제1곱셈부를 포함한다. 제1곱셈부는 행렬 X의 제1원소 및 제2원소를 서로 곱하여 제1곱셈값을 산출한다. 제1 Y원소 처리유닛은 제2곱셈부를 포함한다. 제2곱셈부는 행렬 Y의 제1원소 및 제2원소를 곱하여 제2곱셈값을 산출한다. 제1 Z원소 처리유닛은 제11저장부, 제12저장부, 제13저장부, 제21저장부, 제22저장 부, 제23저장부, 제1가산부, 제2가산부, 제3곱셈부 및 누적연산부를 포함한다. 제11저장부 및 제12저장부는 행렬 X의 제1원소 및 제2원소를 각각 입력받아 저장한다. 제13저장부는 제1곱셈부에서 생성된 제1곱셈값을 저장한다. 제21저장부 및 제22저장부는 행렬 Y의 제1원소 및 제2원소를 각각 입력받아 저장한다. 제23저장부는 제2곱셈부에서 생성된 제2곱셈값을 저장한다. 제1가산부는 제11저장부 및 제21저장부에 각각 저장된 행렬 X의 제1원소 및 행렬 Y의 제1원소를 수신하여 덧셈을 수행하여 제1 덧셈값을 산출한다. 제2가산부는 제12저장부 및 제22저장부에 각각 저장된 행렬 X의 제2원소 및 행렬 Y의 제2원소를 수신하여 덧셈을 수행하여 제2 덧셈값을 산출한다. 제3곱셈부는 제1 덧셈값 및 제2 덧셈값을 수신하여 제1 덧셈값 및 제2 덧셈값을 서로 곱하여 제3곱셈값을 산출한다. 누적연산부는 제1곱셈부, 제2곱셈부 및 제3곱셈부로부터 각각 제1곱셈값, 제2곱셈값 및 제 3곱셈값을 수신하고, 제3곱셈값에 제1곱셈값 및 제2곱셈값을 각각 빼서 누적값을 산출한다. 여기서 산출된 누적 값이 행렬 Z의 한 Z원소값이 된다. 도 2에서, 각 Z원소 처리유닛(231, 232, ... , 246)은 해당 Z원소 처리유닛(231, 232, ... , 246)의 좌측단의 X원소 처리유닛(211, 212, 213, 214)으로부터 제1 X원소의 값, 제2 X원소의 값 및 그 곱셈값을 수신하고, 해당 Z원소 처리유닛(231, 232, ... , 246)의 상단의 Y원소 처리유닛(221, 222, 223, 224)으로부터 제1 Y원소의 값, 제2 Y원소의 값 및 그 곱셈값을 수신하여 해당 Z원소 처리유닛(231, 232, ... , 246)에 대응되는 Z원소값을 연 산한다. 예컨대, Z원소 처리유닛의 경우 같은 행 좌측단에 존재하는 X원소 처리유닛과 같은 열 상단 에 존재하는 Y원소 처리유닛으로부터 해당 Z원소 처리유닛의 연산동작에 필요한 원소값들을 수신한다. 한편, 6개의 저장부(311, 312, 313, 321, 322, 323)는 각각 플립플롭(flip-flop)으로 구현될 수 있으며, 플립 플롭의 동작은 당업자에게 자명한 사항이므로 이에 대한 더 이상의 상세한 설명은 생략한다. 도 2의 연산장치에서, 제3연산부의 Z원소 처리유닛(231, 232, ... , 246)의 개수가 제1연산부 의 X원소 처리유닛(211, 212, 213, 214)의 개수 및 Y원소 처리유닛(221, 222, 223, 224)의 개수보다 각각 많기 때문에, 연산장치의 성능향상을 위해서는 제3연산부를 최적화하는 것이 더 중요하다. 도 2 및 도 3에 도시한 바와 같이, 제3연산부내의 제1 Z원소 처리유닛은 뺄셈 연산을 위한 데이터를 제1연산부 및 제2연산부에서 각각 수신한다. 제1 Z원소 처리유닛 뿐만 아니라 나머지 Z원소 처리유닛(232, ... , 246)들도 모두 뺄셈 연산을 위하여 데 이터를 제1연산부 및 제2연산부에서 각각 수신한다. 따라서, 뺄셈연산에 필요한 데이터의 전송을 위한 경로가 2차원으로 배열된 Z원소 처리유닛(231, 232, ... , 246)에 필요하다.도 4는 본 실시예에 따른 위노그라드 알고리즘 기반 행렬 곱셈을 위한 시스톨릭 배열 형태의 연산장치의 구성을 도시한 도면이다. 본 실시예에 따른 연산장치는 4×4 크기의 제1행렬 X와 제2행렬 Y를 서로 곱하여 4×4 크기의 제3행렬 Z의 각 원소값을 산출하는 경우를 예시한 행렬 곱셈기로서 동작하며, 원소값 산출부, 제2누적값 출력부 및 제3누적값 출력부를 포함한다. 원소값 산출부는 복수의 행 원소값 산출부(411, 412, 413, 414)를 포함한다. 행 원소값 산출부(411, 412, 413, 414)의 개수는 n 개(단, n은 1 이상의 자연수)이다. 여기서 n은 동시에 처리할 수 있는 행렬 X의 최대 행 의 개수 및 제3행렬 행렬 Z의 행의 개수와 동일할 수도 있다. 본 실시예에서는 n = 4인 경우를 예로 들어 설명 한다. 제2누적값 출력부는 복수의 제2누적값 연산부(421, 422, 423, 424)를 포함한다. 제2누적값 연산부(421, 422, 423, 424)의 개수는 m 개(단, m은 1 이상의 자연수)이다. 여기서 m은 동시에 처리할 수 있는 행렬 Y의 최 대 행의 개수 및 행렬 Z의 열의 개수와 동일할 수도 있다. 본 실시예에서는 m = 4인 경우를 예로 들어 설명한다. 제3누적값 출력부는 복수의 제3누적값 연산부(431, 432, ..., 446)를 포함한다. 여기서, 제3누적값 연산부 (431, 432, ..., 446)의 개수는 n×m 개, 즉, 16 개이다. 도 4에 도시한 바와 같이, 복수의 행 원소값 산출부(411, 412, 413, 414), 복수의 제2누적값 연산부(421, 422, 423, 424) 및 복수의 제3누적값 연산부(431, 432, ..., 446)는 전체적으로 2차원의 시스톨릭 배열 구조로 형성 된다. 도 4의 전체적인 2차원 시스톨릭 배열 구조 상에서 구성요소의 종류별로 상세히 살펴보면, 복수의 행 원소값 산 출부(411, 412, 413, 414) 및 복수의 제2누적값 연산부(421, 422, 423, 424)는 각각 1차원의 시스톨릭 배열 구 조로 형성되고, 복수의 제3누적값 연산부(431, 432, ..., 446)는 2차원의 시스톨릭 배열 구조로 형성된다. 하지만, n=1 또는 m=1인 경우 3누적값 연산부(431, 432, ..., 446)는 1차원의 시스톨릭 배열 구조로 형성된다. 제2누적값 출력부는 제3누적값 출력부의 상측에 형성되고, 원소값 산출부는 제3누적값 출력부 의 측면에 형성된다. 도 4에서 원소값 산출부가 제3누적값 출력부의 좌측에 형성되는 것으로 도 시되어 있으나 실시예에 따라서는 제3누적값 출력부의 우측에 형성될 수도 있다. 제2누적값 연산부(421, 422, 423, 424)는 제2행렬 원소값쌍을 서로 곱한 제2곱셈값을 누적한다. 또한, 제2누적 값 연산부(421, 422, 423, 424) 중 최우측 제2누적값 연산부를 제외한 제2누적값 연산부(421, 422, 423) 는 각각 인접한 제2누적값 연산부(422, 423, 424)의 출력값과 누적된 제2곱셈값 중 하나를 선택하여 제2누적값 을 출력한다. 또한, 최우측 제2누적값 연산부는 누적된 제2곱셈값을 좌측의 제2누적값 연산부로 출력시킨다. 또한, 각 제3누적값 연산부(431, 432, ..., 446)는 제1행렬 원소값쌍 중 하나의 원소값과 제2행렬 원소값쌍 중 하나의 원소값을 더한 제1값을 생성하고 제1행렬 원소값쌍 중 다른 하나의 원소값과 제2행렬 원소값쌍 중 다른 하나의 원소값을 더한 제2값을 생성하고 생성된 제1값 및 제2값을 곱한 값인 제3곱셈값을 누적한다. 각 제3누적값 연산부(431, 432, ..., 446) 중 최우측 제3누적값 연산부(434, 438, 442, 446)을 제외한 나머지 제3누적값 연산부(431, 432, ..., 445)는 각각 누적된 제3곱셈값과 인접한 제3누적값 연산부(43, 432, ..., 446)의 출력값 중 하나를 선택하여 제3누적값을 생성한다. 최우측 제3누적값 연산부(434, 438, 442, 446)는 각각 누적된 제3곱셈값을 좌측의 제3누적값 연산부(433, 437, 441, 445)로 출력시킨다. 각 행 원소값 산출부(411, 412, 413, 414)는 제1행렬 원소값쌍을 서로 곱한 제1행렬원소 곱셈값을 누적하고, 제 3누적값에서 누적된 제1행렬원소 곱셈값 및 제2누적값을 각각 감산하여 제3행렬의 원소값을 산출한다. 도 5는 제1행 원소값 산출부, 최좌측 제2누적값 연산부 및 최상단 좌측 제3누적값 연산부의 내 부 구성을 도시한 도면이다. 이하, 도 4 및 도 5를 함께 참조하면서 제1행 원소값 산출부, 최좌측 제2누적값 연산부 및 최상단좌 측 제3누적값 연산부의 동작을 설명한다.제1행 원소값 연산부는 제2누적값 저장부, 제1곱셈부, 제1누적부, 제11저장부 및 제1 합산부를 포함한다. 제1행 원소값 연산부는 제1행렬 원소값쌍을 서로 곱한 제1행렬원소 곱셈값을 누적하고, 제1행 원소값 연산 부의 위치에 대응하는 제3누적값 연산부에서 생성된 제3누적값에서 제1행 원소값 연산부에서 누 적된 제1행렬원소 곱셈값 및 제2누적값을 각각 감산하여 제3행렬의 원소값을 산출한다. 제2누적값 저장부는 제2누적값 출력부로부터 수신한 제2누적값을 저장한다. 제1곱셈부는 행렬 X의 한쌍의 원소값인 제1원소값 x11 및 제2원소값 x12를 각각 입력단자 i11 및 i12에서 입 력받는다. 제1곱셈부는 입력된 x11 및 x12를 서로 곱하여 제1행렬원소 곱셈값 a1을 산출한다. 또한, 제1곱 셈부는 행렬 X의 다른 한쌍의 원소값인 제3원소값 x13 및 제4원소값 x14가 각각 입력단자 i11 및 i12에서 입 력되면 입력된 x13 및 x14를 서로 곱하여 또다른 제1행렬원소 곱셈값 a2를 산출한다. 참고로, 본 실시예에서 행렬 의 원소값의 첨자에 대해 xij, xi,j와 같이 서로 혼용하여 표현될 수 있으며, 이 둘은 첨자의 표시방식만 다를 뿐 동일한 의미로 사용된 것이다. 제1누적부는 제1곱셈부에서 생성된 제1행렬원소 곱셈값 a1 및 a2를 순차적으로 누적하여 제1행렬원소 곱셈누적값을 생성한다. 만일, 행렬 X의 크기가 4×6, 6×6 및 8×6인 경우와 같이 행렬 X의 열의 개수가 6인 경우, 제1곱셈부의 입력단자 i11 및 i12에 각각 입력되는 행렬 X의 또다른 한쌍의 원소값인 제5원소값 x15 및 제6원소값 x16을 서로 곱하여 또다른 제1행렬원소 곱셈값 a3을 산출한다. 이 경우, 제1누적부는 제1곱셈부에서 생성된 제1 행렬원소 곱셈값 a1, a2 및 a3을 순차적으로 누적하여 제1행렬원소 곱셈누적값을 생성한다. 제11저장부는 제1누적부에서 생성된 제1행렬원소 곱셈누적값을 저장한다. 제11저장부에 저장된 제1행렬원소 곱셈누적값은 제1합산부에서 행렬 Z의 한 행별로 원소값을 산출하는 데에 사용된다. 제1합산부는 제14저장부에 저장된 제3누적값에서 제11저장부에 저장된 제1행렬원소 곱셈누적값 및 제2누적값 저장부에 저장된 제2누적값을 각각 감산하여 제3행렬 Z의 원소값을 산출한다. 참고로, 제2누적값 저장부에 저장된 제2누적값이 제2행 원소값 산출부로 전달되도록 제2누적값 저장 부와 제1합산부 사이의 연결선로로부터 연결선이 제1행 원소값 산출부의 아래에 위치하는 제2행 원소값 산출부의 제2누적값 저장부(미도시)로 연장된다. 제2행 원소값 산출부도 제1행 원소값 산출부와 동일한 구성요소를 가진다. 제2행 원소값 산출부(41 2)는 Z 행렬의 제2행의 원소값을 산출하기 위해 필요한 행렬 X의 원소값을 수신하고 제2행 원소값 산출부 내의 제2누적값 저장부(미도시)에 저장된 제2누적값과, 인접하는 제3누적값 연산부로부터 수신된 제3누적 값을 이용하여 Z 행렬의 제2행의 원소값을 산출한다. 여기에 도시하지는 않았지만 제2누적값이 제3행 원소값 산출부와 제4행 원소값 산출부로 순차적으로 전달하기 위한 추가적인 연결선로(미도시)가 연이어 형성된다. 제2행 원소값 산출부, 제3행 원소값 산출부 및 제4행 원소값 산출부도 그 구성 및 동작이 제1행 원소값 산출부의 구성 및 동작과 유사하므로 더 이상의 상세한 설명은 생략한다. 최좌측 제2누적값 연산부는 제2곱셈부, 제2누적부 및 제2선택부를 포함한다. 최좌측 제2누적값 연산부는 입력된 제2행렬 원소값쌍을 서로 곱한 제2곱셈값을 누적하고, 인접한 제2누적 값 연산부의 출력값과 누적된 제2곱셈값 중 하나를 선택하여 제2누적값을 출력한다. 제2곱셈부는 행렬 Y의 한쌍의 원소값인 제1원소값 y11 및 제2원소값 y21을 입력단자 i21 및 i22에서 각각 입 력받고, 입력된 y11 및 y21을 서로 곱하여 제2행렬원소 곱셈값 b1을 산출한다. 또한, 제2곱셈부는 행렬 Y의 다른 한쌍의 원소값인 제3원소값 y31 및 제4원소값 y41이 입력단자 i21 및 i22에서 각각 입력되면 입력된 y31 및 y41을 서로 곱하여 또다른 제2행렬원소 곱셈값 b2를 산출한다. 제2누적부는 제2곱셈부에서 생성된 제2행렬원소 곱셈값 b1 및 b2를 순차적으로 누적하여 제2행렬원소 곱셈누적값을 생성한다. 만일, 행렬 Y의 크기가 6×4, 6×6 및 6×8인 경우와 같이 행렬 Y의 행의 개수가 6인 경우, 제2곱셈부의 입력단자 i21 및 i22에 각각 입력되는 행렬 Y의 또다른 한쌍의 원소값인 제5원소값 y51 및 제6원소값 y61을 서로 곱하여 또다른 제2행렬원소 곱셈값 b3을 산출한다. 이 경우, 제2누적부는 제2곱셈부에서 생성된 제2 행렬원소 곱셈값 b1, b2 및 b3을 순차적으로 누적하여 제2행렬원소 곱셈누적값을 생성한다. 제2선택부는 제2누적부에서 생성된 제2행렬원소 곱셈누적값과 인접하는 제2누적값 연산부로부터 곱셈누적값을 각각 수신하고 제2누적부에서 생성된 제2행렬원소 곱셈누적값과 인접하는 제2누적값 연산부 로부터 수신된 곱셈누적값 중에서 하나를 제2선택부의 제어입력 c0의 값에 따라 선택하여 제2누적값 으로서 출력하여 제2누적값 저장부에 저장된다. 참고로, c0의 값이 0이면 제2누적부에서 생성된 제2행렬원소 곱셈누적값이 선택되고 c0의 값이 1이면 인접 하는 제2누적값 연산부로부터 수신된 곱셈누적값이 선택된다. 최상단좌측 제3누적값 연산부는 제12저장부, 제13저장부, 제14저장부, 제21저장부, 제22저장부, 제31가산부, 제32가산부, 제3곱셈부, 제3누적부 및 제3선택부를 포함한다. 최상단좌측 제3누적값 연산부는 입력된 제1행렬 원소값쌍 중 하나의 원소값과 입력된 제2행렬 원소값쌍 중 하나의 원소값을 더한 제1값을 생성하고 제1행렬 원소값쌍 중 다른 하나의 원소값과 제2행렬 원소값쌍 중 다른 하나의 원소값을 더한 제2값을 생성하고 제1값 및 제2값을 곱한 값인 제3곱셈값을 누적하고 인접한 제3누적값 연산부의 출력값과 누적된 제3곱셈값 중 하나를 선택하여 제3누적값을 생성한다. 제12저장부는 행렬 X의 한쌍의 원소값 중의 하나를 저장하고 제13저장부는 행렬 X의 한쌍의 원소값 중의 다른 하나를 저장한다. 예컨대, 행렬 X의 한쌍의 원소값으로서 x11 및 x12가 입력단자 i11 및 i12에 각각 입 력된 경우, 제12저장부는 하나의 원소값 x11을 저장하고 제13저장부는 다른 하나의 원소값 x12를 저장 한다. 제14저장부는 제3선택부로부터 제3누적값을 수신하여 저장한다. 여기서 제3누적값은 최상단좌측 제3 누적값 연산부와 같은 행에 존재하는 제3누적값 연산부(432, 433, 434)의 제3선택부(미도시) 및 최상단좌 측 제3누적값 연산부의 제3선택부 중 어느 하나에서 선택된 제3누적값이 순차적으로 좌측으로 전달되 어 제3선택부가 출력하여 제14저장부에 저장된다. 제21저장부는 행렬 Y의 한쌍의 원소값 중의 하나를 저장하고 제22저장부는 행렬 Y의 한쌍의 원소값 중의 다른 하나를 저장한다. 예컨대, 행렬 Y의 한쌍의 원소값으로서 y11 및 y21이 입력된 경우, 제21저장부(52 4)는 하나의 원소값 y11을 저장하고 제22저장부는 다른 하나의 원소값 y21을 저장한다. 한편, 제21저장부 및 제22저장부에 각각 저장된 데이터는 아래쪽으로 인접한 제3누적값 연산부 의 제21저장부(미도시) 및 제22저장부(미도시)로 각각 출력된다. 제31가산부는 행렬 X의 하나의 원소값을 제12저장부로부터 수신하고 행렬 Y의 하나의 원소값을 제21 저장부로부터 수신하고, 행렬 X의 하나의 원소값과 행렬 Y의 하나의 원소값을 서로 더한 제1값을 생성한다. 제32가산부는 행렬 X의 다른 하나의 원소값을 제13저장부로부터 수신하고 행렬 Y의 다른 하나의 원소 값을 제22저장부로부터 수신하고, 행렬 X의 다른 하나의 원소값과 행렬 Y의 다른 하나의 원소값을 서로 더 한 제2값을 생성한다. 제3곱셈부는 제31가산부에서 생성된 제1값과 제32가산부에서 생성된 제2값을 서로 곱하여 제3곱 셈값을 산출한다. 제3누적부는 제3곱셈부에서 생성된 제3곱셈값을 누적한다. 제3선택부는 제3누적부에서 생성된 누적 제3곱셈값과 인접하는 제3누적값 연산부로부터 곱셈누 적값을 각각 수신하고, 제3선택부의 제어입력 c0의 값에 따라 제3누적부에서 생성된 누적 제3곱셈값 과 인접하는 제3누적값 연산부로부터 수신된 곱셈누적값 중에서 하나를 선택하여 제3누적값으로서 출력한다. 제3선택부에서 출력된 제3누적값은 제14저장부에 저장된다. 한편, 제3선택부는 시스톨릭 배열 상 최좌측 제2누적값 연산부와 같은 열에 존재하는 제3누적값 연산 부인 최상단좌측 제3누적값 연산부의 제2선택부에 입력되는 제어입력과 동일한 제어입력인 c0에 따라 출력이 결정된다. 도 6은 제2누적값 연산부(421, 422, 423, 424) 및 최상측 제3누적값 연산부(431, 432, 433, 434)의 구성을 상 세히 도시하되 도면번호는 설명에 필요한 일부 구성요소에 대해서만 표기하고 나머지는 생략한 도면이다. 최좌측 제2누적값 연산부 및 최상단좌측 제3누적값 연산부의 동작은 전술하였으므로, 이하의 설명에 서는 나머지 제2누적값 연산부(422, 423, 424) 및 나머지 제3누적값 연산부(432, 433, 434)의 상세한 동작의 설 명은 생략하고 제2선택부(523, 623, 624) 및 제3선택부(535, 635, 636)의 데이터 선택 동작을 중심으로 설명한 다. 도 6에서, c0 값이 0이면, 제2누적값 연산부의 제2누적부에서 생성된 곱셈누적값이 제2선택부에 서 선택되어 제2누적값 저장부로 출력된다. 또한 제3누적값 연산부의 제3누적부에서 생성된 곱 셈누적값이 제3선택부에서 선택되어 제14저장부로 출력된다. c0 값이 1이면, 제2누적값 연산부의 제2선택부에서 출력된 곱셈누적값이 제2선택부에서 선택되 어 제2누적값 저장부로 출력되고 또한 제3누적값 연산부의 제3누적부(S21)에서 생성된 곱셈누적값이 제3선택부에서 선택되어 제14저장부로 출력된다. c1 값이 0이면, 제2누적값 연산부의 제2누적부(S11)에서 생성된 곱셈누적값이 제2선택부에서 선택되 어 제2누적값 연산부의 제2선택부로 입력되고 또한 제3누적값 연산부의 제3누적부(S21)에서 생 성된 곱셈누적값이 제3누적값 연산부의 제3선택부에서 선택되어 제3누적값 연산부의 제3선택부 로 입력된다. c1 값이 1이면, 제2누적값 연산부의 제2선택부에서 출력된 곱셈누적값이 제2누적값 연산부의 제 2선택부에서 선택되어 제2누적값 연산부의 제2선택부로 입력되고 또한 제3누적값 연산부의 제3누적부(S22)에서 생성된 곱셈누적값이 제3선택부에서 선택되어 제3누적값 연산부의 제3선택부 로 입력된다. c2 값이 0이면, 제2누적값 연산부의 제2누적부(S12)에서 생성된 곱셈누적값이 제2선택부에서 선택되 어 제2누적값 연산부의 제2선택부로 입력되고 또한 제3누적값 연산부의 제3누적부(S22)에서 생 성된 곱셈누적값이 제3선택부에서 선택되어 제3누적값 연산부의 제3선택부로 입력된다. c2 값이 1이면, 제2누적값 연산부의 제2누적부(S13)에서 생성된 곱셈누적값이 제2선택부에서 선택되 어 제2누적값 연산부의 제2선택부로 입력되고 또한 제3누적값 연산부의 제3누적부(S23)에서 생 성된 곱셈누적값이 제3선택부에서 선택되어 제3누적값 연산부의 제3선택부로 입력된다. 제1행 원소값 산출부에서 행렬 Z의 원소값을 산출하기 위한 누적값이 c0, c1, c2 값에 따라 선택되는 출력 의 구성요소 번호를 표 1에 나타내었다. 표 1 c0 c1 c2 선택되는 구성요소 번호 0 x x 522, 534 1 0 x S11, S21 1 0 S12, S22 1 S13, S23 표 1에 나타낸 바와 같이, c0 = 0인 경우, c1 및 c2의 값에 관계없이 제2누적값 연산부의 제2누적부 에서 생성된 곱셈누적값이 제2선택부에서 선택되어 제2누적값 저장부로 출력되고 또한 제3누적값 연 산부의 제3누적부에서 생성된 곱셈누적값이 제3선택부에서 선택되어 제14저장부로 출력된 다. c0 = 1, c1 = 0인 경우, c2의 값에 관계없이 제2누적값 연산부의 제2누적부(S11)에서 생성된 곱셈누적값이 제2선택부 및 제2선택부에서 순차적으로 선택되어 제2누적값 저장부로 출력되고 또한 제3누적값연산부의 제3누적부(S21)에서 생성된 곱셈누적값이 제3선택부 및 제3선택부에서 순차적으로 선 택되어 제14저장부로 출력된다. c0 = c1 = 1, c2 = 0인 경우, 제2누적값 연산부의 제2누적부(S12)에서 생성된 곱셈누적값이 제2선택부 , 제2선택부 및 제2선택부에서 순차적으로 선택되어 제2누적값 저장부로 출력되고 또한 제 3누적값 연산부의 제3누적부(S22)에서 생성된 곱셈누적값이 제3선택부, 제3선택부 및 제3선택부 에서 순차적으로 선택되어 제14저장부로 출력된다. c0 = c1 = c2 = 1인 경우, 제2누적값 연산부의 제2누적부(S13)에서 생성된 곱셈누적값이 제2선택부, 제2선택부 및 제2선택부에서 순차적으로 선택되어 제2누적값 저장부로 출력되고 또한 제3누적값 연산부의 제3누적부(S23)에서 생성된 곱셈누적값이 제3선택부, 제2선택부 및 제2선택부에 서 순차적으로 선택되어 제14저장부로 출력된다. 따라서, 제1행 원소값 산출부는 c0, c1 및 c2 값에 따라 해당하는 제3누적값 및 제2누적값을 순차적으로 수신하여 행렬 Z의 원소값 z11, z12, z13 및 z14를 순차적으로 생성한다. 제1행 원소값 산출부을 제외한 나머지 행 원소값 산출부(412, 413, 414)의 동작은 제1행 원소값 산출부 의 동작과 유사하므로 나머지 행 원소값 산출부(412, 413, 414)이 행렬 Z의 원소값을 생성하는 방법에 대 한 더 이상의 설명은 생략한다. 한편, 도 5에서, 7개의 저장부(501, 513, 514, 515, 516, 524, 525)는 각각 플립플롭으로 구현되고 제2선택부 및 제3선택부는 멀티플렉서로 구현될 수 있으나 본 발명이 이에 한정되지는 않는다. 한편, 플립플롭 및 멀티플렉서의 동작은 당업자에게 자명한 사항이므로 이에 대한 더 이상의 상세한 설명은 생략한다. 이상에서 설명한 바와 같이, 본 실시예에 따른 연산장치는 행렬 Z의 원소값 산출에 필요한 뺄셈 연산이 2 차원 시스톨릭 배열 구조를 갖는 제3누적값 연산부(431, 432, ..., 446)에는 존재하지 않도록 구현된다. 대신에 행렬 Z의 원소값 산출에 필요한 뺌셈 연산 회로는 제1합산부와 같이 행 원소값 산출부(411, 412, 413, 414)에 각각 설계된다. 2차원 구조를 갖는 제3누적값 연산부(431, 432, ..., 446) 각각에 2회씩의 (-) 연산을 위하여 필요한 하드웨어 를 배치하지 않는 대신에 하나의 선택연산을 위한 하드웨어를 설계하고, (-) 연산회로는 1차원 구조를 갖는 행 원소값 산출부(411, 412, 413, 414)에 각각 설계되므로 도 4의 전체적인 하드웨어 설계면적은 도 2의 전체적인 하드웨어 설계 면적에 비해 줄어드는 효과가 있다. 또한, 제2누적값 출력부에서 생성된 피감수인 제2누적값의 전달에 필요한 데이터 경로가 제2누적값 출력부 와 제3누적값 출력부 사이에는 존재하지 않고 제2누적값 출력부 내의 우측으로부터 좌측방향과 원소값 산출부 내의 상측으로부터 하측 방향으로 데이터 경로가 추가로 형성된다. 따라서, 제2누적값 출력부에서 생성된 피감수인 제2누적값이 1차원 시스톨릭 배열 구조를 갖는 제2누적값 출력부와 원소값 산출부를 경우하므로 피감수인 제2누적값의 전달 경로의 개수가 도 2의 연산장치 의 경우에 비해 대폭 줄어든다. 따라서, 위노그라드 알고리즘을 이용한 행렬 곱셈을 연산함에 있어서 도 2 의 연산장치에 비해 도 4의 연산정치의 동작은 더욱 고속으로 수행 가능한 효과가 있다. 따라서, 본 실시예는 하드웨어 면적 감소에 따른 경제적 측면과 동작속도 증가에 따른 연산속도 측면 모두에 현 저한 효과가 있는 발명이다. 본 실시예에 따른 연산장치를 설계함에 있어서 다중 정밀도, 즉 다중 비트 길이를 지원하도록 구현할 수 있다. 연산장치는 다중 정밀도 지원이 가능하도록 제3누적값 연산부에서 제31가산부, 제32가산부 , 제3곱셈부 및 제3누적부의 기능이 서로 다른 비트 길이의 입력에 대해 공용으로 사용될 수 있 도록 설계된다. 복수의 정밀도의 행렬곱셈 연산을 수행하는 경우, 행렬곱셈을 위한 연산장치가 입력 데이터에 대한 하나의 정밀 도 외에 다른 정밀도의 입력 데이터에 대한 연산도 지원하도록 구현되는 경우 하드웨어 비용을 크게 줄일 수 있 다. 본 실시예는 8비트 정밀도와 16비트 정밀도 입력 데이터를 동시에 지원하는 경우에 대해 기술하지만, 16비트 정 밀도와 32비트 정밀도 입력 데이터 동시 지원 등 다양한 경우에 대해서도 적용 가능하다. 다중 정밀도를 지원하는 행렬 곱셈기의 하드웨어 설계에는 두 가지 방법이 가능하다. 낮은 정밀도를 지원하는 하드웨어 연산기를 기반으로 높은 정밀도의 데이터를 여러 사이클에 걸쳐 처리하는 방법과, 반대로 높은 정밀도 를 지원하는 하드웨어 연산기를 기반으로 한 사이클에 여러 개의 낮은 정밀도의 데이터를 처리하는 방법이 있다. 먼저, 낮은 정밀도를 지원하는 하드웨어 연산기를 기반으로 높은 정밀도의 데이터를 여러 사이클에 걸쳐 처리하 는 방법에 대하여 기술한다. 위노그라드 알고리즘을 이용하는 경우, 8비트 정수 행렬 데이터가 입력되는 경우 9비트 정수 곱셈 계산이 필요 하며, 16비트 정수 행렬 데이터가 입력되는 경우 17비트 정수 곱셈 계산이 필요하다. 17비트 정수 곱셈의 경우 는 9비트 정수 곱셈기를 4회 이용하여 수행 가능하다. 도 7은 본 실시예에 따른 합산곱 연산방법을 도시한 것으로서, 제3누적값 연산부에서 제31가산부, 제 32가산부, 제3곱셈부 및 제3누적부의 기능을 데이터 흐름도로 표현한 것이다. 참고로, 도 7에서의 캐리(carry)는 덧셈 연산을 수행하였을 때, 최상위 자리에서 올림이 발생하였는지 여부를 나타내는 비트를 나타낸다. 예를 들어, 덧셈 연산의 결과 최상위 자리에서 올림이 발생한 경우 캐리는 1의 값을 갖는 반면 최상위 자리에서 올림이 발생하지 않은 경우 캐리는 0의 값을 가지도록 구현될 수 있다. 도 8은 본 실시예에 따른 합산곱 연산장치를 도시한 도면으로서 도 7의 데이터 흐름도를 구현한 것이다. 도 8에서, 본 실시예에 따른 합산곱 연산장치는 입력분할부, 제1가산부, 제2가산부, 곱셈 부 및 누적부를 포함하며, 제3누적값 연산부(431, 432, 433, 434)는 본 실시예에 따른 합산곱 연산장 치를 포함하여 구현될 수 있다. 참고로, 본 실시예에 따른 합산곱 연산장치는, 제1가산부 및 제2가산부는 N 비트 단위의 행렬 원소 입력에 대하여 합산 연산은 제공하지만 2N 비트 단위의 행렬 원소 입력에 대해서는 합산 연산을 제공하지 않는 경우, 2N 비트 단위의 행렬 원소 입력에 대한 합산곱 연산 가능하도록 확장된 것을 예시한 것이다. 이하, N=8인 경우를 예로 들어 설명한다. 입력분할부는 제11처리부, 제12처리부, 제21처리부 및 제22처리부를 포함한다. 제1가산부는 제11선택부, 제12선택부, 제11가산부, 제1캐리 저장부 및 제1캐리 입력 부를 포함한다. 제2가산부는 제21선택부, 제22선택부, 제21가산부, 제2캐리 저장부, 제2캐리 입력부 를 포함한다. 곱셈부는 합산값 곱셈부, 승수선택부 및 승수 곱셈부를 포함한다. 도 8에서, 제11처리부는 2N(즉, 16) 비트 길이의 X 행렬 원소인 제1입력 xi,2k-1에 대하여 상위 N 비트 분할 비트맵 와 하위 N 비트 분할비트맵 로 분할 출력하여 제11선택부로 입력시킨다. 제12처리부는 2N 비트 길이의 Y 행렬 원소인 제2입력 y2k,j에 대하여 상위 N 비트 분할비트맵"}
{"patent_id": "10-2019-0077200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "와 하위 N 비트 분할비트맵 로 분할 출력하여 제12선택부로 입력시킨다. 제11선택부는 xi,2k-1에 대한 상위 분할비트맵 과 하위 분할비트맵 을 각각 수신 하여 S0의 값에 따라 선택적으로 출력한다. 예컨대, S0=0이면 제11선택부는 하위 분할비트맵 을 출력하고 S0=1이면 제11선택부는 상위 분할비트맵 을 출력하여 제11가산부로 입력시킨다. 제12선택부는 제1행렬의 하나의 원소값, 제2행렬의 하나의 원소값에 대해 각각 선택된 동일 위치 분할 비 트맵별로 선택한다. 즉, 제12선택부는 y2k,j에 대한 상위 분할비트맵 과 하위 분할비트맵 을 각각 수신하여 S0의 값에 따라 선택적으로 출력한다. 예컨대, S0=0이면 제12선택부는 하 위 분할비트맵 을 출력하고 S0=1이면 제12선택부는 상위 분할비트맵 을 출력하 여 제11가산부로 입력시킨다. 제11가산부는 제11선택부의 출력 및 제12선택부의 출력을 수신하여 그 덧셈값을 산출한다. 여기 서, 제11가산부가 제11선택부 및 제12선택부로부터 동일 위치 분할 비트맵에 대한 선택값을 각 각 수신한다. 제21처리부는 제3입력 xi,2k에 대하여 2N 비트 길이의 X 행렬 다른 원소인 상위 N 비트 분할비트맵 와 하위 N 비트 분할비트맵 로 분할 출력하여 제21선택부로 입력시킨다. 제22처리부는 2N 비트 길이의 Y 행렬 다른 원소인 제4입력 y2k-1,j에 대하여 상위 N 비트 분할비트맵 와 하위 N 비트 분할비트맵 로 분할 출력하여 제22선택부로 입력시킨다. 제21선택부는 xi,2k-1에 대한 상위 분할비트맵 과 하위 분할비트맵 을 각각 수신 하여 S1의 값에 따라 선택적으로 출력한다. 예컨대, S1=0이면 제21선택부는 하위 분할비트맵 을 출력하고 S1=1이면 제21선택부는 상위 분할비트맵 을 출력하여 제21가산부 로 입력시킨다. 제22선택부는 y2k-1,j에 대한 상위 분할비트맵 과 하위 분할비트맵 을 각각 수신하 여 S1의 값에 따라 선택적으로 출력한다. 예컨대, S1=0이면 제22선택부는 하위 분할비트맵 을 출력하고 S1=1이면 제22선택부는 상위 분할비트맵 을 출력하여 제21가산부로 입력시킨 다. 제21가산부는 제21선택부의 출력 및 제22선택부의 출력을 수신하여 그 덧셈값을 산출한다. 여기 서, 제21가산부가 제21선택부 및 제22선택부로부터 동일 위치 분할 비트맵에 대한 선택값을 각 각 수신한다. 합산값 곱셈부는 제11가산부에서 생성된 가산결과와 제21가산부생성된 가산결과를 곱하여 곱셈 결과를 산출한다. 승수선택부는 제11가산부의 가산결과와 상기 제21가산부의 가산결과에 대응하는 승수를 선택한 다. 승수 곱셈부는 제11가산부의 가산결과와 상기 제21가산부의 가산결과를 곱한 곱셈결과에 승수선 택부에서 선택된 승수를 곱하여 제2곱셈값을 산출한다. 누적부는 승수 곱셈부에서 산출되는 제2곱셈값을 누적한다. 각 가산부(제11가산부 및 제21가산부)는 (N+1)비트 정수 덧셈기 또는 N 비트 양수 덧셈기로 동작되는 지 여부에 따라 M0/M1의 값이 결정된다. 예를 들어, 각 가산부(제11가산부 및 제21가산부)가 (N+1)비트 정수 덧셈기로서 동작이 필요한 경우(즉, (N+1) 비트 정수 덧셈기 모드) M0/M1의 값은 0으로 설정되며, 각 가산부(제11가산부 및 제21가산부)가 N 비트 양수 덧셈기로서 동작이 필요한 경우(즉, N 비트 양수 덧셈기 모드) M0/M1의 값은 1이 된다. M0/M1의 값이 0인 경우, 즉, 각 가산부(제11가산부 및 제21가산부)가 (N+1) 비트 정수 덧셈기 모드인 경우, 각 가산부(제11가산부 및 제21가산부)는 N 비트 입력 값의 합인 N 비트 출력값과 캐리를 생성 하고 여기서 생성된 N 비트 출력값과 부호값(F)을 합산값 곱셈부로 입력시킨다. 여기서, 합산값 곱셈부 로 입력되는 부호값은 표 2에 도시한 바와 같이 XOR 연산기를 이용하여 세개의 입력값에 대한 XOR 연산을 수행시킨 결과값이 (N+1) 비트 출력의 부호값(F)으로서 생성된다. 여기서, XOR 연산기에 입력되는 3개의 입력값 은 어느 한 해당 가산부(제11가산부 및 제21가산부)의 두 입력 값들의 부호들(A, B)과 해당 가산부 (제11가산부 및 제21가산부)의 8비트 덧셈연산 결과 발생하는 캐리(C)를 의미한다. 표 2 A B C F 0 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 M0/M1의 값이 1인 경우, 즉, 각 가산부(제11가산부 및 제21가산부)가 N 비트 양수 덧셈기 모드인 경 우, 각 가산부(제11가산부 및 제21가산부)는 N 비트 입력 값의 합산 결과 N 비트 출력값과 캐리를 생 성한다. 각 가산부(제11가산부 및 제21가산부)는 하위 N 비트의 덧셈을 연산하는 경우(즉, U0/U1이 1인 경우) 덧셈의 결과에 따라 생성되는 캐리를 플립플롭과 같은 저장기에 각각 저장하고 나중에 S0/S1이 1이 되는 경우 이 캐리를 가산부의 캐리 입력으로서 사용한다. 도 8에서, S0/S1, M0/M1, U0/U1와 같은 플래그 값은 가산부(제11가산부 및 제21가산부)의 정밀도 및 곱셈연산 처리 사이클에 따라 결정되며, 표 3과 같이 설정할 수 있다. S0/S1, M0/M1, U0/U1 값의 설정은 표 3에 나타낸 것에 한정되지 않고 실시예에 따라 다르게 설정될 수 있다. 표 3 N 비트 정밀도 데이터 입력시2N 비트 정밀도 데이터 입력시 N 비트 연산 처리 사이클 1 2 3 4 S0 0 0 0 1 1 S1 0 0 1 0 1 M0 0 1 1 0 0 M1 0 1 0 1 0 U0 0 1 0 0 0 U1 0 1 0 0 0 도 9는 도 5의 제1곱셈부 또는 제2곱셈부 대신에 두개의 2N 비트 입력 데이터에 대하여 N 비트 단위 로 분할하여 곱셈을 수행하기 위한 곱셈장치의 구성을 도시한 도면이다. 도 9에 도시하듯이, 제1 실시예에 따른 곱셈장치는 제1입력분할부, 제2입력분할부, 제1선택부 , 제2선택부, 제1부호확장부, 제2부호확장부, 제1곱셈부, 승수선택부 및 승수 곱셈부를 포함한다. 이하, 제1 실시예에 따른 곱셈장치가 제1곱셈부로서 적용되는 경우를 설명한다. 참고로, 본 실시예에 따른 곱셈장치는, 제1곱셈부가 N 비트 단위의 행렬 원소 입력에 대한 곱셈 연산 은 제공하지만 2N 비트 단위의 행렬 원소 입력에 대해서는 곱셈 연산을 제공하지 않는 경우, 2N 비트 단위의 행 렬 원소 입력에 대한 곱셈이 가능하도록 확장된 것을 예시한 것이다. 이하, N=8인 경우를 예로 들어 설명한다. 이하, 도 5 및 도 9를 함께 참조하면서 제1 실시예에 따른 곱셈장치의 동작을 설명한다. 제1입력분할부는 2N 비트 길이의 X 행렬 원소인 제1입력 xi,2k-1에 대하여 상위 N 비트 분할비트맵 와 하위 N 비트 분할비트맵 로 분할 출력하여 제1선택부로 입력시킨다. 제2입력분할부는 2N 비트 길이의 X 행렬 다른 원소인 제2입력 xi,2kj에 대하여 상위 N 비트 분할비트맵 와 하위 N 비트 분할비트맵 로 분할 출력하여 제2선택부로 입력시킨다. 제1선택부는 xi,2k-1에 대한 상위 분할비트맵과 하위 분할비트맵을 각각 제1입력분할부로부터 수신하여 S0의 값에 따라 선택적으로 출력한다. 예컨대, S0=0이면 제1선택부는 하위 분할비트맵을 출력하고 S0=1이 면 제1선택부는 상위 분할비트맵을 출력하여 제1부호확장부로 입력시킨다. 제2선택부는 xi,2kj에 대한 상위 분할비트맵과 하위 분할비트맵을 각각 수신하여 S1 값의 제어입력을 수신하 여 상위 분할비트맵과 하위 분할비트맵 중에서 하나를 출력한다. 예컨대, S1=0이면 제2선택부는 하위 분할 비트맵을 출력하고 S1=1이면 제2선택부는 상위 분할비트맵을 출력하여 제2부호확장부로 입력시킨다. 제1부호확장부는 M0이 0인 경우 제1부호확장부에 입력된 N 비트의 상위 분할비트맵의 부호 값을 N 비 트의 상위 분할비트맵의 앞에 추가하여 [상위 분할비트맵의 부호 값, N 비트의 상위 분할비트맵]의 형태로 (N+1) 비트 데이터를 형성하여 제1곱셈부로 입력시킨다. 만일 M0이 1인 경우 제1부호확장부는 [0, N 비트의 상위 분할비트맵]의 형태로 (N+1) 비트 데이터를 형성하여 제1곱셈부로 입력시킨다. 제2부호확장부는 M1이 0인 경우 제2부호확장부에 입력된 N 비트의 상위 분할비트맵의 부호 값을 N 비 트의 상위 분할비트맵의 앞에 추가하여 [상위 분할비트맵의 부호 값, N 비트의 상위 분할비트맵]의 형태로 (N+1) 비트 데이터를 형성하여 제1곱셈부로 입력시킨다. 만일 M1이 1인 경우 제2부호확장부는 [0, N 비트의 상위 분할비트맵]의 형태로 (N+1) 비트 데이터를 형성하여 제1곱셈부로 입력시킨다. 제1곱셈부는 제1부호확장부로부터 수신된 (N+1) 비트 데이터와 제2부호확장부로부터 수신된 (N+1) 비트 데이터를 곱하여 곱셈결과를 산출한다. 승수선택부는 제1부호확장부로부터 수신된 (N+1) 비트 데이터와 제2부호확장부로부터 수신된 (N+1) 비트 데이터에 대응하는 승수를 선택한다. 예컨대, {S0, S1} = {0, 0} 이면 1, {S0, S1} = {0, 1}이면 28, {S0, S1} = {1, 0}이면 28, {S0, S1} = {1, 1}이면 216을 승수로서 각각 선택한다. 승수 곱셈부는 제1부호확장부로부터 수신된 (N+1) 비트 데이터와 제2부호확장부로부터 수신된 (N+1) 비트 데이터를 곱한 곱셈결과에 승수선택부에서 선택된 승수를 곱하여 제1곱셈값을 산출하여 제2누 적부로 전송한다. 한편, 제1 실시예에 따른 곱셈장치가 제2곱셈부로서 적용되는 경우, 행렬 Y의 입력 원소값이 제1입력 분할부 및 제2입력분할부에 입력된 후의 동작은 행렬 X의 입력 원소값이 제1입력분할부 및 제2 입력분할부에 입력된 후의 동작과 유사하므로 더 이상의 상세한 설명은 생략한다. 도 10은 복수의 행렬 원소값을 하나의 데이터로 병합하여 행렬곱셈을 연산하는 데에 필요한 장치로서 본 실시예 에 따른 합산곱 연산장치를 도시한 도면으로서 제3누적값 연산부에서 제31가산부, 제32가산부 , 제3곱셈부 및 제3누적부의 기능을 구현한 다른 실시예이다. 이하, 도 10 및 도 11은 높은 정밀도를 지원하는 행렬곱셈 하드웨어 연산기를 기반으로 한 사이클에 여러 개의 낮은 정밀도의 데이터를 처리하는 방법을 나타낸 것이다. 본 실시예에서는 위노그라드 알고리즘을 이용하여 2N 비트 행렬 원소 2쌍을 한번에 처리하는 하드웨어 유닛을 확장하여 N 비트 행렬 원소 4쌍을 한번에 처리하는 설 계 방법을 기술한다. 도 10에서, 본 실시예에 따른 합산곱 연산장치는 복수의 전처리부(1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018), 복수의 선택부(1021, 1022, 1023, 1024, 1025), 제1가산부, 제2가산부, 제3가산부 , 곱셈부 및 누적부를 포함하며, 제3누적값 연산부(431, 432, 433, 434)는 각각 본 실시예 에 따른 합산곱 연산장치를 포함하여 구현될 수 있다. 참고로, 본 실시예에 따른 합산곱 연산장치는 N 비트 단위의 입력에 대하여 합산곱 연산을 제공하도록 형 성된 경우를 예시한 것이다. 이하, N=16인 경우를 예로 들어 설명한다. 제1전처리부는 N 비트 길이의 행렬 Y의 입력 원소값 y2k,j을 수신하여 제1 비트맵에 저장하되 제1비트맵의 (N+1)번째 비트에 N 비트 행렬 원소값 y2k,j의 부호 비트를 복사하여 부호가 확장된 N+1 비트 길이의 제1비트맵 {SignExt(y2k,j)}을 생성한다. 여기서 N이 16인 경우에 부호가 확장된 N+1 비트 길이의 제1비트맵의 길이는 17 비트가 된다. 제2전처리부는 N/2 비트 길이의 행렬 Y의 2개의 입력 원소값인 y4k,j 및 y4k-2,j을 수신하여 제2 비트맵에 저장하되 제2비트맵의 (N/2+1)번째 비트에 N/2 비트 행렬 원소값 y4k-2,j의 부호 비트를 복사 및 삽입하여 N/2+1 비트 길이의 SignExt(y4k-2,j)를 생성하여 N+1 비트 길이의 제2비트맵 {y4k,j, SignExt(y4k-2,j)}을 생성한다. 여기 서 {y4k,j, SignExt(y4k-2,j)}는 입력된 y4k,j 및 부호가 확장된 y4k-2,j인 {SignExt(y4k-2,j)} 순으로 배열된 비트맵이 다. 제3전처리부는 N 비트 길이의 행렬 X의 입력 원소값 xi,2k-1을 수신하여 제3 비트맵에 저장하되 제3비트맵 의 (N+1)번째 비트에 N 비트 행렬 원소값 xi,2k-1의 부호 비트를 복사하여 부호가 확장된 N+1 비트 길이의 제3비 트맵 {SignExt(xi,2k-1)}을 생성한다. 제4전처리부는 N/2 비트 길이의 행렬 X의 2개의 입력 원소값인 xi,4k-1 및 xi,4k-3을 수신하여 제4비트맵에 저장하되 제4비트맵의 (N/2+1)번째 비트에 N/2 비트 행렬 원소값 xi,4k-3의 부호 비트를 복사 및 삽입하여 N/2+1 비트 길이의 SignExt(xi,4k-3)를 생성하여 N+1 비트 길이의 제4비트맵 {xi,4k-1, SignExt(xi,4k-3)}을 생성한다. 여기 서 {xi,4k-1, SignExt(xi,4k-3)}는 입력된 xi,4k-1 및 부호가 확장된 xi,4k-3인 {SignExt(xi,4k-3)} 순으로 배열된 비트맵 이다. 제5전처리부는 N 비트 길이의 행렬 Y의 입력 원소값 y2k-1,j을 수신하여 제5 비트맵에 저장하되 제5비트맵 의 (N+1)번째 비트에 N 비트 행렬 원소값 y2k-1,j의 부호 비트를 복사하여 부호가 확장된 N+1 비트 길이의 제5비 트맵 {SignExt(y2k-1,j)}을 생성한다. 제6전처리부는 N/2 비트 길이의 행렬 Y의 2개의 입력 원소값인 y4k-1,j 및 y4k-3,j을 수신하여 제6 비트맵에 저장하되 제6비트맵의 (N/2+1)번째 비트에 N/2 비트 행렬 원소값 y4k-3,j의 부호 비트를 복사 및 삽입하여 N/2+1 비트 길이의 SignExt(y4k-3,j)를 생성하여 N+1 비트 길이의 제6비트맵 {y4k-1,j, SignExt(y4k-3,j)}을 생성한다. 여기 서 {y4k-1,j, SignExt(y4k-3,j)}는 y4k-1,j 및 부호가 확장된 y4k-3,j인 {SignExt(y4k-3,j)} 순으로 배열된 비트맵이다. 제7전처리부는 N 비트의 행렬 X의 입력 원소값 xi,2k을 수신하여 제7 비트맵에 저장하되 제7비트맵의 (N+1)번째 비트에 N 비트 행렬 원소값 xi,2k의 부호 비트를 복사하여 부호가 확장된 N+1 비트 길이의 제7비트맵 {SignExt(xi,2k)}을 생성한다. 제8전처리부는 N/2 비트 길이의 행렬 X의 2개의 입력 원소값인 xi,4k 및 xi,4k-2을 수신하여 제8비트맵에 저 장하되 제8비트맵의 (N/2+1)번째 비트에 N/2 비트 행렬 원소값 xi,4k-2의 부호 비트를 복사 및 삽입하여 N/2+1 비 트 길이의 SignExt(xi,4k-2)을 생성하여 N+1 비트 길이의 제8비트맵 {xi,4k, SignExt(xi,4k-2)}을 생성한다. 여기서 {xi,4k, SignExt(xi,4k-2)}는 xi,4k 및 부호가 확장된 xi,4k-2인 {SignExt(xi,4k-2)} 순으로 배열된 비트맵이다. 여기서 N이 16인 경우에 제1 내지 제8비트맵의 길이는 각각 N+1인 17 비트가 된다. 참고로, N/2 비트 모드의 행렬 원소값 입력과 관련하여, 예컨대 제4전처리부에는 {xi,1, xi,3}, {xi,5, xi,7}, {xi,9, xi,11} 순으로 행렬 원소값이 입력되고, 제8전처리부에는 {xi,2, xi,4}, {xi,6, xi,8}, {xi,10, xi,12} 순으로 행렬 원소값이 입력된다. 제1 내지 제5 선택부(1021, 1022, 1023, 1024, 1025)는 각 입력되는 S 값에 따라 동작을 달리한다. 입력되는 S 값이 0인 경우, 제1선택부는 입력되는 제1비트맵 {SignExt(y2k,j)} 및 제2비트맵 {y4k,j, SignExt(y4k-2,j)} 중에서 제1비트맵 {SignExt(y2k,j)}을 선택하여 제1가산부로 입력시킨다. 입력되는 S 값이 0인 경우, 제2선택부는 입력되는 제3비트맵 {SignExt(xi,2k-1)} 및 제4비트맵 {xi,4k-1, SignExt(xi,4k-3)} 중에서 제3비트맵 {SignExt(xi,2k-1)}을 선택하여 제1가산부로 입력시킨다. 입력되는 S 값이 0인 경우, 제3선택부는 입력되는 제5비트맵 {SignExt(y2k-1,j)} 및 제6비트맵 {y4k-1,j, SignExt(y4k-3,j)} 중에서 제5비트맵 {SignExt(y2k-1,j)}을 선택하여 제2가산부로 입력시킨다. 입력되는 S 값이 0인 경우, 제4선택부는 입력되는 제7비트맵 {SignExt(xi,2k)} 및 제8비트맵 {xi,4k, SignExt(xi,4k-2)} 중에서 제7비트맵 {SignExt(xi,2k)}을 선택하여 제2가산부로 입력시킨다. 한편, S 값이 1인 경우, 제1선택부 및 제2선택부는 각각 제2비트맵 {y4k,j, SignExt(y4k-2,j)} 및 제4 비트맵 {xi,4k-1, SignExt(xi,4k-3)}을 선택하여 제1가산부로 입력시킨다. 또한, S 값이 1인 경우, 제3선택부 및 제4선택부는 각각 제6비트맵 {y4k-1,j, SignExt(y4k-3,j)} 및 제 8비트맵 {xi,4k, SignExt(xi,4k-2)}을 선택하여 제2가산부로 입력시킨다. 이하에서 설명하는 제1가산부 및 제2가산부는 각각 듀플렉스(duplex) 덧셈기로써 구현될 수 있으며, 그 상세한 구성은 당업자에게 자명하므로 구성에 대한 상세한 설명은 생략한다. S 값이 0인 경우, 제1가산부는 제1비트맵 {SignExt(y2k,j)}과 제3비트맵 {SignExt(xi,2k-1)}을 서로 더하여 덧셈결과를 곱셈부로 입력시킨다. S 값이 0인 경우, 제2가산부는 제5비트맵 {SignExt(y2k-1,j)}과 제7비트맵 {SignExt(xi,2k)}을 서로 더하여 덧셈결과를 곱셈부로 입력시킨다. S 값이 0인 경우, 제1가산부 및 제2가산부는 N+2 비트 덧셈을 수행한다. S 값이 1인 경우, 제1가산부는 제2비트맵 {y4k,j, SignExt(y4k-2,j)} 및 제4비트맵 {xi,4k-1, SignExt(xi,4k- 3)}을 서로 더하여 덧셈결과를 곱셈부로 입력시킨다. S 값이 1인 경우, 제2가산부는 제6비트맵 {y4k-1,j, SignExt(y4k-3,j)} 및 제8비트맵 {xi,4k, SignExt(xi,4k- 2)}을 서로 더하여 덧셈결과를 곱셈부로 입력시킨다. S 값이 1인 경우, 제1가산부 및 제2가산부는 각각 두개의 입력 비트맵을 절반으로 분리하여 N/2+1 비트 덧셈을 2회 수행한다. 예컨대, 제1가산부는 제2비트맵의 상위 비트 데이터인 y4k,j과 제4비트맵의 상 위 비트 데이터인 xi,4k-1를 서로 더한 상위 비트 덧셈결과와, 제2비트맵의 하위 비트 데이터인 SignExt(y4k-2,j)과 제4비트맵의 하위 비트 데이터인 SignExt(xi,4k-3)를 서로 더한 하위 비트 덧셈결과를 곱셈부로 입력시킨다. 또한, 제2가산부는 제6비트맵의 상위 비트 데이터인 y4k-1,j와 제8비트맵의 상위 비트 데이터 인 xi,4k를 서로 더한 상위 비트 덧셈결과와, 제6비트맵의 하위 비트 데이터인 SignExt(y4k-3,j) 및 제8비트맵의 하위 비트 데이터인 SignExt(xi,4k-2)를 서로 더한 하위 비트 덧셈결과를 곱셈부로 입력시킨다. 이하에서 설명하는 곱셈부는 듀플렉스 곱셈기로써 구현될 수 있으며, 그 상세한 구성은 당업자에게 자명 하므로 구성에 대한 상세한 설명은 생략한다. S값이 0인 경우, 곱셈부는 18비트 곱셈을 수행하여 36비트 곱셈결과를 출력하여 제5선택부로 입력 시킨다. 즉, 곱셈부는, S 값이 0인 경우의 제1가산부의 덧셈결과와 S 값이 0인 경우의 제2가산부의 덧셈결과를 서로 곱하여 그 결과를 제5선택부로 입력시킨다. S값이 1인 경우, 곱셈부는 9비트 곱셈을 두번 수행하여 18비트의 곱셈결과 두개를 출력하여 제3가산부 로 입력시킨다. 예컨대, S값이 1인 경우 곱셈부는 제1가산부의 상위 비트 덧셈결과와 제2가 산부의 상위 비트 덧셈결과를 서로 곱셈한 18비트 출력인 제1결과와, 제1가산부의 하위 비트 덧셈 결과와 제2가산부의 하위 비트 덧셈결과를 서로 곱셈한 18비트 출력인 제2결과를 각각 출력하여 제3가산 부로 입력시킨다. 제3가산부는 곱셈부에서 생성된 제1결과와 제2결과를 서로 더한 결과를 제5선택부로 입력시 킨다. 제5선택부는 S값이 0인 경우, 곱셈부로부터 입력된 36비트 곱셈결과를 누적부로 출력시킨다. S값이 1인 경우, 제5선택부는 제3가산부로부터 입력된 결과를 누적부로 출력시킨다. 참고로, 제3누적값 연산부가 본 실시예에 따른 합산곱 연산장치을 포함하도록 구현될 수 있지만, 제 1전처리부, 제2전처리부, 제5전처리부, 제6전처리부, 제1선택부 및 제3선택부 는 제1누적값 연산부에 위치하도록 구현될 수도 있다. 또한, 제3전처리부, 제4전처리부, 제7전처리부, 제8전처리부, 제2선택부 및 제 4선택부는 제1행 원소값 산출부에 위치하도록 구현될 수도 있다. 도 11은 행 원소값 산출부(411, 412, 413, 414)의 제1곱셈부(511,...)와 각 제2누적값 연산부(421, 422, 423, 424)의 제2곱셈부(521, ...)로서 사용될 수 있는 제2 실시예에 따른 곱셈장치를 도시한 도면이다. 이하, 제2 실시예에 따른 곱셈장치가 행 원소값 산출부(411, 412, 413, 414)의 제1곱셈부(511,...)로서 적용되는 경우를 설명한다. 제2 실시예에 따른 곱셈장치는 복수의 전처리부(1111, 1112, 1113, 1114), 복수의 선택부(1121, 1122, 1123), 곱셈부 및 가산부를 포함한다. 제1전처리부는 N 비트 길이의 행렬 X 입력 원소값 xi,2k-1을 수신하여 제1 비트맵에 저장하되 제1비트맵의 (N+1)번째 비트에 원소값 xi,2k-1의 부호 비트를 복사하여 부호가 확장된 N+1 비트 길이의 제1비트맵 {SignExt(xi,2k-1)}을 생성한다. 제2전처리부는 N/2 비트 길이의 행렬 X의 2개의 입력 원소값인 xi,4k-1 및 xi,4k-3을 수신하여 제2 비트맵에 저장하되 제2비트맵의 (N/2+1)번째 비트에 하나의 N/2 비트 행렬 원소값 xi,4k-3의 부호 비트를 복사 및 삽입하여 N/2+1 비트 길이의 SignExt(xi,4k-3)를 생성하여 N+1 비트 길이의 제2비트맵 {xi,4k-1, SignExt(xi,4k-3)}을 생성한다. 제3전처리부는 N 비트 길이의 행렬 X의 입력 원소값 xi,2k을 수신하여 제3 비트맵에 저장하되 제3비트맵의 (N+1)번째 비트에 N 비트 행렬 원소값 xi,2k의 부호 비트를 복사하여 부호가 확장된 N+1 비트 길이의 제3비트맵 {SignExt(xi,2k)}을 생성한다. 제4전처리부는 N/2 비트의 행렬 X의 2개의 입력 원소값인 xi,4k 및 xi,4k-2을 수신하여 제4비트맵에 저장하 되 제4비트맵의 (N/2+1)번째 비트에 하나의 N/2 비트 행렬 원소값 xi,4k-2의 부호 비트를 복사 및 삽입하여 N/2+1 비트 길이의 SignExt(xi,4k-2)를 생성하여 N+1 비트 길이의 제4비트맵 {xi,4k, SignExt(xi,4k-2)}을 생성한다. 제1 내지 제3 선택부(1121, 1122, 1123)는 각 입력되는 S 값에 따라 동작을 달리한다. 입력되는 S 값이 0인 경우, 제1선택부는 입력되는 제1비트맵 {SignExt(xi,2k-1)} 및 제2비트맵 {xi,4k-1, SignExt(xi,4k-3)} 중에서 제1비트맵 {SignExt(xi,2k-1)}을 선택하여 곱셈부로 입력시킨다. 입력되는 S 값이 0인 경우, 제2선택부는 입력되는 제3비트맵 {SignExt(xi,2k)} 및 제4비트맵 {xi,4k, SignExt(xi,4k-2)} 중에서 제3비트맵 {SignExt(xi,2k)} 을 선택하여 곱셈부로 입력시킨다.한편, S 값이 1인 경우, 제1선택부 및 제2선택부는 각각 제2비트맵 {xi,4k-1, SignExt(xi,4k-3)} 및 제 4비트맵 {xi,4k, SignExt(xi,4k-2)}을 선택하여 곱셈부로 입력시킨다. 이하 설명하는 곱셈부는 듀플렉스 곱셈기로써 구현될 수 있다. 곱셈부는 듀플렉스 곱셈기로써 구현될 수 있으며, 그 상세한 구성은 당업자에게 자명하므로 구성에 대한 상세한 설명은 생략한다. 곱셈부는 S 값이 0인 경우, 각각 S=0에 해당하는 제1선택부의 선택결과 및 제2선택부의 선택 결과를 서로 곱하여 그 곱셈결과를 제3선택부로 입력시킨다. S값이 1인 경우, 곱셈부는 9비트 곱셈을 두번 수행하여 18비트의 곱셈결과 두개를 출력하여 가산부(114 0)로 입력시킨다. 즉, S값이 1인 경우 곱셈부는 제1선택부가 선택한 제2비트맵 {xi,4k-1, SignExt(xi,4k-3)}의 상위 비트 데이터 xi,4k-1 및 제2선택부가 선택한 제4비트맵 {xi,4k, SignExt(xi,4k-2)}의 상위 비트 데이터 xi,4k를 서로 곱셈한 제1결과를 생성한다. 또한, 곱셈부는 제1선택부가 선택한 제 2비트맵 {xi,4k-1, SignExt(xi,4k-3)}의 하위 비트 데이터 SignExt(xi,4k-3) 및 제2선택부가 선택한 제4비트맵 {xi,4k, SignExt(xi,4k-2)}의 하위 비트 데이터 SignExt(xi,4k-2)를 서로 곱셈한 제2결과를 생성한다. 곱셈부 는 생성된 제1결과와 제2결과를 가산부로 입력시킨다. 가산부는 곱셈부에서 생성된 제1결과와 제2결과를 서로 더한 결과를 제3선택부로 입력시킨다. 제3선택부는 S값이 0인 경우, 곱셈부로부터 입력된 곱셈결과를 누적부로 출력시킨다. S값이 1인 경우, 제3선택부는 가산부로부터 입력된 결과를 누적부로 출력시킨다. 이하, 제2 실시예에 따른 곱셈장치가 각 제2누적값 연산부(421, 422, 423, 424)의 제2곱셈부(521, ...) 로서 사용되는 경우, 제1 내지 제4 전처리부(1111, 1112, 1113, 1114)에는 아래와 같이 다른 행렬 Y의 원소값이 입력된다. 예컨대, 제1전처리부는 N 비트 길이의 행렬 Y 입력 원소값 y2k,j을 수신하여 부호가 확장된 N+1 비트 길이 의 제1비트맵 {SignExt(y2k,j)}을 생성한다. 제2전처리부는 N/2 비트 길이의 행렬 Y의 2개의 입력 원소값인 y4k,j 및 y4k-2,j을 수신하여 N+1 비트 길이 의 제2비트맵 {y4k,j, SignExt(y4k-2,j)}을 생성한다. 제3전처리부는 N 비트 길이의 행렬 Y의 입력 원소값 y2k-1,j을 수신하여 부호가 확장된 N+1 비트 길이의 제 3비트맵 {SignExt(y2k-1,j)}을 생성한다. 제4전처리부는 N/2 비트 길이의 행렬 Y의 2개의 입력 원소값인 y4k-1,j 및 y4k-3,j을 수신하여 N+1 비트 길이 의 제4비트맵 {y4k-1,j, SignExt(y4k-3,j)}을 생성한다. 한편, 제2 실시예에 따른 곱셈장치가 각 제2누적값 연산부(421, 422, 423, 424)의 제2곱셈부(521, ...) 로서 사용되는 경우, 행렬 Y의 입력 원소값이 제1 내지 제4 전처리부(1111, 1112, 1113, 1114)에 입력된 후의 동작은 행렬 X의 입력 원소값이 제1 내지 제4 전처리부(1111, 1112, 1113, 1114)에 입력된 후의 동작과 유사하 므로 더 이상의 상세한 설명은 생략한다. 이상의 설명은 본 실시예의 기술 사상을 예시적으로 설명한 것에 불과한 것으로서, 본 실시예가 속하는 기술 분 야에서 통상의 지식을 가진 자라면 본 실시예의 본질적인 특성에서 벗어나지 않는 범위에서 다양한 수정 및 변 형이 가능할 것이다. 따라서, 본 실시예들은 본 실시예의 기술 사상을 한정하기 위한 것이 아니라 설명하기 위 한 것이고, 이러한 실시예에 의하여 본 실시예의 기술 사상의 범위가 한정되는 것은 아니다. 본 실시예의 보호 범위는 아래의 청구범위에 의하여 해석되어야 하며, 그와 동등한 범위 내에 있는 모든 기술 사상은 본 실시예의 권리범위에 포함되는 것으로 해석되어야 할 것이다. 부호의 설명200: 행렬곱셈기 210: 제1연산부 211, 212, 213, 214: X원소 처리유닛 220: 제2연산부 221, 222, 223, 224: Y원소 처리유닛 230: 제3연산부 231, 232, ... , 246: Z원소 처리유닛 311: 제11저장부 312: 제12저장부 313: 제13저장부 314: 제1곱셈부 321: 제21저장부 322: 제22저장부 323: 제23저장부 324: 제2곱셈부 331: 제1가산부 332: 제2가산부 333: 제3곱셈부 334: 누적연산부 400: 연산장치 410: 원소값 산출부 411, 412, 413, 414: 행 원소값 산출부 420: 제2누적값 출력부 421, 422, 423, 424: 제2누적값 연산부 430: 제3누적값 출력부 431, 432, ..., 446: 제3누적값 연산부 501: 제2누적값 저장부 511: 제1곱셈부 512: 제1누적부 513: 제11저장부 514: 제12저장부 515: 제13저장부 516: 제14저장부 517: 제1합산부 521: 제2곱셈부 522: 제2누적부 523, 623, 624: 제2선택부 524: 제21저장부 525: 제22저장부 531: 제31가산부 532: 제32가산부 533: 제3곱셈부 534: 제3누적부 535, 635, 636: 제3선택부 800, 1000: 합산곱 연산장치 810: 입력분할부 820: 제1가산부 830: 제2가산부 840: 곱셈부 850: 누적부 900: 곱셈장치 911: 제1입력분할부 912: 제2입력분할부 913: 제1선택부 914: 제2선택부 915: 제1부호확장부 916: 제2부호확장부 917: 제1곱셈부 918: 승수선택부 919: 승수곱셈부 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018: 전처리부 1021, 1022, 1023, 1024, 1025: 선택부 1031: 제1가산부 1032: 제2가산부 1033: 제3가산부 1040: 곱셈부1050: 누적부 1100: 곱셈장치 1111, 1112, 1113, 1014: 전처리부 1121, 1122, 1123: 선택부 1130: 곱셈부 1140: 가산부 S11, S12, S13, S21, S22, S23: 누적부"}
{"patent_id": "10-2019-0077200", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 행렬 X와 Y를 곱셈하여 행렬 Z를 산출하는 행렬 곱셈을 나타낸 것이다. 도 2는 위노그라드 알고리즘 기반 행렬 곱셈을 위한 시스톨릭 배열(systolic array) 형태의 종래의 행렬곱셈기 의 구성을 예시한 도면이다. 도 3은 도 2의 제1 X원소 처리유닛, 제1 Y원소 처리유닛 및 제1 Z원소 처리유닛의 내부 구성을 나타낸 도면이다. 도 4는 본 실시예에 따른 위노그라드 알고리즘 기반 행렬 곱셈을 위한 시스톨릭 배열 형태의 연산장치의 구성을 도시한 도면이다. 도 5는 제1행 원소값 산출부, 최좌측 제2누적값 연산부 및 최상단 좌측 제3누적값 연산부의 내부 구성을 도시한 도면이다. 도 6은 제2누적값 연산부 및 최상측 제3누적값 연산부의 구성을 상세히 도시하되 도면번호는 설명에 필요한 일 부 구성요소에 대해서만 표기하고 나머지는 생략한 도면이다. 도 7은 본 실시예에 따른 합산곱 연산방법을 도시한 것으로서, 제3누적값 연산부의 기능에서 제3선택부의 기능 을 제외한 연산 방법을 데이터 흐름도로 표현한 것이다. 도 8은 본 실시예에 따른 합산곱 연산장치를 도시한 도면으로서 도 7의 데이터 흐름도를 구현한 것이다. 도 9는 도 5의 제1곱셈부 또는 제2곱셈부 대신에 두개의 16비트 입력 데이터에 대하여 8비트 단위로 분할하여 곱셈을 수행하기 위한 곱셈장치의 구성을 도시한 도면이다. 도 10은 복수의 행렬 원소값을 하나의 데이터로 병합하여 행렬곱셈을 연산하는 데에 필요한 장치로서 본 실시예 에 따른 합산곱 연산장치를 도시한 도면이다. 도 11은 행 원소값 산출부의 제1곱셈부와 각 제2누적값 연산부의 제2곱셈부에 사용될 수 있는 연산장치를 도시 한 도면이다."}
