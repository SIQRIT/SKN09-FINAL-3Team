{"patent_id": "10-2016-7032938", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2016-0146976", "출원번호": "10-2016-7032938", "발명의 명칭": "비관리 네트워크들을 통한 클래스 기반의 지능형 다중화", "출원인": "액티브비디오 네트웍스, 인코포레이티드", "발명자": "브로크만, 로날드, 에이."}}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "콘텐츠-스트림 대역폭을 적응시키는 방법으로서,가변 용량을 갖는 비관리 네트워크를 통한 전송을 위해 콘텐츠 스트림을 발생시키는 단계;상기 비관리 네트워크를 통해 상기 콘텐츠 스트림을 클라이언트 디바이스를 향하여 송신하는 단계;상기 비관리 네트워크의 용량을 모니터링하는 단계;상기 콘텐츠 스트림의 업커밍 부분(upcoming portion)의 집합 대역폭(aggregate bandwidth)이 상기 용량에 맞는지를 결정하는 단계 - 상기 콘텐츠 스트림의 업커밍 부분은 각각의 프레임 시간에 대응하고, 비디오 콘텐츠및 사용자 인터페이스 데이터를 포함함 -; 및상기 콘텐츠 스트림의 업커밍 부분의 집합 대역폭이 상기 용량에 맞지 않는다는 결정에 응답하여, 상기 콘텐츠스트림의 업커밍 부분의 크기를 감소시키는 단계를 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 감소시키는 단계는, 상기 비디오 콘텐츠의 프레임 레이트와 상기 사용자 인터페이스 데이터의 레이턴시를트레이드오프하는 단계를 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 감소시키는 단계는, 상기 비디오 콘텐츠의 품질을 유지하면서 상기 비디오 콘텐츠의 프레임 레이트를 감소시키는 단계를 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 비디오 콘텐츠의 프레임 레이트를 감소시키는 것이 상기 콘텐츠 스트림의 업커밍 부분의 집합 대역폭을 충분히 감소시키는지를 결정하는 단계; 및상기 비디오 콘텐츠의 프레임 레이트를 감소시키는 것이 상기 콘텐츠 스트림의 업커밍 부분의 집합 대역폭을 충분히 감소시키지 않는다고 결정하는 것에 응답하여, 상기 사용자 인터페이스 데이터의 프레임 레이트를 감소시키는 단계를 더 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,상기 콘텐츠 스트림의 업커밍 부분은 오디오 데이터를 더 포함하고,상기 감소시키는 단계는, 상기 업커밍 부분에 선행하는 상기 콘텐츠 스트림의 부분에서 상기 오디오 데이터를미리 송신하는 단계를 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,공개특허 10-2016-0146976-3-상기 사용자 인터페이스 데이터가 사용자 상호작용의 결과일 때, 상기 비디오 콘텐츠의 프레임 레이트를 유지하는 것에 비해 상기 사용자 인터페이스 데이터에 대한 저 레이턴시를 우선순위화하는 단계를 더 포함하고,상기 감소시키는 단계는 상기 비디오 콘텐츠의 프레임 레이트를 감소시키는 단계를 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,상기 감소시키는 단계는, 상기 업커밍 부분, 및 상기 업커밍 부분에 후속하는 상기 콘텐츠 스트림의 제2 부분에걸쳐 상기 사용자 인터페이스 데이터를 확산시키는 단계를 더 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제6항에 있어서,상기 콘텐츠 스트림의 업커밍 부분은 오디오 데이터를 더 포함하고,상기 감소시키는 단계는 상기 오디오 데이터를 영향을 받지 않은 채로 남겨두는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서,상기 사용자 인터페이스 데이터가 사용자 상호작용의 결과가 아닐 때, 상기 사용자 인터페이스 데이터에 대한레이턴시에 비해 상기 비디오 콘텐츠의 프레임 레이트를 유지하는 것을 우선순위화하는 단계를 더 포함하고,상기 감소시키는 단계는 상기 사용자 인터페이스 데이터를 지연시키는 단계를 포함하고, 상기 사용자 인터페이스 데이터는 상기 업커밍 부분 이후에 오는 상기 콘텐츠 스트림의 하나 이상의 부분에 포함되는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 업커밍 부분에서, 상기 업커밍 부분 이후에 오는 상기 콘텐츠 스트림의 각각의 부분들에 대한 하나 이상의비디오 프레임을 미리 송신하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제9항에 있어서,상기 콘텐츠 스트림의 업커밍 부분은 오디오 데이터를 더 포함하고,상기 감소시키는 단계는 상기 오디오 데이터를 영향을 받지 않은 채로 남겨두는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1항에 있어서,상기 사용자 인터페이스 데이터가 애플리케이션-타이머로 유도될 때, 상기 사용자 인터페이스 데이터에 대한 레이턴시에 비해 상기 비디오 콘텐츠의 프레임 레이트를 유지하는 것을 우선순위화하는 단계를 더 포함하고,상기 감소시키는 단계는 상기 사용자 인터페이스 데이터를 지연시키는 단계를 포함하고, 상기 사용자 인터페이스 데이터는 상기 업커밍 부분 이후에 오는 상기 콘텐츠 스트림의 하나 이상의 부분에 포함되는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서,상기 업커밍 부분에서, 상기 업커밍 부분 이후에 오는 상기 콘텐츠 스트림의 각각의 부분들에 대한 하나 이상의비디오 프레임을 미리 송신하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "공개특허 10-2016-0146976-4-제12항에 있어서,상기 콘텐츠 스트림의 업커밍 부분은 오디오 데이터를 더 포함하고,상기 감소시키는 단계는 상기 오디오 데이터를 영향을 받지 않은 채로 남겨두는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제1항에 있어서,상기 콘텐츠 스트림을 송신하는 단계는 TCP 세그먼트들의 버스트들을 송신하는 단계를 포함하고,상기 비관리 네트워크의 용량을 모니터링하는 단계는 상기 버스트들의 확인응답들을 수신하는 단계 - 상기 확인응답들은 타임스탬프들을 포함함 -, 및 상기 타임스탬프들을 이용하여 상기 비관리 네트워크의 용량을 결정하는단계를 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서,상기 타임스탬프들을 이용하여 상기 비관리 네트워크의 용량을 결정하는 단계는,상기 타임스탬프들에 따라 도달 시간들의 히스토그램을 구축하는 단계; 및상기 히스토그램으로부터 상기 용량을 도출하는 단계를 포함하는 방법."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "전자 디바이스로서,하나 이상의 프로세서; 및상기 하나 이상의 프로세서에 의해 실행되도록 구성된 하나 이상의 프로그램을 저장하는 메모리를 포함하고,상기 하나 이상의 프로그램은 제1항 내지 제16항 중 어느 한 항의 방법을 수행하기 위한 명령어들을 포함하는전자 디바이스."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "전자 디바이스에 의해 실행되도록 구성된 하나 이상의 프로그램을 저장하는 비일시적인 컴퓨터 판독가능 저장매체로서,상기 하나 이상의 프로그램은 제1항 내지 제16항 중 어느 한 항의 방법을 수행하기 위한 명령어들을 포함하는비일시적인 컴퓨터 판독가능 저장 매체."}
{"patent_id": "10-2016-7032938", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제1항 내지 제16항 중 어느 한 항의 방법을 수행하는 수단을 포함하는 전자 디바이스."}
{"patent_id": "10-2016-7032938", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "주문형 비디오 및 다른 대화식 텔레비전 서비스들을 위한 스위칭형 디지털 텔레비전 프로그래밍은 클래스 기반의 다차원 결정 로직을 이용하여 결합되어, 비관리 네트워크를 통한 시스템과의 사용자 상호작용 동안 레이턴시를 최소화하면서 동시에 비디오 품질 및 오디오 균일성을 최적화한다. 예를 들어, 콘텐츠-스트림 대역폭을 적응시 (뒷면에 계속)"}
{"patent_id": "10-2016-7032938", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시내용은 일반적으로 케이블 텔레비전 네트워크 기술에 관한 것이며, 구체적으로는 인터넷을 포함한 다양 한 네트워크 토폴로지들을 통해 전달되는 대화식 텔레비전 서비스들을 위한 적응형 및 동적 다중화 기술들에 관 한 것이다."}
{"patent_id": "10-2016-7032938", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "대화식 텔레비전 서비스들은 의미있는 방식들로 텔레비전과 상호작용하는 능력을 텔레비전 시청자에게 제공한다. 이러한 서비스들은, 예를 들어, 전자 프로그램 가이드들 및 페이-퍼-뷰(pay-per-view) 또는 다른 주 문형 프로그램 예약들 및 구매들을 구현하는데 이용되는 내비게이팅가능한 메뉴 및 주문 시스템들을 제공하기 위해 이용되어, 텔레비전 제공자에게 전화를 걸 필요성을 제거하였다. 다른 용도들은 캐릭터, 플롯 또는 배우 에 대한 추가 정보를 위해 텔레비전 프로그래밍과 상호작용하는 것, 또는 제품이나 할인 쿠폰에 대한 추가 정보 를 위해 텔레비전 광고들과 상호작용하는 것을 포함한다. 이러한 서비스들은 케이블 텔레비전 헤드엔드에서와 같이 TV 시청자로부터 원격에 위치된 서버 시스템 상에서 실행되는 소프트웨어 애플리케이션을 전형적으로 이용한다. 이러한 애플리케이션의 출력은 전형적으로 오디오- 비주얼 MPEG 전송 스트림의 형태로 시청자에게 스트리밍된다. 이것은 스트림이 텔레비전 셋톱 박스와 같이 사 실상 MPEG 디코딩 능력을 갖는 임의의 클라이언트 디바이스 상에 디스플레이되는 것을 가능하게 한다. 클라이 언트 디바이스는, 키스트로크들을 캡처하고 이들을 서버 상에서 구동되는 애플리케이션에 다시 전달하는 것에 의해, 사용자가 원격 애플리케이션과 상호작용하는 것을 허용한다. 케이블 시스템 배치들에서, 헤드엔드 서버 및 그것의 가정내 셋톱 또는 다른 클라이언트는 ATSC 또는 DVB-C와 같은 잘 알려진 프로토콜들을 이용하는 관리 디지털 케이블 TV 네트워크에 의해 분리된다. 여기서, \"관리 (managed)\"는 이러한 서비스들을 제공하는데 요구되는 임의의 대역폭 리소스들이 이용 이전에 예약될 수 있는 것을 의미한다. 일단 리소스들이 할당되면, 대역폭은 이용가능한 것으로 보증되고, 시청자가 고품질 대화식 애 플리케이션 경험을 받는 것이 보장된다. 최근에, 오디오-비주얼 가전 디바이스들은 점점 더 로컬 영역 네트워크(LAN) 접속을 지원하여, 소위 \"광대역 접 속 디바이스들(Broadband Connected Devices)\" 또는 BCD들이라고 하는 클라이언트 디바이스들의 새로운 클래스 를 야기한다. 이러한 디바이스들은 인터넷 상에서와 같이 전통적인 케이블 텔레비전 공간과는 다른 시스템들에 서 이용될 수 있다. 예를 들어, 소위 스마트 TV와 같은 클라이언트 디바이스는 오디오-비주얼 애플리케이션 스 트리밍 서버로부터 텔레비전까지 공중 데이터 네트워크를 통해 스트리밍되는 오디오-비주얼 애플리케이션들을 전달하도록 클라이언트 애플리케이션을 구현할 수 있다. 사용자는 대화식 커맨드들을 다시 애플리케이션 스트 리밍 서버로 전송하기 위해 클라이언트 디바이스와 함께 리모트 컨트롤을 이용할 수 있고, 그에 의해 원하는 콘 텐츠의 선택 및 전달을 제어하는 서버와 상호작용할 수 있다. 공중 네트워크들에서의 \"라스트 마일(last mile)\"(최종 사용자에 대한 실제 접속성을 제공하는 전기 통신 네트 워크들의 최종 레그(final leg))은 전형적으로 고용량 광섬유 네트워크들부터 비대칭 디지털 가입 라인들까지의 범위의 다수의 네트워크 기술로 구성된다. 대조적으로, 가정 내부에서, 분배는 IEEE 802.11 네트워크들(일반적 으로 Wi-Fi 네트워크들로서 알려져 있음)과 같은 무선 기술들에 의해 종종 실현된다. 결과적으로, 용량(여기서, 특정 링크가 운반할 수 있는 최대 집합 대역폭(maximum aggregate bandwidth)을 의미함)은 최종 사용자들 사이에서 변하고, 수반되는 무선 기술들로 인해, 특정 최종 사용자에 대한 용량도 또한 시간에 따라 변한다. 또한, 공중 데이터 네트워크들은 사설 케이블 텔레비전 분배 시스템들과 동일한 방식으로 관리되지는 않는다. 인터넷에 대한 가장 일반적인 전송 프로토콜인 TCP는 용량의 페어 쉐어(fair share)의 이용을 최대화 하려고 노력한다. 결과적으로, 이러한 네트워크들에서 구동하는 애플리케이션들에 대한 특정 양의 대역폭을 보 증하는 것은 불가능하다. 가변 용량 및 이용가능한 대역폭(즉, 아직 이용 중이지 않은 용량) 상태들의 네트워크를 통해 비디오를 전송하 는 복잡성은 성공적으로 처리되었던 알려진 과제이다. 가변 용량 및 이용가능한 대역폭(즉, 아직 이용 중이지 않은 용량)을 갖는 네트워크를 통해 비디오를 전송하는 시스템들의 예들은 다음의 것들을 포함한다: 1. 비디오 회의 통화 시스템들, 2. 클라우드 게임 서비스들, 3. HLS(HTTP Live Streaming), 및 4. 프로그레시브 다운로드 주문형 비디오(progressive download video-on-demand). 비디오 회의 통화 시스템들 및 클라우드 게임 서비스들은 연속적인 저 지연 비디오 신호가 실시간으로 인코딩되 는 타입의 시스템을 나타낸다. 인코딩된 스트림은 픽처 품질을 변경함으로써 변경되는 네트워크 상태들에 적응 하는데, 여기서 (전형적으로 픽처를 나타내는 계수들의 더 높은 평균 양자화에 의해 실현되는) 더 낮은 픽처 품 질은 더 낮은 평균 비트레이트를 산출한다. 전형적으로, 이러한 시스템들은 신뢰성없는 전송(예컨대, UDP 또는 RTP)을 통해 스트리밍하고, 손실을 보상하기 위해 에러 정정 및/또는 은닉 메커니즘들을 이용한다. 이러한 손 실 또는 불완전한 은닉으로 인한 임의의 아티팩트들은 신호의 연속적인 속성으로 인해 시간에 따라 정정된다.이러한 시스템들은, 이용되는 은닉 방법들의 복잡도 때문에, 그리고 서버가 네트워크 상태들에 대한 지능형 결 정을 하는 것을 허용하는 통계들의 측정 및 보고에서 클라이언트가 중요한 역할을 하기 때문에, 복잡하고 종종 사유의 클라이언트를 요구한다. 스펙트럼의 타단에는, TCP/HTTP와 같은 신뢰성있는 전송 프로토콜을 통해 오프라인 인코딩된 비실시간 스트림을 스트리밍하는 시스템들이 있다. 이러한 스트림들은 프로그레시브 다운로드되고, 여기서 버퍼링은 이용가능한 대역폭 또는 용량에서의 시간적 변동들에 대해 시스템을 강건하게 하고, 예를 들어 HLS의 경우에, 스트림은 용 량 또는 지속된 이용가능한 대역폭에 종속하여 상이한 품질 레벨로 변경된다. 이 경우, 클라이언트의 복잡도는 비교적 낮고, 클라이언트를 구성하는 컴포넌트들은 명확하다. 대화식 텔레비전 서비스는 이러한 이전에 언급된 타입의 시스템들 양쪽 모두의 특성들의 조합을 갖는다. 스트 림들은 전형적으로 UDP/RTP의 고 복잡도, 사유 클라이언트들과 연관된 저 지연, 실시간 특성들을 나타낸다. 그 러나, 스트림은 표준 컴포넌트들을 이용하는 비교적 저 복잡도 클라이언트들에 의해 수신된다. 전형적으로, 이 러한 클라이언트들은 대화식 또는 실시간 서비스들을 제공하는 클라이언트들보다는 TCP/HTTP를 이용하는 프로그 레시브 다운로드 클라이언트들과 더 유사하다. 대화식 텔레비전 서비스는, 평활한 비중단 플레이아웃(smooth and uninterrupted play out)을 요구하는 풀 모션 비디오 및 오디오를 갖는 부분들과 결합되는, 대화성(interactivity)에 대한 저 레이턴시, 무아티팩트 업데이트 들을 요구하는 그래픽 사용자 인터페이스(GUI)를 갖는 비교적 정적 부분들을 또한 갖는다. 종래의 시스템들은 이러한 요건들의 조합을 적절하게 용이하게 하지 못한다. 그러므로, 새로운 접근법이 필요 하다. 케이블 텔레비전 시스템과 같은 관리 네트워크를 통한 디지털 텔레비전은 다수의 프로그램 스트림을 운반하기 위해 일정한 대역폭 채널들을 이용한다. 대역폭의 고정 할당 내에서의 다중화는 다중화기 제어기가 경쟁하는 프로그램 스트림들 또는 경쟁하는 세션들의 그룹 사이의 대역폭의 할당을 관리하는 것을 요구한다. 이러한 방 식으로, 개별적인 프로그램 스트림 또는 세션은 프로그램 스트림들 또는 세션들의 그룹에서의 나머지 프로그램 스트림들 또는 세션들과 대역폭에 대하여 경쟁한다. 다중화기 제어기에서의 제어 로직은, 품질에 있어서 가능 한 한 적은 손상들이 요구되고 이러한 손상들이 그룹 사이에 고르게 분배되도록 프로그램 스트림들 사이의 바이 트 할당을 관리한다. 관리 네트워크들은 대부분의 상용 텔레비전 프로그램 분배 네트워크들을 형성한다. 그러나, 비디오 프로그램 소비는 비관리 네트워크인 인터넷을 통한 라이브 및 주문형 소비 양쪽 모두로 급속하게 이동하고 있다. 오늘날, 프라임타임에서의 모든 인터넷 데이터 트래픽의 완전히 1/3은 인기있는 인터넷 비디오 서비스인 Netflix로부터의 것이다. 가까운 미래에, 모든 인터넷 트래픽의 80% 초과는 비디오 데이터일 것이다. 인터넷과 같은 비관리 네트워크 상에서, 단일 프로그램 스트림(또는 세션)은 다중화기가 제어하지 않는 다수의 다른 알려지지 않은 스트림과 대역폭에 대하여 경쟁한다. 본 명세서에 설명된 시스템들 및 방법들의 많은 이점 들 중 하나는, 비관리 네트워크들을 통해 비디오 정보를 송신하는 것을 제어하고, 대화식 및 주문형 텔레비전 프로그래밍에 대한 대화식 사용자 경험을 최적화하는 클래스 기반의 다차원 제어 로직을 이용할 수 있는 다중화 기 제어기이다. 대화식 텔레비전 서비스들은, 많은 가능한 용도들 중에서, 특정 텔레비전 프로그래밍을 선택하는 목적, 이 프로 그래밍에 대한 추가 정보를 요청하는 목적 또는 오퍼들에 응답하는 목적을 위해, 텔레비전과 상호작용하는 능력 을 시청자에게 제공한다. 이러한 서비스들은, 예를 들어, 전자 프로그램 가이드들, 및 주문형 및 페이-퍼-뷰 프로그램 예약들을 구현하는데 이용되는 내비게이팅가능한 메뉴 및 주문 시스템들을 제공하기 위해 이용되었다. 이러한 서비스들은 시청자로부터 원격에 위치된 서버 상에서 실행되는 애플리케이션을 전형적으로 이용한다. 이러한 서버들은 예를 들어 케이블 텔레비전 헤드엔드에 위치할 수 있다. 이 서버 상에서 구동되는 소프트웨어 애플리케이션의 출력은 전형적으로 오디오-비주얼 MPEG 전송 스트림의 형태로 시청자에게 스트리밍된다. 이것 은, \"스마트\" 텔레비전, 텔레비전 셋톱 박스, 게임 콘솔, 및 다양한 네트워크 접속된 가전 디바이스들 및 모바 일 디바이스들을 포함하여, 사실상 MPEG 디코딩 능력을 갖는 임의의 클라이언트 디바이스 상에 스트림이 디스플 레이되는 것을 가능하게 한다. 클라이언트 디바이스는, 키스트로크들을 캡처하고 이러한 키스트로크들을 네트 워크 접속을 통해 소프트웨어 애플리케이션에 전달하는 것에 의해, 사용자가 원격 애플리케이션과 상호작용하는것을 가능하게 한다. 대화식 텔레비전 서비스는 전술한 타입의 시스템들(즉, 관리 및 비관리 네트워크 토폴로지) 양쪽 모두의 특성들 을 결합한다. 이러한 서비스들은, 전형적으로 고 복잡도, 사유 클라이언트들 상의 사용자 데이터그램 프로토콜 위에서 구동하는 실시간 전송 프로토콜(UDP/RTP)과 연관된 저 지연, 지각적으로 실시간 특성들을 요구한다. 그 러나, 대화식 텔레비전 애플리케이션들에서, 스트림은 가전 그레이드 컴포넌트들을 이용하는 비교적 저 복잡도 클라이언트들에 의해 수신된다. 전형적으로, 이러한 클라이언트들은, 전형적으로 대화식 서비스들을 제공하는 클라이언트들보다는 전송 제어 프로토콜/하이퍼텍스트 전송 프로토콜(TCP/HTTP)을 이용하는 프로그레시브 다운 로드 클라이언트들과 더 유사하다. 또한, 대화식 텔레비전 서비스는, 사용자 입력에 응답하는 저 레이턴시, 무아티팩트 업데이트들을 요구하는 그 래픽 사용자 인터페이스(그래픽 UI 또는 GUI)를 나타내는 비교적 정적 이미지 부분들과, 평활한 비중단 플레이 아웃을 요구하는 연관된 오디오와 비디오를 가질 수 있는 다른 부분들의 조합이다. 종래의 다중화기들은 인터 넷 상에서의 이러한 데이터 타입들의 조합을 적절하게 용이하게 하지 못한다. 예를 들어, 인터넷을 통해 데이 터를 송신하는 기존의 시스템에 있어서, 특정 세션의 큰 사용자 인터페이스 그래픽이 특정 클라이언트로 송신될 필요가 있을 때, 예측불가능한 네트워크 정체들이 전달에 영향을 미치는 경우, 단지 하나의 예로, 이러한 시스 템들은, (이미지 품질에서의 극단적인 감소를 제외하고는) UI 그래픽을 나타내는 일시적인 큰 데이터 블록이 전 달되는 것을 다중화기 요소들이 허용하는 정도를 수정하거나 축소하는데 이용가능한 어떠한 수단도 갖지 않는다. 인터넷에 걸쳐 엄청나게 높은 개수의 세션들이 활성이면, 비디오, 오디오 및/또는 GUI 데이터에 대한 중단 가능 성은 확실하다. 종래의 시스템들이 갖는 유일한 대안은, 종종 비디오 품질에서의 극단적인 감소나 프레임 레이 트의 큰 저하, 또는 더 나쁘게는 수신 클라이언트 디바이스가 진행하기에 충분한 데이터를 버퍼링하려고 시도하 는 동안의 프로그램 자료의 중단에 대한 것이다. 본 실시예들은, 클래스 기반 자산 할당을 이용함으로써 비관리 네트워크들을 통해 수신 클라이언트 디바이스들 로 비디오 프로그래밍 및 대화식 텔레비전 서비스를 송신하는 것에 대한 이러한 일반적인 장애물들을 극복한다. 예를 들어, 비관리 네트워크에 걸친 비디오 전송에서의 개선은, 비디오 품질 및 프레임 레이트와 레이턴시를 트 레이드오프함으로써 불리한 네트워크 상태들을 관리하는데 있어서 최상의 선택을 하도록 프로그래밍되는 다차원 제어 루프 로직을 이용하여 실현된다. 오디오와 같은 중요 데이터는 패킷 손실에 대하여 최대로 보호되고, 이 는 오디오 중단이 일반적으로 비디오에서의 중단과 비교하여 매우 부적당하다는 것인 \"귀들은 깜박거리지 않는 다(the ears don't blink)\"는 것 때문에 바람직하다. 또한, 네트워크 레이턴시는 네트워크 정체의 유용한 척도들이 추정될 수 있도록 측정된다. 일부 실시예들에서, 콘텐츠-스트림 대역폭을 적응시키는 방법은, 가변 용량을 갖는 비관리 네트워크를 통한 전 송을 위해 콘텐츠 스트림을 발생시키는 단계; 비관리 네트워크를 통해 콘텐츠 스트림을 클라이언트 디바이스를 향하여 송신하는 단계; 비관리 네트워크의 용량을 모니터링하는 단계; 콘텐츠 스트림의 업커밍 부분(upcoming portion)의 집합 대역폭이 용량에 맞는지를 결정하는 단계 - 콘텐츠 스트림의 업커밍 부분은 각각의 프레임 시 간에 대응하고, 비디오 콘텐츠 및 사용자 인터페이스 데이터를 포함함 -; 및 집합 대역폭이 용량에 맞지 않는다 는 결정에 응답하여, 콘텐츠 스트림의 업커밍 부분의 크기를 감소시키는 단계를 포함한다. 일부 실시예들에서, 서버 시스템은 하나 이상의 프로세서; 및 하나 이상의 프로세서에 의해 실행되도록 구성된 하나 이상의 프로그램을 저장하는 메모리를 포함한다. 하나 이상의 프로그램은 위에서 설명된 방법을 수행하기 위한 명령어들을 포함한다. 일부 실시예들에서, 비일시적인 컴퓨터 판독가능 저장 매체는 서버 시스템의 하나 이상의 프로세서에 의해 실행되도록 구성된 하나 이상의 프로그램을 저장한다. 하나 이상의 프로그램은 위에서 설명된 방법을 수행하기 위한 명령어들을 포함한다."}
{"patent_id": "10-2016-7032938", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 실시예들에 대한 참조가 이루어질 것이며, 그것의 예들은 첨부 도면들에 예시되어 있다. 다음의 설명에 서, 다양한 설명된 실시예들에 대한 이해를 제공하기 위해서 다수의 특정 상세가 제시된다. 그러나, 다양한 설"}
{"patent_id": "10-2016-7032938", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "명된 실시예들은 이러한 특정 상세들 없이 실시될 수 있다는 점이 본 기술분야의 통상의 기술자에게 분명할 것 이다. 다른 경우에, 실시예들의 양태들을 불필요하게 모호하게 하지 않도록 잘 알려진 방법들, 절차들, 컴포넌 트들, 회로들 및 네트워크들은 상세하게 설명되지 않았다. 최근에, 오디오-비주얼 가전 디바이스들은 점점 더 로컬 영역 네트워크(LAN) 접속을 지원하여, 소위 \"광대역 접 속 디바이스들\" 또는 BCD들이라고 하는 클라이언트 디바이스들의 새로운 클래스를 야기한다. 이러한 디바이스 들은 인터넷 상에서와 같이 전통적인 케이블 텔레비전과는 다른 시스템들에서 이용될 수 있다. 예를 들어, 스 마트 TV와 같은 클라이언트 디바이스는 오디오-비주얼 애플리케이션 스트리밍 서버(애플리케이션 서버로도 지칭 됨)로부터 텔레비전까지 공중 데이터 네트워크를 통해 스트리밍되는 오디오-비주얼 애플리케이션들을 전달하도 록 클라이언트 애플리케이션을 구현할 수 있다. 사용자는 대화식 커맨드들을 다시 애플리케이션 스트리밍 서버 로 전송하기 위해 클라이언트 디바이스와 함께 리모트 컨트롤을 이용할 수 있고, 그에 의해 대화식으로 콘텐츠 를 제어할 수 있다. 비관리 네트워크를 통한 디지털 미디어의 전달에 대한 서비스 품질은 적응형 비트레이트 네트워크 다중화기를 제어하기 위해 클래스 기반 관리 스킴을 이용함으로써 최적화된다. 도 1a는 일부 실시예들에 따른 이러한 시스 템을 도시한다. 이 시스템은 비디오 트랜스코더, 애플리케이션 엔진, 컴포지터(compositor),전역적 프레임 시간 클록, 사유 TCP 컴포넌트, 비관리 다운스트림 및 업스트림 통신 채널 (예를 들어, 인터넷), 및 클라이언트 펌웨어를 포함한다. 클라이언트 펌웨어는 클라이언트 디바이스 상에서 구동한다. 비디오 트랜스코더, 애플리케이션 엔진(즉, 애플리케이션 실행 엔진), 컴포지터 , 전역적 프레임 시간 클록 및 사유 TCP 컴포넌트(즉, 스택)는 (예를 들어, 케이블 텔레비전 헤 드엔드에 있는) 서버 시스템 상에 위치된다(예를 들어, 상에서 구동된다). 컴포지터는, UI 업데이트들을 나타내는 프래그먼트들을 발생시키는 애플리케이션 엔진 및 비디오 자 산들을 합성가능한 자산들로 트랜스코딩하는 트랜스코더와 같지만 이에 제한되지는 않는 다양한 소스들로 부터의 프래그먼트들 및 비디오 스트림들을 합성한다. 업스트림 채널을 경유하여 TCP의 확인응답 메커니 즘을 통해 획득되는 사유 TCP 컴포넌트로부터의 피드백은 전역적 프레임 시간 클록을 결정하는 데 이용된다. 도 4는 일부 실시예들에 따른 도 1a의 시스템의 더 상세한 분해를 도시한다. 그것은 동일한 컴포넌트들, 즉 트 랜스코더, 애플리케이션 엔진, 컴포지터, TCP와 같은 사유 전송, 인터넷과 같은 비관리 네 트워크 및 클라이언트 펌웨어를 포함한다. 일부 실시예들에서, 도 1a의 프레임 레이트 피드백 신호 는, 전송 수신 프로세스로부터 제어 루프로 전달되는 정보로부터 컴포지터에서의 제어 루 프에 의해 도출된다. 제어 루프 및 스케줄러(또한 컴포지터에 있음)는 도 2a 또는 도 2b 의 최적화 공간 내에서 합성된 스트림을 최적화한다. 도 2a는 일부 실시예들에 따른, 오디오, 비디오 및 그래픽 사용자 인터페이스(UI) 요소들을 다중화하기 위한 결 정 경로들을 도시하는 3차원 제어 그래프이다. 각각의 차원은, 복합 사용자 스크린-앞 경험의 지각적 열화를 최소화하면서, 사용자 경험의 어느 컴포넌트들이 다른 컴포넌트들에 의한 이용을 위한 대역폭을 기여할 수 있는 지를 표시한다. 3개의 차원은 레이턴시, 프레임 레이트 및 품질이다. 따라서, 3차원 결정 로 직은 프레임 크기 대 프레임 레이트(레이턴시) 대 프레임 품질(양자화)을 조정(즉, 트레이드오프)할 수 있다. 일부 실시예들에서, 스케줄러의 제어 로직은 레이턴시에 영향을 미치는 프레임 레이트에 대한 프레임 크기의 트 레이드오프에 기초하여 결정을 하고, 또는 프레임 크기 및 프레임 품질 중 어느 하나 또는 이들의 조합에 대해 이미지 품질을 추가로 트레이드한다. 이러한 결정 로직의 도식적인 표현은, 레이턴시, 프레임 레이트 및 품질을 트레이드오프하는 다차원 제어 로직을 도시하는 도 2a에서 보여질 수 있다. 도 2b는 애 플리케이션 그룹들의 추가적인 결정 차원과 함께 위의 도 2a에서와 같은 결정 경로들을 도시하는 4차원 제 어 그래프이다. 종래의 시스템들은 비트레이트에 대해 픽처 품질을 전형적으로 트레이드하지만, 이것은 개시된 시스템에서 만족스러운 결과들을 산출하지는 않는다. 도 4의 시스템은 그래픽 사용자 인터페이스들과 비디오를 결합한다. 스크린의 사용자 인터페이스 부분들과 관련한 최종 사용자 경험은 저 레이턴시, 고 품질 및 무에러 업데이트들 로부터 이득을 얻는다. 동시에, 비디오 신호는 평활한 비중단 재생에 의해 최상으로 서빙되지만, 품질은 너무 많이 열화되어서는 안 되거나 픽처는 블로키(blocky) 또는 왜곡 상태로 된다. 최종 사용자 경험에 대한 테스트 들은, 비트 레이트에 대한 프레임 레이트 및 레이턴시(도 2a 및 도 2b)의 트레이드가 품질을 이용하 는 것보다 양호한 경험을 실제로 초래할 수 있다는 것을 나타내었다. 사유 TCP 컴포넌트로부터 수신된 통 계들은 제어 루프에 대한 입력으로서 제공된다. 이러한 통계들의 예들은 다음의 것들을 포함한다: ● 용량(C), ● 이용가능한 대역폭(A), ● 평균 델타 단방향 지연(Delta One Way Delay)(~DOWD), ● 왕복 시간(Round Trip Time)(RTT), 및 ● 손실률. 이러한 입력들에 기초하여, 제어 루프는, 애플리케이션 엔진 및 스케줄러에 대한 입력으로서 제 공되는 일시정지 신호, 최대 청크 크기 및 프레임 레이트를 계산한다. 예를 들어, 프레임 레이트는 애플리케이 션 엔진에 제공되는 한편, 프레임 레이트, 최대 청크 크기 및 일시정지 신호는 스케줄러에 제공된다. 일부 실시예들에서, 애플리케이션 엔진은 가변 대역폭 상태들에 적응하기 위해 프레임 레이트를 이용한다. 2의 팩터만큼의 프레임 레이트에서의 감소는 등가 픽처 품질에 대해 비트 레이트에서의 유사한 감소를 대략 산 출한다. 애플리케이션 엔진으로부터의 프래그먼트들은 품질을 인터페이스에 걸쳐 균일하게 유지하기 위해고정된 양자화 파라미터를 이용할 수 있다. 그러므로, 애플리케이션 엔진의 출력은 일반적으로 전형적인 비디오 자산의 출력보다 더 피크형인데, 그 이유는 프래그먼트들이 레이트 제어되는 것 대신에 이러한 고정된 양자화 파라미터들을 이용할 수 있기 때문이다. 일부 실시예들에서, 트랜스코더는 품질 레벨들 대신에 상이한 프레임 레이트 특징들의 비디오 자산들을 가 질 수 있다. 비디오 자산들은 시간 전에 트랜스코딩될 수 있고, 다양한 대역폭 상태들에 대한 적응가능성은 다 수의 비트 레이트 특징으로(즉, 다수의 비트 레이트를 이용하여) 비디오 자산을 트랜스코딩함으로써 달성된다. 종래의 시스템들에서, 비트레이트에서의 감소는 비디오 프레임들을 구성하는 계수들의 양자화를 증가시킴으로써 전형적으로 달성된다. 이러한 양자화에서의 증가의 결과는, 특히 장면 전환들에서, 링잉(ringing), 컨투어링 (contouring), 포스터라이징(posterizing), 에일리어싱(aliasing), 블로키니스(blockiness) 또는 이들의 임의 의 조합으로서 일반적으로 지각되는 픽처 품질에서의 감소이다. 일부 실시예들에서, 비디오의 품질을 감소시키 고 프레임 레이트를 유지하는 것 대신에, 프레임 레이트가 감소되고 품질이 유지되어, 유사한 감소를 달성한다. 이점은, 가변 대역폭 상태들에 대해, 비디오의 품질이 상이한 프레임 레이트에서도 동일하게 유지된다는 점이다. 다른 이점은, 비디오 자산들에 대해 프레임 레이트 옵션들의 선택을 가짐으로써, 스케줄러가 비 디오 프레임 레이트에 대해 UI 레이턴시를 트레이드오프할 수 있다는 점이다. 일부 실시예들에서, 전송 컴포넌트는 TCP 시맨틱(semantics)을 갖는 UDP-유사 스트리밍 거동을 이용한다. TCP 프로토콜의 시맨틱을 이용하는 이점은, 클라이언트가 표준 TCP/HTTP 프로토콜 구현을 구동할 수 있다는 점 이다. TCP 프로토콜을 이용하는 것은 라스트 마일에서 종종 발견되는 NAT 라우터들 및 방화벽들의 더 쉬운 횡 단을 또한 허용한다. 표준 TCP의 단점은, 그것의 랜덤 백오프, 공정성 및 재전송 특성들 때문에, 그것이 실시 간, 저 지연 스트리밍에 대해 일반적으로 적합하지 않다는 점이다. 그러므로, 일부 실시예들에서, 서버 시스템 은 슬로우 스타트(slow start), 정체 윈도우 및 랜덤 백오프와 같은 전형적인 TCP 거동을 고수하지 않고, 대신 에 표준 TCP 클라이언트 구현들을 이용할 수 있을 정도로 충분한 준수(예컨대, TCP의 수신 윈도우 및 재전송 규 칙들을 따름)를 유지하면서 설명된 실시간 스트리밍 요건들에 맞는 방식으로 세그먼트들을 송신한다. 전송 컴포넌트는 송신 프로세스 및 수신 프로세스를 가질 수 있다. 송신 프로세스는 전통 적인 TCP 공정성 규칙들에 관련 없이 TCP 세그먼트들의 버스트들로서 스케줄링된 청크들을 송신하고, 수신 프로 세스로부터의 손실 표시들에 대해 TCP 프로토콜에 의해 지시되는 바와 같이 손실 세그먼트들을 재전송한다. 수신 프로세스는 송신 프로세스에 의해 송신되는 세그먼트들에 관한 타임스탬프들, 및 TCP 확인응답들(ACK들)과 선택적 확인응답들(SACK들)을 처리한다. RFC 1323은 TCP 타임스탬프들을 설명한다. 표준 TCP 구현들에서, TCP 타임스탬프들은 PAWS(Protection Against Wrapped Sequence numbers)로서 알려진 알 고리즘에서 이용된다. PAWS는, 전형적으로 매우 고 대역폭/지연 생성물을 갖는 네트워크들에서, TCP 윈도우 크 기가 시퀀스 번호들의 가능한 개수를 초과할 때 이용된다. 일부 실시예들에서, 타임스탬프들은, 버스트 전송 기간(burst transmission timespan)이 클라이언트측 수신 기간과 비교될 수 있다는 사실을 레버리징함으로써 서 버측 링크의 용량 및 이용가능한 대역폭을 결정하기 위해 이용된다. 종래의 시스템들은, 링크의 용량을 도출하 기 위해 이러한 델타 단방향 지연들을 이용하고, 버스트에서의 세그먼트들의 정확한 타이밍을 변화시킴으로써, 이용가능한 대역폭을 근사화하는 알고리즘들을 갖는다. 세션의 시작에서만 이러한 통계들을 결정하기 위해 특 별 프로브 데이터를 이용하는 것 대신에, 서버 시스템은, TCP 패킷들의 버스트로부터 클라이언트로의 리턴 TCP ACK들의 타임스탬프들을 판독하는 것에 의해 링크의 용량 및 이용가능한 대역폭에서의 변경들을 연속적으로 측 정하기 위해 오디오 및 비디오 데이터 자체를 이용한다. 리턴 ACK들의 이러한 측정은 네트워크 레이턴시 및 정 체를 결정하는 수단을 제공하여, 이용가능한 대역폭의 더 정확한 이용을 허용한다. 패킷 손실이 순방향 에러 정정 또는 재전송들과 같은 표준 메커니즘들에 의해 핸들링되는 것을 가정하여, TCP 대신에 표준 UDP의 상부에서 동일한 메커니즘들이 구현될 수 있다. 비관리 네트워크(예를 들어, 인터넷)는, 설명된 시스템이 작동하도록 설계되는 환경이다. 이러한 네트워 크는, 큐들과 연관된 특성들을 갖는 복수의 다운스트림 네트워크 및 큐들과 연관된 특성들을 갖는 업스트 림 네트워크에 의해 대표된다. 다운스트림 및 업스트림 네트워크들은 일반적으로 용량, 이용가능한 대역 폭 및 레이턴시 특성들과 관련하여 비대칭이다. 개시된 시스템은, 가변 레이턴시, 손실 및 재순서화가 발생할 것으로 가정되는 것 외에, 비관리 네트워크의 특성들에 대한 사전 지식이 없다고 가정한다. Wi-Fi 링크들과 같 은 일부 링크들은 모든 접속성의 일시적인 손실을 또한 나타낼 수 있다. 클라이언트 펌웨어를 구동하는 클라이언트 디바이스는 광대역 접속된 셋톱 박스, 광대역 접속된 텔레비전, 컴퓨터 또는 임의의 다른 디바이스일 수 있다. 일부 실시예들에서, 클라이언트 디바이스는 표준 TCP 클라이언트 구현, 신 클라이언트 구현 및 오디오/비디오 디코더(예를 들어, MPEG-2, H.264/MPEG-AUDIO, AC3 또는 AAC 비디오/오디오 스트림들을 디코딩할 수 있음)를 갖는다. 일부 실시예들에서, 오디오/비디오 디코더는 하드웨어 디코더이다. 전형적으로, 하드웨어 디코더들은 오 디오/비디오 데이터의 일정한 스트림에 의존하고, 버퍼 언더런들을 매우 잘 핸들링하지는 않는다. 그러므로, 신 클라이언트 구현은 도 10의 방법과 같이 언더런을 방지하기 위한 방법들을 구현할 수 있다. 도 10의 방법에서, 클라이언트는 디코딩 체인의 헬스를 유지하는데 필요한 바와 같이 하드웨어 디코더 버퍼에 널 프레임 들을 주입한다. 이러한 널 프레임들은, 기준 프레임을 변경하지 않는 매크로블록들 또는 스킵 매크로블록들로 만 구성되는 인터 또는 시간적 인코딩된 프레임들일 수 있다. 널 프레임들은 또한 일회용일 수 있고, 그에 의 해 디코더의 상태는 변경되지 않는다. 널 프레임들이 삽입된 경우, 신 클라이언트는 비디오 스트림으로부터 유 사한 널 프레임들을 나중에 제거하는 것에 의해 보상할 수 있다. 제거된 것보다 추가된 프레임들이 더 많은 기 간 동안, 클라이언트는 하드웨어 디코더의 타이밍 메커니즘을 만족되게 유지하기 위해 타임스탬프 보상 메커니 즘(예컨대, 프리젠테이션 타임스탬프들(PTS들)을 리스탬핑하는 것)을 적용해야 할 수 있다. 도 10의 방법은, 비디오 데이터가 TCP 수신 버퍼로부터 검색되는 것에서 시작한다. 비디오 데이터가 완 전한 비디오 프레임이 아닌 경우(1202-아니오), 널 프레임이 발생되어, 하드웨어 디코더 버퍼로 주입(즉, 스터핑)되고, 이 방법은 아래에 논의되는 동작으로 진행한다. 비디오 데이터가 완전한 프레임이고(1202- 예), 비-널(non-null) 또는 비-일회성(non-disposable) 프레임이 아닌 경우(1204-아니오), 오디오 및 비디오가 동기화되는지가 결정된다. 오디오 및 비디오가 동기화되지 않는 경우(1205-아니오), 이 방법은 동작 으로 리턴한다. 오디오 및 비디오가 동기화되는 경우(1205-예), 또는 비디오 데이터가 비-널 또는 비-일 회성 프레임인 경우(1204-예), PTS가 리스탬핑되고, 프레임이 디코더로 전달된다. 다음에, 이 방법은 다 음 프레임 시간에 대해 대기하고, 동작으로 리턴한다. 컴포지터는 NTSC 시스템들에 대해서는 29.97 Hz 또는 PAL 시스템들에 대해서는 25 Hz의 시스템 프레임 레 이트로 전송 스트림들을 발생시킬 수 있다. 컴포지터가 다른 프레임 레이트로 변경한다고 할 때, 그것은 변경될 수 있는 유효 프레임 레이트(effective frame rate)이다. 프레임 클록이 진행하는 레이트인 시스템 프 레임 레이트와는 대조적으로, 유효 프레임 레이트는 디스플레이가 변경되는 레이트이다. 유효 프레임 레이트가 시스템 프레임 레이트보다 더 작은 경우, 컴포지터는 디스플레이를 변경하는 데이터를 운반하는 프레임들 사이 에서 중간 널 프레임들을 출력할 수 있다. 시스템 프레임 레이트가 30 Hz이고, 유효 프레임 레이트가 15 Hz라 고 가정한다. 이 경우, 컴포지터는 다음의 프레임들, 즉 E0-N1-E2-N3-E4-N5를 출력할 수 있고, 여기서 Et는 시 스템 프레임 시간 t에서의 유효 프레임을 표시하고, Nt는 시스템 프레임 시간 t에서의 널 프레임을 표시한다. 이것은 임의의 유효 프레임 레이트(예를 들어, 10 Hz에 대해 E0-N1-N2-E3-N4-N5 및 7.5 Hz에 대해 E0-N1-N2- N3-E4-N5)로 임의로 확장될 수 있다. 클라이언트 펌웨어는 서버에 의해 지시된 바와 같이 그것이 도입한 더 조기의 널 프레임들을 보상하기 위 해 널 프레임들을 제거할 수 있다. 유효 프레임 레이트가 시스템 프레임 레이트와 동일할 때, 스트림은 제거될 수 있는 프레임들을 갖지 않을 수 있다. 그러므로, 최대 유효 프레임 레이트의 2배인 시스템 프레임 레이트를 항상 갖는 것이 유리하다. NTSC 시스템에 있어서, 시스템 프레임 레이트는 59.94 Hz일 수 있고, PAL에 있어서, 시스템 프레임 레이트는 50 Hz일 수 있지만, 트랜스코딩된 자산들의 최대 유효 프레임 레이트는 각각 29.97 Hz 또는 25 Hz이다. 최대 유효 프레임 레이트보다 더 높은 시스템 프레임 레이트를 이용하는 다른 이유는 필름 또는 시네마 레이트 로부터 시스템 프레임 레이트로 비디오 자산들을 리샘플링하는데 있어서 더 큰 자유를 허용할 수 있기 때문이다. 이에 반해, 자산들을 29.97 Hz로부터 25 Hz로 그리고 그 반대로 변환하는 것은, 시스템 프레임 레이 트가 더 높을 때 양호한 결과들을 산출할 수 있고, 프레임들은 그것의 오리지널 프레임 시간에 더 가깝게 스케 줄링될 수 있다. 본 발명의 일부 실시예들에서, 더 높은 시스템 프레임 레이트는 사용자 인터페이스 자료로부터 비디오 자료를 분리하는데 이용될 수 있다. 이것은 합성된 사용자 인터페이스 프래그먼트들에 대해서는 홀수 프레임들을 이용 하면서 인코딩된 비디오에 대해서는 짝수 프레임들을 이용함으로써(또는 그 반대로 함으로써) 서버 측에서 달성 될 수 있다. 이러한 접근법의 이점들은 감소된 합성 오버헤드, 및 사용자 인터페이스 프래그먼트들에 이용되는 프래그먼트 합성 프로세스와 호환되지 않는 인코딩 파라미터들을 비디오가 이용할 수 있다는 사실일 것이며(예 를 들어, H.264를 이용하는 실시예는 합성된 프래그먼트들에 대해 CAVLC를 이용하면서 비디오 자산들을 인코딩 하기 위해 CABAC를 이용할 수 있음), 이는 더 높은 품질의 비디오를 초래한다.본 발명의 일부 실시예들에서, 비디오 및 사용자 인터페이스 프레임들을 교호하는 개념은 대역외 비디오 자산을 검색 및 디코딩하는데 또한 이용될 수 있다. 이러한 접근법의 추가적인 이득은, 비디오 스트림에 대해, 자산의 프로그레시브 다운로드가 저 레이턴시의 서버 측 인코딩된 사용자 인터페이스들과 함께 이용될 수 있다는 것이다. 일부 실시예들에서, 사용자 인터페이스 및 비디오는 동일한 레이턴시를 공유한다. 클라이언트에 대한 추 가적인 복잡도 없이 비디오 데이터를 미리 송신하는 것은 가능하지 않다. 시스템이 비디오 데이터를 미리 송신 하는 경우, 클라이언트가 재생을 정정하기 위해 타임스탬프들을 변경하는 것이 요구될 수 있다. 그러나, 가변 링크 상태들과 관련한 허용오차는, 오디오 및 비디오가 사용자 인터페이스로부터 결합해제되고 통상의 프로그레 시브 다운로드 시스템에서와 같이 버퍼링될 수 있는 경우에 개선될 것이다. 일부 실시예들에서, 이러한 결합해제는 오디오를 미리 송신하는 것에 의해 부분적으로 달성될 수 있다. 오디오 재생에서의 불연속성은 비디오에서의 일시적인 중단들보다 훨씬 더 두드러진다. 사용자 경험은, 오디오의 수백 밀리초가 접속성에서의 일시적인 손실을 메우는데 이용가능한 경우에 상당히 향상된다. 시스템은 오디오를 미 리 송신할 수 있는데, 그 이유는 오디오 및 비디오가 타임스탬프들을 통해 동기화될 수 있기 때문이다. 클라이 언트에서, 오디오-비디오 동기화는 오디오 타임스탬프들과 비디오 타임스탬프들을 매칭함으로써 달성될 수 있다. 그러므로, 특정 양까지 오디오를 미리 송신하는 것은 문제가 없다. 이러한 방식으로, 특정 정도의 접속 성 강건성 및 연속적인 사용자 경험이 레이턴시 페널티 없이 달성되는데, 이는 그렇지 않으면 사용자에 대한 대 화식 경험을 손상시킬 것이다. 링크 접속성의 일시적인 중단의 경우에, 오디오 및 비디오는 동기화되지 않게 될 수 있는데, 그 이유는 오디오 는 재생을 유지하는 한편, 비디오 버퍼는 언더런될 수 있기 때문이다. 이러한 문제점을 완화하기 위해서, 신 클라이언트는 설명된 바와 같은 널 프레임 스터핑/제거 메커니즘을 이용할 수 있다. 오디오는 별개의 논리 또는 물리 접속을 통해 또한 미리 송신될 수 있다. 설명된 바와 같이, 컴포지터는, 이용가능한 대역폭에 대해 오디오/비디오 스트림들 및 사용자 인터페이스 를 적응시키기 위해 픽처 품질 대신에 또는 픽처 품질에 추가하여 프레임 레이트 및 레이턴시를 이용할 수 있다. 계수들의 양자화를 변경함으로써 적응시키는 것은 잘 알려져 있다. 레이턴시 및/또는 프레임 레이트를 이용한 적응가능성은 예에 의해 최상으로 설명된다. 일부 실시예들에서, 대화식 애플리케이션은 부분-스크린 비디오 스트림을 갖는 사용자 인터페이스를 포함한다. 도 5는 합성된 사용자 인터페이스, 비디오 스트림 및 오디오 스트림에 대해 요구되는 대역폭이 MaxChunkSize에 의해 표현된 바와 같은 이용가능한 대역폭에 맞는 상황을 도시한다. (MaxChunkSize는 주어진 프레임 레이트에 대해 시스템이 이용하는 바이트 단위의 최대 청크이다.) 프레임 시간 t 내지 t+3으로부터, 스 트림을 구성하는 이러한 3개의 소스에 대한 집합 대역폭은 결코 시스템 프레임 레이트에 대한 최대 청크 크기를 초과하지 않고, 어떠한 정책 결정도 이루어지지 않아야 한다. 이하, 예를 들어, t에서의 사용자 인터페이스 업데이트가 너무 커서 버짓에 맞지 않기 때문에, 집합 대역폭이 맞지 않다(즉, 최대 청크 크기를 초과한다)고 가정한다. 오디오는 전형적으로 고정 컴포넌트이고, 사용자 경험 은 비중단 오디오 재생으로부터 이득을 얻는다. 그러므로, 사용자 인터페이스 업데이트에 대한 우선권을 제공 할지 또는 비디오 스트림에 대한 우선권을 제공할지에 대한 정책 결정이 이루어져야 한다. 사용자 인터페이스 업데이트가 시스템과의 사용자 상호작용의 결과인 경우, 응답의 저 레이턴시가 비디오 프레 임 레이트를 유지하는 것보다 더 중요하다고 가정될 수 있다. 이것이 작동하는 방법의 예가 도 6에 도시되어 있다. 청크들(603 및 604)로 구성되는 사용자 인터페이스 업데이트는 t 및 t+1에 걸쳐 확산될 수 있으며, t+1 에서의 비디오 프레임은 스킵되어, 충분한 공간을 만들 수 있다. 지속된 초과신청(oversubscription)에 있어서 (예를 들어, 사용자 인터페이스가 다수의 프레임에 대해 애니메이팅할 때), 이러한 할당 스킴이 반복되어, t+2 및 t+3에서 유사한 전략을 초래할 수 있다. 오디오가 고정되기 때문에, 오디오 데이터의 스케줄링에 대해 어떠 한 변경도 이루어지지 않는다. 사용자 인터페이스 업데이트가 사용자 상호작용의 결과가 아니라, 예를 들어 애플리케이션-타이머로 유도되는 경우, 사용자가 비디오 스트림을 시청하고 있다고 가정될 수 있고, 비디오 프레임 레이트를 유지하고 사용자 인 터페이스를 지연시키는 것이 사용자 경험에 대해 이로울 수 있다. 이러한 시나리오가 도 7에 도시되어 있다. 이러한 시나리오에서, 오디오 및 제1 비디오 프레임은 이전과 같이 스케줄링된다. 그러나, t에서 사 용자 인터페이스 업데이트를 나타내는 프레임을 송신하는 것 대신에, 비디오 프레임 V1, V2 및 V2'가 미리 송신되고, 사용자 인터페이스 업데이트는, 충분한 대역폭이 완전한 업데이트를 송신하는데 이용가능할 때까지 지연된다. 이러한 전략의 간이 구현은 도 6에서와 같이 UI0(603 및 604)을 발생시킬 것이지만, 더 최적의 사용자 경험은, 프레임이 실제로 디스플레이되는 시간에 대해 t에서의 업데이트를 외삽함으로써 달성 되는데, 이 시간은 t+2일 수 있고, 따라서 이 도면은 UI2를 도시한다. 도 5 내지 도 7의 예들은, 적응 이전의 유효 프레임 레이트가 시스템 프레임 레이트와 동일하다고 가정한다. 그렇지만, 이것이 반드시 필요하지는 않고; 이용가능한 더 낮은 비디오 프레임 레이트가 존재하는 한, 모든 유 효 프레임 레이트에 대해 정책 결정이 이루어질 수 있다는 점에 유의해야 한다. 그러한 경우가 아닌 경우, 시 스템은 항상 사용자 인터페이스 그래픽 요소들을 지연시키는 옵션을 갖는다. 비디오 스트림들이 시간 전에 적어도 수개의 프레임이 트랜스코딩되었던 미리 트랜스코딩된 또는 실시간 트랜스 코딩된 비디오 자산들일 수 있기 때문에, 비디오 프레임들은 미리 송신될 수 있다. 전형적인 다중 프레임 레이 트 비디오 자산의 구조는 도 8에 도시되어 있다. 그것은 별도의 각각의 프레임 레이트들(예를 들어, 각각 최대 (full), 절반, 1/3 및 1/4)에서의 다수(예를 들어, 4개)의 비디오 스트림(801-804), 및 오디오 스트림을 포함한 다. 자산들을 트랜스코딩하고 저장하기 위한 리소스들을 절약하기 위해서, 더 낮은 프레임 레이트 자산들만이 단일 또는 제한된 개수의 순열에서 이용가능할 수 있다. 예를 들어, 절반 프레임 레이트는 단지 짝수 프레임들 에서 이용가능하고; 홀수 프레임 순열은 생략될 수 있다. 이것은, 순시적으로 하나의 프레임 레이트로부터 다 른 프레임 레이트로 스위칭하는 것이 항상 가능하지는 않다는 것을 의미한다. 예를 들어, 시간 t에서, 컴포지 터는 최대 프레임 레이트 V0-0으로부터 V1-2, V2-3 및 V3-4로 스위칭할 수 있는데, 그 이유는 이들 모두가 시 간 t에서 등가 프레임에 대한 차이를 인코딩하기 때문이다. 그러나, 시간 t+4에서, 컴포지터는 단지 최대 프레 임 레이트 또는 절반 프레임 레이트로 리턴할 수 있는데, 그 이유는 1/3 프레임 레이트는 시간 t+4 내지 t+n에 서 픽처로부터의 트랜지션을 트랜스코딩하는 프레임을 갖지 않기 때문이다. 픽처 품질을 감소시키는 것 대신에 프레임 레이트를 감소시키는 이점은, 특정 시간 t에서의 프레임들이 다소 등 가적이고; 이들이 대략 동일한 픽처를 나타낸다는 점이다. 특히 장면 전환에 있어서, 이것은 상당한 이점인데, 그 이유는 전형적으로 장면 전환에서는 블로킹 아티팩트들이 매우 분명해지기 때문이다. 이전에 언급된 바와 같이, 2만큼의 프레임 레이트에서의 감소는 등가 픽처 품질에 대해 2만큼의 비트레이트에서의 감소를 산출한다. 그렇지만, 등가 프레임들이 상이한 프레임 레이트들에 대해 동일하지 않을 수 있다는 점에 유의해야 한다. 블 록 기반 인코더 및 그것의 양자화 프로세스의 복잡성으로 인해, 정확한 픽셀 값들은 인트라 및 인터 예측 및 양 자화 프로세스의 정확한 시퀀스에 종속한다. 하나의 프레임 레이트로부터 다른 프레임 레이트로의 스위칭은, 상이한 품질의 스트림들 사이에서 스위칭할 때보다 훨씬 더 작지만, 작은 에러들을 도입할 수 있다. 이러한 작 은 에러들의 빌드업을 완화하기 위해서 적절한 인트라 리프레시 프로세스가 적용될 수 있다. 유효 프레임 레이트의 개념은 전송에 의해 또한 이용된다. 도 5 내지 도 7에서 개략 설명된 바와 같이, 하나 이상의 합성된 프레임의 데이터는 MaxChunkSize까지의 청크에서 집합되어 송신된다. MaxChunkSize는 제어 루프 컴포넌트에 의해 결정되고, 용량 또는 이용가능한 대역폭 및 프레임 레이트로부터 도출될 수 있다. MaxChunkSize를 도출하는 방법의 단순한 예가 아래에 주어진다. Bapp(초당 비트 단위)는 애플리케이션이 최대 프레임 레이트에서 작동하도록 특정되는 비트 레이트이고, 여기서 시스템 프레임 레이트는 Fs(초당 프레임 단위)라고 가정한다. 그러면, 다음의 것이 유지될 수 있다:"}
{"patent_id": "10-2016-7032938", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "이용가능한 대역폭 또는 용량이 Bapp를 초과하는 경우, 유효 프레임 레이트 Fe는 Fs와 동일할 수 있다. 또는, 시스템이 이전에 개략 설명된 이점들로부터 이득을 얻는 경우에는 Fs의 절반이다. 이용가능한 대역폭 또는 용 량이 Bapp 미만인 경우, 제어 루프는 MaxChunkSize를 축소하거나 또는 유효 프레임 레이트를 다음 이용가능한 디바이더로 변경하기로 결정할 수 있다. 일부 실시예들에서, 유효 프레임 레이트는 변경될 수 있다. 개별적인 프레임들에 대한 비트 버짓을 유지하고 프레임 레이트를 감소시키는 이점들은 픽처 품질에 대해 개략 설명되었 지만, 이러한 이점은 전송으로 또한 확장되고; 픽처 품질 대신에 프레임 레이트를 감소시킴으로써, 프레임당 평 균 데이터의 양이 가변 비트레이트들에 대해 동일하게 유지된다. 효율의 이유로, 항상 최대 TCP 세그먼트 크기 를 이용하여 청크에서 데이터를 송신하는 것이 유리하다. 전송이 세그먼트마다 통계들을 도출하기 때문에, 데 이터의 양을 감소시키는 것은 통계들이 도출될 수 있는 세그먼트들의 양을 감소시킬 것이다. 물론, 그렇지 않 으면, 세그먼트 크기가 감소된다. 통계들을 도출하기 위한 세그먼트들의 비교적 높은 개수를 유지하는 것은 중요한데, 그 이유는 클라이언트들이 제한된 TCP 타임스탬프 특성들을 가질 수 있기 때문이다. RFC 1323은 타임스탬프들이 표현되는 유닛들도 그것 의 업데이트들의 해상도도 특정하지 않는다. 테스트들은, 일반적인 타임스탬프 입도(timestamp granularity) (상이한 세그먼트들이 서로 구별될 수 있는 해상도)가 1 밀리초 내지 최대 10 밀리초의 범위라고 나타내었다. 가정으로의 전형적인 인터넷 접속에 대한 전형적인 TCP 세그먼트는 데이터의 대략 1450 바이트를 운반할 수 있 다. BCD 세션들에 대한 전형적인 Bapp 설정은 예를 들어 6 Mbps일 수 있고, 여기서 TCP 세그먼트는 대략 2 밀 리초를 차지한다. (링크의 용량은 대략 Bapp와 동일하다고 가정한다.) 10 밀리초의 타이머 입도는 대략 5개의 세그먼트와 동일시되고, 이는 임의의 유용한 통계들을 직접적으로 도출할 정도로 충분하지는 않다. 개시된 시스템에서, 전송은 도달 시간들의 히스토그램을 구축함으로써 측정들의 정확도를 증가시킨다. 클 라이언트가 10 밀리초의 타임스탬프 입도를 갖는다고 가정한다. 프레임에서의 제1 세그먼트는 제1 히스토그램 슬롯 0을 마킹한다. 임의의 후속 세그먼트들의 타임스탬프들은 이러한 제1 슬롯의 타임스탬프에 의해 감산되어, 히스토그램의 슬롯 0, 1, ..., n에 추가된다. 제1 세그먼트의 도달은 전형적으로 슬롯 타이밍과 동 기화되지 않는다는 점에 유의한다. 그러므로, 12개의 세그먼트에 대한 전형적인 히스토그램은: 0: ### 1: ###### 2: ### 3: 처럼 보일 수 있다(여기서, #은 세그먼트를 표시함). 이들과 같은 히스토그램들은 다수의 네트워크 특성 및 상태를 도출하는데 이용될 수 있으며, 이들 중 일부는 아 래에 특정된다. 세그먼트들의 출발 콘스텔레이션(departure constellation)(세그먼트들 사이의 간격들)이 충분히 밀집한 경우, 즉 세그먼트들이 최소 세그먼트간 간격들을 가지면서 버스트로서 전송된 경우, 좁은 링크, 즉 최저 용량을 갖는 링크의 용량은 최대 개수의 히트를 갖는 슬롯으로부터 도출될 수 있다. 밀집 출발 콘스텔레이션의 히스토그램의 폭이 유효 프레임 시간 내에서 예상되는 슬롯들의 개수(첫번째 및 마지 막 슬롯이 도달 콘스텔레이션(arrival constellation)에 대해 임의로 정렬되기 때문에, 초당 30 프레임에서 NTSC에 대해서는 4)를 초과하는 경우, 스트림은 용량을 초과할 수 있거나: 0: ## 1: ### 2: ### 3: ### 4: # 또는 (Wi-Fi 간섭으로 인한 레이턴시와 같은) 간헐적인 네트워크 문제들을 경험하고 있을 수 있다. 0: ### 1: ###### 2: # 3: 4: ## 히스토그램의 폭이 빈약한(lean) 경우(처음 2 슬롯만을 이용함), 시스템은 링크의 최대 용량을 이용하고 있지 않다: 0: ########### 1: # 2: 3: 4: 히스토그램 접근법은, 클라이언트가 입도를 대략 10 밀리초의 입도로 인공적으로 제한함으로써 더 양호한 타임 스탬프 입도를 허용하는 경우에도 이용될 수 있다. 예를 들어, 4 밀리초의 일반적인 입도는 8 밀리초 슬롯 시 간으로 변경될 수 있다. 입도를 인공적으로 제한하는 것은 유효 프레임 레이트들을 저하시키도록 알고리즘을 스케일링하는데 또한 이용 될 수 있다. 예를 들어, 유효 프레임 레이트가 이등분될 때, 입도도 또한 (예를 들어, 10 밀리초로부터 20 밀 리초로) 이등분될 수 있다. 이것은 유효 프레임 레이트로 알고리즘을 효과적으로 스케일링하고; 평균 데이터의 양과 세그먼트들의 개수, 픽처 품질, 히스토그램의 시맨틱 및 다른 것들을 포함한 모든 부분들은 동일하게 유지 되는 한편, 유효 프레임 레이트만이 변경된다. 그러나, 더 큰 정확도가 이용가능한 경우, 히스토그램들은 '확 대된' 히스토그램이 추가 정보를 산출하는지를 확인하기 위해 임의로 재계산될 수 있다는 점에 유의한다. 입도 가 허용되는 경우, 타임스탬프들이 또한 직접적으로 이용될 수 있다. 타임스탬프 입도가 너무 낮은 경우, 업스트림 정체에서의 변동들이 결과들을 왜곡시킬 수 있다는 단점을 갖는 대안으로서 RTT(round trip time)가 이용될 수 있다. 본 개시내용 전체에 걸쳐, 용량 및 이용가능한 대역폭에 대한 참조가 이루어졌다. 단대단 관점에서, 용량은 좁 은 대역이 운반할 수 있는 최대 집합 대역폭이고, 여기서 좁은 링크는 최저 용량을 갖는 링크이다. 동일한 관 점에서, 이용가능한 대역폭은 미이용 용량이다. 용량의 오버플로우는 회피되어야 하는 한편, 이용가능한 대역 폭의 오버플로우는 정책 결정이다. 시스템은 연속적으로 용량을 측정하고, 이 용량에 맞을 유효 프레임 레이트 를 추정한다. 밀접 이격된 TCP 세그먼트들(또는 버스트들)로서 청크들을 송신함으로써, 시스템은 용량의 쉐어 를 캡처하고 레이턴시를 최소화할 수 있다. 비수정 TCP와 같은 비관리 프로토콜들과의 공존성은, 대화식 애플 리케이션들이 강한 가변 비트 레이트(VBR) 프로파일을 갖고 MaxChunkSize를 거의 완전히 이용하지는 않는다는 사실에 의해 달성될 수 있다. 이용가능한 대역폭에 대한 임의의 추가적인 지식은 현재의 유효 프레임 레이트를 유지하거나 그것을 감소시키는 결정을 향상시킬 수 있다. 주문형 피처 파일들에 추가하여, 점점 더 많은 라이브 케이블 텔레비전 프로그래밍이 케이블 및 위성 분배에 추 가하여 인터넷으로 이동하고 있다. 인터넷 전달(비관리 네트워크 전달) 콘텐츠는 전형적으로 케이블 또는 위성 셋톱 박스의 등가물을 통해 수신된다. 이러한 타입의 수신기의 예는 동시적 스마트 TV들에 빌트인되는 처리 능 력인데, 여기서 표준 TV 튜너에 추가하여, 도 9의 시스템은 클라이언트 디바이스에 또한 구현된다. 그리고, 텔 레비전 프로그램이 수신 및 디스플레이되는 것을 선택하는 TV 튜너에 추가하여, 도 9의 시스템은 전형적으로 사 용자에 의해 스마트 TV로 다운로드되거나 제조자에 의해 설치된 서브시스템에서 구동하는 소프트웨어 프로그램 들에 의해 비관리 네트워크(인터넷)로부터 데이터 패킷들을 수신한다."}
{"patent_id": "10-2016-7032938", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "전형적으로, 네트워크 접속된 셋톱 박스들은 도 9에서 요약된 바와 같은 컴포넌트들과 유사한 컴포넌트들을 갖 는다. 비관리 네트워크는 전형적으로 데이터 버퍼를 피딩하는 네트워크 인터페이스를 통하여 TCP/IP 프로토콜을 통해 어드레싱된다. 오디오, 비디오 및 그래픽 컴포넌트들은 오디오/비디오(A/V) 디코더 를 통해 디코딩되고, 이 디코더는 그것의 출력을 그래픽 오버레이 믹서로 피딩하고, 이 믹서는 특정 의 로컬 발생된 그래픽들을 추가하고, 중앙 처리 유닛(CPU)으로 공급되고 중앙 처리 유닛과 연관된 정보에 따라 A/V 디코더로부터의 비디오 신호와 이러한 그래픽들을 결합한다. 결국, 다양한 제3자 애플리케이션 들(907, 908, 909)은 애플리케이션 프로그램 인터페이스(API)를 통해 CPU에 액세스한다. 로컬 발생 된 정보 및 수신된 프로그램 정보의 결과는 그래픽 오버레이 믹서에 의해 믹싱되고, 비디오 출력 신호 로서 비디오 디스플레이 디바이스로 출력된다. 도 3은 트랜스코드가 클라이언트 수신기와 호환되는 비디오 및 오디오를 전송 다중화기에 대한 컴포지터로 제공하는 비디오 프로그램 정보의 경로를 예시함으로써 본 발명을 예시하는데, 이 전송 다중화 기는 본 발명의 사유 TCP를 이용한다. 클라이언트는 본 발명을 통해 프로그램 자료를 이롭게 수신 및 디 스플레이하기 위해 비수정 TCP 전송 수단만을 필요로 한다. 그것은, 본 발명의 신규 수단이 비관리 네트 워크를 통한 원격 서버 수단 상의 대화식 비디오 콘텐츠 호스트의 최상의 품질 및 최저 레이턴시 전달을 위해 이용가능한 채널 대역폭을 최적으로 필링하는 것을 허용하는 303에서 감지된 네트워크 정보(정체)와 협력하는 302의 오디오, 비디오 및 그래픽 컴포넌트들의 클래스 기반 관리이다.도 1a는 일부 실시예들에 따른, 네트워크 정체를 테스트하고 그것의 영향들을 경감시키는 방법의 플로우차트이 다. 사유 TCP 스택은 프레임 시간마다의 다운스트림 패킷 트레인들(per-frame-time downstream packet trains)(즉, 버스트들)을 송신하고, 접속 품질을 결정하기 위해 결과적인 업스트림 ACK 타이밍을 이용한 다. 클래스 기반 적응형 비트 레이트 프로세스는 재생의 품질을 최적화하고 레이턴시를 최소화하기 위해 오디오, 비디오 및 그래픽 정보의 할당 결정들을 하는데 채널 정체 정보를 이용한다. 클라이언트는 서버 가 예측불가능한 채널 정체를 극복하는 것을 돕는 중요 오디오 연속성을 유지하기 위해 딥 오디오 버퍼(deep audio buffer)를 이용한다. 클라이언트는 서버가 예측불가능한 채널 정체를 극복하고 버퍼 언더런들을 회피하는 것을 돕기 위해 최대 프레임 레이트로 빈 비디오 버퍼 상에 필러 비디오 프레임들(filler video frames)을 자동으로 삽입한다. 본 명세서에 설명된 기능성은, 프로세서(예를 들어, 마이크로프로세서, 마이크로컨트롤러, 디지털 신호 프로세 서 또는 범용 컴퓨터)와 함께 이용하기 위한 컴퓨터 프로그램 로직, 프로그래머블 로직 디바이스(예를 들어, 필 드 프로그래머블 게이트 어레이(FPGA) 또는 다른 PLD)와 함께 이용하기 위한 프로그래머블 로직, 이산 컴포넌트 들, 집적 회로(예를 들어, 주문형 집적 회로(ASIC)), 또는 이들의 임의의 조합을 포함하는 임의의 다른 수단을 포함하지만 결코 이에 제한되지는 않는 많은 상이한 형태로 구현될 수 있다. 본 명세서에서 이전에 설명된 기능성의 전부 또는 일부를 구현하는 컴퓨터 프로그램 로직은, 소스 코드 형태, 컴퓨터 실행가능 형태 및 다양한 중간 형태들(예를 들어, 어셈블러, 컴파일러, 링커 또는 로케이터에 의해 발생 되는 형태들)을 포함하지만 결코 이에 제한되지는 않는 다양한 형태들로 구현될 수 있다. 소스 코드는, 다양한 운영 체제들 또는 운영 환경들과 함께 이용하기 위한 다양한 프로그래밍 언어들(예를 들어, 오브젝트 코드, 어 셈블리 언어, 또는 Fortran, C, C++, JAVA 또는 HTML과 같은 하이 레벨 언어) 중 임의의 것으로 구현된 일련의 컴퓨터 프로그램 명령어들을 포함할 수 있다. 소스 코드는 다양한 데이터 구조들 및 통신 메시지들을 정의하고 이용할 수 있다. 소스 코드는 (예를 들어, 해석기를 통해) 컴퓨터 실행가능 형태로 이루어질 수 있거나, 또는 소스 코드는 (예를 들어, 번역기, 어셈블러 또는 컴파일러를 통해) 컴퓨터 실행가능 형태로 변환될 수 있다. 컴퓨터 프로그램은, 반도체 메모리 디바이스(예를 들어, RAM, ROM, PROM, EEPROM 또는 플래시 프로그래머블 RAM), 자기 메모리 디바이스(예를 들어, 디스켓 또는 고정 디스크), 광학 메모리 디바이스(예를 들어, CD-ROM), PC 카드(예를 들어, PCMCIA 카드) 또는 다른 메모리 디바이스와 같은 유형의 저장 매체에서 영구적으로 또는 일 시적으로 임의의 형태(예를 들어, 소스 코드 형태, 컴퓨터 실행가능 형태 또는 중간 형태)로 고정될 수 있다. 컴퓨터 프로그램은, 아날로그 기술들, 디지털 기술들, 광학 기술들, 무선 기술들(예를 들어, 블루투스), 네트워 킹 기술들 및 인터네트워킹 기술들을 포함하지만 결코 이에 제한되지는 않는 다양한 통신 기술들 중 임의의 것 을 이용하여 컴퓨터로 전송가능한 신호에서 임의의 형태로 고정될 수 있다. 컴퓨터 프로그램은, 통신 시스템 (예를 들어, 인터넷 또는 월드 와이드 웹)을 통해 서버 또는 전자 게시판으로부터 분배되거나, 컴퓨터 시스템으 로(예를 들어, 시스템 ROM 또는 고정 디스크 상에) 프리로딩되거나, 또는 첨부의 인쇄된 또는 전자 문서(예를 들어, 수축 포장된 소프트웨어(shrink wrapped software))를 갖는 착탈식 저장 매체로서 임의의 형태로 분배될 수 있다. 본 명세서에서 이전에 설명된 기능성의 전부 또는 일부를 구현하는 하드웨어 로직(프로그래머블 로직 디바이스 와 함께 이용하기 위한 프로그래머블 로직을 포함함)은 전통적인 수동 방법들을 이용하여 설계될 수 있거나, 또 는 CAD(Computer Aided Design), 하드웨어 기술 언어(예를 들어, VHDL 또는 AHDL), 또는 PLD 프로그래밍 언어 (예를 들어, PALASM, ABEL 또는 CUPL)와 같은 다양한 툴들을 이용하여 전자적으로 설계, 캡처, 시뮬레이트 또는 문서화될 수 있다. 프로그래머블 로직은, 반도체 메모리 디바이스(예를 들어, RAM, ROM, PROM, EEPROM 또는 플래시 프로그래머블 RAM), 자기 메모리 디바이스(예를 들어, 디스켓 또는 고정 디스크), 광학 메모리 디바이스(예를 들어, CD-ROM) 또는 다른 메모리 디바이스와 같은 유형의 저장 매체에서 영구적으로 또는 일시적으로 고정될 수 있다. 프로그 래머블 로직은, 아날로그 기술들, 디지털 기술들, 광학 기술들, 무선 기술들(예를 들어, 블루투스), 네트워킹 기술들 및 인터네트워킹 기술들을 포함하지만 결코 이에 제한되지는 않는 다양한 통신 기술들 중 임의의 것을 이용하여 컴퓨터로 전송가능한 신호에서 고정될 수 있다. 프로그래머블 로직은, 통신 시스템(예를 들어, 인터 넷 또는 월드 와이드 웹)을 통해 서버 또는 전자 게시판으로부터 분배되거나, 컴퓨터 시스템으로(예를 들어, 시 스템 ROM 또는 고정 디스크 상에) 프리로딩되거나, 또는 첨부의 인쇄된 또는 전자 문서(예를 들어, 수축 포장된 소프트웨어)를 갖는 착탈식 저장 매체로서 분배될 수 있다. 전술한 설명은 설명의 목적으로 특정 실시예들을 참조하여 설명되었다. 그러나, 위의 예시적인 논의들은 모든 것을 망라하거나 청구항들의 범위를 개시된 정밀한 형태들로 제한하는 것으로 의도되지는 않는다. 위의 교시들 을 고려하여 많은 수정들 및 변형들이 가능하다. 실시예들은 청구항들 및 그들의 실용적인 애플리케이션들의"}
{"patent_id": "10-2016-7032938", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "기초가 되는 원리들을 최상으로 설명하기 위해 선택되었고, 그에 의해 본 기술분야의 통상의 기술자로 하여금 고려되는 특정 용도들에 적합한 다양한 수정들을 갖는 실시예들을 최상으로 이용하는 것을 가능하게 한다."}
{"patent_id": "10-2016-7032938", "section": "도면", "subsection": "도면설명", "item": 1, "content": "다양한 설명된 실시예들의 양호한 이해를 위해, 다음의 도면들과 함께 아래의 상세한 설명에 대한 참조가 이루 어져야 한다. 유사한 참조 번호들은 이러한 도면들 및 설명 전체에 걸쳐 대응하는 부분들을 지칭한다. 도 1a는 인터넷과 같은 비관리 네트워크를 통한 적응형 비트 레이트 통신들을 이용하기 위한 대화식 텔레비전 (ITV) 애플리케이션 서버, 클라이언트 디바이스 및 분배 네트워크 요소들의 일부 실시예들에 따른 개략도이다. 도 1b는 일부 실시예들에 따른, 네트워크 정체를 테스트하고, 대화식 텔레비전(ITV) 애플리케이션 서버와 상호작용하고 있는 클라이언트 디바이스에 대한 그것의 영향들을 경감시키는 방법의 일부 실시예들에 따른 플로우차 트이다. 도 2a는 일부 실시예들에 따른, 오디오, 비디오 및 그래픽 사용자 인터페이스(UI) 요소들을 다중화하기 위한 결 정 경로들을 도시하는 다차원 제어 그래프이다. 각각의 차원은, 복합 사용자 스크린-앞 경험(composite user front-of-screen experience)의 지각적 열화를 최소화하면서, 사용자 경험의 어느 컴포넌트들이 다른 컴포넌트 들에 의한 이용을 위한 대역폭을 기여할 수 있는지를 표시한다. 도 2b는 일부 실시예들에 따른, 전체 애플리케이션 그룹들의 추가적인 결정 차원과 함께 도 2a에서와 같은 결정 경로들을 도시하는 다차원 제어 그래프이다. 도 3은 서버와 클라이언트 디바이스 사이의 통신을 위해 이용되는 베이스 전송 제어 프로토콜(TCP)을 도시하는 대화식 텔레비전(ITV) 애플리케이션 서버 및 클라이언트 디바이스의 일부 실시예들에 따른 개략도이다. 서버는 개시된 사유(즉, 수정) TCP 프로토콜을 이용하는 한편, 클라이언트는 유리하게도 비수정 TCP에 의해 데이터 스 트림을 수신할 수 있다. 도 4는 분배 네트워크 요소들을 도시하는 대화식 텔레비전(ITV) 애플리케이션 서버 및 클라이언트 디바이스의 일부 실시예들에 따른 개략도이다. 도 5는 적절한 대역폭을 갖는 UI, 비디오 요소들 및 오디오위 프레임 분배를 위한 클래스 기반 할당의 시간 흐 름도이다. 도 6은 일부 실시예들에 따른, 특정 비디오 요소들의 프레임 레이트를 감소시켜 UI 및 오디오가 변경되지 않은 채로 전달되는 것을 허용함으로써 경감되는 제약된 대역폭 할당을 예시하는 클래스 기반 할당의 시간 흐름도이 다. 도 7은 일부 실시예들에 따른, 사용자 인터페이스 레이턴시를 희생하여 비디오 프레임 레이트를 유지함으로써 경감되는 제약된 대역폭 할당을 예시하는 클래스 기반 할당의 시간 흐름도이다. 도 8은 4개의 비디오 프레임 레이트로 트랜스코딩되는 비디오 스트림의 다중 프레임레이트 인코딩을 도시하며, 단지 유효 인코딩 시퀀스 트랜지션들을 나타내는 특정 트랜지션 시간들에서 하나의 프레임레이트로부터 다른 프 레임레이트로 트랜지션하는 예를 도시하는 시간 흐름도이다. 도 9는 ITV 클라이언트 애플리케이션 및 제3자 애플리케이션들을 구동하는 클라이언트 디바이스(예를 들어, 셋 톱 박스 또는 스마트 TV 호스트 시스템)의 개략도이다. 도 10은 비디오 버퍼 디코더 언더런(video buffer decoder under-run)을 방지하기 위해 비디오 디코더를 널 프 레임들로 스터핑하는 방법을 도시하는 플로우차트이다."}
