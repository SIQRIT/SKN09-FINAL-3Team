{"patent_id": "10-2023-0076305", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0175962", "출원번호": "10-2023-0076305", "발명의 명칭": "DSP 및 이를 이용한 전자 장치", "출원인": "삼성전자주식회사", "발명자": "이형우"}}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "디지털 신호 처리 장치에 있어서,연산 유닛을 이용한 레거시 연산 아키텍처를 갖는 제1 기능 유닛;메모리 셀 어레이를 이용한 인-메모리 연산 아키텍처를 갖는 제2 기능 유닛; 및상기 제1 기능 유닛 및 상기 제2 기능 유닛에 의해 이용되는 레지스터 파일을 포함하는 디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 제1 기능 유닛은상기 연산 유닛의 논리 게이트를 이용하여 레거시 연산을 수행하고,상기 제2 기능 유닛은상기 메모리 셀 어레이의 비트 셀을 이용하여 인-메모리 연산을 수행하는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 제1 기능 유닛은스칼라 연산을 수행하는 스칼라 기능 유닛 및 벡터 연산을 수행하는 벡터 기능 유닛 중 적어도 일부를포함하는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 제1 기능 유닛 및 상기 제2 기능 유닛은서로 독립적으로 명령어들을 처리하는 복수의 레인들 중 서로 다른 레인들에 속하는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,상기 디지털 신호 처리 장치는복수의 독립적인 명령어들을 패킷화하여 VLIW 패킷을 생성하는 VLIW 패킷화기를 더 포함하고,상기 제1 기능 유닛은 상기 VLIW 패킷의 일부를 처리하고,상기 제2 기능 유닛은 상기 VLIW 패킷의 다른 일부를 처리하는,디지털 신호 처리 장치.공개특허 10-2024-0175962-3-청구항 6 제1항에 있어서,상기 디지털 신호 처리 장치는상기 제2 기능 유닛과 상기 레지스터 파일 사이에 배치되고, 상기 제2 기능 유닛과 상기 레지스터 파일 사이의데이터 전달을 수행하는 버퍼 블록을 더 포함하는, 디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,상기 버퍼 블록은상기 레지스터 파일에 저장된 메모리 입력 데이터를 상기 제2 기능 유닛의 상기 메모리 셀 어레이로 전달하는입력 FIFO(first in first out) 버퍼; 및상기 제2 기능 유닛의 상기 메모리 셀 어레이를 통해 생성된 메모리 출력 데이터를 상기 레지스터 파일로 전달하는 출력 FIFO 버퍼를 포함하는, 디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제6항에 있어서,상기 레지스터 파일은상기 제1 기능 유닛에 의해 사용되는 제1 레지스터 파일; 및상기 제2 기능 유닛에 의해 사용되는 제2 레지스터 파일을 포함하고,상기 제2 레지스터 파일에 메모리 입력 데이터가 로드되면 상기 메모리 입력 데이터는 상기 버퍼 블록을 통해상기 제2 기능 유닛에 저장되는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제6항에 있어서,상기 제1 기능 유닛은 로드 명령어에 따라 상기 레지스터 파일에 메모리 입력 데이터를 로드하고,상기 레지스터 파일에 상기 메모리 입력 데이터가 로드되면 상기 메모리 입력 데이터는 상기 버퍼 블록으로 전달되고,상기 제2 기능 유닛은 팝 명령어에 따라 상기 버퍼 블록의 상기 메모리 입력 데이터를 상기 메모리 셀 어레이에저장하는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제6항에 있어서,상기 제1 기능 유닛은 로드 명령어에 따라 상기 레지스터 파일에 메모리 입력 데이터를 로드하고,상기 레지스터 파일에 상기 메모리 입력 데이터가 로드되면 상기 메모리 입력 데이터는 상기 버퍼 블록으로 전달되고,상기 제2 기능 유닛은 버퍼 모드에서 명시적인 명령어 없이 상기 버퍼 블록의 상기 메모리 입력 데이터를 상기공개특허 10-2024-0175962-4-메모리 셀 어레이에 저장하는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제6항에 있어서,상기 제2 기능 유닛의 상기 메모리 셀 어레이에 네트워크 웨이트 데이터가 저장된 상태에서 상기 제2 기능 유닛의 상기 메모리 셀 어레이에 네트워크 입력 데이터가 입력되면, 상기 제2 기능 유닛은 상기 네트워크 웨이트 데이터와 상기 네트워크 입력 데이터 간의 MAC(multiply-accumulate) 연산을 수행하여 네트워크 출력 데이터를 생성하는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,상기 제2 기능 유닛은 푸쉬 명령어에 따라 상기 메모리 셀 어레이의 네트워크 출력 데이터를 상기 버퍼 블록을통해 상기 레지스터 파일에 저장하는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1항에 있어서,상기 제1 기능 유닛 및 상기 제2 기능 유닛 중 어느 하나는 제1 연산을 수행하여 제1 연산 결과를 상기 레지스터 파일에 저장하고, 상기 제1 기능 유닛 및 제2 기능 유닛 중 나머지 하나는 상기 제1 연산 결과에 기초하여제2 연산을 수행하는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "디지털 신호 처리 장치에 있어서,복수의 독립적인 명령어들을 패킷화하여 VLIW 패킷을 생성하는 VLIW 패킷화기; 및상기 VLIW 패킷을 처리하는 복수의 레인들을 포함하고,상기 복수의 레인들은연산 유닛을 이용한 레거시 연산 아키텍처에 기초하여 상기 VLIW 패킷의 일부를 처리하는 제1 레인; 및메모리 셀 어레이를 이용한 인-메모리 연산 아키텍처에 기초하여 상기 VLIW 패킷의 다른 일부를 처리하는 제2레인을 포함하는, 디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서,상기 제1 레인의 제1 기능 유닛은상기 연산 유닛의 논리 게이트를 이용하여 레거시 연산을 수행하고,상기 제2 레인의 제2 기능 유닛은상기 메모리 셀 어레이의 비트 셀을 이용하여 인-메모리 연산을 수행하는,디지털 신호 처리 장치.공개특허 10-2024-0175962-5-청구항 16 제14항에 있어서,상기 제1 레인은 상기 레거시 연산 아키텍처를 갖는 제1 기능 유닛, 및 상기 제1 기능 유닛에 의해 사용되는 제1 레지스터 파일을 포함하고,상기 제2 레인은 상기 메모리 셀 어레이를 갖는 제2 기능 유닛, 및 상기 제2 기능 유닛에 의해 사용되는 제2 레지스터 파일을 포함하고,상기 디지털 신호 처리 장치는상기 제2 기능 유닛과 상기 제2 레지스터 파일 사이에 배치되고, 상기 제2 기능 유닛과 상기 제2 레지스터 파일사이의 데이터 전달을 수행하는 버퍼 블록을 포함하는, 디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서,상기 제2 레지스터 파일에 메모리 입력 데이터가 로드되면 상기 메모리 입력 데이터는 상기 버퍼 블록을 통해상기 제2 기능 유닛에 저장되는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제16항에 있어서,상기 제1 기능 유닛 및 상기 제2 기능 유닛 중 어느 하나는 제1 연산을 수행하여 제1 연산 결과를 상기 제1 레지스터 파일 및 상기 제2 레지스터 파일 중 어느 하나에 저장하고, 상기 제1 기능 유닛 및 제2 기능 유닛 중 나머지 하나는 상기 제1 연산 결과에 기초하여 제2 연산을 수행하는,디지털 신호 처리 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "데이터를 저장하는 메인 메모리; 및상기 데이터를 처리하는 디지털 신호 처리 장치를 포함하고,상기 디지털 신호 처리 장치는연산 유닛을 이용한 레거시 연산 아키텍처를 갖는 제1 기능 유닛;메모리 셀 어레이를 이용한 인-메모리 연산 아키텍처를 갖는 제2 기능 유닛; 및상기 제1 기능 유닛 및 상기 제2 기능 유닛에 의해 이용되는 레지스터 파일을 포함하는, 전자 장치."}
{"patent_id": "10-2023-0076305", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제19항에 있어서,상기 제2 기능 유닛과 상기 레지스터 파일 사이에 배치되고, 상기 제2 기능 유닛과 상기 레지스터 파일 사이의데이터 전달을 수행하는 버퍼 블록을 포함하는, 전자 장치."}
{"patent_id": "10-2023-0076305", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "DSP 및 이를 이용한 전자 장치가 제공된다. DSP는 연산 유닛을 이용한 레거시 연산 아키텍처를 갖는 제1 기능 유닛, 메모리 셀 어레이를 이용한 인-메모리 연산 아키텍처를 갖는 제2 기능 유닛, 및 제1 기능 유닛 및 제2 기 능 유닛에 의해 이용되는 레지스터 파일을 포함할 수 있다."}
{"patent_id": "10-2023-0076305", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "아래 실시예들은 DSP 및 이를 이용한 전자 장치에 관한 것이다."}
{"patent_id": "10-2023-0076305", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "MAC(multiply and accumulate) 연산(operation)이라고도 알려져 있는 벡터 매트릭스 곱셈 오퍼레이션은 다양한 분야에서 어플리케이션의 성능을 좌우한다. 예를 들어, 다중 레이어를 포함하는 뉴럴 네트워크(neural network)의 머신 러닝(machine learning) 및 인증 동작에 있어서, MAC 연산이 수행될 수 있다. 입력 신호는 입 력 벡터를 형성하는 것으로 간주될 수 있으며, 이미지, 바이트 스트림 또는 기타 데이터 세트에 대한 데이터일 수 있다. 입력 신호에 웨이트(weight)가 곱해지고 누적된 MAC 연산의 결과로부터 출력 벡터가 구해지고, 이 출 력 벡터는 다음 레이어에 대한 입력 벡터로 제공될 수 있다. 이와 같은 MAC 연산은 다수의 레이어에 대해 반복 되기 때문에, 뉴럴 네트워크 처리 성능은 주로 MAC 연산의 성능에 의해 결정된다. MAC 연산이 인메모리 컴퓨팅 을 통해 구현될 수 있다."}
{"patent_id": "10-2023-0076305", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시예에 따르면, 디지털 신호 처리 장치는 연산 유닛을 이용한 레거시 연산 아키텍처를 갖는 제1 기능 유닛, 메모리 셀 어레이를 이용한 인-메모리 연산 아키텍처를 갖는 제2 기능 유닛, 및 제1 기능 유닛 및 제2 기 능 유닛에 의해 이용되는 레지스터 파일을 포함한다. 일 실시예에 따르면, 디지털 신호 처리 장치는 복수의 독립적인 명령어들을 패킷화하여 VLIW 패킷을 생성하는 VLIW 패킷화기, 및 VLIW 패킷을 처리하는 복수의 레인들을 포함하고, 복수의 레인들은 연산 유닛을 이용한 레거 시 연산 아키텍처에 기초하여 VLIW 패킷의 일부를 처리하는 제1 레인, 및 메모리 셀 어레이를 이용한 인-메모리 연산 아키텍처에 기초하여 VLIW 패킷의 다른 일부를 처리하는 제2 레인을 포함한다. 일 실시예에 따르면, 전자 장치는 데이터를 저장하는 메인 메모리, 및 데이터를 처리하는 디지털 신호 처리 장 치를 포함하고, 디지털 신호 처리 장치는 연산 유닛을 이용한 레거시 연산 아키텍처를 갖는 제1 기능 유닛, 메 모리 셀 어레이를 이용한 인-메모리 연산 아키텍처를 갖는 제2 기능 유닛, 및 제1 기능 유닛 및 제2 기능 유닛 에 의해 이용되는 레지스터 파일을 포함한다."}
{"patent_id": "10-2023-0076305", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "실시예들에 대한 특정한 구조적 또는 기능적 설명들은 단지 예시를 위한 목적으로 개시된 것으로서, 다양한 형 태로 변경되어 구현될 수 있다. 따라서, 실제 구현되는 형태는 개시된 특정 실시예로만 한정되는 것이 아니며, 본 명세서의 범위는 실시예들로 설명한 기술적 사상에 포함되는 변경, 균등물, 또는 대체물을 포함한다. 제1 또는 제2 등의 용어를 다양한 구성요소들을 설명하는데 사용될 수 있지만, 이런 용어들은 하나의 구성요소 를 다른 구성요소로부터 구별하는 목적으로만 해석되어야 한다. 예를 들어, 제1 구성요소는 제2 구성요소로 명 명될 수 있고, 유사하게 제2 구성요소는 제1 구성요소로도 명명될 수 있다. 어떤 구성요소가 다른 구성요소에 \"연결되어\" 있다고 언급된 때에는, 그 다른 구성요소에 직접적으로 연결되어 있거나 또는 접속되어 있을 수도 있지만, 중간에 다른 구성요소가 존재할 수도 있다고 이해되어야 할 것이다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\" 또는 \"가지다\" 등의 용어는 설명된 특징, 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것이 존재함 으로 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부분품 또는 이들 을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 본 명세서에서, \"A 또는 B 중 적어도 하나\", 및 \"A, B, 또는 C 중 적어도 하나\"와 같은 문구들 각각은 그 문구 들 중 해당하는 문구에 함께 나열된 항목들 중 어느 하나, 또는 그들의 모든 가능한 조합을 포함할 수 있다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 해당 기술 분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가진다. 일반적으로 사용되 는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의미를 갖는 것으로 해석되어야 하며, 본 명세서에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적인 의미로 해석되지 않는다. 이하, 실시예들을 첨부된 도면들을 참조하여 상세하게 설명한다. 첨부 도면을 참조하여 설명함에 있어, 도면 부호에 관계없이 동일한 구성 요소는 동일한 참조 부호를 부여하고, 이에 대한 중복되는 설명은 생략하기로 한 다. 도 1은 일 실시예에 따른 전자 장치의 일부 구성을 나타내는 블록도다. 도 1을 참조하면, 전자 장치는 데 이터를 저장하는 메인 메모리 및 메인 메모리의 데이터를 처리하는 디지털 신호 처리 장치(digital signal processor, DSP)를 포함할 수 있다. DSP는 연산 유닛을 이용한 레거시 연산 아키텍처를 갖 는 제1 기능 유닛(function unit, FU) 및 메모리 셀 어레이를 이용한 인-메모리 연산 아키텍처를 갖는 제2 FU를 포함할 수 있다. 제2 FU는 메모리 셀 어레이를 포함할 수 있다. 메모리 셀 어레이는 메모리 장치로서 데이터를 저장하는 기능을 수행할 수 있고, 연산 장치로서 저장된 데이터에 따른 연산 결과를 도출하는 기능을 수행할 수 있다. 메모리 셀 어레이는 인메모리 컴퓨팅(in-memory computing, IMC)을 통해 MAC(multiply-accumulate) 연산을 수 행할 수 있다. IMC는 메모리 소자가 갖는 구조적 특성이나 동작 방식을 활용하여 메모리 소자에 저장된 데이터 와 메모리 소자에 대한 입력(예: 제어 신호) 간의 연산 결과를 도출하는 기술이다. 폰-노이만 아키텍처(Von Neumann architecture)에서는 연산 장치와 메모리 장치 사이의 빈번한 데이터 이동으로 인한 성능 및 전력 상의 한계가 발생할 수 있다. 여기서, 연산 장치는 프로세서에 해당할 수 있고, 메모리 장 치는 디스크 저장 장치(예: HDD(hard disk drive)), 플래쉬 메모리, DRAM(dynamic random access memory)과 같 은 대용량 저장 장치에 대응할 수 있다. IMC는 데이터가 저장된 메모리 내부에서 직접 연산을 수행하는 컴퓨터 아키텍쳐로서, 연산 장치와 메모리 장치 사이의 데이터 이동이 감소되고, 전력 효율이 증가될 수 있다. 메모리 셀 어레이에 웨이트 데이터 또는 입력 특징 데이터 중 하나가 저장된 상태에서 메모리 셀 어레이에 나머지 하나 가 입력되면 메모리 셀 어레이의 출력으로부터 MAC 연산 결과가 도출될 수 있다. 입력 특징 데이터는 간단히 입력 데이터로 부를 수 있다. 따라서, 연산 과정 동안의 데이터 전송이 최소화될 수 있다. 제2 FU는 IMC를 이용하여 MAC 연산을 수행할 수 있다. MAC 연산은 인공지능(artificial intelligence, AI) 알고리즘의 구현을 위한 연산들 중 상당 부분을 차지할 수 있다. 예를 들어, 뉴럴 네트워크 모델의 복수의레이어들의 처리는 상당 부분 MAC 연산을 통해 이루어질 수 있다. 뉴럴 네트워크 모델에서 레이어의 처리는 입 력 노드들의 입력 값들의 각각에 가중치를 곱한 결과들을 합산하는 MAC 연산을 포함할 수 있다. MAC 연산은 예 시적으로 하기 수학식 1과 같이 표현될 수 있다. 수학식 1"}
{"patent_id": "10-2023-0076305", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "수학식 1에서 Ot는 t번째 노드로의 출력, Im는 m번째 입력, Wt,m는 t번째 노드에 입력되는 m번째 입력에 대해 적 용되는 가중치를 나타낼 수 있다. Ot는 노드의 출력 또는 노드 값으로서 입력 Im와 가중치 Wt,m의 가중합 (weighted sum)으로서 산출될 수 있다. 여기서, m은 0 이상 M-1 이하의 정수, t는 0이상 T-1이하의 정수, M, T는 정수일 수 있다. M은 연산의 대상이 되는 현재 레이어의 한 노드에 연결된 이전 레이어의 노드들의 개수일 수 있고, T는 현재 레이어의 노드들의 개수일 수 있다. IMC는 아날로그 IMC 및 디지털 IMC로 구분될 수 있다. 아날로그 IMC는 MAC 연산을 전류, 전하, 또는 시간 도메 인을 포함하는 아날로그 도메인에서 수행할 수 있다. 예시적으로, 디지털 IMC는 논리 회로를 사용하여 MAC 연 산을 수행할 수 있다. 디지털 IMC는 선단 공정으로 쉽게 구현이 가능하고, 우수한 성능을 나타낼 수 있다. 일 실시예에 따르면, 제2 FU는 디지털 IMC를 수행할 수 있다. 예를 들어, 제2 FU는 복수의 트랜지스터 들(예: 6개의 트랜지스터들)을 포함하는 SRAM(static random access memory)을 가질 수 있다. 6개의 트랜지스 터로 구성된 SRAM을 6T SRAM이라고도 나타낼 수 있다. SRAM은 0 또는 1의 논리 값으로 데이터를 저장하므로, 도메인 변환 과정이 요구되지 않는다. 제2 FU의 인-메모리 연산 아키텍처는 이러한 IMC를 이용한 아키텍처에 해당할 수 있다. 제1 FU의 레 거시 연산 아키텍처는 이러한 IMC를 이용하지 않는 아키텍처에 해당할 수 있다. 레거시 연산 아키텍처는 ALU(arithmetic logical unit) 및 MAC 연산기(multiply and accumulate operator)와 같이 논리 게이트 기반의 전통적인 연산 유닛을 이용하는 아키텍처에 해당할 수 있다. 레거시 연산 아키텍처의 레거시라는 용어는 인-메 모리 연산 아키텍처와의 구분을 위한 것이다. 레거시 연산 아키텍처는 인-메모리 연산 아키텍처의 IMC를 이용 하지 않는 연산 아키텍처를 통칭할 수 있다. 제1 FU는 스칼라 연산을 스칼라 FU 및 벡터 연산을 수행하는 벡터 FU 중 적어도 일부를 포함할 수 있다. 레거시 연산 아키텍처를 이용한 연산은 레거시 연산으로 부를 수 있고, 인-메모리 연산 아키텍처를 이용한 연산은 인-메모리 연산으로 부를 수 있다. 도 1에 도시되지 않았지만, DSP는 레지스터 파일과 같은 추가 구성요소를 더 포함할 수 있다. 레지스터 파일은 제1 FU 및 제2 FU의 연산에 이용될 수 있다. 메인 메모리는 DSP의 연산에 이용되는 데이터, DSP의 연산 결과, 응용 프로그램이나 작업의 소 스 코드 등을 저장할 수 있다. 메인 메모리는 DSP의 외부에 위한 메모리들 중에 DSP에 가장 가 깝게 위치할 수 있다. 예를 들어, 메인 메모리는 DRAM(dynamic random access memory)일 수 있다. 도 2는 일 실시예에 따른 DSP의 구조를 예시적으로 나타내는 도면이다. 도 2를 참조하면, DSP는 명령어 제공 블록, FU 블록, 레지스터 파일 블록, 버퍼 블록, 및 데이터 메모리를 포함할 수 있다. 명령어 제공 블록은 명령어 메모리(instruction memory), VLIW 패킷화기(very long instruction word packetizer), 인출 유닛(fetch unit), 디코더를 포함할 수 있다. 명령어 메모리는 프로세서 명령어들을 저장할 수 있다. 프로세서 명령어들은 응용 프로그램이나 작업의 소스 코드로부터 도출될 수 있다. VLIW 패킷화기는 프로세서 명령어들을 VLIW 패킷으로 변환할 수 있다. VLIW는 복수의 명령어들을 매우 긴 명령 어 묶음(instruction bundle)으로 변환하는 기술 또는 본 기술로 생성된 명령어 묶음을 의미하며, VLIW 프로세 서(예: VLIW DSP)는 VLIW를 이용하여 명령어들을 병렬로 처리하는 프로세서 아키텍처를 의미한다. VLIW 패킷은 명령어 묶음에 해당할 수 있다. 인출 유닛은 명령어 인출을 수행할 수 있고, 디코더는 각 명령어의의미를 디코딩할 수 있다. FU 블록은 디코딩 결과에 따라 각 명령어를 처리할 수 있다. VLIW 아키텍처는 명령어 묶음을 발행(issue)할 수 있는 처리 유닛을 포함할 수 있다. 처리 유닛을 통해 명령어 묶음이 한 번에 인출될 수 있다. 명령어 묶음은 각 명령어에 따른 독립적인 연산들로 구성될 수 있다. 각 연 산에 필요한 레지스터가 독립적으로 운영될 수 있고, 각 연산은 개별 레인에서 독립적으로 실행될 수 있다. 각 연산은 예측가능한 실행 사이클 수를 가질 수 있다. 컴파일러는 각 연산의 실행 사이클 수에 기초하여 명령어 묶음을 만들 수 있다. VLIW 아키텍처는 하드웨어를 간단하게 만들 수 있다. 소프트웨어(예: 컴파일러)가 복수의 명령어들 사이의 독 립성을 미리 체크한 후, 독립성이 확인된 명령어들끼리 묶어서 명령어들을 처리하므로, 하드웨어는 묶음의 형태 로 들어오는 명령어들을 동시에 인출하고, 각 레인에 들어온 연산을 처리하는 구조로 단순화될 수 있다. 최근 컴파일러의 발전에 따라 VLIW 아키텍처의 이용 효율이 향상될 수 있는 환경이 마련되었다. 독립성을 판단 하기 좋은 조건(예: 명료한 필요 사이클, 명료한 연산의 시작과 종료, 간단한 데이터 접근 패턴)을 갖는 일정 연산들(예: 영상 처리, AI)의 경우 VLIW 아키텍처에 적합할 수 있다. DSP는 VLIW 패킷을 처리하는 복수의 레인들을 포함할 수 있다. 일 실시예에 따르면, DSP는 M+N개의 레인들을 포함할 수 있다. 레인들 중에 M개는 레거시 연산 레인일 수 있고, N개는 IMC 연산 레인일 수 있다. 각 레인은 서로 독립적으로 명령어들을 처리할 수 있다. 예를 들어, 어느 레인(예: 제m 레인의 제1 기능 유 닛)은 연산 유닛을 이용한 레거시 연산 아키텍처에 기초하여 VLIW 패킷의 일부를 처리하고, 다른 레인(예: 제n 레인의 제2 기능 유닛)은 메모리 셀 어레이를 이용한 인-메모리 연산 아키텍처에 기초하여 VLIW 패킷의 다른 일 부를 처리할 수 있다. 이때, 어느 레인과 다른 레인의 처리는 서로 독립적일 수 있다. 레거시 연산 레인들은 스칼라 FU 및 스칼라 레지스터 파일을 포함하거나, 벡터 FU 및 벡터 레지 스터 파일을 포함할 수 있다. 스칼라 FU 및 벡터 FU는 레거시 연산 아키텍처를 가질 수 있고, 레거시 FU나 제1 FU로 지칭될 수 있다. 제1 FU는 연산 유닛의 논리 게이트를 이용하여 레거시 연산을 수행할 수 있다. 스칼라 레지스터 파일 및 벡터 레지스터 파일은 제1 FU에 의해 이용될 수 있고, 레거시 레 지스터 파일이나 제1 레지스터 파일로 지칭될 수 있다. 스칼라 FU 및 벡터 레지스터 파일은 각각 스 칼라 레지스터 파일 및 벡터 레지스터 파일 모두에 접근할 수 있다. IMC FU는 인-메모리 연산 아키텍처를 가질 수 있고, 제2 FU로 지칭될 수 있다. IMC 레지스터 파일은 IMC FU에 의해 이용될 수 있고, 제2 레지스터 파일로 지칭될 수 있다. 제2 FU는 메모리 셀 어레이의 비트 셀을 이용하여 인-메모리 연산을 수행할 수 있다. 제1 FU 및 제2 FU는 서로 독립적으로 명령어들을 처리하는 복수의 레인들 중 서로 다른 레인들에 속할 수 있다. IMC FU와 레지스터 파일(예: IMC 레지스터 파일) 사이에 버퍼 블록이 배치될 수 있다. 버퍼 블 록은 IMC FU와 IMC 레지스터 파일 사이의 데이터 전달을 수행할 수 있다. 버퍼 블록은 레 지스터 파일(예: IMC 레지스터 파일)에 저장된 메모리 입력 데이터를 제2 기능 유닛(예: IMC FU의 메 모리 셀 어레이로 전달하는 입력 버퍼 및 제2 기능 유닛의 메모리 셀 어레이를 통해 생성된 메모리 출력 데이터를 레지스터 파일로 전달하는 출력 버퍼를 포함할 수 있다. 입력 버퍼 및 출력 버퍼는 FIFO(first in first out) 버퍼에 해당할 수 있다. IMC 레지스터 파일의 레지스터 용량은 제한적일 수 있다. 버퍼 블록은 IMC 레지스터 파일의 제한적인 레지스터 용량의 효율을 높일 수 있다. 또한, 버 퍼 블록은 IMC FU의 메모리 동작(예: 쓰기 동작)에 의해 발생가능한 지연의 영향을 줄이고, DSP 및 IMC 레지스터 파일의 동작 효율을 높일 수 있다. FU 블록의 연산에 이용되는 데이터 및 FU 블록의 연산 결과는 데이터 메모리에 일시적으로 저장 될 수 있다. 메인 메모리는 FU 블록의 연산에 이용되는 데이터를 데이터 메모리에 제공하거나, FU 블록의 연산 결과를 데이터 메모리로부터 수신할 수 있다. DSP는 스칼라 FU나 벡터 FU와 같은 레거시 FU가 IMC 레지스터 파일에 직접적으로 접근가능 한 추가 경로를 제공할 수 있다. 레거시 FU는 추가 경로를 통해 IMC 레지스터 파일에 데이터를 전달하거 나, IMC 레지스터 파일의 데이터를 가져올 수 있다. DSP는 IMC FU가 스칼라 레지스터 파일 이나 벡터 레지스터 파일과 같은 레거시 레지스터 파일에 직접적으로 접근가능한 추가 경로를 제공하 지 않을 수 있다. 레거시 FU가 MC 레지스터 파일에 직접적으로 접근가능한 추가 경로가 제공되고, IMC FU가 레거시 레지스터 파일에 직접적으로 접근가능한 추가 경로가 제공되지 않는 것과 같이 추가 경로가 제한적으로 제공됨에 따라 DSP의 하드웨어 복잡도가 낮아질 수 있다.도 3은 일 실시예에 따른 DSP의 일부 레인의 상세 구조를 예시적으로 나타내는 도면이다. 도 3을 참조하면, DSP는 스칼라 FU, 벡터 FU, IMC FU, 레거시 레지스터 파일, 특수 레지스터 파일 , MUX, 및 버퍼 블록을 포함할 수 있다. 스칼라 FU 및 벡터 FU는 레거시 FU에 해당할 수 있고, 입력 명령어에 따른 연산을 수행할 수 있다. 스칼라 FU는 스칼라 연산을 수행할 수 있고, 벡터 FU는 벡터 연산을 수행할 수 있다. 스칼라 연산 및 벡터 연산은 레거시 연산 아키텍처를 이용하여 수행될 수 있다. IMC FU는 MAC 연산을 수행할 수 있다. MAC 연산은 인-메모리 연산 아키텍처를 이용하여 수행될 수 있다. 레거시 레지스터 파일은 스칼라 FU의 스칼라 연산을 위한 스칼라 레지스터 파일 및 벡터 FU의 벡터 연산을 위한 벡터 레지스터 파일을 포함할 수 있다. 스칼라 레지스터 파일과 벡터 레지스터 파일은 서로 구분될 수 있다. 예를 들어, 스칼라 레지스터 파일은 스칼라 연산에 적합한 특성(예: 용량)을 가질 수 있고, 벡터 레지스터 파일은 벡터 연산에 적합한 특성을 가질 수 있다. 레거시 레지스터 파일은 복수의 레지스 터들을 포함할 수 있다. 도 3은 레거시 레지스터 파일이 16개의 레지스터들(R0 내지 R15)을 포함하는 예 시를 나타낸다. 특수 레지스터 파일은 IMC 레지스터 파일에 해당할 수 있다. 특수 레지스터 파일은 MAC 연산에 적합한 특성을 가질 수 있다. 특수 레지스터 파일은 복수의 레지스터들을 포함할 수 있다. 도 3은 특수 레지스터 파일이 4개의 레지스터들(R16 내지 R19)을 포함하는 예시를 나타낸다. 다만, 레거시 레지스터 파일 및 특수 레지스터 파일 각각이 갖는 레지스터들의 수가 도 3의 예시에 제한되는 것은 아니다. 스칼라 FU 및 벡터 FU는 레거시 레지스터 파일 및 특수 레지스터 파일을 이용하여 연산을 수행할 수 있다. 예를 들어, 스칼라 FU 및 벡터 FU는 메모리의 데이터 값들을 레거시 레지스터 파일 및/또는 특수 레지스터 파일로 로드하는 동작, 레거시 레지스터 파일 및/또는 특수 레지스터 파일의 데이터 값들을 이용한 연산을 수행하는 동작, 연산 결과를 레거시 레지스터 파일 및/또는 특 수 레지스터 파일에 저장하는 동작 등을 수행할 수 있다. MUX는 레지스터 MUX에 해당할 수 있다. MUX는 스칼라 FU 및 벡터 FU의 레거시 레지스터 파일 및 특수 레지스터 파일로의 접 근 경로를 형성할 수 있다. 버퍼 블록은 IMC FU와 특수 레지스터 파일 사이에 배치될 수 있다. 버퍼 블록은 IMC FU와 특수 레지스터 파일 사이의 데이터 전달을 수행할 수 있다. 버퍼 블록은 특수 레지스터 파일에 저장된 메모리 입력 데이터를 IMC FU의 메모리 셀 어레이로 전달하는 입력 버퍼 및 IMC FU의 메모리 셀 어레이를 통해 생성된 메모리 출력 데이터를 특수 레지스터 파일로 전달하는 출력 버 퍼를 포함할 수 있다. 메모리 출력 데이터는 메모리 입력 데이터에 기초한 인-메모리 연산의 결과물에 해 당할 수 있다. 입력 버퍼 및 출력 버퍼는 FIFO(first in first out) 버퍼에 해당할 수 있다. 도 3에 따르면, IMC FU는 복수의 행들(rows)을 포함할 수 있고, 입력 버퍼 및 출력 버퍼는 각각 복수의 컬럼들(columns)을 포함할 수 있다. 도 3에 IMC FU는 16개의 행들을 포함하는 것으로 도시되어 있 으나 이에 한정되지 않는다. IMC FU의 하나의 행, 입력 버퍼의 하나의 열, 출력 버퍼의 하나의 열, 및 특수 레지스터 파일의 하나의 레지스터는 동일한 용량을 가질 수 있다. 특수 레지스터 파일 의 제1 레지스터(예: 레지스터(R16))의 메모리 입력 데이터는 FIFO에 따라 입력 버퍼의 열들을 거쳐 IMC FU의 어느 행(예: Row 0)에 저장될 수 있다. 메모리 입력 데이터에 기초한 인-메모리 연산 결과로 메모리 출력 데이터가 생성되면 메모리 출력 데이터는 FIFO에 따라 출력 버퍼의 열들을 거쳐 특수 레지스터 파일 의 제1 레지스터 또는 다른 레지스터(예: 레지스터(R17))에 저장될 수 있다. 도 3에 IMC FU가 복수 의 행들로 관리되는 예시가 도시되어 있지만, 도 3과 달리 IMC FU는 복수의 열들로 관리될 수 있다. 스칼라 FU, 벡터 FU, 및 IMC FU는 서로 독립적으로 명령어들을 처리하는 복수의 레인들 중 서로 다른 레인들에 속할 수 있다. 도 3은 스칼라 FU는 레인 A에 속하고, 벡터 FU는 레인 B에 속하고, IMC FU는 레인 C에 속하는 예시를 나타낸다. 레거시 레지스터 파일 및 특수 레지스터 파일은 스칼라 FU, 벡터 FU, 및 IMC FU의 독립적인 연산 처리가 보장되도록 운용될 수 있다. 도 4a 및 도 4b는 일 실시예에 따른 레거시 기능 유닛을 이용하여 IMC 기능 유닛에 메모리 입력 데이터를 저장 하는 동작을 예시적으로 나타내는 도면이다. 도 4a 및 도 4b를 참조하면, DSP는 스칼라 FU, 벡터 FU, IMC FU, 레거시 레지스터 파일, 특수 레지스터 파일, MUX, 및 버퍼 블록을 포함할 수 있다. 버퍼 블록은 입력 버퍼 및 출력 버퍼를 포함할 수 있다.DSP는 스칼라 FU 및 벡터 FU와 같은 레거시 기능 유닛과 특수 레지스터 파일 간의 전송 경 로를 제공할 수 있고, 이러한 전송 경로를 통해 레거시 기능 유닛이 IMC FU에 메모리 입력 데이터를 저장 하는데 이용될 수 있다. 특수 레지스터 파일에 메모리 입력 데이터가 로드되면 메모리 입력 데이터는 버 퍼 블록을 통해 IMC FU의 메모리 셀 어레이에 저장될 수 있다. 메모리 입력 데이터는 IMC FU의 메모리 셀 어레이에 입력되는 데이터를 의미할 수 있고, 메모리 출력 데이터는 IMC FU의 메모리 셀 어레이 를 통해 생성된 데이터를 의미할 수 있다. 도 4a를 참조하면, 스칼라 FU는 로드 명령어를 실행할 수 있다. 로드 명령어는 메모리 내 데이 터(A)를 레지스터(R16)로 로드하라는 의미를 가질 수 있다. 스칼라 FU는 로드 명령어에 따라 데이터 (A)를 MUX를 통해 특수 레지스터 파일의 레지스터(R16)에 저장할 수 있다. 데이터(A)는 메모리 입력 데이터에 해당할 수 있다. 레지스터(R16)의 데이터(A)는 입력 버퍼로 전달될 수 있다. 일 실시예에 따르 면, 특수 레지스터 파일의 각 레지스터에 로드된 데이터는 입력 버퍼로 전달되도록 규칙이 정의될 수 있고, 데이터(A)는 본 규칙에 따라 레지스터(R16)로부터 입력 버퍼로 전달될 수 있다. 도 4b를 참조하면, IMC FU는 팝 명령어를 실행할 수 있다. 팝 명령어는 입력 버퍼로부터 데이터를 꺼내라는 의미를 가질 수 있다. IMC FU는 팝 명령어에 따라 입력 버퍼로부터 데이터 를 꺼내서 IMC FU의 메모리 셀 어레이에 저장할 수 있다. 데이터 전달은 FIFO에 따라 순차적으로 이루어 질 수 있다. 예를 들어, 입력 버퍼에 데이터(A[0]), 데이터(A[1]), 데이터(A[2])가 순차적으로 저장된 경 우, 이와 동일한 순서로 데이터(A[0]), 데이터(A[1]), 데이터(A[2])가 메모리 셀 어레이에 순차적으로 저장될 수 있다. 도 5는 일 실시예에 따른 IMC 기능 유닛의 버퍼 모드를 이용하여 IMC 기능 유닛에 메모리 입력 데이터를 저장하 는 동작을 예시적으로 나타내는 도면이다. 도 5를 참조하면, DSP는 스칼라 FU, 벡터 FU, IMC FU, 레거시 레지스터 파일, 특수 레지스터 파일, MUX, 및 버퍼 블록을 포함할 수 있 다. 버퍼 블록은 입력 버퍼 및 출력 버퍼를 포함할 수 있다. 일 실시예에 따르면, IMC FU의 동작 모드는 연산 모드 및 버퍼 모드를 포함할 수 있다. IMC FU는 연 산 모드에서 인-메모리 연산을 수행할 수 있고, 버퍼 모드에서 버퍼로 동작할 수 있다. IMC FU가 버퍼 모 드로 동작할 경우 DSP의 레지스터 용량이 커지는 것과 같은 효과가 나타날 수 있다. 스칼라 FU는 로드 명령어를 실행할 수 있다. 로드 명령어는 메모리 내 데이터(A)를 레지스터 (R16)로 로드하라는 의미를 가질 수 있다. 스칼라 FU는 로드 명령어에 따라 데이터(A)를 MUX를 통해 특수 레지스터 파일의 레지스터(R16)에 저장할 수 있다. 레지스터(R16)의 데이터(A)는 입력 버퍼 로 전달될 수 있다. 데이터(A)는 미리 정해진 규칙에 따라 레지스터(R16)로부터 입력 버퍼로 전달될 수 있다. 버퍼 모드에서 입력 버퍼는 입력 버퍼에 입력된 데이터(A)를 IMC FU로 자동으로 전달 하도록 설정될 수 있다. 이에 따라 데이터(A)는 IMC FU로 자동으로 전달될 수 있다. 예를 들어, 레지스 터(R16)에 데이터(A)를 포함하는 일련의 데이터(R16[0], R16[1], R16[2])가 로드된 경우, 데이터(R16[0], R16[1], R16[2])는 입력 버퍼를 통해 IMC FU에 순차적으로 저장될 수 있다. 버퍼 모드에서 IMC FU의 팝 명령어와 같은 명시적인 명령어 없이 입력 버퍼의 데이터가 IMC FU로 전달될 수 있다. 도 6은 일 실시예에 따른 IMC 기능 유닛의 추가 구성을 이용하여 메모리 입력 데이터를 저장하는 동작을 예시적 으로 나타내는 도면이다. 도 6을 참조하면, DSP는 스칼라 FU, 벡터 FU, IMC FU, 레거시 레지스터 파일, 특수 레지스터 파일, MUX, 및 버퍼 블록을 포함할 수 있다. 버퍼 블록 은 입력 버퍼 및 출력 버퍼를 포함할 수 있다. 일 실시예에 따르면, IMC FU가 배치된 레인 C에 별도의 로드/스토어 유닛이 포함될 수 있다. 레인 C에 별 도의 로드/스토어 유닛이 없는 경우 레인 C의 특수 레지스터 파일에 데이터를 로드하기 위해 레거시 FU의 레인(예: 레인 A, 레인 B)의 로드/스토어 유닛이 이용될 수 있다. 도 4, 도 5는 이처럼 레인 C에 별도의 로드/ 스토어 유닛이 없는 예시를 나타낼 수 있다. 레인 C에 별도의 로드/스토어 유닛이 있는 경우 레인 C의 로드/스 토어 유닛을 통해 특수 레지스터 파일에 데이터가 로드될 수 있다. 도 6은 이처럼 레인 C에 별도의 로드/ 스토어 유닛이 있는 예시를 나타낼 수 있다. IMC FU는 로드 명령어를 실행할 수 있다. 로드 명령어는 메모리 내 데이터(A)를 레지스터(R1 6)로 로드하라는 의미를 가질 수 있다. IMC FU는 로드 명령어에 따라 데이터(A)를 특수 레지스터 파 일의 레지스터(R16)에 저장할 수 있다. 레지스터(R16)의 데이터(A)는 입력 버퍼로 전달될 수 있다.데이터(A)는 미리 정해진 규칙에 따라 레지스터(R16)로부터 입력 버퍼로 전달될 수 있다. 로드 명령어 에 따라 입력 버퍼의 데이터(A[0], A[1], A[2])는 FIFO에 따라 순차적으로 IMC FU의 메모리 셀 어레이에 순차적으로 저장될 수 있다. 도 7a 및 도 7b는 일 실시예에 따른 IMC 기능 유닛의 MAC 연산 동작을 예시적으로 나타내는 도면이다. 도 7a 및 도 7b를 참조하면, DSP는 스칼라 FU, 벡터 FU, IMC FU, 레거시 레지스터 파일, 특수 레지스터 파일, MUX, 및 버퍼 블록을 포함할 수 있다. 버퍼 블록은 입력 버퍼 및 출력 버퍼를 포함할 수 있다. IMC FU는 메모리 셀 어레이를 이용한 인-메모리 연산 아키텍처를 갖고, 인-메모리 연산 아키텍처를 통해 MAC 연산을 수행할 수 있다. MAC 연산은 두 단계로 수행될 수 있다. 첫 번째 단계에서 IMC FU에 제1 메 모리 입력 데이터가 저장될 수 있고, 두 번째 단계에서 IMC FU에 제2 메모리 입력 데이터가 인가될 수 있 다. IMC FU는 제2 메모리 입력 데이터의 인가에 따라 제1 메모리 입력 데이터와 제2 메모리 입력 데이터 간의 MAC 연산을 수행할 수 있다. 예를 들어, 뉴럴 네트워크의 실행을 위해서는 웨이트 데이터와 입력 특징 데 이터 간의 대규모의 MAC 연산들이 요구될 수 있는데, IMC FU는 이러한 MAC 연산을 효율적으로 처리할 수 있다. 뉴럴 네트워크의 실행을 위한 MAC 연산에 이용되는 메모리 입력 데이터는 웨이트 데이터 및 입력 특징 데이터를 포함할 수 있다. 웨이트 데이터는 네트워크 웨이트 데이터로 부를 수 있고, 입력 특징 데이터는 네트워크 입력 데이터로 부를 수 있다. IMC FU의 메모리 셀 어레이에 네트워크 웨이트 데이터가 저장된 상태에서 메모리 셀 어레이에 네트워크 입력 데이터가 입력되면, IMC FU는 네트워크 웨이트 데이터와 네트워크 입력 데이터 간의 MAC 연산을 수행하여 네트워크 출력 데이터를 생성할 수 있다. 아래에서 대표적으로 네트워크 웨이트 데 이터가 IMC FU에 저장된 뒤 네트워크 입력 데이터가 IMC FU에 인가되는 예시가 설명될 수 있지만, 네 트워크 입력 데이터가 IMC FU에 저장된 뒤 네트워크 웨이트 데이터가 IMC FU에 인가되는 예시도 가능 하다. 도 7a를 참조하면, IMC FU의 메모리 셀 어레이에 데이터(A[0] 내지 A[15])가 저장된 상태에서 메모리 셀 어레이에 일련의 데이터(B[0] 내지 B[2])가 인가될 수 있다. 데이터(A[0] 내지 A[15])는 네트워크 웨이트 데이 터에 해당할 수 있고, 데이터(B[0] 내지 B[2])는 네트워크 입력 데이터에 해당할 수 있다. 데이터(A[0] 내지 A[15])는 도 4a, 도 4b, 도 5, 및 도 6의 메모리 입력 데이터의 저장 동작을 통해 IMC FU에 저장될 수 있 다. IMC FU는 팝 명령어를 실행할 수 있다. 팝 명령어에 따라 입력 버퍼의 데이터(B[0] 내지 B[2])가 IMC FU의 메모리 셀 어레이에 입력될 수 있다. 데이터 입력은 FIFO에 따라 순차적으로 이루 어질 수 있다. 도 7b를 참조하면, 인-메모리 연산에 따라 데이터(A[0]*B[0] 내지 A[15]*B[15])가 생성될 수 있다. 데이터 (A[0]*B[0] 내지 A[15]*B[15])는 곱셈 연산에 따른 중간 결과물에 해당할 수 있고, 데이터(A[0]*B[0] 내지 A[15]*B[15])의 출력 과정에서 데이터(A[0]*B[0] 내지 A[15]*B[15])의 누적이 이루어져서 MAC 연산의 최종 결 과물이 생성될 수 있다. IMC FU는 푸쉬 명령어를 실행할 수 있다. 푸쉬 명령어에 따라 메모리 셀 어레이의 데이터(A[0]*B[0] 내지 A[15]*B[15])가 출력 버퍼에 입력될 수 있다. 출력 버퍼는 데 이터(A[0]*B[0] 내지 A[15]*B[15])를 특수 레지스터 파일의 레지스터(예: 레지스터(R18))에 전달할 수 있 다. 데이터 전달은 FIFO에 따라 순차적으로 이루어질 수 있다. 도 8a 및 도 8b는 일 실시예에 따른 레거시 기능 유닛과 IMC 기능 유닛을 이용한 복합 연산을 예시적으로 나타 내는 도면이다. 도 8을 참조하면, DSP는 스칼라 FU, 벡터 FU, IMC FU, 레거시 레지스터 파일, 특수 레지스터 파일, MUX, 및 버퍼 블록을 포함할 수 있다. 버퍼 블록은 입 력 버퍼 및 출력 버퍼를 포함할 수 있다. 복합 연산은 어떤 데이터가 메모리로부터 로드된 뒤 해당 데이터에 기초한 연산의 결과물이 메모리에 저장되기 전까지 복수의 FU가 해당 데이터의 연산에 연속적으로 관여하는 형태의 연산을 의미할 수 있다. 보다 구체적으 로, 레거시 FU(예: 스칼라 FU, 벡터 FU) 및 IMC FU 중 어느 하나가 제1 연산을 수행하여 제1 연산 결과를 레지스터 파일(예: 레거시 레지스터 파일, 특수 레지스터 파일)에 저장하고, 레거시 FU 및 IMC FU 중 나머지 하나가 제1 연산 결과에 기초하여 제2 연산을 수행할 수 있다. 이때, 제1 연산 및 제2 연산이 복합 연산을 구성할 수 있다. 복합 연산은 다양한 형태로 수행될 수 있다. 도 8a를 참조하면, 벡터 FU는 제1 명령어에 따라 레지 스터(R12)의 데이터와 레지스터(R13)의 데이터 간의 제1 연산(예: 벡터 곱셈)을 수행하고, 제1 연산에 따른 제1 연산 결과를 레지스터(R16)에 저장할 수 있다. 레지스터(R16)의 제1 연산 결과는 입력 버퍼에 전달될 수 있다. IMC FU는 제2 명령어에 따라 제1 연산 결과의 적어도 일부에 대응하는 데이터 (R12[0]*R13[0])를 입력 버퍼로부터 받고 데이터(R12[0]*R13[0])를 IMC FU의 메모리 셀 어레이에 저 장할 수 있다. 도 8b를 참조하면, IMC FU는 제3 명령어에 따라 데이터(A[0]*B[0] 내지 A[15]*B[15])를 출력 버퍼 를 통해 레지스터(R18)에 저장할 수 있다. 데이터(A[0]*B[0] 내지 A[15]*B[15])는 인-메모리 연산에 따 라 생성된 것일 수 있다. 데이터(A[0]*B[0] 내지 A[15]*B[15])는 곱셈 연산에 따른 중간 결과물에 해당할 수 있고, 데이터(A[0]*B[0] 내지 A[15]*B[15])의 출력 과정에서 데이터(A[0]*B[0] 내지 A[15]*B[15])의 누적이 이 루어져서 MAC 연산의 최종 결과물이 생성될 수 있다. MAC 연산은 제1 연산, 최종 결과물은 제1 연산 결과에 해 당할 수 있다. 최종 결과물에 해당하는 제1 연산 결과가 출력 버퍼를 통해 레지스터(R18)에 저장될 수 있 다. 스칼라 FU는 제4 명령어에 따라 레지스터(R14)의 데이터와 레지스터(R18)의 데이터 간의 제2 연 산(예: 스칼라 곱셈)을 수행하고, 제2 연산 결과를 레지스터(R15)에 저장할 수 있다. 복합 연산에 따르면 제1 연산 결과는 메모리에 저장되지 않은 채 제2 연산에 이용될 수 있다. 따라서, 복합 연 산에 따라 메모리 접근이 줄어들고 연산 속도가 향상될 수 있다. 도 9a 및 도 9b는 레거시 컨볼루션 연산과 DSC 연산 간의 차이를 나타내는 도면이다. 도 9a를 참조하면, 입력 특징 맵과 웨이트 커널 간의 레거시 컨볼루션 연산에 따라 출력 특징 맵이 생성될 수 있다. 입 력 특징 맵은 I_W*I_H*I_C의 디멘전을, 웨이트 커널의 각 개별 커널은 K_W1*K_H1*K_C1의 디멘전을, 출력 특징 맵은 O_W*O_H*O_C의 디멘전을 가질 수 있다. 웨이트 커널은 O_C개의 개별 커널들을 포함 할 수 있다. 메모리 셀 어레이는 복수의 메모리 셀들을 포함할 수 있다. 복수의 메모리 셀들은 웨이트 커널 에 대응하는 웨이트 데이터를 저장할 수 있다. 메모리 셀 어레이의 열(row) 방향은 웨이트 커널 의 채널 방향에 해당할 수 있고, 행(column) 방향은 커널 방향에 해당할 수 있다. 개별 커널들의 각 채널 의 데이터는 채널 방향을 따라 저장될 수 있고, 각 개별 커널은 커널 방향을 따라 저장될 수 있다. 예를 들어, 제1 열에 각 개별 커널의 제1 채널의 웨이트 값들이 저장되고, 제2 열에 각 개별 커널의 제2 채널의 웨이트 값 들이 저장될 수 있다. 제1 행에 제1 개별 커널의 복수의 채널들의 웨이트 값들이 저장될 수 있고, 제2 행에 제 2 개별 커널의 복수의 채널들의 웨이트 값들이 저장될 수 있다. 본 예시는 하나의 열에 하나의 채널이 저장되 고, 하나의 행에 하나의 개별 커널이 저장되는 것을 가정하지만, 하나의 채널이 복수의 열들에 걸쳐 저장되거나, 하나의 개별 커널이 복수의 열들에 걸쳐 저장되는 것도 가능하다. 복수의 메모리 셀들에 웨이트 데이터가 저장된 상태에서, 입력 특징 맵에 대응하는 입력 데이터가 입 력 섹션을 통해 메모리 셀 어레이에 인가될 수 있다. 메모리 셀 어레이의 IMC를 통해 입력 데 이터와 웨이트 데이터 간의 MAC 연산이 수행될 수 있다. 출력 섹션을 통해 MAC 연산 결과가 출력될 수 있 다. MAC 연산 결과에 기초하여 출력 특징 맵이 결정될 수 있다. 도 9b를 참조하면, 도 9a의 레거시 컨볼루션 연산에 대응하는 DSC(depth-wise separable convolution) 연산이 수행될 수 있다. 입력 특징 맵과 제1 웨이트 커널 간의 뎁스-와이즈(depth-wise) 컨볼루션 연산에 따라 히든 맵이 생성될 수 있다. 제1 웨이트 커널은 K_C2개의 개별 커널들을 포함할 수 있고, 제1 웨이트 커널의 각 개별 커널은 K_W2*K_H2*1의 디멘전을 가질 수 있다. 히든 맵은 H_W*H_H*H_C의 디 멘전을 가질 수 있다. I_C, K_C2, H_C는 동일한 값일 수 있다. 히든 맵과 제2 웨이트 커널 간의 포인트-와이즈(point-wise) 컨볼루션 연산에 따라 출력 특징 맵 이 생성될 수 있다. 제2 웨이트 커널은 O_C개의 개별 커널들을 포함할 수 있고, 제2 웨이트 커널 의 각 개별 커널은 1*1*K_C3의 디멘전을 가질 수 있다. 제1 웨이트 커널 및 제2 웨이트 커널은 도 9a의 웨이트 커널이 DSC에 적합하게 변형된 결과물에 해당할 수 있다. 메모리 셀 어레이가 DSC에 이용되는 경우, 메모리 셀 어레이를 통해 뎁스-와이즈 컨볼루션 연산과 포 인트-와이즈 컨볼루션 연산이 수행될 수 있다. 입력 특징 맵과 제1 웨이트 커널 간의 뎁스-와이즈 컨볼루션 연산은 입력 특징 맵의 각 채널의 개별 맵과 제1 웨이트 커널의 각 개별 커널 간의 개별 컨 볼루션 연산을 포함할 수 있다. 인-메모리 연산 아키텍처에서 복수의 메모리 셀들에 많은 웨이트 데이터 가 저장된 상태에서 입력 데이터가 메모리 셀 어레이에 인가되어야 메모리 셀 어레이의 사용 효율이높아질 수 있다. 뎁스-와이즈 컨볼루션 연산의 경우 제1 웨이트 커널의 각 개별 커널이 저장된 상태에서 입력 특징 맵의 대응 채널의 개별 맵이 인가되고, 일반적으로 개별 커널은 메모리 셀 어레이에 비해 크게 작은 사이즈를 가지므로, 메모리 셀 어레이의 사용 효율이 높지 않게 나타날 수 있다. 도 10a 및 도 10b는 일 실시예에 따른 복합 연산을 이용한 DSC 동작을 예시적으로 나타내는 도면이다. 복합 연 산은 어떤 데이터가 메모리로부터 로드된 뒤 해당 데이터에 기초한 연산의 결과물이 메모리에 저장되기 전까지 복수의 FU가 해당 데이터의 연산에 연속적으로 관여하는 형태의 연산을 의미할 수 있다. 예를 들어, 제1 FU 및 제2 FU 중 어느 하나는 제1 연산을 수행하여 제1 연산 결과를 레지스터 파일에 저장하고, 제1 FU 및 제2 FU 중 나머지 하나는 제1 연산 결과에 기초하여 제2 연산을 수행할 수 있다. IMC FU의 메모리 셀 어레이의 사 용 효율이 높지 않게 나타나는 연산(예: DSC의 뎁스-와이즈 컨볼루션)은 레거시 FU(예: 스칼라 FU, 벡터 FU)에 의해 처리될 수 있고, 메모리 셀 어레이의 사용 효율이 높게 나타나는 연산(예: DSC의 포인트-와이 즈 컨볼루션)은 IMC FU에 의해 처리될 수 있다. 도 10a 및 도 10b를 참조하면, DSP는 스칼라 FU, 벡터 FU, IMC FU, 레거시 레지스터 파일, 특수 레지스터 파일, MUX, 및 버퍼 블록을 포함할 수 있다. 버퍼 블록 은 입력 버퍼 및 출력 버퍼를 포함할 수 있다. 도 10a를 참조하면, 벡터 FU은 뎁스-와이즈 컨볼루션을 수행할 수 있다. 레거시 레지스터 파일의 레지스터들(예: 레지스터들(R12, R13, R16))에 입력 특징 맵의 입력 데이터 및 제1 웨이트 커널의 웨이트 데이 터가 저장될 수 있고, 레지스터들의 입력 데이터와 웨이트 데이터 간의 뎁스-와이즈 컨볼루션이 수행될 수 있다. 연산 결과물은 특수 레지스터 파일의 레지스터(예: 레지스터(R16))에 저장될 수 있다. 연산 결과 물은 히든 맵의 히든 데이터에 해당할 수 있다. 연산 결과물은 입력 버퍼를 거쳐 IMC FU의 메모리 셀 어레이에 인가될 수 있다. 벡터 FU는 입력 특징 맵의 더 많은 데이터와 웨이트 커널의 더 많은 데이 터 간의 뎁스-와이즈 컨볼루션을 수행할 수 있고, 그 결과 IMC FU의 메모리 셀 어레이에 더 많은 히든 데 이터가 인가될 수 있다. 도 10b를 참조하면, IMC FU는 포인트-와이즈 컨볼루션을 수행할 수 있다. IMC FU의 메모리 셀 어 레이에는 제2 웨이트 커널의 웨이트 데이터가 저장될 수 있다. 메모리 셀 어레이에 웨이트 데이터가 저장된 상 태에서 메모리 셀 어레이에 히든 데이터가 인가될 수 있다. IMC FU는 웨이트 데이터와 히든 데이터 간의 포인트-와이즈 컨볼루션을 수행할 수 있다. IMC FU의 출력은 출력 버퍼를 통해 특수 레지스터 파 일의 레지스터들(예: 레지스터(R18))에 저장될 수 있다. IMC FU의 출력은 출력 특징 맵의 출력 데 이터에 해당할 수 있다. 도 11a 및 도 11b는 일 실시예에 따른 IMC 기능 유닛의 버퍼 모드를 예시적으로 나타내는 도면이다. 도 11a 및 도 11b를 참조하면, DSP는 스칼라 FU, 벡터 FU, IMC FU, 레거시 레지스터 파일 , 특수 레지스터 파일, MUX, 및 버퍼 블록을 포함할 수 있다. 버퍼 블록은 입 력 버퍼 및 출력 버퍼를 포함할 수 있다. IMC FU의 동작 모드는 연산 모드 및 버퍼 모드를 포함할 수 있다. IMC FU는 연산 모드에서 인-메모리 연산을 수행할 수 있고, 버퍼 모드에서 버퍼로 동작 할 수 있다. IMC FU는 버퍼 명령어(예: IMC_BUF_ON)에 따라 버퍼 모드로 동작할 수 있다. IMC FU가 버퍼 모드로 동작할 경우 DSP의 레지스터 용량이 커지는 것과 같은 효과가 나타날 수 있다. 도 11a를 참조하면, 벡터 FU는 벡터 곱셈 명령어를 실행할 수 있다. 벡터 곱셈 명령어는 레 지스터(R12)의 데이터와 레지스터(R13)의 데이터 간의 벡터 곱셈을 수행하고, 벡터 곱셈의 연산 결과를 레지스 터(R16)에 저장하라는 의미를 가질 수 있다. 벡터 FU는 벡터 곱셈 명령어에 따라 레지스터(R12)의 데이터와 레지스터(R13)의 데이터 간의 벡터 곱셈을 수행하고, 벡터 곱셈의 연산 결과를 레지스터(R16)에 저장 할 수 있다. 연산 결과는 입력 버퍼로 전달될 수 있다. 벡터 곱셈 명령어와 같은 명령어가 호출 될 때 입력 및/또는 출력에 사용될 레지스터(예: 벡터 곱셈 명령어의 레지스터들(R12, R13, R16))가 선언 되는데, 이러한 레지스터를 통해 IMC FU가 메모리 소자로 활용될 수 있다. 버퍼 모드에서 버퍼 블록은 바이패스(bypass)될 수 있다. 버퍼 블록은 앞선 블록에서 들어오는 값 을 FIFO에 따라 자동적으로 순서대로 다음 블록으로 넘길 수 있다. 버퍼 모드에서 입력 버퍼는 입력 버 퍼에 입력된 데이터를 IMC FU로 자동으로 전달하도록 설정될 수 있다. 이에 따라 연산 결과는 IMC FU로 자동으로 전달될 수 있다. 예를 들어, 레지스터(R16)에 일련의 데이터(R16[0], R16[1], R16[2])가 로드된 경우, 데이터(R16[0], R16[1], R16[2])는 입력 버퍼를 통해 IMC FU에 순차적으로 저장될 수 있다. 버퍼 모드에서 IMC FU의 팝 명령어와 같은 명시적인 명령어 없이 입력 버퍼의 데이터가IMC FU로 전달될 수 있다. 도 11b를 참조하면, 벡터 FU는 벡터 곱셈 명령어를 실행할 수 있다. 벡터 곱셈 명령어는 레 지스터(R17)의 데이터와 레지스터(R14)의 데이터 간의 벡터 곱셈을 수행하고, 벡터 곱셈의 연산 결과를 레지스 터(R15)에 저장하라는 의미를 가질 수 있다. 벡터 FU는 벡터 곱셈 명령어에 따라 레지스터(R17)의 데이터와 레지스터(R14)의 데이터 간의 벡터 곱셈을 수행할 수 있다. 레지스터(R17)의 데이터는 IMC FU 및 출력 버퍼에 의해 제공될 수 있다. 버퍼 모드에서 IMC FU는 IMC FU에 저장된 데이터를 출력 버퍼에 제공할 수 있다. 버퍼 모드에서 출력 버퍼 는 출력 버퍼에 입력된 데이터를 특수 레지스터 파일로 자동으로 전달하도록 설정될 수 있다. 이에 따라 버퍼 데이터는 특수 레지스터 파일로 자동으로 전달될 수 있다. 예를 들어, IMC FU에 일련의 데이터(R16[0] 내지 R16[15])가 저장된 경우, 데이터(R16[0] 내지 R16[15])는 출력 버퍼 를 통해 특수 레지스터 파일로 순차적으로 전달될 수 있다. 버퍼 모드에서 IMC FU의 푸쉬 명령어와 같은 명시적인 명령어 없이 IMC FU의 데이터가 출력 버퍼로 전달될 수 있다. 도 12는 일 실시예에 따른 각 레인의 독립적인 운영을 예시적으로 나타내는 도면이다. 도 12a 및 도 12b를 참 조하면, DSP는 스칼라 FU, 벡터 FU, IMC FU, 레거시 레지스터 파일, 특수 레지 스터 파일, MUX, 및 버퍼 블록을 포함할 수 있다. 버퍼 블록은 입력 버퍼 및 출력 버퍼를 포함할 수 있다. IMC FU의 동작 모드는 연산 모드 및 버퍼 모드를 포함할 수 있다. 복수의 명령어들의 명령어 묶음에 해당하는 VLIW 패킷이 DSP의 복수의 레인들(예: 레인 A, 레인 B, 레인 C)을 통해 독립적으로 처리될 수 있다. 각 명령어의 처리에 필요한 레지스터들(예: 레거시 레지스터 파일 의 레지스터, 특수 레지스터 파일의 레지스터)이 독립적으로 운영될 수 있다. 도 12는 덧셈 명령어, 벡터 곱셈 명령어, 및 푸쉬 명령어가 각 레인에서 독립적으로 처리되 는 예시를 나타낸다. 예를 들어, 명령어들(1201 내지 1203)의 명령어 묶음은 {ADD R2, R0, R1; VMUL R16, R12, R13; PUSH R18}와 같이 나타낼 수 있다. 스칼라 FU는 덧셈 명령어를 실행할 수 있다. 덧셈 명령어의 실행에 따라 레지스터(R0)의 데 이터 및 레지스터(R1)의 데이터의 덧셈 연산이 수행되고, 덧셈 연산의 연산 결과가 레지스터(R2)에 저장될 수 있다. 벡터 FU는 벡터 곱셈 명령어를 실행할 수 있다. 벡터 곱셈 명령어의 실행에 따라 레 지스터(R12)의 데이터 및 레지스터(R13)의 데이터의 벡터 곱셈 연산이 수행되고, 벡터 곱셈 연산의 연산 결과가 레지스터(R16)에 저장될 수 있다. IMC FU는 푸쉬 명령어를 실행할 수 있다. 푸쉬 명령어의 실행에 따라 IMC FU의 출력 데이터가 출력 버퍼를 통해 레지스터(R18)에 저장될 수 있다. 도 13은 일 실시예에 따른 IMC 기능 유닛의 구조를 예시적으로 나타낸다. 도 13은 일 실시예에 따른 IMC FU의 하나의 예시를 나타낼 뿐, IMC FU는 인-메모리 연산 아키텍처에 따른 다양한 구조를 가질 수 있다. 도 13을 참 조하면, IMC FU는 비트 셀과 같은 복수의 비트 셀들을 포함하는 메모리 셀 어레이, 각 비트 셀의 곱셈 연산에 따른 곱셈 결과들에 기초한 덧셈 연산들을 수행하는 가산기, 및 가산기의 덧셈 연산들에 따른 덧셈 결과에 기초한 누적 연산을 수행하는 누적기를 포함할 수 있다. 누적기의 출 력은 MAC 연산의 연산 결과에 해당할 수 있다. 각 비트 셀은 웨이트 데이터의 적어도 일부 및 입력 특징 데이터의 적어도 일부에 따른 비트 쌍들의 곱셈 연산들을 수행할 수 있다. 가산기는 가산기 트리(adder tree)에 해당할 수 있다. 누적기는 비트 포지션을 변경하기 위한 쉬프트를 수행하는 쉬프트 회로를 포함 할 수 있다. 메모리 셀 어레이는 입력 데이터(Ym)와 셀 데이터(Xmk) 간의 비트 별 곱셈 연산(bitwise multiplication operation)을 수행할 수 있다. 여기서, m은 1 이상 M 이하의 정수, k는 1이상 K이하의 정수, M, K는 정수일 수 있다. 셀 데이터(Xmk)는 각 비트 셀에 저장된 데이터를 의미할 수 있다. IMC FU의 연산이 수행되기 전에 메모리 셀 어레이에 셀 데이터(Xmk)가 미리 저장될 수 있고, 메모리 셀 어레이에 셀 데이터(Xmk)의 저장이 완료된 후 메모리 셀 어레이에 입력 데이터(Ym)가 입력되면서 곱셈 연산 결과가 출력될 수 있다. 곱셈 연산은 각 비트 셀의 메모리 타입에 따라 다양한 방식으로 수행될 수 있다. 예를 들어, 각 비트 셀이 6T SRAM에 해당하는 경우, 각 비트 셀의 인버터들에 의해 셀 데이터(Xmk)가 저장되고, 워드 라인(word line)을 통해 입력 데이터(Ym)가 입력되고, 비트 라인(bit line)을 통해 출력 데이터(XmkYm)가 출력될 수 있다. 이때, 각 비트 셀에 트랜지스터나 인버터와 같이 곱셈 연산을 위한 회로 소자가 추가될 수 있다. 입력 데이터(Ym)가 멀티 비트의 데이터 형식을 가지는 경우 입력 데이터(Ym)에 대응하는 비트 스트림이 메모리 셀 어레이에 한 비트씩 순차적으로 입력되면서 연산이 진행될 수 있다. 예를 들어, 제1 스테이지에서 제 1 비트 포지션(예: LSB(least significant bit))에 대응하는 입력 데이터(Ym)가 메모리 셀 어레이에 입력 될 수 있고, 제1 비트 포지션에 대응하는 출력 데이터(XmkYm)가 메모리 셀 어레이로부터 출력될 수 있다. 가산기는 출력 데이터(XmkYm)에 따른 덧셈 연산들을 수행할 수 있고, 누적기는 덧셈 결과를 누적할 수 있다. 제1 비트 포지션에 대응하는 입력 데이터(Ym)에 따른 덧셈 결과는 제1 덧셈 결과로 부를 수 있다. 누적기 는 쉬프트 동작을 통해 덧셈 결과의 비트 포지션을 증가시킬 수 있다. 제1 비트 포지션의 경우 비트 포 지션의 증가가 요구되지 않으므로 제1 덧셈 결과에 대한 쉬프트 동작은 생략될 수 있다. 제2 스테이지에서 제2 비트 포지션에 대응하는 입력 데이터(Ym)가 메모리 셀 어레이에 입력된 후, 제2 비트 포지션에 대응하는 덧셈 결과가 결정될 수 있다. 제2 비트 포지션에 대응하는 입력 데이터(Ym)에 따른 덧셈 결과는 제2 덧셈 결과 로 부를 수 있다. 제2 비트 포지션의 경우 제1 비트 포지션보다 비트 포지션이 하나 크므로 제2 덧셈 결과에 대한 한 차례의 쉬프트 동작을 통해 제2 덧셈 결과의 비트 포지션이 하나 증가될 수 있다. 누적기는 비 트 포지션의 변경 후 제1 덧셈 결과와 제2 덧셈 결과를 누적할 수 있다. 이러한 연산 과정이 입력 데이터(Ym) 의 마지막 비트 포지션(예: MSB(most significant bit)까지 반복될 수 있다. 셀 데이터(Xmk)가 멀티 비트의 데이터 형식을 가지는 경우 서로 다른 비트 포지션의 셀 데이터(Xmk)는 서로 다른 비트 셀 어레이에 저장한 뒤 연산 결과를 쉬프트 및 누적하여 최종 연산 결과가 도출될 수 있다. 셀 데이터 (Xmk)가 웨이트 데이터인 경우 입력 데이터(Ym)는 입력 특징 데이터일 수 있다. 도 14는 일 실시예에 따른 전자 장치의 예시적인 구성을 나타내는 블록도이다. 도 14를 참조하면, 전자 장치 는 프로세서, 메모리, 카메라, 저장 장치, 입력 장치, 출력 장치 및 네트워크 인터페이스를 포함할 수 있으며, 이들은 통신 버스를 통해 서로 통신할 수 있다. 예 를 들어, 전자 장치는 이동 전화, 스마트 폰, PDA, 넷북, 태블릿 컴퓨터, 랩톱 컴퓨터 등과 같은 모바일 장치, 스마트 워치, 스마트 밴드, 스마트 안경 등과 같은 웨어러블 디바이스, 데스크탑, 서버, 데이터 센터 등 과 같은 컴퓨팅 장치, 텔레비전, 스마트 텔레비전, 냉장고 등과 같은 가전 제품, VTS(voice triggering syste m)과 같은 IoT(internet of things) 기기, 도어 락 등과 같은 보안 장치, 자율주행 차량, 스마트 차량 등과 같 은 차량, 드론 등과 같은 로봇의 적어도 일부로 구현될 수 있다. 전자 장치는 도 1의 전자 장치를 구조적 및/또는 기능적으로 포함할 수 있다. 프로세서는 전자 장치 내에서 실행하기 위한 기능 및 명령어들을 실행한다. 예를 들어, 프로세서 는 메모리 또는 저장 장치에 저장된 명령어들을 처리할 수 있다. 프로세서는 도 1 내 지 도 13을 통하여 설명된 동작을 수행할 수 있다. 메모리는 컴퓨터 판독가능한 저장 매체 또는 컴퓨터 판독가능한 저장 장치를 포함할 수 있다. 메모리는 프로세서에 의해 실행하기 위한 명령어들을 저 장할 수 있고, 전자 장치에 의해 소프트웨어 및/또는 애플리케이션이 실행되는 동안 관련 정보를 저장할 수 있다. 카메라는 사진 및/또는 비디오를 촬영할 수 있다. 저장 장치는 컴퓨터 판독가능한 저장 매체 또는 컴퓨터 판독가능한 저장 장치를 포함한다. 저장 장치는 메모리보다 더 많은 양의 정보를 저장하고, 정보를 장기간 저장할 수 있다. 예를 들어, 저장 장치는 자기 하드 디스크, 광 디스크, 플래 쉬 메모리, 플로피 디스크 또는 이 기술 분야에서 알려진 다른 형태의 비휘발성 메모리를 포함할 수 있다. 입력 장치는 키보드 및 마우스를 통한 전통적인 입력 방식, 및 터치 입력, 음성 입력, 및 이미지 입력과 같은 새로운 입력 방식을 통해 사용자로부터 입력을 수신할 수 있다. 예를 들어, 입력 장치는 키보드, 마우스, 터치 스크린, 마이크로폰, 또는 사용자로부터 입력을 검출하고, 검출된 입력을 전자 장치에 전달 할 수 있는 임의의 다른 장치를 포함할 수 있다. 출력 장치는 시각적, 청각적 또는 촉각적인 채널을 통 해 사용자에게 전자 장치의 출력을 제공할 수 있다. 출력 장치는 예를 들어, 디스플레이, 터치 스 크린, 스피커, 진동 발생 장치 또는 사용자에게 출력을 제공할 수 있는 임의의 다른 장치를 포함할 수 있다. 네트워크 인터페이스는 유선 또는 무선 네트워크를 통해 외부 장치와 통신할 수 있다.이상에서 설명된 실시예들은 하드웨어 구성요소, 소프트웨어 구성요소, 및/또는 하드웨어 구성요소 및 소프트웨 어 구성요소의 조합으로 구현될 수 있다. 예를 들어, 실시예들에서 설명된 장치, 방법 및 구성요소는, 예를 들 어, 프로세서, 콘트롤러, ALU(arithmetic logic unit), 디지털 신호 프로세서(digital signal processor), 마 이크로컴퓨터, FPGA(field programmable gate array), PLU(programmable logic unit), 마이크로프로세서, 또는 명령(instruction)을 실행하고 응답할 수 있는 다른 어떠한 장치와 같이, 범용 컴퓨터 또는 특수 목적 컴퓨터를 이용하여 구현될 수 있다. 처리 장치는 운영 체제(OS) 및 상기 운영 체제 상에서 수행되는 소프트웨어 애플리 케이션을 수행할 수 있다. 또한, 처리 장치는 소프트웨어의 실행에 응답하여, 데이터를 접근, 저장, 조작, 처 리 및 생성할 수도 있다. 이해의 편의를 위하여, 처리 장치는 하나가 사용되는 것으로 설명된 경우도 있지만,"}
{"patent_id": "10-2023-0076305", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "해당 기술분야에서 통상의 지식을 가진 자는, 처리 장치가 복수 개의 처리 요소(processing element) 및/또는 복수 유형의 처리 요소를 포함할 수 있음을 알 수 있다. 예를 들어, 처리 장치는 복수 개의 프로세서 또는 하 나의 프로세서 및 하나의 컨트롤러를 포함할 수 있다. 또한, 병렬 프로세서(parallel processor)와 같은, 다른 처리 구성(processing configuration)도 가능하다. 소프트웨어는 컴퓨터 프로그램(computer program), 코드(code), 명령(instruction), 또는 이들 중 하나 이상의 조합을 포함할 수 있으며, 원하는 대로 동작하도록 처리 장치를 구성하거나 독립적으로 또는 결합적으로 (collectively) 처리 장치를 명령할 수 있다. 소프트웨어 및/또는 데이터는, 처리 장치에 의하여 해석되거나 처리 장치에 명령 또는 데이터를 제공하기 위하여, 어떤 유형의 기계, 구성요소(component), 물리적 장치, 가상 장치(virtual equipment), 컴퓨터 저장 매체 또는 장치에 저장될 수 있다. 소프트웨어는 네트워크로 연결된 컴 퓨터 시스템 상에 분산되어서, 분산된 방법으로 저장되거나 실행될 수도 있다. 소프트웨어 및 데이터는 컴퓨터 판독 가능 기록 매체에 저장될 수 있다. 실시예에 따른 방법은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등을 단 독으로 또는 조합하여 저장할 수 있으며 매체에 기록되는 프로그램 명령은 실시예를 위하여 특별히 설계되고 구 성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판독 가능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD-ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체(magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다. 위에서 설명한 하드웨어 장치는 실시예의 동작을 수행하기 위해 하나 또는 복수의 소프트웨어 모듈로서 작동하 도록 구성될 수 있으며, 그 역도 마찬가지이다."}
{"patent_id": "10-2023-0076305", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "이상과 같이 실시예들이 비록 한정된 도면에 의해 설명되었으나, 해당 기술분야에서 통상의 지식을 가진 자라면 이를 기초로 다양한 기술적 수정 및 변형을 적용할 수 있다. 예를 들어, 설명된 기술들이 설명된 방법과 다른 순서로 수행되거나, 및/또는 설명된 시스템, 구조, 장치, 회로 등의 구성요소들이 설명된 방법과 다른 형태로 결합 또는 조합되거나, 다른 구성요소 또는 균등물에 의하여 대치되거나 치환되더라도 적절한 결과가 달성될 수 있다. 그러므로, 다른 구현들, 다른 실시예들 및 특허청구범위와 균등한 것들도 후술하는 특허청구범위의 범위에 속한 다.도면 도면1 도면2 도면3 도면4a 도면4b 도면5 도면6 도면7a 도면7b 도면8a 도면8b 도면9a 도면9b 도면10a 도면10b 도면11a 도면11b 도면12 도면13 도면14"}
{"patent_id": "10-2023-0076305", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일 실시예에 따른 전자 장치의 일부 구성을 나타내는 블록도다. 도 2는 일 실시예에 따른 DSP의 구조를 예시적으로 나타내는 도면이다. 도 3은 일 실시예에 따른 DSP의 일부 레인의 상세 구조를 예시적으로 나타내는 도면이다. 도 4a 및 도 4b는 일 실시예에 따른 레거시 기능 유닛을 이용하여 IMC 기능 유닛에 메모리 입력 데이터를 저장 하는 동작을 예시적으로 나타내는 도면이다. 도 5는 일 실시예에 따른 IMC 기능 유닛의 버퍼 모드를 이용하여 IMC 기능 유닛에 메모리 입력 데이터를 저장하 는 동작을 예시적으로 나타내는 도면이다. 도 6은 일 실시예에 따른 IMC 기능 유닛의 추가 구성을 이용하여 메모리 입력 데이터를 저장하는 동작을 예시적 으로 나타내는 도면이다. 도 7a 및 도 7b는 일 실시예에 따른 IMC 기능 유닛의 MAC 연산 동작을 예시적으로 나타내는 도면이다. 도 8a 및 도 8b는 일 실시예에 따른 레거시 기능 유닛과 IMC 기능 유닛을 이용한 복합 연산을 예시적으로 나타 내는 도면이다. 도 9a 및 도 9b는 레거시 컨볼루션 연산과 DSC 연산 간의 차이를 나타내는 도면이다. 도 10a 및 도 10b는 일 실시예에 따른 복합 연산을 이용한 DSC 동작을 예시적으로 나타내는 도면이다. 도 11a 및 도 11b는 일 실시예에 따른 IMC 기능 유닛의 버퍼 모드를 예시적으로 나타내는 도면이다. 도 12는 일 실시예에 따른 각 레인의 독립적인 운영을 예시적으로 나타내는 도면이다.도 13은 일 실시예에 따른 IMC 기능 유닛의 구조를 예시적으로 나타낸다. 도 14는 일 실시예에 따른 전자 장치의 예시적인 구성을 나타내는 블록도이다."}
