{"patent_id": "10-2022-0175322", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0030922", "출원번호": "10-2022-0175322", "발명의 명칭": "MPEG-VCM에 기반하여 인공신경망을 분산 처리하는 NPU 및 방법", "출원인": "주식회사 딥엑스", "발명자": "유하준"}}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "인코딩을 수행할 수 있는 NPU(Neural Processing Unit)로서,인공신경망 내의 다수의 레이어들을 위한 연산을 수행하여 복수의 출력 특징맵을 생성하는 하나 이상의PE(Processing Element)와; 그리고상기 복수의 출력 특징맵 중에서 하나 이상의 임의 출력 특징맵을 비트스트림으로 인코딩한 후, 전송하는 인코더를 포함하는, NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 인코더는 상기 복수의 출력 특징맵 중에서 하나 이상의 임의 출력 특징맵을 임의의 정보에 기초하여 선택하는, NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 임의의 정보는, 서버 혹은 상기 비트스트림을 수신하는 다른 NPU로부터 수신되는, NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서, 상기 임의의 정보는 상기 하나 이상의 임의 출력 특징맵에 대한 식별 정보 혹은 상기 임의 출력 특징맵에 대응하는 레이어에 대한 식별 정보를 포함하는, NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서, 상기 임의의 정보는:출력 특징맵의 사이즈 정보, 상기 비트스트림을 수신하는 다른 NPU에서 수행되는 머신 태스크의 정보 그리고 상기 비트스트림을 수신하는 다른 NPU에서 연산되는 인공신경망 모델의 정보 중 하나 이상에 기초하여 생성되는,NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 비트스트림은, 상기 인공신경망 내의 후속 레이어들을 위한 연산을 다른 NPU가 수행하도록 하기 위해 전송되는, NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "디코딩을 수행할 수 있는 NPU(Neural Processing Unit)로서,수신되는 비트스트림을 디코딩하여 하나 이상의 임의 특징맵으로 복원하는 디코더와; 그리고인공신경망 모델을 위한 연산을 수행하는 하나 이상의 PE(Processing Element)를 포함하고,상기 복원된 하나 이상의 임의 특징맵은 상기 인공신경망 내의 다수의 레이어들 중에서 임의 레이어의 출력 특징맵이고,상기 하나 이상의 PE는 상기 복원된 하나 이상의 임의 특징맵을 상기 임의 레이어의 후속 레이어의 입력 특징맵으로 활용하는, NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서, 상기 NPU는 상기 임의 레이어 혹은 상기 하나 이상의 특징맵을 상기 비트스트림을 전송하는 다공개특허 10-2024-0030922-3-른 NPU에 의해 선택될 수 있도록 하는 임의 정보를 전송하는, NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서, 상기 임의 정보는 상기 하나 이상의 임의 특징맵에 대한 식별 정보 혹은 상기 하나 이상의 임의 특징맵에 대응하는 레이어에 대한 식별 정보를 포함하는, NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제8항에 있어서, 상기 임의 정보는:특징맵의 사이즈 정보, 상기 NPU에서 수행되는 머신 태스크의 정보 그리고 상기 인공신경망 모델의 정보 중 하나 이상에 기초하여 생성되는, NPU."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "복수의 레이어를 포한하는 인공신경망 모델의 제1 레이어 구간을 처리하도록 구성된 제1 신경 프로세싱 유닛;및상기 인공신경망 모델의 제2 레이어 구간을 처리하도록 구성된 제2 신경 프로세싱 유닛;을 포함하고,상기 제1 신경 프로세싱 유닛은 상기 제1 레이어 구간의 마지막 레이어의 출력 특징맵을 상기 제2 신경 프로세싱 유닛에 입력하도록 구성된, 시스템."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,상기 제1 레이어 구간의 레이어들의 가중치의 총합의 크기는 상기 제2 레이어 구간의 레이어들의 가중치의 총합의 크기보다 상대적으로 더 작은, 시스템."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제11항에 있어서,상기 제1 신경 프로세싱 유닛은 복수개이고, 상기 제2 신경 프로세싱 유닛은 상기 제1 신경 프로세싱 유닛에서출력되는 상기 출력 특징맵 각각을 순차적으로 처리하도록 구성된, 시스템."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제11항에 있어서,상기 제2 신경 프로세싱 유닛은 적어도 상기 제1 신경 프로세싱 유닛의 개수에 대응하여 가중치를 재사용하도록구성된, 시스템."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제11항에 있어서,상기 제1 신경 프로세싱 유닛의 제1 메모리의 크기는 상기 제2 신경 프로세싱 유닛의 제2 메모리 보다 상대적으로 더 작도록 구성된, 시스템."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제11항에 있어서,상기 인공신경망 모델의 제1 레이어 구간과 상기 제2 레이어 구간은 특정 레이어의 출력 특징맵의 크기를 기초로 결정된, 시스템."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제11항에 있어서,상기 인공신경망 모델의 제1 레이어 구간과 상기 제2 레이어 구간은 각각의 레이어 구간의 가중치 총합의 크기공개특허 10-2024-0030922-4-를 기초로 결정된, 시스템."}
{"patent_id": "10-2022-0175322", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제11항에 있어서,상기 인공신경망 모델의 제1 레이어 구간의 제1 가중치의 크기는 상기 제2 레이어 구간의 제2 가중치 크기 보다상대적으로 더 작은, 시스템."}
{"patent_id": "10-2022-0175322", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 명세서의 일 개시에 따르면, 인코딩을 수행할 수 있는 NPU(Neural Processing Unit)가 제공된다. 상기 NPU는 인공신경망 내의 다수의 레이어들을 위한 연산을 수행하여 복수의 출력 특징맵을 생성하는 하나 이상의 PE(Processing Element)와; 그리고 상기 복수의 출력 특징맵 중에서 하나 이상의 임의 출력 특징맵을 비트스트림 으로 인코딩한 후, 전송하는 인코더를 포함할 수 있다."}
{"patent_id": "10-2022-0175322", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 인공신경망을 분산 처리하는 NPU 및 방법에 관한 것이다."}
{"patent_id": "10-2022-0175322", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "정보 통신 산업의 지속적인 발달을 통해 HD(High Definition) 해상도를 가지는 방송 서비스가 세계적으로 확산 되었다. 이러한 확산을 통해, 많은 사용자들이 고해상도이며 고화질인 영상(image) 및/또는 비디오(video)에 익숙해지게 되었고, 보다 높은 화질, 즉 4K 또는 8K 이상의 UHD(Ultra High Definition) 영상/비디오와 같은 고해상도, 고 품질의 영상/비디오에 대한 수요가 다양한 분야에서 증가되었다. 이러한 UHD 영상데이터를 코딩하는 기술은 2013년 표준 기술인 HEVC(High Efficiency Video Coding)를 통해 완성되었다. HEVC는 이전의 H.264/AVC 기술보다 더 높은 압축률과 더 낮은 복잡도를 갖는 차세대 영상 압축 기술이며, HD급, UHD급 영상의 방대한 데이터를 효과적으로 압축하기 위한 핵심 기술이다. HEVC는 이전의 압축 표준들과 같이 블록 단위의 부호화를 수행한다. 다만 H.264/AVC와 달리 하나의 프로파일만 존재하는 차이점이 있다. HEVC의 유일한 프로파일에 포함된 핵심 부호화 기술은 총 8개 분야로 계층적 부호화 구조 기술, 변환 기술, 양자화 기술, 화면 내 예측 부호화 기술, 화면 간 움직임 예측 기술, 엔트로피 부호화 기술, 루프 필터 기술 및 기타 기술이 있다. 2013년 HEVC 비디오 코덱 제정 이후, 4K, 8K를 비디오 영상을 이용한 실감 영상 및 가상 현실 서비스 등이 확대 됨에 따라 HEVC 대비 2배 이상 성능 개선을 목표로 하는 차세대 비디오 코덱인, 다용도 비디오 부호화(VVC: Versatile Video Coding) 표준이 개발되었다. VVC는 H.266으로 불린다. H.266(VVC)은 이전 세대 코덱인 H.265(HEVC)보다 2배 이상의 효율을 목표로 개발되었다. VVC는 처음에는 4K 이 상의 해상도를 감안하고 개발되었으나 점점 VR 시장의 확장으로 인한 360도 영상을 대응할 목적으로 무려 16K 수준의 초고해상도 영상처리용으로도 개발되었다. 또한 점차 디스플레이 기술의 발달로 HDR 시장이 확대 됨에 따라 이에 대응하기 위해 10비트 색심도는 물론이고 16비트 색심도를 지원하며 1000니트, 4000니트, 10000니트의 밝기 표현을 지원한다. 또한 VR시장과 360도 영상시장을 염두하여 개발되고 있기에 0~120 FPS 범위 의 부분 프레임 속도를 지원한다. <인공 지능의 발전> 인공지능(artificial intelligence: AI)도 점차 발전하고 있다. AI는 인간의 지능, 즉 인식(Recognition), 분 류(Classification), 추론(Inference), 예측(Predict), 조작/의사결정(Control/Decision making) 등을 할 수 있는 지능을 인공적으로 모방하는 것을 의미한다. 인공 지능 기술의 발전 및 사물인터넷(Internet Of Things; IOT) 기기의 증가로 인해 기계 간 트래픽이 폭증할 것으로 예측되고, 기계(machine)에 의존하는 영상 분석이 널리 사용될 것으로 예측되고 있다. 그러나, 기계에 의해 분석되어야 할 영상이 기하급수적으로 증가될 것으로 예상됨에 따라, 서버의 부하 및 전력 소모 문제가 제기될 것으로 예측된다."}
{"patent_id": "10-2022-0175322", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "발명의 내용"}
{"patent_id": "10-2022-0175322", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "따라서, 본 개시는 기계에 의한 영상 분석을 효과적으로 수행할 수 있도록 하기 위한, NPU(Neural Processing Unit)을 제공하는 것을 목적으로 한다."}
{"patent_id": "10-2022-0175322", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "전술한 목적을 달성하기 위하여, 본 명세서의 일 개시에 따르면, 인코딩을 수행할 수 있는 NPU(Neural Processing Unit)가 제공된다. 상기 NPU는 인공신경망 내의 다수의 레이어들을 위한 연산을 수행하여 복수의 출 력 특징맵을 생성하는 하나 이상의 PE(Processing Element)와; 그리고 상기 복수의 출력 특징맵 중에서 하나 이 상의 임의 출력 특징맵을 비트스트림으로 인코딩한 후, 전송하는 인코더를 포함할 수 있다. 상기 인코더는: 상기 복수의 출력 특징맵 중에서 하나 이상의 임의 출력 특징맵을 임의의 정보에 기초하여 선택 할 수 있다. 상기 임의의 정보는, 서버 혹은 상기 비트스트림을 수신하는 다른 NPU로부터 수신될 수 있다. 상기 임의의 정보는 상기 하나 이상의 임의 출력 특징맵에 대한 식별 정보 혹은 상기 임의 출력 특징맵에 대응 하는 레이어에 대한 식별 정보를 포함할 수 있다. 상기 임의의 정보는: 출력 특징맵의 사이즈 정보, 상기 비트스트림을 수신하는 다른 NPU에서 수행되는 머신 태 스크의 정보 그리고 상기 비트스트림을 수신하는 다른 NPU에서 연산되는 인공신경망 모델의 정보 중 하나 이상 에 기초하여 생성될 수 있다. 상기 비트스트림은, 상기 인공신경망 내의 후속 레이어들을 위한 연산을 다른 NPU가 수행하도록 하기 위해 전송 될 수 있다. 전술한 목적을 달성하기 위하여, 본 명세서의 일 개시에 따르면, 디코딩을 수행할 수 있는 NPU(Neural Processing Unit)가 제공된다. 상기 NPU는 수신되는 비트스트림을 디코딩하여 하나 이상의 임의 특징맵으로 복 원하는 디코더와; 그리고 인공신경망 모델을 위한 연산을 수행하는 하나 이상의 PE(Processing Element)를 포함 할 수 있다. 상기 복원된 하나 이상의 임의 특징맵은 상기 인공신경망 내의 다수의 레이어들 중에서 임의 레이 어의 출력 특징맵일 수 있다. 상기 하나 이상의 PE는 상기 복원된 하나 이상의 임의 특징맵을 상기 임의 레이어 의 후속 레이어의 입력 특징맵으로 활용할 수 있다. 상기 NPU는 상기 임의 레이어 혹은 상기 하나 이상의 특징맵을 상기 비트스트림을 전송하는 다른 NPU에 의해 선 택될 수 있도록 하는 임의 정보를 전송할 수 있다. 상기 임의 정보는 상기 하나 이상의 임의 특징맵에 대한 식별 정보 혹은 상기 하나 이상의 임의 특징맵에 대응 하는 레이어에 대한 식별 정보를 포함할 수 있다. 상기 임의 정보는: 특징맵의 사이즈 정보, 상기 NPU에서 수행되는 머신 태스크의 정보 그리고 상기 인공신경망 모델의 정보 중 하나 이상에 기초하여 생성될 수 있다. 또한, 전술한 목적을 달성하기 위하여, 본 명세서의 일 개시에 따르면, 시스템이 제시된다. 상기 시스템은 복수 의 레이어를 포한하는 인공신경망 모델의 제1 레이어 구간을 처리하도록 구성된 제1 신경 프로세싱 유닛; 및 상 기 인공신경망 모델의 제2 레이어 구간을 처리하도록 구성된 제2 신경 프로세싱 유닛;을 포함할 수 있다. 상기 제1 신경 프로세싱 유닛은 상기 제1 레이어 구간의 마지막 레이어의 출력 특징맵을 상기 제2 신경 프로세싱 유 닛에 입력하도록 구성될 수 있다. 상기 제1 레이어 구간의 레이어들의 가중치의 총합의 크기는 상기 제2 레이어 구간의 레이어들의 가중치의 총합 의 크기보다 상대적으로 더 작을 수 있다. 상기 제1 신경 프로세싱 유닛은 복수개이고, 상기 제2 신경 프로세싱 유닛은 상기 제1 신경 프로세싱 유닛에서 출력되는 상기 출력 특징맵 각각을 순차적으로 처리하도록 구성될 수 있다. 상기 제2 신경 프로세싱 유닛은 적어도 상기 제1 신경 프로세싱 유닛의 개수에 대응하여 가중치를 재사용하도록 구성될 수 있다. 상기 제1 신경 프로세싱 유닛의 제1 메모리의 크기는 상기 제2 신경 프로세싱 유닛의 제2 메모리 보다 상대적으 로 더 작도록 구성될 수 있다. 상기 인공신경망 모델의 제1 레이어 구간과 상기 제2 레이어 구간은 특정 레이어의 출력 특징맵의 크기를 기초 로 결정될 수 있다. 상기 인공신경망 모델의 제1 레이어 구간과 상기 제2 레이어 구간은 각각의 레이어 구간의 가중치 총합의 크기 를 기초로 결정될 수 있다. 상기 인공신경망 모델의 제1 레이어 구간의 제1 가중치의 크기는 상기 제2 레이어 구간의 제2 가중치 크기 보다 상대적으로 더 작을 수 있다."}
{"patent_id": "10-2022-0175322", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시에 의해 제시되는 NPU에 따르면, 인공신경망의 분산 처리를 통하여, 엣지형 NPU는 제조 원가와 소모 전 력을 절감할 수 있고, 서버형 NPU는 연산 부하를 절감할 수 있다."}
{"patent_id": "10-2022-0175322", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 명세서 또는 출원에 개시되어 있는 본 개시의 개념에 따른 실시 예들에 대해서 특정한 구조적 내지 단계적 설명들은 단지 본 개시의 개념에 따른 실시 예를 설명하기 위한 목적으로 예시된 것으로, 본 개시의 개념에 따 른 실시 예들은 다양한 형태로 실시될 수 있으며 본 개시의 개념에 따른 실시 예들은 다양한 형태로 실시될 수 있으며 본 명세서 또는 출원에 설명된 실시 예들에 한정되는 것으로 해석되어서는 아니 된다. 본 개시의 개념에 따른 실시 예는 다양한 변경을 가할 수 있고 여러 가지 형태를 가질 수 있으므로 특정 실시 예들을 도면에 예시하고 본 명세서 또는 출원에 상세하게 설명하고자 한다. 그러나, 이는 본 개시의 개념에 따 른 실시 예를 특정한 개시 형태에 대해 한정하려는 것이 아니며, 본 개시의 사상 및 기술 범위에 포함되는 모든 변경, 균등물 내지 대체물을 포함하는 것으로 이해되어야 한다. 제1 및/또는 제2 등의 용어는 다양한 구성 요소들을 설명하는데 사용될 수 있지만, 상기 구성 요소들은 상기 용 어들에 의해 한정되어서는 안 된다. 상기 용어들은 하나의 구성 요소를 다른 구성 요소로부터 구별하는 목적으 로만, 예컨대 본 개시의 개념에 따른 권리 범위로부터 이탈되지 않은 채, 제1 구성요소는 제2 구성요소로 명명 될 수 있고, 유사하게 제2 구성요소는 제1 구성요소로도 명명될 수 있다. 어떤 구성요소가 다른 구성요소에 \"연결되어\" 있다거나 \"접속되어\" 있다고 언급된 때에는, 그 다른 구성요소에 직접적으로 연결되어 있거나 또는 접속되어 있을 수도 있지만, 중간에 다른 구성요소가 존재할 수도 있다고 이 해되어야 할 것이다. 반면에, 어떤 구성요소가 다른 구성요소에 \"직접 연결되어\" 있다거나 \"직접 접속되어\" 있 다고 언급된 때에는, 중간에 다른 구성요소가 존재하지 않는 것으로 이해되어야 할 것이다. 구성요소들 간의 관 계를 설명하는 다른 표현들, 즉 \"~사이에\"와 \"바로 ~사이에\" 또는 \"~에 이웃하는\"과 \"~에 직접 이웃하는\" 등도 마찬가지로 해석되어야 한다. 본 명세서에서 사용한 용어는 단지 특정한 실시 예를 설명하기 위해 사용된 것으로, 본 개시를 한정하려는 의도 가 아니다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\" 또는 \"가지다\" 등의 용어는 서술된 특징, 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 본 개시가 속하는 기술 분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가지고 있다. 일 반적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의미 를 가지는 것으로 해석되어야 하며, 본 명세서에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적 인 의미로 해석되지 않는다. 실시 예를 설명함에 있어서 본 개시가 속하는 기술 분야에 익히 알려져 있고 본 개시와 직접적으로 관련이 없는 기술 내용에 대해서는 설명을 생략한다. 이는 불필요한 설명을 생략함으로써 본 개시의 요지를 흐리지 않고 더 욱 명확히 전달하기 위함이다. 이 문서는 비디오/영상 코딩에 관한 것이다. 예를 들어 이 문서에서 개시된 방법/실시예는 VVC (Versatile Video Coding) 표준 (ITU-T Rec. H.266), VVC 이후의 차세대 비디오/이미지 코딩 표준, 또는 그 이외의 비디오 코딩 관련 표준들(예를 들어, HEVC (High Efficiency Video Coding) 표준 (ITU-T Rec. H.265), EVC(essential video coding) 표준, AVS2 표준 등)과 관련될 수 있다. 이 문서에서는 비디오/영상 코딩에 관한 다양한 실시예들을 제시하며, 다른 언급이 없는 한 상기 실시예들은 서 로 조합되어 수행될 수도 있다. 이 문서에서 비디오(video)는 시간의 흐름에 따른 일련의 영상(image)들의 집합을 의미할 수 있다. 픽처 (picture)는 일반적으로 특정 시간대의 하나의 영상을 나타내는 단위를 의미하며, 슬라이스(slice)/타일(tile)는 코딩에 있어서 픽처의 일부를 구성하는 단위이다. 슬라이스/타일은 하나 이상의 CTU(coding tree unit)을 포 함할 수 있다. 하나의 픽처는 하나 이상의 슬라이스/타일로 구성될 수 있다. 하나의 픽처는 하나 이상의 타일 그룹으로 구성될 수 있다. 하나의 타일 그룹은 하나 이상의 타일들을 포함할 수 있다. 픽셀(pixel) 또는 펠(pel)은 하나의 픽처(또는 영상)을 구성하는 최소의 단위를 의미할 수 있다. 또한, 픽셀에 대응하는 용어로서 '샘플(sample)'이 사용될 수 있다. 샘플은 일반적으로 픽셀 또는 픽셀의 값을 나타낼 수 있 으며, 루마(luma) 성분의 픽셀/픽셀값만을 나타낼 수도 있고, 크로마(chroma) 성분의 픽셀/픽셀 값만을 나타낼 수도 있다. 또는 샘플은 공간 도메인에서의 픽셀값을 의미할 수도 있고, 이러한 픽셀값이 주파수 도메인으로 변 환되면 주파수 도메인에서의 변환 계수를 의미할 수도 있다. 유닛(unit)은 영상 처리의 기본 단위를 나타낼 수 있다. 유닛은 픽처의 특정 영역 및 해당 영역에 관련된 정보 중 적어도 하나를 포함할 수 있다. 하나의 유닛은 하나의 루마 블록 및 두개의 크로마(ex. cb, cr) 블록을 포함 할 수 있다. 유닛은 경우에 따라서 블록(block) 또는 영역(area) 등의 용어와 혼용하여 사용될 수 있다. 일반적 인 경우, MxN 블록은 M개의 열과 N개의 행으로 이루어진 샘플들(또는 샘플 어레이) 또는 변환 계수(transform coefficient)들의 집합(또는 어레이)을 포함할 수 있다. <용어의 정의> 이하, 본 명세서에서 제시되는 개시들의 이해를 돕고자, 본 명세서에서 사용되는 용어들에 대하여 간략하게 정 리하기로 한다. NPU: 신경 프로세싱 유닛(Neural Processing Unit)의 약어로서, CPU(Central processing unit)과 별개로 인공 신경망 모델의 연산을 위해 특화된 프로세서를 의미할 수 있다. AI accelerator: AI 연산 가속기로써, NPU를 지칭할 수 있다. ANN: 인공 신경망(artificial neural network)의 약어로서, 인간의 지능을 모방하기 위하여, 인간 뇌 속의 뉴런 들(Neurons)이 시냅스(Synapse)를 통하여 연결되는 것을 모방하여, 노드들을 레이어(Layer: 계층) 구조로 연결 시킨, 네트워크를 의미할 수 있다. 인공 신경망의 구조에 대한 정보: 레이어의 개수에 대한 정보, 레이어 내의 노드의 개수, 각 노드의 값, 연산 처리 방법에 대한 정보, 각 노드에 적용되는 가중치 행렬에 대한 정보 등을 포함하는 정보이다. 인공 신경망의 데이터 지역성에 대한 정보: 신경 프로세싱 유닛이 별개의 메모리에 요청하는 데이터 접근 요청 순서에 기반하여 신경 프로세싱 유닛이 처리하는 인공신경망모델의 연산 순서를 예측하게 하는 정보이다. DNN: 심층 신경망(Deep Neural Network)의 약어로서, 보다 높은 인공 지능을 구현하기 위하여, 인공 신경망의 은닉 레이어의 개수를 늘린 것을 의미할 수 있다. CNN: 컨볼루션 신경망(Convolutional Neural Network)의 약어로서, 인간 뇌의 시각 피질에서 영상을 처리하는 것과 유사한 기능을 하는 신경망이다. 컨볼루션 신경망은 영상처리에 적합한 것으로 알려져 있으며, 입력 데이 터의 특징들(features)을 추출하고, 특징들의 패턴을 파악하기에 용이한 것으로 알려져 있다. 커널: CNN에 적용되는 가중치 행렬을 의미할 수 있다. 커널의 값은 기계 학습을 통해서 결정될 수 있다. 이하, 첨부한 도면을 참조하여 본 개시의 바람직한 실시 예를 설명함으로써, 본 개시를 상세히 설명한다. 이하, 본 개시의 실시 예를 첨부된 도면을 참조하여 상세하게 설명한다. 도 1은 비디오/영상 코딩 시스템의 예를 개략적으로 나타낸다. 도 1을 참조하면, 비디오/영상 코딩 시스템은 소스 디바이스 및 수신 디바이스를 포함할 수 있다. 소스 디바이 스는 인코딩된 비디오(video)/영상(image) 정보 또는 데이터를 파일 또는 스트리밍 형태로 디지털 저장매체 또 는 네트워크를 통하여 수신 디바이스로 전달할 수 있다. 상기 소스 디바이스는 비디오 소스, 인코딩 장치, 전송부를 포함할 수 있다. 상기 수신 디바이스는 수신부, 디 코딩 장치 및 렌더러를 포함할 수 있다. 상기 인코딩 장치는 비디오/영상 인코딩 장치라고 불릴 수 있고, 상기 디코딩 장치는 비디오/영상 디코딩 장치라고 불릴 수 있다. 송신기는 인코딩 장치에 포함될 수 있다. 수신기는 디코딩 장치에 포함될 수 있다. 렌더러는 디스플레이부를 포함할 수도 있고, 디스플레이부는 별개의 디바이스 또는 외부 컴포넌트로 구성될 수도 있다. 비디오 소스는 비디오/영상의 캡쳐, 합성 또는 생성 과정 등을 통하여 비디오/영상을 획득할 수 있다. 비디오 소스는 비디오/영상 캡쳐 디바이스 및/또는 비디오/영상 생성 디바이스를 포함할 수 있다. 비디오/영상 캡쳐 디 바이스는 예를 들어, 하나 이상의 카메라, 이전에 캡쳐된 비디오/영상을 포함하는 비디오/영상 아카이브 등을 포함할 수 있다. 비디오/영상 생성 디바이스는 예를 들어 컴퓨터, 타블렛 및 스마트폰 등을 포함할 수 있으며 (전자적으로) 비디오/영상을 생성할 수 있다. 예를 들어, 컴퓨터 등을 통하여 가상의 비디오/영상이 생성될 수 있으며, 이 경우 관련 데이터가 생성되는 과정으로 비디오/영상 캡쳐 과정이 갈음될 수 있다. 인코딩 장치는 입력 비디오/영상을 인코딩할 수 있다. 인코딩 장치는 압축 및 코딩 효율을 위하여 예측, 변환, 양자화 등 일련의 절차를 수행할 수 있다. 인코딩된 데이터(인코딩된 비디오/영상 정보)는 비트스트림 (bitstream) 형태로 출력될 수 있다. 전송부는 비트스트림 형태로 출력된 인코딩된 비디오/영상 정보 또는 데이터를 파일 또는 스트리밍 형태로 디지 털 저장매체 또는 네트워크를 통하여 수신 디바이스의 수신부로 전달할 수 있다. 디지털 저장 매체는 USB, SD, CD, DVD, 블루레이, HDD, SSD 등 다양한 저장 매체를 포함할 수 있다. 전송부는 미리 정해진 파일 포맷을 통하 여 미디어 파일을 생성하기 위한 엘리먼트를 포함할 수 있고, 방송/통신 네트워크를 통한 전송을 위한 엘리먼트 를 포함할 수 있다. 수신부는 상기 비트스트림을 수신/추출하여 디코딩 장치로 전달할 수 있다. 디코딩 장치는 인코딩 장치의 동작에 대응하는 역양자화, 역변환, 예측 등 일련의 절차를 수행하여 비디오/영상 을 디코딩할 수 있다. 렌더러는 디코딩된 비디오/영상을 렌더링할 수 있다. 렌더링된 비디오/영상은 디스플레이부를 통하여 디스플레 이될 수 있다. 도 2는 비디오/영상 인코딩 장치의 구성을 개략적으로 설명하는 도면이다. 이하 비디오 인코딩 장치라 함은 영상 인코딩 장치를 포함할 수 있다. 도 2를 참조하면, 인코딩 장치(10a)는 영상 분할부(image partitioner, 10a-10), 예측부(predictor, 10a-20), 레지듀얼 처리부(residual processor, 10a-30), 엔트로피 인코딩부(entropy encoder, 10a-40), 가산부(adder, 10a-50), 필터링부(filter, 10a-60) 및 메모리(memory, 10a-70)를 포함하여 구성될 수 있다. 예측부(10a-20)는 인터 예측부(10a-21) 및 인트라 예측부(10a-22)를 포함할 수 있다. 레지듀얼 처리부(10a-30)는 변환부 (transformer, 10a-32), 양자화부(quantizer 10a-33), 역양자화부(dequantizer 10a-34), 역변환부(inverse transformer, 10a-35)를 포함할 수 있다. 레지듀얼 처리부(10a-30)는 감산부(subtractor, 10a-31)를 더 포함할 수 있다. 가산부(10a-50)는 복원부(reconstructor) 또는 복원 블록 생성부(reconstructed block generator)로 불릴 수 있다. 상술한 영상 분할부(10a-10), 예측부(10a-20), 레지듀얼 처리부(10a-30), 엔트로피 인코딩부 (10a-40), 가산부(10a-50) 및 필터링부(10a-60)는 실시예에 따라 하나 이상의 하드웨어 컴포넌트(예를 들어 인 코더 칩셋 또는 프로세서)에 의하여 구성될 수 있다. 또한 메모리(10a-70)는 DPB(decoded picture buffer)를 포함할 수 있고, 디지털 저장 매체에 의하여 구성될 수도 있다. 상기 하드웨어 컴포넌트는 메모리(10a-70)를 내 /외부 컴포넌트로 더 포함할 수도 있다. 영상 분할부(10a-10)는 인코딩 장치(10a)에 입력된 입력 영상(또는, 픽처, 프레임)를 하나 이상의 처리 유닛 (processing unit)으로 분할할 수 있다. 일 예로, 상기 처리 유닛은 코딩 유닛(coding unit, CU)이라고 불릴 수 있다. 이 경우 코딩 유닛은 코딩 트리 유닛(coding tree unit, CTU) 또는 최대 코딩 유닛(largest coding unit, LCU)으로부터 QTBTTT (Quad-tree binary-tree ternary-tree) 구조에 따라 재귀적으로(recursively) 분할 될 수 있다. 예를 들어, 하나의 코딩 유닛은 쿼드 트리 구조, 바이너리 트리 구조, 및/또는 터너리 구조를 기반 으로 하위(deeper) 뎁스의 복수의 코딩 유닛들로 분할될 수 있다. 이 경우 예를 들어 쿼드 트리 구조가 먼저 적 용되고 바이너리 트리 구조 및/또는 터너리 구조가 나중에 적용될 수 있다. 또는 바이너리 트리 구조가 먼저 적 용될 수도 있다. 더 이상 분할되지 않는 최종 코딩 유닛을 기반으로 본 문서에 따른 코딩 절차가 수행될 수 있 다. 이 경우 영상 특성에 따른 코딩 효율 등을 기반으로, 최대 코딩 유닛이 바로 최종 코딩 유닛으로 사용될 수 있고, 또는 필요에 따라 코딩 유닛은 재귀적으로(recursively) 보다 하위 뎁스의 코딩 유닛들로 분할되어 최적 의 사이즈의 코딩 유닛이 최종 코딩 유닛으로 사용될 수 있다. 여기서 코딩 절차라 함은 후술하는 예측, 변환, 및 복원 등의 절차를 포함할 수 있다. 다른 예로, 상기 처리 유닛은 예측 유닛(PU: Prediction Unit) 또는 변환 유닛(TU: Transform Unit)을 더 포함할 수 있다. 이 경우 상기 예측 유닛 및 상기 변환 유닛은 각각 상술한 최 종 코딩 유닛으로부터 분할 또는 파티셔닝될 수 있다. 상기 예측 유닛은 샘플 예측의 단위일 수 있고, 상기 변 환 유닛은 변환 계수를 유도하는 단위 및/또는 변환 계수로부터 레지듀얼 신호(residual signal)를 유도하는 단 위일 수 있다.유닛은 경우에 따라서 블록(block) 또는 영역(area) 등의 용어와 혼용하여 사용될 수 있다. 일반적인 경우, MxN 블록은 M개의 열과 N개의 행으로 이루어진 샘플들 또는 변환 계수(transform coefficient)들의 집합을 나타낼 수 있다. 샘플은 일반적으로 픽셀 또는 픽셀의 값을 나타낼 수 있으며, 휘도(luma) 성분의 픽셀/픽셀값만을 나 타낼 수도 있고, 채도(chroma) 성분의 픽셀/픽셀 값만을 나타낼 수도 있다. 샘플은 하나의 픽처(또는 영상)을 픽셀(pixel) 또는 펠(pel)에 대응하는 용어로서 사용될 수 있다. 감산부(10a-31)는 입력 영상 신호(원본 블록, 원본 샘플들 또는 원본 샘플 어레이)에서 예측부(10a-20)로부터 출력된 예측 신호(예측된 블록, 예측 샘플들 또는 예측 샘플 어레이)를 감산하여 레지듀얼 신호(레지듀얼 블록, 레지듀얼 샘플들 또는 레지듀얼 샘플 어레이)를 생성할 수 있고, 생성된 레지듀얼 신호는 변환부(10a-32)로 전 송된다. 예측부(10a-20)는 처리 대상 블록(이하, 현재 블록이라 함)에 대한 예측을 수행하고, 상기 현재 블록에 대한 예측 샘플들을 포함하는 예측된 블록(predicted block)을 생성할 수 있다. 예측부(10a-20)는 현재 블록 또 는 CU 단위로 인트라 예측이 적용되는지 또는 인터 예측이 적용되는지 결정할 수 있다. 예측부는 각 예측모드에 대한 설명에서 후술하는 바와 같이 예측 모드 정보 등 예측에 관한 다양한 정보를 생성하여 엔트로피 인코딩부 (10a-40)로 전달할 수 있다. 예측에 관한 정보는 엔트로피 인코딩부(10a-40)에서 인코딩되어 비트스트림 형태로 출력될 수 있다. 인트라 예측부(10a-22)는 현재 픽처 내의 샘플들을 참조하여 현재 블록을 예측할 수 있다. 상기 참조되는 샘플 들은 예측 모드에 따라 상기 현재 블록의 주변(neighbor)에 위치할 수 있고, 또는 떨어져서 위치할 수도 있다. 인트라 예측에서 예측 모드들은 복수의 비방향성 모드와 복수의 방향성 모드를 포함할 수 있다. 비방향성 모드 는 예를 들어 DC 모드 및 플래너 모드(Planar 모드)를 포함할 수 있다. 방향성 모드는 예측 방향의 세밀한 정도 에 따라 예를 들어 33개의 방향성 예측 모드 또는 65개의 방향성 예측 모드를 포함할 수 있다. 다만, 이는 예시 로서 설정에 따라 그 이상 또는 그 이하의 개수의 방향성 예측 모드들이 사용될 수 있다. 인트라 예측부(10a- 22)는 주변 블록에 적용된 예측 모드를 이용하여, 현재 블록에 적용되는 예측 모드를 결정할 수도 있다. 인터 예측부(10a-21)는 참조 픽처 상에서 움직임 벡터에 의해 특정되는 참조 블록(참조 샘플 어레이)을 기반으 로, 현재 블록에 대한 예측된 블록을 유도할 수 있다. 이때, 인터 예측 모드에서 전송되는 움직임 정보의 양을 줄이기 위해 주변 블록과 현재 블록 간의 움직임 정보의 상관성에 기초하여 움직임 정보를 블록, 서브블록 또는 샘플 단위로 예측할 수 있다. 상기 움직임 정보는 움직임 벡터 및 참조 픽처 인덱스를 포함할 수 있다. 상기 움 직임 정보는 인터 예측 방향(L0 예측, L1 예측, Bi 예측 등) 정보를 더 포함할 수 있다. 인터 예측의 경우에, 주변 블록은 현재 픽처 내에 존재하는 공간적 주변 블록(spatial neighboring block)과 참조 픽처에 존재하는 시간적 주변 블록(temporal neighboring block)을 포함할 수 있다. 상기 참조 블록을 포함하는 참조 픽처와 상 기 시간적 주변 블록을 포함하는 참조 픽처는 동일할 수도 있고, 다를 수도 있다. 상기 시간적 주변 블록은 동 일 위치 참조 블록(collocated reference block), 동일 위치 CU(colCU) 등의 이름으로 불릴 수 있으며, 상기 시간적 주변 블록을 포함하는 참조 픽처는 동일 위치 픽처(collocated picture, colPic)라고 불릴 수도 있다. 예를 들어, 인터 예측부(10a-21)는 주변 블록들을 기반으로 움직임 정보 후보 리스트를 구성하고, 상기 현재 블 록의 움직임 벡터 및/또는 참조 픽처 인덱스를 도출하기 위하여 어떤 후보가 사용되는지를 지시하는 정보를 생 성할 수 있다. 다양한 예측 모드를 기반으로 인터 예측이 수행될 수 있으며, 예를 들어 스킵 모드와 머지 모드 의 경우에, 인터 예측부(10a-21)는 주변 블록의 움직임 정보를 현재 블록의 움직임 정보로 이용할 수 있다. 스 킵 모드의 경우, 머지 모드와 달리 레지듀얼 신호가 전송되지 않을 수 있다. 움직임 정보 예측(motion vector prediction, MVP) 모드의 경우, 주변 블록의 움직임 벡터를 움직임 벡터 예측자(motion vector predictor)로 이용하고, 움직임 벡터 차분(motion vector difference)을 시그널링함으로써 현재 블록의 움직임 벡터를 지시할 수 있다. 예측부(10a-20)는 후술하는 다양한 예측 방법을 기반으로 예측 신호를 생성할 수 있다. 예를 들어, 예측부는 하 나의 블록에 대한 예측을 위하여 인트라 예측 또는 인터 예측을 적용할 수 있을 뿐 아니라, 인트라 예측과 인터 예측을 동시에 적용할 수 있다. 이는 combined inter and intra prediction (CIIP)라고 불릴 수 있다. 또한, 예측부는 블록에 대한 예측을 위하여 인트라 블록 카피(intra block copy, IBC)를 수행할 수도 있다. 상기 인트 라 블록 카피는 예를 들어 SCC(screen content coding) 등과 같이 게임 등의 컨텐츠 영상/동영상 코딩을 위하여 사용될 수 있다. IBC는 기본적으로 현재 픽처 내에서 예측을 수행하나 현재 픽처 내에서 참조 블록을 도출하는 점에서 인터 예측과 유사하게 수행될 수 있다. 즉, IBC는 본 문서에서 설명되는 인터 예측 기법들 중 적어도 하 나를 이용할 수 있다. 인터 예측부(10a-21) 및/또는 인트라 예측부(10a-22)를 통해 생성된 예측 신호는 복원 신호를 생성하기 위해 이 용되거나 레지듀얼 신호를 생성하기 위해 이용될 수 있다. 변환부(10a-32)는 레지듀얼 신호에 변환 기법을 적용하여 변환 계수들(transform coefficients)를 생성할 수 있다. 예를 들어, 변환 기법은 DCT(Discrete Cosine Transform), DST(Discrete Sine Transform), GBT(Graph-Based Transform), 또는 CNT(Conditionally Non- linear Transform) 등을 포함할 수 있다. 여기서, GBT는 픽셀 간의 관계 정보를 그래프로 표현한다고 할 때 이 그래프로부터 얻어진 변환을 의미한다. CNT는 이전에 복원된 모든 픽셀(all previously reconstructed pixel) 를 이용하여 예측 신호를 생성하고 그에 기초하여 획득되는 변환을 의미한다. 또한, 변환 과정은 정사각형의 동 일한 크기를 갖는 픽셀 블록에 적용될 수도 있고, 정사각형이 아닌 가변 크기의 블록에도 적용될 수 있다. 양자화부(10a-33)는 변환 계수들을 양자화하여 엔트로피 인코딩부(10a-40)로 전송되고, 엔트로피 인코딩부(10a- 40)는 양자화된 신호(양자화된 변환 계수들에 관한 정보)를 인코딩하여 비트스트림으로 출력할 수 있다. 상기 양자화된 변환 계수들에 관한 정보는 레지듀얼 정보라고 불릴 수 있다. 양자화부(10a-33)는 계수 스캔 순서 (scan order)를 기반으로 블록 형태의 양자화된 변환 계수들을 1차원 벡터 형태로 재정렬할 수 있고, 상기 1차 원 벡터 형태의 양자화된 변환 계수들을 기반으로 상기 양자화된 변환 계수들에 관한 정보를 생성할 수도 있다. 엔트로피 인코딩부(10a-40)는 예를 들어 지수 골롬(exponential Golomb), CAVLC(context-adaptive variable length coding), CABAC(context-adaptive binary arithmetic coding) 등과 같은 다양한 인코딩 방법을 수행할 수 있다. 엔트로피 인코딩부(10a-40)는 양자화된 변환 계수들 외 비디오/이미지 복원에 필요한 정보들(예컨대 신택스 요 소들(syntax elements)의 값 등)을 함께 또는 별도로 인코딩할 수도 있다. 인코딩된 정보(ex. 인코딩된 비디오/ 영상 정보)는 비트스트림 형태로 NAL(network abstraction layer) 유닛 단위로 전송 또는 저장될 수 있다. 상기 비디오/영상 정보는 어댑테이션 파라미터 세트(APS), 픽처 파라미터 세트(PPS), 시퀀스 파라미터 세트(SPS) 또 는 비디오 파라미터 세트(VPS) 등 다양한 파라미터 세트에 관한 정보를 더 포함할 수 있다. 또한 상기 비디오/ 영상 정보는 일반 제한 정보(general constraint information)을 더 포함할 수 있다. 본 문서에서 후술되는 시 그널링/전송되는 정보 및/또는 신택스 요소들은 상술한 인코딩 절차를 통하여 인코딩되어 상기 비트스트림에 포 함될 수 있다. 상기 비트스트림은 네트워크를 통하여 전송될 수 있고, 또는 디지털 저장매체에 저장될 수 있다. 여기서 네트워크는 방송망 및/또는 통신망 등을 포함할 수 있고, 디지털 저장매체는 USB, SD, CD, DVD, 블루레 이, HDD, SSD 등 다양한 저장매체를 포함할 수 있다. 엔트로피 인코딩부(10a-40)로부터 출력된 신호는 전송하는 전송부(미도시) 및/또는 저장하는 저장부(미도시)가 인코딩 장치(10a)의 내/외부 엘리먼트로서 구성될 수 있고, 또는 전송부는 엔트로피 인코딩부(10a-40)에 포함될 수도 있다. 양자화부(10a-33)로부터 출력된 양자화된 변환 계수들은 예측 신호를 생성하기 위해 이용될 수 있다. 예를 들어, 양자화된 변환 계수들에 역양자화부(10a-34) 및 역변환부(10a-35)를 통해 역양자화 및 역변환을 적용함으 로써 레지듀얼 신호(레지듀얼 블록 or 레지듀얼 샘플들)를 복원할 수 있다. 가산부(10a-50)는 복원된 레지듀얼 신호를 예측부(10a-20)로부터 출력된 예측 신호에 더함으로써 복원(reconstructed) 신호(복원 픽처, 복원 블록, 복원 샘플들 또는 복원 샘플 어레이)가 생성될 수 있다. 스킵 모드가 적용된 경우와 같이 처리 대상 블록에 대 한 레지듀얼이 없는 경우, 예측된 블록이 복원 블록으로 사용될 수 있다. 생성된 복원 신호는 현재 픽처 내 다 음 처리 대상 블록의 인트라 예측을 위하여 사용될 수 있고, 후술하는 바와 같이 필터링을 거쳐서 다음 픽처의 인터 예측을 위하여 사용될 수도 있다. 한편 픽처 인코딩 및/또는 복원 과정에서 LMCS (luma mapping with chroma scaling)가 적용될 수도 있다. 필터링부(10a-60)는 복원 신호에 필터링을 적용하여 주관적/객관적 화질을 향상시킬 수 있다. 예를 들어 필터링 부(10a-60)는 복원 픽처에 다양한 필터링 방법을 적용하여 수정된(modified) 복원 픽처를 생성할 수 있고, 상기 수정된 복원 픽처를 메모리(10a-70), 구체적으로 메모리(10a-70)의 DPB에 저장할 수 있다. 상기 다양한 필터링 방법은 예를 들어, 디블록킹 필터링, 샘플 적응적 오프셋(sample adaptive offset, SAO), 적응적 루프 필터 (adaptive loop filter), 양방향 필터(bilateral filter) 등을 포함할 수 있다. 필터링부(10a-60)는 각 필터링 방법에 대한 설명에서 후술하는 바와 같이 필터링에 관한 다양한 정보를 생성하여 엔트로피 인코딩부(10a-90)로 전달할 수 있다. 필터링 관한 정보는 엔트로피 인코딩부(10a-90)에서 인코딩되어 비트스트림 형태로 출력될 수 있다. 메모리(10a-70)에 전송된 수정된 복원 픽처는 인터 예측부(10a-80)에서 참조 픽처로 사용될 수 있다. 인코딩 장 치는 이를 통하여 인터 예측이 적용되는 경우, 인코딩 장치(10a)와 디코딩 장치에서의 예측 미스매치를 피할 수 있고, 부호화 효율도 향상시킬 수 있다. 메모리(10a-70)의 DPB는 수정된 복원 픽처를 인터 예측부(10a-21)에서의 참조 픽처로 사용하기 위해 저장할 수 있다. 메모리(10a-70)는 현재 픽처 내 움직임 정보가 도출된(또는 인코딩된) 블록의 움직임 정보 및/또는 이미복원된 픽처 내 블록들의 움직임 정보를 저장할 수 있다. 상기 저장된 움직임 정보는 공간적 주변 블록의 움직 임 정보 또는 시간적 주변 블록의 움직임 정보로 활용하기 위하여 인터 예측부(10a-21)에 전달할 수 있다. 메모 리(10a-70)는 현재 픽처 내 복원된 블록들의 복원 샘플들을 저장할 수 있고, 인트라 예측부(10a-22)에 전달할 수 있다. 도 3은 비디오/영상 디코딩 장치의 구성을 개략적으로 설명하는 도면이다. 도 3을 참조하면, 디코딩 장치(10b)는 엔트로피 디코딩부(entropy decoder, 10b-10), 레지듀얼 처리부 (residual processor, 10b-20), 예측부(predictor, 10b-30), 가산부(adder, 10b-40), 필터링부(filter, 10b- 50) 및 메모리(memory, 10b-60)를 포함하여 구성될 수 있다. 예측부(10b-30)는 인터 예측부(10b-31) 및 인트라 예측부(10b-32)를 포함할 수 있다. 레지듀얼 처리부(10b-20)는 역양자화부(dequantizer, 10b-21) 및 역변환부 (inverse transformer, 10b-21)를 포함할 수 있다. 상술한 엔트로피 디코딩부(10b-10), 레지듀얼 처리부(10b- 20), 예측부(10b-30), 가산부(10b-40) 및 필터링부(10b-50)는 실시예에 따라 하나의 하드웨어 컴포넌트(예를 들 어 디코더 칩셋 또는 프로세서)에 의하여 구성될 수 있다. 또한 메모리(10b-60)는 DPB(decoded picture buffer)를 포함할 수 있고, 디지털 저장 매체에 의하여 구성될 수도 있다. 상기 하드웨어 컴포넌트는 메모리 (10b-60)을 내/외부 컴포넌트로 더 포함할 수도 있다. 비디오/영상 정보를 포함하는 비트스트림이 입력되면, 디코딩 장치(10b)는 도 2의 인코딩 장치에서 비디오/영상 정보가 처리된 프로세스에 대응하여 영상을 복원할 수 있다. 예를 들어, 디코딩 장치(10b)는 상기 비트스트림으 로부터 획득한 블록 분할 관련 정보를 기반으로 유닛들/블록들을 도출할 수 있다. 디코딩 장치(10b)는 인코딩 장치에서 적용된 처리 유닛을 이용하여 디코딩을 수행할 수 있다. 따라서 디코딩의 처리 유닛은 예를 들어 코딩 유닛일 수 있고, 코딩 유닛은 코딩 트리 유닛 또는 최대 코딩 유닛으로부터 쿼드 트리 구조, 바이너리 트리 구 조 및/또는 터너리 트리 구조를 따라서 분할될 수 있다. 코딩 유닛으로부터 하나 이상의 변환 유닛이 도출될 수 있다. 그리고, 디코딩 장치(10b)를 통해 디코딩 및 출력된 복원 영상 신호는 재생 장치를 통해 재생될 수 있다. 디코딩 장치(10b)는 도 2의 인코딩 장치로부터 출력된 신호를 비트스트림 형태로 수신할 수 있고, 수신된 신호 는 엔트로피 디코딩부(10b-10)를 통해 디코딩될 수 있다. 예를 들어, 엔트로피 디코딩부(10b-10)는 상기 비트스 트림을 파싱하여 영상 복원(또는 픽처 복원)에 필요한 정보(ex. 비디오/영상 정보)를 도출할 수 있다. 상기 비 디오/영상 정보는 어댑테이션 파라미터 세트(APS), 픽처 파라미터 세트(PPS), 시퀀스 파라미터 세트(SPS) 또는 비디오 파라미터 세트(VPS) 등 다양한 파라미터 세트에 관한 정보를 더 포함할 수 있다. 또한 상기 비디오/영상 정보는 일반 제한 정보(general constraint information)을 더 포함할 수 있다. 디코딩 장치는 상기 파라미터 세트에 관한 정보 및/또는 상기 일반 제한 정보를 더 기반으로 픽처를 디코딩할 수 있다. 본 문서에서 후술되는 시그널링/수신되는 정보 및/또는 신택스 요소들은 상기 디코딩 절차를 통하여 디코딩되어 상기 비트스트림으로부터 획득될 수 있다. 예컨대, 엔트로피 디코딩부(10b-10)는 지수 골롬 부호화, CAVLC 또는 CABAC 등의 코딩 방법을 기초로 비트스트림 내 정보를 디코딩하고, 영상 복원에 필요한 신택스 엘리 먼트의 값, 레지듀얼에 관한 변환 계수의 양자화된 값 들을 출력할 수 있다. 보다 상세하게, CABAC 엔트로피 디 코딩 방법은, 비트스트림에서 각 구문 요소에 해당하는 빈을 수신하고, 디코딩 대상 구문 요소 정보와 주변 및 디코딩 대상 블록의 디코딩 정보 혹은 이전 단계에서 디코딩된 심볼/빈의 정보를 이용하여 문맥(context) 모델 을 결정하고, 결정된 문맥 모델에 따라 빈(bin)의 발생 확률을 예측하여 빈의 산술 디코딩(arithmetic decoding)를 수행하여 각 구문 요소의 값에 해당하는 심볼을 생성할 수 있다. 이때, CABAC 엔트로피 디코딩 방 법은 문맥 모델 결정 후 다음 심볼/빈의 문맥 모델을 위해 디코딩된 심볼/빈의 정보를 이용하여 문맥 모델을 업 데이트할 수 있다. 엔트로피 디코딩부(10b-10)에서 디코딩된 정보 중 예측에 관한 정보는 예측부(10b-30)로 제 공되고, 엔트로피 디코딩부(10b-10)에서 엔트로피 디코딩이 수행된 레지듀얼에 대한 정보, 즉 양자화된 변환 계 수들 및 관련 파라미터 정보는 역양자화부(10b-21)로 입력될 수 있다. 또한, 엔트로피 디코딩부(10b-10)에서 디코딩된 정보 중 필터링에 관한 정보는 필터링부(10b-50)으로 제공될 수 있다. 한편, 인코딩 장치로부터 출력된 신호를 수신하는 수신부(미도시)가 디코딩 장치(10b)의 내/외부 엘리먼 트로서 더 구성될 수 있고, 또는 수신부는 엔트로피 디코딩부(10b-10)의 구성요소일 수도 있다. 한편, 본 문서 에 따른 디코딩 장치는 비디오/영상/픽처 디코딩 장치라고 불릴 수 있고, 상기 디코딩 장치는 정보 디코더(비디 오/영상/픽처 정보 디코더) 및 샘플 디코더(비디오/영상/픽처 샘플 디코더)로 구분할 수도 있다. 상기 정보 디 코더는 상기 엔트로피 디코딩부(10b-10)를 포함할 수 있고, 상기 샘플 디코더는 상기 역양자화부(10b-21), 역변 환부(10b-22), 예측부(10b-30), 가산부(10b-40), 필터링부(10b-50) 및 메모리(10b-60) 중 적어도 하나를 포함 할 수 있다.역양자화부(10b-21)에서는 양자화된 변환 계수들을 역양자화하여 변환 계수들을 출력할 수 있다. 역양자화부 (10b-21)는 양자화된 변환 계수들을 2차원의 블록 형태로 재정렬할 수 있다. 이 경우 상기 재정렬은 인코딩 장 치에서 수행된 계수 스캔 순서를 기반하여 재정렬을 수행할 수 있다. 역양자화부(10b-21)는 양자화 파라미터(예 를 들어 양자화 스텝 사이즈 정보)를 이용하여 양자화된 변환 계수들에 대한 역양자화를 수행하고, 변환 계수들 (transform coefficient)를 획득할 수 있다. 역변환부(10b-22)에서는 변환 계수들를 역변환하여 레지듀얼 신호(레지듀얼 블록, 레지듀얼 샘플 어레이)를 획 득하게 된다. 예측부는 현재 블록에 대한 예측을 수행하고, 상기 현재 블록에 대한 예측 샘플들을 포함하는 예측된 블록 (predicted block)을 생성할 수 있다. 예측부는 엔트로피 디코딩부(10b-10)로부터 출력된 상기 예측에 관한 정 보를 기반으로 상기 현재 블록에 인트라 예측이 적용되는지 또는 인터 예측이 적용되는지 결정할 수 있고, 구체 적인 인트라/인터 예측 모드를 결정할 수 있다. 예측부는 후술하는 다양한 예측 방법을 기반으로 예측 신호를 생성할 수 있다. 예를 들어, 예측부는 하나의 블 록에 대한 예측을 위하여 인트라 예측 또는 인터 예측을 적용할 수 있을 뿐 아니라, 인트라 예측과 인터 예측을 동시에 적용할 수 있다. 이는 combined inter and intra prediction (CIIP)라고 불릴 수 있다. 또한, 예측부는 블록에 대한 예측을 위하여 인트라 블록 카피(intra block copy, IBC)를 수행할 수도 있다. 상기 인트라 블록 카피는 예를 들어 SCC(screen content coding) 등과 같이 게임 등의 컨텐츠 영상/동영상 코딩을 위하여 사용될 수 있다. IBC는 기본적으로 현재 픽처 내에서 예측을 수행하나 현재 픽처 내에서 참조 블록을 도출하는 점에서 인터 예측과 유사하게 수행될 수 있다. 즉, IBC는 본 문서에서 설명되는 인터 예측 기법들 중 적어도 하나를 이 용할 수 있다. 인트라 예측부(10b-32)는 현재 픽처 내의 샘플들을 참조하여 현재 블록을 예측할 수 있다. 상기 참조되는 샘플 들은 예측 모드에 따라 상기 현재 블록의 주변(neighbor)에 위치할 수 있고, 또는 떨어져서 위치할 수도 있다. 인트라 예측에서 예측 모드들은 복수의 비방향성 모드와 복수의 방향성 모드를 포함할 수 있다. 인트라 예측부 (10b-32)는 주변 블록에 적용된 예측 모드를 이용하여, 현재 블록에 적용되는 예측 모드를 결정할 수도 있다. 인터 예측부(10b-31)는 참조 픽처 상에서 움직임 벡터에 의해 특정되는 참조 블록(참조 샘플 어레이)을 기반으 로, 현재 블록에 대한 예측된 블록을 유도할 수 있다. 이때, 인터 예측 모드에서 전송되는 움직임 정보의 양을 줄이기 위해 주변 블록과 현재 블록 간의 움직임 정보의 상관성에 기초하여 움직임 정보를 블록, 서브블록 또는 샘플 단위로 예측할 수 있다. 상기 움직임 정보는 움직임 벡터 및 참조 픽처 인덱스를 포함할 수 있다. 상기 움 직임 정보는 인터 예측 방향(L0 예측, L1 예측, Bi 예측 등) 정보를 더 포함할 수 있다. 인터 예측의 경우에, 주변 블록은 현재 픽처 내에 존재하는 공간적 주변 블록(spatial neighboring block)과 참 조 픽처에 존재하는 시간적 주변 블록(temporal neighboring block)을 포함할 수 있다. 예를 들어, 인터 예측부 (10b-31)는 주변 블록들을 기반으로 움직임 정보 후보 리스트를 구성하고, 수신한 후보 선택 정보를 기반으로 상기 현재 블록의 움직임 벡터 및/또는 참조 픽처 인덱스를 도출할 수 있다. 다양한 예측 모드를 기반으로 인터 예측이 수행될 수 있으며, 상기 예측에 관한 정보는 상기 현재 블록에 대한 인터 예측의 모드를 지시하는 정보 를 포함할 수 있다. 가산부(10b-40)는 획득된 레지듀얼 신호를 예측부(10b-30)로부터 출력된 예측 신호(예측된 블록, 예측 샘플 어 레이)에 더함으로써 복원 신호(복원 픽처, 복원 블록, 복원 샘플 어레이)를 생성할 수 있다. 스킵 모드가 적용 된 경우와 같이 처리 대상 블록에 대한 레지듀얼이 없는 경우, 예측된 블록이 복원 블록으로 사용될 수 있다. 가산부(10b-40)는 복원부 또는 복원 블록 생성부라고 불릴 수 있다. 생성된 복원 신호는 현재 픽처 내 다음 처 리 대상 블록의 인트라 예측을 위하여 사용될 수 있고, 후술하는 바와 같이 필터링을 거쳐서 출력될 수도 있고 또는 다음 픽처의 인터 예측을 위하여 사용될 수도 있다. 한편, 픽처 디코딩 과정에서 LMCS (luma mapping with chroma scaling)가 적용될 수도 있다. 필터링부(10b-50)는 복원 신호에 필터링을 적용하여 주관적/객관적 화질을 향상시킬 수 있다. 예를 들어 필터링 부(10b-50)는 복원 픽처에 다양한 필터링 방법을 적용하여 수정된(modified) 복원 픽처를 생성할 수 있고, 상기 수정된 복원 픽처를 메모리, 구체적으로 메모리(10b-60)의 DPB에 전송할 수 있다. 상기 다양한 필터링 방법 은 예를 들어, 디블록킹 필터링, 샘플 적응적 오프셋(sample adaptive offset), 적응적 루프 필터(adaptive loop filter), 양방향 필터(bilateral filter) 등을 포함할 수 있다.메모리(10b-60)의 DPB에 저장된 (수정된) 복원 픽처는 인터 예측부(10b-31)에서 참조 픽쳐로 사용될 수 있다. 메모리(10b-60)는 현재 픽처 내 움직임 정보가 도출된(또는 디코딩된) 블록의 움직임 정보 및/또는 이미 복원된 픽처 내 블록들의 움직임 정보를 저장할 수 있다. 상기 저장된 움직임 정보는 공간적 주변 블록의 움직임 정보 또는 시간적 주변 블록의 움직임 정보로 활용하기 위하여 인터 예측부(10b-31)에 전달할 수 있다. 메모리(10b- 60)는 현재 픽처 내 복원된 블록들의 복원 샘플들을 저장할 수 있고, 인트라 예측부(10b-32)에 전달할 수 있다. 본 명세서에서, 디코딩 장치(10b)의 예측부(10b-30), 역양자화부(10b-21), 역변환부(10b-22) 및 필터링부(10b- 50) 등에서 설명된 실시예들은 각각 인코딩 장치(10a)의 예측부(10a-20), 역양자화부(10a-34), 역변환부(10a- 35) 및 필터링부(10a-60) 등에도 동일 또는 대응되도록 적용될 수 있다. 상술한 바와 같이 비디오 코딩을 수행함에 있어 압축 효율을 높이기 위하여 예측을 수행한다. 이를 통하여 코딩 대상 블록인 현재 블록에 대한 예측 샘플들을 포함하는 예측된 블록을 생성할 수 있다. 여기서 상기 예측된 블 록은 공간 도메인(또는 픽셀 도메인)에서의 예측 샘플들을 포함한다. 상기 예측된 블록은 인코딩 장치 및 디코 딩 장치에서 동일하게 도출되며, 상기 인코딩 장치는 원본 블록의 원본 샘플 값 자체가 아닌 상기 원본 블록과 상기 예측된 블록 간의 레지듀얼에 대한 정보(레지듀얼 정보)를 디코딩 장치로 시그널링함으로써 영상 코딩 효 율을 높일 수 있다. 디코딩 장치는 상기 레지듀얼 정보를 기반으로 레지듀얼 샘플들을 포함하는 레지듀얼 블록 을 도출하고, 상기 레지듀얼 블록과 상기 예측된 블록을 합하여 복원 샘플들을 포함하는 복원 블록을 생성할 수 있고, 복원 블록들을 포함하는 복원 픽처를 생성할 수 있다. 상기 레지듀얼 정보는 변환 및 양자화 절차를 통하여 생성될 수 있다. 예를 들어, 인코딩 장치는 상기 원본 블 록과 상기 예측된 블록 간의 레지듀얼 블록을 도출하고, 상기 레지듀얼 블록에 포함된 레지듀얼 샘플들(레지듀 얼 샘플 어레이)에 변환 절차를 수행하여 변환 계수들을 도출하고, 상기 변환 계수들에 양자화 절차를 수행하여 양자화된 변환 계수들을 도출하여 관련된 레지듀얼 정보를 (비트스트림을 통하여) 디코딩 장치로 시그널링할 수 있다. 여기서 상기 레지듀얼 정보는 상기 양자화된 변환 계수들의 값 정보, 위치 정보, 변환 기법, 변환 커널, 양자화 파라미터 등의 정보를 포함할 수 있다. 디코딩 장치는 상기 레지듀얼 정보를 기반으로 역양자화/역변환 절차를 수행하고 레지듀얼 샘플들(또는 레지듀얼 블록)을 도출할 수 있다. 디코딩 장치는 예측된 블록과 상기 레지듀얼 블록을 기반으로 복원 픽처를 생성할 수 있다. 인코딩 장치는 또한 이후 픽처의 인터 예측을 위한 참 조를 위하여 양자화된 변환 계수들을 역양자화/역변환하여 레지듀얼 블록을 도출하고, 이를 기반으로 복원 픽처 를 생성할 수 있다. <NPU(Neural Processing Unit)> 도 4는 본 개시에 따른 신경 프로세싱 유닛을 설명하는 개략적인 개념도이다. 도 4에 도시된 신경 프로세싱 유닛(neural processing unit, NPU)은 인공신경망을 위한 동작을 수행하도록 특화된 프로세서이다. 인공신경망은 여러 입력 또는 자극이 들어오면 각각 가중치를 곱해 더해주고, 추가적으로 편차를 더한 값을 활 성화 함수를 통해 변형하여 전달하는 인공 뉴런들이 모인 네트워크를 의미한다. 이렇게 학습된 인공신경망은 입 력 데이터로부터 추론(inference) 결과를 출력하는데 사용될 수 있다. NPU는 전기/전자 회로로 구현된 반도체일 수 있다. 전기/전자 회로라 함은 수많은 전자 소자, (예컨대 트렌지스터, 커패시터)를 포함하는 것을 의미할 수 있다. Transformer 및/또는 CNN 기반의 인공신경망모델인 경우, NPU는 행렬 곱셈 연산, 합성곱 연산, 등을 인공 신경망의 구조(architecture)에 따라 선별하여, 처리할 수 있다. 예를 들어, 합성곱 신경망(CNN)의 레이어 각각에서, 입력 데이터에 해당하는 입력 특징맵(Input feature map)과 가중치(Weight)에 해당하는 커널(kernel)은 복수의 채널로 구성된 행렬일 수 있다. 입력 특징맵과 커널의 합성 곱 연산이 수행되며, 각 채널에서 합성곱 연산과 풀링 출력 특징맵(output feature map)이 생성된다. 출력 특징 맵에 활성화 함수를 적용하여 해당 채널의 활성화맵(activation map)이 생성된다. 이후, 활성화맵에 대한 풀링 이 적용될 수 있다. 여기서 포괄적으로 활성화맵은 출력 특징맵으로 지칭될 수 있다. 단, 본 개시의 예시들은 이에 제한되지 않으며, 출력 특징맵은 행렬 곱셈 연산 또는 합성곱 연산등이 적용된 것 을 의미한다. 부연 설명하면, 본 개시의 예시들에 따른 출력 특징맵은 포괄적인 의미로 해석되어야 한다. 예를 들면, 출력 특 징맵은 행렬 곱셈 연산 또는 합성곱 연산 결과값일 수 있다. 이에, 복수의 프로세싱 엘리먼트는 추가 알고리즘을 위한 처리 회로부를 더 포함하도록 변형 실시되는 것도 가능하다. NPU는 상술한 인공신경망 연산에 필요한 합성곱 및 행렬 곱셈을 처리하기 위한 복수의 프로세싱 엘리먼트 를 포함하도록 구성될 수 있다. NPU는 상술한 인공신경망 연산에 필요한 행렬 곱셈 연산, 합성곱 연산, 활성화 함수 연산, 풀링 연산, 스 트라이드 연산, 배치 정규화 연산, 스킵 커넥션 연산, 접합 연산, 양자화 연산, 클리핑 연산, 패딩 연산에 최적 화된 각각의 처리 회로를 포함하도록 구성될 수 있다. 예를 들면, NPU는 상술한 알고리즘들 중 활성화 함수 연산, 풀링 연산, 스트라이드 연산, 배치 정규화 연 산, 스킵 커넥션 연산, 접합 연산, 양자화 연산, 클리핑 연산, 패딩 연산 중 적어도 하나를 처리하기 위한 SFU를 포함하도록 구성될 수 있다. 구체적으로, NPU는 복수의 프로세싱 엘리먼트(processing element: PE) , SFU, NPU 내부 메모 리, NPU 컨트롤러, 및 NPU 인터페이스를 포함할 수 있다. 복수의 프로세싱 엘리먼트, SFU, NPU 내부 메모리, NPU 컨트롤러, 및 NPU 인터페이스 각각은 수많은 트렌지스터들이 연결된 반도체 회로일 수 있다. 따라서, 이들 중 일부는 육안으로는 식별되어 구분되기 어려울 수 있고, 동작에 의해서만 식별될 수 있다. 예컨대, 임의 회로는 복수의 프로세싱 엘리먼트으로 동작하기도 하고, 혹은 NPU 컨트롤러로 동작될 수도 있다. NPU 컨트롤러는 NPU의 인공신경망 추론 동작을 제어하도록 구성된 제어부의 기능을 수행 하도록 구성될 수 있다. NPU는 복수의 프로세싱 엘리먼트 및 SFU에서 추론될 수 있는 인공신경망모델의 파라미터를 저장 하도록 구성된 NPU 내부 메모리, 및 복수의 프로세싱 엘리먼트, SFU, 및 NPU 내부 메모리(12 0)의 연산 스케줄을 제어하도록 구성된 스케줄러를 포함하는 NPU 컨트롤러를 포함할 수 있다. NPU는 SVC 또는 SFC를 이용한 인코딩 및 디코딩 방식에 대응되어 특징맵을 처리하도록 구성될 수 있다. 복수의 프로세싱 엘리먼트는 인공신경망을 위한 동작의 일부를 수행할 수 있다. SFU는 인공신경망을 위한 동작의 다른 일부를 수행할 수 있다. NPU는 복수의 프로세싱 엘리먼트와 SFU를 사용하여 인공신경망모델의 연산을 하드웨어적으로 가 속하도록 구성될 수 있다. NPU 인터페이스는 시스템 버스를 통해서 NPU와 연결된 다양한 구성요소들, 예컨대 메모리와 통신할 수 있다. NPU 컨트롤러는 신경 프로세싱 유닛의 추론 연산을 위한 복수의 프로세싱 엘리먼트의 연산, SFU의 연산 및 NPU 내부 메모리의 읽기 및 쓰기 순서를 제어하도록 구성된 스케줄러를 포함할 수 있 다. NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 복수의 프로세싱 엘리먼트, SFU, 및 NPU 내부 메모리를 제어하도록 구성될 수 있다. NPU 컨트롤러 내의 스케줄러는 복수의 프로세싱 엘리먼트 및 SFU에서 작동할 인공신경망모델의 구조를 분석하거나 또는 이미 분석된 정보를 제공받을 수 있다. 예를 들면, 인공신경망모델이 포함할 수 있는 인공신경망의 데이터는 각각의 레이어의 노드 데이터(즉, 특징맵), 레이어들의 배치 데이터, 지역성 정보 또는 구조에 대한 정보, 각각의 레이어의 노드를 연결하는 연결망 각각의 가중치 데이터 (즉, 가중치 커널) 중 적어 도 일부를 포함할 수 있다. 인공신경망의 데이터는 NPU 컨트롤러 내부에 제공되는 메모리 또는 NPU 내부 메모리에 저장될 수 있다. NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 NPU가 수행할 인공신경망모델의 연산 순서를 스케줄링 할 수 있다. NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 인공신경망모델의 레이어의 특징맵 및 가중치 데이터가 저장된 메모리 어드레스 값을 획득할 수 있다. 예를 들 면, NPU 컨트롤러 내의 스케줄러는 메모리에 저장된 인공신경망모델의 레이어의 특징맵 및 가중치 데이터 가 저장된 메모리 어드레스 값을 획득할 수 있다. 따라서 NPU 컨트롤러 내의 스케줄러는 구동할 인공신경망모델의 레이어의 특징맵 및 가중치 데이터를 메인 메모리에서 가져와서 NPU 내부 메모리에 저장할 수 있 다. 각각의 레이어의 특징맵은 대응되는 각각의 메모리 어드레스 값을 가질 수 있다. 각각의 가중치 데이터는 대응되는 각각의 메모리 어드레스 값을 가질 수 있다. NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보, 예를 들면, 인공신경망모델의 인공신경망의 레이어들의 배치 데이터, 지역성 정보 또는 구조에 대한 정보에 기초해서 복수 의 프로세싱 엘리먼트의 연산 순서를 스케줄링 할 수 있다. NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 스케줄링 하기 때문에, 일반적인 CPU의 스케줄링 개념과 다르게 동작할 수 있다. 일반적인 CPU의 스케줄링은 공 평성, 효율성, 안정성, 반응 시간 등을 고려하여, 최상의 효율을 낼 수 있도록 동작한다. 즉, 우선 순위, 연산 시간 등을 고려해서 동일 시간내에 가장 많은 프로세싱을 수행하도록 스케줄링 한다. 종래의 CPU는 각 프로세싱의 우선 순서, 연산 처리 시간 등의 데이터를 고려하여 작업을 스케줄링 하는 알고리 즘을 사용하였다. 이와 다르게 NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보 에 기초하여 결정된 NPU의 프로세싱 순서대로 NPU를 제어할 수 있다. 더 나아가면, NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보 및/또는 사용하려는 신경 프로세싱 유닛의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 결정된 프로세싱 순서대로 NPU를 구동할 수 있다. 단, 본 개시는 NPU의 데이터 지역성 정보 또는 구조에 대한 정보에 제한되지 않는다. NPU 컨트롤러 내의 스케줄러는 인공신경망의 데이터 지역성 정보 또는 구조에 대한 정보를 저장하도록 구 성될 수 있다. 즉, NPU 컨트롤러 내의 스케줄러는 적어도 인공신경망모델의 인공신경망의 데이터 지역성 정보 또는 구조 에 대한 정보만 활용하더라도 프로세싱 순서를 결정할 수 있다. 더 나아가서, NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보 및 NPU의 데이터 지역성 정보 또는 구조에 대한 정보를 고려하여 NPU의 프로세싱 순서를 결정할 수 있다. 또한, 결정된 프로세싱 순서대로 NPU의 프로세싱 최적화도 가능하다. 복수의 프로세싱 엘리먼트는 인공신경망의 특징맵과 가중치 데이터를 연산하도록 구성된 복수의 프로세싱 엘리먼트들(PE1 to PE12)이 배치된 구성을 의미한다. 각각의 프로세싱 엘리먼트는 MAC (multiply and accumulate) 연산기 및/또는 ALU (Arithmetic Logic Unit) 연산기를 포함할 수 있다. 단, 본 개시에 따른 예시 들은 이에 제한되지 않는다. 각각의 프로세싱 엘리먼트는 추가적인 특수 기능을 처리하기 위해 추가적인 특수 기능 유닛을 선택적으로 더 포 함하도록 구성될 수 있다. 예를 들면, 프로세싱 엘리먼트(PE)는 배치-정규화 유닛, 활성화 함수 유닛, 인터폴레이션 유닛 등을 더 포함하 도록 변형 실시되는 것도 가능하다. SFU는 활성화 함수 연산, 풀링(pooling) 연산, 스트라이드(stride) 연산, 배치 정규화(batch- normalization) 연산, 스킵 커넥션(skip-connection) 연산, 접합(concatenation) 연산, 양자화(quantization) 연산, 클리핑(clipping) 연산, 패딩(padding) 연산 등을 인공신경망의 구조(architecture)에 따라 선별하여, 처리하도록 구성된 회로부를 포함할 수 있다. 즉, SFU는 복수의 특수 기능 연산 처리 회로 유닛들을 포함 할 수 있다. 도 4에서는 예시적으로 복수의 프로세싱 엘리먼트들이 도시되었지만, 하나의 프로세싱 엘리먼트 내부에 MAC을 대체하여, 복수의 곱셈기(multiplier) 및 가산기 트리(adder tree)로 구현된 연산기들이 병렬로 배치되어 구성 되는 것도 가능하다. 이러한 경우, 복수의 프로세싱 엘리먼트는 복수의 연산기를 포함하는 적어도 하나의 프로세싱 엘리먼트로 지칭되는 것도 가능하다. 복수의 프로세싱 엘리먼트는 복수의 프로세싱 엘리먼트들(PE1 to PE12)을 포함하도록 구성된다. 도 4에 도 시된 복수의 프로세싱 엘리먼트들(PE1 to PE12)은 단지 설명의 편의를 위한 예시이며, 복수의 프로세싱 엘리먼 트들(PE1 to PE12)의 개수는 제한되지 않는다. 복수의 프로세싱 엘리먼트들(PE1 to PE12)의 개수에 의해서 복수 의 프로세싱 엘리먼트의 크기 또는 개수가 결정될 수 있다. 복수의 프로세싱 엘리먼트의 크기는 N x M 행렬 형태로 구현될 수 있다. 여기서 N 과 M은 0보다 큰 정수이다. 복수의 프로세싱 엘리먼트는 N x M 개의 프로세싱 엘리먼트를 포함할 수 있다. 즉, 프로세싱 엘리먼트는 1개 이상일 수 있다. 복수의 프로세싱 엘리먼트의 크기는 NPU이 작동하는 인공신경망모델의 특성을 고려하여 설계할 수 있 다. 복수의 프로세싱 엘리먼트는 인공신경망 연산에 필요한 덧셈, 곱셈, 누산 등의 기능을 수행하도록 구성된 다. 다르게 설명하면, 복수의 프로세싱 엘리먼트는 MAC(multiplication and accumulation) 연산을 수행하 도록 구성될 수 있다. 이하 복수의 프로세싱 엘리먼트 중 제1 프로세싱 엘리먼트(PE1)를 예를 들어 설명한다. 도 5a는 본 개시에 적용될 수 있는 복수의 프로세싱 엘리먼트 중 하나의 프로세싱 엘리먼트를 설명하는 개략적 인 개념도이다. 본 개시의 일 예시에 따른 NPU은 복수의 프로세싱 엘리먼트, 복수의 프로세싱 엘리먼트에서 추 론될 수 있는 인공신경망모델을 저장하도록 구성된 NPU 내부 메모리 및 복수의 프로세싱 엘리먼트 및 NPU 내부 메모리을 제어하도록 구성된 NPU 컨트롤러를 포함하고, 복수의 프로세싱 엘리먼트는 MAC 연산을 수행하도록 구성되고, 복수의 프로세싱 엘리먼트는 MAC 연산 결과를 양자화해서 출력하도록 구 성될 수 있다. 단, 본 개시의 예시들은 이에 제한되지 않는다. NPU 내부 메모리은 메모리 크기와 인공신경망모델의 데이터 크기에 따라 인공신경망모델의 전부 또는 일부 를 저장할 수 있다. 제1 프로세싱 엘리먼트(PE1)는 곱셈기, 가산기, 누산기, 및 비트 양자화 유닛을 포함할 수 있다. 단, 본 개시에 따른 예시들은 이에 제한되지 않으며, 복수의 프로세싱 엘리먼트는 인공신경망의 연 산 특성을 고려하여 변형 실시될 수도 있다. 곱셈기는 입력 받은 (N)bit 데이터와 (M)bit 데이터를 곱한다. 곱셈기의 연산 값은 (N+M)bit 데이터 로 출력된다. 곱셈기는 하나의 변수와 하나의 상수를 입력 받도록 구성될 수 있다. 누산기는 (L)loops 횟수만큼 가산기를 사용하여 곱셈기의 연산 값과 누산기의 연산 값을 누산 한다. 따라서 누산기의 출력부와 입력부의 데이터의 비트 폭은 (N+M+log2(L))bit로 출력될 수 있다. 여기서 L은 0보다 큰 정수이다. 누산기는 누산이 종료되면, 초기화 신호(initialization reset)를 인가받아서 누산기 내부에 저장된 데이터를 0으로 초기화 할 수 있다. 단, 본 개시에 따른 예시들은 이에 제한되지 않는다. 비트 양자화 유닛은 누산기에서 출력되는 데이터의 비트 폭을 저감할 수 있다. 비트 양자화 유닛 은 NPU 컨트롤러에 의해서 제어될 수 있다. 양자화된 데이터의 비트 폭은 (X)bit로 출력될 수 있다. 여기서 X는 0보다 큰 정수이다. 상술한 구성에 따르면, 복수의 프로세싱 엘리먼트는 MAC 연산을 수행하도 록 구성되고, 복수의 프로세싱 엘리먼트는 MAC 연산 결과를 양자화해서 출력할 수 있는 효과가 있다. 특히 이러한 양자화는 (L)loops가 증가할수록 소비 전력을 더 절감할 수 있는 효과가 있다. 또한 소비 전력이 저감되 면 발열도 저감할 수 있는 효과가 있다. 특히 발열을 저감하면 NPU의 고온에 의한 오동작 발생 가능성을 저감할 수 있는 효과가 있다. 비트 양자화 유닛의 출력 데이터(X)bit은 다음 레이어의 노드 데이터 또는 합성곱의 입력 데이터가 될 수 있다. 만약 인공신경망모델이 양자화되었다면, 비트 양자화 유닛은 양자화된 정보를 인공신경망모델에서 제공받도록 구성될 수 있다. 단, 이에 제한되지 않으며, NPU 컨트롤러는 인공신경망모델을 분석하여 양자 화된 정보를 추출하도록 구성되는 것도 가능하다. 따라서 양자화된 데이터 크기에 대응되도록, 출력 데이터 (X)bit를 양자화 된 비트 폭으로 변환하여 출력될 수 있다. 비트 양자화 유닛의 출력 데이터(X)bit는 양자 화된 비트 폭으로 NPU 내부 메모리에 저장될 수 있다. 본 개시의 일 예시에 따른 NPU의 복수의 프로세싱 엘리먼트는 곱셈기, 가산기, 및 누산기 를 포함한다. 비트 양자화 유닛은 양자화 적용 여부에 따라 취사 선택될 수 있다. 도 5b는 본 개시에 적용될 수 있는 SFU를 설명하는 개략적인 개념도이다. 도 5b를 참고하면 SFU는 여러 기능 유닛을 포함한다. 각각의 기능 유닛은 선택적으로 동작될 수 있다. 각 각의 기능 유닛은 선택적으로 턴-온되거나 턴-오프될 수 있다. 즉, 각각의 기능 유닛은 설정이 가능하다. 다시 말해서, SFU는 인공신경망 추론 연산에 필요한 다양한 회로 유닛들을 포함할 수 있다. 예를 들면, SFU의 회로 유닛들은 건너뛰고 연결하기(skip-connection) 동작을 위한 기능 유닛, 활성화 함 수(activation function) 동작을 위한 기능 유닛, 풀링(pooling) 동작을 위한 기능 유닛, 양자화 (quantization) 동작을 위한 기능 유닛, NMS(non-maximum suppression) 동작을 위한 기능 유닛, 정수 및 부동 소수점 변환(INT to FP32) 동작을 위한 기능 유닛, 배치 정규화(batch-normalization) 동작을 위한 기능 유닛, 보간법(interpolation) 동작을 위한 기능 유닛, 연접(concatenation) 동작을 위한 기능 유닛, 및 바이아스 (bias) 동작을 위한 기능 유닛 등을 포함할 수 있다. SFU의 기능 유닛들은 인공신경망모델의 데이터 지역성 정보에 의해서 선택적으로 턴-온되거나 혹은 턴-오 프될 수 있다. 인공신경망모델의 데이터 지역성 정보는 특정 레이어를 위한 연산이 수행될 때, 해당 기능 유닛 의 턴-오프 혹은 턴-오프와 관련된 제어 정보를 포함할 수 있다. SFU의 기능 유닛들 중 활성화된 유닛은 턴-온 될 수 있다. 이와 같이 SFU의 일부 기능 유닛을 선택적 으로 턴-오프하는 경우, NPU의 소비 전력을 절감할 수 있다. 한편, 일부 기능 유닛을 턴-오프하기 위하여, 파워 게이팅(power gating)을 이용할 수 있다. 또는, 일부 기능 유닛을 턴-오프하기 위하여, 클럭 게이팅(clock gating)을 수행할 수도 있다. 도 6은 도 4에 도시된 NPU의 변형예를 나타낸 예시도이다. 도 6에 도시된 NPU은 도 4에 예시적으로 도시된 프로세싱 유닛과 비교하면, 복수의 프로세싱 엘리먼 트를 제외하곤 실질적으로 동일하기 때문에, 이하 단지 설명의 편의를 위해서 중복 설명은 생략할 수 있다. 도 6에 예시적으로 도시된 복수의 프로세싱 엘리먼트는 복수의 프로세싱 엘리먼트들(PE1 to PE12) 외에, 각각의 프로세싱 엘리먼트들(PE1 to PE12)에 대응되는 각각의 레지스터 파일들(RF1 to RF12)을 더 포함할 수 있 다. 도 6에 도시된 복수의 프로세싱 엘리먼트들(PE1 to PE12) 및 복수의 레지스터 파일들(RF1 to RF12)은 단지 설명 의 편의를 위한 예시이며, 복수의 프로세싱 엘리먼트들(PE1 to PE12) 및 복수의 레지스터 파일들(RF1 to RF12) 의 개수는 제한되지 않는다. 복수의 프로세싱 엘리먼트들(PE1 to PE12) 및 복수의 레지스터 파일들(RF1 to RF12)의 개수에 의해서 복수의 프 로세싱 엘리먼트의 크기 또는 개수가 결정될 수 있다. 복수의 프로세싱 엘리먼트 및 복수의 레지스터 파일들(RF1 to RF12)의 크기는 N x M 행렬 형태로 구현될 수 있다. 여기서 N 과 M은 0보다 큰 정수이다. 복수의 프로세싱 엘리먼트의 어레이 크기는 NPU이 작동하는 인공신경망모델의 특성을 고려하여 설계 할 수 있다. 부연 설명하면, 레지스터 파일의 메모리 크기는 작동할 인공신경망모델의 데이터 크기, 요구되는 동작 속도, 요구되는 소비 전력 등을 고려하여 결정될 수 있다. NPU의 레지스터 파일들(RF1 to RF12)은 프로세싱 엘리먼트들(PE1 to PE12)과 직접 연결된 정적 메모리 유 닛이다. 레지스터 파일들(RF1 to RF12)은 예를 들면, 플립플롭, 및/또는 래치 등으로 구성될 수 있다. 레지스터 파일들(RF1 to RF12)은 대응되는 프로세싱 엘리먼트들(PE1 to PE12)의 MAC 연산 값을 저장하도록 구성될 수 있 다. 레지스터 파일들(RF1 to RF12)은 NPU 내부 메모리와 가중치 데이터 및/또는 노드 데이터를 제공하거나 제공받도록 구성될 수 있다. 레지스터 파일들(RF1 to RF12)은 MAC 연산 시 누산기의 임시 메모리의 기능을 수행하도록 구성되는 것도 가능하 다. 도 7은 예시적인 인공신경망모델을 설명하는 개략적인 개념도이다. 이하 NPU에서 작동될 수 있는 예시적인 인공신경망모델(110-10)의 연산에 대하여 설명한다. 도 7의 예시적인 인공신경망모델(110-10)은 도 4 또는 도 6에 도시된 NPU에서 학습되거나 별도의 기계 학 습 장치에서 학습된 인공신경망일 수 있다. 인공신경망모델은 객체 인식, 음성 인식 등 다양한 추론 기능을 수 행하도록 학습된 인공신경망일 수 있다. 인공신경망모델(110-10)은 심층 신경망(DNN, Deep Neural Network)일 수 있다. 단, 본 개시의 예시들에 따른 인공신경망모델(110-10)은 심층 신경망에 제한되지 않는다. 예를 들면, 인공신경망모델은 Object Detection, Object Segmentation, Image/Video Reconstruction, Image/Video Enhancement, Object Tracking, Event Recognition, Event Prediction, Anomaly Detection, Density Estimation, Event Search, Measurement 등의 추론을 수행하도록 학습될 모델일 수 있다. 예를 들면, 인공신경망모델은 Bisenet, Shelfnet, Alexnet, Densenet, Efficientnet, EfficientDet, Googlenet, Mnasnet, Mobilenet, Resnet, Shufflenet, Squeezenet, VGG, Yolo, RNN, CNN, DBN, RBM, LSTM 등 의 모델일 수 있다. 예를 들면, 인공신경망모델은 Generative adversarial networks (GAN), transformer 등의 모델일 수 있다. 단, 본 개시는 이에 제한되지 않으며, NPU에서 동작할 새로운 인공신경망모델이 꾸준히 발표되 고 있다. 단, 본 개시는 상술한 모델들에 제한되지 않는다. 또한 인공신경망모델(110-10)은 적어도 두 개의 서로 다른 모 델들에 기초한 앙상블 모델일 수도 있다. 인공신경망모델(110-10)은 NPU의 NPU 내부 메모리에 저장될 수 있다. 이하 도 7를 참조하여 예시적인 인공신경망모델(110-10)에 의환 추론 과정이 NPU에 의해서 수행되는 것에 관해 설명한다. 인공신경망모델(110-10)은 입력 레이어(110-11), 제1 연결망(110-12), 제1 은닉 레이어(110-13), 제2 연결망 (110-14), 제2 은닉 레이어(110-15), 제3 연결망(110-16), 및 출력 레이어(110-17)을 포함하는 예시적인 심층 신경망 모델이다. 단, 본 개시는 도 7에 도시된 인공신경망모델에만 제한되는 것은 아니다. 제1 은닉 레이어 (110-13) 및 제2 은닉 레이어(110-15)는 복수의 은닉 레이어로 지칭되는 것도 가능하다. 입력 레이어(110-11)는 예시적으로, x1 및 x2 입력 노드를 포함할 수 있다. 즉, 입력 레이어(110-11)는 2개의 입력 값에 대한 정보를 포함할 수 있다. 도 4 또는 도 6에 도시된 NPU 컨트롤러 내의 스케줄러는 입력 레 이어(110-11)로부터의 입력 값에 대한 정보가 저장되는 메모리 어드레스를 도 4 또는 도 6에 도시된 NPU 내부 메모리에 설정할 수 있다. 제1 연결망(110-12)은 예시적으로, 입력 레이어(110-11)의 각각의 노드를 제1 은닉 레이어(110-13)의 각각의 노 드로 연결시키기 위한 6개의 가중치 값에 대한 정보를 포함할 수 있다. 도 4 또는 도 6에 도시된 NPU 컨트롤러 내의 스케줄러는 제1 연결망(110-12)의 가중치 값에 대한 정보가 저장되는 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다. 각각의 가중치 값은 입력 노드 값과 곱해지고, 곱해진 값들의 누산된 값이 제1 은닉 레이어(110-13)에 저장된다. 여기서 노드들은 특징맵으로 지칭될 수 있다. 제1 은닉 레이어(110-13)는 예시적으로 a1, a2, 및 a3 노드를 포함할 수 있다. 즉, 제1 은닉 레이어(110-13)는 3개의 노드 값에 대한 정보를 포함할 수 있다. 도 4 또는 도 6에 도시된 NPU 컨트롤러 내의 스케줄러는 제 1 은닉 레이어(110-13)의 노드 값에 대한 정보를 저장시키기 위한 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다. NPU 컨트롤러 내의 스케줄러는 제1 프로세싱 엘리먼트(PE1)가 제1 은닉 레이어(110-13)의 a1 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. NPU 컨트롤러 내의 스케줄러는 제2 프로 세싱 엘리먼트(PE2)가 제1 은닉 레이어(110-13)의 a2 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도 록 구성될 수 있다. NPU 컨트롤러 내의 스케줄러는 제3 프로세싱 엘리먼트(PE3)가 제1 은닉 레이어(110- 13)의 a3 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. 여기서 NPU 컨트롤러 내의 스케줄러는 3개의 프로세싱 엘리먼트들이 병렬로 동시에 MAC 연산을 각각 수행하도록 연산 순서를 미리 스케줄링 할 수 있다. 제2 연결망(110-14)은 예시적으로, 제1 은닉 레이어(110-13)의 각각의 노드를 제2 은닉 레이어(110-15)의 각각 의 노드로 연결시키기 위한 9개의 가중치 값에 대한 정보를 포함할 수 있다. 도 4 또는 도 6에 도시된 NPU 컨트 롤러 내의 스케줄러는 제2 연결망(110-14)의 가중치 값에 대한 정보를 저장시키기 위한 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다. 상기 제2 연결망(110-14)의 가중치 값은 제1 은닉 레이어(110-13)로부터 입력되는 노드 값과 각기 곱해지고, 곱해진 값들의 누산된 값이 제2 은닉 레이어(110-15)에 저장된다. 제2 은닉 레이어(110-15)는 예시적으로 b1, b2, 및 b3 노드를 포함할 수 있다. 즉, 제2 은닉 레이어(110-15)는 3개의 노드 값에 대한 정보를 포함할 수 있다. NPU 컨트롤러 내의 스케줄러는 제2 은닉 레이어(110-15)의 노드 값에 대한 정보를 저장시키기 위한 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다. NPU 컨트롤러 내의 스케줄러는 제4 프로세싱 엘리먼트(PE4)가 제2 은닉 레이어(110-15)의 b1 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. NPU 컨트롤러 내의 스케줄러는 제5 프로 세싱 엘리먼트(PE5)가 제2 은닉 레이어(110-15)의 b2 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도 록 구성될 수 있다. NPU 컨트롤러 내의 스케줄러는 제6 프로세싱 엘리먼트(PE6)가 제2 은닉 레이어(110- 15)의 b3 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. 여기서 NPU 컨트롤러 내의 스케줄러는 3개의 프로세싱 엘리먼트들이 병렬로 동시에 MAC 연산을 각각 수행 하도록 연산 순서를 미리 스케줄링 할 수 있다. 여기서 NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 제1 은닉 레이어(110-13)의 MAC 연산 이후 제2 은 닉 레이어(110-15)의 연산이 수행되도록 스케줄링을 결정할 수 있다. 즉, NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하 여 복수의 프로세싱 엘리먼트 및 NPU 내부 메모리을 제어하도록 구성될 수 있다. 제3 연결망(110-16)은 예시적으로, 제2 은닉 레이어(110-15)의 각각의 노드와 출력 레이어(110-17)의 각각의 노 드를 연결하는 6개의 가중치 값에 대한 정보를 포함할 수 있다. NPU 컨트롤러 내의 스케줄러는 제3 연결망 (110-16)의 가중치 값에 대한 정보를 저장시키기 위한 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있 다. 제3 연결망(110-16)의 가중치 값은 제2 은닉 레이어(110-15)로부터 입력되는 노드 값과 각기 곱해지고, 곱 해진 값들의 누산된 값이 출력 레이어(110-17)에 저장된다. 출력 레이어(110-17)는 예시적으로 y1, 및 y2 노드를 포함할 수 있다. 즉, 출력 레이어(110-17)는 2개의 노드 값에 대한 정보를 포함할 수 있다. NPU 컨트롤러 내의 스케줄러는 출력 레이어(110-17)의 노드 값에 대한 정보를 저장시키기 위해 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다. NPU 컨트롤러 내의 스케줄러는 제7 프로세싱 엘리먼트(PE7)가 출력 레이어(110-17)의 y1 노드의 MAC 연산 을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. NPU 컨트롤러 내의 스케줄러는 제8 프로세싱 엘리먼트(PE8)가 출력 레이어(110-15)의 y2 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. 여기서 NPU 컨트롤러 내의 스케줄러는 2개의 프로세싱 엘리먼트들이 병렬로 동시에 MAC 연산을 각각 수행 하도록 연산 순서를 미리 스케줄링 할 수 있다. 여기서 NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 제2 은닉 레이어(110-15)의 MAC 연산 이후 출력 레이어(110-17)의 연산이 수행되도록 스케줄링을 결정할 수 있다. 즉, NPU 컨트롤러 내의 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하 여 복수의 프로세싱 엘리먼트 및 NPU 내부 메모리을 제어하도록 구성될 수 있다. 즉, NPU 컨트롤러 내의 스케줄러는 복수의 프로세싱 엘리먼트에서 작동할 인공신경망모델의 구조를 분석하거나 또는 분석된 정보를 제공받을 수 있다. 인공신경망모델이 포함할 수 있는 인공신경망의 정보는 각각 의 레이어의 노드 값에 대한 정보, 레이어들의 배치 데이터 지역성 정보 또는 구조에 대한 정보, 각각의 레이어 의 노드를 연결하는 연결망 각각의 가중치 값에 대한 정보를 포함할 수 있다. NPU 컨트롤러 내의 스케줄러는 예시적인 인공신경망모델(110-10)의 데이터 지역성 정보 또는 구조에 대한 정보를 제공받았기 때문에, NPU 컨트롤러 내의 스케줄러는 인공신경망모델(110-10)의 입력부터 출력까지의 연산 순서를 파악할 수 있다. 따라서, NPU 컨트롤러 내의 스케줄러는 각각의 레이어의 MAC 연산 값들이 저장되는 메모리 어드레스를 스 케줄링 순서를 고려해서 NPU 내부 메모리에 설정할 수 있다. NPU 내부 메모리는 NPU의 추론 연산이 지속되는 동안 NPU 내부 메모리에 저장된 연결망들의 가 중치 데이터를 보존하도록 구성될 수 있다. 따라서 메모리 읽기 쓰기 동작을 저감할 수 있는 효과가 있다.즉, NPU 내부 메모리는 추론 연산이 지속되는 동안 NPU 내부 메모리에 저장된 MAC 연산 값을 재사용 하도록 구성될 수 있다. 도 8a는 컨볼류션 신경망의 기본 구조를 설명하기 위한 도면이다. 도 8a를 참조하면, 컨볼류션 신경망은 하나 또는 여러 개의 컨볼류션 레이어(convolutional layer)와 통합 레이 어(pooling layer), 완전하게 연결된 레이어(fully connected layer)들의 조합일 수 있다. 본 개시의 예시에서, 컨볼류션 신경망은 채널마다 채널의 입력 영상의 특징을 추출하는 커널이 존재한다. 커널 은 2차원 행렬로 구성될 수 있으며, 입력 데이터를 순회하면서 합성곱 연산 수행한다. 커널의 크기는 임의로 결 정될 수 있으며, 커널이 입력 데이터를 순회하는 간격(stride) 또한 임의로 결정될 수 있다. 커널 하나당 입력 데이터 전체에 대한 합성곱 결과는 특징맵(feature map) 또는 활성화 맵으로 지칭될 수 있다. 이하에서 커널은 일 세트의 가중치 값들 또는 복수의 세트의 가중치 값들을 포함할 수 있다. 각 레이어 별 커널의 개수는 채널의 개수로 지칭될 수 있다. 커널은 행렬 형식의 가중치로, 또는 커널은 가중치로 지칭될 수 있다. 이처럼 합성곱 연산은 입력 데이터와 커널의 조합으로 이루어진 연산이므로, 이후 비선형성을 추가하기 위한 활 성화 함수가 적용될 수 있다. 합성곱 연산의 결과인 특징맵에 활성화 함수가 적용되면 활성화 맵으로 지칭될 수 있다. 구체적으로 도 8a를 참조하면, 컨볼류션 신경망은 적어도 하나의 컨볼류션 레이어, 적어도 하나의 풀링 레이어, 및 적어도 하나의 완전 연결 레이어를 포함한다. 예를 들면, 합성곱(컨볼류션)은, 입력 데이터의 크기(통상적으로 1Х1, 3Х3 또는 5Х5 행렬)와 출력 특징 맵 (Feature Map)의 깊이(커널의 수)와 같은 두 개의 주요 파라미터에 의해 정의될 수 있다. 이러한 주요 파라미터 는 합성곱에 의해 연산 될 수 있다. 이들 합성곱은, 깊이 32에서 시작하여, 깊이 64로 계속되며, 깊이 128 또는 256에서 종료될 수 있다. 합성곱 연산은, 입력 데이터인 입력 이미지 행렬 위로 3Х3 또는 5Х5 크기의 커널 (kernel)을 슬라이딩하여 커널의 각 가중치와 겹쳐지는 입력 이미지 행렬의 각 원소를 곱한 후 이들을 모두 더 하는 연산을 의미할 수 있다. 이와 같이 생성된 출력 특징맵에 활성화 함수가 적용되어 활성화 맵이 최종적으로 출력될 수 있다. 또한, 현재 레이어에서의 사용된 가중치는 합성곱을 통해 다음 레이어에 전달될 수 있다. 풀링 레이어는 출력 데이터(즉, 활성화 맵)을 다운 샘플링하여 특징맵의 크기를 줄이는 풀링 연산을 수행할 수 있다. 예를 들어, 풀링 연산은 최대 풀링(max pooling) 및/또는 평균 풀링(average pooling)을 포함할 수 있으나, 이에 한정되지 않는다. 최대 풀링 연산은 커널을 이용하며, 특징맵과 커널이 슬라이딩되어 커널과 겹쳐지는 특징맵의 영역에서 최대 값 을 출력한다. 평균 풀링 연산은 특징맵과 커널이 슬라이딩되어 커널과 겹쳐지는 특징맵의 영역 내에서 평균값을 출력한다. 이처럼 풀링 연산에 의해 특징맵의 크기가 줄어들기 때문에 특징맵의 가중치 개수 또한 줄어든다. 완전 연결 레이어는 풀링 레이어를 통해서 출력된 데이터를 복수의 클래스(즉, 추정값)로 분류하고, 분류된 클 래스 및 이에 대한 점수(score)를 출력할 수 있다. 풀링 레이어를 통해서 출력된 데이터는 3차원 특징맵 형태를 이루며, 이러한 3차원 특징맵이 1차원 벡터로 변환되어 완전 연결 레이어로 입력될 수 있다. 도 8b은 컨볼류션 신경망의 동작을 이해하기 쉽게 나타낸 종합도이다. 도 8b를 참조하면, 예시적으로 입력 이미지가 6 x 6 크기를 갖는 2차원적 행렬인 것으로 나타나 있다. 또한, 도 8b에는 예시적으로 3개의 채널, 즉 채널 1, 채널 2, 채널 3이 사용되는 것으로 나타내었다. 먼저, 합성곱 동작에 대해서 설명하기로 한다. 입력 이미지(도 8b에서는 예시적으로 6 x 6 크기인 것으로 나타내어짐)는 첫 번째 노드에서 채널 1을 위한 커널 1(도 8b에서는 예시적으로 3 x 3 크기인 것으로 나타내어짐)과 합성곱되고, 그 결과로서 특징맵1(도 8b에서는 예시적으로 4 x 4 크기인 것으로 나타내어짐)이 출력된다. 또한, 상기 입력 이미지(도 8b에서는 예시적으로 6 x 6 크기인 것으로 나타내어짐)는 두 번째 노드에서 채널 2를 위한 커널 2(도 8b에서는 예시적으로 3 x 3 크기인 것으로 나타내어짐)와 합성곱되고 그 결과로서 특징맵 2(도 8b에서는 예시적으로 4 x 4 크기인 것으로 나타내어 짐)가 출력된다. 또한, 상기 입력 이미지는 세 번째 노드에서 채널 3을 위한 커널 3(도 8b에서는 예시적으로 3 x 3 크기인 것으로 나타내어짐)과 합성곱되고, 그 결과로서 특징맵3(도 8b에서는 예시적으로 4 x 4 크기인 것으 로 나타내어짐)이 출력된다. 각각의 합성곱을 처리하기 위해서 NPU의 프로세싱 엘리먼트들(PE1 to PE12)은 MAC 연산을 수행하도록 구성 된다. 다음으로, 활성화 함수의 동작에 대해서 설명하기로 한다. 합성곱 동작으로부터 출력되는 특징맵1, 특징맵2 그리고 특징맵3(도 8b에서는 각각의 크기는 예시적으로 4 x 4 인 것으로 나타내어짐)에 대해서 활성화 함수가 적용될 수 있다. 활성화 함수가 적용되고 난 이후의 출력은 예 시적으로 4 x 4 의 크기일 수 있다. 다음으로, 폴링(pooling) 동작에 대해서 설명하기로 한다. 상기 활성화 함수로부터 출력되는 특징맵1, 특징맵2, 특징맵3(도 8b에서는 각각의 크기는 예시적으로 4 x 4인 것으로 나타내어짐)은 3개의 노드로 입력된다. 활성화 함수로부터 출력되는 특징맵들을 입력으로 받아서 폴링 (pooling)을 수행할 수 있다. 상기 폴링이라 함은 크기를 줄이거나 행렬 내의 특정 값을 강조할 수 있다. 폴링 방식으로는 최대값 폴링과 평균 폴링, 최소값 폴링이 있다. 최대값 폴링은 행렬의 특정 영역 안에 값의 최댓값 을 모으기 위해서 사용되고, 평균 폴링은 특정 영역내의 평균을 구하기 위해서 사용될 수 있다. 도 8b의 예시에서는 4 x 4 크기의 특징맵이 폴링에 의하여 2 x 2 크기로 줄어지는 것으로 나타내었다. 구체적으로, 첫 번째 노드는 채널 1을 위한 특징맵1을 입력으로 받아 폴링을 수행한 후, 예컨대 2 x 2 행렬로 출력한다. 두 번째 노드는 채널 2을 위한 특징맵2을 입력으로 받아 폴링을 수행한 후, 예컨대 2 x 2 행렬로 출 력한다. 세 번째 노드는 채널 3을 위한 특징맵3을 입력으로 받아 폴링을 수행한 후, 예컨대 2 x 2 행렬로 출력 한다. 전술한 합성곱, 활성화 함수과 폴링이 반복되고 최종적으로는, 도 8a과 같이 fully connected로 출력될 수 있다. 해당 출력은 다시 이미지 인식을 위한 인공 신경망으로 입력될 수 있다. 단, 본 개시는 특징맵, 커널의 크기에 제한되지 않는다. <VCM(Video coding for Machines)> 최근에 Surveillance, Intelligent Transportation, Smart City, Intelligent Industry, Intelligent Content 와 같은 다양한 산업 분야가 발전함에 따라 기계에 의해 소비되는 영상 또는 특징맵 데이터양이 증가하고 있다. 이에 반해, 현재 사용 중인 전통적인 영상 압축방식은 시청자가 인지하는 시각(Human Vision)의 특성을 고려해 개발된 기술이기에 불필요한 정보들을 포함하고 있어 기계 임무 수행에 비효율적이다. 따라서, 기계 임무 수행 에 대해 효율적으로 특징맵을 압축하기 위한 비디오 코덱 기술에 관한 연구가 요구되고 있다. 멀티미디어 부호화 국제표준화 그룹인 MPEG(Moving Picture Experts Group)에서 VCM(Video Coding for Machine) 기술이 논의되고 있다. VCM은 사람이 보는 시청자 시각 기준이 아닌 기계의 데이터 소비시각(Machine Vision)에 대한 기준의 영상 또는 특징맵 부호화 기술이다. <본 명세서의 개시에 대한 설명> 도 9a 내지 도 9d는 VCM 인코더를 포함하는 NPU와 VCM 디코더를 포함하는 NPU를 나타낸 예시도들이다. 도 9a을 참조하면, 제1 NPU(100a)는 VCM 인코더(150a)를 포함할 수 있고, 제2 NPU(100b)는 VCM 디코더(150b)를 포함할 수 있다. 제1 NPU(100a) 내의 VCM 인코더(150a)가 비디오 및/또는 특징맵을 인코딩하여 비트스트림으로 전송하면, 제2 NPU(100b) 내의 VCM 디코더(150b)는 상기 비트스트림을 디코딩하여 출력할 수 있다. 이때, 상기 제2 NPU(100b) 내의 VCM 디코더(150b)는 하나 이상의 비디오 및/또는 특징맵을 출력할 수 있다. 예를 들어, 상기 제2 NPU(100b) 내의 VCM 디코더(150b)는 머신을 이용한 분석을 위한 제1 특징맵을 출력할 수 있고, 사용자에 의한 시청을 위한 제1 영상을 출력할 수 있다. 상기 제1 영상은 상기 제1 특징맵에 비하여 보다 고해상도일 수 있다. 도 9b를 참조하면, 제1 NPU(100a)는 특징맵을 추출하는 특징 추출기(Feature Extractor)와 VCM 인코더(150a)를 포함할 수 있다. 상기 제1 NPU(100a) 내의 VCM 인코더(150a)는 특징 인코더를 포함할 수 있다. 제2 NPU(100b)는 VCM 디코더 (150b)를 포함할 수 있다. 상기 제2 NPU(100b) 내의 VCM 디코더(150b)는 특징 디코더와 비디오 재생성기(Videoreconstructor)를 포함할 수 있다. 상기 특징 디코더는 비트스트림으로부터 특징맵을 디코딩하여, 머신을 이용 한 분석을 위한 제1 특징맵을 출력할 수 있다. 상기 비디오 재생성기는 비트스트림으로부터 사용자에 의한 시청 을 위한 제1 영상을 재생성하여 출력할 수 있다. 도 9c 참조하면, 제1 NPU(100a)는 특징맵을 추출하는 특징 추출기(Feature Extractor)와 VCM 인코더(150a)를 포함할 수 있다. 상기 제1 NPU(100a) 내의 VCM 인코더(150a)는 특징 인코더를 포함할 수 있다. 제2 NPU(100b)는 VCM 디코더 (150b)를 포함할 수 있다. 상기 제2 NPU(100b) 내의 VCM 디코더(150b)는 특징 디코더를 포함할 수 있다. 상기 특징 디코더는 비트스트림으로부터 특징맵을 디코딩하여, 머신을 이용한 분석을 위한 제1 특징맵을 출력할 수 있다. 즉, 비트스트림은 영상이 아닌 특징맵으로만 인코딩 될 수 있다. 부연 설명하면, 특징맵은 영상을 기초로 머신의 특정 타스크를 처리하기 위한 특징에 대한 정보를 포함한 데이터 일 수 있다. 도 9d를 참조하면, 제1 NPU(100a)는 특징맵을 추출하는 특징 추출기(Feature Extractor)와 VCM 인코더(150a)를 포함할 수 있다. 상기 제1 NPU(100a) 내의 VCM 인코더(150a)는 특징 컨버터와 비디오 인코더를 포함할 수 있다. 제2 NPU(100b)는 VCM 디코더(150b)를 포함할 수 있다. 상기 제2 NPU(100b)내의 VCM 디코더(150b)는 비디오 디코더와 인버스 컨버 터를 포함할 수 있다. 도 9b 내지 도 9d에 도시된 특징 추출기는 도 4 또는 도 6에 도시된 상기 NPU 내의 복수의 PE들에 해 당할 수 있다. 또는, 도 9b 내지 도 9d에 도시된 특징 추출기는 상기 NPU 내의 복수의 PE들과 전술한 SFU의 조합에 해당할 수 있다. 이상과 같이, 도 9a 내지 도 9d에서는 제1 NPU(100a)는 적어도 VCM 인코더(150a)를 포함하고, 제2 NPU(100b)는 적어도 VCM 디코더(150b)를 포함하는 것으로 나타나 있다. 단, 이에 제한되지 않으며, VCM 인코더(150a)가 제1 NPU(100a)를 포함하도록 변형실시 될 수 있거나, VCM 디코더(150b)가 제2 NPU(100b)를 포함하도록 변형실시 될 수 있다. 제1 NPU(100a)는 인공지능 연산(예를 들면, 컨볼류션(convolution))을 처리하여 특징맵을 생성할 수 있다. 제1 NPU(100a)는 인공지능 연산을 처리하여 특징맵을 인코딩한 후, 전송할 수 있다. 제2 NPU(100b)는 상기 인코딩된 특징맵을 수신할 수 있다. 상기 제2 NPU(100b)는 인공지능 연산(예를 들면, 디 컨볼류선(deconvolution))을 처리하여 인코딩된 특징맵을 디코딩할 수 있다. 인공지능 연산을 처리하기 위해서 특정 구조의 인공신경망모델이 사용될 수 있다. 예를 들면, 특징맵 추출을 위 해서 NPU는 컨볼류션 연산을 처리할 수 있다. 예를 들면, 특징맵 인코딩을 위해서 NPU는 컨볼류션 연산을 처리 할 수 있다. 예를 들면, 인코딩된 특징맵 디코딩을 위해서 NPU는 디컨볼류션 연산을 처리할 수 있다. 인공신경망모델은 다층 구조일 수 있으며, 인공신경망모델은 백본(backbone) 네트워크를 포함할 수 있다. 제1 NPU(100a)의 인공지능 연산을 통해 생성된 특징맵은 다층 구조의 인공신경망모델의 특정 층에서 생성된 특징맵 일 수 있다. 즉, 특징맵은 다층 구조의 인공신경망모델의 적어도 하나의 층에서 생성된 적어도 하나의 특징맵일 수 있다. 다층 구조의 인공신경망모델의 특정 층에서 생성된 특징맵은 특정 머신을 이용한 분석에 적합한 특징 맵일 수 있다. 도 10a 및 도 10b는 인공신경망모델에서 비트스트림의 위치를 나타낸 예시도이다. 도 10a을 참고하여 알 수 있는 바와 같이, 제1 NPU(100a) 또는 VCM 인코더는 비디오를 입력받으면, 인공신경망 모델(예컨대, 컨볼류션 네트워크 모델)을 이용하여, 각 레이어별로 각각의 특징맵들을 생성할 수 있다. 도 10a 에서는 컨볼루션 네트워크 모델의 마지막인 레이어에 해당하는 완전 연결된 레이어(fully connected layer)에서 의 특징맵을 비트스트림으로 전송하는 예가 나타나 있다. 그러면, 제2 NPU(100b) 또는 VCM 디코더는 디컨볼류션 네트워크 모델을 이용하여 상기 특징맵을 포함하는 비트 스트림을 디코딩할 수 있다. 한편, 도 10b를 참고하면, 완전 연결된 레이어(fully connected layer)에서의 특징맵이 비트스트림으로 전송되 는 것이 아니라, 인공신경망모델(예컨대, 컨볼류션 네트워크 모델)의 중간 레이어에서 생성된 특징맵들이 비트 스트림으로 전송되는 예가 나타나 있다.도 11a은 특징맵을 압축한 후 비트스트림으로 전송하는 VCM 인코더와 수신된 비트스트림을 복원하는 VCM 디코더 를 일 예시에 따라 나타내고, 도 11b는 도 11a에 도시된 특징맵 P2 내지 특징맵 P5를 생성하는 예를 나타낸다. 그리고, 도 11c는 도 11a에 도시된 MSFF 수행부를 자세하게 나타낸 예시도이다. 도 11a을 참고하여 알 수 있는 바와 같이, VCM 인코더(150a)(혹은 송신단)은 MSFF(Multi-scale feature fusion) 수행부(150a-1)와, SSFC(Single-stream feature codec) 인코더(150a-2)를 포함할 수 있다. VCM 디코더 (150b)(혹은 수신단)은 SSFC 디코더(150b-1)와 MSFR(Multi-Scale Feature Reconstruction) 수행부(150b-2)을 포함할 수 있다. 상기 MSFF 수행부(150a-1)는 P 레이어의 특징맵 P2 내지 특징맵 P5를 정렬(Align)시킨 후, 연접(Concatenate) 시킨다. 상기 P 레이어의 특징맵 P2 내지 특징맵 P5는 도 11b에서 도시된 바와 같이 생성될 수 있다. 도 11b를 참조하여 설명하면, 제1 인공신경망 모델, 예컨대 ResNet과 제2 인공신경망 모델, 예컨대 FPN(Feature Pyramid Network)의 조합을 이용하여 특징맵 P2 내지 특징맵 P5가 생성될 수 있다. 상기 제1 인공신경망 모델은 백본 (Back-bone)으로 불릴 수 있고, 상기 제2 인공신경망 모델은 넥(Neck) 혹은 헤드(Head)로 불릴 수 있다. 도 11b 에 도시된 바와 같이 이미지가 입력되면 제1 인공신경망 모델(예컨대 ResNet)은 Bottom-up 방식으로 여러 단계 들(예컨대, Stage 1에서 Stage 5)까지를 수행할 수 있다. 각 단계는 예를 들어, 컨볼류션, 배치 정규화(Batch Normalization), ReLu(Rectified Linear Unit) 등을 포함할 수 있다. 상기 제1 인공신경망 모델(예컨대 ResNet)의 각 단계로부터의 출력에 대해서는 컨볼류션이 수행되어, C 레이어의 특징맵 C2 내지 특징맵 C5가 생 성될 수 있다. 상기 제2 인공신경망 모델(예컨대, FPN)은 상기 C 레이어의 특징맵 C2 내지 특징맵 C5을 입력받 아, Top-Down 방식으로 누적하여 M 레이어의 특징맵 M2 내지 특징맵 M5를 생성할 수 있다. 상기 M 레이어의 특 징맵 M2 내지 특징맵 M5에 대해서 각기 컨볼류션이 수행됨으로써, P 레이어의 특징맵 P2 내지 특징맵 P5가 생성 될 수 있다. 다시 도 11a를 참조하면, 상기 MSFF 수행부(150a-1)는 P 레이어의 특징맵 P2 내지 특징맵 P5를 정렬(Align)시킨 후, 연접(Concatenate)시킨다. 구체적으로, 상기 MSFF 수행부(150a-1)는 상기 특징맵 P5의 사이즈에 맞추어 특 징맵 P2 내지 특징맵 P4의 사이즈를 다운샘플링한 후, 연접시킨다. 도 11c를 참조하여 자세히 설명하면, 상기 MSFF 수행부(150a-1)는 특징맵 P2 내지 특징맵 P5 각각에 대하여 풀 링(pooling)을 수행한다. 상기 풀링에 의하여, 특징맵 P2 내지 특징맵 P5 각각은 특정 크기, 예컨대 64 x 64 크 기 혹은 32 x 32 크기로 줄어들 수 있다. 또는, 특징맵 P2 내지 특징맵 P5 중에서 가장 작은 크기를 갖는 특징 맵 P5을 기준으로 나머지 특징맵들(즉, 특징맵 P2, 특징맵 P3 및 P4)이 동일 크기를 갖도록 할 수 있다. 즉, 나 머지 특징맵들(즉, 특징맵 P2, 특징맵 P3 및 P4) 각각에 대해서 풀링(pooling)을 수행하여, 특징맵 P5 크기와 동일하게 만들 수 있다. 그런 다음, 상기 MSFF 수행부(150a-1)는 특징맵 P2 내지 특징맵 P5를 연접시킬 수 있다. 예를 들어 특징맵 P2 내지 특징맵 P5 각각이 64 x 64 크기이면서 256 채널인 큐브(cube) 형태인 경우, 연접후에는 64 x 64 크기이면 서 1024 채널인 큐브 형태로 될 수 있다. 상기 연접된 특징맵들은 SEblock을 통과할 수 있다. 다시 도 11a를 참조하면, 상기 SEBlock은 SE(Squeeze-and-Excitation)에 의한 처리 동작으로서, 피쳐맵의 채널 별 가중치를 계산하고, 이 가중치를 residual unit의 출력 피쳐맵에 곱해줍니다. 또한, 상기 MSFF 수행부는 상 기 SEBlock의 출력에 대하여 컨볼류션을 이용하여 채널 방향의 축소(channel-wise reduction)를 수행할 수 있다. 상기 MSFF 수행부는 최종적으로 출력 F를 상기 SSFC 인코더(150a-2)로 전달할 수 있다.상기 SSFC 인코더 (150a-2)는 상기 MSFF 수행부(150a-1)로부터의 출력 F를 입력받으면, 채널의 개수를 축소시킨 후, 비트스트림을 전송할 수 있다. 이를 위하여, 상기 SSFC 인코더(150a-2)는 컨볼류션과, 배치 정규화 그리고 Tanh 함수를 포함 할 수 있다. 상기 VCM 디코더(150b)(즉, 수신단)은 MSFR 수행부(150b-1)와 SSFC 디코더(150b-2)를 포함할 수 있다. 상기 SSFC 디코더(150b-2)는 상기 비트스트림을 수신하면, 출력 F'를 생성할 수 있다. 이를 위하여, 상기 SSFC 디코 더(150b-2)는 컨볼류션과, 배치 정규화 그리고 PReLu 등을 포함할 수 있다. 상기 VCM 디코더(150b)의 MSFR 수행부(150b-1)는 상기 SSFC 디코더(150b-2)로부터의 출력 F'로부터 P' 레이어 의 특징맵 P2' 내지 특징맵 P5'을 복원해낼 수 있다. 이를 위하여, 상기 MSFR 수행부(150b-1)는 업 샘플링/다운 샘플링과 누적 등을 수행할 수 있다. 도 12는 도 11a의 변형예를 나타낸 예시도이다. 이하, 도 11a과 다른 부분에 대해서만 설명하고 동일한 부분에 대해서는 중복하여 설명하지 않고, 도 11a에 대 한 설명 내용을 원용하기로 한다. 도 12를 참조하여 알 수 있는 바와 같이, VCM 인코더(150a)는 컴프레서(Compressor)(150a-3)을 더 포함할 수 있다. 그리고 VCM 디코더(150b)는 디컴프레서(Decompressor)(150b-3)를 더 포함할 수 있다. 상기 VCM 인코더(150a)의 MSFF 수행부(150a-1)는 도 9b 내지 도 9d에 도시된 특징맵 추출기로부터 추출된 복수 의 특징맵들 중에서 하나 이상을 선택적으로 입력받을 수 있다. 구체적인 예를 들면, 도 9b 내지 도 9d에 도시 된 특징맵 추출기가 도 11b에 도시된 바와 같이 특징맵 P2 내지 특징맵 P5를 추출하였다고 가정해보자. 그러면, 상기 VCM 인코더(150a)의 MSFF 수행부(150a-1)는 상기 특징맵 P2 내지 특징맵 P5 중에서 하나 이상의 특징맵을 필요에 따라 선택적으로 입력받을 수 있다. 도 12의 예시에서는, 상기 특징맵 P2 내지 특징맵 P5 중에서, 특징 맵 P2, 특징맵 P3 그리고 특징맵 P5를 선택적으로 상기 VCM 인코더(150a)의 MSFF 수행부(150a-1)가 입력받는 것으로 나타내어져 있다. 상기 VCM 인코더(150a) 내의 컴프레서(150a-3)는 상기 SSFC 인코더(150a-2)로부터의 출력을 압축할 수 있다. 상 기 압축을 위하여, 상기 VCM 인코더(150a) 내의 컴프레서(150a-3)는 VVC(Versatile Video Coding)(혹은 H.266), CABAC(context-based adaptive binary arithmetic coding), PCA(principal component analysis), DCT(discrete cosine transform) 등을 수행할 수 있다. 또는 상기 압축을 위하여, 상기 VCM 인코더(150a) 내의 컴프레서(150a-3)는 그 밖에 엔트로피 코딩(entropy coding) 기법 등을 이용할 수 있다. 이와 같이 상기 압축을 수행하게 되면, 전송되는 비트스트림의 크기가 크게 줄어들 수 있어, 네트워크 대역폭을 절약할 수 있게 된다. 상기 VCM 디코더(150b)의 디컴프레서(150b-3)은 수신되는 비트스트림을 압축 해제할 수 있다. 이를 위하여, 상 기 VCM 디코더(150b)의 디컴프레서(150b-3)는 VVC(즉, H.266), IDCT(Inverse DCT), IPCA(Inverse PCA) 등을 수 행할 수 있다. 상기 VCM 디코더(150b)의 MSFR 수행부(150b-1)는 상기 SSFC 디코더(150b-2)로부터의 출력 F' 로부터 특징맵 P2' 내지 특징맵 P5'을 복원해낼 수 있다. 그리고, 상기 VCM 디코더(150b)의 MSFR 수행부(150b-1)는 상기 복원 된 특징맵 P2' 내지 특징맵 P5' 중에서 하나 이상을 각 태스크로 전달할 수 있다. 상기 태스크는 예를 들면, 오 브젝트 분류(classification), 오브젝트 검출(detection), 오브젝트 추적(tracking), 오브젝트 세그먼테이션 (segmentation) 등을 포함할 수 있다. 즉, 상기 VCM 디코더(150b)의 MSFR 수행부(150b-1)는 상기 복원된 특징 맵 P2' 내지 특징맵 P5'중에서 특징맵 P5'는 태스크#1로 전달할 수 있고, 특징맵 P2', 특징맵 P3' 그리고 특징 맵 P4'를 태스크#2로 전달할 수 있다. 도 13a는 예시적인 인공신경망 모델 내의 각 레이어 별 데이터의 크기를 기준으로, 본 명세서의 일 개시에 따라 에지 디바이스와 클라우드 서버 사이에 분산 처리되는 예시를 나타낸 개념도이다. 도 13b는 도 13a에 도시된 예 시적 인공신경망 모델에서 각 레이어 별 데이터 사이즈 등을 나타낸 예시적인 테이블이다. 도 13a에 도시된 예시적인 인공신경망 모델은 Mobilenet V1인 것으로 나타나 있다. 도 13a를 참조하면, 가로축 은 예시적인 인공신경망 모델에서 레이어들을 순차적으로 나타내고, 세로축은 데이터의 크기를 나타낸다. 도 13a 및 도 13b에 도시된 레이어 1을 참고하면, 입력 특징맵의 크기(IFMAP_SIZE) 보다 출력 특징맵의 크기 (OFMAP_SIZE)가 더 큰 것을 알 수 있다. 그러나, 도 13a 및 도 13b에 도시된 레이어 12를 참고하면, 출력 특징맵의 크기(OFMAP_SIZE)는 50,176 바이트 (약 50Kb)로서 입력 특징맵의 크기(IFMAP_SIZE)인 200,704 바이트 보다 작을 뿐만 아니라, 레이어 12의 출력 특 징맵의 크기(OFMAP_SIZE)는 전후 인접한 레이어들의 출력 특징맵의 크기 보다도 작다. 또한, 레이어 1부터 레이어 12까지의 가중치들의 합계는 그 크기가 133Kb로 매우 작다. 또한, 레이어 12의 출력 특징맵의 크기는 약 50Kb로 그 크기가 또한 매우 작다. 따라서 각 감시 카메라의 NPU는 레이어 12의 출력 특징맵을 비트스트림 형태로 전송할 수 있다. 이와 같이 크기 가 작은 특징맵을 전송하는 방식을 택하게 되면, 감시 카메라의 대수가 매우 증가하더라도, 통신 네트워크에 큰 부하 혹은 혼잡을 발생시키지 않을 수 있다. 따라서, 도 13a에 도시된 바와 같이, 레이어 1부터 레이어 12까지를 에지 단말의 NPU에서 처리한 후, 레이어 12 의 출력 특징맵을 유선 또는 무선으로 클라우드 서버로 전송하는 방안을 고려해볼 수 있다. 클라우드 서버의 NPU는 수신한 레이어 12의 출력 특징맵을 레이어 13의 입력 특징맵으로 사용하여, 레이어 13부 터 레이어 28까지를 처리할 수 있다. 한편, 레이어 12의 출력 특징맵은 도 11a에 도시된 바와 같이 MSFF 수행부(150a-1) 및 SSFC 인코더(150a-2)를 거쳐, 비트스트림 형태로 전송될 수도 있다. 즉, 레이어 12의 출력 특징맵의 크기는 MSFF 수행부 및 SSFC 인코 더(150a-2)를 통해 압축되어 더 작아질 수 있다. 이와 같이, 인공신경망 모델 내의 레이어들 중에서, 출력 특징맵의 사이즈가 작은 것을 선택하여 전송하게 되면, 네트워크 트래픽을 줄이면서, 컴퓨팅 부하를 분산할 수 있다. 도 14a는 도 13a에 도시된 인공신경망 모델의 레이어 9부터 레이어 13까지의 특징맵을 예시적으로 나타낸 예시 도이다. 도 14a를 참조하면, 도 13a에 도시된 인공신경망 모델의 레이어 9에서 임의 연산(예컨대, 합성곱 연산)을 수행 하면 특징맵 P9이 출력되고, 상기 특징맵 P9은 레이어 10으로 입력된다. 상기 레이어 10에서 임의 연산(예컨대, 합성곱 연산)을 수행하면 특징맵 P10이 출력되고, 상기 특징맵 P10은 레이어 11으로 입력된다. 상기 레이어 11 에서 임의 연산(예컨대, 합성곱 연산)을 수행하면 특징맵 P11이 출력되고, 레이어 12로 입력된다. 마찬가지로, 상기 레이어 12에서 임의 연산(예컨대, 합성곱 연산)을 수행하면 특징맵 P12이 출력되고, 상기 특징맵 P12은 레 이어 13으로 입력된다. 도 14b는 도 14a에 도시된 특징맵 P9부터 특징맵 P12를 압축한 후 비트스트림으로 전송하는 VCM 인코더와 수신 된 비트스트림을 복원하는 VCM 디코더를 일 예시에 따라 나타낸 예시도이다. 도 14b를 참조하여 알 수 있는 바와 같이, VCM 인코더(150a)(혹은 송신단)은 MSFF 수행부(150a-1)와, SSFC 인 코더(150a-2) 그리고 컴프레서(150a-3)를 포함할 수 있다. 그리고 VCM 디코더(150b)(혹은 수신단)은 SSFC 디코 더(150b-1)와 MSFR 수행부(150b-2)와 그리고 디컴프레서(150b-3)를 포함할 수 있다. 이하 도 11a와 도 12와 다 른 부분에 대해서만 설명하고 동일한 부분에 대해서는 중복하여 설명하지 않고, 도 11a와 도 12에 대한 설명 내 용을 원용하기로 한다. 상기 VCM 인코더(150a)의 MSFF 수행부(150a-1)는 도 9b 내지 도 9d에 도시된 특징맵 추출기로부터 추출된 복수 의 특징맵들 중에서 하나 이상을 선택적으로 입력받을 수 있다. 구체적인 예를 들면, 도 9b 내지 도 9d에 도시 된 특징맵 추출기가 도 14a에 도시된 바와 같이 특징맵 P9 내지 특징맵 P12를 추출하였다고 가정해보자. 그러면, 상기 VCM 인코더(150a)의 MSFF 수행부(150a-1)는 상기 특징맵 P9 내지 특징맵 P12 중에서 하나 이상의 특징맵을 필요에 따라 선택적으로 입력받을 수 있다. 도 14b의 예시에서는, 상기 특징맵 P9 내지 특징맵 P12 중 에서, 특징맵 P9, 특징맵 P10 그리고 특징맵 P12를 선택적으로 상기 VCM 인코더(150a)의 MSFF 수행부(150a-1)가 입력받는 것으로 나타내어져 있다. 상기 VCM 디코더(150b)의 MSFR 수행부(150b-1)는 상기 SSFC 디코더(150b-2)로부터의 출력 F' 로부터 특징맵 P9' 내지 특징맵 P12'을 복원해낼 수 있다. 그리고, 상기 VCM 디코더(150b)의 MSFR 수행부(150b-1)는 상기 복원 된 특징맵 P9' 내지 특징맵 P12' 중에서 하나 이상을 각 태스크로 전달할 수 있다. 도 15a는 본 명세서의 개시에 따른 NPU를 동작 관점에서 나타낸 예시도이다. 도 15a를 참고하여 알 수 있는 바와 같이, 전송측 제1 NPU(100a)는 복수의 제1 PE들(110a), 제1 NPU 내부 메모 리(120a), 제1 NPU 컨트롤러(130a), 제1 NPU 인터페이스(140a) 그리고 VCM 인코더(150a)를 포함할 수 있다. 상기 VCM 인코더(150a)는 도 11, 도 12 또는 도 14B에 도시된 바와 같이 MSFF 수행부(150a-1), SSFC 인코더 (150a-2) 그리고 컴프레서(150a-3)를 포함할 수 있다. 그리고, 수신측 제2 NPU(100b)는 복수의 제2 PE들(110b), 제2 NPU 내부 메모리(120b), 제2 NPU 컨트롤러 (130b), 제2 NPU 인터페이스(140b) 그리고 VCM 디코더(150b)를 포함할 수 있다. 상기 VCM 디코더(150b)는 도 11, 도 12 또는 도 14B에 도시된 바와 같이 SSFC 디코더(150b-1)와 MSFR 수행부 (150b-2)와 그리고 디컴프레서(150b-3)를 포함할 수 있다. 도시된 굵은선은 데이터(예, 비디오/이미지, 특징맵, 혹은 비트스트림)의 흐름을 나타내고, 점선은 제어 신호의 흐름을 나타낸다.먼저, 상기 전송측 제1 NPU(100a)가 비디오/이미지를 수신하면, 상기 제1 NPU(100a) 내의 제1 NPU 컨트롤러 (130a)는 제1 NPU 인터페이스(140a)를 통하여, 제1 NPU 내부 메모리(120a)에 저장한다. 이어서, 상기 제1 NPU(100a) 내의 제1 NPU 컨트롤러(130a)는 상기 복수의 제1 PE들(110a)로 하여금 상기 제1 NPU 내부 메모리(120a)로부터 상기 비디오/이미지를 읽어낸 후, ANN 모델의 레이어 별로 연산을 수행하도록 한 다. 상기 복수의 제1 PE들(110a)은 상기 제1 NPU 컨트롤러(130a)로부터의 제어 신호에 따라 상기 ANN 모델의 레이어 별 연산을 수행한 결과로 출력되는 특징맵들을 상기 제1 NPU 내부 메모리(120a)에 저장시킨다. 이처럼 ANN 모델 의 레이어 별로 특징맵들이 저장됨에 따라, 상기 제1 NPU 내부 메모리(120a) 내에는 복수의 특징맵들이 저장될 수 있다. 상기 VCM 인코더(150a)는 상기 제1 NPU 컨트롤러(130a)로부터의 제어 신호에 따라, 상기 제1 NPU 내부 메모리 (120a) 내에 저장된 복수의 특징맵들 중에서 하나 이상의 특징맵을 전송 대상으로 선택할 수 있다. 그러면, 상기 선택된 하나 이상의 특징맵들은 상기 VCM 인코더(150a) 내에서 SSFC 디코더(150b-1)와 MSFR 수행 부(150b-2)와 그리고 디컴프레서(150b-3)를 거쳐서 도 11, 도 12 또는 도 14B에 도시된 바와 같이 비트스트림으 로 변환된다. 이후, 상기 VCM 인코더(150a)는 상기 제1 NPU 컨트롤러(130a)로부터의 제어 신호에 따라, 제1 NPU 인터페이스 (140a)를 통하여 상기 비트스트림을 전송한다. 한편, 상기 수신측 제2 NPU(100b)는 상기 비트스트림을 수신하면, 상기 제2 NPU(100b) 내의 제2 NPU 컨트롤러 (130b)는 제2 NPU 인터페이스(140b)를 통하여, 제2 NPU 내부 메모리(120b)에 저장한다. 상기 수신측 제2 NPU(100b) 내의 VCM 디코더(150b)는 상기 제2 NPU 컨트롤러(130b)의 제어에 따라 상기 제2 NPU 내부 메모리(120b)로부터 상기 비트스트림을 읽어낸다. 상기 읽어진 비트스트림은 상기 VCM 디코더(150b) 내의 SSFC 디코더(150b-1)와 MSFR 수행부(150b-2)와 그리고 디컴프레서(150b-3)를 거친 후 도 11, 도 12 또는 도 14B에 도시된 바와 같이 하나 이상의 특징맵으로 복원된다. 그러면, 상기 VCM 디코더(150b)는 상기 복원된 하나 이상의 특징맵을 상기 제2 NPU 내부 메모리(120b)에 저장한 다. 상기 제2 NPU(100b) 내의 제2 NPU 컨트롤러(130b)는 상기 복수의 제2 PE들(110b)로 하여금 상기 제2 NPU 내부 메모리(120b)로부터 상기 복원된 하나 이상의 특징맵을 읽어낸 후, ANN 모델의 레이어 별로 연산을 수행하도록 한다. 도 14b에 도시된 바와 같이 머신 태스크가 복수개 존재할 경우, 상기 ANN 모델도 복수개가 존재할 수 있다. 도 15b는 전송측 NPU와 수신측 NPU 간의 신호 흐름을 나타낸 흐름도이다. 도 15b를 참조하면, 송신측 NPU(100a)와 수신측 NPU(100b)가 나타나 있다. 수신측 NPU(100b)는 피드백 정보를 송신측 NPU(100a)에게 전송할 수 있다. 상기 피드백 정보는 상기 송신측 NPU(100a)가 하나 이상의 특징맵을 전 송 대상으로 선택할 수 있도록 하는 정보일 수 있다. 예를 들어 상기 피드백 정보는 상기 수신측 NPU(100b)에서 사용되는 머신 태스크와 그리고 대응 ANN 모델에 대한 정보를 포함할 수 있다. 또는, 상기 피드백 정보는 상기 대응 ANN 모델 내의 복수의 레이어들 중에서 하나 이상의 레이어에 대한 식별 정보를 포함할 수 있다. 또는, 상 기 피드백 정보는 상기 송신측 NPU(100a)에서 생성되는 복수의 특징맵 중에서 전송 대상이 되는 하나 이상의 특 징맵에 대한 식별 정보를 포함할 수 있다. 그러면, 상기 송신측 NPU(100a)는 상기 피드백 정보에 기초하여, 복수의 특징맵 중에서 하나 이상의 특징맵을 전송 대상으로 선택할 수 있다. 그리고, 상기 송신측 NPU(100a)는 상기 선택된 특징맵을 인코딩 및/또는 압축한 후, 비트스트림 형태로 전송할 수 있다. 상기 수신측 NPU(100b)는 상기 비트스트림을 수신한 후, 디코딩 및/또는 압축 해제를 수행하여, 특징맵을 복원 할 수 있다.그리고 상기 수신측 NPU(100b)는 상기 복원된 특징맵을 이용하여, ANN 모델의 후속 레이어의 연산을 수행하여, 머신 태스크를 수행할 수 있다. 도 15c는 도 15b의 변형예이다. 도 15c를 참조하면, 송신측 NPU(100a)와 수신측 NPU(100b) 그리고 서버가 나타나 있다. 먼저 상기 서버는 상기 수신측 NPU(100b)가 사용할 ANN 모델에 대한 정보를 상기 송신측 NPU(100a)와 그리 고 상기 수신측 NPU(100b) 모두에게 혹은 어느 하나에 전송할 수 있다. 상기 수신측 NPU(100b)는 피드백 정보를 전송할 수 있다. 상기 피드백 정보는 상기 송신측 NPU(100a)가 하나 이 상의 특징맵을 전송 대상으로 선택할 수 있도록 하는 정보일 수 있다. 예를 들어 상기 피드백 정보는 상기 ANN 모델 내의 복수의 레이어들 중에서 하나 이상의 레이어에 대한 식별 정보를 포함할 수 있다. 또는, 상기 피드백 정보는 상기 송신측 NPU(100a)에서 생성되는 복수의 특징맵 중에서 전송 대상이 되는 하나 이상의 특징맵에 대 한 식별 정보를 포함할 수 있다. 그러면, 상기 송신측 NPU(100a)는 상기 피드백 정보에 기초하여, 복수의 특징맵 중에서 하나 이상의 특징맵을 전송 대상으로 선택할 수 있다. 그리고, 상기 송신측 NPU(100a)는 상기 선택된 특징맵을 인코딩 및/또는 압축한 후, 비트스트림 형태로 전송할 수 있다. 상기 수신측 NPU(100b)는 상기 비트스트림을 수신한 후, 디코딩 및/또는 압축 해제를 수행하여, 특징맵을 복원 할 수 있다. 그리고 상기 수신측 NPU(100b)는 상기 복원된 특징맵을 이용하여, ANN 모델의 후속 레이어의 연산을 수행하여, 머신 태스크를 수행할 수 있다. 도 16은 본 명세서의 일 개시가 적용되는 예시적인 제1 시나리오를 나타낸 예시도이다. 도 16을 참고하여 알 수 있는 바와 같이, 감시(surveillance) 카메라에는 엣지용 NPU가 장착될 수 있다. 상기 엣지용 NPU는 저전력으로 특화된 NPU이다. 상기 NPU는 촬영 영상으로부터 특징맵을 추출할 수 있다. 일반적으로 특징맵의 사이즈는 매우 크기 때문에, 이 를 유선 혹은 무선으로 전송하려면, 상당한 크기의 네트워크 대역폭이 요구되고, 네트워크 혼잡을 야기한다. 또 한, 전력 낭비도 야기된다. 따라서, 본 명세서의 일 개시에 따르면, 감시 카메라에 장착된 NPU는 인공신경망 모델 내의 레이어들 중에서, 출력 특징맵의 사이즈가 작은 것을 선택하여 전송할 수 있다. 상기 출력 특징맵을 전송하기 전에, 상기 감시 카 메라에 장착된 NPU는 도 11a에 도시된 바와 같이 MSFF(Multi-scale feature fusion) 수행부와, SSFC(Single- stream feature codec) 인코더를 통해, 사이즈를 더 줄일 수 있다. 이와 같이 각 감시 카메라가 데이터 사이즈가 작은 특정 레이어, 예컨대 레이어 12를 선택하여, 레이어 12의 특 징맵을 전송하게 되면, 추론 1회 마다 약 4M 바이트의 가중치 사용을 생략할 수 있다. 표 1 Mobilenet V1 Layer 가중치의 합산 MAX IFMAP+OFMAPMAC 연산 EDGE NPU 1~12 133,568 (Kbyte) 1,204,224 (Kbyte) 202,861,568 SERVER NPU13~28 4,075,520(Kbyte) 200,704 (Kbyte) 365,878,784 따라서, 상기 감시 카메라에 장착된 NPU는 인공신경망의 모든 레이어를 처리해야 할 필요가 없고, 그로 인해 복 잡도가 간소화될 수 있다. 예를 들어, 상기 감시 카메라에 장착된 NPU는 인공신경망의 전체 레이어 중에서 임의 레이어까지만 처리하면 되므로, 더 적은 개수의 PE만을 포함할 수 있다. 또한, 상기 감시 카메라에 장착된 NPU 는 더 적은 크기의 SRAM을 포함할 수 있다. 나아가, 상기 카메라에 장착된 NPU는 DRAM(Dynamic random-access memory)은 포함하지 않을 수 있다. 이를 통해, 상기 감시 카메라에 장착될 NPU는 제조 원가를 크게 절감할 수 있다. 또한, 상기 감시 카메라에 장착될 NPU는 소비 전력을 크게 줄일 수 있다.각 감시 카메라는 데이터 사이즈가 작은 특정 레이어를 선택한 후, 해당 특정 레이어의 출력 특징맵을 전송할 수 있다. 이와 같이, 다수의 감시 카메라로부터 전송되는 출력 특징맵들은 멀티플렉서(Multiplexer, MUX)에 의해 시분할 방식으로 다중화되어 클라우드 서버로 전송될 수 있다. 상기 클라우드 서버는 제1 메모리와, NPU를 포함할 수 있다. 상기 클라우드 서버의 상기 제1 메모리는 시분할 방식으로 다중화되어 수신되는 다수의 출력 특징맵을 일시적으 로 저장한다. 또한, 상기 클라우드 서버의 상기 제1 메모리는 상기 감시 카메라의 NPU에 의해서 처리되지 않은 후속 레이어들에서 사용될 가중치들을 저장할 수 있다. 도 12 및 도 13을 참고하여 알 수 있는 바와 같이, 레이 어 13부터 레이어 28까지의 가중치들의 합산 크기는 4075Kb일 수 있다. 이와 같이 레이어 13부터 레이어 28까지 의 가중치들의 합산 크기는 현격히 작지는 않지만, 감시 카메라의 대수가 증가할 수 록, 가중치의 재사용율도 증가되기 때문에, 효율성이 저하되지는 않는다. 상기 제1 메모리를 제어하는 메모리 컨트롤러는 상기 다수의 출력 특징맵들이 상기 제1 메모리로부터 순차적으 로 읽혀질 수 있도록, 메모리 주소를 관리할 수 있다. 상기 메모리 컨트롤러의 제어에 따라 상기 제1 메모리는 상기 다수의 출력 특징맵들을 순차적으로 상기 NPU로 전달한다. 상기 클라우드 서버의 NPU는 상기 제1 메모리로부터 읽어온 각 카메라로부터의 레이어 12의 출력 특징맵을 레이 어 13의 입력 특징맵으로 활용하고 상기 제1 메모리로부터 읽어온 가중치를 이용하여, 연산을 수행한다. 한편, 상기 클라우드 서버의 NPU가 레이어 13부터 레이어 28까지를 처리하면서 상기 제1 메모리에 씌여지거나 읽혀지는 출력 특징맵과 입력 특징맵의 크기는 도 12 및 도 13을 참고하여 알 수 있는 바와 같이 그리 크지 않 기 대문에(감시 카메라 1대당 200kb에 불과함), 상기 클라우드 서버는 많은 대수의 카메라를 위한 인공신경망 연산을 처리할 수 있다. 도 17은 본 명세서의 일 개시가 적용되는 예시적인 제2 시나리오를 나타낸 예시도이다. 도 17에 도시된 차량 카메라는 엣지용 NPU를 포함할 수 있다. 상기 차량 카메라에 장착된 NPU는 전술한 바와 마 찬가지로 인공신경망 모델 내의 레이어들 중에서, 출력 특징맵의 사이즈가 작은 것을 선택하여 전송할 수 있다. 상기 출력 특징맵을 전송하기 전에, 상기 감시 카메라에 장착된 NPU는 도 11a에 도시된 바와 같이 MSFF(Multi- scale feature fusion) 수행부와, SSFC(Single-stream feature codec) 인코더를 통해, 사이즈를 더 줄일 수 있 다. 클라우드 서버는 서버용 NPU를 포함할 수 있다. 상기 클라우드 서버의 NPU는 각 차량 카메라로부터의 출력 특징 맵을 입력 특징맵으로 활용하여, 연산을 수행한다. 그리고 상기 클라우드 서버의 NPU는 상기 연산의 결과로서 차량 제어 신호를 생성하여, 각 차량으로 전송할 수 있다. 그 밖에 자세한 내용은 전술한 내용과 동일하므로, 중복하여 설명하지 않기로 한다. 본 명세서와 도면에 나타난 본 개시의 예시들은 본 개시의 기술 내용을 쉽게 설명하고 본 개시의 이해를 돕기 위해 특정 예를 제시한 것뿐이며, 본 명의 범위를 한정하고자 하는 것은 아니다. 지금까지 설명한 예시들 이외 에도 다른 변형 예들이 실시 가능하다는 것은 본 개시가 속하는 기술 분야에서 통상의 지식을 가진 자에게 자명 한 것이다. 본 명세서에 기재된 청구항들은 다양한 방식으로 조합될 수 있다. 예를 들어, 본 명세서의 방법 청구항의 기술 적 특징이 조합되어 장치로 구현될 수 있고, 본 명세서의 장치 청구항의 기술적 특징이 조합되어 방법으로 구현 될 수 있다. 또한, 본 명세서의 방법 청구항의 기술적 특징과 장치 청구항의 기술적 특징이 조합되어 장치로 구 현될 수 있고, 본 명세서의 방법 청구항의 기술적 특징과 장치 청구항의 기술적 특징이 조합되어 방법으로 구현 될 수 있다.도면 도면1 도면2 도면3 도면4 도면5a 도면5b 도면6 도면7 도면8a 도면8b 도면9a 도면9b 도면9c 도면9d 도면10a 도면10b 도면11a 도면11b 도면11c 도면12 도면13a 도면13b 도면14a 도면14b 도면15a 도면15b 도면15c 도면16 도면17"}
{"patent_id": "10-2022-0175322", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 비디오/영상 코딩 시스템의 예를 개략적으로 나타낸다. 도 2는 비디오/영상 인코딩 장치의 구성을 개략적으로 설명하는 도면이다. 도 3은 비디오/영상 디코딩 장치의 구성을 개략적으로 설명하는 도면이다. 도 4는 본 개시에 따른 신경 프로세싱 유닛을 설명하는 개략적인 개념도이다. 도 5a는 본 개시에 적용될 수 있는 복수의 프로세싱 엘리먼트 중 하나의 프로세싱 엘리먼트를 설명하는 개략적 인 개념도이다. 도 5b는 본 개시에 적용될 수 있는 SFU를 설명하는 개략적인 개념도이다. 도 6은 도 4에 도시된 신경 프로세싱 유닛의 변형예를 나타낸 예시도이다. 도 7은 예시적인 인공신경망모델을 설명하는 개략적인 개념도이다. 도 8a은 컨볼루션 신경망의 기본 구조를 설명하기 위한 도면이다. 도 8b는 컨볼루션 신경망의 동작을 이해하기 쉽게 나타낸 종합도이다. 도 9a 내지 도 9d는 VCM 인코더를 포함하는 NPU와 VCM 디코더를 포함하는 NPU를 나타낸 예시도들이다. 도 10a 및 도 10b는 인공신경망모델에서 비트스트림의 위치를 나타낸 예시도이다. 도 11a은 특징맵을 압축하는한 후 비트스트림으로 전송하는 예를 VCM 인코더와 수신된 비트스트림을 복원하는 VCM 디코더를 일 예시에 따라 나타내고, 도 11b는 도 11a에 도시된 특징맵 P2 내지 특징맵 P5를 생성하는 예를 나타낸다. 도 11c는 도 11a에 도시된 MSFF 수행부를 자세하게 나타낸 예시도이다. 도 12는 도 11a의 변형예를 나타낸 예시도이다. 도 13a는 예시적인 인공신경망 모델 내의 각 레이어 별 데이터의 크기를 기준으로, 본 명세서의 일 개시에 따라 에지 디바이스와 클라우드 서버 사이에 분산 처리되는 예시를 나타낸 개념도이다. 도 13b는 도 13a에 도시된 예시적 인공신경망 모델에서 각 레이어 별 데이터 사이즈 등을 나타낸 예시적인 테이 블이다. 도 14a는 도 13a에 도시된 인공신경망 모델의 레이어 9부터 레이어 13까지의 특징맵을 예시적으로 나타낸 예시 도이다. 도 14b는 도 14a에 도시된 특징맵 P9부터 특징맵 P12를 압축한 후 비트스트림으로 전송하는 VCM 인코더와 수신 된 비트스트림을 복원하는 VCM 디코더를 일 예시에 따라 나타낸 예시도이다. 도 15a는 본 명세서의 개시에 따른 NPU를 동작 관점에서 나타낸 예시도이다.도 15b는 전송측 NPU와 수신측 NPU 간의 신호 흐름을 나타낸 흐름도이다. 도 15c는 도 15b의 변형예이다. 도 16은 본 명세서의 일 개시가 적용되는 예시적인 제1 시나리오를 나타낸 예시도이다. 도 17은 본 명세서의 일 개시가 적용되는 예시적인 제2 시나리오를 나타낸 예시도이다."}
