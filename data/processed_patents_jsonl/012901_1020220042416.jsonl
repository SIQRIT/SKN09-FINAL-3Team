{"patent_id": "10-2022-0042416", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0143473", "출원번호": "10-2022-0042416", "발명의 명칭": "전자 장치의 악성 스크립트 탐지 방법", "출원인": "국방과학연구소", "발명자": "구성모"}}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "전자 장치의 악성 스크립트 탐지 방법에 있어서,시스템 이벤트로부터 대상 스크립트의 실행을 탐지하는 단계;상기 대상 스크립트의 실행 로그를 기초로 행위를 확인하는 단계;확인된 행위를 기초로 상기 대상 스크립트에 대응하는 대상 벡터를 생성하는 단계; 및상기 대상 벡터를 기초로 상기 대상 스크립트의 악성 여부를 확인하는 단계를 포함하는, 악성 스크립트 탐지 방법."}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 행위를 확인하는 단계는,미리 정의된 명령어 사전을 이용하여, 상기 실행 로그로부터 적어도 하나의 명령어를 확인하고, 상기 적어도 하나의 명령어에 관한 정보를 확인하는 단계; 및상기 대상 벡터를 생성하는 단계는,상기 적어도 하나의 명령어에 관한 정보를 기초로 상기 대상 스크립트에 대응하는 상기 대상 벡터를 구성하는단계를 포함하는, 악성 스크립트 탐지 방법."}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 대상 벡터를 구성하는 단계는,상기 적어도 하나의 명령어 각각의 식별자를 나열하는 단계를 포함하는, 악성 스크립트 탐지 방법."}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 악성 여부를 확인하는 단계는,상기 대상 벡터 및 기준 벡터 사이의 유사도를 확인하고, 확인된 유사도를 기초로 상기 대상 스크립트의 악성여부를 판정하는 단계를 포함하는, 악성 스크립트 탐지 방법."}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 악성 여부를 판정하는 단계는,상기 유사도가 기 설정된 수치 이상인 경우, 상기 대상 스크립트를 악성 스크립트로 판정하는 단계를 포함하는,악성 스크립트 탐지 방법."}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제4항에 있어서,상기 유사도는 자카드 유사도(Jaccard Similarity)인, 악성 스크립트 탐지 방법.공개특허 10-2023-0143473-3-청구항 7 제1항에 있어서,상기 악성 여부를 확인하는 단계는,소정의 알고리즘을 이용하여 상기 대상 벡터에 대한 적어도 하나의 최근접 이웃(nearest neighbor) 기준 벡터를확인하는 단계; 및상기 적어도 하나의 최근접 이웃 기준 벡터 중 악성으로 분류되는 최근접 이웃 기준 벡터의 수가 상기 최근접이웃 기준 벡터 중 악성이 아닌 것으로 분류되는 최근접 이웃 기준 벡터의 수 이상인 경우, 상기 대상 스크립트를 악성 스크립트로 판정하는 단계를 포함하는, 악성 스크립트 탐지 방법."}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 악성 여부를 확인하는 단계는,입력 벡터를 처리하여 상기 입력 벡터에 대응하는 스크립트의 악성 여부를 출력하도록 학습된 인공신경망을 이용하여, 상기 대상 벡터로부터 상기 대상 스크립트의 악성 여부를 확인하는 단계를 포함하는, 악성 스크립트 탐지 방법."}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서,상기 대상 스크립트는 파워쉘(Powershell) 스크립트를 포함하는, 악성 스크립트 탐지 방법."}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "전자 장치로서, 적어도 하나의 프로그램이 저장된 메모리; 및상기 적어도 하나의 프로그램을 실행함으로써,시스템 이벤트로부터 대상 스크립트의 실행을 탐지하고,상기 대상 스크립트의 실행 로그를 기초로 행위를 확인하고,확인된 행위를 기초로 상기 대상 스크립트에 대응하는 대상 벡터를 생성하고,상기 대상 벡터를 기초로 상기 대상 스크립트의 악성 여부를 확인하는 프로세서를 포함하는, 전자 장치."}
{"patent_id": "10-2022-0042416", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "전자 장치의 악성 스크립트 탐지 방법을 컴퓨터에서 실행시키기 위한 프로그램을 기록한 컴퓨터로 읽을 수 있는비일시적 기록매체로서, 상기 악성 스크립트 탐지 방법은,시스템 이벤트로부터 대상 스크립트의 실행을 탐지하는 단계;상기 대상 스크립트의 실행 로그를 기초로 행위를 확인하는 단계;확인된 행위를 기초로 상기 대상 스크립트에 대응하는 대상 벡터를 생성하는 단계; 및상기 대상 벡터를 기초로 상기 대상 스크립트의 악성 여부를 확인하는 단계를 포함하는, 비일시적 기록 매체."}
{"patent_id": "10-2022-0042416", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "시스템 이벤트로부터 대상 스크립트의 실행을 탐지하고, 대상 스크립트의 실행 로그를 기초로 행위를 확인하고, 확인된 행위를 기초로 대상 스크립트에 대응하는 대상 벡터를 생성하고, 대상 벡터를 기초로 대상 스크립트의 악 성 여부를 확인하는 전자 장치 및 그의 동작 방법을 제공한다."}
{"patent_id": "10-2022-0042416", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 전자 장치의 악성 스크립트 탐지 방법에 관한 것이다."}
{"patent_id": "10-2022-0042416", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "사이버 공격이 지능화/고도화 되고 있으며, 흔적을 찾기 어려운 Fileless 및LOL(Living Off the Land) 형태의 공격이 빈번하게 발생하고 있다. 특히 파워쉘(Powershell) 공격은 전체 공격 중 28%에 이르고 있다. 파워쉘 공 격에 대해 스크립트를 파싱해서 악성 스크립트를 탐지하는 방법이 있으나, 악성 스크립트는 대부분 난독화 되어 있기 때문에 파싱하기 어렵다."}
{"patent_id": "10-2022-0042416", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명에 따르면, 전자 장치는 본 발명에서 기술되는 방법을 수행하는 프로세서를 포함하여, 스크립트의 실행 로그를 기초로 행위를 확인하고, 벡터를 생성하여 스크립트가 악성 스크립트인지 확인할 수 있다. 본 발명이 이루고자 하는 기술적 과제는 상기된 바와 같은 과제로 한정되지 않으며, 이하의 실시예들로부터 또 다른 기술적 과제들이 유추될 수 있다."}
{"patent_id": "10-2022-0042416", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시예에 따라, 전자 장치의 악성 스크립트 탐지 방법에 있어서, 시스템 이벤트로부터 대상 스크립트의 실행 을 탐지하는 단계; 대상 스크립트의 실행 로그를 기초로 행위를 확인하는 단계; 확인된 행위를 기초로 대상 스 크립트에 대응하는 대상 벡터를 생성하는 단계; 대상 벡터를 기초로 대상 스크립트의 악성 여부를 확인하는 단 계를 포함할 수 있다. 일 실시예에 따라, 악성 스크립트 탐지를 위한 전자 장치로서, 적어도 하나의 프로그램이 저장된 메모리; 및 적 어도 하나의 프로그램을 실행함으로써, 시스템 이벤트로부터 대상 스크립트의 실행을 탐지하고, 대상 스크립트 의 실행 로그를 기초로 행위를 확인하고, 확인된 행위를 기초로 대상 스크립트에 대응하는 대상 벡터를 생성하 고, 대상 벡터를 기초로 대상 스크립트의 악성 여부를 확인하는 프로세서를 포함할 수 있다. 일 실시예에 따라, 컴퓨터로 읽을 수 있는 기록매체는 상술한 동작 방법을 컴퓨터에서 실행시키기 위한 프로그 램을 기록한 비일시적 기록매체를 포함할 수 있다. 기타 실시예들의 구체적인 사항은 상세한 설명 및 도면들에 포함된다."}
{"patent_id": "10-2022-0042416", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "난독화 되어 있는 악성 스크립트는 복호화 전에 탐지하기는 어려우나, 본 발명을 이용하면 스크립트 실행 직후 로그를 통해 이상행위를 탐지할수 있어, 즉각적으로 공격 행위를 식별할 수 있다. 또한, 본 발명을 이용하면 APT(지능적 지속 공격)와 같이 목표에 대한 장기적인 공격들도 초기에 식별될 수 있 어 공격의 Dwell-Time(공격 지속시간)을 최소화 하는데 기여할 수 있다. 또한, 본 발명을 이용하면 LOL(living-off-the-land) 기법과 같은 시스템의 합법적인 도구를 기반으로 활동하는 악성 행위도 탐지할 수 있다."}
{"patent_id": "10-2022-0042416", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 2, "content": "발명의 효과는 이상에서 언급한 효과만으로 제한되지 않으며, 언급되지 않은 또 다른 효과들은 청구범위 기재로 부터 당해 기술 분야의 통상의 기술자에게 명확하게 이해될 수 있다."}
{"patent_id": "10-2022-0042416", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 개시에 기술된 실시예는 본 개시를 제한하는 것이 아니라 예시하는 것이고, 통상의 기술자는 첨부된 청구범 위에 의해 정의된 본 개시의 범주를 벗어나지 않으면서, 다수의 대안적인 실시예를 설계할 수 있다. 실시 예들 에서 사용되는 용어는 본 개시에서의 기능을 고려하면서 가능한 현재 널리 사용되는 일반적인 용어들을 선택하 였으나, 이는 당 분야에 종사하는 기술자의 의도 또는 판례, 새로운 기술의 출현 등에 따라 달라질 수 있다. 또 한, 특정한 경우는 출원인이 임의로 선정한 용어도 있으며, 이 경우 해당되는 설명 부분에서 상세히 그 의미를 기재할 것이다. 따라서 본 개시에서 사용되는 용어는 단순한 용어의 명칭이 아닌, 그 용어가 가지는 의미와 본 개시의 전반에 걸친 내용을 토대로 정의되어야 한다. 본 명세서에서 사용되는 단수의 표현은 문맥상 명백하게 반대되는 기재가 존재하지 않는 한, 단수는 물론 복수 를 모두 포함한다. 본 명세서 전체에서 어떤 부분이 어떤 구성요소들 또는 어떤 단계들을 \"포함\"한다고 할 때, 이는 특별히 반대되 는 기재가 없는 한, 어떤 부분이 구성요소들 또는 단계들을 반드시 모두 포함해야 하는 것은 아니고, 청구범위 또는 명세서 전체에 열거된 것 이외의 구성요소 또는 단계가 포함되는 것을 배제하는 것도 아니며, 단지 이들을 더 포함할 수 있음을 의미한다. 또한, 본 명세서에서 사용되는 제1, 제2 등과 같이 서수를 포함하는 용어는 다양한 구성요소들을 설명하는데 사 용될 수 있지만, 상기 구성요소들은 상기 서수를 포함하는 용어들에 의해 한정되어서는 안 된다. 상기 용어들은 문맥상 명세서의 일 부분에서 일 구성요소를 다른 구성요소로부터 구별하는 목적으로만 사용된다. 예를 들어, 본 발명의 권리범위를 벗어나지 않으면서 제1 구성요소는 명세서의 다른 부분에서 제2 구성요소로 명명될 수 있 고, 반대로 제2 구성요소도 명세서의 다른 부분에서 제1 구성요소로 명명될 수 있다. 본 명세서에서 \"매커니즘\", \"요소\", \"수단\", \"구성\"과 같은 용어는 넓게 사용될 수 있으며, 기계적이고 물리적 인 구성들로서 한정되는 것은 아니다. 상기 용어는 프로세서 등과 연계하여 소프트웨어의 일련의 처리들 (routines)의 의미를 포함할 수 있다. 본 명세서(특히 청구범위에서)에서 \"상기\"의 용어 및 이와 유사한 지시 용어의 사용은 단수 및 복수 모두에 해 당하는 것일 수 있다. 또한, 범위(range)를 기재한 경우 상기 범위에 속하는 개별적인 값을 포함하는 것으로서 (이에 반하는 기재가 없다면), 상세한 설명에 상기 범위를 구성하는 각 개별적인 값을 기재한 것과 같다. 마지 막으로, 방법을 구성하는 단계들에 대하여 명백하게 순서를 기재하거나 반하는 기재가 없다면, 상기 단계들은 적당한 순서로 재배열되어 행해질 수 있고, 반드시 상기 단계들의 기재 순서에 한정되는 것은 아니다. 모든 예 들 또는 예시적인 용어(예들 들어, 등등)의 사용은 단순히 기술적 사상을 상세히 설명하기 위한 것으로서 청구 범위에 의해 한정되지 않는 이상 상기 예들 또는 예시적인 용어로 인해 범위가 한정되는 것은 아니다. 통상의 기술자는 본 명세서에 개시된 실시예에 설계 조건 및 팩터에 따라 다양한 수정, 조합 및 변경을 부가하여 특허 청구범위 또는 그 균등물의 범주에 속하는 새로운 실시예를 구성할 수 있다. 이하에서는 도면을 참조하여 본 개시의 실시예를 설명한다. 도 1 은 본 개시의 적어도 하나의 실시예를 실행하는데 사용될 수 있는 전자 장치의 예시적이고 단순화된 블록도를 나타낸다. 다양한 실시예에서, 전자 장치는 본 개시에서 서술된 임의의 시스템 또는 방법을 구현 하는데 사용될 수 있다. 예를 들어, 전자 장치는 데이터 서버, 웹 서버, 휴대용 컴퓨팅 디바이스, 개인용 컴퓨터, 태블릿 컴퓨터, 워크스테이션, 휴대폰, 스마트 폰(smart phone) 또는 아래에서 서술되는 임의의 다른 디바이스를 포함하는 임의의 전자 장치로서 사용되도록 구성될 수 있다. 전자 장치는 메모리 및 메모리와 통신하도록 구성될 수 있는 하나 이상의 캐시 메모리 및 메모 리 제어기를 갖는 하나 이상의 프로세서를 포함할 수 있다. 추가적으로, 전자 장치는 하나 이상의 포 트(예컨대, USB(Universal Serial Bus), 헤드폰 잭, 라이트닝(Lightning) 커넥터, 썬더볼트(Thunderbolt) 커넥 터 등)를 통해 전자 장치에 연결될 수 있는 다른 디바이스를 포함할 수 있다. 전자 장치에 연결될 수 있는 디바이스는 광섬유 커넥터를 수용하도록 구성되는 복수의 포트를 포함할 수 있다. 도시된 전자 장치 의 구성은 디바이스의 바람직한 실시예를 예시할 목적으로 특정 예시로서만 의도된다. 도시된 전자 장치에 는 본 실시예들과 관련된 구성요소들만이 도시되어 있다. 따라서, 전자 장치에 도시된 구성요소들 외에 다"}
{"patent_id": "10-2022-0042416", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "른 범용적인 구성요소들이 더 포함될 수 있음은 당해 기술분야의 통상의 기술자에게 자명하다. 프로세서는 전자 장치가 본 개시에서 서술된 임의의 실시예의 단계 또는 기능을 제공하도록 하기 위 해 이용될 수 있다. 예를 들어, 프로세서는 전자 장치 내의 메모리에 저장된 프로그램들을 실행 함으로써, 전자 장치를 전반적으로 제어한다. 프로세서는 전자 장치 내에 구비된 CPU(centralprocessing unit), GPU(graphics processing unit), AP(application processor) 등으로 구현될 수 있으나, 이 에 제한되지 않는다. 메모리는 전자 장치 내에서 처리되는 각종 데이터들을 저장하는 하드웨어로서, 메모리는 전자 장치에서 프로세서를 통해 처리된 데이터들 및 처리될 데이터들을 저장할 수 있다. 또한, 메모리 는 본 개시의 적어도 하나의 실시예의 기능을 제공할 수 있는 기본 프로그래밍 및 데이터 구조를 저장하는 것은 물론, 본 개시의 실시예의 기능을 제공할 수 있는 애플리케이션들(프로그램, 코드 모듈, 명령어), 드라이 버들 등을 저장할 수 있다. 메모리는 DRAM(dynamic random access memory), SRAM(static random access memory) 등과 같은 RAM(random access memory), ROM(read-only memory), EEPROM(electrically erasable programmable read-only memory), CD-ROM, 블루레이 또는 다른 광학 디스크 스토리지, HDD(hard disk drive), SSD(solid state drive), 또는 플래시 메모리를 포함할 수 있다. 일 실시예에서, 프로세서는 시스템 이벤트로부터 대상 스크립트의 실행을 탐지할 수 있다. 시스템 이벤트 는 대상 스크립트의 시작 여부 및 시작 시간을 포함할 수 있고, 프로세서는 시스템 이벤트로부터 대상 스 크립트의 시작 및 대상 스크립트의 시작 시간을 확인할 수 있다. 프로세서는 대상 스크립트의 시작 및 대 상 스크립트의 시작 시간을 기초로 대상 스크립트의 실행 로그를 확인할 수 있다. 일 실시예에서, 스크립트는 파워쉘(Powershell) 스크립트를 포함할 수 있다. 다만, 본 개시에 따른 스크립트는 이에 한정되지 않는다. 스크립트는 응용 프로그램 또는 운영 체제의 동작을 제어하는 명령을 포함하는 그 어떤 것도 될 수 있다. 예를 들어, 스크립트는 윈도우즈 명령 프롬프트(Windows Command Prompt, cmd.exe) 또는 유 닉스 쉘(UNIX shell)(예를 들어, 배쉬(bash))과 같은 명령줄 쉘(command-line shell)에 의해 실행될 수 있는 명령문의 집합일 수 있다. 일 실시예에서, 프로세서는 대상 스크립트의 실행 로그를 기초로 행위를 확인할 수 있다. 스크립트의 실행 로그에는 대상 스크립트의 행위가 포함될 수 있다. 구체적으로, 행위는 대상 스크립트가 제어하거나 실행한 명 령어, 매개 변수 또는 전달 인자를 포함할 수 있다. 명령어는 명령행(파워쉘의 cmdlet 등) 또는 함수의 이름 또 는 별칭을 포함할 수 있다. 매개 변수 또는 전달 인자는 명령어 실행에 필요한 입력 값을 포함할 수 있다. 예를 들어, 매개 변수 또는 전달 인자는 프로세스명, 파일명, 파일 경로, URL(Uniform Resource Locator), 플래그 또는 스위치 등을 포함할 수 있다. 도 2 는 본 개시에 따라 스크립트 실행 로그로부터 행위를 식별하는 방법의 일 실시예를 나타낸다. 일 실시예에서, 프로세서는 미리 정의된 명령어 사전을 이용하여, 실행 로그로부터 적어도 하나 의 명령어를 확인하고, 적어도 하나의 명령어에 관한 정보를 확인할 수 있다. 일 실시예에서, 명령어 사전은 메모리에 저장될 수 있다. 프로세서는 메모리를 참조하여, 명령어 사전의 내용을 확인할 수 있다. 또 다른 실시예에서, 명령어 사전은 본 개시에 따른 전자 장 치 외부에 존재하는 외부 저장소에 저장된 것일 수 있다. 이 경우, 프로세서는 별도의 입력 또는 출 력 디바이스를 이용하여 외부 저장소에 직접 액세스하여 명령어 사전의 내용을 확인할 수 있다. 또는, 프 로세서는 외부 저장소 또는 외부 저장소를 관리하는 외부 디바이스에 명령어 사전의 전부 또는 일부 를 요청할 수 있고, 이에 대응하여 외부 저장소 또는 외부 저장소를 관리하는 외부 디바이스는 프로세서에 명령어 사전의 전부 또는 일부를 송신할 수 있다. 프로세서는 외부 저장소 또는 외부 저장소를 관리 하는 외부 디바이스로부터 명령어 사전의 전부 또는 일부를 수신하여 명령어 사전의 내용을 바로 확 인하거나, 상기 명령어 사전의 전부 또는 일부를 메모리에 저장할 수 있다. 이는 명령어 사전이 메모리에 전부 저장되는 경우보다 메모리 저장 공간을 절약할 수 있는 이점이 있다. 명령어 사전은 미리 준비될 수 있다. 다만, 명령어 사전은 이에 한정되지 않는다. 예를 들어, 명령어 사전은 본 개시에 따른 악성 스크립트 탐지 결과 또는 다른 프로그램에 의한 악성 스크립트 탐지 결과를 반영하여 갱신될 수 있다. 이는 명령어 사전이 최신화되어, 본 개시에 따른 프로세서가 새로운 악성 스크립트를 더 잘 탐지할 수 있도록 하는 이점이 있다. 일 실시예에서, 명령어 사전은 스크립트, 바람직하게는 악성 스크립트에 빈번하게 사용되는 명령어 및 명 령어에 관한 정보를 포함할 수 있다. 도 2 에 나타난 것과 같이, 명령어 사전은 행과 열을 갖는 테이블 형 태일 수 있다. 테이블의 각 행(221, 222, 223)은 사전에 수록된 서로 다른 명령어의 정보를 포함할 수 있다. 다 만, 명령어 사전은 도 2 에 나타난 것과 같이 테이블에만 한정되지 않으며, 서로 다른 명령어의 이름과 각 명령어에 대한 정보를 포함할 수 있는 유사한 다른 데이터 구조로 구성될 수 있다. 데이터 입출력의 속도 및 저장 공간 효율을 고려하여 적절한 데이터 구조가 선택될 수 있다. 명령어 사전의 테이블의 각 행(221, 222, 223)에는 각 명령어의 식별자(ID)가 수록될 수 있다. 명령어 사 전의 식별자(ID)는 사용자에 의해 또는 미리 정해진 규칙에 따라 부여될 수 있다. 예를 들어, 식별자는 명 령어 사전에 해당 명령어가 추가된 순서대로 부여된 순번일 수 있다. 또 다른 예를 들어, 식별자는 명령어 사전 내 중요도 순서대로 부여된 순번일 수 있다. 명령어 사전의 테이블의 각 행(221, 222, 223)에는 각 명령어의 구분(분류 또는 타입)이 수록될 수 있다. 이는 사용자가 명령어 사전을 이용하여 스크립트에 포함된 명령어 중 특정 구분에 속하는 명령어가 몇 개 인지 계산하는 등의 통계적 분석에 도움이 될 수 있다. 명령어 사전의 테이블의 각 행(221, 222, 223)에는 각 명령어의 용도가 수록될 수 있다. 이는 사용자가 명 령어 사전을 이용하여 각 명령어의 역할 또는 용도를 쉽게 알 수 있도록 도울 수 있다. 명령어 사전의 테이블의 각 행(221, 222, 223)에는 도 2 에는 도시되지 않은 각 명령어에 대한 다른 정보 가 포함될 수 있다. 예를 들어, 명령어 사전의 테이블의 각 행(221, 222, 223)에는 각 명령어의 입력 또는 출력이 포함될 수 있다. 명령어 사전에 수록된 입력 또는 출력은 본 개시에 따른 벡터를 생성할 때 사용될 수 있다. 이에 대하여는 이후에 자세히 설명한다. 실행 로그는 스크립트의 행위에 관한 텍스트 또는 토큰(token)을 포함할 수 있다. 예를 들어, 실행 로그는 행위에 포함된 명령어, 즉, 명령어 또는 함수의 이름 또는 별칭 등을 텍스트 형태로 포함할 수 있다. 프로세서는 실행 로그의 텍스트를 분석하여 명령어 또는 함수의 이름 또는 별칭 등을 추출 할 수 있다. 프로세서는 실행 로그의 텍스트로부터 명령어 사전에 수록된 명령어 또는 함수의 이름 또는 별 칭의 텍스트 또는 토큰을 확인할 수 있다. 구체적으로, 도 2 에 따르면, 프로세서는 스크립트 실행 로그 의 텍스트와 명령어 사전에 포함된 명령어 텍스트를 서로 매칭할 수 있다. 예를 들어, 프로세서(11 0)는 명령어 사전에 포함된 모든 명령어의 이름 각각이 실행 로그의 텍스트에 포함되는지 확인할 수 있다. 또 다른 예를 들어, 프로세서는 명령어 사전에 포함된 특정 명령어의 이름이 실행 로그의 텍스트에 포함되는지 확인할 수 있다. 프로세서는 명령어 사전을 이용하여, 명령어 사전에 포함된 적어도 하나의 명령어에 관한 정보 를 확인할 수 있다. 구체적으로, 프로세서는 명령어 사전에 포함된 특정 명령어의 이름, 식별자, 구 분, 용도, 입력 또는 출력 등의 정보를 확인할 수 있다. 프로세서는 도 2 와 같이, 명령어 사전에 포함된 명령어 중 스크립트 실행 로그에 포함된 명령 어의 이름을 나열하고, 이를 행위로서 확인할 수 있다. 도 3 은 본 개시에 따라 대상 스크립트로부터 대상 벡터를 생성하는 방법의 일 실시예를 나타낸다. 일 실시예에서, 프로세서는 확인된 행위를 기초로 대상 스크립트에 대응하는 대상 벡터를 생성 할 수 있다. 구체적으로, 프로세서는 적어도 하나의 명령어에 관한 정보를 기초로 대상 스크립트 에 대응하는 대상 벡터를 구성할 수 있다. 도 2 에 관한 설명에서 자세히 설명한 것과 같이, 프로세서는 미리 정의된 명령어 사전을 이용하여, 실행 로그로부터 적어도 하나의 명령어를 확인하고, 적어도 하나의 명령어에 관한 정보를 확인할 수 있다. 적어도 하나의 명령어에 관한 정보는 대상 스크립트에 나타나는 명령어의 이름을 나열한 것일 수 있다. 이 때, 명령어 이름의 나열은 대상 스크립트 또는 실행 로그에 각 명령어가 나타나는 순서 에 기초할 수 있다. 예를 들어, 도 3 의 대상 스크립트에는 Get-process 명령어, bitsadmin 명령어 및 WebClient 명령어가 순서대로 나타나므로, 적어도 하나의 명령어에 관한 정보에는 Get-process 명령어, bitsadmin 명령어 및 WebClient 명령어의 이름인 Get-process, bitsadmin 및 WebClient가 순서대로 나열될 수 있다. 하지만, 적어도 하나의 명령어에 관한 정보에 각 명령어 이름이 나열되는 기준은 이에 한정되지 않 는다. 예를 들어, 각 명령어 이름의 순서는 적어도 하나의 명령어에 관한 정보에 해당 명령어가 추가된 순 서일 수 있다. 또 다른 예를 들어, 각 명령어 이름의 순서는 적어도 하나의 명령어에 관한 정보 내에서 각 명령어의 중요도 순서일 수 있다. 일 실시예에서, 적어도 하나의 명령어에 관한 정보는 대상 스크립트의 식별자 또는 파일명을 포함할 수 있 다. 이는 적어도 하나의 명령어에 관한 정보가 복수의 스크립트에 관한 것일 경우, 적어도 하나의 명령어에 관한 정보 중 대상 스크립트에 대응하는 정보가 무엇인지 식별할 수 있게 되는 이점이 있다. 일 실시예에서, 적어도 하나의 명령어에 관한 정보는 도 3 에 나타난 것과 같이 그래프 또는 트리 형태의 구조를 포함할 수 있다. 구체적으로, 트리의 루트(root) 노드는 대상 스크립트의 식별자 또는 파일명 정보 를 포함할 수 있고, 루트 노드에 연결된 자식 노드(322, 323, 324) 각각에 각 명령어에 대응되는 정보가 포함될 수 있다. 예를 들어, 제1 자식 노드, 제2 자식 노드 및 제3 자식 노드는 각각 Get- process 명령어, bitsadmin 명령어 및 WebClient 명령어의 정보가 포함할 수 있다. 도 3 에 나타난 실시예에서 는, 제1 자식 노드, 제2 자식 노드 및 제3 자식 노드가 각각 Get-process 명령어, bitsadmin 명령어 및 WebClient 명령어의 이름을 포함하는 것으로 도시되어 있다. 어떤 명령어는 해당 명령어가 동작하는 방식이 복수 개일 수 있고, 명령어는 입력 매개변수로서 스위치 또는 플 래그 입력을 가질 수 있다. 예를 들어, 도 3 의 대상 스크립트에 나타난 것과 같이, bitsadmin 명령어는 bitsadmin의 동작 방법에 관한 플래그 또는 스위치 입력 매개변수로서 /transfer를 포함할 수 있다. 명령어 사 전은 명령어의 입력 매개변수 또는 전달 인자에 관한 정보를 포함할 수 있고, 프로세서는 대상 스크립트 에서 명령어의 입력 매개변수(예를 들어, 위와 같은 스위치 또는 플래그 입력)의 텍스트 또는 토큰을 확인 하고, 텍스트 또는 토큰이 명령어 사전에 포함된 경우, 적어도 하나의 명령어에 관한 정보에 이를 포함시 킬 수 있다. 구체적으로, 적어도 하나의 명령어에 관한 정보가 트리 구조를 포함한다면, 명령어의 입력 매 개변수 또는 전달 인자에 관한 정보는 명령어의 식별자 또는 이름을 포함하는 노드의 자식 노드에 포함될 수 있 다. 예를 들어, 도 3 의 대상 스크립트에 나타난 bitsadmin 명령어는 스위치 입력 매개변수로서 /transfer 를 포함하므로, 프로세서는 bitsadmin 명령어의 이름을 포함하는 제2 자식 노드의 자식 노드를 생성 하고, 제2 자식 노드의 자식 노드에 /transfer를 포함시킬 수 있다. 일 실시예에서, 프로세서는 적어도 하나의 명령어에 관한 정보를 기초로, 대상 벡터를 구성할 수 있다. 예를 들어, 적어도 하나의 명령어에 관한 정보가 도 3 에 나타난 것과 같이 그래프 또는 트리 구 조를 가지는 경우, 프로세서는 적절한 알고리즘을 이용하여 그래프 또는 트리 구조를 순회 또는 탐색하고, 그래프 또는 트리 구조를 대상 벡터로 나타낼 수 있다. 대상 벡터는 각 명령어에 관한 정보를 포함할 수 있지만, 대상 벡터의 간결성을 위하여, 대상 벡터 는 각 명령어에 대응되는 식별자(예를 들어, 도 2 의 명령어 사전에 수록된 식별자) 또는 이름만을 포함할 수 있다. 즉, 일 실시예에서, 프로세서는 적어도 하나의 명령어 각각의 식별자를 나열할 수 있다. 예를 들어, 도 3 의 대상 벡터는 도 2 의 명령어 사전에 수록된 Get-process 명령어, bitsadmin 명 령어 및 WebClient 명령어의 식별자인 3, 2 및 1을 각각 순서대로 포함하는 것으로 도시되어 있다. 일 실시예에서, 프로세서는 별도의 그래프 또는 트리 구조를 만들지 않고, 대상 벡터를 구성할 수도 있다. 구체적으로, 프로세서는 미리 정의된 명령어 사전을 이용하여, 상기 실행 로그로부터 적어도 하나의 명령어 및 적어도 하나의 명령어 각각의 식별자를 확인하고, 적어도 하나의 명령어 각각의 식별자를 나열하여 대상 벡터를 구성할 수도 있다. 이는 대상 벡터를 생성하는 과정이 보다 간단해지는 이점이 있다. 일 실시예에서, 프로세서는 대상 벡터를 기초로 대상 스크립트의 악성 여부를 확인할 수 있다. 구체적으로, 프로세서는 대상 벡터 및 기준 벡터 사이의 유사도를 확인하고, 확인된 유사도를 기초로 대상 스크립트의 악성 여부를 판정할 수 있다. 기준 벡터는 악성 여부가 미리 판단된 다른 스크립트에 대응되는 것일 수 있다. 보다 구체적으로, 기준 벡터는 악성이라고 판단된 다른 스크립트를 기초로 생성된 벡터일 수 있다. 이 경우, 프로세서는 유사도가 기 설 정된 수치 이상인 경우, 대상 스크립트를 악성 스크립트로 판정할 수 있다. 또는, 프로세서는 유사도가 기 설정된 수치 이하인 경우, 대상 스크립트를 악성 스크립트가 아니라고 판정할 수 있다. 기 설정된 수치는 통계 적 분석을 기초로 설정된 것일 수 있다. 다른 실시예에서, 기준 벡터는 악성이 아니라고 판단된 다른 스크립트를 기초로 생성된 벡터일 수 있다. 이 경 우, 프로세서는 유사도가 기 설정된 수치 이상인 경우, 대상 스크립트를 악성 스크립트가 아니라고 판정할 수 있다. 또는, 프로세서는 유사도가 기 설정된 수치 이하인 경우, 대상 스크립트를 악성 스크립트로 판정 할 수 있다. 일 실시예에서, 유사도는 자카드 유사도(Jaccard Similarity)일 수 있다. 예를 들어, 도 3 에 나타난 실시예에 서 대상 스크립트에 대응되는 대상 벡터는 {3,2,1}이었다. 악성이라고 판단된 스크립트에 대응되는 기준 벡터가 {2,1,4}라면, 프로세서는 대상 벡터 및 기준 벡터 사이의 교집합은 {1,2}이고, 대상 벡터 및 기준 벡터 사이의 합집합은 {1,2,3,4} 이라고 확인할 수 있다. 따라서 이 경우, 프로세서는 대 상 벡터 및 기준 벡터 사이의 교집합인 {1,2}의 원소의 개수 2를 대상 벡터 및 기준 벡터 사이의 합집합인 {1,2,3,4}의 원소의 개수 4로 나눈 0.5가 대상 벡터 및 기준 벡터 사이의 자카드 유사도라고 확인할 수 있 다. 만약 기 설정된 수치가 0.4라면, 대상 벡터 및 기준 벡터 사이의 자카드 유사도인 0.5는 0.4 이상이므 로, 프로세서는 대상 스크립트를 악성 스크립트로 판정할 수 있다. 일 실시예에서, 프로세서는 소정의 알고리즘을 이용하여 대상 벡터에 대한 적어도 하나의 최근접 이웃 (nearest neighbor) 기준 벡터를 확인하고, 적어도 하나의 최근접 이웃 기준 벡터 중 악성으로 분류되는 최근접 기준 벡터의 수가 최근접 기준 벡터 중 악성이 아닌 것으로 분류되는 최근접 기준 벡터의 수 이상인 경우, 대상 스크립트를 악성 스크립트로 판정할 수 있다. 소정의 알고리즘은 k-NN(k-최근접 이웃) 알고리즘일 수 있다. 예 를 들어, k가 5인 경우, 프로세서는 대상 벡터에 대한 5개의 최근접 이웃 기준 벡터를 확인할 수 있다. 5 개의 최근접 이웃 기준 벡터 중 악성으로 분류된 벡터가 4개이고, 악성이 아닌 것으로 분류된 벡터가 1개인 경 우, 프로세서는 대상 스크립트를 악성 스크립트로 판정할 수 있다. 이 실시예에서, 대상 벡터 및 기준 벡 터 사이의 거리는 다양한 방법으로 계산될 수 있다. 예를 들어, 대상 벡터 및 기준 벡터 사이의 거리는 L1- norm, L2-norm 또는 L3-norm, Maximum norm 등의 놈(norm)으로 표현될 수 있고, 자카드 거리(Jaccard Distance)로 표현될 수도 있다. 다른 실시예에서, 프로세서는 SVM(Support Vector Machine) 등의 기계학습 알고리즘 또는 분류기 (Classifier)를 이용하여 대상 벡터를 분류한 다음, 분류 결과를 기초로 대상 스크립트를 악성 스크립트로 판정 할 수 있다. 예를 들어, 제1 클래스로 분류되는 벡터들에 대응하는 스크립트들의 대부분 또는 모두가 악성 스크 립트가 아닌 경우, 프로세서는 대상 벡터가 제1 클래스로 분류된다면 대상 스크립트를 악성 스크립트가 아 니라고 판정할 수 있다. 다른 예를 들어, 제2 클래스로 분류되는 벡터들에 대응하는 스크립트들의 대부분 또는 모두가 악성 스크립트인 경우, 프로세서는 대상 벡터가 제2 클래스로 분류된다면 대상 스크립트를 악성 스 크립트로 판정할 수 있다. 일 실시예에서, 프로세서는 입력 벡터를 처리하여 입력 벡터에 대응하는 스크립트의 악성 여부를 출력하도 록 학습된 인공신경망을 이용하여, 대상 벡터로부터 대상 스크립트의 악성 여부를 확인할 수 있다. 예를 들어, 인공신경망은 DNN(Deep Neural Network), RNN(Recurrent Neural Network), CNN(Convolutional Neural Network), SLP(Single-Layer Perceptron), MLP(Multi-Layer Perceptron) 또는 이들의 조합을 포함할 수 있다. 일 실시예에서, 프로세서는 복수 개의 알고리즘 또는 분류기 각각의 분류 결과를 기초로 투표(vote)를 이 용하여 대상 스크립트의 악성 여부를 판단할 수 있다. 구체적으로, 프로세서는 복수의 분류기 각각의 분류 결과 중 대상 스크립트가 악성이라는 분류 결과가 대상 스크립트가 악성이 아니라는 분류 결과보다 더 많은 경 우, 대상 스크립트가 악성이라고 판정할 수 있다. 예를 들어, k-NN 알고리즘을 사용하는 제1 분류기는 대상 스 크립트가 악성이라는 제1 분류 결과를 출력하고, RNN 알고리즘을 사용하는 제2 분류기는 대상 스크립트가 악성 이라는 제2 분류 결과를 출력하고, CNN 알고리즘을 사용하는 제3 분류기는 대상 스크립트가 악성이 아니라는 제 3 분류 결과를 출력할 수 있다. 프로세서는 제1 내지 제3 분류 결과 중 대상 스크립트가 악성이라는 분류 결과의 수는 총 2개로, 대상 스크립트가 악성이 아니라는 분류 결과의 수인 1개보다 많음을 확인하고, 대상 스 크립트가 악성이라고 판정할 수 있다. 도 4 는 일 실시예에 따른 전자 장치의 동작 방법을 나타낸다. 도 4 의 동작 방법의 각 단계는 도 1 의 전 자 장치에 의해 수행될 수 있으므로, 도 1 과 중복되는 내용에 대해서는 설명을 생략한다. 단계 S410에서, 전자 장치는 시스템 이벤트로부터 대상 스크립트의 실행을 탐지할 수 있다. 대상 스크립트는 파워쉘(Powershell) 스크립트를 포함할 수 있다. 단계 S420에서, 전자 장치는 대상 스크립트의 실행 로그를 기초로 행위를 확인할 수 있다. 전자 장치는 미리 정의된 명령어 사전을 이용하여, 실행 로그로부터 적어도 하나의 명령어를 확인하고, 적 어도 하나의 명령어에 관한 정보를 확인할 수 있다. 단계 S430에서, 전자 장치는 확인된 행위를 기초로 대상 스크립트에 대응하는 대상 벡터를 생성할 수 있다. 전자 장치는 적어도 하나의 명령어에 관한 정보를 기초로 대상 스크립트에 대응하는 대상 벡터를 구성할 수 있다.전자 장치는 적어도 하나의 명령어 각각의 식별자를 나열할 수 있다. 단계 S440에서, 전자 장치는 대상 벡터를 기초로 대상 스크립트의 악성 여부를 확인할 수 있다. 전자 장치는 대상 벡터 및 기준 벡터 사이의 유사도를 확인하고, 확인된 유사도를 기초로 대상 스크립트의 악성 여부를 판정할 수 있다. 전자 장치는 유사도가 기 설정된 수치 이상인 경우, 대상 스크립트를 악성 스크립트로 판정할 수 있다. 유사도는 자카드 유사도(Jaccard Similarity)일 수 있다. 전자 장치는 소정의 알고리즘을 이용하여 대상 벡터에 대한 적어도 하나의 최근접 이웃(nearest neighbor) 기준 벡터를 확인하고, 적어도 하나의 최근접 이웃 기준 벡터 중 악성으로 분류되는 최근접 기준 벡터의 수가 최근접 기준 벡터 중 악성이 아닌 것으로 분류되는 최근접 기준 벡터의 수 이상인 경우, 대상 스크립트를 악성 스크립트로 판정할 수 있다. 전자 장치는 입력 벡터를 처리하여 입력 벡터에 대응하는 스크립트의 악성 여부를 출력하도록 학습된 인공 신경망을 이용하여, 대상 벡터로부터 대상 스크립트의 악성 여부를 확인할 수 있다. 이상 설명된 본 개시에 따른 실시예들은 다양한 컴퓨터 구성요소를 통하여 수행될 수 있는 프로그램 명령어의 형태로 구현되어 컴퓨터 판독 가능한 기록 매체 또는 비일시적 기록 매체에 기록될 수 있다. 상기 컴퓨터 판독 가능한 기록 매체 또는 비일시적 기록 매체는 프로그램 명령어, 데이터 파일, 데이터 구조 등을 단독으로 또는 조합하여 포함할 수 있다. 상기 컴퓨터 판독 가능한 기록 매체 또는 비일시적 기록 매체에 기록되는 프로그램 명령어는 본 발명을 위하여 특별히 설계되고 구성된 것들이거나 컴퓨터 소프트웨어 분야의 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판독 가능한 기록 매체 또는 비일시적 기록 매체의 예에는, 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체, CD-ROM, DVD와 같은 광기록 매체, 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체(magneto-optical media), 및 ROM, RAM, 플래시 메모리 등과 같은 프로그램 명령어 를 저장하고 수행하도록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령어의 예에는, 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드도 포함된다. 상기 하드웨어 장치 또는 전자 장치는 본 개시에 따른 처리를 수행하기 위해 하나 이상 의 소프트웨어 모듈로서 작동하도록 구성될 수 있으며, 그 역도 마찬가지이다. 본 실시 예는 기능적인 블록 구성들 및 다양한 처리 단계들로 나타내어질 수 있다. 이러한 기능 블록들은 특정 기능들을 실행하는 다양한 개수의 하드웨어, 소프트웨어, 또는 이들의 조합들로 구현될 수 있다. 예를 들어, 실 시 예는 하나 이상의 마이크로프로세서들의 제어 또는 다른 제어 장치들에 의해서 다양한 기능들을 실행할 수 있는, 메모리, 프로세싱, 로직(logic), 룩 업 테이블(look-up table) 등과 같은 직접 회로 구성들을 채용할 수 있다. 구성 요소들이 소프트웨어 프로그래밍 또는 소프트웨어 요소들로 실행될 수 있는 것과 유사하게, 본 실시 예는 데이터 구조, 프로세스들, 루틴들 또는 다른 프로그래밍 구성들의 조합으로 구현되는 다양한 알고리즘을 포함하여, C, C++, 자바(Java), 어셈블러(assembler) 등과 같은 프로그래밍 또는 스크립팅 언어로 구현될 수 있 다. 기능적인 측면들은 하나 이상의 프로세서들에서 실행되는 알고리즘으로 구현될 수 있다. 또한, 본 실시 예 는 전자적인 환경 설정, 신호 처리, 데이터 처리 또는 이들의 조합 등을 위하여 종래 기술을 채용할 수 있다."}
{"patent_id": "10-2022-0042416", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1 은 본 개시에 따른 전자 장치를 나타낸다. 도 2 는 본 개시에 따라 스크립트 실행 로그로부터 행위를 식별하는 방법의 일 실시예를 나타낸다. 도 3 은 본 개시에 따라 대상 스크립트로부터 대상 벡터를 생성하는 방법의 일 실시예를 나타낸다. 도 4 는 본 개시에 따른 방법의 일 실시예를 나타낸다."}
