{"patent_id": "10-2024-7032597", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0023337", "출원번호": "10-2024-7032597", "발명의 명칭": "AI 칩, 전자 장치 및 컨볼루션 연산 방법", "출원인": "베리실리콘 마이크로일렉트로닉스", "발명자": "쉬, 썬"}}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "N 개의 컨볼루션 코어 - 여기서 N은 2이상의 정수 -, 및상기 N 개의 컨볼루션 코어와 전기적으로 연결되는 저장 제어 시스템; 을 포함하고,상기 저장 제어 시스템은, 메모리로부터 입력 이미지 데이터를 판독하고, 상기 입력 이미지 데이터를 각 컨볼루션 코어에 배포하며, 메모리로부터 각 가중치 타일을 판독하고, 각 가중치 타일을 N 몫의 가중치 데이터로 분할하여 상기 N 개의 컨볼루션 코어에 배포하도록 구성되며, 여기서, 각 컨볼루션 코어는 한 몫의 가중치 데이터에대응되고, 각 가중치 타일은 모두 전체 가중치의 일부이며;각 컨볼루션 코어는, 수신된 가중치 데이터를 입력 이미지 데이터와 컨볼루션 연산을 진행하고, 여기서, 동일한가중치 타일에 대한 각 컨볼루션 코어의 컨볼루션 연산 결과를 합산하여 각 가중치 타일의 컨볼루션 연산 결과를 획득하고, 각 가중치 타일의 컨볼루션 연산 결과를 합산하여 최종 컨볼루션 연산 결과를 획득하도록 구성되는 것을 특징으로 하는 AI 칩."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 저장 제어 시스템은 A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분할하거나, B*A크기의 각 가중치 타일을 N 몫의 Kpc*A크기의 가중치 데이터로 분할하도록 구성되고, A, B, Kpc는 모두 양의 정수이고, B는 모든 컨볼루션 코어가 컨볼루션 라운드당 처리하는 최대 가중치 요소 그룹 수이며, A는 제 1 방향에서의 모든 컨볼루션 코어의 최대 높이이고, Kpc는 제 2 방향에서의 각 컨볼루션 코어가 컨볼루션 라운드당 처리하는 최대 가중치 요소 그룹 수인 것을 특징으로 하는 AI 칩."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 저장 제어 시스템은,메모리로부터 상기 입력 이미지 데이터를 판독하고, 상기 입력 이미지 데이터를 각 컨볼루션 코어에 배포하도록구성된 제 1 이미지 데이터 로딩 모듈;메모리로부터 각 가중치 타일을 판독하도록 구성된 제 2 이미지 데이터 로딩 모듈; 및상기 제 2 이미지 데이터 로딩 모듈 및 상기 N 개의 컨볼루션 코어와 각각 전기적으로 연결되는 가중치 데이터처리 모듈; 을 포함하고, 상기 가중치 데이터 처리 모듈은 A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분할하여상기 N 개의 컨볼루션 코어에 배포하거나, B*A 크기의 각 가중치 타일을 N 몫의 Kpc*A 크기의 가중치 데이터로분할하여 상기 N 개의 컨볼루션 코어에 배포하도록 구성된 것을 특징으로 하는 AI 칩."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 가중치 데이터 처리 모듈이 A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분할하도공개특허 10-2025-0023337-3-록 구성된 경우, 상기 가중치 데이터 처리 모듈은,상기 N 개의 컨볼루션 코어와 각각 대응되는 N 개의 레지스터를 포함하고, 상기 N 개의 레지스터는 모두 상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되며, 각 레지스터는 한 몫의 A*Kpc 크기의 가중치 데이터를 저장하도록 구성된 것을 특징으로 하는 AI 칩."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제3항에 있어서,상기 가중치 데이터 처리 모듈은,상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되는 N 개의 추출기를 포함하고, 각 상기 추출기는, 가중치 타일의 크기가 B*A이고, Kpc=1일 때, 하나의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성된 것을 특징으로 하는 AI 칩."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제3항에 있어서,상기 가중치 데이터 처리 모듈은,상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되는 N 개의 논리 시프터를 포함하고, 각 상기 논리 시프터는 가중치 타일의 크기가 B*A이고, Kpc>1일 때, A 개의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성된 것을 특징으로 하는 AI 칩."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제3항에 있어서,가중치 데이터 처리 모듈이 B*A 크기의 각 가중치 타일을 N 몫의 Kpc*A크기의 가중치 데이터로 분할하도록 구성된 경우,상기 가중치 데이터 처리 모듈은, N 개의 추출기, N 개의 논리 시프터 및 N 개의 셀렉터를 포함하고,상기 N 개의 추출기는 상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, 각 상기 추출기는 하나의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A크기의 가중치 데이터를 추출하도록 구성되며;상기 N 개의 논리 시프터는 상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, 각 상기 논리 시프터는A개의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A크기의 가중치 데이터를 추출하도록 구성되고; 상기 N 개의 셀렉터는 상기 N 개의 컨볼루션 코어와 각각 대응되고, 각 상기 셀렉터는 모두 하나의 상기추출기, 하나의 상기 논리 시프터 및 하나의 컨볼루션 코어와 전기적으로 연결되며, 각 상기 셀렉터는 Kpc=1일때, 추출기의 출력을 대응되는 컨볼루션 코어에 전송하고; Kpc>1일 때, 논리 시프터의 출력을 대응되는 컨볼루션 코어에 전송하도록 구성된 것을 특징으로 하는 AI 칩."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제3항에 있어서,상기 가중치 데이터 처리 모듈은,N 개의 레지스터, N 개의 추출기, N 개의 논리 시프터, N 개의 제 1 셀렉터 및 N 개의 제 2 셀렉터를 포함하고,공개특허 10-2025-0023337-4-상기 N 개의 레지스터는 상기 N 개의 컨볼루션 코어와 각각 대응되고, 상기 N 개의 레지스터는 모두 상기 제 2이미지 데이터 로딩 모듈과 전기적으로 연결되며, 각 레지스터는 한 몫의 A*Kpc 크기의 가중치 데이터를 저장하도록 구성되고,상기 N 개의 추출기는 상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, 각 상기 추출기는 하나의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성되며;상기 N 개의 논리 시프터는 상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, 각 상기 논리 시프터는A개의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성되며;각 상기 제 1 셀렉터는 모두 하나의 상기 추출기, 하나의 상기 논리 시프터와 전기적으로 연결되고, 각 상기 제1 셀렉터는 Kpc=1일 때, 대응되는 추출기의 출력 데이터를 선택하여 출력하고; Kpc>1일 때, 대응되는 논리 시프터의 출력 데이터를 선택하여 출력하도록 구성되며;각 상기 제 2 셀렉터는 모두 하나의 상기 제 1 셀렉터, 하나의 상기 레지스터, 하나의 상기 컨볼루션 코어와 전기적으로 연결되고, 각 제 2 셀렉터는 가중치 타일의 크기가 A*B일 때, 대응되는 레지스터의 출력 데이터를 선택하여 출력하고, 가중치 타일의 크기가 B*A일 때, 대응되는 제 1 셀렉터의 출력 데이터를 선택하여 출력하도록구성된 것을 특징으로 하는 AI 칩."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항 내지 제8항 중 어느 한 항에 있어서,각 컨볼루션 코어는 Kpc*A 크기의 가중치 데이터가 수신된 경우, Kpc*A 크기의 가중치 데이터를 A*Kpc 크기의가중치 데이터로 전환하고, 입력 이미지 데이터와 컨볼루션 연산을 진행하도록 구성된 것을 특징으로 하는 AI칩."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "메모리; 및제 1항 내지 제 8항 중 어느 한 항에 따른 AI 칩; 을 포함하고,상기 AI 칩과 상기 메모리는 전기적으로 연결되는 것을 특징으로 하는 전자 장치."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "메모리; 및제9항에 따른 AI 칩; 을 포함하고,상기 AI 칩과 상기 메모리는 전기적으로 연결되는 것을 특징으로 하는 전자 장치."}
{"patent_id": "10-2024-7032597", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "입력 이미지 데이터를 판독하고, 전체 가중치의 일부인 각 가중치 타일을 판독하여, 각 가중치 타일을 N 몫의가중치 데이터로 분할하는 단계; 각 몫의 가중치 데이터를 상기 입력 이미지 데이터와 컨볼루션 연산을 진행하는 단계; 동일한 가중치 타일에 속하는 각 몫의 가중치 데이터의 컨볼루션 연산 결과를 합산하여 각 가중치 타일의 컨볼루션 연산 결과를 획득하는 단계; 및 각 가중치 타일의 컨볼루션 연산 결과를 합산하여, 최종 컨볼루션 연산 결과를 획득하는 단계; 를 포함하는 것을 특징으로 하는 컨볼루션 연산 방법.공개특허 10-2025-0023337-5-"}
{"patent_id": "10-2024-7032597", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 출원은 AI 칩, 전자 장치 및 컨볼루션 연산 방법에 관한 것으로, 인공 지능분야에 속한다. 상기 AI 칩은, N 개의 컨볼루션 코어 및 저장 제어 시스템을 포함하고, 저장 제어 시스템과 N 개의 컨볼루션 코어는 전기적으로 연결된다. 저장 제어 시스템은, 메모리로부터 입력 이미지 데이터를 판독하고, 입력 이미지 데이터를 각 컨볼루 (뒷면에 계속)"}
{"patent_id": "10-2024-7032597", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원은 인공 지능 분야에 관한 것으로, 구체적으로, AI 칩, 전자 장치 및 컨볼루션 연산 방법에 관한 것이다."}
{"patent_id": "10-2024-7032597", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "관련 기술에서는 흔히 인공 지능（Artificial Intelligence, AI）칩, 예를 들어, 신경망 프로세서（Neural- network Processing Units, NPU）를 통해 일반 행렬 곱셈（GEneral Matrix Multiplication, GEMM）을 실현하고 있다. NPU칩의 구조는 도 1에 도시된 바와 같고, 저장 제어 시스템은（Memory Sub System, MSS）은 메모리（예 를 들어, DDR（Double Data Rate） 또는 SRAM（Static Random Access Memory））로부터 입력 이미지 데이터（ 예를 들어 InImage로 표시되고, 가중치 데이터와 컨볼루션 연산을 진행하기 위해 사용됨）, 가중치 데이터（예 를 들어 kernel로 표시되고, 입력 이미지 데이터와 컨볼루션 연산을 진행하기 위해 사용됨） 및 2ndImage데이터 （컨볼루션 연산으로 출력되는 이미지 데이터와의 덧셈（tensor_add） 또는 곱셈（tensor_mult）에 사용됨）을 판독한다. 여기서, InImage데이터와 kernel데이터는 컨볼루션 코어에서 컨볼루션을 진행하고, 컨볼루션 후의 데 이터는 후처리 모듈（postprocess）에 진입하여 후처리 되고（활성화, 풀링（pooling） 또는 2ndImage데이터와 의 덧셈/곱셈등을 포함）, 후처리가 완료된 데이터는 최종적으로 출력되는 이미지 데이터（예를 들어 OutImage 로 표시）로서 메모리에 저장된다. 하드웨어 면적을 제한하고 처리 효율성을 향상시키기 위해 InImage데이터, 2ndImage데이터 및 OutImage데이터는 모두 3차원 Tile（타일） 분할 형태로 처리된다. 그러나, 하드웨어에서 가중치 데이터（kernel）를 판독하는데 는 3차원 Tile의 개념이 없어, kernel데이터가 InImage Tile과 정확한 GEMM 연산을 위해 오프라인으로 정렬 순 서를 조절한 후 메모리에 저장하여야 한다. 실제 적용에서 가중치 행렬 P는 신경망의 특정층의 출력 데이터에서 유래될 수 있으며 외부 모듈에서 정확한 GEMM 곱셈 시퀀스로 재배열되어야만 InImage데이터와 컨볼루션을 진행 할 수 있다. 가중치 행렬 P를 외부로 전송하여 행렬 데이터 재배열할 경우, 소요되는 시간이 비교적 길고, 특히 비교적 큰 행렬을 처리할 때 효율이 매우 낮은 문제가 존재한다."}
{"patent_id": "10-2024-7032597", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "이에, 본 출원은, 현재의 AI 칩이 일반 행렬 곱셈을 수행할 때 가중치 행렬 P를 외부로 전송하여 행렬 데이터 재배열을 해야 하므로 소요되는 시간이 비교적 길고, 특히 비교적 큰 행렬을 처리할 때 효율이 매우 낮은 문제 를 개선시키기 위한 AI 칩, 전자 장치 및 컨볼루션 연산 방법을 제공하기 위한 것이다."}
{"patent_id": "10-2024-7032597", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 출원의 실시예는 다음과 같이 실현된다： 제 1 측면에 따르면, 본 출원의 실시예는 N 개（N은 2 이상의 정수）의 컨볼루션 코어（convolution core）, 저 장 제어 시스템을 포함하는 AI 칩을 제공하고, 저장 제어 시스템은 상기 N 개의 컨볼루션 코어와 전기적으로 연 결되며, 상기 저장 제어 시스템은, 메모리로부터 입력 이미지 데이터를 판독하고, 상기 입력 이미지 데이터를 각 컨볼루션 코어에 배포하며, 메모리로부터 각 가중치 타일(weight block)을 판독하고, 각 가중치 타일을 N 몫 의 가중치 데이터로 분할하여 상기 N 개의 컨볼루션 코어에 배포하도록 구성되며, 여기서, 각 컨볼루션 코어는 한 몫의 가중치 데이터에 대응되고, 각 가중치 타일은 전체 가중치의 일부이며; 각 컨볼루션 코어는 수신된 가 중치 데이터를 입력 이미지 데이터와 컨볼루션 연산을 진행하고, 여기서, 동일한 가중치 타일에 대한 각 컨볼루 션 코어의 컨볼루션 연산 결과를 합산하여 각 가중치 타일의 컨볼루션 연산 결과를 획득하고, 각 가중치 타일의 컨볼루션 연산 결과를 합산하여, 최종 컨볼루션 연산 결과를 획득하도록 구성될 수 있다. 제 1 측면의 실시예를 결부한 일 가능한 실시 양태에서, 상기 저장 제어 시스템은 A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분할하거나, B*A 크기의 각 가중치 타일을 N 몫의 Kpc*A 크기의 가중치 데이터로 분할하도록 구성될 수 있으며, A, B, Kpc는 모두 양의 정수이고, B는 모든 컨볼루션 코어가 컨볼루션 라운드당 처리하는 최대 가중치 요소 그룹 수이며, A는 제 1 방향에서의 모든 컨볼루션 코어의 최대 높이이고,Kpc는 제 2 방향에서의 각 컨볼루션 코어가 컨볼루션 라운드당 처리하는 최대 가중치 요소 그룹 수일 수 있다. 본 출원의 실시예에서, A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분할하거나, B*A 크 기의 각 가중치 타일을 N 몫의 Kpc*A 크기의 가중치 데이터로 분할함으로써, 일반 행렬 P*행렬 Q든 행렬 PT* 행 렬 Q든 처리 효율을 극대화할 수 있다. 여기서 행렬 PT는 행렬 P의 전치 행렬일 수 있다. 제 1 측면의 실시예를 결부한 일 가능한 실시 양태에서, 상기 저장 제어 시스템은, 제 1 이미지 데이터 로딩 모 듈, 제 2 이미지 데이터 로딩 모듈 및 가중치 데이터 처리 모듈을 포함할 수 있다. 제 1 이미지 데이터 로딩 모 듈은 메모리로부터 상기 입력 이미지 데이터를 판독하고, 상기 입력 이미지 데이터를 각 컨볼루션 코어에 배포 하도록 구성되고; 제 2 이미지 데이터 로딩 모듈은 메모리로부터 각 가중치 타일을 판독하도록 구성되며; 가중 치 데이터 처리 모듈은 상기 제 2 이미지 데이터 로딩 모듈과 상기 N 개의 컨볼루션 코어와 각각 전기적으로 연 결될 수 있고, 상기 가중치 데이터 처리 모듈은 A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이 터로 분할하여 상기 N 개의 컨볼루션 코어에 배포하거나, B*A 크기의 각 가중치 타일을 N 몫의 Kpc*A 크기의 가 중치 데이터로 분할하여 상기 N 개의 컨볼루션 코어에 배포하도록 구성될 수 있다. 제 1 측면의 실시예를 결부한 일 가능한 실시 양태에서, 상기 가중치 데이터 처리 모듈이 A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분할하도록 구성된 경우, 상기 가중치 데이터 처리 모듈은, 상기 N 개의 컨볼루션 코어와 각각 대응되는 N 개의 레지스터를 포함하고, 상기 N 개의 레지스터는 모두 상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되며, 각 레지스터는 한 몫의 A*Kpc 크기의 가중치 데이터를 저장하 도록 구성될 수 있다. 제 1 측면의 실시예를 결부한 일 가능한 실시 양태에서, 상기 가중치 데이터 처리 모듈은 상기 제 2 이미지 데 이터 로딩 모듈과 전기적으로 연결되는 N 개의 추출기를 포함할 수 있고, 각 상기 추출기는, 가중치 타일의 크 기가 B*A이고, Kpc=1일 때, 하나의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A 크기의 가중치 데이 터를 추출하도록 구성될 수 있다. 제 1 측면의 실시예를 결부한 일 가능한 실시 양태에서, 상기 가중치 데이터 처리 모듈은 상기 제 2 이미지 데 이터 로딩 모듈과 전기적으로 연결되는 N 개의 논리 시프터를 포함할 수 있고, 각 상기 시프터는 가중치 타일의 크기가 B*A이고, Kpc>1일 때, A 개의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A 크기의 가중치 데 이터를 추출하도록 구성될 수 있다. 제 1 측면의 실시예를 결부한 일 가능한 실시 양태에서, 가중치 데이터 처리 모듈이 B*A 크기의 각 가중치 타일 을 N 몫의 Kpc*A크기의 가중치 데이터로 분할하도록 구성된 경우; 상기 가중치 데이터 처리 모듈은, N 개의 추 출기, N 개의 논리 시프터, N 개의 셀렉터를 포함할 수 있다. N 개의 추출기는 상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, 각 상기 추출기는 하나의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성되며; N 개의 논리 시프터는 상기 제 2 이미지 데이터 로딩 모듈과 전 기적으로 연결되고, 각 상기 시프터는 A개의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A크기의 가 중치 데이터를 추출하도록 구성되며; N 개의 셀렉터는 상기 N 개의 컨볼루션 코어와 각각 대응되고, 각 상기 셀 렉터는 모두 하나의 상기 추출기, 하나의 상기 논리 시프터 및 하나의 컨볼루션 코어와 전기적으로 연결되며, 각 상기 셀렉터는 Kpc=1일 때, 추출기의 출력을 대응되는 컨볼루션 코어에 전송하고; Kpc>1일 때, 논리 시프터 의 출력을 대응되는 컨볼루션 코어에 전송하도록 구성될 수 있다. 제 1 측면의 실시예를 결부한 일 가능한 실시 양태에서, 상기 가중치 데이터 처리 모듈은 N 개의 레지스터, N 개의 추출기, N 개의 논리 시프터, N 개의 제 1 셀렉터 및 N 개의 제 2 셀렉터를 포함할 수 있고, N 개의 레지 스터는 상기 N 개의 컨볼루션 코어와 각각 대응될 수 있다. 상기 N 개의 레지스터는 모두 상기 제 2 이미지 데 이터 로딩 모듈과 전기적으로 연결되고, 각 레지스터는 한 몫의 A*Kpc 크기의 가중치 데이터를 저장하도록 구성 되며; N 개의 추출기는 상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, 각 상기 추출기는 하나의 클럭 주기내에 하나의 가중치 타일로부터 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성되며; N 개의 논리 시프터는 상기 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, 각 상기 시프터는 A개의 클럭 주기 내에 하나의 가중치 타일로부터 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성되며; 각 상기 제 1 셀 렉터는 모두 하나의 상기 추출기, 하나의 상기 논리 시프터와 전기적으로 연결되고, 각 상기 제 1 셀렉터는 Kpc=1일 때, 대응되는 추출기의 출력 데이터를 선택하여 출력하고; Kpc>1일 때, 대응되는 논리 시프터의 출력 데이터를 선택하여 출력하도록 구성되며; 각 상기 제 2 셀렉터는 모두 하나의 상기 제 1 셀렉터, 하나의 상기 레지스터, 하나의 상기 컨볼루션 코어와 전기적으로 연결되고, 각 제 2 셀렉터는 가중치 타일의 크기가 A*B일 때, 대응되는 레지스터의 출력 데이터를 선택하여 출력하고, 가중치 타일의 크기가 B*A일 때, 대응되는 제 1 셀렉터의 출력 데이터를 선택하여 출력하도록 구성될 수 있다. 제 1 측면의 실시예를 결부한 일 가능한 실시 양태에서, 각 컨볼루션 코어는 Kpc*A 크기의 가중치 데이터가 수 신된 경우, Kpc*A 크기의 가중치 데이터를 A*Kpc 크기의 가중치 데이터로 전환하고, 입력 이미지 데이터와 컨볼 루션 연산을 진행하도록 구성될 수도 있다. 본 출원의 실시예에서, Kpc*A 크기의 가중치 데이터가 수신된 경우, Kpc*A 크기의 가중치 데이터를 A*Kpc 크기 의 가중치 데이터로 전환하고, 입력 이미지 데이터와 컨볼루션 연산을 진행함으로써, 행렬 PT * 행렬 Q의 동작 을 실현하여, 해당 AI 칩이 행렬 P * 행렬 Q에 적용될 수 있을 뿐만 아니라, 행렬 PT * 행렬 Q에도 적용될 수 있다. 제 2 측면에 따르면, 본 출원의 실시예는 메모리 및 전술한 제 1측면의 실시예 및/또는 제 1 측면의 실시예를 결부한 어느 일 가능한 실시 양태에서 제공하는 AI 칩을 포함하고, 상기 AI 칩과 상기 메모리는 전기적으로 연 결되는 전자 장치를 제공할 수 있다. 제 3 측면에 따르면, 본 출원의 실시예는 또한, 입력 이미지 데이터를 판독하고, 전체 가중치의 일부인 각 가중 치 타일을 판독하여, 각 가중치 타일을 N 몫의 가중치 데이터로 분할하는 단계; 각 몫의 가중치 데이터를 상기 입력 이미지 데이터와 컨볼루션 연산을 진행하는 단계; 동일한 가중치 타일에 속하는 각 몫의 가중치 데이터의 컨볼루션 연산 결과를 합산하여 각 가중치 타일의 컨볼루션 연산 결과를 획득하는 단계; 및 각 가중치 타일의 컨볼루션 연산 결과를 합산하여, 최종 컨볼루션 연산 결과를 획득하는 단계;를 포함하는 컨볼루션 연산 방법을 제공할 수 있다."}
{"patent_id": "10-2024-7032597", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 출원의 실시예에서는 가중치 데이터에 타일（Tile）의 개념을 도입하여 전체 가중치를 여러 개의 가중치 타 일로 나눈 다음 각 가중치 타일을 판독하고, 각 가중치 타일을 N 몫의 가중치 데이터로 분할하여 N개의 컨볼루 션 코어로 배포하여, 외부 모듈이 가중치 데이터에 비효율적인 데이터 재배열을 수행할 필요가 없도록 하여 GEMM 동작 주기（cycle）를 감소함으로써 컨볼루션 연산 효율을 향상시킬 수 있다. 본 출원의 실시예에서, GEMM 동작시 기존의 가중치 데이터 요청 채널을 사용하여 kernel 데이터를 요청하지 않 고, 제 2 이미지 데이터 로딩 모듈을 사용하여 가중치 행렬 P를 요청하는데, 제 2 이미지 데이터 로딩 모듈은 3 차원 타일의 형식으로 데이터를 판독하기 때문에 가중치 데이터를 판독할 때마다 전체 가중치의 일부, 즉 하나 의 가중치 타일만 판독하게 되어 외부 모듈이 가중치 데이터에 대한 비효율적인 데이터 재배열을 수행할 필요가 없어 GEMM 동작의 주기（cycle）를 감소시킬 수 있다. 본 출원의 실시예에서, N 개의 레지스터를 이용하여 A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분할함으로써, 이의 발명의 목적을 실현함과 동시에 원가를 절약하고 AI 칩의 복잡 정도를 낮출 수 있 다. 본 출원의 실시예에서, Kpc=1일 때, N 개의 추출기를 이용하여 B*A 크기의 각 가중치 타일을N 몫의 Kpc*A크기의 가중치 데이터로 분할하고, Kpc>1일 때, N 개의 논리 시프터를 이용하여 B*A 크기의 각 가중치 타일을 N 몫의 Kpc*A 크기의 가중치 데이터로 분할하며, 동시에, N 개의 셀렉터를 이용하여 정확한 데이터를 선택하여 대응되 는 컨볼루션 코어에 출력함으로써, 이의 발명의 목적을 실현함과 동시에 원가를 절약하고 AI 칩의 복잡 정도를 낮출 수 있으며, 해당 AI 칩이 다양한 Kpc 분할방식을 호환할 수 있도록 할 수 있다. 본 출원의 실시예에서, 전술한 구조의 가중치 데이터 처리 모듈을 적용할 경우, 여러 상황에서 호환할 수 있다. 예를 들어, 가중치 타일의 크기가 A*B 일 경우, 이 때, 제 2 이미지 데이터 로딩 모듈은 가중치 타일을 path0 경로를 경유하여 N 개의 레지스터로 전송하고; 가중치 타일의 크기가 B*A이고, Kpc=1일 때, 가중치 타일을 N 개 의 추출기로 전송하고; 가중치 타일의 크기가 B*A이고, Kpc>1일 때, 가중치 타일을 N 개의 논리 시프터로 전송 한 다음, N 개의 제 1 셀렉터를 이용하여 정확한 데이터를 선택하여 대응되는 제 2 셀렉터에 출력한 후, 제 2 셀렉터가 정확한 데이터를 선택하여 대응되는 컨볼루션 코어 출력함으로써, 이의 발명의 목적을 실현함과 동시 에 원가를 절약하고 AI 칩의 복잡 정도를 낮출 수 있으며, 해당 AI 칩이 다양한 상황에서 호환할 수 있도록 하 여 방안의 적용성을 향상할 수 있다. 본 출원의 기타 특징 및 이점은 아래의 명세서에서 설명하도록 한다. 본 출원의 목적 및 기타 이점은 작성된 명 세서 및 도면에 구체적으로 명시된 구조에 의해 실현 및 획득될 수 있다."}
{"patent_id": "10-2024-7032597", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 본 출원 실시예의 도면과 결합하여 본 출원 실시예의 기술 방안에 대해 설명하도록 한다. 설명된 실시예 는 전체 실시예가 아니라 본 출원의 일부일 뿐이다. 아래의 실시예는 본 출원의 기술적 방안을 보다 명확하게 설명하는 예시로 사용되고, 본 출원의 보호 범위를 한정하지 않는다. 통상의 기술자는 모순되지 않는 전제하에 다음 실시예와 실시예의 특징을 서로 결합할 수 있음을 이해할 수 있을 것이다. 유사한 부호와 알파벳은 첨부된 도면에서 유사한 항목을 표시하므로 특정 도면에서 항목에 대해 정의할 경우 기 타 도면에서는 더 이상 정의 및 설명을 진행하지 않을 것임을 유의하여야 한다. 동시에, 본 출원의 설명에서 “ 제1”, “제2”와 같은 관계 용어는 한 개체 또는 동작을 다른 개체 또는 동작과 구별하는데만 사용되며, 이러 한 개체 또는 동작 사이에 어떠한 실제 관계 또는 순서가 반드시 요구되거나 암시되지는 않는다. 또한, 용어 “ 포함한”, “포함하는” 또는 이의 기타 변형은 배타적이지 않은 포함을 포함하도록 의도되어 일련의 요소를 포 함하는 프로세스, 방법, 물품 또는 장비가 그러한 요소뿐만 아니라 명확하게 나열되지 않은 다른 요소도 포함하 거나 이러한 프로세스, 방법, 항목 또는 장비에 고유한 요소를 포함한다. 추가의 한정이 없는 경우, “하나의… 가 포함된다”로 정의된 요소는 해당 요소를 포함하는 프로세스, 방법, 물품 또는 장비에 동일한 다른 요소가 있음을 배제하지 않는다. 또한, 본 출원에서 “및/또는”이라는 용어는 A 및/또는 B와 같이 세 가지 관계가 있을 수 있음을 나타내는 관 련 대상의 상관 관계를 설명하는 것일 뿐이며, 이는 A가 단독으로 존재하고 A와 B가 동시에 존재하며 B가 단독 으로 존재할 수 있음을 나타낼 수 있다. 본 출원의 실시예에 대한 설명에서 달리 명시되지 않는 한 기술 용어 “전기적으로 연결”은 직접 전기적 연결 또는 중간 매개체를 통한 간접 전기적 연결이 될 수 있다. 현재의 AI 칩이 일반 행렬 곱셈을 수행할 때 가중치 행렬 P를 외부로 전송하여 행렬 데이터 재배열을 해야 하므 로 소요되는 시간이 비교적 길고, 특히 더 큰 행렬을 처리할 때 효율이 매우 낮은 문제가 존재한다. 이에, 본 출원의 실시예는 가중치 행렬 P를 더 이상 행렬 데이터 재배열을 위해 외부로 전송할 필요가 없도록 하는 AI 칩, 전자 장치 및 컨볼루션 연산 방법을 제공하여 컨볼루션 연산 효율을 향상시키고자 한다. 아래 도 2에 결부 하여 본 출원의 실시예에서 제공하는 AI 칩에 대해 설명하도록 한다. 상기 AI 칩은, N 개의 컨볼루션 코어와 저장 제어 시스템을 포함하고, 저장 제어 시스템과 N 개의 컨볼루션 코어는 전기적으로 연결되고, N은 2이상의 정 수이다. 이해할 수 있는 것은, AI 칩은 메모리와도 전기적으로 연결되어 있다는 것이다. 그 중 메모리와 저장 제어 시스템은 서로 다른 장치이고, 각각 기능과 용도가 다르며, 메모리는 특히 데이터를 저장하는 저장 장치로 사용되고, 저장 제어 시스템은 메모리의 판독 및 쓰기 제어 시스템으로서 데이터의 판독과 쓰기를 제어하는데 사용된다. 저장 제어 시스템은 메모리（SRAM 메모리 및/또는 DDR 메모리일 수 있음）에서 입력 이미지 데이터를 판독하고, 입력 이미지 데이터를 각 컨볼루션 코어에 배포하며, 메모리에서 각 가중치 타일（가중치 Tile）을 판독하고 각 가중치 타일을 N 몫의 가중치 데이터로 분할하여 N 개의 컨볼루션 코어에 배포하도록 구성되며, 여기서 각 컨볼 루션 코어는 한 몫의 가중치 데이터에 대응되며 각 가중치 타일은 전체 가중치의 일부이다. 본 출원의 실시예에 서는 가중치 데이터에 타일（Tile）의 개념을 도입하여 전체 가중치를 여러 개의 가중치 타일로 나눈 다음 각 가중치 타일을 N몫의 가중치 데이터로 분할하고 N개의 컨볼루션 코어로 배포하여, 외부 모듈이 가중치 데이터에 비효율적인 데이터 재배열을 수행할 필요가 없도록 하여 GEMM 동작 주기（cycle）를 감소시킬 수 있다. 이해할 수 있는 것은, 저장 제어 시스템이 메모리에서 판독해내는 입력 이미지 데이터도 전체 입력 이미지 데이 터의 일부로, 다양한 크기의 메모리에 맞게 분할할 수 있다는 것이다. 이해를 돕기 위해, 아래 도 3에 도시된 컨볼루션 동작에 결부하여 설명하도록 한다. 도3에 도시된 바와 같이, InImage의 차원은 outX*outY*kZ이고, kernel데이터의 차원은 kX*kY*kZ*outZ이다. 여기서, kZ은 제 1 방향의 깊 이를 나타내고, outZ는 제 2 방향의 깊이이며, outX*outY는 입력 이미지 데이터의 2차원 크기이고, outX는 이미 지의 길이이며, outY는 이미지의 높이이고, kX*kY는 2차원 가중치 원소 그룹의 크기이며, kX는 2차원 가중치 원 소 그룹의 길이이며, kY는 2차원 가중치 원소 그룹의 높이이다. 첫 번째 3차원（kX*kY*kZ） kernel 배열이 동일한 차원 InImage의 각 점에 대응하여 곱하면 kX*kY*kZ개의 곱셈 결과를 획득하고, kX*kY*kZ개의 곱셈 결과를 모두 합산하면 OutImage상의 첫 번째 평면의 첫 번째 점을 얻을 수 있으며, 3차원 kernel 배열은 왼쪽에서 오른쪽으로, 다시 위에서 아래로 순서대로 Intile에서 슬라이딩하고, 동 일한 곱셈을 수행하면 OutImage상의 첫 번째 평면의 첫 번째 outTile을 얻을 수 있다. 제 4차원에는 outZ개의 3 차원 kernel 배열이 있으며 각각 동일한 동작을 수행하면 outZ 차원의 서로 다른 평면의 OutImage 결과를 얻을 수 있다. 행렬 P*행렬 Q=행렬 R의 GEMM동작은, 도 3에 도시된 컨볼루션과 일치하며, 이의 원리도는 도 4에 도시된 바와 같다. GEMM중 하나의 kZ*outZ의 행렬 P（행 kZ, 열 outZ, 이때, kX=kY=1）를 kernel 배열로 사용하고 다른 outX*outY*kZ의 행렬 Q（행 outX*outY, 열kZ）를 InImage로 사용하면, GEMM은 InImage와 kernel 배열의 컨볼루 션으로 볼 수 있다. 가중치 데이터（kZ*outZ）를 분할할 때 먼저 kZ 방향을 따라 데이터를 분할하고, 다음 outZ 방향을 따라 분할하 여 크기가 A*B 또는 B*A인 복수의 가중치 타일로 분할하며, 여기서 A와 B는 양의 정수이고, A는 제 1 방향（전 술한 kZ 방향）의 모든 컨볼루션 코어의 최대 높이, 예를 들어 A의 최대값은 9이며, B는 모든 컨볼루션 코어의 라운드당 처리된 최대 가중치 원소 그룹의 수이고, 각 가중치 원소 그룹의 크기는 kX*kY*A, 즉 하나의 가중치 원소 그룹에는 kX*kY*A개의 가중치 원소가 포함되어 있으며, kX=kY=1일 때 하나의 가중치 원소 그룹에는 A개의 가중치 원소가 포함되어 있다. 여기서, 저장 제어 시스템은, A*B크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분할하거나, B*A크기의 각 가중치 타일을 N 몫의 Kpc*A크기의 가중치 데이터로 분할하도록 구성되며, 여기서 Kpc는 양의 정 수이고, Kpc는 제2 방향（전술한 outZ 방향）의 각 컨볼루션 코어가 컨볼루션 라운드당 처리하는 가중치 요소 그룹의 최대 개수이다. GEMM을 진행할 때, 행렬 P의 경우, 먼저 kZ 방향에서 타일 데이터를 취한 다음 outZ 방향으로 취해야 한다. 상 이한 데이터 배치 순서에 따라 GEMM은 행렬 P * 행렬 Q와 행렬 PT * 행렬 Q의 두 가지 상황으로 나눌 수 있으며, 행렬 PT는 행렬 P의 전치 행렬(轉置行列, transpose matrix)이다. 여기서, 행렬 PT * 행렬 Q일 때 행렬 P는 행렬 PT로 변환되어야 행렬 Q에 곱할 수 있으며, 이 단계는 컨볼루션 코어 내부에서 완성될 수 있다. 행렬 P의 두가지 경우는 각각 2차원 형태와 3차원 형태를 갖는다. 행렬 P * 행렬 Q를 진행할 때, 메모리에서 행렬 P의 kZ 방향은 연속적인 것이다. 행렬 P의 두 가지 형태는 도 5 에 도시되어 있다. 도 5는 DDR 메모리에서 SRAM（캐시）으로, 이어서 컨볼루션 코어（core）로 데이터의 흐름을 도시하고 있다. 여기서, 데이터는 먼저 DDR 메모리에 저장된 다음 SRAM에 로드된 후 컨볼루션 코어에 로드될 수있다. 이때 도 2의 메모리는 DDR 메모리와 SRAM을 동시에 포함할 수 있으며, DDR 메모리는 SRAM을 통해 저장 제 어 시스템과 연결된다. 도 5의 좌측 상단은 DDR 메모리에 저장된 행렬 P의 2차원 형태인 in_x（행렬 P의 x 방향에서의 길이） = kZ; Tile_x（타일의 x 방향에서의 길이） = A（x 방향에서의 마지막 타일의 Tile_x는 다른 타일의 Tile_x보다 작을 수 있음）; in_y（행렬 P의 y 방향에서의 길이） = outZ; Tile_y（타일의 y 방향에서의 길이） = B = Kpc*N（마 지막 타일의 y 방향에서의 길이）를 나타내고, 화살표는 타일의 슬라이딩 방향, 즉 왼쪽에서 오른쪽으로, 그 다 음 위에서 아래로의 방향을 나타내고, 도 5에서 왼쪽에서 오른쪽으로의 슬라이딩 방향만을 나타낸다. 도 5의 좌 측 하단은 DDR 메모리에 저장된 행렬 P의 3차원 형태인 in_x = kZ; Tile_x = A（x 방향에서의 마지막 타일의 Tile_x는 다른 타일의 Tile_x보다 작음）; in_y = outZ/B; Tile_y = 1; in_z（행렬 P의 z 방향에서의 길이） = B（y 방향에서의 마지막 타일의 Tile_y는 다른 타일의 Tile_y보다 작을 수 있음）을 나타내고, 화살표는 타일의 슬라이딩 방향, 즉 왼쪽에서 오른쪽으로, 그 다음 위에서 아래로의 슬라이딩 방향을 나타낸다. 도 5의 중간 부 분은 처리 과정중 SRAM 메모리에 캐싱된 행렬 P의 형태로서, DDR 메모리의 2차원 형태와 동일하며, 가중치 타일 을 판독할 때 판독 순서는 왼쪽에서 오른쪽으로, 그 다음 위에서 아래로 진행된다. 도 5의 오른쪽 부분은 각 컨 볼루션 코어에 대해 수신된 가중치 데이터로서, 가중치 데이터는 A*Kpc의 크기를 가진다. 행렬 PT * 행렬 Q를 진행할 때, 메모리에서 행렬 P의 outZ방향은 연속적인 것이다. 행렬 P의 두 가지 형태는 도 6a 및 도 6b에 도시된 바와 같다. 도 6a는 DDR 메모리에서 SRAM으로 이어서 컨볼루션 코어로의 2차원 데이터의 흐름을 나타내고, 도 6b는 DDR 메모리에서 SRAM으로 이어서 컨볼루션 코어로의 3차원 데이터의 흐름을 나타내고 있다. 도 6a의 좌측 부분은 DDR 메모리에 저장된 행렬 P의 2차원 형태인 in_x = outZ; Tile_x = B（x 방향에서의 마지 막 타일의 Tile_x는 다른 타일의 Tile_x보다 작을 수 있음）; in_y = kZ; Tile_y = A（y 방향에서의 마지막 타 일의 Tile_y는 다른 타일의 Tile_y보다 작을 수 있음）을 나타내고, 화살표는 타일의 슬라이딩 방향, 즉 위에서 아래로, 그 다음 왼쪽에서 오른쪽으로의 슬라이딩 방향을 나타낸다. 도 6a의 중간 부분은 SRAM 메모리에 캐싱된 행렬 P의 형태로서, DDR 메모리중의 2차원 형태와 동일하며, 화살표는 타일의 슬라이딩 방향을 나타내며, 즉 위 에서 아래로, 그 다음 왼쪽에서 오른쪽으로 판독한다. 도 6a의 오른쪽 부분은 각 컨볼루션 코어가 수신한 가중 치 데이터로서, 가중치 데이터는 A*Kpc의 크기를 가지며, 컨볼루션 연산 진행시, A*Kpc로 전치(轉置)하여야 한 다. 도 6b의 좌측 부분은 DDR 메모리에 저장된 행렬 P의 3차원 형태인 in_x = outZ; Tile_x = B（x 방향에서의 마지 막 타일의 Tile_x는 다른 타일의 Tile_x보다 작을 수 있음）; in_y =kZ/A; Tile_y = 1; in_z = B를 나타낸다. 화살표는 타일의 슬라이딩 방향, 즉 위에서 아래로, 그 다음 왼쪽에서 오른쪽으로의 슬라이딩 방향을 나타낸다. 도 6b의 중간 부분은 처리 과정중 SRAM 메모리에 캐싱된 행렬 P의 형태로서, 행렬 P * 행렬 Q의 2차원 형태와 동일하며, 화살표는 타일의 슬라이딩 방향, 즉 왼쪽에서 오른쪽으로, 그 다음 위에서 아래로의 방향을 나타낸다. 도 6b의 오른쪽 부분은 각 컨볼루션 코어가 수신한 가중치 데이터로서, 가중치 데이터는 A*Kpc의 크 기를 가지며, 컨볼루션 연산 진행시, 별도의 전치가 필요 없다. 저장 제어 시스템이 가중치 타일을 판독할 때, 도 5 또는 도 6a, 도 6b에 도시된 원리에 따라 DDR메모리 또는 SRAM메모리로부터 순차적으로 가중치 타일을 판독한다. 저장 제어 시스템이 가중치 타일을 판독할 때, 우선적으 로 SRAM메모리로부터 판독하고, SRAM 메모리중에 대응되는 가중치 타일이 없을 경우, DDR 메모리로부터 판독하 고, DDR로부터 가중치 타일을 판독한 후에는 SRAM에 저장하여 캐싱을 진행한다. 선택 가능한 일 실시예에서, SRAM메모리는 AI 칩 내부의 메모리이고, DDR 메모리는 AI 칩 외부의 메모리이다. 일 실시 양태에서, 저장 제어 시스템은 제 1 이미지 데이터 로딩 모듈, 제 2 이미지 데이터 로딩 모듈, 가중치 데이터 처리 모듈을 포함한다. 제 1 이미지 데이터 로딩 모듈은 메모리 및 N 개의 컨볼루션 코어와 각각 전기적 으로 연결되고, 제 2 이미지 데이터 로딩 모듈은 메모리 및 가중치 데이터 처리 모듈과 각각 전기적으로 연결되 며, 가중치 데이터 처리 모듈은 N 개의 컨볼루션 코어와 각각 전기적으로 연결된다. 제 1 이미지 데이터 로딩 모듈은, 메모리로부터 입력 이미지 데이터를 판독하고, 입력 이미지 데이터를 각 컨볼 루션 코어에 배포하도록 구성된다. 제 2 이미지 데이터 로딩 모듈은, 메모리로부터 각 가중치 타일을 판독하고, 판독한 각 가중치 타일을 가중치 데이터 처리 모듈로 전송하도록 구성된다. 가중치 데이터 처리 모듈은, 제 2 이미지 데이터 로딩 모듈 및 N 개의 컨볼루션 코어와 각각 전기적으로 연결되고, 가중치 데이터 처리 모듈은 각 가중치 타일을 N 몫의 가중치 데이터로 분할하여 N 개의 컨볼루션 코어에 배포하도록 구성된다.본 출원의 실시예에서, GEMM 동작시 기존의 가중치 데이터 요청 채널을 사용하여 kernel 데이터를 요청하지 않 고, 제 2 이미지 데이터 로딩 모듈을 사용하여 가중치 행렬 P를 요청한다. 제 2 이미지 데이터 로딩 모듈은 3차 원 타일의 형식으로 데이터를 판독하기 때문에 가중치 데이터를 판독할 때마다 전체 가중치의 일부, 즉 하나의 가중치 타일만 판독하게 되어 외부 모듈이 가중치 데이터에 대한 비효율적인 데이터 재배열을 수행할 필요가 없 어 GEMM 동작의 주기（cycle）를 감소할 수 있다. 구체적으로, 가중치 데이터 처리 모듈은 A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분 할하여 N 개의 컨볼루션 코어에 배포하거나, B*A 크기의 각 가중치 타일을 N 몫의 Kpc*A 크기의 가중치 데이터 로 분할하여 N 개의 컨볼루션 코어에 배포하도록 구성된다. 일 실시 양태에서, 가중치 데이터 처리 모듈이 A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이 터로 분할하도록 구성된 경우, 가중치 데이터 처리 모듈은 N 개의 레지스터를 포함한다. N 개의 레지스터는 N 개의 컨볼루션 코어와 각각 대응되고, N 개의 레지스터는 모두 제 2 이미지 데이터 로딩 모듈과 전기적으로 연 결되며, 각 레지스터는 한 몫의 A*Kpc크기의 가중치 데이터를 저장하도록 구성된다. 여기서, 전술한 레지스터는 VLW（Variable Length Writer） 레지스터일 수 있고, 유효 길이가 고정되어 있지 않은 가중치 데이터를 수신할 수 있으며, 유효 데이터가 충분한 출력 폭을 가진 후에 유효 데이터를 대응하는 컨볼루션 코어로 전송할 수 있 다. 성능을 보장하기 위해, VLW은 최대 입력 폭은 min（sram_data_width A*max_kpc*bpp）이고, 출력 폭은 max_kpc*bpp이다. 파라미터 sram_data_width는 SRAM의 폭을 나타내고, bpp는 가중치 요소당 바이트（byte） 수 를 나타낸다. 여기서, DDR에서 가중치 타일을 판독한 후 SRAM에 저장하여 캐싱을 진행한다. 다른 실시 양태에서, 가중치 데이터 처리 모듈이 B*A 크기의 각 가중치 타일을 N 몫의 Kpc*A 크기의 가중치 데 이터로 분할하도록 구성된 경우, 가중치 데이터 처리 모듈은 도 7에 도시된 바와 같이 N 개의 추출기, N 개의 논리 시프터와 N 개의 셀렉터를 포함한다. 각 추출기, 각 논리 시프터는 모두 제 2 이미지 데이터 로딩 모듈과 연결되고, 하나의 셀렉터는 하나의 추출기 및 논리 시프터와 연결된다. N 개의 추출기는 모두 제 2 이미지 데이 터 로딩 모듈과 전기적으로 연결되며, Kpc=1일 경우, 제 2 이미지 데이터 로딩 모듈은 가중치 타일 데이터를 추 출기에 전송한다. 각 추출기는 하나의 클럭 주기 동안 하나의 가중치 타일에서 한 몫의 Kpc*A 크기의 가중치 데 이터를 추출하도록 구성된다. 본 실시 형태에서 제 2 이미지 로딩 모듈은 클럭 주기 내에서 A개의 B의 가중치 데이터를 추출기로 전송할 수 있다. Kpc=1일 경우, 인접한 가중치 요소는 다른 컨볼루션 코어에 속하며 사이클당 전송된 유효 데이터에는 A개의 B 어레이（행 어레이）가 포함된다. Kpc=1이고, 컨볼루션 코어의 개수 N=24이라고 가정한다면, B=Kpc*N=1*24이고; A=9이고, 가중치 요소당 하나의 바이트를 차지한다고 가정하면, 사이클당 전송되는 데이터 폭은 216 바이트이다. 그러면, 바이트0, 바이트24, 바이트48, 바이트72, 바이트96, 바이트120, 바이트144, 바이트168, 바 이트96는 코어（core）1에 속하고; 바이트1, 바이트25, 바이트49, 바이트73, 바이트97, 바이트121, 바이트145, 바이트169, 바이트197는 코어 2에 속하며, 이러한 방식으로 유추할 수 있다. 본 실시 형태에서 1클럭 주기로 A 개의 B 어레이를 전송할 수 있다. N 개의 논리 시프터는 모두 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, Kpc가 1보다 클 때, 제 2 이 미지 데이터 로딩 모듈은 가중치 타일 데이터를 논리 시프터에 전송한다. 각 시프터는 A 개의 클럭 주기 동안 하나의 가중치 타일에서 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성된다. 본 실시 양태에서, 제 2 이미지 로딩 모듈은 하나의 클럭 주기내에서, 단 하나의 B의 가중치 데이터를 논리 시프터에 전송하고, 하나의 B*A의 가중치 타일은 전송을 완료하는데 A개의 클럭 주기가 필요하다. Kpc가 1보다 클 때, 각 사이클당 최대 하나의 B어레이만을 전송할 수 있다. Kpc=2이고, 컨볼루션 코어의 개수 N=24이며, 가중치 요소당 하나의 바이트를 차지한다고 가정하면, Kpc*N=2*24=48이다. 그러면, 사이클당 전송되 는 데이터 폭은 48Byte이고, 바이트0, 바이트1은 코어1에 속하며; 바이트2, 바이트3은 코어2에 속하고, 이러한 방식으로 유추하면, 바이트46, 바이트47은 코어 24에 속한다. 그러면 논리 시프터 1은 바이트0과 바이트1의 출 력을 담당하고 논리 시프터 2는 바이트2와 바이트3의 출력을 담당하며, 이와 같이 유추하면 논리 시프터 24는 바이트46, 바이트47의 출력을 담당한다. N 개의 셀렉터는 N 개의 컨볼루션 코어와 각각 대응되고, 각 셀렉터는 모두 하나의 추출기, 하나의 논리 시프터 및 하나의 컨볼루션 코어와 전기적으로 연결되며, 각 셀렉터는 Kpc=1일 때, 추출기의 출력을 대응되는 컨볼루션 코어에 전송하고, Kpc>1일 때, 논리 시프터의 출력을 대응되는 컨볼루션 코어에 전송하도록 구성된다.이해할 수 있는 것은, 가중치 타일의 크기가 B*A이고, Kpc=1일 때, 가중치 데이터 처리 모듈은 N 개의 추출기（ N 개의 논리 시프터 및 N 개의 셀렉터를 포함하지 않음）만 포함할 수 있고, 이 때, N 개의 추출기는 N 개의 컨 볼루션 코어와 직접 연결된다. 마찬가지로, 가중치 타일의 크기가 B*A이고, Kpc>1일 때, 가중치 데이터 처리 모 듈은 N 개의 논리 시프터（N 개의 추출기 및 N 개의 셀렉터를 포함하지 않음）만 포함할 수 있고, 이 때, N 개 의 논리 시프터는 N 개의 컨볼루션 코어와 직접 연결된다. 도 7에 도시된 구조는 여러 Kpc의 가중치 데이터 처 리 모듈의 구조와 호환될 수 있다. 이해할 수 있는 것은, 가중치 타일의 크기가 B*A이고, Kpc>1일 때, 추출기를 사용하여 B*A 크기의 각 가중치 타 일을 N 몫의 Kpc*A 크기의 가중치 데이터로 분할 할 수 도 있다. 이 때, 사례별로 구성된 Kpc의 크기가 다르고 행렬 P의 가장자리 타일에서 컨볼루션 코어마다 Kpc가 균일하지 않게 분배될 수 있기 때문에 분할 및 재구성 설 계에 많은 변수가 도입되므로 이러한 변수에 의한 면적 오버헤드를 줄이기 위해 Kpc>1일 때 논리적 시프터를 사 용하여 구현하게 된다. 또 다른 실시 양태에서, 도 8에 도시된 바와 같이, 가중치 데이터 처리 모듈은, N 개의 레지스터, N 개의 추출 기, N 개의 논리 시프터, N 개의 제 1 셀렉터 및 N 개의 제 2 셀렉터를 포함한다. 이해할 수 있는 것은, 제 2 이미지 데이터 로딩 모듈이 가중치 타일을 전송할 때, 추출기, 논리 시프터, 레지스터 중 적어도 두 개에 동시 에 전송하지 않는다. 가중치 타일의 크기가 A*B 일 경우, 이 때, 제 2 이미지 데이터 로딩 모듈은 가중치 타일 을 path0 경로를 경유하여 N 개의 레지스터로 전송하고; 가중치 타일의 크기가 B*A이고, Kpc=1일 때, 가중치 타 일을 N 개의 추출기로 전송하고; 가중치 타일의 크기가 B*A이고, Kpc>1일 때, 가중치 타일을 N 개의 논리 시프 터로 전송한다. N 개의 레지스터는 N 개의 컨볼루션 코어와 각각 대응되고, N 개의 레지스터는 모두 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되며, 각 레지스터는 한 몫의 A*Kpc 크기의 가중치 데이터를 저장하도록 구성된다. N 개의 추출기는 모두 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, 각 추출기는 하나의 클럭 주기 동 안 하나의 가중치 타일에서 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성된다. N 개의 논리 시프터는 모두 제 2 이미지 데이터 로딩 모듈과 전기적으로 연결되고, 각 시프터는 A개의 클럭 주 기 동안 하나의 가중치 타일에서 한 몫의 Kpc*A 크기의 가중치 데이터를 추출하도록 구성된다. 각 제 1 셀렉터는 모두 하나의 추출기, 하나의 논리 시프터와 전기적으로 연결되고, 각각의 제 1 셀렉터는 Kpc=1일 때, 대응되는 추출기의 출력 데이터를 선택하여 출력하고; Kpc>1일 때, 대응되는 논리 시프터의 출력 데이터를 선택하여 출력하도록 구성된다. 각 제 2 셀렉터는 모두 하나의 제 1 셀렉터, 하나의 레지스터, 하나의 컨볼루션 코어와 전기적으로 연결되고, 각각의 제 2 셀렉터는 가중치 타일의 크기가 A*B（또는 가중치 데이터의 크기가 A*Kpc일 때）일 때, 대응되는 레지스터의 출력 데이터를 선택하여 출력하고, 가중치 타일의 크기가 B*A（또는 가중치 데이터의 크기가 Kpc *A 일 때）일 때, 대응되는 제 1 셀렉터의 출력 데이터를 선택하여 출력하도록 구성된다. 각 컨볼루션 코어는 수신된 가중치 데이터와 입력 이미지 데이터에 대해 컨볼루션 연산을 진행하도록 구성되며, 구체적으로, 각 컨볼루션 코어는 A*Kpc 크기의 가중치 데이터를 수신한 경우, 수신된 가중치 데이터와 입력 이 미지 데이터에 대해 컨볼루션 연산을 진행하도록 구성된다. Kpc*A 크기의 가중치 데이터가 수신된 경우, Kpc*A 크기의 가중치 데이터를 A*Kpc 크기의 가중치 데이터로 전환하고, 입력 이미지 데이터와 컨볼루션 연산을 진행 한다. 여기서, 동일한 가중치 타일에 대한 각 컨볼루션 코어의 컨볼루션 연산 결과를 대응 위치에 따라 합산하여 각 가중치 타일의 컨볼루션 연산 결과를 획득하고, 각 가중치 타일의 컨볼루션 연산을 대응 위치에 따라 합산하여 최종 컨볼루션 연산 결과를 획득한다. 일부 실시 가능한 양태에서, 전술한 AI 칩은 후처리 모듈을 더 포함할 수 있고, 후처리 모듈은 각 컨볼루션 코 어와 메모리에 각각 연결된다. 후처리 모듈은, 동일한 가중치 타일에 대한 각 컨볼루션 코어의 컨볼루션 연산 결과를 대응 위치에 따라 합산하여 각 가중치 타일의 컨볼루션 연산 결과를 획득하고, 각 가중치 타일의 컨볼루 션 연산을 대응 위치에 따라 합산하여 최종 컨볼루션 연산 결과를 획득하기 위해 사용된다. 여기서, 전술한 AI 칩은 신호 처리 능력을 갖는 집적 회로 칩일 수 있다. 전술한 AI 칩은 CPU（Central Processing Unit）, NP（Network Processor）, 마이크로프로세서 등을 포함한 범용 프로세서일 수 있으며, DSP （Digital Signal Processor）, ASIC（Application Specific Integrated Circuit）, FPGA（FieldProgrammable Gate Array） 또는 기타 프로그래밍 가능한 논리 장치, 분리 게이트 또는 트랜지스터 논리 장치, 분리 하드웨어 구성일 수 있다. 본 출원의 실시예에서 개시된 방법, 단계 및 논리 블록 다이어그램을 실현하거 나 실행할 수 있다. 또는 AI 칩은 임의의 일반 프로세서 등일 수도 있다. 또한, 전술한 AI 칩은 GPU（Graphic Processing Unit）, TPU（Tensor Processing Unit）, 신경망 처리 장치 등 과 같은 복잡한 계산 작업을 수행하도록 설계된 특수 계산 가속 칩（또는 가속기）일 수 있으며 물론 AI 계산 작업을 위한 다른 프로세서일 수도 있다. 본 출원의 실시예는 또한 메모리와 메모리에 전기적으로 연결되는 전술한 AI 칩을 포함하는 전자 장치를 제공한 다. 메모리는 입력 이미지 데이터 및 가중치 데이터등과 같은 GEMM 동작에 필요한 데이터를 저장하는데 사용된 다. 전술한 전자 장치는 태블릿, 노트북, 차량용 장치 및 서버를 포함할 수 있지만, 이에 한정되지 않는다. 본 출원의 실시예는 전술한 AI 칩에 적용할 수 있는 컨볼루션 연산 방법을 제공한다. 아래, 도 9와 결부하여 본 출원의 실시예에서 제공하는 컨볼루션 연산 방법에 대해 설명하도록 한다. S1：입력 이미지 데이터를 판독하고, 각 가중치 타일을 판독하여, 각 가중치 타일을 N 몫의 가중치 데이터로 분 할한다. 전술한 제 1 이미지 데이터 로딩 모듈을 이용하여 메모리로부터 입력 이미지 데이터를 판독하고, 전술한 제 2 이미지 데이터 로딩 모듈을 이용하여 메모리로부터 각 가중치 타일을 판독할 수 있고, 전술한 가중치 데이터 처 리 모듈을 이용하여 각 가중치 타일을 N 몫의 가중치 데이터로 분할할 수 있다. 예를 들어, 제 2 이미지 데이터 로딩 모듈은 판독한 각 가중치 타일을 가중치 데이터 처리 모듈로 전송하고, 가중치 데이터 처리 모듈에 의해 각 가중치 타일을 N 몫의 가중치 데이터로 분할할 수 있다. 여기서, 각 가중치 타일은 모두 전체 가중치의 일부 이다. 제 1 이미지 데이터 로딩 모듈은 입력 이미지 데이터를 판독한 경우, 입력 이미지 데이터를 N 개의 컨볼루션 코 어로 배포할 수 있고, N은 2이상의 정수이다. 가중치 데이터 처리 모듈은 각 가중치 타일을 N 몫의 가중치 데이터로 분할한 후, N 몫의 가중치 데이터를 N 개 의 컨볼루션 코어에 배포할 수 있으며, 각 컨볼루션 코어는 한 몫의 가중치 데이터에 대응된다. 가중치 데이터 처리 모듈은 각 가중치 타일을 N 몫의 가중치 데이터로 분할할 때, A*B 크기의 각 가중치 타일을 N 몫의 A*Kpc 크기의 가중치 데이터로 분할하거나, B*A크기의 각 가중치 타일을 N 몫의 Kpc*A크기의 가중치 데 이터로 분할 수 있다. A, B, Kpc는 모두 양의 정수이고, B는 모든 컨볼루션 코어가 컨볼루션 라운드당 처리하는 최대 가중치 요소 그룹 수이며, A는 제 1 방향에서의 모든 컨볼루션 코어의 최대 높이이고, Kpc는 제 2 방향에 서의 각 컨볼루션 코어가 컨볼루션 라운드당 처리하는 최대 가중치 요소 그룹 수이다. S2：각 몫의 가중치 데이터를 모두 상기 입력 이미지 데이터와 컨볼루션 연산을 진행한다. 수신된 각 몫의 가중치 데이터를 AI 칩 중의 컨볼루션 코어에 의해 입력 이미지 데이터와 컨볼루션 연산을 진행 하는 것일 수 있다. S3：동일한 가중치 타일에 속하는 각 몫의 가중치 데이터의 컨볼루션 연산 결과를 합산하여 각 가중치 타일의 컨볼루션 연산 결과를 획득한다. 후처리 모듈에 의해, 동일한 가중치 타일에 속하는 각 몫의 가중치 데이터의 컨볼루션 연산 결과를 합산하여 각 가중치 타일의 컨볼루션 연산 결과를 획득할 수 있다. S4：각 가중치 타일의 컨볼루션 연산 결과를 합산하여, 최종 컨볼루션 연산 결과를 획득한다. 후처리 모듈에 의해, 각 가중치 타일의 컨볼루션 연산 결과를 합산하여, 최종 컨볼루션 연산 결과를 획득할 수 있다. 본 출원의 실시예에서 제공하는 컨볼루션 연산 방법의 구현 원리와 기술적 효과는 앞서 언급한 AI 칩의 실시예 와 동일하여, 간략한 설명을 위해, 방법 실시예에서 언급되지 않은 부분은 앞서 언급한 AI 칩의 관련 내용을 참 조할 수 있다. 본 출원의 실시예는 또한 컴퓨터와 같은 전술한 전자 장치에 의해 동작할 때 전술한 컨볼루션 연산 방법을 수행 하는 컴퓨터 프로그램이 저장된 비휘발성 컴퓨터 판독 가능한 저장 매체（이하 저장 매체）를 제공한다. 다만, 본 명세서에서의 각 실시예는 점진적인 방식으로 설명되며, 각 실시예의 주요 설명은 다른 실시예와 다른 점이며, 각 실시예 간의 동일하고 유사한 부분은 상호 참조할 수 있다. 본 출원에서 제공하는 몇 가지 실시예에서 공개된 장치 및 방법이 다른 방법으로도 구현될 수 있음을 이해하여 야 한다. 전술한 장치 실시예는 예시적인 것일 뿐이며, 예를 들어 도면의 흐름도 및 블록도는 본 출원의 여러 실시예에 따른 장치, 방법 및 컴퓨터 프로그램 제품에 의해 실현 가능한 아키텍쳐, 기능 및 동작을 도시한다. 이러한 점에서, 흐름도 또는 블록도의 각 프레임은 지정된 논리적 기능을 구현하기 위한 하나 이상의 실행 가능 한 명령을 포함하는 모듈, 세그먼트 또는 코드의 일부를 나타낼 수 있다. 또한 일부 대체 가능한 실시 양태에서, 프레임에 표시된 기능이 첨부 도면에 표시된 것과 다른 순서로 발생할 수 있다는 점에 유의해야 한다. 예를 들어, 두 개의 연속적인 프레임은 실제로 실질적으로 병렬로 수행될 수 있으며 관련된 기능에 따라 때로는 반대 순서로 수행될 수도 있다. 블록도 및/또는 흐름도의 각 프레임과 블록도 및/또는 흐름도의 프레임 조합은 지정된 기능 또는 동작을 수행하는 특수 하드웨어 기반 시스템으로 또는 특수 하드웨어와 컴퓨터 명령의 조합으로 실현할 수 있다. 또한, 본 출원의 각 실시예에서 각 기능 모듈은 통합되어 하나의 독립적인 부분을 형성하거나, 각 모듈이 독립 적으로 존재하거나, 둘 이상의 모듈이 통합되어 독립적인 부분을 형성할 수도 있다. 상기 기능이 소프트웨어 기능 모듈의 형태로 구현되어 독립적인 제품으로 판매되거나 사용되는 경우 컴퓨터 판 독 가능한 저장 매체에 저장할 수 있다. 이러한 이해를 바탕으로, 본 출원의 기술 방안은 본질적으로 또는 선행 기술에 기여하는 부분 또는 기술 방안의 부분은 소프트웨어 제품의 형태로 구현될 수 있고, 해당 컴퓨터 소프트 웨어 제품은 하나의 컴퓨터 판독 가능한 저장 매체에 저장되며, 하나의 컴퓨터 장치（개인 컴퓨터, 노트북, 서 버 또는 전자 장치 등）가 본 출원의 각 실시예에서 설명한 방법의 전체 또는 일부를 수행할 수 있도록 하는 여 러 지령을 포함할 수 있다. 전술한 컴퓨터 판독 가능한 저장 매체에는 USB, 외장 하드 디스크, ROM（Read-Only Memory）, RAM（Random Access Memory）, 디스크 또는 CD등 프로그램 코드를 저장할 수 있는 다양한 매체를 포 함할 수 있다. 위에서 언급한 내용은 본 출원의 구체적인 실시 형태일 뿐이지만, 본 출원의 보호 범위는 이에 한정되지 않으며, 본 출원에 개시한 기술 범위 내에서 본 기술 분야에 대해 숙지하고 있는 통상의 기술자는 변경 또는 교 체를 쉽게 생각할 수 있으며, 이는 모두 본 출원의 보호 범위 내에 포함된다. 따라서 본 출원의 보호 범위는 청 구범위의 보호 범위를 기준으로 하여야 한다."}
{"patent_id": "10-2024-7032597", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 출원의 실시예 또는 선행기술의 기술적 방안을 보다 명확하게 설명하기 위해, 아래에서는 실시예에 사용될 수 있는 도면을 간략하게 소개하며, 아래에 설명된 도면은 본 출원의 일부 실시예에 불과하며, 통상의 기술자는 창조적인 노동을 하지 않는다는 전제 하에 이러한 도면을 기반으로 다른 도면을 얻을 수 있다. 첨부된 도면을 통해 위에서 언급한 본 출원의 목적, 특징 및 장점은 더욱 명확해질 것이다. 도 1은 관련 기술에서의 AI 칩과 메모리가 서로 연결되는 구조의 예시도이다. 도 2는 본 출원의 실시예에서 제공하는 AI 칩과 메모리가 서로 연결되는 구조를 도시한 예시도이다. 도 3은 본 출원의 실시예에서 제공하는 컨볼루션 동작의 원리를 도시한 예시도이다. 도 4는 본 출원의 실시예에서 제공하는 GEMM 동작을 도 3에서 도시한 컨볼루션 동작과 일치되게 하는 원리를 보 여주는 예시도이다. 도 5는 본 출원의 실시예에서 제공하는 행렬 P의 데이터가 DDR메모리로부터 SRAM까지, 이어서 컨볼루션 코어로 향하는 흐름을 도시한 예시도이다. 도 6a는 본 출원의 실시예에서 제공하는 다른 행렬 P의 2차원 데이터가 DDR메모리로부터 SRAM까지, 이어서 컨볼 루션 코어로 향하는 흐름을 도시한 예시도이다. 도 6b는 본 출원의 실시예에서 제공하는 또 다른 행렬 P의 3차원 데이터가 DDR메모리로부터 SRAM까지, 이어서 컨볼루션 코어로 향하는 흐름을 도시한 예시도이다. 도 7은 본 출원의 실시예에서 제공하는 가중치 데이터 처리 모듈의 구조를 도시한 예시도이다. 도 8은 본 출원의 실시예에서 제공하는 또 다른 가중치 데이터 처리 모듈의 구조를 도시한 예시도이다. 도 9는 본 출원의 실시예에서 제공하는 컨볼루션 연산 방법의 프로세서를 도시한 예시도이다."}
