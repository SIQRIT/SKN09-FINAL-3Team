{"patent_id": "10-2019-7006211", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2019-0038601", "출원번호": "10-2019-7006211", "발명의 명칭": "첸 프레임워크, 첸 코딩과 첸 코드", "출원인": "찬 캄푸", "발명자": "찬 캄푸"}}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합에서 데이터를 위해 질서를 창조하거나 또는 데이터 질서거나 또는 데이터 구조 또는 데이터 조직을 창조하고 코드 유닛으로 조성되며 상기 코드유닛은 숫자 데이터 집합은 숫자 데이터 집합의 이진 비트를 포함하는 비트용기의 기본 유닛으로 사용되고; 인코딩과 디코딩 목적에 의해 처리를 선택한 디자인과 모드에 근거하여 코드유닛은 주요하게 코드유닛이 정의되어 수용하거나 나타내는 데이터 값의 최대 가능 수량(즉 코드유닛의 값의 크기)을 통해 분류하되 여기서 코드유닛의 매 하나의 가능한 고유값은 동일한 비트 크기 또는 상이한 비트 크기를 가질 수 있으며; 코드유닛은 잠시 뒤에 코드유닛이 차지한모든 가능한 고유 데이터 값의 비트수(즉 코드유닛이 차지한 매 하나의 가능한 고유 데이터 값의 비트 크기의총합)에 의해 분류하고; 코드유닛은 진일바로 헤드 디자인(즉 이는 0헤드 디자인이거나 1헤드 디자인)에 의해분류하며; 이로써 각 실시방안에 근거하여 첸 프레임워크에서의 특정된 값의 크기의 코드유닛은 상이한 정의와버전을 가지는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 처리유닛으로 조성되고 상기 처리유닛은 인코딩과 디코딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 일정한 수량의 코드유닛을 서브 유닛으로 하여 조성되는 것을 특징으로하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 슈퍼 처리유닛으로 조성되고 상기 슈퍼 처리유닛은 인코딩과 디코딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 일정한 수량의 코드유닛을 서브 유닛으로 하여 조성되는 것을특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 암호화되지 않은 코드유닛으로 조성되고 상기 암호화되지 않은 코드유닛은 일정한수량의 이진 비트로 조성되며 이러한 이진 비트는 하나의 처리유닛의 크기에 도달할 수 없으므로 인코딩과 디코딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 암호화되지 않은 코드로 유지되거나 원래의모습을 유지하는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 암호화되지 않은 코드유닛으로 조성되고 상기 암호화되지 않은 코드유닛은 일정한수량의 이진 비트로 조성되며 이러한 이진 비트는 하나의 처리유닛의 크기에 도달할 수 없으므로 인코딩과 디코딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 암호화되지 않은 코드로 유지되거나 원래의모습을 유지하는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 인코딩과 디코딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 코드유닛, 처리유닛, 슈퍼 처리유닛과 암호화되지 않은 코드유닛 및 이들이 사용 중에서의 조합이 파생한 특성 또는 특징 또는 관계로 조성되는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보공개특허 10-2019-0038601-3-에서 질서를 창조하는 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "그 어떤 숫자 데이터 집합의 특성 또는 특징 또는 관계의 설명적이 언어를 설명하기 위하여 코드유닛,처리유닛, 슈퍼 처리유닛과 암호화되지 않은 코드유닛의 특성 또는 특징 또는 관계의 용어에 사용되는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "첸 프레임워트에서의 인코딩과 디코딩의 목적으로 데이터를 처리하는 기술에 사용되는 것을 특징으로 하는 첸코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "첸 코딩 기술을 사용하여 그 어떤 숫자 데이터 집합에서 획득된 첸 코드를 창조하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "범위를 가지는 절대 어드레스 분기 기술을 가지는 기술을 사용하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "수학공식을 사용하여 첸 프레임워크에서 창조한 데이터 질서를 나타내는 처리유닛의 코드유닛 사이의 관계를 나타내는 기술에 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "배치기술, 즉 수학공식으로 나타내는 값 또는 암호화된 코드 및 코드유닛, 처리유닛, 슈퍼 처리유닛과 암호화되지 않은 코드유닛의 그러한 값 또는 암호화된 코드를 상이한 자리순서로 배치하는 것을 특징으로 하는 첸 코딩,인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "분류기술, 즉 0헤드 디자인 또는 1 헤드 디자인 또는 양자를 서로 매칭되는 비트모드를 대표로 하는 디자인으로처리 중인 숫자 데이터의 특성 또는 특징에 분포하되 상기 특성 또는 특징은 인코딩과 디코딩의 목적으로 데이터 값을 분류하거나 그루핑하여 처리하는데 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "분류기술, 즉 처리 중인 숫자 데이터의 데이터 값에 관한 정렬과 자리의 특성 또는 특징을 사용하여 인코딩과디코딩의 목적으로 데이터 값을 분류하거나 그루핑하여 처리하는데 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "분류기술, 즉 코드 재분포의 운용은 아래의 기술에서의 임의의 하나를 사용하여 고유 데이터 값 및 고유 어드레스 코드를 분류모드의 한 클래스로부터 다른 한 클라스로 재분포하는 것을 포함하고 상기 기술은 코드 교환, 코드 재분포와 코드 재기입을 포함하여 인코딩과 디코딩의 목적으로 숫자 데이터 집합을 처리하는 것을 특징으로하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "코드 향상, 코드 강등, 코드 생략 및 코드 복구에서의 임의의 하나를 포함하여 인코딩과 디코딩의 목적으로 처리하도록 하는 코드 조절기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "공개특허 10-2019-0038601-4-종료 조건 또는 종료값을 사용하여 처리유닛 또는 슈퍼 처리유닛의 크기를 정의하여 인코딩과 디코딩의 목적으로 처리하는 기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "코드유닛 정의를 숫자 데이터 값 또는 암호화된 코드값으로 사용하는 판독기의 기술인 것을 특징으로 하는 첸코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "코드유닛 정의를 숫자 데이터 값 또는 암호화된 코드값으로 사용하는 라이터의 기술인 것을 특징으로 하는 첸코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "슈퍼 처리유닛을 사용하여 숫자 데이터 집합을 데이터의 서브 섹션으로 세분화화는 기술로서, 그 중 적어도 하나의 서브 섹션은 무작위가 아니어 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제20항에 있어서, 분류조건을 사용, 예하면 특정된 클라스에 사용되는 슈퍼 처리유닛에 나타난 값 항목의 수량을 사용하여 진일보로 숫자 데이터 집합의 슈퍼 처리유닛을 두개 또는 더 많은 클라스로 분류하고, 이러한 클라스에 적용되는 매 하나의 데이터 분포의 매핑 테이블을 디자인하여 인코딩과 디코딩을 진행하며, 이러한 슈퍼처리유닛의 매 하나의 데이터 값에 적용되는 데이터 분포에서의 이들 각각의 매핑 테이블을 사용하여 이러한 슈퍼 처리유닛에서의 매 하나의 데이터 값에 대해 인코딩과 디코딩을 진행하고, 지정자를 사용하여 이러한 카테고리의 슈퍼 처리유닛 사이에서 구별하여 디코딩에 사용하며 이러한 지정자는 이러한 슈퍼 처리유닛에서의 매 하나의 마스터헤드 또는 기타 지점, 예하면 단독으로 된 첸 코드파일에 저장되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제20항에 있어서, 분류조건을 사용, 예하면 특정된 클라스에 사용되는 슈퍼 처리유닛에 나타난 값 항목의 수량을 사용하여 진일보로 숫자 데이터 집합의 슈퍼 처리유닛을 두개의 클라스로 분류하고, 이러한 클라스에 적용되는 매 하나의 데이터 분포의 매핑 테이블을 디자인하여 인코딩과 디코딩을 진행하며, 이러한 슈퍼 처리유닛에서의 매 하나의 데이터값의 데이터 분포에 적용되는 이들 각각의 매핑 테이블을 사용하여 이러한 슈퍼 처리유닛에서의 매 하나의 데이터값을 인코딩과 디코딩하고, 슈퍼 처리유닛의 클라스의 데이터 분포에 적용되는 표준을 설치하여 인코딩과 디코딩의 대응하는 매핑 테이블에 사용함으로써 암호화된 코드를 평가하여 슈퍼 처리유닛의 클라스 사이의 인공지능 구별을 진행하여 지정자의 사용을 생략하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제20항에 있어서, 분류조건을 사용, 예하면 특정된 클라스에 사용되는 슈퍼 처리유닛에 나타난 값 항목의 수량을 사용하여 진일보로 숫자 데이터 집합의 슈퍼 처리유닛을 두개의 클라스로 분류하고, 이러한 클라스에 적용되는 매 하나의 데이터 분포의 매핑 테이블을 디자인하여 인코딩과 디코딩을 진행하며, 이로써 이러한 매핑 테이블에서의 적어도 하나가 이에 의해 선택되어 언이브너로 사용되고 이러한 언이브너는 코드 재분포를 사용하여조절할 수 있으며 상기 코드 재분포는 적어도 한 클라스의 슈퍼 처리유닛의 데이터 값의 데이터 분포를 이용하여 코드 재분포를 통해 코드 조절을 진행한 후의 언이브너 매핑 테이블로 하여금 이에 의해 선택되어 적어도 한클라스의 슈퍼 처리유닛의 압축기의 매핑 테이블로 사용되도록 하고, 첫번째 순환주기에서 언이브너를 사용하여모든 슈퍼 처리유닛을 인코딩하며, 그 다음 압축기를 사용하여 적어도 한 클라스의 슈퍼 처리유닛을 인코딩하되그 중 처리 중인 상응한 슈퍼 처리유닛의 데이터 압축은 제2 순환주기에서 가능한 것인 바, 즉 제1 순환주기에서 언이브너를 사용하여 암호화하고 제2 순환주기에서 압축기를 사용하여 암호화함으로써 그러한 압축 불가능한데이터를 함유한 슈퍼 처리유닛이 언이브너만 사용하여 암호화하도록 하고, 디코딩할 경우 이러한 슈퍼 처리유닛에서의 매 하나의 데이터 값에 적용되는 데이터 분포의 상응한 매핑 테이블을 이용하여 이러한 슈퍼 처리유닛에서의 매 하나의 데이터 값을 디코딩함으로써 제1 디코딩 순환주기에서 언이브너의 인코딩과 압축기의 인코딩공개특허 10-2019-0038601-5-으로 형성된 암호화된 코드가 디코딩되어 압축기 인코딩층의 인코딩이 디코딩되도록 하고 제2 디코딩 순환주기에서 모든 슈퍼 처리유닛은 언이브너가 암호화한 코드로 조성된 암호화된 코드가 언이브너 디코더에 의해 디코딩되며, 슈퍼 처리유닛에서의 모든 카테고리의 데이터 분포에 사용되는 적용 규칙 및 인코딩과 디코딩에 사용되는 상응한 매핑 테이블의 적용 규칙을 설치하여 이를 암호화된 코드를 평가하는데 사용함으로써 인공지능을 사용하여 슈퍼 처리유닛의 각 카테고리 사이의 식별작업을 진행하도록 하여 지정자의 사용을 절약할 수 있는 것을특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "매핑 테이블을 구성하고 상기 매핑 테이블의 고유 코드 어드레스를 사용하여 일대일 매핑방식으로 숫자 데이터입력 중에서의 고유 데이터 값을 매핑함으로써 언이브너 인코더와 언이브너 디코더의 기술을 창조하므로 고유데이터 값이 사용한 비트수는 상응하게 매핑 매칭되어 상응하게 매핑된 고유 테이블 코드 어드레스가 사용한 비트수와 동일하고 상기 매핑 테이블을 사용하여 인코딩과 디코딩을 진행하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "인코딩과 디코딩의 목적으로 언이브너 인코더와 언이브너 디코더를 사용하여 처리하는 기술을 특징으로 하는 첸코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "인코딩과 디코딩의 목적으로 언이브너 인코더와 언이브너 디코더를 사용하여 이브너 인코더와 디코더 또는 압축기와 디컴프레서와 함께 처리하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "데이터 분포의 상황을 변화하는 상황에서 처리 중에 사용한 종료 조건에 근거하여 처리유닛 또는 슈퍼 처리유닛의 크기를 동적으로 조절하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "처리 중의 데이터값의 데이터 분포 모드에 근거하여 코드유닛 정의를 동적으로 조절하는 기술을 특징으로 하는첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "분류 코드와 내용코드, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집합에서 창조되어 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코드."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "분류 코드, 내용코드와 암호화되지 않은 코드유닛, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집합에서 창조되어 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코드."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "마스터헤드, 분류 코드와 내용코드, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집합에서 창조되어 인코딩과 디코딩의 목적으로 처리함으로써 상기 마스터헤드에 첸 코딩 기술의 사용으로부터 발생한 지정자를 포함하여 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코드."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "마스터헤드, 분류 코드, 내용코드와 암호화되지 않은 코드유닛, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자데이터 집합에서 창조되어 인코딩과 디코딩의 목적으로 처리함으로써 상기 마스터헤드에 첸 코딩 기술의 사용으로부터 발생한 지정자를 포함하여 인코딩과 디코딩의 목적으로 처리하며 이러한 지정자는 검사 합계 지정자, 첸코드파일 싸인, 매핑 테이블 지정자, 순환 주기수량 지정자, 코드유닛 정의 지정자, 처리유닛 정의 지정자, 슈퍼 처리유닛 정의 지정자, 최후 식별코드 지정자, 시나리오 디자인 지정자, 언이브너/이브너 지정자, 재순환 지정자, 빈도 지정자, 특수 코드 지정자, 일부 크기 지정자, 숫자 데이터 블랙홀 타입 지정자 및 압축 가능/압축공개특허 10-2019-0038601-6-불가능 데이터 지정자에서의 임의의 하나를 포함하는 것을 특징으로 하는 첸 코드."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "첸 코딩 기술이 임베디드되어 처리를 진행하는 것을 특징으로 하는 첸 프레임워크로 디자인된 인코더와 디코더,코더."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "첸 코딩과 마스터헤드 지정자기술이 임베디드되어 처리를 진행하되 이러한 지정자는 검사 합계 지정자, 첸 코드파일 싸인, 매핑 테이블 지정자, 순환 주기수량 지정자, 코드유닛 정의 지정자, 처리유닛 정의 지정자, 슈퍼 처리유닛 정의 지정자, 최후 식별코드 지정자, 시나리오 디자인 지정자, 언이브너/이브너 지정자, 재순환 지정자,빈도 지정자, 특수 코드 지정자, 일부 크기 지정자, 숫자 데이터 블랙홀 타입 지정자 및 압축 가능/압축 불가능데이터 지정자에서의 임의의 하나를 포함하는 것을 특징으로 하는 첸 프레임워크로 디자인된 인코더와 디코더,코더."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "첸 코드의 숫자정보파일을 포함하는 것을 특징으로 하는 첸 코드파일."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "첸 코딩 기술이 사용한 부가적인 정보의 숫자정보파일을 포함하고 마스터헤드와 여기에 포함되는 지정자를 포함하며 이러한 지정자는 검사 합계 지정자, 첸 코드파일 싸인, 매핑 테이블 지정자, 순환 주기수량 지정자, 코드유닛 정의 지정자, 처리유닛 정의 지정자, 슈퍼 처리유닛 정의 지정자, 최후 식별코드 지정자, 시나리오 디자인지정자, 언이브너/이브너 지정자, 재순환 지정자, 빈도 지정자, 특수 코드 지정자, 일부 크기 지정자, 숫자 데이터 블랙홀 타입 지정자 및 압축 가능/압축 불가능 데이터 지정자에서의 임의의 하나를 포함하는 것을 특징으로 하는 첸 코드파일."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "한가지 수학방법의 사용기술로서, 이 기술을 사용하여 데이터 값이 하나의 질서에 놓이게 되고 이 질서는 수학공식에 의해 설명될 수 있으며 이 수학공식은 상응한 첸 형상과 대응되는 수학공식으로서 숫자정보와 관련 되는수학계산논리와 기술을 병합하고 분리하는 것을 포함하고 이러한 숫자정보는 무작위 여부와 관계 없는 숫자정보를 처리하는 처리유닛에서의 코드유닛의 값을 포함하여 인코딩과 디코딩의 목적으로 사용하는 것을 특징으로 하는 첸 프레임워크에서 사용하는 첸 수학."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "한가지 설명방법으로서, 이 방법은 기본 컴포넌트, 코드유닛과 파생 컴포넌트(예하면 첸 코드의 RP피스와 기타파생 컴포넌트) 사이의 특징과 관계를 설명하는 바, 예하면 무작위 여부와 관계 없는 숫자정보를 처리하는 처리유닛에서의 기본 컴포넌트 값의 조합치 또는 총합 또는 차이를 설명하여 인코딩과 디코딩의 목적으로 사용하는것을 특징으로 하는 첸 프레임워크에서 사용하는 공식, 즉 첸 공식."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_39", "content": "첸 점, 첸 라인, 첸 삼각형, 첸 직사각형, 첸 제형과 첸 정방형 및 첸 바를 포함하고 첸 공식으로 설명한 처리유닛의 기본 컴포넌트의 특징과 관계를 대표하는 첸 형상."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "상수값을 사용하거나 수치의 변수를 포함하여 보완 상수 또는 보완 변수로 하여 수학 처리에 사용함으로써 하나의 수치 또는 하나의 범위 내 또는 다수의 범위 내의 다수의 수치의 미러 수치를 첸 공식에 사용하는 것을 특징으로 하는 보완 수학."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "보완 수학과 상규적인 수학 또는 이들 중의 임의의 하나를 첸 프레임워크에서 디자인한 디코더에 단독으로 사용공개특허 10-2019-0038601-7-하여 처리하는 첸 수학."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 프레임워크."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_43", "content": "암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 코딩."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_44", "content": "암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 코드."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_45", "content": "암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 코드파일."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_46", "content": "암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 수학."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_47", "content": "암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 보완 수학."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_48", "content": "암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 형상."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_49", "content": "첸 프레임워크에서 정의한 데이터 질서의 디자인과 모드를 사용하는것을 특징으로 하는 숫자 데이터 집합에 관한 통계정보를 수집하는데 사용되어 인코딩과 디코딩의 목적으로 사용되는 무작위 여부와 관계 없는 숫자 데이터 집합을 분석하는 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_50", "content": "첸 프레임워크 언어를 사용하는 것을 특징으로 하는 무작위 여부와 관계 없는 숫자 데이터 집합을 설명하는 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_51", "content": "사후 분류 코드 또는 내부 분류 코드 또는 수정된 내용코드를 분류 코드로 사용하는 기술을 특징으로 하는 첸코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_52", "content": "첸 프레임워크에서 정의한 디코더의 코드값을 사용하여 절대 어드레스 분기 코딩기술을 통해 기타 코드값을 흡수하거나 표시, 즉 블랙홀 코드와 관련되는 절대 어드레스 분기 코드를 사용하여 흡수된 코드값을 대표하는 숫자 데이터 블랙홀 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_53", "content": "코드대체기술에 이어 첸 프레임워크에서 정의한 디코더에서의 코드값을 사용하여 이어지는 단계로 다른 한 코드값을 대표하거나 표시하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_54", "content": "절대 어드레스 분기코드의 반대되는 배치기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_55", "content": "공개특허 10-2019-0038601-8-첸 프레임워크에서 정의한 디코더가 처리하고 있는 데이터 집합에 결여한 코드값을 사용하여 블랙홀 코드를 충당하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_56", "content": "첸 프레임워크에서 정의한 디코더가 처리하고 있는 데이터 집합에 결여한 코드값으로 비교적 긴 비트 길이의 다른 한 코드값을 대체하되, 다른 한 코드값이 처리 중인 데이터 집합에 존재하는 것인 기술을 특징으로 하는 첸코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_57", "content": "첸 프레임워크에서 정의한 디코더를 사용하여 인코딩과 디코딩을 진행하되, 사용한 기술은 숫자 데이터 블랙홀,절대 어드레스 코딩, 지정자 비트 지출 축소와 잇따른 코드 대체 또는 잇따르지 않는 코드 대체 기술이고 처리중인 데이터 집합에서 결여한 코드값을 동일한 비트 길이 도는 더 긴 비트 길이를 대체하는 다른 한 코드값으로교체하되, 여기서 다른 한 코드값은 적합한 상황에서 처리 중인 데이터 집합에 존재하는 것인 기술을 특징으로하는 결여된 고유 코드값이 있거나 없는 상황에서 무작위 데이터나 비무작위 데이터와 관계 없는 숫자 데이터를압축하고 압축 해제하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_58", "content": "처리 중인 숫자 데이터 집합으로부터 생성된 빈도 분포 특징에 기반하여 지정자 비트 지출을 축소하는 기술을특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법."}
{"patent_id": "10-2019-7006211", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_59", "content": "코드유닛, 처리유닛과슈퍼 처리유닛의 고유 코드값으로서 사용한 디자인에 근거하여 하나의 비트 크기 또는 비트 길이 도는 상이한 비트 크기 또는 비트 길이를 가지는 것을 특징으로 하는 첸 프레임워크를 사용하여 디자인한 디코더."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 손상이 없고 정확한 인코딩과 디코딩 방식을 통해 무작위 또는 비무작위 데이터 여부와 관계없는 프레 임워크 및 관련 방법, 모드와 디자인에 관한 것으로서 암호화/복호화 또는 압축/압축 해제 또는 양자를 포함하는 목적에 사용된다. 처리하기 전에 처리하고자 하는 숫자정보에 대해 그 어떤 가정도 하지 않는다. 본 발명은 범용 코덱을 발명하고 비둘기집에서 블랙홀을 만났다. CPC특허분류 H03M 7/3084 (2013.01) H03M 7/6011 (2013.01) 우선권주장 PCT/IB2016/054732 2016년08월05일 국제사무국(IB)(IB) PCT/IB2017/050985 2017년02월22일 국제사무국(IB)(IB) PCT/IB2017/053993 2017년07월01일 국제사무국(IB)(IB)명 세 서 청구범위 청구항 1 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합에서 데이터를 위해 질서를 창조하거나 또는 데이터 질서거 나 또는 데이터 구조 또는 데이터 조직을 창조하고 코드 유닛으로 조성되며 상기 코드유닛은 숫자 데이터 집합 은 숫자 데이터 집합의 이진 비트를 포함하는 비트용기의 기본 유닛으로 사용되고; 인코딩과 디코딩 목적에 의 해 처리를 선택한 디자인과 모드에 근거하여 코드유닛은 주요하게 코드유닛이 정의되어 수용하거나 나타내는 데 이터 값의 최대 가능 수량(즉 코드유닛의 값의 크기)을 통해 분류하되 여기서 코드유닛의 매 하나의 가능한 고 유값은 동일한 비트 크기 또는 상이한 비트 크기를 가질 수 있으며; 코드유닛은 잠시 뒤에 코드유닛이 차지한 모든 가능한 고유 데이터 값의 비트수(즉 코드유닛이 차지한 매 하나의 가능한 고유 데이터 값의 비트 크기의 총합)에 의해 분류하고; 코드유닛은 진일바로 헤드 디자인(즉 이는 0헤드 디자인이거나 1헤드 디자인)에 의해 분류하며; 이로써 각 실시방안에 근거하여 첸 프레임워크에서의 특정된 값의 크기의 코드유닛은 상이한 정의와 버전을 가지는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조 하는 방법. 청구항 2 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이 터 구조 또는 데이터 조직은 처리유닛으로 조성되고 상기 처리유닛은 인코딩과 디코딩을 목적으로 하여 처리하 도록 선택된 디자인과 모드에 근거하여 일정한 수량의 코드유닛을 서브 유닛으로 하여 조성되는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법. 청구항 3 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이 터 구조 또는 데이터 조직은 슈퍼 처리유닛으로 조성되고 상기 슈퍼 처리유닛은 인코딩과 디코딩을 목적으로 하 여 처리하도록 선택된 디자인과 모드에 근거하여 일정한 수량의 코드유닛을 서브 유닛으로 하여 조성되는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법. 청구항 4 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이 터 구조 또는 데이터 조직은 암호화되지 않은 코드유닛으로 조성되고 상기 암호화되지 않은 코드유닛은 일정한 수량의 이진 비트로 조성되며 이러한 이진 비트는 하나의 처리유닛의 크기에 도달할 수 없으므로 인코딩과 디코 딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 암호화되지 않은 코드로 유지되거나 원래의 모습을 유지하는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창 조하는 방법. 청구항 5 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이 터 구조 또는 데이터 조직은 암호화되지 않은 코드유닛으로 조성되고 상기 암호화되지 않은 코드유닛은 일정한 수량의 이진 비트로 조성되며 이러한 이진 비트는 하나의 처리유닛의 크기에 도달할 수 없으므로 인코딩과 디코 딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 암호화되지 않은 코드로 유지되거나 원래의 모습을 유지하는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창 조하는 방법. 청구항 6 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이 터 구조 또는 데이터 조직은 인코딩과 디코딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 코 드유닛, 처리유닛, 슈퍼 처리유닛과 암호화되지 않은 코드유닛 및 이들이 사용 중에서의 조합이 파생한 특성 또 는 특징 또는 관계로 조성되는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법. 청구항 7 그 어떤 숫자 데이터 집합의 특성 또는 특징 또는 관계의 설명적이 언어를 설명하기 위하여 코드유닛, 처리유닛, 슈퍼 처리유닛과 암호화되지 않은 코드유닛의 특성 또는 특징 또는 관계의 용어에 사용되는 것을 특 징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법. 청구항 8 첸 프레임워트에서의 인코딩과 디코딩의 목적으로 데이터를 처리하는 기술에 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 9 첸 코딩 기술을 사용하여 그 어떤 숫자 데이터 집합에서 획득된 첸 코드를 창조하는 것을 특징으로 하는 첸 코 딩, 인코딩과 디코딩의 방법. 청구항 10 범위를 가지는 절대 어드레스 분기 기술을 가지는 기술을 사용하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코 딩의 방법. 청구항 11 수학공식을 사용하여 첸 프레임워크에서 창조한 데이터 질서를 나타내는 처리유닛의 코드유닛 사이의 관계를 나 타내는 기술에 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 12 배치기술, 즉 수학공식으로 나타내는 값 또는 암호화된 코드 및 코드유닛, 처리유닛, 슈퍼 처리유닛과 암호화되 지 않은 코드유닛의 그러한 값 또는 암호화된 코드를 상이한 자리순서로 배치하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 13 분류기술, 즉 0헤드 디자인 또는 1 헤드 디자인 또는 양자를 서로 매칭되는 비트모드를 대표로 하는 디자인으로 처리 중인 숫자 데이터의 특성 또는 특징에 분포하되 상기 특성 또는 특징은 인코딩과 디코딩의 목적으로 데이 터 값을 분류하거나 그루핑하여 처리하는데 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 14 분류기술, 즉 처리 중인 숫자 데이터의 데이터 값에 관한 정렬과 자리의 특성 또는 특징을 사용하여 인코딩과 디코딩의 목적으로 데이터 값을 분류하거나 그루핑하여 처리하는데 사용되는 것을 특징으로 하는 첸 코딩, 인코 딩과 디코딩의 방법. 청구항 15 분류기술, 즉 코드 재분포의 운용은 아래의 기술에서의 임의의 하나를 사용하여 고유 데이터 값 및 고유 어드레 스 코드를 분류모드의 한 클래스로부터 다른 한 클라스로 재분포하는 것을 포함하고 상기 기술은 코드 교환, 코 드 재분포와 코드 재기입을 포함하여 인코딩과 디코딩의 목적으로 숫자 데이터 집합을 처리하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 16 코드 향상, 코드 강등, 코드 생략 및 코드 복구에서의 임의의 하나를 포함하여 인코딩과 디코딩의 목적으로 처 리하도록 하는 코드 조절기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 17 종료 조건 또는 종료값을 사용하여 처리유닛 또는 슈퍼 처리유닛의 크기를 정의하여 인코딩과 디코딩의 목적으 로 처리하는 기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 18 코드유닛 정의를 숫자 데이터 값 또는 암호화된 코드값으로 사용하는 판독기의 기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 19 코드유닛 정의를 숫자 데이터 값 또는 암호화된 코드값으로 사용하는 라이터의 기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 20 슈퍼 처리유닛을 사용하여 숫자 데이터 집합을 데이터의 서브 섹션으로 세분화화는 기술로서, 그 중 적어도 하 나의 서브 섹션은 무작위가 아니어 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코딩, 인코딩 과 디코딩의 방법. 청구항 21 제20항에 있어서, 분류조건을 사용, 예하면 특정된 클라스에 사용되는 슈퍼 처리유닛에 나타난 값 항목의 수량 을 사용하여 진일보로 숫자 데이터 집합의 슈퍼 처리유닛을 두개 또는 더 많은 클라스로 분류하고, 이러한 클라 스에 적용되는 매 하나의 데이터 분포의 매핑 테이블을 디자인하여 인코딩과 디코딩을 진행하며, 이러한 슈퍼 처리유닛의 매 하나의 데이터 값에 적용되는 데이터 분포에서의 이들 각각의 매핑 테이블을 사용하여 이러한 슈 퍼 처리유닛에서의 매 하나의 데이터 값에 대해 인코딩과 디코딩을 진행하고, 지정자를 사용하여 이러한 카테고 리의 슈퍼 처리유닛 사이에서 구별하여 디코딩에 사용하며 이러한 지정자는 이러한 슈퍼 처리유닛에서의 매 하 나의 마스터헤드 또는 기타 지점, 예하면 단독으로 된 첸 코드파일에 저장되는 것을 특징으로 하는 첸 코딩, 인 코딩과 디코딩의 방법. 청구항 22 제20항에 있어서, 분류조건을 사용, 예하면 특정된 클라스에 사용되는 슈퍼 처리유닛에 나타난 값 항목의 수량 을 사용하여 진일보로 숫자 데이터 집합의 슈퍼 처리유닛을 두개의 클라스로 분류하고, 이러한 클라스에 적용되 는 매 하나의 데이터 분포의 매핑 테이블을 디자인하여 인코딩과 디코딩을 진행하며, 이러한 슈퍼 처리유닛에서 의 매 하나의 데이터값의 데이터 분포에 적용되는 이들 각각의 매핑 테이블을 사용하여 이러한 슈퍼 처리유닛에 서의 매 하나의 데이터값을 인코딩과 디코딩하고, 슈퍼 처리유닛의 클라스의 데이터 분포에 적용되는 표준을 설 치하여 인코딩과 디코딩의 대응하는 매핑 테이블에 사용함으로써 암호화된 코드를 평가하여 슈퍼 처리유닛의 클 라스 사이의 인공지능 구별을 진행하여 지정자의 사용을 생략하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코 딩의 방법. 청구항 23 제20항에 있어서, 분류조건을 사용, 예하면 특정된 클라스에 사용되는 슈퍼 처리유닛에 나타난 값 항목의 수량 을 사용하여 진일보로 숫자 데이터 집합의 슈퍼 처리유닛을 두개의 클라스로 분류하고, 이러한 클라스에 적용되 는 매 하나의 데이터 분포의 매핑 테이블을 디자인하여 인코딩과 디코딩을 진행하며, 이로써 이러한 매핑 테이 블에서의 적어도 하나가 이에 의해 선택되어 언이브너로 사용되고 이러한 언이브너는 코드 재분포를 사용하여 조절할 수 있으며 상기 코드 재분포는 적어도 한 클라스의 슈퍼 처리유닛의 데이터 값의 데이터 분포를 이용하 여 코드 재분포를 통해 코드 조절을 진행한 후의 언이브너 매핑 테이블로 하여금 이에 의해 선택되어 적어도 한 클라스의 슈퍼 처리유닛의 압축기의 매핑 테이블로 사용되도록 하고, 첫번째 순환주기에서 언이브너를 사용하여 모든 슈퍼 처리유닛을 인코딩하며, 그 다음 압축기를 사용하여 적어도 한 클라스의 슈퍼 처리유닛을 인코딩하되 그 중 처리 중인 상응한 슈퍼 처리유닛의 데이터 압축은 제2 순환주기에서 가능한 것인 바, 즉 제1 순환주기에 서 언이브너를 사용하여 암호화하고 제2 순환주기에서 압축기를 사용하여 암호화함으로써 그러한 압축 불가능한 데이터를 함유한 슈퍼 처리유닛이 언이브너만 사용하여 암호화하도록 하고, 디코딩할 경우 이러한 슈퍼 처리유 닛에서의 매 하나의 데이터 값에 적용되는 데이터 분포의 상응한 매핑 테이블을 이용하여 이러한 슈퍼 처리유닛 에서의 매 하나의 데이터 값을 디코딩함으로써 제1 디코딩 순환주기에서 언이브너의 인코딩과 압축기의 인코딩으로 형성된 암호화된 코드가 디코딩되어 압축기 인코딩층의 인코딩이 디코딩되도록 하고 제2 디코딩 순환주기 에서 모든 슈퍼 처리유닛은 언이브너가 암호화한 코드로 조성된 암호화된 코드가 언이브너 디코더에 의해 디코 딩되며, 슈퍼 처리유닛에서의 모든 카테고리의 데이터 분포에 사용되는 적용 규칙 및 인코딩과 디코딩에 사용되 는 상응한 매핑 테이블의 적용 규칙을 설치하여 이를 암호화된 코드를 평가하는데 사용함으로써 인공지능을 사 용하여 슈퍼 처리유닛의 각 카테고리 사이의 식별작업을 진행하도록 하여 지정자의 사용을 절약할 수 있는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 24 매핑 테이블을 구성하고 상기 매핑 테이블의 고유 코드 어드레스를 사용하여 일대일 매핑방식으로 숫자 데이터 입력 중에서의 고유 데이터 값을 매핑함으로써 언이브너 인코더와 언이브너 디코더의 기술을 창조하므로 고유 데이터 값이 사용한 비트수는 상응하게 매핑 매칭되어 상응하게 매핑된 고유 테이블 코드 어드레스가 사용한 비 트수와 동일하고 상기 매핑 테이블을 사용하여 인코딩과 디코딩을 진행하는 것을 특징으로 하는 첸 코딩, 인코 딩과 디코딩의 방법. 청구항 25 인코딩과 디코딩의 목적으로 언이브너 인코더와 언이브너 디코더를 사용하여 처리하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 26 인코딩과 디코딩의 목적으로 언이브너 인코더와 언이브너 디코더를 사용하여 이브너 인코더와 디코더 또는 압축 기와 디컴프레서와 함께 처리하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 27 데이터 분포의 상황을 변화하는 상황에서 처리 중에 사용한 종료 조건에 근거하여 처리유닛 또는 슈퍼 처리유닛 의 크기를 동적으로 조절하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 28 처리 중의 데이터값의 데이터 분포 모드에 근거하여 코드유닛 정의를 동적으로 조절하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 29 분류 코드와 내용코드, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집합에서 창조되어 인코딩과 디코 딩의 목적으로 처리하는 것을 특징으로 하는 첸 코드. 청구항 30 분류 코드, 내용코드와 암호화되지 않은 코드유닛, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집합에 서 창조되어 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코드. 청구항 31 마스터헤드, 분류 코드와 내용코드, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집합에서 창조되어 인 코딩과 디코딩의 목적으로 처리함으로써 상기 마스터헤드에 첸 코딩 기술의 사용으로부터 발생한 지정자를 포함 하여 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코드. 청구항 32 마스터헤드, 분류 코드, 내용코드와 암호화되지 않은 코드유닛, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집합에서 창조되어 인코딩과 디코딩의 목적으로 처리함으로써 상기 마스터헤드에 첸 코딩 기술의 사용으 로부터 발생한 지정자를 포함하여 인코딩과 디코딩의 목적으로 처리하며 이러한 지정자는 검사 합계 지정자, 첸 코드파일 싸인, 매핑 테이블 지정자, 순환 주기수량 지정자, 코드유닛 정의 지정자, 처리유닛 정의 지정자, 슈 퍼 처리유닛 정의 지정자, 최후 식별코드 지정자, 시나리오 디자인 지정자, 언이브너/이브너 지정자, 재순환 지 정자, 빈도 지정자, 특수 코드 지정자, 일부 크기 지정자, 숫자 데이터 블랙홀 타입 지정자 및 압축 가능/압축불가능 데이터 지정자에서의 임의의 하나를 포함하는 것을 특징으로 하는 첸 코드. 청구항 33 첸 코딩 기술이 임베디드되어 처리를 진행하는 것을 특징으로 하는 첸 프레임워크로 디자인된 인코더와 디코더, 코더. 청구항 34 첸 코딩과 마스터헤드 지정자기술이 임베디드되어 처리를 진행하되 이러한 지정자는 검사 합계 지정자, 첸 코드 파일 싸인, 매핑 테이블 지정자, 순환 주기수량 지정자, 코드유닛 정의 지정자, 처리유닛 정의 지정자, 슈퍼 처 리유닛 정의 지정자, 최후 식별코드 지정자, 시나리오 디자인 지정자, 언이브너/이브너 지정자, 재순환 지정자, 빈도 지정자, 특수 코드 지정자, 일부 크기 지정자, 숫자 데이터 블랙홀 타입 지정자 및 압축 가능/압축 불가능 데이터 지정자에서의 임의의 하나를 포함하는 것을 특징으로 하는 첸 프레임워크로 디자인된 인코더와 디코더, 코더. 청구항 35 첸 코드의 숫자정보파일을 포함하는 것을 특징으로 하는 첸 코드파일. 청구항 36 첸 코딩 기술이 사용한 부가적인 정보의 숫자정보파일을 포함하고 마스터헤드와 여기에 포함되는 지정자를 포함 하며 이러한 지정자는 검사 합계 지정자, 첸 코드파일 싸인, 매핑 테이블 지정자, 순환 주기수량 지정자, 코드 유닛 정의 지정자, 처리유닛 정의 지정자, 슈퍼 처리유닛 정의 지정자, 최후 식별코드 지정자, 시나리오 디자인 지정자, 언이브너/이브너 지정자, 재순환 지정자, 빈도 지정자, 특수 코드 지정자, 일부 크기 지정자, 숫자 데 이터 블랙홀 타입 지정자 및 압축 가능/압축 불가능 데이터 지정자에서의 임의의 하나를 포함하는 것을 특징으 로 하는 첸 코드파일. 청구항 37 한가지 수학방법의 사용기술로서, 이 기술을 사용하여 데이터 값이 하나의 질서에 놓이게 되고 이 질서는 수학 공식에 의해 설명될 수 있으며 이 수학공식은 상응한 첸 형상과 대응되는 수학공식으로서 숫자정보와 관련 되는 수학계산논리와 기술을 병합하고 분리하는 것을 포함하고 이러한 숫자정보는 무작위 여부와 관계 없는 숫자정보 를 처리하는 처리유닛에서의 코드유닛의 값을 포함하여 인코딩과 디코딩의 목적으로 사용하는 것을 특징으로 하 는 첸 프레임워크에서 사용하는 첸 수학. 청구항 38 한가지 설명방법으로서, 이 방법은 기본 컴포넌트, 코드유닛과 파생 컴포넌트(예하면 첸 코드의 RP피스와 기타 파생 컴포넌트) 사이의 특징과 관계를 설명하는 바, 예하면 무작위 여부와 관계 없는 숫자정보를 처리하는 처리 유닛에서의 기본 컴포넌트 값의 조합치 또는 총합 또는 차이를 설명하여 인코딩과 디코딩의 목적으로 사용하는 것을 특징으로 하는 첸 프레임워크에서 사용하는 공식, 즉 첸 공식. 청구항 39 첸 점, 첸 라인, 첸 삼각형, 첸 직사각형, 첸 제형과 첸 정방형 및 첸 바를 포함하고 첸 공식으로 설명한 처리 유닛의 기본 컴포넌트의 특징과 관계를 대표하는 첸 형상. 청구항 40 상수값을 사용하거나 수치의 변수를 포함하여 보완 상수 또는 보완 변수로 하여 수학 처리에 사용함으로써 하나 의 수치 또는 하나의 범위 내 또는 다수의 범위 내의 다수의 수치의 미러 수치를 첸 공식에 사용하는 것을 특징 으로 하는 보완 수학. 청구항 41 보완 수학과 상규적인 수학 또는 이들 중의 임의의 하나를 첸 프레임워크에서 디자인한 디코더에 단독으로 사용하여 처리하는 첸 수학. 청구항 42 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 프레임워크. 청구항 43 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 코딩. 청구항 44 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 코드. 청구항 45 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 코드파일. 청구항 46 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 수학. 청구항 47 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 보완 수학. 청구항 48 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 형상. 청구항 49 첸 프레임워크에서 정의한 데이터 질서의 디자인과 모드를 사용하는것을 특징으로 하는 숫자 데이터 집합에 관 한 통계정보를 수집하는데 사용되어 인코딩과 디코딩의 목적으로 사용되는 무작위 여부와 관계 없는 숫자 데이 터 집합을 분석하는 방법. 청구항 50 첸 프레임워크 언어를 사용하는 것을 특징으로 하는 무작위 여부와 관계 없는 숫자 데이터 집합을 설명하는 방 법. 청구항 51 사후 분류 코드 또는 내부 분류 코드 또는 수정된 내용코드를 분류 코드로 사용하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 52 첸 프레임워크에서 정의한 디코더의 코드값을 사용하여 절대 어드레스 분기 코딩기술을 통해 기타 코드값을 흡 수하거나 표시, 즉 블랙홀 코드와 관련되는 절대 어드레스 분기 코드를 사용하여 흡수된 코드값을 대표하는 숫 자 데이터 블랙홀 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 53 코드대체기술에 이어 첸 프레임워크에서 정의한 디코더에서의 코드값을 사용하여 이어지는 단계로 다른 한 코드 값을 대표하거나 표시하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 54 절대 어드레스 분기코드의 반대되는 배치기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 55 첸 프레임워크에서 정의한 디코더가 처리하고 있는 데이터 집합에 결여한 코드값을 사용하여 블랙홀 코드를 충 당하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 56 첸 프레임워크에서 정의한 디코더가 처리하고 있는 데이터 집합에 결여한 코드값으로 비교적 긴 비트 길이의 다 른 한 코드값을 대체하되, 다른 한 코드값이 처리 중인 데이터 집합에 존재하는 것인 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 57 첸 프레임워크에서 정의한 디코더를 사용하여 인코딩과 디코딩을 진행하되, 사용한 기술은 숫자 데이터 블랙홀, 절대 어드레스 코딩, 지정자 비트 지출 축소와 잇따른 코드 대체 또는 잇따르지 않는 코드 대체 기술이고 처리 중인 데이터 집합에서 결여한 코드값을 동일한 비트 길이 도는 더 긴 비트 길이를 대체하는 다른 한 코드값으로 교체하되, 여기서 다른 한 코드값은 적합한 상황에서 처리 중인 데이터 집합에 존재하는 것인 기술을 특징으로 하는 결여된 고유 코드값이 있거나 없는 상황에서 무작위 데이터나 비무작위 데이터와 관계 없는 숫자 데이터를 압축하고 압축 해제하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 58 처리 중인 숫자 데이터 집합으로부터 생성된 빈도 분포 특징에 기반하여 지정자 비트 지출을 축소하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 청구항 59 코드유닛, 처리유닛과슈퍼 처리유닛의 고유 코드값으로서 사용한 디자인에 근거하여 하나의 비트 크기 또는 비 트 길이 도는 상이한 비트 크기 또는 비트 길이를 가지는 것을 특징으로 하는 첸 프레임워크를 사용하여 디자인 한 디코더. 발명의 설명"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "[0] 이해력이 있는 사람으로 하여금 숫자를 카운트하도록 하시오……"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 2, "content": "[1] 본 발명은 4부의 이른 시기의 PCT출원-본 발명자가 제출한 2016년 7월 29일에 제출한 PCT/IB2016/054562, 2016년 8월 5일에 제출한 PCT/IB2016/054732, 2017년 2월 22일에 제출한 PCT/IB2017/050985 및 2017년 7월 1일 에 제출한 PCT/IB2017/053993의 우선권을 주장한다. 본원 발명은 상술한 4부의 PCT출원에서 제출하고 본원 발명 에서 개진한 개념과 기술의 용도에 관한 것으로서 무작위 숫자 데이터 여부와 관계 없는 프레임워크를 정렬, 조 직 및 설명, 인코딩 및 디코딩하는 목적, 압축과 압축 해제 및 암호화와 복호화를 포함하는 것을 제출한다. 본 발명의 단일성은 본원 발명의 설명이 숫자 데이터를 정렬, 조직 및 설명하는 프레임워크인 CHAN FRAMEWORK, 즉 첸 프레임워크를 개시하여 상기 숫자 데이터로 하여금 CHAN, 즉 첸 프레임워크에서 코딩방안(코딩-디코딩방안이 라고도 함), 방법과 기술을 사용하여 여러 가지 용도의 숫자 데이터를 처리하는 목적인 바, 구체적으로 여러 가 지 활동의 숫자 데이터의 암호화/복호화와 압축/압축 해제에 사용되는 용도를 포함한다. 첸 형상의 상이한 성분 (첸 직사각형, 첸 제형, 첸 정방형, 첸 삼각형, 첸 바, 첸 점 및 첸 선 또는 처리유닛의 기초조성부분의 관계와 특징, 이진 비트 형식의 숫자 데이터로 조성된 처리유닛을 설명하는 기타 형상을 포함) 사이의 관계 및 숫자정 보의 코딩(인코딩과 디코딩을 포함)을 진행하여 지적재산권의 사용과 보호에서의 상응하는 기술에 사용함을 개 시할 경우 본 발명에서 숫자 데이터를 정렬하고 조직하는 한가지 방식을 찾는데 상기 지적재산권은 숫자정보의 형식으로 표달하고 숫자 데이터 및 기기에 사용되는 실행코드를 포함하며 기기는 실행코드를 운행할 수 있거나 숫자 데이터를 사용할 수 있는 컴퓨터 시스템 또는 컴퓨터가 제어하는 기기 또는 운영체제가 제어하는 기기 또 는 시스템을 포함한다. 이러한 기기는 아래의 내용에서 기기라고 일컫는다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 3, "content": "[2] 구체적으로 본 발명은 프레임워크와 방법 및 이가 숫자정보 기기에서의 처리, 저장, 분포와 사용에서의 응 용에 관한 것인 바, 상기 숫자정보는 숫자 데이터 및 실행코드, 예하면 시작코드, 프로그램, 응용 프로그램, 기 기 드라이버 프로그램 또는 운영체제를 구성하는 이러한 실행 파일의 집합을 포함하고 상기 실행 파일은 하드웨 어에 임베디드 또는 저장(예하면 모든 클라스의 저장매체에 임베디드되거나 또는 저장됨)되는 실행코드의 형식으로 나타나며 상기 저장매체는 읽기 전용 또는 재기록 또는 휘발성 또는 비휘발성 저장매체(이하 저장매체라고 함), 예하면 물리적 메모리 또는 내부 DRAM(동적 임의 접근 메모리) 또는 하드 디스크 또는 솔리드 스테이트 디 스크(SSD) 또는 ROM(읽기 전용 메모리) 또는 읽기 전용 또는 재기록 CD/DVD/HD-DVD/블루 레이DVD 또는 하드웨어 칩 또는 칩셋 등을 포함한다. 개시한 코딩방법, 즉 첸 코딩은 실현과정에서 암호화된 코드를 발생하고 첸 코드 는 손상 없이 복호화되어 원본 코드에 복구되며 만약 이러한 코딩이 압축에 사용되면 이러한 압축코드는 한계에 도달할 때까지 반복적으로 재압축된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 4, "content": "[3] 실제적으로 본 발명은 숫자 데이터를 셋 업하는 정렬 프레임워크를 개시함으로써 숫자 데이터를 설며할 수 있고 이의 특징을 연구하여 숫자정보를 압축/압축 해제 또는 암호화/복호화하는 목적에 사용될 수 있다. 이러한 관계에서 이는 지적재산권을 보호하는 목적으로 사용되도록 로컬 클라우드 또는 인터넷 클라우드를 통해 연결된 기기에서 숫자정보를 처리, 저장, 분포 및 사용할 수 있도록 한다. 기타 압축방법을 사용하는 것과 마찬가지로 대응되는 방법을 사용하여 적당히 압축 해제하지 않는 상황에서 압축코드는 정확하게 복구되지 못할 수 있다. 만약 압축의 목적으로 사용되지 않으면 암호화된 코드는 암호화 코드로 이해되어 정확한 대응 코딩방법을 사용 할 수 있는데 이러한 암호화 코드는 손상 없이 원본 코드에 복구될 수 있다. 첸 코딩과 첸 코드(개념, 방법을 포함하는 첸 코딩과 첸 코드, 즉 기술의 조합 및 상기 PCT출원과 본원 발명에서 개시하여 발생된 코드를 포함) 는 탐색 대기중인 여러 가지 응용의 기타 과학, 공업과 상업활동에도 사용될 수 있다. 압축분야에서 이를 사용 한 것은 이의 거대한 용도를 생동하게 전시하였다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 5, "content": "[4] 그러나 본 발명에서 제시한 프레임워크, 관련되는 모드, 디자인과 방법 및 이의 응용은 클라우드(즉 근거리 통신망 또는 인터넷)를 통한 전달 또는 숫자정보 교환에 한정되지 않고 기타 정보 전달 또는 모드 교환에 사용 될 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "[5] 압축과학기술분야에는 여러 가지 이미 발표된 숫자정보를 압축하는 방법과 알고리즘이 존재하는 바, http://en.wikipedia.org/wiki/Data_compression 에서 상용하는 데이터 압축방법과 알고리즘에 대한 소개를 찾을 수 있다. 본 발명은 새로운 방법을 설명하는데 상기 방법은 손상 없이 데이터를 압축(이 외에 암호화 및 무손상 복호화를 진행하는데 사용될 수도 있음) 및 이 를 복구하는데 사용될 수 있다. 상기 위키 피디아의 손상 없이 압축하는 관련 부분은 참조에 용이하도록 여기서 재현한다: \"무손상 데이터 압축 알고리짐은 통상적으로 통계 중복을 이용하여 데이터를 더 간결하게 나타내어 정보가 결여 하지 않도록 함으로써 상기 과정이 가역되도록 한다. 무손상 압축은 가능한 것인데 이는 대부분의 진실한 데이 터가 모두 통계 중복을 갖고 있기 때문이다. 예하면 이미지는 약간의 픽셀에서 변화하지 않는 컬러영역을 구비 할 수 있고 \"레드 픽셀, 레드 픽셀……\"을 코딩하지 않으며 데이터는 \"279개의 레드 픽셀로 암호화될 수 있다. 이는 런 렝스 부호화의 기본적인 구현예로서 수많은 방안이 중복을 제거하여 파일 크기를 절감하는 상황이 존재 한다. Lempel-Ziv(LZ)압축방법은 제일 환영받는 무손상 저장 알고리즘 중의 하나이다. [6] DEFLATE는 LZ의 한가지 변 형으로서 압축 해제 속도와 압축 비율을 최적화하지만 압축은 비교적 완만할 수 있다. DEFLATE는 PKZIP, Gzip와 PNG에 사용된다. LZW(Lempel-Ziv-Welch)는 GIF이미지에 사용된다. 이 외에 유의해야 할 것은 LZR(Lempel-Ziv- Renau) 알고리즘은 Zip방법의 기초로 사용된다. LZ방법은 표에 의한 압축모델을 사용하는데 그 중 표 항목은 중 복된 데이터 스트링을 대체한다. 대부분의 LZ방법에 있어서 이 표는 입력되고 있는 초기의 데이터로부터 동적으 로 생성된 것이다. 표 자체는 통상적으로 호프만 인코딩(예하면 SHRI, LZX)이다. 현재 LZ에 기반한 코딩 방안에 서 표현이 양호한 것은 LZX로서 이는 마이크로 소프트의 CAB양식에 사용된다. 제일 좋은 현대의 무손상 압축기 는 확률모델을 사용하는데 예하면 일부 매칭을 통해 예측을 진행하는 것이다. Burrows-Wheeler변환도 모델링을 통계하는 간접적인 형식으로 간주할 수 있다.[7] 이러한 문법에 기반한 코드는 점점 환영을 받고 있는데 이는 이들이 고도로 중복되는 텍스트, 예하면 동일하거 나 관련된 종류의 생물 데이터 수집, 거대한 버전의 문서 세트, 인터넷 파일 등을 매우 효과적으로 압축할 수 있기 때문이다. 문법에 기반한 코드의 기본적인 임무는 하나의 문자열의 앞뒤 문장과 무관한 문법을 구축 파생 하는 것이다. Sequitur과 Re-Pair는 공통코드가 사용 가능한 실용적인 문법 압축 알고리즘이다. 이러한 기술의 진일보로 되는 세분화에서는 산술 코딩으로 불리는 알고리즘에 커플링 될 수 있는 것을 통계 예 측한다. 산술 코딩은 Jorma Rissanen이 발명한 것이고 Witten, Neal과 Cleary에 의해 실용방법으로 전환되어 사 람들에게 더 잘 알려진 Huffman알고리즘에 대한 우수한 압축을 실현하였으며 그 자체가 그 중의 앞뒤 문장과 밀 접히 연관되는 자아적응 데이터 압축 임무를 예측하는데 특별히 적용된다. 산술 코딩은 이중 이미지 압축표준 JBIG와 파일 압축표준DjVu에 사용된다. 텍스트 입력 시스템 Dasher은 역산술 인코더이다[8]\""}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "[6] 상기 위키에서는 \"LZ방법은 표에 기반한 압축모델을 사용하는데 그 중 표 항목은 중복되는 데이터 스트링을 대체함\"을 설명하였다. 표를 사용하여 전환, 암호화, 압축 및 확장하는 것은 흔한 것이지만 어떻게 표를 이러한 목적에 사용할 것인가 하는 것은 여러 가지이고 그 어떤 방식 또는 기타 방식으로 새로워질 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 3, "content": "[7] 본 발명은 새로운 방법, 즉 첸 코딩법(즉 첸 코딩)을 제출하여 그 어디서도 개시하지 않은 놀라운 결과를 발생한다. 이는 도전이 성공적임을 대표하고 정보이론에서의 비둘기집원리의 신화적인 혁명적 종결을 대표한다. 첸 코딩은 다음의 설명에서 어떻게 기술적 과제를 처리하고 해결할 것인지를 전시하였다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "[8] 무손상 데이터 압축 도전에서 제기한 기술적 과제는 어떻게 하면 짧은 코드 항목에서 숫자 데이터 코드의 긴 항목을 나타나고 또 어떻게 이를 복구할 것인가 하는 것이다. 비록 짧은 항목은 긴 데이터 항목을 대체하는 데 사용될 수 있으나 불가피하게 숫자 형식의 기타 정보를 추가하여 이로 하여금 어떻게 축소된 항목에서 기존 의 긴 항목을 복구할 것인지를 가능하도록 하거나 또는 알려주도록 한다. 만약 이러한 숫자정보를 아주 많이 추 가해야 하면 압축작업이 헛수고로 되게 할 수 있으며 경우에 따라 결과는 압축이 아닌 확장일 수 있게 된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 2, "content": "[9] 이러한 부가적인 정보를 저장하는 방식은 압축과정에 대해 또 다른 도전을 제출하였다. 만약 숫자정보의 하 나 또는 다수의 항목의 부가적인 정보가 압축 데이터가 분산된 항목으로 저장되면 어떻게 부가적인 정보와 숫자 정보의 원시적인 항목을 구분할 것인가 하는 것은 하나의 과제로서 복구기간에 숫자정보의 압축항목의 분리에 대해 또 다른 도전을 제출하였는 바, 특히 숫자정보의 원시적인 항목을 상이한 길이로 압축할 경우 부가적인 정 보의 길이도 이에 따라 상응하게 변화하게 된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 3, "content": "[10] 만약 반복해서 재압축한 다음 부가적인 정보를 복구하고 숫자 항목을 압축하게 되면 이는 특별히 문제가 된다. 통상적으로 압축 데이터는 재압축될 수 없고 재압축하고자 시도를 하더라도 많은 이득을 얻을 수 없게 되 며 통상적인 결과는 확장이지 압축이 아닐 수 있게 된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 4, "content": "[11] 압축하고자 하는 숫자정보는 본질적으로 상이한 바, 일부는 텍스트 파일이고 기타는 도형, 음악, 음성 또 는 영상 파일 등이다. 텍스트 파일은 통상적으로 반드시 무손상 압축이여야 하고 그렇지 않을 경우 그 내용은 결여하거나 교란되므로 식별할 수 없게 된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 5, "content": "[12]또한 일부 텍스트 파일은 ASCII에 기반한 것이고 기타 텍스트 파일은 UNICODE에 기반한 것이다. 상이한 언 어의 텍스트 파일 또한 상이한 특징, 예하면 숫자 코드의 빈도와 조합에서 표현되는 상이한 특징을 가진다. 이 는 매우 적은 자기 적응 능력(즉 모든 가능한 상황을 만족시킬 수 없음)을 가지는 프레임워크와 방법이 모든 이 러한 시나리오에 대해 가장 적당하게 작동할 수 없음을 의미한다. 따라서 데이터 압축에 더 우수한 적응성과 영 활성을 제공하거나 또는 풀 패키지와 방법을 제공하는 것은 하나의 도전이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "[13] 본 명세서는 프레임워크, 모드와 컴퓨터가 실현하는 방법을 개시하는 바, 상기 방법은 데이터에 대해 무손 상 인코딩과 디코딩을 진행하여 무작위 데이터를 포함하는 숫자 데이터를 처리하는데 사용된다. 상기 프레임워 크와 방법은 데이터를 정확하게 처리하여 암호화/복호화 또는 압축/압축 해제의 목적에 사용된다. 상기 프레임 워크와 방법은 무손상 데이터 압축, 무손상 데이터 암호화 및 데이터의 무손상 디코딩과 복구에 사용될 수 있다. 상기 프레임워크는 데이터를 처리하기 전에 처리해야 할 숫자 데이터에 대해 가정하지 않았다. 본 발명이 나타나기 전까지 오랜 시간동안 데이터 압축분야에서 순 무작위의 이진법 데이터는 절대 압축되지 않 는 것으로 증명되었다. 상이한 유형과 상이한 언어 특징에 적용되는, 무작위 숫자정보의 무손상 압축에 관계 없 는 프레임워크와 방법을 제공함으로써 본 발명은 사람들로 하여금 무작위 숫자정보를 압축함과 동시에 성공적으 로 복구하도록 한다. 본 발명이 개시하는 프레임워크(첸 프레임워크)는 무작위 여부와 관계 없는 숫자정보의 정 렬을 조직이 있는 방식으로 설명하고 구축함으로써 임의의 숫자정보의 특징을 찾아 설명하고 조사하고 분석하여 숫자정보의 이러한 특징과 내용이 무손상 암호화/복호화와 압축/압축 해제를 주기적으로 중복하는 것을 목적으로 하는 기술과 방법을 개발하도록 한다. 이는 정보이론에서의 비둘기집원리의 신화를 종결하였다. 물론 한정도 존재한다. 명확한 것은 사람들은 1비트만 있는 숫자정보를 진일보로 압축할 수 없게 된다. 본 발명이 개시한 바 와 같이 숫자정보를 압축 하는 제한은 압축과정에서 관련 실현방식이 선택한 모드와 방법에 따라 변화하게 되는 데 예하면 사용하는 마스터헤드의 크기, 처리유닛(일정한 수량의 코드유닛을 포함)의 크기 또는 사용하는 슈퍼 처리유닛(일정한 수량의 처링유닛을 포함)의 크기 및 암호화되지 않은 이진 비트 코드의 크기에 의해 결정되고 암호화되지 않은 이진 비트 코드는 완전한 처리유닛 또는 슈퍼 처리유닛을 구성하기엔 부족했다. 따라서 디자인 과 관련 데이터 분포 자체의 성질에 근거하여 그 어떤 숫자정보를 압축하는 이러한 한정은 수천개의 이진 비트 내지 더 적게 유지할 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 2, "content": "[14] 첸 프레임워크와 첸 코딩을 사용하게 되면 압축하고 복구하고자 하는 무작위 숫자정보를 사전에 알 필요가 없다. 적합한 상황에서 아래에 설명하는 과정에서 첸 프레임워크를 정의하고자 한다. 예하면 상용하는 데이터 코더에 대해 2비트의 고정비트 크기를 사용하여 숫자 데이터를 샘플링하게 되면 이는 줄곧 2비트 양식의 숫자 데이터를 나타내고 제일 많아 4개의 값, 즉 00, 01, 10과 11을 가지게 되어 첸 프레임워크에서의 데이터 코더와 대조되는데 상기 첸 데이터 코더가 사용하는 데이터 코더는 수용 가능한 최대 데이터 값을 사용하여 데이터를 구분하는 주요한 요소 또는 표준이 되도록 디자인되며 숫자 코드의 비트값 크기와 기타 표준을 주요한 요소 또 는 표준이 아닌 것으로 하였다. 아는 상용하는 데이터 코더가 단지 첸 프레임워크에서의 데이터 코더의 하나의 변형임을 의미하고 상기 2비트 양식을 사용하는 상용 데이터 코더를 구현예로 사용하며 이는 첸 프레임워크에서 최대 4개의 값(max4클라스) 수치를 가지는 데이터 코더이다. 따라서 첸 프레임워크에서의 max4클라스의 데이터 코더는 기타 변형을 가질 수 있는 바, 예하면 모든 고유 한 4개의 값에 사용되는 총 비트 수를 비트 그룹으로 정의하고 진일보로 사용하는 마스터헤드 클라스로 정의하는데 예하면 아래의 도표0에서 나타낸 바와 같다: 도표0 첸 프레임워크에서 그루핑한 상용 데이터 코더 Max4클라스=데이터를 구분하는 주요한 요소 또는 표준으로 사용 8비트 그룹 9비트 그룹=주요한 요소 또는 표준이 아님 0마스터헤드 1마스터헤드=주요한 요소 또는 표준이 아님 00 0 1 01 10 01 10 110 001 11 111 000 Max4클라스의 데이터 코더의 3가지 변형에서 유의할만한 것은 동일한 비트 크기의 코드유닛, 예하면 8비트 그룹 외에 그 중의 모든 4개의 고유 한 코드유닛 값은 동일한 수량의 이진 비트 표시를 가지고 9비트 그룹의 다른 두 변형의 코드유닛의 비트값 크기는 모두 상이하다. 바로 이러한 첸 프레임워크에서의 풍부하고 영활한 숫자 데이 터 분류방안에 의하여 데이터를 조작 또는 나타내는 새로운 방법과 기술을 개발하여 인코딩과 디코딩의 목적에 사용함으로써 정보이론에서의 비둘기집원리의 신화를 타파하였다. 아래의 도표는 본 발명에서 개시한 데이터 코더를 사용하여 인코딩과 디코딩(압축/압축 해제와 암호화/복호화의 목적을 포함)을 진행하는 첸 프레임워크의 특징을 해석하는데 사용되는 바, 상기 데이터 코더는 상용 데이터 코 더에 의해 정의되는 동일한 최대 가능 수량을 가지는 고유한 값을 가지는 것, 예하면 Max4 8비트 그룹이 2비트 의 고정 크기와 같은 상용 데이터 코더 또는 Max8 24비트 그룹이 3비트의 고정 크기와 같은 상용 데이터 코더를 사용하는 것이다. 이는 간략을 위하여 잠시 첸 프레임워크에서의 데이터 코더를 사용하지 않은 사람들에게 처리 유닛 조성부분(컴포넌트라고도 함)의 개념을 설명하기 위한 것이다: 도표1 첸 프레임워크와 과 처리유닛 컴포넌트의 개념을 도해 설명"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 3, "content": "여기서 a와 b는 두가닥의 숫자정보인 바, 매 한가닥마다 하나의 코드유닛을 대표하고 코드유닛(은 0과 1의 일정 한 수량의 이진 비트의 코드의 기본유닛이다). 일정한 수량의 0과 1의 이진 비트가 나타내는 코드유닛의 내용 또는 값은 하나 또 하나씩 판독되는 바, 예하면 a는 제1 코드유닛으로 판독되고 b는 제2 코드유닛으로 판독된다. 한 가닥의 숫자정보는 하나의 코드유닛을 구성하고 도표1에서의 두개의 이러한 코드유닛은 하나의 처리유닛(처 리유닛이 포함하는 코드유닛의 수량은 코딩 디자인에서 사용하는 모드와 기술에 근거하여 변화하는데 이는 코드 디자이너에 의해 결정되며 따라서 도표1을 사용하는 본 도면에서 사용하는 상황과 상이함)을 구성한다; 편리함과 계산의 편리를 위하여 매 하나의 코드유닛은 동일한 정의를 가지는것이 좋은 바, 예하면 하나의 코딩 과정주기의 비트 크기에 근거하여 스케일 전환을 진행할 필요가 없이 동일한 숫자 스케일을 사용하고; 인코딩과 디코딩의 일치성과 규율성은 코딩 후 손상없이 숫자정보를 성공적으로 복구함에 있어서 중요한 일이다. 인코딩 과 디코딩의 일치성과 규율성은 숫자정보의 처리가 어떠한 규칙을 준수하여 숫자정보를 전환 또는 변환할 수 있 는 이러한 방식으로 인코딩과 디코딩에서 논리적 추론을 사용함으로써 데이터 분포를 개변, 예하면 숫자정보의 이진 비트0과 이진 비트1의 비율 및 동적 코드 조절(코드 향상, 코드 강등, 코드 생략과 코드 복구를 포함)을 개변할 수 있도록 한다. 인코딩과 디코딩에 사용되는 이러한 규칙은 코드유닛 또는 처리유닛 또는 슈퍼 처리유 닛의 특징과 내용 및 사용하는 관련 모드, 디자인 및 인코딩과 디코딩방법에 의해 결정된다. 인코딩과 디코딩의 이러한 규칙 또는 논리는 메인 마스터헤드 내의 이진법 코드(전반 숫자 데이터에 대한 입력) 또는 지정자로서 이진 비트를 사용하는 부분적 마스터헤드 내(전반 숫자 데이터 입력은 이진 비트 코드를 함유하는 다수의 부분 으로 분류되고 매 부분의 마스터헤드는 부분적 마스터헤드로 불리움)에 기록될 수 있고; 지정자로서의 이러한 이진법 코드는 인코더와 디코더에 임베디드될 수 있으며 이는 인코딩과 디코딩의 모드, 디자인과 방법의 일체성 과 규율성이 허용하는 전제하에서 발생하여야 한다. 코드유닛은 임의의 적합한 숫자 스케일의 선택에 의해 표달하고 나타나야 하는데 이는 이진법 스케일, 8진법, 16진법 등을 포함한다. 코드유닛의 크기, 즉 코드유닛 크기는 임의의 적합한 크기로 선택될 수 있는 바, 예하면 이진법 스케일, 예하면 4비트 또는 8비트 또는 16비트 또는 32비트 또는 64비트 또는 임의의 컴퓨팅에 편리한 비트값 크기는 모두 코드 유닛 크기(코드유닛의 정의는 제[54]단락으로부터 시작되는 첸 프레임워크에 근거하여 개진할 수 있음)가 될 수 있다. 매 하나의 코드유닛의 숫자수 또는 숫자값은 코드유닛의 숫자 내용을 대표하고 숫자수는 코드유닛의 모든 비트 의 비트 기호를 나타낸다. 또한, 사용하는 코드유닛 사이의 관계를 디자인하고 찾으며 설명할 수 있는 바, 첸 코딩이 어떻게 두개의 코드유닛을 사용하여 사용하는 개념과 기술의 데모로 할 수 있는가를 설명하기 위하여 상기 관계는 수학공식을 사용하여 아 래와 같이 정의한다: 여기서 a와 b는 도표1에서의 현재 모드에서 응용하는 첸 코딩에서 하나의 처리유닛의 두개의 코드유닛을 구성하 고 매 하나의 코드유닛은 각 코드유닛에서 전송하는 숫자정보의 내용 또는 수치를 나타내는 숫자수이며 b 전에 a를 판독한다. 여기서 a는 b보다 더 크거나 더 작은 값일 수 있고 사람들은 그 밖의 두개의 변수 이름을 사용하여 이 두개의 코드유닛의 값의 랭크를 나타낼 수 있다: A는 두개의 코드유닛에서의 비교적 큰 값; B는 두개의 코드유닛에서의 비교적 작은 값; 또한 여기서 a와 b의 값이 같으면 사람들은 우선 A를 판독하게 되고 두번째로 B를 판독하므로 A의 값은 B보다 크거나 같으며 이에 의하여 a가 A가 될 것인가 아니면 B가 될 것인가 하는 것은 그와 b의 관련 값에 의해 결정 된다. 여기서 상기 상황에 비추어보아 반드시 비트(RP비트)(즉 랭크와 자리 비트)를 사용하여 제1 코드유닛이 제2 코 드유닛보다 더 크거나/같거나 또는 더 작은 값인지 여부를 지시하고 코드의 이 비트 코드는 이에 의하여 두개의 코드유닛이 값을 판독하는 자리와 랭크 사이의 관계를 나타낸다; 여기서 a와 b를 암호화하기 위하여 사람들은 간단하게 a와 b의 값을 함께 하나의 단독적인 값에 추가하는데 코 드유닛 크기를 사용하는 비트값 크기에 1비트를 더하여 아래와 같이 나타낸다.도표2 인코딩하기 전에 도표2의 데이터는 도표1에 나타낸 바와 같이 코드유닛 크기를 64비트라고 가정하면 두개의 코 드유닛을 가지는 처리유닛을 구비한다:"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 4, "content": "도표3 인코딩한 후 생성된 코드, 첸 코드는 RP피스와 CV피스로 조성된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 5, "content": "여기서 첸 코드의 RP비트(1비트), 즉 제1 피스, RP피스 및 a와 b의 조합치, A+B, (65비트, 즉 64비트 더하기 1 은 코드유닛 크기의 비트 크기에 1비트를 더한 것), 즉 제2 피스, 첸 코드의 코딩값 피스 또는 내용값 피스(CV 피스)는 함께 발생하는 코딩을 구성하고 첸 코드는 이미 원시적인 숫자정보에 대해 실행한 코딩주기수량에 필요 한 것 및 나머지 코드처리에 필요한 것을 지시하기 위한 관련 마스터헤드정보를 더 포함할 수 있다. 본 발명자 는 2015년 8월 29일에 제출한 다른 PCT특허출원 PCT/IB2015/056562에서 이미 이러한 마스터헤드정보의 형성과 처리를 제출한 바가 있으므로 본 명세서에서는 더이상 중복하지 않는다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 6, "content": "코딩의 목적으로 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자들은 상술한 PCT특허출원 또는 기타 디 자인에서 제출한 마스터헤드를 이용하여 용이하게 획득된 첸 코드, 즉 첸 코드의 RP피스와 CV피스를 함께 처리 할 수 있다. 잠시 뒤의 본 발명에서 개시한 바와 같이 이렇게 디자인의 인코딩과 디코딩의 모드와 방법에 근거 하여 더 많은 코드유닛을 사용할 경우 CV피스는 진일보로 서브 피스로 분류될 수 있다. RP피스는 하나의 코드 피스로서 대응되는 코드유닛의 어떠한 특성 또는 특징을 대표하고 본 명세서의 처리유니 싀 두개의 대응되는 코드유닛 사이의 랭크와 자리의 특징을 대표한다. 또한 RP피스는 더 광범위한 코드 카테고 리의 코드의 부분 집합으로서 이는 특성코드 또는 특징코드 또는 분류 코드(이렇게 지칭하는 이유는 관련된 특 성 또는 특징이 유사한 특성 또는 특징을 가지는 코드유닛을 분류하거나 그루핑하는데 사용됨)로 명명된다. CV 피스는 하나 또는 다수의 코드유닛의 내용의 암호화된 코드를 나타낸다. 때로는 인코딩과 디코딩의 모드와 방법 에 근거하여 코드유닛의 내용의 일부는 분류 코드로 추출되어 CV피스에 남아있는 것은 단지 코드유닛과 대응되 는 내용의 나머지 부분이 되도록 한다. CV피스는 첸 코드의 내용코드를 구성한다. 따라서 인코딩과 디코딩의 모 드와 방법에 근거하여 첸 코드는 이에 따라 적어도 내용코드를 포함하고 적합한 상황에서 분류 코드를 추가하며 적당하거나 필요할 경우 내용코드 자체에 포함되거나 내용코드 자체가 내부 혼합하거나 또는 마스터헤드에 포함 되는 기타 지정자코드를 추가하는 바, 예하면 슈퍼 처리유닛을 처리할 경우 사용하는 코딩 방법 또는 코드 매핑 표를 지시한다. 이는 적합한 시기에 본 발명의 설명에서 명백히 알 수 있다. 여기까지 첸 프레임워크는 코드유닛, 처리유닛,슈퍼 처리유닛, 암호화되지 않은 코드유닛(암호화되지 않은 코드 를 포함), 마스터헤드유닛(숫자정보파일의 마스터헤드에서 사용되는 지정자를 포함하여 전반 숫자 데이터파일에 응용함), 내용코드유닛, 부분과 부분적 마스터헤드(여기서 전반 숫자 데이터파일 또는 스트림은 다수의 부분으 로 분류되어 처리가 용이하도록 함)와 적합한 상황에서 추가한 분류 코드유닛(아래 내용에서는 상기 특성코드 또는 특징코드유닛을 의미하는 것을 사용) 및 내용코드 내부와 혼합한 지정자코드(예하면 상응하는 슈퍼 처리유 닛에 특정됨)를 포함한다. 상기 프레임워크는 적합한 시기에 진일보로 완전해지고 명백히 논술한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 7, "content": "[15] 컴포넌트의 관계를 찾은 후 유닛의 두개의 기본코드유닛, 즉 랭크와 자리 및 이상의 단락[14]에서 열거한 총합을 처리하는데 이러한 관계는 RP피스에서 나타나고 첸 코드의 CV피스는 CV피스에서의 제일 간단한 수학공식 A+B를 사용한다. RP피스는 단지 1비트, 0 또는 1을 포함함으로써 하나의 처리유닛에서 판독한 두개의 코드유닛 의 제2 값b가 제1 값a에 대하여 어느 것이 더 크거나 같거나 더 작은 값인지를 지시한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 8, "content": "[16] 이전의 구현예 및 현재 시장에서 유행하고 있는 64비트 개인용 컴퓨터를 사용하는 것을 통하여 만약 이진 법 스케일의 매 하나의 64비트 코드유닛이 64비트를 사용하여 나타내게 되면 압축 또는 암호화가 없을 수 있다.따라서 매 하나의 인코딩단계에 대하여 반드시 1개보다 많은 코드유닛을 처리유닛으로 사용해야 한다. 숫자정보 의 숫자파일 또는 숫자파일의 일부(만약 숫자파일이 진일보로 다수의 부분으로 분할되어 처리가 용이하도록 함)는 매 하나의 인코딩단계를 진행하도록 반드시 하나 또는 다수의 처리유닛 또는 슈퍼 처리유닛으로 분해되며 이로써 형성된 매 하나의 처리유닛 또는 슈퍼 처리유닛의 암호화된 코드는 첸 코드의 요소로서 매 하나의 처리 유닛의 하나의 RP피스와 하나의 CV피스로 조성되며 현재의 이러한 상황에서는 첸 코드의 유닛이다. 첸 코딩을 사용하여 압축 또는 암호화를 진행한 후의 숫자정보의 숫자파일(또는 숫자파일이 분할된 부분)은 이에 의해 하 나 또는 다수의 첸 코드유닛으로 조성, 즉 첸 코드파일로 조성된다. 첸 코드를 포함하는 외에 첸 코드파일은 원 시적인 숫자정보의 임의의 나머지 암호화되지 않은 비트, 즉 하나의 처리유닛 또는 하나의 슈퍼 처리유닛을 구 성하지 않는 암호화되지 않은 코드유닛 및 식별숫자정보를 나타내기 위한 마스터헤드 또는 각주의 기타 부가적 인 숫자정보를 더 포함하나 이에 한정되는 것이 아니고 검사 합계 및 언제 인코딩을 정지하거나 또는 인코딩 또 는 다시 몇주기로인코딩, 또는 마스테헤드 또는 각주에서의 식별자 또는 지정자가 지시하는 시작 또는 결말 또 는 어느 한 곳에 존재하는 원시적인 인코딩하지 않은 숫자정보가 몇비트의 싸인 또는 지정자를 가지는 것인지를 포함한다. 만약 필요하면 현재의인코딩주기에서인코딩되지 않은 이러한 숫자정보는 다음의 주기기간에 진일보로 인코딩될 수 있다. 본 발명은 이러한 부가적인 숫자정보를 어떻게 디자인하고 장착하며 사용할 것인지에 대해 요구하지 않는다. 이러한 부가적인 숫자정보가 인코딩과 디코딩과정에 사용될 수 있다면 사람들은 자신의 목적 에 근거하여 그들만의 디자인을 진행할 수 있다. 이러한 부가적인 숫자정보를 어떻게 사용할 것인지를 설명하기 위한 목적으로 적합한 상황에서 이러한 부가적인 숫자정보의 용도를 제기할 것이다. 본 발명은 이로 인하여 주 요하게 인코딩과 디코딩에서 사용하는 기술과 방법(즉 첸 프레임워크 내의 첸 코딩)이 발생하는 첸 코드를 포함 한다. 첸 코드는 두개 또는 더 많은 저장되고자 하는 부분으로 분할될 수 있는데, 예하면 첸 코드의 서브 피스 는 단독적인 숫자 데이터 파일에 저장되어 편리 또는 안전을 고려하여 인코딩 또는 교부에 사용될 수 있다. 첸 코드 마스터헤드 또는 각주도 다른 한 단독적인 숫자 데이터 파일에 저장되어 동일한 목적으로 교부될 수 있다. 이러한 첸 코드를 조성하는 파일 및 첸 코드 마스터헤드와 각주파일은 기타 부가적인 숫자정보에 저장되는데 관 계 없이 모두 첸 코드파일이고 이는 제[14]단락에서 정의하는 첸 프레임워크에 추가되는 다른한 요소이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 9, "content": "[17] 첸 코드는 첸 코딩을 사용하는 암호화 코드이다. 첸 코딩은 원본 코드에서 암호화 코드 또는 파생 코드를 생성한다. 만약 압축하는데 사용하게 되면 첸 코드는 압축코드를 나타내고(만약 사용하는 모드와 방법에서 압축 을 진행할 수 있으면) 데이터 분포가 무작위인지의 여부와 관계 없이 모두 원본 코드에서 사용하는 비트수보다 작다. 일정한 크기를 초과하는 무작위 데이터는 균일한바, 즉 비트0과 비트1 사이의 비율은 1대1이다. 첸 코드 는 첸 코딩의 결과를 나타내고 본 구현예에서는 대응되는 수학공식을 사용하여 지시하는 연산에 의해 발생하는 바, 즉 RP피스의 값과 계산과 인코딩을 진행하기 위한 덧셈연산, 상기 수학공식이 나타내는(처리유닛) 기본 컴 포넌트와 (코드유닛) 사이의 관계에 의해 발생하고 파생 컴포넌트, 즉 도표3에서의 CV피스의 A+B를 생성한다. 상기 인코딩규칙과 논리를 사용함으로써 원본 코드로 복구할 수 있다. RP피스는 지정자 정보를 나타냄으로써 인 코더에 의해 발생한 처리유닛의 두개의 코드유닛의 랭크와 자리특징을 지시하여 디코더에 의해 완성되는 원본 코드를 복구한다. 디코딩할 경우 디코더가 준수해야할 연산규칙을 지정하는 상기 지정자는 발생된 암호화 코드 에 포함된다. 그러나 수학공식A+B로 나타내는 연산규칙은 그가 인코딩과 디코딩에서 응용되는 일치성과 규율성 으로 인하여 인코더와 디코더에 임베디드된다. 파생 컴포넌트는 하나 또는 다수의 기본 컴포넌트로 조성된 컴포 넌트이거나 또는 어떠한 연산규칙(예하면 수학공식으로 나타냄)으로 연산한 후 기타 파생 컴포넌트와 함께 조성 된 컴포넌트로서 상기 연산규칙은 예하면 덧셈, 뺄셈, 곱셈 또는 나눗셈연산을 포함한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 10, "content": "[18] 상술한 바와 같이 첸 코딩을 사용하여 처리한 후 획득한 첸 코드는 숫자정보의 숫자 비트를 포함하고 상기 숫자 비트는 하나의 유닛에 조직되거나 또는 서브 피스로 분할되어 원시적인 숫자정보의 내용을 나타내며 원시 적인 숫자정보는 데이터 분포에서 무작위인지의 여부와 관계없이 모두 정확하고 손상 없이 복구될 수 있다. 상 기 구현예는 당연히 원시적인 숫자정보의 정확한 무손상 복구를 허용하지 않는다. 예하면 이는 다른 수학공식, 예하면 A에서 B를 덜어내거나 및/또는 원시적인 숫자정보로 복구되기 전에 존재하는 대응되는 내용 코드 피스에 서의 하나를 필요로 한다. 이상의 구현예는 현재 첸 프레임워크 및 그 요소를 설명하고 정의하는 목적으로만 사 용된다. 계산하고자 하는 숫자 스케일의 선택을 결정한 후 코드유닛의 비트 크기 및 유닛을 처리하기 위한 컴포 넌트(즉 하나의 처리유닛에 사용되는 코드유닛의 수량; 제일 간단한 상황은 상술한 바와 같은 하나의 처리유닛 에 사용되는 두개의 코드유닛) 및 그들의 관계는 수학공식에서 정의하고 숫자 컴퓨터에서 사용하는 실행코드에 서 실현되며 수학공식을 사용하여 연산규칙으로 할 경우 첸 코딩이 인코딩을 위해 진행한 작업(사용되는 기타 기술은 적합한 시기에 발표)은 다음과 같은 단계를 포함한다: 원시적인 숫자정보를 판독 입력; 숫자정 보를 분석하여 그 특징, 즉 압축유닛의 컴포넌트 및 이의 관계를 획득; 수학공식 또는 디자인의 공식을 응용 하여 계산하되 상기 공식은 첸 코딩 분석 후 획득한 원시적인 숫자정보의 컴포넌트의 특징 또는 원시적인 숫자정보의 컴포넌트 사이의 관계, 즉 원시적인 숫자 데이터의 특징이 첸 코드에서의 표시를 설명; 만약 압축하게 되면 첸 코드의 숫자 비트수는 데이터 분포가 무작위인지의 여부와 관계없는 원본 코드에서 사용되는 숫자 비트 수보다 작음; 첸 코드는 무손상 인토딩 코드로서 이는 디코딩 할 경우 원본 코드로 손상 없이 복구될 수 있음 [수학공식을 사용하고 인코딩에서의 관련 수학연산은 압축으로 하여금 가능한 것이 되도록 할 수 없을 수 있는 바, 예하면 이는 사용하는 모드와 방법이 함께 디자인한 공식, 코드유닛 정의와 코드배치기술과 크게 관계됨]; 또한 단계에서 판독한 원시적인 숫자정보와 관련한 대응되는 첸 코드를 발생한다. 첸 코딩은 대응되는 첸 코드를 숫자 원본 코드가 진행한 작업으로 디코딩하는 것은 아래와 같은 단계를 포함한 다: 대응하는 첸 코드를 판독 입력; 첸 코드와 대응되는 특징을 획득; 반대되는 방식으로 이렇게 디자인한 수학공식을 응용하되 상기 공식은 첸 코드의 첸 코딩을 분석한 후 획득한 원시적인 숫자정보의 컴포넌 트의 특징 또는 컴포넌트 사이의 관계를 설명하는데 상규적인 수학과 보완 수학의 운용을 포함; 원시적인 숫 자정보가 데이터 분포에서 무작위인지 여부와 관계없이 단계을 사용한 후 손상 없이 원시적인 숫자정보의 원 본 코드를 발생한다. 따라서 디코딩 할 경우 도표3에서의 첸 코드는 정확하고 손상 없이 도표2에서의 원시적인 숫자 데이터 코드로 복구된다. 이는 코드유닛의 정의를 확대한 것을 사용하여 더 영활하고 새로운 프레임워크를 제공하는 다른 발명특징을 통해 제[14]단락에서 소개한 숫자 데이터를 정렬, 조직 및 설명하고 (잠시 후 단락"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 11, "content": "[54]에서 시작)되는 첸 프레임워크를 진일보로 완전하게 하고 명백히 논술하는 것으로 완성된다. 물론 현재까지 본 발명의 특징을 진일보로 개시하기 전에 A에서 B를 덜어내는 것을 나타내는 다른 CV서브 피스가 예하면 이상 의 도표에서 결여할 경우 상황은 결코 이와 같지 않을 것 (즉 이러한 상황에서 사용한 공식은 원시적인 데이터 코드를 정확히 복구하기에는 부족) 인 바, 이 CV서브 피스가 존재한다 하더라도 기존의 코드유닛을 사용하여 정 의(코드유닛은 통일된 비트 크기 또는 동일한 비트 크기에 근거하여 정의됨)하게 되면 획득한 첸 코드의 크기는 원보 코드보다 작도록 담보할 수 없으며 이는 사용하는 모드와 방법, 예하면 코드유닛 정의와 코드 배치 기술 및 원시적인 데이터 분포에 의해 결정된다. 그러나 수학공식 A 빼기 B를 나타내는 연산결과가 존재하는 CV서브 피스가 대응되는 결여공식 또는 처리유닛 컴포넌트의 결여피스와 함께 일 경우 획득된 첸 크드는 암호화 코드로 간주될 수 있고 상기 암호화 코드는 원시적인 숫자코드를 정확하고 손상 없이 복구하는데 사용될 수 있으나, 이 렇게 발생한 암호화 첸 코드는 압축코드가 아닌 확장코드 일 수 있다. 무작위 여부와 관계없이 분포하는 숫자 데이터를 압축하고 압축코드를 발생하는 방법과 관련 기술은 정보이론에서의 비둘기집원리의 신화를 종결시켰고 이러한 방법 및 이의 관련 기술은 잠시 후 적합한 시기에 새로운 코드유닛이 정의하는 진보성 특징 및 첸 프레 임워크를 실현하기 위한 신규 특징을 토론하는 기타 기술 다음에 개시하도록 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 12, "content": "[19] 범위의 개념 및 그가 절대 어드레스 분기 기술에서의 용도를 이해함으로써 그 용도는 무작위 데잍터를 압 축하는데 도움이 되고 첸 프레임워크의 진보성 특징의 용도와 함께 보완 수학이 어떻게 작용하는지에 대한 해석 은 아래 도표에서 제시한다: 도표4 보완 수학 CC-A=Ac 또한 Ac+A=CC 또는 Bc+B=CC 또한 (Ac+B)=(CC-A)+B 여기서 CC는 보완 상수 또는 변수로서 보완 수학 연산을 위해 선택한 상수값 또는 변수값인 바, 이는 보완 상수 또는 변수(상이한 코드유닛 크기가 상이한 인코딩과 디코딩 주기에 사용될 경우 이는 변수)를 사용하는 것으로 정의되고 본 발명에서 해석한 바와 같이 상기 보완 상수 또는 변수는 수학계산 또는 덧셈과 뺄셈 논리를 가지는 연산에서 사용된다. 상황에 근거하여 하나보다 많은 보완 상수 또는 변수를 디자인할 수 있으며 필요하거나 적 당할 경우에 상이한 조작 또는 목적에 사용될 수 있다;A는 연산하는 값으로서 본 명세서에서 사용하는 구현예는 랭크값A이고 현재 두개의 코드유닛 값만 사용하는 상 황에서 A의 값은 B의 값보다 크거나 같으므로 제1공식에서는: CC-A=Ac이다. 여기서 CC 빼기 A는 A보완, 즉 Ac로 표시하고 이는 A가 상응하는 보완 상수 또는 변수를 사용하는 보완값 또는 미러값인 바, 예하면 CC를 코드유닛 크기의 최대치의 상수라고 할 경우 예하면 256개 값의 8비트를 가지면 CC의 값은 256이고; 또한 A의 값을 100이라고 하면 Ac는 256 빼기 100=156이며; 또한 역연산은 이로써 Ac+A=CC가 되 어 100+156=256의 연산을 나타내고; 또한 제4공식에서 (Ac+B)=(CC-A)+B이며; 또한 B가 50이라고 하면 Ac+B=(256-100)+50=156+50=206이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 13, "content": "[20] 도표4는 본 발명자에 의해 발명된 보완 수학의 기본연산의 논리를 제출하였는 바, 상기 논리는 충분히 디 코딩과정으로 하여금 이후에 인입되도록 한다. 그러나 보완 수학의 덧셈과 뺄셈 연산을 더 완전하게 설명하기 위하여 이러한 논리는 아래의 도표5에서 정의하고 해석하고자 한다. 도표5 정의한 더 많은 보완 수학논리: CC-(A+B)=(A+B)c 또는=CC-A-B; 또한 CC-(A-B)=Ac+B 또한 CC-A+B는 사람들로 하여금 곤혹스럽게 할 수 있으므로 이는 아래와 같이 더 명확히 나타내야 한다. 또는 (CC-A)+B=Ac+B 또는 (CC-B)+A=Bc+A 또는 CC-(A+B)=CC-A-B; 그러므로 상기 보완 수학의 뺄셈 연산의 논리를 진일보로 설명하기 위하여 CC를 256, A를 100, B를 50이라고 하 면, CC-(A+B)=(A+B)c 또는=Ac-B 또는=Bc-A, 즉 256-(100+50)=(100+50) c=256-150=106=Ac-B=156-50=106 또는 =Bc-A=206-100=106 또한 CC-(A-B)=Ac+B 즉 256-(100-50)=256-=206=156+50=206 또한 (CC-A)+B=Ac+B 즉 (256-100)+50=156+50=206 또는 (CC-B)+A=Bc+A 즉 (256-50)+100=206+100=306"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 14, "content": "[21] 따라서 보완 수학의 덧셈과 뺄셈 연산을 사용한 상기 논리를 통해 사람들은 보완 수학이 아래의 도표6에서 어떻게 동작하는지에 관한 더 많은 세부 절차를 계속하여 표시할 수 있다. 도표6 보완 수학을 사용하여 데이터 값 또는 데이터 범위에 대해 연산 CC를 256, A를 100, B를 50이라 하면 상규적인 수학 처리: 150을 2로 나누는 바, 즉 A와 B의 평균값을 얻으면: =(A+B)/2=1/2 A+1/2B=75; 또한 A가 A+B에서의 비교적 큰값이므로; 따라서 =A-1/2(A-B)=100-1/2(100-50)=100-1/2=100-25=75; =B+1/2(A-B)=50+1/2(100-50)=50+1/2=50+25=75; 보완 수학 처리: (CC-A)+B를 연산하는 바, 즉 B가 아닌 A에서 CC에 대해 연산하면: =(CC-A)+B=Ac+B=(256-100)+50=156+50=206; 이 단계에서 연산하게 되면 우선 반드시 A와 B를 나눠야 된다는 것을 유의하게 되었는데 이 단계는 본완 수학이 여기에서의 연산을 설명하기 위한 것이다. 첸 수학을 사용하여 첸 코딩(상규적인 수학 처리와 보완 수학 처리)을 진행: A-1/2(A-B)를 사용하여 단계 의 결과를 단계의 결과에 추가하면: =Ac+B+A-1/2(A-B)=Ac+A+B-1/2(A-B) =CC+B-1/2(A-B)=256+50-1/2(100-50) =256+50-25 =256+25; 첸 수학을 사용하는 첸 코딩: 단계의 결과에서 CC를 덜어내면: =[CC+B-1/2(A-B)]-CC=B-1/2(A-B) =[256+50-25]-256 =[50-25]; 첸 수학을 사용하는 첸 코딩: B+1/2(A-B)를 사용하여 단계의 결과를 단계에 추가하면: =[B-1/2(A-B)]+[B+1/2(A-B)] =2B =[50-25]+[50+25] =25+75 =100 상규적인 수학 처리: 2B를 2로 나누어 B의 값을 얻으면: =2B/2=B =100/2=50 상규적인 수학 처리: A+B에서 B를 덜어 A의 값을 얻으면: =A+B-B =150-50 =100 상술한 내용은 상규적인 수학 처리, 보완 수학 처리와 첸 수학을 사용하는 첸 코딩 사이의 차이점을 나타낼 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 15, "content": "[22] 상기 단계에서 수행한 보완 수학은 단지 A와 B를 분리하고 사전에 미리 알고 진행하므로 반드시 다른 한가닥의 데이터정보, 즉 (A-B)(즉 새로운 코드유닛 정의를 발명하기 전에 이는 잠시 뒤에 개시함)를 추가하여 A와 B가 공식(A+B)+(A-B)=2*A와 2*A/2=A 및 (A+B) +(A-B)=2*B와 2*B/2=B를 이용하여 분리되도록 한다. RP비트 를 사용함으로써 분리된 후의 A와 B가 제1 값의 자리로 정확히 복구되도록 하고 제2 값을 a와 b로 판독한다. 또 한 단계는 단지 이러한 기본 컴포넌트를 연산할 경우 보완 수학이 어떻게 작용하는지를 표시한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 16, "content": "[23] 보완 수학은 정보이론에서의 비둘기집원리의 도전을 해결함에 있어서 직접적으로 도움이 되지 않는다. 그 러나 이는 확실히 범위를 사용하여 데이터 값을 더하고 덜어내는 개념 및 보완 상수 또는 값을 정해주는 미러값 의 개념을 돌출시켰다. 이러한 범위의 통찰력에 의해 정보이론에서의 비둘기집원리의 도전은 성공적인 결과를 획득하였는데 이는 범위가 절대어드레스분지를 사용하는 조작에서 없어서는 안되는 것이거나 또는 데이터 값 또 는 숫자의 표시와 정의방식 방면에서 잠재적인 것이기 때문이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 17, "content": "[24] 정보이론에서의 비둘기집원리의 신화를 종결하기 전에 본 발명은 첸 프레임워크에서 어떻게 수학공식을 사 용하여 무한개의 인코딩과 디코딩 알고리즘을 발생할 것인가 하는 것을 더 상세히 개시한다. 설명은 도표7로부 터 시작되는데 그 중 4개의 코드유닛, 4개의 기본 컴포넌트는 하나의 처리유닛을 조성한다. 대부분의 상황에서 처리유닛의 4개의 기본 컴포넌트는 3개의 암(Arm), 즉 롱 암, 미들 암과 숏 암으로 배치되고 2쌍의 기본 컴포넌트를 구비함으로써 상응하는 암의 상각(비교적 큰 총합을 가지는 한쌍의 두개의 기본 컴포넌 트)과 하각(비교적 작은 총합을 가지는 한쌍의 두개의 기본 컴포넌트)을 대표한다. 그러나 극소수의 상황에서 이러한 쌍의 값은 마침 어떠한 방식으로 동일한 값을 가져 3개보다 적은 암, 예하면 2개의 암 또는 1개의 암 또 는 심지어 점형상을 가질 수 있다. 따라서 처리유닛의 4개의 기본 컴포넌트의 값의 분포는 상이한 첸 형상으로 다음과 같이 나타낼 수 있다: 도표7 첸 형상 첸 점 ● 이는 모든 4개의 기본 분량이 동일한 값을 가지는 곳; 첸 라인 존재하는 2개의 첸 라인은 아래와 같다. 첸 라인1: 3개의 암은 모두 숏 암과 중첩되는데 값 [1]+[4]는상각이고 [2]+[3]은 하각이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 18, "content": "첸 라인2: 3개의 암은 모두 숏 암과 중첩되는데 값[2]+[3]은 상각이고 [1]+[4]는 하각이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 19, "content": "첸 삼각형 롱 암과 미들 암 2개의 암이 존재하고 숏 암은 하나의 점인 바, 이는 그의 값이 [1]+[4]와 [2]+[3]에 대해 동등 하기 때문이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 20, "content": "첸 직사각형과 제형과 정방형 첸 직사각형1은 순서에 따라 순차적으로 4개의 코드유닛의 데이터 값의 입력 스트림을 표시한다. 첸 직사각형2는 4개의 코드유닛의 데이터 값의 입력 스트림의랭크와 자리를 표시한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 21, "content": "상기 첸 직사각형은 처리유닛의 제1 코드유닛 값a를 B로, 4개의 코드유닛에서 랭크를 두번째로, 제2 코드유닛 값 B를 C로, 랭크를 세번째로, 제3 코드유닛 값c를 A로, 랭크를 첫번째로, 제4 코드유닛 값d를 D로, 랭크를 제 일 마지막으로 표시한다. 첸 제형은 첸 직사각형의 4개의 기본 컴포넌트 사이의 관계를 표시한다. 첸 제형1 3개 암의 상각은 [1]+[2],[1]+[3]과 [1]+[4], 또한"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 22, "content": "3개 암의 하각은 [3]+[4], [2]+[4]와 [2]+[3]이다. 첸 제형1은 4개의 기본 컴포넌트 사이의 관계, 즉 첸 직사각형2에 표시되는 4개의 코드유닛의 4개의 값을 나타 내는데 여기서 A는 [1], B는 [2], C는 [3]과 D는 [4]로 다시 나타내고, 또 같은 방식으로 (A+B)=[1]+[2], (A- B)=[1]-[2] 등등으로 나타낸다. 보다 시피 처리유닛[1], [2], [3]과 [4]의 4개의 기본 컴포넌트의 값은 3개의 암으로 배열될 수 있는 바, 즉 ([1]+[2])-([3]+[4])는 롱 암, ([1]+[3])-([2]+[4])는 미들 암 및 ([1]+[4])- ([2]+[3])은 숏 암이다. 모든 3개의 암에 대하여 [1]+[2]+[3]+[4]의 값의 총합은 항상 동일하다. 3개의 암 사이 의 차이점은 그들의 길이에 있는 바, 즉 3개의 암의 상각과 하각 사이의 값의 차이이다. 롱 암과 미들 암은 랭크값 배열에서 항상 동일한 방식을 유지한다. 그러나 숏 암의 상각과 하각은 4개의 기본 컴포넌트의 값의 분포에 근거하여 교환한다. 따라서 두가지 상황이 존재하는 바, [1]+[4]의 값이 [2]+[3]보다 크고 첸 제형1에서 또는 반대로 첸 제형2에서 다음과 같이 나타낸다.첸 제형2"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 23, "content": "3개의 암의 상각은 [1]+[2], [1]+[3]과 [1]+[4]이고 첸 제형1에서 3개의 암의 하각은 [3]+[4], [2]+[4]와"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 24, "content": "[2]+[3]이다. 첸 제형1에서 롱 암, 미들 암과 숏 암의 값은 다음과 같이 재분포할 수 있다. 롱 암=([1]+[2])-([3]+[4])=([1]-[4])+([2]-[3])=([1]-[3])+([2]-[4]); 미들 암=([1]+[3])-([2]+[4])=([1]-[4])- ([2]-[3])=([1]-[2])+([3]-[4]); 또한 숏 암=([1]+[4])-([2]+[3])=([1]-[3])-([2]-[4])=([1]-[2])-([3]-[4]). 첸 제형2에서 롱 암, 미들 암과 숏 암의 값도 다음과 같이 재분포할 수 있다. 롱 암=([1]+[2])-([3]+[4])=([1]-[4])+([2]-[3])=([2]-[4])+([1]-[3]); 미들 암=([1]+[3])-([2]+[4])=([1]-[4])-([2]-[3])=([3]-[4])+([1]-[2]); 또한 숏 암=([2]+[3])-([1]+[4])=([2]-[4])-([1]-[3])=([3]-[4])-([1]-[2]). 따라서 첸 제형1과 2에서 롱 암은 항상 미들 암2*([2]-[3])보다 크거나 같다. 그러나 숏 암의 상각 값과 하각 값을 교환하는 두가지 가능한 상황으로 인하여 첸 제형1에서 롱 암은 항상 숏 암2*([2]-[4])보다 크거나 같고 미들 암은 항상 숏 암2*([3]-[4])보다 크거나 같다. 또한 첸 제형2에서 롱 암은 항상 숏 암2*([1]-[3])보다 크거나 같고 미들 암은 항상 숏 암2*([1]-[2])보다 크거 나 같다.첸 제형3 또는 첸 정방형1"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 25, "content": "이는 미들 암과 롱 암이 중첩되는 곳인 바, 여기서 숏 암의 상각과 하각은 각각 [1]+[4]와 [2]+[3]이다. 만약 여기서 두개의 암의 길이가 동등하지 않으면 그는 제형이고 그렇지 않으면 그는 정방형이다. 첸 제형4 또는 첸 정방형2 이는 미들 암과 롱 암이 중첩되는 곳인 바, 여기서 숏 암의 상각과 하각은 각각 [2]+[3]과 [1]+[4]이다. 만약 여기서 두개의 암의 길이가 동등하지 않으면 그는 제형이고 그렇지 않으면 그는 정방형이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 26, "content": "첸 제형5 또는 첸 정방형3 이는 숏 암과 미들 암이 중첩되는 곳인 바, 여기서 숏 암의 상각과 하각은 각각 [1]+[4]와 [2]+[3]이다. 만약 여기서 두개의 암의 길이가 동등하지 않으면 그는 제형이고 그렇지 않으면 그는 정방형이다. 첸 제형6 또는 첸 정방형4 이는 숏 암과 미들 암이 중첩되는 곳인 바, 여기서 숏 암의 상각과 하각은 각각 [2]+[3]과 [1]+[4]이다. 만약 여기서 두개의 암의 길이가 동등하지 않으면 그는 제형이고 그렇지 않으면 그는 정방형이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 27, "content": "[25] 본 도면에서 가능한 데이터 인코딩과 디코딩을 진행하기 위하여 4개의 기본 컴포넌트의 4개의 값은 반드시 1개의 CV피스로 나타내야 하고 상기 피스는 4개의 서브 피스 값으로 조성(이 목적을 위해 디자인된 4개의 공식 을 사용하여 발생; 사람들은 3개 또는 더 적은 공식을 사용하도록 시도할 수 있고 현재까지 이러한 노력은 희망 적인 결과를 나타내지 않으나 사람들은 이러한 가능성을 배제하지 않았는데 이는 새로운 기술을 본 발명으로서 본 응용에 나타내는 첸 프레임워크에 인입할 수많은 기회가 있기 때문이다)되며 RP피스를 제외하고 그는 4개의 기본 컴포넌트의 값의 자리와 랭크 사이의 관계를 지시하기 위한 것인 바, 아래의 도표8에 나타낸 바와 같다. 도표8 첸 직사각형은 4개의 입력 기본 컴포넌트의 자리와 랭크의 상세한 정보 및 획득한 첸 코드를 표시한다. 첸 직사각형3은 4개의 코드유닛의 데이터 값의 입력 스트림의 랭크와 자리 및 사용하는 64비트 크기를 표시한다. 첸 직사각형4첸 코드는 첸 코딩을 사용하여 만든 압축코드를 통해 RP피스와 CV피스의 상세한 정보를 표시한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 28, "content": "본 발명의 하나의 아주 현저한 특징은 CV피스를 구성하는 4개의 서브 피스의 값의 상이한 비트 크기에 있고 또 RP피스 자체는 4비트와 5비트 사이에서 변화하며 또 이들의 비트 크기가 상이하지만 개시하고자 하는 첸 코딩기 술을 잠시 뒤에 사용하여 관련 첸 코드에 대해 디코드를 진행함과 동시에 이를 손상 없고 정확하게 원시적인 입 력 숫자 데이터 코드에 복구시킬 수 있다. 압축의 목적으로부터 볼 때 사용되는 변화된 비트 크기는 첸 코딩 기 술을 사용하여 진일보로 압축 비율을 향상시키는 것을 말하는 바, 이는 숫자 공식을 사용하여 실현한 압축 비율 보다 우월하다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 29, "content": "[26] 우선 여기서 RP피스를 해석한다. RP피스는 처리유닛의 4개의 기본 컴포넌트(4개의 코드유닛)의 4개의 랭크 값의 상대자리를 지시하기 위한 것으로서 4개의 기본 컴포넌트의 랭크가 그의 자리에 따라 변화하기 때문에 고 정된 규칙으로 4개의 기본 컴포넌트의 값의 자리와 랭크 사이의 관계를 결정하는 것이 존재하지 않는다. 자리와 랭크 사이가 존재하는 것은 모두 24가지 조합이 있는데 아래 도표9에 표시한 바와 같다.도표9"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 30, "content": "[27] 조합된 4개의 기본 컴포넌트의 값의 랭크와 자리 사이에는 모두 24개의 변체가 존재하므로 사람들은 통상 적으로 5개의 비트를 사용하여 랭크와 자리 조합의 이러한 24개의 변체를 수용하고 지시함으로써 분해할 경우 4 개의 기본 분량의 값의 정확한 랭크와 자리를 정확하게 복구, 즉 기본 컴포넌트의 4개의 랭크값을 그들과 입력 되는 숫자 데이터 입력에서의 이러한 값의 자리가 서로 대응되는 정확한 자리로 다시 갖다 놓는다. 그러나 절대 어드레스 분기라고 불리는 기술을 사용하여 공간의 낭비를 방지할 수 있는 바, 절대 어드레스 분기를 사용하지 않으면 32개의 자리가 24개의 변체를 수용하게 되어 8개의 자리가 남아 낭비하게 된다.[28] 제일 간단한 상황을 사용하기 위하여 3개의 값만 가질 수 있는데 그렇게 되면 통상적으로 2개의 비트를 사 용하여 3개의 변체 값에 4개의 자리를 제공하게 된다. 그러나 절대 어드레스 분기를 사용하는 상황에서 그 중의 값=1인 상황에 대하여 1개의 비트만 사용하면 그 중의 값=2 또는 값=3인 상황에 대하여 반드시 2개의 비트를 사 용해야 한다. 예하면 검색과정의 작업은 다음과 같다: 우선 1비트를 판독; 만약 비트값이 0이고 값이 1 임을 나타내면 제2 비트를 판독할 필요가 없고 만약 비트값이 1이면 제2 비트를 반드시 판독해야 하며 제2 비트 가 0이면 값이 2임을 나타내고 만약 제2 비트가 1이면 값은 3이다. 따라서 이는 일부 수용공간을 절약하여 고려 하는 3개의 값을 수용한다. 1/3의 상황 또는 변체는 1비트를 사용하고 그 밖의 2/3의 상황 또는 변체는 반드시 2비트를 사용하여 지시한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 31, "content": "[29] 따라서 절대 어드레스 분기를 사용하는 것을 통해 24개의 변체에서의 8개의 변체는 4개의 비트만으로 수 용하고 나머지 16개의 변체는 5개의 비트를 필요하게 된다. 이는 4개의 비트가 16개의 자리만을 제공하고 5개의 비트가 32개의 자리를 제공함을 의미한다. 또한 만약 24개의 변체가 존재하면 4개의 비트가 제공하는 자리에는 8개의 변체가 존재하므로 4개의 비트가 제공하는 16개의 자리에서의 8개의 자리는 반드시 보류하여 2개의 변체 를 나타내야 한다. 따라서 우선 4비트를 판독할 수 있는데 만약 상기 값이 1부터 8 사이에 있음을 발견하면 정 지하거나 다른 한 비트를 판독 입력할 필요가 없게 된다. 그러나 만약 4비트를 판독하고 값이 9와 16 사이에 있 음을 판독한 다음 이 8개의 변체에 대하여 다른 한 비트를 반드시 판독하여 그가 어느 값을 대표하는지를 결정 하는 바, 예하면 9를 결정한 후 그는 9 또는 다른 한 값, 예하면 17을 나타낼 수 있으며 이렇게 되면 반드시 다 른 한 비트를 판독해야 고 만약 그가 0이면 그가 9를 유지함을 나타내며 만약 그가 1이면 값은 17이므로 값이 17인 랭크 자리 코드를 나타내어 [1], [2], [3]과 [4]의 값이 반드시 대응되게 이상의 도표9에서의 랭크 자리 코드표를 참조하고 검색함으로써 3, 4, 1,과 2의 자리에서의 RP모드에 놓이도록 지시한다. 따라서 절대 어드레 스 분기는 한가지 디자인으로서 그 중 어드레스(통상적인것과 같이 하나의 값을 지시하는 것이 아님)는 현재 분 기하여 디자인에 의해 별도의 한 비트 또는 다수의 비트를 사용하여 2개 또는 더 많은 값을 표시하도록 한다. 그는 이미 알고 있는 범위를 한정할 경우 사용되고 상기 범위는 이 범위 한정에서 결정하는 변수 값의 최대 가 능 조합 또는 옵션을 한정한다. 예하면 이상의 RP표에서 랭크와 자리가 단지 24가지 조합만 가짐을 알 수 있으 므로 최대 가능한 조합은 단지 24가지이며 그는 범위 한정으로 사용되어 처리유닛이 RP조합에서의 어느 특정 값 을 가지는지를 지시함으로써 어떻게 [1], [2], [3]과 [4]의 값을 숫자 데이터 스트림의 제1 자리, 제2 자리, 제 3 자리와 제4 자리에 놓을 것인지를 지시한다. 이 범위 한정은 이미 알고 있는 것이고 또 절대 어드레스 분기를 사용하므로 평균적으로 놓고 볼 때 이 24개의 조합에 대하여 통상적인 5개의 비트를 사용하는 것이 아니라 4개 반의 비트를 사용하게 된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 32, "content": "[30] 아래에는 4개의 기본 컴포넌트 분량의 랭크값을 결정하는 바, A=[1], B=[2], C=[3], 또한D=[4]이다. [1],"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 33, "content": "[2], [3]과 [4]의 값을 결정하기 위하여 첸 직사각형과 첸 제형의 공식을 사용하여 4개의 기본 분량의 기본 관 계와 특징을 나타 낼 수 있는데 여기서 위의 제[29]단락에서 해석한 RP피스와 CV피스가 점용한 전체적인 비트 크기는 4개의 입력 기본 컴포넌트a, b, c와 d가 점용한 전체적인 비트 크기보다 작은 바, 즉 상술한 바와 같이 첸 직사각형과 첸 제형을 사용한 본 발명에서 나타낸 모드에서의 처리유닛의 코드유닛의 크기의 4배이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 34, "content": "[31] 첸 형상으로 나타내는 처리 유닛을 구성하는 4개의 기본 컴포넌트 사이의 특징과 관계를 세심히 연구한 후 CV피스의 3개의 서브 피스에서 나타내는 공식의 아래 조합은 뒤에서 작용하는 원리의 첫번째 시도를 나타내기 위한 것이다. 기타 유사한 공식을 발견하고 사용할 수 있다. 따라서 한정이 존재하지 않으나 아래에 첸 형상을 참조하여 제출한 공식을 사용하는 것을 포함한다. 그러므로 이 첫번째 시도는: =([4]-1/2([3]-[4])) =([1]-[4]) =(([2]-[3])+1/2([3]-[4])) 단계 내지 단계의 공식에서 나타낸 상기 3개의 앖과 앞에서 언급한 2016년 8월 5일에 제출한 PCT출원 PCT/IB2016/054732에서 나타낸 그러한 값들은 상이한 것이다. 상기 PCT출원에서 랭크와 자리가 처리한 용도와 결합한 보완 수학의 용도는 정보이론에서의 비둘기집원리의 신화를 종결지을 수 있다고 여겨졌다. 더 자세한 검 사를 거쳐 이렇게 사용한 3개의 공식은 이 목표를 달성할 수 없음을 발견하였다. 따라서 정확한 공식과 공식 디 자인이 첸 코딩 기술에 대한 응용은 아주 중요하다. 상기 PCT출원에서 첸 형상이 나타낸 바와 같이 첸 코딩은 기본 컴포넌트(즉 처리유닛의 코드유닛) 사이의 특징과 관계를 사용하여 디자인함으로써 완성한 거이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 35, "content": "[32] 공식 디자인은 하나의 과학이 아닌 하나의 예술과 같다. 사람들이 처리유닛의 상이한 기본 컴포넌트와 파 생 컴포넌트 사이의 특징과 관계의 모든 조합을 전부 사용할 수 없으므로 새로운 사유는 정확한 공식을 사용하 는 것을 성공적으로 장악하는데 도움이 될 것이다. 상기 PCT출원에서 사용한 3개의 공식은 적극적인 사유로 디 자인한 것으로서 3개의 공식을 사용하게 되면 사람들은 관련 첸 형상을 재현할 수 있으며 구체적인 상황에 근거 하여 첸 제형 또는 첸 정방형 또는 첸 삼각형 또는 첸 점 또는 첸 라인을 포함할 수 있다. 그러나 상기 PCT출원 에 인입한 기술을 사용하여 디자인한 3개의 공식이 나타낸 바와 같은 이러한 사유 모드를 사용하게 되면 기본 컴포넌트는 그들의 파생 컴포넌트에서 분리될 수 없을 수 있다(또는 쉽게 분리될 수 없을 수 있는데 이는 계산 에 사용되는 조합이 완전히 사용되지 않을 수 있기 때문이다)."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 36, "content": "[33] 정보이론에서의 비둘기집원리의 도전에 대응하기 위하여 상기 PCT출원에는 새로운 사유패턴이 결여한다. 또한 여기서 시도한다. 사물이 적극적인 방식으로 작용을 발휘할 수 없을 경우 그는 반대되는 방식으로 작용을 발휘할 수 있다. 이는 보완 수학과 관련되는 사유 모드 또는 패러다임이기도 하다. 따라서 만약 정확한 첸 형상 을 재현하도록 디자인된 공식이 좋은 결과를 가져외지 않으면 사람들은 이 3가지 공식에 차이점을 인입하도록 시도할 수 있다. 따라서 본 발명은 차이점 인입(또는 이상 인입으로 불리움)의 기술을 개시하여 차이점 인입과 보완 코딩과 같은 유용한 기술에 의해 첸 코딩의 모든 기술로 하여금 정보이론에서의 비둘기집원리의 신화를 종 결하도록 하며 이는 보완 코딩의 유용성 및 공식 디자인 단계에서의 차이점 인입 기술 자체의 유용성을 나타낼 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 37, "content": "[34] 따라서 디자인 단계 과정에서 제1 단계는 사람들이 예전과 같이 공식을 디자인하여 인코딩함으로써 이렇게 디자인한 공식을 사용하여 첸 형상을 재현하도록 할 수 있다. 예하면 상기 PCT출원에서 제공한 구현예를 사용하 여 단계 내지 단계에서 첸 코드의 CV피스의 3개의 서브 피스의 값과 암호화된 코드를 도출하고 획득하는 3개의 공식은 다음과 같다. =([1]-[4]); =([2]-[3]); 및 =([3]+[4]). 상규적인 수학을 사용함으로써 아래에서 상기 PCT출원을 인용한 단계 내지 단계에서 관련되는 첸 형상을 재현하면 다음과 같다. =+; 즉 단계+단계 =([1]-[4])+([2]-[3]); 이 4개의 랭크값을 재배치하거나또는 재분포할 경우 초래함; =([1]+[2])-([3]+[4]); 롱 암을 획득; =([1]-[3])+([2]-[4]); 기타 암과 길이의 차이점을 비교하는데 사용됨; =-; =([1]-[4])-([2]-[3]); =([1]+[3])-([2]+[4]); 미들 암을 획득; =([1]-[2])+([3]-[4]); =+; =([1]-[4])+([3]+[4]); =([1]+[3]); 미들 암의 상각; =+; =([2]-[3])+([3]+[4]); =([2]+[4]); 미들 암의 하각; =+; =([1]+[3])+([2]+[4]); [1]+[2]+[3]+[4]의 총합으로서 롱 암의 상각을 찾음에 있어서 매우 유용함; =([1]+[2]+[3]+[4]); =-; =([1]+[2]+[3]+[4])-([3]+[4]); 여기서 [3]+[4]=단계은 롱 암의 하각으로 제공됨; =([1]+[2]); 롱 암의 상각;"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 38, "content": "[35] 상기 단계로부터 알 수 있다 시피 단계 내지 단계의 상규적인 수학을 사용함으로써 롱 암과 미들 암 의 두개의 각 및 암 자체를 정확히 재현할 수 있다. 그러나 3개의 적합한 공식을 사용함으로써 기본 컴포넌트는 병합되고 파생 컴포넌트에서 양호하게 결합되어 기본 컴포넌트로 하여금 서로 용이하게 분리되지 않도록 한다. 따라서 사람들은 3개의 디자인이 합리적인 공식에서 차이점을 인입하여 처리함으로써 새로운 세계를 발견할 수 있을지의 여부를 진일보로 확인할 수 있다. 사람들은 무작위 방식으로 불용 정보에서의 불용 정보 원칙의 차이 점을 인입하지 말아야 한다. 사람들은 이미 디자인한 3개의 합리적인 공식을 위해 유용한 정보를 제공하는데 필 요한 내용에 관심을 보여야 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 39, "content": "[36] 이상의 구현예에서 사람들은 두개의 파생된 컴포넌트의 결여를 쉽게 주의할 수 있으나 현재의 문제점을 해 결하기 위한 부가적인 정보를 제공함에 있어서 매우 중요한 바, 즉 4개의 기본 컴포넌트를 파생 컴포넌트에서 분리한다. 이 두개의 파생 컴포넌트는 [1]-[2]와 [3]-[4]로 식별된다. 이 두개의 파생 컴포넌트에서의 임의의 하나를 구비하면 사람들은 단계에서 획득한 ([1]-[2])와 ([1]+[2]) 사이 및 단게에서 획득한 ([3]-[4])와 ([3]+[4]) 사이의 덧셈과 뺄셈을 통해 기본 컴포넌트를 용이하게 분리할 수 있다. 따라서 [1]-[2]와 [3]-[4]에 서의 임의의 하나 또는 두개를 상기 3개의 적합한 공식에 인입하도록 시도할 수 있다. 또한 필요할 경우 진일보 로 되는 공식을 사용하여 조절할 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 40, "content": "[37] 수차례의 시험과 오류를 거친 후 현재까지 설명한 첸 프레임워크에서 단계[31]에서의 공식 디자인에서 차 이점 인입 또는 이상 인입의 특징을 시도할 지라도 4개의 코드유닛을 처리유닛으로 사용한 모드에서 3개의 공식 을 사용하여 정확한 디코딩을 진행하여 성공한 공식 디자인이 존재하지 않는다. 따라서 제4 공식, 예하면 [1]-"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 41, "content": "[2] 또는 [3]-[4], 즉 단계=[1]-[2] 또는 단계=[3]-[4]는 이미 인입되어 정확한 디코딩을 진행하도록 한 다. 또는 더 총명한 사람은 3개의 공식만을 사용하는 해결방안을 제추할 수 있다. 그러므로 이 방면에서 여전히 희망이 있다. 첸 프레임워크의 새로운 방면에 있어서 이는 한가지 기회를 제공하여 숫자 데이터를 정렬 또는 조 직하고 숫자 데이터에서 설명 가능한 정렬 또는 구조를 만드는 여러 가지 방식을 가능하도록 함으로써 상이한 데이터가 분포한 숫자 데이터의 성질을 연구할 수 있고 그들의 특징의 차이점을 비교할 수 있으며 이러한 데이 터 특징의 규율성(또는 규칙 또는 규율)을 식별할 수 있도록 하여 압축과 암호화의 목적으로 상이한 기술을 디 자인하여 인코딩과 디코딩을 진행함으로써 숫자정보를 보호할 수 있다. 따라서 잠시 뒤에 볼 수 있는 바와 같이 유리한 결과를 얻을 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 42, "content": "[38] 4개의 공식을 사용하여 발생한 4개의 CV서브 피스와 RP피스가 함께 디코딩을 진행할 때 처리유닛의 4개의 기본 컴포넌트 또는 코드유닛의 값을 정확히 분리하여 워니적인 숫자정보를 정확히 복구하더라도 그는 여전히 숫자정보의 공식 디자인과 데이터 분포에 근거하여 압축할 기회를 제공한다. 잠시 뒤에 볼 수 있는 바와 같이 슈퍼 처리유닛을 인입하여 사용하는 다른 한 기술의 상황에서 기타 첸 코딩 기술을 사용하고 첸 프레임워크에서 정의한 데이터 코더의 용도를 포함하며 특히 숫자 데이터 블랙홀에서의 이상 인입 용도와 절대 어드레스 분기 기술의 용도를 디자인, 창조 및 실현함에 있어서 모든 데이터가 분포한 숫자 데이터(심지어 무작위 데이터를 포 함)를 압축할 경우에도 유리한 결과를 발생할 수 있다. 그러나 첸 프레임워크에서 사용하는 공식 디자인은 숫자 데이터에 무한한 방법 또는 알고리즘을 제공하여 암호화와 복호화를 진행함으로써 데이터를 보호하는 목적에 도 달한다. 또한 이는 통상의 지식을 가진 자가 이니더라도 용이하게 실천할 수 있는 간단한 암호화와 복호화 방법 이다. 총명하지 않은 사람에게 있어서 [1], [2], [3]과 [4]의 값은 단계 내지 에서 표현한 공식과 단락"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 43, "content": "[34]와 [36]에서 설명한 기타 파생 단계에 따라 서로 분리된다. 그 외의 공식 조절과 단계는 공간의 최적화에 사용되도록 디자인 될 수 있는 바, 적용될 경우 아래 단락 [43]과 [44]에서 설명하는 구현예에서 모델링한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 44, "content": "[39] 단락[37]에서의 단계(I) 내지 단계(IV)에서 설명한 공식을 통해 계산한 데이터의 값은 현재 인코딩 과정에 서 첸 코드의 CV피스의 4개의 서브 피스에 놓여진다. 인코딩 할 경우 이 4개의 값은 CV피스의 4개의 서브 피스 로서 대응되는 RP피스와 함께 첸 코드 파일에 저장된다. 매 하나의 CV서브 피스의 값의 범위 한정은 응당 충분 히 큼으로써 상응하는 공식을 사용할 경우 가능하게 나타날 수 있는 모든 가능한 값에 적응하도록 한다. 디코딩 과정에서 절대 어드레스 분기 기술을 사용하고 도표9에 대해 사용한 관련 랭크 자리 코드표를 통해 검색값을 찾 으며 처리유닛과 대응되는 랭크 자리 코드를 통해 RP피스와 CV피스를 판독하여 디코딩함으로써 디코딩 기간에 처리유닛에 배치할 [1], [2], [3]과 [4]의 랭크값의 자리를 결정하도록 한다. [1], [2], [3]과 [4]의 랭크값은 단락[38]에서 설명한 상기 단계에서 나타낸 바와 같이 단락[37]에서의 단계(I) 내지 단계(IV)에 저장된 대응되는 CV피스의 4개의 서브 피스의 값을 사용하여 결정한다. CV피스의 4개의 서브 피스는 단락[43]과 [44]에서 개 시한 기술을 사용하여 배치하는데 이렇게 보완 수학과 보완 코딩이 CV서브 피스를 배치하는 범위를 한정하는 것 을 상세히 설명함으로써 적합한 상황에서 디자인할 경우ㅢ 가치를 조절한다. 절대 어드레스 분기 기술은 여기에 서 공간 절약을 최적화하는 기술이다. 간단하게 a, b, c, d를 대체하고 단락[37]에서 설명한 4개의 공식에서"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 45, "content": "[1], [2], [3]과 [4]를 대체하는 것도 RP피스를 생략하는 가능성을 지시한다. 이는 이러한 대체를 통하여 단락"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 46, "content": "[37]과 [38]에서 설명한 공식도 RP 처리가 없는 상황에서 작용한다는 것을 의미한다. 그러나 RP 처리가 없는 상 황에서는 그 다음에 사용범위의 한정으로 인한 공간 절약 가능성의 장점을 잃을 수 있다. 이는 RP처리를 사용하 는 것보다 더 많은 공산을 낭비하는 문제를 초래할 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 47, "content": "[40] 보완 수학과 보완 코딩은 CV 서브 피스의 배치를 진행하는 디자인 과정에서 공간을 절약하는데 매우 유용 한 바, 이는 적합한 상황에서 원시적인 공식 디자인을 조절하는 상황을 초래할 수 있다. 아래 도표10은 공식 디 자인 단계에서 현재의 노력으로 보완 수학과 보완 코딩을 사용하여 단락[31]에서의 공식 디자인이 아래 도표10 과 함께 한 기여를 나타냈다. 도표10 첸 바 코드유닛 크기를 보완 상수CC의 보완 수학 패러다임에서의 범위 한정의 시각적 표시"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 48, "content": "미지의 데이터"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 49, "content": "기지 데이터"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 50, "content": "[41] 이상의 도표에서 단락[31]에서 3개의 CV서브 피스의 값으로 나타나는 3개의 공식이 나타내는 범위는 그들 의 보완 범위(미지의 데이터)와 함께 표시된다. X자체는 이미 알고 있는 것이 아니고 공식의 일부([2]-[3]) +1/2([3]-[4])로서 병합된다. 이러한 공식에 인입된 이상 또는 차이 또는 조절, 1/2([3]-[4])은 주요하게 관련되 는 첸 형상의 [3]+[4]과 [2]-[3]의 적합한 다지인을 순수히 설명한 공식에 인입된다. [3]+[4]의 평균값이 ([4]+1/2([3]-[4]) 또는 ([3]-1/2([3]-[4])이므로 그 중의 임의의 하나를 사용하여 이상 또는 차이 또는 조절을 인입할 수 있다. ([4]+1/2([3]-[4])는 이에 공식 차이 또는 조절을 인입한 후 수정된 공식으로 간주되는 바, 그 의 현재의 공식은 단계에서 사용되고 이러한 차이 도는 조절을 평형하기 위하여 단계에 사용된 제3 공식 을 (([2]-[3])+1/2([3]-[4]))로 대응되게 조절한다. 이것은 예전에 그 누구도 측량하지 않았던 새로운 세계이므 로 반드시 시행착오의 방법을 통해 학습해야 한다. 단락[31]에서 디자인한 공식이 상기 도전에 대해 제출한 해결방법도 성공적이지 못하므로 더 많은 조절이 필요하다. 더 총명한 영혼을 가진 사람은 데이터 또는 처리유닛 을 병합한 기본 컴포넌트와 이로써 디자인한 공식이 나타내는 파생(또는 기본 컴포넌트와 조합) 컴포넌트를 분 리하도록 첸 코딩을 사용하는데 적용되는 기타 공식을 더 디자인할 수 있다. 공식 차이 또는 공식 이상 또는 공 식 조절을 인입하는 기술은 아래와 같은 단계를 포함한다: (i) 파생 또는 기본 컴포넌트의 값 또는 관계와 특징 을 재현하는데 사용될 수 있는 공식을 디자인; (ii) 어떠한 파생 또는 기본 컴포넌트가 결여하지만 부가적인 값 을 제공함에 있어서 매우 중요하다는 것을 찾아내어 기본 컴포넌트와 디자인 공식이 대표하는 컴포넌트를 분리 하는 목적에 사용; (iii) 이러한 결여 컴포넌트를 제공하는 공식을 사용하여 공식 이상 또는 공식 조절 또는 공 식 차이를 디자인하되, 이러한 공식 이상 또는 공식 조절 또는 공식 차이는 첸 코드의 CV 서브 피스 값을 획득 하기 위한 공식에 인입; (iv) 공식 이상 또는 공식 조절 또는 공식 차이를 이상의 단계(i)의 선행 디자인의 공 식에 병합하고 한 그룹의 새로운 공식을 만들되 상기 공식은 기본 컴포넌트와 새로운 디자인 또는 조절에 의한 공식이 대표하는 컴포넌트를 분리하는 목적에 적용된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 51, "content": "[42] 단락[38]에서 설명한 4개의 공식을 사용한다고 가정하면[1], [2], [3]과 [4]의 랭크값을 결정하고 RP피스 를 사용한 후 대응하는 처리유닛의 원시적인 숫자 데이터는 현재의 무손상 해독을 입력하고 정확한 자리로 정확 히 복구된다. 지금 단계(I) 내지 단계(IV)의 공식이 첸 코드로 나타내는 CV피스의 4개의 서브 블록의 코듸의 위 치와 비트 크기를 저장하고 인코딩 과정에서 비트 저장을 진일보로 최적화하는 것을 고려할 수 있다. 그는 범위 한정의 개념을 사용한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 52, "content": "[43] 첸 코드의 CV 피스의 4개의 서브 피스에서 어느 서브 피스가 먼저 배치될 것인지를 고려하기 위하여 하나 의 서브 피스 배치가 기타 서브 피스의 배치에 정보를 제공할 수 있을지의 여부를 고려하여 저장공간을절약할 수 있다. 이하 단락[31]에서 설명한 3개의 공식을 사용하여 설명하는 목적을 토론하고자 한다. 보완 수학의 가 치를 이해하기 위하여 단락[31]에서의 단계 내지 에서의 자유 공식 ([4]+1/2([3]-[4]), ([1]-[4])와 (([2]-[3])+1/2([3]-[4]))를 비교하는 것을 통해 앞의 2개의 공식 [4]-1/2([3]-[4])와 ([1]-[4])가 나타내는 범 위가 범위를 초과하였음을 알 수 있으며 이러한 범위에서는 하나가 다른 하나를 포함하지 않는다. 따라서 그들 중의 임의의 하나는 모두 제1 자리에 놓일 수 있음은 명백한 것이다. 그러나 [4]-1/2([3]-[4])에서 CC를 사용하 면 [4]-1/2([3]-[4])의 미러값, 즉 [4]c+1/2([3]-[4])는 응당 [1]-[4]의 범위를 포함할 수 있을 것임은 아주 분명 하므로 [4]c+1/2([3]-[4]), [4]-1/2([3]-[4])의 미러값은 [1]-[4]의 값을 배치하는 범위 한정으로 사용할 수 있다. 또한 이로써 [4]-1/2([3]-[4])의 CC 값을 제1 CV서브 피스로 하여 배치함으로써 공식 [1]-[4]에 의해 나타 내는 제2 CV서브 피스로 하여금 [4]-1/2([3]-[4])의 미러값(CC의 조작이 가동되도록 하는 것을 통해)을 사용하여"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 53, "content": "[1]-[4]의 값을 저장하는 범위 한정으로 하도록 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 54, "content": "[44] 그러나 [4]-1/2([3]-[4])의 값이 일부 드문 경우에 마이너스 값일 수 있으므로 [4]c+1/2([3]-[4]]) 값은 코 드유닛 크기를 초과할 경우 이러한 상황에서 CC값, 즉 코드유닛 크기의 사용을 복구하여 [1]-[4] 값의 범위 한 정으로 할 수 있다. 바꾸어 말하면 [4]c+1/2([3]-[4])와 CC 값이 제공하는 두개의 범위에서의 제일 짧은 범위를 선택하여 [1]-[4]의 값의 범위 한정으로 사용할 수 있다. 대부분의 기타 상황에서 [4]c+1/2([3]-[4])가 나타내는 범위 한정이 CC 값보다 작으므로 비트 저장 절약을 달성할 수 있다. [1]-[4]는 ([2]-[3])+1/2([3]-[4])의 범위 한정으로 사용될 수 있는데 이는 [1]-[4]를 보완 변수의 [2]-[3]의 미러값으로 사용하는 것은 [1]-[2]에 [3]-"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 55, "content": "[4]을 더하는 것이고 [3]-[4]는 응당 1/2([3]-[4])보다 커야 하므로 ([2]-[3])+1/2([3]-[4])가 [1]-[4]의 범위 내에 위치한다는 것을 확신할 수 있다. 따라서 [1]-[4]는 제2 CV서브 피스로 사용할 수 있는데 이는 제3 CV서브 피스([2]-[3])+1/2([3]-[4])의 범위 한정에 사용되어 더 많은 비트 저장공간을 절약한다. 제1 CV서브 피스를 배 치하는 범위 한정은 CC값으로서 이는 그가 참조로 되기 전에 기타 사용 가능한 범위 한정이 존재하지 않기 때문 이다. 마찬가지로 그 중의 [4]-1/2([3]-[4])의 값이 마이너스 값으로 변하는 일부 드문 상황에서 그에 대해 별도 의 부호 비트를 사용해야 한다. 그 외에 반감조작으로 인하여 상기 값은 0.5의 일부만 가질 수 있으므로 일부 비트가 이러한 지시에 사용되는 것을 포함해야 한다. 그러므로 그는 항상 CC비트 크기+2비트이다. 따라서 만약"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 56, "content": "[1]-[4]의 값이 최대치인 2^64가 아니고 1,000이면 1000은 ([2]-[3])+1/2([3]-[4])의 범위 한정을 저장하는데 사용될 수 있다. 절대 어드레스 분기를 사용하여 1,024의 한정이 1,000으로 정확히 감소되도록 하여 이러한 상 황에서 아주 적게 절약하도록 할 수도 있다. 사용되는 비트 크기는 64비트 코드유닛이 통상적으로 필요한 64비트가 아닌 10비트 또는 9비트이다. 그러나 제1 CV서브 피스 [4]-1/2([3]-[4])의 상황과 같이 반감조작으로 인해 제3 CV서브 피스([2]-[3])+1/2([3]-[4])도 0.5의 값분수를 가질 수도 있으므로 하나의 분수 비트를 [1]-[4]의 값 이 설치한 범위 한정에 하나 더 분포할 필요가 있다. 다음 이상에서 개시한 단락[31]에서의 단계 내지 에 대해 첸 코드의 CV피스 이 3개 서브 피스의 배치를 완성한다. 따라서 만약 범위 한정과 절대 어드레스 분기의 개념과 기술도 저장공간의 최적화에 사용되면 CV피스의 3개의 서브 피스 및 이로써 전반적인 CV피스의 크기가 처리유닛의 상이함에 의해 변화하게 됨은 명백한 것이다. 기억해야 할 것은 사용하는 범위 한정이 나타날 수 있 는 모든 가능한 값을 포함해야 하고 관련 범위 한정은 이러한 가능한 값에 사용되도록 디자인된다. 일부 상황에 서 범위 한정은 이에 수치2를 추가하여 조절할 필요가 있을 것인 바, 이는 랭크값이 값 자체에 근거하여 랭크한 것이고 값이 동등할 경우 그들은 그들이 입력한 숫자 데이터 스트림에서의 자리에 근거하여 랭크한 것이기 때문 이다. 따라서 반드시 구체적인 문제는 구체적으로 분석해야 하고 특정된 값의 범위 한정을 조심스럽게 고려해야 하며 특정된 값을 위해 디자인한 범위 한정이 나타날 수 있는 모든 가능한 값을 포함할 수 있도록 확보해야 한 다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 57, "content": "[45] 예를 들어 첸 코드를 배치하는 아래 3개의 CV서브 피스에 필요한 공간 또는 비트 크기(단락[31]에서의 그 것들이 아니고 공식(IV)이 코드유닛의 표준 비트 크기를 사용한다고 가정), 예하면 암호화 목적으로 공식에 의 해 아래와 같은 디자인으로 표시한다. 공식(I)=3*([1]-[2]+[3]-[4])+([2]-[3])+([1]+[3]); 공식(II)=3*([1]-[2]+[3]-[4])+([2]-[3])-([2]+[4]); 및 공식(III)=[3]-[4]; 각각 5개의 코드유닛, 3개의 코드유닛과 1개의 코드유닛으로 추정한다. 24가지 조합의 RP피스를 제공하여 별도 의 5비트를 사용하는데 만약 절대 어드레스 분기를 사용하면 일부 조합은 4비트만 사용할 수 있다. 따라서 만약 코드유닛 크기가 64비트이면 범위 한정을 사용하여 달성하는 공간 최적화를 계산하는 것이 아니라 각각 68비트, 66비트와 64비트를 공식(I), (II)와 (III)에 사용한다. 범위 한정을 사용하는 것을 통해 공식(I)의 값은 명백히 공식(II)의 값보다 크고 공식(II)의 값은 공식 (III)의 값보다 크다. 따라서 우선 공식(I)을 배치하고 다음 공 식(II)를 배치하며 그 다음 공식(III)을 배치한다. 이러한 배치기술을 사용하는 것을 통해 비트 저장을 최소화 할 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 58, "content": "[46] 진일보로 반성해보면 보완 수학은 매우 유용한 개념과 더 많은 기술 도구를 제공하여 저장 공간을 절약하 는 것 같다. 그러나 그의 중요성은 범위 처리, 미러값 및 기본 시프팅을 포함하는 패러다임에 있는 바, 예를 들 어 값의 미러값을 지시하는 기준은 CC 값, 즉 코드유닛 크기를 사용하는 것이고 상규적인 수학 처리를 진행할 경우 값 0의 기수 가 아닌 역으로 계산하기 위한 기수로 사용된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 59, "content": "[47] 첸형상에서 개시한 특징과 관계를 사용하는 것을 통해 처리유닛에 사용되는 상이한 수량의 코드유닛으로 공식 또는 기타 형상을 디자인 할 수 있는데 이는 단지 상규적인 수학 처레의 상황에서도 이러한 상황은 첸 코 딩을 사용하는 정보이론에서의 비둘기집원리의 도전과 마주할 수 있기 때문이다. 첸 프레임워크에서 구축한 코 드유닛과 공식 디자인의 무한한 조합(및 기타 기술을 추가하여 그와 함께 사용하는 가능성에 응용됨)을 감안하 여 그 누구도 이것이 불가능하다는 것을 확정할 수 없다. 또한 아래에 개시하고자 하는 것은, 공식 디자인의 특 징을 사용하지 않더라도 이러한 기타 기술은 정보이론에서의 비둘기집원리의 신화를 종료할 수 있다는 것이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 60, "content": "[48] 보완 수학과 보완 코딩은 공식 디자인 단계 및 인코딩과 디코딩에 도움이 된다. 따라서 첸 수학과 첸 코딩 은 한 그룹의 슈퍼 수학 처리인 바, 상기 슈퍼 수학 처리는 첸 형상 및 숫자정보(무작위 여부와 관계없이)를 인 코딩과 디코딩할 경우 개시하는 특징과 관계를 결합 도는 단독으로 분리하여 사용한 상규적인 수학과 보완 수학 을 포함한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 61, "content": "[49]최적화를 위해 진일보로 검사할 경우 단락[37]과 [38]에서 설명한 공식에서 처리유닛의 a, b, c와 d 값을"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 62, "content": "[1], [2], [3]과 [4]로 대체하여 RP피스와 관련 RP처리를 생략할 수 있다. 그러나 CV서브 피스의 배치는 이로 인하여 RP피스와 RP처리를 사용할 대보다 더 많은 공간을 필요하게 된다. 또한 더 알아야 할 것은 RP처리의 가 치는 [1], [2], [3]과 [4] 형식으로 된 처리유닛의 4개의 기본 컴포넌트(a, b, c와 d) 사이의 관계를 더 명확히 요해하여 첸 형상을 사용하고 첸 형상으로 나타낼 경우 이러한 값을 정확히 이해할 수 있다는 것이다. 이는 진 일보로 본 발명에서 설명한 기타 인코딩 및 디코딩 기술을 적용하기 위한 정확한 공식을 디자인하는 방법을 추 가한다. 따라서 RP 피스와 RP 처리를 사용하여 인코딩과 디코딩을 진행할지 여부는 구체적인 상황에 따라 결정될 수 있는 선택 사항이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 63, "content": "[50] 이렇게 디자인된 4 가지 공식으로 나타낸 4개의 CV 서브 피스를 사용하면 암호화를 위한 다변량 알고리즘 을 대담하게 설계 할 수 있다. 그 다음 인입하고자 하는 기타 기술을 사용하여 이러한 암호화 된 숫자 데이터를 압축할 수 있다. 이러한 방식으로 매우 쉽고 안전하게 암호화/복호화 및 압축/압축 해제 알고리즘과 과정을 디 자인하고 실현할 수 있다. 암호화/복호화 및 압축/압축 해제의 주기수 또한 결과 코드에 영향을 미친다. 또한 이러한 정보(디자인된 공식과 실현하고자 하는 암호화/복호화 및 압축/압축 해제의 주기 수를 포함)와 전송하고 자 하는 데이터가 별도로 전송되면 데이터 안전성이 향상 될 수 있으고 전례없는 수준으로 크게 보호 될 수 있 다. 데이터 보호를 더욱 강화하기 위해 원시적인 숫자정보를 복구하도록 상이한 유형의 첸 코드를 별도로 저장 하고 정확한 순서로 전송할 수 있으며 예하면 CV 서브 피스의 부호 비트는 하나의 부호 비트파일에 있고 매 하 나의 CV 피스는 개별적인 CV 서브 피스 파일에 있으며 RP 피스는 RP 피스 파일에 있고 마스테헤드 또는 각주는 별도의 마스터헤드 또는 각주파일에서의 대응되는 첸 코드의 처리와 관련되는 별도의 정보를 포함한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 64, "content": "[51] 4개의 CV서브 피스를 발생하는 4개의 공식을 사용하는 것은 압축을 달성할 수 없음을 의미하는 것이 아니 다. 식별된 제일 짧은 범위를 선택하여 하나의 공식을 발생할 수 있는데 이 공식은 압축을 진행하도록 추가하고 자 하는 제4 값의 제일 짧은 범위를 나타낸다. 예하면 만약 [1]이 CC값, 즉 코드유닛의 최대값에 매우 근접하게 되면 CC에서 ([1]+[2])를 덜어내는 것은 단계 내지 단계에서의 앞의 3개의 공식을 처리하는 것을 통해 식 별한 제일 짧은 범위이고 다음 제3 공식을 [1]로 선택할 수 있으며 CC에서 ([1]+[2])를 덜어낸 범위 한정을 사 용하여 [1]의 값을 배치한다. 첸 코드 피스의 공식 디자인과 배치에 관하여 이 방면에서 진일보로 연구할 수 있 다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 65, "content": "[52] 4개의 CV서브 피스를 사용하더라도 처리유닛의 매 하나의 피스를 압축할 수 없을 수 있는데 상이한 유형의 데이터에 적용되어 분포한 상이한 공식 집합(각 데이터 값의 빈도와 대응되는 데이터 값 분포, 즉 존재하는 매 하나의 값의 빈도 및 존재하는 대응되는 값의 수량과 동일성)을 디자인할 수 있고 무작위 데이터의 모든 숫자를 파일에 입력하여 비무작위의 슈퍼 처리유닛으로 분해할 수 있다. 공식 디자인보다 더 간단한 기타 기술이 그 중 에 추가되어 실현될 경우 잠시 뒤에 비무작위의 슈퍼 처리유닛을 사용하는 기술을 설명하고자 한다. 이러한 토 론과정에서 슈퍼 처리유닛의 관련 개념을 개시한다. 상이한 데이터에 대해 분포한 슈퍼 처리유닛은 상이한 공식 디자인 그룹을 사용하는데 이러한 기타 기술과 슈퍼 처리유닛이 함께 사용되는 상황과 마찬가지로 재압축을 시 도하고 실현할 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 66, "content": "[53] 따라서 알 수 있다 시피 아주 간단한 첸 수학논리를 사용하는 것을 통해 상규적인 수학 처리와 보완 수학 을 포함하여 압축과 압축 해제 및 암호화와 복호화에 있어서 과학과 예술분야에서 이미 거대한 진보를 얻었다. PCT/IB2016/054562에서 공개하고 PCT/IB2016/054732에서 확인한 바와 같이 정보이론에서의 비둘기집원리의 신화 를 종결하기 위하여 기타 기술은 필요한 것이고 또 다음과 같이 개시된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 67, "content": "[54] 이러한 기술을 개시하기 전에 첸 프레임워크는 반드시 진일보로 미조정을 진행해야 한다. 현재까지 첸 프 레임워크의 특징은 아래의 구조특징에 있다. (a)코드유닛(내용코드와 분류 코드를 포함); (b)처리유닛; (c)슈퍼 처리유닛; (d)암호화되지 않은 코드유닛; (e)(전체 그룹의 숫자 데이터) 일부; (f)부분적 마스터헤드 또는 각주; (g)(전체 그룹의 숫자 데이터의) 주요 마스터헤드 또는 각주; 및 (h)첸 파일(첸 코드의 숫자 데이터파일을 포함하고 상기 (a) 내지 (g)의 숫자코드 조합 또는 단독으로 조성). 첸 프레임워크의 모드와 디자인은 그 어떤 상기 구조요소를 위해 선택한 정의인 바, 만약 사용하게 되면 상이한 실시형태에서 적합한 상황에서 조합하여 처리함으로써 인코딩과 디코딩이 본 발명에서 개시한 첸 코딩의 선택된 기술과 대응되는 특정된 숫자 데이터 집합의 목적에 사용된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 68, "content": "[55] 코드유닛은 첸 프레임워크의 기본유닛이다. 현재까지 이의크기, 즉 코드유닛 크기는 이진 비트수(비트 크 기)로 측량되고 상용 이진법 데이터 코더(데이터 코더, 특히 갖고 있는 고유 한 값이 동일한 비트 크기를 가지 고 본 발명이 개시하는 첸 프레임워크에서 디자인한 데이터 코더의 특징을 구비하지 않은 데이터 코더)에서 코 드유닛이 나타낼 수 있는 최대값 수량(코드내용)은 이로써 코드유닛의 비트 크기의 한정을 받는다. 예하면 코드 유닛의 크기가 1 비트만 가지면 그는 단지 두개의 값을 나타내는데 사용될 수 있고 구현예에서는 비트값 0 또는 비트값 1이다. 만약 코드유닛의 비트 크기가 3이면 그는 최대로 8비트값, 즉 000, 001, 010, 011, 100, 101, 110과 111을 나타낼 수 있다. 이는 이진 비트를 사용하여 데이터 값을 나타내는 상용적인 방식이다. 코드유닛은 데이터의 기본유닛으로서 인코더가 데이터 입력 스트림에서 하나씩 판독함으로써 인코딩 목적에 사용된다. 바로 이러한 상용적인 데이터 판독과 표시방식이 정보이론에서의 비둘기집원리의 신화를 만들었는 바, 상세한 내용은 아래 사이트를 참조할 수 있다. https://en.wikipedia.org/wiki/Pigeonhole_principle 이의 실질적인 내용은 다음과 같이 표달된다. \"수학방면에서 비둘기집원리는, n개의 물품이 m개의 용기에 놓여지고 n>m이면 적어도 하나의 용기는 하나 이상 의 물품을 반드시 포함한다고 규정한다\". 다시 말하면 만약 하나의 용기가 하나의 물품만 점용하면 용기가 점용한 물품의 수량이 용기 수량의 한정을 받 는 바, 즉 점용할 수 있는 물품의 수량이 물품을 점용하기 위한 용기의 수량을 초과할 수 없게 된다. 이는 물품 과 용기 사이의 일일이 대응되는 관계이다. 여기서 코드유닛의 용도를 응용하여 인코딩하는데 만약 코드유닛의 비트 크기가 3비트이면 이는 8개의 어드레스 만 제공할 수 있고 이로써 이는 최대 8개의 고유값을 나타내는데만 사용될 수 있으며 하나의 시간에 단지 하나 의 값만 가진다. 상용방식으로 코드유닛이 갖고 있는 어드레스 수량은 이진 비트 크기로 도량되어 코드유닛의 이진 비트수가 클 수록 코드유닛은 일일이 대응되는 관계로 나타내는 코드내용값의 어드레스가 더 많다. 따라서 코드유닛이 가지는 어드레스수는 2의(코드유닛의 비트 크기(이진 비트수), 즉 코드유닛 크기를 측량하는 이진 비트수)의 제곱이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 69, "content": "[56] 따라서 현재까지 압축을 진행하기 위한 인코딩은 가능한 것이였는 바, 이는 단지 인코딩 방법이 데이터 분 포의 불균일 성질을 가지기 때문이다. 비트 크기를 제공하는 코드유닛, 예하면 3비트의 코드유닛에 대하여 만약 데이터 입력 스트림이 3개의 상이한 고유 코드값, 예하면 000, 001과 100을 가지면 데이터 입력 스트림을 압축 할 수 있다. 또는 데이터 이력 스트림에 모든 8개의 상이한 고유 코득값, 즉 000, 001, 010、011, 100, 101, 110과 111을 포함하고 이 8개의 코드값의 빈도 분포가 불균일, 즉 이 8개의 고유 코드값의 빈도가 서로 상이하 면 이는 여전히 압축될 수 있다. 통상적으로 데이터 분포의 불균일성이 클 수록 실현 가능한 압축 절약은 더 많 다. 무작위 데이터는 숫자 비트0과 1 사이의 비율에서 균일한 경향을 가지고 그 중의 비트0과 비트1은 무작위방 식으로 나타난다. 즉 현재까지는 그 어떤 규율성 또는 예측 가능한 모드가 개시되지 않는다. 따라서 오랜 시간 동안 무작위 데이터는 압축할 수 없는 것으로 간주되어 정보이론에서의 비둘기집원리의 신화가 발생하였다. 그 러나 첸 프레임워크에서는 무작위 분포를 포함한 모든 유형의 숫자 데이터를 분포하는 방식을 설명하므로 무작 위 데이터의 더 많은 특징과 규율성을 조사하고 개시하여 개념을 인입하고 슈퍼 처리유닛을 사용하여 데이터 코 더와 함께 상이한 비트 크기와 기타 첸 코딩 기술을 사용하는 상황에서 고유 코드유닛 값을 수용하는 바, 예하 면 이상 인입 기술과 특히는 숫자 데이터 블랙홀 기술과 첸 프레임워크에서 절대 어드레스 분기 또는 어드레스 다중 분기 기술을 함께 사용하는 상황에서 오랜 시간동안 사람들이 믿고 있었던 이 신화는 까밝혀졌다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 70, "content": "[57]정보이론에서의 비둘기집원리는 매우 정확하지만 오직 그 자체만이 정확하다! 그러나 그의 신화는 무작위 데이터를 압축할 수 없거나 또는 데이터를 반복해서 재압축할 수 없는 이 원리와 관련되는 신화에 존재한다. 따 라서 신화를 종결짓기 위하여 하나의 가능한 방법은 무작위 데이터에서 불균일성을 창조하는 것이다. 불균일성 을 창조하는 기본기술은 코드유닛을 정의하고 측정하는 방법과 코드유닛을 표현하는데 사용되는 각각의 코드 값 을 미조정하는 방식을 통해 진행된다. 따라서 이는 본 발명의 중요한 신규 특징인 바, 첸 프레임워크에 사용되 는 코드유닛의 개념을 다시 정의하는 것은 첸 프레임워크, 코드유닛 및 그가 정의하는 아주 기본적인 요소에서 발견한 구조 변화 또는 개선이다. 이로써 무작위 데이터에서 분균일성을 용이하게 창조할 수 있다. 첸 프레임워 크의 이러한 구조변화를 효과적으로 이용함으로써 코드유닛이 응당 수용해야 할 값보다 더 많은 어드레스를 제 공하는 모드를 용이하게 디자인할 수 있다. 따라서 코드값을 나타낼 수 있는 코드 어드레스의 수량은 주기에서 무작위 데이터 집합을 압축하고 재압축하는 한정 요소가 아니다. 정보이론에서의 비둘기집원리가 빠뜨리고 소홀 히 한 것은 숫자 데이터 집합의 빈도 분포 특징이다. 주기에서 무작위 데이터 집합을 압축하고 재압축하기 위하 여 사람들은 데이터 집합에 존재하는 코드값의 빈도 분포 성질 및 코드값이 대응되는 비트 길이 두가지 방면을반드시 유의해야 한다. 이 두개의 문제는 이전에 주기에서 무작위 데이터 집합을 압축하고 재압축하는 인코딩과 디코딩방면의 노력을 패배시켰는 바, 상이한 고유 코드값이 사용 가능한 코드 어드레스의 수량 및 숫자 데이터 집합에 존재하는 상이한 고유 코드값의 빈도 분포와 같은 문제는 아래의 토론에서 일일이 해결할 것이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 71, "content": "[58]우선 데이터 집합에서의 상이한 고유 코드값이 사용 가능한 코드 어드레스 수량의 문제에 대하여 다시 정의 한 코드유닛의 신규 특징이 첸 프레임워크에 인입된 후 적합한 상황에서 코드 프레임워크에서의 코드유닛은 우 선 코드유닛이 나타내고 수용하는 상이한 고유 코드값의 최대 수량으로 측량되고 다음 전반적인 코드유닛의 이 진 비트수(각 고유 코드값에 영향을 주는 가능한 비트 크기)로 측량되며 또다시 코드유닛이 정의하는 헤드 디자 인으로 구별하는데 이는 아래의 단락[62]의 도표14에서 나타난다. 따라서 상이한 고유 코드값의 최대 수량을 제 1 또는 주요 요소로 하여 비트수가 아닌 코드유닛을 명명하거나 또는 표시(물론 한번에 하나씩)하도록 코드유닛 의 명명방식은 반드시 변화하여야 하므로 코드유닛의 명명을 3비트 코드유닛으로부터 8비트의 코드유닛(또는 Max8코드유닛)으로 변화하도록 지시하고 비트수는 이차적인 요소로서 코드유닛의 크기를 구별한다. 이 또한 코 드유닛의 모든 상이한 고유 코드값이 단지 동일한 비트 크기에 의해 표시되는 상용적인 정의를 제외하고 코드유 닛의 각 고유 코드값의 비트 크기도 상이할 수 있다. 또한 이 신규 특징은 사람들이 하나의 표준 비트값을 사 용하여 모드를 다지인하여 코드유닛의 모든 코드값을 위해 사용되는 것을 방애하지 않고 이 상용적인 정의를 제 외하고 그는 상이한 비트값을 사용하여 모드 디자인으로 사용하는 기회를 제공함으로써 코드유닛의 상이한 고유 코드값으로 하여금 상이한 비트값을 사용하도록 한다. 이는 코드유닛의 상이한 고유 코드값이 상이한 비트값 크 기를 가진다는 것을 의미하고, 이 외에 그는 비트값 크기에서 코드유닛의 매 하나의 고유 코드값을 위해 동일한 비트수를 제공하도록 허락되는데 이는 인코딩과 디코딩의 특정된 모드와 디자인에서 인코딩과 디코딩 과정에서 의 어느 한 시간에 사용한 코드값 정의와 관련 코드유닛 정의에 의해 결정된다. 예하면 8값 코드유닛에 대해 모 든 8개의 고유 코드값은 특정된 모드와 디자인에서 동일한 3비트의 비트 크기를 가질 수 있는 바, 예하면 도표 11에 나타낸 바와 같다. 도표11 동일한 비트 크기를 가지는 8값 코드유닛의 코드값의 정의 Max8클라스 24비트 그룹 코드값 비트수 000 3 001 3 010 3 011 3 100 3 101 3 110 3 111 3 또는 다른 한 특정된 모드와 디자인에서 코드유닛의 이 8개의 값은 상이한 비트수 크기를 가지는 것으로 다시 정의될 수 있는 바, 도표12에 나타낸 바와 같다. 도표12 상이한 비트수 크기를 가지는 8값 코드유닛의 코드값의 정의 Max8클라스 35비트 그룹 코드값 비트수 0 1 10 2 110 3 1110 4 11110 5 111110 6 1111110 7 1111111 7"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 72, "content": "[59] 따라서 첸 프레임워크에서의 코드유닛은 현재 다음과 같다: 우선 코드유닛이 수용 또는 표시하는 고유 코 드값의 최대 수량을 통해 측정하되, 코드유닛의 이진 비트수는 크기를 측정하기 위한 이차적인 요소로 된다. 따 라서 코드유닛의 코드값은 동일한 비트 크기 또는 상이한 비트 크기를 가질 수 있는데 이러한 옵션은 인코딩과 디코딩을 위한 특정 모드와 디자인에서 어떻게 정의되는가에 의해 결정된다. 첸 코딩의 코드 조절 기술을 통해 이러한 코드값 정의 또는 코드유닛 정의도 인코딩과 디코딩 과정에서 필요하고 적합할 때 변화될 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 73, "content": "[60] 첸 프레임워크에서의 코드유닛 정의와 코드값 정의를 사용하는 이러한 신규 특징을 통해 무작위 데이터를 포함하는 데이터 분포에서 불균일성이 발생하는 기술을 용이하게 디자인할 수 있다. 무작위 데이터의 성질도 연 구할 수 있고 코드값 및 이가 특정된 숫자 데이터 입력 스트림에서 발생한 관련 빈도에 근거하여 데이터 분포의 방식을 설명하는 것을 허용함으로써 적합한 기술을 인코딩과 디코딩에 사용하여 압축/압축 해제와 같은 목적을 달성할 수 있다. 임의의 특정된 데이터 집합이 불균일성을 창조하는 기술을 데모하기 전에 여기서 3값 코드유닛 에 사용되는 모드와 디자인을 소개함으로써 정보이론에서의 비둘기집원리의 신화를 종결, 즉 코드 어드레스의 수량이 고유 코드값의 수량을 초과하지 않도록 한다. 코드유닛 크기가 비트 크기에 근거하여 측정될 경우 코드 어드레스의 수량은 고유 코드값의 수량, 예하면 1비트 코드유닛, 2비트 코드유닛 등등을 초과하지 않는다. 코드 유닛이 디자인되어 수용하는 코드값의 최대 수에 근거하여 코드유닛을 측정할 경우 상황은 이렇지 않다. 이진 비트수에 근거하여 코드유닛을 측정하는 상용 방법은 하나의 한정을 제출하였는 바, 즉 코드유닛이 수용할 수 있는 코드값의 수량은 코드유닛의 이진 비트의 수량에 의해 결정되는데, 예하면 3비트의 코드유닛은 제일 많아 8개의 고유 코드값을 저장할 수 있고 매 하나의 코드값은 딱 3개의 비트를 이용하여 나타낸다. 3개의 코드유닛 은 8개를 초과하는 코유 코드값을 수용할 수 없다. 또한 이러한 상용적인 정의를 사용하여 데이터를 판독할 경 우 만약 인코더 또는 디코더가 존재하면 인코더 또는 디코더는 모든 8개의 고유 코드값을 판독하는 것을 피하지 못할 수 있는데 이는 인코더 또는 디코더가 단지 3개의 고유 코드값만 판독하지 못할 수 있음을 의미하고 만약 기타 5개의 고유 코드값이 데이터 집합에 존재하면 이를 소홀히 하거나 버릴 수 있다. 이는 상용적인 코드유닛 의 정의를 사용함으로써 관련되는 인코더는 항상 동일한 비트 길이 또는 비트 크기의 코드값을 사용하여 데이터 집합을 처리하되 상기 비트 길이 또는 비트 크기는 코드유닛 정의에서 사용되는 비트 크기보다 짧거나 길지 않 음을 의미한다. 첸 프레임워크에서는 이러한 한정을 제거한다. 따라서 데이터를 판독하고 해석하는 상용 디자인 에서 사용 가능한 코드 어드레스 수량은 코드유닛이 디자인되어 수용하는 코드값의 수량과 완전히 동일하다. 따 라서 만약 모든 고유 코드값이 데이터 집합에 나타나게 되면 모든 코드 어드레스는 모두 사용되어 데이터 집합 에 존재하는 코드값의 빈도 분포의 불균일성의 기술만을 이용하여 무작위 데이터 집합을 압축할 수 없을 수 있 고, 무작위 데이터 집합에 대하여 데이터 집합의 모든 코드값의 이러한 빈도 분포는 균일한 것으로, 즉 전반적 인 데이터 집합의 비트0과 비트1 사이의 비율은 1 대 1이며 코드유닛의 모든 코드값의 빈도는 대체적으로 동일 하다. 따라서 현재까지 디자인한 선행기술은 데이터 집합에 존재하는 고유 코드값의 수량보다 많은 사용 가능한 코드 어드레스를 제외(모든 고유 코드값도 무작위 데이터 집합에 나타남)하고 무작위 데이터 집합의 코드유닛의 코드값의 빈도 분포의 불균일성을 이용하여 압축하지 않았다. 도표13은 첸 프레임워크에 방금 인입한 신규 특성 (즉 코드유닛이 최대 코드값 수량에 의해 측정되고 이진 비트수가 전반적으로 코드유닛의 보조 측정에 사용됨) 의 3값 코드유닛, Max3코드유닛을 사용한 디자인을 나타낸다. 도표13 2개의 번전에서 5개 비트의 3값 코드유닛의 코드값을 사용하여 정의하되 하나의 비트가 구비하는 비트0과 비트1 의 비율은 2:3이고 다른 하나는 3:2이다. Max3클라스 5비트 그룹 0헤드 디자인 1헤드 디자인 2:3(비트0:비트1 비율) 3:2(비트0:비트1 비율) 0 1 10 01 11 00"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 74, "content": "[61] 이 두개의 버전의 3값 코드유닛 정의의 디자인은, 코드유닛을 위해 더 많은 수량의 코드 어드레스를 창조 할 수 있고 그가 가질 수 있게 디자인된 상이한 고유 코드값의 수량보다 많아 데이터 집합에서 나타나는 고유값 의 수량보다 많은 어드레스를 제공함을 설명한다. 3개의 3값 코드유닛으로 조성된 처리유닛을 사용한 모드가 숫 자 데이터 입력 스트림에 대해 인코딩과 디코딩을 진행하여 데이터 압축을 진행하도록 디자인된다고 가정한다. 상기 디자인에서 숫자 데이터 입력 스트림의 코드유닛을 하나씩 판독하고 0 헤드 디자인의 정의를 사용하여 3개 의 인접한 코드유닛을 하나의 유닛인 처리유닛으로 암호화(또는 해독하여 다음에 복구)하며; 인코딩 또는 디코 딩의 작용은 0헤드 디자인의 코드유닛 정의를 판독기로 3개의 3값 코드유닛을 판독(하나씩 3개를 판독)하고 그 다음 3개의 코드유닛의 코드를 하나의 코드 피스(하나의 처리유닛의 코드)로 하여 다른 한 코드 피스를 이용하 여 이에 대해 변화를 진행하는 바, 예하면 1헤드 디자인의 코드유닛 정의를 이용하여 판독기로 암호화 할 경우 이에 대해 인코딩 또는 기입하거나; 또는 1헤드 디자인 코드유닛 정의를 이용하여 암호화된 코드를 판독하고 또 0헤드 디자인 코드유닛 정의를 이용하여 이를 기입하여 디코딩할 경우 이를 원본 코드로 복구하거나; 또는 기타 디자인의 매핑 테이블을 이용하여 인코딩과 디코딩을 진행한다. 여기서 사용한 코드유닛에 3개의 고유의 코드값 이 존재하므로 처리유닛은 제일 많아 27개의 고유값(3개의 값에 3개의 코드유닛을 곱하면 27개의 고유값과 같음)을 수용하여 나타내도록 디자인된다. 아래의 수학공식을 사용하여 사용 가능한 어드레스수를 계산할 수 있 다. 2의 (코드유닛의 코드값의 평균 비트 크기*처리유닛의 코드유닛수)제곱 따라서 0헤드 디자인을 사용한 3개의 3값 코드유닛이 조성한 처리유닛이 사용 가능한 어드레스 수량은, 2의 (5비트/3값*3유닛)제곱=2의 5제곱=32 27개의 고유값이 사용 가능한 32개의 고유 어드레스가 존재한다. 이는 정보이론에서의 비둘기집원리의 신화를 종결짓는 제1표지이다. 이러한 디자인을 사용함으로써 반드시 나타내야 할 고유값의 수량보다 더 많은 어드레스 가 존재할 수 있다. 따라서 사람들은 27개의 상이한 고유값이 사용하는 5비트값을 4비트값 또는 5비트값으로 절 감할 수 있다[예하면 절대 어드레스 단일 분기를 사용함으로써 4비트의 값의 범위는 16(비교적 낮은 값의 범 위)이고 5비트의 값의 범위는 32(비교적 높은 값의 범위)이며 이 처리유닛의 실제 값의 범위는 27(실제 값의 범 위)이므로 27-16=11이고 11개의 값이 반드시 4비트 범위내의 단일 분기에 존재해야 하는 바, 4비트를 이용하는 5값 어드레스와 5비트를 이용하는 22값 어드레스가 존재한다]. 따라서 일부 비트의 절약을 실현하였다. 다른 한 디자인에서는 27개의 고유 어드레스위에 1개 또는 2개 또는 더 많은 어드레스(제일 많아 5개)를 보류하여 진행 하고자 하는 특수 처리를 지시하기 위한 특수 어드레스로 사용하도록 한다. 예하면 암호화된 코드에 존재할 경 우 28번째 어드레스는 아래의 두개의 처리유닛을 지시하여 제일 마지막 하나의 처리유닛과 동일한 데이터 값을 포함하도록 하여 이로써 동일하게 암호화된 코드를 포함하도록 한다. 이러한 방식으로 그는 데이터를 인코딩과 디코딩하여 압축하는 것과 암호화를 진행하는데 더 많은 영활성을 제공한다. 만약 28개의 어드레스, 즉 27개의 고유값 어드레스와 1개의 특수 처리 어드레스를 사용하면 4개 비트를 사용하는 4개의 어드레스[16-12(단일 분기 에 사용하도록 보류)=4] 및 5개 비트를 사용하는 24개의 어드레스[(28-16=12)*2=24]가 존재한다. 잠시 뒤에 증 거를 제공하고 어떻게 무작위 데이터 집합을 압축할 것인가를 제공하는 구현예에서 3개의 3값 코드유닛의 처리 유닛 및 상응하는 인코딩과 디코딩 과정의 이러한 모드와 디자인의 용도를 설명한다. 현재에는 우선 특정된 데 이터 집합에서 불균일성을 창조하는 기술을 토론하면 아래와 같다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 75, "content": "[62]데이터 집합의 비트0과 비트1 사이의 비율을 변화하여 불균일성을 상응하는 데이터 분포에 셋업함으로써 압 축의 목적을 진행하는 기술을 이해하고자 아래에서는 상이한 코드값 정의를 가지는 6값 코드유닛의 도표14에서 코드값 정의와 코드유닛 정의의 더 많은 구현예를 표시한다. 도표14a 20비트(Max6클라스20비트 그룹)의 6값 코드유닛의 코드값의 정의: 1개의 다중 분기는 2개의 버전을 구비하고 1 개의 버전이 구비하는 비트0과 비트1의 비율은 5:15이며 다른 하나는 15:5이다. Max6클라스 20비트 그룹 0헤드 디자인 1헤드 디자인 5:15(비트0:비트1 비율) 15:5(비트0:비트1 비율) 0 1 10 01 110 001 1110 0001 11110 00001 11111 00000 도표14b 16비트(Max6클라스16비트 그룹)의 6값 코드유닛의 코드값의 정의: 3쌍의 단일 분기는 2개의 버전을 구비하고 1 개의 버전이 구비하는 비트0과 비트1의 비율은 7:9이며 다른 하나는 9:7이다(비대칭 분포). Max6클라스 16비트 그룹 0헤드 디자인 1헤드 디자인 7:9(비트0:비트1 비율) 9:7(비트0:비트1 비율) 00 11 01 10 100 011 101 010 110 001 111 000 도표14c 16비트(Max6클라스16비트 그룹)의 6값 코드유닛의 코드값의 정의: 2쌍의 비대칭이 없는 단일 분기는 2개의 비대 칭이 없는 버전을 구비하고 이러한 버전은 동등한 비트0과 비트1의 비율을 가지며 비트0과 비트1의 비율은 모두 8:8이다(비대칭 분포). Max6클라스 16비트 그룹 2개의 0헤드 디자인 3개의 0헤드 디자인 8:8(비트0:비트1 비율) 8:8(비트0:비트1 비율) 00 000 11 001 010 01 011 10 101 110 100 111 도표14d 17비트(Max6클라스17비트 그룹)의 6값 코드유닛의 코드값의 정의: 1쌍의 단일 분기와 1개의 다중 분기는 2개의 버전을 구비하는데 한 버전이 구비하는 비트0과 비트1의 비율은 6:11이고 다른 하나는 11:6이다(비대칭 분포). Max6클라스 17비트 그룹 0헤드 디자인 1헤드 디자인 6:11(비트0:비트1 비율) 11:6(비트0:비트1 비율) 00 11 01 10 10 01 110 001 1110 0001 1111 0000 도표14e 18비트(Max6클라스18비트 그룹)의 6값 코드유닛의 코드값의 정의: 1쌍의 단일 분기와 1개의 다중분기는 2개의 버전을 구비하는데 한 버전이 구비하는 비트0과 비트1의 비율은 6:12이고 다른 하는 12:6이다(비대칭 분포). Max6클라스 18비트 그룹 0헤드 디자인 1헤드 디자인 6:12(비트0:비트1 비율) 12:6(비트0:비트1 비율) 0 1 100 011 101 010 110 001 1110 0001 1111 0000 도표14f 19비트(Max6클라스19비트 그룹)의 6값 코드유닛의 코드값의 정의: 2쌍의 단일 분기는 2개의 버전을 구비하는데 한 버전이 구비하는 비트0과 비트1의 비율은 6:13이고 다른 하는 13:6이다. Max6클라스 19비트 그룹 0헤드 디자인 1헤드 디자인 6:13(비트0:비트1 비율) 13:6(비트0:비트1 비율) 0 1 10 01 1100 0011 1101 0010 1110 0001 1111 0000"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 76, "content": "[63] 도표14로부터 알 수 있다 시피 상이한 비트0과 비트1의 비율을 가지는 16비트 내지 20비트를 사용함으로써 6값 코드유닛에 대해 1개 이상의 정의가 존재할 수 있다. 따라서 코드유닛은 주요하게 그가 갖고 있는 고유 데 이터 값의 최대 수에 의해 분류될 수 있고 다음 비트 크기의 수량에 의해 분류될 수 있으며 그 다음 0헤드 또는 1헤드의 헤드 디자인의 버전에 의해 분류될 수 있다. 이를 숫자 데이터 집합의 특성 또는 특징의 언어(첸 프레 임워크 언어, 본 발명에서 개시한 바와 같이 첸 프레임워크의 구조요소 및 첸 코딩 기술의 특성 또는 특징을 설 명하기 위한 용어)를 설명하기 위한 기본유닛으로 사용하는 외에 코드유닛을 정의하는 이러한 모드는 코드유닛 을 숫자 데이터를 조작하는 기본유닛으로 사용하도록 허락하는 경우에 아주 큰 영활성을 갖는다. 이는 단지 비 트 크기에 근거하여 코드유닛을 정의하는 상용적인 방법과는 다른 바, 상용적인 방법에서는 어느 한 비트 크기 의 코드유닛은 1개의 번전의 코드 정의만 가질 수 있는데 여기서 나타내고자 하는 고유값의 최대 수량(예하면 상용적인 방식으로 정의한 3비트의 코드유닛에 대해 8개의 고유값으로 나타내는 바, 사람들은 8가지의 가능한 조합에서의 6개의 고유값만 나타내고 기타 두개의 고유값을 소홀히 하여 그들이 처분되거나 처리되지 않도록 할 수 없는 바, 즉 그들이 사용적인 방식으로 정의한 3비트 코드유닛의 데이터 집합에 출현할 경우 사람들은 6개의 고유값만 처리하고 기타 두개의 고유값을 처리하지 않을 수 없다)은 변화되지 않을 수 있고 헤드 디자인도 변화 되지 않을 수 있으며; 첸 프레임워크에서의 코드가 모드를 정의함에 있어서 코드유닛 정의가 수많은 상이한 버 전의 정의, 코드유닛의 전체 비트 크기 변화, 코드유닛 값의 비트 크기 변화, 코드유닛이 디자인되어 수용한 고 유값의 수량 변화 및 0헤드 또는 1헤드 디자인 변화를 가지는 것을 허용한다. 6값 코드유닛의 매 한가지 상이한 디자인 유형에 대하여 상이한 모드와 코드값의 정의 사이의 상기 차이점을 이 용하여 불균일성을 기존의 숫자 데이터 집합에 셋업하는 바, 예하면 비트0과 비트1의 비율을 변화하는 것이다. 예하면 도표14c에서는 16비트 6값 코드유닛의 2개의 비대칭이 없는 버전(즉 0헤드 디자인과 1헤드 디자인)을 제 공하였다. 특별히 설명되지 않은 한 0헤드 디자인 버전은 아래의 토론에 사용된다. 도표14b에서의 대응되는 3쌍 의 비대칭 단일 분기 버전과 비교하면 비대칭이 없는 버전과 3쌍의 비대칭 단일 분기 버전은 모두 16개 비트를 사용하여 6값 코드유닛의 6개의 고유값을 표시하고; 그들의 구별점은 단지 사용하는 비트 코드의 모드 및 비트0 과 비트1 사이의 비율이 상이한 것인 바, 여기서 비대칭이 없는 버전의 비율은 8:8이고 3쌍의 비대칭 단일 분기 버전은 7:9이다. 따라서 이 두 그룹의 6개의 코드값 사이에서 교차적으로 매핑함으로써 비대칭이 없는 버전의 비트1의 수량을 증가하여 매핑 전환 후의 새로운 데이터 집합의 비트0과 비트1의 비율이 8:8에서 7:9로 전환하 도록 할 수 있다. 그러나 일부 시험을 진행한 후 한차례의 인코딩전환을 이용하여 무작위 데이터 집합의 상기 비율의 변화에 사용하는 것은 가능한 것이지만 상대적으로 비교적 작다는 것을 발견할 수 있다. 이는 무작위 데 이터 집합에서 찾든 6개의 고유 코드값의 빈도 분포의 성직에 의해 결정된 것이다. 도표15는 2017년 2월 22일에 제출한 PCT출원PCT/IB2016/054732의 자동 프로그램을 작동하여 발생한 결과의 한 구현예(이러한 자동 프로그램 이 이미 우선권에 근거하여 본 PCT출원에 편성될 것을 요구하므로 사람들은 상기 PCT출원을 고려하여 그들에 대 한 액세스를 획득할 수 있으며 이로써 본 PCT출원에 편성되지 않을 것이다. 그러나 자동 프로그램 라이브러리와 함께 파일을 도와 그의 용도를 토론할 경우 무작위 데이터 집합으로 사용될 경우 압축될 최종 증거의 프로그램"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 77, "content": "을 열거할 수 있어 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자들로 하여금 어떻게 인코딩과 디코딩 을 진행하는 데이터 코더를 구성하여 첸 코드와 첸 파일을 형성할 경우 첸 코딩의 방법과 기술을 첸 프레임워크 의 실제 실현방식에 사용하여 암호화/복호화와 압축/압축 해제의 목적에 사용할 것인지를 알 수 있도록 함)를 고려하여 80,000개의 무작위 이진 비트를 사용한 것을 다음과 같이 제공하였다. 도표15 비대칭이 없는 버전의 3개의 0헤드 디자인의 6값 코드유닛의 6개의 고유 코드값의 빈도 분포 코드값 빈도 000 3995 001 4019 01 8074 10 7949 110 3980 111 3991"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 78, "content": "[64] 도표15는 단지 이러한 생성된 하나의 구현예일 뿐이다. 그를 생성하는 자동 프로그램을 한번 작동하게 되 면 하나의 이러한 구현예를 생성하게 되는데 매 하나의 구현예는 기타 구현예와 약간의 차이점이 있을 것이다. 그러나 일반적으로 6값 코드유닛의 빈도 분포의 이러한 구현예는 매번 관심을 보이는 6개의 고유 코드값에 대해 대략적으로 동일한 비율을 유지한다. 비대칭이 없는 버전의 코드값과 6값 코드유닛의 3쌍의 단일 분기 버전 사 이의 교차 매핑 및 관련 계산은 도표16에 나타낸 바와 같다. 도표16 비대칭이 없는 6개의 코드값과 6값 코드유닛의 3쌍의 단일 분기 버전 사이의 교차 매핑 비대칭이 없음 3쌍의 단일 분기 코드값 빈도 코드값 비트1를 더하거나 덜어냄 000 3995 101 3995*2를 더함=7990개의 비트1 001 4019 100 균등 01 8074 01 균등 10 7949 00 7949개의 비트1을 덜어냄 110 3980 110 균등 111 3991 111 균등 ======= 네트: 41개의 비트1을 더함 따라서 알 수 있다 시피 이러한 교차 매핑을 통해 비트1의 수량은 이미 80000개의 총 이진비트에서 41개 비트가 증가하였다. 이는 상대적으로 작은 숫자이다. 그러나 만약 비트1의 이러한 추세를 계속하여 증가하게 되면 데이 터 분포는 승수효과에서 비트1로 점점 향하게 된다. 비대칭이 클 수록 실현 가능한 압축 절약은 더 많다. 따라 서 더 많은 실험을 시도하여 코드유닛의 상이한 디자인의 코드값 사이의 교차 매핑의 패텅를 요해해야 한다. 이 러한 상황에서 비대칭이 없는 버전과 3쌍의 단일 분기 버전은 모드 16개 비트를 사용하고 매핑은 2비트값을 2비 트값에, 3비트값을 3비트값에 매핑하는 이러한 방식으로 완성(즉 서로 대응되는 코드유닛 값으 동일한 비트 크 기의 인코더를 사용)하므로 비트 사용은 변화가 존재하지 않으나 비트0과 비트1 비율은 약간의 변화만 존재한다. 그리고 모든 상기 버전의 6값 코드유닛의 디자인에 대하여 16비트 내지 20비트를 사용함으로써 매 하 나의 비트 크기로 하여금 대부분의 상황에서 확실하게 2개의 대응 버전(즉 0마스터헤드 디자인과 1마스터헤드 디자인)을 갖도록 한다. 따라서 하나의 인코딩 주기로부터 다른 하나의 인코딩 주기까지 이 두개의 버전의 코드 값 사이(또는 도표18에서의 한 버전 자체 사이)의 교차 매핑을 이용하여 총적인 비트 사용을 변화하는 것이 아 닌 데이터 집합에서의 비트0과 비트1 사이의 비율을 변화하는 목적에 사용된다. 제1 인코딩 주기가 도표16에서 나타내는 16비트의 두개의 버전 사이의 교차매핑을 사용한다고 가정할 경우 다음 한 주기는 20비트 버전을 사용 할 수 있고 제3 주기는 18비트 버전을 사용할 수 있으며 이와 같이 유추할 수 있다. 물론 이러한 교차 매핑을 진행하는 과정에서 응당 먼저 코드값을 판독하기 위한 빈도 분포를 찾아내고 제일 적당한 교차 매핑 테이블을 디자인하여 이 2개의 비트값 사이의 비트 비율에 근거하여 특정 비트(비트0 또는 비트1)의 증가하는 추세는 하 나의 인코딩 주기로부터 다른 한 인코딩 주기로 유지된다. 이 외에 동일한 비트 크기의 2개의 버전의 코드유닛 디자인 사이의 교차 매핑을 사용하여 이 목적을 달성할 수 있다. 도표 17에 나타낸 바와 같이 1개 버전의 코드 유닛 디자인 자체의 교차 매핑을 사용할 수도 있다. 도표17 비대칭이 없는 버전의 6값 코드유닛 자체의 6개의 코드값 사이의 교차 매핑 비대칭이 없음 마찬가지로 비대칭이 없음 코드값 빈도 코드값 비트1를 더하거나 덜어냄 000 3995 110 3995*2를 더함=7990개의 비트1 001 4019 111 4019*2를 더함=8038개의 비트1 01 8074 01 균등 10 7949 10 균등 110 3980 000 3980*2를 덜어냄=7960개의 비트1 111 3991 001 3991*2를 덜어냄=7982개의 비트1 ======= 네트: 86개의 비트1을 더함 알 수 있다 시피 임의의 코드유닛 디자인 자체의 코드값 사이의 교차 매핑을 사용하여도 비트0과 비트1 사이의 비율을 변화할 수 있다. 또한 도표17에서 나타낸 이러한 상황에서의 결과는 심지어 도표16에서의 2개 버전의 코 드유닛 디자인을 사용하여 변화한 결과보다 더 우수하다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 79, "content": "[65]이 외에 비트0과 비트1의 비율을 한쪽으로 편향하는 목적을 위해 이러한 교차 매핑은 6값 코드유닛 디자인 을 사용하여 완성할 수 있을 뿐만 아니라 상이한 인코딩 주기에서 임의의 X값 코드유닛에 대한 코드유닛 디자인 을 이용하여 완성할 수도 있다. 예하면 제1 주기는 6값 코드유닛 디자인을 사용하고 다음 주기는 12값 코드유닛 디자인을 사용하는 것 등일 수 있다. 편향하는 추세를 유지하기만 하면 된다. 따라서 데이터 분포 스펙트럼에서 의 비트0으로부터 비트1까지의 비율의 임의의 점으로부터 시작하는 임의의 특정된 데이터 집합에 대하여 비트0 과 비트1 사이의 비율을 변화할 수 있는 무궁무진한 기회가 존재한다. 또한 이러한 교차 매핑의 모드, 이러한 교차 매핑논리 및 이가 데이터 분포 스펙트럼에서의 비트0으로부터 비트1까지의 비율의 임의의 점으로부터 시작 된 데이터 집합이 따르는 경로를 찾고 기록하기만 하면 인코더와 디코더에 임베디드 할 수 있다. 또는 이러한 교차 매핑의 논리와 경로를 지정자로 하여 암호화된 코드의 마스터헤드에 배치함으로써 매 하나의 인코딩 주기 에 사용하여 잠시 뒤 디코딩할 경우에 정확하고 손상없이 원본 코드를 복구할 수 있다. 물론 인코더와 디코더에 서 코드값을 임베디드하는 교차 매핑의 이러한 논리와 경로는 비트를 진일보로 최소화하여 사용하는데 도움이 되고 인코딩을 압축하는 단계에서 압축하는 목적으로 사용된다. 따라서 총 비트수 수량을 변화하지 않고 사용하 는 상황에서 단독적인 동일한 코드유닛 디자인 또는 상이한 코드유닛 디자인을 사용한 코드값의 교차 매핑을 사 용함으로써 한차례 또는 여러 차례 데이터 집합에서의 비트0과 비트1 사이의 비율을 변화하여 데이터 분포를 변 화하여 하나의 중간 단계로 사용할 수 있어 데이터 집합에서 불균일성을 발생하는 목적으로 사용함으로써 기타 기술을 사용하여 압축하는 인코딩 단계에서 특정된 숫자 데이터 집합의 압축을 가능하도록 하거나 잠시 뒤에 증 강하도록 한다. 그리고 특정된 단계 또는 임의의 인코딩 주기에서 데이터 집합의 비트 크기를 변화하는 것은 중 요한 일이 아니며 제일 중요한 것은 최종적인 결과이다. 따라서 데이터 분포의 변화 및 읨의의 데이터 집합의 비트수의 사용은 항상 인코딩 단계와 관련된다. 이 계시의 신규 특징은 인코딩이 응당 이러한 방식으로 디자인, 즉 임의의 데이터 집합의 데이터 분포의 변화는 일반적으로 비트0과 비트1의 비율을 변화하는 것에 근거하여 하 나의 방향으로 편향됨으로서 데이터 압축의 목적에 사용되는 것이다. 코드유닛 정의는 판독기와 라이터로 사용 되여 숫자 데이터 집합의 비트0:비트1의 비율을 변화하는 외에 처리유닛 정의는 단락[115]와 도표55 및 단락"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 80, "content": "[116]과 도표56에 나타난 동일한 목적에 사용될 수도 있다. 이로써 결과는 더 우수하다. 따라서 더 큰 코드유닛 크기 또는 더 큰 처리유닛 크기를 사용함으로써 더 큰 차이점을 생성, 포획하고 발생하는 것을 특정된 데이터 집합의 데이터 분포에서의 불균일성으로 하는 것은 자명한 것이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 81, "content": "[66]따라서 비트0:비트1의 비율을 대체적으로 한 방향을 따라 편향(적합한 상황에서 어느 한 점에 도달)하도록 함으로써 임의의 데이터 집합의 데이터 분포의 중간 단계를 변화한 후 비트0:비트1의 점에서 이러한 분포된 데 이터 집합을 압축하는 기술을 사용하여 숫자 데이터 집합을 압축한다. 따라서 우선 압축을 위한 무작위 데이터 집합을 제공하면 이상의 단락[62] 내지 [64] 또는 아래의 단락[115]와 [116]에서 설명하는 기술을 사용하여 비 트0:비트1의 비율을 한 방향을 향해 편향하는 것으로 개변할 수 있고 그 다음 데이터 분포에 근거하여 코드값의 교차 매핑 기술을 이용하여 압축하며 현재 사용하는 것과 같은 구현에에서는 이번에 동일한 값 크기이지만 상이 한 비트 크기인 코그유닛의 코드값의 교차 매핑: 상이한 비트 크기위 6값 코드유닛, 예하면 20비트 크기의 6값 코드유닛(또는 적합한 상황에서 임의의 기타 비트 크기)을 사용하여 데이터 집합을 판독하고 이러한 코드값과19비트 크기(또는 적합한 상황에서 임의의 기타 비트 크기)의 6값 코드유닛의 이러한 코드값을 쿄차 매핑하여 인코딩의 목적에 사용하며 이는 처리 중의 데이터 집합의 코드값의 빈도 분포에 의해 결정된다. 간단히 말하면 코드값의 교차 매핑을 진행할 경우 비트0:비트1의 비율에 근거하여 데이터 분포를 변화하기 위하여 일일이 대응 되는 관계에 의해 동일한 비트값 크기의 데이터 값에 매핑되는 코드 어드레스의 동일한 X값 코드유닛을 사용; 그러나 데이터 압축을 진행하여 비트 사용을 절감하기 위하여 동일한 X값의 코드유닛을 사용하도록 전환해야 하 고 그들은 일일이 대응되게 매핑되는 관계를 구비하지만 데이터 값은 상이한 비트값 크기를 가진다. 그러나 이 는 상이한 코드값 크기를 가지는 코드유닛으로 비트수의 사용 및 일회적으로 비트0과 비트1의 비율을 변화하는 한가지 형식을 배제하지 않는다. 이는 마찬가지로 처리유닛을 이 목적에 사용하는 것에 적용된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 82, "content": "[67] 따라서 이상의 내용으로부터 알 수 있다 시피 수정을 거친 첸 프레임워크에서 코드유닛 크기는 현재 코드 값의 수량 및 도표14에서 제공하는 상이한 비트 크기를 가지는 6값 코드값의 구현예에서 나타내는 이진 비트의 수량에 의해 측량되고 데이터 집합의 기타 특징, 예하면 일정한 수량의 값과 일정한 비트 크기를 가지는 임의의 코드유닛이 정의하는 코드유닛의 고유 코드값의 비트0과 비트1의 비율에 사용되는 빈도 분포를 연구하고 발견할 수 있다. 이는 임의의 숫자 데이터 집합 및 임의의 목적을 위하여 적당한 인코딩과 디코딩 기술을 사용하는데 도움이 되며 데이터 암호화와 데이터 압축 및 원시적인 숫자 데이터의 정확하고 손상이 없는 복구를 진행하는 목적을 포함한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 83, "content": "[68] 코드유닛 크기의 정의의 변화에 따라 코드유닛은 코드유닛이 디자인되어 수용하는 코드의 수량과 코드유닛 을 하나의 전체적인 이진 비트로 사용하는 수량에 근거하여 측정되고 처리유닛(인코딩 또는 하나의 암호화된 코 드 피스를 기입하기 위한 유닛)은 1개의 코드유닛으로 조성되는 바, 도표14에 나타낸 바와 같이 동일한 코드값 수량을 가지는 코드유닛은 매 하나의 코드값과 코드유닛에 대해 전반적으로 상이한 비트 크기를 가지도록 디자 인된다. 따라서 코드유닛, 즉 기본 판독유닛은 기타 판독유닛과 조합하여 처리유닛, 즉 기본적인 기입/판독유닛 을 형성할 필요가 없이 그 자체가 단독으로 사용되어 인코딩 과정에서 암호화된 코드를 기입하고 디코딩과정에 서 다시 판독하는데 사용될 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 84, "content": "[69] 무작위 데이터는 장기적으로 압축이 불가능한 것으로 식별되어왔다. 지금은 상술한 첸 프레임워크를 이용 하여 데이터 집합에서의 비트0과 비트1의 비율을 변화하는 것을 사용하기에 적당한 시기이며 개시하고자 하는 기타 기술은 다음과 같다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 85, "content": "[70] 이러한 기타 기술은 첸 프레임워크에서의 첸 코딩에서 사용하는 코딩기술로 분류될 수 있다. 코드유닛의 특성 또는 특징(하나이든 조합이든 관계 없음)을 식별하고 조합하여 첸 코드의 분류 코드를 발생하는 것이 바로 이러한 기술인 바 예하면 코드유닛의 랭크와 자리를 이용하여 RP코드를 발생하거나 또는 코드유닛의 코드값(하 나 또는 조합)을 설명하는 수학공식을 사용하고 인코딩과 디코딩의 목적에 더 사용되는 바, 예하면 첸 코드의 내용값 코드인 CV서브 피스를 창조하는데 사용된다. 따라서 첸 프레임워크에서 첸 코드의 기본적인 부분(코드유 닛의 특성 또는 특징을 설명하는 부분)은 분류 코드와 내용값 코드(또는 내용코드라고 약칭함)로 분류될 수 있 다. 첸 코드에 속하는 것으로 간주되는 기타 부분은 기타 식별코드 또는 지정자(예하면 첸 코드파일에서의 메인 마스터헤드 또는 숫자 데이터파일의 일부 부분적 마스터헤드에 포함됨)를 포함하고 상기 식별코드 또는 지정자 는 인코딩과 디코딩을 위한 첸 코드의 기본부분의 교차 매핑 테이블(매핑 테이블 지정자), 특정된 숫자 데이터 에 대해 입력한 인코딩과 디코딩을 진행하는 주기수(주기 지정자의 수량), 첸 코드파일에 대해 계산한 검사 합 계(검사 합계 지정자), 임의의 특정된 인코딩과 디코딩 주기에 사용되는 숫자 데이터의 암호화되지 않은 코드유 닛(만약 존재하면) 및 적당하고 필요한 상황에서 첸 코드를 표시 및 인코딩과 디코딩을 진행하는 목적으로 디자 이너가 디자인한 기타 지정자를 표시하기 위한 것이다. 예하면 하나의 이러한 지정자는 인코딩과 디코딩을 위한 슈퍼 처리유닛의 처리유닛의 수량을 구성할 수 있고; 기타는 적합하고 필요한 상황에서 빈도를 통해 첸 코드의 분류 코드의 지정자를 조절하고 빈도를 통해 첸 코드의 내용코드의 지정자를 조절(즉분류 코드와 내용코드를 사 용하는 0헤드 또는 1헤드를 적합한 상황에서 처리 중의 데이터 집합의 비트0:비트1 비율의 모드에서의 빈도 지 정자로 디자인 하고 빈도 지정자로 약칭함)할 수 있다. 슈퍼 처리유닛의 개념과 사용방법 및 빈도를 통한 첸 코 드의 조절도 잠시 뒤에 개시한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 86, "content": "[71]상기 토론에서 이미 여러 곳에서 첸 코드에 사용된 한가지 기본기능, 즉 절대 어드레스 분기를 토론하였다. 상기 기술이 어떻게 무작위 데이터 집합을 압축하는지, 즉 전반 무작위 데이터 집합의 비트 저장 사용을 절감하 는지에 대해 상세히 설명할 필요가 있다. 코드 어드레스의 수량과 코드값의 수량 사이의 관계의 문제를 토론할 경우 단락[60]과 [61]에서 이러한 사용방법을 간단히 소개하였다. 여러분의 기억을 재생하기 위하여 상기 토론 에서는 3개의 3값 코드유닛으로 조성된 처리유닛은 코드 어드레스의 수량이 인코딩과 디코딩을 위한 처리유닛이 디자인되어 수용하는 코드값의 수량보다 많을 수 있다는 것을 개시하도록 한다. 이는 코드유닛의 새로운 정의에의해 실현되어 코드유닛의 크기를 코드유닛이 수용한 코드값의 수량과 코드유닛의 상이한 고유 코드값의 비트수 및 전반 코드유닛의 비트수에 의해 측량되도록 할 수 있다. 이러한 특징은 도표14에 나타낸 바와 같이 6값 코드 유닛의 상이한 디자인과 정의를 사용한다. 또한 절대 어드레스 분기 기술을 사용하므로 이러한 특징을 실현할 수도 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 87, "content": "[72] 상기 토론에서는 처리유닛의 27개의 고유 코드값이 어떻게 코드 어드레스로 나타내고 일부 예비 어드레스 를 특수 처리 어드레스로 하여 인코딩과 디코딩을 진행하는 목적에 사용하는 것을 건단히 소개하였다. 예하면 하나의 다자인에서 27개의 고유 코드값은 5개의 4비트 기본 어드레스와 22개의 5비트 단일 분기 어드레서로 나 타낼 수 있다. 따라서 아래의 구현예는 코드값이 어떻게 코드 어드레스로 교차 매핑되는지를 설명하였다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 88, "content": "[73] 도표18 27개 값의 절대 어드레스 분기를 분류하는 코드표(CAABCT) 실시예I 분류PU 첸 코드에서의 비트 표시, 클라스비트, 정상비트와 분기비트를 포함 서열 클라스(클라스비트 정상비트 분기비트) 비트 크기 번호 번호(첸 코드) 1 0 0 000 4 2 0 0 001 4 3 0 0 010 4 4 0 0 011 4 5 0 0 100 4 6 0 0 101 0 5 7 0 0 101 1 5 8 0 0 110 0 5 9 0 0 110 1 5 10 0 0 111 0 5 11 0 0 111 1 5 12 1 1 000 0 5 13 1 1 000 1 5 14 1 1 001 0 5 15 1 1 001 1 5 16 1 1 010 0 5 17 1 1 010 1 5 18 1 1 011 0 5 19 1 1 011 1 5 20 1 1 100 0 5 21 1 1 100 1 5 22 1 1 101 0 5 23 1 1 101 1 5 24 1 1 110 0 5 25 1 1 110 1 5 26 1 1 111 0 5 27 1 1 111 1 5 합계: 130비트 이상의 절대 어드레스 분기를 분류하는 코드표(CAABCT)를 사용한 실시예I를 통해 처리유닛의 3개의 3값 코드유 닛의 27개의 코드값은 첸 코드에 하나씩 교차 매핑될 수 있고 클라스비트(분류 코드) 및 정상비트와 분기비트 (내용코드)를 포함한다. 그러나 CAABCT를 사용하는 이 버전의 실시예I를 통해 무작위 데이터의 빈도 분포로 인 하여 무작위 데이터 집합을 압축할 수 없을 수 있다. 그러나 이는 숫자 데이터 집합을 압축할 수 있는데 상기 숫자 데이터 집합의 모든 27개의 고유 코드값의 빈도는 대체적으로 동일하거나 또는 대체적으로 균일하게 모든 27개의 고유 코드값에 존재한다(예하면 만약 특정된 데이터 집합에서의 모든 27개의 고유 코드값의 빈도가 1이 면 모든 27개의 고유 코드값은 아래 도표20에 나타낸 바와 같이 함께 총 135개의 비트를 사용하고 만약 그가 이 상의 도표18에서의 도합 130개의 비트만 사용하는 코드 어드레스와 교차 매핑되면 응당 9개의 비트 압축이 절약 된다). 따라서 중요한 코드 어드레스의 수량뿐만 아니라 고유 코드값의 빈도 분포도 무작위 데이터 집합을 압축 하는 시도에서 다른 한 장애가 존재하는 바, 아래에는 상기 문제를 해결하고자 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 89, "content": "[74] 도표19에 나타낸 3값 코드유닛의 정의의 성질로 인하여 코드유닛의 비트0:비트1의 비율은 2:3이고 3개의 3 값 코드유닛의 처리유닛의 27개의 코드값의 빈도 분포는 균일한 분포가 아니며 이는 도표20에 나타낸 바와 같다. 도표19 3값 코드유닛 정의: 0헤드 디자인 여기서 비트0:비트1 비율=2:3 코드값 번호 코드값 코드 1 0 2 10 3 11 도표20 3개의 3값 코드유닛으로 조성된 처리유닛의 도표19에서의 코드유닛이 정의하는 80,000비트의 무작위 데이터 집 합이 판독한 27개의 고유 코드값의 분류하지 않은 빈도 분포의 구현예 처리유닛 코드값 사용한 비트 빈도 코드(분류하지 않음) 분류하지 않음 서열번호 코드유닛1 코드유닛2 코드유닛3 1 0 0 0 3 2155 2 0 0 10 4 1101 3 0 0 11 4 1154 4 0 10 0 4 1078 5 0 10 10 5 587 6 0 10 11 5 506 7 0 11 0 4 1132 8 0 11 10 5 558 9 0 11 11 5 605 10 10 0 0 4 1074 11 10 0 10 5 574 12 10 0 11 5 566 13 10 10 0 5 552 14 10 10 10 6 279 15 10 10 11 6 290 16 10 11 0 5 564 17 10 11 10 6 263 18 10 11 11 6 292 19 11 0 0 4 1143 20 11 0 10 5 566 21 11 0 11 5 530 22 11 10 0 5 563 23 11 10 10 6 304 24 11 10 11 6 253 25 11 11 0 5 527 26 11 11 10 6 277 27 11 11 11 6 262 합계: 135비트"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 90, "content": "[75] 다른 한 자동 프로그램을 통해 도표20에서의 빈도 숫자를 생성하고 도표21에서 결과를 나열한다. 도표21 도표20의 프로그램을 생성하여 발생한 다른 한 결과 0-0-0 : 2273 0-0-10 : 1175 0-0-11 : 1149 0-10-0 : 1123 0-10-10 : 531 0-10-11 : 593 0-11-0 : 1060 0-11-10 : 548 0-11-11 : 542 10-0-0 : 1045 10-0-10 : 542 10-0-11 : 576 10-10-0 : 551 10-10-10 : 276 10-10-11 : 288 10-11-0 : 559 10-11-10 : 266 10-11-11 : 294 11-0-0 : 1072 11-0-10 : 508 11-0-11 : 561 11-10-0 : 540 11-10-10 : 277 11-10-11 : 279 11-11-0 : 591 11-11-10 : 262 11-11-11 : 304 빈도: 2273 1175 1149 1123 1072 1060 1045 593 591 576 561 559 551 548 542 542 540 531 508 304 294 288 279 277 276 266 262 원시적인 것: 80001 표1 크기: 82133 표2a 크기: 80001 표2b 크기: 84373 표3 크기: 81444 알 수 있다 시피 본 구현예에서 사용한 3개의 3값 코드유닛의 처리유닛의 27개의 고유 코드값의 빈도 분포와 도 표20에서 나열한 하ㅏ와 유사하거나 비례한다. 표1의 크기는 도표21의 27개의 고유 코드값 사이의 교차 매핑이 발생한 비트 크기이고 상기 코드값은 비트의 사용으로 분류(이러한 27개의 고유 코드값의 분류는 아래 단락[7 8]에서의 도표23에서 나열)하며 절대 어드레스 분기를 분류하는 코드표(CAABCT)에서 찾아낸 27개의 고유 코드는 단락[73]의 도표18에서 나열한 실시예I에서 사용한 27개의 값에 사용된다. 도표21에서의 표2a의 크기는 다른 한 CAABCT의 교차 매핑을 사용한 결과로서 아래 도표22에서의 실시예II에서 발견한 바와 같다. 도표22 27개 값의 절대 어드레스 분기를 분류하는 코드표(CAABCT) 실시예II 분류PU 첸 코드에서의 비트 표시, 클라스비트, 정상비트와 분기비트를 포함 서열 클라스(클라스비트 정상비트 분기비트) 비트 크기 번호 번호(첸 코드) 1 0 0 00 3 2 0 0 01 0 4 3 0 0 01 1 4 4 0 0 10 0 4 5 0 0 10 1 4 6 0 0 11 0 4 7 0 0 11 1 4 8 1 1 0000 5 9 1 1 0001 5 10 1 1 0010 5 11 1 1 0011 5 12 1 1 0100 5 13 1 1 0101 5 14 1 1 0110 5 15 1 1 0111 5 16 1 1 1000 5 17 1 1 1001 5 18 1 1 1010 5 19 1 1 1011 5 20 1 1 1100 0 6 21 1 1 1100 1 6 22 1 1 1101 0 6 23 1 1 1101 1 6 24 1 1 1110 0 6 25 1 1 1110 1 6 26 1 1 1111 0 6 27 1 1 1111 1 6 합계: 135비트 알 수 있다 시피 이상의 실시예II에서 이의 27개의 고유 테이블 코드에 동일한 비트를 사용할 경우 처리유닛을 구성하는 3개의 코드유닛의 3값 코드유닛의 0헤드 디자인(값1=0, 값2=10, 값3=11임)을 사용하여 판독한 데이터 집합에서 발생한 27개의 고유 코드값(비트의 사용으로 분류함)에서 사용한 것이면 비트 사용 결과는 도표21에서 생성하고 나열한 원시적인 무작위 데이터 집합의 구현예와 동일하다. 도표21에서 생성하고 나열한 0헤드 디자인 을 사용한 3값 코드유닛의 상기 3항이 판독한 무작위 데이터 집합은 80001개의 비트를 점용하고 실시예II에서의 CAABCT(도표23에서의 표2a)의 테이블 코드의 교차 매핑을 사용하여 판독한 상기 무작위 데이터 집합을 인코딩하 는 비트의 사용은 이로써 동일한 바, 80001개의 비트이다. 실시예II에서의 CAABCT는 그가 갖고 있는 27개의 고 유 테이블 코드에 135개의 비트(매 하나의 표 코드를 한번 계산)를 사용하고 실시예I에서의 CAABCT에서는 단지 130개의 비트만 사용한다. 그러나 무작위 데이터 집합에서의 27개의 고유 코드값의 불균일 빈도 분포(이러한 불 균일은 판독하는 과정에서 표준적이고 일치한 비트 크기에 대한 코드유닛이 아닌 3값 코드유닛의 0헤드 디자인 을 사용하여 채택한 매 하나의 값이 디자인한 표준적이고 동일한 비트 크기를 통해 데이터를 판독한 사용방식으 로 판독하기 때문이다)로 인하여 실시예I에서의 CAABCT(130개의 비트를 사용하여 그의 27개의 고유 테이블 코드 가 매번마다 계산한 균일한 빈도 분포)는 8,0001개 비트의 원시적인 무작위 데이터 집합을 인코딩 할 경우 비트 사용에 있어서 실시예에서의 CAABCT가 사용하는 것보다 더 많은(135개의 비트를 사용하여 그의 27개의 고유 테 이블 코드가 매번마다 계산한 균일한 빈도 분포) 비트를 사용함으로써 도표23에 나타낸 바와 같이 8,1989개 비트를 사용하는데 이는 압축이 아닌 확장이다. 표2a 내지 표3의 결과(단락[85] 내지 [93]과 도표29에서 토론한 바와 같이 표2a는 CAABCT2를 사용한 교차 매핑 결과, 표2b는 CAABCT1을 사용한 교차 매핑 결과, 표3은 CAABCT0 을 사용한 교차 매핑 결과)는 도표21에서 나열하고 다음과 같이 추출한다. 표2a 크기: 80001 표2b 크기: 84373 표3 크기: 81444 이상에서는 교차 매핑에서 무작위 데이터 집합으로부터 PU값(비트의 사용으로 분류)을 판독한 다음 인코딩한 비 트 사용 결과를 제공하는데 여기서 기타 비트 사용 모드의 테이블 코드는 다음과 같이 나열된다. 전반적$매핑 테이블1[27]=[4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5] 전반적$매핑 테이블2a[27]=[3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6] 전반적$매핑 테이블2b[27]=[3, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6] 전반적$매핑 테이블3[27]=[3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6] 따라서 알 수 있다 시피, 27개의 고유 테이블 코드를 가지는 코드표를 디자인하기 어려운 바, 무작위 데이터 집 합으로부터 판독한 27개의 고유 코드값을 인코딩 할 경우 비트 사용에서의 임의의 절약 또는 압축을 실현할 수 있다. 따라서 무작위 데이터 집합을 압축하기 위하여 반드시 기타 기술을 디자인하고 개발 사용하여 이러한 목 적에 도달해야 한다. 아래에 개시하고자 하는 것은 이러한 디자인이 슈퍼 처리유닛 및 전문적으로 디자인한 코 드표를 이용하여 매핑 또는 인코딩 하는 것이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 91, "content": "[76] 슈퍼 처리유닛을 사용하는 개념은 사실상 무작위 데이터 집합이 수많은 불균일한 데이터 서브 섹션으로 조 성되어 있다고 생각할 수 있고 또 무작위 데이터 집합은 데이터 코드값으 빈도 분포 성질로 인해 압축될 수 없 다는 사실에서 비롯되므로 무작위 데이터의 전반 숫자 데이터 입력 파일을 불균일한 데이터의 서브 섹션으로 나 누되 상기 서브 섹션은 여기서 슈퍼 처리유닛으로 지칭되어 이러한 단독적인 슈퍼 처리유닛으로 하여금 하나씩 불균일 데이터를 이용하여 분포하도록 함으로써 압축 가능한 기술이 되도록 하여 무작위 분포에 대한 전반 숫자 데이터 입력을 압축할 수 있도록 한다. 이는 분할 정복 전략이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 92, "content": "[77] 따라서 전반 숫자 데이터 입력 파일은 대형의 처리유닛으로 간주될 수 있는데 상기 처리유닛은 임의의 극 단에서 무작위 또는 완전 불균일한 데이터 분포 스펙트럼의 어느 한 점으로부터의 숫자 데이터의 모든 처리유닛 을 포함한다. 압축과학분야에서는 단지 데이터 집합의 뷸균일 특성을 이용하여 압축기술을 실현할 수 있다. 또 한 현재까지 무작위 할달된 데이터 집합은 압축이 불가능한 것으로 간주된다. 따라서 전반적인 무작위 데이터의 처리유닛으로 조성된 하나의 대형 처리유닛은 일정한 수량의 처리유닛으로 조성된 서브 섹션으로 분할될 수 있 고 상기 서브 섹션은 슈퍼 처리유닛으로 불릴수 있으며 기술로 하여금 이러한 데이터 서브 섹션을 압축하도록 디자인될 수 있다. 따라서 대형 처리유닛은 전체유닛으로 정의되고 전체유닛은 인코딩과 디코딩하는 모든 데이 터 코드를 포함하므로 암호화되지 않은 코드유닛을 배제하며 상기 코드유닛은 인코딩과 디코딩과정을 거치지 않 은 데이터 코드로 조성되는 바, 예하면 적합한 상황에서 하나의 처리유닛 또는 하나의 슈퍼 처리유닛의 크기에 도달하지 않았기 때문이다. 어떠한 목적에 의하여 대형 처리유닛을 인코딩과 디코딩을 위한 다수의 슈퍼 처리유 닛으로 분류할 수 있는 바, 예하면 이러한 구분 또는 기타 목적을 통해 무작위 데이터를 압축한다. 슈퍼 처리유 닛에 사용되는 데이터의 인코딩과 디코딩은 처리유닛에 대해 진행한 인코딩과 디코딩에 사용되는 인코딩과 디코 딩 기술 또는 과정을 통해 일부 조절된다. 따라서 슈퍼 처리유닛은 하나 또는 다수의 처리유닛으로 조성된 데이 터유닛이다. 처리유닛에 대해 진행한 인코딩과 디코딩은 일부 코딩 조절을 거치게 된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 93, "content": "[78] 슈퍼 처리유닛이 어떻게 무작위 데이터를 압축하는 목적을 이해하기 위하여 도표20에서의 0헤드 디자인의 3개의 3값 코드유닛으로 조성된 처리유닛의 27개의 고유 코드값은 우선 아래 도표23에서 분류되고 나열된다. 도표23 도표19에서의 코드유닛을 사용하여 정의한 80,000비트의 무작위 데이터 집합에서 3개의 3값 코드유닛으로 조성 된 처리유닛의 27개의 고유 코드값의 분류/미분류 빈도 분포를 판독하는 구현예 처리유닛 코드값 사용한 비트 빈도 코드(분류/미분류) 분류/미분류 서열번호 코드유닛1 코드유닛2 코드유닛3 1/1 0 0 0 3 2155 2/3 0 0 11 4 1154 3/19 11 0 0 4 1143 4/7 0 11 0 4 1132 5/2 0 0 10 4 1101 6/4 0 10 0 4 1078 7/10 10 0 0 4 1074 8/9 0 11 11 5 605 9/5 0 10 10 5 587 10/11 10 0 10 5 574 11/12 10 0 11 5 566 12/20 11 0 10 5 566 13/16 10 11 0 5 564 14/22 11 10 0 5 563 15/8 0 11 10 5 558 16/13 10 10 0 5 552 17/21 11 0 11 5 530 18/25 11 11 0 5 527 19/6 0 10 11 5 506 20/23 11 10 10 6 304 21/18 10 11 11 6 292 22/15 10 10 11 6 290 23/14 10 10 10 6 279 24/26 11 11 10 6 277 25/17 10 11 10 6 263 26/27 11 11 11 6 262 27/24 11 10 11 6 253 합계: 135비트 응당 유의해야 할 것은, 이상의 도표23에서의 27개의 고유 코드값의 분류 정렬값은 비트의 사용에 근거하여 4그 룹으로 분류될 수 있는데 그룹1의 1개의 코드값은 3비트이고 그룹2의 6개의 코드값은 4비트이며 그룹3의 12개의 코드값은 5비트이고 그룹4의 8개의 코드값은 6비트이다. 수시로 발생한 무작위 데이터의 빈도 분포가 약간씩 변 화되므로 특정된 그룹 내의 매 하나의 코드값의 랭크는 무작위 데이터 집합의 상이함으로 인하여 약간씩 변화될수 있다, 그러나 하나의 무작위 데이터의 구현예와 다른 한 구현예 사이의 빈도에 있어서 코드값은 하나의 그룹 에서 다른 한 그룹으로 이동하지 않는다. 만약 그륻의 변화가 이토록 크게 되면 데이터 분포는 근본적으로 무작 위가 아닐 것이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 94, "content": "[79] 무작위 데이터가 이런 유사한 데이터 코드값의 빈도 분포를 가지므로 상이한 버전의 CAABCT를 디자인하여 그들과 교차 매핑될 수 있고 이러한 CAABCT를 사용하여 인코딩 한 후의 비트 사용 결과는 이미 도표21에 언급되 고 나타났다. CAABCT의 테이블 코드와 어떠한 데이터 분포를 처리하기 위한 특정된 데이터 집합의 첸 프레임워 크에서의 처리유닛과 코드유닛의 특정 모드와 디자인의 데이터 코드닶의 교차 매핑에 대하여 관심을 보이는 27 개의 고유 코드값의 데이터 코드값의 빈도 랭크는 무작위 데이터 집합의 코드값과 상이할 수 있다. 따라서 이 27개의 고유 코드값 빈도의 순서를 반드시 알고 있으므로써 CAABCT의 테이블 코드와 27개의 고유 코드값의 교차 매핑을 설계하여 압축의 가장 적당한 결과를 시도하도록 할 수 있다. 따라서 응당 관심을 가지는 데이터 집합을 우선적으로 분석하여 고유 코드값 빈도의 이러한 순서를 획득하고 이러한 정보로 하여금 인코더와 디코더에 사 용되어 처리하도록 하여야 한다. 이러한 정보는 하나의 데이터 집합으로부터 다른 한 데이터 집합으로 변화하므 로 이를 암호화된 코드의 마스터헤드에 포함시켜 잠시 뒤 디코더에 제공함으로써 원시적인 데이터 집합을 정확 하게 복구하도록 할 수 있다. 무작위 분포에서의 데이터 집합 및 인코딩과 디코딩의 데이터 코드값과 테이블 코 드값의 교차 매핑의 분포에 대하여 마찬가지로 이렇게 진행한다. 그러나 무작위 데이터 집합의 그룹 내의 코드 값의 빈도 랭크의 약간의 변화가 수락될 수 있는 것으로 간주되면 마스터헤드에서 이러한 정보를 생략한다. 그 러나 CAABCT를 처리하기 위한 지정자(또는 전반적인 CAABCT의 내용)는 여전히 마스테헤드에 보류되거나 또는 적 합한 상황에서 인코더와 디코더에 사용되거나 구성될 수 있다. 여기서 CAABCT를 사용하는 것은 AAB기술이 0헤드 디자인을 사용하는 3개의 3값 코드유닛을 이용하여 처리유닛의 27개의 고유 코드값을 위하 매핑 코드표를 디자 인하기 때문이다. 따라서 AAB기술을 사용하지 않는 기타 매핑 코드표도 적합한 상황에서 사용되도록 디자인될 수 있다. 따라서 본 토론에서 CAABCT를 사용하는 상황을 언급하는 바, 매핑 코드표가 통상적으로 인코딩과 디코 딩에서의 용도에도 적용된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 95, "content": "[80] 이하 CAABCT가 어떻게 인코딩에서의 슈퍼 처리유닛을 사용하여 무작위 데이터 집합을 압축하는가 하는 것 을 본다. 슈퍼 처리유닛의 용도는 무작위 데이터 집합을 데이터의 서브 섹션으로 분할하기 위한 것이므로 슈퍼 처리유닛은 데이터 분포를 가지도록 디자인되고 상기 데이터 분포와 무작위 데이터 집합은 상이하여 불균일 데 이터를 압축하는 기술을 이용하여 압축을 진행할 수 있다. 예하면 풀 세트의 처리유닛(구현예에서는 27개의 고 유의 데이터 값 항목)과 동일하거나 또는 더 적은 수량의 처리유닛을 가지는 처리유닛의 슈퍼 처리유닛은 불균 일한 데이터 분포를 구비하도록 담보된다. 그러나 이는 모든 불균일한 데이터 서브 섹션이 모두 압추할 수 있다 는 것을 의미하지 않는다. 이는 어느 한 데이터 분포를 압축하는 데이터에서 유용한 임의의 압축기술 또는 매핑 코드표는 다른 한 상이한 데이터 분포의 데이터에 적합하지 않을 수 있기 때문이다. 이는 한가지 압축기술보다 많거나 하나의 매핑 코드표보다 많은 것으로 상이한 데이터 분포의 슈퍼 처리유닛을 압축한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 96, "content": "[81] 무작위 데이터 집합을 슈퍼 처리유닛 형식의 데이터 서브 섹션으로 분류하는 이러한 방법과 기술에서 처음 으로 슈퍼 처리유닛을 두개의 그룹으로 분류하는 시도를 진행하였는데 하나의 CAABCT를 인코딩과 디코딩 그룹의 슈퍼 처리유닛의 처리유닛으로 사용하고 다른 한 CAABCT를 인코딩과 디코딩의 다른 한 그룹의 수퍼 처리유닛의 처리유닛으로 사용한다. 이러한 방식으로 어느 한 CAABCT가 두개의 그룹에서의 어느 한 그룹의 1비트 지정자로 사용되는것은 반드시 하나의 슈퍼 처리유닛에 응용되어야 하는 것이다. 따라서 이러한 방법을 사용하여 압축하 는 것은 반드시 별도의 비트 사용이 발생한다. 또한 매 하나의 슈퍼 처리유닛의 CAABCT 비트 지정자 및 기타 부 가적인 정보(예하면 마스터헤드에 포함되는 것들)를 사용하여 반드시 초래하는 비트 사용과 비교하면 관련 CAABCT를 사용하여 압축함으로써 실현하는 인코딩은 응당 더 많은 비트 사용의 절약을 초래할 수 있다. 이는 미 래에 아주 큰 도전성을 가지는 임무이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 97, "content": "[82] 현재까지 이 목적에 사용되도록 제의하는 기술은: (a) 슈퍼 처리유닛을 사용; (b) 슈퍼 처리유닛을 본 명세서의 이러한 상황에서 우선 두 그룹으로 분류하고; 및 (c) CAABCT(이러한 상황은 두개)를 (두 그룹의 슈퍼 처리유닛 그룹의) 고유 데이터 코드값과 고유테이블 코드값 사이의 교차 매핑에 사용하고 CAABCT 지정자를 사용. 슈퍼 처리유닛의 크기는 사용 및 어떻게 슈퍼 처리유닛을 그루핑하거나 분류하고 어떠한 CAABCT를 사용할 것인 지를 제공하는 것은 문제의 소재이다.[83] 이러한 문제의 답안은 반드시 도표23에서 토론하는 상기 상황에서 사용하는 구현예에서 찾아야 하는 바, 여기서 처리유닛은 0헤드 디자인의 3개의 3값 코드유닛을 포함하도록 디자인되므로 약 80000개의 비트의 무작위 데이터 집합에 대해 빈도 랭크로 분류한 27개의 고유 코드값을 구비한다. 도표21은 단락[73] 내지 [75]에서 토 론한 두개의 CAABCT가 무작위 데이터 집합의 압축을 가능하도록 하지 못할 수 있다는 것을 나타낸다. 이는 인코 딩을 진행하도록 무작위 데이터 집합을 슈퍼 처리유닛으로 분류하여 이 상황의 해결방안으로 사용하도록 제의된 다. 따라서 반드시 이 방식으로 슈퍼 처리유닛을 구분하는데 그 방식은 반드시 그들 중의 매 하나가 모두 무작 위 데이터 분포를 갖지 않도록 한다. 따라서 고정비트 크기 또는 고정범위의 비트 크기 또는 고정수량의 처리유 닛을 가지는 슈퍼 처리유닛을 사용할 수 있고 상기 슈퍼 처리유닛은 매 하나의 슈퍼 처리유닛 내의 데이터 분포 가 무작위가 아님을 확보한다. 따라서 단락[73] 내지 [75]의 토론에서 표명하다 시피 27개 또는 더 적은 처리유 닛으로 조성된 슈퍼 처리유닛은 응당 상기 표준을 만족시킨다고 확정하는데 이는 27개의 고유 코드값(만약 모두 존재하거나 존재하지 않으면)이 상용 의미에서 사용하는 고정비트 값 크기를 사용하여 디자인한 코드유닛의 무 작위 데이터 집합을 구성하지 않기 때문이다. 상용 의미에서 고정비트 값 크기를 사용하여 디자인한 코드유닛의 무작위 데이터 집합이 0헤드 디자인의 3개의 3값 코드유닛으로 조성된 처리유닛의 모드와 디자인을 사용하여 판 독할 때 도표18에 나타낸 27개의 고유값에서의 매 하나의 빈도 분포 특징을 나타내는 것이 아니라 도표23에 나 타나는 특유의 데이터 빈도 분포 특징을 나타낸다. 고정 크기의 슈퍼 처리유닛을 사용하는 것은 구분을 실현하 기 위한 한가지 방법이다. 따라서 잠시 슈퍼 처리유닛의 크기를 27개의 처리유닛으로 정하도록 고려한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 98, "content": "[84] 여기서 27개의 처리유닛 크기를 가지는 슈퍼 처리유닛은 매 하나의 독특한 27개의 코드값으로 하여금 이렇 게 구분한 매 하나의 슈퍼 처리유닛에 존재하도록 담보하지 않는다. 이러한 슈퍼 처리유닛에서 매 하나마다 상 이한 데이터 분포를 가질 수 있는데 일부는 27개의 고유 코드값에 존재하고 일부는 일부 독특한 코드값을 결여 하며 기타 고유 코드값은 한번만 나타나는 것이 아니고 이들은 모두 상이한 방식으로 존재한다. 따라서 설명의 편리를 위하여 여기의 구현예는 이러한 상이한 데이터 모드를 두 그룹으로 분류하여 인코딩과 디코딩에 사용한 다. 도표23에서의 80000비트의 무작위 데이터 집합의 비트 사용과 빈도 분포의 통계값은 도표24에서 완전하게 하고 아래에 나타낸 바와 같다. 도표24 3개의 3값 코드유닛으로 조성된 처리유닛이 도표19에서의 코드유닛이 정의하는 80,003비트의 무작위 데이터 집 합으로부터 판독한 27개의 고유 코드값의 통계값의 구현예 처리유닛 분류 코드 카테고리 번호 코드 사용한 비트 빈도 빈도％ 빈도％ 값 (~) (~) 카테고리 1 12.1 1 000 3 2155 12.1 카테고리 2 37.6 2 0011 4 1154 6.5 3 1100 4 1143 6.4 4 0110 4 1132 6.4 5 0010 4 1101 6.2 6 0100 4 1078 6.1 7 1000 4 1074 6.0 카테고리 3 37.7 8 01111 5 605 3.4 9 01010 5 587 3.3 10 10010 5 574 3.2 11 10011 5 566 3.2 12 11010 5 566 3.2 13 10110 5 564 3.2 14 11100 5 563 3.2 15 01110 5 558 3.1 16 10100 5 552 3.1 17 11011 5 530 3.0 18 11110 5 527 3.0 19 01011 5 506 2.8 카테고리 4 12.5 20 111010 6 304 1.7 21 101111 6 292 1.6 22 101011 6 290 1.6 23 101010 6 279 1.6 24 111110 6 277 1.6 25 101110 6 263 1.5 26 111111 6 262 1.5 27 111011 6 253 1.4 합계: 135비트 합계: 17755 합계: ~100"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 99, "content": "[85] 이상의 도표24로부터 알 수 있다 시피 27개의 고유값은 비트 사용 또는 빈도 특징 방면에서 4클라스로 분 류될 수 있다. 만약 카테고리1과 카테고리2가 한 그룹(그룹0)을 이루면 빈도 카운트 방면에서 이는 약 49.7％를 차지하고 카테고리3과 카테고리4가 다른 한 그룹(그룹1)을 형성하면 이는 약 50.2％를 차지한다. 이 두 그룹의 빈도 카운트는 대략적으로 동일하다. 따라서 무작위 데이터 집합을 불균일 데이터 분포를 가지는 슈퍼 처리유닛 (27개의 처리유닛을 사용)으로 분류하면 일부 슈퍼 처리유닛은 그룹1보다 그룹0에서 더 많은 고유 코드값을 가 지고 그 외에 일부는 반대된다. 따라서 만약 매핑 코드표(CAABCT 0)가 그룹1이 아닌 그룹0에 교차 매핑되도록 디자인 될 경우 비교적 적은 비트값을 사용하고 다른 한 매핑 코드표(CAABCT 1)는 반대된다. 그렇게 되면 그룹0 에서 유래한 더 많은 고유 데이터 코드값의 슈퍼 처리유닛은 CAABCT 0을 사용하여 인코딩하여 압축하는 목적의 혜택을 보게 되며 동일한 목적으로 그룹1에서 유래한 더 많은 슈퍼 처리유닛이 CCABCT 1을 사용하는 것의 혜택 을 보게 된다. 그러나 하나의 지정자 비트가 어느 매핑 코드표를 지시하여 매 하나의 슈퍼 처리유닛에 사용하는 용도의 별도의 비용이 발생하는 문제가 존재한다. 한편으로 그룹0의 슈퍼 처리유닛(즉 그룹0에서 유래한 더 많 은 데이터 값을 가지는 슈퍼 처리유닛)은 때로는 그룹1이 아닌 그룹0에서 유래한 1개의 데이터 값보다 많은 항 목을 가진다. 그룹1의 슈퍼 처리유닛도 마찬가지이다. 따라서 매 하나의 슈퍼 처리유닛의 매핑 테이블 지정자 비트의 이러한 별도의 비용은 여전히 상기에서 제출한 코드값 출현 모드에 의해 차감될 기회가 있을 것이다. 그 러나 일부 기타 기술은 이러한 슈퍼 처리유닛과 매핑 코드표의 인코딩과 디코딩기술을 사용할 경우 더 많은 비 트 사용 공간을 절약하는데 도움이 될 것이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 100, "content": "[86] 이러한 기타 기술에서의 하나는 인공지능(AI)기술[또는 더 구체적으로 말하면 인류지능(HI)기술]을 사용하 는 것인데 상기 기술은 인코딩과 디코딩에서 매 하나의 슈퍼 처리유닛을 위해 매핑 코드표 비트 지정자를 사용 하는 것을 면제한다. 여기서 사용한 인공지능기술은 AI표준을 건립하고 상기 AI표준을 통해 매 하나의 암호화된 슈퍼 처리 유닛의 내용을 구분하며 그 중 두개의 매핑 코드표에서의 하나는 인코딩과 대응되는 슈퍼 처리유닛에 응용되어야 한다. 이러한 방식으로 만약 AI를 적합하게 설치하면 매핑 코드표 비트 지정자를 생략할 수 있다. 아래는 사용 가능한 AI표준의 일부 제의이다.(a) 슈퍼 처리유닛에 존재하는 코드값(식별 코드값), 상기 코드값은 어느CAABCT가 그의 인코딩에 사용되는지를 식별할 수 있고; 따라서 이 표준을 고려하여 이러한 코드값은 응당 두개의 상이한 CAABCT에 의해 상이한 테이블 코드값에 인코딩되며; 또한 디자인이 관심을 주는 두개의 CAABCT의 단계에서 반드시 이 요구를 만족해야 하고; 마찬가지로 이 요구에 의해 하나의 매핑 코드표를 사용 정지하여 슈퍼 처리유닛을 인코딩하는 종료 조건 또는 표준이 개변되는 바; 예하면 우선 슈퍼 처리유닛의 크기를 27개의 처리유닛의 코드값으로 설정하지만 슈퍼 처리 유닛에 존재하는 27개의 코드값에서 식별 코드값을 항상 찾을 수 있는 것이 아니므로 종료 조건은 반드시 아래 와 같이 수정되어야 한다. (i) 식별 코드값을 종료값으로 사용하되 상기 종료값을 통해 하나의 CAABCT를 사용하여 그 이전의 값 코드 및 그 자체를 인코딩하고 여기서 코드값을 식별한 후 다시 평가하는데 평가는 반드시 어느 CAABCT를 사용하여 다음 의 식별 코드값을 가지는 그러한 코드값을 암호화하며; 이러한 기술을 통해 식별 코드값을 포함하지 않는 원시 적인 코드 값의 최후의 일부를 더 평가할 수 있고 두개의 CAABCT에서의 임의의 하나를 사용하여 인코딩하지만; 이러한 방식으로는 반드시 인코딩 뒤에 식별 코드값을 이 부분의 끝부분에 인코딩해야 하며; 이 최후의 식별 코 드값이 추가된 하나의 코드 또는 원시적인 코드값의 일부인지 여부의 지정자는 마스터헤드에 추가되어 인코딩을 진행할 경우 식별 코드값은 반드시 디코딩되거나 또는 복구코드에서 삭제되어야 하며; 그 후 이 부분 다음에 암 호화되지 않은 코드유닛이 존재할 수 있는데 상기 코드유닛은 하나의 처리유닛 코드값을 구성하지 않는 코드비 트(존재한다고 하면)를 포함거나; 또는 (ii) 식별 코드값의 슈퍼 처리유닛을 종료 조건으로 사용함; 이는 숫자 데이터가 입력한 마스터헤드로부터 시작 하여 제3 슈퍼 처리유닛(이러한 상황에서는 27개의 코드값)이 식별 코드값을 포함하면 앞의 3개의 슈퍼 처리유 닛의 모든 코드값은 모두 평가할 때 하나의 CAABCT를 사용하여 인코딩함과 동시에 새로운 평가를 진행해야 하며 평가는 응당 어느 CAABCT를 사용하여 다음의 코드값을 인코딩 할 것인지를 평가해야 하는데 이는 즉 다음의 슈 퍼 처리유닛이 그 식별 코드값을 포함해야 한다는 것이며; 마지막으로 하나의 슈퍼 처리유닛을 구성하거나 또는 식별 코드값을 가지지 않는 원본 코드의 제일 마직막 부분의 코드는 이상의 (i)에서의 방식과 같이 처리하거나 또는 암호화되지 않은 코드유닛에 포함되도록 남겨줄 수 있다. (b) 디코딩 실패; 하나의 CAABCT를 사용하여 암호화한 코드값은 때로는 다른 한 CAABCT를 사용하여 성공적으로 디코딩할 수 없을 수 있으므로 암호화된 코드값은 반드시 두개의 CAABCT를 사용하여 디코딩해야 하는데 이는 하 나의 CAABCT가 반드시 인코딩을 위한 하나의 CAABCT에 사용되도록 해야 하고; 디코딩 과정은 응당 성공적으로 이를 사용하여 디코딩할 수 있으며; 디코딩에 사용되지 않는 다른 한 CAABCT를 사용하여 인코딩하는 것은 이러 한 상황에 도달할 수 없을 수 있다. (c) 암호화된 코드가 비교적 짧음; 이는 인코딩이 압축의 목적에 사용되므로 반드시 제일 짧은 암호화된 코드를 발생하는 CAABCT를 선택하게 되고; 따라서 디코딩 할 경우 인코딩에 사용되지 않은 CAABCT를 사용하여 암호화하 게 되면 반드시 전반적으로 비교적 긴 코드를 발생하게 된다. (d) 재 인코딩의 실패; 따라서 두개의 상이한 CAABCT를 사용하여 디코딩 할 경우 두 그룹의 상이한 암호화된 코 드를 발생하고; 이 두 그룹의 암호화된 코드는 교환 가능하게 또다시 두개의 CAABCT를 사용하여 또다시 인코딩 하는데 때로는 선택된 하나가 아닌 다른 한 CAABCT를 사용하여 재코딩하는 것은 성공하지 못할 수 있으며; 특히 두개의 상이한 CAABCT에서 상이한 헤드 디자인의 트리오(trios)에서의 코드값을 사용하는 바, 예하면 0헤드 디 자인의 하나의 CAABCT를 사용하는 것은 아래의 트리오를 사용하는 것이다. 0 10 11 접미사로서 다른 하나의 1헤드 디자인을 사용하는 CAABCT는 아래의 트리오를 코드값으로 사용하는 접미사, 즉: 1 01 00 트리오 코드값으로서의 접미사(이는 뒤에서 해석하기로 함); 인코딩이 실패한 다른 한 증거는 재 인코딩 할 경 우 암호화된 코드의 제일 마지막 몇 비트는 하나의 코드값을 형성하지 않고 고정 비트 크기 또는 고정수량의 처리유닛을 가지는 슈퍼 처리유닛을 사용함에 있어서 재 인코딩한 코드값은 디자인된 고정크기를 구성하지 않으며 재 인코딩 할 경우 고정크기의 슈퍼 처리유닛이 가지는 더 많거나 더 적은 코드를 발생하기 된다. (e) 필요할 경우 암호화된 코드 뒤에 별도의 비트를 추가하되, 상기 AI표즌을 사용하여 평가한 후 여전히 인코 딩을 위해 선택한 CAABCT를 식별할 수 없는 기회가 존재하게 되어 반드시 별도의 비트를 암호화된 코드의 일부 또는 유닛의 끝부분에 추가하여 이러한 구별을 진행하도록 하고; 만약 필요하다면 이 부가적인 비트는 단지 안 전하게 벗어나기 위한 것으로 제공되어 정확하게 구분할 수 없는 상황을 벗어나며; 상기 안전하게 벗어나는 것 은 실현할 필요가 거의 없으므로 실제적으로는 이를 위해 이 등위로 저장하지 않을 수 있고 모든 상기 AI표준에 모두 모순이 존재하지 않은 상황에서 명확한 답안을 제공할 경우에야 만이 사용할 수 있으며; 이 점을 감안하여 인코딩 과정 중 및 인코딩의 매 하나의 부분 또는 유닛이 완성된 후 이러한 AI평가를 진행해야 한다. 그리고 (f) 적합하고 효과적으로 사용하는 기타 표준으로 발견되고 디자인된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 101, "content": "[87] 상기 계시를 더 뚜렷하게 나타내기 위하여 두개의 이러한 CAABCT를 디자인하여 도표25와 도표26에서 진일 보로 상세히 설명하기로 한다. 도표25 27개 값의 절대 어드레스 분기 분류 코드표(CAABCT 0) 실시예III 분류PU 첸 코드에서의 비트 표시, 그룹번호, 정상비트와 분기비트/접미사를 포함 서열 그룹 (정상비트 분기비트/접미사) 비트 크기 번호 번호 (첸 코드) 1 0 000 3 2 0 001 3 3 0 1000 4 4 0 1001 4 5 0 1010 4 6 0 1011 4 7 0 0100 4 8 0 0101 4 9 0 01100 5 10 0 01101 5 11 0 01110 5 12 1 01111 5 13 1 0 5 14 1 10 6 15 1 11 6 16 1 110100 6 17 1 110101 6 18 1 110110 6 19 1 110111 6 20 1 111000 6 21 1 111001 6 22 1 111010 6 23 1 111011 6 24 1 111100 6 25 1 111101 6 26 1 111110 6 27 1 111111 6 합계: 139비트 도표26 27개 값의 절대 어드레스 분기 분류 코드표(CAABCT 1) 실시예IV 분류PU 첸 코드에서의 비트표시, 그룹번호, 정상비트와 분기비트/접미사를 포함 서열 그룹 (정상비트 분기비트/접미사) 비트 크기 번호 번호 (첸 코드) 1 0 011 3 2 0 10000 5 3 0 10001 5 4 0 10010 5 5 0 10011 5 6 0 1 5 7 0 1 5 8 0 01 6 9 0 00 6 10 0 01 6 11 0 00 6 12 1 0000 4 13 1 0001 4 14 1 [001] 1 4 15 1 [010] 1 4 16 1 1100 4 17 1 1101 4 18 1 [001] 01 5 19 1 [001] 00 5 20 1 [010] 01 5 21 1 [010] 00 5 22 1 1 5 23 1 1 5 24 1 01 6 25 1 00 6 26 1 01 6 27 1 00 6 합계: 135비트"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 102, "content": "[88] 상술한 두개의 CAABCT로부터 알 수 있다 시피 테이블 코드값에 대한 그루핑은 약간의 조절을 진행하여 앞 의 11개의 테이블 코드를 그룹0으로 조합하고 나머지 테이블 코드를 그룹1로 조합한다. 이러한 그루핑 조절은 더 용이한 코드 배치의 결과이다. 괄호에서의 그러한 테이블 코드값은 트리오에서의 코드값이다. CAABCT 0에는 1개의 트리오만 존재하고 CAABCT 1에는 6개의 트리오가 존재한다. CAABCT 0에서 트리오는 0헤드 디자인, 즉 아 래 형식의 접미사를 사용한다. 0 10 11 CAABCT 1에서 트리오는 1헤드 디자인을 사용하고 아래 형식의 접미사를 가진다. 1 01 00 단락[86]의 (d)에서 설명한 바와 같이 상이한 디자인의 접미사의 용도는 AI구별을 의미한다. 접미사 디자인은 AAB기술을 사용하여 발생한 다른 한가지 사용방법이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 103, "content": "[89] 아래의 도표27은 비트 크기에 근거하여 분류한 3개의 3값 코드유닛의 처리유닛의 27개의 고유 데이터 코드 값과 CAABCT 0과 CAABCT 1의 테이블 코드값의 교차 매핑된 통일적인 투시도를 제공한다. 도표27 데이터 코드값(도표24)과 CAABCT 0과 CAABCT 1의 테이블 코드값 사이의 교차 매핑 처리유닛 분류 코드 번호 코드 사용한 빈도 ％ CAABCT 0 CAABCT 1 값 비트 값+/-비트 값+/-비트 그룹0 1 000 3 2155 12.1 000 0 011 0 2 0011 4 1154 6.5 001 -1 10000 +1 3 1100 4 1143 6.4 1000 0 10001 +1 4 0110 4 1132 6.4 1001 0 10010 +1 5 0010 4 1101 6.2 1010 0 10011 +1 6 0100 4 1078 6.1 1011 0 1 +1 7 1000 4 1074 6.0 0100 0 1 +1 8 01111 5 605 3.4 0101 -1 01 +1 9 01010 5 587 3.3 01100 0 00 +1 10 10010 5 574 3.2 01101 0 01 +1 11 10011 5 566 3.2 01110 0 00 +1 그룹1 12 11010 5 566 3.2 01111 0 0000 -1 13 10110 5 564 3.2 0 0 0001 -1 14 11100 5 563 3.2 10 +1 [001]1 -1 15 01110 5 558 3.1 11 +1 [010]1 -1 16 10100 5 552 3.1 110100 +1 1100 -1 17 11011 5 530 3.0 110101 +1 1101 -1 18 11110 5 527 3.0 110110 +1 [001]01 0 19 01011 5 506 2.8 110111 +1 [001]00 0 20 111010 6 304 1.7 111000 0 [010]01 -1 21 101111 6 292 1.6 111001 0 [010]00 -1 22 101011 6 290 1.6 111010 0 1 -1 23 101010 6 279 1.6 111011 0 1 -1 24 111110 6 277 1.6 111100 0 01 0 25 101110 6 263 1.5 111101 0 00 0 26 111111 6 262 1.5 111110 0 01 0 27 111011 6 253 1.4 111111 0 00 0"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 104, "content": "[90] 이상의 통계 데이터를 비교할 경우 상술한 두개의 CAABCT를 사용하여 무작위 데이터 집합을 압축할지 여부 는 절대적으로 명확한 것이 아닌 바, 이는 매핑 테이블이 전반적인 무작위 데이터 집합에 적용되지 않고 그 중 의 어느 한 CAABCT에 대해 비트 사용방면에서 더 양호하게 적합한 슈퍼 처리유닛에 적용되기 때문이다. 무작위 데이터 집합을 불균일 데이터 분포로 분류한 슈퍼 처리유닛 다음의 데이터 코드값의 분포 모드는 결정되지 않았 다. 어느 CAABCT를 사용하여 임의의 특정된 슈퍼 처리유닛을 인코딩할 것인가 하는 것은 그룹0과 그룹1의 데이 터 코드값의 수량을 카운트하여 상응한 인코딩을 실제적으로 실현하여 발생한 비트 사용 결과가 아닌 실제적인 인코딩결과에 기반해야 하는 바, 어느 CAABCT가 특정된 슈퍼 처리유닛의 더 정확한 지정자에 사용되는것이 더 적합한 것인지에 관한 것이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 105, "content": "[91] 각 실시방안에 근거하여 상기 기술을 증강시킬 수 있는데, 예하면 하나의 CAABCT를 사용하여 진행하는 것 이며; 상기 CAABCT는 무작위 데이터 집합의 특징에 사용되는 27개의 고유 데이터 코드값의 분포를 구비하고 비 트 사용에 있어서 완전하게 동일하다. 하나의 이러한 CAABCT는 CAABCT1이다. CAABCT1은 교차 매핑을 재분포하는 목적에 사용될 수 있는 바, 아래 도표28에 나타낸 바와 같다. 도표28 데이터 코드값(도표24)과 CAABCT 2와 CAABCT 1의 테이블 코드값 사이의 교차 매핑 처리유닛 분류 코드 번호 코드 사용한 빈도 ％ CAABCT 2 CAABCT 1 값 비트 값+/-비트 값+/-비트 그룹0 1 000 3 2155 12.1 010 0 011 0 2 0011 4 1154 6.5 0000 0 10000 +1 3 1100 4 1143 6.4 0001 0 10001 +1 4 0110 4 1132 6.4 [001]0 0 10010 +1 5 0010 4 1101 6.2 [011]0 0 10011 +1 6 0100 4 1078 6.1 1100 0 1 +1 7 1000 4 1074 6.0 1101 0 1 +1 8 01111 5 605 3.4 0 0 01 +1 9 01010 5 587 3.3 0 0 00 +1 10 10010 5 574 3.2 0 0 01 +1 11 10011 5 566 3.2 0 0 00 +1 그룹1 12 11010 5 566 3.2 10000 0 0000 -1 13 10110 5 564 3.2 10001 0 0001 -1 14 11100 5 563 3.2 10010 0 [001]1 -1 15 01110 5 558 3.1 [001]10 0 [010]1 -1 16 10100 5 552 3.1 [001]11 0 1100 -1 17 11011 5 530 3.0 10011 0 1101 -1 18 11110 5 527 3.0 [011]10 0 [001]01 0 19 01011 5 506 2.8 [011]11 0 [001]00 0 20 111010 6 304 1.7 10 0 [010]01 -1 21 101111 6 292 1.6 11 0 [010]00 -1 22 101011 6 290 1.6 10 0 1 -1 23 101010 6 279 1.6 10 0 1 -1 24 111110 6 277 1.6 11 0 01 0 25 101110 6 263 1.5 11 0 00 0 26 111111 6 262 1.5 10 0 01 0 27 111011 6 253 1.4 11 0 00 0"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 106, "content": "[92] CAABCT 2와 CAABCT 1은 완전히 같고 상이한 점은 아래와 같다. (a) CAABCT 2는 0헤드 디자인을 사용하여 이의 6개의 트리오(즉 0, 10, 11)에 사용하고 CAABCT 1은 1헤드 디자 인(즉 1, 01, 00)을 사용하여 그들 각각의 트리오 접미사에 사용한다. (b) 교차 매핑에 사용될 경우 CAABCT2의 고유 테이블 코드값은 완전히 동일한 비트 크기를 가지는 무작위 데이 터 집합의 고유 데이터 코드값에 매핑, 즉 3비트 크기의 테이블 코드값이 3비트 크기의 데이터 코드값에 매핑되 고 4비트 크기의 테이블 코드값이 4비트 크기의 데이터 코드값에 매핑되며 5비트 크기의 테이블 코드값이 5비트 크기의 데이터 코드값에 매핑되고 6비트 크기의 테이블 코드값이 6비트 크기의 데이터 코드값에 매핑되어 이러 한 방식으로 매핑하 되면면 인코딩 후 동일한 비트 사용을 초래하고 무작위 데이터 집합의 데이터 크기는 압축 되지 않을 뿐만 아니라 확장하지도 않는다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 107, "content": "[93] 무작위 데이터 집합을 압축하는 인코딩과 디코딩을 진행할 경우 아래에서 설명한 바와 같이 슈퍼 처리유닛 을 사용할 경우 인입한 기술에 약간의 조절을 진행한다. 우선 무작위 데이터 집합을 인코딩 할 경우 CAABCT 2를 사용하여 무작위 데이터 집합의 데이터 코드값에 대해 교차 매핑함으로써 인코딩 할 수 있는 바, 즉 0헤드 디자 인의 3값 코드유닛의 정의를 사용하여 무작위 데이터 집합을 하나씩 판독하는데 이러한 연속으로 판독된 유닛에 서의 3개는 하나의 처리유닛을 형성하여CAABCT 2와 함께 교차 매핑으로 사용되어 인코딩을 진행한다. 상술한 바 와 같이 처리유닛 및 슈퍼 처리유닛은 그 뒤에 하나 또 하나씩 인코딩한다. 이는 암호화되지 않은 코드유닛, 즉 1개의 처리유닛의 크기를 구성하지 않는 나머지의 인코딩되지 않는 소량의 코드 비트를 제외한 모든 무작위 데 이터 집합의 모든 전환으로서 CAABCT 2에 근거한 전환코드를 발생한다. 전환된 후의 이 데이터 집합을 압축(현 재 CAABCT 2를 사용하여 교차 매핑 전환을 진행한 후 이 데이터 집합은 예전과 같이 무작위가 아니다)하고 CAABCT 1은 그 다음 전환 데이터 집합에서 구획된 슈퍼 처리유닛에 사용되며 상기 슈퍼 처리유닛은 선택된 종료 조건을 가지는 바, 예하면 원본 코드값000은 현재 010으로 전환되고 CAABCT 2의 대응되는 테이블 코드값이다. 따라서 처리 중의 슈퍼 처리유닛이 만약 어디서든 CAABCT 1을 사용하여 인코딩을 진행하여 동일한 슈퍼 처리유 닛의 전환 코드의 비트보다 더 적은 암호화된 코드를 발생하게 되면 상기 암호화된 코드는 CAABCT 1을 사용하여 암호화 할 수 있다. 종료 조건이 암호화를 위한 CAABCT 테이블 코드값 010을 포함하므로 만약 CAABCT 1을 이용 하여 이에 대해 암호화하면 010을 011로 암호화하게 된다. 따라서 CAABCT 2와 CAABCT 1이 인코딩 한 후 획득한 암호화된 코드를 사용하여 원시적인 데이터 코드값 000은 010으로 전환되고 그 다음 011로 전환된다. 만약 CAABCT 1이 슈퍼 처리유닛의 CAABCT 2의 암호화된 코드의 크기를 축소시킬 수 없으면 그러한 슈퍼 처리유닛의 CAABCT 2의 암호화된 코드값은 그 다음 영향을 받지 않는 상태를 유지한다. 따라서 원시적인 데이터 코드값 000 은 010을 유지한다. 따라서 이는 CAABCT 2코드와 CAABCT 1코드의 AI표준에서의 하나에 작용할 수 있다. CAABCT 2의 6개의 트리오의 접미사와 CAABCT 1의 접미사가 상이하므로 수많은 접미사 지정자도 AI구분을 위한 목적으로 사용될 수도 있다. 단락[86]에서 제기한 모든 AI조작도 CAABCT 1코드와 CAABCT 2코드를 구분하는데 사용된다. 이를 원시적인 데이터 코드값으로 전환하여 AI구분을 진행할 필요가 없으므로 디코딩 과정은 의심할 여지가 없 이 성공적인 것이다. 따라서 CAABCT 2를 사용하여 진행한 모든 매핑 인코딩 및 그 다음 CAABCT 1을 사용하여 선 택적인 교차 매핑을 진행하여 얻은 암호화된 코드를 디코딩하기 위하여 AI기술을 사용하여 단락[86]에서 제기한 CAABCT 1코드의 슈퍼 처리유닛에 AI구분을 진행할 수 있다. 또한 CAABCT 1 코드를 포함한 슈퍼 처리유닛이 결정 된 후 이와 상응하는 CAABCT 1 코드는 CAABCT 2 코드로 디코드하게 된다. 모든 CAABCT 1 코드를 CAABCT 2 코드 로 전환한 다음 CAABCT 2 의 코드표를 사용하여 CAABCT 2 코드로부터 원시적인 데이터 코드값의 일회적 디코딩 을 실현하게 된다. 이러한 방식을 통해 단언컨대 언제 CAABCT 1을 통해 압축한 코드값을 가지는 슈퍼 처리유닛 이 존재하든 이러한 슈퍼 처리유닛을 포함하는 무작위 데이터 집합을 압축할 수 있다. 또는 CAABCT 1이 아닌 CAABCT 0을 사용하여 CAABCT 2와 교차 매핑할 수 있거나 또는 적합한 상황에서 CAABCT 0과 CAABCT 1을 호환 가 능하게 사용하여 CAABCT 2와 교차 매핑할 수 있는데 이러한 상황에서는 반드시 AI표준을 조절하거나 추가하여 어느 매핑 코드표가 임의의 특정된 슈퍼 처리유닛에 사용되는지를 결정해야 한다. 아래의 도표29는 모든 3개의 CAABCT를 사용하여 완성할 수 있는 교차 매핑을 나타낸다. 도표29 데이터 코드값(도표24)과 CAABCT 2, CAABCT 0과 CAABCT 1의 테이블 코드값 사이의 교차 매핑 처리유닛 분류 코드 번호 CAABCT 2 사용한 빈도 ％ CAABCT 0 CAABCT 1 값 비트 값+/-비트 값+/-비트 그룹0 1 010 3 2155 12.1 000 0 011 0 2 0000 4 1154 6.5 001 -1 10000 +1 3 0001 4 1143 6.4 1000 0 10001 +1 4 [001]0 4 1132 6.4 1001 0 10010 +1 5 [011]0 4 1101 6.2 1010 0 10011 +1 6 1100 4 1078 6.1 1011 0 1 +1 7 1101 4 1074 6.0 0100 0 1 +1 8 0 5 605 3.4 0101 -1 01 +1 9 0 5 587 3.3 01100 0 00 +1 10 0 5 574 3.2 01101 0 01 +1 11 0 5 566 3.2 01110 0 00 +1 그룹1 12 10000 5 566 3.2 01111 0 0000 -1 13 10001 5 564 3.2 0 0 0001 -1 14 10010 5 563 3.2 10 +1 [001]1 -1 15 [001]10 5 558 3.1 11 +1 [010]1 -1 16 [001]11 5 552 3.1 110100 +1 1100 -1 17 10011 5 530 3.0 110101 +1 1101 -1 18 [011]10 5 527 3.0 110110 +1 [001]01 0 19 [011]11 5 506 2.8 110111 +1 [001]00 0 20 10 6 304 1.7 111000 0 [010]01 -1 21 11 6 292 1.6 111001 0 [010]00 -1 22 10 6 290 1.6 111010 0 1 -1 23 10 6 279 1.6 111011 0 1 -1 24 11 6 277 1.6 111100 0 01 0 25 11 6 263 1.5 111101 0 00 0 26 10 6 262 1.5 111110 0 01 0 27 11 6 253 1.4 111111 0 00 0"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 108, "content": "[94] 또한 슈퍼 처리유닛을 구획할 수 있는 종료 조건을 조절하거나 약간의 조절을 진행할 수 있으므로, 예하면 슈퍼 처리유닛의 고정 크기를 27개의 데이터 코드값으로부터 때는 더 적고 또는 때로는 더 많은 것으로 변화하 거나,또는 사용하는 종료값을 000으로부터 다른 한 코드값으로 변화하거나, 또는 고정 크기를 가지는 슈퍼 처리 유닛의 종료값이 아닌 종료 값만 사용하여 슈퍼 처리유닛의 크기(이러한 방식으로 슈퍼 처리유닛은 상이한 크기 를 가질 수 있음)를 결정하거나; 또는 기타 크기의 코드유닛(예하면 6값 코드유닛과 이를 위해 디자인한 CAABCT 집합) 또는 기타 크기의 처리유닛을 사용하도록 시도할 수 있는 바, 예하면 3개의 6값 코드유닛이 아닌 4개의 6 값 코드유닛을 처리유닛으로 사용하는 바, 첸 프레임워크에는 이러한 변형이 무궁무진하게 존재할 수 있으므로 무작위 데이터 집합이 영원히 압축되지 않는다고 결정할 수 없다. 반대 상황에서는 오히려 더 결정될 수 있다. 그런데 단락[62] 내지 [66]에서 제기한 비트0:비트1 비율을 변화하는 기술은 우선 무작위 데이터 집합의 빈도 분포를 불균일한 데이터 집합으로 변화하는데 사용될 수 있고 상기 데이터 집합은 그 다음 불균일 데이터 분포 를 이용하는 기술을 통해 압축하는데 사용된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 109, "content": "[95] 상기 진보성의 계시는 인코딩과 디코딩이 무작위인지의 여부와 관계없는 숫자 데이터 집합의 수많은 새로 운 기술을 개시하는 바, 암호화/복호화 및 압축/압축 해제의 목적에 사용된다. 이러한 기술을 조합하여 디자이 너, 구현자와 사용자가 예기하는 이러한 목적을 실현할 수 있다. 또 기타 기술을 디자인하고 실현하여 이를 이 용하여 첸 프레임워크에서 인입한 구조특성과 코딩기술에 사용할 수도 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 110, "content": "[96] 다른 한가지 기술이 존재하는데 상기 기술은 더 간단하고 유용하며 단독으로 사용되거나 또는 이상에서 소 개한 기술과 결합하여 사용될 수 있다. 이는 상이한 크기의 동적 처리유닛과 함께 인공지능기술의 코드값을 동 적으로 조절하는 정의를 사용하여 인코딩과 디코딩을 진행하는 것이다. 이상의 슈퍼 처리유닛에 대한 토론에서 종료값으로만 슈퍼 처리유닛의 크기를 결정함에 있어서 슈퍼 처리유닛의 크기의 변화를 초래할 수 있는 바, 즉상이한 수량의 처리유닛은 숫자 데이터 집합의 상이한 자리에서 슈퍼 처리유닛을 구성한다. 또 종료 조건을 적 당히 디자인하여 이로 하여금 상이한 수량의 코드유닛을 처리유닛으로 사용하여 동적으로 인코딩과 디코딩을 진 행하도록 할 수 있다. 인코딩과 디코딩 과정에서 처리 중인 코드 크기 및 그의 정의에 대해 동적인 조절을 진행 할 수도 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 111, "content": "[97] 단락[96]에서 제기한 기술, 즉 데이터 분포를 변화하는 배경에서 상이한 크기의 처리유닛(본 구현예에서는 3개의 코드유닛과 4개의 코드유닛의 처리유닛이 설명에 사용됨)을 동적으로 사용하는 기술로 돌아가되 상기 기 술은 아래 도표30에 나열한 것과 같은 0헤드 디자인의 3값 코드유닛 디자인을 사용한다. 도표30 하나의 3값 코드유닛의 처리유닛 PU PU 값 번호 코드값 값1(v1) 0 값2(v2) 10 값3(v3) 11 따라서 처리유닛은 0헤드 디자인의 3개 또는 4개의 3값 코드유닛으로 조성되는데 이는 처리 중의 임의의 점에서 의 데이터 분포의 변화배경에 의해 결정된다. 이러한 새로운 기술은 임의의 유형의, 무작위 여부와 관계 없는 데이터 분포의 데이터에 대해 인코딩과 디코딩 처리를 진행하는 것을 풍부하도록 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 112, "content": "[98] 이러한 기술을 디자인하는 것은 종료 조건 개념을 사용한 결과이다. 구상하는 종료 조건은 처리유닛의 종 료점(여기서는 0헤드 디자인의 3값 코드유닛을 사용)이 3값 코드유닛의 모든 3개의 고유 코드값의 출현여부에 기반한다. 논리적 추론을 통해 만약 종료 조건의 이러한 정의에 기반하게 되면 처리유닛은 3값 코드유닛을 가지 는 3개의 코드유닛의 크기보다 작지 말아야 한다. 따라서 만약 모든 3개의 고유 코드값이 연속 세번 나타나면 처리유닛의 크기는 3개의 코드유닛이고 그렇지 않으면 처리유닛의 크기는 응당 3개의 코드유닛을 초과해야 한다. 이는 4 또는 5 또는 6 등등 일 수 있다. 따라서 만약 종료 조건(종료 조건은 Max3 5비트 코드유닛의 모든 3개의 고유 코드값이 나타났음을 말한다)이 달성되지 않으면 4개의 코드유닛을 하나의 종료점으로 간단하게 사 용할 수 있다. 이는 0헤드 디자인의 3값 코드유닛의 정의를 사용하여 3개의 연속된 코드값을 판독할 경우 모든 3개의 고유 데이터 코드값(즉 도표30에서 나열한 v1, v2와 v3)을 얻지 못하게 되면 종료점은 판독한 제4 코드값 에서 나타나고 판독을 정지함으로써 4개의 코드유닛이 처리유닛으로 되게 하며 이러한 상황에서 종료하는 것은 모든 3개의 고유 코드값이 모두 나타났는지 여부와 관계 없음을 의미하는 바, 만약 3개의 연속된 코드값을 판독 할 때 모든 3개의 고유 데이터 코드값이 존재하면 종료점은 제3 코드값을 판독하는 곳에 있고 처리유닛은 3개의 코드유닛으로 조성된다. 따라서 처리유닛의 크기는 조성한 코드유닛의 수량에 근거하여 측정되는데 상기 수량은 처리 중의 숫자 데이터 집합의 데이터 분포에 따라 동적으로 변화된다. 데이터 분포의 상황에 근거하여 만약 처 리유닛의 크기가 응당 4개의 코드유닛이면 이에 대해 두가지 시나리오가 존재하게 된다. (i)모든 3개의 고유 코드값이 존재; 및 (ii)모든 3개의 고유 코드값이 모두 존재하는 것이 아님. 따라서 모두 세가지 상황이 존재한다. (a)3개의 코드유닛의 처리유닛, 여기에는 모든 3개의 고유 코드값이 존재; (b)4개의 코드유닛의 처리유닛, 여기에는 모든3개의 고유 코드값이 존재; 및 (c)4개의 코드유닛의 처리유닛, 여기에는 모든 3개의 고유 코드값이 존재하지 않음."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 113, "content": "[99] 따라서 분류 코드를 도표31에서 나열한 이 세가지 시나리오에 분포할 수 있다. 도표31a 단락[98]의 세가지 시나리오의 시나리오 분류 코드(첸 코드의 일부) 시나리오 분류 코드 시나리오 0 (a) 10 (b) 11 (c) 이 세가지 시나리오의 빈도 분포에 근거하여 최고 빈도를 가지는 시나리오를 최소 수량을 사용하는 이진 비트로 조절할 수 있다. 따라서 시나리오(c)가 최고 빈도를 가진다고 가정하면 시나리오 분류 코드의 시나리오의 분포 를 도표31b로 조절하여 아래와 같이 나열할 수 있다. 도표31b 단락[98]의 세가지 시나리오의 시나리오 분류 코드(첸 코드의 일부) 시나리오 분류 코드 시나리오 0 (c) 10 (b) 11 (a) 따라서 전반 숫자 데이터 입력 파일에 대한 인코딩과 디코딩은 우선 전반 숫자 데이터 파일을 분석하여 어느 시 나리오가 최고 빈도를 가지는지를 찾아내고 이를 분포하여 제일 짧은 분류 코드를 사용하며 기타 시나리오를 아 래로 푸시한다. 따라서 반드시 마스터헤드에 시나리오 다자인 지정자(어느 시나리오 분류모드 또는 디자인을 사 용할 것인지를 지시)를 포함하여 정확하게 디코딩을 완성하도록 해야 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 114, "content": "[100] 본 명세서의 구현예에서 어떻게 첸 코드를 사용하여 코드를 분류할 것인지를 토론한 후 어떻게 첸 코딩의 다른 한 기술(즉 동적 코드 조절)을 사용하여 첸 코드 내의 내용코드를 디자인하고 조작할 것인지를 알 수 있다. 시나리오(a)에 대하여 아래의 코딩을 사용할 수 있다. 시나리오 분류 코드+랭크와 자리코드 시나리오(a)가 3개의 코드유닛의 처리유닛이므로 그 중에는 모든 3개의 고유 코드값이 존재하고 2 또는 3비트 [첸 코딩의 AAB기술을 사용하는 바, 예하면 이의 실제값 범위는 6, 즉 시나리오(a)에 부합되는 종료 조건의 3개 의 코드유닛의 6개의 고유 처리유닛이 존재하고 하한값 범위는 2비트로서 4개의 값과 상응되며 상한값 범위는 3 비트로서 8개의 값과 상응됨]를 사용하며 랭크와 자리코드는 처리유닛을 충분히 커버할 수 있는 모든 6가지 가 능한 조합이고 그 중 3개의 코드유닛은 이의 랭크와 자리 구별을 가지는 3개의 고유 코드값을 구비하며 아래 도 표32에 나타낸 바와 같다. 도표32 3개의 고유 코드값을 가지는 3개의 코드유닛의 처리유닛은 랭크와 자리 방면의 6가지 가능한 조합의RP코드 분포 RP코드 비트 +/- 랭크와 자리방면의 조합 비트 00 2+2 -1 v1v2v3 5 01 2+2 -1 v1v3v2 5 100 2+3 v2v1v3 5 101 2+3 v2v3v1 5 110 2+3 v3v1v2 5 111 2+3 v3v2v1 5"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 115, "content": "[101]시나리오(b)와 (c)의 첸 코드의 내용코드에 대해 첸 코딩을 진행하기 위하여 판독한 4개의 데이터 코드값 을 사용할 수 있는데 이는 이러한 시나리오의 종료 조건에 의해 결정된다. 상기 제4 데이터 코드값, 즉 종료값 은 원본 코드가 완전히 0헤드 디자인을 사용한 3값 코드유닛의 정의를 판독함으로써 나타낼 수 있는 바, 즉 원 본 코드에 어떤 변화도 진행하지 않아도 된다. 따라서 시나리오(b)와 (c)의 내용코드 부분의 인코딩은 아래와 같은 단계(시나리오(a)가 이미 단독으로 처리되었다고 가정)를 각각 포함한다.(a)관련되는 코드유닛의 정의를 사용하여 4개의 연속된 데이터 코드값을 판독; (b)판독된 원래의 양식에 따라 제4 데이터 코드값을 기입; (c)적합한 상황에서 코드 조절기술을 사용하여 제1 데이터 코드값을 기입; (d)적합한 상황에서 코드 조절기술을 사용하여 제2 데이터 코드값을 기입; (e)적합한 상황에서 코드 조절기술을 사용하여 제3 데이터 코드값을 기입; 및 (f)단계(a)에서 판독한 4개의 연속되는 코드값의 인코딩을 완성한 후 암호화되지 않은 코드유닛이 시작되는 점 에 도달할 때까지 단계(a)에 순환적으로 되돌아간다. 또한 적합한 상황에서 상기 단계(c) 내지 (e)에서 제기한 코드 조절기술은 내용코드 랭크와 자리 코딩, 내용코 드 향상과 내용코드 생략, 내용코드 강등 및 내용코드 복구를 포함한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 116, "content": "[102] 시나리오(b)에 대하여 제4 데이터 코드값은 3개의 데이터 코드값인 v1, v2 또는 v3에서의 하나일 수 있 다. 따라서 시나리오(b)에서 서브 시나리오는, 도표33 시나리오(b)의 3개의 서브 시나리오 및 RP코딩 코드 자리 RP코드 제4 제1 제2 제3 (i) v1 v2 v2 v3 00 v1 v2 v3 v2 01 v1 v2 v3 v3 100 v1 v3 v2 v2 101 v1 v3 v2 v3 110 v1 v3 v3 v2 111 (ii) v2 v1 v1 v3 00 v2 v1 v3 v1 01 v2 v1 v3 v3 100 v2 v3 v1 v1 101 v2 v3 v1 v3 110 v2 v3 v3 v1 111 (iii) v3 v1 v1 v2 00 v3 v1 v2 v1 01 v3 v1 v2 v2 100 v3 v2 v1 v1 101 v3 v2 v1 v2 110 v3 v2 v2 v1 111 시나리오(b)의 3개의 서브 시나리오에서의 매 하나에 대하여 6가지 가능한 조합이 더 존재한다. 이러한 서브 시나리오에서의 랭크와 자리코딩을 사용하는 매 하나의 기술은 도표33에 나타낸 그들 각각의 6가지 가능한 조합에 대해 2비트 또는 3비트를 사용한다. 또는 적합한 상황에서 코드 향상과 코드 생략 기술을 사용하는데 이는 도표34에 나타낸 바와 같다. 도표34a 시나리오(b)의 3개의 서브 시나리오 및 코드 향상과 코드 생략 코드 자리와 코드값 코드 향상과 코드 생략 제4 제1 제2 제3 제1 제2 제3 (i) v1 v2 v2 v3 0 0 [논리 생략] [v1이 제1, 제2와 제3 자리에 나타나지 않으므로 2개의 값, 즉 v2와 v3이 선택 가능하고; 따라서 제1 자리와 제 2 자리에서 v2는 코드0으로 향상되고 제3 자리의 v3(만약 배치하고자 하면 코드1을 사용)을 생략하는데 이는 이 러한 시나리오에서 반드시 모든 3개의 고유값이 나타나야 하기 때문이다.] v1 v2 v3 v2 0 1 0 v1 v2 v3 v3 0 1 1 v1 v3 v2 v2 1 0 0 v1 v3 v2 v3 1 0 1 v1 v3 v3 v2 1 1 [논리 생략] (ii) v2 v1 v1 v3 0 0 [논리 생략] v2 v1 v3 v1 0 1 0 v2 v1 v3 v3 0 1 1 v2 v3 v1 v1 1 0 0 v2 v3 v1 v3 1 0 1 v2 v3 v3 v1 1 1 [논리 생략] (iii) v3 v1 v1 v2 0 0 [논리 생략] v3 v1 v2 v1 0 1 0 v3 v1 v2 v2 0 1 1 v3 v2 v1 v1 1 0 0 v3 v2 v1 v2 1 0 1 v3 v2 v2 v1 1 1 [논리 생략] 또는 제4 코드값을 배치한 후 배치하고자 하는 값은 재배열될 수 있는데 이는 아래 도표34b에 도시된 바와 같다. 도표34b 시나리오(b)의 3개의 서브 시나리오 및 코드 향상과 코드 생략 코드 자리 및 코드값 코드 향상과 코드 생략 제4 제1 제2 제3 비트 제4 제3 제2 제1 비트 +/- (i) v1 v2 v2 v3 7 0 1 0 0 2+4 -1 v1 v2 v3 v2 7 0 0 1 0 2+4 -1 v1 v2 v3 v3 7 0 1 1 [] 2+3 -2 v1 v3 v2 v2 7 0 0 0 [] 2+3 -2 v1 v3 v2 v3 7 0 1 0 1 2+4 -1 v1 v3 v3 v2 7 0 0 1 1 2+4 -1 (ii) v2 v1 v1 v3 6 10 1 0 0 2+5 +1 v2 v1 v3 v1 6 10 0 1 0 2+5 +1 v2 v1 v3 v3 7 10 1 1 [] 2+4 -1 v2 v3 v1 v1 6 10 0 0 [] 2+4 v2 v3 v1 v3 7 10 1 0 1 2+5 v2 v3 v3 v1 7 10 0 1 11 2+5 (iii) v3 v1 v1 v2 6 11 1 0 0 2+5 +1 v3 v1 v2 v1 6 11 0 1 0 2+5 +1 v3 v1 v2 v2 7 11 1 1 [] 2+4 -1 v3 v2 v1 v1 6 11 0 0 [] 2+4 v3 v2 v1 v2 7 11 1 0 1 2+5 v3 v2 v2 v1 7 11 0 1 1 2+5 만약 코드 향상과 코드 생략의 기술을 사용하고자 하면 일치성을 위하여 도표34b에서의 코드값의 배치는 도표 34a보다 우수할 수 있는데 이는 이러한 배치가 아래 단락[103]에서 해석하고자 하는 시나리오(c)에 대하여 더 양호한 선택일 수 있기 때문이다. 이상의 시나리오(b)의 서브 시나리오(i)를 사용함으로써 코드 향상은 논리 추론의 결과로서 비트 사용을 절감하 는데 사용된다. 예하면 시나리오(b)가 3개의 고유 코드값이 판독된 4개의 연속된 코드값에 전부 나타나야 하는 시나리오이므로 도표33b에 사용되는 시나리오 분류 코드와 제4 코드값(예하며 v1)을 배치한 후 암호화된 코드는 도표35에서 나열한 바와 같다. 도표35 시나리오 분류에 사용되는 인코딩 및 제4 코드값 신 (b) 제4 코드값 제3 코드값 제2 코드값 제1 코드값 v1 10 0 또한 나머지 3개의 코드값의 암호화된 코드가 삽입된다. 이것이 시나리오(b)이기 때문에 이는 앞의 3개의 코드 값, 즉 제1 코드값 내지 제3 코드값이 반드시 제4 코드값과 상이해야 함을 의미하는 바, 이는 이것이 제4 코드 값으로서 상기 제4 코드값은 시나리오(b)를 위해 디자인한 종료 조건을 만족하도록 하기 때문이다. 따라서 나머 지 3개의 코드값은 v2 또는 v3이다. 또한 두가지 선택만이 존재하므로 1비트(비트0 또는 비트1)로 이 두개의 상 이한 값을 출현을 표시할 수 있다. 맨 처음 v2와 v3은 각각 10과 11로 표시한다. 따라서 이러한 코드값은 그 다 음 각각 0과 1을 사용하여 비트 사용을 절약하도록 향상된다. 이는 코드 향상 기술로서 첸 코딩 기술이다. 또한 만약 제3 코드값과 제2 코드값이 모두 v2이면 첫번째는 반드시 v3이여야 하는데 이는 시나리오(b)에 대해 정의 한 것으로서 그렇지 않게 되면 시나리오(b)의 종료 조건을 만족시키지 않기 때문이다. 따라서 상기 추론으로 인 하여 논리적 추론을 통해 v3을 생략할 수 있다. 방금 제기한 첸 코딩의 코드 향상과 코드 생략 기술을 사용하여 4개의 코드유닛이 조성한 처리유닛을 코딩함으로서 전반적인 암호화된 코드 피스를 얻고 아래 도표36에 표시한 다. 도표36 첸 코딩의 코드 향상과 코드 생략을 사용하여 인코딩 (b) 제4 코드값 제3 코드값 제2 코드값 제1 코드값 v1 v2 v2 v3 10 0 0 0 [] [코드 향상] [코드 생략] 코드 향상과 코드 생략기술을 사용하여 도표33에서 랭크와 자리코딩기술을 사용하는 것과 동일한 비트 사용결과 (도표34a와 도표34b에 나열한 2*2비트+4*3비트)를 제공함을 관찰할 수 있는 바, 이 두가지 기술은 획득한 비트 모드 배열방면에서 상이할 뿐이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 117, "content": "[103] 마찬가지로 시나리오(c)에 대하여 제4 데이터 코드값은 v1, v2 또는 v3 이 3개의 데이터 코드값에서의 하 나 일 수 있다. 따라서 시나리오(c)에서 서브 시나리오는 도표37에서 나열한다. 도표37 시나리오(c)의 3개의 서브 시나리오 및 RP코딩 코드 자리 비트 비트 +/- 제4 제1 제2 제3 제4 RP코드 (i) v1 v1 v1 v1 4 0 000 1+4 +1 v1 v1 v1 v2 5 0 0010 1+5 +1 v1 v1 v2 v1 5 0 0011 1+5 +1 v1 v1 v2 v2 6 0 0100 1+5 v1 v1 v1 v3 5 0 0101 1+5 +1 v1 v1 v3 v1 5 0 0110 1+5 +1 v1 v1 v3 v3 6 0 0111 1+5 v1 v2 v2 v2 7 0 1000 1+5 -1 v1 v2 v2 v1 6 0 1001 1+5 v1 v2 v1 v2 6 0 1010 1+5 v1 v2 v1 v1 5 0 1011 1+5 +1 v1 v3 v3 v3 7 0 1100 1+5 -1 v1 v3 v3 v1 6 0 1101 1+5 v1 v3 v1 v3 6 0 1110 1+5 v1 v3 v1 v1 5 0 1111 1+5 +1 (ii) v2 v2 v2 v2 8 10 000 1+5 -2 v2 v2 v2 v1 7 10 0010 1+6 v2 v2 v1 v2 7 10 0011 1+6 v2 v2 v1 v1 6 10 0100 1+6 +1 v2 v2 v2 v3 8 10 0101 1+6 -1 v2 v2 v3 v2 8 10 0110 1+6 -1 v2 v2 v3 v3 8 10 0111 1+6 -1 v2 v1 v1 v1 5 10 1000 1+6 +2 v2 v1 v1 v2 6 10 1001 1+6 +1 v2 v1 v2 v1 6 10 1010 1+6 +1 v2 v1 v2 v2 7 10 1011 1+6 v2 v3 v3 v3 8 10 1100 1+6 -1 v2 v3 v3 v2 8 10 1101 1+6 -1 v2 v3 v2 v3 8 10 1110 1+6 -1 v2 v3 v2 v2 8 10 1111 1+6 -1 (iii)v3 v3 v3 v3 8 11 000 1+5 -2 v3 v3 v3 v2 8 11 0010 1+6 -1 v3 v3 v2 v3 8 11 0011 1+6 -1 v3 v3 v2 v2 8 11 0100 1+6 -1 v3 v3 v3 v1 7 11 0101 1+6 v3 v3 v1 v3 7 11 0110 1+6 v3 v3 v1 v1 6 11 0111 1+6 +1 v3 v2 v2 v2 8 11 1000 1+6 -1 v3 v2 v2 v3 8 11 1001 1+6 -1 v3 v2 v3 v2 8 11 1010 1+6 -1 v3 v2 v3 v3 8 11 1011 1+6 -1 v3 v1 v1 v1 5 11 1100 1+6 +2 v3 v1 v1 v3 6 11 1101 1+6 +1 v3 v1 v3 v1 6 11 1110 1+6 +1 v3 v1 v3 v3 7 11 1111 1+6 시나리오(c)의3개의 서브 시나리오에서의 매 하나에 대하여 15가지 가능한 조합이 더 존재한다. 도표37에 나타 낸 바와 같이 이러한 서브 시나리오에서의 매 하나에 랭크와 자리코딩기술을 사용하여 도표35에 나타낸 그들 각 각의 15가지 가능한 조합에 3비트 또는 4비트를 사용한다. 적합한 상황에서 코드 향상, 코드 생략 및 기타 형식의 코드 조절기술을 사용할 수 있다. 도표38은 우선 제4 코 드값을 배치한 후 제3 코드값, 제2 코드값과 제1 코드값의 순서를 통해 나머지 3개의 코드값에 인코딩하는 한가 지 코드 조절방식을 나타낸다. 시나리오(c)에 단지 2개의 고유 코드값만 존재하므로 제4 코드값은 이미 1개로 계산되었고 나머지 3개의 자리는 반드시 제4 코드값과 동일한 하나 및 나머지 2개의 고유 코드값에서의 다른 하 나에 의해 기입되어야 한다. 그러나 3개의 옵션에 두가지 선택이 존재하므로 비트 사용을 절감할 때 그의 불확 정성을 제거하기 위하여 우선 제4 코드값 외의 하나의 코드값을 결정해야 한다. 따라서 나머지 3개의 코드값을 직접 인코딩하기 위하여 처리과정에 진입한 숫자 데이터 입력 내의 처리유닛의 제3 자리의 코드값을 인코딩하는 것은 바람직한 선택일 것이다. 이는 하나 또 하나씩 2개 또는 더 많은 동일한 코드값을 가지는 기회가 2개의 상 이한 코드값을 가지는 기회보다 적은 상용적인 가정이다. 물론 처리과정에서의 숫자 데이터 입력 중인 3개의 고 유 코드값에 빈도 분포 모드와 관련된 유용한 정보가 존재하면 이러한 배치선택을 조절할 수 있는데 여기서 사 용 가능한 이러한 정보는 상기 변화를 담보한다. 그러나 우선 편리를 위하여 도표38은 우선 제4, 제1, 제2와 제 3 비트의 순서에 따른 배치를 사용한다. 제4 코드값을 v3이라고 가정하면 기타 3개의 자리의 값은 v1, v2 또는 v3에서의 임의의 하나일 수 있다. 다른 한 코드값이 존재하는 것을 빨리 알게 될 수록 코드 향상 기술을 통해 더 많은 비트를 절약할 수 있다. 그러나 두개의 코드값에서의 하나가 v1, v2와 v3 이 3개의 값에서의 임의이 하나일 수 있으므로 그 중의 하나는 v3 일 수 있다. 따라서 v3을 향상시키는 것은 논리에 부합되는 바, 즉 우선 11로부터 0으로, 또한 그 다음 v1을 v2로 강등하고 v2를 v3으로 강등한다. 또한 만약 다른 한 코드값이 나타나면 이미 나타난 2개의 고유 코드값으로 한정할 수 있다. 제4 코드값이 이미 비트0을 사용한 코드값의 v1의 랭크를 사용하므로 나타난 제2 고유 코드값은 비트10의 코드값을 사용할 수 있다. 이러한 논리를 사용함으로써 도표38은 아래와 같이 생성된다. 도표38 시나리오(c)의 3개의 서브 시나리오 및 1개의 비트(비트0)를 사용한 시나리오 분류 코드의 코드 조절 코드 자리 비트 코드 조절 비트 +/- 제4 제1 제2 제3 신 제4 제1 제2 제3 코드 v1 v1 v1 v1 4 0 0 0 0 0 1+4 +1 v1 v1 v1 v2 5 0 0 0 0 10 1+5 +1 v1 v1 v2 v1 5 0 0 0 10 0 1+5 +1 v1 v1 v2 v2 6 0 0 0 10 1 1+5 v1 v1 v1 v3 5 0 0 0 0 11 1+5 +1 v1 v1 v3 v1 5 0 0 0 11 0 1+5 +1 v1 v1 v3 v3 6 0 0 0 11 1 1+5 v1 v2 v2 v2 7 0 0 10 1 1 1+5 -1 v1 v2 v2 v1 6 0 0 10 1 0 1+5 v1 v2 v1 v2 6 0 0 10 0 1 1+5 v1 v2 v1 v1 5 0 0 10 0 0 1+5 +1 v1 v3 v3 v3 7 0 0 11 1 1 1+5 -1 v1 v3 v3 v1 6 0 0 11 1 0 1+5 v1 v3 v1 v3 6 0 0 11 0 1 1+5 v1 v3 v1 v1 5 0 0 11 0 0 1+5 +1 v2 v2 v2 v2 8 0 10 0 0 0 1+5 -2 v2 v2 v2 v1 7 0 10 0 0 10 1+6 v2 v2 v1 v2 7 0 10 0 10 0 1+6 v2 v2 v1 v1 6 0 10 0 10 1 1+6 +1 v2 v2 v2 v3 8 0 10 0 0 11 1+6 -1 v2 v2 v3 v2 8 0 10 0 11 0 1+6 -1 v2 v2 v3 v3 8 0 10 0 11 1 1+6 -1 v2 v1 v1 v1 5 0 10 10 1 1 1+6 +2 v2 v1 v1 v2 6 0 10 10 1 0 1+6 +1 v2 v1 v2 v1 6 0 10 10 0 1 1+6 +1 v2 v1 v2 v2 7 0 10 10 0 0 1+6 v2 v3 v3 v3 8 0 10 11 1 1 1+6 -1 v2 v3 v3 v2 8 0 10 11 1 0 1+6 -1 v2 v3 v2 v3 8 0 10 11 0 1 1+6 -1 v2 v3 v2 v2 8 0 10 11 0 0 1+6 -1 v3 v3 v3 v3 8 0 11 0 0 0 1+5 -2 v3 v3 v3 v2 8 0 11 0 0 11 1+6 -1 v3 v3 v2 v3 8 0 11 0 11 0 1+6 -1 v3 v3 v2 v2 8 0 11 0 11 1 1+6 -1 v3 v3 v3 v1 7 0 11 0 0 10 1+6 v3 v3 v1 v3 7 0 11 0 10 0 1+6 v3 v3 v1 v1 6 0 11 0 10 1 1+6 +1 v3 v2 v2 v2 8 0 11 11 1 1 1+6 -1 v3 v2 v2 v3 8 0 11 11 1 0 1+6 -1 v3 v2 v3 v2 8 0 11 11 0 1 1+6 -1 v3 v2 v3 v3 8 0 11 11 0 0 1+6 -1 v3 v1 v1 v1 5 0 11 10 1 1 1+6 +2 v3 v1 v1 v3 6 0 11 10 1 0 1+6 +1 v3 v1 v3 v1 6 0 11 10 0 1 1+6 +1 v3 v1 v3 v3 7 0 11 10 0 0 1+6 여기서 시나리오(c)는 코드 향상과 코드 생략기술을 사용하여 랭크와 자리코딩기술을 사용한 것과 대체적으로 동일한 비트 사용결과(여기서 코드 향상기술을 사용하는 것이 뚜렷하게 조금 더 양호함)를 제공함을 관찰할 수 있다. 상기 결과에 근거하여 다른 한 관찰결과는 인코딩 후 확장된 그러한 코드값 항목이 더 많은 v1 코드값을 가지는 항목이라는 것이다. 따라서 만약 데이터 집합의 데이터 분포는 비트1보다 더 많은 비트0을 가지게 되면 1헤드 디자인을 코드유닛의 정의로 사용하여 상기 기술을 통해 숫자 데이터 집합을 판독함으로써 인코딩에 사용하는 것이 가장 좋으며 3개의 고유 코드값은 그 뒤에 다음과 같이 변한다. 1 01 00 이러한 방식으로 비트0은 판독될 때 v1로 변하는 것이 아니라 v2와 v3으로 샘플링된다. 따라서 상술한 바와 같 이 숫자 데이터 입력이 데이터 분포 모드 변화에 대응하는 처리유닛의 크기를 동적으로 조절하는 기술을 사용하 여 인코딩 기간에 동적인 코드 조절로 하여금 더 큰 유연성을 가지도록 허락하는 것은 자명한 것이다. 더 중요 한 것은 데이터 해석단계기간에 정보를 수집하여 시나리오 분류 코드를 가지는 세가지 시나리오(a), (b)와(c)를 배치하고 분포함으로써 제일 빈번한 시나리오가 제일 적은 비트수를 제공하도록 할 수 있다. 또한 비트0과 비트 1의 빈도 분포에 근거하여 코드유닛의 0헤드 디자인 또는 1헤드 디자인을 선택하여 사용하도록 할 수도 있다. 또한 단락[62] 및 이후에 인입되어 데이터 집합에서의 비트0과 비트1 비율을 변화하는 기술은 이상에서 제기한 기타 인이기술과 함께 사용하면 무작위 집합에 응용되어 압축할 수 있다. 도표32와 도표34b에서의 시나리오(a)와 (b)의 비트 사용결과를 통해 유의해야 할 것은, 처리유닛에 모든 3개의 고유 코드값이 존재하는 상황에서 데이터 분포모드의 적은 변화와 적은 비트를 사용하여 이러한 모드를 나타내 므로 RP코딩을 사용하거나 또는 코드 향상과 코드 생략의 코드 조절기술을 사용하는 것과 관계 없이 더 용이하 게 인코딩할 수 있다. 따라서 아래의 종료 조건을 변화함으로써 이상에서 제기한 디자인을 진일보로 개선할 수 있는데 상기 디자인은 상이한 수량의 코드유닛을 가지는 처리유닛을 사용한다. 사용한 임의의 처리유닛은 응당 v1, v2와 v3의 모든 3개의 고유 코드값(즉 0, 10과 11)을 포함해야 한다. 따라서 v1, v2와 v3의 3개의 고유 코드값이 나타나고 종료점이 상기 코드유닛에서 정지될 때까지 반드시 그를 크기가 5개인 코드유닛 또는 6개인 코드유닛(이로써 유추함)인 처리유닛으로 대체함으로써 이상에서 토론한 시 나리오(c)를 제거 및 대체하며 상기 코드유닛은 제일 마지막으로 나타나는 아래 트리오의 고유 코드값 v1, v2와 v3을 포함한다. 또한 시나리오 분류 코드는 이로써 다음과 같이 변경된다. 도표39a"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 118, "content": "도표39b"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 119, "content": "상기 시나리오 분류 코드는 모두 비트0으로 끝나고 만약 이렇게 디자인하게 되면 비트1에서 종료되는 시나리오 분류 코드가 존재하지 않게 된다. 또는 비트1에서 종료되는 시나리오 분류 코드는 시나리오(c)와 유사한 바, 시 나리오(c)의 처리유닛의 수량은 고정된 것이고 상기 처리유닛은 상기 점까지 하나 또는 두개의 고유값만 포함, 즉 시나리오(c)를 대체하며 4코드유닛은 3개보다 적은 고유값을 포함하고 5코드유닛은 3개보다 적은 고유값을 포함하며 6코드유닛 또는 7코드유닛은 이로써 유추되는데 이는 시나리오 코드가 가지는 이진 비트수에 의해 결 정된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 120, "content": "[104] 따라서 시나리오(a)와 (b)의 비트 사용도표는 아래와 같이 수정될 수 있다. 도표40 3개의 고유 코드값이 랭크와 자리방면에서의 6가지 가능한 조합의 RP코드분포 상황 RP코드 비트 +/- 조합 비트 코드 랭크와 자리방면 0/10 00 1/2+2 -1/-2 v1v2v3 5 0/10 01 1/2+2 -1/-2 v1v3v2 5 0/10 100 1/2+3 -1/-1 v2v1v3 5 0/10 101 1/2+3 0/-1 v2v3v1 5 0/10 110 1/2+3 0/-1 v3v1v2 5 0/10 111 1/2+3 0/-1 v3v2v1 5 도표41 시나리오(b)의 3개의 서브 시나리오 및 코드 향상과 코드 생략 코드 자리＆ 코드 향상＆코드 생략 코드값 시나리오 코드 내용코드 제4 제1 제2 제3 비트 제4 제3 제2 제1 비트 +/- v1 v2 v2 v3 7 0/10 0 1 0 0 1/2+4 -2/-1 v1 v2 v3 v2 7 0/10 0 0 1 0 1/2+4 -2/-1 v1 v2 v3 v3 7 0/10 0 1 1 [] 1/2+3 -3/-2 v1 v3 v2 v2 7 0/10 0 0 0 [] 1/2+3 -3/-2 v1 v3 v2 v3 7 0/10 0 1 0 1 1/2+4 -2/-1 v1 v3 v3 v2 7 0/10 0 0 1 1 1/2+4 -2/-1 v2 v1 v1 v3 6 0/10 10 1 0 0 1/2+5 0/+1 v2 v1 v3 v1 6 0/10 10 0 1 0 1/2+5 0/+1 v2 v1 v3 v3 7 0/10 10 1 1 [] 1/2+4 -2/-1 v2 v3 v1 v1 6 0/10 10 0 0 [] 1/2+4 -1/0 v2 v3 v1 v3 7 0/10 10 1 0 1 1/2+5 -1/0 v2 v3 v3 v1 7 0/10 10 0 1 11 1/2+5 -1/0 v3 v1 v1 v2 6 0/10 11 1 0 0 1/2+5 0/+1 v3 v1 v2 v1 6 0/10 11 0 1 0 1/2+5 0/+1 v3 v1 v2 v2 7 0/10 11 1 1 [] 1/2+4 -2/-1 v3 v2 v1 v1 6 0/10 11 0 0 [] 1/2+4 -1/0 v3 v2 v1 v2 7 0/10 11 1 0 1 1/2+5 -1/0 v3 v2 v2 v1 7 0/10 11 0 1 1 1/2+5 -1/0 도표40에서 알 수 있다 시피 시나리오(a)가 하나의 비트0을 사용하고 현재 시나리오3 코드유닛으로 다시 명명되 므로 인코딩결과는 이러한 시나리오에 더 양호할 수 있다. 도표41에서의 시나리오4 코드유닛의 비트 사용결과는단지 그 전과 동일할 뿐이다. 그러나 수많은 다른(또는 제일 나쁜 상황에서 심지어는 무한하게) 상이한 크기의 처리유닛이 존재할 가능성을 고려하여 반드시 더 간단한 논리가 존재하여 발생할 가능성이 있는 무한한 수량의 시나리오를 프로그래밍하도록 한다. 따라서 모든 이러한 시나리오를 인코딩하는 논리는 다음과 같이 변화할 수 있다. (a)모든 관련된 코드유닛의 정의를 사용하여 진입한 3개의 연속된 데이터 코드값을 판독하고 종료 조건에 부합 되는지 여부를 결정하되, 상기 종료 조건은 현재까지 판독한 연속된 데이터 코드값으로서 디자인한 코드유닛에 근거한 모든 고유 데이터 코드값[즉 이러한 상황에서 현재까지 판독한 코드유닛이 모든 3개의 고유 코드값을 포 함하지 않을 경우 단계(b)로 넘어가고 그러지 않을 경우 단계(c)로 넘어감]을 포함한다. (b)1개의 데이터 코드값[즉 현재까지 앞에서 판독한 코드유닛이 모든 3개의 고유 코드값을 포함하지 않을 경 우]을 판독하고 판독한 코드유닛이 모든 3개의 고유 코드값[즉 이러한 상황에서의 종료 조건]을 포함할 때까지 매번마다 종료 조건을 만족하는지 여부를 평가하며 만약 종료 조건을 만족하면 단계(c)로 넘어간다. (c)이렇게 판독한 데이터 코드값이 모든 고유 데이터 코드값[3값 코드유닛의 이러한 상황에서는 3]을 포함할 경 우 이렇게 판독한 데이터 코드값의 수량을 계산하고 대응되는 시나리로 분류 코드값을 결정하는 동시에 이를 기 입하며 그 다음 판독과 완전히 같도록 제일 마지막에 판독한 데이터 코드값을 기입한다. (d)1비트코드를 사용하고 기입하여 존재하는 별도의 두개의 고유 코드값에서의 어느 하나[3값 코드유닛의 이러 한 상황에 대하여, 비트0은 단계(c)에서 판독하고 기입한 제일 마지막 하나의 고유 데이터 코드값을 제외한 나 머지 두개의 고유 데이터 코드값의 제일 높은 랭크의 고유 데이터 코드값에 사용되고 비트1은 비교적 낮은 랭크 의 하나의 코드값에 사용되며 반대로 적합한 상황에서 이는 디자인에 의해 결정됨]를 식별하여 처음으로부터 제 1 자리에서 판독한 하나의 코드값[본 단계(d)에서 제기한 비트0 또는 비트1을 사용하여 이를 대체하거나 인코딩]을 제일 마지막 자리 이전의 하나의 코드값이 될 때까지 기입하며 적합한 상황에서 내용코드 조절 기술 [적합한 상황에서 내용코드 랭크와 자리코딩, 내용코드 향상, 내용코드 생략, 내용코드 강등 및 내용코드 복구 를 포함]을 사용한다. (e)처리중의 처리유닛을 인코딩, 즉 단계(a)에서 판독한 제일 마지막 한 자리 이전의 하나의 데이터 코드를 인 코딩한 후 암호화되지 않은 코드유닛이 시작된 점에 도달할 때까지 순환적으로 단계(a)로 돌아간다. 이상에서 수정한 인코딩 단계에 따라 아래와 같이 시나리오3 코드유닛으로부터 시작되는 비트 사용도표를 수정 할 수 있다. 도표42 시나리오3 코드유닛의 인코딩과 비트 사용 코드 자리＆ 코드값 시나리오 코드 내용코드 코드 조절 제3 제1 제2 비트 제3 제1 제2 비트 +/- v1 v2 v3 5 0/10 0 0 [] 1/2+2 -2/-1 v1 v3 v2 5 0/10 0 1 [] 1/2+2 -2/-1 v2 v1 v3 5 0/10 10 0 [] 1/2+3 -1/0 v2 v3 v1 5 0/10 10 1 [] 1/2+3 -1/0 v3 v1 v2 5 0/10 11 0 [] 1/2+3 -1/0 v3 v2 v1 5 0/10 11 1 [] 1/2+3 -1/0 여기서 []는 논리적 추론을 통한 코드 생략을 대표하고 제1 자리의 데이터 코드값을 인코딩하는 비트0과 비트1 은 적합한 상황에서 코드 향상을 사용하는 코드 조절이다. 도표43 시나리오4 코드유닛의 인코딩과 비트 사용 코드 자리＆ 코드 향상＆코드 생략 코드값 시나리오 코드 내용코드 제4 제1 제2 제3 비트 제4 제1 제2 제3 비트 +/- v1 v2 v2 v3 7 0/11 0 0 0 [] 1/2+3 -3/-2 v1 v2 v3 v2 7 0/11 0 0 1 0 1/2+4 -2/-1 v1 v2 v3 v3 7 0/11 0 0 1 1 1/2+4 -2/-1 v1 v3 v2 v2 7 0/11 0 1 0 0 1/2+4 -2/-1 v1 v3 v2 v3 7 0/11 0 1 0 1 1/2+4 -2/-1 v1 v3 v3 v2 7 0/11 0 1 1 [] 1/2+3 -3/-2 v2 v1 v1 v3 6 0/11 10 0 0 [] 1/2+4 -1/0 v2 v1 v3 v1 6 0/11 10 0 1 0 1/2+5 0/+1 v2 v1 v3 v3 7 0/11 10 0 1 1 1/2+5 -1/0 v2 v3 v1 v1 6 0/11 10 1 0 0 1/2+5 0/+1 v2 v3 v1 v3 7 0/11 10 1 0 1 1/2+5 -1/0 v2 v3 v3 v1 7 0/11 10 1 1 [] 1/2+4 -2/-1 v3 v1 v1 v2 6 0/11 11 0 0 [] 1/2+4 -1/0 v3 v1 v2 v1 6 0/10 11 0 1 0 1/2+5 0/+1 v3 v1 v2 v2 7 0/10 11 0 1 1 1/2+5 -1/0 v3 v2 v1 v1 6 0/11 11 1 0 0 1/2+5 0/+1 v3 v2 v1 v2 7 0/11 11 1 0 1 1/2+5 -1/0 v3 v2 v2 v1 7 0/11 11 1 1 [] 1/2+4 -2/-1 이상의 도면으로부터 알 수 있다 시피, 만약 시나리오3 코드유닛이 10을, 시나리오4 코드유닛이 0을 시나리오 분류 코드로 사용하면 모든 항목은 균등하거나 또는 비트 사용 절역결과를 가질 수 있다. 시나리오5 코드유닛의 인코딩과 비트 사용은 조금 길고 복잡하여 이를 나열할 수 없다. 그러나 인코딩은 동일한 논리를 따르므로 아래와 같이 비트 사용 결과를 간단하게 토론할 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 121, "content": "[105]시나리오4 코드유닛은 시나리오 코드10을 토론의 기초로 사용한다. 18개의 암호화 항목에 대하여 비트 사 용은 6개의 비트(즉 평균 10개 비트에서 4개 비트를 손실하게 됨)를 절약한다. 만약 시나리오5 코드유닛이 시나 리오 코드110을 사용하면 이는 그가 매 하나의 암호화 항목에 사용되는 시나리오 코드에서 하나의 비트를 더 사 용하게 됨을 의미하지만 이는 다른 한 부가적인 데이터 코드값에 대해 인코딩할 기회가 생기게 된다. 0헤드 디자인의 3값 코드유닛의 3개의 고유 데이터 코드값이 도표44에서의 빈도 분포는 우선권 요구에서의 상기 PCT출원에서 제기한 자동 프로그램을 작동함으로써 발생한다. 도표44 80000개의 무작위 비트를 사용하는 3값 코드유닛의 빈도분포 0 : 26536 10 : 13156 11 : 13576"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 122, "content": "[106] 알 수 있다 시피, v2와 v3의 빈도 카운트는 50%보다 좀 더 클 수 있는 바, 즉 대략 절반이고 v1은 50%보 다 좀 더 작을 수 있는 바, 이 또한 대략 절반이다. 따라서 데이터 코드값이 나타나는 약 절반의 가능성은 v1이 고 다른 절반의 25%는 v2이며 25%는 v3이다. 따라서 v1이 제5 데이터 코드값일 경우 다시 나타나는 부가적인 데 이터 코드값은 반드시 v2 또는 v3이므로 1개의 비트를 절약하는 확률은 절반이고 만약 v2 또는 v3이 제5 데이터 코드값이면 v1 또는 v3이 v2가 제5 데이터 코드값일 경우에 나오고 v1 또는 v2가 v3이 제5 데이터 코드값인 경 우에 나오므로 1비트를 절약할 기히는 절반의 절반이다. 따라서 평균을 놓고 볼 때 1개의 비트를 절약하는 기회 는 4분의 3인 바, 즉 4분의3개의 비트를 절약한다. 마찬가지로 논리적 추론을 통해 만약 제1 값, 제2 값과 제3 값이 동일한 고유 데이터 코드값이면 제4 값을 유도해낼 수 있으므로 이러한 상황에 사용되는 비트 사용은 2개 의 비트 또는 1개의 비트일 것이다. 따라서 총적으로 말하면 시나리오수가 4개의 코드유닛으로부터 5개의 코드 유닛 및 이후의 수의 유닛 등으로 증가할 경우 많은 손실이 없게 된다. 만약 시나리오4 코드유닛이 10(2비트)을 사용함을 고려할 경우 평균적으로 18개의 암호화 항목에서 6개의 비트의 비트 사용을 절약한다. 시나리오수가 3 개의 코드유닛으로부터 증가하기 시작함을 고려할 경우 이러한 시나리오에 사용되는 80000개의 무작위 비트의 빈도 분포는 감소되고 있어 전반적인 무작위 데이터 집합이 전체 비트 사용을 절약할 수 있는 가능성이 매우 크 다. 비트 사용을 절약하는 최적화 결과의 방식으로 처음 3개의 제일 빈번한 시나리오의 분포를 다시 조절할 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 123, "content": "[107] (a), (b)와 (c)의 순서가 2비트 , 2비트 와 1비트(비트0)를 가지는 시나리오 코드분포 배치에 근 거한 도표42[즉 시나리오3 코드유닛 또는 (a)], 도표43[즉 시나리오4 코드유닛 또는 (b)] 및 도표38[즉 시나리 오(c)]를 다시 심사하여 알 수 있다 시피 시나리오(a)에 있어서 이는 6개의 암호화 항목에서의 2개의 비트(2비 트를 절약하여 0개의 비트를 소모)를 절약하고 시나리오(b)에 있어서 이는 18개 항목에서의 6개의 비트(10개 비 트를 절약하여 4개 비트를 손실)를 절약하며 이는 또 45개 항목에서의 3개의 비트(즉 20개 비트를 절약하여 17 개 비트를 손실)를 절약한다. 모든 3개의 시나리오(a), (b)와 (c)가 모두 비트 사요을 절약한 것 같다. 그러나 결과는 여전히 이 세가지 시나리오에서의 매 한가지 상황에서의 매 하나의 암호화 항목의 빈도분포에 의해 결정 된다. 그러나 80000개의 무작위 비트의 이 세가지 시나리오를 사용하는 도표45에서의 빈도 분포는 우선권 요구 에서의 상기 PCT출원에서 나열한 자동 프로그램을 작동시켜 발생할 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 124, "content": "[108] 이렇게 발생한 도표45는 다음과 같이 나열된다. 도표45 80000개의 무작위 비트를 사용하는 시나리오의 빈도 분포 상황 10000 전부: 8449 cu3: 1606 cu4: 1578 cu5: 1292 cu6: 953 cu7: 774 cu8: 575 cu9: 422 cu10: 311 cu11: 238 cu12: 191 cu13: 143 cu14: 94 cu15: 56 cu16: 49 cu17: 42 cu18: 33 cu19: 18 cu20: 16 cu21: 6 cu22: 13 cu23: 7 cu24: 7 cu25: 10 cu26: 4 cu27: 1 cu28: 3 cu29: 2 cu30: 1 cu31: 2 cu32: 0 cu33: 0 cu34: 0 cu35: 0 cu36: 0 cu37: 0 cu38: 1 나머지: 1 이상의 도표45로부터 알 수 있다 시피 0헤드 디자인의 3값 코드유닛을 사용하여 무작위로 생성된 80000비트를 판독하고 종료 조건, 즉 3개의 고유 데이터 코드값이 응당 처리유닛에 저장되어야 한다는 종료 조건을 사용하지 만 일단 제일 마지막의 고유 데이터 코드값(종료값)이 나타나게 되면 이 80000개의 무작위 비트는 3개의 코드유 닛으로부터 38개의 코드유닛까지의 상이한 크기의 처리유닛을 발생하며 나머지는 암호화되지 않은 코드유닛이다. 3으로부터 38까지의 상이한 코드유닛 크기의 의러한 처리유닛은 도표45에 나열되는 바, 나열된 것은 그 중의 하나의 생성된 구현예로서 그들이 80000개의 무작위 비트에서 나타나는 빈도를 표시한다. 알 수 있다 시피 처리유닛의 빈도는 통상적으로 처리유닛 크기의 증가에 따라 축소되고 3개의 코드유닛으로부터 20개의 코드유닛은 상당히 안정된다. 8449개의 처리유닛에서 시나리오3 코드유닛 또는 (a) 및 4개의 코드유닛 또는 (b)의 빈도는 각각 1606과 1578이다. 따라서 시나리오(c)의 빈도는 8449-(1606+1578=3184 또는 37.68%)=5265 또는 62.32%이다. 80000개의 무작위 비트의 데이터 집합으로 생성된 이상의 한가닥 정보를 고려하여 인코딩 디자인에 다른 한가지 개선을 진행할 수 있다. 예하면 데이터 집합에서의 비트0 비율이 아닌 비트1 비율을 증가하고자 하는 경우이다. 도표46에서의 시나리오(a), (b)와 (c)에 대하여 아래의 코드를 시나리오 분류 코드(또는 시나리오 코드라고 약 칭)로 사용할 수 있다.도표46 시나리오(a), (b)와 (c)의 시나리오 코드분포 시나리오 코드 시나리오 ％ 1 (c) 62.32 01 (a) 19.01 00 (b) 18.67 시나리오(c)이 대부분의 처리유닛을 점유하므로 제일 짧은 시나리오 코드 비트1을 제공해야 하고 또 이는 비트1 비율을 증가하기 위한 것이므로 시나리오 코드의 1헤드 디자인을 사용한다. 같은 원인으로 시나리오(a)와 (b)는 각각 시나리오 코드 비트 01과 00으로 분포된다. 다른 한 개선은, 두개의 동일한 데이터 코드값이 서로 이웃하는 확률이 비교적 작다고 가정하는 상황에서 반대 되는 자리 배치를 이용하여 암호화된 데이터 코드를 배치, 즉 제4, 제3, 제2와 제1 자리의 반대순서에 따라 배 치하는 것인데 이는 시나리오(c)에 있어서는 유리한 것이며 제4 데이터 코드값이 나타나는 확률에 있어서는 다 음의 고유 데이터 코드값이 나타나는 확률을 증가한다. 더 중요한 것은, 진일보로 되는 분석을 거쳐 암호화된 데이터 코드는 그의 상대 자리의 반대에 따라 배치됨으로써 데이터 코드의 정렬에 다른 특성 또는 특징(상기 특 성은 제일 마지막 하나의 데이터 코드값이 제일 마지막 하나 이전의 한 데이터 코드값과 상이한지 여부)을 형성 하며 상기 특성 또는 특징은 압축하여 비트를 저장할 때에 충분히 이용되도록 한다. 상기 특징은 종료 조건의 디자인과 관련된다. 간단함을 위하여 우선 다른 한 유사한 종료 조건을 사용하여 설명할 수 있다. 현재 종료 조 건은 3개의 코드유닛에 정지되고 데이터 코드값은 단지 두 그룹 또는 두 부류로 분류될 수 있는데 하나는 3값 코드유닛을 가지는 모든 고유 데이터 코드값의 3코드유닛이고 다른 하나는 모든 고유 데이터 코드값을 가지지 않는 3코드유닛이다. 따라서 이는 제1 클라스에 3개의 고유 코드값이 존재하고 제2 클라스에 2개의 고유 코드값 이 존재하며 그 중 1개의 고유 코드값이 손실됨을 의미한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 125, "content": "[109] 따라서 도표45의 결과에 근거하여 이 두개의 클라스는 아래의 빈도(도표47에 나열된 바와 같이)를 가진다. 도표47 80000비트의 무작위 데이터 집합에서의 2부류의 처리유닛의 빈도분포: 1개 비트는 모든 3개의 고유 데이터 코드 값(클라스A)을 가지고 다른 1개의 비트는 3개보다 적은 고유 데이터 코드값(클라스B)을 가진다. 클라스 빈도 ％ A 1606 19 B 6843 81 합계 8449 100 클라스B는 절대다수의 데이터 코드값을 가진다. 그러나 이 특징에 근거하여 이러한 처리유닛을 구획할 수 있는 데 이 특징은 데이터 코드값이 그들의 상대자리에 대해 반대로 배치하는데 관한 것이다. 이러한 데이터 코드값 의 반대로의 배치에 대한 한가지 모드와 디자인은 우선 제3 데이터 코드값을 배치한 후 제2 데이터 코드값을 배 치하며 그 다음 제1 데이터 코드값을 배치하는 것이다. 따라서 모든 3개의 고유 데이터 코드값을 가지는 처리유 닛에 대하여 제3과 제2 데이터 코드값은 반드시 상이해야 하고 모든 3개의 고유 데이터 코드값을 가지지 않는 처리유닛에 대하여 제3과 제2 데이터 코드값의 값은 동일하거나 상이할 수 있다. 이러한 특징을 다른 한 분류표 준으로 사용하면 비트 저장방면에서 더 양호한 결과를 발생할 수 있다. 따라서 마찬가지로 대응되게 시나리오 코드를 분포할 수 있다. 따라서 서브 시나리오 코드 비트1을 그 중의 제3과 제2 데이터 코드값이 동일한 처리유 닛에 분포하고 비트0을 그 중의 제3과 제2 데이터 코드값이 상이한 처리유닛에 분포할 수 있다. 여기서 시나리 오 클라스0에 대하여 별도의 서브 시나리오 코드 비트를 분포하거나 또는 첸 코딩의 다른 한 신규 특징을 사용 하여 이러한 서브 시나리오 코드 비트와 내용코드 비트를 조합할 수 있는데 상기 신규 특징은 사후 분류의 용도 또는 사후 분류 코드가 첸 코드의 내용코드 내에서의 배치이다. 도표47에서의 종료 조건으 사용함으로써 3개의 3값 코드유닛의 처리유닛의 실제 인코딩을 사용하여 첸 코딩의 이러한 인코딩 기술을 더 잘 해석할 수 있는 바, 이는 아래의 도표48에 나열된 바와 같다.도표48 시나리오 클라스0과 시나리오 클라스1에 분포한 시나리오 코드: 인코딩과 비트 사용 및 비트1/비트0의 변화에 따라 변화 데이터 코드 내용코드 코드 조절 제3제2제1 비트 시나리오 제3 제2 제1 비트 +/- 비트1/비트0 코드값 코드 클라스B v1v1v1 3 1 0 [] 0 1+2 0 +1/-1 000 v1v1v2 4 1 0 [] 10 1+3 0 +1/-1 0010 v1v1v3 4 1 0 [] 11 1+3 0 +1/-1 0011 v2v2v2 6 1 10 [] 10 1+5 -1 0/-1 101010 v2v2v1 5 1 10 [] 0 1+3 -1 0/-1 10100 v2v2v3 6 1 10 [] 11 1+4 -1 0/-1 101011 v3v3v3 6 1 11 [] 11 1+4 -1 -1/0 111111 v3v3v1 5 1 11 [] 0 1+3 -1 -1/0 11110 v3v3v2 6 1 11 [] 10 1+4 -1 -1/0 111110 === === -6비트 0/-6 9개 항목 조합에서 v1v2v1 4 01 0 0 0 2+2 +1 0/+1 0100 v1v2v2 5 01 0 0 1 2+3 0 0/0 01010 v1v3v1 4 01 0 1 0 2+3 +1 0/+1 0110 v1v3v3 5 01 0 1 1 2+3 0 -1/+1 01111 v2v1v1 4 01 10 0 0 2+4 +2 +1/+1 1000 v2v1v2 5 01 10 0 1 2+4 +1 +1/0 10010 v2v3v2 6 01 10 1 0 2+4 0 -1/+1 101110 v2v3v3 6 01 10 1 1 2+4 0 -1/+1 101111 v3v1v1 4 01 11 0 0 2+4 +2 +1/+1 1100 v3v1v3 5 01 11 0 1 2+4 +1 0/+1 11011 v3v2v2 6 01 11 1 0 2+4 0 0/0 111010 v3v2v3 6 01 11 1 1 2+4 0 0/0 111011 === === +8비트 0/+8 12개 항목 조합에서 클라스A v1v2v3 5 00 0 0 [] 2+2 -1 -3/+2 01011 v1v3v2 5 00 0 1 [] 2+2 -1 -2/+1 01110 v2v1v3 5 00 10 0 [] 2+3 0 -2/+2 10011 v2v3v1 5 00 10 1 [] 2+3 0 -1/+1 10110 v3v1v2 5 00 11 0 [] 2+3 0 -1/+1 11010 v3v2v1 5 00 11 1 [] 2+3 0 0/0 11100 === ==== -2 -9/+7 6개 항목 조합에서 이상으로부터 알 수 있다 시피 결과는 매우 근접하다. 도표48에서의 시나리오 코드1이 분포된 처리유닛의 인코 딩 논리는 다음과 같다. (a) 숫자 데이터 입력에서 데이터 코드값을 판독한 후, 또한 처리 중인 처리유닛의 데이터 분포의 성질을 결정 한 후 만약 처리유닛이 그 중의 제3과 제2 데이터 코드값이 동일한 클라스에 속하면 시나리오 크드비트1을 기입 한다. (b)제3 데이터 코드값을 그대로 기입한다. (c)논리를 통해 제2 데이터 코드값을 생략하되, 제2 데이터 코드값과 제3 데이터 코드값이 동일하므로 논리적 추론을 통해 생략할 수 있다. (d)코드유닛을 디자인하여 판독한 원시적인 데이터 코드값을 사용하여 제 데이터 코드값을 기입하되, 처리유닛 이 모든 3개의 고유 데이터 코드값을 가지는 처리유닛이므로 이는 하나 또는 두개의 데이터 코드값만 가질 수 있다. 하나의 데이터 코드값이 이미 제3 데이터 코드값으로 나타났으나 세가지 옵션이 선택할 수 있도록 제공되 므로 제1 비트 자리값은 직접적으로 판독 및 기입(또는 제3 자리에 존재하는 코드값이 비트0으로 향상되고 기타 두개의 나머지 값이 그들의 상대 랭크에 근거하여 비트10 또는 비트11로 조절되며 제1 비트 자리값은 그 다음 이러한 조절을 거친 코드를 사용함)할 수밖에 없다. 도표48에서의 시나리오 코드0이 분포된 처리유닛에 대해 인코딩하면 다음과 같다. (i) 숫자 데이터 입력에서 데이터 코드값을 판독한 후, 또한 처리 중인 처리유닛의 데이터 분포의 성질을 결정 한 후 만약 처리유닛이 그 중의 제3과 제2 데이터 코드값이 상이하고 그 중에 모든 고유 데이터 코드값이 존재 하는 클라스에 속하면 그를 위해 시나리오 크드비트1을 기입하며; 만약 처리유닛이 그 중의 제3과 제2 데이터 코드값이 상이하지만 그 중에 모든 고유 데이터 코드값이 존재하지 않는 클라스에 속하면 그를 위해 시나리오 코드비트01을 기입한다. (ii)제3 데이터 코드값을 그대로 기입한다. (iii)아래의 인코딩 논리를 사용하여 시나리오 코드00을 가지는 처리유닛을 위해 제2 데이터 코드값을 기입하되, 그가 모든 고유 데이터 코드값을 가지고 하나의 데이터 코드값이 이미 제3 데이터 코드값으로 나타날 경우 여전히 두개의 옵션을 선택할 수 있으므로 하나의 비트를 사용하여 어느 하나를 제2 데이터 코드값(비트0 은 비교적 작은 값에 사용되고 비트1은 비교적 큰 값에 사용되며 적합한 상황에서 0헤드 디자인에서는 v1을 제 일 작은 값으로, v3을 제일 큰 값으로 디자인 할 수 있음)으로 나타나도록 지시하거나; 또는 아래의 인코딩 논 리를 사용하여 시나리오 코드01을 가지는 처리유닛을 위해 제2 데이터 코드값을 기입하되, 그가 모든 고유 데이 터 코드값을 가지지 않고 하나의 데이터 코득값이 이미 제3 데이터 코드값으로 나타날 경우 여전히 2개의 선택 (두개의 고유값이 존재하지 안ㅎ음)이 있을 수 있어 선택할 수 있으며 이 시나리오 클라스0이 그 중의 제3과 제 2 데이터 코드값이 상이한 클라스로 정의되므로 하나의 비트를 사용하여 어느것이 제2 데이터 코드값(비트0은 비교적 작은 값v1에 사용되고 비트1은 비교적 큰 값v3에 사용됨)으로 나타날 것인지를 지시할 수 있다. (iv)시나리오 코드00이 분포된 처리유닛에 대하여 제1 데이터 코드값을 생략할 수 있는 바, 시나리오 코드01이 분포되어 있는 처리유닛에 대하여 아래의 인코딩 논리를 사용하여 제1 데이터 코드값을 인코딩하고 기입할 수 있는데 두개의 상이한 데이터 코드값이 이미 제3과 제2 자리에 나타날 경우 시나리오 클라스01은 그 중에 전부 의 3개의 고유 데이터 코드값이 존재하지 않으며 이는 제1 자리에서의 데이터 코드값이 반드시 제3과 제2 자리 에서의 두개의 값에서의 하나이므로 다른 한 비트를 사용하여 제1 자리 데이터 코드값(비트0은 비교적 작은 값 v1에 사용되고 비트1은 비교적 큰 값v3에 사용됨)을 인코딩하고 기입한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 126, "content": "[110]한가지 형식으로 사후 분류를 사용하게 되면 진일보로 조금씩 비트 저장을 감소시키는데 도움이 될 수 있 다. 본 구현예에서는 사후 분류 코드의 배치가 두가지 방식으로 완성될 수 있다. (a)시나리오 코드00과 01이 분포된 처리유닛에 대하여 제2 비트는 그가 클라스A(모든 고유 데이터 코드값을 가 지는 클라스)에 속하는지 아니면 클라스B(모든 고유 데이터 코드값을 가지지 않는 클라스)에 속하는지를 구분하 는데 사용된다. 아래의 내용코드를 조합하는 것을 통해 시나리오 코드의 제2 비트를 생략할 수 있는데 클라스A 에서의 제2 데이터 코드값의 비트(또한 제2 데이터 코드값에 사용되는 비트를 가짐)를 인코딩하고 클라스B의 제 1 데이터 코드값의 비트를 조합하는데 사용되므로 이러한 암호화된 코드는 6가지 조합으로 나타내고 도표49에서 의 아래의 분포에 이 6가지 조합의 암호화된 코드값을 기입한 후 2비트 또는 3비트를 사용한다.도표49"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 127, "content": "이상의 분포를 사용함으로써 시나리오 코드00과 01의 제2 비트를 취소할 수 있고 이러한 처리유닛을 위해 기입 한 첫번째 암호화된 코드는 시나리오 코드0이며, 그 다음 이어서 기입한 제3 데이터 코드값이 판독된 바와 같고, 그 다음 이어서 이상에서 2비트부터 3비트가 결합된 시나리오와 내용코드를 기입한다. 비트 사용방면에서 비트 사용의 결과는 도표48에서 발생한 결과와 완전히 동일하다. 또한, (b)그러나 아래의 논리를 사용함으로써 시나리오 코드와 내용코드를 서로 결합하는 다른 한 새로운 방법이 존재 한다. (i)시나리오 코드0을 인코딩하고 기입하며 시나리오 코드0에서의 그러한 처리유닛의 제3 데이터 코드값과 제2 데이터 코드값에 사용될 경우(제2 비트는 제거하도록 디자인됨) 하나의 종료 코드를 창조할 수 있는데 상기 종 료 코드는 시나리오 코드0의 제2 비트와 시나리오 코드0에서의 클라스B의 제1 데이터 코그밧의 내용코드가 병합 되어 형성된 것으로서 도표50에서 아래와 같이 나타낼 수 있다. 도표50"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 128, "content": "또한 디코딩할 경우 이러한 종료 코드를 사용하여 원시적인 숫자 데이터 정보를 정확하게 복구하도록 한다. 이는 데이터 분포에 관한 처리유닛의 빈도 분포에 의해 결정된다. 상기 기술은 더 양호한 비트 저장의 절약에 사용될 수 있다. 상기 80000비트의 구현에서 사용하는 무작위 데이터 집합, 클라스B 처리유닛의 빈도는 처리유 닛의 총수(도표45에서 나열한 바와 같이 8449)에서 6843이다. 이 6843에는 약 절반이 시나리오01에 사용되고 또 그 중의 절반이 제1 데이터 코드값을 가지며 인코딩할 경우 비트0을 사용하는데 이 값은 지금 종료 코드비트1로 표시되고 시나리오 코드01의 제243개의 처리유닛의 비트는 제거되므로 이 6843개의 처리유닛의 절반에 대하여 1 비트를 절약하는 바, 이는 약 3422/2, 즉 약 1711비트를 절약하게 된다. 또한 이러한 6843개의 처리유닛의 다른 절반의 종료 코드는 비트01의 종료 코드를 사용하므로 종료 코드의 2비트로 시나리오 코드01의 원래의 제2 비트 를 대체하고 원래의 제1 데이터 코드값의 암호화된 코드의 비트0/1을 나타낸다. 따라서 이 절반의 클라스B 처리 유닛의 비트 사용은 손실이 없다. 시나리오 코드00에서의 클라스A 처리유닛에 대하여 이가 비트00의 종료 코드 를 사용하므로 현재 제거된 시나리오 코드00의 원래의 제2 비트는 종료 코드의 2비트에서의 1비트를 차지할 수 있고; 논리가 그의 제1 데이터 코드값을 생략하므로 이에 사용되는 종료 코드의 기타 비트는 고려되지 않아 비 트 사용의 소모를 대표하게 된다. 또한 이러한 클라스A 처리유닛에 사용되는 빈도는 1606이다. 이상에서 클라스 B 처리유닛을 위해 절약한 1711개 비트에 대하여 나머지 결산은 1711에서 1606을 덜어=105비트의 비트 사용을 절약한다. 80000개의 무작위 비트에서 이의 신규 특징은 약 105개의 비트를 절약하는데 도움이 될 수 있다. 현 재까지 제출한 기술은 기타 시나리오, 예하면 시나리오(a), (b)와 (c) 또는 시나리오3 코드유닛, 4코드유닛과 나머지 코드유닛을 사용하는데 응용될 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 129, "content": "[111]두개의 시나리오 0과 1로 분류된 클라스A와 클라스B의 처리유닛의 선행 구현예는 데이터 코드값이 어떻게 혼합 분류하고 내용코드에서 조합 분류하며 사후방식으로 배치할 수 있는지를 나타내는데 이는 앞 자리에서의 상용적인 배치와 반대된다. 데이터 분류의 다른 한 신규 특징은 임베디드방식 또는 내부 분류 코드에만 사용될 수 있다. 도표51은 이러한 신규 특징을 사용하는 결과를 나타낸다. 도표51a 사전 분류 코드와 클라스A 처리유닛 데이터 코드 내용코드 코드 조절 제3제2제1 비트 신 제3 제2 제1 비트 +/- 비트1/비트0 코드값 코드 클라스A v1v2v3 5 00 0 0 [] 2+2 -1 -3/+2 01011 v1v3v2 5 00 0 1 [] 2+2 -1 -2/+1 01110 v2v1v3 5 00 10 0 [] 2+3 0 -2/+2 10011 v2v3v1 5 00 10 1 [] 2+3 0 -1/+1 10110 v3v1v2 5 00 11 0 [] 2+3 0 -1/+1 11010 v3v2v1 5 00 11 1 [] 2+3 0 0/0 11100 === ==== -2 -9/+7 6개 항목조합에서 이는 마침 도표48에서의 클라스A부분임; 도표51b 제3과 제2 데이터 코드값이 동일한 값인지 여부를 판단하는 표준을 사용하여 세부화한 클라스B 처리유닛의 내부 또는 임베디드방식의 분류 코드 데이터 코드 내용코드 코드 조절 제3제2제1 비트 제3 신 제2 제1 비트 +/- 비트1/비트0 코드값 코드 클라스B (여기서 제3과 제2는 상이함) v1v2v1 4 01 0 0 0 2+1+2 +1 0/+1 0100 v1v2v2 5 01 0 0 1 2+1+2 0 0/0 01010 v1v3v1 4 01 0 1 0 2+1+2 +1 0/+1 0110 v1v3v3 5 01 0 1 1 2+1+2 0 -1/+1 01111 v2v1v1 4 10 0 0 0 2+1+2 +1 0/+1 1000 v2v1v2 5 10 0 0 1 2+1+2 0 0/0 10010 v2v3v2 6 10 0 1 0 2+1+2 -1 -2/+1 101110 v2v3v3 6 10 0 1 1 2+1+2 -1 -2/+1 101111 v3v1v1 4 11 0 0 0 2+1+2 +1 0/+1 1100 v3v1v3 5 11 0 0 1 2+1+2 0 -1/+1 11011 v3v2v2 6 11 0 1 0 2+1+2 -1 -1/0 111010 v3v2v3 6 11 0 1 1 2+1+2 -1 -1/0 111011 === === 0비트 0/+8 12개의 항목조합에서 클라스B (여기서 제3과 제2는 동일함) v1v1v1 3 01 1 [] 0 2+1+1 +1 +2/-1 000 [0으로 기입하고 01을 기입할 필요가 없는데 이는 그가 헤드가 아닌 내용코드에서 사용하기 때문이다] v1v1v2 4 01 1 [] 10 2+1+2 +1 +2/-1 0010 [10원래대로 기입] v1v1v3 4 01 1 [] 11 2+1+2 +1 +2/-1 0011 [11원래대로 기입] v2v2v2 6 10 1 [] 10 2+1+2 -1 0/-1 101010 v2v2v1 5 10 1 [] 0 2+1+1 -1 0/-1 10100 v2v2v3 6 10 1 [] 11 2+1+2 -1 0/-1 101011 v3v3v3 6 11 1 [] 11 2+1+2 -1 -1/0 111111 v3v3v1 5 11 1 [] 0 2+1+1 -1 -1/0 11110 v3v3v2 6 11 1 [] 10 2+1+2 -1 -1/0 111110 === === -3비트 +3/-6 9개의 항목조합에서 클라스A에 있어서 6개의 항목조합에는 2비트 절약이 존재하고 제3과 제2 데이터 코드값이 상이한 값을 가지는 클라스B에 대하여 12가지 조합에는 뚜렷한 절약이나 손실이 나타나지 않았으며 제3과 제2 데이터 코드값이 동일 한 값을 가지는 클라스B에 대하여 9개 항목조합에는 3비트 절약이 뚜렷이 존재한다. 상술한 바와 같이 기타 기 술, 예하면 본 구현예에서의 기술을 사용하기 전에 우선 비트0:비트1의 비율을 변화하거나 또는 전체 무작위 데 이터 집합에 사용되는 불균일 데이터를 가지는 슈퍼 처리유닛을 사용하는 기술을 사용할 수 있다. 또한 이는 단 지 본 구현예에서 제출한 기술을 사용하기 위하여 디자인한 수많은 가능한 시나리오에서의 한 구현예 일 뿐이다. 이상의 구현예의 분류는 분류 코드를 사용하는데 기반하는 바, 00의 4개의 클라스는 클라스A 처리유닛에 사용되 지만 새로운 것은 01,10과 11의 용도로서 실제적으로 그들은 내용코드 자체인 바, 단지 v1의 비트0부터 비트01 까지 약간 수정하여 이러한 내용코드로 하여금 분류 코드로 사용될 자격이 있도록 하며; 인코딩 처리에서 내용 코드의 일부로 사용될 경우 v1의 암호화된 코드값, 즉 01은 비교적 짧은 형식인 0으로 복구되는데 이는 내용코 드 부분내에서 틀리지 않을 것이며 인코딩 처리유닛의 헤드 부분의 분류 코드로 사용되지 않기 때문이다. 이상 의 구현예에서는 비록 수정이 존재하지만 이로써 내용코드를 분류 코드로 사용하는 이러한 기술의 유용성을 생 동하게 나타냈다. 이는 첸 코드를 발생하는 첸 코딩에 사용되는 다른 한가지 기술이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 130, "content": "[112] 도표52에 나타낸 바와 같이 분류 코드는 내용코드(약간 수정)를 사용하여 대체할 수 있는 바, 아래와 같 이 나타낸다. 도표52 제3과 제2 데이터 코드값이 동일한 값인지 여부를 판단하는 표준의 수정한 내용코드를 분류 코드로사용하여 클 라스B 처리유닛을 구획 데이터 코드 내용코드 코드 조절 제3제2제1 비트 제3 제2 제1 비트 +/- 비트1/비트0 코드값 클라스B (여기서 제3과 제2는 상이함) v1v2v1 4 01 10 0 5 +1 0/+1 0100 v1v2v2 5 01 10 1 5 0 0/0 01010 v1v3v1 4 01 11 0 5 +1 0/+1 0110 v1v3v3 5 01 11 1 5 0 -1/+1 01111 v2v1v1 4 10 0 0 4 0 0/+1 1000 v2v1v2 5 10 0 1 4 -1 0/0 10010 v2v3v2 6 10 11 0 5 -1 -2/+1 101110 v2v3v3 6 10 11 1 5 -1 -2/+1 101111 v3v1v1 4 11 0 0 4 0 0/+1 1100 v3v1v3 5 11 0 1 4 -1 -1/+1 11011 v3v2v2 6 11 10 0 5 -1 -1/0 111010 v3v2v3 6 11 10 1 5 -1 -1/0 111011 === === -4비트 0/+8 12개의 항목조합에서 클라스B (여기서 제3과 제2는 동일함) v1v1v1 3 01 0 0 4 +1 +2/-1 000 [0으로 기입하고 01을 기입할 필요가 없는데 이는 그가 헤드가 아닌 내용코드에서 사용하기 때문이다] v1v1v2 4 01 0 10 5 +1 +2/-1 0010 [10원래대로 기입] v1v1v3 4 01 0 11 5 +1 +2/-1 0011 [11원래대로 기입] v2v2v2 6 10 10 10 6 0 0/-1 101010 v2v2v1 5 10 10 0 5 0 0/-1 10100 v2v2v3 6 10 10 11 6 0 0/-1 101011 v3v3v3 6 11 11 11 6 0 -1/0 111111 v3v3v1 5 11 11 0 5 0 -1/0 11110 v3v3v2 6 11 11 10 6 0 -1/0 111110 === === +3비트 +3/-6 9개의 항목조합에서"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 131, "content": "[113] 상기 여러가지 분류 기술을 개시한 후 어떤 기술이 처리 중인 숫자 데이터 집합에 제일 유용한 것인지를 평가한다. 또한 선택하여 사용한 분류 기술에 근거하여 인코딩과 디코딩에 사용되는 데이터 코드값의 재분류와 재분포가 예정된 목적에 대하여 필요하고 적당한 것임을 발견했다. 도표53은 \"제일 유용한 기술은 데이터 코드 값을 정확히 분류하는 특성을 정확히 식별하는 것\"이라는 점을 고려한 결과이다. 토론하고 있는 본 디자인과 모 드에 있어서 이미 수많은 기술을 개발, 디자인하고 실현하여 앞의 단락에 나타난 도표에 사용했다. 관찰할 수 있다 시피, 일부 코드항목 조합이 비록 비트를 절약하였으나 기타 코드가 발생한 비트 손실은 이러한 절약을 상 쇄시키거나 심지어 이러한 절약보다 더 많다. 따라서 이러한 특성 또는 특징은 반드시 조사되어야 할 하나의 특 징인 바, 즉 이상에서 토론한 첸 코딩의 여러 가지 기술을 사용하여 인코딩을 진행할 경우 비트 손실이 있는 문 제의 항목 조합을 찾아내는 것이다. 만약 손실을 가져오는 문제가 있는 항목 조합을 조합하고 또 마찬가지로 절 약을 가져오는 양호한 항목 조합을 조합하게 되면 성공할 기회를 증가할 수 있게 됨은 자명한 것이다. 도표53은 여기서 이를 데이터 분류의 주요 표준으로 하고 그 다음의 인코딩에서 코드 향상, 코드 생략, 코드 대체 및 제 일 주요한 절대 어드레스 분기기술에 범위를 추가하여 사용하는 것을 포함하는 코드 조절과 같은 첸 코딩의 기 타 기술을 사용한다. 도표53 코드 재분포 이전에 압축 가능한 것과 압축 불가능한 데이터 값 항목에 의해 데이터를 분류하되 단락[75]에서의 도표21을 사용한 빈도를 가진다. 압축 불가능한 클라스: AAB기술을 사용하여 범위 인코딩을 진행(실제값 범위: 7, 하한값 범위: 4를 위한 2비트; 상한값 범위: 8을 위한 3비트) 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 v1v1v1 3 0 00 4 0 0/0 2273 000 v1v1v2 4 0 010 4 0 0/0 1175 0010 v1v1v3 4 0 011 4 0 0/0 1149 0011 v1v2v1 4 0 100 4 0 0/0 1123 0100 v1v3v1 4 0 101 4 0 0/0 1060 0110 v2v1v1 4 0 110 4 0 +1/-1 1045 1000 v3v1v1 4 0 111 4 0 +1/-1 1072 1100 === === 0 +2/-2 7개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 상이하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v2v1] 10 0 0 0 5 [기입하고자 하는 빈 코드 자리] [압축 불가능한 클라스에서 재조합] v1v2v2 5 10 0 0 1 5 0 0/0 531 01010 [v1v3v1] 10 0 1 0 5 [기입하고자 하는 빈 코드 자리] [압축 불가능한 클라스에서 재조합] v1v3v3 5 10 0 1 1 5 0 -1/+1 542 01111 [v2v1v1] 10 10 0 0 6 [기입하고자 하는 빈 코드 자리] [압축 불가능한 클라스에서 재조합] v2v1v2 5 10 10 0 1 6 +1 0/0 542 10010 v2v3v2 6 10 10 1 0 6 0 -1/+1 266 101110 v2v3v3 6 10 10 1 1 6 0 -1/+1 294 101111 [v3v1v1] 10 11 0 0 6 [기입하고자 하는 빈 코드 자리] [압축 불가능한 클라스에서 재조합] v3v1v3 5 10 11 0 1 6 +1 0/+1 561 11011 v3v2v2 6 10 11 1 0 6 0 0/0 277 111010 v3v2v3 6 10 11 1 1 6 0 0/0 279 111011 === === +2비트 -3/+4 12개의 항목조합에서 압축 가능한 클라스; 그 중 제3과 제2자리 값이 동일하고 코드 조절기술을 사용하여 인코딩한다. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v1v2] 11 0 [] 0 4 [기입하고자 하는 빈 코드 자리] [압축 불가능한 클라스에서 재조합] [v1v1v3] 11 0 [] 1 4 [기입하고자 하는 빈 코드 자리] [압축 불가능한 클라스에서 재조합] v2v2v1 5 11 10 [] 0 5 0 +1/-1 551 10100 v2v2v3 6 11 10 [] 1 5 -1 0/-1 288 101011 v3v3v1 5 11 11 [] 0 5 0 0/0 591 11110 v3v3v2 6 11 11 [] 1 5 -1 0/-1 262 111110 === === +2비트 +1/-3 6개의 항목조합에서 압축 가능한 클라스: 그 중 아래의 2개의 항목조합은 재분포의 예외인 바,적합한 곳에서 앞의 두개의 항목조합 과 상이하다. v2v2v2 6 276 101010 (코드 재기입을 통해 코드를 재분포함) v3v3v3 6 304 111111 (코드 재기입을 통해 코드를 재분포함) === === 2개의 항목조합 압축 가능한 클라스: 여기서 모든 3개의 코드값은 모두 유일한 것이고 암호화된 코드는 재분포 됨. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 v1v2v3 5 593 01011 v1v3v2 5 548 01110 v2v1v3 5 576 10011 v2v3v1 5 559 10110 v3v1v2 5 508 11010 v3v2v1 5 540 11100 ======= 6개의 항목조합에서"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 132, "content": "[114] 이상의 도표53에서 알 수 있다 시피 반드시 다음과 같은 2가지 유형의 코드 조절을 진행해야 한다. (a)코드교환; v2v1v2와 v3v1v3은 각각 원래의 코두가 사용하는 5비트의 암호화된 코드가 아닌 6비트의 암호화된 코드를 사용하여 비트 소모를 발생하게 되므로 그들의 암호화된 코드는 반드시 v2v2v3과 v3v3v2와 교환해야 하 는데 그 중 매 하나마다 모두 원래의 코드가 사용하는 6비트가 아닌 5비트를 사용하게 되어 비트 이득이 발생하 게 되며, 따라서 이러한 쌍 사이에 암호화된 코드를 교환함으로써 비트 사용의 평형을 이룰 수 있어 비트 소모 또는 비트 이득을 발생하지 않게 된다.(b)코드 재분포 또는 재분포 또는 재기입; 동일한 제3과 제2 값을 가지는 압축 불가능한 클라스에는 2개의 빈 코드 자리 또는 어드레스가 존재하는 바, 즉 v1v1v2와 v1v1v3의 이 두개의 빈 코드 어드레스의 암호화된 코드는 1100과 1101이고 이 2개의 암호화된 코드에서의 매 하나마다 4비트를 사용하며, 상이한 제3과 제2 값을 가지는 압축 불가능한 클라스에는 4개의 빈 코드 자리 또는 어드레스가 존재하여 이러한 4개의 빈 코드 어드레스의 암 호화된 코드에 다음과 같이 사용된다: v1v2v1, 암호화된 코드는 10000이고 5비트를 사용; v1v3v1, 암호화된 코 드는 10010이고 5비트를 사용; v2v1v1, 암호화된 코드는 101000이고 6비트를 사용; 및 v3v1v1, 암호화된 코드 는 101100이고 6비트를 사용. 따라서 지금 6개의 빈 코드 어드레스가 재기입이 필요하다. 우선 두개의 이상 항 목 조합을 사용하여 v2v2v2와 v3v3v3 이 두개의 빈 코드 자리를 기입할 수 있다. 그러므로 4개의 빈 코드 자리 만 남게 된다. 즉 2개는 4비트를 사용하고 2개는 5비트를 사용하여 압축 가능한 클라스의 6개의 항목 조합을 수 용하는데 여기서 처리유닛은 5비트를 사용하는 3개의 고유 데이터 코드값을 가진다. 따라서 모든 3개의 고유 데 이터 코드값을 가지는 5비트가 수용되지 않은 처리유닛의 앞의 두개를 사용하여 먼저 두개의 빈 코드자리를 재 기입 할 수 있고 나머지 4개의 수용되지 않은 5비트 처리유닛은 나머지 2개의 4비트 코드의 빈 어드레스에 남게 된다. 또한 도표54는 이러한 코드 재분포의 상황을 아래와 같이 나타낸다. 도표54 코드 재분포를 진행할 경우 압축 가능한 것과 압축 불가능한 데이터 값 항목의 데이터 분류에 의해 단락[75]에 서의 도표21을 사용한 빈도를 가진다. 압축 불가능한 클라스: AAB기술을 사용하여 범위 인코딩을 진행 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 v1v1v1 3 0 00 4 0 0/0 2273 000 v1v1v2 4 0 010 4 0 0/0 1175 0010 v1v1v3 4 0 011 4 0 0/0 1149 0011 v1v2v1 4 0 100 4 0 0/0 1123 0100 v1v3v1 4 0 101 4 0 0/0 1060 0110 v2v1v1 4 0 110 4 0 +1/-1 1045 1000 v3v1v1 4 0 111 4 0 +1/-1 1072 1100 === === 0 +2/-2 7개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 상이하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v2v1] 10 0 0 0 5 0 -2/+2 [아래와 같이 재기입] v1v2v3 5 593 01011 v1v2v2 5 10 0 0 1 5 0 0/0 531 01010 [v1v3v1] 10 0 1 0 5 0 -1/+1 [아래와 같이 재기입] v1v3v2 5 548 01110 v1v3v3 5 10 0 1 1 5 0 -1/+1 542 01111 [v2v1v1] 10 10 0 0 6 0 -1/+1 [아래와 같이 재기입] v2v2v2 6 276 101010 v2v1v2 5 [10 10 0 1 6 +1 0/0] 542 10010 이를 이용하여 교환 11 10 [] 1 5 0 +2/-2 v2v3v2 6 10 10 1 0 6 0 -1/+1 266 101110 v2v3v3 6 10 10 1 1 6 0 -1/+1 294 101111 [v3v1v1] 10 11 0 0 6 0 -3/+3 [아래와 같이 재기입] v3v3v3 6 304 111111 v3v1v3 5 [10 11 0 1 6 +1 0/+1] 561 11011 이를 이용하여 교환 11 11 [] 1 5 0 +1/-1 v3v2v2 6 10 11 1 0 6 0 0/0 277 111010 v3v2v3 6 10 11 1 1 6 0 0/0 279 111011 === === +2비트 -7/+7 8개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 동일하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v1v2] 11 0 [] 0 4 [기입하고자 하는 빈 코드 자리] [압축 불가능한 클라스에서 재조합] [v1v1v3] 11 0 [] 1 4 [기입하고자 하는 빈 코드 자리] [압축 불가능한 클라스에서 재조합] v2v2v1 5 11 10 [] 0 5 0 +1/-1 551 10100 v2v2v3 6 [11 10 [] 1 5 -1 0/-1] 288 101011 이를 이용하여 교환 10 10 0 1 6 0 -1/+1 v3v3v1 5 11 11 [] 0 5 0 0/0 591 11110 v3v3v2 6 [11 11 [] 1 5 -1 0/-1] 262 111110 이를 이용하여 교환 10 11 0 1 6 0 -1/+1 === === -2비트 -1/+1 6개의 항목조합에서"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 133, "content": "[115]그러므로 현재까지 나머지 4개의 비트 처리유닛에서의 두개를 반드시 사용하여 나머지 두개의 4비트의 빈 코드 어드레스를 재기입함으로써 매 하나의 자리를 위해 1비트를 절약하고 또 나머지 두개의 수용되지 않은 5비 트 처리유닛에 대해 반드시 AAB기술을 사용하여 그들로 하여금 2개의 6비트의 코드 어드레스(최저 빈도를 가지 는 항목 조합을 선택)를 배가하도록 해야 할 것 같으나 그들이 이미 기타 2개의 항목 조합에 의해 점유되어 3개 의 7비트의 항목 조합 및 2*(7-5+7-6)=6 비트 손실을 발생하게 된다. 그러나 이는 AAB기술의 적당한 용도로서 한가지 새로운 방식으로 새로운 코드 어드레스를 창조하는 것이 이의 목적이다. 따라서 AAB기술을 사용하여 2개 의 4비트의 빈 코드 어드레스에 한 비트를 추가하여 2*2개의 5비트의 빈 코드 어드레스를 획득함으로써 4개의 사용 가능한 5비트의 빈 코드 어드레스를 구성하여 모든 3개의 데이터 코드값을 가지는 4개의 5비트가 수용되지 않은 처리유닛을 충분히 포용하도록 하고 그 어떤 비트 손실도 초래하지 않는다. 최종 결과는 비트 사용 방면에 서 모두 균등한 바, 이 구현예에서 비트 이득 또는 비트 손실이 없다는 것에 대하여 아래 도표55에서 다음과 같 이 나열한다. 도표55 도표53에 나열된 코드 어드레스와 코드 항목값을 재분포 한 후 균등상황이 출현 압축 불가능한 클라스: AAB기술을 사용하여 범위 인코딩을 진행 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 v1v1v1 3 0 00 4 0 0/0 2273 000 v1v1v2 4 0 010 4 0 0/0 1175 0010 v1v1v3 4 0 011 4 0 0/0 1149 0011 v1v2v1 4 0 100 4 0 0/0 1123 0100 v1v3v1 4 0 101 4 0 0/0 1060 0110 v2v1v1 4 0 110 4 0 +1/-1 1045 1000 +1045/-1045 v3v1v1 4 0 111 4 0 +1/-1 1072 1100 +1072/-1072 === === ==== 0 +2/-2 8897 +2117/-2117 7개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 상이하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v2v1] 10 0 0 0 5 0 -2/+2 [아래와 같이 재기입] v1v2v3 5 593 01011 -1186/+1186 v1v2v2 5 10 0 0 1 5 0 0/0 531 01010 0/0 [v1v3v1] 10 0 1 0 5 0 -1/+1 [아래와 같이 재기입] v1v3v2 5 548 01110 -548/+548 v1v3v3 5 10 0 1 1 5 0 -1/+1 542 01111 -542/+542 [v2v1v1] 10 10 0 0 6 0 -1/+1 [아래와 같이 재기입] v2v2v2 6 276 101010 -276/+276 v2v1v2 5 [10 10 0 1 6 +1 0/0] 542 10010 이를 이용하여 교환 11 10 [] 1 5 0 +2/-2 +1084/-1084 v2v3v2 6 10 10 1 0 6 0 -1/+1 266 101110 -266/+266 v2v3v3 6 10 10 1 1 6 0 -1/+1 294 101111 -294/+294 [v3v1v1] 10 11 0 0 6 0 -3/+3 [아래와 같이 재기입] v3v3v3 6 304 111111 -912/+912 v3v1v3 5 [10 11 0 1 6 +1 0/+1] 561 11011 이를 이용하여 교환 11 11 [] 1 5 0 +1/-1 +561/-561 v3v2v2 6 10 11 1 0 6 0 0/0 277 111010 0/0 v3v2v3 6 10 11 1 1 6 0 0/0 279 111011 0/0 === === === 0비트 -7/+7 5013 -2379/+2379 12개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 동일하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v1v2] [11 0 [] 0 4] [AAB를 사용하여 2개로 분리] 11 0 [] 0 0 5 0 -1/+1 v2v1v3 5 576 10011 -576/+576 11 0 [] 0 1 5 0 0/0 v2v3v1 5 559 10110 0/0 [v1v1v3] 11 0 [] 1 4 [AAB를 사용하여 2개로 분리] 11 0 [] 1 0 5 0 0/0 v3v1v2 5 508 11010 0/0 11 0 [] 1 1 5 0 +1/-1 v3v2v1 5 540 11100 +540/-540 v2v2v1 5 11 10 [] 0 5 0 +1/-1 551 10100 +551/-551 v2v2v3 6 [11 10 [] 1 5 -1 0/-1] 288 101011 -288/+288 이를 이용하여 교환 10 10 0 1 6 0 -1/+1 v3v3v1 5 11 11 [] 0 5 0 0/0 591 11110 0/0 v3v3v2 6 [11 11 [] 1 5 -1 0/-1] 262 111110 -262/+262 이를 이용하여 교환 10 11 0 1 6 0 -1/+1 === === === 0비트 -1/+1 3875 -35/+35 ========= -297/+297 8개의 항목조합에서"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 134, "content": "[116] 이상의 압축 불가능한 클라스와 압축 가능한 클라스의 빈도는 약간 상이한 바, 그 중의 제1 클라스는 8897개의 처리유닛을 가지고 제2 클라스는 8888개의 처리유닛을 가진다. 그러나 제2 클라스가 시나리오10과 11 에 분포되므로 비대칭은 비트0 비율이 아닌 비트1 비율을 증가하는데 있다. 그러나 결과는 아주 놀라운 바, 1개 의 주기를 인코딩 한 후 도표55에 나타난 바와 같이 비트1은 297비트 감소하고 비트0은 297비트 증가한다. 따라 서 인코딩을 진행한 후 비트 이득 또는 비트 손실이 존재하지 않더라도 비트0:비트1 비율의 변화 방식은 데이터 로 하여금 압축될 수 있도록 하고 현재 인코딩 한 후 비트0과 비트1 사이의 비율 분포는 더 불균일하게 된다. 만약 반대되는 방식을 사용하여 시나리오 코드를 분포하면 다음의 도표56에서 비트0:비트1의 이득 또는 손실을 나타낸다. 도표56a 도표55에서 사용한 것과 다른 시나리오 코드를 사용하는 반대되는 분포 압축 불가능한 클라스: AAB기술을 사용하여 범위 인코딩을 진행 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 v1v1v1 3 1 00 4 0 +1/-1 2273 000 +2273/-2273 v1v1v2 4 1 010 4 0 +1/-1 1175 0010 +1175/-1175 v1v1v3 4 1 011 4 0 +1/-1 1149 0011 +1149/-1149 v1v2v1 4 1 100 4 0 +1/-1 1123 0100 +1123/-1123 v1v3v1 4 1 101 4 0 +1/-1 1060 0110 +1060/-1060 v2v1v1 4 1 110 4 0 +2/-2 1045 1000 +2095/-2095 v3v1v1 4 1 111 4 0 +2/-2 1072 1100 +2144/-2144 === === ==== 0 +9/-9 8897 +11019/-11019 7개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 상이하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v2v1] 01 0 0 0 5 0 -2/+2 [아래와 같이 재기입] v1v2v3 5 593 01011 -1186/+1186 v1v2v2 5 01 0 0 1 5 0 0/0 531 01010 [v1v3v1] 01 0 1 0 5 0 -1/+1 [아래와 같이 재기입] v1v3v2 5 548 01110 -548/+548 v1v3v3 5 01 0 1 1 5 0 -1/+1 542 01111 -542/+542 [v2v1v1] 01 10 0 0 6 0 -1/+1 [아래와 같이 재기입] v2v2v2 6 276 101010 -276/+276 v2v1v2 5 [01 10 0 1 6 +1 +1/0] 542 10010 이를 이용하여 교환 00 10 [] 1 5 0 0/0 0/0 v2v3v2 6 01 10 1 0 6 0 -1/+1 266 101110 -266/+266 v2v3v3 6 01 10 1 1 6 0 -1/+1 294 101111 -294/+294 [v3v1v1] 01 11 0 0 6 0 -3/+3 [아래와 같이 재기입] v3v3v3 6 304 111111 -912/+912 v3v1v3 5 [01 11 0 1 6 +1 0/+1] 561 11011 이를 이용하여 교환 00 11 [] 1 5 0 -1/+1 -561/+561 v3v2v2 6 01 11 1 0 6 0 0/0 277 111010 v3v2v3 6 01 11 1 1 6 0 0/0 279 111011 === === === 0비트 -11/+11 5013 -4585/+4585 12개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 동일하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v1v2] [00 0 [] 0 4] [AAB를 사용하여 2개로 분리] 00 0 [] 0 0 5 0 -3/+3 v2v1v3 5 576 10011 -1728/+1728 00 0 [] 0 1 5 0 -2/+2 v2v3v1 5 559 10110 -1118/+1118 [v1v1v3] 00 0 [] 1 4 [AAB를 사용하여 2개로 분리] 00 0 [] 1 0 5 0 -2/+2 v3v1v2 5 508 11010 -1016/+1016 00 0 [] 1 1 5 0 -1/+1 v3v2v1 5 540 11100 -540/+540 v2v2v1 5 00 10 [] 0 5 0 -1/+1 551 10100 -551/+551 v2v2v3 6 [00 10 [] 1 5 -1 0/-1] 288 101011 -288/+288 이를 이용하여 교환 01 10 0 1 6 0 -1/+1 v3v3v1 5 00 11 [] 0 5 0 -2/+2 591 11110 -1182/+1182 v3v3v2 6 [00 11 [] 1 5 -1 0/-1] 262 111110 -262/+262 이를 이용하여 교환 01 11 0 1 6 0 -1/+1 === === === 0비트 -13/+13 3875 -6685/+6685 ========= -251/+251 8개의 항목조합에서 사실이 증명하다 싶이 80000비트의 무작위 데이터 집합에 대한 비대칭 축소는 단지 비트1에서 251을 감소하고 비트0에 동일한 양을 증가하는 것이다. 이상으로부터 알 수 있다 시피 마스터헤드에서의 지정자는 시나리오 코드를 어떻게 분포할 것인지를 지시하기 위해 보류될 수 있고, 마찬가지로 코드유닛을 0헤드 디자인으로 사용하거나 또는 코드유닛을 1헤드 디자인으로 사용하여 숫자 데이터를 판독할지 여부를 지시하기 위해 보류될 수 있으며 또 어느 헤드 디자인이 데이터 값을 판독한 후 데이터 값을 인코딩하는데 사용되는지를 지시하기 위해 보류될 수 있는데 이는 그들이 동일할 필요가 없기 때문이다. 이러한 변동은 획득한 첸 코드 암호화에서의 비트0:비트1의 비율에 영향을 미칠 수 있다. 이러 한 지정자는 최적의 시나리오를 선택하여 인코딩하는 목적에 부합되도록 하기 위한 것이다. 비트0:비트1의 비율을 진일보로 변화하기 위하여 진일보로 도표56a를 코드유닛을 1헤드 디자인으로 사용한 하나 로 변화할 수 있는데 이는 아래에 나타낸 바와 같다. 도표56b 반대되는 분포를 사용하여 도표56a에서 사용한 0헤드 디자인과는다른 1헤드 디자인의 코드유닛의 내용코드에 사 용 압축 불가능한 클라스: AAB기술을 사용하여 범위 인코딩을 진행 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 v1v1v1 3 1 11 4 0 +3/-3 2273 000 +6819/-6819 v1v1v2 4 1 101 4 0 +2/-2 1175 0010 +2350/-2350 v1v1v3 4 1 100 4 0 0/0 1149 0011 0/0 v1v2v1 4 1 011 4 0 +2/-2 1123 0100 +2246/-2246 v1v3v1 4 1 010 4 0 0/0 1060 0110 0/0 v2v1v1 4 1 001 4 0 +1/-1 1045 1000 +1045/-1045 v3v1v1 4 1 000 4 0 -1/+1 1072 1100 -1072/+1072 === === ==== 0 +7/-7 8897 +11388/-11388 7개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 상이하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v2v1] 01 1 1 1 5 0 +1/-1 [아래와 같이 재기입] v1v2v3 5 593 01011 +593/-593 v1v2v2 5 01 1 1 0 5 0 +1/-1 531 01010 +531/-531 [v1v3v1] 01 1 0 1 5 0 0/0 [아래와 같이 재기입] v1v3v2 5 548 01110 0/0 v1v3v3 5 01 1 0 0 5 0 -2/+2 542 01111 -1084/+1084 [v2v1v1] 01 01 1 1 6 0 +1/-1 [아래와 같이 재기입] v2v2v2 6 276 101010 +276/-276 v2v1v2 5 [01 10 0 1 6 +1 0/0] 542 10010 이를 이용하여 교환 00 01 [] 0 5 0 -1/+1 -542/+542 v2v3v2 6 01 01 0 1 6 0 -1/+1 266 101110 -266/+266 v2v3v3 6 01 01 0 0 6 0 -3/+3 294 101111 -882/+882 [v3v1v1] 01 00 1 1 6 0 -3/+3 [아래와 같이 재기입] v3v3v3 6 304 111111 -912/+912 v3v1v3 5 [01 11 0 1 6 +1 0/+1] 561 11011 이를 이용하여 교환 00 00 [] 0 5 0 -4/+4 -2244/+2244 v3v2v2 6 01 00 0 1 6 0 -2/+2 277 111010 -554/+554 v3v2v3 6 01 00 0 0 6 0 -4/+4 279 111011 -1116/+1116 === === === 0비트 -17/+17 5013 -6200/+6200 12개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 동일하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v1v2] [00 0 [] 0 4] [AAB를 사용하여 2개로 분리] 00 1 [] 1 1 5 0 0/0 v2v1v3 5 576 10011 0/0 00 1 [] 1 0 5 0 -1/+1 v2v3v1 5 559 10110 -559/+559 [v1v1v3] 00 0 [] 1 4 [AAB를 사용하여 2개로 분리] 00 1 [] 0 1 5 0 -1/+1 v3v1v2 5 508 11010 -508/+508 00 1 [] 0 0 5 0 -2/+2 v3v2v1 5 540 11100 -1080/+1080 v2v2v1 5 00 01 [] 1 5 0 0/0 551 10100 0/0 v2v2v3 6 [00 10 [] 1 5 -1 0/-1] 288 101011 -288/+288 이를 이용하여 교환 01 01 1 0 6 0 -1/+1 v3v3v1 5 00 00 [] 1 5 0 -3/+3 591 11110 -1773/+1773 v3v3v2 6 [00 11 [] 1 5 -1 0/-1] 262 111110 -786/+786 이를 이용하여 교환 01 00 1 0 6 0 -3/+3 === === === 0비트 -11/+11 3875 -4994/+4994 ========= +194/-194 8개의 항목조합에서 코드유닛의 내용코드의 헤드 디자인을 변화하려고 할 경우 제일 간단한 방법은 내용코드의 비트0을 비트1로 변 경하는 것이고 반대로 해도 마찬가지인 바, 이는 도표56b에 나타낸 바와 같이 도표56a로부터 변경되는 것과 같 다. 이상의 구현예는 첸 인코딩이 어떻게 언이브너 인코더의 창조에 사용되는지를 표시하여 도표56a에서 비트1 로부터 251을 감소하고 비트0에 251을 증가하거나 또는 도표56b에서 비트1에 194를 증가하고 비트0으로부터 194 를 감소하는데 사용된다.이는 비트0:비트1 비율을 향한 것에서 더 많은 비트1의 추세가 반대로 됨을 표명한다. 완정성을 위하여 도표56c는 0헤드 시나리오 코드와 1헤드 내용코드를 사용하여 80000비트의 원시적인 무작위 데 이터 집합을 인코딩하는 결과를 표시하는데 이는 아래에 나타낸 바와 같다. 도표56c 도표56b에 사용된 1헤드 디자인과는 다른 0헤드 디자인을 이용하여 시나리오 코드를 디자인하는 반대되는 분포 압축 불가능한 클라스: AAB기술을 사용하여 범위 인코딩을 진행 3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 v1v1v1 3 0 11 4 0 +2/-2 2273 000 +4546/-4546 v1v1v2 4 0 101 4 0 +1/-1 1175 0010 +1175/-1175 v1v1v3 4 0 100 4 0 -1/+1 1149 0011 -1149/+1149 v1v2v1 4 0 011 4 0 +1/-1 1123 0100 +1123/-1123 v1v3v1 4 0 010 4 0 -1/+1 1060 0110 -1060/+1060 v2v1v1 4 0 001 4 0 0/0 1045 1000 0/0 v3v1v1 4 0 000 4 0 -2/+2 1072 1100 -2144/+2144 === === ==== 0 0/0 8897 +2491/-2491 7개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 상이하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v2v1] 10 1 1 1 5 0 +1/-1 [아래와 같이 재기입] v1v2v3 5 593 01011 +593/-593 v1v2v2 5 10 1 1 0 5 0 +1/-1 531 01010 +531/-531 [v1v3v1] 10 1 0 1 5 0 0/0 [아래와 같이 재기입] v1v3v2 5 548 01110 0/0 v1v3v3 5 10 1 0 0 5 0 -2/+2 542 01111 -1084/+1084 [v2v1v1] 10 01 1 1 6 0 +1/-1 [아래와 같이 재기입] v2v2v2 6 276 101010 +276/-276 v2v1v2 5 [01 10 0 1 6 +1 0/0] 542 10010 이를 이용하여 교환 11 01 [] 0 5 0 +1/-1 +542/-542 v2v3v2 6 10 01 0 1 6 0 -1/+1 266 101110 - 266/+266 v2v3v3 6 10 01 0 0 6 0 -3/+3 294 101111 -882/+882 [v3v1v1] 10 00 1 1 6 0 -3/+3 [아래와 같이 재기입] v3v3v3 6 304 111111 -912/+912 v3v1v3 5 [01 11 0 1 6 +1 0/+1] 561 11011 이를 이용하여 교환11 00 [] 0 5 0 -2/+2 -1122/+1122 v3v2v2 6 10 00 0 1 6 0 -2/+2 277 111010 -554/+554 v3v2v3 6 10 00 0 0 6 0 -4/+4 279 111011 -1116/+1116 === === === 0비트 -13/+13 5013 -3994/+3994 12개의 항목조합에서 압축 가능한 클라스; 그 중의 제3과 제2자리 값이 동일하고 코드 조절기술을 사용하여 인코딩. 제3제2제1 비트 신 제3제2제1 비트 +/- 비트1/비트0 빈도 코드값 코드 [v1v1v2] [00 0 [] 0 4] [AAB를 사용하여 2개로 분리] 11 1 [] 1 1 5 0 +2/-2 v2v1v3 5 576 10011 +1152/-1152 11 1 [] 1 0 5 0 +1/-1 v2v3v1 5 559 10110 +559/-559 [v1v1v3] 11 0 [] 1 4 [AAB를 사용하여 2개로 분리] 11 1 [] 0 1 5 0 +1/-1 v3v1v2 5 508 11010 +508/-508 11 1 [] 0 0 5 0 0/0 v3v2v1 5 540 11100 0/0 v2v2v1 5 11 01 [] 1 5 0 +2/-2 551 10100 +1102/-1102 v2v2v3 6 [00 10 [] 1 5 -1 0/-1] 288 101011 -288/+288 이를 이용하여 교환 10 01 1 0 6 0 -1/+1 v3v3v1 5 11 00 [] 1 5 0 -1/+1 591 11110 -591/+591 v3v3v2 6 [00 11 [] 1 5 -1 0/-1] 262 111110 -786/+786 이를 이용하여 교환 10 00 1 0 6 0 -3/+3 === === === 0비트 +1/-1 3875 +1656/-1656 ========= +153/-153 8개의 항목조합에서 따라서 도표55, 도표56a, 도표56b와 도표56c의 비트0과 비트1을 변화한 결과는 각각 +297/-297, -251/+251, -194/+194와 -153/+153이다. 따라서 도표55는 더 많은 비트0을 향한 최대 비대칭을 제공함은 아주 선명하다. 상 술한 바와 같이 동일한 데이터 분포에 대하여 상이한 헤드 디자인 및 분류 코드와 내용코드를 사용한 분포는 비 트0:비트1의 비율의 분포에 영향을 줄 수 있다. 또한 이러한 분포를 임의의 특정된 데이터 집합의 비트0:비트1 에 대응하는 상이한 비율 분포로 조절할 수 있고 하나의 분포가 계속하여 효과적으로 어느 한 방향을 향해 비대 칭을 이룰 수 없을 경우 이를 변화하여 한 점에 도달할 때까지 비대칭 방향이 다른 한가지 방안으로 유지되거나 디자인되도록 할 수 있는데 이 점에서 상기 불균일 분포는 첸 코딩의 기타 기술을 사용하여 압축할 수 있다. 예를 들어 AI구분기술을 사용하여 슈퍼 처리유닛을 진일보로 압축할 수 있다. 또는 단락[62]에서 소개한 6값 코 드유닛의 상이한 코드유닛 정의를 사용하여 하나의 정의는 데이터를 판독하는데 사용하고 다른 한 정의는 데이 터를 인코딩하고 기입하는데 사용될 수 있는 바, 예하면 만약 비트1이 비트0보다 많으면 1헤드 디자인의 17비트 의 6값 코드유닛 정의는 데이터를 판독하는데 사용될 수 있고 인코딩하고 기입함에 있어서는 동일한 헤드 디자 인의 18비트의 6값 코드유닛 정의를 통해 완성할 수 있다. 17비트 정의가 2비트의 비트코드11를 v1의 값으로 사 용하고 18비트 정의는 비트의 비트코드1을 사용하여 v1을 나타내므로 그 다음 18비트 정의를 사용하여 기입할 경우 판독된 2비트의 비트코드11은 17비트 정의가 판독한 v1에 사용되는 1비트의 비트코드1로 인코딩되어 2비트 를 1비트로 감소한다. 만약 비트1의 빈도가 비트0보다 높으면 이는 압축에 도움이 될 수 있다.[117]예하면 도표57은 1헤드 디자인의 17비트 내지 19비트의 6값 코드유닛을 나타낸다. 도표57 17, 18과 19비트의 1헤드 디자인을 사용하여 디자인한 6값 코드유닛의 코드값의 정의 데이터 17비트 18비트 19비트 값 판독 기입 기입 v1 11 1 1 v2 10 011 01 v3 01 010 0011 v4 001 001 0010 v5 0001 0001 0001 v6 0000 0000 0000 상술한 바와 같이 만약 숫자 데이터 집합이 가지는 비트1이 비트0보다 많으면 1헤드 디자인 코드유닛 판독기를 사용함으로써 v1이 가지는 빈도가 기타 유닛값보다 훨씬 높아진다. 이상의 3개의 6값 코드유닛의 정의를 비교하 는 것을 통하여 알 수 있다 시피 만약 v1의 빈도가 기타보다 높으면 17비트를 판독기로 사용하고 18비트 라이터 를 이용하여 기입하며 매번 v1을 판독할 경우 모두 1비트를 절약하게 되며 매번 v2와 v3을 판독할 경우 이는 각 각 1비트를 손실하게 되고 v4, v5와 v6에 대하여 비트 사용은 균등한 것이므로 v1의 빈도가 v2와 v3의 빈도의 합보다 높으면 비트를 절약할 수 있다. V2와 v3 한쌍과 v3과 v4 한쌍 사이의 빈도 분포에 근거하여 v1의 빈도와 비교하여 19비트 라이터를 사용할 수도 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 135, "content": "[118] 따라서 데이터 집합에서의 비트0:비트1 모드의 미세한 차이점을 이용하여 간단한 방식으로 압축하기 위하 여 한쌍의 상이한 비트 크기의 0헤드 디자인과 1헤드 디자인 코드유닛의 정의를 구성하여 기타 값 크기의 코드 유닛에 사용할 수 있다. 예하면 단락[117]에서 사용한 판독기와 라이터 또는 인코더는 6값 코드유닛에 기반한 것인 바, 기타 값 크기, 예하면 7-값, 8-값, 9-값, 10-값에 근거하여 이러한 판독기와 라이터를 구축할 수 있고 이로써 유추할 수 있다. 코드유닛이 정의한 값 크기가 클 수록 판독기와 라이터가 획득할 수 있는 비트0:비트1 의 차이점은 더 정밀하고 비트 저장을 절약하는 것으로 변한다. 인코딩에서 압축하기 전에 여러 차례의 불균일 처리(즉, 언이브너를 사용하여 몇개 주기를 진행함으로써 우선 한 방향을 향하여 비대칭되는 디지털 데이터 집 합에서의 비트0:비트1 비율을 변화시킴)를 더 진행할 수 있다. 만약 한가지 언이브너가 항상 데이터 분포 모드 로 하여금 한 방향으로 비대칭하도록 할 수 없으면 분류 코드의 분포 모드를 0헤드로부터 1헤드로 변화할 수 있 고 반대로 해도 마찬가지이며 판독기와 라이터의 헤드 디자인을 하나의 헤드 디자인으로부터 다른 한 헤드 디자 인으로 변화하거나 호환하거나 또는 상이한 비트 크기 및 상이한 값 크기의 코드유닛이 정의하는 상이한 디자인 을 사용할 수 있는 바, 이러한 변화를 진행한 경로가 첸 코드의 마스터헤드에 잘 기록되거나 인코더와 디코더에 구성되어 사용하도록 하면 된다. 더 중요한것은 언이브너는 상이한 내용코드 구성을 사용할 수 있다. 예하면 단 락[114]와 도표54에서 토론한 언이브너는 2클라스로 분류된 내용코드를 사용하는데 한 클라스는 압축할 수 없고 다른 한 클라스는 압축 가능한 바, 그 다음 코드 재분포 최적화로 인해 약간 수정된다. 상기 언이브너는 매 하 나의 고유 코드 어드레스를 동일한 비트 크기를 가지는 고유 데이터 값에 하나씩 매핑하여 처리 중인 임의의 데 이터 값의 매 하나의 암호화된 코드와 상응하는 원시적인 데이터 값의 비트 크기가 완전히 동일하도록 함으로써 비트 이득이 없을 뿐만 아니라 비트 손실도 없도록 한다. 도표55와 도표56은 동일한 그룹의 내용코드에 대한 분 류 코드에 대해 분포한 두가지 상이한 배치를 표시하지만 0헤드 디자인과 1헤드 디자인을 사용함으로써 비트0: 비트1의 분포 모드에 있어서 상이한 비율 변화를 초래한다. 그러나 단락[114]에서 소개하는 기술을 사용하여 유 사한 방식으로 상이한 내용코드를 가지는 기타 언이브너를 디자인하되 처리하고자 하는 처리유닛의 성질을 정의 하는 종료 조건을 선택하는 것을 포함하고 처리유닛의 고유값 항목이 식별한 특징 또는 특성에 근거하여 이에 대해 분류하며 코드 조절, 코드 교환과 코드 재분포를 진행하여 도표54 내지 도표56에 나타난 바와 같은 다른 한 언이브너 인코더를 창조할 수 있도록 한다. 다른 한 구현예는 단락[91]과 도표28에서 슈퍼 처리유닛에 대한 토론에서 발견한 것이다. 도표28에서의 언이브너를 사용함으로써 데이터 집합의 비트0:비트1의 비율이 변화하는 방식과 도표55 또는 도표5에서의 언이브너의 방식이 상이하다. 따라서 상술한 바와 같이 하나의 언이브너가 더 이상 비트1과비트0의 비율을 하나의 일정한 방향으로 변화할 수 없을 경우 적당히 디자인한 다른 한 언이브너를 통해 진일보로 이러한 일방향 변화를 사용할 수 있으며 이로써 유추할 수 있다. 따라서 언이브너 인코더의 작용은 숫자 데이터 집합의 비트0과 비트1의 분포 모드를 불균일로 기울어지도록 하는 것이다. 비트0보다 더 많은 비트1(1:1의 비율의 비트0:비트1의 균일한 분포와 비교할 때)을 발생하는 언이브너 인코더는 비트1 언이브너로 불리울 수 있고 더 많은 비트0 비대칭을 형성하는 데이터를 향해 분포하는 것은 잠시 후 비트0 언이브너의 언이 브너 인코더가 대비(1:1의 비율의 비트0:비트1의 균일한 분포와 비교할 때)를 이루는 것이라 할 수 있다. 한편 으로 비트0:비트1 비율이 인코딩 전보다 더 균일하도록 하는 그러한 인코더(비트0:비트1 비율이 1:1방향으로 더 향하도록 함)는 이브너 인코더 또는 이브너로 불리울 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 136, "content": "[119] 이러한 방식으로 단락[115] 내지 [117]에서 언급한 바와 같이 코드유닛 정의를 판독기와 라이터로 사용하 여 압축하는 기술은 단락[118]에서 언급한 언이브너와 함께 사용되어 정보이론에서의 비둘기집원리의 신화를 종 결하는 확실한 증거가 되고 임의의 데이터 집합이 무작위 여부와 관계 없이 본 발명이 앞에서 해석한 바와 같이 하나의 한계에 도달할 때까지 반복해서 압축할 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 137, "content": "[120] 숫자 데이터 집합을 압축하는 과정에서 압축기는 이브너의 작용을 하는 바, 그렇지 않으면 임의의 데이터 집합은 모두 한번 또 한번씩 압축 (물론 본 발명에서 개시한 바와 같이 어느 한 한계에 도달할 때까지) 될 수 있다. 사실상 본 발명에 앞서 압축분야에서의 방법은 반복해서 무작위 여부와 관계 없는 임의의 데이터 분포 모 드의 데이터 집합을 순환적으로 압축하는 장기적인 목표에 도달하지 못하였는데 이는 사실상 이 점을 설명한다. 단락[118]에서 토론한 방식으로 본 발명을 개시한 상황에서, 즉 단락[124]에서 토론한 언이브너와 이브너를 차 례대로 대체하여 사용하거나 또는 기타 방식으로 사용하는 상기 목표는 절대적으로 볼 수 있다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 138, "content": "[121] 언이브너와 이브너를 사용하여 차례대로 인코딩과 디코딩하여 획득한 암호화된 첸 코드 파일의 마스터헤 드는 기본적으로 아래와 같은 지정자를 포함한다. (a)검사 합계 지정자; 만약 적합한 상황에서 이것이 존재하면 디코더는 이를 사용하여 복호화하고자 하는 파일 이 유효한지 여부의 첸 코드파일을 식별하므로 디자이너에 의해 인코더가 발생한 상응하는 첸 코드파일, 디자이 너의 싸인 지정자 및 파일이 사용을 위해 제공되는 유효한 파일인지 여부를 포함; (b)재순환 비트 또는 지정자; 인코더는 디코더가 사용할 비트를 기입하여 디코더로 하여금 현재 처리순환 다음 에 반드시 정지할지 여부를 디코딩하도록 함; 및 (c)사용한 매핑 테이블 또는 코드유닛 정의 지정자는 (인코더가 인코딩에서 사용하거나 또는) 현재 인코딩 순환 하는 숫자 데이터층에 사용; 다른 한 지정자 비트(언이브너/이브너 지정자)를 사용하여 현재 암호화하는 첸 코 드층이 언이브너 매핑 테이블 또는 이브너 매핑 테이블을 사용하여 완성되었는지의 여부를 구별한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 139, "content": "[122] 마스터헤드 외에 획득한 첸 코드파일은 별도의 두개 유닛을 더 포함한다. (A)첸 코드유닛; 암호화하는 첸 코드를 포함하되, 선택된 코드유닛 정의의 판독기를 사용하여 입력한 숫자 데이 터를 판독하고 라이터를 사용하여 판독한 숫자 데이터를 기입하거나 인코딩하는데 라이터는 마스터헤드에서 지 시한 코드유닛 정의 또는 매핑 테이블을 사용하는 인코더로서 코드를 기입하거나 또는 코드유닛 정의 또는 매핑 테이블을 실현하기 위한 프로그래밍 논리를 포함하여 인코딩하며 여기서 암호화된 첸 코드는 적합한 상황에서 분류와 내용코드를 포함; 및 (B)암호화되지 않은 코드유닛;이는 숫자 데이터 부분을 입력한 이진 비트의 부분을 나타내는 바, 이는 판독될 때 암호화되지 않고 통상적으로 획득한 첸 코드파일의 끝부분에 놓이며 코드의 일부분으로 디자인되고 이의 비 트수는 하나의 처리유닛 또는 하나의 슈퍼 처리유닛을 구성하기에는 부족하여 사용하는 인코딩기술을 통해 이를 암호화할 수 없게 된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 140, "content": "[123]상술한 바와 같이 단락[121]와 [122]에서 식별한 이러한 단독적인 한가닥의 숫자정보는 각각 상이한 첸 코 드파일에 배치되어 단독적인 개체로서 저장을 위해 사용될 수 있다. 상응하는 디자인은 응당 디코더로 하여금 그들을 액세스하고 정확하게 식별하도록 함으로써 디코딩을 진행하도록 한다. 디코딩을 진행할 경우 디코더는 관련되어 획득한 첸 코드파일의 마스터헤드에서 지시하는 코드유닛 정의 또는 매핑 테이블을 사용함으로써 입력 한 이미 암호화된 첸 코드파일을 판독하거나, 또는 코드유닛 정의 또는 매핑 테이블을 실현하는데 사용되어 디 코딩하는 프로그래밍 논리(즉 상응하는 코드유닛 정의 또는 매핑 테이블 또는 상응하는 내장 프로그래밍 논리를 사용하여 암호화된 코드를 숫자 데이터 코드를 입력하는 것으로 전환하고 이를 적어낸다)를 포함하고 획득한 암 호화된 코드는 상기 인코딩 순환 이전에 입력한 숫자 데이터 코드이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 141, "content": "[124]만약 교대에서 이브너와 함께 사용하지 않으면 언이브너를 사용하여 숫자 데이터를 압축할 수도 있는데 극 단까지 진행할 경우 모든 숫자 입력 이진 비트는 모두 언이브너가 진행하는 불균일 처리의 순환주기를 통해 비트0 또는 비트1까지 감소된다. 따라서 발생한(불균일 처리 단계의 경로의) 첸 코드파일은 불균일 인코더가 채택 한 경로와 관련된 정보일 뿐이고 원시적인 숫자 데이터가 입력한 비트 크기, 필요하거나 적합한 상황에서 형성 된 불균일 처리 횟수의 수량 및 매 하나의 불균일 순환주기에 사용되는 코드유닛 정의 또는 매핑 테이블을 포함 한다. 불균일 디코더는 이로써 불균일 인코더가 채택한 불균일 경로의 이러한 정보에 의존하여 원시적인 숫자 데이터를 정확하고 손상 없이 복수할 수 있다. 이러한 방식으로 인코딩과정은 1개 또는 1개보다 많은 불균일 인 코딩의 순환주기를 포함할 수 있으나 이브너 인코딩 또는 압축기 인코딩을 진행하지 않는다. 언이브너를 사용하는 다른 한 변형방식은 최후의 처리순환주기 이전에 여러 차례 순환하도록 이를 사용하고 최 후 순환하는 인코딩은 압축기(또는 압축을 위한 이브너)에 의해 완성되는 것이다. 이러한 방식으로 인코딩 과정 은 압축기가 인코딩하는 최후의 한 순환주기 이전의 하나 또는 하나보다 많은 불균일 인코딩 순환주기를 포함한 다. 이러한 변형에서 획득한 첸 코드와 첸 코드파일의 구조는 단락[121] 내지 [123]에서 설명한 구조와 유사하 다. 이브너는 데이터 집합의 비트0:비트1의 비율이 더 균일하도록 하는 압축기에 치우치고 최후의 하나의 순환 주리 또는 최후의 인코딩층의 인코더로 사용될 경우 이러한 이브너 또는 압축기를 사용하는 결과로 인하여 데이 터 분포가 이의 비대칭 방향으로 향하는 것이 더이상 중요하지 않도록 하는데 예정대로 데이터를 압축할 수만 있다면 비대칭은 임의의 한가지 방식일 수 있다. 사용한 용어, 즉 이브너 또는 이브너 인코더는 본 발명에서의 압축기 또는 압축기 인코더와 동일한 것으로 간주되어야 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 142, "content": "[125]현재까지 이상에서 개시한 첸 프레임워크와 첸 코딩은 적어도 코드 어드레스의 수량이 고유 데이터 값의 수량에 상대하여 데이터 압축에 강압 한정되는 요소(예전에는 정보이론에서의 비둘기집원리의 신화에 의해 오도 됨)가 아님을 증명하였다. 중요한 것은 데이터 집합을 입력하는 데이터 값의 빈도분포이다. 상기 단락에서 소개 한 기술을 사용하여 실현한 첸 코딩방법은 인코딩에서 무작위로 데이터집합을 입력한 것과 관계 없이 이러한 공 적을 완성하였는 바, 즉 인코딩에서 데이터의 정보를 입력하는 것에 데이터 특성을 입력한 것을 나타내는 분류 코드를 더하고 데이터의 분포를 변화하여 첸 코딩의 관련 기술을 사용하여 암호화된 코드를 디코딩할 경우 입력 데이터를 손상 없이 정확하게 복구할 수 있으며; 또한 일정한 한도에 도달하면 상응한 숫자 데이터는 암호화와 압축을 순환할 수 있고; 상기의 한도는 사용하거나 실현하는 디자인과 모드의 제한을 받는 바, 사용되는 마스터 헤드와 관련 지정자의 코드비트를 대표하고 하나의 처리유닛 또는 하나의 슈퍼 처리유닛에 놓이는 첸 코드에 적 용되며 만약 존재하면 암호화되지 않은 이진 비트의 암호화되지 않은 코드유닛(또는 임의의 이러한 암호화되지 않은 이진 비트를 남기지 않을 수 있음)이며 상기 암호화되지 않은 이진 비트의 수량은 하나의 처리유닛 또는 하나의 슈퍼 처리유닛의 크기보다 적으나 0보다 더 많다. 본 단락에서 이렇게 제기한 첸 코드는 첸 코드의 핵심 인 바, 원시적으로 데이터의 내용 도는 데이터 값 부분을 입력하는 암호화된 코드로서, 예하면 마스터헤드에 포 함되는 기타 부가적인 정보 및 그가 포함하는 지정자(및 인코더와 디코더에 내장된 정보와 프로그래밍 논리의 상기 부분)이고 암호화되지 않은 코드유닛도 첸 코드에 속하며 첸 코드의 외곽으로서 인코딩과 디코딩 과정에서 첸 코드 핵심과 함께 사용하여 원시적으로 데이터를 입력하는 것이 완벽하게 암호화되며 암호화된 코드는 완벽 하고 암호화되는 동시에 정확하고 손상 없이 원시적인 입력 데이터에 복구된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 143, "content": "[126]이렇게 사용하는 방법과 기술은 비무작위 숫자 데이터를 압축하는데 사용된다. 만약 이렇게 디자인하면 암 호화와 복호화를 동시에 진행할 수도 있다. 데이터를 확장하고 수축하지 않는 상황에서 암호화와 복호화를 진행 하면 제일 간단한 방법으로는 임의의 코드유닛 값에 사용될 수 있는 동일한 비트 인코더를 사용하는 기술이다. 예하면 단락[62]는 이미 도표14b와 도표14c에 나열된 Max6 16비트 인코더의 몇가지 디자인을 개시하였다. 개시 한 네가지 디자인에서의 매 한가지마다 모두 동일한 비트 크기의 인코더로 사용되어 한가지 디자인을 사용하여 판독하고 또 다른 한가지 디자인을 사용하여 기입함으로써 원본 코드를 전환하여 암호화와 복호화를 진행하는 목적으로 사용될 수 있도록 한다. 결과는 암호화 코드가 원본 코드와 동일한 크기를 가지게 된다. 기타 Max 클 라스에 유사한 디자인을 창조할 수 있으므로 암호화와 복호화는 무궁무진한 변화가 존재할 수 있다. 어느 Max 클라스(및 특정 Max 클라스에서의 어느 비트 그룹)가 인코딩에 사용되는지를 모르는 상황에서 암호화된 코드를 복호화하기 쉽지 않을 수 있다. 암호화하지 않는 동일한 비트 크기의 인코더를 사용하고 또한 이가 동일한 인코 더만 사용하면 상기 인코더는 한편으로는 숫자 데이터를 판독하고 다른 한편으로는 이를 적는다. 물론 기타 기 술과 함께 사용하지 않는 상황에서 정확한 데이터 복사기 외에 이는 그 무엇도 할 수 없다. 현재까지 개시한 기 술은 적어도 암호화/복호화를 진행하고 처리하고자 하는 숫자정보의 데이터 분포가 적합한 상황에서 압축/압축 해제를 진행하는데 사용될 수 있다. 또 어떻게 상이한 디자인과 모드에서의 첸 코딩 기술을 사용하여 무작위 데 이터를 압축하고 복구하는 방법을 더 제출하였다. 아래에 진일보로 개시한 일부 더 많은 기술의 발명을 통해 아 래 증거로 하여금 정확하고 손상 없이 무작위 데이터를 압축하고 복구할 수 있음을 증명하도록 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 144, "content": "[127]마지막으로 지금은 명확한 증거를 제출하여 무작위 데이터가 압축될 수 있고 압축 해제를 통해 정확하고 손상 없는 복구가 가능함을 증명할 적당한 시기이다. 이러한 기술은 숫자 데이터 블랙홀인 바, 상기 기술을 통 해 코드유닛 값 또는 처리유닛 값을 식별하여 숫자 데이터 블랙홀이 되도록 한다. 어떻게 숫자 데이터 블랙홀을 창조할 것인지를 개시하기 위하여 또다시 Max3 5비트 0헤드 디자인 코드유닛 인코더의 구현예를 사용하며 처리 유닛은 Max3 5비트0헤드 디자인 코드유닛 인코더를 통해 판독한 3개의 이러한 코드유닛으로 조성된 것으로 정의 된다. 따라서 27개의 고유 처리유닛 코드값(PUCV)이 존재하고 단락[74]에서의 도표20과 동일하다. 도표20은 이 27개의 고유 PUCV에서의 매 하나의 빈도 분포를 표시하는데 알 수 있다 시피 제일 짧은 PUCV는 000이고 3비트를 가지며 4비트의 PUCV, 5비트의 PUCV와 6비트의 PUCV가 더 존재한다. 따라서 이 27개의 PUCV는 비트 클라스로 분 류될 수도 있다. 또한 비트의 크기가 1비트 증가함에 따라 이러한 하나의 PUCV의 빈도는 약 절반 감소되고, 3개 의 싱글 코드유닛으로 조성된 처리유닛의 Max3 5비트0헤드 디자인 코드유닛 인코더를 사용하여 무작위 데이터를 판독할 경우 무작위 데이터의 빈도 분포에서 일반적인 규율성(또는 무작위성 규칙)을 관찰할 수 있음을 알 수 있다. 진일보로 조사할 경우 첸 프레임워크에서 개발한 동일한 모드(즉 3개의 싱글 코드유닛으로 조성된 처리유 닛을 가지는 Max3 5비트0헤드 디자인 코드유닛 인코더를 사용)를 사용하여 무작위 데이터의 다른 한 빈도 분포 규칙 또는 규율성을 발견할 수 있다. 이 무작위 데이터의 빈도 분포의 다른 한 특징규율 또는 규칙은 아래 도표 58에 나타낸 바와 같다. 도표58a 3개의 싱글 코드유닛으로 조성된 처리유닛을 가지는 Max3 5비트0헤드 디자인 코드유닛 인코더를 사용하여 판독 한 80000비트의 무작위 데이터 집합의 처리유닛의 빈도 분포 처리유닛 코드값 PUCV 빈도 특수 코드 3비트 클라스 000 2311 클라스에서 오직 하나 4비트 클라스 1100 1151 클라스에서 최고 0010 1121 0100 1119 0011 1103 1000 1086 0110 1036 클라스에서 최저 5비트 클라스 11100 579 클라스에서 최고 01111 574 11010 569 10011 562 10110 561 10100 556 01011 555 10010 551 01010 539 11110 524 11011 524 01110 523 클라스에서 최저 6비트 클라스 111111 315 클라스에서 최고 101010 293 101011 289 111011 288 101110 288 101111 264 111110 262 111010 254 클라스에서 최저 도표58b 3개의 싱글 코드유닛으로 조성된 처리유닛을 가지는 Max3 5비트0헤드 디자인 코드유닛 인코더를 사용하여 판독 한 80000비트 무작위 데이터 집합의 슈퍼 처리유닛의 빈도분포 - 슈퍼 처리유닛은 2개의 연속된 처리유닛으로 조성(그 중 선택된 SPUCV를 표시) 슈퍼 처리유닛 코드값 SPUCV 빈도 특수 코드 6비트 클라스 000-000 264 클라스에서 오직 하나 7비트 클라스 000-0100 160 클라스에서 최고 000-1000 156 클라스에서 두번째 …… 000-0110 141 클라스에서 최저이지만 유일함 000-1100 140 클라스에서 최저 8비트 클라스 0010-1100 91 클라스에서 최고 블랙홀0 01011-000 86 클라스에서 두번째 …… 0100-0100 51 클라스에서 최저이지만 유일함 000-11110 50 클라스에서 최저 9비트 클라스 0100-10110 48 클라스에서 최고 111110-000 48 클라스에서 최고 …… 10110-0011 21 클라스에서 최저이지만 유일함 …... 0011-11011 19 클라스에서 최저 블랙홀1 대체 코드0(Scode 0) 블랙홀1로 대체 10비트 클라스 01111-01111 31 클라스에서 최고 …… 01111-01010 28 클라스에서 두번째 …… 10011-11100 8 클라스에서 최저이지만 유일함 …... 01111-01110 6 클라스에서 최저 대체 코드1(Scode 1) Scode 0을 대체 11비트 클라스 111111-10110 17 클라스에서 최고 …… 10010-111110 15 클라스에서 두번째 …… 01011-101011 3 클라스에서 최저이지만 유일함 대체 코드3a(Scode 3) 2부분으로 분류: 01011-101011-0 자체를 대체 및 01011-101011-1 Scode 2를 대체 …… 101111-11110 2 클라스에서 최저 대체 코드2(Scode 2) Scode 1을 대체 12비트 클라스 111111-101011 14 클라스에서 최고 (다른 한 블랙홀0일 수 있는 바, 단락[131]을 참조) …… 101111-101010 10 클라스에서 두번째 …… 111110-101110 1 클라스에서 최저이지만 유일함 111111-111110 0 클라스에서 최저 대체 코드3b(Scode 3) Scode 2를 대체 도표58a와 도표58b의 빈도 분포 통계값의 구현예는 아래와 같은 도표58c와 도표59d에 나열한 자동3프로그램을 사용하여 생성된 것이다. 도표58c 도표58a와 도표58b에 표시된 빈도 통계값의 자동 프로그램을 생성"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 145, "content": "도표58d 도표58c에 나열된 자동 프로그램이 사용하는 자동 프로그래밍 라이브러리"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 146, "content": "[128] 도표58a는 80,000비트의 무작위 데이터 집합의 27개의 고유 PUCV의 빈도분포를 나열하였고 도표58b는 동 일한 무작위 데이터 집합의 27×27개의 고유 SPUCV의 빈도분포를 나열하였다. 간결함을 위하여 도표58b에는 매하나의 비트 클라스이 2개의 제일 빈번한 것과 2개의 제일 빈번하지 않은 SPUCV를 열거하였다. Max3 5비트0헤드 디자인 코드유닛 인코더가 판독하고 샘플링할 경우 이는 80,000비트의 무작위 데이터 집합의 기타 빈도 분포 규 율 또는 규칙성을 충분히 판별할 수 있고 상기 인코더는 3개의 싱글 코드유닛으로 조성된 처리유닛 및 연속된 2 개의 처리유닛을 가지는 슈퍼 처리유닛, 첸 프레임워크를 사용하여 개발한 인코더를 가진다. 상술한 바와 같이 첸 프레임워크는 무작위 데이터를 포함하는 임의의 데이터 분포를 설명하고 조사하기 위한 숫자 데이터의 특징 또는 특성의 프레임워크를 제공한다. 현재까지 무작위 데이터의 특징은 더 상세하고 명확하게 개시되지 않았고 단지 이는 무작위이므로 이것이 대표하는 값은 예측 불가능한 방식으로 무작위로 나타나며 장기적으로 볼 때 이 는 균일한 분포에 근접하는 비트0:비트1 비율에 더 기울어지지만 규율성은 없다는 것을 알 수 있다. 지금 첸 프 레임워크를 사용하여 예하면 한가지 디자인된 인코더에서Max3 5비트0헤드 디자인 코드유닛 인코더는 3개의 싱글 코드유닛으로 조성된 처리유닛 및 2개의 연속된 처리유닛을 갖는 슈퍼 처리유닛을 구비하는데 사람들은 무작위 데이터를 설명하는데 사용될 수 있는 어떠한 규율 또는 규칙성을 찾아낼 수 있다. 무작위 데이터 집합과 관련되 는 빈도 분포의 이러한 규율 또는 규칙성을 이용하여 이를 무작위 데이터 및 비무작위 데이터를 제정하고 처리 하는 참고로 사용할 수 있다. 도표 58a와 도표58b에는 일부 식별 가능한 규율성이 존재하는 바, 예하면 각각 27 개의 고유 처리유닛과 27×27개의 고유 슈퍼 처리유닛에 대하여 임의의 특정된 코드값의 빈도는 모두 그 비트 길이 또는 비트 크기 또는 비트 클라스의 측량이고 비교적 높은 비트 클라스에서의 하나, 즉 비트 길이 또는 크 기가 1비트 축소된 것이며 이의 빈돈는 대략 배가 된다. 예하면 도표58a에서 3비트 클라스의 PUCV 000의 빈도는 2,311이고 4비트 클라스에서의 다음의 한 PUCV 1100은 1151로 변한다. 또한 27×27 SPUCV에 대하여 도표58b에서 규율성을 찾을 수도 있다. 그러나 도표58a와 도표58b에서의 코드값 사이의 빈도범위를 비교할 경우 사람들은 이러한 규율의 변화를 발견할 수 있다. 하나의 비트 클라스에서 제일 빈번한 코드값과 이웃하는 비트 클라스에서의 제일 빈번하지 않는 코드 값 사이의 빈도범위를 비교한다. 아래 도표58e는 상이한 비트 클라스에서의 코드값의 빈도범위를 나열하였다. 도표58e 비트 클라스 사이의 빈도범위 비트 클라스 최고빈도 최저빈도 빈도범위 비율 PU 3 2311 4 1151 1036 2.23 : 1(2311/1036) 5 579 523 2.20 : 1 (1151/523) 6 315 254 2.80 : 1 (579/254) SPU 6 264 7 160 140 1.88 : 1 (264/140) 2.25 : 1 (315/140) 8 91 50 3.2 : 1 (160/50) 9 48 19 4.79 : 1 (91/19) 10 31 6 8 : 1 (48/6) 11 17 2 15.5 : 1 (31/2) 12 14 0 17 : 0 따라서 이는 비트 길이가 값의 빈도를 결정하는 고유 요소가 아님을 개시하는 바, 상이한 그루핑에서의 값도 자 신의 그룹의 자신의 빈도 규칙성 특징을 가지게 된다. 예하면 비트 클라스가 점점 낮아질 경우 비트 클라스가 높은 비트 클라스에서의 제일 빈번한 코드값과 낮은 비트 클라스에서의 제일 빈번하지 않은 코드값 사이의 비율 은 SPUCV그룹에서 증가하는데 더 치우친다.이로써 사람들은 무작위 여부와 관계 없이 목표 목적에 적합한 데이터를 처리하는 방법과 관련 규칙을 디자인할 수 있다. 이하 본 특허는 상기에서 발견한 어떻게 숫자 데이터, 특히는 무작위 데이터를 압축하는데 사용될 것 인지를 개시한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 147, "content": "[129]무작위 데이터를 압축함에 있어서 단락[128]에서 개시한 발견을 이용하여 절대 어드레스 분기 코딩(AABC) 과 연속되는 코드 대체(SCS)를 함께 이용하여 숫자 블랙홀 기술(DBh)을 개발하였다. 물리세계에서 블랙홀은 물 질이 흡수되는 곳이다. 마찬가지로 본 발명에서 개시한 일부 실시방안은 이진법 숫자코드를 사용하여 기타 이진 법 코드를 흡수하는 자리점을 표시한다. 이는 일부 상기 역할을 수행하기에 유리한 숫자 이진법 코드를 식별하 는 것에 관한 것이다. 이러한 자리의 표준을 선택하는 것은 사람들이 실현하고자 하는 목적에 의해 결정된다. 따라서 건립한 표준과 목적은 관련된다. 데이터 압축을 진행하기 위하여 뚜렷한 표준은 숫자 이진법 코드의 빈 도에 관한 것이다. 따라서 숫자 이진법 코드 피스가 빈번하게 발생할 수록 기타 숫자 이진법 코드에 대한 흡수 는 더 빈번해지므로 더 많은 비트를 절약할 수 있게 된다. 따라서 도표58a와 도표58b에 나타낸 바와 같이 PUCV 그룹과 SPUCV그룹에서의 매 하나의 비트 클라스를 위해 제일 빈번하게 나타나는 값을 식별해야 한다. 숫자 블랙홀의 발명은 AABC기술을 사용한다. 도표55에 나타낸 바와 같이 단락[115]에서 발견한 설명의 상황에서 27개의 고유 PUCV그룹은 약 절반의 빈도를 가지는 2개의 서브 그룹으로 분류될 수 있다. 또한 단락[116]에서는 이상의 압축 불가능한 클라스와 압축 가능한 클라스의 빈도를 총화하였는데 여기서 제1 클라스는 8897개의 처리 유닛을 가지고 제2 클라스는 8888개의 처리 유닛을 가진다. 압축 불가능한 클라스는 7개의 PUCV를 가지고 압축 가능한 클라스는 20개의 PUCV를 가진다. 압축 불가능한 클라스는 분류 코드 또는 시나리오 코드0을 그의 헤드로 포함하고 압축 가능한 클라스는 1을 그의 헤드로 사용한다. 만약 분류 코드 또는 시나리오 코드의 사용을 절약 하게 되면 어떠한 특정 빈도 분포를 가지는 무작위 데이터에 대해 데이터 압축을 진행할 수 있는 바, 즉 그가 일정한 빈도 분포 규율성을 가지기 때문이다. 이는 여기서 개시한 숫자 블랙홀의 발명을 통해 완성된 것이다. 임의의 무작위 데이터 집합에서의 임의의 PUCV 또는 SPUCV 이전과 이후는 다른 한 PUCV인데 이는 3/4/5/6빝 클 라스리다. 도표55에서의 압축 불가능한 클라스는 3비트 클라스와 4비트 클라스에서 PUCV이고 압축 가능한 클라 스는 5비트 클라스와 6비트 클라스서 PUCV이다. 만약 분류 코드 비트0/1을 사용하지 않으면 아래의 AAB코드를 압축 불가능한 클라스와 압축 가능한 클라스의 PUCV에 사용하는데 이는 아래 도표59에 나타낸 바와 같다. 도표59a 압축 불가능한 클라스 3/4비트 클라스의 PUCV의 AAB코드 7개의 고유 PUCV 분포 00 -1 3비트 클라스PUCV 010 -1 4비트 클라스PUCV 011 -1 4비트 클라스PUCV 100 -1 4비트 클라스PUCV 101 -1 4비트 클라스PUCV 110 -1 4비트 클라스PUCV 111 -1 4비트 클라스PUCV 도표59b 압축 불가능한 클라스 5/6비트 클라스의 PUCV의 AAB코드 20개의 고유 PUCV 분포 0000 -1 5비트 클라스PUCV 0001 -1 5비트 클라스PUCV 0010 -1 5비트 클라스PUCV 0011 -1 5비트 클라스PUCV 0100 -1 5비트 클라스PUCV 0101 -1 5비트 클라스PUCV 0110 -1 5비트 클라스PUCV 0111 -1 5비트 클라스PUCV 1000 -1 5비트 클라스PUCV 1001 -1 5비트 클라스PUCV 1010 -1 5비트 클라스PUCV 1011 -1 5비트 클라스PUCV 11000 -1 6비트 클라스PUCV 11001 -1 6비트 클라스PUCV 11010 -1 6비트 클라스PUCV 11011 -1 6비트 클라스PUCV 11100 -1 6비트 클라스PUCV 11101 -1 6비트 클라스PUCV 11110 -1 6비트 클라스PUCV 11111 -1 6비트 클라스PUCV 도표59a와 도표59b에서 모두 알 수 있다 시피 상기 방식으로 분포한 매 하나의 PUCV가 AABC기술을 사용함으로써 1비트를 절약하는데 도움이 된다. 그러나 분류 또는 시나리오 코드가 결여하기 때문에 사람들은 이러한 AAB코드 만을 사용하여 27개의 고유 PUCV를 대표할 수 없었다. 따라서 숫자 블랙홀을 창조하는 기술은 반드시 작용을 발 휘해야 한다. 이는 상술한 바와 같이 숫자 이진법 코드를 이전의 PUCV 또는 다음의 PUCV를 흡수하는 블랙홀로 지정하고 일단 암호화를 진행할 때 상기 숫자 인진법 코드를 검출하게 되면 도표59a와 도표59b에 나열한 AAB코 드를 사용하여 그들에게 PUCV를 분포한 코드를 사용하였음을 나타낸다. 그러나 두개의 클라스인 압축 불가능한 클라스와 압축 가능한 클라스가 존재하므로 응당 두개의 블랙홀이 존재해야 하는 바, 하나는 AAB코드를 사용하 여 3비트 클라스와 4비트 클라스 PUCV 및 기타 5비트 클라수와 6비트 클라스 PUCV를 나타(따라서 흡수함)내야 한다. 따라서 블랙홀1(SPUCV 0011-11011, 빈도는 19, 9비트 클라스에서 제일 낮음)과 배합하고 블랙홀0(SPUCV 0010-1100, 빈도는 91, SPUCV그룹에서의 8비트 클라스에서 제일 높은 하나)과 짝을 이루어 블랙홀0과 블랙홀1 이전에 또는 이후에 두개의 반 코드값(절반은 3비트와 4비트 클라스 코드값이고 다른 절반은 5비트와 6비트 클 라스 코드값)을 흡수하도록 해야 한다. 여기서 SPUCV 0010-1100와 SPUCV 0011-11011을 블랙홀0과1로 선택하는데 이는 그들이 함께 빈도 범위(도표58c에 나타낸 바와 같이 비율은 4:1보다 크다)를 나타내고 하나의 특징으로서 그 중의 한 형식의 숫자 데이터 블랙홀 기술에 적용되기 때문이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 148, "content": "[130] 따라서 SPUCV그룹의 빈도 규율성 또는 규칙의 발견은 상기 블랙홀 기술을 사용하여 무작위 데이터의 데이 터 압축을 위해 길을 딲는데 도움이 된다. 또한 현재 PUCV그룹과 SPUCV그룹의 빈도 규율 모드를 결정할 수 있고 이러한 모드가 그의 빈도 폭과 임의의 특정된 비트 클라스 또는 비트 클라스값의 빈도 범위를 포함하므로 이를 규칙을 제정하여 기타 유형의 데이터 분포를 압축하는 참고로 사용할 수 있으며 아래에서 이에 대해 개시한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 149, "content": "[131]숫자 데이터 블랙홀은 AABC를 사용하여 곧 다가올 예정인 행렬에서의 앞의 값 또는 다음의 한 값 또는 앞 또는 뒤의 두개의 값을 흡수할 수 있다. 따라서 숫자 데이터 블랙홀의 기술은 첸 프레임워트에서 정의한 인코더 의 코드값을 사용하여 AAB코딩을 통해 기타 코드값, 즉 흡수한 코드를 표시하는 블랙홀 코드값을 흡수하는 것과 관련된 AAB코드를 흡수하거나 나타내고 블랙홀 코드값은 이로서 AAB코드를 향하는 인덱스 또는 포인터로서 대응 하는 블랙홀에 의해 흡수한 코드값을 나타낸다고 정의된다. 예하면 블랙홀0은 도표59a에서의 AAB코드를 사용하 여 3비트와 4비트 PUCV를 흡수하고 그들이 이후에 나타날 경우(후방향 흡수에 사용) 여기서 사용한 구현예에서 의 약 절반 나타난 블랙홀0, SPUCV 0010-1100에 대해 1비트를 절약한다. 예하면 이는 약 46(91/2)를 절약하는데 이는 3비트와 4비트 PUCV의 빈도와 5비트와 6비트PUCV의 빈도 사이의 비율에 의해 결정된다. SPUCV 0011- 11011을 사용하여 도표59b에서는 AAB코드를 사용한 블랙홀1의 역할을 하여 나타내는데, SPUCV 0011-11011은 이 후에 5비트 또는 6비트PUCV를 따르는 이러한 한가지 모드로 되어 한편으로는 45(91/2)비트를 절약하지만 다른한편으로는 45비트를 잃게 되는데 이는 SPUCV 0011-11011, 블랙홀1이 9비트로서 블랙홀0, SPUCV 0010-1100보다 1비트 길기 때문이다. 따라서 블랙홀1을 사용한 결과는 균등하다. 전체적으로 말하면 이러한 기술을 사용함으로 써 약 1비트 곱하기 SPUCV 0010-1100빈도의 절반, 즉 46(91/2)비트를 절약할 수 있다. 그러나 아직 완성되지 않 았다. 이는 SPUCV 0010-1100(대체 코드0, Scode 0)이 SPUCV 0010-1100(이어서는 5/6비트의 PUCV)을 대체하는데 사용되고 블랙홀1로 변했기 때문이다. 따라서 블랙홀1의 비트 길이는 블랙홀0보다 1비트 길지 말아야 하고 이 빈도는 블랙홀0의 4분의1 좌우 작아야 한다. 그렇지 않으면 데이터 압축을 실현할 수 없게 된다. 또한 블랙홀1 의 자리는 반드시 다른 한 코드에 의해 대체되어야 한다. 데이터 압축의 목적을 진행하기 위하여 대체 코드를 선택함으로써 연속되는 코드 대체의 표준이나 규칙을 진행하는 것은 다음과 같다: 코드의 비트 길이가 짧을 수록 좋고, 코드의 빈도가 낮을수록 좋고, 코드 충돌을 야기하는 대체 코드를 선택하지 않는다(예하면 SPUCV 0010-1100을 블랙홀0으로 선택하면 이의 일부를 블랙홀1로 구성하는 구성부분을 가능한 피해야 한다). 따 라서 선택된 Scode는 응당 대체되고자 하는 코드(피대체 코드)보다 더 빈번하지 말아야 하고(빈번하지 않으면 않을 수록 좋음) 비트 길이도 대체되고자 하는 코드보다 1비트 길지 말아야 한다(대체 코드가 짧으면 짧을수록 좋음). 상기 규칙은 응당 무작위 데이터를 압축하는 범용 규칙으로 되어야 한다. 비무작위 데이터를 압축과 압 축 해제 할 경우 단락[134]에서 더 많은 내용을 토론한다. 적합한 상황에서 그 자체의 목적에 적용되는 기타 규칙을 제정한다. 도표58b에 나타낸 바와 같이 이러한 코드는 SPUCV 0011-11011에서 시작되어 SPUCV 0010- 1100(다음은 5/6비트 PUCV)을 대체하는 것을 대체하고 SPUCV 0011-11011(블랙홀1과 Scode 0)는 반드시 Scode 1 에 의해 대체되는 것 등등이다. 이는 SPUCV그룹의 제일 낮은 비트 클라스, 즉 12비트 클라스에 정지된다. 이 비 트 클라스에는 한번도 발생되지 않았던 코드값이 존재한다. 따라서 값이 결여하는 SPUCV는 제일 마지막 하나의 Scode로 사용되어 별도의 코드를 사용하여 이를 대체할 필요가 없게 딘다. 그러나 디코딩할 경우 이러한 대체에 사용되는 코드값은 무엇인지를 반드시 알아야 하므로 Scode지정자를 사용하여 반드시 이를 메인 마스터헤드 또 는 분분적 마스터헤드에 기록해야 한다. 이는 일부 비트 지출을 초래한다. 따라서 대체는 SPUCV그룹의 어느 한 비트 클라스에 정지될 수 있는데 여기서 이러한 비트 지출은 진일보로 되는 대체에 의해 발생하는 비트 절약을 초과한다. 이것이 특정된 비트 클라스에 정지될 경우 최저 빈도를 가지는 다음의 SPUCV는 AAB코드를 사용하여 자신을 2개의 Scode로 분류하는데 한 Scode(제일 마지막 하나 이전의 한 Scode)는 이 Scode체인에서의 이전의 Scode를 대체하고 그 다음 다른 하나(최후의 Scode)가 자신을 대체한다. 예하면 도표58b에 나열된 대체 코드를 사용함으로써 만약 대체가 11비트 클라스에 정지되면 SPUCV 101111-11110(Scode 2)는 반드시 클라스에서 다음 최저 빈도를 가지는 SPUCV 01011-101011(Scode 3a)를 사용하여 대체해야 하는데 이는 SPUCV 01011-101011- 0(SPUCV 01011-101011자체를 대체)와 SPUCV 01011-101011-1(Scode 2, SPUCV 101111-11110를 대체)로 분류된다. 그러나 Scode 3b은 값이 결여한 코드이므로 만약 이를 사용하여 Scode2를 대체하게 되면 코드를 분할할 필요가 없게 된다. 따라서 이러한 특수 코드에 필요한 비트 지출을 사용하여 어느 비트 클라스에서 이러한 연속되는 코 드 대체를 정지할 것인지를 결정할 수 있다. 그러나 본 구현예에서 사용한 80,000비트의 무작위 데이터 집합을 통해 만약 4:1의 빈도 범위 비율을 사용하여 어느 코드값을 블랙홀0과 블랙홀1로 사용할 것인지에 관한 선택표 준을 결정하면 숫자 데이터 블랙홀, AAB코딩과 연속되는 코드 대체 기술을 통해 실현한 비트 절약이 사용한 특 수 코드의 비트 지출을 커버하기에는 부족하게 된다. 무작위 데이터 집합을 800,000비트로 증가하게 되면 빈도 범위(즉 4:1)는 비교적 낮은 비율로 축소하게 되는데 이는 이러한 숫자 데이터 블랙홀 기술을 이용할지라도 이 러한 무작위 데이터를 압축할 수 없게 됨은 분명한 것이다. 그러나 숫자 데이터의 비교적 높은 빈도 범위 비율과 비교적 적은 무작위 비트를 사용하게 되면 비트 절약이 사 용한 특수 코드 지정자의 비트 지출을 충분히 커버할 수 있도록 한다. 예하면 빈도가 14인 12비트 SPUCV 111111-101011을 사용하여 12비트 클라스에서 제일 높은 것을 블랙홀0으로 사용하여 결여한 SPUCV 111111- 111110과 짝을 이루도록 하여 이 이전의 PUCV를 흡수(예하면 전향 흡수)하도록 한다. 이 DDB를 사용하는 것은 매우 직접적이다. 12비트 클라스의 64개의 고유 코드값이 존재하는데 두개의 DDB에서의 매 하나는 모두 6비트를 이들 각각의 특수 코드 지정자로 사용하여 그들에 대해 식별한다. 이는 12비트가 필요하게 된다. 이는 블랙홀1 이 결여하는 코드값이므로 Scode로 이를 대체해야 하기 때문이다. 따라서 상기 80,000비트의 무작위 데이터 집 합에 대하여 비트 절약은 14 빼기 12비트로서 2비트와 같다. 이는 확실한 신호와 구현예로서 어떠한 상황에서 무작위 데이터는 압축될 수 있으므로 무작위 데이터가 영원히 압축되지 않는 정보이론에서의 비둘기집원리의 신화를 타파하였다. 더 많은 탐구를 거쳐 일부 규칙의 모드를 발 견하여 모든 상황에서 임의의 크기의 무작위 데이터를 압축함을 확실하게 말할 수 있다. 또한 다른 구현예도 아 래의 단락[134]의 도표 60에서의 어떻게 다른 한가지 기술을 사용하여 무작위 데이터를 압축하는 기회를 증가할 것인가하는 토론에 나타낼 수 있다. 따라서 상기 기술 조합은 압축될 자격이 있는 데이터 집합, 즉 4:1보다 큰 빈도 범위 비율을 만족시키는 빈도 범위 요구의 데이터 집합을 압축하는데 사용할 수 있고 상기 비율이 높을 수록 성공적인 압축을 진행하는 무작위 데이터 집합의 크기는 더 작을 수 있다. 무한한 크기 수량의 무작위 데이 터 집합을 사용하여 첸 프레임워크에서 무한한 인코더를 디자인 할 수 있으므로 상기 기술(또는 기타 부가적인 기술, 예하면 이상에서 소개한 불균일 데이터의 기술 및 기타 새로운 발명의 기술, 예하면 아래 단락[134]의 도 표60에서 인입한 기술 또는 기타 총명한 사람들이 디자인한 그러한 기술과 함께 사용)을 사용하여 특정 크기의 특정 무작위 데이터 집합에 대해 상응하는 빈도 범위 비율 모드를 식별하여 압축하는 것을 시도할 수 있다. 따 라서 사용된 데이터 집합의 크기(또는 이렇게 정의되어 처리하는 특정된 크기로 분류된 부분) 및 높은 비트 클 라스에서의 제일 빈번한 코드값: 낮은 비트 클라스에서의 제일 빈번하지 않는 코드값 사이의 빈도 범위 비율(에 하면 도표58c에 나타낸 바와 같이)은 숫자 데이터 집합(무작위 여부와 관계 없는 숫자 데이터 집합)의 두개의 특징인 바, 상기 특징은 숫자 데이터 집합의 모드 또는 규칙을 식별하는데 사용되어 상기 기술 조합으로 하여금 이를 성공적으로 압축할 수 있도록 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 150, "content": "[132]이상의 단락[131]에서는 첸 코드 기술을 개시하는 바, 즉 연속적으로 대체하여 디지털 데이터 블랙홀기술 과 함께 사용할 경우 무작위 데이터 집합이 상응한 빈도 범위 특징의 요구를 만족하는 정황에 도움이 되고 첸 프레임워크에서 적당한 인코더를 디자인한 상황에서 정보이론에서의 비둘기집원리의 신화를 타파한다. 따라서 적합한 상황에서 상이한 PUCV와 SPUCV그룹의 상이한 Max수와 비트수를 사용하여 기타 디자인된 이코더와 유사한 방식으로 여기서 설명한 방법과 동일한 방법을 이용하여 완성할 수 있다. 이 외의 실시방안은 첸 프레임워크의 인코더를 사용하는 상이한 조합을 더 포함하여 상이한 기술 또는 방법의 기타 상이한 해결방안을 사용할 수 있 다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 151, "content": "[133]여기서 소개한 숫자 데이터 블랙홀(DDB)는 여라 가지 형식을 가질 수 있다. 이는 AAB코드를 사용하여 앞 또는 뒤 또는 두개의 방향 심지어 사이드 웨이의 코드값(예하면 비트0과 비트1을 사용하여 대체 코드를 두개로 분류하여 두개의 코드값이 코드값의 사이드 웨이에 흡수 또는 표시되는 형식을 대표할 수 있는데 그 중 대체 코 드를 분할하여 표시한 코드 값은 데이터 집합에서의 임의의 곳에 나타날 수 있음)을 흡수(즉 표시) 할 수 있다. DDB를 사용하여 뒤의 코드값을 흡수하는 것이 더 간단하다. 앞에서 코드값을 흡수하게 되면 반드시 두개 또는 연속된 다수의 DDB가 나타나는 상황을 유의해야 한다. DDB의 코드와 연결된 것으로 지정될 경우 매 하나의 DDB 의 AAB코드는 반드시 우선 순서에 따라 저장되어야 하고 제일 마지막 DDB의 AAB코드를 처리한 후 이러한 AAB코 드는 반드시 반대되는 순서로 배치(즉 AAB코드의 반대되는 배치 기술을 사용하여 디코딩 후의 앞의 코드값이 다 른 한 DDB로 형성될 수 있는지 여부를 검사하고 필요할 경우 진일보로 대응되는 코드를 디코딩)되어 디코딩을 진행할 때 정확한 순서로 AAB코드의 디코딩을 해석함으로써 흡수된 코드값을 디코딩할 수 있도록 해야 한다. 또 한 비트 코드, 즉 비트0 또는 비트1(관련되는 구분 비트)을 사용하여 구분해야 하는데 암호화된 코드 출력 스트 림의 첫번째 암호화된 코드값으로 나타난 DDB로서 앞에서 코드값을 흡수한 DDB(만약 맞으면 이상의 구분 비트도 반드시 흡수된 코드값을 나타내는 AAB코드를 따라야 하고, 만약 아니면 상기 구분 비트는 충분하다)인지를 구분 해야 한다. 블랙홀이 두개의 방향에서 코드값을 흡수하는 것에 대하여 비트 절약은 더 많을 수 있는데 이는 2개 의 AAB코드를 사용할 수 있고 하나는 앞과 뒤에서 흡수한 매 하나의 코드값에 사용된다. 몇개의 DDB가 모일 경 우 이는 더 복잡해진다. 따라서 DDB가 부딪치는 매 하나의 가능한 상황 또는 시나리오에 대해 진일보로 분석하 고 그 다음 어떻게 코딩을 완성할 것인지에 관한 규칙을 건립한다. 예하면 만약 어떠한 원인으로 AAB코드의 반 대 배치를 사용하지 않고자 하면 예외적인 규칙을 설치할 수 있는 바, 즉 두개의 DDB가 연속으로 나타날 경우 그 중의 하나는 상응하는 흡수방향에서 AAB코딩을 진행하여 관련 코드값(즉 기타 DDB)을 흡수하지 않도록 할 수 있다. 이러한 예외적인 규칙은 일방향 또는 양방향 흡수를 디자인할 수 있다. DDB를 사용하여 앞 또는 뒤 또는 두개의 방향에서 코드값을 흡수하기 위하여 관련 마스터헤드에 DDB타입의 지정자를 더 포함하여 이와 관련되는 AAB코드를 정확히 암호화할 수 있도록 한다. 이 외에 앞 또는 뒤에서 나타내는 코드값은 대응되는 DDB와 일정한 거리 이격되도록 디자인 될 수 있고 통상적으로 앞 또는 뒤의 코드값에서 AAB코딩으로 흡수 또는 표시될 수 있 으나 또한 대응되는 DDB의 앞 또는 뒤의 지정된 고정 수량의 자리에서 흡수하거나 AAB코딩으로 표시하는 코드값 에 사용될 수 있다. 이러한 방식으로 원시적인 숫자 데이터 입력 스트림에서 제1 DDB를 만나 이러한 흡수 또는 표시를 진행할 경우 반드시 더 정밀한 규칙을 디자인하여 이러한 상황을 나타냄으로써 디코딩 과정에서 그 어떤 오해도 존재하지 않도록 한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 152, "content": "[134] 상기 계시를 통하여 무작위 데이터와 비무작위 데이터를 압축하는 방법 또는 기술 또는 기술조합을 아래"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 153, "content": "와 같이 간단히 요약할 수 있다. 무작위 데이터를 압축 또는 압축 해제. (1a)첸 프레임워크를 사용하여 디자인한 인코더에 대해 데이터 해석을 진행하여 무작위 데이터 집합의 빈도 통 계값을 발생: 이 단계는 첸 프레임워크를 사용하여 인코더를 디자인하는 바, 예하면 도표58에 표시된 빈도 통계값은 Max3 5비 트 0헤드 디자인 코드유닛 인코더를 사용하여 발생한 것이고 상기 인코더는 3개의 싱글 코드유닛으로 조성된 처 리유닛을 구비하며 2개의 처리유닛으로 조성된 슈퍼 처리유닛을 구비한다; (1b)코드값을 특수 코드(또는 이상 코드)로 지정하여 특수처리를 진행하되 AAB코딩을 사용한 숫자 데이터 블랙 홀 기술 및 코드 분할을 사용 또는 사용하지 않는 연속되는 대체 기술을 포함하여 새로운 대체 코드를 형성하여 사용하도록 한다. 무작위 데이터 집합의 빈도 통계값에 근거하여 PUCV와 SPUCV를 특수 코드, 예하면 블랙홀 코 드와 대체 코드로 선택하되 적당한 빈도 모드만 식별하면 되며; 이러한 선택은 인코딩과 디코딩의 목적에 기반 한 표준인 바, 예하면 이러한 상황에서 이는 숫자 데이터에 사용되고 구체적으로 무작위 데이터의 압축과 압축 해제에 사용되며; 이상에서 이미 계시한 바와 같이 어떻게 이 목적을 위해 코드를 선택할 것인지를 곗시하는 바, 예하면 간단하게 PUCV와 SPUCV그룹에서의 비트 클라스에 근거하여 그들의 빈도에 의해 특수 코드를 선택하 며; 예하면 매 하나의 비트 클라스에서 최고 빈도인 코드값은 블랙홀0의 후보자이며; 매 하나의 비트 클라스에 서 최저 빈도인 코드값은 대체 코드의 후보자이고 그 중의 하나(대체 코드0)는 블랙홀1로 사용되어 이와 블랙홀 0의 코드로 하여금 짝을 이루도록 하여 AAB코딩에 사용되어 앞 또는 뒤 또는 두 방향에서의 코드값을 표시(또는 흡수)하도록 하므로; 상기 특수 처리는 코드 분할이 있거나 없는 상황에서 AAB코딩과 연속으로 대체된 숫자 데 이터 블랙홀을 사용하여 새로운 대체 코드를 형성하며; 블랙홀 코드와 관련된 AAB코드는 단독으로 된 AAB코드 파일을 사용하여 이러한 AAB코드를 저장하는 것이 아니라 블랙홀 코드 다음에 메인 암호화된 코드 출력 파일에 놓여지고 병합되며 단독적인 AAB코드 파일을 사용하여 적합한 상황에서 AAB코드를 저장하는 것을 더 결정할 수 있으고; 상기 특수 코드에 사용되는 지정자(특수 코드 지정자)는 블랙홀 지정자와 대체 코드 지정자를 포함하며; 특수 코드 지정자와 일부 크기 지정자(아래 내용 참조)는 반드시 관련 마스터헤드에 기입되어야 하고; 인코딩의 편리를 위하여 전반 숫자 데이터 입력은 소량의 이진 비트, 어느 한 고정된 수량의 이진 비트로 조성된 부분, 예하면 80000비트를 하나의 부분으로 사용하여 처리하는 것을 포함하되, 상기 부분이 충분히 커 이러한 특수 처리를 진행하여 비트 절약(예하면 하나의 부분이 1개의 이진 비트로 조성되면 비트 절약을 실현할 수 없게 되므로 또다시 이렇게 무의미한 가정을 제출하지 않음)을 발생하기만 하면 상기 부분이 작을 수록 비트 절약은 더 적고 따라서 비교적 큰 비트 크기를 사용한 부분은 실현 가능함을 의미하는 바, 상기 부분에 대하여 더 많은 비트를 절약할 수 있으나 데이터 해석의 속도도 늦어지게 되므로 반드시 비트 절약과 인코딩 속도 사이 의 평형을 형성해야 하므로 일부 크기 지정자(상응하는 부분적 마스터헤드에 기입)를 사용하여 처리 중인 부분 의 비트 크기를 지시할 수 있으며; 만약 부분을 사용하면 부분의 경계를 뛰어넘는 PUCV 또는 SPUCV(예하면 80,000비트)는 부분 경계 이전의 일부 또는 새로운 부분으로서 처리할 수 있고 상응하게 부분 경계를 조절할 수 있다. (1c)무작위 데이터를 압축하기 위한 인코딩과정: 따라서 무작위 데이터를 압축하기 위한 인코딩과정은 아래와 같은 내용을 포함한다. (i)첸 프레임워크로 디자인한 인코더를 사용하여 숫자 데이터 입력을 판독하고 해석함으로써 무작위 데이터 집 합의 빈도 통계표를 생성한다. (ii)코드값을 특수 코드로 지정하여 특수 처리를 진행하는데 AAB코딩을 사용한 숫자 데이터 블랙홀 및 코드 분 할을 가지거나 가지지 않는 연속되는 대체를 포함하여 새로운 대체 코드를 이루어 사용하도록 한다. (iii)코드값을 판독하고 코드가 일반적인 코드인지 아니면 특수 코드(블랙홀0과 기타 Scode를 포함)인지를 구별 하며 이렇게 판독한 코드값을 인코딩하고 적합한 상황에서 특수 처리(여기서 특수처리는 DDB를 만났을 경우 AAB 코딩을 사용한 숫자 데이터 블랙홀 또는 대체 코드매핑 테이블을 포함하여 기타 특수 코드, 즉 대체 코드에 사 용함으로써 적합한 상황에서 연속되는 코드 대체를 진행하도록 함)를 응용하며 적합한 상황에서 상기 단계 (1cii)에서 지정한, 코드 분할을 가지거나 가지지 않는 연속적으로 대체된 디자인 규칙 및 AAB코드표 규칙에 근 거하여 암호화된 코드를 출력 파일에 기입함으로써 AAB코드를 발생하여 블랙홀에 의해 흡수한 코드값에 사용하 고 AABA코드는 적합한 상황에서 단독적인 AAB코드 출력 파일로서 메인 암호화된 코드파일에 기입되거나 기입 병 합된다. (iv)적합한 상황에서 (만약 인코더에 임베디드 되지 않으면) 지정자를 메인 마스터 헤드와 부분적 마스터헤드에 기입하는데 이러한 지정자는 적합한 상황에서 검사 합계 지정자, 첸 코드파일 싸인, 매핑 테이블 지정자, 주기 수 지정자, 코드유닛 정의 지정자, 처리유닛 정의 지정자, 슈퍼 처리유닛 정의 지정자, 최후 식별코드 지정자,시나리오 디자인 지정자, 언이브너/이브너 지정자, 순환주기 지정자, 빈도 지정자, 특수 코드 지정자, 일부 크 기 지정자, 숫자 데이터 블랙홀 타입의 지정자를 포함한다. (1d)무작위 데이터를 압축하기 위한 디코딩 과정: 무작위 데이터를 압축 해제하기 위한 디코딩과정은 아래와 같은 내용을 포함한다. (i)첸 프레임워크로 디자인한 인코더를 사용하여 암호화된 코드파일을 판독하고 해석한다. (ii)적합한 상황에서 상기 단계(1cii)에서 지정한, 코드 분할을 가지거나 가지지 않는 연속적으로 대체된 디자 인 규칙 및 AAB코드표 규칙에 근거하여 코드값을 디코딩(즉 적합한 상황에서 코드값에 사용되는 코드 매핑 테이 블을 대체)하고 복호화된 코드를 복호화된 코드 파일에 기입하며 마스터헤드에 기록되거나(또는 디코더에 임베 디드된) AAB코드와 지정자를 검색하여 블랙홀이 흡수한 코드값을 디코딩하고 이들을 복호화된 코드 파일의 적당 한 자리에 기입한다. 이는 무작위 데이터가 압축 가능하다는 다른 한 증거로서 도표58c에 나열된 프로그램으로 생성한 72.003비트의 무작위 데이터의 빈도 분포의 한 구현예이고 상기 행을, if not FileExists('ff') then GenerateRandomFile('ff', 10000) 로부터 if not FileExists('ff') then GenerateRandomFile('ff', 9000) 로 수정한다. 이러한 빈도 분포의 구현예는 아래 도표60a에서 나열한다. 도표60a Max3 5비트0헤드 디자인 코드유닛 인코더를 사용하여 판독한 72,003비트 무작위 데이터 집합의 코드값의 빈도 분포 000 2004 ( -1 ) 1100 1059 ( 0 ) 0011 1034 ( 0 ) 0110 1023 ( 0 ) 0010 987 ( 0 ) 1000 982 ( -1 ) 0100 914 ( -1 ) 10011 546 ( 0 ) 11100 541 ( 0 ) 11010 523 ( 0 ) 10110 517 ( 0 ) 01110 506 ( 0 ) 01111 502 ( 0 ) 01011 499 ( 0 ) 10010 484 ( 0 ) 01010 477 ( 0 ) 11110 476 ( 0 ) 11011 470 ( 0 ) 10100 470 ( 0 ) 111011 264 ( 1 ) 101010 261 ( 1 ) 111110 259 ( 1 ) 111010 250 ( 1 ) 101111 248 ( 1 ) 101011 244 ( 1 ) 111111 237 ( 1 ) 101110 227 ( 1 ) 총 비트수: 72003 aab증가량: -1910 27x27 000-000 199 000-1100 148 000-0100 142 …… (리스트가 너무 길어 관련되지 않는 코드값을 건너뜀) 11011-10100 17 111111-1100 17 101010-10100 17 11비트 클라스에서의 최고 빈도 101111-0100 17 10110-10100 17 0011-111110 17 10010-11100 17 0110-111011 17 10100-10011 17 0010-111110 17 10100-01010 17 1000-111010 17 01110-10011 17 111110-0011 17 01010-10110 17 111110-0110 17 10011-01110 17 01111-01011 17 111110-1100 17 01011-01111 17 01010-10011 17 01011-10110 17 11110-10010 17 11100-10010 16 11110-01110 16 10110-10011 16 0100-111010 16 01110-11110 16 11010-10100 16 11100-10100 16 0110-101110 16 101011-1000 16 101111-0110 16 1100-111011 16 111010-0011 16 0011-101011 16 01110-11011 16 101011-11010 16 11비트 클라스에서 두번째로 높은 빈도 10100-10100 16 01110-10010 16 111011-0011 16 01111-11110 16 11100-01011 15 01010-11010 15 1000-111110 15 11010-11010 15 11010-01111 15 11011-11110 15 101111-0010 15 10011-11010 15 11100-11010 15 11010-01110 15 11011-11010 15 111111-0010 15 101011-1100 15 0011-111011 15 101010-0010 15 1100-111110 15 0100-111011 15 01111-10010 15 1100-101010 15 01110-11010 15 11100-11011 15 101110-10011 15 11비트 클라스에서 세번째로 높은 빈도 11100-10011 15 10011-11011 15 101110-0110 14 01110-11100 14 10100-10110 14 01110-10110 14 11011-01111 14 101010-1000 14 10011-101010 14 111010-11110 14 111010-01111 14 01010-11011 14 01011-11110 14 111110-0100 14 11110-01011 14 01111-11100 14 11010-111011 14 11110-10100 14 11110-01111 14 111011-11100 14 0100-101010 14 0100-101111 14 111111-0011 14 11100-01110 14 111111-1000 14 0010-111011 14 111011-1100 14 0010-111010 14 1000-101110 14 0010-101010 14 10110-10110 14 10110-01010 14 10110-01011 14 10110-101011 13 10100-11100 13 10011-10100 13 01011-01011 13 01011-10010 13 111110-01010 13 101011-0110 13 0011-111111 13 10010-10100 13 0100-101011 13 11011-11100 13 101111-0011 13 101111-10110 13 0110-101010 13 0010-101011 13 10100-10010 13 10010-10011 13 01011-111111 13 101010-0011 13 111010-10010 13 111010-1100 13 01111-10110 13 111010-0010 13 01010-11100 13 01010-10010 13 11110-01010 12 01111-11010 12 111011-10100 12 111111-10011 12 11010-11110 12 111011-01110 12 1000-111111 12 01110-101011 12 11100-111010 12 11100-101110 12 111111-10110 12 11011-01010 12 10100-11110 12 11100-01111 12 10010-101010 12 101010-01010 12 1100-101111 12 01110-01111 12 111110-10011 12 10011-111110 12 101110-0100 12 01010-11110 12 01110-01011 12 01111-01111 12 111011-01010 12 0110-101011 12 0110-111111 12 101110-0011 11 101011-01010 11 101110-1000 11 111110-11100 11 111111-0110 11 111011-101010 11 12비트 클라스에서의 최고 빈도 11011-101110 11 111011-10110 11 101010-11100 11 101010-10110 11 101010-10011 11 111010-101011 11 12비트 클라스에서 두번째로 높은 빈도 10010-01111 11 10010-10010 11 10010-01110 11 01010-101011 11 10100-01011 11 01010-101010 11 01110-111110 11 11100-111111 11 0100-111111 11 01011-11100 11 1100-111111 11 1100-111010 11 11010-10110 11 11100-01010 11 11010-01010 11 11010-11011 11 101011-10110 10 11110-11011 10 111011-0110 10 01110-101111 10 0110-101111 10 0011-101110 10 11010-111111 10 1000-101010 10 101011-10010 10 0010-101111 10 11110-111111 10 101111-11100 10 111010-0100 10 111010-1000 10 111010-11011 10 10010-101011 10 101010-01110 10 11110-11110 10 111110-11110 10 111110-01111 10 111110-10110 10 11011-11011 10 111111-0100 10 11100-111011 10 11100-101111 10 11011-01011 10 111111-11100 10 101110-10100 10 0100-101110 10 11110-10011 9 111010-01011 9 10110-101010 9 10010-111110 9 10011-101111 9 11010-101010 9 11010-101111 9 11100-101010 9 11011-111011 9 10100-101110 9 111111-10010 9 101110-11100 9 01011-111011 9 111111-01010 9 10010-101111 9 101110-01111 9 101110-01010 9 11100-111110 9 101110-10110 9 101011-11110 9 111011-01111 9 111011-11010 9 10100-111011 9 01011-11011 9 10010-111011 9 11010-111110 9 101010-10010 9 111011-0100 9 111010-11100 8 11011-101010 8 111010-01010 8 101111-101111 8 12비트 클라스에서 세번째로 높은 빈도 101011-111010 8 11010-101110 8 101011-11100 8 101011-11011 8 111111-11110 8 11011-10110 8 11110-101011 8 111111-11011 8 01111-111110 8 111111-101111 8 11010-111010 8 01010-111010 8 111110-11011 8 11100-101011 8 01011-01010 8 01011-111010 8 01011-101011 8 10011-111011 8 101010-01011 8 111011-01011 8 101110-11110 8 111011-101111 8 10011-101110 8 01110-01110 8 01110-111111 8 111010-10100 8 10010-01011 8 111111-01111 8 111111-01110 8 101111-10010 8 101111-01111 8 10011-111111 8 111110-1000 8 11110-101111 7 01111-101011 7 111010-01110 7 01111-111011 7 11110-101110 7 01111-01010 7 111111-10100 7 111110-111010 7 01010-10100 7 01010-01110 7 111111-111011 7 01011-101010 7 01111-111111 7 01110-111011 7 101010-11110 7 11011-111110 7 101011-10011 7 10110-111010 7 11011-111010 7 101110-11011 7 101111-01011 7 101011-01011 7 101010-0100 7 101110-01011 7 101010-11010 7 101010-11011 7 10011-101011 7 101111-10011 7 01110-101110 7 10011-111010 7 111010-10011 6 101111-01110 6 111010-11010 6 01010-111011 6 101111-10100 6 01110-01010 6 101010-101110 6 10010-111010 6 01011-101110 6 111110-111110 6 111110-01110 6 101110-101010 6 101111-11010 6 101110-111111 6 111110-10010 6 01110-111010 6 10110-111011 6 11110-101010 6 10100-111111 6 01111-101010 6 101011-01110 6 10110-10010 6 10110-111110 6 01111-101110 6 11110-111010 6 101011-10100 6 11011-111111 6 01111-101111 6 101010-111110 5 10100-101111 5 10100-101010 5 111110-101010 5 10010-101110 5 101010-111111 5 101011-01111 5 101010-101010 5 01111-111010 5 01110-101010 5 101010-111010 5 111110-10100 5 111110-01011 5 111111-111111 5 01010-111110 5 10110-101111 5 11110-111110 5 111111-01011 5 101111-101011 5 11110-111011 5 101110-11010 5 101111-01010 5 111011-11110 5 101011-111111 5 10010-111111 5 11010-101011 5 111011-111011 5 111010-101110 5 11011-101111 5 10100-101011 5 10100-111010 4 101110-01110 4 111011-111111 4 101110-10010 4 111111-11010 4 111011-10011 4 111011-10010 4 111011-111010 4 111011-11011 4 101111-111110 4 01010-101110 4 101111-111111 4 01011-111110 4 101011-0011 4 01010-111111 4 111010-111010 4 111010-111011 4 101111-11110 4 101111-101010 4 111110-101111 4 111110-101011 4 111110-11010 4 01011-101111 4 10110-111111 3 101111-11011 3 10100-111110 3 111010-101111 3 111010-101010 3 111111-111010 3 101011-111110 3 111111-101010 3 111111-101110 3 101111-111011 3 101011-101010 3 10110-101110 3 101111-111010 3 101010-111011 3 101110-101011 3 101110-101111 3 101110-111110 3 111110-111111 3 111110-111011 3 101010-01111 3 111011-111110 3 111010-111110 2 111111-101011 2 101011-101110 2 101010-101111 2 111110-101110 2 111010-10110 2 111111-111110 2 111010-111111 2 01010-101111 2 101011-101011 1 101011-101111 1 111011-101011 1 101110-111010 1 111011-101110 1 101111-101110 1 101011-111011 1 101010-101011 1 11011-101011 1 101110-111011 1 101110-101110 0 Blackhole 1 블랙홀1 도표60b 도표60a의 빈도 통계값의 12비트 클라스 SPUCV의 빈도 카운트의 분포 빈도 카운트 12비트 클라스의 고유 SPUCV의 수량 0 1 SPUCV 101110-101110을 블랙홀1로 사용 1 9 2 7 3 16 4 9 5 10 6 4 7 2 8 4 9 0 10 0 11 2 SPUCV 111011-101010과 111010-101011 임의의 하나를 블랙홀0으로 사용 합계: 64개의 고유 코드값 상술한 바와 같이 무작위 데이터 집합의 크기를 비교적 작은 값인 ff=9000으로 하여 도표60a를 생성하고 도표 60b는 도표60a의 빈도 통계값을 사용한 12 비트 클래스에서의의 SPUCV의 빈도 카운트 분포이다. 도표60b에 도시 된 바와 같이 두개의 최고 빈도가 11개의 카운트인 코드값이 존재한다. 첫번째 또는 두번째(즉 SPUCV 111011- 101010과111010-101011)를 블랙홀0으로 선택하여 0 빈도 카운트를 가지는 블랙홀1로서의 결여한 SPUCV 101110- 101110과 짝을 이룰 수 있다. 임의의 하나를 사용하는 것을 통해 비트 절약은 단지 11비트뿐이고 상용적인 방법 을 사용하여 계산한 두개의 블랙홀 지정자의 비트 지출은 12이트이다. 이는 명백히 적합한 방법이 아니다. 따라 서 다른 한 새로운 기술을 디자인하여 블랙홀 지정자에 필요한 비트 길이를 축소할 수 있다. 이는 또다시 범위 의 개념을 사용한다. 12비트 클라스의 코드값SPUCV 111011-101010을 사용하는 바, 최고 빈도 카운트인 블랙홀0은12비트 클라스 SPUCV 의 최고 빈도에 최저 한계를 제공한다. 2비트(여기서 사용한 이진 비트의 수량은 처리 중인 숫자 데이터 집합에 서 결정된 빈도 모드 또는 규율성에 근거하여 조절될 수 있음)를 사용하여 두번째 최고 빈도 카운트의 12비트 코드값을 지시할 수 있는데 비트 길이로 계산하면 그 곁에서 조금 떨어져 있다. 두개의 비트 지정자는 4개 비트 의 비트 길이의 폭을 부여할 수 있다. 이는 대부분의 상황에 있어서는 충족한 것이다. 만약 이것이 이 목적에 사용할 수 없고 또 최고 빈도의 12비트 코드값이 이미 디자인되고 선택된 비트 길이 범위 밖에 있으면 이를 압 축할 수 없는 무작위 데이터로 간주할 수 있다. 따라서 비트00은 11비트SPUCV에 사용되고 비트01은 12비트SPUCV 에 사용되며 비트10은 13비트SPUCV에 사용되고 비트11은 14비트SPUCV에 사용된다. SPUCV 111011-101010이 11비트이므로 이에 사용되는 지정자는 비트00이다. 만약 최고 빈도를 가지는 코드값을 블랙홀0으로 선택하고 결여한 코드값을 블랙홀1로 선택하면 인코딩을 완료한 후 암호화된 코드를 해석하며 SPUCV의 빈도 카운트의 분포는 1로 변하는 바, 이는 아래 도표60c에 나타낸 바와 같다. 도표60c 도표60a의 빈도 통계값을 사용한 암호화된 코드에서의 12비트 클라스SPUCV의 빈도 카운트 분포 빈도 카운트 12비트 클라스의 고유 SPUCV의 수량 0 0 1 9 2 7 3 16 4 9 5 10+1 SPUCV 111011-101010 은 블랙홀0 6 4+1 SPUCV 101110-101110 은 블랙홀1 7 2 8 4 9 0 10 0 11 2-1 SPUCV 111010-101011 합계: 64개의 고유 코드값 이러한 가정은, 블랙홀0과 블랙홀1에 사용되는 3/4비트 PUCV와 5/6비트 PUCV의 빈도 카운트의 분포가 원시적인 12비트 SPUCV 111011-101010를 위한 비례를 유지하는 것에 기반한다. 이상이 정확하다고 가정할 경우 고정된 디자인의 블랙홀을 사용하여 3/4비트 PUCV를 흡수하고 블랙홀1을 사용하 여 5/6비트 PUCV를 흡수할 수 있다. 파동이 없으면 암호화된 코드를 해석할 수 있고 3/4비트 PUCV의 절반이 더 큰지 아니면 5/6비트 PUCV의 절반이 더 큰지를 알 수 있다. 만약 변경을 허용하면 1개의 비트를 사용하여 어느 12비트 코드값이 블랙홀0(예하면 자연수 정렬에서 우선 나타난 값)인지를 지시할 수 있고 그 다음 어느 한 코드 값을 식별하여 5개의 빈도 카운트와 6개의 빈도 카운트의 매 그룹에서 온 것인지를 결정한 다음 블랙홀1은 자연 적으로 이미 알고 있는 것이 된다. 5와 6 빈도 카운트 그룹에서 이 두개의 DDB를 식별하기 위하여 모두 55개의 옵션(즉 10+1=11과 4+1=5 및 11*5=55)이 선택에 사용된다. 따라서 이는 5 내지 6비트(AAB코딩을 사용)를 사용하 여 이러한 식별을 진행한다. 그래서 모두 2개의 비트를 사용하여 블랙홀0의 빈도 카운트를 지시할 수 있고 1개 의 비트는 어느 DDB코드값이 결여한 코드값인지를 지시하고 5 내지 6개의 비트는 두개의 DDB를 식별하는데 사용 되는 바, 모두 8 내지 9개의 비트이다. 따라서 획득한 비트 절약은 11개 비트에서 8 내지 9개의 비트를 덜어낸 것으로서 2 내지 3개의 비트에 상응한다. 그러나 두개의 DDB가 암호화된 코드에서 발견된 자리(즉 어떤 빈도 카운트 그룹)는 일정한 정도의 파동이 있을 수 있다. 가능한 그루핑은 5와 6개 빈도 카운트 그룹, 4와 7개 빈도 카운트 그룹, 3과 7개 빈도 카운트 그룹, 2 와 9개 빈도 카운트 그룹, 1과 10개 빈도 카운트 그룹 등 모두 5가지 가능한 그루핑이 존재한다. 그러나 매우 정확한 것은 2/9그룹과 1/10그룹은 고유한 것이므로 4가지 가능한 그루핑이 여전히 존재한다. 따라서 2개의 비 트를 더 제공하여 이러한 가능성을 지시하는데 사용될 수 있다. 그러나 2개의 비트를 더 제공하는 것은 필요가 없을 수 있는데 이는 두개의 DDB가 5/6과 6/7빈도 카운트를 초과하는 그루핑에 들어갈 기회가 아주 작기 때문이 다. 또한 이들은 압축할 수 없는 무작위 데이터에 또다시 분류될 수 있다. 따라서 1개 비트를 사용하여 두개의 DDB가 들어간 빈도 카운트 그루핑의 이러한 파동을 허용한다. 블랙홀0과 블랙홀1의 두개의 특별한 코드 지정자의 비트 지출이 상이한 그룹에 들어가는 것은, 5/6빈도 카운트 그루핑에 사용되는 5 내지 6개 비트, 4/7그루핑에 사용되는 4 내지 5개 비트(10*3). 따라서 만약 빈도 카운트 그루핑이 두개의 DDB에 사용되면 비트 절약은 2 내지 3개의 비트에서 1비트 내지 1 내 지 2개의 비트를 감소한다. 만약 그루핑이 4/7이면 비트 절약은 변화가 없으므로 2 내지 3개의 비트에서 1비트 를 절감하여 DDB의 빈도 카운트 그루핑을 지시하는데 사용되고 또 두개의 DDB의 특수 코드 지정자의 비트 지출 이 감소되어 발생한 1개의 비트의 증가는 이를 동일하도록 유지시켜준다. 따라서 비트 절약은 1 내지 2개의 비 트 또는 2 내지 3개의 비트이다. 따라서 이는 처리 중인 숫자 데이터 집합으로부터 수집한 정보(즉 빈도 카운트 그루핑에 관한 통계 데이터)를 사용하여 축소한 것인데 예하면 DDB의 특수 코드의 지정자, 지정자 비트 지출의 기술에 사용된다. 1비트를 제공하여 압축 가능하거나 압축할 수 없는 데이터의 지정자로 사용하는데 결과는 균등하거나 또는 1 내 지 2비트의 절약이 있게 된다. 사용된 인코더가 샘플링한 PUCV의 빈도 분포의 규율성을 고려하여 두개의 DDB가 3/8그루핑에 들어가는 가능성은 매우 작거나 매우 낮게 되므로 두개의 DDB가 들어가는 기회의 순서는 먼저 5/6 그루핑이고 다음은 4/7그루핑이며 그 다음은 3/8그루핑일 가능성이 작고 심지어 더 작게는 2/9 또는 1/10 그루 핑이다. 또한 상술한 바와 같이 만약 DDB가 5/6과 4/7 빈도 카운트 구룹의 그루핑에 들어가지 않으면 무작위 데 이터 집합은 압축할 수 없는 데이터로 분류된다. 이러한 데이터는 상기 압축 가능/압축할 수 없는 데이터 비트 를 사용한다. ff=9,000을 사용하여 상기 빈도 분포를 생성한 구현예는 약 8개의 구현예를 생성하는데 1개만이 결여값이 없는 12비트 코드값임을 더 발견했다. 따라서 이는 이상 현재까지 소개한 기술을 사용하면 더 높은 비트 절약 가능성 이 있음을 의미한다. 다른 한 실시방안에서는 11비트 클라스에서의 최고 빈도의 코드값 SPUCV101010-10100을 블랙홀0으로 더 사용하 여 블랙홀1, SPUCV 101110-101110과 짝을 이루도록 할 수 있는데 이와 동시에 적합한 상황에서 유사한 방식으로 지정자 비트 지출을 절약하는 기술을 사용할 수 있다. 첸 프레임워크에서 디자인한 상이한 인코더에서 샘플링한 상이한 크기의 무작위 데이터 빈도 분포의 더 많은 규 칙 모드는 병합될 것이고 이들에 대한 규율을 이미 결정하였으므로 더 정밀한 규칙과 새로운 기술은 개발될 것 이다. 이러한 비트 지정자의 용도 및 이들 각각의 크기도 상이한 실시방안에서 조절될 것이고 조절은 첸 프레임 워크 디자인을 이용한 상이한 인코더를 통해 결정된 것이며 이는 무작위인지 비무작위인지, 상이한 크기의 숫자 데이터 집합인지, 특정 빈도 모드 또는 규율인지와 관계 없다. 따라서 본 발명에서 인입한 기술은 그들이 무작위 데이터를 압축함에 있어서의 유용성을 이미 설명하였다. 또한 이러한 기술은 무작위 데이터 집합에서 판별한 규율 모드의 정보를 더 이용하여 참조로 사용함으로써 비무작위 데이터를 압축하고 압축 해제하도록 할 수 있다. 비무작위 데이터에 대한 압축과 압축 해제 이상의 에서 개시한 방법을 사용하여 무작위 데이터를 압축하므로 동일한 방법을 사용하여 비무작위 데이터 를 압축할 수도 있다. 특수 코드의 지정을 결정하게 될 경우 비무작위 데이터의 성질을 고려할 필요가 있다. 기 본적으로 이러한 상황에서 특수 코드를 지정하기 위한 논리와 무작위 데이터를 압축하는 상황은 동일한 바, 이 는 목적이 동일, 즉 비트 사용 절약을 실현하기 위함이다. 그러나 무작위 데이터가 비무작위 데이터가 준수하지 않는 일부 규율성을 준수하고 비무작위 데이터 집합의 데이터 분포가 서로 현저한 차이가 있는데 이는 바로 특 수 코드를 지정할 경우 일부 이러한 변화를 왜 만족시켜야 하고 도 더 적당한 기술을 사용하여 이러한 변화에 적응하는 것이 필요한 것인지를 알려준다. 다라서 특수 코드를 지정하기 위하여 적합한 상황에서 아래와 같은 규칙을 제정하고 준수할 수 있다. (2a)비무작위 데이터 집합에 PUCV가 결여할 가능성: 소량의 무작위 데이터 또는 비무작위 이진 비트를 처리하는 부분은 비트 절약을 실현할 수 없고 마스터헤드에 기록한 지정자의 비트 지출을 보상할 수 없게 될 수 있다. 따라서 같은 방식으로 비무작위 데이터의 일부 크기 는 매우 작지 말아야 한다. 그러나 매우 큰 크기를 가지더라도 비무작위 데이터 집합은 데이터 집합에서 하나 또는 다수의 PUVC를 결여할 수 있다. 또한 이러한 PUCV결여 현상은 적합한 상황에서 충분히 이용되어 이러한 결 여된 PUCV를 특수 코드, 블랙홀1 또는 기타 Scode로 지정할 수 있다. 블랙홀1이 되기 위한 표준은 선택되고자 하는 코드값 길이가 선택된 블랙홀0보다 1비트 길지 말아야 하는데 이는 블랙홀1이 AAB코드를 사용하여 앞 또는 뒤의 코드값을 흡수함으로써 1비트(현재의 토론은 블랙홀이 일방향으로 코드값을 흡수하는 것을 토론하는데 상응하게 블랙홀을 통하여 양방향으로 흡수하는 규칙을 조절할 수 있음)를 절약할 수 있기 때문이다. 따라서 Scode0을 블랙홀1로 사용하되 그 중에서 비트 길이가 1비트 길다는 것은 데이터 확장을 의미하는 바, 이는 데이 터 압축을 실현하는 방향을 향한 방향이 아니다. 따라서 무작위와 비무작위 데이터에 대해 데이터 압축을 진행 하는 규칙(블랙홀과 연속되는 코드 대체 기술의 용도의 영향을 받지 않는 기타 코드값이 동일한 비트 크기의 인 코더를 사용하여 인코딩하고 인코더 자체가 동일한 비트 크기 인코더로 사용되는 클라스에서의 인코더를 판독한 다고 가정하면 상술한 바와 같이 데이터 확장이나 데이터 수축이 없는 인코더 자체가 대표하는 한가지 암호화 형식이 아닌 동일한 비트 크기 인코더를 사용하여 인코딩)은, 블랙홀을 사용하여 발생한 비트 이득이 응당 대체 코드에 마스터헤드에 사용되는 비트 지출을을 더하여 조성한 비트 결여를 초과하는 것이다. 따라서 상기 탑 규칙에서 숫자 데이터 집합을 압축과 압축 해제하는 데이터 분포 및 데이터 처리와 같은 이러한 활동의 관련 목적을 진행할 경우 실제 상황에 근거하여 적당한 시기에 기타 규칙을 완화할 수 있다. 그 중에 결 여 PUCV가 존재하지 않는 상황을 토론하는 상황에서 그 중에 결여 PUCV를 압축하는데 사용할 수 있는 비무작위 데이터 집합의 기술의 더 많은 내용은 별도로 토론할 수 있다. (2b)비무작위 데이터 집합에는 결여 PUCV가 존재하지 않음: 상기와 같이 개시한 숫자 데이터 블랙홀과 연속되는 코드 대체가 무작위 데이터를 압축하는데 사용될 수 있으므 로 이러한 기술은 비무작위 데이터를 압축할 수도 있다. 비무작위 데이터는 변하가 아주 크고 예측할 수도 없으 나 동일한 비트 크기의 무작위 데이터 집합(예하면 본 구현예에서 사용한 80,000개 이진 비트)의 빈도 분포 통 계값을 참고(상술한 바와 같이 첸 프레임워크 정의의 인코더를 사용하여 획득)로 사용하여 검사하고 비교할 경 우 결여 PUCV가 존재하지 않는 상황에서 숫자 데이터 블랙홀과 연속되는 코드 대체기술을 사용한 방법 또한 비 무작위 데이터 집합을 압축하는데 사용될 수 있다는 결론을 얻게 되고 이 결론은 논리에 부합되는 것이다. PUCV 가 결여하지 않는 상황에서는 반드시 코드 분할을 가지거나 가지지 않는 것과 관계 없이 연속되는 코드 대체를 사용하여 블랙홀1로 사용되는 부가적인 코드값을 제공함으로써 블랙홀0과 합작하여 AAB코딩으로써 기타 코드값 을 흡수하도록 한다. 예기할 수 있는 것은 비무작위 데이터 집합에서의 임의의 비트 클라스에서의 이의 최고 빈 도의 코드값의 빈도는 무작위 데이터 집합에서의 동일한 비트 클라스에서의 상응한 코드값의 빈도보다 훨씬 높 을 수 있다. 하나의 비트 클라스에 대해 이렇지 않으면 다른 한 비트 클라스에서 이러한 현상을 발견할 수 있다. 빈도가 제일 낮은 그러한 코드값에 대하여도 마찬가지이다. 또한 무작위 데이터 집합으로부터 유도한 참 고를 사용하여 아래와 같은 규칙을 준수할 수 있다. (i)비무작위 데이터 집합의 한쌍의 블랙홀0과 블랙홀1 사이의 빈도 차이 범위는 동일한 크기의 무작위 데이터 집합보다 커야 하고 무작위 데이터 집합에서의 상응한 한쌍의 빈도 차이는 아래와 같다: 블랙홀0의 빈도는 응당 블랙홀1 빈도의 4배 또는 그 이상이고 블랙홀1의 비트 길이는 블랙홀0의 비트 길이보다 1비트 이상 길지 말아야 하는데 이는 블랙홀1이 처리 중인 데이터 집합에서의 빈도가 그렇게 빈번하지 않고 비트 길이가 여기서 규정한 것보다 더 짧다는 것을 의미하고 또 기타 코드값이 이러한 요구를 만족시키면 이러한 코드값이 블랙홀1로 사용 될 수도 있다는 것을 의미한다. 블랙홀0의 빈도>=블랙홀1의 빈도의 4배 플러스 블랙홀0의 비트 길이가 블랙홀1의 비트 길이보다 1비트 큼 (ii)이러한 상황에서 치리 중인 데이터 집합에 결여 코드가 존재하지 않으므로 블랙홀1의 코드값은 사용하도록 제공한 코드값()으로서 블랙홀0을 대체하고 여기서 절반을 흡수한 코드값은 상응한 AAB코드로 나타내고 한 코드 값은 다른 한 코드값으로 대체해야 한다. 상술한 바와 같이 이는 연속되는 코드 대체가 도움을 제공하는 상황이 다. 이러한 연속되는 코드 대체에 사용되는 규칙은 아래와 같을 수 있다. 모든 합산된 Scode의 총 빈도=<Scode 0의 빈도 플러스 매 하나의 연속되는 Scode의 빈도는 응당=<대체되고자 하는 코드 빈도의 절반 플러스 매 하나의 연속되는 Scode의 비트 길이는 대체되고자 하는 코드의 비트 길이보다 1비트 길지 말아야 하고 만약 더 길거나 1비트 증가하면 1비트 증가할 때마다 이러한 연속되는 Scode의 빈도는 응당 진일보로 절반 감소되어 야 한다. 모든 Scode의 총 빈도가 낮을 수록, 또 이 비트 길이가 짧을 수록 이상에서 지정한 규칙은 더 양호화다. 만약 상기 규칙을 만족시키면 기타 코드값을 Scode로 사용할 수도 있다. 상술한 바와 같은 숫자 데이터 블랙홀과 연속되는 코드 대체의 방법을 사용함으로써 아주 적은 상황에서만 관련 된 비무작위 데이터 집합에 대해 압축 처리할 수 없게 된다. 적합한 상황에서 이 점에 대하여 본 발명의 우선권 요구에 따른 2017년 2월 22일에 제출한 PCT/IB2017/050985를 참조할 수 있다. 상기 규칙을 사용한 후에는 요구를 만족시키는 블랙홀을 식별할 수 없을 수 있는데 출현한 코드값이 특정된 비 트 클라스에 매우 집중, 예하면 3비트 클라스와 하나의 코드값(즉 000)에 집중되었음을 확신할 수 있다. 이러한 상황에서 잠시 뒤에 아래의 AAB코드를 사용하여 선택함으로써 PUCV000을 압축하는 것을 고려할 수 있다. 도표61a PUCV 000에 고도로 집중된 코드값을 발생하기 위한AAB코드표 0 1000 1001 1010 10110 10111 11000 11001 11010 110110 110111 111000 111001 1111000 1111001 11110100 11110101 11110110 11110111 11111000 11111001 11111010 11111011 11111100 11111101 11111110 11111111 도표61b 코드값이 PUCV 000에 집중되는데 사용되는 AAB코드표, 손실이 4비트 PUCV에 발생할 경우 적용되고 비교적 적은 수량의 4비트 PUCV를 가지는 데이터 집합에 적용된다. 00 01000 01001 01010 01011 01100 01101 01110 01111 10000 10001 10010 10011 10100 10101 10110 10111 11000 11001 11010 11011 11100 11101 111100 111101 111110 111111 도표61c 코드값이 PUCV 000에 집중되는데 사용되는 AAB코드표, 손실이 5비트 PUCV에 발생할 경우 적용되고 비교적 적은 수량의 5비트 PUCV를 가지는 데이터 집합에 적용된다. 00 0100 0101 0110 0111 1000 1001 101000 101001 101010 101011 1011000 1011001 1011010 1011011 1011100 1011101 1011110 1011111 111000 111001 111010 111011 111100 111101 111110 111111 도표61d 코드값이 PUCV 000에 집중되는데 사용되는 AAB코드표, 손실이 6비트 PUCV에 발생할 경우 적용되고 비교적 적은 수량의 6비트 PUCV를 가지는 데이터 집합에 적용된다. 00 0100 0101 0110 0111 1000 1001 10100 10101 10110 10111 11000 11001 11010 11011 11100 11101 111100 111101 11111000 11111001 11111010 11111011 11111100 11111101 11111110 11111111 도표61e 코드값이 PUCV 000에 집중되는데 사용되는 AAB코드표, 여기서 나머지PUCV는 저하된 빈도에 근거하여 내림차순으 로 코드값을 분포한 것이다. 00 0100 0101 0110 0111 10000 10001 10010 10011 10100 10101 10110 10111 11000 11001 110100 110101 110110 110111 111000 111001 111010 111011 111100 111101 111110 111111 상기 5가지 버전의 AAB코드표 디자인은 코드값을 다수의 부분()으로 분류하여 코드값의 데이터 분포에 근거하여 응용해야 하는 AAB코드 타입의 범위를 한정한다고 표명한다. 따라서 이들이 기대되고 적합할 경우 더 많은 이러 한 AAB코드표를 디자인하여 상기 규칙과 도표61에 나열된 AAB코드표를 보충할 수 있다. 상기 규칙과 도표61은 어떻게 숫자 데이터 블랙홀과 연속되는 코드 대체 기술 및 AAB 코딩 기술을 디자인하고 개발하여 비무작위 데이 터를 압축하기 위해 제정된 것으로서 이상에서 설명한 것은 이미 끝난 것이고 항상 최적화의 목적으로 출현하여 디자인과 개발을 진행할 수 있으며 그들에 대해 보충을 진행한다. 여기서 사용한 AAB코드표의 기술을 조절하여 DDB와 관련된 AAB코드표에도 적용함으로써 DDB를 사용하여 획득한 최대화된 비트 사용 이득을 획득한다. 디자인 에 근거하여 어느 DDB가 비트 사용에서 제일 많이 획득되는가에 근거하여 절반(또는 일부)이 비교적 높은 빈도 의 코드값을 이 DDB에 분포하여 흡수되도록 한다. 이는 비무작위 데이터 지집합에 대하여 코드값의 불균일 분포 로 인하여 매 하나의 DDB쌍의 두개반에 대해 반드시 처리 중인 데이터 집합의 코드값의 현재의 빈도 분포에 근 거하여 조절함을 의미한다. 따라서 AAB코드표도 상응되게 조절해야 한다. 따라서 처리 중인 비무작위 데이터 집 합의 데이터 분포에 근거하여 적당히 조절한 상기 규칙과 상기 AAB코드표는 결여가 없는 모든 PUCV의 비무작위 데이터를 거의 커버하는 상황에서 상기 AAB코드표는 처리 중인 비무작위 데이터 집합의 데이터 분포 상황에 근 거하여 적당히 조절한 것임은 자명한 것이다. 또한 일부 크기를 조절할 수 있는데 예하면 이를 80,000개 이진 비트로부터 10배 또는 100배 증가할 수 있고 이는 반드시 더 좋은 비트 절약 기회를 제공할 것이다. 마찬가지로 비무작위 데이터에 대하여 만약 상기 최적화 옵션을 사용하여 한 부분의 데이터를 압축함으로써 비트 사용의 손 실을 초래하게 되면 이는 전반 숫자 데이터 입력에 비트 사용의 이득이 존재하지 않음을 의미하는 것이 아니다. 따라서 규칙과 AAB코드표를 보충하는 기회가 생겨 진일보로 최적화하는 점을 고려하여 방금 설명한 방법은 응당 PUCV가 결여하지 않는 비무작위 데이터를 압축하기에 충분행 한다. (2c)PUCV가 결여한 비무작위 데이터 집합: PUCV가 결여한 비무작위 데이터 집합을 압축하는 것은 상대적으로 용이한 바, 아래의 기술을 사용하면 항상 실 현할 수 있다. (i)처리 중인 비무작위 데이터 집합에서의 결여한 코드값을 블랙홀1로 사용하되, 상기 블랙홀1은 동일한 비트 클라스에서 또는 심지어 1비트를 감소한 비트 클라스에서 블랙홀0의 매칭 파트너로 사용되고 상기 블랙홀0은 관 련 클라스에서 제일 빈번한 코드값을 가지며 이러한 결여 코드값의 출현 빈도는 0이므로 그 어떤 대체 코드를 사용하여 이를 대체할 필요가 없다. (ii)처리 중인 비무작위 데이터 집합에서 결여한 PUCV를 비교적 긴 비트 길이의 다른 한 코드값으로 대체하는데 이 다른 한 코드값은 처리 중인 데이터 집합에 존재한다. 이 외에 적합한 상황에서 한쌍보다 많은 DDB를 사용하여 무작위 데이터 및 비무작위 데이터를 압축하는 것을 고 려해야 한다. 상기 방법과 기술을 사용함으로써 반드시 관련 지정자를 추가하여 관련 마스터헤드에서 사용하는 특수 코드에 사용하거나 또는 적합한 상황에서 이들을 이미 토론한 사용된 인코더와 디코더에 임베디드한다. 예 하면 시나리오 지정자 등 기타 지정자도 동일한 방식으로 사용하여 암호화 또는 복호화된 데이터 집합이 무작위 데이터 집합인지 아니면 비무작위 데이터 집합인지를 지시하고 또 이미 어느 한 쌍의 DDB 또는 어느 AAB코드표 를 사용하였는지를 지시할 수 있다. 이상의 구현예는 첸 프레임워크 가 디자인한 Max3인코더를 사용하였고 기타 Max수의 인코더 디자인을 사용할 수 도 있다. 따라서 기타 특징 외에 제일 중요한 구별 특징은 첸 프레임워크 디자인의 인코더와 기타 인코더를 구 별하는 것인데 이 표준은 코드유닛, 처리유닛과 슈퍼 처리유닛의 고유 코드값이고 사용한 디자인에 근거하여 하 나의 수보다 많은 비트 크기 또는 비트 길이, 또는 상이한 비트 크기 또는 비트 길이를 가지는 것이다. 따라서 이상에서 설명한 방법과 기술은 무작위이든 비무작위이든 관계 없이 모든 유형의 숫자 데이터를 순환적 으로 압축할 수 있다(몇천개의 이진 비트의 무작위 데이터를 포함하지 않는데 여기서 정확한 한정은 중점이 아 니다). 따라서 이상의 내용과 결부하여 범용 인코더를 발명했다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 154, "content": "[135]전체적으로 말하면 결론은 또다시, 이해력이 있는 사람으로 하여금 숫자를 카운트하도록 하세요……"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "[136]입력된 숫자정보에 대한 가정이 없으므로 무작위 숫자 또는 균일하게 분포된 숫자를 포함하는 임의의 숫자 는 상기 한정한 순환주기에서 암호화 또는 압축을 진행할 수 있다. 정보가 발달한 시대인 지금 암호화와 압축을 순환할 수 있다는 것은 분포에서 무작위 여부와 관계 없는 숫자 데이터의 방법은 모든 인류에게 있어서 생활의 곳곳에서 숫자 데이터의 교환과 저장의 이용에 의지하도록 하는데 큰 기여를 하게 되었다. 이는 인류가 공간 탐 색 또는 재이민의 노력에도 도움이 될 것이다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "최적의 모드"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "[137]현재까지 본 발명에서 인입한 최적의 실시방안은 숫자 데이터와 코드 대체(연속 또는 연속이 아님)를 함께 적합한 상황에서 무작위 데이터와 비무작위 데이터를 압축하는데 사용하는 것이다. 또한 비무작위 데이터에 대 하여 별도의 규칙과 AAB코드표를 디자인하고 개발하여 처리 중인 숫자 데이터집합의 데이터 분포 타입에 적응할 수 있도록 한다. 이는 명확한 증거를 제공하는 바, 즉 그 어떤 숫자 데이터 집합이든 모드 주기 내에서 인코딩 과 디코딩을 진행하여 설명하는 한정에 도달할 수 있고 상기 증거는 정보이론에서의 비둘기집원리의 산화를 종 결지으며 현재 비둘기집은 블랙홀을 만났다. 이는 기타 모드에서의 기타 첸 코딩 기술이 동일한 결과 또는 동일 한 증거를 발생할 수 없음을 의미하는 것이 아니다. 예측 가능한 것은 기타 모드를 사용하여도 동일한 결과와 동일한 증거를 제공할 수 있다는 것이다. 발명의 모드"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "[138]기타 모드는 언이브너와 이브너를 교대로 사용하여 인코딩과 디코딩을 진행하는 것을 포함하는데 슈퍼 처 리유닛을 사용함으로써, 특히는 이러한 서브 섹션의 AI구분을 사용하는 표준을 위한 기술을 통하여 무작위 데이 터 집합을 압축을 쉽게 받는 불균일 데이터의 서브 섹션 또는 서브 유닛으로 분해하고 상이한 크기의 처리유닛 을 사용하여 숫자 데이터 값의 내용의 특성 또는 특징에 근거하여 종료 조건과 분류 표준을 적당히 사용하여 인 코딩과 디코딩하며 특히 암호화 모드의 간단한 디자인에 대하여 수학 공식 및 이들의 상응한 값을 사용하여 인 코딩과 디코딩을 진행한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "[139]제일 중요한 것은 이상의 토론에서 알 수 있다 시피 첸 프레임워크는 무작위 여부와 관계 없는 데이터에 사용될 수 있고 질서를 창조하는 프레임워크에 사용될 수 있어 이러한 데이터로부터 통계정보를 생성하는데 제 공되고 이러한 통계정보는 처리 중인 특정 데이터 집합을 설명하기 위한 모드[모드와 디자인은 코드유닛, 처리 유닛, 슈퍼 처리유닛의 디자인(일부는 더 큰 크기의 슈퍼 처리유닛),암호화되지 않은 코드유닛, 이러한 정보를 사용하는 기본 지정자에 사용되는 마스터헤드 및 인코더와 디코더에 내장된 프로그래밍 논리를 포함하여 첸 코 드를 발생함으로써 첸 코드파일 형식의 숫자 인진 비트로 표시]와 관련되며 이로써 첸 코딩 기술을 사용하여 적 합한 상황에서 압축과 암호화의 목적에 사용되도록 하여 인코딩과 디코딩을 진행한다. 상술한 바와 같이 상기 이러한 통계정보는 코드유닛, 처리유닛, 슈퍼 처리유닛의 크기, 이들의 빈도 분포, 데이터 코드값의 랭크와 자리 및 예하면 수학공식에 나타낸 상이한 데이터 코드값 사이의 관계의 기타 특징정보, 종료값과 종료 조건, 비 트0과 비트1 사이의 비율, 데이터 범위 등을 포함한다. 첸 프레임워크에서 데이터 집합의 이러한 특징 또는 특 성을 설명할 수 있으므로 인코딩과 디코딩의 목적으로 관계 또는 파생 특성을 창조한다. 예하면, 특별히 유용한 특성은 절대 어드레스 분기 코드인 바, 예하면 이는 코드유닛 정의 자체로 사용될 수도 있거나 또는 내용코드로 사용될 수 있거나 또는 시나리오 분류 코드로 사용되고 AI구분을 진행하는 표준의 내용코드의 트리오의 접미사 로 사용되며 특히 숫자 데이터 블랙홀과 연속되는 코드 대체를 사용하여 정확하고 손상 없이 무작위 데이터를 압축하고 압축 해제할 수 있다. 따라서, 첸 프레임워크는 풍부한 프레임워크로서 그 어떤 데이터 집합을 위해 그 어떤 데이터 분포의 데이터 집합이든 모두 질서를 창조하여 디자인 단계기간에 큰 영활성을 갖도록 하며 이 는 프레임워크에서 설명 가능하여 개발기술이 데이터 값 사이의 차이를 포획하도록 하는데 이는 잠시 뒤에 꼬꼼 하게 조작할 수 있는 바, 예하면 순확적으로 운용하여 데이터 집합의 비트0과 비트1 사이의 비율을 변화시켜 데 이터 분포의 불균일성을 증가시킴으로써 데이터 압축의 재순환을 가능하도록 하거나 또는 수학 공식을 디자인하 여 처리유닛의 상이한 컴포넌트 사이의 관계를 나타내도록 함으로써 자체 또는 이에 대해 또다시 진일보로 압축 하기 전에 대응되는 숫자 데이터 집합을 암호화하는데 사용된다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "[140]어느 모드를 사용할 것인가 하는 것은 하나의 선택 문제로서 인코딩의 주요 목적에 의해 결정되는 바, 암 호화거나 압축이거나 또는 양자에 모두 사용된다. 그러나 순환적인 재압축을 용이하게 진행할 수 있으므로 구별 을 진행하는 것은 크게 중요하지 않다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "[141]본질적으로 본 발명의 실시방안의 특징은 다음과 같다. 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합에서 데이터를 위해 질서를 창조하거나 또는 데이터 질서 거나 또는 데이터 구조 또는 데이터 조직을 창조하고 코드 유닛으로 조성되며 상기 코드유닛은 숫자 데이터 집 합은 숫자 데이터 집합의 이진 비트를 포함하는 비트용기의 기본 유닛으로 사용되고; 인코딩과 디코딩 목적에 의해 처리를 선택한 디자인과 모드에 근거하여 코드유닛은 주요하게 코드유닛이 정의되어 수용하거나 나타내는 데이터 값의 최대 가능 수량(즉 코드유닛의 값의 크기)을 통해 분류하되 여기서 코드유닛의 매 하나의 가능한 고유값은 동일한 비트 크기 또는 상이한 비트 크기를 가질 수 있으며; 코드유닛은 잠시 뒤에 코드유닛이 차지한 모든 가능한 고유 데이터 값의 비트수(즉 코드유닛이 차지한 매 하나의 가능한 고유 데이터 값의 비트 크기의 총합)에 의해 분류하고; 코드유닛은 진일바로 헤드 디자인(즉 이는 0헤드 디자인이거나 1헤드 디자인)에 의해 분류하며; 이로써 각 실시방안에 근거하여 첸 프레임워크에서의 특정된 값의 크기의 코드유닛은 상이한 정의와 버전을 가지는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조 하는 방법. 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 처리유닛으로 조성되고 상기 처리유닛은 인코딩과 디코딩을 목적으로 하여 처 리하도록 선택된 디자인과 모드에 근거하여 일정한 수량의 코드유닛을 서브 유닛으로 하여 조성되는 것을 특징 으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법. 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 슈퍼 처리유닛으로 조성되고 상기 슈퍼 처리유닛은 인코딩과 디코딩을 목적으 로 하여 처리하도록 선택된 디자인과 모드에 근거하여 일정한 수량의 코드유닛을 서브 유닛으로 하여 조성되는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법. 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 암호화되지 않은 코드유닛으로 조성되고 상기 암호화되지 않은 코드유닛은 일 정한 수량의 이진 비트로 조성되며 이러한 이진 비트는 하나의 처리유닛의 크기에 도달할 수 없으므로 인코딩과 디코딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 암호화되지 않은 코드로 유지되거나 원래 의 모습을 유지하는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법. 무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 암호화되지 않은 코드유닛으로 조성되고 상기 암호화되지 않은 코드유닛은 일 정한 수량의 이진 비트로 조성되며 이러한 이진 비트는 하나의 처리유닛의 크기에 도달할 수 없으므로 인코딩과 디코딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하여 암호화되지 않은 코드로 유지되거나 원래 의 모습을 유지하는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법.무작위 여부와 관계 없는 그 어떤 숫자 데이터 집합으로부터 창조된 데이터의 질서 또는 데이터 질서 또는 데이터 구조 또는 데이터 조직은 인코딩과 디코딩을 목적으로 하여 처리하도록 선택된 디자인과 모드에 근거하 여 코드유닛, 처리유닛, 슈퍼 처리유닛과 암호화되지 않은 코드유닛 및 이들이 사용 중에서의 조합이 파생한 특 성 또는 특징 또는 관계로 조성되는 것을 특징으로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법. 그 어떤 숫자 데이터 집합의 특성 또는 특징 또는 관계의 설명적이 언어를 설명하기 위하여 코드유닛, 처리 유닛, 슈퍼 처리유닛과 암호화되지 않은 코드유닛의 특성 또는 특징 또는 관계의 용어에 사용되는 것을 특징으 로 하는 첸 프레임워크, 무작위 여부와 관계 없는 숫자 데이터 정보에서 질서를 창조하는 방법. 첸 프레임워트에서의 인코딩과 디코딩의 목적으로 데이터를 처리하는 기술에 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 첸 코딩 기술을 사용하여 그 어떤 숫자 데이터 집합에서 획득된 첸 코드를 창조하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 범위를 가지는 절대 어드레스 분기 기술을 가지는 기술을 사용하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 수학공식을 사용하여 첸 프레임워크에서 창조한 데이터 질서를 나타내는 처리유닛의 코드유닛 사이의 관계 를 나타내는 기술에 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 배치기술, 즉 수학공식으로 나타내는 값 또는 암호화된 코드 및 코드유닛, 처리유닛, 슈퍼 처리유닛과 암호 화되지 않은 코드유닛의 그러한 값 또는 암호화된 코드를 상이한 자리순서로 배치하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 분류기술, 즉 0헤드 디자인 또는 1 헤드 디자인 또는 양자를 서로 매칭되는 비트모드를 대표로 하는 디자인 으로 처리 중인 숫자 데이터의 특성 또는 특징에 분포하되 상기 특성 또는 특징은 인코딩과 디코딩의 목적으로 데이터 값을 분류하거나 그루핑하여 처리하는데 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 분류기술, 즉 처리 중인 숫자 데이터의 데이터 값에 관한 정렬과 자리의 특성 또는 특징을 사용하여 인코딩 과 디코딩의 목적으로 데이터 값을 분류하거나 그루핑하여 처리하는데 사용되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 분류기술, 즉 코드 재분포의 운용은 아래의 기술에서의 임의의 하나를 사용하여 고유 데이터 값 및 고유 어 드레스 코드를 분류모드의 한 클래스로부터 다른 한 클라스로 재분포하는 것을 포함하고 상기 기술은 코드 교환, 코드 재분포와 코드 재기입을 포함하여 인코딩과 디코딩의 목적으로 숫자 데이터 집합을 처리하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 코드 향상, 코드 강등, 코드 생략 및 코드 복구에서의 임의의 하나를 포함하여 인코딩과 디코딩의 목적으로 처리하도록 하는 코드 조절기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 종료 조건 또는 종료값을 사용하여 처리유닛 또는 슈퍼 처리유닛의 크기를 정의하여 인코딩과 디코딩의 목 적으로 처리하는 기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 코드유닛 정의를 숫자 데이터 값 또는 암호화된 코드값으로 사용하는 판독기의 기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 코드유닛 정의를 숫자 데이터 값 또는 암호화된 코드값으로 사용하는 라이터의 기술인 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 슈퍼 처리유닛을 사용하여 숫자 데이터 집합을 데이터의 서브 섹션으로 세분화화는 기술로서, 그 중 적어도 하나의 서브 섹션은 무작위가 아니어 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코딩, 인코 딩과 디코딩의 방법. 제20항에 있어서, 분류조건을 사용, 예하면 특정된 클라스에 사용되는 슈퍼 처리유닛에 나타난 값 항목의 수량을 사용하여 진일보로 숫자 데이터 집합의 슈퍼 처리유닛을 두개 또는 더 많은 클라스로 분류하고, 이러한 클라스에 적용되는 매 하나의 데이터 분포의 매핑 테이블을 디자인하여 인코딩과 디코딩을 진행하며, 이러한 슈퍼 처리유닛의 매 하나의 데이터 값에 적용되는 데이터 분포에서의 이들 각각의 매핑 테이블을 사용하여 이러한 슈퍼 처리유닛에서의 매 하나의 데이터 값에 대해 인코딩과 디코딩을 진행하고, 지정자를 사용하여 이러한 카테 고리의 슈퍼 처리유닛 사이에서 구별하여 디코딩에 사용하며 이러한 지정자는 이러한 슈퍼 처리유닛에서의 매 하나의 마스터헤드 또는 기타 지점, 예하면 단독으로 된 첸 코드파일에 저장되는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 제20항에 있어서, 분류조건을 사용, 예하면 특정된 클라스에 사용되는 슈퍼 처리유닛에 나타난 값 항목의 수량을 사용하여 진일보로 숫자 데이터 집합의 슈퍼 처리유닛을 두개의 클라스로 분류하고, 이러한 클라스에 적 용되는 매 하나의 데이터 분포의 매핑 테이블을 디자인하여 인코딩과 디코딩을 진행하며, 이러한 슈퍼 처리유닛 에서의 매 하나의 데이터값의 데이터 분포에 적용되는 이들 각각의 매핑 테이블을 사용하여 이러한 슈퍼 처리유 닛에서의 매 하나의 데이터값을 인코딩과 디코딩하고, 슈퍼 처리유닛의 클라스의 데이터 분포에 적용되는 표준 을 설치하여 인코딩과 디코딩의 대응하는 매핑 테이블에 사용함으로써 암호화된 코드를 평가하여 슈퍼 처리유닛 의 클라스 사이의 인공지능 구별을 진행하여 지정자의 사용을 생략하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 제20항에 있어서, 분류조건을 사용, 예하면 특정된 클라스에 사용되는 슈퍼 처리유닛에 나타난 값 항목의 수량을 사용하여 진일보로 숫자 데이터 집합의 슈퍼 처리유닛을 두개의 클라스로 분류하고, 이러한 클라스에 적 용되는 매 하나의 데이터 분포의 매핑 테이블을 디자인하여 인코딩과 디코딩을 진행하며, 이로써 이러한 매핑 테이블에서의 적어도 하나가 이에 의해 선택되어 언이브너로 사용되고 이러한 언이브너는 코드 재분포를 사용하 여 조절할 수 있으며 상기 코드 재분포는 적어도 한 클라스의 슈퍼 처리유닛의 데이터 값의 데이터 분포를 이용 하여 코드 재분포를 통해 코드 조절을 진행한 후의 언이브너 매핑 테이블로 하여금 이에 의해 선택되어 적어도 한 클라스의 슈퍼 처리유닛의 압축기의 매핑 테이블로 사용되도록 하고, 첫번째 순환주기에서 언이브너를 사용 하여 모든 슈퍼 처리유닛을 인코딩하며, 그 다음 압축기를 사용하여 적어도 한 클라스의 슈퍼 처리유닛을 인코 딩하되 그 중 처리 중인 상응한 슈퍼 처리유닛의 데이터 압축은 제2 순환주기에서 가능한 것인 바, 즉 제1 순환 주기에서 언이브너를 사용하여 암호화하고 제2 순환주기에서 압축기를 사용하여 암호화함으로써 그러한 압축 불 가능한 데이터를 함유한 슈퍼 처리유닛이 언이브너만 사용하여 암호화하도록 하고, 디코딩할 경우 이러한 슈퍼 처리유닛에서의 매 하나의 데이터 값에 적용되는 데이터 분포의 상응한 매핑 테이블을 이용하여 이러한 슈퍼 처 리유닛에서의 매 하나의 데이터 값을 디코딩함으로써 제1 디코딩 순환주기에서 언이브너의 인코딩과 압축기의 인코딩으로 형성된 암호화된 코드가 디코딩되어 압축기 인코딩층의 인코딩이 디코딩되도록 하고 제2 디코딩 순 환주기에서 모든 슈퍼 처리유닛은 언이브너가 암호화한 코드로 조성된 암호화된 코드가 언이브너 디코더에 의해 디코딩되며, 슈퍼 처리유닛에서의 모든 카테고리의 데이터 분포에 사용되는 적용 규칙 및 인코딩과 디코딩에 사 용되는 상응한 매핑 테이블의 적용 규칙을 설치하여 이를 암호화된 코드를 평가하는데 사용함으로써 인공지능을 사용하여 슈퍼 처리유닛의 각 카테고리 사이의 식별작업을 진행하도록 하여 지정자의 사용을 절약할 수 있는 것 을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 매핑 테이블을 구성하고 상기 매핑 테이블의 고유 코드 어드레스를 사용하여 일대일 매핑방식으로 숫자 데 이터 입력 중에서의 고유 데이터 값을 매핑함으로써 언이브너 인코더와 언이브너 디코더의 기술을 창조하므로 고유 데이터 값이 사용한 비트수는 상응하게 매핑 매칭되어 상응하게 매핑된 고유 테이블 코드 어드레스가 사용 한 비트수와 동일하고 상기 매핑 테이블을 사용하여 인코딩과 디코딩을 진행하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 인코딩과 디코딩의 목적으로 언이브너 인코더와 언이브너 디코더를 사용하여 처리하는 기술을 특징으로 하 는 첸 코딩, 인코딩과 디코딩의 방법. 인코딩과 디코딩의 목적으로 언이브너 인코더와 언이브너 디코더를 사용하여 이브너 인코더와 디코더 또는 압축기와 디컴프레서와 함께 처리하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 데이터 분포의 상황을 변화하는 상황에서 처리 중에 사용한 종료 조건에 근거하여 처리유닛 또는 슈퍼 처리 유닛의 크기를 동적으로 조절하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 처리 중의 데이터값의 데이터 분포 모드에 근거하여 코드유닛 정의를 동적으로 조절하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 분류 코드와 내용코드, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집합에서 창조되어 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코드.분류 코드, 내용코드와 암호화되지 않은 코드유닛, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집 합에서 창조되어 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코드. 마스터헤드, 분류 코드와 내용코드, 이들은 첸 코딩기술을 사용하여 그 어떤 숫자 데이터 집합에서 창조되 어 인코딩과 디코딩의 목적으로 처리함으로써 상기 마스터헤드에 첸 코딩 기술의 사용으로부터 발생한 지정자를 포함하여 인코딩과 디코딩의 목적으로 처리하는 것을 특징으로 하는 첸 코드. 마스터헤드, 분류 코드, 내용코드와 암호화되지 않은 코드유닛, 이들은 첸 코딩기술을 사용하여 그 어떤 숫 자 데이터 집합에서 창조되어 인코딩과 디코딩의 목적으로 처리함으로써 상기 마스터헤드에 첸 코딩 기술의 사 용으로부터 발생한 지정자를 포함하여 인코딩과 디코딩의 목적으로 처리하며 이러한 지정자는 검사 합계 지정자, 첸 코드파일 싸인, 매핑 테이블 지정자, 순환 주기수량 지정자, 코드유닛 정의 지정자, 처리유닛 정의 지정자, 슈퍼 처리유닛 정의 지정자, 최후 식별코드 지정자, 시나리오 디자인 지정자, 언이브너/이브너 지정자, 재순환 지정자, 빈도 지정자, 특수 코드 지정자, 일부 크기 지정자, 숫자 데이터 블랙홀 타입 지정자 및 압축 가능/압축 불가능 데이터 지정자에서의 임의의 하나를 포함하는 것을 특징으로 하는 첸 코드. 첸 코딩 기술이 임베디드되어 처리를 진행하는 것을 특징으로 하는 첸 프레임워크로 디자인된 인코더와 디 코더, 코더. 첸 코딩과 마스터헤드 지정자기술이 임베디드되어 처리를 진행하되 이러한 지정자는 검사 합계 지정자, 첸 코드파일 싸인, 매핑 테이블 지정자, 순환 주기수량 지정자, 코드유닛 정의 지정자, 처리유닛 정의 지정자, 슈 퍼 처리유닛 정의 지정자, 최후 식별코드 지정자, 시나리오 디자인 지정자, 언이브너/이브너 지정자, 재순환 지 정자, 빈도 지정자, 특수 코드 지정자, 일부 크기 지정자, 숫자 데이터 블랙홀 타입 지정자 및 압축 가능/압축 불가능 데이터 지정자에서의 임의의 하나를 포함하는 것을 특징으로 하는 첸 프레임워크로 디자인된 인코더와 디코더, 코더. 첸 코드의 숫자정보파일을 포함하는 것을 특징으로 하는 첸 코드파일. 첸 코딩 기술이 사용한 부가적인 정보의 숫자정보파일을 포함하고 마스터헤드와 여기에 포함되는 지정자를 포함하며 이러한 지정자는 검사 합계 지정자, 첸 코드파일 싸인, 매핑 테이블 지정자, 순환 주기수량 지정자, 코드유닛 정의 지정자, 처리유닛 정의 지정자, 슈퍼 처리유닛 정의 지정자, 최후 식별코드 지정자, 시나리오 디 자인 지정자, 언이브너/이브너 지정자, 재순환 지정자, 빈도 지정자, 특수 코드 지정자, 일부 크기 지정자, 숫 자 데이터 블랙홀 타입 지정자 및 압축 가능/압축 불가능 데이터 지정자에서의 임의의 하나를 포함하는 것을 특 징으로 하는 첸 코드파일. 한가지 수학방법의 사용기술로서, 이 기술을 사용하여 데이터 값이 하나의 질서에 놓이게 되고 이 질서는 수학공식에 의해 설명될 수 있으며 이 수학공식은 상응한 첸 형상과 대응되는 수학공식으로서 숫자정보와 관련 되는 수학계산논리와 기술을 병합하고 분리하는 것을 포함하고 이러한 숫자정보는 무작위 여부와 관계 없는 숫 자정보를 처리하는 처리유닛에서의 코드유닛의 값을 포함하여 인코딩과 디코딩의 목적으로 사용하는 것을 특징 으로 하는 첸 프레임워크에서 사용하는 첸 수학. 한가지 설명방법으로서, 이 방법은 기본 컴포넌트, 코드유닛과 파생 컴포넌트(예하면 첸 코드의 RP피스와 기타 파생 컴포넌트) 사이의 특징과 관계를 설명하는 바, 예하면 무작위 여부와 관계 없는 숫자정보를 처리하는 처리유닛에서의 기본 컴포넌트 값의 조합치 또는 총합 또는 차이를 설명하여 인코딩과 디코딩의 목적으로 사용 하는 것을 특징으로 하는 첸 프레임워크에서 사용하는 공식, 즉 첸 공식. 첸 점, 첸 라인, 첸 삼각형, 첸 직사각형, 첸 제형과 첸 정방형 및 첸 바를 포함하고 첸 공식으로 설명한 처리유닛의 기본 컴포넌트의 특징과 관계를 대표하는 첸 형상. 상수값을 사용하거나 수치의 변수를 포함하여 보완 상수 또는 보완 변수로 하여 수학 처리에 사용함으로써 하나의 수치 또는 하나의 범위 내 또는 다수의 범위 내의 다수의 수치의 미러 수치를 첸 공식에 사용하는 것을 특징으로 하는 보완 수학. 보완 수학과 상규적인 수학 또는 이들 중의 임의의 하나를 첸 프레임워크에서 디자인한 디코더에 단독으로 사용하여 처리하는 첸 수학. 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 프레임워크. 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 코딩. 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 코드. 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 코드파일. 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 수학. 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 보완 수학. 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되는 첸 형상. 첸 프레임워크에서 정의한 데이터 질서의 디자인과 모드를 사용하는것을 특징으로 하는 숫자 데이터 집합에 관한 통계정보를 수집하는데 사용되어 인코딩과 디코딩의 목적으로 사용되는 무작위 여부와 관계 없는 숫자 데 이터 집합을 분석하는 방법. 첸 프레임워크 언어를 사용하는 것을 특징으로 하는 무작위 여부와 관계 없는 숫자 데이터 집합을 설명하는 방법. 사후 분류 코드 또는 내부 분류 코드 또는 수정된 내용코드를 분류 코드로 사용하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 첸 프레임워크에서 정의한 디코더의 코드값을 사용하여 절대 어드레스 분기 코딩기술을 통해 기타 코드값을 흡수하거나 표시, 즉 블랙홀 코드와 관련되는 절대 어드레스 분기 코드를 사용하여 흡수된 코드값을 대표하는 숫자 데이터 블랙홀 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 코드대체기술에 이어 첸 프레임워크에서 정의한 디코더에서의 코드값을 사용하여 이어지는 단계로 다른 한 코드값을 대표하거나 표시하는 것을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 절대 어드레스 분기코드의 반대되는 배치기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 첸 프레임워크에서 정의한 디코더가 처리하고 있는 데이터 집합에 결여한 코드값을 사용하여 블랙홀 코드를 충당하는 기술을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 첸 프레임워크에서 정의한 디코더가 처리하고 있는 데이터 집합에 결여한 코드값으로 비교적 긴 비트 길이 의 다른 한 코드값을 대체하되, 다른 한 코드값이 처리 중인 데이터 집합에 존재하는 것인 기술을 특징으로 하 는 첸 코딩, 인코딩과 디코딩의 방법. 첸 프레임워크에서 정의한 디코더를 사용하여 인코딩과 디코딩을 진행하되, 사용한 기술은 숫자 데이터 블 랙홀, 절대 어드레스 코딩, 지정자 비트 지출 축소와 잇따른 코드 대체 또는 잇따르지 않는 코드 대체 기술이고 처리 중인 데이터 집합에서 결여한 코드값을 동일한 비트 길이 도는 더 긴 비트 길이를 대체하는 다른 한 코드 값으로 교체하되, 여기서 다른 한 코드값은 적합한 상황에서 처리 중인 데이터 집합에 존재하는 것인 기술을 특 징으로 하는 결여된 고유 코드값이 있거나 없는 상황에서 무작위 데이터나 비무작위 데이터와 관계 없는 숫자 데이터를 압축하고 압축 해제하는 첸 코딩, 인코딩과 디코딩의 방법. 처리 중인 숫자 데이터 집합으로부터 생성된 빈도 분포 특징에 기반하여 지정자 비트 지출을 축소하는 기술 을 특징으로 하는 첸 코딩, 인코딩과 디코딩의 방법. 코드유닛, 처리유닛과슈퍼 처리유닛의 고유 코드값으로서 사용한 디자인에 근거하여 하나의 비트 크기 또는 비트 길이 도는 상이한 비트 크기 또는 비트 길이를 가지는 것을 특징으로 하는 첸 프레임워크를 사용하여 디자 인한 디코더. 산업상 이용가능성"}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "[142]수많은 산업이 첸 프레임워크와 첸 코딩 및 관련되는 디자인과 모드를 유리하게 사용할 수 있는데 숫자정 보를 처리하는 모든 컴퓨터 응용 프로그램을 포함하고 무작위 분포 여부와 관계 없는 모든 유형의 숫자 데이터 를 포함한다."}
{"patent_id": "10-2019-7006211", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "[143]임의의 적합하게 배치된 컴퓨터 하드웨어 및/또는 소프트웨어를 사용하여 본 명세서에서 설명한 실시방안 을 시스템에 실현할 수 있게 된다. 예하면 어떠한 실시방안은 컴퓨터 언어와 컴파일러를 사용하여 실행 코드와 운영체제 및 응용 프로그램을 형성하도록 시스템에 실현할 수 있는데 네트워킹이든 독립적인 그 어떤 기기의 하 드웨어이든 실행코드를 운행할 수 있는 컴퓨터 시스템 또는 컴퓨터가 제어하는 기기 또는 운영체제가 제어하는 기기 또는 시스템 및 본 명세서에서 설명한 방법의 단계를 수행하는데 도움이 되는 컴퓨터 실행 가능하거나 운영체제가 실행 가능한 명령 또는 프로그램을 포함한다. 상기 기술 특징의 용도와 결부하여 본 명세서에서 개시 한 실시방안은 첸 코딩을 사용하여 첸 프레임워크를 실현함으로써 손상이 없고 정확하게 숫자 데이터와 숫자 실 행코드를 포함하는 관련 숫자 데이터를 인코딩과 디코딩하여 무작위 여부와 관계 없는 숫자정보를 처리함으로써 암호화/복호화 또는 압축/압축 해제 또는 양자의 목적으로 사용되며 이러한 관계에서 이의 특징은 아래의 청구 범위에 있다. 시퀀스 리스트 텍스트 []"}
