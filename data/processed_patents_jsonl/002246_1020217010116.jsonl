{"patent_id": "10-2021-7010116", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0068034", "출원번호": "10-2021-7010116", "발명의 명칭": "메모리 기반 프로세서", "출원인": "뉴로블레이드, 리미티드.", "발명자": "시티, 엘라드"}}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "복수의 메모리 뱅크; 상기 복수의 메모리 뱅크의 하나 이상의 세그먼트에 대한 접근 동작을 나타내는 접근 정보를 저장하도록 구성된데이터 스토리지; 및 상기 저장된 접근 정보에 적어도 부분적으로 의거하여 상기 하나 이상의 세그먼트의 리프레시 동작을 수행하도록 구성된 리프레시 컨트롤러를 포함하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 데이터 스토리지는 상기 복수의 메모리 뱅크의 하나 이상의 세그먼트가 마지막으로 리프레시 되었던 시간을 나타내는 리프레시 타임 지시자를 저장하도록 구성된 타임스탬프 레지스터를 포함하는 것을 특징으로 하는,메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 리프레시 컨트롤러는 상기 리프레시 타임 지시자가 마지막 리프레시 타임이 미리 정해진 타임 임계값 이내인 것으로 나타내는 경우에 상기 복수의 메모리 뱅크의 상기 하나 이상의 세그먼트에 대한 리프레시 동작을 건너뛰도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 리프레시 컨트롤러는, 상기 하나 이상의 세그먼트에 대한 리프레시 동작을 건너뛴 이후에, 상기 하나 이상의 세그먼트와 연관된 상기 저장된 리프레시 타임 지시자를 변경하여 다음 동작 사이클 동안에 상기 하나 이상의 세그먼트가 리프레시 되게 하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서, 상기 하나 이상의 세그먼트는 상기 복수의 메모리 뱅크 내의 메모리 구조의 적어도 한 행을 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 타이머를 더 포함하고, 상기 리프레시 컨트롤러는 임계 시간 간격 이후에 상기 데이터 스토리지에 저장된 상기접근 정보를 비우는 데에 상기 타이머의 출력을 활용하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서, 상기 데이터 스토리지는 상기 하나 이상의 세그먼트와 연관된 적어도 하나의 비트 레지스터를 포함하고, 상기적어도 하나의 비트 레지스터의 상태는 접근되는 상기 적어도 하나의 세그먼트에 대응하여 변경되도록공개특허 10-2021-0068034-3-구성되고, 상기 리프레시 컨트롤러는 상기 적어도 하나의 비트 레지스터의 상기 상태에 의거하여 상기 적어도하나의 세그먼트의 리프레시를 건너뛰도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서, 상기 하나 이상의 세그먼트로의 접근은 상기 적어도 하나의 세그먼트와 연관된 쓰기 동작을 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제7항에 있어서, 타이머를 더 포함하고, 상기 리프레시 컨트롤러는 임계 시간 간격 이후에 상기 적어도 하나의 비트 레지스터를재설정하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제7항에 있어서, 상기 리프레시 컨트롤러는 적어도 부분적으로는 상기 적어도 하나의 비트 레지스터의 상기 상태에 의거하여 상기 복수의 메모리 뱅크와 연관된 비트 테이블의 업데이트를 보조하도록 구성된 로우 카운터(row counter) 및 합산기(adder)를 포함하고, 상기 리프레시 컨트롤러는 상기 하나 이상의 세그먼트로의 리프레시가 상기 비트 테이블에 저장된 해당 값에 의거하여 일어날지 여부를 제어하도록 구성된 리프레시 게이트를 더 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제7항에 있어서, 타이머를 더 포함하고, 상기 리프레시 컨트롤러는 임계 시간 간격 이후에 상기 데이터 스토리지에 저장된 상기접근 정보를 비우는 데에 상기 타이머의 출력을 활용하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1항에 있어서, 상기 복수의 메모리는 DRAM(dynamic random access memory)을 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제7항에 있어서, 상기 하나 이상의 세그먼트에 접근하도록 구성되고, 상기 적어도 하나의 비트 레지스터의 상기 상태를 업데이트하도록 구성된 상기 리프레시 컨트롤러와 통신하도록 구성된, 센스 증폭기(sense amplifier)를 더 포함하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제7항에 있어서, 상기 리프레시 컨트롤러는 상기 복수의 메모리 뱅크에 대한 메모리 컨트롤러와 통합된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제1항에 있어서, 상기 복수의 메모리 뱅크와 동일한 기판 상에 배치된 복수의 프로세싱 어레이―여기서, 상기 프로세싱 어레이는복수의 프로세서 서브유닛을 포함하고, 상기 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관됨; 공개특허 10-2021-0068034-4-제1 복수의 버스―여기서, 각 버스는 상기 복수의 프로세서 서브유닛 중의 하나의 프로세서 서브유닛을 상기 복수의 메모리 뱅크의 상응하는 전용 메모리 뱅크에 연결함; 및 제2 복수의 버스―여기서, 각 버스는 상기 복수의 프로세서 서브유닛 중의 하나의 프로세서 서브유닛 중의 하나의 프로세서 서브유닛을 상기 복수의 프로세서 서브유닛 중의 다른 프로세서 서브유닛에 연결함―을 더 포함하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제1항에 있어서, 상기 복수의 메모리 뱅크와 동일한 기판 상에 배치된 프로세싱 어레이―여기서, 상기 프로세싱 어레이는 어드레스 생성기를 각각 포함하는 복수의 논리부를 포함하고, 상기 어드레스 생성기 각각은 상기 복수의 메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관됨; 및 복수의 버스―여기서, 각 버스는 상기 복수의 어드레스 생성기 중의 하나의 어드레스 생성기를 상응하는 전용메모리 뱅크에 연결함―를 더 포함하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제1항에 있어서, 상기 복수의 메모리 뱅크와 동일한 기판 상에 배치된 프로세싱 어레이―여기서, 상기 프로세싱 어레이는 복수의프로세서 서브유닛을 포함하고, 상기 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의 메모리뱅크의 상응하는 전용 메모리 뱅크와 연관됨; 및 복수의 버스―여기서, 상기 복수의 버스의 각 버스는 상기 복수의 프로세서 서브유닛 중의 하나의 프로세서 서브유닛을 상기 복수의 프로세서 서브유닛의 적어도 하나의 다른 프로세서 서브유닛에 연결함―을 더 포함하고, 상기 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛 사이의 데이터 전송과 상기 복수의버스 중에서 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "명령을 저장하는 비일시적 컴퓨터 판독가능 매체에 있어서, 상기 명령은 적어도 하나의 프로세서에 의해 실행되는 경우에 상기 적어도 하나의 프로세서로 하여금: 고수준 컴퓨터 코드를 수신; 상기 고수준 컴퓨터 코드에 의해 접근될 메모리 칩과 연관된 복수의 메모리 뱅크에 분산된 복수의 메모리 세그먼트를 식별; 상기 고수준 컴퓨터 코드를 평가하여 복수의 메모리 접근 사이클에 걸쳐 발생할 복수의 메모리 읽기 명령을 식별; 및 상기 복수의 메모리 세그먼트 각각이 상기 복수의 메모리 접근 사이클 각각 동안에 접근되도록 상기 복수의 메모리 읽기 명령과 연관된 데이터의 분산을 상기 복수의 메모리 세그먼트 각각에 걸쳐 유발;하도록 유발하는 것을 특징으로 하는, 비일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "명령을 저장하는 비일시적 컴퓨터 판독가능 매체에 있어서, 상기 명령은 적어도 하나의 프로세서에 의해 실행되는 경우에 상기 적어도 하나의 프로세서로 하여금: 공개특허 10-2021-0068034-5-고수준 컴퓨터 코드를 수신; 상기 고수준 컴퓨터 코드에 의해 접근될 메모리 칩과 연관된 복수의 메모리 뱅크에 분산된 복수의 메모리 세그먼트를 식별; 상기 고수준 컴퓨터 코드를 평가하여 상기 복수의 메모리 세그먼트의 하나 이상을 각각 연관시키는 복수의 메모리 접근 명령을 식별; 상기 메모리 접근 명령의 분석에 의거하고 상기 복수의 메모리 세그먼트의 각 메모리 세그먼트에 대해, 상기 메모리 세그먼트로의 마지막 접근으로부터 누적될 수 있는 시간의 양을 추적; 및 특정 메모리 세그먼트에 대한 마지막 접근 이후의 시간의 양이 미리 정해진 임계값을 초과할 것이라는 판단에대응하여, 상기 특정 메모리 세그먼트로의 접근을 유발하도록 구성된 메모리 리프레시 명령 및 메모리 접근 명령의 적어도 하나를 상기 고수준 컴퓨터 코드에 도입;하도록 유발하는 것을 특징으로 하는, 비일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "소프트웨어 구성 가능 메모리 리프레시 제어가 있는 메모리 칩에 있어서, 상기 메모리 칩은: 복수의 메모리 뱅크 및 상기 복수의 메모리 뱅크 각각에 포함된 복수의 메모리 세그먼트; 및 상기 복수의 메모리 뱅크 각각에 포함된 상기 복수의 메모리 세그먼트의 리프레시에 이행될 적어도 하나의 메모리 리프레시 패턴을 저장하는 데이터 스토리지 요소를 포함하는 리프레시 컨트롤러를 포함하고, 상기 메모리 리프레시 패턴은 특정 메모리 뱅크의 상기 복수의 메모리 세그먼트 중에서 리프레시 사이클 동안에리프레시 될 메모리 세그먼트와 리프레시 되지 않을 메모리 세그먼트를 식별하도록 소프트웨어를 활용하여 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제20항에 있어서, 상기 리프레시 패턴은 복수의 메모리 세그먼트 식별자를 포함하는 테이블을 포함하고, 상기 복수의 메모리 세그먼트 식별자는 리프레시 사이클 동안에 리프레시 될 특정 메모리 뱅크 내의 상기 복수의 메모리 세그먼트의 범위 및 상기 리프레시 사이클 동안에 리프레시 되지 않을 상기 특정 메모리 뱅크의 상기 복수의 메모리 세그먼트의 범위를 식별하게 소프트웨어에 의해 배정되는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제21항에 있어서, 상기 복수의 메모리 세그먼트는 행으로 배열되고, 각 메모리 세그먼트 식별자는 메모리 리프레시가 시작 또는종료되어야 하는 메모리의 행 이내의 특정 위치를 식별하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제21항에 있어서, 상기 리프레시 컨트롤러의 상기 데이터 스토리지 요소는 복수의 메모리 리프레시 패턴을 포함하고, 각 메모리리프레시 패턴은 상기 복수의 메모리 뱅크의 각각에 포함된 상기 복수의 메모리 세그먼트의 리프레시를 위한 상이한 리프레시 패턴을 나타내고, 상기 리프레시 컨트롤러는 특정 리프레시 사이클 동안에 상기 복수의 메모리리프레시 패턴 중에서 이행할 메모리 리프레시 패턴의 선택이 가능하도록 구성된 것을 특징으로 하는, 메모리칩."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제21항에 있어서, 상기 데이터 스토리지 요소는 복수의 설정 가능 레지스터를 포함하는 것을 특징으로 하는, 메모리 칩. 공개특허 10-2021-0068034-6-청구항 25 메모리 칩 상의 메모리 뱅크를 리프레시하는 방법에 있어서, 상기 방법은: 상기 메모리 칩에 포함된 복수의 메모리 뱅크의 하나 이상의 세그먼트에 대한 접근 동작을 나타내는 정보를 포함하는 데이터 스토리지에 접근하는 단계; 및 접근 동작을 나타내는 상기 저장된 정보에 적어도 부분적으로 의거하여 상기 하나 이상의 세그먼트의 리프레시동작을 리프레시 컨트롤러로 수행하는 단계를 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "제25항에 있어서, 리프레시 타임 지시자가 마지막 리프레시 타임이 미리 정해진 타임 임계값 이내인 것으로 나타내는 경우에 상기복수의 메모리 뱅크의 하나 이상의 세그먼트에 대한 리프레시 동작을 건너뛰는 단계를 더 포함하고, 상기 리프레시 타임 지시자는 상기 복수의 메모리 뱅크의 상기 하나 이상의 세그먼트가 마지막으로 리프레시 되었던 시간을 나타내고, 상기 리프레시 타임 지시자는 상기 데이터 스토리지의 타임스탬프 레지스터에 저장된 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "제26항에 있어서, 다음 동작 사이클 동안에 상기 하나 이상의 세그먼트가 리프레시 되도록, 상기 하나 이상의 세그먼트와 연관된상기 저장된 리프레시 타임 지시자를 변경하도록 상기 하나 이상의 세그먼트에 대한 리프레시 동작을 건너뛴 이후에 상기 리프레시 컨트롤러를 유발하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "제25항에 있어서, 임계 시간 간격 이후에 상기 데이터 스토리지에 저장된 상기 접근 정보를 비우는 데에 상기 메모리 칩과 연관된타이머의 출력을 활용하도록 상기 리프레시 컨트롤러를 유발하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "제25항에 있어서, 상기 데이터 스토리지는 상기 하나 이상의 세그먼트와 연관된 적어도 하나의 비트 레지스터를 포함하고, 상기방법은 접근되는 상기 적어도 하나의 세그먼트에 대응하여 상기 적어도 하나의 비트 레지스터의 상태를 변경하는 단계, 및 상기 적어도 하나의 비트 레지스터의 상기 상태에 의거하여 상기 적어도 하나의 세그먼트의 리프레시를 건너뛰도록 상기 리프레시 컨트롤러를 유발하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "제29항에 있어서, 상기 메모리 칩과 연관된 타이머의 출력에 의거하여 임계 시간 간격 이후에 상기 적어도 하나의 비트 레지스터를 재설정하도록 상기 리프레시 컨트롤러를 유발하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "웨이퍼로부터 선택 가능 용량의 메모리 칩을 생산하는 방법에 있어서, 상기 방법은: 다이의 그룹과 결합 회로를 포함하는 웨이퍼를 형성하는 단계―여기서, 상기 그룹의 상기 다이는 메모리 유닛을포함하고, 상기 결합 회로는 상기 그룹의 상기 다이에 결합됨; 및 상기 다이의 그룹과 상기 결합 회로를 포함하는 상기 웨이퍼의 영역을 절단하여 상기 다이의 그룹을 포함하는단일 메모리 칩을 제공하고 상기 다이의 그룹과 연관된 적어도 하나의 컨트롤러를 구성하여 상기 다이의 그룹을단일 메모리 칩으로서 함께 제어하는 단계 및 각 영역이 상기 그룹의 다이를 포함하여 복수의 별개 메모리 칩을공개특허 10-2021-0068034-7-제공하는 상기 웨이퍼의 영역을 절단하는 단계 중의 적어도 하나에 의해 상기 선택 가능 용량의 메모리 칩을 형성하는 단계를 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제31항에 있어서, 상기 적어도 하나의 컨트롤러는 메모리 유닛 중의 적어도 하나의 메모리 유닛의 적어도 하나의 메모리 컨트롤러를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "제31항에 있어서, 상기 적어도 하나의 컨트롤러는 상기 메모리 유닛 중의 적어도 하나의 메모리 유닛의 적어도 하나의 메모리 컨트롤러와 상이한 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제31항에 있어서, 상기 메모리 유닛 각각은 분산 프로세시를 포함하고, 각 분산 프로세서는: 기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이; 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이; 상기 복수의 프로세서 서브유닛의 하나를 이에 상응하는 전용 메모리 뱅크에 각각 연결하는 제1 복수의 버스;및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 프로세서 서브유닛의 다른 하나에 각각 연결하는 제2 복수의 버스를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "제31항에 있어서, 상기 메모리 유닛 각각은 분산 프로세시를 포함하고, 각 분산 프로세서는: 기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이―여기서, 상기 이산 메모리 뱅크 각각의 용량은 1메가바이트 이상임; 및 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "제31항에 있어서, 상기 메모리 유닛 각각은 복수의 메모리 뱅크와 동일한 기판 상에 배치된 프로세싱 어레이―여기서, 상기 프로세싱 어레이는 어드레스 생성기를 각각 포함하는 복수의 논리부를 포함하고, 상기 어드레스 생성기 각각은 상기복수의 메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관됨; 및 복수의 버스―여기서, 각 버스는 상기 복수의어드레스 생성기 중의 하나의 어드레스 생성기를 상응하는 전용 메모리 뱅크에 연결함―를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "제31항에 있어서, 공개특허 10-2021-0068034-8-상기 메모리 유닛 각각은 복수의 메모리 뱅크와 동일한 기판 상에 배치된 프로세싱 어레이―여기서, 상기 프로세싱 어레이는 복수의 프로세서 서브유닛을 포함하고, 프로세서 서브유닛 각각은 상기 복수의 메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관됨; 및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 프로세서 서브유닛의 적어도 다른 하나에 각각 연결하는 복수의 버스를 포함하고, 상기 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛 사이의 데이터 전송과 상기 복수의버스 중에서 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "제31항에 있어서, 상기 결합 회로는 상기 그룹의 상기 메모리 유닛에 의해 공유되는 버스를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_39", "content": "제31항에 있어서, 상기 결합 회로는 하나 이상의 논리 회로를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "제31항에 있어서, 상기 결합 회로는 메모리 접근 관리 로직을 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "제31항에 있어서, 상기 결합 회로는 상기 적어도 하나의 컨트롤러를 설정하는 회로 및 상기 메모리 유닛의 적어도 하나의 메모리유닛의 적어도 하나의 메모리 컨트롤러를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "제31항에 있어서, 상기 다이의 그룹을 포함하는 상기 웨이퍼의 상기 영역을 절단하는 경우에 상기 다이의 그룹과 연관된 적어도하나의 다른 컨트롤러를 비활성화하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_43", "content": "제31항에 있어서, 상기 메모리 유닛 각각은 상기 기판에 배치된 프로세싱 어레이―여기서, 상기 프로세싱 어레이는 복수의 프로세서 서브유닛을 포함하고, 상기 프로세서 서브유닛 각각은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산메모리 뱅크와 연관됨; 및 제2 복수의 버스―여기서, 각 버스는 상기 그룹의 상기 다이 중의 어느 하나의 다이의 상기 복수의 프로세서 서브유닛의 하나를 상기 그룹의 상기 다이의 어느 하나의 다이의 상기 복수의 프로세서 서브유닛의 다른 하나에 연결함―을 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_44", "content": "웨이퍼로부터 선택 가능 용량의 메모리 칩을 생산하는 방법에 있어서, 상기 방법은: 상기 웨이퍼 상에 복수의 메모리 칩을 형성하는 단계―여기서, 상기 복수의 메모리 칩은 하나 이상의 행을 따라배열됨; 상기 하나 이상의 행에 상응하는 적어도 하나의 공유 입력-출력 버스를 형성하는 단계―여기서, 상기 적어도 하나의 공유 입력-출력 버스는 상기 복수의 메모리 칩의 적어도 두 메모리 칩을 전기적으로 연결하여 함께 단일칩으로 기능하도록 함; 적어도 하나의 메모리 컨트롤러가 상기 복수의 메모리 칩의 적어도 두 메모리 칩이 함께 단일 칩으로서 기능하공개특허 10-2021-0068034-9-게 제어하도록 구성 가능하도록 상기 웨이퍼에서 상기 복수의 메모리 칩의 적어도 두 메모리 칩을 상기 공유 입력-출력 버스의 적어도 하나의 상응하는 부분과 함께 절단하는 단계를 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_45", "content": "제44항에 있어서, 상기 적어도 하나의 공유 입력-출력 버스를 사용하여 상기 복수의 메모리 칩을 검사하는 단계를 더 포함하고,상기 절단은 상기 검사에 합격하는 메모리 칩만을 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_46", "content": "제44항에 있어서, 상기 메모리 칩에 상응하는 상기 웨이퍼 상에 입력-출력 컨트롤러를 형성하는 단계; 상기 입력-출력 컨트롤러에 상응하는 비활성화 요소를 형성하는 단계; 및 단일 칩으로 함께 기능하도록 구성된 상기 복수의 메모리 칩의 상기 적어도 두 메모리 칩이 입력-출력 컨트롤러를 공유하도록 상기 비활성화 요소의 하나 이상을 활성화하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_47", "content": "제46항에 있어서, 상기 비활성화 요소는 퓨즈를 포함하고, 상기 비활성화 요소의 하나 이상을 활성화하는 단계는 전류를 인가하여상기 퓨즈의 하나 이상을 촉발하는 단계를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_48", "content": "제44항에 있어서, 상기 웨이퍼 상에 하나 이상의 논리 회로를 형성하는 단계―여기서, 상기 하나 이상의 논리 회로는 상기 복수의메모리 칩의 그룹들을 전기적으로 연결함―를 더 포함하고, 상기 메모리 칩의 그룹들은 상기 하나 이상의 논리 회로가 존재하는 경우에 함께 기능하도록 구성되고 상기 하나 이상의 논리 회로가 제거되는 경우에 개별적으로 기능하도록 구성된 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_49", "content": "제48항에 있어서, 함께 기능하도록 설계된 상기 그룹들의 하나 이상의 그룹에 대해, 상기 웨이퍼에서 상기 하나 이상의 논리 회로의 상응하는 논리 회로와 함께 상기 하나 이상의 그룹을 절단하는 단계; 및 개별적으로 기능하도록 설계된 상기 그룹들의 다른 그룹에 대해, 상기 웨이퍼에서 상기 하나 이상의 논리 회로의 상응하는 논리 회로를 동반하지 않고 상기 다른 그룹을 절단하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_50", "content": "제48항에 있어서, 상기 복수의 메모리 칩을 포함하고 상기 하나 이상의 논리 회로를 포함하지 않는 복수의 절단 형상을 형성하는단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_51", "content": "다이의 그룹―여기서, 상기 그룹의 상기 다이는 메모리 유닛을 포함함; 및 상기 다이의 그룹에 의해 공유된 적어도 하나의 입력-출력 버스―여기서, 상기 그룹의 상기 다이는 제조될 메모리 칩에 각각 상응하고 상기 공유된 입력-출력 버스의 적어도 일부분을 각각 제외하는 복수의 절단 형상이 가능하도록 배열됨―을 포함하는, 선택 가능 용량의 메모리 칩을 제공하기 위한 웨이퍼.공개특허 10-2021-0068034-10-청구항 52 제51항에 있어서, 상기 그룹의 상기 다이는 상기 웨이퍼의 하나 이상의 행을 따라 배열된 것을 특징으로 하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_53", "content": "제51항에 있어서, 상기 다이의 그룹에서 복수의 다이를 전기적으로 연결하는 적어도 하나의 논리 회로―여기서, 상기 복수의 다이의 상기 다이들은 상기 논리 회로가 제거되는 경우에 개별적으로 기능하도록 구성됨―을 더 포함하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_54", "content": "제53항에 있어서, 상기 적어도 하나의 논리 회로와 상기 복수의 다이가 제조될 상기 메모리 칩의 일부가 되도록 상기 적어도 하나의 논리 회로가 상기 복수의 다이에 인접하여 레이아웃 되는 것을 특징으로 하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_55", "content": "제53항에 있어서, 적어도 하나의 절단 형상은 상기 적어도 하나의 논리 회로와 상기 복수의 다이를 포함하는 것을 특징으로 하는,웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_56", "content": "제53항에 있어서, 복수의 논리 회로로부터의 적어도 하나의 논리회로가 상기 복수의 논리 회로로부터의 적어도 다른 하나의 논리회로에 연결되도록 상기 복수의 논리 회로가 상기 복수의 다이에 인접하여 레이아웃 되고, 상기 복수의 논리 회로와 상기 복수의 다이는 제조될 상기 메모리 칩의 일부인 것을 특징으로 하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_57", "content": "제53항에 있어서, 상기 절단 형상의 적어도 하나는 상기 적어도 하나의 논리 회로를 제외하는 것을 특징으로 하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_58", "content": "제51항에 있어서, 상기 그룹의 상기 다이는 입력-출력 컨트롤러를 더 포함하고, 상기 그룹의 상기 다이는 상기 입력-출력 컨트롤러의 상응하는 입력-출력 컨트롤러를 전기적으로 단전하도록 구성된 비활성화 요소를 더 포함하는 것을 특징으로 하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_59", "content": "제58항에 있어서, 상기 비활성화 요소는 퓨즈를 포함하는 것을 특징으로 하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_60", "content": "제58항에 있어서, 상기 그룹으로부터의 다이는 상응하는 입력-출력 컨트롤러가 비활성화되는 경우에 독립적으로 기능하도록 구성된 것을 특징으로 하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_61", "content": "공개특허 10-2021-0068034-11-제51항에 있어서, 다이의 메모리 유닛 각각은 상기 기판에 배치된 프로세싱 어레이―여기서, 상기 프로세싱 어레이는 복수의 프로세서 서브유닛을 포함하고, 상기 프로세서 서브유닛 각각은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 연관됨; 및 제2 복수의 버스―여기서, 각 버스는 상기 그룹의 상기 다이 중의 어느 하나의 다이의 상기 복수의 프로세서 서브유닛의 하나를 상기 그룹의 상기 다이의 어느 하나의 다이의 상기 복수의 프로세서 서브유닛의 다른 하나에 연결함―을 포함하는 것을 특징으로 하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_62", "content": "다이의 그룹―여기서, 상기 그룹의 상기 다이는 메모리 유닛을 포함함; 및 결합 회로―여기서, 상기 결합 회로는 그룹의 상기 다이에 결합됨―을 포함하고, 상기 그룹의 상기 다이는 제조될 메모리 칩에 각각 상응하고 상기 결합 회로의 적어도 일부분을 각각 제외하는복수의 절단 형상이 가능하도록 배열된 것을 특징으로 하는, 선택 가능 용량의 메모리 칩을 제공하기 위한 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_63", "content": "제62항에 있어서, 상기 그룹의 상기 다이는 공간 영역에 의해 서로로부터 이격될 수 있고, 여기서 상기 공간 영역은 상기 공간 영역에서 웨이퍼 절단이 가능하도록 선택된 것을 특징으로 하는, 웨이퍼."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_64", "content": "적어도 하나의 행과 적어도 하나의 열을 따라 배열된 복수의 메모리 뱅크; 단일 클럭 사이클 동안에 읽기와 쓰기를 위한 두 개의 어드레스를 수신하도록 구성된 적어도 하나의 컬럼 멀티플렉서; 및 상기 적어도 하나의 컬럼 멀티플렉서와 협조하여, 워드라인 어드레스를 공유하는 상기 두 개의 어드레스에 의거하여 워드라인을 활성화하고, 메모리 접근 사이클 동안에 제1 어드레스에 상응하는 비트라인을 디코딩하여 상기적어도 하나의 컬럼 멀티플렉서로부터 상기 두 개의 어드레스 중의 상기 제1 어드레스를 가져오고, 상기 메모리접근 사이클 동안에 제2 어드레스에 상응하는 비트라인을 디코딩하여 상기 적어도 하나의 컬럼 멀티플렉서로부터 상기 두 개의 어드레스 중의 상기 제2 어드레스를 가져오도록 구성된, 로우 디코더를 포함하는, 듀얼 포트기능을 제공하는 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_65", "content": "제64항에 있어서, 상기 두 개의 어드레스의 적어도 상기 제1 어드레스는 쓰기를 위한 것이고, 상기 로우 디코더와 상기 적어도 하나의 컬럼 멀티플렉서는 서로 협조하여 상기 적어도 하나의 컬럼 멀티플렉서로부터 가져온 제1 데이터를 상기메모리 접근 사이클 동안에 상기 두 개의 어드레스 중의 상기 제1 어드레스에 쓰도록 더 구성된 것을 특징으로하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_66", "content": "제64항에 있어서, 스위치로 기능하도록 구성된 적어도 하나의 행 회로 및 적어도 하나의 열 회로를 더 포함하는, 메모리인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_67", "content": "제66항에 있어서, 상기 로우 디코더와 상기 적어도 하나의 컬럼 멀티플렉서는 상기 워드라인에 상응하는 상기 스위칭 요소의 가까운 요소로 하나 이상의 제어 신호를 전송함으로써 서로 협조하여 상기 워드라인에 상응하는 상기 적어도 하나의공개특허 10-2021-0068034-12-행 회로와 상기 적어도 하나의 열 회로 중의 하나를 활성화하도록 더 구성된 것을 특징으로 하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_68", "content": "적어도 하나의 행과 적어도 하나의 열을 따라 배열된 복수의 메모리 뱅크; 단일 클럭 사이클 동안에 읽기 또는 쓰기를 위한 두 개의 어드레스를 수신하도록 구성된 적어도 하나의 로우 멀티플렉서 또는 적어도 하나의 컬럼 멀티플렉서; 및 서로 협조하여, 제1 사이클 동안에 상기 적어도 하나의 로우 멀티플렉서 또는 상기 적어도 하나의 컬럼 멀티플렉서로부터 상기 두 개의 어드레스 중의 제1 어드레스를 가져오고 상기 제1 어드레스에 상응하는 워드라인과 비트라인을 디코딩하고, 상기 제1 사이클에 후속하는 제2 사이클 동안에 상기 적어도 하나의 로우 멀티플렉서 또는 상기 적어도 하나의 컬럼 멀티플렉서로부터 상기 두 개의 어드레스 중의 제2 어드레스를 가져오고 상기 제2어드레스에 상응하는 워드라인과 비트라인을 디코딩하도록 구성된 로우 디코더 및 컬럼 디코더를 포함하는, 듀얼 포트 기능을 제공하는 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_69", "content": "제68항에 있어서, 상기 로우 디코더 및 상기 컬럼 디코더는 상기 두 개의 어드레스를 생성하는 상응하는 논리 회로의 속도보다 적어도 2배 빠른 속도로 클러킹 되도록 구성된 것을 특징으로 하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_70", "content": "제68항에 있어서, 상기 두 개의 어드레스는 상기 로우 디코더가 두 읽기에 대한 동일한 워드라인을 활성화하도록 행을 공유하는것을 특징으로 하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_71", "content": "제68항에 있어서, 상기 로우 디코더와 상기 컬럼 디코더는: 상기 로우 디코더를 활용하여 상기 제1 어드레스 또는 상기 제2 어드레스에 상응하는 워드라인을 활성화; 및 상기 컬럼 디코더를 활용하여 상기 제1 어드레스 또는 상기 제2 어드레스에 상응하는 상기 활성화된 워드라인상의 비트라인을 활성화하여,협조하도록 더 구성된 것을 특징으로 하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_72", "content": "제68항에 있어서, 상기 두 개의 어드레스는 쓰기를 위한 것이고, 상기 로우 디코더와 상기 컬럼 디코더는 서로 협조하여: 상기 제1 사이클 동안에, 상기 적어도 하나의 로우 멀티플렉서 또는 상기 적어도 하나의 컬럼 멀티플렉서에서가져온 제1 데이터를 상기 두 개의 어드레스 중의 상기 제1 어드레스에 쓰고; 상기 제2 사이클 동안에, 상기 적어도 하나의 로우 멀티플렉서 또는 상기 적어도 하나의 컬럼 멀티플렉서에서가져온 제2 데이터를 상기 두 개의 어드레스 중의 상기 제2 어드레스에 쓰도록 더 구성된 것을 특징으로 하는,메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_73", "content": "제68항에 있어서, 상기 제1 어드레스와 상기 제2 어드레스는, 상기 로우 디코더가 상기 제1 사이클 동안에 상기 제1 어드레스에공개특허 10-2021-0068034-13-대해 활성화된 워드라인과 같은 동일한 워드라인을 상기 제2 어드레스에 대해 활용하게 구성되도록, 행을 공유하는 것을 특징으로 하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_74", "content": "제68항에 있어서, 스위치로 기능하도록 구성된 적어도 하나의 행 회로 및 적어도 하나의 열 회로를 더 포함하는, 메모리인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_75", "content": "제74항에 있어서, 상기 로우 디코더와 상기 컬럼 디코더는 서로 협조하여, 상기 스위칭 요소의 가까운 상응하는 요소로 하나 이상의 제어 신호를 전송함으로써 상기 적어도 하나의 행 회로 및 상기 적어도 하나의 열 회로의 상응하는 회로를활성화하도록, 더 구성된 것을 특징으로 하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_76", "content": "적어도 하나의 행과 적어도 하나의 열을 따라 배열된 복수의 메모리 뱅크; 스위치 기능을 하도록 구성된 적어도 하나의 행 회로 및 적어도 하나의 열 회로; 및 서로 협조하여, 제1 어드레스에 상응하는 스위칭 요소의 가까운 요소로 하나 이상의 제어 신호를 전송하여 상기제1 어드레스에 상응하는 상기 적어도 하나의 행 회로 및 상기 적어도 하나의 열 회로의 하나를 활성화하고 메모리 칩의 적어도 하나의 로우 멀티플렉서 및 적어도 하나의 컬럼 멀티플렉서를 활용하여 상기 제1 어드레스에상응하는 워드라인 및 비트라인을 디코딩하여 메모리 클럭 사이클 동안에 두 개의 어드레스 중의 상기 제1 어드레스를 가져오고, 제2 어드레스에 상응하는 스위칭 요소의 가까운 요소로 하나 이상의 제어 신호를 전송하여 상기 제2 어드레스에 상응하는 상기 적어도 하나의 행 회로 및 상기 적어도 하나의 열 회로의 하나를 활성화하고상기 적어도 하나의 로우 멀티플렉서 및 상기 적어도 하나의 컬럼 멀티플렉서를 활용하여 상기 제2 어드레스에상응하는 워드라인 및 비트라인을 디코딩하여 상기 메모리 클럭 사이클 동안에 상기 두 개의 어드레스 중의 상기 제2 어드레스를 가져오도록 구성된 로우 디코더 및 컬럼 디코더를 포함하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_77", "content": "제76항에 있어서, 상기 제1 어드레스와 상기 제2 어드레스는 행을 공유하고, 상기 로우 디코더는 상기 제1 어드레스에 대해 상기로우 디코더에 의해 활성화된 워드라인과 동일한 워드라인을 상기 제2 어드레스에 대해 사용하도록 구성된 것을특징으로 하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_78", "content": "제76항에 있어서, 상기 적어도 하나의 행 회로와 상기 적어도 하나의 열 회로는 스위칭 요소를 포함하는 것을 특징으로 하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_79", "content": "제76항에 있어서, 상기 적어도 하나의 행 회로와 상기 적어도 하나의 열 회로는 스위치 기능을 하도록 구성된 트랜지스터를 포함하는 것을 특징으로 하는, 메모리 인스턴스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_80", "content": "제78항에 있어서, 상기 적어도 하나의 행 회로와 상기 적어도 하나의 열 회로의 상응하는 회로의 활성화는 상기 스위칭 요소의 가까운 상응하는 스위칭 요소로의 하나 이상의 제어 신호의 전송을 포함하는 것을 특징으로 하는, 메모리 인스턴공개특허 10-2021-0068034-14-스."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_81", "content": "적어도 하나의 행과 적어도 하나의 열을 따라 배열되고 복수의 정전용량 요소를 포함하는 복수의 메모리 셀; 상기 적어도 하나의 행을 활성화하기 위한 적어도 두 개의 로우 디코더; 상기 적어도 하나의 열을 활성화하기 위한 적어도 두 개의 컬럼 멀티플렉서; 상기 메모리 셀을 상기 적어도 두 개의 로우 디코더의 제1 디코더 및 상기 적어도 두 개의 컬럼 멀티플렉서의제1 멀티플렉서로 연결하는 제1 복수의 전도성 라인; 및 상기 메모리 셀을 상기 적어도 두 개의 로우 디코더의 제2 디코더 및 상기 적어도 두 개의 컬럼 멀티플렉서의제2 멀티플렉서로 연결하는 제2 복수의 전도성 라인을 포함하는, 듀얼 포트 접근을 위한 메모리 매트."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_82", "content": "제81항에 있어서, 상기 메모리 셀은 커패시터를 포함하는 것을 특징으로 하는, 메모리 매트."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_83", "content": "메모리 셀, 출력 포트, 및 읽기 회로를 포함하는 메모리 유닛; 및 처리부를 포함하고, 상기 읽기 회로는 리덕션 유닛(reduction unit) 및 상기 출력 포트를 통해 제1 수의 비트까지 출력하기 위한 제1 그룹의 인메모리(in-memory) 읽기 경로를 포함하고, 상기 처리부는 상기 메모리 유닛으로부터 제2 수의 비트를 읽기 위한 읽기 요청을 상기 메모리 유닛으로 전송하도록 구성되고, 상기 리덕션 유닛은 상기 제1 수의 비트와 상기 제2 수의 비트에 의거하여 상기 읽기 요청에 의해 촉발된 읽기동작 동안에 상기 인메모리 읽기 경로를 제어하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_84", "content": "제83항에 있어서, 상기 리덕션 유닛은 상기 제2 수가 상기 제1 수보다 작은 경우에 무관한 인메모리 읽기 경로를 제어하도록 구성되고, 상기 무관한 인메모리 읽기 경로는 상기 제1 수의 비트의 무관한 비트와 연관되고, 상기 무관한 비트는상기 제2 수의 비트에 포함되지 않는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_85", "content": "제84항에 있어서, 상기 읽기 동작 동안에, 상기 리덕션 유닛은 관련 있는 인메모리 읽기 경로를 활성화하도록 구성되고, 상기 관련 있는 인메모리 읽기 경로는 상기 제2 수의 비트를 전달하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_86", "content": "제84항에 있어서, 상기 읽기 동작 동안에, 상기 리덕션 유닛은 상기 무관한 인메모리 읽기 경로 각각의 적어도 일부분을 폐쇄하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_87", "content": "제84항에 있어서, 상기 읽기 동작 동안에, 상기 리덕션 유닛은 상기 무관한 인메모리 읽기 경로를 저전력 모드로 유지하도록 구성공개특허 10-2021-0068034-15-된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_88", "content": "제84항에 있어서, 상기 리덕션 유닛은 상기 무관한 인메모리 읽기 경로의 비트라인을 제어하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_89", "content": "제84항에 있어서, 상기 리덕션 유닛은 관련 있는 인메모리 읽기 경로의 비트라인을 로드하고 무관한 인메모리 읽기 경로의 비트라인을 저전력 모드로 유지하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_90", "content": "제84항에 있어서, 상기 리덕션 유닛은 무관한 인메모리 읽기 경로의 비트라인을 비활성화 상태로 유지하는 반면에 관련 있는 인메모리 읽기 경로의 비트라인을 로드하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_91", "content": "제83항에 있어서, 상기 리덕션 유닛은 상기 읽기 동작 동안에 관련 있는 인메모리 읽기 경로의 부분들을 활용하고 무관한 인메모리 읽기 경로 각각의 일부분을 저전력 모드로 유지하도록 구성되고, 상기 일부분은 비트라인과 상이한 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_92", "content": "제83항에 있어서, 상기 리덕션 유닛은 상기 읽기 동작 동안에 관련 있는 인메모리 읽기 경로의 부분들을 활용하고 상기 무관한 인메모리 읽기 경로(irrelevant in-memory read paths)의 적어도 일부의 센스 증폭기(sense amplifier)를 저전력모드로 유지하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_93", "content": "제83항에 있어서, 상기 리덕션 유닛은 상기 읽기 동작 동안에 관련 있는 인메모리 읽기 경로의 부분들을 활용하고 상기 무관한 인메모리 읽기 경로(irrelevant in-memory read path)의 적어도 일부의 센스 증폭기를 저전력 모드로 유지하도록구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_94", "content": "제83항에 있어서, 상기 리덕션 유닛은 읽기 동작 동안에 관련 있는 인메모리 읽기 경로의 부분들을 활용하고 상기 무관한 인메모리 읽기 경로의 센스 증폭기 이후의 무관한 인메모리 읽기 경로의 부분들을 저전력 모드로 유지하도록 구성된것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_95", "content": "제83항에 있어서, 상기 메모리 유닛은 컬럼 멀티플렉서를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_96", "content": "공개특허 10-2021-0068034-16-제95항에 있어서, 상기 리덕션 유닛은 상기 컬럼 멀티플렉서와 상기 출력 포트 사이에 결합되는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_97", "content": "제95항에 있어서, 상기 리덕션 유닛은 상기 컬럼 멀티플렉서에 내장된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_98", "content": "제95항에 있어서, 상기 리덕션 유닛은 상기 메모리 셀과 상기 컬럼 멀티플렉서 사이에 결합된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_99", "content": "제83항에 있어서, 상기 리덕션 유닛은 독립적으로 제어 가능한 리덕선 서브유닛을 포함하고, 상이한 리덕션 서브유닛은 상이한 메모리 유닛 행과 연관된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_100", "content": "제83항에 있어서, 상기 리덕션 유닛은 상기 처리부와 상이한 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_101", "content": "제83항에 있어서, 상기 리덕션 유닛은 상기 처리부인 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_102", "content": "집적회로의 처리부에 의해 상기 집적회로의 메모리 유닛으로 상기 메모리 유닛으로부터 제2 수의 비트를 읽기위한 읽기 요청을 전송하는 단계―여기서, 상기 메모리 유닛은 메모리 셀, 출력 포트, 및 리덕션 유닛 및 상기출력 포트를 통해 제1 수의 비트까지 출력하기 위한 제1 그룹의 인메모리 읽기 경로를 포함하는 읽기 회로를 포함함; 및 상기 리덕션 유닛이 상기 제1 수의 비트와 상기 제2 수의 비트에 의거하여 상기 읽기 요청에 의해 촉발된 읽기동작 동안에 상기 인메모리 읽기 경로를 제어하는 단계를 포함하는, 집적회로의 에너지 감소를 위한 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_103", "content": "제102항에 있어서, 상기 제어하는 단계는 상기 제2 수가 상기 제1 수보다 작은 경우에 무관한 인메모리 읽기 경로를 제어하는 단계를 포함하고, 상기 무관한 인메모리 읽기 경로는 상기 제1 수의 비트의 무관한 비트와 연관되고, 상기 무관한비트는 상기 제2 수의 비트에 포함되지 않는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_104", "content": "제103항에 있어서, 상기 제어하는 단계는 관련 있는 인메모리 읽기 경로를 읽기 동작 동안에 활성화하는 단계를 포함하고, 상기 관련 있는 인메모리 읽기 경로는 상기 제2 수의 비트를 전달하도록 구성된 것을 특징으로 하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_105", "content": "공개특허 10-2021-0068034-17-제103항에 있어서, 상기 제어하는 단계는 상기 무관한 인메모리 읽기 경로 각각의 적어도 일부분을 상기 읽기 동작 동안에 폐쇄하는 단계를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_106", "content": "제103항에 있어서, 상기 제어하는 단계는 상기 무관한 인메모리 읽기 경로를 상기 읽기 동작 동안에 저전력 모드로 유지하는 단계를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_107", "content": "제103항에 있어서, 상기 제어하는 단계는 상기 무관한 인메모리 읽기 경로의 비트라인을 제어하는 단계를 포함하는 것을 특징으로하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_108", "content": "제103항에 있어서, 상기 제어하는 단계는 관련 있는 인메모리 읽기 경로의 비트라인을 로드하고 무관한 인메모리 읽기 경로의 비트라인을 저전력 모드로 유지하는 단계를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_109", "content": "제103항에 있어서, 상기 제어하는 단계는 무관한 인메모리 읽기 경로의 비트라인을 비활성화 상태로 유지하는 반면에 관련 있는 인메모리 읽기 경로의 비트라인을 로드하는 단계를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_110", "content": "제102항에 있어서, 상기 제어하는 단계는 상기 읽기 동작 동안에 관련 있는 인메모리 읽기 경로의 부분들을 활용하고 무관한 인메모리 읽기 경로 각각의 일부분을 저전력 모드로 유지하는 단계를 포함하고, 상기 일부분은 비트라인과 상이한것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_111", "content": "제102항에 있어서, 상기 제어하는 단계는 상기 읽기 동작 동안에 관련 있는 인메모리 읽기 경로의 부분들을 활용하고 상기 무관한인메모리 읽기 경로(irrelevant in-memory read paths)의 적어도 일부의 센스 증폭기(sense amplifier)를 저전력 모드로 유지하는 단계를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_112", "content": "제102항에 있어서, 상기 제어하는 단계는 상기 읽기 동작 동안에 관련 있는 인메모리 읽기 경로의 부분들을 활용하고 상기 무관한인메모리 읽기 경로(irrelevant in-memory read path)의 적어도 일부의 센스 증폭기를 저전력 모드로 유지하는단계를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_113", "content": "제102항에 있어서, 상기 제어하는 단계는 읽기 동작 동안에 관련 있는 인메모리 읽기 경로의 부분들을 활용하고 상기 무관한 인메모리 읽기 경로의 센스 증폭기 이후의 무관한 인메모리 읽기 경로의 부분들을 저전력 모드로 유지하는 단계를공개특허 10-2021-0068034-18-포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_114", "content": "제102항에 있어서, 상기 메모리 유닛은 컬럼 멀티플렉서를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_115", "content": "제114항에 있어서, 상기 리덕션 유닛은 상기 컬럼 멀티플렉서와 상기 출력 포트 사이에 결합되는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_116", "content": "제114항에 있어서, 상기 리덕션 유닛은 상기 컬럼 멀티플렉서에 내장된 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_117", "content": "제114항에 있어서, 상기 리덕션 유닛은 상기 메모리 셀과 상기 컬럼 멀티플렉서 사이에 결합된 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_118", "content": "제102항에 있어서, 상기 리덕션 유닛은 독립적으로 제어 가능한 리덕선 서브유닛을 포함하고, 상이한 리덕션 서브유닛은 상이한 메모리 유닛 행과 연관된 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_119", "content": "제102항에 있어서, 상기 리덕션 유닛은 상기 처리부와 상이한 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_120", "content": "제102항에 있어서, 상기 리덕션 유닛은 상기 처리부인 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_121", "content": "메모리 셀, 출력 포트, 및 쓰기 회로를 포함하는 메모리 셀; 및 처리부를 포함하고,상기 쓰기 회로는 리덕션 유닛 및 상기 출력 포트를 통해 제1 수의 비트까지 출력하기 위한 제1 그룹의 인메모리 쓰기 경로를 포함하고, 상기 처리부는 상기 메모리 유닛으로부터 제2 수의 비트를 쓰기 위한 쓰기 요청을 상기 메모리 유닛으로 전송하도록 구성되고, 상기 리덕션 유닛은 상기 제1 수의 비트와 상기 제2 수의 비트에 의거하여 상기 쓰기 요청에 의해 촉발된 쓰기동작 동안에 상기 인메모리 쓰기 경로를 제어하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_122", "content": "제1 메모리 매트; 제2 메모리 매트; 및 공개특허 10-2021-0068034-19-상기 제2 메모리 매트에 포함된 제2 그룹의 메모리 셀을 활성화하지 않고 상기 제1 메모리 매트에 포함된 제1그룹의 메모리 셀을 활성화하도록 구성된 활성화부를 포함하고, 상기 제1 그룹의 메모리 셀과 상기 제2 그룹의메모리 셀은 모두 메모리 유닛의 단일 행에 속하는 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_123", "content": "제122항에 있어서, 상기 활성화부는 상기 제1 그룹의 메모리 셀을 활성화하지 않고 상기 제2 메모리 매트에 포함된 상기 제2 그룹의 메모리 셀을 활성화하도록 구성된 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_124", "content": "제122항에 있어서, 상기 활성화부는 상기 제1 그룹의 메모리 셀의 완전한 활성화 이후에 상기 제2 그룹의 메모리 셀을 활성화하도록 구성된 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_125", "content": "제123항에 있어서, 상기 활성화부는 상기 제1 그룹의 메모리 셀의 활성화가 완료된 이후에 개시된 지연 기간의 만료에 후속하여 상기 제2 그룹의 메모리 셀을 활성화하도록 구성된 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_126", "content": "제122항에 있어서, 상기 활성화부는 상기 제1 그룹의 메모리 셀에 결합된 제1 워드라인에 생성된 신호의 값에 의거하여 상기 제2그룹의 메모리 셀을 활성화하도록 구성된 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_127", "content": "제122항에 있어서, 상기 활성화부는 제1 워드라인 세그먼트와 제2 워드라인 세그먼트 사이에 배치된 중간 회로를 포함하고, 상기제1 워드라인 세그먼트는 상기 제1 메모리 셀에 결합되고 상기 제2 워드라인 세그먼트는 상기 제2 메모리 셀에결합되는 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_128", "content": "제126항에 있어서, 상기 중간 회로는 플립플롭(flip-flop)을 포함하는 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_129", "content": "제126항에 있어서, 상기 중간 회로는 스위치를 포함하는 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_130", "content": "제126항에 있어서, 상기 중간 회로는 버퍼(buffer)를 포함하는 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_131", "content": "제126항에 있어서, 상기 중간 회로는 하나 이상의 인버터(inverter)를 포함하는 것을 특징으로 하는, 메모리 유닛. 공개특허 10-2021-0068034-20-청구항 132 제122항에 있어서, 상기 제2 메모리 셀은 제2 워드라인 세그먼트에 결합되고, 상기 제2 워드라인 세그먼트는 적어도 상기 제1 메모리 매트를 통과하는 바이패스(bypass) 워드라인 경로에 결합되는 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_133", "content": "제122항에 있어서, 상기 활성화부는 상기 제1 그룹의 메모리 셀과 상기 제2 그룹의 메모리 셀로의 상기 단일 행과 연관된 워드라인으로부터의 활성화 신호의 인가를 제어하도록 구성된 제어부를 포함하는 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_134", "content": "제1 메모리 매트, 제2 메모리 매트, 및 상기 제1 메모리 매트의 제1 그룹의 메모리 셀로 활성화 신호를 공급하고 상기 적어도 제1 그룹의 메모리 셀의 활성화가 완료될 때까지 상기 제2 메모리 매트의 제2 그룹의 메모리 셀로의 활성화 신호의 공급을 지연하도록 구성된 활성화부를 포함하고, 상기 제1 그룹의 메모리 셀과 상기 제2 그룹의 메모리 셀은 메모리 유닛의 단일 행에 속하는 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_135", "content": "제134항에 있어서, 상기 활성화부는 상기 활성화 신호의 상기 공급을 지연하도록 구성된 지연부를 포함하는 것을 특징으로 하는,메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_136", "content": "제135항에 있어서, 활성화부는 비교기(comparator)를 포함하고, 상기 비교기는 입력에서 상기 활성화 신호를 수신하고 상기 활성화신호의 적어도 하나의 특성에 의거하여 상기 지연부를 제어하도록 구성된 것을 특징으로 하는, 메모리 유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_137", "content": "제1 메모리 매트, 제2 메모리 매트, 및 격리부(isolation unit)를 포함하고, 상기 격리부는: 상기 제1 메모리 매트의 제1 메모리 셀을 상기 제1 메모리 셀이 활성화되는 초기 활성화 기간 동안에 상기 제2메모리 매트의 제2 메모리 셀로부터 격리; 및 상기 초기 활성화 기간 후에 상기 제1 메모리 셀을 상기 제2 메모리 셀에 결합하도록 구성되고, 상기 제1 메모리 셀과 상기 제2 메모리 셀은 상기 메모리 유닛의 단일 행에 속하는 것을 특징으로 하는, 메모리유닛."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_138", "content": "메모리 유닛을 동작하기 위한 방법에 있어서, 상기 방법은 활성화부가 상기 메모리 유닛의 제2 메모리 매트에포함된 제2 그룹의 메모리 셀을 활성화하지 않고 상기 메모리 유닛의 제1 메모리 매트에 포함된 제1 그룹의 메모리 셀을 활성화하는 단계를 포함하고, 상기 제1 그룹의 메모리 셀과 상기 제2 그룹의 메모리 셀은 모두 상기메모리 유닛의 단일 행에 속하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_139", "content": "제138항에 있어서, 상기 활성화부가 상기 제1 그룹의 메모리 셀을 활성화하지 않고 상기 제2 그룹의 메모리 셀을 활성화하는 단계를 더 포함하는, 방법. 공개특허 10-2021-0068034-21-청구항 140 제138항에 있어서, 상기 제1 그룹의 메모리 셀의 완전한 활성화 이후에 상기 제2 그룹의 메모리 셀을 활성화하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_141", "content": "제138항에 있어서, 상기 제1 그룹의 메모리 셀의 활성화가 완료된 이후에 개시된 지연 기간의 만료에 후속하여상기 제2 그룹의 메모리 셀을 활성화하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_142", "content": "제138항에 있어서, 상기 제1 그룹의 메모리 셀에 결합된 제1 워드라인에 생성된 신호의 값에 의거하여 상기 제2 그룹의 메모리 셀을 활성화하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_143", "content": "제138항에 있어서, 상기 활성화부는 제1 워드라인 세그먼트와 제2 워드라인 세그먼트 사이에 배치된 중간 회로를 포함하고, 상기제1 워드라인 세그먼트는 상기 제1 메모리 셀에 결합되고 상기 제2 워드라인 세그먼트는 상기 제2 메모리 셀에결합되는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_144", "content": "제143항에 있어서, 상기 중간 회로는 플립플롭(flip-flop)을 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_145", "content": "제143항에 있어서, 상기 중간 회로는 스위치를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_146", "content": "제143항에 있어서, 상기 중간 회로는 버퍼(buffer)를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_147", "content": "제143항에 있어서, 상기 중간 회로는 하나 이상의 인버터(inverter)를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_148", "content": "제148항에 있어서, 상기 제2 메모리 셀은 제2 워드라인 세그먼트에 결합되고, 상기 제2 워드라인 세그먼트는 적어도 상기 제1 메모리 매트를 통과하는 바이패스(bypass) 워드라인 경로에 결합되는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_149", "content": "제148항에 있어서, 제어부가 상기 제1 그룹의 메모리 셀과 상기 제2 그룹의 메모리 셀로의 상기 단일 행과 연관된 워드라인으로부터의 활성화 신호의 인가를 제어하는 단계를 더 포함하는, 방법.공개특허 10-2021-0068034-22-청구항 150 기판; 상기 기판 상에 배치된 메모리 어레이; 상기 기판 상에 배치된 프로세싱 어레이; 및 상기 기판 상에 배치된 인터페이스를 포함하는 집적회로에 있어서, 상기 메모리 어레이는 다중 메모리 뱅크를 포함하고, 상기 프로세싱 어레이는 복수의 검사부를 포함하고, 상기 복수의 검사부는 상기 다중 메모리 뱅크를 검사하여 검사 결과를 제공하도록 구성되고, 상기 인터페이스는 상기 검사 결과를 나타내는 정보를 상기 집적회로의 외부로 출력하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_151", "content": "제150항에 있어서, 상기 복수의 검사부 각각은 상기 복수의 검사부의 특정 검사부에 의해 사용될 검사 패턴을 생성하여 상기 다중메모리 뱅크의 적어도 하나를 검사하도록 구성된 검사 패턴 생성기를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_152", "content": "제150항에 있어서, 상기 복수의 검사부는 상기 다중 메모리 뱅크의 하나 이상의 검사에 사용할 적어도 하나의 검사 패턴을 생성하도록 구성된 적어도 하나의 검사 패턴 생성기를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_153", "content": "제152항에 있어서, 상기 적어도 하나의 검사 패턴 생성기는 상기 적어도 하나의 검사 패턴을 생성하기 위한 명령을 상기 인터페이스로부터 수신하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_154", "content": "제153항에 있어서, 상기 인터페이스는 상기 적어도 하나의 검사 패턴을 생성하기 위한 상기 명령을 포함하는 구성 정보를 상기 집적회로 외부의 외부 장치로부터 수신하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_155", "content": "제152항에 있어서, 상기 적어도 하나의 검사 패턴 생성기는 상기 메모리 어레이로부터 상기 적어도 하나의 검사 패턴을 생성하기위한 명령을 포함하는 구성 정보를 읽어오도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_156", "content": "제154항에 있어서, 상기 구성 정보는 벡터를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_157", "content": "제153항에 있어서, 상기 인터페이스는 상기 적어도 하나의 검사 패턴인 명령을 포함하는 구성 정보를 상기 집적회로의 외부에 있는공개특허 10-2021-0068034-23-외부 장치로부터 수신하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_158", "content": "제150항에 있어서, 상기 적어도 하나의 검사 패턴은 상기 메모리 어레이의 상기 검사 동안에 접근되어야 할 메모리 어레이 엔트리를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_159", "content": "제158항에 있어서, 상기 적어도 하나의 검사 패턴은 상기 메모리 어레이의 상기 검사 동안에 접근된 상기 메모리 어레이에 기록될입력 데이터를 더 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_160", "content": "제158항에 있어서, 상기 적어도 하나의 검사 패턴은 상기 메모리 어레이의 상기 검사 동안에 접근된 상기 메모리 어레이 엔트리에기록될 입력 데이터를 더 포함하고, 상기 적어도 하나의 검사 패턴은 또한 상기 메모리 어레이의 상기 검사 동안에 접근된 상기 메모리 어레이 엔트리에서 읽어올 출력 데이터의 예상 값을 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_161", "content": "제150항에 있어서, 상기 복수의 검사부는 상기 복수의 검사부에 의해 실행되면 상기 복수의 검사부가 상기 메모리 어레이를 검사하도록 유발하는 검사 명령을 상기 메모리 어레이로부터 가져오도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_162", "content": "제161항에 있어서, 상기 검사 명령은 구성 정보에 포함된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_163", "content": "제162항에 있어서, 상기 구성 정보는 상기 메모리 어레이의 상기 검사의 예상 결과를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_164", "content": "제162항에 있어서, 상기 구성 정보는 상기 메모리 어레이의 상기 검사 동안에 접근된 메모리 어레이 엔트리로부터 읽어올 출력 데이터의 값을 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_165", "content": "제162항에 있어서, 상기 구성 정보는 벡터를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_166", "content": "제150항에 있어서, 상기 복수의 검사부는 상기 복수의 검사부에 의해 실행되면 상기 복수의 검사부가 상기 메모리 어레이를 검사하고 상기 프로세싱 어레이를 검사하도록 유발하는 검사 명령을 상기 메모리 어레이로부터 가져오도록 구성된 것을 특징으로 하는, 집적회로. 공개특허 10-2021-0068034-24-청구항 167 제166항에 있어서, 상기 검사 명령은 구성 정보에 포함된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_168", "content": "제167항에 있어서, 상기 구성 정보는 벡터를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_169", "content": "제167항에 있어서, 상기 구성 정보는 상기 메모리 어레이와 상기 프로세싱 어레이의 상기 검사의 예상 결과를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_170", "content": "제150항에 있어서, 상기 복수의 검사부는 상기 다중 메모리 뱅크의 검사 동안에 사용되는 검사 패턴의 생성을 위한 검사 패턴 생성기가 없는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_171", "content": "제150항에 있어서, 상기 복수의 검사부의 적어도 2개의 검사부는 상기 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크를 병렬로 검사하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_172", "content": "제150항에 있어서, 상기 복수의 검사부의 적어도 2개의 검사부는 상기 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크를 직렬로 검사하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_173", "content": "제150항에 있어서, 상기 검사 결과를 나타내는 상기 정보는 불량 메모리 어레이 엔트리의 식별자를 포함하는 것을 특징으로 하는,집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_174", "content": "제173항에 있어서, 상기 인터페이스는 상기 복수의 검사 회로에 의해 확보된 부분적 검사 결과를 상기 메모리 어레이의 상기 검사동안에 여러 회 가져오도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_175", "content": "제150항에 있어서, 상기 메모리 어레이의 상기 검사 동안에 검출된 적어도 하나의 오류를 수정하도록 구성된 오류 수정부를 더 포함하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_176", "content": "제150항에 있어서, 공개특허 10-2021-0068034-25-상기 집적회로는 메모리 칩인 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_177", "content": "제150항에 있어서, 상기 집적회로는 분산 프로세서를 포함하고, 상기 프로세싱 어레이는 상기 분산 프로세서의 복수의 서브유닛을 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_178", "content": "제177항에 있어서, 상기 프로세서 서브유닛의 각각은 다중 메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관되는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_179", "content": "제150항에 있어서, 상기 검사 결과를 나타내는 상기 정보는 적어도 하나의 메모리 뱅크의 상태를 나타내는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_180", "content": "기판; 상기 기판 상에 배치된 메모리 어레이; 상기 기판 상에 배치된 프로세싱 어레이; 및 상기 기판 상에 배치된 인터페이스를 포함하는, 집적회로에 있어서, 상기 메모리 어레이는 다중 메모리 뱅크를 포함하고, 상기 인터페이스는 명령을 포함하는 구성 정보를 수신하도록 구성되고, 상기 프로세싱 어레이는 상기 명령을 실행하여 상기 메모리 어레이에 접근하고 연산 동작을 수행하고 결과를 제공하도록 구성되고, 상기 인터페이스는 상기 결과를 나타내는 정보를 상기 집적회로의 외부로 출력하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_181", "content": "제180항에 있어서, 상기 구성 정보는 상기 명령, 상기 명령을 기록할 메모리 엔트리의 어드레스, 입력 데이터, 및 상기 명령의 상기 실행 동안에 계산된 출력 값을 수신할 메모리 엔트리의 어드레스를 포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_182", "content": "제180항에 있어서, 상기 프로세싱 어레이의 적어도 2개의 프로세서는 상기 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크에 접근이필요한 상이한 명령을 병렬로 실행하도록 구성된 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_183", "content": "제180항에 있어서, 상기 프로세싱 어레이의 적어도 2개의 프로세서는 상기 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크에 접근이필요한 상이한 명령을 중복되지 않는 방식으로 실행하도록 구성된 것을 특징으로 하는, 집적회로. 공개특허 10-2021-0068034-26-청구항 184 제180항에 있어서, 상기 메모리 어레이의 상기 검사 동안에 검출된 적어도 하나의 오류를 수정하도록 구성된 오류 수정부를 더 포함하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_185", "content": "제180항에 있어서, 상기 집적회로는 메모리 칩인 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_186", "content": "제180항에 있어서, 상기 집적회로는 분산 프로세서를 포함하고, 상기 프로세싱 어레이는 상기 분산 프로세서의 복수의 서브유닛을포함하는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_187", "content": "제186항에 있어서, 상기 프로세서 서브유닛의 각각은 다중 메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관되는 것을 특징으로 하는, 집적회로."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_188", "content": "기판, 상기 기판 상에 배치되고 메모리 뱅크를 포함하는 메모리 어레이, 상기 기판 상에 배치되고 복수의 검사부를 포함하는 프로세싱 어레이, 및 상기 기판 상에 배치된 인터페이스를 포함하는 집적회로의 상기 메모리 뱅크를 검사하라는 요청을 수신하는 단계; 상기 복수의 검사부가 상기 요청에 대응하여 상기 다중 메모리 뱅크를 검사하여 검사 결과를 제공하는 단계; 및 상기 인터페이스가 상기 검사 결과를 나타내는 정보를 상기 집적회로의 외부로 출력하는 단계를 포함하는, 집적회로의 메모리 뱅크를 검사하기 위한 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_189", "content": "제188항에 있어서, 상기 복수의 검사부 각각은 검사 패턴 생성기를 포함하고, 상기 방법은 상기 검사 패턴 생성기의 일부가 상기복수의 검사부의 특정 검사부에 의해 사용될 검사 패턴을 생성하여 상기 다중 메모리 뱅크의 적어도 하나를 검사하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_190", "content": "제188항에 있어서, 상기 복수의 검사부는 적어도 하나의 검사 패턴 생성기를 포함하고, 상기 방법은 상기 적어도 하나의 검사 패턴생성기가 상기 다중 메모리 뱅크의 하나 이상 메모리 뱅크의 검사에 사용할 적어도 하나의 검사 패턴을 생성하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_191", "content": "제190항에 있어서, 상기 적어도 하나의 검사 패턴을 생성하기 위한 명령을 상기 적어도 하나의 검사 패턴 생성기가 상기 인터페이스로부터 수신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_192", "content": "공개특허 10-2021-0068034-27-제191항에 있어서, 상기 적어도 하나의 검사 패턴을 생성하기 위한 상기 명령을 포함하는 구성 정보를 상기 인터페이스가 상기 집적회로 외부의 외부 장치로부터 수신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_193", "content": "제190항에 있어서, 상기 적어도 하나의 검사 패턴을 생성하기 위한 상기 명령을 포함하는 구성 정보를 상기 적어도 하나의 검사 패턴 생성기가 상기 메모리 어레이로부터 읽어오는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_194", "content": "제193항에 있어서, 상기 구성 정보는 벡터를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_195", "content": "제191항에 있어서, 상기 적어도 하나의 검사 패턴인 명령을 포함하는 구성 정보를 상기 인터페이스가 상기 집적회로 외부의 외부장치로부터 수신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_196", "content": "제188항에 있어서, 상기 적어도 하나의 검사 패턴은 상기 메모리 어레이의 상기 검사 동안에 접근되어야 할 메모리 어레이 엔트리를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_197", "content": "제196항에 있어서, 상기 적어도 하나의 검사 패턴은 상기 메모리 어레이의 상기 검사 동안에 접근된 상기 메모리 어레이에 기록될입력 데이터를 더 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_198", "content": "제196항에 있어서, 상기 적어도 하나의 검사 패턴은 상기 메모리 어레이의 상기 검사 동안에 접근된 상기 메모리 어레이 엔트리에기록될 입력 데이터를 더 포함하고, 상기 적어도 하나의 검사 패턴은 또한 상기 메모리 어레이의 상기 검사 동안에 접근된 상기 메모리 어레이 엔트리에서 읽어올 출력 데이터의 예상 값을 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_199", "content": "제188항에 있어서, 복수의 검사부에 의해 실행되면 상기 복수의 검사부가 상기 메모리 어레이를 검사하도록 유발하는 검사 명령을상기 복수의 검사부가 상기 메모리 어레이로부터 가져오는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_200", "content": "제199항에 있어서, 상기 검사 명령은 구성 정보에 포함된 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_201", "content": "공개특허 10-2021-0068034-28-제200항에 있어서, 상기 구성 정보는 상기 메모리 어레이의 상기 검사의 예상 결과를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_202", "content": "제200항에 있어서, 상기 구성 정보는 상기 메모리 어레이의 상기 검사 동안에 접근된 메모리 어레이 엔트리로부터 읽어올 출력 데이터의 값을 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_203", "content": "제200항에 있어서, 상기 구성 정보는 벡터를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_204", "content": "제188항에 있어서, 상기 복수의 검사부에 의해 실행되면 기 복수의 검사부가 상기 메모리 어레이를 검사하고 상기 프로세싱 어레이를 검사하도록 유발하는 검사 명령을 상기 복수의 검사부가 상기 메모리 어레이로부터 수신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_205", "content": "제204항에 있어서, 상기 검사 명령은 구성 정보에 포함된 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_206", "content": "제204항에 있어서, 상기 구성 정보는 벡터를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_207", "content": "제204항에 있어서, 상기 구성 정보는 상기 메모리 어레이와 상기 프로세싱 어레이의 상기 검사의 예상 결과를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_208", "content": "제188항에 있어서, 상기 복수의 검사부는 상기 다중 메모리 뱅크의 검사 동안에 사용되는 검사 패턴의 생성을 위한 검사 패턴 생성기가 없는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_209", "content": "제188항에 있어서, 상기 복수의 검사부의 적어도 2개의 검사부가 상기 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크를 병렬로 검사하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_210", "content": "제188항에 있어서, 상기 복수의 검사부의 적어도 2개의 검사부가 상기 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크를 직렬로 검사하는 단계를 더 포함하는, 방법. 공개특허 10-2021-0068034-29-청구항 211 제188항에 있어서, 상기 검사 결과를 나타내는 상기 정보는 불량 메모리 어레이 엔트리의 식별자를 포함하는 것을 특징으로 하는,방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_212", "content": "제188항에 있어서, 상기 복수의 검사 회로에 의해 확보된 부분적 검사 결과를 상기 메모리 어레이의 상기 검사 동안에 상기 인터페이스가 여러 회 수신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_213", "content": "제188항에 있어서, 상기 메모리 어레이의 상기 검사 도중에 검출된 적어도 하나의 오류를 오류 수정부가 수정하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_214", "content": "제188항에 있어서, 상기 집적회로는 메모리 칩인 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_215", "content": "제188항에 있어서, 상기 집적회로는 분산 프로세서를 포함하고, 상기 프로세싱 어레이는 상기 분산 프로세서의 복수의 서브유닛을포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_216", "content": "제215항에 있어서, 상기 프로세서 서브유닛의 각각은 다중 메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관되는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_217", "content": "제188항에 있어서, 상기 검사 결과를 나타내는 상기 정보는 적어도 하나의 메모리 뱅크의 상태를 나타내는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_218", "content": "기판, 메모리 뱅크를 포함하고 상기 기판 상에 배치되는 메모리 어레이, 상기 기판 상에 배치되는 프로세싱 어레이, 및 상기 기판 상에 배치된 인터페이스를 포함하는 집적회로의 인터페이스가 명령을 포함하는 구성 정보를수신하는 단계; 상기 프로세싱 어레이가 상기 메모리 어레이에 접근하고 연산 동작을 수행하고 결과를 제공하여 상기 명령을 실행하는 단계; 및 상기 인터페이스가 상기 결과를 나타내는 정보를 상기 집적회로의 외부로 출력하는 단계를 포함하는, 집적회로의 메모리 뱅크를 검사하기 위한 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_219", "content": "제218항에 있어서, 공개특허 10-2021-0068034-30-상기 구성 정보는 상기 명령, 상기 명령을 기록할 메모리 엔트리의 어드레스, 입력 데이터, 및 상기 명령의 상기 실행 동안에 계산된 출력 값을 수신할 메모리 엔트리의 어드레스를 포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_220", "content": "제218항에 있어서, 상기 프로세싱 어레이의 적어도 2개의 프로세서가 상기 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크에 접근이필요한 상이한 명령을 병렬로 실행하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_221", "content": "제218항에 있어서, 상기 프로세싱 어레이의 적어도 2개의 프로세서가 상기 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크에 접근이필요한 상이한 명령을 직렬로 실행하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_222", "content": "제218항에 있어서, 상기 메모리 어레이의 상기 검사 도중에 검출된 적어도 하나의 오류를 오류 수정부가 수정하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_223", "content": "제218항에 있어서, 상기 집적회로는 메모리 칩인 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_224", "content": "제218항에 있어서, 상기 집적회로는 분산 프로세서를 포함하고, 상기 프로세싱 어레이는 상기 분산 프로세서의 복수의 서브유닛을포함하는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_225", "content": "제218항에 있어서, 상기 프로세서 서브유닛의 각각은 다중 메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관되는 것을 특징으로 하는, 방법."}
{"patent_id": "10-2021-7010116", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "메모리 칩은 복수의 메모리 뱅크, 상기 복수의 메모리 뱅크의 하나 이상의 세그먼트에 대한 접근 동작을 지시하 는 접근 정보를 저장하도록 구성된 데이터 스토리지, 및 상기 저장된 접근 정보에 적어도 부분적으로 의거하여 상기 하나 이상의 세그먼트의 리프레시 동작을 수행하도록 구성된 리프레시 컨트롤러를 포함할 수 있다"}
{"patent_id": "10-2021-7010116", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 메모리 집약적 동작을 가능하게 하는 장치에 관한 것이다. 특히, 본 개시는 전용 메모리 뱅크에 연결 된 처리 소자를 포함하는 하드웨어칩에 관한 것이다. 본 개시는 또한 전력 효율과 메모리 칩의 속도를 개선하는 장치에 관한 것이다. 특히, 본 개시는 메모리 칩 상에 리프레시를 부분적으로 하거나 전혀 하지 않는 시스템 및 방법에 관한 것이다. 본 개시는 또한 선택 가능한 용량의 메모리 칩 및 메모리 칩 상의 듀얼 포트 능력에 관한 것이다."}
{"patent_id": "10-2021-7010116", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "프로세서 속도와 메모리 용량이 지속적으로 상승함에 따라, 효과적인 처리 속도에 대한 중대한 한계는 폰노이만 병목현상(von Neumann bottleneck)이다. 폰노이만 병목현상은 기존의 컴퓨터 아키텍처의 스루풋(throughput) 한 계에서 기인한다. 특히, 프로세서에 의해 수행되는 실제 계산에 비해 메모리로부터 프로세서로의 데이터 전송에 병목이 생기는 경우가 많다. 이에 따라, 메모리 집약적 처리에서는 메모리에 읽기와 쓰기를 위한 클럭 사이클의수가 상당히 증가한다. 클럭 사이클이 메모리에 읽기와 쓰기에 소비되고 데이터에 대한 연산을 수행하는데 활용 될 수 없으므로, 그 결과 효과적인 처리 속도에 손실이 발생한다. 또한, 프로세서의 계산 대역폭은 일반적으로 프로세서가 메모리에 접근하기 위해 사용하는 버스의 대역폭보다 크다. 이러한 병목현상은 신경망 및 기타 머신러닝 알고리즘, 데이터베이스 구축, 검색 인덱싱, 및 쿼리 처리와 같은 메모리 집약적 프로세스, 및 데이터 처리 동작보다 많은 읽기와 쓰기 동작을 수반하는 기타 작업에서 더욱 두드 러진다. 또한, 사용 가능한 디지털 데이터의 크기와 입도가 급성장하면서 머신러닝 알고리즘의 구성의 기회가 생겼고 새 로운 기술이 가능해졌다. 그러나 이로 인해 데이터베이스와 병렬 연산의 세계에 번거로운 문제도 생겨났다. 예 를 들어, 소셜미디어와 사물인터넷의 증가로 인해 전례 없는 속도로 디지털 데이터가 생성되고 있다. 이러한 새 로운 데이터는 새로운 광고 방식에서부터 더욱 정교한 산업 공정 제어 방법에 이르기까지 다양한 목적을 위한 알고리즘을 생성하는데 활용될 수 있다. 그러나 새로운 데이터의 저장, 처리, 분석, 및 취급이 쉽지 않았다. 새로운 데이터 소스는 페타바이트 내지 제타바이트 규모로 거대할 수 있다. 또한, 이러한 데이터 소스의 성장 속도는 데이터 처리 능력을 능가할 수 있다. 따라서, 데이터 과학자들은 이러한 문제를 해결하기 위하여 병렬 데이터 처리 방식을 채택해왔다. 계산 능력을 향상하고 거대한 양의 데이터를 취급하려는 노력의 일환으로, 과 학자들은 병렬 집약 계산이 가능한 시스템과 방법을 개발하려고 시도했다. 그러나 기존의 시스템과 방법은 그 방식이 데이터 관리, 분리된 데이터의 통합, 및 분리된 데이터의 분석을 위한 추가적인 리소스의 필요에 의해 제한을 받는 경우가 많기 때문에 데이터 처리의 요구조건을 따라가지 못했다. 대형 데이터 세트의 취급을 가능하게 하기 위하여, 엔지니어들과 과학자들은 이제 데이터 분석에 사용되는 하드 웨어를 향상하려고 노력한다. 예를 들어, 산술적 계산보다는 메모리 운용에 더 적합한 기술로 제조된 단일 기판 내에 메모리 및 처리 기능을 도입함으로써, 새로운 반도체 프로세서 또는 칩(예, 여기에 기재된 프로세서 또는 칩)이 데이터 집약적 작업에 특정하여 설계될 수 있다. 데이터 집약적 작업을 위해 특정 설계된 집적회로가 있 으면, 새로운 데이터 처리 요구조건의 충족이 가능하다. 그럼에도 불구하고, 대형 데이터 세트의 데이터 처리 문제를 해결하기 위한 이러한 접근방식에는 칩 설계와 제조에서 새로운 문제의 해결이 요구된다. 예컨대, 데이 터 집약적 작업을 위해 설계된 새로운 칩이 일반적인 칩에 사용되는 제조 기술과 아키텍처로 제조된다면, 새로 운 칩은 성능 저하 및/또는 수율 저조를 겪게 될 것이다. 또한, 새로운 칩이 기존의 데이터 취급 방법으로 동작 하도록 설계된다면, 새로운 칩이 병렬 연산을 처리할 능력은 기존의 방법에 의해 한계가 있으므로 새로운 칩의 성능은 저하될 것이다."}
{"patent_id": "10-2021-7010116", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시는 상기에 설명한 하나 이상의 문제 및 선행 기술의 기타 문제를 완화 또는 극복하기 위한 해결 방안을 설명한다. 본 개시는 메모리 집약적 동작을 가능하게 하는 장치에 관한 것이다. 특히, 본 개시는 전용 메모리 뱅크에 연결 된 처리 소자를 포함하는 하드웨어칩에 관한 것이다. 본 개시는 또한 전력 효율과 메모리 칩의 속도를 개선하는 장치에 관한 것이다. 특히, 본 개시는 메모리 칩 상에 리프레시를 부분적으로 하거나 전혀 하지 않는 시스템 및 방법에 관한 것이다. 본 개시는 또한 선택 가능한 용량의 메모리 칩 및 메모리 칩 상의 듀얼 포트 능력에 관한 것이다."}
{"patent_id": "10-2021-7010116", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일부 실시예에서, 메모리 칩은 복수의 메모리 뱅크, 상기 복수의 메모리 뱅크의 하나 이상의 세그먼트에 대한 접근 동작을 지시하는 접근 정보를 저장하도록 구성된 데이터 스토리지, 및 상기 저장된 접근 정보에 적어도 부 분적으로 의거하여 상기 하나 이상의 세그먼트의 리프레시 동작을 수행하도록 구성된 리프레시 컨트롤러를 포함 할 수 있다. 일부 실시예는 적어도 하나의 프로세서에 의해 실행되는 경우에 상기 적어도 하나의 프로세서로 하여금: 고수준 컴퓨터 코드를 수신; 상기 고수준 컴퓨터 코드에 의해 접근될 메모리 칩과 연관된 복수의 메모리 뱅크에 분산된 복수의 메모리 세그먼트를 식별; 상기 고수준 컴퓨터 코드를 평가하여 복수의 메모리 접근 사이클에 걸쳐 발생 할 복수의 메모리 읽기 명령을 식별; 및 상기 복수의 메모리 세그먼트 각각이 상기 복수의 메모리 접근 사이클각각 동안에 접근되도록 상기 복수의 메모리 읽기 명령과 연관된 데이터의 분산을 상기 복수의 메모리 세그먼트 각각에 걸쳐 유발하도록 유발하는 명령을 저장하는 비일시적 컴퓨터 가독 매체를 포함할 수 있다. 일부 실시예는 적어도 하나의 프로세서에 의해 실행되는 경우에 상기 적어도 하나의 프로세서로 하여금: 고수준 컴퓨터 코드를 수신; 상기 고수준 컴퓨터 코드에 의해 접근될 메모리 칩과 연관된 복수의 메모리 뱅크에 분산된 복수의 메모리 세그먼트를 식별; 상기 고수준 컴퓨터 코드를 평가하여 상기 복수의 메모리 세그먼트의 하나 이 상을 각각 연관시키는 복수의 메모리 접근 명령을 식별; 상기 메모리 접근 명령의 분석에 의거하고 상기 복수의 메모리 세그먼트의 각 메모리 세그먼트에 대해, 상기 메모리 세그먼트로의 마지막 접근으로부터 누적될 수 있는 시간의 양을 추적; 및 특정 메모리 세그먼트에 대한 마지막 접근 이후의 시간의 양이 미리 정해진 임계값을 초 과할 것이라는 판단에 대응하여, 상기 특정 메모리 세그먼트로의 접근을 유발하도록 구성된 메모리 리프레시 명 령 및 메모리 접근 명령의 적어도 하나를 상기 고수준 컴퓨터 코드에 도입하도록 유발하는 명령을 저장하는 비 일시적 컴퓨터 가독 매체를 포함할 수 있다. 일부 실시예에서, 소프트웨어 구성 가능 메모리 리프레시 제어가 있는 메모리 칩은: 복수의 메모리 뱅크 및 상 기 복수의 메모리 뱅크 각각에 포함된 복수의 메모리 세그먼트; 및 상기 복수의 메모리 뱅크 각각에 포함된 상 기 복수의 메모리 세그먼트의 리프레시에 이행될 적어도 하나의 메모리 리프레시 패턴을 저장하는 데이터 스토 리지 요소를 포함하는 리프레시 컨트롤러를 포함할 수 있고, 상기 메모리 리프레시 패턴은 특정 메모리 뱅크의 상기 복수의 메모리 세그먼트 중에서 리프레시 사이클 동안에 리프레시 될 메모리 세그먼트와 리프레시 되지 않 을 메모리 세그먼트를 식별하도록 소프트웨어를 활용하여 구성될 수 있다. 본 개시의 일 실시예에 따라, 웨이퍼로부터 선택 가능 용량의 메모리 칩을 생산하는 방법이 제공된다. 상기 방 법은 그룹의 다이와 결합 회로를 포함하는 웨이퍼를 형성하는 단계를 포함하고, 여기서 상기 그룹의 다이는 메 모리 유닛을 포함하고, 상기 결합 회로는 상기 그룹의 다이에 결합된다. 상기 방법은 상기 그룹의 다이와 상기 결합 회로를 포함하는 상기 웨이퍼의 영역을 절단하여 상기 그룹의 다이를 포함하는 단일 메모리 칩을 제공하고 상기 그룹의 다이와 연관된 적어도 하나의 컨트롤러를 구성하여 상기 그룹의 다이를 단일 메모리 칩으로서 함께 제어하는 단계 및 각 영역이 상기 그룹의 다이를 포함하는 상기 웨이퍼의 영역을 절단하여 복수의 별개 메모리 칩을 제공하는 단계 중의 적어도 하나에 의해 상기 선택 가능 용량의 메모리 칩을 형성하는 단계를 더 포함할 수 있다. 본 개시의 다른 실시예에 따라, 웨이퍼로부터 선택 가능 용량의 메모리 칩을 생산하는 방법이 제공된다. 상기 방법은 상기 웨이퍼 상에 복수의 메모리 칩을 형성하는 단계―여기서, 상기 복수의 메모리 칩은 하나 이상의 행 을 따라 배열됨; 및 상기 하나 이상의 행에 상응하는 적어도 하나의 공유 입력-출력 버스를 형성하는 단계를 포 함하고, 상기 적어도 하나의 공유 입력-출력 버스는 상기 복수의 메모리 칩의 적어도 두 메모리 칩을 전기적으 로 연결하여 함께 단일 칩으로 기능하도록 한다. 상기 방법은 적어도 하나의 메모리 컨트롤러가 상기 복수의 메 모리 칩의 적어도 두 메모리 칩이 함께 단일 칩으로서 기능하게 제어하도록 구성 가능하도록 상기 웨이퍼에서 상기 복수의 메모리 칩의 상기 적어도 두 메모리 칩을 상기 공유 입력-출력 버스의 적어도 하나의 상응하는 부 분과 함께 절단하는 단계를 더 포함할 수 있다. 본 개시의 다른 실시예에 따라, 선택 가능 용량을 가진 메모리 칩을 포함하는 웨이퍼가 제공된다. 상기 웨이퍼 는 상기 웨이퍼의 하나 이상의 행을 따라 배열된 복수의 메모리 칩 및 상기 하나 이상의 행에 상응하는 적어도 하나의 공유 입력-출력 버스를 포함할 수 있다. 상기 웨이퍼는 상기 복수의 메모리 칩을 포함하고 상기 공유 입 력-출력 버스의 적어도 일 부분을 제외하는 복수의 절단 형상을 더 포함할 수 있다. 일부 실시예는 듀얼 포트 기능을 제공하는 메모리 인스턴스를 포함할 수 있다. 상기 메모리 인스턴스는: 적어도 하나의 행과 적어도 하나의 열을 따라 배열된 복수의 메모리 뱅크; 단일 클럭 사이클 동안에 읽기와 쓰기를 위 한 두 개의 어드레스를 수신하도록 구성된 적어도 하나의 컬럼 멀티플렉서; 및 상기 적어도 하나의 컬럼 멀티플 렉서와 협조하여, 워드라인 어드레스를 공유하는 상기 두 개의 어드레스에 의거하여 워드라인을 활성화하고, 메 모리 접근 사이클 동안에 제1 어드레스에 상응하는 비트라인을 디코딩하여 상기 적어도 하나의 컬럼 멀티플렉서 로부터 상기 두 개의 어드레스 중의 상기 제1 어드레스를 가져오고, 상기 메모리 접근 사이클 동안에 제2 어드 레스에 상응하는 비트라인을 디코딩하여 상기 적어도 하나의 컬럼 멀티플렉서로부터 상기 두 개의 어드레스 중 의 상기 제2 어드레스를 가져오도록 구성된 로우 디코더를 포함할 수 있다. 다른 실시예에서, 듀얼 포트 기능을 제공하는 메모리 인스턴스는: 적어도 하나의 행과 적어도 하나의 열을 따라 배열된 복수의 메모리 뱅크; 단일 클럭 사이클 동안에 읽기와 쓰기를 위한 두 개의 어드레스를 수신하도록 구성 된 적어도 하나의 로우 멀티플렉서 또는 적어도 하나의 컬럼 멀티플렉서; 및 서로 협조하여, 제1 사이클 동안에상기 적어도 하나의 로우 멀티플렉서 또는 상기 적어도 하나의 컬럼 멀티플렉서로부터 상기 두 개의 어드레스의 제1 어드레스를 가져오고 상기 제1 어드레스에 상응하는 워드라인과 비트라인을 디코딩하고, 상기 제1 사이클에 후속하는 제2 사이클 동안에 상기 적어도 하나의 로우 멀티플렉서 또는 상기 적어도 하나의 컬럼 멀티플렉서로 부터 상기 두 개의 어드레스의 제2 어드레스를 가져오고 상기 제2 어드레스에 상응하는 워드라인과 비트라인을 디코딩하도록 구성된 로우 디코더 및 컬럼 디코더를 포함할 수 있다. 일부 실시예에서, 메모리 인스턴스는: 적어도 하나의 행과 적어도 하나의 열을 따라 배열된 복수의 메모리 뱅크; 스위치 기능을 하도록 구성된 적어도 하나의 행 회로 및 적어도 하나의 열 회로; 및 서로 협조하여, 제1 어드레스에 상응하는 스위칭 요소의 가까운 요소로 하나 이상의 제어 신호를 전송하여 상기 제1 어드레스에 상 응하는 상기 적어도 하나의 행 회로 및 상기 적어도 하나의 열 회로의 하나를 활성화하고 메모리 칩의 적어도 하나의 로우 멀티플렉서(row multiplexer) 및 적어도 하나의 컬럼 멀티플렉서(column multiplexer)를 활용하여 상기 제1 어드레스에 상응하는 워드라인 및 비트라인을 디코딩하여 메모리 클럭 사이클 동안에 두 개의 어드레 스 중의 상기 제1 어드레스를 가져오고, 제2 어드레스에 상응하는 스위칭 요소의 가까운 요소로 하나 이상의 제 어 신호를 전송하여 상기 제2 어드레스에 상응하는 상기 적어도 하나의 행 회로 및 상기 적어도 하나의 열 회로 의 하나를 활성화하고 상기 적어도 하나의 로우 멀티플렉서 및 상기 적어도 하나의 컬럼 멀티플렉서를 활용하여 상기 제2 어드레스에 상응하는 워드라인 및 비트라인을 디코딩하여 상기 메모리 클럭 사이클 동안에 상기 두 개 의 어드레스 중의 상기 제2 어드레스를 가져오도록 구성된 로우 디코더 및 컬럼 디코더를 포함할 수 있다. 다른 실시예에서, 듀얼 포트 접근을 위한 메모리 매트는: 적어도 하나의 행과 적어도 하나의 열을 따라 배열되 고 복수의 정전용량 요소를 포함하는 복수의 메모리 셀; 상기 적어도 하나의 행을 활성화하기 위한 적어도 두 개의 로우 디코더; 적어도 하나의 열을 활성화하기 위한 적어도 두 개의 컬럼 멀티플렉서; 상기 메모리 셀을 상 기 적어도 두 개의 로우 디코더의 제1 디코더 및 상기 적어도 두 개의 컬럼 멀티플렉서의 제1 멀티플렉서로 연 결하는 제1 복수의 전도성 라인; 및 상기 메모리 셀을 상기 적어도 두 개의 로우 디코더의 제2 디코더 및 상기 적어도 두 개의 컬럼 멀티플렉서의 제2 멀티플렉서로 연결하는 제2 복수의 전도성 라인을 포함할 수 있다. 일부 실시예에서, 집적회로는: 메모리 셀, 출력 포트, 및 읽기 회로를 포함하는 메모리 유닛; 및 처리부를 포함 할 수 있다. 상기 읽기 회로는 리덕션 유닛 및 상기 출력 포트를 통해 제1 수의 비트(a first number of bits) 까지 출력하기 위한 제1 그룹의 인메모리 읽기 경로를 포함할 수 있다. 상기 처리부는 상기 메모리 유닛으로부 터 제2 수의 비트를 읽기 위한 읽기 요청을 상기 메모리 유닛으로 전송하도록 구성될 수 있다. 상기 리덕션 유 닛은 상기 제1 수의 비트와 상기 제2 수의 비트에 의거하여 상기 읽기 요청에 의해 촉발된 읽기 동작 동안에 상 기 인메모리 읽기 경로를 제어하도록 구성될 수 있다. 다른 실시예는 메모리 셀, 출력 포트, 및 쓰기 회로를 포함하는 메모리 셀; 및 처리부를 포함하는 집적회로를 포함할 수 있다. 상기 쓰기 회로는 리덕션 유닛 및 상기 출력 포트를 통해 제1 수의 비트까지 출력하기 위한 제 1 그룹의 인메모리 쓰기 경로를 포함할 수 있다. 상기 처리부는 상기 메모리 유닛으로부터 제2 수의 비트를 쓰 기 위한 쓰기 요청을 상기 메모리 유닛으로 전송하도록 구성될 수 있다. 상기 리덕션 유닛은 상기 제1 수의 비 트와 상기 제2 수의 비트에 의거하여 상기 쓰기 요청에 의해 촉발된 쓰기 동작 동안에 상기 인메모리 쓰기 경로 를 제어하도록 구성될 수 있다. 일부 실시예는 집적회로의 에너지 감소를 위한 방법을 포함할 수 있다. 상기 방법은: 상기 집적회로의 처리부에 의해 상기 집적회로의 메모리 유닛으로 상기 메모리 유닛으로부터 제2 수의 비트를 읽기 위한 읽기 요청을 전송 하는 단계―여기서, 상기 메모리 유닛은 메모리 셀, 출력 포트, 및 리덕션 유닛 및 상기 출력 포트를 통해 제1 수의 비트까지 출력하기 위한 제1 그룹의 인메모리 읽기 경로를 포함하는 읽기 회로를 포함함; 및 상기 리덕션 유닛이 상기 제1 수의 비트와 상기 제2 수의 비트에 의거하여 상기 읽기 요청에 의해 촉발된 읽기 동작 동안에 상기 인메모리 읽기 경로를 제어하는 단계를 포함할 수 있다. 일부 실시예에서, 메모리 유닛은: 제1 메모리 매트; 제2 메모리 매트; 및 상기 제2 메모리 매트에 포함된 제2 그룹의 메모리 셀을 활성화하지 않고 상기 제1 메모리 매트에 포함된 제1 그룹의 메모리 셀을 활성화하도록 구 성된 활성화부를 포함할 수 있고, 여기서 상기 제1 그룹의 메모리 셀과 상기 제2 그룹의 메모리 셀은 모두 상기 메모리 유닛의 단일 행에 속한다. 다른 실시예는 제1 메모리 매트, 제2 메모리 매트, 및 상기 제1 메모리 매트의 제1 그룹의 메모리 셀로 활성화 신호를 공급하고 상기 제2 메모리 매트의 제2 그룹의 메모리 셀로의 상기 활성화 신호의 공급은 적어도 상기 제 1 그룹의 메모리 셀의 활성화가 완료될 때까지 지연하도록 구성된 활성화부를 포함하는 메모리 유닛을 포함할 수 있다. 상기 제1 그룹의 메모리 셀과 상기 제2 그룹의 메모리 셀은 상기 메모리 유닛의 단일 행에 속할 수 있다. 일부 실시예에서, 메모리 유닛은 제1 메모리 매트, 제2 메모리 매트, 및 격리부를 포함할 수 있다. 상기 격리부 는 상기 제1 메모리 매트의 제1 메모리 셀을 상기 제1 메모리 셀이 활성화되는 초기 활성화 기간 동안에 상기 제2 메모리 매트의 제2 메모리 셀로부터 격리하고, 상기 초기 활성화 기간 후에 상기 제1 메모리 셀을 상기 제2 메모리 셀에 결합하도록 구성될 수 있고, 상기 제1 메모리 셀과 상기 제2 메모리 셀은 상기 메모리 유닛의 단일 행에 속한다. 일부 실시예는 메모리 유닛을 동작하기 위한 방법을 포함할 수 있다. 상기 방법은 활성화부가 상기 메모리 유닛 의 제2 메모리 매트에 포함된 제2 그룹의 메모리 셀을 활성화하지 않고 상기 메모리 유닛의 제1 메모리 매트에 포함된 제1 그룹의 메모리 셀을 활성화하는 단계를 포함할 수 있다. 상기 제1 그룹의 메모리 셀과 상기 제2 그 룹의 메모리 셀은 모두 상기 메모리 유닛의 단일 행에 속할 수 있다. 일부 실시예에서, 집적회로는: 기판; 상기 기판 상에 배치된 메모리 어레이; 상기 기판 상에 배치된 프로세싱 어레이; 및 상기 기판 상에 배치된 인터페이스를 포함할 수 있다. 상기 메모리 어레이는 다중 메모리 뱅크를 포 함할 수 있고, 상기 프로세싱 어레이는 복수의 검사부를 포함할 수 있고, 상기 복수의 검사부는 상기 다중 메모 리 뱅크를 검사하여 검사 결과를 제공하도록 구성될 수 있고, 상기 인터페이스는 상기 검사 결과를 나타내는 정 보를 상기 집적회로의 외부로 출력하도록 구성될 수 있다. 다른 실시예는 기판; 상기 기판 상에 배치된 메모리 어레이; 상기 기판 상에 배치된 프로세싱 어레이; 및 상기 기판 상에 배치된 인터페이스를 포함하는, 집적회로를 포함할 수 있다. 상기 메모리 어레이는 다중 메모리 뱅크 를 포함할 수 있고, 상기 인터페이스는 명령을 포함하는 구성 정보를 수신하도록 구성될 수 있고, 상기 프로세 싱 어레이는 상기 명령을 실행하여 상기 메모리 어레이에 접근하고 연산 동작을 수행하고 결과를 제공하도록 구 성될 수 있고, 상기 인터페이스는 상기 결과를 나타내는 정보를 상기 집적회로의 외부로 출력하도록 구성될 수 있다. 일부 실시예는 집적회로의 메모리 뱅크를 검사하기 위한 방법을 포함할 수 있다. 상기 방법은 기판, 상기 기판 상에 배치되고 상기 메모리 뱅크를 포함하는 메모리 어레이, 상기 기판 상에 배치되고 복수의 검사부를 포함하 는 프로세싱 어레이, 및 상기 기판 상에 배치된 인터페이스를 포함하는 집적회로의 상기 메모리 뱅크를 검사하 라는 요청을 수신하는 단계; 상기 복수의 검사부가 상기 요청에 대응하여 상기 다중 메모리 뱅크를 검사하여 검 사 결과를 제공하는 단계; 및 상기 인터페이스가 상기 검사 결과를 나타내는 정보를 상기 집적회로의 외부로 출 력하는 단계를 포함할 수 있다. 일부 실시예에서, 집적회로의 메모리 뱅크를 검사하기 위한 방법은: 기판, 메모리 뱅크를 포함하고 상기 기판 상에 배치되는 메모리 어레이, 상기 기판 상에 배치되는 프로세싱 어레이, 및 상기 기판 상에 배치된 인터페이 스를 포함하는 집적회로의 인터페이스가 명령을 포함하는 구성 정보를 수신하는 단계; 상기 프로세싱 어레이가 상기 메모리 어레이에 접근하고 연산 동작을 수행하고 결과를 제공하여 상기 명령을 실행하는 단계; 및 상기 인 터페이스가 상기 결과를 나타내는 정보를 상기 집적회로의 외부로 출력하는 단계를 포함할 수 있다. 기타 개시된 실시예들에 따라, 비일시적 컴퓨터 가독 저장 매체는 적어도 하나의 처리 장치에 의해 실행되고 여 기에 기재된 방법 중의 하나 이상을 수행하는 프로그램 명령을 저장할 수 있다. 상기의 일반적인 설명과 하기의 상세한 설명은 예시에 불과하며 본 개시의 청구 범위에 대한 한정이 아니다."}
{"patent_id": "10-2021-7010116", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "하기의 상세한 설명은 첨부한 도면을 참조한다. 편의상, 도면과 설명에서 동일 또는 유사한 구성요소에 동일한 참조 번호를 사용한다. 여러 예시적인 실시예를 설명하지만, 다양한 변경, 개조, 구현 등이 가능하다. 예를 들 어, 도면에 예시된 구성요소를 치환, 또는 추가, 변경할 수 있고, 설명에 포함된 방법은 단계를 치환하거나 순 서를 바꾸거나 삭제하거나 추가하여 변경할 수 있다. 따라서, 하기의 상세한 설명은 개시된 실시예와 예시에 국 한되지 않고, 올바른 청구 범위는 첨부된 청구항에 의해 정의된다. 프로세서 아키텍처 본 기재의 전체를 통해, '하드웨어 칩'이라는 용어는 하나 이상의 회로 소자(예, 트랜지스터, 커패시터, 저항기 등)가 형성되는 반도체 웨이퍼(실리콘 등)을 말한다. 회로 소자는 처리 소자 또는 메모리 소자를 형성할 수 있다. '처리 소자'는 적어도 하나의 논리 함수(예, 산술 함수, 논리 게이트, 기타 불리언(Boolean) 연산 등)을 함 께 수행하는 하나 이상의 회로 소자를 말한다. 처리 소자는 범용 처리 소자(예, 설정 가능한 복수의 트랜지스터) 또는 전용 처리 소자(예, 특정 논리 함수를 수행하도록 설계된 특정 논리 게이트 또는 복수의 회로 소자)일 수 있다. '메모리 소자'는 데이터를 저장하는데 활용될 수 있는 하나 이상의 회로 소자를 말한다. '메 모리 소자'는 또한 '메모리 셀'로 불릴 수도 있다. 메모리 소자는 동적(즉, 데이터 저장을 유지하기 위해 전기 적 리프레쉬가 필요), 정적(즉, 전원이 차단된 이후의 일정 시간 동안 데이터 유지), 또는 비휘발성 메모리일 수 있다. 처리 소자는 서로 접합되어 프로세서 서브유닛(subunit)을 형성할 수 있다. 이에 따라, '프로세서 서브유닛'은 적어도 하나의 작업 또는 명령(예, 프로세서 명령 세트의 작업 또는 명령)을 실행할 수 있는 최소 묶음의 처리 소자를 포함할 수 있다. 예를 들어, 서브유닛은 명령을 함께 실행하도록 구성된 하나 이상의 범용 처리 소자, 하나 이상의 전용 처리 소자와 쌍을 이루어 서로 보완적인 방식으로 명령을 실행하도록 구성된 하나 이상의 범 용 처리 소자 등을 포함할 수 있다. 프로세서 서브유닛은 기판(예, 웨이퍼) 상에 어레이로 배치될 수 있다. '어 레이'는 직사각형상을 포함할 수 있지만, 서브유닛의 어레이 배치는 기판 상에서 기타 모든 형상으로 형성될 수 있다. 메모리 소자는 서로 접합되어 메모리 뱅크를 형성할 수 있다. 예를 들어, 메모리 뱅크는 적어도 하나의 회선(또 는 기타 전도성 연결)을 따라 연결된 하나 이상의 메모리 소자 라인을 포함할 수 있다. 또한, 메모리 소자는 다 른 방향의 적어도 하나의 추가 회선을 따라 연결될 수 있다. 예를 들어, 메모리 소자는 하기에 설명하는 바와 같이 워드라인(wordline)과 비트라인(bitline)을 따라 배치될 수 있다. 메모리 뱅크가 라인을 포함할 수 있지만, 기타 모든 배치를 활용하여 소자를 기판 내에 배치하여 기판 상에 뱅크를 형성할 수 있다. 또한, 하나 이상의 뱅크가 적어도 하나의 메모리 컨트롤러에 전기적으로 접합되어 메모리 어레이를 형성할 수 있다. 메모리 어레이는 장방형 배치의 뱅크를 포함할 수 있지만, 어레이 내의 뱅크의 배치는 기판 상에서 기타 모든 형상으로 형성될 수 있다. 본 기재의 전체를 통해, '버스'는 기판의 소자 사이의 모든 통신 연결을 말한다. 예를 들어, 회선 또는 라인(전 기적 연결 형성), 광섬유(광 연결 형성), 또는 구성 부품 사이의 통신을 하는 기타 모든 연결이 '버스'로 지칭 될 수 있다. 기존의 프로세서에서는 범용 논리 회로와 공유 메모리가 쌍을 이룬다. 공유 메모리는 논리 회로가 실행할 명령 세트뿐만 아니라 명령 세트의 실행에 활용할 데이터와 명령 세트의 실행의 결과로 획득하는 데이터를 모두 저장 할 수 있다. 하기에 설명하는 바와 같이, 일부 기존 프로세서는 캐싱(caching) 시스템을 활용하여 공유 메모리 로부터의 읽기 지연을 줄이지만, 기존의 캐싱 시스템은 공유 상태를 유지하고 있다. 기존 프로세서는 중앙처리 장치(CPU), 그래픽처리장치(GPU), 다양한 주문형반도체(ASIC) 등을 포함한다. 도 1은 CPU의 일례를 도시한 것이 고, 도 2는 GPU의 일례를 도시한 것이다. 도 1에 도시된 바와 같이, CPU는 프로세서 서브유닛(120a)과 프로세서 서브유닛(120b)과 같은 하나 이상의 프로세서 서브유닛을 포함하는 처리부를 포함할 수 있다. 도 1에는 도시되어 있지 않지만, 각 프로세서 서 브유닛은 복수의 처리 소자를 포함할 수 있다. 또한, 처리부는 하나 이상의 단계의 온칩캐시(on-chip cache)를 포함할 수 있다. 이러한 캐시 소자는 프로세서 서브유닛(120a, 120b)과 캐시 소자를 포함하는 기판 내 에 형성된 하나 이상의 버스를 통해 프로세서 서브유닛(120a, 120b)에 연결되기보다는 대부분 처리부와 동 일한 반도체 다이 상에 형성된다. 버스를 통한 연결보다는 동일 다이 상의 직접 배치는 기존 프로세서의 1단계 (L1) 캐시와 2단계(L2) 캐시에 모두 일반적이다. 또는, 구형 프로세서에서, L2 캐시는 프로세서 서브유닛과 L2 캐시 사이의 후면 버스(back-side bus)를 사용하여 프로세서 서브유닛 사이에 공유되었다. 후면 버스는, 하기에 설명하는 바와 같이, 일반적으로 전면 버스(front-side bus)보다 크다. 이에 따라, 캐시는 다이 상의 모든 프로 세서 서브유닛과 공유돼야 하므로, 캐시가 프로세서 서브유닛(120a, 120b)과 동일한 다이 상에 형성되거나 하나 이상의 후면 버스를 통하여 프로세서 서브유닛(120a, 120b)에 통신 가능하게 결합될 수 있다. 버스가 없는 실시예(예, 캐시가 다이 상에 직접 형성)와 후면 버스를 활용하는 실시예 모두에서, 캐시는 CPU의 프로세서 서 브유닛 간에 공유된다. 또한, 처리부는 공유 메모리(140a) 및 공유 메모리(140b)와 통신한다. 예를 들어, 메모리(140a, 140b)는 공유 DRAM(dynamic random access memory)의 메모리 뱅크를 나타내는 것일 수 있다. 도면에는 두 개의 뱅크가 도시 되었지만, 대부분의 기존 메모리 칩은 8개 내지 16개의 메모리 뱅크를 포함한다. 이에 따라, 프로세서 서 브유닛(120a, 120b)은 공유 메모리(140a, 140b)를 활용하여 프로세서 서브유닛(120a, 120b)에 의해 운용될 데이터를 저장할 수 있다. 그러나, 이러한 구성의 결과로, 처리부의 클럭 속도가 버스의 데이터 전송 속도를 초과하는 경우에, 메모리(140a, 140b)와 처리부 사이의 버스는 병목이 된다. 이는 기존 프로세서에서 일반 적이며, 이에 따라 클럭 속도와 트랜지스터 수에 의거한 처리 속도 사양보다 처리 속도가 떨어지는 결과를 초래 한다. 도 2에 도시된 바와 같이, 유사한 문제가 GPU에도 존재한다. GPU는 하나 이상의 프로세서 서브유닛(예, 서 브유닛(220a, 220b, 220c, 220d, 220e, 220f, 220g, 220h, 220i, 220j, 220k, 220l, 220m, 220n, 220o, 220p))을 포함하는 처리부를 포함할 수 있다. 또한, 처리부는 하나 이상의 단계의 온칩캐시 및/또는 레지스터 파일을 포함할 수 있다. 이러한 캐시 소자는 일반적으로 처리부와 동일한 반도체 다이 상에 형성 된다. 실제로, 도 2의 예에서, 캐시는 처리부와 동일한 다이 상에 형성되고 모든 프로세서 서브유닛 사이에서 공유되는 반면, 캐시(230a, 230b, 230c, 230d)는 각각 프로세서 서브세트(subset) 상에 형성되고 그 전용이 된다. 또한, 처리부는 공유 메모리(250a, 250b, 250c, 250d)와 통신한다. 예를 들어, 메모리(250a, 250b, 250c, 250d)는 공유 DRAM의 메모리 뱅크를 나타내는 것일 수 있다. 이에 따라, 처리부의 프로세서 서브유닛은 공 유 메모리(250a, 250b, 250c, 250d)를 활용하여 프로세서 서브유닛에 의해 이후에 운용되는 데이터를 저장할 수 있다. 그러나, 앞서 CPU에 대한 설명과 유사하게, 이러한 배치의 결과로 메모리(250a, 250b, 250c, 250d)와 처 리부 사이의 버스는 병목이 된다. 기재된 하드웨어 칩의 설정 도 3a는 예시적인 하드웨어 칩의 일 실시예를 개략적으로 도시한 것이다. 하드웨어 칩은 앞서 설명한 CPU, GPU, 및 기타 기존 프로세서에 대한 병목을 완화하도록 설계된 분산 프로세서를 포함할 수 있다. 분산 프 로세서는 단일 기판 상에 공간적으로 분산된 복수의 프로세서 서브유닛을 포함할 수 있다. 또한, 앞서 설명한 바와 같이, 본 기재의 분산 프로세서에서, 상응하는 메모리 뱅크도 기판 상에서 공간적으로 분산되어 있다. 일 부 실시예에서, 분산 프로세서는 명령 세트와 연관되어 있고, 분산 프로세서의 프로세서 서브유닛의 각 서브유 닛은 명령 세트에 포함된 하나 이상의 작업의 수행을 담당할 수 있다. 도 3a에 도시된 바와 같이, 하드웨어 칩은 논리 및 제어 서브유닛(320a, 320b, 320c, 320d, 320e, 320f, 320g, 320h)과 같은 복수의 프로세서 서브유닛을 포함할 수 있다. 도 3a에 더 도시된 바와 같이, 각 프로세서 서브유닛은 전용 메모리 인스턴스(memory instance)를 포함할 수 있다. 예컨대, 논리 및 제어 서브유닛(320a)은 전용 메모리 인스턴스(330a)에 작동적으로 연결되고, 논리 및 제어 서브유닛(320b)은 전용 메모리 인스턴스 (330b)에 작동적으로 연결되고, 논리 및 제어 서브유닛(320c)은 전용 메모리 인스턴스(330c)에 작동적으로 연결 되고, 논리 및 제어 서브유닛(320d)은 전용 메모리 인스턴스(330d)에 작동적으로 연결되고, 논리 및 제어 서브 유닛(320e)은 전용 메모리 인스턴스(330e)에 작동적으로 연결되고, 논리 및 제어 서브유닛(320f)은 전용 메모리 인스턴스(330f)에 작동적으로 연결되고, 논리 및 제어 서브유닛(320g)은 전용 메모리 인스턴스(330g)에 작동적 으로 연결되고, 논리 및 제어 서브유닛(320h)은 전용 메모리 인스턴스(330h)에 작동적으로 연결된다. 도 3a에는 각 메모리 인스턴스가 단일 메모리 뱅크인 것으로 도시되어 있지만, 하드웨어 칩은 하드웨어 칩 상의 프로세서 서브유닛에 대한 전용 메모리 인스턴스로 둘 이상의 메모리 뱅크를 포함할 수 있다. 또한, 도 3a에는 각 프로세서 서브유닛이 각 전용 메모리 뱅크에 대해 논리 소자와 제어를 모두 포함하는 것으로 도시 되어 있지만, 하드웨어 칩은 적어도 부분적으로는 논리 소자와 분리된 제어를 메모리 뱅크에 대해 사용할 수도 있다. 또한, 도 3a에 도시된 바와 같이, 둘 이상의 프로세서 서브유닛과 그에 상응하는 메모리 뱅크가 예 를 들어 프로세싱 그룹(310a, 310b, 310c, 310d)으로 합쳐질 수 있다. '프로세싱 그룹'이란 하드웨어 칩이 형성되는 기판 상의 공간적 구분을 나타내는 것일 수 있다. 이에 따라, 프로세싱 그룹은, 예를 들어 제어(340a, 340b, 340c, 340d)와 같은, 프로세싱 그룹의 메모리 뱅크에 대한 추가적인 제어를 더 포함할 수 있다. 추가적으 로 또는 대안적으로, '프로세싱 그룹'은 하드웨어 칩 상에서 실행할 코드의 컴파일을 위한 논리 묶음을 나 타내는 것일 수 있다. 이에 따라, 하드웨어 칩에 대한 컴파일러(하기에 설명)가 전반적인 명령 세트를 하 드웨어 칩 상의 프로세싱 그룹 간에 분리할 수 있다. 또한, 호스트가 하드웨어 칩으로 명령, 데이터, 및 기타 입력을 제공하고 하드웨어 칩으로부터 출력을 읽을 수 있다. 이에 따라, 명령 세트 전체가 단일 다이, 예를 들어 하드웨어 칩을 호스트하는 다이 상에서 실행될 수 있다. 실제로, 다이 밖에서의 통신은 하드웨어 칩으로의 명령 로딩, 하드웨어 칩으 로의 입력 전송, 및 하드웨어 칩으로부터의 출력 읽기가 전부일 수 있다. 이에 따라, 하드웨어 칩의 프로세서 서브유닛은 하드웨어 칩의 전용 메모리 뱅크와 통신하므로, 모든 계산과 메모리 연산은 다이 상(하드웨어 칩 상)에서 수행될 수 있다. 도 3b는 다른 예시적인 하드웨어 칩(300')의 실시예를 개략적으로 도시한 것이다. 하드웨어 칩의 대안으로 도시되었지만, 도 3b에 도시된 아키텍처는 적어도 부분적으로는 도 3a에 도시된 아키텍처와 병합될 수 있다. 도 3b에 도시된 바와 같이, 하드웨어 칩(300')은 프로세서 서브유닛(350a, 350b, 350c, 350d)과 같은 복수의 프 로세서 서브유닛을 포함할 수 있다. 도 3b에 더 도시된 바와 같이, 각 프로세서 서브유닛은 복수의 전용 메모리 인스턴스를 포함할 수 있다. 예컨대, 프로세서 서브유닛(350a)은 전용 메모리 인스턴스(330a, 330b)에 연결되고, 프로세서 서브유닛(350b)은 전용 메모리 인스턴스(330c, 330d)에 연결되고, 프로세서 서브유닛(350 c)은 전용 메모리 인스턴스(330e, 330f)에 연결되고, 프로세서 서브유닛(350d)은 전용 메모리 인스턴스(330g, 330h)에 연결된다. 또한, 도 3b에 도시된 바와 같이, 프로세서 서브유닛과 그에 상응하는 메모리 뱅크는 예를 들어 프로세싱 그룹(310a, 310b, 310c, 310d)으로 합쳐질 수 있다. 앞서 설명한 바와 같이, '프로세싱 그룹'이 란 하드웨어 칩(300')이 형성되는 기판 상의 공간적 구분 및/또는 하드웨어 칩(300') 상에서 실행할 코드의 컴 파일을 위한 논리 묶음을 나타내는 것일 수 있다. 도 3b에 더 도시된 바와 같이, 프로세서 서브유닛은 버스를 통하여 서로 통신할 수 있다. 예를 들어, 도 3b에 도시된 바와 같이, 프로세서 서브유닛(350a)은 버스(360a)를 통하여 프로세서 서브유닛(350b)과 통신하고, 버스 (360c)를 통하여 프로세서 서브유닛(350c)과 통신하고, 버스(360f)를 통하여 프로세서 서브유닛(350d)과 통신할 수 있다. 마찬가지로, 프로세서 서브유닛(350b)은 버스(360a)를 통하여 프로세서 서브유닛(350a)과 통신하고(상 기에 설명), 버스(360e)를 통하여 프로세서 서브유닛(350c)과 통신하고(상기에 설명), 버스(360d)를 통하여 프 로세서 서브유닛(350d)과 통신할 수 있다. 또한, 프로세서 서브유닛(350c)은 버스(360c)를 통하여 프로세서 서 브유닛(350a)과 통신하고(상기에 설명), 버스(360e)를 통하여 프로세서 서브유닛(350b)과 통신하고(상기에 설명), 버스(360b)를 통하여 프로세서 서브유닛(350d)과 통신할 수 있다. 이에 따라, 프로세서 서브유닛(350d) 은 버스(360f)를 통하여 프로세서 서브유닛(350a)과 통신하고(상기에 설명), 버스(360d)를 통하여 프로세서 서 브유닛(350b)과 통신하고(상기에 설명), 버스(360b)를 통하여 프로세서 서브유닛(350c)과 통신할 수 있다(상기 에 설명). 본 기재의 당업자라면, 도 3b에 도시된 것보다 적은 수의 버스가 사용될 수 있음을 이해할 것이다. 예를 들어, 프로세서 서브유닛(350b)과 프로세서 서브유닛(350c) 사이의 통신이 프로세서 서브유닛(350a) 및/또 는 프로세서 서브유닛(350d)을 통하여 이루어지도록 버스(360e)가 제거될 수 있다. 마찬가지로, 프로세서 서브 유닛(350a)과 프로세서 서브유닛(350d) 사이의 통신이 프로세서 서브유닛(350b) 또는 프로세서 서브유닛(350c) 을 통하여 이루어지도록 버스(360f)가 제거될 수 있다. 또한, 본 기재의 당업자라면, 도 3a와 도 3b에 도시된 것과 다른 아키텍처가 활용될 수 있음을 이해할 것이다. 예를 들어, 각각 단일 프로세서 서브유닛과 메모리 인스턴스를 포함하는 프로세싱 그룹의 어레이가 기판 상에 배치될 수 있다. 프로세서 서브유닛은 상응하는 전용 메모리 뱅크에 대한 컨트롤러의 일부, 상응하는 전용 메모 리 매트(memory mat)에 대한 컨트롤러의 일부 등을 추가적으로 또는 대안적으로 형성할 수 있다. 상기 설명한 아키텍처에 따라, 하드웨어 칩(300, 300')은 메모리 집약적 작업에 대해 기존의 아키텍처에 비해 상당히 증가된 효율을 제공할 수 있다. 예를 들어, 데이터베이스 연산 및 인공지능 알고리즘(예, 신경망)은 기 존의 아키텍처가 하드웨어 칩(300, 300')보다 효율성이 떨어지는 메모리 집약적 작업의 예이다. 이에 따라, 하 드웨어 칩(300, 300')은 데이터베이스 가속기(accelerator) 프로세서 및/또는 인공지능 가속기 프로세서로 불릴 수 있다. 기재된 하드웨어 칩의 설정 상기에 설명한 하드웨어 칩 아키텍처는 코드의 실행을 위해 구성될 수 있다. 예를 들어, 각 프로세서 서브유닛 은 하드웨어 칩 내의 다른 프로세서 서브유닛과 별개로 개별적으로 코드(명령 세트를 정의)를 실행할 수 있다. 이에 따라, 멀티스레딩(multithreading)을 관리하기 위하여 운영체제에 의존하거나 멀티태스킹(병렬성보다는 동 시성)을 활용하기보다, 본 기재의 하드웨어 칩은 프로세서 서브유닛이 완전히 병렬로 동작하게 할 수 있다. 앞서 설명한 완전 병렬 구현 외에도, 각 프로세서 서브유닛에 배정된 명령의 적어도 일부는 중첩할 수 있다. 예 를 들어, 분산 프로세서 상에 배치된 복수의 프로세서 서브유닛은 운영체제 또는 기타 관리 소프트웨어의 구현 등으로서 중복 명령을 실행할 수 있는 반면에, 운영체제 또는 기타 관리 소프트웨어의 컨텍스트 내에서 병렬 작 업을 수행하기 위하여 비중복(non-overlapping) 명령을 실행할 수 있다. 도 4는 프로세싱 그룹으로 일반적인 명령을 실행하는 예시적인 프로세스을 도시한 것이다. 예컨대, 프로세싱 그룹은 본 기재의 하드웨어 칩의 일부를 포함할 수 있다(하드웨어 칩, 하드웨어 칩(300')등). 도 4에 도시된 바와 같이, 전용 메모리 인스턴스와 쌍을 이룬 프로세서 서브유닛으로 명령이 전송될 수 있다. 외부 호스트(예, 호스트)가 실행을 위해 명령을 프로세싱 그룹으로 전송할 수 있다. 또는, 프로세서 서브유닛이 메모리 인스턴스로부터 명령을 가져오고 가져온 명령을 실행할 수 있도록, 호스 트가 상기 명령을 포함하는 명령 세트를 전송하여 메모리 인스턴스에 저장할 수 있다. 이에 따라, 가 져온 명령을 실행하게 구성될 수 있는 일반적인 처리 소자인 처리 소자에 의해 명령이 실행될 수 있다. 또 한, 프로세싱 그룹은 메모리 인스턴스에 대한 컨트롤을 포함할 수 있다. 도 4에 도시된 바와 같 이, 컨트롤은 수신된 명령을 실행할 때 처리 소자에 의해 요구되는 메모리 인스턴스로의 읽기 및/또는 쓰기를 수행할 수 있다. 명령의 실행 후, 프로세싱 그룹은 명령의 결과를 외부 호스트로 또는 동 일 하드웨어 칩 상의 다른 프로세싱 그룹 등으로 출력할 수 있다. 일부 실시예에서, 도 4에 도시된 바와 같이, 프로세서 서브유닛은 어드레스 생성기를 더 포함할 수 있다. '어드레스 생성기'는 읽기와 쓰기를 수행하기 위한 하나 이상의 메모리 뱅크의 어드레스를 판단하도록 구 성된 복수의 처리 소자를 포함할 수 있고, 또한 판단된 어드레스에 위치한 데이터에 연산(예, 덧셈, 뺄셈, 곱셈 등)을 수행할 수 있다. 예를 들어, 어드레스 생성기는 메모리로의 읽기 또는 쓰기를 위한 어드레스를 판단 할 수 있다. 일 실시예에서, 어드레스 생성기는 읽기값이 더 이상 필요하지 않은 경우에 명령에 의거하여 판단된 새로운 값으로 읽기값을 덮어씀으로써 효율을 향상할 수 있다. 추가적으로 또는 대안적으로, 어드레스 생성기는 명령 실행의 결과를 저장할 사용 가능한 어드레스를 선택할 수 있다. 이로써, 외부 호스트에게 더 편리한 나중의 클럭 사이클에 대한 결과 읽기를 스케줄 할 수 있게 된다. 다른 예에서, 어드레스 생성기 는 벡터 또는 행렬 곱셈-누적(multiply-accumulate) 계산과 같은 멀티사이클 계산 동안에 읽기 및 쓰기를 할 어드레스를 판단할 수 있다. 이에 따라, 어드레스 생성기는 데이터를 읽고 멀티사이클 계산의 중간 결 과를 쓰기 위한 메모리 어드레스를 유지 또는 계산하여, 프로세서 서브유닛이 이러한 메모리 어드레스를 저장할 필요 없이 계속 처리할 수 있도록 할 수 있다. 도 5는 프로세싱 그룹으로 특수 명령을 실행하기 위한 예시적인 프로세스를 도시한 것이다. 예를 들 어, 프로세싱 그룹은 본 기재의 하드웨어 칩의 일부를 포함할 수 있다(하드웨어 칩, 하드웨어 칩 (300') 등). 도 5에 도시된 바와 같이, 전용 메모리 인스턴스와 쌍을 이룬 처리 소자로 특수 명령(예, 곱셈-누적 명령)이 전송될 수 있다. 외부 호스트(예, 호스트)가 실행을 위해 명령을 처리 소자로 전송할 수 있 다. 이에 따라, 특정 명령(수신된 명령 포함)을 실행하도록 구성된 특수 처리 소자인 처리 소자에 의해 명 령이 호스트로부터의 특정 신호에 실행될 수 있다. 또는, 처리 소자는 실행을 위해 메모리 인스턴스 로부터 명령을 가져올 수 있다. 따라서, 도 5의 예에서, 처리 소자는 외부 호스트로부터 수신된 또는 메모 리 인스턴스로부터 가져온 MAC(multiply-accumulate) 명령을 실행하도록 구성된 MAC 회로이다. 명령을 실 행한 후, 프로세싱 그룹은 명령의 결과를 외부 호스트 또는 동일 하드웨어 칩의 다른 프로세싱 그룹 등으 로 출력할 수 있다. 도면에는 단일 명령과 단일 결과만을 도시하였지만, 복수의 명령이 수신, 검색, 및 실행될 수 있고, 복수의 결과가 출력 이전에 프로세싱 그룹 상에서 병합될 수 있다. 도 5에는 MAC 회로로 도시되었지만, 프로세싱 그룹에는 추가적인 또는 대안적인 특수 회로가 포함될 수 있다. 예를 들어, MAX-읽기 명령(벡터의 최댓값 출력), MAX0-읽기 명령(전체 벡터를 출력하지만 0으로 MAX 하는 정류 기(rectifier)로 불리는 기능) 등이 구현될 수 있다. 도 4의 일반적인 프로세싱 그룹과 도 5의 특수 프로세싱 그룹이 별도의 것으로 도시 되어 있지만, 이 들은 병합될 수 있다. 예를 들어, 일반적인 프로세서 서브유닛이 하나 이상의 특수 프로세서 서브유닛과 결합되 어 프로세서 서브유닛을 형성할 수 있다. 이에 따라, 일반적인 프로세서 서브유닛은 하나 이상의 특수 프로세서 서브유닛에 의해 실행 가능하지 않은 모든 명령에 대해 활용될 수 있다. 본 기재의 당업자라면, 신경망 구현과 기타 메모리 집약적 작업이 특수 논리 회로에 의해 처리될 수 있음을 이 해할 것이다. 예를 들어, 데이터베이스 쿼리, 패킷 검사, 스트링 비교, 및 기타 기능은 여기에 기재된 하드웨어 칩에 의해 실행되는 경우에 효율이 향상될 수 있다. 분산 처리에 대한 메모리 기반 아키텍처 본 기재에 따른 하드웨어 칩 상에서, 전용 버스는 칩 상의 프로세서 서브유닛 사이 및/또는 프로세서 서브유닛 과 그에 상응하는 전용 메모리 뱅크 사이에 데이터를 전송할 수 있다. 전용 버스를 사용하면 상충하는 요구가불가능하거나 하드웨어가 아닌 소프트웨어를 사용하여 쉽게 회피될 수 있기 때문에 중재 비용을 줄일 수 있다. 도 6은 프로세싱 그룹을 개략적으로 도시한 것이다. 프로세싱 그룹은 하드웨어 칩, 하드웨어 칩 (300') 등과 같은 하드웨어 칩에서 사용하기 위한 것일 수 있다. 프로세서 서브유닛은 버스를 통해 메모리에 연결될 수 있다. 메모리는 프로세서 서브유닛에 의한 실행을 위한 데이터 및 코드를 저장하는 RAM 소자를 포함할 수 있다. 일부 실시예에서, 메모리는 N-웨이 메모리일 수 있다(여기서, N은 인터리브(interleaved) 메모리 내의 세그먼트의 수를 의미하는 1 이상의 수). 프로세서 서브유닛은 버스를 통해 프로세서 서브유닛 전용의 메모리에 결합되므로, N은 실행 성능의 손실 없이도 상 대적으로 낮은 수로 유지될 수 있을 것이다. 이는, N이 작으면 실행 성능이 떨어지고 N이 높으면 면적과 파워 손실이 큰 기존의 멀티웨이 레지스터 파일 또는 캐시에 비한 향상을 의미한다. 프로세싱 그룹을 사용하는 시스템의 작업 및 어플리케이션 구현의 요구조건에 맞도록 작업에 연관된 데이 터의 사이즈 등에 따라 메모리의 사이즈, N-웨이의 N의 수, 및 버스의 폭이 조절될 수 있다. 메모리 소자는, 예를 들어, 휘발성 메모리(RAM, DRAM, SRAM, 상변화 RAM (phase-change RAM 또는 PRAM), 강자성 RAM(magnetoresistive RAM 또는 MRAM), 저항성 RAM(resistive RAM 또는 ReRAM) 등) 또는 비휘발성 메모리(플 래시메모리 또는 ROM)와 같은, 본 기술 분야에 알려진 하나 이상의 메모리 유형을 포함할 수 있다. 일부 실시예 에 따라, 메모리 소자의 일부분은 제1 메모리 유형을 포함하고, 다른 부분은 다른 메모리 유형을 포함할 수 있다. 예를 들어, 메모리 소자의 코드 영역은 ROM 소자를 포함하고, 메모리 소자의 데이터 영역은 DRAM 소자를 포함할 수 있다. 이러한 분할의 다른 예로서, 신경망의 무게는 플래시메모리에 저장하는 반면, 계 산을 위한 데이터는 DRAM에 저장할 수 있다. 프로세서 서브유닛은 프로세서를 포함할 수 있는 처리 소자를 포함한다. 프로세서는, 당업자라면 이"}
{"patent_id": "10-2021-7010116", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "해하듯이, 파이프라인 되거나 되지 않을 수 있고, 본 기술분야에 알려진 모든 시중의 집적회로(예, ARM, ARC, RISC-V 등) 상에 구현된 맞춤형 RISC(Reduced Instruction Set Computing) 소자 또는 기타 처리 스키마 일 수 있다. 처리 소자는 일부 실시예에서 ALU(Arithmetic Logic Unit) 또는 기타 컨트롤러를 포함하는 컨트롤러 를 포함할 수 있다. 일부 실시예에 따라, 수신 또는 저장된 코드를 실행하는 처리 소자는 일반적인 처리 소자를 포함할 수 있 으므로 매우 다양한 처리 연산의 수행이 유연하고 가능하다. 특정 연산의 수행 동안에 소비하는 전력을 비교할 때, 전용이 아닌 회로는 특정 연산 전용 회로보다 많은 전력을 소비한다. 따라서, 특정 복잡 산술 계산을 수행 할 경우, 처리 소자는 전용 하드웨어보다 많은 전력을 소비하고 효율이 떨어질 수 있다. 따라서, 일부 실 시예에 따라, 처리 소자의 컨트롤러는 특정 연산(예, 합산 또는 '이동' 연산)을 수행하도록 설계될 수 있 다. 일례에서, 특정 연산은 하나 이상의 가속기(accelerator, 650)에 의해 수행될 수 있다. 각 가속기는 특정 계산 (예, 곱셈, 부동 소수점 벡터 연산 등)의 수행의 전용으로 프로그램될 수 있다. 가속기를 사용함으로써, 프로세 서 서브유닛 당 계산 별로 소비하는 평균 전력이 감소될 수 있고, 향후 계산 처리량이 증가한다. 가속기는 시스템이 구현(예, 신경망의 실행, 데이터베이스 쿼리의 실행 등)하도록 설계된 어플리케이션에 따라 선택될 수 있다. 가속기는 처리 소자에 의해 설정될 수 있고, 전력 소비의 감소와 계산의 가속을 위해 처리 소 자와 협력하여 작동할 수 있다. 스마트 DMA(direct memory access) 주변기기와 같이, 가속기는 프로세싱 그룹의 메모리와 MUX/DEMUX/입력/출력 포트(예, MUX, DEMUX) 사이에 데이터를 전송하기 위해 추가적으로 또는 대안적으로 사용될 수 있다. 가속기는 다양한 기능을 수행하도록 구성될 수 있다. 예를 들어, 어떤 가속기는 신경망에서 자주 사용되는 16비트 부동 소수점 계산 또는 8비트 정수 계산을 수행하도록 구성될 수 있다. 가속기 기능의 다른 예는 신경망 의 학습 단계에서 자주 사용되는 32비트 부동 소수점 계산이다. 가속기 기능의 또 다른 예는 데이터베이스에서 사용되는 것과 같은 쿼리 처리이다. 일부 실시예에서, 가속기는 이러한 기능을 수행하기 위해 특화된 처리 소자를 포함할 수 있고/있거나 메모리 소자에 저장된 설정 데이터에 따라 설정되어 수정이 가능하도록 할 수 있다. 가속기는 메모리로의/로부터의 또는 기타 가속기 및/또는 입력/출력으로의/으로부터의 데이터의 설정 가능한 기재된 목록의 메모리 이동에서 타임 이동을 추가적으로 또는 대안적으로 구현할 수 있다. 이에 따라, 하기에 더 설명하는 바와 같이, 프로세싱 그룹을 사용하는 하드웨어 칩 내부의 모든 데이터 이동은 하드웨 어 동기화보다는 소프트웨어 동기화를 이용할 수 있다. 예를 들어, 한 프로세싱 그룹(예, 600)의 가속기는 10번 째 사이클마다 데이터를 입력에서 가속기로 전송한 후에 다음 사이클에서 데이터를 출력하여 프로세싱 그룹의메모리로부터 다른 프로세싱 그룹으로 정보가 이동하게 할 수 있다. 도 6에 더 도시된 바와 같이, 일부 실시예에서, 프로세싱 그룹은 입력 포트에 연결된 적어도 하나의 입력 멀티플렉서(MUX)와 출력 포트에 연결된 적어도 하나의 출력 디멀티플렉서(DEMUX)를 더 포함할 수 있 다. 이러한 MUX/DEMUX는 처리 소자 및/도는 가속기 중의 하나로부터의 제어 신호(미도시)에 의해 제 어되고, 처리 소자에 의해 수행되는 현 지시 및/또는 가속기 중의 한 가속기에 의해 실행되는 연산에 따라 판단될 수 있다. 일부의 경우, 프로세싱 그룹은 (코드 메모리로부터의 미리 정해진 명령에 따라) 입 력 포트로부터 출력 포트로 데이터를 전송하도록 요구될 수 있다. 이에 따라, MUX/DEMUX의 각각이 처리 소자 와 가속기에 연결될 뿐만 아니라, 입력 MUX의 하나 이상(예, MUX)이 하나 이상의 버스를 통해 출력 DEMUX(예, DEMUX)로 직접 연결될 수 있다. 도 6의 프로세싱 그룹은 배열되어 도 7a에 도시된 것 등과 같은 분산 프로세서를 형성할 수 있다. 프로세 싱 그룹은 기판에 배치되어 어레이를 형성할 수 있다. 일부 실시예에서, 기판은 실리콘과 같은 반도 체 기판을 포함할 수 있다. 추가적으로 또는 대안적으로, 기판은 연성회로기판과 같은 회로기판을 포함할 수 있다. 도 7a에 도시된 바와 같이, 기판은, 프로세싱 그룹과 같은, 그 위에 배치된 복수의 프로세싱 그룹을 포함할 수 있다. 이에 따라, 기판은 뱅크(720a, 720b, 720c, 720d, 720e, 720f, 720g, 720h)와 같은 복수 의 뱅크를 포함하는 메모리 어레이를 포함한다. 또한, 기판은 서브유닛(730a, 730b, 730c, 730d, 730e, 730f, 730g, 730h)과 같은 복수의 프로세서 서브유닛을 포함할 수 있는 프로세싱 어레이를 포함한다. 또한, 앞서 설명한 바와 같이, 각 프로세싱 그룹은 프로세서 서브유닛과 이 서브유닛 전용의 하나 이상의 상응 하는 메모리 뱅크를 포함할 수 있다. 이에 따라, 도 7a에 도시된 바와 같이, 각 서브유닛은 상응하는 전용 메모 리 뱅크와 연관된다. 예를 들어, 프로세서 서브유닛(730a)은 메모리 뱅크(720a)와 연관되고, 프로세서 서브유닛 (730b)은 메모리 뱅크(720b)와 연관되고, 프로세서 서브유닛(730c)은 메모리 뱅크(720c)와 연관되고, 프로세서 서브유닛(730d)은 메모리 뱅크(720d)와 연관되고, 프로세서 서브유닛(730e)은 메모리 뱅크(720e)와 연관되고, 프로세서 서브유닛(730f)은 메모리 뱅크(720f)와 연관되고, 프로세서 서브유닛(730g)은 메모리 뱅크(720g)와 연 관되고, 프로세서 서브유닛(730h)은 메모리 뱅크(720h)와 연관된다. 각 프로세서 서브유닛이 상응하는 전용 메모리 뱅크와 통신하도록 하기 위하여, 기판은 프로세서 서브유닛 중의 하나를 그에 상응하는 전용 메모리 뱅크로 연결하는 제1 복수의 버스를 포함할 수 있다. 이에 따라, 버스 (740a)는 프로세서 서브유닛(730a)을 메모리 뱅크(720a)로 연결하고, 버스(740b)는 프로세서 서브유닛(730b)을 메모리 뱅크(720b)로 연결하고, 버스(740c)는 프로세서 서브유닛(730c)을 메모리 뱅크(720c)로 연결하고, 버스 (740d)는 프로세서 서브유닛(730d)을 메모리 뱅크(720d)로 연결하고, 버스(740e)는 프로세서 서브유닛(730e)을 메모리 뱅크(720e)로 연결하고, 버스(740f)는 프로세서 서브유닛(730f)을 메모리 뱅크(720f)로 연결하고, 버스 (740g)는 프로세서 서브유닛(730g)을 메모리 뱅크(720g)로 연결하고, 버스(740h)는 프로세서 서브유닛(730h)을 메모리 뱅크(720h)로 연결한다. 또한, 각 프로세서 서브유닛이 다른 프로세서 서브유닛과 통신하도록 하기 위하 여, 기판은 프로세서 서브유닛 중의 하나를 프로세서 서브유닛 중의 다른 하나로 연결하는 제2 복수의 버 스를 포함할 수 있다. 도 7a의 예에서, 버스(750a)는 프로세서 서브유닛(730a)을 프로세서 서브유닛(750e)으로 연결하고, 버스(750b)는 프로세서 서브유닛(730a)을 프로세서 서브유닛(750b)으로 연결하고, 버스(750c)는 프로 세서 서브유닛(730b)을 프로세서 서브유닛(750f)으로 연결하고, 버스(750d)는 프로세서 서브유닛(730b)을 프로 세서 서브유닛(750c)으로 연결하고, 버스(750e)는 프로세서 서브유닛(730c)을 프로세서 서브유닛(750g)으로 연 결하고, 버스(750f)는 프로세서 서브유닛(730c)을 프로세서 서브유닛(750d)으로 연결하고, 버스(750g)는 프로세 서 서브유닛(730d)을 프로세서 서브유닛(750h)으로 연결하고, 버스(750h)는 프로세서 서브유닛(730h)을 프로세 서 서브유닛(750g)으로 연결하고, 버스(750i)는 프로세서 서브유닛(730g)을 프로세서 서브유닛(750g)으로 연결 하고, 버스(750j)는 프로세서 서브유닛(730f)을 프로세서 서브유닛(750e)으로 연결한다. 이에 따라, 도 7a에 도시된 예시적인 배치에서, 복수의 논리 프로세서 서브유닛은 적어도 하나의 행과 적어도 하나의 열로 배치된다. 제2 복수의 버스는 각 프로세서 서브유닛을 동일한 행의 적어도 하나의 인접 프로세서 서브유닛과 동일한 열의 적어도 하나의 인접 프로세서 서브유닛으로 연결한다. 도 7a는 '부분 타일 연결 (partial tile connection)'로 일컬을 수 있다. 도 7a에 도시된 배치는 수정되어 '완전 타일 연결(full tile connection)'을 형성할 수 있다. 완전 타일 연결은 대각선의 프로세서 서브유닛을 연결하는 추가적인 버스를 포함한다. 예를 들어, 제2 복수의 버스는 프로세서 서 브유닛(730a)과 프로세서 서브유닛(730f) 사이, 프로세서 서브유닛(730b)과 프로세서 서브유닛(730e) 사이, 프로세서 서브유닛(730b)과 프로세서 서브유닛(730g) 사이, 프로세서 서브유닛(730c)과 프로세서 서브유닛(730f) 사이, 프로세서 서브유닛(730c)과 프로세서 서브유닛(730h) 사이, 및 프로세서 서브유닛(730d)과 프로세서 서브 유닛(730g) 사이에 추가적인 버스를 포함할 수 있다. 완전 타일 연결은, 근처의 프로세서 서브유닛에 저장된 데이터와 결과를 활용하는, 컨볼루션(convolution) 계산 에 이용될 수 있다. 예를 들어, 컨볼루션 이미지 처리 중에, 각 프로세서 서브유닛은 이미지 타일(예, 한 픽셀 또는 픽셀 그룹)을 수신할 수 있다. 컨볼루션 결과를 계산하기 위하여, 각 프로세서 서브유닛은 각각 상응하는 타일을 수신한 8개의 인접 프로세서 서브유닛으로부터 데이터를 확보할 수 있다. 부분 타일 연결에서는, 대각선 으로 인접한 프로세서 서브유닛으로부터의 데이터는 해당 프로세서 서브유닛에 연결된 다른 인접 프로세서 서브 유닛을 통해 통과될 수 있다. 이에 따라, 칩 상의 분산 프로세서는 인공지능 가속기 프로세서일 수 있다. 컨볼루션 계산의 구체적인 예에서, N x M 이미지가 복수의 프로세서 서브유닛에 걸쳐 분할될 수 있다. 각 프로 세서 서브유닛은 상응하는 타일에 대해 A x B 필터로 컨볼루션을 수행할 수 있다. 타일 사이의 경계상의 하나 이상의 픽셀에 대한 필터링을 수행하기 위하여, 각 프로세서 서브유닛은 동일한 경계상의 픽셀을 포함하는 타일 을 가진 이웃 프로세서 서브유닛으로부터 데이터를 요구할 수 있다. 이에 따라, 각 프로세서 서브유닛에 대해 생성된 코드는 해당 서브유닛이 컨볼루션을 계산하고 인접 서브유닛으로부터 데이터가 필요할 때마다 제2 복수 의 버스 중의 하나로부터 당겨오도록 설정한다. 제2 복수의 버스로 데이터를 출력하기 위한 상응하는 명령이 해 당 서브유닛으로 제공되어 필요한 데이터 전송의 타이밍이 적절하도록 한다. 도 7a의 부분 타일 연결은 N-부분 타일 연결이 되도록 수정될 수 있다. 이러한 수정에서, 제2 복수의 버스는 각 프로세서 서브유닛을 도 7a의 버스가 지나가는 4방향(즉, 상, 하, 좌, 우 방향)의 해당 프로세서 서브유닛의 임 계 거리 이내(예, n 프로세서 서브유닛 이내)에 있는 프로세서 서브유닛으로 더 연결할 수 있다. 완전 타일 연 결에도 유사한 수정이 이루어져(즉, 결과적으로 N-완전 타일 연결이 되어) 제2 복수의 버스가 각 프로세서 서브 유닛을 도 7a의 버스가 지나가는 4방향과 대각선 2 방향의 해당 프로세서 서브유닛의 임계 거리 이내(예, n 프 로세서 서브유닛 이내)에 있는 프로세서 서브유닛으로 더 연결하도록 할 수 있다. 다른 배치도 가능하다. 예를 들어, 도 7b에 도시된 배치에서, 버스(750a)는 프로세서 서브유닛(730a)을 프로세 서 서브유닛(730d)으로 연결하고, 버스(750b)는 프로세서 서브유닛(730a)을 프로세서 서브유닛(730b)으로 연결 하고, 버스(750c)는 프로세서 서브유닛(730b)을 프로세서 서브유닛(730c)으로 연결하고, 버스(750d)는 프로세서 서브유닛(730c)을 프로세서 서브유닛(730d)으로 연결한다. 이에 따라, 도 7b에 도시된 예에서, 복수의 프로세서 서브유닛은 별 무늬로 배치된다. 제2 복수의 버스는 각 프로세서 서브유닛을 별 무늬 이내의 적어도 하나의 인 접 프로세서 서브유닛으로 연결한다. 추가적인 배치(미도시)도 가능하다. 예를 들면, 복수의 프로세서 서브유닛이 하나 이상의 선에 배치되도록(도 7a에 도시된 배치와 유사) 하는 이웃 연결 배치가 사용될 수 있다. 이웃 연결 배치에서, 제2 복수의 버스는 각 프로세서 서브유닛을 동일 선 상의 좌측에 있는 프로세서 서브유닛, 동일 선 상의 우측에 있는 프로세서 서브유 닛, 동일 선 상의 좌우측 모두에 있는 프로세서 서브유닛 등에 연결한다. 다른 예에서, N-선형 연결 배치가 사용될 수 있다. N-선형 연결 배치에서, 제2 복수의 버스는 각 프로세서 서브 유닛을 해당 프로세서 서브유닛의 임계 거리 이내(예, n 프로세서 서브유닛 이내)에 있는 프로세서 서브유닛에 연결한다. N-선형 연결 배치는 라인 어레이(상기 설명 참조), 장방형 어레이(도 7a에 도시), 타원형 어레이(도 7b에 도시), 또는 기타 기하 어레이와 함께 사용될 수 있다. 또 다른 예에서, N-로그 연결 배치가 사용될 수 있다. N-로그 연결 배치에서, 제2 복수의 버스는 각 프로세서 서브유닛을 해당 프로세서 서브유닛의 2의 거듭제곱 임계 거리 이내(예, 2n 프로세서 서브 유닛 이내)에 있는 프 로세서 서브유닛에 연결한다. N-로그 연결 배치는 라인 어레이(상기 설명 참조), 장방형 어레이(도 7a에 도시), 타원형 어레이(도 7b에 도시), 또는 기타 기하 어레이와 함께 사용될 수 있다. 상기에 설명한 연결 스키마의 어느 것이라도 서로 병합하여 동일 하드웨어 칩 상에서 사용될 수 있다. 예를 들 어, 완전 타일 연결이 한 영역에서 사용되고, 부분 타일 연결이 다른 영역에서 사용될 수 있다. 다른 예를 들면, N-선형 연결 배치가 한 영역에서 사용되고, N-완전 타일 연결이 다른 영역에서 사용될 수 있다. 메모리 칩의 프로세서 서브유닛 사이의 전용 버스에 대안적으로 또는 추가적으로, 하나 이상의 공유 버스를 사 용하여 분산 프로세서의 모든 프로세서 서브유닛(또는 모든 프로세서 서브유닛의 서브세트)을 서로 연결할 수 있다. 공유 버스 상의 충돌은 프로세서 서브유닛에 의해 실행되는 코드를 활용하여 공유 버스 상의 데이터 전송 타이밍을 조정함으로써 방지될 수 있으며, 이에 대하여는 하기에 설명한다. 공유 버스에 추가적으로 또는 대안적으로, 설정형 버스(configurable bus)를 사용하여 프로세서 서브유닛을 동적으로 연결하여 서로 분리된 버스 로 연결되는 프로세서 서브유닛 그룹을 형성할 수 있다. 예를 들어, 설정형 버스는 프로세서 서브유닛에 의해 제어되어 데이터를 선택된 프로세서 서브유닛으로 전송할 수 있는 트랜지스터 또는 기타 메커니즘을 포함할 수 있다. 도 7a와 도 7b에서, 프로세싱 어레이의 복수의 프로세서 서브유닛은 메모리 어레이의 복수의 이산 메모리 뱅크 사이에 공간적으로 분포된다. 다른 대안적인 실시예(미도시)에서, 복수의 프로세서 서브유닛은 기판의 하나 이 상의 영역에서 클러스터링 될 수 있고, 복수의 메모리 뱅크는 기판의 하나 이상의 다른 영역에서 클러스터링 될 수 있다. 일부 실시예에서, 공간적 분포와 클러스터링의 조합(미도시)이 사용될 수 있다. 예를 들어, 기판의 일 영역은 프로세서 서브유닛의 클러스터를 포함하고, 기판의 다른 영역은 메모리 뱅크의 클러스터를 포함하고, 기 판의 또 다른 영역은 메모리 뱅크 사이에 분포된 프로세싱 어레이를 포함할 수 있다. 본 기재의 당업자라면, 기판 상에 프로세싱 그룹의 어레이를 형성하는 것은 배타적인 실시예가 아님을 이 해할 것이다. 예를 들어, 각 프로세서 서브유닛은 적어도 두 개의 전용 메모리 뱅크와 연관될 수 있다. 이에 따 라, 도 3b의 프로세싱 그룹(310a, 310b, 310c, 310d)은 프로세싱 그룹을 대신하여 또는 프로세싱 그룹 과 함께 사용되어 프로세싱 어레이와 메모리 어레이를 형성할 수 있다. 셋, 넷, 또는 그 이상 등의 전용 메모리 뱅크(미도시)를 포함하는 다른 프로세싱 그룹도 사용될 수 있다. 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 특정 어플리케이션과 연관된 소프트웨어 코드를 복수의 프 로세서 서브유닛에 포함된 다른 프로세서 서브유닛에 대해 개별적으로 실행하도록 구성될 수 있다. 예를 들어, 하기에 설명하는 바와 같이, 복수의 서브시리즈(sub-series)의 명령이 머신 코드로 그룹으로 묶이고 각 프로세 서 서브유닛으로 제공되어 실행될 수 있다. 일부 실시예에서, 각 전용 메모리 뱅크는 적어도 하나의 DRAM을 포함한다. 대안적으로, 메모리 뱅크는 SRAM, DRAM, 플래시메모리 등과 같은 메모리 유형의 조합을 포함할 수 있다. 기존의 프로세서에서, 프로세서 서브유닛 사이의 데이터 공유는 일반적으로 공유 메모리로 수행된다. 공유 메모 리는 보통 넓은 부분의 칩 영역을 요구 및/또는 추가적인 하드웨어(예, 아비터(arbiter))에 의해 관리되는 버스 에 의해 수행된다. 버스는 앞서 설명한 바와 같이 병목 현상을 초래한다. 또한, 칩의 외부에 있을 수 있는 공유 메모리는 정확하고 업데이트 된 데이터를 프로세서 서브유닛에 제공하기 위해서 캐시 일관성 메커니즘과 더욱 복잡한 캐시(예, L1 캐시, L2 캐시, 공유 DRAM)를 포함하는 것이 보통이다. 하기에 더 설명하는 바와 같이, 도 7a와 도 7b에 도시된 전용 버스는 하드웨어 관리(예, 아비터)가 필요 없는 하드웨어 칩을 가능하게 한다. 또한, 도 7a와 도 7b에 도시된 것과 같은 전용 메모리를 사용하면 복잡한 캐싱 계층과 일관성 메커니즘이 없어도 된다. 대신에, 각 프로세서 서브유닛이 다른 프로세서 서브유닛에 의해 계산 및/또는 다른 프로세서 서브유닛의 전용 메모리 뱅크에 저장된 데이터에 접근하게 하기 위하여, 각 프로세서 서브유닛에 의해 개별적으로 실행되는 코드 를 활용하여 동적으로 타이밍이 수행되는 버스가 제공된다. 이로써, 기존에 사용되는 버스 관리 하드웨어 대부 분 또는 전부가 없어도 된다. 또한, 복잡한 캐싱 메커니즘을 이러한 버스를 통한 직접 전송으로 대체할 수 있으 므로, 그 결과, 메모리 읽기와 쓰기 동안에 대기 시간을 줄일 수 있다. 메모리 기반 프로세싱 어레이 도 7a와 도 7b에 도시된 바와 같이, 본 기재의 메모리 칩은 개별적으로 동작할 수 있다. 또는, 본 기재의 메모 리 칩은 메모리 장치(예, 하나 이상의 DRAM 뱅크), 시스템 온 칩, FPGA(field-programmable gate array), 또는 기타 프로세싱 및/또는 메모리 칩과 같은 하나 이상의 추가적인 집적회로에 작동적으로 연결될 수 있다. 이러한 실시예에서, 상기 아키텍처에 의해 실행되는 일련의 명령의 작업은 메모리 칩의 프로세서 서브유닛과 추가적인 집적회로의 프로세서 서브유닛 사이에 분할될 수(예, 하기에 설명하는 바와 같이, 컴파일러에 의해) 있다. 예를 들어, 추가적인 집적회로는 명령 및/또는 데이터를 메모리 칩에 입력하고 메모리 칩으로부터 출력을 수신하는 호스트(예, 도 3a의 호스트)를 포함할 수 있다. 본 기재의 메모리 칩과 하나 이상의 추가 집적회로를 서로 연결하기 위하여, 메모리 칩은 JEDEC(Joint Electron Device Engineering Council) 표준 또는 그 개정 표준을 준수하는 메모리 인터페이스와 같은 메모리 인터페이스 를 포함할 수 있다. 상기 하나 이상의 추가 집적회로는 이후 메모리 인터페이스로 연결될 수 있다. 이에 따라, 하나 이상의 추가 집적회로가 본 기재의 복수의 메모리 칩에 연결되는 경우, 데이터가 하나 이상의 추가 집적회 로를 통해 메모리 칩 사이에 공유될 수 있다. 추가적으로 또는 대안적으로, 하나 이상의 추가 집적회로는 본 기재의 메모리 칩의 버스와 연결하기 위한 버스를 포함하여 상기 하나 이상의 추가 집적회로가 본 기재의 메모리 칩과 협력하여 코드를 실행하도록 할 수 있다. 이러한 실시예에서, 하나 이상의 추가 집적회로는 본 기재의 메 모리 칩과 다른 기판 상에 있더라도 분산 프로세싱을 추가적으로 지원할 수 있다. 또한, 본 기재의 메모리 칩은 분산 프로세서의 어레이를 형성하기 위하여 어레이로 배치될 수 있다. 예를 들어, 도 7c에 도시된 바와 같이, 하나 이상의 버스가 메모리 칩(770a)을 추가 메모리 칩(770b)으로 연결할 수 있다. 도 7c의 예에서, 메모리 칩(770a)은 하나 이상의 상응하는 메모리 뱅크가 각 프로세서 서브유닛의 전용인 프로 세서 서브유닛을 포함한다. 예를 들어, 프로세서 서브유닛(730a)은 메모리 뱅크(720a)와 연관되고, 프로세서 서 브유닛(730b)은 메모리 뱅크(720b)와 연관되고, 프로세서 서브유닛(730e)은 메모리 뱅크(720c)와 연관되고, 프 로세서 서브유닛(730f)은 메모리 뱅크(720d)와 연관된다. 버스는 각 프로세서 서브유닛을 그에 상응하는 메모리 뱅크에 연결한다. 이에 따라, 버스(740a)는 프로세서 서브유닛(730a)을 메모리 뱅크(720a)에 연결하고, 버스 (740b)는 프로세서 서브유닛(730b)을 메모리 뱅크(720b)에 연결하고, 버스(740c)는 프로세서 서브유닛(730e)을 메모리 뱅크(720c)에 연결하고, 버스(740d)는 프로세서 서브유닛(730f)을 메모리 뱅크(720d)에 연결한다. 또한, 버스(750a)는 프로세서 서브유닛(730a)을 프로세서 서브유닛(750a)에 연결하고, 버스(750b)는 프로세서 서브유 닛(730a)을 프로세서 서브유닛(750b)에 연결하고, 버스(750c)는 프로세서 서브유닛(730b)을 프로세서 서브유닛 (750f)에 연결하고, 버스(750d)는 프로세서 서브유닛(730e)을 프로세서 서브유닛(750f)에 연결한다. 앞서 설명 한 바와 같이, 메모리 칩(770a)의 다른 배치도 활용될 수 있다. 마찬가지로, 메모리 칩(770b)은 하나 이상의 상응하는 메모리 뱅크가 각 프로세서 서브유닛의 전용인 프로세서 서브유닛을 포함한다. 예를 들어, 프로세서 서브유닛(730c)은 메모리 뱅크(720e)와 연관되고, 프로세서 서브유 닛(730d)은 메모리 뱅크(720f)와 연관되고, 프로세서 서브유닛(730g)은 메모리 뱅크(720g)와 연관되고, 프로세 서 서브유닛(730h)은 메모리 뱅크(720h)와 연관된다. 버스는 각 프로세서 서브유닛을 그에 상응하는 메모리 뱅 크에 연결한다. 이에 따라, 버스(740e)는 프로세서 서브유닛(730c)을 메모리 뱅크(720e)에 연결하고, 버스 (740f)는 프로세서 서브유닛(730d)을 메모리 뱅크(720f)에 연결하고, 버스(740g)는 프로세서 서브유닛(730g)을 메모리 뱅크(720g)에 연결하고, 버스(740h)는 프로세서 서브유닛(730h)을 메모리 뱅크(720h)에 연결한다. 또한, 버스(750g)는 프로세서 서브유닛(730c)을 프로세서 서브유닛(750g)에 연결하고, 버스(750h)는 프로세서 서브유 닛(730d)을 프로세서 서브유닛(750h)에 연결하고, 버스(750i)는 프로세서 서브유닛(730c)을 프로세서 서브유닛 (750d)에 연결하고, 버스(750j)는 프로세서 서브유닛(730g)을 프로세서 서브유닛(750h)에 연결한다. 앞서 설명 한 바와 같이, 메모리 칩(770b)의 다른 배치도 활용될 수 있다. 메모리 칩(770a, 770b)의 프로세서 서브유닛은 하나 이상의 버스를 사용하여 서로 연결될 수 있다. 이에 따라, 도 7c의 예에서, 버스(750e)는 메모리 칩(770a)의 프로세서 서브유닛(730b)과 메모리 칩(770b)의 프로세서 서브 유닛(730c)을 서로 연결할 수 있고, 버스(750f)는 메모리 칩(770a)의 프로세서 서브유닛(730f)과 메모리 칩 (770b)의 프로세서 서브유닛(730c)을 서로 연결할 수 있다. 예를 들어, 버스(750e)는 메모리 칩(770b)으로의 입 력 버스(따라서, 메모리 칩(770a)의 출력 버스) 역할을 할 수 있고, 버스(750f)는 메모리 칩(770a)으로의 입력 버스(따라서, 메모리 칩(770b)의 출력 버스) 역할을, 또는 그 반대의 역할을, 할 수 있다. 또는 버스(750e, 750f)는 모두 메모리 칩(770a, 770b) 사이의 양방향 버스 역할을 할 수 있다. 버스(750e, 750f)는 직접 회선을 포함하거나, 메모리 칩(770a)과 집적회로(770b) 사이의 인터칩 인터페이스 (inter-chip interface)에 사용되는 핀을 줄이기 위해 고속 연결 상에 인터리브 될 수 있다. 또한, 메모리 칩에 사용되는 앞서 설명한 모든 연결 구성이 사용되어 메모리 칩을 하나 이상의 추가 집적회로에 연결할 수 있다. 예를 들어, 메모리 칩(770a, 770b)은 도 7c에 도시된 것과 같은 2개의 버스만을 사용하기보다 완전 타일 연결이 나 부분 타일 연결을 사용하여 연결될 수 있다. 이에 따라, 버스(750e, 750f)를 사용하여 도시되었지만, 아키텍처는 더 적은 수의 버스나 더 많은 수의 버 스를 포함할 수 있다. 예를 들어, 프로세서 서브유닛(730a, 730b) 사이 또는 프로세서 서브유닛(730f, 730c) 사 이에 단일 버스가 사용될 수 있다. 또는, 추가적인 버스가 프로세서 서브유닛(730b)와 (730d) 사이 또는 프로세 서 서브유닛(730f)와 (730d) 사이 등에 사용될 수 있다. 또한, 단일 메모리 칩과 추가 집적회로를 사용하는 것으로 도시되었지만, 복수의 메모리 칩이 앞서 설명한 바와 같이 연결될 수 있다. 예를 들어, 도 7c에 도시된 바와 같이, 메모리 칩(770a, 770b, 770c, 770d)이 어레이로 연결된다. 각 메모리 칩은 앞서 설명한 메모리 칩과 유사하게 프로세서 서브유닛과 전용 메모리 뱅크를 포함한 다. 이에 따라, 이러한 구성요소에 대한 설명은 여기서 반복하지 않는다. 도 7c의 예에서, 메모리 칩(770a, 770b, 770c, 770d)은 루프로 연결된다. 이에 따라, 버스(750a)는 메모리 칩 (770a, 770d)을 연결하고, 버스(750c)는 메모리 칩(770a, 770b)을 연결하고, 버스(750e)는 메모리 칩(770b, 770c)을 연결하고, 버스(750g)는 메모리 칩(770c, 770d)을 연결한다. 메모리 칩(770a, 770b, 770c, 770d)은 완 전 타일 연결, 부분 타일 연결 또는 기타 연결 구성으로 연결될 수 있지만, 도 7c의 예는 메모리 칩(770a, 770b, 770c, 770d) 사이에 적은 수의 핀 연결을 가능하게 한다. 상대적 대용량 메모리 본 기재의 실시예들은 기존 프로세서의 공유 메모리에 비하여 상대적으로 큰 사이즈의 전용 메모리를 사용할 수 있다. 공유 메모리가 아닌 전용 메모리를 사용하면 메모리 증가로 인한 효율 감소 없이 작업을 진행할 수 있다. 이로써, 공유 메모리의 증가에 따른 효율 향상이 폰노이만 병목현상(von Neumann bottleneck)으로 인해 줄어드 는 기존 프로세서에서 수행되는 것보다 신경망 처리와 데이터베이스 쿼리와 같은 메모리 집약적 작업이 더 효율 적으로 수행될 수 있다. 예를 들어, 본 기재의 분산 프로세서에서, 기재된 프로세서의 기판 상에 배치된 메모리 어레이는 복수의 이산 메모리 뱅크를 포함할 수 있다. 각각의 이산 메모리 뱅크는 1메가바이트 이상의 용량 및 복수의 프로세서 서브 유닛을 포함하고 기판 상에 배치된 프로세싱 어레이를 포함할 수 있다. 앞서 설명한 바와 같이, 프로세서 서브 유닛의 각 프로세서 서브유닛은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 연관될 수 있다. 일부 실시예에서, 복수의 프로세서 서브유닛은 메모리 어레이 이내의 복수의 이산 메모리 뱅크 사이에서 공간적으로 분포될 수 있다. 대형 CPU 또는 GPU에 대해 몇 메가바이트의 공유 캐시를 사용하기보다 최소 1 메카 바이트의 전용 메모리를 사용함으로써, 본 기재의 분산 프로세서는 CPU와 GPU의 폰노이만 병목현상으로 인해 기 존의 시스템에서 가능하지 않은 효율성을 얻게 된다. 서로 다른 메모리가 전용 메모리로 사용될 수도 있다. 예를 들어, 각 전용 메모리 뱅크는 적어도 하나의 DRAM 뱅크를 포함할 수 있다. 또는, 각 전용 메모리 뱅크는 적어도 하나의 SRAM 뱅크를 포함할 수 있다. 다른 실시예 에서, 서로 다른 유형의 메모리가 단일 하드웨어 칩 상에서 병합될 수 있다. 앞서 설명한 바와 같이, 각 전용 메모리는 최소 1메가바이트일 수 있다. 이에 따라, 각 전용 메모리 뱅크는 동 일 사이즈이거나, 복수의 메모리 뱅크의 적어도 두 메모리 뱅크는 서로 다른 사이즈일 수 있다. 또한, 앞서 설명한 바와 같이, 분산 프로세서는 각각 복수의 프로세서 서브유닛의 한 프로세서 서브유닛을 그에 상응하는 전용 메모리 뱅크에 연결하는 제1 복수의 버스 및 각각 복수의 프로세서 서브유닛의 한 프로세서 서브 유닛을 복수의 프로세서 서브유닛의 다른 프로세서 서브유닛에 연결하는 제2 복수의 버스를 포함할 수 있다. 소프트웨어를 활용한 동기화 앞서 설명한 바와 같이, 본 기재의 하드웨어 칩은 하드웨어가 아닌 소프트웨어를 활용하여 데이터 전송을 관리 할 수 있다. 특히, 버스 상의 전송, 메모리의 읽기와 쓰기, 및 프로세서 서브유닛의 계산의 타이밍이 프로세서 서브유닛에 의해 실행되는 명령의 서브시리즈에 의해 설정되기 때문에, 본 기재의 하드웨어 칩은 코드를 실행하 여 버스 상의 충돌을 방지할 수 있다. 이에 따라, 본 기재의 하드웨어 칩은 종래에 데이터 전송의 관리에 사용 되는 하드웨어 메커니즘(예, 칩 내의 네트워크 컨트롤러, 프로세서 서브유닛 간의 패킷 파서(packet parser) 및 패킷 전송기(packet transferor), 버스 아비터, 중재를 피하기 위한 복수의 버스 등)을 회피할 수 있다. 본 기재의 하드웨어 칩이 종래의 방식으로 데이터를 전송한다면, N 프로세서 서브유닛을 버스에 연결하려면 아 비터에 의해 제어되는 광범위한 MUX 또는 버스 중재가 필요할 것이다. 반면, 앞서 설명한 바와 같이, 본 기재의 실시예는 프로세서 서브유닛 사이에 오직 회선, 광케이블 등인 버스를 사용할 수 있고, 프로세서 서브유닛은 개 별적으로 코드를 실행하여 버스 상의 충돌을 방지할 수 있다. 이에 따라, 본 기재의 실시예는 기판 상의 공간을 보존할 수 있을 뿐만 아니라 (중재에 의한 전력 및 시간 소비로 인한) 재료 비용과 효율 저하를 줄일 수 있다. FIFO(first-in-first-out) 컨트롤로 및/또는 메일박스를 사용하는 다른 아키텍처와 비교하면 효율성과 공간의 이점이 더욱 크다. 또한, 앞서 설명한 바와 같이, 각 프로세서 서브유닛은 하나 이상의 처리 소자 외에도 하나 이상의 가속기를 포 함할 수 있다. 일부 실시예에서, 처리 소자가 아니라 가속기가 버스의 읽기와 쓰기를 할 수 있다. 이러한 실시 예에서, 처리 소자가 하나 이상의 계산을 수행하는 사이클과 동일한 사이클 동안에 가속기가 데이터를 전송하게 함으로써 효율성이 추가적으로 확보될 수 있다. 그러나 이러한 실시예는 가속기에 대한 추가적인 재료를 필요로 한다. 예를 들어, 가속기의 제조를 위해 트랜지스터가 추가적으로 필요할 수 있다. 코드는 또한 프로세서 서브유닛(예, 처리 소자 및/또는 프로세서 서브유닛의 일부를 형성하는 가속기)의 타이밍 과 지연을 포함하는 내부 동작에 대처할 수 있다. 예를 들면, 컴파일러(하기에 설명)는 데이터 전송을 제어하는 명령의 서브시리즈를 생성하는 경우의 타이밍과 지연에 대처하는 프리프로세싱(pre-processing)을 수행할 수 있 다. 일례에서, 복수의 프로세서 서브유닛은 이전 계층의 더 많은 복수의 뉴런에 완전히 연결된 복수의 뉴런을 포함 하는 신경망 계층을 계산하는 작업이 배정될 수 있다. 복수의 프로세서 서브유닛 사이에 이전 계층의 데이터가 균일하게 퍼져있다고 가정할 때, 상기 계산을 수행하는 한가지 방법은 각 프로세서 서브유닛이 이전 계층의 데 이터를 메인 버스로 차례로 전송하도록 설정하는 것일 수 있고, 그러면 각 프로세서 서브유닛은 프로세서 서브 유닛이 구현하는 해당 뉴런의 가중치로 이 데이터를 곱할 것이다. 각 프로세서 서브유닛은 하나 이상의 뉴런을 계산하므로, 각 프로세서 서브유닛은 이전 계층의 데이터를 뉴런의 수만큼 전송할 것이다. 따라서, 프로세서 서 브유닛은 서로 다른 시간에 전송하게 될 것이므로, 각 프로세서 서브유닛의 코드는 다른 프로세서 서브유닛의 코드와 동일하지 않다. 일부 실시예에서, 분산 프로세서는 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이가 배치된 기판(예, 실리 콘과 같은 반도체 기판 및/또는 연성회로기판과 같은 회로 기판) 및 상기 기판에 배치되고 도 7a와 도 7b 등에 도시된 것과 같은 복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이를 포함할 수 있다. 앞서 설명한 바와 같이, 각각의 프로세서 서브유닛은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 연관될 수 있다. 또한, 도 7a와 도 7b 등에 도시된 것과 같이, 분산 프로세서는 각각 복수의 프로세서 서브유닛의 하나 를 복수의 프로세서 서브유닛의 적어도 다른 하나에 연결하는 복수의 버스를 더 포함할 수 있다. 앞서 설명한 바와 같이, 복수의 버스는 소프트웨어로 제어될 수 있다. 이에 따라, 복수의 버스는 타이밍 하드웨 어 로직 요소가 없어서 프로세서 서브유닛 사이의 데이터 전송과 복수의 버스의 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않을 수 있다. 일례에서, 복수의 버스는 버스 아비터가 없 어서 프로세서 서브유닛 사이의 데이터 전송과 복수의 버스의 상응하는 버스를 통한 데이터 전송은 버스 아비터 에 의해 제어되지 않을 수 있다. 일부 실시예에서, 도 7a와 도 7b 등에 도시된 것과 같이, 분산 프로세서는 복수의 프로세서 서브유닛을 상응하 는 전용 메모리 뱅크에 연결하는 제2 복수의 버스를 더 포함할 수 있다. 앞서 설명한 복수의 버스와 유사하게, 제2 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛과 상응하는 전용 메모리 뱅크 사이 의 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않을 수 있다. 일례에서, 제2 복수의 버스는 버 스 아비터가 없어서 프로세서 서브유닛과 상응하는 전용 메모리 뱅크 사이의 데이터 전송은 버스 아비터에 의해 제어되지 않을 수 있다. 본 기재에서, '없다.'라는 표현은 타이밍 하드웨어 로직 요소(예, 버스 아비터, 중재 구조, FIFO 컨트롤러, 메 일박스 등)가 절대적으로 없음을 반드시 의미하는 것이 아니다. 이러한 요소는 이러한 요소가 '없다.'라고 설명 된 하드웨어 칩에 여전히 포함되어 있을 수 있다. 오히려, '없다.'라는 표현은 하드웨어 칩의 기능을 말하는 것 이다. 즉, 타이밍 하드웨어 로직 요소가 '없는' 하드웨어 칩은 타이밍 하드웨어 로직 요소를 사용하지 않고 하 드웨어 칩의 데이터 전송의 타이밍을 제어한다. 예를 들어, 하드웨어 칩이 실행 코드의 오류로 인한 충돌로부터 의 보호를 위한 2차 예방책으로 타이밍 하드웨어 로직 요소를 포함하더라도, 하드웨어 칩은 하드웨어 칩의 프로 세서 서브유닛 사이의 데이터 전송을 제어하는 명령의 서브시리즈를 포함하는 코드를 실행한다. 앞서 설명한 바와 같이, 복수의 버스는 복수의 프로세서 서브유닛의 상응하는 프로세서 서브유닛 사이에 회선 및 광섬유의 적어도 하나를 포함할 수 있다. 이에 따라, 일례에서, 타이밍 하드웨어 로직 요소가 없는 분산 프 로세서는 버스 아비터, 중재 구조, FIFO 컨트롤러, 메일박스 등이 없이 회선 또는 광섬유만을 포함할 수 있다. 일부 실시예에서, 복수의 프로세서 서브유닛은 복수의 프로세서 서브유닛에 의해 실행되는 코드에 따라 복수의 버스의 적어도 하나를 통해 데이터를 전송하도록 구성된다. 이에 따라, 앞서 설명한 바와 같이, 컴파일러는 각 각 단일 프로세서 서브유닛에 의해 실행되는 코드를 포함하는 명령의 서브시리즈를 정리할 수 있다. 명령의 서 브시리즈는 프로세서 서브유닛에 언제 버스 중의 하나로 데이터를 전송할지와 언제 버스로부터 데이터를 가져올 지를 지시할 수 있다. 서브시리즈가 분산 프로세서에 걸쳐 협력하여 실행되는 경우, 프로세서 서브유닛 사이의 전송의 타이밍은 서브시리즈에 포함된 전송과 회수 명령에 의해 통제될 수 있다. 따라서, 코드는 복수의 버스의 적어도 하나를 통한 데이터 전송의 타이밍을 통제한다. 컴파일러는 단일 프로세서 서브유닛에 의해 실행될 코드 를 생성할 수 있다. 또한, 컴파일러는 프로세서 서브유닛의 그룹에 의해 실행될 코드를 생성할 수 있다. 일부의 경우, 컴파일러는 모든 프로세서 서브유닛을 마치 하나의 슈퍼프로세서(예, 분산 프로세서)인 것처럼 취급할 수 있고, 컴파일러는 이렇게 정의된 슈퍼프로세서/분산 프로세서에 의해 실행될 코드를 생성할 수 있다. 앞서 설명하고 도 7a와 도 7b에 도시된 바와 같이, 복수의 프로세서 서브유닛은 메모리 어레이 내의 복수의 이 산 메모리 뱅크 사이에 공간적으로 분포될 수 있다. 또는, 복수의 프로세서 서브유닛은 기판의 하나 이상의 영 역에서 클러스터링 될 수 있고, 복수의 메모리 뱅크는 기판의 하나 이상의 다른 영역에서 클러스터링 될 수 있 다. 일부 실시예에서, 앞서 설명한 바와 같이, 공간적 분포와 클러스터링의 조합이 사용될 수 있다. 일부 실시예에서, 분산 프로세서는 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이가 배치된 기판(예, 실리 콘과 같은 반도체 기판 및/또는 연성회로기판과 같은 회로 기판)을 포함할 수 있다. 프로세싱 어레이는 또한 상 기 기판에 배치되고 도 7a와 도 7b 등에 도시된 것과 같은 복수의 프로세서 서브유닛을 포함할 수 있다. 앞서 설명한 바와 같이, 각각의 프로세서 서브유닛은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅 크와 연관될 수 있다. 또한, 도 7a와 도 7b 등에 도시된 것과 같이, 분산 프로세서는 각각 복수의 프로세서 서 브유닛의 하나를 복수의 이산 메모리 뱅크의 상응하는 전용 이산 메모리 뱅크에 연결하는 복수의 버스를 더 포 함할 수 있다. 앞서 설명한 바와 같이, 복수의 버스는 소프트웨어로 제어될 수 있다. 이에 따라, 복수의 버스는 타이밍 하드웨 어 로직 요소가 없어서 프로세서 서브유닛과 복수의 이산 메모리 뱅크의 상응하는 전용 이산 메모리 뱅크 사이 의 데이터 전송과 복수의 버스의 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어 되지 않을 수 있다. 일례에서, 복수의 버스는 버스 아비터가 없어서 프로세서 서브유닛 사이의 데이터 전송과 복수의 버스의 상응하는 버스를 통한 데이터 전송은 버스 아비터에 의해 제어되지 않을 수 있다. 일부 실시예에서, 도 7a와 도 7b 등에 도시된 바와 같이, 분산 프로세서는 복수의 프로세서 서브유닛의 하나를 복수의 프로세서 서브유닛의 적어도 다른 하나에 연결하는 제2 복수의 버스를 더 포함할 수 있다. 앞서 설명한 복수의 버스와 유사하게, 제2 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛과 상응하 는 전용 메모리 뱅크 사이의 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않을 수 있다. 일례에 서, 제2 복수의 버스는 버스 아비터가 없어서 프로세서 서브유닛과 상응하는 전용 메모리 뱅크 사이의 데이터 전송은 버스 아비터에 의해 제어되지 않을 수 있다. 일부 실시예에서, 분산 프로세서는 소프트웨어 타이밍 요소와 하드웨어 타이밍 요소의 조합을 사용할 수 있다. 예를 들어, 분산 프로세서는 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이가 배치된 기판(예, 실리콘과 같은 반도체 기판 및/또는 연성회로기판과 같은 회로 기판)을 포함할 수 있다. 프로세싱 어레이는 또한 상기 기 판에 배치되고 도 7a와 도 7b 등에 도시된 것과 같은 복수의 프로세서 서브유닛을 포함할 수 있다. 앞서 설명한 바와 같이, 각각의 프로세서 서브유닛은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 연 관될 수 있다. 또한, 도 7a와 도 7b 등에 도시된 것과 같이, 분산 프로세서는 각각 복수의 프로세서 서브유닛의 하나를 복수의 프로세서 서브유닛의 적어도 다른 하나에 연결하는 복수의 버스를 더 포함할 수 있다. 또한, 앞 서 설명한 바와 같이, 복수의 프로세서 서브유닛은 복수의 버스를 통한 데이터 전송의 타이밍을 제어하여 복수 의 버스의 적어도 하나 상에서의 데이터 전송의 충돌을 방지하는 소프트웨어를 실행하도록 구성될 수 있다. 이 러한 예에서, 소프트웨어는 데이터 전송의 타이밍을 제어할 수 있지만, 전송 자체는 적어도 부분적으로는 하나 이상의 하드웨어 요소에 의해 제어될 수 있다. 이러한 실시예에서, 분산 프로세서는 복수의 프로세서 서브유닛의 하나를 상응하는 전용 메모리 뱅크에 연결하 는 제2 복수의 버스를 더 포함할 수 있다. 앞서 설명한 복수의 버스와 유사하게, 복수의 프로세서 서브유닛은 제2 복수의 버스를 통한 데이터 전송의 타이밍을 제어하여 제2 복수의 버스의 적어도 하나 상에서의 데이터 전 송의 충돌을 방지하는 소프트웨어를 실행하도록 구성될 수 있다. 이러한 예에서, 앞서 설명한 바와 같이, 소프 트웨어는 데이터 전송의 타이밍을 제어할 수 있지만, 전송 자체는 적어도 부분적으로는 하나 이상의 하드웨어 요소에 의해 제어될 수 있다. 코드의 분할 앞서 설명한 바와 같이, 본 기재의 하드웨어 칩은 하드웨어 칩을 형성하는 기판 상에 포함된 프로세서 서브유닛 전체에서 병렬로 코드를 실행할 수 있다. 또한, 본 기재의 하드웨어 칩은 멀티태스킹을 수행할 수 있다. 예를 들면, 본 기재의 하드웨어 칩은 영역 멀티태스킹을 수행할 수 있다. 즉, 하드웨어 칩의 프로세서 서브유닛의 한 그룹은 한 작업(예, 오디오 프로세싱)을 실행하고, 하드웨어 칩의 프로세서 서브유닛의 다른 그룹은 다른 작업 (예, 이미지 프로세싱)을 실행할 수 있다. 다른 예에서, 본 기재의 하드웨어 칩은 타이밍 멀티태스킹을 수행할 수 있다. 즉, 하드웨어 칩의 하나 이상의 프로세서 서브유닛은 제1시간 주기 동안에 한 작업을 실행하고 제2시 간 주기 동안에는 다른 작업을 실행할 수 있다. 영역 멀티태스킹과 타이밍 멀티태스킹의 조합도 사용되어 제1시 간 주기 동안에 한 작업이 제1그룹의 프로세서 서브유닛에 배정되고 제1시간 주기 동안에 다른 작업이 제2그룹의 프로세서 서브유닛에 배정된 후에 제2시간 주기 동안에 제3 작업이 제1그룹과 제2그룹에 포함된 프로세서 서 브유닛에 배정될 수 있다. 본 기재의 메모리 칩 상의 실행을 위한 머신 코드를 정리하기 위하여, 머신 코드는 메모리 칩의 프로세서 서브 유닛 사이에서 분할될 수 있다. 예를 들어, 메모리 칩 상의 프로세서는 기판 및 기판 상에 배치된 복수의 프로 세서 서브유닛을 포함할 수 있다. 메모리 칩은 기판 상에 배치된 상응하는 복수의 메모리 뱅크를 더 포함할 수 있고, 여기서, 복수의 프로세서 서브유닛의 각각은 복수의 프로세서 서브유닛의 어느 프로세서 서브유닛에도 공 유되지 않는 적어도 하나의 전용 메모리 뱅크에 연결될 수 있다. 메모리 칩 상의 각 프로세서 서브유닛은 다른 프로세서 서브유닛과 별개로 일련의 명령을 실행하도록 구성될 수 있다. 각 일련의 명령은 일련의 명령을 정의 하는 코드에 따라 프로세서 서브유닛의 하나 이상의 일반 처리 소자를 설정 및/또는 일련의 명령을 정의하는 코 드 내에 제공된 시퀀스에 따라 프로세서 서브유닛의 하나 이상의 특별 처리 소자(예, 하나 이상의 가속기)를 활 성화하여 실행될 수 있다. 이에 따라, 각 일련의 명령은 단일 프로세서 서브유닛에 의해 수행될 일련의 작업을 정의할 수 있다. 단일 작업 은 프로세서 서브유닛 내의 하나 이상의 처리 소자의 아키텍처에 의해 정의된 명령 세트 이내의 명령을 포함할 수 있다. 예를 들어, 프로세서 서브유닛은 특정 레지스터(register)를 포함할 수 있고, 단일 작업은 레지스터로 데이터 푸쉬(push), 레지스터로부터 데이터 풀(pull), 레지스터 이내의 데이터에 대한 산술 연산의 수행, 레지 스터 이내의 데이터에 대한 논리 연산의 수행 등을 할 수 있다. 또한, 프로세서 서브유닛은 0-피연산자 (operand) 프로세서 서브유닛('스택 머신(stack machine)'으로도 지칭), 1-피연산자 프로세서 서브유닛(어큐뮬 레이터 머신(accumulator machine)으로도 지칭), 2-연산자 프로세서 서브유닛(RISC 등), 3-연산자 프로세서 서 브유닛(CISC(complex instruction set computer)) 등과 같이 여러 수의 피연산자에 대해 구성될 수 있다. 다른 예에서, 프로세서 서브유닛은 하나 이상의 가속기를 포함할 수 있고, 단일 작업은 가속기를 활성화하여 MAC 함 수, MAX 함수, MAX-0 함수 등과 같은 특정 함수를 수행할 수 있다. 일련의 명령은 메모리 칩의 전용 메모리 뱅크로부터 읽기와 쓰기를 하기 위한 작업을 더 포함할 수 있다. 예를 들어, 작업은 이 작업을 실행하는 프로세서 서브유닛 전용의 메모리 뱅크에 데이터 하나를 쓰는 작업, 이 작업 을 실행하는 프로세서 서브유닛 전용의 메모리 뱅크에서 데이터 하나를 읽는 작업 등을 포함할 수 있다. 일부 실시예에서, 읽기와 쓰기는 메모리 뱅크의 컨트롤러와 협력하여 프로세서 서브유닛에 의해 수행될 수 있다. 예 를 들어, 프로세서 서브유닛은 읽기 또는 쓰기를 수행하라는 제어 신호를 컨트롤러에 전송하여 읽기 또는 쓰기 작업을 실행할 수 있다. 일부 실시예에서, 제어 신호는 읽기와 쓰기에 사용할 특정 어드레스를 포함할 수 있다. 또는 프로세서 서브유닛은 읽기와 쓰기를 위해 사용할 수 있는 어드레스의 선택을 메모리 컨트롤러에 맡길 수 있다. 추가적으로 또는 대안적으로, 읽기와 쓰기는 하나 이상의 가속기가 메모리 뱅크의 컨트롤러와 협력하여 수행될 수 있다. 예를 들어, 가속기는 앞서 설명한 프로세서 서브유닛이 제어 신호를 생성하는 것과 유사하게 메모리 컨트롤러에 대한 제어 신호를 생성할 수 있다. 상기에 설명한 실시예에서, 어드레스 생성기를 사용하여 메모리 뱅크의 특정 어드레스로 읽기와 쓰기를 지시할 수도 있다. 예를 들어, 어드레스 생성기는 읽기와 쓰기를 위한 메모리 어드레스를 생성하도록 구성된 처리 소자 를 포함할 수 있다. 어드레스 생성기는 추후 계산의 결과를 더 이상 필요가 없는 이전 계산의 결과의 어드레스 와 같은 어드레스로 쓰는 등을 통하여 효율성을 향상하기 위하여 어드레스를 생성하도록 구성될 수 있다. 이에 따라, 어드레스 생성기는 프로세서 서브유닛으로부터의(예, 프로세서 서브유닛에 포함된 처리 소자 또는 하나 이상의 가속기로부터의) 명령에 대응하여 또는 프로세서 서브유닛과 협력하여 메모리 컨트롤러에 대한 제어 신 호를 생성할 수 있다. 추가적으로 또는 대안적으로, 어드레스 생성기는, 예를 들어, 특정 패턴에서 메모리 내의 특정 어드레스에 대해 반복하는 중첩 루프(nested loop) 구조를 생성하는 일부 설정 또는 레지스터에 의거하여 어드레스를 생성할 수 있다. 일부 실시예에서, 각 일련의 명령은 상응하는 일련의 작업을 정의하는 머신 코드 세트를 포함할 수 있다. 이에 따라, 상기 일련의 작업은 일련의 명령을 포함하는 머신 코드 내에 압축될 수 있다. 일부 실시예에서, 하기에 도 8을 참조하여 설명하는 바와 같이, 일련의 작업은 복수의 논리 회로 중의 고수준(higher-level)의 일련의 작 업을 복수의 일련의 작업으로 분포하도록 구성된 컴파일러에 의해 정의될 수 있다. 예를 들어, 컴파일러는 고수 준의 일련의 작업에 의거하여 복수의 일련의 작업을 생성하여 각각 상응하는 일련의 작업을 함께 실행하는 프로 세서 서브유닛이 고수준의 일련의 작업이 서술한 것과 같은 함수를 수행할 수 있다. 하기에 설명하는 바와 같이, 고수준의 일련의 작업은 인간-판독 가능 프로그래밍 언어로 된 명령 세트를 포함할 수 있다. 이에 상응하여, 각 프로세서 서브유닛에 대한 일련의 작업은 머신 코드로 된 명령 세트를 각각 포함하 는 저수준(lower-level)의 일련의 작업을 포함할 수 있다. 앞서 도 7a와 도 7b를 참조하여 설명한 바와 같이, 메모리 칩은 복수의 프로세서 서브유닛의 하나를 복수의 프 로세서 서브유닛의 적어도 다른 하나에 각각 연결하는 복수의 버스를 더 포함할 수 있다. 또한, 앞서 설명한 바 와 같이, 복수의 버스 상의 데이터 전송은 소프트웨어를 사용하여 제어될 수 있다. 이에 따라, 복수의 버스의 적어도 하나를 통한 데이터 전송은 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛에 포함된 일련의 명 령에 의해 미리 정해질 수 있다. 따라서, 일련의 명령에 포함된 작업 중의 하나는 버스 중의 하나로 데이터를 출력하는 작업 또는 버스 중의 하나로부터 데이터를 가져오는 작업을 포함할 수 있다. 이러한 작업은 프로세서 서브유닛의 처리 소자 또는 프로세서 서브유닛에 포함된 하나 이상의 가속기에 의해 실행될 수 있다. 후자의 실 시예에서, 프로세서 서브유닛은 가속기가 버스 중의 하나로부터 데이터를 가져오거나 버스 중의 하나로 데이터 를 배치하는 사이클과 같은 사이클에서 계산을 수행하거나 상응하는 메모리 뱅크로 제어 신호를 전송할 수 있다. 일례에서, 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛에 포함된 일련의 명령은 복수의 버스의 적어 도 하나에 연결된 프로세서 서브유닛이 복수의 버스의 적어도 하나로 데이터를 쓰게 하는 명령을 포함하는 전송 작업을 포함할 수 있다. 추가적으로 또는 대안적으로, 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛 에 포함된 일련의 명령은 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛이 복수의 버스의 적어도 하나 로부터 데이터를 읽게 하는 명령을 포함하는 수신 작업을 포함할 수 있다. 프로세서 서브유닛 사이의 코드 분산에 추가적으로 또는 대안적으로, 데이터는 메모리 칩의 메모리 뱅크 사이에 분할될 수 있다. 예를 들어, 앞서 설명한 바와 같이, 메모리 칩 상의 분산 프로세서는 메모리 칩 상에 배치된 복수의 프로세서 서브유닛과 메모리 칩 상에 배치된 복수의 메모리 뱅크를 포함할 수 있다. 복수의 메모리 뱅크 의 각 메모리 뱅크는 복수의 메모리 뱅크의 다른 메모리 뱅크에 저장된 데이터와 별개인 데이터를 저장하도록 구성될 수 있고, 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 복수의 메모리 뱅크 중에서 적어도 하나 의 전용 메모리 뱅크에 연결될 수 있다. 예를 들어, 각 프로세서 서브유닛은 그 프로세서 서브유닛 전용의 하나 이상의 상응하는 메모리 뱅크의 하나 이상의 메모리 컨트롤러에 접근할 수 있고, 다른 어떤 프로세서 서브유닛 도 이러한 상응하는 하나 이상의 메모리 컨트롤러에 접근할 수 없을 수 있다. 이에 따라, 메모리 뱅크 사이에 공유될 수 있는 메모리 컨트롤러가 없기 때문에 각 메모리 뱅크에 저장된 데이터는 다른 메모리 뱅크에 저장된 메모리와 별개일 수 있다. 일부 실시예에서, 하기에 도 8을 참조하여 설명하는 바와 같이, 복수의 메모리 뱅크 각각에 저장된 데이터는 복 수의 메모리 뱅크 사이에 데이터를 분산하도록 구성된 컴파일러에 의해 정의될 수 있다. 또한, 컴파일러는 상응 하는 프로세서 서브유닛에 분산된 복수의 저수준 작업을 이용하여 고수준의 일련의 작업에서 정의된 데이터를 복수의 메모리 뱅크에 분산하도록 구성될 수 있다. 하기에 더 설명하는 바와 같이, 고수준의 일련의 작업은 인간-판독 가능 프로그래밍 언어로 된 명령 세트를 포 함할 수 있다. 이에 상응하여, 각 프로세서 서브유닛에 대한 일련의 작업은 머신 코드로 된 명령 세트를 각각 포함하는 저수준의 일련의 작업을 포함할 수 있다. 앞서 도 7a와 도 7b를 참조하여 설명한 바와 같이, 메모리 칩은 복수의 프로세서 서브유닛의 하나를 복수의 메 모리 뱅크 중의 하나 이상의 상응하는 전용 메모리 뱅크에 각각 연결하는 복수의 버스를 더 포함할 수 있다. 또 한, 앞서 설명한 바와 같이, 복수의 버스 상의 데이터 전송은 소프트웨어를 활용하여 제어될 수 있다. 이에 따 라, 복수의 버스중 특정 버스를 통한 데이터 전송은 복수의 버스중 특정 버스에 연결된 상응하는 프로세서 서브 유닛에 의해 제어될 수 있다. 따라서, 일련의 명령에 포함된 작업의 하나는 버스 중의 하나로 데이터를 출력하 는 작업 또는 버스 중의 하나로부터 데이터를 가져오는 작업을 포함할 수 있다. 앞서 설명한 바와 같이, 이러한 작업은 (i) 프로세서 서브유닛의 처리 소자 또는 (ii) 프로세서 서브유닛에 포함된 하나 이상의 가속기에 의해 실행될 수 있다. 후자의 실시예에서, 프로세서 서브유닛은 가속기가 하나 이상의 상응하는 전용 메모리 뱅크에 연결된 버스 중의 하나로부터 데이터를 가져오거나 하나 이상의 상응하는 전용 메모리 뱅크에 연결된 버스 중의 하나로 데이터를 배치하는 사이클과 같은 사이클에서 계산을 수행하거나 프로세서 서브유닛을 다른 프로세서 서 브유닛에 연결하는 버스를 사용할 수 있다. 따라서, 일례에서, 복수의 버스의 적어도 하나로 연결된 프로세서 서브유닛에 포함된 일련의 명령은 전송 작업 을 포함할 수 있다. 전송 작업은 하나 이상의 상응하는 전용 메모리 뱅크에 저장할 데이터를 복수의 버스의 적 어도 하나에 연결된 프로세서 서브유닛이 복수의 버스의 적어도 하나로 쓰게 하는 명령을 포함할 수 있다. 추가적으로 또는 대안적으로, 복수의 버스의 적어도 하나로 연결된 프로세서 서브유닛에 포함된 일련의 명령은 수신 작업을 포함할 수 있다. 수신 작업은 하나 이상의 상응하는 전용 메모리 뱅크에 저장할 데이터를 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛이 복수의 버스의 적어도 하나로부터 읽게 하는 명령을 포함할 수 있다. 이에 따라, 이러한 실시예의 전송 및 수신 작업은 하나 이상의 상응하는 전용 메모리 뱅크의 하나 이상의 메모리 컨트롤러로 복수의 버스의 적어도 하나를 따라 전송되는 제어 신호를 포함할 수 있다. 또한, 전송 및 수 신 작업은 프로세서 서브유닛의 다른 부분(프로세서 서브유닛의 하나 이상의 다른 가속기)에 의해 실행되는 계 산 또는 기타 작업과 동시에 프로세서 서브유닛의 일 부분(예, 프로세서 서브유닛의 하나 이상의 가속기)에 의 해 실행될 수 있다. 이러한 동시 실행의 일례에는 수신, 곱셈, 및 전송이 함께 실행되는 MAC-릴레이(relay) 명 령이 포함될 수 있다. 메모리 뱅크 간의 데이터 분산 외에도, 특정 부분의 데이터가 서로 다른 메모리 뱅크에 복제될 수 있다. 예를 들어, 앞서 설명한 바와 같이, 메모리 칩 상의 분산 프로세서는 메모리 칩 상에 배치된 복수의 프로세서 서브유 닛과 메모리 칩 상에 배치된 복수의 메모리 뱅크를 포함할 수 있다. 복수의 프로세서 서브유닛의 각각은 복수의 메모리 뱅크 중의 적어도 하나의 전용 메모리 뱅크로 연결될 수 있고, 복수의 메모리 뱅크의 각 메모리 뱅크는 복수의 메모리 뱅크의 다른 메모리 뱅크에 저장된 데이터와 별개인 데이터를 저장하도록 구성될 수 있다. 또한, 복수의 메모리 뱅크 중의 하나의 특정 메모리 뱅크에 저장된 데이터의 적어도 일부는 복수의 메모리 뱅크의 적 어도 다른 하나의 메모리 뱅크에 저장된 데이터의 복제본을 포함할 수 있다. 예를 들어, 일련의 명령에 사용되 는 데이터의 번호, 문자열, 또는 기타 유형이 한 메모리 뱅크에서 메모리 칩의 다른 프로세서 서브유닛으로 전 송되기보다는 서로 다른 프로세서 서브유닛의 전용인 복수의 메모리 뱅크에 저장될 수 있다. 일례에서, 병렬 문자열 매칭(parallel string matching)은 앞서 설명한 데이터 복제를 활용할 수 있다. 예를 들 어, 복수의 문자열은 동일한 문자열에 비교될 수 있다. 기존의 프로세서는 복수의 문자열의 각 문자열을 동일 스트링과 순차 비교할 것이다. 본 기재의 하드웨어 칩에서는, 동일 문자열이 메모리 뱅크 전반에 걸쳐 복제되어 프로세서 서브유닛이 복수의 문자열의 개별 문자열을 복제된 문자열과 병렬 비교할 수 있도록 할 수 있다. 일부 실시예에서, 하기에 도 8을 참조하여 설명하는 바와 같이, 복수의 메모리 뱅크 중의 하나의 특정 메모리 뱅크 및 복수의 메모리 뱅크의 적어도 다른 하나에 복제된 일부 데이터는 메모리 뱅크에 데이터를 복제하도록 구성된 컴파일러에 의해 정의된다. 또한, 컴파일러는 상응하는 프로세서 서브유닛에 분산된 복수의 저수준 작업 을 이용하여 적어도 일부 데이터를 복제하도록 구성될 수 있다. 데이터의 복제는 데이터의 동일 부분을 다른 계산에 재사용하는 작업에 유용할 수 있다. 데이터의 이런 부분을 복제함으로써, 이러한 계산이 메모리 뱅크의 프로세서 서브유닛에 분산되어 병렬 실행될 수 있는 반면, 각 프로 세서 서브유닛은 (프로세서 서브유닛을 연결하는 버스를 통해 데이터의 이런 부분을 푸쉬(pushing) 및 풀(pull 하지 않고) 데이터의 이런 부분을 전용 메모리 뱅크에 저장하고 전용 메모리 뱅크에서 저장된 부분에 접근할 수 있다. 일례에서, 복수의 메모리 뱅크의 하나의 특정 메모리 뱅크와 복수의 메모리 뱅크의 적어도 하나의 다른 메모리 뱅크에 복제된 일부 데이터는 신경망의 가중치를 포함할 수 있다. 이러한 예에서, 신경망의 각 노드는 복수의 프로세서 서브유닛의 적어도 한 프로세서 서브유닛에 의해 정의될 수 있다. 예를 들어, 각 노드는 이 노 드를 정의하는 적어도 하나의 프로세서 서브유닛에 의해 실행되는 머신 코드를 포함할 수 있다. 이러한 예에서, 가중치를 복제하면 각 프로세서 서브유닛이 (다른 프로세서 서브유닛과의 데이터 전송을 수행하지 않고) 하나 이상의 전용 메모리 뱅크에만 접근하면서 머신 코드를 실행하여 상응하는 노드에 적어도 부분적으로 작용할 수 있다. 전용 메모리에 대한 읽기와 쓰기 타이밍은 다른 프로세서 서브유닛과 별개인 반면에 프로세서 서브유닛 사이의 데이터 전송은 타이밍 동기화(앞서 설명한 바와 같이 소프트웨어를 활용)가 필요하므로, 메모리의 복제 를 통해 프로세서 서브유닛 사이의 데이터 전송을 안 해도 되면 전체적인 실행이 더욱 효율적이 될 수 있다. 앞서 도 7a와 도 7b를 참조하여 설명한 바와 같이, 메모리 칩은 복수의 프로세서 서브유닛의 하나를 복수의 메 모리 뱅크의 하나 이상의 상응하는 전용 메모리 뱅크에 각각 연결하는 복수의 버스를 포함할 수 있다. 또한, 앞 서 설명한 바와 같이, 복수의 버스 상의 데이터 전송은 소프트웨어를 이용하여 제어될 수 있다. 이에 따라, 복 수의 버스의 특정 버스를 통한 데이터 전송은 복수의 버스의 특정 버스에 연결된 상응하는 프로세서 서브유닛에 의해 제어될 수 있다. 따라서, 일련의 명령에 포함된 작업의 하나는 버스 중의 하나로 데이터를 출력하는 작업 또는 버스 중의 하나에서 데이터를 가져오는 작업을 포함할 수 있다. 앞서 설명한 바와 같이, 이러한 작업은 (i) 프로세서 서브유닛의 처리 소자 또는 (ii) 프로세서 서브유닛에 포함된 하나 이상의 가속기에 의해 실행될 수 있다. 앞서 더 설명한 바와 같이, 이러한 작업은 하나 이상의 상응하는 전용 메모리 뱅크의 하나 이상의 메 모리 컨트롤러로 복수의 버스의 적어도 하나를 따라 전송되는 제어 신호를 포함하는 전송 작업 및/또는 수신 작업을 포함할 수 있다. 도 8은 도 7a와 도 7b에 도시된 것 등과 같은 본 기재의 예시적인 메모리 칩 상에서 실행되기 위한 일련의 명령 을 컴파일 하는 방법의 순서도를 도시한 것이다. 방법은 범용 또는 전용의 기존 프로세서에 의해 구 현될 수 있다. 방법은 컴파일러를 형성하는 컴퓨터 프로그램의 일부로 실행될 수 있다. 본 기재에서, '컴파일러'는 고수 준 언어(예, C, FORTRAN, BASIC 등과 같은 절차형 언어; Java, C++, Pascal, Python 등과 같은 객체 지향 언어 등)를 저수준 언어(예, 어셈블리 코드, 오브젝트 코드, 머신 코드 등)로 변환하는 모든 컴퓨터 프로그램을 말한 다. 컴파일러는 사람으로 하여금 인간 판독 가능 언어로 일련의 명령을 프로그램 할 수 있게 해줄 수 있고, 이 러한 명령은 나중에 머신 실행 가능 언어로 변환된다. 단계 810에서, 프로세서는 일련의 명령과 연관된 작업을 프로세서 서브유닛의 서로 다른 서브유닛에 배정할 수 있다. 예를 들어, 일련의 명령은 프로세서 서브유닛에서 병렬로 실행될 소그룹으로 분할될 수 있다. 일례에서, 신경망은 노드로 분할될 수 있고, 하나 이상의 노드가 서로 다른 프로세서 서브유닛에 배정될 수 있다. 이러한 예에서, 각 소그룹은 서로 다른 계층으로 연결된 복수의 노드를 포함할 수 있다. 따라서, 프로세서 서브유닛은 신경망의 제1 계층으로부터의 노드, 동일 프로세서 서브유닛에 의해 구현된 제1 계층으로부터의 노드에 연결된 제2 계층으로부터의 노드 등을 구현할 수 있다. 각각의 연결에 의거하여 노드를 배정함으로써, 프로세서 서브유 닛 간의 데이터 전송이 적어질 수 있고, 그 결과로 앞서 설명한 바와 같이 효율성이 향상될 수 있다. 앞서 도 7a와 도 7b를 참조하여 설명한 바와 같이, 프로세서 서브유닛은 메모리 칩 상에 배치된 복수의 메모리 뱅크에 공간적으로 분산될 수 있다. 이에 따라, 작업의 배정은 논리적으로 분할될 뿐만 아니라 적어도 부분적으 로는 공간적으로 분할될 수 있다. 단계 820에서, 프로세서는 버스에 의해 각각 연결되는 메모리 칩의 프로세서 서브유닛의 쌍 사이에 데이터를 전 송하는 작업을 생성할 수 있다. 예를 들어, 앞서 설명한 바와 같이, 데이터 전송은 소프트웨어를 활용하여 제어 될 수 있다. 이에 따라, 프로세서 서브유닛은 동기화된 시간에 버스 상에서 데이터를 푸시(pushing) 및 풀 (pulling) 하도록 구성될 수 있다. 따라서, 생성된 작업은 데이터의 이러한 동기화된 푸쉬 및 풀을 수행하기 위 한 작업을 포함할 수 있다. 앞서 설명한 바와 같이, 단계 820은 프로세서 서브유닛의 타이밍과 지연을 포함하는 내부 동작에 대처하기 위한 프리프로세싱을 포함할 수 있다. 예를 들어, 프로세서는 생성된 작업이 동기화 되도록 하기 위하여 프로세서 서 브유닛의 알려진 시간과 지연(예, 버스로 데이터를 푸쉬 하는데 드는 시간, 버스로부터 데이터를 풀(pull) 하는 데 드는 시간, 계산과 푸쉬(push) 또는 풀(pull) 사이의 지연 등)을 활용할 수 있다. 따라서, 하나 이상의 프로 세서 서브유닛에 의한 적어도 하나의 푸쉬(push) 및 하나 이상의 프로세서 서브유닛에 의한 적어도 하나의 풀 (pull)을 포함하는 데이터 전송은 프로세서 서브유닛 간의 타이밍 차이, 프로세서 서브유닛의 지연 등으로 인한 지연을 발생시키지 않고 동시에 일어날 수 있다. 단계 830에서, 프로세서는 배정 및 생성된 작업을 복수의 그룹의 서브시리즈 명령으로 분류할 수 있다. 예를 들 어, 서브시리즈 명령은 각각 단일 프로세서 서브유닛에 의해 실행될 일련의 작업을 포함할 수 있다. 따라서, 복 수의 그룹의 서브시리즈 명령의 각각은 복수의 프로세서 서브유닛의 서로 다른 서브유닛에 상응할 수 있다. 이 에 따라, 단계 810, 단계 820, 및 단계 830의 결과로, 일련의 명령이 복수의 그룹의 서브시리즈 명령으로 나누 어질 수 있다. 앞서 설명한 바와 같이, 단계 820은 서로 다른 그룹 사이의 데이터 전송이 모두 동기화 되게 할 수 있다. 단계 840에서, 프로세서는 복수의 그룹의 서브시리즈 명령의 각각에 상응하는 머신 코드를 생성할 수 있다. 예 를 들어, 서브시리즈 명령을 나타내는 고수준 코드는 상응하는 프로세서 서브유닛에 의해 실행 가능한 머신 코 드와 같은 저수준 코드로 변환될 수 있다. 단계 850에서, 프로세서는 복수의 그룹의 서브시리즈 명령의 각각에 상응하는 생성된 머신 코드를 상기 분할에 따라 복수의 프로세서 서브유닛의 상응하는 프로세서 서브유닛에 배정할 수 있다. 예를 들어, 프로세서는 각 서 브시리즈 명령에 상응하는 프로세서 서브유닛의 식별자를 붙일 수 있다. 따라서, 서브시리즈 명령이 실행을 위 해 메모리 칩에 업로드 되는 경우에(예, 도 3a의 호스트에 의해), 각 서브시리즈는 적절한 프로세서 서브 유닛을 설정할 수 있다. 일부 실시예에서, 일련의 명령과 연관된 작업을 프로세서 서브유닛의 서로 다른 프로세서 서브유닛에 배정하는 것은 적어도 부분적으로는 메모리 칩 상의 둘 이상의 프로세서 서브유닛 사이의 공간적 근접성에 의존할 수 있다. 예를 들어, 앞서 설명한 바와 같이, 프로세서 서브유닛 사이의 데이터 전송의 수를 감소하면 효율성이 향상 될 수 있다. 이에 따라, 프로세서는 둘 이상의 프로세서 서브유닛을 통해 데이터를 이동하는 데이터 전송을 최 소화할 수 있다. 따라서, 프로세서는 인접 전송을 최대화하고(적어도 국부적으로) 이웃하지 않는 프로세서 서브 유닛으로의 전송을 최소화하는(적어도 국부적으로) 방식으로 서브시리즈를 프로세서 서브유닛으로 배정하기 위 하여 메모리 칩의 알려진 레이아웃을 하나 이상의 최적화 알고리즘(예, 그리디 알고리즘(greedy algorithm))과 병합하여 활용할 수 있다. 방법은 본 기재의 메모리 칩에 대한 추가적인 최적화를 포함할 수 있다. 예를 들어, 프로세서는 상기 분할 에 의거하여 일련의 명령과 연관된 데이터를 분류하고 이러한 분류에 따라 데이터를 메모리 뱅크에 배정할 수 있다. 이에 따라, 메모리 뱅크는 각 메모리 뱅크의 전용인 각 프로세서 서브유닛에 배정된 서브시리즈 명령에 사용되는 데이터를 보유할 수 있다. 일부 실시예에서, 데이터의 분류는 둘 이상의 메모리 뱅크로 복제될 데이터의 적어도 일부를 판단하는 작업을 포함할 수 있다. 예를 들어, 앞서 설명한 바와 같이, 일부 데이터는 하나 이상의 서브시리즈 명령에서 사용될 수 있다. 이러한 데이터는 서로 다른 서브시리즈 명령이 배정된 복수의 프로세서 서브유닛 전용의 메모리 뱅크 에 복제될 수 있다. 이러한 최적화는 프로세서 서브유닛 간의 데이터 전송을 더 감소시킬 수 있다. 방법의 출력은 실행을 위한 본 기재의 메모리 칩으로의 입력일 수 있다. 예를 들어, 메모리 칩은 적어도 하나의 전용 메모리 뱅크에 각각 연결된 복수의 프로세서 서브유닛과 이에 상응하는 복수의 메모리 뱅크를 포함 할 수 있고, 메모리 칩의 프로세서 서브유닛은 방법에 의해 생성된 머신 코드를 실행하도록 구성될 수 있 다. 도 3a를 참조하여 설명한 바와 같이, 호스트는 방법에 의해 생성된 머신 코드를 프로세서 서브유 닛에 입력하여 실행할 수 있다. 서브뱅크와 서브컨트롤러 기존의 메모리 뱅크에서, 컨트롤러는 뱅크 레벨에서 제공된다. 각 뱅크는 전형적으로 장방형으로 배치되지만 이 외의 기타 모든 기하 형상으로 배치될 수 있는 복수의 매트(mat)를 포함한다. 각 매트는 역시 전형적으로 장방 형으로 배치되지만 이 외의 기타 모든 기하 형상으로 배치될 수 있는 복수의 메모리 셀을 포함한다. 각 셀은 (셀이 고압 또는 저압으로 유지되는지 등에 따라) 단일 비트의 데이터를 저장할 수 있다. 이러한 기존의 아키텍처의 예가 도 9와 도 10에 도시되어 있다. 도 9에 도시된 바와 같이, 뱅크 레벨에서, 복수 의 매트(예, 매트(930-1, 930-2, 940-1, 940-2))가 뱅크를 형성할 수 있다. 기존의 장방형 구조에서, 뱅 크는 글로벌 워드라인(예, 워드라인)과 글로벌 비트라인(예, 비트라인)으로 제어될 수 있다. 이 에 따라, 로우 디코더(row decoder)는 입력되는 제어 신호(예, 어드레스에서 읽기 요청, 어드레스로 쓰기 요청 등)에 의거하여 정확한 워드라인을 선택할 수 있고, 글로벌 센스 증폭기(global sense amplifier, 920)(및 /또는 도 9에는 도시되지 않은 글로벌 컬럼 디코더)는 제어 신호에 의거하여 정확한 비트라인을 선택할 수 있다. 증폭기는 또한 읽기 동작 중에 선택된 뱅크에서 전압 레벨을 증폭할 수 있다. 도면에는 초기 선택을 위해 로우 디코더를 사용하고 열을 따라 증폭을 수행하는 것으로 도시되어 있지만, 뱅크는 추가적으로 또는 대 안적으로 컬럼 디코더(column decoder)를 사용하여 초기 선택을 하고 행을 따라 증폭을 수행할 수 있다. 도 10은 매트의 일례를 도시한 것이다. 예를 들어, 매트는 도 9의 뱅크와 같은 메모리 뱅크의 일부를 형성할 수 있다. 도 10에 도시된 바와 같이, 복수의 셀(예, 1030-1, 1030-2, 1030-3)이 매트를 형성할 수 있다. 각 셀은 커패시터, 트랜지스터, 또는 적어도 1비트의 데이터를 저장하는 기타 회로를 포함할 수 있다. 예를 들어, 셀은 하전되어 '1'을 나타내고 방전되어 '0'을 나타내는 커패시터를 포함하거나 '1'을 나 타내는 제1 상태와 '0'을 나타내는 제2 상태를 포함하는 플립플롭(flip-flop)을 포함할 수 있다. 기존의 매트는 예를 들어 512비트 x 512비트를 포함할 수 있다. 매트가 MRAM, ReRAM 등의 일부를 형성하는 실시예에서, 셀은 트랜지스터, 저항기, 커패시터, 또는 적어도 1비트의 데이터를 저장하는 물질의 이온 또는 일부를 분리하 는 기타 메커니즘을 포함할 수 있다. 예를 들어, 셀은 제1 상태가 '1'을 나타내고 제2 상태가 '0'을 나타내는 전해질 이온, 칼코겐화 유리(chalcogenide glass) 등을 포함할 수 있다. 도 10에 더 도시된 바와 같이, 기존의 장방형 구조에서, 매트는 로컬 워드라인(예, 워드라인)과 로 컬 비트라인(예, 비트라인)에 걸쳐 제어될 수 있다. 이에 따라, 워드라인 드라이버(예, 워드라인 드라이 버(1020-1, 1020-2, . . . , 1020-x))가 선택된 워드라인을 제어하여, 매트가 그 일부를 형성하는 메모 리 뱅크와 연관된 컨트롤러로부터의 제어 신호(예, 어드레스에서 읽기 요청, 어드레스로 쓰기 요청, 리프레쉬 신호 등)에 의거하여 읽기, 쓰기, 또는 리프레쉬를 수행할 수 있다. 또한, 로컬 센스 증폭기(예, 로컬 증폭기(1010-1, 1010-2, . . . , 1010-x)) 및/또는 로컬 컬럼 디코더(도 10에는 미도시)가 선택된 비트라인을 제어하 여 읽기, 쓰기, 또는 리프레쉬를 수행할 수 있다. 로컬 센스 증폭기는 또한 선택된 셀의 전압 레벨을 읽기 동작 동안에 증폭할 수 있다. 도면에는 초기 선택에 워드라인 드라이버를 사용하고 열을 따라 증폭을 수행하는 것으 로 도시되어 있지마, 매트는 초기 선택에 비트라인 드라이버를 사용하고 행을 따라 증폭을 수행할 수도 있다. 앞서 설명한 바와 같이, 많은 수의 매트가 복제되어 메모리 뱅크를 형성한다. 메모리 뱅크는 그룹으로 묶여서 메모리 칩을 형성할 수 있다. 예를 들어, 메모리 칩은 8개 내지 32개의 메모리 뱅크를 포함할 수 있다. 이에 따 라, 기존의 메모리 칩 상에서 프로세서 서브유닛과 메모리 뱅크를 페어링한 결과로 8 내지 32 프로세서 서브유 닛만이 형성된다. 이에 따라, 본 기재의 실시예는 추가적인 서브뱅크(sub-bank) 체계를 가진 메모리 칩을 포함 할 수 있다. 본 기재의 이러한 메모리 칩은 따라서 프로세서 서브유닛과 페어링 된 전용 메모리 뱅크로 사용되 는 메모리 서브뱅크를 가진 프로세서 서브유닛을 포함할 수 있다. 이에 따라, 더 많은 수의 서브프로세서(sub processor)가 가능하고, 인메모리 계산(in-memory computing)의 병렬 수행과 성능을 향상할 수 있다. 본 기재의 일부 실시예에서, 뱅크의 글로벌 로우 디코더와 글로벌 센스 증폭기는 서브뱅크 컨트롤러로 대 체할 수 있다. 이에 따라, 메모리 뱅크의 글로벌 로우 디코더와 글로벌 센스 증폭기로 제어 신호를 보내지 않고, 메모리 뱅크의 컨트롤러는 제어 신호를 적합한 서브뱅크 컨트롤러로 보낼 수 있다. 제어 신호를 보내는 방향은 동적으로 제어되거나 하드웨어에 내장(예, 하나 이상의 논리 게이트를 통해)될 수 있다. 일부 실시예에 서, 퓨즈를 사용하여 각 서브뱅크 또는 매트의 컨트롤러가 제어 신호를 해당 서브뱅크 또는 매트로 통과시키거 나 차단하도록 지시할 수 있다. 따라서, 이러한 실시예에서, 퓨즈를 사용하여 불량 서브뱅크가 비활성화될 수 있다. 이러한 실시예의 일례에서, 메모리 칩은 복수의 메모리 뱅크를 포함할 수 있고, 각 메모리 뱅크는 뱅크 컨트롤 러와 복수의 메모리 서브뱅크를 포함할 수 있고, 각 메모리 서브뱅크는 메모리 서브뱅크 상의 각 위치로 읽기와 쓰기가 가능하도록 하는 서브뱅크 로우 디코더와 서브뱅크 컬럼 디코더를 포함할 수 있다. 각 서브뱅크는 복수 의 메모리 매트를 포함할 수 있고, 각 메모리 매트는 복수의 메모리 셀을 포함할 수 있고 내부적으로 로컬인 로 우 디코더, 컬럼 디코더, 및/또는 로컬 센스 증폭기를 포함할 수 있다. 서브뱅크 로우 디코더와 서브뱅크 컬럼 디코더는 뱅크 컨트롤러의 읽기 및 쓰기 요청 또는 하기에 설명하는 서브뱅크 메모리 상의 메모리 내 계산에 사 용되는 서브뱅크 프로세서 서브유닛의 읽기 및 쓰기 요청을 처리할 수 있다. 추가적으로, 각 메모리 서브뱅크는 뱅크 컨트롤러의 읽기 요청과 쓰기 요청을 처리할지 여부 및/또는 이러한 요청을 다음 레벨(예, 매트 상의 로우 디코더 및 컬럼 디코더의 레벨)로 송부할지 또는 이러한 요청을 차단할지, 예를 들어, 내부 처리 소자 또는 프 로세서 서브유닛이 메모리에 접근하게 허용할지, 여부를 판단하도록 구성된 컨트롤러를 더 포함할 수 있다. 일 부 실시예에서, 뱅크 컨트롤러는 시스템 클럭(system clock)에 동기화될 수 있다. 그러나 서브뱅크 컨트롤러는 시스템 클럭에 동기화되지 않을 수 있다. 앞서 설명한 바와 같이, 서브뱅크를 사용하면, 프로세서 서브유닛이 기존 칩의 메모리 뱅크와 쌍을 이룬 경우보 다 더 많은 수의 프로세서 서브유닛을 메모리 칩에 포함시킬 수 있다. 이에 따라, 각 서브뱅크는 서브뱅크를 전 용 메모리로 사용하는 프로세서 서브유닛을 더 포함할 수 있다. 앞서 설명한 바와 같이, 프로세서 서브유닛은 RISC, CISC, 또는 기타 범용 프로세서 서브유닛을 포함 및/또는 하나 이상의 가속기를 포함할 수 있다. 또한, 프로세서 서브유닛은 앞서 설명한 바와 같이 어드레스 생성기를 포함할 수 있다. 앞서 설명한 모든 실시예에서, 각 프로세서 서브유닛은 뱅크 컨트롤러를 사용하지 않고 서브뱅크의 로우 디코더와 컬럼 디코더를 사용하여 프 로세서 서브유닛 전용의 서브뱅크에 접근하도록 구성될 수 있다. 서브 뱅크와 연관된 프로세서 서브유닛은 또한 메모리 매트를 취급(하기에 설명하는 디코더 및 메모리 중복 메커니즘 포함) 및/또는 상위 레벨(예, 뱅크 레벨 또는 메모리 레벨)의 읽기 및 쓰기 요청이 이에 부응하여 전송 및 취급되는지 여부를 판단할 수 있다. 일부 실시예에서, 서브뱅크 컨트롤러는 서브뱅크의 상태를 저장하는 레지스터를 더 포함할 수 있다. 이에 따라, 서브뱅크가 사용중인 것으로 레지스터가 나타내는 가운데 서브뱅크 컨트롤러가 메모리 컨트롤러로부터 제어 신 호를 수신하는 경우에, 서브뱅크 컨트롤러는 오류임을 출력할 수 있다. 각 서브뱅크가 프로세서 서브유닛을 더 포함하는 실시예에서, 서브뱅크의 프로세서 서브유닛이 메모리 컨트롤러로부터의 외부 요청에 상충하여 메모리 에 접근하는 경우, 레지스터는 오류임을 나타낼 수 있다. 도 11은 서브뱅크 컨트롤러를 사용하는 메모리 뱅크의 다른 실시예의 일례를 도시한 것이다. 도 11의 예에서, 뱅크는 로우 디코더, 뱅크 디코더, 및 서브뱅크 컨트롤러(예, 컨트롤러(1130a, 1130b, 1130c))가 있는 복수의 메모리 서브뱅크(예, 서브뱅크(1170a, 1170b, 1170c))를 포함한다. 서브뱅크 컨트롤러는 서브뱅크 컨트롤러의 제어를 받는 하나 이상의 서브뱅크로 요청을 전달할지 여부를 판단할 수 있는 어드레스 리졸버(address resolver; 예, 리졸버(1140a, 1140b, 1140c))를 포함할 수 있다. 서브뱅크 컨트롤러는 하나 이상의 논리 회로(예, 회로(1150a, 1150b, 1150c))를 더 포함할 수 있다. 예를 들어, 하나 이상의 처리 소자를 포함하는 논리 회로는 서브뱅크의 셀을 리프레쉬하는 동작, 서브뱅크의 셀을 비우는 동작 등과 같은 하나 이상의 동작이 뱅크의 외부에서 요청을 처리하지 않고 수행되도록 할 수 있다. 또는, 논리 회로는 앞서 설명한 바와 같은 프로세서 서브유닛을 포함하여 서브뱅크 컨트롤러에 의해 제어되는 모든 서브뱅크가 프로세서 서브유닛의 상응하는 전용 메모리가 되도록 할 수 있다. 도 11의 예에서, 논리 (1150a)의 상응하는 전용 메모리는 서브뱅크(1170a)이고, 논리(1150b)의 상응하는 전용 메모리는 서브뱅크 (1170b)이고, 논리(1150c)의 상응하는 전용 메모리는 서브뱅크(1170c)이다. 앞서 설명한 모든 실시예에서, 논리 회로에는 서브뱅크로 연결하는 버스, 예를 들어, 버스(1131a, 1131b, 1131c)가 있다. 도 11에 도시된 바와 같이, 서브뱅크 컨트롤러 각각은 처리 소자 또는 프로세서 서브유닛에 의한 또는 명령을 발생하는 고수준 메모 리 컨트롤러에 의한 메모리 뱅크 상의 위치에 읽기와 쓰기가 가능하게 하는 서브뱅크 로우 디코더와 서브뱅크 컬럼 디코더와 같은 복수의 디코더를 포함할 수 있다. 예를 들어, 서브뱅크 컨트롤러(1130a)는 디코더(1160a, 1160b, 1160c)를 포함하고, 서브뱅크 컨트롤러(1130b)는 디코더(1160d, 1160e, 1160f)를 포함하고, 서브뱅크 컨트롤러(1130c)는 디코더(1160g, 1160h, 1160i)를 포함한다. 뱅크 로우 디코더의 요청에 의거하여, 서브 뱅크 컨트롤러는 서브뱅크 컨트롤러에 포함된 디코더를 사용하여 워드라인을 선택할 수 있다. 여기에 설명한 시 스템은 서브뱅크의 처리 소자 또는 프로세서 서브유닛이 다른 뱅크 및 다른 서브뱅크마저도 간섭하지 않으면서 메모리에 접근할 수 있게 하고, 이에 따라 각 서브뱅크 프로세서 서브유닛은 다른 서브뱅크 서브유닛과 병렬로 메모리 계산을 할 수 있다. 또한, 각 서브뱅크는 복수의 메모리 셀을 각각 포함하는 복수의 메모리 매트를 포함할 수 있다. 예를 들어, 서 브뱅크(1170a)는 매트(1190a-1, 1190a-2, . . . , 1190a-x)를 포함하고, 서브뱅크(1170b)는 매트(1190b-1, 1190b-2, . . . , 1190b-x)를 포함하고, 서브뱅크(1170c)는 매트(1190c-1, 1190c-2, . . . , 1190c-x)를 포함 한다. 또한, 도 11에 도시된 바와 같이, 각 서브뱅크는 적어도 하나의 디코더를 포함할 수 있다. 예를 들어, 서 브뱅크(1170a)는 디코더(1180a)를 포함하고, 서브뱅크(1170b)는 디코더(1180b)를 포함하고, 서브뱅크(1170c)는 디코더(1180c)를 포함한다. 이에 따라, 뱅크 컬럼 디코더는 외부 요청에 의거하여 글로벌 비트라인(예, 1121a 또는 1121b)을 선택할 수 있는 반면에 뱅크 로우 디코더에 의해 선택된 서브뱅크는 컬럼 디코더를 활용하여 이 서브뱅크가 전용인 논리 회로의 로컬 요청에 의거한 로컬 비트라인(예, 1181a 또는 1181b)을 선택 할 수 있다. 이에 따라, 각 프로세서 서브유닛은 뱅크 로우 디코더와 뱅크 컬럼 디코더를 사용하지 않고 서브 뱅크의 로우 디코더와 컬럼 디코더를 활용하여 프로세서 서브유닛의 전용 서브 뱅크에 접근하도록 구성될 수 있 다. 따라서, 각 프로세서 서브유닛은 다른 서브뱅크를 간섭하지 않으면서 상응하는 서브뱅크에 접근할 수 있다. 또한, 서브뱅크로의 요청이 프로세서 서브유닛의 외부에서 이루어지는 경우에, 서브뱅크 디코더는 접근된 데이 터를 뱅크 디코더에 반영할 수 있다. 또는, 각 서브뱅크에 단일 행의 메모리 뱅크만이 있는 실시예에서, 로컬 비트라인은 서브뱅크의 비트라인이 아닌 매트의 비트라인일 수 있다. 도 11에 도시된 실시예의 서브뱅크 로우 디코더와 서브뱅크 컬럼 디코더를 사용하는 실시예의 조합도 사용될 수 있다. 예를 들어, 뱅크 로우 디코더가 제거되지만 뱅크 컬럼 디코더는 유지하고 로컬 비트라인을 사용할 수 있 다. 도 12는 복수의 매트를 포함하는 메모리 서브뱅크의 실시예의 일례를 도시한 것이다. 예를 들어, 서브뱅 크는 도 11의 서브뱅크의 일부분을 나타내거나 메모리 뱅크가 다르게 구현된 것을 나타내는 것일 수 있다. 도 12의 예에서, 서브뱅크는 복수의 매트(예, 1240a, 1240b)를 포함한다. 또한, 각 매트는 복수 의 셀을 포함할 수 있다. 예를 들어, 매트(1240a)는 셀(1260a-1, 1260a-2, . . . , 1260a-x)을 포함하고, 매트 (1240b)는 셀(1260b-1, 1260b-2, . . . , 1260b-x)을 포함한다. 각 매트에는 매트의 메모리 셀에 배정될 어드레스의 범위가 배정될 수 있다. 이러한 어드레스는 매트가 이리저 리 옮겨질 수 있고 결함이 있는 매트는 비활성화되고 사용되지 않도록(예, 하기에 설명하는 바와 같이, 하나 이 상의 퓨즈 사용) 제조시에 설정될 수 있다. 서브뱅크는 메모리 컨트롤러로부터 읽기와 쓰기 요청을 수신한다. 도 12에는 도시되어 있지 않지만, 메모리 컨트롤러로부터의 요청은 서브뱅크의 컨트롤러를 통해 필터링 되고 어드레스 결정 을 위해 서브뱅크의 적절한 매트로 보내질 수 있다. 대안적으로, 메모리 컨트롤러의 요청의 어드레 스의 적어도 일부분(예, 높은 비트)이 서브뱅크의 모든 매트(예, 1240a, 1240b)로 전송되어 매트의 배정 된 어드레스 범위가 명령에 특정된 어드레스를 포함하는 경우에만 어드레스와 연관된 요청과 전체 어드레스를처리하도록 할 수 있다. 상기의 서브뱅크 지시와 유사하게, 매트 판단은 동적으로 제어되거나 하드웨어에 내장 될 수 있다. 일부 실시예에서, 퓨즈를 사용하여 각 매트에 대한 어드레스 범위를 판단할 수 있고, 또한 불법 어 드레스 범위를 배정함으로써 불량 매트를 비활성화할 수 있다. 매트는 일반적인 기타 방법이나 퓨즈 연결에 의 해 추가적으로 또는 대안적으로 비활성화 될 수 있다. 앞서 설명한 모든 실시예에서, 서브뱅크의 각 매트는 매트에서 워드라인을 선택하기 위한 로우 디코더(예, 1230a, 1230b)를 포함할 수 있다. 일부 실시예에서, 각 매트는 퓨즈 및 비교기(예, 1220a, 1220b)를 더 포함할 수 있다. 앞서 설명한 바와 같이, 비교기는 각 매트가 입력되는 요청을 처리할지 여부를 판단하게 할 수 있고, 퓨즈는 각 매트가 불량인 경우 비활성화 되게 할 수 있다. 대안적으로, 뱅크 및/또는 서브뱅크의 로우 디코더가 각 매트의 로우 디코더 대신에 사용될 수 있다. 또한, 앞서 설명한 모든 실시예에서, 해당 매트에 포함된 컬럼 디코더(예, 1250a, 1250b)는 로컬 비트라인(예, 1251, 1253)을 선택할 수 있다. 로컬 비트라인은 메모리 뱅크의 글로벌 비트라인에 연결될 수 있다. 서브뱅크에 자체의 로컬 비트라인이 있는 실시예에서, 셀의 로컬 비트라인은 서브뱅크의 로컬 비트라인으로 더 연결될 수 있다. 이에 따라, 선택된 셀의 데이터는 셀의 컬럼 디코더(및/또는 센스 증폭기)를 통한 후에 서브뱅크의 컬럼 디코더(및/또는 센스 증폭기)를 통하고(서브뱅크 컬럼 디코더 및/또는 센스 증폭기를 포함하는 실시예에서) 그 후에 뱅크의 컬럼 디코더(및/또는 센스 증폭기)를 통해 읽어질 수 있다. 매트는 복제되고 어레이로 배열되어 메모리 뱅크(또는 메모리 서브뱅크)를 형성할 수 있다. 예를 들어, 본 기재의 메모리 칩은 복수의 메모리 뱅크를 포함할 수 있고, 각 메모리 뱅크에는 복수의 메모리 서브뱅크가 있고, 각 메모리 서브뱅크에는 메모리 서브뱅크 상의 각 위치로 읽기와 쓰기를 처리하기 위한 서브뱅크 컨트롤 러가 있다. 또한, 각 메모리 서브뱅크는 복수의 메모리 매트를 포함할 수 있고, 각 메모리 매트에는 복수의 메 모리 셀과 매트 로우 디코더와 매트 컬럼 디코더(도 12에 도시)가 있다. 매트 로우 디코더와 매트 컬럼 디코더 는 서브뱅크 컨트롤러로부터의 읽기와 쓰기 요청을 처리할 수 있다. 예를 들어, 매트 디코더는 모든 요청을 수 신하고 요청을 처리할지 여부를 각 매트의 알려진 어드레스 범위에 의거하여 판단(예, 비교기를 활용)하거나, 서브뱅크(또는 뱅크) 컨트롤러에 의한 매트 선택에 의거하여 알려진 어드레스 범위 이내의 요청 만을 수신할 수 있다. 컨트롤러 데이터 전송 본 기재의 메모리 칩은 또한 프로세서 서브유닛을 활용하여 데이터를 공유하는 것 외에도 메모리 컨트롤러(또는 서브뱅크 컨트롤러 또는 매트 컨트롤러)를 활용하여 데이터를 공유할 수 있다. 예를 들어, 본 기재의 메모리 칩 은 메모리 뱅크의 각 위치로 읽기와 쓰기가 가능하도록 하는 뱅크 컨트롤러, 로우 디코더, 및 컬럼 디코더를 각 각 포함하는 복수의 메모리 뱅크(예, SRAM 뱅크, DRAM 뱅크 등)와 복수의 뱅크 컨트롤러의 각 컨트롤러를 복수 의 뱅크 컨트롤러의 적어도 하나의 다른 컨트롤러에 연결하는 복수의 버스를 포함할 수 있다. 일부 실시예에서, 복수의 버스는 하나 이상의 프로세서 서브유닛에 연결된 메모리 뱅크의 메인 버스 상의 데이 터 전송의 방해 없이 접근될 수 있다. 이에 따라, 메모리 뱅크(또는 서브뱅크)는 다른 메모리 뱅크(또는 서브뱅 크)와의 데이터 전송 또는 수신과 동일한 클럭 사이클로 상응하는 프로세서 서브유닛과 데이터를 전송 또는 수 신할 수 있다. 각 컨트롤러가 복수의 다른 컨트롤러에 연결된 실시예에서, 컨트롤러는 데이터의 전송 또는 수신 을 위해 복수의 다른 컨트롤러의 하나의 다른 컨트롤러를 선택하도록 구성될 수 있다. 일부 실시예에셔, 각 컨 트롤러는 적어도 하나의 이웃하는 컨트롤러에 연결될 수 있다(예, 공간적으로 인접하는 컨트롤러의 쌍들이 서로 연결될 수 있다). 메모리 회로의 리던던트 로직 본 기재는 온칩(on-chip) 데이터 프로세싱을 위한 프라이머리 논리부(primary logic portions)가 있는 메모리 칩에 관한 것이다. 메모리 칩은 불량 프라이머리 논리부를 교체하여 칩의 제조 수율을 증가시킬 수 있는 리던던 트 논리부(redundant logic portions)를 포함할 수 있다. 따라서, 칩은 논리부의 개별 검사에 의거한 메모리 칩 의 로직 블록의 설정을 가능하게 하는 온칩 요소를 포함할 수 있다. 메모리 칩은 논리부 전용의 영역이 클수록 제조 오류의 영향을 더 많이 받기 때문에 칩의 이러한 특징은 수율을 향상할 수 있다. 예를 들어, 리던던트 논 리부가 큰 DRAM 메모리 칩은 수율을 감소시키는 제조 문제의 영향을 많이 받을 수 있다. 그러나 리던던트 논리 부를 구현하면 고도의 병렬성 능력을 유지하면서도 DRAM 메모리 칩의 생산자나 사용자가 전체 논리부를 켜거나 끌 수 있게 해주기 때문에 수율과 신뢰성이 향상되는 결과를 얻을 수 있다. 본 기재에서, 기재된 실시예의 설명 의 편의상 특정 메모리 유형(예, DRAM)의 예를 들 수 있다. 그렇다고 하더라도, 본 기재가 특정된 메모리 유형으로 한정되는 것은 아니라는 점은 당연하다 할 것이다. 오히려, 본 기재의 일부 부분에서 예로 든 메모리 유형 이 적다고 하더라도, 기재된 실시예와 함께 DRAM, 플래시메모리, SRAM, ReRAM, PRAM, MRAM, ROM, 또는 기타 모 든 메모리와 같은 메모리 유형이 사용될 수 있다. 도 13은 본 기재에 따른 예시적인 메모리 칩의 구성도이다. 메모리 칩은 DRAM 메모리 칩으로 구현 될 수 있다. 메모리 칩은 또한 플래시메모리, SRAM, ReRAM, PRAM, 및/또는 MRAM 등과 같은 모든 유형의 휘발성 또는 비휘발성 메모리로 구현될 수 있다. 메모리 칩은 어드레스 매니저, 복수의 메모리 뱅 크(1304(a,a) 내지1304(z,z))를 포함하는 메모리 어레이, 메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직이 배치된 기판을 포함할 수 있다. 메모리 로직과 비즈니스 로직 은 프라이머리 로직 블록을 구성할 수 있는 반면, 리던던트 비즈니스 로직은 리던던트 블록을 구성 할 수 있다. 또한, 메모리 칩은 비활성화 스위치와 활성화 스위치가 포함될 수 있는 설정 스 위치를 포함할 수 있다. 비활성화 스위치와 활성화 스위치도 기판에 배치될 수 있다. 본 출 원에서, 메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직은 또한 집합적으로 '로직 블록'으로 칭해질 수 있다. 어드레스 매니저는 로우 디코더 및 컬럼 디코더 또는 기타 유형의 메모리 보조장치를 포함할 수 있다. 대 안적으로 또는 추가적으로, 어드레스 매니저는 마이크로컨트롤러 또는 처리부를 포함할 수 있다. 일부 실시예에서, 도 13에 도시된 바와 같이, 메모리 칩은 복수의 메모리 블록을 2차원 어레이로 기판 상에 배치할 수 있는 단일 메모리 어레이를 포함할 수 있다. 그러나 다른 실시예에서, 메모리 칩 은 다수의 메모리 어레이를 포함할 수 있고, 각각의 메모리 어레이는 서로 다른 구성으로 메 모리 블록을 배치할 수 있다. 예를 들어, 메모리 어레이 중의 적어도 한 어레이의 메모리 블록(즉, 메모리 뱅크)이 방사형 분포로 배치되어 어드레스 매니저 또는 메모리 로직으로부터 메모리 블록으로의 라 우팅을 가능하게 할 수 있다. 비즈니스 로직은 메모리 자체의 관리에 사용되는 논리와 무관한 어플리케이션의 인메모리 계산(in-memory computation)을 위해 사용될 수 있다. 예를 들어, 비즈니스 로직은 활성화 함수로 사용되는 플로팅, 정수, 또는 MAC 연산과 같은 AI에 관한 함수를 이행할 수 있다. 또한, 비즈니스 로직은 min, max, sort, count 등과 같은 데이터베이스 관련 함수를 이행할 수 있다. 메모리 로직은 읽기, 쓰기, 리프레쉬 동작 등을 포함하는 메모리 관리에 관한 작업을 수행할 수 있다. 따라서, 비즈니스 로직은 뱅크 레벨, 매트 레벨, 매 트 레벨의 그룹 중의 하나 이상에 추가될 수 있다. 비즈니스 로직에는 하나 이상의 어드레스 출력과 하나 이상의 데이터 입력/출력이 있을 수 있다. 예를 들어, 비즈니스 로직은 로우/컬럼 라인에 의해 어드레스 매니저로 어드레스 할 수 있다. 그러나 일부 실시예에서, 데이터 입력/출력을 통해 로직 블록이 추가적으 로 또는 대안적으로 어드레스 될 수 있다. 리던던트 비즈니스 로직은 비즈니스 로직의 복제일 수 있다. 또한, 리던던트 비즈니스 로직 은 작은 퓨즈/안티퓨즈(anti-fuse)를 포함할 수 있는 비활성화 스위치 및/또는 활성화 스위치에 연 결될 수 있고, 인스턴스 중의 하나(예, 디폴트로 연결되는 인스턴스)를 비활성화 또는 활성화하는 논리에 사용 되고 다른 로직 블록 중의 하나(예, 디폴트로 연결 해제되는 인스턴스)를 활성화할 수 있다. 일부 실시예에서, 하기에 도 15를 참조하여 설명하는 바와 같이, 블록의 중복성은 비즈니스 로직과 같은 로직 블록 이내에 국한될 수 있다. 일부 실시예에서, 메모리 칩의 로직 블록은 전용 버스로 메모리 어레이의 서브세트에 연결될 수 있 다. 예를 들어, 메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직의 세트는 메모리 어레이의 메모리 블록(즉, 1304 (a,a) 내지 1304 (a,z))의 제1행에 연결될 수 있다. 전용 버스는 연관된 로직 블록이 어드레스 매니저 등을 통하여 통신 라인을 개설할 필요없이 메모리 블록으로부터 데이터에 신속히 접근하게 해줄 수 있다. 복수의 프라이머리 로직 블록의 각각은 복수의 메모리 뱅크의 적어도 하나에 연결될 수 있다. 또한, 리던 던트 비즈니스 블록과 같은 리던던트 블록은 메모리 인스턴스(1304(a,a)-(z,z))의 적어도 하나에 연결될 수 있다. 리던던트 블록은 메모리 로직 또는 비즈니스 로직과 같은 복수의 프라이머리 로직 블록의 적어도 하나를 복제할 수 있다. 비활성화 스위치는 복수의 프라이머리 로직 블록의 적어도 하나에 연결될 수 있고, 활성화 스위치는 복수의 리던던트 블록의 적어도 하나에 연결될 수 있다. 이러한 실시예에서, 복수의 프라이머리 로직 블록(메모리 로직 및/또는 비즈니스 로직)의 하나와 연관된 결함이 검출되면, 비활성화 스위치는 복수의 프라이머리 로직 블록의 하나를 비활성화하도록 구성 될 수 있다. 동시에, 활성화 스위치는 복수의 프라이머리 로직 블록의 하나를 복제하는 리던던트 로직 블 록과 같은 복수의 리던던트 블록의 하나를 활성화하도록 구성될 수 있다. 또한, 집합적으로 '설정 스위치'로 불릴 수 있는 활성화 스위치와 비활성화 스위치는 스위치의 상 태를 설정하는 외부 입력을 포함할 수 있다. 예를 들어, 활성화 스위치는 외부 입력의 활성화 신호가 스 위치가 닫힌 상태를 유발하도록 설정될 수 있고, 비활성화 스위치는 외부 입력의 비활성화 신호가 스위치 가 열린 상태를 유발하도록 설정될 수 있다. 일부 실시예에서, 메모리 칩의 모든 설정 스위치는 디폴트로 비활성화 상태이고, 검사의 결과가 관련 로직 블록이 기능을 하는 것으로 나타내고 신호가 외부 입력에 주어진 이후에 활성화될 수 있다. 또는, 일부의 경우, 메모리 칩의 모든 설정 스위치는 디폴트로 활성화 상태이 고, 검사의 결과가 관련 로직 블록이 기능을 하지 않는 것으로 나타내고 비활성화 신호가 외부 입력에 주어진 이후에 비활성화될 수 있다. 설정 스위치가 초기에 활성화이거나 비활성화인지 여부와 상관없이, 관련 로직 블록과 연관된 결함이 검출되면, 설정 스위치는 관련 로직 블록을 비활성화할 수 있다. 설정 스위치가 초기에 활성화되어 있는 경우, 설정 스위 치의 상태는 관련 로직 블록을 비활성화하기 위하여 비활성화로 변경될 수 있다. 설정 스위치가 초기에 비활성 화되어 있는 경우, 설정 스위치의 상태는 관련 로직 블록을 비활성화하기 위하여 비활성화 상태로 유지될 수 있 다. 예를 들어, 조작성 검사의 결과, 특정 로직 블록이 작동하지 않는 것으로 나오거나 특정 사양 내에서 작동 하지 않는 것으로 나올 수 있다. 이러한 경우, 로직 블록은 상응하는 설정 스위치를 활성화하지 않음으로써 비 활성화될 수 있다. 일부 실시예에서, 설정 스위치는 둘 이상의 로직 블록에 연결될 수 있고 서로 다른 로직 블록 사이에서 선택하 도록 구성될 수 있다. 예를 들어, 설정 스위치는 비즈니스 로직과 리던던트 로직 블록 모두에 연결 될 수 있다. 설정 스위치는 리던던트 로직 블록을 활성화하는 반면에 비즈니스 로직을 비활성화할 수 있다. 대안적으로 또는 추가적으로, 복수의 프라이머리 로직 블록의 적어도 하나(메모리 로직 및/또는 비즈니스 로직)가 제1 전용 연결로 복수의 메모리 뱅크 또는 메모리 인스턴스의 서브세트에 연결될 수 있다. 이후, 복수의 프라이머리 로직 블록의 적어도 하나를 복제하는 복수의 리던던트 블록의 적어도 하나(예, 리던던 트 비즈니스 블록)가 제2 전용 연결로 동일한 복수의 메모리 뱅크 또는 인스턴스의 서브세트에 연 결될 수 있다. 또한, 메모리 로직에는 비즈니스 로직과 다른 기능과 능력이 있을 수 있다. 예를 들어, 메모리 로 직은 메모리 뱅크에 읽기와 쓰기 동작이 가능하도록 설계될 수 있는 반면, 비즈니스 로직은 인메모리 계산을 수행하도록 설계될 수 있다. 따라서, 비즈니스 로직이 제1 비즈니스 로직 블록을 포함하 고 비즈니스 로직이 제2 비즈니스 로직 블록(예, 리던던트 비즈니스 로직)을 포함하는 경우, 결함 이 있는 비즈니스 블록을 연결 해제하고 능력의 손실 없이 리던던트 비즈니스 로직에 다시 연결하 는 것이 가능하다. 일부 실시예에서, 설정 스위치(비활성화 스위치와 활성화 스위치 포함)는 퓨즈, 안티퓨즈, 또는 프 로그램 가능 장치(일회용 프로그램 가능 장치 포함), 또는 기타 형태의 비휘발성 메모리로 구현될 수 있다. 도 14는 기재된 실시예에 따른 예시적인 리던던트 로직 블록 세트의 구성도이다. 일부 실시예에서, 리던 던트 로직 블록 세트는 기판에 배치될 수 있다. 리던던트 로직 블록 세트는 스위치(1312, 1314)에 각각 연결된 비즈니스 로직과 리던던트 비즈니스 로직 중의 적어도 하나를 포함할 수 있다. 또한, 비즈니스 로직과 리던던트 비즈니스 로직은 어드레스 버스와 데이터 버스(140 4)에 연결될 수 있다. 일부 실시예에서, 도 14에 도시된 바와 같이, 스위치(1312, 1314)는 로직 블록을 클럭 노드에 연결할 수 있다. 이로써, 설정 스위치는 로직 블록을 클럭 신호와 연결 또는 해제할 수 있고, 그 결과로 로직 블록을 활성화 또 는 비활성화할 수 있다. 그러나 다른 실시예에서, 스위치(1312, 1314)는 로직 블록을 다른 노드에 연결하여 활 성화 또는 비활성화할 수 있다. 예를 들어, 설정 스위치는 로직 블록을 전압 공급 노드(예, VCC) 또는 접지 노 드(예, GND) 또는 클럭 신호에 연결할 수 있다. 이로써, 설정 스위치는 개방 회로를 만들거나 로직 블록 전원을 차단할 수 있기 때문에 로직 블록은 설정 스위치에 의해 활성화 또는 비활성화 될 수 있다. 일부 실시예에서, 도 14에 도시된 바와 같이, 어드레스 버스와 데이터 버스는 서로 각각의 버스에 병렬로 연결된 로직 블록의 반대편에 있을 수 있다. 이로써, 서로 다른 온칩 요소의 라우팅이 로직 블록 세트 에 의해 가능해질 수 있다. 일부 실시예에서, 복수의 비활성화 스위치의 각각은 복수의 프라이머리 로직 블록의 적어도 하나를 클럭 노드와 결합하고, 복수의 활성화 스위치의 각각은 복수의 리던던트 블록의 적어도 하나를 클럭 노드와 결 합하여 클럭을 단순 활성화/비활성화 메커니즘으로 연결/해제할 수 있게 한다. 리던던트 로직 블록 세트의 리던던트 비즈니스 로직은 설계자가 복제할 가치가 있는 블록을 면적과 라우팅에 의거하여 선택할 수 있게 해준다. 예를 들어, 칩 설계자는 블록의 면적이 클수록 오류가 날 가능성이 높으므로 면적이 큰 블록을 복제하기로 선택할 수 있다. 따라서, 칩 설계자는 면적이 큰 로직 블록을 복제하기 로 결정할 수 있다. 반면, 설계자는 면적이 작은 블록은 공간의 상당한 손실 없이도 쉽게 복제가 되기 때문에 면적이 작은 블록의 복제를 선호할 수도 있다. 또한, 도 14의 구성을 활용하여, 설계자는 면적당 오류의 통계에 따라 로직 블록의 복제를 쉽게 선택할 수도 있다. 도 15는 기재된 실시예에 따른 예시적인 로직 블록의 구성도이다. 로직 블록은 비즈니스 로직 블록 및/또는 리던던트 비즈니스 로직 블록일 수 있다. 그러나 다른 실시예에서, 예시적인 로직 블록은 메모리 로직 또는 메모리 칩의 기타 요소일 수도 있다. 로직 블록은 작은 프로세서 파이프라인 이내에서 로직 중복성이 사용되는 또 다른 실시예를 제시한다. 로 직 블록은 레지스터, 페치(fetch) 회로, 디코더, 및 라이트백(write-back) 회로 를 포함할 수 있다. 또한, 로직 블록은 계산부 및 복제 계산부를 포함할 수 있다. 그 러나 다른 실시예에서, 로직 블록은 컨트롤러 파이프라인을 포함하지 않지만 요구되는 비즈니스 로직이 있는 산발적 처리 소자를 포함하는 기타 요소를 포함할 수 있다. 계산부와 복제 계산부는 디지털 계산의 수행이 가능한 디지털 회로를 포함할 수 있다. 예를 들어, 계산부와 복제 계산부는 이진수에 대한 산술과 비트 연산을 수행하는 산술논리부(arithmetic logic unit, ALU)를 포함할 수 있다. 또는, 계산부와 복제 계산부는 부동소수점수에 대한 연산을 수행하 는 부동소수점부(floating-point unit, FPU)를 포함할 수 있다. 또한, 일부 실시예에서, 계산부와 복제 계산부는 min, max, count, 및 compare 등과 같은 데이터베이스 관련 함수를 이행할 수 있다. 일부 실시예에서, 도 15에 도시된 바와 같이, 계산부와 복제 계산부는 스위칭 회로(1514, 1516)에 연결될 수 있다. 스위칭 회로는 활성화되는 경우에 계산부를 활성화 또는 비활성화 할 수 있다. 로직 블록에서, 복제 계산부는 계산부의 복제일 수 있다. 또한, 일부 실시예에서, 레지스터 , 페치 회로, 디코더, 및 라이트백 회로는(집합적으로 '로컬 논리부'라 칭함) 계산부 보다 크기가 작을 수 있다. 소자의 크기가 클수록 제조 과정에서 문제가 발생할 가능성이 크므로, 설계자 는 크기가 작은 요소(예, 로컬 논리부)보다는 크기가 큰 요소(예, 계산부)를 복제하기로 결정할 수 있다. 그러나 수율과 오류율의 기록에 따라, 설계자는 크기가 큰 요소에 추가적으로 또는 대안적으로 로컬 논리부를 (또는 전체 블록을) 복제하기로 선택할 수도 있다. 예를 들어, 계산부는 레지스터, 페치 회로 , 디코더, 및 라이트백 회로보다 크기가 클 수 있고, 따라서 오류 가능성이 높을 수 있다. 설계자는 로직 블록의 다른 요소보다는 계산부 또는 전체 블록을 복제하기로 선택할 수 있다. 로직 블록은 계산부와 복제 계산부의 적어도 하나에 각각 연결되는 복수의 로컬 설정 스위치 를 포함할 수 있다. 로컬 설정 스위치는 계산부에 결함이 검출되는 경우에 계산부를 비활성화하고 복제 계산부를 활성화 하도록 설정될 수 있다. 도 16은 기재된 실시예에 따른 버스로 연결된 예시적인 로직 블록의 구성도이다. 일부 실시예에서, 로직 블록 (예, 메모리 로직, 비즈니스 로직, 또는 리던던트 비즈니스 로직)은 서로 별개일 수 있고, 버스를 통해 연결될 수 있고, 외부에서 구체적으로 어드레스 함으로써 활성화될 수 있다. 예를 들어, 메 모리 칩은 각각의 ID 번호를 가진 여러 로직 블록을 포함할 수 있다. 그러나 다른 실시예에서, 로직 블록 은 메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직의 하나 이상이 포함된 더 큰 요소를 나타내는 것일 수 있다. 일부 실시예에서, 로직 블록의 각각은 다른 로직 블록과 중복될 수 있다. 모든 블록이 프라이머리 블록 또는 리던던트 블록으로 동작할 수 있는 이러한 완전한 중복성으로 인해 설계자는 칩의 전체적인 기능은 유지하면서 결함이 있는 요소의 연결을 해제할 수 있기 때문에 제조 수율을 향상할 수 있다. 예를 들어, 모든 복제 블록이 동일한 어드레스와 데이터 버스에 연결될 수 있기 때문에 설계자는 오류가 날 가능성이 높은 논리영역은 비활성화하면서 유사한 계산 능력을 유지할 능력이 있을 수 있다. 예를 들어, 로직 블록의 초기 수는 목표 능력보다 클 수 있다. 이후, 일부 로직 블록을 비활성화해도 목표 능력에 영향을 주지 않을 수 있다. 로직 블록에 연결된 버스는 어드레스 버스, 명령 라인, 및 데이터 라인을 포함할 수 있다. 도 16에 도시된 바와 같이, 로직 블록의 각각은 버스의 각 라인과 별개로 연결될 수 있다. 그러나 특정 실시예 에서, 로직 블록은 체계적 구조로 연결되어 라우팅을 가능하게 할 수 있다. 예를 들어, 버스의 각 라인은 라인을 다른 로직 블록으로 라우팅하는 멀티플렉서로 연결될 수 있다. 일부 실시예에서, 소자의 활성화/비활성화로 인해 변경될 수 있는 칩의 내부 구조를 몰라도 외부에서의 접근을 가능하게 하기 위하여, 로직 블록의 각각은 퓨즈드(fused) ID와 같은 퓨즈드 ID를 포함할 수 있다. 퓨즈 드 ID는 ID를 판단하고 관리 회로에 연결될 수 있는 스위치(예, 퓨즈)의 어레이를 포함할 수 있다. 예를 들어, 퓨즈드 ID는 어드레스 매니저에 연결될 수 있다. 또는, 퓨즈드 ID는 높은 계층의 메모 리 어드레스 유닛에 연결될 수 있다. 이러한 실시예에서, 퓨즈드 ID는 특정 어드레스로 설정될 수 있다. 예를 들어, 퓨즈드 ID는 관리 회로로부터 수신된 명령에 의거하여 최종 ID를 판단하는 프로그램 가능 비 휘발성 장치를 포함할 수 있다. 메모리 칩 상의 분산 프로세서는 도 16에 도시된 구성으로 설계될 수 있다. 칩 웨이크업(chip wakeup) 또는 공 장 검사 단계에서 BIST로서 실행되는 검사 절차는 검사 프로토콜에 합격하는 복수의 프라이머리 로직 블록(메모 리 로직 및 비즈니스 로직)의 블록에 실행 ID 번호를 배정할 수 있다. 검사 절차는 또한 검사 프로 토콜에 불합격하는 복수의 프라이머리 로직 블록의 블록에 불법 ID 번호를 배정할 수 있다. 검사 절차는 또한 검사 프로토콜에 합격하는 복수의 리던던트 블록(리던던트 로직 블록)의 블록에 실행 ID 번호를 배정할 수 있다. 리던던트 블록이 불합격하는 프라이머리 로직 블록을 대체하기 때문에, 실행 ID 번호가 배정된 복수의 리던던트 블록의 블록은 불법 ID 번호가 배정된 복수의 프라이머리 로직 블록의 블록보다 크거나 같을 수 있고, 이에 따라 블록이 비활성화된다. 또한, 복수의 프라이머리 로직 블록의 각각과 복수의 리던던트 블록의 각각은 적어도 하나의 퓨즈드 ID를 포함할 수 있다. 또한, 도 16에 도시된 바와 같이, 로직 블록을 연결하 는 버스는 명령 라인, 데이터 라인, 및 어드레스 라인을 포함할 수 있다. 그러나 다른 실시예에서, 버스에 연결된 모든 로직 블록은 비활성화 상태로 ID 번호 없이 시작할 것이다. 하나씩 검사하여, 양호한 각 블록에는 실행 ID가 부여되고, 작동하지 않는 로직 블록에는 불법 ID가 남아있고 비활성화될 것이다. 이런 식으로, 리던던트 로직 블록은 결함이 있는 것으로 알려진 블록을 검사 과정에서 대체 함으로써 제조 수율을 향상할 수 있다. 어드레스 버스는 관리 회로를 복수의 메모리 뱅크의 각각, 복수의 프라이머리 로직 블록의 각각, 및 복수 의 리던던트 블록의 각각에 결합할 수 있다. 이러한 연결로 인해, 프라이머리 로직 블록과 연관된 결함을 검출 하면, 관리 회로는 유효하지 않은 어드레스를 복수의 프라이머리 로직 블록의 하나에 배정하고 유효한 어드레스 를 복수의 리던던트 블록의 하나에 배정할 수 있다. 예를 들어, 도 16의 A)에 도시된 바와 같이, 불법 ID(예, 어드레스 0xFFF)가 모든 로직 블록(1602(a)-(c))에 설 정될 수 있다. 검사 후에, 로직 블록 1602(a)와 1602(c)는 제대로 기능 하는 것으로 확인되고 로직 블록 1602(b)는 기능에 문제가 있는 것으로 확인된다. 도 16의 A)에서, 음영 처리하지 않은 로직 블록은 기능 검사에 합격한 로직 블록을 나타내고 음영 처리한 로직 블록은 기능 검사에 불합격한 로직 블록을 나타내는 것일 수 있 다. 이후, 검사 절차는 제대로 기능 하는 로직 블록에 대한 불법 ID를 합법 ID로 변경하고 기능에 문제가 있는 로직 블록에 대한 불법 ID는 그대로 유지한다. 예를 들면, 도 16의 A)에서, 로직 블록 1602(a)와 1602(c)에 대 한 어드레스는 각각 0xFFF에서 0x001과 0x002로 변경된다. 반면에, 로직 블록 1602(b)에 대한 어드레스는 불법 어드레스 0xFFF로 유지된다. 일부 실시예에서, ID는 상응하는 퓨즈드 ID을 프로그램하여 변경된다. 로직 블록의 검사 결과가 다르면 설정도 다를 수 있다. 예를 들어, 도 16의 B)에 도시된 바와 같이, 어드 레스 매니저는 초기에 모든 로직 블록에 불법 ID(즉, 0xFFF )를 배정할 수 있다. 그러나 검사의 결 과, 로직 블록 1602(a)와 1602(b) 모두 정상적으로 기능 하는 것으로 나타날 수 있다. 이 경우, 메모리 칩 은 두 개의 로직 블록만 있어도 되기 때문에, 로직 블록 1602(c)의 검사는 불필요할 수 있다. 따라서, 검 사에 들어가는 리소스를 최소화하기 위하여, 메모리 칩의 제품 정의에 의해 요구되는 기능 하는 로직 블 록의 최소 수량에 따라서만 로직 블록이 검사하고 다른 블록은 검사하지 않을 수 있다. 도 16의 B)에서, 음영 처리하지 않은 로직 블록은 기능성 검사에 합격한 로직 블록을 나타내고, 음영 처리한 로직 블록은 검사하지 않 은 로직 블록을 나타낸다. 이러한 실시예에서, 생산 테스터(외장 또는 내장, 자동 또는 수동) 또는 스타트업에서 BIST를 실행하는 제어기 는 검사를 통해 기능 하는 것으로 판명된 로직 블록에 대해 불법 ID를 실행 ID로 변경하고 검사하지 않은 로직 블록은 불법 ID를 변경하지 않을 수 있다. 예를 들면, 도 16의 B)에서, 로직 블록 1602(a)와 1602(b)의 어드레 스는 각각 0xFFF에서 0x001과 0x002로 변경된다. 반면, 검사하지 않은 로직 블록 1602(c)에 대한 어드레스는 불 법 어드레스 0xFFF를 유지한다. 도 17은 기재된 실시예에 따른 직렬로 연결된 예시적인 소자(1702, 1712)의 구성도이다. 도 17은 전체 시스템 또는 칩을 도시한 것일 수 있다. 또는, 도 17은 다른 기능 블록을 포함하는 칩 내부의 블록을 도시한 것일 수 있다. 소자(1702, 1712)는 메모리 로직 및/또는 비즈니스 로직과 같은 복수의 로직 블록을 포함하는 전체 소자를 나타내는 것일 수 있다. 이런 실시예에서, 소자(1702, 1712)는 또한 어드레스 매니저와 같이 동작 을 수행하기 위해 필요한 요소를 포함할 수 있다. 그러나 다른 실시예에서, 소자(1702, 1712)는 비즈니스 로직 또는 리던던트 비즈니스 로직과 같은 논리 소자를 나타내는 것일 수 있다. 도 17은 소자(1702, 1712)가 서로 통신할 필요가 있을 수 있는 실시예를 제시한다. 이런 경우, 소자(1702, 1712)는 직렬로 연결될 수 있다. 그러나 작동하지 않는 소자가 로직 블록 사이의 연결성을 막을 수 있다. 따라 서, 소자 사이의 연결은 소자가 결함으로 인해 비활성화되어야 할 필요가 있는 경우를 대비하여 우회 옵션을 포 함할 수 있다. 우회 옵션은 또한 우회된 소자 자체의 일부일 수 있다. 도 17에서, 소자는 직렬로 연결될 수 있고(예, 1702(a)-(c)), 불합격 소자(예, 1702(b))는 결함 시에 우회될 수 있다. 소자는 스위칭 회로와 병렬도 더 연결될 수 있다. 예를 들어, 일부 실시예에서, 도 17에 도시된 바와 같 이, 소자(1702, 1712)는 스위칭 회로(1722, 1728)와 연결될 수 있다. 도 17에 도시된 예에서, 소자(1702(b))는 결함이 있다. 예를 들어, 소자(1702(b))는 회로 기능 검사에서 불합격이다. 따라서, 소자(1702(b))는 활성화 스 위치(1314; 도 17에 미도시) 등을 활용하여 비활성화될 수 있고/있거나 스위칭 회로(1722(b))가 활성화되어 소 자(1702(b))를 우회하고 로직 블록 사이의 연결성을 유지할 수 있다. 이에 따라, 복수의 프라이머리 소자가 직렬로 연결된 경우, 복수의 소자의 각각은 병렬 스위치와 병렬로 연결될 수 있다. 복수의 소자의 하나와 연관된 결함이 검출되면, 복수의 소자의 하나와 연결된 병렬 스위치가 활성화되 어 복수의 소자의 두 소자를 서로 연결할 수 있다. 다른 실시예에서, 도 17에 도시된 바와 같이, 스위칭 회로는 사이클을 지연시켜서 소자의 서로 다른 라인 사이의 동기화를 유지하는 하나 이상의 샘플링 포인트를 포함할 수 있다. 어떤 소자가 비활성화된 경우에, 인접 로직 블록 사이의 연결을 차단하면 다른 계산과의 동기화 오류가 발생할 수 있다. 예를 들어, 어떤 작업이 A 라 인과 B 라인 모두로부터 데이터를 필요로 하고, A 라인과 B 라인은 각각 서로 별개의 일련의 소자에 의해 수행 되는 경우에, 한 소자를 비활성화하면 A 라인과 B 라인 사이의 비동기화가 발생할 것이고 이에 따라 추가적인 데이터 관리가 필요할 것이다. 비동기화를 방지하기 위하여, 샘플 회로는 비활성화된 소자(1712(b))에 의 해 유발된 지연을 시뮬레이션할 수 있다. 그러나 일부 실시예에서, 병렬 스위치는 샘플링 회로 대신에 안 티퓨즈를 포함할 수 있다. 도 18은 기재된 실시예에 따른 2차원 어레이로 연결된 예시적인 소자의 구성도이다. 도 18은 전체 시스템 또는 칩을 나타내는 것일 수 있다. 또는, 도 18은 다른 기능 블록을 포함하는 칩 내부의 블록을 도시한 것일 수 있다. 소자는 메모리 로직 및/또는 비즈니스 로직과 같은 복수의 로직 블록을 포함하는 자율 소자 (autonomous unit)를 나타내는 것일 수 있다. 그러나 다른 실시예에서, 소자는 비즈니스 로직과 같 은 논리 소자를 나타내는 것일 수 있다. 설명의 편의상, 도 18의 설명은 앞서 도 13에 설명한 요소(예, 메모리 칩)를 참조할 수 있다. 도 18에 도시된 바와 같이, 소자는 소자(메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직의 하나 이상을 포함하거나 나타낼 수 있음)가 스위칭 박스 및 연결 박스를 통해 서로 연결된 2차원 어레이로 배치될 수 있다. 또한, 2차원 어레이의 설정을 제어하기 위하여, 2차원 어레이는 주변에 I/O 블록을 포함할 수 있다. 연결 박스는 I/O 블록으로부터 입력되는 신호에 대응할 수 있는 프로그램 가능 및 재구성 가능 장 치일 수 있다. 예를 들어, 연결 박스는 소자로부터의 복수의 입력 핀을 포함할 수 있고, 또한 스위칭 박스로 연결될 수 있다. 또는, 연결 박스는 프로그램 가능 로직 셀의 핀을 라우팅 트랙과 연결하는 한 그룹의 스위치를 포함할 수 있고, 스위칭 박스는 서로 다른 트랙을 연결하는 한 그룹의 스위치를 포함 할 수 있다. 일부 실시예에서, 연결 박스와 스위칭 박스는 스위치(1312, 1314)와 같은 설정 스위치로 구현될 수 있다. 이러한 실시예에서, 연결 박스와 스위칭 박스는 칩 스타트업에 실행되는 BIST 또는 생산 테 스터에 의해 설정될 수 있다. 일부 실시예에서, 연결 박스와 스위칭 박스는 소자에 대한 회로 기능 검사 후에 설정될 수 있다. 이런 실시예에서, I/O 블록을 사용하여 검사 신호를 소자에 전송할 수 있다. 검사 결과에 따 라, I/O 블록은 검사 프로토콜에 불합격하는 소자를 비활성화하고 검사 프로토콜에 합격하는 소자 를 활성화하는 방식으로 연결 박스와 스위칭 박스를 설정하는 프로그래밍 신호를 전송할 수 있다. 이러한 실시예에서, 복수의 프라이머리 로직 블록과 복수의 리던던트 블록은 2차원 그리드(grid)로 기판 상에 배치될 수 있다. 따라서, 복수의 프라이머리 소자의 각 소자와 리던던트 비즈니스 로직과 같은 복 수의 리던던트 블록의 각 블록은 스위칭 박스로 서로 연결될 수 있고, 입력 블록은 2차원 그리드의 각 라 인과 각 열의 주변에 배치될 수 있다. 도 19는 기재된 실시예에 따른 복합 연결된 예시적인 소자의 구성도이다. 도 19는 전체 시스템을 나타내는 것일 수 있다. 또는, 도 19는 다른 기능 블록을 포함하는 칩 내부의 블록을 도시한 것일 수 있다. 도 19의 복합 연결은 소자(1902(a)-(f))와 설정 스위치(1904(a)-(h))를 포함한다. 소자는 메모리 로직 및/또는 비즈니스 로직과 같은 복수의 로직 블록을 포함하는 자율 소자를 나타내는 것일 수 있다. 그러나 다른 실시예에서, 소자는 메모리 로직, 비즈니스 로직, 또는 리던던트 비즈니스 로직 과 같은 로직 소자를 나타내는 것일 수 있다. 설정 스위치는 비활성화 스위치와 활성화 스위 치 중의 하나 이상을 포함할 수 있다. 도 19에 도시된 바와 같이, 복합 연결은 두 면에 있는 소자를 포함할 수 있다. 예를 들어, 복합 연결은 z 축을 따라 이격된 두 개의 개별적인 기판을 포함할 수 있다. 대안적으로 또는 추가적으로, 소자는 기판의 두 면에 배치될 수 있다. 예를 들어, 메모리 칩의 면적을 줄이려는 목적으로, 기판은 중첩하는 두 면에 배치될 수 있고, 3차원으로 배치된 설정 스위치로 연결될 수 있다. 설정 스위치는 비활성화 스위치 및/또는 활성화 스위치를 포함할 수 있다. 기판의 제1면은 '메인' 소자를 포함할 수 있다. 이 블록은 디폴트로 활성화될 수 있다. 이러한 실시예에 서, 제2면은 '리던던트' 소자를 포함할 수 있다. 이 소자는 디폴트로 비활성화 될 수 있다. 일부 실시예에서, 설정 스위치는 안티퓨즈를 포함할 수 있다. 따라서, 소자의 검사 후에, 특정 안 티퓨즈를 '상시 온(always-on)' 상태로 스위칭하고 선택된 소자를 비활성화 함으로써 블록이 서로 다른 면에 있더라도 기능 소자의 타일로 연결될 수 있다. 도 19에 도시된 예에서, '메인' 소자의 하나(1902(e))는 고 장이다. 도 19에서, 기능에 문제가 있거나 검사하지 않은 블록은 음영 처리로 표시되고, 검사도 하고 기능에 문 제가 없는 블록은 음영 처리하지 않은 상태로 표시될 수 있다. 따라서, 설정 스위치는 서로 다른 면에 있 는 로직 블록의 하나(예, 1902(f))가 활성화 되도록 설정될 수 있다. 이로써, 메인 로직 블록의 하나에 결함이 있더라도, 여분의 논리 소자로 대체함으로써 메모리 칩이 여전히 기능을 한다. 또한, 도 19에서, 메인 로직 블록이 기능을 하기 때문에, 제2면에 있는 소자의 하나(1902(c))가 검사를 받지 않았고 활성화 되지 않았다. 예를 들어, 도 19에서, 메인 소자1902(a)와 1902(d)는 모두 기능 검사에 합격 했다. 따라서, 소자(1902(c))는 검사를 받거나 활성화 되지 않았다. 따라서, 도 19는 검사 결과에 따라 활성화 되는 로직 블록을 구체적으로 선택하는 능력을 도시한다. 일부 실시예에서, 도 19에 도시된 바와 같이, 제1면에 있는 모든 소자에 상응하는 여분 또는 리던던트 블 록이 있는 것이 아니다. 그러나 다른 실시예에서, 모든 소자가 프라이머리와 리던던트 모두에 해당하는 경우에 모든 소자는 서로에 대해 리던던트가 됨으로써 완벽한 중복성을 가질 수 있다. 또한, 일부에서는 도 19에 도시 된 방사형 네트워크(star network)로 구현되지만, 병렬 연결, 직렬 연결, 및/또는 서로 다른 요소를 설정 스위 치로 병렬 또는 직렬로 연결하는 구현도 가능하다. 도 20은 기재된 실시예에 따른 리던던트 블록 활성화 프로세스를 도시한 예시적인 순서도이다. 활성화 프 로세스는 메모리 칩, 특히 DRAM 메모리 칩에 대해 이행될 수 있다. 일부 실시예에서, 프로세스 는 메모리 칩의 기판 상에 배치된 복수의 로직 블록의 각 블록에 대해 적어도 하나의 회로 기능을 검사하 는 단계, 검사의 결과에 의거하여 복수의 프라이머리 로직 블록에서 결함이 있는 로직 블록을 식별하는 단계, 메모리 칩의 기판 상에 배치된 적어도 하나의 리던던트 또는 추가 로직 블록에 대해 적어도 하나의 회로 기능을 검사하는 단계, 외부 신호를 비활성화 스위치에 인가하여 적어도 하나의 결함이 있는 로직 블록을 비활성화하는 단계, 및 외부 신호를 활성화 스위치에 인가하여 적어도 하나의 리던던트 블록을 활성화하는 단계를 포함할 수 있다. 여기서, 활성화 스위치는 적어도 하나의 리던던트 블록과 연결될 수 있고, 메모리 칩의 기판 상에 배치될 수 있다. 하기의 도 20의 설명에서 프로세스의 각 단계에 대해 더 설명한다. 프로세스는 비즈니스 블록과 복수의 리던던트 블록(예, 리던던트 비즈니스 블록)과 같은 복 수의 로직 블록을 검사하는 단계(단계 2002)를 포함할 수 있다. 검사는 온-웨이퍼(on-wafer) 검사를 위한 프로 빙 스테이션(probing station) 등을 활용한 패키징(packaging) 이전에 수행될 수 있다. 그런, 프로세스 는 패키징 이후에 수행될 수도 있다. 단계 2002의 검사는 유한 시퀀스의 검사 신호를 메모리 칩의 모든 로직 블록 또는 메모리 칩의 로 직 블록의 서브세트에 인가하는 단계를 포함할 수 있다. 검사 신호는 0 또는 1을 출력할 것으로 예상되는 계산 을 요청할 수 있다. 다른 실시예에서, 검사 신호는 메모리 뱅크의 특정 어드레스를 읽거나 특정 메모리 뱅크에 쓰기를 요청할 수 있다. 단계 2002의 반복 프로세스 하에서 로직 블록의 반응을 검사하기 위해 검사 방식이 이행될 수 있다. 예를 들어, 메모리 뱅크에 데이터를 쓰도록 하는 명령을 전송한 후에 기록한 데이터의 무결성을 검증하여 로직 블록을 검사 할 수 있다. 다른 실시예에서, 데이터를 역으로 하여 알고리즘을 반복하여 검사할 수 있다. 다른 실시예에서, 단계 2002의 검사는 로직 블록의 모델을 실행하여 검사 명령의 세트에 의거하여 타깃 메모리 이미지를 생성하는 단계를 포함할 수 있다. 이후, 메모리 칩의 로직 블록에 명령의 동일한 시퀀스가 실행되고, 그 결과가 기록될 수 있다. 시뮬레이션의 잔존하는 메모리 이미지는 또한 검사에서 확보된 이미지와 비교될 수 있고, 불일치에는 불합격의 플래그가 붙여질 수 있다. 또는, 단계 2002에서, 검사는 셰도우 모델링(shadow modeling)을 포함할 수 있고, 여기서, 진단은 생성되지만 결과를 반드시 예측하지는 않는다. 오히려, 셰도우 모델링을 활용한 검사는 메모리 칩과 시뮬레이션에서 병렬로 실행될 수 있다. 예를 들어, 메모리 칩의 로직 블록이 명령 또는 작업을 완수하는 경우, 동일한 명령을 실행하 라는 신호를 시뮬레이션에 보낼 수 있다. 메모리 칩의 로직 블록이 명령을 완수하면, 두 모델의 아키텍처 상태 를 비교한다. 여기에 불일치가 있으면, 불합격 플래그가 붙는다. 일부 실시예에서, 단계 2002에서 모든 로직 블록(메모리 로직, 비즈니스 로직, 및 리던던트 비즈니 스 로직의 각각 등을 포함)을 검사할 수 있다. 그러나 다른 실시예에서, 서로 다른 차수의 검사에서 로직 블록의 서브세트만을 검사할 수도 있다. 예를 들어, 1차 검사에서는 메모리 로직과 그 연관 블록 만을 검 사할 수 있다. 2차 검사에서는 비즈니스 로직과 그 연관 블록 만을 검사할 수 있다. 3차 검사에서는 앞선 2번의 검사의 결과에 따라 리던던트 비즈니스 로직과 연관된 로직 블록을 검사할 수 있다. 프로세스는 단계 2004로 진행할 수 있다. 단계 2004에서, 결함이 있는 로직 블록이 식별되고, 결함이 있 는 리던던트 블록도 식별될 수 있다. 예를 들어, 단계 2002의 검사에 불합격하는 로직 블록이 단계 2004에서 결 함이 있는 블록으로 식별될 수 있다. 그러나 다른 실시예에서, 결함이 있는 특정 블록 만이 초기에 식별될 수 있다. 예를 들어, 일부 실시예에서, 비즈니스 로직과 연관된 로직 블록만이 식별될 수 있고, 리던던트 로 직 블록이 결함이 있는 로직 블록을 대체해야 하는 경우에만 결함이 있는 리던던트 로직 블록이 식별될 수 있다. 또한, 결함이 있는 로직 블록을 식별하는 단계는 식별된 결함이 있는 로직 블록의 식별 정보를 메모리 뱅 크 또는 비휘발성 메모리에 기록하는 단계를 포함할 수 있다. 단계 2006에서, 결함이 있는 로직 블록이 비활성화될 수 있다. 예를 들어, 설정 회로를 사용하여, 결함이 있는 로직 블록을 클럭, 접지, 및/또는 전원 노드로부터 연결 해제함으로써 결함이 있는 로직 블록이 비활성화될 수 있다. 또는, 로직 블록을 회피하는 배치로 연결 박스를 설정함으로써 결함이 있는 로직 블록이 비활성화될 수 있다. 또한, 다른 실시예에서, 어드레스 매니저로부터 불법 어드레스를 수신함으로써 결함이 있는 로직 블록이 비활성화 될 수 있다. 단계 2008에서, 결함이 있는 로직 블록을 복제하는 리던던트 블록이 식별될 수 있다. 일부 로직 블록에 결함이 있더라도 메모리 칩의 능력을 유지하기 위하여, 단계 2008에서, 결함이 있는 로직 블록을 복제할 수 있고 사용가능한 리던던트 블록을 식별할 수 있다. 예를 들어, 벡터 곱셈을 수행하는 로직 블록이 결함이 있는 것으로 판 단되는 경우, 단계 2008에서, 어드레스 매니저 또는 온칩 컨트롤러는 역시 벡터 곱셈을 수행하는 사용 가 능한 리던던트 로직 블록을 식별할 수 있다. 단계 2010에서, 단계 2008에서 식별된 리던던트 블록이 활성화될 수 있다. 단계 2006의 비활성화 동작에 반하여, 단계 2010에서는, 식별된 리던던트 블록을 클럭, 접지, 및/또는 전원 노드에 연결함으로써 식별된 리던 던트 블록이 활성화될 수 있다. 또는, 식별된 리던던트 블록을 연결하는 배치로 연결 박스를 설정함으로써, 식 별된 리던던트 블록이 활성화될 수 있다. 또한, 다른 실시예에서, 검사 절차 실행 타임에 실행 어드레스를 수신 함으로써, 식별된 리던던트 블록이 활성화될 수 있다. 도 21은 기재된 실시예에 따른 어드레스 배정 프로세스를 도시한 예시적인 순서도이다. 어드레스 배정 프 로세스는 메모리 칩, 특히 DRAM 메모리 칩에 대해 이행될 수 있다. 도 16을 참조하여 설명한 바와 같이, 일부 실시예에서, 메모리 칩의 로직 블록은 데이터 버스에 연결될 수 있고 어드레스 ID를 포함할 수 있다. 프로세스는 결함이 있는 로직 블록을 비활성화하고 검사에 합격하는 로직 블록을 활성화하는 어 드레스 배정 방법을 제공한다. 프로세스의 단계들은 칩 스타트업에 실행되는 BIST 또는 생산 테스터에 의 해 수행되는 것으로 설명되지만, 메모리 칩의 다른 요소 및/또는 외부 장치도 프로세스의 하나 이 상의 단계를 수행할 수 있다. 단계 2102에서, 테스터는 칩 레벨의 각 로직 블록에 불법 ID를 배정함으로써 모든 로직 블록과 리던던트 블록을 비활성화 할 수 있다. 단계 2104에서, 테스터는 로직 블록의 검사 프로토콜을 실행할 수 있다. 예를 들어, 테스터는 메모리 칩 의 로직 블록의 하나 이상에 대해 단계 2002에서 설명한 검사 방법을 실행할 수 있다. 단계 2106에서, 단계 2104의 검사의 결과에 따라, 테스터는 로직 블록에 결함이 있는지 여부를 판단할 수 있다. 로직 블록에 결함이 없는 경우(단계 2106에서 '아니오'), 어드레스 매니저는 단계 2108에서 실행 ID를 검사된 로직 블록에 배정할 수 있다. 로직 블록에 결함이 있는 경우(단계 2106에서 '예'), 어드레스 매니저는 단 계 2110에서 결함이 있는 로직 블록에 불법 ID를 남겨둘 수 있다. 단계 2112에서, 어드레스 매니저는 결함이 있는 로직 블록을 복제하는 리던던트 로직 블록을 선택할 수 있다. 일부 실시예에서, 결함이 있는 로직 블록을 복제하는 리던던트 로직 블록에는 결함이 있는 로직 블록과 동일한 요소 및 연결이 있을 수 있다. 그러나 다른 실시예에서, 리던던트 로직 블록은 결함이 있는 로직 블록과 다른 요소 및/또는 연결을 포함하지만 균등한 동작을 수행할 수 있을 수 있다. 예를 들어, 결함이 있는 로직 블 록이 벡터 곱셈을 수행하도록 설계된 경우, 선택된 리던던트 로직 블록도 결함이 있는 로직 블록과 동일한 아키 텍처가 아니더라도 벡터 곱셈을 수행할 수 있을 수 있다. 단계 2114에서, 어드레스 매니저는 리던던트 블록을 검사할 수 있다. 예를 들어, 테스터는 단계 2104에 적용된 검사 방식을 식별된 리던던트 블록에 적용할 수 있다. 단계 2116에서, 단계 2114의 검사의 결과에 의거하여, 테스터는 리던던트 블록에 결함이 있는지 여부를 판단할 수 있다. 단계 2118에서, 리던던트 블록에 결함이 없는 경우(단계 2116에서 '아니오'), 테스터는 식별된 리던던 트 블록에 실행 ID를 배정할 수 있다. 일부 실시예에서, 프로세스는 단계 2118 이후에 단계 2104로 돌아 가서 메모리 칩의 모든 로직 블록을 검사하는 반복 루프를 구성할 수 있다. 테스터가 리던던트 블록에 결함이 있는 것으로 판단하는 경우(단계 2116에서 '예'), 단계 2120에서, 테스터는 추가 리던던트 블록이 사용 가능한지 여부를 판단할 수 있다. 예를 들어, 테스터는 사용 가능한 리던던트 로직 블록에 관한 정보로 메모리 뱅크에 쿼리를 할 수 있다. 사용 가능한 리던던트 로직 블록이 있는 경우(단계 2120 에서 '예'), 테스터는 단계 2112로 돌아가서 결함이 있는 로직 블록을 복제하는 새로운 리던던트 로직 블록을 식별할 수 있다. 사용 가능한 리던던트 로직 블록이 없는 경우(단계 2120에서 '아니오'), 단계 2122에서, 테스 터는 오류 신호를 생성할 수 있다. 오류 신호는 결함이 있는 로직 블록과 결함이 있는 리던던트 블록의 정보를 포함할 수 있다. 결합된 메모리 뱅크 여기에 기재된 실시예들은 또한, 분산된 고성능 프로세서를 포함한다. 프로세서는 메모리 뱅크와 처리부를 접근 시키는 메모리 컨트롤러를 포함할 수 있다. 프로세서는 데이터가 계산을 위해 처리부에 신속히 전달되도록 구성 될 수 있다. 예를 들어, 작업을 수행하기 위해 처리부가 두 개의 데이터 인스턴스가 필요한 경우, 메모리 컨트롤러는 통신 라인이 개별적으로 두 데이터 인스턴스로부터의 정보에 대한 접근을 제공할 수 있도록 구성될 수 있다. 기재된 메모리 아키텍처는 복합 캐시 메모리와 복합 레지스터 파일 스키마와 연관된 하드웨어 요구조건을 최소화하고자 한다. 일반적으로, 프로세서 칩은 코어가 레지스터와 직접 작용하도록 하는 캐시 체계를 포함한다. 그러나 캐시 동작은 상당한 다이 면적을 필요로 하고 추가적인 전력을 소비한다. 기재된 메모리 아키 텍처는 메모리에 논리 요소를 추가함으로써 캐시 체계의 사용을 피한다. 기재된 아키텍처는 또한 메모리 뱅크 내에 데이터를 전략적으로(또는 최적화된) 배치할 수 있게 한다. 메모리 뱅크가 단일 포트만을 포함하고 지연이 많은 경우라도, 기재된 메모리 아키텍처는 데이터를 메모리 뱅크의 다른 블록에 전략적으로 배치함으로써 고성능을 가능하게 하고 메모리 병목현상을 방지할 수 있다. 지속적인 데이터 스트림을 처리부로 제공하려는 목적으로, 컴파일 최적화(compilation optimization) 단계는 데이터가 특정 또는 일반 작업에 대해 메모리 뱅크에 저장되어야 하는 방법을 판단할 수 있다. 이후, 처리부와 메모리 뱅크를 접근 시키는 메모리 컨트롤러는 동작을 수행하기 위하여 데이터가 필요한 경우에 특정 처리부에게 접근을 허용하도록 구성될 수 있다. 메모리 칩의 설정은 처리부(예, 설정 매니저) 또는 외부 인터페이스에 의해 수행될 수 있다. 설정은 또한 컴파 일러 또는 기타 소프트웨어 툴에 의해 기록될 수 있다. 또한, 메모리 컨트롤러의 설정은 메모리 뱅크에 사용 가 능한 포트와 메모리 뱅크의 데이터 구조에 의거할 수 있다. 이에 따라, 기재된 아키텍처는 서로 다른 메모리 뱅 크로부터 데이터의 지속적인 흐름 또는 동시 정보를 처리부에 제공할 수 있다. 이로써, 지연 병목현상 또는 캐 시 메모리 요구사항을 회피하여 메모리 이내의 계산 작업이 신속히 처리될 수 있다. 또한, 메모리 칩에 저장된 데이터는 컴파일 최적화 단계에 의거하여 배치될 수 있다. 컴파일은 프로세서가 메모 리 지연이 없는 처리부로 작업을 효율적으로 배정하는 처리 루틴의 구축을 가능하게 할 수 있다. 컴파일은 컴파 일러에 의해 수행되고 기판의 외부 인터페이스와 연결된 호스트로 전송될 수 있다. 일반적으로, 특정 접근 패턴 에 대한 높은 지연 및/또는 적은 수의 포트의 결과는 데이터를 필요로 하는 처리부에 대한 데이터 병목현상이 될 수 있다. 그러나 기재된 컴파일은 불리한 메모리 유형으로도 처리부가 지속적으로 데이터를 수신할 수 있게 메모리 뱅크에 데이터를 배치할 수 있다. 또한, 일부 실시예에서, 설정 매니저는 작업에 요구되는 계산에 의거하여 필요한 처리부에 신호를 보낼 수 있다. 칩의 서로 다른 처리부 또는 로직 블록에는 서로 다른 작업에 대해 특화된 하드웨어 또는 아키텍처가 있 을 수 있다. 따라서, 수행될 작업에 따라, 처리부 또는 처리부의 그룹이 해당 작업을 수행하도록 선택될 수 있 다. 기판 상의 메모리 컨트롤러는 프로세서 서브유닛의 선택에 따라 데이터를 보내거나 접근을 허용하여 데이터 전송 속도를 향상할 수 있다. 예를 들어, 컴파일 최적화와 메모리 아키텍처에 의거하여, 처리부는 작업을 수행 하도록 요구되는 경우에 메모리 뱅크의 접근이 허용될 수 있다. 또한, 칩 아키텍처는 메모리 뱅크의 데이터 접근에 필요한 시간을 단축하여 데이터의 전송을 가능하게 하는 온 칩 요소를 포함할 수 있다. 따라서, 본 기재는 단순한 메모리 인스턴스를 활용하여 특정 또는 일반 작업의 수행 이 가능한 고성능 프로세서에 대한 칩 아키텍처를 컴파일 최적화 단계와 함께 설명한다. 메모리 인스턴스에는 DRAM 장치 또는 기타 메모리 지향 기술에 사용되는 것과 같은 적은 수의 포트 및/또는 높은 지연이 있을 수 있 지만, 기재된 아키텍처는 메모리 뱅크로부터 처리부로의 데이터의 지속적인(또는 거의 지속적인) 흐름을 가능하 게 하여 이러한 단점을 극복할 수 있다. 본 출원에서, 동시 통신이란 클럭 사이클 이내의 통신을 말하는 것일 수 있다. 또는, 동시 통신이란 미리 정해 진 시간 이내에 정보를 전송하는 것을 의미하는 것일 수 있다. 예를 들어, 동시 통신은 몇 나노초(10억분의 몇 초) 이내의 통신을 말하는 것일 수 있다. 도 22는 기재된 실시예에 따른 예시적인 처리 장치에 대한 구성도이다. 도 22의 A)는 메모리 컨트롤러가 멀티플렉서를 활용하여 제1 메모리 블록과 제2 메모리 블록을 연결하는 처리 장치의 제1 실 시예를 도시한 것이다. 메모리 컨트롤러는 또한 적어도 설정 매니저, 로직 블록, 복수의 가 속기(2216(a)-(n))를 연결할 수 있다. 도 22의 B)는 메모리 컨트롤러가 메모리 컨트롤러와 적어도 설정 매니저, 로직 블록, 복수의 가속기(2216(a)-(n))를 연결하는 버스를 활용하여 메모리 블록 (2202, 2204)을 연결하는 처리 장치의 제2 실시예를 도시한 것이다. 또한, 호스트는 외부에 위치할 수 있고 외부 인터페이스 등을 통해 처리 장치에 연결될 수 있다. 메모리 블록(2202, 2204)은 DRAM 매트 또는 매트 그룹, DRAM 뱅크, MRAM\\ PRAM\\ RERAM\\ SRAM 유닛, 플래시 매 트, 또는 기타 메모리 기술을 포함할 수 있다. 메모리 블록(2202, 2204)은 대안적으로 비휘발성 메모리, 플래시메모리 장치, ReRAM(Resistive Random Access Memory) 장치, 또는 MRAM(Magnetoresistive Random Access Memory) 장치를 포함할 수 있다. 메모리 블록(2202, 2204)은 추가적으로 복수의 워드라인(미도시)과 복수의 비트라인(미도시) 사이에 행과 열로 배치된 복수의 메모리 셀을 포함할 수 있다. 메모리 셀의 각 행의 게이트는 복수의 워드라인 각각에 연결될 수 있다. 메모리 셀의 각 열은 복수의 비트라인 각각에 연결될 수 있다. 다른 실시예에서, 메모리 영역(메모리 블록(2202, 2204) 포함)은 단일 메모리 인스턴스로부터 구성될 수 있다. 본 출원에서, '메모리 인스턴스'라는 용어는 '메모리 블록'과 서로 호환하여 사용될 수 있다. 메모리 인스턴스 (또는 블록)의 특성은 열악할 수 있다. 예를 들어, 메모리에는 포트가 하나밖에 없을 수 있고 랜덤 액세스 지연 이 클 수 있다. 대안적으로 또는 추가적으로, 메모리는 열 및 라인 변경 동안에 접근이 불가능할 수 있고 정정 용량 충전 및/또는 회로 설정 등과 관련된 데이터 접근 문제에 직면할 수 있다. 그러나 도 22에 제시된 아키텍 처는 메모리 인스턴스와 처리부 사이의 전용 연결을 허용하고 블록의 특성을 고려하는 특정 방식으로 데이터를 배치함으로써 메모리 장치의 병렬 처리를 가능하게 한다. 일부 장치 아키텍처에서, 메모리 인스턴스는 여러 포트를 가지고 있어서 병렬 동작이 가능할 수 있다. 그러나 이러한 실시예에서, 칩은 데이터가 칩 아키텍처에 의거하여 컴파일되고 구성되는 경우에 성능 향상을 이룰 수 있다. 예를 들어, 컴파일러는 단일 포트 메모리를 활용하여도 용이하게 접근될 수 있도록 명령을 제공하여 데이 터 배치를 구성함으로써 메모리 영역의 접근 효율을 향상할 수 있다. 또한, 메모리 블록(2202, 2204)은 단일 칩의 메모리에 대해 다중 유형일 수 있다. 예를 들어, 메모리 블록 (2202, 2204)은 eFlash 및 eDRAM일 수 있다. 또한, 메모리 블록은 ROM의 인스턴스를 가진 DRAM을 포함할 수 있 다. 메모리 컨트롤러는 메모리 접근을 처리하고 그 결과를 나머지 모듈로 전달할 논리 회로를 포함할 수 있다. 예를 들어, 메모리 컨트롤러는 어드레스 매니저 및 멀티플렉서와 같은 선택 장치를 포함하여 데이 터를 메모리 블록과 처리부 사이에 전달하고 메모리 블록으로의 접근을 허용할 수 있다. 대안적으로, 메모리 컨 트롤러는 시스템의 메모리 클럭의 상승 에지(rising edge)와 하강 에지(falling edge)에 데이터가 전송되 는 DDR SDRAM의 구동에 사용되는 DDR(double data rate) 메모리 컨트롤러를 포함할 수 있다. 또한, 메모리 컨트롤러는 듀얼 채널(Dual Channel) 메모리 컨트롤러를 구성할 수 있다. 듀얼 채널 메모리 를 도입하면 메모리 컨트롤러에 의한 병렬 접근의 제어가 가능할 수 있다. 병렬 접근 라인은 다중 라인이 함께 사용되는 경우에 서로 동일한 길이가 데이터의 동기화를 가능하게 하도록 구성될 수 있다. 대안적으로 또 는 추가적으로, 병렬 접근 라인은 메모리 뱅크의 다중 메모리 포트의 접근을 허용할 수 있다. 일부 실시예에서, 처리 장치는 처리부에 연결될 수 있는 하나 이상의 멀티플렉서를 포함할 수 있다. 처리 부는 멀티플렉서에 직접 연결될 수 있는 설정 매니저, 로직 블록, 가속기를 포함할 수 있다. 또한, 메모리 컨트롤러는 복수의 메모리 뱅크 또는 블록으로부터의 적어도 하나의 데이터 입력과 복수의 처리부 각각으로 연결된 적어도 하나의 데이터 출력을 포함할 수 있다. 이러한 구성으로, 메모리 컨트롤 러는 두 개의 데이터 입력을 통하여 메모리 뱅크 또는 블록(2202, 2204)으로부터 동시에 데이터를 수신하 고, 적어도 하나의 선택된 처리부를 통하여 수신된 데이터를 두 개의 데이터 출력을 통하여 동시에 전송할 수 있다. 그러나, 일부 실시예에서, 적어도 하나의 데이터 입력과 적어도 하나의 데이터 출력은 읽기 또는 쓰기 동 작만을 허용하는 단일 포트에서 이행될 수 있다. 이러한 실시예에서, 단일 포트는 데이터, 어드레스, 및 명령 라인을 포함하는 데이터 버스로 구현될 수 있다. 메모리 컨트롤러는 복수의 메모리 블록(2202, 2204)의 각각으로 연결될 수 있고, 선택 스위치 등을 통하 여 처리부로도 연결될 수 있다. 또한, 설정 매니저, 로직 블록, 및 가속기를 포함하는 기판 상의 처리부는 메모리 컨트롤러에 개별적으로 연결될 수 있다. 일부 실시예에서, 설정 매니저는 수 행될 작업의 표시를 수신할 수 있고, 이에 대응하여 메모리에 저장되거나 외부에서 제공된 설정에 따라 메모리 컨트롤러, 가속기, 및/또는 로직 블록을 설정할 수 있다. 대안적으로, 메모리 컨트롤러 는 외부 인터페이스에 의해 설정될 수 있다. 작업은 복수의 처리부 중에서 적어도 하나의 처리부를 선택 하는데 사용될 수 있는 적어도 하나의 계산을 필요로 할 수 있다. 대안적으로 또는 추가적으로, 선택은 적어도 하나의 계산을 수행할 수 있는 선택된 처리부의 능력에 적어도 부분적으로의 의거하여 이루어질 수 있다. 이에 대응하여, 메모리 컨트롤러는, 전용 버스를 활용하여 및/또는 파이프라인 된 메모리 접근에서, 메모리 뱅 크에 접근을 허용하거나 적어도 하나의 선택된 처리부와 적어도 두 개의 메모리 뱅크 사이에 데이터를 전달할수 있다. 일부 실시예에서, 적어도 두 개의 메모리 블록의 제1 메모리 블록은 복수의 처리부의 제1측에 배치될 수 있고, 적어도 두 개의 메모리 블록의 제2 메모리 블록은 제1측의 반대편인 복수의 처리부의 제2측에 배치 될 수 있다. 또한, 작업을 수행할 선택된 처리부, 예를 들어, 가속기(2216(n))는 통신 라인이 제1 메모리 뱅크 또는 제1 메모리 블록에 개방된 클럭 사이클 동안에 제2 메모리 뱅크에 접근하도록 설정될 수 있다. 또는, 선택된 처리부는 통신 라인이 제1 메모리 블록에 개방된 클럭 사이클 동안에 제2 메모리 블 록으로 데이터를 전송하도록 설정될 수 있다. 일부 실시예에서, 도 22에 도시된 바와 같이, 메모리 컨트롤러는 개별 요소로 구현될 수 있다. 그러나 다 른 실시예에서, 메모리 컨트롤러는 메모리 영역에 내장되거나 가속기(2216(a)-(n))를 따라 배치될 수 있 다. 처리 장치의 처리 영역은 설정 매니저, 로직 블록 및 가속기(2216(a)-(n))를 포함할 수 있다. 가속기는 기능이 미리 정의된 복수의 처리 회로를 포함할 수 있고 특정 어플리케이션에 의해 정의 될 수 있다. 예를 들어, 가속기는 모듈 사이의 메모리 이동을 취급하는 벡터 MAC 유닛 또는 DMA(Direct Memory Access) 유닛일 수 있다. 가속기는 또한 자체 어드레스를 계산하고 메모리 컨트롤러에 데이터를 요 청하거나 기록할 수 있다. 예를 들어, 설정 매니저는 메모리 뱅크에 접근할 수 있는 가속기의 적어 도 하나에 신호할 수 있다. 이후, 가속기는 메모리 컨트롤러를 설정하여 데이터를 전달하거나 접근 을 허용하도록 할 수 있다. 또한, 가속기는 적어도 하나의 산술 논리부, 적어도 하나의 벡터 처리 논리부, 적어도 하나의 문자열 비교 논리부, 적어도 하나의 레지스터, 및 적어도 하나의 DMA(direct memory access)를 포함할 수 있다. 설정 매니저는 가속기를 설정하고 작업의 실행을 지시하는 디지털 처리 회로를 포함할 수 있다. 예 를 들어, 설정 매니저는 메모리 컨트롤러와 복수의 가속기 각각에 연결될 수 있다. 설정 매 니저에는 가속기의 설정을 저장할 전용 메모리가 있을 수 있다. 설정 매니저는 메모리 뱅크 를 이용하여 메모리 컨트롤러를 통해 명령과 설정을 가져올 수 있다. 또는, 설정 매니저는 외부 인 터페이스를 통하여 프로그램 될 수 있다. 일부 실시예에서, 설정 매니저에는 자체 캐시 체계를 가진 온칩 RISC(reduced instruction set computer) 또는 온칩 복합 CPU가 구현되어 있을 수 있다. 일부 실시예에서, 설 정 매니저가 생략될 수도 있고, 가속기는 외부 인터페이스를 통해 설정될 수 있다. 처리 장치는 또한 외부 인터페이스(미도시)를 포함할 수 있다. 외부 인터페이스는 외부 호스트 또 는 온칩 메인 프로세서로부터 명령을 수신하는 메모리 뱅크 컨트롤러와 같은 상위 레벨로부터 메모리의 접근을 허용하거나 외부 호스트 또는 온칩 메인 프로세서로부터 메모리의 접근을 허용한다. 외부 인터페이스는 나중에 설정 매니저 또는 소자들(2214, 2216)에 의해 사용될 메모리 컨트롤러를 통해 메모리에 설 정 또는 코드를 기록함으로써 설정 매니저와 가속기의 프로그래밍을 허용할 수 있다. 그러나 외부 인터페이스는 또한, 메모리 컨트롤러를 통해 전달되지 않고도 처리부를 직접 프로그램할 수 있다. 설정 매니저가 마이크로컨트롤러인 경우, 설정 매니저는 외부 인터페이스를 통해 메인 메모리로부터 컨 트롤러 로컬 메모리에 코드의 로딩을 허용할 수 있다. 메모리 컨트롤러는 외부 인터페이스로부터의 요청 수신에 대응하여 작업을 중단하도록 설정될 수 있다. 외부 인터페이스는 처리 장치 상의 다양한 요소에 글루리스 인터페이스(glue-less interface)를 제공하는 논리 회로와 연관된 복수의 커넥터를 포함할 수 있다. 외부 인터페이스는 데이터 읽기를 위한 데이터 I/O 입력과 데 이터 쓰기를 위한 출력, 외부 어드레스 출력, 외부 CE0 칩 선택 핀, 액티브 로우 칩 셀렉터(Active-low chip selectors), 바이트 활성화 핀, 메모리 사이클 상의 대기 상대에 대한 핀, 쓰기 활성화 핀, 출력 활성화 핀, 및 읽기-쓰기 활성화 핀을 포함할 수 있다. 따라서, 외부 인터페이스에는 프로세스를 제어하고 처리 장치로부터 정 보를 확보하는 요청된 입력과 출력이 있다. 예를 들어, 외부 장치는 JEDEC DDR 표준을 준수할 수 있다. 대안적 으로 또는 추가적으로, 외부 장치는 SPI／OSPI 또는 UART와 같은 기타 표준을 준수할 수 있다. 일부 실시예에서, 외부 인터페이스는 칩 기판 상에 배치될 수 있고 외부 호스트과 연결될 수 있다. 외부 호스트는 외부 인터페이스를 통해 메모리 블록(2202, 2204), 메모리 컨트롤러, 및 처리부에 대한 접근을 확보할 수 있다. 추가적으로 또는 대안적으로, 외부 호스트는 메모리에 대한 읽기 및 쓰기를 할 수 있고, 읽기 및 쓰기 명령을 통하여 설정 매니저에게 신호를 보내 프로세스의 개시 및/또는 중단과 같은 동작을 수행하게 할 수 있다. 또한, 외부 호스트는 가속기를 직접 설정할 수 있다. 일부 실시예에서, 외부 호스트는 메모리 블록(2202, 2204) 상에서 직접 읽기/쓰기 동작을 수행할 수 있다. 일부 실시예에서, 설정 매니저와 가속기는 대상 작업에 따라 직접 버스를 사용하여 장치 영역을 메 모리 영역과 연결하도록 설정될 수 있다. 예를 들어, 가속기의 서브세트는 가속기의 서브세트가 작업을 실행하기 위해 필요한 계산을 수행할 능력이 있는 경우에 메모리 인스턴스와 연결할 수 있다. 이러한 분 리를 함으로써, 메모리 블록(2202, 2204)에 필요한 대역폭(BW)이 전용 가속기에 확보되도록 할 수 있다. 또한, 메모리 인스턴스를 메모리 컨트롤러로 연결하면 행 지연 시간이 크더라도 서로 다른 메모리의 데이터에 신속하게 접근할 수 있기 때문에, 전용 버스가 있는 이러한 구성은 용량이 큰 메모리를 작은 인스턴스 또는 블 록으로 나누는 것을 가능하게 할 수 있다. 연결의 병렬화를 하기 위해, 메모리 컨트롤러는 데이터, 어드 레스, 및/또는 컨트롤 버스로 메모리 인스턴스의 각각에 연결될 수 있다. 상기에 설명한 바와 같이 메모리 컨트롤러를 포함시키면 처리 장치에 캐시 체계 또는 복합 레지스터 파일 이 없어도 될 수 있다. 캐시 체계를 추가하여 시스템 역량을 강화할 수도 있지만, 처리 장치의 아키텍처 로 인해, 설계자는 처리 동작에 의거하여 충분한 메모리 블록 또는 인스턴스를 추가하고 이에 따라 캐시 체계 없이 인스턴스를 관리할 수 있다. 예를 들어, 처리 장치의 아키텍처로 인해, 파이프라인 된 메모리 접근 을 제거함으로써 캐시 체계가 필요하지 않게 될 수 있다. 파이프라인 된 메모리 접근에서, 처리부는 다른 데이 터 라인이 데이터를 수신 또는 전송하는 동안에 특정 데이터 라인이 개방(또는 활성화)될 수 있는 매 사이클에 지속적인 데이터 흐름을 수신할 수 있다. 개별 통신 라인을 활용한 지속적인 데이터의 흐름으로 인해, 실행 속 도는 향상될 수 있고, 라인 변경으로 인한 지연은 최소화될 수 있다. 또한, 도 22의 기재된 아키텍처는 적은 수의 메모리 블록에서 데이터를 구성하고 라인 변경으로 인한 전력 손실 을 줄일 수 있는 파이프라인 된 메모리 접근을 가능하게 한다. 예를 들어, 일부 실시예에서, 컴파일러는 메모리 뱅크의 데이터 구성 또는 데이터 구성 방법을 호스트와 주고 받고 주어진 작업 동안에 데이터에 대한 접 근을 가능하게 할 수 있다. 이후, 설정 매니저는 어느 메모리 뱅크가(경우에 따라서는 메모리 뱅크의 어 느 포트가) 가속기에 의해 접근될 수 있는지 정의할 수 있다. 메모리 뱅크 내의 데이터 위치와 데이터 접근 방 법 사이의 동기화는 데이터를 최소의 지연으로 가속기에 공급함으로써 전산 작업을 개선한다. 예를 들어, 설정 매니저가 RISC＼CPU를 포함하는 실시예에서, 방법은 오프라인 소프트웨어에서 이행될 수 있고, 이후에 설 정 매니저는 상기 방법을 실행하도록 프로그램 될 수 있다. 방법은 RISC＼\\CPU 컴퓨터에 의해 실행 가능 한 모든 언어로 만들어질 수 있고 모든 플랫폼에서 실행될 수 있다. 방법의 입력은 메모리 컨트롤러 뒤의 메모 리의 설정 및 메모리 접근 패턴과 함께 데이터 자체를 포함할 수 있다. 또한, 방법은 해당 실시예에 특정된 언 어 또는 기계어로 구현될 수 있고, 단순히 이진수 또는 문자로 된 일련의 설정값일 수도 있다. 앞서 설명한 바와 같이, 일부 실시예에서, 컴파일러는 파이프라인 된 메모리 접근에 대비하여 데이터를 메모리 블록(2202, 2204)에 구성하기 위해 호스트로 명령을 제공할 수 있다. 파이프라인 된 메모리 접근은 일반 적으로 복수의 메모리 뱅크 또는 메모리 블록(2202, 2204)의 복수의 어드레스를 수신하는 단계, 수신된 어드레 스에 따라 개별 데이터 라인을 사용하여 복수의 메모리 뱅크에 접근하는 단계, 복수의 메모리 뱅크의 제1 메모 리 뱅크 내에 있는 제1 어드레스로부터 제1 통신 라인을 통하여 복수의 처리부의 적어도 하나로 데이터를 공급 하고 복수의 메모리 뱅크의 제2 메모리 뱅크 내에 있는 제2 어드레스로 제2 통신 라인을 개통하는 단계, 및 제2 어드레스로부터 제2 통신 라인을 통하여 복수의 처리부의 적어도 하나로 데이터를 공급하고 제2 클럭 사 이클 이내에 제1 통신 라인의 제1 메모리 뱅크 내의 제3 어드레스로 제3 통신 라인을 개통하는 단계를 포함할 수 있다. 일부 실시예에서, 파이프라인 된 메모리 접근은 단일 포트에 연결된 두 개의 메모리 블록으로 실행될 수 있다. 이러한 실시예에서, 메모리 컨트롤러는 단일 포트 뒤로 메모리 블록을 숨길 수 있지만 파이프라 인 된 메모리 접근 방식으로 처리부에 데이터를 전송할 수 있다. 일부 실시예에서, 컴파일러는 작업을 실행하기 전에 호스트 상에서 실행될 수 있다. 이러한 실시예에서, 컴파일러가 데이터 흐름의 설정을 이미 알고 있을 수 있기 때문에, 컴파일러는 메모리 장치의 아키텍처에 의거 하여 데이터 흐름의 설정을 판단할 수 있을 수 있다. 다른 실시예에서, 오프라인 시간에 메모리 블록(2204, 2202)의 설정을 모르는 경우, 파이프라인 된 방법은 호스 트에서 실행할 수 있고, 호스트는 계산을 시작하기 전에 메모리 블록에 데이터를 배치할 수 있다. 예를 들어, 호스트는 메모리 블록(2204, 2202)에 직접 데이터를 기록할 수 있다. 이러한 실시예에서, 설 정 매니저와 같은 처리부와 메모리 컨트롤러는 필요한 하드웨어에 관한 정보를 런타임까지 모를 수 있다. 이후, 작업의 실행이 시작될 때까지 가속기의 선택을 지연할 필요가 있을 수 있다. 이러한 상황에 서, 처리부 또는 메모리 컨트롤러는 가속기를 무작위로 선택하고, 작업이 실행되면서 수정될 수 있 는 검사 데이터 접근 패턴을 생성할 수 있다. 그러나 작업을 미리 아는 경우, 컴파일러는 데이터와 명령을 메모리 뱅크 내에 배치하여 호스트가 접근 지연을 최소화하는 신호 연결을 설정 매니저와 같은 처리부에 설정하게 할 수 있다. 예를 들어, 일부의 경우, 가속기는 동시에 n 개의 워드를 필요로할 수 있다. 그러나, 각 메모리 인스턴스는 한 번에 m 개의 워드만 가져오는 것을 지원할 수 있다. 여기서, m과 n은 모두 정수이고, m < n이다. 따라서, 컴파일러는 필요 한 데이터를 서로 다른 메모리 인스턴스 또는 블록에 배치하여 데이터 접근을 가능하게 할 수 있다. 또한, 라인 누락 지연을 방지하기 위해, 호스트는 처리 장치에 다수의 메모리 인스턴스가 있는 경우에 서로 다른 메 모리 인스턴스의 서로 다른 라인에 데이터를 나눌 수 있다. 데이터를 분할하면, 현재의 인스턴스에서 데이터를 계속 사용하면서 다음 인스턴스에 데이터의 다음 라인에 접근하는 것이 가능하다. 예를 들어, 가속기(2216(a))는 두 개의 벡터를 곱하도록 구성될 수 있다. 각 벡터는 메모리 블록(2202, 2204)과 같은 별개의 메모리 블록에 저장될 수 있고, 각 벡터는 다수의 워드를 포함할 수 있다. 따라서, 가속기 (2216(a))에 의한 곱셈을 필요로 하는 작업을 완료하려면, 두 개의 메모리 블록에 접근하고 복수의 워드를 가져 올 필요가 있을 수 있다. 그러나, 일부 실시예에서, 메모리 블록은 클럭 사이클 당 하나의 워드만 접근을 허용 한다. 예를 들어, 메모리 블록에는 단일 포트가 있을 수 있다. 이런 경우, 동작 중의 데이터 전송을 빠르게 하 기 위해, 컴파일러는 벡터를 구성하는 워드를 서로 다른 메모리 블록에 배치하여 워드의 병렬 및/또는 동시 읽 기를 가능하게 할 수 있다. 이런 상황에서, 컴파일러는 전용 라인이 있는 메모리 블록에 워드를 저장할 수 있다. 예를 들어, 각 벡터가 두 개의 워드를 포함하고 메모리 컨트롤러가 4개의 메모리 블록에 직접 접근이 가 능한 경우, 컴파일러는 4개의 메모리 블록에 데이터를 배치하고, 각 메모리 블록은 워드를 전송하고 데이터 전 달을 빠르게 할 수 있다. 또한, 메모리 컨트롤러에 각 메모리 블록으로 단일 연결 이상이 있을 수 있는 실시예에서, 컴파일러는 설정 매니저(또는 다른 처리부)에게 특정 포트로 접근하도록 명령할 수 있다. 이 방법으로, 처리 장치는 파이프라인 된 메모리 접근을 수행하여, 동시에 일부 라인에서 워드를 로딩하고 다른 라인에서 데이터를 전송함으로써 데이터를 처리부로 지속 제공할 수 있다. 도 23은 기재된 실시예에 따른 예시적인 처리 장치의 구성도이다. 구성도는 MAC 유닛, 설정 매니저 (2304; 설정 매니저와 균등 또는 유사), 메모리 컨트롤러(2306; 메모리 컨트롤러와 균등 또는 유사), 및 복수의 메모리 블록(2308(a)-(d)) 형태의 단일 가속기를 표시하는 단순화 된 처리 장치를 도시 한다. 일부 실시예에서, MAC 유닛은 특정 작업을 처리하기 위한 특정 가속기일 수 있다. 예를 들어, 처리 장치 에 2D-컨볼루션 작업이 부여될 수 있다. 이 경우, 설정 매니저는 적절한 하드웨어를 구비한 가속기 에 이 작업과 연관된 계산을 수행하도록 신호를 보낼 수 있다. 예를 들어, MAC 유닛에는 4개의 내부 증가 카운터(internal incrementing counter; 컨볼루션 계산에 필요한 4개의 루프를 관리하기 위한 논리 합산기 (logical adder) 및 레지스터)와 곱셈-누적부(multiply accumulate unit)가 있을 수 있다. 설정 매니저 는 입력되는 데이터를 처리하고 작업을 실행하도록 MAC 유닛에 신호를 보낼 수 있다. 설정 매니저 는 작업을 실행하라는 표시를 MAC 유닛에 전송할 수 있다. 이러한 상황에서, MAC 유닛은 계산된 어 드레스에서 반복하고, 수를 곱하고, 내부 레지스터에 누적할 수 있다. 일부 실시예에서, 메모리 컨트롤러가 전용 버스를 활용하여 블록과 MAC 유닛에 접근을 허용 하는 반면, 설정 매니저는 가속기를 설정할 수 있다. 그러나, 다른 실시예에서, 설정 매니저 또는 외부 인터페이스로부터 수신된 명령에 의거하여 메모리 컨트롤러가 직접 가속기를 설정할 수 있다. 대안 적으로 또는 추가적으로, 설정 매니저는 몇 가지 설정을 미리 로드하고 가속기가 서로 다른 크기를 가진 서로 다른 어드레스 상에서 반복적으로 실행하도록 할 수 있다. 이러한 실시예에서, 설정 매니저는 가속 기와 같은 복수의 처리부의 적어도 하나로 명령이 전송되기 전에 명령을 저장하는 캐시 메모리를 포함할 수 있다. 그러나, 다른 실시예에서, 설정 매니저는 캐시를 포함하지 않을 수 있다. 일부 실시예에서, 설정 매니저 또는 메모리 컨트롤러는 작업을 위해 접근될 필요가 있는 어드레스 를 수신할 수 있다. 설정 매니저 또는 메모리 컨트롤러는 레지스터를 확인하여 메모리 블록 의 하나에 로드된 라인에 이 어드레스가 이미 있는지 여부를 판단할 수 있다. 이 어드레스가 이미 있는 경우, 메모리 컨트롤러는 메모리 블록으로부터 워드를 읽어서 MAC 유닛으로 전달할 수 있다. 로드 된 라인에 이 어드레스가 없는 경우, 설정 매니저는 메모리 컨트롤러에게 이 라인을 로드하도록 요 청하고 MAC 유닛에게 이 어드레스를 가져올 때까지 대기하라는 신호를 보낼 수 있다. 일부 실시예에서, 도 23에 도시된 바와 같이, 메모리 컨트롤러는 두 개의 개별 어드레스로부터 두 개의 입력을 포함할 수 있다. 그러나 둘 이상의 어드레스에 동시에 접근해야 하고, 이러한 어드레스가 단일 메모리블록에 있는 경우(예를 들어, 메모리 블록(2308(a))에만 있는 경우), 메모리 컨트롤러 또는 설정 매니저 는 예외를 둘 수 있다. 또는, 설정 매니저는 두 어드레스가 단일 라인을 통해서만 접근 가능한 경 우에 무효 데이터 신호를 출력할 수 있다. 다른 실시예에서, 유닛은 필요한 모든 데이터를 가져올 수 있을 때까 지 프로세스 실행을 지연할 수 있다. 이로 인해, 전체적인 성능이 저하될 수 있다. 그렇지만, 컴파일러는 지연 을 방지할 수 있는 설정과 데이터 배치를 찾을 수 있다. 일부 실시예에서, 컴파일러는 설정 매니저와 메모리 컨트롤러와 가속기가 단일 메모리 블록 으로부터 다중 어드레스가 접근되어야 하지만 메모리 블록에 포트가 하나뿐인 상황에 대응하도록 설정할 수 있 는 처리 장치에 대한 설정 또는 명령을 생성할 수 있다. 예를 들어, 컴파일러는 처리부가 메모리 블록 의 여러 라인에 접근할 수 있도록 메모리 블록에 데이터를 재배치할 수 있다. 또한, 메모리 컨트롤러는 하나 이상의 입력에 대해 동시에 작용할 수 있다. 예를 들면, 메모리 컨트롤러 는 한 포트를 통하여 메모리 블록의 하나에 접근을 허용하고 다른 입력에서 다른 메모리 블록의 요 청을 수신하면서 데이터를 공급하는 것을 허용할 수 있다. 따라서, 이러한 동작의 결과로, 해당 메모리 블록과 의 통신의 전용 라인으로부터 데이터를 수신하는 예시적인 2D-컨볼루션 작업이 가속기에 부여될 수 있다. 추가적으로 또는 대안적으로, 메모리 컨트롤러 또는 로직 블록은 각 메모리 블록에 대해 리프레쉬 카운터 를 보유하고 모든 라인의 리프레쉬를 처리할 수 있다. 이런 카운터가 있으면, 메모리 컨트롤러가 장치로 부터의 데드 액세스 타임(dead access times) 사이에 리프레쉬 사이클을 삽입할 수 있다. 또한, 메모리 컨트롤러는 파이프라인 된 메모리 접근을 수행하여 데이터를 공급하기 전에 어드레스를 수 신하고 메모리 블록에 라인을 개통하도록 설정하는 것이 가능할 수 있다. 파이프라인 된 메모리 접근은 중단 또 는 지연된 클럭 사이클 없이 데이터를 처리부로 제공할 수 있다. 예를 들어, 메모리 컨트롤러 또는 로직 블록의 하나가 도 23의 우측 라인으로 데이터에 접근하는 반면, 좌측 라인에서 데이터가 전송될 수 있다. 이 방 법에 대해서는 도 26을 참조하여 상세히 설명하기로 한다. 요구되는 데이터에 대응하여, 처리 장치는 멀티플렉서 및/또는 기타 스위칭 장치를 활용하여 어느 장치가 주어진 작업을 수행할지를 선택할 수 있다. 예를 들어, 설정 매니저는 적어도 두 개의 데이터 라인이 MAC 유닛까지 이어지도록 멀티플렉서를 설정할 수 있다. 이로써, 컨볼루션 중에 곱셈을 필요로 하는 벡터 또 는 워드가 단일 클럭에서 동시에 처리부에 도달할 수 있기 때문에, 2D-컨볼루션과 같이 다중 어드레스로부터의 데이터를 필요로 하는 작업의 수행이 빨라질 수 있다. 이러한 데이터 전송 방법으로 인해, 가속기와 같은 처리부는 결과를 신속하게 출력할 수 있다. 일부 실시예에서, 설정 매니저는 작업의 우선순위에 의거하여 프로세스를 실행하도록 설정하는 것이 가능 할 수 있다. 예를 들어, 설정 매니저는 중단 없이 실행 프로세스를 완료하도록 설정될 수 있다. 이 경우, 설정 매니저는 명령 또는 작업의 설정을 가속기에 제공하고, 중단 없이 실행되도록 하고, 작업이 완료된 경우에만 멀티플렉서를 스위치 할 수 있다. 그러나 다른 실시예에서, 설정 매니저는 외부 인터페 이스의 요청과 같은 우선 작업을 수신하는 경우에 작업을 중단하고 데이터 라우팅을 재설정할 수 있다. 그러나 메모리 블록이 충분히 있으면, 메모리 컨트롤러는 작업이 완료될 때까지 변경되지 않아도 되는 전 용 라인이 있는 처리부로 데이터를 라우팅하거나 접근을 허용하도록 설정될 수 있다. 또한, 일부 실시예에서, 모든 장치는 버스에 의해 설정 매니저의 입구로 연결될 수 있고, 장치는 장치와 버스 사이의 접근을 관리 (예, 멀티플렉서와 동일한 로직을 활용)할 수 있다. 따라서, 메모리 컨트롤러는 복수의 메모리 인스턴스 또는 메모리 블록에 직접 연결될 수 있다. 또는, 메모리 컨트롤러는 메모리 서브인스턴스(sub-instance)에 직접 연결될 수 있다. 일부 실시예에서, 각 메모리 인스턴스 또는 블록은 서브인스턴스로부터 구성될 수 있다(예를 들어, DRAM은 개별적인 데이터 라인 이 다중 서브블록(sub-block)으로 배치된 매트로부터 구성될 수 있다). 또한, 인스턴스는 DRAM 매트, DRAM, 뱅 크, 플래시 매트, SRAM 매트, 또는 기타 유형의 메모리를 포함할 수 있다. 이후, 메모리 컨트롤러는 어드 레스 서브인스턴스로의 전용 라인을 포함하여 파이프라인 된 메모리 접근 중의 지연을 직접 최소화할 수 있다. 일부 실시예에서, 메모리 컨트롤러는 또한 특정 메모리 인스턴스에 필요한 로직(로우/컬럼 디코더, 리프 레쉬 로직 등)을 구비하고, 메모리 블록은 자체 로직을 처리할 수 있다. 따라서, 메모리 블록은 어 드레스를 확보하고 출력/기록 데이터에 대한 명령을 생성할 수 있다. 도 24는 기재된 실시예에 따른 예시적인 메모리 구성도를 도시한다. 일부 실시예에서, 처리 장치에 대한 코드 또는 설정을 생성하는 컴파일러는 데이터를 각 메모리 블록에 사전 배치하여 메모리 블록(2202, 2204)으로부터 로딩을 설정하는 방법을 수행할 수 있다. 예를 들어, 컴파일러는 작업에 필요한 각 워드가 메모리 인스턴 스 또는 메모리 블록의 라인에 상호 연관되도록 데이터를 사전 배치할 수 있다. 그러나 처리 장치의 사용 가능한 메모리 블록보다 많은 메모리 블록을 필요로 하는 작업에 대해, 컴파일러는 각 메모리 블록의 하나 이상 의 메모리 위치에 데이터를 맞추는 방법을 이행할 수 있다. 컴파일러는 또한 데이터를 시퀀스로 저장하고, 라인 누락 지연을 피하기 위해 각 메모리 블록의 지연을 평가할 수 있다. 일부 실시예에서, 호스트는 설정 매니저 와 같은 처리부의 일부일 수 있지만, 다른 실시예에서, 컴파일러 호스트는 외부 인터페이스를 통해 처리 장치에 연결될 수 있다. 이러한 실시예에서, 호스트는 컴파일러에 대해 설명한 것과 같은 컴파일링 기능 을 실행할 수 있다. 일부 실시예에서, 설정 매니저는 CPU 또는 마이크로컨트롤러(uC)일 수 있다. 이러한 실시예에서, 설정 매 니저는 메모리에 접근하여 메모리에 배치된 명령을 가져와야 할 수 있다. 특정 컴파일러는 연속 명령이 동일 메모리 라인과 다수의 메모리 뱅크에 저장되어 가져온 명령에 대한 파이프라인 된 메모리 접근이 허용되도 록 하는 방식으로 코드를 생성하고 메모리에 배치할 수 있다. 이러한 실시예에서, 설정 매니저와 메모리 컨트롤러는 파이프라인 된 메모리 접근을 가능하게 함으로써 선형 실행에서 행 지연을 방지하는 것이 가 능할 수 있다. 프로그램의 선형 실행의 이전 경우의 방법에서는, 컴파일러가 명령을 인지하고 배치하여 파이프라인 된 메모리 실행을 하였다. 그러나 다른 소프트웨어 구조는 더 복잡할 수 있고 컴파일러가 명령을 인지하고 그에 따라 동작 하는 것이 요구될 수 있다. 예를 들어, 작업에 루프와 브랜치(branches)가 필요한 경우, 컴파일러는 모든 루프 코드를 단일 라인 내부에 배치하여 단일 라인이 라인 개통 지연 없이 반복되게 할 수 있다. 이에 따라, 메모리 컨트롤러는 실행 중에 라인을 변경할 필요가 없을 수 있다. 일부 실시예에서, 설정 매니저는 내부 캐싱 또는 소형 메모리를 포함할 수 있다. 내부 캐싱은 설정 매니 저에 의해 실행되는 명령을 저장하여 브랜치와 루프를 처리할 수 있다. 예를 들어, 내부 캐싱 메모리의 명령은 메모리 블록에 접근하기 위해 가속기를 설정하는 명령을 포함할 수 있다. 도 25는 기재된 실시예에 따른 메모리 설정 프로세스를 도시한 예시적인 순서도이다. 메모리 설정 프로세 스 설명의 편의상, 앞서 설명한 도 22에 도시된 구성요소가 참조될 수 있다. 일부 실시예에서, 프로세스 는 외부 인터페이스를 통해 연결된 호스트로 명령을 제공하는 컴파일러에 의해 실행될 수 있다. 다른 실 시예에서, 프로세스는 설정 매니저와 같은 처리 장치의 구성요소에 의해 실행될 수 있다. 일반적으로, 프로세스는 작업의 수행을 위해 동시에 필요한 워드의 수를 판단하는 단계, 복수의 메모리 뱅크 각각으로부터 동시에 접근될 수 있는 워드의 수를 판단하는 단계, 및 동시에 필요한 워드의 수가 동시에 접근될 수 있는 워드의 수보다 큰 경우에 동시에 필요한 워드의 수를 다중 메모리 뱅크 사이에 분할하는 단계를 포함할 수 있다. 또한, 동시에 필요한 워드의 수를 분할하는 단계는 사이클릭(cyclic) 구조의 워드를 실행하는 단계 및 메모리 뱅크 당 한 워드를 순차적으로 배정하는 단계를 포함할 수 있다. 더욱 구체적으로, 프로세스는 컴파일러가 작업 사양을 수신할 수 있는 단계 2502로 시작할 수 있다. 이 사양은 요구되는 계산 및/또는 우선순위 레벨을 포함할 수 있다. 단계 2504에서, 컴파일러는 작업을 수행할 수 있는 가속기 또는 가속기의 그룹을 식별할 수 있다. 또는, 컴파일 러는 작업을 수행할 가속기를 설정 매니저와 같은 처리부가 식별할 수 있도록 명령을 생성할 수 있다. 예 를 들어, 요구되는 계산을 활용하여, 설정 매니저는 가속기의 그룹에서 작업을 수행할 수 있는 가속기를 식별할 수 있다. 단계 2506에서, 컴파일러는 작업을 실행하기 위해 동시에 접근돼야 하는 워드의 수를 판단할 수 있다. 예를 들 어, 두 벡터의 곱셈을 하려면 적어도 두 벡터에 접근해야 하고, 따라서 컴파일러는 연산을 수행하기 위해 벡터 워드가 동시에 접근돼야 한다고 판단할 수 있다. 단계 2508에서, 컴파일러는 작업을 실행하기 위해 필요한 사이클의 수를 판단할 수 있다. 예를 들면, 4개의 부 수곱(by-product)의 컨볼루션 연산이 작업에 필요한 경우, 컴파일러는 작업을 수행하기 위해 적어도 4 사이클이 필요할 것이라고 판단할 수 있다. 단계 2510에서, 컴파일러는 동시에 접근될 필요가 있는 워드를 서로 다른 메모리 뱅크에 배치할 수 있다. 이로 써, 메모리 컨트롤러는, 캐시에 저장된 데이터가 필요 없이, 서로 다른 메모리 인스턴스로 라인을 개통하 고 필요한 메모리 블록에 클럭 사이클 이내에 접근하도록 설정될 수 있다. 단계 2512에서, 컴파일러는 순차적으로 접근되는 워드를 동일한 메모리 뱅크에 배치할 수 있다. 예를 들어, 4 사이클의 연산이 필요한 경우, 컴파일러는 실행 중에 서로 다른 메모리 블록 사이의 라인 변경을 방지하기 위하 여 단일 메모리 블록에 순차적 사이클로 필요한 워드를 쓰도록 하는 명령을 생성할 수 있다. 단계 2514에서, 컴파일러는 설정 매니저와 같은 처리부를 프로그램하는 명령을 생성할 수 있다. 명령은 스위칭 장치(예, 멀티플렉서)를 작동하거나 데이터 버스를 설정하는 조건을 명시할 수 있다. 이러한 명령으로, 설정 매니저는 메모리 컨트롤러가 작업에 따른 전용 통신 라인을 활용하여 데이터를 메모리 블록에 서 처리부로 라우팅하거나 메모리 블록에 대한 접근을 허용하도록 설정할 수 있다. 도 26은 기재된 실시예에 따른 메모리 읽기 프로세스를 도시한 예시적인 순서도이다. 메모리 읽기 프로세 스 설명의 편의상, 앞서 설명한 도 22에 도시된 구성요소가 참조될 수 있다. 일부 실시예에서, 하기에 설 명하는 바와 같이, 프로세스는 메모리 컨트롤러에 의해 이행될 수 있다. 그러나 다른 실시예에서, 프로세스는 설정 매니저와 같은 처리 장치의 다른 구성요소에 의해 이행될 수 있다. 단계 2602에서, 메모리 컨트롤러, 설정 매니저, 또는 기타 처리부는 메모리 뱅크로 데이터를 라우 팅하거나 메모리 뱅크에 대한 접근을 허용하도록 하는 요청을 수신할 수 있다. 이 요청은 어드레스와 메모리 블 록을 명시할 수 있다. 일부 실시예에서, 상기 요청은 라인 2218의 읽기 명령 및 라인 2220의 어드레스를 명시하는 데이터 버스를 통해 수신될 수 있다. 다른 실시예에서, 상기 요청은 메모리 컨트롤러에 연결된 디멀티플렉서를 통해 수신될 수 있다. 단계 2604에서, 설정 매니저, 호스트, 또는 기타 처리부는 내부 레지스터를 쿼리할 수 있다. 내부 레지스 터는 메모리 뱅크로 개통된 라인, 개통된 어드레스, 개통된 메모리 블록, 및/또는 다음 작업에 관한 정보를 포 함할 수 있다. 내부 레지스터에 있는 정보에 의거하여, 메모리 뱅크로 개통된 라인이 있는지 여부 및/또는 메모 리 블록이 단계 2602에서 요청을 수신했는지 여부가 판단될 수 있다. 대안적으로 또는 추가적으로, 메모리 컨트 롤러가 직접 내부 레지스터를 쿼리할 수 있다. 개통된 라인에 메모리 뱅크가 로딩되어 있지 않다고 내부 레지스터가 나타내는 경우(즉, 단계 2606에서 '아니오'), 프로세스는 단계 2616으로 진행하여 수신된 어드레스와 연관된 메모리 뱅크로 라인이 로딩될 수 있다. 또한, 메모리 컨트롤러 또는 설정 매니저와 같은 처리부는 단계 2616에서 메모리 어드레 스로부터 정보를 요청하는 구성요소로 지연 신호를 보낼 수 있다. 예를 들어, 가속기가 이미 사용중인 메 모리 블록에 위치한 메모리 정보를 요청하는 경우, 메모리 컨트롤러는 단계 2618에서 가속기로 지연 신호 를 보낼 수 있다. 단계 2620에서, 설정 매니저 또는 메모리 컨트롤러는 내부 레지스터를 업데이트 하여 새로운 메모리 뱅크 또는 새로운 메모리 블록으로 라인이 개통됐음을 나타낼 수 있다. 개통된 라인에 메모리 뱅크가 로딩되어 있다고 내부 레지스터가 나타내는 경우(즉, 단계 2606에서 '예'), 프로 세스는 단계 2608로 진행할 수 있다. 단계 2608에서, 메모리 뱅크에 로딩된 라인이 다른 어드레스에 사용 되고 있는지 여부가 판단될 수 있다. 라인이 다른 어드레스에 사용되고 있는 경우(즉, 단계 2608에서 '예'), 단 일 블록에 두 인스턴스가 있는 것을 나타내는 것일 수 있으므로, 동시에 접근될 수 없다. 따라서, 단계 2616에 서 메모리 어드레스로부터 정보를 요청하는 구성요소로 오류 또는 면제 신호가 전송될 수 있다. 그러나 라인이 다른 어드레스에 사용되고 있지 않은 경우(즉, 단계 2608에서 '아니오'), 라인이 어드레스에 대해 개통될 수 있 고 타깃 메모리 뱅크로부터 데이터를 가져오고 단계 2614로 진행하여 메모리 어드레스로부터 정보를 요청하는 구성요소로 데이터를 전송할 수 있다. 프로세스를 통해, 처리 장치는 작업을 수행하는데 필요한 정보를 포함하는 메모리 블록 또는 메모 리 인스턴스와 처리부 사이의 직접 연결을 구축할 수 있다. 이러한 데이터의 구성으로 인해, 서로 다른 메모리 인스턴스 내에 구성된 벡터로부터 정보를 읽는 것이 가능할 뿐만 아니라 장치가 복수의 이런 어드레스를 요청하 는 경우에 서로 다른 메모리 블록으로부터 동시에 정보를 가져오는 것이 가능할 수 있다. 도 27은 기재된 실시예에 따른 실행 프로세스를 도시한 예시적인 순서도이다. 실행 프로세스 설명 의 편의상, 앞서 설명한 도 22에 도시된 구성요소가 참조될 수 있다. 단계 2702에서, 컴파일러 또는 설정 매니저와 같은 로컬 유닛은 수행되어야 하는 작업의 요청을 수신할 수 있다. 작업은 단일 연산(예, 곱셈) 또는 복합 연산(예, 행렬 사이의 컨볼루션)을 포함할 수 있다. 작업은 또 한 필요한 계산을 나타낼 수 있다. 단계 2704에서, 컴파일러 또는 설정 매니저는 작업을 수행하기 위해 동시에 요구되는 워드의 수를 판단할 수 있다. 예를 들어, 설정 매니저 또는 컴파일러는 벡터 사이의 곱셈을 수행하기 위해 두 워드가 동시에 필요하 다고 판단할 수 있다. 다른 예로써, 2D 컨볼루션 작업에서, 설정 매니저는 'n'과 'm'이 각각 행렬 차원인 'n' 곱하기 'm'의 워드가 행렬 사이의 컨볼루션을 위해 필요하다고 판단할 수 있다. 단계 2704에서, 설정 매니 저는 또한 작업을 수행하기 위해 필요한 사이클의 수를 판단할 수 있다. 단계 2706에서, 단계 2704의 판단에 따라, 컴파일러는 동시에 접근되어야 하는 워드를 기판 상에 배치된 복수의 메모리 뱅크에 기록할 수 있다. 예를 들어, 복수의 메모리 뱅크로부터 동시에 접근될 수 있는 워드의 수가 동시 에 필요한 워드의 수보다 적은 경우, 컴파일러는 데이터를 다중 메모리 뱅크에 배치하여 필요한 서로 다른 워드 에 클럭 이내에 접근 가능하게 할 수 있다. 또한, 작업을 수행하기 위해 여러 사이클이 필요하다고 설정 매니저 또는 컴파일러가 판단하는 경우, 컴파일러는 필요한 워드를 순차적 사이클로 복수의 메모리 뱅크의 단일 메모리 뱅크에 기록하여 메모리 뱅크 사이의 라인 변경을 방지할 수 있다. 단계 2708에서, 메모리 컨트롤러는 제1 메모리 라인을 이용하여 복수의 메모리 뱅크 또는 블록의 제1 메 모리 뱅크에서 적어도 하나의 제1 워드를 읽거나 적어도 하나의 제1 워드에 대한 접근을 허용하도록 설정될 수 있다. 단계 2170에서, 가속기의 하나와 같은 처리부는 적어도 하나의 제1 워드를 활용하여 작업을 처리할 수 있 다. 단계 2712에서, 메모리 컨트롤러는 제2 메모리 뱅크에 제2 메모리 라인을 개통하도록 설정될 수 있다. 예 를 들어, 작업에 의거하고 파이프라인 된 메모리 접근 방식을 활용하여, 메모리 컨트롤러는 작업에 필요 한 정보가 단계 2706에서 기록된 제2 메모리 블록에 제2 메모리 라인을 개통하도록 설정될 수 있다. 일부 실시 예에서, 제2 메모리 라인은 단계 2170의 작업이 완료되려는 시점에 개통될 수 있다. 예를 들어, 작업에 100 클 럭이 필요한 경우, 제2 메모리 라인은 90번째 클럭에서 개통될 수 있다. 일부 실시예에서, 단계 2708 내지 단계 2712는 하나의 라인 액세스 사이클 이내에 실행될 수 있다. 단계 2714에서, 메모리 컨트롤러는 단계 2710에서 개통된 제2 메모리 라인을 활용하여 제2 메모리 뱅크의 적어도 하나의 제2 워드의 데이터에 대한 접근을 허용하도록 설정될 수 있다. 단계 2176에서, 가속기의 하나와 같은 처리부는 적어도 하나의 제2 워드를 활용하여 작업을 처리할 수 있 다. 단계 2718에서, 메모리 컨트롤러는 제1 메모리 뱅크에 제2 메모리 라인을 개통하도록 설정될 수 있다. 예 를 들어, 작업에 의거하고 파이프라인 된 메모리 접근 방식을 활용하여, 메모리 컨트롤러는 제1 메모리 블록으로의 제2 메모리 라인을 개통하도록 설정될 수 있다. 일부 실시예에서, 제1블록으로의 제2 메모리 라인은 단계 2176의 작업이 완료되려는 시점에 개통될 수 있다. 일부 실시예에서, 단계 2714 내지 단계 2718은 하나의 라인 액세스 사이클 이내에 실행될 수 있다. 단계 2720에서, 메모리 컨트롤러는 제1 뱅크의 제2 메모리 라인 또는 제3 뱅크의 제1라인을 활용하고 다른 메모 리 뱅크로 진행하여 복수의 메모리 뱅크의 제1 메모리 뱅크에서 적어도 하나의 제3 워드를 읽거나 적어도 하나 의 제3 워드에 대한 접근을 허용할 수 있다. DRAM 칩과 같은 일부 메모리 칩은 칩의 커패시터 또는 기타 전기 부품의 전압 쇠퇴로 인해 저장된 데이터(예, 전기용량 활용)가 손실되는 것을 방지하기 위해 리프레시를 활용한다. 예를 들어, DRAM에서, 각 셀은 데이터가 손실되거나 손상되지 않도록 커패시터에 전하를 복원하기 위하여 수시로(특정 프로세스 또는 설계에 의거) 리프 레시 되어야 한다. DRAM 칩의 메모리 용량이 증가함에 따라, 메모리를 리프레시 하는데 상당한 양의 시간이 요 구된다. 특정 라인의 메모리가 리프레시 되고 있는 시한 동안에, 리프레시 되고 있는 라인을 포함하는 뱅크에는 접근이 불가능하다. 이는 성능 저하로 이어질 수 있다. 또한, 리프레시 프로세스와 연관된 전력 또한, 상당해진 다. 종전에는 메모리 리프레시와 연관된 역효과를 줄이기 위해 리프레시가 수행되는 비율을 줄이려고 노력하였 지만, 이러한 노력의 대부분은 DRAM의 물리적 레이어에만 집중하였다. 리프레시 동작은 메모리의 행을 읽고 다시 쓰는 것과 비슷하다. 이 원리를 활용하고 메모리로의 접근 패턴에 집 중하여, 본 개시의 실시예들은 리프레시에 전력을 덜 사용하고 메모리가 리프레시 되는 소요 시간을 줄이기 위 해 소프트웨어 및 하드웨어 방식 및 메모리 칩의 수정을 포함한다. 예를 들어, 개요를 설명하면, 일부 실시에는 하드웨어 및/또는 소프트웨어를 사용하여 라인 액세스 타이밍을 추적하고 리프레시 사이클 이내의(예, 타이밍임계값에 의거하여) 최근에 접근된 행을 건너뛸 수 있다. 다른 예에서, 일부 실시예는 메모리 칩의 리프레시 컨 트롤러에 의해 실행된 소프트웨어에 의존하여 메모리로의 접근이 무작위가 아니 되도록 읽기와 쓰기를 배정할 수 있다. 이에 따라, 소프트웨어는 리프레시를 더욱 정교하게 제어하여 낭비되는 리프레시 사이클 및/또는 라인 을 방지할 수 있다. 이러한 방법들은 단독으로 사용되거나 프로세서에 대한 머신 코드와 함께 리프레시 컨트롤 러에 대한 명령을 인코딩하는 컴파일러와 함께 사용되어 메모리로의 접근이 역시 무작위가 아니 되도록 한다. 하기에 상세히 설명하는 이러한 방법 및 구성의 모든 임의의 조합을 활용하여, 개시된 실시예들은 메모리 유닛 이 리프레시 되는 소요 시간을 줄임으로써 메모리 리프레시 전력 요구를 감소 및/또는 시스템 성능을 향상시킬 수 있다. 도 28은 본 개시에 따른 리프레시 컨트롤러를 포함하는 예시적인 메모리 칩을 도시한 것이다. 예를 들어, 메모리 칩은 기판 상에 복수의 메모리 뱅크(예, 메모리 뱅크(2801a) 등)를 포함할 수 있다. 도 28 의 예에서, 기판은 4개의 메모리 뱅크를 포함하고, 각 메모리 뱅크에는 4개의 라인이 있다. 라인은 메모리 칩 의 하나 이상의 메모리 뱅크 내의 워드라인 또는, 메모리 뱅크 또는 메모리 뱅크의 그룹을 따라 있는 행 의 일부 또는 전체와 같은, 메모리 칩 내의 메모리 셀의 모든 임의의 다른 모음을 의미할 수 있다. 다른 실시예에서, 기판은 모든 임의의 수의 메모리 뱅크를 포함할 수 있고, 각 메모리 뱅크는 모든 임의의 수의 라인을 포함할 수 있다. 일부 메모리 뱅크는 동일할 수의 라인을 포함할 수 있는 반면에(예, 도 28의 경우), 다 른 메모리 뱅크는 상이한 수의 라인을 포함할 수 있다. 도 28에 도시된 바와 같이, 메모리 칩은 컨트롤러 를 포함하여 메모리 칩으로 입력을 수신하고 메모리 칩으로부터 출력을 전송할 수 있다(상기 에 '코드의 분할'에서 설명). 일부 실시예에서, 복수의 메모리 뱅크는 DRAM(dynamic random access memory)을 포함할 수 있다. 그러나 복수 의 메모리 뱅크는 주기적인 리프레시를 필요로 하는 데이터를 저장하는 모든 임의의 휘발성 메모리를 포함할 수 있다. 하기에 더 상세히 설명하는 바와 같이, 개시된 실시예들은 카운터 또는 저항-커패시터 회로를 이용하여 리프레 시 사이클의 타이밍을 수행할 수 있다. 예를 들어, 카운터 또는 타이머를 활용하여 마지막 완전 리프레시 사이 클 이후의 시간을 잰 후에 카운터가 목표값에 도달하는 경우에 다른 카운터를 활용하여 모든 행에 걸쳐 반복할 수 있다. 본 개시의 실시예들은 추가적으로 메모리 칩의 세그먼트로의 접근을 추적하고 필요한 리프레시 전력을 줄일 수 있다. 예를 들면, 도 28에는 도시되어 있지 않지만, 메모리 칩은 복수의 메모리 뱅크의 하나 이상의 세그먼트에 대한 접근 동작을 나타내는 접근 정보를 저장하도록 구성된 데이터 스토리지를 더 포함 할 수 있다. 예컨대, 하나 이상의 세그먼트는 메모리 칩 내의 메모리 셀의 라인, 열, 또는 모든 임의의 다른 그룹의 모든 임의의 부분을 포함할 수 있다. 한 특정 예에서, 하나 이상의 세그먼트는 복수의 메모리 뱅크 내의 메모리 구조의 적어도 한 행을 포함할 수 있다. 리프레시 컨트롤러는 적어도 부분적으로는 저장된 접근 정보에 의거하여 하나 이상의 세그먼트의 리프레시 동작을 수행하도록 구성될 수 있다. 예를 들어, 데이터 스토리지는 메모리 칩의 세그먼트(예, 메모리 칩 내의 메모리 셀의 라인, 열, 또는 모든 임의의 기타 그룹)와 연관된 하나 이상의 레지스터, SRAM 셀 등을 포함할 수 있다. 또한, 데이터 스 토리지는 연관된 세그먼트가 하나 이상의 이전 사이클에서 접근되었는지 여부를 나타내는 비트를 저장하도록 구 성될 수 있다. '비트'는 레지스터, SRAM 셀, 비휘발성 메모리 등과 같은 적어도 하나의 비트를 저장하는 모든 임의의 데이터 구조를 포함할 수 있다. 또한, 비트는 데이터 구조의 상응하는 스위치(또는 트랜지스터와 같은 스위칭 요소)를 ON('1' 또는 'true'와 동등할 수 있음)으로 설정하여 설정될 수 있다. 추가적으로, 또는 대안적 으로, 비트는 데이터 구조에 '1'(또는 비트의 설정을 나타내는 모든 임의의 다른 값)을 쓰기 위하여 데이터 구 조 내의 모든 임의의 다른 성질을 수정(예, 플래시 메모리의 플로팅 게이트를 충전, SRAM 내의 하나 이상의 플 립플롭의 상태를 수정 등)하여 설정될 수 있다. 비트가 메모리 컨트롤러의 리프레시 동작의 일부로 설정된 것으 로 판단되는 경우, 리프레시 컨트롤러는 연관된 세그먼트의 리프레시 사이클을 건너뛰고 해당 부분과 연 관된 레지스터를 비울 수 있다. 다른 예에서, 데이터 스토리지는 메모리 칩의 세그먼트(예, 메모리 칩 내의 메모리 셀의 라인, 열, 또는 모든 임의의 기타 그룹)와 연관된 하나 이상의 비휘발성 메모리(예, 플래시 메모리 등)를 포함할 수 있다. 비휘발성 메모리는 연관된 세그먼트가 하나 이상의 이전 사이클에서 접근되었는지 여부를 나타내는 비트를 저장 하도록 구성될 수 있다. 일부 실시예는, 추가적으로 또는 대안적으로, 라인이 접근된 현재의 리프레시 사이클 내의 마지막 틱(tick)을 가지고 있는 각 행 또는 행의 그룹(또는 메모리 칩의 다른 세그먼트) 상에 타임스탬프 레지스터를 추가할수 있다. 이는 각 행 접근에서 리프레시 컨트롤러가 행 타임스탬프 레지스터를 업데이트 할 수 있음을 의미한다. 따라서, 다음번에 리프레시가 발생할 때에(예, 리프레시 사이클의 끝), 리프레시 컨트롤러는 저장된 타임스탬프를 비교하고, 연관된 세그먼트가 이전에 특정 시간 주기 이내에(예, 저장된 타임스탬프에 적용된 것 과 같은 특정 임계값 이내에) 접근된 경우, 리프레시 컨트롤러는 다음 세그먼트로 건너뛸 수 있다. 이는 시스템 이 최근에 접근된 세그먼트에 리프레시 전력을 사용하는 것을 방지한다. 또한, 리프레시 컨트롤러는 각 세그먼 트가 다음 사이클에서 접근되거나 리프레시 되도록 접근의 추적을 계속할 수 있다. 이에 따라, 또 다른 예에서, 데이터 스토리지는 메모리 칩의 세그먼트(예, 메모리 칩 내의 메모리 셀의 라인, 열, 또는 모든 임의의 기타 그룹)와 연관된 하나 이상의 레지스터 또는 비휘발성 메모리를 포함할 수 있다. 비트를 사용하여 연관 세그먼트가 접근되었는지 여부를 나타내기보다, 레지스터 또는 비휘발성 메모리 는 연관 세그먼트의 가장 최근 접근을 나타내는 타임스탬프 또는 기타 정보를 저장하도록 구성될 수 있다. 이러 한 예에서, 리프레시 컨트롤러는 연관 레지스터 또는 메모리에 저장된 타임스탬프와 현재 시각 사이의 시 간의 양(예, 하기의 도 29a 및 도 29b에 설명하는 바와 같은 타이머로부터의 시간)이 미리 정해진 임계값(예, 8ms, 16ms, 32ms, 64ms 등)을 초과하는지 여부에 의거하여 연관 세그먼트를 리프레시 할지 또는 접근할 지 여부 를 판단할 수 있다. 이에 따라, 미리 정해진 임계값은 연관 세그먼트가 리프레시 사이클마다 적어도 한 번씩 리프레시(접근이 아닌 경우) 되도록 하는 리프레시 사이클에 대한 시간의 양을 포함할 수 있다. 대안적으로, 미리 정해진 임계값은 리 프레시 사이클에 필요한 시간보다 짧은 시간의 양을 포함할 수 있다(예, 모든 임의의 요구되는 리프레시 또는 접근 신호가 리프레시 사이클이 완료되기 전에 연관 세그먼트에 도달하게 하기 위함). 예를 들어, 미리 정해진 시간은 리프레시 주기가 8ms인 메모리 칩에 대해 7ms일 수 있고, 이로써 세그먼트가 7ms 이내에 접근되지 않으 면 리프레시 컨트롤러가 8ms 리프레시 주기의 종료 전에 세그먼트에 도착하는 리프레시 또는 접근 신호를 전송 하게 될 수 있다. 일부 실시예에서, 미리 정해진 임계값은 연관 세그먼트의 크기에 달려있을 수 있다. 예를 들 어, 미리 정해진 임계값은 메모리 칩의 세그먼트가 작을수록 작아질 수 있다. 상기에서는 메모리 칩을 참조하여 설명하였지만, 본 개시의 리프레시 컨트롤러는 앞서 설명하고 본 개시 전반에 걸쳐 설명하는 것과 같은 분산 프로세서 아키텍처에서도 사용될 수 있다. 이러한 아키텍처의 일례가 도 7a에 도 시되어 있다. 이러한 실시예에서, 메모리 칩과 동일한 기판은, 도 7a에 도시된 바와 같은, 그 위에 배치 된 복수의 프로세싱 그룹을 포함할 수 있다. 앞서 도 3a를 참조하여 설명한 바와 같이, '프로세싱 그룹'은 둘 이상의 프로세서 서브유닛 및 이 서브유닛에 상응하는 기판 상의 메모리 뱅크를 의미할 수 있다. 프로세싱 그룹 은 기판 상의 공간적 분산 및/또는 메모리 칩 상의 실행을 위한 코드의 컴파일링 목적의 논리적 그루핑을 나타낼 수 있다. 이에 따라, 기판은 도 28에 도시된 뱅크(2801a)와 기타 뱅크와 같은 복수의 뱅크를 포함하는 메모리 어레이를 포함할 수 있다. 또한, 기판은 복수의 프로세서 서브유닛(예, 도 7a에 도시된 서브유닛(730a, 730b, 730c, 730d, 730e, 730f, 730g, 730h ))을 포함할 수 있는 프로세싱 어레이를 포함할 수 있다. 앞서 도 7a를 참조하여 더 설명한 바와 같이, 각 프로세싱 그룹은 프로세서 서브유닛 및 서브유닛 전용의 상응 하는 하나 이상의 메모리 뱅크를 포함할 수 있다. 또한, 각 프로세서 서브유닛이 상응하는 전용 메모리 뱅크와 통신할 수 있게 하기 위하여, 기판은 프로세서 서브유닛 중의 하나를 그에 상응하는 전용 메모리 뱅크로 연결하 는 제1 복수의 버스를 포함할 수 있다. 이러한 실시예에서, 도 7a에 도시된 바와 같이, 기판은 각 프로세서 서브유닛을 적어도 하나의 다른 프로세서 서브유닛(예, 동일 행의 인접 서브유닛, 동일 열의 인접 프로세서 서브유닛, 또는 기판 상의 모든 임의의 다른 프로세서 서브유닛)과 연결하기 위한 제2 복수의 버스를 포함할 수 있다. 앞서 '소프트웨어를 활용한 동기화' 부분에서 설명한 바와 같이, 프로세서 서브유닛 사이와 복수의 버스의 상응하는 버스를 통한 데이터 전달이 타 이밍 하드웨어 로직 요소에 의해 제어되지 않도록 제1 및/또는 제2 복수의 버스에는 타이밍 하드웨어가 없을 수 있다. 메모리 칩과 동일한 기판이 그 위에 배치된 복수의 프로세싱 그룹(예, 도 7a에 도시)을 포함할 수 있는 실시예에서, 프로세서 서브유닛은 어드레스 생성기(예, 도 4에 도시된 어드레스 생성기)를 더 포함할 수 있다. 또한, 각 프로세싱 그룹은 프로세서 서브유닛 및 서브유닛 전용의 상응하는 하나 이상의 메모리 뱅크를 포함할 수 있다. 이에 따라, 어드레스 생성기 각각은 복수의 메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관 될 수 있다. 또한, 기판은 복수의 어드레스 생성기 중의 하나를 그에 상응하는 전용 메모리 뱅크로 각각 연결하 는 복수의 버스를 포함할 수 있다. 도 29a는 본 개시에 따른 예시적인 리프레시 컨트롤러를 도시한 것이다. 리프레시 컨트롤러는 도 28의 메모리 칩과 같은 본 개시의 메모리 칩에 포함될 수 있다. 도 29a에 도시된 바와 같이, 리프레시 컨 트롤러는 온칩 발진기(on-chip oscillator) 또는 리프레시 컨트롤러를 위한 모든 임의의 기타 타이 밍 회로를 포함할 수 있는 타이머를 포함할 수 있다. 도 29a에 도시된 구성에서, 타이머는 리프레 시 사이클을 주기적으로(예, 8ms, 16ms, 32ms, 64ms 등 마다) 촉발할 수 있다. 리프레시 사이클은 로우 카운터 를 활용하여 상응하는 메모리 칩의 모든 행을 통해 사이클을 하고 합산기를 활성 비트와 함 께 활용하여 각 행에 대한 리프레시 신호를 생성할 수 있다. 도 29a에 도시된 바와 같이, 비트는 각 행이 한 사이클 동안에 확실히 리프레시 되도록 하기 위해 1('true')에 고정될 수 있다. 본 개시의 실시예에서, 리프레시 컨트롤러는 데이터 스토리지를 포함할 수 있다. 앞서 설명한 바와 같이, 데이터 스토리지는 메모리 칩의 세그먼트(예, 메모리 칩 내의 메모리 셀의 라인, 열, 또는 모든 임 의의 기타 그룹)와 연관된 하나 이상의 레지스터 또는 비휘발성 메모리를 포함할 수 있다. 레지스터 또는 비휘 발성 메모리는 연관 세그먼트의 가장 최근 접근을 나타내는 타임스탬프 또는 기타 정보를 저장하도록 구성될 수 있다. 리프레시 컨트롤러는 저장된 정보를 활용하여 메모리 칩의 세그먼트에 대한 리프레시를 건너뛸 수 있다. 예를 들어, 어떤 세그먼트가 하나 이상의 이전 리프레시 사이클 동안에 리프레시 되었다고 저장된 정보가 나타내는 경우에 리프레시 컨트롤러는 현 리프레시 사이클에서 해당 세그먼트를 건너뛸 수 있다. 다른 예 에서, 어떤 세그먼트에 대한 저장된 타임스탬프와 현재 시각 사이의 차이가 임계값보다 작은 경우에 리프레시 컨트롤러는 현재 리프레시 사이클에서 해당 세그먼트를 건너뛸 수 있다. 리프레시 컨트롤러는 또한 다중 리프레시 사이클을 통해 메모리 칩의 세그먼트의 접근과 리프레시의 추적을 계속 이어갈 수 있다. 예를 들어, 리프레시 컨트롤러는 타이머를 활용하여 저장된 타임스탬프를 업데이트할 수 있다. 이 러한 실시예에서, 리프레시 컨트롤러는 임계 시간 간격 이후에 데이터 스토리지에 저장된 접근 정보를 비 우는 데에 타이머의 출력을 활용하도록 구성될 수 있다. 예를 들어, 데이터 스토리지가 연관 세그먼트에 대한 가장 최근 접근 또는 리프레시의 타임스탬프를 저장하는 실시예에서, 리프레시 컨트롤러는 접근 명령 또 는 리프레시 신호가 세그먼트로 전송될 때마다 새로운 타임스탬프를 데이터 스토리지에 저장할 수 있다. 데이터 스토리지가 타임스탬프 대신에 비트를 저장하는 경우, 타이머는 임계 시간 주기보다 길게 설정된 비트를 비우도록 구성될 수 있다. 예를 들어, 데이터 스토리지가 연관 세그먼트가 하나 이상의 이전 사이클에서 접근되 었던 것으로 나타내는 비트를 저장하는 실시예에서, 리프레시 컨트롤러는 타이머가 연관 비트에 설 정된 것(예, 1)보다 임계 수의 사이클(예, 1, 2 등) 이후의 새로운 리프레시 사이클을 촉발할 때마다 데이터 스 토리지 내의 비트를 비울(예, 0으로 설정) 수 있다. 리프레시 컨트롤로는 메모리 칩의 다른 하드웨어와 협력하여 메모리 칩의 세그먼트의 접근을 추적할 수 있다. 예를 들면, 메모리 칩은 센스 증폭기를 사용하여 읽기 동작을 수행한다(예, 도 9 및 도 10에 도시). 센스 증폭기는 하나 이상의 메모리 셀에 데이터를 저장하는 메모리 칩의 세그먼트로부터 저전력 신호를 감지하고, 데이터가 앞서 설명한 바와 같은 외부 CPU 또는 GPU 또는 집적 프로세서 서브유닛과 같은 로 직에 의해 해석될 수 있도록 작은 전압 스윙(voltage swing)을 높은 전압 수준으로 증폭하도록 구성된 복수의 트랜지스터를 포함할 수 있다. 도 29a에는 도시되어 있지 않지만, 리프레시 컨트롤러는 또한 하나 이상의 세그먼트에 접근하고 적어도 하나의 비트 레지스터의 상태를 변경하도록 구성된 센스 증폭기와 통신할 수 있다. 예를 들어, 센스 증폭기가 하나 이상의 세그먼트에 접근하는 경우, 연관 세그먼트가 이전 사이클에서 접근되었 음을 나타내는 비트를 설정(예, 1로 설정)할 수 있다. 데이터 스토리지가 연관 세그먼트에 대한 가장 최근 접근 또는 리프레시의 타임스탬프를 저장하는 실시예에서, 센스 증폭기가 하나 이상의 세그먼트에 접근하는 경우, 타 이머로부터 레지스터, 메모리, 또는 데이터 스토리지를 포함하는 기타 요소로 타임스탬프의 기록을 촉발 할 수 있다. 앞서 설명한 모든 실시예에서, 리프레시 컨트롤러는 복수의 메모리 뱅크에 대한 메모리 컨트롤러와 통합 될 수 있다. 예를 들어, 도 3a에 도시된 실시예와 유사하게, 리프레시 컨트롤러는 메모리 칩의 메 모리 뱅크 또는 기타 세그먼트와 연관된 논리 및 제어 서브유닛에 포함될 수 있다. 도 29b는 본 개시에 따른 다른 예시적인 리프레시 컨트롤러(2900')를 도시한 것이다. 리프레시 컨트롤러(290 0')는 도 28의 메모리 칩과 같은 본 개시의 메모리 칩에 포함될 수 있다. 리프레시 컨트롤러와 유 사하게, 리프레시 컨트롤러(2900')는 타이머, 로우 카운터, 활성 비트, 및 합산기를 포함한다. 또한, 리프레시 컨트롤러(2900')는 데이터 스토리지를 포함할 수 있다. 도 29b에 도시된 바와 같이, 데이터 스토리지는 메모리 칩의 세그먼트(예, 메모리 칩 내의 메모리 셀의 라인, 열, 또는 모든 임의의 기타 그룹)와 연관된 하나 이상의 레지스터 또는 비휘발성 메모리를 포함할 수 있고, 데이터스토리지 내의 상태는 연관되는 하나 이상의 세그먼트에 대응하여 변경되도록(예, 앞서 설명한 바와 같이, 리프 레시 컨트롤러(2900')의 센스 증폭기 또는 기타 요소에 의해) 구성될 수 있다. 이에 따라, 리프레시 컨트롤러 (2900')는 데이터 스토리지 내의 상태에 의거하여 하나 이상의 세그먼트의 리프레시를 건너뛰도록 구성될 수 있 다. 예를 들어, 세그먼트와 연관된 상태가 활성화되어 있으면(예, 스위치를 켜서 1로 설정, '1'을 저장하기 위 하여 성질을 변경 등), 리프레시 컨트롤러(2900')는 연관 세그먼트에 대한 리프레시 사이클을 건너뛰고 해당 부 분과 연관된 상태를 비울 수 있다. 상태는 적어도 1비트 레지스터 또는 적어도 1비트의 데이터를 저장하도록 구 성된 모든 임의의 다른 메모리 구조로 저장될 수 있다. 메모리 칩의 세그먼트가 각 리프레시 사이클 동안에 반드시 리프레시 또는 접근되도록 하기 위하여, 리프레시 컨트롤러(2900')는 다음 리프레시 사이클 동안에 리프레시 신호를 촉발하기 위하여 상태를 재설정하거나 비울 수 있다. 일부 실시예에서, 세그먼트를 건너뛴 다음에, 리프레시 컨트롤러(2900')는 해당 세그먼트가 다음 리프 레시 사이클에 반드시 리프레시 되게 하기 위하여 연관 상태를 비울 수 있다. 다른 실시예에서, 리프레시 컨트 롤러(2900')는 임계 시간 간격 이후에 데이터 스토리지 내의 상태를 재설정하도록 구성될 수 있다. 예를 들면, 리프레시 컨트롤러(2900')는 타이머가 연관 상태가 설정된(예, 스위치를 켜서 1로 설정, '1'을 저장하기 위하여 성질을 변경 등) 이후에 임계 시간을 초과할 때마다 데이터 스토리지의 상태를 비울 수(예, 0으로 설정) 있다. 일부 실시예에서, 리프레시 컨트롤러(2900')는 임계 시간 대신에 임계 수의 리프레시 사이클(예, 1, 2 등) 또는 임계 수의 클럭 사이클(예, 2, 4 등)을 사용할 수 있다. 다른 실시예에서, 상태는 연관 세그먼트의 가장 최근 리프레시 또는 접근의 타임스탬프를 포함하여, 타임스탬프 와 현재 시각(예, 도 29a 및 도 29b의 타이머로부터의 시각) 사이의 시간의 양이 미리 정해진 임계값(예, 8ms, 16ms, 32ms, 64ms 등)을 초과하는 경우에 리프레시 컨트롤러(2900')는 연관 세그먼트로 접근 명령 또는 리 프레시 신호를 전송하고 그 부분과 연관된 타임스탬프를 업데이트(예, 타이머를 활용)하도록 할 수 있다. 추가적으로 또는 대안적으로, 리프레시 컨트롤러(2900')는 리프레시 타임 지시자가 미리 정해진 타임 임계값 이 내의 마지막 리프레시 타임을 나타내는 경우에 복수의 메모리 뱅크의 하나 이상의 세그먼트에 대한 리프레시 동 작을 건너뛰도록 구성될 수 있다. 이러한 실시예에서, 하나 이상의 세그먼트에 대한 리프레시 동작을 건너뛴 이 후에, 리프레시 컨트롤러(2900')는 하나 이상의 세그먼트와 연관된 저장된 리프레시 타임 지시자를 변경하여 다 음 동작 사이클 동안에 하나 이상의 세그먼트가 리프레시 되게 하도록 구성될 수 있다. 예를 들어, 앞서 설명한 바와 같이, 리프레시 컨트롤러(2900')는 타이머를 이용하여 저장된 리프레시 타임 지시자를 업데이트할 수 있다. 이에 따라, 데이터 스토리지는 복수의 메모리 뱅크의 하나 이상의 세그먼트가 마지막으로 리프레시 되었던 시간 을 나타내는 리프레시 타임 지시자를 저장하도록 구성된 타임스탬프 레지스터를 포함할 수 있다. 또한, 리프레 시 컨트롤러(2900')는 데이터 스토리지에 저장된 접근 정보를 임계 시간 간격 이후에 비우는데 타이머의 출력을 이용할 수 있다. 앞서 설명한 모든 실시예에서, 하나 이상의 세그먼트로의 접근은 하나 이상의 세그먼트와 연관된 쓰기 동작을 포함할 수 있다. 추가적으로 또는 대안적으로, 하나 이상의 세그먼트로의 접근은 하나 이상의 세그먼트와 연관 된 읽기 동작을 포함할 수 있다. 또한, 도 29b에 도시된 바와 같이, 리프레시 컨트롤러(2900')는 적어도 부분적으로는 데이터 스토리지 내의 상 태에 의거하여 데이터 스토리지의 업데이트를 보조하도록 구성된 합산기 및 로우 카운터를 포함할 수 있다. 데이터 스토리지는 복수의 메모리 뱅크와 연관된 비트 테이블을 포함할 수 있다. 예를 들어, 비트 테이블은 연관 세그먼트에 대한 비트를 가지도록 구성된 스위치(또는 트랜지스터와 같은 스위칭 요 소) 또는 레지스터(예, SRAM 등)의 어레이를 포함할 수 있다. 추가적으로 또는 대안적으로, 데이터 스토리지 는 복수의 메모리 뱅크와 연관된 타임스탬프를 저장할 수 있다. 또한, 리프레시 컨트롤러(2900')는 하나 이상의 세그먼트로의 리프레시가 비트 테이블에 저장된 해당 값에 의거 하여 일어날지 여부를 제어하도록 구성된 리프레시 게이트를 포함할 수 있다. 예를 들어, 리프레시 게이 트는, 연관 세그먼트가 하나 이상의 이전 클럭 사이클 동안에 리프레시 또는 접근되었던 것으로 데이터 스토리지의 상응하는 상태가 나타내는 경우에, 로우 카운터로부터의 리프레시 신호를 무효로 하도 록 구성된 논리 게이트(예, 'and' 게이트)를 포함할 수 있다. 다른 실시예에서, 리프레시 게이트는, 연관 세그먼트가 미리 정해진 임계 시간값 이내에 리프레시 또는 접근되었던 것으로 데이터 스토리지로부터의 해당 타임스탬프가 나타내는 경우에, 로우 카운터로부터의 리프레시 신호를 무효로 하도록 구성된 마이크 로프로세서 또는 기타 회로를 포함할 수 있다. 도 30은 메모리 칩(예, 도 28의 메모리 칩)의 부분 리프레시를 위한 프로세스의 예시적인 순서도이 다. 프로세스는 도 29a의 리프레시 컨트롤러 또는 도 29b의 리프레시 컨트롤러(2900')와 같은 본 개시에 따른 리프레시 컨트롤러에 의해 실행될 수 있다. 단계 3010에서, 리프레시 컨트롤러는 복수의 메모리 뱅크의 하나 이상의 세그먼트에 대한 접근 동작을 나타내는 정보에 접근할 수 있다. 예를 들어, 앞서 도 29a와 도 29b를 참조하여 설명한 바와 같이, 리프레시 컨트롤러는 메모리 칩의 세그먼트(예, 메모리 칩 내의 메모리 셀의 라인, 열, 또는 모든 임의의 기타 그룹)와 연관되고 연관 세그먼트의 가장 최근 접근을 나타내는 타임스탬프 또는 기타 정보를 저장하도록 구성된 데이터 스토리지를 포함할 수 있다. 단계 3020에서, 리프레시 컨트롤러는 적어도 부분적으로는 접근된 정보에 의거하여 리프레시 및/또는 접근 명령 을 생성할 수 있다. 예를 들어, 앞서 도 29a와 도 29b를 참조하여 설명한 바와 같이, 리프레시 컨트롤러는, 접 근된 정보가 미리 정해진 시간 임계값 이내의 마지막 리프레시 또는 접근 시각 및/또는 하나 이상의 이전 클럭 사이클 동안에 발생한 마지막 리프레시 또는 접근을 나타내는 경우에, 복수의 메모리 뱅크의 하나 이상의 세그 먼트에 대한 리프레시 동작을 건너뛸 수 있다. 추가적으로 또는 대안적으로, 리프레시 컨트롤러는, 접근된 정보 가 나타내는 가장 최근 리프레시 또는 접근 시간이 미리 정해진 임계값을 초과하는지 여부에 의거 및/또는 가장 최근 리프레시 또는 접근이 하나 이상의 이전 클럭 사이클 동안에 발생하지 않은 경우에, 연관 세그먼트를 리프 레시 또는 접근하라는 명령을 생성할 수 있다. 단계 3030에서, 리프레시 컨트롤러는 하나 이상의 세그먼트와 연관되어 저장된 리프레시 타임 지시자를 변경하 여 다음 동작 사이클 동안에 하나 이상의 세그먼트가 리프레시 되게 할 수 있다. 예를 들어, 하나 이상의 세그 먼트에 대한 리프레시 동작을 건너뛴 이후에, 리프레시 컨트롤러는 하나 이상의 세그먼트에 대한 접근 동작을 나타내는 정보를 변경하여 다음 클럭 사이클 동안에 하나 이상의 세그먼트가 리프레시 되게 할 수 있다. 이에 따라, 리프레시 컨트롤러는 리프레시 사이클을 건너뛴 이후에 세그먼트에 대한 상태를 비울 수(예, 0으로 설정) 있다. 추가적으로 또는 대안적으로, 리프레시 컨트롤러는 현재 사이클 동안에 리프레시 및/또는 접근되는 세그 먼트에 대한 상태를 설정할 수(예, 1로 설정) 있다. 하나 이상의 세그먼트에 대한 접근 동작을 나타내는 정보가 타임스탬프를 포함하는 실시예에서, 리프레시 컨트롤러는 현재 사이클 동안에 리프레시 및/또는 접근되는 세그 먼트와 연관되어 저장된 모든 임의의 타임스탬프를 업데이트할 수 있다. 방법은 추가적인 단계를 더 포함할 수 있다. 예를 들어, 단계 3030에 대한 추가 또는 대안으로, 센스 증 폭기가 하나 이상의 세그먼트에 접근하고 하나 이상의 세그먼트와 연관된 정보를 변경할 수 있다. 추가적으로 또는 대안적으로, 센스 증폭기는 접근이 발생한 경우에 리프레시 컨트롤러로 신호를 보내서 리프레시 컨트롤러 가 하나 이상의 세그먼트와 연관된 정보를 업데이트하게 할 수 있다. 앞서 설명한 바와 같이, 센스 증폭기는 하 나 이상의 메모리 셀에 데이터를 저장하는 메모리 칩의 세그먼트로부터 저전력 신호를 감지하고, 데이터가 앞서 설명한 바와 같은 외부 CPU 또는 GPU 또는 집적 프로세서 서브유닛과 같은 로직에 의해 해석될 수 있도록 작은 전압 스윙을 높은 전압 수준으로 증폭하도록 구성된 복수의 트랜지스터를 포함할 수 있다. 이러한 예에서, 센스 증폭기가 하나 이상의 세그먼트에 접근할 때마다, 세그먼트와 연관된 비트를 설정하여(예, 1로 설정) 연관 세그 먼트가 이전 사이클에서 접근되었음을 나타낼 수 있다. 하나 이상의 세그먼트에 대한 접근 동작을 나타내는 정 보가 타임스탬프를 포함하는 실시예에서, 센스 증폭기가 하나 이상의 세그먼트에 접근할 때마다, 리프레시 컨트 롤러의 타이머로부터 데이터 스토리지로 타임스탬프의 쓰기를 촉발하여 세그먼트와 연관된 모든 임의의 저장된 타임스탬프를 업데이트할 수 있다. 도 31은 메모리 칩(예 도 28의 메모리 칩)에 대한 리프레시를 판단하는 프로세스의 예시적인 순서 도이다. 프로세스는 본 개시에 따른 컴파일러 내에서 이행될 수 있다. 앞서 설명한 바와 같이, '컴파일러'는 고수준 언어(예, C, FORTRAN, BASIC 등과 같은 절차형 언어; Java, C++, Pascal, Python 등과 같 은 객체 지향 언어 등)를 저수준 언어(예, 어셈블리 코드, 오브젝트 코드, 머신 코드 등)로 변환하는 모든 컴퓨 터 프로그램을 말한다. 컴파일러는 사람으로 하여금 인간 판독 가능 언어로 일련의 명령을 프로그램할 수 있게 해줄 수 있고, 이러한 명령은 나중에 머신 실행 가능 언어로 변환된다. 컴파일러는 하나 이상의 프로세서에 의 해 실행되는 소프트웨어 명령을 포함할 수 있다. 단계 3110에서, 하나 이상의 프로세서는 고수준 컴퓨터 코드를 수신할 수 있다. 예를 들면, 고수준 컴퓨터 코드 는 메모리(예, 하드디스크 드라이브 등과 같은 비휘발성 메모리, DRAM과 같은 휘발성 메모리 등) 상의 하나 이 상의 파일에 인코딩 되거나 네트워크(예, 인터넷 등)를 통해 수신될 수 있다. 추가적으로 또는 대안적으로, 고 수준 컴퓨터 코드는 사용자로부터 수신될 수 있다(예, 키보드와 같은 입력 장치를 활용). 단계 3120에서, 하나 이상의 프로세서는 고수준 컴퓨터 코드에 의해 접근될 메모리 칩과 연관된 복수의 메모리 뱅크에 분산된 복수의 메모리 세그먼트를 식별할 수 있다. 예를 들어, 하나 이상의 프로세서는 복수의 메모리 뱅크를 한정하는 데이터 구조 및 메모리 칩의 상응하는 구조에 접근할 수 있다. 하나 이상의 프로세서는 메모리 (예, 하드디스크 드라이브 등과 같은 비휘발성 메모리, DRAM과 같은 휘발성 메모리 등)로부터 데이터 구조에 접 근하거나 네트워크(예, 인터넷 등)를 통해 데이터 구조를 수신할 수 있다. 이러한 실시예에서, 데이터 구조는 컴파일러에 의해 접근될 수 있는 하나 이상의 라이브러리에 포함되어, 접근될 특정 메모리 칩에 대한 명령을 컴 파일러가 생성하도록 허용할 수 있다. 단계 3130에서, 하나 이상의 프로세서는 고수준 컴퓨터 코드에 접근하여 복수의 메모리 접근 사이클에서 일어날 복수의 메모리 읽기 명령을 식별할 수 있다. 예를 들어, 하나 이상의 프로세서는 메모리로부터의 하나 이상의 읽기 명령 및/또는 메모리로의 하나 이상의 쓰기 명령을 요구하는 고수준 컴퓨터 코드 이내의 각 연산을 식별할 수 있다. 이러한 명령은 변수 초기화, 변수 재할당, 변수의 논리 연산, 입력-출력 연산 등을 포함할 수 있다. 단계 3140에서, 하나 이상의 프로세서는 복수의 메모리 접근 사이클의 각 사이클 동안에 복수의 메모리 세그먼 트의 각 세그먼트가 접근되도록 복수의 메모리 세그먼트의 각 세그먼트를 통해 복수의 메모리 접근 명령과 연관 된 데이터의 분산을 유발할 수 있다. 예를 들어, 하나 이상의 프로세서는 메모리 칩의 구조를 한정하는 데이터 구조로부터 메모리 세그먼트를 식별한 후에 변수를 고수준 코드로부터 메모리 세그먼트의 다양한 세그먼트로 배 정하여 각 메모리 세그먼트가 각 리프레시 사이클(특정 수의 클럭 사이클을 포함할 수 있음) 동안에 적어도 한 번 접근(예, 쓰기 또는 읽기를 통해)되도록 할 수 있다. 이러한 예에서, 하나 이상의 프로세서는 각 메모리 세 그먼트가 특정 수의 클럭 사이클 동안에 적어도 한 번 접근(예, 쓰기 또는 읽기를 통해)되도록 고수준 코드의 라인으로부터 변수를 배정하기 위하여 고수준 코드의 각 라인이 요구하는 클럭 사이클의 수를 나타내는 정보에 접근할 수 있다. 다른 예에서, 하나 이상의 프로세서는 고수준 코드로부터 머신 코드 또는 기타 저수준 코드를 우선 생성할 수 있다. 이후, 하나 이상의 프로세서는 변수를 저수준 코드로부터 메모리 세그먼트의 다양한 세그먼트로 배정하여 각 메모리 세그먼트가 각 리프레시 사이클(특정 수의 클럭 사이클을 포함할 수 있음) 동안에 적어도 한 번 접근 (예, 쓰기 또는 읽기를 통해)되도록 할 수 있다. 이러한 예에서, 저수준 코드의 각 라인은 단일 클럭 사이클을 필요로 할 수 있다. 상기의 모든 실시예에서, 하나 이상의 프로세서는 임시 출력을 사용하는 논리 연산 또는 기타 명령을 메모리 세 그먼트 중 다양한 세그먼트에 더 배정할 수 있다. 이러한 임시 출력의 결과는 여전히 읽기 및/또는 쓰기 명령이 되어서 지명된 변수가 해당 메모리 세그먼트에 아직 배정되지 않아도 배정된 메모리 세그먼트가 리프레시 사이 클 동안에 여전히 접근되도록 할 수 있다. 방법은 추가적인 단계를 더 포함할 수 있다. 예를 들어, 컴파일링 이전에 변수가 배정되는 실시예에서, 하나 이상의 프로세서는 고수준 코드로부터 머신 코드 또는 기타 저수준 코드를 생성할 수 있다. 또한, 하나 이 상의 프로세서는 메모리 칩과 상응하는 논리 회로에 의한 실행을 위한 컴파일링 된 코드를 전송할 수 있다. 논 리 회로는 GPU 또는 CPU와 같은 종래의 회로를 포함하거나 도 7a에 도시된 바와 같이 메모리 칩으로서 동일 기 판 상에 프로세싱 그룹을 포함할 수 있다. 이에 따라, 앞서 설명한 바와 같이, 기판은 도 28에 도시된 뱅크 (2801a)와 기타 뱅크와 같은 복수의 뱅크를 포함하는 메모리 어레이를 포함할 수 있다. 또한, 기판은 복수의 프 로세서 서브유닛(예, 도 7a에 도시된 서브유닛(730a, 730b, 730c, 730d, 730e, 730f, 730g, 730h))을 포함하는 프로세싱 어레이를 포함할 수 있다. 도 32는 메모리 칩(예, 도 28의 메모리 칩)에 대한 리프레시를 판단하는 프로세스의 다른 예시적인 순서도이다. 프로세스는 본 개시에 따른 컴파일러 내에서 이행될 수 있다. 프로세스는 컴파일러를 포함하는 소프트웨어 명령을 실행하는 하나 이상의 프로세서에 의해 실행될 수 있다. 프로세스는 도 31의 프로세스와 별도로 또는 함께 이행될 수 있다. 단계 3210에서, 단계 3110과 유사하게, 하나 이상의 프로세서는 고수준 컴퓨터 코드를 수신할 수 있다. 단계 3220에서, 단계 3120과 유사하게, 하나 이상의 프로세서는 고수준 컴퓨터 코드에 의해 접근될 메모리 칩과 연관 된 복수의 메모리 뱅크에 분산된 복수의 메모리 세그먼트를 식별할 수 있다. 단계 3230에서, 하나 이상의 프로세서는 고수준 컴퓨터 코드를 평가하여 복수의 메모리 세그먼트의 하나 이상을 각각 연관시키는 복수의 메모리 읽기 명령을 식별할 수 있다. 예를 들어, 하나 이상의 프로세서는 메모리로부터 의 하나 이상의 읽기 명령 및/또는 메모리로의 하나 이상의 쓰기 명령을 필요로 하는 고수준 컴퓨터 코드 내의각 연산을 식별할 수 있다. 이러한 명령은 변수 초기화, 변수 재할당, 변수의 논리 연산, 입력-출력 연산 등을 포함할 수 있다. 일부 실시예에서, 하나 이상의 프로세서는 논리 회로 및 복수의 메모리 세그먼트를 활용하여 고수준 코드의 실 행을 시뮬레이션할 수 있다. 예를 들어, 시뮬레이션은 디버거(debugger) 또는 기타 명령어 집합 시뮬레이터 (instruction set simulator 또는 ISS)와 유사하게 고수준 코드의 라인별 스텝스루(line-by-line step- through)를 포함할 수 있다. 디버거가 프로세서의 레지스터를 나타내는 내부 변수를 유지하는 것과 유사하게, 시물레이션은 복수의 메모리 세그먼트의 어드레스를 나타내는 내부 변수를 더 유지할 수 있다. 단계 3240에서, 하나 이상의 프로세서는, 메모리 접근 명령의 분석에 의거하고 복수의 메모리 세그먼트의 각 메 모리 세그먼트에 대해, 메모리 세그먼트로의 마지막 접근부터 누적되는 시간의 양을 추적할 수 있다. 예를 들어, 앞서 설명한 시뮬레이션을 활용하여, 하나 이상의 프로세서는 복수의 메모리 세그먼트의 각 세그먼트 이 내의 하나 이상의 어드레스로의 각 접근(예, 읽기 또는 쓰기) 사이의 시간의 길이를 판단할 수 있다. 시간의 길 이는 절대적 시간, 클럭 사이클, 또는 리프레시 사이클(예, 메모리 칩의 알려진 리프레시 속도에 의해 판단)로 측정될 수 있다. 단계 3250에서, 임의의 특정 메모리 세그먼트에 대한 마지막 접근 이후의 시간의 양이 미리 정해진 임계값을 초 과할 것이라는 판단에 대응하여, 하나 이상의 프로세서는 특정 메모리 세그먼트로의 접근을 유발하도록 구성된 메모리 리프레시 명령 및 메모리 접근 명령의 적어도 하나를 고수준 컴퓨터 코드로 도입할 수 있다. 예를 들어, 하나 이상의 프로세서는 리프레시 컨트롤러(예, 도 29a의 리프레시 컨트롤러 또는 도 29b의 리프레시 컨 트롤러(2900'))에 의한 실행을 위한 리프레시 명령을 포함할 수 있다. 논리 회로가 메모리 칩으로서 동일 기판 상에 매립되지 않는 실시예에서, 하나 이상의 프로세서는 메모리 칩으로의 전송을 위한 리프레시 명령을 논리 회로로의 전송을 위한 저수준 코드와 별도로 생성할 수 있다. 추가적으로 또는 대안적으로, 하나 이상의 프로세서는 메모리 컨트롤러(리프레시 컨트롤러와 분리 또는 일체일 수 있음)에 의한 실행을 위한 접근 명령을 포함할 수 있다. 접근 명령은 메모리 세그먼트에 읽기 연산을 촉발하 지만 메모리 세그먼트에 읽기 또는 쓰기가 된 변수에 논리 회로가 더 이상의 연산을 못하게 하도록 구성된 더미 (dummy) 명령을 포함할 수 있다. 일부 실시예에서, 컴파일러는 프로세스와 프로세스의 단계의 조합을 포함할 수 있다. 예를 들면, 컴파일러는 단계 3140에 따른 변수를 배정한 후에 상기에 설명한 시뮬레이션을 실행하여 단계 3250에 따른 모든 임의의 추가적인 메모리 리프레시 명령 또는 메모리 접근 명령을 추가할 수 있다. 이러한 조합으로, 컴파일러는 최대한 많은 메모리 세그먼트로 변수를 분산하고 미리 정해진 임계 시간의 양 이내에 접근될 수 없는 모든 임의 의 메모리 세그먼트에 대한 리프레시 또는 접근 명령을 생성할 수 있다. 다른 조합의 예에서, 컴파일러는 단계 3230에 따른 코드를 시뮬레이션 하고, 미리 정해진 임계 시간의 양 이내에 접근되지 않을 것으로 시뮬레이션에 서 나타난 모든 임의의 세그먼트에 의거하여 단계 3140에 따른 변수를 배정할 수 있다. 일부 실시예에서, 이러 한 조합은 단계 3250을 더 포함하여, 단계 3140에 따른 배정이 완료된 후라도, 미리 정해진 임계 시간의 양 이 내에 접근될 수 없는 메모리 세그먼트에 대한 리프레시 또는 접근 명령을 컴파일러가 생성할 수 있다. 본 개시의 리프레시 컨트롤러로 인해, 논리회로(CPU 및 GPU와 같은 종래의 논리 회로 또는 도 7a에 도시된 바와 같은 메모리 칩으로서 동일 기판 상의 프로세싱 그룹)에 의해 실행되는 소프트웨어는 리프레시 컨트롤러에 의해 실행되는 자동 리프레시를 비활성화하고, 대신에 실행되는 소프트웨어를 통해 리프레시를 제어할 수 있다. 이에 따라, 본 개시의 일부 실시예는 공지의 메모리 칩 접근 패턴을 가진 소프트웨어를 제공할 수 있다(예, 컴파일러 가 복수의 메모리 뱅크를 한정하는 데이터 구조 또는 메모리 칩의 상응하는 구조로 접근이 되는 경우). 이러한 실시예에서, 포스트 컴파일링 옵티마이저(post-compiling optimizer)는 자동 리프레시를 비활성화하고 임계 시 간의 양 이내에 접근되지 않은 메모리 칩의 세그먼트에 대해서만 수동으로 리프레시 제어를 설정할 수 있다. 따 라서, 앞서 설명한 단계 3250과 유사하지만 컴파일링 이후에, 포스트 컴파일링 옵티마이저는 각 메모리 세그먼 트가 반드시 미리 정해진 임계 시간의 양으로 접근 또는 리프레시 되도록 하는 리프레시 명령을 생성할 수 있다. 리프레시 사이클을 감소시키는 다른 예로 메모리 칩으로의 미리 정의된 패턴의 접근을 활용할 수 있다. 예를 들 어, 논리 회로에 의해 실행되는 소프트웨어가 메모리 칩에 대한 접근 패턴을 제어할 수 있는 경우에, 일부 실시 예는 종래의 선형 라인 리프레시 이상의 리프레시를 위한 접근 패턴을 생성할 수 있다. 예를 들면, 컨트롤러의 판단에 논리 회로에 의해 실행되는 소프트웨어가 메모리의 2행마다 정기적으로 접근하는 경우, 본 개시의 리프 레시 컨트롤러는 메모리 칩의 속도를 증가하고 전력 소모를 감소하기 위하여 2 라인마다 리프레시를 하지 않는접근 패턴을 사용할 수 있다. 이러한 리프레스 컨트롤러의 일례가 도 33에 도시되어 있다. 도 33은 본 개시에 따른 저장된 패턴에 의해 구성 된 예시적인 리프레시 컨트롤러를 도시한 것이다. 리프레시 컨트롤러는 본 개시의 메모리 칩에 포 함될 수 있다. 예를 들어, 복수의 메모리 뱅크와 복수의 메모리 세그먼트가 도 28의 메모리 칩과 같은 복 수의 메모리 뱅크의 각각에 포함되게 할 수 있다. 리프레시 컨트롤러는 타이머(도 29a와 도 29b의 타이머와 유사), 로우 카운터(도 29a 와 도 29b의 로우 카운터와 유사), 및 합산기(도 29a와 도 29b의 합산기와 유사)를 포함한다. 또한, 리프레시 컨트롤러는 데이터 스토리지를 포함한다. 도 29b의 데이터 스토리지 와 달리, 데이터 스토리지는 복수의 메모리 뱅크의 각각에 포함된 복수의 메모리 세그먼트의 리프 레시에서 이행될 적어도 하나의 메모리 리프레시 패턴을 포함할 수 있다. 예를 들어, 도 33에 도시된 바와 같이, 데이터 스토리지는 메모리 뱅크의 세그먼트를 행 및/또는 열로 구분하는 Li(예, 도 33의 예에서 L1, L2, L3, L4) 및 Hi(예, 도 33의 예에서 H1, H2, H3, H4)를 포함할 수 있다. 또한, 각 세그먼트는 세그먼트 와 연관된 행이 증가되는 방식(예, 각 행이 접근 또는 리프레시 되는지 여부, 한 항씩 건너서 접근 또는 리프레 시 되는지 여부 등)을 정의하는 Inci 변수(예, 도 33의 예에서 Inc1, Inc2, Inc3, Inc4)와 연관될 수 있다. 따 라서, 도 33에 도시된 바와 같이, 리프레시 패턴은 리프레시 사이클 동안에 리프레시 될 특정 메모리 뱅크 내의 복수의 메모리 세그먼트의 범위 및 리프레시 사이클 동안에 리프레시 되지 않을 특정 메모리 뱅크의 복수의 메 모리 세그먼트의 범위를 식별하게 소프트웨어에 의해 배정되는 복수의 메모리 세그먼트 식별자를 포함하는 테이 블을 포함할 수 있다. 따라서, 데이터 스토리지는 논리 회로(CPU 및 GPU와 같은 종래의 논리 회로 또는 도 7a에 도시된 바와 같 은 메모리 칩으로서 동일 기판 상의 프로세싱 그룹)에 의해 실행되는 소프트웨어가 사용하기로 선택할 수 있는 리프레시 패턴을 정의할 수 있다. 메모리 리프레시 패턴은 리프레시 사이클 동안에 특정 메모리 뱅크 내의 복수 의 메모리 세그먼트 중에서 어느 메모리 세그먼트가 리프레시 될지 및 리프레시 사이클 동안에 특정 메모리 뱅 크의 복수의 메모리 세그먼트 중에서 어느 메모리 세그먼트가 리프레시 되지 않을지를 식별하게 소프트웨어를 활용하여 구성 가능할 수 있다. 따라서, 리프레시 컨트롤러는 Inci에 따라 현재 사이클 동안에 접근되지 않는 정의된 세그먼트 내의 일부 또는 모든 행을 리프레시 할 수 있다. 리프레시 컨트롤러는 현재 사이클 동안에 접근되도록 설정된 정의된 세그먼트의 다른 행을 건너뛸 수 있다. 리프레시 컨트롤러의 데이터 스토리지가 복수의 메모리 리프레시 패턴을 포함하는 실시예에서, 각 메모리 리프레시 패턴은 복수의 메모리 뱅크의 각각에 포함된 복수의 메모리 세그먼트의 리프레시를 위한 상이 한 리프레시 패턴을 나타낼 수 있다. 메모리 리프레시 패턴은 복수의 메모리 세그먼트 상의 사용을 위해 선택 가능할 수 있다. 이에 따라, 리프레시 컨트롤러는 특정 리프레시 사이클 동안에 복수의 메모리 리프레시 패턴 중에서 이행할 메모리 리프레시 패턴의 선택이 가능하도록 구성될 수 있다. 예를 들어, 논리 회로(CPU 및 GPU와 같은 종래의 논리 회로 또는 도 7a에 도시된 바와 같은 메모리 칩으로서 동일 기판 상의 프로세싱 그룹) 에 의해 실행되는 소프트웨어는 하나 이상의 상이한 리프레시 사이클 동안에 사용될 상이한 메모리 리프레시 패 턴을 선택할 수 있다. 대안적으로, 논리 회로에 의해 실행되는 소프트웨어는 상이한 리프레시 사이클의 일부 또 는 전체 동안에 사용할 하나의 메모리 리프레시 패턴을 선택할 수 있다. 메모리 리프레시 패턴은 데이터 스토리지에 저장된 하나 이상의 변수를 활용하여 인코딩될 수 있다. 예를 들어, 복수의 메모리 세그먼트가 행으로 배열된 실시예에서, 각 메모리 세그먼트 식별자는 메모리 리프레시가 시작 또는 종료되어야 하는 메모리의 행 이내의 특정 위치를 식별하도록 구성될 수 있다. 예를 들어, Li와 Hi 외에, 하나 이상의 추가적인 변수가 Li와 Hi에 의해 정의된 행의 어느 부분이 세그먼트 이내인지 정의할 수 있 다. 도 34는 메모리 칩(예, 도 28의 메모리 칩)에 대한 리프레시를 판단하기 위한 프로세스의 예시적인 순서도이다. 프로세스는 본 개시에 따른 리프레시 컨트롤러(예, 도 33의 리프레시 컨트롤러) 내의 소프트웨어에 의해 이행될 수 있다. 단계 3410에서, 리프레시 컨트롤러는 복수의 메모리 뱅크의 각각에 포함된 복수의 메모리 세그먼트의 리프레시 에 이행될 적어도 하나의 메모리 리프레시 패턴을 저장할 수 있다. 예를 들어, 앞서 도 33을 참조하여 설명한 바와 같이, 리프레시 패턴은 리프레시 사이클 동안에 리프레시 될 특정 메모리 뱅크 내의 복수의 메모리 세그먼 트의 범위 및 리프레시 사이클 동안에 리프레시 되지 않을 특정 메모리 뱅크의 복수의 메모리 세그먼트의 범위 를 식별하게 소프트웨어에 의해 배정되는 복수의 메모리 세그먼트 식별자를 포함하는 테이블을 포함할 수 있다. 일부 실시예에서, 적어도 하나의 리프레시 패턴은 제조시에 리프레시 컨트롤러 상으로(예, 리프레시 컨트롤러와 연관되거나 리프레시 컨트롤러에 의해 적어도 접근될 수 있는 ROM 상으로) 인코딩될 수 있다. 이에 따라, 리프 레시 컨트롤러는 적어도 하나의 리프레시 패턴에 접근하지만 이 리프레시 패턴을 저장하지 않을 수 있다. 단계 3420과 단계 3430에서, 리프레시 컨트롤러는 소프트웨어를 활용하여 리프레시 사이클 동안에 특정 메모리 뱅크 내의 복수의 메모리 세그먼트 중에서 어느 메모리 세그먼트가 리프레시 될지 및 리프레시 사이클 동안에 특정 메모리 뱅크의 복수의 메모리 세그먼트 중에서 어느 메모리 세그먼트가 리프레시 되지 않을지를 식별할 수 있다. 예를 들면, 앞서 도 33을 참조하여 설명한 바와 같이, 논리 회로(CPU 및 GPU와 같은 종래의 논리 회로 또 는 도 7a에 도시된 바와 같은 메모리 칩으로서 동일 기판 상의 프로세싱 그룹)에 의해 실행되는 소프트웨어는 적어도 하나의 메모리 리프레시 패턴을 선택할 수 있다. 또한, 리프레시 컨트롤러는 선택된 적어도 하나의 메모 리 리프레시 패턴에 접근하여 각 리프레시 사이클 동안에 상응하는 리프레시 신호를 생성할 수 있다. 리프레시 컨트롤러는 적어도 하나의 리프레시 패턴에 따라 현재 리프레시 사이클 동안에 접근되지 않은 정의된 세그먼트 이내의 일부 또는 전체 부분을 리프레시 하고, 현재 사이클 동안에 접근되기로 설정된 정의된 세그먼트의 다른 부분을 건너뛸 수 있다. 단계 3440에서, 리프레시 컨트롤러는 상응하는 리프레시 명령을 생성할 수 있다. 예를 들어, 도 33에 도시된 바 와 같이, 합산기는 데이터 스토리지 내의 적어도 하나의 메모리 리프레시 패턴에 따라 리프레시 되 지 않을 특정 세그먼트에 대한 리프레시 신호를 무효로 하도록 구성된 논리 회로를 포함할 수 있다. 추가적으로 또는 대안적으로, 마이크로프로세서(도 33에는 미도시)가 데이터 스토리지 내의 적어도 하나의 메모리 리 프레시 패턴에 따라 어느 세그먼트가 리프레시 되어야 하는지에 의거하여 특정 리프레시 신호를 생성할 수 있다. 방법은 추가적인 단계를 더 포함할 수 있다. 예를 들어, 적어도 하나의 메모리 리프레시 패턴이 1, 2, 또 는 기타 수의 리프레시 사이클마다 변화하도록(예, 도 33에 도시된 바와 같이 L1, H1, Inc1에서 L2, H2, Inc2로 이동) 구성된 실시예에서, 리프레시 컨트롤러는 단계 3430과 단계 3440에 따른 리프레시 신호의 다음 판단을 위 해 데이터 스토리지의 상이한 부분에 접근할 수 있다. 이와 유사하게, 논리 회로(CPU 및 GPU와 같은 종래의 논 리 회로 또는 도 7a에 도시된 바와 같은 메모리 칩으로서 동일 기판 상의 프로세싱 그룹)에 의해 실행되는 소프 트웨어가 하나 이상의 추후 리프레시 사이클에서의 사용을 위해 데이터 스토리지에서 새로운 메모리 리프레시 패턴을 선택하는 경우, 리프레시 컨트롤러는 단계 3430과 단계 3440에 따른 리프레시 신호의 다음 판단을 위해 데이터 스토리지의 상이한 부분에 접근할 수 있다. 메모리 칩을 설계하고 메모리의 특정 용량을 목표로 하는 경우, 메모리 용량의 증가 또는 축소의 변화를 하려면 제품 및 전체 마스크 세트를 재설계해야 할 수 있다. 종종, 제품 설계와 시장 조사는 동시에 이루어지고, 경우 에 따라 시장 조사가 가능하기 전에 제품 설계가 끝나기도 한다. 따라서, 제품 설계와 시장의 실제 수요 사이에 괴리가 있을 수 있다. 본 개시는 시장 수요에 상응하는 메모리 용량의 메모리 칩을 유연하게 제공하는 방법을 제시한다. 설계 방법은 적절한 인터커넥트(interconnect) 회로와 함께 다이를 설계하여, 단일 웨이퍼로부터 가 변 크기의 메모리 용량의 메모리 칩을 생산하는 기회를 제공하기 위하여, 하나 이상의 다이를 포함할 수 있는 메모리 칩이 웨이퍼로부터 선택적으로 절단되게 할 수 있다. 본 개시는 웨이퍼로부터 메모리 칩을 절단하여 메모리 칩을 제조하는 시스템 및 방법에 관한 것이다. 본 방법은 웨이퍼로부터 선택적 크기의 메모리 칩을 생산하는데 활용될 수 있다. 다이를 포함하는 웨이퍼의 예시적인 실시예가 도 35a에 도시되어 있다. 웨이퍼는 반도체 물질(예, 실리콘(Si), 실리콘 게르마늄 (SiGe), SOI(silicon on insulator), 질화 갈륨(GaN), 질화 알루미늄(AlN), 알루미늄 질화 갈륨(AlGaN), 질화 붕소(BN), 갈륨 비소(GaAs), 갈륨 알루미늄 비소(AlGaAs), 질화 인듐(InN), 및 그 조합 등)로부터 형성될 수 있 다. 다이는 모든 임의의 적합한 반도체, 유전체, 또는 금속 성분을 포함할 수 있는 모든 임의의 적합한 회로 요소(예, 트랜지스터, 커패시터, 저항 등)를 포함할 수 있다. 다이는 웨이퍼의 물질과 동일하 거나 상이할 수 있는 반도체 물질로 형성될 수 있다. 다이 외에도, 웨이퍼는 다른 구조 및/또는 회 로를 포함할 수 있다. 일부 실시예에서, 하나 이상의 결합 회로가 제공될 수 있고 다이 중의 하나 이상을 서로 결합할 수 있다. 예시적인 실시예에서, 이러한 결합 회로는 둘 이상의 다이에 의해 공유되는 버스를 포함 할 수 있다. 추가적으로, 결합 회로는 다이와 연관된 회로를 제어 및/또는 다이로 정보를 제공 및 다이로부터 정보를 가져오도록 설계된 하나 이상의 논리 회로를 포함할 수 있다. 일부 경우에서, 결합 회 로는 메모리 접근 관리 로직을 포함할 수 있다. 이러한 로직은 논리적 메모리 어드레스를 다이와 연관된 물리적 어드레스로 변환할 수 있다. 여기서, '제조'라는 용어는 개시된 웨이터, 다이, 및/또는 칩을 구성하는 모든 단계를 통칭할 수 있다. 예를 들어, 제조는 웨이퍼 상에 포함된 다양한 다이(및 모든 임의의 기타 회로)의동시 레이아웃과 형성을 의미할 수 있다. 제조는 또한 경우에 따라 하나의 다이 또는 다수의 다이를 포함하도록 웨이퍼로부터 선택적 크기의 메모리 칩을 절단하는 것을 의미할 수 있다. 물론, 제조라는 용어는 이러한 예에 제한되지 않으며 개시된 메모리 칩 및 그 중간 구조의 일부 또는 전체의 생성과 연관된 다른 측면을 포함할 수 있다. 메모리 칩의 제조를 위해 다이 또는 한 그룹의 다이를 사용할 수 있다. 메모리 칩은 본 개시의 다른 부분 에서 설명한 바와 같이 분산 프로세서를 포함할 수 있다. 도 35b에 도시된 바와 같이, 다이는 기판 및 기판 상에 배치된 메모리 어레이를 포함할 수 있다. 메모리 어레이는 데이터를 저장하도록 설계된 메모리 뱅 크(3511A-3511D) 등과 같은 하나 이상의 메모리 유닛을 포함할 수 있다. 다양한 실시예에서, 메모리 뱅크는 트 랜지스터, 커패시터 등과 같은 반도체 기반 회로 요소를 포함할 수 있다. 예시적인 일 실시예에서, 메모리 뱅크 는 저장 장치의 다중 행과 열을 포함할 수 있다. 일부의 경우에서, 이러한 메모리 뱅크의 용량은 1 메가바이트 이상일 수 있다. 메모리 뱅크는 DRAM 또는 SRAM을 포함할 수 있다. 다이는 기판 상에 배치된 프로세싱 어레이를 더 포함할 수 있고, 프로세싱 어레이는 도 35b에 도시된 바 와 같이 복수의 프로세서 서브유닛(3515A-3515D)을 포함할 수 있다. 앞서 설명한 바와 같이, 각 메모리 뱅크는 전용 버스에 의해 연결된 전용 프로세서 서브유닛을 포함할 수 있다. 예를 들어, 프로세서 서브유닛(3515A)은 버스 또는 연결을 통해 메모리 뱅크(3511A)와 연관된다. 여기서, 메모리 뱅크(3511A-3511D)와 프로세서 서브유닛(3515A-3515D) 사이에 다양한 연결이 가능하고, 도 35b에는 그 중의 일부 연결만이 도시되어 있음은 당 연하다 할 것이다. 예시적인 일 실시예에서, 프로세서 서브유닛은 연관된 메모리 뱅크에 대해 읽기/쓰기 동작을 수행할 수 있고, 다양한 메모리 뱅크에 저장된 메모리에 관한 리프레시 동작 또는 기타 적절한 동작을 더 수행 할 수 있다. 다이는 프로세서 서브유닛을 상응하는 메모리 뱅크와 연결시키도록 구성된 제1그룹의 버스를 포함할 수 있다. 예시적인 버스는 전기 요소를 연결하고 각 메모리 뱅크와 그 연관 프로세서 서브유닛 사이에 데이터와 어 드레스의 전송을 허용하는 전선 또는 컨덕터의 집합을 포함할 수 있다. 예시적인 실시예에서, 연결은 프 로세서 서브유닛(3515A)을 메모리 뱅크(3511A)로 연결하기 위한 전용 버스의 역할을 할 수 있다. 다이는 한 그룹의 이러한 버스를 포함할 수 있고, 각 버스는 프로세서 서브유닛을 상응하는 전용 메모리 뱅크로 연결할 수 있다. 또한, 다이는 다른 그룹의 버스를 포함할 수 있고, 각 버스는 프로세서 서브유닛(예, 서브유닛 (3515A-3515D))을 서로 연결할 수 있다. 예를 들어, 이러한 버스는 연결(3516A-3516D)을 포함할 수 있다. 다양 한 실시예에서, 메모리 뱅크(3511A-3511D)를 위한 데이터는 입력-출력 버스를 통해 전달될 수 있다. 예시 적인 일 실시예에셔, 입력-출력 버스는 데이터 관련 정보 및 다이의 메모리 유닛의 동작을 제어하 기 위한 명령 관련 정보를 전달할 수 있다. 데이터 정보는 메모리 뱅크에 저장하기 위한 데이터, 메모리 뱅크에 서 읽은 데이터, 상응하는 메모리 뱅크에 저장된 데이터에 대해 수행된 동작에 의거한 하나 이상의 프로세서 서 브유닛으로부터의 프로세싱 결과, 명령 관련 정보, 다양한 코드 등을 포함할 수 있다. 다양한 경우에서, 입력-출력 버스에 의해 전송된 데이터 및 명령은 입력-출력(IO) 컨트롤러에 의 해 제어될 수 있다. 예시적인 일 실시예에서, IO 컨트롤러는 버스와 프로세서 서브유닛(3515A- 3515D) 사이의 데이터의 흐름을 제어할 수 있다. IO 컨트롤러는 프로세서 서브유닛(3515A-3515D) 중의 어 느 서브유닛에서 정보를 가져올 것인지를 판단할 수 있다. 다양한 실시에에서, IO 컨트롤러는 IO 컨트롤 러를 비활성화하도록 구성된 퓨즈를 포함할 수 있다. 퓨즈는 다수의 다이를 함께 합쳐서 더 큰 메모리 칩(단일 다이만을 포함하는 단일 다이 메모리 칩에 대한 상대적인 용어로 멀티 다이 메모리 칩으로도 지칭함)을 형성하는 경우에 사용될 수 있다. 이후, 멀티 다이 메모리 칩은 멀티 다이 메모리 칩을 형성하는 다 이 유닛 중의 하나의 IO 컨트롤러의 하나를 사용하고, 다른 IO 컨트롤러에 상응하는 퓨즈를 사용하여 다른 다이 유닛과 연관된 다른 IO 컨트롤러를 비활성화 할 수 있다. 각 메모리 칩 또는 프로세서 다이 또는 다이의 그룹은 상응하는 메모리 뱅크와 연관된 분산 프로세서를 포함할 수 있다. 일부 실시예에서, 이러한 분산 프로세서는 복수의 메모리 뱅크로서 동일 기판 상에 배치된 프로세싱 어레이로 배열될 수 있다. 또한, 프로세싱 어레이는 각각이 어드레스 생성기(어드레스 생성 장치(AGU)로도 지칭)를 포함하는 하나 이상의 논리부를 포함할 수 있다. 일부 경우에서, 어드레스 생성기는 적어도 하나의 프 로세서 서브유닛의 일부일 수 있다. 어드레스 생성기는 메모리 칩과 연관된 하나 이상의 메모리 뱅크로부터 데 이터를 가져오기 위해 필요한 메모리 어드레스를 생성할 수 있다. 어드레스 생성 계산은 덧셈, 뺄셈, 모듈로 연 산, 또는 비트 이동과 같은 정수 산술 연산을 포함할 수 있다. 어드레스 생성기는 한 번에 여러 피연산자를 연 산하도록 구성될 수 있다. 또한, 다중 어드레스 생성기가 동시에 하나 시상의 어드레스 계산 연산을 수행할 수 있다. 다양한 실시예에서, 어드레스 생성기는 상응하는 메모리 뱅크와 연관될 수 있다. 어드레스 생성기는 상응하는 버스 라인을 통해 상응하는 메모리 뱅크와 연결될 수 있다. 다양한 실시예에서, 웨이퍼의 상이한 영역을 선택적으로 절단하여 웨이퍼로부터 선택 가능 사이즈 의 메모리 칩을 형성할 수 있다. 설명한 바와 같이, 웨이퍼는 한 그룹의 다이를 포함할 수 있고, 이 그룹 은 웨이퍼 상에 포함된 둘 이상의 다이(예, 2, 3, 4, 5, 10, 또는 그 이상의 다이)의 그룹을 포함할 수 있다. 하기에 상세히 설명하는 바와 같이, 일부 경우에서, 한 그룹의 다이의 하나의 다이만을 포함하는 웨이퍼의 부분 을 절단하여 단일 메모리 칩이 형성될 수 있다. 이러한 경우, 그 결과의 메모리 칩은 한 다이와 연관된 메모리 칩을 포함할 수 있다. 반면, 다른 경우에서, 선택 가능 사이즈의 메모리 칩이 하나 이상의 다이를 포함하게 형 성될 수 있다. 이러한 메모리 칩은 웨이퍼 상에 포함된 한 그룹의 다이의 둘 이상의 다이를 포함하는 웨이퍼의 영역을 절단하여 형성될 수 있다. 이러한 경우, 다이는 다이를 서로 결합시키는 결합 회로와 함께 멀티 다이 메 모리 칩을 제공한다. 클럭 요소, 데이터 버스, 또는 모든 임의의 적절한 논리 회로와 같은 일부 회로 요소가 또 한 칩 사이에 추가적으로 연결될 수 있다. 일부 경우에서, 다이 그룹과 연관된 적어도 하나의 컨트롤러는 다이 그룹의 동작을 단일 메모리 칩(예, 다중 메 모리 유닛 메모리 칩)으로 제어하도록 구성될 수 있다. 컨트롤러는 메모리 칩과의 데이터 흐름을 관리하는 하나 이상의 회로를 포함할 수 있다. 메모리 컨트롤러는 메모리 칩의 일부이거나 메모리 칩과 직접 연관되지 않는 별 도의 칩의 일부일 수 있다. 예시적인 일 실시예에서, 컨트롤러는 메모리 칩의 분산 프로세서와 연관된 읽기 및 쓰기 요청 또는 기타 명령을 가능하게 하도록 구성될 수 있고, 메모리 칩의 모든 임의의 다른 측면(에, 메모리 칩의 리프레시, 분산 프로세서와의 상호 작용 등)을 제어하도록 구성될 수 있다. 일부 경우에서, 컨트롤러는 다 이의 일부일 수 있고, 다른 경우에서, 컨트롤러는 다이에 인접하여 레이아웃 될 수 있다. 다양한 실시예에서, 컨트롤러는 또한 메모리 칩 상에 포함된 적어도 하나의 메모리 유닛의 적어도 하나의 메모리 컨트 롤러를 포함할 수 있다. 일부 경우에서, 메모리 칩 상의 정보에 접근하기 위해 사용되는 프로토콜은 메모리 칩 상에 존재할 수 있는 복제 로직 및 메모리 유닛(예, 메모리 뱅크)과 무관할 수 있다. 프로토콜은 메모리 칩 상 의 데이터의 적절한 접근을 위해 상이한 ID 또는 어드레스 범위를 가지도록 구성될 수 있다. 이러한 프로토콜을 가진 칩의 예로, 상이한 메모리 뱅크에 상이한 어드레스 범위가 있는 JEDEC(Joint Electron Device Engineering Council) 더블 데이터 레이트(DDR) 컨트롤러, 상이한 메모리 유닛(예, 메모리 뱅크)에 상이한 ID가 있는 SPI(serial peripheral interface) 등을 가진 칩이 있을 수 있다. 다양한 실시예에서, 다중 영역이 웨이퍼에서 절단될 수 있고, 여기서 다양한 영역은 하나 이상의 다이를 포함할 수 있다. 일부 경우에서, 각 별도의 영역은 멀티 다이 메모리 칩의 형성에 사용될 수 있다. 일부 경우에서, 둘 이상의 영역이 동일한 형상일 수 있고, 동일한 수의 다이가 동일한 방식으로 결합 회로에 결합될 수 있다. 대안 적으로, 예시적인 일 실시예에서, 제1그룹의 영역이 제1 유형의 메모리 칩의 형성에 활용되고, 제2그룹의 영역 이 제2 유형의 메모리 칩의 형성에 활용될 수 있다. 예를 들어, 도 35c에 도시된 바와 같은 웨이퍼는 단 일 다이를 포함할 수 있는 영역을 포함할 수 있고, 제2 영역은 두 개의 다이의 그룹을 포함할 수 있다. 영역 웨이퍼에서 절단되는 경우, 단일 다이 메모리 칩이 제공되게 된다. 영역이 웨이 퍼에서 절단되는 경우, 멀티 다이 메모리 칩이 제공되게 된다. 도 35c에 도시된 그룹들은 예시에 불과하 고, 다양한 다른 영역과 다이 그룹이 웨이퍼에서 절단될 수 있다. 다양한 실시예에서, 다이는 웨이퍼에서 형성되어, 예를 들어 도 35c에 도시된 바와 같이, 다이는 웨이퍼 의 하나 이상의 행을 따라 배열될 수 있다. 다이는 하나 이상의 행에 상응하는 입력-출력 버스를 공유할 수 있다. 예시적인 일 실시예에서, 다이의 그룹은 다양한 절단 형상을 사용하여 웨이퍼에서 절단될 수 있 고, 여기서, 메모리 칩의 형성에 활용될 수 있는 다이의 그룹을 절단하는 경우, 공유 입력-출력 버스의 적어도 일부분은 제외될 수 있다(예, 입력-출력 버스의 일부만이 다이의 그룹을 포함하여 형성되는 메모 리 칩의 일부로 포함될 수 있다). 앞서 설명한 바와 같이, 다수의 다이(예, 도 35c에 도시된 다이(3506A 및 3506B))를 사용하여 메모리 칩 을 형성하는 경우, 다이 중의 하나에 상응하는 하나의 IO 컨트롤러가 활성화되고 다이(3506A 및 3506B)의 모든 프로세서 서브유닛으로의 데이터 흐름을 제어하도록 구성될 수 있다. 예를 들어, 도 35d에는 메모리 뱅크 (3511A-3511H), 프로세서 서브유닛(3515A-3515H), IO 컨트롤러(3521A, 3521B), 및 퓨즈(3554A, 3554B)를 포함 하는 메모리 칩을 형성하기 위해 조합된 다이(3506A 및 3506B)가 도시되어 있다. 여기서, 메모리 칩 은 웨이퍼로부터 메모리 칩을 제거하기 전에 웨이퍼의 영역에 상응한다. 즉, 본 개시에서, 일단 웨이퍼에서 절단된 웨이퍼의 영역(3504, 3505, 3517 등)은 메모리 칩(3504, 3505, 3517 등) 이 되게 된다. 또한, 여기서 퓨즈는 비활성화 요소를 말하기도 한다. 예시적인 일 실시예에서, 퓨즈(3554B)는 IO 컨트롤러(3521B)를 비활성화하는데 사용될 수 있고, IO 컨트롤러(3521A)는 프로세서 서브유닛(3515A-3515H)과 데이터를 주고받음으로써 모든 메모리 뱅크(3511A-3511H)로의 데이터 흐름을 제어하는데 사용될 수 있 다. 예시적인 일 실시예에서, IO 컨트롤러(3521A)는 모든 임의의 적절한 연결을 활용하여 다양한 프로세서 서브 유닛과 연결될 수 있다. 일부 실시예에서, 하기에 더 설명하는 바와 같이, 프로세서 서브유닛(3515A-3515H)은 상호 연결될 수 있고, IO 컨트롤러(3521A)는 메모리 칩의 프로세싱 로직을 형성하는 프로세서 서브유닛 (3515A-3515H)으로의 데이터 흐름을 제어하도록 구성될 수 있다. 예시적인 일 실시예에서, 컨트롤러(3521A 및 3521B)와 같은 IO 컨트롤러 및 상응하는 퓨즈(3554A 및 3554B)는 메모리 뱅크(3511A-3511H) 및 프로세서 서브유닛(3515A-3515H)의 형성과 함께 웨이퍼 상에 형성될 수 있 다. 다양한 실시예에서, 메모리 칩을 형성할 때에, 단일 칩으로 기능 하고 단일 입력-출력 컨트롤러(예, 컨트롤러(3521A))에 의해 제어되는 메모리 칩을 다이(3506A 및 3506B)가 형성하도록 구성되도록 퓨즈 중 의 하나(예, 퓨즈(3554B))가 비활성화될 수 있다. 예시적인 일 실시예에서, 퓨즈의 활성화는 전류를 인가하여 퓨즈를 촉발하는 것을 포함할 수 있다. 다양한 실시예에서, 메모리 칩의 형성을 위해 하나 이상의 다이가 사용 되는 경우에, 하나의 IO 컨트롤러를 제외한 모든 IO 컨트롤러는 상응하는 퓨즈를 통해 비활성화 될 수 있다. 다양한 실시예에서, 도 35c에 도시된 바와 같이, 다수의 다이가 한 세트의 입력-출력 버스 및/또는 컨트롤 버스 와 함께 웨이퍼 상에 형성된다. 예시적인 입력-출력 버스가 도 35c에 도시되어 있다. 예시적인 일 실시예에서, 입력-출력 버스 중의 하나(예, 입력-출력 버스)가 여러 다이에 연결될 수 있다. 도 35c에는 다이(3506A 및 3506B) 옆을 지나가는 입력-출력 버스의 예시적인 일 실시예가 도시되어 있다. 도 35c에 도시된 바와 같은 다이(3506A 및 3506B) 및 입력-출력 버스의 구성은 예시에 불과하고, 다양한 다른 구성 이 사용될 수도 있다. 예를 들어, 도 35e는 웨이퍼 상에 형성되고 육각형 대형으로 배열된 다이가 도시하고 있다. 예시적인 일 실시예에서, 4개의 다이를 포함하는 메모리 칩이 웨이퍼에서 절 단될 수 있다. 예시적인 일 실시예에서, 메모리 칩은 적절한 버스 라인(예, 도 35e에 도시된 라인(353 3))에 의해 4개의 다이로 연결된 입력-출력 버스의 일부분을 포함할 수 있다. 정보를 메모리 칩의 적절한 메모리 유닛으로 전달하기 위하여, 메모리 칩은 입력-출력 버스에 대한 분기점에 배치된 입 력/출력 컨트롤러(3542A 및 3542B)를 포함할 수 있다. 컨트롤러(3542A 및 3542B)는 입력-출력 버스를 통 해 명령 데이터를 수신하고 적절한 메모리 유닛으로 정보를 전송하기 위한 버스의 분기를 선택할 수 있다. 예를 들면, 명령 데이터가 다이와 연관된 메모리 유닛에서의 읽기/쓰기 정보를 포함하는 경우, 컨 트롤러(3542A)는 명령 요청을 수신하고 데이터를 도 35d에 도시된 버스의 분기(3531A)로 전송하는 반면, 컨트롤러(3542B)는 명령 요청을 수신하고 데이터를 분기(3531B)로 전송할 수 있다. 도 35e에는 파선으로 절단선 을 표현하여 상이한 영역의 다양한 절단이 이루어질 수 있음이 도시되어 있다. 예시적인 일 실시예에서, 한 그룹의 다이 및 상호 연결 회로가 도 36a에 도시된 것과 같은 메모리 칩에 포함되도록 설계될 수 있다. 이러한 실시예는 사로 통신하도록 구성될 수 있는 프로세서 서브유닛을 포함할 수 (인메모리 프로세싱을 위해) 있다. 예를 들어, 메모리 칩에 포함될 각 다이는 메모리 뱅크(3511A-3511D), 프로세서 서브유닛(3515A-3515D), 및 IO 컨트롤러(3521 및 3522)와 같은 다양한 메모리 유닛을 포함할 수 있다. IO 컨트롤러(3521 및 3522)는 입력-출력 버스와 병렬로 연결될 수 있다. IO 컨트롤러에는 버스 가 있을 수 있고, IO 컨트롤러에는 버스가 있을 수 있다. 예시적인 일 실시예에서, 프로세서 서브유닛(3515A-3515D)은 예를 들어 버스를 통해 연결될 수 있다. 일부 경우에서, IO 컨트롤러 중의 하나 는 상응하는 퓨즈를 사용하여 비활성화될 수 있다. 예를 들어, IO 컨트롤러는 퓨즈를 활용하여 비 활성화 될 수 있고, IO 컨트롤러는 버스을 통해 서로 연결된 프로세서 서브유닛(3515A-3515D)을 통 한 메모리 뱅크(3511A-3511D)로의 데이터 흐름을 제어할 수 있다. 도 36a에 도시된 바와 같은 메모리 유닛의 구성은 예시에 불과하고, 웨이퍼의 상이한 영역을 절단함으로 써 다양한 다른 구성이 형성될 수 있다. 예를 들면, 도 36b에는 메모리 유닛을 포함하고 입력-출력 버스 에 연결된 3개의 영역(3601-3603)을 가진 구성이 도시되어 있다. 예시적인 일 실시예에서, 영역(3601-3603)은 상응하는 퓨즈(3554-3556)에 의해 비활성화될 수 있는 IO 컨트롤 모듈(3521-3523)을 활용하여 입력-출력 버스 로 연결된다. 메모리 유닛을 포함하는 영역을 배열하는 실시예의 다른 예가 도 36c에 도시되어 있고, 여 기서 3개의 영역(3601, 3602, 3603)이 버스 라인(3611, 3612, 3613)을 활용하여 입력-출력 버스로 연결 된다. 도 36d는 IO 컨트롤러(3521-3524)를 통해 입력-출력 버스(3530A 및 3530B)에 연결된 메모리 칩(3506A- 3506D)의 다른 예시적인 실시예를 도시한 것이다. 예시적인 일 실시예에서, IO 컨트롤러는 도 36d에 도시된 바 와 같이 상응하는 퓨즈를 활용하여 비활성화 될 수 있다. 도 37은 하나 이상의 다이를 포함할 수 있는 그룹 및 그룹과 같은 다이의 다양한 그룹 을 도시하고 있다. 예시적인 일 실시예에서, 웨이퍼 상에 다이를 형성하는 것 외에도, 웨이퍼는 글루 로직으로 불리는 논리 회로도 포함할 수 있다. 글루 로직은 웨이퍼 상 의 공간을 일부 차지함으로써 웨이퍼 당 제조되는 다이의 수가 글루 로직이 없이 제조하는 경우보 다 적어지는 결과를 가져올 수 있다. 그러나 글루 로직이 있음으로써 다수의 다이가 단일 메모리 칩으로 기능 하도록 구성되게 할 수 있다. 예컨대, 글루 로직은 구성을 변경하지 않고 다이 내부의 영역을 다이끼리 연 결하기 위해서만 사용되는 회로를 위해 지정하지 않고 다수의 다이를 연결할 수 있다. 다양한 실시예에서, 글루 로직은 다른 메모리 컨트롤러와의 인터페이스를 제공하여 멀티 다이 메모리 칩이 단일 메모리 칩으로 기 능 하도록 할 수 있다. 글루 로직은 예를 들어 그룹으로 도시된 다이의 그룹으로 함께 절단될 수 있다. 또는, 메모리 칩에 대해 하나의 다이만이, 예를 들어 그룹이 필요한 경우, 글루 로직은 절단되지 않을 수 있다. 예를 들어, 글루 로직은 상이한 다이 사이의 협력을 가능하게 하기 위해 필요하지 않은 경우에 선택적으로 제거될 수 있다. 도 37에서, 예를 들어, 파선 영역과 같은, 상이한 영역의 다양한 절단이 도시된 바 와 같이 이루어질 수 있다. 다양한 실시예에서, 도 37에 도시된 바와 같이, 하나의 글루 로직 요소가 두 개의 다이마다 웨이퍼 상에 레이아웃 될 수 있다. 일부 경우에서, 하나의 글루 로직 요소는 한 그 룹의 다이를 형성하는 모든 임의의 수의 다이에 대해 사용될 수 있다. 글루 로직은 다이 그룹의 모 든 다이에 연결되도록 구성될 수 있다. 다양한 실시예에서, 글루 로직에 연결된 다이는 멀티 다이 메모리 칩을 형성하도록 구성될 수 있고, 글루 로직에 연결되지 않은 경우에는 별개의 단일 다이 메모리 칩을 형 성하도록 구성될 수 있다. 다양한 실시예에서, 글루 로직에 연결되고 함께 기능 하도록 설계된 다이가 그 룹으로 웨이퍼에서 절단될 수 있고, 그룹 등으로 표시된 바와 같이 글루 로직을 포함할 수 있다. 글루 로직에 연결되지 않은 다이는 그룹 등으로 표시된 바와 같이 글루 로직을 포함하 지 않고 웨이퍼에서 절단되어 단일 다이 메모리 칩을 형성할 수 있다. 일부 실시예에서, 웨이퍼에서 멀티 다이 메모리 칩을 제조하는 과정에서, 원하는 멀티 다이 메모리 칩의 세트를 생성하기 위해 하나 이상의 절단 형상(예, 그룹(3713, 3715)을 형성하는 형상)이 결정될 수 있다. 일부 경우에서, 그룹으로 도시된 바와 같이, 절단 형상은 글루 로직을 포함하지 않을 수 있다. 다양한 실시예에서, 글루 로직은 멀티 다이 메모리 칩의 다중 메모리 유닛의 제어를 위한 컨트롤러일 수 있다. 일부 경우에서, 글루 로직은 다양한 다른 컨트롤러에 의해 수정될 수 있는 파라미터를 포함할 수 있다. 예컨대, 멀티 다이 메모리 칩의 결합 회로는 글루 로직의 파라미터 또는 메모리 컨트롤러(예, 도 35b에 도시된 프로세서 서브유닛(subunits 3515A-3515D))의 파라미터를 구성하기 위한 회로를 포함할 수 있다. 글루 로직은 다양한 작업을 수행하도록 구성될 수 있다. 예를 들면, 글루 로직은 어느 다이가 어드 레스 되어야 할지를 판단하도록 구성될 수 있다. 일부 경우에서, 글루 로직은 다중 메모리 유닛을 동기화 하는데 사용될 수 있다. 다양한 실시예에서, 글루 로직은 메모리 유닛들이 단일 칩으로 작동하게 되도록 다양한 메모리 유닛을 제어하도록 구성될 수 있다. 일부 경우에서, 입력-출력 버스(예, 도 35c에 도시된 버스 )와 프로세서 서브유닛(3515A-3515D) 사이에 증폭기가 추가되어 버스로부터의 데이터 신호를 증폭 할 수 있다. 다양한 실시예에서, 웨이퍼에서 복잡한 형상을 절단하는 것은 기술적으로 어려울/비쌀 수 있고, 다이들이 웨이퍼 상에 정렬된다면 더 단순한 절단 방법이 채택될 수 있다. 도 38a는 다이가 정렬되어 직사각 형 격자를 형성하는 것을 도시하고 있다. 예시적인 일 실시예에서, 전체 웨이퍼에 세로 절단과 가 로 절단을 하여 절단된 다이의 그룹을 분리할 수 있다. 예시적인 일 실시예에서, 세로 및 가로 절단 (3803, 3801)으로 선택된 수의 다이를 포함하는 그룹이 만들어질 수 있다. 예컨대, 절단과 절단의 결과로 단일 다이를 포함하는 영역(예, 3811A), 두 개의 다이를 포함하는 영역(예, 3811B), 및 4개의 다이를 포 함하는 영역(예, 3811C)이 형성될 수 있다. 절단과 절단에 의해 형성된 영역들은 예시에 불과하며, 모든 임의의 다른 적절한 영역이 형성될 수 있다. 다양한 실시예에서, 다이의 정렬에 따라, 다양한 절단이 이루 어질 수 있다. 예를 들면, 도 38b에 도시된 바와 같이, 다이들이 삼각형 격자로 정렬되는 경우, 라인(3802, 3804, 3806)과 같은 절단 라인을 활용하여 멀티 다이 메모리 칩을 형성할 수 있다. 예컨대, 일부 영역은 6개의 다이, 5개의 다이, 3개의 다이, 2개의 다이, 1개의 다이, 또는 모든 임의의 기타 적절한 수의 다이를 포함할 수 있다. 도 38c는 버스 라인이 삼각형 격자로 배열되고, 교차하는 버스 라인에 의해 형성된 삼각형의 중앙 에 다이가 정렬된 것을 도시하고 있다. 다이는 버스 라인을 통해 이웃하는 모든 버스라인으 로 연결될 수 있다. 둘 이상의 인접 다이를 포함하는 영역(예, 도 38c에 도시된 영역)을 절단함으로써, 적어도 하나의 버스 라인(예, 라인)이 영역에 남게 되고, 영역을 활용하여 형성된 멀티 다이 메모리 칩으로 데이터 및 명령을 제공하기 위해 버스 라인이 활용될 수 있다. 도 39는 메모리 유닛의 그룹이 단일 메모리 칩으로 기능 하도록 하기 위해 프로세서 서브유닛(3515A-3515P) 사 이에 다양한 연결이 형성될 수 있음을 도시하고 있다. 예를 들어, 다양한 메모리 유닛의 그룹은 프로세서 서브유닛(3515B)과 프로세서 서브유닛(3515E) 사이의 연결을 포함할 수 있다. 연결은 메모리 뱅크 (3511E)를 제어하는데 사용될 수 있는 서브유닛(3515B)에서 서브유닛(3515E)으로의 데이터 및 명령의 전송을 위 한 버스 라인으로 사용될 수 있다. 다양한 실시예에서, 프로세서 서브유닛 사이의 연결은 웨이퍼 상에 다 이를 형성하는 동안에 구현될 수 있다. 일부 경우에서, 여러 다이로부터 형성된 메모리 칩의 패키징 단계에서 추가적인 연결이 제조될 수 있다. 도 39에 도시된 바와 같이, 프로세서 서브유닛(3515A-3515P)은 다양한 버스(예, 연결)를 활용하여 서로 연결될 수 있다. 연결에는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛 사이의 데이터 전송과 연결을 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않을 수 있다. 다양한 실시예에 서, 프로세서 서브유닛(3515A-3515P)을 연결하는 버스는 웨이퍼 상에 다양한 회로를 제조하기 전에 웨이 퍼 상에 레이아웃 될 수 있다. 다양한 실시예에서, 프로세서 서브유닛(예, 서브유닛(3515A-3515P))은 상호 연결될 수 있다. 예를 들어, 서브유 닛(3515A-3515P)은 적절한 버스(예, 연결)에 의해 연결될 수 있다. 연결은 서브유닛(3515A-3515P) 중의 하나 이상을 서브유닛(3515A-3515P) 중의 다른 하나 이상과 연결시킬 수 있다. 예시적인 일 실시예에서, 연결된 서브유닛은 동일 다이 상에 있을 수 있고(예, 3515A와 3515B의 경우), 다른 경우에서, 연결된 서브유닛 은 상이한 다이 상에 있을 수 있다(예, 3515B와 3515E의 경우). 연결은 서브유닛을 연결하기 위한 전용 버스를 포함할 수 있고 서브유닛(3515A-3515P) 사이에 데이터를 효율적으로 전송하도록 구성될 수 있다. 본 개시의 다양한 측면은 선택 가능 사이즈의 메모리 칩을 웨이퍼로부터 생산하기 위한 방법에 관한 것이다. 예 시적인 일 실시예에서, 선택 가능 사이즈의 메모리 칩은 아나 이상의 다이로부터 형성될 수 있다. 앞서 설명한 바와 같이, 다이는 예를 들어 도 35c에 도시된 바와 같이 하나 이상의 행을 따라 배열될 수 있다. 일부 경우에 서, 하나 이상의 행에 상응하는 적어도 하나의 공유 입력-출력 버스가 웨이퍼 상에 레이아웃 될 수 있다. 예를 들어, 버스가 도 35c에 도시된 바와 같이 레이아웃 될 수 있다. 다양한 실시예에서, 버스는 적어도 두 개의 다이의 메모리 유닛으로 전기적으로 연결될 수 있고, 연결된 다이는 멀티 다이 메모리 칩의 형 성에 사용될 수 있다. 예시적인 일 실시예에서, 하나 이상의 컨트롤러(예, 도 35b에 도시된 입력-출력 컨트롤러 (3521, 3522))가 멀티 다이 메모리 칩의 형성에 사용되는 적어도 두 개의 다이의 메모리 유닛을 제어하도록 구 성될 수 있다. 다양한 실시예에서, 버스로 연결된 메모리 유닛이 있는 다이는 적어도 하나의 컨트롤러(예, 컨트롤러(3521, 3522))로 정보를 전송하는 공유 입력-출력 버스(예, 도 35b에 도시된 버스(353 0))의 적어도 하나의 상응하는 부분과 함께 웨이퍼에서 절단되어, 연결된 다이의 메모리 유닛을 함께 단일 칩으 로 기능 하게 컨트롤러가 제어하도록 구성될 수 있다. 일부 경우에서, 웨이퍼의 영역을 절단하여 메모리 칩을 제조하기 이전에 웨이퍼 상에 위치한 메모 리 유닛을 검사할 수 있다. 검사는 적어도 하나의 공유 입력-출력 버스(예, 도 35c에 도시된 버스)를 사 용하여 수행될 수 있다. 메모리 칩은 메모리 유닛이 검사에 합격하는 경우에 메모리 유닛을 포함하는 다이의 그 룹으로부터 형성될 수 있다. 검사에 불합격하는 메모리 유닛은 폐기되고 메모리 칩의 제소에 사용되지 않을 수 있다. 도 40은 다이의 그룹으로부터 메모리 칩을 구성하는 예시적인 프로세스를 도시한 것이다. 프로세스(400 0)의 단계 4011에서, 다이가 반도체 웨이퍼 상에 레이아웃 될 수 있다. 단계 4015에서, 모든 임의의 적절 한 방식을 활용하여 웨이퍼 상에 다이가 제작될 수 있다. 예를 들어, 다이는 웨이퍼를 식각하고, 다양한 유전층, 금속층, 또는 반도체층을 증착하고, 증착된 층을 더 식각하는 등을 통하여 제작될 수 있다. 예 컨대, 다중 층이 증착되고 식각될 수 있다. 다양한 실시예에서, 층은 모든 임의의 적절한 도핑 요소를 활용하여 n형 도핑 또는 p형 도핑 될 수 있다. 예를 들어, 반도체층은 인(P)으로 n형 도핑 될 수 있고 붕소(B)로 p형 도 핑 될 수 있다. 도 35a에 도시된 바와 같은 다이는 웨이퍼에서 다이를 절단하기 위해 사용될 수 있는 공간에 의해 서로로부터 분리될 수 있다. 예를 들어, 다이는 공간 영역에 의해 서로로부터 이격 될 수 있고, 여기서 공간 영역의 폭은 공간 영역에서 웨이퍼 절단이 가능하도록 선택될 수 있다. 단계 4017에서, 모든 임의의 적절한 방식을 활용하여 웨이퍼로부터 다이가 절단될 수 있다. 예시적 인 일 실시예에서, 다이는 레이저를 활용하여 절단될 수 있다. 예시적인 일 실시예에서, 웨이퍼는 우선 스크라이브(scribe) 된 후에 기계적 절단이 될 수 있다. 또는, 기계적 절단 톱(dicing saw)이 사용될 수 있다. 일부 경우에서, 스텔스다이싱(stealth dicing) 프로세스가 사용될 수 있다. 절단 과정에서, 웨이퍼는 다이가 절단된 이후에 다이를 홀드하기 위한 다이싱 테이프 상에 탑재될 수 있다. 다양한 실시예에서, 도 38a의 절단(3801 및 3803) 또는 도 38b의 절단(3802, 3804, 및 3806)으로 도시된 바와 같이 대형 절단이 이루 어질 수 있다. 일단 다이가 개별적으로 또는, 도 35c의 그룹과 같이, 그룹으로 절단되면, 다이 는 패키징 될 수 있다. 다이의 패키징은 다이에 컨택트(contacts)를 형성하고, 컨택트에 보호층을 증착하고, 열관리 장치(예, 히트싱크)를 부착하고, 다이를 인캡슐레이션 하는 과정을 포함한다. 다양한 실시예에서, 메모리 칩의 형성에 선택되는 다이의 수에 따라, 컨택트와 버스의 적절한 구성이 사용될 수 있다. 예시적인 일 실시예에서, 메모리 칩을 형성하는 다이 사이의 컨택트의 일부는 메모리 칩 패키징 과정에서 형성 될 수 있다. 도 41a는 다수의 다이를 포함하는 메모리 칩을 제조하기 위한 예시적인 프로세스를 도시한 것이다. 프로 세스의 단계 4011은 프로세스의 단계 4011과 동일할 수 있다. 단계 4111에서, 도 37에 도시된 바와 같은 글루 로직이 웨이퍼 상에 레이아웃 될 수 있다. 글루 로직은 도 37에 도시된 바와 같이 다이의 동작을 제어하기 위한 모든 임의의 적합한 로직일 수 있다. 앞서 설명한 바와 같이, 글루 로직 의 존재로 인해 여러 다이가 단일 메모리 칩으로 기능 할 수 있게 된다. 글루 로직은 다수의 다이 로부터 형성된 메모리 칩이 단일 메모리 칩으로 기능 할 수 있도록 다른 메모리 컨트롤러와의 인터페이스를 제 공할 수 있다. 프로세스의 단계 4113에서, 버스(예, 입력-출력 버스 및 컨트롤 버스)가 웨이퍼 상에 레이아웃 될 수 있다. 버스는 다양한 다이 및 글루 로직과 같은 다양한 논리 회로와 연결되도록 레이아웃 될 수 있다. 일부 경우에서, 버스는 메모리 유닛을 연결할 수 있다. 예를 들어, 버스는 상이한 다이의 프로세서 서브유닛을 연결하도록 구성될 수 있다. 단계 4115에서, 모든 임의의 적합한 방식을 활용하여 다이, 글루 로직, 및 버스가 제작될 수 있다. 예를 들어, 논리 요소는 웨이퍼를 식각하고, 다양한 유전층, 금속층, 또는 반도체층을 증착하고, 증착된 층을 더 식각하는 등을 통하여 제작될 수 있다. 버스는 예를 들어 금속 증착을 활용하여 제작 될 수 있다. 단계 4140에서, 절단 형상을 활용하여 도 37에 도시된 것과 같은 단일 글루 로직에 연결된 다이의 그룹을 절단할 수 있다. 절단 형상은 다수의 다이를 포함하는 메모리 칩에 대한 메모리 요구사항을 활용하여 판 단될 수 있다. 예를 들어, 도 41b는 프로세스의 변형일 수 있는 프로세스를 도시하고 있으며, 여기 서 프로세스의 단계 4140 이전에 단계 4117과 단계 4119가 있을 수 있다. 단계 4117에서, 웨이퍼 절단 시스템은 메모리 칩에 대한 요구사항을 설명하는 명령을 수신할 수 있다. 예를 들면, 요구사항에는 4개의 다이를 포함하는 메모리 칩의 형성을 포함할 수 있다. 일부 경우에서, 단계 4119에서 프로그램 소프트웨 어가 다이의 그룹과 글루 로직에 대한 주기적 패턴을 판단할 수 있다. 예컨대, 주기적 패턴은 2개의 글루 로직 요소와 4개의 다이에서 1개의 글루 로직마다 2개의 다이가 연결된 패턴을 포함할 수 있 다. 또는 단계 4119에서, 패턴은 메모리 칩의 설계자에 의해 제공될 수 있다. 일부 경우에서, 패턴은 웨이퍼로부터 메모리 칩의 수율을 극대화하도록 선택될 수 있다. 예시적인 일 실 시예에서, 다이의 메모리 유닛을 검사하여 불량 메모리 유닛이 있는 다이('불량 다이'라고 지칭)를 식별 하고, 불량 다이의 위치에 의거하여, 검사에 합격한 메모리 유닛을 포함하는 다이의 그룹이 식별되고 적 절한 절단 패턴이 판단될 수 있다. 예를 들어, 웨이퍼의 가장자리에서 많은 수의 다이가 불량인 경 우, 웨이퍼의 가장자리의 다이를 제외하는 절단 패턴이 결정될 수 있다. 단계 4011, 단계 4111, 단계 4113, 단계 4115, 및 단계 4140과 같은 프로세스의 다른 단계들은 프로세스의 동일한 번호의 단계 들과 동일할 수 있다. 도 41c는 프로세스의 변형일 수 있는 예시적인 프로세스를 도시한 것이다. 프로세스의 단계 4011, 단계 4111, 단계 4113, 단계 4115, 및 단계 4140은 프로세스의 동일한 번호의 단계들과 동일할 수 있고, 프로세스의 단계 4131은 프로세스의 단계 4117을 대신할 수 있고, 프로세스의 단계 4133은 프로세스의 단계 4119를 대신할 수 있다. 단계 4131에서, 웨이퍼 절단 시스템은 제1세트의 메모리 칩과 제2세트의 메모리 칩에 대한 요구사항을 설명하는 명령을 수신할 수 있다. 예를 들어, 요구사항은 4개의 다이를 포함하는 메모리 칩으로 제1세트의 메모리 칩을 형성하고 2개의 다이를 포함하는 메 모리 칩으로 제2세트의 메모리 칩을 형성하는 것을 포함할 수 있다. 일부 경우에서, 웨이퍼에서 2세트 이 상의 메모리 칩이 형성되어야 할 수도 있다. 예컨대, 제3세트의 메모리 칩은 1개의 다이만을 포함하는 메 모리 칩을 포함할 수 있다. 일부의 경우, 단계 4133에서, 각 세트의 메모리 칩에 대한 메모리 칩을 형성하기 위 한 다이의 그룹과 글루 로직의 주기적 패턴을 프로그램 소프트웨어가 판단할 수 있다. 예를 들면, 제1세 트의 메모리 칩은 2개의 글루 로직과 4개의 다이에서 1개의 글루 로직마다 2개의 다이가 연결된 패턴을 포함하는 메모리 칩을 포함할 수 있다. 다양한 실시예에서, 동일한 메모리 칩에 대한 글루 로직 은 서로 연결되어 단일 글루 로직으로 기능 할 수 있다. 예를 들어, 글루 로직의 제작 과정에서, 글루 로직을 서로 연결하는 버스 라인이 형성될 수 있다. 제2세트의 메모리 칩은 1개의 글루 로직과 2개의 다이에서 다이가 글루 로직에 연결된 패턴을 가진 메모리 칩을 포함할 수 있다. 일부 경우에서, 제2세트의 메모리 칩이 선택되고, 제2세트의 메모리 칩은 단일 다이를 포함하는 메모리 칩을 포함하는 경우, 글루 로직이 필요하지 않을 수 있다. 메모리 칩 또는 칩 내의 메모리 인스턴스를 설계할 때에, 한 가지 중요한 특성은 단일 클럭 사이클 동안에 동시 에 접근될 수 있는 워드의 수이다. 읽기 및/또는 쓰기를 위해 동시에 접근될 수 있는 어드레스(예, 워드 또는 워드라인이라고도 부르는 행 및 비트 또는 비트라인이라고도 부르는 열을 따라 있는 어드레스)가 많을수록, 메 모리 칩은 더 빨라진다. 레지스터 파일, 캐시, 또는 공유 메모리를 구축하는 등의, 동시에 다중 어드레스에 접 근할 수 있게 하는 다중 방향 포트를 포함하는 메모리를 개발하려는 노력이 있어왔지만, 대부분의 인스턴스는 사이즈가 크고 다중 어드레스 접근을 지원하는 메모리 매트를 활용한다. 그러나 DRAM 칩은 각 메모리 셀의 각 커패시터에 연결된 단일 비트라인과 단일 로우라인(row line)을 포함하는 것이 일반적이다. 이에 따라, 본 개시 의 실시예들은 DRAM 어레이의 이러한 종래의 단일 포트 메모리 구조를 변경하지 않고 기존의 DRAM 칩 상에 다중 포트 접근을 제공하고자 한다. 본 개시의 실시예들에서, 메모리 인스턴스 또는 칩의 클럭 속도는 메모리를 사용하는 논리 회로의 속도보다 2배 빠를 수 있다. 따라서, 메모리를 사용하는 모든 임의의 논리 회로는 메모리 및 그 구성요소에 '상응'할 수 있다. 이에 따라, 본 개시의 실시예들2 메모리 어레이 클럭 사이클로 2개의 어드레스에 읽기 또는 쓰기를 할 수 있고, 이는 논리 회로에 대한 단일 프로세싱 클럭 사이클과 맞먹는다. 논리 회로는 컨트롤러, 가속기, GPU, 또 는 CPU와 같은 회로를 포함할 수 있거나 도 7a에 도시된 바와 같이 메모리 칩과 동일한 기판 상의 프로세싱 그 룹을 포함할 수 있다. 앞서 도 3a를 참조하여 설명한 바와 같이, '프로세싱 그룹'은 둘 이상의 프로세서 서브유 닛과 이에 상응하는 기판 상의 메모리 뱅크를 말하는 것일 수 있다. 그룹은 기판 상의 공간적 분산 및/또는 메 모리 칩 상의 실행을 위한 코드의 컴파일링을 위한 논리적 묶음을 나타낼 수 있다. 이에 따라, 앞서 도 7a를 참조하여 설명한 바와 같이, 메모리 칩이 있는 기판은 도 28에 도시된 뱅크(2801a) 및 기타 뱅크와 같은 복수의 뱅크가 있는 메모리 어레이를 포함할 수 있다. 또한, 기판은 복수의 프로세서 서브유닛(예, 도 7a에 도 시된 서브유닛(730a, 730b, 730c, 730d, 730e, 730f, 730g, 730h))을 포함할 수 있는 프로세싱 어레이도 포함 할 수 있다. 이에 따라, 본 개시의 실시예에서, 단일 포트 메모리 어레이가 2 포트 메모리 칩인 것처럼 각 로직 사이클에 대 해 2개의 어드레스를 처리하고 로직에 2개의 결과를 제공하기 위하여, 연속하는 2 메모리 사이클의 각각에서 어 레이로부터 데이터를 읽을 수 있다. 추가적인 클러킹(clocking)을 통해, 본 개시의 메모리 칩은 단일 포트 어레 이가 2 포트 메모리 인스턴스, 3 포트 메모리 인스턴스, 4 포트 메모리 인스턴스, 또는 모든 임의의 기타 다중 포트 메모리 인스턴스처럼 기능할 수 있다. 도 42는 본 개시에 따른 회로이 사용되는 메모리 칩의 열을 따라 듀얼 포트 접근을 제공하는 예시적인 회 로를 도시한 것이다. 도 42에 도시된 실시예는 2개의 컬럼 멀티플렉서('mux')(4205a 및 4205b)가 있는 하 나의 메모리 어레이를 사용하여 논리 회로에 대한 동일 클럭 사이클 동안에 동일 행의 2 워드에 접근할 수 있다. 예를 들어, 메모리 클럭 사이클 동안에, RowAddrA가 로우 디코더에서 사용되고 ColAddrA가 멀티 플렉서(4205a)에서 사용되어 어드레스 (RowAddrA, ColAddrA)를 가진 메모리로부터의 데이터를 버퍼링 한다. 동 일한 메모리 클럭 사이클 동안에, ColAddrB가 멀티플렉서(4205b)에서 사용되어 어드레스 (RowAddrA, ColAddr B)를 가진 메모리로부터의 데이터를 버퍼링 한다. 따라서, 회로는 동일한 행 또는 워드라인을 따라 2개의 상이한 어드레스에서 메모리 셀 상에 저장된 데이터(예, DataA 및 DataB)로의 듀얼 포트 접근을 가능하게 할 수 있다. 따라서, 로우 디코더가 두 읽기에 대한 동일한 워드라인을 활성화하도록 두 어드레스가 행을 공유 할 수 있다. 또한, 도 42에 도시된 예와 같은 실시예들은 동일한 메모리 클럭 사이클 동안에 2 어드레스가 접근 될 수 있도록 컬럼 멀티플렉서를 사용할 수 있다. 이와 유사하게, 도 43은 본 개시에 따른 회로가 사용되는 메모리 칩의 행을 따라 듀얼 포트 접근을 제공 하는 예시적인 회로를 도시한 것이다. 도 43에 도시된 실시예는 로우 디코더가 멀티플렉서('mux') 에 결합된 하나의 메모리 어레이를 사용하여 논리 회로에 대한 동일 클럭 사이클 동안에 동일 열 상의 2 개의 워드에 접근할 수 있다. 예를 들어, 2 메모리 클럭 사이클의 제1 사이클에서, RowAddrA가 로우 디코더 에서 사용되고, ColAddrA가 컬럼 멀티플렉서에서 사용되어 어드레스 (RowAddrA, ColAddrA)를 가진메모리 셀로부터의 데이터를 버퍼링 할 수 있다(예, 도 43의 'Buffered Word' 버퍼로). 2 메모리 클럭 사이클의 제2 사이클에서, RowAddrB가 로우 디코더에서 사용되고, ColAddrA가 컬럼 멀티플렉서에서 사용되어 어드레스 (RowAddrB, ColAddrA)를 가진 메모리 셀로부터의 데이터를 버퍼링 할 수 있다. 따라서, 회로는 동일한 열 또는 비트라인을 따라 2개의 상이한 어드레스에서 메모리 셀 상에 저장된 데이터(예, DataA 및 DataB)로의 듀얼 포트 접근을 가능하게 할 수 있다. 따라서, 컬럼 디코더(도 43에 도시된 바와 같이, 하나 이상 의 컬럼 멀티플렉서와 분리되거나 병합될 수 있음)가 두 읽기에 대한 동일한 비트라인을 활성화하도록 두 어드 레스가 행을 공유할 수 있다. 로우 디코더는 각 워드라인을 활성화하기 위해 하나의 메모리 클럭 사이클 이 필요할 수 있기 때문에 도 43에 도시된 예와 같은 실시예들은 2개의 메모리 클럭 사이클을 사용할 수 있다. 이에 따라, 회로를 사용하는 메모리 칩은 상응하는 논리 회로보다 클럭 속도가 적어도 2배 빠른 경우에 듀얼 포트 메모리로 기능할 수 있다. 이에 따라, 앞서 설명한 바와 같이, 도 43은 상응하는 논리 회로에 대한 클럭 사이클보다 빠른 2개의 메모리 클 럭 사이클 동안에 DataA와 DataB를 읽어올 수 있다. 예컨대, 로우 디코더(예, 도 43의 로우 디코더) 및 컬럼 디코더(도 43에 도시된 바와 같이, 하나 이상의 컬럼 멀티플렉서와 분리되거나 병합될 수 있음)는 2개의 어드레스를 생성하는 상응하는 논리 회로의 속도보다 적어도 2배 빠른 클러킹 되도록 구성될 수 있다. 예를 들 어, 회로에 대한 클럭 회로(도 43에는 미도시)는 2개의 어드레스를 생성하는 상응하는 논리 회로의 속도 보다 적어도 2배 빠른 속도에 따라 회로를 클러킹 할 수 있다. 도 42와 도 43의 실시예는 별개로 또는 함께 사용될 수 있다. 이에 따라, 단일 포트 메모리 어레이 또는 매트 상에 듀얼 포트 기능을 제공하는 회로(예, 회로 또는 회로)는 적어도 하나의 행과 적어도 하나의 열을 따라 배열된 복수의 메모리 뱅크를 포함할 수 있다. 복수의 메모리 뱅크는 도 42에 메모리 어레이로 도시되어 있고 도 43에 메모리 어레이로 도시되어 있다. 본 실시예는 또한 단일 클럭 사이클 동안에 읽기 또는 쓰기를 위한 2개의 어드레스를 수신하도록 구성된 적어도 하나의 로우 멀티플렉서(도 43에 도시) 또는 적 어도 하나의 컬럼 멀티플렉서(도 42에 도시)를 사용할 수 있다. 또한, 본 실시예는 로우 디코더(예, 도 42의 로 우 디코더 및 도 43의 로우 디코더) 및 컬럼 디코더(도 42와 도 43에 도시된 바와 같이, 하나 이상 의 컬럼 멀티플렉서와 분리되거나 병합될 수 있음)를 사용하여 2개의 어드레스에 읽기 또는 쓰기를 할 수 있다. 예를 들어, 로우 디코더와 컬럼 디코더는 제1 사이클 동안에 적어도 하나의 로우 멀티플렉서 또는 적어도 하나 의 컬럼 멀티플렉서로부터 2개의 어드레스 중 제1 어드레스를 읽어오고 제1 어드레스에 상응하는 워드라인 및 비트라인을 디코딩할 수 있다. 또한, 로우 디코더와 컬럼 디코더는 제2 사이클 동안에 적어도 하나의 로우 멀티 플렉서 또는 적어도 하나의 컬럼 멀티플렉서로부터 2개의 어드레스 중 제2 어드레스를 읽어오고 제2 어드레스에 상응하는 워드라인 및 비트라인을 디코딩할 수 있다. 이러한 읽어오기는 각각, 로우 디코더를 사용하여 어드레 스에 상응하는 워드라인을 활성화하고, 컬럼 디코더를 사용하여 이 어드레스에 상응하는 활성화된 워드라인 상 의 비트라인을 활성화하여 이루어질 수 있다. 상기에서는 읽어오기에 대하여 설명하였지만, 도 42 와 도 43의 실시예들은 개별적으로 구현되거나 함께 구현되 는 여부와 관계없이, 쓰기 명령을 포함할 수 있다. 예를 들어, 제1 사이클 동안에, 로우 디코더와 컬럼 디코더 는 적어도 하나의 로우 멀티플렉서 또는 적어도 하나의 컬럼 멀티플렉서에서 읽어온 제1 데이터를 2개의 어드레 스 중의 제1 어드레스에 기록할 수 있다. 또한, 제2 사이클 동안에, 로우 디코더와 컬럼 디코더는 적어도 하나 의 로우 멀티플렉서 또는 적어도 하나의 컬럼 멀티플렉서에서 읽어온 제2 데이터를 2개의 어드레스 중의 제2 어 드레스에 기록할 수 있다. 도 42의 예는 제1 및 제2 어드레스가 워드라인 어드레스를 공유하는 경우의 이러한 프로세스를 보여주고, 도 43 의 예는 제1 및 제2 어드레스가 컬럼 어드레스를 공유하는 경우의 이러한 프로세스를 보여준다. 하기에 도 47을 참조하여 설명하는 바와 같이, 제1 및 제2 어드레스가 워드라인 어드레스 또는 컬럼 어드레스를 공유하지 않는 경우에 동일 프로세스가 구현될 수 있다. 이에 따라, 상기의 예는 행 및 열 중의 적어도 하나를 따라 듀얼 포트 접근을 제공하지만, 추가적인 실시예는 행 및 열 모두를 따라 듀얼 포트 접근을 제공할 수 있다. 도 44는 본 개시에 따른 회로가 사용되는 메모 리 칩의 행과 열 모두를 따라 듀얼 포트 접근을 제공하는 예시적인 회로를 도시한 것이다. 이에 따라, 회 로는 도 42의 회로와 도 43의 회로의 조합을 나타내는 것을 수 있다. 도 44에 도시된 실시예는 하나의 메모리 어레이를 멀티플렉서(\"mux\")와 결합된 로우 디코더와 함께 사용하여 논리 회로에 대한 동일한 클럭 사이클 동안에 2개의 행에 접근할 수 있다. 또한, 도 44에 도시된 실시 예는 메모리 어레이를 멀티플렉서(\"mux\")와 결합된 컬럼 디코더(또는 멀티플렉서)와 함께 사용하여동일한 클럭 사이클 동안에 2개의 열에 접근할 수 있다. 예를 들어, 2 메모리 클럭 사이클의 제1 사이클에서, RowAddrA가 로우 디코더에서 사용되고, ColAddrA가 컬럼 멀티플렉서에서 사용되어 어드레스 (RowAddrA, ColAddrA)를 가진 메모리 셀로부터의 데이터를 버퍼링 할 수 있다(예, 도 44의 'Buffered Word' 버 퍼로). 2 메모리 클럭 사이클의 제2 사이클에서, RowAddrB가 로우 디코더에서 사용되고, ColAddrA가 컬럼 멀티플렉서에서 사용되어 어드레스 (RowAddrB, ColAddrA)를 가진 메모리 셀로부터의 데이터를 버퍼링 할 수 있다. 따라서, 회로는 2개의 상이한 어드레스에서 메모리 셀 상에 저장된 데이터(예, DataA 및 Data B)로의 듀얼 포트 접근을 가능하게 할 수 있다. 로우 디코더는 각 워드라인을 활성화하기 위해 하나의 메 모리 클럭 사이클이 필요할 수 있기 때문에 도 44에 도시된 예와 같은 실시예들은 추가적인 버퍼를 사용할 수 있다. 이에 따라, 회로를 사용하는 메모리 칩은 상응하는 논리 회로보다 클럭 속도가 적어도 2배 빠른 경 우에 듀얼 포트 메모리로 기능할 수 있다. 도 44에는 도시되어 있지 않지만, 회로는 행 또는 워드라인을 따라 도 46(하기에 설명)의 추가 회로 및/ 또는 열 또는 비트라인을 따라 유사한 추가 회로를 더 포함할 수 있다. 이에 따라, 회로는 상응하는 회로 를 활성화하여(예, 도 46의 스위칭 요소(4613a, 4613b) 등의 하나 이상과 같은 하나 이상의 스위칭 요소를 개방 하여) 어드레스를 포함하는 단전된 부분을 활성화할 수 있다(예, 단전된 부분에 전압을 연결하거나 전류를 흐르 게 하여). 이에 따라, 회로는 회로의 요소(예, 라인 등)가 어드레스에 의해 식별된 위치를 포함하는 경우 및/또 는 회로의 요소(예, 스위칭 요소)가 어드레스에 의해 식별된 메모리 셀로의 전압의 공급 및/또는 전류의 흐름을 제어하는 경우에 '상응'할 수 있다. 이후, 회로는 로우 디코더와 컬럼 멀티플렉서를 사용하 여 상응하는 워드라인과 비트라인을 디코딩하고, 활성화된 단전 부분에 위치하는 어드레스에 데이터를 읽기 또 는 쓰기 할 수 있다. 도 44에 더 도시된 바와 같이, 회로는 읽기와 쓰기를 위한 두 개의 어드레스를 단일 클럭 사이클 동안에 가져오도록 구성된 적어도 하나의 로우 멀티플렉서(로우 디코더와 분리된 것으로 도시되어 있지만 그 안 에 포함될 수 있음) 및/또는 적어도 하나의 컬럼 멀티플렉서(컬럼 멀티플렉서와 분리된 것으로 도시되어 있지만 그 안에 포함될 수 있음)를 더 사용할 수 있다. 이에 따라, 본 실시예들은 로우 디코더(예, 로우 디코더 )와 컬럼 디코더(컬럼 멀티플렉서와 분리되거나 병합될 수 있음)를 사용하여 두 개의 어드레스에 읽기와 쓰기를 할 수 있다. 예를 들어, 로우 디코더와 컬럼 디코더는 메모리 클럭 사이클 동안에 적어도 하나의 로우 멀티플렉서 또는 적어도 하나의 컬럼 멀티플렉서로부터 2개의 어드레스 중의 제1 어드레스를 가져오고 제1 어드레스에 상응하는 워드라인 및 비트라인을 디코딩할 수 있다. 또한, 로우 디코더와 컬럼 디코더는 동일 메모 리 사이클 동안에 적어도 하나의 로우 멀티플렉서 또는 적어도 하나의 컬럼 멀티플렉서로부터 2개의 어드레스 중의 제2 어드레스를 가져오고 제2 어드레스에 상응하는 워드라인 및 비트라인을 디코딩할 수 있다. 도 45a와 도 45b는 단일 포트 메모리 어레이 또는 매트 상에 듀얼 포트 기능을 제공하기 위한 기존의 복제 방식 을 도시한 것이다. 도 45a에 도시된 바와 같이, 듀얼 포트 읽기는 메모리 어레이 또는 매트 전체에 걸쳐 데이터 의 복제 사본의 동기화 상태를 유지함으로써 제공될 수 있다. 이에 따라, 읽기는 도 45a에 도시된 바와 같이 메 모리 인스턴스의 두 사본 모두에서 수행될 수 있다. 또한, 도 45b에 도시된 바와 같이, 메모리 어레이 또는 매 트 전체에 걸쳐 모든 쓰기를 복제함으로써 듀얼 포트 쓰기가 제공될 수 있다. 예를 들면, 메모리 칩은 메모리 칩을 사용하는 모든 논리 회로가 데이터의 각 복제 사본에 하나씩 쓰기 명령의 복제를 전송할 것을 요구할 수 있다. 또는, 일부 실시예에서, 도 45a에 도시된 바와 같이, 추가 회로를 구비함으로써, 사본의 동기화 상태를 유지하기 위하여 메모리 어레이 또는 매트 전체에 걸쳐 기록된 데이터의 복제 사본을 생성하도록 추가 회로에 의해 자동으로 복제된 단일 쓰기 명령을 메모리 인스턴스를 사용하는 논리 회로가 전송할 수 있다. 도 42, 도 43, 및 도 44의 실시예들은, 멀티플렉서를 사용하여 단일 메모리 클럭 사이클에서 2개의 비트라인에 접근(예, 도 42 참조) 및/또는 메모리의 클럭 속도를 상응하는 논리 회로보다 빠르게 하고(예, 도 43 참조) 모든 데이터 를 메모리에 복제하는 대신에 추가 어드레스를 처리할 추가 멀티플렉서를 제공함으로써, 이러한 기존의 복제 방 식에서 중복성을 감소시킬 수 있다. 상기에 설명한 클럭 속도의 증가 및/또는 추가 멀티플렉서 외에도, 본 개시의 실시예들은 메모리 어레이 내의 어느 지점에서 비트라인 및/또는 워드라인을 단전하는 회로를 사용할 수 있다. 이러한 실시예들에서, 단전 회로 의 동일 부분으로 결합되지 않은 상이한 위치에 로우 디코더 및 컬럼 디코더가 접근하는 한, 어레이로 다중 동 시 접근이 가능하다. 예를 들어, 단전 회로는 로우 디코더 및 컬럼 디코더가 전기적 간섭 없이 상이한 어드레스 에 접근할 수 있게 할 수 있으므로, 상이한 워드라인과 비트라인을 가진 위치가 동시에 접근될 수 있다. 메모리 내의 단전 영역의 입도(granularity)는 메모리 칩의 설계 과정에서 단전 회로에 의해 요구되는 추가 부분과 비 교하여 고려될 수 있다. 이러한 동시 접근을 이행하기 위한 아키텍처가 도 46에 도시되어 있다. 구체적으로, 도 46은 단일 포트 메모리 어레이 또는 매트에 듀얼 포트 기능을 제공하는 예시적인 회로를 도시한 것이다. 도 46에 도시된 바와 같 이, 회로는 적어도 하나의 행과 적어도 하나의 열을 따라 배열된 복수의 메모리 매트(예, 4609a, 4609b 등)를 포함할 수 있다. 회로의 레이아웃은 행에 상응하는 워드라인(4611a, 4611b)과 같은 복수의 워드라 인과 열에 상응하는 비트라인(4615a, 4615b)을 더 포함할 수 있다. 도 46의 예는 각각 2개의 라인과 8개의 열이 있는 12개의 메모리 매트를 포함한다. 다른 실시예에서, 기판은 모 든 임의의 수의 메모리 매트를 포함할 수 있고, 각 메모리 매트는 모든 임의의 수의 라인과 모든 임의의 수의 열을 포함할 수 있다. 일부 메모리 매트는 동일 수의 라인과 열(도 46의 예)을 포함할 수 있는 반면에, 다른 메 모리 매트는 상이한 수의 라인 및/또는 열을 포함할 수 있다. 도 46에는 도시되어 있지 않지만, 회로는 읽기와 쓰기를 위한 2개(또는 3개 또는 모든 임의의 복수)의 어 드레스를 단일 클럭 사이클 동안에 수신하도록 구성된 적어도 하나의 로우 멀티플렉서(로우 디코더(4601a 및/또 는 4601b)와 분리 또는 일체) 또는 적어도 하나의 컬럼 멀티플렉서(예, 컬럼 멀티플렉서(4603a 및/또는 4603 b))를 더 사용할 수 있다. 또한, 본 실시예들은 로우 디코더(예, 로우 디코더(4601a 및/또는 4601b) 및 컬럼 멀 티플렉서(4603a 및/또는 4603b)와 분리 또는 일체일 수 있음)를 사용하여 2개(또는 그 이상)의 어드레스에 읽기 또는 쓰기를 할 수 있다. 예를 들어, 로우 디코더와 컬럼 디코더는 메모리 클럭 사이클 동안에 2개의 어드레스 중의 제1 어드레스를 적어도 하나의 로우 멀티플렉서 또는 적어도 하나의 컬럼 멀티플렉서로부터 읽어오고 제1 어드레스에 상응하는 워드라인 또는 비트라인을 디코딩할 수 있다. 또한, 로우 디코더와 컬럼 디코더는 동일한 메모리 사이클 동안에 2개의 어드레스 중의 제2 어드레스를 적어도 하나의 로우 멀티플렉서 또는 적어도 하나의 컬럼 멀티플렉서로부터 읽어오고 제2 어드레스에 상응하는 워드라인 또는 비트라인을 디코딩할 수 있다. 앞서 설명한 바와 같이, 2개의 어드레스가 단전 회로의 동일 부분(예, 4613a, 4613b 등과 같은 스위칭 요소)에 결합 되지 않은 상이한 위치에 있는 한, 접근은 동일 메모리 클럭 사이클 동안에 일어날 수 있다. 또한, 회로 는 제1 메모리 클럭 사이클 동안에 첫 번째 2개의 어드레스에 동시에 접근한 후에 제2 메모리 클럭 사이클 동안 에 두 번째 2개의 어드레스에 동시에 접근할 수 있다. 이러한 실시예에서, 회로를 사용하는 메모리 칩은 상응하는 논리 회로보다 클럭 속도가 적어도 2배 빠른 경우에 4 포트 메모리로 기능 할 수 있다. 도 46은 스위치로 기능 하도록 구성된 적어도 하나의 행 회로 및 적어도 하나의 열 회로를 더 포함한다. 예를 들어, 4613a, 4613b 등과 같은 상응하는 스위칭 요소는 4613a, 4613b 등과 같은 스위칭 요소에 연결된 워드라인 도는 비트라인으로부터 전류가 흐르도록 또는 흐르지 못하도록 및/또는 전압이 연결되도록 또는 연결되지 못하 도록 구성된 트랜지스터 또는 모든 임의의 다른 전기 요소를 포함할 수 있다. 따라서, 상응하는 스위칭 요소는 회로를 단전된 부분으로 구분할 수 있다. 여기에는 단일 행과 각 행의 16열을 포함하는 것으로 도시되어 있지만, 회로 내의 단전된 부분은 회로의 설계에 따라 상이한 수준의 입도를 포함할 수 있다. 회로는 앞서 설명한 어드레스 동작 동안에 상응하는 단전된 영역을 활성화하기 위하여 컨트롤러(예, 행 컨트롤)를 사용하여 적어도 하나의 행 회로 및 적어도 하나의 열 회로의 상응하는 회로를 활성화할 수 있 다. 예를 들어, 회로는 스위칭 요소 중의 가까운 상응하는 스위칭 요소(예, 4613a, 4613b 등)로 하나 이 상의 제어 신호를 전송할 수 있다. 스위칭 요소(4613a, 4613b 등)가 트랜지스터를 포함하는 실시예에서, 제어 신호는 트랜지스터를 개방하기 위한 전압을 포함할 수 있다. 어드레스를 포함하는 단전된 영역에 따라, 스위칭 요소 중의 하나 이상이 회로에 의해 활성화될 수 있다. 예를 들어, 도 46의 메모리 매트(4609b) 내의 어드레스에 도달하기 위해, 메모리 매트(4609a)로의 접근을 허용 하는 스위칭 요소는 메모리 매트(4609b)로의 접근을 허용하는 스위칭 요소와 함께 개방되어야 한다. 행 컨트롤 은 회로 내의 특정 어드레스를 읽어오기 위하여 특정 어드레스에 따라 스위칭 요소의 활성화를 결 정할 수 있다. 도 46은 메모리 어레이(예, 메모리 매트(4609a, 4609b 등)를 포함)의 워드라인을 분리하는데 사용되는 회로 의 예를 나타낸 것이다. 그러나 다른 실시예들은 유사한 회로(예, 메모리 칩을 단전 영역으로 분리 하는 스위칭 요소)를 사용하여 메모리 어레이의 비트라인을 분리할 수 있다. 이에 따라, 회로의 아키텍처 는 도 42 또는 도 44에 도시된 것과 같은 듀얼-컬럼 접근에 사용될 수 있을 뿐만 아니라 도 43 또는 도 44에 도 시된 것과 같은 듀얼-로우 접근에 사용될 수 있다. 메모리 어레이 또는 매트로의 멀티 사이클 접근을 위한 프로세스가 도 47a에 도시되어 있다. 구체적으로, 도 47a는 싱글 포트 메모리 어레이 또는 매트(예, 도 43의 회로 또는 도 44의 회로 사용) 상에 듀얼 포트 접근을 제공하기 위한 프로세스의 예시적인 순서도이다. 프로세스는 도 43 또는 도 44의 로우디코더(4303 또는 4304) 및 컬럼 디코더(도 43 또는 도 44의 컬럼 멀티플렉서(4305 또는 4405)와 같은 하나 이 상의 컬럼 멀티플렉서와 분리 또는 일체일 수 있음)와 같은 본 개시에 따른 로우 디코더 및 컬럼 디코더를 사용 하여 실행될 수 있다. 단계 4710에서, 제1 메모리 클럭 사이클 동안에, 회로는 적어도 하나의 로우 멀티플렉서와 적어도 하나의 컬럼 멀티플렉서를 사용하여 2개의 어드레스의 제1 어드레스에 상응하는 워드라인 및 비트라인을 디코딩할 수 있다. 예를 들어, 적어도 하나의 로우 디코더는 워드라인을 활성화할 수 있고, 적어도 하나의 컬럼 멀티플렉서는 활성 화된 워드라인을 따르고 제1 어드레스에 상응하여 메모리 셀로부터의 전압을 증폭할 수 있다. 증폭된 전압은 회 로를 포함하는 메모리 칩을 활용하는 논리 회로로 제공되거나 하기에 설명하는 단계 4720에 따라 버퍼링 될 수 있다. 논리 회로는 GPU나 CPU와 같은 회로를 포함하거나, 예를 들어 도 7a에 도시된 바와 같이 메모리 칩과 동 일한 기판 상에 프로세싱 그룹을 포함할 수 있다. 상기에서는 읽기 동작으로 설명하였지만, 방법은 쓰기 동작도 유사하게 처리할 수 있다. 예를 들면, 적어 도 하나의 로우 디코더는 워드라인을 활성화하고, 적어도 하나의 컬럼 멀티플렉서는 활성화된 워드라인을 따르 고 제1 어드레스에 상응하여 메모리 셀로 전압을 인가하여 새로운 데이터를 메모리 셀에 기록할 수 있다. 일부 실시예에서, 회로는 회로를 포함하는 메모리 칩을 활용하는 논리 회로로 쓰기의 확인을 제공하거나 하기의 단계 4720에 따라 확인을 버퍼링 할 수 있다. 단계 4720에서, 회로는 제1 어드레스의 읽어온 데이터를 버퍼링 할 수 있다. 예를 들어, 도 43과 도 44에 도시 된 바와 같이, 버퍼로 인해 회로는 2개의 어드레스 중의 제2 어드레스를 읽어올 수 있고(하기의 단계 4730에서 설명) 두 읽어오기 모두의 결과를 함께 출력할 수 있다. 버퍼는 레지스터, SRAM, 비휘발성 메모리, 또는 모든 임의의 다른 데이터 저장 장치를 포함할 수 있다. 단계 4730에서, 제2 메모리 클럭 사이클 동안에, 회로는 적어도 하나의 로우 멀티플렉서와 적어도 하나의 컬럼 멀티플렉서를 사용하여 2개의 어드레스의 제2 어드레스에 상응하는 워드라인과 비트라인을 디코딩할 수 있다. 예를 들어, 적어도 하나의 로우 디코더는 워드라인을 활성화할 수 있고, 적어도 하나의 컬럼 멀티플렉서는 활성 화된 워드라인을 따르고 제2 어드레스에 상응하여 메모리 셀로부터의 전압을 증폭할 수 있다. 증폭된 전압은 회 로를 포함하는 메모리 칩을 활용하는 논리 회로로, 개별적으로 또는 예를 들어 단계 4720에서 버퍼링된 전압과 함께, 제공될 수 있다. 논리 회로는 GPU나 CPU와 같은 회로를 포함하거나, 예를 들어 도 7a에 도시된 바와 같이 메모리 칩과 동일한 기판 상에 프로세싱 그룹을 포함할 수 있다. 상기에서는 읽기 동작으로 설명하였지만, 방법은 쓰기 동작도 유사하게 처리할 수 있다. 예를 들면, 적어 도 하나의 로우 디코더는 워드라인을 활성화하고, 적어도 하나의 컬럼 멀티플렉서는 활성화된 워드라인을 따르 고 제2 어드레스에 상응하여 메모리 셀로 전압을 인가하여 새로운 데이터를 메모리 셀에 기록할 수 있다. 일부 실시예에서, 회로는 개별적으로 또는 단계 4720 등에서 버퍼링된 전압과 함께 회로를 포함하는 메모리 칩을 활 용하는 논리 회로로 쓰기의 확인을 제공할 수 있다 단계 4740에서, 회로는 버퍼링된 제1 어드레스와 함께 제2 어드레스의 읽어온 데이터를 출력할 수 있다. 예를 들어, 도 43과 도 44에 도시된 바와 같이, 회로는 두 읽어오기(예, 단계 4710과 단계 4730) 모두의 결과를 함께 출력할 수 있다. 회로는 회로를 포함하는 메모리 칩을 활용하는 논리 회로로 결과를 출력할 수 있다. 논리 회로 는 GPU나 CPU와 같은 회로를 포함하거나, 예를 들어 도 7a에 도시된 바와 같이 메모리 칩과 동일한 기판 상에 프로세싱 그룹을 포함할 수 있다. 상기에서는 다중 사이클에 대하여 설명하였지만, 도 42에 도시된 바와 같이 2개의 어드레스가 워드라인을 공유 하는 경우에, 방법은 2개의 어드레스로 단일 사이클 접근도 가능하다. 예를 들어, 다중 컬럼 멀티플렉서 가 동일 메모리 클럭 사이클 동안에 동일 워드라인 상의 상이한 비트라인을 디코딩할 수 있으므로, 단계 4710과 단계 4730은 동일 메모리 클럭 사이클 동안에 수행될 수 있다. 이러한 실시예에서, 버퍼링을 하는 단계 4720은 건너뛸 수 있다. 동시 접근(예, 상기에 설명한 회로를 활용)을 위한 프로세스가 도 47b에 도시되어 있다. 이에 따라, 단계 가 순차적으로 도시되어 있지만, 도 47b의 단계들은 동일 메모리 클럭 사이클 동안에 수행될 수 있고, 적어도 일부 단계들(예, 단계 4760과 4780 또는 단계 4770과 4790)은 동시에 실행될 수 있다. 구체적으로, 도 47b는 단 일 포트 메모리 어레이 또는 매트(예, 도 42의 회로 또는 도 46의 회로 활용) 상에 듀얼 포트 접근 을 제공하기 위한 프로세스의 예시적인 순서도이다. 프로세스는 도 42 또는 도 46의 로우 디코더 (4203 또는 4601a 및 4601b) 및 컬럼 디코더(도 42 또는 도 46의 컬럼 멀티플렉서(4205a 및 4205b 또는 4603a및 4603b)와 같은 하나 이상의 컬럼 멀티플렉서와 분리 또는 일체일 수 있음)와 같은 본 개시에 따른 로우 디코 더 및 컬럼 디코더를 사용하여 실행될 수 있다. 단계 4760에서, 회로는, 메모리 클럭 사이클 동안에, 2개의 어드레스의 제1 어드레스에 의거하여 적어도 하나의 행 회로와 적어도 하나의 열 회로의 상응하는 회로를 활성화할 수 있다. 예를 들어, 회로는 적어도 하나의 행 회로와 적어도 하나의 열 회로를 포함하는 스위칭 요소의 가까운 상응하는 요소로 하나 이상의 제어 신호를 전 송할 수 있다. 이에 따라, 회로는 2개의 어드레스의 제1 어드레스를 포함하는 상응하는 단전 영역에 접근할 수 있다. 단계 4770에서, 메모리 클럭 사이클 동안에, 회로는 적어도 하나의 로우 멀티플렉서와 적어도 하나의 컬럼 멀티 플렉서를 활용하여 제1 어드레스에 상응하는 워드라인과 비트라인을 디코딩할 수 있다. 예를 들면, 적어도 하나 의 로우 디코더는 워드라인을 활성화할 수 있고, 적어도 하나의 컬럼 멀티플렉서는 활성화된 워드라인을 따르고 제1 어드레스에 상응하여 메모리 셀로부터의 전압을 증폭할 수 있다. 증폭된 전압은 회로를 포함하는 메모리 칩 을 활용하는 논리 회로로 제공될 수 있다. 예컨대, 앞서 설명한 바와 같이, 논리 회로는 GPU나 CPU와 같은 회로 를 포함하거나, 예를 들어 도 7a에 도시된 바와 같이 메모리 칩과 동일한 기판 상에 프로세싱 그룹을 포함할 수 있다. 상기에서는 읽기 동작으로 설명하였지만, 방법은 쓰기 동작도 유사하게 처리할 수 있다. 예를 들면, 적어 도 하나의 로우 디코더는 워드라인을 활성화하고, 적어도 하나의 컬럼 멀티플렉서는 활성화된 워드라인을 따르 고 제1 어드레스에 상응하여 메모리 셀로 전압을 인가하여 새로운 데이터를 메모리 셀에 기록할 수 있다. 일부 실시예에서, 회로는 회로를 포함하는 메모리 칩을 활용하는 논리 회로로 쓰기의 확인을 제공할 수 있다. 단계 4780에서, 동일 사이클 동안에, 회로는 2개의 어드레스의 제2 어드레스에 의거하여 적어도 하나의 행 회로 와 적어도 하나의 열 회로의 상응하는 회로를 활성화할 수 있다. 예를 들어, 회로는 적어도 하나의 행 회로와 적어도 하나의 열 회로를 포함하는 스위칭 요소의 가까운 상응하는 요소로 하나 이상의 제어 신호를 전송할 수 있다. 이에 따라, 회로는 2개의 어드레스의 제2 어드레스를 포함하는 상응하는 단전 영역에 접근할 수 있다. 단계 4790에서, 동일 사이클 동안에, 회로는 적어도 하나의 로우 멀티플렉서와 적어도 하나의 컬럼 멀티플렉서 를 사용하여 제2 어드레스에 상응하는 워드라인과 비트라인을 디코딩할 수 있다. 예를 들어, 적어도 하나의 로 우 디코더는 워드라인을 활성화할 수 있고, 적어도 하나의 컬럼 멀티플렉서는 활성화된 워드라인을 따르고 제2 어드레스에 상응하여 메모리 셀로부터의 전압을 증폭할 수 있다. 증폭된 전압은 회로를 포함하는 메모리 칩을 활용하는 논리 회로로 제공될 수 있다. 예를 들어, 앞서 설명한 바와 같이, 논리 회로는 GPU나 CPU와 같은 종래 의 회로를 포함하거나, 도 7a에 도시된 바와 같이 메모리 칩과 동일한 기판 상에 프로세싱 그룹을 포함할 수 있 다. 상기에서는 읽기 동작으로 설명하였지만, 방법은 쓰기 동작도 유사하게 처리할 수 있다. 예를 들면, 적어 도 하나의 로우 디코더는 워드라인을 활성화하고, 적어도 하나의 컬럼 멀티플렉서는 활성화된 워드라인을 따르 고 제2 어드레스에 상응하여 메모리 셀로 전압을 인가하여 새로운 데이터를 메모리 셀에 기록할 수 있다. 일부 실시예에서, 회로는 회로를 포함하는 메모리 칩을 활용하는 논리 회로로 쓰기의 확인을 제공할 수 있다. 상기에서는 단일 사이클을 참조하여 설명하였지만, 2개의 어드레스가 워드라인과 비트라인을 공유하는(또는 적 어도 하나의 행 회로와 적어도 하나의 열 회로에서 스위칭 요소를 공유하는) 단전 영역에 있는 경우, 방법 은 2개의 어드레스로 멀티 사이클 접근을 가능하게 할 수 있다. 예를 들면, 단계 4760과 단계 4770은 제1 로우 디코더와 제1 컬럼 멀티플렉서가 제1 어드레스에 상응하는 워드라인과 비트라인을 디코딩할 수 있는 제1 메모리 클럭 사이클 동안에 수행될 수 있고, 단계 4780과 단계 4790은 제2 로우 디코더와 제2 컬럼 멀티플렉서 가 제2 어드레스에 상응하는 워드라인과 비트라인을 디코딩할 수 있는 제2 메모리 클럭 사이클 동안에 수행될 수 있다. 행과 열을 모두 따라 듀얼 포트 접근을 하는 아키텍처의 다른 예가 도 48에 도시되어 있다. 구체적으로, 도 48 은 다중 로우 디코더를 다중 컬럼 멀티플렉서와 함께 활용하여 행과 열을 모두 따라 듀얼 포트 접근을 제공하는 예시적인 회로를 도시한 것이다. 도 48에서, 로우 디코더(4801a)는 제1 워드라인에 접근할 수 있고, 컬럼 멀티플렉서(4803a)는 제1 워드라인을 따라 하나 이상의 메모리 셀로부터의 데이터를 디코딩할 수 있는 반면, 로 우 디코더(4801b)는 제2 워드라인에 접근할 수 있고, 컬럼 멀티플렉서(4803b)는 제2 워드라인을 따라 하나 이상 의 메모리 셀로부터의 데이터를 디코딩할 수 있다. 도 47b를 참조하여 설명한 바와 같이, 이 접근은 하나의 메모리 클럭 사이클 동안에 동시일 수 있다. 이에 따라, 도 46의 아키텍처와 유사하게, 도 48의 아키텍처(하기의 도 49에서 설명하는 메모리 매트를 포함)는 다중 어드레스가 동일 클럭 사이클에서 접근되도록 할 수 있다. 예를 들어, 도 48의 아키텍처는 모든 임의의 수의 로 우 디코더와 모든 임의의 수의 컬럼 멀티플렉서를 포함하여 로우 디코더와 컬럼 멀티플렉서의 수에 상응하는 수 의 어드레스가 모두 단일 메모리 클럭 사이클 이내에서 접근되도록 할 수 있다. 다른 실시예에서, 이 접근은 두 메모리 클럭 사이클을 따라 순차적일 수 있다. 메모리 칩의 클럭 속도를 상응하는 논리 회로보다 빠르게 함으로써, 두 메모리 클럭 사이클은 메모리를 사용하는 논리 회로에 대한 하나 의 클럭 사이클과 동등할 수 있다. 예를 들어, 앞서 설명한 바와 같이, 논리 회로는 GPU나 CPU와 같은 종래의 회로를 포함하거나, 도 7a에 도시된 바와 같이 메모리 칩과 동일한 기판 상에 프로세싱 그룹을 포함할 수 있다. 다른 실시예들은 동시 접근을 가능하게 할 수 있다. 예를 들어, 도 42를 참조하여 설명한 바와 같이, 다중 컬럼 디코더(도 48에 도시된 4803a 및 4803b와 같은 컬럼 멀티플렉서를 포함할 수 있음)가 단일 메모리 클럭 사이클 동안에 동일 워드라인을 따라 다중 비트라인을 읽을 수 있다. 추가적으로 또는 대안적으로, 도 46을 참조하여 설명한 바와 같이, 회로는 추가적인 회로를 포함하여 이 접근이 동시가 되게 할 수 있다. 예를 들면, 로 우 디코더(4801a)는 제1 워드라인에 접근하고, 컬럼 멀티플렉서(4803a)는 로우 디코더(4801b)가 제2 워드라인에 접근하는 동일 메모리 클럭 사이클 동안에 제1 워드라인을 따라 메모리 셀로부터의 데이터를 디코딩할 수 있고, 컬럼 멀티플렉서(4803b)는 제2 워드라인을 따라 메모리 셀로부터의 데이터를 디코딩할 수 있다. 도 48의 아키텍처는 도 49에 도시된 바와 같은 메모리 뱅크를 형성하는 변형 메모리 매트와 함께 사용될 수 있 다. 도 49에서, 각 메모리 셀(DRAM과 유사하게 커패시터로 도시되었지만 SRAM 또는 임의의 다른 메모리 셀과 유 사한 방식으로 배열된 다수의 트랜지스터를 포함할 수도 있음)에는 2개의 워드라인과 2개의 비트라인이 접근된 다. 이에 따라, 도 49의 메모리 매트는 2개의 상이한 비트를 동시에 접근할 수 있게 하거나 2개의 상이한 논리 회로에 의한 동일 비트의 접근마저 가능하게 한다. 그러나 도 49의 실시예는 상기의 실시예와 같이 단일 포트 접근을 위해 배선되는 표준 DRAM 메모리 매트 상의 듀얼 포트 솔루션을 구현하기 보다는 메모리 매트의 변 형을 활용한다. 상기에서는 2개의 포트로 설명하였지만, 상기에 설명한 모든 임의의 실시예들은 2개의 포트 이상으로 확장될 수 있다. 예를 들어, 도 42, 도 46, 도 48, 및 도 49의 실시예들은 각각 추가적인 열 또는 로우 멀티플렉서를 포함 하여 단일 클럭 사이클 동안에 각각 추가적인 열 또는 행으로의 접근을 제공할 수 있다. 다른 예를 들면, 도 43 및 도 44의 실시예들은 추가적인 로우 디코더 및/또는 컬럼 멀티플렉서를 포함하여 단일 클럭 사이클 동안에 각 각 추가적인 행 또는 열로의 접근을 제공할 수 있다. 메모리 내의 가변 워드 길이 접근 이상과 이하에서, '결합'이라는 용어는 직접 연결, 간접 연결, 전기적 연결 등을 포함하는 의미로 사용될 수 있 다. 또한, '제1', '제2' 등의 용어는 이름이나 명칭이 동일하거나 유사한 구성요소 또는 방법 단계 사이의 구분을 위해 사용될 뿐이고, 반드시 공간적 또는 시간적 순서를 나타내는 것이 아니다. 일반적으로, 메모리 칩은 메모리 뱅크를 포함한다. 메모리 뱅크는 읽기나 쓰기를 할 특정 워드(또는 기타 고정 사이즈의 데이터 유닛)를 선택하도록 구성된 로우 디코더 및 컬럼 디코더에 결합될 수 있다. 각 메모리 뱅크는 데이터 유닛을 저장하기 위한 메모리 셀, 로우 디코더 및 컬럼 디코더에 의해 선택된 메모리 셀로부터의 전압을 증폭하기 위한 센스 증폭기, 및 모든 임의의 기타 적절한 회로를 포함할 수 있다. 각 메모리 뱅크는 보통 특정 I/O 폭을 가진다. 예를 들어, I/O 폭은 워드를 포함할 수 있다. 메모리 칩을 사용하는 논리 회로에 의해 실행되는 일부 프로세스는 매우 긴 워드를 사용하는 것이 이점이 있을 수 있는 반면에, 일부 다른 프로세스는 워드의 일부만 필요할 수 있다. 실제로, 인메모리(in-memory) 컴퓨팅 유닛(예, 도 7a에 도시되고 설명된 바와 같은, 메모리 칩과 동일한 기판에 배치된 프로세서 서브유닛)이 워드의 일부만 필요로 하는 메모리 접근 동작을 수행하는 경우가 흔하다. 워드의 일부만이 사용되는 경우에 워드 전체의 접근과 연관된 지연을 줄이기 위하여, 본 개시의 실시예들은 워 드의 하나 이상의 부분만을 가져오는 방법과 시스템을 제공함으로써 워드의 불필요한 부분의 전송과 연관된 데 이터 손실을 감소하고 메모리 장치의 전력 소모를 감소할 수 있다. 또한, 본 개시의 실시예들은 메모리 칩과, 워드의 일부에만 읽기와 쓰기를 하는 메모리 칩에 접근하는 기타 구 성(예, CPU나 GPU와 같이 분리되어 있거나, 도 7a에 도시되고 설명된 프로세서 서브유닛과 같이 메모리 칩과 동 일한 기판 상에 포함된, 논리 회로) 사이의 상호작용의 전력 소모도 감소시킬 수 있다. 메모리 접근 명령(예, 메모리를 사용하는 논리 회로로부터의 명령)은 메모리 내의 어드레스를 포함할 수 있다. 예를 들어, 어드레스는 로우 어드레스와 컬럼 어드레스를 포함하거나 메모리의 메모리 컨트롤러 등에 의해 로우 어드레스 및 컬럼 어드레스로 변환될 수 있다. DRAM과 같은 많은 휘발성 메모리에서, 로우 어드레스는 로우 디코더로 전송되고(예, 논리 회로에 의해 직접 또 는 메모리 컨트롤러를 활용하여), 로우 디코더는 행(워드라인이라고도 지칭) 전체를 활성화하고 당해 행에 포함 된 모든 비트라인을 로딩한다. 컬럼 어드레스는 비트라인을 포함하는 메모리 뱅크 외부와 다음 레벨 회로로 전송되는 활성화된 행 상의 비트라 인을 식별한다. 예를 들면, 다음 레벨 회로는 메모리 칩의 I/O 버스를 포함할 수 있다. 인메모리 프로세싱을 활 용하는 실시예에서, 다음 레벨 회로는 메모리 칩의 프로세서 서브유닛(예, 도 7a에 도시)을 포함할 수 있다. 이에 따라, 아래에 설명하는 메모리 칩은 도 3a, 도 3b, 도 4 내지 도 6, 도 7a 내지 도 7d, 도 11 내지 도 13, 도 16 내지 도 19, 도 22, 및 도 23의 하나 이상에 도시된 바와 같은 메모리 칩에 포함되거나 메모리 칩을 포함 할 수 있다. 메모리 칩은 논리 셀보다는 메모리 셀에 최적화된 제1 제조 프로세스에 의해 제조될 수 있다. 예를 들면, 제1 제조 프로세스에 의해 제조된 메모리 셀은 제1 제조 프로세스에 의해 제조된 논리 회로보다 임계 치수가 작을 (예, 2배, 3배, 4배, 5배, 6배, 7배, 8배, 9배, 10배 등만큼) 수 있다. 예컨대, 제1 제조 프로세스는 아날로그 제조 프로세스, DRAM 제조 프로세스 등을 포함할 수 있다. 이러한 메모리 칩은 메모리 유닛을 포함할 수 있는 집적회로를 포함할 수 있다. 메모리 유닛은 메모리 셀, 출력 포트, 및 읽기 회로를 포함할 수 있다. 일부 실시예에서, 메모리 유닛은 앞서 설명한 프로세서 서브유닛과 같은 처리부를 더 포함할 수 있다. 예를 들어, 읽기 회로는 출력 포트를 통해 제1 수의 비트까지 출력하기 위한 제1 그룹의 메모리 읽기 경로 및 리덕션 유닛을 포함할 수 있다. 출력 포트는 오프칩(off-chip) 논리 회로(예, 가속기, CPU, GPU 등) 또는 앞서 설명한 바와 같은 온칩(on-chip) 프로세서 서브유닛으로 연결될 수 있다. 일부 실시예에서, 처리부는 리덕션 유닛을 포함하거나, 리덕션 유닛의 일부이거나, 리덕션 유닛과 상이하거나, 리덕션 유닛을 포함할 수 있다. 인메모리 읽기 경로는 집적회로에 포함(예를 들어, 메모리 유닛에 포함)되거나, 메모리 셀에 읽기 및/또는 쓰기 를 하도록 구성된 모든 임의의 회로 및/또는 링크를 포함할 수 있다. 예를 들면, 인메모리 읽기 경로는 센스 증 폭기, 메모리 셀에 결합된 컨덕터, 멀티플렉서 등을 포함할 수 있다. 처리부는 메모리 유닛에서 제2 수의 비트를 읽기 위한 읽기 요청을 메모리 유닛으로 전송하도록 구성될 수 있다. 추가적으로 또는 대안적으로, 읽기 요청은 오프칩 논리 회로(예, 가속기, CPU, GPU 등)에서 유래할 수 있 다. 리덕션 유닛은 접근 요청과 관련된 전력 소모의 감소를 보조하도록(예, 여기에 기재된 부분 워드 접근의 하나 이상을 활용) 구성될 수 있다. 리덕션 유닛은 제1 수의 비트와 제2 수의 비트에 의거하여, 읽기 요청에 의해 촉발된 읽기 동작 동안에, 메모리 읽기 경로를 제어하도록 구성될 수 있다. 예를 들어, 리덕션 유닛으로부터의 제어 신호는 읽기 경로의 메모리 소모에 영향을 주어, 요청된 제2 수의 비트와 관련이 없는 메모리 읽기 경로의 에너지 소모를 감소시킬 수 있다. 예컨대, 리덕션 유닛은 제2 수가 제1 수보다 작은 경우에 무관한 메모리 읽기 경로를 제어하도록 구성될 수 있다. 앞서 설명한 바와 같이, 집적회로는 도 3a, 도 3b, 도 4 내지 도 6, 도 7a 내지 도 7d, 도 11 내지 도 13, 도 16 내지 도 19, 도 22, 및 도 23의 하나 이상에 도시된 바와 같은 메모리 칩에 포함되거나 메모리 칩을 포함할 수 있다. 무관한 인메모리 읽기 경로는, 제2 수의 비트에 포함되지 않은 제1 수의 비트의 비트와 같은, 제1 수의 비트의 무관한 비트와 연관될 수 있다. 도 50은 메모리 셀 어레이의 메모리 셀(5001-5008), 비트(5021-5028)를 포함하는 출력 포트, 메모 리 읽기 경로(5011-5018)를 포함하는 읽기 회로, 및 리덕션 유닛을 포함하는 예시적인 집적회로 를 도시한 것이다. 제2 수의 비트가 상응하는 메모리 읽기 경로를 활용하여 읽혀지는 경우, 제1 수의 비트의 무관한 비트는 읽혀지 지 않아야 하는 비트(예, 제2 수의 비트에 포함되지 않는 비트)에 상응할 수 있다. 읽기 동작 동안에, 리덕션 유닛은 활성화된 메모리 읽기 경로가 제2 수의 비트를 전달하도록 구성될 수 있도록 제2 수의 비트에 상응하는 메모리 읽기 경로를 활성화하도록 구성될 수 있다. 이러한 실시예에서, 제2 수의 비트에 상응하는 메모리 읽기 경로만이 활성화될 수 있다. 읽기 동작 동안에, 리덕션 유닛은 각각의 무관한 메모리 읽기 경로의 적어도 일부를 폐쇄하도록 구성될 수 있다. 예컨대, 무관한 메모리 읽기 경로는 제1 수의 비트의 무관한 비트에 상응할 수 있다. 여기서, 무관한 메모리 경로의 적어도 일부분을 폐쇄하는 대신에, 리덕션 유닛은 무관한 경로가 활성화되 지 않도록 할 수 있다. 추가적으로 또는 대안적으로, 읽기 동작 동안에, 리덕션 유닛은 무관한 메모리 읽기 경로를 저전력 모드 로 유지하도록 구성될 수 있다. 예를 들면, 저전력 모드는 무관한 메모리 경로에 정상 동작 전압 또는 전류보다 낮은 전압 또는 전류가 공급되는 모드를 포함할 수 있다. 리덕션 유닛은 무관한 메모리 읽기 경로의 비트라인을 제어하도록 더 구성될 수 있다. 이에 따라, 리덕션 유닛은 관련 있는 메모리 읽기 경로의 비트라인을 로드(load) 하고 무관한 메모리 읽 기 경로의 비트라인을 저전력 모드로 유지하도록 구성될 수 있다. 예를 들면, 관련 있는 메모리 읽기 경로의 비 트라인만이 로드 될 수 있다. 추가적으로 또는 대안적으로, 리덕션 유닛은 무관한 메모리 읽기 경로를 비활성화 상태로 유지하면서 관 련 있는 메모리 읽기 경로의 비트라인을 로드 하도록 구성될 수 있다. 일부 실시예에서, 리덕션 유닛은 읽기 동작 동안에 관련 있는 메모리 읽기 경로의 일부를 활용하고 무관 한 각 메모리 읽기 경로의 일부(비트라인과 다름)를 저전력 모드로 유지하도록 구성될 수 있다. 앞서 설명한 바와 같이, 메모리 칩은 센스 증폭기를 사용하여 내부에 포함된 메모리 셀로부터의 전압을 증폭할 수 있다. 이에 따라, 리덕션 유닛은 읽기 동작 동안에 관련 있는 메모리 읽기 경로의 일부를 활용하고 무 관한 메모리 읽기 경로의 적어도 일부와 연관된 센스 증폭기를 저전력 모드로 유지하도록 구성될 수 있다. 이러한 실시예에서, 리덕션 유닛은 읽기 동작 동안에 관련 있는 메모리 읽기 경로의 일부를 활용하고 관 련 없는 메모리 읽기 경로 모두와 연관된 하나 이상의 센스 증포기를 저전력 모드로 유지하도록 구성될 수 있다. 추가적으로 또는 대안적으로, 리덕션 유닛은 읽기 동작 동안에 관련 있는 메모리 읽기 경로의 일부를 활 용하고 무관한 메모리 읽기 경로와 연관된 하나 이상의 센스 증폭기를 따라가는(예, 공간적으로 및/또는 시간적 으로) 무관한 메모리 읽기 경로의 일부를 저전력 모드로 유지하도록 구성될 수 있다. 상기에 설명한 모든 임의의 실시예에서, 메모리 유닛은 컬럼 멀티플렉서(미도시)를 포함할 수 있다. 이러한 실시예에서, 리덕션 유닛은 컬럼 멀티플렉서와 출력 포트 사이에 결합될 수 있다. 추가적으로 또는 대안적으로, 리덕션 유닛은 컬럼 멀티플렉서에 내장될 수 있다. 추가적으로 또는 대안적으로, 리덕션 유닛은 메모리 셀과 컬럼 멀티플렉서 사이에 결합될 수 있다. 리덕션 유닛은 독립적으로 제어 가능할 수 있는 리덕션 서브유닛을 포함할 수 있다. 예를 들어, 상이한 리덕션 서브유닛은 상이한 메모리 유닛 열과 연관될 수 있다. 상기에서는 읽기 동작과 읽기 회로를 참조하여 설명하였지만, 상기의 실시예들은 쓰기 동작과 쓰기 회로에 대하 여 유사하게 적용될 수 있다. 예를 들어, 본 개시에 따른 집적회로는 메모리 셀, 출력 포트, 및 쓰기 회로를 포함하는 메모리 유닛을 포함할 수 있다. 일부 실시예에서, 메모리 유닛은 앞서 설명한 프로세서 서브유닛과 같은 처리부를 더 포함할 수 있다. 쓰기 회로는 출력 포트를 통하여 제1 수의 비트까지 출력하기 위한 제1 그룹의 메모리 쓰기 경로 및 리덕션 유닛을 포함할 수 있다. 처리부는 메모리 유닛으로부터 제2 수의 비트를 쓰기 위한 쓰기 요청을 메모리 유닛으로 전송하도록 구성될 수 있다. 추가적으로 또는 대안적으로, 쓰기 요청은 오프칩 논리 회로(예, 가속기, CPU, GPU 등)에서 유래할 수 있다. 리덕션 유닛은 제1 수의 비트와 제2 수의 비트에 의거하여, 쓰기 요청에 의해 촉발된 쓰기 동작 동안에, 메모리 쓰기 경로를 제어하도록 구성될 수 있다. 도 51은 로우 어드레스와 컬럼 어드레스를 활용하여(예, 온칩 프로세서 서브유닛 또는 가속기, CPU, GPU 등과 같은 오프칩 논리 회로로부터) 어드레스 된 메모리 셀 어레이를 포함하는 메모리 뱅크를 도시한 것 이다. 도 51에 도시된 바와 같이, 메모리 셀은 비트라인(세로) 및 워드라인(가로―대부분 생략되어 간략히 묘사 됨)으로 연결된다. 또한, 로우 디코더에는 로우 어드레스가 공급(예, 온칩 프로세서 서브유닛, 오프칩 논 리 회로, 또는 도 51에 도시되지 않은 메모리 컨트롤러로부터)될 수 있고, 컬럼 멀티플렉서에는 컬럼 어 드레스가 공급(예, 온칩 프로세서 서브유닛, 오프칩 논리 회로, 또는 도 51에 도시되지 않은 메모리 컨트롤러로 부터)될 수 있고, 컬럼 멀티플렉서는 최대 전체 라인으로부터 출력을 수신하고 출력 버스를 통해 워드까지 출력할 수 있다. 도 51에서, 컬럼 멀티플렉서의 출력 버스는 메인 I/O 버스에 결합 된다. 다른 실시예에서, 출력 버스는 로우 어드레스 및 컬럼 어드레스를 전송하는 메모리 칩의 프로세서 서브유닛(예, 도 7a에 도시)에 결합될 수 있다. 간략한 묘사를 위해, 메모리 뱅크를 메모리 매트로 분할하는 것 은 도시되지 않았다. 도 52는 메모리 뱅크를 도시한 것이다. 도 52에서, 메모리 뱅크는 출력 버스에 입력이 결합된 PIM(processing in memory) 로직도 포함하는 것으로 도시되어 있다. PIM 로직은 어드레스(예, 로 우 어드레스와 컬럼 어드레스를 포함)를 생성하고 PIM 어드레스 버스를 통해 출력하여 메모리 뱅크에 접 근할 수 있다. PIM 로직은 처리부를 포함하는 리덕션 유닛(예, 5030)의 예이다. PIM 로직은 전력의 감소를 보조하는 도 52에 도시되지 않은 다른 회로를 제어할 수 있다. PIM 로직은 또한 메모리 뱅크 를 포함하는 메모리 유닛의 메모리 경로를 포함할 수 있다. 앞서 설명한 바와 같이, 워드 길이(예, 한 번에 전송되는 것으로 선택된 비트라인의 수)는 일부 경우에 클 수 있다. 이러한 경우에서, 읽기 및/또는 쓰기를 위한 각 워드는 아래의 예와 같은 읽기 및/또는 쓰기 동작의 다양한 단 계에서 전력을 소모할 수 있는 메모리 경로와 연관될 수 있다. a.비트라인 로딩―필요한 값으로 비트라인이 로드 되는 것을(읽기 사이클에서 비트라인 상의 커패시터로부터 또 는 쓰기 사이클에서 커패시터로 기록될 새 값으로) 방지하려면, 메모리 어레이의 끝에 위치한 센스 증폭기를 비 활성화하고 데이터를 보유하는 커패시터가 방전되거나 충전되지 않도록 할 필요가 있다(그렇지 않으면 저장된 데이터가 파괴된다). b.센스 증폭기로부터, 비트라인을 선택하는 컬럼 멀티플렉서를 통해, 칩의 나머지 부분으로(칩의 내부로 또는 외부로 데이터를 전송하는 I/O 버스로 또는 메모리와 동일 기판 상의 프로세서 서브유닛과 같은, 데이터를 사용 하는, 내장 로직으로) 데이터 이동. 전력 절약을 활성화하기 위해, 본 개시의 집적회로는 워드의 일부 부분이 무관하다는 판단을 행 활성화 시간에 한 후에 비활성화 신호를 워드의 무관한 부분에 대한 하나 이상의 센스 증폭기로 전송할 수 있다. 도 53은 메모리 셀의 어레이, 로우 디코더, 출력 버스에 결합된 컬럼 멀티플렉서, 및 PIM 로직을 포함하는 메모리 유닛을 도시한 것이다. 메모리 유닛은 또한 컬럼 멀티플렉서로의 비트의 경로를 활성화 또는 비활성화하는 스위치를 포함한다. 스위치는 아날로그 스위치, 스위치 기능 하도록 구성된 트랜지스터, 또는 메모리 유닛의 일부로 전압의 공급 및/또는 전류의 흐름을 제어하도록 구성된 모든 임의의 기타 회로를 포함할 수 있다. 센스 증폭기(미도시)는 메모리 셀 어레이의 끝에, 예를 들어 스위치보다 앞에(공간적으로 및/또는 시간적으 로), 위치할 수 있다. 스위치는 PIM 로직으로부터 버스를 통해 전송되는 인에이블 신호(enable signal)에 의해 제 어될 수 있다. 스위치는, 연결이 끊어진 경우에, 메모리 유닛의 센스 증폭기(미도시)의 연결을 끊고 따라 서 센스 증폭기로부터 연결이 끊어진 비트라인을 방전 또는 충전하지 않도록 구성될 수 있다. 스위치와 PIM 로직은 리덕션 유닛(예, 5030)을 구성할 수 있다. 또 다른 예에서, PIM 로직은 인에이블 신호를 스위치로 전송하는 대신에 센스 증폭기로 전송할 수 있다(예, 센스 증폭기에 활성화 입력이 있는 경우). 비트라인은 추가적으로 또는 대안적으로 다른 지점에서, 예를 들어 비트라인의 끝과 센스 증폭기 이후가 아닌 지점에서, 연결이 끊어질 수 있다. 예를 들면, 비트라인은 어레이로 들어가기 이전에 연결이 끊어질 수 있다. 이러한 실시예에서, 센스 증폭기 및 전송 하드웨어(예, 출력 버스)로부터의 데이터 전송에서도 전력이 절 약될 수 있다. 다른 실시예들(전력 절약은 덜하지만 구현이 더 수월한 실시예들)은 컬럼 멀티플렉서의 전력과 컬럼 멀티 플렉서로부터 다음 레벨 회로로의 전송 손실의 감소에 초점을 맞춘다. 예를 들어, 앞서 설명한 바와 같이, 다음 레벨 회로는 메모리 칩의 I/O 버스(예, 버스)를 포함할 수 있다. 인메모리 프로세싱을 활용하 는 실시예에서, 다음 레벨 회로는 메모리 칩의 프로세서 서브유닛(예, PIM 로직)을 추가적으로 또는 대안 적으로 포함할 수 있다. 도 54a는 세그먼트로 분할된 컬럼 멀티플렉서를 도시한 것이다. 컬럼 멀티플렉서의 각 세그 먼트는 PIM 로직으로부터 버스를 통해 전송된 활성화 및/또는 비활성화 신호에 의해 개별적 으로 활성화 또는 비활성화될 수 있다. 컬럼 멀티플렉서는 또한 어드레스 컬럼 버스에 의해 공급될 수 있다. 도 54a의 실시예는 컬럼 멀티플렉서로부터의 출력의 다른 부분보다 더 나은 제어를 제공할 수 있다. 여기서, 상이한 메모리 경로의 제어는 비트 해상도가 상이할 수 있다. 예를 들어, 비트 해상도는 단일 비트 해 상도에서 다중 비트 해상도까지의 범위일 수 있다. 전자는 전력 감소에 더 효과적일 수 있고, 후자는 구현이 더 단순하고 제어 신호가 덜 필요할 수 있다. 도 54b는 예시적인 방법을 도시한 것이다. 예컨대, 방법은 상기에 도 50, 도 51, 도 52, 도 53, 또는 도 54a를 참조하여 설명한 모든 임의의 메모리 유닛을 활용하여 이행될 수 있다. 방법은 단계 5132와 단계 5134를 포함할 수 있다. 단계 5132에서, 메모리 유닛에서 제2 수의 비트를 읽기 위한 접근 요청을 집적회로의 처리부(예, PIM 로직 )가 집적회로의 메모리 유닛으로 전송할 수 있다. 메모리 유닛은 메모리 셀(예, 어레이의 메모리 셀), 출력 포트(예, 출력 버스), 및 리덕션 유닛(예, 리덕션 유닛)과 출력 포트를 통해 제1 수의 비트까지의 출력 및/또는 입력을 위한 제1 그룹의 메모리 읽기/쓰기 경로를 포함할 수 있는 읽기/쓰기 회로를 포함할 수 있다. 접근 요청은 읽기 요청 및/또는 쓰기 요청을 포함할 수 있다. 메모리 입력/출력 경로는 메모리 읽기 경로, 메모리 쓰기 경로, 및/또는 읽기와 쓰기에 모두 사용되는 경로를 포함할 수 있다. 단계 5134에서, 접근 요청에 대응할 수 있다. 예를 들어, 단계 5134에서, 제1 수의 비트와 제2 수의 비트에 의거하여, 접근 요청에 의해 촉발된 접근 동작 동 안에, 리덕션 유닛(예, 리덕션 유닛)이 메모리 읽기/쓰기 경로를 제어할 수 있다. 또한, 단계 5134에서, 다음 중의 어느 하나 및/또는 다음 중의 하나 이상의 모든 임의의 조합이 수행될 수 있다. 아래에 나열된 모든 임의의 동작은 접근 요청에 대응하는 동안에 실행될 수 있지만 접근 요청에 대한 대 응 이전 및/또는 이후에 실행될 수도 있다. 따라서, 단계 5134는 다음 중의 적어도 하나를 포함할 수 있다. a.제2 수가 제1수보다 작은 경우에 무관한 메모리 읽기 경로를 제어하는 단계―여기서, 무관한 메모리 읽기 경 로는 제2 수의 비트에 포함되지 않는 제1 수의 비트의 비트와 연관됨; b.읽기 동작 동안에 관련 있는 메모리 읽기 경로를 활성화하는 단계―여기서, 관련 있는 메모리 읽기 경로는 제 2 수의 비트를 전달하도록 구성됨; c.무관한 메모리 읽기 경로 각각의 적어도 일부분을 읽기 동작 동안에 폐쇄하는 단계; d.무관한 메모리 읽기 경로를 읽기 동작 동안에 저전력 모드로 유지하는 단계; e.무관한 메모리 읽기 경로의 비트라인을 제어하는 단계; f.관련 있는 메모리 읽기 경로의 비트라인을 로드하고 무관한 메모리 읽기 경로의 비트라인을 저전력 모드로 유 지하는 단계; g.무관한 메모리 읽기 경로의 비트라인을 비활성화 상태로 유지하는 반면에 관련 있는 메모리 읽기 경로의 비트 라인을 로드하는 단계; h.읽기 동작 동안에 관련 있는 메모리 읽기 경로의 부분들을 활용하고 무관한 메모리 읽기 경로 각각의 일부분 을 저전력 모드로 유지하는 단계―여기서, 상기 일부분은 비트라인과 상이함; i.읽기 동작 동안에 관련 있는 메모리 읽기 경로의 부분들을 활용하고 적어도 일부 무관한 메모리 읽기 경로에 대한 센스 증폭기를 저전력 모드로 유지하는 단계; j.읽기 동작 동안에 관련 있는 메모리 읽기 경로의 부분들을 활용하고 적어도 무관한 메모리 읽기 경로의 센스 증폭기를 저전력 모드로 유지하는 단계; 및 k.읽기 동작 동안에 관련 있는 메모리 읽기 경로의 부분들을 활용하고 무관한 메모리 읽기 경로의 센스 증폭기 이후의 무관한 메모리 읽기 경로의 부분들을 저전력 모드로 유지하는 단계. 저전력 모드 또는 유휴 모드(idle mode)는 메모리 접근 경로가 접근 동작을 위해 사용되는 경우의 전력 소비보 다 메모리 접근 경로의 전력 소비가 적은 모드를 포함할 수 있다. 일부 실시예에서, 저전력 모드는 메모리 접근 경로를 폐쇄하는 것을 포함할 수도 있다. 저전력 모드는 추가적으로 또는 대안적으로 메모리 접근 경로를 활성 화하지 않는 것을 포함할 수 있다. 여기서, 비트라인 단계 동안에 전력 감소가 일어나려면 메모리 접근 경로의 관련성 또는 무관성을 워드라인 개 방 전에 알고 있어야 할 수 있다. 다른 위치(예, 컬럼 멀티플렉서)에서 일어나는 전력 감소는 각 접근의 메모리 접근 경로의 관련성 또는 무관성의 결정이 가능할 수 있다. 고속 저전력 활성화 및 고속 접근 메모리 DRAM 및 기타 메모리 유형들(SRAM, 플래시메모리 등)은 일반적으로 로우 및 컬럼 접근 스키마를 감안하여 구성 되는 메모리 뱅크로부터 구성되는 경우가 흔하다. 도 55는 다중 메모리 매트와 연관 로직(예, 도 55에 각각 RD 및 COL로 도시된 로우 디코더 및 컬럼 디코더)을 포함하는 메모리 칩의 일례를 도시한 것이다. 도 55의 예에서, 매트는 뱅크로 그룹 지어지고 워드라인과 비트라인이 지나간다. 메모리 뱅크와 연관 로직은 도 55에 5141, 5142, 5143, 5144, 5145, 및 5146으로 표시되 고 적어도 하나의 버스를 공유한다. 메모리 칩은 도 3a, 도 3b, 도 4 내지 도 6, 도 7a 내지 도 7d, 도 11 내지 도 13, 도 16 내지 도 19, 도 22, 및 도 23의 하나 이상에 도시된 바와 같은 메모리 칩에 포함되거나 메모리 칩을 포함할 수 있다. 예컨대, DRAM에는 새 행의 활성화((예, 접근을 위한 새 라인을 준비)와 연관된 오버헤드가 많다. 라인이 활성화 (또는 라인의 개방)되면, 그 행의 데이터는 훨씬 빠른 접근을 위해 사용 가능할 수 있다. DRAM에서, 이러한 접 근은 무작위 방식으로 일어날 수 있다. 새 라인의 활성화와 연관된 두 가지 문제는 전력과 시간이다. c. 라인 상의 모든 커패시터에 한꺼번에 접근하고 라인을 로드해야 함에 따라 유발되는 전류의 빠른 흐름으로 인해 전력이 상승한다(예, 몇 개의 메모리 뱅크만 있는 라인을 개방하는 경우에 전력은 수 암페어에 이를 수 있 다). d. 시간 지연 문제는 대부분 행(워드라인)을 로드한 후에 열(비트라인)을 로드하는데 들어가는 시간과 연관된다. 본 개시의 일부 실시예들은 라인의 활성화 동안에 첨두 전력 소비를 감소하고 라인의 활성화 시간을 감소하는 시스템 및 방법을 포함할 수 있다. 일부 실시예들은 어느 정도까지 완전 무작위 접근을 희생하여 이러한 전력과 시간 비용을 감소시킬 수 있다. 예를 들어, 일 실시예에서, 메모리 유닛은 제1 메모리 매트, 제2 메모리 매트, 및 제2 메모리 매트에 포함된 제 2 그룹의 메모리 셀을 활성화하지 않고 제1 메모리 매트에 포함된 제1 그룹의 메모리 셀을 활성화하도록 구성된활성화부를 포함할 수 있다. 제1 그룹의 메모리 셀과 제2 그룹의 메모리 셀은 모두 메모리 유닛의 단일 행에 속 할 수 있다. 대안적으로, 활성화부는 제1 그룹의 메모리 셀을 활성화하지 않고 제2 메모리 매트에 포함된 제2 그룹의 메모리 셀을 활성화하도록 구성될 수 있다. 일부 실시예에서, 활성화부는 제1 그룹의 메모리 셀의 활성화 이후에 제2 그룹의 메모리 셀을 활성화하도록 구 성될 수 있다. 예를 들면, 활성화부는 제1 그룹의 메모리 셀의 활성화가 완료된 이후에 개시된 지연 기간의 만료에 후속하여 제2 그룹의 메모리 셀을 활성화하도록 구성될 수 있다. 추가적으로 또는 대안적으로, 활성화부는 제1 그룹의 메모리 셀에 결합된 제1 워드라인에 생성된 신호의 값에 의거하여 제2 그룹의 메모리 셀을 활성화하도록 구성될 수 있다. 상기에 설명한 모든 임의의 실시예들에서, 활성화부는 제1 워드라인 세그먼트와 제2 워드라인 세그먼트 사이에 배치된 중간 회로를 포함할 수 있다. 제1 워드라인 세그먼트는 제1 메모리 셀에 결합될 수 있고, 제2 워드라인 세그먼트는 제2 메모리 셀에 결합될 수 있다. 중간 회로의 예로는, 이게 국한되지 않지만, 도 56 내지 도 61에 일부가 도시된 스위치, 플립플롭, 버퍼, 인버터(inverter) 등이 있을 수 있다. 일부 실시예에서, 제2 메모리 셀은 제2 워드라인 세그먼트에 결합될 수 있다. 이러한 실시예에서, 제2 워드라인 세그먼트는 적어도 제1 메모리 매트를 통과하는 바이패스(bypass) 워드라인 경로에 결합될 수 있다. 활성화부는 단일 행과 연관된 워드라인으로부터의 활성화 신호에 의거하여 제1 그룹의 메모리 셀과 제2 그룹의 메모리 셀로의 전압의 공급(및/또는 전류의 흐름)을 제어하도록 구성된 제어부를 포함할 수 있다. 다른 예시적인 실시예에서, 메모리 유닛은 제1 메모리 매트, 제2 메모리 매트, 및 제1 메모리 매트의 제1 그룹 의 메모리 셀로 활성화 신호를 공급하고 적어도 제1 그룹의 메모리 셀의 활성화가 완료될 때까지 제2 메모리 매 트의 제2 그룹의 메모리 셀로의 활성화 신호의 공급을 지연하도록 구성된 활성화부를 포함할 수 있다. 제1 그룹 의 메모리 셀과 제2 그룹의 메모리 셀은 메모리 유닛의 단일 행에 속할 수 있다. 예를 들어, 활성화부는 활성화 신호의 공급을 지연하도록 구성된 지연부를 포함할 수 있다. 추가적으로 또는 대안적으로, 활성화부는 입력부에서 활성화 신호를 수신하고 활성화 신호의 적어도 하나의 특 성에 의거하여 지연부를 제어하도록 구성된 비교기(comparator)를 포함할 수 있다. 다른 예시적인 실시예에서, 메모리 매트는 제1 메모리 매트, 제2 메모리 매트, 및 제1 메모리 매트의 제1 메모 리 셀을 제1 메모리 셀이 활성화되는 초기 활성화 기간 동안에 제2 메모리 매트의 제2 메모리 셀로부터 격리하 고 초기 활성화 기간 후에 제1 메모리 셀을 제2 메모리 셀에 결합하도록 구성된 격리부를 포함할 수 있다. 제1 및 제2 메모리 셀은 메모리 유닛의 단일 행에 속할 수 있다. 하기의 예시들에서, 메모리 매트 자체에 대한 수정은 필요 없다. 일부 예에서, 실시예들은 메모리 뱅크에 대한 약간의 수정에 의존할 수 있다. 아래에 설명하는 도면들은 메모리 뱅크에 추가된 워드 신호를 짧게 하여 워드라인을 여러 개의 짧은 부분으로 나누는 메커니즘을 도시한다. 다음의 도면에서, 간략한 설명을 위해 다양한 메모리 뱅크 구성이 생략되었다. 도 56 내지 도 61은 상이한 그룹 내에 그룹으로 된 다중 메모리 매트(5150, 5150, 5150, 5150, 5150, 5150, 5151, 5151, 5151, 5151, 5151, 5151, 5152, 5152, 5152, 5152, 5152, 및 5152)와 로우 디코더를 포함하는 메모리 뱅크의 부분들(각각 5140, 5140, 5140, 5140, 5140, 및 5149로 표시)을 도시한 것이다. 행으로 배열된 메모리 매트는 상이한 그룹을 포함할 수 있다. 도 56 내지 도 59 및 도 61은 각 그룹이 한 쌍의 메모리 매트를 포함하는 9 그룹의 메모리 매트를 도시한다. 메모리 매트(5150, 5150, 5150, 5150, 5150, 및 5150)는 행으로 배열되고, 다중 메모리 라 인을 공유하며, 3개의 그룹으로 분류된다. 즉, 제1 상부 그룹은 5150과 5150으로 표시된 메모리 매트를 포함하고, 제2 상부 그룹은 5150과 5150으로 표시된 메모리 매트를 포함하고, 제3 상부 그룹은 5150와5150으로 표시된 메모리 매트를 포함한다. 마찬가지로, 메모리 매트(5151, 5151, 5151, 5151, 5151, 및 5151)는 행으로 배열되고, 다 중 메모리 라인을 공유하며, 3개의 그룹으로 분류된다. 즉, 제1 중간 그룹은 5151과 5151로 표시된 메모 리 매트를 포함하고, 제2 중간 그룹은 5151과 5151로 표시된 메모리 매트를 포함하고, 제3 중간 그룹은 5151와 5151으로 표시된 메모리 매트를 포함한다. 또한, 메모리 매트(5152, 5152, 5152, 5152, 5152 및 5152)는 행으로 배열되고, 다중 메모 리 라인을 공유하며, 3개의 그룹으로 분류된다. 즉, 제1 하부 그룹은 5152과 5152로 표시된 메모리 매트 를 포함하고, 제2 하부 그룹은 5152과 5152로 표시된 메모리 매트를 포함하고, 제3 하부 그룹은 5152 와 5152로 표시된 메모리 매트를 포함한다. 모든 임의의 수의 메모리 매트가 행으로 배열되고, 메모리 라인 을 공유하고, 모든 임의의 수의 그룹으로 분류될 수 있다. 예컨대, 각 그룹의 메모리 매트의 수는 1, 2, 또는 그 이상일 수 있다. 앞서 설명한 바와 같이, 활성화 회로는 동일 메모리 라인을 공유하는 다른 그룹의 메모리 매트를 활성화하지 않 고 한 그룹의 메모리 매트를 활성화하도록 구성될 수 있다. 또는, 라인 어드레스가 동일한 상이한 메모리 라인 세그먼트에 적어도 결합될 수 있다. 도 56 내지 도 61은 활성화 회로의 상이한 예를 도시한 것이다. 일부 실시예에서, 활성화 회로의 적어도 일부분 (예, 중간 회로)은 메모리 매트의 그룹 사이에 위치하여 한 그룹의 메모리 매트가 활성화되게 하는 반면에 동일 한 행의 다른 그룹의 메모리 매트는 활성화되지 않게 할 수 있다. 도 56은 제1 상부 그룹의 메모리 매트와 제2 상부 그룹의 메모리 매트의 상이한 라인 사이에 위치한 지연 또는 격리 회로(5153 - 5153)와 같은 중간 회로를 도시하고 있다. 도 56은 또한 제2 상부 그룹의 메모리 매트와 제3 상부 그룹의 메모리 매트의 상이한 라인 사이에 위치한 지연 또는 격리 회로(5154 - 5154)와 같은 중간 회로를 도시하고 있다. 추가적으로, 일부 지연 또는 격리 회로 는 중간 그룹의 메모리 매트로부터 형성된 그룹 사이에 위치한다. 또한, 일부 지연 또는 격리 회로는 하부 그룹 의 메모리 매트로부터 형성된 그룹 사이에 위치한다. 지연 또는 연기 회로는 로우 디코더로부터의 워드라인 신호가 다른 그룹의 행을 따라 전파되는 것을 지연 또는 중지할 수 있다. 도 57은 플립플롭(5155 - 5155 and 5156-5156)을 포함하는 지연 또는 격리 회로와 같은 중간회로 를 도시하고 있다. 활성화 신호가 워드라인으로 주입되는 경우, 제1 그룹의 매트(워드라인에 따라)가 활성화되는 반면에 워드라인 상의 다른 그룹은 비활성화 상태로 유지된다. 다른 그룹은 다음 클럭 사이클에 활성화될 수 있다. 예를 들어, 다른 그룹의 제2그룹은 다음 클럭 사이클에서 활성화될 수 있고, 다른 그룹의 제3그룹은 또 다른 클럭 사이클 이후에 활성화될 수 있다. 플립플롭은 D형 플립플롭 또는 모든 임의의 다른 유형의 플립플롭을 포함할 수 있다. D형 플립플롭으로 공급되 는 클럭은 단순화를 위해서 도면에서 생략되었다. 따라서, 제1그룹으로의 접근은 전력을 사용하여 제1그룹과 연관된 워드라인의 부분만을 충전할 수 있고, 이는 전체 워드라인을 충전하는 것보다 빠르고 전류도 덜 필요하다. 하나 이상의 플립플롭이 메모리 매트의 그룹 사이에 사용될 수 있으므로, 개방 부분 사이의 지연을 증가시킬 수 있다. 추가적으로 또는 대안적으로, 실시예들은 클럭을 느리게 하여 지연을 증가시킬 수 있다. 또한, 활성화되는 그룹들은 이전에 사용된 라인 값으로부터의 그룹들을 여전히 포함할 수 있다. 예를 들어, 방 법은 이전 라인의 데이터에 여전히 접근하면서 새로운 라인 세그먼트를 활성화하게 할 수 있어서, 새로운 라인 의 활성화와 연관된 페널티를 감소시킬 수 있다. 이에 따라, 일부 실시예들은 활성화된 제1그룹이 있을 수 있고, 이전에 활성화된 라인의 다른 그룹들을 서로 간 섭하지 않는 비트라인의 신호를 가지고 활성화 상태로 유지되도록 할 수 있다. 추가적으로, 일부 실시예들은 스위치와 제어 신호를 포함할 수 있다. 제어 신호는 뱅크 컨트롤러에 의해 제어되 거나 제어 신호 사이에 플립플롭을 추가하여(예, 상기에 설명한 메커니즘과 동일한 타이밍 효과를 생성하여) 제어될 수 있다. 도 58은 스위치(5157 - 5157 및 5158-5158 등)이고 한 그룹과 다른 그룹 사이에 위치하는 지연 또 는 격리 회로와 같은 중간 회로를 도시하고 있다. 그룹 사이에 위치한 한 세트의 스위치는 전용 제어 신호에 의 해 제어될 수 있다. 도 58에서, 제어 신호는 행 제어부(5160)에 의해 전송되고 상이한 세트의 스위치 사이의 하나 이상의 연속된 지연부(예, 5160 및 5160)에 의해 지연될 수 있다. 도 59는 연속된 인버터 게이트 또는 버퍼(예, 159 - 5159 및 5159'1(0 - 5159')이고 메모리 매트의 그룹들 사이에 위치한 지연 또는 격리 회로와 같은 중간 회로를 도시하고 있다. 스위치 대신에, 버퍼는 메모리 매트의 그룹들 사이에 사용될 수 있다. 버퍼는 스위치와 스위치 간에, 단일 트랜 지스터 구조를 사용하는 경우에 때때로 발생하는 효과인, 워드라인을 따른 전압 강하를 방지할 수 있다. 다른 실시예들은 메모리 뱅크에 추가된 영역을 활용함으로써 더욱 무작위 한 접근을 허용하면서 매우 낮은 활성 화 전력과 시간을 제공할 수 있다. 메모리 매트에 근접하여 위치한 워드라인(예, 5152 - 5152)을 사용하는 일례가 도 60에 도시되어 있다. 이러한 워드라인들은 메모리 매트를 통과할 수도 또는 통과하지 않을 수도 있고 스위치(예, 5157 - 5157 )와 같은 중간 회로를 통해 메모리 매트 내의 워드라인들에 결합할 수 있다. 스위치는 어느 메모리 매트가 활성화될지를 제어할 수 있고 메모리 컨트롤러가 각 시점에 관련이 있는 라인 부분만 활성화하도록 할 수 있다. 상기에 설명한 라인 부분의 연속 활성화를 사용하는 실시예와 달리, 도 60의 예는 더 강한 제어를 제공할 수 있 다. 로우 파트 인에이블 신호(5170 및 5170)와 같은 인에이블 신호는 도시되지 않은 메모리 컨트롤러와 같은 로직에서 유래할 수 있다. 도 61은 글로벌 워드라인이 메모리 매트를 통과하고, 메모리 매트 외부로 보내질 필요가 없을 수 있는 워 드라인 신호에 대한 바이패스 경로를 형성하는 것을 도시하고 있다. 이에 따라, 도 61에 도시된 실시예는 메모 리 밀도에 약간의 손실을 감수하고 메모리 뱅크의 면적을 줄일 수 있다. 도 61에서, 글로벌 워드라인은 중단 없이 메모리 매트를 통과할 수 있고 메모리 셀에 연결되지 않을 수 있다. 로컬 워드라인 세그먼트는 스위치 중의 하나에 의해 제어되고 메모리 매트 내에서 메모리 셀에 연결될 수 있다. 메모리 매트의 그룹이 워드라인의 상당한 파티션을 제공하는 경우, 메모리 뱅크는 완전한 무작위 접근을 사실상 지원할 수 있다. 일부 배선과 로직을 또한 절약할 수 있고 워드라인을 따라 활성화 신호의 전파 속도를 감소시키는 다른 실시예 는 전용 인에이블 신호 및 인에이블 신호를 전달하는 전용 라인을 사용하지 않고 메모리 매트 사이에 다른 버퍼 링 또는 격리 회로 및/또는 스위치를 사용한다 예를 들어, 비교기를 사용하여 스위치 또는 기타 버퍼링 또는 격리 회로를 제어할 수 있다. 비교기는 비교기에 의해 모니터링 된 워드라인 세그먼트 상의 신호의 레벨이 특정 레벨에 도달하는 경우에 스위치 또는 기타 버퍼 링 또는 격리 회로를 활성화할 수 있다. 예를 들어, 특정 레벨은 이전 워드라인 세그먼트가 완전히 로드 되었음 을 나타낼 수 있다. 도 62는 메모리 유닛의 동작을 위한 방법을 도시한 것이다. 예컨대, 방법은 도 56 내지 도 61을 참 조하여 앞서 설명한 메모리 뱅크의 하나 이상을 사용하여 이행될 수 있다. 방법은 단계 5192와 단계 5194를 포함할 수 있다. 단계 5192는 활성화부가 메모리 유닛의 제2 메모리 매트에 포함된 제2 그룹의 메모리 셀을 활성화하지 않고 메 모리 유닛의 제1 메모리 매트에 포함된 제1 그룹의 메모리 셀을 활성화하는 단계를 포함할 수 있다. 제1 그룹의 메모리 셀과 제2 그룹의 메모리 셀은 모두 메모리 유닛의 단일 행에 속할 수 있다. 단계 5194는 활성화부가 단계 5192 이후에 제2 그룹의 메모리 셀을 활성화하는 단계를 포함할 수 있다. 단계 5194는 제1 그룹의 메모리 셀이 활성화되는 동안, 제1 그룹의 메모리 셀의 완전 활성화 이후, 제1 그룹의 메모리 셀의 활성화가 완료된 이후에 개시된 지연 기간의 만료 이후, 제1 그룹의 메모리 셀이 비활성화된 이후 등에 실행될 수 있다. 지연 기간은 고정 또는 조정될 수 있다. 예를 들어, 지연 기간의 길이는 메모리 유닛의 예상 접근 패턴에 의거 할 수 있거나 예상 접근 패턴과 무관하게 설정될 수 있다. 지연 기간은 1000분의 1초 내지 1초 이상의 범위일 수 있다. 일부 실시예에서, 단계 5194는 제1 그룹의 메모리 셀에 결합된 제1 워드라인 세그먼트 상에 생성된 신호의 값에 의거하여 개시될 수 있다. 예컨대, 신호의 값이 제1 임계값을 초과하는 경우, 제1 그룹의 메모리 셀이 완전히 활성화되었음을 나타내는 것일 수 있다. 단계 5192와 단계 5194의 하나는 제1 워드라인 세그먼트와 제2 워드라인 세그먼트 사이에 배치된 중간 회로(예, 활성화부의 중간 회로)를 사용할 수 있다. 제1 워드라인 세그먼트는 제1 메모리 셀에 결합될 수 있고, 제2 워드 라인 세그먼트는 제2 메모리 셀에 결합될 수 있다. 중간 회로의 예들은 도 56 내지 도 61에 도시되어 있다. 단계 5192와 단계 5194는 단일 행과 연관된 워드라인으로부터의 활성화 신호의 제1 그룹의 메모리 셀과 제2 그 룹의 메모리 셀로의 인가를 제어부가 제어하는 단계를 더 포함할 수 있다. 검사 시간 단축을 위한 메모리 병렬화(parallelism) 및 벡터를 활용하는 메모리의 검사 로직 본 개시의 일부 실시예들은 인칩 검사부(in chip testing unit)를 활용하여 검사의 속도를 빠르게 할 수 있다. 일반적으로, 메모리 칩의 검사에는 상당한 검사 시간이 필요하다. 검사 시간을 줄이면 생산 비용을 줄일 수 있 고 또한 더 많은 검사가 가능해지므로 제품의 신뢰성이 높아질 수 있다. 도 63과 도 64는 검사기 및 칩(또는 칩의 웨이퍼)을 도시한 것이다. 검사기는 검사를 관리하 는 소프트웨어를 포함할 수 있다. 검사기는 메모리의 전체에 대해 데이터의 상이한 시퀀스를 실행 한 후에 이 시퀀스를 다시 읽어 메모리의 불량 비트가 위치한 장소를 식별할 수 있다. 일단 인지가 되면, 검사기는 비트를 수리하기 위한 명령을 생성하고, 문제가 해결되는 경우에, 검사기는 메모리(521 0)의 검사 합격을 표명할 수 있다. 그렇지 않은 경우에, 일부 칩은 불량으로 표명될 수 있다. 검사기는 검사 시퀀스를 기록한 후에 데이터를 다시 읽어와서 예상 결과와 비교할 수 있다. 도 64는 검사기 및 병렬로 검사되는 칩(예, 5210)의 전체 웨이퍼가 있는 검사 시스템을 도시한 것 이다. 예컨대, 검사기는 배선의 버스로 칩의 각각에 연결될 수 있다. 도 64에 도시된 바와 같이, 검사기는 메모리 칩 모두에 읽기 및 쓰기를 몇 차례 해야 하고, 데이터는 외 부 칩 인터페이스를 통해 통과해야 한다. 또한, 일반적인 I/O 동작을 활용하여 제공될 수 있는 프로그램 가능한 구성 정보 등을 활용하여 집적회로의 로 직과 메모리 뱅크 모두를 검사하는 것이 이로울 수 있다. 또한, 집적회로 이내에 검사부가 있는 것이 검사에 유리할 수 있다. 검사부는 집적회로에 속해 있을 수 있고 검사 결과를 분석하고 로직(예, 도 7a에 도시되고 설명한 프로세서 서 브유닛) 및/또는 메모리(예, 복수의 메모리 뱅크 전체)의 불량 등을 발견할 수 있다. 메모리 검사기는 보통 매우 단순하고 단순 형식에 따라 집적회로와 검사 벡터를 교환한다. 예를 들어, 기록될 메모리 엔트리의 어드레스의 쌍 및 메모리 엔트리에 기록될 값을 포함하는 쓰기 벡터가 있을 수 있다. 또한, 읽 을 메모리 엔트리의 어드레스를 포함하는 읽기 벡터도 있을 수 있다. 쓰기 벡터의 어드레스의 적어도 일부는 읽 기 벡터의 어드레스의 적어도 일부와 동일할 수 있다. 쓰기 벡터의 적어도 일부 다른 어드레스는 읽기 벡터의 적어도 일부 다른 어드레스와 상이할 수 있다. 프로그램이 되면, 메모리 검사기는 또한 읽을 메모리 엔트리의 어드레스와 읽을 예상 값을 포함할 수 있는 예상 결과 벡터를 수신할 수 있다. 메모리 검사기는 읽는 값에 예상 값을 비교할 수 있다. 일 실시예에 따르면, 집적회로(집적회로의 메모리 포함 또는 미포함)의 로직(예, 프로세서 서브유닛)은 동일한 프로토콜/형식을 사용하여 메모리 검사기에 의해 검사될 수 있다. 예를 들어. 쓰기 벡터의 값의 일부는 집적회 로의 로직에 의해 실행될 명령일 수(및 계산 및/또는 메모리 접근을 포함할 수) 있다. 메모리 검사기는 메모리 엔트리 어드레스(적어도 일부는 계산의 예상 값을 저장)를 포함할 수 있는 예산 결과 벡터 및 읽기 벡터로 프로 그램 될 수 있다. 따라서, 메모리 검사기는 로직뿐만 아니라 메모리의 검사에 사용될 수 있다. 메모리 검사기는 일반적으로 로직 검사기보다 훨씬 단순하고 저렴하며, 제시된 방법을 통해 단순한 메모리 검사기를 활용하여 복 잡한 로직 검사를 수행할 수 있다. 일부 실시예에서, 메모리 이내의 로직은 벡터(또는 기타 데이터 구조)만을 활용하고 로직 검사에 흔히 사용되는 더욱 복잡한 메커니즘(예, 인터페이스 등을 통해 컨트롤러와 통신하여 어느 회로를 검사할지 로직에 지시)을 활 용하지 않고 메모리 이내의 로직의 검사를 가능하게 한다. 검사부를 사용하는 대신에, 메모리 컨트롤러는 구성 정보에 포함된 메모리 엔트리에 접근하라는 명령을 수신하 고 접근 명령을 실행하고 결과를 출력하도록 구성될 수 있다. 도 65 내지 도 69에 도시된 집적회로의 하나 이상은 검사부가 없이도 또는 검사를 수행할 능력이 없는 검사기가 있어도 검사를 실행할 수 있다. 본 개시의 실시예들은 메모리의 병렬화(parallelism) 및 내부 칩 대역폭을 활용하여 검사 시간을 단축하고 향상 하는 방법 및 시스템을 포함할 수 있다. 방법과 시스템은 메모리 칩이 그 자체를 검사하고(검사기가 검사를 실행하고, 검사 결과를 읽고, 결과를 분석하 는 것이 아닌), 결과를 저장하고, 및 궁극적으로 검사기가 결과를 읽도록 하는(및, 필요한 경우, 메모리 칩을 다시 프로그램하여 중복 메커니즘을 활성화하는 등) 것에 기반할 수 있다. 검사는 메모리의 검사 또는 메모리 뱅크와 로직의 검사(앞서 도 7a를 참조하여 설명한 바와 같은 검사할 기능적 논리부가 있는 계산 메모리의 경우)를 포함할 수 있다. 일 실시예에서, 방법은 외부 대역폭이 검사를 제한하지 않도록 칩 이내에서 데이터를 읽기 및 쓰기 하는 단계를 포함할 수 있다. 메모리 칩이 프로세서 서브유닛을 포함하는 실시예에서, 각 프로세서 서브유닛은 검사 코드 또는 구성으로 프로 그램 될 수 있다. 메모리 칩이 검사 코드를 실행할 수 없는 프로세서 서브유닛을 포함하거나 프로세서 서브유닛이 없지만 메모리 컨트롤러를 포함하는 실시예에서, 메모리 컨트롤러는 패턴을 읽고 쓰고(예, 외부적으로 컨트롤러에 프로그램) 추가적인 분석을 위해 불량의 위치를 표시(예, 메모리 엔트리에 값을 기록하고, 엔트리를 읽고, 기록된 값과 다 른 값을 수신)하도록 구성될 수 있다. 여기서, 메모리의 검사에는 방대한 수의 비트의 검사, 예를 들어, 메모리의 각 비트를 검사하고 검사된 비트가 기능 함을 확인하는 것이 필요할 수 있다. 또한, 메모리 검사는 상이한 전압 및 온도 조건 하에서 때때로 반복 될 수 있다. 일부 불량에 대해, 하나 이상의 중복 메커니즘이 활성화될 수(예, 플래시 또는 OTP를 프로그램 하거나 퓨즈를 태워서) 있다. 또한, 메모리 칩의 논리 및 아날로그 회로(예, 컨트롤러, 레귤레이터, I/O)의 검사도 필요할 수 있다. 일 실시예에서, 집적회로는 기판, 기판 상에 배치된 메모리 어레이, 기판 상에 배치된 프로세싱 어레이, 및 기 판 상에 배치된 인터페이스를 포함할 수 있다. 여기서 설명하는 집적회로는 도 3a, 도 3b, 도 4 내지 도 6, 도 7a 내지 도 7d, 도 11 내지 도 13, 도 16 내지 도 19, 도 22, 및 도 23의 하나 이상에 도시된 바와 같은 메모리 칩에 포함되거나 메모리 칩을 포함할 수 있다. 도 65 내지 도 69는 다양한 집적회로 및 검사기를 도시하고 있다. 집적회로는 메모리 뱅크, 칩 인터페이스(예, 메모리 뱅크가 공유하는 버스 및 I/O 컨트롤러 ), 및 논리부(이하 \"로직\"으로 칭함)를 포함하는 것으로 도시되어 있다. 도 66은 퓨즈 인터페이스 및 퓨즈 인터페이스와 상이한 메모리 뱅크에 결합된 버스를 도시하고 있다. 도 65 내지 도 70은 또한 다음과 같은 검사 프로세스의 다양한 단계를 도시하고 있다. a.검사 시퀀스를 쓰는 단계 (도 65, 도 67, 도 68, 도 69); b.검사 결과를 읽어오는 단계 (도 67, 도 68, 도 69); c.예상 결과 시퀀스를 쓰는 단계 (도 65); d.수정할 불량 어드레스를 읽어오는 단계 (도 66); 및 e.퓨즈를 프로그램 하는 단계 (도 66). 각 메모리 뱅크는 그 자체의 논리부에 결합 및/또는 논리부에 의해 제어될 수 있다. 그러나 앞서 설명한 바와 같이, 논리부로의 모든 임의의 할당이 제공될 수 있다. 따라서, 논리부의 수는 메모리 뱅크의 수와 다를 수 있고, 논리부는 하나 이상의 메모리 뱅크 또는 한 메모리 뱅크의 일부 등을 제어할 수 있 다. 논리부는 하나 이상의 검사부를 포함할 수 있다. 또 65는 논리부 내의 검사부(TU)를 도시하 고 있다. TU는 논리부의 전체 또는 일부에 포함될 수 있다. 여기서, 검사부는 논리부와 분리되어 있거나 논리부와 일체일 수 있다. 도 65는 또한 TU 내의 검사 패턴 생성기(GEN으로 표시)를 도시하고 있다. 검사 패턴 생성기는 검사부의 전체 또는 일부에 포함될 수 있다. 간략한 도시를 위해, 검사 패턴 생성기와 검사 부는 도 66 내지 도 70에는 도시되어 있지 않지만 이러한 실시예들에 포함될 수 있다. 메모리 어레이는 다중 메모리 뱅크를 포함할 수 있다. 또한, 프로세싱 어레이는 복수의 검사부를 포함할 수 있 다. 복수의 검사부는 다중 메모리 뱅크를 검사하여 검사 결과를 제공하도록 구성될 수 있다. 인터페이스는 검사 결과를 나타내는 정보를 집적회로 외부의 장치로 출력하도록 구성될 수 있다. 복수의 검사부는 다중 메모리 뱅크의 하나 이상의 검사에 사용할 적어도 하나의 검사 패턴을 생성하도록 구성된 적어도 하나의 검사 패턴 생성기를 포함할 수 있다. 일부 실시예에서, 앞서 설명한 바와 같이, 복수의 검사부 각각은 복수의 검사부의 특정 검사부에 의해 사용될 검사 패턴을 생성하여 다중 메모리 뱅크의 적어도 하나를 검사하도록 구성된 검사 패턴 생성기를 포함할 수 있다. 앞서 설명한 바와 같이, 도 65는 검사부 내의 검사 패 턴 생성기(GEN)를 도시하고 있다. 하나 이상의 또는 모든 논리부가 검사 패턴 생성기를 포함할 수 있다. 적어도 하나의 검사 패턴 생성기는 적어도 하나의 검사 패턴을 생성하기 위한 명령을 인터페이스로부터 수신하 도록 구성될 수 있다. 검사 패턴은 검사 중에 접근되어야 할(예, 읽기 및/또는 쓰기 할) 메모리 엔트리 및/또는 엔트리에 기록될 값 등을 포함할 수 있다. 인터페이스는 집적회로 외부에 있을 수 있는 외부 장치로부터 적어도 하나의 검사 패턴 생성을 위한 명령을 포 함하는 구성 정보를 수신하도록 구성될 수 있다. 적어도 하나의 검사 패턴 생성기는 메모리 어레이로부터 적어도 하나의 검사 패턴을 생성하기 위한 명령을 포함 하는 구성 정보를 읽어오도록 구성될 수 있다. 일부 실시예에서, 구성 정보는 벡터를 포함할 수 있다. 인터페이스는 적어도 하나의 검사 패턴일 수 있는 명령을 포함하는 구성 정보를 집적회로의 외부에 있을 수 있 는 장치로부터 수신하도록 구성될 수 있다. 예를 들어, 적어도 하나의 검사 패턴은 메모리 어레이의 검사 동안에 접근되어야 할 메모리 어레이 엔트리를 포 함할 수 있다. 적어도 하나의 검사 패턴은 메모리 어레이의 검사 동안에 접근된 메모리 어레이에 기록될 입력 데이터를 더 포 함할 수 있다. 추가적으로 또는 대안적으로, 적어도 하나의 검사 패턴은 메모리 어레이의 검사 동안에 접근된 메모리 어레이 엔트리에 기록될 입력 데이터 및 메모리 어레이의 검사 동안에 접근된 메모리 어레이 엔트리에서 읽어올 출력 데이터의 예상 값을 더 포함할 수 있다. 일부 실시예에서, 복수의 검사부는 복수의 검사부에 의해 실행되면 복수의 검사부가 메모리 어레이를 검사하도 록 유발하는 검사 명령을 메모리 어레이로부터 가져오도록 구성될 수 있다. 예를 들어, 검사 명령은 구성 정보에 포함될 수 있다. 구성 정보는 메모리 어레이 검사의 예상 결과를 포함할 수 있다. 추가적으로 또는 대안적으로, 구성 정보는 메모리 어레이의 검사 동안에 접근된 메모리 어레이 엔트리로부터 읽 어올 출력 데이터의 값을 포함할 수 있다. 추가적으로 또는 대안적으로, 구성 정보는 벡터를 포함할 수 있다. 일부 실시예에서, 복수의 검사부는 복수의 검사부에 의해 실행되면 복수의 검사부가 메모리 어레이를 검사하고 프로세싱 어레이를 검사하도록 유발하는 검사 명령을 메모리 어레이로부터 가져오도록 구성될 수 있다. 예를 들어, 검사 명령은 구성 정보에 포함될 수 있다. 구성 정보는 벡터를 포함할 수 있다. 추가적으로 또는 대안적으로, 구성 정보는 메모리 어레이 검사와 프로세싱 어레이 검사의 예상 결과를 포함할 수 있다. 일부 실시예에서, 앞서 설명한 바와 같이, 복수의 검사부는 다중 메모리 뱅크의 검사 동안에 사용되는 검사 패 턴의 생성을 위한 검사 패턴 생성기가 없을 수 있다. 이러한 실시예에서, 복수의 검사부의 적어도 2개의 검사부는 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크를 병렬로 검사하도록 구성될 수 있다. 대안적으로, 복수의 검사부의 적어도 2개의 검사부는 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크를 직렬로 검사하도록 구성될 수 있다. 일부 실시예에서, 검사 결과를 나타내는 정보는 불량 메모리 어레이 엔트리의 식별자를 포함할 수 있다. 일부 실시예에서, 인터페이스는 복수의 검사 회로에 의해 확보된 부분적 검사 결과를 메모리 어레이의 검사 동 안에 여러 회 가져오도록 구성될 수 있다. 일부 실시예에서, 집적회로는 메모리 어레이의 검사 동안에 검출된 적어도 하나의 오류를 수정하도록 구성된 오 류 수정부를 포함할 수 있다. 예를 들어, 오류 수정부는 일부 메모리 워드를 비활성화하고 이러한 워드를 중복 워드로 대체하는 등의 모든 임의의 적절한 방법을 활용하여 메모리 오류를 수정하도록 구성될 수 있다. 상기의 모든 임의의 실시예에서, 집적회로는 메모리 칩일 수 있다. 예컨대, 집적회로는 분산 프로세서를 포함할 수 있고, 여기서 프로세싱 어레이는 도 7a에 도시된 바와 같은 분 산 프로세서의 복수의 서브유닛을 포함할 수 있다. 이러한 실시예에서, 프로세서 서브유닛의 각각은 다중 메모리 뱅크의 상응하는 전용 메모리 뱅크와 연관될 수 있다. 앞서 설명한 모든 임의의 실시예에서, 검사 결과를 나타내는 정보는 적어도 하나의 메모리 뱅크의 상태를 나타 낼 수 있다. 메모리 뱅크의 상태는, 메모리 워드 당, 엔트리 그룹 당, 또는 전체 메모리 뱅크 당의 하나 이상의 입도로 제공될 수 있다. 도 65 내지 도 66은 검사기 검사 단계의 4 단계를 도시하고 있다. 제1단계에서, 검사기는 검사 시퀀스를 기록하고, 메모리 뱅크의 논리부는 데이터를 메모리에 기록한다. 로직은 검사기로부터 명령을 수신하고 자체적으로 검사 시퀀스를 생성(하기에 설명)할 정도로 복잡할 수도 있다. 제2단계에서, 검사기는 예상 결과를 검사된 메모리에 기록하고, 논리부는 메모리 뱅크에서 읽어온 데이터 에 예상 결과를 비교하여 오류의 목록을 저장한다. 예상 결과를 기록하는 단계는 로직이 자체적으로 예상 결과 의 시퀀스를 생성(하기에 설명)할 수 있을 정도로 복잡한 경우에 단순화될 수 있다. 제3단계에서, 검사기는 논리부로부터 불량 어드레스를 판독한다. 제4단계에서, 검사기는 결과에 의거하여 행동하고 오류를 수정할 수 있다. 예를 들면, 특정 인터페이스에 연결하여 메모리 내에 퓨즈를 프로그램하지만 메모리 내에 오류 수정 메커니즘을 프로그램할 수 있게 하는 모든 임의의 다른 메커니즘을 활용할 수도 있다. 이러한 실시예에서, 메모리 검사기는 벡터를 활용하여 메모리를 검사할 수 있다. 예를 들어, 각 벡터는 입력 시리즈와 출력 시리즈로부터 구성될 수 있다. 입력 시리즈는 메모리에 기록할 데이터와 어드레스의 쌍을 포함할 수 있다(많은 실시예에서, 이 시리즈는 논리 부에 의해 실행된 프로그램과 같은 프로그램이 필요한 경우에 생성할 수 있게 하는 공식으로 모델링 될 수 있다). 일부 실시예에서, 검사 패턴 생성기는 이러한 벡터를 생성할 수 있다. 여기서, 벡터가 예시적인 데이터 구조이지만, 다른 실시예들은 다른 데이터 구조를 사용할 수 있다. 데이터 구 조는 집적회로 외부에 위치한 검사기에 의해 생성된 다른 검사 데이터 구조를 준수할 수 있다. 출력 시리즈는 메모리로부터 읽어올 예상 데이터를 포함하는 데이터와 어드레스 쌍을 포함할 수 있다(일부 실시 예에서, 이 시리즈는 런타임(runtime)에 프로그램에 의해, 예를 들면 논리부에 의해, 생성될 수 있다). 메모리 검사는 각각의 벡터가 입력 시리즈에 따라 메모리에 데이터를 쓴 후에 출력 시리즈에 따라 데이터를 읽 어오고 예상 데이터에 비교하는 벡터의 목록을 실행하는 단계를 일반적으로 포함한다. 부조화(mismatch)의 경우, 메모리는 불량으로 분류되거나, 메모리에 중복성에 대한 메커니즘이 있으면 중복 메 커니즘이 활성화되게 하여 활성화된 중복 메커니즘 상에서 벡터가 다시 검사되게 할 수 있다. 메모리가 프로세서 서브유닛(도 7a를 참조하여 설명)을 포함하거나 여러 메모리 컨트롤러를 포함하는 실시예에 서, 전체 검사는 메모리 뱅크의 논리부에 의해 처리될 수 있다. 따라서, 메모리 컨트롤러 또는 프로세서 서브유 닛이 검사를 수행할 수 있다. 메모리 컨트롤러는 검사기로부터 프로그램될 수 있고, 검사의 결과는 검사기에 의한 추후 판독을 위해 메모리 컨트롤러 자체에 보관될 수 있다. 논리부의 동작을 구성 및 검사하기 위해, 검사기는 논리부를 메모리 접근이 되도록 구성하고 검사 결과가 메모 리 접근에 의해 판독될 수 있음을 확인할 수 있다. 예를 들면, 입력 벡터는 논리부에 대한 프로그래밍 시퀀스를 포함할 수 있고, 출력 벡터는 이러한 검사의 예상 결과를 포함할 수 있다. 예컨대, 프로세서 서브유닛과 같은 논리부가 메모리의 2개의 어르레스 상의 계산을 수 행하도록 구성된 배율기(multiplier) 또는 합산기(adder)를 포함하는 경우, 입력 벡터는 데이터를 메모리에 기 록하는 명령의 세트 및 합산기/배율기 로직으로 기록하는 명령의 세트를 포함할 수 있다. 합산기/배율기 결과가 출력 벡터로 읽어올 수만 있다면, 결과는 검사기로 전송될 수 있다. 검사는 메모리로부터 로직 구성을 로드하고 로직 출력이 메모리로 전송되게 하는 단계를 더 포함할 수 있다. 논리부가 그 구성을 메모리로부터 로드하는 실시예에서(예, 로직이 메모리 컨트롤러인 경우), 논리부는 코드를 메모리 그 자체로부터 실행할 수 있다. 이에 따라, 입력 벡터는 논리부에 대한 프로그램을 포함할 수 있고, 프로그램 그 자체가 논리부의 다양한 회로 를 검사할 수 있다. 따라서, 검사는 외부 검사기가 사용하는 형식으로 벡터를 수신하는 것으로 제한되지 않을 수 있다. 논리부로 로드되는 명령이 논리부에게 메모리 뱅크로 결과를 기록하도록 지시하는 경우, 검사기는 이러한 결과 를 판독하고 예상 출력 시리즈에 비교할 수 있다. 예를 들어, 메모리에 기록된 벡터는 논리부에 대한 검사 프로그램이거나 검사 프로그램(예, 검사는 메모리가 유 효하다는 가정 하에 하지만, 그렇지 않은 경우에도, 기록된 검사 프로그램은 작동하지 않을 것이고, 검사는 실 패할 것이며, 이는 어차피 칩이 유효하지 않으므로 용납될 만한 결과이다) 및/또는 논리부가 코드를 실행하고 결과를 메모리에 기록하는 방법을 포함할 수 있다. 논리부의 모든 검사는 메모리를 통해 수행될 수 있으므로(메 모리에 로직 검사 입력을 기록하고 검사 결과를 기록), 검사기는 입력 시퀀스와 예상 출력 시퀀스로 단순 벡터 검사를 실행할 수 있다. 로직 구성과 결과는 읽기 명령 및/또는 쓰기 명령으로 접근될 수 있다. 도 68은 벡터인 쓰기 검사 시퀀스를 전송하는 검사기를 도시한 것이다. 벡터의 부분들에는 프로세싱 어레이의 로직에 결합된 메모리 뱅크 사이에 나누어진 검사 코드 가 포함된다. 각 로직은 연관된 메모리 뱅크에 저장된 코드를 실행할 수 있고, 이러한 실행은 하나 이상의 메모 리 뱅크에 접근하는 단계, 계산을 수행하는 단계, 및 결과(예, 검사 결과)를 메모리 뱅크에 저장하 는 단계를 포함할 수 있다. 검사 결과는 검사기에 의해 반송될 수 있다(예, 결과를 판독). 이로써, 로직은 I/O 컨트롤러에 의해 수신된 명령에 의해 제어될 수 있다. 도 68에서, I/O 컨트롤러는 메모리 뱅크와 로직으로 연결된다. 다른 실시예에서, 로직은 I/O 컨트롤러 와 메모리 뱅크 사이에 연결될 수 있다. 도 70은 메모리 뱅크를 검사하는 방법을 도시한 것이다. 예컨대, 방법은 앞서 도 65 내지 도 69를 참조하여 설명한 메모리 뱅크의 하나 이상을 활용하여 이행될 수 있다. 방법은 단계 5302, 단계 5310, 및 단계 5320을 포함할 수 있다. 단계 5302에서, 집적회로의 메모리 뱅크 를 검사하라는 요청을 수신할 수 있다. 집적회로는 기판, 기판 상에 배치되고 메모리 뱅크를 포함하는 메모리 어레이, 기판 상에 배치된 프로세싱 어레이, 및 기판 상에 배치된 인터페이스를 포함할 수 있다. 프로세싱 어레 이는 앞서 설명한 바와 같이 복수의 검사부를 포함할 수 있다. 일부 실시예에서, 요청은 구성 정보, 하나 이상의 벡터, 명령 등을 포함할 수 있다. 이러한 실시예에서, 구성 정보는 메모리 어레이 검사의 예상 결과, 명령, 데이터, 메모리 어레이의 검사 동안에 접근되는 메모리 어레이 엔트리로부터 판독될 출력 데이터의 값, 검사 패턴 등을 포함할 수 있다. 검사 패턴은 (i) 메모리 어레이의 검사 동안에 접근될 메모리 어레이 엔트리, (ii) 메모리 어레이의 검사 동안 에 접근된 메모리 어레이에 기록될 입력 데이터, 및 (iii) 메모리 어레이의 검사 동안에 접근된 메모리 어레이 엔트리로부터 판독될 출력 데이터의 예상 값 중의 적어도 하나를 포함할 수 있다. 단계 5302는 다음과 같은 단계들의 적어도 하나를 포함하고/하거나 다음과 같은 단계들의 적어도 하나가 후속할 수 있다. a. 적어도 하나의 검사 패턴을 생성하기 위한 명령을 적어도 하나의 검사 패턴 생성기가 인터페이스로부터 수신 하는 단계; b. 적어도 하나의 검사 패턴을 생성하기 위한 명령을 포함하는 구성 정보를 인터페이스가 집적회로 외부의 외부 장치로부터 수신하는 단계; c. 적어도 하나의 검사 패턴을 생성하기 위한 명령을 포함하는 구성 정보를 적어도 하나의 검사 패턴 생성기가 메모리 어레이로부터 읽어오는 단계; d. 적어도 하나의 검사 패턴인 명령을 포함하는 구성 정보를 인터페이스가 집적회로 외부의 외부 장치로부터 수 신하는 단계; e. 복수의 검사부에 의해 실행되면 복수의 검사부가 메모리 어레이를 검사하도록 유발하는 검사 명령을 복수의 검사부가 메모리 어레이로부터 가져오는 단계; 및 f. 복수의 검사부에 의해 실행되면 복수의 검사부가 메모리 어레이를 검사하고 프로세싱 어레이를 검사하도록 유발하는 검사 명령을 복수의 검사부가 메모리 어레이로부터 수신하는 단계. 단계 5302 이후에 단계 5310이 수행될 수 있다. 단계 5310에서, 복수의 검사부가 요청에 대응하여 다중 메모리 뱅크를 검사하고 검사 결과를 제공할 수 있다. 방법은 인터페이스가 복수의 검사부에 의해 확보된 부분적 검사 결과를 메모리 어레이의 검사 동안에 여 러 회 수신하는 단계를 더 포함할 수 있다. 단계 5310은 다음과 같은 단계들의 적어도 하나를 포함하고/하거나 다음과 같은 단계들의 적어도 하나가 후속할 수 있다. a.하나 이상의 다중 메모리 뱅크의 적어도 하나를 검사하기 위해 검사부에 의해 사용될 검사 패턴을 하나 이상 의 검사 패턴 생성기(예, 복수의 검사부의 하나, 일부, 또는 모두에 포함된 검사 패턴 생성기)가 생성하는 단계; b.복수의 검사부의 적어도 2개의 검사부가 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크를 병렬로 검사하는 단 계; c.복수의 검사부의 적어도 2개의 검사부가 다중 메모리 뱅크의 적어도 2개의 메모리 뱅크를 직렬로 검사하는 단 계; d.메모리 엔트리에 값을 기록하고, 메모리 엔트리를 판독하고, 결과를 비교하는 단계; 및 e.메모리 어레이의 검사 도중에 검출된 적어도 하나의 오류를 오류 수정부가 수정하는 단계. 단계 5310 이후에 단계 5320이 수행될 수 있다. 단계 5320에서, 검사 결과를 나타내는 정보를 인터페이스가 집 적회로의 외부로 출력할 수 있다. 검사 결과를 나타내는 정보는 불량 메모리 어레이 엔트리의 식별자를 포함할 수 있다. 이로써, 각 메모리 엔트 리에 관한 읽기 데이터를 전송하지 않음으로써 시간을 절약할 수 있다. 추가적으로 또는 대안적으로, 검사 결과를 나타내는 정보는 적어도 하나의 메모리 뱅크의 상태를 나타낼 수 있 다. 이에 따라, 일부 실시예에서, 검사 결과를 나타내는 정보는 검사 동안에 메모리 뱅크에 기록되거나 메모리 뱅크 로부터 판독된 데이터 유닛의 총 사이즈보다 훨씬 작을 수 있고, 검사부의 도움 없이 메모리를 검사하는 검사기 에서 전송될 수 있는 입력 데이터보다 훨씬 작을 수 있다. 검사된 집적회로는 상기에 설명한 도면의 하나 이상에 도시된 바와 같은 메모리 칩 및/또는 분산 프로세서를 포 함할 수 있다. 예를 들어, 여기서 설명하는 집적회로는 도 3a, 도 3b, 도 4 내지 도 6, 도 7a 내지 도 7d, 도 11 내지 도 13, 도 16 내지 도 19, 도 22, 및 도 23의 하나 이상에 도시된 바와 같은 메모리 칩에 포함되거나 메모리 칩을 포함할 수 있다. 도 71은 집적회로의 메모리 뱅크를 검사하는 방법의 일례를 도시한 것이다. 예컨대, 방법은 앞서 도 65 내지 도 69를 참조하여 설명한 메모리 뱅크의 하나 이상을 활용하여 이행될 수 있다. 방법은 단계 5352, 단계 5355, 및 단계 5358을 포함할 수 있다. 단계 5352에서, 명령을 포함하는 구성 정 보를 집적회로의 인터페이스가 수신할 수 있다. 인터페이스를 포함하는 집적회로는 또한 기판, 메모리 뱅크를 포함하고 기판 상에 배치되는 메모리 어레이, 기판 상에 배치되는 프로세싱 어레이, 및 기판 상에 배치된 인터 페이스를 포함할 수 있다. 구성 정보는 메모리 어레이 검사의 예상 결과, 명령, 데이터, 메모리 어레이의 검사 동안에 접근되는 메모리 어 레이 엔트리로부터 판독될 출력 데이터의 값, 검사 패턴 등을 포함할 수 있다. 추가적으로 또는 대안적으로, 구성 정보는 명령, 명령을 기록할 메모리 엔트리의 어드레스, 입력 데이터를 포함 할 수 있고, 명령의 실행 동안에 계산된 출력 값을 수신하기 위한 메모리 엔트리의 어드레스도 포함할 수 있다. 검사 패턴은 (i) 메모리 어레이의 검사 동안에 접근될 메모리 어레이 엔트리, (ii) 메모리 어레이의 검사 동안 에 접근된 메모리 어레이에 기록될 입력 데이터, 및 (iii) 메모리 어레이의 검사 동안에 접근된 메모리 어레이 엔트리로부터 판독될 출력 데이터의 예상 값 중의 적어도 하나를 포함할 수 있다. 단계 5352 이후에 단계 5355가 수행될 수 있다. 단계 5355에서, 메모리 어레이에 접근하고, 연산 동작을 수행하 고, 결과를 제공하여 프로세싱 어레이가 명령을 실행할 수 있다. 단계 5355 이후에 단계 5358이 수행될 수 있다. 단계 5358에서, 결과를 나타내는 정보를 인터페이스가 집적회로 의 외부로 출력할 수 있다. 상기의 설명은 예시의 목적으로 제시되었다. 이 설명은 모든 것을 망라한 것이 아니며 개시된 그대로의 형태 또 는 실시예로 제한되는 것이 아니다. 수정 및 응용은 본 명세서를 고려하고 개시된 실시예를 실시함으로써 당업 자에게 당연할 것이다. 또한, 개시된 실시예의 양상들이 메모리에 저장되는 것으로 설명되었지만, 당업자라면 이러한 양상들이, 예를 들어, 하드 디스크 또는 CD ROM, 또는 다른 유형의 RAM 또는 ROM, USB 매체, DVD, 블루 레이, UHD 블루레이, 또는 기타 광드라이브 매체 등의 2차 저장장치와 같은 다른 유형의 컴퓨터 가독 매체에 저 장될 수도 있음을 이해할 것이다. 개시된 설명과 방법에 기반한 컴퓨터 프로그램은 당업자에게는 당연한 기술이다. 다양한 프로그램 또는 프로그 램 모듈이 당업자에게 공지인 기술을 사용하여 생성되거나 기존의 소프트웨어와 관련되어 설계될 수 있다. 예를 들어, 프로그램 섹션 또는 프로그램 모듈은 .Net Framework, .Net Compact Framework (및 Visual Basic, C 등 과 같은 관련 언어), Java, C++, Objective-C, HTML, HTML/AJAX 조합, XML, 또는 자바 애플릿(Java applet)을 포함하는 HTML로 설계될 수 있다. 또한, 예시된 실시예들을 여기에 설명하였지만, 모든 실시예의 범위는 균등한 구성요소, 수정, 누락, 조합(예, 다양한 실시예에 걸친 양상의 조합), 응용, 및/또는 변경을 가짐은 본 발명의 당업자에게 당연하다. 청구항의 한정은 청구항에 사용된 언어에 근거하여 넓게 해석되어야 하며 본 명세서에서 또는 본 발명의 출원 중에 설명 된 예시에 한정되지 않는다. 예시들은 배타적이지 않은 것으로 이해되어야 한다. 나아가, 개시된 방법의 단계들 은 단계들의 순서를 재배열 및/또는 단계를 삽입 또는 삭제하는 등의 다양한 방법으로 수정될 수 있다. 따라서, 본 명세서와 예시들은 예시의 목적으로만 고려되고, 진정한 범위와 기술적 사상은 하기의 청구항과 그 균등한 범위에 의해 정의된다."}
{"patent_id": "10-2021-7010116", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시에 포함되고 본 개시의 일부를 구성하는 첨부 도면은 개시된 다양한 실시예를 도시한다. 도 1은 중앙처리장치(CPU)를 개략적으로 도시한 것이다. 도 2는 그래픽처리장치(GPU)를 개략적으로 도시한 것이다. 도 3a는 개시된 실시예에 따른 예시적인 하드웨어 칩의 일 실시예를 개략적으로 도시한 것이다. 도 3b는 개시된 실시예에 따른 예시적인 하드웨어 칩의 다른 실시예를 개략적으로 도시한 것이다. 도 4는 개시된 실시예에 따른 예시적인 하드웨어 칩에 의해 실행되는 일반적인 명령을 개략적으로 도시한 것이다.도 5는 개시된 실시예에 따른 예시적인 하드웨어 칩에 의해 실행되는 특수한 명령을 개략적으로 도시한 것이다. 도 6은 개시된 실시예에 따른 예시적인 하드웨어 칩에서 사용하기 위한 프로세싱 그룹을 개략적으로 도시한 것 이다. 도 7a는 개시된 실시예에 따른 프로세싱 그룹의 장방형 어레이를 개략적으로 도시한 것이다. 도 7b는 개시된 실시예에 따른 프로세싱 그룹의 타원형 어레이를 개략적으로 도시한 것이다. 도 7c는 개시된 실시예에 따른 하드웨어 칩의 어레이를 개략적으로 도시한 것이다. 도 7d는 개시된 실시예에 따른 하드웨어 칩의 다른 어레이를 개략적으로 도시한 것이다. 도 8은 개시된 실시예에 따른 예시적인 하드웨어 칩 상에서의 실행을 위한 일련의 명령을 컴파일하기 위한 예시 적인 방법을 도시한 순서도이다. 도 9는 메모리 뱅크를 개략적으로 도시한 것이다. 도 10은 메모리 뱅크를 개략적으로 도시한 것이다. 도 11은 개시된 실시예에 따른 서브뱅크 컨트롤이 있는 예시적인 메모리 뱅크의 일 실시예를 개략적으로 도시한 것이다. 도 12는 개시된 실시예에 따른 서브뱅크 컨트롤이 있는 예시적인 메모리 뱅크의 다른 실시예를 개략적으로 도시 한 것이다 도 13은 개시된 실시예에 따른 예시적인 메모리 칩의 구성도이다. 도 14는 개시된 실시예에 따른 예시적인 리던던트 로직 블록 세트의 구성도이다. 도 15는 개시된 실시예에 따른 예시적인 로직 블록의 구성도이다. 도 16은 개시된 실시예에 따른 버스가 연결된 예시적인 로직 블록의 구성도이다. 도 17은 개시된 실시예에 따른 직렬로 연결된 예시적인 로직 블록의 구성도이다. 도 18은 개시된 실시예에 따른 2차원 어레이로 연결된 예시적인 로직 블록의 구성도이다. 도 19는 개시된 실시예에 따른 복합 연결된 예시적인 로직 블록에 대한 구성도이다. 도 20은 개시된 실시예에 따른 리던던트 블록 활성화 프로세스를 도시한 예시적인 순서도이다. 도 21은 개시된 실시예에 따른 어드레스 배정 프로세스를 도시한 예시적인 순서도이다. 도 22는 개시된 실시예에 따른 예시적인 처리 장치에 대한 구성도이다. 도 23은 개시된 실시예에 따른 예시적인 처리 장치의 구성도이다. 도 24는 개시된 실시예에 따른 예시적인 메모리 구성도를 포함한다. 도 25는 개시된 실시예에 따른 메모리 설정 프로세스를 도시한 예시적인 순서도이다. 도 27은 개시된 실시예에 따른 실행 프로세스를 도시한 예시적인 순서도이다. 도 28은 본 개시에 따른 리프레시 컨트롤러를 포함하는 예시적인 메모리 칩을 도시한 것이다. 도 29a는 본 개시에 따른 예시적인 리프레시 컨트롤러를 도시한 것이다. 도 29b는 본 개시에 따른 다른 예시적인 리프레시 컨트롤러를 도시한 것이다. 도 30은 본 개시에 따른 리프레시 컨트롤러에 의해 실행되는 프로세스의 예시적인 순서도이다. 도 31은 본 개시에 따른 컴파일러에 의해 이행되는 프로세스의 예시적인 순서도이다. 도 32는 본 개시에 따른 컴파일러에 의해 이행되는 프로세스의 다른 예시적인 순서도이다. 도 33은 본 개시에 따른 저장된 패턴에 의해 구성된 예시적인 리프레시 컨트롤러를 도시한 것이다. 도 34는 본 개시에 따른 리프레시 컨트롤러 내의 소프트웨어에 의해 이행되는 프로세스의 예시적인 순서도이다. 도 35a는 본 개시에 따른 다이를 포함하는 예시적인 웨이퍼를 도시한 것이다. 도 35b는 본 개시에 따른 입력/출력 버스에 연결된 예시적인 메모리 칩을 도시한 것이다. 도 35c는 본 개시에 따른 행으로 배열되고 입력-출력 버스에 연결된 메모리 칩을 포함하는 예시적인 웨이퍼를 도시한 것이다. 도 35d는 본 개시에 따른 그룹을 형성하고 입력-출력 버스에 연결된 두 개의 메모리 칩을 도시한 것이다. 도 35e는 본 개시에 따른 육각형 격자로 배치되고 입력-출력 버스에 연결된 다이를 포함하는 예시적인 웨이퍼를 도시한 것이다. 도 36a 내지 도 36d는 본 개시에 따른 입력/출력 버스에 연결된 메모리 칩의 다양한 가능한 구성을 도시한 것이다. 도 37은 본 개시에 따른 글루 로직을 공유하는 다이의 예시적인 그루핑을 도시한 것이다. 도 38a 내지 도 38b는 본 개시에 따른 웨이퍼의 예시적인 절단을 도시한 것이다. 도 38c는 본 개시에 따른 웨이퍼 상의 다이의 예시적인 배열 및 입력-출력 버스의 배열을 도시한 것이다. 도 39는 본 개시에 따른 상호 연결된 프로세서 서브유닛을 포함하는 웨이퍼 상의 예시적인 메모리 칩을 도시한 것이다. 도 40은 본 개시에 따른 웨이퍼로부터 메모리 칩의 그룹을 레이아웃 하는 프로세스의 예시적인 순서도이다. 도 41a는 본 개시에 따른 웨이퍼로부터 메모리 칩의 그룹을 레이아웃 하는 프로세스의 다른 예시적인 순서도이 다. 도 41b 내지 도 41c는 본 개시에 따른 웨이퍼로부터 한 그룹 이상의 메모리 칩을 절단하기 위한 절단 패턴을 판 단하는 프로세스의 예시적인 순서도이다. 도 42는 본 개시에 따른 열을 따라 듀얼 포트 접근을 제공하는 메모리 칩 내의 회로의 예시를 도시한 것이다. 도 43은 본 개시에 따른 행을 따라 듀얼 포트 접근을 제공하는 메모리 칩 내의 회로의 예시를 도시한 것이다. 도 44는 본 개시에 따른 행과 열을 따라 듀얼 포트 접근을 제공하는 메모리 칩 내의 회로의 예시를 도시한 것이다. 도 45a는 복제된 메모리 어레이 또는 매트를 활용한 듀얼 읽기를 도시한 것이다. 도 45b는 복제된 메모리 어레이 또는 매트를 활용한 듀얼 쓰기를 도시한 것이다. 도 46은 본 개시에 따른 행을 따라 듀얼 포트 접근을 위한 스위칭 요소를 포함하는 메모리 칩 내의 회로의 예시 를 도시한 것이다. 도 47a는 본 개시에 따른 싱글 포트 메모리 어레이 또는 매트 상에 듀얼 포트 접근을 제공하기 위한 프로세스의 예시적인 순서도이다. 도 47b는 본 개시에 따른 싱글 포트 메모리 어레이 또는 매트 상에 듀얼 포트 접근을 제공하기 위한 다른 프로 세스의 예시적인 순서도이다. 도 48은 본 개시에 따른 행과 열을 따라 듀얼 포트 접근을 제공하는 메모리 칩 내의 회로의 다른 예시를 도시한 것이다. 도 49는 본 개시에 따른 메모리 매트 내의 듀얼 포트 접근을 위한 스위칭 요소의 예시를 도시한 것이다. 도 50은 본 개시에 따른 부분 워드에 접근하도록 구성된 리덕션 유닛을 포함하는 예시적인 집적회로를 도시한 것이다. 도 51은 도 50에 대해 설명된 바와 같은 리덕션 유닛을 활용하기 위한 메모리 뱅크를 도시한 것이다. 도 52는 본 개시에 따른 PIM 로직으로 통합된 리덕션 유닛을 활용하는 메모리 뱅크를 도시한 것이다. 도 53은 본 개시에 따른 PIM 로직을 활용하여 부분 워드에 접근하기 위한 스위치를 활성화하는 메모리 뱅크를도시한 것이다. 도 54a는 본 개시에 따른 부분 워드 접근을 비활성화하는 분할된 열 멀티플렉스를 포함하는 메모리 뱅크를 도시 한 것이다. 도 54b는 본 개시에 따른 메모리에서 부분 워드 접근을 위한 프로세스의 예시적인 순서도이다. 도 55는 다중 메모리 매트를 포함하는 종래의 메모리 칩을 도시한 것이다. 도 56은 본 개시에 따른 라인의 개통 동안에 전력 소비를 감소하기 위한 활성화 회로를 포함하는 예시적인 메모 리 칩을 도시한 것이다. 도 57은 본 개시에 따른 라인의 개통 동안에 전력 소비를 감소하기 위한 활성화 회로를 포함하는 다른 예시적인 메모리 칩을 도시한 것이다. 도 58은 본 개시에 따른 라인의 개통 동안에 전력 소비를 감소하기 위한 활성화 회로를 포함하는 또 다른 예시 적인 메모리 칩을 도시한 것이다. 도 59는 본 개시에 따른 라인의 개통 동안에 전력 소비를 감소하기 위한 활성화 회로를 포함하는 추가로 예시적 인 메모리 칩을 도시한 것이다. 도 60은 본 개시에 따른 라인의 개통 동안에 전력 소비를 감소하기 위한 글로벌 워드라인과 로컬 워드라인을 포 함하는 예시적인 메모리 칩을 도시한 것이다. 도 61은 본 개시에 따른 라인의 개통 동안에 전력 소비를 감소하기 위한 글로벌 워드라인과 로컬 워드라인을 포 함하는 다른 예시적인 메모리 칩을 도시한 것이다. 도 62는 본 개시에 따른 메모리 내에서 라인의 순차적 개통을 위한 프로세스의 예시적인 순서도이다. 도 63은 메모리 칩에 대한 종래의 검사기를 도시한 것이다. 도 64는 메모리 칩에 대한 다른 종래의 검사기를 도시한 것이다. 도 65는 본 개시에 따른 동일 기판 상의 논리 소자를 메모리로 사용하여 메모리 칩을 검사하는 예시를 도시한 것이다. 도 66은 본 개시에 따른 동일 기판 상의 논리 소자를 메모리로 사용하여 메모리 칩을 검사하는 다른 예시를 도 시한 것이다. 도 67은 본 개시에 따른 동일 기판 상의 논리 소자를 메모리로 사용하여 메모리 칩을 검사하는 또 다른 예시를 도시한 것이다. 도 68은 본 개시에 따른 동일 기판 상의 논리 소자를 메모리로 사용하여 메모리 칩을 검사하는 추가적인 예시를 도시한 것이다. 도 69는 본 개시에 따른 동일 기판 상의 논리 소자를 메모리로 사용하여 메모리 칩을 검사하는 다른 추가적인 예시를 도시한 것이다. 도 70은 본 개시에 따른 메모리 칩을 검사하기 위한 프로세스의 예시적인 순서도이다. 도 71은 본 개시에 따른 메모리 칩을 검사하기 위한 다른 프로세스의 예시적인 순서도이다."}
