{"patent_id": "10-2022-7010631", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0054395", "출원번호": "10-2022-7010631", "발명의 명칭": "상이한 어플리케이션 프로세스들에 대한 초기 데이터 분배", "출원인": "마이크론 테크놀로지, 인크.", "발명자": "유다노브, 드미트리"}}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "방법에 있어서,모바일 디바이스(mobile device)에서, 어플리케이션(application)의 복수의 프로세스들을 모니터링하는 단계(monitoring);상기 어플리케이션의 개시 동안 메모리에서 오브젝트(object)들 또는 컴포넌트(component)들의 배치를 결정하기위해 상기 복수의 프로세스들에 의해 사용되는 상기 오브젝트들 또는 컴포넌트들을 스코어링하는 단계(scoring); 및상기 어플리케이션의 개시 동안:제1 레벨(level)에서 스코어링된 상기 오브젝트들 또는 컴포넌트들을 적어도 부분적으로 상기 메모리의 제1 부분으로 로딩하는 단계(loading); 및제2 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들을 적어도 부분적으로 상기 메모리의 제2 부분으로로딩하는 단계를 포함하고, 여기서 상기 제2 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들은 상기 제1레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들보다 상기 어플리케이션에 대해 덜 중요한, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 어플리케이션의 상기 개시는 상기 어플리케이션에 대한 루트 프로세스(root process)를실행하는 단계를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 루트 프로세스는 상기 제1 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들의 로딩을 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 루트 프로세스는 상기 제2 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들의 로딩을 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서, 상기 메모리의 상기 제1 부분은 동적 랜덤 액세스 메모리(DRAM)를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서, 상기 메모리의 제2 부분은 비휘발성 랜덤 액세스 메모리(NVRAM)를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서, 상기 NVRAM은 3D XPoint 메모리를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 스코어 테이블(score table)에 상기 스코어링된 오브젝트들 또는 컴포넌트들의 대응하는 식별들 및 스코어들을 저장하는 단계를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서, 상기 스코어링은 머신 러닝(machine learning)에 적어도 부분적으로 기초하는, 방법.공개특허 10-2022-0054395-3-청구항 10 제9항에 있어서,상기 복수의 프로세스들의 상기 모니터링, 상기 오브젝트들 또는 컴포넌트들의 상기 스코어링, 및 상기 오브젝트들 또는 컴포넌트들의 상기 로딩을 반복하는 단계; 및상기 모니터링, 상기 스코어링 및 상기 로딩을 반복할 때마다, 상기 오브젝트들 또는 컴포넌트들의 상기 스코어링 중 적어도 일부를 훈련하는 단계를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서, 상기 스코어링은 인공 신경망(ANN)에 적어도 부분적으로 기초하고, 상기 훈련은 상기 ANN을훈련하는 것을 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1항에 있어서, 상기 어플리케이션의 개시 후에,사용량이 감소하거나 상기 제1 부분에 로딩된 상기 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제1 임계값을 넘어 감소할 것으로 예측되는 경우 상기 메모리의 상기 제1 부분으로부터 상기 메모리의 상기 제2 부분으로 상기 오브젝트들 또는 컴포넌트들 중 적어도 일부를 이동시키는 단계; 및사용량이 증가하거나 상기 제2 부분에 로딩된 상기 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제2 임계값을 넘어 증가할 것으로 예측되는 경우 상기 메모리의 제2 부분으로부터 상기 메모리의 상기 제1 부분으로상기 오브젝트들 또는 컴포넌트들의 적어도 일부를 이동시키는 단계를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서, 상기 어플리케이션의 개시 후에:사용량이 상기 제2 부분의 상기 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제3 임계값을 넘어 감소하는 경우 상기 메모리의 상기 제2 부분으로부터 상기 오브젝트들 또는 컴포넌트들의 적어도 일부를 제거하는 단계를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제1항에 있어서, 상기 어플리케이션의 상기 개시는 상기 어플리케이션의 이전 실행 패턴에 따라 초기 포인트로상기 어플리케이션에 대한 루트 프로세스를 실행하는 단계를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서,상기 모바일 디바이스의 사용자로부터 상기 어플리케이션의 시작 요청을 수신하는 단계; 및상기 어플리케이션의 시작 요청을 수신하는 것에 응답하여 그리고 상기 어플리케이션의 상기 루트 프로세스를사용함으로써 상기 모바일 디바이스에서 상기 어플리케이션을 시작하는 단계를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서, 상기 실행, 수신 또는 시작 중 적어도 하나는 상기 모바일 디바이스의 운영 체제(OS)에 의해수행되는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제15항에 있어서,상기 모바일 디바이스의 운영 체제(OS)에 의해 상기 어플리케이션의 상기 루트 프로세스를 다수의 프로세스들로분기하는 단계; 및상기 어플리케이션의 상기 시작 요청을 수신하는 것에 응답하여 그리고 상기 어플리케이션의 상기 시작 요청에공개특허 10-2022-0054395-4-따라 상기 다수의 프로세스들 중 적어도 하나를 사용함으로써 상기 모바일 디바이스에서 상기 어플리케이션을시작하는 단계를 포함하는, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서, 상기 다수의 프로세스들 중 적어도 일부는 상기 루트 프로세스와 상이한, 방법."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "컴퓨터 실행 가능 명령어로 유형적으로 인코딩된(tangibly encoded) 비일시적 컴퓨터 판독 가능 저장 매체로서,컴퓨팅 디바이스와 연관된 프로세서에 의해 실행될 때 방법을 수행하고, 상기 방법은:모바일 디바이스에서, 어플리케이션의 복수의 프로세스들을 모니터링하는 단계;상기 어플리케이션의 개시 동안 메모리에서 오브젝트들 또는 컴포넌트들의 배치를 결정하기 위해 상기 어플리케이션의 상기 개시 동안 상기 복수의 프로세스들에 의해 사용되는 상기 오브젝트들 또는 컴포넌트들을 스코어링하는 단계; 및상기 어플리케이션의 개시 동안:제1 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들을 상기 메모리의 제1 부분으로 로딩하는 단계; 및제2 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들을 상기 메모리의 제2 부분으로 로딩하는 단계를 포함하고, 여기서 상기 제2 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들은 상기 제1 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들보다 상기 어플리케이션의 개시에 대해 덜 중요한, 비일시적 컴퓨터 판독가능 저장 매체."}
{"patent_id": "10-2022-7010631", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "방법에 있어서,모바일 디바이스의 운영 체제(OS)에 의해 어플리케이션의 개시 동안 상기 어플리케이션의 복수의 프로세스들을모니터링하는 단계-여기서 상기 복수의 프로세스들의 상기 모니터링은 백그라운드 프로세스(backgroundprocess)임-;상기 어플리케이션의 개시 동안 메모리에서 오브젝트들 또는 컴포넌트들의 배치를 결정하기 위해 상기 어플리케이션의 상기 개시 동안 상기 복수의 프로세스들에 의해 사용된 상기 오브젝트들 또는 컴포넌트들을 스코어링하는 단계; 및상기 어플리케이션의 개시 동안:제1 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들을 상기 메모리의 제1 부분으로 로딩하는 단계; 및제2 레벨에서 스코어링된 상기 오브젝트들 또는 컴포넌트들을 상기 메모리의 제2 부분에 로딩하는 단계를 포함하고, 여기서 상기 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들은 상기 제1 레벨에서 스코어링된 상기오브젝트들 또는 컴포넌트들보다 상기 어플리케이션의 개시에 대해 덜 중요한, 방법."}
{"patent_id": "10-2022-7010631", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "모바일 디바이스에서, 초기 데이터 분배를 위해 어플리케이션의 프로세스들이 모니터링되고 스코어링될 수 있다. 구체적으로, 방법은 어플리케이션의 프로세스를 모니터링하는 단계, 및 어플리케이션의 개시 동안 메모리에 오브 젝트들 또는 컴포넌트들의 배치를 결정하기 위해 프로세스에 의해 사용되는 오브젝트들 또는 컴포넌트들을 스코 어링하는 단계를 포함할 수 있다. 방법은 또한 어플리케이션의 개시 동안, 메모리의 제1 부분으로, 적어도 부분 적으로, 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들을 로딩하는 단계를 포함할 수 있다. 방법은 또한 어플리케이션의 개시 동안, 메모리의 제2 부분으로, 적어도 부분적으로, 제2 레벨에서 스코어링된 오브젝트들 또 는 컴포넌트들을 로딩하는 단계를 포함할 수 있다. 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들은 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들보다 어플리케이션에 대해 덜 중요할 수 있다."}
{"patent_id": "10-2022-7010631", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "관련 출원 본 출원은 2019년 10월 3일에 출원되고 \"상이한 어플리케이션 프로세스들에 대한 초기 데이터 분배\"라는 명칭의 미국 특허 출원 번호 제16/592,547호에 대한 우선권을 주장하며, 이의 전체 개시 내용은 본 명세서에 참조로 포 함된다. 기술 분야 본 명세서에 개시된 적어도 일부 실시예는 컴퓨팅 시스템에 대한 루트 프로세스(root process) 및 컴퓨팅 디바 이스에서 상이한 어플리케이션 프로세스들에 대한 초기 데이터 분배에 관한 것이다."}
{"patent_id": "10-2022-7010631", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "ANDROID 운영 체제의 내부 작업(innerworking)는 모든 ANDROID 어플리케이션 프로세스의 상위(parent) 또는 루 트 프로세스 역할을 하는 접합자(zygote)를 포함한다. UNIX 및 UNIX와 유사한 운영 체제(예를 들어, LINUX 및 ANDROID)에서, 임의의 비-초기 프로세스(또는 0이 아닌 프로세스)는 운영 체제(OS)의 초기 또는 제로 프로세스 로부터 적어도 부분적으로 파생될 수 있다. 따라서 ANDROID OS에서 그의 루트 프로세스 또는 프로세스 0을 참조 하기 위해 \"접합자\"라는 용어를 사용한다. ANDROID는 GOOGLE에서 개발한 모바일 디바이스 용 모바일 OS이다. 이는 LINUX 커널 및 기타 오픈 소스 소프트웨 어의 수정된 버전을 기반으로 하며, 주로 모바일 디바이스(예를 들어, 스마트폰, 태블릿 등)용으로 설계되었다. GOOGLE은 또한 사물 인터넷(IoT)을 위한 ANDROID 버전을 개발하였다. 또한 TV 및 기타 가전 제품, 차량 내 정보 시스템, 웨어러블 스마트 디바이스, 게임 콘솔, 디지털 카메라 및 PC를 포함한 기타 유형의 전자 제품을 위해 ANDROID 버전이 개발되었다. ANDROID, UNIX 또는 UNIX와 유사한 다른 OS에 의한 비-제로 프로세스의 생성은 다른 프로세스가 \"fork()\"로 표 시되는 시스템 콜(call)을 실행할 때 발생하며, 이는 프로세스를 여러 프로세스들로 분기(forking)되는 것을 야 기한다. 분기를 콜한 프로세스는 상위 프로세스(parent process)이고 새로 생성된 프로세스는 하위 프로세스 (child process)이다. UNIX 또는 UNIX와 유사한 운영 체제에서 커널은 그의 프로세스 식별자, 예를 들어, 초기 또는 제로 프로세스의 경우 \"0\"으로 각 프로세스를 식별할 수 있다. UNIX 및 유사한 운영 체제에서 제로 프로세 스(즉, 프로세스 0)는 OS가 부팅될 때 생성되는 루트 프로세스이다. \"init\"로 알려진 제1 하위 프로세스(예를 들어, 프로세스 1)는 적어도 부분적으로 제로 프로세스에서 파생될 수 있으며 OS의 다른 모든 프로세스의 원형 (ancestor)이 될 수 있다."}
{"patent_id": "10-2022-7010631", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 명세서에 개시된 적어도 일부 실시예는 컴퓨팅 시스템에 대한 루트 프로세스(root process) 및 컴퓨팅 디바 이스의 상이한 어플리케이션 프로세스들에 대한 초기 데이터 분배에 관한 것이다. 본 명세서에 개시된 일부 실시예는 상이한 유형의 메모리(예를 들어, 동적 랜덤 액세스 메모리(DRAM), 비휘발성 랜덤 액세스 메모리(NVRAM), 3D XPoint 메모리 및 플래시 메모리)를 갖는 모바일 디바이스와 같은 컴퓨팅 디바 이스에 관한 것이다. 컴퓨팅 디바이스의 운영 체제는 오브젝트들 및 컴포넌트들이 메모리에서 초기에 배치되는 위치를 결정하기 위해 어플리케이션의 상이한 데이터 오브젝트들 및 컴포넌트들을 스코어링(scoring)할 수 있다. 오브젝트들 및 컴포넌트들은 컴퓨팅 디바이스의 상이한 유형의 메모리에 배치될 수 있으며 오브젝트들 및 컴포넌트들의 배치는 어플리케이션이 처음 시작될 때 발생할 수 있다. 초기 어플리케이션 프로세스(예를 들어, 어플리케이션의 루트 프로세스)는 실행을 위해 로딩 가능한 모듈 및 라 이브러리와 함께 실행 가능성을 가질 수 있다. 이러한 실행 가능하고 로딩 가능한 모듈 및 라이브러리는 어플리 케이션 프로세스 이전과 어플리케이션의 루트 프로세스 중에 어플리케이션 프로세스에 대한 메모리에 로딩될 수있다. 일부 컴포넌트(예를 들어, 정적 멤버)는 중요 경로에 있는 것으로 미리 결정되어 DRAM 또는 SRAM과 같은 고성능 메모리 유형에 로딩될 수 있다. 일부 컴포넌트는 프로세스 간 통신(IPC)를 위해 메모리 매핑된 공유 파일에 로 딩되도록 미리 결정되어 DRAM 또는 SRAM과 같은 고성능 메모리 유형에 로딩될 수 있다. 또한 더 중요한 프로세 스에 더 높은 성능의 메모리 유형을 명시적으로 할당되거나 더 중요한 프로세스에 더 높은 성능의 공유 메모리 영역을 명시적으로 할당될 수 있다(예를 들어, 익명 공유 메모리(Ashmem) 또는 그래픽 메모리 할당자(Gralloc) 를 통해). 상당한 크기의 일부 중요한 사용자 트리거 메모리 페이지는 디바이스의 고성능 메모리 유형으로 이동 할 수 있다. 중요한 구조(예를 들어, 어플리케이션 런타임 환경 및 시스템 호출과 관련된)는 디바이스의 고성능 메모리 유형에도 할당될 수 있다. 예를 들어 OS를 통해 컴퓨팅 디바이스는 실행 동안 각 어플리케이션에 대한 컴포넌트 및 오브젝트를 스코어링할 수 있고 스코어 테이블(이는 어플리케이션 자체의 일부일 수 있음)에 스코어를 저장할 수 있다. 사용자가 어플 리케이션을 여러 번 호출한 후 스코어링 프로세스(예를 들어, 카운팅, 훈련 및/또는 머신 러닝 프로세스를 통해 구현)를 사용하여 어플리케이션의 성능을 향상시킬 수 있다. 선택적으로, 컴퓨팅 디바이스는 초기 스코어 테이 블을 가짐으로써 어떤 오브젝트가 중요하고 어떤 것이 중요하지 않은지 식별할 수 있다. 어플리케이션 프로세스의 오브젝트는 기본적으로 프로세스들 간에 공유된다(예를 들어, 루트 프로세스 분기 후). 오브젝트에 대한 기록이 존재하는 경우(예를 들어, COW(copy-on-write) 트리거), 가장 가까운 장래에 덜 점유되거나 덜 점유될 것으로 예상되는 버스에 따라(예를 들어, DRAM 버스 또는 NVRAM 버스의 대역폭에 따라) 오브젝트 또는 오브젝트의 일부가 다른 메모리 유형 또는 동일한 메모리 유형으로 보관된 위치에서 이동 및/또 는 복사(예를 들어, NVRAM에서 DRAM으로 또는 DRAM에서 NVRAM으로 또는 DRAM에서 SRAM으로 이동 및/또는 복사) 될 수 있다. 컴포넌트 또는 오브젝트의 이동은 컴포넌트 또는 오브젝트(또는 해당 부분)가 얼마나 많이 사용될 것으로 예상되는지 또는 제거되기 전에 메모리에 얼마나 오래 남아 있는지에 따라 달라질 수 있다. 기대 최대화 알고리즘은 의미 있는 메트릭(예를 들어, 초당 프레임, 터치 렌더링 응답 시간 등)으로 측정된 예 상 사용자 경험을 최대화하는 동시에 다수의 메모리 유형들의 버스 용량 리소스를 최대화하지만 과도하게 제한 하지 않는 데 사용될 수 있다. 공유 오브젝트는 처음에 디바이스의 가장 높은 성능 유형의 메모리(예를 들어, DRAM)에 배치될 수 있으며 부분적으로는 해당 메모리 유형으로, 일부는 더 낮은 성능 유형의 메모리(예를 들어, NVRAM 또는 플래시 메모리)에 점진적으로 복사될 수 있다. 점진적인 복사는 COW에 의해 트리거링되는 바에 따라 부분적으로 이루어질 수 있다. 그리고 일정 시간이 지나면 가장 높은 성능 유형의 메모리에 있는 공유 오브젝트 의 부분(예를 들어, DRAM의 부분)은 자주 사용하지 않는 경우 더 낮은 성능 유형의 메모리(예를 들어, NVRAM 또 는 플래시 메모리)로 축출될 수 있다. 대안적으로 가장 높은 성능 유형의 메모리에 있는 부분을 전체적으로 더 낮은 성능 유형의 메모리에 직접 복사할 수 있고, 각 기록과 함께 다른 유형의 메모리 간에 부품을 앞뒤로 이동 할 수 있다. 운영 체제는 컴퓨팅 디바이스의 가장 높은 성능 유형의 메모리에 사용자 중요 작업 오브젝트 세트 (예를 들어, 포그라운드 어플리케이션 및/또는 백그라운드에서 실행 중인 프로세스에서 사용하되 오브젝트)를 유지하려고 할 수 있다. 다른 오브젝트는 여전히 고성능 유형의 메모리에 캐싱되어 있는 일부 중요한 부분과 함 께 컴퓨팅 디바이스의 더 낮은 성능 유형의 메모리로 마이그레이션될 수 있다. 본 명세서에 개시된 일부 실시예는 어플리케이션의 복수의 프로세스들을 모니터링하도록 구성된 하나 이상의 컴 퓨팅 디바이스의 OS 또는 하이퍼바이저 등에 관한 것이다. 모니터링은 단일 컴퓨팅 디바이스 또는 디바이스 그 룹에 대해 발생할 수 있다. OS, 하이퍼바이저 등은 어플리케이션의 개시 동안 메모리에서 오브젝트들 또는 컴포 넌트들의 배치를 결정하기 위해 복수의 프로세스들에 의해 사용되는 오브젝트들 또는 컴포넌트들을 스코어링하 도록 구성될 수 있다. 어플리케이션의 개시 동안, OS, 하이퍼바이저 등은 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들을 적 어도 부분적으로 메모리의 제1 부분에 로딩하도록 구성될 수 있다. 또한 어플리케이션을 시작하는 동안, OS, 하 이퍼바이저 등은 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들을 적어도 부분적으로 메모리의 제2 부분 에 로딩하도록 구성될 수 있으며, 여기서 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들은 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들보다 어플리케이션에 덜 중요하다. 메모리의 제1 부분은 DRAM을 포함할 수 있다. 메모리의 제2 부분은 NVRAM을 포함할 수 있다. NVRAM에는 3D XPoint 메모리가 포함될 수 있다. 어플리케이션의 개시는 어플리케이션에 대한 루트 프로세스의 실행을 포함할 수 있다. 적어도 부분적으로, OS, 하이퍼바이저 등은 어플리케이션에 대한 루트 프로세스를 실행하도록 구성될 수 있다. 루트 프로세스는 제1 레 벨에서 스코어링된 오브젝트들 또는 컴포넌트들의 로딩을 포함할 수 있고 및/또는 루트 프로세스는 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들의 로딩을 포함할 수 있다. 또한, 일부 실시예들에서, 어플리케이션의 개시는 어플리케이션들의 그룹으로부터의 어플리케이션의 개시를 포 함할 수 있고, 개시는 어플리케이션들의 그룹에 대한 루트 프로세스를 실행하는 것을 포함할 수 있다. 적어도 부분적으로, OS, 하이퍼바이저 등은 어플리케이션(또는 어플리케이션 그룹)에 대한 루트 프로세스를 실행하도록 구성될 수 있다. 루트 프로세스는 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들의 로딩을 포함할 수 및 /또는 루트 프로세스는 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들의 로딩을 포함할 수 있다. 일부 실시예에서, OS, 하이퍼바이저 등은 스코어 테이블에 스코어링된 오브젝트들 또는 컴포넌트들의 대응하는 식별들 및 스코어들을 저장하도록 구성될 수 있다. 또한 스코어링은 적어도 부분적으로 머신 러닝을 기반으로 할 수 있다. 그러한 실시예에서, OS, 하이퍼바이저 등은 복수의 프로세스들의 모니터링, 오브젝트들 또는 컴포 넌트들의 스코어링, 및 오브젝트들 또는 컴포넌트들의 로딩을 반복하도록 구성될 수 있다. 그리고, 모니터링, 스코어링 및 로딩의 각각의 반복으로, OS, 하이퍼바이저 등은 오브젝트들 또는 컴포넌트들의 스코어링의 적어도 일부를 훈련하도록 구성될 수 있다. 스코어링은 인공 신경망(ANN)에 적어도 부분적으로 기초할 수 있으며, 이러 한 예에서 훈련은 ANN 훈련을 포함할 수 있다. 일부 실시예에서, OS, 하이퍼바이저 등은 사용량이 감소하거나 제1 부분에 로딩된 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제1 임계값을 넘어 감소할 것으로 예측되는 경우 메모리의 제1 부분에서 메모리의 제2 부분으로 오브젝트들 또는 컴포넌트들의 적어도 일부를 이동시키도록 구성될 수 있다. 이러한 이동은 어플리케 이션을 개시한 후에 발생할 수 있다. 또한, OS, 하이퍼바이저 등은 사용량이 증가하거나 제2 부분에 로딩된 오 브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제2 임계값을 넘어 증가할 것으로 예측되는 경우 메모리의 제 2 부분에서 메모리의 제1 부분으로 오브젝트들 또는 컴포넌트들의 적어도 일부를 이동하도록 구성될 수 있다. 이러한 이동은 어플리케이션을 개시한 후에도 발생할 수 있다. 또한, 어플리케이션의 개시 후에, OS, 하이퍼바 이저 등은 사용량이 제2 부분의 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제3 임계값을 넘어 감소하 는 경우 메모리의 제2 부분으로부터 오브젝트들 또는 컴포넌트들의 적어도 일부를 제거하도록 구성될 수 있다. 일부 실시예에서, OS, 하이퍼바이저 등은 어플리케이션을 개시하도록 구성될 수 있고, 어플리케이션의 개시는 어플리케이션의 이전 실행 패턴에 따라 초기 포인트로 어플리케이션에 대한 루트 프로세스를 실행하는 OS, 하이 퍼바이저 등을 포함한다. 또한 OS, 하이퍼바이저 등은 어플리케이션이 어플리케이션 그룹의 일부일 때 어플리케 이션을 개시하도록 구성될 수 있으며, 어플리케이션의 개시는 어플리케이션(또는 어플리케이션 그룹)의 이전 실 행 패턴에 따라 초기 포인트로 어플리케이션의 루트 프로세스를 실행(또는 어플리케이션 그룹에 대한 루트 프로 세스 실행)하는 OS, 하이퍼바이저 등을 포함한다. 또한, OS, 하이퍼바이저 등은 어플리케이션 시작 요청을 수신 하는 것에 응답하여 그리고 어플리케이션의 루트 프로세스를 사용함으로써(또는 어플리케이션 그룹의 루트 프로 세스를 사용함으로써) 컴퓨팅 디바이스(들)의 사용자로부터 어플리케이션을 시작하라는 요청을 수신할 뿐만 아 니라 컴퓨팅 디바이스(들)에서 어플리케이션을 시작하도록 구성될 수 있다. 일부 실시예에서, OS, 하이퍼바이저 등은 어플리케이션의 루트 프로세스(또는 어플리케이션 그룹의 루트 프로세 스)를 다중 프로세스들로 분기하도록 구성될 수 있다. 이러한 실시예에서, OS, 하이퍼바이저 등은 어플리케이션 시작 요청을 수신하는 것에 응답하여 그리고 어플리케이션 시작 요청에 따라 다중 프로세스들 중 적어도 하나를 사용함으로써 컴퓨팅 디바이스(들)에서 어플리케이션을 시작하도록 구성될 수 있다. 다중 프로세스들 중 적어도 일부는 서로 및/또는 루트 프로세스와 다를 수 있다. 또한, 다중 프로세스들 중 적어도 일부는 초기에 서로 및/ 또는 루트 프로세스와 동일할 수 있다. 어플리케이션(또는 어플리케이션 그룹)에 대한 루트 프로세스는 OS, 하이퍼바이저 등을 시작할 때 런칭될 수 있 다. 일부 실시예에서, 어플리케이션의 루트 프로세스(또는 어플리케이션 그룹의 루트 프로세스)는 어플리케이션 이 일정 시간 내에 사용되지 않거나 어플리케이션이 CPU, GPU, 메모리 또는 기타 리소스와 같은 시스템 리소스 를 너무 많이 사용하는 경우 종료될(killed) 수 있다. 그러한 실시예에서, 어플리케이션의 사용을 예상하여, OS, 하이퍼바이저 등은 어플리케이션 모니터링에서 식별된 패턴에 따라 루트 프로세스를 재 런칭하도록 구성될 수 있다. 패턴에 대한 선호도(preference)는 패턴의 수량, 빈도 및/또는 최신성을 기반으로 할 수 있으며 어플 리케이션에 대한 임의의 유형의 메모리 액세스 패턴이 모니터링되고 추적될 수 있다. 모니터링 및 추적은 특수 레지스터(예를 들어, 모델별 레지스터) 판독 및 기록을 통해 OS를 통해 이용 가능한 하드웨어 및 소프트웨어 성 능 카운터를 포함할 수 있다. 패턴은 메트릭, 예를 들어 메모리로부터의 판독, 메모리에 대한 기록의 양, 빈도 및/또는 최신성, 물리적 메모리 공간의 어드레스 패턴, 가상 공간의 어드레스 패턴, 데이터의 지역성(공간적 및 /또는 시간적), 뱅크 충돌 또는 명령어당 CPU 사이클을 기반으로 할 수 있다. 패턴은 또한 메트릭, 예를 들어TLB(translation lookaside buffer) 메트릭의 양, 빈도 및/또는 최신성 및 OS에 대해 이용 가능한 기타 메트릭 에 기초할 수 있다. 일부 실시예에서, 어플리케이션이 컴퓨팅 디바이스(모바일 디바이스와 같은)에 설치된 후, 디바이스의 OS 또는 연관된 하이퍼바이저는 어플리케이션을 사전 런칭하여 사용자에게 맞춤화된 루트 어플리케이션 프로세스를 생성 할 수 있다. 사전 런칭은 사용자가 어플리케이션을 시작하기 위해 컴퓨팅 디바이스를 요청하기 전에 발생할 수 있다. 어플리케이션은 OS 또는 하이퍼바이저 등을 통해 적어도 부분적으로 실행될 수 있다. 따라서 어플리케이 션의 사전 런칭 프로세스 또는 루트 프로세스는 OS의 루트 프로세스와 다르다. 그러한 실시예에서, OS 또는 하 이퍼바이저 등은 어플리케이션의 루트 프로세스를 설정하기 위해 데이터를 이동 및/또는 복사될 수 있다. 일부 실시예에서, 데이터의 복사 및/또는 이동은 초기에 OS의 루트 프로세스에 의해 수행될 수 있다. 이는 예를 들어 어플리케이션의 루트 프로세스에 의해 어플리케이션에 대한 초기 판독 또는 기록 전에 발생할 수 있다. 일부 실 시예에서, 공통 코드 및 판독 전용 데이터(예를 들어, 라이브러리, 런타임, 드라이버, 메모리 페이지)는 OS의 루트 프로세스 또는 어플리케이션의 개별 루트 프로세스에 의해 복사 및/또는 이동되지 않는다. 일부 실시예에 서, 루트 프로세스의 코드 및 데이터는 루트 프로세스, 다른 프로세스 또는 OS에 의한 코드 및 데이터의 초기 수정까지 복사되지 않는다. 일부 실시예에서, 코드 및 데이터의 수정된 부분만이 복사되고, 그러나 수정되지 않 은 부분은 공통으로 유지된다. 일부 실시예에서 이러한 부분은 메모리 페이지, 캐시 라인 또는 파일 시스템 섹 터 또는 컴퓨터 판독 가능 저장 매체의 다른 요소에 대한 기록을 모니터링함으로써 식별될 수 있다. 초기 판독 및 기록은 특히 어플리케이션 또는 어플리케이션을 포함하는 어플리케이션 그룹에 대해 개별 루트 프 로세스를 통해 사용되기 위해 메모리에 저장되거나 캐싱될 수 있다. 일부 실시예에서, 저장 또는 캐싱은 초기 판독 및 기록을 가속화하기 위해 더 빠른 메모리에서 수행될 수 있다. 초기 판독 및 기록은 사용 빈도, 사용 최 신성 등에 따라 메모리를 통해 OS, 하이퍼바이저 등에 의해 관리, 유지, 우선 순위 지정 등을 할 수 있다. 컴퓨팅 디바이스(예를 들어, 모바일 디바이스)는 어플리케이션의 루트 프로세스(또는 어플리케이션 그룹의 루트 프로세스)에 추가할 초기 판독 및 기록을 결정하기 위해 사용자에 의한 어플리케이션의 빈번한 또는 최근 사용 을 모니터링할 수 있다. 이는 OS, 하이퍼바이저 등이 어플리케이션에 대한 메모리로부터 판독하고 및/또는 그에 대해 기록하게 할 수 있다. 초기 기록의 결과로 데이터 이동 및/또는 복사는 사용자가 OS, 하이퍼바이저 등에 어플리케이션 시작을 요청하기 전에 수행될 수도 있다. OS, 하이퍼바이저 등이 시스템 레벨 루트 프로세스를 분기한 후, 어플리케이션에 대해 예측된 초기 판독 및/또 는 기록을 사용하여 어플리케이션의 루트 프로세스 또는 그룹의 루트 프로세스를 맞춤화할 수 있다. 이러한 예 에서, 어플리케이션 또는 그룹의 맞춤형 루트 프로세스는 어플리케이션의 빠른 시작을 위해 영구 비휘발성 메모 리(예를 들어, 플래시 메모리 및/또는 NVRAM)에 저장될 수 있다. 사용자가 OS, 하이퍼바이저 등에 어플리케이션 시작을 요청할 때, OS, 하이퍼바이저 등은 어플리케이션 또는 어 플리케이션 그룹의 사전 런칭 프로세스(즉, 어플리케이션 또는 어플리케이션 그룹의 루트 프로세스)를 사용하거 나 사전 런칭 프로세스에서 분기된 프로세스를 사용하여 사용자에게 서비스를 제공할 수 있다. 어플리케이션의 루트 프로세스 또는 어플리케이션 그룹의 루트 프로세스에서 분기된 프로세스는 상위 루트 프로세스와 유사하거 나 다를 수 있다. 또한 사용자가 어플리케이션을 종료하면 OS는 어플리케이션의 활성 프로세스 및/또는 어플리케이션 또는 어플리 케이션 그룹의 루트 프로세스를 완전히 또는 부분적으로 종료할 수 있다. 사용자가 어플리케이션을 실행할 것을 예상하여 OS, 하이퍼바이저 등이 어플리케이션 또는 어플리케이션 그룹의 루트 프로세스를 다시 런칭할 수 있으 며, 이는 어플리케이션의 가장 최근 및/또는 빈번한 사용자 사용 패턴을 기반으로 추가로 맞춤화될 수 있다. 도 1, 4 및 6은 본 개시내용의 일부 실시예에 따른, 상이한 어플리케이션 프로세스들에 대한 초기 데이터 분배 를 구현할 수 있는 예시적인 모바일 디바이스를 도시한다. 또한, 도 4 및 도 6에 도시된 바와 같이, 모바 일 디바이스는 본 개시의 일부 실시예에 따라 다수의 어플리케이션들에 대한 개별 루트 프로세스들을 포함 하고 운영할 수 있다. 본 개시의 목적을 위해, 도 1, 4 및 6이 어플리케이션당 루트 프로세스를 언급하지만, 그 러한 어플리케이션은 어플리케이션들의 그룹의 일부일 수 있고 루트 프로세스는 어플리케이션들의 그룹에 대한 루트 프로세스일 수 있다는 것을 이해해야 한다. 도 2, 3, 5, 7 및 8은 본 개시내용의 일부 실시예에 따른 도 1, 4 및 6에 도시된 모바일 디바이스에 의해 수행될 수 있는 예시적인 방법들(200, 300, 500, 700 및 800)의 흐름도이다. 구체적으로, 도 1은 적어도 메모리를 포함하는 모바일 디바이스를 도시한다. 도 1은 또한 개별 메모 리 부분들을 포함하는 메모리를 도시한다(예를 들어, 제1 메모리 부분(106a), 제2 메모리 부분(106b), 및 N 번째 메모리 부분(106c) 참조). 개별 메모리 부분들의 각각은 대응하는 레벨의 오브젝트 및/또는 컴포넌트를 포함할 수 있다(예를 들어, 제1 레벨 오브젝트 또는 컴포넌트(108a), 제2 레벨 오브젝트 또는 컴포넌트(108b), 및 N번째 레벨 오브젝트 또는 컴포넌트(108c) 참조). 대응하는 레벨은 어플리케이션 실행에 대한 중요도 (importance) 또는 임계도(criticality)와 연관될 수 있다. 다시 말해서, 개별 메모리 부분들의 각각은 어플리 케이션 실행에 대한 오브젝트들 및/또는 컴포넌트들의 중요도 또는 임계도와 관련된 대응하는 레벨의 오브젝트 들 및/또는 컴포넌트들을 포함할 수 있다. 또한, 모바일 디바이스의 메모리의 오브젝트들 및/또는 컴 포넌트들의 대응하는 수의 레벨들에 대해 2개 초과(또는 3개 초과)의 메모리 부분들이 존재할 수 있다는 것이 예시에 의해 이해되어야 한다. 모바일 디바이스의 OS, 또는 모바일 디바이스에 있거나 그와 통신적으로 결합된 하이퍼바이저 등은 모바일 디바이스에 포함되고 모바일 디바이스에서 운영 가능한 어플리케이션의 복수의 프로세스들을 모니터링하도록 구 성될 수 있다. OS, 하이퍼바이저 등은 어플리케이션의 개시 동안 메모리(예를 들어, 메모리 참조)에서 오 브젝트들 또는 컴포넌트들의 배치(placement)를 결정하기 위해 복수의 프로세스들에 의해 사용되는 오브젝트들 또는 컴포넌트들(예를 들어, 제1 레벨 오브젝트들 또는 컴포넌트들(108a), 제2 레벨 오브젝트들 또는 컴포넌트 들(108b), 및 N 번째 레벨 오브젝트들 또는 컴포넌트들(108c) 참조)을 스코어링하도록 구성될 수 있다. 어플리 케이션을 개시하는 동안 OS, 하이퍼바이저 등은 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들(예를 들 어, 제1 레벨 오브젝트들 또는 컴포넌트들(108a) 참조)을 적어도 부분적으로 메모리의 제1 부분(예를 들어, 제1 메모리 부분(106a) 참조)에 로딩하도록 구성될 수 있다. 또한 어플리케이션을 개시하는 동안 OS, 하이퍼바이저 등은 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들(예를 들어, 제2 레벨 오브젝트들 또는 컴포넌트들 (108b) 참조)을 적어도 부분적으로 메모리의 제2 부분(예를 들어, 제2 메모리 부분(106b) 참조)에 로딩하도록 구성될 수 있다. 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들은 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들보다 어플리케이션에 덜 중요할 수 있다. 메모리 부분들의 각각은 하나 이상의 유형의 메모리로 구성될 수 있다. 그리고, 메모리 부분들의 각각은 서로 다른 기능 또는 트레이드오프(tradeoff)를 제공할 수 있다. 예를 들어, 제1 메모리 부분(106a) 또는 가장 높은 메모리 부분은 메모리의 개별 부분들의 판독 및 기록 속도와 관련하여 가장 높은 성능을 제공할 수 있다. 제2 메모리 부분(106b), 또는 제2로 높은 메모리 부분은 메모리의 개별 부분들의 판독 및 기록 속도와 관련하여 제2 로 가장 높은 성능을 제공할 수 있다. 가장 낮은 메모리 부분(예를 들어, N번째 메모리 부분(106c) 참조)은 메 모리의 개별 부분들의 판독 및 기록 속도와 관련하여 가장 낮은 성능을 제공할 수 있다. 그러나 트레이드오프로 가장 낮은 메모리 부분이 가장 큰 메모리 용량, 데이터 신뢰성, 유효성 또는 지속성을 제공할 수 있다. 이러한 기능을 제공하기 위해, 제1 메모리 부분(106a) 또는 가장 높은 메모리 부분은 DRAM 또는 SRAM, 또는 NVRAM과 DRAM의 조합을 포함할 수 있다. 또한, 이러한 예에서, 제2 메모리 부분(106b), 또는 제2로 높은 메모리 부분은 NVRAM, 또는 DRAM, NVRAM, 및/또는 플래시 메모리의 조합을 포함할 수 있다. 그리고, 그러한 예에서, 가장 낮은 메모리 부분(예를 들어, N번째 메모리 부분(106c) 참조)은 플래시 메모리, 또는 NVRAM 및/또는 플래시 메모리의 조합을 포함할 수 있다. 본 명세서에 개시된 모든 예에서 NVRAM은 3D XPoint 메모리를 포함할 수 있다. 어플리케이션(예를 들어, 도 4에 도시된 어플리케이션들(406a, 406b, 406c) 참조)의 개시는 어플리케이션에 대 한 루트 프로세스(예를 들어, 도 4에 도시된 루트 프로세스들(408, 412 및 416) 참조)를 실행하는 것을 포함할 수 있다. 적어도 부분적으로, OS, 하이퍼바이저 등은 어플리케이션에 대한 루트 프로세스를 실행하도록 구성될 수 있다. 루트 프로세스는 하나 이상의 레벨들에서 스코어링된 오브젝트들 또는 컴포넌트들의 로딩을 포함할 수 있다. 예를 들어, 루트 프로세스는 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들(예를 들어, 제1 레벨 오브젝트 또는 컴포넌트들(108a) 참조)의 로딩을 포함할 수 있고 및/또는 루트 프로세스는 제2 레벨에서 스코어 링된 오브젝트들 또는 컴포넌트들(예를 들어, 제2 레벨 오브젝트들 또는 컴포넌트들(108b) 참조)의 로딩을 포함 할 수 있다. 일부 실시예에서, OS, 하이퍼바이저 등은 스코어 테이블(예를 들어, 도 1에 도시된 스코어 테이블 참조)에 스코어링된 오브젝트들 또는 컴포넌트들(예를 들어, 제1 레벨 오브젝트들 또는 컴포넌트들(108a), 제2 레벨 오 브젝트들 또는 컴포넌트(108b), 및 N번째 레벨 오브젝트들 또는 컴포넌트들(108c) 참조)의 대응하는 식별들 및 스코어들을 저장하도록 구성될 수 있다. 일부 실시예에서, 스코어 테이블은 모바일 디바이스의 OS의 어플리케이션 바이너리 파일(application binary file)의 일부일 수 있다. 그러한 실시예에서, 스코어 테이블은 사용자가 모바일 디바이스의 OS를 업데이트할 때마다 사용자에게 이용 가능할 수 있다. 또한, 스코어 테이블은 클라우드를 통해 사용자의 다른 디바이스와 동기화될 수 있다. 또한 스코어링은 적어도 부분적으로 머신 러닝을 기반으로 할 수 있다. 그러한 실시예에서, OS, 하이퍼바이저 등은 복수의 프로세스들의 모니터링, 오브젝트들 또는 컴포넌트들의 스코어링, 및 오브젝트들 또는 컴포넌트들 의 로딩을 반복하도록 구성될 수 있다. 그리고, 모니터링, 스코어링 및 로딩의 각각의 반복으로, OS, 하이퍼바 이저 등은 오브젝트들 또는 컴포넌트들의 스코어링의 적어도 일부를 훈련하도록 구성될 수 있다. 스코어링은 적 어도 부분적으로 ANN을 기반으로 할 수 있으며 이러한 예에서 훈련은 ANN의 훈련을 포함할 수 있다. 일부 실시예에서, OS, 하이퍼바이저 등은 사용량이 감소하거나 제1 부분에 로딩된 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제1 임계값을 넘어 감소할 것으로 예측되는 경우 메모리의 제1 부분으로부터 메모리의 제2 부분으로 오브젝트들 또는 컴포넌트들의 적어도 일부를 이동시키도록 구성될 수 있다(예를 들어, 제1 메모 리 부분(106a)의 오브젝트들 또는 컴포넌트들은 사용량이 감소하거나 제1 메모리 부분(106a)에 로딩된 오브젝트 들 또는 컴포넌트들 중 적어도 일부에 대한 제1 임계값을 넘어 감소할 것으로 예측되는 경우 제2 메모리 부분 (106b)으로 이동될 수 있다). 이러한 이동은 어플리케이션의 개시 이후에 발생할 수 있다. 또한, OS, 하이퍼바 이저 등은 사용량이 증가하거나 제2 부분에 로딩된 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제2 임 계값을 초과하여 증가할 것으로 예측되는 경우 메모리의 제2 부분에서 메모리의 제1 부분으로 오브젝트들 또는 컴포넌트들의 적어도 일부를 이동시키도록 구성될 수 있다(예를 들어, 제2 메모리 부분(106b)의 오브젝트들 또 는 컴포넌트들은 사용량이 증가하거나 제2 메모리 부분(106b)에 로딩된 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제2 임계값을 초과하여 증가할 것으로 예측되는 경우 제1 메모리 부분(106a)으로 이동될 수 있다). 이러한 이동은 어플리케이션의 개시 후에도 발생할 수 있다. 또한 어플리케이션의 개시 이후에, OS, 하이퍼바이 저 등은 실시예에 따른 메모리의 제2 부분, 낮은 부분, 또는 가장 낮은 부분의 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 사용량이 제3 임계값을 넘어 감소할 때 메모리의 제2 부분 또는 메모리의 더 낮은 또는 가 장 낮은 부분(예를 들어, N번째 메모리 부분(106c) 참조)으로부터 오브젝트들 또는 컴포넌트들의 적어도 일부를 제거하도록 구성될 수 있다. 구체적으로, 도 2는 도 1에 도시된 모바일 디바이스 또는 모바일 디바이스와 유사하게 구성된 다른 유형의 컴퓨팅 디바이스에 의해 수행될 수 있는 방법의 동작을 도시한다. 또한, 일부 실시예에서, 방법 은 일반적으로 컴퓨팅 디바이스의 OS 또는 모바일 디바이스의 OS에 의해 적어도 부분적으로 수행될 수 있 다. 방법은 또한 하이퍼바이저 및/또는 하나 이상의 운영 체제에 의해 적어도 부분적으로 수행될 수 있다. 도 2에서, 방법은 어플리케이션의 복수의 프로세스들을 모니터링하는 단계에서 시작한다. 예를 들어, 단계는 컴퓨팅 디바이스(모바일 디바이스와 같은)에서 어플리케이션의 복수의 프로세스들을 모니터링하는 것을 포함할 수 있다. 단계에서, 방법은 어플리케이션의 개시 동안 메모리에서 오브젝트들 또는 컴포넌트들의 배치를 결정 하기 위해 복수의 프로세스들에 의해 사용되는 오브젝트들 또는 컴포넌트들을 스코어링하는 것으로 계속된다. 예를 들어, 단계는 컴퓨팅 디바이스에서, 어플리케이션의 개시 동안 메모리에서 오브젝트들 또는 컴포넌트 들의 배치를 결정하기 위해 복수의 프로세스들에 의해 사용되는 오브젝트들 또는 컴포넌트들을 스코어링하는 것 을 포함할 수 있다. 단계에서의 스코어링은 머신 러닝에 적어도 부분적으로 기초할 수 있다. 그러한 실시예에서, OS, 하이퍼바 이저 등은 복수의 프로세스들의 모니터링, 오브젝트들 또는 컴포넌트들의 스코어링, 및 오브젝트들 또는 컴포넌 트들의 로딩을 반복하도록 구성될 수 있다. 그리고, 모니터링, 스코어링, 및 로딩의 각각의 반복으로, OS, 하이 퍼바이저 등은 오브젝트들 또는 컴포넌트들의 스코어링의 적어도 일부를 훈련하도록 구성될 수 있다(예를 들어, 방법의 단계 참조). 단계에서의 스코어링은 ANN에 적어도 부분적으로 기초할 수 있고, 이러한 예에서 훈련은 단계에서 ANN을 훈련하는 것을 포함할 수 있다. 단계에서, 방법은 스코어 테이블에 스코어링된 오브젝트들 또는 컴포넌트들의 대응하는 식별들 및 스 코어들을 저장하는 것을 계속한다. 예를 들어, 단계는 스코어링된 오브젝트들 또는 컴포넌트들의 대응하는 식별들 및 스코어들을 저장하는 것을 포함할 수 있고, 저장은 컴퓨팅 디바이스의 메모리에 구현된 스코어 테이 블에서 발생할 수 있다(예를 들어, 모바일 디바이스의 메모리에 구현된 스코어 테이블에서). 단계에서, 방법은 어플리케이션 개시로 계속된다. 어플리케이션의 개시는 어플리케이션에 대한 루트 프로 세스를 실행하는 것을 포함할 수 있다. 루트 프로세스는 제1 레벨(예를 들어, 가장 높은 중요 레벨) 및/또는 제 2 레벨(예를 들어, 가장 높은 중요 레벨보다 낮은 레벨)에서 스코어링된 오브젝트들 또는 컴포넌트들의 로딩을포함할 수 있다. 일부 실시예에서, 단계에서의 모니터링 및 단계에서의 스코어링은 단계에서 어 플리케이션 개시의 일부일 수 있다(도시되지 않음). 어플리케이션을 개시하는 동안, 방법은 단계에서 어플리케이션에 대한 루트 프로세스를 실행하는 것으로 계속된다. 또한 어플리케이션을 개시하는 동안 방법은 단계에서 스코어링된 오브젝트들 또는 컴포넌트들의 스코어에 따라 스코어링된 오브젝트들 또는 컴포넌트들을 적어도 부분적으로 메모리의 부분으로 로딩하는 것으 로 계속된다. 제2 레벨에서 단계에서 스코어링된 오브젝트들 또는 컴포넌트들은 제1 레벨에서 단계에 서 스코어링된 오브젝트들 또는 컴포넌트들보다 어플리케이션에 대해 덜 중요할 수 있다. 일부 실시예에서, 예를 들어, 단계에서, 방법은 루트 프로세스를 통해 제1 레벨(예를 들어, 가장 높 은 중요 레벨)에서 스코어링된 오브젝트들 또는 컴포넌트들의 로딩을 포함할 수 있다. 또한, 단계에서, 방 법은 루트 프로세스를 통해 제2 레벨(예를 들어, 가장 높은 중요 레벨보다 낮은)에서 스코어링된 오브젝트 들 또는 컴포넌트들의 로딩을 포함할 수 있다. 일부 실시예에서, 예를 들어, 단계에서, 방법은 메모리의 제1 부분(예를 들어, 메모리의 가장 높은 성능 레벨 부분)에 제1 레벨(예를 들어, 가장 높은 중요 레벨)에서 스코어링된 오브젝트들 또는 컴포넌트들을 적어도 부분적으로 로딩하는 것을 포함할 수 있다. 또한, 단계에서, 방법은 메모리의 제2 부분(예를 들어, 메모리의 가장 높은 성능 레벨보다 낮은 부분)에 제2 레벨(예를 들어, 가장 높은 중요 레벨보다 낮음)에 서 스코어링된 오브젝트들 또는 컴포넌트들을 적어도 부분적으로 로딩하는 단계를 포함할 수 있다. 메모리의 제 1 부분과 메모리의 제2 부분은 상이한 기능이나 트레이드오프를 가질 수 있는 하나 이상의 유형의 메모리로 만 들어질 수 있다. 예를 들어, 제1 부분은 메모리의 개별 부분들의 판독 및 기록 속도와 관련하여 최고 성능을 제 공할 수 있다. 제2 부분은 메모리의 개별 부분들의 판독 및 기록 속도와 관련하여 제2로 높은 성능을 제공할 수 있다. 그러나 트레이드오프로서 제2 부분은 제1 부분에 비해 더 큰 메모리 용량, 데이터 신뢰성, 유효성 또는 지속성을 제공할 수 있다. 예를 들어, 일부 실시예에서, 메모리의 제1 부분은 DRAM을 포함할 수 있고 메모리의 제2 부분은 NVRAM을 포함할 수 있다. NVRAM에는 3D XPoint 메모리가 포함될 수 있다. 도 2에 도시된 바와 같이, 방법은 단계에서 어플리케이션의 개시 후에 자체적으로 반복될 수 있다. 예를 들어, 방법은 복수의 프로세스들의 모니터링, 오브젝트들 또는 컴포넌트들의 스코어링, 및 어플리케 이션의 개시 동안 오브젝트들 또는 컴포넌트들의 로딩을 반복하는 것을 포함할 수 있다. 단계에서, 방법 은 단계들(202 내지 212)의 각각의 반복과 함께, 단계에서 오브젝트들 또는 컴포넌트들의 스코어링의 적어도 일부를 훈련하는 것으로 계속된다. 예를 들어, 모니터링, 스코어링 및 로딩의 각각의 반복과 함께, 단계 에서 방법은 오브젝트들 또는 컴포넌트들의 스코어링의 적어도 일부를 계속 훈련할 수 있다. 일부 실시예 에서, 단계에서의 스코어링은 ANN에 적어도 부분적으로 기초할 수 있고, 훈련은 단계에서 ANN을 훈련 하는 것을 포함할 수 있다. 일부 실시예에서, 적어도 일부 단계들의 반복은 다른 단계와 동시에 수행될 수 있다. 예를 들어, 단계는 그 자체를 연속적으로 반복하는 것으로 구현될 수 있고 그 출력 데이터를 계속해 서 자체적으로 반복하는 것으로서 구현되는 단계로 스트리밍할 수 있다. 이러한 실시예의 결과로서 방법 은 지속되는 실행 파이프라인으로서 구현될 수 있다. 구체적으로, 도 3은 도 1에 도시된 모바일 디바이스 또는 모바일 디바이스와 유사하게 구성된 다른 유형의 컴퓨팅 디바이스에 의해 수행될 수 있는 방법의 동작을 예시한다. 또한, 일부 실시예에서, 방법 은 일반적으로 컴퓨팅 디바이스의 OS 또는 모바일 디바이스의 OS에 의해 적어도 부분적으로 수행될 수 있 다. 방법은 또한 하이퍼바이저 및/또는 하나 이상의 운영 체제에 의해 적어도 부분적으로 수행될 수 있다. 도 3에서, 방법은 방법의 단계에서 시작하여 어플리케이션의 복수의 프로세스들을 모니터링한다. 그 다음, 방법의 단계에서, 방법은 어플리케이션의 개시 동안 메모리에서 오브젝 트들 또는 컴포넌트들의 배치를 결정하기 위해 복수의 프로세스들에 의해 사용되는 오브젝트들 또는 컴포넌트들 을 스코어링하는 것으로 계속된다. 그 다음, 방법의 단계에서, 방법은 스코어링 테이블에 스코 어링된 오브젝트들 또는 컴포넌트들의 대응하는 식별들 및 스코어들을 저장하는 것으로 계속된다. 그 다음, 방 법의 단계에서, 방법은 어플리케이션의 개시로 계속된다. 어플리케이션의 개시 동안, 방법(30 0)은 또한 단계에서 어플리케이션에 대한 루트 프로세스를 실행하는 것으로 계속된다. 또한, 어플리케이션 의 개시 동안, 방법은 단계에서 스코어링된 오브젝트들 또는 컴포넌트들의 스코어에 따라 스코어링된 오브젝트들 또는 컴포넌트들을 적어도 부분적으로 메모리의 일부로 로딩하는 것으로 계속된다. 단계에서, 방법은 사용량이 감소하거나 더 높은 부분에 로딩된 오브젝트들 또는 컴포넌트들 중 적어 도 일부에 대한 임계값을 초과하여 감소할 것으로 예상되는 경우 메모리의 더 높은 부분으로부터 메모리의 더낮은 부분으로 오브젝트들 또는 컴포넌트들의 적어도 일부를 이동시키는 것으로 계속된다. 단계에서, 방법 은 사용량이 증가하거나 너 낮은 부분에 로딩된 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 임계 값을 초과하여 증가할 것으로 예상되는 경우 메모리의 더 낮은 부분에서 메모리의 더 높은 부분으로 오브젝트들 또는 컴포넌트들의 적어도 일부를 이동시키는 것으로 계속된다. 단계에서, 방법은 사용량이 더 낮은 부분의 오브젝트들 또는 컴포넌트들 중 적어도 일부에 대한 제2 임계값을 초과하여 감소할 때 단계에서 언 급된 메모리의 더 낮은 부분으로부터 오브젝트들 또는 컴포넌트들의 적어도 일부를 제거하는 것으로 계속된다. 단계에서, 방법은 단계들(202 내지 212) 및 단계들(302 내지 306)의 각각의 반복으로 단계에서 오브젝트들 또는 컴포넌트들의 스코어링의 적어도 일부를 훈련하는 것으로 계속된다. 적어도 일부 단계들의 반 복은 다른 단계와 동시에 수행될 수 있음을 이해해야 한다. 예를 들어, 단계들(302 및 304)이 연속적으로 반복 되는 등의 방식으로 구현될 수 있다. 이러한 실시예의 결과로서 방법은 지속되는 실행 파이프라인으로서 구현될 수 있다. 본 명세서에 개시된 일부 실시예는, 예를 들어, 모바일 디바이스 및 도 1에 도시된 메모리의 다른 부분들 (106a, 106b, 106c)을 참조하면, 상이한 유형의 메모리(예를 들어, DRAM, NVRAM, 3D XPoint 메모리 및 플래시 메모리)를 갖는 모바일 디바이스와 같은 컴퓨팅 디바이스에 관한 것이다. 컴퓨팅 디바이스의 운영 체제 또는 장 치의 다른 시스템은, 예를 들어 도 2 및 3에 도시된 단계를 참조하면, 어플리케이션의 상이한 데이터 오브 젝트들 및 컴포넌트들(예를 들어, 도 1에 도시된 오브젝트들 또는 컴포넌트들(108a, 108b, 108c) 참조)을 스코 어링하여 오브젝트들 및 컴포넌트들이 메모리에서 초기에 배치되는 위치를 결정할 수 있다. 예를 들어, 도 2 및 3에 도시된 단계들(208 내지 212)을 참조하면 오브젝트들과 컴포넌트들은 컴퓨팅 디바이스의 상이한 유형의 메 모리에 배치될 수 있고, 어플리케이션이 처음 개시될 때 오브젝트들 및 컴포넌트들의 배치가 발생할 수 있다. 초기 어플리케이션 프로세스(예를 들어, 어플리케이션의 루트 프로세스)는 실행을 위해 로딩 가능한 모듈들 및 라이브러리들과 함께 실행 가능성(executables)을 가질 수 있다. 예를 들어, 도 2 및 3에 도시된 단계들(208 내 지 212)을 참조하면 이러한 실행 가능한 및 로딩 가능한 모듈들 및 라이브러리들은 어플리케이션 프로세스 이전 과 어플리케이션의 루트 프로세스 중에 어플리케이션 프로세스에 대한 메모리에 로딩될 수 있다. 일부 컴포넌트들(예를 들어, 정적 멤버들)은 종료 경로에 있는 것으로 미리 결정되어 DRAM과 같은 고성능 메모 리 유형에 로딩될 수 있으며, 예를 들어, 이는 각각 단계들(204 및 212)에 포함될 수 있다. 일부 컴포넌트들은 프로세스 간 통신(IPC)를 위해 메모리 매핑된 공유 파일에 로딩되도록 미리 결정되어 DRAM과 같은 고성능 메모 리 유형에 로딩될 수 있으며, 예를 들어, 이는 각각 단계들(204 및 212)에 포함될 수 있다. 또한 더 중요한 프 로세스에 더 높은 성능의 메모리 유형을 명시적으로 할당하거나 더 중요한 프로세스에 더 높은 성능의 공유 메 모리 영역을 명시적으로 할당할 수 있으며(예를 들어, 익명 공유 메모리(Ashmem) 또는 그래픽 메모리 할당자 (Gralloc)를 통해), 예를 들어, 이는 단계에 포함될 수 있다. 상당한 크기의 일부 중요 사용자 트리거 (user-triggered) 메모리 페이지들은 디바이스의 고성능 메모리 유형으로 이동할 수 있다. 중요 구조(예를 들어, 어플리케이션 런타임 환경 및 시스템 콜 관련)는 디바이스의 고성능 메모리 유형에 할당될 수도 있으며, 예를 들어 이는 단계에 포함될 수 있다. 예를 들어, 단계들(204 및 206)를 참조하면 컴퓨팅 디바이스는, 예를 들어 OS 등을 통해, 실행 동안 각 어플리 케이션에 대한 컴포넌트들 및 오브젝트들을 스코어링할 수 있고 스코어 테이블(이는 어플리케이션 자체의 일부 일 수 있음)에 스코어들을 저장할 수 있다. 예를 들어, 단계들(214 및 308)을 참조하면, 사용자가 어플리케이션 을 여러 번 호출(invocation)한 후 스코어링 프로세스(예를 들어, 카운팅, 훈련 및/또는 머신 러닝 프로세스를 통해 구현된)를 사용하여 어플리케이션의 성능을 개선할 수 있다. 선택적으로, 컴퓨팅 디바이스는 초기 스코어 테이블을 가짐으로써 어떤 오브젝트가 중요하고 어떤 것이 중요하지 않은지 식별할 수 있다. 어플리케이션 프로세스의 오브젝트는 기본적으로 프로세스들 간에 공유된다(예를 들어, 루트 프로세스 분기 후). 단계들(302 또는 304)에서, 오브젝트에 대한 기록이 있는 경우(예를 들어, COW(copy-on-write)에 대한 트 리거), 오브젝트 또는 그 일부는 가장 가까운 장래에 덜 사용되거나(예를 들어, DRAM 버스 또는 NVRAM 버스의 대역폭에 따라 다름) 덜 사용될 것으로 예상되는 버스에 따라 다른 메모리 유형으로(예를 들어, NVRAM에서 DRAM 으로 또는 DRAM에서 NVRAM으로 이동 및/또는 복사) 또는 동일한 메모리 유형으로 보유된 위치에서 이동 및/또는 복사될 수 있다. 단계들(302 및 304)에서 컴포넌트 또는 오브젝트의 이동은 또한 컴포넌트 또는 오브젝트(또는 그 일부)가 얼마나 많이 사용될 것으로 예상되는지 또는 그것이 축출되기 전에 메모리에 얼마나 오래 남아 있을 것인지에 의존할 수 있다. 일부 실시예에서, 지능형(intelligent) COW는 루트 프로세스에서 어플리케이션 프로세스까지 사용될 수 있다. 지능형 COW의 구현은 현재 및 예측된 메모리 버스 트래픽, 오브젝트 사용량, COW가 더 이상 유효하지 않을 때까 지의 예측 시간 및 사용자 메트릭에 의한 감지 가능성(예를 들어, 초당 프레임 수, 스크린 응답 등)을 포함하는 입력의 함수일 수 있다. 지능형 COW는 현재 및 예측 메모리 버스 트래픽, 오브젝트 사용량, 예측 시간 및 사용 자 관련 메트릭과 같은 입력을 사용하는 기대 최대화 알고리즘(expectation-maximization algorithm)을 통해 향상될 수 있다. 단계 204에서, 의미 있는 메트릭(예를 들어, 초당 프레임 수, 터치 렌더링 응답 시간 등) 에 의해 측정된 예상 사용자 경험을 최대화하고 다중 메모리 유형의 버스 용량 리소스를 최대화하기 위해 기대 최대화 알고리즘이 사 용될 수 있다. 단계에서, 공유 오브젝트는 초기에 디바이스의 가장 높은 성능 유형의 메모리(예를 들어, DRAM)에 배치되 고 부분적으로는 해당 메모리 유형으로, 부분적으로는 더 낮은 성능 유형의 메모리(예를 들어, NVRAM 또는 플래 시 메모리)에 점진적으로 복사될 수 있다. 점진적인 복사는 COW들에 의해 트리거링되는 것에 따라 부분적으로 이루어질 수 있다. 그리고 시간이 지나면서 가장 높은 성능 유형의 메모리(예를 들어, DRAM의 부분)의 공유 오 브젝트의 부분들은 자주 사용되지 않으면 더 낮은 성능 유형의 메모리(예를 들어, NVRAM 또는 플래시 메모리)로 축출될 수 있다. 또는 가장 높은 성능 유형의 메모리의 부분들이 전체적으로 더 낮은 성능 유형의 메모리에 직 접 복사될 수 있고 또는 단계들(302와 304) 사이에서와 같이 각 기록과 함께 상이한 유형의 메모리 사이에서 부 분들이 앞뒤로 이동될 수 있다. 서로 다른 유형의 메모리 사이를 오가는 것은 서로 다른 유형의 메모리 사이의 핑퐁(ping-ponging)을 포함할 수 있다. 핑퐁은 오브젝트의 부분들이 한 메모리 부분 또는 유형에서 다른 메모리 부분 또는 유형으로 복사되거나 이동되는 고급 알고리즘이거나 이를 포함할 수 있다. 예를 들어, 새로운 프로세스가 분기되어 일부 부분의 공유 오브젝트에 기록할 수 있다. 메모리 버스 A가 사용 중이고(busy) 버스 B가 비어 있다고(free) 가정한다. 오브젝 트의 부분의 판독-수정-기록은 핑퐁을 통해 메모리 A에서 메모리 B로 이동될 수 있다. 또한 메모리 B의 오브젝 트의 일부가 있는 프로세스에서 다른 프로세스가 분기될 수 있다. 그리고 메모리 버스 A가 사용 중이고 버스 B 가 비어 있다고 가정한다. 그러면 오브젝트의 부분의 판독-수정-기록이 메모리 B의 한 부분에서 메모리 B의 동 일한 부분 또는 다른 부분으로 다시 이동될 수 있다. 메모리 버스 B가 사용 중이고 버스 A가 비어 있으면 오브 젝트의 부분의 판독-수정-기록이 메모리 B에서 메모리 A로 이동될 수 있다. 운영 체제는 컴퓨팅 디바이스의 가장 높은 성능 유형의 메모리에 오브젝트들의 사용자 중요 작업 세트를 유지하 려고 할 수 있다(예를 들어, 포그라운드(foreground application) 어플리케이션 및/또는 백그라운드에서 실행 중인 프로세스에 의해 사용되는 오브젝트들). 다른 오브젝트들은 컴퓨팅 디바이스의 더 낮은 성능 유형의 메모 리로 마이그레이션될 수 있으며 그 중 일부 중요한 부분은 여전히 가장 높은 성능 유형의 메모리에 캐싱된다. 일부 실시예에서, OS(또는 하이퍼바이저 등)는 어플리케이션을 개시하도록 구성될 수 있고, 어플리케이션의 개 시는 어플리케이션의 이전 실행 패턴에 따라 초기 포인트까지 어플리케이션에 대한 루트 프로세스를 실행하는 것을 포함한다. 또한, OS(또는 하이퍼바이저 등)는 컴퓨팅 디바이스의 사용자로부터 어플리케이션을 시작하라는 요청을 수신하고 뿐만 아니라 어플리케이션 시작 요청을 수신하는 것에 응답하여 그리고 어플리케이션의 루트 프로세스를 사용함으로써 컴퓨팅 디바이스에서 어플리케이션을 시작하도록 구성될 수 있다. 구체적으로, 도 4는 적어도 제어기 및 메모리를 포함하는 모바일 디바이스를 도시하고, 이는 개별 어 플리케이션 또는 어플리케이션 그룹에 대한 맞춤형(customized) 루트 프로세스의 생성을 구현할 수 있다. 제어 기 및 메모리의 메모리는 도 1에 도시된 메모리를 포함할 수 있다. 모바일 디바이스의 제어기 및 메모리는 모바일 디바이스에서 실행되는 어플리케이션들(예를 들어, 어플리케이션들(406a, 406b, 406c) 참조)에 대한 명령어 및 데이터를 포함할 수 있다. 모바일 디바이스의 제어기는 데이터에 기초하여 어플리 케이션에 대한 명령어를 실행할 수 있다. 데이터는 바이너리 형식 또는 프로그래밍 언어 인터프리터 (interpreter)에 의한 해석에 적합한 형식의 어플리케이션 명령어 코드를 포함할 수 있다. 데이터는 일부 데이 터 구조, 라이브러리 등을 포함할 수 있다. 제어기는 제어기의 레지스터들에 명령어와 데이터를 저장할 수도 있 다. 메모리는 그의 메모리 셀들에 명령어와 데이터를 저장할 수 있다. 일부 실시예에서, 모바일 디바이스 의 메모리의 메모리 셀들은 플래시 메모리 셀들 및/또는 NVRAM 셀들을 포함할 수 있다. NVRAM 셀들은 3D XPoint 메모리 셀들이거나 이를 포함할 수 있다. 일부 실시예에서, 메모리는 상이한 속도, 레이턴시, 대역폭 및 기타 파라미터를 가질 수 있다. 예를 들어, SRAM 메모리는 고속 캐시로, DRAM은 메인 메모리로, NVRAM은 저장 메모리로 사용될 수 있다.모바일 디바이스에 포함되고 실행 가능한 각각의 어플리케이션에 대한 명령어 및 데이터는 루트 프로세스 데이터 및 어플리케이션의 루트 프로세스에 대한 명령어를 포함할 수 있다. 모바일 디바이스에 포함된 어 플리케이션의 개별 루트 프로세스(예를 들어, 어플리케이션(406a)의 루트 프로세스, 어플리케이션(406b)의 루트 프로세스, 어플리케이션(406c)의 루트 프로세스 참조)는 제어기 및 메모리에 의해 구현될 수 있다. 제어기는 루트 프로세스에 대한 명령어 및 데이터에 따라 루트 프로세스의 명령어를 실행하도록 구성 될 수 있으며, 메모리는 제어기에 의한 루트 프로세스의 실행을 위한 명령어 및 데이터를 보유하거나 저장하도 록 구성될 수 있다. 도 4 및 도 6에서는 루트 프로세스가 단일 어플리케이션에 대응하는 것으로 도시되어 있다(예를 들어, 루트 프 로세스 및 대응하는 어플리케이션(406a)뿐만 아니라 루트 프로세스 및 대응하는 어플리케이션(606a) 참조). 루트 프로세스는 단일 어플리케이션 또는 단일 어플리케이션을 포함하는 다중 어플리케이션들에 의해 사 용될 수 있는 다중 프로세스들로 분기될 수 있음을 이해해야 한다. 예를 들어 단일 어플리케이션이 어플리케이 션 그룹에 있는 경우, 그룹에 대한 루트 프로세스는 다중 분기된 프로세스들로 분기될 수 있으며 다중 분기된 프로세스들은 그룹의 어플리케이션들에 의해 사용될 수 있다. 또한 어플리케이션 그룹의 단일 어플리케이션은 다중의 서로 다른 분기된 프로세스들을 사용할 수 있다. 예를 들어, 어플리케이션(606a)(이는 어플리케이션 그 룹의 일부일 수 있음)은 분기된 프로세스들(610a, 610b, 610c)을 사용할 수 있다. 어플리케이션(606a)을 갖는 그룹의 다른 어플리케이션들 도 6에 도시되어 있지 않다는 것에 유의한다. 또한 언급했듯이 그룹의 다중 어플리 케이션들은 다중의 상이한 분기된 프로세스들을 사용할 수 있다. 예를 들어, 어플리케이션들(606a, 606b, 606 c)은 예를 들어 어플리케이션들이 동일한 그룹에 있다면(이는 도 6에 도시되지 않음) 분기된 프로세스들(610a, 610b, 610c)을 사용할 수 있다. 이러한 실시예는 분기를 병합함으로써 구현될 수 있다. 일부 실시예에서, 분기된 루트 프로세스들의 초기 실행은 라이브러리를 사전 로딩하고, 필요한 라이브러리 및 초기 데이터 구조로부터 분기된 프로세스를 구성하고, 추가 재사용을 위해 분기된 프로세스를 저장하는 것으로 제한될 수 있다. 또한 분기된 프로세스의 실행은 언제든지 메모리에 특정 상태로 저장되어 프로세스를 재실행하 는 데 시간을 낭비하지 않도록 재사용될 수 있다. 본 개시의 목적을 위해, 도 1, 4 및 6이 어플리케이션당 루트 프로세스를 언급하지만, 그러한 어플리케이션은 어플리케이션 그룹의 일부일 수 있고 루트 프로세스는 어플리케이션 그룹에 대한 루트 프로세스일 수 있다는 것 을 이해해야 한다. 모바일 디바이스에 포함된 어플리케이션(예를 들어, 어플리케이션들(406a, 406b 및 406c) 참조)의 다른 프 로세스들은 제어기 및 메모리에 의해 구현될 수도 있다. 제어기는 다른 프로세스에 대한 명령어 및 데이터 에 따라 어플리케이션의 다른 프로세스의 명령어를 실행하도록 구성될 수 있으며, 메모리는 제어기에 의한 다른 프로세스의 실행을 위한 명령어 및 데이터를 보유하거나 저장하도록 구성될 수 있다. 구체적으로, 도 5는 도 1, 4 및 6에 도시된 모바일 디바이스에 의해 또는 모바일 디바이스와 유사하 게 구성된 다른 유형의 컴퓨팅 디바이스에 의해 수행될 수 있는 방법의 동작을 도시한다. 또한, 일부 실시 예에서, 방법은 일반적으로 컴퓨팅 디바이스의 OS 또는 모바일 디바이스의 OS에 의해 적어도 부분적으로 수행될 수 있다. 방법은 또한 하이퍼바이저 및/또는 하나 이상의 운영 체제에 의해 적어도 부분적으로 수 행될 수 있다. 도 5에서, 방법은 단계에서 어플리케이션에 대한 메모리로부터의 판독 및 메모리에 대한 기록의 빈도 (frequency) 또는 최신성(recency)을 결정하기 위해 어플리케이션의 사용을 모니터링하는 것으로 시작한다. 일 부 실시예에서(도시되지 않음), 방법은 어플리케이션의 이전 실행 패턴의 수량, 빈도 및/또는 최신성을 결 정하기 위해 어플리케이션의 사용을 모니터링 및/또는 추적하는 것으로 시작할 수 있다. 어플리케이션의 이전 실행 패턴은 모니터링 및/또는 추적되는 어플리케이션의 이전 실행의 패턴의 적어도 양, 빈도 및/또는 최신성을 포함하거나, 이와 관련되거나, 이에 기초할 수 있다. 모니터링 및/또는 추적되는 패턴은 사용자 또는 머신에 의한 어플리케이션 사용의 패턴의 임의의 유형일 수 있다. 예를 들어, 어플리케이션에 대한 임의의 유형의 메모리 액세스 및 사용 패턴을 모니터링 및/또는 추적될 수 있다. 패턴은 메트릭, 예를 들어 메 모리로부터의 판독, 메모리로의 기록의 양, 빈도 및/또는 최신성, 물리적 메모리 공간의 어드레스 패턴, 가상 공간의 어드레스 패턴, 데이터의 지역성(locality)(공간적 및/또는 시간적), 뱅크 충돌(bank conflict), 명령어 당 CPU 사이클 등을 포함하거나 이와 관련되거나 이에 기초 할 수 있다. 또한, 어플리케이션의 사용을 모니터링 및 추적하는 것은 어플리케이션의 개시 동안(예를 들어, 어플리케이션이 메모리에 로딩되는 경우 포함) 및/또는 이후의 어플리케이션의 실행 동안 발생할 수 있다. 어플리케이션의 사용 의 모니터링 및 추적은 어플리케이션을 개시하는 동안 및 개수 후 어플리케이션을 실행하는 다른 기간에 발생할 수 있다. 런타임(runtime) 동안 어플리케이션의 사용을 모니터링하고 추적하면 어플리케이션의 효과적 및/또는 효율적인 루트 프로세스의 유도를 촉진 할 수 있다. 예를 들어, 개시 후 사용자는 스크린을 터치하여 어플리케 이션의 일부 요소를 트리거링하고 일부 결과를 기대할 수 있다. 중요한 메모리 오브젝트가 어플리케이션의 런타 임 동안 발생하는 모니터링에 기초하여 사전 로딩될 수 있기 때문에 해당 결과의 전달은 일부 실시예에서 매우 빠를 수 있다. 일부 실시예에서, 오브젝트의 사전 로딩은 NAND형 플래시 메모리와 같은 더 느린 메모리에서 DRAM과 같은 더 빠른 메모리로 수행될 수 있다. 단계에서, 방법은 어플리케이션에 대한 메모리로부터의 판독 및 메모리에 대한 기록의 빈도 또는 최 신성에 따라 어플리케이션의 이전 실행의 패턴을 생성하는 것을 계속된다. 일부 실시예에서(도시되지 않음), 방 법은 모니터링 및/또는 추적되는 어플리케이션의 이전 실행에서 패턴의 양, 빈도 및/또는 최신성에 따라 어플리케이션의 이전 실행 패턴을 생성하는 것으로 계속될 수 있다. 또한, 어플리케이션의 이전 실행의 생성된 패턴은 모니터링 및/또는 추적되는 어플리케이션의 이전 실행의 패턴 의 적어도 양, 빈도 및/또는 최신성을 포함하거나, 이와 관련되거나, 이에 기초할 수 있다. 단계에서 생성 된 패턴은 사용자 또는 머신에 의한 어플리케이션 사용의 임의 유형의 패턴일 수 있다. 예를 들어, 단계에 서 생성된 패턴은 모니터링 및/또는 추적될 수 있는 어플리케이션에 대한 메모리 액세스 및 사용의 임의 유형의 패턴을 포함할 수 있다. 또한, 예를 들어 생성된 패턴은 메트릭, 예를 들어 메모리로부터의 판독, 메모리에 대 한 기록의 양, 빈도 및/또는 최신성, 물리적 메모리 공간의 어드레스 패턴, 가상 공간의 어드레스 패턴, 데이터 의 지역성(공간적 및/또는 시간적), 뱅크 충돌 또는 어플리케이션 및 어플리케이션에 대한 메모리 사용과 관련 된 기타 임의의 유형의 메트릭을 포함하거나 이와 관련되거나 이에 기초 할 수 있다. 단계에서, 방법은 어플리케이션의 이전 실행의 패턴에 따라 초기 포인트로 어플리케이션의 루트 프로 세스를 실행하는 것으로 계속된다. 단계는 어플리케이션의 이전 실행의 패턴에 따라 어플리케이션의 루트 프로세스를 맞춤화한 다음, 어플리케이션의 이전 실행의 패턴에 따라 초기 포인트로 어플리케이션의 루트 프로 세스를 실행하는 것을 포함할 수 있다. 단계는 또한 도 2에 도시된 단계를 포함할 수 있다. 단계 는 또한 도 2에 도시된 단계와 단계를 포함할 수 있다. 루트 프로세스를 맞춤화하는 것은 다양한 라이브러리로부터 그것을 구성하고, 기본적으로 사용 가능한 다른 루 트 프로세스를 사용하고, 데이터 구조를 형성하고, 및 루트 프로세스 컴포넌트에 대해 네트워크를 통해 다양한 소스를 질의하여(querying) 수행된다. 어플리케이션의 이전 실행의 패턴은 모니터링 및/또는 추적되는 어플리케이션의 이전 실행의 패턴의 적어도 양, 빈도 및/또는 최신성을 포함하거나, 이와 관련되거나, 이에 기초할 수 있다. 모니터링 및/또는 추적되는 패턴은 사용자 또는 머신에 의한 어플리케이션 사용의 패턴의 임의의 유형일 수 있다. 예를 들어, 어플리케이션에 대한 임의의 유형의 메모리 액세스 및 사용 패턴이 모니터링 및/또는 추적될 수 있다. 어플리케이션의 이전 실행의 패턴은 사용자 또는 머신에 의한 어플리케이션 사용의 임의의 유형의 패턴의 적어도 양, 빈도 및/또는 최신성과 같은 메트릭을 포함하거나 관련되거나 이에 기초할 수 있다. 예를 들어 패턴은 메트릭, 예를 들어 메모리로부터 의 판독, 메모리에 대한 기록의 양, 빈도 및/또는 최신성, 물리적 메모리 공간의 어드레스 패턴, 가상 공간의 어드레스 패턴, 데이터의 지역성(공간적 및/또는 시간적), 뱅크 충돌, 명령어당 CPU 사이클 등을 포함하거나 이 와 관련되거나 이에 기초할 수 있다. 어플리케이션의 루트 프로세스를 실행하는 것은 어플리케이션에 대한 메모리에 대한 초기 기록 및/또는 판독 전 에 메모리에서 데이터를 이동시키는 것을 포함할 수 있다. 또한, 어플리케이션의 루트 프로세스를 실행하는 것 은 어플리케이션에 대한 메모리에 대한 초기 기록 및/또는 판독 전에 메모리에 데이터를 복사하는 것을 포함할 수 있다. 그리고, 이동 및/또는 복사된 데이터는 어플리케이션의 이전 실행 패턴과 관련된 데이터를 포함할 수 있다. 일부 실시예에서, 메모리에 대한 임의의 초기 기록 전에 메모리에서 데이터의 이동 및/또는 복사는 공통 코드 및 판독 전용 데이터의 이동 및/또는 복사를 피하는 것을 포함할 수 있다. 일부 실시예에서, 방법은, 컴퓨팅 디바이스의 OS(또는 하이퍼바이저)가 OS(또는 하이퍼바이저)에 대한 루트 프로세스를 분기한 후, 어플리 케이션의 루트 프로세스가 어플리케이션에 대한 어플리케이션 레벨 프로세스가 되도록 어플리케이션의 루트 프 로세스의 실행을 맞춤화하기 위해 어플리케이션에 대한 예측된 초기 기록 및/또는 판독을 실행하는 것을 포함할 수 있다. 또한, 방법은 루트 프로세스의 실행의 적어도 일부 전에 어플리케이션의 루트 프로세스에 대한 데이터를 플래시 메모리에 저장하는 단계를 포함할 수 있다(도면에 도시되지 않은). 방법은 또한 루트 프로세스의 실행의 적어도 일부 전에 NVRAM에 어플리케이션의 루트 프로세스에 대한 데이터를 저장하는 단계를 포함할 수 있다(도면에 도시되지 않음). NVRAM는 3D XPoint 메모리를 포함할 수 있다. 일부 실시예에서 새로운 데이터를 저장하는 것은 어플리케이션의 사용과 관련된 오래된 미사용 데이터를 덮어쓸 수 있다. 단계에서, 방법은 사용자로부터 어플리케이션을 시작하라는 요청을 수신하는 것으로 계속된다. 단계 에서, 방법은 어플리케이션 시작 요청을 수신하는 것에 응답하여 그리고 어플리케이션의 루트 프로세 스를 사용함으로써 어플리케이션을 시작하는 것으로 계속된다. 일부 실시예에서, 방법은, 컴퓨팅 디바이스 의 OS에 의해 적어도 부분적으로, 어플리케이션의 루트 프로세스를 어플리케이션의 이전 실행 패턴에 따라 백그 라운드 프로세스로서 실행하는 것을 포함할 수 있다. 그러한 실시예에서, 방법은 또한, OS에 의해, 컴퓨팅 디바이스의 사용자로부터 어플리케이션을 시작하라는 요청을 수신하는 단계를 포함할 수 있다. 그리고, 방법 은 어플리케이션을 시작하라는 요청을 수신하는 것에 응답하여 그리고 어플리케이션의 루트 프로세스 또는 루트 프로세스의 분기된 프로세스들을 사용함으로써, OS에 의해, 컴퓨팅 디바이스에서 어플리케이션을 시작하는 단계를 포함할 수 있다. 일부 실시예에서, 분기된 프로세스의 코드 및 데이터는 어플리케이션, 다른 프로세스 또는 OS에 의한 코드 및 데이터의 초기 수정까지 복사되지 않는다. 일부 실시예에서, 코드 및 데이터의 수정된 부분만 복사되지만 수정되지 않은 부분은 공통으로 남아 있다. 일부 실시예에서, 그러한 부분은 메모리 페이지, 캐시 라인 또는 파일 시스템 섹터 또는 컴퓨터 판독가능 저장 매체의 다른 요소에 대한 기록을 모니터링함으로 써 식별될 수 있다. 일부 실시예에서, 루트 프로세스를 초기 포인트로 실행하는 것은 하나의 디바이스, 예를 들어, 클라우드 컴퓨팅 환경에서 수행되고, 그런 다음 다른 디바이스로부터 어플리케이션 중 적어도 하나를 시작하라는 요청을 받으면 이를 분기하고, 그런 다음 네트워크를 통해 분기된 프로세스를 다른 디바이스, 예를 들어 모바일 디바이스로 전 송하고, 그런 다음 모바일 디바이스에서 분기된 프로세스를 어플리케이션의 시작점으로 사용한다. 구체적으로, 도 6은 적어도 제어기 및 메모리를 포함하는 모바일 디바이스를 도시하고, 제어기 및 메 모리의 메모리는 도 1에 도시된 메모리를 포함할 수 있다. 모바일 디바이스의 제어기 및 메모리 는 모바일 디바이스에서 실행되는 어플리케이션(예를 들어, 어플리케이션(606a, 606b, 606c) 참조)에 대한 명령어 및 데이터를 포함할 수 있다. 모바일 디바이스의 제어기는 데이터에 기초하여 어플리케이션에 대한 명령어를 실행할 수 있다. 데이터는 바이너리 형식 또는 프로그래밍 언어 인터프리터에 의한 해석에 적합한 형 식의 어플리케이션 명령어 코드를 포함할 수 있다. 데이터는 일부 데이터 구조, 라이브러리 등을 포함할 수 있 다. 제어기는 제어기의 레지스터에 명령어와 데이터를 저장할 수도 있다. 메모리는 메모리 셀에 명령어와 데이 터를 저장할 수 있다. 일부 실시예에서, 모바일 디바이스의 메모리의 메모리 셀들은 플래시 메모리 셀들 및/또는 NVRAM 셀들을 포함할 수 있다. NVRAM 셀들은 3D XPoint 메모리 셀들이거나 이를 포함할 수 있다. 도 6에 도시된 바와 같이, 모바일 디바이스에 포함되고 실행 가능한 각각의 어플리케이션에 대한 명령어 및 데이터는 루트 프로세스 데이터 및 어플리케이션의 루트 프로세스에 대한 명령어들을 포함할 수 있다. 예를 들어 개별 루트 프로세스들(608, 612 및 616)을 참조하면 도 6에 도시된 바와 같이 모바일 디바이스에 포 함된 어플리케이션의 루트 프로세스는 제어기 및 메모리에 의해 구현될 수 있다. 제어기는 루트 프로세스 들에 대한 명령어들 및 데이터에 따라 루트 프로세스의 명령어들을 실행하도록 구성되고, 메모리는 제어기에 의 해 루트 프로세스를 실행하기 위한 명령어들 및 데이터를 유지하거나 저장하도록 구성된다. 또한, 도 6에 도시 된 바와 같이, 모바일 디바이스에 포함된 어플리케이션(예를 들어, 어플리케이션들(606a, 606b 및 606c) 참조)의 다른 프로세스는 제어기 및 메모리에 의해 구현될 수도 있다. 제어기는 다른 프로세스에 대한 명 령어들 및 데이터에 따라 어플리케이션의 다른 프로세스의 명령어들을 실행하도록 구성되며, 메모리는 제어기에 의한 다른 프로세스의 실행을 위한 명령어들 및 데이터를 유지하거나 저장하도록 구성된다. 또한, 도 6에 도시된 바와 같이, 제어기 및 메모리는 모바일 디바이스에 저장되고 실행 가능한 어플 리케이션들의 개별 루트 프로세스들로부터 분기된 다중 프로세스들(예를 들어, 분기된 프로세스들(610a, 610b, 610c, 614a, 614b, 618a 및 618b) 참조)에 대한 데이터 및 명령어들을 포함할 수 있다. 도 6에 도시된 바와 같 이, 적어도 프로세스들(610a, 610b, 610c)은 루트 프로세스로부터 분기되고; 그러나 루트 프로세스에 서 더 많은 프로세스들이 분기될 수 있다. 또한 도시된 바와 같이, 프로세스들(614a 및 614b)은 루트 프로세스 로부터 분기된다. 그리고, 프로세스들(618a 및 618b)는 루트 프로세스에서 분기된다. 일부 실시예에서, 모바일 디바이스의 운영 체제, 또는 모바일 디바이스 내의 또는 이와 연관된 하이퍼바이 저는 어플리케이션의 루트 프로세스(예를 들어, 어플리케이션(606a)의 루트 프로세스, 어플리케이션(606b)의 루트 프로세스, 어플리케이션(606c)의 루트 프로세스 참조)를 다중 프로세스들(예를 들어, 분기 된 프로세스들(610a, 610b, 610c, 614a, 614b, 618a 및 618b) 참조)로 분기하도록 구성된다. 이러한 실시예에 서, 운영 체제 또는 하이퍼바이저는 어플리케이션을 시작하라는 요청을 수신하는 것에 응답하여 그리고 어플리 케이션 시작 요청에 따라 다수의 분기된 프로세스들(예를 들어, 분기된 프로세스들(610a, 610b, 610c, 614a, 614b, 618a 및 618b) 참조) 및/또는 개별 루트 프로세스(예를 들어, 어플리케이션(606a)의 루트 프로세스, 어플리케이션(606b)의 루트 프로세스, 어플리케이션(606c)의 루트 프로세스 참조) 중 적어도 하나를 사용함으로써 모바일 디바이스에서 어플리케이션을 시작하도록 구성될 수 있다. 분기된 다중 프로세스들의 적어도 일부 또는 각각은 어플리케이션의 상위 루트 프로세스와 다를 수 있다. 차이 점은 실행될 컴퓨팅 디바이스의 다른 어플리케이션 및 다른 어플리케이션 부분을 기반으로 할 수 있다. 그리고, 분기된 다중 프로세스들의 적어도 일부 또는 각각은 적어도 어플리케이션 실행의 일부 포인트에서 어플리케이션 의 상위 루트 프로세스와 동일할 수 있다. 본 개시의 목적을 위해, 도 1, 4 및 6이 어플리케이션당 루트 프로세스를 언급하지만, 그러한 어플리케이션은 어플리케이션 그룹의 일부일 수 있고 루트 프로세스는 어플리케이션 그룹에 대한 루트 프로세스일 수 있다는 것 을 이해해야 한다. 구체적으로, 도 7은 도 6에 도시된 모바일 디바이스 또는 모바일 디바이스와 유사하게 구성된 다른 유형의 컴퓨팅 디바이스에 의해 수행될 수 있는 방법의 동작을 도시한다. 또한, 일부 실시예에서, 방법 은 일반적으로 컴퓨팅 디바이스의 운영 체제 또는 모바일 디바이스의 운영 체제에 의해 수행될 수 있다. 방법은 또한 하이퍼바이저 및/또는 하나 이상의 운영 체제에 의해 수행될 수 있다. 도 7에서 방법은 도 5에 더 상세히 도시된 방법의 단계들(502 내지 508)로 시작한다. 단계에서, 방법은 어플리케이션에 대한 메모리로부터의 판독 및 메모리에 대한 기록의 빈도 또는 최신성을 결정하기 위해 어플리케이션의 사용을 모니터링하는 단계를 포함한다. 단계에서, 방법은 어플리케이션에 대한 메모 리로부터의 판독 및 메모리에 대한 기록의 빈도 또는 최신성에 따라 어플리케이션의 이전 실행 패턴을 생성하는 단계를 포함한다. 단계에서, 방법은 어플리케이션의 이전 실행 패턴에 따라 초기 포인트로 어플리케이션의 루트 프로세스를 실행하는 단계를 포함한다. 단계에서, 방법은 사용자로부터 어플리케이션을 시작하기 위 한 요청을 수신하는 단계를 포함한다. 단계에서, 방법은 어플리케이션의 루트 프로세스를 다수의 프로세스들로 분기하는 것으로 계속된다. 단계에서, 방법은 어플리케이션 시작 요청을 수신하는 것에 응답하여 그리고 어플리케이션 시작 요청 에 따라 다수의 프로세스들 중 적어도 하나를 사용함으로써 어플리케이션 시작으로 계속된다. 대안적으로, 단계 에서, 방법은 어플리케이션 시작 요청을 수신하는 것에 응답하여 그리고 어플리케이션 시작 요청에 따른 상위 루트 프로세스(예를 들어, 루트 프로세스 참조) 및 다중 프로세스들(예를 들어, 분기된 프로세 스들(610a, 610b 및 610c) 참조)을 사용함으로써 어플리케이션 시작을 계속할 수 있다. 방법과 관련하여, 분기된 다중 프로세스들의 적어도 일부 또는 각각은 어플리케이션의 상위 루트 프로세스 와 다를 수 있다. 차이점은 실행될 컴퓨팅 디바이스의 다른 어플리케이션 및 다른 어플리케이션 부분을 기초로 할 수 있다. 그리고, 분기된 다중 프로세스들의 적어도 일부 또는 각각은 적어도 어플리케이션 실행의 일부 포 인트에서 어플리케이션의 상위 루트 프로세스와 동일할 수 있다. 구체적으로, 도 8은 도 1, 4 및 6에 도시된 모바일 디바이스에 의해 또는 모바일 디바이스와 유사하 게 구성된 다른 유형의 컴퓨팅 디바이스에 의해 수행될 수 있는 방법의 동작을 도시한다. 또한, 일부 실시 예에서, 방법은 일반적으로 컴퓨팅 디바이스의 운영 체제 또는 모바일 디바이스의 운영 체제에 의해 수행 될 수 있다. 방법은 또한 하이퍼바이저 및/또는 하나 이상의 운영 체제에 의해 수행될 수 있다. 도 8에 도시된 바와 같이, 방법은 도 5에 도시된 방법 또는 도 7에 도시된 방법으로 시작한다. 단계에서, 방법은 사용자로부터 어플리케이션을 종료하라는 요청을 수신하는 것으로 계속된다. 예를 들어, 단계에서, 방법은 컴퓨팅 디바이스의 사용자(예를 들어, 모바일 디바이스의 사용자)로부터 어 플리케이션을 종료하라는 요청을 수신하는 것으로 계속된다. 단계에서, 방법은 어플리케이션을 종료하라는 요청을 수신하면 어플리케이션을 적어도 부분적으로 종 료하는 것으로 계속된다. 단계에서, 방법은 어플리케이션 종료 요청을 수신하면 어플리케이션의 루트 프로세스를 적어도 부분적으로 종료하는 것으로 계속된다. 도 8에 도시된 바와 같이, 단계에서, 단계가 완료되면, 방법은 미리 결정된 조건에 따라 루트 프로세스를 적어도 부분적으로 재실행하는 것으로 계속된다(적어도 부분적으로 어플리케이션과 루트 프로세스를 종료한 후). 단계에서, 루트 프로세스를 적어도 부분적으로 재실행하는 것은 어플리케이션의 이전 실행 패 턴에 기초하여 발생할 수 있다. 또한, 단계에서, 루트 프로세스를 적어도 부분적으로 재실행은 어플리케이 션의 이전 실행 패턴에 의해 업데이트될 수 있다. 도 8에 도시된 바와 같이, 단계에서, 단계가 완료되지 않은 경우, 방법은 어플리케이션을 종료 하라는 요청을 수신할 때 어플리케이션의 루트 프로세스를 계속해서 실행하는 것으로 진행한다. 다시 말해서, 방법은 단계에서 모바일 디바이스의 사용자로부터 어플리케이션을 종료하라는 요청을 수신하는 단계 를 포함하고, 그 다음 단계에서, 어플리케이션 종료 요청을 수신하면 어플리케이션을 적어도 부분적으로 종료하는 단계를 포함할 수 있고, 그 다음, 단계에서, 단계들(804와 810) 사이에 루트 프로세스를 중지하 지 않고 어플리케이션을 종료하라는 요청을 수신하면 어플리케이션의 루트 프로세스를 계속 실행하는 것을 포함 할 수 있다. 그 결과, 사용자가 적어도 부분적으로 종료된 어플리케이션이나 이 루트 프로세스를 사용할 수 있 는 다른 어플리케이션을 다시 시작하기로 결정한 경우 어플리케이션의 루트 프로세스를 다시 사용할 수 있다. 방법(500 및 700)을 구현할 수 있는 실시예와 같은 일부 실시예에서, 어플리케이션의 이전 실행 패턴은 특정 사 용자 및 다른 사용자에 의한 특정 컴퓨팅 디바이스 상의 어플리케이션 사용으로부터 유래하므로 루트 프로세스 는 임의의 사용자가 특정 컴퓨팅 디바이스(예를 들어, 특정 모바일 디바이스) 상의 어플리케이션을 사용하도록 맞춤화된다. 방법(500 및 700)을 구현할 수 있는 일부 다른 실시예와 같은 일부 다른 실시예에서, 어플리케이션의 이전 실행 패턴은 루트 프로세스가 특정 사용자에 의한 특정 모바일 디바이스 상의 어플리케이션 사용을 위해 맞춤화되도 록 특정 사용자에 의한 특정 컴퓨팅 디바이스(예를 들어, 특정 모바일 디바이스) 상의 어플리케이션 사용으로부 터 유래한다. 방법(500 및 700)을 구현할 수 있는 일부 다른 실시예와 같은 일부 다른 실시예에서, 어플리케이션의 이전 실행 패턴은 특정 사용자가 특정 컴퓨팅 디바이스(예를 들어, 특정 모바일 디바이스) 및 적어도 하나의 다른 컴퓨팅 디바이스에서 특정 어플리케이션을 사용한 것으로부터 유래하여, 루트 프로세스가 특정 사용자에 의해 컴퓨팅 디바이스 및 적어도 하나의 다른 컴퓨팅 디바이스 상의 어플리케이션 사용을 위해 맞춤화된다. 방법, 방법, 방법, 방법, 방법, 또는 본 명세서에 설명된 임의의 다른 방법, 프로세 스 또는 동작과 관련하여, 일부 실시예에서, 비일시적 컴퓨터 판독 가능 저장 매체는 적어도 하나의 처리 디바 이스(예를 들어, 도 9에 도시된 제어기)에 의해 실행될 때 적어도 하나의 처리 디바이스로 하여금 방법 , 방법, 방법, 방법, 방법, 또는 본 명세서에 설명된 임의의 다른 방법, 프로세스 또 는 동작, 및/또는 이들의 임의의 조합을 수행하게 하는 명령어를 저장한다. 예를 들어, 일부 실시예는 컴퓨팅 디바이스와 연관된 프로세서에 의해 실행될 때 도 2에 도시된 방법과 같 은 방법을 수행하는 컴퓨터 실행 가능 명령어로 유형적으로 인코딩된 비일시적 컴퓨터 판독 가능 저장 매체를 포함할 수 있다. 또한, 예를 들어, 일부 실시예는 컴퓨터 실행 가능 명령어로 유형적으로 인코딩된 비일시적 컴 퓨터 판독 가능 저장 매체를 포함할 수 있으며, 이는 컴퓨팅 디바이스와 관련된 프로세서에 의해 실행될 때 방 법, 예를 들어, 도 3에 도시된 방법, 도 5에 도시된 방법, 도 7에 도시된 방법, 및 도 8에 도시 된 방법을 수행한다. 또한, 예를 들어, 일부 실시예는 컴퓨터 실행 가능 명령어로 유형적으로 인코딩된 비일시적 컴퓨터 판독 가능 저장 매체를 포함할 수 있으며, 이는 컴퓨팅 디바이스와 연관된 프로세서에 의해 실행될 때 모바일 디바이스에 서 어플리케이션에 대한 복수의 프로세스들을 모니터링하는 것을 포함하는 방법을 수행할 수 있다. 방법은 또한 어플리케이션의 개시 동안 메모리 내의 오브젝트들 또는 컴포넌트들의 배치를 결정하기 위해 어플리케이션의 개 시 동안 복수의 프로세스들에 의해 사용되는 오브젝트들 또는 컴포넌트들을 스코어링하는 단계를 포함할 수 있 다. 그리고, 어플리케이션을 개시하는 동안, 방법은 또한 메모리의 제1 부분으로 제1 레벨에서 스코어링된 오브 젝트들 또는 컴포넌트들을 로딩하는 것뿐만 아니라 메모리의 제2 부분으로 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들을 로딩하는 단계를 포함할 수 있다. 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들은 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들보다 어플리케이션 시작에 덜 중요할 수 있다. 또한, 예를 들어, 일부 실시예는 모바일 디바이스의 OS에 의해 어플리케이션의 개시 동안 어플리케이션에 대한 복수의 프로세스들을 모니터링하는 단계를 포함하는 방법을 포함할 수 있다. 복수의 프로세스들에 대한 모니터 링은 백그라운드 프로세스에서 발생할 수 있다. 방법은 또한 어플리케이션의 개시 동안 메모리 내의 오브젝트들또는 컴포넌트들의 배치를 결정하기 위해 어플리케이션의 개시 동안 복수의 프로세스들에 의해 사용되는 오브젝 트들 또는 컴포넌트들을 스코어링하는 단계를 포함할 수 있다. 그리고, 어플리케이션을 개시하는 동안, 방법은 메모리의 제1 부분에 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들을 로딩하는 것뿐만 아니라 메모리의 제2 부분에 제2 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들을 로딩하는 것을 포함할 수 있다. 제2 레벨에 서 스코어링된 오브젝트들 또는 컴포넌트들은 제1 레벨에서 스코어링된 오브젝트들 또는 컴포넌트들보다 어플리 케이션 개시에 덜 중요할 수 있다. 도 9는 본 개시내용의 일부 실시예에 따른, 상이한 어플리케이션 프로세스들에 대한 초기 데이터 분배를 구현할 수 있는 예시적인 컴퓨팅 디바이스를 도시한다. 컴퓨팅 디바이스는 또한 본 개시내용의 일부 실시예 에 따라 개별 어플리케이션 또는 어플리케이션 그룹에 대한 맞춤형 루트 프로세스의 생성을 구현할 수 있다. 디 바이스는 스마트폰, 태블릿 컴퓨터, IoT 기기, 스마트 텔레비전, 스마트 시계, 안경 또는 기타 스마트 가 전 제품, 차량내 정보시스템, 웨어러블 스마트기기, 게임 콘솔, PC, 디지털 카메라 또는 이들의 조합과 같은 모 바일 디바이스 또는 모바일 디바이스와 다소 유사하거나 유사한 임의의 다른 유형의 컴퓨팅 디바이스거나 이를 포함하거나 그 일부일 수 있다. 도시된 바와 같이, 디바이스는 적어도 광역 네트워크(WAN), 근거리 통신망(LAN), 인트라넷, 엑스트라넷, 인터넷, 및/또는 이들의 임의의 조합을 포함하는 통신 네트워크(들) 에 연결될 수 있다. 본 명세서에 설명된 컴퓨팅 또는 모바일 디바이스(예를 들어, 모바일 디바이스 또는 컴퓨팅 디바이스 ) 각각은 개인용 컴퓨터(PC), 태블릿 PC, 셋톱박스(STB), 개인휴대정보비서(PDA), 휴대폰, 웹 어플라이언 스, 서버, 네트워크 라우터, 스위치 또는 브리지, 또는 해당 머신이 취해야 할 조치를 지정하는 명령어 세트(순 차적이든 아니든)를 실행할 수 있는 임의의 머신으로 대체될 수 있다. 또한, 도 9에 도시된 디바이스와 도 1, 4 및 6에 도시된 모바일 디바이스에 대해 단일 머신이 도시되 어 있지만, \"머신\"라는 용어는 또한 본 명세서에서 논의된 방법론 또는 작업 중 하나 이상을 수행하기 위해 명 령어 세트(또는 여러 세트들)를 개별적으로 또는 공동으로 실행하는 머신들의 집합을 포함하는 것으로 간주되어 야 한다. 그리고, 예시된 컴퓨팅 또는 모바일 디바이스 각각은 각각 적어도 버스 및/또는 마더보드, 하나 이상 의 제어기(예를 들어, 하나 이상의 CPU), 임시 데이터 저장을 포함할 수 있는 메인 메모리, 하나 이상의 유형의 네트워크 인터페이스, 영구 데이터 저장소를 포함할 수 있는 저장 시스템, 및/또는 이들의 임의의 조합을 포함 할 수 있다. 일부 다중 디바이스 실시예에서, 한 디바이스가 본 명세서에 설명된 방법의 일부를 완료한 다음 다 른 장치가 본 명세서에 설명된 방법의 다른 단계를 계속할 수 있도록 네트워크를 통해 다른 디바이스에 완료 결 과를 보낼 수 있다. 도 9는 또한 본 개시의 일부 실시예에 따른 예시적인 컴퓨팅 디바이스의 예시적인 부분을 도시한다. 디바 이스는 도시된 바와 같이 네트워크(들)에 통신 가능하게 결합될 수 있다. 디바이스는 적어도 버 스, 제어기(예를 들어, CPU), 메모리, 네트워크 인터페이스, 데이터 저장 시스템, 및 기타 컴포넌트들(이는 GPS 컴포넌트, I/O 컴포넌트 및 센서와 같은 모바일 또는 컴퓨팅 디바이스에서 찾을 수 있는 임의의 유형의 컴포넌트일 수 있음)을 포함한다. 다른 컴포넌트는 하나 이상의 디스플레이, 상이한 유형의 센서, 오디오 및/또는 시각적 입력/출력 디바이스, 추가 어플리케이션 특정 메모리, 하나 이상의 추가 제어기(예를 들어, GPU), 또는 이들의 임의의 조합을 포함할 수 있다. 버스는 제어기, 메모리 , 네트워크 인터페이스, 데이터 저장 시스템 및 다른 컴포넌트를 통신적으로 결합한다. 디 바이스는 버스(다중 버스를 포함할 수 있음)를 통해 서로 통신하는 적어도 제어기, 메모리 (예를 들어, 판독 전용 메모리(ROM), 플래시 메모리, 동기식 DRAM(SDRAM) 또는 램버스 DRAM(RDRAM)과 같 은 DRAM, 정적 랜덤 액세스 메모리(SRAM) 등), 및 데이터 저장 시스템을 포함하는 컴퓨터 시스템을 포함한 다. 다시 말해서, 도 9는 본 개시내용의 실시예가 동작할 수 있는 컴퓨터 시스템을 갖는 예시적인 디바이스의 블록도이다. 일부 실시예에서, 컴퓨터 시스템은 실행될 때 머신이 본 명세서에 논의된 방법론 중 임의의 하나 이상을 수행하게 하기 위한 명령어 세트를 포함할 수 있다. 이러한 실시예에서, 머신은 LAN, 인트라넷, 4G 또는 5G와 같은 모바일 무선 네트워크, 엑스트라넷, 및/또는 인터넷(예를 들어, 네트워크)의 다른 머신에 연결 될 수 있다(예를 들어, 네트워크 인터페이스를 통해 네트워킹됨). 머신은 피어-투-피어(peer-to-peer)(또 는 분산된) 네트워크 환경(예를 들어, 본 명세서에 설명된 피어-투-피어 네트워크)에서 피어 머신으로서 또는 클라우드 컴퓨팅 인프라 또는 환경에서 서버 또는 클라이언트 머신으로서 클라이언트-서버 네트워크 환경에서 서버 또는 클라이언트 머신의 용량(capacity)으로 작동할 수 있다.제어기는 마이크로프로세서, 중앙 처리 장치 등과 같은 하나 이상의 범용 처리 디바이스들을 나타낸다. 보 다 구체적으로, 처리 디바이스는 복잡한 명령 세트 컴퓨팅(CISC) 마이크로프로세서, 감소된 명령어 세트 컴퓨팅 (RISC) 마이크로프로세서, VLIW(Very Long Instruction Word) 마이크로프로세서, 단일 명령 다중 데이터 (SIMD), 다중 명령 다중 데이터(MIMD) 또는 다른 명령어 세트를 구현하는 프로세서, 또는 명령어 세트의 조합을 구현하는 프로세서일 수 있다. 제어기는 또한 하나 이상의 특수 목적 처리 디바이스, 예를 들어, 주문형 집적 회로(ASIC), 필드 프로그래밍 가능 게이트 어레이(FPGA), 디지털 신호 처리기(DSP), 네트워크 프로세서 등 일 수 있다. 제어기는 본 명세서에 논의된 동작 및 단계를 수행하기 위한 명령어를 실행하도록 구성된다. 제어기는 하나 이상의 통신 네트워크(네트워크(들)과 같은)를 통해 통신하기 위해 네트워크 인터페이 스와 같은 네트워크 인터페이스 디바이스를 더 포함할 수 있다. 데이터 저장 시스템은 본 명세서에 설명된 방법론 또는 기능 중 임의의 하나 이상을 구현하는 하나 이상의 명령어 또는 소프트웨어 세트가 저장되어 있는 머신 판독 가능 저장 매체(컴퓨터 판독 가능 매체라고도 함)를 포함할 수 있다. 명령어는 또한 컴퓨터 시스템에 의한 실행 동안 메모리 및/또는 제어기 내에 완전히 또는 적어도 부분적으로 상주할 수 있으며, 메모리 및 제어기는 또한 머신 판독가능 저장 매체를 구 성한다. 메모리는 디바이스의 메인 메모리이거나 이를 포함할 수 있다. 예시적인 실시예에서는 메모리, 제어기 및 데이터 저장 부분이 각각 단일 부분인 것으로 도시되었지만, 각 부분 은 명령어를 저장하고 그들의 개별 동작을 수행할 수 있는 단일 부분 또는 여러 부분들을 포함하는 것으로 간주 되어야 한다. \"머신 판독 가능 저장 매체\"라는 용어는 기계에 의해 실행되는 명령어 세트를 저장하거나 인코딩 할 수 있는 임의의 매체를 포함하고 머신이 본 개시의 방법론들 중 임의의 하나 이상을 수행하게 하는 것으로 간주된다. 따라서 \"머신 판독 가능 저장 매체\"라는 용어는 솔리드 스테이트 메모리, 광학 매체 및 자기 매체를 포함하지만 이에 제한되지 않는 것으로 간주되어야 한다. 도 10은 본 개시의 일부 실시예에 따른 루트 프로세스의 예시적인 대안을 포함하는 도 1, 4 및 6에 도시된 모바 일 디바이스를 도시한다. 도 10에 도시된 바와 같이, 모바일 디바이스는 제어기 및 메모리 및 루트 프로세스의 대안의 4개의 예시적인 케이스들을 포함한다(도 10에 도시된 예시적인 케이스들 1, 2, 3 및 4 참조). 도 10에 도시된 모바일 디바이스는 또한 도 1, 4 및 6에 도시된 모바일 디바이스의 양태를 포 함할 수 있다. 도 10에 도시된 제1 예시 케이스는 케이스 1이다. 케이스 1의 경우, 어플리케이션(606a)은 도 6에 도시된 바와 같이 도시된다. 어플리케이션(606a)은 다중 분기된 프로세스들로 분기되는 루트 프로세스를 포함합니다(예 를 들어, 분기된 프로세스들(610a, 610b, 610c) 참조). 도 10에 도시된 제2 예시 케이스는 케이스 2이다. 케이스 2에서, 어플리케이션은 루트 프로세스 \"a\"를 포 함하고 어플리케이션은 루트 프로세스 \"b\"를 포함한다. 케이스 2의 경우 여러 어플리케이션들에서 서로 다른 루트 프로세스들이 사용되는 것으로 도시된다. 이것은 다대일(many-to-one) 매핑 예시의 상위 집합인 다대 다(many-to-many) 매핑 예시이다. 어플리케이션에 대한 루트 프로세스는 둘 이상의 어플리케이션들에 의해 사용 될 수 있다. 또한, 일대다(one-to-many) 매핑 예시가 본 명세서에 설명된 일부 실시예에서 사용될 수 있다. 예 를 들어, 단일 어플리케이션에 의해 여러 개의 서로 다른 루트 프로세스들이 사용될 수 있다. 도 10에 도시된 바와 같이, 케이스 2에서, 어플리케이션의 루트 프로세스 \"a\"는 분기된 프로세스 1a 및 2a로 분기되고, 프로세스 1a는 어플리케이션에 의해 사용되고 프로세스 2a는 어플리케이션에 의해 사용된다. 또한 케이스 2에서 어플리케이션의 루트 프로세스 \"b\"는 분기된 프로세스 1b 및 2b로 분기되고 분기된 프로세 스 1b는 어플리케이션에서 사용되고 프로세스 2b는 어플리케이션에서 사용되고 있다. 도 10에 도시된 제3 예시 케이스는 케이스 3이다. 케이스 3에서, 어플리케이션은 루트 프로세스 \"a\"를 포 함하고 운영 체제(모바일 디바이스의 OS임)는 루트 프로세스 \"b\"를 포함한다. 케이스 3에서 루트 프 로세스 \"a\"는 적어도 분기된 프로세스들 1a 및 2로 분기되고 루트 프로세스 \"b\"는 적어도 분기된 프로세스 들1b 로 분기된다. 케이스 3의 경우 OS 생성 분기 프로세스(분기 프로세스 1b)는 하나 또는 여러 어플리케이션들에 의해 사용될 수 있다(예를 들어, 도 10은 어플리케이션에 의해 사용 중인 OS 생성 분기 프로세스를 도시 한다). 그리고 OS는 자체 프로세스를 수정 및/또는 생성하기 위해 임의의 어플리케이션으로부터 분기된 프로세스를 요청할 수 있다(예를 들어, 어플리케이션의 루트 프로세스 \"a\"에서 분기된 프로세스 2 참조, 이는 OS에서 사용 중인 것으로 도시됨). 그리고, OS 외의 다른 어플리케이션은 어플리케이션의 루트 프로 세스 \"a\"에서 분기된 프로세스 2를 사용할 수 있다. 도 10에 도시된 제4 케이스는 케이스 4이다. 케이스 4에서, 어플리케이션은 루트 프로세스 \"a\"를 포함하 고 어플리케이션은 루트 프로세스 \"b\"를 포함한다. 케이스 4의 경우, 분기된 프로세스 1 및 2는 어플리케 이션의 루트 프로세스 \"a\"에서 분기되고 적어도 분기된 프로세스 1은 어플리케이션의 루트 프로세 스 \"b\"에서 분기된다. 케이스 4는 서로 다른 어플리케이션들로부터 분기된 두 프로세스들을 하나의 분기된 프로 세스로 병합하는 것을 보여준다(예를 들어, 분기된 프로세스 1 참조). 일부 예에서 다른 어플리케이션들로부터 분기된 프로세스들은 결합되고 병합된 분기된 프로세스로 병합되는 다른 분기된 프로세스일 수 있다. 일부 다른 예에서, 병합되는 분기된 프로세스들은 동일한 프로세스 및/또는 데이터를 포함할 수 있다. 도 10의 케이스 4에 도시된 병합의 구현은 분기된 프로세스의 병합을 포함하는 특수 분기 프로세스를 포함할 수 있는 병합된 분기를 통해 수행될 수 있다. 특수 분기 프로세스는 OS 시스템 콜일 수 있다. 병합을 통한 특수 분기는 하나 이상의 프 로세스를 입력으로 사용하고(예를 들어, 각각 바이트코드로 표시됨) 프로세스(들)를 하나의 참조된 프로세스로 병합할 수 있다. 이는 병합 스키마(merge schema)(예를 들어, XML 파일에 설명된 병합 스키마)를 사용할 수 있 다. 병합 스키마는 바이트코드 및 데이터 섹션을 가리킬 수 있으며 각 섹션은 특정 함수 콜 또는 작업을 나타낼 수 있다. 병합 스키마는 또한 각 섹션의 병합에 대한 명령어를 제공할 수 있다(예를 들어, 제1 프로세스의 관련 섹션을 제2 프로세스의 하나로 대체하거나 제1 프로세스 A에 삽입 등). 이전의 상세한 설명의 일부는 컴퓨터 메모리 내의 데이터 비트에 대한 연산의 알고리즘 및 기호 표현의 관점에 서 제시되었다. 이러한 알고리즘 설명 및 표현은 데이터 처리 기술 분야의 기술자가 자신의 작업 내용을 해당 기술 분야의 다른 사람에게 가장 효과적으로 전달하기 위해 사용하는 방법이다. 알고리즘은 본 명세서에서 일반 적으로 원하는 결과로 이어지는 자체 일관된 작업 시퀀스로 간주된다. 작업은 물리량의 물리적 조작이 필요한 작업이다. 일반적으로 반드시 그런 것은 아니지만 이러한 양은 저장, 결합, 비교 및 조작할 수 있는 전기 또는 자기 신호의 형태를 취한다. 주로 일반적인 사용을 위해 이러한 신호를 비트, 값, 요소, 기호, 문자, 용어, 숫 자 등으로 지칭하는 것이 때때로 편리한 것으로 입증되었다. 그러나 이러한 모든 용어 및 유사한 용어는 적절한 물리량과 관련되어야 하며 이러한 양에 적용되는 편리한 라 벨일 뿐이라는 점을 염두에 두어야 한다. 본 개시는 컴퓨터 시스템의 레지스터 및 메모리 내에서 물리적(전자적) 수량으로 표시된 데이터를 컴퓨터 시스템 메모리 또는 레지스터 또는 기타 그러한 정보 저장 시 스템 내에서 물리적 수량으로 유사하게 표시되는 다른 데이터로 조작하고 변환하는 컴퓨터 시스템 또는 유사한 전자 컴퓨팅 디바이스의 동작 및 프로세스를 참조할 수 있다. 본 개시는 또한 본 명세서의 동작을 수행하기 위한 장치에 관한 것이다. 이 장치는 의도된 목적을 위해 특별히 구성되거나 컴퓨터에 저장된 컴퓨터 프로그램에 의해 선택적으로 활성화되거나 재구성되는 범용 컴퓨터를 포함 할 수 있다. 이러한 컴퓨터 프로그램은 이에 제한되는 것은 아니지만 플로피 디스크, 광 디스크, CD-ROM 및 광 자기 디스크, 판독 전용 메모리(ROM), 랜덤 액세스 메모리(RAM), EPROM, EEPROM, 자기 또는 광학 카드, 또는 컴 퓨터 시스템 버스에 각각 연결된 전자 명령을 저장하는 데 적합한 모든 유형의 매체와 같은 컴퓨터 판독 가능 저장 매체에 저장될 수 있다. 본 명세서에 제시된 알고리즘 및 디스플레이는 본질적으로 특정 컴퓨터 또는 기타 장치와 관련이 없다. 다양한 범용 시스템이 본 명세서의 교시에 따른 프로그램과 함께 사용될 수 있거나, 방법을 수행하기 위해 보다 전문화 된 장치를 구성하는 것이 편리한 것으로 입증될 수 있다. 이러한 다양한 시스템의 구조는 아래 설명에 설명된 대로 나타난다. 또한, 본 개시는 임의의 특정 프로그래밍 언어를 참조하여 설명되지 않는다. 다양한 프로그래밍 언어가 본 명세서에 설명된 바와 같이 본 개시내용의 교시를 구현하기 위해 사용될 수 있다는 것이 이해될 것이다. 본 개시내용은 명령어가 저장된 머신 판독가능 매체를 포함할 수 있는 컴퓨터 프로그램 제품 또는 소프트웨어로 서 제공될 수 있으며, 이는 본 개시에 따른 프로세스를 수행하기 위해 컴퓨터 시스템(또는 다른 전자 디바이 스)을 프로그래밍하는 데 사용될 수 있다. 머신 판독 가능 매체는 머신(예를 들어, 컴퓨터)에 의해 판독 가능한 형태로 정보를 저장하기 위한 임의의 메커니즘을 포함한다. 일부 실시예에서, 머신 판독가능(예를 들어, 컴퓨터 판독가능) 매체는 머신(예를 들어, 컴퓨터) 판독가능 저장 매체, 예를 들어, 판독 전용 메모리(\"ROM\"), 랜덤 액 세스 메모리(\"RAM\"), 자기 디스크 저장 매체, 광 저장 매체, 플래시 메모리 부품 등을 포함한다. 전술한 명세서에서, 본 개시의 실시예들은 그 특정 예시적인 실시예들을 참조하여 설명되었다. 다음의 청구범위 에 기재된 본 개시내용의 실시형태의 보다 넓은 사상 및 범위를 벗어나지 않고 다양한 변형이 이루어질 수 있음 이 명백할 것이다. 따라서, 본 명세서 및 도면은 제한적인 의미가 아니라 예시적인 의미로 간주되어야 한다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10"}
{"patent_id": "10-2022-7010631", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시내용은 이하에 주어진 상세한 설명 및 본 개시내용의 다양한 실시예의 첨부 도면으로부터 보다 완전하게 이해될 것이다. 도 1, 4 및 6은 본 개시내용의 일부 실시예에 따른, 상이한 어플리케이션 프로세스들에 대한 초기 데이터 분배 를 구현할 수 있는 예시적인 모바일 디바이스를 도시한다. 도 2, 3, 5, 7 및 8은 본 개시내용의 일부 실시예에 따른, 도 1, 4 및 6에 도시된 모바일 디바이스에 의해 수행 될 수 있는 예시적인 동작의 흐름도를 도시한다. 도 9는 본 개시내용의 일부 실시예에 따른, 상이한 어플리케이션 프로세스들에 대한 초기 데이터 분배를 구현할 수 있는 예시적인 컴퓨팅 디바이스를 도시한다. 도 10은 본 개시내용의 일부 실시예에 따른, 루트 프로세스의 예시적인 대안을 포함하는 도 1, 4 및 6에 도시된 예시적인 모바일 디바이스를 도시한다."}
