{"patent_id": "10-2017-0148004", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2019-0052367", "출원번호": "10-2017-0148004", "발명의 명칭": "메모리 시스템 및 그것의 동작방법", "출원인": "에스케이하이닉스 주식회사", "발명자": "김형섭"}}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "메모리 시스템에 있어서,복수의 동작메모리들을 포함하는 메모리 블레이드; 및컨트롤러를 구비하고,상기 컨트롤러는발생된 타겟 워크로드를 처리하기 위하여 사용되는 동작메모리의 평균 사용량인 제 1 정보를 필드로 하며 워크로드를 엔트리로 하는 DB를 저장하는 DB 메모리;처리 요청된 현재 타겟 워크로드에 대응하며, 상기 DB에 저장된 상기 제 1 정보의 값에 기초하여 상기 현재 타겟 워크로드의 처리를 위해 동작메모리의 사용량을 할당하는 할당부; 및상기 현재 타겟 워크로드의 처리가 완료된 이후에, 상기 현재 타겟 워크로드의 처리에 할당된 동작메모리의 평균 사용량으로 상기 제 1 정보의 값을 업데이트하는 모니터를 포함하는 메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 할당부는사전 설정된 오버 프로비젼(over-provision) 값을 반영하여 동작메모리의 사용량을 할당하는메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 2 항에 있어서,상기 할당부는상기 현재 타겟 워크로드를 처리하기 위하여 동작메모리의 사용량에 대하여 추가적인 할당 요청이 있는 경우,사전 설정된 동작메모리의 사용량을 추가 할당하는메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 3 항에 있어서,상기 DB는 상기 현재 타겟 워크로드를 처리하기 위하여 사용된 최종적인 동작메모리 사용량인 제 2 정보를 필드로 더 포함하고 상기 모니터부는상기 타겟 워크로드의 처리가 완료된 이후에, 상기 현재 타켓 워크로드의 처리에 할당된 최종적인 동작메모리사용량으로 상기 제 2 정보의 값을 업데이트하는공개특허 10-2019-0052367-2-메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4 항에 있어서,상기 DB는 상기 현재 타겟 워크로드를 처리한 횟수인 제 3 정보를 필드로 더 포함하고,상기 모니터부는상기 현재 타겟 워크로드의 처리가 완료된 이후에, 상기 현재 타겟 워크로드의 처리 횟수로 상기 제 3 정보의값을 업데이트하는메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 5 항에 있어서,상기 모니터부는상기 제 1 정보의 값 내지 상기 제 3 정보의 값에 기초하여 상기 제 1 정보의 값을 업데이트하는메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 6 항에 있어서,상기 모니터부는상기 제 2 정보의 값이 사전 설정된 값의 범위 밖에 있는 경우 상기 제 1 정보의 값을 업데이트하는메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1 항에 있어서,상기 할당부는 상기 엔트리에 상기 처리 요청된 타겟 워크로드가 등록되어 있지 아니한 경우, 상기 타겟 워크로드의 처리를 위하여 사전 설정된 값으로 동작메모리 사용량을 할당하는메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1 항에 있어서,상기 복수의 동작메모리들은 사전 설정된 기준에 따라 제 1 리드 타입 메모리, 제 2 라이트 타입 메모리 및 제3 노멀 타입 메모리로 구분되는메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "공개특허 10-2019-0052367-3-제 9 항에 있어서,상기 사전 설정된 기준은 해당 동작을 수행하기 위하여 소요되는 클록 수인메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 10 항에 있어서,상기 DB는 상기 타겟 워크로드를 처리하기 위하여 수행된 리드 요청에 대한 라이트 요청의 비율인 제 4 정보를필드로 더 포함하며,상기 할당부는 처리 요청된 상기 현재 타겟 워크로드에 대응하며 상기 DB에 저장된 상기 제 4 정보의 값에 기초하여 상기 현재 타겟 워크로드의 처리를 위해 상기 복수의 동작메모리들 중 어느 하나를 할당하는메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 11 항에 있어서,상기 모니터는상기 타겟 워크로드의 처리가 완료된 이후에, 상기 현재 타겟 워크로드를 처리하기 위하여 수행된 리드 요청에대한 라이트 요청의 비율로 상기 제 4 정보의 값을 업데이트하는메모리 시스템."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "복수의 동작메모리들을 포함하는 메모리 블레이드와 컨트롤러로 구성된 메모리 시스템의 동작방법에 있어서,발생된 타겟 워크로드를 처리하기 위하여 사용되는 동작메모리의 평균 사용량인 제 1 정보를 필드로 하고, 워크로드를 엔트리로 하는 DB에 처리 요청된 타겟 워크로드에 대응하는 상기 제 1 정보의 값이 저장되어있는지 확인하는 제 1 단계;처리 요청된 현재 타겟 워크로드에 대응하며, 상기 DB에 저장된 상기 제 1 정보의 값에 기초하여 상기 현재 타겟 워크로드의 처리를 위한 동작메모리의 사용량을 할당하는 제 2 단계;상기 현재 타겟 워크로드 처리가 완료된 이후에, 상기 현재 타겟 워크로드의 처리에 할당된 동작메모리의 평균사용량으로 상기 제 1 정보의 값을 업데이트하는 제 3 단계로 구성되는 메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 13 항에 있어서,상기 제 2 단계는사전 설정된 오버 프로비젼(over-provision) 값을 반영하여 동작메모리의 사용량을 할당하는메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "공개특허 10-2019-0052367-4-제 14 항에 있어서,상기 현재 타겟 워크로드의 처리를 위하여 동작메모리의 사용량에 대하여 추가적인 할당 요청이 있는 경우, 사전 설정된 동작메모리의 사용량을 추가 할당하는 단계를더 포함하는 메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 15 항에 있어서, 상기 DB는 상기 현재 타겟 워크로드를 처리하기 위하여 사용된 최종적인 동작메모리의 사용량인 제 2 정보를 필드로 더 포함하는상기 제 3 단계는상기 타겟 워크로드의 처리가 완료된 이후에, 상기 현재 타켓 워크로드의 처리에 할당된 최종적인 동작메모리사용량으로 상기 제 2 정보의 값을 업데이트하는메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제 16 항에 있어서, 상기 DB는 상기 타겟 워크로드를 처리한 횟수인 제 3 정보를 필드로 더 포함하는상기 제 3 단계는상기 현재 타겟 워크로드의 처리가 완료된 이후에, 상기 현재 타겟 워크로드의 처리 횟수로 상기 제 3 정보의값을 업데이트하는메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제 17 항에 있어서,상기 제 3 단계는상기 제 1 정보의 값 내지 상기 제 3 정보의 값에 기초하여 상기 제 1 정보의 값을 업데이트하는메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 18 항에 있어서,상기 제 3 단계는상기 제 2 정보의 값이 사전 설정된 값의 범위 밖에 있는 경우 상기 제 1 정보의 값을 업데이트하는메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제 13 항에 있어서,공개특허 10-2019-0052367-5-상기 제 2 단계는상기 엔트리에 상기 처리 요청된 타겟 워크로드가 등록되어 있지 아니한 경우, 상기 타겟 워크로드의 처리를 위하여 사전 설정된 값으로 동작메모리 사용량을 할당하는메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제 13 항에 있어서,상기 DB는 상기 타겟 워크로드를 처리하기 위하여 수행된 리드 요청에 대한 라이트 요청의 비율인 제 4 정보를필드로 더 포함하며,상기 제 2 단계는처리 요청된 상기 현재 타겟 워크로드에 대응하며 상기 DB에 저장된 상기 제 4 정보의 값에 기초하여 상기 현재타겟 워크로드의 처리를 위해 상기 복수의 동작메모리들 중 어느 하나를 할당하며,상기 복수의 동작메모리들은 사전 설정된 기준에 따라 제 1 리드 타입 메모리, 제 2 라이트 타입 메모리 및 제3 노멀 타입 메모리로 구분되고,상기 사전 설정된 기준은 해당 동작을 수행하기 위하여 소요되는 클록 수인메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제 21 항에 있어서,상기 제 3 단계는상기 타겟 워크로드의 처리가 완료된 이후에, 상기 현재 타겟 워크로드를 처리하기 위하여 수행된 리드 요청에대한 라이트 요청의 비율로 상기 제 4 정보의 값을 업데이트하는메모리 시스템의 동작방법."}
{"patent_id": "10-2017-0148004", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명의 실시 예에 따른 메모리 시스템에 있어서, 복수의 동작메모리들을 포함하는 메모리 블레이드; 및 컨트 롤러를 구비하고, 상기 컨트롤러는 발생된 타겟 워크로드를 처리하기 위하여 사용되는 동작메모리의 평균 사용량 인 제 1 정보를 필드로 하며 워크로드를 엔트리로 하는 DB를 저장하는 DB 메모리; 처리 요청된 현재 타겟 워크로 드에 대응하며, 상기 DB에 저장된 상기 제 1 정보의 값에 기초하여 상기 현재 타겟 워크로드의 처리를 위해 동작 메모리의 사용량을 할당하는 할당부; 및 상기 현재 타겟 워크로드의 처리가 완료된 이후에, 상기 현재 타겟 워크 로드의 처리에 할당된 동작메모리의 평균 사용량으로 상기 제 1 정보의 값을 업데이트하는 모니터를 포함할 수 있다."}
{"patent_id": "10-2017-0148004", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 메모리 시스템에 관한 것으로, 보다 구체적으로는 효율적인 데이터 처리를 위한 메모리 시스템 및 그 것의 동작방법에 관한 것이다."}
{"patent_id": "10-2017-0148004", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "데이터는 4차 산업혁명 시대 기업들의 비즈니스에 가장 중요한 자산이 되고 있으며, 이에 대규모 데이터를 빠르 게 전송 및 분석하도록 지원하는 최신 기술에 대한 수요가 점차 증가하고 있다. 예를 들어, 인공지능, 자율주행, 로봇, 헬스케어, 가상현실(virtual reality, VR)/증강현실(augmented reality, AR), 스마트홈 등이 확대됨에 따라 서버나 데이터 센터에 대한 수요의 증가가 예상되고 있다. 레거시(legacy) 데이터 센터는 자원들(예; 컴퓨팅, 네트워킹, 스토리지)을 하나의 장비 내에 포함시키는 구조였 다. 그러나 미래의 대용량 데이터 센터는 자원들을 각각 별개로 구성하고, 논리적으로 자원들을 재구성하는 구 조를 가질 수 있다. 예를 들어, 대용량 데이터 센터는 자원들을 각각 랙(rack) 수준에서 모듈화하고, 용도에 따 라 자원들을 재구성하여 공급할 수 있는 구조를 가질 수 있다. 따라서 미래의 대용량 데이터 센터에 사용하기적합한 통합형 스토리지 또는 메모리 디바이스가 요구되고 있다."}
{"patent_id": "10-2017-0148004", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 복수의 동작들 각각에 최적화된 동작메모리에 최적의 초기 동작메모리 사용량을 할당함으로써 효율적 인 데이터 처리를 할 수 있는 메모리 시스템 및 그의 동작 방법에 대하여 제안한다."}
{"patent_id": "10-2017-0148004", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 실시 예들에 따른 메모리 시스템에 있어서, 복수의 동작메모리들을 포함하는 메모리 블레이드; 및 컨 트롤러를 구비하고, 상기 컨트롤러는 발생된 타겟 워크로드를 처리하기 위하여 사용되는 동작메모리의 평균 사 용량인 제 1 정보를 필드로 하며 워크로드를 엔트리로 하는 DB를 저장하는 DB 메모리; 처리 요청된 현재 타겟 워크로드에 대응하며, 상기 DB에 저장된 상기 제 1 정보의 값에 기초하여 상기 현재 타겟 워크로드의 처리를 위 해 동작메모리의 사용량을 할당하는 할당부; 및 상기 현재 타겟 워크로드의 처리가 완료된 이후에, 상기 현재 타겟 워크로드의 처리에 할당된 동작메모리의 평균 사용량으로 상기 제 1 정보의 값을 업데이트하는 모니터를 포함할 수 있다. 본 발명의 실시 예에 따른 메모리 시스템의 동작방법에 있어서, 발생된 타겟 워크로드를 처리하기 위하여 사용 되는 동작메모리의 평균 사용량인 제 1 정보를 필드로 하고, 워크로드를 엔트리로 하는 DB에 처리 요청된 타겟 워크로드에 대응하는 상기 제 1 정보의 값이 저장되어있는지 확인하는 제 1 단계; 처리 요청된 현재 타겟 워크 로드에 대응하며, 상기 DB에 저장된 상기 제 1 정보의 값에 기초하여 상기 현재 타겟 워크로드의 처리를 위한 동작메모리의 사용량을 할당하는 제 2 단계; 상기 현재 타겟 워크로드 처리가 완료된 이후에, 상기 현재 타겟 워크로드의 처리에 할당된 동작메모리의 평균 사용량으로 상기 제 1 정보의 값을 업데이트하는 제 3 단계로 구 성되는 구성될 수 있다."}
{"patent_id": "10-2017-0148004", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 실시 예에 따르면, 복수의 동작들 각각에 최적화된 동작메모리에 할당하여 효율적인 데이터 처리가 가능하며, 최적의 동작메모리 사용량의 할당으로 추가 할당에 따른 대기시간을 단축시킬 수 있다."}
{"patent_id": "10-2017-0148004", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 본 발명에 따른 바람직한 실시 예를 첨부한 도면을 참조하여 상세히 설명한다. 하기의 설명에서는 본 발 명에 따른 동작을 이해하는데 필요한 부분만이 설명되며 그 이외 부분의 설명은 본 발명의 요지를 흩뜨리지 않 도록 생략될 것이라는 것을 유의하여야 한다. 이하, 본 발명에 따른 바람직한 실시 예를 첨부한 도면을 참조하여 상세히 설명한다. 하기의 설명에서는 본 발 명에 따른 동작을 이해하는데 필요한 부분만이 설명되며 그 이외 부분의 설명은 본 발명의 요지를 흩뜨리지 않 도록 생략될 것이라는 것을 유의하여야 한다. 도 1은 데이터 처리 시스템을 도시하는 도면이다. 도 1을 참조하면, 데이터 처리 시스템은 다수의 컴퓨 팅 랙들(computing racks)과 관리 인터페이스(management interface, 30), 그리고 이들 사이의 통신이 가능하 도록 하는 네트워크(network, 40)을 포함할 수 있다. 이러한 랙스케일 구조(rack-scale architecture)를 가지 는 데이터 처리 시스템은 대용량 데이터 처리를 위한 데이터 센터 등에 사용될 수 있다. 다수의 컴퓨팅 랙들 각각은 단독으로 하나의 컴퓨팅 디바이스(computing device)를 구현할 수 있다. 이를 대신 하여, 다수의 컴퓨팅 랙들 각각은 다른 컴퓨팅 랙들과의 조합으로 하나의 컴퓨팅 디바이스를 구현할 수 있다. 이러한 컴퓨팅 랙들의 구체적인 구성 및 동작에 대한 설명은 후술될 것이다. 관리 인터페이스은 사용자가 데이터 처리 시스템 10을 조정, 운영 또는 관리할 수 있도록 하는 인터액티브 인터페이스(interactive interface)를 제공할 수 있다. 관리 인터페이스는 컴퓨터, 멀티프로세서 시스템, 서버, 랙마운트(rack-mount) 서버, 블레이드(blade) 서버, 랩탑(lap-top) 컴퓨터, 노트북 컴퓨터, 태블릿 컴퓨 터, 웨어러블 컴퓨팅 디바이스, 네트워크 기기, 웹 기기, 분산 컴퓨팅 시스템, 프로세서 기반 시스템, 및/또는 소비자 전자 기기를 포함하는, 임의 유형의 연산 디바이스로서 구현될 수 있다. 일부 실시 예들에서, 관리 인터페이스은 컴퓨팅 랙들에 의해 수행될 수 있는 연산 기능들이나, 관리 인터페 이스에 의해 수행될 수 있는 사용자 인터페이스 기능들을 가지는 분산 시스템에 의해 구현될 수 있다. 다 른 일부 실시 예들에서, 관리 인터페이스은 네트워크을 통하여 분산된 다중 컴퓨팅 디바이스들에 의해 구성되고 클라우드(cloud)로서 동작하는 가상 서버(virtual server)에 의해 구현될 수 있다. 관리 인터페이스 은 프로세서, 입력/출력 서브시스템, 메모리, 데이터 스토리지 디바이스 및 통신 회로를 포함할 수 있다. 네트워크은 컴퓨팅 랙들과 관리 인터페이스 사이 및/또는 컴퓨팅 랙들 사이에서의 데이터를 송수신할 수 있다. 네트워크은 적절한 수의 다양한 유선 및/또는 유선 네트워크들에 의해 구현될 수 있다. 예를 들어, 네트워크은 유선 또는 무선 LAN(local area network), WAN(wide area network) 셀룰라 네트워크, 및 /또는 인터넷과 같이 공개적으로 억세스 가능한 글로벌 네트워크(publicly-accessible, global network)에 의 해 구현되거나 이를 포함할 수 있다. 추가적으로, 네트워크은 보조적인 컴퓨터들, 라우터(router)들 및 스 위치들과 같은 적절한 수의 보조적인 네트워크 디바이스들을 포함할 수 있다. 도 2는 본 출원의 실시 예에 따른 랙 구조를 가지는 컴퓨팅 디바이스를 도시하는 도면이다. 도 2를 참조하면, 컴퓨팅 랙 은 구성요소들의 구조, 형태 및 호칭 등에 제한되는 것은 아니지만, 다양한 형 태의 구성요소들을 포함할 수 있다. 예를 들어, 컴퓨팅 랙 은 다수의 드로워(drawer)들(21 내지 29)를 포함 할 수 있다. 다수의 드로워들 (21 내지 29) 각각은 다수의 모듈(module)들을 포함할 수 있다. 다수의 모듈들 각각은 다수의 블레이드(blade)들을 포함할 수 있다. 다양한 실시 예들에 있어서, 컴퓨팅 랙은 적절한 수의 연산 블레이드(compute blade), 메모리 블레이드 (memory blade) 및/또는 상호접속 블레이드(interconnect blade)의 조합에 의해 구현될 수 있다. 여기서는 컴 퓨팅 랙이 다수의 블레이드들의 조합에 의해 구현되는 것으로 정의되고 있지만, 이를 대신하여, 드로워들, 모듈들, 트레이들, 보드들, 샷시들 또는 유닛들 등의 다양한 이름으로 구현되는 것으로 정의될 수 있음에 유의 하여야 한다. 이러한 컴퓨팅 랙의 구성요소들은 구현의 편의상 기능별로 분류 및 구별되는 구조를 가질 수 있다. 제한되는 것은 아니지만, 컴퓨팅 랙은 상단부터 상호접속 블레이드, 연산 블레이드, 메모리 블레이 드의 순서로 분류된 구조를 가질 수 있다. 이러한 컴퓨팅 랙 및 이에 의해 구현되는 컴퓨팅 디바이스는 \"랙 스케일 시스템(rack-scale system)\" 또는\"분류 시스템(disaggregated system)\"으로 명명될 수 있다. 다양한 실시 예들에 있어서, 컴퓨팅 디바이스는 하나의 컴퓨팅 랙에 의해 구현될 수 있다. 이를 대신하여, 컴퓨팅 디바이스는 2개 이상의 컴퓨팅 랙들에 포함되는 모든 구성요소들에 의해 구현되거나, 2개 이상의 컴퓨팅 랙들에 포함되는 일부 구성요소들의 조합에 의해 구현되거나, 하나의 컴퓨팅 랙에 포함되는 일부 구성요소 들에 의해 구현될 수 있다. 다양한 실시 예들에 있어서, 컴퓨팅 디바이스는 컴퓨팅 랙에 포함되는 적절한 수의 연산 블레이드, 메모리 블레이드 및 상호접속 블레이드(interconnect blade)의 조합에 의해 구현될 수 있다. 예를 들어, 컴퓨팅 디바이 스(20A)는 2개의 연산 블레이드들, 3개의 메모리 블레이드들 및 1개의 상호접속 블레이드에 의해 구현될 수 있 다. 다른 예로, 컴퓨팅 디바이스(20B)는 3개의 연산 블레이드들, 2개의 메모리 블레이드들 및 1개의 상호접속 블레이드에 의해 구현될 수 있다. 또 다른 예로, 컴퓨팅 디바이스(20C)는 1개의 연산 블레이드들, 4개의 메모리 블레이드들 및 1개의 상호접속 블레이드에 의해 구현될 수 있다. 비록 도 2에서는 컴퓨팅 랙이 적절한 수의 연산 블레이드, 메모리 블레이드 및/또는 상호접속 블레이드의 조합에 의해 구현되는 경우를 도시하고 있지만, 컴퓨팅 랙은 통상의 서버 등에서 확인될 수 있는, 파워 시 스템, 냉각 시스템, 입력/출력 디바이스들과 같은 추가적인 구성요소들을 포함할 수 있다. 도 3은 본 출원의 실시 예에 따른 컴퓨팅 디바이스의 블록 구성을 도시하는 도면이다. 도 3을 참조하면, 컴퓨팅 디바이스는 다수의 연산 블레이드들(compute blades, 200), 다수의 메모리 블레이드들 (memory blades, 400) 및 상호접속 블레이드(interconnect blade, 300)를 포함할 수 있다. 다수의 연산 블레 이드들은 풀드 연산 블레이드(pooled compute blades), 풀드 연산 시스템 등으로 불리울 수 있다. 유사하 게, 다수의 메모리 블레이드들은 풀드 메모리 블레이드(pooled memory blade), 풀드 메모리 시스템 등으로 불리 울 수 있다. 여기서는 컴퓨팅 디바이스가 다수의 블레이드들의 조합에 의해 구현되는 것으로 정의되고 있지만, 이를 대신하여 드로워들, 모듈들, 트레이들, 보드들, 샷시들 또는 유닛들 등의 다양한 이름으로 구현되는 것으 로 정의될 수 있음에 유의하여야 한다. 다수의 연산 블레이드들 각각은 하나 또는 그 이상의 프로세서, 프로세싱/컨트롤 회로, 또는 중앙처리장치 (central processing unit, CPU)와 같은 프로세싱 요소를 포함할 수 있다. 다수의 메모리 블레이드들 각각은 다수의 휘발성 메모리(volatile memory)들 및/또는 비휘발성 메모리 (nonvolatile memory)들과 같은 다양한 형태의 메모리들을 포함할 수 있다. 예를 들어, 다수의 메모리 블레이 드들 다수의 DRAM(Dynamic Random Access Memory)들, 플래시 메모리(flash memory)들, 메모리 카드들, 하 드 디스크 드라이브(hard disk drive, HDD)들, 솔리드 스테이트 드라이브(solid state drive, SSD)들, 및/또는 이들의 조합들을 포함할 수 있다. 다수의 메모리 블레이드들 각각은 연산 블레이드들 각각에 포함되는 하나 이상의 프로세싱 요소에 의 해 분할되거나, 할당되거나, 또는 지정되어 사용될 수 있다. 또한 다수의 메모리 블레이드들 각각은 연산 블레이드들에 의해 초기화 및/또는 수행될 수 있는 하나 이상의 오퍼레이팅 시스템(operating system, O S)들을 저장할 수 있다. 상호접속 블레이드은 연산 블레이드들 각각에 포함되는 하나 이상의 프로세싱 요소에 의해 분할, 할 당 또는 지정되어 사용될 수 있는, 임의의 통신 회로, 디바이스, 또는 이들의 결합에 의해 구현될 수 있다. 예 를 들어, 상호접속 블레이드은 임의 개수의 네트워크 인터페이스 포트들, 카드들, 또는 스위치들로서 구현 될 수 있다. 상호접속 블레이드은 통신을 실행시키기 위한, 하나 이상의 유선 또는 유선 통신 기술들과 관 련된 프로토콜들을 사용할 수 있다. 예를 들어, 상호접속 블레이드은 PCIe(Peripheral Component Interconnect Express), QPI(QuickPath Interconnect), 이더넷(Ethernet) 등과 같은 프로토콜들에 따라 연산 블레이드들과 메모리 블레이드들 사이의 통신을 지원할 수 있다. 도 4는 본 출원의 실시 예에 따른 컴퓨터 블레이드의 구성을 도시하는 도면이다. 도 4를 참조하면, 컴퓨터 블레이드은 하나 이상의 중앙처리장치(central processing unit, CPU, 210), 하 나 이상의 로컬 메모리(local memory, 220) 및 입출력(input/output, I/O) 인터페이스(interface, 230)를 포함 할 수 있다. CPU은 도 3에 도시된 다수의 메모리 블레이드들 중에서 사용하기 위한 적어도 하나의 메모리 블레이 드를 분할, 할당 또는 지정할 수 있다. 또한 CPU은 분할, 할당 또는 지정된 적어도 하나의 메모리 블레이 드를 초기화하고, 이들을 통해 데이터의 리드 동작, 라이트(또는 프로그램) 동작 등을 수행할 수 있다. 로컬 메모리은 CPU의 동작 수행 중에 필요한 데이터를 저장할 수 있다. 다양한 실시 예들에 있어서, 하나의 로컬 메모리은 하나의 CPU에 일대일 대응하는 구조를 가질 수 있다. I/O 인터페이스은 도 3의 상호접속 블레이드을 통한 CPU과 메모리 블레이드들 사이에서의 인터페이싱을 지원할 수 있다. I/O 인터페이스 은 하나 이상의 유선 또는 유선 통신 기술들과 관련된 프로토콜들을 사용하여, CPU으로부터 상호접속 블레이드으로의 송신 데이터를 출력하고, 상호접속 블레이 드으로부터 CPU으로의 수신 데이터를 입력할 수 있다. 예를 들어, I/O 인터페이스는 PCIe(Peripheral Component Interconnect Express), QPI(QuickPath Interconnect), 이더넷(Ethernet) 등과 같 은 프로토콜들에 따라 CPU 과 상호접속 블레이드 사이의 통신을 지원할 수 있다. 도 5는 본 출원의 실시 예에 따른 메모리 블레이드의 구성을 도시하는 도면들이다. 도 5를 참조하면, 메모리 블레이드은 컨트롤러와 다수의 메모리들 을 포함할 수 있다. 다수의 메모리들은 컨트롤러의 제어에 따라 데이터를 저장(또는 라이트)하고, 저장된 데이터를 출력(또는 리 드)할 수 있다. 다수의 메모리들은 제1 그룹의 메모리들(420A), 제2 그룹의 메모리들(420B) 및 제3 그룹의 메모리들(420C)를 포함할 수 있다. 제1 그룹의 메모리들(420A), 제2 그룹의 메모리들(420B) 및 제3 그룹의 메모 리들(420C)은 서로 동일한 특성을 가질 수도 있고, 서로 다른 특성을 가질 수 있다. 다양한 실시 예들에 있어서, 제1 그룹의 메모리들(420A), 제2 그룹의 메모리들(420B) 및 제3 그룹의 메모리들(420C)은 저장 용량 (capacity) 또는 레이턴시(latency) 측면에서 서로 다른 특성을 가지는 메모리들일 수 있다. 컨트롤러 410은 데이터 컨트롤러(data controller) 510, 메모리 컨트롤러들(memory controller, MC) 520A- 520C, 및 I/O 인터페이스 530을 포함할 수 있다. 데이터 컨트롤러 510은 도 3의 연산 블레이드들 200과 다수의 메모리들 420 사이에서 송수신되는 데이터를 제어 할 수 있다. 예를 들어, 라이트 요청 또는 커맨드에 응답하여, 데이터 컨트롤러 510은 연산 블레이드들 200로부 터의 라이트를 위한 데이터를 수신하고, 이 데이터를 다수의 메모리들 420중에서 해당하는 메모리에 라이트하는 라이트 동작을 제어할 수 있다. 다른 예로, 리드 요청 또는 커맨드에 응답하여, 데이터 컨트롤러 510은 연산 블 레이드들 200으로부터 다수의 메모리들 420중에서 특정 메모리에 저장된 데이터를 리드하고, 리드 데이터를 연 산 블레이드들 200중에서 해당하는 연산 블레이드로 출력하는 리드 동작을 제어할 수 있다. 메모리 컨트롤러들 520A-520C는 데이터 컨트롤러 510과 다수의 메모리들 420의 사이에 위치하며, 이들 사이에서 의 인터페이싱을 지원할 수 있다. 메모리 컨트롤러들 520은 다수의 메모리들 420에 포함되는 제1 그룹의 메모리 들 420A, 제2 그룹의 메모리들 420B 및 제3 그룹의 메모리들 420C를 각각에 대응하는 메모리 컨트롤러(iMC0) 520A, 메모리 컨트롤러(iMC1) 520B, 메모리 컨트롤러(iMC2) 520C를 포함할 수 있다. 메모리 컨트롤러(iMC0) 520A는 데이터 컨트롤러 510과 제1 그룹의 메모리들 420A의 사이에 위치하며, 이들 사이에서의 데이터 송수신을 지원할 수 있다. 메모리 컨트롤러(iMC1) 520B는 데이터 컨트롤러 510과 제2 그룹의 메모리들 420B의 사이에 위 치하며, 이들 사이에서의 데이터 송수신을 지원할 수 있다. 메모리 컨트롤러(iMC2) 520C는 데이터 컨트롤러 510 과 제3 그룹의 메모리들 420C의 사이에 위치하며, 이들 사이에서의 데이터 송수신을 지원할 수 있다. 제3 그룹 의 메모리들 420C가 플래시 메모리인 경우, 메모리 컨트롤러(iMC2) 520C는 도 5b에 도시된 바와 같이 플래시 컨 트롤러(flash controller)일 수 있다. I/O 인터페이스 530은 도 3의 상호접속 블레이드 300을 통한 데이터 컨트롤러 510과 연산 블레이드들 200 사이 에서의 인터페이싱을 지원할 수 있다. I/O 인터페이스 530은 하나 이상의 유선 또는 유선 통신 기술들과 관련된 프로토콜들을 사용하여, 데이터 컨트롤러 510으로부터 상호접속 블레이드 300으로의 송신 데이터를 출력하고, 상호접속 블레이드 300으로부터 데이터 컨트롤러 510으로의 수신 데이터를 입력할 수 있다. 예를 들어, I/O 인 터페이스 530은 PCIe(Peripheral Component Interconnect Express), QPI(QuickPath Interconnect), 이더넷 (Ethernet) 등과 같은 프로토콜들에 따라 데이터 컨트롤러 510과 상호접속 블레이드 300 사이의 통신을 지원할 수 있다. 전술한 바와 같이, 미래의 데이터 센터와 같은 서버 시스템 또는 데이터 처리 시스템은 연산 블레이드들, 메모 리 또는 스토리지 블레이드들 등과 같은 다수의 블레이드들이 단위 랙 내에서 구별되어 장착되는 구조를 가질 수 있다. 이때 하나의 메모리 블레이드에는 다양한 사용자 워크로드(user workload)를 충족시키기 위하여 서로 다른 특성을 가지는 다수의 메모리들이 포함될 수 있다. 즉, 하나의 메모리 블레이드는 DRAM, PCRAM, MRAM, STT-RAM, 플래시 메모리와 같은 다수의 메모리들이 통합된 형태를 가지는 통합 메모리 디바이스(convergence memory device)일 수 있다. 이러한 통합 메모리 디바이스는 각 메모리들이 서로 다른 특성을 가지기 때문에 다 양한 사용 모델(usage model)에 활용될 수 있다. 도 6는 본 발명 실시 예에 따른 메모리 시스템의 구조를 개략적으로 나타내는 도면이다. 메모리 시스템은 컨트롤러 및 복수의 메모리 블레이드들을 포함할 수 있다. 도 3을 참조하면, 컨트롤러는 컴퓨터 블레이드들 및 상호접속 블레이드를 포함할 수 있다. 따라서, 컨트롤러는 복수의 메모리 블레이드들 각각과 통신할 수 있으며, 또한 복수의 메모리 블레이드들 중에서 사용하기 위한 적어도 하나의 메모리 블레이드를 분할, 할당 또는 지정할 수 있다. 나아가, 분할, 할당 또는 지정된 적어도 하나의 메모리 블레이드를 초기화하고, 이들을 통하여 데이터의 리드 동작, 라이트(또는 프로그 램) 동작 등을 수행할 수 있다. 컨트롤러는 컴퓨터 블레이드들 및 상호접속 블레이드의 구성요소뿐만 아니라, DB 메모리, 모니터 및 할당부를 더 포함할 수 있다. DB 메모리(Data Base memory, 630)는 DB를 저장할 수 있다. DB는 처리 요청된 워크로드에 대한 정보 를 포함할 수 있다. 구체적으로, 워크로드를 처리하기 위하여 사용되는 평균 동작메모리 사용량인 제 1 정보 (#1)를 포함할 수 있다. 나아가, 도면에는 도시되지 아니하였으나, 워크로드를 처리하기 위하여 사용된 최종적 인 동작메모리 사용량인 제 2 정보(#2), 워크로드를 처리한 횟수인 제 3 정보(#3) 및 워크로드를 처리하기 위한 동작의 비율 즉, 리드에 대한 라이트 비율에 대한 제 4 정보(#4)를 포함할 수 있다. DB는 상기 제 1 정보 (#1) 내지 제 4 정보(#5)를 필드로 하고, 복수의 워크로드들 각각을 엔트리로 구성될 수 있다. 예를 들면, 도 시된 DB에는 워크로드 A(workload A)의 워크로드 A의 제 1 정보의 값 즉, 워크로드 A를 처리하기 위하여 사용되는 평균 동작메모리 사용량은 '1200'으로 등록되어 있다. 다만, 본 메모리 시스템에서 처리된 경험 이 없는 워크로드에 대하여는 DB에 등록되어 있지 않다. 따라서, 그러한 워크로드는 DB에 새롭게 등 록될 수 있다. 모니터는 처리 요청된 워크로드에 대응하는 제 1 정보의 값이 DB메모리에 저장되어 있는지 확인할 수 있다. 앞서 설명된 바와 같이, 만약 제 1 정보의 값이 DB에 등록되어 있지 않다면, 모니터는 해당 워크로드에 대한 정보를 DB에 등록할 수 있다. 반면에, 제 1 정보의 값이 DB에 등록되어 있다면, 제 1 정보(#1)의 값은 해당 워크로드를 처리하기 위하여 메모리 할당량의 기준이 될 수 있다. 나아가, 모니터 는 워크로드의 처리가 완료된 이후에, 상기 제 1 정보(#1) 내지 제 4 정보(#4)를 확인하여 DB를 업데 이트할 수 있다. 특히, 제 1 정보는 워크로드를 처리하기 위하여 사용된 최종적인 동작메모리 량인 제 2 정보 (#2)와 해당 워크로드를 처리한 횟수인 제 3 정보(#3)를 활용하여 계산될 수 있다. 나아가, 모니터는 제 4 정보(#4)를 확인하여 해당 워크로드가 리드에 최적화된 동작인지 혹은 라이트에 최적화된 동작인지 판단할 수 있다. 제 4 정보(#4)는 사전 설정된 기준에 따라 계산될 수 있다. 구체적으로, 제 4 정보(#4)는 타겟 워크로 드를 처리하기 위하여 수행된 리드 요청에 대한 라이트 요청의 비율일 수 있다. 더 자세한 내용은 도 8에서 설 명된다. 할당부는 DB에 저장된 제 1 정보(#1)의 값에 기초하여 워크로드의 처리를 위해 동작메모리의 사용량 을 할당할 수 있다. 만약, DB의 엔트리에 타겟 워크로드가 등록되어 있지 않다면, 사전 설정된 메모리 량 을 할당할 수 있다. 나아가, 할당부는 제 1 정보(#1)의 값에 사전 설정된 오버 프로비젼(over-provision) 값을 반영하여 동작메모리를 할당할 수 있다. 예를 들면, 워크로드 A의 제 1 정보(#1)의 값이 '1200'이라면, 할당부는 메모리량을'1200'으로 할당하는 것이 아니라, 오버 프로비젼을 반영하여 10%를 더한 '1320'으로 할당할 수 있다. 뿐만 아니라, 동작메모리 할당량이 부족하여 추가적인 할당 요청이 있는 경우, 할당부는 사전 설정된 동작메모리 사용량을 추가로 할당할 수 있다. 또한, 할당부는 DB에 저장된 제 4 정보(#1)의 값에 기초하여 워크로드의 처리를 위해 복수의 동작메 모리들 중 어느 하나에 할당할 수 있다. 즉, 워크로드가 리드 동작에 최적화된 경우, 리드 동작에 최적화된 동 작메모리에 할당할 수 있다. 반면에 워크로드가 라이트 동작에 최적화된 경우, 라이트 동작에 최적화된 동작메 모리에 할당할 수 있다. 메모리 블레이드들은 복수의 동작메모리를 포함할 수 있다. 복수의 동작메모리들은 사전 설정된 기준에 따라 리드 동작에 최적화된 리드타입 동작메모리, 라이트 동작에 최적화된 라이트타입 동작메모리 및 노멀타입 동작메모리로 구분될 수 있다. 예를 들면, 리드타입 동작메모리는 리드 동작을 수행할 때 3클록(clock)을 사용 하고, 라이트 동작에 대하여는 7클록을 사용할 수 있다. 반면에, 라이트타입 동작메모리는 라이트 동작에 대하 여 7클록, 리드 동작에 대하여는 3클록을 사용할 수 있다. 나아가, 노멀타입 동작메모리는 리드 동작 및 라이 트 동작에 대하여 각각 5클록씩을 사용할 수 있다. 이는 단순히 예일 뿐이며 이에 제한되는 것은 아니고, 사용 되는 클록은 메모리에 따른 속도 및 메모리의 특성 등을 반영하여 설정되거나 기존 옵션(option) 중 하나를 선 택하여 설정될 수 있다. 도 7은 본 발명의 일 실시 예에 따른 메모리 시스템의 동작을 개략적으로 나타낸 흐름도이다. 단계 S701에서, 외부로부터 워크로드의 처리에 대한 요청이 발생될 수 있다. 단계 S703에서, 모니터는 DB메모리에 저장된 DB를 확인하여 요청된 워크로드가 DB에 등록 되어 있는지 확인할 수 있다. 구체적으로, 모니터는 DB의 엔트리에 타겟 워크로드가 등록되어있는지 확인할 수 있다. 만약, 타겟 워크로드가 엔트리에 등록되어 있지 않다면(단계 S703에서, 'No'), 단계 S705에서, 할당부는 사전에 설정된 동작메모리 사용량을 상기 타겟 워크로드 처리를 위하여 할당할 수 있다. 이후 단계 S709가 수 행될 수 있다. 반면에, 타겟 워크로드가 엔트리에 등록되어 있다면(단계 S703에서, 'Yes'), 단계 S707에서, 할당부는 DB에 등록된 제 1 정보(#1)의 값에 기초하여 동작메모리 사용량을 할당할 수 있다. 나아가, 도시되진 아 니하였으나, 할당부는 사전 설정된 오버 프로비젼(over-provision) 값을 반영하여 할당할 수 있다. 나아가, 단계 S709에서, 할당부는 할당된 동작메모리 량의 부족으로 추가 동작메모리 할당 요청을 수신할 수 있다. 만약, 추가 메모리 할당 요청이 있는 경우(단계 S709에서, 'Yes'), 단계 S711에서, 할당부는 사전 설정된 값으로 추가적인 동작메모리 사용량을 할당할 수 있다. 반면에, 추가 동작메모리 할당 요청이 없는 경우(단계 S709에서, 'No'), 바로 단계 S713이 수행될 수 있다. 단계 S713에서, 모니터는 해당 워크로드의 처리가 완료된 후에 DB에 저장된 제 1 정보(#1) 내지 제 4 정보(#4)를 업데이트할 수 있다. 그로 인하여, 추후 동일한 워크로드에 대한 처리 요청이 발생된 경우, 상기 업데이트된 DB에 기초하여 상기 설명된 바와 같이 최적의 동작메모리의 사용량이 할당될 수 있으며, 추가 적인 동작메모리 할당이 최소화되어, 메모리 시스템의 성능이 극대화될 수 있다. 도 8은 본 발명의 일 실시 예에 따른 DB에 등록된 값을 개략적으로 나타낸 도면이다. 앞서 설명된 바와 같이, DB는 제 1 정보(#1) 내지 제 4 정보(#4)를 필드로 하고, 처리 요청된 워크로드들 각각을 엔트리로 하여 구성될 수 있다. 다만, 처리된 경험이 있는 워크로드만이 DB에 등록이 될 수 있다. 제 1 정보(#1)는 해당 워크로드를 처리하기 위하여 사용된 평균 동작메모리 사용량을 나타낼 수 있다. 예를 들 면, 워크로드 A를 처리하기 위하여 사용된 동작메모리 사용량은 평균적으로 '1200'이다. 앞서 설명된 바와 같 이, 할당부는 워크로드 A를 처리하기 위하여 초기에 '1200'에 해당하는 동작메모리를 할당할 수 있다. 나 아가 만약, 오버프로비젼이 10%라고 가정한다면, 할당부는 '1200'의 10%를 더한 값인 '1320'에 해당하는 동작메모리의 사용량을 할당할 수 있다. 제 2 정보(#2)는 워크로드 A를 처리하기 위하여 사용된 최종적인 동작메모리 사용량을 나타낼 수 있다. 제 2 정보(#2)의 값이 '1730'인 점에 비추어 볼 때, 초기에 할당된 '1320'에 해당하는 동작메모리 량이 부족하여 추 가적인 동작메모리 할당이 있었음을 알 수 있다. 제 3 정보(#3)는 현재까지 워크로드 A를 처리한 횟수를 나타낼 수 있다. 제 3 정보(#3)의 값이 '12'인 점에 비 추어 볼 때, 컨트롤러는 워크로드 A를 12회 처리하였으며, 워크로드 A의 처리를 완료하면 제 3 정보(#3)의 값이 '13'으로 업데이트될 수 있다. 타겟 워크로드의 처리가 완료된 이후에, 모니터은 제 1 정보(#1), 즉, 워크로드 A를 처리하기 위하여 사용 된 동작메모리의 평균 사용량을 업데이트 할 수 있다. 동작메모리의 평균 사용량은 초기 동작메모리 할당량과 최종 동작메모리 사용량을 합한 값에 처리 횟수를 나눈 값으로 계산될 수 있다. 예를 들면, 워크로드 A의 처리가 완료된 이후에, 모니터은 제 2 정보(#2)의 값 및 제 3 정보(#3)의 값을 업데이트할 수 있다. 나아가, 모니터 평균 동작메모리 할당량은 [(12*1200)+1730]/13 = 1240'으로 계산될 수 있다. 즉, 상기 계산에 따라 제 1 정보(#1)의 값을 업데이트할 수 있다. 도 9는 본 발명의 다른 실시 예에 따른 메모리 시스템의 동작을 개략적으로 나타낸 도면이다. 구체적으로, 도 9는 처리 요청된 타겟 워크로드의 특성을 파악하여, 타겟 워크로드를 처리하기 위한 최적화된 동작메모리로 할당할 수 있는 장치를 나타낸다.모니터는 처리 요청된 워크로드가 DB의 엔트리에 저장되어 있는지 확인할 수 있다. 앞서 설명된 바 와 같이, 만약 타겟 워크로드가 DB의 엔트리에 등록되어 있지 않다면, 모니터는 해당 워크로드에 대 한 정보를 DB에 등록할 수 있다. 반면에, 타겟 워크로드가 DB의 엔트리에 등록되어 있다면, 제 1 정 보(#1)의 값은 해당 워크로드를 처리하기 위하여 메모리 사용량의 기준이 될 수 있다. 앞서 설명된 바와 같이, 모니터는 타겟 워크로드의 처리가 완료된 후에, 상기 제 1 정보(#1) 내지 제 4 정보(#4)를 업데이트할 수 있다. 제 4 정보(#4)는 타겟 워크로드를 처리하기 위하여 수행된 리드 요청에 대한 라이트 요청의 비율을 나타 낼 수 있다. 할당부는 DB에 저장된 제 4 정보(#4)의 값에 기초하여 워크로드를 효율적으로 처리할 수 있는 동작메 모리에 할당할 수 있다. 사전 설정된 기준에 따라 제 4 정보(#4)에 기초하여 할당부는 타겟 워크로드가 어느 동작에 최적화된 워크로드인지 판단할 수 있다. 예를 들면, 타겟 워크로드를 처리하기 위하여 요청된 리 드 요청의 횟수가 라이트 요청의 횟수보다 20%많다면, 상기 타겟 워크로드는 리드 동작에 최적화된 리드타입 동 작메모리에 할당되는 것이 시스템 관점에서 효율적이다. 예를 들면, 워크로드 A를 처리하기 위하여 수행되는 리 드 동작의 비율이 라이트 동작의 비율보다 사전의 설정된 값보다 높은 경우에는, 할당부는 리드 동작을 수 행하기에 최적화된 리드타입 동작메모리에 할당할 수 있다. 복수의 메모리 블레이드들 각각(400A 내지 400N)은 복수의 동작메모리를 구비할 수 있다. 예를 들면, 워크로드 A를 처리하기 위한 제 1 메모리 블레이드(400A)는 리드 동작에 최적화된 리드타입 메모리(410A), 라이트 동작에 최적화된 라이트타입 메모리(430A) 및 노멀타입 메모리(450A)로 구분될 수 있다. 사용자는 상기 복수의 동작메 모리들의 타입을 설정할 수 있다. 예를 들면, 리드 동작에 최적화된 리드타입 메모리(410A)는 리드 동작에 소 요되는 클록(clock)에 대하여 '3'으로 할당되고, 라이트 동작에 소요되는 클록에 대하여 '7'로 할당될 수 있다. 반면에, 라이트 동작에 최적화된 라이트타입 동작메모리(430A)는 라이트 동작에 소요되는 클록에 대하여 '3'으 로 할당되고, 리드 동작에 소요되는 클록에 대하여 '7'로 할당될 수 있다. 또한, 노멀타입 동작메모리(450A)는 리드 동작 및 라이트 동작에 소요되는 클록에 대하여 동일하게 할당될 수 있다. 따라서, 워크로드 A를 처리하 기 위하여 요청되는 동작 중에 리드 동작의 비율이 라이트 동작의 비율보다 더 높다면, 할당부는 제 1 메 모리 블레이드(400A)의 복수의 동작메모리들 중 리드타입 동작메모리(410A)에 할당할 수 있다. 도 10은 본 발명의 다른 실시 예에 따른 메모리 시스템의 동작을 개략적으로 나타낸 흐름도이다. 단계 S1001에서, 외부로부터 워크로드의 처리에 대한 요청이 발생될 수 있다. 단계 S1003에서, 모니터는 DB메모리에 저장된 DB의 엔트리를 확인하여 요청된 워크로드가 DB에 등록되어 있는지 확인할 수 있다. 만약, 타겟 워크로드가 DB의 엔트리에 등록되어 있지 않다면(단계 S1003에서, 'No'), 단계 S1005에서, 할 당부는 타겟 워크로드 처리를 위하여 노멀타입 동작메모리에 할당할 수 있다. 반면에, 타겟 워크로드가 DB의 엔트리에 등록되어 있다면(단계 S1003에서, 'Yes'), 단계 S1007에서, 할당 부는 DB에 등록된 제 4 정보(#4)의 값에 기초하여 상기 워크로드를 처리하기 위한 리드 요청에 대한 라이트 요청의 비율을 확인할 수 있다. 만약, 상기 워크로드를 처리하기 위하여 리드 요청의 비율이 높다면(단계 S1007에서 'Read-tpye'), 단계 S1009 에서, 할당부는 상기 워크로드를 처리하기 위하여 리드 동작에 최적화된 리드타입 동작메모리에 할당할 수 있다. 반면에, 상기 워크로드를 처리하기 위하여 라이트 요청의 비율이 높다면(단계 S1007에서 'Write-tpye'), 단계 S1011에서, 할당부는 상기 워크로드를 처리하기 위하여 라이트 동작에 최적화된 라이트타입 동작메모리에 할당할 수 있다. 또한, 상기 워크로드를 처리하기 위하여 리드 요청의 비율과 라이트 요청의이 비율이 같다면(단계 S1007에서 'Normal-tpye'), 단계 S1013에서, 할당부는 상기 워크로드를 처리하기 위하여 노멀타입 동작메모리에 할당 할 수 있다. 단계 S1015에서, 모니터는 해당 워크로드의 처리가 완료된 후에 DB에 저장된 제 4 정보(#4)를 업데이 트할 수 있다. 그로 인하여, 추후 동일한 워크로드에 대한 처리 요청이 발생된 경우, 해당 타겟 워크로드는 상 기 업데이트된 DB에 기초하여 상기 설명된 바와 같이 최적의 동작메모리에 할당될 수 있으며, 메모리 시스 템의 성능이 극대화될 수 있다.본 발명의 실시 예들에 따르면, 외부로부터 생성된 워크로드를 효율적으로 처리하기 위하여, 컨트롤러는 워크로드의 처리에 대하여 DB를 작성하고, 처리 경험이 있는 워크로드에 대하여 상기 DB에 기초하여 최적의 동작메모리 사용량을 할당할 수 있다. 이로 인하여 추가 동작메모리 할당을 최소화할 수 있어, 전체적 인 시스템은 동작메모리의 할당에 소요되는 대기시간을 단축시킬 수 있다. 또한, 복수의 메모리를 복수의 동작 각각에 최적화된 메모리로 구분하여 효율적으로 상기 워크로드를 처리할 수 있도록, 컨트롤러는 워크로드 를 처리하기 위한 메모리를 구분하여 할당할 수 있다. 이로써, 전체 시스템은 효율적으로 외부로부터 생성된 워크로드를 단시간에 처리할 수 있다. 한편, 본 발명의 상세한 설명에서는 구체적인 실시 예에 관해 설명하였으나, 본 발명의 범위에서 벗어나지 않는 한도 내에서 여러 가지 변형이 가능함은 물론이다. 그러므로, 본 발명의 범위는 설명된 실시 예에 국한되어 정 해져서는 안되며 후술하는 특허청구의 범위뿐만 아니라 이 특허청구의 범위와 균등한 것들에 의해 정해져야 한 다."}
{"patent_id": "10-2017-0148004", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 데이터 처리 시스템을 도시하는 도면이다. 도 2 및 도 3은 본 발명의 실시 예에 따른 컴퓨팅 디바이스의 구성을 도시하는 도면들이다. 도 4는 본 발명의 실시 예에 따른 컴퓨터 블레이드의 구성을 도시하는 도면이다. 도 5는 본 발명의 실시 예에 따른 메모리 블레이드의 구성을 도시하는 도면들이다. 도 6은 본 발명의 실시 예에 따른 메모리 시스템의 동작을 개략적으로 나타낸 도면이다. 도 7은 본 발명의 실시 예에 따른 메모리 시스템의 동작을 개략적으로 나타낸 흐름도이다. 도 8은 본 발명의 실시 예에 따른 DB에 등록된 값을 개략적으로 나타낸 흐름도이다. 도 9은 본 발명의 다른 실시 예에 따른 메모리 시스템의 동작을 개략적으로 나타낸 도면이다. 도 10은 본 발명의 다른 실시 예에 따른 메모리 시스템의 동작을 개략적으로 나타낸 흐름도이다."}
