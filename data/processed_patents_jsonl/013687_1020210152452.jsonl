{"patent_id": "10-2021-0152452", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0066926", "출원번호": "10-2021-0152452", "발명의 명칭": "삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 방법 및 장치", "출원인": "한양대학교 산학협력단", "발명자": "최정욱"}}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "행렬곱 연산을 수행하는 디지털 신호 처리 장치로서,입력 데이터에 대해 삼항으로 양자화되어 있는 가중치 데이터를 곱하여 행렬곱 연산을 수행하는 MAC 연산 모듈;상기 MAC 연산 모듈에서 출력하는 출력 데이터를 누적적으로 저장하며, N 비트의 데이터를 저장할 수 있는 제1누적기;상기 제1누적기와 직렬적으로 연결되며, 상기 N 비트보다 큰 비트의 데이터를 저장할 수 있는 제2누적기; 및상기 제1누적기가 누적하는 상기 출력 데이터에 대한 누적 연산에 대해, 누적 연산 값이 상기 제1누적기의 저장 공간을 초과하는 것으로 판단된 경우, 상기 제1누적기에 저장되어 있는 저장 데이터를 상기 제2누적기로 송신하는 오버플로 감지 모듈;을 포함하는,삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 MAC 연산 모듈은,8비트 이하의 고정 소수점 값으로 양자화 되어 있는 입력 데이터에 대해 삼항(-1,0,1)으로 양자화 되어 있는 가중치 데이터를 곱하여 MAC 연산을 수행하는, 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 MAC 연산 모듈은,XOR, SUB 및 AND 논리 연산을 이용하여 상기 MAC 연산을 수행하는, 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 MAC 연산 모듈은,상기 MAC 연산을 수행할 수 있는 복수 개의 MAC 연산부를 포함하고, 상기 제1누적기와 상기 제2누적기는,상기 복수 개의 MAC 연산 블록에 대한 출력 데이터를 각각 병렬적으로 저장할 수 있도록 상기 복수 개의 MAC 연산부의 개수에 대응되는 수 만큼 복수 개의 누적 블록을 가지는, 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치는 상기 제1누적기와 상기 제2누적기를 포함하는 복수 개의 누적기를 포함하고,공개특허 10-2023-0066926-3-상기 오버플로 감지 모듈은,상기 복수 개의 누적기에 대응되어 각각 연결되어 있는 복수 개의 카운터를 포함하는 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 복수 개의 카운터는,상기 복수 개의 카운터에 대응되는 누적기에 상기 출력 데이터가 입력되는 횟수에 기초하여 오버플로 여부를 감지하는,삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,상기 복수 개의 카운터는.상기 복수 개의 카운터에 대응되는 누적기의 임계 카운터(c)를 각각 계산하고, 상기 임계 카운터에 기초하여 각각의 누적기의 오버플로 여부를 판단하는, 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 임계 카운터는.상기 입력 데이터의 비트 값 및 상기 복수 개의 누적기들의 비트 값에 기초하여 결정되는, 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 복수 개의 카운터는,상기 복수 개의 카운터에 대응되는 누적기에 상기 출력 데이터가 입력되는 횟수가 상기 임계 카운터에 도달한경우 오버플로가 발생할 것으로 판단하는,삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 오버플로 감지 모듈은,오버플로가 발생할 것으로 감지된 오버플로 누적기에 대해서는, 상기 오버플로 누적기가 누적하고 있던 데이터를 상기 오버플로 누적기와 직렬적으로 연결되어 있는 다음 누적기로 송신하고, 상기 오버플로 누적기를 리셋(Reset)하는, 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "행렬곱 연산을 수행하는 디지털 신호 처리 장치로서,입력 데이터에 대해 삼항으로 양자화되어 있는 가중치 데이터를 곱하여 행렬곱 연산을 수행하는 MAC 연산 모듈;공개특허 10-2023-0066926-4-상기 MAC 연산 모듈에서 출력하는 출력 데이터를 누적적으로 저장하며, N 비트의 데이터를 저장할 수 있는 누적기를 복수 개 포함하는 제1누적기;상기 제1누적기와 직렬적으로 연결되며, 상기 N 비트보다 큰 비트의 데이터를 저장할 수 있는 누적기를 복수 개포함하는 제2누적기; 및상기 제1누적기 및 상기 제2누적기에 포함되어 있는 복수 개의 누적기에 대응되어 연결되어 있는 복수 개의 오버플로 감지기를 포함하는 오버플로 감지 모듈;을 포함하고,상기 오버플로 감지기는,상기 오버플로 감지기에 연결되어 있는 누적기가 상기 출력 데이터에 대한 누적 연산 값이 저장 공간을 초과할것으로 판단된 경우, 저장 공간을 초과할 것으로 판단한 누적기에 저장되어 있는 저장 데이터를 직렬 연결되어있는 다른 누적기로 송신하는, 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,상기 오버플로 감지기는,상기 오버플로 감지기에 연결되어 있는 누적기의 저장 용량 및 상기 누적기에 입력되는 상기 입력 데이터의 크기에 기초하여 오버플로 여부를 판단하는, 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서,상기 오버플로 감지기는,상기 오버플로 감지기에 연결되어 있는 누적기에 저장되는 상기 입력 데이터의 총 합을 매 연산마다 계산하여,연산된 값이 상기 누적기의 저장 용량 값을 초과할 것으로 계산된 경우, 오버플로가 발생할 수 있을 것으로 판단하는,삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서,상기 오버플로 감지기는,오버플로가 발생할 것으로 감지된 오버플로 누적기에 대해서는, 상기 오버플로 누적기가 누적하고 있던 데이터를 상기 오버플로 누적기와 직렬적으로 연결되어 있는 다음 누적기로 송신하고, 상기 오버플로 누적기를 리셋(Reset)하는, 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치."}
{"patent_id": "10-2021-0152452", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "MAC 연산 모듈 및 복수 개의 누적기를 포함하는 디지털 신호 처리 장치 방법에 있어서,MAC 연산 모듈을 이용하여 입력 데이터에 대해 삼항으로 양자화되어 있는 가중치 데이터를 곱하여 행렬곱 연산을 수행하는 단계;상기 MAC 연산 모듈에서 출력하는 출력 데이터를 N 비트의 데이터를 저장할 수 있는 제1누적기에 저장하는단계,상기 제1누적기가 누적하는 상기 출력 데이터에 대한 누적 연산에 대해, 누적 연산 값이 상기 제1누적기의 저장 공간을 초과하는 것으로 판단된 경우, 상기 제1누적기에 저장되어 있는 저장 데이터를 상기 제1누적기와 직공개특허 10-2023-0066926-5-렬적으로 연결되며, 상기 N 비트보다 큰 비트의 데이터를 저장할 수 있는 제2누적기로 송신하는 단계; 및 상기 제1누적기에 대해 리셋을 수행하고, 상기 MAC 연산 모듈에서 출력하는 출력 데이터를 다시 상기 제1누적기에 저장하는 단계;를 포함하는 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 방법."}
{"patent_id": "10-2021-0152452", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "일 실시예에 따른 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치는, 입력 데이터에 대해 삼 항으로 양자화되어 있는 가중치 데이터를 곱하여 행렬곱 연산을 수행하는 MAC 연산 모듈, 상기 MAC 연산 모듈에 서 출력하는 출력 데이터를 누적적으로 저장하며, N 비트의 데이터를 저장할 수 있는 제1누적기, 상기 제1누적기 와 직렬적으로 연결되며, 상기 N 비트보다 큰 비트의 데이터를 저장할 수 있는 제2누적기 및 상기 제1누적기가 누적하는 상기 출력 데이터에 대한 누적 연산에 대해, 누적 연산 값이 상기 제1누적기의 저장 공간을 초과하는 것으로 판단된 경우, 상기 제1누적기에 저장되어 있는 저장 데이터를 상기 제2누적기로 송신하는 오버플로 감지 모듈을 포함할 수 있다."}
{"patent_id": "10-2021-0152452", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 방법 및 장치에 관한 발명으로서, 보 다 구체적으로는 삼항 가중치 기반의 SIMD 연산을 수행함에 있어, 누적 연산에 따른 오버플로를 감지하고, 오버 플로가 감지된 경우 다음 단계의 레지스터를 활성화하는 방법으로, 기존 행렬곱 라이브러리보다 빠른 행렬곱 연 산을 수행할 수 있는 디지털 신호 처리 및 장치에 관한 발명이다."}
{"patent_id": "10-2021-0152452", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "무선통신단말기, 개인용 디지털 단말기(PDA), ATM 스위치, 디지털 오디오/비디오 장치, 개인용 컴퓨터 등의 많 은 전자기기가 다량의 데이터를 신속하게 처리할 것을 요구하고 있다. 일반적으로 데이터 처리를 위하여 전자기 기에 탑재되는 프로세서는 GPP (General-Purpose Processor)와 DSP(Digital Signal Processor)로 구분할 수 있 다. GPP는 게임이나 데스크탑 어플리케이션을 위한 일반적인 작업을 수행하는 범용 프로세서로서, 인텔사의 펜 티움 프로세서가 그 대표적인 예이다. DSP는 특정 디지털 신호처리 기능을 수행하기 위한 프로세서로서, 특정 디지털 신호처리 동작의 특성을 이용하 여 효율적으로 계산할 수 있도록 설계된다. DSP 상에서 수행되는 디지털 신호처리 동작은 일반적으로 대량의 순 차적인 연산을 반복적으로 수행하는 특성을 가지고 있다. 디지털 신호 처리에 있어서 특히 중요하게 여겨지는 연산으로는 곱셈 누적 연산(Multiply and Accumulate; MA C)이 있다. 대다수의 DSP는 MAC 연산을 효율적으로 수행하기 위하여 곱셈기(Multiplier), 덧셈기(Adder) 및 누 적기(Accumulator)를 포함하고 있다. 곱셈기를 사용하여 두 개의 피연산자에 대한 곱셈을 수행하고, 곱셈 결과 를 덧셈기를 이용하여 누적 서브누적기에 저장된 값과 합하여 누적 서브누적기에 저장함으로써 MAC 연산을 수행 하며, 상기MAC 연산은 유한 임펄스 응답 필터(FIR filter)나 무한 임펄스 응답 필터(IIR filter)와 같은 여파 (filtering), 고속 푸리에 변환(FFT)나 고속 역 푸리에 변환(IFFT) 등의 디지털 신호처리 알고리즘에서 비슷한 형태로 응용되거나 사용되고 있다. 현재 대다수의 DSP는 이러한 MAC 연산의 속도를 더욱 높이기 위하여 병렬화된 MAC 연산을 지원하는 경우가 많다. 즉, DSP는 2개의 MAC 블록(Dual-MAC)이나, 4개의 MAC 블록(Quad-MAC), 또는 그 이상의 MAC 블록을 병렬 화하여 DSP 내부에 기능블록으로 구비함으로써 MAC 연산을 가속한다. 병렬화된 MAC 블록은 매 클럭 사이클마다 MAC 블록 수의 두 배에 달하는 피연산자를 메모리에서 읽어와야 한다. 하지만 일반적인 메모리는 한 사이클에 한 개의 데이터만을 가져올 수 있기 때문에, 종래의 병렬화된 MAC 블록을 구비한 DSP는 메모리 접근 용량 (memory access bandwidth)에 한계가 존재한다는 문제가 있었다. 또한, MAC 블록은 곱셈 결과값을 누적 레지스 터에 반복적으로 누적하는 과정에서 누적 레지스터의 비트수의 한계로 인해 오버플로우가 쉽게 발생할 수 있다 는 문제점이 있다. 또한, 최근 인공지능 기술의 발달로 인해 기계학습 모델, DNN (deep neural network) 모델을 사용함에 있어서, 낮은 전력으로 보다 빠르게 모델을 작동시키기 위해 데이터의 비트 수를 줄여 가중치 값으로 삼항(ternary)을 사용하는 양자화 기법이 도입되고 있는데, 아직까지는 삼항 정밀도 기반의 행렬곱 연산을 보다 빠르게 효율적으 로 연산할 수 있는 기술에 대해서는 전무한 실정이다. 선행기술문헌 특허문헌 (특허문헌 0001) 대한민국 공개특허공보 10-2019-0138779호 - 스토캐스틱 연산을 위한 로그-양자화된 곱셈 및 누적기와 이를 포함하는 가속기 (2020.05.12) (특허문헌 0002) 대한민국 공개특허공보 10-2018-0090416호 - 세밀한 정밀도 조정이 가능한 곱셈누적기 (2019.10.28)"}
{"patent_id": "10-2021-0152452", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "일 실시예에 따른 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치는 이러한 문제점을 해결 하기 위해 고안된 발명으로서, 행렬곱의 한쪽 행렬이 삼항 {-1, 0, 1} 으로 양자화되어 있고, 반대쪽 행렬이 8 비트 미만의 고정 소수점 값으로 양자화 되어 있는 경우에 SIMD 연산을 지원하는 연산기에서 행렬곱을 효율적으 로 연산할 수 있는 방법을 제공하는데 그 목적이 있다. 구체적으로, 본 발명의 일 실시예 따른 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치는, 상항 가중치 기반의 SIMD 연산을 수행하는 과정에서 8비트 혹은 16비트의 누적 연산에 따라 레지스터에서 오버 플로가 발생하는지 효율적으로 감지하고, 레지스터에서 오버플로가 발생할 것으로 감지된 경우, 레지스터에 누 적된 데이터를 다음 단계 레지스터로 이전하는 방법으로 레지스터의 저장 용량을 활용하여, SIMD 연산 과정의 전체 속도를 효율적으로 증가시킬 수 있는 디지털 신호 처리 장치를 제공하는데 그 목적이 있다."}
{"patent_id": "10-2021-0152452", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시예에 따른 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치는, 입력 데이터에 대해 삼항으로 양자화되어 있는 가중치 데이터를 곱하여 행렬곱 연산을 수행하는 MAC 연산 모듈, 상기 MAC 연산 모듈 에서 출력하는 출력 데이터를 누적적으로 저장하며, N 비트의 데이터를 저장할 수 있는 제1누적기, 상기 제1누 적기와 직렬적으로 연결되며, 상기 N 비트보다 큰 비트의 데이터를 저장할 수 있는 제2누적기 및 상기 제1누적 기가 누적하는 상기 출력 데이터에 대한 누적 연산에 대해, 누적 연산 값이 상기 제1누적기의 저장 공간을 초과 하는 것으로 판단된 경우, 상기 제1누적기에 저장되어 있는 저장 데이터를 상기 제2누적기로 송신하는 오버플로 감지 모듈을 포함할 수 있다. 상기 MAC 연산 모듈은, 8비트 이하의 고정 소수점 값으로 양자화 되어 있는 입력 데이터에 대해 삼항(-1,0,1)으 로 양자화 되어 있는 가중치 데이터를 곱하여 MAC 연산을 수행할 수 있다. 상기 MAC 연산 모듈은, XOR, SUB 및 AND 논리 연산을 이용하여 상기 MAC 연산을 수행하는, 삼항 정밀도 기반의 행렬곱 연산을 수행할 수 있다. 상기 MAC 연산 모듈은, 상기 MAC 연산을 수행할 수 있는 복수 개의 MAC 연산부를 포함하고, 상기 제1누적기와 상기 제2누적기는, 상기 복수 개의 MAC 연산부에 대한 출력 데이터를 각각 병렬적으로 저장할 수 있도록 상기 복수 개의 MAC 연산부의 개수에 대응되는 수 만큼 복수 개의 누적기를 포함할 수 있다. 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치는 상기 제1누적기와 상기 제2누적기를 포함 하는 복수 개의 누적기를 포함하고, 상기 오버플로 감지 모듈은, 상기 복수 개의 누적기에 대응되어 각각 연결 되어 있는 복수 개의 카운터를 포함할 수 있다. 상기 복수 개의 카운터는, 상기 복수 개의 카운터에 대응되는 누적기에 상기 출력 데이터가 입력되는 횟수에 기 초하여 오버플로 여부를 감지할 수 있다. 상기 복수 개의 카운터는, 상기 복수 개의 카운터에 대응되는 누적기의 임계 카운터(c)를 각각 계산하고, 상기 임계 카운터에 기초하여 각각의 누적기의 오버플로 여부를 판단할 수 있다. 상기 임계 카운터는, 상기 입력 데이터의 비트 값 및 상기 복수 개의 누적기들의 비트 값에 기초하여 결정될 수 있다. 상기 복수 개의 카운터는, 상기 복수 개의 카운터에 대응되는 누적기에 상기 출력 데이터가 입력되는 횟수가 상 기 임계 카운터에 도달한 경우 오버플로가 발생할 것으로 판단할 수 있다. 상기 오버플로 감지 모듈은, 오버플로가 발생할 것으로 감지된 오버플로 누적기에 대해서는, 상기 오버플로 누 적기가 누적하고 있던 데이터를 상기 오버플로 누적기와 직렬적으로 연결되어 있는 다음 누적기로 송신하고, 상기 오버플로 누적기를 리셋(Reset)할 수 있다. 일 실시예에 따른 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치는, 입력 데이터에 대해 삼항으로 양자화되어 있는 가중치 데이터를 곱하여 행렬곱 연산을 수행하는 MAC 연산 모듈, 상기 MAC 연산 모듈 에서 출력하는 출력 데이터를 누적적으로 저장하며, N 비트의 데이터를 저장할 수 있는 누적기를 복수 개 포함 하는 제1누적기, 상기 제1누적기와 직렬적으로 연결되며, 상기 N 비트보다 큰 비트의 데이터를 저장할 수 있는 누적기를 복수 개 포함하는 제2누적기 및 상기 제1누적기 및 상기 제2누적기에 포함되어 있는 복수 개의 누적기 에 대응되어 연결되어 있는 복수 개의 오버플로 감지기를 포함하는 오버플로 감지 모듈을 포함하고, 상기 오버 플로 감지기는, 상기 오버플로 감지기에 연결되어 있는 누적기가 상기 출력 데이터에 대한 누적 연산 값이 저장 공간을 초과할 것으로 판단된 경우, 저장 공간을 초과할 것으로 판단한 누적기에 저장되어 있는 저장 데이터를 직렬 연결되어 있는 다른 누적기로 송신할 수 있다. 상기 오버플로 감지기는, 상기 오버플로 감지기에 연결되어 있는 누적기의 저장 용량 및 상기 누적기에 입력되 는 상기 입력 데이터의 크기에 기초하여 오버플로 여부를 판단할 수 있다. 상기 오버플로 감지기는, 상기 오버플로 감지기에 연결되어 있는 누적기에 저장되는 상기 입력 데이터의 총 합 을 매 연산마다 계산하여, 연산된 값이 상기 누적기의 저장 용량 값을 초과할 것으로 계산된 경우, 오버플로가 발생할 수 있을 것으로 판단할 수 있다. 상기 오버플로 감지기는, 오버플로가 발생할 것으로 감지된 오버플로 누적기에 대해서는, 상기 오버플로 누적기 가 누적하고 있던 데이터를 상기 오버플로 누적기와 직렬적으로 연결되어 있는 다음 누적기로 송신하고, 상기 오버플로 누적기를 리셋(Reset)할 수 있다. 일 실시예에 따른 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 방법은, MAC 연산 모듈 및 복 수 개의 누적기를 포함하는 디지털 신호 처리 장치 방법에 있어서, MAC 연산 모듈을 이용하여 입력 데이터에 대 해 삼항으로 양자화되어 있는 가중치 데이터를 곱하여 행렬곱 연산을 수행하는 단계, 상기 MAC 연산 모듈에서 출력하는 출력 데이터를 N 비트의 데이터를 저장할 수 있는 제1누적기에 저장하는 단계, 상기 제1누적기가 누적 하는 상기 출력 데이터에 대한 누적 연산에 대해, 누적 연산 값이 상기 제1누적기의 저장 공간을 초과하는 것으 로 판단된 경우, 상기 제1누적기에 저장되어 있는 저장 데이터를 상기 제1누적기와 직렬적으로 연결되며, 상기 N 비트보다 큰 비트의 데이터를 저장할 수 있는 제2누적기로 송신하는 단계 및 상기 제1누적기에 대해 리셋을 수행하고, 상기 MAC 연산 모듈에서 출력하는 출력 데이터를 다시 상기 제1누적기에 저장하는 단계를 포함할 수 있다."}
{"patent_id": "10-2021-0152452", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "일 실시예에 따른 신호 처리 장치는 삼항 가중치를 사용한 SIMD 연산 방법에 있어서, 상대적으로 낮은 비트의 누적기의 오버플로 여부를 판단하고 이를 기초로 누적기의 활용을 제어하므로, 종래 기술과 다르게 행렬곱 연산 을 함에 있어서 보다 작은 비트 수를 가지는 누적기를 많이 사용할 수 있어 SIMD 연산의 전체 속도를 효율적으 로 증가시킴과 동시에 전력의 효율을 높일 수 있는 장점이 존재한다. 따라서, 본 발명에 따른 연산 방법은 행렬곱 연산의 속도를 향상시키므로, 연산 시간의 대부분이 행렬곱 연산으 로 이루어져있는 인공지능 모델의 추론 속도를 비약적으로 향상시킬 수 있는 장점이 존재한다."}
{"patent_id": "10-2021-0152452", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 명세서에 기재된 실시 예와 도면에 도시된 구성은 개시된 발명의 바람직한 일 예이며, 본 출원의 출원 시점 에 있어서 본 명세서의 실시 예와 도면을 대체할 수 있는 다양한 변형 예들이 있을 수 있다. 또한, 본 명세서에서 사용한 용어는 실시 예를 설명하기 위해 사용된 것으로, 개시된 발명을 제한 및/또는 한정 하려는 의도가 아니다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\", \"구비하다\" 또는 \"가지다\" 등의 용어는 명세서상에 기재된 특징, 숫자, 단계, 작동, 구성요소, 부품 또는 이들을 조합한 것이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들 이나 숫자, 단계, 작동, 구성요소, 부품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않 는다. 또한, 본 명세서에서 사용한 \"제 1\", \"제 2\" 등과 같이 서수를 포함하는 용어는 다양한 구성 요소들을 설명하는 데 사용될 수 있지만, 상기 구성 요소들은 상기 용어들에 의해 한정되지는 않는다. 아래에서는 첨부한 도면을 참고하여 본 발명의 실시예에 대하여 본 발명이 속하는 기술 분야에서 통상의 지식을 가진 자가 용이하게 실시할 수 있도록 상세히 설명한다. 그리고 도면에서 본 발명을 명확하게 설명하기 위해서 설명과 관계없는 부분은 생략한다. 한편, 본 명세서에 따른 발명의 명칭은 발명의 특징을 드러내기 위해 '삼항 정밀도 기반의 행렬곱 연산을 수행 하는 디지털 신호 처리 장치'로 기재하였으나, 이하 명세서에서는 설명의 편의를 위해 '삼항 정밀도 기반의 행 렬곱 연산을 수행하는 디지털 신호 처리 방법 및 장치'는 '디지털 신호 처리 장'치로 지칭하여 설명하도록 한다. 인공지능 기술의 발달로 인해 다양한 분야에서 기계학습 모델이나 DNN(deep neural network) 모델이 사용되고 있으며, 이러한 모델들이 빠르게 추론 결과를 출력하면서 동시에 메모리를 절약하고 낮은 전력을 소모하도록 하 기 위해 행렬곱 연산을 수행함에 있어서 비트 수를 줄여 가중치 값으로 삼항 (ternary)을 사용하는 양자화 기법 이 도입되고 있다. 그러나, 종래 기술에 따른 SIMD 연산기의 경우 8비트 미만의 값을 지원하지 않다 보니 이보다 낮은 비트에서의 연산에 비효율이 발생하는데, 특히 행렬곱 (matrix multiplication) 등 대용량 연산이 필요한 경우 낮은 정밀도 를 최대한으로 활용하지 못하는 문제가 발생한다. 이를 구체적으로 살펴보면, 기존의 행렬곱 연산 라이브러리들은 8비트를 최소 자료형으로 지원하는 연산기에서 SIMD 연산이 이루어지기 때문에, 이러한 종래의 연산 방법은 이진 (binary), 삼항 (ternary) 정밀도를 이용하여 연산을 수행하는 다양한 기계학습 모델에 최적화되어 있지 않아 연산의 비효율 문제를 발생시키고 있다. 즉, 종 래 기술에 따른 연산 방법은 실제 값이 8비트 미만인데도 불구하고 최소 연산단위가 8비트이기 때문에 낮은 정 밀도를 사용하는 경우 불필요한 연산을 수행하기 때문에 연산 속도가 느려지는 문제가 발생한다. 또한, 종래 기술에 따른 SIMD 연산을 지원하는 연산기의 경우, 행렬곱의 곱연산의 결과물을 바로 32비트 레지스 터에 누적(accumulation) 시키기 때문에 일반적으로 오버플로 문제가 발생하지 않아 오버플로(overflow) 감지 기능 자체를 지원하지 않는다. 그러나, 삼항 연산에서는 연산의 특성상 오버플로 문제가 발생할 수 있기때문에, 이를 감지하고 적절하게 활용하면 연산의 효율을 높일 수 있음에도 불구하고, 아직까지는 이를 효율적 으로 활용하는 기술은 개발이 되지 않은 실정이다. 따라서, 일 실시예에 따른 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치는 이러한 문제점 을 해결하기 위해 고안된 발명으로서, 행렬곱의 한쪽 행렬이 삼항 {-1, 0, 1} 으로 양자화되고, 반대쪽 행렬이 8비트 미만의 고정 소수점 값으로 양자화 되어 있는 경우에 SIMD 연산을 지원하는 연산기에서 행렬곱을 효율적 으로 연산할 수 있는 방법을 제공하는데 그 목적이 있다. 구체적으로 본 발명에 따른 삼항 정밀도 기반의 행렬곱 연산을 수행하는 디지털 신호 처리 장치는, 상항 가중치 기반의 SIMD 연산에서 8비트 혹은 16비트의 누적 연산에 따라 레지스터에서 오버플로가 발생하는지 효율적으로 감지하고, 오버플로가 발생할 것으로 감지된 경우, 레지스터에 누적된 데이터를 다음 단계 레지스터로 이전하는 방법으로 SIMD 연산 전체의 속도를 증가시킬 수 있는 디지털 신호 처리 장치를 제공하는데 그 목적이 있다. 이 하 도면을 통해 본 발명의 특징 및 프로세스에 대해 자세히 알아본다. 도 1은 본 발명의 일 실시예에 따른 디지털 신호 처리 장치의 일부 구성 요소를 도시한 블록도이다. 도 1을 참조하여 설명하면, 일 실시예에 따른 디지털 신호 처리 장치는 입력되는 입력 데이터(X)에 대해 삼 항 가중치(W,Weight)를 적용하여 행렬 곱에 해당하는 MAC 연산을 수행하는 MAC 연산 모듈, MAC 연산 모듈 에서 출력되는 출력 데이터를 순차적으로 누적하는 복수 개의 누적기를 포함하는 누적기 모듈 및 누 적기 모듈에 포함되어 있는 복수 개의 누적기들의 오버플로 여부를 감지하는 오버플로 감지 모듈를 포함할 수 있다. MAC 연산 모듈은 디지털 신호 처리의 연산 과정 중 곱셈 누적 연산(Multiply and Accumulate)을 수행하는 구성으로서, 본 발명에 따른 MAC 연산 모듈은 입력되는 두 개의 행렬 데이터에 대해 행렬 곱 연산을 수행 할 수 있다. 구체적으로, MAC 연산 모듈은 8비트 미만의 크기를 가지는 입력 데이터(X)에 따른 행렬과 삼항(-1, 0, 1) 중 하나의 값을 가지는 삼항 가중치 데이터(W)에 따른 행렬에 대해 행렬 곱셈 연산을 수행한다. 본 명세서에서 는 설명의 편의를 위해 MAC 연산 모듈에 입력되는 데이터를 입력 데이터(X)로 지칭하였으나, MAC 연산 모 듈이 연산 레벨에서 동작하는 점에 비추어 입력 데이터(X)는 액티베이션(A, Activation)으로 지칭될 수 도 있다. 이하 명세서에서는, 설명의 편의를 위해 입력 데이터는 4비트의 크기를 가지고, 삼항 가중치 데이터는 2비트의 크기를 가지는 데이터를 기준으로 설명하나, 본 발명의 실시예가 이로 한정되는 것은 아니고 입력 데이터의 비 트의 크기는 설계 목적에 따라 8비트 이하의 다양한 비트의 크기를 가지는 데이터로 구현되도록 설계할 수 있다. MAC 연산 모듈은 두 입력 행렬(X,W)에 대해 곱셈 연산을 수행한 후, 수행한 연산 값을 출력 데이터로 하여 누적기 모듈로 출력 데이터를 송신하고, 누적기 모듈은 MAC 연산 모듈이 송신한 출력 데이터를 누적한다. MAC 연산 모듈에서 사용하는 논리 연산 방법은 입력되는 W값의 기초하여 다른 연산을 수행하는 것을 특징 으로 한다. 구체적으로, MAC 연산 모듈는, w값이 0과 비교하여 큰지, 0과 같은지를 나타내는 두 값 CEQZ (Compare Equal Zero)와 CGTZ (Compare Greater Zero)를 사용한다. 따라서, x에 CEQZ와 AND 연산을 취하여 w=0 이라면 0을 출력하도록 하고, 이후 CGTZ와 XOR 및 SUB 연산을 취하여 w=-1이라면 -x를 출력하도록 한다. 이에 대한 구체적인 설명은 도 2에서 예시를 통해 자세히 설명하도록 한다. 한편, MAC 연산 모듈에서 이루어지는 연산들은 모두 SIMD 형식의 입력, 출력 및 명령어를 사용할 수 있으 며, 이와 같이 논리 연산으로 MAC 연산을 대체한 것을 TernMAC이라 지칭할 수 있다. 따라서, MAC 연산 모듈 은 TernMAC 연산 모듈로 지칭될 수 있다. 누적기 모듈은 MAC 연산 모듈에서 출력하는 출력 데이터를 순차적으로 누적할 수 있다. 본 명세에서 표현되는 누적한다는 의미는 MAC 연산 모듈에서 이루어진 곱셈 연산에 대한 결과 값을 누적기 모듈에 순차적으로 저장하는 것을 의미한다. 구체적으로 누적기 모듈은 복수 개의 누적기(210, 220, 230..)를 포함할 수 있으며, 복수 개의 누적기는 도 2에 도시된 바와 같이 순차적으로 직렬적으로 연결되어 있을 수 있어, 이전 누적기에서 저장되어 있는 데이 터는 다음 누적기로 송신될 수 있다. 직렬적으로 연결되어 있는 누적기의 용량은 MAC 연산 모듈에서 멀어질수록 순차적으로 더 큰 용량을 가지도록 구현될 수 있다. 일 예로, 도 2에 도시된 바와 같이 누적기 모듈이 제1누적기 및 제2누적기를 포함하고 있는 경 우, MAC 연산 모듈에서 출력되는 출력 데이터는 MAC 연산 모듈과 직접적으로 연결되어 있는 제1누적 기에 맨 처음 저장된다. 즉, 제1누적기는 MAC 연산 모듈에서 출력되는 출력 데이터를 순차적으로 누적하게 되는데, 오버플로 감지 모듈에 의해 제1누적기의 저장 공간이 부족하여 더 이상 MAC 연산 모듈에서 출력하는 출력 데이터를 누적 할 수 없는 것으로 판단되는 경우, 그 때까지 제1누적기에 저장되어 있는 데이터들은 제2누 적기로 송신된다. 그리고 제1누적기 모듈은 오버플로 감지 모듈에 의해 다시 리셋(Reset)이 되 어 MAC 연산 모듈에서 출력하는 출력 데이터를 다시 순차적으로 누적한다. 제2누적기는 제1누적기와 직렬 연결되어 있어 제1누적기에서 출력되는 데이터를 저장하는 누적 기이다. 따라서, 제1누적기 보다 더 큰 비트수의 용량을 가지는 누적기로 구현될 수 있다. 일 예로, 제1누 적기가 8비트의 누적기라면, 제2누적기는 16비트의 누적기로 구현될 수 있다. 만약, 누적기 모듈이 제1누적기 및 제2누적기와 더불어 제3누적기를 포함하는 것으로 구현 되는 경우, 제3누적기는 제2누적기에서 오버플로가 발생하기 전까지 누적되어 있는 데이터를 수신 받 을 수 있다. 따라서, 제3누적기는 제2누적기보다 더 큰 비트의 누적기로 구현될 수 있다. 일 예로 제 1누적기는 8비트의 누적기로, 제2누적기는 16비트의 누적기로, 제3누적기는 32비트의 누적기로 구현될 수 있다. 한편, 본 발명에 따른 누적기의 개수 및 각각의 누적기의 용량은 상기 설명한 예로 한정되는 것은 아니고 누적 기의 개수는 2개, 3개 뿐만 아니라 더 많은 개수로 구현될 수 있으며, 직렬적으로 연결되어 있는 각각의 누적기 의 용량은 8비트 - 12비트 - 16비트 - 20비트, 8비트 - 16비트 - 24비트 - 32비트 등 순차적으로 비트가 증가하 는 경우라면 그 어떤 형태로도 구현될 수 도 있다. 따라서, MAC 연산 모듈과 누적기 모듈은 앞서 설명한 프로세스들을 수행할 수 있는 장치로 구현될 수 있는데, 일 예로 소량의 데이터나 처리 중인 중간 결과를 일시적으로 기억할 수 있는 장치인 레지스터 (register)로 구현될 수 있다. 즉, 레지스터는 한 단어 또는 여러 단어, 때로는 수의 자릿수의 정보를 기억하는 장치이기 때문에, 특정 목적에 사용되고, 수시로 그 내용을 이용할 수 있도록 되어 있어, 본 발명의 MAC 연산 모듈 및 누적기 모듈에 사용될 수 있다. 구체적으로, 본 발명에 따른 레지스터는 산술 연산, 논리 연산, 전송 조작을 행할 때 데이터나 명령을 일시적으 로 기억해둘 장소로 활용하게 되므로, MAC 연산 모듈은 그 용도에 맞춰 연산 레지스터(arithmetic register)로 구현될 수 있고, 누적기 모듈은 그 용도에 맞춰 누산기(accumulator)로 구현될 수 있다. 오버플로 감지 모듈은 누적기 모듈이 MAC 연산 모듈에서 출력하는 출력 데이터를 순차적으로 누 적함에 있어서, 오버플로(Overflow)가 발생할 가능성이 있는지 여부를 판단한다. 오버플로란, 사칙 연산의 결과 가 레지스터 또는 컴퓨터가 다룰 수 있는 수의 범위에서 삐어져 나오는 상태를 의미하는 것으로, 본 발명에서는 순차적으로 누적되는 출력 데이터의 총 합이 누적기의 저장 용량을 초과하는 경우를 의미한다. 따라서, 오버플 로 감지 모듈은 각각의 누적기에서 오버플로 여부가 발생할 수 있는지 판단하고, 특정 누적기에서 오버플 로가 발생할 것으로 판단된 경우, 직렬 연결되어 있는 다음 누적기로 데이터를 송신하도록 할 수 있다. 오버플로 감지 모듈이 복수 개의 누적기의 오버플로를 감지하는 방법은 누적기에 누적되는 데이터의 양에 기초한 카운터(counter) 방식의 오버플로 감지 방법과 누적기에 누적되는 데이터의 횟수에 기초한 벨류(value) 기반의 오버플로 감지 방법 2가지로 나누어질 수 있다. 이에 대한 자세한 알고리즘에 대한 설명은 후술하도록 한다. 도 2는 본 발명의 일 실시예에 따른 MAC 연산 모듈과 누적기 모듈을 상세하게 도시한 블록도이며, 도 3은 본 발 명의 일 실시예에 따른 MAC 연산 모듈을 상세하게 도시한 블록도이며, 도 4는 본 발명의 일 실시예에 따라 MAC 연산 모듈에서 논리 연산을 수행하는 개념을 설명한 도면이고, 도 5는 본 발명의 일 실시예에 따라 MAC 연산 모듈에서의 논리 연산을 일 예를 설명하기 위한 도면이며, 도 6은 본 발명의 일 실시예에 따라 누적기에 순차적 으로 데이터가 저장되는 과정을 설명하기 위한 도면이다. 도 2와 도 3 을 참조하면, MAC 연산 모듈에 입력되는 입력 데이터(X)는 순차적으로 MAC 연산 모듈의 연산 레지스터 모듈에 저장된다. 일반적인 디지털 신호 처리 장치는 2개의 MAC 블록(Dual-MAC)이나, 4개의 MAC 블록(Quad-MAC), 또는 그 이상의 MAC 블록을 병렬화하는 방식으로 디지털 신호 처리 장치 내부에 기능 블록을 구비함으로써 MAC 전체 연산을 가 속화할 수 있다. 따라서, 본 발명에 따른 MAC 연산 모듈 또한 도면에 도시된 바와 같이 n개의 연산 레지스터(R1, R2, R3,..)를 가지는 연산 레지스터 모듈을 포함하고 있으며, 각각의 입력 데이터(X)와 삼항 가중치(w, weight)에 대해 행렬곱 연산을 수행하는 복수개의 MAC 연산 모듈(121, 122, 123,..)를 포함할 수 있다. 이러한 구조로 인해, MAC 연산 모듈는 M1-비트의 크기의 입력 데이터들에 대한 행렬 곱 연산을 병렬적으로 한번에 수행할 수 있다. 본 발명에서는 설명의 편의를 위해 각각의 연산 레지스터는 8비트의 크기를 가지는 레지스터를 기준으로 설명하 고, 입력되는 데이터의 크기는 8비트 미만의 크기를 가지는 데이터(일 예로 4비트)를 데이터를 기준으로 설명하 도록 한다. 또한, 도 2에서는 설명의 편의를 위해 연산 레지스터 모듈이3개의 연산 레지스터(R1, R2, R3)를 포함하는 것으로 도시하였으나, 본 발명의 실시예가 이로 한정되는 것은 아니고 설계 목적에 따라 연산 레지스터 모듈 은 1개, 2개, 4개, 5개 또는 N개의 레지스터를 포함하도록 구현될 수 있다. MAC 연산 모듈은 복수 개의 MAC 연산부(121, 122, 123...)를 포함하고 있어, 연산 레지스터 모듈에 순차적으로 입력된 입력 데이터(x)들에 대한 입력 데이터 행렬과 삼항 가중치(w) 정보를 포함하고 있는 삼항 가 중치 행렬에 대해 각각 행렬곱 연산을 수행한다. 구체적으로, 각각의 MAC 연산 모듈은, w값이 0과 비교하여 큰지, 0과 같은지를 나타내는 두 값 CEQZ (Compare Equal Zero)와 CGTZ (Compare Greater Zero)를 사용하는데, x에 CEQZ와 AND 연산을 취하여 w=0이라면 0을 출력 하도록 하고, 이후 CGTZ와 XOR 및 SUB 연산을 취하여 w=-1이라면 -x를 출력하도록 한다. 즉. 도 4에 표시된 식처럼 MAC 연산 과정에 의해 MAC 연산 모듈에서 출력되는 출력 데이터는 y는 x*w로 표 현될 수 있는데, 이러한 식을 삼항 가중치에 대한 연산으로 변환하면y={xor(x,CGTZ(w))-CGTZ(w)}&CEQZ(w) 로 표현될 수 있다. 여기서, CGTZ는 w가 0보다 큰지 비교하여, w=-1일 때 ff을 출력하고, 아닐 때에는 0을 출력하 는 연산 논리이며, CEQZ 는 0과 동일한지 비교하는 연산으로, w=0일 때 0을 출력하고, 아닌 경우 ff를 출력하게 된다. 따라서, w = -1인 경우, 0xff와 bitwise xor을 취하면 0과 1이 반전되며, 0xff를 빼는 것은 1을 더하는 것과 사실상 같은데, bit 반전 후 1을 더하면 2's complement에서 부호 반전과 같다. 또한, 0xff와 bitwise and를 취하는 것은 출력 결과에 영향을 주지 않으므로 MAC 연산 모듈은 결국 -x를 출력하게 된다. w = 0인 경우에는 0x00과 bitwise and를 취하면 어떤 값도 0으로 만드므로, MAC 연산 모듈은 0을 출력하게 된다. w = 1인 경우에는 \"0x00\" 과 bitwise xor을 취하거나 0x00을 빼는 과정은 x값에 아무런 영항을 주지 않으며, 마 찬가지로 0xff 와 bitwise and를 취하는 것은 결과에 영향을 주지 않는다. 따라서, 이러한 경우 MAC 연산 모듈 은 입력되는 인풋 데이터 x를 그대로 출력하게 된다. 이러한 연산 과정을 도 5를 통해 예시를 들어 설명하면, 입력되는 인풋 데이터가 21로서 0001 0101 로 표현되 는 데이터이고, w=-1인 경우 도 5의 Case 1에 표시된 식들에 따라 MAC 연산이 수행될 수 있으며, 최종 출력값은 입력 데이터 x에 반전 부호(마이너스)만 곱하여 계산된 -21이 최종적으로 출력 된다. 만약, w=0인 경우 도 5의 Case 2에 표시된 식들에 따라 계산을 하게 되면 최종 출력값은 입력 데이터의 크기와 상관없이 0으로 출력되며, w=-1인 경우 도 5의 Case 3에 표시된 식들에 따라 계산을 하게 되면 최종 출력값은 입력 데이터를 그대로 출력하게 되는바 21이 출력 된다. 즉, MAC 연산 모듈에 수행되는 연산 결과는 입력 데이터가 8비트 미만의 데이터인 경우 출력 데이터 또한 논리 연산을 이용한 곱의 결과는 8비트 미만의 값을 가지게 된다. 따라서, 출력 데이터는 8비트와 16비트의 두 단계 또는 더 세분화되어 나누어진 누적기 모듈의 용량에 충분히 저장될 수 있는 데이터이므로 단계적으로 누적기 모듈의 누적기들에 나누어서 축적될 수 있다. 즉, 도 6에 도시된 바와 같이 MAC 연산 모듈에서 출력된 복수 개의 출력 데이터(y1,y2,y3,..yn)는 M1비트 의 크기를 가지는 복수 개의 누적기를 포함하는 제1누적기에 누적될 수 있는데, 구체적으로 제1출력 데이터(y1)는 제1-1누적기(Acc11)에, 제2출력 데이터(y2)는 제1-2누적기(Acc12)에, 제3출력 데이터(y3)는 제1-3누 적기(Acc13)에, 제n출력 데이터(y1)는 제1-n누적기(Acc1n)에 누적될 수 있다. 제1누적기에 출력 데이터들이 누적되면, 오버플로 감지 모듈은 각각의 누적기들의 오버플로 여부를 감지하고, 오버플로가 일어날 것으로 예상되는 누적기가 존재하는 경우, 해당 누적기에 누적되어 있는 데이터가 직렬 연결되어 있는 다음 누적기로 송신하도록 제어하고, 누적된 데이터를 송신한 누적기는 리셋을 하여 MAC 연 산 모듈에서 출력되는 출력 데이터를 다시 누적할 수 있도록 한다. 즉, 이와 같은 원리로 인해 제1누적기에 오버플로가 감지된 경우 제1누적기는 제2누적기로 데이 터를 전송하고, 제2누적기에 오버플로가 감지된 경우 제2누적기는 제3누적기로 누적값들을 계층적으 로(hierarchical) 전파하게 된다. 따라서, 누적기의 도번 번호가 높아질수록(도면의 아래로 향할수록) 누적기들 은 앞선 누적기에서 송신되는 누적 데이터를 충분히 저장할 공간이 필요하므로, 누적기에 할당되는 비트 수는 점점 커지게 된다. 예를 들어, 제1누적기의 누적기들은 8비트의 누적기들로 구현되고, 제2누적기의 누적기들은 16비트의 누적기들로 구현되고, 제3누적기의 누적기들은 32비트의 누적기들로 구현될 수 있다. 한편, 도 6에서는 오버플로 감지 모듈이 하나의 구성 요소로 구현되는 것으로 도시하였지만, 본 발명의 실 시예가 이로 한정되는 것은 아니고 오버플로 감지 모듈은 복수 개의 오버플로 감지부를 포함하고 있어, 복 수 개의 오버플로 감지부가 복수 개의 누적기의 오버플로 여부를 각각 감지할 수 도 있다. 오버플로 감지 모듈이 누적기의 오버플로를 감지하는 방법은 누적되는 데이터의 양에 기초한 카운터 (counter) 방식의 오버플로 감지 방법과 누적되는 데이터의 횟수에 기초한 벨류(value) 기반의 오버플로 감지 방법 2가지로 나누어질 수 있다. 이하 첫번째 방식인 카운터 방식의 오버플로 감지 방법에 대해 알아본다. 도 7은 본 발명의 일 실시예에 따른 오버플로 감지 모듈의 카운터 방식 기반의 오버플로 감지 방법을 설명하기 위한 누적기과 오버플로 감지 모듈과의 관계를 도시한 도면이고, 도 8은 본 발명의 일 실시예에 따라 제1누적기 와 제2누적기가 각각 8비트 및 16비트의 누적기인 경우, 제1카운터와 제2카운터가 카운트 하는 방법을 설명하기 위한 도면이며, 도 9 내지 도 19는 오버플로 감지부가 카운트 방식으로 누적기의 오버플로를 감지하는 방법을 하나의 예시를 기준으로 설명한 도면이다. 도 7을 참조하면, 오버플로 감지 모듈이 카운터 방식을 기반으로 누적기의 오버플로를 감지하는 경우 복수 개의 카운터(counter)를 포함할 수 있다. 구체적으로 도 7에 도시된 바와 같이, 오버플로 감지 모듈은 제1 누적기의 오버플로를 감지하는 제1카운터, 제2누적기의 오버플로를 감지하는 제2카운터를 포함할 수 있으며, 누적기 모듈가 k개의 누적기를 포함하는 경우, 오버플로 감지 모듈 또한 k개의 누 적기의 오버플로를 각각 감지하는 k개의 카운터를 포함할 수 있다. 제1카운터는 제1누적기의 오버플로를 감지할 수 있는데, 앞서 설명한 바와 같이 각각의 누적기는 병 렬 연산 처리를 위해 복수 개의 누적기를 포함하고 있으므로, 제1카운터는 제1누적기의 제1-1누적기 (Acc11), 제1-2누적기(Acc12), 제1-3누적기(Acc13) 등, 제1누적기가 포함하고 있는 모든 누적기에 대해 각각 오버플로 여부를 감지할 수 있다. 이와 마찬가지고, 제2카운터는 제2누적기의 오버플로를 감지할 수 있으며, 구체적으로 제2카운터 는 제2누적기의 제2-1누적기(Acc21), 제2-2누적기(Acc22), 제2-3누적기(Acc23) 등, 제2누적기 가 포함하고 있는 모든 누적기에 대해 각각 오버플로 여부를 감지할 수 있다. 카운터는 오버플로 여부를 감지하는 누적기의 임계 카운터 횟수를 기초로 누적기의 오버플로 여부를 판단할 수 있다. 임계 카운터란 누적기에 오버플로가 발생하지 않을 출력 데이터의 최대 누적 횟수를 의미하는 숫자로서, 임계 카운터까지는 출력 데이터의 크기에 상관없이 누적기에 출력 데이터가 저장될 수 있는 것을 의미한다. 예를 들어, 4비트 값을 가진 데이터를 8비트 공간을 가지는 누적기에 누적하는 경우, 4비트 값을 가진 데이터의 크기를 항상 최대로 계산하여도, 최소 16회 까지는 누적을 하여도 오버플로가 발생하지 않게 된다. 즉, 2^4(4비 트 데이터의 최대 크기) * 16(임계 카운터) = 2^8 이 되므로, 오버플로가 발생하지 않게 된다. 그리고 이를 일 반화하여 각각의 카운터에 대한 임계 카운터 Ck는 아래와 같이 수학 식 로 표현될 수 있다. 수학식 - Ck= 2^Mk-Mk-1 수학식 에서 Mk-1는 출력 데이터가 누적되는 누적기의 비트 값을 의미하고, Mk 는 오버플로가 발생하는 경우 데이터를 수신하는 다음 누적기의 비트 값을 의미하며, M0는 MAC 연산 모듈에서 출력되는 출력 데이터의 비트 값을 의미한다. 따라서, 출력 데이터의 비트 값이 4비트이고, 제1누적기의 비트 값이 8비트이고, 제2 누적기의 비트 값이 16비트인 경우, 제1카운터의 임계 카운터 C1은 도 8에 표현 되어 있다시피 C1은 16이 되고, 제2카운터의 임계 카운터 C2는 256이 된다. 따라서, 제1카운터는 제1누적기에 MAC 연산 모듈의 출력 데이터가 총 16번 누적이 된 경우, 제1 누적기에 오버플로가 발생할 가능성이 있다고 판단하여, 제1누적기에 16번에 걸쳐 저장되어 있는 데 이터들을 제2누적기로 송신하고 제1누적기를 리셋(Reset)시켜 다시 제1누적기(210가 MAC 연산 모듈 의 출력 데이터를 누적할 수 있도록 한다. 이를 도 9 내지 도 19를 통해 하나의 예시를 기준으로 설명하면, 도 9에 따라 제1누적기가 MAC 연산 모듈 의 데이터를 수신하지 않은 경우 모든 누적기의 저장 공간은 리셋이 되어 있다. 이러한 상태에서 MAC 연산 모듈에서 의 첫 출력 데이터를 제1누적기가 수신하는 경우, 도 10에 도시된 바와 같이 제1누적기 의 각각의 누적기들을 출력 데이터들을 임시적으로 저장하며, 이렇게 하나의 프로세스를 마친 경우 제1카 운터의 카운터는 1이 된다. 그 후, 도 11에 도시된 바와 같이 제1누적기는 MAC 연산 모듈의 출력 데이터를 한 번 더 수신하게 되 고, 수신한 데이터를 누적 저장한다. 그리고 이러한 경우 한번의 프로세스를 더 거쳤으므로 제1카운터의 카운터는 2가 된다. 이러한 과정을 계속 거치면 카운터는 하나씩 증가하게 되며 제1카운터의 카운터가 15 가 되는 경우 도 12와 같이 표현될 수 있다. 이 상태에서, 제1누적기가 MAC 연산 모듈의 출력 데이터를 한번 더 수신하게 되면 도 13과 같이 제1 카운터의 카운터는 16이 되며, 16은 앞서 살펴본 바와 같이 제1누적기의 임계 카운터에 해당한다. 따 라서, 이러한 경우 도 14에 도시된 바와 같이 제1누적기에 저장되어 있는 모든 데이터들은 각각 직렬 연결 되어 있는 제2누적기로 송신되어 지며, 제2누적기는 처음으로 데이터를 수신 받았으므로, 제2카운터 의 카운터는 1이 된다. 한편, 제2누적기로 데이터를 송신한 제1누적기는 MAC 연산 모듈의 출력 데이터를 다시 순차적으로 누적할 수 있도록 도 15에 도시된 바와 같이 제1누적기의 저장 공간이 리 셋이 된다. 리셋이 된 후, 제1누적기는 도 16에 도시된 바와 같이 MAC 연산 모듈의 출력 데이터를 수신한 후 저 장하며, 이러한 과정을 계속 거치는 경우 도 17에 도시된 바와 같이 제1카운터의 카운터는 임계 카운터인 16에 다시 도달하게 된다. 따라서 이러한 경우 앞서 살펴본 바와 같이 제1누적기에 저장되어 있는 데이터 들은 도 18에 도시된 바와 같이 제2누적기로 송신되며, 제2누적기는 앞서 수신한 데이터와 더불어 두 번째로 수신받은 데이터들을 함께 저장하게 된다. 그리고 이러한 과정에 의해, 제2카운터의 카운터는 2로 증가하게 된다. 한편, 제2누적기로 데이터를 송신한 제1누적기는 MAC 연산 모듈의 출력 데이터를 다시 누적할 수 있도록 도 19에 도시된 바와 같이 카운터 및 저장 공간이 리셋이 된다. 즉, 이러한 프로세스에 의해 제2누적기도 데이터가 누적되며, 제2누적기에 데이터가 누적됨에 따라 제2카운터의 카운터가 임계 카운터인 256에 도달하는 경우, 제2누적기에 저장되어 있는 데이터들은 모두 제3누적기로 이동되어 저장되어 진다. 지금까지 설명한 연산 방법에 따르면, 본 발명에 따른 신호 처리 장치는 삼항 가중치를 사용한 SIMD 연산에 따라, 행렬곱의 결과를 누적기에 누적할 때, 상대적으로 낮은 비트의 누적기의 오버플로 여부를 판단하고 이를 기초로 누적기의 활용을 제어하므로, 종래 기술과 다르게 연산을 함에 있어서 보다 작은 비트 수를 가지는 누적 기를 많이 사용할 수 있어 SIMD 연산의 전체 속도를 효율적으로 증가시킴과 동시에 전력의 효율을 높일 수 있는 장점이 존재한다. 또한, 본 발명에 따른 연산 방법은 행렬곱 연산의 속도를 향상시키므로, 연산 시간의 대부분이 행렬곱 연산으로 이루어져있는 인공지능 모델의 추론 속도를 비약적으로 향상시킬 수 있다. 실제 Intel CPU에서 측정한 결과에 따르면ResNet-50, MobileNet-V2, EfficientNet-B0 등의 다양한 DNN 구조에 본 발명의 원리를 적용하는 경우 모 델의 연산 속도가 기존 라이브러리 대비 약 2~3배이상의 빨라진 것을 알 수 있었다. 지금까지 오버플로 감지 모듈이 누적기의 오버플로를 감지하는 방법으로 카운터(counter) 방식의 오버플로 감지 방법에 대해 알아보았다. 이하 도면을 통해 데이터의 횟수에 기초한 벨류(value) 기반의 오버플로 감지 방법에 대해 알아본다. 도 20은 본 발명의 일 실시예에 따른 오버플로 감지 모듈의 벨류 방식 의 오버플로 감지 방법을 설명하기 위한 오버플로 감지 모듈의 구성을 도시한 블럭도이고, 도 21 내지 도 25는 본 발명의 일 실시예에 따른 오버플로 감 지 모듈의 벨류 방식의 오버플로 감지 방법을 설명하기 위한 도면이다. 도 20을 참조하면, 일 실시예에 따른 오버플로 감지 모듈은 도 20에 도시된 바와 같이 오버플로 감지 회로 를 포함할 수 있다. 구체적으로 오버플로 감지 회로는 도 20에 도시된 바와 같이 Sign bit와 C_out 값을 따져서 오버플로 여부 를 나타내는 신호(0 or 1)을 출력하는 회로로서, Sign bit는 데이터 값의 부호를 나타내는 신호로서 데이터 값 이 양수인 경우 0으로 나타내고, 데이터 값이 음수인 경우 1을 나타낸다. 따라서, 오버플로 감지 회로는 MAC 연산 모듈에서 출력되는 출력 데이터를 합산하고 누적함에 있어서, 실제로 누적되는 데이터의 양을 계 산하고, 계산된 값과 누적기의 용량을 고려하여 오버플로 여부를 감지할 수 있다. 도 21의 케이스를 참고하여 설명하면, 지금까지 제1누적기에 누적된 데이터의 양이 72이고 88을 합산해야 한다면, 합산 값은 160이 되고 8비트가 표현할 수 있는 범위는 -128에서 127 사이이므로, 8비트로 160을 표현할 수 가 없으므로 이 경우 오버플로 감지 모듈은 오버플로가 발생할 수 있는 것으로 판단한다. 도 22의 케이스를 참고하여 다른 경우를 설명하면, 지금까지 제1누적기에 누적된 데이터의 양이 32이고 8 을 합산해야 한다면, 합산 값은 40이 되고 이 수는 8비트가 표현할 수 있는 범위에 표현되므로 오버플로가 발생 할 수 있는 경우가 아니다. 따라서, 오버플로 감지 모듈은 오버플로가 발생하지 않는 케이스로 판단한다. 또한 도 23의 케이스의 경우처럼, 지금까지 제1누적기에 누적된 데이터의 양이 72이고 -76을 합산해야 한 다면, 합산 값은 -4가 되고 이 수는 8비트가 표현할 수 있는 범위에 표현되므로 오버플로가 발생할 수 있는 경 우가 아니다. 따라서, 이 경우 오버플로 감지 모듈은 오버플로가 발생하지 않는 케이스로 판단한다. 그러나 도 24의 케이스처럼, 지금까지 제1누적기에 누적된 데이터의 양이 -87이고 -61을 합산해야 한다면, 합산 값은 -148이 되고 이는 8비트가 표현할 수 있는 범위를 초과하는 경우이므로 오버플로가 발생할 수 있는 경우에 해당한다. 따라서, 이러한 경우 오버플로 감지 모듈은 오버플로가 발생할 수 있는 것으로 판단한다. 즉, 이러한 원리로 오버플로 감지 모듈은 각각의 누적기의 오버플로 여부를 감지하고, 오버플로 가 발생할 것으로 감지된 경우 누적기의 데이터를 이전시키는 방법으로 전체 연산의 속도를 향상시킬 수 있다. 이하 도면을 통해 구체적으로 알아본다. 도 25는 본 발명의 일 실시예에 따른 누적기 모듈과 오버플로 감지 모듈의 관계를 도시한 블록도이고, 도 26 내지 도 34는 본 발명의 실시예에 따라 오버플로 감지 모듈이 밸류 기반 방식의 오버플 로를 감지하는 방법을 설명하기 위한 도면이다. 도 25를 참조하면, 밸류 기반 방식의 오버플로 감지 모듈은 각각의 누적기에 포함되어 있는 복수 개의 누 적기의 누적 값을 개별적으로 연산하여 판단하므로, 도면에 도시된 바와 같이 각각의 누적기에 일대일로 오버플 로 감지기(OFD, Overflow Detector)가 연결되어 있다. 즉, 제1-1누적기(Acc11)에는 제1-1오버플로 감지기(OFD11)가 연결되어 있어 제1-1누적기(Acc11)의 오버플로 여 부를 감지하고, 제1-2누적기(Acc12)에는 제1-2오버플로 감지기(OFD12)가 연결되어 있어 제1-2누적기(Acc11)의 오버플로 여부를 감지한다. 또한, 제2-1누적기(Acc21)에는 제2-1오버플로 감지기(OFD21)가 연결되어 있어 제2-1누적기(Acc21)의 오버플로 여부를 감지하고, 제3-1누적기(Acc31)에는 제3-1오버플로 감지기(OFD31)가 연결되어 있어 제3-1누적기(Acc31)의 오버플로 여부를 감지한다. 따라서, 일 실시예에 따른 오버플로 감지 모듈은 누적기의 총 개수만큼의 오버플로 감지기(OFD)를 포함하 고 있고, 각각의 오버플로 감지기는 연결되어 있는 누적기의 오버플로 개별적으로 감지할 수 있다.개별 오버플 로 감지기(OFD)가 어떻게 오버플로를 감지하는지에 대해서는 도 26 내지 도 34를 통해 설명한다. 도 26은 MAC 연산 모듈에서의 출력 데이터가 아직 각각의 누적기에 입력되기 이전의 상태로서, 모든 누적 기의 상태는 리셋 상태이다. 이러한 상태에서, 도 27과 도 28처럼 순차적으로 출력 데이터가 입력이 되면 각각 의 오버플로 감지기는 연결되어 있는 누적기의 누적 연산 값을 계산한다. 도 27의 경우 제1-1누적기(ACC11)의 누적 비트 값은 50이 되고, 제1-3누적기(ACC13)의 누적 비트 값은 1이 되며, 도 28의 경우 제1-1누적기(ACC11)의 누적 비트 값은 100이 되고, 제1-3누적기(ACC13)의 누적 비트 값은0이 된다. 이러한 상태에서 도 29에서처럼 제1-1누적기(ACC11)에 50이 더 들어오게 되면 8비트의 용량을 가지는 제1-1누적 기(ACC11)의 용량을 초과하게 되므로 이 경우 제1-1 누적기(ACC11)에는 오버플로가 발생할 수 있는 것으로 판단 한다. 그러나, 제1-3누적기(ACC11)의 경우 도 29의 상황에서도 누적 값은 1이 되므로 오버플로가 발생하지 않는 다. 오버플로가 발생할 것으로 예상되면, 앞서 설명한 바와 같이 제1-1누적기(ACC11)에 누적되어 있는 데이터는 제 2-1누적기(ACC12)로 송신되며, 제1-1누적기(ACC11) 대해서는 도 30에 도시된 바와 같이 리셋이 된다. 그리고 다 시 도 31, 도 32, 도33에 도시된 바와 같이 MAC 연산 모듈의 출력 데이터가 순차적으로 입력되면 각각의 누적기는 출력 데이터에 대해 누적을 하며, 도 33에서과 같이 제1-1누적기(ACC11)에 오버플로가 발생할 것으로 예상되면, 도 34처럼 제1-1누적기(ACC11)에 누적되어 있는 데이터는 제2-1누적기(ACC12)로 송신되며, 제1-1누적 기(ACC11) 대해서는 도 30에 도시된 바와 같이 리셋이 된다. 이 경우 제2-1누적기(ACC21)의 전체 누적 값은 300(=150+150)이 된다. 이러한 원리로 오버플로 감지 모듈은 각각의 누적기의 오버플로 여부를 감지하고, 오버플로가 발생할 것으 로 감지된 경우 누적기의 데이터를 이전시키는 방법으로 전체 연산의 속도를 향상시킬 수 있다. 구체적으로, 밸 류 방식의 오버플로 감지 모듈에 따라 오버플로를 감지하는 경우, 각각의 누적기에 대해 오버플로가 발생 할 수 있을 때까지 연산 값을 최대한 더하기 때문에 작은 비트 수를 가지고 있는 누적기를 최대한 많이 활용할 수 있는 장점이 존재한다. 이를 카운터 방식의 오버플로 감지 방법과 비교하여 설명하면, 카운터 기반의 오버플로 감지 방법은 오버플로가 절대 일어나지 않을 범위의 횟수에 대해서만 해당 누적기에서 누적을 수행하므로 보다 안전하게 연산을 수행할 수 있는 장점이 존재한다. 반면, signal 값을 통한 밸류 방식의 오버플로 감지 방법은 오버플로가 일어나기 직 전까지 해당 누적기에서 누적 연산을 수행할 수 있어, 크기가 작은 비트를 가지는 누적기를 더 많이 사용할 수 있어, 높은 연산 속도와 더불어 전력을 효율을 높일 수 있는 장점이 존재한다. 지금가지 본 발명의 일 실시예에 따른 디지털 신호 처리 장치의 구성 요소 및 프로세스에 대해 자세히 알아 보았다. 일 실시예에 따른 신호 처리 장치는 삼항 가중치를 사용한 SIMD 연산 방법에 있어서, 상대적으로 낮은 비트의 누적기의 오버플로 여부를 판단하고 이를 기초로 누적기의 활용을 제어하므로, 종래 기술과 다르게 행렬곱 연산 을 함에 있어서 보다 작은 비트 수를 가지는 누적기를 많이 사용할 수 있어 SIMD 연산의 전체 속도를 효율적으 로 증가시킴과 동시에 전력의 효율을 높일 수 있는 장점이 존재한다. 따라서, 본 발명에 따른 연산 방법은 행렬곱 연산의 속도를 향상시키므로, 연산 시간의 대부분이 행렬곱 연산으 로 이루어져있는 인공지능 모델의 추론 속도를 비약적으로 향상시킬 수 있는 장점이 존재한다. 이상에서 설명된 장치는 하드웨어 구성요소, 소프트웨어 구성요소, 및/또는 하드웨어 구성요소 및 소프트웨어 구성요소의 조합으로 구현될 수 있다. 예를 들어, 실시예들에서 설명된 장치 및 구성요소는, 예를 들어, 프로세 서, 컨트롤러, ALU(arithmetic logic unit), 디지털 신호 프로세서(digital signal processor), 마이크로컴퓨 터, FPA(field programmable array), PLU(programmable logic unit), 마이크로프로세서, 또는 명령 (instruction)을 실행하고 응답할 수 있는 다른 어떠한 장치와 같이, 하나 이상의 범용 컴퓨터 또는 특수 목적 컴퓨터를 이용하여 구현될 수 있다. 처리 장치는 운영 체제(OS) 및 운영 체제 상에서 수행되는 하나 이상의 소 프트웨어 애플리케이션을 수행할 수 있다. 또한, 처리 장치는 소프트웨어의 실행에 응답하여, 데이터를 접근, 저장, 조작, 처리 및 생성할 수도 있다. 이해의 편의를 위하여, 처리 장치는 하나가 사용되는 것으로 설명된 경"}
{"patent_id": "10-2021-0152452", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "우도 있지만, 해당 기술분야에서 통상의 지식을 가진 자는, 처리 장치가 복수 개의 처리 요소(processing element) 및/또는 복수 유형의 처리 요소를 포함할 수 있음을 알 수 있다. 예를 들어, 처리 장치는 복수 개의 프로세서 또는 하나의 프로세서 및 하나의 컨트롤러를 포함할 수 있다. 또한, 병렬 프로세서(parallel processor)와 같은, 다른 처리 구성(processing configuration)도 가능하다. 실시예에 따른 방법은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 상기 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등을 단독으로 또는 조합하여 포함할 수 있다. 상기 매체에 기록되는 프로그램 명령은 실시예를 위하여 특별히 설계 되고 구성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판독 가 능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD-ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체 (magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도 록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다."}
{"patent_id": "10-2021-0152452", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "이상과 같이 실시예들이 비록 한정된 실시예와 도면에 의해 설명되었으나, 해당 기술분야에서 통상의 지식을 가 진 자라면 상기의 기재로부터 다양한 수정 및 변형이 가능하다. 예를 들어, 설명된 기술들이 설명된 방법과 다 른 순서로 수행되거나, 및/또는 설명된 시스템, 구조, 장치, 회로 등의 구성요소들이 설명된 방법과 다른 형태 로 결합 또는 조합되거나, 다른 구성요소 또는 균등물에 의하여 대치되거나 치환되더라도 적절한 결과가 달성될 수 있다. 그러므로, 다른 구현들, 다른 실시예들 및 특허청구범위와 균등한 것들도 후술하는 특허청구범위의 범 위에 속한다."}
{"patent_id": "10-2021-0152452", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 일 실시예에 따른 디지털 신호 처리 장치의 일부 구성 요소를 도시한 블록도이다. 도 2는 본 발명의 일 실시예에 따른 MAC 연산 모듈과 누적기 모듈을 상세하게 도시한 블록도이다. 도 3은 본 발명의 일 실시예에 따른 MAC 연산 모듈을 상세하게 도시한 블록도이다. 도 4는 본 발명의 일 실시예에 따라 MAC 연산 모듈에서 논리 연산을 수행하는 개념을 설명한 도면이다. 도 5는 본 발명의 일 실시예에 따라 MAC 연산 모듈에서 논리 연산을 일 예를 설명하기 위한 도면이다. 도 6은 본 발명의 일 실시예에 따라 누적기에 순차적으로 데이터가 저장되는 과정을 설명하기 위한 도면이다. 도 7은 본 발명의 일 실시예에 따른 오버플로 감지 모듈의 카운터 방식 기반의 오버플로 감지 방법을 설명하기 위한 누적기과 오버플로 감지 모듈과의 관계를 도시한 도면이다.도 8은 본 발명의 일 실시예에 따라 제1누적기와 제2누적기가 각각 8비트 및 16비트의 누적기인 경우, 제1카운 터와 제2카운터가 카운트 하는 방법을 설명하기 위한 도면이다. 도 9 내지 도 19는 오버플로 감지부가 카운트 방식으로 누적기의 오버플로를 감지하는 방법을 하나의 예시를 기 준으로 설명한 도면이다. 도 20은 본 발명의 일 실시예에 따른 오버플로 감지 모듈의 벨류 방식 의 오버플로 감지 방법을 설명하기 위한 오버플로 감지 모듈의 구성을 도시한 블럭도이다. 도 21 내지 도 24는 본 발명의 일 실시예에 따른 오버플로 감지 모듈의 벨류 방식의 오버플로 감지 방법을 설명 하기 위한 도면이다. 도 25는 본 발명의 일 실시예에 따른 누적기 모듈과 오버플로 감지 모듈의 관계를 도시한 블록도이다. 도 26 내지 도 34는 본 발명의 실시예에 따라 오버플로 감지 모듈이 밸류 기반 방식의 오버플로를 감지하는 방 법을 설명하기 위한 도면이다."}
