{"patent_id": "10-2017-0036256", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2018-0033036", "출원번호": "10-2017-0036256", "발명의 명칭": "멀티 쓰레드 프로세서 및 제어 방법", "출원인": "삼성전자주식회사", "발명자": "서동관"}}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "쓰레드(thread)를 처리하는 적어도 하나의 기능 유닛;하나의 기능 유닛에서 동시에 처리 가능한 쓰레드의 크기 및 개수에 따라 구분된 복수의 쓰레드 모드 중, 처리대상 작업에 대응되는 쓰레드 모드 정보를 저장하는 모드 레지스터; 및상기 모드 레지스터에 저장된 상기 쓰레드 모드 정보에 기초하여 상기 처리 대상 작업에 포함된 적어도 하나의쓰레드를 상기 적어도 하나의 기능 유닛으로 할당하는 컨트롤러;를 포함하는 멀티 쓰레드 프로세서."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 복수의 쓰레드 모드는,하나의 기능 유닛에 상기 기능 유닛의 데이터 크기보다 작은 서로 다른 크기의 복수의 쓰레드를 할당하는 모드를 포함하는, 멀티 쓰레드 프로세서."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 복수의 쓰레드 모드는,하나의 기능 유닛의 최대 처리 용량의 1/(2n) 크기를 가지는 쓰레드의 조합으로 복수의 쓰레드를 상기 하나의기능 유닛에 할당하는 모드를 포함하며,상기 n은 자연수인, 멀티 쓰레드 프로세서."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 쓰레드의 크기는,최대 처리 용량을 (2n)으로 나눈 크기이고, 스칼라 데이터 패스 크기(scalar data path size)보다 큰, 멀티 쓰레드 프로세서."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 컨트롤러는,상기 처리 대상 작업에 대응되는 모드에 포함된 쓰레드 개수 만큼의 인스트럭션을 페치(fetch)하고, 상기 페치된 인스트럭션에 기초하여 상기 기능 유닛에 할당된 쓰레드를 처리하는, 멀티 쓰레드 프로세서."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제3항에 있어서,상기 컨트롤러는,상기 하나의 기능 유닛에 할당된 쓰레드에 대응되는 데이터를 리딩하기 위한 어드레스를 생성하고,상기 멀티 쓰레드 프로세서는,상기 컨트롤러에서 생성된 어드레스에 기초하여 리딩된 데이터를 상기 하나의 기능 유닛으로 전달하는 벡터 레공개특허 10-2018-0033036-3-지스터;를 더 포함하는, 멀티 쓰레드 프로세서."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "멀티 쓰레드 프로세서의 제어 방법에 있어서,쓰레드(thread)를 처리하는 적어도 하나의 기능 유닛에서 동시에 처리 가능한 쓰레드의 크기 및 개수에 따라 구분된 복수의 쓰레드 모드 중, 처리 대상 작업에 대응되는 쓰레드 모드 정보를 저장하는 단계; 및상기 저장된 쓰레드 모드 정보에 기초하여 상기 처리 대상 작업에 포함된 적어도 하나의 쓰레드를 상기 적어도하나의 기능 유닛으로 할당하는 단계;를 포함하는 멀티 쓰레드 프로세서의 제어 방법."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 복수의 쓰레드 모드는,하나의 기능 유닛에 상기 기능 유닛의 데이터 크기보다 작은 서로 다른 크기의 복수의 쓰레드를 할당하는 모드를 포함하는, 멀티 쓰레드 프로세서의 제어 방법."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제7항에 있어서,상기 복수의 쓰레드 모드는,하나의 기능 유닛의 최대 처리 용량의 1/(2n) 크기를 가지는 쓰레드의 조합으로 복수의 쓰레드를 상기 하나의기능 유닛에 할당하는 모드를 포함하며,상기 n은 자연수인, 멀티 쓰레드 프로세서의 제어 방법."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 쓰레드의 크기는,최대 처리 용량을 (2n)으로 나눈 크기이고, 스칼라 데이터 패스 크기(scalar data path size)보다 큰, 멀티 쓰레드 프로세서의 제어 방법."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서,상기 처리 대상 작업에 대응되는 모드에 포함된 쓰레드 개수 만큼의 인스트럭션을 페치(fetch)하고, 상기 페치된 인스트럭션에 기초하여 상기 기능 유닛에 할당된 쓰레드를 처리하는 단계;를 더 포함하는 멀티 쓰레드 프로세서의 제어 방법."}
{"patent_id": "10-2017-0036256", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제9항에 있어서,상기 멀티 쓰레드 프로세서의 제어 방법은,상기 하나의 기능 유닛에 할당된 쓰레드에 대응되는 데이터를 리딩하기 위한 어드레스를 생성하는 단계; 및상기 생성된 어드레스에 기초하여 리딩된 데이터를 상기 하나의 기능 유닛으로 전달하는 단계;를 더 포함하는멀티 쓰레드 프로세서의 제어 방법."}
{"patent_id": "10-2017-0036256", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "인공지능(AI) 시스템을 구현하기 위한 멀티 쓰레드 프로세서 및 제어 방법이 개시된다. 딥러닝 등의 기계 학습 알고리즘을 활용하여 인간 두뇌의 인지, 판단 등의 기능을 모사할 수 있는 인공지능(AI) 시스템을 구현하기 위한 멀티 쓰레드 프로세서는 쓰레드(thread)를 처리하는 적어도 하나의 기능 유닛, 하나의 기능 유닛에서 동시에 처 리 가능한 쓰레드의 크기 및 개수에 따라 구분된 복수의 쓰레드 모드 중, 처리 대상 작업에 대응되는 쓰레드 모 드 정보를 저장하는 모드 레지스터 및 모드 레지스터에 저장된 쓰레드 모드 정보에 기초하여 처리 대상 작업에 포함된 적어도 하나의 쓰레드를 적어도 하나의 기능 유닛으로 할당하는 컨트롤러를 포함한다."}
{"patent_id": "10-2017-0036256", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 인공지능 시스템을 구현하기 위한 멀티 쓰레드 프로세서 및 제어 방법에 관한 것으로, 보다 상세하게 는 동시에 복수의 쓰레드를 처리하는 멀티 쓰레드 프로세서 및 제어 방법에 관한 것이다."}
{"patent_id": "10-2017-0036256", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능(Artificial Intelligence, AI) 시스템은 인간 수준의 지능을 구현하는 컴퓨터 시스템이며, 기존 Rule 기반 스마트 시스템과 달리 기계가 스스로 학습하고 판단하며 똑똑해지는 시스템이다. 인공지능 시스템은 사용 할수록 인식률이 향상되고 사용자 취향을 보다 정확하게 이해할 수 있게 되어, 기존 Rule 기반 스마트 시스템은 점차 딥러닝 기반 인공지능 시스템으로 대체되고 있다. 인공지능 기술은 기계학습(딥러닝) 및 기계학습을 활용한 요소 기술들로 구성된다. 기계학습은 입력 데이터들의 특징을 스스로 분류/학습하는 알고리즘 기술이며, 요소 기술은 딥러닝 등의 기계학 습 알고리즘을 활용하여 인간 두뇌의 인지, 판단 등의 기능을 모사하는 기술로서, 언어적 이해, 시각적 이해, 추론/예측, 지식 표현, 동작 제어 등의 기술 분야로 구성된다. 인공지능 기술이 응용되는 다양한 분야는 다음과 같다. 언어적 이해는 인간의 언어/문자를 인식하고 응용/처리 하는 기술로서, 자연어 처리, 기계 번역, 대화시스템, 질의 응답, 음성 인식/합성 등을 포함한다. 시각적 이해 는 사물을 인간의 시각처럼 인식하여 처리하는 기술로서, 객체 인식, 객체 추적, 영상 검색, 사람 인식, 장면 이해, 공간 이해, 영상 개선 등을 포함한다. 추론 예측은 정보를 판단하여 논리적으로 추론하고 예측하는 기술 로서, 지식/확률 기반 추론, 최적화 예측, 선호 기반 계획, 추천 등을 포함한다. 지식 표현은 인간의 경험정보 를 지식데이터로 자동화 처리하는 기술로서, 지식 구축(데이터 생성/분류), 지식 관리(데이터 활용) 등을 포함 한다. 동작 제어는 차량의 자율 주행, 로봇의 움직임을 제어하는 기술로서, 움직임 제어(항법, 충돌, 주행), 조 작 제어(행동 제어) 등을 포함한다. 이상과 같이 인공지능 시스템의 구현을 위해서는 방대한 데이터의 신속한 처리가 요구된다. 예를 들어, 인공지능 시스템은 드라이버 어시스턴스 시스템(Driver Assistance System) 등에 적용될 수 있으며, 이 경우 드라이버 어시스턴스 시스템은 스마트 자동차의 차선 인식, 장애물 식별, 보행자 인식, 자동차 추적 등 을 위해 대량의 이미지 데이터를 실시간으로 처리해야 한다. 또한, DTV, 스마트폰의 해상도가 증가함에 따라 영 상 처리를 위해 사용되는 이미지의 데이터 양이 증가하고 알고리즘 또한 복잡해지고 있다. 따라서, 이미지 데이 터를 실시간으로 처리하기 위한 커널 함수 또는 기능들에 대한 효율적인 처리가 중요해지고 있다. 최근에는 인공지능 시스템에서 특히 기계학습을 위한 데이터 병렬화 프로세서에 대한 연구가 진행되고 있다. 기 계학습은 작업을 반복적으로 수행함으로써 결과를 얻어내는 기술의 개선 과정으로, 특히 더 많은 데이터를 빠르 게 처리하기 위해 데이터 병렬화 프로세서 구조에 대한 연구가 진행되고 있다. 그러나, 많은 프로세서들은 특정 응용 코드의 처리를 할 때 비효율적일 수 있다. 따라서, 다양한 벡터화된 응용 코드의 처리를 수행할 수 있는 멀티쓰레딩이 가능한 프로세서에 대한 필요성이 존재한다."}
{"patent_id": "10-2017-0036256", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명의 목적은 인공지능 시스템을 구현하기 위한 다양한 크기의 복수 개의 쓰레드를 동시에 처리할 수 있는 멀티 쓰레드 프로세서 및 제어 방법을 제공함에 있다."}
{"patent_id": "10-2017-0036256", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "이상과 같은 목적을 달성하기 위한 본 발명의 일 실시 예에 따른 멀티 쓰레드 프로세서는 쓰레드(thread)를 처 리하는 적어도 하나의 기능 유닛, 하나의 기능 유닛에서 동시에 처리 가능한 쓰레드의 크기 및 개수에 따라 구 분된 복수의 쓰레드 모드 중, 처리 대상 작업에 대응되는 쓰레드 모드 정보를 저장하는 모드 레지스터, 및 상기 모드 레지스터에 저장된 상기 쓰레드 모드 정보에 기초하여 상기 처리 대상 작업에 포함된 적어도 하나의 쓰레 드를 상기 적어도 하나의 기능 유닛으로 할당하는 컨트롤러를 포함한다. 그리고, 본 발명의 일 실시 예에 따른 멀티 쓰레드 프로세서의 제어 방법은 쓰레드(thread)를 처리하는 적어도 하나의 기능 유닛에서 동시에 처리 가능한 쓰레드의 크기 및 개수에 따라 구분된 복수의 쓰레드 모드 중, 처리 대상 작업에 대응되는 쓰레드 모드 정보를 저장하는 단계 및 상기 저장된 쓰레드 모드 정보에 기초하여 상기 처 리 대상 작업에 포함된 적어도 하나의 쓰레드를 상기 적어도 하나의 기능 유닛으로 할당하는 단계를 포함한다."}
{"patent_id": "10-2017-0036256", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "이상 설명한 바와 같이 다양한 실시 예에 따르면 인공지능 시스템을 구현하기 위한 멀티 쓰레드 프로세서 및 제 어 방법은 다양한 크기의 복수 개의 쓰레드를 동시에 처리함으로써 프로세서를 효율적으로 이용할 수 있다."}
{"patent_id": "10-2017-0036256", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하에서는 첨부된 도면을 참조하여 다양한 실시 예를 보다 상세하게 설명한다. 본 명세서에 기재된 실시 예는 다양하게 변형될 수 있다. 특정한 실시 예가 도면에서 묘사되고 상세한 설명에서 자세하게 설명될 수 있다. 그 러나, 첨부된 도면에 개시된 특정한 실시 예는 다양한 실시 예를 쉽게 이해하도록 하기 위한 것일 뿐이다. 따라 서, 첨부된 도면에 개시된 특정 실시 예에 의해 기술적 사상이 제한되는 것은 아니며, 발명의 사상 및 기술 범 위에 포함되는 모든 균등물 또는 대체물을 포함하는 것으로 이해되어야 한다. 다만, 발명을 설명함에 있어서, 관련된 공지 기능 혹은 구성에 대한 구체적인 설명이 발명의 요지를 불필요하게 흐릴 수 있다고 판단되는 경우, 그에 대한 상세한 설명은 축약하거나 생략한다. 도 1은 일 실시 예에 따른 멀티 쓰레드 프로세서의 블록도이다. 도 1을 참조하면, 멀티 쓰레드 프로세서는 모드 레지스터, 컨트롤러 및 기능 유닛(functional unit)을 포함한다. 모드 레지스터는 하나의 기능 유닛에서 동시에 처리 가능한 쓰레드(thread)의 크기 및 개수에 따라 구분된 복수의 쓰레드 모드 중, 처리 대상 작업에 대응되는 쓰레드 모드 정보를 저장한다. 프로세서는 특정한 프로그램을 실행함으로써 특정한 프로그램에 대응되는 동작을 수행할 수 있다. 특정한 프로그램은 복수 개의 쓰레드로 구분될 수 있다. 쓰레드는 프로세서에서 실행되는 프로세서 내에서 실행되는 흐 름의 단위 또는 작업의 수행 단위를 의미할 수 있다. 쓰레드는 사용자의 설정에 의한 프로그램의 스케쥴링 또는 커널에 의한 프로그램의 스케쥴링을 통해 관리될 수 있다. 또한, 쓰레드는 프로세서에서 처리 가능한 크기로 구 분될 수 있다. 한편, 프로세서는 한 번에 하나의 쓰레드를 처리할 수 있고, 동시에 복수 개의 쓰레드를 처 리할 수 있다. 동시에 복수 개의 쓰레드를 처리하는 프로세서가 멀티 쓰레드 프로세서라고 할 수 있다. 본 명세서의 멀티 쓰레드 프로세서는 동시에 복수 개의 쓰레드를 처리할 수 있다. 또한, 처리되는 복수 개 의 쓰레드의 크기는 서로 다를 수 있다. 따라서, 멀티 쓰레드 프로세서는 동시에 처리할 수 있는 쓰레드의 크기 및 개수에 따라 복수 개의 쓰레드 모드를 가질 수 있다. 복수 개의 쓰레드 모드는 미리 설정될 수 있고, 모드 레지스터는 현재 처리 대상 작업에 대응되는 쓰레드 모드 정보를 수신할 수 있다. 모드 레지스터 는 현재 처리 대상 작업에 대응되는 쓰레드 모드 정보를 저장할 수 있다. 다시 말해서, 모드 레지스터는 미리 정의해 둔 서브스케일 멀티스레딩(subscale multithreading) 구조에 기초하여 서브스케일 쓰레드 구성을 정의하는 정보를 저장할 수 있다. 예를 들어, 현재 처리 대상 작업이 4개의 쓰레드 구성을 포함하는 경우, 모드 레지스터는 2비트를 이용하여 4개의 쓰레드를 기능 유닛에 할당하도록 컨트롤러에 쓰레드 모드 정보를 제공할 수 있다. 따라서, 모드 레지스터는 현재 서브스케일 SIMD(Single Instruction Multiple Data) 쓰레드의 구성 조합을 나타낼 수 있다. 컨트롤러는 모드 레지스터에 저장된 쓰레드 모드 정보에 기초하여 처리 대상 작업에 포함된 적어도 하나의 쓰레드를 적어도 하나의 기능 유닛으로 할당한다. 컨트롤러는 모드 레지스터로부터 현재 처리 대상 작업에 대응되는 쓰레드 정보를 수신하여 대응되는 어드레스를 생성하고 활성화시키며, 생성된 어드 레스에 대응되는 데이터를 레지스터(미도시)로 리딩(reading)하고, 리딩된 데이터를 기능 유닛으로 전달하 도록 제어할 수 있다. 구체적인 과정은 후술한다. 기능 유닛은 쓰레드를 처리한다. 기능 유닛은 멀티 쓰레드 프로세서에 복수 개 포함될 수 있다. 기능 유닛은 스칼라 기능 유닛(scalar functional unit)과 벡터 기능 유닛(vector function unit)을 포함 할 수 있다. 예를 들어, 스칼라 기능 유닛은 플로우제어(flow control), 조건의 판단, 어드레스 계산, 벡터 관 련 계산을 수행할 수 있다. 그리고, 벡터 기능 유닛은 오퍼랜드(operand)를 수신하여 산술 또는 로직 연산을 수 행할 수 있다. 일반적으로 스칼라 기능 유닛에서 처리되는 데이터의 크기는 벡터 기능 유닛에서 처리되는 데이 터의 크기보다 작기 때문에 스칼라 기능 유닛의 크기(또는, 처리 가능한 데이터의 최대 크기)는 벡터 기능 유닛 의 크기(또는, 처리 가능한 데이터의 최대 크기)보다 작을 수 있다. 일 실시 예로서, 벡터 기능 유닛이 최대 1024 비트의 데이터를 처리할 수 있다면, 스칼라 기능 유닛은 256 비트의 데이터를 처리할 수 있다. 그러나, 상 술한 크기는 일 실시 예이며, 스칼라 기능 유닛 및 벡터 기능 유닛의 크기는 다양하게 구현될 수 있다. 본 명세 서의 실시 예들에서 언급하는 기능 유닛은 벡터 기능 유닛을 의미할 수 있다. 한편, 복수의 쓰레드 모드는 하나의 기능 유닛에 서로 다른 크기의 복수의 쓰레드를 할당하는 모드를 포함 할 수 있다. 예를 들어, 복수의 쓰레드 모드는 하나의 기능 유닛의 최대 처리 용량의 1/(2n) 크기를 가지 는 쓰레드 및 최대 처리 용량의 1/(4n) 크기를 가지는 쓰레드를 하나의 기능 유닛에 할당하는 모드를 포함 할 수 있다. 또한, 복수의 쓰레드 모드는 하나의 기능 유닛에 하나의 쓰레드를 할당하는 모드, 하나의 기 능 유닛에 두 개의 쓰레드를 할당하는 모드 또는 하나의 기능 유닛에 네 개의 쓰레드를 할당하는 모 드를 포함할 수 있다. 하나의 기능 유닛에 다양한 크기의 쓰레드를 할당하는 구체적인 실시 예는 후술한다. 먼저, 도 2에서는 전반적인 멀티 쓰레드 프로세서에 대해 설명한다. 도 2는 일 실시 예에 따른 재구성 가능한 멀티 쓰레드 프로세서를 설명하는 도면이다. 도 2를 참조하면, 멀티 쓰레드 프로세서는 기능 유닛, 레지스터 파일 및 구성 메모리 (configuration memory)를 더 포함할 수 있다. 멀티 쓰레드 프로세서는 재구성 가능 아키텍처 (reconfigurable architecture)일 수 있다. 재구성 가능 아키텍처는 수행하는 작업에 따라 CGA(Coarse-Grained Array) 모드 또는 VLIW(Very Long Instrcution Word) 모드로 동작될 수 있다. CGA 모드는 루프 가속이 필요한 연산을 수행할 수 있고, VLIW 모드는 일반적인 연산을 수행할 수 있다. 멀티 쓰레드 프로세서는 프로그램 의 스케쥴링에 따라 CGA 모드 및 VLIW 모드 간 전환을 하면서 프로그램을 실행할 수 있다. 기능 유닛은 멀티 쓰레드 프로세서에 복수 개 포함될 수 있다. 기능 유닛은 산술 연산 및 논리 연산을 수행할 수 있다. 그리고, 각각의 기능 유닛은 쓰레드를 병렬적으로 처리할 수 있다. 기능 유닛 은 다수의 입출력을 통해 서로 연결될 수 있고, 기능 유닛의 연결 관계는 구성 메모리에 저장된 구성 정보에 따라 변할 수 있다. 레지스터 파일은 기능 유닛의 연산에 필요한 데이터를 메모리(미도시)로부터 리딩할 수 있다. 그리고, 레지스터 파일은 리딩된 데이터를 기능 유닛으로 전달할 수 있다. 또한, 레지스터 파일(15 0)은 기능 유닛에서 수행된 연산 결과 데이터를 저장할 수도 있다. 레지스터 파일은 복수 개 존재할 수 있다. 구성 메모리는 멀티 쓰레드 프로세서의 동작을 제어하기 위한 구성 정보를 저장할 수 있다. 예를 들 어, 구성 메모리는 기능 유닛에서 수행될 연산, 기능 유닛 간의 연결 관계 등의 정보를 포함할 수 있다. 한편, 일반적인 VLIW 구조나 CGA 구조를 이용하는 프로세서는 많은 독립적인 기능 유닛을 포함하고 있고, Wide SIMD의 지원을 위해 기능 유닛들의 병렬화는 특정 응용 프로그램에서 면적 오버헤드로 작용될 수 있다. 본 명세 서에서는 Wide SIMD 구조의 프로세서가 멀티쓰레딩을 지원함으로써 다양한 벡터화된 응용 프로그램을 수행할 수 있는 프로세서 구조를 제안한다.도 3은 일 실시 예에 따른 멀티 쓰레드 프로세서의 컨트롤러를 설명하는 도면이다. 도 3을 참조하면, 멀티 쓰레드 프로세서의 컨트롤러는 서브스케일 프런트-엔드 컨트롤러(Subscale Front- end Controller), 서브스케일 벡터 레지스터 파일 컨트롤러(Subscale Vector Register File Controller), 서브스케일 기능 유닛 컨트롤러(Subscale Functional Unit Controller) 및 서브스케일 구성 메모리 디코더 컨트롤러(Subscale Configuration Memory Controller)를 포함할 수 있다. 서브스케일 프런트-엔드 컨트롤러(Subscale Front-end Controller)는 서브스케일 구성 정보로부터 동시에 수행할 페치 유닛(fetch unit)을 결정하여 제어할 수 있다. 예를 들어, 서브스케일 프런트-엔드 컨트롤러 는 싱글 쓰레드 모드인 경우 하나의 페치 유닛만을 활성화시킬 수 있고, 멀티 쓰레드 모드인 경우 해당 쓰레드 의 페치 유닛을 활성화시킬 수 있다. 즉, 서브스케일 프런트-엔드 컨트롤러는 동시에 수행할 쓰레드의 수 에 따라 페치 유닛과 디코더를 결정하고 제어할 수 있다. 서브스케일 벡터 레지스터 파일 컨트롤러(Subscale Vector Register File Controller)는 레지스터 파일의 어드레스 정보를 쓰레드의 수에 따라 제어하고, 각 쓰레드 파티션에 맞는 어드레스와 라이트 활성화(write enable)를 제어할 수 있다. 싱글 쓰레드인 경우 레지스터 파일을 하나로 제어하고, 멀티 쓰레드인 경우 작업 대 상 쓰레드의 개수에 따라 레지스터 파일을 부분으로 나누어 제어할 수 있다. 서브스케일 기능 유닛 컨트롤러(Subscale Functional Unit Controller)는 먹스(Multiplexer: MUX)와 그 제어 신호를 세분화하여 쓰레드에 따라 입력 오퍼랜드를 제어할 수 있다. 또한, 서브스케일 기능 유닛 컨트롤러 는 기능 유닛의 유효성 여부(valid) 및 데이터 환원(write-back)을 쓰레드에 따라 제어할 수 있다. 서브스케일 구성 메모리 디코더 컨트롤러(Subscale Configuration Memory Controller)는 서브스케일 프런 트-엔드 컨트롤러와 동일한 방식으로 동작할 수 있다. 서브스케일 구성 메모리 디코더 컨트롤러는 VLIW와 CGA 모드 간에 번갈아 가며 재구성이 가능한 멀티 쓰레드 프로세서에서 각각의 모드에 따라 별도의 디코딩 로직을 가지고 쓰레드의 구성에 따라 구성 메모리 및 디코더를 제어할 수 있다. 즉, 서브스케일 구성 메 모리 디코더 컨트롤러는 VLIW 제어 정보 또는 CGA 제어 정보를 현재 작업 대상 쓰레드에 맞게 할당함으로 써 구성부를 제어할 수 있다. 각각의 서브스케일 컨트롤러(121, 122, 123, 124)는 하나의 컨트롤러 내부에 하드웨어 모듈 또는 소프트웨어 모 듈로 구현될 수 있다. 또는, 각각의 서브스케일 컨트롤러(121, 122, 123, 124)는 대응되는 구성 유닛을 제어하 기 위해 각각 독립적으로 구현될 수도 있다. 도 3에서 적어도 하나의 쓰레드를 기능 유닛에 할당하는 과정을 제어하는 컨트롤러를 설명하였다. 멀티 쓰 레드 프로세서는 다른 구성부 또는 기능을 제어하는 컨트롤러를 더 포함할 수도 있다. 도 4는 다른 실시 예에 따른 멀티 쓰레드 프로세서의 블록도이다. 도 4에서는 최대 4개의 쓰레드를 동시에 처리할 수 있는 프로세서의 실시 예가 도시되어 있다. 도 4에 도 시된 프로세서는 일 실시 예이며, 다양한 개수를 처리할 수 있는 프로세서가 구현될 수 있다. 도 4를 참조하면, 멀티 쓰레드 프로세서는 모드 레지스터, 서브스케일 프런트-엔드 컨트롤러, 서브스케일 벡터 레지스터 파일 컨트롤러 , 서브스케일 기능 유닛 컨트롤러, 서브스케일 구성 메모리 디코더 컨트롤러, 복수의 기능 유닛, 스칼라 레지스터 파일(Scalar Register File), 벡터 레지 스터 파일(Vertor Register File), 인스트럭션 캐쉬(Instruction Cache), 프로그램 카운터(Program Counter), 페치 유닛(Fetch Unit), 인스트럭션 큐(Instrcution Queue), 디코더, 구성 메 모리 디코더를 포함할 수 있다. 일 실시 예로서, 도 4에 도시된 멀티 쓰레드 프로세서의 블록도를 기초로 네 개의 쓰레드를 동시에 처리하 는 과정을 설명한다. 모드 레지스터는 하나의 기능 유닛에서 동시에 처리 가능한 쓰레드(thread)의 크기 및 개수에 따라 구분된 복수의 쓰레드 모드 중, 처리 대상 작업에 대응되는 쓰레드 모드 정보를 저장한다. 도 4의 실시 예에서 모드 레 지스터은 네 개의 쓰레드를 기능 유닛에 할당하는 모드에 대한 정보가 저장될 수 있다. 그리고, 모드 레지 스터는 네 개의 쓰레드가 기능 유닛에 할당되어 처리될 수 있도록 각 컨트롤러(121, 122, 123, 124) 등에 모드 정보를 전송할 수 있다. 인스트럭션 캐쉬은 현재 대상 작업의 쓰레드의 인스트럭션을 전달받고 저장할 수 있다. 프로그램 카운터 는 프로세서가 다음 실행할 인스트럭션의 위치를 기억하는 레지스터의 한 종류로서, 현재 인스트럭션 이 실행될 때마다 레지스터에 1이 자동적으로 더해지면서 다음에 실행할 인스트럭션의 위치를 지시할 수 있다. 페치 유닛은 프로그램 카운터에 기초하여 인스트럭션 캐쉬로부터 네 개의 쓰레드와 관련된 동시에 처 리 가능한 인스트럭션을 페치하여 인스트럭션 큐로 전달할 수 있다. 도 4에 도시된 프로세서는 네 개의 쓰레드를 동시에 처리할 수 있는 아키텍쳐를 포함하기 때문에 네 개의 인스트럭션 큐를 포함할 수 있다. 네 개의 인스트럭션 큐는 각각 네 개의 쓰레드와 관련된 네 개의 인스트럭션을 페치 유닛으로부터 전달받을 수 있다. 네 개의 인스트럭션은 하나의 기능 유닛에서 동시에 처리할 수 있는 동일한 인스트럭션일 수 있다. 예를 들어, 일반적으로 프로세서는 한 번에 하나의 인스트럭션을 순차적으로 처리할 수 있다. 그러나, SIMD(Single Instruction Multiple Data) 구조의 프로세서는 한 번에 복 수의 동일한 인스트럭션을 모아 하나의 인스트럭션으로 여러 개의 데이터를 동시에 처리할 수 있다. 구체적인 예로서, 이미지 처리용 프로세서가 1픽셀, 2픽셀, 3픽셀, 4픽셀에 대응되는 각각의 쓰레드에 동일한 add 인스트 럭션을 처리하는 경우, 하나의 기능 유닛에 1픽셀, 2픽셀, 3픽셀 4픽셀에 대응되는 쓰레드와 관련된 add 인스트 럭션을 위한 데이터를 전달하고, 하나의 기능 유닛은 add 인스트럭션을 동시에 처리함으로써 하나의 add 인스트 럭션을 처리하는 사이클 동안 네 개의 데이터를 처리할 수 있다. 멀티 쓰레드 모드에서는 최대 네 개의 인스트럭션이 디코더에 의해 디코딩되고, 기능 유닛으로 전달될 수 있다. 서브스케일 프런트 엔드 컨트롤러는 복수의 쓰레드와 관련된 동시에 처리 가능한 복수의 인스트 럭션을 페치하여 기능 유닛으로 전달하도록 각 구성부를 제어할 수 있다. 만일, 네 개의 인스트럭션이 스칼라 연산과 관련된 경우, 각각 해당 스칼라 레지스터 파일을 접근하며, 스칼라 레지스터 파일은 연산을 위한 데이터가 저장된 어드레스를 생성 또는 활성화하여 연산에 필요한 데이터를 스칼라 레지스터 파일로 리딩(reading)할 수 있다. 예를 들어, 스칼라 연산은 플로우제어(flow control), 조건의 판단, 어드레스 연산, 벡터 관련 연산 등을 포함할 수 있다. 기능 유닛 중 스칼라 기능 유닛(Scalar Functional Unit)은 스칼라 레지스터 파일로부터 데이터를 전 달받고, 스칼라 연산을 수행할 수 있다. 도 4에 도시된 프로세서는 네 개의 쓰레드를 동시에 처리할 수 있으므 로 네 개의 스칼라 기능 유닛을 포함할 수 있다. 또한, 일반적으로 스칼라 연산은 벡터 연산에 비해 연산에 필 요한 데이터의 크기가 작기 때문에 벡터 기능 유닛에 비해 작은 크기로 구현될 수 있다. 예를 들어, 벡터 기능 유닛이 1024 비트의 데이터를 처리할 수 있는 크기로 구현되어 4개의 sub-scale thread를 처리하는 경우, 스칼 라 기능 유닛은 4개의 32 비트의 데이터를 처리할 수 있는 크기로 구현될 수 있다. 위의 설명과 유사하게, 네 개의 인스트럭션이 벡터 연산과 관련된 경우, 벡터 레지스터 파일은 연산을 위 한 데이터가 저장된 어드레스를 생성 또는 활성화하여 연산에 필요한 데이터를 벡터 레지스터 파일로 리딩 (reading)할 수 있다. 예를 들어, 벡터 연산은 스칼라 연산을 제외한 일반적인 산술 연산 또는 논리 연산을 포 함할 수 있다. 서브스케일 벡터 레지스터 파일 컨트롤러는 모드 레지스터로부터 현재 처리 작업과 관 련된 쓰레드 모드에 대한 정보를 수신하고, 어드레스를 생성 또는 활성화하여 연산에 필요한 데이터를 벡터 레 지스터 파일로 리딩(reading)할 수 있도록 각 구성부를 제어할 수 있다. 기능 유닛 중 벡터 기능 유닛(Vector Functional Unit)은 벡터 레지스터 파일로부터 데이터를 전달받 고, 벡터 연산을 수행할 수 있다. 일 실시 예로서, 하나의 프로세서는 열두 개의 벡터 기능 유닛을 포함할 수 있다. 그리고, 도 4에 도시된 프로세서는 네 개의 쓰레드를 동시에 처리할 수 있으므로 하나의 벡터 기능 유닛 은 네 개의 영역으로 분할될 것처럼 제어될 수 있다. 하나의 벡터 기능 유닛은 실제로 복수의 영역으로 분리되 는 것이 아니라 어드레스 인터페이스, 데이터 인터페이스 또는 먹스(MUX) 등을 이용하여 네 개의 영역으로 분리 된 것과 같이 제어될 수 있다. 예를 들어, 벡터 기능 유닛이 1024 비트의 데이터를 처리할 수 있는 크기로 구현 되고, 네 개의 쓰레드와 관련된 인스트럭션을 처리하는 경우, 하나의 벡터 기능 유닛은 네 개의 서로 다른 256 비트의 데이터를 동시에 처리할 수 있다. 상술한 예는 일 실시 예이며, 벡터 기능 유닛 및 스칼라 기능 유닛은 다양한 크기로 구현될 수 있다. 서브스케일 벡터 기능 유닛 컨트롤러는 벡터 레지스터 파일로부터 벡 터 기능 유닛으로 연산에 필요한 데이터를 전달하도록 각 구성부를 제어할 수 있다. 한편, 상술한 바와 같이, 멀티 쓰레드 프롯세서는 처리하는 프로그램 코드의 특성에 따라 VLIW 모드 또는 CGA 모드를 번갈아 가며 설정될 수 있다. 구성 메모리는 VLIW 모드 또는 CGA 모드에 필요한 구성 정보를 저장할 수 있다. 그리고, 설정되는 모드에 따라 필요한 구성 정보가 구성 메모리 디코더를 통해 디코딩되 어 기능 유닛으로 전달될 수 있다. 기능 유닛 내의 각각의 기능 유닛들은 전달된 구성 정보에 기초하 여 연결 관계 등을 재구성할 수 있다. 서브스케일 구성 메모리 디코더 컨트롤러는 VLIW 모드 및 CGA 모드에 따라 구성 메모리로부터 구성 정보를 리딩(reading)하고, 구성 메모리 디코더를 통해 디코딩하여 기능 유닛을 재구성할 수 있도록 각 구성부를 제어할 수 있다. 지금까지 하나의 기능 유닛에서 네 개의 쓰레드를 처리하는 실시 예를 기초로 멀티 쓰레드 프로세서의 블 록도를 설명하였다. 그러나, 본 명세서의 멀티 쓰레드 프로세서는 서로 다른 크기의 복수의 쓰레드를 하나 의 기능 유닛에서 처리할 수도 있다. 일 실시 예로서, 하나의 기능 유닛은 최대 1024 비트 크기의 데이터를 처리할 수 있다. 그리고, 하나의 기능 유 닛은 한 개의 512 비트 크기의 데이터와 두 개의 256 비트 크기의 데이터를 동시에 처리할 수 있다. 즉, 하나의 기능 유닛의 처리 공간은 512 비트 크기의 데이터와 두 개의 256 비트 크기의 데이터를 동시에 처리함으로써 최 대한 효율적으로 이용될 수 있다. 하나의 기능 유닛의 최대 크기 또는 하나의 기능 유닛이 처리할 수 있는 데이터의 최대 크기는 다양하게 설정될 수 있다. 예를 들어, 하나의 기능 유닛의 최대 크기는 256 비트, 512 비트, 1024 비트, 2048 비트, 4096 비트 등과 같이 다양한 크기로 설정될 수 있다. 또한, 하나의 기능 유닛의 최대 크기에 따라 하나의 기능 유닛에서 처리할 수 있는 데이터의 크기 및 개수도 가변될 수 있다. 예를 들어, 하나의 기능 유닛이 네 개의 쓰레드를 동 시에 처리 가능하고 최대 크기가 2048 비트인 경우, 하나의 기능 유닛은 한 개의 1024 비트 크기의 데이터와 두 개의 512 비트 크기의 데이터를 동시에 처리할 수 있다. 또한, 하나의 기능 유닛은 한 개의 2048 비트 크기의 데이터만을 처리할 수 있고, 두 개의 1024 비트 크기의 데이터를 동시에 처리할 수도 있으며, 네 개의 512 비트 크기의 데이터를 동시에 처리할 수도 있다. 또는, 하나의 기능 유닛이 여덟 개의 쓰레드를 동시에 처리 가능하고 최대 크기가 2048 비트인 경우, 하나의 기 능 유닛은 한 개의 2048 비트 크기의 데이터만을 처리하거나 두 개의 1024 비트 크기의 데이터를 동시에 처리하 거나, 네 개의 512 비트 크기의 데이터를 동시에 처리하거나, 여덟 개의 256 비트 크기의 데이터를 동시에 처리 하거나, 한 개의 1024 비트 크기의 데이터와 두 개의 512 비트 크기의 데이터를 동시에 처리하거나, 한 개의 1024 비트 크기의 데이터와 네 개의 256 비트 크기의 데이터를 동시에 처리하거나, 한 개의 512 비트 크기의 데 이터와 여섯 개의 256 비트 크기의 데이터를 동시에 처리하거나, 두 개의 512 비트 크기의 데이터와 네 개의 256 비트 크기의 데이터를 동시에 처리하거나, 세 개의 512 비트 크기의 데이터와 두 개의 256 비트 크기의 데 이터를 동시에 처리할 수도 있다. 그리고, 상술한 쓰레드 처리 방식은 쓰레드 모드라고 부를 수 있다. 즉, 쓰레 드 모드는 복수 개가 존재할 수 있고, 하나의 기능 유닛에 서로 다른 크기의 복수의 쓰레드를 할당하여 처리하 는 모드를 포함할 수 있다. 그리고, 쓰레드 모드는 하나의 기능 유닛의 최대 처리 용량의 1, 1/2, 1/4, 1/8, …, 1/(2n) ([최대처리 용량×1/(2n)] > [스칼라 데이터 패스 크기(scalar data path size)]) 크기의 쓰레드들 의 조합으로 구성되며 각 쓰레드의 데이터 폭(data width) 총합이 기능 유닛의 최대 용량보다 작도록 하나의 기 능 유닛에 할당하여 처리하는 모드를 포함할 수 있다. 아래에서는 각각의 쓰레드 모드에서 각 컨트롤러의 제어 과정을 설명한다. 도 5는 일 실시 예에 따른 서브스케일 프런트-엔드 컨트롤러의 동작을 설명하는 도면이다. 도 5를 참조하면, 모드 레지스터, 서브스케일 프런트 엔드 컨트롤러 및 복수의 인스트럭션 큐가 도시 되어 있다. 모드 레지스터는 하나의 기능 유닛에서 동시에 처리 가능한 쓰레드의 크기 및 개수에 따라 구분된 복수의 쓰레드 모드 중 처리 대상 작업에 대응되는 쓰레드 모드 정보를 저장할 수 있다. 일 실시 예로서, 멀티 쓰레드 프로세서가 512 비트 아키텍처이고 네 개의 쓰레드를 동시에 처리할 수 있는 경우, 네 개의 쓰레드 모드가 존재 할 수 있다. 예를 들어, 제1 모드는 하나의 512 비트 쓰레드를 처리하는 모드이고, 제2 모드는 두 개의 256 비 트 쓰레드를 처리하는 모드이며, 제3 모드는 두 개의 128 비트 쓰레드 및 한 개의 256 비트 쓰레드를 처리하는 모드이고, 제4 모드는 네 개의 128 비트 쓰레드를 처리하는 모드일 수 있다. 즉, 복수의 쓰레드 모드는 하나의 기능 유닛의 최대 처리 용량에 대응되는 하나의 쓰레드를 하나의 기능 유닛에 할당하는 제1 모드, 최대 처리 용량의 1/2 크기를 가지는 두 개의 쓰레드를 하나의 기능 유닛에 할당하는 제2 모드, 최대 처리 용량의 1/2 크기를 가지는 쓰레드 및 최대 처리 용량의 1/4 크기를 가지는 두 개의 쓰레드를 하나의 기능 유닛에 할당하는 제3 모드, 최대 처리 용량의 1/4 크기를 가지는 네 개의 쓰레드를 하나의 기능 유 닛에 할당하는 제4 모드를 포함할 수 있다. 모드 레지스터는 현재 처리 대상 작업에 대응하는 쓰레드 모드 정보를 컨트롤러로 전달할 수 있다. 예를 들어, 네 개의 쓰레드 모드가 존재하는 경우, 모드 레지스터는 두 개의 제어 비트를 이용하여 모드 정보를컨트롤러에게 전달할 수 있다. 일 실시 예로서, 두 개의 제어 비트가 모두 0인 경우 제1 모드, 제1 제어 비트는 1이고 제2 제어 비트는 0인 경우 제2 모드, 제1 제어 비트는 0이고 제2 제어 비트는 1인 경우 제3 모드, 두 개 의 제어 비트가 모두 1인 경우 제4 모드를 의미할 수 있다. 모드 레지스터는 쓰레드 모드 정보를 서브스케일 프런트 엔드 컨트롤러로 전달 수 있다. 상술한 바와 같이, 서브스케일 프런트 엔드 컨트롤러는 페치 유닛을 활성화시키고, 쓰레드의 수에 따라 인스트럭션을 페치할 수 있다. 예를 들어, 하나의 쓰레드를 처리하는 제1 모드인 경우, 서브스케일 프런트 엔드 컨트롤러 는 하나의 인스트럭션을 하나의 인스트럭션 큐에 페치할 수 있다. 두 개의 쓰레드를 처리하는 제2 모드인 경우, 서브스케일 프런트 엔드 컨트롤러는 두 개의 인스트럭션을 두 개의 인스트럭션 큐에 페치할 수 있다. 세 개의 쓰레드를 처리하는 제3 모드인 경우, 서브스케일 프런트 엔드 컨트롤러는 세 개의 인스트럭 션을 세 개의 인스트럭션 큐에 페치할 수 있고, 네 개의 쓰레드를 처리하는 제4 모드인 경우, 서브스케일 프런 트 엔드 컨트롤러는 네 개의 인스트럭션을 네 개의 인스트럭션 큐에 페치할 수 있다. 복수의 인스트럭션은 한 번에 처리 가능한 동일한 인스트럭션일 수 있다. 페치된 인스트럭션은 디코딩되어 기능 유닛으로 전달될 수 있다. 도 6은 일 실시 예에 따른 서브스케일 벡터 레지스터 파일 컨트롤러의 동작을 설명하는 도면이다. 도 6(a)를 참조하면, 모드 레지스터 및 서브스케일 벡터 레지스터 파일 컨트롤러가 도시되어 있다. 모드 레지스터는 서브스케일 벡터 레지스터 파일 컨트롤러로 쓰레드 모드 정보를 전달할 수 있다. 상 술한 바와 같이, 서브스케일 벡터 레지스터 파일 컨트롤러는 레지스터 파일의 어드레스 정보를 쓰레드의 수에 따라 제어하고, 각 쓰레드 파티션에 맞는 어드레스와 라이트 활성화(write enable)를 제어할 수 있다. 도 6(b)를 참조하면, 벡터 레지스터 파일 및 데이터 인터페이스가 도시되어 있다. 예를 들어, 멀티 쓰레드 프로세서가 512 비트 아키텍처이고 네 개의 쓰레드를 동시에 처리할 수 있는 경우, 네 개의 쓰레드 모드가 존재 할 수 있다. 벡터 레지스터 파일의 데이터 인터페이스도 512 비트일 수 있다. 서브스케일 벡터 레지스터 파일 컨트롤러는 쓰레드 모드에 대응되는 어드레스를 생성 또는 활성화(enable)할 수 있다. 예를 들어, 하 나의 512 비트 쓰레드를 처리하는 제1 모드의 경우, 서브스케일 벡터 레지스터 파일 컨트롤러는 하나의 512 비트 데이터를 리딩(reading)하기 위한 하나의 어드레스를 생성 또는 활성화(enable)할 수 있다. 두 개의 256 비트 쓰레드를 처리하는 제2 모드의 경우, 서브스케일 벡터 레지스터 파일 컨트롤러는 두 개의 256 비 트 데이터를 리딩하기 위한 두 개의 어드레스를 생성 또는 활성화(enable)할 수 있다. 두 개의 128 비트 쓰레드 및 한 개의 256 비트 쓰레드를 처리하는 제3 모드의 경우, 서브스케일 벡터 레지스터 파일 컨트롤러는 두 개의 128 비트 데이터 및 한 개의 256 데이터를 리딩하기 위한 세 개의 어드레스를 생성(또는, 할당) 또는 활성 화(enable)할 수 있다. 네 개의 128 비트 쓰레드를 처리하는 제4 모드의 경우, 서브스케일 벡터 레지스터 파일 컨트롤러는 네 개의 128 비트 데이터를 리딩하기 위한 네 개의 어드레스를 생성 또는 활성화(enable)할 수 있다. 즉, 도 6(b)에 도시된 바와 같이, 서브스케일 벡터 레지스터 파일 컨트롤러는 제1 모드에서 네 개의 128 비트(#0, #1, #2, #3)에 대해 동일한 어드레스를 생성하여 동일한 어드레스의 512 비트 데이터를 벡터 레지스터 파일로 리딩하도록 제어할 수 있다. 그리고, 서브스케일 벡터 레지스터 파일 컨트롤러는 제2 모드에 서 두 개의 128 비트(#0, #1)에 대해 동일한 어드레스를 생성하고, 나머지 두 개의 128 비트(#2, #3)에 대해 동 일한 어드레스를 생성함으로써 두 개의 서로 다른 256 비트 데이터를 벡터 레지스터 파일로 리딩하도록 제 어할 수 있다. 또는, 서브스케일 벡터 레지스터 파일 컨트롤러는 제3 모드에서 두 개의 128 비트(#0, #1) 에는 서로 다른 어드레스를 생성하고, 나머지 두 개의 128 비트(#2, #3)에는 앞의 두 개의 128 비트(#0, #1)에 생성된 어드레스와 다른 동일한 어드레스를 생성함으로써 두 개의 서로 다른 128 비트 데이터와 하나의 256 비 트 데이터를 벡터 레지스터 파일로 리딩하도록 제어할 수 있다. 유사하게, 서브스케일 벡터 레지스터 파일 컨트롤러는 제4 모드에서 네 개의 128 비트(#0, #1, #2, #3)에 서로 다른 어드레스를 생성하여 네 개의 서 로 다른 128 비트 데이터를 벡터 레지스터 파일에 리딩◎록 제어할 수 있다. 도 7은 일 실시 예에 따른 서브스케일 기능 유닛 컨트롤러의 동작을 설명하는 도면이다. 도 7(a)를 참조하면, 모드 레지스터 및 서브스케일 기능 유닛 컨트롤러가 도시되어 있다. 모드 레지 스터는 서브스케일 기능 유닛 컨트롤러로 쓰레드 모드 정보를 전달할 수 있다. 상술한 바와 같이, 서 브스케일 기능 유닛 컨트롤러는 먹스(MUX)를 이용하여 쓰레드에 따라 입력 오퍼랜드를 제어할 수 있다. 도 7(b)를 참조하면, 하나의 기능 유닛 및 먹스(MUX)가 도시되어 있다. 예를 들어, 멀티 쓰레드 프로세서 가 512 비트 아키텍처이고 네 개의 쓰레드를 동시에 처리할 수 있는 경우, 네 개의 쓰레드 모드가 존재할 수 있 다. 기능 유닛은 인스트럭션에 대응하는 복수의 데이터를 수신할 수 있다. 예를 들어, 두 개의 thread로 동작하는 경우, 기능 유닛은 두 개의 서로 다른 데이터를 입력받을 수 있다. 입력 데이터를 수신하는 데이 터 인터페이스에는 복수의 thread를 처리하기 위해 복수의 먹스(MUX) 제어신호를 사용하도록 설계된다. 일 실시 예로서, 도 7(b)에 도시된 바와 같이, 기능 유닛은 제2 소스(src2)를 통해 데이터를 입력받을 수 있다. 그 리고, 네 개의 쓰레드 모드가 존재하므로 각 소스에는 네 개의 먹스(MUX)로 분할되어 동작할 수 있고, 각 먹스 (MUX)로 입력되는 각각의 데이터 라인은 128 비트일 수 있다. 제1 소스와 제2 소스도 마찬가지로 설계된다. 예를 들어, 하나의 512 비트 쓰레드를 처리하는 제1 모드의 경우, 서브스케일 기능 유닛 컨트롤러는 기능 유닛이 하나의 512 비트 데이터를 입력받을 수 있도록 네 개의 먹스를 동일하게 제어할 수 있다. 따라서, 512 비트 데이터는 네 개의 먹스를 통해 128 비트씩 기능 유닛으로 입력될 수 있다. 두 개의 256 비트 쓰 레드를 처리하는 제2 모드의 경우, 서브스케일 기능 유닛 컨트롤러는 기능 유닛이 두 개의 256 비트 데이터를 입력받을 수 있도록 두 개의 먹스(#0, #1)를 동일하게 제어하고, 또 다른 두 개의 먹스(#2, #3)를 동 일하게 제어하지만 이전 두 개의 먹스(#0, #1)와는 다르게 제어할 수 있다. 따라서, 두 개의 256 비트 데이터는 각각 두 개의 먹스를 통해 128비트씩 기능 유닛으로 입력될 수 있다. 두 개의 128 비트 쓰레드 및 한 개의 256 비트 쓰레드를 처리하는 제3 모드의 경우, 서브스케일 기능 유닛 컨트롤러는 두 개의 먹스(#0, #1)는 각각 다르게 제어하고, 나머지 두 개의 먹스(#2, #3)를 동일하게 제어하지만 이전 두 개의 먹스(#0, #1)와는 다 르게 제어할 수 있다. 따라서, 두 개의 128 비트 데이터 및 한 개의 256 비트 데이터는 먹스를 통해 기능 유닛 으로 입력될 수 있다. 네 개의 128 비트 쓰레드를 처리하는 제4 모드의 경우, 서브스케일 기능 유닛 컨트 롤러는 네 개의 먹스(#0, #1, #2, #3)를 각각 다르게 제어할 수 있다. 따라서, 네 개의 128 비트 데이터는 각각의 먹스를 통해 기능 유닛으로 입력될 수 있다. 도 8은 일 실시 예에 따른 서브스케일 구성 메모리 디코더 컨트롤러의 동작을 설명하는 도면이다. 도 8을 참조하면, 모드 레지스터 및 서브스케일 구성 메모리 디코더 컨트롤러가 도시되어 있다. 모드 레지스터는 서브스케일 구성 메모리 디코더 컨트롤러로 쓰레드 모드 정보를 전달할 수 있다. 상술한 바와 같이, 서브스케일 구성 메모리 디코더 컨트롤러는 VLIW 제어 정보 또는 CGA 제어 정보를 현재 작업 대상 쓰레드에 맞게 할당함으로써 구성부를 제어할 수 있다. 서브스케일 구성 메모리 디코더 컨트롤러는 서브스케일 프런트-엔드 컨트롤러와 동일한 방식으로 동작할 수 있다. 예를 들어, 하나의 쓰레드를 처리하는 제1 모드인 경우, 서브스케일 구성 메모리 디코더 컨트롤러는 한 개 의 구성 메모리 디코더를 활성화시킬 수 있다. 두 개의 쓰레드를 처리하는 제2 모드인 경우, 서브스케일 구성 메모리 디코더 컨트롤러는 두 개의 구성 메모리 디코더를 활성화시킬 수 있다. 그리고, 세 개의 쓰레드를 처리하는 제3 모드인 경우, 서브스케일 구성 메모리 디코더 컨트롤러는 세 개의 구성 메모리 디코더를 활 성화시킬 수 있다. 또한, 네 개의 쓰레드를 처리하는 제4 모드인 경우, 서브스케일 구성 메모리 디코더 컨트롤 러는 네 개의 구성 메모리 디코더를 활성화시킬 수 있다. 상술한 다양한 실시 예에 따라, 멀티 쓰레드 프로세서는 하나의 기능 유닛에 서로 다른 크기의 복수의 쓰레드를 할당하여 동시에 처리함으로써 유연하고 효율적으로 프로그램을 처리할 수 있다. 도 9는 일 실시 예에 따른 1024 비트의 아키텍처의 레지스터 파일 동작을 설명하는 도면이다. 도 9에는 네 개의 쓰레드를 동시에 처리할 수 있는 1024 비트 아키텍처의 레지스터 파일에 대한 쓰레드 모드가 도시되어 있다. 도 9(a)에는 1024 비트 레지스터 파일이 도시되어 있다. 즉, 하나의 기능 유닛은 하나의 1024 비트의 데이터 또 는 쓰레드를 처리할 수 있다. 도 9(b)에는 두 개의 512 비트 레지스터 파일이 도시되어 있다. 즉, 하나의 기능 유닛은 두 개의 512 비트의 데이터 또는 쓰레드를 동시에 처리할 수 있다. 도 9(c)에는 두 개의 256 비트 레지 스터 파일 및 한 개의 512 비트 레지스터 파일이 도시되어 있다. 즉, 하나의 기능 유닛은 두 개의 256 비트 데 이터 또는 쓰레드와 함께 한 개의 512 비트 데이터 또는 쓰레드를 동시에 처리할 수 있다. 도 9(d)에는 네 개의 256 비트 레지스터 파일이 도시되어 있다. 즉, 하나의 기능 유닛은 네 개의 256 비트 데이터 또는 쓰레드를 동 시에 처리할 수 있다. 다시 말하면, 복수의 쓰레드 모드는 하나의 기능 유닛의 최대 처리 용량에 대응되는 하나의 쓰레드를 하나의 기 능 유닛에 할당하는 제1 모드, 최대 처리 용량의 1/2 크기를 가지는 두 개의 쓰레드를 하나의 기능 유닛에 할당 하는 제2 모드, 최대 처리 용량의 1/2 크기를 가지는 쓰레드 및 최대 처리 용량의 1/4 크기를 가지는 두 개의쓰레드를 하나의 기능 유닛에 할당하는 제3 모드, 최대 처리 용량의 1/4 크기를 가지는 네 개의 쓰레드를 하나 의 기능 유닛에 할당하는 제4 모드를 포함할 수 있다. 지금까지 멀티 쓰레드 프로세서의 다양한 실시 예를 설명하였다. 아래에서는 멀티 쓰레드 프로세서의 제어 방법 을 설명한다. 도 10은 일 실시 예에 따른 멀티 쓰레드 프로세서 제어 방법의 흐름도이다. 도 10을 참조하면, 멀티 쓰레드 프로세서는 쓰레드(thread)를 처리하는 적어도 하나의 기능 유닛에서 동시에 처 리 가능한 쓰레드의 크기 및 개수에 따라 구분된 복수의 쓰레드 모드 중, 처리 대상 작업에 대응되는 쓰레드 모 드 정보를 저장한다(S1010). 복수의 쓰레드 모드는 하나의 기능 유닛에 서로 다른 크기의 복수의 쓰레드를 할당 하는 모드를 포함할 수 있다. 즉, 복수의 쓰레드 모드는 하나의 기능 유닛의 최대 처리 용량의 1, 1/2, 1/4, 1/8, …, 1/(2n) ([최대처리 용량×1/(2n)] > [스칼라 데이터 패스 크기(scalar data path size)]) 크기를 가 지는 쓰레드들의 조합으로 여러 개의 쓰레드를 하나의 기능 유닛에 할당할 수 있다. 일 실시 예로서, 복수의 쓰레드 모드는 하나의 기능 유닛의 최대 처리 용량에 대응되는 하나의 쓰레드를 하나의 기능 유닛에 할당하는 제1 모드, 최대 처리 용량의 1/2 크기를 가지는 두 개의 쓰레드를 하나의 기능 유닛에 할 당하는 제2 모드, 최대 처리 용량의 1/2 크기를 가지는 쓰레드 및 최대 처리 용량의 1/4 크기를 가지는 두 개의 쓰레드를 하나의 기능 유닛에 할당하는 제3 모드, 최대 처리 용량의 1/4 크기를 가지는 네 개의 쓰레드를 하나 의 기능 유닛에 할당하는 제4 모드를 포함할 수 있다. 멀티 쓰레드 프로세서는 저장된 쓰레드 모드 정보에 기초하여 처리 대상 작업에 포함된 적어도 하나의 쓰레드를 적어도 하나의 기능 유닛으로 할당한다(S1020). 한편, 멀티 쓰레드 프로세서는 처리 대상 작업에 대응되는 모드에 포함된 쓰레드 개수 만큼의 인스트럭션을 페 치(fetch)하고, 페치된 인스트럭션에 기초하여 기능 유닛에 할당된 쓰레드를 처리할 수 있다. 그리고, 멀티 쓰 레드 프로세서는 제1 모드에서 하나의 쓰레드에 대응되는 데이터를 리딩하기 위한 하나의 어드레스를 생성하고, 제2 모드에서 두 개의 쓰레드에 대응되는 데이터를 리딩하기 위한 두 개의 상이한 어드레스를 생성하며, 제3 모 드에서 세 개의 쓰레드에 대응되는 데이터를 각각 리딩하기 위한 세 개의 상이한 어드레스를 생성하고, 제4 모 드에서 네 개의 쓰레드에 대응되는 데이터를 각각 리딩하기 위한 네 개의 상이한 어드레스를 생성할 수 있다. 생성된 어드레스에 기초하여 리딩된 데이터는 하나의 기능 유닛으로 전달될 수 있다. 본 발명은 큰 폭의 SIMD 벡터 처리가 가능한 프로세서에서 내재적 병렬화의 한계가 있는 작은 폭의 SIMD 응용에 대해 여러 개의 쓰레드를 동시에 처리 가능하도록 지원해주는 프로세서 아키텍처 및 장치에 관한 것이다. 와이 드 SIMD를 지원하는 프로세서는 상대적으로 큰 데이터패스(datapath)를 가져야 한다. 따라서, 데이터패스는 전 체 프로세서 면적의 많은 부분을 차지하게 되고, 여러 개의 기능 유닛을 가지는 멀티 프로세서서에서는 더 큰 부분을 차지한다. 본 발명은 기능 유닛을 half size, quarter size 등의 더 적은 SIMD 폭으로 효율적으로 동작 시킬 수 있다. 한편, 본 명세서에서 기술한 멀티 쓰레드 프로세서는 디지털 신호처리 프로세서, 응용특화 명령어 셋 프로세서, 증강현실(Augmented Reality: AR) 프로세서, 가상현실(Virtual Reality: VR), 심층 신경망(Deep Neural Network: DNN) 프로세서, 그래픽 처리 장치 프로세서 등으로 사용될 수 있다. 즉, 멀티 쓰레드 프로세서 아키텍 처는 영상 처리, 비전처리, 화질처리, 그래픽 렌더링, 인지/인식, AR/VR, DNN의 분야에 응용될 수 있다. 예를 들어, 멀티 쓰레드 프로세서는 디지털 TV, 스마트 폰, 태블릿 PC, 디지털 카메라, 스마트 자동차, 인공 지능 (AI) 장치 등에 사용될 수 있다. 상술한 다양한 실시 예에 따른 프로세서 제어 방법은 프로그램으로 구현되어 비일시적 판독 가능 매체(non- transitory computer readable medium)에 저장되어 제공될 수 있다. 비일시적 판독 가능 매체란 레지스터, 캐 쉬, 메모리 등과 같이 짧은 순간 동안 데이터를 저장하는 매체가 아니라 반영구적으로 데이터를 저장하며, 기기 에 의해 판독(reading)이 가능한 매체를 의미한다. 구체적으로는, 상술한 다양한 어플리케이션 또는 프로그램들 은 CD, DVD, 하드 디스크, 블루레이 디스크, USB, 메모리카드, ROM 등과 같은 비일시적 판독 가능 매체에 저장 되어 제공될 수 있다. 또한, 이상에서는 본 발명의 바람직한 실시 예에 대하여 도시하고 설명하였지만, 본 발명은 상술한 특정의 실시"}
{"patent_id": "10-2017-0036256", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "예에 한정되지 아니하며, 청구범위에서 청구하는 본 발명의 요지를 벗어남이 없이 당해 발명이 속하는 기술분야 에서 통상의 지식을 가진 자에 의해 다양한 변형실시가 가능한 것은 물론이고, 이러한 변형실시들은 본 발명의기술적 사상이나 전망으로부터 개별적으로 이해되어져서는 안될 것이다."}
{"patent_id": "10-2017-0036256", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일 실시 예에 따른 멀티 쓰레드 프로세서의 블록도이다. 도 2는 일 실시 예에 따른 재구성 가능한 멀티 쓰레드 프로세서를 설명하는 도면이다. 도 3은 일 실시 예에 따른 멀티 쓰레드 프로세서의 컨트롤러를 설명하는 도면이다. 도 4는 다른 실시 예에 따른 멀티 쓰레드 프로세서의 블록도이다. 도 5는 일 실시 예에 따른 서브스케일 프런트-엔드 컨트롤러의 동작을 설명하는 도면이다. 도 6은 일 실시 예에 따른 서브스케일 벡터 레지스터 파일 컨트롤러의 동작을 설명하는 도면이다. 도 7은 일 실시 예에 따른 서브스케일 기능 유닛 컨트롤러의 동작을 설명하는 도면이다. 도 8은 일 실시 예에 따른 서브스케일 구성 메모리 디코더 컨트롤러의 동작을 설명하는 도면이다. 도 9는 일 실시 예에 따른 1024 비트의 아키텍처의 레지스터 파일 동작을 설명하는 도면이다. 도 10은 일 실시 예에 따른 멀티 쓰레드 프로세서 제어 방법의 흐름도이다."}
