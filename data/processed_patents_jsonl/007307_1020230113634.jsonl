{"patent_id": "10-2023-0113634", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0031758", "출원번호": "10-2023-0113634", "발명의 명칭": "스토리지 장치, 인증 장치, 및 인증 시스템", "출원인": "삼성전자주식회사", "발명자": "염윤호"}}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "디버깅 장치로부터 제1 공개키에 대응하는 제1 개인키에 기초하여 생성된 인증서, 상기 제1 공개키, 및 제2 공개키를 수신하고, 상기 제1 공개키를 인증하고, 상기 제1 공개키의 인증이 성공이면 상기 제2 공개키를 인증하고, 상기 제2 공개키의 인증이 성공이면 디버깅 이네이블 신호를 출력하는 인증 장치; 및상기 디버깅 이네이블 신호에 응답하여 상기 디버깅 장치로부터 디버깅 신호를 수신하고, 상기 디버깅 신호에기초하여 디버깅을 수행하는 프로세서를 포함하는 스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 제1 공개키는 상기 스토리지 장치의 마스터 공개키에 대응하는 키이고,상기 제2 공개키는 상기 마스터 공개키와 동일한 암호화 알고리즘을 사용하여 생성된 제품 공개키에 대응하는키인,스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 인증 장치는,상기 스토리지 장치의 마스터 공개키의 제1 해시값을 저장하고,상기 제1 공개키의 제2 해시값을 생성하고,상기 제1 해시값 및 상기 제2 해시값이 일치하면 상기 제1 공개키의 인증이 성공인 것으로 결정하는,스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 인증 장치는,상기 스토리지 장치의 제품 정보를 저장하고,상기 제1 공개키의 인증이 성공이면 상기 제품 정보 및 상기 제2 공개키에 기초하여 제1 해시값을 생성하고,상기 제1 공개키를 사용하여 상기 인증서를 복호화하여 제2 해시값을 획득하고,상기 제1 해시값 및 상기 제2 해시값이 일치하면 상기 제2 공개키의 인증이 성공인 것으로 결정하는,스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 인증 장치는,상기 제품 정보 및 상기 제2 공개키를 연결(concatenate)하여 연결 데이터를 생성하고, 상기 연결 데이터에 해시 알고리즘을 사용하여 상기 제1 해시값을 생성하고,공개특허 10-2025-0031758-3-상기 해시 알고리즘은 상기 인증서를 생성하는 데 사용되는 알고리즘과 동일한,스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 제품 정보는,상기 스토리지 장치의 식별 번호 및 버전 정보를 포함하고,상기 인증 장치는,상기 인증서에 포함된 데이터의 연결 순서와 일치하도록 상기 식별 번호, 상기 버전 정보, 및 상기 제2 공개키를 연결하는,스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 인증 장치는,상기 제2 공개키의 인증이 성공이면 상기 디버깅 장치와 챌린지-응답 인증을 수행하는,스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 인증 장치는,상기 제2 공개키의 인증이 성공이면 난수를 생성하여 상기 디버깅 장치에 전송하고,상기 디버깅 장치로부터 상기 제2 공개키에 대응하는 제2 개인키에 기초하여 생성되는 응답 신호를 수신하고,상기 응답 신호를 인증하고, 상기 응답 신호의 인증이 성공이면 상기 디버깅 이네이블 신호를 출력하는,스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 인증 장치는,상기 제2 공개키를 사용하여 상기 응답 신호를 복호화하여 인증값을 획득하고, 상기 난수 및 상기 인증값이 일치하면 상기 응답 신호의 인증이 성공인 것으로 결정하는,스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1항에 있어서,상기 디버깅 장치는 상기 제1 개인키 없이 상기 인증서, 상기 제1 공개키, 상기 제2 공개키, 및 상기 제2 공개키에 대응하는 제2 개인키를 사용하여 인증을 요청하는,스토리지 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제1 해시값 및 제품 정보를 저장하는 비휘발성 메모리; 및공개특허 10-2025-0031758-4-디버깅 장치로부터 제1 공개키, 제2 공개키, 및 인증서를 수신하고, 상기 제1 해시값을 사용하여 상기 제1 공개키를 검증하고, 상기 제1 공개키의 검증이 성공이면, 상기 제1 해시 값, 상기 제품 정보, 및 암호화 엔진을 사용하여 제2 공개키 및 인증서를 검증하는 제어 로직을 포함하는 인증 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,상기 제품 정보는,식별 번호 및 버전 정보를 포함하고,상기 비휘발성 메모리는,상기 제1 해시값을 저장하는 제1 OTP(One Time Programmable) 메모리;상기 식별 번호를 저장하는 제2 OTP 메모리; 및상기 버전 정보를 저장하는 제3 OTP 메모리를 포함하는, 인증 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서,상기 제어 로직은,버전 갱신에 따라 상기 제3 OTP 메모리에 저장된 상기 버전 정보를 갱신하는,인증 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제11항에 있어서,상기 암호화 엔진은,해시 알고리즘을 사용하여 해시값을 생성하는 해시 알고리즘 회로;상기 인증서를 복호화하는 공개키 가속기; 및난수를 생성하는 난수 생성기를 포함하는, 인증 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서,상기 해시 알고리즘 회로는,상기 제1 공개키의 제2 해시값을 생성하고, 상기 제품 정보 및 상기 제2 공개키에 기초하여 제3 해시값을 생성하고,상기 공개키 가속기는,상기 제1 공개키를 사용하여 상기 인증서를 복호화하여 제4 해시값을 획득하고,상기 제어 로직은,상기 제1 해시값과 상기 제2 해시값이 일치하면 상기 제1 공개키의 검증이 성공인 것으로 결정하고, 상기 제3해시값과 상기 제4 해시값이 일치하면 상기 제2 공개키 및 상기 인증서의 검증이 성공인 것으로 결정하는,인증 장치.공개특허 10-2025-0031758-5-청구항 16 제15항에 있어서,상기 제어 로직은,상기 제2 공개키 및 상기 인증서의 검증이 성공이면 상기 디버깅 장치와 챌린지-응답 인증을 수행하는,인증 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서,상기 난수 생성기는,상기 제2 공개키 및 상기 인증서의 검증이 성공이면 난수를 생성하고,상기 공개키 가속기는,상기 디버깅 장치로부터 상기 난수에 대한 응답 신호를 수신하면 상기 제2 공개키를 사용하여 상기 응답 신호를복호화하여 인증값을 출력하고,상기 제어 로직은,상기 난수를 챌린지 신호로서 상기 디버깅 장치에 전송하고, 상기 난수 및 상기 인증값이 일치하면 상기 챌린지-응답 인증이 성공인 것으로 결정하는,인증 장치."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "스토리지 장치의 제품 정보, 제1 공개키, 상기 제1 공개키에 대응하는 제1 개인키, 제2 공개키, 및 상기 제2 공개키에 대응하는 제2 개인키를 관리하고, 인증된 디버깅 장치의 요청에 응답하여 상기 제품 정보 및 상기 제1개인키에 기초하여 인증서를 생성하고, 상기 인증서, 상기 제1 공개키, 상기 제2 공개키, 및 상기 제2 개인키를상기 인증된 디버깅 장치에 전송하는 상기 인증 서버;상기 인증서, 상기 제1 공개키, 상기 제2 공개키, 및 상기 제2 개인키를 저장하면 상기 인증 서버와 연결을 해제하고, 상기 인증서, 상기 제1 공개키, 상기 제2 공개키, 및 상기 제2 개인키를 사용하여 상기 스토리지 장치에 디버깅을 요청하는 디버깅 장치; 및상기 인증서, 상기 제1 공개키, 및 상기 제2 공개키를 검증하고, 검증이 성공이면 상기 디버깅 장치에 챌린지신호를 전송하고, 상기 디버깅 장치로부터 상기 제2 개인키에 기초한 응답 신호를 수신하면 상기 제2 공개키를사용하여 상기 응답 신호를 검증하는 스토리지 장치를 포함하는 인증 시스템."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서,상기 인증 서버는,상기 제품 정보 및 상기 제2 공개키를 연결하여 연결 데이터를 생성하고, 상기 연결 데이터에 해시 알고리즘을사용하여 해시값을 생성하고, 상기 제1 개인키를 사용하여 상기 해시값에 서명함으로써 상기 인증서를생성하는,인증 시스템."}
{"patent_id": "10-2023-0113634", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제18항에 있어서,상기 스토리지 장치는,공개특허 10-2025-0031758-6-상기 인증서, 상기 제1 공개키, 및 상기 제2 공개키를 검증하고, 검증이 성공이면 난수를 생성하고, 상기 난수를 상기 챌린지 신호로서 상기 디버깅 장치에 전송하고,상기 디버깅 장치는,상기 제2 개인키를 사용하여 상기 난수에 서명함으로써 상기 응답 신호를 생성하고, 상기 응답 신호를 상기 스토리지 장치에 전송하는,인증 시스템."}
{"patent_id": "10-2023-0113634", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "디버깅 장치로부터 제1 공개키에 대응하는 제1 개인키에 기초하여 생성된 인증서, 상기 제1 공개키, 및 제2 공개 키를 수신하고, 상기 제1 공개키를 인증하고, 상기 제1 공개키의 인증이 성공이면 상기 제2 공개키를 인증하고, 상기 제2 공개키의 인증이 성공이면 디버깅 이네이블 신호를 출력하는 인증 장치; 및 상기 디버깅 이네이블 신호 에 응답하여 상기 디버깅 장치로부터 디버깅 신호를 수신하고, 상기 디버깅 신호에 기초하여 디버깅을 수행하는 프로세서를 포함한다."}
{"patent_id": "10-2023-0113634", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "개시 내용은 스토리지 장치, 인증 장치, 및 인증 시스템에 관한 것이다."}
{"patent_id": "10-2023-0113634", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "플래시 메모리 기반의 대용량 스토리지 장치의 대표적인 예로 솔리드 스테이트 드라이브(Solid State Drive(SSD))가 있다. SSD의 폭발적인 수요 증가와 함께 그 용도는 다양하게 분화되고 있다. 예를 들어, 최근에 는 클라우드 컴퓨팅이 대중화됨에 따라 사용자들은 복수의 SSD가 설치된 데이터 센터를 사용하여 대용량의 데이 터를 저장하고 액세스할 수 있게 되었다. SSD는 높은 신뢰성과 최적 서비스 품질을 제공할 수 있도록 관리 및 유지되어야 한다. SSD의 동작 중에 하드웨어 또는 소프트웨어 문제에 기인한 예상치 못한 고장이나 오류가 발생할 수 있다. 이 경 우, SSD는 오류 또는 고장이 발생한 시점에서의 상태를 수집하여 덤프 데이터(dump data)로 저장하게 된다. 수 집된 덤프 데이터는 SSD가 연결된 호스트로 전달된다. 호스트에 전달된 덤프 데이터는 디버깅 장치에 제공되고, 덤프 데이터 기반의 디버깅이 수행된다. SSD는 보안 데이터나 민감한 데이터를 저장하고 있는 경우도 있어, 인증된 장치에만 디버깅이 허용되어야 한다. SSD는 이러한 디버깅 장치를 인증하기 위한 인증 장치를 포함할 수 있다. 인증 장치는 디버깅 장치를 대상으로 소정의 인증 절차를 수행하고, 인증이 성공이면 디버깅 장치에 디버깅을 허여할 수 있다."}
{"patent_id": "10-2023-0113634", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "일 실시예는 인증 서버와 통신이 불가능한 환경에서 인증 장치의 인증을 통과하기 위한 디버깅 장치를 제공하고 자 한다. 일 실시예는 인증 서버와 통신이 불가능한 환경에서 디버깅 장치를 인증하기 위한 인증 장치, 스토리지 장치, 및 인증 시스템을 제공하고자 한다. 일 실시예는 마스터 개인키를 불출하지 않고도 인증 장치의 인증을 통과하기 위한 디버깅 장치를 제공하고자 한 다."}
{"patent_id": "10-2023-0113634", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "이러한 기술적 과제를 해결하기 위한 일 실시예에 따른 스토리지 장치는 디버깅 장치로부터 제1 공개키에 대응 하는 제1 개인키에 기초하여 생성된 인증서, 상기 제1 공개키, 및 제2 공개키를 수신하고, 상기 제1 공개키를 인증하고, 상기 제1 공개키의 인증이 성공이면 상기 제2 공개키를 인증하고, 상기 제2 공개키의 인증이 성공이 면 디버깅 이네이블 신호를 출력하는 인증 장치; 및 상기 디버깅 이네이블 신호에 응답하여 상기 디버깅 장치로 부터 디버깅 신호를 수신하고, 상기 디버깅 신호에 기초하여 디버깅을 수행하는 프로세서를 포함한다. 상기 제1 공개키는 상기 스토리지 장치의 마스터 공개키에 대응하는 키이고, 상기 제2 공개키는 상기 마스터 공 개키와 동일한 암호화 알고리즘을 사용하여 생성된 제품 공개키에 대응하는 키일 수 있다. 상기 인증 장치는, 상기 스토리지 장치의 마스터 공개키의 제1 해시값을 저장하고, 상기 제1 공개키의 제2 해시 값을 생성하고, 상기 제1 해시값 및 상기 제2 해시값이 일치하면 상기 제1 공개키의 인증이 성공인 것으로 결정 할 수 있다. 상기 인증 장치는, 상기 스토리지 장치의 제품 정보를 저장하고, 상기 제1 공개키의 인증이 성공이면 상기 제품 정보 및 상기 제2 공개키에 기초하여 제1 해시값을 생성하고, 상기 제1 공개키를 사용하여 상기 인증서를 복호 화하여 제2 해시값을 획득하고, 상기 제1 해시값 및 상기 제2 해시값이 일치하면 상기 제2 공개키의 인증이 성 공인 것으로 결정할 수 있다. 상기 인증 장치는, 상기 제품 정보 및 상기 제2 공개키를 연결(concatenate)하여 연결 데이터를 생성하고, 상기 연결 데이터에 해시 알고리즘을 사용하여 상기 제1 해시값을 생성하고, 상기 해시 알고리즘은 상기 인증서를 생 성하는 데 사용되는 알고리즘과 동일할 수 있다. 상기 제품 정보는, 상기 스토리지 장치의 식별 번호 및 버전 정보를 포함하고, 상기 인증 장치는, 상기 인증서 에 포함된 데이터의 연결 순서와 일치하도록 상기 식별 번호, 상기 버전 정보, 및 상기 제2 공개키를 연결할 수 있다. 상기 인증 장치는, 상기 제2 공개키의 인증이 성공이면 상기 디버깅 장치와 챌린지-응답 인증을 수행할 수 있다. 상기 인증 장치는, 상기 제2 공개키의 인증이 성공이면 난수를 생성하여 상기 디버깅 장치에 전송하고, 상기 디 버깅 장치로부터 상기 제2 공개키에 대응하는 제2 개인키에 기초하여 생성되는 응답 신호를 수신하고, 상기 응 답 신호를 인증하고, 상기 응답 신호의 인증이 성공이면 상기 디버깅 이네이블 신호를 출력할 수 있다. 상기 인증 장치는, 상기 제2 공개키를 사용하여 상기 응답 신호를 복호화하여 인증값을 획득하고, 상기 난수 및 상기 인증값이 일치하면 상기 응답 신호의 인증이 성공인 것으로 결정할 수 있다. 상기 디버깅 장치는 상기 제1 개인키 없이 상기 인증서, 상기 제1 공개키, 상기 제2 공개키, 및 상기 제2 공개 키에 대응하는 제2 개인키를 사용하여 인증을 요청할 수 있다. 일 실시예에 따른 인증 장치는 제1 해시값 및 제품 정보를 저장하는 비휘발성 메모리; 및 디버깅 장치로부터 제 1 공개키, 제2 공개키, 및 인증서를 수신하고, 상기 제1 해시값을 사용하여 상기 제1 공개키를 검증하고, 상기 제1 공개키의 검증이 성공이면, 상기 제1 해시 값, 상기 제품 정보, 및 암호화 엔진을 사용하여 제2 공개키 및 인증서를 검증하는 제어 로직을 포함할 수 있다. 상기 제품 정보는, 식별 번호 및 버전 정보를 포함하고, 상기 비휘발성 메모리는, 상기 제1 해시값을 저장하는 제1 OTP(One Time Programmable) 메모리; 상기 식별 번호를 저장하는 제2 OTP 메모리; 및 상기 버전 정보를 저 장하는 제3 OTP 메모리를 포함할 수 있다. 상기 제어 로직은, 버전 갱신에 따라 상기 제3 OTP 메모리에 저장된 상기 버전 정보를 갱신할 수 있다. 상기 암호화 엔진은, 해시 알고리즘을 사용하여 해시값을 생성하는 해시 알고리즘 회로; 상기 인증서를 복호화 하는 공개키 가속기; 및 난수를 생성하는 난수 생성기를 포함할 수 있다. 상기 해시 알고리즘 회로는, 상기 제1 공개키의 제2 해시값을 생성하고, 상기 제품 정보 및 상기 제2 공개키에 기초하여 제3 해시값을 생성하고, 상기 공개키 가속기는, 상기 제1 공개키를 사용하여 상기 인증서를 복호화하 여 제4 해시값을 획득하고, 상기 제어 로직은, 상기 제1 해시값과 상기 제2 해시값이 일치하면 상기 제1 공개키 의 검증이 성공인 것으로 결정하고, 상기 제3 해시값과 상기 제4 해시값이 일치하면 상기 제2 공개키 및 상기 인증서의 검증이 성공인 것으로 결정할 수 있다. 상기 제어 로직은, 상기 제2 공개키 및 상기 인증서의 검증이 성공이면 상기 디버깅 장치와 챌린지-응답 인증을 수행할 수 있다. 상기 난수 생성기는, 상기 제2 공개키 및 상기 인증서의 검증이 성공이면 난수를 생성하고, 상기 공개키 가속기 는, 상기 디버깅 장치로부터 상기 난수에 대한 응답 신호를 수신하면 상기 제2 공개키를 사용하여 상기 응답 신 호를 복호화하여 인증값을 출력하고, 상기 제어 로직은, 상기 난수를 챌린지 신호로서 상기 디버깅 장치에 전송 하고, 상기 난수 및 상기 인증값이 일치하면 상기 챌린지-응답 인증이 성공인 것으로 결정할 수 있다. 일 실시예에 따른 인증 시스템은 스토리지 장치의 제품 정보, 제1 공개키, 상기 제1 공개키에 대응하는 제1 개 인키, 제2 공개키, 및 상기 제2 공개키에 대응하는 제2 개인키를 관리하고, 인증된 디버깅 장치의 요청에 응답하여 상기 제품 정보 및 상기 제1 개인키에 기초하여 인증서를 생성하고, 상기 인증서, 상기 제1 공개키, 상기 제2 공개키, 및 상기 제2 개인키를 상기 인증된 디버깅 장치에 전송하는 상기 인증 서버; 상기 인증서, 상기 제 1 공개키, 상기 제2 공개키, 및 상기 제2 개인키를 저장하면 상기 인증 서버와 연결을 해제하고, 상기 인증서, 상기 제1 공개키, 상기 제2 공개키, 및 상기 제2 개인키를 사용하여 상기 스토리지 장치에 디버깅을 요청하는 디버깅 장치; 및 상기 인증서, 상기 제1 공개키, 및 상기 제2 공개키를 검증하고, 검증이 성공이면 상기 디버깅 장치에 챌린지 신호를 전송하고, 상기 디버깅 장치로부터 상기 제2 개인키에 기초한 응답 신호를 수신하면 상기 제2 공개키를 사용하여 상기 응답 신호를 검증하는 스토리지 장치를 포함한다. 상기 인증 서버는, 상기 제품 정보 및 상기 제2 공개키를 연결하여 연결 데이터를 생성하고, 상기 연결 데이터 에 해시 알고리즘을 사용하여 해시값을 생성하고, 상기 제1 개인키를 사용하여 상기 해시값에 서명함으로써 상 기 인증서를 생성할 수 있다. 상기 스토리지 장치는, 상기 인증서, 상기 제1 공개키, 및 상기 제2 공개키를 검증하고, 검증이 성공이면 난수 를 생성하고, 상기 난수를 상기 챌린지 신호로서 상기 디버깅 장치에 전송하고, 상기 디버깅 장치는, 상기 제2 개인키를 사용하여 상기 난수에 서명함으로써 상기 응답 신호를 생성하고, 상기 응답 신호를 상기 스토리지 장 치에 전송할 수 있다."}
{"patent_id": "10-2023-0113634", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "아래에서는 첨부한 도면을 참고로 하여 본 발명의 실시예에 대하여 본 발명이 속하는 기술 분야에서 통상의 지 식을 가진 자가 용이하게 실시할 수 있도록 상세히 설명한다. 그러나 본 발명은 여러 가지 상이한 형태로 구현 될 수 있으며 여기에서 설명하는 실시예에 한정되지 않는다. 그리고 도면에서 본 발명을 명확하게 설명하기 위해서 설명과 관계없는 부분은 생략하였으며, 명세서 전체를 통 하여 유사한 부분에 대해서는 유사한 도면 부호를 붙였다. 도면을 참고하여 설명한 흐름도에서, 동작 순서는 변 경될 수 있고, 여러 동작들이 병합되거나, 어느 동작이 분할될 수 있고, 특정 동작은 수행되지 않을 수 있다. 또한, 단수로 기재된 표현은 \"하나\" 또는 \"단일\" 등의 명시적인 표현을 사용하지 않은 이상, 단수 또는 복수로 해석될 수 있다. 제1, 제2 등과 같이 서수를 포함하는 용어는 다양한 구성요소를 설명하는 데 사용될 수있지만, 구성요소는 이러한 용어에 의해 한정되지는 않는다. 이들 용어는 하나의 구성요소를 다른 구성요소로부 터 구별하는 목적으로 사용될 수 있다. 도 1은 일 실시예에 따른 인증 시스템의 개략적인 블록도이고, 도 2는 일 실시에에 따른 디버깅 장치와 서버의 동작을 설명하기 위한 순서도이고, 도 3은 일 실시예에 따른 인증서 생성 방법을 설명하기 위한 순서도이다. 도 1을 참조하면, 일 실시예에 따른 인증 시스템은 디버깅 장치(또는 디버거(debugger); 100), 서버, 및 전자 장치를 포함한다. 인증 시스템은 디버깅 장치가 전자 장치를 대상으로 디버깅을 수 행하기 위한 인증 프로세스를 수행할 수 있다. 즉, 디버깅 장치는 전자 장치를 디버깅하기 위한 장치 일 수 있다. 예를 들어, 전자 장치에 이상이 발생하면 디버깅 장치는 전자 장치와 연결되고, 전 자 장치에 디버깅을 수행할 수 있다. 전자 장치는 서버(server), 데이터 센터(data center), 인공지능(artificial intelligence(AI)) 장치, 개 인용 컴퓨터(personal computer), 랩탑(laptop) 컴퓨터, 미디어 재생기, 디지털 카메라 등과 같은 사용자 장치 들, 또는 내비게이션(navigation), 블랙 박스, 차량용 전장 장치 등과 같은 차량용 장비(automotive device)에 포함될 수 있다. 또는, 전자 장치는 휴대용 통신 단말기(mobile phone), 스마트폰(smart phone), 태블릿 PC(tablet personal computer), 웨어러블 기기, 헬스케어 기기 또는 사물 인터넷(Internet of Things(IoT)) 기 기와 같은 모바일(mobile) 시스템일 수도 있다. 일 실시예에서, 전자 장치는 복수의 스토리지 장치(예를 들어, SSD(Solid State Drive) 장치)를 포함하는 데이터 센터이고, 디버깅 장치는 복수의 스토리지 장치 중 적어도 하나에 디버깅을 수행할 수 있다. 서버는 전자 장치의 제조사가 관리하는 인증 서버일 수 있다. 디버깅 장치가 전자 장치에 디버깅을 수행하기 위해서는 서버로부터 전자 장치 고유의 인증 데이터를 획득해야 할 수 있다. 하지 만, 전자 장치가 배치된 장소에서는 디버깅 장치는 서버와 통신이 불가할 수 있다. 이에, 디버 깅 장치는 전자 장치에 연결되기 전에(전자 장치가 배치된 장소에 진입하기 전에) 서버와 통신할 수 있다. 디버깅 장치는 전자 장치를 디버깅하기 위한 인증 데이터를 서버에 요청할 수 있다. 도 1에서 두 줄의 수직선은 디버깅 장치와 서버가 서로 통신할 때 전자 장치는 디버깅 장 치 또는 서버와 통신하지 않음을 나타낸다. 서버는 디버깅 장치의 요청에 응답하여 인증 데이터를 생성할 수 있다. 서버는 전자 장치 의 인증을 위한 키 페어(key pair) 등을 저장할 수 있다. 예를 들어, 인증을 위한 키 페어는 마스터 공개키 및 마스터 개인키를 포함할 수 있다. 서버는 인증 데이터를 생성하는 프로세서를 포함할 수 있다. 프로 세서는 키 페어에 기초하여 인증 데이터를 생성할 수 있다. 도 2를 참조하면, 서버는 제1 키 페어를 유지할 수 있다(S210). 제1 키 페어는 마스터 공개키 및 마스터 개인키를 포함할 수 있다. 서버가 제1 키 페어를 유지하는 것은 서버의 스토리지 장치에 제1 키 페어 를 저장하고 있는 것을 의미할 수 있다. 서버는 소정의 암호화 알고리즘을 사용하여 제1 키 페어를 생성하 고, 제1 키 페어를 저장할 수 있다. 디버깅 장치는 서버에 인증 데이터를 요청할 수 있다(S220). 디버깅 장치는 디버깅 대상이 되는 전자 장치(예를 들어, 도 1의 전자 장치)의 제품 정보를 서버에 전송할 수 있다. 예를 들어, 제품 정 보는 식별 번호, 버전 정보 등을 포함할 수 있다. 식별 번호는 전자 장치 고유의 번호를 나타낼 수 있다. 버전 정보는 전자 장치에서 현재 구동되는 시스템의 버전 정보를 나타낼 수 있다. 버전 정보는 한번 버전이 올라가면 되돌릴 수 없는 안티롤백(anti-rollback) 값을 포함할 수 있다. 전자 장치는 보안 등을 이유로 시스템의 버전이 업데이트될 수 있다. 어떤 실시예에서, 디버깅 장치는 인증 데이터를 요청하기에 앞서 서버에 로그인(log-in)할 수 있다. 서버는 소정의 인증 프로세스를 통해 디버깅 장치의 로그인을 허용할 수 있다. 즉, 서버는 디버 깅 장치가 인증 프로세스를 통과하면 액세스를 허용하고, 인증 프로세스를 통과하지 못하면 액세스를 금지 할 수 있다. 서버는 제2 키 페어를 생성할 수 있다(S230). 제2 키 페어는 제품 공개키 및 제품 개인키를 포함할 수 있 다. 서버는 제1 키 페어를 생성할 때 사용된 동일한 암호화 알고리즘을 사용하여 제2 키 페어를 생성할 수 있다. 서버는 인증서를 생성할 수 있다(S240). 디버깅 대상이 되는 전자 장치는 디버깅 장치의 검증에 인증 서를 사용할 수 있다. 서버는 제1 키 페어, 제2 키 페어, 및 제품 정보 중 적어도 하나를 사용하여 인증서 를 생성할 수 있다. 도 1 및 도 3을 참조하면, 서버의 프로세서는 인증서를 생성할 수 있다. 프로세서는 제품 공개 키(p.pubk) 및 제품 정보(p.info)를 연결시킬(concatenate) 수 있다(S310). 제품 정보(p.info)는 식별 번호 및 버전 정보 중 적어도 하나를 포함할 수 있다. 어떤 실시예에서, 프로세서는 제품 공개키(p.pubk), 제품 정 보(p.info)의 순서로 연결(concatenation)을 수행할 수 있지만, 실시예가 반드시 이에 한정되는 것은 아니고, 반대의 순서도 가능하다. 어떤 실시예에서, 프로세서는 제품 공개키(p.pubk), 제품 정보(p.info) 중 식별 번호, 제품 정보(p.info) 중 버전 정보의 순서로 연결(concatenation)을 수행할 수 있지만, 실시예가 반드시 이 에 한정되는 것은 아니다. 프로세서는 제품 공개키(p.pubk) 및 제품 정보(p.info)를 연결시키는 순서를 도 1의 전자 장치와 공유할 수 있다. 어떤 실시예에서, 프로세서는 순서에 대한 정보를 디버깅 장치 를 통해 전자 장치에 전송할 수 있다. 순서에 대한 정보는 순서 그 자체, 연결 사이 구분자 (delimiter) 등을 포함할 수 있다. 어떤 실시예에서, 디버깅 장치는 프로세서에 순서를 지시하고, 해 당 순서를 전자 장치에 전달할 수 있다. 프로세서는 연결된 데이터(concatenated data)를 해시할 수 있다(S320). 프로세서는 해시 알고리즘을 사용하여, 연결된 데이터의 해시값을 생성할 수 있다. 어떤 실시예에서, 프로세서는 제품 정보(p.info), 제품 공개키(p.pubk)의 순서로 연결된 데이터를 해시하여 해시값을 생성할 수 있다. 어떤 실시예에서, 프로세서 는 제품 공개키(p.pubk), 식별 번호, 버전 정보의 순서로 연결된 데이터를 해시하여 해시값을 생성할 수 있다. 프로세서는 마스터 개인키(m.prik)를 사용하여 해시값에 서명을 수행함으로써 인증서를 생성할 수 있다 (S330). 마스터 개인키(m.prik)를 사용하여 서명된 인증서는 마스터 공개키를 사용하여 복호(decrypt)될 수 있 다. 다시 도 2를 참조하면, 서버는 인증 데이터를 디버깅 장치에 전송할 수 있다(S250). 인증 데이터는 제1 키 페어 중 마스터 공개키, 제2 키 페어, 및 인증서를 포함할 수 있다. 즉, 서버는 마스터 공개키, 제 품 공개키, 제품 개인키, 및 인증서를 디버깅 장치에 전송할 수 있다. 디버깅 장치는 인증 데이터를 저장할 수 있다(S260). 디버깅 장치는 인증 데이터를 저장하면 서버 와 연결을 해제할 수 있다. 디버깅 장치는 인증 데이터를 사용하여 디버깅 대상이 되는 전자 장치에 디버깅을 요청할 수 있다. 도 4는 일 실시예에 따른 인증 시스템의 개략적인 블록도이고, 도 5는 일 실시예에 따른 디버깅 장치와 컨트롤 러의 동작을 설명하기 블록도이고, 도 6은 일 실시예에 따른 디버깅 장치와 인증 장치의 동작을 설명하기 위한 순서도이고, 도 7 및 도 8은 일 실시예에 따른 인증 장치의 인증 방법을 설명하기 위한 순서도이다. 도 4를 참조하면, 일 실시예에 따른 인증 시스템은 디버깅 장치, 서버, 및 전자 장치를 포 함할 수 있다. 도 4의 인증 시스템은 도 1의 인증 시스템에 대한 설명이 동일하게 적용되므로, 중복되 는 설명은 생략한다. 디버깅 장치는 인증 데이터(ATDT; 150)를 저장할 수 있다. 디버깅 장치는 전자 장치에 액세스하기 전에 서버로부터 인증 데이터를 획득했을 수 있다. 디버깅 장치는 전자 장치와 연결되고, 인증 데이터를 사용하여 전자 장치에 디버깅을 요청할 수 있다. 전자 장치 가 배치된 장소에서는 디버깅 장치는 서버와 통신이 불가할 수 있다. 도 4에서 두 줄의 수직선 은 디버깅 장치와 전자 장치가 서로 통신할 때 서버는 디버깅 장치 또는 전자 장치와 통신하지 않음을 나타낸다. 디버깅 장치는 디버깅 인터페이스를 사용하여 전자 장치와 연결될 수 있다. 디버깅 인터페이스 는 디버깅을 위한 프로토콜로서, JTAG(Joint Test Action Group), SWD(Serial Wire Debug) 등의 방식을 사 용할 수 있다. 전자 장치는 디버깅 인터페이스를 지원하기 위한 포트를 포함할 수 있다. 어떤 실 시예에서, 포트는 JTAG 방식을 지원하기 위한 TDI(데이터 입력 핀), TDO(데이터 출력 핀), TCK(테스트 클 록 신호 핀), TMS(테스트 모드 전환 신호 핀), TRST(리셋 핀), 접지 등의 핀을 포함할 수 있다. 전자 장치는 전자 장치의 제반 동작을 제어하는 컨트롤러(CTRL; 310)를 포함할 수 있다. 어떤 실시예 에서, 컨트롤러는 시스템온칩(System on Chip(SoC))으로 구현될 수도 있다. 컨트롤러는 디버깅 장치 로부터 인증 데이터를 수신하고, 인증 데이터를 검증할 수 있다. 컨트롤러는 검증 결과에 따라 디버깅 장치에 디버깅을 허여할 수 있다. 예를 들어, 컨트롤러는 검증이 성공하면 디버깅 장치 에 디버깅을 허여하고, 검증이 실패하면 디버깅 장치에 디버깅을 금지할 수 있다. 컨트롤러는 전자 장치의 주변 장치를 제어하는 서브 컨트롤러를 포함할 수 있다. 어떤 실시예에서, 전자 장치는 메모리 장치를 포함하고, 컨트롤러는 메모리 장치(예를 들어, 동적 랜덤 액세스 메모리 (Dynamic Random Access Memory(DRAM)와 같은 휘발성 메모리)를 제어하기 위한 메모리 컨트롤러를 포함할 수 있다. 어떤 실시예에서, 전자 장치는 스토리지 장치(예를 들어, 낸드 플래시(NAND flash)와 같은 비휘발성 메모리)를 포함하고, 컨트롤러는 스토리지 장치를 제어하기 위한 스토리지 컨트롤러를 포함할 수 있다. 도 5를 참조하면, 일 실시예에 따른 컨트롤러는 인증 장치(SJTAG; 410) 및 프로세서를 포함할 수 있 다. 인증 장치는 디버깅 장치의 인증 데이터를 검증할 수 있다. 인증 데이터는 마스터 공 개키(m.pubk), 제품 공개키(p.pubk), 제품 개인키(p.prik), 및 인증서(certificate)를 포함할 수 있다. 프로세 서는 CPU(Central Processing Unit), GPU(Graphics Processing Unit), NPU(Neural Processing Unit), DPU(Data Processing Unit), AP(Application Processor) 등과 같은 다양한 프로세서들 중 적어도 하나로 구현 될 수 있다. 어떤 실시예에서, 프로세서는 싱글 코어 프로세서 또는 멀티 코어 프로세서로 구현될 수 있다. 인증 장치는 디버깅 장치로부터 인증 데이터를 수신할 수 있다. 예를 들어, 인증 장치는 디버깅 인터페이스를 통해 인증 데이터를 수신할 수 있다. 인증 장치는 인증 데이터를 검증 할 수 있다. 인증 장치는 검증 결과에 따라 디버깅 이네이블 신호를 프로세서에 출력할 수 있다. 예 를 들어, 인증 장치는 검증이 성공이면 디버깅 이네이블 신호를 출력하고, 검증이 실패이면 디버깅 이네이 블 신호를 출력하지 않을 수 있다. 디버깅 이네이블 신호는 디버깅 장치로 하여금 프로세서에 디버깅 을 가능하게 하는 신호일 수 있다. 프로세서가 디버깅 이네이블 신호를 수신하면 디버깅 장치는 프로 세서에 디버깅을 수행할 수 있다. 즉, 프로세서가 디버깅 이네이블 신호를 수신하면 디버깅 장치 는 프로세서의 디버깅 신호에 기초하여 디버깅을 수행할 수 있다. 프로세서가 디버깅 이네이블 신호를 수신하지 않으면 디버깅 장치는 프로세서에 디버깅이 불가능할 수 있다. 도 5 및 도 6을 참조하면, 디버깅 장치는 인증 장치에 인증 데이터의 검증을 요청할 수 있다. 디버깅 장치는 인증 장치에 인증 데이터 중 마스터 공개키(m.pubk)의 검증을 요청할 수 있다 (S610). 디버깅 장치는 디버깅 인터페이스를 통해 인증 장치에 마스터 공개키(m.pubk)를 전송할 수 있다. 인증 장치는 마스터 공개키(m.pubk)를 검증할 수 있다(S620). 인증 장치는 디버깅 장치의 마스 터 공개키(m.pubk)가 도 4의 서버로부터 획득된 것인지 검증할 수 있다. 인증 장치는 마스터 공개키 (m.pubk)를 검증하기 위한 검증값을 저장할 수 있다. 검증값은 서버의 마스터 공개키에 대한 정보를 포함 할 수 있다. 예를 들어, 검증값은 서버의 마스터 공개키의 해시값일 수 있다. 인증 장치는 검증값을 저장하는 비휘발성 메모리를 포함할 수 있다. 도 7에서는 일 실시예에 따른 인증 장치가 마스터 공개키(m.pubk)를 검증하는 방법을 설명한다. 도 7을 참 조하면, 인증 장치는 마스터 공개키(m.pubk)에 해시 알고리즘을 사용하여 해시값(HASH1)을 생성할 수 있다 (S621). 인증 장치는 해시값(HASH1)과 해시값(HASH2)이 일치하는지 여부를 판정할 수 있다(S622). 해시값(HASH2)은 해시값(HASH1)을 검증하기 위한 검증값으로서, 인증 장치의 비휘발성 메모리에 저장될 수 있다. 인증 장치 는 서버의 마스터 공개키에 해시 알고리즘을 사용하여 해시값(HASH2)을 생성하여 저장할 수 있다. 해시값 (HASH1)과 해시값(HASH2)의 생성에 사용되는 해시 알고리즘은 동일할 수 있다. 인증 장치는 해시값(HASH1)과 해시값(HASH2)이 일치하면 마스터 공개키(m.pubk)의 검증이 성공인 것으로 결정할 수 있다(S623). 인증 장치는 마스터 공개키(m.pubk)를 저장할 수 있다. 예를 들어, 인증 장치(41 0)는 마스터 공개키(m.pubk)를 저장하는 메모리를 포함할 수 있다. 메모리는 휘발성 메모리로 구현될 수 있으나, 실시예가 반드시 이에 한정되는 것은 아니다. 인증 장치는 마스터 공개키(m.pubk)의 검증이 성공 이면 단계(S640)로 진행하여 다음 검증을 수행할 수 있다. 인증 장치는 해시값(HASH1)과 해시값(HASH2)이 일치하지 않으면 마스터 공개키(m.pubk)의 검증이 실패인 것으로 결정할 수 있다(S624). 인증 장치는 마스터 공개키(m.pubk)의 검증이 실패이면 인증 데이터의 검증을 종료할 수 있다. 다시 도 5 및 도 6을 참조하면, 디버깅 장치는 인증 장치에 제품 공개키(p.pubk)의 검증을 요청할 수 있다(S630). 디버깅 장치는 디버깅 인터페이스를 통해 인증 장치에 제품 공개키(p.pubk) 및 인증 서를 전송할 수 있다. 인증서는 제품 공개키(p.pubk)의 검증에 사용될 수 있다. 인증 장치는 제품 공개키(p.pubk)를 검증할 수 있다(S640). 인증 장치는 단계(S620)에서 마스터 공개 키(m.pubk)의 검증이 성공이면 제품 공개키(p.pubk)를 검증할 수 있다. 인증 장치는 디버깅 장치의 제품 공개키(p.pubk)가 도 4의 서버로부터 획득된 것인지 검증할 수 있다. 인증 장치의 비휘발성 메 모리는 제품 공개키(p.pubk)를 검증하기 위한 제품 정보를 더 저장할 수 있다. 제품 정보는 식별 번호, 버전 정 보 등을 포함할 수 있다. 도 8에서는 일 실시예에 따른 인증 장치가 제품 공개키(p.pubk)를 검증하는 방법을 설명한다. 도 8을 참조 하면, 인증 장치는 마스터 공개키(m.pubk)를 사용하여 인증서를 복호화하여 해시값(HASH3)을 획득할 수 있 다(S641). 인증서는 도 1의 프로세서가 마스터 개인키(m.prik)를 사용하여 서명하였으므로, 마스터 개인키 (m.prik)와 함께 제1 키 페어를 이루는 마스터 공개키(m.pubk)에 의해 복호화될 수 있다. 마스터 공개키 (m.pubk)는 단계(S620) 이후에 인증 장치의 메모리에 저장되어 있을 수 있다. 해시값(HASH3)은 도 1의 프 로세서가 제품 공개키(p.pubk) 및 제품 정보(p.info)에 해시 알고리즘을 사용하여 생성한 값일 수 있다. 인증 장치는 제품 공개키(p.pubk) 및 제품 정보(p.info')를 사용하여 해시값(HASH4)을 생성할 수 있다 (S642). 인증 장치의 비휘발성 메모리는 제품 정보(p.info')를 더 저장하며, 제품 정보(p.info')는 도 3의 제품 정보(p.info)와 동일한 값을 가질 수 있다. 인증 장치는 제품 공개키(p.pubk) 및 제품 정보(p.inf o')를 연결하여 연결된 데이터를 생성할 수 있다. 인증 장치가 제품 공개키(p.pubk) 및 제품 정보 (p.info')를 연결시키는 순서는 도 3에서 프로세서가 제품 공개키(p.pubk) 및 제품 정보(p.info)를 연결시 키는 순서와 동일할 수 있다. 인증 장치는 연결된 데이터에 해시 알고리즘을 사용하여 해시값(HASH4)을 생 성할 수 있다. 인증 장치는 해시값(HASH3)과 해시값(HASH4)이 일치하는지 여부를 판정할 수 있다(S643). 해시값(HASH4)을 생성하는 데 사용된 해시 알고리즘은 해시값(HASH3)을 생성하는 데 사용된 해시 알고리즘과 동일할 수 있다. 이 에, 제품 정보(p.info')와 제품 정보(p.info)가 일치하면 해시값(HASH3)과 해시값(HASH4)이 일치할 수 있다. 인증 장치는 해시값(HASH3)과 해시값(HASH4)이 일치하면 제품 공개키(p.pubk)의 검증이 성공인 것으로 결 정할 수 있다(S644). 어떤 실시예에서, 인증 장치는 제품 공개키(p.pubk)와 함께, 인증서의 검증이 성공인 것으로 결정할 수 있다. 인증 장치는 해시값(HASH3)과 해시값(HASH4)이 일치하면 제품 공개키(p.pubk)를 메모리에 저장할 수 있다. 메모리는 휘발성 메모리로 구현될 수 있으나, 실시예가 반드시 이에 한정되는 것은 아니다. 인증 장치는 제품 공개키(p.pubk)의 검증이 성공이면 단계(S650)로 진행하여 다음 검증을 수행할 수 있다. 인증 장치는 해시값(HASH3)과 해시값(HASH4)이 일치하지 않으면 제품 공개키(p.pubk)의 검증이 실패인 것으로 결정할 수 있다(S645). 인증 장치는 제품 공개키(p.pubk)의 검증이 실패이면 인증 데이터의 검 증을 종료할 수 있다. 다시 도 5 및 도 6을 참조하면, 인증 장치는 제품 공개키(p.pubk)의 검증이 성공이면 챌린지-응답 인증 (challenge-response authentication)을 수행할 수 있다. 인증 장치는 난수(random number; RDN)를 생성 할 수 있다(S650). 인증 장치는 참-난수 생성기(True Random Number Generator(TRNG))를 사용하여 난수 (RDN)를 생성할 수 있다. 어떤 실시예에서, 인증 장치는 참-난수 생성기 및 의사-난수 생성기(Pseudo Random Number Generator(PRNG))를 조합하여 난수(RDN)를 생성할 수 있다. 인증 장치는 난수(RDN)를 메모 리에 저장할 수 있다. 인증 장치는 난수(RDN)를 챌린지-응답 인증의 챌린지로서 디버깅 장치에 전송할 수 있다(S650). 디버 깅 장치는 챌린지인 난수(RDN)를 수신할 수 있다. 디버깅 장치는 난수(RDN)를 사용하여 서명을 생성할 수 있다(S660). 예를 들어, 디버깅 장치는 인증 데이터의 제품 개인키(p.prik)를 사용하여 난수(RDN)에 서명을 수행할 수 있다. 어떤 실시예에서, 디버깅 장치는 난수(RDN) 및 디버깅 정보에 기초하여 서명을 생성할 수 있다. 예를 들어, 디버깅 장치는 난 수(RDN) 및 디버깅 정보를 연결(concatenate)하여 연결 데이터를 생성할 수 있다. 디버깅 장치는 난수(RDN), 디버깅 정보의 순서로 연결 데이터를 생성할 수 있지만, 실시예가 반드시 이에 한정되는 것은 아니다. 디버깅 장치는 제품 개인키(p.prik)를 사용하여 연결 데이터에 서명을 수행할 수 있다. 제품 개인키 (p.prik)를 사용한 서명은, 제품 개인키(p.prik)와 함께 제2 키 페어를 이루는 제품 공개키(p.pubk)에 의해 복 호화될 수 있다. 디버깅 장치는 서명을 챌린지-응답 인증의 응답으로서 인증 장치에 전송할 수 있다(S665). 인증 장치 는 응답인 서명을 수신할 수 있다. 인증 장치는 서명을 검증할 수 있다(S670). 인증 장치는 인증 데이터의 제품 공개키(p.pubk)를 사용하여 서명을 복호화하고, 응답 데이터를 획득할 수 있다. 인증 장치는 응답 데이터와, 메모리에 저장 된 난수(RDN)를 비교할 수 있다. 인증 장치는 응답 데이터가 난수(RDN)와 일치하면 서명 검증이 성공인 것으로 결정할 수 있다. 인증 장치는 응답 데이터가 난수(RDN)와 일치하지 않으면 서명 검증이 실패인 것으 로 결정할 수 있다. 어떤 실시예에서, 인증 장치는 복호화 결과 응답 데이터와 함께 디버깅 정보를 더 획 득할 수 있다. 인증 장치는 인증 결과가 성공이면 디버깅 정보를 프로세서에 전송할 수 있다. 인증 장치는 디버깅 장치에 인증 결과를 전송할 수 있다(S670). 디버깅 장치는 인증 결과가 실 패이면 디버깅을 수행할 수 없다. 디버깅 장치는 인증 결과가 성공이면 디버깅을 수행할 수 있다. 인증 장 치는 인증 결과가 성공이면 프로세서에 디버깅 이네이블 신호를 출력할 수 있다. 어떤 실시예에서, 디버깅 장치는 인증 결과가 성공이면 프로세서에 디버깅 정보를 전송할 수 있다. 프로세서는 디 버깅 이네이블 신호 및 디버깅 정보에 기초하여 디버깅을 수행할 수 있다. 이와 같이, 인증 시스템에서 전자 장치가 있는 장소에서 서버와 통신이 불가능하고, 서버가 마스터 개인키(m.prik)를 불출하지 않더라도, 디버깅 장치는 인증서, 마스터 공개키(m.pubk), 제품 공개키 (p.pubk), 및 제품 개인키(p.prik)를 사용하여 인증 장치의 인증을 통과할 수 있다. 만약 인증서, 마스터 공개키(m.pubk), 제품 공개키(p.pubk), 및 제품 개인키(p.prik) 중 적어도 하나가 유출되는 상황에서도, 인증 장치는 보안을 유지할 수 있다. 예를 들어, 고객사 별로 상이한 식별 번호를 갖는 전자 장치가 제공될 수 있다. 이때, 어느 고객사의 인증 서, 마스터 공개키(m.pubk), 제품 공개키(p.pubk), 및 제품 개인키(p.prik) 중 적어도 하나가 유출되더라도, 다 른 고객사의 전자 장치는 상이한 식별 번호를 가지므로 인증 장치의 인증을 통과할 수 없게 된다. 또한, 인증서, 마스터 공개키(m.pubk), 제품 공개키(p.pubk), 및 제품 개인키(p.prik) 중 적어도 하나가 유출된 고객 사의 경우, 버전 정보를 업데이트하면 보안을 유지할 수 있게 된다. 한 번 갱신된 버전 정보는 다시 되돌릴 수 없는 안티롤백 값을 가질 수 있다. 도 9는 일 실시예에 따른 인증 장치, 리텐션 로직, 및 프로세서의 동작을 설명하기 위한 블록도이고, 도 10은 일 실시예에 따른 리텐션 로직의 동작을 설명하기 위한 회로도이다. 도 9를 참조하면, 일 실시예에 따른 인증 장치는 인증 장치(SJTAG; 910), 리텐션 로직(RTL; 920), 및 복수 의 프로세서를 포함할 수 있다. 복수의 프로세서는 제1 내지 제m 프로세서(930_1~930_m)를 포함할 수 있다. 여기서, m은 1보다 큰 정수일 수 있다. 인증 장치는 인증 결과에 따라 디버깅 이네이블 신호(DBEN)를 출력할 수 있다. 디버깅 이네이블 신호 (DBEN)는 복수의 프로세서 중 디버깅 대상이 되는 프로세서에 대한 정보를 포함할 수 있다. 예를 들어, 인 증 장치는 디버깅 장치의 인증이 성공이면 디버깅 이네이블 신호(DBEN)를 출력하고, 디버깅 장치의 인증이 실패이면 디버깅 이네이블 신호(DBEN)를 출력하지 않을 수 있다. 리텐션 로직은 인증 장치로부터 디버깅 이네이블 신호(DBEN)를 입력 받을 수 있다. 리텐션 로직(92 0)은 디버깅 이네이블 신호(DBEN)에 기초하여 JTAG 신호(JSG_1~JSG_m)를 출력하는 복수의 리텐션 회로를 포함할 수 있다. 각각의 리텐션 회로는 래치 회로 및 선택 회로를 포함할 수 있다. 도 9 및 도 10을 참조하면, 일 실시예에 따른 제1 리텐션 회로는 래치 회로 및 선택 회로를 포 함할 수 있다. 래치 회로는 디버깅 이네이블 신호(DBEN)에 응답하여 인증 결과를 저장할 수 있다. 예를 들 어, 디버깅 이네이블 신호(DBEN)는 프로세서(930_1)에 대한 인증 성공을 지시하고, 래치 회로는 프로세서 (930_1)에 대한 인증 성공 지시를 저장할 수 있다. 래치 회로는 선택 회로에 인증 결과를 전달할 수 있다.선택 회로는 선택 신호(SEL), 리셋 신호(RST), 및 인증 결과를 수신할 수 있다. 선택 회로는 제1 JTAG 신호(JSG_1)를 프로세서(930_1)에 출력할 수 있다. 선택 회로는 선택 신호(SEL)에 따라, 인증 결과 또는 리셋 신호(RST)를 선택적으로 프로세서(930_1)에 제공할 수 있다. 선택 회로는 멀티플렉서 (multiplexer)로 구현될 수 있다. 어떤 실시예에서, 리텐션 로직은 제1 리텐션 회로와 동일한 구조의 회로를 복수 개 포함할 수 있다. 예를 들어, 리텐션 로직은 복수의 프로세서의 수에 대응하는 복수의 리텐션 회로를 포함할 수 있다. 복수의 프로세서는 m개의 프로세서를 포함하고, 리텐션 로직은 m개의 래치 회로 및 m개의 선택 회로 를 포함할 수 있다. 리텐션 로직은 디버깅 이네이블 신호(DBEN)에 응답하여 인증 결과를 저장하고, 복수의 프로세서 각각 에 JTAG 신호(JSG_1~JSG_m)를 제공할 수 있다. 예를 들면, 제1 JTAG 신호(JSG_1)는 제1 프로세서(930_1)에 제 공되고, 제2 JTAG 신호(JSG_2)는 제2 프로세서(930_2)에 제공되며, 제m JTAG 신호(JSG_m)는 제m 프로세서 (930_m)에 제공될 수 있다. 복수의 프로세서 각각은 JTAG 신호(JSG_1~JSG_m)에 응답하여 디버깅 동작을 수 행할 수 있다. 도 11은 일 실시예에 따른 인증 장치의 블록도이고, 도 12는 일 실시예에 따른 암호화 엔진의 블록도이고, 도 13은 일 실시예에 따른 비휘발성 메모리의 동작을 설명하기 위한 도면이고, 도 14는 일 실시예에 따른 휘발성 메모리의 동작을 설명하기 위한 도면이다. 도 11를 참조하면, 일 실시예에 따른 인증 장치는 제어 로직(CTL; 510), 암호화 엔진(CRPT; 520), 비휘발 성 메모리(NVM; 530), 및 휘발성 메모리(VM; 540)를 포함할 수 있다. 제어 로직은 인증 장치의 전반적인 동작을 제어할 수 있다. 제어 로직은 암호화 엔진, 비 휘발성 메모리, 휘발성 메모리를 제어할 수 있다. 예를 들어, 제어 로직은 암호화 엔진을 사용하여 암호화 또는 복호화를 수행할 수 있다. 제어 로직은 비휘발성 메모리에 저장된 데이터를 독 출할 수 있다. 비휘발성 메모리에서 독출된 데이터는 암호화 엔진에 전달되어 암호화에 사용될 수 있 다. 제어 로직은 검증에 성공한 데이터를 휘발성 메모리에 저장할 수 있다. 암호화 엔진은 암호화와 복호화를 수행할 수 있다. 예를 들어, 암호화 엔진은 디버깅 장치 및 디버깅 장치로부터 수신한 데이터를 검증하기 위해 암호화 및 복호화를 수행할 수 있다. 암호화 엔진은 암호화에 필요한 구성요소 및 복호화에 필요한 구성요소를 포함할 수 있다. 도 11 및 도 12을 참조하면, 암호화 엔진 은 난수 생성기(random number generator(RNG); 521), 공개키 가속기(public key accelerator(PKA); 522), 및 해시 알고리즘 회로(HASH; 523)를 포함할 수 있다. 난수 생성기는 난수를 생성할 수 있다. 난수 생성기는 참-난수 생성기(TRNG)를 포함할 수 있다. 난수 생성기는 참-난수 생성기(TRNG)를 사용하여 난수를 생성할 수 있다. 어떤 실시예에서, 난수 생성기는 의사-난수 생성기(PRNG)를 더 포함할 수 있다. 난수 생성기는 참-난수 생성기(TRNG) 및 의사-난수 생성기 (PRNG)를 조합하여 난수를 생성할 수 있다. 예를 들어, 참-난수 생성기(TRNG)는 참-난수를 생성하고, 의사-난수 생성기(PRNG)는 참-난수 생성기(TRNG)가 생성한 참-난수에 기초하여 난수를 생성할 수 있다. 난수 생성기 가 생성한 난수는 디버깅 장치의 챌린지-응답 인증에 사용될 수 있다. 공개키 가속기는 디버깅 장치로부터 수신한 데이터를 복호화할 수 있다. 디버깅 장치는 마스터 개인키 또 는 제품 개인키를 사용하여 생성한 데이터를 인증 장치에 전송할 수 있다. 공개키 가속기는 마스터 공개키 또는 제품 공개키를 사용하여 이러한 데이터에 복호화를 수행할 수 있다. 휘발성 메모리는 마스터 공개키 및 제품 공개키를 저장할 수 있다. 예를 들어, 디버깅 장치는 마스터 개인키를 사용하여 생성된 인증서 를 인증 장치에 전송할 수 있다. 인증서는 인증 서버가 마스터 개인키를 사용하여 생성할 수 있다. 공개키 가속기는 마스터 공개키를 사용하여 인증서를 복호화하여 제1 복호화 값을 획득할 수 있다. 또한, 디버깅 장치는 제품 개인키를 사용하여 응답을 생성하여 인증 장치에 전송할 수 있다. 응답은 인증 장치가 요청한 챌린지-응답 인증의 챌린지에 대응하는 응답일 수 있다. 공개키 가속기는 제품 공개키 를 사용하여 응답을 복호화하여 제2 복호화 값을 획득할 수 있다. 공개키 가속기가 복호화 결과 획득한 제 1 및 제2 복호화 값들은 제어 로직이 검증을 수행할 때 사용될 수 있다. 해시 알고리즘 회로는 해시 알고리즘을 사용하여 해시값을 생성할 수 있다. 예를 들어, 해시 알고리즘 회 로는 디버깅 장치로부터 수신한 마스터 공개키의 제1 해시값을 생성할 수 있다. 해시 알고리즘 회로 는 비휘발성 메모리의 제품 정보 및 디버깅 장치로부터 수신한 제품 공개키를 연결하여 연결 데이터를 생 성하고, 연결 데이터의 제2 해시값을 생성할 수 있다. 또한, 해시 알고리즘 회로는 인증 서버의 마스터 공 개키의 제3 해시값을 생성할 수 있다. 제3 해시값은 비휘발성 메모리에 저장될 수 있다. 해시 알고리즘 회 로가 생성한 해시값들은 제어 로직이 검증을 수행할 때 사용될 수 있다. 도 11 및 도 13을 참조하면, 일 실시예에 따른 비휘발성 메모리는 디버깅 장치 및 디버깅 장치로부터 수신 한 데이터를 검증하기 위한 데이터를 저장할 수 있다. 예를 들어, 비휘발성 메모리는 키 정보 및 제 품 정보를 저장할 수 있다. 키 정보는 인증 서버가 인증 장치에 대해 관리하는 키에 대한 정보 일 수 있다. 인증 서버는 인증 장치에 대해 키 페어(공개키 및 개인키)를 저장할 수 있다. 비휘발성 메모 리는 인증 서버의 키 페어 중 마스터 공개키에 대한 정보를 저장할 수 있다. 예를 들어, 도 12의 해시 알 고리즘 회로는 인증 서버의 마스터 공개키의 제3 해시값을 생성하고, 비휘발성 메모리는 마스터 공개 키의 제3 해시값을 저장할 수 있다. 비휘발성 메모리가 저장하는 제3 해시값은 디버깅 장치가 전송하는 마 스터 공개키의 검증에 사용될 수 있다. 예를 들어, 해시 알고리즘 회로는 디버깅 장치가 전송하는 마스터 공개키의 제1 해시값을 생성할 수 있다. 제어 로직은 비휘발성 메모리의 제3 해시값과 해시 알고리즘 회로가 생성한 제1 해시값을 비교하여 디버깅 장치가 전송하는 마스터 공개키를 검증할 수 있다. 제품 정보는 인증 장치의 제품 정보(또는 전자 장치의 제품 정보)일 수 있다. 예를 들어, 제품 정보 는 식별 번호, 버전 정보 등을 포함할 수 있다. 제품 정보는 디버깅 장치가 전송하는 제품 공개키의 검증에 사용될 수 있다. 도 12의 해시 알고리즘 회로는 제품 정보 및 디버깅 장치가 전송하는 제품 공개키를 연결하여 연결 데이터를 생성하고, 연결 데이터의 제2 해시값을 생성할 수 있다. 제어 로직은 제 2 해시값과 복호화된 인증서를 비교하여 디버깅 장치가 전송하는 제품 공개키를 검증할 수 있다. 도 11 및 도 14를 참조하면, 일 실시예에 따른 휘발성 메모리는 검증이 성공인 데이터를 저장할 수 있다. 제어 로직은 디버깅 장치로부터 수신한 데이터의 검증이 성공이면 해당 데이터를 휘발성 메모리에 저 장할 수 있다. 예를 들어, 제어 로직은 디버깅 장치로부터 수신한 마스터 공개키(m.pubk)에 기초하여 생성 된 제1 해시값과, 비휘발성 메모리가 저장하는 제3 해시값을 비교할 수 있다. 제어 로직은 제1 해시 값과 제3 해시값이 일치하면 마스터 공개키(m.pubk)의 검증이 성공인 것으로 결정할 수 있다. 제어 로직은 제1 메모리 영역에 마스터 공개키(m.pubk)를 저장할 수 있다. 제어 로직은 비휘발성 메모리의 제품 정보 및 디버깅 장치로부터 수신한 제품 공개키(p.pubk)에 기초 하여 생성된 제2 해시값과, 도 12의 공개키 가속기가 획득한 제1 복호화 값을 비교할 수 있다. 인증 서버 는 제품 공개키 및 제품 정보에 해시 알고리즘을 사용하여 제4 해시값을 생성하고, 마스터 개인키를 사용하여 제4 해시값에 서명함으로써 인증서를 생성할 수 있다. 따라서, 공개키 가속기가 획득한 제1 복호화 값은 제4 해시값과 동일할 수 있다. 제어 로직은 제2 해시값과 제4 해시값이 일치하면 제품 공개키(p.pubk)의 검증이 성공인 것으로 결정할 수 있다. 제어 로직은 제2 메모리 영역에 제품 공개키(p.pubk)를 저장 할 수 있다. 제어 로직은 도 12의 난수 생성기가 생성한 난수(CHLG)를 제3 메모리 영역에 저장할 수 있다. 제어 로직은 난수(CHLG)와, 도 12의 공개키 가속기가 획득한 제2 복호화 값을 비교할 수 있다. 제어 로직은 난수(CHLG)와 제2 복호화 값이 일치하면 챌린지-응답 인증이 성공인 것으로 결정할 수 있다. 어떤 실시예에서, 디버깅 장치의 응답 데이터는 디버깅 정보(DBG)를 포함할 수 있다. 제어 로직은 제4 메모리 영역에 디버깅 정보(DBG)를 저장할 수 있다. 제어 로직은 디버깅 정보(DBG)를 프로세서에 전달하고, 프로세서는 디버깅 정보(DBG)에 기초하여 디버깅을 수행할 수 있다. 어떤 실시예에서, 암호화 엔진은 난수 생성기, 공개키 가속기, 및 해시 알고리즘 회로의 동작을 순차적으로 실행하는 유한 상태 기계(Finite State Machine(FSM)) 회로를 더 포함할 수 있다. FSM 회로 는 도 6과 같은 순서도에서 인증 장치가 S620, S640, S650, S670의 순서로 인증을 수행할 수 있도록 난수 생성기, 공개키 가속기, 및 해시 알고리즘 회로의 동작을 제어할 수 있다. 예를 들어, FSM 회로 는, 해시 알고리즘 회로가 디버깅 장치의 마스터 공개키의 제1 해시값을 생성하고, 공개키 가속기가 인증서를 복호화하고, 해시 알고리즘 회로가 제품 정보 및 제품 공개키의 제2 해시값을 생성하고, 난수 생 성기가 난수를 생성하고, 공개키 가속기가 응답을 복호화하는 순서로 동작하도록 난수 생성기, 공개키 가속기, 및 해시 알고리즘 회로를 제어할 수 있다.도 15는 일 실시예에 따른 비휘발성 메모리의 블록도이다. 도 15를 참조하면, 일 실시예에 따른 비휘발성 메모리는 복수의 OTP(One Time Programmable) 메모리 (610~630)를 포함할 수 있다. 복수의 OTP 메모리(610~630)의 한 칸은 하나의 메모리 셀을 나타내며, 하나의 메 모리 셀은 1 비트의 데이터를 저장할 수 있다. 복수의 OTP 메모리(610~630)는 초기에 모든 메모리 셀이 '0' 비 트를 유지하고, 한 번 '1' 비트로 프로그램된 메모리 셀은 계속하여 '1' 비트를 유지할 수 있다. 제1 OTP 메모리는 A 비트들을 저장하고, 도 13의 키 정보를 저장할 수 있다. 제2 OTP 메모리는 B 비트들을 저장하고, 도 13의 제품 정보 중 식별 번호를 저장할 수 있다. 제3 OTP 메모리는 C 비트 들을 저장하고, 도 13의 제품 정보 중 버전 정보를 저장할 수 있다. 이때, A, B, C는 1보다 큰 정수이고, 실시예에 따라 모두 같은 수로 구현되거나, A, B, C 중 두 개만 같은 수로 구현되거나, 또는 모두 다른 수로 구 현될 수 있다. 도 13의 키 정보 및 제품 정보 중 식별 번호는 일반적으로 한 번 설정되면 변경되지 않으므로, 제1 OTP 메모리와 제2 OTP 메모리는 특별한 사정이 없는 한, 한 번 프로그램된 데이터를 변경하지 않고 계속 유지할 수 있다. 반면에, 비휘발성 메모리가 포함된 전자 장치는 보안 등을 이유로 현재 구동되는 시 스템의 버전이 업데이트될 수 있다. 이에, 제3 OTP 메모리는 시스템의 업데이트에 따라 버전 정보를 갱신 할 수 있다. 도 11의 제어 로직은 제3 OTP 메모리에 버전 정보 갱신을 지시하고, 제3 OTP 메모리 는 제어 로직의 지시에 기초하여 버전 정보를 갱신할 수 있다. 예를 들어, 도 15에서 제3 OTP 메모리 는 현재 시스템의 제1 버전 정보에 대응하여 메모리 셀들(631~633)에 '1' 비트를 저장할 수 있다. 이후에 전자 장치가 업데이트된 제2 버전 정보의 시스템을 구동하면, 메모리 셀에 '1' 비트를 프로그램할 수 있다. 복수의 OTP 메모리(610~630)가 메모리 셀들을 프로그램하는 순서 등은 실시예에 따라 다양한 방식으로 구 현될 수 있다. 도 16은 일 실시예에 따른 집적 회로의 블록도이다. 도 16을 참조하면, 일 실시예에 따른 집적 회로는 프로세서, 메모리, 주변 회로, DAP(debugging access port; 1010), JTAG, 마스터 포트(MPORT; 1030), 및 인증 장치(SJTAG; 1040)를 포 함한다. 프로세서는 복수의 프로세싱 유닛들을 포함할 수 있다. 외부의 사용자는 DAP를 통하여 집 적 회로를 디버깅할 수 있다. JTAG는 마스터 포트를 통하여 집적 회로의 내부 구성들 (1100, 1200, 1300)을 디버깅할 수 있다. 일 실시예에 따른 인증 장치는 사용자와 JATG 사이의 인증 프로토콜 진행하기 위한 요청으로 합법 적인 사용자가 가진 정보를 사용할 수 있다. 또한, 인증 장치는 인증 프로토콜 후에 사용자로부터 입력된 접근 제어 정보를 근거로 하여 JTAG에 대한 프로세싱 유닛들 각각의 접근 여부, 메모리의 접근 여부, 주변 회로의 접근 여부를 결정할 수 있다. 인증 장치는 도 1 내지 도 15를 참조하여 설명한 인증 장치에 대한 내용이 적용될 수 있다. 즉, 인증 장 치는 DAP, JTAG, 및 마스터 포트를 통해 수신되는 마스터 공개키, 제품 공개키, 제품 개인키, 및 인증서의 검증을 수행하고, 검증이 성공이면 디버깅을 허용할 수 있다. 이에, 일 실시예에 따른 집적 회로는 안전한 디버깅을 수행함으로써 보안을 강화할 수 있다. 도 17은 일 실시예에 따른 스토리지 장치의 개략적인 블록도이다. 도 17을 참조하면, 일 실시예에 따른 스토리지 장치는 데이터를 저장할 수 있다. 스토리지 장치는 컴퓨팅 시스템에 배치되어 호스트의 명령에 기초하여 동작할 수 있다. 컴퓨팅 시스템은 서버, 데이터 센터, 인 공지능 장치, 개인용 컴퓨터, 랩탑 컴퓨터, 미디어 재생기, 디지털 카메라 등과 같은 사용자 장치들, 또는 내비 게이션, 블랙 박스, 차량용 전장 장치 등과 같은 차량용 장비일 수 있다. 또는, 컴퓨팅 시스템은 휴대용 통신 단말기, 스마트폰, 태블릿 PC, 웨어러블 기기, 헬스케어 기기 또는 사물 인터넷 기기와 같은 모바일 시스템일 수도 있다. 컴퓨팅 시스템에서 호스트는 다양한 인터페이스를 통하여 스토리지 장치와 통신할 수 있다. 호스트는 스 토리지 장치에 데이터 처리 동작, 예를 들어, 데이터 독출 동작, 데이터 라이트(프로그램) 동작, 및 데이터 소거 동작 등을 요청할 수 있다. 예를 들어, 호스트는 CPU, GPU, 마이크로프로세서, 또는 AP 등일 수 있다. 스토리지 장치는 스토리지 컨트롤러 및 비휘발성 메모리(Non-Volatile Memory(NVM); 2200)를 포함 할 수 있다. 스토리지 장치는 호스트로부터의 요청에 따라 데이터를 저장하기 위한 저장 매체들을 포함할 수 있다. 예를 들어, 스토리지 장치는 SSD(Solid-State Drive), eMMC(embedded Multi-Media Card), UFS(Universal Flash Storage), CF(Compact Flash), SD(Secure Digital) 장치, Micro-SD 장치, Mini-SD 장치, xD(extreme digital) 장치, 또는 메모리 스틱 등 다양한 종류로 구현될 수 있다. 스토리지 장치가 SSD인 경우, 스토리지 장치는 NVMe(non-volatile memory express) 표준을 따르는 장치일 수 있다. 스토리지 장치가 임베디드 메모리 혹은 외장(external) 메모리인 경우, 스토리지 장치 는 UFS 표준 혹은 eMMC 표준을 따르는 장치일 수 있다. 호스트와 스토리지 장치는 각각 채용된 표 준 프로토콜에 따른 패킷(packet)을 생성하고 이를 전송할 수 있다. 스토리지 장치의 비휘발성 메모리가 플래시 메모리를 포함할 때, 이러한 플래시 메모리는 2차원 (2D) NAND 메모리 어레이나 3차원(3D) NAND 메모리 어레이를 포함할 수 있다. 다른 예로서, 스토리지 장치 의 비휘발성 메모리는 다른 다양한 종류의 메모리들을 포함할 수도 있다. 예를 들어, 비휘발성 메 모리는 MRAM(Magnetoresistive Random-Access Memory), STT-RAM(Spin-Transfer Torque Magnetic Random-Access Memory), CBRAM(Conductive Bridging Random-Access Memory), FeRAM(Ferroelectric Random- Access Memory), PRAM(Phase-Change Random-Access Memory), RRAM(Resistive Random-Access Memory) 등 다른 다양한 종류의 메모리가 적용될 수 있다. 스토리지 컨트롤러는 호스트 인터페이스, 메모리 인터페이스, 및 CPU를 포함할 수 있 다. 또한, 스토리지 컨트롤러는 플래시 변환 레이어(Flash Translation Layer(FTL); 2120), 인증 장치 (SJTAG; 2130), 패킷 매니저(packet manager; 2140), 버퍼 메모리(buffer memory; 2150), ECC(Error Correction Code; 2160) 엔진, 및 AES(Advanced Encryption Standard; 2170) 엔진을 더 포함할 수 있다. 스토리지 컨트롤러는 플래시 변환 레이어가 로딩되는 워킹 메모리(working memory)를 더 포함할 수 있으며, CPU가 플래시 변환 레이어를 실행하는 것에 의해 비휘발성 메모리에 대한 데이터 라 이트 동작 및 리드 동작이 제어될 수 있다. 호스트 인터페이스는 호스트로부터/호스트로 패킷을 송수신할 수 있다. 호스트로부터 호스트 인터페이스 에 전송되는 패킷은 커맨드(command) 혹은 비휘발성 메모리에 라이트될 데이터 등을 포함할 수 있 으며, 호스트 인터페이스로부터 호스트에 전송되는 패킷은 커맨드에 대한 응답(response) 혹은 비휘발성 메모리로부터 리드된 데이터 등을 포함할 수 있다. 메모리 인터페이스는 비휘발성 메모리에 라이트될 데이터를 비휘발성 메모리에 송신하거나, 비휘발성 메모리로부터 리드된 데이터를 수신할 수 있다. 이러한 메모리 인터페이스는 토글 (Toggle) 혹은 온파이(Open NAND Flash Interface(ONFI))와 같은 표준 규약을 준수하도록 구현될 수 있다. 플래시 변환 레이어는 어드레스 매핑(address mapping), 웨어-레벨링(wear-leveling), 가비지 콜렉션 (garbage collection)과 같은 여러 기능을 수행할 수 있다. 어드레스 매핑 동작은 호스트로부터 수신한 논리 어 드레스(logical address)를, 비휘발성 메모리 내에 데이터를 실제로 저장하는 데 사용되는 물리 어드레스 (physical address)로 바꾸는 동작이다. 웨어-레벨링은 비휘발성 메모리 내의 블록(block)들이 균일하게 사용되도록 하여 특정 블록의 과도한 열화를 방지하기 위한 기술로, 예시적으로 물리 블록(physical block)들의 소거 카운트들을 밸런싱하는 펌웨어 기술을 통해 구현될 수 있다. 가비지 콜렉션은, 블록의 유효 데이터를 새 블록에 복사한 후 기존 블록을 소거하는 방식을 통해 비휘발성 메모리 내에서 사용 가능한 용량을 확보하 기 위한 기술이다. 인증 장치는 도 1 내지 도 15를 참조하여 설명한 인증 장치에 대한 설명이 동일하게 적용될 수 있다. 인 증 장치는 스토리지 장치를 디버깅하고자 하는 디버깅 장치와 연결될 수 있다. 인증 장치는 디버깅 장치와 연결되고, 디버깅 장치로부터 마스터 공개키, 제품 공개키, 제품 개인키, 및 인증서를 수신할 수 있다. 인증 장치는 디버깅 인터페이스를 통해 디버깅 장치와 통신할 수 있다. 인증 장치는 마스터 공개키, 제품 공개키, 제품 개인키, 및 인증서의 검증을 수행하고, 검증이 성공이면 디버깅 장치의 디버깅을 허 용할 수 있다. 패킷 매니저는 호스트와 협의된 인터페이스의 프로토콜에 따른 패킷을 생성하거나, 호스트로부터 수신된 패킷으로부터 각종 정보를 파싱할 수 있다. 또한, 버퍼 메모리는 비휘발성 메모리에 라이트될 데이터 혹은 비휘발성 메모리로부터 리드될 데이터를 임시로 저장할 수 있다. 버퍼 메모리는 스토리지 컨트롤러 내에 구비되는 구성일 수 있으나, 스토리지 컨트롤러의 외부에 배치되어도 무방하다. ECC 엔진은 비휘발성 메모리로부터 리드되는 리드 데이터에 대한 오류 검출 및 정정 기능을 수행할 수 있다. 보다 구체적으로, ECC 엔진은 비휘발성 메모리에 기입될 기입 데이터에 대하여 패리티 비 트(parity bit)들을 생성할 수 있으며, 이와 같이 생성된 패리티 비트들은 라이트 데이터와 함께 비휘발성 메모 리 내에 저장될 수 있다. 비휘발성 메모리로부터의 데이터 리드 시, ECC 엔진은 리드 데이터 와 함께 비휘발성 메모리로부터 리드되는 패리티 비트들을 이용하여 리드 데이터의 에러를 정정하고, 에 러가 정정된 리드 데이터를 출력할 수 있다. AES 엔진은, 스토리지 컨트롤러로 입력되는 데이터에 대한 암호화(encryption) 동작과 복호화 (decryption) 동작 중 적어도 하나를, 대칭 키 알고리즘(symmetric-key algorithm)을 이용하여 수행할 수 있다. 어떤 실시예에서, 도 1 내지 도 17을 참고로 하여 설명한 각 구성요소 또는 둘 이상의 구성요소의 조합은 디지 털 회로, 프로그램 가능한 또는 프로그램할 수 없는 로직 장치 또는 어레이, 응용 주문형 집적 회로 (application specific integrated circuit, ASIC) 등으로 구현될 수 있다. 이상에서 본 발명의 실시예에 대하여 상세하게 설명하였지만 본 발명의 권리범위는 이에 한정되는 것은 아니고 다음의 청구범위에서 정의하고 있는 본 발명의 기본 개념을 이용한 당업자의 여러 변형 및 개량 형태 또한 본 발명의 권리범위에 속하는 것이다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12 도면13 도면14 도면15 도면16 도면17"}
{"patent_id": "10-2023-0113634", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일 실시예에 따른 인증 시스템의 개략적인 블록도이다. 도 2는 일 실시에에 따른 디버깅 장치와 서버의 동작을 설명하기 위한 순서도이다. 도 3은 일 실시예에 따른 인증서 생성 방법을 설명하기 위한 순서도이다. 도 4는 일 실시예에 따른 인증 시스템의 개략적인 블록도이다. 도 5는 일 실시예에 따른 디버깅 장치와 컨트롤러의 동작을 설명하기 블록도이다. 도 6은 일 실시예에 따른 디버깅 장치와 인증 장치의 동작을 설명하기 위한 순서도이다. 도 7 및 도 8은 일 실시예에 따른 인증 장치의 인증 방법을 설명하기 위한 순서도이다. 도 9는 일 실시예에 따른 인증 장치, 리텐션 로직, 및 프로세서의 동작을 설명하기 위한 블록도이다. 도 10은 일 실시예에 따른 리텐션 로직의 동작을 설명하기 위한 회로도이다. 도 11은 일 실시예에 따른 인증 장치의 블록도이다. 도 12는 일 실시예에 따른 암호화 엔진의 블록도이다. 도 13은 일 실시예에 따른 비휘발성 메모리의 동작을 설명하기 위한 도면이다. 도 14는 일 실시예에 따른 휘발성 메모리의 동작을 설명하기 위한 도면이다. 도 15는 일 실시예에 따른 비휘발성 메모리의 블록도이다. 도 16은 일 실시예에 따른 집적 회로의 블록도이다. 도 17은 일 실시예에 따른 스토리지 장치의 개략적인 블록도이다."}
