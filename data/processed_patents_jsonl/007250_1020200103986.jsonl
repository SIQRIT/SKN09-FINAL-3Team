{"patent_id": "10-2020-0103986", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0080163", "출원번호": "10-2020-0103986", "발명의 명칭": "런타임시 디지털 프로세스에서의 동적 인공 지능/머신 러닝 모델 업데이트, 또는 재트레이닝", "출원인": "유아이패스, 인크.", "발명자": "오로스 안드레이 로버트"}}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨터 구현 방법에 있어서,컴퓨팅 시스템 상에서 실행되는 디지털 프로세스에 의해, 인공 지능(artificial intelligence; AI)/머신 러닝(machine learning; ML) 모델에 대한 업데이트 요청을 청취하는(listening for) 단계; 및상기 업데이트 요청이 수신되어 AI/ML 모델을 업데이트하는 경우, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 AI/ML 모델의 업데이트된 버전을 호출하기 위해 상기 디지털 프로세스를 재초기화하거나 또는 재인스턴스화하고 다른 업데이트 요청을 청취하는 단계를 포함하고,상기 AI/ML 모델의 상기 업데이트는 상기 디지털 프로세스의 런타임(runtime) 동안 발생하고,상기 디지털 프로세스는 로봇 프로세스 자동화(robotic process automation; RPA) 워크플로우를 포함하고 상기AI/ML 모델은 상기 RPA 워크플로우의 활동에 의해 호출되는 것인, 컴퓨터 구현 방법."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 AI/ML 모델에 대한 재트레이닝 요청을청취하는 단계; 및상기 재트레이닝 요청이 수신되어 상기 AI/ML 모델을 재트레이닝하는 경우, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 AI/ML 모델의 재트레이닝을 개시하는 단계를 더 포함하고,상기 AI/ML 모델의 상기 재트레이닝은 상기 디지털 프로세스의 런타임 동안 발생하는 것은, 컴퓨터 구현 방법."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 AI/ML 모델의 상기 재트레이닝은 상기 디지털 프로세스를 실행하는 상기 컴퓨팅 시스템과는 상이한 하나이상의 다른 컴퓨팅 시스템 상에서 발생하는 것인, 컴퓨터 구현 방법."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서,상기 업데이트 요청이 수신될 때까지, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기재트레이닝 동안 상기 AI/ML 모델의 현재 버전을 사용하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서,상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 재트레이닝된 AI/ML 모델의 성능을,성능 임계치(performance threshold)에, 상기 AI/ML 모델의 이전 버전의 성능에 대해, 또는 둘 모두에 대해 비교하는 단계; 및상기 재트레이닝된 AI/ML 모델이 상기 성능 임계치, 상기 AI/ML 모델의 상기 이전 버전의 성능, 또는 둘 모두를초과하는 경우, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 AI/ML 모델을 업데이트하는 단계를 더 포함하는, 컴퓨터 구현 방법.공개특허 10-2021-0080163-3-청구항 6 제1항에 있어서,미리 결정된 양의 트레이닝 데이터가 수신된 이후, 마지막 재트레이닝 이후 미리 결정된 양의 시간이 경과한 이후, 또는 둘 모두의 경우에, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 AI/ML 모델의 재트레이닝을 자동적으로 개시하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 디지털 프로세스는 비즈니스 프로세스 관리(business process management; BPM) 플로우차트, 순차적 플로우, 또는 유한 상태 머신(finite state machine; FSM)을 포함하는 것인, 컴퓨터 구현 방법."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 AI/ML 모델은 상기 RPA 워크플로우의 활동에 직접적으로 임베딩되는(embedded) 것인, 컴퓨터 구현 방법."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서,상기 디지털 프로세스는, 상기 AI/ML 모델을 스토리지로부터 로딩하거나 또는 상기 AI/ML 모델을 상기 디지털프로세스에 의해 호출 가능하게 만드는 초기화 상태를 포함하는 것인, 컴퓨터 구현 방법."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "디지털 프로세스를 포함하는 컴퓨터 프로그램이 구현되어 있는 비일시적 컴퓨터 판독 가능 기록 매체에 있어서,상기 프로그램은 적어도 하나의 프로세서로 하여금:인공 지능(AI)/머신 러닝(ML) 모델에 대한 재트레이닝 요청 또는 업데이트 요청을 청취하게 하도록;상기 재트레이닝 요청이 수신되어 상기 AI/ML 모델을 재트레이닝하는 경우, 상기 AI/ML 모델의 재트레이닝을 개시하게 하도록; 그리고상기 업데이트 요청이 수신되어 상기 AI/ML 모델을 업데이트하는 경우, 상기 AI/ML 모델의 업데이트된 버전을호출하기 위해 상기 디지털 프로세스를 재초기화 또는 재인스턴스화하고 다른 재트레이닝 요청 또는 업데이트요청을 청취하게 하도록 구성되고,상기 AI/ML 모델의 상기 재트레이닝 또는 업데이트는 상기 디지털 프로세스의 런타임 동안 발생하고,상기 디지털 프로세스는 로봇 프로세스 자동화(RPA) 워크플로우를 포함하고 상기 AI/ML 모델은 상기 RPA 워크플로우의 활동에 의해 호출되는 것인, 비일시적 컴퓨터 판독 가능 기록 매체."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서,상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금:상기 업데이트 요청이 수신될 때까지 상기 재트레이닝 동안 상기 AI/ML 모델의 현재 버전을 사용하게 하도록 구성되는 것인, 비일시적 컴퓨터 판독 가능 기록 매체."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제10항에 있어서,상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금:공개특허 10-2021-0080163-4-상기 재트레이닝된 AI/ML 모델의 성능을, 성능 임계치에 대해, 상기 AI/ML 모델의 이전 버전의 성능에 대해, 또는 둘 모두에 대해 비교하게 하도록; 그리고상기 재트레이닝된 AI/ML 모델이 상기 성능 임계치, 상기 AI/ML 모델의 상기 이전 버전의 성능, 또는 둘 모두를초과하는 경우, 상기 AI/ML 모델을 업데이트하게 하도록 구성되는 것인, 비일시적 컴퓨터 판독 가능 기록 매체."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제10항에 있어서,상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금:미리 결정된 양의 트레이닝 데이터가 수신된 이후, 마지막 재트레이닝 이후 미리 결정된 양의 시간이 경과한 이후, 또는 둘 모두의 경우에, 상기 AI/ML 모델의 재트레이닝을 자동적으로 개시하게 하도록 구성되는 것인, 비일시적 컴퓨터 판독 가능 기록 매체."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제10항에 있어서,상기 AI/ML 모델은 상기 RPA 워크플로우의 활동에 직접적으로 임베딩되는 것인, 비일시적 컴퓨터 판독 가능 기록 매체."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "컴퓨팅 시스템에 있어서,디지털 프로세스를 포함하는 컴퓨터 프로그램 명령어를 저장하는 메모리; 및상기 컴퓨터 프로그램 명령어를 실행하도록 구성되는 적어도 하나의 프로세서를 포함하되, 상기 명령어는 상기적어도 하나의 프로세서로 하여금:인공 지능(AI)/머신 러닝(ML) 모델에 대한 재트레이닝 요청을 청취하게 하도록; 그리고상기 재트레이닝 요청이 수신되어 상기 AI/ML 모델을 재트레이닝하는 경우, 상기 AI/ML 모델의 재트레이닝을 개시하게 하도록 구성되고,상기 AI/ML 모델의 상기 재트레이닝은 상기 디지털 프로세스의 런타임 동안 발생하고,상기 디지털 프로세스는 로봇 프로세스 자동화(RPA) 워크플로우를 포함하고 상기 AI/ML 모델은 상기 RPA 워크플로우의 활동에 의해 호출되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서,상기 명령어는 또한, 상기 적어도 하나의 프로세서로 하여금:상기 AI/ML 모델에 대한 업데이트 요청을 청취하게 하도록; 그리고상기 업데이트 요청이 수신되어 상기 AI/ML 모델을 업데이트하는 경우, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 AI/ML 모델의 업데이트된 버전을 호출하기 위해 상기 디지털 프로세스를 재초기화하거나 또는 재인스턴스화하고 다른 업데이트 요청을 청취하게 하도록 구성되고,상기 AI/ML 모델의 상기 업데이트는 상기 디지털 프로세스의 런타임 동안 발생하는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제15항에 있어서,공개특허 10-2021-0080163-5-상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금:업데이트 요청이 수신될 때까지 상기 재트레이닝 동안 상기 AI/ML 모델의 현재 버전을 사용하게 하도록 구성되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제15항에 있어서,상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금:상기 재트레이닝된 AI/ML 모델의 성능을, 성능 임계치에 대해, 상기 AI/ML 모델의 이전 버전의 성능에 대해, 또는 둘 모두에 대해 비교하게 하도록; 그리고상기 재트레이닝된 AI/ML 모델이 상기 성능 임계치, 상기 AI/ML 모델의 상기 이전 버전의 성능, 또는 둘 모두를초과하는 경우, 상기 AI/ML 모델을 업데이트하게 하도록 구성되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제15항에 있어서,상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금:미리 결정된 양의 트레이닝 데이터가 수신된 이후, 마지막 재트레이닝 이후 미리 결정된 양의 시간이 경과한 이후, 또는 둘 모두의 경우에, 상기 AI/ML 모델의 재트레이닝을 자동적으로 개시하게 하도록 구성되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2020-0103986", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제15항에 있어서,상기 AI/ML 모델은 상기 RPA 워크플로우의 활동에 직접적으로 임베딩되는 것인, 컴퓨팅 시스템."}
{"patent_id": "10-2020-0103986", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "런타임시 디지털 프로세스에서 인공 지능(AI)/머신 러닝(ML) 모델을 동적으로 업데이트하는 것, 또는 재트레이닝 및 업데이트하는 것이 개시된다. AI/ML 모델 업데이트 또는 재트레이닝 및 업데이트를 위해 생산 동작이 중단될 필요가 없을 수도 있다. AI/ML 모델에 대한 업데이트 단계 및/또는 재트레이닝 단계는 디지털 프로세스의 일부로 서 포함될 수도 있다. AI/ML 모델 업데이트는 내부 로직으로부터(예를 들면, 조건의 평가로부터, AI/ML 모델을 호출하는 표현에 의해, 등등으로), 외부 요청으로부터(예를 들면, 유한 상태 머신(FSM)에서의 외부 트리거, 예컨 대 파일 변경, 데이터베이스 데이터, 서비스 호출, 등등으로부터), 또는 둘 모두로부터 요청될 수도 있다. AI/ML 모델 업데이트 또는 재트레이닝 및 업데이트의 자동화가 제공될 수도 있는데, 여기서, 소프트웨어는 AI/ML 모델 이 이용 가능하게 된 이후(그리고 어쩌면 직후에) 재트레이닝된 및/또는 업데이트된 AI/ML 모델을 사용하여 재로 딩/재초기화/재인스턴스화된다. 공개특허10-2021-0080163 CPC특허분류 G06N 3/008 (2019.01)명 세 서 청구범위 청구항 1 컴퓨터 구현 방법에 있어서, 컴퓨팅 시스템 상에서 실행되는 디지털 프로세스에 의해, 인공 지능(artificial intelligence; AI)/머신 러닝 (machine learning; ML) 모델에 대한 업데이트 요청을 청취하는(listening for) 단계; 및 상기 업데이트 요청이 수신되어 AI/ML 모델을 업데이트하는 경우, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디 지털 프로세스에 의해, 상기 AI/ML 모델의 업데이트된 버전을 호출하기 위해 상기 디지털 프로세스를 재초기화 하거나 또는 재인스턴스화하고 다른 업데이트 요청을 청취하는 단계 를 포함하고, 상기 AI/ML 모델의 상기 업데이트는 상기 디지털 프로세스의 런타임(runtime) 동안 발생하고, 상기 디지털 프로세스는 로봇 프로세스 자동화(robotic process automation; RPA) 워크플로우를 포함하고 상기 AI/ML 모델은 상기 RPA 워크플로우의 활동에 의해 호출되는 것인, 컴퓨터 구현 방법. 청구항 2 제1항에 있어서, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 AI/ML 모델에 대한 재트레이닝 요청을 청취하는 단계; 및 상기 재트레이닝 요청이 수신되어 상기 AI/ML 모델을 재트레이닝하는 경우, 상기 컴퓨팅 시스템 상에서 실행되 는 상기 디지털 프로세스에 의해, 상기 AI/ML 모델의 재트레이닝을 개시하는 단계 를 더 포함하고, 상기 AI/ML 모델의 상기 재트레이닝은 상기 디지털 프로세스의 런타임 동안 발생하는 것은, 컴퓨터 구현 방법. 청구항 3 제2항에 있어서, 상기 AI/ML 모델의 상기 재트레이닝은 상기 디지털 프로세스를 실행하는 상기 컴퓨팅 시스템과는 상이한 하나 이상의 다른 컴퓨팅 시스템 상에서 발생하는 것인, 컴퓨터 구현 방법. 청구항 4 제2항에 있어서, 상기 업데이트 요청이 수신될 때까지, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 재트레이닝 동안 상기 AI/ML 모델의 현재 버전을 사용하는 단계를 더 포함하는, 컴퓨터 구현 방법. 청구항 5 제2항에 있어서, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 재트레이닝된 AI/ML 모델의 성능을, 성능 임계치(performance threshold)에, 상기 AI/ML 모델의 이전 버전의 성능에 대해, 또는 둘 모두에 대해 비 교하는 단계; 및 상기 재트레이닝된 AI/ML 모델이 상기 성능 임계치, 상기 AI/ML 모델의 상기 이전 버전의 성능, 또는 둘 모두를 초과하는 경우, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 AI/ML 모델을 업데이 트하는 단계 를 더 포함하는, 컴퓨터 구현 방법.청구항 6 제1항에 있어서, 미리 결정된 양의 트레이닝 데이터가 수신된 이후, 마지막 재트레이닝 이후 미리 결정된 양의 시간이 경과한 이 후, 또는 둘 모두의 경우에, 상기 컴퓨팅 시스템 상에서 실행되는 상기 디지털 프로세스에 의해, 상기 AI/ML 모 델의 재트레이닝을 자동적으로 개시하는 단계를 더 포함하는, 컴퓨터 구현 방법. 청구항 7 제1항에 있어서, 상기 디지털 프로세스는 비즈니스 프로세스 관리(business process management; BPM) 플로우차트, 순차적 플로 우, 또는 유한 상태 머신(finite state machine; FSM)을 포함하는 것인, 컴퓨터 구현 방법. 청구항 8 제1항에 있어서, 상기 AI/ML 모델은 상기 RPA 워크플로우의 활동에 직접적으로 임베딩되는(embedded) 것인, 컴퓨터 구현 방법. 청구항 9 제1항에 있어서, 상기 디지털 프로세스는, 상기 AI/ML 모델을 스토리지로부터 로딩하거나 또는 상기 AI/ML 모델을 상기 디지털 프로세스에 의해 호출 가능하게 만드는 초기화 상태를 포함하는 것인, 컴퓨터 구현 방법. 청구항 10 디지털 프로세스를 포함하는 컴퓨터 프로그램이 구현되어 있는 비일시적 컴퓨터 판독 가능 기록 매체에 있어서, 상기 프로그램은 적어도 하나의 프로세서로 하여금: 인공 지능(AI)/머신 러닝(ML) 모델에 대한 재트레이닝 요청 또는 업데이트 요청을 청취하게 하도록; 상기 재트레이닝 요청이 수신되어 상기 AI/ML 모델을 재트레이닝하는 경우, 상기 AI/ML 모델의 재트레이닝을 개 시하게 하도록; 그리고 상기 업데이트 요청이 수신되어 상기 AI/ML 모델을 업데이트하는 경우, 상기 AI/ML 모델의 업데이트된 버전을 호출하기 위해 상기 디지털 프로세스를 재초기화 또는 재인스턴스화하고 다른 재트레이닝 요청 또는 업데이트 요청을 청취하게 하도록 구성되고, 상기 AI/ML 모델의 상기 재트레이닝 또는 업데이트는 상기 디지털 프로세스의 런타임 동안 발생하고, 상기 디지털 프로세스는 로봇 프로세스 자동화(RPA) 워크플로우를 포함하고 상기 AI/ML 모델은 상기 RPA 워크플 로우의 활동에 의해 호출되는 것인, 비일시적 컴퓨터 판독 가능 기록 매체. 청구항 11 제10항에 있어서, 상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금: 상기 업데이트 요청이 수신될 때까지 상기 재트레이닝 동안 상기 AI/ML 모델의 현재 버전을 사용하게 하도록 구 성되는 것인, 비일시적 컴퓨터 판독 가능 기록 매체. 청구항 12 제10항에 있어서, 상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금:상기 재트레이닝된 AI/ML 모델의 성능을, 성능 임계치에 대해, 상기 AI/ML 모델의 이전 버전의 성능에 대해, 또 는 둘 모두에 대해 비교하게 하도록; 그리고 상기 재트레이닝된 AI/ML 모델이 상기 성능 임계치, 상기 AI/ML 모델의 상기 이전 버전의 성능, 또는 둘 모두를 초과하는 경우, 상기 AI/ML 모델을 업데이트하게 하도록 구성되는 것인, 비일시적 컴퓨터 판독 가능 기록 매체. 청구항 13 제10항에 있어서, 상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금: 미리 결정된 양의 트레이닝 데이터가 수신된 이후, 마지막 재트레이닝 이후 미리 결정된 양의 시간이 경과한 이 후, 또는 둘 모두의 경우에, 상기 AI/ML 모델의 재트레이닝을 자동적으로 개시하게 하도록 구성되는 것인, 비일 시적 컴퓨터 판독 가능 기록 매체. 청구항 14 제10항에 있어서, 상기 AI/ML 모델은 상기 RPA 워크플로우의 활동에 직접적으로 임베딩되는 것인, 비일시적 컴퓨터 판독 가능 기 록 매체. 청구항 15 컴퓨팅 시스템에 있어서, 디지털 프로세스를 포함하는 컴퓨터 프로그램 명령어를 저장하는 메모리; 및 상기 컴퓨터 프로그램 명령어를 실행하도록 구성되는 적어도 하나의 프로세서를 포함하되, 상기 명령어는 상기 적어도 하나의 프로세서로 하여금: 인공 지능(AI)/머신 러닝(ML) 모델에 대한 재트레이닝 요청을 청취하게 하도록; 그리고 상기 재트레이닝 요청이 수신되어 상기 AI/ML 모델을 재트레이닝하는 경우, 상기 AI/ML 모델의 재트레이닝을 개 시하게 하도록 구성되고, 상기 AI/ML 모델의 상기 재트레이닝은 상기 디지털 프로세스의 런타임 동안 발생하고, 상기 디지털 프로세스는 로봇 프로세스 자동화(RPA) 워크플로우를 포함하고 상기 AI/ML 모델은 상기 RPA 워크플 로우의 활동에 의해 호출되는 것인, 컴퓨팅 시스템. 청구항 16 제15항에 있어서, 상기 명령어는 또한, 상기 적어도 하나의 프로세서로 하여금: 상기 AI/ML 모델에 대한 업데이트 요청을 청취하게 하도록; 그리고 상기 업데이트 요청이 수신되어 상기 AI/ML 모델을 업데이트하는 경우, 상기 컴퓨팅 시스템 상에서 실행되는 상 기 디지털 프로세스에 의해, 상기 AI/ML 모델의 업데이트된 버전을 호출하기 위해 상기 디지털 프로세스를 재초 기화하거나 또는 재인스턴스화하고 다른 업데이트 요청을 청취하게 하도록 구성되고, 상기 AI/ML 모델의 상기 업데이트는 상기 디지털 프로세스의 런타임 동안 발생하는 것인, 컴퓨팅 시스템. 청구항 17 제15항에 있어서,상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금: 업데이트 요청이 수신될 때까지 상기 재트레이닝 동안 상기 AI/ML 모델의 현재 버전을 사용하게 하도록 구성되 는 것인, 컴퓨팅 시스템. 청구항 18 제15항에 있어서, 상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금: 상기 재트레이닝된 AI/ML 모델의 성능을, 성능 임계치에 대해, 상기 AI/ML 모델의 이전 버전의 성능에 대해, 또 는 둘 모두에 대해 비교하게 하도록; 그리고 상기 재트레이닝된 AI/ML 모델이 상기 성능 임계치, 상기 AI/ML 모델의 상기 이전 버전의 성능, 또는 둘 모두를 초과하는 경우, 상기 AI/ML 모델을 업데이트하게 하도록 구성되는 것인, 컴퓨팅 시스템. 청구항 19 제15항에 있어서, 상기 프로그램은 또한, 상기 적어도 하나의 프로세서로 하여금: 미리 결정된 양의 트레이닝 데이터가 수신된 이후, 마지막 재트레이닝 이후 미리 결정된 양의 시간이 경과한 이 후, 또는 둘 모두의 경우에, 상기 AI/ML 모델의 재트레이닝을 자동적으로 개시하게 하도록 구성되는 것인, 컴퓨 팅 시스템. 청구항 20 제15항에 있어서, 상기 AI/ML 모델은 상기 RPA 워크플로우의 활동에 직접적으로 임베딩되는 것인, 컴퓨팅 시스템. 발명의 설명"}
{"patent_id": "10-2020-0103986", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 일반적으로 인공 지능(artificial intelligence; AI)에 관한 것으로, 더 구체적으로, 런타임시 디지 털 프로세스에서 AI/머신 러닝(machine learning; ML) 모델을 동적으로 업데이트, 또는 재트레이닝 및 업데이트 하는 것에 관한 것이다."}
{"patent_id": "10-2020-0103986", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "AI/ML 모델은, 현재, 다양한 타입의 컴퓨팅 시스템 상에서 실행되는 디지털 프로세스의 일부로서 배치된다. 이 들 AI/ML 모델은 분류를 수행할 수도 있고, 예측을 제공할 수도 있고, 데이터 분석을 수행할 수도 있고, 등등을 할 수도 있다. AI/ML 모델은, 도메인 또는 비즈니스 규칙 변경에 기인하여, 더 나은 출력(예를 들면, 예측, 분 류, 등등)을 제공하기 위해, 또는 다른 이유 때문에, 업데이트될 필요가 있을 수도 있거나, 또는 재트레이닝되 고 업데이트될 필요가 있을 수도 있다. 현재, AI/ML 모델 업데이트 프로세스는 시스템 가동 중단 시간 및 스케줄링된 유지 보수 시간을 필요로 한다. 이것은 직원 생산성, 수익 창출, 서비스 가용성, 등등에 영향을 줄 수 있다. 따라서, AI/ML 모델을 업데이트하 는 것에 대한, 그리고 AI/ML 모델을 재트레이닝하고 업데이트하는 것에 대한 향상된 접근법이 유리할 수도 있다. 본 발명의 소정의 실시형태는 현재의 AI 기술에 의해 아직 완전히 식별, 인식, 또는 해결되지 않은 본 기술 분 야에서의 문제점 및 요구에 대한 솔루션을 제공할 수도 있다. 예를 들면, 본 발명의 몇몇 실시형태는 런타임시 디지털 프로세스에서 AI/ML 모델을 동적으로 업데이트하는 것, 또는 재트레이닝하고 업데이트하는 것에 관한 것이다. 한 실시형태에서, 컴퓨터 구현 방법은 컴퓨팅 시스템 상에서 실행되는 디지털 프로세스에 의해 AI/ML 모델에 대 한 업데이트 요청을 청취하는(listen for) 것을 포함한다. 업데이트 요청이 수신되어 AI/ML 모델을 업데이트하 는 경우, 컴퓨터 구현 방법은, 컴퓨팅 시스템 상에서 실행되는 디지털 프로세스에 의해, AI/ML 모델의 업데이트 된 버전을 호출하기 위해 디지털 프로세스를 재초기화하거나(reinitializing) 또는 재인스턴스화하는(re- instantiating) 것 및 다른 업데이트 요청을 청취하는 것을 포함한다. AI/ML 모델의 업데이트는 디지털 프로세 스의 런타임 동안 발생한다. 다른 실시형태에서, 디지털 프로세스를 포함하는 컴퓨터 프로그램은 비일시적 컴퓨터 판독 가능 매체 상에서 구 체화된다. 프로그램은 적어도 하나의 프로세서로 하여금 AI/ML 모델에 대한 재트레이닝 요청 또는 업데이트 요 청을 청취하게 하도록 구성된다. 재트레이닝 요청이 수신되어 AI/ML 모델을 재트레이닝하는 경우, 프로그램은 적어도 하나의 프로세서로 하여금 AI/ML 모델의 재트레이닝을 개시하게 하도록 구성된다. 업데이트 요청이 수신 되어 AI/ML 모델을 업데이트하는 경우, 프로그램은 적어도 하나의 프로세서로 하여금 AI/ML 모델의 업데이트된 버전을 호출하기 위해 디지털 프로세스를 재초기화하거나 또는 재인스턴스화하게 하도록 그리고 다른 재트레이 닝 요청 또는 업데이트 요청을 청취하게 하도록 구성된다. AI/ML 모델의 재트레이닝 또는 업데이트는 디지털 프 로세스의 실행 동안 발생한다. 또 다른 실시형태에서, 컴퓨팅 시스템은 디지털 프로세스를 포함하는 컴퓨터 프로그램 명령어를 저장하는 메모 리 및 컴퓨터 프로그램 명령어를 실행하도록 구성되는 적어도 하나의 프로세서를 포함한다. 명령어는 적어도 하 나의 프로세서로 하여금 AI/ML 모델에 대한 재트레이닝 요청을 청취하게 하도록 구성된다. 재트레이닝 요청이 수신되어 AI/ML 모델을 재트레이닝하는 경우, 명령어는 적어도 하나의 프로세서로 하여금 AI/ML 모델의 재트레 이닝을 개시하게 하도록 구성된다. AI/ML 모델의 재트레이닝은 디지털 프로세스의 런타임 동안 발생한다. 여전히 다른 실시형태에서, AI/ML 모델의 동적 업데이트, 또는 재트레이닝 및 업데이트를 위한 컴퓨터 구현 방 법은, 컴퓨팅 시스템 상에서 실행되는 RPA 디지털 프로세스에 의해, AI/ML 모델에 대한 업데이트 요청을 청취하 는 것을 포함한다. 업데이트 요청이 수신되어 AI/ML 모델을 업데이트하는 경우, 컴퓨터 구현 방법은, 컴퓨팅 시 스템 상에서 실행되는 RPA 디지털 프로세스에 의해, AI/ML 모델의 업데이트된 버전을 호출하기 위해 RPA 디지털 프로세스를 재초기화하거나 또는 재인스턴스화하는 것 및 다른 업데이트 요청을 청취하는 것을 포함한다. AI/ML 모델의 업데이트는 RPA 디지털 프로세스의 런타임 동안 발생한다. RPA 디지털 프로세스는 RPA 워크플로우를 포 함하며 AI/ML 모델은 RPA 워크플로우의 활동에 의해 호출된다."}
{"patent_id": "10-2020-0103986", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "몇몇 실시형태는 런타임시(즉, 소프트웨어가 실행되고 있는 경우 또는 지속되는 동안) 디지털 프로세스에서 AI/ML 모델을 동적으로 업데이트하거나, 또는 재트레이닝 및 업데이트하는 것에 관한 것이다. 그러한 만큼, AI/ML 모델 업데이트 또는 재트레이닝 및 업데이트를 위해 생산 동작은 중단될 필요가 없다. AI/ML 모델에 대한 업데이트 단계 및/또는 재트레이닝 단계는 몇몇 실시형태에서 디지털 프로세스의 일부로서 포함될 수도 있다. 몇몇 실시형태에서, AI/ML 모델 업데이트는, (예를 들면, 조건의 평가로부터의, AI/ML 모델에 대한 그 표현 호 출에 의한, 등등의) 내부 로직, (예를 들면, 파일 변경, 데이터베이스 데이터, 서비스 호출, 등등과 같은, 유한 상태 머신(finite state machine; FSM)에서의 외부 트리거로부터의) 외부 요청, 또는 둘 모두로부터 요청될 수 도 있다. 본원에서 사용되는 바와 같이, 디지털 프로세스는 모든 타입의 소프트웨어 구현 워크플로우(예를 들면, 로봇 프로세스 자동화(RPA), 비즈니스 프로세스 관리(business process management; BPM) 소프트웨어 플 로우차트, 순차적 플로우, FSM, 등등), 애플리케이션, 솔루션, 시스템 서비스, 함수, 메소드, 스크립트, 등등을 포함한다. 디지털 프로세스의 동작 상태는, 설계 시간(예를 들면, 중지, 구성, 재설계, 등등), 런타임(예를 들 면, 실행, 지속, 등등), 등등을 포함하지만, 그러나 이들로 제한되지는 않는다. 애플리케이션은 통상적으로 기능성 관점(functionality perspective)에서 세분화되고 특정한 역할을 서비스하는 어떤 것을 암시한다. 시스템 솔루션은, 특정한 주제를 서비스하는 더 큰 솔루션의 일부일 수 있다(예를 들면, 유저 관리 기능성은 패스워드 재설정, 개인의 타임 오프(time off) 중단 요청, 의료 요청, 직원 온보딩 (employee onboarding), 등등을 가질 수 있음). 애플리케이션은 통상적으로 프론트 엔드 또는 유저 인터페이스 (user interface; UI)를 암시하고, 반면, 시스템 서비스는 일반적으로 백그라운드에서 실행된다. 애플리케이션 의 콜렉션은 솔루션으로서 그룹화될 수도 있고, 반면, 서비스의 콜렉션은 시스템 서비스로서 그룹화될 수도 있 다. 최대 효율성 및 투자 수익률(return of investment; ROI)을 위해, 시스템 및 솔루션이 가능한 한 적은 가동 중 단 시간(downtime)을 가지고 실행되는 것이 바람직할 수도 있다. 현재, 디지털 프로세스에서, AI/ML 모델 업데 이트, 또는 재트레이닝 및 업데이트는, 유지 보수 가동 중단 시간을 필요로 하는데, 가동 중단 시간은 프로세스 를 이용 불가능하게 만든다. 런타임시 디지털 프로세스에 의해 호출되는 AI/ML 모델을 동적으로 업데이트하거나, 또는 재트레이닝 및 업데이트하는 능력은 다양한 이점을 제공한다. 예를 들면, 이들 성능을 활용하는 소프트웨어는, AI/ML 모델을 업데이트하는 것 또는 재트레이닝 및 업데이트하는 것으로부터 유래하는 가 동 중단 시간이 없거나 또는 거의 없을 수도 있다. AI/ML 모델 업데이트 또는 재트레이닝 및 업데이트의 자동화 가 제공될 수도 있는데, 여기서, 소프트웨어는 AI/ML 모델이 이용 가능하게 된 이후(그리고 어쩌면 직후에) 재 트레이닝된 및/또는 업데이트된 AI/ML 모델을 사용하여 재로딩/재초기화/재인스턴스화된다. 본원에서 사용될 때, \"재로딩(reload)\"은, AI/ML 모델 데이터가 그것의 포함 계층(예를 들면, RPA의 경우에서의 활동)에 의해 AI/ML 모델 데이터 저장소(예를 들면, 파일, 메모리, 등등)로부터 AI/ML 모델 데이터가 취해지는 동작이다. \"재초기화\"는, 일부/모든 컴포넌트의 상태가 초기/공지된/소망되는 값으로 재설정되는 일반적인 프로 세스에서의 상태/단계를 가리킨다. \"재인스턴스화\"는 객체 지향 프로그래밍에서의 오브젝트의 생성을 가리키는 데, 여기서, 이 경우에서의 객체는, 런타임시의 애플리케이션, 프로세스, 함수, 등등 내부의 AI/ML 모델이다. 몇몇 실시형태는 AI/ML 모델 재트레이닝/업데이트 프로세스를, 그것이 유저에 의해 실행될 필요가 없도록, 자동 화할 수도 있다. 예를 들면, AI/ML 모델은, 마지막 트레이닝 동작 이후 미리 결정된 양의 시간이 경과한 경우, 미리 결정된 양의 데이터가 수신되는 경우, 이들의 조합의 경우, 등등의 경우에 자동적으로 재트레이닝될 수도 있다. 재트레이닝된 AI/ML 모델의 성능이 기대치를 충족하거나(예를 들면, 90 % 정확도를 달성하거나), 현재 실 행 중인 버전의 성능을 초과하거나, 또는 둘 모두를 충족하는 경우, 재트레이닝된 AI/ML 모델은 유저 상호 작용 없이 자동적으로 배치(즉, 업데이트)될 수도 있다. 로봇 프로세스 자동화(RPA)를 위해 소정의 실시형태가 활용될 수도 있다. 도 1은, 본 발명의 한 실시형태에 따 른, RPA 시스템을 예시하는 아키텍쳐 다이어그램이다. RPA 시스템은 개발자가 워크플로우를 설계 및 구현하는 것을 허용하는 디자이너를 포함한다. 디자이너는 애플리케이션 통합뿐만 아니라, 써드파티 애플리케이션, 관리 정보 기술(IT) 태스크, 및 비즈니스 IT 프로세스를 자동화하기 위한 솔루션을 제공할 수도 있다. 디자이너는 비즈니스 프로세스의 그래픽 표현인 자동화 프로젝트(automation project)의 개발을 용 이하게 할 수도 있다. 간단히 말하면, 디자이너는 워크플로우 및 로봇의 개발 및 배치를 용이하게 한다. 자동화 프로젝트는 개발자에게 실행 순서의 제어 및, 본원에서 \"활동\"으로 정의되는, 워크플로우에서 개발되는 커스텀 세트의 단계 사이의 관계를 제공하는 것에 의해 규칙 기반의 프로세스의 자동화를 가능하게 한다. 디자 이너의 실시형태의 하나의 상업적인 예는 UiPath Studio™이다. 각각의 활동은, 버튼 클릭, 파일 판독, 로 그 패널에 대한 기록, 등등과 같은 액션을 포함할 수도 있다. 몇몇 실시형태에서, 워크플로우는 네스트화되거나 또는 임베딩될 수도 있다. 몇몇 타입의 워크플로우는 시퀀스, 플로우차트, FSM, 및/또는 전역적 예외 핸들러를 포함할 수도 있지만 그러나 이들로 제한되지는 않는다. 시퀀스는 선형 프로세스에 특히 적합할 수도 있어서, 워크플로우를 흩뜨리지 않으면 서 하나의 활동으로부터 다른 활동으로의 흐름을 가능하게 할 수도 있다. 플로우차트는 더욱 복잡한 비즈니스 로직에 특히 적합할 수도 있어서, 다수의 분기 로직 연산자를 통해 의사 결정의 통합 및 활동의 연결을 더욱 다 양한 방식으로 가능하게 할 수도 있다. FSM은 대규모 워크플로우에 특히 적합할 수도 있다. FSM은, 조건(즉, 전 이) 또는 활동에 의해 트리거되는 그들의 실행에서 유한한 수의 상태를 사용할 수도 있다. 전역적 예외 핸들러 는, 실행 에러를 조우하는 경우 워크플로우 거동을 결정하는 데 그리고 프로세스를 디버깅하는 데 특히 적합할 수도 있다. 일단 워크플로우가 디자이너에서 개발되면, 비즈니스 프로세스의 실행은 컨덕터에 의해 편성되는데 (orchestrate), 컨덕터는, 디자이너에서 개발되는 워크플로우를 실행하는 하나 이상의 로봇을 편성한다. 컨덕터의 실시형태의 하나의 상업적인 예는 UiPath Orchestrator™이다. 컨덕터는 한 환경 에서의 리소스의 생성, 모니터링 및 배치의 관리를 용이하게 한다. 컨덕터는 써드파티 솔루션 및 애플리케 이션과의 통합 지점(integration point), 또는 집성 지점(aggregation point) 중 하나로서 작용할 수도 있다. 컨덕터는 일단의(a fleet of) 로봇을 관리할 수도 있어서, 중앙 집중식 지점으로부터 로봇을 연 결하고 실행할 수도 있다. 관리될 수도 있는 로봇의 타입은, 유인 로봇(attended robot; 132), 무인 로봇 (unattended robot; 134), 개발 로봇(무인 로봇과 유사하지만, 그러나 개발 및 테스트 목적을 위해 사용됨), 및 비생산 로봇(nonproduction robot)(유인 로봇과 유사하지만, 그러나 개발 및 테스트 목적을 위해 사용됨)을 포함하지만, 그러나 이들로 제한되지는 않는다. 유인 로봇은 유저 이벤트에 의해 트리거되 고 동일한 컴퓨팅 시스템 상에서 사람 옆에서 동작한다. 유인 로봇은 중앙 집중식 프로세스 배치 및 로깅 매체(logging medium)를 위해 컨덕터와 함께 사용될 수도 있다. 유인 로봇은 인간 유저가 다양한 태 스크를 수행하는 것을 도울 수도 있고, 유저 이벤트에 의해 트리거될 수도 있다. 몇몇 실시형태에서, 프로세스 는 이러한 타입의 로봇 상에서 컨덕터로부터 시작될 수 없고 및/또는 그들은 잠금 화면(locked screen) 하에서 실행될 수 없다. 소정의 실시형태에서, 유인 로봇은 오직 로봇 트레이로부터 또는 커맨드 프롬프트로 부터 시작될 수 있다. 몇몇 실시형태에서, 유인 로봇은 인간의 감독 하에서 실행되어야 한다. 무인 로봇은 가상 환경에서 무인으로(unattended) 실행되며 많은 프로세스를 자동화할 수 있다. 무인 로봇 은 원격 실행, 모니터링, 스케줄링, 및 작업 큐에 대한 지원의 제공을 담당할 수도 있다. 모든 로봇 타입 에 대한 디버깅은 몇몇 실시형태에서 디자이너에서 실행될 수도 있다. 유인 및 무인 로봇 둘 모두는, 메인 프레임, 웹 애플리케이션, VM, 엔터프라이즈 애플리케이션(예를 들면, SAP®, SalesForce®(세일즈포스), Oracle ®(오라클), 등등에 의해 생성되는 애플리케이션), 및 컴퓨팅 시스템 애플리케이션(예를 들면, 데스크탑 및 랩탑 애플리케이션, 모바일 디바이스 애플리케이션, 웨어러블 컴퓨터 애플리케이션, 등등)을 포함하는, 그러나 이들 로 제한되지는 않는 다양한 시스템 및 애플리케이션을 자동화할 수도 있다. 컨덕터는, 프로비저닝(provisioning), 배치, 버저닝(versioning), 구성, 큐잉, 모니터링, 로깅, 및/또는 상호 연결성의 제공을 포함하는 이들로 제한되지는 않는 다양한 성능을 가질 수도 있다. 프로비저닝은 로봇 과 컨덕터(예를 들면, 웹 애플리케이션) 사이의 연결의 생성 및 유지 보수를 포함할 수도 있다. 배치 는 실행을 위한 할당된 로봇에 패키지 버전의 정확한 전달을 보장하는 것을 포함할 수도 있다. 버저닝은 몇몇 실시형태에서 몇몇 프로세스 또는 구성의 고유의 인스턴스의 관리를 포함할 수도 있다. 구성은 로봇 환경 및 프로세스 구성의 유지 보수 및 전달을 포함할 수도 있다. 큐잉은 큐 및 큐 아이템의 관리를 제공하는 것을 포함할 수도 있다. 모니터링은 로봇 식별 데이터를 계속 추적하는 것 및 유저 퍼미션을 유지하는 것을 포함할 수도 있다. 로깅은 데이터베이스(예를 들면, SQL 데이터베이스) 및/또는 다른 스토리지 메커니즘(예를 들면, 대 규모 데이터세트를 저장하고 빠르게 조회하는 능력을 제공하는 ElasticSearch®)에 로그를 저장하고 인덱싱하는 것을 포함할 수도 있다. 컨덕터는 써드파티 솔루션 및/또는 애플리케이션에 대한 통신의 중앙 집중식 지점 으로서 작용하는 것에 의해 상호 연결성을 제공할 수도 있다. 로봇은 디자이너에 내장되는 워크플로우를 실행하는 실행 에이전트이다. 로봇(들)의 몇몇 실시 형태의 하나의 상업적인 예는 UiPath Robots™이다. 몇몇 실시형태에서, 로봇은, 디폴트로, Microsoft Windows®(마이크로소프트 윈도우즈) 서비스 제어 관리자(Service Control Manager; SCM) 관리 서비스를 설치한 다. 결과적으로, 그러한 로봇은 로컬 시스템 계정 하에서 상호 작용식 Windows®(윈도우즈) 세션을 열 수도 있고, Windows® 서비스의 권한을 가질 수 있다. 몇몇 실시형태에서, 로봇은 유저 모드에서 설치될 수 있다. 그러한 로봇의 경우, 이것은, 그들이 주 어진 로봇이 설치되었던 유저와 동일한 권리를 갖는다는 것을 의미한다. 이 피쳐는 고밀도(High Density; HD) 로봇에 대해서도 또한 이용 가능할 수도 있는데, 이 피쳐는 각각의 머신의 최대 전원에서 각각의 머신의 완 전한 활용을 보장한다. 몇몇 실시형태에서, 임의의 타입의 로봇은 HD 환경에서 구성될 수도 있다. 몇몇 실시형태에서 로봇은 여러 가지 컴포넌트로 분할되는데, 각각은 특정한 자동화 태스크에 전용된다. 몇몇 실시형태에서 로봇 컴포넌트는, SCM 관리 로봇 서비스, 유저 모드 로봇 서비스, 실행기(executor), 에이전 트, 및 커맨드 라인을 포함하지만 그러나 이들로 제한되지는 않는다. SCM 관리 로봇 서비스는 Windows® 세션을 관리 및 모니터링하고 컨덕터와 실행 호스트(즉, 로봇이 실행되는 컴퓨팅 시스템) 사이의 프록시 역 할을 한다. 이들 서비스는 로봇에 대한 자격 증명(credential)을 사용하여 신뢰되고 그 자격 증명을 관리 한다. 콘솔 애플리케이션은 로컬 시스템 하에서 SCM에 의해 론칭된다. 몇몇 실시형태에서 유저 모드 로봇 서비스는 Windows® 세션을 관리 및 모니터링하고 컨덕터와 실행 호스트 사이의 프록시로서 역할을 한다. 유저 모드 로봇 서비스는 로봇에 대한 자격 증명을 사용하여 신뢰될 수도 있고 그 자격 증명을 관리할 수도 있다. SCM 관리 로봇 서비스가 설치되지 않은 경우 Windows® 애플리케이션이 자동적으로 론칭될 수도 있다. 실행기는 Windows® 세션 하에서 주어진 작업을 실행할 수도 있다(즉, 그들은 워크플로우를 실행할 수도 있다). 실행기는 모니터당 인치당 도트(dots per inch; DPI) 설정을 알고 있을 수도 있다. 에이전트는 시스템 트레이 윈도우(system tray window)에서 이용 가능한 작업을 디스플레이하는 Windows® 프리젠테이션 파운데이션 (Windows® Presentation Foundation; WPF) 애플리케이션일 수도 있다. 에이전트는 서비스의 클라이언트일 수도있다. 에이전트는 작업을 시작 또는 중지할 것을 그리고 설정을 변경할 것을 요청할 수도 있다. 커맨드 라인은 서비스의 클라이언트이다. 커맨드 라인은, 작업을 시작할 것을 요청할 수 있고 그들의 출력을 대기하는 콘솔 애 플리케이션이다. 상기에서 설명되는 바와 같이 로봇의 컴포넌트를 분할하는 것은, 개발자가 유저를 지원하는 것, 및 컴퓨팅 시스템이 각각의 컴포넌트가 실행하고 있는 것을 더욱 쉽게 실행하고, 식별하고 추적하는 것을 돕는다. 실행기 및 서비스에 대해 상이한 방화벽 규칙을 셋업하는 것과 같은 방식으로, 컴포넌트별로 특수한 거동이 구성될 수 도 있다. 실행기는 몇몇 실시형태에서 모니터당 DPI 설정을 항상 인식할 수도 있다. 결과적으로, 워크플로우는, 그들이 생성되었던 컴퓨팅 시스템의 구성에 관계없이, 임의의 DPI에서 실행될 수도 있다. 디자이너로부터 의 프로젝트는 또한, 몇몇 실시형태에서, 브라우저 줌 레벨과 무관할 수도 있다. DPI를 알지 못하는 또는 알지 못하는 것으로 의도적으로 마킹되는 애플리케이션의 경우, 몇몇 실시형태에서, DPI는 디스에이블될 수도 있다. 도 2는, 본 발명의 한 실시형태에 따른, 배치된 RPA 시스템을 예시하는 아키텍쳐 다이어그램이다. 몇몇 실 시형태에서, RPA 시스템은 도 1의 RPA 시스템일 수도 있거나 또는 그 일부일 수도 있다. 클라이언트 측, 서버 측, 또는 둘 모두는 본 발명의 범위를 벗어나지 않으면서 임의의 소망되는 수의 컴퓨팅 시스템을 포함 할 수도 있다는 것을 유의해야 한다. 클라이언트 측에서, 로봇 애플리케이션은 실행기, 에이전트 , 및 디자이너를 포함한다. 그러나, 몇몇 실시형태에서, 디자이너는 컴퓨팅 시스템 상에서 실행되고 있지 않을 수도 있다. 실행기는 프로세스를 실행하고 있다. 도 2에서 도시되는 바와 같이, 여러 비즈니스 프로젝트가 동시에 실행될 수도 있다. 에이전트(예를 들면, Windows® 서비스)는 이 실시형태에서 모든 실행기에 대한 단일의 접촉 지점이다. 이 실시형태의 모든 메시지는 컨덕터에 로그인되는데, 컨 덕터는 데이터베이스 서버, 인덱서 서버(indexer server) 또는 둘 모두를 통해 그들을 추가로 프로세싱한다. 도 1과 관련하여 상기에서 논의되는 바와 같이, 실행기는 로봇 컴포넌트일 수도 있다. 몇몇 실시형태에서, 로봇은 머신 이름과 유저명 사이의 관련화(association)를 나타낸다. 로봇은 동시에 다수의 실행기를 관리할 수도 있다. 동시에 실행되는 다수의 상호 작용식 세션을 지원하는 컴퓨팅 시스템(예를 들면, Windows® Server(윈도우즈 서버) 2012) 상에서, 다수의 로봇이 동시에 실행될 수도 있는데, 각각은 고유의 유저 명을 사용하여 별개의 Windows® 세션 내에 있다. 이것은 상기에서 HD 로봇으로 지칭된다. 에이전트는 또한, 로봇의 상태를 전송하는 것(예를 들면, 로봇이 여전히 기능하고 있다는 것을 나타내는 \"하트비트(heartbeat)\" 메시지를 주기적으로 전송함) 및 실행될 패키지의 필요한 버전을 다운로드하는 것을 담 당한다. 에이전트와 컨덕터 사이의 통신은 몇몇 실시형태에서 에이전트에 의해 항상 개시된다. 통지 시나리오에서, 에이전트는, 커맨드를 로봇으로 전송하기 위해(예를 들면, 시작, 정지, 등등) 컨덕터 에 의해 나중에 사용되는 WebSocket(웹소켓) 채널을 개방할 수도 있다. 서버 측 상에서, 프리젠테이션 계층(웹 애플리케이션, 개방 데이터 프로토콜(Open Data Protocol; OData) 대표 상태 전송(Representative State Transfer; REST) 애플리케이션 프로그래밍 인터페이스(Application Programming Interface; API) 엔드포인트, 및 통지 및 모니터링), 서비스 계층(API 구현/비즈니스 로직), 및 퍼시스턴스 계층(persistence layer)(데이터베이스 서버 및 인덱서 서버)이 포함된 다. 컨덕터는 웹 애플리케이션, OData REST API 엔드포인트, 통지 및 모니터링, 및 API 구현/비즈니스 로직을 포함한다. 몇몇 실시형태에서, 유저가 컨덕터의 인터페이스에서 (예를 들면, 브라우저를 통해) 수행하는 대부분의 액션은 다양한 API를 호출하는 것에 의해 수행된다. 그러한 액션은, 본 발명의 범위를 벗어나지 않으면서, 로봇 상에서 작업을 시작하는 것, 큐에서 데이터를 추가/제거하는 것, 무 인으로 실행할 작업을 스케줄링하는 것, 등등을 포함할 수도 있지만, 그러나, 이들로 제한되지는 않는다. 웹 애 플리케이션은 서버 플랫폼의 시각적 계층(visual layer)이다. 이 실시형태에서, 웹 애플리케이션은 하이퍼텍스트 마크업 언어(Hypertext Markup Language; HTML) 및 JavaScript(자바스크립트)(JS)를 사용한다. 그러나, 본 발명의 범위를 벗어나지 않으면서, 임의의 소망되는 마크업 언어, 스크립트 언어, 또는 임의의 다른 포맷이 사용될 수도 있다. 유저는, 컨덕터를 제어하기 위한 다양한 액션을 수행하기 위해, 이 실시형태에 서 브라우저를 통해 웹 애플리케이션으로부터의 웹 페이지와 상호 작용한다. 예를 들면, 유저는 로봇 그룹을 생성할 수도 있고, 로봇에 패키지를 할당할 수도 있고, 로봇마다 및/또는 프로세스마다 로그를 분석할 수도 있고, 로봇을 시작 및 중지할 수도 있고, 등등을 할 수도 있다. 웹 애플리케이션 외에, 컨덕터는 또한, OData REST API 엔드포인트를 노출시키는 서비스 계층을 포함한다. 그러나, 본 발명의 범위를 벗어나지 않으면서 다른 엔드포인트가 포함될 수도 있다. REST API는 웹애플리케이션 및 에이전트 둘 모두에 의해 소비된다. 에이전트는 이 실시형태에서 클라이언트 컴퓨터 상의 하나 이상의 로봇의 감독자(supervisor)이다. 이 실시형태에서의 REST API는 구성, 로깅, 모니터링 및 큐잉 기능성을 포괄한다. 구성 엔드포인트는, 몇몇 실 시형태에서, 애플리케이션 유저, 퍼미션, 로봇, 자산, 릴리스, 및 환경을 정의하고 구성하기 위해 사용될 수도 있다. 로깅 REST 엔드포인트는, 예를 들면, 에러, 로봇에 의해 전송되는 명시적 메시지, 및 다른 환경 고유의 정보와 같은 상이한 정보를 로깅하기 위해 사용될 수도 있다. 배치 REST 엔드포인트는, 작업 시작 커맨드가 컨 덕터에서 사용되는 경우 실행되어야 하는 패키지 버전을 조회하기 위해 로봇에 의해 사용될 수도 있다. 큐 잉 REST 엔드포인트는, 큐 및 큐 아이템 관리, 예컨대 데이터를 큐에 추가하는 것, 큐로부터 트랜잭션을 획득하 는 것, 트랜잭션의 상태를 설정하는 것, 등등을 담당할 수도 있다. REST 엔드포인트를 모니터링하는 것은 웹 애플리케이션 및 에이전트를 모니터링할 수도 있다. 통지 및 모니터링 API는, 에이전트를 등록하기 위해, 구성 설정을 에이전트에 전달하기 위해, 그리고 서버 및 에이전트로부터의 통지를 전송/수신하기 위해 사용되는 REST 엔드포인트일 수도 있다. 통지 및 모 니터링 API는 또한, 몇몇 실시형태에서, WebSocket 통신을 사용할 수도 있다. 퍼시스턴스 계층은 이 실시형태에서 한 쌍의 서버 - 데이터베이스 서버(예를 들면, SQL 서버) 및 인덱서 서버 - 를 포함한다. 이 실시형태에서의 데이터베이스 서버는 로봇, 로봇 그룹, 관련된 프로세스, 유 저, 역할, 스케줄, 등등의 구성을 저장한다. 이 정보는 몇몇 실시형태에서 웹 애플리케이션을 통해 관리된 다. 데이터베이스 서버는 큐 및 큐 아이템을 관리할 수도 있다. 몇몇 실시형태에서, 데이터베이스 서버 는 (인덱서 서버에 추가하여 또는 그것을 대신하여) 로봇에 의해 로깅되는 메시지를 저장할 수도 있 다. 몇몇 실시형태에서 옵션 사항인(optional) 인덱서 서버는 로봇에 의해 로깅되는 정보를 저장 및 인덱싱한 다. 소정의 실시형태에서, 인덱서 서버는 구성 설정을 통해 디스에이블될 수도 있다. 몇몇 실시형태에서, 인덱서 서버는 오픈 소스 프로젝트 풀텍스트 검색 엔진(open source project full-text search engine)인 ElasticSearch®를 사용한다. (예를 들면, 메시지 로깅(log message) 또는 라인 기록(write line)과 같은 활동 을 사용하여) 로봇에 의해 로깅되는 메시지는 로깅 REST 엔드포인트(들)를 통해 인덱서 서버로 전송될 수 도 있는데, 여기서 그들은 미래의 활용을 위해 인덱싱된다. 도 3은, 본 발명의 한 실시형태에 따른, 디자이너, 활동(320, 330), 및 드라이버 사이의 관계를 예시하는 아키텍쳐 다이어그램이다. 상기에 따르면, 개발자는 디자이너를 사용하여 로봇에 의해 실행되는 워크플로우를 개발한다. 워크플로우는 유저 정의 활동 및 UI 자동화 활동을 포함할 수도 있다. 몇몇 실시형태는, 본원에서 컴퓨터 비전(computer vision; CV)으로 지칭되는 이미지에서 텍스트가 아닌 시각적 컴포 넌트를 식별할 수 있다. 그러한 컴포넌트와 관련되는 몇몇 CV 활동은, 클릭, 타이핑(type), 텍스트 가져오기 (get text), 호버링(hover), 엘리먼트 존재, 새로고침 범위, 하이라이트, 등등을 포함할 수도 있지만, 그러나 이들로 제한되지는 않는다. 몇몇 실시형태에서의 클릭은, 예를 들면, CV, 광학 문자 인식(optical character recognition; OCR), 퍼지 텍스트 매칭, 및 멀티 앵커를 사용하여 엘리먼트를 식별하고, 그것을 클릭한다. 타이 핑은 상기의 것을 사용하여 엘리먼트를 식별할 수도 있고 그 엘리먼트에서 타이핑한다. 텍스트 가져오기는 특정 한 텍스트의 위치를 식별하고 OCR을 사용하여 그것을 스캔할 수도 있다. 호버링은 엘리먼트를 식별하고 그 위에 서 호버링할 수도 있다. 엘리먼트 존재는 상기에서 설명되는 기술을 사용하여 화면 상에 엘리먼트가 존재하는지 의 여부를 체크할 수도 있다. 몇몇 실시형태에서, 디자이너에서 구현될 수 있는 수 백 또는 심지어 수 천 개의 활동이 있을 수도 있다. 그러나, 본 발명의 범위를 벗어나지 않으면서 임의의 수 및/또는 타입의 활동이 이용 가능할 수도 있다. UI 자동화 활동은, 하위 레벨 코드로 작성되는 특수한 하위 레벨 활동(예를 들면, CV 활동)의 서브세트이 며 화면과의 상호 작용을 용이한다. UI 자동화 활동은, 로봇이 소망되는 소프트웨어와 상호 작용하는 것을 허용하는 드라이버를 통해 이들 상호 작용을 용이하게 한다. 예를 들면, 드라이버는 OS 드라이버 , 브라우저 드라이버, VM 드라이버, 엔터프라이즈 애플리케이션 드라이버, 등등을 포함할 수도 있다. 드라이버는 후크를 찾는, 키를 모니터링하는, 등등을 하는 낮은 레벨에서 OS와 상호 작용할 수도 있다. 그 들은 Chrome®, IE®, Citrix®, SAP®, 등등과의 통합을 용이하게 할 수도 있다. 예를 들면, \"클릭\" 활동은 드라 이버를 통해 이들 상이한 애플리케이션에서 동일한 역할을 수행한다.도 4는, 본 발명의 한 실시형태에 따른, RPA 시스템을 예시하는 아키텍쳐 다이어그램이다. 몇몇 실시형태 에서, RPA 시스템은 도 1 및/또는 도 2의 RPA 시스템(100 및/또는 200)일 수도 있거나 또는 그들을 포함할 수도 있다. RPA 시스템은 로봇을 실행하는 다수의 클라이언트 컴퓨팅 시스템을 포함한다. 컴퓨팅 시 스템은 컨덕터 컴퓨팅 시스템과 그 상에서 실행되는 웹 애플리케이션을 통해 통신할 수 있다. 컨덕터 컴퓨팅 시스템은, 결국에는, 데이터베이스 서버 및 옵션 사항인 인덱서 서버와 통신할 수 있다. 도 1 및 도 3과 관련하여, 웹 애플리케이션이 이들 실시형태에서 사용되는 동안, 본 발명의 범위를 벗어나지 않 으면서 임의의 적절한 클라이언트/서버 소프트웨어가 사용될 수도 있다는 것을 유의해야 한다. 예를 들면, 컨덕 터는 클라이언트 컴퓨팅 시스템 상의 웹 기반이 아닌 클라이언트 소프트웨어 애플리케이션과 통신하는 서버 측 애플리케이션을 실행할 수도 있다. 도 5는, 본 발명의 한 실시형태에 따른, 런타임시 AI/ML 모델을 동적으로 업데이트하도록, 또는 재트레이닝 및 업데이트하도록 구성되는 컴퓨팅 시스템을 예시하는 아키텍쳐 다이어그램이다. 몇몇 실시형태에서, 컴퓨팅 시스템은 본원에서 묘사되는 및/또는 설명되는 컴퓨팅 시스템 중 하나 이상일 수도 있다. 컴퓨팅 시스템 은 정보를 전달하기 위한 버스 또는 다른 통신 메커니즘, 및 정보를 프로세싱하기 위한 버스에 커플링되는 프로세서(들)를 포함한다. 프로세서(들)는 중앙 프로세싱 유닛(Central Processing Unit; CPU), 주문형 집적 회로(Application Specific Integrated Circuit; ASIC), 필드 프로그래머블 게이트 어레이(Field Programmable Gate Array; FPGA), 그래픽 프로세싱 유닛(Graphics Processing Unit; GPU), 이들 의 다수의 인스턴스, 및/또는 이들의 임의의 조합을 비롯한, 임의의 타입의 범용 또는 특수 목적의 프로세서일 수도 있다. 프로세서(들)는 또한 다수의 프로세싱 코어를 가질 수도 있고, 코어 중 적어도 일부는 특수 기 능을 수행하도록 구성될 수도 있다. 몇몇 실시형태에서, 다중 병렬 프로세싱이 사용될 수도 있다. 소정의 실시 형태에서, 프로세서(들) 중 적어도 하나는 생물학적 뉴런을 모방하는 프로세싱 엘리먼트를 포함하는 뉴로 모픽 회로(neuromorphic circuit)일 수도 있다. 몇몇 실시형태에서, 뉴로모픽 회로는 폰 노이만(Von Neumann) 컴퓨팅 아키텍쳐의 통상적인 컴포넌트를 요구하지 않을 수도 있다. 컴퓨팅 시스템은 프로세서(들)에 의해 실행될 정보 및 명령어를 저장하기 위한 메모리를 더 포 함한다. 메모리는 랜덤 액세스 메모리(Random Access Memory; RAM), 리드 온리 메모리(Read Only Memory; ROM), 플래시 메모리, 캐시, 자기 또는 광학 디스크와 같은 정적 스토리지, 또는 임의의 다른 타입의 비일시적 컴퓨터 판독 가능 매체 또는 이들의 조합의 임의의 조합으로 구성될 수 있다. 비일시적 컴퓨터 판독 가능 매체 는 프로세서(들)에 의해 액세스될 수 있는 임의의 이용 가능한 매체일 수도 있고, 휘발성 매체, 불휘발성 매체, 또는 둘 모두를 포함할 수도 있다. 매체는 또한 착탈식일 수도 있거나, 비착탈식일 수도 있거나, 또는 둘 모두일 수도 있다. 추가적으로, 컴퓨팅 시스템은, 무선 및/또는 유선 연결을 통해 통신 네트워크에 대한 액세스를 제공하기 위해, 트랜스시버와 같은 통신 디바이스를 포함한다. 몇몇 실시형태에서, 통신 디바이스는, 주파수 분할 다중 액세스(Frequency Division Multiple Access; FDMA), 싱글 캐리어 FDMA(Single Carrier FDM; SC- FDMA), 시분할 다중 액세스(Time Division Multiple Access; TDMA), 코드 분할 다중 액세스(Code Division Multiple Access; CDMA), 직교 주파수 분할 멀티플렉싱(Orthogonal Frequency Division Multiplexing; OFDM), 직교 주파수 분할 다중 액세스(Orthogonal Frequency Division Multiple Access; OFDMA), 이동 통신용 글로벌 시스템(Global System for Mobile communications; GSM), 일반 패킷 무선 서비스(General Packet Radio Service; GPRS), 범용 이동 통신 시스템(Universal Mobile Telecommunications System; UMTS), cdma2000, 광대 역 CDMA(Wideband CDMA; W-CDMA), 고속 다운링크 패킷 액세스(High-Speed Downlink Packet Access; HSDPA), 고 속 업링크 패킷 액세스(High-Speed Uplink Packet Access; HSUPA), 고속 패킷 액세스(High-Speed Packet Access; HSPA), 롱 텀 에볼루션(Long Term Evolution; LTE), LTE 어드밴스드(LTE Advanced; LTE-A), 802.11x, Wi-Fi(와이파이), Zigbee(지그비), 초광대역(Ultra-WideBand; UWB), 802.16x, 802.15, 홈 Node-B(Home Node-B; HnB), Bluetooth(블루투스), 무선 주파수 식별(Radio Frequency Identification; RFID), 적외선 데이터 연합 (Infrared Data Association; IrDA), 근접장 통신(Near-Field Communications; NFC), 5 세대(5G), 뉴 라디오 (New Radio; NR), 이들의 임의의 조합, 및/또는 본 발명의 범위를 벗어나지 않으면서 임의의 다른 현재 존재하 는 또는 미래에 구현될 통신 표준 및/또는 프로토콜을 사용하도록 구성될 수도 있다. 몇몇 실시형태에서, 통신 디바이스는 본 발명의 범위를 벗어나지 않으면서 단일(singular), 배열(arrayed), 위상(phased), 스위치 (switched), 빔포밍(beamforming), 빔조향(beamsteering), 이들의 조합 및 또는 임의의 다른 안테나 구성인 하 나 이상의 안테나를 포함할 수도 있다. 프로세서(들)는, 버스를 통해, 플라즈마 디스플레이, 액정 디스플레이(Liquid Crystal Display; LCD), 발광 다이오드(Light Emitting Diode; LED) 디스플레이, 전계 방출 디스플레이(Field Emission Display; FED), 유기 발광 다이오드(Organic Light Emitting Diode; OLED) 디스플레이, 플렉시블 OLED 디스플레이, 플렉 시블 기판 디스플레이, 프로젝션 디스플레이, 4K 디스플레이, 고선명 디스플레이, Retina®(레티나) 디스플레이, 인 플레인 스위칭(In-Plane Switching; IPS) 디스플레이, 또는 정보를 유저에게 디스플레이하기 위한 임의의 다 른 적절한 디스플레이와 같은 디스플레이에 추가로 커플링된다. 디스플레이 는, 저항성, 용량성, 표 면 탄성파(surface-acoustic wave; SAW) 용량성, 적외선, 광학 이미징, 분산 신호 기술, 음향 펄스 인식, 불완 전 내부 전반사(frustrated total internal reflection), 등등을 사용하여 터치(햅틱) 디스플레이, 삼차원 (three dimensional; 3D) 터치 디스플레이, 멀티 입력 터치 디스플레이, 멀티 터치 디스플레이, 등등으로서 구 성될 수도 있다. 임의의 적절한 디스플레이 디바이스 및 햅틱 I/O가 본 발명의 범위를 벗어나지 않으면서 사용 될 수도 있다. 키보드 및 커서 제어 디바이스, 예컨대 컴퓨터 마우스, 터치패드, 등등은 유저가 컴퓨팅 시스템(50 0)과 인터페이싱하는 것을 가능하게 하기 위해 버스에 추가로 커플링된다. 그러나, 소정의 실시형태에서, 물리적 키보드 및 마우스가 존재하지 않을 수도 있고, 유저는 디스플레이 및/또는 터치패드(도시되지 않음)를 통해서만 디바이스와 상호 작용할 수도 있다. 입력 디바이스의 임의의 타입 및 조합이 설계 선택의 문 제로서 사용될 수도 있다. 소정의 실시형태에서, 어떠한 물리적 입력 디바이스 및/또는 디스플레이도 존재하지 않는다. 예를 들면, 유저는 컴퓨팅 시스템과 통신하는 다른 컴퓨팅 시스템을 통해 컴퓨팅 시스템과 원격으로 상호 작용할 수도 있거나, 또는 컴퓨팅 시스템은 자율적으로 동작할 수도 있다. 메모리는 프로세서(들)에 의해 실행될 때 기능성을 제공하는 소프트웨어 모듈을 저장한다. 모듈은 컴 퓨팅 시스템을 위한 오퍼레이팅 시스템을 포함한다. 모듈은 본원에서 설명되는 프로세스 또는 그 파 생물의 모두 또는 일부를 수행하도록 구성되는 AI/ML 모델 재트레이닝/업데이트 모듈을 더 포함한다. 컴퓨 팅 시스템은, 추가적인 기능성을 포함하는 하나 이상의 추가적인 기능 모듈을 포함할 수도 있다. 기술 분야의 숙련된 자는, \"시스템\"이, 본 발명의 범위를 벗어나지 않으면서, 서버, 임베딩된 컴퓨팅 시스템, 퍼스널 컴퓨터, 콘솔, 개인 휴대형 정보 단말(personal digital assistant; PDA), 셀 폰, 태블릿 컴퓨팅 디바 이스, 양자 컴퓨팅 시스템, 또는 임의의 다른 적절한 컴퓨팅 디바이스, 또는 디바이스의 조합으로서 구현될 수 도 있다는 것을 인식할 것이다. \"시스템\"에 의해 수행되는 것으로 상기에서 설명된 기능을 제시하는 것은, 어떠 한 방식으로든 본 발명의 범위를 제한하도록 의도되는 것이 아니라, 본 발명의 많은 실시형태의 하나의 예를 제 공하도록 의도된다. 실제로, 본원에서 개시되는 방법, 시스템, 및 장치는, 클라우드 컴퓨팅 시스템을 비롯하여, 컴퓨팅 기술과 일치하는 국소화되고 분산된 형태로 구현될 수도 있다. 본 명세서에서 설명되는 시스템 피쳐 중 일부는, 그들의 구현 독립성을 특히 강조하기 위해, 모듈로서 제시되었 다는 것을 유의해야 한다. 예를 들면, 모듈은 주문형(custom) 대규모 집적(very large scale integration; VLSI) 회로 또는 게이트 어레이, 로직 칩과 같은 기성의(off-the-shelf) 반도체, 트랜지스터, 또는 다른 별개의 컴포넌트를 포함하는 하드웨어 회로로서 구현될 수도 있다. 모듈은 또한, 필드 프로그래머블 게이트 어레이, 프 로그래머블 어레이 로직, 프로그래머블 로직 디바이스, 그래픽 프로세싱 유닛, 또는 등등과 같은 프로그래머블 하드웨어 디바이스에서 구현될 수도 있다. 모듈은 또한 다양한 타입의 프로세서에 의한 실행을 위해 소프트웨어로 적어도 부분적으로 구현될 수도 있다. 실행 가능 코드의 식별된 단위는, 예를 들면, 객체, 프로시져, 또는 함수로서 편제될 수도 있는, 예를 들면, 컴 퓨터 명령어의 하나 이상의 물리적 또는 논리적 블록을 포함할 수도 있다. 그럼에도 불구하고, 식별된 모듈의 실행 파일은 물리적으로 함께 위치될 필요는 없지만, 그러나 논리적으로 함께 결합될 때, 모듈을 포함하며 모듈 에 대한 지정된 목적을 달성하는 상이한 위치에 저장된 별개의 명령어를 포함할 수도 있다. 게다가, 모듈은, 예 를 들면, 하드 디스크 드라이브, 플래시 디바이스, RAM, 테이프, 및/또는 본 발명의 범위를 벗어나지 않으면서 데이터를 저장하기 위해 사용되는 임의의 다른 그러한 비일시적 컴퓨터 판독 가능 매체일 수도 있는 컴퓨터 판 독 가능 매체 상에 저장될 수도 있다. 실제로, 실행 가능 코드의 모듈은 단일의 명령어, 또는 다수의 명령어일 수 있으며, 심지어 몇몇 상이한 코드 세그먼트에 걸쳐, 상이한 프로그램 사이에서, 그리고 몇몇 메모리 디바이스에 걸쳐 분산될 수도 있다. 유사하게, 동작 데이터는 본원에서 모듈 내에서 식별되고 예시될 수도 있으며, 임의의 적절한 형태로 구체화되 고 임의의 적절한 타입의 데이터 구조 내에서 편제될 수도 있다. 동작 데이터는 단일의 데이터 세트로서 수집될 수도 있거나, 또는 상이한 저장 디바이스에 걸치는 것을 비롯하여 상이한 위치에 걸쳐 분산될 수도 있으며, 적 어도 부분적으로는, 단지, 시스템 또는 네트워크 상의 전자 신호로서 존재할 수도 있다.RPA의 맥락에서, AI/ML 모델은, 예를 들면, 항력 앤 드랍(drag-and-drop) 기능성을 사용하여 RPA 워크플로우에 통합될 수도 있는 활동의 일부로서 이용 가능할 수도 있다. 활동은 소망되는 타입의 하나 이상의 입력 인수를 포함할 수도 있고 소망되는 타입의 하나 이상의 출력을 반환할 수도 있다. AI/ML 모델은 활동에 직접적으로 임 베딩될 수도 있거나 또는 외부 소스로부터 로딩/실행될 수 있거나 또는 호출/실행될 수 있다. 예를 들면, AI/ML 모델은 영구적 메모리의 로컬 또는 원격 파일로부터, 서비스로부터, 로컬 또는 원격 데이터베이스로부터, 스트 림으로부터, 비영구적 메모리(예를 들면, RAM, 프로세서 캐시, 등등)로부터, 등등으로부터 로딩/실행 또는 호출 /실행될 수 있다. 예를 들면, AI/ML 모델이 ML.NET으로 트레이닝된 경우, AI/ML 모델은 런타임시 외부 .zip 파 일로부터 로딩될 수도 있고, 그 다음, 초기화/인스턴스화될 수도 있다. AI/ML 모델이 로컬 컴퓨팅 시스템에 저장되지 않는 구현예에서, AI/ML 모델은 컴퓨팅 시스템(이것은 몇몇 실시 형태에서 그 자체가 서버일 수도 있음)에 의해 액세스 가능한 사이트 상의 서버(on-site server), 상이한 사이 트에 있는 원격 서버(예를 들면, 서버 팜), 클라우드 스토리지 솔루션, 등등 상에 저장될 수도 있고 이들에 의 해 제공되거나 또는 실행될 수도 있다. AI/ML 모델은 파일로부터, (예를 들면, SQL을 통해) 데이터베이스로부터, 서비스로부터, 범용 리소스 로케이터(universal resource locator; URL)로부터, 파일 전송 프로토콜(file transfer protocol; FTP)로부터, 스트림으로부터, 또는 본 발명의 범위를 벗어나지 않으면서 임 의의 다른 적절한 메커니즘을 통해 실행될 수도 있다. 실제로, AI/ML 모델이 본 발명의 범위를 벗어나지 않으면 서 로컬 컴퓨팅 시스템에 의해 로딩/실행될 수 있는 또는 호출/실행될 수 있는 임의의 아키텍쳐/구성. 이것은 또한 비 RPA 실시형태를 갖는 경우일 수도 있다. RPA 구현 비제한적인 예로서, 고객으로부터 수신되는 코멘트의 감정을 모니터링하는 서비스로서 실행되는 RPA 워크플로우 를 고려하는데, 여기서 워크플로우는 FSM으로서 구현된다. 워크플로우는, 고객 코멘트를 포함하는 새 파일에 대 한 폴더를 모니터링할 수도 있고 코멘트에서의 감정이 긍정적인지 또는 부정인지의 여부를 나타낼 수도 있다. 도 6은, 본 발명의 한 실시형태에 따른, 런타임시 AI/ML 모델을 동적으로 업데이트하도록, 또는 재트레이닝 및 업데이트하도록 구성되는 FSM의 흐름도의 스크린샷이다. FSM은 UiPath Studio™에서 나타내어진다. 관련된 AI/ML 활동이 AI/ML 모델을 호출하는 경우, 초기화 상태는 외부 파일로부터 AI/ML 모델을 로딩하고 그것을 메모리에서 FSM이 액세스 가능한 변수로 유지한다. 초기화 상태의 시퀀스 및 청취 상태로의 전이의 또 다른 세부 사항은 도 7a 및 도 7b에서 도시되어 있다. 초기화 상태의 상태는 710에서 \"init\"에 할당된다. 초기화 상태는 이 실시형태에서 AI/ML 모델, 변수 및 데이터가 로딩/초기화/인스턴스화되는 FSM의 로직의 영역이다. 그 다음, 720에서, AI/ML 모델이 로딩되고 있다는 것을 유저에게 통지하는 텍스트 가 출력된다. 730에서, 변수 AI_Model_InMemo가 새로운 메모리 스트림으로 생성된다. 이 변수는 FSM에 의 한 사용을 위해 AI/ML 모델을 RAM에 저장할 것이다. 그러나, 상기에 따라, AI/ML 모델은 본 발명의 범위를 벗어 나지 않으면서 임의의 저장 위치(들)로부터 로딩 및/또는 호출될 수도 있다. 그 다음, 740에서, 로컬 디스크로부터 AI/ML 모델을 로딩하고 그것을 RAM에 복사하는 방법이 호출된다. 도 7b의 관련된 속성을 또한 참조한다. 750에서, fileStream이 AI/ML 모델에 할당되고 760에서 fileStream은 복사 동작을 수행한다. 도 7b의 관련된 속성을 또한 참조한다. 초기화 상태의 변수가 도 7b에서 도시 되어 있다. fileStream 변수는 데이터 저장소로부터 로딩된 AI/ML 모델을 나타내는 데이터를 유지한다. 로컬 디스크의 경우, 이 변수로부터, 활동이 인스턴스화될 때 활동은 AI/ML 모델을 로딩한다(활동 객체 인스턴스화/생성에서, 코드의 초기화 섹션에서, AI/ML 모델은 외부 변수로부터 로딩되며, 이 경우에서는 텍스트 파라미터인 입력을 프 로세싱하기 위해 실제로 사용되는 내부 변수에 할당된다). AI/ML 모델이 RAM으로 복사된 이후, fileStream은 770에서 폐기되고 FSM은 780에서 \"청취\" 상태를 할당받 는다. 이것은 몇몇 실시형태에서 트리거(예를 들면, HTTP 엔드포인트)에 기초하여 인스턴스화하는 것을 포함할 수도 있다. 이것은 초기화 준비 전이(init ready transition; 622)를 통해 FSM을 청취 상태로 전이 시킨다. 청취 상태에서, FRM은 (예를 들면, 전자 메일로부터의, 서비스로부터의, 챗봇으로부터의, 폴더 내의 파일의 존재를 주기적으로 체크하는, 등등의) 요청을 청취한다. 도 6의 예에서, 청취 상태는 폴더에 저장 되는 정보 기술(information technology; IT) 서비스 티켓 텍스트 파일을 프로세싱하기 위한 요청을 청취한다. 도 8의 IT ServiceDesk Ticket을 참조한다. 도 8에서의 텍스트는, AI/ML 모델이 감정에 대해 분석할 IT서비스 데스크에 의해 수행되는 서비스에 응답하는 고객으로부터의 피드백이다. 새로운 프로세싱 요청이 수신되는 경우, FSM은 630에서 아이템 프로세싱 상태로 전이한다. 아이템 프 로세싱 상태의 시퀀스가 도 9에서 도시되어 있다. 시퀀스는, 로봇이 현재 아이템을 프로세싱하 고 있다는 것을 유저에게 통지하는 라인 기록 활동(write line activity)을 포함한다. \"for each\" 활동 은, 로봇이 데이터를 반복하고 정보의 각각의 단편(piece)을 개별적으로 프로세싱할 수 있도록, 어레이, 리스트, 데이터 테이블 또는 다른 타입의 콜렉션을 차례로 옮겨 가는 것을 가능하게 한다. 이 예에서, \"for each\" 활동의 조건은 선택된 폴더 내의 각각의 파일에 대한 것이다. \"for each\" 활동의 바디(body)는 다른 네스트화된 활동을 포함한다. 텍스트 파일 판독 활동(read text file activity)은 \"for each\" 활동이 폴더 내에서 반복하고 있는 현재 파일의 텍스트를 판독한 다. 이 텍스트는 감정 분석 AI/ML 모델 활동에 대한 입력으로서 포함된다. 라인 기록 활동은 유저가 보도록 감정 분석 AI/ML 모델 활동으로부터의 출력을 기록하고, 파일 이동 활동(move file activity)은 \"for each\" 활동이 분석을 완료한 현재 파일을 상이한 폴더로 이동시킨다. 감정 분석 AI/ML 모델 활동에 의해 호출되는 AI/ML 모델의 속성이 도 10에서 도시되어 있다. 더 구 체적으로, 디스플레이 이름, AI/ML 모델이 소스 파일로부터 유래하는지 또는 스트림으로부터 유래하는지의 여부, 분석될 콘텐츠가 텍스트이다는 것을 나타내는 설정, 및 출력될 결과가 제공된 다. 속성은 구현의 요건에 따라 유저에 의해 커스터마이징될 수도 있거나 또는 변경될 수도 있다. 634에서 아이템 프로세싱 상태가 완료되면, FSM은 청취 상태로 복귀한다. FSM은, 재트레이 닝 요청 또는 새로운 AI/ML 모델 통지가 수신될 때까지, 청취 상태 및 아이템 프로세싱 상태 에서 요청을 계속 프로세싱한다. 재트레이닝 요청이 수신되는 경우(예를 들면, 유저 또는 소프트웨어 애플리케이션에 의해 재트레이닝이 요청되는 경우, 재트레이닝을 위한 새로운 데이터세트가 수신되는 경우, 재 트레이닝을 위한 소정 양의 데이터가 수신된 이후, 초기 트레이닝 또는 마지막 트레이닝 이후 소정 양의 시간이 경과한 이후, 등등), FSM은 재트레이닝 초기화 상태에 진입하는 것에 의해 AI/ML 모델로 하여금 재트 레이닝되게 한다. 이것은 FSM을 실행하는 컴퓨팅 시스템 상에서 로컬로 행해질 수도 있거나, FSM을 실행하는 컴퓨팅 시스템 외부의 다른 컴퓨팅 시스템(들)에 의해 수행될 수도 있거나, 또는 이들의 조합일 수도 있다. 예를 들면, FSM을 실행하는 컴퓨팅 시스템이 퍼스널 컴퓨터이고 AI/ML 모델이 복잡한 경우, AI/ML 모델을 트레이닝시키기 위해 최적화되는 강력한 서버(예를 들면, 다수의 CPU 및 GPU를 활용함, 다수의 서버를 사용하여 분산 트레이닝을 수행함 - 이 경우 서버는 프로세싱 태스크를 분할함 - , 등등) 상에서 AI/ML 모델을 재트레이닝하는 것이 유리할 수도 있다. 예를 들면, 도 14의 시스템을 참조한다. 이 예에서, AI/ML 모델의 재트레이닝은 국소적으로 발생하고, 재트레이닝 동안의 진척을 유저에게 보여주는 윈 도우가 디스플레이될 수도 있다. 예를 들면, 재트레이닝이 95 %의 신뢰 구간을 가지고 완료된 도 11의 재트레이 닝 윈도우를 참조한다. FSM의 동작에 관련되는 상태 메시지가 또한 도시될 수도 있다. 도 11의 상태 메시지를 참조한다. 그 다음, FSM은 작업을 재개하고 청취 상태로 복귀한다. 이것은, AI/ML 모델이 재트레이닝되는 동안, FSM이 요청을 계속 프로세싱하는 것을 허용한다. 새로운 AI/ML 모델 또는 현재 AI/ML 모델의 재트레이닝된 버전이 이용 가능하다는 통지가 수신되는 경우, FSM은 업데이트 상태에 진입한다. 도 12의 AI/ML 모델 업데이트 동안의 FSM 실행 상태. 업데이 트 상태에서, AI/ML 모델 파일은 새로운 AI/ML 모델 파일로 변경된다. 이것은 본질적으로 생산 AI/ML 모델 을 업데이트된 AI/ML 모델로 대체한다. 그 다음, FSM은 전이에 진입하여 새로운 AI/ML 모델을 사용하 여 재초기화하고, FSM은, 새로운 AI/ML 모델이 초기화되는 초기화 상태로 복귀한다. 도 13은, 본 발명의 한 실시형태에 따른, AI/ML 모델을 업데이트하기 위한 시퀀스를 예시하는 스크린샷이 다. 라인 기록 활동은, AI/ML 모델이 업데이트되고 있다는 것을 유저에게 통지한다. 재트레이닝 체킹 활 동은, AI/ML 모델의 재트레이닝이 현재 발생하고 있는지의 여부를 체크한다. 만약 그렇다면, 시퀀스 는 재트레이닝이 완료될 때까지 AI/ML 모델 업데이트를 지연시킨다. 파일 이동 활동은 새로운 AI/ML 모델을 그것이 저장될 위치로 이동시키고, 상태 할당 활동은 FSM의 상태를 초기화 상태 에 할당한다. FSM은 이제 업데이트된 및/또는 재트레이닝된 AI/ML 모델을 사용하여 초기화될 수 있다. AI/ML 모델 업데이트 또는 재트레이닝 및 업데이트 아키텍쳐 상기에 따르면, 몇몇 실시형태에서, AI/ML 모델의 재트레이닝은 디지털 프로세스를 실행하는 컴퓨팅 시스템으로 부터 원격에서 발생할 수도 있다. 도 14는, 본 발명의 한 실시형태에 따른, AI/ML 모델을 재트레이닝하도록 구성되는 시스템을 예시하는 아키텍쳐 다이어그램이다. 시스템은 데스크탑 컴퓨터, 태블릿 , 및 스마트폰과 같은 유저 컴퓨팅 시스템을 포함한다. 그러나, 스마트 워치, 랩탑 컴퓨터, 사물 인터넷(Internet-of-Things; IoT) 디바이스, 차량 컴퓨팅 시스템, 등등을 포함하는, 그러나 이들로 제한되지는 않는 임의의 소망되는 컴퓨팅 시스템이 본 발명의 범위를 벗어나지 않으면서 사용될 수도 있다. 각각의 컴퓨팅 시스템(1402, 1404, 1406)은, AI/ML 모델을 호출 및/또는 실행하는 디지털 프로세스가 그 상에서 실행된다. 디지털 프로세스는 RPA 디자이너 애플리케이션을 통해 생성되는 로봇일 수도 있거나, 오퍼레이팅 시스템의 일부일 수도 있거나, 퍼스널 컴퓨터(PC) 또는 스마트폰에 대한 다운로드 가능한 애플리케 이션일 수도 있거나, 또는 본 발명의 범위를 벗어나지 않으면서 임의의 다른 소프트웨어 및/또는 하드웨어일 수 도 있다. 실제로, 몇몇 실시형태에서, 하나 이상의 디지털 프로세스의 로직은 물리적 하드웨어를 통해 부 분적으로 또는 완전히 구현된다. 디지털 프로세스는 네트워크(예를 들면, 근거리 통신망(local area network; LAN), 이동 통신 네 트워크, 위성 통신 네트워크, 인터넷, 이들의 임의의 조합, 등등)를 통해 AI/ML 모델 업데이트 요청, 또는 재트 레이닝 및 업데이트 요청을 서버로 전송한다. 몇몇 실시형태에서, 서버는 컨덕터 애플리케이션을 실행할 수도 있고 데이터는 하트비트 메시지의 일부로서 주기적으로 전송될 수도 있다. 소정의 실시형태에서, 요청은, 일단 미리 결정된 양의 재트레이닝 데이터가 수집되면, 미리 결정된 시간 기간이 경과한 이후, 또는 둘 모두의 경우에, 서버로 전송될 수도 있다. 서버는 다양한 버전의 AI/ML 모델을 데이터베이스(144 0)에 저장한다. 인간 유저(예를 들면, RPA 엔지니어 또는 데이터 과학자)에 의해 지시받는 경우, 미리 결정된 양의 재트레이닝 데이터가 수집된 경우, 마지막 재트레이닝 이후 미리 결정된 양의 시간이 경과한 경우, 재트레이닝 요청이 수신 되는 경우, 등등의 경우에, 서버는 다수의 AI 계층을 통해 재트레이닝 데이터를 실행한다. AI 계층 은 데이터를 프로세싱하고 AI/ML 모델의 재트레이닝된 버전을 생성한다. AI 계층은 통계 모델링(예 를 들면, 은닉 마르코프 모델(hidden Markov model; HMM))을 수행할 수도 있고 딥 러닝 기술(예를 들면, 장단기 메모리(long short term memory; LSTM) 딥 러닝, 이전의 은닉 상태의 인코딩, 등등)을 활용할 수도 있다. 소정의 실시형태에서, 데이터 과학자는 AI/ML 모델의 재트레이닝을 개시 및/또는 모니터링할 수도 있다. 예를 들면, 데이터 과학자는 재트레이닝 데이터세트를 추가적인 데이터로 보충할 수도 있고, 재트레이닝된 AI/ML 모 델이 소망되는 신뢰 구간을 달성하는 데 실패하는 경우 상이한 또는 보충된 트레이닝 데이터를 사용하여 AI/ML 모델을 다시 재트레이닝할 수도 있고, 등등일 수도 있다. 데이터 과학자는, AI/ML 모델이 준비되고 승인되는 경 우 업데이트 통지를 생성할 수도 있고 그것을 유저 컴퓨팅 시스템(1402, 1404, 1406)으로 전송할 수도 있다. 대 안적으로, 서버는 통지를 생성할 수도 있다. 몇몇 실시형태에서, 다수의 AI 계층이 사용될 수도 있다. 각각의 AI 계층은, 재트레이닝 데이터에 대해 실행되는 알고리즘(또는 모델)이며, AI/ML 모델 그들 자체는, 트레이닝 데이터에서 트레이닝되는 트레이닝 된 인공 \"뉴런\"의 딥 러닝 신경망(deep learning neural network; DLNN)일 수도 있다. 계층은 직렬 또는 병렬 로 실행될 수도 있다. AI 계층은, 시퀀스 추출 계층, 클러스터링 검출 계층, 시각적 컴포넌트 검출 계층, 텍스트 인식 계층(예 를 들면, OCR), 오디오 대 텍스트 변환 계층, 하나 이상의 타입의 계층의 다수의 인스턴스, 또는 이들의 임의의 조합을 포함할 수도 있지만, 그러나 이들로 제한되지는 않는다. 임의의 소망되는 수 및 타입(들)의 계층이 본 발명의 범위를 벗어나지 않으면서 사용될 수도 있다. 다수의 계층을 사용하는 것은, 시스템이 화면 또는 프로세 스에서 발생하고 있는 것의 전역적 픽쳐(global picture)를 개발하는 것을 허용할 수도 있다. 예를 들면, 하나 의 AI 계층은 OCR을 수행할 수 있고, 다른 것은 버튼을 검출할 수 있고, 등등을 할 수 있다. 패턴은 AI 계층에 의해 개별적으로 또는 다수의 AI 계층에 의해 집합적으로 결정될 수도 있다. AI/ML 모델 업데이트 또는 재트레이닝 및 업데이트 프로세스 도 15는, 본 발명의 한 실시형태에 따른, 런타임시의 AI/ML 모델 동적 재트레이닝 및 업데이트를 위한 디지털 프로세스를 예시하는 아키텍쳐 다이어그램이다. 묘사된 실시형태에서, 디지털 프로세스는 FSM이다. 그러나, 본원에서의 개념은 본 발명의 범위를 벗어나지 않으면서 임의의 적절한 디지털 프로세스에서 구체화될 수도 있다. 디지털 프로세스는, AI/ML 모델을 프로세스에 의해 호출 가능하게 만드는 초기화/인스턴스화 상태를 가지고 시작한다. 초기화/인스턴스화 상태는 AI/ML 모델 인스턴스화/초기화 컴포넌트(151 2)뿐만 아니라, 디지털 프로세스의 다른 속성 및 컴포넌트의 컴포넌트 인스턴스화 또는 초기화를포함한다. 초기화가 완료된 이후, 디지털 프로세스는 작업/프로세싱 상태로 전이한다. 작업/프로세싱 상태 에서, 디지털 프로세스는 작업 요청뿐만 아니라, AI/ML 모델 재트레이닝 또는 업데이트 요청 을 청취하고, 작업/요청 프로세싱 컴포넌트를 통해 요청 프로세싱을 수행한다. 작업 요청 및 AI/ML 모델 재트레이닝 또는 업데이트 요청은 내부적일 수도 있고(즉, 디지털 프로세스를 실행하는 컴퓨팅 시스템으로부터 유래함) 또는 외부적일 수도 있다(즉, 다른 컴퓨팅 시스템으로부터 유래함). 작업 요청이 수신되는 경우, AI/ML 모델에 대한 정보는 AI/ML 모델 컴포넌트에 대한 입력으로서 제 공되는데, AI/ML 모델 컴포넌트는 입력 정보를 프로세싱하고 작업/요청 프로세싱 컴포넌트에 출력 을 제공한다. 그 다음, 작업/요청 프로세싱 컴포넌트는, AI/ML 모델 컴포넌트의 실행의 결과와 관 련되는 정보를 갖는 응답을, 작업 요청(예를 들면, 다른 소프트웨어 애플리케이션)과 관련되는 요청자 (requestor)에게 제공한다. 작업/요청 프로세싱 컴포넌트가 AI/ML 모델 재트레이닝 요청을 수신하는 경우, 이것은 업데이트 AI/ML 모델 상태의 AI/ML 모델 재트레이닝 컴포넌트로 전송된다. AI/ML 모델을 재트레이닝하기 위 한 새로운 데이터는 AI/ML 모델 저장소(예를 들면, 데이터베이스)로부터 판독되고 재트레이닝된(새 로운) AI/ML 모델은 AI/ML 모델 저장소에 기록된다. 그 다음, 재로딩/재초기화/재인스턴스화 컴포 넌트는 재트레이닝된(새로운) AI/ML 모델을 사용하여 디지털 프로세스를 재로딩/재초기화/재 인스턴스화하고, 디지털 프로세스는, 그 다음, 재트레이닝된(새로운) AI/ML 모델을 사용하여 작업/ 프로세싱 상태로 복귀한다. 도 16은, 본 발명의 한 실시형태에 따른, 런타임시의 AI/ML 모델 동적 업데이트를 위한 디지털 프로세스 를 예시하는 아키텍쳐 다이어그램이다. 묘사된 실시형태에서, 디지털 프로세스는 FSM이다. 그러나, 본원 에서의 개념은 본 발명의 범위를 벗어나지 않으면서 임의의 적절한 디지털 프로세스에서 구체화될 수도 있다. 디지털 프로세스에서와 같이, 디지털 프로세스는, 하나 이상의 AI/ML 모델의 인스턴스화 또는 초기 화를 위한 그리고 디지털 프로세스의 다른 속성 및 컴포넌트를 위한 컴포넌트(1612, 1614)를 각각 갖는 초기화/인스턴스화, 작업/요청 프로세싱 컴포넌트 및 AI/ML 모델 컴포넌트를 갖는 작업/프로 세싱 상태, 및 작업 요청을 포함한다. 그러나, 이 실시형태에서, 디지털 프로세스는 AI/ML 모델의 재트레이닝에서 수반되지 않는다. 따라서, 디지털 프로세스는 AI/ML 모델 업데이트 요청을 수신한다. AI/ML 모델 업데이트 요청이 작업/요청 프로세싱 컴포넌트에 의해 수신되는 경우, AI/ML 모델 업데 이트 요청은 업데이트 AI/ML 모델 상태의 재로딩/재초기화/재인스턴스화 컴포넌트로 전송되 고, 그 다음, AI/ML 모델 저장소로부터 새로운(또는 다르게 업데이트된) AI/ML 모델을 사용하여 디 지털 프로세스를 재로딩/재초기화/재인스턴스화한다. 그 다음, 디지털 프로세스는 새로운 AI/ML 모 델을 사용하여 작업/프로세싱 상태로 복귀한다. 도 17은, 본 발명의 한 실시형태에 따른, 런타임 동안 디지털 프로세스에서의 AI/ML 모델 동적 업데이트, 또는 동적 재트레이닝 및 업데이트를 위한 프로세스를 예시하는 플로우차트이다. 프로세스는, 1710에서, AI/ML 모델에 대한 실행 요청, 재트레이닝 요청, 또는 업데이트 요청에 대한 요청을 청취하는 것으로 시작한다. 1720 에서 재트레이닝 요청이 수신되거나 또는 1730에서 다른 재트레이닝 조건이 충족되는 경우, 1740에서 AI/ML 모 델의 재트레이닝이 개시된다. 디지털 프로세스 구현 프로세스는 재트레이닝이 발생하고 있는 동안 현재 버전의 AI/ML 모델을 사용하여 실행을 계속할 수도 있다. 몇몇 실시형태에서, 디지털 프로세스는 RPA 워크플로우, BPM 플로우차트, 순차적 플로우, 또는 FSM이다. 소정의 실시형태에서, FSM은 RPA 워크플로우의 일부일 수도 있다. 소정의 실시형태에서, AI/ML 모델은 RPA 워크플로우 의 활동에 의해 호출된다. 몇몇 실시형태에서, AI/ML 모델은 RPA 워크플로우의 활동에 직접적으로 임베딩된다. 다른 재트레이닝 조건은 AI/ML 모델의 자동 재트레이닝을 위한 메커니즘을 제공할 수도 있다. 이들 조건은 미리 결정된 양의 트레이닝 데이터가 수신되는 것, 마지막 재트레이닝 이후 미리 결정된 양의 시간이 경과하는 것, 이들의 조합, 등등을 포함할 수도 있다. 자동 재트레이닝을 위한 임의의 재트레이닝 조건이 본 발명의 범위를 벗어나지 않으면서 사용될 수도 있다. 1750에서 업데이트 요청이 수신되는 경우, 1760에서, AI/ML 모델은 업데이트되고 디지털 프로세스는 재초기화되 거나 또는 초기화된다. 몇몇 실시형태에서, 이것은 재트레이닝된 AI/ML 모델의 성능을, 성능 임계치에 대해,AI/ML 모델의 이전 버전의 성능에 대해, 또는 둘 모두에 대해 비교하는 것, 및 새로운 버전이 성능 기준을 충족 하는 경우에만 AI/ML 모델을 업데이트하는 것을 수반할 수도 있다. 소정의 실시형태에서, 이들 기준이 충족되지 않는 경우, 어떠한 업데이트 요청도 전송되지 않는다. 1770에서 AI/ML 모델을 실행하기 위한 요청이 수신되는 경우, 1780에서 AI/ML 모델이 실행된다. 단계(1720, 1730, 1750 또는 1770) 중 어느 것도 충족되지 않는 경우, 프로세스는 1710에서 AI/ML 모델에 대한 재트레이닝 요청 또는 업데이트 요청을 청취하는 것으로 복귀한다. 프로세스는 디지털 프로세스 구현 프로세스(170 0)가 중지될 때까지 실행을 계속할 수도 있다. 도 15 내지 도 17에서 수행되는 프로세스 단계는, 본 발명의 실시형태에 따라, 프로세서(들)가 도 15 내지 도 17에서 설명되는 프로세스(들)의 적어도 일부를 수행하기 위한 명령어를 인코딩하는 컴퓨터 프로그램에 의해 수 행될 수도 있다. 컴퓨터 프로그램은 비일시적 컴퓨터 판독 가능 매체 상에서 구체화될 수도 있다. 컴퓨터 판독 가능 매체는, 하드 디스크 드라이브, 플래시 디바이스, RAM, 테이프, 및/또는 데이터를 저장하기 위해 사용되는 임의의 다른 그러한 매체 또는 매체의 조합일 수도 있지만, 그러나 이들로 제한되지는 않는다. 컴퓨터 프로그램 은, 컴퓨터 판독 가능 매체 상에 또한 저장될 수도 있는, 도 15 내지 도 17에 설명되는 프로세스 단계의 모두 또는 일부를 구현하기 위해 컴퓨팅 시스템의 프로세서(들)(예를 들면, 도 5의 컴퓨팅 시스템의 프로세서 (들))를 제어하기 위한 인코딩된 명령어를 포함할 수도 있다. 컴퓨터 프로그램은 하드웨어, 소프트웨어 또는 하이브리드 구현에서 구현될 수 있다. 컴퓨터 프로그램은, 서로 동작 가능하게 통신하는, 정보 또는 명령어를 디스플레이에 전달하도록 설계되는 모듈로 구성될 수 있다. 컴퓨 터 프로그램은 범용 컴퓨터, ASIC, 또는 임의의 다른 적절한 디바이스 상에서 동작하도록 구성될 수 있다. 본원의 도면에서 일반적으로 설명되고 예시되는 바와 같이, 본 발명의 다양한 실시형태의 컴포넌트는 아주 다양 하고 상이한 구성으로 배열 및 설계될 수도 있다는 것이 쉽게 이해될 것이다. 따라서, 첨부된 도면에서 표현되 는 바와 같이, 본 발명의 실시형태의 상세한 설명은 청구되는 바와 같은 본 발명의 범위를 제한하도록 의도되는 것이 아니라, 단지 본 발명의 선택된 실시형태를 대표하는 것에 불과하다. 본 명세서 전반에 걸쳐 설명되는 본 발명의 피쳐, 구조체, 또는 특성은 하나 이상의 실시형태에서 임의의 적절 한 방식으로 결합될 수도 있다. 예를 들면, 본 명세서 전체에 걸친 \"소정의 실시형태\", \"몇몇 실시형태\" 또는 유사한 언어에 대한 언급은, 실시형태와 관련하여 설명되는 특정한 피쳐, 구조체 또는, 특성이 본 발명의 적어 도 하나의 실시형태에서 포함된다는 것을 의미한다. 따라서, 본 명세서 전체에 걸친 어구 \"소정의 실시형태에서\", \"몇몇 실시형태에서\", \"다른 실시형태에서\" 또는 유사한 언어의 출현은, 반드시 모두 동일한 그 룹의 실시형태를 가리키는 것은 아니며, 설명되는 피쳐, 구조체, 또는 특성은 하나 이상의 실시형태에서 임의의 적절한 방식으로 결합될 수도 있다. 본 명세서 전반에 걸친 피쳐, 이점 또는 유사한 언어에 대한 언급은, 본 발명을 사용하여 실현될 수도 있는 피 쳐 및 이점 모두가 본 발명의 임의의 단일의 실시형태에 있어야 한다는 또는 있다는 것을 암시하지는 않는다. 오히려, 피쳐 및 이점을 언급하는 언어는, 실시형태와 관련하여 설명되는 특정한 피쳐, 이점, 또는 특성이 본 발명의 적어도 하나의 실시형태에 포함된다는 것을 의미하는 것으로 이해된다. 따라서, 본 명세서 전체에 걸친 피쳐 및 이점의 논의, 및 유사한 언어는 동일한 실시형태를 지칭할 수도 있지만, 그러나 반드시 그런 것은 아니 다. 더구나, 본 발명의 설명되는 피쳐, 이점, 및 특성은 하나 이상의 실시형태에서 임의의 적절한 방식으로 결합될 수도 있다. 관련 기술 분야에서 숙련된 자는, 본 발명이 특정한 실시형태의 특정한 피쳐 또는 이점 중 하나 이 상이 없어도 실시될 수 있다는 것을 인식할 것이다. 다른 경우에, 소정의 실시형태에서 본 발명의 모든 실시형 태에서 존재하지 않을 수도 있는 추가적인 피쳐 및 이점이 인식될 수도 있다. 기술 분야에서 통상의 스킬을 가진 자는, 상기에서 논의되는 바와 같은 본 발명이 상이한 순서의 단계로, 및/또 는 개시되는 것과는 상이한 구성의 하드웨어 엘리먼트로 실시될 수도 있다는 것을 쉽게 이해할 것이다. 따라서, 비록 본 발명이 이들 바람직한 실시형태에 기초하여 설명되었지만, 본 발명의 취지 및 범위 내에 남아 있으면서, 소정의 수정예, 변형예, 및 대안적인 구성예가 명백할 것이다는 것이 기술 분야의 숙련된 자에게 명 백할 것이다. 따라서, 본 발명의 경계 및 범위를 결정하기 위해, 첨부된 청구범위에 대한 참조가 이루어져야 한 다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7a 도면7b 도면8 도면9 도면10 도면11 도면12 도면13 도면14 도면15 도면16 도면17"}
{"patent_id": "10-2020-0103986", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 발명의 소정의 실시형태의 이점이 쉽게 이해되도록, 첨부된 도면에서 예시되는 특정한 실시형태에 대한 참조 에 의해 상기에서 간략하게 설명되는 본 발명의 보다 구체적인 설명이 제공될 것이다. 이들 도면이 본 발명의 통상적인 실시형태만을 묘사하며 따라서 그 범위를 제한하는 것으로 간주되지 않는다는 것이 이해되어야 하지만, 본 발명은 첨부하는 도면의 사용을 통해 추가적으로 특이하게 그리고 상세하게 기술되고 설명될 것인데, 첨부하는 도면에서: 도 1은, 본 발명의 한 실시형태에 따른, 로봇 프로세스 자동화(robotic process automation; RPA) 시스템을 예 시하는 아키텍쳐 다이어그램(architectural diagram)이다. 도 2는, 본 발명의 한 실시형태에 따른, 배치된 RPA 시스템을 예시하는 아키텍쳐 다이어그램이다. 도 3은, 본 발명의 한 실시형태에 따른, 디자이너(designer), 활동, 및 드라이버 사이의 관계를 예시하는 아키 텍쳐 다이어그램이다. 도 4는, 본 발명의 한 실시형태에 따른, RPA 시스템을 예시하는 아키텍쳐 다이어그램이다. 도 5는, 본 발명의 한 실시형태에 따른, 런타임시 AI/ML 모델을 동적으로 업데이트하도록, 또는 재트레이닝하고 업데이트하도록 구성되는 컴퓨팅 시스템을 예시하는 아키텍쳐 다이어그램이다. 도 6은, 본 발명의 한 실시형태에 따른, 런타임시 AI/ML 모델을 동적으로 업데이트하도록 또는 재트레이닝하고 업데이트하도록 구성되는 유한 상태 머신(finite state machine; FSM)의 흐름도의 스크린샷이다. 도 7a는, 본 발명의 한 실시형태에 따른, 도 6의 FSM의 초기화 상태의 스크린샷을 예시한다.도 7b는, 본 발명의 한 실시형태에 따른, 도 7a의 초기화 상태의 파라미터의 스크린샷을 예시한다. 도 8은, 본 발명의 한 실시형태에 따른, 고객 피드백을 포함하는 텍스트 파일을 예시하는 스크린샷이다. 도 9는, 본 발명의 한 실시형태에 따른, 도 6의 FSM의 아이템 프로세싱 상태의 RPA 워크플로우 시퀀스를 예시하 는 스크린샷이다. 도 10은, 본 발명의 한 실시형태에 따른, 도 9의 RPA 워크플로우 시퀀스에 의해 호출되는 AI/ML 모델의 속성을 예시하는 스크린샷이다. 도 11은, 본 발명의 한 실시형태에 따른, 재트레이닝 동안의 진척(progress) 및 재트레이닝 동안의 FSM 실행 상 태를 도시하는 스크린샷을 예시한다. 도 12는, 본 발명의 한 실시형태에 따른, AI/ML 모델 업데이트 동안의 FSM 실행 상태를 도시하는 스크린샷이다. 도 13은, 본 발명의 한 실시형태에 따른, AI/ML 모델을 업데이트하기 위한 시퀀스를 예시하는 스크린샷이다. 도 14는, 본 발명의 한 실시형태에 따른, AI/ML 모델을 재트레이닝하도록 구성되는 시스템을 예시하는 아키텍쳐 다이어그램이다. 도 15는, 본 발명의 한 실시형태에 따른, 런타임시 AI/ML 모델 동적 재트레이닝 및 업데이트를 위한 디지털 프 로세스를 예시하는 아키텍쳐 다이어그램이다. 도 16은, 본 발명의 한 실시형태에 따른, 런타임시의 AI/ML 모델 동적 업데이트를 위한 디지털 프로세스를 예시 하는 아키텍쳐 다이어그램이다. 도 17은, 본 발명의 한 실시형태에 따른, 런타임 동안 디지털 프로세스에서의 AI/ML 모델 동적 업데이트, 또는 동적 재트레이닝 및 업데이트를 위한 프로세스를 예시하는 플로우차트이다. 달리 지시되지 않는 한, 유사한 참조 문자는 첨부의 도면 전체에 걸쳐 대응하는 피쳐를 일관되게 나타낸다."}
