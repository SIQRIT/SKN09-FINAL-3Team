{"patent_id": "10-2020-0123297", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0040295", "출원번호": "10-2020-0123297", "발명의 명칭": "메트릭 학습을 위한 가상의 학습 데이터 생성 방법 및 시스템", "출원인": "네이버 주식회사", "발명자": "고병수"}}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "메트릭 학습(metric learning)을 위한 가상의 학습 데이터 생성 방법에 있어서,제1 클래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 상기 제1 클래스의 복수의 학습 데이터에 대응하는 제1 클래스의 복수의 임베딩 특징을 생성하는 단계;상기 제1 클래스의 복수의 임베딩 특징에 기초하여 제1 클래스의 프록시를 결정하는 단계;제2 클래스의 복수의 학습 데이터를 상기 인공 신경망 모델에 입력하여 상기 제2 클래스의 복수의 학습 데이터에 대응하는 제2 클래스의 복수의 임베딩 특징을 생성하는 단계;상기 제2 클래스의 복수의 임베딩 특징에 기초해서 제2 클래스의 프록시를 결정하는 단계;상기 제1 클래스의 복수의 임베딩 특징 및 상기 제2 클래스의 복수의 임베딩 특징에 기초하여 가상 임베딩 특징을 생성하는 단계; 및상기 제1 클래스의 프록시 및 상기 제2 클래스의 프록시에 기초하여 가상 클래스의 프록시를 생성하는 단계를 포함하고,상기 가상 임베딩 특징은 상기 가상 클래스에 속하고,상기 가상 클래스는 상기 제1 클래스 및 상기 제2 클래스와 상이한, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 제1 클래스의 복수의 임베딩 특징 및 상기 제2 클래스의 복수의 임베딩 특징에 기초하여 가상 임베딩 특징을 생성하는 단계는,상기 제1 클래스의 복수의 임베딩 특징 중 하나 및 상기 제2 클래스의 복수의 임베딩 특징 중 하나에 기초하여선형보간법(linear interpolation)을 이용하여 상기 가상 임베딩 특징을 생성하는 단계를 포함하는, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,선형보간법 계수는 베타 분포(beta distribution)를 이용하여 결정되는, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 제1 클래스의 프록시 및 상기 제2 클래스의 프록시에 기초하여 가상 클래스의 프록시를 생성하는 단계는,상기 제1 클래스의 프록시 및 상기 제2 클래스의 프록시에 기초하여 선형보간법을 이용하여 상기 가상 클래스의프록시를 생성하는 단계를 포함하고,상기 가상 임베딩 특징과 상기 가상 클래스의 프록시는 동일한 선형보간법 계수를 사용하여 생성되는, 가상의학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "공개특허 10-2022-0040295-3-제1항에 있어서,상기 제1 클래스의 프록시와 상기 제2 클래스의 프록시 사이의 거리는, 상기 제1 클래스의 프록시와 상기 가상클래스의 프록시 사이의 거리, 그리고 상기 제2 클래스의 프록시와 상기 가상 클래스의 프록시 사이의 거리보다먼, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 생성된 가상 임베딩 특징 및 가상 클래스의 프록시에 기초하여 프록시 기반 손실 함수를 이용하여 상기 인공 신경망 모델을 업데이트하는 단계를 더 포함하는, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,상기 프록시 기반 손실 함수는 앵커 임베딩 특징과 각 클래스의 프록시 사이의 거리에 기초하여 손실값을 산출하는, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 프록시 기반 손실 함수는 앵커 임베딩 특징과 앵커 임베딩 특징이 속하는 클래스의 프록시 사이의 거리가가까울수록 손실이 적고, 앵커 임베딩 특징과 앵커 임베딩 특징이 속하지 않는 클래스의 프록시 사이의 거리가가까울수록 손실이 큰 것으로 손실값을 정의하는, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제6항에 있어서,상기 생성된 가상 임베딩 특징 및 가상 클래스의 프록시에 기초하여 프록시 기반 손실 함수를 이용하여 상기 인공 신경망 모델을 업데이트하는 단계는,상기 제1 클래스의 복수의 임베딩 특징 중 하나와 상기 제1 클래스의 프록시 사이의 거리가 가까워지고, 상기제1 클래스의 복수의 임베딩 특징 중 하나와 상기 가상 클래스의 프록시가 멀어지고, 상기 제1 클래스의 복수의임베딩 특징 중 하나와 상기 제2 클래스의 프록시가 멀어지도록 상기 인공 신경망 모델을 업데이트하는 단계를 포함하는, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제6항에 있어서,상기 생성된 가상 임베딩 특징 및 가상 클래스의 프록시에 기초하여 프록시 기반 손실 함수를 이용하여 상기 인공 신경망 모델을 업데이트하는 단계는,상기 가상 임베딩 특징과 상기 가상 클래스의 프록시 사이의 거리가 가까워지고, 상기 가상 임베딩 특징과 상기제1 클래스의 프록시가 멀어지고, 상기 가상 임베딩 특징과 상기 제2 클래스의 프록시가 멀어지도록 상기 인공신경망 모델을 업데이트하는 단계를 포함하는, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제6항에 있어서,제1 이미지에 대한 데이터를 수신하는 단계;상기 제1 이미지에 대한 데이터를 상기 업데이트된 인공 신경망 모델에 입력하여 미리 저장된 복수의 이미지 중공개특허 10-2022-0040295-4-상기 제1 이미지와 가장 유사도가 높은 제2 이미지에 대한 데이터를 출력하는 단계를 더 포함하는, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1항에 있어서,학습 데이터 세트에 기초하여 프록시 기반 손실 함수를 이용하여 상기 인공 신경망 모델을 생성하는 단계를 더포함하고,상기 제1 클래스의 복수의 학습 데이터 및 상기 제2 클래스의 복수의 학습 데이터는 상기 학습 데이터 세트의서브세트인, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1항에 있어서,상기 제1 클래스의 프록시는 상기 제1 클래스의 복수의 임베딩 특징들의 중간값 또는 평균값인, 가상의 학습 데이터 생성 방법."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제1항 내지 제13항 중 어느 한 항에 따른 가상의 학습 데이터 생성 방법을 컴퓨터에서 실행하기 위해 컴퓨터 판독 가능한 기록 매체에 저장된 컴퓨터 프로그램."}
{"patent_id": "10-2020-0123297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "메트릭 학습을 위한 가상의 학습 데이터 생성 시스템으로서,메모리; 및상기 메모리와 연결되고, 상기 메모리에 포함된 컴퓨터 판독 가능한 적어도 하나의 프로그램을 실행하도록 구성된 적어도 하나의 프로세서를 포함하고,상기 적어도 하나의 프로그램은,제1 클래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 상기 제1 클래스의 복수의 학습 데이터에 대응하는 제1 클래스의 복수의 임베딩 특징을 생성하고,상기 제1 클래스의 복수의 임베딩 특징에 기초하여 제1 클래스의 프록시를 결정하고,제2 클래스의 복수의 학습 데이터를 상기 인공 신경망 모델에 입력하여 상기 제2 클래스의 복수의 학습 데이터에 대응하는 제2 클래스의 복수의 임베딩 특징을 생성하고,상기 제2 클래스의 복수의 임베딩 특징에 기초해서 제2 클래스의 프록시를 결정하고,상기 제1 클래스의 복수의 임베딩 특징 및 상기 제2 클래스의 복수의 임베딩 특징에 기초하여 가상 임베딩 특징을 생성하고,상기 제1 클래스의 프록시 및 상기 제2 클래스의 프록시에 기초하여 가상 클래스의 프록시를 생성하기 위한 명령어들을 포함하고,상기 가상 임베딩 특징은 상기 가상 클래스에 속하고,상기 가상 클래스는 상기 제1 클래스 및 상기 제2 클래스와 상이한, 가상의 학습 데이터 생성 시스템."}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 개시는 메트릭 학습(metric learning)을 위한 가상의 학습 데이터 생성 방법에 관한 것이다. 가상의 학습 데 이터 생성 방법은 제1 클래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 제1 클래스의 복수의 학습 데이터에 대응하는 제1 클래스의 복수의 임베딩 특징을 생성하는 단계, 제1 클래스의 복수의 임베딩 특징에 기초 (뒷면에 계속)"}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 메트릭 학습을 위한 가상의 학습 데이터 생성 방법 및 시스템에 관한 것으로, 구체적으로 기존의 학 습 데이터를 기초로 가상의 학습 데이터를 생성하여 인공 신경망 모델을 학습하는 방법 및 시스템에 관한 것이다."}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "최근 인공 지능(AI)의 발달과 함께 다양한 분야에서 인공 지능이 적용됨에 따라, 딥 메트릭 학습(deep metric learning)을 통해 정확도 높은 인공 신경망 모델을 생성하는 것에 대한 관심이 증가하고 있다. 인공 신경망 모 델의 딥 메트릭 학습은 임의의 데이터 포인트 간의 유사성 메트릭을 학습하여, 의미적으로 유사한 데이터는 서 로 가까워지고, 상이한 데이터는 서로 멀어지도록 임베딩 공간을 정의하고자 하며, 이는 손실 함수의 손실값이 줄어드는 방향으로 인공 신경망 모델을 학습함으로써 수행될 수 있다. 여기서 사용되는 손실 함수는 쌍 기반 손실 및 프록시 기반 손실의 두 가지 유형으로 분류될 수 있다. 쌍 기반 손실은 임베딩 공간에서 데이터 포인트 간의 유사성을 기초로 산출된다. 쌍 기반 손실 유형은 손실을 산출하기 위해 데이터 포인트 간 튜플(tuple)(2-튜플, 3-튜플 등)을 고려해야 하므로 학습이 매우 복잡하고, 복수의 튜플 중 학습에 유용한 튜플을 선정하는 샘플링이 필요하다는 문제가 있다. 한편, 프록시 기반 손실 유형은 앵커(anchor)와 각 클래스의 프록시 사이의 관계만을 고려하므로, 쌍 기반 손실 의 학습 복잡성과 샘플링 문제를 해결하고, 메트릭 학습의 성능을 향상시킬 수 있다. 그러나, 학습 데이터로만 학습된 인공 신경망 모델의 경우, 학습한(seen) 클래스에 대해서만 과도하게 적합(over-fitted)할 수 있으며, 학습하지 않은(unseen) 클래스에 대한 일반화(generalization)가 부족하다는 문제가 있다."}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시는 상기와 같은 문제를 해결하기 위한 메트릭 학습을 위한 가상의 학습 데이터 생성 방법, 기록 매체에 저장된 컴퓨터 프로그램 및 장치(시스템)를 제공한다."}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시는 방법, 장치(시스템) 또는 판독 가능 저장 매체에 저장된 컴퓨터 프로그램을 포함한 다양한 방식으로 구현될 수 있다. 본 개시의 일 실시예에 따르면, 메트릭 학습(metric learning)을 위한 가상의 학습 데이터 생성 방법은, 제1 클 래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 제1 클래스의 복수의 학습 데이터에 대응하는 제1 클래스의 복수의 임베딩 특징을 생성하는 단계, 제1 클래스의 복수의 임베딩 특징에 기초하여 제1 클래스의 프 록시를 결정하는 단계, 제2 클래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 제2 클래스의 복수의 학습 데이터에 대응하는 제2 클래스의 복수의 임베딩 특징을 생성하는 단계, 제2 클래스의 복수의 임베딩 특징 에 기초해서 제2 클래스의 프록시를 결정하는 단계, 제1 클래스의 복수의 임베딩 특징 및 제2 클래스의 복수의 임베딩 특징에 기초하여 가상 임베딩 특징을 생성하는 단계 및 제1 클래스의 프록시 및 제2 클래스의 프록시에 기초하여 가상 클래스의 프록시를 생성하는 단계를 포함하고, 가상 임베딩 특징은 가상 클래스에 속하고, 가상 클래스는 제1 클래스 및 제2 클래스와 상이하다. 본 개시의 일 실시예에 따른 가상의 학습 데이터 생성 방법을 컴퓨터에서 실행하기 위해 컴퓨터 판독 가능한 기 록 매체에 저장된 컴퓨터 프로그램이 제공된다. 본 개시의 일 실시예에 따른 메트릭 학습을 위한 가상의 학습 데이터 생성 시스템은, 메모리 및 메모리와 연결 되고, 메모리에 포함된 컴퓨터 판독 가능한 적어도 하나의 프로그램을 실행하도록 구성된 적어도 하나의 프로세 서를 포함하고, 적어도 하나의 프로그램은, 제1 클래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 제1 클래스의 복수의 학습 데이터에 대응하는 제1 클래스의 복수의 임베딩 특징을 생성하고, 제1 클래스의 복수 의 임베딩 특징에 기초하여 제1 클래스의 프록시를 결정하고, 제2 클래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 제2 클래스의 복수의 학습 데이터에 대응하는 제2 클래스의 복수의 임베딩 특징을 생성하고, 제2 클래스의 복수의 임베딩 특징에 기초해서 제2 클래스의 프록시를 결정하고, 제1 클래스의 복수의 임베딩 특 징 및 제2 클래스의 복수의 임베딩 특징에 기초하여 가상 임베딩 특징을 생성하고, 제1 클래스의 프록시 및 제2 클래스의 프록시에 기초하여 가상 클래스의 프록시를 생성하기 위한 명령어들을 포함하고, 가상 임베딩 특징은 가상 클래스에 속하고, 가상 클래스는 제1 클래스 및 제2 클래스와 상이하다."}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시의 다양한 실시예에서 클래스 간의 관계를 고려한 추가적인 학습 데이터를 사용하여 인공 신경망 모델을 학습할 수 있으므로, 인공 신경망 모델이 정교하게 구조화된(well-structed) 임베딩 공간을 구축할 수 있다. 즉, 학습하지 않은 데이터에 대하여 강인한 인공 신경망 모델을 생성할 수 있다. 본 개시의 다양한 실시예에서 가상 클래스는 기존의 클래스들 사이에 생성되므로, 어려운 가상 클래스를 사용하 여 인공 신경망 모델을 학습할 수 있다. 그에 따라, 클래스들 사이의 부드러운 결정 경계(decision boundary) 가 제공될 수 있고, 인공 신경망 모델이 더욱 일반화된 임베딩 공간을 제공할 수 있다. 본 개시의 다양한 실시예에서 추가적인 생성 네트워크 사용 없이 임베딩 공간에서 선형보간법을 사용하여 가상 클래스를 생성하므로, 메모리와 학습 속도에 큰 영향이 없다. 본 개시의 다양한 실시예들은 프록시 기반 손실을 사용하는 종래의 모든 메트릭 학습 방법에 바로 적용할 수 있 다. 본 개시의 다양한 실시예에서 기존의 프록시 기반 손실을 사용하는 메트릭 학습 방법 및 그 외의 메트릭 학습 방법들 보다 높은 성능을 갖는 인공 신경망 모델을 제공할 수 있다. 특히, 이미지 검색 작업에서 인공 신경망 모델의 성능이 크게 향상될 수 있다."}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 본 개시의 실시를 위한 구체적인 내용을 첨부된 도면을 참조하여 상세히 설명한다. 다만, 이하의 설명에 서는 본 개시의 요지를 불필요하게 흐릴 우려가 있는 경우, 널리 알려진 기능이나 구성에 관한 구체적 설명은 생략하기로 한다. 첨부된 도면에서, 동일하거나 대응하는 구성요소에는 동일한 참조부호가 부여되어 있다. 또한, 이하의 실시예 들의 설명에 있어서, 동일하거나 대응되는 구성요소를 중복하여 기술하는 것이 생략될 수 있다. 그러나, 구성 요소에 관한 기술이 생략되어도, 그러한 구성요소가 어떤 실시예에 포함되지 않는 것으로 의도되지는 않는다. 개시된 실시예의 이점 및 특징, 그리고 그것들을 달성하는 방법은 첨부되는 도면과 함께 후술되어 있는 실시예 들을 참조하면 명확해질 것이다. 그러나, 본 개시는 이하에서 개시되는 실시예들에 한정되는 것이 아니라 서로 다른 다양한 형태로 구현될 수 있으며, 단지 본 실시예들은 본 개시가 완전하도록 하고, 본 개시가 통상의 기술 자에게 발명의 범주를 완전하게 알려주기 위해 제공되는 것일 뿐이다. 본 명세서에서 사용되는 용어에 대해 간략히 설명하고, 개시된 실시예에 대해 구체적으로 설명하기로 한다. 본 명세서에서 사용되는 용어는 본 개시에서의 기능을 고려하면서 가능한 현재 널리 사용되는 일반적인 용어들을 선택하였으나, 이는 관련 분야에 종사하는 기술자의 의도 또는 판례, 새로운 기술의 출현 등에 따라 달라질 수 있다. 또한, 특정한 경우는 출원인이 임의로 선정한 용어도 있으며, 이 경우 해당되는 발명의 설명 부분에서 상세히 그 의미를 기재할 것이다. 따라서, 본 개시에서 사용되는 용어는 단순한 용어의 명칭이 아닌, 그 용어 가 가지는 의미와 본 개시의 전반에 걸친 내용을 토대로 정의되어야 한다. 본 명세서에서의 단수의 표현은 문맥상 명백하게 단수인 것으로 특정하지 않는 한, 복수의 표현을 포함한다. 또한, 복수의 표현은 문맥상 명백하게 복수인 것으로 특정하지 않는 한, 단수의 표현을 포함한다. 명세서 전체 에서 어떤 부분이 어떤 구성요소를 포함한다고 할 때, 이는 특별히 반대되는 기재가 없는 한 다른 구성요소를 제외하는 것이 아니라 다른 구성요소를 더 포함할 수 있음을 의미한다. 또한, 명세서에서 사용되는 '모듈' 또는 '부'라는 용어는 소프트웨어 또는 하드웨어 구성요소를 의미하며, '모 듈' 또는 '부'는 어떤 역할들을 수행한다. 그렇지만, '모듈' 또는 '부'는 소프트웨어 또는 하드웨어에 한정되 는 의미는 아니다. '모듈' 또는 '부'는 어드레싱할 수 있는 저장 매체에 있도록 구성될 수도 있고 하나 또는 그 이상의 프로세서들을 재생시키도록 구성될 수도 있다. 따라서, 일 예로서, '모듈' 또는 '부'는 소프트웨어 구성요소들, 객체지향 소프트웨어 구성요소들, 클래스 구성요소들 및 태스크 구성요소들과 같은 구성요소들과, 프로세스들, 함수들, 속성들, 프로시저들, 서브루틴들, 프로그램 코드의 세그먼트들, 드라이버들, 펌웨어, 마이 크로 코드, 회로, 데이터, 데이터베이스, 데이터 구조들, 테이블들, 어레이들 또는 변수들 중 적어도 하나를 포 함할 수 있다. 구성요소들과 '모듈' 또는 '부'들은 안에서 제공되는 기능은 더 작은 수의 구성요소들 및 '모듈' 또는 '부'들로 결합되거나 추가적인 구성요소들과 '모듈' 또는 '부'들로 더 분리될 수 있다. 본 개시의 일 실시예에 따르면, '모듈' 또는 '부'는 프로세서 및 메모리로 구현될 수 있다. '프로세서'는 범용 프로세서, 중앙 처리 장치(CPU), 마이크로프로세서, 디지털 신호 프로세서(DSP), 제어기, 마이크로제어기, 상태 머신 등을 포함하도록 넓게 해석되어야 한다. 몇몇 환경에서, '프로세서'는 주문형 반도체(ASIC), 프로그램가 능 로직 디바이스(PLD), 필드 프로그램가능 게이트 어레이(FPGA) 등을 지칭할 수도 있다. '프로세서'는, 예를 들어, DSP와 마이크로프로세서의 조합, 복수의 마이크로프로세서들의 조합, DSP 코어와 결합한 하나 이상의 마 이크로프로세서들의 조합, 또는 임의의 다른 그러한 구성들의 조합과 같은 처리 디바이스들의 조합을 지칭할 수 도 있다. 또한, '메모리'는 전자 정보를 저장 가능한 임의의 전자 컴포넌트를 포함하도록 넓게 해석되어야 한 다. '메모리'는 임의 액세스 메모리(RAM), 판독-전용 메모리(ROM), 비-휘발성 임의 액세스 메모리(NVRAM), 프 로그램가능 판독-전용 메모리(PROM), 소거-프로그램가능 판독 전용 메모리(EPROM), 전기적으로 소거가능 PROM(EEPROM), 플래쉬 메모리, 자기 또는 광학 데이터 저장장치, 레지스터들 등과 같은 프로세서-판독가능 매체 의 다양한 유형들을 지칭할 수도 있다. 프로세서가 메모리로부터 정보를 판독하고/하거나 메모리에 정보를 기 록할 수 있다면 메모리는 프로세서와 전자 통신 상태에 있다고 불린다. 프로세서에 집적된 메모리는 프로세서 와 전자 통신 상태에 있다. 본 개시에서, '임베딩 공간(embedding space)'은 입력 데이터(학습 데이터 또는 테스트 데이터)를 인공 신경망 모델에 입력하여, 인공 신경망 모델로부터 출력되는 특징(feature) 포인트들이 존재하는 공간을 지칭할 수 있다. '임베딩 특징'은 이러한 임베딩 공간에서의 특징 포인트를 지칭할 수 있으며, 각각의 임베딩 특징은 입 력 데이터와 대응될 수 있다.본 개시에서, '클래스'는 복수의 데이터를 분류하는 카테고리를 지칭할 수 있다. 본 개시에서, '프록시'는 하나의 클래스를 대표하는 임베딩 특징을 지칭할 수 있다. 예를 들어, 프록시는 클래 스에 포함된 복수의 임베딩 특징들의 중간값 또는 평균값일 수 있다. 대안적으로, 프록시는 관리자가 지정하는 임베딩 특징일 수 있다. 본 개시에서, '앵커'는 인공 신경망 모델을 학습하는 데 있어서, 프록시 기반 손실을 산출할 때, 기준이 되는 임베딩 특징을 지칭할 수 있다. 도 1은 본 개시의 일 실시예에 따른 정보 처리 시스템이 제1 이미지를 수신하여, 제1 이미지와 가장 유사도가 높은 제2 이미지를 출력하는 이미지 검색(image retrieval)을 수행하는 예시를 나타내는 도 면이다. 도시된 바와 같이, 정보 처리 시스템은 인공 신경망 모델 및 이미지 DB를 포함할 수 있다. 여기서, 인공 신경망 모델은 메트릭 학습(또는 거리 메트릭 학습)을 통해 학습 데이터 세트에 최적 화된 거리 메트릭(distance metric) 또는 유사성 메트릭(similarity metric)을 학습한 모델일 수 있다. 즉, 인공 신경망 모델은 학습 데이터 세트 내의 유사한 이미지들의 사이의 거리는 가깝고(유사도가 높고), 상 이한 이미지들 사이의 거리는 멀게(유사도가 낮도록) 측정되는 임베딩 공간을 정의하도록 학습될 수 있다. 일 실시예에서, 정보 처리 시스템은 제1 이미지를 수신할 수 있다. 이 경우, 정보 처리 시스템(10 0)은 수신된 제1 이미지를 인공 신경망 모델에 입력하여, 이미지 DB에 미리 저장된 복수의 이미 지 중 제1 이미지와 가장 유사도가 높은 제2 이미지를 출력할 수 있다. 예를 들어, 정보 처리 시스 템은 수신된 제1 이미지에 포함된 캐릭터와 동일한 캐릭터가 포함된 제2 이미지를 출력함으로써 이미지 검색을 수행할 수 있다. 메트릭 학습을 통해 생성된 인공 신경망 모델은 이미지 검색뿐만 아니라, 사람 재식별(person re-identication), 제로 샷 학습(zero-shot learning), 얼굴 인식(face recognition) 등의 다양한 서비스를 제공하기 위해 사용될 수 있다. 일 실시예에서, 학습하지 않은 클래스에 대해서도 더욱 일반화된 임베딩 공간을 갖는 인공 신경망 모델을 학습하기 위해, 가상의 학습 데이터(synthetic training data)를 생성할 수 있다. 여기서 가상의 학습 데이터 는 가상 임베딩 특징 및 가상 프록시를 포함할 수 있다. 이렇게 생성된 가상의 학습 데이터를 추가 학습 데이 터로 사용함으로써, 부드러운 결정 경계(smooth decision boundary)와 클래스 간의 관계를 고려한 임베딩 공간 을 갖는 인공 신경망 모델을 학습할 수 있다. 이러한 가상의 학습 데이터 생성 방법은 프록시 기반 손실 을 사용하는 모든 메트릭 학습에 적용될 수 있으며, 메모리와 학습 속도에 큰 영향을 미치지 않으면서 학습하지 않은 클래스에 대하여 더욱 강인한 인공 신경망 모델을 제공할 수 있다. 도 1에서는 정보 처리 시스템이 하나의 이미지를 입력 받아 그와 가장 유사한 하나의 이미지를 출력하고 있으나, 이에 한정되지 않는다. 예를 들어, 정보 처리 시스템은 하나의 이미지를 입력 받아 가장 높은 유 사도를 가지는 n 개(n>2)의 이미지를 출력할 수 있다. 대안적으로, 정보 처리 시스템은 복수의 이미지를 입력 받아 하나의 이미지를 출력하거나, 복수의 이미지를 입력 받아 복수의 이미지를 출력할 수 있다. 또한, 도 1에서는 정보 처리 시스템의 입력/출력 데이터로서 이미지 데이터를 도시하고 있으나, 이에 한정되지 않으며, 음성 데이터, 문자 데이터 등이 정보 처리 시스템의 입력/출력 데이터에 포함될 수 있다. 도 2는 본 개시의 일 실시예에 따른 이미지 검색 서비스를 제공하는 정보 처리 시스템이 복수의 사용자 단 말(210_1, 210_2, 210_3)과 통신 가능하도록 연결된 구성을 나타내는 개요도이다. 정보 처리 시스템은 네 트워크를 이미지 검색 서비스를 포함한 다양한 서비스를 제공할 수 있는 시스템(들), 이러한 서비스를 제 공하기 위한 인공 신경망 모델을 학습할 수 있는 시스템(들)을 포함할 수 있다. 일 실시예에서, 정보 처리 시 스템은 이미지 검색 등의 서비스, 인공 신경망 모델 학습과 관련된 컴퓨터 실행 가능한 프로그램(예를 들 어, 다운로드 가능한 어플리케이션) 및 데이터를 저장, 제공 및 실행할 수 있는 하나 이상의 서버 장치 및/또는 데이터베이스, 또는 클라우드 컴퓨팅 서비스 기반의 하나 이상의 분산 컴퓨팅 장치 및/또는 분산 데이터베이스 를 포함할 수 있다. 정보 처리 시스템에 의해 제공되는 이미지 검색 등의 서비스는, 복수의 사용자 단말(210_1, 210_2, 210_ 3)의 각각에 설치된 이미지 검색 어플리케이션, 웹 브라우저 어플리케이션 등을 통해 사용자에게 제공될 수 있 다. 예를 들어, 정보 처리 시스템은 이미지 검색 어플리케이션 등을 통해 사용자 단말(210_1, 210_2, 210_3)로부터 수신되는 이미지에 대응하는 정보를 제공하거나 대응하는 처리를 수행할 수 있다. 추가적으로, 정보 처리 시스템은 학습 데이터 세트를 이용하여 인공 신경망 모델을 점진적으로 학습/업데이트할 수 있 다.복수의 사용자 단말(210_1, 210_2, 210_3)은 네트워크를 통해 정보 처리 시스템과 통신할 수 있다. 네트워크는 복수의 사용자 단말(210_1, 210_2, 210_3)과 정보 처리 시스템 사이의 통신이 가능하도록 구성될 수 있다. 네트워크는 설치 환경에 따라, 예를 들어, 이더넷(Ethernet), 유선 홈 네트워크(Power Line Communication), 전화선 통신 장치 및 RS-serial 통신 등의 유선 네트워크, 이동통신망, WLAN(Wireless LAN), Wi-Fi, Bluetooth 및 ZigBee 등과 같은 무선 네트워크 또는 그 조합으로 구성될 수 있다. 통신 방식은 제한되지 않으며, 네트워크가 포함할 수 있는 통신망(일례로, 이동통신망, 유선 인터넷, 무선 인터넷, 방 송망, 위성망 등)을 활용하는 통신 방식뿐만 아니라 사용자 단말(210_1, 210_2, 210_3) 사이의 근거리 무선 통 신 역시 포함될 수 있다. 도 2에서 휴대폰 단말(210_1), 태블릿 단말(210_2) 및 PC 단말 (210_3)이 사용자 단말의 예로서 도시되었으나, 이에 한정되지 않으며, 사용자 단말(210_1, 210_2, 210_3)은 유선 및/또는 무선 통신이 가능하고 이미지 기반 서비스 어플리케이션, 검색 어플리케이션, 웹 브라우저 어플리케이션 등이 설치되어 실행될 수 있는 임의의 컴 퓨팅 장치일 수 있다. 예를 들어, 사용자 단말은, AI 스피커, 스마트폰, 휴대폰, 내비게이션, 컴퓨터, 노트북, 디지털방송용 단말, PDA(Personal Digital Assistants), PMP(Portable Multimedia Player), 태블릿 PC, 게임 콘솔(game console), 웨어러블 디바이스(wearable device), IoT(internet of things) 디바이스, VR(virtual reality) 디바이스, AR(augmented reality) 디바이스, 셋톱 박스 등을 포함할 수 있다. 또한, 도 2에는 3개의 사용자 단말(210_1, 210_2, 210_3)이 네트워크를 통해 정보 처리 시스템과 통신하는 것으로 도시되어 있으나, 이에 한정되지 않으며, 상이한 수의 사용자 단말이 네트워크를 통해 정보 처리 시스템과 통 신하도록 구성될 수도 있다. 도 3은 본 개시의 일 실시예에 따른 사용자 단말 및 정보 처리 시스템의 내부 구성을 나타내는 블록 도이다. 사용자 단말은 이미지 기반 서비스 어플리케이션 등이 실행 가능하고 유/무선 통신이 가능한 임 의의 컴퓨팅 장치를 지칭할 수 있으며, 예를 들어, 도 2의 휴대폰 단말(210_1), 태블릿 단말(210_2), PC 단말 (210_3) 등을 포함할 수 있다. 도시된 바와 같이, 사용자 단말은 메모리, 프로세서, 통신 모듈 및 입출력 인터페이스를 포함할 수 있다. 이와 유사하게, 정보 처리 시스템은 메모리, 프로세서, 통신 모듈 및 입출력 인터페이스를 포함할 수 있다. 도 3에 도시된 바와 같이, 사용 자 단말 및 정보 처리 시스템은 각각의 통신 모듈(316, 336)을 이용하여 네트워크를 통해 정보 및/또는 데이터를 통신할 수 있도록 구성될 수 있다. 또한, 입출력 장치는 입출력 인터페이스를 통 해 사용자 단말에 정보 및/또는 데이터를 입력하거나 사용자 단말로부터 생성된 정보 및/또는 데이터 를 출력하도록 구성될 수 있다. 메모리(312, 332)는 비-일시적인 임의의 컴퓨터 판독 가능한 기록매체를 포함할 수 있다. 일 실시예에 따르면, 메모리(312, 332)는 RAM(random access memory), ROM(read only memory), 디스크 드라이브, SSD(solid state drive), 플래시 메모리(flash memory) 등과 같은 비소멸성 대용량 저장 장치(permanent mass storage device) 를 포함할 수 있다. 다른 예로서, ROM, SSD, 플래시 메모리, 디스크 드라이브 등과 같은 비소멸성 대용량 저장 장치는 메모리와는 구분되는 별도의 영구 저장 장치로서 사용자 단말 또는 정보 처리 시스템에 포함 될 수 있다. 또한, 메모리(312, 332)에는 운영체제와 적어도 하나의 프로그램 코드(예를 들어, 사용자 단말 에 설치되어 구동되는 이미지 기반 서비스 어플리케이션 등을 위한 코드)가 저장될 수 있다. 이러한 소프트웨어 구성요소들은 메모리(312, 332)와는 별도의 컴퓨터에서 판독 가능한 기록매체로부터 로딩될 수 있다. 이러한 별도의 컴퓨터에서 판독가능한 기록매체는 이러한 사용자 단말 및 정보 처리 시스템 에 직접 연결가능한 기록 매체를 포함할 수 있는데, 예를 들어, 플로피 드라이브, 디스크, 테이프, DVD/CD-ROM 드라이브, 메모리 카드 등의 컴퓨터에서 판독 가능한 기록매체를 포함할 수 있다. 다른 예로서, 소 프트웨어 구성요소들은 컴퓨터에서 판독 가능한 기록매체가 아닌 통신 모듈을 통해 메모리(312, 332)에 로딩될 수도 있다. 예를 들어, 적어도 하나의 프로그램은 개발자들 또는 어플리케이션의 설치 파일을 배포하는 파일 배포 시스템이 네트워크를 통해 제공하는 파일들에 의해 설치되는 컴퓨터 프로그램에 기반하여 메모리 (312, 332)에 로딩될 수 있다. 프로세서(314, 334)는 기본적인 산술, 로직 및 입출력 연산을 수행함으로써, 컴퓨터 프로그램의 명령을 처리하 도록 구성될 수 있다. 명령은 메모리(312, 332) 또는 통신 모듈(316, 336)에 의해 프로세서(314, 334)로 제공 될 수 있다. 예를 들어, 프로세서(314, 334)는 메모리(312, 332)와 같은 기록 장치에 저장된 프로그램 코드에 따라 수신되는 명령을 실행하도록 구성될 수 있다. 통신 모듈(316, 336)은 네트워크를 통해 사용자 단말과 정보 처리 시스템이 서로 통신하기 위한 구성 또는 기능을 제공할 수 있으며, 사용자 단말 및/또는 정보 처리 시스템이 다른 사용자 단말 또 는 다른 시스템(일례로 별도의 클라우드 시스템 등)과 통신하기 위한 구성 또는 기능을 제공할 수 있다. 일례 로, 사용자 단말의 프로세서가 메모리 등과 같은 기록 장치에 저장된 프로그램 코드에 따라 생 성한 요청 또는 데이터(예를 들어, 이미지 검색 요청 등)는 통신 모듈의 제어에 따라 네트워크를 통 해 정보 처리 시스템으로 전달될 수 있다. 역으로, 정보 처리 시스템의 프로세서의 제어에 따 라 제공되는 제어 신호나 명령이 통신 모듈과 네트워크를 거쳐 사용자 단말의 통신 모듈을 통해 사용자 단말에 수신될 수 있다. 예를 들어, 사용자 단말은 정보 처리 시스템으로부터 통 신 모듈을 통해 입력 이미지와 연관된 정보, 데이터 및/또는 이미지 등을 수신할 수 있다. 입출력 인터페이스는 입출력 장치와의 인터페이스를 위한 수단일 수 있다. 일 예로서, 입력 장치는 오디오 센서 및/또는 이미지 센서를 포함한 카메라, 키보드, 마이크로폰, 마우스 등의 장치를, 그리고 출력 장 치는 디스플레이, 스피커, 햅틱 피드백 디바이스(haptic feedback device) 등과 같은 장치를 포함할 수 있다. 다른 예로, 입출력 인터페이스는 터치스크린 등과 같이 입력과 출력을 수행하기 위한 구성 또는 기능이 하 나로 통합된 장치와의 인터페이스를 위한 수단일 수 있다. 예를 들어, 사용자 단말의 프로세서가 메 모리에 로딩된 컴퓨터 프로그램의 명령을 처리함에 있어서 정보 처리 시스템이나 다른 사용자 단말이 제공하는 정보 및/또는 데이터를 이용하여 구성되는 서비스 화면 등이 입출력 인터페이스를 통해 디스플레 이에 표시될 수 있다. 도 3에서는 입출력 장치가 사용자 단말에 포함되지 않도록 도시되어 있으나, 이에 한정되지 않으며, 사용자 단말과 하나의 장치로 구성될 수 있다. 또한, 정보 처리 시스템의 입 출력 인터페이스는 정보 처리 시스템과 연결되거나 정보 처리 시스템이 포함할 수 있는 입력 또 는 출력을 위한 장치(미도시)와의 인터페이스를 위한 수단일 수 있다. 도 3에서는 입출력 인터페이스(318, 338)가 프로세서(314, 334)와 별도로 구성된 요소로서 도시되었으나, 이에 한정되지 않으며, 입출력 인터페이스 (318, 338)가 프로세서(314, 334)에 포함되도록 구성될 수 있다. 사용자 단말 및 정보 처리 시스템은 도 3의 구성요소들보다 더 많은 구성요소들을 포함할 수 있다. 그러나, 대부분의 종래기술적 구성요소들을 명확하게 도시할 필요성은 없다. 일 실시예에 따르면, 사용자 단말 은 상술된 입출력 장치 중 적어도 일부를 포함하도록 구현될 수 있다. 또한, 사용자 단말은 트 랜시버(transceiver), GPS(Global Positioning system) 모듈, 카메라, 각종 센서, 데이터베이스 등과 같은 다 른 구성요소들을 더 포함할 수 있다. 예를 들어, 사용자 단말이 스마트폰인 경우, 일반적으로 스마트폰이 포함하고 있는 구성요소를 포함할 수 있으며, 예를 들어, 가속도 센서, 자이로 센서, 카메라 모듈, 각종 물리적 인 버튼, 터치패널을 이용한 버튼, 입출력 포트, 진동을 위한 진동기 등의 다양한 구성요소들이 사용자 단말 에 더 포함되도록 구현될 수 있다. 일 실시예에 따르면, 사용자 단말의 프로세서는 이미지 기반 서비스를 제공하는 어플리케이션 등이 동작하도록 구성될 수 있다. 이 때, 해당 어플리케이션 및/또는 프로그램과 연관된 코드가 사용자 단말의 메모리에 로딩될 수 있다. 어플리케이션 및/또는 프로그램이 동작되는 동안에, 사용자 단말의 프로 세서는 입출력 장치로부터 제공된 정보 및/또는 데이터를 입출력 인터페이스를 통해 수신하거나 통신 모듈을 통해 정보 처리 시스템으로부터 정보 및/또는 데이터를 수신할 수 있으며, 수신된 정보 및/또는 데이터를 처리하여 메모리에 저장할 수 있다. 또한, 이러한 정보 및/또는 데이터는 통신 모듈 을 통해 정보 처리 시스템에 제공할 수 있다. 이미지 기반 서비스 어플리케이션 등을 위한 프로그램이 동작되는 동안에, 프로세서는 입출력 인터페이스 와 연결된 터치 스크린, 키보드, 오디오 센서 및/또는 이미지 센서를 포함한 카메라, 마이크로폰 등의 입 력 장치를 통해 입력되거나 선택된 텍스트, 이미지, 영상, 음성 등을 수신할 수 있으며, 수신된 텍스트, 이미지, 영상 및/또는 음성 등을 메모리에 저장하거나 통신 모듈 및 네트워크를 통해 정보 처리 시스템에 제공할 수 있다. 일 실시예에서, 프로세서는 입력 장치를 통해 이미지 기반 서비스 어플리 케이션 상에서 사용자에 의해 입력된 이미지에 대한 데이터를 네트워크 및 통신 모듈을 통해 정보 처 리 시스템에 제공할 수 있다. 정보 처리 시스템의 프로세서는 복수의 사용자 단말 및/또는 복 수의 외부 시스템으로부터 수신된 정보 및/또는 데이터를 관리, 처리 및/또는 저장하도록 구성될 수 있다. 일 실시예에서, 정보 처리 시스템은 사용자 단말로부터 수신한 이미지에 대한 데이터에 대응하는 정보, 데이터 및/또는 이미지를 사용자 단말로 제공할 수 있다. 도 4는 본 개시의 일 실시예에 따른 프로세서의 상세 블록도이다. 도시된 바와 같이, 프로세서는 인 공 신경망 모델 학습부, 임베딩 특징 생성부, 프록시 결정부 및 가상 클래스 생성부를 포 함할 수 있다. 학습 데이터 DB는 학습 데이터를 포함할 수 있으며, 프로세서는 학습 데이터 DB으로부터 학습 데이터를 수신할 수 있다. 학습 데이터는 복수의 클래스로 분류될 수 있다. 예를 들어, 학습 데이터는 제1 클래스와 연관된 학습 데이터, 제2 클래스와 연관된 학습 데이터 등을 포함할 수 있다. 학습 데 이터 DB는 정보 처리 시스템의 내부에 포함되거나, 외부 시스템 또는 외부 저장 장치에 포함되어 프로세서 와 연결될 수 있다. 일 실시예에서, 인공 신경망 모델 학습부는 학습 데이터 DB로부터 초기 인공 신경망 모델을 생성하기 위한 학습 데이터 세트를 수신하여, 메트릭 학습을 통해 초기 인공 신경망 모델을 생성할 수 있다. 예를 들어, 인공 신경망 모델 학습부는 학습 데이터 세트에 기초하여 프록시 기반 손실 함수를 이용하여 초기 인공 신 경망 모델을 생성할 수 있다. 여기서, 프록시 기반 손실 함수는 Softmax, Norm-Softmax, SphereFace, CosFace, ArcFace, Proxy-NCA, SoftTriple, Proxy-Anchor 등과 같이 샘플(앵커)과 프록시들 사이의 유사도/거 리를 기준으로 손실을 계산하는 모든 손실 함수 중 하나 일 수 있다. 메트릭 학습의 목적은 통해 동일한 클래 스의 학습 데이터를 서로 가깝게 배치하고, 서로 다른 클래스의 학습 데이터를 서로 멀게 배치하도록 인공 신경 망 모델을 학습하는 것이다. 예를 들어, 메트릭 학습을 통해 생성된 인공 신경망 모델은 제1 클래스와 연관된 학습 데이터가 서로 가깝게 배치되고, 제2 클래스와 연관된 학습 데이터가 서로 가깝게 배치되고, 제1 클래스와 연관된 학습 데이터와 제2 클래스와 연관된 학습 데이터가 서로 멀게 배치되는 임베딩 공간을 구축할 수 있다. 대안적으로, 프로세서는 정보 처리 시스템의 외부 시스템, 외부 저장 장치 또는 내부 저장 장치로부터 이 미 생성된 초기 인공 신경망 모델을 수신할 수 있다. 임베딩 특징 생성부는 학습 데이터 DB로부터 복수의 학습 데이터를 수신하고, 수신된 복수의 학습 데 이터를 인공 신경망 모델에 입력하여 복수의 학습 데이터 각각과 대응하는 복수의 임베딩 특징을 생성할 수 있 다. 여기서, 복수의 학습 데이터는 학습 데이터 DB에 저장된 전체 학습 데이터의 일부일 수 있다. 일 실 시예에서, 임베딩 특징 생성부가 수신한 복수의 학습 데이터는 제1 클래스의 복수의 학습 데이터와 제2 클 래스의 복수의 학습 데이터를 포함할 수 있다. 임베딩 특징 생성부는 수신된 제1 클래스의 복수의 학습 데이터와 제2 클래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 제1 클래스의 복수의 학습 데이터에 대응하는 제1 클래스의 복수의 임베딩 특징 및 제2 클래스의 복수의 학습 데이터에 대응하는 제2 클래스의 복수 의 임베딩 특징을 생성할 수 있다. 일 실시예에서, 프록시 결정부는 임베딩 특징 생성부가 생성한 각 클래스에 포함된 임베딩 특징에 기 초하여 각 클래스의 프록시를 결정할 수 있다. 예를 들어, 프록시 결정부는 제1 클래스의 복수의 임베딩 특징에 기초하여 제1 클래스의 프록시를 결정하고, 제2 클래스의 복수의 임베딩 특징에 기초하여 제2 클래스의 프록시를 결정할 수 있다. 여기서, 프록시 결정부는 각 클래스에 포함된 복수의 임베딩 특징들의 중간값 또는 평균값을 각 클래스의 프록시로 결정할 수 있다. 프록시는 각 클래스를 대표하는 대표값일 수 있다. 가상 클래스 생성부는 가상 임베딩 특징과 가상 클래스의 프록시를 포함하는 가상 클래스를 생성할 수 있 다. 일 실시예에서, 가상 클래스 생성부는 제1 클래스의 복수의 임베딩 특징 및 제2 클래스의 복수의 임 베딩 특징에 기초하여 가상 임베딩 특징을 생성하고, 제1 클래스의 프록시 및 제2 클래스의 프록시에 기초하여 가상 클래스의 프록시를 생성할 수 있다. 여기서, 가상 클래스, 제1 클래스 및 제2 클래스는 서로 상이한 클래 스일 수 있다. 일 실시예에서, 가상 클래스 생성부는 제1 클래스의 복수의 임베딩 특징 중 하나 및 제2 클래스의 복수의 임베딩 특징 중 하나에 기초하여 선형보간법(linear interpolation)을 이용하여 가상 임베딩 특징을 생성할 수 있다. 또한, 가상 클래스 생성부는 제1 클래스의 프록시 및 제2 클래스의 프록시에 기초하여 선형보간법 을 이용하여 가상 클래스의 프록시를 생성할 수 있다. 예를 들어, 가상 클래스 생성부는 아래 수학식 1을 사용하여 가상 임베딩 특징과 가상 클래스의 프록시를 생성할 수 있다. 수학식 1"}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "여기서, 는 제1 클래스의 복수의 임베딩 특징 중 하나와 제1 클래스의 프록시를 나타내고, 는 제2 클래스의 복수의 임베딩 특징 중 하나와 제2 클래스의 프록시를 나타내고, 는 가상 임베딩 특징()과 가 상 클래스의 프록시( )를 나타내고, 는 선형보간법 계수를 나타낸다. 수학식 1에서 확인할 수 있는 바와 같 이 가상 클래스 생성부는 동일한 선형보간법 계수( )를 사용하여 가상 임베딩 특징과 가상 클래스의 프록 시를 생성할 수 있다. 여기서, 사용되는 선형보간법 계수( )는 베타 분포(beta distribution)를 이용하여 결정 될 수 있다. 예를 들어, 선형보간법 계수( )는 (여기서, 는 를 만족하는 베타 분포 함수의 파라미터)분포에 따라 결정될 수 있으며, 이렇게 결정된 선형보간법 계수( )는 0과 1 사이의 실수일 수 있다. 상술한 가상 클래스 생성법에 따라 가상 클래스 생성부는 복수의 가상 클래스를 생성할 수 있다. 일 실시 예에서, 가상 클래스 생성부는 미리 결정된 생성률(μ)을 이용하여 생성할 가상 클래스의 수를 결정할 수 있다. 구체적으로, 가상 클래스 생성부는 미니 배치 사이즈에 생성률(μ)을 곱해서 생성할 가상 클래스의 수를 결정할 수 있다. 여기서, 미니 배치 사이즈는 임베딩 특징 생성부가 학습 데이터 DB로부터 수 신하는 학습 데이터의 수를 나타낼 수 있다. 인공 신경망 모델 학습부는 가상 클래스 생성부에서 생성한 가상 임베딩 특징과 가상 클래스의 프록 시를 포함하는 가상 클래스를 사용하여 인공 신경망 모델을 학습/업데이트할 수 있다. 일 실시예에서, 인공 신 경망 모델 학습부는 생성된 가상 임베딩 특징 및 가상 클래스의 프록시에 기초하여 프록시 기반 손실 함수 를 이용하여 인공 신경망 모델을 업데이트 할 수 있다. 예를 들어, 프록시 기반 손실 함수는 앵커 임베딩 특징 과 각 클래스의 프록시 사이의 거리에 기초하여 손실값을 산출할 수 있다. 이러한 프록시 기반 손실 함수는 아 래 수학식 2와 같이 산출될 수 있다. 수학식 2"}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "여기서, 는 학습 데이터 DB로부터 수신된 학습 데이터에 대응하는 복수의 임베딩 특징(즉, 기존의 임베 딩 특징)과 새로 생성된 가상 클래스의 가상 임베딩 특징을 포함하는 임베딩 특징 세트를 나타내고, 는 학습 데이터 DB로부터 수신된 학습 데이터에 대응하는 복수의 임베딩 특징을 기초로 결정된 프록시(즉, 기존의 프록시)와 가상 클래스의 프록시를 포함하는 프록시 세트를 나타내고, 는 기존의 임베딩 특징-프록시 쌍과 선형보간법 계수( )로 생성된 가상 임베딩 특징-가상 클래스의 프록시 쌍의 분포를 나타낸다. 예를 들어, 수학 식 2의 는 아래의 수학식 3 내지 6 중 하나일 수 있다. 수학식 3 수학식 4"}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "수학식 5"}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "수학식 6"}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "여기서, 는 를 제외한 모든 프록시의 집합을 나타내고, 와 는 각각 a와 b사이의 유클리디 안 거리와 코사인 유사도를 나타내고, 는 스케일 값을 나타낸다. 일 실시예에서, 인공 신경망 모델 학습부는 제1 클래스의 복수의 임베딩 특징 중 하나와 제1 클래스의 프 록시 사이의 거리가 가까워지고, 제1 클래스의 복수의 임베딩 특징 중 하나와 가상 클래스의 프록시가 멀어지고, 제1 클래스의 복수의 임베딩 특징 중 하나와 제2 클래스의 프록시가 멀어지도록 인공 신경망 모델을 업데이트 할 수 있다. 추가적으로 또는 대안적으로, 인공 신경망 모델 학습부는 가상 임베딩 특징과 가상 클래스의 프록시 사이의 거리가 가까워지고, 가상 임베딩 특징과 제1 클래스의 프록시가 멀어지고, 가상 임베딩 특징과 제2 클래스의 프록시가 멀어지도록 인공 신경망 모델을 업데이트할 수 있다. 추가적으로 또는 대안적으 로, 인공 신경망 모델 학습부는 제2 클래스의 복수의 임베딩 특징 중 하나와 제2 클래스의 프록시 사이의 거리가 가까워지고, 제2 클래스의 복수의 임베딩 특징 중 하나와 가상 클래스의 프록시가 멀어지고, 제2 클래스 의 복수의 임베딩 특징 중 하나와 제1 클래스의 프록시가 멀어지도록 인공 신경망 모델을 업데이트 할 수 있다. 도 5a는 본 개시의 일 실시예에 따라 하나의 가상 클래스를 생성하는 예시를 나타내는 도면이다. 도시된 바와 같이, 제1 클래스는 2개의 임베딩 특징(512, 514)과 하나의 프록시를 포함할 수 있다. 여기서, 프록시는 제1 클래스를 대표하는 대표값일 수 있다. 마찬가지로, 제2 클래스는 2개의 임베딩 특징(522, 524)과 하나의 프록시를 포함하고, 제3 클래스는 2개의 임베딩 특징(532, 534)과 하나의 프록시를 포함할 수 있다. 일 실시예에서, 프로세서(예를 들어, 정보 처리 시스템의 적어도 하나의 프로세서)는 제1 내지 제3 클래스(510, 520, 530) 중 두 개의 클래스를 이용하여 가상 클래스를 생성할 수 있다. 예를 들어, 프로세서는 제1 클래스 와 제2 클래스 사이의 가상 클래스를 생성할 수 있다. 이 경우, 가상 클래스는 가상 임베 딩 특징과 가상 프록시를 포함할 수 있다. 구체적으로, 프로세서는 제1 클래스의 임베딩 특징(512, 514)들 중 하나의 임베딩 특징과 제2 클래스 의 임베딩 특징(522, 524)들 중 하나의 임베딩 특징에 기초하여 가상 임베딩 특징을 생성할 수 있다. 일 실시예에서, 프로세서는 선형보간법을 이용하여 가상 임베딩 특징을 생성할 수 있다. 이 경우, 가상 임베딩 특징은 임베딩 공간 상에서 두 개의 임베딩 특징(514, 524) 사이에 위치할 수 있다. 또한, 프로세서는 제1 클래스의 프록시와 제2 클래스의 프록시에 기초하여 가상 클래스 의 프록시를 생성할 수 있다. 일 실시예에서, 프로세서는 선형보간법을 이용하여 가상 클래스의 프록시를 생성할 수 있다. 여기서, 프로세서는 동일한 선형보간법 계수를 이용하여 가상 임베딩 특징 과 가상 클래스의 프록시를 생성할 수 있다. 이 경우, 가상 클래스의 프록시는 제1 클래스의 프록시와 제2 클래스의 프록시 사이에 위치할 수 있다. 이렇게 생성된 가상 임 베딩 특징 및 가상 클래스의 프록시는 가상 클래스를 구성할 수 있다. 도 5b는 본 개시의 일 실시예에 따라 하나의 가상 클래스를 사용하여 인공 신경망 모델을 업데이트하는 예 시를 나타내는 도면이다. 프로세서는 생성된 가상의 임베딩 특징과 가상 클래스의 프록시에 기 초하여 프록시 기반 손실 함수를 이용하여 인공 신경망 모델을 업데이트할 수 있다. 일 실시예에서, 프로세서 는 손실값이 작아지는 방향으로 인공 신경망 모델을 학습할 수 있다. 구체적으로, 프로세서는 앵커 임베딩 특징과 앵커 임베딩 특징이 속하는 제1 클래스의 프록시 사이의 거리가 가까워지도록, 앵커 임베딩 특징과 앵커 임베딩 특징이 속하지 않는 제2 클래스 , 제3 클래스 및 가상 클래스의 프록시들(526, 536, 544) 사이의 거리가 멀어지도록 인공 신경 망 모델을 업데이트할 수 있다. 도 5b에서는 제1 클래스의 임베딩 특징(512, 514) 중 하나의 임베딩 특징 을 앵커로 도시하고 있으나, 이에 한정되지 않으며, 임베딩 특징들(512, 514, 522, 524, 532, 534) 및 가 상 임베딩 특징 중 일부 또는 전부가 앵커 임베딩 특징이 될 수 있다. 예를 들어, 가상 임베딩 특징(54 2)이 앵커인 경우, 프로세서는 가상 임베딩 특징과 가상 클래스의 프록시 사이의 거리가 가까워 지고, 가상 임베딩 특징과 제1 클래스, 제2 클래스 및 제3 클래스의 프록시(516, 526, 536)가 멀어지도록 인공 신경망 모델을 업데이트할 수 있다. 도 5a 및 도 5b에는 임베딩 공간에 3개의 기존의 클래스(510, 520, 530)가 존재하는 것으로 도시되어 있으나, 이에 한정되지 않으며, 상이한 수의 클래스가 임베딩 공간에 존재할 수 있다. 또한, 도 5a 및 도 5b에는 각각 의 클래스(510, 520, 530)가 두 개의 임베딩 특징을 포함하는 것으로 도시되어 있으나, 이에 한정되지 않으며, 임의의 수의 임베딩 특징을 포함할 수 있다. 도 6a는 본 개시의 다른 실시예에 따라 세 개의 가상 클래스(640, 650, 660)를 생성하는 예시를 나타내는 도면 이다. 제1 클래스는 2개의 임베딩 특징(612, 614)과 하나의 프록시를 포함할 수 있다. 마찬가지로, 제2 클래스는 2개의 임베딩 특징(622, 624)과 하나의 프록시를 포함하고, 제3 클래스는 2개의 임베딩 특징(632, 634)과 하나의 프록시를 포함할 수 있다. 일 실시예에서, 프로세서(예를 들어, 정보 처리 시스템의 적어도 하나의 프로세서)는 제1 내지 제3 클래스(610, 620, 630) 중 두 개의 클래스 조합을 이용하여 복수의 가상 클래스를 생성할 수 있다. 예를 들어, 프로세서는 제1 클래스와 제2 클래스 사이의 제1 가상 클래스, 제2 클래스와 제3 클래스 사이의 제2 가상 클래스, 제1 클래스와 제3 클래스 사이의 제3 가상 클래스를 생성할 수 있다. 도시된 바와 같이, 프로세서는 제1 클래스의 임베딩 특징들 중 하나와 제2 클래스의 임베딩 특 징들 중 하나에 기초하여 제1 가상 임베딩 특징을 생성하고, 제1 클래스의 프록시와 제2 클래스 의 프록시에 기초하여 제1 가상 클래스의 프록시를 생성할 수 있다. 마찬가지로, 프로세서는 제2 클 래스의 임베딩 특징들 중 하나와 제3 클래스의 임베딩 특징들 중 하나에 기초하여 제2 가 상 임베딩 특징을 생성하고, 제2 클래스의 프록시와 제3 클래스의 프록시에 기초하여 제2 가상 클래스의 프록시를 생성할 수 있다. 마찬가지로, 프로세서는 제1 클래스의 임베딩 특징들 중 하나 와 제3 클래스의 임베딩 특징들 중 하나에 기초하여 제3 가상 임베딩 특징을 생성하고, 제 1 클래스의 프록시와 제3 클래스의 프록시에 기초하여 제3 가상 클래스의 프록시를 생성할 수 있다. 도 6b는 본 개시의 일 실시예에 따라 세 개의 가상 클래스(640, 650, 660)를 사용하여 인공 신경망 모델을 업데 이트하는 예시를 나타내는 도면이다. 프로세서는 생성된 가상 임베딩 특징들(642, 652, 662)과 가상 클래스들 의 프록시(644, 654, 664)에 기초하여 프록시 기반 손실 함수를 이용하여 인공 신경망 모델을 업데이트할 수 있 다. 일 실시예에서, 프로세서는 손실값이 작아지는 방향으로 인공 신경망 모델을 학습할 수 있다. 구체적으로, 프로세서는 앵커 임베딩 특징과 앵커 임베딩 특징이 속하는 제1 클래스의 프록시 사이의 거리가 가까워지도록, 앵커 임베딩 특징과 앵커 임베딩 특징이 속하지 않는 클래스의 프록시들(626, 636, 644, 654, 664) 사이의 거리가 멀어지도록 인공 신경망 모델을 업데이트할 수 있다. 도 6b 에서는 제1 클래스의 임베딩 특징 중 하나의 임베딩 특징을 앵커로 도시하고 있으나, 이에 한정되지 않으며, 임베딩 특징들(612, 614, 622, 624, 632, 634) 및 가상 임베딩 특징들(642, 652, 662) 중 일부 또는전부가 앵커 임베딩 특징이 될 수 있다. 도 6a 및 도 6b에는 임베딩 공간에 3개의 기존의 클래스(610, 620, 630)가 존재하는 것으로 도시되어 있으나, 이에 한정되지 않으며, 상이한 수의 클래스가 임베딩 공간에 존재할 수 있다. 또한, 도 6a 및 도 6b에는 각각의 클래스(610, 620, 530)가 두 개의 임베딩 특징을 포함하는 것으로 도시되어 있으나, 이에 한정되지 않으며, 임의의 수의 임베딩 특징을 포함할 수 있다. 도 7은 본 개시의 일 실시예에 따른 가상의 학습 데이터 생성 방법을 나타내는 흐름도이다. 일 실시예에 서, 가상의 학습 데이터를 생성하는 방법은 프로세서(예를 들어, 정보 처리 시스템의 적어도 하나의 프로 세서)에 의해 수행될 수 있다. 도시된 바와 같이, 가상의 학습 데이터를 생성하는 방법은 프로세서가 제1 클래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 제1 클래스의 복수의 학습 데이터에 대응하는 제1 클래스의 복수의 임베딩 특징을 생성함으로써 개시될 수 있다(S710). 여기서, 인공 신경망 모델은 학습 데이터 세트에 기초하여 프록시 기반 손실 함수를 이용하여 생성된 것일 수 있다. 그 후, 프로세서는 제1 클래스의 복 수의 임베딩 특징에 기초하여 제1 클래스의 프록시를 결정할 수 있다(S720). 예를 들어, 제1 클래스의 프록시 는 제1 클래스의 복수의 임베딩 특징들의 중간값 또는 평균값일 수 있다. 또한, 프로세서는 제2 클래스의 복수의 학습 데이터를 인공 신경망 모델에 입력하여 제2 클래스의 복수의 학습 데이터에 대응하는 제2 클래스의 복수의 임베딩 특징을 생성할 수 있다(S730). 한편, 제1 클래스의 복수의 학 습 데이터 및 제2 클래스의 복수의 학습 데이터는 인공 신경망 모델을 생성, 학습하기 위해 사용된 학습 데이터 세트의 서브세트일 수 있다. 그 후, 프로세서는 제2 클래스의 복수의 임베딩 특징에 기초해서 제2 클래스의 프 록시를 결정할 수 있다(S740). 예를 들어, 제2 클래스의 프록시는 제2 클래스의 복수의 임베딩 특징들의 중간 값 또는 평균값일 수 있다. 그 후, 프로세서는 제1 클래스의 복수의 임베딩 특징 및 제2 클래스의 복수의 임베딩 특징에 기초하여 가상 임 베딩 특징을 생성할 수 있다(S750). 일 실시예에서, 제1 클래스의 복수의 임베딩 특징 중 하나 및 제2 클래스 의 복수의 임베딩 특징 중 하나에 기초하여 선형보간법(linear interpolation)을 이용하여 가상 임베딩 특징을 생성할 수 있다. 여기서, 선형보간법 계수는 베타 분포(beta distribution)를 이용하여 결정될 수 있다. 또한, 프로세서는 제1 클래스의 프록시 및 제2 클래스의 프록시에 기초하여 가상 클래스의 프록시를 생성할 수 있다(S760). 일 실시예에서, 제1 클래스의 프록시 및 제2 클래스의 프록시에 기초하여 선형보간법을 이용하여 가상 클래스의 프록시를 생성할 수 있다. 이 때, 사용되는 선형보간법 계수는 가상 임베딩 특징을 생성할 때 사용되는 선형보간법 계수와 동일 할 수 있다. 제1 클래스의 프록시와 제2 클래스의 프록시 사이의 거리는, 제 1 클래스의 프록시와 가상 클래스의 프록시 사이의 거리, 그리고 제2 클래스의 프록시와 가상 클래스의 프록시 사이의 거리보다 멀 수 있다. 상술한 가상의 학습 데이터 생성 방법에 따라 생성된 가상 임베딩 특징은 가상 클래스에 속할 수 있으며, 가상 클래스는 제1 클래스 및 제2 클래스와 상이할 수 있다. 일 실시예에서, 생성된 가상 임베딩 특징 및 가상 클래스의 프록시에 기초하여 프록시 기반 손실 함수를 이용하 여 인공 신경망 모델을 업데이트할 수 있다. 여기서, 프록시 기반 손실 함수는 앵커 임베딩 특징과 각 클래스 의 프록시 사이의 거리에 기초하여 손실값을 산출할 수 있다. 예를 들어, 프록시 기반 손실 함수는 앵커 임베 딩 특징과 앵커 임베딩 특징이 속하는 클래스의 프록시 사이의 거리가 가까울수록 손실이 적고, 앵커 임베딩 특 징과 앵커 임베딩 특징이 속하지 않는 클래스의 프록시 사이의 거리가 가까울수록 손실이 큰 것으로 손실값을 정의할 수 있다. 구체적으로, 프로세서는 제1 클래스의 복수의 임베딩 특징 중 하나와 제1 클래스의 프록시 사 이의 거리가 가까워지고, 제1 클래스의 복수의 임베딩 특징 중 하나와 가상 클래스의 프록시가 멀어지고, 제1 클래스의 복수의 임베딩 특징 중 하나와 제2 클래스의 프록시가 멀어지도록 인공 신경망 모델을 업데이트할 수 있다. 추가적으로 또는 대안적으로, 프로세서는 가상 임베딩 특징과 가상 클래스의 프록시 사이의 거리가 가까 워지고, 가상 임베딩 특징과 제1 클래스의 프록시가 멀어지고, 가상 임베딩 특징과 제2 클래스의 프록시가 멀어 지도록 인공 신경망 모델을 업데이트할 수 있다. 일 실시예에서, 프로세서는 제1 이미지에 대한 데이터를 수신하고, 수신된 제1 이미지에 대한 데이터를 업데이 트된 인공 신경망 모델에 입력하여 미리 저장된 복수의 이미지 중 제1 이미지와 가장 유사도가 높은 제2 이미지 에 대한 데이터를 출력할 수 있다. 도 8은 본 개시의 일 실시예에 따른 인공 신경망 모델의 학습/업데이트에 있어서, 가상의 학습 데이터 사용 여 부에 따른 성능 차이를 시각적으로 비교하기 위한 그래프이다. 제1 그래프는 가상 학습 데이터를 사용하 지 않은 경우의 입력 공간을 시각화한 것을 나타내고, 제2 그래프는 가상 학습 데이터를 사용한 경우의 입 력 공간을 시각화한 것을 나타내고, 제3 그래프는 가상 학습 데이터를 사용하지 않은 경우의 임베딩 공간 을 시각화한 것을 나타내고, 제4 그래프는 가상 학습 데이터를 사용한 경우의 임베딩 공간을 시각화한 것을 나타낸다. 본 성능 평가를 위해, 빨간색, 파란색 및 회색의 세 가지 클래스를 포함하는 2D 등방성 가우시안 (2D isotropic Gaussian) 데이터 세트를 사용하고, 메트릭 학습을 위해 2 차원 임베딩을 가지는 심플 피드 포워 드 네트워크(simple feed-forward network with two-dimension embedding)를 사용하고, 프록시 기반 손실 함수 로 Norm-Softmax를 사용한다. 또한, 빨간색과 파란색 두 개의 클래스를 기초로 가상의 학습 데이터 생성 및/또 는 인공 신경망 모델을 학습/업데이트하고, 회색의 클래스는 학습 데이터로 사용하지 않는다. 제1 내지 제4 그래프(810, 820, 830, 840)를 통해, 입력 공간과 임베딩 공간 모두에 대하여, 가상의 학습 데이 터를 사용하지 않은 경우의 결과에서는 엄격한 결정 경계(strict decision boundary)가 나타나는 반면, 가상의 학습 데이터를 사용한 경우의 결과에서는 빨간색 클래스에서 파란색 클래스로 선형으로 전환되는 부드러운 결정 경계(smooth decision boundary)가 나타나는 것을 확인할 수 있다. 또한, 가상의 학습 데이터를 사용하지 않은 경우의 임베딩 공간보다 가상의 학습 데이터를 사용한 경우의 임베딩 공간이 임베딩 특징들의 더 좋은 위치 구 조를 갖는 것을 확인할 수 있다. 또한, 학습되지 않은 회색 클래스의 입력 데이터가 빨간색과 파란색 클래스 사이에 있음을 고려할 때, 본 개시의 실시예에 따라 생성된 가상의 학습 데이터를 사용하여 학습/업데이트된 인 공 신경망 모델이 임베딩 특징들의 선형 위치 관계를 제공하는 것을 제4 그래프를 통해 확인할 수 있다. 따라서, 본 개시의 실시예들에 따라 생성된 가상의 학습 데이터를 사용하여 인공 신경망 모델을 학습/업데이트 하는 경우, 인공 신경망 모델은 클래스 간의 관계를 고려하여 부드러운 결정 경계를 가지는 임베딩 공간을 구축 할 수 있다. 도 9는 본 발명의 일 실시예에 따라 생성된 가상의 학습 데이터를 사용하여 인공 신경망 모델을 학습/업데이트 한 경우의 통합 네트워크의 t-SNE 시각화 결과를 나타낸다. 여기서, 인공 신경망 모델 학습/업데이트를 위해 CARS196 데이터 세트를 사용한다. 제1 그래프에서는 인공 신경망 모델이 학습한 학습 데이터의 임베딩 특 징과 학습하지 않은 테스트 임베딩 특징이 도시되어 있으며, 제2 그래프에서는 제1 그래프와 동일한 학습 데이터의 임베딩 특징과 본 개시의 실시예들에 따라 생성된 가상 임베딩 특징 및 가상 클래스의 프록시가 도시되어 있다. 제1 그래프와 제2 그래프에서 파란색 포인트는 인공 신경망 모델이 학습한 클래스의 프록시, 회색 포인트는 학습한 임베딩 특징, 분홍색 포인트는 학습하지 않은 임베딩 특징, 빨간색 포인트는 가 상 클래스의 프록시, 초록색 포인트는 가상 임베딩 특징을 나타낸다. 한편, 제1 그래프 및 제2 그래프 에서 사용된 인공 신경망 모델은 가상의 학습 데이터 생성을 위한 베타 분포 함수의 파라미터(α)를 0.4로 설정하고, 생성률(μ)을 1.0으로 설정하고, 512 임베딩 차원을 포함하는 배치 정규화된 Inception 네트워크에 대한 학습 과정에 따라 학습/업데이트된 모델이다. 제1 그래프에서 인공 신경망 모델이 학습하지 않은 테스트 임베딩은 클러스터를 형성하여 학습한 임베딩 특징들의 클러스터 사이에 위치한다. 이와 유사하게, 가상 클래스는 제2 그래프에 도시된 바와 같이, 학 습한 임베딩 특징들 사이에 생성되며, 이러한 가상 클래스는 학습하지 않은 클래스를 모방하는 기능을 한다. 따라서, 이러한 가상 클래스는 인공 신경망이 차별성 있는(discriminative) 임베딩 특징들(즉, 학습한 임베딩 특징들 사이의 임베딩 특징들)을 추가로 학습하여, 학습하지 않은 클래스에 대한 더 나은 강인성을 갖도록 할 수 있다. 즉 학습하지 않은 클래스에 대한 강인성을 향상시키기 위해, 본 개시의 실시예들에 따라 생성된 가상 클래스를 이용하는 것이 메트릭 학습에서 바람직하다. 한편, 추가 학습 데이터로서 가상 클래스의 정량적 성능을 평가하기 위해, Norm-Softmax 손실 산출에 사용되는 임베딩 특징과 프록시의 구성을 달리하여 성능 평가를 수행하였다. 아래 표 1은 기존의 임베딩 특징 ('Embedding-Org'), 가상 임베딩 특징('Embedding-Syn'), 기존의 프록시('Proxy-Org') 및 가상 프록시('Proxy- Syn') 중 일부 또는 전부를 사용하는 각각의 경우에서의 재현율(recall)을 나타낸다. 표 1 Model Embedding Proxy Recall@1 Org Syn Org Syn M1 (baseline) o o 83.3 M2 o o 83.1 M3 o o o 83.7 M4 o o o 83.7 Proxy Synthesis o o o o 84.7 위의 표 1을 통해, 인공 신경망 모델을 학습/업데이트 하는데 있어서, 가상 임베딩 특징과 가상 클래스의 프록 시만 사용하는 경우(M2)에 기존의 임베딩 특징과 기존의 프록시만 사용한 경우(M1)보다 성능이 근소하게 저하된 다는 것을 확인할 수 있다. 이는 생성된 가상 임베딩 특징 및 가상 프록시가 인공 신경망 모델 학습에 있어서 의미 있는 가상 클래스를 구축한다는 것을 나타낸다. 또한, 기존의 임베딩 특징, 기존의 프록시 및 가상 프록 시를 사용한 경우(M3)에 기존의 임베딩 특징과 기존의 프록시만 사용한 경우(M1)보다 성능이 향상된다는 것을 확인할 수 있다. 이는, 가상 임베딩 특징 없이 가상 프록시만을 추가 학습 데이터로 사용하더라도 인공 신경망 모델의 학습에 있어서 긍정적인 영향을 미친다는 것을 나타낸다. 또한, 기존의 임베딩 특징 없이 가상 임베딩 특징, 기존의 프록시 및 가상 클래스의 프록시를 사용하는 경우(M4)에 기존의 임베딩 특징, 기존의 프록시 및 가상 클래스의 프록시를 사용한 경우(M3)와 유사한 성능을 나타낸다. 이는 가상 임베딩 특징과 가상 프록시로 가상 클래스를 형성하는 것이 인공 신경망 모델을 학습/업데이트하기 위해 충분히 차별성 있는 정보를 제공할 수 있음을 나타낸다. 마지막으로 본 개시의 실시예들에 따라 기존의 임베딩 특징, 기존의 프록시, 가상 임베딩 특징 및 가상 프록시를 사용하는 경우('proxy synthesis')에 가장 좋은 성능이 나타남을 확인할 수 있다. 도 10은 본 개시의 일 실시예에 따른 인공 신경망 모델의 학습/업데이트에 있어서, 가상의 학습 데이터 사용 여 부에 따른 성능 차이를 열지도 시각화(Heatmap visualization) 결과로 비교하기 위한 그래프이다. 제1 그래프 는 가상 클래스를 사용하지 않고 인공 신경망 모델을 학습한 경우, 100번째 에포크(epoch)에서의 임베딩 특징과 프록시 사이의 코사인 유사성(logit)의 열지도 시각화(Heatmap visualization) 결과를 나타낸다. 제2 그래프는 가상 클래스를 사용하지 않고 인공 신경망 모델을 학습한 경우, 100번째 에포크에서의 임베딩 특징과 프록시 사이의 코사인 유사성의 열지도 시각화 결과이다. 도시된 컬러바는 신뢰도를 나타내고, 는 기 존의 클래스 i의 임베딩 특징을 나타내고, 는 기존의 클래스 i의 프록시를 나타내고, 는 기존의 클래스 i 와 임의의 클래스를 기초로 생성된 가상 임베딩 특징을 나타내고, 는 기존의 클래스 i와 임의의 클래스를 기 초로 생성된 가상 클래스의 프록시를 나타내고, C는 사용된 클래스의 수를 나타내고, 는 GT(ground truth) 로짓 대각선(logits diagonal)을 나타내고, 는 경쟁자(competitor) 로짓 대각선을 나타낸다. 가상 클래스를 생성하는 것은 인공 신경망 모델이 더 많은 차별성 있는 학습 데이터를 학습할 수 있도록 기존의 학습 데이터에 대하여 충분히 어려워야 한다. 가상 클래스의 난이도(hardness values)는 선형보간법 계수( )의 샘플링 확률을 결정하는 베타 분포 함수의 파라미터( )에 의해 제어될 수 있다. 아래 표 2는 고정 선형보간법 계수에 따른 인공 신경망 모델의 재현율('Static')(표 2의 좌측) 및 확률적인 선형보간법 계수에 따른 인공 신 경망 모델의 재현율('stochastic')(표 2의 우측)을 나타낸다. 표 2 Static Stochastic Recall@1 α Recall@1 0.1 83.1 0.2 84 0.2 83.8 0.4 84.7 0.3 83.7 0.8 83.9 0.4 83.5 1 83.7 0.5 83.3 1.5 83.7 고정 선형보간법 계수( )를 0.1로 설정하는 경우에는 기존의 클래스에 너무 근접한 가상 클래스를 생성하기 때 문에 인공 신경망 모델의 재현율이 낮다. 또한, 고정 선형보간법 계수( )를 0.5로 설정하는 경우에도, 상대적 으로 구별하기 쉬운 두 개의 기존의 클래스들 중간에 가상 클래스를 생성하므로 인공 신경망 모델의 재현율이 낮다. 표 2에서 고정 선형보간법 계수( )는 기존의 클래스들과 구별하기 너무 어렵거나 너무 쉽지 않은 0.2 주 변으로 설정하는 것이 바람직한 것을 확인할 수 있다. 또한, 표 2를 통해, 가상 클래스를 확률적으로 생성하는 경우가 고정적으로 생성하는 경우보다 좋은 성능의 인 공 신경망 모델을 제공하는 것을 확인할 수 있다. 이는, 가상 클래스를 확률적 생성하는 경우에, 넓은 범위의변화량(variation)을 갖는 상이한 가상 클래스들을 더 많이 생성할 수 있기 때문이다. 가상 클래스를 확률적으 로 생성하는데 있어서, 베타 분포 함수의 파라미터(α)를 1.0으로 설정하면 베타 분포가 균등 분포(uniform distribution)와 동일해지고, 베타 분포 함수의 파라미터(α)를 1.5로 설정하면 가상 클래스가 두 클래스의 중 간에 생성될 확률이 높으므로, 상대적으로 인공 신경망 모델의 재현율이 낮다. 반면, 베타 분포 함수의 파라미 터(α)를 약 0.4로 설정하면, 기존의 클래스와 충분히 근접한 가상 클래스를 생성할 확률이 높아지며, 인공 신 경망 모델의 재현율이 가장 높다. 가상 클래스의 난이도(hardness values)의 영향을 확인하기 위해, 제1 그래프 및 제2 그래프를 통 해, 가상 클래스를 사용하지 않은 경우와 가상 클래스를 사용한 경우의 학습 중 임베딩 특징과 프록시 간의 코 사인 유사성(로짓)을 비교할 수 있다. 제1 그래프에서 주 대각선 로 표시되는 GT의 로짓 값은 높은 예측 신뢰도로 인해 명확하게 빨간색으로 나타난다. 이는 상술한 도 8에서와 마찬가지로, 입력 공간 및 임베딩 공간에서 엄격한 결정 경계가 나타나도록 유도할 수 있으며, 과적합(overfitting) 문제를 유발할 수 있다. 반면, 제2 그래프의 및 의 GT 로짓 값은 낮은 신뢰도로 인해 노란색에서 주황색으로 나타날 수 있다. 기존의 클래스 주변에 생성된 가상 클래스가 어려운 경쟁자(hard competitor)( 및 )로 작용하여, 예측 신뢰도가 낮아지게 된다. 여기서, 제2 그래프의 주 대각선( 및 )의 신뢰도는 경 쟁자의 대각선( 및 )의 신뢰도보다 높아 동일한 임베딩 특징에 대해 더 붉게(또는 붉은 색에 가깝게) 표시된다. 이러한 구성에 의해 인공 신경망 모델이 구축하는 임베딩 공간에서의 결정 경계는 보다 부드러워지 며, 학습하지 않은 클래스에 대하여 보다 좋은 성능을 발휘할 수 있다. 일반적으로, 일반화가 잘된 인공 신경망 모델일수록 다양한 입력 변형에 대해서도 높은 강인성(robust)을 제공 한다. 아래 표 3은 학습하지 않은 다양한 변형을 가한 테스트 데이터를 사용하여 인공 신경망 모델의 성능을 평가한 것을 나타낸다. 표 3을 통해, 가상 클래스를 사용하여 학습된 인공 신경망 모델('PS+NS')이 다양한 입 력 변형에 대해서도 높은 재현율을 갖는 것을 확인할 수 있다. 표 3 Deformation NS PS+NS Cutout 75.377.0(+1.7) Dropout 59.762.2(+2.5) Zoom in 64.365.6(+1.3) Zoom out 78.380.0(+1.7) Rotation 70.872.1(+1.3) Shearing 70.372.0(+1.7) Gaussian noise 65.167.2(+2.1) Gaussian blur 74.476.3(+1.9) 한편, 가상 클래스를 사용하지 않은 경우의 인공 신경망 모델은 학습 데이터 세트 및 테스트 데이터 세트 모두 에 대하여 낮은 재현율을 나타내는 반면, 가상 클래스를 사용한 경우의 인공 신경망 모델은 학습 데이터 세트 및 테스트 데이터 세트 모두에서 가상 클래스를 사용하지 않은 경우에 비하여 거의 두 배 높은 재현율을 나타낸 다. 즉, 가상 클래스를 사용한 인공 신경망 모델이 학습 데이터에 대하여 더욱 강인한 임베딩 특징을 제공하며, 학습하지 않은 테스트 데이터에 대해서도 강인하다. 도 11은 선형보간법 계수( )를 결정하기 위한 베타 분포 함수의 파라미터(α)와 생성률(μ)의 값에 따른 인공 신경망 모델의 재현율을 나타내는 그래프이다. 여기서, 베타 분포 함수의 파라미터(α)는 0.2, 0.4, 0.8, 1.0, 1.5 또는 2.0으로, 생성률(μ)은 0.2, 0.5, 1.0, 1.5 또는 2.0으로 설정된다. 도 10을 참조하여 상술한 바와 같이, 베타 분포 함수의 파라미터(α)를 작은 값(예를 들어, 0.2에서 0.8사이의 값)으로 설정하는 경우, 기존의 클래스와 근접한 어려운 가상 클래스를 생성할 확률이 높아지므로 인공 신경망 모델의 재현율이 비교적 높게 나 타난다. 또한 도시된 것과 같이, 생성률(μ)을 약 1.0으로 설정하는 경우에 인공 신경망 모델의 재현율이 높게 나타난다. 이는 생성률(μ)을 너무 작은 값으로 설정하면, 가상 학습 데이터가 인공 신경망 모델 학습에 충분한 영향을 미치지 못하고, 반대로 생성률(μ)을 너무 큰 값으로 설정하여 가상 클래스가 너무 많으면, 기존의 학습 데이터의 학습을 방해할 수 있기 때문이다. 아래 표 4에서 확인할 수 있는 것과 같이, 본 개시의 실시예들에 따라 가상 클래스를 생성하고, 생성된 가상 클 래스를 사용하여 인공 신경망 모델을 학습/업데이트하는 방법은 메모리 사용과 학습 속도에 큰 영향을 주지 않 는다. 표 4는 생성률(μ)에 따른 처리 시간 및 사용 메모리 크기를 나타낸다. 구체적으로, 표 4는 배치 크기 (N)가 128일 때의, 가상 임베딩 특징 및 가상 프록시의 생성에 필요한 시간('Generation'), 손실 계산에 필요한 시간('Loss') 및 임베딩 특징 및 프록시의 수('# of feature')를 나타낸다. 표 4"}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "μTime(ms) Memory Generation Loss # of Features 0.0 - 0.558 N 0.2 0.232 0.872 (1+0.2)×N 0.5 0.233 0.873 (1+0.5)×N 1.0 0.435 1.09 (1+1.0)×N 1.5 0.449 1.3 (1+1.5)×N 2.0 0.467 1.53 (1+2.0)×N 표 4를 통해, 가상 클래스를 생성하는 데 필요한 처리 시간은 0.232 ms에서 0.467 ms이고, 생성된 가상 클래스 를 사용하여 손실을 산출하는데 필요한 처리 시간은 0.872 ms에서 1.530 ms라는 것을 확인할 수 있다. 이는 단 순한 선형 대수를 사용하여, 가상 클래스를 생성하고, 손실을 산출할 수 있기 때문이다. 메모리 측면에서, 가상 클래스를 사용하지 않는 경우 임베딩 특징과 프록시는 N개에 해당하고, 손실을 산출하기 위해 N×N의 유사성 행렬을 생성한다. 반면, 가상 클래스를 사용하는 경우, 임베딩 특징과 프록시는 (N + μ× N)개에 해당하고, 손실을 산출하기 위해 (N + μ×N)×(N + μ×N)의 유사성 행렬을 생성한다. 즉, 본 개시의 실시예들에 따라 가상 클래스를 생성하고, 생성된 가상 클래스를 사용하여 인공 신경망 모델을 학습/업데이트하 는 방법에서는 추가적인 순방향 전파(forward propagation)를 필요로 하지 않으므로, 메모리에 큰 영향을 주지 않는다. 도 12는 본 개시의 일 실시예에 따른 점진적으로 인공 신경망 모델을 업데이트하는 방법을 나타내는 흐름 도이다. 일 실시예에서, 방법은 프로세서(예를 들어, 정보 처리 시스템의 적어도 하나의 프로세서)에 의 해 수행될 수 있다. 도시된 바와 같이, 방법은 프로세서가 초기 인공 신경망 모델을 생성함으로써 개시 될 수 있다(S1210). 예를 들어, 프로세서는 초기 학습 데이터 세트에 기초하여 프록시 기반 손실 함수를 이용 하여 초기 인공 신경망 모델을 생성할 수 있다. 그 후, 프로세서는 가상의 학습 데이터를 생성할 수 있다(S1220). 예를 들어, 프로세서는 초기 인공 신경망 모 델을 생성하는데 사용된 학습 데이터 세트의 서브세트에 기초하여 가상의 학습 데이터를 생성할 수 있다. 여기 서, 학습 데이터 세트는 복수의 클래스를 포함할 수 있고, 복수의 클래스 각각은 복수의 임베딩 특징 및 프록시 를 포함할 수 있다. 가상의 학습 데이터를 생성하는 것에 응답하여, 프로세서는 가상의 학습 데이터에 기초하여 인공 신경망 모델을 업데이트할 수 있다(S1230). 예를 들어, 프로세서는 인공 신경망 모델을 생성하는데 사용된 학습 데이터 세트 와 생성된 가상의 학습 데이터를 사용하여 인공 신경망 모델을 업데이트할 수 있다. 이 때, 프로세서는 프록시 기반 손실 함수를 사용하여 손실 값이 작아지는 방향으로 인공 신경망 모델을 업데이트할 수 있다. 그 후, 프로세서는 추가 학습 데이터를 수신할 수 있다(S1240). 여기서, 추가 학습 데이터는 적어도 하나의 클 래스를 포함할 수 있고, 각 클래스는 복수의 임베딩 특징 및 프록시를 포함할 수 있다. 프로세서는 수신된 추 가 학습 데이트를 기초로 인공 신경망 모델을 업데이트 할 수 있다(S1250). 예를 들어, 프로세서는 단계 (S1210)에서 사용된 학습 데이터 세트 및/또는 단계(S1240)에서 수신한 추가 학습 데이터를 기초로 인공 신경망 모델을 업데이트할 수 있다. 대안적으로, 프로세서는 단계(S1210)에서 사용된 학습 데이터 세트, 단계(S1230) 에서 생성된 가상의 학습 데이터 및/또는 단계(S1240)에서 수신한 추가 학습 데이터를 기초로 인공 신경망 모델 을 업데이트할 수 있다. 그 후, 프로세서는 단계들(S1220 내지 S1250)을 반복적으로 수행함으로써, 인공 신경망 모델을 점진적으로 학습 /업데이트할 수 있다. 한편, 아래 표 5는 이미지 검색 수행에 있어서, 다양한 방법으로 학습된 인공 신경망 모 델의 4개의 벤치마크(benchmark)(CUB200, CARS196, SOP, In-Shop)에 대한 재현율(Recall@1 (%))을 나타낸다. 모든 방법들은 512 임베딩 차원을 사용한다. 또한, 아래 표 5의 'Net'에서 G는 GoogleNet을 나타내고, BN은 배 치 정규화된 Inception을 나타낸다. 표 5 Method Net CUB200 CARS196 SOP In-Shop A-BIER G57.5 - 82.0 -74.2 -83.1 - ABE G60.6 - 85.2 -76.3 -87.3 - HTL BN57.1 - 81.4 -74.8 - - - Multi-Similarity BN65.7 - 84.1 -78.2 -89.7 - Softmax BN64.2 - 81.5 -76.3 -90.4 - PS + Softmax BN64.9 (+0.7)84.3 (+2.8)77.6 (+1.3)90.9 (+0.5) Norm-softmax BN64.9 - 83.3 -78.6 -90.4 - PS + Norm-softmax BN66.0 (+1.1)84.7 (+1.4)79.6 (+1.0)91.5 (+1.1) SphereFace BN65.4 - 83.6 -78.9 -90.3 - PS + SphereFace BN66.6 (+1.2)85.1 (+1.5)79.4 (+0.5)91.6 (+1.3) CosFace BN65.7 - 83.6 -78.6 -90.7 - PS + CosFace BN66.6 (+0.9)84.6 (+1.0)79.3 (+0.7)91.4 (+0.7) ArcFace BN66.1 - 83.7 -78.8 -91.0 - PS + ArcFace BN66.8 (+0.7)84.7 (+1.0)79.7(+0.9)91.7 (+0.7) Proxy-NCA BN64.3 - 82.0 -78.1 -90.0 - PS + Proxy-NCA BN66.0 (+1.7)83.1 (+1.1)79.1 (+1.0)91.4 (+1.4) SoftTriple BN65.4 - 84.5 -78.3 -91.1 - PS + SoftTriple BN66.6 (+1.2)85.3 (+0.8)79.5 (+1.2)91.8(+0.7) Proxy-anchor BN68.4 - 86.1 -79.1 -91.5 - PS + Proxy-anchor BN69.2 (+0.8)86.9 (+0.8)79.8 (+0.7)91.9 (+0.4) 프록시 기반 손실(예를 들어, Softmax, Norm-softmax, SphereFace, CosFace, ArcFace, Proxy-NCA, SoftTriple, Proxy-anchor)을 사용하는 모든 방법에 있어서, 가상 클래스를 사용한 경우(표 5에서, 'PS+'를 포함하는 항목) 가 가상 클래스를 사용하지 않은 경우(표 5에서, 'PS+'를 포함하지 않는 항목)보다 모든 벤치마크에 대한 재현 율이 더 높게 나타난다. 구체적으로, 'CUB200' 및 'CARS196'과 같이 카테고리가 적은 세분화된(fine-grained) 데이터 세트에서는, 가상 클래스를 사용한 경우의 재현율이 최소 0.7 %에서 최대 2.8 % 더 높게 나타나며, 평균 적으로 1.2 % 높게 나타난다. 또한, 'SOP' 및 'In-Shop'과 같은 다양한 카테고리가 있는 대규모 데이터 세트에 서는, 가상 클래스를 사용한 경우의 재현율이 최소 0.4 %에서 최대 1.4 % 더 높게 나타나며 평균적으로 0.9 % 높게 나타난다. 또한, 쌍 기반 손실을 사용하는 방법('HTL' 및 'Multi-Similarity') 및 앙상블(ensemble) 방 법 ('A-BIER' 및 'ABE')과 비교하여도, 가상 클래스를 사용한 경우의 재현율이 모든 벤치마크에 대하여 가장 높 다. 필요한 학습 시간과 메모리의 양을 고려할 때, 본 개시의 실시예들에 따라 가상 클래스를 생성하고, 가상 클래스를 사용하여 인공 신경망 모델을 학습하는 방법은 높은 효율성과 향상된 성능을 제공한다. 상술한 가상의 학습 데이터 생성 방법은 컴퓨터에서 실행하기 위해 컴퓨터 판독 가능한 기록 매체에 저장된 컴 퓨터 프로그램으로 제공될 수 있다. 매체는 컴퓨터로 실행 가능한 프로그램을 계속 저장하거나, 실행 또는 다 운로드를 위해 임시 저장하는 것일 수도 있다. 또한, 매체는 단일 또는 수개 하드웨어가 결합된 형태의 다양한 기록수단 또는 저장수단일 수 있는데, 어떤 컴퓨터 시스템에 직접 접속되는 매체에 한정되지 않고, 네트워크 상 에 분산 존재하는 것일 수도 있다. 매체의 예시로는, 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체, CD-ROM 및 DVD 와 같은 광기록 매체, 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체(magneto- optical medium), 및 ROM, RAM, 플래시 메모리 등을 포함하여 프로그램 명령어가 저장되도록 구성된 것이 있을 수 있다. 또한, 다른 매체의 예시로, 애플리케이션을 유통하는 앱 스토어나 기타 다양한 소프트웨어를 공급 내 지 유통하는 사이트, 서버 등에서 관리하는 기록매체 내지 저장매체도 들 수 있다. 본 개시의 방법, 동작 또는 기법들은 다양한 수단에 의해 구현될 수도 있다. 예를 들어, 이러한 기법들은 하드 웨어, 펌웨어, 소프트웨어, 또는 이들의 조합으로 구현될 수도 있다. 본원의 개시와 연계하여 설명된 다양한 예시적인 논리적 블록들, 모듈들, 회로들, 및 알고리즘 단계들은 전자 하드웨어, 컴퓨터 소프트웨어, 또는 양자 의 조합들로 구현될 수도 있음을 통상의 기술자들은 이해할 것이다. 하드웨어 및 소프트웨어의 이러한 상호 대체를 명확하게 설명하기 위해, 다양한 예시적인 구성요소들, 블록들, 모듈들, 회로들, 및 단계들이 그들의 기능 적 관점에서 일반적으로 위에서 설명되었다. 그러한 기능이 하드웨어로서 구현되는지 또는 소프트웨어로서 구 현되는지의 여부는, 특정 애플리케이션 및 전체 시스템에 부과되는 설계 요구사항들에 따라 달라진다. 통상의 기술자들은 각각의 특정 애플리케이션을 위해 다양한 방식들로 설명된 기능을 구현할 수도 있으나, 그러한 구현 들은 본 개시의 범위로부터 벗어나게 하는 것으로 해석되어서는 안된다. 하드웨어 구현에서, 기법들을 수행하는 데 이용되는 프로세싱 유닛들은, 하나 이상의 ASIC들, DSP들, 디지털 신 호 프로세싱 디바이스들(digital signal processing devices; DSPD들), 프로그램가능 논리 디바이스들 (programmable logic devices; PLD들), 필드 프로그램가능 게이트 어레이들(field programmable gate arrays; FPGA들), 프로세서들, 제어기들, 마이크로제어기들, 마이크로프로세서들, 전자 디바이스들, 본 개시에 설명된 기능들을 수행하도록 설계된 다른 전자 유닛들, 컴퓨터, 또는 이들의 조합 내에서 구현될 수도 있다. 따라서, 본 개시와 연계하여 설명된 다양한 예시적인 논리 블록들, 모듈들, 및 회로들은 범용 프로세서, DSP, ASIC, FPGA나 다른 프로그램 가능 논리 디바이스, 이산 게이트나 트랜지스터 로직, 이산 하드웨어 컴포넌트들, 또는 본원에 설명된 기능들을 수행하도록 설계된 것들의 임의의 조합으로 구현되거나 수행될 수도 있다. 범용 프로세서는 마이크로프로세서일 수도 있지만, 대안으로, 프로세서는 임의의 종래의 프로세서, 제어기, 마이크로 제어기, 또는 상태 머신일 수도 있다. 프로세서는 또한, 컴퓨팅 디바이스들의 조합, 예를 들면, DSP와 마이크 로프로세서, 복수의 마이크로프로세서들, DSP 코어와 연계한 하나 이상의 마이크로프로세서들, 또는 임의의 다 른 구성의 조합으로서 구현될 수도 있다. 펌웨어 및/또는 소프트웨어 구현에 있어서, 기법들은 랜덤 액세스 메모리(random access memory; RAM), 판독 전 용 메모리(read-only memory; ROM), 비휘발성 RAM(non-volatile random access memory; NVRAM), PROM(programmable read-only memory), EPROM(erasable programmable read-only memory), EEPROM(electrically erasable PROM), 플래시 메모리, 컴팩트 디스크(compact disc; CD), 자기 또는 광학 데이 터 스토리지 디바이스 등과 같은 컴퓨터 판독가능 매체 상에 저장된 명령들로서 구현될 수도 있다. 명령들은 하나 이상의 프로세서들에 의해 실행 가능할 수도 있고, 프로세서(들)로 하여금 본 개시에 설명된 기능의 특정 양태들을 수행하게 할 수도 있다. 이상 설명된 실시예들이 하나 이상의 독립형 컴퓨터 시스템에서 현재 개시된 주제의 양태들을 활용하는 것으로 기술되었으나, 본 개시는 이에 한정되지 않고, 네트워크나 분산 컴퓨팅 환경과 같은 임의의 컴퓨팅 환경과 연계 하여 구현될 수도 있다. 또 나아가, 본 개시에서 주제의 양상들은 복수의 프로세싱 칩들이나 장치들에서 구현 될 수도 있고, 스토리지는 복수의 장치들에 걸쳐 유사하게 영향을 받게 될 수도 있다. 이러한 장치들은 PC들, 네트워크 서버들, 및 휴대용 장치들을 포함할 수도 있다."}
{"patent_id": "10-2020-0123297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "본 명세서에서는 본 개시가 일부 실시예들과 관련하여 설명되었지만, 본 개시의 발명이 속하는 기술분야의 통상 의 기술자가 이해할 수 있는 본 개시의 범위를 벗어나지 않는 범위에서 다양한 변형 및 변경이 이루어질 수 있 다. 또한, 그러한 변형 및 변경은 본 명세서에 첨부된 특허청구의 범위 내에 속하는 것으로 생각되어야 한다."}
{"patent_id": "10-2020-0123297", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시의 실시예들은, 이하 설명하는 첨부 도면들을 참조하여 설명될 것이며, 여기서 유사한 참조 번호는 유사 한 요소들을 나타내지만, 이에 한정되지는 않는다. 도 1은 본 개시의 일 실시예에 따른 정보 처리 시스템이 제1 이미지를 수신하여, 제1 이미지와 가장 유사도가 높은 제2 이미지를 출력하는 이미지 검색(image retrieval)을 수행하는 예시를 나타내는 도면이다. 도 2는 본 개시의 일 실시예에 따른 이미지 검색 서비스를 제공하는 정보 처리 시스템이 복수의 사용자 단말과 통신 가능하도록 연결된 구성을 나타내는 개요도이다. 도 3은 본 개시의 일 실시예에 따른 사용자 단말 및 정보 처리 시스템의 내부 구성을 나타내는 블록도이다. 도 4는 본 개시의 일 실시예에 따른 프로세서의 상세 블록도이다. 도 5a는 본 개시의 일 실시예에 따라 하나의 가상 클래스를 생성하는 예시를 나타내는 도면이다. 도 5b는 본 개시의 일 실시예에 따라 하나의 가상 클래스를 사용하여 인공 신경망 모델을 업데이트하는 예시를 나타내는 도면이다. 도 6a는 본 개시의 다른 실시예에 따라 세 개의 가상 클래스를 생성하는 예시를 나타내는 도면이다. 도 6b는 본 개시의 일 실시예에 따라 세 개의 가상 클래스를 사용하여 인공 신경망 모델을 업데이트하는 예시를 나타내는 도면이다. 도 7은 본 개시의 일 실시예에 따른 가상의 학습 데이터 생성 방법을 나타내는 흐름도이다. 도 8은 본 개시의 일 실시예에 따른 인공 신경망 모델의 학습/업데이트에 있어서, 가상의 학습 데이터 사용 여 부에 따른 성능 차이를 시각적으로 비교하기 위한 그래프이다. 도 9는 본 발명의 일 실시예에 따라 생성된 가상의 학습 데이터를 사용하여 인공 신경망 모델을 학습/업데이트 한 경우의 통합 네트워크의 t-SNE 시각화 결과를 나타낸다. 도 10은 본 개시의 일 실시예에 따른 인공 신경망 모델의 학습/업데이트에 있어서, 가상의 학습 데이터 사용 여 부에 따른 성능 차이를 열지도 시각화(Heatmap visualization) 결과로 비교하기 위한 그래프이다. 도 11은 선형보간법 계수( )를 결정하기 위한 베타 분포 함수의 파라미터(α)와 생성률(μ)의 값에 따른 인공 신경망 모델의 재현율을 나타내는 그래프이다. 도 12는 본 개시의 일 실시예에 따른 점진적으로 인공 신경망 모델을 업데이트하는 방법을 나타내는 흐름도이다."}
