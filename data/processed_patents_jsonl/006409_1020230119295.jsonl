{"patent_id": "10-2023-0119295", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0036607", "출원번호": "10-2023-0119295", "발명의 명칭": "전자 장치 및 그 제어 방법", "출원인": "삼성전자주식회사", "발명자": "류희창"}}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "코드 생성 모델을 포함하는 전자 장치에 있어서,적어도 하나의 인스트럭션을 저장하는 메모리;상기 메모리와 연결되어 상기 전자 장치를 제어하는 적어도 하나의 프로세서;를 포함하고,상기 적어도 하나의 프로세서는,상기 코드 생성 모델을 학습하기 위한 사용자 명령을 획득하고,상기 코드 학습 명령에 대응되는 소스 코드를 획득하고,상기 소스 코드를 기 설정된 단위로 분할하여 제1 코드 블록, 제2 코드 블록을 획득하고,상기 제1 코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제1 오류 메시지 정보 및 상기 제2코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제2 오류 메시지 정보를 획득하고,상기 제1 오류 메시지 정보에 대응되는 제1 검사 점수 및 상기 제2 오류 메시지 정보에 대응되는 제2 검사 점수를 획득하고,상기 제1 검사 점수 및 상기 제2 검사 점수에 기초하여 상기 제1 코드 블록 및 상기 제2 코드 블록 중 샘플링블록을 결정하고,상기 샘플링 블록을 이용하여 상기 코드 생성 모델을 학습하는, 전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 적어도 하나의 프로세서는,상기 소스 코드를 상기 기 설정된 단위로 누적함으로써 상기 제1 코드 블록 및 상기 제2 코드 블록을 획득하고,상기 제1 코드 블록의 크기는 상기 제2 코드 블록의 크기보다 작은, 전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 기 설정된 단위는,상기 소스 코드에서 선언된 함수 단위인, 전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 적어도 하나의 프로세서는,상기 제1 오류 메시지 정보 및 상기 제2 오류 메시지 정보에 포함된 적어도 하나의 세부 오류 메시지 각각의 메시지 타입을 식별하고,상기 식별된 메시지 타입에 대응되는 기준 점수에 기초하여 상기 제1 검사 점수 및 상기 제2 검사 점수를 획득하는, 전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,공개특허 10-2025-0036607-3-상기 적어도 하나의 프로세서는,상기 제1 오류 메시지 정보 및 상기 제2 오류 메시지 정보에 포함된 적어도 하나의 세부 오류 메시지 각각의 메시지 타입을 식별하고,상기 메시지 타입 별 비율 정보 및 상기 메시지 타입 별 가중치 정보에 기초하여 상기 제1 검사 점수 및 상기제2 검사 점수를 획득하는, 전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 적어도 하나의 프로세서는,상기 제1 검사 점수 및 상기 제2 검사 점수 중 임계값 이상인 검사 점수에 대응되는 코드 블록을 상기 샘플링블록으로 결정하는, 전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 적어도 하나의 프로세서는,상기 제1 코드 블록에 대응되는 제1 토큰 개수를 획득하고,상기 제2 코드 블록에 대응되는 제2 토큰 개수를 획득하고,상기 제1 토큰 개수가 임계 개수 미만이고 상기 제2 토큰 개수가 상기 임계 개수 미만이면, 상기 제1 코드 블록및 상기 제2 코드 블록을 상기 샘플링 블록으로 결정하고,상기 제1 토큰 개수가 상기 임계 개수 미만이고 상기 제2 토큰 개수가 상기 임계 개수 미만이 아니면, 상기 제1코드 블록을 상기 샘플링 블록으로 결정하는, 전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 적어도 하나의 프로세서는,상기 샘플링 블록을 포함하는 전처리된 코드 정보를 획득하고,상기 전처리된 코드 정보를 입력 데이터로써 상기 코드 생성 모델에 입력함으로써 결과 코드 정보를 획득하는,전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 기 설정된 단위는 제1 단위이고,상기 적어도 하나의 프로세서는,상기 결과 코드 정보를 제2 단위로 누적함으로써 제3 코드 블록 및 제4 코드 블록을 획득하고,상기 제3 코드 블록에 대응되는 제3 검사 점수 및 상기 제4 코드 블록에 대응되는 제4 검사 점수를 획득하고,상기 제3 검사 점수 및 상기 제4 검사 점수의 평균 검사 점수를 획득하는, 전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 적어도 하나의 프로세서는,상기 평균 검사 점수에 기초하여 강화 학습 기능을 수행함으로써 상기 코드 생성 모델의 파라미터를 변경하고,공개특허 10-2025-0036607-4-상기 변경된 파라미터에 기초하여 상기 코드 생성 모델을 업데이트하는, 전자 장치."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "코드 생성 모델을 포함하는 전자 장치의 제어 방법에 있어서,상기 코드 생성 모델을 학습하기 위한 사용자 명령을 획득하는 단계;상기 코드 학습 명령에 대응되는 소스 코드를 획득하는 단계;상기 소스 코드를 기 설정된 단위로 분할하여 제1 코드 블록, 제2 코드 블록을 획득하는 단계;상기 제1 코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제1 오류 메시지 정보 및 상기 제2코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제2 오류 메시지 정보를 획득하는 단계;상기 제1 오류 메시지 정보에 대응되는 제1 검사 점수 및 상기 제2 오류 메시지 정보에 대응되는 제2 검사 점수를 획득하는 단계;상기 제1 검사 점수 및 상기 제2 검사 점수에 기초하여 상기 제1 코드 블록 및 상기 제2 코드 블록 중 샘플링블록을 결정하는 단계; 및상기 샘플링 블록을 이용하여 상기 코드 생성 모델을 학습하는 단계;를 포함하는, 제어 방법."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서,상기 제1 코드 블록 및 상기 제2 코드 블록을 획득하는 단계는,상기 소스 코드를 상기 기 설정된 단위로 누적함으로써 상기 제1 코드 블록 및 상기 제2 코드 블록을 획득하고,상기 제1 코드 블록의 크기는 상기 제2 코드 블록의 크기보다 작은, 제어 방법."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서,상기 기 설정된 단위는,상기 소스 코드에서 선언된 함수 단위인, 제어 방법."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제11항에 있어서,상기 제1 검사 점수 및 상기 제2 검사 점수를 획득하는 단계는,상기 제1 오류 메시지 정보 및 상기 제2 오류 메시지 정보에 포함된 적어도 하나의 세부 오류 메시지 각각의 메시지 타입을 식별하고,상기 식별된 메시지 타입에 대응되는 기준 점수에 기초하여 상기 제1 검사 점수 및 상기 제2 검사 점수를 획득하는, 제어 방법."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제11항에 있어서,상기 제1 검사 점수 및 상기 제2 검사 점수를 획득하는 단계는,상기 제1 오류 메시지 정보 및 상기 제2 오류 메시지 정보에 포함된 적어도 하나의 세부 오류 메시지 각각의 메시지 타입을 식별하고,상기 메시지 타입 별 비율 정보 및 상기 메시지 타입 별 가중치 정보에 기초하여 상기 제1 검사 점수 및 상기제2 검사 점수를 획득하는, 제어 방법.공개특허 10-2025-0036607-5-청구항 16 제11항에 있어서,상기 샘플링 블록을 결정하는 단계는,상기 제1 검사 점수 및 상기 제2 검사 점수 중 임계값 이상인 검사 점수에 대응되는 코드 블록을 상기 샘플링블록으로 결정하는, 제어 방법."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제11항에 있어서,상기 샘플링 블록을 결정하는 단계는,상기 제1 코드 블록에 대응되는 제1 토큰 개수를 획득하고,상기 제2 코드 블록에 대응되는 제2 토큰 개수를 획득하고,상기 제1 토큰 개수가 임계 개수 미만이고 상기 제2 토큰 개수가 상기 임계 개수 미만이면, 상기 제1 코드 블록및 상기 제2 코드 블록을 상기 샘플링 블록으로 결정하고,상기 제1 토큰 개수가 상기 임계 개수 미만이고 상기 제2 토큰 개수가 상기 임계 개수 미만이 아니면, 상기 제1코드 블록을 상기 샘플링 블록으로 결정하는, 제어 방법."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제11항에 있어서,상기 코드 생성 모델을 학습하는 단계는,상기 샘플링 블록을 포함하는 전처리된 코드 정보를 획득하고,상기 전처리된 코드 정보를 입력 데이터로써 상기 코드 생성 모델에 입력함으로써 결과 코드 정보를 획득하는,제어 방법."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서,상기 기 설정된 단위는 제1 단위이고,상기 코드 생성 모델을 학습하는 단계는,상기 결과 코드 정보를 제2 단위로 누적함으로써 제3 코드 블록 및 제4 코드 블록을 획득하고,상기 제3 코드 블록에 대응되는 제3 검사 점수 및 상기 제4 코드 블록에 대응되는 제4 검사 점수를 획득하고,상기 제3 검사 점수 및 상기 제4 검사 점수의 평균 검사 점수를 획득하는, 제어 방법."}
{"patent_id": "10-2023-0119295", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제19항에 있어서,상기 코드 생성 모델을 학습하는 단계는,상기 평균 검사 점수에 기초하여 강화 학습 기능을 수행함으로써 상기 코드 생성 모델의 파라미터를 변경하고,상기 변경된 파라미터에 기초하여 상기 코드 생성 모델을 업데이트하는, 제어 방법."}
{"patent_id": "10-2023-0119295", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "코드 생성 모델을 포함하는 전자 장치는 적어도 하나의 인스트럭션을 저장하는 메모리, 메모리와 연결되어 전자 장치를 제어하는 적어도 하나의 프로세서를 포함하고, 적어도 하나의 프로세서는 코드 생성 모델을 학습하기 위 한 사용자 명령을 획득하고, 코드 학습 명령에 대응되는 소스 코드를 획득하고, 소스 코드를 기 설정된 단위로 분할하여 제1 코드 블록, 제2 코드 블록을 획득하고, 제1 코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제1 오류 메시지 정보 및 제2 코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제2 오 류 메시지 정보를 획득하고, 제1 오류 메시지 정보에 대응되는 제1 검사 점수 및 제2 오류 메시지 정보에 대응되 는 제2 검사 점수를 획득하고, 제1 검사 점수 및 제2 검사 점수에 기초하여 제1 코드 블록 및 제2 코드 블록 중 샘플링 블록을 결정하고, 샘플링 블록을 이용하여 코드 생성 모델을 학습한다."}
{"patent_id": "10-2023-0119295", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 전자 장치 및 그 제어방법에 관한 것으로, 더욱 상세하게는 사용자 명령에 따라 코드를 생성하는 전 자 장치 및 그 제어방법에 대한 것이다."}
{"patent_id": "10-2023-0119295", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "사용자 명령에 따라 정해진 컴퓨터 언어로 코드를 생성해주는 코드 생성 모델이 존재한다. 코드 모델은 사용자 가 지정한 컴퓨터 언어 내지 기 설정된 컴퓨터 언어를 이용하여 사용자가 요청하는 코드를 자동으로 생성할 수 있다. 코드 생성 모델은 인공 지능 모델일 수 있으며, 학습 과정을 통해 최종 코드 생성 모델이 결정될 수 있다. 인공 지능 모델의 학습 과정에서 학습 데이터가 필요할 수 있다. 학습 데이터의 품질이 높을수록 학습되는 인공 지능 모델의 정확도가 높을 수 있다. 코드 생성 모델을 학습하기 위해서 오류가 존재하지 않는 코드 데이터를 이용해야 하는데, 오류가 존재하지 않는 코드 데이터를 다양하게 수집하는 것이 어려운 문제점이 있다. 표준화된 코드를 생성하기 위해 학습 데이터가 표준화되어야 하는데, 다양한 코드 데이터를 표준화시키는 것이 어렵다는 문제점이 있다."}
{"patent_id": "10-2023-0119295", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시는 상술한 문제를 개선하기 위해 고안된 것으로, 본 개시의 목적은 코드 생성 모델의 학습 과정에서 전 처리된 학습 데이터를 이용하는 전자 장치 및 그의 제어 방법을 제공함에 있다. 일 실시 예에 따른 코드 생성 모델을 포함하는 전자 장치는 적어도 하나의 인스트럭션을 저장하는 메모리, 상기 메모리와 연결되어 상기 전자 장치를 제어하는 적어도 하나의 프로세서를 포함하고, 상기 적어도 하나의 프로세 서는 상기 코드 생성 모델을 학습하기 위한 사용자 명령을 획득하고, 상기 코드 학습 명령에 대응되는 소스 코 드를 획득하고, 상기 소스 코드를 기 설정된 단위로 분할하여 제1 코드 블록, 제2 코드 블록을 획득하고, 상기 제1 코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제1 오류 메시지 정보 및 상기 제2 코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제2 오류 메시지 정보를 획득하고, 상기 제1 오류 메시지 정보에 대응되는 제1 검사 점수 및 상기 제2 오류 메시지 정보에 대응되는 제2 검사 점수를 획득하고, 상기 제1 검사 점수 및 상기 제2 검사 점수에 기초하여 상기 제1 코드 블록 및 상기 제2 코드 블록 중 샘플링 블록을 결정하고, 상기 샘플링 블록을 이용하여 상기 코드 생성 모델을 학습한다. 상기 적어도 하나의 프로세서는 상기 소스 코드를 상기 기 설정된 단위로 누적함으로써 상기 제1 코드 블록 및 상기 제2 코드 블록을 획득하고, 상기 제1 코드 블록의 크기는 상기 제2 코드 블록의 크기보다 작을 수 있다. 상기 기 설정된 단위는 상기 소스 코드에서 선언된 함수 단위일 수 있다. 상기 적어도 하나의 프로세서는 상기 제1 오류 메시지 정보 및 상기 제2 오류 메시지 정보에 포함된 적어도 하 나의 세부 오류 메시지 각각의 메시지 타입을 식별하고, 상기 식별된 메시지 타입에 대응되는 기준 점수에 기초 하여 상기 제1 검사 점수 및 상기 제2 검사 점수를 획득할 수 있다. 상기 적어도 하나의 프로세서는 상기 제1 오류 메시지 정보 및 상기 제2 오류 메시지 정보에 포함된 적어도 하 나의 세부 오류 메시지 각각의 메시지 타입을 식별하고, 상기 메시지 타입 별 비율 정보 및 상기 메시지 타입 별 가중치 정보에 기초하여 상기 제1 검사 점수 및 상기 제2 검사 점수를 획득할 수 있다. 상기 적어도 하나의 프로세서는 상기 제1 검사 점수 및 상기 제2 검사 점수 중 임계값 이상인 검사 점수에 대응 되는 코드 블록을 상기 샘플링 블록으로 결정할 수 있다. 상기 적어도 하나의 프로세서는 상기 제1 코드 블록에 대응되는 제1 토큰 개수를 획득하고, 상기 제2 코드 블록 에 대응되는 제2 토큰 개수를 획득하고, 상기 제1 토큰 개수가 임계 개수 미만이고 상기 제2 토큰 개수가 상기 임계 개수 미만이면, 상기 제1 코드 블록 및 상기 제2 코드 블록을 상기 샘플링 블록으로 결정하고, 상기 제1 토큰 개수가 상기 임계 개수 미만이고 상기 제2 토큰 개수가 상기 임계 개수 미만이 아니면, 상기 제1 코드 블 록을 상기 샘플링 블록으로 결정할 수 있다. 상기 적어도 하나의 프로세서는 상기 샘플링 블록을 포함하는 전처리된 코드 정보를 획득하고, 상기 전처리된 코드 정보를 입력 데이터로써 상기 코드 생성 모델에 입력함으로써 결과 코드 정보를 획득할 수 있다. 상기 기 설정된 단위는 제1 단위이고, 상기 적어도 하나의 프로세서는 상기 결과 코드 정보를 제2 단위로 누적 함으로써 제3 코드 블록 및 제4 코드 블록을 획득하고, 상기 제3 코드 블록에 대응되는 제3 검사 점수 및 상기 제4 코드 블록에 대응되는 제4 검사 점수를 획득하고, 상기 제3 검사 점수 및 상기 제4 검사 점수의 평균 검사 점수를 획득할 수 있다. 상기 적어도 하나의 프로세서는 상기 평균 검사 점수에 기초하여 강화 학습 기능을 수행함으로써 상기 코드 생 성 모델의 파라미터를 변경하고, 상기 변경된 파라미터에 기초하여 상기 코드 생성 모델을 업데이트할 수 있다. 일 실시 예에 따른, 코드 생성 모델을 포함하는 전자 장치의 제어 방법은 상기 코드 생성 모델을 학습하기 위한 사용자 명령을 획득하는 단계, 상기 코드 학습 명령에 대응되는 소스 코드를 획득하는 단계, 상기 소스 코드를 기 설정된 단위로 분할하여 제1 코드 블록, 제2 코드 블록을 획득하는 단계, 상기 제1 코드 블록과 관련된 적어 도 하나의 세부 오류 메시지를 포함하는 제1 오류 메시지 정보 및 상기 제2 코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제2 오류 메시지 정보를 획득하는 단계, 상기 제1 오류 메시지 정보에 대응되는 제1 검사 점수 및 상기 제2 오류 메시지 정보에 대응되는 제2 검사 점수를 획득하는 단계, 상기 제1 검사 점수 및 상기 제2 검사 점수에 기초하여 상기 제1 코드 블록 및 상기 제2 코드 블록 중 샘플링 블록을 결정하는 단계 및 상기 샘플링 블록을 이용하여 상기 코드 생성 모델을 학습하는 단계를 포함한다. 상기 제1 코드 블록 및 상기 제2 코드 블록을 획득하는 단계는 상기 소스 코드를 상기 기 설정된 단위로 누적함 으로써 상기 제1 코드 블록 및 상기 제2 코드 블록을 획득하고, 상기 제1 코드 블록의 크기는 상기 제2 코드 블 록의 크기보다 작을 수 있다. 상기 기 설정된 단위는 상기 소스 코드에서 선언된 함수 단위일 수 있다. 상기 제1 검사 점수 및 상기 제2 검사 점수를 획득하는 단계는 상기 제1 오류 메시지 정보 및 상기 제2 오류 메 시지 정보에 포함된 적어도 하나의 세부 오류 메시지 각각의 메시지 타입을 식별하고, 상기 식별된 메시지 타입 에 대응되는 기준 점수에 기초하여 상기 제1 검사 점수 및 상기 제2 검사 점수를 획득할 수 있다. 상기 제1 검사 점수 및 상기 제2 검사 점수를 획득하는 단계는 상기 제1 오류 메시지 정보 및 상기 제2 오류 메 시지 정보에 포함된 적어도 하나의 세부 오류 메시지 각각의 메시지 타입을 식별하고, 상기 메시지 타입 별 비 율 정보 및 상기 메시지 타입 별 가중치 정보에 기초하여 상기 제1 검사 점수 및 상기 제2 검사 점수를 획득할 수 있다. 상기 샘플링 블록을 결정하는 단계는 상기 제1 검사 점수 및 상기 제2 검사 점수 중 임계값 이상인 검사 점수에 대응되는 코드 블록을 상기 샘플링 블록으로 결정할 수 있다. 상기 샘플링 블록을 결정하는 단계는 상기 제1 코드 블록에 대응되는 제1 토큰 개수를 획득하고, 상기 제2 코드 블록에 대응되는 제2 토큰 개수를 획득하고, 상기 제1 토큰 개수가 임계 개수 미만이고 상기 제2 토큰 개수가 상기 임계 개수 미만이면, 상기 제1 코드 블록 및 상기 제2 코드 블록을 상기 샘플링 블록으로 결정하고, 상기 제1 토큰 개수가 상기 임계 개수 미만이고 상기 제2 토큰 개수가 상기 임계 개수 미만이 아니면, 상기 제1 코드 블록을 상기 샘플링 블록으로 결정할 수 있다. 상기 코드 생성 모델을 학습하는 단계는 상기 샘플링 블록을 포함하는 전처리된 코드 정보를 획득하고, 상기 전 처리된 코드 정보를 입력 데이터로써 상기 코드 생성 모델에 입력함으로써 결과 코드 정보를 획득할 수 있다. 상기 기 설정된 단위는 제1 단위이고, 상기 코드 생성 모델을 학습하는 단계는 상기 결과 코드 정보를 제2 단위 로 누적함으로써 제3 코드 블록 및 제4 코드 블록을 획득하고, 상기 제3 코드 블록에 대응되는 제3 검사 점수 및 상기 제4 코드 블록에 대응되는 제4 검사 점수를 획득하고, 상기 제3 검사 점수 및 상기 제4 검사 점수의 평 균 검사 점수를 획득할 수 있다. 상기 코드 생성 모델을 학습하는 단계는 상기 평균 검사 점수에 기초하여 강화 학습 기능을 수행함으로써 상기 코드 생성 모델의 파라미터를 변경하고, 상기 변경된 파라미터에 기초하여 상기 코드 생성 모델을 업데이트할 수 있다."}
{"patent_id": "10-2023-0119295", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하에서는 첨부 도면을 참조하여 본 개시를 상세히 설명한다. 본 개시의 실시 예에서 사용되는 용어는 본 개시에서의 기능을 고려하면서 가능한 현재 널리 사용되는 일반적인 용어들을 선택하였으나, 이는 당 분야에 종사하는 기술자의 의도 또는 판례, 새로운 기술의 출현 등에 따라 달 라질 수 있다. 또한, 특정한 경우는 출원인이 임의로 선정한 용어도 있으며, 이 경우 해당되는 개시의 설명 부 분에서 상세히 그 의미를 기재할 것이다. 따라서 본 개시에서 사용되는 용어는 단순한 용어의 명칭이 아닌, 그 용어가 가지는 의미와 본 개시의 전반에 걸친 내용을 토대로 정의되어야 한다. 본 명세서에서, \"가진다,\" \"가질 수 있다,\" \"포함한다,\" 또는 \"포함할 수 있다\" 등의 표현은 해당 특징(예: 수 치, 기능, 동작, 또는 부품 등의 구성요소)의 존재를 가리키며, 추가적인 특징의 존재를 배제하지 않는다. A 또는/및 B 중 적어도 하나라는 표현은 \"A\" 또는 \"B\" 또는 \"A 및 B\" 중 어느 하나를 나타내는 것으로 이해되어 야 한다. 본 명세서에서 사용된 \"제1,\" \"제2,\" \"첫째,\" 또는 \"둘째,\"등의 표현들은 다양한 구성요소들을, 순서 및/또는 중요도에 상관없이 수식할 수 있고, 한 구성요소를 다른 구성요소와 구분하기 위해 사용될 뿐 해당 구성요소들 을 한정하지 않는다. 어떤 구성요소(예: 제1 구성요소)가 다른 구성요소(예: 제2 구성요소)에 \"(기능적으로 또는 통신적으로) 연결되 어((operatively or communicatively) coupled with/to)\" 있다거나 \"접속되어(connected to)\" 있다고 언급된 때에는, 어떤 구성요소가 다른 구성요소에 직접적으로 연결되거나, 다른 구성요소(예: 제3 구성요소)를 통하여 연결될 수 있다고 이해되어야 할 것이다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 출원에서, \"포함하다\" 또 는 \"구성되다\" 등의 용어는 명세서상에 기재된 특징, 숫자, 단계, 동작, 구성요소, 부품 또는 이들을 조합한 것 이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 본 개시에서 \"모듈\" 혹은 \"부\"는 적어도 하나의 기능이나 동작을 수행하며, 하드웨어 또는 소프트웨어로 구현되 거나 하드웨어와 소프트웨어의 결합으로 구현될 수 있다. 또한, 복수의 \"모듈\" 혹은 복수의 \"부\"는 특정한 하드 웨어로 구현될 필요가 있는 \"모듈\" 혹은 \"부\"를 제외하고는 적어도 하나의 모듈로 일체화되어 적어도 하나의 프 로세서(미도시)로 구현될 수 있다. 본 명세서에서, 사용자라는 용어는 전자 장치를 사용하는 사람 또는 전자 장치를 사용하는 장치(예: 인공지능 전자 장치)를 지칭할 수 있다. 이하 첨부된 도면들을 참조하여 본 개시의 일 실시 예를 보다 상세하게 설명한다. 본 개시에서, 인공 지능 모델이 학습된다는 것은, 기본 인공 지능 모델(예를 들어 임의의 랜덤한 파라미터를 포 함하는 인공 지능 모델)이 학습 알고리즘에 의하여 다수의 훈련 데이터들을 이용하여 학습됨으로써, 원하는 특 성(또는, 목적)을 수행하도록 설정된 기 정의된 동작 규칙 또는 인공 지능 모델이 만들어짐을 의미한다. 이러한 학습은 별도의 서버 및/또는 시스템을 통해 이루어질 수 있으나, 이에 한정되는 것은 아니며 전자 장치에 서 이루어질 수도 있다. 학습 알고리즘의 예로는, 지도형 학습(supervised learning), 비지도형 학습 (unsupervised learning), 준지도형 학습(semi-supervised learning), 전이 학습(transfer learning) 또는 강 화 학습(reinforcement learning)이 있으나, 전술한 예에 한정되지 않는다. 여기서, 인공 지능 모델 각각은, 예를 들어, CNN (Convolutional Neural Network), RNN (Recurrent Neural Network), RBM (Restricted Boltzmann Machine), DBN (Deep Belief Network), BRDNN(Bidirectional Recurrent Deep Neural Network) 또는 심층 Q-네트워크 (Deep Q-Networks) 등으로 구현될 수 있으나, 이에 한정되지 않는 다. 본 개시의 일 실시 예에 따른 인공 지능 모델을 실행하기 위한 적어도 하나의 프로세서는 CPU, AP, DSP(Digital Signal Processor) 등과 같은 범용 프로세서, GPU, VPU(Vision Processing Unit)와 같은 그래픽 전용 프로세서 또는 NPU와 같은 인공 지능 전용 프로세서와 소프트웨어의 조합을 통해 구현될 수 있다. 적어도 하나의 프로세서는, 메모리에 저장된 기 정의된 동작 규칙 또는 인공 지능 모델에 따라, 입력 데이터 를 처리하도록 제어할 수 있다. 또는, 적어도 하나의 프로세서가 전용 프로세서(또는 인공 지능 전용 프로 세서)인 경우, 특정 인공 지능 모델의 처리에 특화된 하드웨어 구조로 설계될 수 있다. 예를 들어, 특정 인공 지능 모델의 처리에 특화된 하드웨어는 ASIC, FPGA 등의 하드웨어 칩으로 설계될 수 있다. 적어도 하나의 프로 세서가 전용 프로세서로 구현되는 경우, 본 개시의 실시 예를 구현하기 위한 메모리를 포함하도록 구현되 거나, 외부 메모리를 이용하기 위한 메모리 처리 기능을 포함하도록 구현될 수 있다. 다른 예에 따라, 메모리는 복수의 레이어를 포함하는 인공 지능 모델에 관한 정보를 저장할 수 있다. 여기 서, 인공 지능 모델에 관한 정보를 저장한다는 것은 인공 지능 모델의 동작과 관련된 다양한 정보, 예를 들어 인공 지능 모델에 포함된 복수의 레이어에 대한 정보, 복수의 레이어 각각에서 이용되는 파라미터(예를 들어, 필터 계수, 바이어스 등)에 대한 정보 등을 저장한다는 것을 의미할 수 있다. 도 1은 일 실시 예에 따라, 코드 생성 모델을 설명하기 위한 도면이다. 전자 장치는 코드 생성 모델을 포함할 수 있다. 코드 생성 모델은 입력 데이터에 기초하여 보완 된 코드를 생성하는 모델을 포함할 수 있다. 코드 생성 모델은 입력 데이터에 포함된 코드 정보를 분석하 여 오류가 없는 코드를 생성하는 모델을 포함할 수 있다. 코드 생성 모델은 입력 데이터를 구현하는 코드 를 생성하는 모델을 포함할 수 있다. 코드 생성 모델은 코드를 생성하는 인공 지능 모델을 포함할 수 있다. 코드 생성 모델은 입력 데이터 에 포함된 정보에 기초하여 프로그래밍 언어를 이용한 코드 정보를 생성하는 모델을 포함할 수 있다. 예를 들어, 프로그래밍 언어는 파이썬, 자바 스크립트, 자바, C++, C# 중 하나를 포함할 수 있다. 일 예로, 코드 생성 모델은 입력 데이터에 포함된 프로그래밍 언어를 이용하여 코드 정보를 생성할 수 있 다. 사용자는 어떤 프로그래밍 언어로 코드 정보를 생성할 것인지 결정할 수 있다. 예를 들어, 적어도 하나의 프로세서가 “파이썬으로 사칙연산 수행하는 코드를 생성해줘”를 나타내는 사용자 입력이 입력 데이터를 수신하였음을 가정한다. 적어도 하나의 프로세서는 입력 데이터에 프로그래밍 언어가 포함되어 있는지 여부를 식별할 수 있다. 적어도 하나의 프로세서는 입력 데이터에서 프로그래밍 언어를 식별하고, 식별된 프 로그래밍 언어를 이용하여 코드 정보를 생성할 수 있다. 일 예로, 코드 생성 모델은 기 설정된 언어로 코드 정보를 생성할 수 있다. 기 설정된 언어 사용자가 설정 한 언어일 수 있다. 코드 생성 모델은 고유한 프로그래밍 언어가 설정되어 있을 수 있다. 코드 생성 모델 은 입력 데이터에 대응되는 코드 정보를 기 설정된 언어를 이용하여 생성할 수 있다. 기 설정된 언어는 사 용자의 설정에 따라 변경될 수 있다. 코드 생성 모델마다 기 설정된 언어가 상이할 수 있다. 예를 들어, 제1 코드 생성 모델은 제1 언어를 이용하는 모델이고, 제2 코드 생성 모델은 제2 언어를 이용하는 모델일 수 있 다. 도 1의 실시 예를 참조하면, 코드 생성 모델은 표준화된 학습 데이터를 이용하지 않고 학습된 모델을 가정한다. 전자 장치는 입력 데이터를 코드 생성 모델에 입력할 수 있다. 코드 생성 모델은 입력 데이터에 대응되는 출력 데이터를 획득할 수 있다. 입력 데이터는 데이터 베이스(DB)에서 키 (key) 값을 획득하는 미완성 코드를 포함할 수 있다. 출력 데이터는 베이스(DB)에서 키(key) 값을 획득하는 완성 코드(또는 보완된 코드)를 포함할 수 있다. 도 1의 실시 예를 참조하면, 코드 생성 모델은 표준화된 학습 데이터를 이용하여 학습된 모델을 가정 한다. 전자 장치는 입력 데이터를 코드 생성 모델에 입력할 수 있다. 코드 생성 모델은 입 력 데이터에 대응되는 출력 데이터를 획득할 수 있다. 입력 데이터는 데이터 베이스(DB)에서 키 (key) 값을 획득하는 미완성 코드를 포함할 수 있다. 출력 데이터는 베이스(DB)에서 키(key) 값을 획득하는 완성 코드(또는 보완된 코드)를 포함할 수 있다. 출력 데이터는 출력 데이터에 포함되지 않은 코드(“except Exception as e:”, “print(\"Error\", e) ”)를 포함할 수 있다. 표준화된 학습 데이터를 이용하는 경우 최소한의 오류를 발생시키는 보완된 코드를 생성 할 가능성이 높아질 수 있다. 도 2는 일 실시 예에 따라, 전자 장치를 도시한 블록도이다. 도 2를 참조하면, 전자 장치는 메모리 및 적어도 하나의 프로세서를 포함할 수 있다. 메모리는 적어도 하나의 프로세서에 포함된 롬(ROM)(예를 들어, EEPROM(electrically erasable programmable read-only memory)), 램(RAM) 등의 내부 메모리로 구현되거나, 적어도 하나의 프로세서와 별도의 메모리로 구현될 수도 있다. 이 경우, 메모리는 데이터 저장 용도에 따라 전자 장치에 임베디 드된 메모리 형태로 구현되거나, 전자 장치에 탈부착이 가능한 메모리 형태로 구현될 수도 있다. 예를 들 어, 전자 장치의 구동을 위한 데이터의 경우 전자 장치에 임베디드된 메모리에 저장되고, 전자 장치 의 확장 기능을 위한 데이터의 경우 전자 장치에 탈부착이 가능한 메모리에 저장될 수 있다. 메모리는 적어도 하나의 인스트럭션을 저장할 수 있다. 메모리는 도 9의 메시지 타입 테이블을 저장할 수 있다. 메모리는 코드 생성 모델을 저장할 수 있다. 적어도 하나의 프로세서는 메모리와 연결되어 전자 장치를 제어할 수 있다. 적어도 하나의 프로세서는 전자 장치의 전반적인 제어 동작을 수행할 수 있다. 구체적으로, 적어도 하나의 프로세서는 전자 장치의 전반적인 동작을 제어하는 기능을 한다. 적어도 하나의 프로세서는 디지털 신호를 처리하는 디지털 시그널 프로세서(digital signal processor(DSP), 마이크로 프로세서(microprocessor), TCON(Time controller)으로 구현될 수 있다. 다만, 이에 한정되는 것은 아니며, 중앙처리장치(central processing unit(CPU)), MCU(Micro Controller Unit), MPU(micro processing unit), 컨트롤러(controller), 어플리케이션 프로세서(application processor(AP)), GPU(graphics- processing unit) 또는 커뮤니케이션 프로세서(communication processor(CP)), ARM(advanced reduced instruction set computer (RISC) machines) 프로세서 중 하나 또는 그 이상을 포함하거나, 해당 용어로 정의 될 수 있다. 또한, 적어도 하나의 프로세서는 프로세싱 알고리즘이 내장된 SoC(System on Chip), LSI(large scale integration)로 구현될 수도 있고, FPGA(Field Programmable gate array) 형태로 구현될 수도 있다. 또한, 적어도 하나의 프로세서는 메모리에 저장된 컴퓨터 실행가능 명령어(computer executable instructions)를 실행함으로써 다양한 기능을 수행할 수 있다. 적어도 하나의 프로세서는 코드 생성 모델을 학습하기 위한 사용자 명령을 획득하고, 코드 학습 명령 에 대응되는 소스 코드를 획득하고, 소스 코드를 기 설정된 단위로 분할하여 제1 코드 블록, 제2 코드 블록을획득하고, 제1 코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제1 오류 메시지 정보 및 제2 코드 블록과 관련된 적어도 하나의 세부 오류 메시지를 포함하는 제2 오류 메시지 정보를 획득하고, 제1 오류 메시지 정보에 대응되는 제1 검사 점수 및 제2 오류 메시지 정보에 대응되는 제2 검사 점수를 획득하고, 제1 검 사 점수 및 제2 검사 점수에 기초하여 제1 코드 블록 및 제2 코드 블록 중 샘플링 블록을 결정하고, 샘플링 블 록을 이용하여 코드 생성 모델을 학습할 수 있다. 적어도 하나의 프로세서는 코드 생성 모델을 학습하기 위한 사용자 명령을 획득(또는 수신)할 수 있 다. 사용자 명령은 코드 생성 모델을 학습하기 위한 사용자 입력을 포함할 수 있다. 코드 학습 명령이 획득되면, 적어도 하나의 프로세서는 코드 학습 명령에 대응되는 소스 코드를 획득할 수 있다. 일 예로, 적어도 하나의 프로세서는 코드 학습 명령에 따라 다양한 후보 학습 데이터를 포함하는 소스 코 드를 획득할 수 있다. 일 예로, 적어도 하나의 프로세서는 코드 학습 명령에 따라 코드 학습 명령에 대응되는 소스 코드를 획득 할 수 있다. 코드 학습 명령은 학습과 관련된 정보가 포함될 수 있다. 예를 들어, 학습과 관련된 정보는 학습 방향 또는 학습 카테고리를 포함할 수 있다. 적어도 하나의 프로세서는 소스 코드 데이터 베이스를 이용하여 소스 코드를 획득할 수 있다. 적어도 하나의 프로세서는 코드 학습 명령에 따라 소스 코드를 소스 코드 데이터 베이스에 요청할 수 있다. 소스 코드 데이터 베이스는 요청에 응답하여 소스 코드를 전자 장치에 전송할 수 있다. 적어도 하나 의 프로세서는 소스 코드 데이터 베이스로부터 소스 코드를 수신할 수 있다. 소스 코드는 학습 데이터로 이용되기 위한 코드 정보를 포함할 수 있다. 소스 코드는 로우(raw) 데이터를 포함 할 수 있다. 적어도 하나의 프로세서는 복수의 소스 코드를 이용하여 코드 생성 모델을 학습할 수 있 다. 학습 기능을 수행하기 위해 적어도 하나의 프로세서는 복수의 소스 코드를 이용할 수 있다. 적어도 하나의 프로세서는 소스 코드를 기 설정된 단위로 분할(또는 구분)할 수 있다. 적어도 하나의 프로 세서는 표준화된 학습 데이터를 이용하기 위해 소스 코드에 대하여 전처리 기능을 수행할 수 있다. 전처리 기능은 소스 코드의 크기를 줄이는 동작을 포함할 수 있다. 소스 코드의 크기를 줄이는 경우 효율적인 학습 데 이터로써 이용될 수 있다. 적어도 하나의 프로세서는 소스 코드를 기 설정된 단위에 기초하여 복수의 코드 블록으로 분할할 수 있다. 일 실시 예에 따라, 기 설정된 단위는 소스 코드에서 선언된 함수 단위일 수 있다. 소스 코드에는 복수의 함수 가 포함될 수 있다. 적어도 하나의 프로세서는 소스 코드를 함수 단위로 분할할 수 있다. 이와 관련된 설 명은 도 6에기 기재한다. 함수 단위는 제1 단위로 기재될 수 있다. 적어도 하나의 프로세서는 소스 코드에서 함수가 선언된 라인(또는 위치)를 기준으로 소스 코드를 복수의 코드 블록으로 분할할 수 있다. 일 실시 예에 따라, 기 설정된 단위는 소스 코드의 라인(줄) 단위 일 수 있다. 적어도 하나의 프로세서는 소스 코드의 라인을 기준으로 소스 코드를 분할할 수 있다. 이와 관련된 설명은 도 19에서 기재한다. 라인 단위 는 제2 단위로 기재될 수 있다. 적어도 하나의 프로세서는 기 설정된 단위에 기초하여 소스 코드를 제1 코드 블록 및 제2 코드 블록으로 분할할 수 있다. 적어도 하나의 프로세서는 시간 순서에 따라 제1 코드 블록을 먼저 획득하고, 이후 제2 코드 블록을 획득할 수 있다. 적어도 하나의 프로세서는 분할 동작을 누적하여 수행할 수 있다. 적어도 하나의 프로세서는 소스 코 드를 분할하되 누적하여 코드 블록을 획득할 수 있다. 적어도 하나의 프로세서는 소스 코드를 기 설정된 단위로 누적함으로써 제1 코드 블록 및 제2 코드 블록을 획득하고, 제1 코드 블록의 크기는 제2 코드 블록의 크기보다 작을 수 있다. 적어도 하나의 프로세서는 48 라인을 포함하는 소스 코드를 분할함을 가정한다. 적어도 하나의 프로세서 는 1-19 라인의 코드를 제1 코드 블록으로 분할할 수 있다. 적어도 하나의 프로세서는 1-25 라인의코드를 제2 코드 블록으로 분할할 수 있다. 제2 코드 블록은 제1 코드 블록에 포함된 코드를 포함할 수 있다. 적어도 하나의 프로세서는 기존에 분할된 코드가 포함되도록 소스 코드를 분할할 수 있다. 적어도 하나의 프로세서는 제1 코드 블록을 분석하여 적어도 하나의 세부 오류 메시지를 획득할 수 있다. 적어도 하나의 프로세서는 제2 코드 블록을 분석하여 적어도 하나의 세부 오류 메시지를 획득할 수 있다. 적어도 하나의 프로세서는 코드 블록을 컴파일(또는 검사)하여 세부 오류 메시지를 획득할 수 있다. 세부 오류 메시지는 세부 오류 정보로 기재될 수 있다. 세부 오류 메시지는 코드 블록에 대한 오류 여부를 검사한 결과를 나타내는 메시지일 수 있다. 적어도 하나의 프로세서는 코드 블록에 오류가 포함되어 있는지 여부를 분석할 수 있다. 적어도 하나의 프로세서는 전체 소스 코드가 아니라 코드 블록에 포함된 코드만에 대하여 오류 검사를 수행할 수 있다. 적어도 하나의 프 로세서는 오류 검사를 통해 오류 메시지를 생성할 수 있다. 적어도 하나의 프로세서는 코드 블록 각 각에 대한 오류 검사를 수행하여 오류 메시지를 획득할 수 있다. 획득되는 하나의 오류 메시지는 세부 오류 메 시지로 기재될 수 있다. 적어도 하나의 프로세서는 하나의 코드 블록에서 복수의 세부 오류 메시지를 획득 할 수 있다. 적어도 하나의 프로세서는 제1 코드 블록에서 획득한 적어도 하나의 세부 오류 메시지를 포함하는 제1 오 류 메시지 정보를 획득할 수 있다. 제1 오류 메시지 정보는 제1 코드 블록에 대응되는 적어도 하나의 세부 오류 메시지를 포함할 수 있다. 적어도 하나의 프로세서는 제2 코드 블록에서 획득한 적어도 하나의 세부 오류 메시지를 포함하는 제2 오 류 메시지 정보를 획득할 수 있다. 제2 오류 메시지 정보는 제2 코드 블록에 대응되는 적어도 하나의 세부 오류 메시지를 포함할 수 있다. 적어도 하나의 프로세서는 제1 오류 메시지 정보에 대응되는 제1 검사 점수를 획득(또는 계산)할 수 있다. 적어도 하나의 프로세서는 제2 오류 메시지 정보에 대응되는 제2 검사 점수를 획득(또는 계산)할 수 있다. 적어도 하나의 프로세서는 기 설정된 방식에 의하여 검사 점수를 획득할 수 있다. 검사 점수는 코드 블록 에 오류 가능성이 얼마나 있는지를 나타내는 점수일 수 있다. 검사 점수가 높을수록 오류 가능성이 낮다고 판단 될 수 있다. 기 설정된 방식은 메시지 타입에 대응되는 기본 점수를 이용하여 검사 점수를 획득하는 방식(제1 방식) 또는 비 율 정보를 이용하여 검사 점수를 획득하는 방식(제2 방식) 중 적어도 하나를 포함할 수 있다. 적어도 하나의 프로세서는 제1 오류 메시지 정보에 포함된 적어도 하나의 세부 오류 메시지에 기초하여 제 1 검사 점수를 계산할 수 있다. 적어도 하나의 프로세서는 제2 오류 메시지 정보에 포함된 적어도 하나의 세부 오류 메시지에 기초하여 제2 검사 점수를 계산할 수 있다. 적어도 하나의 프로세서는 제1 오류 메시지 정보 및 제2 오류 메시지 정보에 포함된 적어도 하나의 세부 오류 메시지 각각의 메시지 타입을 식별하고, 식별된 메시지 타입에 대응되는 기준 점수에 기초하여 제1 검사 점수 및 제2 검사 점수를 획득할 수 있다. 이와 관련된 구체적인 설명은 도 9 및 도 10에서 기재한다. 적어도 하나의 프로세서는 제1 오류 메시지 정보에 포함된 적어도 하나의 세부 오류 메시지 각각에 대응되 는 메시지 타입을 식별할 수 있다. 예를 들어, 제1 오류 메시지 정보는 제1 세부 오류 메시지 및 제2 세부 오류 메시지를 포함한다고 가정한다. 적어도 하나의 프로세서는 제1 세부 오류 메시지의 메시지 타입 및 제2 세 부 오류 메시지의 메시지 타입을 식별할 수 있다. 적어도 하나의 프로세서는 도 9의 메시지 타입 테이블 을 이용하여 제1 세부 오류 메시지의 메시지 타입에 대응되는 기본 점수(제1 점수)를 획득하고, 제2 세부 오류 메시지의 메시지 타입에 대응되는 기본 점수(제2 점수)를 획득할 수 있다. 적어도 하나의 프로세서는 제1 점수 및 제2 점수의 평균값에 기초하여 제1 오류 메시지 정보의 제1 검사 점수를 획득할 수 있다. 제2 검사 점수를 획득하는 방식 역시 동일할 수 있다. 적어도 하나의 프로세서는 제1 오류 메시지 정보 및 제2 오류 메시지 정보에 포함된 적어도 하나의 세부 오류 메시지 각각의 메시지 타입을 식별하고, 메시지 타입 별 비율 정보 및 메시지 타입 별 가중치 정보에 기초 하여 제1 검사 점수 및 제2 검사 점수를 획득할 수 있다. 이와 관련된 구체적인 설명은 도 13에서 기재한다. 적어도 하나의 프로세서는 제1 검사 점수 및 제2 검사 점수 중 임계값 이상인 검사 점수에 대응되는 코드 블록을 샘플링 블록으로 결정할 수 있다.적어도 하나의 프로세서는 검사 점수에 기초하여 샘플링 블록을 결정(또는 획득 또는 식별)할 수 있다. 샘 플링 블록은 코드 생성 모델의 학습 과정에서 이용되는 선별적인 학습 데이터를 의미할 수 있다. 적어도 하나의 프로세서는 분할된 복수의 코드 블록 중 선택적으로 샘플링 블록을 결정할 수 잇다. 샘플링 블록은 분할된 복수의 코드 블록 중 적어도 하나의 블록을 포함할 수 있다. 샘플링 블록은 필터링 블록, 학습 블록, 전처리된 블록 등으로 기재될 수 있다. 일 예로, 적어도 하나의 프로세서는 분할된 복수의 코드 블록 중 모든 코드 블록을 샘플링 블록으로 결정 할 수 있다. 일 예로, 적어도 하나의 프로세서는 분할된 복수의 코드 블록 중 일부 코드 블록만을 샘플링 블록으로 결 정할 수 있다. 일 예로, 적어도 하나의 프로세서는 분할된 복수의 코드 블록 중 어느 블록도 샘플링 블록으로 결정하지 않을 수 있다. 적어도 하나의 프로세서는 소스 코드 전체를 코드 생성 모델의 학습 과정에 이용하지 않을 수 있다. 적어도 하나의 프로세서는 제1 코드 블록에 대응되는 제1 토큰 개수를 획득하고, 제2 코드 블록에 대응되 는 제2 토큰 개수를 획득하고, 제1 토큰 개수가 임계 개수 미만이고 제2 토큰 개수가 임계 개수 미만이면, 제1 코드 블록 및 제2 코드 블록을 샘플링 블록으로 결정하고, 제1 토큰 개수가 임계 개수 미만이고 제2 토큰 개수 가 임계 개수 미만이 아니면, 제1 코드 블록을 샘플링 블록으로 결정할 수 있다. 이와 관련된 구체적인 설명은 도 14에서 기재한다. 적어도 하나의 프로세서는 샘플링 블록을 포함하는 전처리된 코드 정보를 획득하고, 전처리된 코드 정보를 입력 데이터로써 코드 생성 모델에 입력함으로써 결과 코드 정보를 획득할 수 있다. 전처리된 코드 정보는 샘플링 블록을 포함할 수 있다. 적어도 하나의 프로세서는 전처리 기능을 수행하여 전처리된 코드 정보를 획득할 수 있다. 적어도 하나의 프로세서는 결정된 샘플링 블록을 코드 생성 모델 의 학습 과정에 이용하기 위해 데이터 포맷을 변경할 수 있다. 적어도 하나의 프로세서는 샘플링 블 록을 기 설정된 포맷에 기초하여 변환(또는 처리)함으로써 전처리된 코드 정보를 획득할 수 있다. 다양한 구현 예에 따라, 적어도 하나의 프로세서는 데이터 포맷을 변경하지 않고 샘플링 블록 자체를 코드 생성 모델의 학습 과정에 이용할 수 있다. 적어도 하나의 프로세서는 전처리된 코드 정보를 코드 생성 모델에 입력할 수 있다. 적어도 하나의 프로세서는 코드 생성 모델을 통해 전처리된 코드 정보에 대응되는 결과 코드 정보를 획득할 수 있다. 결과 코드 정보는 코드 생성 모델에서 생성한 보완 코드를 포함할 수 있다. 보완 코드는 전처리된 코드 정보에 존재하는 오류를 수정한 코드, 전처리된 코드 정보에 존재하는 오류 가능성 을 줄이기 위한 코드, 전처리된 코드 정보에서 효율성을 증가시키기 위한 코드 중 적어도 하나를 포함할 수 있 다. 보완 코드는 수정 코드, 추가 코드, 생성 코드, 변경 코드, 향상 코드, 강화 코드 등으로 기재될 수 있다. 보완 코드를 포함하는 결과 코드 정보와 관련된 설명을 도 15 및 도 17에서 기재한다. 적어도 하나의 프로세서는 기 설정된 단위(제1 단위)에 기초하여 소스 코드를 복수의 코드 블록으로 분할 할 수 있다. 적어도 하나의 프로세서는 결과 코드 정보를 제1 단위가 아닌 제2 단위로 누적함으로써 제3 코드 블록 및 제4 코드 블록을 획득하고, 제3 코드 블록에 대응되는 제3 검사 점수 및 제4 코드 블록에 대응되는 제4 검사 점 수를 획득하고, 제3 검사 점수 및 제4 검사 점수의 평균 검사 점수를 획득할 수 있다. 제1 단위는 함수 단위이고 제2 단위는 라인 단위일 수 있다. 이와 관련된 설명은 도 19에서 기재한다. 적어도 하나의 프로세서는 평균 검사 점수에 기초하여 강화 학습 기능을 수행함으로써 코드 생성 모델 의 파라미터를 변경하고, 변경된 파라미터에 기초하여 코드 생성 모델을 업데이트할 수 있다 강화 학습 기능은 코드 생성 모델과 관련된 파라미터를 반복적으로 업데이트하는 동작을 포함할 수 있다. 이와 관련된 설명은 도 3 및 도 15에서 기재한다. 도 3은 일 실시 예에 따라, 코드 생성 모델을 학습하는 동작을 설명하기 위한 도면이다. 도 3을 참조하면, 전자 장치는 코드 생성 네트워크를 통해 코드 생성 모델을 학습할 수 있다. 코드 생성 네트워크는 전처리 모듈, 소스 코드 데이터 베이스, 코드 생성 모델, 소스 코드 데이터 베이스, 강화 학습 모듈 중 적어도 하나를 포함할 수 있다. 전자 장치는 학습 명령을 획득할 수 있다. 학습 명령은 사용자 입력에 포함될 수 있다. 전처리 모듈은 소스 코드를 분할하여 표준화된 학습 데이터로 변환하는 모듈을 포함할 수 있다. 표준화된 학습 데이터는 소스 코드 중 불필요한 부분이 제외된 데이터를 포함할 수 있다. 전처리 모듈은 학습 명령 을 획득할 수 있다. 전처리 모듈은 학습 명령에 기초하여 소스 코드를 소스 코드 데이터 베이스에 요 청할 수 있다. 소스 코드 데이터 베이스는 복수의 소스 코드를 포함할 수 있다. 소스 코드 데이터 베이스는 특정 카 테고리에 따라 구분된 복수의 소스 코드를 포함할 수 있다. 소스 코드 데이터 베이스는 소스 코드 요청에 포함된 정보를 이용하여 요청에 대응되는 소스 코드를 제공할 수 있다. 소스 코드는 완성 코드, 미완성 코드 또 는 오류를 포함하는 코드 중 적어도 하나를 포함할 수 있다. 소스 코드 데이터 베이스는 전처리 모듈(13 0)로부터 소스 코드를 요청 받을 수 있다. 소스 코드 요청에는 학습 명령을 나타내는 정보가 포함될 수 있다. 소스 코드 데이터 베이스는 소스 코드 요청에 대응되는 소스 코드를 식별할 수 있다. 소스 코드 데이터 베 이스는 식별된 소스 코드를 전처리 모듈에 전송할 수 있다. 전처리 모듈은 소스 코드 데이터 베이스로부터 소스 코드를 수신할 수 있다. 전처리 모듈은 소 스 코드에 기초하여 전처리된 코드 정보를 획득할 수 있다. 전처리 모듈은 전처리 기능을 수행하여 소스 코드를 복수의 코드 블록으로 분할할 수 있다. 전처리 모듈은 복수의 코드 블록 중 샘플링된 코드 블록만 을 이용하여 전처리된 코드 정보를 획득할 수 있다. 전처리 모듈은 전처리된 코드 정보를 코드 생성 모델 에 전송할 수 있다. 코드 생성 모델은 입력 데이터에 대응되는 완성된(또는 보완된) 코드를 제공하는 모델일 수 있다. 입력 데 이터는 미완성 코드 또는 미완성 코드를 나타내는 정보 중 적어도 하나를 포함할 수 있다. 코드 생성 모델(15 0)은 전처리 모듈로부터 전처리된 코드 정보를 수신할 수 있다. 코드 생성 모델은 전처리된 코드 정 보를 이용하여 결과 코드 정보를 생성할 수 있다. 코드 생성 모델은 전처리된 코드 정보를 입력 데이터로 써 이용하여 결과 코드 정보를 출력 데이터로써 획득할 수 있다. 결과 코드 정보는 전처리된 코드 정보를 보완 한 코드를 포함할 수 있다. 코드 생성 모델은 결과 코드 정보를 코드 분석 모듈에 전송할 수 있다. 코드 분석 모듈은 코드를 분석하여 점수화하는 모듈을 포함할 수 있다. 점수화하는 동작은 오류의 발생 가 능성을 나타내는 점수를 계산하는 동작을 포함할 수 있다. 코드 분석 모듈은 코드 생성 모델로부터 결과 코드 정보를 수신할 수 있다. 코드 분석 모듈은 결과 코드 정보의 검사 점수를 획득할 수 있다. 코드 분석 모듈은 결과 코드 정보의 검사 점수를 강화 학습 모듈에 전송할 수 있다. 강화 학습 모듈은 코드 생성 모델과 관련된 학습 동작을 반복 수행하기 위해 파라미터를 변경하는 모 듈을 포함할 수 있다. 강화 학습 모듈은 코드 분석 모듈로부터 결과 코드 정보의 검사 점수를 수신할 수 있다. 강화 학습 모듈은 검사 점수에 기초하여 코드 생성 모델에 포함된 적어도 하나의 파라미터 를 변경할지 여부를 결정할 수 있다. 강화 학습 모듈은 검사 점수에 기초하여 적어도 하나의 파라미터를 변경하고, 변경된 파라미터를 코드 생성 모델에 전송할 수 있다. 코드 생성 모델은 강화 학습 모듈로부터 변경된 파라미터를 수신할 수 있다. 코드 생성 모델은 변경된 파라미터를 이용하여 업데이트될 수 있다. 코드 생성 모델은 변경된 파라미터에 기초하여 전처리된 코드 정보에 대응되는 결과 코드 정보를 재생성할 수 있다. 이후, 전자 장치는 코드 분석 모듈, 강화 학습 모듈을 이용하여 업데이트 과정을 반복할 수 있다. 도 4는 일 실시 예에 따라, 학습 데이터를 전처리하는 동작을 설명하기 위한 도면이다. 도 4를 참조하면, 전처리 모듈은 소스 코드 획득 모듈, 코드 분할 모듈, 오류 메시지 추출 모듈 , 오류 메시지 점수화 모듈, 샘플링 모듈, 학습 데이터 획득 모듈 중 적어도 하나를 포함 할 수 있다.소스 코드 획득 모듈은 소스 코드 데이터 베이스로부터 소스 코드를 획득하는 모듈을 포함할 수 있다. 소스 코드 획득 모듈은 수신된 학습 명령에 기초하여 소스 코드 데이터 베이스에 소스 코드 요 청을 전송할 수 있다. 소스 코드 획득 모듈은 소스 코드 데이터 베이스로부터 요청에 대응되는 소스 코드를 수신할 수 있다. 소스 코드 획득 모듈은 수신된 소스 코드를 코드 분할 모듈에 전송할 수 있 다. 코드 분할 모듈은 소스 코드를 기 설정된 기준에 따라 분할하는 모듈을 포함할 수 있다. 기 설정된 기준은 함수 단위 또는 라인(줄) 단위 중 하나일 수 있다. 코드 분할 모듈은 기 설정된 기준에 따라 소스 코드를 복수의 코드 블록으로 분할 수 있다. 코드 분할 모듈은 코드 블록을 누적하여 분할할 수 있다. 이와 관련 된 설명은 도 6에서 기재한다. 코드 분할 모듈은 분할된 코드 블록을 오류 메시지 추출 모듈에 전송 할 수 있다. 오류 메시지 추출 모듈은 코드 블록에서 발생 가능한 오류를 나타내는 오류 메시지 정보를 생성하는 모듈 을 포함할 수 있다. 오류 메시지 추출 모듈은 코드 분할 모듈로부터 분할된 코드 블록을 수신할 수 있다. 오류 메시지 추출 모듈은 분할된 코드 블록 각각에 대응되는 오류 메시지 정보를 획득할 수 있다. 오류 메시지 정보는 적어도 하나의 세부 오류 메시지를 포함할 수 있다. 세부 오류 메시지는 분할된 코드 블록 에서 발생하는 오류를 나타내는 메시지를 포함할 수 있다. 오류 메시지 추출 모듈은 분할된 코드 블록 각 각에 대응되는 오류 메시지 정보를 오류 메시지 점수화 모듈에 전송할 수 있다. 오류 메시지 추출 모듈 은 제1 정적 분석 모듈로 기재될 수 있다. 오류 메시지 점수화 모듈은 오류 메시지와 관련된 점수를 계산하는 모듈을 포함할 수 있다. 오류 메시지 점수화 모듈은 오류 메시지 추출 모듈로부터 오류 메시지 정보를 수신할 수 있다. 오류 메시지 점수 화 모듈은 분할된 코드 블록 각각에 대응되는 검사 점수를 획득할 수 있다. 검사 점수는 오류의 발생 가능 성을 나타내는 점수를 포함할 수 있다. 검사 점수가 높다는 것은 오류 발생 가능성이 낮음을 나타낼 수 있다. 오류 메시지 점수화 모듈은 분할된 코드 블록 각각에 대응되는 검사 점수를 샘플링 모듈로 전송할 수 있다. 오류 메시지 점수화 모듈은 제2 정적 분석 모듈로 기재될 수 있다. 샘플링 모듈은 검사 점수에 기초하여 복수의 코드 블록 중 일부를 선택하는 모듈을 포함할 수 있다. 샘플 링 모듈은 검사 점수를 이용하여 복수의 코드 블록 중 일부 코드 블록을 샘플링할 수 있다. 샘플링 모듈 은 샘플링된 코드 블록을 학습 데이터 획득 모듈에 전송할 수 있다. 샘플링 모듈은 필터링 모듈 로 기재될 수 있다. 학습 데이터 획득 모듈은 표준화된 학습 데이터를 획득(또는 생성)하는 모듈일 수 있다. 학습 데이터 획득 모듈은 샘플링된 코드 블록만을 포함하는 코드 정보를 획득할 수 있다. 학습 데이터 획득 모듈이 생 성하는 코드 정보는 전처리된 코드 정보로 기재될 수 있다. 학습 데이터 획득 모듈은 전처리된 코드 정보 를 코드 생성 모델에 전송할 수 있다. 학습 데이터 획득 모듈이 획득하는 전처리된 코드 정보의 크기가 소스 코드 획득 모듈에 의해 획득되 는 소스 코드의 크기보다 작을 수 있다. 전처리된 코드 정보는 샘플링된 코드 정보만을 포함하기 때문이다. 샘 플링 동작을 통해 학습 데이터의 크기를 줄일 수 있다. 샘플링 동작을 통해 학습 데이터의 오류 발생율을 줄일 수 있다. 도 5는 일 실시 예에 따라, 검사 점수를 획득하는 동작을 설명하기 위한 도면이다. 도 5를 참조하면, 전자 장치는 학습 명령을 획득할 수 있다 (S505). 전자 장치는 학습 명령에 대응되 는 소스 코드를 획득할 수 있다 (S510). 전자 장치는 소스 코드를 기 설정된 단위로 누적 분할하여 제1 코 드 블록, 제2 코드 블록을 획득할 수 있다. 제2 코드 블록은 제1 코드 블록을 포함할 수 있다. 기 설정된 단위 는 코드를 구분하는 기준을 포함할 수 있다. 기 설정된 단위는 함수 단위 또는 라인 단위 중 적어도 하나를 포 함할 수 있다. 전자 장치는 제1 코드 블록에 대응되는 제1 오류 메시지 정보를 획득할 수 있다 (S520). 전자 장치는 메시지 타입 테이블에 기초하여 제1 오류 메시지 정보에 대응되는 제1 검사 점수를 획득할 수 있다 (S525). 메 시지 타입 테이블은 도 9에서 기재한다. 전자 장치는 제2 코드 블록에 대응되는 제2 오류 메시지 정보를 획득할 수 있다 (S530). 전자 장치는 메시지 타입 테이블에 기초하여 제2 오류 메시지 정보에 대응되는 제2 검사 점수를 획득할 수 있다 (S535).도 6은 일 실시 예에 따라, 코드 블록을 획득하는 동작을 설명하기 위한 도면이다. 도 6을 참조하면, 전자 장치는 소스 코드를 획득할 수 있다. 소스 코드는 48 라인으로 이루어진 코드이며 기 설정된 단위는 함수 단위임을 가정한다. 전자 장치는 함수 단위로 소스 코드를 누적하여 분할할 수 있 다. 전자 장치는 함수 단위로 복수의 코드 블록을 획득할 수 있다. 복수의 코드 블록은 누적된 코드 블록을 포 함할 수 있다. 전자 장치는 제1 함수(flatten)만을 포함하는 제1 코드 블록을 획득할 수 있다. 제1 코드 블록 은 라인 1-19의 코드를 포함할 수 있다. 전자 장치는 제1 함수(flatten) 및 제2 함수(chunks)를 포함하는 제2 코드 블록을 획득할 수 있다. 제2 코드 블록은 라인 1-25의 코드를 포함할 수 있다. 전자 장치는 제1 함수(flatten), 제2 함수(chunks), 제3 함수(remap_nwo)를 포함하는 제3 코드 블록(63 0)을 획득할 수 있다. 제3 코드 블록은 라인 1-35의 코드를 포함할 수 있다. 전자 장치는 제1 함수(flatten), 제2 함수(chunks), 제3 함수(remap_nwo), 제4 함수(get_sha)를 포함하는 제4 코드 블록을 획득할 수 있다. 제4 코드 블록은 라인 1-44의 코드를 포함할 수 있다. 전자 장치는 제1 함수(flatten), 제2 함수(chunks), 제3 함수(remap_nwo), 제4 함수(get_sha), 제5 함수 (download)를 포함하는 제5 코드 블록을 획득할 수 있다. 제5 코드 블록은 라인 1-48의 코드를 포함 할 수 있다. 제5 코드 블록과 소스 코드는 동일할 수 있다. 전자 장치가 획득하는 코드 블록 중 하나는 소스 코드 와 동일할 수 있다. 코드 블록은 누적되면서 획득되기 때문이다. 도 7은 일 실시 예에 따라, 코드 블록 별로 검사 점수를 계산하는 동작을 설명하기 위한 도면이다. 도 7의 제1 코드 블록은 도 6의 제1 코드 블록에 대응될 수 있다. 전자 장치는 제1 코드 블록 에 대응되는 제1 오류 메시지 정보 를 획득할 수 있다. 전자 장치는 오류 메시지 추출 모듈 을 이용하여 제1 코드 블록에 대응되는 제1 오류 메시지 정보를 획득할 수 있다. 전자 장치는 제1 오류 메시지 정보에 기초하여 제1 검사 점수를 획득할 수 있다. 전자 장치 는 오류 메시지 점수화 모듈을 이용하여 제1 오류 메시지 정보에 대응되는 제1 검사 점수 를 획득할 수 있다. 도 8은 일 실시 예에 따라, 코드 블록 별로 검사 점수를 계산하는 동작을 설명하기 위한 도면이다. 도 8은 일 실시 예에 따라, 코드 블록 별로 검사 점수를 계산하는 동작을 설명하기 위한 도면이다. 도 8의 제2 코드 블록은 도 6의 제2 코드 블록에 대응될 수 있다. 전자 장치는 제2 코드 블록 에 대응되는 제2 오류 메시지 정보 를 획득할 수 있다. 전자 장치는 오류 메시지 추출 모듈 을 이용하여 제2 코드 블록에 대응되는 제2 오류 메시지 정보를 획득할 수 있다. 전자 장치는 제2 오류 메시지 정보에 기초하여 제2 검사 점수를 획득할 수 있다. 전자 장치 는 오류 메시지 점수화 모듈을 이용하여 제2 오류 메시지 정보에 대응되는 제2 검사 점수 를 획득할 수 있다. 제2 검사 점수는 도 7의 제1 검사 점수보다 큰 점수를 가질 수 있다. 검사 점수는 높은 값일수록 오 류가 포함될 가능성이 작음을 나타낼 수 있다. 제2 코드 블록이 제1 코드 블록을 포함하고 있다. 따 라서, 제1 코드 블록에서 발생했던 오류가 제2 코드 블록에서는 발생하지 않을 수 있다. 도 9는 일 실시 예에 따라, 메시지 타입에 대응되는 점수를 나타내는 표를 설명하기 위한 도면이다. 도 9의 메시지 타입 테이블은 메시지 타입에 대응되는 기준 점수를 포함할 수 있다. 메시지 타입은 오류 메시지의 타입을 포함할 수 있다. 메시지 타입은 사용자 설정에 따라 분류될 수 있다. 메시지 타입은 제1 타입 (fatal), 제2 타입(error), 제3 타입(warning), 제4 타입(refactor), 제5 타입(convention ) 중 적어도 하나를 포함할 수 있다.제1 타입(fatal)은 정적 분석이 불가능한 타입을 포함할 수 있다. 제1 타입에 대응되는 점수는 1일 수 있다. 제2 타입(error)은 버그가 존재하는 타입을 포함할 수 있다. 제2 타입에 대응되는 점수는 2일 수 있다. 제3 타입(warning)은 프로그래밍 언어의 문법 오류가 존재하는 타입을 포함할 수 있다. 제3 타입에 대응되는 점 수는 3일 수 있다. 제4 타입(refactor)은 호환성 오류가 존재하는 타입을 포함할 수 있다. 제4 타입에 대응되는 점수는 4일 수 있 다. 제5 타입(convention )은 프로그래밍 언어의 규칙 오류가 존재하는 타입을 포함할 수 있다. 제5 타입에 대응되 는 점수는 5일 수 있다. 도 9에서는 5가지 타입으로 분류하였으나 이에 반드시 제한되는 것은 아니다. 도 10은 일 실시 예에 따라, 메시지 타입에 대응되는 점수에 기초하여 검사 점수를 계산하는 동작을 설명하기 위한 도면이다. 도 10을 참조하면, 전자 장치는 제1 코드 블록에 대응되는 제1 오류 메시지 정보를 획득할 수 있다 (S1005). 전자 장치는 제1 오류 메시지 정보에 포함된 복수의 세부 오류 메시지를 획득할 수 있다 (S1010). 전자 장치는 복수의 세부 오류 메시지 각각에 대응되는 메시지 타입을 식별할 수 있다 (S1015). 전자 장치 는 메시지 타입에 대응되는 기준 점수에 기초하여 제1 오류 메시지 정보의 제1 검사 점수를 획득할 수 있 다 (S1020). 전자 장치는 복수의 세부 오류 메시지 각각에 대응되는 메시지 타입을 획득할 수 있다. 전자 장치는 도 9의 메시지 타입 테이블을 이용하여 복수의 세부 오류 메시지 각각에 대응되는 점수를 획득할 수 있다. 도 10의 동작은 제2 코드 블록에 대응되는 제2 검사 점수를 획득하는데 동일하게 적용될 수 있다. 도 11은 일 실시 예에 따라, 비율 정보를 이용하여 검사 점수를 획득하는 동작을 설명하기 위한 도면이다. 도 11의 표는 특정 코드 블록의 오류 메시지의 타입 개수 및 타입 별 비율 정보를 포함할 수 있다. 특정 코드 블록의 제1 타입의 세부 오류 메시지가 n1개이고, 제2 타입의 세부 오류 메시지가 n2개이고, 제3 타 입의 세부 오류 메시지가 n3개이고, 제4 타입의 세부 오류 메시지가 n4개이고, 제5 타입의 세부 오류 메시지가 n5개라고 가정한다. 전자 장치는 전체 세부 오류 메시지의 개수(n_total)에서 각 타입 별 세부 오류 메시지의 개수가 차지하는 비율 정보를 획득할 수 있다. n_total은 n1+n2+n3+n4+n5일 수 있다. 제1 타입의 제1 비율 정보(R1)는 n1/ n_total 일 수 있다. 제2 타입의 제2 비율 정보(R2)는 n2/ n_total 일 수 있다. 제3 타입의 제3 비율 정보(R3)는 n3/ n_total 일 수 있다. 제4 타입의 제4 비율 정보(R4)는 n4/ n_total 일 수 있다. 제5 타입의 제5 비율 정보(R5)는 n5/ n_total 일 수 있다. 제1 비율 정보(R1), 제2 비율 정보(R2), 제3 비율 정보(R3), 제4 비율 정보(R4), 제5 비율 정보(R5)의 합은 1 일 수 있다. 실시 예는 비율 정보를 이용하여 검사 점수를 획득하는 수식을 포함할 수 있다. 검사 점수는 1에서 종합 비율 정보(R_total)를 뺄셈하여 획득할 수 있다. 종합 비율 정보(R_total)는 제2 비율 정보(R2)와 제1 가중치(w1)를 곱셈한 제1값(R2*w1), 제3 비율 정보(R3)와 제2 가중치(w2)를 곱셈한 제2값(R3*w2), 제4 비율 정보(R4)와 제3 가중치(w3)를 곱셈한 제3값(R4*w3), 제5 비 율 정보(R5)와 제4 가중치(w4)를 곱셈한 제4값(R5*w4)을 합산한 값일 수 있다. 제1 가중치(w1)는 제2 타입에 대응되는 가중치일 수 있다. 제2 가중치(w2)는 제3 타입에 대응되는 가중치일 수 있다. 제3 가중치(w3)는 제4 타입에 대응되는 가중치일 수 있다. 제4 가중치(w4)는 제5 타입에 대응되는 가중치일 수 있다. 실시 예는 실시 예와 관련된 조건을 나타낼 수 있다. 제1 가중치(w1)는 제2 가중치(w2)보다 크고, 제2 가중치(w2)는 제3 가중치(w3)보다 크고, 제3 가중치(w3)는 제4 가중치(w4)보다 클 수 있다. 제1 가중치(w1), 제2 가중치(w2), 제3 가중치(w3), 제4 가중치(w4)의 합은 1일 수 있다. 제1 타입에 대응되는 가중치는 고려하지 않을 수 있다. 전자 장치는 제1 타입은 치명적인 오류를 포함하기 때문에 검사 점수를 0으로 계산할 수 있다. 이와 관련된 설명은 도 12에서 기재한다. 도 12는 일 실시 예에 따라, 비율 정보를 이용하여 검사 점수를 획득하는 동작을 설명하기 위한 도면이다. 도 12를 참조하면, 전자 장치는 제1 코드 블록에 대응되는 제1 오류 메시지 정보를 획득할 수 있다 (S1205). 전자 장치는 제1 오류 메시지 정보에 포함된 복수의 세부 오류 메시지를 획득할 수 있다 (S1210). 전자 장치는 복수의 세부 오류 메시지 각각에 대응되는 메시지 타입을 식별할 수 있다 (S1215). 전자 장치는 식별된 적어도 하나의 메시지 타입에 제1 타입(fatal)의 세부 오류 메시지가 포함되어 있는지 여부를 판단할 수 있다 (S1220). 식별된 적어도 하나의 메시지 타입에 제1 타입(fatal)의 세부 오류 메시지가 포함되어 있으면 (S1220-Y), 전자 장치는 제1 코드 블록을 샘플링 대상에서 제외할 수 있다 (S1225). 전자 장치는 제1 타입의 세부 오 류 메시지는 치명적인 오류 메시지로 보아 표준화된 코드가 아니라고 판단할 수 있다. 전자 장치는 제1 코 드 블록을 학습 데이터로 이용하지 않을 수 있다. 식별된 적어도 하나의 메시지 타입에 제1 타입(fatal)의 세부 오류 메시지가 포함되어 있지 않은 경우 (S1220- N), 전자 장치는 타입 별 비율 정보를 획득할 수 있다 (S1230). 타입 별 비율 정보는 도 11의 제1 비율 정 보(R1), 제2 비율 정보(R2), 제3 비율 정보(R3), 제4 비율 정보(R4), 제5 비율 정보(R5)를 포함할 수 있다. 전자 장치는 타입 별 비율 정보 및 타입 별 가중치 정보에 기초하여 검사 점수를 획득할 수 있다 (S1235). 타입 별 가중치 정보는 제1 가중치(w1), 제2 가중치(w2), 제3 가중치(w3), 제4 가중치(w4)를 포함할 수 있다. 도 13은 일 실시 예에 따라, 검사 점수를 이용한 샘플링 동작을 설명하기 위한 도면이다. 도 13을 참조하면, 전자 장치는 제1 코드 블록에 대응되는 제1 검사 점수를 획득할 수 있다 (S1305). 전자 장치는 제2 코드 블록에 대응되는 제2 검사 점수를 획득할 수 있다 (S1310). 전자 장치는 제1 검사 점수가 임계값 이상인지 판단할 수 있다 (S1315). 제1 검사 점수가 임계값 이상이면 (S1315-Y), 전자 장치는 제2 검사 점수가 임계값 이상인지 판단할 수 있다 (S1320). 제2 검사 점수가 임계값 이상이면 (S1320-Y), 전자 장치는 제1 코드 블록 및 제2 코드 블록을 모두 샘플링 할 수 있다 (S1325). 전자 장치는 제1 코드 블록 및 제2 코드 블록을 모두 학습 데이터로써 이용할 수 있 다. 제2 검사 점수가 임계값 이상이 아니면 (S1320-N), 전자 장치는 제1 코드 블록을 샘플링할 수 있다 (S1330). 전자 장치는 제1 코드 블록을 학습 데이터로써 이용할 수 있다. 제1 검사 점수가 임계값 이상이 아니면 (S1315-N), 전자 장치는 제2 검사 점수가 임계값 이상인지 판단할 수 있다 (S1335). 제2 검사 점수가 임계값 이상이면 (S1335-Y), 전자 장치는 제2 코드 블록을 샘플링할 수 있다 (S1340). 전 자 장치는 제2 코드 블록을 학습 데이터로써 이용할 수 있다. 제2 검사 점수가 임계값 이상이 아니면 (S1335-N), 전자 장치는 샘플링 데이터가 없다고 판단할 수 있다. 전자 장치는 복수의 코드 블록 각각에 대응되는 검사 점수를 획득하고, 검사 점수가 임계값 이상인 코드 블록만을 샘플링할 수 있다. 전자 장치는 임계값 미만의 검사 점수에 대응되는 코드 블록은 표준화된 코드 가 아니라고 판단할 수 있다. 다양한 실시 예에 따라, 제1 검사 점수와 비교하는 제1 임계값과 제2 검사 점수와 비교하는 제2 임계값이 상이 할 수 있다. 도 14는 일 실시 예에 따라, 토큰 개수를 이용한 샘플링 동작을 설명하기 위한 도면이다. 도 14을 참조하면, 전자 장치는 제1 코드 블록에 대응되는 제1 토큰 개수를 획득할 수 있다 (S1405). 전자 장치는 제2 코드 블록에 대응되는 제2 토큰 개수를 획득할 수 있다 (S1410). 토큰은 코드를 구성하는 기 설정된 단위를 포함할 수 있다. 토큰은 프로그래밍 언어 또는 스크립트에서 최소 단 위의 요소(element)를 포함할 수 있다. 토큰은 해석의 최소 단위를 포함할 수 있다. 토큰은 식별자, 키워드, 연 산자, 구두점, 주석, 공백, 문자 중 적어도 하나를 포함할 수 있다. 전자 장치는 각 코드 블록에 대응되는 토큰 개수를 계산(또는 획득)할 수 있다. 전자 장치는 제1 토큰 개수가 임계 개수 미만인지 판단할 수 있다 (S1415). 제1 토큰 개수가 임계 개수 미 만이면 (S1415-Y), 전자 장치는 제2 토큰 개수가 임계 개수 미만인지 판단할 수 있다 (S1420). 제2 토큰 개수가 임계 개수 미만이면 (S1420-Y), 전자 장치는 제1 코드 블록 및 제2 코드 블록을 모두 샘 플링할 수 있다 (S1425). 전자 장치는 제1 코드 블록 및 제2 코드 블록을 모두 학습 데이터로써 이용할 수 있다. 제2 토큰 개수가 임계 개수 미만이 아니면 (S1420-N), 전자 장치는 제1 코드 블록을 샘플링할 수 있다 (S1430). 전자 장치는 제1 코드 블록을 학습 데이터로써 이용할 수 있다. 제1 토큰 개수가 임계 개수 미만이 아니면 (S1415-N), 전자 장치는 샘플링 데이터가 없다고 판단할 수 있 다 (S1445). 제1 코드 블록이 제2 코드 블록보다 작은 크기일 수 있다. 제1 코드 블록의 제1 토큰 개수가 이미 임계 개수 이상이면, 전자 장치는 제2 코드 블록의 제2 토큰 개수도 반드시 임계 개수 이상인 것으로 판단 할 수 있다. 전자 장치는 제1 코드 블록 및 제2 코드 블록 모두 샘플링 대상에서 제외할 수 있다. 전자 장치는 복수의 코드 블록 각각에 대응되는 토큰 개수를 획득하고, 토큰 개수가 임계 개수 미만인 코 드 블록만을 샘플링할 수 있다. 전자 장치는 임계 개수 미만의 토큰 개수에 대응되는 코드 블록은 표준화 된 코드가 아니라고 판단할 수 있다. 다양한 실시 예에 따라, S1410, S1415 단계의 순서가 변경될 수 있다. S1415 단계를 먼저 수행하고 S1410 단계 를 수행할 수 있다. 도 15는 일 실시 예에 따라, 코드 생성 모델을 학습하는 동작을 설명하기 위한 도면이다. 도 15를 참조하면, 전자 장치는 샘플링된 적어도 하나의 코드 블록을 포함하는 전처리된 코드 정보를 획득 할 수 있다 (S1505). 전자 장치는 전처리된 코드 정보를 입력 데이터로써 코드 생성 모델에 입력하여 결과 코드 정보를 획 득할 수 있다 (S1510). 전자 장치는 결과 코드 정보에 기초하여 검사 점수를 획득할 수 있다 (S1515). 전자 장치는 검사 점수에 기초하여 강화 학습을 수행함으로써 코드 생성 모델의 파라미터를 변경할 수 있다 (S1520). 전자 장치는 변경된 파라미터에 기초하여 코드 생성 모델을 업데이트할 수 있다. 전자 장치는 기 설정된 이벤트가 식별될 때까지 업데이트 동작을 반복할 수 있다. 기 설정된 이벤트는 검사 점수가 임계값 이상인 이벤트, 업데이트 반복 횟수가 임계 횟수 이상인 이벤트, 전처 리된 코드 정보가 더 이상 획득되지 않는 이벤트 중 적어도 하나를 포함할 수 있다. 도 16은 일 실시 예에 따라, 오류 메시지를 설명하기 위한 도면이다. 도 16의 실시 예는 세부 오류 메시지를 포함할 수 있다. 실시 예에서 5개의 세부 오류 메시지가 식 별됨을 가정한다. 제1 세부 오류 메시지는 특정 변수(foo)가 정의되었으나 이용되지 않았음을 나타내는 메시지일 수 있다. 제1 세부 오류 메시지는 제2 타입일 수 있다. 제2 세부 오류 메시지는 특정 문자열(use strict)이 단일 따옴표가 하나를 이용하였음을 나타내는 메시지 일 수 있다. 단일 따옴표는 특정 프로그래밍 언어에서 이용되지 않을 수 있다. 제2 세부 오류 메시지는 제2 타입일 수 있다. 제3 세부 오류 메시지는 특정 함수(fn)가 정의되지 않았음을 나타내는 메시지일 수 있다. 제3 세부 오류 메시지는 제2 타입일 수 있다. 제4 세부 오류 메시지는 비동기 콜백 함수에서 발생한 오류를 처리하지 않음을 나타내는 메시지일 수 있 다. 제4 세부 오류 메시지는 제3 타입일 수 있다. 제5 세부 오류 메시지는 특정 변수(err)가 정의되었으나 이용되지 않았음을 나타내는 메시지일 수 있다. 제5 세부 오류 메시지는 제1 타입일 수 있다. 도 17은 일 실시 예에 따라, 결과 코드 정보를 설명하기 위한 도면이다. 도 17을 참조하면, 전자 장치는 입력 데이터를 코드 생성 모델에 입력하여 출력 데이터 를 획득할 수 있다. 입력 데이터는 사용자 입력에 대응되는 코드일 수 있다. 일 예로, 입력 데이터는 사용자가 직접 입력한 코드일 수 있다. 일 예로, 입력 데이터는 사용자 입력에 기초하여 획득된 소스 코드일 수 있다. 전자 장치는 복수의 소스 코드가 포함된 소스 코드 데이터 베이스로부터 사용자 입력에 대응되는 소스 코드를 획득할 수 있다. 사용자 입력은 “2개의 숫자를 입력 받아 초기값 저장, 덧셈을 수행하는 코드 만들어줘”와 같은 텍스트(또는 오디오) 정보를 포함할 수 있다. 전자 장치는 코드 생성 모델을 이용하여 보완된 코드를 포함하는 출력 데이터를 생성할 수 있 다. 보완된 코드는 “try”, \"except ValueError:\", \"print(\"올바른 숫자 형식을 입력하세요.\")\"를 포함할 수 있다. 보완된 코드가 추가되는 경우 사용자아 숫자를 입력하지 않은 경우 에러 메시지를 표시할 수 있다. 숫자 만을 이용해야 하는 계산 동작에서 사용자가 문자를 잘못 입력할 수 있다. 전자 장치는 사용자가 문자가 아닌 숫자를 입력할 것을 가이드하는 보완 코드를 추가함으로써 출력 데이터를 생성할 수 있다. 전자 장치는 사용자의 수동 조작 없이 입력 데이터보다 완성도가 높은 출력 데이터를 획득할 수 있다. 코드 생성 모델은 표준화된 학습 데이터에 기초하여 학습된 모델일 수 있다. 도 18은 일 실시 예에 따라, 프롬프트를 이용하여 결과 코드 정보를 획득하는 동작을 설명하기 위한 도면이다. 도 18을 참조하면, 전자 장치는 입력 데이터를 코드 생성 모델에 입력하여 출력 데이터 를 획득할 수 있다. 입력 데이터는 프롬프트(prompt) 코드 정보를 포함할 수 있다. 프롬프트 코드 정보는 기 설정된 코드 포 맷을 포함할 수 있다. 프롬프트 코드 정보는 완성된 코드가 아니라 코드 포맷 또는 코드 스타일을 포함할 수 있 다. 프롬프트 코드 정보는 함수 이름만을 정의하는 코드를 포함할 수 있다. 전자 장치는 코드 생성 모델을 이용하여 프롬프트 코드 정보에 대응되는 세부 정보를 생성할 수 있다. 전자 장치는 프롬프트 코드 정보에 포함된 코드 포맷을 이용하여 완성된 코드를 포함하는 출력 데이 터를 획득할 수 있다. 예를 들어, 입력 데이터는 제1 함수(flattern(I)), 제2 함수(chunks(I : List.n : int) 내용만을 포함할 수 있다. 코드 생성 모델을 이용하여 제1 함수(flattern(I))에 대한 구체적인 세부 코드 및 제2 함수 (chunks(I : List.n : int)에 대한 구체적인 세부 코드를 포함하는 출력 데이터를 생성할 수 있다. 도 19는 일 실시 예에 따라, 코드 블록을 라인별로 설정하는 동작을 설명하기 위한 도면이다. 도 19를 참조하면, 전자 장치는 복수의 코드 블록을 라인(줄) 별로 분할할 수 있다. 17 줄의 소스 코드가 있음을 가정한다. 전자 장치는 라인 별로 코드를 분할하여 17개의 코드 블록을 생성할 수 있다. 코드 블록 은 누적될 수 있다. 제1 코드 블록은 1 라인에 대응되는 코드를 포함할 수 있다. 제1 코드 블록에 대응되는 점수는 s1일 수 있다. 제2 코드 블록은 1-2 라인에 대응되는 코드를 포함할 수 있다. 제2 코드 블록에 대응되는 점수는 s2일 수 있다. 제17 코드 블록은 1-17 라인에 대응되는 코드를 포함할 수 있다. 제17 코드 블록에 대응되는 점수는 s17일 수 있다. 다양한 실시 예에 따라, 전자 장치는 검사 점수를 계산하는 경우 “0”은 제외하여 계산될 수 있다. 전자 장치는 획득된 복수의 검사 점수 중 “0”을 제외한 값들의 평균값을 검사 점수로 획득할 수 있다. 전자 장치는 라인 별로 분할된 복수의 코드 블록 각각에 대응되는 검사 점수를 획득할 수 있다. 도 20은 일 실시 예에 따라, 일 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다."}
{"patent_id": "10-2023-0119295", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일 실시 예에 따라, 코드 생성 모델을 설명하기 위한 도면이다. 도 2는 일 실시 예에 따라, 전자 장치를 도시한 블록도이다. 도 3은 일 실시 예에 따라, 코드 생성 모델을 학습하는 동작을 설명하기 위한 도면이다. 도 4는 일 실시 예에 따라, 학습 데이터를 전처리하는 동작을 설명하기 위한 도면이다. 도 5는 일 실시 예에 따라, 검사 점수를 획득하는 동작을 설명하기 위한 도면이다. 도 6은 일 실시 예에 따라, 코드 블록을 획득하는 동작을 설명하기 위한 도면이다. 도 7은 일 실시 예에 따라, 코드 블록 별로 검사 점수를 계산하는 동작을 설명하기 위한 도면이다. 도 8은 일 실시 예에 따라, 코드 블록 별로 검사 점수를 계산하는 동작을 설명하기 위한 도면이다. 도 9는 일 실시 예에 따라, 메시지 타입에 대응되는 점수를 나타내는 표를 설명하기 위한 도면이다. 도 10은 일 실시 예에 따라, 메시지 타입에 대응되는 점수에 기초하여 검사 점수를 계산하는 동작을 설명하기 위한 도면이다. 도 11은 일 실시 예에 따라, 비율 정보를 이용하여 검사 점수를 획득하는 동작을 설명하기 위한 도면이다. 도 12는 일 실시 예에 따라, 비율 정보를 이용하여 검사 점수를 획득하는 동작을 설명하기 위한 도면이다. 도 13은 일 실시 예에 따라, 검사 점수를 이용한 샘플링 동작을 설명하기 위한 도면이다. 도 14는 일 실시 예에 따라, 토큰 개수를 이용한 샘플링 동작을 설명하기 위한 도면이다. 도 15는 일 실시 예에 따라, 코드 생성 모델을 학습하는 동작을 설명하기 위한 도면이다. 도 16은 일 실시 예에 따라, 오류 메시지를 설명하기 위한 도면이다. 도 17은 일 실시 예에 따라, 결과 코드 정보를 설명하기 위한 도면이다. 도 18은 일 실시 예에 따라, 프롬프트를 이용하여 결과 코드 정보를 획득하는 동작을 설명하기 위한 도면이다. 도 19는 일 실시 예에 따라, 코드 블록을 라인별로 설정하는 동작을 설명하기 위한 도면이다. 도 20은 일 실시 예에 따라, 일 실시 예에 따른 전자 장치의 제어 방법을 설명하기 위한 도면이다."}
