{"patent_id": "10-2024-0095200", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0032914", "출원번호": "10-2024-0095200", "발명의 명칭": "CTR 모드를 이용한 업데이트 패키지 암호화 방법 및 장치", "출원인": "현대자동차주식회사", "발명자": "정창훈"}}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "적어도 하나의 프로세서를 포함하는 컴퓨팅 장치에 의해 수행되는, CTR 모드를 이용한 업데이트 패키지 암호화방법으로서,차량으로부터 업데이트 패키지를 수신하는 과정;임의의 초기 벡터(IV)를 생성하는 과정;생성된 초기 벡터를 이용하여 상기 업데이트 패키지를 기 설정된 비트(bit) 길이로 암호화하는 과정; 및암호화된 업데이트 패키지를 전부 전송할 때까지 상기 암호화하는 과정을 수행하는, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서,상기 암호화하는 과정은,상기 임의의 초기 벡터 및 키(key)값을 HMAC 함수에 대입하여 H값을 계산하는 과정;상기 H값을 이용하여 시프트(shift)값을 결정하는 과정;암호화 데이터를 결정된 시프트값에 따라 시프트 연산을 수행하는 과정; 및시프트된 암호화 데이터를 평문과 XOR 연산하는 과정을 포함하는, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2 항에 있어서,상기 H값을 이용하여 상기 시프트값을 결정하는 과정은,상기 H값의 하위 8 bit를 추출한 후, 64로 나눈 나머지 값을 계산하는, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2 항에 있어서,상기 암호화 데이터는,상기 초기벡터와 카운터값을 합친 결과를 상기 키와 함께 블록 암호 알고리즘을 이용하여 생성한 결과값인, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2 항에 있어서,상기 암호화된 데이터를 결정된 시프트값에 따라 시프트 연산을 수행하는 과정은,상기 암호화된 데이터를 상기 시프트값만큼 왼쪽으로 시프트하고, 다시 64비트 오른쪽으로 시프트하여 하위 64비트를 추출하는 과정인, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "적어도 하나의 프로세서를 포함하는 컴퓨팅 장치에 의해 수행되는, CTR 모드를 이용한 업데이트 패키지 암호화방법으로서,임의의 초기 벡터를 수신하는 과정;공개특허 10-2025-0032914-3-상기 임의의 초기 벡터를 이용하여 시프트 연산을 수행하는 과정;암호화된 업데이트 패키지를 수신하는 과정; 및상기 암호화된 업데이트 패키지를 복호화하는 과정을 포함하는, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6 항에 있어서,시프트 연산을 수행하는 과정은,상기 임의의 초기 벡터 및 키값을 HMAC 함수에 대입하여 H값을 계산하는 과정;상기 H값을 이용하여 시프트값을 결정하는 과정; 및암호화 데이터를 결정된 시프트값에 따라 시프트 연산을 수행하는 과정을 포함하는, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7 항에 있어서,상기 H값을 이용하여 상기 시프트값을 결정하는 과정은,상기 H값의 하위 8 bit를 추출한 후, 64로 나눈 나머지 값을 계산하는, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제7 항에 있어서,상기 암호화 데이터는,상기 초기벡터와 카운터값을 합친 결과를 상기 키와 함께 블록 암호 알고리즘을 이용하여 생성한 결과값인, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제7 항에 있어서,상기 암호화 데이터를 결정된 시프트값에 따라 시프트 연산을 수행하는 과정은,상기 암호화된 데이터를 상기 시프트값만큼 왼쪽으로 시프트하고, 다시 64비트 오른쪽으로 시프트하여 하위 64비트를 추출하는 과정인, 방법."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "적어도 하나의 메모리; 및적어도 하나의 프로세서를 포함하되,상기 적어도 하나의 프로세서는 명령어들을 실행함으로써,차량으로부터 업데이트 패키지를 수신하고,임의의 초기 벡터(IV)를 생성하고,생성된 초기 벡터를 이용하여 상기 업데이트 패키지를 기 설정된 비트 길이로 암호화하고,암호화된 업데이트 패키지를 전부 전송할 때까지 상기 암호화하는, 장치."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11 항에 있어서,상기 암호화는,공개특허 10-2025-0032914-4-상기 임의의 초기 벡터 및 키 값을 HMAC 함수에 대입하여 H값을 계산하고,상기 H값을 이용하여 시프트값을 결정하고,암호화 데이터를 결정된 시프트값에 따라 시프트 연산을 수행하고,시프트된 암호화 데이터를 평문과 XOR 연산하는 것을 포함하는, 장치."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12 항에 있어서,상기 H값을 이용하여 상기 시프트값을 결정하는 것은,상기 H값의 하위 8 bit를 추출한 후, 64로 나눈 나머지 값을 계산하는 것인, 장치."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제12 항에 있어서,상기 암호화 데이터는,상기 초기벡터와 카운터값을 합친 결과를 상기 키와 함께 블록 암호 알고리즘을 이용하여 생성한 결과값인, 장치."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제12 항에 있어서,상기 암호화된 데이터를 결정된 시프트값에 따라 시프트 연산을 수행하는 것은,상기 암호화된 데이터를 상기 시프트값만큼 왼쪽으로 시프트하고, 다시 64비트 오른쪽으로 시프트하여 하위 64비트를 추출하는 것인, 장치."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "적어도 하나의 메모리; 및적어도 하나의 프로세서를 포함하되,상기 적어도 하나의 프로세서는 명령어들을 실행함으로써,임의의 초기 벡터를 수신하고,상기 임의의 초기 벡터를 이용하여 시프트 연산을 수행하고,암호화된 업데이트 패키지를 수신하고,상기 암호화된 업데이트 패키지를 복호화하는, 장치."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16 항에 있어서,상기 시프트 연산은,상기 임의의 초기 벡터 및 키 값을 HMAC 함수에 대입하여 H값을 계산하고;상기 H값을 이용하여 시프트값을 결정하고암호화 데이터를 결정된 시프트값에 따라 시프트 연산을 수행하는 것을 포함하는, 장치."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17 항에 있어서,상기 H값을 이용하여 상기 시프트값을 결정하는 것은공개특허 10-2025-0032914-5-상기 H값의 하위 8 bit를 추출한 후, 64로 나눈 나머지 값을 계산하는 것인, 장치."}
{"patent_id": "10-2024-0095200", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제17 항에 있어서,상기 암호화 데이터를 결정된 시프트값에 따라 시프트 연산을 수행하는 것은,상기 암호화된 데이터를 상기 시프트값만큼 왼쪽으로 시프트하고, 다시 64비트 오른쪽으로 시프트하여 하위 64비트를 추출하는 것인, 장치."}
{"patent_id": "10-2024-0095200", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 개시는 CTR 모드를 이용한 업데이트 패키지 암호화 방법 및 장치를 제공한다. 본 개시의 일 측면에 의하면, 적어도 하나의 프로세서를 포함하는 컴퓨팅 장치에 의해 수행되는, CTR 모드를 이 용한 업데이트 패키지 암호화 방법으로서, 차량으로부터 업데이트 패키지를 수신하는 과정; 임의의 초기 벡터 (IV)를 생성하는 과정; 생성된 초기 벡터를 이용하여 상기 업데이트 패키지를 기 설정된 비트(bit) 길이로 암호 화하는 과정; 및 암호화된 업데이트 패키지를 전부 전송할 때까지 상기 암호화하는 과정을 수행하는, CTR 모드를 이용한 업데이트 패키지 암호화방법을 제공한다."}
{"patent_id": "10-2024-0095200", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 CTR 모드를 이용한 업데이트 패키지 암호화 방법 및 시스템에 관한 것으로, 더욱 상세하게는, CTR 모 드를 이용한 차량 내부 네트워크에서의 업데이트 패키지 암호화 방법 및 장치에 관한 것이다."}
{"patent_id": "10-2024-0095200", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "이하에 기술되는 내용은 단순히 본 실시예와 관련되는 배경 정보만을 제공할 뿐 종래기술을 구성하는 것이 아니 다 배터리 기술의 발전 및 충전 인프라 구축에 따라 전기 자동차의 시장 규모가 점점 커지고 있다. 또한, 인공 지 능, 이동/무선 통신, 클라우드, 센서, 정밀 측위 등의 기술 발전에 따라 자동차에 적용되는 자율 주행 단계도 점점 올라가고 있다. 이러한 환경에서 주행 안전, 운전자 보조, 자율주행 등의 다양한 기능과 서비스를 수행하기 위해, 제어기 (Electronic Control Unit: ECU)에 의해 구동되는 전장화된 또는 전자화된 장치 또는 부품 등이 다수 차량에 탑 재되고 있다. 자율주행 단계가 올라가거나 차량의 선택 사양이 높아질수록, 차량에서 전장 부품이 차지하는 비중이 커지고, 이러한 전장 부품을 효율적으로 구동하기 위한 소프트웨어의 중요성이 커진다. 이러한 차량에 탑재되는 전장 부품은, 차량 내부의 통신 네트워크를 경유하여 차량 외부의 네트워크에 연결되어, 주행과 관련한 차량 내부의 정보뿐만 아니라 차량 외부의 정보를 차량 내부의 다른 전장 부품이나 다 른 차량 또는 차량 외부의 다른 장치와 주고받을 수 있다. 이러한 네트워크 연결 환경에서는, 차량에 등록된 개인 정보, 스마트 키, 차량 운영 소프트웨어 등을 외부의 공 격으로부터 안전하게 보호하는 차량 보안(vehicle security)이 중요해진다. 외부 공격에 의해 차량 내부 소프트 웨어가 오작동하면 차량 및 탑승자에게 치명적인 결과를 초래할 수 있다. 특히, 차량 내부 소프트웨어를 원격으로 업데이트하는 OTA(Over The Air) 기능을 차량에 적용하는 경우 보안의 중요성은 더욱 커진다. OTA는 무선 네트워크와 클라우드와 연계되어 다양한 보안 이슈가 발생할 가능성이 높기 때문이다. OTA 적용 시 업데이트 서버로부터 차량의 VMG(Vehicle Mobile Gateway)까지 TLS(Transport Layer Security) 등 을 이용하여 업데이트 패키지(update package)를 암호화(encryption)하여 공격자가 업데이트 패키지를 수집하는 것을 방지하고 있다. 하지만, 차량 내부에 OTA 마스터(master)로부터 타겟(target) ECU까지는 평문상태(plain text)로 전송됨에 따라 외부 공격에 노출될 가능성이 높다."}
{"patent_id": "10-2024-0095200", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시는 이러한 상황을 감안한 것으로, 본 개시의 목적은 차량 내부에서도 손쉽게 업데이트 패키지를 암호화 하여 외부 공격으로부터 보호하기 위한 방법 및 장치를 제공하는 데 있다. 본 개시의 다른 목적은, CTR 모드를 이용한 암호화 방법을 적용함으로써, 차량 내부 네트워크에서도 데이터 보 호를 강화하는 데 목적이 있다. 본 발명이 해결하고자 하는 과제들은 이상에서 언급한 과제들로 제한되지 않으며, 언급되지 않은 또 다른 과제 들은 아래의 기재로부터 통상의 기술자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2024-0095200", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시의 일 측면에 의하면, 적어도 하나의 프로세서를 포함하는 컴퓨팅 장치에 의해 수행되는, CTR 모드를 이 용한 업데이트 패키지 암호화 방법으로서, 차량으로부터 업데이트 패키지를 수신하는 과정; 임의의 초기 벡터 (IV)를 생성하는 과정; 생성된 초기 벡터를 이용하여 상기 업데이트 패키지를 기 설정된 비트(bit)길이로 암호 화하는 과정; 및 암호화된 업데이트 패키지를 전부 전송할 때까지 상기 암호화하는 과정을 수행하는, CTR 모드 를 이용한 업데이트 패키지 암호화 방법을 제공할 수 있다. 본 개시의 다른 측면에 의하면, 적어도 하나의 프로세서를 포함하는 컴퓨팅 장치에 의해 수행되는, CTR 모드를 이용한 업데이트 패키지 암호화 방법으로서, 임의의 초기 벡터를 수신하는 과정; 상기 임의의 초기 벡터를 이용 하여 시프트 계산하는 과정; 암호화된 업데이트 패키지를 수신하는 과정; 및 상기 암호화된 업데이트 패키지를 복호화하는 과정을 포함하는, CTR 모드를 이용한 업데이트 패키지 암호화 방법을 제공할 수 있다. 본 개시의 다른 측면에 의하면, 적어도 하나의 메모리; 및 적어도 하나의 프로세서를 포함하되, 상기 적어도 하 나의 프로세서는 명령어들을 실행함으로써, 차량으로부터 업데이트 패키지를 수신하고, 임의의 초기 벡터(IV)를 생성하고, 생성된 초기 벡터를 이용하여 상기 업데이트 패키지를 기 설정된 비트 길이로 암호화하고, 암호화된 업데이트 패키지를 전부 전송할 때까지 상기 암호화하는, CTR 모드를 이용한 업데이트 패키지 암호화 장치를 제 공할 수 있다. 본 개시의 다른 측면에 의하면, 적어도 하나의 메모리; 및 적어도 하나의 프로세서를 포함하되, 상기 적어도 하 나의 프로세서는 명령어들을 실행함으로써, 임의의 초기 벡터를 수신하고, 상기 임의의 초기 벡터를 이용하여 시프트 계산하고, 암호화된 업데이트 패키지를 수신하고, 상기 암호화된 업데이트 패키지를 복호화하는, CTR 모 드를 이용한 업데이트 패키지 암호화 장치를 제공할 수 있다."}
{"patent_id": "10-2024-0095200", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시의 실시예에 의하면, 대칭키 암호 운용모드 중 하나인 CTR 모드를 이용하여 업데이트 패키지를 암호화하 는 방법을 적용함으로써, 업데이트 과정은 운행 중인 차량의 내부 네트워크 메세지들과 달리 실시간성(real time property)이 크리티컬(critical)하지 않기 때문에 암호화 적용이 가능하다. 본 개시의 실시예에 의하면, CTR 모드를 이용하여 암호화함으로써, 데이터의 기밀성을 확보할 수 있다. 본 개시의 실시예에 의하면, 업데이트 과정은 실시간성이 크리티컬하지 않으므로 암호화 및 복호화로 인한 지연 이 문제되지 않으므로, 업데이트 패키지를 암호화하여 전송할 수 있다. 본 개시의 실시예에 의하면, 외부 공격자가 중간에 패킷을 가로채더라도 암호화된 패키지의 내용을 알 수 없게 하여, 중요한 정보가 외부에 유출되는 것을 방지한다. 본 개시의 실시예에 의하면, MTD(Moving Target Defense)를 적용하여 암호화된 패키지를 캡처하여 다시 전송하 는 소위 재전송 공격(replay attack)을 방지할 수 있다. 본 개시의 효과들은 이상에서 언급한 효과들로 제한되지 않으며, 언급되지 않은 또 다른 효과들은 아래의 기재 로부터 통상의 기술자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2024-0095200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 이 명세서에 따른 차량 보안 방법 및 장치에 대한 실시예를 첨부하는 도면에 의거하여 상세히 설명한다. 각 도면의 구성 요소들에 참조 부호를 부가함에 있어서, 동일한 구성 요소들에 대해서는 비록 다른 도면에 표시 되더라도 가능한 한 동일한 부호를 가지도록 하고 있음에 유의해야 한다. 또한, 이 명세서의 실시예를 설명함 에 있어, 관련된 공지 구성 또는 기능에 대한 구체적인 설명이 발명의 요지를 흐릴 수 있다고 판단되는 경우에 는 그 상세한 설명은 생략한다. 또한, 이 명세서의 실시예의 구성 요소를 설명하는 데 있어서, 제1, 제2, (a), (b) 등의 용어를 사용할 수 있다. 이러한 용어는 그 구성 요소를 다른 구성 요소와 구별하기 위한 것일 뿐, 그 용어에 의해 해당 구성 요 소의 본질이나 차례 또는 순서 등이 한정되지 않는다. 명세서 전체에서, 어떤 부분이 어떤 구성 요소를 '포 함', '구비'한다고 할 때, 이는 특별히 반대되는 기재가 없는 한 다른 구성 요소를 제외하는 것이 아니라 다른 구성 요소를 더 포함할 수 있는 것을 의미한다. 또한, 명세서에 기재된 '쪋부', '모듈' 등의 용어는 적어도 하 나의 기능이나 동작을 처리하는 단위를 의미하며, 이는 하드웨어나 소프트웨어 또는 하드웨어 및 소프트웨어의 결합으로 구현될 수 있다. 첨부된 도면과 함께 이하에 개시될 상세한 설명은 예시적인 실시 형태를 설명하고자 하는 것이며, 유일한 실시 형태를 나타내고자 하는 것이 아니다. 도 1은 본 개시의 일 실시예에 따른 차량이 네트워크를 통해 OTA 서버에 연결되는 것을 개념적으로 도시한 것이다. 본 개시의 일 실시예에 따른 CTR 모드를 이용한 업데이트 패키지(update package) 암호화 장치는, OTA 서버 및 차량을 전부 또는 일부 포함할 수 있다. 도 1에 도시된 구성요소들은 기능적으로 구분되는 요소 들을 나타낸 것으로서, 적어도 하나의 구성요소가 실제 물리적 환경에서는 서로 통합되는 형태로 구현될 수도 있다. AES(Advanced Encryption Standard)는 블록 암호화 알고리즘 중 하나로, 암호화 및 복호화 시 동일한 키(key) 를 사용하는 대칭 키 알고리즘(Symmetric Key Algorithm)이다. AES는 128 bit, 192 bit 및 256 bit의 암호화 키를 가질 수 있다. AES를 적용하는 적용하는 방식에는 ECB모드(Electronic Code Book Mode), CBC모드(Cipher Block Chaining Mode), CFB모드(Cipher FeedBack Mode), OFB모드(Output FeedBack Mode) 및 CTR모드(Counter Mode) 등이 있다. ECB모드는 블록 암호 방식의 운용 방식 중 가장 간단한 방식으로서, 평문(plain text)을 일정한 비트로 나누어 암호화하는 방식이다. 마지막 블록이 일정한 비트가 되지 않을 경우 임의의 약속된 비트 모양을 패딩(padding)한다. ECB모드는 동일한 평문 블록 모양에 대해서 항상 동일한 암호문이 출력되므로 암호의 해독 가능성이 높 은 단점이 있으나, 한번에 암호화하는 평문 길이보다 짧은 평문의 암호화에 유용한 장점이 있다. CBC모드는 출력 암호문이 다음 평문 블록에 영향을 미치게 하여 각 암호문 블록이 앞의 암호문의 영향을 받도록 만든 방식이다. CFB모드는 한 단계 앞의 암호문 블록을 암호 알고리즘의 입력으로서 사용하며 평문 블록을 XOR 논리 연산하여 암호화하는 방식이다. CFB모드는 블록보다 작은 크기의 데이터에서도 동작가능한 장점이 있으나 재전송에 따른 공격 가능성이 있다. OFB모드는 초기화 벡터(Initialization Vector, IV)를 암호화하여 암호화된 IV평문과 XOR하여 암호화하는 방식 이다. 이 OFB모드는 병렬처리가 가능하여 스트림 형식으로 암호화할 수 있으나, 오류가 발생되면 이 오류가 전 체 암호문에 영향을 미치는 단점이 있다. CTR모드는 블록을 암호화할 때 1씩 증가되는 카운터를 암호화해서 키 스트림을 만드는 방식이다. 즉, 카운터를 암호화한 비트열과 평문 블록과의 XOR 논리 연산을 취한 결과가 암호문 블록이 된다. CTR모드는 암호화 및 복호 화의 사전 준비가 가능하고 병렬처리가 가능하나, 1비트가 반전되는 경우 다른 블록에서도 1비트가 반전되는 단 점이 있다. OTA 서버는 차량이나 다른 IoT 기기들의 소프트웨어를 무선 네트워크를 이용하여 업데이트하거나 패 치를 배포하는 장치이다. OTA 서버는 업데이트 패키지를 생성하고, 이를 배포하기 전에 검증한다(verify). OTA 서버는 업데이트 대상 기기의 상태를 모니터링하고, 각 기기의 소프트웨어 버전을 추적한다. OTA 서버 는 업데이트 패키지의 무결성(integrity)을 검증하기 위해 디지털 서명 및 암호화를 사용한다. 차량은 LTE, 5G, Wi-Fi 등의 이동 또는 무선 네트워크를 통해 차량과 관련된 기능이나 서비스를 제공 하는 OTA 서버에 연결될 수 있다. 도 2a는 본 개시의 일 실시예에 따른 차량을 설명하기 위한 블록도이다. 이하에서, 일부 실시예에 따른 차 량의 구성요소들을 설명하는 데 있어, 도 1 및 도 2c가 함께 참조될 수 있다. 차량은 VMG, OTA 마스터 및 타겟 ECU를 전부 또는 일부 포함할 수 있다. VMG는 CCU(Central Control Unit)와 유사하게 차량의 통신을 담당하는 논리적 장치이다. OTA 서버로 부터 소프트웨어 업데이트(혹은 업데이트 패키지)를 받아 차량의 다른 장치에 전송하는 역할을 한다. 외부 공격 자로부터 업데이트 패키지가 캡쳐되지 않도록, 두 장치, 즉 OTA 서버와 VMG 간의 데이터 전송에 TLS(Transport Layer Security)와 같은 E2E 암호화(End-to-End Encryption)를 적용한다. E2E 암호화는 송신자 와 수신자 간의 통신 내용을 암호화하여 중간에 누구도 내용을 볼 수 없게 하는 방식이다. OTA 마스터는 차량 소프트웨어 업데이트, 혹은 업데이트 패키지를 관리하는 중앙 시스템이다. CCU 또는 CGW(Central Gateway)가 OTA 마스터의 역할을 담당할 수 있다. OTA 마스터는 VMG로부터 업데이 트 패키지를 수신한다. OTA 마스터는 업데이트 상태를 모니터링한다. VMG와 OTA 마스터 간의 데 이터 전송은 반드시 암호화되어야 한다. 이는 두 시스템 간의 통신을 도청하거나 조작하려는 외부 공격자로부터 데이터를 보호하기 위함이다. OTA 마스터는 난수생성부(random number generator, 238)를 이용하여 초기 벡터(IV)를 생성한다. OTA 마 스터는 생성된 IV를 타겟 ECU에 전송한다. OTA 마스터는 업데이트 패키지를 모두 전송할 때까지 업데이트 패키지를 기 설정된 비트 길이로 암호화하여 타겟 ECU에 전송한다. 여기서, 기 설정된 비트 길이 는 64비트에 해당한다. 타겟 ECU는 특정 기능을 담당하는 차량 내 전자제어장치(Electronic Control Unit)이다. 자동차에는 복수 개의 ECU가 존재한다. 각 ECU는 엔진 제어, 브레이크 시스템, 인포테인먼트 시스템 등 다양한 기능을 제어한다. OTA 업데이트 과정에서, 타겟 ECU는 소프트웨어 업데이트의 대상이 되는 특정 ECU를 의미한다. 타겟 ECU는 수신한 업데이트 패키지를 복호화한다. 도 2b는 본 개시의 일 실시예에 따른 OTA 마스터와 타겟 ECU가 암호화채널에 의해 연결된 상태 를 도시한 도면이다. OTA 마스터와 타겟 ECU 간의 안전한 데이터 전송을 위해 암호화 채널이 필요하다. 암호화 채널 은 업데이트 패키지가 전송 중에 외부 공격자(external attacker)에 의해 가로채이거나, 변형되는 것을 방지하는 데 중요하다. 따라서 전송 중 데이터가 변경되지 않음을 보장할 수 있고, 전송되는 데이터가 인가되지 않은 사용자에게 노출되지 않도록 할 수 있다. OTA 마스터와 타겟 ECU에는, HSM(Hard Security Module)등의 안전한 저장소와 암호연산이 가능한 소 프트웨어 및 하드웨어가 설치되어 있다. OTA 마스터와 타겟 ECU는 대칭키와 동기화된 카운터 (counter)를 가지고 있다. HSM은 암호화키(대칭키 및 비대칭키)를 생성, 저장, 관리하는 역할을 한다. 키(key) 는 HSM 내부에서 보호되며, 외부에 유출되지 않는다. 도 2c는 본 개시의 일 실시예에 따른 OTA 마스터를 설명하기 위한 블록도이다. OTA 마스터를 설명하 기 위해 도 2d가 참조될 수 있다. 본 개시의 일 실시예에 따른 OTA 마스터는, 제1 저장부, 제1 암호연산부, 제1 통신부 및 난수생성부를 전부 또는 일부 포함할 수 있다. 제1 저장부는 업데이트 패키지, 인증서, IV 등의 데이터를 저장한다. 또한 OTA 업데이트 과정에서 발생하 는 로그를 저장하여, 사고(event)가 발생하는 경우에 추적할 수 있도록 한다. 또한, OTA 업데이트 도중 문제 (trouble)가 발생하는 경우, 제1 저장부는 백업 데이터를 저장한다. 제1 암호연산부는 업데이트 패키지를 암호화하여 제1 통신부에 전송한다. 제1 암호연산부는 대 칭키, 비대칭키 등 암호화에 필요한 키를 생성, 저장 및 관리한다. 제1 암호연산부는 시프트(shift)값을 결정하고, 결정된 시프트값에 따라 암호화 데이터를 시프트하고, 시프트된 암호화 데이터를 평문과 XOR 논리 연 산한다. 제1 통신부는 암호화된 업데이트 패키지를 타겟 ECU에 전송한다. 또한, 제1 통신부는 데이터를 송수신하고, 통신 프로토콜을 관리한다. 난수생성부는 예측 불가능한 랜덤값을 생성한다. 즉 임의의 초기 벡터를 생성한다. 난수생성부는 소 프트웨어 기반의 의사난수 생성기(Pseudo-Random Number Generator, PRNG) 또는 하드웨어 기반의 진난수 생성 기(True Random Number Generator, TRNG)으로 구현될 수 있다. OTA 마스터는 난수생성부를 호출하여 IV를 생성한다. 도 2d는 본 개시의 일 실시예에 따른 타겟 ECU를 설명하기 위한 블록도이다. 타겟 ECU를 설명하기 위 해 도 2c가 참조될 수 있다. 본 개시의 일 실시예에 따른 타겟 ECU는, 제2 저장부, 제2 암호연산부 및 제2 통신부를 전 부 또는 일부 포함할 수 있다. 제2 저장부는 OTA 마스터로부터 수신한 업데이트 패키지를 저장한다. 또한, 운영데이터, 로그, 및 백 업데이터를 저장하고 관리한다. 제2 암호연산부는 OTA 마스터로부터 수신한 암호화된 업데이트 패키지를 복호화한다. 제2 암호연산부 는, 필요한 경우, 데이터를 저장하거나 데이터를 전송하기 위해 데이터를 암호화할 수 있다. 또한, 복호화 수행 시, 시프트 계산을 수행할수 있다. 제2 통신부는 OTA 마스터로부터 업데이트 패키지를 수신한다. 또한, 제2 통신부는, 필요한 경우, OTA 마스터에 상태 정보나 로그 데이터를 전송한다. 또한 제2 통신부는 데이터 전송을 위한 통 신 프로토콜을 관리한다. 도 3은 본 개시의 일 실시예에 따른 암호화모드 중 하나인 CTR 모드를 설명하기 위한 도면이다. 도 3은 카운터 모드(CTR)로 불리는 암호화 알고리즘을 도시한 도면이다. 도 3을 참조하면, 카운터 모드는 비표 (nonce) 및 카운터(counter) 값을 사용할 수 있도록 구성된다. 비표(nonce)는 키 교환 과정에서 통신 장치간 주 고받는 랜덤값을 의미한다. 일반적인 경우 비표(nonce)는 64 비트 또는 96 비트로 설정된다. 카운터는 비표와 함께 128 비트를 맞추기 위해 나머지 부분을 차지한다. 따라서 비표가 96 비트인 경우, 카운터는 32 비트가 된 다. 비표(nonce)는 암호화 블럭 스트림(key stream) 생성 시 동일하게 유지되나, 카운터는 개별 키 스트림(key stream)마다 다른 값을 사용한다. 일반적으로, 카운터는 키 스트림마다 1씩 증가시킨 값을 사용한다. CTR 모드(Counter mode)는 블록을 암호화할 때마다 1씩 증가해가는 카운터를 암호화해서 키 스트림을 만든다."}
{"patent_id": "10-2024-0095200", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "즉, 카운터를 암호화한 비트열과 평문 블록과의 XOR을 취한 결과가 암호문 블록이 된다.CTR 모드의 암호화 과정을 요약하면 다음과 같다. IV와 카운터를 결합하여 블록을 생성한다. 생성된 블록을 암 호화한다. 이때 사용되는 암호화 알고리즘은 AES(Advanced Encryption Standard, AES)와 같은 블록 암호에 해 당한다. 암호화된 블록을 평문 블록과 XOR 연산을 수행한다. 도 4는 본 개시의 일실시예에 따른 OTA 마스터와 타겟 ECU 간의 동작방식을 설명하기 위한 도면이다. 동작방식을 설명하기 위해 도 2c가 참조될 수 있다. 차량 내부 네트워크에 일반적으로 사용되는 프로토콜인 CAN(Controller Area Network)은 8 바이트의 페이로드 (payload)를 가진다. 8 바이트의 페이로드는 CAN (Controller Area Network) 프로토콜의 데이터 프레임에서 전 송할 수 있는 데이터의 최대 크기를 의미한다. 즉, CAN 메시지 하나에 실을 수 있는 데이터가 최대 8 바이트라 는 의미이다. 더 구체적으로 설명하자면, CAN 프로토콜은 차량 내부 네트워크에서 다양한 전자제어장치(ECU) 간의 통신을 위 한 표준을 의미한다. CAN 메시지는 여러 부분으로 구성되는데, 그 중 페이로드 부분은 실제 데이터가 들어가는 부분이다. 이 페이로드는 한 번에 최대 8 바이트의 데이터를 담을 수 있다. 이 제한 때문에 더 큰 데이터를 전 송하려면 여러 개의 CAN 메시지로 나누어 전송해야 한다. 예를 들어, 16 바이트의 데이터를 전송하려면 두 개의 CAN 메시지가 필요하게 된다. 각각의 CAN 메시지는 8 바 이트씩 데이터를 전송하게 된다. 이러한 이유로 AES 암호화 알고리즘을 사용할 때, 한 번에 128 비트(16 바이트)의 데이터를 처리하기 때문에 CAN 프로토콜에서는 데이터가 분할되어 전송되는 문제가 발생한다. 이를 해결하기 위해 CTR 모드와 같은 암호화 모드는 데이터를 나누어 전송할 때 사용할 수 있는 방법 중 하나이다. 본 개시는 CTR모드를 변형하여 이용한다. OTA 마스터는 난수생성부를 이용하여 초기 벡터(IV)를 생성한다(S402). 생성된 IV는 타겟 ECU에 전송된다(S404). IV는 각 암호화 블록에 대해 고유한 값을 제공한다. 타겟 ECU는 수신한 업데이트 패키지를 복호화하기 전에 시프트 연산을 수행한다(S406). 타겟 ECU는 수신한 업데이트 패키지를 복호화하기 위하여, 각 패키지의 시작 위치를 알아야 한다. 타겟 ECU는 이를 위 해, 시프트 연산을 수행하여 데이터의 일관성을 유지하고, 패키지의 순서를 제어한다. 또한, 복호화 시 시프트 계산이 수행될 수도 있다. OTA 마스터는 업데이트 패키지를 8 바이트씩 암호화한다(S408). OTA 마스터는 전체 업데이트 패키지 를 분할하여 8 바이트씩 암호화한다. 업데이트 패키지를 암호화하는 과정에 시프트 결정 및 결정된 시프트값에 따라 시프트 연산이 수행될 수 있다. OTA 마스터는 업데이트 패키지를 타겟 ECU에 전송할 때, 각 패키지의 위치를 정확히 지정하기 위해 시프트 연산을 수행한다. 시프트 연산을 수행하여, OTA 마스터는 업데이트 패키지의 순서와 위치를 타겟 ECU가 정상적으로 수신할 수 있도록 보장한다. OTA 마스터는 업데이트 패키지를 모두 전송할 때까지 업데이트 패키지를 8 바이트씩 암호화하여 타겟 ECU에 전송한다(S410). 타겟 ECU는 수신한 업데이트 패키지를 복호화한다(S412). 타겟 ECU는 수신된 데이터를 IV를 이용하여 각 데이터 부분을 복호화한다. 복호화를 수행하는 동안, 시프트 계산이 수행될 수 있다. 복호화 과정 후에는, 업데이트 패키지가 원래의 형태로 복구되어 시스템에 적용된다. 도 5는 본 개시의 일 실시예에 따른 OTA 마스터에서 시프트 연산이 수행되는 과정을 설명하기 위한 도면이 다. CTR 모드를 이용하여, nonce(이하, 'IV')와 counter를 AES 등의 대칭키 암호 알고리즘을 이용하여 암호화하면 128 비트의 암호문이 생성된다. 생성된 암호문을 평문(업데이트 패키지 조각)과 XOR 연산하여 암호문을 생 성한다. 암호화된 IV와 Counter와 평문은 길이가 서로 다르다. 즉, 암호화된 IV와 Counter(501 이하, '중 간 결과물')의 데이터 길이는 128 비트이고, 평문은 64 비트이다. 즉 평문은 제1 평문이 될 수도 있고, 제 2 평문 또는 제3 평문가 될 수도 있다. 따라서, 중간 결과물의 몇번째 비트부터 XOR 연산을 수행하는 가에 따라 암호문이 달라진다. 또한, MTD(Moving Target Defense)의 개념을 이용하여 매번 계산되는 위치를 변경하면 재전송 공격(replay attack)을 차단할 수 있다. 도 6은 본 개시의 일 실시예에 따른 평문이 암호화되는 과정을 설명하는 순서도이다. 도 6의 과정을 설명함에 있어, 도 2c, 도 2d 및 도4 가 참조될 수 있다. HMAC(hash-based message authentication code)는 암호화 해시함수와 기밀 암호화 키를 수반하는 특정 유형의 메시지 인증 코드(MAC)이다. 제1 암호연산부는 임의의 초기 벡터(IV)와 키(Key)를 이용하여 HMAC의 값 H를 생성한다(S602). 제1 암호연산부는 HMAC 값의 하위 8비트, 즉 H값의 하위 8 bit를 추출한 후, 64로 나눈 나머지 값을 계산 하여 시프트값을 결정한다(S604). 제1 암호연산부는 시프트값을 결정하고, Em을 결정된 시프트값만큼 왼쪽으로 시프트하고, 다시 64비트 오 른쪽으로 시프트하여 하위 64비트를 추출한다(S606). 여기서 Em은, 암호화 데이터를 의미하며, 초기 벡터(IV)와 카운터값을 합친 결과를 키(key)와 함께 블록 암호 알고리즘을 이용하여 생성된 결과값이다. 따라서 새로운 비 트 길이의 New_Em 값이 생성된다. 마찬가지로, 제2 암호연산부도 초기 벡터를 OTA 마스터로부터 수신한 다음 또는 복호화 시, 제1 암호 연산부가 수행한 시프트 계산(S602, S604, S606)이 수반될 수 있다. 제1 암호연산부는 New_Em과 평문을 XOR 연산하여 최종암호문을 생성한다(S608). 생성된 최종암호문은 64비 트가 된다. 즉 시프트 계산을 이용하여, 인덱스(index) 위치를 매번 다르게 하여, 복수의 암호문을 생성한 결과 외부 해커들로부터 재전송 공격을 막을 수 있다. 도 7은 본 개시에 따른 방법 또는 장치를 구현하기 위해 사용될 수 있는 예시적인 컴퓨팅 장치를 개략적으로 나 타낸 블록구성도이다. 컴퓨팅 장치는 메모리, 프로세서, 스토리지, 입출력 인터페이스 및 통신 인터페이스 중 일부 또는 전부를 포함할 수 있다. 컴퓨팅 장치는 데스크탑 컴퓨터, 서버 등과 같은 고정형 (stationary) 컴퓨팅 장치뿐만 아니라, 랩탑 컴퓨터, 스마트 폰 등과 같은 휴대용(mobile) 컴퓨팅 장치일 수도 있다. 컴퓨팅 장치는 인공지능 모델에 대한 연산들을 효율적인 방식으로 처리하는 것이 가능한 임의의 특수 화된 하드웨어 가속기(accelerator)를 포함할 수도 있다. 예컨대, 컴퓨팅 장치는 그래픽 처리 장치 (Graphics Processing Unit, GPU), 텐서 처리 장치(Tensor Processing Unit, TPU) 또는 신경망 처리 장치 (Neural Processing Unit, NPU)를 포함할 수 있다. 메모리는 프로세서로 하여금 본 개시의 다양한 실시예에 따른 방법 또는 동작을 수행하도록 하는 프 로그램을 저장할 수 있다. 예를 들면, 프로그램은 프로세서에 의해서 실행 가능한(executable) 복수의 명 령어들을 포함할 수 있고, 복수의 명령어들이 프로세서에 의해서 실행됨으로써 전술한 방법 또는 동작들이 수행될 수 있다. 메모리는 단일 메모리 또는 복수의 메모리들일 수 있다. 이 경우, 본 개시의 다양한 실시 예에 따른 방법 또는 동작을 수행하기 위해 필요한 정보는 단일 메모리에 저장되거나 복수의 메모리들에 나뉘어 저장될 수 있다. 메모리가 복수의 메모리들로 구성된 경우, 복수의 메모리들은 물리적으로 분리될 수 있다. 메모리는 휘발성 메모리 및 비휘발성 메모리 중 적어도 하나를 포함할 수 있다. 휘발성 메모리는 SRAM(Static Random Access Memory) 또는 DRAM(Dynamic Random Access Memory) 등을 포함하고, 비휘발성 메모 리는 플래시 메모리(flash memory) 등을 포함한다. 프로세서는 적어도 하나의 명령어들을 실행할 수 있는 적어도 하나의 코어를 포함할 수 있다. 프로세서 는 메모리에 저장된 명령어들을 실행할 수 있다. 프로세서는 단일 프로세서 또는 복수의 프로세 서들일 수 있다. 스토리지는 컴퓨팅 장치에 공급되는 전력이 차단되더라도 저장된 데이터를 유지한다. 예를 들면, 스토 리지는 비휘발성 메모리를 포함할 수도 있고, 자기 테이프, 광학 디스크, 자기 디스크와 같은 저장 매체를 포함할 수도 있다. 스토리지에 저장된 프로그램은 프로세서에 의해서 실행되기 이전에 메모리로 로딩될 수 있다. 스토리지는 프로그램 언어로 작성된 파일을 저장할 수 있고, 파일로부터 컴파일러 등에 의해서 생성된 프로그램은 메모리로 로딩될 수 있다. 스토리지는 프로세서에 의해서 처리될 데 이터 및/또는 프로세서에 의해서 처리된 데이터를 저장할 수 있다. 입출력 인터페이스는 키보드, 마우스 등과 같은 입력 장치 및/또는 디스플레이 장치, 프린터 등과 같은 출 력 장치와의 인터페이스를 제공할 수 있다. 사용자는 입력 장치를 통해 프로세서에 의한 프로그램의 실행을 트리거하고/거나 출력 장치를 통해 프로세서의 처리 결과를 확인할 수 있다. 통신 인터페이스는 외부 네트워크에 대한 액세스를 제공할 수 있다. 컴퓨팅 장치는 통신 인터페이스 를 통해 다른 장치들과 통신할 수 있다. 이 명세서에 설명되는 시스템들 및 기법들의 다양한 구현예들은, 디지털 전자 회로, 집적 회로, FPGA(field programmable gate array), ASIC(application specific integrated circuit), 컴퓨터 하드웨어, 펌웨어, 소프 트웨어, 및/또는 이들의 조합으로 실현될 수 있다. 이러한 다양한 구현예들은 프로그래밍가능 시스템상에서 실 행 가능한 하나 이상의 컴퓨터 프로그램들로 구현되는 것을 포함할 수 있다. 프로그래밍가능 시스템은, 저장 시 스템, 적어도 하나의 입력 디바이스, 그리고 적어도 하나의 출력 디바이스로부터 데이터 및 명령들을 수신하고 이들에게 데이터 및 명령들을 전송하도록 결합되는 적어도 하나의 프로그래밍가능 프로세서(이것은 특수 목적 프로세서일 수 있거나 혹은 범용 프로세서일 수 있음)를 포함한다. 컴퓨터 프로그램들(이것은 또한 프로그램들, 소프트웨어, 소프트웨어 애플리케이션들 혹은 코드로서 알려져 있음)은 프로그래밍가능 프로세서에 대한 명령어 들을 포함하며 \"컴퓨터가 읽을 수 있는 기록 매체\"에 저장된다. 컴퓨터가 읽을 수 있는 기록 매체는, 컴퓨터 시스템에 의하여 읽혀질 수 있는 데이터가 저장되는 모든 종류의 기록장치를 포함한다. 이러한 컴퓨터가 읽을 수 있는 기록 매체는 ROM, CD-ROM, 자기 테이프, 플로피디스크, 메 모리 카드, 하드 디스크, 광자기 디스크, 스토리지 디바이스 등의 비휘발성(non-volatile) 또는 비 일시적인 (non-transitory) 매체 또는 데이터 전송 매체(data transmission medium)와 같은 일시적인(transitory) 매체 를 더 포함할 수도 있다. 또한, 컴퓨터가 읽을 수 있는 기록 매체는 네트워크로 연결된 컴퓨터 시스템에 분산되 어, 분산방식으로 컴퓨터가 읽을 수 있는 코드가 저장되고 실행될 수도 있다. 이 명세서에 설명되는 시스템들 및 기법들의 다양한 구현예들은, 프로그램가능 컴퓨터에 의하여 구현될 수 있다. 여기서, 컴퓨터는 프로그램가능 프로세서, 데이터 저장 시스템(휘발성 메모리, 비휘발성 메모리, 또는 다 른 종류의 저장 시스템이거나 이들의 조합을 포함함) 및 적어도 한 개의 커뮤니케이션 인터페이스를 포함한다. 예컨대, 프로그램가능 컴퓨터는 서버, 네트워크 기기, 셋탑 박스, 내장형 장치, 컴퓨터 확장 모듈, 개인용 컴퓨 터, 랩탑, PDA(Personal Data Assistant), 클라우드 컴퓨팅 시스템 또는 모바일 장치 중 하나일 수 있다. 이 명세서는 기재된 실시예들에 한정되는 것이 아니고, 본 발명의 사상 및 범위를 벗어나지 않고 다양하게 수정 및 변형할 수 있음은 이 기술의 분야에서 통상의 지식을 가진 자에게 자명하다. 따라서, 그러한 수정예 또는 변형예들은 본 발명의 특허청구범위에 속한다 하여야 할 것이다."}
{"patent_id": "10-2024-0095200", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 개시의 일 실시예에 따른 차량이 네트워크를 통해 OTA 서버에 연결되는 것을 개념적으로 도시한 것이다. 도 2a는 본 개시의 일 실시예에 따른 차량을 설명하기 위한 블록도이다. 도 2b는 본 개시의 일 실시예에 따른 OTA 마스터와 타겟 ECU가 암호화채널에 의해 연결된 상태를 도시한 도면이 다. 도 2c는 본 개시의 일 실시예에 따른 OTA 마스터를 설명하기 위한 블록도이다. 도 2d는 본 개시의 일 실시예에 따른 타겟 ECU를 설명하기 위한 블록도이다. 도 3은 본 개시의 일 실시예에 따른 암호화모드 중 하나인 CTR 모드를 설명하기 위한 도면이다. 도 4는 본 개시의 일 실시예에 따른 OTA 마스터와 타겟 ECU 간의 동작방식을 설명하기 위한 도면이다. 도 5는 본 개시의 일 실시예에 따른 OTA 마스터에서 시프트(shift) 연산이 수행되는 과정을 설명하기 위한 도면 이다. 도 6은 본 개시의 일 실시예에 따른 평문이 암호화되는 과정을 설명하는 순서도이다. 도 7은 본 개시에 따른 방법 또는 장치를 구현하기 위해 사용될 수 있는 예시적인 컴퓨팅 장치를 개략적으로 나 타낸 블록구성도이다."}
