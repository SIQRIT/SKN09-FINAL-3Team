{"patent_id": "10-2023-0169862", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0080173", "출원번호": "10-2023-0169862", "발명의 명칭": "프로세스 인 메모리의 활용을 위한 코드 최적화 방법 및 그를 위한 장치", "출원인": "연세대학교 산학협력단", "발명자": "벅스텔러 번트"}}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "코드 최적화 장치에서, 프로세스 인 메모리의 활용을 위하여 코드를 최적화하는 방법에 있어서,성능 모니터링 유닛(PMU)에서 측정된 이벤트에 대한 소스 코드를 대상 IR(Intermediates Representation)로 변환하는 단계;상기 대상 IR에서 기 설정된 영역 처리 단위(granularity)로 코드 영역을 식별하고, PIM 프로파일링 라이브러리기반으로 상기 대상 IR을 계측하는 단계;상기 계측된 대상 IR을 상기 PIM 프로파일링 라이브러리와 연결하여 실행 가능 바이너리(binary)를 생성하는 단계;상기 실행 가능 바이너리를 실행하여 프로파일링 데이터(profiling data)를 생성하는 단계; 상기 프로파일링 데이터를 포함하는 프로파일링 통계 및 상기 대상 IR을 기반으로 코드 영역을 분류하는 단계;및분류 결과에 따라 코드 영역을 프로세싱 인 메모리 또는 메인 프로세서로 전달하는 단계를 포함하는 것을 특징으로 하는 코드 최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 대상 IR 변환 단계는,성능 모니터링 유닛(PMU)로부터 측정된 하드웨어 기반 이벤트에 대한 상기 대상 IR을 변환하는 것을 특징으로하는 코드 최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 이벤트에 대한 소스 코드는, 파이썬(Python), R, 자바(Java) 및 C/C++ 등과 같은 고레벨 프로그래밍 언어(high-level programming language) 기반의 코드 또는 TensorFlow, PyTorch, Keras 및 Scikit-learn 등과 같은라이브러리 및 프레임워크 기반의 코드인 것을 특징으로 하는 코드 최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 대상 IR 계측 단계는,상기 대상 IR에서 영역 처리 단위(granularity)를 기반으로 코드 영역을 식별하는 단계;상기 PIM 프로파일링 라이브러리에 기 저장된 PIM 프로파일링 API를 삽입하여 상기 대상 IR을 계측하는 단계를 포함하는 것을 특징으로 하는 코드 최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 코드 영역을 식별하는 단계는,함수 레벨의 영역 처리 단위(granularity)로 상기 대상 IR을 확인하고, 상기 대상 IR에서 확인된 함수가 빌트인함수가 아닌 경우, 해당 함수의 코드 영역 시작과 끝에 프로파일러 런타임 라이브러리에 대한 제1 호출 함수를공개특허 10-2024-0080173-3-삽입하는 것을 특징으로 하는 코드 최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 코드 영역을 식별하는 단계는,기본 블록의 영역 처리 단위(granularity)로 상기 해당 함수를 확인하고, 상기 확인된 기본 블록이 오프로드 가능한 코드 영역으로 시작하지 않는 경우, 상기 기본 블록의 코드 영역 시작과 끝에 프로파일러 런타임 라이브러리에 대한 제2 호출 함수를 삽입하는 것을 특징으로 하는 코드 최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제4항에 있어서,상기 프로파일링 데이터 생성 단계는,상기 코드 영역의 시작과 끝에서 상기 이벤트에 대한 카운터를 리드(read)하는 단계;상기 코드 영역의 시작과 끝에서 리드된 카운터를 비교하는 단계; 및상기 비교 결과에 대한 차이를 상기 프로파일링 데이터로 저장하는 단계를 포함하는 것을 특징으로 하는 코드 최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 코드 영역을 분류하는 단계는,상기 프로파일링 통계에 포함된 과거 카운팅 결과를 기반으로 코드 영역을 분류하는 것을 특징으로 하는 코드최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 코드 영역을 분류하는 단계는,상기 코드 영역을 데이터 중심 부분(data-intensive parts) 및 계산 중심 부분(compute-intensive parts) 중하나로 분류하는 것을 특징으로 하는 코드 최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 전달 단계는,분류된 코드 영역이 데이터 중심(data-intensive)으로 분류된 경우, 메모리 바운드 기반의 코드 영역에 대응하는 프로세싱 인 메모리에 오프로드되도록 하는 것을 특징으로 하는 코드 최적화 방법."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "코드 최적화 장치에 있어서, 상기 코드 최적화 장치는, 코드 최적화 처리를 위한 하나 이상의 프로그램을 저장하는 메모리; 및 상기 하나 이상의 프로그램에 따라 상기 코드 최적화 처리를 위한 동작들을 수행하는 하나 이상의 프로세서를 포함하고, 상기 프로세서에 의하여 수행되는 동작들은, 성능 모니터링 유닛(PMU)에서 측정된 이벤트에 대한 소스 코드를 대상 IR(Intermediates Representation)로 변환하는 단계;상기 대상 IR에서 기 설정된 영역 처리 단위(granularity)로 코드 영역을 식별하고, PIM 프로파일링 라이브러리공개특허 10-2024-0080173-4-기반으로 상기 대상 IR을 계측하는 단계;상기 계측된 대상 IR을 상기 PIM 프로파일링 라이브러리와 연결하여 실행 가능 바이너리(binary)를 생성하는 단계;상기 실행 가능 바이너리를 실행하여 프로파일링 데이터(profiling data)를 생성하는 단계; 상기 프로파일링 데이터를 포함하는 프로파일링 통계 및 상기 대상 IR을 기반으로 코드 영역을 분류하는 단계;및분류 결과에 따라 코드 영역을 프로세싱 인 메모리 또는 메인 프로세서로 전달하는 단계를 포함하는 것을 특징으로 하는 코드 최적화 장치."}
{"patent_id": "10-2023-0169862", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "컴퓨터에 제1항 내지 제10항 중 어느 한 항에 따른 코드 최적화 방법을 실행시키기 위하여 기록매체에 저장된컴퓨터프로그램."}
{"patent_id": "10-2023-0169862", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "프로세스 인 메모리의 활용을 위한 코드 최적화 방법 및 그를 위한 장치를 개시한다. 본 발명의 실시예에 따른 코드 최적화 장치에서, 프로세스 인 메모리의 활용을 위하여 코드를 최적화하는 방법에 있어서, 코드 최적화 방법은, 성능 모니터링 유닛(PMU)에서 측정된 이벤트에 대한 소스 코드를 대상 (뒷면에 계속)"}
{"patent_id": "10-2023-0169862", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 프로세스 인 메모리의 활용을 위한 코드 최적화 방법 및 그를 위한 장치에 관한 것이다."}
{"patent_id": "10-2023-0169862", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "이 부분에 기술된 내용은 단순히 본 발명의 실시예에 대한 배경 정보를 제공할 뿐 종래기술을 구성하는 것은 아 니다. 프로세스 인 메모리(PIM: Processing-in-Memory)는 프로세싱 장치(CPU)와 메모리의 통합을 의미한다. 프로세스 인 메모리를 사용하면 메모리와 CPU 간에 전송되는 데이터 양이 크게 줄어들어 성능과 에너지 효율성을 모두 향 상시킬 수 있다. 이는 데이터 집약적 워크로드가 있는 AI 및 빅 데이터와 같은 신흥 분야에 도움이 될 수 있다. 그러나, 프로세스 인 메모리의 리소스를 효과적으로 활용하려면 애플리케이션 코드 내에서 정보에 근거한 결정 이 필요하다. 프로세스 인 메모리의 상대적으로 낮은 컴퓨팅 성능과 높은 메모리 대역폭으로 인해 메모리 바운 드 계산만 프로세스 인 메모리에서 효율적으로 작동한다. 컴퓨팅 바운드 계산은 범용 CPU(메인 프로세서)에 남 아 있어야 한다. 따라서, 프로그래머는 메모리 제한 측면에서 코드의 특성을 구별해야 한다. 프로파일 기반 최적화(PGO)는 런타임에서 수집된 함수 호출 횟수에 관한 통계를 이용한 컴파일러 최적화 기법이 다. 프로파일 기반 최적화(PGO)로 프로그램을 최적화하기 위해서는 먼저 계측되어야 하는 프로그램이 데이터 수 집을 위해 최소 한번은 실행되어야 하며, 그 후 수집된 데이터를 프로그램 최적화에 사용하게 된다. 프로파일 기반 최적화(PGO)는 함수 호출 횟수에만 초점을 맞췄기 때문에 핫스팟 분석과 같이 더 넓은 범위의 최 적화에는 활용이 제한적이었다. 따라서, 프로파일 기반 최적화(PGO)는 코드의 일반적인 특성을 분류하는 데 사 용될 수 없다."}
{"patent_id": "10-2023-0169862", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 프로세스 인 메모리의 활용을 위하여 성능 모니터링 유닛(PMU)에서 측정되는 하드웨어 기반 이벤트를 프로파일 기반 최적화(PGO)를 사용하여 어플리케이션 코드의 특성을 분류하는 프로세스 인 메모리의 활용을 위 한 코드 최적화 방법 및 그를 위한 장치를 제공하는 데 주된 목적이 있다."}
{"patent_id": "10-2023-0169862", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 일 측면에 의하면, 상기 목적을 달성하기 위한 코드 최적화 장치에서, 프로세스 인 메모리의 활용을 위하여 코드를 최적화하는 방법에 있어서, 코드 최적화 방법은, 성능 모니터링 유닛(PMU)에서 측정된 이벤트에 대한 소스 코드를 대상 IR(Intermediates Representation)로 변환하는 단계; 상기 대상 IR에서 기 설정된 영역처리 단위(granularity)로 코드 영역을 식별하고, PIM 프로파일링 라이브러리 기반으로 상기 대상 IR을 계측하 는 단계; 상기 계측된 대상 IR을 상기 PIM 프로파일링 라이브러리와 연결하여 실행 가능 바이너리(binary)를 생 성하는 단계; 상기 실행 가능 바이너리를 실행하여 프로파일링 데이터(profiling data)를 생성하는 단계; 상기 프로파일링 데이터를 포함하는 프로파일링 통계 및 상기 대상 IR을 기반으로 코드 영역을 분류하는 단계; 및 분 류 결과에 따라 코드 영역을 프로세싱 인 메모리 또는 메인 프로세서로 전달하는 단계를 포함할 수 있다. 또한, 본 발명의 다른 측면에 의하면, 상기 목적을 달성하기 위한 코드 최적화 장치에 있어서, 상기 코드 최적 화 장치는, 코드 최적화 처리를 위한 하나 이상의 프로그램을 저장하는 메모리; 및 상기 하나 이상의 프로그램 에 따라 상기 코드 최적화 처리를 위한 동작들을 수행하는 하나 이상의 프로세서를 포함하고, 상기 프로세서에 의하여 수행되는 동작들은, 성능 모니터링 유닛(PMU)에서 측정된 이벤트에 대한 소스 코드를 대상 IR(Intermediates Representation)로 변환하는 단계; 상기 대상 IR에서 기 설정된 영역 처리 단위 (granularity)로 코드 영역을 식별하고, PIM 프로파일링 라이브러리 기반으로 상기 대상 IR을 계측하는 단계; 상기 계측된 대상 IR을 상기 PIM 프로파일링 라이브러리와 연결하여 실행 가능 바이너리(binary)를 생성하는 단 계; 상기 실행 가능 바이너리를 실행하여 프로파일링 데이터(profiling data)를 생성하는 단계; 상기 프로파일 링 데이터를 포함하는 프로파일링 통계 및 상기 대상 IR을 기반으로 코드 영역을 분류하는 단계; 및 분류 결과 에 따라 코드 영역을 프로세싱 인 메모리 또는 메인 프로세서로 전달하는 단계를 포함할 수 있다."}
{"patent_id": "10-2023-0169862", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "이상에서 설명한 바와 같이, 일반적으로 프로그래머가 직접 기존의 프로그램을 새로운 장치를 위해 최적화시키 는 과정은 큰 노력이 필요하며, TensorFlow와 같은 대규모 프레임워크에서는 불가능에 가까웠으나, 본 발명에 따른 메커니즘은 프로그래머의 관여가 필요 없는 자동화된 과정이며 대규모 코드 베이스에도 사용이 가능하다는 효과가 있다. 또한, 본 발명은 코드 영역의 자동 오프로드 과정을 통한 PIM 기반 시스템에서의 성능 향상이 가능하기 때문에 시장에서 PIM 하드웨어의 도입을 가속화할 수 있는 효과가 있다."}
{"patent_id": "10-2023-0169862", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 본 발명의 바람직한 실시예를 첨부된 도면들을 참조하여 상세히 설명한다. 본 발명을 설명함에 있어, 관 련된 공지 구성 또는 기능에 대한 구체적인 설명이 본 발명의 요지를 흐릴 수 있다고 판단되는 경우에는 그 상 세한 설명은 생략한다. 또한, 이하에서 본 발명의 바람직한 실시예를 설명할 것이나, 본 발명의 기술적 사상은 이에 한정하거나 제한되지 않고 당업자에 의해 변형되어 다양하게 실시될 수 있음은 물론이다. 이하에서는 도면 들을 참조하여 본 발명에서 제안하는 프로세스 인 메모리의 활용을 위한 코드 최적화 방법 및 그를 위한 장치에 대해 자세하게 설명하기로 한다. 도 1은 본 발명의 실시예에 따른 코드 최적화 장치를 개략적으로 나타낸 블록 구성도이다. 본 실시예에 따른 코드 최적화 장치는 성능 모니터링 유닛, 코드 최적화 유닛, 프로세싱 인 메모 리 및 메인 프로세서를 포함한다. 도 1의 코드 최적화 장치는 일 실시예에 따른 것으로서, 도 1에 도시된 모든 블록이 필수 구성요소는 아니며, 다른 실시예에서 코드 최적화 장치에 포함된 일부 블록이 추 가, 변경 또는 삭제될 수 있다. 코드 최적화 장치는 성능 모니터링 유닛(PMU: Performance Monitoring Unit, 10)에서 측정되는 하드웨어 기반 이벤트를 프로파일 기반 최적화(PGO)에 사용하여 어플리케이션 코드의 특성을 프로세스 인 메모리(PIM: Processing-in-Memory)을 위해 분류하는 동작을 수행한다. 코드 최적화 장치는 성능 모니터링 유닛으로부터 값을 읽고 기록하는 기법을 포함한다. 하드웨어 기반 이벤트를 활용한 프로파일러 기반 최적화(PGO: Profiler-Guided Optimization)를 이용하기 위해서는 서로 다른 하드웨어 상에서 어떤 이벤트를 수집할지 특정하는 것이 필요하다. 이를 위해 어플리케이션 코드는 코드 영역 단위로 나눠진다. 각각의 코드 영역은 명령(instruction), 기본 블록(basic block)，함수(function)，또는 루 프(loop) 단위로 구성될 수 있다. 코드 최적화 장치는 Control Flow Graph(CFG) 구조를 가지는 LLVM IR 모듈일 수 있다. Control Flow Graph(CFG) 구조는 명령(instruction)으로 구성되어 있고, CFG에서 분기가 일어나기 전까지의 명령 (instruction)들을 묶은 것이 기본 블록이다. 코드 영역의 단위는 모듈(Module) > 함수(function) > 기본 블록 (basic block) > 명령(instruction) 크기로 정의될 수 있다. 각 코드 영역의 시작과 끝에는 프로파일러 기반 최적화 처리를 위한 특수한 코드(기 설정된 특수 코드)가 추가 된다. 코드 영역이 실행될 때마다 성능 모니터링 유닛에서 이벤트 값을 읽고 이를 기록하게 된다. 이벤트 기록을 위한 메모리는 제안된 발명의 일부인 컴파일러 계측(instrumentation)에 의해 관리된다. 코드 영역이 실행될 때마다 특정 크기의 버퍼를 미리 할당하며，기록된 값은 코드 영역 분류를 위해 저장장치로 옮겨 지게 된다. 본 발명은 해당 값을 이용해 자동적으로 프로세싱 인 메모리에 오프로드할 코드 영역을 판별한다. 이는 프 로그램 IR 단위에서 동작하기 때문에 프로그래머가 직접 코드 분류를 하기 힘든 고레벨 프로그래밍 언어도 프로 세싱 인 메모리에서 활용할 수 있게 된다. 본 발명에 따른 코드 최적화 장치는 세분화된 코드 계측, 프로파일링 및 코드 영역 분류 프로세스 등으로 동작하며, 이는 호스트(예: CPU 등)에서 수행될 수 있으나 반드시 이에 한정되는 것은 아니다. 본 발명은 모든 데이터 집약적인 작업 부하를 프로세싱 인 메모리 기판으로 오프로드하는 것이다. 본 실시예에 따른 코드 최적화 장치는 성능이 최대화될 수 있는 방식으로 애플리케이션 코드를 분할하고 이를 PIM 하드웨어로 오프로드하는 자동화된 방법을 제공하는 것을 목적으로 한다. 본 발명은 PGO를 통한 단순한 호출 횟수보다는 하드웨어별 PMU 이벤트 수집을 제안한다. 이를 달성하기 위해 본 발명은 호출 횟수 대신 다양한 데이터를 수집하는 일반화된 함수를 삽입한다. 이 접근 방식은 스레드로부터 안 전하다. 즉, 순차 및 다중 스레드 프로그램에서 작동합니다. 초기화 프로세스 후에 프로파일러 런타임은 버퍼에 서 프로파일러 통계를 수집한다. 버퍼가 가득 차면, 프로그램은 포함된 통계 정보를 파일에 저장한다. 프로그램이 종료되면 최적화 프로그램은 프로파일러 통계를 수집하고 수집된 프로파일러 통계에서 메모리 바인딩된 휴리스틱을 계산한다. 계산된 휴리스 틱을 기반으로 최적화는 자동으로 프로그램의 메모리 바운드 영역을 분류하고 PIM에 오프로드하여 PIM을 자동으 로 활용한다. 코드 최적화를 위한 PGO(프로파일러 기반 최적화)는 프로파일러 통계를 기반으로 프로그램을 최적화한다. PGO는 세 단계로 구성된다. 첫째, 프로그램을 프로파일링하는 특정 함수나 루틴을 호출하도록 프로그램이 계측된다. 프로파일링 중에 PGO는 프로그램의 특정 지역의 호출 횟수를 기록한다. 둘째, 프로그래머는 실제 런타임에서 사용될 것으로 예상되는 입력 데이터를 가지고 프로그램을 실행한다. 이 단계에서는 프로그램이 실행될 때 계측된 코드가 실행된다. 셋째, PGO는 PGO의 두 번째 단계에서 수집된 데이터를 활용하여 컴파일러의 최적화가 결정되도록 한다. 따라서 컴파일러는 프로파일링 중에 사용된 입력 데이터에 대해 프로그램을 전문화한다. 코드 최적화 장치는 LLVM 기반으로 동작할 수 있다. LLVM 컴파일러는 프론트 엔드, 미들 엔드, 백 엔드의 세 단계로 작동한다. 프런트 엔드에서 소스 코드는 IR(Intermediates Representation)으로 변환된다. 변환된 IR을 사용하면 컴파일러는 미들 엔드에서 IR을 최적 화한다. 마지막 단계로 백엔드는 IR에서 실제 대상 언어를 생성하여 전달한다. 일반적인 LLVM 컴파일러는 광범위하고 점점 더 다양한 프로그래밍 언어를 지원하는 업계 최고의 컴파일러 프레 임워크이다. LLVM에서 컴파일하려면 먼저 모든 프로그램(소스 코드)을 LLVM IR로 낮추어야 합니다. IR 수준에서 LLVM은 코드 계측을 지원한다. 계측은 프로그램 런타임 시 성능 데이터를 수집할 목적으로 애플리케이션의 IR에 추가 코드를 주입하는 프로세스이다. 성능 모니터링 유닛은 하드웨어 기반의 이벤트를 모니터링하는 동작을 수행한다. 코드 최적화 유닛은 성능 모니터링 유닛에서 측정된 이벤트에 대한 소스 코드를 대상 IR로 변환한다. 코드 최적화 유닛은 대상 IR에서 기 설정된 영역 처리 단위(granularity)로 코드 영역을 식별하고, PIM 프 로파일링 라이브러리 기반으로 대상 IR을 계측한다. 코드 최적화 유닛은 계측된 대상 IR을 PIM 프로파일링 라이브러리와 연결하여 실행 가능 바이너리(binary) 를 생성하고, 실행 가능 바이너리를 실행하여 프로파일링 데이터(profiling data)를 생성한다. 코드 최적화 유닛은 프로파일링 데이터를 포함하는 프로파일링 통계 및 대상 IR을 기반으로 코드 영역을 분 류하고, 분류 결과에 따라 코드 영역을 프로세싱 인 메모리 또는 메인 프로세서로 전달한다. 코드 최적화 유닛에 대한 자세한 설명은 도 3 내지 도 7에 기재하도록 한다. 프로세싱 인 메모리는 처리 장치(예: CPU)를 메모리와 통합한 메모리를 의미한다. 프로세싱 인 메모리를 사용하면 메모리와 CPU 간에 전송되는 데이터의 양이 크게 줄어들어 성능과 에너지 효율성을 모두 향상시킬 수 있다. 이는 데이터 집약적인 워크로드가 있는 AI 및 빅 데이터와 같은 신흥 분야에 도움이 될 수 있다. 프로세싱 인 메모리의 리소스를 효과적으로 활용하려면 애플리케이션 코드 내에서 정보에 근거한 결정이 필 요하다. 프로세싱 인 메모리의 상대적으로 낮은 컴퓨팅 성능과 높은 메모리 대역폭으로 인해 프로세싱 인 메모리에서는 메모리 바인딩된 계산만 효율적으로 동작한다. 즉, 컴퓨팅 바인딩된 계산은 메인 프로세서에 남아 있어야 한다. 여기서, 메인 프로세서는 CPU, GPU 등 일 수 있다. 도 2는 본 발명의 실시예에 따른 코드 최적화 장치의 하드웨어 구조를 개략적으로 나타낸 블록 구성도이다. 도 2는 본 발명의 바람직한 실시예들에서 사용되기에 적합한 컴퓨팅 기기를 포함하는 코드 최적화를 위한 시스 템의 컴퓨팅 환경을 예시하여 설명하기 위한 코드 최적화 장치의 하드웨어 구성을 나타낸 블록도이다. 코드 최적화 장치는 컴퓨팅 디바이스로 구현될 수 있으며, 스마트폰(Smart Phone), 개인용 컴퓨터 (Personal Computer, PC), 태블릿 PC(Tablet PC), 휴대용 개인정보 단말기(Personal Digital Assistant, PDA), 랩톱(Laptop) 등이 있을 수 있으나 이에 한정되는 것은 아니다. 코드 최적화 장치는 프로세서 및 프로세서에 의해 실행되는 프로그램을 저장하는 메모리를 포함할 수 있으 며, 프로세서에서 코드 최적화 처리를 위한 명령어들을 생성하고, 생성된 명령어들을 이용하여 코드 최적화 처 리를 위한 정보를 제공할 수 있다. 코드 최적화 장치는 데이터베이스를 포함할 수 있다. 데이터베이스는 데이터의 검색, 추출, 삭제, 편집, 추가 등을 자유롭게 행할 수 있는 데이터의 저장형태를 의미한다. 데이터베이스는 오라클(Oracle), 인포믹스 (Infomix), 사이베이스(Sybase), 관계형 데이터베이스 관리시스템(Relational Data Base Management System, RDBMS), 겜스톤(Gemston), 오리온(Orion), 객체 지향형 데이타베이스 관리 시스템(Object Oriented Database Management System, OODBMS) 분산 데이터베이스, 클라우드 등을 이용하여 본 실시예의 목적에 맞게 구현될 수 있다. 도 2에 도시된 실시예에서, 각 컴포넌트들은 이하에 기술된 것 이외에 상이한 기능 및 능력을 가질 수 있고, 이 하에 기술되지 것 이외에도 추가적인 컴포넌트를 포함할 수 있다. 도시된 컴퓨팅 환경은 코드 최적화 장치을 포함한다. 일 실시예에서 코드 최적화 장치는 타 단말기와 신호를 송수신하는 모든 형태의 컴퓨팅 기기일 수 있다. 코드 최적화 장치는 적어도 하나의 프로세서, 컴퓨터 판독 가능한 저장 모듈 및 통신 버스를 포 함한다. 프로세서는 코드 최적화 장치로 하여금 앞서 언급된 예시적인 실시예에 따라 동작하도록 할 수 있다. 예컨대, 프로세서는 컴퓨터 판독 가능한 저장 모듈에 저장된 하나 이상의 프로그램들을 실 행할 수 있다. 상기 하나 이상의 프로그램들은 하나 이상의 컴퓨터 실행 가능 명령어를 포함할 수 있으며, 상기 컴퓨터 실행 가능 명령어는 프로세서에 의해 실행되는 경우 코드 최적화 장치로 하여금 예시적인 실 시예에 따른 동작들을 수행하도록 구성될 수 있다. 프로세서는 신경망 모듈과 연동하여 코드 최적화 동작을 처리할 수도 있다. 한편, 프로세서 및 신경망 모듈는 서로 다른 모듈인 것으로 기재하고 있으나 반드시 이에 한정되는 것은 아니며, 하나의 모듈 로 결합되어 각각의 동작이 수행되도록 구현될 수도 있다. 신경망 모듈은 인공지능(AI: Artificial Intelligence)를 기반으로 코드 최적화 처리와 관련된 신경망 처 리를 수행한다. 신경망 모듈은 입력 노드와, 중간 노드 및 출력 노드를 가지며, 각 노드를 연결하는 연결 가중치로서, 트레이닝 데이터를 통해 미리 학습이 완료된 결정 가중치에 의하여 특정된 구조를 갖는다. 신경망 모듈의 출력값은, 확장 영역의 좌표값, 단위 블록 영역의 좌표값일 수 있으며, 확장 영역 또는 단위 블록 영역에 대한 특징값 행렬의 형태로 구현될 수 있다. 컴퓨터 판독 가능한 저장 모듈은 컴퓨터 실행 가능 명령어 내지 프로그램 코드, 프로그램 데이터 및/또는 다른 적합한 형태의 정보를 저장하도록 구성된다. 컴퓨터 판독 가능한 저장 모듈에 저장된 프로그램은 프 로세서에 의해 실행 가능한 명령어의 집합을 포함한다. 일 실시예에서, 컴퓨터 판독한 가능 저장 모듈 는 메모리(랜덤 액세스 메모리와 같은 휘발성 메모리, 비휘발성 메모리, 또는 이들의 적절한 조합), 하나 이상의 자기 디스크 저장 기기들, 광학 디스크 저장 기기들, 플래시 메모리 기기들, 그 밖에 코드 최적화 장치 에 의해 액세스되고 원하는 정보를 저장할 수 있는 다른 형태의 저장 매체, 또는 이들의 적합한 조합일 수 있다. 통신 버스는 프로세서, 컴퓨터 판독 가능한 저장 모듈를 포함하여 코드 최적화 장치의 다른 다 양한 컴포넌트들을 상호 연결한다. 코드 최적화 장치는 또한 하나 이상의 입출력 장치(미도시)를 위한 인터페이스를 제공하는 하나 이상의 입 력 모듈 및 출력 모듈 및 하나 이상의 통신 인터페이스를 포함할 수 있다. 입력 모듈 및 출력 모듈 및 통신 인터페이스는 통신 버스에 연결된다. 입출력 장치(미도시)는 입력 모듈 및 출력 모듈 를 통해 코드 최적화 장치의 다른 컴포넌트들에 연결될 수 있다. 예시적인 입출력 장치는 포인팅 장 치(마우스 또는 트랙패드 등), 키보드, 터치 입력 장치(터치패드 또는 터치스크린 등), 음성 또는 소리 입력 장 치, 다양한 종류의 센서 장치 및/또는 촬영 장치와 같은 입력 장치, 및/또는 디스플레이 장치, 프린터, 스피커 및/또는 네트워크 카드와 같은 출력 장치를 포함할 수 있다. 예시적인 입출력 장치(미도시)는 코드 최적화 장치 를 구성하는 일 컴포넌트로서 코드 최적화 장치의 내부에 포함될 수도 있고, 코드 최적화 장치 와는 구별되는 별개의 장치로 컴퓨팅 기기와 연결될 수도 있다. 도 3은 본 발명의 실시예에 따른 코드 최적화 장치의 코드 최적화 동작 구조에 대한 다이어그램을 나타낸 도면 이다. 코드 최적화 유닛은 프론트 엔드, 제1 미들 엔드, 계측 처리부, 코드 분할 알고리즘 저장부 , 제2 미들 엔드 및 백 엔드 등의 구성 요소를 포함할 수 있다. 프론트 엔드는 성능 모니터링 유닛에서 측정된 이벤트에 대한 소스 코드를 대상 IR로 변환한다. 프론트 엔드는 모니터링 유닛(PMU)로부터 측정된 하드웨어 기반 이벤트에 대한 상기 대상 IR을 변환한다. 여기서, 이벤트에 대한 소스 코드는, 파이썬(Python), R, 자바(Java) 및 C/C++ 등과 같은 고레벨 프로그래밍 언 어(high-level programming language) 기반의 코드 또는 TensorFlow, PyTorch, Keras 및 Scikit-learn 등과 같 은 라이브러리 및 프레임워크 기반의 코드일 수 있다. 제1 미들 엔드는 대상 IR에서 기 설정된 영역 처리 단위(granularity)로 코드 영역을 식별하고, PIM 프로 파일링 라이브러리 기반으로 대상 IR을 계측한다. 제1 미들 엔드는 대상 IR에서 영역 처리 단위(granularity)를 기반으로 코드 영역을 식별하고, PIM 프로파 일링 라이브러리에 기 저장된 PIM 프로파일링 API를 삽입하여 상기 대상 IR을 계측한다. 제1 미들 엔드는 함수 레벨의 영역 처리 단위(granularity)로 상기 대상 IR을 확인하고, 상기 대상 IR에서 확인된 함수가 빌트인 함수가 아닌 경우, 해당 함수의 코드 영역 시작과 끝에 프로파일러 런타임 라이브러리에 대한 제1 호출 함수를 삽입한다. 또한, 제1 미들 엔드는 기본 블록의 영역 처리 단위(granularity)로 상기 해당 함수를 확인하고, 상기 확 인된 기본 블록이 오프로드 가능한 코드 영역으로 시작하지 않는 경우, 상기 기본 블록의 코드 영역 시작과 끝 에 프로파일러 런타임 라이브러리에 대한 제2 호출 함수를 삽입할 수 있다. 예를 들어, 제1 미들 엔드는 런타임 중에 프로파일링 함수를 호출하기 위해 IR을 계측화하는 인스펙터이다. 런타임 라이브러리에서 프로그램은 PMU를 초기화하여 하드웨어별 이벤트를 수집한다. 동시에 라 이브러리는 스레드를 CPU에 고정시킨다. 이 초기화 단계 이후, 인스펙터의 런타임 라이브러리는 PMU 이벤트를 수집하고 이벤트 데이터를 버퍼에 저장한다. 버퍼가 가득 차거나 프로그램이 종료되면 버퍼는 결과를 파일로 덤 프한다. 계측 처리부는 계측된 대상 IR을 PIM 프로파일링 라이브러리와 연결하여 실행 가능 바이너리(binary)를 생 성하고, 실행 가능 바이너리를 실행하여 프로파일링 데이터(profiling data)를 생성한다. 계측 처리부는 코드 영역의 시작과 끝에서 상기 이벤트에 대한 카운터를 리드(read)한다. 계측 처리부는 코드 영역의 시작과 끝에서 리드된 카운터를 비교하고, 비교 결과에 대한 차이를 프로파일 링 데이터로 저장한다. 예를 들어, 계측화된 IR은 실행 가능한 바이너리로 컴파일된다. 바이너리를 실행함으로써 프로파일링 결과를 얻 을 수 있다. 이 결과는 제2 미들 엔드인 오프로더에 전달된다. 코드 분할 알고리즘 저장부은 코드 영역이 메모리 바운드인지를 결정하기 위한 코드 분할 알고리즘을 저장 한다. 본 실시예에 따른 제1 미들 엔드 및 계측 처리부에서 코드 최적화를 위한 프로파일링 결과를 생성하 기 위해 코드 분할 알고리즘을 사용하며, 코드 분할 알고리즘은 휴리스틱을 계산하고, 계산 결과는 제2 미들 엔 드로 전달된다. 여기서, 코드 분할 알고리즘은 Detecting Memory-Boundedness with Hardware Performance Counters(ICPE '17: Proceedings of the 8th ACM/SPEC on International Conference on Performance Engineering, April 2017, Pages 27-38)에 기재된 알고리즘과 유사하다. 제2 미들 엔드는 프로파일링 데이터를 포함하는 프로파일링 통계 및 대상 IR을 기반으로 코드 영역을 분류 한다. 제2 미들 엔드는 프로파일링 통계에 포함된 과거 카운팅 결과를 기반으로 코드 영역을 분류한다. 여기서, 제2 미들 엔드는 코드 영역을 데이터 중심 부분(data-intensive parts) 및 계산 중심 부분(compute- intensive parts) 중 하나로 분류한다. 다시 말해, 제2 미들 엔드는 대상 IR과 프로파일링된 통계를 입력으로 받는다. 코드 분할 알고리즘의 도움 으로 제2 미들 엔드는 코드 영역을 분류하고 해당 영역이 메모리 바운드인지 아니면 컴퓨트 바운드인지를 결정한다. 이후, 제2 미들 엔드는 메모리 바운드 코드 영역을 프로세싱 인 메모리로, 컴퓨트 바운드 코드 영역을 메인 프로세서로 오프로드할 수 있다. 백 엔드는 분류 결과에 따라 코드 영역을 프로세싱 인 메모리 또는 메인 프로세서로 전달한다. 백 엔드는 분류된 코드 영역이 데이터 중심(data-intensive)으로 분류된 경우, 메모리 바운드 기반의 코드 영역에 대응하는 프로세싱 인 메모리에 오프로드되도록 할 수 있다. 도 4는 본 발명의 실시예에 따른 코드 최적화 장치의 코드 최적화 방법을 설명하기 위한 순서도이다. 코드 최적화 유닛은 성능 모니터링 유닛(PMU)에서 측정된 이벤트에 대한 소스 코드를 대상 IR로 변환한다 (S410). 대상 IR은 코드 최적화 유닛의 프론트 엔드에서 변환되어 생성될 수 있다. 여기서, 프론트 엔 드는 LLVM 컴파일러에 포함된 프론트 엔드일 수 있다. 성능 모니터링 유닛(PMU)에서 측정된 이벤트는 하드웨어 기반 이벤트이며, 이벤트에 대한 소스 코드는 파이썬 (Python), R, 자바(Java) 및 C/C++ 등과 같은 고레벨 프로그래밍 언어(high-level programming language) 기반 의 코드 또는 TensorFlow, PyTorch, Keras 및 Scikit-learn 등과 같은 라이브러리 및 프레임워크 기반의 코드 일 수 있다. 코드 최적화 유닛에서 변환된 대상 IR은 제1 미들 엔드로 전달된다(S420). 여기서, 제1 미들 엔드 는 인스펙터(Inspector) 패스로써, LLVM 컴파일러의 제1 미들 엔드 패스일 수 있다. 제1 미들 엔드는 대상 IR에서 다양한 영역 처리 단위들(granularities)을 기반으로 코드 영역을 식별하고, PIM 프로파일링 라이브러리에 기 저장된 PIM 프로파일링 API를 삽입하여 하드웨어 별 이벤트를 수집하도록 대상 IR을 계측한다. 코드 최적화 유닛은 계측된 대상 IR을 PIM 프로파일링 라이브러리와 연결하여 실행 가능 바이너리(binary) 를 생성한다(S430). 다시 말해, 계측된 대상 IR은 PIM 프로파일링 런타임 라이브러리로 컴파일되고, 계측된 실 행 가능 바이너리가 생성된다. 코드 최적화 유닛은 계측된 바이너리를 실행하여 프로파일링 통계를 수집한다(S440). 코드 최적화 유닛은 계측된 바이너리를 실행하여 프로파일링 데이터(profiling data)를 생성한다. 코드 최 적화 유닛은 적어도 하나의 프로파일링 데이터를 기반으로 프로파일링 통계를 수집한다. 여기서, 생성된 프 로파일링 데이터는 제2 미들 엔드로 전달된다. 여기서, 제2 미들 엔드는 오프로더(offloader) 패스로 써, LLVM 컴파일러의 제2 미들 엔드 패스일 수 있다. 코드 최적화 유닛은 제2 미들 엔드를 통해 프로파일링 데이터를 포함하는 프로파일링 통계 및 대상 IR 을 기반으로 코드 영역을 분류하고, 분류 결과에 따라 백 엔드를 통해 프로세싱 인 메모리 또는 메인 프로세서로 코드 영역을 전달한다(S450). 제2 미들 엔드는 프로파일링 데이터를 분석하여 코드 영역을 분류한다. 여기서, 제2 미들 엔드는 코 드 영역을 데이터 중심 부분(data-intensive parts) 및 계산 중심 부분(compute-intensive parts)으로 분류할 수 있다. 여기서, 데이터 중심 부분으로 분류된 코드 영역은 프로세싱 인 메모리로 전달되고, 계산 중심 부 분으로 분류된 코드 영역은 메인 프로세서로 전달된다. 도 5 내지 도 7은 본 발명의 실시예에 따른 코드 최적화 장치의 인스펙터 및 오프로더의 동작을 설명하기 위한 순서도이다. 도 5는 제1 미들 엔드인 인스펙터 패스의 동작을 설명한다. 제1 미들 엔드는 대상 IR을 입력 받는다(S510). 제1 미들 엔드는 프론트 엔드로부터 대상 IR을 수신한다. 제1 미들 엔드는 함수 레벨의 영역 처리 단위(granularity)로 대상 IR을 확인한다(S520). 제1 미들 엔드는 대상 IR에서 확인된 함수가 기 저장된 빌트인(built-in) 함수인지 여부를 확인한다 (S530). 단계 S530에서, 제1 미들 엔드는 대상 IR에서 확인된 함수가 빌트인 함수인 경우, 대상 IR에 포함된 다음 함수를 확인한다(S532) 한편, 단계 S530에서, 제1 미들 엔드는 대상 IR에서 확인된 함수가 빌트인 함수가 아닌 경우, 해당 함수의 코드 영역 시작과 끝에 프로파일러 런타임 라이브러리에 대한 제1 호출 함수(기 설정된 특수 코드)를 삽입한다 (S540). 이후, 제1 미들 엔드는 기본 블록의 영역 처리 단위(granularity)로 해당 함수를 확인한다(S550). 제1 미들 엔드는 확인된 기본 블록이 오프로드 가능한 코드 영역으로 시작하는지 여부를 확인한다(S560). 단계 S560에서, 확인된 기본 블록이 오프로드 가능한 코드 영역으로 시작하는 경우, 함수 내의 다음 기본 블록 을 확인한다(S562). 한편, 단계 S560에서, 확인된 기본 블록이 오프로드 가능한 코드 영역으로 시작하지 않는 경우, 기본 블록의 코 드 영역 시작과 끝에 프로파일러 런타임 라이브러리에 대한 제2 호출 함수(기 설정된 특수 코드)를 삽입한다 (S570). 도 6은 제1 미들 엔드인 인스펙터 패스에서 사용되는 PIM 프로파일링 런타임의 동작을 설명한다. PIM 프로파일링 런타임 동작은 계측 처리부에서 수행된다. 계측 처리부에서 프로파일러가 시작되면(S610), 성능 모니터링 유닛의 초기화 여부를 확인한다(S620). 단계 S620에서, 성능 모니터링 유닛이 초기화되지 않은 상태인 경우, 계측 처리부는 하드웨어 별 이벤 트를 측정하는 성능 모니터링 유닛가 초기화되도록 한다(S622). 단계 S620에서, 성능 모니터링 유닛이 초기화된 상태인 경우, 계측 처리부는 성능 모니터링 유닛 의 하드웨어 별 이벤트 카운터를 리드(read)하고, 기 설정된 버퍼 내에 저장한다(S630). 계측 처리부는 저장된 바이너리를 실행하고(S640), 프로파일링 데이터(profiling data)를 생성하여 프로파 일러를 종료한다(S650). 계측 처리부는 성능 모니터링 유닛의 하드웨어 별 이벤트 카운터를 리드(read)한다(S660). 계측 처리부는 단계 S630 및 S660 각각 즉, 코드 영역의 시작과 끝에서 리드된 카운터를 비교하고(S670), 비교 결과에 대한 차이를 프로파일링 결과를 파일로 저장한다(S680). 여기서, 프로파일링 결과는 통계 연산된 결과일 수 있으며, 프로파일링 데이터(profiling data)를 포함할 수 있다. 도 7은 제2 미들 엔드인 오프로더 패스의 동작을 설명한다. 제2 미들 엔드는 대상 IR 및 프로파일링 결과를 입력 받는다(S710). 제2 미들 엔드는 프론트 엔드 로부터 대상 IR을 수신하고, 계측 처리부로부터 프로파일링 결과를 수신한다. 제2 미들 엔드는 대상 IR을 코드 영역으로 나눈다(S720). 제2 미들 엔드는 프로파일된 통계를 기반으로 코드 영역을 분류한다(S730). 제2 미들 엔드는 프로파 일링 결과에 포함된 프로파일링 데이터를 분석하여 코드 영역을 분류한다. 제2 미들 엔드는 프로파일링 결 과에 포함된 과거 카운팅 결과를 기반으로 코드 영역을 분류할 수 있다. 여기서, 제2 미들 엔드는 코드 영 역을 데이터 중심 부분(data-intensive parts) 및 계산 중심 부분(compute-intensive parts)으로 분류할 수 있 다. 제2 미들 엔드는 분류된 코드 영역이 메모리 바운드 기반인지 여부를 확인한다(S740). 단계 S740에서, 분류된 코드 영역이 메모리 바운드 기반의 코드 영역인 경우, 대상 IR을 데이터 중심(data- intensive)으로 수정하여 프로세싱 인 메모리에 오프로드되도록 한다(S750). 단계 S740에서, 분류된 코드 영역이 메모리 바운드 기반의 코드 영역이 아닌 경우, 대상 IR을 계산 중심 (compute-intensive)으로 수정하여 메인 프로세서에서 처리되도록 한다(S760). 도 4 내지 도 7 각각에서는 각 단계를 순차적으로 실행하는 것으로 기재하고 있으나, 반드시 이에 한정되는 것 은 아니다. 다시 말해, 도 4 내지 도 7 각각에 기재된 단계를 변경하여 실행하거나 하나 이상의 단계를 병렬적 으로 실행하는 것으로 적용 가능할 것이므로, 도 4 내지 도 7 각각은 시계열적인 순서로 한정되는 것은 아니다. 도 4 내지 도 7에 기재된 본 실시예에 따른 코드 최적화 방법은 애플리케이션(또는 프로그램)으로 구현되고 단 말장치(또는 컴퓨터)로 읽을 수 있는 기록매체에 기록될 수 있다. 본 실시예에 따른 코드 최적화 방법을 구현하 기 위한 애플리케이션(또는 프로그램)이 기록되고 단말장치(또는 컴퓨터)가 읽을 수 있는 기록매체는 컴퓨팅 시 스템에 의하여 읽혀질 수 있는 데이터가 저장되는 모든 종류의 기록장치 또는 매체를 포함한다. 도 8 내지 도 12는 본 발명의 실시예에 따른 코드 최적화 예시를 나타낸 도면이다. 도 8은 코드 최적화를 위한 예시 코드를 나타낸다. 도 9는 컴파일러 프런트 엔드에서 생성된 제어 흐름 그래프(CFG: Control-flow graph)를 나타낸다. 도 9을 참고 하면, 컴파일러에 의해 LLVM IR(대상 IR)은 생성될 수 있다. 도 10는 PIM 런타임 라이브러리를 사용하여 인스펙터 패스에 의해 생성된 제어 흐름 그래프(CFG)를 나타낸다. 도 10을 참고하면, 제어 흐름 그래프를 통해 계측된 바이너리가 컴파일될 수 있다. 도 11 및 도 12는 오프로더 패스에 의한 코드 구분을 나타낸다. 도 11 및 도 12을 참고하면, 메모리 바운드 기 반의 코드 영역은 프로세스 인 메모리로 오프로드된다. 이상의 설명은 본 발명의 실시예의 기술 사상을 예시적으로 설명한 것에 불과한 것으로서, 본 발명의 실시예가 속하는 기술 분야에서 통상의 지식을 가진 자라면 본 발명의 실시예의 본질적인 특성에서 벗어나지 않는 범위에서 다양한 수정 및 변형이 가능할 것이다. 따라서, 본 발명의 실시예들은 본 발명의 실시예의 기술 사상을 한정 하기 위한 것이 아니라 설명하기 위한 것이고, 이러한 실시예에 의하여 본 발명의 실시예의 기술 사상의 범위가 한정되는 것은 아니다. 본 발명의 실시예의 보호 범위는 아래의 청구범위에 의하여 해석되어야 하며, 그와 동등 한 범위 내에 있는 모든 기술 사상은 본 발명의 실시예의 권리범위에 포함되는 것으로 해석되어야 할 것이다."}
{"patent_id": "10-2023-0169862", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 실시예에 따른 코드 최적화 장치를 개략적으로 나타낸 블록 구성도이다. 도 2는 본 발명의 실시예에 따른 코드 최적화 장치의 하드웨어 구조를 개략적으로 나타낸 블록 구성도이다. 도 3은 본 발명의 실시예에 따른 코드 최적화 장치의 코드 최적화 동작 구조에 대한 다이어그램을 나타낸 도면 이다. 도 4는 본 발명의 실시예에 따른 코드 최적화 장치의 코드 최적화 방법을 설명하기 위한 순서도이다. 도 5 내지 도 7은 본 발명의 실시예에 따른 코드 최적화 장치의 인스펙터 및 오프로더의 동작을 설명하기 위한 순서도이다. 도 8 내지 도 12는 본 발명의 실시예에 따른 코드 최적화 예시를 나타낸 도면이다."}
