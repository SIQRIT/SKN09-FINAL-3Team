{"patent_id": "10-2024-7015160", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0072271", "출원번호": "10-2024-7015160", "발명의 명칭": "유니버셜 블록체인 E3A 커넥션", "출원인": "하산 사이드 캄란", "발명자": "하산 사이드 캄란"}}
{"patent_id": "10-2024-7015160", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "범용 BCHAIN 모든 연결들 (UBEC; BCHAIN Everyone / Everything / Everywhere Connections) 시스템으로서,a) 상기 BCHAIN 프로토콜에 따라 작동하는 UBEC 어플리케이션;b) 상기 BCHAIN 프로토콜에 따라 소프트웨어를 동작시키는 다수의 BCHAIN 노드를 포함하는 BCHAIN 네트워크;c) 상기 BCHAIN 네트워크에서 직접 작동하는 데이터 저장, 제공 및 계산 프로그램을 포함하는 앱체인(Appchain);d) UBEC 플랫폼에서 인공 지능 제어 메커니즘을 포함하는 제정된 UBEC 독립 관리 지능(LUIGI; Legislated UBECIndependent Governing Intelligence)을 포함하고,상기 BCHAIN 네트워크 내에 존재하는 상기 노드 상호 작용의 패러다임에서,메타체인(Metachain)은 상기 BCHAIN 네트워크상의 모든 노드가 필수 및 주요 참조를 위해 접속하는 메타데이터를 포함하는 커스텀체인이며,상기 메타체인은 노드와 섹터 위치, 컨텐츠 요구 경향 및 홉 라우팅(hop routing)을 포함하는 기본 정보를 추적하고, 이를 통해 인프라 설정((infrastructure setup)을 간소화 하며,모든 단일 BCHAIN 노드가 상기 메타체인을 읽는 데 참여해야 하며,상기 앱체인은 상기 메타체인이 구성한 상기 인프라를 통해 정보를 전달하기 위한 진보된 스마트 계약(advancedsmart contract)으로 작동하는 커스텀체인이며,상기 앱체인은 병렬된 입력과 출력 및 중첩된(nested) 커스텀체인 생태계(Customchain Ecosystem)를 위하여 서로를 참조할 수 있으며,마이크로체인은 상기 메타체인에 종속되지 않거나 연결되지 않는 커스텀체인으로 자동 변환되는 앱체인이고,개인 지능 프로파일(PIP; Personal Intelligence Profile)은 상기 UBEC 사용자의 개인 정보를 다수의 잠재적엔드 포인트 및 프론트-엔드를 통해 저장하는 것을 특징으로 하는 시스템."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "UBEC (Universal BCHAIN Everyone / Everything / Everywhere Connections) 시스템은 BCHAIN 프로토콜에 따라 작동하는 UBEC 응용 프로그램, BCHAIN 프로토콜에 따라 소프트웨어를 작동하는 BCHAIN 노드의 기능을 포함하는 BCHAIN 네트워크, UBEC 플랫폼에서 인공 지능 제어 메커니즘을 포함하는 BCHAIN 네트워크 및 입법화 된 UBEC 독 립 거버넌스 지능 (LUIGI)에서 직접 작동하는 데이터 저장, 서빙 및 계산 프로그램을 포함하는 앱체인을 포함한 다."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명의 명칭은 유니버설/유비쿼터스 블록체인 모두/모든 것/모든 장소, 모든 시간 커넥션 (Universal/Ubiquotous BCHAIN Everyone / Everything / Everywhere, All Time (E3A) Connections (UBEC))이 다. UBEC은 동기화 된 별도의 알고리즘 기준의 인스턴스를 통해 효율적인 협업을 달성한다."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "스마트 장치 (예를 들어, 스마트 폰, PC, IoT 장치)를 사용하는 디지털 도메인은 서로 연결하기 위한 플랫폼을 필요로 한다. 이러한 플랫폼을 통해 스마트 장치는 안전하고 효율적인 방식으로 디지털 활동을 수행 할 수 있어 야 한다. 블록 체인은 이러한 플랫폼을 구축하기에 적합한 기술이다. 인공 지능은 플랫폼 및 플랫폼에서 수행되 는 디지털 활동을 향상시키기 위한 새로 떠오르는 분야이다.선행기술문헌 특허문헌 (특허문헌 0001) US 2017/0214701 A1 (2017. 7. 27)"}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 스마트 장치가 안전하고 효율적인 방식으로 디지털 활동을 수행 할 수 있는 방안을 제공하는 것이다."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명은 다음을 포함하는 UBEC (Universal BCHAIN Everyone / Everything / Everywhere Connections) 시스템 을 제공한다. a) BCHAIN 프로토콜에 따라 작동하는 UBEC 어플리케이션; b) BCHAIN 프로토콜에 따라 소프트웨어 를 동작시키는 다수의 BCHAIN 노드를 포함하는 BCHAIN 네트워크; c) BCHAIN 네트워크에서 직접 작동하는 데이터 저장, 제공 및 계산 프로그램을 포함하는 앱체인; d) UBEC 플랫폼에서 인공 지능 제어 메커니즘을 포함하는 제 정된 UBEC 독립 관리 지능(LUIGI; Legislated UBEC Independent Governing Intelligence). BCHAIN 네트워크 내 에 존재하는 노드 상호 작용의 패러다임에서, 메타체인은 BCHAIN 네트워크상의 모든 노드가 본질적 및 주요 참 조를 위해 접속하는 메타데이터를 포함하는 커스텀체인이며, 메타체인은 노드 / 섹터 위치, 컨텐츠 요구 경향 및 홉 라우팅(hop routing)을 포함하는 기본 정보를 추적하여 인프라 설정을 간소화 하며, 모든 단일 BCHAIN 노 드가 메타체인을 읽는 데 참여하는 것이 요구되고, 앱체인은 메타체인이 구성한 인프라를 통해 정보를 전달하기 위한 진보된 스마트 계약(advanced smart contract)으로 작동하는 커스텀체인이며, 앱체인은 병렬된 입력 / 출 력 및 중첩된(nested) 커스텀체인 생태계(Customchain Ecosystem)를 위하여 서로를 참조할 수 있으며, 마이크로 체인은 메타체인에 종속되지 않거나 연결되지 않는 커스텀체인으로 자동 변환되는 앱체인이다. BCHAIN 프로토콜에서, 대기정보 브로드캐스트(QIB; Queued Information Broadcast)는 다른 노드로 브로드캐스 팅 할 예정인 컨텐츠 클레임 요청들(CCRs; Content Claim Requests) 또는 컨텐츠 클레임 실행(CCF; Contents Claim Fulfillment)를 관리하고, CCR 및 CCF의 패킷의 정보는 BCHAIN 프로토콜(BP)과 노드의 하드웨어 인터 페이스 사이의 익스클루시브 레이어(Exclusive layer)인 커뮤니케이션 게이트웨이(CG; Communications Gateway)로 전달되며, CG는 주변 노드에 관한 정보를 노드 통계 조사(NSS; Node Statistical Survey)로 전달하 며, NSS는 계산될 4 개의 인덱스 -즉, 노드 이탈 인덱스(Node Escape Index), 노드 포화 인덱스(Node Saturation Index), 노드 일관성 인덱스(Node Consistency Index), 노드 오버랩 인덱스(Node Overlap Index)- 의 형성의 원인이 되는 주변노드를 추적하며, 노드 이탈 인덱스는 이웃 노드가 감지 노드(Perceiving Node)의 부근으로부터 이탈할 가능성을 추적하며, 노드 포화 인덱스는 감지 노드(Perceiving Node)의 감지 범위 내의 노 드의 양을 추적하고, 노드 일관성(consistency) 인덱스는 감지 노드(Perceiving Node)에 의해 해석되는 노드 서 비스의 질을 추적하고, 노드 오버랩 인덱스는 감지 노드(Perceiving Node)에 의해 해석되는 노드들이 서로 중첩 되는 양을 추적하며 감지 노드(Perceiving Node)는 NSS의 인스턴스를 실행하는 것이다 결과적인 4 개의 변수는 노드들 사이에서 프로토콜 컨센서스를 강요하는 전략 확증 시스템(SCS; Strategy Corroboration System)에 보내지고, 동적 전략 적응(DSA; Dynamic Strategy Adaption)은 NSS 변수를 수신하여, 계산된 전략 기준 구성(Strategy Criteria Composition)을 기반으로 한 전략 배치를 동적으로 변경 하며, 전략 기준 구성(Strategy Criteria Composition)은 BCHAIN 프로토콜의 핵심 요소, 중요 요소 및 보충 요소들에 어떻게 작동할 지 알려주는 다양한 변수를 포함하며, 등록된 앱체인은 다양한 앱체인의 암호화 액세스 키를 포함하며, 메타체인의 앱체인 업데이트에서 앱체인에 대한 업데이트가 공고(announce)되면 기기는 앱체인 에 가장 최신 업데이트를 다운로드 하고, 등록된 앱체인에 저장된 암호화 키에서 가져온 암호화 자격 증명 (Cryptographic Proof of Entitlement)으로 표시된다. LUIGI는 UBEC 플랫폼 내에서, 하드코딩 된 영구적이고 돌이킬 수 없는 수준의 관리 및 실행 권한을 부여 받고, LUIGI는 SPSI에 의해 독점적으로 프로그래밍되고 유지 관리되고, LUIGI는 배포된 BCHAIN 네트워크에서만 독점적 으로 호스팅 되며, 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)은 공식 지정을 부여받은 UBEC 플랫폼 내에서 자신 및 다른 앱체인을 자동으로 프로그램하는 앱체인이다. 어휘 객관성 마이닝(LOM; Lexical Objectivity Mining)은 광범위한 질의 및 / 또는 주장에 대한 객관적인 대답 에 최대한 가깝게 접근하려고 시도하며, LOM은 UBEC 사용자와 협의하여 LOM의 입장에 대한 그들의 주장을 양보 또는 개선하도록 허용하며, 자동화된 리서치 매커니즘(ARM; Automated Research Mechanism)이 LOM의 일반적인 평가 및 의사 결정 기능을 향상시키기 위해 지속적으로 CKR에 새로운 지식을 제공하려고 시도한다. LOM 컨테이너 앱체인은 앱체인의 포맷으로 핵심 모듈을 수용하고, 앱체인은 실행 스트림(Execution Stream)을 출력하기 위해 ESC를 통해 추출된 자신의 실행 세그먼트(Execution Segments)를 가지고, 실행 스트림은 LOM을 운영하는 핵심 모듈로서 나타나며, 초기 쿼리 추론(IQR; Initial Query Reasoning)은 UBEC 사용자가 제공한 초기 질의 / 주장을 수신한 다음 중앙 지식 보유(CKR; Central Knowledge Retention)를 활용하여 이해 및 질의 /주장에 대한 답변/응답에 필수적인 누락된 세부 사항을 해독하며, 주장 구성(AC; Assession Construction)은 주장 또는 질의의 형태로 명제를 수신하고 그러한 명제와 관련된 개념의 출력을 제공하며, 계층적 매핑(HM; Hierarchical Mapping)은 연관 개념을 매핑하여 질의 / 주장 일관성의 확증 또는 충돌을 발견하고 주제에 대해 특정 입장을 취하는 이점 및 위험을 계산하며, 합리적 어필(RA; Rational Appeal)은 CTMP 기술을 사용하여, 사 람의 반응의 비판이든 자기 비판이든 주장에 대해 비판하며, 지식 검증(KV; Knowledge Validation)은 질의 능력 및 CKR로의 동화를 위해 논리적으로 분리될 필요가 있는 고도로 확실하고 미리 비판된 지식을 수신하며, 상호 참조 분석(CRA; Cross Reference Analysis)은 수신된 정보를 CKR로부터의 선재 지식을 고려하여 비교되고 구성 되며, 실행 스트림은 ESE에 의해 실행된 후에 실제로 나타나며, 데이터 세그먼트는 UBEC 시스템와이드 로직 (Systemwide Logic)으로부터 LOM 컨테이너 앱 체인으로 도착하고, 데이터 세그먼트는 실행 스트림에 의해 정의 된 LOM의 핵심 로직과 함께 ESE에 의해 처리되고 실행 스트림의 모듈식 표시(Manifestation)로 열거되고, 입력 데이터 세그먼트는 LOM 질의 / 주장 입력으로서 나타나고, ESE의 실행은 LOM 질의 / 주장 입력에 대한 LOM의 공식 응답으로서 UBEC 시스템와이드 로직으로 되돌아오는 데이터 세그먼트를 출력한다. 개인 지능 프로파일(PIP; Personal Intelligence Profile)은 UBEC 사용자의 개인 정보를 다수의 잠재적 엔드 포인트 및 프론트-엔드를 통해 저장한다. 자동 배포 메커니즘은 상기 UBEC 플랫폼을 어플리케이션으로서 하드웨어 장치에 배포하도록 적응되며, SPSI는 소프트웨어, 펌웨어 및 하드웨어 업데이트를 UBEC / BCHAIN 하이브리드 핵심 로직에 제출하고, 여기서 상기 UBEC 플랫폼은 상기 BCHAIN 프로토콜 코드베이스와 공동 작업하는 자신의 고유한 코드베이스(Codebase)를 가지 고, 두 코드베이스는 모두 상기 모듈식 인터페이스 플러그인(Modular Interface Plugin)에 직접 연결되어 BCHAIN 노드의 다른 운영 체제 구성 및 하드웨어 상에서 코드베이스의 호환 가능한 실행을 보장하며, 상기 하이 브리드 핵심 로직은 이후 상기 선택된 BCHAIN 노드의 상기 상관 관계가 있는 하드웨어 및 운영 체제 구성에 따 라 선택되는 다른 배포 루틴(Deployment Routines) 중 하나를 통해 배포된다. UBEC 패스스루(Passthrough)는 앱체인으로서의 UBEC에서 발생하는 정보 트래픽을 수신하고, 상기 통과한 정보를 분석 할 때 상기 정보는 UBEC 종합 리턴(UBEC Comprehensive Return)을 통해 앱체인으로서의 UBEC에 리턴되어 이후의 여정을 계속하고 상기 UBEC 플랫폼 내의 의도된 목적지에 도달하며, UBEC 패스스루로부터 상기 들어오는 정보는, 상기 데이터가 LOM, LIZARD 또는 둘 모두에 의해 처리 되어야 하는지를 결정하는 LUIGI 업무 위임(LTD; LUIGI Task Delegation)으로 전달되며, 상기 UBEC 플랫폼 내에서 발생하는 정보 액세스 이벤트 및 거래 (transaction)를 적절하게 관리하기 위해, LUIGI 시정 조치(LCA; LUIGI Corrective Action)가 호출된다. 새로운 어플리케이션 또는 이미 존재하는 어플리케이션에 대한 업데이트가 제출될 때, LUIGI는 LIZARD 기술을 사용하여 정확한 관할 패턴을 식별함으로써 UBEC에서 어플리케이션이 필요한지 아닌지를 이해할 수 있도록 하며, LUIGI는 어플리케이션 제출을 차단하거나 승인하며 이는 LCA(LUIGI Corrective Action)에 나타난 실행이 다. 사용자 노드 상호 작용(UNI)은 인증을 위해 직접적인 생체정보를 사용하고, 어느 사용자 이름이나 계정 (account) 컨테이너도 참조하지 않으며, 노드, 데이터 및 서비스는 상기 사용자의 생체정보에 직접 연결되며, 생체 정보는 생체 데이터 측정 장치의 오차 범위로 인한 생체 데이터 측정의 변화를 제거하는 상기 데이터의 반 올림 버전을 생성하는 BBC(Biometric Band Categorization)로 전송되며, BBC에 입력된 각각의 생체 데이터에 대해 대응하는 밴드 인증 토큰(BAT; Band Authorization Token)이 출력으로서 생성되며, 새롭게 생성된 BAT와 밴드 연관성 앱 체인(Band Association Appchain)에 저장된 인증 토큰이 비교되고, 제공되는 생체정보의 양은 상기 인증 프로세스에 충분한지 측정 및 검사된다BBC 내에서, 상기 수신된 일반 생체 입력(Generic Biometric Input)의 입상 분리(Granular Separation)가 생성 되고, 상기 입상 분리는 상기 입력 내에서 발견된 크기 범위를 정량화하는 포맷으로 상기 일반 생체 입력을 나 타내는 것이며, 생체 정보(Biometric Data)의 다양한 구성은 높고 낮은 크기의 데이터 포인트를 강조하는 동일 한 포맷으로 어셈블(assemble)되며, 데이터 포인트의 범위는 포맷을 예상되는 오차 범위보다 더 크게 생성하기 위해 확장되며, 상기 포맷에서 생성된 밴드 카테고리는 BAT(Band Authorization Token)로 저장된다 커스텀체인 생태계는 앱체인, 마이크로체인과 하나의 메타체인의 복잡한 상호 작용으로 상기 BCHAIN 네트워크를 구성하는 프로그램 / 루틴 실행과 함께 동적으로 적용 가능한 데이터 보존 및 서비스를 생성하며, 상기 UBEC 앱 스토어는 UBEC 어플리케이션을 호스트, 나열 및 서비스하기 위해 상기 커스텀체인 생태계 내에 존재하며, 상기 UBEC 가능 기기는 상기 UBEC 앱 스토어로부터 UBEC 어플리케이션 A를 선택하고 다운로드하며, 상기 실행 세그먼 트는 상기 UBEC 어플리케이션 A와 상관 관계가 있는 상기 앱체인 A0으로부터 수집되고, 수집된 상기 실행 세그 먼트는 그것들을 실행 스트림 A0으로 모으는(assemble) 실행 스트림 콜렉션(ESC; Execution Stream Collection)으로 보내지고, ESC에 의해 수행되는 상기 어셈블리(assembly)는 상기 실행 세그먼트가 정렬될 필요 가 있는 정확한 순서를 고려하며, 실행 스트림 A0의 상기 실행 세그먼트의 상기 실행은 상기 모듈 실행 스트림 실행(ESE)에서 발생하며, 상기 실행 스트림 A0의 처리 및 어셈블리는 데이터 스트림 A0 및 Z3의 처리 및 어셈블 리와 병행하며, 이는 앱체인 A0으로부터 상기 데이터 세그먼트를 수집하고 이를 데이터 스트림 정렬(DSS)에서 정렬하기 위해 제출하는 스테이지를 통하여 이루어지고, ESE는 실행 스트림 A0에 나열된 상기 명령을 올바르게 실행하기 위해 상기 데이터 스트림 A0 및 Z3을 참조한다. 다수의 커스텀체인 생태계들은 상기 BCHAIN 네트워크를 구성하고, UBEC 어플리케이션 A 및 UBEC 어플리케이션 B 는 각각 자신의 커스텀체인 생태계를 구성하고, 어플리케이션과 상관 관계가 있는 각각의 커스텀체인 생태계는 컨테이너 앱체인(Container Appchain)이 있고, 상기 컨테이너 앱체인은 보충 앱체인에 저장된 실행 스트림 및 데이터 스트림을 참조한다. 커스텀체인 생태계는 특정 UBEC 어플리케이션에 속하지도, 특정 UBEC 어플리케이션을 나타내지도 않는 독립 앱 체인을 포함하고, 독립 앱체인으로부터 개별 실행 스트림 또는 데이터 스트림이 추출될 수 있는 이다. UBEC 사용자는 창의성(Creativity)과 결정을 상기 로지스틱스 관리자 인터페이스(LMI; Logistics Manager Interface)에 입력하고 LMI는 UBEC 사용자가 LMI를 통해 디자인한 상기 어플리케이션 로지스틱스를 정의하는 일 반 정보 형식인 로지스틱스 레이어(Logistics Layer)를 출력하고, 상기 로지스틱스 레이어는 입력으로, 상기 커 스텀체인 생태계 빌더(CEB; Customchain Ecosystem Builder)에 보내지며, 상기 CEB는 상기 UBEC 사용자에 의해 감지된 상기 로지스티컬 어플리케이션(Logistical Application)을 커스텀체인 생태계로 구성된 기본 빌딩 블록 을 사용하여 자동으로 구성하고, 커스텀체인 생태계 빌더 논리 흐름(Builder Logic flow)에서, 초기에 상기 앱 체인의 현재 상태는 실행 세그먼트 및 데이터 세그먼트가 있는 관련 위치를 해석하도록 해석되며, 상기 실행 세 그먼트는 ESE에 의한 상기 프로그램의 올바른 실행을 보장하기 위해 올바른 순서로 실행 스트림으로 어셈블되며, 상기 데이터 세그먼트들은 수집되어 DSS 프로세싱을 통해 데이터 스트림으로 어셈블되고, 상기 내 부 CEB 로직 프로세싱(Internal CEB Logic Processing)은 상기 앱체인의 가장 최신 블록에 저장되는 실행 + 데 이터 서플먼트(Execution + Data Supplements)를 출력하고, 상기 앱체인에 대한 새로운 실행 및 데이터 서플먼 트는 BCHAIN 네트워크 내에서 신규 컨텐츠 공고(NCA; New Content Announcement)를 통해 처리되기 시작하고, 상기 컨텐츠는 상기 채굴자의 상기 멤풀 데이터 저장소(MDS; Mempool Data Storage)에 제출되는데, 이는 최종적 으로 커스텀체인 인터페이스 모듈(CIM; Customchain Interface Module)을 통해 상기 앱체인의 다음 블록 으로 채굴되며, 상기 새로 채굴된 블록의 상기 컨텐츠는 캐시 부분들로 잘라지고 캐시 시딩을 제공하는 마이닝 노드(Mining Nodes Supplying Cache Seeding)를 통해 캐싱 노드들로 전송되며, 상기 캐시 부분은 상기 데이터 를 요청하는 노드들에게 가능한 최상의 가동 시간 및 다운로드 속도를 보장하는 서비스 최적화 영역으로 점차적 으로 및 자동으로 이동하며, 노드들은 컨텐츠 클레임 생성기(Content Claim Generator)를 통해 상기 캐싱 노드 들로부터 상기 컨텐츠를 클레임 하며, 일단 다운로드 된 상기 노드는 ESE를 통해 상기 실행 스트림을 실행하여 상기 의도한 어플리케이션의 표현(manifestation)으로 이어진다 와트 유닛(Watt Unit)은 알고리즘 적으로 전기 가치에 고정되는 암호화 통화이고, 와트 유닛은 상기 UBEC 경제 에 유동성(Liquidity)이 유입 및 유출됨에 따라 LUIGI에 의해 직접 생성되고 파기되며, 분산된 에너지 가격 조 사(DEPS; Distributed Energy Price Survey)는 전기의 현재 명목 화폐(Fiat Currency)가격을 확실하게 보고 할 수 있는 BCHAIN 노드를 조사하고, 제 3 자 통화 거래(TPCE; Third Party Currency Exchange)는 유동성이 상기 메타체인의 상기 와트 경제에 유입 및 유출되는 것을 허용하는 명목 화폐(Fiat Currency)의 매매를 관리하는 상 기 로지스틱스 레이어 역할을 하며, TPCE에서, 와트 유닛을 판매 및 구매하고자 하는 UBEC 사용자는 본질적으로교환에서 함께 쌍을 이루며, 와트 유닛의 상기 명목 화폐 가치는 DEPS에 의해 보고된 가치로 고정되며, UBEC 사 용자가 와트 유닛(Watt Units)을 구매할 때, 구매된 금액을 상세히 밝히는 검증된 거래 보고서(Verified Transaction Report)가 LUIGI에 보내지고, 상기 거래에 대한 LUIGI의 승인에 따라, 와트 유닛을 구입하는 사용 자는 상기 LUIGI 경제 인터페이스(LEI)에서 와트 유닛 생성으로 이어지고, UBEC 사용자가 와트 유닛(Watt Units)을 판매할 때, 구매된 금액을 상세히 밝히는 검증된 거래 보고서가 LUIGI에 보내지고, 상기 거래에 대한 LUGI의 승인을 얻은 사용자는 와트 유닛을 구입하면 LUIGI 경제 인터페이스(LEI; LUIGI Economy Interface)의 와트 유닛 파괴(Watt Unit Destruction)로 이어지고, LEI의 기능에는 사용자 사모 자금 할당(UPFA)에 대한 지식 과 액세스가 필요하며, UPFA의 자금 할당은 그 유형에 따라 지능적으로 노드에 분산되어 노드의 손상 / 도난 위 험을 완화한다. 상기 UBEC 사용자는 경제적 특성(Economical Personality)을 선택할 수 있고, 경제적 특성(이퀄라이저 Equalizer)은 노드 리소스가 오직 상기 USBC 사용자가 소비하는 것과만 일치하도록 소비되는 경우이며, 특성 B (이윤 Profit)는 상기 이윤 마진이 X보다 큰 한, 상기 노드가 가능한 한 많은 로컬 리소스를 소비하는 경우이며, 특성 C(소비자 Consumer)는 상기 UBEC 사용자가 거래 통화를 통해 작업 유닛에 대해 비용을 지불하여 적은 노드 리소스를 소비하면서 컨텐츠를 소비 할 수 있는 경우이며, 특성 D(애타주의 Altruistic)는 어느 것도 그 대가로 기대하지 않으면서 노드 리소스가 가능한 한 많이 소비되는 것이며, ECWI(경제 고려 업무 시행 Economic Considered Work Imposition)는 상기 메타체인의 상기 와트 경제를 참조하여 작업 완료 크레디트와 관련하여 이 노드의 현재 잉여 / 적자를 확인하며, 현재 작업 잉여 / 적자는 ECWI로 전달되며, 이는 현재 수행 해야 할 작업이 더 있는은지 평가하기 위하여 상기 선택된 경제적 특성 및 상기 잉여 / 적자를 고려한다. 병렬 홉 스프레드 기준(Parallel Hop Spread Criteria)으로 알려진 전략 배포(Strategy Deployment)에서 정의 된 상기 기준이 충족되면, 상기 노드는 PHL(Parallel Hop Logic)을 호출하고, 이는 상기 특정 노드가 그들이 수 신 한 것보다 더 많은 병렬 홉 경로를 개시하게 하고, 이는 상기 이동하는 CCR 또는 CCF에 관한 홉 경로에서 중 복을 유도하고, 중복 병렬 홉 경로는 적어도 최소량의 요구된 경로가 카오스로부터의 심각한 방해 없이 최종 타 겟(Final Target)에 도달하는 확률을 높임으로써 카오스로 인한 위험을 완화 시키며, 상기 최종 타겟은 PHL에 의해 개시되는 중복 병렬 홉 경로로 인해 분산된 컨센서스로부터 발생하는 확인을 수신 할 수 있고, CCR 또는 CCF 패킷이 그것의 목적지 노드에서 받아 들여지기 위해서는, 적어도 미리 결정된 수의 별도의 병렬 홉 경로들 로부터 도착 해야 하고, OPHPR(Over-Parallelized Hop Path Reduction)은 상기 시스템에 비효율적인 부담이 되 어 이후 작업 지속이 중단 되어야 하는 병렬 홉 경로를 탐지하고, 생성되는 중복 병렬 홉 경로의 양은 상기 CCR 또는 CCF의 EAT(Economic Authorization Token)에 대해 사전 승인된 상기 와트 유닛 요금의 크기에 따라 달라 지며, 노드의 상기 물리적 움직임을 활용하는 기능은 PDML(Physical Data Migration Layer) 및 PDMU(Physical Data Migration Usage) 모듈들에 의해 처리되며, 물리적 마이그레이션 기능은 시스템의 전체적인 처리량 증가를 허용하며, 이는 노드의 물리적 이동이 네트워크의 효율성을 위해 작동하기 때문이다 섹터들은 상기 BCHAIN 네트워크 내에서 방향 및 이동 경로를 논리적으로 용이하게 하는 BCHAIN 노드들의 클러스 터들이며, 임의의 주어진 시간에 임의의 BCHAIN 노드가 정확히 2 개의 섹터들의 관할에 속하며, 섹터들의 정의 는 TSC(Traffic Scope Consensus)에 의해 생성된 상기 이중 범위 해시(Dual Scope Hash)로부터 파생되며, 최적 화 섹터 경로 발견(OSRD; Optimized Sector Route Discovery)는 상기 메타체인에 정의된 대로 상기 BCHAIN 네 트워크의 지리적 상태를 해석하고 효과적으로 정보의 하이웨이인 최적화된 섹터 경로(Optimized Sector Route) 를 생성하며, 상기 정보가 상기 메타체인의 최적화된 섹터 경로(Optimized Sector Routing)에 제출되고, 경로 (Pathway) 강도(유효성) 및 경로 포화 (수요/사용량)을 포함한 통계 정보가 상기 메타체인의 최적화 된 섹터 경 로(Optimized Sector Routing)에 포함된다 BCHAIN 노드는 궁극적으로 상기 최종 타겟 노드로 보내지는 CCR을 생성하기 위해 CCG를 사용하고, 상기 CCR은 상기 PBHP(Proposed Baseline Hop Path) 및 TVS(Trail Variable Suite)를 갖추고 있으며, 상기 PBHP는 결국 최 종 타겟에 도달하기 위해 이동해야 할 노드의 제안된 시퀀스에 관한 라우팅 정보를 포함하며, 상기 TVS는 상기 CCR 전달을 위한 로지스틱스 관리와 관련된 동적 정보를 포함하고, 로지스틱스의 상기 관리 요소에는 상기 EAT(Economic Authorization Token) 및 특정 섹터 내에서 이동 중에 참조되는 전략 배포 인스턴스가 포함되며, 상기 CCR은 중간 노드(Intermediate node)들 내에 존재하는 노드들을 통해 이동하며, 상기 CCR이 최종 타겟 노 드에 성공적으로 도달하면, 상기 노드는 상기 요청 노드(Request node)에 의해 만들어진 컨텐츠 요청을 수행을 시도하기 위해 CCD(Content Claim Delivery)를 실행하고, 그에 대하여 상기 중간 노드(Intermediate node)를 통해 상기 요청 노드로 이동하는 CCF(Content Claim Fulfillment) 패킷이 전송되고, 상기 CCF는 CCR(Content Claim Rendering)에 의해 처리되고, 상기 CCR은 전체 컨텐츠 유닛이 완전히 렌더링 될 때까지 컨텐츠 부분을 유지하기 위해 SRCC(Stagger Release Content Cache)를 사용한다. 라이브 스트림 컨텐츠 메커니즘은 CCR을 사용하지 않고, 컨텐츠 니즈(Content needs)는 설명 및 관할권의 암시 (implication)에 따라 그러한 컨텐츠를 요청하는 노드에 CCF를 통해 채워지며, 상기 JICS(Jurisdictionally Implied CCF Submission) 모듈은 다른 노드의 컨텐트 전달에 대한 관할권적 인 니즈를 인지하는 BCHAIN 노드에 서 동작하며, CCF는 동반 CCR 없이 중간 노드를 통해 제출되며, 상기 CCF는 JACR(Jurisdictionally Accepted CCF Reception)에 의해 최종 타겟 노드에서 수신되고 유효화되고 이후 CCR에 의해 렌더링 된다 상기 전략 확증 시스템(SCS; Strategy Corroboration System)은 상기 TSC(Traffic Scope Consensus) 모듈을 사 용하여 이중 범위 해시 수집을 유도하고, 상기 이중 범위 해시의 상기 구성은 궁극적으로 NSS(Node Statistical Survey)에 의해 생성된 상기 네 가지 인덱스, 노드 이탈 인덱스, 노드 포화 인덱스, 노드 일관성 인덱스 및 노 드 오버랩 인덱스 에서 파생되며, 상기 변수들은 외부 트래픽 행동(External Traffic Behavior)으로부터의 NSS 에 의해 유도되고, 상기 해시 공고(Hash Announcements)들은 섹터들로 알려진 상이한 트래픽 영역들 사이에서 교환되고, 각 노드는 TSC(Traffic Scope Consensus)에서 실행되는 알고리즘으로 인해 두 개의 해시를 인지하고, 상기 이중 해시 인지 로직은 2 개의 노드가 서로 커뮤니케이션 할 수 있도록 상기 2 개의 해시 중 적어도 하나 가 매치할 것을 요구하며, TSC에서 사용되는 반내림 / 반올림 (rounding down / rounding up) 로직 으로 인해, 한 번에 단 하나의 해시가 변하기 때문에, 노드는 다른 노드와 컨센서스를 유지하면서 다른 네트워크 환경으로 이동할 수 있으며 따라서 상기 노드는 BCHAIN 프로토콜에서 주변 노드와 적어도 하나의 해시와 겹치는 것을 특 징으로 하는 시스템 노드 통계 조사(Node Statistical Survey, NSS)는 네 개의 주요 인덱스를 계산하기 위해 주변 노드의 행동에 관 한 정보를 모으고, 이는 BCHAIN 프로토콜의 핵심 기능을 운영하는 모듈에, 노드 활동 및 행동에 관한 상기 BCHAIN 네트워크의 상태에 관하여 알려주며, 노드 상호 작용 로직(NIL) 모듈은 커뮤니케이션 게이트웨이(CG)의 서브 세트로서 동작하고 운영 시스템 및 API 엔드포인트를 통해 하드웨어 인터페이스와 상호 작용하며, NSS의 인스턴스를 실행중인 노드의 바로 근처에 있는 노드와 관련된 모든 핑(Ping) 은 노드 핑 프로세싱(NPP; Node Ping Processing)으로 전달되며, 노드 활동 DB(NAD; Node Activity DB)는 노드 핑 활동(node ping activity)에 관한 미가공 데이터를 보유하는 로컬 데이터베이스이며, NAD는 NPP가 노드 인덱스 변수 모음의 인덱스 계산으로 이끄는 동작 쿼리를 수행하는 주요 정보 소스이며, 노드 핑 레코드는 처음에 인커밍 트래픽에서 수신되고, 각 노드 핑 레코드는 관련 노드에 관한 ID뿐만 아니라 만료 타임 스탬프(Expiration Timestamp)를 포함하며, 상기 타임 스탬프는 NSS가 상기 BCHAIN 네트워크의 로컬 부근의 현재 상태를 반영하는 최신 정보를 보고하도록 하며, 운영 질의(Operational Queries)는 상기 만료 타임 스탬프(Expiration Timestamp)를 고려하면서 노드 핑 레코 드(Node Ping Records)를 일괄로 처리하고, 상기 레코드는 인덱스 계산에서 4 개의 노드 인덱스 변수의 기준에 따라 최종적으로 계산된다 전략 확증 시스템(SCS; Strategy Corroboration System)과 관련하여 트래픽 범위 컨센서스(TSC; Traffic Scope Consensus)는 NSS 변수 및 정적 하드코딩 된 정책(SHP; Static Hardcoded Policy)의 정적 정의를 참조하여 이 중 범위 해시 세트를 생성하며, SCS는 SID(Sector Identity Derivation)를 호출하여 이중 범위 해시를 사용하 여 현재 섹터 식별 정보를 정의하는 기준으로 작용하며, 각 노드는 주어진 시간에 각각 해시 1 및 해시 2에 의 해 정의된 정확히 2 개의 섹터의 관할권 내에 존재하며, 해시 확증(Hash Corroboration)을 통해 주변의 이웃들 (Neighbors)로부터 공고된 해시가 로컬에서 생성된 해시에 대하여 체크되며, 상기 해시들 중 어느 것도 일치하 지 않으면, 상기 이웃 노드는 상기 노드 차단리스트에 추가되고, 일치하는 해시 공고로 인해 합법적으로 인지되 는 특정 노드 트래픽 인지 노드(Specific Node Traffic Perception Nodes)는 불량이거나 SHP(Static Hardcoded Policy)에 정의된 BCHAIN 프로토콜 제한을 넘어서는 것으로 의심되는 노드에 대해 다른 노드에 알린다. TSC는 NVP를 호출하여 노드 통계 조사(NSS; Node Statistical Survey) 변수를 수신하고 NSS 변수 합성 평균 (NVCI; NSS Variables Composite Average)을 생성하며, 동일한 섹터 내에서의 NVP 노드와 함께 서로에게 NSS 변수에 대한 인지(perception)를 공고하여 섹터 특성에 대한 컨센서스를 구축함으로서 로컬 및 원격 NSS 변수가 함께 모아져 NVCI라고하는 합성 평균(composite average)을 생성하며, NVCI는 이 섹터 의 범위와 정의에 대한 컨센서스를 유지하기 위해 사용되며, 따라서 물리적 경계가 있으며, 노드 이탈 인덱스의 상기 풀링된(pooled) 버전은 가장 가까운 배수 X로 반내림되고, 노드 포화 인텍스의 상기 풀링된(pooled) 버전은 가장 가까운 배수 X로 반내림되고, 노드 일관성 인덱스의 상기 풀링된(pooled) 버전은 가장 가까운 배수 X로 반내림 되고, 노드 오버랩 인덱스의 상기 풀링된(pooled) 버전은 스테이지(Stage)에서 가장 가까운 배수 X로 반내림 되고, 스테이 지(Stage) 내에서 생성된 모든 변수는 단일 변수로 병합된다퍼포먼스 요소(Performance Factors)는 NSS 변수 풀링(NVP; NSS Variable Pooling)에 의해 생성되고 또한 가장 가까운 배수 X로 반내림되며, 상기 퍼포먼스 요소는 관련 섹터 내의 상기 네트워크 트래픽에 관한 퍼포먼스의 측정치이며, 상기 반올림 단계에서 사용되는 상기 X 값은 전략 배포(Strategy Deployment)의 상기 트래픽 컨센 서스 라운딩 배수(Traffic Consensus Rounding Multiple)에서 비롯되며, 상기 전략 배포(Strategy Deploymen t)는 섹터 크로싱 이벤트 프로세싱(SCEP; Sector Crossing Event Processing)에 의해 처리되는 트레일 변수 묶 음(TVS; Trail Variable Suite)로부터 추출되며, 상기 배수는 각 섹터 내에서 상이 할 것으로 예상되나, 병합 결과가 이중 범위 해시의 해시 1에 대한 베이스가 되는 동일한 섹터 내의 모든 노드들에 대해 동일하게 유지되 며, 해시 2의 베이스에 대해 동일한 NVCI가 반내림 프로세스에서 참조되지만, 트래픽 컨센서스 라운딩 배수 (Traffic Consensus Rounding Multiple)에서 가져온 같은 X의 배수는 반올림하며, NVP의 동일한 퍼포먼스 요소 는 비록 반올림되지만 처리된다 동적 전략 적응(DSA; Dynamic Strategy Adaptation)은 상기 BCHAIN 네트워크 내의 처리 요소들을 제어하는 동 적 변수들을 생성하기 위한 상기 프레임워크로서 동작하며, 상기 변수들은 트레일 변수 묶음(TVS; Trail Variable Suite) 내에서 운반되는 전략 배포(Strategy Deployment)를 통해서 패키지 되고 전달(transferred)되 며 DSA는 필드 카오스 해석(FCI; Field Chaos Interpretation)을 통해 NSS 변수에 의해 보고된 물리적 네트워 크의 상태에 따라 네트워크 동작을 제어하는 변수를 지속적으로 유지 및 조정하며, FCI는 상기 전체 BCHAIN 네 트워크 도처의 노드 가용성 카오스(Node availability chaos)의 전반적인 레벨을 해석하며, 전략 배포(Strategy Deployment)는 상기 BCHAIN 프로토콜의 모듈들 내에 동작 값들을 설정하는 패키지된 기준의 세트이며, 최적화된 전략 선택 알고리즘(OSSA; Optimized Strategy Selection Algorithm)은 NSS에 의해 선언된 환경 조건 하에서 최상으로 작동하는 가장 적합하고 가장 이상적인 전략을 선택하며, 현재 선호 전략(Current Preferred Strategy)은 전략 창조 모듈(SCM; Strategic Creation Module)에 대한 입력으로 사용되어 실험을 통해 전략을 조정할 수 있으며, SCM은 상기 창의성 모듈을 사용하여, 현재 선호 전략의 형태와 FCI으로부터 필드 카오스의 현재 해석을 혼용한다. 우선순위 할당 및 증명(PAP; Priority Assignment and Proof)은 상기 UBEC 사용자가 지불한 추가 금액에 따라 확장 우선 순위와 함께 실행하기 위하여 상기 전략 배포 기준을 수정하며, 후속적으로 생성되는 전략 배포는 병 렬 홉 확산 기준(Parallel Hop Spread Criteria)에 대한 상대적으로 높은 값 및 병렬 홉 감소 기준(Parallel Hop Reduction Criteria) 에 대해 비교적 낮은 값을 포함하여 더 많은 병렬 홉 경로(Parallel Hop Paths)가 개 시되어 더 낮은 대기 시간, 낮은 패킷 손실, 높은 신뢰성으로 이어지며, 전략 배포는 CCR 또는 CCF의 트레일 변 수 묶음(TVS)에 패키지 되어 있으며, 전략 퍼포먼스 추적(SPT; Strategy Performance Tracking)은 OSSA가 지역 주변 네트워크 상황을 고려한 현재 우선 전략으로 고려되는 것을 선택할 수 있도록 하는, 상기 네트워크 내에서 배포된 전략의 인지된 퍼포먼스를 추적하는 데이터베이스 앱체인이다. 전략 퍼포먼스 추적(SPT)은 데이터 세그먼트 헤비 앱체인으로 작동하고, SPT는 전략 유닛을 저장하며, 각 전략 은 전략의 핵심 정체성 역할을 하는 기본 전략 기준 구성(base Strategy Criteria Composition)을 가지며, 상 기 전략 유닛 내의 다른 모든 변동은 OSSA가 현재의 우선 전략으로 간주하는 것을 선택할 수 있도록 하는 퍼포 먼스 및 시간의 논리적 측정으로 작용하며, 각각의 전략 유닛은 상기 전략에 대한 업데이트가 전략 퍼포먼스 해 석(SPI)에 의해 제공 될 때마다 연장되는 만료 타임스탬프(Expiration Timestamp)를 가지며, SPT에 의해 보고되 는 다수의 퍼포먼스 추적 유닛(Performance Tracking Units)이 각 전략과 관련되어 있으며, 추적 유닛은 NSS 구 성 및 퍼포먼스 인덱스(Performance Index)를 포함하며, 상기 NSS 구성은 이 추적 유닛이 포착(captured)된 시 점에 존재했던 상기 NSS 변수를 포착하고, 상기 퍼포먼스 인덱스는 초당 홉(hops), 메가 바이트(megabytes)를 포함하는 퍼포먼스 측정치를 기록한다. 전략 퍼포먼스 추적(SPT)은 다중 변수 선택 알고리즘(MVSA; Multiple Variable Selection Algorithm)에 간접적 으로 연결되고, MVSA는 SPT 내의 데이터로부터 가장 적절한 전략을 선택하고, SPT로부터의 데이터는 단일 전략 내에 나열된 모든 개별 퍼포먼스 인덱스의 합성 평균인 전략 퍼포먼스 인덱스(Strategy Performance Index)를 도출하는데 사용되며, 전략 신뢰 랭킹(Strategy Confidence Ranking)은 전략 퍼포먼스 인덱스에 대한 인지를 정 당화하기 위해 얼마나 많은 전례 / 증거가 이용 가능한지를 나타내며, MVSA는 적절한 전략을 선택하는 기준을 분별하기 위해 정적 하드코딩된 정책(SHC; Static Hardcoded Policy)을 참조하며, SPT로부터 만료되지 않은 모 든 전략들이 검색되고, 로컬 NSS 구성의 범위 내에 있는 모든 액티브 전략의 모든 NSS 구성이 검색되어 다양한 전략에서 선택된 퍼포먼스 추적 유닛을 포함하는 범위 내에서 NSS 구성을 생성하고, 상기 퍼포먼스 추적 유닛은 전략 기준 구성(Strategy Criteria Composition)에 따라 조직되며, 전략 컨테이너는 초기에 선택된 상기 퍼포먼 스 추적 유닛을 포함하는 선택된 전략을 포함하고, 상기 전략 컨테이너는 전략 당 평균 퍼포먼스 인덱스를 계산하도록 참조되어 전략 퍼포먼스 인덱스로 출력되며 전략 신뢰도 순위가 전략 당 계산되며, 바람직한 전략은 MVSA를 통한 퍼포먼스 및 평가 신뢰도에 따라 선택된다. 전략 생성 모듈(SCM)은 동적 전략 적응(DSA)에 의해 호출되며, SCM은 창의성(creativity) 모듈을 통해 전략 구 성을 지능적으로 변화시켜 사전 반복의 강점을 바탕으로 저위험 실험 전략을 창출하며, 필드 카오스 해석(FCI; Field Chaos Interpretation)은 카오스 해석 출력을 입력 양식으로 창의성에 제출하고, 창의성의 정적 기준은 동의된 전략 범위 제한 및 경제 인증 토큰(EAT; Economic Authorization Token)에서 사전 승인된 와트 유닛 금 액을 기반으로 하며, 상기 현재 선호 전략은 OSSA에 의해 수신되고 상기 전략 기준 구성을 검색하기 위해 언팩 (unpacked) 된다 전략 기준 구성을 구성하는 기준은, a) 잠재적으로 쓸모없는 병렬 홉 경로(Parallel Hop Paths)를 제거하도록, 최근의 홉 히스토리(RHH, Recent Hop History)에서 무시되어야 하는 홉 위트니스 진입(Hop Witness Entry)에 얼마나 많은 시간이 소요되는지 나타내는 홉 위트니스 만료(Hop Witness Expiration). b) 병렬 홉이 얼마나 넓 게 확산 되어야 하는지, 그리고 변수 값을 무엇이 트리거 하는지를 나타내는 병렬 홉 확산 기준(Parallel Hop Spread Criteria) c) 중복으로 인해 병렬 홉 경로를 제거해야 하는 시기를 나타내는 병렬 홉 축소 기준 (Parallel Hop Reduction Criteria). d) 최신 홉 히스토리(RHH)에서 이 노드가 최근 앱체인을 목격한 최소 발 생 횟수인 것인, 캐시에 필요한 컨텐츠 포화(Content Saturation Requried for Cache) e) 중간 지점 이후의 여 정에 참여하는 노드만 컨텐츠를 캐시 할 수 있도록 하는, 노드가 컨텐츠를 캐시하기 위해 완료 되어야 하는 최 소 진행 정도인, 캐시에 요구되는 최소 홉 이동(Minimum Hop Travel Required to Cache) f) 노드가 메타체인에 앱체인 요구(Appchain Demand) 및 섹터 요구(Sector Demand)를 선언하는, CCR 또는 CCF 여정 중에 있는 합 포 인트(hop point)이며, 앱체인 요구는 앱체인 캐싱 및 위치를 결정하기 위해 추적되고 섹터 요구는 다른 분야의 다른 가격을 계산하기 위해 추적되는 것인 요구 선언 합 포인트(Demand Declaration Hop Point) g) 홉 경로 (Hop Pathway)에 포함될 노드에 대한 상기 NSS 변수에 의해 판정된 노드의 최소 신뢰도 수준인, 경로 배포를 위 한 최소 노드 신뢰도(Minimum Node Reliability for Path Deployment) h) 앱체인을 채굴하는 데 필요한 관련 컴퓨팅 리소스의 최소량이며, 이 양은 그 앱체인의 채굴 리소스 양에 비례하는 것인, 자체 부과된 채굴 기준 (Self Imposed Mining Criteria) i) NSS에서 제공하는 변수에 의해 이해되는 것처럼 산발적이고 신뢰할 수 없 다는 것을 나타내는 노드의 특성을 정의하는, 카오스 환경 회피 기준(Chaotic Environment Avoidance Criteria) j) PNCC(Primary Node Content Cache)에 존재하지 않는 CCF를 보유하도록 할당 되어야 하는 로컬 노 드 스토리지(storage)의 백분율을 정의하는, 충돌 캐시에서 보유되어야 하는 CCFs(CCFs to Retain in Clash Cash) k) 선택된 노드의 신뢰도와 예상되는 이동 거리 사이의 트레이드 오프 선택에 관한 인지된 효율성 영역을 정의하는 경로 신뢰도 / 거리 트레이드 오프(Route Reliability/Distance Tradeoff) l) 앱체인을 마이크로체인 포맷으로 전환하기 위해 노드 투표를 수행하는 데 필요한 정보 전송 격리 인덱스(ITII; Information Transfer Isolation Index)의 값을 정의하는 ITII 마이크로체인 트리거.(ITII Mircrochain Trigger) m) NVCI 및 퍼포먼 스 변수가 위 또는 아래로 반올림되는 것의 배수로, 이 값이 증가하면 이 변수의 영향을 받는 섹터의 상대적 크 기가 점차적으로 증가하고 이 값이 감소하면, 섹터의 크기와 노드 수는 줄어드는 것인, 트래픽 컨센서스 반올림 배수(Traffic Consensus Rounding Multiple) n) 노드가 인지하는 NSS 변수와 겹치는 섹터 내에서 노드가 서로 얼마나 자주 공고(announce) 해야하는지 정의하는 NSS 변수 풀링 간격(NSS Variable Pooling Interval) o) 최 저 및 최고 지불 섹터 간의 지급 불일치 강도를 규정하는 작업 배당 배수(Work Payout Multiplier), p) 채택하 기로 선택한 캐시를 보유하는 데 캐싱 노드가 필요한 최소 시간을 정의하는 것인 최소 캐시 보유 시간(Minimum Cache Retention Time) q) 마이닝 선택 알고리즘(MSA; Mining Selection Algorithm)을 통한 수동 작업과 캐시 선택 알고리즘(CSA; Cache Selection Algorithm)을 통한 수동 작업간에 지불 분할을 할당하는 것인, 마이닝 대 캐시 지불 비율(Mining to Caching Payment Ratio) r) 데이터 도피처 처리(DRP; Data Refuge Processing)를 통 해 데이터를 복구하는 한 섹터의 채굴자가 위험에 처한 데이터를 삭제하는 것이 언제 안전한지를 정의하는, 캐 시 부분 삭제 임계 값(Cache Part Deletion Threshold) s) 관련 섹터의 노드에 부과 될 세금 결과 유닛(Tax Consequence Unit)의 가치 크기에 대한 배율(multiplier)로 작용하는 섹터 세금 규모(Sector Tax Magnitude)를 포함한다 SCM의 모듈식 입력 및 출력 처리는 현재 선호 전략을 초기 입력으로 시작하고, 전략은 부모 모듈 SCM에 의한 조 작 및 처리를 가능하게 하기 위해 중간 포맷으로 추출되어 전략 기준 구성이 입력 현재 선호 전략으로부터 생성 되고, 로직은 상기 전략의 새로운 저위험 실험버전으로 상기 전략 기준 구성(Strategy Criteria Composition)을 업데이트 하고, 이는 상기 전략 배포(Strategy Deployment)의 출력이 되며, 상기 업데이트 프로세스가 완료되면, 상기 SSA(Strategy Syntax Assembly) 모듈은 상기 정보를 상기 BCHAIN 프로토콜을 작동시키는 다른모듈에서 이해할 수 있는 포맷으로 리팩(repack)한다. 상기 창의성 모듈은 상기 로컬 BCHAIN 네트워크 환경의 상기 상태를 반영하는 상기 NSS 변수를 고려하여 상기 전략 기준 구성(Strategy Criteria Composition)을 업데이트하는 데 사용되며, 창의성에는 동적 전략 생성 및 변형(variation)을 관리하기 위한 사전 정의된 템플릿인 전략 생성(Strategy Creation)에서 현재 선택된 기준의 모드가 주어지며, 창의성은 두 가지 입력, 즉 A 형식(Form A)과 B 형식(Form B)을 처리하며, 상기 전략 기준 구 성(Strategy Criteria Composition)의 모든 단일 기준은 개별 프로세스를 위해 선택되는데 A 형식은 창의성이고, B 형식은 필드 카오스 해석(Field Chaos Interpretation, FCI)으로부터의 필드 카오스의 전반적인 해석이며, 창의성 처리가 완료되면 출력 양식 AB가 기준의 새로운 제안된 변형(variation)으로 생성된다 상기 UBEC 사용자는 사용자 노드 상호 작용(UNI)에서 수행된 생체 인지를 통해 상기 UBEC 플랫폼에 액세스하며, 이에 의해 상기 연관 노드 리스트가 추출되는 인증된 사용자 세션이 생성되고, 상기 인증된 사용자 세션은 또한 프런트-엔드 사용자 인터페이스에 액세스하여 경제적 특성 선택으로 이끄는 데 사용되며, 상기 UBEC 사용자는 상기 BCHAIN 프로토콜의 계산 및 네트워크 리소스 가용성에 의해 참조되는 경제적 특성을 선택하고, CNRA는 상 기 연관 노드 리스트(Associated Nodes List)를 통해 상기 UBEC 사용자와 연관된 노드의 모든 잉여 가용 리소스 를 측정하는 방법론으로 상기 UBEC 플랫폼에서 상기 경제적 특성 선택을 참조하며, CNRA는 상기 경제 인센티브 선택(EIS; Economic Incentive Selection) 모듈에 대한 참조를 허용하며, EIS는 노드가 다른 노드 작업 또는 DLS(Diagnostic Log Submission)의 작업 세션을 수행 할 것을 권장하며, 노드상의 EIS의 로컬 실행은 노드가 DLS의 실행을 통해 자기 부과된 진단 노드(self-imposed Diagnostic Node)가 되도록 트리거하고, 상기 노드는 자신을 상기 메타체인의 진단 노드 위치에 대한 진단 노드로 선언하고, 상기 단계의 실행으로부터의 상기 노드 의 상기 초기 선언 상태 때문에, 다른 노드가 선언된 기능을 수행하고 있음을 확증할 수 있을 때까지 상기 노드 는 미확인으로 표시되고, 상기 메타체인의 상기 진단 노드 위치에 대한 업데이트가 커스텀체인 인터페이스 모듈 (CIM; Customchain Interface Module)로 전송되어 상기 실제 메타체인에 채굴되고 커밋(committed)된다 상기 메타체인에서 진단 노드가 된다는 상기 노드의 선언으로 인해, 동일한 섹터 내의 다른 노드가 JICS(Jurisdictionally Implied CCF Submission) 및 JACR(Jurisdictionally Accepted CCF Reception)을 통해 진단 로그를 보내고, 상기 진단 로그는 상기 자체 선언된 진단 노드에 의해 신빙성을 위해 유효화되고, 공식 시 스템 토큰으로 태그된 로그 유닛은 SID(SPSI Indirect Development)에 제출되며, 공식 시스템 토큰(Official System Token)은 상기 로그 유닛이 공식 앱 체인에서 유래하는 것에 대한 암호 증명이며, 앱체인은 상기 UBEC 플랫폼에 핵심 기능을 제공하는 경우 공식(Official)으로 태그된다 동일한 섹터의 다른 BCHAIN 노드는 상기 진단 로그 제출(DLS)을 통해 상기 관련 위치에 제출될 관련 로그를 record 하도록 진단 로그 수집(DLC) 모듈을 처리하고, DLC로부터의 상기 로그는 상기 자체 선언된 진단 노드상 에서 DLS를 호출한 JACR의 인스턴스에 CCR을 수반하지 않고 CCF를 제출하는 JICS로 전달되며, 상기 메타체인의 진단 노드 위치에 진단 노드라는 상기 노드의 선언을 이유로, 상기 선출된 관할권으로 인해 JICS가 보낸 상기 CCF 패킷을 받아들여야 하며, LIZARD는 CCR의 수반 없이 CCF 패킷을 모니터하고 정당화함으로써 LIZARD의 관할 추적 기술이 상기 BCHAIN 네트워크 트래픽의 최하위 레이어에서 구현된다 EIS(Economic Incentive Selection) 및 WPCP(Work Payment Claim Processing)에서 EIS는 상기 BCHAIN 네트워 크를 위한 공급 / 수요 중재 메커니즘으로 작용하며, 액티브 노드 작업을 찾는 노드는 EIS를 호출하여 노드에게 투자 대비 가장 좋은 수익을 얻어줄 수 있는 최상의 가능한 작업 유형을 선택하며, 상기 메타체인에 관한 로컬 및 원격 변수를 분석하여 현재의 공급 수요 동향을 파악하고, 공급 수요 중재(SDA; Supply Demand Arbitration) 모듈이 호출되고, SDA는 상기 메타체인을 참조하여 상기 BCHAIN 네트워크 내의 공급 / 수요 벡터의 논리적 표현 을 생성하고, SDA는 상기 계산 결과를 나타내기 위해 공급 수요 구성(Supply Demand Makeup)을 제출하고, 리소 스 가용성은 계산 및 네트워크 리소스 가용성(CNRA; Computation and Network Resource Availability)를 호출 함으로써 체크되며, 경제적 특성 지정은 상기 UBEC 플랫폼 인터페이스(UPI) 내에서 디자인되며, 리소스가 이용 가능하지 않은 경우, EIS의 동작이 종료되고, 리소스가 이용 가능한 경우, EIS는, 수요 공급 구성 및 노드 리소 스의 이용 가능성을 참조하여 적절한 수익성 있는 작업을 선택하는 노드 작업 선택(NJS; Node Job Selection)을 호출한다. 경제적 인센티브 선택(EIS; Economic Incentive Selection)과 작업 지불 클레임 프로세싱(WPCP; Work Payment Claim Processing) 사이의 전환에서, 액티브 또는 패시브 작업이 완료되면, 상기 메타체인의 상기 와트 경제에 대한 지불을 확인하고 처리하는 WPCP에 대하여 수익 청구가 이루어지며, 패시브 노드 작업(Passive Node Work) 은 상기 네트워크의 필요로 인해 상기 BCHAIN 프로토콜에 의해 연루되며, 액티브 노드 작업은 그 소유자인 상기UBEC 사용자를 대신하여 상기 노드의 이기적 동기들로부터 행해지는 한편, 선택된 경제적 특성에 따르며, EIS는 노드 작업 선택을 통해 액티브 노드 작업만을 호출하고, 패시브 노드 작업은 상기 프로토콜의 준수로 인해 연루 되며, 노드의 패시브 또는 액티브 작업의 완료에 의해 WPCP가 호출된 경우; 상기 검증된 작업 지불(Validated Work Payment)은 상기 메타체인의 미결 미검증 작업 지불(Pending Yet Validated Work Payments)에 제출되며, WPCP가 해결된 신규 블록 공고(Solved New Block Announcement)에 의해 호출된 경우, 미결 지불(Pending Payments)은 상기 와트 경제에 제출되고, 해결된 블록 공고(Solved Work New Block Announcement)를 통한 WPCP 의 모듈 식 호출 시, 상기 새로 해결된 블록(newly solved block)과 연관된 상기 앱체인으로부터 미결 미검증 작업 지불(Pending Yet Validated Work Payments)가 검색되어 미결 지불(Pending Payments)이 출력으로 생성된 다 UBMA 프로세서에서, 2 개의 전압 레귤레이터는 상기 UBMA 프로세서의 2 개의 개별 서브섹션으로 연결되는 전압 입력을 제어하고, 2 개의 분리된 전압이 병렬로 조정될 수 있고, 이는 상기 BCHAIN 프로토콜로부터 수신된 신호 에 따라 리소스의 동적인 우선 순위를 유도하며, BCHAIN 노드들이 라디오를 통해 서로 커뮤니케이션 할 수 있도 록 하기 위해, 각 노드는 종종 자신의 아이덴티티(Indentity), 해시 공고(Hash Announcement) 및 개인 주파수를 브로드캐스트 하는 몇 개의 밋업(meet up) 주파수를 가지며, 그 후에 두 개의 노드가 피어 투 피어 커뮤니케이 션 채널(peer-to-peer communication channel)을 구축(establish)하기 위해 서로의 개인 주파수에서 만나 정보 를 교환 할 수 있고, 무선은 모두 충돌 및 간섭을 피하기 위해 상이한 주파수로 동작하고, 단거리, 중거리 및 장거리 커뮤니케이션으로 다양화되며, 상기 BCHAIN 프로토콜은 희소성(scarcity) 상황에서 전송되어야 하는 정 보의 우선 순위를 정하고, I / O 관리는 실행 세그먼트 및 일반 처리 명령을 인지하여 이를 올바른 마이크로 칩 에 할당(assign)하고 데이터를 나머지 노드로 반환한다. 서브섹션 A의 구조에서 앱체인 로지스틱스 마이크로칩은 상기 BCHAIN 네트워크 내의 앱체인 및 마이크로체인의 보존 및 실행을 처리 할 수 있으며, 마이크로 칩으로서의 LIZARD는 작동을 위해 데이터베이스에 의존하지 않고 대신 복잡한 사전 지식(사전 참조 없음)으로 인해 순간의 위험 및 순응도의 측정을 즉시 판단하고 추정하며, 상 기 UBMA 프로세서는 동적 전도성 구조를 통해 동적으로 자신의 마이크로 프로세서 어셈블리를 변경할 수 있으며, 라우팅 로직 마이크로칩은 라우팅 로직(RL)의 에너지 효율을 높이고 대기 시간을 낮추며, AC(Assertion Construction) 및 HM(Hierarchical Mapping)을 포함하는 가장 반복적으로 사용되는 LOM의 서브 모듈은 LOM 핵 심 로직에서 마이크로 칩으로서 최적화 됨으로써, LOM의 실행 스트림의 전체 모듈 표현(manifestation)이 효율 적으로 실행되고, 마이크로 칩으로서의 창의성 모듈은 상기 UBEC 플랫폼 내에서 상기 창의성 모듈의 상기 실행 을 최적화하여, I2GE, CTMP, MPG, SPSI를 포함한 창의성에 의존하는 많은 앱체인으로 인해 상기 UBEC 플랫폼 및 BCHAIN 네트워크 전체에서 계산 효율성을 높이는 것을 특징으로 하는 시스템 상기 UBMA 프로세서의 서브섹션 B에서, 상기 CGPU(Cryptographic Processing Unit)는 상기 BCHAIN 프로토콜 전 체에서 호출되는 CC(Cryptographic Core) 내에서 작동하는 기능을 실행하며, 상기 보안 하드웨어 자격 발생부 (SHCG; Secure Hardware Certificate Generating Unit)는 상기 메타체인의 상기 와트 경제 내에서 노드의 자금 을 조작하는 데 사용되는 보안에 민감한 고유 개인키(Security Sensitive Unique Private Key)를 안전하게 유 지하므로 노드 생성 공공 주소(Node Generated Public Address)가 SHCG에 의해 보안에 민감한 고유 개인키가 노출될 책임 및 위험 없이 효율적이고 신속하게 생성될 수 있으며, 상기 와트 경제의 와트 유닛을 상기 UBMA 프 로세서를 통해 노드의 물리적 하드웨어와 강제로 결합함으로써, 와트 유닛의 관리 및 조작이 상기 UBEC 플랫폼 및 BCHAIN 네트워크 내에서 보다 예측 가능하고 안전해지며, 상기 SHCGU 마이크로칩은 상기 UBMA 프로세서의 제 조시에 무작위로 생성된 하드코딩 된 노드 고유 식별 문자열(hardcoded Node Unique Identification string)을 포함한다. SHCGU에서, PIAH(Permanent Identity Association with Hardware)는 제조시에 정의된 노드 고유 식별 정보를 생성하며, 하드웨어 잠금 개인 키(HLPK; Hardware Locked Private Key)와 함께, 보안에 민감한 고유 개인 키 (Security Sensitive Unique Private Key)는 하드웨어 잠금 레이어(Hardware Lock Layer) 뒤에서 영구적으로 관찰되며, 의도적으로 하드웨어 잠금 레이어를 떠나는 개인 키의 복사본에 대한 유일한 예외는 LUIGI에 제출을 위한 익스클루시브 백도어 채널(Exclusive Backdoor Channel)을 통해서 이며, 공공 주소 생성(PAG; Public Address Generation)은 상기 개인 키의 어느 인스턴스도 하드웨어 잠금 레이어 외부로 전송하지 않고, 상기 개 인 키에서 파생된 공용 주소를 생성하는 상기 서브섹션이다 자금 복구 메커니즘(FRM; Fund Recovery Mechanism)에서, 상기 UBEC 사용자는 인증된 사용자 세션 (Authenticated User Session)을 생성하는 사용자 노드 상호작용(UNI; User Node Interaction)을 통해 스스로 를 인증하며, 손실된 자금을 복구하는 상기 프로세스의 개시는 상기 UBEC 프론트엔드를 통해 상기 UBEC 사용자에 의해 호출되고, 상기 연관 노드리스트(Associated Nodes List)는 상기 인증된 사용자 세션으로부터 언팩 (unpacked)되며, 자금 복구 검증 세션(Fund Recovery Verification Session)은 상기 UBEC 프론트엔드를 통해 상기 UBEC 사용자와 함께 개시되고, 상기 자금 복구 검증(FRV; Fund Recovery Verification) 모듈은 상기 자금 복구 검증 세션을 관리한다. 상기 자금 복구 메커니즘(FRM; Fund Recovery Mechanism)과 LUIGI 간의 상호작용에서, FRM은 LUIGI의 상기 관 할권 내에 속하는 서브모듈이며, 상기 보유 해독 키(Retention Decryption Key)는 LSE(LUIGI Secure Enclave) 로부터 액세스되고, 상기 보유 해독 키는 자금 조작 메커니즘(FMM; Fund Manipulation Mechanism)을 통해 상기 메타체인의 상기 와트 경제에서 자금을 조종하는 데 사용되는 상기 보안에 민감한 고유 개인키를 해독하고 액세 스하는 데 사용되며, LUIGI는 상기 개인키의 암호화된 보유(Encrypted Retention)에 있는 상기 개인키의 중복 사본으로 인해 상기 와트 경제에 저장된 상기 전체 UBEC / BCHAIN 경제에 액세스 할 수 있다 LUIGI는 인간에 의해 처음 한 번 직접 프로그래밍 되고, 일단 상기 UBEC 플랫폼과 BCHAIN 네트워크가 처음으로 기능 및 작동하게 되면 LUIGI의 코드베이스를 수정하기 위한 모든 암호화 액세스가 SPSI(Self Programming Self Innovation)에 의해 독점적으로 유지되며, SPSI는 LIZARD 기술을 사용하여 상기 UBEC 플랫폼 내에서 다른 앱체 인을 프로그래밍하는 앱체인이며, SPSI에 의한 프로그래밍은 세부조정, 버그 / 오류 수정, 예정된 유지 보수, 진단 로그 유닛 분석, 새로운 특징 혁신을 포함하며, SPSI는 스스로 프로그래밍 할 수 있지만 SID(SPSI Indirect Development)로부터 프로그래밍 가이드의 요소를 수신한다. SPSI는 상기 영구적인 BCHAIN 프로토콜에 따라, UBEC 어플리케이션, LUIGI, 창의성, I2GE, SPSI, LOM, LIZARD, CTMP, MPG, MC 및 I2CM을 포함하는 상기 UBEC 플랫폼의 모든 주요 기능의 코드베이스를 조작하기 위한 독점적인 액세스 권한이 부여되며, LOM은 자동 리서치 메커니즘(ARM)에서 진단 로그 유닛을 수신하고, LOM은 현재 존재하 는 기능(Currently Existing Features)으로 일상적인 오작동을 특징 지우고 이해하며 상기 수신된 로그 유닛에 대해 솔루션을 제안하며, 현재 존재하는 기능은 프로그래밍 / 세부조정 / 혁신을 타겟으로 한 상기 선택된 앱체 인의 기능이며, 제안된 솔루션은 기존 기능 오작동(Existing Feature Malfunctions)에 출력되며, LOM은 상기 선택된 앱체인을 검사하고, 주요 기능을 수행 할 때 상기 앱체인의 능력과 효율성을 향상시킬 것으로 기대되는 제안된 새로운 기능을 평가하며, 상기 제안된 기능 및 제안된 솔루션은 목적에 정의되고, 목적(Purpose) 및 구 문(Syntax) 모듈을 통해 기능 코드로 프로그래밍되도록 LIZARD로 전송된다 LIZARD는 본래 LOM로부터 나온 아이디어를 나타내는 실행 코드 세트(Executable Code Sets)를 출력하고, 상기 실행 가능한 코드 세트는 LIZARD로부터의 성공적인 실행 및 실패 실행 시나리오와 함께 I2GE로 전송되며, I2GE 는 상기 BCHAIN 네트워크에 의해 사용 가능해진 상기 CPU 및 스토리지 리소스를 사용하여 창조성을 통해 상기 소프트웨어를 여러 진화 경로로 개발 및 조정하며, 성공 및 실패 실행 시나리오를 참조하여 I2GE는 궁극적으로 안정적이고 기능적인 코드 세트의 변형과 그렇지 않은 것을 구별 할 수 있으며, LOM은 상기 결과적인 소프트웨 어가 안정성에 대한 인지와 기능을 달성하는 수단에 부합 함을 확인한다. SRIA(Symbiotic Recursive Intelligence Advancement)는 SPSI(Self Programming Self Innovation) 동작에 주 로 나타나는 인공 지능 알고리즘이며, SRIA는 LIZARD, I2GE 및 SPSI와 관련이 있고, LIZARD는 코드 목적을 이해 하여 알고리즘의 소스 코드를 향상시키고, I2GE는 가상 프로그램 반복 생성을 에뮬레이션하므로 가장 강력한 프 로그램 버전을 선택하고, BCHAIN은 분산된 방식으로 앱체인들을 실행할 수 있는 방대한 무질서하게 연결된 노드 들의 방대한 네트워크이며, SPSI는 기능과 퍼포먼스를 부여하는 동일한 앱체인을 유지 관리하며, 피드백 루프 기반 시스템의 레이아웃은 인공지능 인지 및 문제 해결 능력의 진행이 점진적인 증가하도록 보장하며, 가상 에 뮬레이션은 I2GE가 상기 BCHAIN 네트워크에 의해 호스팅 되는 가상 환경에서 상기 타겟 앱체인의 상기 코드를 실행할 때이며, BCHAIN은 I2GE, LIZARD, LOM, CTMP, NC 및 I2CM을 위한 호스팅 리소스 공급자 역할을 한다. 현재 상황(Status Quo)은 타겟 시스템의 전반적인 기능, 효율 및 디자인을 총체적으로 나타내며, LOM은 DPIP(Design Principle Invocation Prompt)에 의해 호출되어 시스템 디자인 원칙을 생성하며, 상기 디자인 원 칙에 대한 세부조정은, 관련 데이터를 시스템 수정을 정확하게 수행하기 위한 중대한 중간 단계 역할을 하는 목 적 포맷으로 변환하는 LIZARD에 의해 가능하며, LIZARD는 프로그래밍 능력을 상기 리파인 된 현재 상황(Refined Status Quo)에 대한 실험적인 수정을 수행하는데 사용하며, 상기 새로운 현재 상황(Status Quo)는 I2GE에 의해 가상화되고 진화되어, 지능형 사이클이 재설정되고 관련 앱체인 알고리즘이 새로운 정보, 기능 및 기술을 발견 할 때 다음 주기의 잠재력이 증가한다. 지능 풀링(Intelligence Pooling)과 관련하여 CTMP는 알고리즘의 지능을 점차적으로 빼앗기 때문에 지능 보존 (intelligence retention)의 중심 위치로 작용하며, CTMP는 LIZARD, LOM 및 I2GE를 포함하여 앱체인 알고리즘에 의해 만들어진 모든 인공 기반 결정(artificially based decisions)을 해석하고, 결정에 관한 객관적 사실로 작용하는 미가공 처리 로그(raw processing logs)를 수신하며, 이로 인해 여러 앱체인 알고리즘의 총체적 지능 이 CTMP에 의해 재활용되고 수집 / 풀링된 지능은 결국 CTMP와 상호 작용하는 모든 앱체인 알고리즘에 이익을 준다. 하드웨어, 프레임워크 및 기능 피드백 및 영향과 관련하여, 이상적인 시스템 디자인이 ATSG(Abstract Target System Generator)에서 생성되고, 요구된 사용자 기능은 새로운 사용자 기능의 정의와 관련이 있으며 새로운 사 용자 기능의 정의에 알리고, 기능의 구문은 어플리케이션 기능에 의해 상속되며, 이는 결국 새로운 사용자 기능 을 위한 동작 가능(Operation Enablement)의 레이어가 되며, 어플리케이션 기능 향상은 SPSI의 서브모듈인 신규 앱체인 개발(NAD; New Appchain Development)에서 나타나며, 로지스틱스 레이어 텐션의 핵심 관행은 코드 효율 성, 품질, 보안 및 안정성 향상이며, 프로세스는 SPSI에 의해 그 서브모듈인 ASH(Appchain Security Hardening), IEC(Intate Error Correction), A2R(Automated Appchain Refinement), A2M(Automated Appchain Maintenance), ARC(Appchain Regulatory Compliance) 및 진단 로그 유닛 분석(DLUA; Diagnostic Log Unit Analysis)를 통해서 진행되며, 향상된 코드 품질은 어플리케이션 기능의 동작을 가능하게 하고, 이는 결국 새로 운 사용자 기능을 가능하게 하며, 상기 소프트웨어의 상기 양상들은 프레임워크 적응(Adaption)에 의해 가능해 지고, 상기 적응(Adaption)은 사용자 공간 어플리케이션이 작동하도록 허용하는 기본(underlying) 프레임워크에 수행된 변경을 나타내며, 상기 프레임워크 적응은 실질적으로 SPSI의 EFD(Enhanced Framework Development)에 의해 수행되며, 이에 따라 하드웨어 변경이 상속된 프레임워크 구문에 따라 수행되고, 이에 따라 프레임워크와 해당 사용자 공간이 작동할 수 있게 된다 상기 UBEC 사용자의 다단계 사이클에 걸친 상호 작용으로부터의 지능의 흐름(trickling)과 관련하여, 장기 사이 클은 SPSI 방향의 대규모 지침 원칙을 나타내며, SPSI의 기능, 방법론 및 경향에 대한 정보가 LOM 및 SID(SPSI Indirect Development)의 인간 상호 작용을 통해 느리고 장기적으로 점차적으로 제공되며, LOM은 CTMP의 내장된 모듈식 호출로 가능해지는 객관적인 추론으로 인해 SPSI의 기능성 및 작동 구성을 합리적으로 이끌어내는 역할 을 하며, 장기 사이클에서 LOM 및 SID를 통해 발생하는 변화는 결국 SPSI의 실질적인 지속 작동을 나타내는 중 간기간 사이클에 영향을 미치고 정보를 제공하며, SPSI의 서브모듈들은 SPSI 방향(Direction)의 지침 원칙에 의 해 서서히 영향을 받으며, 중간기간 사이클 내의 SPSI의 동작은 상기 UBEC 플랫폼 / BCHAIN 네트워크의 앱체인 뿐만 아니라 앱체인 에뮬레이션 레이어(AEL)를 통해 레거시 시스템 내에서 동작하는 앱체인 / 레거시 프로그램 의 일반적인 향상으로 이어지며, 지능의 단기 적응 사이클은 SPSI에 의해 향상되어 단기간에 배포됨으로써 정교 한 적응 전략을 가능하게 하는 이다. SPSI (Self Programming Self Innovation) 내에서 자동 앱체인 세부조정(A2R; Automated Appchain Refinemen t)이 앱체인 또는 레거시 프로그램을 검사하며, 자동화 앱체인 유지보수(A2M; Automated Appchain Maintenance)는, 만료된 캐시 삭제, 감가 상각 기능을 사용 가능한 기능으로 업그레이드(upgrading Depreciated Functions to Usable Functions), 감가 상각된 모듈 및 종속성을 사용 가능한 모듈로 업그레이드 (upgrading Depreciated Modules and Dependencies with usable Modules), 만료된 참조점 삭제(deleting Expired Points of Reference) 및 경제적 안정성 교정 수행(performing Economical Stability Calibration)에 의하여 상기 선택된 앱체인 또는 레거시 프로그램을 유지 보수하며, 앱체인 보안 하드닝(ASH; Appchain Security Hardening)은 앱체인 또는 레거시 프로그램(Legacy Program)에서 침입 및 악용 지점을 자동으로 검사 하며, ARC(Appchain Regulatory Compliance)는 상기 선택된 앱체인 또는 레거시 프로그램이 다양하고 구체적인 규정을 준수하도록 보장하며, 상기 진단 로그 유닛 분석(DLUA)은 오작동 루틴으로부터 진단 로그 유닛(DLU)을 수신하고 그러한 인지된 오작동을 수정하기 위해 시도하는 적절한 조항을 시행하며, IEC(Innate Error Correction)는 정지된 루틴으로 이어질 수 있는 근본적인 절차 결함을 수정하려고 시도하며, NAD(New Appchain Development)는 생태계에 인지할 수 있는 이익을 줄 수 있을 잠재된 어플리케이션 기능이 누락된 특정 어플리케 이션 생태계 내에서 어플리케이션에 대한 사용을 찾으며, EFD(Enhanced Framework Development)는 상기 UBEC 플랫폼 / BCHAIN 네트워크 및 레거시 시스템 모두에 대한 기존 소프트웨어 프레임워크를 검사하고 잠재적으로 개선하며, EHD(Enhanced Hardware Development)는 DLCB(Dynamic Liquid Conductive Boards)를 포함하고 따라서 핵심 하드웨어 구조를 최적화하고 업그레이드 할 수 있는 물리적 시스템을 수정하며, ATM(Appchain Targeting Mechanism)은 처리 시 어떤 앱체인을 선택해야 하는지 다른 모듈에 알리는 지능형 선택 알고리즘을 처리한다. LIZARD는 ATM에 의해 선택된 상기 타겟 앱체인의 상기 실행 스트림(Execution Stream)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하도록 동작하고, ESC(Execution Stream Collection)에 의해 생성된 타겟 앱체인의 상 기 실행 스트림(Execution Stream)이 상기 구문 모듈(SM; Syntax Module)에 제출되고, 코드 기록을 위해, SM은상기 목적 모듈(PM; Purpose Module)로부터 복합 목적 형식(Complex Purpose Format)을 수신하고, 코드 판독을 위해, SM은 PM에 대한 컴퓨터 코드의 구문 해석을 제공하여 그러한 코드의 기능을 위한 목적을 도출하고, 상기 타겟 앱체인은 코드 번역(Code Translation)에 의해 이행된 실행 스트림(Fulfilled Execution Stream) 형식으 로 수신되고, 코드 번역은 SM에 의해 인지되고 이해되는 임의의(일반적인) 코드를 선택된 계산 언어로 변환하고, 코드 번역은 알려진 계산 언어를 임의의 구문 유형으로 번역하는 역함수를 수행하며, 코드 번역의 완 료된 실행의 출력은 논리 감소(Logical Reduction)에 입력으로서 전달되고, 논리 감소는 코드 논리를 단순한 형 식으로 감소시켜 규칙 및 구문의 정의에 따라 상호 연결된 함수의 맵을 생성하고, 논리 감소의 실행 완료 시 대 응하는 SM 인스턴스의 실행이 완료되고 SM의 모듈식 출력은 PM의 반복 해석(Iterative Interpretation)으로 보 내지고, PM은 컴퓨터 코드로부터 복합 목적 형식(Complex Purpose Format)의 목적을 도출하기 위해 SM을 사용하 며, 반복 해석은 목적 연관성(Purpose Associations)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 구문 모듈(SM)의 논리 감소는 PM의 반복 해석에 출력을 제출하며, 반복 해석은 목적 연관성을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하며, 상기 목적 정의 출력은 PM을 위한 모듈식 출력 으로서 제출된 복합 목적 형식에 존재하며, 상기 출력은 상기 타겟 앱체인의 상기 복합 목적 형식 버전으로 제 시되는 목적 계층 맵으로 라벨링 된다. 코드 디자인 원칙은 외부 핵심(OC; Outer Core)의 관할권에 속한 SM에게 제출되며, SM은 컴퓨터 코드를 판독하 고 기록하기 위한 프레임워크를 제공하며, 코드 기록을 위해 SM은 PM으로부터 복합 목적 형식을 수신하고, 상기 복합 목적 형식이 의사코드(pseudocode)로 기록되며, 헬퍼 기능은 상기 의사코드를 원하는 타겟 계산 구문에 따라 실제 실행 가능한 코드로 변환하고, 코드 판독을 위해; SM은 그러한 코드의 기능에 대한 목적을 도출하기 위해 PM에 대한 컴퓨터 코드의 구문론적인 해석(Syntactical interpretation)을 제공하며, 상기 타겟 앱 체인은 코드 번역에 의해 원칙 구문 형식(Principle Syntax format)으로 수신되며, 코드 번역은 SM에 의해 인지되고 이 해되는 임의의 코드를 임의의 선택된 계산 언어로 변환하며, 코드 번역은 알려진 계산 언어를 임의의 구문 유형 으로 번역하는 역함수를 수행하며, 코드 번역의 완료된 실행의 상기 출력은 입력으로서 논리 감소로 전달되고, 논리 감소는 코드 논리를 단순한 폼으로 감소시켜 규칙 및 구문의 정의에 따라 상호 연결된 함수의 맵을 생성한 다. SM으로부터의 논리 감소는 그것의 출력을 PM으로부터 반복 해석으로 제출하고, 반복 해석은 목적 연관성을 참조 하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하며, 상기 목적 정의 출력은 PM 용 모듈 식 출력으로서 제출된 복합 목적 형식에 존재하며, 상기 출력은 상기 코드 디자인 원칙의 상기 복합 목적 형식 버전으로 제시되는 목적 계층 맵으로 라벨링 된다 지시 목적 모음(Instruction Purpose Collection)은 복합 목적 형식(Complex Purpose Format)에 존재하며 LIZARD의 외부 핵심(OC) 내에서 PM의 반복 확장(Iterative Expansion)으로 제출되며, 반복 확장은 상세함과 복 잡성을 추가하여 간단한 목표를 특정한 복합 목적 정의로 발전시키며, 그러므로 상기 SM의 논리적 유도(Logical Derivation)에 제출되기 전에 입력의 최대 연관성(Purpose Association) 잠재성이 실현되고 복합 목적 형식으로 유지되며, 입력 데이터는 PM으로부터 복합 목적 형식으로 수신되고 SM의 논리적 유도로 전달되며, 논리적 유도 는 초기에 보다 단순한 함수로부터 논리적으로 필요한 함수를 도출하고, 상기 생성된 결과는 정의된 복합 목적 형식 데이터에 따라 구축된(built) 함수 의존의 트리이고, 논리적 유도는 상기 내부 핵심의 핵심 코드 요소에서 상속된 상기 규칙 및 구문 정의에 따라 작동하며, 논리적 유도는 코드 번역에 그것의 출력을 제출하며, 따라서 PM은 SM을 호출하여 코드 번역을 통해 입력된 업그레이드된 목적 맵(Upgraded Purpose Map)의 결과적인 앱체인 구문 버전을 생성한다. 선천적 오류 정정(Innate Error Correction, IEC)은 SPSI의 서브모듈이며, ATM(AppChain Targeting Mechanis m)은 호출된 ESC(Execution Stream Collection) 인스턴스에 모듈식 입력으로 제출된 지정된 타겟 앱체인을 선택 하고, 상기 ESC 인스턴스로부터의 모듈식 출력으로서 생성된 실행 스트림은 상기 코드 구조 청사진(Code Structure Blueprint)을 생성하기 위해 상기 앱체인의 실행 스트림을 분리하는 IEC 스테이지에 모듈식 입력으로 서 제출되고, 상기 코드 구조 청사진 내에 존재하는 각각의 선택된 코드 유닛은 프로그래밍 루프를 통해 사이클 되며, LIZARD는 전체 코드 구조 청사진의 목적 계층 맵을 생성하기 위해 호출되며, 두 목적 계층 맵은 모두 P2SP(Purpose to Purpose Symmetry Processing) 모듈에 모듈식 입력으로 제출되며, P2SP 처리가 완료되면, 대 칭 처리 결과(Symmetry Processing Result) 가 모듈식 출력으로서 생성된다 상기 선택된 코드 유닛은 SM에 제출되며, 상기 선택된 코드 유닛은 코드 번역에 의해 이행된 실행 스트림 포맷 으로 수신되고, 코드 번역의 상기 완료된 실행의 상기 출력은 입력으로서 논리 감소로 전달되고, 논리 감소는 코드 로직을 단순한 폼으로 감소시켜 규칙과 구문의 상기 정의에 따라 상호 연결된 함수의 맵을 생성하며, 논리 감소는 반복 해석으로 출력을 제출하고, 상기 코드 구조 청사진은 SM에 제출된다 ESC(Execution Stream Collection)가 IEC의 모듈식 입력으로서 상기 실행 스트림을 제출하면, 실행 스트림 렌 더링(Execution Stream Rendering)을 호출하여 보충 앱체인의 모든 관련 종속체를 해석 및 구축하고 이행된 실 행 스트림을 생성하며, 상기 선택된 이행된 실행 세그먼트는 분리되어 CUBP(Code Unit Buffer Pool)에 저장되며, CUBP는 SM에 제출된다 CUBP는(각 잠재적 코드 유닛의) 루프(Loop) 에서 처리되며, 상기 전체 CUBP의 상기 목적 계층 맵 및 상기 선택 된 코드 유닛의 상기 목적 계층 맵은 대칭 처리 결과를 생성하는 P2SP(Purpose to Purpose Symmetry Processing)에 제출되고, 상기 대응하는 P2SP 인스턴스의 상기 모듈식 출력은 대칭 처리 결과이며, 상기 결과는 대칭 처리 결과 검증(SPRV)에 모듈식 입력으로서 제출되고, 각각의 정렬 통합 감지(AID) 인스턴스가 분리되고, 각 AID 인스턴스 결과에 대한 루프가 호출되고, 루핑(looping)은 각각의 잘못 정렬 코드 유닛 목적(Misaligned Code Unit Purpose)을 통해 수행되며 코드 구조 청사진의 목적 계층 맵을 따르는 SPR(Suitable Purpose Replacement) 호출을 통해 적절한 목적을 도출하고, LIZARD는 상기 해당 SPR 인스턴스에 의해 생성된 상기 목적 대체(Purpose Replacements)를 실행 세그먼트로 변환하기 위해 호출되며, 각 구문 대체 유닛은 상기 코드 구조 청사진의 관련 위치와 연관되며, LIZARD는, 목적 대체(Purpose Replacements)를, 결과를 생성하여 SRUR(Syntax Replacement Unit Retention)에 제출하는 실행 세그먼트로 변환하기 위해 호출되며, 각 구문 대체 유닛은 상기 코드 구조 청사진의 해당 위치와 연관되어 있으며, 상기 유닛 청사진 조회(UBL; Unit Blueprint Lookup)가 호출 되며, UBL은 상기 입력 데이터를 업그레이드된 앱체인 출력으로 정렬하는 CSSP(Code Structure Streamline Processing)에 출력을 생성하고, 상기 구문 대체 유닛과 상기 앱체인의 대체할 부분에 대한 지침이 포함된 배포 패치가 생성된다 상기 잘못 정렬 코드 유닛 목적 보존(MCUPR; Misaligned Code Unit Purpose Retention)은 SPR에 모듈식 입력으 로 제출되며, MCUPR로부터 각각의 잘못 정렬된 코드 유닛 목적을 통한 루프가 개시되고, LOM은 상기 코드 구조 청사진과 일치하고 호환되는 상기 선택된 잘못 정렬된 코드 유닛에 대한 목적 대체(Purpose Replacement)를 생 성하기 위해 호출되며, 상기 루프 내의 상기 개별 목적 대체는 LIZARD에 의해 처리된다 상기 코드 구조 청사진(Code Structure Blueprint), 잘못 정렬 코드 유닛(Misaligned Code Unit) 및 준수 디자 인 원칙(Compliance Design Principles)은 상기 대체 호출 프롬프트(RIP; Replacement Invocation Prompt)에 대한 초기 입력으로 제공되며. RIP는 LOM과 직접 상호 작용하여 상기 입력 기준 코드 구조 청사진, 잘못 정렬된 코드 유닛 및 준수 디자인 원칙을 고려하여 상기 목적 대체의 생성을 호출하는 프롬프트를 생성하고, 상기 프롬 프트는 LOM의 상기 초기 쿼리 추론(IQR; Initial Query Reasoning) 모듈에 제출되고, LOM의 이 인스턴스는 RIP 에 의해 자동으로 호출되며, 상기 제공된 프롬프트는 LOM에 의한 상기 정확한 가상 이해를 완료하는 데 중요한 상기 프롬프트에서 누락된 세부 사항을 해독하기 위해 중앙 지식 보유(CKR)의 호출을 통해 분석되며, IQR에 의 해 생성된 결과적으로 누락된 세부 정보는 SC (Survey Clarification)에 모듈식 입력으로 제출되며, SC는 보충 정보를 검색하기 위한 상기 프롬프트의 상기 출처와 관련이 있으며, 완전하게 형성되고 리파인(refined)된 버전 의 상기 프롬프트는 SC에서 생성되고 모듈식 입력으로 주장 생성(AC; Assertion Construction)에 제출되며, AC 는 CKR을 직접 참조하고 또한 계층적 매핑(HM; Hierarchical Mapping)을 통해 상기 프롬프트에 대한 일관된 응 답을 형성하려고 시도한다. AC는 RA (Rational Appeal)에 응답 프레젠테이션을 제공하고, 상기 생성된 주장은 주관적 의견(Subjective Opinion) 입력으로서 상기 CTMP에 직접적으로 제출되고, 또한 객관적 팩트(Objective fact) 입력을 CTMP에 제공 하는 문맥 구성(Context Construction, CC)에도 제출되고, CC는 CTMP에 미가공 팩트(raw fact)을 제출하기 위 해, AC로부터 메타데이터, 그리고 RIP를 통해 제공되는 잠재적 증거를 참조하고, 상기 입력 메타데이터는 LOM의 주요 동작 기능들로부터 생성된 관련 로그 파일들의 집합을 포함하는 LOM 로그 집계(Log aggregate) 파일에 의 해 표현되고, CTMP가 동작을 마친 후에, 사후 비판 결정(Post-Criticized Decision)이 모듈식 출력으로서 생성 되고, 상기 초기의 사전 비판 결정(Pre-Criticized Decision)과 사후 비판 결정(Post-Criticized Decision)은 상기 2개의 입력 사이의 잠재적 중복의 상기 범위를 결정하는 상기 결정 비교(DC; Decision Comparison)에 제출 되며, DC가 제공하는 상기 통합된 출력은 CTMP의 양보 또는 대신하여 인지된 개선을 나타낼 수 있으며, 인수 응 답(Argument Response)은 낮은 신뢰도 결과 또는 높은 신뢰도 결과로 분류 될 수 있으며, IQR, SC, AC, 계층적 매핑(HM) 및 지식 검증(KV)을 생성한 모듈식 출력은 상기 LOM 모듈식 로그 모음(LMLC; LOM Modular Log Collection)에 제출되며, LMLC는 상기 입력 로그 데이터를 LOM 로그 집계(LOM Log Aggregate)으로서 참조되는단일 판독 가능 파일로 결합한다. 상기 사전 비판 결정(Pre-Criticized Decision)은 AC로부터의 모듈식 출력으로서 제시되고, 상기 결정은 주관적 의견으로 표시되며, 상기 주관적 의견은 CTMP에 대한 상기 기본(primary) 모듈식 입력 및 상기 선택된 패턴 매 칭 알고리즘(SPMA; Selected Pattern Matching Algorithm)의 내부 표현으로 작용하는 입력 시스템 메타데이터 (Input System Metadata)에 제출되며, 이 인스턴스 구성의 경우; 상기 SPMA는 LOM이며, 입력 시스템 메타데이터 는 추론 처리(Reason Processing)및 RP2(Raw Perception Production)으로 처리하기 위해 제출되며, 추론 처리 는 속성 특성(property attributes)들을 비교함으로써 이루어진 주장을 논리적으로 이해할 것이고, RP2는 LOM으 로부터의 상기 입력 시스템 메타데이터를 구문 분석하여 LOM의 상기 알고리즘 인지를 나타내는 인지 복합 포맷 (Perception Complex Format, PCF)에서 인지를 생성하며, 상기 생성된 인지는 상기 인지 관찰자 에뮬레이터 (POE ; Perception Observer Emulator)에 제출되고, 추론 처리는 규칙 처리를 호출하고, 두 사고 브랜치 (thinking branches)에서 생성된 상기 결과는 모두 상기 결과 사이의 충돌이나 확증의 기본 요소를 평가하는 CDO(Critical Decision Output)로 전송된다 LOM은 AC를 호출하여 상기 목적 대체(Purpose Replacement)를 생성하며, 상기 목적 대체는 상기 데이터를 언팩 (unpack)하여 상기 해당 AC 인스턴스로부터 유래하는 상기 입력 시스템 메타데이터 내의 디버깅 추적(Debugging Trace) 및 알고리즘 추적(Algorithm Trace)의 인스턴스를 생성하는 RP2에 제출되며, 디버깅 추적(Debugging Trace) 은 해당 입력 및 출력 변수 유형 및 컨텐츠와 함께 사용되는 변수, 함수, 메소드 및 클래스를 제공하는 코딩 레벨 추적이며, 알고리즘 추적(Algorithm Trace)은 알고리즘 분석과 결합된 보안 데이터를 제공하는 소프 트웨어 레벨 추적이며, 상기 결과적인 보안 결정은 그것이 결정에 어떻게 도달했는지에 대한 로지스틱 경로와 함께 제공되며, RP2는 상기 생성된 인지 결과에 관한 상기 데이터를 처리를 위해 인지 관찰자 에뮬레이터(POE) 로 전송한다. 메트릭 처리(Metric Processing) 및 시스템 메타데이터 분리(System Metadata Separation; SMS)의 상기 작동은 AC를 통해 상기 목적 대체를 생성하는 LOM의 모듈식 응답을 나타내는 상기 인지(Perceptions) 생성으로 이어지 며, RP2는 검색 기준으로서 스토리지 검색(SS; Storage search)에 공급되는 비교 가능한 가변 포맷 (Comparable Variable Format) 데이터 포인트를 생성하고, SS는 PS에 저장된 이미 존재하는 인지들과의 매칭을 찾기 위해 PS(Perception Storage)의 검색을 수행하고, PS로부터의 대응 인지의 정확한 분포를 찾아서 비교 가 능한 가변 포맷(Comparable Variable Format)을 복제하고 일치 시키려고 시도하는 가중치 계산을 유도하는 실행 SS의 상기 결과가 생성되며, 이는 목적 대체를 생성한 상기 LOM 알고리즘의 상기 실행을 나타낸다. 상기 메모리 웹 프로세스는 POE의 상기 실행과 병행하여 동작하며, LOM에 의해 생성된 상기 목적 대체(Purpose Replacement)는 RIP에서 제공한 상기 프롬프트에 대한 응답으로 LOM이 상기 목적 대체를 생성하기로 한 결정을 어떻게 실행했는지를 처리하는 추론 처리에 모듈식 입력으로 제출되며, 추론 처리의 상기 처리 결론은 LOM의 실 행 행위와 일치하는 상기 규칙을 정의하며, LOM의 실행 행위에 관한 규칙 동작에서 어떤 불일치가 발견되면, 현 재 존재하는 규칙들이 수정되거나 새로운 규칙들이 추가되고, CRSE(Critical Rule Scope Extender)는 알려진 인지를 활용하여 상기 규칙 집합의 상기 '비판적 사고' 범위를 확장하고 실제로 메모리 웹(Memory Web)의 상기 동작 관할권 내에서 규칙 구문 포맷 분리(RSFS; Rule Syntax Format Separation)에 모듈식 입력으로 제출된 커 렉트 룰(Correct Rules)을 생성하도록 상기 규칙 집합을 향상시키고, RSFS는 커렉트 룰(Correct Rules)을 유형 별로 분리하고 구성하며, 여기서, 카오틱 필드 파싱(CFP)은 상기 LOM 로그 집계(LOM Log Aggregate)를 상기 카 오틱 필드(Chaotic Field)로 참조되는 단일 스캔 가능 유닛으로 결합하고 형식화하며, 상기 카오틱 필드는 메모 리 인지(Memory Recognition; MR)에 모듈식 입력으로서 제출되고, MR은 또한 RSFS로부터의 상기 실행 결과인 상 기 오리지널 룰(Original Rules)을 수신하고, MR은 오리지널 룰 (Original Rules)에 정의된 알기 쉬운 개념을 인지하기 위해 CFP가 제공한 상기 카오틱 필드(Chaotic Field)을 스캔한다. PS는 인지의 4 가지 서브 세트, 즉, 인지의 추측된 미지 각도(Deduced Unknown Angles of Perception), 인지의 모든 각도(All Angles of Perception), 인지의 암시 각도(Implied Angles of Perception) 및 인지의 적용 각도 (Applied Angles of Perception)를 포함하며, 인지의 적용 각도(Applied Angles of Perception)는 상기 선택된 패턴 매칭 알고리즘(SPMA)의 알고리즘 행동을 연구함으로써 직접적으로 도입되며, 인지의 암시 각도(Implied Angles of Perception)는 ID (Implication Derivation) 및 APDM의 모듈 식 실행을 통해 인지의 응용 각도 (Applied Angles of Perception)로부터 도출되고, 인지의 모든 각도는 인지의 적용 각도(Applied Angles of Perception)및 인지의 내재된 각도에 포함되지 않은 CTMP에 알려진 인지의 전체 범위를 나타내며, 인지의 추측 된 미지 각도(Deduced Unknown Angles of Perception)는 존재하는 것으로 기대되지만 CTMP가 SCKD(Self- Critical Knowledge Density)에 따라 아직 발견하지 못한 인지의 범위를 나타내며, ID는 인지의 적용 각도(Applied Angles of Perception)의 상기 개별적인 메트릭스(metrics)를 분석하여 인지의 암시 각도를 결정론적 으로 유도하며, APDM은 상기 창의성 모듈을 통해 인지의 각도 구성을 창의적으로 변화시켜 상기 초기 두 개의 입력 가중치를 결합시키는 새로운 반복을 생성하며, APDM 처리와 관련된 모든 인지의 각도(Angles of Perception)는 AC에 의해 생성된 상기 목적 대체와 상응하고 이에 나타낸다 RA(Rational Appeal)는 LOM 내에서 작동하고 메모리 인지(MR; Memory Recognition)에 의해 참조되는 CC의 상기 모듈식 출력으로부터 카오틱 필드를 생성하는 카오틱 필드 파싱(CFP; Chaotic Field Parsing)에 대한 상기 LOM 로그 aggregate 를 처리하기 위해 컨텍스트 구성(CC; Context Construction)을 호출하며, 현재 규칙(Current Rules)은 상기 선택된 패턴 매칭 알고리즘(SPMA)의 상기 현재 기능 상태를 나타내는 규칙 세트를 나타내며, 현 재 규칙은 논리적 '흑백'규칙이 메트릭 기반 인지로 변환되는 상기 규칙 구문 도출(RSD)에 모듈식 입력으로 제 출되며, RSD의 상기 출력은 PM(Perception Matching)에 대한 입력으로서 제공되고, PM에서는 RSD로부터 수신된 상기 인지로부터 CVF(Comparable Variable Format) 유닛이 형성되고, 상기 새로 형성된 CVF는 PS에서 관련 인 지를 검색하는데 사용되며, 상기 잠재적인 매칭은 규칙 구문 생성(RSG)에 모듈식 입력으로서 제출되고, RSG는 인지 포맷에 저장되고 상기 인지의 내부 메트릭 구성에 액세스하는 이전에 확인된 인지(Previsouly Confirmed Perceptions)를 수신하고, 상기 인지는 이전에 확인된 인지를 포함하는 PS로부터 수신되며, 메트릭스(metrics) 의 그러한 그레디언트 기반 측정치들은 상기 오리지널 인지의 입력 / 출력 정보 흐름을 에뮬레이트하는 이진 및 논리 규칙 세트로 변환되고, 따라서 RSG는, 관련성이 높고 대중적인 것으로 고려되며 논리 규칙으로 변환된 인 지 규칙(Perceptive Rules)을 생성하며, 만약 인지가, 많은 '회색 영역'을 정의하는 많은 복잡한 메트릭 관계를 가지고 있는 경우, '흑백' 로컬 규칙은 상기 규칙 세트 복잡성을 확장하여 그러한 '회색'영역을 포괄하며, 인지 규칙(Perceptive Rules)은 규칙 구문 포맷(RSF; Rule Syntax Format) 정의 모음에 의해 저장되고, 인지 규칙은 CFP에 의해 생성된 카오틱 필드(Chaotic Field)에 대해 스캔되는 MR에 입력으로서 제출되며, MR은 커렉트 룰 (Correct Rules)을 그들의 유효성으로 완료하는 추가 규칙(Extra Rules)을 생성한다. PS로부터의 상기 인지의 적용 각도(Applied Angles of Perception)는 인지의 암시 각도(Implied Angles of Perception)에 속하는 더 많은 인지를 생성하기 위해 ID에 입력으로서 제출되고, 상기 인지의 적용 각도는 구체 적으로 ID의 메트릭 조합(Metric Combination)으로 보내지며, 메트릭 조합은 상기 수신된 인지의 각도를 메트릭 의 카테고리: 범위(Scope), 유형(Type), 일관성(Consistency), 강도(Intensity)에 따라 나누며, 상기 인지의 입력각은 AC에 의해 생성된 상기 목적 대체(Purpose Replacement)와 관련되며, 메트릭 복잡도 세트 A가 메트릭 확장(ME; Metric Expansion)에 입력으로서 제출되고, ME와 함께 다수의 변화하는 인지의 각도(Angle of Perception)의 상기 메트릭들이 명확하게 저장되고, ME는 이전에 알려졌거나 마주친 메트릭스(metrics)로부터 추출된 세부 사항 / 복잡도와 함께 수신된 메트릭의 현재 배치(batch)를 향상시키고, 증강 및 복잡성 강화 완료 시, 상기 메트릭스(metrics)는 메트릭 복잡도 세트 B로서 ME 출력으로서 리턴된 후, 인지의 암시 각도(Implied Angles of Perception)에 저장되도록 인지의 각도로 다시 변환된다 CTMP의 중요 결정 출력(Critical Decision Output, CDO)은 POE 및 RE로부터 출력을 수신하고, 각 브랜치 (Branch)는 상응하는 초기 중요 결정에 도달한 이유를 정당화하는 문맥적 변수를 제공하는 메타- 메타데이터 뿐 아니라 각 중요 결정(Critical Decision)을 제출하며, POE의 인지 및 RE의 이행된 규칙(Fulfilled Rules)을 나 타내는 두 결정 세트(Decision Sets)는 모두 전통적인 구문 기반 정보 카테고리화를 사용하여 상기 디버깅 및 알고리즘 추적을 별개의 카테고리로 분리하는 상기 메타데이터 분류 모듈(MCM; Metadata Categorization Module)에 제출되며, DDC(Direction Decision Comparison)의 상기 내부 프로세싱 로직(Intelligent Processing Logic)은 상기 직관적 결정(Intuitive Decision)과 사고 결정(Thinking Decision) 사이의 확증(corroboration) 또는 충돌(conflict)을 확인하고, 터미널 출력 제어(TOC; Terminal Output Control)가 프롬프트로 시작되고, 이는 DDC가 최종 결정 출력을 제공할 수 있는지를 확인하며, 프롬프트에 대한 상기 응답이 예인 경우 최종 결정 출력에서 DDC가 제공한 상기 병합된 최종 결정은 TOC의 출력으로 제출되며, 프롬프트에 대한 상기 응답이 아니 오 이면, PM이 실행되어 대응하는 결과를 가져오고, 이행된 규칙(Fulfilled Rules)은 RE의 상기 중요 결정 + 메 타 - 메타데이터로부터 추출되며, 상기 규칙은 RSD(Rule Syntax Derivation)에 의해 인지로 변환되고, PM은 메 타-메타데이터를 참조하여 강한 내부 중첩 및 사용된 인지의 확증이 있는지를 결정한다. 상기 목적 대체(Purpose Replacement)는 복합 목적 형식으로 존재하며 PM의 반복 확장(Iterative Expansion)으 로 제출되며, 반복 확장은 세부사항 및 복잡성을 추가하여(상기 목적 대체 내에서 간접적으로 정의된) 단순한 목표(goal)를 특정 복합 목적 정의로 발전시켜, SM의 논리적 유도(Logical Derivation)로 제출되기 전에 상기 입력의 최대 목적 연관 (Purpose Association) 잠재성을 실현하고 복합 목적 형식(Complex Purpose Format)으 로 유지되게 하며, IC의 상기 핵심 코드 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks andLibraries), 스레드 관리(Thread Management) 및 로드 균형 조정 스크립트(Load Balancing scripts), 커뮤니케 이션 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템이 포함되어, SM 및 PM에 대한 일반적인 작동 및 기능을 가능하게 하고, IC의 상기 시스템 목적(System Objective)은 보안 정책과 기업 목표를 정의한다. IEC의 상기 유닛 청사진 조회(UBL)의 상기 동작 및 기능에 관해서, SRUR(Syntax Replacement Unit Retention) 으로부터의 입력이 수신되고, 따라서 모든 상기 구문 대체 유닛(Syntax Replacement Unit)을 순환 하는 루프가 개시되며, 상기 관련 코드 유닛 ID(Associated Code Unit ID)는 상기 구문 대체 유닛에서 언팩(unpacked) 되고, UBL의 동일한 인스턴스 내 별도의 병렬 스레드에서 상기 코드 구조 청사진이 입력으로 제출되고 상기 코 드 구조 청사진은 새 코드 구조 청사진 보유(NCSBR)에 설치되며, 상기 실행 세그먼트의 상기 이행된 상태는, 상 기 업그레이드된 앱체인을 출력으로 생성하는 코드 구조 스트림라인 처리(CSSP; Code Structure Streamline Processing)를 통해 리버스되고, 이는 잘못 정렬된 코드 유닛으로 된 원래의 구문 구조가 적합한 목적 대체 (Suitable Purpose Replacement)로 대체된 상태를 나타내는 것이며, 상기 업그레이드된 앱체인은 DPA(Deployment Patch Assembly)에 제출되어 상기 앱체인 정정 패치(Appchain Correction Patch)를 생성하며, 상기 타겟 앱체인은 ESC(Execution Stream Collection)에 의해 처리되므로 상기 원래 실행 스트림을 DPA에 제 출하여 DPA가 원래 형식의 상기 타겟 앱체인에 액세스 할 수 있도록 하며, 상기 앱체인 정정 패치는 상기 타겟 앱체인을 조작하여 컨텐츠를 상기 업그레이드된 앱체인으로 변환하게 하는 커스텀체인 생태계 빌더(CEB; Customchain Ecosystem Builder)에 배포된다 ASH (Appchain Security Hardening)과 관련한 LOM 및 CTMP의 상기 내부 작업과 관련하여 보안 이론, 미확인 보 안 정보 및 확정 보안 지식(Confirmed Security Knowledge)은 DIP(Deduction Invocation Prompt)에 초기 입력 으로 제공되어, LOM과 직접 상호 작용하여 상기 입력 기준 보안 이론을 고려한 상기 신뢰 보안 주장(Confident Security Assertion), 미확인 보안 정보 및 확정 보안 지식의 생성을 호출하는 프롬프트를 생성하며, 상기 프롬 프트는 상기 초기 쿼리 추론(IQR)에 제출되고, 상기 제공된 프롬프트는 중앙 지식 보유(CKR)의 호출을 통해 분 석되고, IQR에 의해 생성된 상기 결과적인 누락 세부 정보는 보충 정보를 검색하기 위해 상기 프롬프트의 상기 출처와 관련된 SC(Survey Clarification)에 입력으로 제출되고, SC는 DIP와 함께 상기 프롬프트와 관련된 보충 정보를 검색하고, 상기 리파인 된(Refined) 버전의 상기 프롬프트는 SC로부터 생성되며, 직접 CKR을 참조하고 계층적 매핑(HM)을 통해 상기 프롬프트에 대한 일관된 응답을 형성하려고 시도하는 AC에 입력으로 제출되며, RA 는 CTMP를 사용하여 자기 비판 또는 IQR에 의해 처리된 상기 질의 / 주장의 상기 출처에 대한 외부 비판의 형태 로 주장을 비판하며, AC로부터 생성된 주장이 RA에 의해 처리된 상기 자기 비판 테스트의 중요한 측정에 실패하 면; AC의 새로운 인스턴스가 호출되어 유효한 비판을 설명하고, RA에 의해 처리된 자기 비판 테스트를 일관되게 통과하는 높은 신뢰성의 주장이 AC에 의해 생성되는 경우; 상기 주장은, DIP에서 제공하는 상기 초기 프롬프트 와 관련하여 신뢰 보안 주장 (Confident Security Assertion)으로 참조되는 LOM의 출력으로 생성된다 ASH와 관련한 RA의 상기 내부 운영 절차와 관련하여, AC는 상기 해당 입력 프롬프트와 관련된 AC에 의해 생성된 상기 주장과 관련하여 RA에게 응답 프레젠테이션을 제공하고, 상기 생성된 주장은 주관적인 의견 입력으로 CTMP 에 직접 제출되며, CTMP에 상기 객관적 사실(Objective Fact) 입력을 제공하는 컨텍스트 구축(CC)에도 제출되며, CC는 AC의 메타데이터와 RIP를 통해 제공된 잠재 증거를 참조하여 CTMP에 미가공 팩트(raw fact)를 비판적 사고(critical thinking)를 위해 제출하고, 상기 입력 메타데이터는 상기 LOM 로그 집합 파일(Log aggregate file)에 의해 표현되며, 초기 쿼리 추론(IQR), SC, AC, HM 및 KV로부터 생성된 출력은 상기 입력 로 그 데이터를 LOM 로그 집계로 참조되는 단일 판독 가능 파일로 결합하고 RA(Rational Appeal)의 CC에 제출되는 상기 LOM 모듈식 로그 모음(LMLC)에 제출된다. CTMP 내에서 RP2의 상기 호출과 관련하여, LOM은 AC를 호출함으로써 신뢰 보안 주장(Confident Security Assertion)을 생성하고, 상기 신뢰 보안 주장은 상기 해당 AC 인스턴스로부터 발생하는 상기 입력 시스템 메타 데이터(Input System Metadata) 내에서 디버깅 추적 및 알고리즘 추적(Argument Trace)의 인스턴스를 생성하기 위해 상기 데이터를 언팩하는 RP2에 제출되고, 메트릭 처리(Metric Processing)는 LOM의 상기 변수를 리버스 엔 지니어링하여 LOM이 제시 한 상기 인공 지능으로부터 인지를 추출하고, 그 이후에 입력 시스템 메타데이터는 시 스템 메타데이터 분리(SMS; System Metadata Separation)를 통해 의미 있는 보안 인과 관계(cause-effect relationship)로 분리된다 LOM 의해 생성된 상기 목적 대체(Purpose Replacement) 및 해당 LOM 로그 집계(LOM Log Aggregate)는 상기 입 력된 목적 대체와 관련하여 긍정적인 감정(승인) 또는 부정적인 감정(차단)의 해석 이분법(Interpretation Dichotomy)을 달성하기 위해 상기 어플리케이션에 적용되는 데이터 향상 로그가 파생되도록 하는 데이터 구문분석(Data Parsing)을 겪으며, 어플리케이션의 실행이 성공적으로 끝나면 CDO(Critical Decision Output)에 의 해 규칙 실행(RE)의 모듈식 출력과 병행하여 처리되는 오버라이드 정정 작업(Override Corrective Action)으로 이어지며, SCKD(Self-Critical Knowledge Density)는 보고 가능한 LOM 로그 집계 범위를 벗어나는 잠재적 인 알려지지 않은 지식의 범위와 유형을 추정한다. PS와 상기 APDM(Automated Perception Discovery Mechanism) 사이의 상기 논리 흐름 상호 작용과 관련하여, PS 는 인지의 4 가지 서브세트 즉, 인지의 추측된 미지 각도(Deduced Unknown Angles of Perception), 인지의 모 든 각도(All Angles of Perception), 인지의 암시 각도(Implied Angles of Perception) 및 인지의 적용 각도 (Applied Angles of Perception)를 포함하며, 인지의 적용 각도는 SPMA의 알고리즘적 행동을 연구함으로써 직접 적으로 도입되며, 인지의 암시 각도는 ID (Implication Derivation)와 APDM의 실행을 통해 인지의 적용 각도에 서 파생되며, 인지의 모든 각도는 인지의 적용 각도 및 인지의 암시 각도에 의해 포함되지 않은 상기 CTMP에 대 한 알려진 인지의 전체 범위를 나타내며, 인지의 추측된 미지 각도는 SCKD에 따르면 상기 CTMP가 아직 발견하지 못하였지만 존재할 것으로 예상되는 인지의 범위를 나타내며, ID는 인지의 암시 각도를 결정론적으로 유도하기 위해 인지의 적용 각도의 상기 개개 메트릭스(metrics)를 분석하고, APDM은 상기 창의력 모듈을 통해 인지 각도 (Angles of Perception)의 구성을 창의적으로 변화시켜 상기 초기 2 개의 입력 가중치(input Weights)를 결합 하는 새로운 반복(New Iteration)을 생성하고, APDM 처리와 관련된 모든 인지의 각도는 LOM의 AC에서 생성된 신 뢰 보안 주장과 일치하고 이를 나타낸다 CTMP의 CRSE(Critical Rule Scope Extender)와 관련하여, RA 인스턴스는 LOM 내에서 동작하고 상기 LOM 로그 집계 대 카오틱 필드 파싱(CFP)을 처리하기 위해 컨텍스트 구축(CC)을 호출하며, 이는 컨텍스트 구축의 상기 모 듈식 출력으로부터 카오틱 필드를 생성하고 이는 메모리 인지(MR)에 의해 참조되며, 현재 규칙은 이 경우에 LOM 인 상기 선택된 패턴 매칭 알고리즘(SPMA)의 상기 현재 기능 상태를 나타내는 규칙 세트를 나타내고, 현재 규칙 은 모듈식 입력으로, 논리적 '흑백'규칙이 메트릭 기반 인지로 변환되는 곳인 상기 규칙 구문 유도(RSD)에 제출 되며, RSD의 상기 출력은 PM(Perception Matching)에 입력으로서 제공되고, PM에서; RSD로부터 상기 수신된 인 지로부터 CVF(Comparable Variable Format) 유닛이 형성되고, 상기 새로 형성된 CVF는 유사한 인덱스를 갖는 상기 인지 저장(Perception Storage: PS)에서 관련 인지를 검색하는데 사용되며, 상기 잠재적 매칭은 규칙 구문 생성(RSG)에 입력으로서 제출되고, RSG는 인지 형식으로 저장되고 이전에 확인된 인지를 수신하고 상기 인지의 내부 메트릭 구성에 액세스하며, 상기 인지가 이전에 확인된 인지를 포함하는 PS로부터 수신됨으로써, 메트릭스 의 이러한 그래디언트 기반 측정치가 상기 원래 인지의 상기 입력 / 출력 정보 흐름을 에뮬레이트하는 이진 및 논리 규칙 집합으로 변환되고 따라서 RSG가 관련성이 있고 대중적이라고 간주되는 인지인 인지 규칙이 논리적인 규칙으로 변환된 인지 규칙을 생성하며, 상기 인지 규칙은 규칙 구문 포맷(RSF) 정의의 모음에 의해 저장되고, 인지 규칙은 CFP에 의해 생성된 상기 카오틱 필드(Chaotic Field)에 대해 스캔되는 MR(Memory Recognition)에 입력으로 제출되며, MR은 커렉트 룰(Correct Rules)을 정당하게 완료하는 추가 규칙(Extra Rules)을 생성한다. CTMP의 ID와 관련하여, PS로부터의 인지의 적용 각도가 ID에 입력으로서 제출되어 인지의 암시 각도에 속하는 더 많은 인지를 생성하며, 인지의 적용 각도는 구체적으로 ID의 메트릭 조합(Metric Combination)으로 보내지고, 메트릭 조합은 상기 수신된 인지의 각도를 메트릭스의 카테고리: 범위, 유형, 일관성, 강도로 분리시 키고, 상기 입력된 인지의 각도는 AC에 의해 생성된 상기 목적 대체와 관련되어 있다 CDO는 CTMP의 두 개의 주요 브랜치(branch) 모두로부터 모듈식 출력을 수신하며 : POE 및 RE, 각 브랜치는 각각 의 중요 결정(Critical Decision) 뿐 아니라 그에 상응하는 메타-메타데이터(Meta-metadata)를 제출하며, 두 결정 세트(Decision Sets)는 모두 전통적인 구문 기반 정보 분류를 사용하여 상기 디버깅 및 알고리즘 추적을 별개의 카테고리로 구분하는 상기 메타데이터 분류 모듈(MCM; Metadata Categorization Module)에 제출된다 상기 시스템 규정 및 지침을 목적 계층 맵으로 변환하는 LIZARD의 상기 작동과 관련하여 상기 시스템 규정 및 지침이 LUIGI로부터 SM으로 제출되며, 상기 시스템 규정 및 지침은 임의의 코드를 선택된 계산 언어로 변환하고 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수를 수행하는 코드 번역에 의해 데이터 스트림 A0 형 식으로 수신된다 상기 업그레이드된 목적 맵(Upgraded Purpose Map)은 복합 목적 형식(Complex Purpose Format)에 존재하며 상 세성과 복잡성을 추가하는 반복 확장(Iterative Expansion)으로 제출되어 간단한 목표(goal)를 특정한 복합 목 적(complex purpose) 정의로 발전시키고, 상기 입력 데이터는 PM으로부터 복합 목적 형식으로 수신되고 SM의 논 리 유도로 전달되며, PM은 SM을 호출하여 코드 번역을 통해 상기 입력된 업그레이드된 목적 맵의 상기 결과적인 앱체인 구문 버전을 생성하고, 최종적으로 코드 번역에 의해 생성된 상기 결과적인 업그레이드된 앱체인은 SM,외부 핵심 및 LIZARD의 상기 모듈식 출력이다 에러 관련 로그 보유 (ERLR; Error Related Log Retention)의 상기 전체 컨텐츠를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하는 LIZARD의 상기 동작과 관련하여, ERLR의 상기 컨텐츠가 SM에 제출되고, SM의 논리 감소(Logical Reduction)는 PM의 반복 해석(Iterative Interpretation)에 출력을 제출하며, 반복해석은 목적 연관성 (Purpose Associations)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하 며, 상기 출력은 ERLR의 복합 목적 형식(Complex Purpose Format) 버전으로서 제시되는 목적 계층 맵으로 라벨 링된다. 상기 컨텍스트화 된 에러 로그(Contextualized Error Log)를 목적 계층 맵으로 변환하기 위한 상기 LIZARD의 동 작과 관련하여, 상기 콘텍스트화된 에러 로그가 SM에 제출되고, SM의 논리 감소(Logical Reduction)는 PM의 반 복 해석에 출력을 제출하고, 반복 해석은 목적 연관성 (Purpose Associations)를 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하며, 상기 출력은 상기 컨텍스트화 된 에러 로그의 상기 복합 목 적 형식 버전으로서 제시되는 목적 계층 맵으로 라벨링된다 리파인 된 실행 세그먼트(Refined Executed Segment)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하는 LIZARD의 상기 동작과 관련하여, 상기 리파인 된 실행 세그먼트는 SM에 제출되고, SM의 논리 감소(Logical Reduction)는 PM의 반복 해석(Iterative Interpretation)에 그 출력을 제출하고, 반복 해석은 목적 연관성 (Purpose Associations)를 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하며, 상 기 출력은 상기 리파인 된 실행 세그먼트의 상기 복합 목적 형식 버전으로서 제공되는 목적 계층 맵으로 라벨링 된다 상기 UBEC 플랫폼의 전체 커스텀체인 생태계(Customchian Ecosystem)를 목적 계층 맵으로 변환하는 LIZARD의 동 작과 관련하여, 상기 UBEC 플랫폼은 SM에 제출되고, SM의 논리 감소(Logical Reduction)는 PM의 반복 해석에 그 출력을 제출하고, 반복 해석은 목적 연관성(Purpose Associations)을 참조하여 해석된 목적 정의를 생성하기 위 해 모든 상호 연결된 함수를 루프하며, 상기 출력은 상기 UBEC 플랫폼의 상기 복합 목적 형식 버전으로 제시되 는 목적 계층 맵으로 라벨링된다 상기 목적 계층 맵을 일련의 목적 밴드(Purpose Bands)로 변환하는 LIZARD의 상기 동작과 관련하여, 상기 목적 계층 맵은 복합 목적 형식으로 존재하고 PM의 반복 확장으로 제출되며, 반복 확장은 세부사항과 복잡성을 추가 하여 단순한 목표를 특정 복합 목적 정의로 발전시켜 상기 입력의 최대 용도 연합 잠재력을 SM의 논리적 유도에 제출하기 전에 복합 목적 형식으로 실현되고 유지되며, 상기 입력 데이터는 상기 PM으로부터의 복합 목적 형식 (Complex Purpose Format)에서 수신되고 SM의 논리 유도(Logical Derivation)로 전송되며, 논리 유도는 초기에 보다 단순한 함수로부터 논리적으로 필요한 함수를 유도하고, 상기 생성된 결과는 상기 정의된 복합 목적 형식 데이터에 따라 구축된 함수 의존 관계의 트리이다 신규 제안된 변경(New Proposed Changes)를 목적 계층 맵으로 변환하는 LIZARD의 상기 동작과 관련하여, 상기 UBEC 플랫폼은 SM으로 제출되며, SM의 논리 감소는 PM의 반복 해석으로 그 출력을 제출하며, 반복 해석은 목적 연관성 (Purpose Associations)를 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하 며, 상기 출력은 상기 신규 제안된 변경의 상기 복합 목적 형식 버전으로 제시되는 목적 계층 맵으로 라벨링 된 다. 시스템 디자인 원칙(System Design Principles)을 목적 계층 맵으로 변환하는 LIZARD의 상기 동작과 관련하여 상기 시스템 디자인 원칙이 SM에 제출되고, SM의 논리 감소(Logical Reduction)는 PM의 반복 해석에 그 출력을 제출하고, 반복 해석은 목적 연관성 (Purpose Associations)를 참조하여 해석된 목적 정의를 생성하기 위해 모 든 상호 연결된 함수를 루프하며, 상기 출력은 상기 시스템 디자인 원칙의 상기 복합 목적 형식 버전으로 제시 되는 목적 계층 맵으로 라벨링된다. 앱체인 관할권(Appchain Jurisdictions)을 목적 계층 맵으로 변환하는 LIZARD의 상기 동작과 관련하여, 상기 앱 체인 관할권이 SM에 제출되며, SM의 논리 감소(Logical Reduction)는 PM의 반복 해석에 출력을 제출하고, 반복 해석은 목적 연관성 (Purpose Associations)를 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하며, 상기 출력은 상기 앱체인 관할권의 상기 복합 목적 형식 버전으로 제시되는 목적 계층 맵으로 라벨링 된다. 상기 업그레이드된 목적 맵(Upgraded Purpose Map)을 신규 제안된 변경(New Proposed Changes)으로 변환하는 LIZARD의 상기 동작과 관련하여, 상기 업그레이드된 목적 맵은 복합 목적 형식으로 존재하며 PM의 반복 확장에제출되며, 상기 입력 데이터는 PM으로부터 수신되고 SM의 논리 유도로 전달되며, 논리 유도는 초기에보다 단순 한 함수로부터 논리적으로 필요한 함수를 도출하고, 상기 생성된 결과는 상기 정의된 복합 목적 형식 데이터에 따라 구축된 함수 종속성의 트리이며, PM은 SM을 호출하여 코드 번역을 통해 상기 입력된 업그레이드된 목적 맵 의 상기 결과적인 앱체인 구문 버전을 생성한다. 생성할 앱체인(Appchains to Create)을 로지스틱스 레이어(Logistics Layer)로 변환하기 위한 LIZARD의 상기 동작과 관련하여, 생성할 앱체인(Appchains to Create)은 SM으로 제출되고, SM의 논리 감소(Logical Reduction)는 PM의 반복 해석(Iterative Interpretation)에 그 출력을 제출하며, 반복 해석은 목적 연관성 (Purpose Associations)를 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하며, 상 기 출력은 생성할 앱체인(Appchains to Create)의 복합 목적 형식 버전으로 제시되는 로지스틱스 레이어로 라벨 링되고, 로지스틱스 레이어(Logistics Layer) 형식으로 더 체계화(codified) 된, 상기 로지스틱스 레이어 (Logistics Layer)는 상기 구문의 매크로 배열이며, 상기 복합 목적 형식은 상기 구문의 상기 마이크로 배열을 정의한다. 상기 OC3 맵을 앱체인 구문 맵(Appchain Syntax Map)으로 변환하는 LIZARD의 상기 동작과 관련하여, 상기 OC3 맵은 복합 목적 형식으로 존재하며 PM의 반복 확장(Iterative Expansion)에 제출되고, 반복 확장은 세부사항과 복잡성을 추가하여 간단한 목표를 특정한 복합 목적 정의로 발전시키고, 상기 입력 데이터는 PM으로부터 복합 목적 형식에서 수신되고 SM의 논리 유도로 전달되며, 논리 유도는 초기에 보다 단순한 함수로부터 논리적으로 필요한 함수를 도출하고, 상기 생성된 결과는 상기 정의된 복합 목적 형식 데이터에 따라 구축된 함수 종속성의 트리(tree)이며, 코드 번역에 의해 최종 생성된 상기 결과적인 앱체인 구문 맵(Appchain Syntact Map) 유닛은 SM, OC 및 LIZARD의 상기 모듈식 출력이다 이행된 앱체인(Fulfilled Appchain)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하는 LIZARD 의 상 기 동작에 관해서, 이행된 앱체인은 SM에 제출되고, SM의 논리 감소(Logical Reduction)은 PM의 반복 해석에 그 출력을 제출하며, 상기 출력은 이행된 앱체인의 상기 복합 목적 형식 버전으로 제시되는 로지스틱스 레이어 (Logistics Layer)로 라벨링된다 신규 앱체인 개발(NAD; New Appchain Development)과 관련된 LOM 및 CTMP의 상기 동작과 관련하여, 상기 창의 적 디자인 원칙, 선택된 맵 세그먼트 및 OC3 맵이 상기 창의적 변수 호출 프롬프트(CVIP; Creative Variance Invocation Prompt)에 대한 초기 입력으로 제공되며, 이는 LOM과 직접 상호 작용하여 상기 입력 기준 보안 이론 (input criteria Theory of Security), 미확인 보안 정보(Unconfirmed Security Information) 및 확인된 보안 지식(Confirmed Security Knowledge)을 고려하여 상기 신뢰 보안 주장의 생성(Confident Security Assertion) 을 호출하는 프롬프트를 생성하며, 상기 프롬프트는 LOM의 상기 초기 쿼리 추론(IQR; Initial Query Reasoning) 모듈에 제출되고, 상기 프롬프트는 중앙 지식 보유(CKR; Central Knowledge Retention)의 호출을 통해 분석되며, IQR에 의해 작성된 상기 결과적으로 누락된 세부 정보(Missing Details)는 보충 정보를 검색하기 위 해 상기 프롬프트의 상기 출처와 관련된 조사 해명(SC; Survey Clarification)에 모듈식 입력으로 제출되며, SC 는 DIP와 관련되어 상기 프롬프트와 관련된 보충 정보를 검색하며, SC로부터의 상기 프롬프트의 상기 버전은, CKR을 직접 참조하고 또한 계층적 매핑(HM)을 통해 상기 프롬프트에 대한 일관된 응답을 형성하려고 시도하는, AC에 제출되고, AC는 AC에 의해 생성된 상기 주장에 관해 RA에 응답 프레젠테이션을 제공하고, 상기 생성된 주 장은 사전 비판 결정(Pre-Criticized Decision)으로 분류되고, CTMP는 사후 비판 결정(Post-Criticized Decision)을 생성하며, 상기 초기 사전 비판 결정과 사후 비판 결정은 상기 두 입력 간의 잠재적 중첩 범위를 결정하는 상기 결정 비교(DC; Decision Comparison)에 제출된다 IQR, SC, AC, HM 및 KV에서 생성된 모듈식 출력은, 상기 입력 로그 데이터를 상기 LOM 로그 집계(LOM Log Aggregate)로 참조되는 단일 판독 가능 파일로 결합하는 LOM 모듈식 로그 모음(LOM Modular Log Collection, LMLC)에 제출되고, 이는 RA (Rational Appeal)의 CC로 제출되며, 상기 사전 비판 결정(Pre-Criticized Decision)은 AC로부터의 모듈식 출력으로 제시되고 주관적 의견(Subjective Opinion)으로 표시되며, 입력 시스 템 메타데이터는 처리를 위해 추론 처리(Reason Processing) 및 RP2에 제출되고, 추론 처리는 속성 특성 (property attributes)를 비교함으로써 만들어진 상기 주장을 논리적으로 이해하고 RP2는 LOM의 상기 입력 시스 템 메타데이터를 구문 분석하여 POE에 제출되는 PCF(Perception Complex Format)에서 인지를 생성하며, 추론 처 리는 규칙 처리(Rule Processing)를 호출하여 결국 상기 SPMA 알고리즘을 반영하는 규칙 세트를 생성한다. POE의 동작과 관련하여, 메트릭 프로세싱 및 시스템 메타데이터 분리(SMS)의 상기 동작은 모두 인지의 상기 생 성으로 이어지며, 상기 결과적인 인지는 AC를 통한 상기 목적 대체를 생성하는 LOM의 응답을 나타내며, RP2는검색 기준으로서 SS에 공급되는 비교 가능한 가변 포맷(Comparable Variable Format) 데이터 포인트를 생성하고, 상기 실행 SS의 상기 결과의 생성은, PS로부터의 대응 인지의 정확한 분포를 발견하여 창의적 잠재 유닛(Creative Potential Unit)을 생성하는 상기 LOM의 상기 실행을 나타내는 상기 비교 가능한 가변 포맷을 복 제 및 매칭시키려고 시도하는, 가중치 계산(Weight Calculation)으로 이어지며, 상기 가중치 계산 완료는 액티 브 승인(Approve) 또는 차단(Block) 결정을 내리기 위해 인지의 상기 어플리케이션으로 이어지며, LOM에 의해 생성된 상기 창의적 잠재 유닛(Creative Potential Unit)및 해당 LOM 로그 집계는, 데이터 향상 로그가 파생되 도록 하는 데이터 구문 분석을 거치며 이는 상기 어플리케이션에 적용되어 상기 입력 창의적 잠재 유닛 (Creative Potential Unit)에 대해 긍정적 감정(승인) 또는 부정적 감정(차단)의 해석 이분법(Interpretation Dichotomy)을 달성하며, 어플리케이션의 상기 실행이 성공적으로 끝나면 RE의 상기 출력과 병행하여 CDO에 의해 처리되는 오버라이드 정정 작업(Override Corrective Action)으로 이어지며, SCKD는 상기 보고 가능한 LOM 로 그 집계의 범위를 벗어나는 잠재적 알려지지 않은 지식의 범위와 유형을 추정한다. POE의 상기 실행과 병행하여 작동하는 상기 메모리 웹 프로세스와 관련하여 LOM에 의해 생성된 상기 창의적 잠 재 유닛(Creative Potential Unit)은 모듈식 입력으로, LOM이 CVIP에 의해 제공된 상기 프롬프트에 대한 응답으 로 상기 창의적 잠재 유닛(Creative Potential Unit)을 생성하는 상기 결정을 어떻게 수행했는지를 처리하는 추 론 처리(Reason Processing)에 제출되며, CRSE는 알려진 인지를 활용하여 규칙 집합(rulesets)의 상기 '비판적 사고'범위를 확장하고, 상기 커렉트 룰(Correct Rules)은 메모리 웹의 운영 관할권 내에서 RSFS(Rule Syntax Format Separation)로 제출되며, RSFS는 커렉트 룰(Correct Rules)을 유형별로 분리하고 구성하며, 카오틱 필 드 파싱(CFP)은 MR에 제출된 카오틱 필드로서 참조되는 단일 스캔 가능한 유닛으로 상기 LOM 로그 집계를 병합 및 포맷하며, MR은 RSFS로부터의 상기 실행 결과인 상기 오리지널 룰(Original rules)을 수신하고 CFP가 제공한 상기 카오틱 필드를 스캔하여 인지 규칙 세그먼트를 생성하는 오리지널 룰에 정의된 알 수 있는 개념을 인지하 고, RFP는 MR에 의한 상기 카오틱 필드 내에서 자신의 인지 또는 부족에 따라 태그가 붙은 상기 오리지널 룰의 개별 부분을 수신하고 RFP는 전체 규칙 집합(모든 부분의 조합)이 RE에 의해 처리되는 자격이 있기 위해 상기 카오틱 필드에서 충분히 인지되었는지 논리적으로 추론하며, RE의 상기 실행의 결론은 POE의 상기 출력과 병행 하여 CDO에 의해 처리된 오버라이드 정정 작업(Override Corrective Action)으로 이어진다 구문 창의성 솔루션(Syntactical Creative Solutions)을 목적 계층 맵으로 변환하는 LIZARD의 상기 작동과 관 련하여, 구문 창의성 솔루션(Syntactical Creative Solutions)은 SM에 제출되고, 상기 구문 모듈(SM)의 논리 감소(Logical Reduction)는 PM의 반복 해석에 그 출력을 제출하며, 반복 해석은 목적 연관성 (Purpose Associations)를 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하며, 상기 출력은 Syntactical Creative Solutions의 상기 복합 목적 형식 버전으로 제시되는 로지스틱스 레이어 (Logistics Layer)로 라벨링된다 EFD(Enhanced Framework Development)와 관련하여, 상기 효율성 디자인 원칙, 안정성 디자인 원칙 및 하드웨어 목적 맵이, IQR에 제출되는 프롬프트를 생성하는 상기 DIP(Deduction Invocation Prompt)에 초기 입력으로 제 공되며, 상기 제공된 프롬프트는 CKR에 의해 분석되어 상기 프롬프트로부터 누락된 세부 사항을 해독하고, 상기 결과적인 누락된 세부 사항은 보충 정보를 검색하기 위해 프롬프트의 상기 출처와 관련된 SC에 제출되며, SC로 부터 생성된 상기 프롬프트의 상기 버전은, CKR을 직접 참조하거나 HM을 통해 상기 프롬프트에 일관된 응답을 시도하는 AC에 제출된다. CTMP 내에서 RP2의 상기 호출과 관련하여, LOM은 AC를 호출하여 상기 이상적인 프레임워크 구조를 생성하며, 상 기 이상적인 프레임워크 구조는 디버깅 추적(Debugging Trace) 및 알고리즘 추적(Algorithm Trace)의 인스턴스 를 생성하기 위해 상기 데이터를 언팩(unpack)하는 RP2로 제출되며, RP2는 상기 생성된 인지 결과에 관한 상기 데이터를 POE로 전송한다. CTMP의 ID와 관련하여, PS로부터의 상기 인지의 적용 각도는 인지의 암시 각도에 속하는 더 많은 인지를 생성하 기 위해 ID로 제출되고, 메트릭 조합은 상기 수신된 인지의 각도를 메트릭의 카테고리들로 분리하고, 상기 입력 된 인지의 각도는 상기 이상적인 프레임워크 구조와 관련되며, 상기 메트릭 복잡도 세트 A가 ME에 제출되고, 증 강 및 복잡성 강화 완료 시, 상기 메트릭스는 메트릭 복잡도 세트 B(Metric Complexity Set B)로서 ME 출력으로 서 리턴된 후, 인지의 암시 각도로 저장되도록 인지의 각도로 다시 변환되고, 상기 메트릭 복잡도 세트 B (C737)은 메트릭 변환(Metric Conversion)에 의해 처리되어 개별 메트릭을 전체 인지의 각도로 다시 리버스 시 킨다. 리파인(refined)된 프레임워크 구조 해석을 이상적인 프레임워크 목적 맵으로 변환하기 위한 LIZARD의 상기 동 작과 관련하여, 리파인(refined)된 프레임워크 구조 해석이 SM에 제출되고, SM의 논리 감소가 PM의 반복 해석에 그 출력을 제출하고, 반복 해석은 목적 연관성(Purpose Associations)를 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프하며, 상기 출력은 리파인 된 프레임워크 목적 맵(Refined Framwork Purpose Map)으로 라벨링된다 니드 맵 매칭(Need Map Matching, NMM)에 관하여, 상기 NMM 인스턴스는 EFD(Enhanced Framework Development) 의 상기 동작을 제공하도록 생성되며, NMM의 상기 호출시, 초기 구문 분석(Initial Parsing)은 저장소로부터 각 관할권 브랜치(branch)를 다운로드하여 상기 진행중인 NMM 인스턴스 내에서 참조를 위해 일시적으로 보유하고, 브랜치 니즈 계산 (Calculate Branch Needs): 각 브랜치(branch)과 관련된 정의에 따라 니즈는 해당 부서와 연 관되어 있으며, 상기 대칭 처리 결과(Symmetry Processing Result)는 NMM의 상기 검색 알고리즘(Search Algorithm)에 대한 입력으로 입력 목적(Input Purpose)으로서 제공되고, 상기 검색 알고리즘은 상기 컴파일된 니드 인덱스(Need Index)를 참조하여 검색함으로써, 상기 입력 목적이 니드 액세스 개발 및 저장소(Need Access Development and Storage)에서 초기에 정의된 관할권 브랜치(branch) 에 따라 유효한 니드를 정의하는지 여부를 판정하고, 상기 니드 인덱스를 통한 상기 검색 알고리즘의 상기 완료된 실행은 NMM으로부터 모듈식 출력으로서 제출되고 상기 니드 결과로서 참조되는 승인 / 블록 응답을 생성한다. CTMP 내에서 RP2(Raw Perception Production)의 상기 호출과 관련하여 LOM은 AC를 호출하여 상기 이상적인 프 레임워크 구조를 생성하고, 상기 이상적인 프레임워크 구조는 디버깅 추적의 인스턴스를 생성하기 위해 상기 데 이터를 언팩하는 RP2로 제출되며, RP2는 상기 생성된 인지 결과에 관한 상기 데이터를 POE로 전송한다. 이상적인 하드웨어 구성(Ideal Hardware Configuration)을 목적 계층 맵으로 변환하는 LIZARD의 상기 동작과 관련하여, 이상적인 하드웨어 구성이 SM에 제출되고, SM의 논리 감소(Logical Reduction)는 PM의 반복 해석에 그 출력을 제출하며, 반복 해석은 목적 연관성 (Purpose Associations)를 참조하여 해석된 목적 정의를 생성하 기 위해 모든 상호 연결된 함수를 루프하며, 상기 출력은 이상적인 하드웨어 구성의 상기 복합 목적 형식 버전 으로 제시되는 목적 계층 맵으로 라벨링 된다 니드 맵 매칭(NMM)의 동작과 관련하여, NMM은 외부 명령 미들웨어(EIM; External Instruction Middleware)의 동작을 제공하도록 생성되며, 초기 구문 분석(Initial Parsing)은 스토리지로부터 각 관할권 브랜치(branch)를 다운로드 하여 상기 진행중인 NMM 인스턴스 내에서 참조하기 위해 일시적으로 보유하고, 브랜치 니즈 계산 (Calculate Branch Needs): 각 브랜치와 관련된 정의에 따라 니드가 해당 부서와 연관되어 있으며, 상기 입력 목적은 NMM의 상기 검색 알고리즘에 입력으로서 제공되고, 상기 검색 알고리즘은 상기 컴파일된 니드 인덱스를 참조하여 검색함으로써, 상기 입력 목적이 니드 액세스 개발 및 저장소에 초기에 정의된 관할권 브랜치(branch) 에 따라 유효한 필요를 정의 하는지를 결정하고, 상기 검색 알고리즘은 승인 / 차단 응답을 생성하고, 상기 니 드 결과는 EIM 처리 내에서 명령 격리 준비(Instruction Isolation Readiness)로서 리턴 된다 상기 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)의 작동 및 기능 그리고 정적 앱체인 처리 (SAP; Static Appchain Processing)를 통한 Precompiled Application Stack(PAS)의 생성과 관련하여, SAP는 해 당 앱체인 컨텐츠를 해석하고 정적 앱체인 보유(Static Appchain Retention)를 생성하여 PAS에 제출하며, AEL이 컴파일 되고 PAS에 임베드 되어 상기 PAS 인스턴스가 레거시 시스템(Legacy system) 내에서 자율성을 갖게 하며, AEL의 TSID(Target System Interpretation and Detection)가 예비 기본 명령 세트에서 실행하고 상기 타 겟 시스템의 상기 운영 체제, 장치 드라이버 및 하드웨어를 감지하려고 시도하며, AEL은 상기 적절한 번역 메커 니즘을 호출하여 상기 타겟 시스템에서 복잡한 코드를 실행함으로써 상기 정적 앱체인 보유가 완전히 실행되도 록 하고, 상기 보유에는 상기 타겟 앱체인에 대한 상기 앱체인 실행 세그먼트 및 데이터 세그먼트가 상기 타겟 앱체인이 작동에 의존하는 다른 앱체인들과 함께 포함되어 있다 SAP는 상기 타겟 앱체인을 포함하는 정적 앱체인 보유(Static Appchain Retention) 인스턴스를 생성하고, 상기 정적 앱체인 보유는 AEL의 상기 실행 및 데이터 세그먼트 추출(EDSE; Execution and Data Segment Extractio n)에 제출되며, EDSE는 실행 스트림 모음(ESC; Execution Stream Collection)의 상기 호출 및 데이터 스트림 정렬(DSS; Data Stream Sorting)의 상기 호출을 위한 컨테이너 모듈이며, 상기 타겟 시스템은 다양한 시스템 유 형에 적용 가능한 상기 적절한 명령 세트를 정의하는 상기 정적 타겟 시스템 라이브러리 모음(Target System Library Collection)의 고려를 통해 타겟 시스템 해석 및 감지(TSID; Target System Interpretation and Detection) 모듈에 의해 해석되고, TSID는 AEL의 상기 내부 동작이 상기 올바른 계산 명령을 상기 타겟 시스템 에 제출할 수 있게 하는 상기 타겟 시스템 명령 세트를 생성하며, 실행 세그먼트 번역(EST: Execution Segment Translation)은, 상기 적절한 레거시 명령어들로 상기 앱체인 구문을 번역하는 상기 타겟 시스템 명령 세트를해석하도록 호출되며, 데이터 세그먼트 번역(DST)은 상기 앱체인 구문을 데이터의 상기 적절한 레거시 세그먼트 로 변환하는 상기 타겟 시스템 명령 세트를 해석하도록 호출되며, EST 및 DST의 상기 모듈식 출력은 상기 정의 된 타겟 시스템 명령어 세트에 따라 상기 정적 앱체인 보유를 렌더링하기 위해 실행 스트림 렌더링(ESR)의 라이 브 인스턴스를 호출하는 레거시 명령어 통합(Legacy Instruction Unification; LIU)에 제출된다 외부 명령어 미들웨어(EIM)의 작동과 관련하여, 상기 레거시 명령어 통합(LIU)의 ESR 인스턴스 내의 상기 정적 앱체인 보유의 상기 동작은 LIU가 상기 외부 명령 명제(External Instruction Proposition)및 상기 명령 격리 준비 지표(Instruction Isolation Readiness index)를 모듈식 출력으로서 생성하게 하고, 상기 출력은 EIM에 제출되며, LIZARD는 상기 외부 명령 명제를 목적 계층 맵으로 변환하기 위해 호출되며, PRP (Purpose Realignment Processing)은 명령 목적 모음(Instruction Purpose Collection) 및 목적 계층 맵의 모듈식 입력 을 위해 호출되며, 마스터 / 슬레이브 어피니티 (Master/Slave Affinity)는 상기 명령 목적 모음을 상기 슬레이 브로 정의하고, PRP는 상기 명령 목적 모음의 새로운 반복을 생성하며, LIU는 상기 니드 맵 매칭(NMM)을 통해 명령 격리 준비를 생성하기 위해 호출되며, 상기 준비 변수는 상기 명령 목적 모음이 다른 실행 구문들의 간섭 없이 실행될 상기 타겟 시스템 내에서 충분히 격리되는지를 정의하고, 상기 명령 격리 준비 변수가 상기 명령 목적 모음이 상기 타겟 시스템에 배포 될 수 있다는 것을 나타내는지를 평가하는 프롬프트가 활성화되고, 프롬 프트에 대한 상기 응답이 배포 준비 안됨(Deployment Not Ready)일 경우, 다음 외부 명령 명제가 LIU를 통해 ESR에 의해 생성 될 때까지 EIM의 실행을 중지시키는 스테이지가 활성화되고, 프롬프트에 대한 상기 응답이 배 포 준비(Deployment Ready)인 경우, 상기 명령 목적 모음을 TSID에 의해 정의된 상기 대응하는 구문으로 변환하 기 위해 LIZARD가 호출된다 SAP의 상기 동작과 관련하여, 제안된 앱체인 모음(Proposed Appchain Collection)이 상기 관리 인터페이스 (Administrative Interface)로부터 생성되고, 실행 및 데이터 세그먼트 모음은 상기 제안된 앱체인 모음의 상기 참조로부터 생성되며, 상기 제안된 앱체인 모음은 다양한 이벤트에 대한 트리거 포인트를 설치하는 사용자 지정 실행 환경인 상기 MCE(Modified Catch Environment) 내에서 ESR에 의해 처리되므로, 종속성 및 디버깅 정보는 상기 실행 세션에서 파생될 수 있으며, 상기 DRF(Dependency Request Fulfillment)는 SAP 내에서 MCE와 함께 호출되며, ESR에 의해 실행 또는 데이터 요청이 발생되며, ESR에 의해 수행된 상기 실행 또는 데이터 요청이 이 러한 모음에 존재하는지 여부를 결정하기 위해 상기 실행 및 데이터 세그먼트 모음이 평가되며, 프롬프트에 대 한 상기 응답이 존재하다(Does Exist)일 경우 상기 해당 실행 또는 데이터 세그먼트가 NMM에 따라 정당화되는지 평가하는 프롬프트가 호출된다. 상기 제안된 앱체인 모음은 그 후에 앱체인 참조 캐시 보유(Appchain Reference Cache Retention; ARCR)에 저 장되는 독립적인 앱체인 참조(Appchain References)로 분리되어 제출되며, ARCR 내의 모든 앱체인 인스턴스를 순환하는 루프가 생성되고, 상기 선택된 앱체인 인스턴스는 상기 BCHAIN 네트워크에서 상기 BCHAIN 프로토콜을 통해 관련 캐시 노드로부터 검색되고, 상기 이행된 앱체인 인스턴스는 ESC 및 DSS의 호출을 통해 생성되고 처리 된다. 제안된 베이스 라인 홉 경로(PBHP)를 갖는 CCR (Content Claim Request)이 생성되고, CCR은 상기 BCHAIN 네트 워크 상에 제출되어 결국 상기 요청된 앱체인 인스턴스의 일부를 포함하는 해당 캐시 노드(Cache Node)에 도달 하게 되며, 상기 캐시 노드는 상기 CCR을 이행하여 BCHAIN 프로토콜을 통해 경제적으로 보상되고 메타체인의 와 트 경제를 활용함으로써, 상기 캐시 노드는 대응하는 상기 CCR에 응답으로 대응하는 CCF(Content Claim Fulfillment) 유닛을 생성하고, 상기 새로 생성된 CCF는 상기 BCHAIN 네트워크를 따라 이동하여 상기 SAP 인스 턴스를 처리하는 상기 노드의 상기 CCR(Content Claim Rendering) 모듈에 도달하고, 컨텐츠 디코딩 명령 (Content Decoding Instructions)은 이행된 상기 앱체인 인스턴스를 생성 하는 상기 CCF 응답을 렌더링하기 위 해 참조된다. SAP 내의 DRF에 관해서, 프롬프트에 대한 존재 응답(Does Exit)은 해당 실행 또는 데이터 세그먼트가 NMM에 따 라 정당화되는지에 대한 검사를 호출하고, 프롬프트에 대한 상기 정당화된 응답이 발생하면 상기 실행 또는 데 이터 세그먼트가 상기 표시된 세그먼트 캐시 보유(MSCR; Marked Segment Cache Retention)에 포함되도록 표시 되고, 존재하지 않음(Does Not Exit) 응답 및 정당화되지 않음(Not Justified) 응답은 공식 시스템 토큰을 포함 하는 진단 로그 유닛(DLU;Diagnostic Log Unit)를 생성하고 제출하며, 상기 토큰은 상기 UBEC 플랫폼 내의 공식 기능이 존재하는 경우에 해당 기능 또는 프로그램이 비 이상적인 상태에 도달했음을 나타내도록 포함되며, DLU 는 DLS에 제출되며, DLS는 SPSI에 DLU를 제공하기 위해 ARM에 의해 호출되어 SPSI가 DLUA와 함께 DLU에서 발견 된 상기 진단 정보를 처리할 수 있다SAP는 관리 인터페이스(Administrative Interface)를 통해 UBEC 사용자 또는 일반 사용자에 의해 호출되며, 제 안된 앱체인 모음이 수신되고, 루프는 앱체인 참조 캐시 보유(ARCH; Appchain Reference Cache Retention)으로 부터 모든 앱체인 인스턴스를 순환하며, 상기 이행된 앱체인 인스턴스는 MSCR(Marked Segment Cache Retention)에서 검색되고, 이행된 앱체인 인스턴스는 상기 선택한 앱체인을 실행하는 데 필요한 실행 및 데이터 세그먼트의 풀 세트를 포함하며, 모든 상기 이행된 앱체인 인스턴스가, 상기 정적 앱체인 보유에 점진적으로 설 치되며, 각 아웃고잉(outgoing) 실행 또는 데이터 세그먼트가 MSCR에 의해 표시된(Marked) 상태를 갖는 것으로 검증되며, 정적 앱체인 보유는 SAP의 최종 모듈식 출력으로 생성된 다음 모듈식 입력으로 AEL의 EDSE에 제출된 다 CDEE(Cryptographic Digital Economic Exchange)와 그것의 종속성 모듈 LUIGI과 관련하여, 신경 경제 형이상학 적 연구(NMC; Neuroeconomic Metaphysical Contentment)의 상기 핵심 모듈은 관련 기부 구조(ES; Endowment Structure)에 의한 투자를 위해 선택된 지정된 UBEC App에 속한 App Public Funds Allocation(APFA)으로 이동 하는 자금의 자금 이동 감시(FMO; Fund Movement Oversight)를 통해 수행되는, 모니터링 및 규제 인 종합 상태 평가(CSE; Comprehensive State Evaluation)이며, APFA에 보관 된 자금에 대한 암호 접근은 BCHAIN 노드를 통 해 유지되며, ES의 BD 및 ID는 LUIGI의 상기 FRM(Fund Recovery Mechanism)에 액세스 할 수 있다. LUIGI가 상기 UBEC 플랫폼 내에서 앱체인으로 작동하는 것과 관련하여, LUIGI의 호출은 와트 유닛 이동을 규제 하고 CDEE 내에서 와트 유닛 할당 안전성을 보장하며, UBEC 패스 스루(UBEC Passthrough)는 앱체인으로부터 데 이터 전송 정보를 수신하여 CDEE 내의 트래픽 및 활동이 본질적으로 상기 UBEC 패스 스루 후크에 링크되며, LTD (LUIGI Task Delegation)은 상기 UBEC 패스 스루로부터의 상기 인커밍 데이터가 LIZARD, LOM 또는 둘 모두에 의해 처리되어야 하는지를 결정하고, 상기 LIZARD 앱체인의 호출은 상기 '관할 집행 및 의도 판독기 (Jurisdictional Enforcement and Intention Reader)'처리 모드가 선택되었음을 나타내며, 상기 LOM 앱체인의 호출은 상기 '지식 문의 및 사법 중재(Knowledge Enquiries and Judicial Arbitration)'처리 모드가 선택되었 음을 나타내며, 상기 로직 흐름은 동적 API 사용자 정의(DAC; Dynamic API Customization)으로 계속되고, DAC 의 상기 기능은 상기 작업 유형(Task Type)을 해석하여 상기 선택된 API의 상기 인터페이스를 상기 선택된 작업 유형으로 커스터마이징 하는 것이며, 상기 대응 알고리즘 LOM 및 LIZARD가 호출됨에 따라 실행되어 분석 결과를 생성하고, 이는 ICU (Intelligent Conclusion Unification)에 전송되며, ICU는 LOM과 LIZARD간에 해석적 / 주 관적 결론을 조정한다. 상기 CSE 출력의 이상적인 투자 결정 구성(Ideal Investment Decision Makeup)은 상기 UBEC 패스 스루를 통해 수신되고, LUIGI는 상기 구성(Makeup)이 수많은 하위 요소 투자 할당, 투자 인출, 이익 배분 및 이사회 통보 (director notification)의 컨테이너 역할을 하는 것을 인지하며, LUIGI 작업 위임(LTD)은 상기 상응하는 데이 터 출력 구성이 상기 적절한 LUIGI 분석의 브랜치(LUIGI branches of analysis): 지식 문의 및 사법 중재 (LOM), 관할 법 집행(Jurisdictional Enforcement) 및 의도 리더(Intention Reader) (LIZARD)에 의해 분석되도 록 위임한다. LUIGI와 상호 작용하는 앱체인과 관련하여, 상기 UBEC 플랫폼은 상기 UBEC 앱체인과 함께 앱체인으로 나타나며, 이는 상기 UBEC 패스 스루와 연결되어 LUIGI에 모듈식 데이터 입력을 제공하며, LUIGI의 처리 완료 시, 상기 UBEC 포괄 리턴(Comprehensive Return)은 상기 데이터를 상기 UBEC 앱체인으로 되돌려 보내고, LOM은 지식 문 의 및 사법 중재(Knowledge Enquiries and Judicial Arbitration) 브랜치(branch) 내에서 처리가 가능하도록 핵심 앱체인 역할을 하며, LOM 및 LIZARD는, 어느 앱체인이 호출 되는지에 따라 필요에 따른 상기 논리 프로세 스의 상기 관련 사용자 정의를 수행하기 위해 적절한 API 정보에 액세스 하는 DAC(Dynamic API Customizatio n)에 API 사용자 지정 정보를 제공하며, SPSI는 LUIGI의 상기 구성과 동작을 감시, 유지 및 업그레이드한다. DAC와 관련하여, LIZARD 용법 API (LIZARD Usage API)는 DAC의 동작 내에서 제공되며, LTD는 작업 수신(Task Reception)에 정의 된 상기 작업 유형(Task Type)을 결정하고, 상기 제공된 작업 유형은 선택된 브랜치(Branc h)에 제공되는 모듈식 명령 세트를 제공하는 DAC에 대한 커스터마이즈 범위를 나타내며, 상기 모듈식 명령 세트 는 LIZARD 용법 API에 따라 프로그래밍되고, LIZARD는 상기 2 개의 입력을 수행하도록 실행되며, ICU(Intelligent Conclusion Unification)은 서로 다른 모듈 실행의 여러 출력을 조정하여 상기 브랜치 (branch)의 단일 통합 출력을 보장함으로써, LCA (LUIGI Corrective Action)의 단순화된 입력 수신을 허용한다. DAC에 관하여, 상기 LOM 용법 API는 DAC의 상기 작동 내에 제공되며, LTD는 작업 수신에 정의 된 상기 작업 유 형을 결정하고, 상기 작업 타입은 상기 선택된 브랜치(branch)에 제공되는 상기 모듈식 명령 세트를 생성하는DAC 내에서 해석되고, 모듈식 명령 세트는 상기 LOM 용법 API에 따라 프로그래밍되고, LOM은 상기 2 개의 입력 을 이행하도록 실행되며, ICU는 서로 다른 모듈 실행의 복수의 출력을 조정하여 LCA의 단순화 된 입력 수신을 허용하는 상기 브랜치(branch)의 단일 통합 출력을 보장한다. 금융 유동성 조작(Financial Liquidity Manipulation)에서 LUIGI에게 독점적으로 속하는 화폐 유동성 조작 (currency liquidity manipulation) 기능과 관련하여, LSE 내부는 LUIGI가 상기 개인 키의 암호화 된 보유를 해독하여 상기 자금 조작 메커니즘(FMM)이 자금 복구 세션에서 상기 메타체인의 상기 와트 경제에서 자금을 조 작 할 수 있게 하는 보유 암호 해독 키(Retention Decryption Key)이며, 권한 증명(Proof of Authority)은 LSE 로지스틱스로 인해 LUIGI만이 생성할 수 있도록 암호로 보장 된 고유 한 암호화 키이며, 권한 증명(Proof of Authority)는 UBMA 칩을 호출하여 보안에 민감한 고유 개인키(Security Sensitive Unique Private Key)를 제공 하는 데 사용된다 BD 및 ID는 상기 제안 투표 인터페이스(PVI; Proposal Voting Interface)를 통해 DVM과 상호 작용하며, 디렉터 (Director)는 승인된 제안(Authorized Proposal)을 제출하고 ID가 있는 제안서는 유일한 디렉터이며 컨센서스가 없는 딜레마(no consensus dilemma)이기 때문에 ES 내에서 커맨드로서 효과적으로 처리되며, 신규 디렉터 가입 (New Director Admission)은 상기 이사회(the Board)가 새로운 디렉터를 수용 할 수 있는 기회를 제공하며, 제 안은 BD에만 적용되고 ID에는 적용되지 않으며, 신규 디렉터 가입(New Director Admission)의 상기 적용 가능성 은 EPR에 정의 된 정책에 달려 있으며, 기존 정책을 수정하기 위해 DVM을 통해 상기 디렉터들이 수행한 투표는 단일 유닛처럼 처리되는 결합된 한 쌍의 제안, 정책 규칙 추가 및 정책 규칙 삭제에 효과적인 투표이며, 수동 오버라이드 조치 추가(Manual Override Measure Addition)는 CSE에 의해 생성된 상기 이상적 투자 결정 구성 (Ideal Investment Decision Makeups)에 영향을 주는 오버라이드 조치 유지(Override Measure Retention, OM R)에 대한 새로운 커스텀 규칙을 도입하며, 두 개의 ES가 동일한 OMR을 가지고 정확히 같은 시간에 생성된 경우, 그들은 이론적으로 CSE로부터 아주 똑같은 이상적 투자 결정 구성을 받게 된다. 예비 스레드 개시(PTI; Preliminary Thread Initiation)에 관하여, 상기 CSE 호출 간격은 상기 확립된 정책 보 유(EPR; Established Policy Retention)로부터 검색되고, 간격(Interval)은 상기 관련 ES가 얼마나 자주 CSE 인스턴스가 생성되게 할 예정인지를 정의하고, 더 작은 간격은 상기 EPR이 CSE 인스턴스의 더 많은 반복을 호스 팅하기 위해 BCHAIN 요금에 더 많은 와트 유닛을 사용해야 한다는 것을 나타내는 것을 암시하며, 상기 CSE 최종 호출(Last Invocation)의 상기 시간은 EPR에 정의된 값의 저장소로부터 검색되고, 상기 CSE 최종 호출 값은 상 기 특정한 BD 또는 ID와 관련된 특정 변수이고, 상기 해당 투자 자본(IC; Investment Capital)로부터 상기 관련 BCHAIN 노드가 성공적으로 자금을 조달 할 때 해당 AOM2 (Automated Override Measure Manipulation)가 상기 관련 ES의 상기 해당 EPR에서 호출되도록 플래그가 지정되었는지 여부가 평가되며, 특정 타겟 마인드가 CSE에 의해 수행된 상기 투자 결정을 안내하기 위한 것이라면 ES는 AOM2를 사용할 수 있게 하도록 선택할 수 있다 AOM2는 AOM2 타겟 마인드 아디덴티티(Target Mind Identity)를 통해 식별된 타겟 마인드의 상기 반동 기준 (reactionary criteria)을 에뮬레이트 하여 관련 ES의 OMR(Override Measure Retention)에서 제정된 오버라이 드 조치(Override Measures)를 제정, 수정 또는 제거하며, AOM2의 상기 작동의 실질적인 효과는 상기 관련 ES가 상기 타겟 마인드가 예상하는 상기 반응 및 경향에 도움이 되는 OMR을 포함한다는 것이며, OMR의 상기 결과적인 구성은 TICI(Target Investment Circumstances Interpretation)에 의해 생성된 타겟 투자 환경(Target Investment Circumstances)에 영향을 미치므로 CSE에 의해 생성된 상기 이상적인 투자 의사 결정 구성(Ideal Investment Decision Makeup) 상기 TICI 결과 캐시(Results Cache)는 TICI에 의해 원래 처리된 상기 타겟 투자 환경을 생성하기 위해 압축 해제되고 추출되며, 현재 지분 포지션(Current Stake Position)은 포트폴리오 지주 보유(PSR; Portfolio Stake Retention)에서 검색되며, OMR로부터 상기 현재 활성화된 모든 오버라이드 조치 (Override Measures)가 검색되어 액비트 오버라이드 조치(Active Override Measures)로 생성되며, 전에 처리된 변수인 액티브 오버라이드 조치(Active Override Measures), 현재 지분 포지션(Current Stake Position), 타겟 투자 환경(Target Investment Circumstances) 및 AOM2 타겟 마인드 아이덴티티(AOM2 Target Mind Identity) 모 두 축적되고, 축적에 따라, 상기 언급된 변수들은 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)에 공급되어 DMT(Digital Mind Tracking)의 인스턴스를 호출한다. MERM은 DMT에 마인드 에뮬레이션 요청을 생성하기 위해 호출되며, DMT는, 상기 AOM2 타겟 마인드 아이덴티티에 의해 표현된 상기 타겟 마인드를 에뮬레이트 하기 위해 CTMP를 사용하고, MERM으로 다시 보내지는 마인드 인지 결과(Mind Perception Result)를 생성하고, MERM은 필요에 따라 DMT의 여러 인스턴스를 호출하여 최종 결과인 선호되는 오버라이드 조치(Preferred Override Measures)를 정확히 생성하고, 이는 선택될 것이 예상되고 따라서 특정 타겟 마인드에 의해 선호되는 오버라이드 조치를 나타낸다 지능형 투자 예측 서비스에 투자하기 위한 컨센서스에 기반한 결정이 ES로 이루어지며, ES는 상기 예측 서비스 인 종합 상태 평가(CSE; Comprehensive State Evaluation)에 IC를 통해 자금을 지원하며, CSE는 상기 확립된 정책 보유(EPR; Established Policy Retention)에 정의된 CSE 호출 간격에 따라 호출되며, 상기 BCHAIN 프로토 콜을 동작시키는 BCHAIN 노드에 걸쳐 계산 작업이 이루어져, 상기 BCHAIN 네트워크를 형성하며, 상기 관련 IC 내에서 전략적으로 배분된 상기 자금 조작은 상기 메타체인의 상기 와트 경제를 누적 시키며, 자금은 상기 IC 인스턴스 자체에 직접적으로 암호적으로 존재하지 않지만, 대신 자금을 보유하는 BCHAIN 노드에 의해 WUP2를 통 해 저당 잡히며(pledged), 이를 통해 모든 와트 유닛이 물리적인 BCHAIN 노드에 암호적으로 존재하는 동안 상기 와트 경제에 의해 관리된다 CSR은 CSE (Comprehensive State Evaluation)가 프로세싱 중인 ES의 등록된 모든 법인실체의 운영 활동 을 고 려하게 하는, 해당 법인실체 추적 앱체인(Corporate Entity Tracking Appchain)에 운영 정보를 제출하는 등록 된 법인실체가 수행한 정보 보고서를 관리하며, 법인실체(corporate entity)는 상기 법인실체 추적 앱체인에 대 한 운영 활동과 관련된 기록된 데이터의 주요 요소를 공고하기로 결정한 점에서 '등록'되어 있으며, CCG(Content Claim Generator)는 다양한 BCHAIN 노드로부터 컨텐츠를 검색 할 수 있게 하는 상기 BCHAIN 프로 토콜의 기능이며, CRM(Customchain Recognition Module)은 등록된 앱체인(Registered Appchain)에 정의된 앱체 인을 자동으로 유지 관리하는 상기 BCHAIN 프로토콜의 기능으로, DLU 형태의 오류 보고서는 ARM에 의해 상기 진 단 로그 유닛 분석(DLUA)을 통해 상기 오류 보고서를 처리하는 SPSI로 전달되며, 상기 오류 보고 피드백 SPSI와 함께 루프하고 CSR의 상기 프로그래밍으로 이어져 SRIA의 상기 개념에 따라 상기 DLU에 의해 시연된 상기 초기 오류 보고서에 대한 입증된 해결책을 수용하기 위해 변경되고, MRP는 ARM을 통해 시장 활동 및 이벤트를 조사하 는 LOM의 인스턴스를 호출하는 RIP를 통해 CSE의 상기 동작에 의해 개시되며, 초기에는 ARM이 공공 및 프라이빗 소스에서 확인되지 않은 정보를 검색 한 후, LOM 및 CTMP가 미확인 정보를 확인하고 진실된 개념을 생성하기 위 해 확장한다. 규제 / 세금 연구 절차(RTRP; Regulatory/Tax Research Procedure)는, ARM을 통해 세금 및 규제 코드를 리서치 하는 LOM의 인스턴스를 호출하는 RIP를 통해 CSE의 상기 동작에 의해 개시되며, 초기에는 ARM이 공공 및 프라이 빗 소스에서 확인되지 않은 정보를 검색 한 후, LOM 및 CTMP가 미확인 정보를 확인하고 진실된 개념을 생성하기 위해 확장한다. TICI는 상기 해당 ES의 상기 관련 포트폴리오 스테이크 보유(PSR)의 상기 포트폴리오 지분 구성(Portfolio Stake Makeup)을 추출하고, 오버라이드 조치(Override Measures)는 상기 해당 ES의 상기 관련 OMR(Override Measure Retention)에서 추출되며, 오버라이드 조치는 DVM을 통해 의도된 커스터마이즈 효과를 상기 결과적인 이상적인 투자 결정 구성에 유도하며, 포트폴리오 지분 구성 및 오버라이드 조치에 포함된 상기 정보는 타겟 투 자 환경이 되는 추상 컨테이너(Abstraction Container)에 병합되고, 이는 CSE에 제출되며, LOM 및 CTMP의 호출 이 완료되면 이상적인 투자 결정 구성(Ideal Investment Decision Makeup)은 CSE에 의해 생성되며, LOM은 CKR 로부터 시장 활동 지식을 생성하며, LOM은 상기 NMC 지식 호출 프롬프트(NKIP; NMC Knowledge Invocation Prompt)에 의해 그러한 지식을 생성하도록 호출된다. 타겟 투자 환경이 상기 ICIP(Idealistic Configuration Invocation Prompt)에 제공되며, ICIP 에 의해 생성된 프롬프트는 LOM의 IQR에 제출되고, 상기 제공된 프롬프트는 CKR에 의해 분석되며, NMM은 CSE를 제공하기 위해 생성되고, 상기 전체론적 상황 상태(Wholistic Situation State)는 니드 액세스와 개발 및 저장(Need Access and Development and Storage)에 저장을 위해 제출되며, 상기 전체론적 상황 상태는 하위 범주로 나뉘어지고 일 련의 계층적 브랜치 및 레이어로 저장소에 보관되며, 인공 지능 위협(AST)은 상기 컴파일된 니드 인덱스(Need Index)를 참조하고 검색하는 NMM의 상기 검색 알고리즘에 입력 목적을 제공하여, 니드 액세스와 개발 및 저장 (Need Access and Development and Storage)에서 처음 정의된 상기 관할지 브랜치(branches) 에 따라 상기 입 력 목적(Input Purpose)이 유효한 필요를 정의하는지 결정한다. PTI(Preliminary Thread Initiation)는 CSE의 상기 내부 처리 메커니즘에 대한 상기 타겟 투자 환경을 생성하 는 상기 타겟 투자 환경 해석 (TICI; Target Investment Circumstances Interpretation) 인스턴스를 시작하며, 상기 리파인(refined)된 투자 결정 구성은 그 개개의 요소들로 언팩(unpack)되며, 상기 지분 구성이 상기 타겟 투자 환경에 동화되고, 투자 결정 작동(IDA; Investment Decision Actuation)은 상기 제공된 개별 요소를 실행 하여 상기 관련 ES에 대한 상기 의도된 결과를 수행한다. DMT(Digital Mind Tracking)의 상기 작동과 관련하여, TBR(Target Behavior Recording)은 상기 특정 대상 마인 드로부터 직접 행동 데이터 세트(BDS; Behavior Data Set) 정보 및 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement)에 의해 작성된 신경 맵핑 연관(neurological mapping associations)을 수신하며, BDS는 액션 (Action), 문장(Statements) 및 상기 타겟 마인드에 관한 메타데이터(Metadata) 정보를 포함하며, 상기 BDS 인 스턴스는 DMT로 공급되고, 이는 구문 포맷으로부터 목적 포맷으로 변환하는 LIZARD를 통해 정상화 됨으로써, 행 동 목적 맵(Behavior Purpose Map)은 LIZARD에 의해 상기 BDS 인스턴스로부터 구성되며, 상기 행동 목적 맵은 상기 타겟 마인드와 논리적으로 연관되어 있는 PIP(Personal Intelligence Profile) 인스턴스에 저장되고 유지 되며, LOM은 특성 템플릿 유형(Personality Template Types)을 생성하기 위해 호출되며, 특성 템플릿 구성 (Personality Template Makeup)은 상기 특성 템플릿 이행(Personality Template Fulfillment, PTF)으로부터 생 성되며, 특성 템플릿 구성은 상기 타겟 마인드의 상기 특성 템플릿 기준에 따라 특성 템플릿 유형들로부터 존재 하는 특성 요소들을 캡쳐(capture)하고, LOM은 상기 해당 PIP 인스턴스로부터의 상기 타겟 마인드에 대응하는 상기 특성 뉘앙스 정의(Personality Nuance Definition)를 생성하기 위해 호출된다 PTF는 각각의 상기 특성 템플릿 기준을 순환하는 루프를 개시하고, 상기 루프 반복(Loop Iteration)으로부터 상 기 선택된 특성 템플릿 기준은, 상기 특성 템플릿 구성을 생성하는 상기 선택된 특성 템플릿 기준에 정의된 존 재의 크기에 따라 할당된 상기 선택된 특성 템플릿 유형을 생성하는 상기 선택된 특성 템플릿 유형 내에서 참조 되는 상기 특성 템플릿 유형에 따라 상기 대응하는 특성 템플릿 유형을 검색하고, LIZARD는 상기 특성 뉘앙스 정의를 목적 계층 맵으로 변환하고, LIZARD는 상기 특성 템플릿 구성을 목적 계층 맵으로 변환하고, 두 목적 계 층 맵은 모두 두 입력 간의 상기 일치 / 호환성을 결정하는 상기 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing) 의해 처리되어 상기 대칭 처리 결과를 생성한다. 상기 타겟 마인드의 상기 타겟 마인드 아이덴티티가 검색되고, 상기 타겟 마인드 아이덴티티와 연관된 상기 PSCR(Personality Snapshot Cache Retention) 인스턴스가 검색되고, 일치하는 상기 PSCR 인스턴스에 저장된 상 기 특성 반응 시스템(Personality Reaction System)의 이전 반복이 있으면, 정의된 시간대(Defined Time Era) 가 체크되고, 상기 정의된 시간대는 상기 타겟 마인드 아이덴티티로부터 참조되며, 상기 정의된 시간대는 사람 들의 이전 버전과 최신 버전을 구별 할 수 있으며, 만약 그렇다면 상기 특성 반응 시스템의 상기 이전 반복이 상기 PSCR 인스턴스에서 삭제되고, 다음 단계는 상기 타겟 마인드 아이덴티티에 따라 상기 정의된 시간대의 상 기 타겟 마인드와 연관된 상기 PSCR 인스턴스로 상기 현재 특성 반응 시스템을 변환, 저장 및 보유한다. 커스터마이징된 커맨드 세트(Customized Command Set)는 상기 ESR 인스턴스의 스냅샷 캡처인 빈 CTMP 실행베이 스(Empty CTMP Execution Base)를 생성하는 선재 데이터없이 CTMP의 상기 앱체인 컨텐츠 추출을 지시하는 ESR에 제출되며, 상기 빈 CTMP 실행베이스는 ESR의 새로운 인스턴스에서 렌더링되고, 상기 렌더링된 커스텀 CTMP 앱체 인은 상기 커스텀 CTMP 인스턴스에서 상기 타겟 마인드의 상기 특성을 캡처하는 상기 특성 반응 시스템 (Personality Reaction System)과 상호 작용하며, 커스터마이징된 커맨드 세트가 상기 ESR 인스턴스에 명령으로 서 제출되어 모든 변경을 영구 스토리지에 커밋(commit)하고 상기 커스텀 CTMP 인스턴스가 CTMP 스냅 샷 앱체인 보유 파일에 효과적으로 캡쳐되고, ESP(Emulation Scenario Production)가 상기 관련 에뮬레이션 시나리오 세트 (Relevant Emulation Scenarios)를 통해 생성되며, ESP는 상기 특성 반응 시스템의 범위, 관할권 및 기능 에 관련된 관련 에뮬레이션 시나리오를 생성하며, 상기 관련된 에뮬레이션 시나리오에 걸쳐 반복하는 루프가 개시 되며, 상기 루프의 반복마다 단일 유닛 선택된 에뮬레이션 시나리오를 생성하고, 상기 선택된 에뮬레이션 시나 리오는 상기 에뮬레이션 명제(the Emulation Proposition) 및 상기 에뮬레이션 환경(Emulation Environment)을 포함하는 상기 2개의 주요 변수를 생성하기 위해 언팩(unpack)되며, 상기 에뮬레이션 명제는 입력 시스템 메타 데이터로서 상기 커스텀 CTMP 인스턴스에 제출되고, 상기 에뮬레이션 환경은 객관적 팩트(Objective Fact) 분류 를 갖는 상기 커스텀 CTMP 인스턴스에 로그로서 제출된다 상기 타겟 마인드의 신경 패턴을 목표 정황 상태(Target Circumstantial State)에서 캡쳐된 존재의 물리적 상태 와 관련시키는 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement)에 관하여, 작업에 방해가 되지 않는 신경 스캐닝 디바이스(UNSD; Unobtrusive Neural Scanning Device)는 UBEC 사용자로서의 능력 안에서 활 동하는 상기 타겟 마인드로부터 미가공 신경 패턴(Raw Neural Pattern)을 수신하고, UBEC 사용자인 상기 타겟 마인드는 내부 표준 API 커뮤니케이션이 상기 BCHAIN 네트워크를 통해 상기 UNSD로 가능하게 하며, 상기 UBEC 사용자의 상기 미가공 신경 패턴(Raw Neural Pattern)은 UNSD를 통해 수신되고, LOM은 해당 PIP 및 라이프 관리 자동화(Life Administration Automation, LAA)를 통해 상기 UBEC 사용자의 상기 목표 정황 상태 및 신뢰도를 보고하며, LOM은 상기 UBEC 사용자의 상기 디지털 라이프 스타일을 연결하는 상기 타겟 UBEC 사용자 및 LAA에 관한 개인 정보를 보유하는 PIP가 제공 한 데이터를 기반으로 상기 목표 정황 상태를 생성하며, LOM은 잠재적인 신경 상태(Neural State)와 잠재적인 정황 상태(Circumstantial State) 사이의 학습된 상관 관계를 나타내는신경 상태 연관 지식(Neural State Association Knowledge)을 생성하며, 신경 상태 연관 지식 신뢰도(Neural State Association Knowledge Confidence)는 신경 상태 연관 지식의 상기 정확성 및 신뢰성에 관한 LOM의 상기 알고리즘 신뢰도와 상호 관련되며, LIZARD는 신경 상태 연관 지식을 목적 계층 맵으로 변환한다. AEL에 더하여 SPSI에 관해서는, NMC에 MPG(Methodology of Perpetual Giving)를 프로그래밍하고 재구성하는 SPSI는 AEL을 통해 상기 레거시 시스템에서 실행되고, 이는 SPSI가 상기 레거시 API 및 프레임 워크 내에서 존 재하고 작동하는 요소에 액세스하고 조작할 수 있게 하며, SPSI는 NMC를 생성하는 MPG에 대한 효율성 및 기능 업그레이드, 유지 보수 및 일반적인 수정을 수행하며, SPSI는 상기 BCHAIN 네트워크 내의 앱체인이며, SPSI는 상기 커스텀체인 생태계 빌더(CEB; Customchain Ecosystem Builder) 호출을 통해 레거시 프로그램의 NMC를 앱 체인으로의 NMC으로 변환한다."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 1, "content": "도 1 - 2는 동기화되어 있지만 별도의 알고리즘 기준의 인스턴스를 통해 효율적인 공동 작업을 수행하는 UBEC 플랫폼 을 구성하는 해당 서브모듈/ 종속성과 함께 정보 생태계를 보여준다. 유니버설 / 유비쿼터스; BCHAIN 110 (통합 노드 부착 기본 연결 조화 Base Connection Harmonization Attaching Intergrated Nodes);모든 사람, 모든 것, 모든 장소, 모든 시간 (Everyone, Everything, Everywhere, All the Time) (E3A) 경제, 고용, 엔터테인먼트, 교육, 에너지, 교환 등); 연결 (사람, 사물, 아이디어가 다른 것과 연결되어 있거나 연관 이 있는 관계: 커뮤니케이션, 담보(collateral), 창의성, 헌법(constitution), 자본, 상업, 만족, 상품 등) - UBEC 플랫폼 . UBEC 플랫폼 은 소프트웨어 및 하드웨어 기반의 새로운 플랫폼 및 촉매로 주로 스마트 장치를 이용하는 (스마트 폰, 컴퓨터, 사물 인터넷 (IoT) 102 장치 등) 디지털 도메인(디지털 도메인 - 디지털 세계. 디지털 도메인에서 무언가가 행해지면 이는 오리지널 데이터 (이미지, 사운드, 비디오 등)가 디지털 형식 으로 변환되고 이는 컴퓨터의 메모리 내부에서 조작되는 것을 의미)이다. 그러나, 그 용도는 다른 도메인 (예: 아날로그, 어쿠스틱 등)에서도 실현 될 수 있다. UBEC 플랫폼 소프트웨어 및 하드웨어를 사용하면 스마트 장치가 Wi-Fi 핫 스팟 연결 (기존 모바일 네트워크 사용 없이)을 통해 서로 연결할 수 있으므로 장치 및 사용자 가 디지털 정보 사회에 참여할 수 있도록 (디지털 정보 커뮤니케이션 기술(ICT; Information Communication Technologies)을 활용하여), 대체 글로벌 커뮤니케이션 플랫폼 역할을 수행할 수 있다. 이는 UBEC 플랫폼 (소프트웨어 및 하드웨어)을 갖춘 스마트 장치 소유자가 안전하고 효율적이며 합법적이며 사적이며 사용자가 제 어하는 방식으로 모든 디지털 활동 (UBEC 플랫폼 으로 스마트 장치를 사용하도록 허용함으로써 수입을 창 출하는 것을 포함하여)을 수행 할 수 있게 한다. UBEC 플랫폼 의 주요 정의 구조는 BCHAIN (Base Connection Harmonization Attaching Integrated Nodes) 이다. BCHAIN 은 블록으로 불리는 정렬 된 레코드들의 연속적으로 증가하는 리스트를 유지하는 분산 (distributed) 데이터베이스이다. BCHAIN 110은 상호 연결된 스마트 장치를 위한, 정교한 블록 체인(모든 거래 에서 공용 장부(ledger) 역할을 하는 디지털 통화 비트 코인의 핵심 구성 요소) 이용 가능한 어플리케이션(커뮤 니케이션, 협업, 정보 전달, 상거래, 자본, 상호 작용 등을 위함)을 생성하는 프레임워크이다. 따라서 BCHAIN은 데이터 및 장치의 기하 급수적인 성장을 안전하고 효율적으로 처리하기 위한 새롭고 혁신적인 (맞춤형 및 강화 된) 블록 체인 기반의 정보 커뮤니케이션 기술 (ICT) 프레임 워크이다. UBEC 플랫폼 은 CDEE (Cryptographic Digital Economic Exchange) 705 (주식, 펀드(뮤추얼, 인덱스, 헤지, 거래소 등) 소유주들의 주식 거래와 유사)를 통한 금융 서비스와 같은 무수한 서비스 뿐 아니라, -U- (와트 단위) 심볼의 암호화폐를 제공한다. 단일 -U- (와트 단위)의 값은 인공 지능을 사용하는 독점적인 와트 단위 통화 알고리즘 666 (Watt Unit Currency Algorithm) (Al - 시각 인식, 음성 인식, 의사 결정 및 언어 간의 번역과 같은 인간의 지능을 필요로 하는 작업을 수행 할 수 있는 컴퓨터 시스템의 이론 및 개발) 및 입력 / 값과 같은 다음 요소: 1. UBEC 플랫폼 서비스 경제 2. BCHAIN 인프라 경제 3. 에너지 4. 시간 5. 자원 (시장력 등)에 기반하여 파생된다. 다른 암호화 통화에 비교할 때 -U- (Watt Unit)의 주요 차별화 요소는 다음과 같다: 1. 포스트-양자 암호(Post-quantum Cryptography), 2. UBEC 서비스에 대한 지불의 독점 수단, 3. BCHAIN 110 플랫폼의 견고성 4. UBEC CDEE 705, 5. AI 시행 스마트 계약 6. Al 기반 셀프 프로그래밍 셀프 혁신 (핵심 프로그래머 불 필요), 7. LUIGI 기반 자동 관리(auto-governance) 8. Al (알고리즘) 기반 평가. 9. WFE (World Federation of Exchanges)를 통해 다른 금융 거래와 연동하는 CDEE 705 10. 모든 기관에 대한 자동 재정적 성 장 (LOM , MPG, UBEC NMC 114/13300을 사용하여 금융 상품 / 서비스, 적법한 세금 감면 / 준비 및 포트폴 리오 계획 / 관리 /보고의 CDEE 705 포트폴리오에 투자) 11. 셀프 프로그래밍 셀프 혁신 기반의 자동화 된 영구 향상; 12. 디지털 마인드 트래킹 (DMT) 12700 및 신경경제/신경학적 매핑 향상(NME; Neuroeconomic/Neurological Mapping Enhancement). UBEC 플랫폼 은, 모든 것(연결된 디지털 사물 등) 사 이에 보편적 상호 연결성을 제공하고, 모든 곳에서 모두를 디지털 시민으로 만들어 디지털 정보 사회를 제공하 기 위하여, (향후 수 십 년 동안 연결될 것으로 예상되는 수십억 개의 장치 및 수십억 바이트의 제타바이트 (Zettabytes)10007/ 요타바이트(Yotta bytes)10008의 데이터와 함께) 글로벌 디지털 정보 경제를 가능하게 하 기 위하여, 인공 지능 (AI), 증강 지능(Augmented Intelligence), 인지 컴퓨팅(cognitive Computing), 지속적 으로 증가하는 프로그래밍, 에뮬레이션, 적응, 리서치 지능과 함께 SRIA(Symbiotic Recursive Intelligence Advancement), 디지털 마인드 추적(DMT) 12700, 신경 경제 매핑 향상 (NME; Neuroeconomic Mapping Enhancement) / 신경학적 매핑 향상 (NME; Neurological Mapping Enhancement) 13090, BCHAIN 110 (암호화, 적 응 지능, BCHAIN 노드, BCHAIN 프로토콜 , BCHAIN 데이터 무결성 관리 1204와 함께), LUIGI (제정된 UBEC 독립적 관리 지능) 116, 어휘 객관성 마이닝 (LOM; Lexical Objectivity Mining) 132, 영구 기부에 대한 방법 론(MPG; Methology for Perpetual Giving) , UBEC 신경 경제 형이상학 만족 (NMC; Neuroeconomic Metaphysical Contentment) 114, 셀프 프로그래밍 셀프 혁신 , 귀납과 추론 (I2GE 및 LIZARD )을 사용한다. UBEC 플랫폼 은 거대한 퍼즐과 같다. 모든 조각은 서로 접속되고 연결되도록 만들어 졌으며, 조각이 중복되지 않고 각 부분이 자기 파트를 완성하므로, 조각들은 앱체인 과 관련된다. RAM (Raw Appchain Manipulation) 6146은 UBEC 플랫폼 및 앱체인 퍼즐 조각 조화의 주요 핵심인 커스텀체인생태계 빌더 (CEB) 584의 중요한 부분 집합이다. CEB 의 생태계는 거대한 퍼즐을 참조하고 있다. 따라서 RAM 6146은, CEB 를 호출하는 모듈이 CEB 와 함께 앱체인 생태계 (퍼즐)의 모자이크 설정을 결정하는 동안, 퍼즐 조각 수정을 가장 직접 수행하는 모듈이다. SPSI 이 거대한 규모로 퍼즐 조각을 수정하는 것이 그 강력한 예이다. 퍼즐 효율 내에서 새로운 정보를 업데이트하기 위해 노력하는 모듈인 NSA (Null Segment Adjustment) 6900을 비롯하여 다양한 방법으로 퍼즐의 구성이 제어된다. 사물 인터넷 (IoT) 102는 디지털 연결 을 통해 서로 상호 작용하는 장치의 생태계를 나타낸다. 그러한 장치는 냉장고, 자동 온도 조절 장치, 자동차, 차고, 문, 드론 등의 범위 일 수 있다. 따라서, UBEC 플랫폼을 동작시키는 하드웨어 장치는 IoT 생태 계 내의 IoT 장치로서 동작 할 것이다. UBEC 사용자는 사용자 노드 상호 작용을 통해 UBEC 플 랫폼 내에 등록된 생체 정보를 갖는 사람이다. 이는 사용자가 UBEC 플랫폼 내에서 정보 및 거 래에 관한 디지털 거래를 수행 할 수 있게 한다. 따라서, 하드웨어 장치 는, 모든 서브 모듈을 중앙 인터 페이스에 연결하는 일련의 코드화 된 루틴인, UBEC 어플리케이션 / 시스템 에 연결된다. UBEC 어플리케이 션 / 시스템 및 그 열거된 종속성들은 모두 BCHAIN (Base Connection Harmonization Attaching Integrated Nodes) 네트워크 의 상부에서 동작한다. BCHAIN 네트워크 는 BCHAIN 프로토콜 에 따라 소프트웨어를 동작시키는 BCHAIN 노드 로 알려진 일련의 IoT 장치이다. 따라서, 전체 UBEC 플 랫폼 은 BCHAIN 네트워크 의 인공 적응 지능을 통한 노드 분권화 (decentralization), 암호 보안 및 데이터 보존 / 라우팅 효율 최적화의 특징으로 동작한다. BCHAIN 네트워크 의 효율적인 동작은 이 상적으로 UBMA 4260 칩에 의해 처리된다. UBEC 플랫폼 내의 서브 모듈 및 종속성은 앱체인 로서 동 작한다. 앱체인 는 BCHAIN 네트워크 인프라 레이어 상에서 직접 동작하는 데이터 저장, 서빙 및 계 산 프로그램이다. MPG (Methodology for Perpetual Giving) 및 NMC (Neuroeconomic Metaphysical Contentment) 는 UBEC 플랫폼 내에서 인공 지능 투자 결정을 수행하는 앱체인이다. 그러한 결 정은 재무 결정 (예: 세법) 내의 규칙 세트를 활용하기 위한 것이다. LUIGI (Legislated UBEC Independent Governing Intelligence) 116은 UBEC 플랫폼 의 경계 내에서 공정성, 형평성, 정의를 구현하기 위한 인공 지능 집행 메커니즘(artificially intelligent enforcement mechanism)이다. 이를 달성하기 위해 LUIGI 에는 UBEC 플랫폼 내에서 하드코딩 된 영구적이고 취소불능 수준의 관리 및 실행 권한(hardcoded permanent and irrevocable level of administrative and executive privilege)이 부여된다. LUIGI 내 에 존재하는 중앙에 밀집한 권력 집중을 통합하기 위해, 악의적인 프로그램 제작자가 악용 제정(enacting exploits)을 하지 못하도록 SPSI 에 의해 독점적으로 프로그램 되고 유지 관리된다. 또한 종속 하드웨어를 관리하지 못하도록 단일 독립체 또는 조직의 영향력을 절대적으로 제거하기 위해 분산(distributed) BCHAIN 네 트워크 에서만 독점적으로 호스팅된다. 따라서 제 3자는 이를 폐쇄(shut it down)하거나 손상시킬 수 없다. SPSI 은 UBEC 플랫폼 내에서 자신과 다른 앱체인을 자동으로 프로그램 하며 '공식' 지정된 앱체인 이다. 이러한 '공식'지정은 앱체인 이 UBEC 플랫폼 의 핵심 기능 부분임을 나타낸다. LIZARD 은 동적 성장 데이터베이스(dynamic growin database)의 직접적인 도움 없이 실시간으로 모든 잠재적인 사 이버 보안 위협을 차단할 수 있는 중앙 감시 알고리즘이다. 어휘 객관성 마이닝 (LOM; Lexical Objectivity Mining) 은 광범위한 질문 및 / 또는 주장에 대한 객관적인 대답에 최대한 가깝게 접근하려는 정교한 알고 리즘이다. UBEC 사용자 과 협의하여 LOM 입장에 대한 주장을 인정하거나 개선할 수 있다. 주장을 인 정하거나 개선하는 것은 LOM 의 핵심 철학인데, 잘못되었을 때 이를 인정할 수 있어야 UBEC 사용자 의 지식을 통해 배울 수 있기 때문이며, UBEC 사용자 은 처음부터 지식의 대부분을 얻는 곳이다. ARM (Automated Research Mechanism) 134는 LOM 의 일반적인 평가 및 의사 결정 기능을 향상시키기 위해 지속 적으로 CKR 에 새로운 지식을 제공하려고 시도한다. PIP (Personal Intelligence Profile) 136은 UBEC 사 용자의 개인 정보가 여러 개의 잠재적 엔드-포인트(end-points) 및 프런트-엔드(front-ends)를 통해 저장되는 곳이다. 그들의 정보는 매우 안전하고 CKR 에서 분리되어 있지만 LOM 가 개인형 의사 결정을 수행 할 때 이용 가능하다. LAA (Life Administration and Automation) 138은 다양한 BCHAIN 지원 장치 (BCHAIN enabled device)와 서비스를 일상 업무 및 격리 된 사건에 대한 작업을 자동화하는 응집력(cohesive)있는 플랫폼에 연결한다. BM (Behavior Monitoring) 140 모듈은 UBEC 사용자 로부터의 개인 식별 가능 데이터 (personally identifiable data) 요청을 모니터하여 비 윤리적 및 / 또는 불법적 인 내용을 검사한다. EPL (Ethical Privacy Legal) 은 MSNP 로부터 커스터마이징 된 블랙리스트를 수신하고, 비윤리적, 민감 한 개인정보, 및 / 또는 불법적 내용을 포함하는 주장을 차단하기 위해 AOS (Assumptive Override System) 를 사용한다. 스타일로메트릭 스캐닝 (SS; Stylometric Scanning) 은 새로운 외래(foreign) 컨텐츠 (시스템이 아직 노출되지 않은)의 스타일로메트릭 서명(Stylometric Signature)을 분석한다. 이는 데이터 / 주 장에 대한 소스 기대치(source expectations)를 추적하는 데있어 CKR 을 지원하며, 이는 LOM 가 확 증하는 주장(corroborative assertions)을 감지하는 데 더 도움이 된다. 주장 생성 (AC; AssertionConstruction) 은 주장 또는 질문의 형태로 명제(proposition)를 수신하고 그러한 명제와 관련된 개념의 출력을 제공한다. 계층적 매핑 (HM; Hierarchical Mapping) 은 질문 / 주장 일관성에서 확인 또는 충돌 을 찾기 위해 관련 개념을 매핑한다. 그런 다음 주제에 대해 특정 태도를 취할 때의 이점과 위험을 계산한다. 제3자 어플리케이션 및 서비스 , 제3자 알고리즘 및 정보 소스 는 LOM 과 접속한다. 도 2는 제3자 어플리케이션 및 서비스 및 제3자 알고리즘 의 세부 사항을 확대한다. 제3자 어플리케 이션 및 서비스 는 상업 , 검색 , 의료 , 교통 , 교육 및 커뮤니케이션 (16 6)을 포함한다. 제3자 알고리즘 은 LOM 및 그에 따른 UBEC 의 동작 및 기능을 향상시키는 기술 서비스를 제공하는 UBEC 플랫폼 내의 UBEC 사용자 에 의해 개발되고 유지되는 독점 기술의 집합이다. 감정 지능 알고리즘(Emotional Intelligence Algorithm)은 음성 인식 알고리즘(Voice Recognition Algorithm) 을 통해 인식 된 음성 패턴뿐만 아니라 얼굴 표정의 시각적 카메라 피드를 통해 다양한 인간 감정을 감지할 수 있다. 음성 인식 알고리즘 에 제공된다. 음성 인식 알고리즘 은 음성 단어를 텍스트로 표기할 수 있다. 망막 스캔 알고리즘(Retina Scan Algorithm) 은 사용자 노드 상호 작용 (UNI; User Node Interaction) 과 같은 보안 인증 사용법을 보완하는 인간의 눈에 관한 구조를 이해한다. 언어 번역 알고리즘 (Language Translation Algorithm) 은 다양한 언어들 사이에서 자동으로 말해진 문 장, 구문 및 단어를 다양한 언어로 번역하므로, UBEC 플랫폼 내의 거래, 상거래 및 커뮤니케이션을 가능 하게 한다. 얼굴 인식 알고리즘(Facial Recognition Algorithm) 은 사용자 노드 상호 작용 (UNI) 과 같은 보안 인증 사용법을 보완하는 인간의 얼굴에 관한 구조를 이해한다. DNA 샘플링 알고리즘(DNA Sampling Algorithm) 은 머리카락, 피부 또는 타액과 같은 인간 표본에서 추출한 유전적 시퀀스(genetic sequences)를 처리 할 수 있다. 이것은 사용자 노드 상호 작용 (UNI) 및 LOM 에서 처리 된 이론 연 구와 같은 보안 인증 사용법을 보완하여 미스테리를 해결하고 음모(conspiracies)를 확인한다. 지문 인식 알고 리즘(Fingerprint Recognition Algorithm) 182는 UNI 과 같이 보안 인증 사용을 보완하는 인간의 얼굴에 관한 구조를 이해한다. '예측 (Predictification)' 알고리즘 은 다양한 정도의 신뢰를 가진 사회적 사건의 결과에 대한 예측을 주장하기 위해 대중의 사회적 행동을 분석한다. 이러한 신뢰도는 일반적으로 알고리즘 에서 사용 가능한 데이터의 풍부함과 밀도에 따라 다양하다. 스타일로메트리 알고리즘(Stylometry Algorithm) 은 그러한 텍스트의 실제 사용자가 남긴 미묘한 서명을 해독하기 위해 단어 사용 및 실제 필체 특성을 분석했다. 이를 통해 LOM 는 미스테리를 풀고 음모를 확인한다. 도 3 내지 도 6은 UBEC 플랫폼 을 어플리케이션 으로서 다양한 하드웨어 장치에 배포하기 위한 자동 화 된 배포 메커니즘(automated deployment mechanism)을 도시한다. SPSI 은 단계 에서 UBEC 의 핵심 코드 구조 에 소프트웨어, 펌웨어(Firmware) 및 하드웨어 업데이트를 제출한다. 하드웨어 업데이 트는 UBEC BCHAIN 마이크로칩 아키텍처 (UBMA; UBEC BCHAIN Microchip Architecture) 4260의 잠재적 미래 반복 을 참조하며 동적 도전 구조(dynamic conductive structures)를 통해 자체 마이크로 프로세서 어셈블리를 동적 으로 변경할 수 있다. UBEC 플랫폼 은 자신의 분명한 코드베이스 를 가지고 있는데, 이는 분명하지만 직접적으로 BCHAIN 프로토콜 코드베이스 과 의존하고 협력한다. 코드베이스 와 은 모두 BCHAIN 노드 의 다른 하드웨어 및 운영 체제 구성에서 코드베이스 와 의 호환 가능한 실행을 보 장하는 미들웨어 소프트웨어로 작동하는 모듈러 인터페이스 플러그인 에 직접 연결된다. 하이브리드 핵심 로직 (Hybridized Core Logic) 은 이후 다양한 배포 루틴 (198, 200 및 202)을 통해 배포된다. 적절한 배 포 루틴 (198-202)는 선택된 BCHAIN 노드 의 연관성 있는 하드웨어 및 운영 체제 구성에 따라 선택된다. 도 4는 애플 iOS 장치에 최적화 된 배포 루틴(Deployment Routine) A 의 상세한 레이아웃을 도시한다. 206 단계에서 SPSI 은 애플 iOS 앱 스토어에 배포 할 하이브리드 핵심 로직(Hybridized Core Logic)을 준 비한다. 이 206 단계는 배포 루틴 A 를 개시하고, 이후 SPSI 를 호출하는 210 단계를 호출하여 인터 페이스 드라이버 A 가 관련된 및 최신 사양을 완전히 준수하도록 업데이트한다. 단계 208에서 SPSI 는 인터페이스 드라이버 를 하이브리드 핵심 로직에 설치한다. 보다 구체적으로, 인터페이스 드라이 버 A는 UBEC 플랫폼 코드베이스 및 BCHAIN 프로토콜 코드베이스 이 UBEC / BCHAIN 어 플리케이션 216내에서 컴파일 된 대로 BCHAIN 노드의 786 하드웨어 및 운영 체제와 인터페이스 할 수 있게 해주 는 모듈러 인터페이스 플러그인 와 함께 설치된다. 이 어플리케이션 은 애플 iOS 앱 스토어에 배포 준비가 된다. 따라서, SPSI 는 UBEC / BCHAIN 어플리케이션 을 단계 218에서의 애플 iOS 앱 스 토어에 제출한다. 도 5에서, SPSI 는 단계 222에서 UBEC / BCHAIN 어플리케이션 을 컴파일하고 애플 아이폰 OS 앱 스 토어 에 제출하는 대신에 구글 플레이 스토어 를 타겟으로 하는 동일한 절차를 개시한다. 따라서, 인터페이스 드라이버 B의 다른 세트는 SPSI 에 의해 프로그램 된 바와 같이 안드로이드 앱 API 사양 에 따라 사용된다. 인터페이스 드라이버 B는 모듈러 인터페이스 플러그인 에 플러그되어 이제 구글 플레이 스토어 생태계 내에서 실행 및 사용을 위해 최적화 된 UBEC / BCHAIN 어플리케이션 의 컴파 일(compilation)로 이어진다. 따라서 배포 루틴 A 의 UBEC / BCHAIN 어플리케이션 의 인스턴스는 배 포 루틴 B 의 인스턴스와 동일한 코드베이스 및 을 유지한다. 도 6에서, 배포 루틴 C 는 루틴 A 및 B 과 유사한 패턴을 따르지만, 어플리케이션 스토어 사양 들 (Application Store Specification) 214 및 230이 사용되는 대신, 다이렉트 스마트 폰 하드웨어 사양 이 SPSI 에 의해 참조되어 인터페이스 드라이버 C242를 생성한다. 따라서, 결과적인 UBEC / BCHAIN 운영 체제 는 중앙 처리 유닛 (CPU), 그래픽 프로세스 유닛 (GPU), RAM (Random Access Memory) 등과 직접 상 호 작용할 수 있는 완전히 발달한 운영 체제이다. SPSI는 (OS) 의 최신 버전의 운영 체제를 서비스하는 BCHAIN 네트워크 상의 앱체인 으로 업데이트를 제출한다. 따라서 UBEC OS 가 사전 설치되어있는 스마트폰은 서버 엔드포인트에서 공식적이고 암호 서명 버전의 OS 을 확인하는 전통적인 업데이트 메커니 즘을 수행한다. 단계 246에서의 OS 업데이트 메커니즘의 비전통적인 측면은 OS 파일이 BCHAIN 네트 워크 내에서 분산 방식으로 호스팅된다는 것이다. 도 7은 처음으로 UBEC 플랫폼 과 상호 작용하는 비전문가 사용자의 사용 사례 예를 보여준다. 단계 250에 서 비전문가 사용자는 디지털 경제에 참여하고자 한다. 이 단계 250에서 비전문가 사용자의 소유물은 보충 (supplement) 에서 하나의 스마트 폰으로 열거된다. 단계 252에서 비전문가 사용자는 스마트 폰에서 실행 되는 관련 앱 스토어 (예: 애플 앱 스토어, 안드로이드 플레이 스토어 등)에서 UBEC 어플리케이션을 다운로드 한다. 따라서 보충 은 비전문가 사용자가 보충 의 일반 스마트 폰과 달리 하나의 UBEC 지원 스마트 폰을 보유하고 있음을 나타낸다. 비전문가 사용자의 스마트 폰에서 UBEC 플랫폼 을 실행하면 비전문가 사 용자가 '디지털 시민'이 될 수 있도록 다양한 새로운 기능과 상호 작용 방식을 구현할 수 있기 때문에 이것은 중대한 변화이다. 단계 254에서 UBEC 어플리케이션 은 비전문가 사용자의 야망 및 자산에 관한 기초적인 질문을 묻는다. 동의하에, 비전문가 사용자는 UBEC 118에서 처리할 재산, 자산 및 생활 상태 / 생활 양식의 실 시간 비디오 스트림을 기록(record)한다. 단계 256에서, LOM 에 의해 수행 된 분석을 완료하면, UBEC 어플 리케이션 은 비전문가 사용자에게 3 개의 UBEC 100 지원 드론을 사기 위해 xyz 자산을 판매할 것을 권장한 다. 단계 258에서, 비전문가 사용자는 전자 지불 수단이 없기 때문에 UBEC는 LOM 백엔드 서비스를 통해 3 개의 드론을 주문하고 배달 직원에게 현금으로 지불하도록 선택한다. 단계 260에서, 지불 및 드론 수령 후에 비 전문가 사용자는 UBEC 어플리케이션 118의 지침에 따라 UBEC 어플리케이션 118을 사용하여 드론의 레이저 에칭 QR 코드를 스캔한다. 따라서 보충 288은 비전문가 사용자가 현재 UBEC 지원 스마트 폰을 1대에 더하여 최근에 등록 된 3 대의 UBEC 지원 드론을 소유하고 있음을 나타낸다. 단계 262에서 세 대의 드론이 즉시 자동으로 비전 문가 사용자의 재산을 온보드 3D 카메라 (Virtual Reality Ready)를 통해 스캔하기 시작한다. 이를 통해 LOM 는 비전문가 사용자의 재산에 대해 지속적으로 업데이트 되어 LOM 지원의 보다 정확한 응답과 경험 을 갖게 된다. 단계 264에서 3 대의 드론이 즉시 자동으로 인접으로부터 BCHAIN 프로토콜 패킷을 라우팅 하기 시작하여, 비전문가 사용자에게 BCHAIN 네트워크 에 대한 직접 액세스를 부여한다. 단계 에서 비전문가 사용자가 이제 BCHAIN 네트워크 에 연결되어 있기 때문에, UBEC 118은 통신 업체 요금제 (telephone carrier plan)를 취소하고 SIM 카드를 전화기에서 제거할 것을 권장한다. 따라서 보충 290은 비전문 가 사용자가 후속 통신업체 요금 지불을 취소하여 비용을 절감했다는 것을 나타낸다. 단계 268에서, UBEC 118은 비전문가 사용자가 자신의 선불 SIM 카드를 현금으로 지불하기 위해 한 달에 한 번 시내로 오래된 오토바이를 몰고 나간다는 것을 안다. 그러므로, UBEC 는 오토바이를 판매하고 자전거를 구입할 것을 권유한다. 그러므로 보충 292는 비전문가 사용자가 오토바이를 팔고 자전거를 사면 이익을 얻었음을 나타낸다. 단계 270 에서 UBEC는 비전문가 사용자가 BCHAIN 네트워크 을 사용하여 매주 자신의 출신 국가에 거주하는 동생에게 매우 저렴한 국제 전화를 걸 수 있는 방법을 보여준다. 그러므로 보충 294는 비전문가 사용자가 레거시 전화 및 VoIP 시스템을 통한 국제 통화 에 돈을 쓰지 않아도 되므로 돈을 절약할 수 있음을 나타낸다. 단계 272에서 UBEC 는 LOM 집중형 데 이터 마이닝을 통해 비전문가 사용자의 집 위치가 드론 재충전 및 유지 / 보수 수요가 높은 드론 고속도로에 비 교적 가깝다는 것을 알게 된다. 단계 274에서 UBEC는 비전문가 사용자에게 한 번에 16 개의 드론을 수용 할 수 있는 드론 도킹 스테이션과 서비스 수리 키트를 구입할 것을 권장한다. UBEC 118의 이 권장 사항은 비전문가 사 용자의 예산 고려를 기반으로 한다. 따라서 UBEC 118은 오토바이를 판매하여 얻은 현금을 사용하여 전술한 품목 을 구매하도록 비전문가 사용자에게 권장한다. 단계 276에서 비전문가 사용자는 승인하고 UBEC 118은 LOM (13 2)를 통해 가장 높은 등급, 비전문가 사용자에게 가장 적합한 가격의 도킹 스테이션 및 서비스 복구 키트를 가장 신뢰할 수 있는 온라인 판매자를 통해 주문한다. 단계 278에서 비전문가 사용자는 물건을 받고 현금으로 지 불한다. 그는 스마트폰의 UBEC 어플리케이션 118을 사용하여 레이저 에칭(laser-etched) 된 QR 코드를 스캔한다. 그 후, 단계 280에서 UBEC 플랫폼 및 그에 따른 BCHAIN 네트워크 는 인근 드론 고속도로 에서 드레인과 비전문가 사용자의 드론 및 도킹 스테이션의 커뮤니케이션을 자동으로 관리한다. 282 단계에서 비전문가 사용자는 자신의 전기 및 드론 수리 서비스를 다른 무인 비행기에 재판매함으로써 이익을 얻는다. 그 는 -U- (와트 유닛)에 이익을 남겨서 UBEC 플랫폼 에서, 주로 사용자의 맥락과 상황을 고려하여 UBEC 118 가 LOM 를 통해 추천한 필요한 물건이나 서비스를 구매하는데 직접 소비한다. 도 8 내지 10은 UBEC 과 상호 작용하여 자신의 개인 건강을 관리하는 비전문가 사용자를 도시한다. 도 8에서, 단계 296은 사용자가 UBEC 플랫폼 을 운영 시스템 으로서 원래부터 운영하는 스마트 폰을 조작하는 것을 설명한다. 단계 298에서 사용자는 체온, 심장 박동, 땀 흘림 등을 지속적으로 감지하는 UBEC 100 지원 스마트워치를 착용하고 있다. 단계 300은 UBEC 스마트 워치로부터의 사용자의 모든 개인 건강 데이 터가 개별 개인 정보 프로파일 (PIP) 앱체인 에 유지되는 방법을 기술한다. 단계 302에서 LOM (13 2)는 PIP 136 앱체인 에 저장된 개인 건강 데이터와 함께 ARM (Automated Research Mechanism) 앱 체인 의 실행에서 나온 의학 관련 지식을 상호 참조한다. 단계 304에서, LOM 은 BCHAIN 프로토콜의 794 적응형 지능에 의해 생성된 효율성을 이용함으로써 단계 302로부터의 깊은 상호 - 참조 데이터 분석을 수행 한다. 단계 에서, LOM 은 PIP 에 저장된 사용자의 개인 건강 데이터의 패턴이 사용자가 계절성 독감 바이러스에 걸릴 확률이 80% 임을 나타낸다. 단계 에서, LOM 은 사용자가 실제로 아플 잠재적인 중대 한 충돌 및 결과를 이해하기 위해 다음 주 사용자의 예상 스케줄을 분석한다. 310 단계에서 LOM 는 이번 주에 환자가 병에 걸리게 되면 부정적인 결과를 초래할 것이라고 인지한다. 단계 에서, LOM 은 사용 자가 다음 3 일간 예상되는 위치의 인식을 생성한다. 단계 314에서 LOM 는 UBEC 플랫폼 과 레거시 인 터넷에 존재하는 가장 좋고 최신의 여러 디렉토리를 통해 사용자의 예상 위치 근처에 있는 병원을 찾는다. 단계 316에서 LOM 는 사용자의 건강 보험 혜택을 지원하지 않는 모든 병원 후보를 삭제한다. 318 단계에서 LOM 는 UBEC 플랫폼 및 레거시 인터넷의 디렉토리를 통해 나머지 의사 후보의 약속 가용성을 확인한다. 단계 에서, BCHAIN 네트워크 와 관련하여 UBEC 플랫폼 을 통해 LOM 은 약속 시간 가용성 을 확인하기 위해 후보자와 전화 통화를 시도한다. 따라서, 자동 전화 호출 프로세스 가 개시된다. 단계 322에서, 수행 된 다양한 전화로부터 학습된 정보 를 고려하여, LOM 은 예약을 위한 후보 및 시간을 선택한다. 단계 에서, LOM 은 약속을 예약하기 위해 전화 통화를 개시하고 보험, 지불 및 약학 전달 정보를 선택된 후보자에게 안전하게 제출한다. 사용자의 잠재적인 질병의 딜레마의 시간 민감성으로 인해 326 단계에서 LOM 는 가능한 가장 빠른 시간을 예약했다. UBEC 플랫폼 및 사용자의 UBEC 지원 기 기에 부여 된 제어의 선재 사용 권한으로 인해 단계 에서, LOM 은 현재 사용자를 몰고 있는 자 동 파일럿 자동차에게 선택된 병원과 약속을 위해 우회 및 운전을 지시한다 따라서 LOM 는 예방 의학 조치 를 적용하지 않을 경우 발생할 수 있는 결과 때문에, 사용자가 일하러 가는 대신 의사에게 즉시 갈 것을 최우선 으로 추정했다. 330 단계에서 약속이 완료되면, LOM 은 약 전달 또는 픽업을 준비하기 위해 약국에 전화 호출을 개시한다. 도 9는 UBEC 플랫폼 및 BCHAIN 네트워크 를 통해 LOM 에 의해 수행되는 자동화 된 전화 호출 프로세스 의 상세한 논리 흐름을 나타낸다. 프로세스 는, 후속하여 프로그래밍 루프 를 통해 반 복되는 후보리스트 와 함께 시작한다. 단계 338은 루프 으로부터의 선택된 후보가 UBEC 플랫폼 (10 0)의 디렉토리에 존재 하는지를 검사한다. 단계 와 관련하여 YES 조건이 발생하면 논리 흐름은 단계 342로 진행하고, 아니오 조건이면 단계 340로 간다. 단계 340은 UBEC 플랫폼 및 BCHAIN 네트워크 가 아닌 레거시 인터넷 상에 존재하는 참조를 제외하고는 단계 와 유사한 체크를 수행한다. 단계 에서 Yes 조건이 발생하면 로직 흐름은 단계 로 계속된다. 단계 에서 결과가 아니오 조건이면 단계 로 진행한다. 단계 는 후보 루프 에서 선택된 선택된 후보를 제거하고 다음 가능 한 후보자 (있는 경우)로 루프를 반복한다. 그러한 후보자가 후보리스트 에서 이용 가능하지 않으면, 프로세스 의 모듈 실행이 종료된다. 단계 는 루프 로부터 선택된 후보가 UBEC 플랫폼 내 에서, 따라서 BCHAIN 프로토콜 을 통해 동작하는 나열된 전화 번호를 갖는지를 검사한다. 단계 에서 Yes 조건이 발생하면, 논리 흐름은 단계 346으로 진행된다. 단계 342가 아니오 조건으로 이어지면 논 리 흐름은 단계 344로 이어진다. 단계 344는 레거시 전화 시스템에서 작동하는 전화 번호를 확인하는 것을 제외 하고는 선택된 후보자의 연락 가능한 전화 번호에 대한 유사한 검사를 수행한다. 단계 가 Yes 조건을발생시키는 경우, 논리 흐름은 단계 로 진행하고, 반면에 No 조건은 단계 로 진행하여 루프 를 반복한다. 단계 는 관련된 프로토콜, BCHAIN 네트워크 또는 레거시 네트워크를 통해 선택된 전화 번호를 다이얼링한다. 전화 통화가 성공적으로 개시되면, 단계 는 제3자 어플리케이션 종속성(Third Party Application Dependencies) 에서 제3자의 어레이에 의해 이용 가능한 알고리즘 및 기술을 통해 전 화 통화를 수행한다. 그러한 종속성 은 음성 인식 알고리즘(voice recognition algorithms), 음성 합성 알고리즘(speech synthesis algorithms), 대화형 언어 분석(conversational linguistic analysis) 등을 포함 할 수 있다. 단계 로부터의 대화가 성공적으로 완료되면, 통화 내용에 관한 학습된 정보(Learned Information) 가 모듈 출력으로서 제출된다. 도 10은 인공 지능 개인 비서(artificially intelligent personal assistant)로서 개인 건강을 관리하는 다수 의 기능을 동작시키는 앱체인 으로서의 LOM 을 도시한다. LOM 는 PIP (Personal Intelligence Profile) 136 및 LAA (Life Administration and Automation) 138를 절차적으로 참조 한다. 사례 352는 \"미래 처방전 주문 및 비타민 권장\"으로 정의된다. PIP 136은 알려진 조건 등으로 인해 향후 처방에 관한 개인 정보를 안전하게 보관한다. LOM 는 그러한 개인 정보 및 중앙 지식 보유 (CKR) 648에 저장된 일반 의학 지식 및 제3자 공급 업체에 관한 정보를 참조하여 사례 352에서 사용 가능한 비타민을 추천할 수 있다. 사례 354는 \"제3 자 어플리케이션과의 상호 작용을 통한 주요 건강 변수의 일일 모니터링\"으로 정의된다. LAA 를 통해 LOM 에 연결되는 제3자 어플리케이션 및 서비스 는 혈압 등의 건강 변수를 모니터 하는데 사용될 수 있다. 사례 356는 \"건강 / 피트니스 운동 루틴 스케줄링\"으로 정의된다. 일정, 습관 및 루틴에 관한 개인 정보 는 PIP에 저장되므로 LOM는 UBEC 사용자을 위해 맞춤화 된 최적의 시간 및 루틴을 추정 할 수 있다. 사례 358은 \"식이 권장 및 식품 구매 권장 사항\"으로 정의된다. 사용자의 신진 대사, 체중, 신장, 건강 상태에 관한 정보는 앱체인 으로 PIP의 인스턴스에 저장된다. 따라서 LOM는 CKR에 저 장된 의학 지식을 참조 할 수 있으며 LAA은 이후에 사용 가능한 백엔드 서비스를 통해 식품 구매를 할 수 있다 사례 360은 자동 전화 호출 프로세스 의 시작을 유도하는 PIP및 LAA을 참조하는 \"미래 후 속 건강검진 스케쥴링\"으로 정의된다. 사례 362는 PIP 에 저장된 개인 정보, CKR 에 저장된 일반 지 식, LAA의 정보, 장비 및 서비스의 상호 연결성을 많이 참조하는 \"UBEC 활동의 모든 측면에서 건강 생활 코치로 봉사\"로 정의된다. 사례 364는 \"스트레스 관리 권장 사항\"이다. LOM은 다른 사람의 일정에 관한 정 보에 액세스 할 수 있기 때문에 LOM 136은 미래에 예상되는 여러 변수를 해석함으로써 발생하는 스트레스 상황 을 예측할 수 있다. 따라서, LOM은 UBEC 어플리케이션 을 통해 UBEC 사용자 에게 권고를 전달하 여 큰 작업 부하 및 어려운/복잡한 상황을 관리할 수 있다. 사례 366은 일정을 해석하고 UBEC 사용자 의 전체적 및 장기간의 만족도를 높이는 지능형 제안을 추천하는 LOM의 능력을 참조하는 \"취미 / 일 / 라이프 스타일 권장사항\"으로 정의된다 도 11에서 도 21은 LUIGI 의 내부 역학(inner mechanics)에 관한 자세한 설명이다. 도 11 및 12에서 UBEC 패스스루 (Passthrough) 368은 UBEC에서 앱체인 로써 발생하는 정보 트래픽을 수신 한다. 그러한 통과 정보를 분석하면, UBEC 포괄 리턴(Comprehensive Return) 388을 통해 UBEC에 앱체인 로써 리턴되어 앞으로의 여정을 계속하고 UBEC 플랫폼 내의 의도된 목적지에 도달한다. UBEC 패스스루 로부터 들어오는 정보는 데이터가 LOM , LIZARD 또는 둘 모두에 의해 처리되어야 하는지를 결 정하는 LUIGI 작업 위임(LTD) 에 전송된다. 이러한 LTD 결정은 들어오는 데이터의 유형 뿐 아니라 LOM 및 LIZARD 의 능력을 고려하여 수행된다. 따라서 데이터 처리는 LTD에 의해, LOM를 나타내는 지식 문의 및 사법 중재(Knowledge Inquiries and Judicial Arbitration) 또는 LIZARD을 나타내는 관할 집행 및 의도 리더기(Jurisdictional Enforcement and Intention Reader)에 위임된다. 따 라서 LOM 를 나타내는 지식 문의 및 사법 중재 372에 LTD 370으로 데이터 처리가 위임된다. 동적 API 커스 터마이제이션 (DAC; Dynamic API Customization) 은 LOM 및 LIZARD 의 올바른 사용이 구현 될 수 있도록 작업 유형 을 해석함으로써 모듈 (372 및 376)의 동작을 가능하게 한다. 도 13 및 14에는 LIZARD 사용 API 402 및 LOM 사용 API 404 사용 사양이 앱체인 자체에서 정의되는 방식을 보여 주는 DAC 384의 자세한 다이어그램이 포함되어 있다. 이는 단계 에서 작업 유형의 DAC 고려를 통해 모듈러 명령 세트 가 생성되도록 한다. 관할 집행 및 의도 리더기 를 위해 생성된 모듈러 명령 세트 는, 이에 따라 작업 데이터 세트(Task Data-Set)를 처리하는 방법에 관한 LIZARD 입력 단계에 서 LIZARD 에 정보를 제공한다. 모듈의 실행 418 동안 LIZARD 에 의해 도달된 그러한 결정 및/ 또는 추정은 대체 결정 및 / 또는 LOM 에 의해 병행하여 처리된 추정을 고려하기 위해 ICU (Intelligent Conclusion Unification)로 전달된다. 그 후, UBEC 플랫폼 내에서 발생하는 정보 액세스 이벤트 및 거래를 적절히 관리하기 위해 LUIGI 시정 동작 (LCA; LUIGI Corrective Action)이 호출될 수 있다. 도 13의 LIZARD 에 대해 발생하는 동일한 정보 처리 패턴이 도 14의 LOM 에 발생한다. LOM 입력 이 작 업 리셉션 (Task Reception) 으로부터 들어오는 작업 데이터 세트(Task Data-Set) 를 수신하고 처리 하도록 하는 유사한 모듈러 명령 세트가 DAC 에 의해 제공된다. 이러한 정보 처리로 인해 ICU 374에 서 결론 처리가 이루어지므로 LCA 378에서 시정 조치가 제정(enactment of corrective action) 될 수 있다. 도 15는 금융 유동성 조작(Financial Liquidity Manipulation) 에서 LUIGI 에만 독점적으로 속하는 통화 유동성 조작(currency liquidity manipulation) 기능을 도시한다. LUIGI 보안 엔클레이브(LSE; LUIGI Secure Enclave) 은 LUIGI 만 액세스 할 수 있는 정보 보유의 보안 구역이다. 따라서 이론적으로는 LSE 380의 내용을 관찰 할 수 있는 인간은 없는데, LUIGI의 116 코드를 작성하는 권한은 SPSI 에만 독점적 으로 속하고 LUIGI 코드를 실행하는 권한은 LUIGI 자체에 독점적으로 속하기 때문이다. LSE 내에는 LUIGI 가 개인키의 암호화 된 보유(Encrypted Retention of Private Keys)를 해독 할 수 있 게 하는 보유 암호 해독 키(Retention Decryption Key) 가있다. 이것은 자금 조작 메커니즘 (FMM; Fund Manipulation Mechanism) 이 자금 복구 세션(fund recovery session)의 메타체인의 와트 경제 에서 자금을 조작하게 한다. 와트 유동성 거버너(WLG; Watt Liquidity Governor) 은 UBEC 100을 출입하는 유동성 운동의 과도한 급증을 감시하고 잠재적으로 이를 차단하는 LUIGI 의 서브셋(subset) 모듈이다. 이 는 UBEC 100 내에서 점진적이고 예측 가능한 경제를 보장한다. 자금 이동 감시(FMO) 392는 사기와 관련된 유동 성 이동을 감시하고 잠재적으로 차단하는 LUIGI 의 서브셋 모듈이다. 펀드 복구 매커니즘 (FRM; Fund Recovery Mechanism) 은 LUIGI 의 서브셋 모듈로, U (와트 유닛) 펀드의 정당한 소유자가 분실, 도 난 또는 취급 부실의 경우 메타체인의 와트 경제로부터 이를 클레임할 수 있게 한다. 권한 증명 (Proof of Authority) 는 LSE 380 로지스틱스(logistics)로 인해 LUIGI 만이 생산할 수 있는 암호- 그래픽으로 보장 된 고유 암호화 키(unique cryptographic key)이다. 따라서, 권한 증명(Proof of Authority) 은 UBMA 칩 을 호출하여 도 362 및 도 363에 도시된 바와 같은 보안에 민감한 고유 개인 키 (Security Sensitive Unique Private Key) 를 공급하는 데 사용된다. 도 16은 \"제출 확인 + 앱체인의 유지(Verification of Submission + Maintenance of Appchains)\"를 수행 하기 위한 LUIGI 의 기능을 도시한다. 단계 428에서 새로운 어플리케이션 또는 이미 존재하는 어플리케이 션에 대한 업데이트가 UBEC 앱스토어에 제출된다. 그 후, LUIGI 가 LIZARD 기술을 사용하여 올바른 관할권 패턴(jurisdiction patterns)을 식별하여 어플리케이션이 UBEC 에서 필요한지 여부를 이해할 수 있 는 단계 가 실행된다. 따라서, 이것은 LUIGI 작업 위임 (LTD; LUIGI Task Delegation) 이 UBEC 패스 스루 로부터 새로운 어플리케이션 커밋(commit)에 관한 그러한 정보를 수신함에 따라 나타난다. LIZARD 의 실행을 위한 논리 컨테이너 인 관할 집행 및 의도 리더기 는 어플리케이션이 승인 또는 차단되어 야 하는지를 측정한다. 따라서 432 단계는 LUIGI 이 LUIGI 시정 동작(LCA) 에 명시된 실행인 어플리 케이션 제출을 차단하거나 승인한다는 것을 나타낸다. 도 17은 \"계약 조건의 검증(Verification of Contractual Conditions)\"을 수행하기 위한 LUIGI 의 기능을 도시한다. 단계 436에서, LUIGI 는 계약의 지식에서 파생 된 조건을 처리한다. 단계 438에서, LUIGI 은 그러한 조건이 충족되었는지 여부를 해석하기 위해 LOM 기술을 사용한다. 예를 들어 특정 사용자가 사망하여 디지털 마지막 의지와 유언(Last Will & Testament)에 나열된 요청을 실행했음을 검증할 수 있다. LOM 은 CKR 에서의 일반적인 지식, PIP 인스턴스에서의 개인 지식, 및 ARM 을 통 해 (결국 CKR 에 통합되는) 외부 정보를 이용함으로써 그러한 조건 이행을 인지할 수 있다. 따라서 단계 440에서 LUIGI 은 LOM 에 의해 주어진 응답에 따라 계약을 처리한다. 도 18은 \"충돌 해결 어필 시스템(Conflict Resolution Appeal System)\"으로서 LUIGI 의 기능을 도시 한다. 단계 444에서, LUIGI 는 거래 분쟁에 관한 정보를 수집하고 유효화한다. 그 후 단계 446에서 LUIGI 은 LOM 기술을 사용하여 문제에 대한 가능한 평결을 유도한다. 단계 446에 관한 실행 프로세스는 도 14의 지식 문의 및 사법 중재(Knowledge Inquiries and Judicial Arbitration) 에서 발생한다. 따라서 단 계 448에서 LUIGI는 LOM 에 의해 주어진 높은 신뢰 결정에 따라 분쟁에 관한 결과를 강요한다. 단계 448에 관한 실행 프로세스는 LUIGI 시정 조치 (LCA; LUIGI Corrective Action) 378에서 발생한다. 도 19는 \"가상 난독화 행위 모니터링을 갖는 사용자 노드 상호 작용(User Node Interaction with Virtual Obfuscation Behavior Monitoring)\"에 관한 LUIGI 의 능력을 도시한다. 단계 452에서, 사용자는 사용자 노드 상호 작용 (UNI) 을 통해 UBEC 플랫폼 에 대해 인증한다. 이후, LUIGI 은 LIZARD 기술을 원활하게 활용하여 단계 에 의해 지시된 잠재적 악의적 행동에 따라 실제 UBEC 플랫폼 으로부터 사용자 를 가상으로 난독화시킬 수 있다. 도 20은 \"앱체인 합병 후속 검증(Appchain Merge Followup Verification)\"에 관한 LUIGI 의 기능을 도시한다. 단계 458에서 앱체인의 두 버전이 커스텀체인 동기화 & 조화 (CSR; Customchain Synchronization & Reconciliation) 에 정의 된 프로세스를 통해 병합된다. 단계 460에서 병합 이벤트 추적 (MET; Merge Event Tracking) 1836은 어떤 BCHAIN 노드가 합병에 참여 하였는지 추적한다. 단계 에서, 악의적 음 모가 감지되면 그러한 관련 노드의 후속 행동이 추적되어 그러한 합병을 잠재적으로 역전시킬 수 있다. 도 21은 손실 자금 복구 및 사기 활동 반전(Lost Fund Recovery & Fraudulent Activity Reversal)에 관한 LUIGI 의 기능을 도시한다. 일반적인 블록 체인 통화의 경우 키를 잘못 처리하거나 데이터 손상 등으로 손 실된 자금에 대한 복구 메커니즘이 없다. -U- (와트 유닛)은 자금 복구 메커니즘 (FRM) 으로 알려진 인공 지능형 LUIGI 복구 시스템에 어필하여 복구가 가능하다. 처음에 466 단계에서, 사용자는 액세스 할 수 없는 자 금에 관한 클레임 주장을 한다. 그 후 단계 468에서 LUIGI 는 내부 모듈 FRM 을 사용하여 그러한 클 레임의 진실성을 검증한다. FRM 398 모듈은 사용자 노드 상호 작용 (UNI) 470의 인증 기술과 LOM 의 지식 조정 기술에 의존한다. 도 22 내지 26은 사용자 노드 상호 작용 (UNI) 470의 기능을 도시한다. UNI 은 UBEC 1 8에 대한 ID 및 액 세스 관리 (IAM) 메커니즘으로 인증에 직접적인 생체 인식 데이터를 사용하며 사용자 이름이나 계정 컨테이너를 참조하지 않는다. 노드, 데이터 및 서비스는 보안을 강화하고 루틴을 단순화하기 위해 사용자의 생체 인식 데이 터에 직접 연결된다. 초기에 UBEC 사용자 는 단계 472에서 측정 된 생체 인식 데이터를 포함하는 UNI 에 데이터 스트림을 제공한다. 이러한 생체 데이터는 지문 , 눈 망막 스캔 , 음성 인식 및 머리카락 / 피부 등의 DNA 샘플 을 포함할 수 있으나 이에 한정되지는 않는다. UBEC 사용자 는 음 성 인식을 사용하여 무작위로 생성된 챌린지 문장을 말해야 하는데, 이는 음성 녹음을 사용하여 악의적인 행위 자가 UBEC 플랫폼 에 불법적으로 로그인 하려고 시도하는 것을 방지하기 위해서이다. 그런 다음 제공된 생 체 인식 데이터는 생체 인식 데이터 분류 장치 data categorization (BBC) 482로 전송되고 생체 데이터 측정 장 비의 오류 마진으로 인한 생체 데이터 측정의 변형을 제거하는 데이터의 반올림 버전이 생성된다. 따라서, BBC 에 입력 된 각각의 생체 인식 데이터에 대하여, 대응하는 밴드 인증 토큰 (BAT) 이 출력으로서 생성 된다. 그 후, 단계 에 의해 표시된 바와 같이 새로 생성 된 BAT 와 밴드 연관성 앱체인에 저장된 인 증 토큰 사이에 비교가 이루어진다. UNI 는 다중 요소 인증을 본질적으로 사용하므로, 로그인 허가 수여 이전에 하나 이상의 생체 인증 방법이 요구된다. 단계 의 도 23에서, 제공된 생체 정보 데이터의 양이 인증 프로세스에 대해 충분한지 측정되고 검사된다. 인증에 필요한 최소 생체 인식 데이터의 임계 값은 정적 하드 코딩 된 정책 (SHP) 488에 정의되어 있다. 조건 96 \"아니오, 양은 충분하지 않다.\"가 충족되면 인증 시도는 거부되고 UNI 의 모듈러 실행은 단계 496에 나 타난 것처럼 종료된다. 조건 96 \"양은 충분하다\"가 충족되면, 논리 흐름은 생체 정보 데이터의 각 인스턴스 에 대해 생체 인식 밴드 분류 (BBC) 를 호출한다. BBC 의 성공적인 실행 시, 밴드 및 노드 연관 앱체인은 단계 에서 커스텀체인 생태계로부터 업데이트된다. 단계 가 성공적으로 완료되면, 충분한 양의 BAT 가 단일 인증 토큰 514와 매치되는지 측정하기 위하여 단계 에서 검사가 수행된다. 충분한 것으로 간주되는 양은 정적 하드코딩 된 정책 (SHP) 488에 정의된다. 도 24는 단계 494로부터의 논리 흐름을 계속하며, 여기서 밴드 및 노드 연관 앱체인은 BCHAIN 프로토콜 을 통해 커스텀체인 생태계 으로부터 최신 버전으로 업데이트된다. 이것은 가장 정확하고 최신의 인증 정보가 가능하여 인증 절차가 계속 될 수 있도록 보장한다. 따라서 밴드 연관성 앱체인 500과 Node Association 앱체인 502는 최신 상태이며 UNI 절차를 수행하는 노드 (자체)에 로컬로 저장된다. 따라서, 단계 는 밴드 연관성 앱체인 에 존재하는 단일 인증 토큰이 존재 하는지를 검사한다. 성공적인 매칭 및 이에 따른 인증 시에, 인증 토큰 과 연관된 노드 아이덴티티는 단계 에 나타낸 바와 같이 노드 연관 앱 체인 으 로부터 검색된다. 도 25에서, 충분한 양의 밴드 인증 토큰 (BAT) 이 정적 하드코딩 된 정책 (SHP) 에 정의 된 양에 따 라 밴드 연관성 앱체인으로부터의 임의의 단일 인증 토큰 과 일치하는 경우에만 성공적인 인증이 발 생한다. 조건은 충분한 양의 BAT 가 임의의 단일 인증 토큰 과 일치하지 않음을 나타낸다. 따라 서, 인증 시도를 거부하고 모듈 실행을 종료하는 단계 512가 실행된다. 조건 은 충분한 양의 BAT 가 임의의 단일 인증 토큰 과 매칭되었음을 나타낸다. 따라서 관련 인증 토큰 을 밴드 연관성 앱체인 으로부터 검색하고 해독하는 단계 510이 실행된다. 따라서, 단계 510은 단계 506으로 진행하여, 노드 연관앱 체인 으로부터 인증 토큰 과 일치하는 연관 노드 리스트 를 검색한다. 따라서, 단계 는 인증 토큰 및 연관된 노드리스트 를 인증된 사용자 세션 에 패킹하는 단계 로 이어진다. 인증된 사용자 세션 은 UBEC 사용자 가 효과적으로 UBEC 플랫폼 에 로그인하여 UBEC 어플리케이 션 에 로그인하고 연관된 전용 개인 지능 프로파일 (PIP) 앱체인을 가질 수 있게 한다. 따라서 인증된 사용자 세션 522는 UNI 의 실행을 끝내는 단계 524에서 모듈 출력으로 제출된다. 도 26은 생체 인식 밴드 분류 (BBC) 의 보다 상세한 다이어그램을 도시한다. BBC 의 목적은 생체 인 식 장비(예: 지문 스캐너 등)의 예상 오류 마진보다 이러한 데이터의 정확성을 더 명확하게 함으로써 참조용으 로 사용 가능한 입력 생체 인식 데이터를 작성하는 것이다. 따라서, BBC 는 처음에 일반 생체 인식 입력 을 수신한다. 입력 의 입상 분리가 단계 에서 생성된다. 이러한 입상 분리는 데이터 내에서 발견 된 크기의 범위를 정량화하는 형식의 일반 생체 인식 입력 (데이터) 를 나타낸다. 따라서, 지 문 , 망막 스캔 , 음성 인식 , 또는 모발 / 피부 의 DNA 샘플 등으로부터 유도 될 수 있는 생체 정보 데이터 의 다양한 조성은 모두 포맷의 데이터 포인트의 높고 낮음을 강조하는 동일한 포맷 에 서 어셈블(assemble) 된다. 그 후, 단계 는 포맷 을 생성하기 위해 포맷 에서 발견되는 데이터 포인트의 범위를 넓힌다. 참조 에 도시 된 바와 같이, 포맷 의 밴드 범위는 전형적인 생체 인식 장치 에 존재하는 예상 오차 범위보다 크도록 의도된다. 이는 UBEC 사용자 가 암기해야 할 패스워드 또는 사용 자 계정의 필요 없이 세계 어디서나 어떤 장치로부터도 UBEC 플랫폼 으로 자신을 인증 할 수 있게 한다. 따라서, UBEC 사용자 의 개인 데이터는 그들의 생체 인식 데이터 및 그에 따른 사용자 자신과 불가 분하게 묶여있다. 단계 532가 발생하지 않다면 다양한 생체 인식 장치 간의 비 교정의 한계로 인해 UBEC 사용자 은 언제 어디서나 자신의 정보와 서비스에 지속적으로 액세스 할 수 없게 된다. 따라서, 단계 는 단 계 로 진행하여, 형식 으로 생성 된 밴드 카테고리를 밴드 인증 토큰 (BAT) 으로서 저장하고, 이는 이어서 모듈 출력으로서 제출된다. 도 27 내지 28은 커스텀체인 생태계 540을 형성하는 앱체인 의 베이스 레이어 메카닉스(base layer mechanics)을 보여준다. 도 27에서, 커스텀체인 생태계 540은 단일 메타체인과 함께 앱체인, Mi-crochains와 복잡한 상호 작용으로 BCHAIN 네트워크 을 구성하는 프로그램 / 루틴 실행과 함께 효율적이고 동적으로 적용 가능한 데이터 보존 및 시스템을 생성한다. UBEC 앱스토어 542는 LUIGI 에 의해 이미 검사되고 승인된 UBEC 어플리케이션 (예 : UBEC 어플리케이션 A )을 호스트, 리스트 및 서비스하기 위해 커스텀체인 생태계 내에 존재한다. 단계 에서, UBEC 지원 장치 는 UBEC 앱스토어 로부터 UBEC 어플리케이션 A 를 선택하여 다운로드 한다. 그 후 단계 에서 실행 세그먼트는 UBEC 어플리케이션 A 와 상관되는 앱체인 AO (55 4)로부터 수집된다. 단계 550에서 수집된 실행 세그먼트 는 실행 스트림 컬렉션 (ESC) 으로 보내져 이들을 앱체인 AO 으로 어셈블링한다. ESC (실행 스트림 Collection) 에 의해 수행되는 어셈블리는 실행 세그먼트 가 정렬 되어야 하는 정확한 순서를 고려한다. 이는 앱체인 (앱체인 AO 554)의 연대 순에 실행 세그먼트 이 존재하는 순서가 원하는 프로그램을 시행하기 위해 Execution Segments 551을 실행 해야 하는 순서를 필요로 하지 않기 때문이다. 실행 스트림 AO 의 실행 세그먼트 의 이러한 실행은 모듈 실행 스트림 렌더링 (ESR) 에서 발생한다. 실행 스트림 AO 의 처리 및 어셈블과 병행하여 데이 터 스트림 AO 및 Z3 의 처리 및 어셈블이 이루어진다. 따라서, 데이터 세그먼트 는 효율적인 데이터 검색 및 유지를 유도하는 방식으로 정렬되므로, 데이터 스트림 AO 및 Z3 은 DSS 에 의해 어셈블 된 다. 이러한 데이터 스트림 A0 및 Z3 은 ESR 에 의해 참조되어 실행 스트림 AO 에 나열된 명령 을 정확하게 실행한다. 따라서, 참조 된 데이터의 조작은 UBEC 플랫폼 내의 모든 앱체인 및 모듈 (즉, LOM , LIZARD 등)에 대한 빌딩 블록으로 작동하는 코드화 된 루틴에 의해 수행된다. 도 28에서, UBEC 지원 장치 와 관련된 커스텀체인 생태계 가 기본 형태로 도시되어 있다. 다수의 커 스텀체인 생태계 는 보다 큰 BCHAIN 네트워크 를 구성한다. UBEC 어플리케이션 A 및 UBEC 어 플리케이션 B 는 각각 커스텀체인 생태계 을 구성한다. UBEC 어플리케이션 A 와 같은 어플리케이션과 관련되는 각각의 커스텀체인 생태계 에 대해, 컨테이너 앱체인 AO 과 같은 컨테이너 앱체인이 존재한다. 이러한 컨테이너 앱체인은 어플리케이션을 렌더링하기 위 한 정보와 지침의 초기 소스로서 작용한다. 따라서 컨테이너 앱체인은 Supplement 앱체인 클러스터 572 및 574 에서처럼 Supplement 앱체인에 저장된 실행 스트림 및 데이터 스트림을 참조 할 수 있다. 그러므로, UBEC 어플 리케이션 A 는 보충 앱체인 클러스터 에 저장된 정보 (실행 및 / 또는 데이터)를 참조하는Supplement 앱체인 클러스터 에 의해 UBEC 어플리케이션 B 에 존재하는 실행 스트림 및 데이터 스트 림에 의존하는 참조를 할 수 있다. 또한, 커스텀체인 생태계는 독립 앱체인 클러스터와 같은 특정 UBEC 어플리케이션에 속하지도 나타내지도 않는 독립 앱체인을 포함 할 수 있다. 독립 앱체인 Z3 577과 같은 독 립 앱체인에서 별도의 실행 스트림 또는 데이터 스트림을 추출 할 수 있다. ESR 에서 선택한 어플리케이 션의 정확한 전체 렌더링을 유도하는 데이터 스트림 Z3 562의 어셈블리로 연결되는 실행 스트림 AO 556에 정의 된 지침에 따라 DSS 에 의해 독립 앱체인 Z3 577에서 데이터가 추출된다. 도 29 내지 31 은 UBEC 어플리케이션 개발 및 배포 프로세스를 보여준다. 도 29에서, UBEC 사용자 는 사용 자 의 창의성 입력 및 어플리케이션의 전체 구조를 구성하는 의사 결정을 포함하는 세션에서 로지스 틱스 관리자 인터페이스 (LMI) 와 상호 작용한다. LMI 580은 UBEC 사용자 이 로지스틱스 지원 도구 세트를 통해 어플리케이션 및 비즈니스를 작성하기 위한 프론트-엔드 인터페이스이다. UBEC 사용자 , 사용 자 창의성 및 입력 , 및 LMI 사이에 양방향 화살표가 표시되어 LMI 가 양방향 건설 세션에서 UBEC 사용자 에게 디자인 피드백을 리턴시키는 것을 나타낸다. 따라서 LMI 는 LMI 를 통해 UBEC 사용자 에 의해 디자인된 어플리케이션 로지스틱스를 정의하는 일반적인 정보 포맷 인 로지스틱스 계층 을 출력한다. 로지스틱스 계층 은 CEB (커스텀체인 생태계 Builder) 에 입력으로 보내진다. CEB 는 커스텀체인 생태계로 구성되는 기본 빌딩 블록을 사용하여 UBEC 사용자 이 인식하는 Logistical Application을 자동으로 구성한다. 커스텀체인 생태계 540으로 구성된 기본 빌딩 블록을 사용하여 UBEC 사용자 이 인식하는 Logistical Application. 따라서 커스텀체인 생태계 Builder Logic Flow 586은 CEB의 작동을 시각적으로 묘사한다. 논리 흐름 내에서 초기에 앱체인 의 현재 상태가 단계 에서 해석된다. 이는 실행 세그먼트 및 데이터 세그먼트 가 존재하는 관련 위치를 해석하는 것 을 의미한다. 그 후, 단계 590에서 ESC 에 의한 프로그램의 정확한 실행을 보장하기 위해 올바른 순서로 실행 세그먼트 가 실행 스트림 으로 어셈블 된다. 단계 590은 ESC 에 의해 효과적으로 처리된 다. 앱체인 의 블록들로부터 실행 스트림 의 실행 세그먼트들로 이동하는 화살표들은 전형적으로 나 중에 실행 세그먼트 가 실행 스트림 에 대해 획득 한 나중 위치에서 앱체인 에 존재한다. 존재 하는 시간 순서의 경향에도 불구하고, 앱체인의 후속 블록이 이전 실행을 위해 표시된 실행 세그먼트 를 포함하는 것이 가능하다. 이러한 일이 일어나는 실제적인 이유는 커스텀체인 생태계 540에 구축 된 어플리케이 션이 버그 수정, 새로운 기능 등으로 점진적으로 업데이트 및 패치 될 수 있기 때문이다. 이후 592 단계에서 DSS 처리를 통해 데이터 세그먼트 553이 수집되어 데이터 스트림으로 어셈블된다. 후속 적으로 실행 스 트림 및 데이터 스트림 은 모두 CEB 로 구성되는 주요 기본 로직을 저장하고 동작시키는 내부 CEB 로직 프로세싱 에 제출된다. 도 30에서 내부 CEB 로직 프로세싱 은 실행 + 데이터 supplement 를 출력하도록 도시된다. 이러한 supplement 은 앱체인 의 최신 블록에 저장되도록 의도된다. 앱체인 602의 가장 새로운 블록에 새로 추가 된 실행 세그먼트 가 포함되어 있음에도 불구하고, 이는 2.5의 우선 순위 플래그가 포함되어 있다. 이는 ESC 에게 우선 순위 플래그를 보존하는 방식으로 실행 스트림을 어셈블하도록 지시한다. 이는 실행 스트 림 및 데이터 스트림 의 임의의 부분 또는 섹션을 효과적으로 변경하기 위해 CEB 가 앱체인 에 대한 업데이트를 수행하는 것을 허용한다. 데이터 세그먼트 는 또한 검색 우선 순위를 고려하여 데이터 스트림 에 추가된다. 또한, CEB 는 실행 세그먼트 또는 데이터 세그먼트 가 실행 스트림 및 / 또는 데이터 스트림 에 포함되는 것을 효과적으로 금지하는 명령을 앱체인 에 추 가 할 수있다. 이러한 금지 된 세그먼트는 여전히 앱체인의 블록 시퀀스에 존재하지만, 실행 세그먼트에 대해서는 ESC 그리고 데이터 세그먼트 에 대해서는 DSS 에 의해 무시 될 것이다. 도 31은 CEB 의 프로세스 완료 시에 따르는 단계들을 도시한다. CEB 가 완성되면 단계 604로 넘어 가 고 앱체인에 대한 새로운 실행 및 데이터 supplement (요소 596에서와 같이)가 New Content Announcement (NCA) 2544를 통해 BCHAIN 네트워크에서 처리하기 시작한다. 이것은 컨텐츠가 채굴자의 Mempool Data Storage (MDS) 에 제출되는 단계 로 이어지고, 최종적으로 커스텀체인 인터페이스 모듈 (CIM) 을 통해 앱체인 의 다음 블록으로 채굴된다. 단계 에서, 새롭게 채굴된 블록의 내용이 캐시 부분들로 절단되 고 캐시 시드 (MNSCS) 를 공급하는 마이닝 노드를 통해 캐싱 노드들로 전송된다. 그 후, 단계 에서 캐시 부분들은 점진적으로 그리고 자동적으로 데이터를 요청하는 노드에게 가능한 최상의 가동 시간과 다운로드 속도를 보장하는 서비스 최적화 영역으로 마이그레이트 migrate한다. 단계 는 캐시 선택 알고리즘 (CSA) 의 실행을 통해 효과적으로 발생한다. 그 후, 최종 단계 에서 노드는 컨텐츠 클레임 생성기 (CCG) 를 통해 캐싱 노드로부터 컨텐츠를 요구한다. 이러한 노드가 다운로드 되면 ESR 을 통해 실행 스트림을 실행하여 의도 한 어플리케이션의 구현을 유도 할 수 있다. 도 32 내지 36은 커스텀체인 생태계 로 알려진 일련의 앱체인 로서 동작하는 LOM 을 도시한다. LOM 을 정의하는 초기 및 주요 요소는 Ap-pchain의 포맷으로 핵심 모듈을 수용하는 LOM Container 앱체인 614 이다. 이러한 앱체인 은 실행 스트림 을 출력하기 위해 ESC 를 통해 추출 된 Execution Segments 를 갖는다. 이 실행 스트림 은 LOM 을 동작시키는 핵심 모듈로서 실질적으로 나타난다. 이러한 모듈은 UBEC 사용자 가 제공한 초기 질문 / 주장 (assertion)을 수행하고 이어서 중앙 지식 보유 (CKR) 648을 활용하여 질문 / 주장에 대한 이해 및 대답 / 응답에 중요한 누락된 세부 사항을 해독하 는 Initial Query Reasoning (IQR) 이다. SC (Survey Clarification) 620은 UBEC 사용자 과 협력하 여 주장 / 질문이 객관적으로 그리고 모든 필요한 맥락으로 분석 될 수 있도록 보충 정보를 얻는다. 주장 구축 주장 생성 (AC) 는 주장이나 질문 형태로 proposition을 받고 그러한 proposition과 관련된 개 념의 출력을 제공한다. 계층적 매핑 (Hierarchical Mapping, HM) 은 관련된 개념을 하여 질문 / 주장 일 관성에서 확인 또는 충돌을 찾는다. 그런 다음 HM 624는 주제에 대해 특정 태도를 취할 때의 이점과 위험을 계산한다. 개인 및 일반 데이터 병합 (PGDM) 626; 임의의 데이터 요청 정보는 항상 CKR 로부터 액세스된다. 데이터 요청에 개인적인 기준이있는 경우, PIP 가 참조되고 메인 CKR 지식을 구축한다. 합리적 어필 (RA) 628은 CTMP 기술을 사 용하여 자기 비판인지 또는 사람의 반응에 대한 비판인지 주장을 비판한다. 지식 검증 (KV) 은 질의 능력 및 CKR 로의 동화(assimilation)를 위해 논리적으로 분리 될 필요가 있는 고도로 confident & 미리 비판 된 지식을 받는다. 교차 참조 분석 (CRA) 에 의해, 수신 된 정보는 CKR 로부터의 기존 지식을 고려하 여 비교되고 구성된다. 이것은 새로운 들어오는 정보가 CKR 이 현재 알고 있고 모르는 것에 따라 평가되고 유효화 될 수 있게 한다. 따라서 실행 스트림 596은 ESR 에 의해 실행 된 후에 실제로 나타난다. 도 33에서, UBEC 시스템와이드 로직 은 UBEC 플랫폼 내의 다른 앱체인 과 상호 작용하는 LOM 컨테이너 앱체인 을 나타낸다. 따라서, 데이터 세그먼트 는 UBEC 시스템 전체 로직 으로부터 LOM 컨테이너로 도착한다. 데이터 세그먼트 는 실행 스트림 에 의해 정의되고 실행 스트림의 모듈 형 매니페스트 로서 열거된 LOM 의 핵심 로직과 관련하여 ESR 에 의해 처리된다. 이러한 입력 데 이터 세그먼트 는 LOM 질문 / 주장 입력 으로 나타난다.. 따라서, 이 경우에 LOM 의 효과 적인 실행인 ESR 의 실행은 LOM 질문 / 어서션 입력 에 대한 LOM 공식 응답으로서 UBEC 시스 템와이드 로직 으로 되돌아 오는 데이터 세그먼트 를 출력한다. 도 34는 요소에 도시된 바와 같이 자신의 독립적인 앱체인 으로서 Central Knowledge Retention (CKR) 이 존재하는 방법을 도시한다. 따라서 앱체인 650 으로서 CKR 은 LOM 컨테이너 앱체인 614와 LOM 모듈, AC 622, Hierarchical Mapping (HM 624), Knowledge Validation (KV) 630, Personal & General Data Merging (PGDM) 626 및 CRA (Cross Reference Analysis) 과 병렬로 상호 작용한다. 앱체인 650과 함께 도시된 것처럼 블록의 대부분의 내용은 데이터 세그먼트 553이며 방대한 소수는 실행 세그먼트 이며 이는 CKR 이 복잡하고 정교한 데이터베이스이기 때문에 기대된다. 또한 LOM 컨테이너 앱체인 614의 합리적 어필 (RA) 628이 CTMP를 앱체인 124와 어떻게 상호 작용하고 의존하는지 보여준다. 도 35는 앱체인 으로서 개인 정보 프로파일 (PIP) 의 인스턴스를 도시한다. CKR의 648 앱체인 650에 서 발견되는 더 많은 블록과 대조하기 위해 더 적은 블록이 앱체인 654에 표시된다. 이는 CKR 앱체인 650 전체가 PIP 136 앱체인 654 인스턴스보다 크기가 훨씬 더 클 것으로 예상된다. 각각의 UBEC 사용자 는 그 들 자신의 독립적인 PIP 136 앱 체인 을 갖는다. PIP 앱체인 인스턴스는 LOM 컨테이너 앱체인 의 CRA (Cross Reference Analysis) 632 및 PGDM (Personal and General Data Merging) 모듈과 상 호 작용하는 것으로 도시되어있다. 도 36은 LOM 라이프 관리 및 자동화 (LAA) 모듈 이 어떻게 병렬 보충 앱 체인 으로서 존재하는 지 도시한다. 따라서 LOM의 132 프론트 엔드 서비스 660 및 백 엔드 서비스 662는 LAA 138과 앱체인 658의 상호 작용의 엔드포인트이다. 동시에, LOM 컨테이너 앱체인 은 UBEC 시스템와이드 로직으로부터 수신한 LOM 질문/ 주장 입력 을 LAA 를 포함하는 보충적인 앱체인에 제공한다. 도 37 내지 39는 UBEC 플랫폼 및 BCHAIN 네트워크 내에서 사용되는 교환 매체에 관한 유동성의 주 요 기능을 작동시키는 와트 유닛 (-U-로 표시) 통화 알고리즘 을 보여준다. 와트 단위 (Watt Unit)는 알고 리즘 적으로 전기의 가치, 즉 에너지에 고정되어 있는 본질적인 가치를 지닌 암호화 통화이다. 에너지는 귀중한상품이므로 UBEC 플랫폼 경제 내에서 엄청난 추측과 변동성이 존재하는 것을 방지한다. UBEC 플랫폼 (10 0)의 성장을 인위적으로 제한된 에너지 수준으로 제한하지 않도록 하기 위하여, 유통되는 와트 단위 (디플레이 션 모형이 아님)의 양은 고정되지 않는다. 대신, 와트 단위는 유동성이 UBEC 경제로 들어가고 빠져 나올 때 단 독 거버너(governor)인 LUIGI 에 의해 직접 생성되고 파괴된다. DEPS (Distributed Energy Price Survey) 668은 현재 전기 요금의 명목 화폐를 보고 할 수 있는 BCHAIN 노드 의 모듈이다. 그러한 노드 은 BCHAIN Network 10에 참여하는 주택에 설치된 전기 계량기 일 수 있다. TPCE (Third Party Currency Exchange) 672는 명목 화폐의 매매를 관리하는 로지스틱스 계층 역할을 하는 모듈 이다. 이것은 유동성이 메타체인의 와트 경제 안팎으로 흐르게 한다. TPCE에서 와트 단위 판매 및 구 매를 모색중인 UBEC 사용자는 본질적으로 교환에서 쌍을 이루고 있다. 와트 단위의 명목 화폐 가치가 DEPS 668 에 의해 보고된 가치로 고정되어 있기 때문에 협상 및 시장 가격 발견에 긴 지연이 없다. UBEC 사용자 이 와트 단위를 구매하면 구입한 금액이 열거된 검증된 거래보고서가 LUIGI 로 보내진다. LUIGI 의 거래 승인에 따라, 와트 유닛을 구입하는 사용자의 단계 682는 LUIGI 이코노미 인터페이스 (LUIGI Economy Interface) 686의 와트 단위 생성 688으로 이어진다. 이와 비슷하게, UBEC 사용자 이 와트 단위를 판매하 면 구입 금액이 열거된 검증된 거래보고서가 LUIGI 로 보내진다. LUIGI 가 거래를 승인 한 후, 와트 단위를 구매하는 사용자의 단계680는 LUIGI 경제 인터페이스 686의 와트 단위 파괴 690으로 이어진다. 따 라서 UBEC 플랫폼 에 대한 유동성 흐름은 모두 LUIGI의 116 자금 이동 관리 (FMO) 392 모듈의 감독을 받는 다. LUIGI 이 와트 유닛을 생성하거나 파괴하기 위해서는 모듈 LEI 는 자금을 보유하고 있 는 UBEC 사용자 와 관련된 노드에 관한 692단계로부터의 신원 정보를 수신해야 한다. BCHAIN 네트워크 10 내에서 데이터 전송, 보존 및 CPU 처리의 기능적 경제를 유지하기 위해 BCHAIN 프로토콜 에있는 다양한 유 형의 작업 속도가 WWR (Work to Watt Reporting) 670 모듈에서 추적된다. BCHAIN 프로토콜에 존재하는 작업 유 형은 메타체인 / 앱체인 / 마이크로체인, 캐싱 컨텐츠 파트, 네트워크 라우팅 (CCR / CCF), 데이터 레퓨지 파인 더, DC2 에뮬레이션, 메타체인 보유, 노드 캐시 검증, 진단 로그 보유를 마이닝 하는 것이다. 676 단계에서 BCHAIN 노드는 X 작업을 수행 한 후 WWR 670을 통해 메타체인 834의 와트 추적으로의 작업 (Work to Watt Tracking) 860으로 X 작업을 수행하는 데 소비된 와트의 양을 보고한다. WUMFC (Watt Unit Minimum Fee Calculator) 684은 BCHAIN 네트워크 1 0에서 작업하는 데 필요한 최소 수용 가능한 요금을 계산하기 위해 메타 체인 834의 와트 추적(Watt Tracking) 860을 참조한다. 단계 에서, BCHAIN 노드 는 Y 양의 작업 (데 이터 전송, 데이터 저장 등)을 원하기 때문에 노드는 WUMFC 모듈을 참조한다. 필요한 최소 수수료를 초과 하는 금액은 데이터 전송 및 보존에 있어 중복을 용이하게 하여 그러한 서비스의 품질 및 신뢰성을 향상시킨다. 도 38은 도 37과 같은 와트 유닛 구매 및 판매의 동일한 메카니즘을 나타내지만, 사용자 노드 상호 작용 (UNI) 을 통한 사용자 인증의 통합과 함께이다. UBEC 사용자 의 성공적인 인증시, UNI 는 인증된 사용 자 세션 을 출력한다. 인증된 사용자 세션 은 단계 에 의해 사용되는 연관된 노드리스트 를 포함한다. UNI 에 의해 제출 된 인증된 사용자 세션 은 또한 와트 유닛의 구매 및 판매 에 필요하다. 도 39에서, FMO 및 LEI 의 기능은 사용자 프라이빗 펀드 할당 (UPFA) 에 대한 지식 및 액세스 를 요구한다. LUIGI 및 UBEC 사용자 만이 UPFA 에 정의된 노드에 의해 보유된 자금을 조작할 수 있다. 따라서 FMO 392 모듈과 LEI 686 모듈이 LUIGI 의 관할권 내에서 운영되는 이유이다. UPFA 718의 자금 할당은 유형 (컴퓨터, 전화, 무인 항공기 등), 이력, 신뢰성 등에 따라 노드를 통해 전적으로 배분된다. 그러한 지능형 자금 할당은 노드가 파손 / 도난 당하는 위험을 줄이기 위해 수행되며 이로 인해 의도하지 않았 지만 노드와 관련된 자금이 손실된다. 그러나 대체 메커니즘은 LUIGI의 116 FRM (Fund Recovery Mechanism)을 사용하는 것이다. 그러나 FRM은 상당한 시간을 요구할 수 있는 subject 프로세스이며 요청이 부당하게 거부되는 결과를 초래할 수 있다. 이러한 위험과 단점으로 인해 UPFA 시스템이 위험을 완화하기 위해 가장 적합한 노드 에 지능적으로 자금을 할당하는 것이 매우 바람직하다. 도 40 내지 42는 CDEE (Cryptographic Digital Economy Exchange)를 보여 주며, CDEE는 어플리케이션을 구입하 고 그것들에 공공 주식처럼 투자도 할 수 있는 마켓 플레이스이다. 성공적인 인증 시 UNI 는 UBEC 플랫폼 에 존재하는 어플리케이션에 자동화 및 수동 투자를 가능하게 하는 인증된 사용자 세션 (52 2)을 제출한다. 단계 706은 UBEC 사용자가 MPG (Methodology for Perpetual Giving) 가 적절한 앱체 인에 자동으로 투자하도록 인증하는 것을 설명한다. 대조적으로, 단계 는 잠재적으로 투자를 선택하기 위 해 UBEC 사용자 가 수동으로 앱 디렉토리 및 탐색 (ADE) 을 탐색하는 것을 설명한다. 시나리오 712에 서 UBEC 사용자 는 자신의 개인 자금에서 앱 공용 자금으로 이전함으로써 어플리케이션에 투자한다. 시나리오 714에서, 사용자는 자신의 지분 가치를 앱 공용 자금에서 그들의 개인 자금으로 이전함으로써 이미 존재하 는 투자를 앱으로부터 복구한다. 개인 자금은 UPFA 718에 의해 보유되고 유지된다. 시나리오 712와 714는 모두 716 단계로 진행하여 AIR (App Investment Registrar) 722에 대한 적절한 수정이 이루어진다. 도 41 - 42는 ADE (App Directory and Exploration) 710 모듈에 나열된 UBEC 앱이 투자 측면에서 유동성을 송 수신 할 수 있는 방법을 보여준다. UBEC 사용자 과 UBEC App간에 유동성 이동을 수행하기 위해 앱체인 과 같은 4 개의 모듈 인스턴스: APFA(App Public Funds Allocation), AIR(App Investment Registrar) , AET (App Expenditure Tracking) 그리고 APD (App Profit Distribution) 가 호출된다. 시나리오에서, 사용자 는 APFA 를 통해 자신들의 UPFA(Private Funds---) 에서 앱 공공 자금으로 이전함으로써 앱에 투자한다. 그 후 716 단계는 AIR 722에 대한 적절한 수정이 이루어질 때 발생한다. 이러한 수정은 투자가 이루어진 해당 앱에 적용된다. 동일한 사건 패턴은 시나리오 714에서 UBEC 사 용자 이 철회할 때 발생한다. 시나리오 714에서 UBEC 사용자 는 자신의 지분 가치를 앱 퍼블릭 펀드 (App Public Funds)에서 그들의 사적 기금 (UPFA) 718로 이전함으로써 이미 존재하는 투자를 앱으로부터 회수한 다. 시나리오 712와 유사하게, 시나리오 714는 AIR 에 대한 적절한 변경이 이루어질 때 발생하는 단계 716 로 이어진다. 도 42는 UBEC 사용자 의 UPFA와 직접 상호 작용하는 동일한 UBEC 앱 A 및 UBEC 앱 B 를 도시한다. 앱 지출 추적 (AET) 은 UBEC 앱과 관련된 모든 지출 및 앱을 관리하는 UBEC 사용자 를 추 적한다. 따라서 AET 724는 현재 및 잠재적 투자자들에게 공공 투명성의 한 형태로 작용한다. AET 724는 지출 정 보를 App Profit Distribution (APD) 726에도 보낸다. APFA 720에서 현재의 시장 가치 및 공공 기금을 참조하 여 APD 726은 이익을 계산하여 관련 투자자 (UBEC 사용자 )에게 분배할 수 있다. 도 43-44는 UBEC 플랫폼 인터페이스 (UPI) 와 캐시 작업 수락 (CWA) 간의 상호 작용을 도시한다. UNI 의 실행은 UPI 와의 인증된 사용자 세션 으로 이어진다. 따라서, UBEC 사용자 는 프 론트 엔드 사용자 인터페이스 를 사용하여 경제적 특성 을 선택할 수 있다. 경제적 특성 740의 세부 사항은 아래와 같다: 특성 A: 이퀄라이저 732는 노드 자원이 UBEC 사용자 가 소비하는 것만 일치시 키도록 소비되는 경우이다. 특성 A 732는 가볍고 적당한 양의 정보 전송을 원하는 일반 소비자에게 이상적이다. VoIP 통화 (예 : Skype) 및 우선 순위 정보 전송과 같은 실시간 스트리밍은 최소화된다. 특성 B: 이익 734는 이 익 마진이 X보다 큰 한 노드 이 가능한 한 많은 로컬 자원을 소비하는 경우이다. 그 후 잠재적 인 이익을 실현하기 위해 과잉 와트 단위는 암호화폐, 명목화폐 (flat currency), 귀금속 등과 같은 대체 통화로 거래 될 수 있다. 특성 B 734는 이익 동기를 위해 BCHAIN 네트워크 의 인프라에 기여하도록 특별히 설정된 노드 에 이상적이다. 따라서 이러한 노드 은 일반적으로 배터리 구동 장치와 달리 주 전원에서 실행되는 영구 인프라 설치이며 강력한 컴퓨터 내부 (무선 기능, CPU 강도, 하드 디스크 크기 등)를 갖추고 있다. 특성 C: 소비자 736은 거래 된 통화 (암호화폐, 명목화폐, 귀금속 등)를 통해 UBEC 사용자 이 와트 단위를 지불 할 때 노드 자원을 덜 소비하면서 컨텐츠를 사용할 수 있도록 하는 것이다. 특성 C 736은 정보 전송의 많은 소비자 또는 BCHAIN 네트워크 에서 Device 786의 자원을 고갈시키지 않고 이익을 얻으려는 사람에게 이상적이다 (즉, 스마트폰은 배터리를 빨리 소모하고 주머니 안에서 따뜻해진다). 특성 D: Altruistic 738은 노 드 자원이 가능한 한 많이 소비되고 컨텐츠 또는 소비 보상에 관계없이 아무 것도 기대하지 않는 어떠한 제한도 없는 경우이다. 특성 D 738은 BCHAIN Network 110의 강점에 가장 관심이 있는 사람이 선택한다 (예 : BCHAIN Protocol 794의 핵심 개발자는 네트워크 110을 강화하기 위한 노드를 구입하고 설치할 수 있으며 컨텐츠 를 소비하거나 와트 단위를 얻지 못한다). 따라서 선택된 경제적 특성 740은 캐시 작업 승인 (CWA) 742의 관할 권 내에서 운영되는 경제적으로 고려되는 작업 부과 (ECWI) 744에 제출된다. 도 44는 CWSI 가 획득된 와트 유닛에 관한 이 노드 의 현재 잉여 / 결손 을 결정하기 위해 메타 체인 의 와트 경제 를 참조하는 방법을 도시한다. 따라서 현재 작업 잉여 / 적자 746은 ECWI 744로 전달되며, ECWI 744는 선택된 경제적 특성 740과 잉여 / 적자 746를 고려하여 더 많은 작업이 현재 수행되어야 하는지 평가한다. 그러므로, 단계 748은 ECWI 의 결과적인 출력을 평가한다. 결과 는 다음과 같이 기 술된다: 작업을 피함, CCR 또는 CCF 에 관한 BCHAIN 처리를 계속하지 않는다. 결과 는 다음 과 같이 기술된다. 작업을 더 수행함, CCR 또는 CCF 를 캐시 선택 알고리즘 (CSA) 으로 전 송하여 BCHAIN 처리를 계속한다. 노드 상호 작용 로직 (NIL) 은 커뮤니케이션 게이트웨이 (CG) 의 관할권에서 동작하고 캐싱으로 간주되는 초기 CCR 또는 CCF 를 제공한다. 도 45 내지 46은 BCHAIN 프로토콜 (BP) 의 개요를 나타낸다. 도 45에서, 라우팅 로직 (RL) 은 BCHAIN 네트워크 내의 데이터 라우팅을 처리하는 주요 모듈을 참조 한다. QIB (Queued Information Broadcast) 는 다른 노드로 방송하기 위해 예정된 CCR 또는 CCF 를 관리한다. 정보 CCR 및 CCF 의 그러한 패킷은 BCHAIN 프로토콜 (BP) 및 노드 하드웨어 인터페이스 간의 인터페이스의 배타적 계층 인 커뮤니케이션 게이트웨이 (CG) 로 전달된다. 커뮤니케이션 게이트웨이 (CG) 또한 주변 노드들 에 관한 정보를 노드 통계 측량 (NSS) 에 전달한다. NSS은 계산될 네 가지 인덱스 즉, 노드 이스케이프 인덱스 , 노드 포화 인덱스 , 노드 일관성 인덱스 , 노드 오버랩 인덱스 의 형성을 야기하는 주변 노드의 행동을 추적 한다. 노드 이스케이프 인덱스 (Node Escape Index) 는 노드 인접이 감지 노드 부근을 벗어 날 가능성을 추적한다. 노드 포화 인덱스 는 감지 노드 의 감지 범위 내의 노드 의 양을 추적한 다. 노드 일관성 인덱스 는 감지 노드 에 의해 해석되는 노드 서비스의 품질을 추적한다. 노드 오버랩 인덱스 는 노드 가 감지 노드 에 의해 해석되는 것과 중첩되는 노드 의 양을 추적 한다. 인지 노드 는 설명에서 구상되고 있는 NSS 의 인스턴스를 실행하는 노드이다. 결과적인 4 개의 변수 (886, 888, 890, 892)는 노드 사이에서 프로토콜 컨센서스를 강요하는 전략 확인 시스템 (Strategic Corroboration System; SCS) 으로 보내진다. 따라서 악의적인 의도를 가지거나 단순히 BCHAIN 프로토콜의 불법적인 변경을 실행하는 악의적인 노드는 컨센서스 및 작업 완료에 참여하는 것이 금지된다. 동적 전략 적응 (Dynamic Strategy Adaptation, DSA) 은 계산 된 전략 기준 구성 (Strategy Criteria Composition)에 기초한 전략 배포 를 동적으로 변경하기 위해 NSS 변수를 수신한다. 전략 기준 구성 992에는 핵심, 중요 및 보완 요소에 BCHAIN 프로토콜 이 어떻게 작동하는지 알려주는 다양한 변수가 포함되어 있다. 전략 배포 916은 DSA 772에 의해 생성된 다음 BCHAIN 프로토콜 (BP) 794 내에서 작동하는 다른 많은 모듈 중에서 QIB 2700 및 CG 2348에 의해 참조된다. 등록된 앱체인 776은 다양한 앱체인 (일반적으 로 UBEC 어플리케이션의 앱체인 컨테이너)의 암호화 액세스 키를 포함한다. 따라서 Metchain의 834 앱체인 Updates 846에서 앱체인 에 대한 업데이트가 공고되면, 그것들의 장치가 앱체인 에 최신 업데이 트를 다운로드 한다. 이것은 등록 된 앱체인 776에 저장된 암호화 키로부터 유래 된 Cryptographic of Proof of Entitlement 2314로 나타난다. 암호화 핵심 (CC) 는 Merkle Tree Calculator (MTC) 등의 BCHAIN 프로토콜 을 동작시키는 모든 주요 암호화 기능을 동작시키는 모든 주요 라이브러리를 포함한다. 도 46은 BCHAIN 프로토콜 이 자신의 하드웨어 및 다른 BCHAIN 노드 의 하드웨어와 함께 어떻게 동작 하는지를 도시한다. 프로토콜 은 커뮤니케이션 게이트웨이 (CG) 와 인터페이스하는 API 엔드포인트 을 통해 실행된다. 하드웨어 인터페이스 와 인터페이스하는 드라이버는 운영 체제 내에서 존재 하고 실행된다. 따라서 CG 는 CCR 및 CCF 패킷을 다른 BCHAIN 노드 로 송신 및 수신 할 수있다. 이러한 정보의 전송은 노드 사이에서 직접적으로 피어 투 피어 커뮤니케이션을 통해 또는 레 거시 인터넷과 같은 중앙 집중된 라우팅을 통하여 발생할 수 있다. BCHAIN 노드 (BN) 의 하드웨어 인터페 이스 는 하드웨어 명령을 수신하는 논리 계층으로서 동작한다. 따라서 하드웨어의 물리적인 표현이 선택적 인 UBEC / BCHAIN 마이크로 칩 아키텍처 (UBMA) 4260 프로세서를 장착한 하드웨어 장치 780에 존재한다. 이러한 프로세서 는 BCHAIN 프로토콜 의 실행 속도 및 효율을 증가시킨다. 이는 모바일 장치 사이의 배터리 수명 성능을 향상시키고 앱체인 을 더 빠르게 실행한다. 도 47은 BCHAIN 네트워크 내에 존재하는 노드 상호 작용의 패러다임을 도시한다. 메타체인 834는 필수 및 기본 참조를 위해 BCHAIN 네트워크 의 모든 노드가 연결하는 메타 데이터를 포함하는 커스텀체인 (블록 체인과 유사)이다. 메타체인 834는 실제 컨텐트를 제공하지 않지만 노드 / 섹터 위치, 컨텐 츠 요구 경향 및 인프라 설정을 간소화 하기 위한 홉 라우팅을 포함하는 기본 정보를 추적한다. 따라서 모든 단 일 BCHAIN Node 786이 메타체인 834를 읽는 데 참여해야 한다. 앱체인 은 메타체인 834에서 구성한 인프라 를 통해 정보를 전달하기 위한 고급 스마트 계약으로 작동하는 커스텀체인이다. 앱체인 은 커스텀체인 생 태계라고도하는 병렬 및 중첩 구조에서 입 / 출력을 위해 서로를 참조할 수 있다. 마이크로체인 838은 메 타체인 834에 종속되거나 연결되지 않는 커스텀체인으로 자동 변환되는 앱체인 이다. 이것은 특정 앱체인 에 참여하는 노드 이 위치에서 격리 될 때 발생한다. 마이크로체인 838은 자원 부담이 큰 메타체인 834를 따라갈 필요 없이 작은 IoT 102 장치가 BCHAIN 네트워크 에 참여할 수 있게 한다. 다이어그램 은 레거시 인터넷을 나타내는 컨텐트 서빙의 구(old) 패러다임을 도시한다. 클라이언트 전용 장치는 증가한 컨 텐츠 요구 (예: 웹 트래픽)를 처리하는 단일 병목 현상이 될 수 있는 단일 서버 또는 서버 클러스터에 요청한다. 서버 또는 서버 클러스터는 단일 실패 지점과 공격 지점을 나타낸다. 따라서 DDoS (Distributed Denial of Service) 공격은 레거시 인터넷 전체에서 효과적인 무기가 되어 강요, 협박, 검열 등을 초래한다. 중 앙 집중식 서버의 정적 설정은 상대적으로 비용이 많이 들고 비효율적 일 수 있는 지리적 로드 균형 조정의 보조 계층(second layer)을 설정해야 하므로 컨텐츠의 비효율적 지리적 분포를 초래한다. 분산된 컨텐츠의 새로운 패러다임 798은 BCHAIN 네트워크 의 기본 메커니즘을 나타낸다. 서버와 클라이언트는 분리 가능하고 취소 불가하게 결합 되었기 때문에, 필요에 따라 고가용성과 컨텐츠 배포가 이루어진다. 따라서 컨텐츠 서빙의 지리적 로드(load) 밸런싱은 BCHAIN 프로토콜 에 내장된다. 단일 실패 지점이나 공격이 없으므로 높은 가용성과 중복성은 BCHAIN Network 110의 자연스러운 부산물이다. 따라서 네트 워킹 하드웨어의 소수를 차지하는 불량 노드의 모든 DDoS 공격은 특정 앱체인과 같은 타겟 컨텐츠 세트에 대한 성공적인 공격을 활용할 수 없다. 또한, BCHAIN 프로토콜 은 노드 가 특정 앱체인 또는 마이크로 체인(마이크로체인s)이 호스팅되는 것을 선택 또는 금지하는 것을 금지한다. 따라서, BCHAIN 프로토콜 은 호스팅 및 배포에서 조화와 협력을 선호하는 반면, UBEC 플랫폼 계층은 LUIGI 을 통해 검열 및 컨텐츠 관리에 대한 사법 측면을 관리한다. 도 48은 해시 알림 교환 보강이 어떻게 불량 BCHAIN 노드 가 BCHAIN 네트워크 에 참여하는 것을 방지 하는지 도시한다. 불량 노드 트래픽 스팸 에서, 불량 노드는 합법적 노드 를 스팸하는 동안 합 법적 BCHAIN 노드 인 척 하려고 하는 것으로 도시되어있다. 이를 방지하기 위해 노드 해시 사실 검증 808 에 설명된 메커니즘은 합법적 노드 이 어떻게 로그 노드 806의 불법 행동을 탐지하여 블랙리스트에 올릴 수 있는지 보여준다. 불량 노드 는 BCHAIN 네트워크 의 참여 및 인접 노드 에 의한 인식을 위해 요구되는 해시 공고 를 인접 노드 에 방송한다. 해시 공고는 Node Statistical Survey (NSS) 778 변수의 해석에서 파생된다. 따라서, 노드 는 로컬 네트워크 상태의 해석이 동일 할 경우에만 서로 참 여한다. 불량 노드가 네트워크의 현재 상태를 해석하는 기준에 대해 거짓을 말하고 악의적 방식(근처 노드 등의 스패밍)으로 행동한다면, 불량 노드의 트래픽 행동은 선언된 전략 제한을 초과하였다고 합법적 노드에게 알려질 것이다. 따라서 로컬 영역 또는 섹터 의 노드 의 대다수가 BCHAIN 프로 토콜 의 수정되지 않은 버전을 작동시키는 정당한 노드 인 경우 트래픽 및 작동 제한과 관련된 합의 에 도달하므로 한도를 초과하거나 그러한 한도에 대한 합의에 동참하지 않는 모든 노드 을 차단한다. 제한 은 해시 공고 내에서 암호로 표현된다. 도 49는 BCHAIN 네트워크 내의 CCR 또는 CCF 패킷의 기본적인 이동 패턴을 도시한다. 여 정은 즉각 타겟 에서 시작하는데, 이는 CCR 또는 CCF 패킷이 전송되어야 하는 바로 다음 노드 를 의미한다. 패킷은 최종 타겟 을 향하여 노드들 사이에서 점프하는 것을 계속할 것이다. 각각의 노드 는 그것의 전체적인 여정을 따라 패킷의 위치를 고려할 것이다. 병렬 홉 스프레드 기준병 렬 홉 Spread Criteria 로 알려진 전략 배포에서 정의 된 기준이 충족되면, 노드 는 BCHAIN 프로토콜 에 부합하지 않는 병렬 홉 로직 (PHL) 을 호출한다. 이로 인해 수신된 것보다 더 많은 병 렬 홉 라우팅을 시작하는 특정 노드 801, 802 및 805가 발생한다. 이것은 이동 CCR 2308 또는 CCF 2318에 관한 홉 라우팅에서 중복성을 초래한다. 이것은 주로 CCR 23 또는 CCF가 최종 목표 2306에 도달하는 데 걸리는 시간 을 줄이기 위해 수행된다. 예측 가능한 시간 프레임 내에 도착하는 패킷의 기대에 대한 확실성 및 신뢰도 또한 병렬 홉 라우팅의 양이 증가함에 따라 증가한다. 이것은 BCHAIN 네트워크 내에서 자연스럽게 발생하는 노 드 존재 카오스의 예상되는 양이 있기 때문이다. 이러한 혼돈은 다양한 특성을 지니고 있는 노드 의 분산된 특성으로 인해 존재하며, volunteer 최선 노력에 따라 업무를 수행한다. 중복 병렬 홉 라우팅은 혼돈으 로부터 큰 방해 없이 최소한 필요한 경로가 최종 목표 2306에 도달할 확률을 높임으로써 그러한 혼란으로 인한 위험을 완화한다. 병렬 홉 라우팅이 너무 적으면 카오스가 대다수를 지연시킬 것으로 예상되므로 CCF 2318의 CCR 2308이 지연될 것이다. 또한, 최종 타겟 2306은 PHL 2922에 의해 시작된 여분의 병렬 홉 라우팅으로 인해 분산된 합의로부터 시작된 확인을 수신할 수 있다. 따라서 CCR 2308 또는 CCF 2318 패킷이 목적지 노드 에 서 받아 들여지기 위해서는 적어도 세 개의 다른 병렬 홉 라우팅에서 도착해야 한다는 정적 하드코딩 정책 (SHP)으로 하드코딩 될 수 있다. 이는 불량 노드 (Rogue Node) 가 그 여정 중에 CCR 2308 또는 CCF 2318 의 컨텐츠를 파괴할 이미 약한 기회를 제거한다. BCHAIN 네트워크 가 가장 생산적이 될 수 있는 병렬 홉 라우팅의 최소 요구를 위하여 어떠한 숫자도 선택될 수 있다. 너무 낮은 숫자를 선택하면 불량 노드 806 파괴 행위의 기회가 증가한다. 번호가 너무 높으면 전체적으로 BCHAIN 네트워크 에 훨씬 많은 리소스 스트레스 가 추가된다. 너무 높은 번호는 또한 서로 매우 가까운 노드가, 긴 우회 경로를 따라 CCR 2308 또는 CCF 2318 패킷을 제출해야만 병렬 경로를 확증 목적으로 시작할 수 있다는 것을 제외하면, 정보를 서로 신뢰하는 것 을 막게 된다. 따라서 보안 / 속도 / 신뢰성과 리소스 소비 사이의 균형이 BCHAIN 네트워크 내에 존재한 다. 이러한 절충안은 환급 감소의 법칙으로 알려진 것을 경험한다. 따라서 중복 병렬 홉 라우팅의 초기 증가는 이미 많은 수의 중복 병렬 홉 라우팅에서 수행 된 증가보다 보안 / 속도 / 신뢰성에서 더 큰 증가를 가져올 것으로 예상된다. 따라서 과도한 양의 중복 병렬 홉 라우팅이 발생하면 보안 / 속도 / 신뢰성이 향상되지만 BCHAIN Network에 많은 부담을 준다. 따라서, 시스템 에 비효율적인 부담이 되고, 이후의 여정을 계 속하는 것으로부터 중단되어야 하는 병렬 홉 라우팅을 감지하기 위해, 오버 병렬화 된 홉 라우팅 감소 (OPHPR) 모듈이 BCHAIN 프로토콜 에 통합된다. 그림은 노드 807이 노드 803에 의해 시작된 병렬 홉 라우팅 에 대해 이를 수행하는 것을 보여준다. 노드 는 병렬 홉 감소 기준 전략 배치를 참조하여 병렬 홉 라우팅을 중단해야 할 때를 알고 있다. 다른 UBEC 어플리케이션은 CCR 2308 / CCF 2318 전송에 더 높은 우선 순위를 요구할 수 있으므로 더 많은 병렬 홉 라우팅이 필요하다. 이러한 어플리케이션 또는 사용은 가능한 가장 적은 대기 시간을 필요로 하므로 대부분의 중복 홉 라우팅이 가능한 실시간 오디오 / 비디오 스트리밍 일 수 있 다. 생성되는 중복 병렬 홉 라우팅의 양은 CCR의 2308 또는 CCF의 238 경제 인증 토큰 (ECP) 에 대해 사전 승인된 와트 유닛 가격 크기에 따라 다르다. 도 50은 BCHAIN 네트워크 의 적응형 지능(Adaptive Intelligence)의 2가지 기능을 나타낸다. 이러한 기능 을 통해 BCHAIN 프로토콜 는 노드 815의 물리적 이동을 활용하고 주의를 기울일 수 있다. 제 1 기능은 노 드 에 의해 개시되고 노드 에 의해 병렬화되어 차량로드 상에 존재하는 노드 의 파괴적 인 움직임을 인지하는 CCR 2308 / CCF 2318 패킷 여정에 참여하는 노드 를 위한 것이다. 패킷을 전방으로 전달하는 동안, 노드 는 노드 가 데이터를 물리적으로 오른쪽으로 이동시키는데 예상되는 이동을 완 화하기 위해 도로의 좌측에 기울어 진 노드 인접을 선호한다. 이 기능은 또한 노드 가 도로 를 작동하는 최종 타겟 인 노드 에 성공적으로 교차시킬 기회를 증가시키기 위해 차량로드 이전 에 중복 병렬 홉 라우팅의 양을 실질적으로 증가시키는 것을 의미한다. 따라서, 노드 에 의해 전송 된 CCR / CCF 패킷은 도로 내의 노드 의 물리적 이동으로부터의 최소한의 방해로 최종 타겟 의 노드 에 성공적으로 도달 할 수 있다. 두 번째 기능은 BCHAIN 프로토콜 이 오른쪽으로 이동 하는 차량 도로 중 노드 의 물리적 이동을 이용하는 것이다. 그러한 노드 는 그들의 매일 아침 통근 중에 자신의 자동차를 운전하도록 하는, UBEC 플랫폼을 실행하는 UBEC 사용자 주머니 속의 스마 트폰 일 수 있다. 노드 의 물리적 이동을 활용하는 그러한 기능은 모듈 PDML (Physical Data Migration Layer) 3850 및 PDMU (Physical Data Migration Usage) 3851에 의해 처리된다. 이 물리적 마이그레이션 기능은 노드의 물리적 이동이 네트워크의 효율성을 위해 작동하기 때문에 시스템의 전체 처리량을 증가시킨 다. 이는 일반적으로 대기업간에 데이터의 대규모 이동에 엄청난 이점을 줄 수 있다. 예를 들어 대기업에서 서 부 해안 지사에서 동부 해안 지사로 10PB의 기업 데이터를 보내려는 경우, PDML 3850은 장기간 데이터 전송을 3 개월에서 2 개월로 크게 단축할 수 있다. 도 51은 BCHAIN 네트워크 내의 다수의 섹터들 사이의 권장 여정의 알려진 '고속도로'를 나타낸다. 섹터 는 BCHAIN 네트워크 내에서 방향 및 이동 라우팅을 논리적으로 용이하게 하는 BCHAIN 노드 의 클러스터이다. 주어진 시간에 BCHAIN 노드은 정확히 두 섹터의 관할에 속한다. 알려진 유일 한 예외는 BCHAIN 노드 에 노드 인접이 너무 적거나 0 인 경우이다. 섹터 의 정의는 TSC (Traffic Scope Consensus) 4090에 의해 생성된 이중범위해시에서 파생된다. 따라서, 최적화 섹터 경로 발견(OSRD; Optimized Sector Route Discovery)3430은 메타체인 834에 정의된 대로 BCHAIN 네트워크 의 지리적 상태를 해석하고 효율적으로 정보의 고속도로 인 최적화 섹터 경로를 생성한다. 이러한 정보는 메 타체인 834의 최적화 섹터 경로에 제출된다. 예시적인 최적화 섹터 경로 라우팅이 도 51에 도시되어 있으며, 그 사이에 고속도로를 포함하는 2 개의 섹터의 아이덴티티 및 제안 된 베이스라인 홉 라우팅 (PBHP) 가 어떻게 그러한 고속도로를 위한 라우팅 명령을 포함하고 있는지 보여준다. Pathway Strength (유효성) 및 Pathway Saturation (수요 / 사용량)과 같은 통계 정보는 메타체인 834의 최적화 섹터 라우팅(85 8)에 포함되어 있다. 최적화 섹터 경로 (Optimized Sector Routes) 는 BCHAIN 네트워크 전체에서 효율적인 길 찾기를 가능하게하는 데 사용된다. 그러므로 노드 은 메타체인 834의 Location Association을 통해 최적화 섹터 경로 858 (고속도로)에의 (to and from) 경로를 수동으로 계산하면 된다. 따라서 CCR 2308 및 CCF 2318 패킷의 장거리 전송은 최소한의 오버 헤드 및 반복 비용으로 매우 효율적이고 반복 가능하다. 도 52 내지 53은 BCHAIN 네트워크 를 통해 정보를 전송하기 위한 두 가지 방법인 스태거드 릴리즈 (staggered release) 컨텐츠 및 라이브 스트림 컨텐츠 를 도시한다. 도 52는 컨텐츠 요청을 요청하고 이행하기 위해 BCHAIN 프로토콜 에 의해 사용되는 주요방법 인 staggered 해제 컨텐츠 를 도시하고 있다. 따라서, BCHAIN 노드 는 컨텐츠 클레임 생성기 (CCG) 를 사용 하여 궁극적으로 최종 타겟 노드 로 전송되는 컨텐츠 클레임 요청 (CCR) 을 생성한다. 그러 므로 CCR 2308은 제안된 베이스라인 홉 경로(PBHP) 2322 및 트레일 변수 묶음 (TVS) 2320과 같이 동적으로 생성되고 변경되는 정보를 갖추고 있다. PBHP 는 최종 타겟 에 도달하기 위해 이동할 노드들의 제안 된 시퀀스에 관한 라우팅 정보를 포함한다. TVS 는 CCR 을 배달하는 로지스틱스 관리에 관한 동적 정 보를 포함한다. 이러한 로지스틱스 관리 요소에는 경제 인증 토큰(EAT) 994 및 특정 부문 내에서 여정 중에 참 조되는 전략 배포 916 인스턴스가 포함된다. CCR 은 중간 노드 내에 존재하는 노드 를 통해 이동한다. CCR 이 최종 타겟 노드 에 성공적으로 도달하면, 그러한 노드 는 컨텐츠 요 구 delivery (CCD) 을 실행하여 요청 노드 의 컨텐츠 요청을 이행하려고 시도한다. 따라서, 중간 노 드 를 통해 요청 노드 로 이동하는 CCF (Content Claim Fulfillment) 패킷이 대신 보내진다. 그 후, CCF 는 충족 된 데이터를 렌더링하는 적절한 관련 방법에 따라 컨텐츠 요구 렌더링(CCR; Content Claim Rendering) 3300에 의해 처리된다. CCR (Content Claim Rendering) 3300은 SRCC (Stagger Release Content Cache) 810을 사용하여 전체 컨텐츠 단위가 완전히 렌더링 될 때까지 컨텐츠 부분을 보관한다. 도 53은 staggered 해제 컨텐츠와 비교하여 메커니즘이 다른 라이브 스트림 컨텐츠 를 도시한다. 라이브 스트림 컨텐츠 메카니즘은 특정 어플리케이션 (즉, 라이브 오디오 호출)에 대해 UBEC 네트워크 전 체에 걸친 지연을 줄이고 처리량을 증가시키기 위해 컨텐츠 요구 요청 (CCR) 을 사용하지 않는다. 따라서, 컨텐츠 요구는 CCF 를 통해 그 설명 및 관할권의 암시에 따라 그러한 컨텐츠를 요청하는 노드 로 채워진다. 따라서, 관할권적 암시 CCF 제출 (JICS) 모듈은 다른 노드 의 컨텐츠 전달의 관 할권적 필요를 인지하는 BCHAIN 노드 에서 동작한다. 이런 이유로, CCF 는 동반하는 CCR 없 이 중간 노드 를 통해 제출된다. CCF 는 JACR (Jurisdictionally Accepted CCF Reception) 4208에 의해 최종 타겟 노드 에서 수신 및 유효화 된 후, CCR (Content Claim Rendering) 3300에 의해 렌 더링 된다. JICS 4194 및 JACR 4208을 사용하는 대부분의 어플리케이션은 CCF 2318이 라이브 오디오 / 비디오 콜 등에서 즉시 렌더링 될 가능성이 있으므로 SRCC (Stagger Release Content Cache) 810 모듈의 호출을 요구 하지 않을 것이다. 도 54 내지 55는 BCHAIN 노드 간의 해시 공고 (HASH Announcement) 교환이 프로토콜 컨센서 스에 이르는 방법을 나타낸다. UBEC 어플리케이션 내에서의 도 54에서, 전략 확인 시스템 (SCS) 은 TSC (Traffic Scope Consensus) 4090 모듈을 사용하여 이중 범위 해시 수집을 파생시킨다. 이중 범위 해시 4134의 구성은 궁 극적으로 노드 통계 조사 (NSS) 778에서 생성된 네 가지 변수 즉, 노드 이스케이프 인덱스 , 노드 포화 인 덱스 , 노드 일관성 인덱스 및 노드 오버랩 인덱스 에서 파생된다. 이러한 변수는 외부 트래픽 동작 으로부터의 NSS 에 의해 도출된다. BCHAIN 프로토콜 의 출처가 확실하고 완전한 버전을 동 작시키는 BCHAIN 노드의 협력 프로그래밍으로 인해 BCHAIN 네트워크 전체는 DDoS 공격에 크게 저항 력이 있다. 레거시 인터넷 DDoS 공격에서 악의적 행위자는 UDP 패킷을 선택한 서버로 스팸 메일로 전송하여 하 드웨어 / 소프트웨어 용량을 압도한다. 대조적으로, BCHAIN 네트워크 은 공급과 수요의 변화에 지속적으로 적응하고 있다. BCHAIN 네트워크 내의 모든 트래픽이 추적되고 소재가 확인되고 클레임되기 때문에, 노드 또는 클러스터의 노드에 스팸을 보내려는 DDoS 공격은 BCHAIN 네트워크 의 경제에 손상을 입히는 것이 아 니라 오히려 기여하게 될 것이다. 또한 BCHAIN 네트워크 을 통해 실행되는 모든 어플리케이션은 UBEC 플랫 폼 내에서 작동하며 LIZARD 기술을 통해 LUIGI 에 의해 의미있는 목적으로 평가된다. 따라서 네트워크 스팸 및 악용을 방지하기 위해 여러 예방 조치가 취해졌다. 도 55에서, 해시 공고(824, 826, 828 및 830)는 섹터로 알려진 3 개의 상이한 트래픽 영역 사이에서 교환 되는 것으로 도시되어있다. 각 노드는 TSC(Traffic Scope Consensus) 4090에서 실행되는 알고리즘으로 인 해 두 개의 해시를 인식한다. 이중 해시 인식 논리는 두 노드가 서로 통신 할 수 있도록 두 해시 중 적어도 하 나가 일치해야 한다. TSC 4090에 사용 된 반내림 / 반올림 논리 덕분에 노드는 다른 노드와 컨센서스를 유지하 면서 다른 네트워크 환경으로 이동할 수 있다. 이는 한 번에 단 하나의 해시가 변경 될 수 있기 때문에 노드가 합법적인 (프로토콜 798을 장악하려는 가짜 소프트웨어와 반대인) BCHAIN 프로토콜을 사용하여 작동하는 경우 주변 노드와 적어도 하나의 해시가 겹치도록 바인딩된다. 트래픽 영역 A 818(섹터 A)에 대해 올바르게 파생 된 해시는 A1과 A2이다. 트래픽 영역 AB 820(섹터 A와 B의 오버랩)에 대해 올바르게 파생 된 해시는 A1, A2, B1, B2이다. 트래픽 영역 B 822(섹터 B)에 대해 올바르게 파생 된 해시는 B1 및 B2이 다. 도 56은 커스텀체인의 로컬 스토리지 인 커스텀체인 Storage(CS)의 구조를 도시한다. 커스텀체인은 스 마트 계약 실행, 다른 병렬 앱체인 786의 참조 및 종속성 및 분할 커스텀체인 병합과 같은 기능을 추가한 고급 블록 체인이다. 분할 커스텀체인 병합은 노드의 지리적 분리로 인해 커스텀체인이 두 개로 나뉘어지는 것인데, [모듈]은 새로 채굴한 데이터의 차이를 조정하면서 이를 다시 병합할 수 있다. 메타체인는 필수 및 기본참조를 위해 BCHAIN 네트워크 의 모든 노드가 연결하는 메타 데이터를 포함하는 커스텀체인이다. 메타체인 는 실제 컨텐트를 제공하지 않지만 노드 / 섹터 883 위치, 컨텐트 요구 경향 및 인프라 구축을 간소 화하기 위한 홉 라우팅을 포함하는 기본 정보를 추적한다. 따라서 메타 체인은 BCHAIN 네트워크의 인 프라 할당을 관리하는 분산 데이터베이스로서 기술 될 수있다. 메타 체인은 앱체인에 관한 관련 이벤 트를 트리거하기 위해 hooks of 정보 업데이트를 제공한다. 따라서, 인스턴트 통지 시스템(즉, 전화, 인스턴트 메시징)은 메타체인을 마스터 동기화 계층으로서 참조함으로써 앱체인에 프로그래밍 될 수 있다. 모 든 노드가 리딩에 참여해야 하고 대부분이 마이닝에 참여해야 하는 메타체인은 하나뿐이다. 메타체인 의 Location Association 840은 메타체인에 연결된 모든 단일 노드 의 진입을 포함한다. 각 진 입은 그러한 노드로부터의 인접 노드가 무엇인지에 대한 선언을 포함한다. 이것은 일반적으로 노드의 무선 범위에 근접한 물리적 인접을 나타내지만 인터넷(유선/무선)을 통해 작동하는 BCHAIN 레거시 호스트를 통 해 상호 연결된 노드 을 의미할 수도 있다. 섹터 Association은 모든 섹터로부터의 진입을 포함 하며, 이는 정해진 경계 내의 노드의 지리적 집합이다. 각각의 섹터는 고급 라우팅 알고리즘을 허용 하는 인식된 섹터(Sector) 인접에게 특정 노드와의 효율적인 경로를 나타내도록 선언한다. 진단 노드 위치는 스스로를 자체적 부과 진단 노드로 선언한 노드의 아이덴티티를 포함한다. 진단 노드는 claimed 역할의 실행과 관련하여 확인되거나 되지 않을 수 있다. 앱체인 Updates 846은 마지막으로 업데이트 한 시간을 나타내는 타임 스탬프와 함께, 등록된 각 앱체인 에 대한 앱체인 고유 식별자를 포함한다. 이 방식으로 노드 은 실시간 알림 시스템과 같이 등록 된 앱체인 에 대한 메타체인를 모니터링 한 다음 앱체인 캐시 컨텐츠가 포함된 노드 에서 직접 실제 컨텐츠를 가져올 수 있다. 앱체인 Cache Location은 특정 앱체인에 대해 저장된 컨텐츠를 갖는 노드에 대한 노드 및 섹터(Sector) 고유 식별자를 포함한다. 따라서, 노드가 자신이 등록한 앱체인에 게시된 정보를 찾고 있는 경우, 메 타체인의 이 섹션에서 그 내용의 위치를 확인할 수 있다. 앱체인 채굴자 위치는 자체 앱체인 광산 관 할권에 부과 된 노드 의 상대적 위치를 추적한다. 이를 통해 노드는, 새 정보를 유효화 하고 새 정보를 앱 체인836의 다음 블록에 포함시키는 타겟 채굴자에게 New Content Announcement(NCA) 2544를 통해 정보를 브로 드캐스팅 할 수 있다. 앱체인 수요는 섹터 가 그 내용이라고 주장하는 것에 따라 앱체인 의 인 기와 관련된 정보를 포함한다. 따라서 앱체인 Cache Locations 848은 적절히 발견될 수 있다. 섹터 수요는 섹터 내의 정보 트래픽 가중치에 관한 정보를 포함한다. 이것은 메타체인이 어느 섹터가 과중한 정보 수요를 겪고 있는지를 추적 할 수 있게 한다. 따라서 BCHAIN Protocol 794를 작동시키는 후속 알고리즘은 수요를 충족시키기 위해 인프라 공급을 미세 조정할 수 있다. Chaotic Environment Tracking 856은 그들이 exhibit하는 NSS 변수로 인해 어떤 노드가 신뢰할 수 없는 것으로 간주되는지 추적한다. 이는 동일한 위 치에 일관되게 존재하지 않음을 나타내는 높은 노드 이스케이프 인덱스(Node Escape Index) 886을 가질 수 있음 을 의미한다. 최적화 된 섹터 라우팅 은 섹터 사이의 가장 효율적인 경로로 인지되는 추천된 PBHP(Proposed Baseline Hop Pathways) 2322를 포함한다. 따라서 이 정보를 사용하여 단일 노드 은 CPU 자원을 많이 소비하지 않고 목적지로의 효율적인 경로를 계획 할 수 있다. 워크 투 와트 트래킹 (Work to Watt Tracking) 은 수행되는 BCHAIN 노드 작업 유형의 여러 유형과 이들을 수행하는 데 소요 된 전기 와 트의 양에 관한 다양한 비율을 추적한다. 와트 경제 는 모든 알려진 노드 에 대해 와트 유닛(-U-)의 적자 또는 잉여를 추적한다. 따라서, BCHAIN 네트워크에서 행해진 정보 전달 작업이 추적되므로, 각 노드 는 컨텐츠 소비 및 작업 완료에 대해 적절하게 보상되고 charge 될 수 있다. 섹터 비상 자금 864는 와트 경제에서 상환 가능한 와트 단위의 자금을 나타내며, 자금이 속한 섹터 의 확인 된 채굴자 사이의 컨센서 스 결정에 의해서만 소비 될 수 있다. 이 자금은 무결성을 영구적으로 잃을 위험에 접근하는 데이터 보존에 지 출하기 위해 예약되어 있다. 앱체인 은 메타체인에 의해 조직된 인프라를 통해 정보를 전달하기 위한 고급 스마트 계약으로 작동하는 커스텀체인이다. 앱체인 은 커스텀체인 생태계 540으로 알려진 병렬 및 중 첩 구조로 입 / 출력을 위해 서로를 참조 할 수 있다. 따라서 전자 메일, 텍스트 메시징, 라이브 전화 및 비디 오 스트리밍과 같은 표준 정보 교환은 앱체인 에서 자원 로드 및 동시성 트레이드 오프로 인해 마이닝 블 록에서의 다양한 간격으로 프로그래밍 할 수 있다. 앱체인 으로 변환 할 수 있는 어플리케이션의 예는 Uber Driving Application이다. 프리랜서 자동차 운전 서비스의 관리는 운전자 / 승객 할당 및 앱체인 으 로 매니페스트 된 정교한 스마트 계약을 통한 감독을 통해 분산 방식으로 완벽하게 관리 될 수 있다. 발신 노드 추적은 CCR 또는 CCF가 특정 앱체인에 관한 노드로부터 언제 유래하는지를 추적한 다. 이는 정보 전달 격리 인덱스(ITII)가 계산되도록 하고, 따라서 노드는 마이크로 체인 스위치 색 인에서, 마이크로 체인으로 변환될 앱체인에 대해 투표할지 여부를 식별 할 수 있다. 마이크로 체인 스위치 인덱스는 이 앱체인 이 마이크로체인 838으로의 변환 기준을 충족하는지 여부에 대하여 이 앱체인 에 대한 암호화 액세스 권한이 있는 Node 786의 투표를 등록한다. 지정된 다수결 표가 전환을나타내면 정보 업로드 및 다운로드는 마이크로체인 838 버전에서 이루어지므로, 다수의 의지에 따르지 않는 사 람은 정보 업데이트에서 제외된다. 이는 정보 업데이트가 마이크로체인s 838 용 메타체인에 제출되지 않았 기 때문에 발생한다. 마이크로체인s 838은 Metchain 834에 종속되거나 연결되지 않는 커스텀체인으로 자동 변환 된 앱체인 이다. 이는 특정 앱체인에 참여하는 노드가 위치에서 격리 될 때 발생한다. 예를 들어 이 변환 은 앱체인 만 실행중인 회사 사무실에서 수행 될 것으로 예상된다. BCHAIN 프로토콜은 정보 전송이 고도의 지리적 격리(GPS 좌표를 참조하지 않고)를 가지고 있음을 감지한 후 자원 소비 효율 목적을 달성하기 위 해 앱체인 을 마이크로체인 838으로 변환한다. 이전의 메타체인 기능은 마이크로체인 838 내에있는 메타체인 에뮬레이터 882로 대체되었으므로 노드 의 일반 대중은 액세스를 의도하지 않은 격리된 모호한 경로에서 정보를 처리하는 부담을 감당할 필요가 없다. 따라서 BCHAIN 프로토콜 의 사양 내에서 앱체인 기능 또는 존재에 대한 언급은 마이크로체인 838과 상호교환가능 및 호환된다. 발신 노드 트랙킹은 CCR 또는 CCF가 특정 마이크로 체인에 관한 노드로부터 유래 한 때를 추적한다. 이는 정보 전 송 아이솔레이션 인덱스(ITII)가 계산되도록하여 노드가 마이크로 체인이 다시 앱체인으 로 변환되어야 하는지의 여부를 투표하게 한다. 메타 체인 에뮬레이터는 마이크로 체인 내에 저장된 전체 메타체인에 대한 플레이스 홀더이다. 이러한 방식으로, BCHAIN 네트워크는 마이크로 체인 으로 변환된 앱체인 을 처리 할 때 일반 메타체인와 동일한 방식으로 이 메타체인 Emulator 882에 동 일한 정보 요청 및 수정을 한다. 도 57 내지도 58은 NSS(Node Statistical Survey)를 도시한다. 도 57에서, NSS는 네 개의 주요 인덱스(886, 888, 890, 892)를 계산하기 위해 주변 노드의 거동에 관한 정보를 수집한다. 이는 BCHAIN 프로토콜의 핵심 기능을 동작시키는 모듈에 노드의 활동 및 행동 에 관한 BCHAIN 네트워크의 상태에 대해 알려준다. 따라서 섹터 메이크업 등에 대한 컨센서스와 같 은 유용한 기능이 유도된다. 노드 상호 작용 로직(NIL) 모듈은 통신 게이트웨이(CG)의 서브 세트로 서 동작하고 운영 체제 및 API 종점을 통해 하드웨어 인터페이스와 상호 작용한다. 핑은 외부 하드웨어와의 네트워크 상호 작용이다. 따라서 NSS의 인스턴스를 실행하는 노드의 바로 근처에있는 노드와 관련된 모든 핑은 노드 핑 처리(NPP)로 포워딩된다. 노드 활동 DB(NAD)는 노드 핑 활동에 관한 미가공 데이터를 보유하는 로컬 데이터베이스이다. NAD는 NPP가 노드 인덱스 변수들 컬렉션의 인덱스 계산을 유도하는 동작 쿼리를 수행하기 위한 정보의 주요 소스 가된다. 노드 이탈 인덱스는 노드 인접이 감지 노드의 감지 범위를 벗어날 가능성을 추적한다. 높은 이탈 인 덱스(Escape Index) 886은 탁월한 전략을 요구하는 더 혼란스러운 환경을 나타낸다. 예 : 고속도로에있는 자동 차의 스마트 폰은 노드 이탈 인덱스가 높다. 스타 벅스의 냉장고는 매우 낮은 노드 이탈 인덱스(Node Escape Index)를 나타낼 것이다. 노드 포화 인덱스는 감지 노드의 감지 범위에서 노드의 양을 추적한다. 포화 인덱스가 높으면 많은 노드가 있는 혼잡한 지역을 나타낸다. 이것은 공급 / 수요 트 레이드오프로 인해 성능에 긍정적 또는 부정적 영향을 모두 미칠 수 있지만, 높은 밀도의 노드 영역이 보 다 안정적 / 예측 가능하고 따라서 혼란이 적을 것으로 예상된다. 예 : 뉴욕시의 중심부에있는 스타 벅스는 노 드 포화 인덱스가 높다. 사막 한가운데있는 텐트는 매우 낮은 노드 포화 인덱스을 갖는다. 노드 일관 성 인덱스는 감지 노드에 의해 해석되는 노드 서비스의 품질을 추적한다. 높은 노드 일관성 인 덱스는 주변 인접 노드가 가용성 가동 시간 및 성능에서의 일관성을 갖는 경향이 있음을 나타낸다. 이중 용도 목적을 가지는 노드는 낮은 일관성 인덱스를 갖는 경향이 있는 반면, BCHAIN 네트워크 전용 노드는 더 높은 값을 나타낸다. 예 : 회사 직원 컴퓨터와 같은 이중 목적을 가진 노드 은 근무 시간 동안은 사용 가능한 자원이 적고 점심 시간과 직원 부재시 더 많은 자원을 사용할 수 있으므로 일관성 인 덱스가 낮다. 노드 오버랩 인덱스는 감지 노드에 의해 해석되는 중첩 노드의 양을 서로 추적한다. 오 버랩 892와 포화 888 인덱스는 상관 관계가 있는 경향이 있지만, 오버랩 인덱스 892는 인접 간 일반적인 중첩 정도를 나타내고 포화 인덱스는 물리적 경향만을 다루기 때문에 구별된다. 따라서 각 장치에서 긴 무선 범위를 갖는 높은 포화 인덱스 888는 높은 오버랩 인덱스 892로 이어질 것이다. 예 : 장치는 새로운 UBEC / BCHAIN 마 이크로 칩 아키텍처(UBMA) 4260 프로세서가 설치된 BCHAIN 네트워크 의 특정 섹터 에 들어가기 시작 한다. 이 프로세서는 고급 빔 포밍 기술이 적용된 고 이득 지향성 안테나를 갖추고 있다. 따라서, 중첩 된 통신 구조를 갖는 노드로 인해 섹터에서 오버랩 인덱스가 증가한다. Significant Node Detection(SND)에서, 이상 및 / 또는 통지 특성을 갖는 노드는 의도된 인덱스의 계산을 용이하게 하 기 위해 강조된다. 도 58에는 노드 핑 처리 (NPP) 의 세부 사항이 도시되어있다. 노드 핑 레코드 는 커뮤니케이션 게이 트웨이 (CG) 의 서브 세트로서 노드 상호 작용 로직 (NIL) 에 의해 제출 된 정보의 컨테이너이다.노드 핑 레코드는 초기에 인커밍 트래픽 에서 수신된다. 각 노드 Ping 레코드 는 만료 타임 스탬프 뿐만 아니라 관련 노드 에 관한 ID를 포함한다. 그러한 타임 스탬프 는 NSS 로 하여금 BCHAIN 네트워크 의 로컬 부근의 현재 상태를 반영하는 최신 정보를보고하게한다. 개별 노드 핑 기록 이 만료되지 않았거나 장시간 후에 만료된다면, 노드 인덱스 변수 는 로컬 부근의 현재 상태를 정확 하게 반영하지 않고 오히려 평균을 반영 할 것이다. 인커밍 트래픽 으로부터의 노드 핑 기록 은 노드 액티비티 DB (NAD) 에 결국 저장된다. 거기로부터 동작 쿼리 는 만료 타임 스탬프 를 고려하면 서 일괄적으로 노드 핑 기록 을 처리한다. 따라서, 레코드 는 최종적으로 인덱스 계산 에서 4개 의 노드 인덱스 변수 의 기준에 따라 계산된다. 도 59는 BCHAIN 노드들 사이에서 프로토콜 컨센서스 빌딩의 오페라 시스템을 동작시키는 전략 확증 시스템 (SCS) 을 도시한다. TSC (Traffic Scope Consensus) 4090은 NSS 변수 및 정적 하드코딩 정 책 (SHP) 488의 정적 정의를 참조하여 이중 범위 해시 4134 세트를 생성한다. SHP 488은 BCHAIN Protocol 794 에 하드코딩 된 기준을 포함한다. 이러한 기준은 전략 자체를 정의하는 데 사용되기 때문에 일반적인 동적 전략 기반 기준과 달리 정적이다. 따라서 전략을 생산하는 데 사용 된 메커니즘 자체가 전략에 의존한다면 시스템은 결국 기능 및 효율성이 제한적이거나 비정상적인 극한 상태로 루프 될 것으로 예상된다. SCS 4080은 Sector Identification Derivation 2092를 호출하여 이중 범위 해시 4134 Hash 1 4136 및 Hash 2 4138을 사용하여 Current Sector Identification 2094를 정의하는 기준으로 작용한다. 따라서, 임의의 주어진 시간에 각 노드 는 정확히 2 개의 섹터 의 관할권 내에 존재하며, 각각은 해시 1 및 해시 2 에 의해 정 의된다. Hash Corroboration 4086을 사용하면 주변의 인접 노드 에서 공고 된 해시 4134가 로컬에서 생성 된 해시 4134와 비교하여 검사된다. 해시가 일치하지 않으면, 인접 노드 (Nighbor Node) 는 노드 차단리스 트 에 추가된다. 특정 노드 트래픽 인식 4084; 그들의 일치하는 해시 공고 로 인해 합법으로 인식 된 노드 는, 불량 (Rogue) 으로 의심되고 정적 하드웨어 코드화 된 정책 (SHP) 에 정의된 BCHAIN 프로토콜 너머로부터 작동되는 노드 에 대해 다른 노드 에게 알린다. 노드 차단리스트 (408 2)는 적어도 하나의 매칭되는 해시 를 생성할 수 없기 때문에 불량으로 의심되는 노드 의 아이 덴티티를 포함한다. 따라서 그것들은 스팸 및 네트워크 남용을 방지하기 위해 합법적 노드 과의 상호 작용 및 정보 전송이 차단된다. 도 60 - 63은 TSC (Traffic Scope Consensus) 4090의 운영에 대해 자세히 설명한다. 도 60에서, TSC 는 NVP 를 호출하여 노드 통계 조사 (NSS) 변수를 수신하고 NSS 변수 합성 평균 (NVCI) 을 생성한다. 같은 섹터 에서 NVP 4140 노드 을 사용하여 섹터의 884 특성에 대 한 컨센서스를 도출하기 위해 NSS 변수에 대한 인식을 서로에게 공고한다. 따라서 로컬 및 원격 NSS 변수를 함께 풀링하여 NVCI 4108으로 알려진 합성 평균을 생성한다. 이 합성은 이 섹터 의 범위와 정의에 대한 컨센서스를 유지하는 데 사용되며, 따라서 물리적인 경계가 있다. 노드 이스케이프 인덱스 886의 풀링 된 버전은 단계 4100에서 가장 가까운 배수 X로 아래쪽으로 반내림된다. 노드 포화 인덱스 의 풀링 된 버전은 단계 에서 가장 가까운 배수 X로 반내림된다. 노드 일관성 인덱스 의 풀링 된 버전은 단 계 에서 가장 가까운 배수 X로 반내림된다. 노드 오버랩 인덱스 의 풀링 된 버전은 단계 에서 가장 가까운 배수 X로 반내림된다. 4098 단계가 완료되면 (그림 61 참조) 4094 단계에서 생성된 모든 변수가 4094 단계에서 단일 변수로 병합된다. 도 61에서, 성능 인자(performance factors)들 은 NSS 가변 풀 (NVP) 에 의해 생성되고 단계 에 제출되어 가장 가까운 배수 X로 반내림 된다 (4094 단계에서 발견 된 다른 계산들과 함께). 성능 인자 는 관련 섹터 내의 네트워크 트래픽에 관한 성능 (예: 평균 홉 / 초, 평균 메가 바이트 / 초 등)을 측정 한 것이다. 4094 단계에서 사용되는 값 X는 전략 배포 916에서 트래픽 컨센서스 라운딩 배수 1024 에서 비롯된다. 전략 배포 916 유닛 자체는 섹터 크로싱 이벤트 프로세싱 (SCEP) 3360에 의해 처리되는 트레일 변수 묶음(TVS) 2320에서 추출된다. 따라서, 배수 1024는 각 섹터 내에서 상이 할 것으로 예상되지만, 동 일한 섹터 내의 모든 노드 에 대해 동일하게 유지된다. 따라서 단계 4092에서 수행 된 병합 결과는 이중 범위 해시 4134의 해시 1 4136에 대한 기준이 된다. 해시 2 에 대한 기준은 도 62에 도시된 바와 같 이 단계 에 의해 생성된다. 도 62에서, 동일한 NVCI 는 단계 내에서 프로세스가 트래픽 컨센서스 라운딩 배수 1024로부터 취 해진 동일한 배수 X로부터 위쪽으로 반올림된다는 것을 제외하고는 단계 내에서 수행되는 반내림 처리로 부터 참조된다. 또한 NVP 4140의 동일한 성능 요소 4110이 반올림되었지만 처리된다. 따라서 단계 4118에서 처 리 된 병합 출력은 단계 4094와 같은 NVCI 4108 및 성능 인자 4110의 참조에서 파생되었지만 라운딩 유사성 차이로 인해 다른 결과가 생성된다. 도 63에서, 단계들 (4092 및 4118)에 의해 생성 된 두 변수들은 단계 에서 영숫자 해시 생성을위한 시드 가된다. 따라서 두 개의 해시 즉 이중 범위 해시 4134의 해시 1 4136 및 해시 2 4138가 생성된다. 이것들은 BCHAIN 네트워크 내에서의 데이터 유지 및 동작을 위한 주요 방향 매커니즘인 섹터에 대한 주요 정 의 인자가 된다. 도 64 - 65는 동적 전략 적응 (DSA) 772를 보여준다. 도 64는 DSA 가 BCHAIN 네트워크 내의 프로세싱 인자들을 제어하는 동적 변수들을 생성하기 위한 프 레임 워크로서 어떻게 동작 하는지를 도시한다. 이러한 변수는 TVS (Trail Variable Suite) 2320에서 수행되는 전략 배포 916을 통해 패키징 되고 전송된다. DSA 772는 필드 카오스 해석 (FCI) 918을 통해 NSS 변수에 의해보고 된 물리적 네트워크의 상태에 따라 네트워크 작업을 제어하는 변수를 지속적으로 유지 관리하고 조정한다. FCI는 BCHAIN 네트워크 전체에 걸쳐서 노드 가용성 카오스의 전반적인 수준을 해석한다. 전략 배포 는 BCHAIN 프로토콜 의 모듈 내에 동작 값을 설정하는 패키지 된 세트의 기준이다. 최적화 전략 선택 알고리즘 (Optimized Strategy Selection Algorithm, OSSA) 956은 NSS 에 의해 선언 된 환경 조건 하에서 가장 잘 작동하는 가장 적합하고 가장 이상적인 전략 914를 선택한다. 그러므로 현재 선호 전략 (SCM) 914는 실험을 통해 전략을 조정하기 위한 전략 창조 모듈 (SCM) 984의 입력으로 사용된다. SCM 984는 현재 선호 전략 914의 형태와 FCI 918의 필드 카오스의 현재 해석을 혼용하기 위해 실행 세그먼트 헤비 앱체인으로 작동하는 창의성 모듈 112를 사용한다. 그러므로 BCHAIN 네트워크 은 점진적 시행 착오의 일정한 상태에 있으며 전략 기준 992와 실제 업무 네트워크 110 성과 사이의 원인과 결과의 상관 관계를 알아보기 위해 변수 조정의 위험성이 낮은 실험을 수행한다. 우선 순위 할당 및 증명 (PAP) 922는 전략 배포 916 기준 992를 수정하 여 UBEC 사용자 이 지불한 추가 금액에 따라 우선 순위를 확장한다. 이러한 우선 순위 지정은 자동화 된 프로세스로 예를 들어, UBEC 사용자 는 전화 통화 앱체인으로 다른 사용자 에게 다이얼링 한다. 그 다음, 앱체인 은 패킷 전송의 우선 순위를 증가 시키도록 PAP 에 요청하여 일관되고 신뢰성 있는 전 화 접속이 이루어질 수 있게 한다. 표준 우선 순위 데이터 전송과 달리 전화 통화에 추가로 소비되는 와트 유닛 의 양은 UBEC 사용자의 106 사용자 개인 자금 배당 (UPFA) 718에서 공제된다. 따라서, 후속적으로 생성되는 전 략 배포 는 병렬 홉 확산 표준 에 대한 비교적 높은 값 그리고 병렬 홉 감소 기준 에 대한 비 교적 낮은 값을 포함한다. 따라서 더 많은 병렬 홉 라우팅이 시작되어 대기 시간이 짧아지고 패킷 손실이 줄어 들며 안정성이 향상된다. 전략 배포 는 CCR 또는 CCF 의 트레일 변수 묶음(TVS) 에 패키징 된다. 트래픽 전략 914, 916은 동적이지만 모든 합법적 노드 에 의해 정상적인 합법적 트래픽의 한 계로 인정되는 하드코딩 된 제한이 있다. 이러한 하드코딩 된 제한은 전략 범위 제한에 대한 컨센서스 996으로 참조된다. 따라서 노드 이 이러한 제한을 초과하는 트래픽을 출력하는 경우 트래픽은 합법적 노드 에 의해 스팸으로 간주된다. 이러한 제한은 네트워크 110 트래픽에 비해 확장 가능하다. 즉, 전체 BCHAIN 네트워크 은 악용 방지 기능을 유지하면서 하드코딩 된 제한에 도달하지 않고 무기한 성장할 수 있다. 전략 성능 추 적 (SPT) 은 네트워크 내의 다양한 배포 된 전략 의인지 된 성능을 추적하는 데이터베이스(앱 체인으로서 동작)이며, 이는 OSSA가 지역 주변 네트워크 110 조건을 고려한 현재 선호 전략로 간주되 는 것을 선택하게 한다. 도 65에서, 전략 성능 해석 (SPI) 은 다양한 환경 조건에서 그러한 전략의 인지 된 성능을 지시하는 필드 데이터를 갖는 배포된 전략을 수신한다. Queued Information Broadcast (QIB) 2700은 환경 조건을 SPI 3420에 보고하기 위해 필드에서 액티브한 전략 배포 916을 중계한다. 이것은 전략 배포 916 기준 992에 관한 DSA 772 모듈 내에서 계산 될 원인과 결과의 상관 관계로 이어진다. (7/24) 도 66 내지도 67은 데이터 세그먼트 헤비 앱체인 으로서 동작하는 전략 성능 추적 (SPT) 의 데 이터베이스 구조를 도시한다. SPT 920은 전략 D28 924 및 전략 K1 1 940 에서처럼 전략 916의 단위를 저장한다. 각 전략 916에는 기본 전략 기준 컴포지션 928, 944가 있으며 모든 정의 기준이 거기에 저장되어 있으므로 전략 916의 핵심 아이덴티티 역할을 한다. 그러므로 전략 916 단위 내의 모든 다른 variances는 OSSA 956이 현재의 우선 전략 914로 간주하는 것을 선택할 수 있도록 성능 및 시간의 논리적 측정으로 작용한다. 각 전략 유 닛은 만기 타임 스탬프 (926, 942)를 갖는다. 그러한 전략 만료 (926, 942)는 전략 성능 해석 (SPI) 에 의해 전략 에 대한 업데이트가 제공 될 때마다 연장된다. 그러므로 만료 타임 스탬프 (926, 942)는 SPT 데이터베이스가 오래되고 관련 없는 성능 데이터를 유지하는 것을 방지한다. 각 전략 (924, 940)과 관련 하여, SPT 에 의해 보고되는 다수의 성능 추적 유닛 이있다. 추적 유닛 은 NSS 구성 (932, 936, 948, 952) 및 성능 인덱스 (934, 938, 950, 954)를 포함한다. NSS 구성은 이 추적 장치 930이 캡처 된 당시 존재한 NSS 변수 886, 888, 890, 892를 캡처 한다. 성능 인덱스는 초당 홉 수, 초당 메가 바이트 수 등과 같은 성능 측정 값을 기록한다. NSS 구성 및 성능 인덱스에 보관 된 데이터를 통해 OSSA 956은 OSSA 956에보고되는 현재 NSS 변수에 따라 현재 선호 전략 914가 무엇인지 인식 할 수 있다. 도 68 - 70은 OSSA (Optimized Strategy Selection Algorithm) 956의 세부 작업을 보여준다. 도 68은 다중 변수 선택 알고리즘 (MVSA) 에 (로직 흐름을 통해) 간접적으로 연결하는 전략 성능 추적 (SPT) 을 도시한다. MVSA 는 SPT 내의 데이터로부터 가장 적절한 전략 을 선택한다. SPT 920의 데이터는 단일 전략 916에 나열된 모든 개별 성과 인덱스의 합성 평균 인 전략 성과 인덱스을 도출 하는 데 사용된다. 전략 신뢰 랭킹은 전략 성과 인덱스에 대한 인식을 정당화 할 수 있는 우선권 / 증거의 정도를 나타낸다. MVSA 는 적절한 전략 을 선택하는 기준을 식별하기 위해 정적 하드코딩 된 정책 (SHP) 을 참조한다. 따라서 MVSA 914는 현재 선호 전략 914를 모듈 출력으로 제출하며 이는 OSSA 956 의 최종 모듈 출력이다. 따라서 MVSA 962는 현재 NSS 변수를 고려한 최상의 성능과 효율성을 제공하고자 하는 전략 914를 선택하는 핵심 결정을 수행했다. 도 69는 SPT 로부터 MVSA 로 이끄는 OSSA 내의 세부사항을 도시한다. 단계 는 SPT (92 0)로부터 만료되지 않은 모든 전략 을 검색한다. 따라서, 모든 액티브 전략 은 어셈블 되고, 도 66 및 67 에 상세히 도시된 전략 D28 및 전략 K11 을 포함한다. 단계 는 단계 로부터의 NSS 동작의 현재 인스턴스에 의해 제공되는 바와 같이, 로컬 NSS 구성 의 범위 내에 있는 모든 활성 전 략 으로부터 모든 NSS 구성을 검색한다. 이러한 범위의 크기는 정적 하드코딩 된 정책 (SHP) 488에 정의되어 있다. 따라서, 단계 962는 다양한 전략들 로부터 선택된 성능 추적 유닛들 을 포함하는 범 위 내의 NSS 메이크업 을 생성한다. 그 후, 단계 에서, 성능 추적 유닛 은 전략 기준 구 성 인 전략 정의에 따라 구성된다. 도 70은 단계 로부터의 OSSA 의 논리 흐름을 계속한다. 단계 966의 출력은 단계 930에서 초기에 선택 된 성능 추적 유닛 을 포함하는 선택된 전략 을 포함하는 전략 컨테이너 이다. 단계 974는 전략 컨테이너 972를 참조하여 전략 성능 인덱스 978로 출력하는 전략 당 평균 성능 인덱스 930을 계산한다. 따 라서 Strategy Confidence Ranking 980은 전략 916에 따라 계산된다. 이러한 랭킹 은 SPT 로부터 추 출 된 데이터로부터 얼마나 많은 선행precedence / 증거가 전략 성능에 대한 인식을 정당화하기 위해 이 용 가능한지를 나타낸다. 이후 982 단계는 MVSA 962를 통해 성능 978 및 평가 신뢰 980에 따라 선호 전략을 선 택한다. 도 71 내지 도 74는 동적 전략 적응 (DSA) 에 의해 호출되는 전략 생성 모듈 (SCM) 을 도시한다. SCM 984는 창의성 모듈 112를 통해 전략 914의 구성을 지능적으로 변경하여 이전 반복의 강점을 바탕으로 저 위 험 실험 전략 916을 만든다. 도 71에서, 필드 카오스 해석 (FCI) 은 카오스 해석 출력을 단계 986에 제출하고, 단계 986은 카오스 해석 출력을 입력 폼으로서 창의성 에 제출한다. 창의성의 112 정적 기준 998은 합의된 전략 범위 한계 996 및 경제 인증 토큰 (EAT) 994 (따라서 우선 순위 수준)에서 사전 승인 된 와트 단위 금액을 기반으로 한다. EAT 994 토큰은 우선 순위 지정 및 증명 922에 의해 제공된다. 현재 선호 전략 은 OSSA 에 의해 수신되고 단계 990에서 언팩 되어 전략 기준 구성 을 검색한다. 도 72는 구성 전략 기준 구성 의 다양한 기준 을 도시한다. 모든 단일 전략 배포 916에는 이러한 각 기준에 대해 정의 된 값이 있다. 홉 위트니스 만료 (Hop Witness Expiration) 는 최근 홉 히스토리 (RHH) 에서의 홉 증인 진입이 무시되는 데 걸린 시간을 나타낸다. 이 변수는 잠재적으로 쓸모없는 병렬 홉 라우팅이 생성되는 것을 제거하는 데 사용된다. 이는 CCR 또는 CCF 가 오래전에 이 노드 를 이미 통과한 경우, 새로운 병렬 CCR 또는 CCF 가 이전의 것을 포착하여 능가할 가능성이 점점 낮아지기 때문이다. 병렬 홉 확산 표준 (Parallel Hop Spread Criteria) 은 병렬 홉이 얼마나 확산되어야 하는지를 나타내고, 무엇이 변수 값을 트리거 하는지를 나타낸다. 병렬 홉 (Parallel Hops)의 증가는 정보 전송의 높은 신뢰성과 품질을 나타낸다. 따라서, 그들의 경제 인증 토큰 (EAT) 에 우선 순위 플래그를 포함하는 CCR 및 CCF 는 더 큰 홉 확산 기준 를 유도 할 것이다. 병렬 홉 감소 기준 (Parallel Hop Reduction Criteria) 은 병렬 홉 라우팅이 중복으로 인해 제거되어야 하는 때를 나타낸다. 병렬 홉 라우팅을 더 일찍 제거하면 안정성과 서비스 품질이 저하된다. 따라서, EAT(Economic Authorization Token) 에 우선 순위 플래그를 포함하는 CCR 및 CCF 는보다 작은 홉 감소 기준 을 유도 할 것이다. 캐시에 요구되는 컨텐츠 포화 는 최근 홉 히스토리 (RHH) 에서 이 노드에 의해 앱체인 이 최 근에 목격 된 최소 발생량이다. 따라서 자주 목격되는 컨텐츠는 캐시 될 것이고, 이는 카오틱하게 분산 된 노드 세트 사이에서 캐시 위치를 점진적으로 자동 최적화한다. 캐시에 요구되는 최소 홉 여정 은 노드가 컨텐츠를 캐싱하기 위해 완료되어야 하는 최소 진행량으로, 즉 캐싱이 허용되기 전에 홉 여정의 적어도 50 %가 완료되어야 한다. 따라서 중간 지점 이후에 여정에 참여하는 노 드 만이 컨텐츠를 캐시 할 자격이 있다. 요구 선언 홉 포인트 는 노드 가 메타 체인 에 앱체인 Demand 및 Sector Demand 를 선언하는 CCR 또는 CCF 여정을 따른 홉 포인트이다. 앱체인 Demand 852는 앱체인 캐싱 및 위치를 결정하기 위해 추적되는 반면 Sector Demand 854는 다른 섹터 의 다양한 가격을 계산하기 위해 추적된다. 따라서 효율적인 수요 / 공급 경제가 창출된다. 경로 배포를 위한 최소 노드 신뢰도는 노드가 홉 라우팅에 포함되도록 NSS 변수에 의해 판정 된 노 드 의 최소 신뢰도 레벨이다. 그러한 경로는 가장 이상적인 경로 또는 덜 유능한 병렬 경로 일 수 있다. 자체 부과된 마이닝 기준 은 앱체인 을 채굴하는데 필요한 상대적 컴퓨팅 리소스의 최소량이다. 이 러한 양은 자원로드 4에 비례한다 앱체인 786은 일부 앱체인 이 다른 앱체인 보다 무거우므로, 앱체인 의 즉각적인 긴급 성은 새 로운 채굴자에게 데이터 무결성을 유지할 것을 요구한다. 카오스 환경 회피 기준 은 NSS 에 의해 제공되는 변수에 의해 이해되는 바와 같이, 이들이 산발적이 고 신뢰할 수 없다는 것을 나타내는 노드의 특성을 정의한다. 따라서 노드 의 예측할 수 없고 산발적인 움 직임과 가용성을 포함하는 환경은 지능적으로 동적 기준에 따라 처리 될 수 있다. 충돌 캐시 에 보유할 CCF는 1차 노드 콘텐트 캐시 (PNCC) 에 존재하지 않는 CCF 를 보유하 도록 할당되어야 하는 로컬 노드 저장 장치의 비율을 정의한다. 따라서, CCR 및 그에 대응하여 저 장된 CCF 가 서로의 경로를 조기에 교차하는 경우, 컨텐츠 요청은 정당하게 이행될 수 있다. 정보의 의도 하지 않은 카오틱 충돌을 효율적으로 사용하기 위해 보유되는 CCFs 2318의 '스위트 스폿 (sweet spot)' 최적화 량이 있다. 따라서 동적 전략 적응에 의한 전략의 동적 분산은 'sweet spot'변수를 발견하고 배포하 려고 시도한다. 루트 신뢰도 / 거리 트레이드 오프 는 선택된 노드 의 신뢰도와 이동 예정 거리 사이의 선택 트레이 드 오프에 관한인지 된 효율성 영역을 정의한다. 최대 효율을 위해 이상적으로 조정 된 변수는 NSS 을 통 해 계산 된 주변 환경 변수에 따라 달라진다. ITII 마이크로 체인 트리거 는 앱체인 을 메타체인 에 대한 자원 소비를 생략하여 지리적으로 고립된 정보의 이전을 위한 정보 사용을 최적화 하는 마이크로체인 포맷으로 스위칭하기 위해 노드 투표를 하는 데 필요한 정보 전송 격리 색인 (ITII) 값을 정의한다. 트래픽 컨센서스 라운딩 배수 1024는 NVCI 및 성능 변수의 배수가 상향 또는 하향으로 반올림된 것이다. 이 값이 증가하면 이 변수의 영향을 받는 섹터의 상대적 크기가 점차적으로 커진다. 이 값이 감소하면 섹 터는 크기가 줄어들고 노드은 카운트한다. NSS 변수 풀링 간격 (NSS Variable Pooling Interval) 은 얼마나 자주 노드가 그들이 인식하는 NSS 변수들을 (중첩을 공유하는 섹터들 내에서) 알릴지를 정의한다. 따라서 섹터 는 자체 NSS 특성에 대한 컨센서스를 이끌어 낼 것이다. 이 간격이 더 작은 경우; 더 엄격한 통합과 보다 많은 동시성 이 있을 것이며, 더 많은 네트워크 110 리소스가 고갈 될 것이다. 이 간격이 더 크면; 낮은 동시성과 더 적은 네트워크 110 리소스가 고갈된다. 작업 배당 배수 는 최저 및 최고 지불 섹터들 사이의 지불 불일치 강도를 정의한다. 따라서 경제는 심한 포화 지역에 이르는 작업 단위에 보다 더 강렬할 수 있다. 이 변수가 증가하면 심한 포화 지역에 대한 참 여 욕구가 커지므로 부족한 지역에 대한 참여 동기가 낮아진다. 때문에 이 변수가 높으면 인프라가 컨텐츠 수요 변동에 더 빠르게 더 잘 적응하는 경향이 있다. 그러나 수요의 일관성이 혼란스러울 수 있기 때문에 인프라 위치 변동이 혼란스러울 수 있다. 최소 캐시 보유 시간 (Minimum Cache Retention Time) 은 캐싱 노드 가 채택하기로 선택한 캐시를 보유하도록 요구되는 최소 시간 량을 정의한다. 이 변수의 사용은 BCHAIN 네트워크 가 캐시 위치 에 서 지나치게 혼란스러운 회전율을 가지지 못하게 의도되어, 지연 시간을 증가시키고 컨텐츠 전달에 관한 신뢰도 를 감소시킨다. 이 변수를 너무 높게 설정하면 캐시 배포 네트워크가 지나치게 엄격 해지고 컨텐츠 요구 변화에 제대로 적응할 수 없게 된다. 마이닝 투 캐싱 지불 비율 은 마이닝 선택 알고리즘 (MSA) 을 통해 수행 된 수동 작업과 캐시 선택 알고리즘 (CSA) 을 통해 수행된 수동 작업간에 지불 분할을 할당한다. 그러므로 이 비율은 BCHAIN 네트워크 에 내재된 유한 리소스 딜레마의 트레이드오프 사이를 결정한다. 이러한 트레이드오프는 데이터 무결성의 충분한 중복성과 최적의 서비스를 위한 적절한 지리적으로 분산 된 캐시 제공을 유지하는 것이다. 캐쉬 부분 삭제 임계치는 데이터 보호처 처리 (DRP) 를 통해 데이터를 구하는 섹터 의 채굴자 가 위험에 있는 데이터를 삭제하는 것이 안전 할 때를 정의한다. 노드 캐시 제공자 (NCP) 는 세금 결과 유닛 에 따라 채굴자에 의해 설정된 ultimatum최후통첩을 준수하는 시드 캐시 풀 에서 노드까 지의 위험에 있는 데이터 일부를 제공한다. 캐시 이행이 이미 발생했더라도, 위험에 처한 데이터의 채굴자의 사 본을 삭제하는 것은 여전히 적절하지 않을 수 있다. 이것은 일부 노드 가 캐시 이행이 발생했는지 여부와 상관없이 데이터를 채택하기로 결정할 수 있기 때문이다. 또한 캐시 이행이 발생하자마자, 준수하는 척하는 데 이터를 즉시 삭제함으로서 불량 노드 806의 데이터 무결성 공격 벡터의 경우 보호 수단의 역할을 한다. 따라서 캐시 이행 이벤트 이후에 채굴자 복사본이 시드 캐시 풀 2112에서 삭제되는 이벤트가 발생한다. 그러므로 캐쉬 부분 삭제 임계치의 값이 크면 위험 요소 데이터가 구제되는 보장이 추가되지만 채굴자의 저장 장치를 오 랫동안 점유하게 된다. 따라서 BCHAIN 네트워크 가 그 공간을 이용하도록 생산적인 다른 작업을 위한 기회 를 제거한다. 그런 다음 삭제 임계치의 값이 작을수록 스토리지 자원을 증가시키지 않는 비용으로 위험에 있는 데이터가 복구되지 않았을 리스크가 높아진다. 섹터 세금 규모는 관련 섹터 의 노드 에 부과되는 세금 결과 유닛 의 값 크기에 대한 배 수로서 작용한다. 따라서 규모 1036의 값이 높을수록 섹터 의 노드 에 더 큰 잠재적 인 과태료가 부 과되고, 더 낮은 값은 더 작은 잠재적인 과태료가 될 수 있다. 도 73은 SCM 이 모듈러 입력 및 출력을 처리하는 방법을 도시한다. 현재 선호 전략 914를 초기 입력으로 시작한다. 전략 은 스테이지 에서 언팩되며, 이것은 부모 모듈 (SCM) 에 의한 조작 및 처리를 위해 중간 포맷으로 추출된다는 것을 의미한다. 그러므로, 전략 기준 구성 은 입력된 현재 선호 전략 으로부터 단계 에서 생성된다. 이와 병행하여, 도 74에 도시 된 로직은 전략 기준 구성을 출력 전략 배포가 되는 전략 914의 새로운 저 위험 실험 버전으로 업데이트한다. 도 74에 도시 된 업데이트 프 로세스가 완료되면, 전략 구문 어셈블리 (SSA) 모듈은 정보를 BCHAIN 프로토콜 을 동작시키는 다른 모듈들이 이해할 수 있는 포맷으로 리팩(repack)한다. 따라서, SSA 는 단계 의 실질적인 인버스를 수행한다. 따라서 전략 배포 916은 SCM 984의 모듈 출력으로 제출되지만 사용 가능한 전략 기준 구성 요소는 모 두 포함된다 (설명 목적으로 3 개만 표시된다: 홉 증인 만료 1000, 병렬 홉 확산 기준 1002 및 병렬 홉 감소 기 준 1004). 도 74는 창의성 모듈 이, 로컬 BCHAIN Network 110 환경의 상태를 반영하는 NSS 변수를 고려하면서, 어떻게 전략 기준 구성을 더 효율적이고 더 나은 수행이 예상되는 방향으로 업데이트에 사용 되는지를 나타낸다. 1136 단계에서 동적 전략 생성 및 변형을 관리하기 위해 미리 정의된 템플릿인 전략 생성에 서 현재 선택된 기준의 모드 1138에 창의성이 부여된다. 이러한 미리 정의 된 템플릿은 미리 정의 된 모드 템플 릿 관리 (PMTM) 1134에서 생성된다. 창의성 은 폼 A와 폼 B의 2 개의 입력을 처리한다. 폼 A는 단계 1146 에서 정의되고 단계 1144에서 선택된다. 그러므로 전략 기준 구성 992의 모든 단일 기준은 개별 프로세스에 대 해 창의성 과 폼 A로 선택된다. 폼 B는 필드 카오스 해석 (FCI) 918에서 986 단계의 필드 카오스의 전반적 인 해석으로 도 71에 도시되어 있다. 그러므로 창의성의 처리가 끝나면 출력폼 AB는 단계 1140에서 기준 992의 새로운 제안된 variations로 생성된다. 그 후 단계 에서 새로운 변경들이 전략 기준 구성 에 투입된다. 도 75 - 79는 자원 사용, 운영 효능 및 진단의 자체 모니터링을 다루는 UBEC 플랫폼 및 BCHAIN 프로토콜 의 핵심 요소를 보여준다. 프로그램 디버깅은 자동으로 관련 성능 및 / 또는 크래시 / 버그 로그를 자동으 로 수집하여 자동으로 작동되고 결국 셀프 프로그래밍 셀프 혁신 (SPSI) 130 및 SPSI Indirect Development(SID) 1190으로 전송된다. 따라서 UBEC 플랫폼 및 BCHAIN 네트워크 / 프로토콜 의 프로그래 밍 오류 및 일반 오류가 자동으로 검색, 분석 및 수정된다. 도 75에서, UBEC 사용자 는 사용자 노드 상호 작용 (UNI) 에서 수행 된 생체 인식을 통해 UBEC 플랫 폼 에 액세스한다. 따라서, 인증된 사용자 세션 이 생성되어, 관련 노드리스트 가 단계 * 1150 에서 추출된다. 인증된 사용자 세션 은 또한 프런트-엔드 사용자 인터페이스 에 액세스하는 데 사용 되어 경제적 특성 선택 으로 이어진다. 단계 1152에서, UBEC 사용자 는 BCHAIN 프로토콜 의 계 산 및 네트워크 자원 가용성 에 의해 참조되는 경제적 특성 을 선택한다. UBEC 플랫폼 의 실제 사용에서; UBEC 사용자 는 UBEC 어플리케이션 의 초기 설정 및 로그인시 경제적 특성 을 선택한 다. 따라서, UBEC 사용자 가 사용자 가 프론트 - 엔드 사용자 인터페이스 와의 새로운 세션을 개시 할 때마다 수동적으로 경제적 특성 을 선택하는 실제적인 사용은 기대되지 않는다. 단계 1154에서; CNRA는 연관된 노드리스트 를 통해 UBEC 사용자 와 연관된 노드 의 잉여 가용 자원을 측정하는 방법으로서 UBEC 플랫폼 으로부터 경제적 특성 선택 을 참조한다. 도 76에서, 단계 1154는 경제적 인센티브 선택 (EIS) 모듈에 대한 참조를 허용하는 CNRA 를 호출 함으로써 계속된다. EIS 는 노드 가 다른 노드 작업 또는 진단 로그 제출 (DLS) 의 작 업 세션을 수행하도록 권고 할 수 있다. 따라서, BCHAIN 프로토콜 의 이러한 인스턴스를 동작시키는 노드 는 BCHAIN 네트워크 내에서 자동화 된 기술적 마이크로 서비스의 공급 및 수요의 균형을 이끄는 EIS 를 통한 투자에 대한 최선의 투자 수익으로 이기적으로 노력한다. 따라서, 단계 에서 노드 상 의 EIS 의 로컬 실행은 노드 가 DLS 의 실행을 통해 자기 부과 진단 노드가 되도록 트리거 할 수 있다. 그 후 단계 에서 노드 는 자신을 메타체인 의 진단 노드 위치에 진단 노드로 선 언한다. 스테이지 의 실행으로부터 노드 의 초기에 선언 된 상태로 인해, 노드 는 다른 노드 가 선언 된 기능을 수행하고 있음을 확인할 수 있을 때까지 미확인으로 표시된다. 이는 알고리즘 기준의 동기화 된 하지만 개별의 인스턴스를 통해 효율적인 협업을 달성하는 BCHAIN 프로토콜 의 준수 원칙에 따 라 수행된다. 따라서 BCHAIN Network 110에는 신뢰가 없는 조화로운 협력이 있다. 메타체인 834의 진단 노드 위 치 844에 대한 업데이트는 커스텀체인 인터페이스 모듈 (CIM) 2470으로 전송되어 실제 메타체인 834에 채굴되고 커밋된다. 도 77에서, 도 76에서 컨텍스트로 주어진 스테이지들 (1162, 1164)은 단계 로의 논리 흐름을 계속한다. 단계 1166에서; 노드의 메타체인에 대한 진단 노드임에 관한 선언으로 인해, 동일한 섹터 내의 다른 노드 는 JICS 및 JMCR 을 통해 진단 로그를 송신한다. 그 후, 단계 에서 진단 로그는 자체 선언 된 진단 노드에 의해 신뢰성을 위해 검증된다. 이는 스팸 및 악용 공격을 완화한다. 그 후 단 계 에서 공식 시스템 토큰 으로 태그 된 로그 유닛 은 SPSI 간접 개발로 제출된다. 관리 콘솔 (MC) 및 (I2CM) 을 통한 (SID)는 UBEC 플랫폼 내의 앱체인 로서 모두 동작 하고 BCHAIN 네트워크 에 의해 호스팅된다. 로그 유닛 을 SID 에 전송하는 것은 UBEC 사용자 프로그래머가 간접 방법을 통해 셀프 프로그래밍 셀프 혁신 (SPSI) 프로그래밍을 더 잘 유도 할 수 있게 한다. 공식 시스템 토큰 은 로그 유닛 이 LOM , LIZARD , MPG 등과 같은 공 식 앱체인으로부터 유래 된 암호 증명이다. 앱체인 은 UBEC 플랫폼 110에 핵심 기능을 제공하는 경우 ‘공 식’으로 태그가 지정된다. Similitude는 파일 탐색기, RAM과 같은 기본 구성 요소용 드라이버, 명령 실행을 위 한 터미널 창과 같이 제거 할 수 없는 운영 체제의 핵심 프로그램이다. 스테이지 1172에서는 스테이지 1170에서 제출된 동일한 로그 유닛 은 셀프 프로그래밍 셀프 혁신 (SPSI) 앱체인 에 연결되는 자동 리 서치 메커니즘 (ARM) 을 통해 LOM 에 제출된다. 로그 유닛 은 SPSI 자체가 UBEC 플랫폼 내에서 자신 및 다른 앱체인 를 더 잘 프로그램 할 수 있게 한다. 그 후 단계 1174에서 완료된 진단 작업 증명이 WPCP (Work Payment Claim Processing) 1258로 전송되어 노드 에서 와트 단위로 전달 된 자 원을 교환한다. 도 78에서는, 원래 도 77에 도시된 논리에 관한 상세내용이 확장되어 있다. 동일한 섹터 내의 다른 BCHAIN 노드는 진단 로그 제출 (DLS) 을 통해 관련 위치에 제출 될 관련 로그를 기록하기 위해 진단 로그 수집 (DLC) 모듈을 처리한다. DLC 1179의 이러한 로그는 JICS 4194로 전달되며, 자체 선언된 진단 노드 에서 DLS 1160을 호출한 JACR 4208의 인스턴스에 CCR 2308을 동반하지 않는 CCF 2318을 제출한다. 노드의 786 은 메타체인 834의 진단 노드 위치 844에있는 진단 노드라고 한 선언으로 인해 관할권을 명시적으로 명시하고 있으므로 선출된 관할권으로 인해 JICS 4194가 보낸 CCF 2318 패킷을 암묵적으로 받아 들여야 한다. 따라서, UBEC 플랫폼 내의 앱체인 으로서 동작하는 LIZARD 는 CCR 을 수반하지 않고 CCF 패킷을 모니터하고 정당화 할 수 있다. 그렇지 않으면 명백한 자기 부과된 역할로 인해서만 관련되는 CCF 를 수신하는 노드로부터의 명시적인 허가가 없기 때문에 스팸처럼 보일 수 있다. 따라서 LIZARD 'S 120 관할 추적 기술은 BCHAIN Network 110 트래픽의 최하위 계층에서 구현된다. 단계 1168은 DLV (Diagnostic Log Validation) 1180 모듈을 통해 로그의 신뢰성을 검증한다. 따라서 올바른 소스에 제출하기 위해 로그를 수집하 는 동안 로그를 인증 혹은 비인증으로 확인하는 것이 진단 노드의 주요 작업이다. 진단 로그 유닛 은 인 증 된 것으로 판명되면 DLV 에 의해 생성된다. 해당되는 경우 공식 시스템 토큰 1184가 포함된다. 도 79는 도 77에서 설명한 논리 흐름을 더 설명한다. 단계 1170에서, 진단 로그 유닛 은 관리 콘솔 (MC) 및 (I2CM) 에 의해 처리된다. 그 다음, 그러한 로그 유닛 은 UBEC 사용자 에 의해 프 로그래머로서 검토되어 SPI 를 간접적으로 프로그래밍하고 가용시키는 기준점이 된다. 잠재적으로 적용 가 능한 공식 시스템 토큰 과 함께 진단 로그 유닛 은 공식 앱체인 의 직접적이고 자동화 된 유 지 및 고정을 위해 SPSI 로 보내진다. 도 80 - 83은 경제적 인센티브 선택 (EIS) 1232와 WPCP (Work Payment Claim Processing) 1258을 보여준다. 도 80에서, EIS 는 BCHAIN 네트워크 에 대한 공급 / 수요 조정 메커니즘으로서 작용한다. 액티브 노 드 작업 을 찾는 노드 는 스테이지 를 통해 EIS 를 호출하여 노드 에 투자 수익 을 가장 많이 줄 가능성이 있는 최상의 작업 유형을 선택한다. 그 후 단계 1236은 메타체인 834에 관한 로컬 및 원격 변수를 분석하여 현재의 공급 수요 동향을 파악한다. 따라서 SDA (Supply Demand Arbitration) 모듈이 호 출된다. SDA 는 메타체인 을 참조하여 BCHAIN 네트워크 내의 공급 / 수요 벡터의 논리적 표현 을 생성한다. 따라서 노드 작업의 어떤 카테고리가 가장 수익성이 높은지를 추정 할 수 있다. 따라서 SDA 1238 은 계산 결과를 나타 내기 위해 공급 수요 메이크업 1240을 제출한다. 단계 는 선택된 경제적 특성 (74 0)을 준수하면서 잉여의 계산 및 네트워킹 리소스가 이용 가능한지를 검사하는 단계 로 이어진다. 단계 1242는 CNRA (Computation and Network Resource Availability) 1156을 호출하여 리소스 가용성을 확인한다. 경제적 특성 740 지정은 UBEC 플랫폼 인터페이스 (UPI) 728에서 디자인되었다. 조건 1246 \"아니오, 리소스 사용 가능하지 않음\"이 발생하면, 단계 1250이 호출되어 EIS 1232의 작동을 종료하고 널(Null) 출력을 제출한다. 조 건 1248 \"예, 리소스 사용 가능\"이 발생하면, EIS 1232는 노드 작업 선택 (NJS) 1252를 호출한다. NJS 1252는 적절하게 수익을 창출 할 수 있는 작업을 선택함에 있어서 공급 수요 메이크업 1240과 노드 리소스의 가 용성을 참조한다. 도 81은 경제 인센티브 선택 (EIS) 과 작업 지불 클레임 처리 (WPCP) 사이의 전이를 도시한다. 액 티브(Active) 1254 또는 패시브(Passive) 1256 작업이 완료되면 WPCP 1258에 대한 수익 클레임이 이루어지며 메타체인 의 와트 경제 에 대한 지불을 확인하고 처리한다. 패시브 노드 작업 는 네트워크 의 요구로 인해 BCHAIN 프로토콜 에 연루되는 작업이다. 예를 들어, CCR 2308 또는 CCF 2318 라우팅 은 네트워크 220의 필요성이며, 프로토콜 에 따라 만들어진 합법적 요청을 이행하기 위해 적시적소에 노드 에 필요하게 된다. 액티브 노드 작업 은 선택된 경제적 특성 740에 따라 그 소유자인 UBEC 사용자 를 대신하여 노드 의 이기적인 동기들로부터 행해진다. 따라서, 패시브 노드 작업 는 프로토 콜 의 준수로 인해 연루될 때, EIS 는 노드 작업 선택 을 통해 액티브 노드 작업 을 호 출한다. 액티브 1254 또는 패시브 1256 작업이 완료되면, 완료 작업 클레임을 받는 1260 단계가 처리된다. 그 후, 단계 는 클레임되는 작업 유형이 완료되었음을 식별한다. 그 다음, 단계 1264는 확인된 유형의 작업 이 정적 하드 코딩된 정책 (SHP) 에 정의되어 있는지를 확인하기 위한 검사를 수행한다. 1264 단계는 노드 작업 유형이 BCHAIN 프로토콜 에 의해 정당하고 공식적으로 인정됨을 보장한다. 또한 WPCP 1258이 사용하 는 참고 자료 및 리소스 즉 앱체인의 보류중인 검증 작업 지불 , 메타체인 834의 와트 경제 그 리고 CIM (커스텀체인 Interface Module) 2470의 해결된 작업 새 블록 공지 2480에 표시된다. 보류중인 검증 작 업 지불 은 정적 하드 코딩된 정책 (SHP) 488에서 BCHAIN 네트워크 내의 공식 작업 유형 1264 내에 서 수행되는 실제 업무에 대한 제 3 자 검증을 수행하는 수단이다. 와트 경제 862는 노드 에 대한 와트 단 위의 할당을 추적한다. 해결 된 작업 새로운 블록 공고 는 WPCP 내에서 처리 루틴을 호출하는 두 번째 수단이며, 단계 는 처리 루틴을 호출하는 첫 번째 수단이다. 도 82는 WPCP 의 논리 루틴에 관한 보다 상세한 내용을 도시한다. 단계 에서 처리된 식별된 유형의 작업이 SHP 에서 정의되지 않으면, 작업 클레임은 거부되고 WPCP 의 모듈 실행은 종료된다. 단계 1264에서 YES 조건 이 발생하면; 작업 클레임은 1270 단계의 CPV (Corroborative Proof Verification) 1266을 통해 제3 자 입증 증거 처리를 통해 검증된다. 따라서 1264 단계에서 확인된 확정된 작업 범주 1280은 처리를 위해 CPV 1266에 제출된다. CPV 프로세싱이 완료되면, 미확인 된 의 결과는 작업 클레임을거부하고 모듈 실행을 종료하는 단계 로 이어진다. 검증된 1272의 결과는 두 개의 잠재적인 단계 1276 및 1278 중 하나가 실행되도록 한다. 노드 가 패시브 또는 액티브 작업을 완료함으로써 WPCP 가 호출 된 경우; 단계 가 호출되어 메타 작업 의 검증된 작업 지불을 보류중인 검증 작업 지 불 로 제출한다. 그러나, WPCP 가 해결 된 새로운 블록 공고 에 의해 호출 된 경우, 보류중인 검증 작업 지불 을 와트 경제 에 제출하는 단계 가 실행된다. 도 83은 WPCP 에서의 논리 루틴에 관한 보다 상세한 내용을 도시한다. 해결된 작업 신규 블록 공고 (Solved Work New Block Announcement) 을 통한 WPCP 1258의 모듈 식 호출 시 단계 1282가 실행된다. 단 계 는 새롭게 해결된 블록과 관련된 앱체인 으로부터 보류중인 검증 작업 지불 을 검색한다. 따 라서, 보류 지불 (Pending Payments) 가 출력으로서 생성된다. 단계 는 CPV 를 통해 보류 지불 (Pending Payments) 로부터 추출 된, 포함 된 제3자 확증 증명을 독립적으로 검증하는 단계 로 이어진다. 따라서 CPV 1266은 확정된 작업 카테고리 1280의 보류 지급에 대한 메타체인 834 또는 제3 자 Corroborative Proof 1292에 대한 확인을 체크한다. 도 84 내지 169는 커스텀체인 동기화 & Reconciliation (CSR) , 캐시 시딩을 제공하는 마이닝 노드 (MNSCS) , 및 마이닝 실패 데이터 재건와 같은 세 가지 주요 가지로 동작하는 데이터 무결성 관리 재건 (MFDR) 1212. DIM 1024의 목적은 앱체인 의 데이터 무결성을 분산 방식으로 유지 관리하고 오프라인 상태 에서 작업을 수행한 노드를 동기화하는 것이다. 데이터의 합법성의 최종성은 프로토콜의 예상되는 동작이 무엇 이었는지 에뮬레이트 하는 DC2 (Deep Client Decision Critique) 1506으로 계산 비용이 많이 드는 방법으로 고 려된다. 따라서 노드는 그에 따라 신뢰되거나 불신한다. 섹터 세금 생성 (STC) 1872 모듈은 캐시 이행이 발생할 때 가변적 인 시간에 제정 될 긍정적이거나 부정적인 세금 결과를 열거하는 Tax Consequence Unit (TCU) 1852를 생성한다. TCU 의 구성 요소를 정의하는 요소에는 섹터 노드 수, 섹터 수요 규모, 섹터 비상 기금 규모 등이 포함된다. Sector Tax Enforcement (STE) 924 해당 섹터의 노드의 캐시 이행 성능을 평가한다. 섹터 내에 서 캐시 이행 상태가 최종적으로 달성되면 이 모듈은 세금 결과 단위 (TCU) 1852에 명시된 대로 세금 코드를 적 용한다. TCU 에는 캐시 이행 시점에 제정된 schedule tax plan이 있다. Tax Consequence Unit (TCU) 1852는 각 섹터의 노드가 새로 채굴 된 블록에서 배달 된 특정 컨텐츠의 캐시 이행을 총체적으로 수행하는 데 걸리는 잠재적인 시간을 고려하여 제정될 잠재적인 세금 감면 또는 과징금을 열거한다. STA (Sector Tax Announcement) 1864는 관련 섹터 관할권 내의 모든 해당 노드에 세금 결과 단위 (TCU) 1852를 브로드캐스트한다. 노드 참조는 기본적으로 메타체인의 위치 연결 을 통해 만들어진다. 섹터 세금 수령 (STR) 1904는 세금 결과 단위 (TCU) 1852 준수에 가장 효과적인 시간을 결정하는 개별 BCHAIN 노드 내에서 처리 되는 논리를 가지고 있다. 그러한 결정은 동일한 TCU 를 수신한 동일한 섹터의 다른 노드와 협력하지 않 고 이루어진다. 따라서 노드는 경제적 특성, 대체 작업의 가용성 및 이익 마진, 사용 가능한 로컬 리소스 등과 같은 자체 요소를 평가한다. 논리는 모든 노드가 수행하기 위해 공고 된 캐시의 채택을 지연 할 경우 해당 섹터 의 모든 노드가 메타체인의 비상 섹터 자금에 제출되는 세금 형식으로 가격을 동등하게 지불해야 한다는 것을 이해하면 실행된다. 그러므로 한 섹터 내의 노드는 그러한 주제에 대한 명확한 의사 소통 없이 공동 작업 을 해야 하며 시나리오와 같이 죄수의 딜레마를 불러 일으킨다. MFDR (Mining Failure Data Reconstruction) 1212는 앱체인 / 마이크로체인의 채굴자가 보유한 데이터의 부분적 무결성을 잃는 드문 경우에 활용되며, 이러 한 데이터를 캐시한 노드는 해당 데이터를 확인할 때 다시 채굴자에게 제출할 수 있다. 도 84는 마이닝 선택 알고리즘 (MSA) , 와트 이코노미 , 앱체인 캐시 위치 , 해결된 work new? , WPCP (Work Payment Claim Processing) , 데이터 무결성 스캐닝 (CSR), data refuge processing 1984, content in danger report, 커스텀체인 동기화 & reconciliation (CSR) / 앱체인 Merge Processing (AMP) 1740, 경제적 인센티브 선택 (EIS), 캐시 시딩 공급 광업 노드(MNSCS) 1850 & Mining 실패 데이터 재구성 (MFDR) 1212을 포함하고 상호 작용 하는 로직(DIM 1204)을 제공한다. MNSCS 1850은 새로 채 굴 된 블록에서 데이터 캐시의 초기 시드를 제공한다. 이는 데이터 보존 무결성의 적절한 분배와 그러한 데이터 의 효율적인 지리적 분포를 보장한다. MNSCS 1850은 Sector Tax Creation (STC) 1872 Sector Tax Enforcement (STE) 1924 Sector Tax Announcement (STA) 1864 Tax Consequence Unit (TCU) 1852로 구성된다. 도 85는 마이닝 캐시 보유 시간 , 마이닝 투 캐싱 지불 비율 , 캐시 선택 알고리즘 (CSA) , 마이닝 선택 알고리즘 (MSA) , 앱체인 지불 논리 1214, BCHAIN 작업 단위 1216를 포함하는 DIM1204 구성 성분과 그들의 상호작용의 추가 논리를 제공한다. 도 86은 앱체인 지불 논리 와 함께 동작하는 DIM 알고리즘 MSA 및 CSA 의 로직을 제공하며, 앱체인 관리자 , 인프라 에 대한 지불 마감, 앱체인 사용자 앱체인 관리자로부터 입력을 수신하고 앱체인 Payment Policy 에 공급하는 앱체인 에 대한 지불 정책을 정 의한다. 앱체인 Payment Policy는 BCHAIN 작업 장치 에 공급되는 앱체인 관리자 및 앱체인 사용 자 모두에게 입력을 제공한다. 도 87의 노드 정보 분배 는 블록 오버랩이 BCHAIN 노드 (1296, 1298, 1300 및 1302) 사이의 검증 컨센서 스를 강화함을 나타낸다. 메타 체인 블록이 다른 노드에서 다운로드되면 모든 노드가 보유한 (모든 메타 체인 블록에 대해) 블록의 알려진 해시를 참조하여 정확하고 정확한 블록으로 확인된다. 해시 collision 공격에 대한 사전 예방 조치로서 합법적 노드는 합법적 인 사본의 중복으로 인해 메타체인 블록의 올바른 내용에 대한 컨센 서스에 도달 할 수 있다. 따라서 메타체인의 무결성이 보존된다. 도 88은 BCHAIN 프로토콜에 의한 필수 보존 영역의 완전 보존 (full retention of mandatory retention zone) 과 첫 번째 3 블록의 유지를 명령하는 풀 메타 클러 범위 가용성 (Full Metund Scope Available) 및 메 타 체인 배포 가용성 을 보여줌으로써 노드 정보 분배 BCHAIN 네트워크의 모든 섹터에서 끊임없이 전체 distribution 곡선을 가지며 경과 시간에 비례하여 기하 급수적으로 가용성을 감소시킨다. MRL (메타체인 Retention Logic) 모듈은 기하 급수적으로 감소하는 distribution 곡선에서 메타체인 블록의 보존을 선택 하기 위해 하드코딩 된다. 이것은 시간이 지남에 따라 메타체인 블록이 프로토콜 함수에 필요하다는 가능성이 기하 급수적으로 감소하기 때문에 수행된다. 예를 들어, 앱체인 Merging1308과 관련하여 3 년 전에 분리 된 두 버전의 앱체인간에 합병이 처리 될 가능성은 거의 없다. 따라서 오래된 블록을 많이 보유하는 것이 경제적으로 이익이 되지 않으므로 MRL 1658은 새로운 블 록과 비교하여 기하 급수적으로 덜 유지한다. 도 89의 앱체인 Merging 은 블록들 (1314, 1320, 1326)로 구성된 앱체인 Version A와 블록들 (1312, 1318, 1324)로 구성된 앱체인 Version B를 나타낸다. 앱체인 Version Time Synchronization (AVTS) 모듈은 두 버전 앱체인의 암호 타임 스탬프를 비교하여 앱체인 Version A의 어느 블록이 앱체인 Version B의 블록과 연대 순으로 연관되는지 추론할 수 있다. 변경된 Merkle Hash 1330은 도 90에서 정의된다. 도 90은 블록 및 블록 이 블록 에서 병합되는 도 89로부터 앱체인 Merging 을 계속 한다. 변경된 머클트리해시 1330은 앱체인의 모든 이전 블록을 고려하여 계산된다. 따라서 블록의 임의의 단일 해시 아이덴티티 또는 블록의 추가 또는 제거는 최종 머클트리해시가 완전히 변경 되도록 한다. 따라서 머클트 리해시는 노드간에 사용되어 앱체인의 내용과 일치하는지 확인하고 로지스틱스 분배를 위해 서로의 버전에 의존 할 수 있다. 앱체인 Merge Processing 프로세스로 중반 앱체인 블록을 삽입 할 수도 있지만, 노드는 작업 증명 및 딜레마 수용 증명에 대한 기준이 동일하기 때문에 궁극적으로 새로운 머클트리해시에 대한 컨센서스에 도달 한다. 머클트리해시 A 1336, 머클트리해시 B 1334 및 머클트리해시 AB 1332는 머클트리 계산기 (MTC) 1338 및 암호 핵심 (CC) 768과 함께 각 블록에 대해 표시된다. 도 91은 병합 된 앱체인 AB 1342 및 앱체인 Version Time Synchronization (AVTS) 1328을 초래하는 앱체인 버 전 A 1340과 앱체인 버전 B 1344 사이의 앱체인 Merging 1308을 보여준다. 도 92는 BCHAIN 노드 A , BCHAIN 노드 B , BCHAIN 노드 C 및 앱체인 Merge Processing (AMP) 1740에 대한 Custom Chain Ecosystem Version A 1346 및 커스텀체인 Ecosystem 버전 B 1348 커스텀체인 생태계의 새로운 현상 해석 1356로 조정한다. 동일한 프로토콜 / 알고리즘 기준이 새로운 병합 패러다임에 대한 컨센서스를 이끌어낸다. 각 BCHAIN 노드는 BCHAIN 프로토콜 클라이언트의 합법적 인 버전을 실행 중이므로 동일 한 기준을 가짐으로 병합 프로세스에 대한 컨센서스에 도달 할 수 있다. 이는 또한 대체 기준이 거짓 결과로 이 어지기 때문에 프로토콜 클라이언트의 불법 버전을 실행중인 BCHAIN 노드를 제거하며, 그 결과는 대다수의 합법 적인 노드에 의해 무시된다. 도 93은 커스텀체인 Ecosystem Version A 및 커스텀체인 Ecosystem Version B 을 도시한다. 조화 될 예정의 분리되고 충돌하는 커스텀체인 생태계. 노드 그룹 간의 지리적 인 분리로 인해 두 그룹 간의 동기화 가 불가능했다. 따라서 그들은 서로에 대한 고려 없이 거래를 수행하여 메타체인s와 각 앱체인 / 마이크로체인s 가 더 이상 동일하지 않다. 다양한 사용자 정의 생태계의 일치하는 앱체인이 점선으로 표시된다. 서로 다른 버 전의 생태계에도 불구하고 ID가 일치하는 앱체인가있을 것으로 예상되며 각 버전은 올바른 버전이라고 주장한다. 커스텀체인 Dilemma Interpretation (CDI) 1660에 의한 지리적 분리 딜레마의 해석은 이 충돌을 해결 할 수 있다. 도 94는 커스텀체인 생태계 A , 커스텀체인 생태계 버전 B , 커스텀체인 딜레마 해석 (CDI) , 전체 딜레마 해석 , 커스텀체인 생태계 1358 및 앱체인 병합 처리(AMP) 1740의 현상 해석에 관한 BCHAIN 노드 A / B / C (1350,1352,1354)에 대한 세부사항을 제공한다. Pre-Merge 패러다임의 사전 및 불합리 컨센서스 (BCHAIN 노드 1350, 1352, 1354 및 커스텀체인 생태계의 각각의 현상 해석 358 사이). 각 BCHAIN 노 드에는 노출 된 커스텀체인 Ecosystem에 대한 특정 인식이 있다. 그들은 합법적 인 지리적 분리 딜레마를 보였 으므로 생태계의 새롭고 올바른 상태로 인도 할 전체 딜레마 해석이 처리 될 때까지 현재 버전의 생태계가 존재 하지 않는다고 생각하는 반응에서 동기화된다. 도 95는 커스텀체인 생태계 표현 (Custom Chain Ecosystem Manifestation) 1362, 전체 딜레마 1360 파트 1-5 1362, 1364, 1366, 1368, 1370, BCHAIN 노드 A 1350, BCHAIN 노드 B 1352, BCHAIN 노드 C 1354 및 커스텀체인 Dilemma Interpretation (CDI) 1660의 현실에 대한 세부사항을 제공한다. 커스텀체인 생태계 표현 의 현실 1362, 전체 딜레마 해석 1360은 관찰 할 수 있는 커스텀체인 생태계의 실제 복잡한 상태를 해석 한 것이다. 즉, 계산을 통한 BCHAIN Nodes의 추상 해석은 관찰 가능한 관찰 범위에 있는 데이터의 실제 표현을 직접 참조한다. 전체 딜레마 해석은 부분들의 혼란스런 분포로 흩어져 있어도 필드에서 구할 수 있다. 이 딜레마 해석은 동일한 앱체인의 두 버전을 채굴하게 된 기존의 지리적 분리 딜레마를 추상화 한 것이다. 커스텀체인 Ecosystem의 현실 내에 완전히 존재하는 딜레마에도 불구하고 개별 노드의 노출은 점진적일 수 있다. 노드는 딜레마의 전체 해석 을 받았을 때 그 구조를 수신할 수 없으므로 노드가 받는 모든 증가분은 딜레마의 전체를 나타낸다고 가정된다. 이것은 새로운 통합 된 앱체인과 그에 따른 Merkle Tree Root에 대한 노드 간의 초기 불일치로 이어질 수 있지 만, 결국 각 BCHAIN 노드 (1350, 1352, 1354)가 딜레마 전체를 정의하는 모든 부분에 일관된 노출을 받으면 컨 센서스에 도달한다. 체인 노드별로 딜레마 파트의 Chaotically Staggered Interpretation. 각각의 개개의 BCHAIN 노드 (1350, 1352, 1354)는 딜레마 해석의 다른 측면이나 다른 부분에 다른 순서로 노출되어 있다. 그러 므로 각 노드가 전체 딜레마 해석에 충분히 노출 될 때까지 컨센서스에 대한 결여가 있는 전환기가 있다. 도 96은도 95의 BCHAIN Nodes A / B / C 1350/1352/1354, 커스텀체인 딜레마 해석 (CDI) 및 생태계 딜레마 존 재 실제의 staggered 해석 1372, 1374, 1376, 1378, 1380으로부터 계속된다. staggered 해석은 결국 동기화 된 기준이 예정된 컨센서스로 이어진다. 점차적으로 시간이 흐름에 따라 각 노드는 반드시 딜레마 해석의 더 많은 부분에 노출 될 것이다. 유효 부분이 수신될 때마다 그것이 마지막 부분이며 이미 전체 딜레마에 노출되어 있다 고 가정해야 한다. 그러나 진위 여부를 검증 할 때 새로운 부분을 쉽게 채택 할 것이다. 각 노드는 BCHAIN 프 로토콜 클라이언트의 동일한 합법적인 버전으로 프로그래밍되기 때문에 Part 1360에서와 같이 결국 딜레마 해석 의 전체 상태에 대한 컨센서스에 도달하게된다. 도 97에서는 머클트리해시 A 1336, 머클트리해시 B 1334, 차등 , 매치 , 차단 및 차단 을 보여주고 있다. 앱체인 분할 포인트 (점선)는 앱체인에 추가 된 노드가 물리적으로 분리되어 앱체인에 대한 추가 작업을 동기화 할 수 없었던 시점이다. 그러므로 분할 포인트 이전에는 모든 블록이 동일했지만 분할 포인트 이후에는 모든 블록이 다르다. 앱체인 합병이 발생하려면 한 번 동기화가 필요하다. 똑같은 아이덴티티 및 / 또는 목적을 가진 두 개의 앱체인조차도 동일한 제너시스 블록(Genesis Block)을 가지고 있지 않으면 병합 할 수 없다. 도 98 내지도 100은 동일한 앱체인 의 2 개의 상이한 버전 간의 초기 접촉으로부터 전체 딜레마해석 을 포함하는 앱체인 합병 처리 (AMP) 에 이르는 전체 프로세스에 대한 더 상세한 설명을 제공한다. 도 101은 단계 1436에서 CAV (Conflilicting Appchain Verification) 1438 프로세스에 대한 논리, 동일한 앱체 인 836의 서로 다른 두 버전 간의 초기 접촉을 제공한다. 1440 단계에서, 버전 A의 노드 모집단이 (LNT 2620으 로부터) 마이닝 다양성을 충족하였는가? 및 1442 단계에서, 버전 B의 노드 모집단 (LNT 2620에서)이 마이닝 다 양성 요구 사항을 충족했는가? 1444 단계에서 두 데이터 체인 모두(데이터 호환성 충돌)에 있는 마이닝 다양성 요구 사항을 검색한다. 도 102는 CAV 의 도 101로부터의 논리를 계속하고 주요 구성 요소 버전 마스터 / 슬레이브 어피니티 (VMSA) , 앱체인 조정 어필, 마이닝 다양성 요구 및 마이닝 노드 캐시 를 강조한다. VMSA 은 어느 버전의 소프트웨어 체인이 원본이고 어떤 버전이 원본으로부터 확장되었는지를 결정한다. ARA 는 BCHAIN 프로토콜이 자동으로 합병을 처리 할 수 없기 때문에 앱체인 관리자가 수동으로 앱체인 합병을 승인하는 절차이다. 마이닝 다양성 요구는 앱체인 합병이 처음에 승인을 받기 위해 필요한 마이닝 노드 구성의 차이를 정의한다. 도 103 및 도 104는 LMNV , VMSA , ARA , 마이닝 노드 캐시 등의 사용에 관한 상세 한 설명과 함께 CAV 1438에 대한 상세 설명을 더 제공한다.도 105는 CAV 1438, 마이닝 다양성 요구 1446/1448 및 버전 마스터 / 슬레이브 어피니티 (VMSA) 로의 앱체인 피드의 승인을 계속한다. 합법적 마이닝 노드 검증 (LMNV) 1492 내의 확인 지불 부담 (VPB) 1494 은 정의 된 앱체인 방침에 따라 어떤 노드가 앱체인 합병에 대한 지불을 부담해야 하는지 판정을 내린다. 상대 적인 복잡성과 성공적인 앱체인 합병을 수행하는 데 필요한 많은 리소스 사용으로 인해 지불 부담을 할당하는 로지스틱스가 조직 및 개인을 관리하는 데 중요하다. 도 106은 딥 클라이언트 결정 비평 (DC2; Deep Client Decision Critique) 모듈이 타겟 노드의 이전 환 경 상황에 대한 올바른 BCHAIN 프로토콜 응답을 에뮬레이트하기 위해 메타 체인의 관련 이행 블록을 수신하는 CAV 및 LMNV 에 대한 추가 세부 사항을 제공한다. BCHAIN 네트워크 환경 요인을 분석하여 이 모듈 은 이러한 요소에 대한 가장 정확하고 그럴듯한 (모호성과 관련된 상황에서) 응답을 감지 할 수 있다. 따라서 노드의 이전 조치는 노드가 BCHAIN 프로토콜의 정당한 정의에 따르는 지 또는 노드의 펌웨어 / 소프트웨어가 의 도적으로 또는 의도하지 않게 손상되었는지 여부를 확인하기 위해 검사될 수 있다. 따라서 BCHAIN 네트워크 내 에서 앱체인 병합과 같은 후속 절차를 가능하게 하는 노드 신뢰 요소를 설정할 수 있다. 메트릭 보유 다운로드 (MRD) 모듈은 BCHAIN 네트워크의 다른 노드와 상호 작용하여 타겟 메타 체인 블록의 내용을 검색한다. 검증 지불 부담 (VPB) 는 정의된 앱체인 정책에 따라 어떤 노드가 앱체인 합병에 대한 비용 부담을 부담 해야 하는지를 결정한다. 상대적인 복잡성과 성공적인 앱체인 합병을 수행하는 데 필요한 많은 리소스 사용으로 인해 지불 부담을 할당하는 로지스틱스가 조직 및 개인을 관리하는 데 중요하다. 도 107은 LMNV , 앱체인 정책 , 앱체인 , 블록 및 블록 및 AVTS 내에 서의 추가 처리에 대한 세부 사항을 제공한다. 도 108은 LMNV 내의 세부 사항에 대한 도 107로부터 계속되며, 핵심 데이터가 없는 메타 체인 은 관련된 메타 체인 블록 참조가 선택되는 블록 요청 시퀀스 (블록 12, 블록 13 및 블록 14의 점선 사각형)를 나 타내며, 이는 관련 메타체인 블록 참조가 메타 체인 보유 다운로드 (MRD) 1560을 통해 다운로드 되도록 선택될 수 있다. 시간 단위로 뒤로 이동하는 배치(batches)로 블록이 선택되며, 시작점은 앱체인 분할점(split point) 이다. MRD 1560 모듈은 BCHAIN 네트워크의 다른 노드와 상호 작용하여 타겟 메타 체인 블록의 내용을 검색한다. 핵심 데이터가 있는 메타 체인의 출력은 DC2 로 입력된다. 도 109 내지 도 112는 앱체인 정책 및 선택된 마이닝 노드 로부터 가상 인터페이스 를 갖는 에뮬레이션 하이퍼바이저 (B5400), BCHAIN 프로토콜 (BP) 794 및 하이퍼바이저 인터페이스 1556로의 DC2 에 대한 세부 사항을 제공한다. 에뮬레이션 하이퍼바이저 는 노드상에서 동작하는 BCHAIN 프로토콜 의 주요 반복에 영향을 끼치거나 손상시키지 않고 사실상 분리된 환경이 BCHAIN 프로토콜 모듈을 실 행할 수 있게 하기 위해 CPU에 특정 명령을 제출하는 인터페이스이다. 하이퍼바이저 인터페이스 전체 모 듈 복제. 에뮬레이션 하이퍼바이저는 올바른 BCHAIN 프로토콜 응답의 전체 가상화를 측정할 수 있 도록 BCHAIN 프로토콜에 대한 전체 모듈 집합을 로드 한다. DC2 1506 모듈은 타겟 노드의 이전 환경 상황에 대 한 올바른 BCHAIN 프로토콜 응답을 에뮬레이트하기 위해 메타 체인의 관련된 이행된 블록을 수신한다. BCHAIN 네트워크 환경 요인을 분석함으로 이 모듈은 이러한 요소에 대한 가장 정확하고 그럴듯한 (모호성과 관련된 상 황에서) 응답을 감지 할 수 있다. 따라서 노드의 이전 조치는 노드가 BCHAIN 프로토콜 의 정당한 정의에 따르는 지 또는 노드의 펌웨어 / 소프트웨어가 고의적으로 또는 의도하지 않게 손상되었는지 여부를 확인하기 위해 검사될 수 있다. 따라서 BCHAIN 네트워크 내에서 앱체인 병합과 같은 후속 절차를 가능하게하는 노드 신뢰 요소를 설정할 수 있다. 도 113 내지 도 115는 메타체인 보유 다운로드(Metachain Retention Download; MRD) 의 상세한 설명을 제공한다. EFVA (Economic Fair Value Appraisal) 다중 모듈 범위의 공급 / 수요 변수에 관한 입력 정 보를 수신한다. 따라서 특정 작업에 대한 정확한 공정 시장 가치를 측정 할 수 있다. 이는 작업 결정 프로세스 에서 다른 노드에 알리기 전에 나타난다. 또한, 도 115는 1586, 1590 및 1594로 정보 검색 시퀀스를 시작한다. 도 116 내지 도 118은 도 115의 1594에 이어 1602, 1606, 1608, 1612, 1620, 1626, 1632의 정보 검색 시퀀스를 계속하고, MRD 가 뒤 따른다. 도 119는 BCHAIN 노드 (BN) (블록 바운티 요청을 발생시킨 노드), BN (노드를 찾기위한 제안을 거절한 노드) , BN 1644 (바운티를 수락했으나 요청된 블록을 가지지 않는 노드), BN1646 (바운티를 수락 하고 요청된 블록을 가진 노드) 및 블록 바운티 의 기하급수적(exponential) 전송 증가를 갖는 정보 탐색 시퀀스 노드 맵의 개요를 제공한다. 블록 바운티가 BCHAIN 네트워크 전체로 전달됨에 따라 다른 노드와의 상호작용 및 노출은 여러 이웃이 있는 단일 노드로 인해 기하 급수적으로 증가한다. 도 120은 저비용 경제 인증 토큰 (EAT) , 고가 경제 인증 토큰 (EAT) 의 예를 제공한다. 수수료 수 준과 기하급수적 성장 메커니즘에도 불구하고 유한 검색은 결국 종료된다. 영구적이고 기하 급수적인 성 장으로 인기하급수적 시스템에 영구적으로 과부하가 걸리지 않도록 하기 위하여, 그것을 전달하는 각 노드와 공 유되는 블록 바운티 보상에 대한 각 홉의 블록 바운티에 대한 어필이 사라진다. 그러므로 블록 바운티의 전달은 블록 바운티와 상호작용을 제안하는 노드를 가진 경제 전망이 매력이 없기 때문에 결국 중단된다. 따라서 경제 인증 토큰 (EAT) 을 통해 블록 바운티에 첨부 된 제안 된 요금은 블록 바운티가 BCHAIN 네트워크를 통해 도달하는 범위의 차이에 대해 모든 차이를 만들고 따라서 원하는 메타 체인 블록의 전망이 발견된다. 메트릭 유 지 로직 (MRL) 이 모듈은 노드가 유지해야 하는 메타 체인 블록을 위한 의사 결정 프로세스를 실행한다. 따라서 이 모듈은 노드가 메타 체인 유지 다운로드 (MRD) 요청을 성공적으로 수행 할 수 있는 가능성을 높이기 위해 가장 적합한 종류의 메타 체인 블록을 유지하려고 시도한다. 이러한 요청을 효율적으로 처리하면 요청을 처리하는 노드에 대한 경제적 전망이 향상되고 BCHAIN 프로토콜 프로세스 (예: 앱체인 병합)가 보다 효 율적으로 실행된다. 앱체인 병합 이벤트와 메타체인 밀도의 다양한 크기 . 다양한 병합 발생으로 인한 메타체인 밀도의 다양한 크기. 메타체인 보유 로직 (MRL; Metachain Retention Logic) 모듈은 앱 체인 병합 발생 정도가 다른 영역에서 실행된다. 그러므로 높은 규모의 앱체인 병합이 있는 지역에서는 MRL 이 랜덤 보유 지대에 더 많은 메타 체인을 보유하도록 노드에 명령 할 것이다. 앱체인 병합 이벤트 . 앱체인이 성공적으로 병합되면 통계적 추적을 위해 이벤트와 관련된 기본 정보가 네트워크에 브로드캐 스트된다. 이러한 통계는 의사 결정 과정에서 MRL 과 같은 모듈에 통보한다. 도 121 내지 도 124는 커스텀 체인 딜레마 해석 (CDI; Customchain Dilemma Interpretation) 에 대한 상 세한 설명을 제공한다. 도 122에서 MCAD (Miner / Cache Activity Detection) 은 메타체인 분할 포인트 (Split point) 이후에 메타체인의 슬레이브 버전에 있는 타겟 앱체인에 기여한 채굴자와 캐셔를 결정한다. 또한 도 122에서 커스텀체인 스플릿 발견 (CSD) 모듈은 커스텀체인의 두 가지 버전이 서로 다른 구성을 시작 한 시점을 계산한다. 도 125 내지 도 127은 딜레마 확증 시퀀스 증거 에 대한 상세한 내용을 제공한다. 도 128 내지 도 129는 앱체인 병합 프로세스의 상세 내용을 나타낸다. 도 130은 블록 언패킹 프로세스 (BUP) 를 상술한다. 도 131은 RBSC (Retrospective Block Scope Consensus) 를 상세화한다. 도 132 내지도 136은 앱체인 병합 프로세스의 상세 내용을 나타낸다. 도 133은 병합된 멤풀 스트림(Merged Mempool Stream)에 대한 상세한 설명을 제공한다. 데이터 량 벡터 (Data Amount Vector) 는 특정 블록이 기여하고 병합된 멤풀 스트림 을 통해 플롯 (plot)하는 컨 텐츠의 양을 나타낸다. 데이터 시간범위 벡터(Data Timespan Vector) 는 특정 블록 내의 데이터가 도달하 는 범위의 크기를 도시한다. 시간의 선형 측정(Linear Measurement of Time) 1820은 일관되고 선형적인 기초 위 에서 시간을 측정하며, 다양한 블록의 컨텐츠가 플롯(Plotted against)된다. 도 134는 조사되고 병합된 멤풀 스트림에 대한 세부 사항을 제공한다. 소급적용 블록을 위한 고전적 마이 닝 논리는 일반적인 새 블록을 마이닝하는 CIM에 의해 사용된 것과 동일한 마이닝 논리로, 중간 앱체인 / 마이크로 체인에 삽입된 블록을 소급하여 마이닝하는 데 사용된다. 주요 차이점은 일반적인 새로운 블록은 작업 증명만 필요로 하는 반면 소급 적용 마이닝은 작업 증명과 딜레마 증명이 필요하다는 것이다. 새로운 소급 블록 할당에 관한 컨센서스. 모든 참가 노드가 BCHAIN 프로토콜의 합법적 인 명세를 실행하기 때문에 병합 된 멤풀 스트림과 관련된 범위 라인을 어디에 그려야 하는지에 대한 기준에 따라 해당 블록의 소급 적용 마이닝에 대한 최종 컨센서스가 이루어지며 결국 앱체인 병합과 같은 복잡한 절차의 작동에도 불구하고 앱체인 / 마이크로 체 인 구성에 대한 컨센서스가 이루어진다 도 135는 병합된 앱체인을 앱체인 버전 A 마스터 및 버전 B 슬레이브로 제공한다. 도 136은 병합 이벤트 태그 (병합 시간 , 마스터 / 슬레이브 어피니티 및 노드 관여 레코 드를 포함)를 앱체인 병합을 겪은 적이 있는 각 단일 블록을 동반하는 병합 이벤트 장부(ledger)에 첨부하는 병합 이벤트 추적 (MET) 모듈을 나타낸다. 이는 커스텀 체인 정보 주입 공격에 관한 고급 분석 및 보 안 작업의 미래 반복을 가능하게 한다.도 137은 캐시 시딩을 공급하는 마이닝 노드(MNCS; Mining Nodes Supplying Cache Seeding) 를 상세화한 다. 섹터 세금 생성(STC) 모듈은 캐시 이행이 발생할 때 가변적인 시간에 제정될 긍정적이거나 부정적인 세금 결과를 열거하는 세금 결과 유닛(TCU; Tax Consequence Unit)을 생성한다. TCU 의 구성을 정 의하는 요소에는 섹터 노드 수, 섹터 수요 규모, 섹터 비상 기금 규모 등이 포함된다. 섹터 세금 시행 (STE; Sector Tax Enforcement) 는 해당 섹터의 노드의 캐시 이행 성능을 평가한다. 섹터 내 캐시 이행 상태가 최종적으로 달성되면 이 모듈은 TCU 에 명시된 바와 같이 세금 코드를 적용한다. 섹터 세금 공고는 관련 섹터 관할권 내의 모든 해당 노드에 세금 결과 단위 (TCU) 를 브로드캐스트한다. 노드 참조는 주로 메타 체인에서 위치 연관을 통해 만들어진다. 도 138은 세금 결과 유닛 (TCU) 시행 이 섹터 J21 및 섹터 KL4 에서 BCHAIN 노드 , BCHAIN 마이닝 노드 , TCU 를 도시한 것을 개략적으로 나타낸다. 특정 분야의 채굴자들 사이의 초 기 세금 결과 컨센서스. 세금 결과 창출, 컨센서스 및 적용은 모든 섹터에서 독립적으로 발생한다. 특정 섹터의 BCHAIN 마이닝 노드 (BMCH)는 먼저 STA (Segment Tax Announcement)를 통해 동일한 섹터 내의 노드로 내용을 브로드캐스트 하기 전에 TCU (Tax Consequence Unit) 정의에 대한 컨센서스에 도달한다. 도 139는 섹터 세금 생성 (STC) 의 세부 내용을 나타낸다. 가변 에뮬레이션 모듈 (Variable Emulation Module, VEM) 은 주어진 동적 입력으로 신뢰할 수 있는 균일 변수를 생성한다. 미가공 변수 Pre-TCU 와 함께 마이닝 노드 컨센서스 프로토콜를 사용하면 채굴자가 특정 섹터의 모든 채굴자들과 정확히 일치하는 최종 TCU 버전을 생산하는 Pre-TCU 미가공 변수에 대한 컨센서스에 도달할 수 있다. 도 140은 STC 을 마치고 세금 결과 유닛 (TCU) 을 상세히 설명한다. TCU 에는 캐시 이행 시 제정된 스케쥴 세금 플랜이 있다. TCU 는 각 섹터의 노드가 새로 채굴된 블록에서 배달된 특정 컨텐츠의 캐시 이행을 총체적으로 수행하는 데 걸리는 잠재적인 시간을 고려하여 제정될 잠재적 세금 감면 또는 과징금을 열거한다. 도 141은 JICS 를 갖는 섹터 세금 공고 (STA) 를 상세하게 도시한다. 도 142 및 도 143은 섹터 세금 리셉션 (STR; Sector Tax Reception) 에 대한 세부 사항을 제공한다. STR 1904는 세금 결과 단위 (TCU; Tax Consequence Unit) 준수에 가장 효과적인 시간을 결정하는 개별 BCHAIN 노드 내에서 처리되는 논리이다. 그러한 결정은 동일한 TCU 를 수신한 동일한 섹터의 다른 노드와 협력하지 않고 이루어진다. 따라서 노드는 자신이 경제적 특성 , 대체 작업의 가용성 및 이익 마진, 사용 가능한 로컬 리소스 등과 같은 자신의 요소를 추정한다. 논리는 모든 노드가 수행하기 위해 공고된 캐시 채택을 지연할 경우 해당 섹터의 모든 노드가 메타체인의 비상 섹터 자금(Emergency Sector Funds of the Metachain) 에 제출되는 세금 형식으로 가격을 동등하게 지불해야 한다는 것을 이해하면 실행된다. 그러므로 한 섹터 내의 노드는, 시나리오와 같은 죄수의 딜레마(게임 이론에서 분석 된 게임의 표준 사례로 왜 두 명의 완전히 \"합리적 인\" 개인이 그렇게 하는 것이 최선의 방법임에도 협력하지 않을 수도 있음을 보여주는 게임)를 불러 일으키는, 그러한 주제에 대한 명확한 의사 소통 없이 공동 작업을 해야 한다. 노드 캐시 컴플라이언스 (NCC; Node Cache Compliance) 은 노드가 섹터 세금 공고(STA; Sector Tax Announcement) 의 호출 시 섹터의 채굴자 에 의해 명시된 데이터를 채택하고 유지하는 것을 수반하는 논리 실행이다. 캐시 이행은 충분한 양의 캐시 채택 이 한 섹터 내의 노드에 의해 착수된 즉각적 순간이다. 캐시 이행은 그러한 캐시의 클레임 및 검증된 채택시에 만 발생한다. 캐시 컴플라이언스는 섹터의 채굴자가 강조된 데이터를 캐싱하는 명령을 준수하는 노드의 행위이 다. 순서 준수에 관해 거짓을 말하는 불량 노드에 대항하기 위해 노드는 결정적으로 무작위로 테스트되어 해당 노드가 실제로 데이터를 보유하고 있는지 또는 데이터를 갖고 있는 척 하는지 확인한다. 도 144 및 도 145는 섹터 세금 시행 (STE; Sector Tax Enforcement) 을 개략적으로 도시한다. 도 145에 서 1938은 STA , 노드 A 준수 , 노드 B 준수 , 노드 C 준수 , 제한 시간 도달 , 더 이상의 준수 시도 없음 , 캐시 이행 달성을 보여주며, 세금 감소는 (세금 감면) 화살표가 위 를 향하고 세금 증가 (과징금)는 화살표가 증가한다. 1948과 1946이 만나는 지점에서 캐시 이행은 노드 준수의 요구를 끝낸다. 캐시 이행이 발생하면 캐시 컴플라이언스의 동력은 더 이상 준수 시점 또는 준수 여부에 관한 벌칙 요소가 없으므로 변경된다. 그러나 노드는 정의 된 경제적 특성 및 / 또는 채택 수익성에 대한 인식 으로 인해 이러한 가용 캐시를 채택하는데 리소스 할 수 있다. 시간, 제한 시간 도달, 캐시 채택 (노드 수) , 캐시 이행달성 도 146은 데이터 무결성 스캐닝 (DIS; Data Integrity Scanning) 을 상세화한다. 위험 보고서 컨텐츠 는 무결성을 영구적으로 잃을 위험이 있다고 주장되는 데이터의 신원을 열거한 포괄적 보고서로, 그러한위험이 시스템 전반에 걸쳐 현실과 관련 있음을 나타내는 증거에 대한 외부 참조를 포함한다. 이러한 외부 참조 는 메타 데이터를 통해 이루어 지므로 대체 당사자가 데이터 무결성 위험에 대한 그러한 주장을 확인할 수 있다. 도 147 내지 도 150은 데이터 보호처 프로세싱 (DRP) 의 상세도이다. 도 148의 SRD (Sector Refuge Discovery) 는 위험 보고서에서 정확한 긴급 내용을 갖는 데이터를 채택 할 가능성이 가장 높은 섹터를 찾아 낸다. 높은 섹터 비상 자금이 있는 섹터는 보호처(refuge)의 자료를 채택할 가능성이 더 크다. 또한 이 파인더 노드 (자체 노드)와의 근접성은 데이터 무결성 안전을 위해 불필요하게 긴 마이그레이션 경로를 피하는 것으로 간주된다. 섹터 마이닝 노드 로케이터 (SMNL; Sector Mining Node Locator) 는 SRD 에서 선택된 타겟 섹터 내에서 적절한 마이닝 노드를 검색한다. 도 149은 데이터 보호처 어플리케이션 생성기 (DRAG; Data Refuge Application Generator) 는 위험 보고 서의 원본 컨텐츠 및 파인더 노드 식별 및 지불 정보에 열거 된 정보를 열거하는 정보 컨테이너를 생성한다. 도 150의 섹터 보호처 어플리케이션 (Sector Refuge Application) (SRA) 은 데이터 보호처 어플리케이션 (Data Refuge Application) 에서 열거된 상황을 고려하여 타겟 섹터 내의 검증된 채굴자다. 따라서 데이 터 무결성 시나리오를 독립적으로 검증하기 위해 데이터 무결성 스캐닝 (DIS) 의 자체 인스턴스를 호출한 다. 도 151 내지 도 155는 도 150에서 시작된 섹터 보호처 어플리케이션 에 대한 로직을 상술한다. 도 156 내지 도 158은 노드 캐시 컴플라이언스 레코딩 (NCCR) , 컴플라이언스 이벤트 로그 , 캐시 이행 API , 시드 캐시 풀 삭제 , 시드 캐시 풀 등을 포함하는 노드 캐시 제공자를 가지는 셀프 노드(채굴자) 프로세스를 개략적으로 도시한다. 도 159는 도 158에서 시작되는 노드 캐시 컴플라이언스 (NCC) 프로세스를 계속한다. 도 160의 노드 캐시 응답 (NCR) 은 요구 된 챌린지 해시로 응답함으로써 검증 노드 로부터의 노드 캐시 검증 (NCV) 요구를 따른다. 도 160은 메타체인을 통한 온라인 확인 (OVCM) , 캐시 검증 챌린지 , 챌린지 해시 을 이용하 는 검증 노드 내의 노드 캐시 검증 (NCV) 을 개략적으로 도시한다. 도 161은 NCP 컴플라이언스 이벤트 로그 및 셀프 노드(채굴자) 에게 확인된 것으로 보고하 는 것이나 혹은 컴플라이언스 이벤트가 확인된 것으로 보고하지 않고 모듈 실행을 마치는 것과 함 께 노드 캐시 검증 (NCV) 을 계속하고 끝낸다. 도 162는 성공적인 경우 캐시 이행이 발생하였나 에서 시작하여 시드 캐시 풀 로부터 캐시 파트 진입을 삭제하는 것으로 끝나고, 성공하지 못한 경우 널(null) 모듈러 로 모듈 실행을 종료시키는 시드 캐 시 풀 삭제 (SCPD) 프로세스를 개략적으로 나타낸다. 도 163은 노드 캐시 제공자 (NCP) 의 세부 사항 및 노드 캐시 이행 검사(NCFC) 와의 상호 작용을 개략적으로 도시한다. 도 164는 1 차 노드 캐시 컨텐츠 (PNCC) , 챌린지 해시 , NCV , 챌린지 문자열 등을 갖는 그 내부 프로세스상의 노드 캐시 응답 (NCR) 에 대한 세부 사항을 제공한다. 도 165 및 도 166은 노드 캐시 컴플라이언스 레코딩 (NCCR) 에 대한 세부 사항을 제공한다. 도 167은 컴플라이언스 이벤트 로그 에 대한 세부 사항을 제공한다. 도 168은 노드 캐시 컴플라이언스 레코딩 (NCCR) 에 대한 세부 사항을 제공한다. 챌린지 문자열 은 8 바이트 길이의 챌린지 문자열 , 시작 부분 , 무작위 값 X , 종료 부분 이다. 도 169는 데이터 무결성 및 컨텐츠 서빙 사이의 원하는 상태를 갖는 데이터 마이그레이션 패턴 을 보여주 고, BCHAIN 프로토콜을 통해 BCHAIN 네트워크는 신속하고 일관된 컨텐츠 전달을 위해 데이터 무결성 및 최적 구 성의 레벨을 지속적으로 최대화하려고 시도한다. 이것은 BCHAIN 네트워크의 노드 중 사용할 수있는 유한 리소스 를 고려하여 수행된다. 초기 컨텐츠 시딩 영역, 컨텐츠 무결성 영역는 무결성 최적 위치를 나타낸 다. BCHAIN 프로토콜에는 데이터 보유 무결성에 대한 바이너리 접근방식이 있다. 모든 데이터는 필수적 중요성 으로 취급되며 의도적 데이터 만료 이벤트가 실행되지 않는 한 데이터 손실이 허용되지 않는다. 따라서 프로토콜은 개별 노드의 혼란스러운 분배 및 가동 시간에도 불구하고 데이터의 중복성을 보장한다. 초기 컨텐츠 시딩 영역에서 확인 된 마이닝 노드 (블록을 성공적으로 채굴한 노드)는 섹터 내의 노드가 새로 채굴된 블록의 컨텐츠를 캐시하도록 유도하는 세금 정책을 시행한다. 컨텐츠 수요가 많은 지역은 최적의 위치 서비스이 다. 컨텐츠 요구는 네트워크의 특정 포켓에서 최고조에 달할 것으로 예상된다. 따라서 CSA (Cache Selection Algorithm)는 이러한 컨텐츠에 대한 요구에 보다 가까운 영역에서 컨텐츠의 캐시 호스팅을 가능하게 한다. 이로 써 라우팅 패킷 (CCR / CCF)이 동일한 데이터 전송을 수행하는 데 소요되는 시간이 훨씬 적어지기 때문에 네트 워크에 대한 전반적인 이점이 있다. 이것은 또한 정보의 소비자들에게 낮은 대기 시간과 더 빠른 전송 속도를 가져온다. 도 170 내지 도 358은 사용하는 다양한 알고리즘을 포함하는 BCHAIN 네트워크 의 주요 핵심인 라우팅 로직 (Routing Logic) 에 대한 세부 사항을 제공한다. BCHAIN의 본질은 패킷을 분산된 방식으로 효율적으로 메 쉬(mesh)에 라우팅하는 것이다. 노드는 카오틱 리소스 배포에서 서로 다른 역할을 맡고, 일부는 CCR (Content Claim Requests) 을 제공하고, 일부는 CCF (Content Claim Fulfillment) 을 수신한다. 주요 라우 팅 논리는 PBHP 생성, 참조 및 업데이트와 관련하여 발생한다. 라우팅 논리의 매우 독특한 측면은 OSRD (Optimized Section Route Discovery) 에서 찾을 수 있다. 도 291 - 294는 중요한 리소스를 소비하지 않 고 노드 토폴로지 전체에서 효율적인 경로를 자동으로 탐지하는 지능형 캐싱 시스템이다. 모듈의 두 가지 주요 측면은 END (Edge Node Detection) , 도 317 - 323 및 도 329에서 시작하는 부메랑 알고리즘이다. 부메랑 시퀀스는 노드의 카오스 분포를 이용하여 패킷 통과의 각도와 영역을 결정하는 효율적인 방법이다. 따라 서 효율적인 패킷 루트는 노드 토폴로지를 따라 최적화된 정보의 고속도로로 연결되는 '자가 인식(self awar e)'이 된다. 도 170의 라우팅 로직 (RL) 은 메타체인, 앱체인그리고 마이크로체인으로 구성된 커스텀 체인 저장소 (CS) 로부터 노드에 의해 이전에 등록된 커스텀체인 (앱체인 또는 마이크로체인일 수 있음)에 연결된 커스텀 체인 인식 모듈 (CRM) 을 통해 입력을 수신한다. 따라서 노드는 그러한 기능에 대한 읽기, 쓰기 및 / 또는 관리 능력에 대한 암호화 액세스 권한을 가진다. 이 모듈은 메타체인 또는 마이크로 체인의 메 타체인 에뮬레이터의 앱체인 섹션에서 업데이트가 감지되면 나머지 BCHAIN 프로토콜에 알린다. 도 171은 RL 의 프로세스에 대하여 도 170으로부터 계속된다. 유효한 CCR 컨텐츠 클레임 요청 (Contents Claim Request) 을 수신하면 CCD (Contents Claim Delivery) 에서, 이 모듈은 요청을 이행하기 위 해 관련된 컨텐츠 CCF (Contents Claim Fulfillment) 을 생성하여 전송한다. 도 172는 RL 의 처리에 대하여 도 171로부터 계속된다. CCR은 CCF를 수신하면, 이 모듈은 요 청 컨텐츠를 UBEC 플랫폼 인터페이스와 같은 프론트 엔드를 통해 사용자에게 렌더링한다. 도 173는 클레임 방향(Cliam Orientation), 인지된 컨텐츠 위치 타당성, 암호화 자격 증명 (Cryptographic proof of entitlement) , 트레일 변수 묶음 (TVS) , 제안된 베이스라인 홉 경로 (PBHP) , 노드 고유 식별 및 타겟 유형 으로 구성된 CCR의 컨텐츠를 상세히 도시한 다. 타겟 유형 은 다음을 포함한다: 즉시 타겟 (immediate target)은 이동 경로의 다음 홉 시퀀스 에서 즉시 탐색되는 노드이고, 후속 타겟 은 최종 타겟 을 향한 효율적인 여정을 촉진하기 위한 최 상의 단기 경로로 인식되는 노드의 동적으로 성장하고 축소하는 리스트이다. 최종 타겟은 전달 컨텐츠를 기대하 거나 컨텐츠를 직접 전달하는 의도된 목적지 노드이다. 클레임 방향(Claim Orientation) 는 컨텐츠 클레 임을 제공한 발신 노드의 식별 세부 사항을 나타내는 암호학적으로 서명 된 정보 블록을 포함한다. 인지된 컨텐 츠 위치 타당성은 노드 홉 라우팅의 주요 측면을 나타내는 동적으로 변하는 변수 집합이다. 암호화 자격 증명 은 발신 노드가 특정 앱체인 / 마이크로체인에 액세스 할 수 있는 유효한 키에 대한 액세스 권한을 가지고 있음을 나타내는 암호학적으로 서명 된 정보 블록을 포함한다. 이러한 키에는 읽기 권한, 쓰기 권한 및 / 또는 관리 기능을 할당 할 수 있다. 이러한 키는 앱체인 / 마이크로체인 관리자가 사용자 또는 그룹 수준에서 암호적으로 취소 할 수도 있다. 도 174는 컨텐츠 시작 , 인지된 컨텐츠 전달 타당성 (도 174에 2312로 나타냄), 컨텐츠의 암호화 된 부분 , 트레일 변수 묶음(TVS) , 제안된 베이스라인 홉 경로(PBHP) , 노드 고유 식별자 및 타겟 타입 으로 구성된 CCF의 컨텐츠를 상세히 도시한다. 컨텐츠 시작 은 컨텐츠 이행을 제공 한 발신 노드의 식별 세부 사항을 나타내는 암호 학적으로 서명 된 정보 블록을 포함한다. 인지 된 컨텐츠 전달 타당성 (도 174에 2312로 도시 됨)은 노드 홉 라우팅의 주요 측면을 나타내는 동적으로 변 하는 변수 세트이다. 컨텐츠의 암호화 된 부분 은 정보의 관련 부분을 그러한 정보의 청구자에게 반환하는 캐시 노드에 의해 충족되는 요청된 정보를 갖는다. 전략 배포를 통해 부분 크기가 적극적으로 최적화되어 전 반적인 네트워크 성능을 위한 최적의 부분 크기를 찾는다. 도 175는 커뮤니케이션 게이트웨이 (CG) 의 구성 요소인 노드 상호 작용 로직 (NIL) , 캐시 작업 승인 (CWA) 및 API 엔드 포인트 , 커뮤니케이션 밴드폭 포화 , 발신 CCR, CCF 및 PBHP 과의 상호 연동을 상세히 도시한다. 도 176 내지 도 180은 주로 캐시 선택 알고리즘 (CSA) 을 설명한다. 커스텀체인 최근 포화 평가 (CRSE; Customchain Recent Saturation Evaluation) 모듈은 인커밍 CCF 앱체인이 최신 홉 히스토리 (RHH) 에서 최근에 목격되었는지 확인한다. 도 181 내지 도 184는 노드 상호 작용 로직 (NIL) 내에서 다른 노드와 상호 작용하고 정보를 교환하는 주요 논리인 프로세스를 정의한다. 이것은 BCHAIN 프로토콜 내에서 하드웨어 인터페이스에 가장 가까운 레 이어이다. 하드웨어 인터페이스는 5G / 4G / LTE / 3G 연결성 및 GSM / CDMA 을 갖춘 무선 (Cellular) 안테나 마이크로칩으로 구성되어 있다. 또한 WIFI (즉, Spec 802.11 ac) 및 블루투스 (예: 버전 4.2) 기능을 제공하는 무선(Wireless) 안테나 마이크로칩도 가지고 있다. 도 185 내지 도 190은 레거시 네트워크 브리징 메커니즘 (LNBM) 및 노드 상호작용 로직 (NIL) 에 대한 프로세스를 설명한다. 이는 노드 통계 조사 (NSS) 로 결론을 맺는다. 도 191 내지 도 193은 데이터 무결성 관리 (DIM; Data Integrity Management) , 커뮤니케이션 게이트웨 이 , 브로드캐스트 프로세서 (BP) 와 상호 작용하는 커스텀 체인 인터페이스 모듈 (CIM) 내 의 프로세스를 도시한다. JICF(Jurisdictionally Implied CCF Submission) 는 노드가 CCF 을 수령 하는 관할 기관의 묵시적 책임으로 인해 CCR 을 동반하지 않는 노드로 CCF 을 보낸다. 브로드캐스 트 프로세서 (BP) 는 홉 라우팅 로직과 커뮤니케이션 게이트웨이 (CG) 사이의 중간 단계이며, 이 모듈은 발신 거래를 암호 서명하고, 하드웨어 혼잡도가 더 많은 거래가 브로드캐스트 되는 것을 허용 할 때까지 선착순으로 주문한다. 도 194 내지 도 198은 마이닝 선택 알고리즘 (Mining Selection Algorithm, MSA) 을 설명한다. 이것은 도 194의 CG , CS , 앱체인 트래픽 경향 추적 관리 (ATTTM) 2500과 상호 작용한다. CIM 에는 커스텀 체인의 마이닝을 용이하게 하는 기본 기능이 포함되어 있다. 도 199 내지 도 203은 신규 컨텐츠 공고(NCA; New Content Announcement) 에 대한 상세한 설명을 제공한 다. JICF(Jurisdictionally Implied CCF Submission) 4134는 CCF 이 그러한 CCF 수신에 대한 해당 관할권적으로 암시된 책임으로 인해 CCR 동반 없는 노드로 전송되는 곳이다. 도 204 내지 도 206는 노드 저장장치 처리 (NSP) 의 상세한 내용을 나타낸다. 노드 통계 조사 (NSS) 은 NSS 변수 풀링 (NVP) 에 입력을 제공한다. NVP 은 동일한 섹터 내의 노드가 노드 통계 조 사 (NSS) 변수에 대한 인식을 공고하여 해당 섹터의 특성에 대한 컨센서스를 도출한다. 따라서 로컬 및 원격 NSS 변수를 함께 풀링하여 NVCI라고 알려진 합성 평균을 만든다. 이 합성은 이 섹터의 범위와 정의 에 대한 컨센서스를 유지하는 데 사용된다. 따라서 경계가 있는 부분이 있다. 관할권적 수락 CCF 리셉션 (JACR) 및 NVP 을 통해 수신된 노드 정보는 NSS 변수가 원격 노드 및 로컬 NSS 인스턴스 에서 언팩 된 NSP 2390으로 제출된다. 로컬 노드 트래킹 (LNT) 은 NSS 의 범위에 의해 정의 된 로컬 부근에 현 재 할당된 노드들에 관한 정보를 저장한다. 도 207 내지 도 209는 제안된 베이스라인 홉 생성기 (PBHG) 의 상세를 도시한다. 로컬 노드 인식 보충 (LNR) 은 LNT의 홉 범위 내에 있는 노드들을 신뢰성 있는 초기 홉 라우팅을 제공하는 것으로 입증된 노드 로 대체한다. 최종 타겟 은 전달 컨텐츠를 기대하거나 스스로 컨텐츠를 전달하는 의도 된 목적지 노드이 다. 즉각 타겟 은 여정 경로의 다음 홉 시퀀스에서 즉시 탐색되는 노드이다. 후속 타겟 은 최종 타 겟 을 향한 효율적인 이동을 용이하게 하는 최적의 단기 경로로 인식되는 노드의 동적으로 성장하고 축소 하는 리스트이다. 대체 최종 타겟는 최종 타겟과 유사한 기능을 제공하는 제안된 노드이다. 이러한 방식으로, 캐리어 노드는 원래의 최종 타겟 에 도달 할 수 없는 경우에 대체 최종 타겟으로 쉽게 전환할 수 있다. 노드 안정성 교환 (NSE) (도 208에 번호 표시 되지 않음)은 신뢰할 수 없다고 생각되는 노드를 안정적 / 신뢰할 수 있는 환경의 노드로 대체한다. 도 210 내지 도 212는 SRD (Shortest Route Detection) 에 관한 처리를 나타낸다. 도 213 내지 도 215는 대기 정보 브로드캐스트(QIB; Queued Information Broadcast) 의 상세를 나타낸다. 섹터 크로싱 이벤트 프로세싱(SCEP; Sector Crossing Event Processing) 은 새로운 섹터로 이 전한 CCR 2308 또는 CCF 2318에 완료된 TVS (Trail Variable Suite) 을 해체시키고 패킷의 이후 여정을 위해 새 TVS 2320을 커밋(commit)한다. BHP (Best Hop Perception) 은 CCR 또는 CCF 을 즉 각 및 후속 타겟의 최종 타겟으로의 여정으로 발전시키기 위한 기본 로직을 제공한다. 로컬 노드 트래킹 (LNT) 은 NSS (Node Statistical Survey) 의 범위에 의해 정의 된 바와 같이 로컬 근처에 현재 할 당된 노드에 관한 정보를 저장한다. 도 216 내지 도 218은 홉 라우팅 로직과 커뮤니케이션 게이트웨이 (CG) 사이의 중간 단계 인 브로드캐스 트 프로세서(BP) 의 세부 사항을 도시하며, 이 모듈은 발신 거래를 암호화 서명하고 또한 이들을 제 1 하 드웨어 혼잡도가 더 많은 거래를 브로드캐스트 할 수 있을 때까지 선착순으로 주문한다. 최근 홉 히스토리 (RHH) 는 CCR 및 CCF 헤더 정보를 저장하는 임시 캐시로서, 다양한 알고리즘이 이러한 진 입의 의미를 로직에 통합 할 수 있도록 한다. 최근 홉 히스토리 관리 모듈 (RHHMM) 은 발신 CCR 및 CCF 가 RHH 에 기록되어 이 정보 캐시를 참조하는 다수의 다른 알고리즘을 용이하게 한다. 시스 템에서 더 이상 목격 이벤트가 '최근'이 아니라고 간주하면 진입은 RHH 에서 삭제된다. 도 219 내지 도 221은 BHP (Best Hop Perception) 의 상세를 도시한다. 셀프 가 노드가 홉 라우팅 내에서 의도된 목표가 만들어졌다는 것을 인식하는 중요한 단계인지 확인한다. 다음 10 개의 홉과 같은 후속 목 표 를 다시 계산한다. 최종 타겟 은 전달 컨텐츠를 기대하거나 컨텐츠를 직접 전달하는 의도된 목 적지 노드이다. 즉각 타겟 은 여정 경로의 다음 홉 시퀀스에서 즉시 탐색되는 노드이다. 후속 타겟 은 최종 타겟 을 향한 효율적인 이동을 용이하게 하는 최적의 단기 경로로 인식되는 노드의 동적으 로 성장하고 축소하는 리스트이다. 도 222 내지 도 223은 STA (Subsequent Target Advancement) 의 세부 사항을 도시한다. CCR 또는 CCF 가 라우팅 로직을 통해 처리 될 때, 이 모듈은 후속 타겟 필드를 해석하여 다음 즉각 타겟 을 생성한다. 이 모듈은 제안된 베이스라인 홉 경로(PBHP) 에 의해 예상되지 않았더라도 후속 타겟 중 하나가 정보의 즉각적이고 직접적인 전송에 현재 사용 가능한지를 확인한다. 즉, 노드의 카오틱 이동 이 시퀀스에서 잠재적 마이크로 최적화를 제공하면(바로 가기), 이 모듈은 이를 감지하고 선언된 즉각적인 목표 를 대체하여 가져온다. 후속 타겟 은 최종 타겟 을 향한 효율적인 이동을 용이하게 하는 최 적의 단기 경로로 인식되는 노드의 동적으로 성장하고 축소하는 리스트이다. LNT 는 노드 통계 조사 (NSS) 의 범위에 의해 정의된 바와 같이 현재 할당 된 노드에 관한 정보를 로컬 부근에 저장한다. 도 224 내지 도 228은 홉 전략 계산 (HSC) 의 상세를 도시한다. 도 229 내지 도 232는 제안된 베이스라인 홉 경로 추출 (PBHPE) 의 상세를 도시한다. 도 233 내지 도 235는 재계산 경로 (RP) 의 상세를 도시한다. 인지된 컨텐츠 위치 타당성 는 최종 타겟 과 유사한 기능을 제공하는 노드를 제안하는 대체 최종 타겟 에 입력을 제공한다. 이러한 방 식으로, 캐리어 노드는 원래의 최종 타겟 이 도달 할 수 없는 경우에 대체 최종 타겟 으로 쉽게 전 환 할 수 있다. 대체 최종 타겟 발견 (AFTD) 는 기능 및 지리적인 면에서 최종 타겟 목적지와 유사한 타 겟을 검색한다. 도 236 내지 도 240은 병렬 홉 논리 (PHL; Parallel Hop Logic) 의 상세를 나타낸다. 최종 타겟으 로 시작하여 개시할 병렬 홉 라우팅 없음(No Parallel Hop Paths to Initiate) 또는 하드웨어 인터페이 스로 끝난다. 도 241 내지 도 244는 병렬 홉 개시 (PHI; Parallel Hop Initiation) 의 상세를 도시한다. LNR (Local Node Awareness Supplement) 은 로컬 노드 트래킹 (LNT) 의 홉 범위 내에 있는 노드를 신뢰성 있 는 초기 홉 라우팅을 제공하는 것으로 입증 된 노드로 대체한다. LNT 는 노드 통계 조사 (NSS)의 범위에 의해 정의 된 바와 같이 현재 할당 된 노드에 관한 정보를 로컬 부근에 저장한다. NSE (Node Stability Exchange) 2982는 신뢰할 수 없다고 생각되는 노드를 안정적 / 신뢰할 수 있는 환경의 노드로 대체한다. 도 245 내지 도 247은 OPHPR (Over-Parallelized Hop Path Reduction) 의 상세를 나타낸다. 도 248 내지 도 251은 CCG (Content Claim Generator) 의 상세를 나타낸다. 도 252는 커스텀 체인 인식 모듈 (CRM) 의 상세를 도시한다. 실시간 업데이트에는 로컬 체인 저장 소가 CIM에 의해 업데이트되면서 실시간 메타 캐시 업데이트가 포함되어 있으며 모든 앱체인 업데이트가 CRM에 실시간으로 푸시되어 적절한 CCR을 생성 할 수 있다. DARD(Due Appchain Retrieval Detection)은 실시간으로 업데이트 된 메타체인 앱체인 업데이트와 로컬에 알려진 버전의 앱체인의 간에 보류중인 차이점을 감지한다. 이 로써, 앱체인이 업데이트되면 서로 다른 타임 스탬프가 CCR이 이러한 정보를 가져 오기 위해 전송될 것임 을 강조하도록 이 모듈에 지시한다. 도 253 및 도 254는 암호 자격 생성기(CEG) 의 상세를 도시한다. 도 255 및 도 256은 제외된 노드 연결 발견 (ENCD) 의 상세를 도시한다. 도 256 내지 도 258은 최상 노드 선택(BNS) 의 상세를 도시한다. PDNR (Potential Destination Node Results) 3058은 최상의 잠재적 타겟 노드를 고려하기 위해 노드가 캐시하는 임시 목록이다. 도 259 내지 도 261은 모두 메타체인 내에 있는 위치 연관성 , 최적화 섹터 라우팅 및 앱체인 캐시 위치 의 세부 사항을 도시한다. 도 262 내지 도 264는 메타체인에 의해 제공되는 최적화 된 노드 발견 데이터를 이용하여 CCG (Content Claim Generator) 의 기준을 만족시키는 노드를 효율적으로 발견하는 예비 타겟 선택 (PTS) 의 세부 사항 을 도시한다. 그것은 발신 노드(Origination Node) (셀프) 로 시작하여 잠재적 목적지 노드로 끝난 다. 도 265 내지 도 267은 MBC (Microchain Bypass Consensus) 의 상세를 도시한다. 앱체인 자체 부과된 채 굴자(Appchain Self Imposed Miner) (도 265에 번호 없음), 앱체인 캐시 노드 또는 앱체인 소비자 노드를 포함하여 세 가지 잠재적 시작을 가질 수 있다. 도 268 및 도 269는 MBC (Microchain Bypass Check) 의 상세를 도시한다. 메타체인 및 / 또는 앱체인 정 보에 대한 요청 으로 시작하여 마이크로체인-에뮬레이션 된 버전에 대한 메타체인 정보에 대한 액 세스의 리턴 지점로 끝난다. 정적 하드코딩 정책 (SHP) 488은 BCHAIN 프로토콜에 하드코딩 된 기준을 제공한다. 이러한 기준은 전략 자체를 정의하는 데 사용되기 때문에 일반적인 동적 전략 기반 기준과 달리 정적이다. 따라 서 전략을 생산하는 데 사용 된 메커니즘 자체가 전략에 의존한다면 시스템은 결국 제한적이고 / 또는 비정상적 인 기능과 효과가 있는 극한 상태로 루프될 것으로 예상된다. 메타체인 에뮬레이터은 마이크로체인 지원 정보 전송(Microchain Enabled Information Transfer)을 위한 메타체인 에뮬레이터이다. - 마이크로체인은 메 타체인과 앱체인의 지역화되고 병합된 조합이다. 따라서 알고리즘의 메타체인에 대한 액세스는 요청된 앱체인이 마이크로체인이 되면서 메타체인 에뮬레이터에 대한 액세스로 대체된다. 마이크로 칩 구현은 최종 사용자에게 매끄럽고 투명하며, 리소스 소비 효율성을 최적화하는 프로토콜 루틴일 뿐이다. 도 270 내지 도 276은 CCR(Content Claim Request), CCD(Content Claim Delivery), CCF (Content Claim Fulfillment) (도 274에서 컨텐츠 클레임 요청(Content Claim Request)으로 잘못 라벨링 됨), 인 식된 컨텐츠 전달 타당성 (도 274에서 인식된 컨텐츠 위치 타당성(Perceived Content Location Plausibility)으로 잘못 표시됨), TVS 및 EARP의 상세를 도시한다. CCR 2308로 시작하여 QIB 으로 끝난다. 도 277은 LDPR (Logically Deduced Path Reversal) 을 포함하는 EARP (Economic Authorization Reversal Processing) 의 상세를 도시한다. LDPR 는 CCR 의 송신자에 의해 미리 인증된 원 래의 PBHP 를 수신한다. CCR 발신자가 리턴 여정을 위해 사전 승인한 경로의 범위를 나타내기 위 해 경로가 리버스된다. 리버스된 경로는 노드 레이아웃의 복잡성으로 인해 원래 경로의 역 거울 이미지가 아닐 수도 있다. 이것은 온 길로 돌아갈 수 없다는 것을 나타내는 일방 통행 도로와 유사하다. 도 278 내지 도 282는 컨텐츠 클레임 수행 (도 278에서 컨텐츠 클레임 요청으로 잘못 라벨링됨), 컨텐츠 클레임 렌더링 (CCR) 의 세부 사항을 도시한다. 그것은 CCF 로 시작하여 UBEC 플랫폼 인터페이스 (UPI) 728에서 컨텐츠 다운로드 3318로 끝난다. CCR 3330은 CCF의 여정의 최종 단계를 나타내며 (명시적 또는 묵시적으로) 원본 컨텐츠 요청의 이행을 결론짓는다. 따라서 이 CCF의 마지막 사례인 2318 여정 TDP 는 통계 결과를 리턴하고 홉 라우팅의 노드에 의해 수행된 작업을 보상하기 위해 호출된다. CHC (Content Hashsum Check) 는 제공된 사전 생성 된 해시섬(Hashsum)과 비교하여 해시섬(Hashsum) 출력을 검사하여 전송 또는 저장된 컨텐츠 부분이 전송 중에 손상되지 않았 음을 확인한다. SRCC (Stagger Release Content Cache) 810에는 만족할만한 양의 데이터가 수집 될 때까지 (컨텐츠 디코딩 지침에 표시된 대로) 저장되고 보관 되는 컨텐츠 부분이 있다. 그런 다음 UBEC 플랫폼 인터페이스 에 다운로드 된 컨텐츠로 컴파일되고 릴리스된다. 도 283 내지 도 285는 TVS, TCP, TDP를 포함하는 SCEP의 세부 사항을 도시한다. TCP 은 새로운 TVS 을 생성하기 위한 새로운 변수 배열을 만들고 호출한다. 여기에는 DSA 및 빈 홉 장부(ledger)의 새로운 전략 배포 해석이 포함된다. 구(old) TVS에서 재사용 할 수 있는 유일한 변수 는 EAT이다. TDP는 데이터 기반 지능 수집 목적으로 처리되는 새로운 TVS로 대체 될 예정인 TVS이다. 이는 홉 장부(ledger)에 표시된 대로 CCR 또는 CCF 전송에 참여한 모든 노드로 BCHAIN 작업 유닛 (BWU) 지불금을 처리 할 수 있게 한다. 성능 정보는 전략 배포(Strategy Deployment) 에서 수집되어 SPT(Strategy Performance Tracking) 에 저장된다. 도 286 내지 도 290은 TCP 및 TDP의 상세를 나타낸다. TVS는 섹터를 가로지르면서 CCR 또는 CCF로서 동적으로 수정되고 참조되는 변수들의 집합이다. WSM은 메타체인의 인프라 경제 섹션에 승인되고 제출된 노드가 수행한 작업에 대한 지불을 제공한다. 홉 장부(ledger)는 특 정 섹터 내에서 CCR 또는 CCF 의 전송에 관여 한 노드의 암호학적으로 안전한 목록이다. 노드는 주어진 시간에 정확히 2 개의 섹터에 존재해야 하기 때문에, 트레일 섹터 식별 에 정의된 두 섹터 중 하 나에 속하지 않은 노드가 해당 TVS 을 수신하면 홉 장부(ledger)는 서비스 해제 프로세스 중에 재 설정된다. 섹터 가격 결정 메커니즘 (SPM)은 메타체인 의 섹터 요구량 에 누적된 참조 정보에 의한 특정 섹터에 대한 노드 홉을 통해 정보를 전송하는 BWU 가격을 결정한다. SPI은 다양한 환경 조건 에서 그러한 전략의 인식 된 성능을 지시하는 필드 데이터로 배포된 전략을 수신한다. 도 291 내지 도 294는 OSRD의 상세를 도시한다. Inter-SRBP은 효율적인 인터섹터 경로를 통해 일 련의 섹터를 연결한다 (도 291의 약자는 Inter-SRSP로 잘못 표시됨) Intra-SRSP은 한 섹터의 한 쪽 가장 자리에서 다른 쪽 가장자리로 컨텐츠를 전달하는 효율적인 경로를 제공하는 것을 목표로 제안된 경로 세그먼트 를 생성한다. WRPE은 여러 개의 경로 세그먼트를 함께 연결함으로써 효율적인 인터섹터 경로를 제안한다. SRSR은 해제된 홉 장부(ledger)가 수행 한 경로를 유지하는 데이터베이스이다. 이 데이터베이스의 노드 인스턴스가 TDP의 해제 이벤트를 경험할 때 또는 다른 섹터의 노드가 수신한 해제 홉 장부 (ledger)에 대해 이 노드에 알릴 때 직접 추가된다. 섹터 메이크업 은 인트라(Intra)-SRS, 인터(Inter)-SRS 및 섹터를 강조한다. 인트라(Intra)-SRS 는 단일 섹터 내에서 가장자리에서 가장자리까지의 여정을 포괄하는 효율적인 홉 라우팅을 발견 할 수 있다. 이러한 발견은 인트라(Intra)-SRSP 모듈에 의해 수행된다. 인터(Inter)-SRS 모듈은 여러 개의 경로 세그먼트가 서로 연결되어 궁극 적으로 메타체인에 저장되고 참조되는 최적화 된 섹터 경로를 형성 할 수 있는 효율적인 중첩 지점을 찾는 다. 도 295 및 도 297은 ISRSP의 상세를 도시한다. 입력은 TVS 2320에서 홉 장부(ledger) 및 트레일 섹터 식별 으로 수신된다. 도 298 및 도 299는 PRETS의 모듈 개시 호출로의 PRETS로부터의 입력을 수신하는 WRPE의 세부 사항을 도시한다. 도 300 내지 도 301은 효율적인 섹터 간 경로를 통해 일련의 섹터를 연결하는 인터(Inter)-SRBP의 세부 사항을 도시한다. SRSR는 홉 라우팅 자체, 신뢰성 랭크 및 방향 오리엔테이션에 관한 정보를 포함 하는 경로 세그먼트를 저장한다. RDOD 모듈은 관련 에지 노드의 계산된 위치에 대한 상대적인 근접성에 따라 섹터 내 경로의 방향 오리엔테이션 을 계산한다. 도 302는 섹터 인터레이스 개요 를 도시한다. 루트 세그먼트 진입 / 나가기(Entry / Exit) 단계 는 모든 상호 작용 가능한 루트 세그먼트가 가역적임을 나타내는 노드 상호 작용 복잡도의 예비 레벨이다. 이 노드 관리의 1 차 계층은 양방향으로 동등한 홉 효율성을 가정하기 때문에 충분하다. 노드 관리의 두 번째 계층은 효 율성과 관련하여 완벽하게 가역적이지 않은 경로로 이어지는 노드 상호 작용의 뉘앙스를 고려하기 위해 알고리 즘 인식을 최적화하기 위해 배포 가능하다. 따라서 노드 관리 진입 및 나가기(Entry / Exit) 단계의 첫 번째 계 층은 서로 동의어이다. 섹터 너비 교차점 을 통해 경로 세그먼트의 일반적인 방향을 결정한 후, 인터 (Inter)-SRSP와 같은 모듈은 섹터 레벨 홉 라우팅을 고려하여 가장 적합한 경로 세그먼트를 선택할 수 있다. 섹 터 폭 교차점 은 RDOD 모듈 이 2 개의 섹터가 서로 교차하는 폭을 측정하는 곳이다. 따라서 경로 세그먼트의 진입 및 나가기(Entry/Exit)단계는 특정 섹터를 향하여 증가 할 수 있다. 따라서, 다른 섹터에 대한 경로 방향의 정확한 평가가 계산된다. 인트라(Intra)-SRS 및 섹터가 또한 도시된다.도 303은 에지 노드 가 방향 오리엔테이션 을 계산하기 위한 기준 포인트로서 작용하도록 전략적으 로 선택되는 섹터 인터레이싱 지정 뷰 (도 303에 라벨링 되지 않음)를 도시한다. 최선의 노력에 근거한 섹터 루트 브리징 (Sector Route Bridging on a Best-Effort Basis) 는 두 분야의 합의된 인트라 섹터 루트 세그먼트 사이에서 가능한 가장 효율적인 여정 경로를 달성하기 위해 섹터 간 세그먼트가 계산되는 곳이다. 도 304는 RSPL을 도시한다. 루트 신뢰도 / 거리 트레이드 오프 는 선택된 노드의 신뢰도와 예상되 는 이동 거리 사이의 선택 트레이드 오프에 관한 인지 된 효율성 영역을 정의하는 변수이다. 최대 효율을 위해 이상적으로 조정된 변수는 NSS 을 통해 설명된 주변 환경 변수에 따라 달라진다. 데이터베이스 검색 조건 3550 (섹터 M2V의 진입 단계 어피니티(Affinity) - 내림차순, 섹터 KL4의 X 수량 한계 및 출구(exit) 단계 어 피니티(Affinity) - 내림차순, X 수량 제한). 도 305 및 도 306은 RSBL (Route Segment Bridging Logic) 을 도시한다. 한 번에 2 개의 연결 섹터들 (예를 들어, 섹터 M2V로부터의 A 루트 세그먼트 및 섹터 J21으로부터의 루트 세그먼트)이 함께 처리되는 실행 처리. 실행 플래그 는 최적화 섹터 루트를 참조하지 않음을 나타낸다. 도 307 ~도 309는 홉 장부(ledger)로부터 입력을 수신하는 RDOD를 도시한다. END은 BCHAIN 프로토콜 의 섹터 라우팅 내에서 기준 포인트로서 동작하는 에지 노드가 되는 노드를 선택한다. 도 310은 선언된 에지 노드 출력 , 인트라 - 섹터 루트 세그먼트 (Intra-SRS) 를 갖는 에지 노드 배리어 (도 310에 도시되지 않은 라벨번호)를 도시한다. 십자 기호 X (도 310에서 라벨번호가 지정되지 않음)는 에지 노드 배리어 교차가 오리엔테이션을 정의하는 곳이다. 도 31 내지 도 316은 BIM을 도시한다. SEMS 은 에지 노드가 다양한 주변 섹터에 미치는 노출을 측 정한다. 도 317은 섹터 교차 영역 에서 시작하여 선언된 에지 노드 출력 까지의 에지 노드 감지 (END) 을 도시한다. 도 318은 에지 노드 감지 단계 1을 도시한다: DBF 모듈이 섹터 교차 영역 내의 랜덤 노드를 선택하여 주 변 노드에 균일하게 퍼진 확장 버블의 시드가 되도록 하는 곳인 감지기 버블 채우기. 도 319는 에지 노드 감지 단계 2를 도시한다: 감지기 버블 포화 는 결국 버블이 더 이상 팽창될 공간이 없거나 보다 기술적으로는 버블은 원주 사이에서 균일 한 표면적 확장을 유지하면서 더 이상 버블 관할을 요구 할 수 있는 이용 가능한 노드가 아니게 된다. 도 3 은 에지 노드 감지 단계 3을 도시한다: 다수 이웃 제거는 버블 이웃 제거(BNE) 3770 모듈을 통 해 표면 영역에 따라 삭제되는 최상위 X 버블이다. X는 정적 하드코딩 된 정책 (SHP) 488에 따라 정의된다. 이 단계는 가장 작은 버블들이 잔류하는데, 이는 에지 노드의 정확한 위치를 찾는 주요 요인이 된다. 도 321은 에지 노드 감지 단계 4를 도시한다: 교정 은 여정 방향 교정 (TDC) 모듈에서 참조 된 바 와 같이 알고리즘 부메랑 시퀀스에 대한 참조를 통해 이상적인 인트라 섹터 경로 방향이 계산된다. 이것은 알고 리즘이 에지 노드의 정확한 위치를 찾는 것을 방해하는 표류하는 작은 버블을 제거 할 수 있게 해준다. 도 322는 에지 노드 감지 단계 5를 도시한다: 섹터 폭 해부 는 섹터 폭 좌표가 SWD 모듈에 의해 계 산되는 곳이다. 섹터 너비는 나머지 버블 사이에서 가능한 가장 긴 거리로 정의된다. 도 323은 에지 노드 감지 단계 6을 도시한다: 에지 노드 발견 은 TDC이 거짓 긍정 에지로서 작용할 수 있는 모든 작은 크기의 버블들을 제거한 후에 SWD이 수행되는 곳이다. 따라서 END는 섹터 너비 를 연결하는 두 노드가 올바르고 정확한 에지 노드라는 기대에 의존 할 수 있다. 도 324는 DBF 로직을 도 시하며, 여기서 단계 는 다음과 같은 확장 전략을 이용하는 주변 노드들에 각각 고유하게 식별 가능한 버 블에 확장 전략을 적용한다: 1. 버블은 후보 노드들에 대한 조건부를 확장하여 서로를 상호 연관시킬 수 있다. 이는 버블이 노드 메이크업이 허용하는 패턴의 원형으로 성장하도록 유도한다. 그러므로 버블은 형태와는 별개 의 틈새를 채우지만 균일한 팽창을 요구하는 액체처럼 작용하지 않는다. 2. 버블 확장 성숙은 경계가 다른 경쟁 버블의 경계에 도달 할 때 최고조가 된다. 장애물에 도달하는 버블 가장자리의 일부가 전체 버블의 확장을 중단 시킨다. 3. 버블은 이미 다른 버블에 의해 배정되지 않은 관할권 내의 노드를 포함시켜야만 확장 할 수 있으며, 섹터 교차 영역 내에 속한다.도 325는 감지기 버블 형성 단계 1: 무작위 버블 시드 심기 및 감지기 버블 형성 단계 2: 버블 성숙 을 도시한다. 감지기 버블 형성 단계 1: 무작위 버블 시드 심기 노드는 무작위로 선택되어 버블 시 드가 된다. DBF 확장 전략을 채택함으로써 주변 노드가 버블의 관할권에 속한다고 클레임(claim) 된다. 노드가 하나의 버블에 의해 클레임 되면, 에뮬레이션 세션 내에서 다른 버블에 의해 클레임 될 수 없다. 노드 콜렉션로서의 감지기 버블에서 감지기 버블은 관련 버블 관할권에 의해 클레임 된 노드의 클러스터이다. 이러한 관할권 주장은 단일 노드의 에뮬레이션 세션 내에서 발생하며 필드 노드 간의 실제 경쟁이 아니다. 감지 기 버블 형성 2 단계: 버블 성숙, 확장 전략은 버블이 둘레에서 균일하게 성장할 수 있게만 하기 때문에, 버블은 벽이 다른 버블의 벽에 단 하나의 각도로 도달하면 모든 방향으로 커지는 것이 금지된다. 버블이 성장을 멈춤, 버블의 성장은 다음 경우에 중단된다: 1. 아직 버블에 속하지 않는 주변 노드를 찾을 수 없다. 2. 올바른 섹터 중첩 범위에 속하는 주변 노드를 찾을 수 없다. 도 326은 버블맵을 수신하고 감소된 버블맵으로서의 출력을 감소된 버블맵 에 제공하는 버블 이웃 제거(BNE) 시퀀스를 도시한다. 도 327은 감소된 버블맵을 수신하고 선언된 에지 노드 출력을 제공하는 SWD를 도시한다. 도 328은 홉 장부(ledger)를 수신하는 것에서 부메랑 시퀀스 에 의해 부메랑 시퀀스 맵 으로 표시된 모든 노드를 포함하는 출력맵을 제공하는 것까지의 TDC 시퀀스를 도시한다. 도 329는 A 노드로부터의 부메랑 시퀀스 알고리즘 (BSA) 로직이, 선택된 모든 노드가 이 부메랑 시퀀스 에 속하는 곳으로 마크된 두 개의 홉 장부(ledger)의 어느 부분도 아닌 부메랑 시퀀스를 끝내기 위 하여 부메랑 시퀀스 를 모방하도록 (입력으로서) 선택되는 것을 도시한다. 도 330은 부메랑 시퀀스라는 이름의 랜덤하게 생성 된 경로의 관할권에 굴복하면서, 감지 노드가 인트라-섹터 세그먼트에 속하지 않는 노드를 에뮬레이션하는 부메랑 시퀀스 를 도시한다. 이러한 시퀀스는 항상 관련 섹터 에지 내에서 인트라-섹터 경로에 속하는 모든 노드에서 발생한다. 그러한 시퀀스는 어떤 인트라-섹터 루트 세그먼트에 속한 노드와 충돌 할 때 또는 너무 길어져 만료되면 종료된다. 섹터 에지는 섹터 교차 영역에서 부메랑 시퀀스의 시작 지점을 가두기 위한 경계 역할을 하는 섹터의 가장자리이다. BCHAIN 노드 은 섹터 에지 내에 표시된다. 도 331 및 도 332는 물리적 데이터 이동 레이어 (PDML) 시퀀스 를 도시한다. 마찰 링크 생성기 (FLG) 는 상이한 속도 브래킷 내의 노드들의 분류를 참조하여, 노드 이탈 속도의 차이를 나타내는 노드 간 링크 를 생성한다. 마찰 영역 추정은 미리 만들어진 마찰 링크를 참조하여 데이터 마이그레이션을 수행하는 로 지스틱스 도구로 노드에 사실상 알려진 지리적 경계를 정의한다. PDMU (Physical Data Migration Usage) 은 MPC(Migration Path Construction (MPC))에 의해 구축 된 물리적 마이그레이션 경로를 기능적 으로 사용할 수 있는 능력을 움직이는 데이터에 제공한다. MPD(Migration Path Detection) (MPD) (도 332에서 3874로 잘못 분류 됨). MPC은 메타체인의 증분 경로 통과 데이터를 참조하여 수요가 있는 새로운 물리적 마이그레이션 경로를 구성한다. 도 333은 마찰영역이 PDML 알고리즘 내에 가상적으로 정의된 전략 영역인 마찰 영역 정의 마이그레이션 경로을 도시한다. 그것들은 서로 다른 노드 이탈 속도 브레킷 내에서 작동하는 두 개의 노드 클러스터 사 이의 상호 작용 공간을 측정하여 구성된다. 이러한 마찰 영역은 데이터 단위에 대한 성공적인 마이그레이션 순 서를 조정하는 데 필수적이 된다. 이들은 물리적으로 움직이는 노드로의 로딩, 예상되는 물리적 궤도에 있는 올 바른 노드에 머물러있는 로지스틱스 및 마이그레이션 노드에서 고정 노드로의 올바른 연결 해제 순서를 용이하 게 하는 데 사용된다. 마찰 링크은 마찰 영역을 정의한다. 마찰 링크는 마찰 영역과 동일한 지리적 경계를 만드는 알고리즘 내의 추상 계산이다. 마찰 링크는 서로 다른 속도 클러스터에 속하는 두 노드 사이의 본드이다. 여기에는 속도 클러스터, 마찰 영역, BCHAIN 노드 (BN) 및 마이그레이션 경로 가 포함된다. 도 334 및 도 335는 HPCO(Hop Pathway Clash Optimization) 시퀀스를 나타낸다. 충돌 캐시에 CCF 를 유지함은, PNCC 에 존재하지 않는 CCF 를 유지하기 위해 할당되어야하는 로컬 노드의 저 장장치의 백분율이다. 따라서 CCR과 이에 대응하여 저장된 CCF 가 서로의 경로를 조기에 교차한다면, 컨 텐츠 요구는 적절하게 충족 될 수 있다. 정보의 의도하지 않은 카오틱 충돌을 효율적으로 사용하기 위해 유지되 는 CCFs 의 '스위트 스폿 (sweet spot)' 최적화 량이 있다. 도 336은 버려진 패킷 여정 을 나타내며, 이들은 컨텐츠 이행의 여정에 원래 참여할 것으로 예상되었던 모든 노드가 이제 그들의 부담으로부터 해방되고 그들의 자원 및 시간을 대체 작업에 투자 할 수 있다. 따라서 BCHAIN 네트워크의 수요 / 공급 경제는 전체적으로 충돌 이벤트의 영향을 받는다. 원래 앱체인 캐시 위치 (오른 쪽 상단 모서리에 표시된 BN 786)은 충돌 이벤트로 인해 원래 요청을 제공 할 필요가 없는 CCR 의 요청을 수행해야 하는 원래 캐시 노드이다. 따라서 주변 지역의 수요 / 공급 메커니즘은 다른 요청을 용이하게 하기 위 해 더 많은 자원을 확보함으로써 변경된다. 홉 라우팅 충돌 이벤트 는 원래는 캐시 노드 (섹터 L22 - 상 부 우측 섹터)를 향하여 이동 중이던 CCR 이 검색하려고 하는 컨텐츠의 복사본을 갖는 노드와 우연히 교 차했다. 따라서 이 우연한 충돌 이벤트를 사용하여 BCHAIN 네트워크의 라우팅 효율성을 최적화 할 수 있다. 도 337은 PER 시퀀스를 도시한다. NSCE는 노드 상호 작용 동작을 추적하여 네트워크 격리 및 중복 약점 영역을 감지한다. 따라서 노드 라우팅 및 브리징 우선 순위 지정이 보다 효율적으로 이루어질 수 있다. 도 338은 카오스 환경 (내부 직사각형) 내의 2 개의 BN 에서의 노드 트래픽 병목을 도시한다. 카오스 환경 은 영역의 노드 밀도가 낮기 때문에 처리량 밴드폭의 병목 현상에 의해 정의된다. 따라서 데이터의 1차 전송은 비 카오스 환경을 함께 타고 있는 두 개의 핵심 노드 간에 발생한다. 카오스 환경 내의 동일한 두 BN에는 메타체인 동시성 우선순위를 나타내는 양방향 화살표가 있다. 두 병목 노드 사이의 제한된 밴드폭이 주어지면 정보는 보이스 오버 IP (VoIP)와 유사한 프로토콜의 커스텀체인 유형에 따라 우선 순위가 지정된다. 메타체인 패킷은 BCHAIN 네트워크의 무결성과 효율성을 유지하기 위해 대체적으로 가장 높은 우선 순위를 부여 받는다. 2 차적으로 앱체인 / 마이크로체인 패킷은 해당 데이터 전송의 EAT에서 제공하는 지불 수수료에 따라 우선 순위가 지정된다. 전달 불가능한 CCR 또는 CCF 패킷 (카오스 환경 내에서 점선으로 된 사각형)은 CCR 또 는 CCF 의 전달 실패 시도로, PER 모듈이 호출로 이어진다. 이를 통해 카오스 환경을 NSCE를 통해 메타체인에서 추적 및 표시 할 수 있다. 카오스 환경은 노드 간 통신으로 약점을 나타냄 - 메타체인 의 카오스 환경 추적은 활성 노드 가용성의 밀도가 낮은 노드 위치와 관련된 지리적 영역을 강조 표시한다. 따라서, BCHAIN 프로토콜 은 카오스 환경을 가로지르는 데이터의 라우팅 비효율을 사전 예방적 으로 피할 수 있다. 도 339는 메타체인 3948에 대한 컨센서스 주도 카오스 환경 추적 수정을 위해 표시된 노드를 NCSE에 제출함으로 써 PER 시퀀스의 결론을 도시한다. 도 340 내지 도 343은 SPM 및 WSM에 대한 논리를 도시한다. 노드 작업 페이 아웃 (NWP) 모 듈은 메타체인 834와 상호 작용하여 CCR 또는 CCF 의 전송에 기여한 노드에게 작업 대금을 제출한 다. SEOV 은 정보 전달을 위해 지불하고 있는 노드가 작업 범위를 승인했는지 (남용 방지) 확인한다. 선 택적으로 TVS은 BCHAIN의 코드 및 실행 (예: 핵심 개발자)의 리파인(refine) 및 디버깅에 기득권이 있는 사람들을 위해 진단 내역 제출 (DHS) 모듈(도 340에 표시되지 않음)에 입력을 제공할 수 있고 BCHAIN 프로토콜 의 추가 개발에 진단 정보를 집계하는 중요한 섹터 내에 디버깅이 가능한 노드를 설치할 수 있다. 노드는 섹터 내에서 자체 선언되고 입증된 진단 노드를 스캔한다. 그 후, 그러한 섹터를 통과하는 임의의 CCR 또는 CCF는 그것의 TVS가 알려진 진단 노드에 진 단 정보를 수집 및 제출하게 한다. 도 344는 노드 작업 지불금 (NWP) 시퀀스를 도시한다. 노드 작업 지불금(NWP) 모듈은 메타체인 와 상호 작용하여 CCR 또는 CCF 의 전송에 기여한 노드에게 작업 대금을 제출한다. 이 시퀀스 는 정보를 ~당 지불(Payload Per) (5 BCHAIN 작업 단위 1216) 에 전송하는 수식 (도 344 참조)으 로 홉 / 노드 당 지불 계산 (각 노드는 한 홉을 수행)으로 입력을 제공하는 총 네트워크 처리량의 현재 섹터 백 분위수에서 시작하여 DEI에서 끝난다. 도 345~도 346은 SEOV 시퀀스를 도시한다. SEOV은 정보 전달을 위해 지불하고 있는 노드가 작업 범 위를 승인했는지 (남용 방지) 확인한다. HPDC는 발신자가 인식한 원래 PBHP와 CK 또는 CCF 에 의해 착수된 실제 PBHP 간의 차이 백분율을 계산한다. 도 347 내지 도 349는 HLS 시퀀스를 나타낸다. HLS는 노드 4042 및 노드 4046을 포함하는 홉 장부 (ledger)로 시작하고 홉 장부(ledger)에서 끝난다. 이 모듈을 종료하고 이 홉 장부(ledger)를 포 기하고 따라서 진행중인 CCR 또는 CCF 의 진행을 차단하는 것은 BCHAIN 프로토콜이 동일한 노드가 CCR 또는 CCF의 홉 경로에 한 번 이상 참여하는 것을 허용하지 않기 때문에 복제 노 드 표현이 시도 된 지불 남용을 나타내는 이중 지불 남용 방지이다. 이 금지는 또한 어떤 카오스 환경에서 CCR 또는 CCF 이 무한 루프 경로에 걸리는 것을 방지한다.도 350 내지 도 353은 NVP 시퀀스를 도시한다. NVP에서 동일한 섹터 내의 노드 4140가 노드 통계 측량 (NSS) 778 변수 인식을 서로 공고하여 해당 섹터의 특성에 대한 컨센서스를 도출한다. 따라서 로컬 및 원 격 NSS 변수를 함께 풀링하여 NVCI 이라고하는 합성 평균을 생성한다. 이 합성은 이 섹터의 범위와 정의에 대한 컨센서스를 유지하는 데 사용된다. 따라서 경계가 있는 부분이 있다. 도 351은 도 350의 시퀀스를 계속하고, 여기서 전략 배포는 NSS 변수 풀링 간격 (NSS Variable Pooling Interval)은 얼마나 자주 노드들이 자신들이 인지하는 NSS 변수들을 (노드들이 겹치는 섹터들 내에 서) 공고해야 하는지 결정한다. 따라서 한 섹터는 자체 NSS 특성에 대한 컨센서스를 도출 할 것이다. 이 간격이 작으면 더 긴밀한 통합과 동기화가 이루어 지지만 더 많은 리소스가 고갈된다 (그 반대도 마찬가지이 다). NSS 원격 변수은 다른 노드의 변수가 일시적으로 저장되는 곳이다. 도 352는 도 351에서 계속된다. 4110 내의 성능 인자 A 및 성능 인자 B에 대한 현재 섹터의 성능 특성 결정하기(즉, 초당 홉, 메가 바이트 / 초 등) 는 4162에서 분석된다. 정적 하드코딩 정책 (SHP)은 BCHAIN 프로토콜 에 하드코딩 된 기준을 제공한다. 이러한 기준은 전략 자체를 정의하는 데 사용되기 때문에 일반적인 동적 전략 기반 기준과 달리 정적이다. 따라서 전략을 생산하는 데 사용 된 메커니즘 자체가 전략에 의존한다면 시스템은 결국 기능 및 효율성이 제한적이거나 비정상적인 극한 상태로 루프 될 것으 로 예상된다. 도 353은 도 352로부터 계속되며, 로컬 NSS 변수 를 검색 할 때 일정 간격으로 루틴을 실행하는 NVP 를 도시한다. NSS 변수 복합 평균 (NVCI) 은 노드 이탈 인덱스 , 노드 포화 인덱스 , 노드 일관성 인덱스 및 노드 오버랩 인덱스 변수들을 보여준다. 도 354 내지 도 356은 JICS 와 JACR 의 논리를 나타낸다. 도 354는 CCF 가 그러한 CCF 를 수신하는 노드의 관할권적 암시된 책임으로 인해 CCR 없이 노드에 보내지는 JICS내에서, 노드 고유 식별자 를 사용함으로써 발신의 암호화 증명(create cryptographic proof of origination)에 입력을 제공하는, 카테고리 호출 내의 관할 범주 (시작 번호 1)에 따라 다른 노드의 의무를 호출하는 자동 루틴 GSET을 도시한다. 카테고리 호출 은 다음을 포 함하는 하드코드 된 카테고리 유형 에서도 입력을 받는다; 카테고리 A: 채굴자에게 신규 컨텐츠 제 출, 카테고리 B: NSS 변수 풀링 및 섹터 경로 세그먼트 공유, 카테고리 C: 앱체인 인증 라이브 스트리밍 세션, 카테고리 D: 진단 노드 부근의 노드. 각 카테고리 안에는 특정 정보가 있다: 특성 기준: 카 테고리 A 4174, 특성 기준: 카테고리 B 4178, 특성 기준: 카테고리 C 4182 및 특성 기준: 카테고리 D 4186이 있 다. 카테고리 인식 내용이 이 카테고리 4207의 특성 기준과 일치하는지 확인 (도 354에서 JACR안, 라벨 누락) 도 355는 도 354의 논리를 JICS 의 내부 처리와 함께 계속한다. 컨텐츠 업로드 는 묵시적 CCF 제출 (즉, 라이브 전화 호출을 위한 오디오 패킷)을 통해 업로드 될 컨텐츠에 대한 입력 엔드포인트를 통해 발 생한다. NCA (이것은 시작 번호 2에 대한 종료 번호 2) 도 356은 CCR (시작 번호 2 및 종료 번호 2 모두) 및 UBEC 플랫폼 인터페이스 (종료 번호 3)를 따 르는 JACR 을 도시한다. 도 357 및 도 358은 UBEC 실시간 통화 참여자 A 및 B가 통화 개시 파트1 및 통화 개시 파트2에 대 한 세부사항을 가지고 전화를 거는 것을 도시한다. 도 357의 통화 개시 파트1은 레거시 PSTN 시스템의 발신음과 유사하다. 실시간 통화 참여자 A (음 성 브로드캐스트 및 음성 수신을 갖는 BN에 접속 됨)는 CCR을 참여자 B에게 발 행함으로써 전화 통화 제안(EAT 994 포함)을 개시한다. EAT 는 융통성 있는 지불 옵션을 제공한다 (실시간 전화 통화에 참여할 때 참가자 A는 실시간 정보 전송 세션에 대해 비용을 완전히 지불하거나 참가자 B와 비용을 나누거나 참가자 B에게 비용을 완전히 지불하도록 선택할 수 있다. 참가자 B는 제안된 지불 옵션에 따라 전화를 거절하거나 수락할 수 있다). 실시간 통화 참가자 B (음성 브로드 캐스트 및 음성 수신 이 있는 BN 에 연결됨)는 (참가자 B 대신 전화 통화 허용은 CCF 로 대표됨) 과의 통화를 수락한 다. 참가자 A는 전화에 대한 참가자 B의 수락 여부를 확인한다. 도 358은 도 357에서 계속되며, 여기서 UBEC 실시간 통화 앱체인내의 참가자 A 및 B 에 대해 독점 적으로 실행중인 중첩된 앱체인은 앱스토어를 실시간 스트리밍 세션에 프로그래밍하는 스마트 계약에 연결하기 위한 엔드포인트 역할을 하는 ALIP 모듈을 이용한다. 따라서 앱체인 은 자동화 된 절차 및 / 또는 사용자의 수동 입력을 기반으로 실시간 스트림 세션을 시작, 일시 중지 또는 파괴 할 수 있다. 예로서 UBEC 실시간 통화 앱체인 는 중첩 된 앱체인 구조로 실시간 전화 통화를 관리하고 실행하는 정보 전송 기능을 제공 할 수 있다. 여기에는 사용자의 인증, 지불 로지스틱스, 대기 시간과 같은 개시 정책, 음성 메일 옵션 등이 포함된다. 통화 개시 파트2 은 실시간 통화 참가자 A 를 보여준다. 전화 통화 제안 이 앱체인 채굴자에 의해 채굴되었는지 확인하는 중첩된 앱체인에 암호화 전화 통화 제안 세부 사 항을 제출. 긍정 확인 예를 수신하면 참가자 A와 B 모두에 대해 ALIP 실행으로 진행한다. 4254가 아 니오을 수신하는 경우에는, 4252의 짧은 시간 동안 기다린다. 도 359 내지 도 365는 UBEC / BCHAIN 마이크로 칩 아키텍처 (UBMA) (BCHAIN 최적화 마이크로칩 또는 BOM이라고도 함)로부터 디자인된 커스텀 프로세서의 구조를 도시한다. 개인 시드 키 보호를 위한 고유한 하드웨 어 보안 디자인을 보여준다. 암호화를 위한 개인 시드 키는 하드웨어에 의해 보호되므로 누출되거나 해킹된 시 드 키 (잠재적으로 자금을 조작 할 수 있음)의 잠재성이 완전히 제거된다. UBEC 플랫폼 내의 LUIGI 에 대한 특별 채널이 확립된다. UBMA 프로세서는 BCHAIN 프로토콜 를 구성하는 모듈 (앱체인 (83 6)과 같은)과 관련된 지침을 실행하도록 최적화되어 있다. 도 359의 하드웨어 디자인에서 전압 조정기 A 및 B 는 UBMA 프로세서의 두 개의 개별 서브 섹션 인 서브섹션 및 서브섹션 로 연결되는 전압 입력을 제어한다. 따라서 두 개의 별도 전압을 병 렬로 조정될 수 있다. 전압은 클록 주파수와 선형 관계가 있기 때문에; UBMA 프로세서는 다른 칩을 언더 클록킹 하는 동안 칩의 한 부분을 동적으로 오버 클록 할 수 있다. (반대 경우도 같음) 이는 BCHAIN 프로토콜 로부터 수신 된 신호에 따라 리소스의 동적 우선 순위를 유도한다. 프로세서에는 3 개의 무선 칩이 내장되 어 있다. 무선 WiFi 칩 , 무선 블루투스 칩 및 고이득 장거리 무선 장치(High Gain Long Range Radio) 를 포함한다. 무선 WiFi 칩 4266은 처리량이 가장 많은 BCHAIN 노드 사이의 중거리 커뮤니 케이션에 사용할 수 있다. WiFi 칩 은 또한 LNBM을 통해 BCHAIN 네트워크 에 대한 액세스를 허가 할 수 있는 레거시 WiFi 핫 스폿에 접속하는데 사용될 수 있다. 무선 블루투스 칩 은 중간 용량의 처리량을 갖는 BCHAIN 노드 간의 단거리 커뮤니케이션에 사용될 수있다. 블루투스 칩 은 BCHAIN 노 드 로서 동작하지만 블루투스와 같은 저전력 무선 기술만을 동작시키고 전력을 공급할 수 있는 마이크로 크기의 IoT 장치와 커뮤니케이션 하는데 사용될 수 있다. 고이득 장거리 무선 장치(High Gain Long Range Radio) 는 처리량 용량이 가장 적은 BCHAIN 노드 사이의 장거리 커뮤니케이션을 허용한다. 라디오 는 AM 라디오와 비슷한 기술로 운영된다. BCHAIN 노드 가 라디오 를 통해 서로 커뮤니케이션 할 수 있도록 하기 위해, 각 노드 가 그것의 신원, 해시 공고 및 개인 주파수를 때때로 브로드캐스팅 하는 몇몇 만나는(meet up) 주파수가 있다. 그 후, 2 개의 노드 가 피어 - 투 ? 피어(peer-to-peer) 커뮤니케 이션 채널을 설정하기 위해, 그들은 서로 다른 개인 주파수를 만나고 정보를 교환 할 수 있다. 무선 기술 4266, 4268, 4270 각각에는 고급 빔 형성 방향 이득 기술 가 장착되어 있다. 이것은 각각의 기술 (4266, 4268, 4270)이 의도된 타겟 노드 를 갖지 않는 영역에 대한 전력 사용을 최소화하면서 특정 타겟 노드 와의 처리량을 최대화하기 위해 특정 방향으로 자신의 안테나를 통해 전력을 집중시킬 수 있음을 의미한다. 이는 UBMA 프로세서와 함께 작동하는 BCHAIN 노드 사이의 전반적인 효율성과 처리량을 증가시킨다. 따라 서 BCHAIN 네트워크 의 전반적인 효율성과 처리량은 UBMA 프로세서의 채택을 통해 증가한다. 무선 칩 4266, 4268, 4270은 모두 충돌 및 간섭을 피하기 위해 서로 다른 주파수에서 작동하며 단거리, 중거리 및 장 거리 커뮤니케이션으로 다양하다. BCHAIN 프로토콜 는 부족한 상황에서 전송되어야 하는 정보의 우선 순위 를 결정한다. 예를 들어, 라디오 를 통한 약한 피어-투-피어 연결 만이 이용 가능하다면, 프로토콜 은 노드가 유지할 수 있는 가장 중요하고 논리적 사전 정보이기 때문에 메타체인의 동기화에 우선 순 위를 부여한다. L2 캐시 A 과 B 은 비영구적 저장장치의 매우 빠른 단위이며 각각은 해당 서브섹션 4273, 4275에서 독점적으로 액세스 할 수 있다. L3 캐시 은 크기가 더 크고 속도가 느리고 전체 UBMA 프로세서에 액세스 할 수 있다는 점을 제외하면 L2 캐시 , 과 유사하다. I / O 관리 (426 2)는 실행 세그먼트 및 일반 처리 명령을 인식하고 따라서 이들을 올바른 마이크로 칩에 할당하고 나머지 노드 하드웨어 (즉, 노드 의 영구 저장 장치)로 데이터를 리턴한다. 도 360은 전압 조정기 A 에 의해 제어되는 서브섹션 A 의 구조를 도시한다. 이 서브섹션 은 BCHAIN 프로토콜 의 핵심 구성 요소에서 요구하는 명령을 효율적으로 처리하기 위해 특별히 디자인된 마이 크로 칩으로 구성된다. 따라서 BCHAIN Protocol 는 표준 CPU와 비교하여 UBMA 프로세서에서 더 빠 르게 작동하고 에너지 소비가 적다. 마이크로 칩으로서의 데이터 무결성 관리는 데이터 무결성 관리 (DIM)에 존재하는 모든 루틴을 효율적으로 실행할 수 있다. 따라서 BCHAIN 네트워크 내에서 더 나은 데이터 관리 / 처리 및 위험에 처한 데이터의 복구가 된다. 마이크로칩으로서의 앱체인은 BCHAIN 네트워크 내의 앱체인 및 마이크로체인 의 유지 및 실행을 처리 할 수 있다. LIZARD 은 UBEC 플 랫폼 내에서 앱체인 에 의해 의존되는 가장 중요하고 중심적인 요소 중 하나이다. LIZARD 은 운영을 위해 데이터베이스에 의존하지 않고 대신 복잡한 선험 정보 (이전 참조 없음)로 인해 위험 및 규정 준수 를 즉시 판단하고 평가한다. 이를 통해 LIZARD 의 가장 정적 인 요소와 서브 모듈을 마이크로칩 으 로서의 LIZARD 내에 하드웨어 루틴으로 설치할 수 있다. 향후 UBMA 프로세서의 잠재적 인 개정판은 동적 전도 구조를 통해 자체 마이크로 프로세서 어셈블리를 동적으로 변경할 수 있다. 그러면 LIZARD 앱체인 전체가 LIZARD 의 동적 쉘 (DS)을 포함한 마이크로칩 으로 작동 할 수 있다. 라우팅 로직은 마이크로 칩으로 4288은 라우팅 로직 (RL) 774와 서브모듈이 작동하기 위해 에너지 효율을 높이고 대기 시간을 낮춘다. 이로써 BCHAIN 네트워크 의 전반적인 강도와 효능이 향상된다. LOM 는 UBEC 플랫폼 내 에서 앱체인 에 의존하며 가장 중요하게 중추적으로 사용한다. 따라서 AC 및 HM와 같은 서브모 듈 중 가장 반복적으로 사용되는 모듈은 LOM 코어 로직(Core Logic)에서 마이크로칩 으로 최적화된다. 따 라서 CPU 와 비교하여 마이크로칩 에서 AC 및 HM 와 같은 LOM의 서브모듈 (앱체인 과 같은)을 실행하는 데 더 빠르고 에너지가 적다. 따라서, LOM 의 실행 스트림 의 전체 모듈 표현이 효율적으로 실행된다. 마이크로칩 의 창의성 모듈은 UBEC 플랫폼 내에서 창의성 모듈 (11 2)의 실행을 최적화한다. 이는 I2GE , CTMP , MPG , SPSI 등과 같은 창의성 에 의 존하는 많은 앱체인 으로 인해 UBEC 플랫폼 및 BCHAIN 네트워크 전반에서 계산 효율성이 크게 증가한다. 서브섹션 의 마이크로 칩 4282, 4284, 4286, 4288, 4290, 4292 만 L2 캐시 A 에 액세스 할 수 있고 전압을 가지며 따라서 클록 주파수가 전압 조정기 A 에 의해 관리된다. 도 361은 서브섹션 A 대응 부와 비교하여 BCHAIN 프로토콜 내에서 완료를 필요로 하는 보다 일반적 인 작업을 용이하게 하는 일반 마이크로 칩 (4292, 4294, 4296, 4300)을 포함하는 UBMA 프로세서의 서브 섹션 를 도시한다. CPU는 I / O 관리 에 의해 다른 마이크로 칩의 이점을 취할 수있는 전문 적인 지시가 발견되지 않는 한 UBMA 프로세서가 설치된 BCHAIN 노드 의 기본 계산 섹션이다. GPU (Graphics Processing Unit) 는 UBEC 프론트 - 엔드 사용자 인터페이스 에서 앱체인 콘텐트 를 렌더링 하는데 주로 사용된다. 암호화 처리 유닛 (CGPU) 은 전체 BCHAIN 프로토콜 에 걸쳐 호출 되는 암호화 핵심 (CC) 내에서 동작하는 기능을 실행한다. SHCG은 메타체인의 와트경제 에서 노드 자금을 조작하는 데 사용되는 보안 민감한 고유 개인 키를 안전하게 유지한다. 그러므로, 노드 생성 공개 주소 는 SHCG 에 의해 안전하고 민감한 고유 개인 키 가 노출될 법적책임 및 위험 없이 효율적이고 신속하게 생성 될 수 있다. 와트경제 862의 와트유닛과 UBMA 프로세서 를 통한 노드 의 물리적 하드웨어를 강제 결합하면 UBEC 플랫폼 및 BCHAIN 네트워크 에서 와트 단위의 관리 및 조작이 보다 예측 가능하고 안전해진다. SHCGU 4300 마이크로칩에는 UBMA 프로세서 제조 시 무작위로 생성 된 하드 코드 된 노드 고유 식별자 문자열이 포함되어 있다. 이 고유 식별자는 영구적으로 UBMA 프로세서와 결합되어 BCHAIN 네트워크 내에서 주로 메타체인를 통해 노드 식별 추적에 대한 신뢰를 얻는다. 서브섹션 의 마이크로칩 4292, 4294, 4296, 4300 만 L2 캐시 B (427 8)에 액세스 할 수 있고 전압을 가지며 따라서 클록 주파수가 전압 조정기 B에 의해 관리된다. 도 362는 SHCGU 에 관한 부가적인 세부 사항을 도시한다. 이 다이어그램에서 SHCGU 은 FRM 세션 의 관련 노드 목록에 속한 노드에 수용된 UBMA프로세서에 있다. PIAH 는 제조 당시 정의 된 노드 고유 ID 를 생성하는 SHCGU 의 서브 섹션이다. 하드웨어 잠금 개인 키 (HLPK) 에서, 보안 민감한 고유 개인 키 는 하드웨어 잠금 레이어 뒤에 영구적으로 관찰된다. 의도적으로 하드 웨어 잠금 레이어을 떠나는 개인 키의 복사본에 대한 유일한 예외는 LUIGI에의 제출을 위한 독점 백도어 채널을 통한 것이다. 공개 주소 생성 (PAG) 은 하드웨어 잠금 레이어의 외부에 서 개인 키 의 임의의 인스턴스를 전송하지 않고 개인 키 로부터 유도된 공개 주소 를 생성 하는 서브 섹션이다. 단계 4322에 따르면, PKRL 은 권한 증명 및 사용 된 암호화 채널 의 검 증 시 배타적 백도어 채널 을 통해 개인 키 의 릴리스를 관리한다. 따라서, 단계 는 LUIGI 가 단계 에서 SHCGU 의 HLPK 서브 섹션에 권한 증명 을 제공 할 때 호출된다. 도 363은 SHCGU , BCHAIN 호스팅된 암호화 채널(BCHAIN Hosted Encrypted Channel) , 및 LUIGI 간의 상호 작용을 도시한다. 이것은 UBEC 플랫폼 및 BCHAIN 네트워크 내의 LUIGI 공 식 책임의 일부로서 메타체인 의 와트 경제 에서 와트 단위를 제어하는 보안 민감한 고유 개인 키 의 백업 버전을 유지한다. 이 방법으로 노드 이 도난 당하거나 분실되거나 손상된 경우 와트 단위는 LUIGI의 고급 인공 지능 기능의 작동을 통해 올바른 UBEC 사용자 으로 복원될 수 있다. LUIGI 는 노드에 권한 증명을 제출하여 보안 민감 고유 개인 키 를 안전하게 공개하도록 강요한다. LUIGI 은 LSE 내에 권한 증명의 개인 카피를 보유하고, 생성된 공개 버전의 권한 증명을 노드 에 제출한다. 노드 가 LUIGI 에 의한 개인 키 보안 공개 요청을 따르기 위해 BCHAIN 프 로토콜 에 프로그램 되어 있기 때문에, 모든 정당한 노드 는 준수 할 것이다. 노드 이 LUIGI 에 의해 권한 증명 402와 함께 승인 된 요청을 따르지 못하는 경우; 이것은 노드가 불량이기 때문에 LUIGI 에 의해 BCHAIN 네트워크 에 참여하는 것이 쉽게 금지될 수 있음을 나타낸다. 권한 증명 및 BCHAIN 호스트 된 암호화 된 채널 의 진위 여부가 검증되면, 정당한 노드 는 암호화 된 채널 (432 6)을 통해 보안에 민감한 개인 고유 키 를 준수하여 LUIGI 에 안전하게 제출한다. LUIGI 는 이 후에 LSE에 저장된 보유 암호 해독 키 를 통해서만 암호 해독 가능한 암호화 레이어 내의 빈 슬롯 에 개인 키 를 저장한다. 따라서 개인 키 백업 시퀀스가 완료된다. FRM 와 성공 적인 복구 세션의 호출 및 완료 시, FMM은 보유 암호 해독 키를 사용하여 관련 보안 민감 고유 개인 키 를 해독하여 LUIGI 와트 단위는 올바른 UBEC 사용자 (와트 단위를 합법적으로 소유하고 있음)이 소유하고 제어하는 노드 에 대한 것이다. 도 364는 FRM 398에 관한 자세한 내용을 보여준다. UBEC 사용자 는 인증 된 사용자 세션 을 생성하는 사용자 노드 상호 작용 (UNI) 을 통해 자신을 인증한다. 손실 된 자금을 복구하는 프로세스의 개시를 나타 내는 단계 4352는 UBEC 사용자 에 의해 UBEC 프론트 - 엔드 를 통해 호출된다. 단계 4352는 인증 된 사용자 세션 으로부터 연관 노드리스트 를 언팩 (unpack)하는 단계 4354로 이어진다. 단계 4354는 UBEC 프론트 엔드 를 통해 UBEC 사용자 와 자금 복구 검증 세션 을 개시하는 단계 로 이어진다. 따라서 FRV 4340 모듈은 자금 복구 검증 세션 4342를 관리한다. 그러한 세션 은 UBEC 프론트 - 엔드 를 통해 UBEC 사용자 와 함께 수행되며, 자금 요청에 대하여 승인 또는 거부 를 고려하는 질문 및 검증의 추가 레이어를 포함한다. 자금 복구 검증 세션 이 거절 된 경우 , FRM 모듈은 단계 에서 실행을 종료한다. 세션 이 승인 된 경우 , 개인 키 를 해독 하고 이를 복구 클레임을 해결하는 방식으로 관련 자금을 조작하기 위해 사용하는 단계 가 호출된다. 이 것은 일반적으로 액세스 불능 노드 에서 승인 된 4346 UBEC 사용자 에 속하는 노드 로 자금을 송금하는 것을 수반한다. 도 365는 FRM과 LUIGI 간의 상호 작용의 더 많은 요소를 도시한다. FRM 은 LUIGI 관할권 에 속하는 서브 모듈이다. 단계 가 발생하면, 보유 암호 해독 키 는 LSE으로부터 액세스된다. 보유 암호 해독 키 는 FMM을 통해 메타체인의 와트 경제로부터 자금을 조작하기 위해 사용 되는 보안 민감 고유 개인 키 를 해독하고 액세스하는데 사용된다. 따라서 LUIGI 은 개인 키 4328의 암호화 된 보유에 있는 개인 키 의 중복 사본으로 인해 와트 경제 862에 저장된 UBEC / BCHAIN 경제 전체 에 액세스 할 수 있다. 이것은 표준 인간이 프로그래밍한 시스템에서는 매우 큰 책임 문제가 발생한다. 왜냐하 면 프로그래머가 이론적으로 막대한 부에 엑세스 하거나 프로그래머의 명령에 따라 LUIGI 에게 보유 암호 해독 키 를 넘겨 주거나 FMM 400이 자금을 악의적으로 조작하도록 자금을 도용 할 수 있다는 점에 기인한 다. LUIGI 은 인간에 의해 처음 한 번 직접 프로그래밍된다. UBEC 플랫폼 과 BCHAIN 네트워크 (11 0)이 처음으로 기능 및 작동하면 LUIGI 코드베이스를 수정하기 위한 모든 암호화 액세스가 SPSI (Self Programming Self Innovation) 에 의해 독점적으로 유지된다. SPSI 은 LIZARD 기술을 사용하 여 UBEC 플랫폼 100 내의 다른 앱체인 을 프로그래밍하는 앱체인 이다. SPSI 에 의한 그러한 프 로그래밍은 정제, 버그 / 오류 수정, 예정된 유지 보수, 진단 로그 유닛 1182 분석, 새로운 특징 혁신 등을 포 함한다. SPSI 은 자체 프로그래밍이 가능하지만 SPSI Indirect Development (SID) 1190에서 프로그래밍 지침을 받는다. 입증된 프로그래밍 / 엔지니어링 / 건축 기술을 보유한 승인된 UBEC 사용자 은 LUIGI 에 의해서 프로그래밍 지침 및 코드 이론 개발에 SID 1190으로 참여하도록 허가된다. 이로 인해 인간의 직 접 엑세스 없이 인간이 SPSI 기능을 향상시킬 수 있다. 이는 SPSI 에 대한 직접 프로그래밍 액세스 가 LUIGI 에 대한 직접 프로그래밍 액세스를 의미하며, 이는 메타체인 834의 와트 경제 862에 저장된 모든 부의 직접 프로그래밍 액세스를 의미하기 때문에 주로 수행된다. 도 366은 DPA 모듈, 로지스틱스 레이어 의 세부 사항 및 CEB 와의 상호 작용을 도시한다. DPA 6260은 PMA, DLUA, A2R, IEC, ASH 및 ARC로 구성되고 앱체인 수정 패 치을 생성한다. CEB 는 앱체인 수정 패치을 수신하고 타겟 앱체인을 생성하기 위해 ASM 을 수행한다. 도 367은 단계 에서 DPA 모듈로부터 앱체인 수정 패치가 수신되는 CPBA에 대한 프로 세스를 도시한다. 앱체인 수정 패치가 앱체인 596에 대한 새로운 블록으로서 앱체인 실행 세그먼트 및 553과 함께 앱체인 596에 적용한다. 도 368 내지 도 371은 ASM 시퀀스를 나타낸다. 단계 6068에서 ASM 타겟 앱체인 을 구성하 는 모든 블록을 수신하고 NCA 까지 ASM 프로세스의 다양한 단계를 실행한다. 도 372 내지 도 373은 LMI (Logistics Manager Interface) 및 NAD (New Appchain Development) 로부터의 입력을 수신하고, DPA (Deployment Patch Assembly)와 RAW (Raw Application Manipulation) 에 출력을 제공하는 L2I (Logistics Layer Interpretation)를 도시한다. 도 374 내지 도 375는 단계 6136에서 타겟 앱체인의 로지스틱스 레이어를 앱체인으로 변환하는 LIZARD 프로세스 를 나타낸다. 도 376은 로지스틱스 레이어 입력으로부터 RAM 프로세스를 도시한다. 도 377 내지 도 378은 LIZARD가 단계 662에서 로지스틱스 레이어의 실행 가능 논리 요소를 실행으로 변환하는 프로세스를 도시한다. 도 379 내지 도 380은 LIZARD가 단계 에서 로지스틱스 층의 정적 데이터 요소를 데이터로 변환하는 프로 세스를 도시한다. 도 381은 LLIZARD가 로지스틱스 레이어의 정적 데이터 요소를 데이터로 변환하는 단계 로부터 RAM 프로세 스 를 계속한다. 도 382는 단계 6172 실행 스트림은 MCE 에서 ESR 에 의해 처리됨 에 대한 시퀀스를 도시한다.. 도 383은 ESR의 예비 인스턴스가 잠재적 환경 범위를 발견하는 단계 를 도시한다. 도 383 내지 도 385는 단계 6210 LIZARD가 초기 렌더링 상태를 단계 6212 초기 렌더링 목적으로 변환하는 것을 나타낸다. 도 386~도 387은, 단계 6214 LIZARD가 최종 렌더링 상태를 단계 6216 최종 렌더링 목적으로 변환하는 것을 나타 낸다. 도 388 내지 도 402는 ESR의 예비 인스턴스가 CTMP 및 LOM 을 이용하여 잠재적 환경 범위를 발견하 는 단계 의 세부 사항을 도시한다. 도 403 및 도 404는 데이터 세그먼트 로부터 마킹된 데이터 세그먼트 로의 RAM DRP (617 6)에 대한 논리를 도시한다. I2GE 는 DRF 에 직접 입력을 제공하고, LIZARD 은 NMM C114를 통 해 DRF 에 입력을 제공한다. 도 405 ~도 407은 LIZARD가 실행 요구 또는 데이터 요구를 목적으로 변환하는 단계 6242에서의 LIZARD 에 대한 논리를 도시한다. 도 408은 DRF 를 갖는 RAM에 대한 논리를 도시한다. 도 409는 업그레이드 된 실행 스트림 A0 및 원본 실행 스트림 A0 을 갖는 DPA를 도시한다. 도 410은 ESC 및 업그레이드 된 실행 스트림 A0 를 갖는 실행 및 데이터 스트림 관리 (EDSM) 를 도시한다. 도 411 내지 도 412는 업그레이드 된 데이터 스트림 A0 및 오리지널 데이터 스트림 A0 을 갖는 DSDL 를 도시한다. 도 413 내지 도 416은 앱체인 수정 패치에 API을 통해서 패치 컨테이너의 모듈 출력을 제출하는 단 계 6348에서 끝나는 EDSL 프로세스를 개시하기 위해서 GENESIS 실행 세그먼트로부터 카운터 루프를 개시 하기 위해서 단계 6304에서 GENESIS 실행 세그먼트와 원본 실행 스트림 A0으로부터 카운터 루프를 개시하 기 위해서 단계 6302에서 업그레이드 된 실행 스트림 A0 을 수신하는 ESDL 을 도시한다 도 417 내지 도 418은 ESR을 도시한 도면이다. ESR 은 스트림 의 일반 실행에서 ESC 및 DSS 으로부터 입력을 수신하고 명령 타입 의 인식 및 참조를 제공 및 수신하면서 R2P 를 제공한다. 명령 타입 이 나열된다.도 418은 MEL과 실행 스트림 A0의 상호 작용을 도시한다. 도 419 및 도 420은 조건부 명령 참조 및 실행 시퀀스 를 갖는 명령 타입 을 도시한다. 도 421 내지 도 424는 명령 타입 에 기초한 MEL 실행 을 도시한다. 도 421은 단계 상속 된 명령 정의에서 지정된 앱체인의 렌더링 결과 상속을 갖는 명령 타입 에 기초한 MEL 실행 을 도시한다. 도 422는 지정된 앱체인 의 렌더링 결과를 상속하는 명령 타입 에 기초한 MEL 실행을 갖는 도 421로부터 계속된다. 데이터 스트림 A1 은 DSS에서 입력을 수신하고 MEL에 출력을 제공한 다. 도 423은 대체 앱체인에 평행한 스레드 실행을 계속함을 갖는 명령 타입 에 기초한 MEL 실행 을 도시한다. 도 424는 대체 앱체인에 스레드 실행을 전송함 명령 타입 에 기초한 MEL 실행 을 도시 한다. 도 425는 명령 타입 및 데이터 세그먼트 판독 를 갖는 데이터 스트림 A0 프로세싱을 도시 한다. 도 426은 명령 타입 및 세션 삭제 데이터 세그먼트 를 갖는 데이터 스트림 A0 프로세싱을 도시한다. 도 427은 명령 타입 및 세션 기록 데이터 세그먼트 를 갖는 데이터 스트림 A0 프로세싱을 도시한다. 도 428은 명령 타입 및 영구 삭제 데이터 세그먼트 를 갖는 데이터 스트림 A0 프로세싱을 도시한다. 도 429는 명령 타입 및 영구 기록 데이터 세그먼트 를 갖는 데이터 스트림 A0 프로세싱을 도시한다. 도 430은 타겟 앱체인으로부터 선택된 데이터 세그먼트를 무효화하는 널 세그먼트를 NCA에 제출하는 단계 에서 명령 타입 및 영구 삭제 데이터 세그먼트 에 기초한 NCA 프로세싱을 도시한다. 도 431은 ESR 과 렌더링된 결과 처리 (R2P) 프로세싱을 나타낸다. 여기에는 스트림의 일반 실행 이 포함된다. 도 432 내지 도 436은 DLS (도 436에 라벨없음)과 실행 이 될 때까지 다양한 단계를 거치는 타겟 앱 체인 과 ESC 을 도시한다. 도 437 내지 도 439는 타겟 앱체인 에 기초한 DSS 프로세스를 도시하며, 여기서 모든 4 개의 블록 이 단계 6816 해당 데이터 세그먼트에 데이터 참조 콜을 할당함에서 처리 될 때까지 타겟 앱체인 내의 각 블록을 처리한다. 도 440 내지 도 442는 새로운 정보의 갱신을 효율적으로 하려고 하는 모듈인 NSA을 도시한다. 6906 단계 의 NSA 는 실행 세그먼트 모음 (ESC 로부터) 또는 데이터 세그먼트 (DSS로부터) 중 하나를 받고 ISCR에 저장한다. 도 443 내지 도 445는 P2SP 7000 논리를 나타낸다. P2SP 7000 프로세스는 수신한 두 입력에 해당하는 대칭 처리 결과 를 생성한다. 입력 A , 목적 계층 맵 및 입력 B , 목적 계층 맵 . 도 446 및 도 447은 PRP이 수신한 2 개의 입력에 기초하여 목적 계층 맵 통합 (PHMU) 을 생성하는 데 사용되는 것을 도시한다. 입력 A , 목적 계층 맵 및 입력 B , 목적 계층 맵 . 도 448은 SRIA의 개관 해석을 나타내며, 이는 SPSI의 동작에 주로 나타나는 인공 지능에 관한 이론이다. 인공 지능의 최고점은 서로가 지능에서 성장할 수 있게 하는 세 가지 알고리즘 간의 삼중 관계이다. LIZARD 은 단계 5002에서 그 자신을 포함하여 코드 목적을 이해함으로 알고리즘의 소스 코드를 향상시킬 수 있다.I2GE 는 가상 프로그램 반복의 발생을 에뮬레이트 할 수 있으므로, 가장 강한 프로그램 버전을 선택할 수 있다. 따라서 이 에뮬레이션 기술은 SRIA 프로세스에 참여하는 다른 모든 모듈에 이익을 준다. BCHAIN은 복잡한 데이터가 많은 프로그램 (앱체인 )을 분산 된 방식으로 실행할 수 있는 무질서하게 연결된 노드 의 방대한 네트워크 110이다. SPSI 은 동일한 앱체인 을 유지하여 기능과 역량을 부여한다. 피드백 루프 기반 시스템의 레이아웃은 인공 지능 인식 및 문제 해결 역량이 점진적으로 향상될 수 있도록 한다. 따라서 SPSI 은 SRIA로 알려진 재귀 지능 성장 시스템의 핵심 요소가 된다. I2GE 는 가상 에뮬레이션 (500 0)을 LIZARD 및 BCHAIN 네트워크/프로토콜에 제공한다. 가상 에뮬레이션 은 I2GE (12 2)가 BCHAIN 네트워크에 의해 호스팅 되는 가상 환경에서 타겟 앱체인 의 코드를 실행할 때이다. 따 라서, BCHAIN 은 I2GE , LIZARD , LOM , CTMP , NC 및 I2CM 에 대한 호스팅 리소스 제공자 로 작동한다. BCHAIN 네트워크 은 다양한 지능형 시스템과 함께 적응 지능을 호스팅 하므로 지능 알고리즘을 실행하는 데 있어 보다 자유롭고 강렬하게 대응할 수 있으므로 결과적으로 BCHAIN 네트워크 / 프로토콜 의 작동에 이익을 리턴 하는 시스템에 효율성, 생산성 및 기능성이 존 재하는 것을 더 잘 이해하게 된다. 로그 집계 는 인간 관찰자가 SRIA의 성장 진행을 모니터 할 수 있게 발생한다. 도 449는 새로운 시스템 현상의 발견에 관한 SRIA의 이론을 나타낸다. 현상 5026은 일반적으로 타겟 시스 템의 전반적인 기능, 효율성 및 디자인을 나타낸다. LOM 은 DPIP (Design Principle Invocation Prompt) 에 의해 호출되어 단계 5014에서 시스템 디자인 원칙 를 생성한다. 이러한 원칙 은 LOM 가 수 행한 점진적인 연구 진행을 통해 생산되었으며 CKR 및 CTMP 에 의해 추가로 활성화된다. 그러므로 원칙 에 대한 변경, 추가 또는 삭제는 단계 5018의 현상 정교화(refinement)에 반영된다. 이러한 정교화 (refinement) 은 관련 데이터를 시스템 수정을 정확하게 수행하기 위한 결정적인 중간 단계로서 작용하는 목적 포맷으로 변환하는 LIZARD 에 의해 가능해진다. 이후 LIZARD 은 5020 단계에서 리파인된 현재 상황(refined Status Quo)에 대한 실험적인 수정을 수행하는 프로그래밍 기능을 사용한다. 이러한 수정은 기능, 효율성, 보안 및 안정성을 향상시키는 긍정적인 결과를 합리적으로 기대하면서 이루어진다. 그러나 그것이 알려 지지 않았고 실험적 상태이기 때문에, 새로운 현상은 단계 5022에서 I2GE 에 의해 가상화되고 진화되었다. 그러한 안정화 프로세스는 또한 단계 5018에서 LIZARD에 의해 이루어진 정제 수정(refinement modification)의 안정성을 확인한다. 따라서 단계 5024에서 새로운 현상이 형성되어 타겟 시스템이 가능한 모든 방식으로 업그레이드 되게 한다. 따라서 지능 주기가 재설정되고 관련 앱체인 알고리즘이 새로운 정보, 기능 및 기술을 발견 할 때 사용할 수 있게 되는 다음주기의 잠재력이 커진다. 도 450은 지능 풀링에 관한 SRIA의 이론을 보여준다. CTMP 는 단계 5032에서 알고리즘의 지능을 점차적으 로 빼앗기 때문에 지능 보유의 중심 위치로 작용한다. CTMP 1224는 LIZARD , LOM 및 I2GE 와 같은 앱체인 알고리즘에 의해 만들어진 인공 기반의 모든 결정을 해석하고 의사 결정과 관련하여 객관적인 사실 로 작용하는 미가공(raw) 처리 로그를 수신한다. 따라서 CTMP 는 다양한 앱체인 알고리즘에서 이전에 빼앗 긴 지능에 따라 앱체인 알고리즘의 결정을 비판한다. 따라서 여러 앱체인 알고리즘의 집계 지능은 단계 5028에서 재활용된다. 수집 / 풀링 된 정보는 결국 스테이지 5030에서 CTMP 와 상호 작용하는 모든 앱체인 알고리즘에 이익을 준다. 도 451은 하드웨어, 프레임 워크 및 기능 피드백 및 영향에 관한 SRIA의 이론을 도시한다. 이상적인 시스템 디 자인은 ATSG (Abstract Target System Generator) 에서 생성되며, 따라서 개념적 이상 시스템에 요구되 는 예상 사용자 기능 을 열거한다. 따라서, 요구 된 사용자 기능 은 신규 사용자 기능 의 정 의와 관련되어 있으며, 신규 사용자 기능 의 정의를 알린다. 기능의 구문 은 어플리케이션 기능 에 의해 상속되며, 어플리케이션 기능 은 신규 사용자 기능 에 대한 작동 가능화(operation enablement) 의 레이어가 된다. 어플리케이션 기능 향상의 추상적 개념은 실질적으로 SPSI의 130 서브 모듈인 새로운 앱체인 개발 (NAD) 에서 나타난다. SPSI 은 서로 상속하고 서로를 가능하게 하 는 서로 다른 로지스틱스 레이어의 SRIA 개념을 전반적으로 실제로 구현 한 것이다. 따라서 로지스틱스 레이어 텐션의 핵심 관행은 코드 효율성, 품질, 보안 및 안정성 향상이다. 이러한 프로세스 은 실질적으 로 SPSI에 의하여 그 서브모듈인 ASH (Appchain Security Hardening) , IEC (Intent Error Correction) , A2R (Automated Appchain Refinement) , A2M (Automated Appchain Maintenance) , ARC (Appchain Regulatory Compliance) 및 진단 로그 단위 분석 (DLUA) 을 통해 착수된 다. 향상된 코드 품질 은 어플리케이션 기능 의 동작 을 가능하게 하고, 이는 차례로 새로운 사용자 기능 을 가능하게 한다. 앞서 언급한 소프트웨어 측면은 프레임워크 적용에 의해서 가능해진다. 그러한 적응은 사용자 공간 어플리케이션(5046, 5044)이 동작 하도록 허용하는기본 프레임워크 (즉, 운영 시스템, 시스템 커널 등)에 수행된 변경을 나타낸다. 이러한 프레임워크 적용(505 0)은 실질적으로 SPSI의 향상된 프레임워크 개발 (EFD)에 의해 수행된다. 따라서 하드웨어 변경은 상속된 프레임워크 구문을 사용하여 수행되며, 이 구문은 프레임워크 와 그 사용자 공간 5046, 5044의 동작을 가능하게 한다. 하드웨어 변경 은 산업 제조 추세의 일반적인 주기로 인해 또는 SPSI의 EHD 을 통해 발생할 수 있다. 따라서 이 전체 레이어 스택은 ATSG 에 따라 필요한 사용자 기능 를 제공하는 이상적인 시스템이 되도록 시도하는 전반적인 기능 시스템을 나타낸다. 도 452는 다중 레이어 사이클을 통해 UBEC 사용자 (또는 레거시 운영을위한 일반 사용자 )의 상호 작용으로부터 지능 '트리클링(trickling)' 에 관한 SRIA의 이론을 도시한다. 장기 사이클 5062는 SPSI 방 향 5070의 대규모 지침 원칙을 나타낸다. 따라서 SPSI 의 기능, 방법론 및 경향은 LOM 및 SID (SPSI Indirect Development) 의 인간 106, 5068 상호 작용을 통해 느리고 장기적인 관점에서 점진적으 로 알려진다. LOM 는 CTMP 의 내장 된 모듈식 호출로 가능해지는 객관적인 추론으로 인해 SPSI 기능 및 작동 메이크업의 합리적인 디렉터 역할을 한다. 따라서, 장기주기에서 LOM 및 SID 를 통해 발생하는 변화는 결국 SPSI의 실질적인 지속 동작을 나타내는 중간주기에 영향을 미치고 알 려준다 . 그러므로 SPSI의 130의 모든 서브 모듈 8040, 8042, 8044, 8046, 8048, 8050, 8052, 8054, 8056은 점차 SPSI 방향 의 기본 원리에 의해 영향을 받는다. 이어서, 중기 사이클 5064 내의 SPSI (13 0)의 동작은 UBEC 플랫폼 / BCHAIN 네트워크 뿐만 아니라 레거시 시스템 내에서 작동하는 앱체인 / 레거시 프로그램 (앱체인 에뮬레이션 레이어(AEL)을 통해)에 존재하는 앱체인의 전반적인 향상으로 이어 진다. 그러므로 지능의 단기간 적응 사이클은 SPSI 에 의해 강화되어 단기간에 배치 됨으로써 정교 한 적응 전략을 가능하게 한다. 그러므로 BCHAIN 프로토콜 내에서 중요한 작업을 수행하는 전략 배포 916 유닛은 SPSI 의 작동과 LOM 및 SID 의 작동에 영향을 받는다. SPSI 은 Sector Crossing Event Processing (SCEP) 3360에 의해 트리거가 호출되면 전략 배포 916 유닛의 인스턴스를 차례로 생성하는 동 적 전략 적용Adaptation (DSA) 772 및 SCM (전략 생성 모듈) 984와 같은 BCHAIN 프로토콜 모듈을 향상시 킨다. 이러한 유닛은 BCHAIN 네트워크 의 동작 내의 단기주기 사이클 내에서 적응 지능을 수 행한다. 셀프 프로그래밍 셀프 혁신 (SPSI) 도 600 내지 도 603은 셀프 프로그래밍 셀프 혁신 (SPSI) 모듈의 핵심 기능의 개요를 도시한다. SPSI 은 LIZARD 기술을 사용하여 UBEC 플랫폼 내의 다른 앱체인 을 프로그래밍하는 앱체인 이다. SPSI 에 의한 이러한 프로그래밍에는 정제, 버그 / 오류 수정, 예정된 유지 보수, 진단 로그 유닛 분석, 새로운 기능 혁신 등이 포함된다. SPSI 은 자체 프로그래밍이 가능하지만 SID (SPSI Indirect Development) 에서 프로그래밍 지침을 받는다. 입증된 프로그래밍 / 엔지니어링 / 건축 기술을 보유한 승인된 UBEC 사용자 은 LUIGI 에서 프로그래밍 지침 및 코드 이론 개발에 SID (옵 션)으로 참여할 수 있다. 이로 인해 사람이 직접 액세스 할 필요 없이 SPSI 기능의 향상을 인간이 유도 할 수 있다. SPSI 은 기본 베이스 레이어 법으로 작용하는 영구적인 BCHAIN 프로토콜 에 따라 UBEC 플랫폼 의 모든 주요 기능의 코드베이스를 조작하기 위한 독점적인 액세스 권한을 부여 받는다. 중요한 예 는 UBEC 어플리케이션 자체 , LUIGI , 독창성 , 12GE , SPSI 자체 (자체 프로그래 밍), LOM (SPSI 을 작동시키는 기본 기술), LIZARD (SPSI 을 작동시키는 기본 기술) SPSI , CTMP , NMC 114, MC 1186 및 PCM 1188을 포함한다. SPSI 을 구성하는 전술한 앱체인 모 듈도 SPSI 에 의해 유지 관리된다. SPSI 은 앱체인 과 동일한 기능과 역량을 유지한다. 피드백 루프 기반 시스템의 레이아웃은 인공 지능인지 및 문제 해결 능력이 점차적으로 점진적 향상이 될 수 있도록 보 장한다. SPSI 은 재귀적 지능 성장 시스템의 핵심 요소가 된다. 도 448 - 452에 표시된 SRIA (Symbiotic Recursive Intelligence Advancement)는 인공 지능(Al)의 절정인데, 이는 서로를 지능 안에서 성장 가능하게 하는 세 가지 알고리즘 간의 삼중 관계이다 (LIZARD , 12GE , BCHAIN 110). LIZARD (지속적으 로 증가하는 프로그래밍 지능)은 자체를 포함하여 코드 목적을 이해함으로써 알고리즘의 소스 코드를 향상시킬 수 있다. I2GE (지속적으로 증가하는 에뮬레이션 지능)는 가상 프로그램 반복 생성을 에뮬레이션 할 수 있으므로 가장 강력한 프로그램 버전을 선택할 수 있다. BCHAIN 110 (지속적으로 증가하는 적응 지능)은 분산된 방식으로 복잡한 데이터가 많은 프로그램을 실행할 수 있는 무질서하게 연결된 노드의 방대한 네트워크이다. SPSI 의 핵심 추진력은 EGFE (Enjoin Good and Forbid Evil)하기 위한 지혜로 자동화 된 유익한 지식이나 지능을 창출하는 메커니즘을 갖추는 것이다. SPSI 은 목적 계층 맵으로 표시된 목적의 개념을 많이 다룬다. 목적 구조의 개념은 LIZARD 에서 유래되고, LIZARD 기능을 기반으로 하며 SPSI를 달성하기 위해 기능을 향상시킨다. 목적 구조는 본질적으로 모든 종류의 구문 뒤에 있는 정당성이다. 메트릭 Z가 있는 상 태 Y에서 유형 X와 같은 구문론적 정의를 상상해보자. 목적 정의는 다음과 같은 정당화 측면에 초점을 맞춘다:단계 L에서 메트릭 Z와 함께 유형 X가 필요하기 때문에 상태는 Y로 존재해야 한다. 목적은 NMM (Need Map Matching) (C42) 모듈을 참조하여 이해될 수 있으며, 이 모듈은 목적 모듈 C36에 따라 목적의 기본 조작자 인 LIZARD 에서 시작하여 작동한다. 따라서 LIZARD 은 SPSI 이 두 번째 계층으로 더 정교한 작업 을 수행하는 데 사용하는 셀프 프로그래밍의 기준이다. 따라서 SPSI는 LIZARD 에 대한 많은 참조를 하고 목적 포맷에 대한 연관성을 가지고 있다. P2SP 및 PRP와 같은 SPSI 내에서 동작하는 전용 모 듈은 목적 포맷을 해석하고 조작하기 위해 호출된다. 도 443 내지 도 447에 도시된 P2SP 및 PRP 는 BCHAIN 프로토콜 의 일부이다. 도 601은 SPSI 의 내부 동작에 관한 더 상세한 내용을 도시한다. LOM 은 진단 로그 유닛 을 그 것의 서브 모듈 (앱체인 으로서) 자동화 된 연구 메커니즘 (ARM) 으로부터 수신한다. ARM 은 진 단 로그 제출 (DLS) 으로부터 로그 유닛 을 수신한다. 로그 유닛 의 수신은 단계 로 이어지고; 여기서 LOM 는 현재 존재하는 기능으로 일상적인 오작동을 특징 지우고 이해하며 솔루션 8002를 제안한다. 현재 존재하는 기능은 프로그래밍 / 개선 / 혁신을 목표로 선택한 앱체인 의 기능이다. 따라서 단계 8000은 기존 피처 오작동에 대한 제안된 솔루션을 출력한다. 단계 8000에서 LOM 는 선택된 앱 체인 을 철저히 검사하고 주요 기능 수행에 있어서 앱체인 의 기능 및 효율성을 향상시킬 것으로 기 대되는 제안된 새로운 기능을 평가한다. 따라서 단계 8000은 제안된 새로운 기능 을 출력한다. 단계 8008 에서, 제안된 특징들 및 제안된 솔루션들은 의도적으로 정의되고, 목적 및 구문 모듈들을 통해 기 능 코드들로 프로그래밍되도록 LIZARD로 전달된다. 도 602는 도 601의 계속에 있어서의 SPSI의 내부 동작에 관한 더 상세한 내용을 나타낸다. 가능한 경우, LIZARD는 단계 8000과 8002에서 LOM에 의해 원래 생각 된 아이디어를 나타내는 실행 가능한 코드 세트를 단계 8012에서 출력한다. 그 후, 단계 4376 에서, 실행 가능 코드 세트 는 LIZARD 로부터 성공적인 실행 및 실패한 실행 시나리오 와 함께 12GE 로 전송된다. 그러한 시나리오 (8014, 8016)는 관련 코드 성공 또는 실패 의 실행에 대한 참조 프레임으로서 동작한다. 그 후 8020 단계에서 l2GE는 BCHAIN 네트워크 0에서 사용 가능한 CPU 및 저장장치 리소스를 사용하여 여러 진화 경로를 통해 소프트웨어를 발전시키고 조정한다 (창의성 를 통해 조정). 성공적인 8014 및 실패한 8016 실행 시나리오를 참조함으로써 l2GE 는 궁극적으로 안 정적이고 기능적이지 않은 코드 세트 8010와 그렇지 않은 것의 변형을 구별할 수 있다. 그 후, 단계 에서, LOM 은 결과 소프트웨어가 안정성의 인식 및 기능을 달성하는 수단에 부합 하는지를 검증한다. 따라서 LOM 는 결과 소프트웨어가 원래 제안 8004 및 8006과 일치하는지 검증한다. 도 603은 도 601의 대체 시나리오로서, LOM 과 LIZARD 모두 진단 로그 유닛 을 자신의 서브 모듈 (앱체인 ) 인 ARM 로부터 수신한다. ARM 은 진단 로그 제출 (DLS) 으로부터 로그 유닛 을 수신한다. LOM 는 현재 기존 기능으로 일상적인 오작동을 특징 지우고 이해하며 해결 방법 를 제안한다. LIZARD는 기술 오류 / 버그 / 충돌 및 리조트를 반복 모듈 을 사용하여 수정하는 것 을 특징 짓고 이해한다. 도 604는 커스텀 체인 에코 시스템 내에서 상호 작용하는 공식 앱체인 를 도시한다. SPSI 은 동작을 위해 LOM , LIZARD , 및 I2GE 에 의존한다. 창의성 는 CTMP 및 LOM 를 보완하고, CTMP 는 LOM 를 보완한다. 그러므로 앱체인 은 UBEC 플랫폼 100 내에서 자신의 정체 성과 관할권을 유지하면서 서로 의존 할 수 있다. 도 605는 SPSI 내에서 동작하는 다양한 서브 모듈의 개요를 도시한다. 자동화 된 앱체인 리파인 (Refinement) (A2R) 은 앱체인 및 레거시 프로그램을 검사하여 루틴의 효율성을 향상시키고 가용성 및 안정성을 향상시킨다. A2M 는 만료 된 캐시 를 삭제하고, 감가 상각 된 함수 8726을 사용 가능 한 함수로 업그레이드하고, 감가 상각 된 모듈 및 종속성 을 사용 가능한 모듈로 업그레이드하고, 만료 된 참조점 (누락 된 내용 등)을 삭제하여 선택된 앱체인 또는 레거시 프로그램을 유지 관리하고, 경 제적 안정도 보정을 수행한다. 앱체인 ASH는 앱체인 또는 레거시 프로그램에서 침입 및 악용 지점을 자동으로 검사한다. ARC 은 선택된 앱체인 또는 레거시 프로그램이 다양한 특정 규정 (예: REST API 준수 등)을 준수하도록 보장한다. DLUA 은 오작동하는 루틴에서 진단 로그 단위 (DLU)를 수신하 고 이러한 인식된 오작동 수정을 시도하기 위한 적절한 조항을 시행한다. 본질적 오류 수정 (IEC) 8050은 중단 된 루틴으로 이어질 수 있는 근본적인 절차 결함을 수정하려고 시도한다. 새로운 앱체인 개발(NAD) 는 잠 재 어플리케이션 기능이 없는 특정 어플리케이션 생태계 (예: UBEC 플랫폼 ) 내의 어플리케이션에 대한 사 용을 찾으며, 이는 그러한 생태계에 잠재적으로 이익이 된다. 향상된 프레임 워크 개발 (EFD)는 UBEC 플 랫폼 / BCHAIN 네트워크 및 레거시 시스템 모두에 대한 기존 소프트웨어 프레임 워크 (예: 프로그래밍 언어)를 검사하고 잠재적으로 향상시킨다. EHD (Enhanced Hardware Development) 8056은 DLCB (Dynamic Liquid Conductive Boards) 8856을 포함하는 실제 시스템을 수정하므로 핵심 하드웨어 구조를 최적화하고 업그 레이드 할 수 있다. 지능형 선택 알고리즘을 처리하는 앱체인 타케팅 매커니즘 (ATM) 은 처리 중에 선택 할 앱체인 을 다른 모듈에 알려준다. ATM 은 A2R , A2M , ASH , ARC , DLUA 및 IEC 모듈에 알린다. 다른 모듈은 논리가 ATM 과 다른 고유 선천 선택 메커니즘을 가지고 있다. 도 606-609는 SPSI 의 특정 서브모듈 (모듈 A2R , A2M , ASH , ARC , DLUA , 및 IEC )에 대한 처리를 위해 관련 앱체인을 지능적으로 선택하는 SPSI 의 서브모듈인 앱체인 타게팅 메커니즘의 작동과 기능을 도시한다. 도 606은 단계 8064에서의 앱체인 타게팅 메커니즘 (ATM) 을 나타내며, 이는 ATM 의 이 인스턴스가 앱체인 에뮬레이션 레이어(AEL) 또는 타겟 앱체인 의 마이닝 노드 내에서 실행되는지를 결정한다. 단계 8070에서의 AEL 인 경우, 레거시 관리로부터의 동작 수신 설정 을 갖는 루틴 (A) 실행 을따르고 모듈러로서 앱체인을 목표 앱체인 에 제출한다. 그리고 단계 8072에서의 마이닝 노드 인 경우, 실행 루틴 B 을 해결된 작업 새로운 블록 공표 와 함께 실행하고, 모듈러로 서 앱체인을 목표 앱체인 에 제출한다. 도 607은 실행 루틴 A 내의 ATM 동작을 나타낸다. 8090 단계에서 레거시 관리 에서 동작 선호도를 받는다. 동작 선호도 유형는 오프모드, 수동모드 및 자동모드을 포함 한다. 꺼짐 모드의 경우 더 이상의 조치가 취해지지 않으므로 SPSI 는 8100 단계에서 레거시 관리 에 의해 동작 선호도 변경이 이루어질 때까지 휴면 상태가 된다. 수동모드의 경우, 레거시 관리에서 앱체인 / 레거시 프로그램의 수동 목록을 검색한다. 자동모드의 경우 8104 단계에서 앱체 인 / 레거시 프로그램이 자동 프로그램 선택(APS) 으로 위임된다. 도 608은 단계 에서 실행 루틴 (A) 내에서 도 607의 ATM (앱체인 Targting Mechanism) 에 대한 논리를 계속하여 레거시 관리 로부터의 앱체인 / 레거시 프로그램의 수동 목록 을 검색한다. 단계 8110에서, 루프는 활성 프로그램 리스트에 대해 위임된다. 8112 단계에서 앱체인 / 레거시 프로그램은 자 동 프로그램 리스트 내의 자동 프로그램 선택(APS)로 위임된다. 단계 8118에서, 선택된 프로그램 은 SPSI 프로세싱 을 위해 타겟 앱체인 에 모듈 출력으로서 제출된다. SPSI 프로세싱이 완료되면 루프에서 다음으로 사용 가능한 프로그램이 8120 단계에서 실행된다. 도 609는 타겟 앱체인 의 마이닝 노드 내의 실행 루팅 B 에 대한 앱체인 타게팅 매커니즘 (ATM) 동작을 도시한다. 8124 단계에서 ATM 의 모듈식 호출이 지정된 앱체인의 채굴자에서 발생하므로 SPSI 함수는 8126 단계에서 해당 노드를 채굴하는 마이닝 노드의 앱체인을 조작하기 위해 수행된다. 해결 된 작업 새 블록 공고는 8128 단계에서 앱체인의 ID를 추출한다. 8130 단계에서 앱체인 업데이트와 메타 체인에서 앱체인 ID를 확인한다. 확인됨인 경우 로컬 메타체인에서 전체 앱체인을 검색하고 앱체인 을 모듈로 타겟 앱체인에 제출한다. 미확인인 경우 공식 시스템 토큰이 있는 DLU를 DLS 1160에 제출한다. 도 610 내지 도 616은 자동화 된 앱체인 리파인 (Refinement) (A2R) 를 도시한다. 도 610은 단계 8138에 서 LIZARD 가 구문 모듈을 통해 타겟 앱체인 의 구문을 해석하는 자동화 된 앱체인 리파인 (Refinement) (A2R) 를 도시한다. 단계 에서, LIZARD 는 목적 모듈을 통해 타겟 앱체인 의 목적 계층 맵을 생성한다. 8144 단계는 중앙 지식 보유 (CKR) 에서 더 큰 효율성을 산출하 는 확립 된 코드 디자인 원칙을 추출한다. LIZARD은 8148 단계에서 코드 디자인 원칙 의 목적 레이어 구조 맵 을 생성한다. 도 611은 ATM에 의해 선택된 타겟 앱체인의 실행 스트림을 목적 계층 맵으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 실행 스트림 콜렉션 (ESC) 에 의해 생성 된 타겟 앱체인 의 실행 스트림 은 외부 핵심 (OC) (C329)의 관할에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성; 목적 모듈 (PM) C36에서 복합 목 적 형식(C325)을 수신한다. 복합 목적 형식(C325)는 '의사 코드'라고도 하는 임의 코드 구문으로 작성된다. 의 사 코드는 if / else 문, while 루프 등 모든 프로그래밍 언어에서 가장 일반적인 계산 연산의 기본 구현을 포 함한다. 그 후 헬퍼 함수는 의사 코드를 원하는 목표 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한 다. 코드 읽기; SM C35는 이러한 코드의 기능을 위한 목적을 도출하기 위해 PM C36에 대한 컴퓨터 코드의 구문해석을 제공한다. 타겟 앱체인 은 코드 번역(C321)에 의해 이행된 실행 스트림 포맷으로 수신된다. 코드 번역(C321)은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역(C321)은 또한 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수를 수행한다. 코드 번역 (C321)의 완료된 실행 결과는 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323은 코드 논리를 단순한 폼으 로 감소시켜 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수의 맵을 생성한다. 그러므로 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 출력이 목적 모듈 (PM) C36의 반복 해 석 C328에 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이 러한 목적 정의는 SM C35가 해석 한 관련 코드 섹션의 의도 된 기능을 적절히 설명한다. PM C36은 또한 데이터 내에 비밀리에 잠긴 코드 조각 (이진 / ASCII 등)을 감지 할 수 있다. 반복 해석 C328은 모든 상호 연결된 함수 를 반복하여 목적 연관성 C326을 참조하여 해석된 목적 정의 (복합 목적 형식 C325에서)를 생성한다. 내부 핵심 (IC) C333은 자동 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래 밍 한 LIZARD의 영역이다. IC C333의 핵심 코드 C335 요소에는 기본 프레임워크 및 라이브러리, 스레드 관 리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코 드 C335는 기본 기능을 사용할 수 있도록 표준화 된 라이브러리 및 스크립트를 제공함으로써 SM C35 및 PM C36 에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표 를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한 다. 도 612는 도 611로부터의 논리 흐름을 계속하여 타겟 앱체인을 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 목적 연관성C326을 참조하여 상호 연결된 모든 함수를 반복하여 해 석된 목적 정의를 생성한다. 목적 정의 출력은 PM C36, 즉 외부 핵심 (OC) C329, 따라서 LIZARD에 대한 모 듈 출력으로 제출 된 복합 용도 형식 C325에 있다. 출력은 타겟 앱체인 의 복합 목적 형식 (Complex Purpose Format) C325 버전으로서 제공되는 목적 계층 맵 으로 라벨링 된다. 동일한 정의와 내부 핵심 (IC) C333의 어플리케이션이 앞서 언급한 기능 및 모듈에 적용된다. 도 613은 중앙 지식 보유 (CKR) 로부터 생성 된 코드 디자인 원칙 를 목적 계층 맵 으로 변환 하기 위한 LIZARD 의 동작에 관한 세부 사항을 도시한다. 코드 디자인 원칙 은 외부 핵심 (OC) C329 의 관할권에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓰는 프레임 워크를 제공한 다. 코드 작성을 위해; 목적 모듈 (PM) C36에서 복합 목적 형식 C325를 수신한다. 복합 목적 형식 C325는 '의사 코드'라고도 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if / else 문, while 루프 등과 같은 모든 프 로그래밍 언어에서 가장 일반적인 계산 작업의 기본 구현이 포함되어 있다. 그런 다음 헬퍼 함수는 의사 코드를 원하는 대상 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 판독을 위해; SM C35는 PM C36 의 컴퓨터 코드에 대한 구문 해석을 제공하여 이러한 코드의 기능성에 대한 목적을 도출한다. 타겟 앱체인 은 코드 번역 C321에 의해 주요 구문 8147 형식으로 수신된다. 코드 번역 C321은 SM C35에서 인식되고 이 해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역 C321은 알려진 계산 언어를 임의 의 구문 유형으로 변환하는 역함수도 수행한다. 코드 번역 C321의 완료된 실행 결과는 논리 감소 C323에 입력으 로 전송된다. 논리 감소 C323은 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 보다 간단한 형식으로 줄이다. 따라서 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행 이 완료되고 SM C35의 모듈 식 출력이 목적 모듈 (PM) C36의 반복 해석 C328로 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35에 의해 해석되 는 관련 코드 섹션의 의도 된 기능을 적절히 설명한다. PM C36은 또한 데이터 (이진 / ASCII 등)에 은밀히 잠긴 코드 조각을 탐지 할 수 있다. 반복 해석 C328은 목적 연관성 C326을 참조하여 해석된 목적 정의를 생성하기 위 해 상호 연결된 모든 기능을 반복한다 (복합 목적 형식 C325에서). 내부 핵심 (IC) C333은 자동화 된 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍하는 LIZARD 의 영역 이다. IC C333의 핵심 코드 C335 요소에는 기본 프레임 워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스 크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 가 능하게 하는 표준화 된 라이브러리 및 스크립트를 제공하여 SM C35 및 PM C36에 대한 일반 작업 및 기능을 가능 하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내에서 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 614는 코드 디자인 원칙 를 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명하기 위해 도 613으로부터의 논리 흐름을 계속한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 모든 상호 연결된 기능을 반복하여 목적 연관성 C326을 참조하여 해석 된 목적 정의를 생성한다. 목적 정의 출력은 복합 목적 형식 C325로 존재하며 PM C36에 대한 모 듈 식 출력으로 제출되므로 외부 핵심 (OC) C329, 따라서 LIZARD 으로 제출된다. 출력물은 목적 계층 맵 으로 표시되며, 코드 디자인 원칙 의 복합 목적 형식 C325 버전으로 표시된다. 내부 핵심 (IC) C333의 동일한 정의 및 적용은 전술 한 기능 및 모듈에 적용된다. 도 615의 자동화 된 앱체인 리파인 (Refinement) (A2R) 는 앱체인 및 레거시 프로그램을 검사하여 루틴의 효율을 향상시키고 사용성 및 신뢰성을 향상시킨다. 목적 계층 맵 및 목적 계층 맵 8142내의 코 드 디자인 원칙 및 실행 스트림 컬렉션 (ESC) 6700은 각각 P2SP 7000에 제출된다. 대칭 처리 결과 8152 는 단계 8154에서 타겟 앱체인의 코드 목적이 코드 디자인 원칙과 일치 하는지를 판단하고, 예인 경우 8156과 일치하면 수정이 필요하지 않으며 모듈 실행이 종료된다. 그러나 8158과 일치하지 않으면 타겟 앱체인 의 목적 계층 맵이 업그레이드 된 목적 맵 를 생성하는 마스터 / 슬레이브 어피니티(affinity) 1480 및 PRP 7050에 제출된 결과와 디자인 원칙 의 맵과 일치하도록 조정된다. 도 616은 업그레이드 된 목적 맵을 앱체인 구문으로 변환하기 위한 LIZARD 의 동작을 설명하기 위해 도 615로부터의 논리 흐름을 계속한다. 업그레이드 된 앱체인 는 DPA (Deployment Patch Assembly) 6260 에 제출되어 앱체인 수정 경로를 생성한다. 앱체인 수정 경로 은 커스텀체인 생태계 빌더(CEB) 에 배포되어 타겟 앱체인 을 조작하여 컨텐츠를 업그레이드 된 앱체인 로 변환한다. 도 617은 업그레이드 된 목적 맵 을 업그레이드 된 앱체인 으로 변환하기 위한 LIZARD 의 동 작에 관한 세부 사항을 도시한다 (도 # 618에서 완료된 것으로 도시 됨). 지시 목적 수집 9462는 복합 목적 형 식 C325으로 존재하며 LIZARD 의 외부 핵심 (OC) C329 내에서 목적 모듈 C36의 반복 확장 C327에 제출된 다. 반복 확장 C327은 세부 목표와 복잡성을 추가하여 간단한 목표 (목적 대체 내에 간접적으로 정의 됨)를 특정 복잡한 목적 정의로 발전시킨다. 그러므로 구문 모듈 (SM) C35의 논리 유도 C320에 제출되기 전에 입력의 최대 목적 연관성 C326 가능성이 실현되어 복합 목적 형식 C325으로 유지된다. 내부 핵심 (IC) C333의 핵심 코드 C335 요소에는 기본 프레임 워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암 호화 프로토콜 및 메모리 관리 시스템이 포함되어 있다. 따라서 핵심 코드 C335는 기본 기능을 가능하게 하는 표준화 된 라이브러리 및 스크립트를 제공하여 SM C35 및 PM C36에 대한 일반 작업 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동 하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 618은 업그레이드된 목적 맵 (도 617에 도시 됨)을 업그레이드 된 앱체인 으로 변환하기 위한 LIZARD 의 동작을 설명하기 위해 도 617로부터의 논리 흐름을 계속한다. 입력 데이터는 PM (Purpose Module) C36에서 복합 목적 형식 C325로 수신되고 SM (Syntax Module) C35의 논리 유도 C320으로 전송된다. 논 리 유도 C320은 초기 단순한 함수에서 논리적으로 필요한 함수를 유도한다. 즉, 함수가 단순한 부모 함수의 암 시로 인해 파생 함수로 형성 될 수 있는 경우; 논리 파생 C320에 의해 형성된다. 생성된 결과는 정의된 복합 목 적 형식 C325 데이터에 따라 작성된 함수 종속성 트리이다. 논리 도출 C320은 내부 핵심 (IC) C333의 핵심 코드 C335 요소에서 상속 된 규칙 및 구문 C322 정의에 따라 작동한다. 논리 도출 C320는 출력을 코드 번역 C321에 제출한다. 코드 번역 C321은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역 C321은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수도 수행한다. 따라서 PM C36은 SM C35를 호출하여 코드 번역 C321을 통해 입력 업그레이드 된 목적 맵 의 결과적 앱체인 구문 버 전을 생성한다. 코드 번역 C321에서 마지막으로 생성되는 결과적 업그레이드 된 앱체인 는 SM C35, 외부 핵심 (OC) C329 및 LIZARD 의 모듈식 출력이다. 도 619 내지 652는 중지된 루틴으로 이어질 수 있는 기본 절차 결함을 수정하려고 시도하는 SPSI (Self Programming Self Innovation) 130의 서브모듈 인 IEC (Innate Error Correction) 8050의 작동 및 기능을 보여준다. 도 619는 SPSI 의 서브모듈인 IEC (Innate Error Correction) 8050의 동작 및 기능을 도시한다. ATM (Appchain Targeting Mechanism) 8038은 지정된 타겟 앱체인 을 선택한 다음 호출 된 ESC (Execution Stream Collection) 인스턴스에 모듈 식 입력으로 제출된다. ESC 인스턴스에서 모듈 식 출력으 로 생성 된 실행 스트림은 IEC 의 스테이지 에 모듈 식 입력으로 제출된다. 단계 8170은 코드 구조 청사진 을 생성하기 위해 앱체인 의 실행 스트림을 분리한다. 단계 8174에서, 코드 구조 청사진 내에 존재하는 각각의 선택된 코드 유닛 은 프로그래밍 루프를 통해 순환된다. 따라서, 단계 8178 에서, LIZARD 는 호출되어 선택된 코드 유닛으로부터 목적 계층 맵 을 생성한다. 단계 8176에서, LIZARD 는 전체 코드 구조 청사진 의 목적 계층 맵 을 생성하도록 호출된다. 따라서 목적 계층 맵 및 8182는 모두 목적 대칭 처리 (P2SP) 모듈에 모듈 식 입력으로 제출된다. P2SP의 7000 처리가 완료되면 대칭 처리 결과 가 모듈 식 출력으로 생성된다. 그러므로 단계 8186은 대칭 처리 결과 를 해석하여 내부 일관성을 수행하여 각각의 선택된 코드 유닛의 목적 계층 맵 이 전체 코드 구조 청사진 의 더 큰 목적 (목적 계층 맵 )과 일치 하는지를 평가함으로써 내부 일관성을 수행한다. 도 620은 선택된 코드 유닛 을 (도 621에 도시 된) 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작에 관한 세부 사항을 도시한다. 선택된 코드 유닛 은 외부 핵심(OC) C329의 관할권에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓰는 프레임 워크를 제공한다. 코드 작성을 위해; 목적 모듈 (PM) C36에서 복합 목적 형식 C325를 수신한다. 복합 목적 형식 C325는 '의사 코드'라고도 하 는 임의의 코드 구문으로 작성된다. 의사 코드에는 if / else 문, while 루프 등과 같은 모든 프로그래밍 언어 에서 가장 일반적인 계산 작업의 기본 구현이 포함되어 있다. 그런 다음 헬퍼 함수는 의사 코드를 원하는 대상 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 판독을 위해; SM C35는 PM C36의 컴퓨터 코 드에 대한 구문 적 해석을 제공하여 이러한 코드의 기능성에 대한 목적을 도출한다. 선택된 코드 유닛 은 코드 번역 C321에 의해 이행 된 실행 스트림 889 형식으로 수신된다. 코드 번역 C321은 SM C35에서 인식되고 이 해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역 C321은 알려진 계산 언어를 임의 의 구문 유형으로 변환하는 역함수도 수행한다. 코드 번역 C321의 완료된 실행 출력은 논리 감소 C323에 입력으 로 전송된다. 논리 감소 C323은 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 보다 간단한 형식으로 줄이다. 따라서 논리적 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실 행이 완료되고 SM C35의 모듈 식 출력이 목적 모듈 (PM) C36의 반복 해석 C328로 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35에 의해 해석되 는 관련 코드 섹션의 의도 된 기능을 적절히 설명한다. PM C36은 데이터 (이진 / ASCI I 등)에 은밀히 잠긴 코 드 조각도 감지 할 수 있다. 반복 해석 C328은 목적 연관성 C326을 참조하여 해석 된 목적 정의를 생성하기 위 해 상호 연결된 모든 기능을 반복한다 (복합 목적 형식 C325에서). 내부 핵심 (IC) C333은 자동화 된 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍하는 LIZARD 의 영역 이다. IC C333의 핵심 코드 C335 요소에는 기본 프레임 워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스 크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 가 능하게 하는 표준화 된 라이브러리 및 스크립트를 제공하여 SM C35 및 PM C36에 대한 일반 작업 및 기능을 가능 하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 622은 코드 구조 청사진을 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작에 관한 세부 사항을 도시한다. 코드 구조 청사진은 외부 핵심(OC) C329의 관할권에 속하는 구문 모듈 (SM) C35에 제출 된다. SM C35는 컴퓨터 코드를 읽고 쓰는 프레임 워크를 제공한다. 코드 작성을 위해; 목적 모듈 (PM) C36에서 복합 목적 형식 C325를 수신한다. 복합 목적 형식 C325는 '의사 코드'라고도 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if / else 문, while 루프 등과 같은 모든 프로그래밍 언어에서 가장 일반적인 계산 작업의 기본 구현이 포함되어 있다. 그런 다음 헬퍼 함수는 의사 코드를 원하는 대상 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 판독을 위해; SM C35는 PM C36의 컴퓨터 코드에 대한 구문 적 해석을 제공하 여 이러한 코드의 기능성에 대한 목적을 도출한다. 코드 구조 청사진은 코드 번역 C321에 의해 복수의 실 행 스트림 형식으로 수신된다. 코드 번역 C321은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역 C321은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역 함수도 수행한다. 코드 번역 C321의 완료된 실행 출력은 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323 은 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 보다 간단한 형식으로 줄이다. 따라서 논리적 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 식 출력이 목적 모듈 (PM) C36의 반복 해석 C328로 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복 합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35에 의해 해석되는 관련 코드 섹션의 의도 된 기능을 적절히 설명한다. PM C36은 데이터 (이진 / ASCI I 등)에 은밀히 잠긴 코드 조각도 감지 할 수 있다. 반 복 해석 C328은 목적 연관성 C326을 참조하여 해석 된 목적 정의를 생성하기 위해 상호 연결된 모든 기능을 반 복한다 (복합 목적 형식 C325에서). 내부 핵심 (IC) C333은 자동화 된 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍하는 LIZARD 의 영역이다. IC C333의 핵심 코드 C335 요소에는 기본 프레임 워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프 로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 가능하게 하는 표준화 된 라 이브러리 및 스크립트를 제공하여 SM C35 및 PM C36에 대한 일반 작업 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 623는 코드 구조 청사진를 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명하기 위해 도 622으로부터의 논리 흐름을 계속한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 모든 상호 연결된 기능을 반복하여 목적 연관성 C326을 참조하여 해석 된 목적 정의를 생성한다. 목적 정의 출력은 복합 목적 형식 C325로 존재하며 PM C36에 대한 모 듈 식 출력으로 제출되므로 외부 핵심 (OC) C329, 따라서 LIZARD 으로 제출된다. 출력물은 목적 계층 맵 으로 표시되며, 코드 구조 청사진의 복합 목적 형식 C325 버전으로 표시된다. 내부 핵심 (IC) C333 의 동일한 정의 및 적용은 전술 한 기능 및 모듈에 적용된다. 도 624는 IEC (Innate Error Correction) 8050으로부터 단계 8170의 동작 세부 사항을 확장한다. 단계 는 타겟 앱체인 의 실행 스트림 을 분리한다. 따라서 ESC (실행 스트림 모음)가 IEC 의 단계 8170에 모듈식 입력으로 실행 스트림 을 제출하면 스트림 이 모듈식 입력으로 단계 8190으로 제출된 다. 8190 단계는 실행 스트림 렌더링 6400을 호출하여 보충 앱체인 의 모든 관련 종속성을 해석하고 빌드 하여 이행 된 실행 스트림 를 생성한다. 스트림 는 이행된 실행 스트림 /556의 각 이행된 실 행 세그먼트 을 반복하는 단계 8194에 모듈식 입력으로 제출된다. 도 625는 IEC 의 단계 8170의 논리 흐름을 계속한다. 이행된 실행 스트림 은 단계 8194에 모듈러 입력으로서 제출되며, 단계 8194는 도 624의 루프를 시작한다. 단계 8196에서, 선택된 이행된 실행 세그먼트 는 격리되고 메타 데이터로 유지되는 동안 이행된 실행 스트림 내에서 관계 컨텍스트를 유지하면서 코드 유닛 버퍼 풀 (CUBP) 8198에 저장된다. 프롬프트는 단계에서 시작된 처리되지 않은 이행된 실 행 세그먼트 가 루프에 남아있는지 해석한다. 프롬프트 에 대한 응답이 예 이면, 단계 8206이 활성화되어 단계 8194에서 다음 사용 가능한 이행된 실행 세그먼트 로 루프가 진행된다. 프롬프트 에 대한 응답이 No 이면 단계 8200이 활성화되어 LIZARD 을 호출하여 CUBP 8198의 전체 내용을 목 적 계층 맵 으로 커버한다. 도 626은 코드 유닛 버퍼 풀 (CUBP) 을 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작에 관한 세부 사항을 도시한다. CUBP은 외부 핵심 (OC) C329의 관할권에 속하는 구문 모듈 (SM) C35에 제출 된다. SM C35는 컴퓨터 코드를 읽고 쓰는 프레임 워크를 제공한다. 코드 작성을 위해; 목적 모듈 (PM) C36에서 복합 목적 형식 C325를 수신한다. 복합 목적 형식 C325는 '의사 코드'라고도 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if / else 문, while 루프 등과 같은 모든 프로그래밍 언어에서 가장 일반적인 계산 작업의 기본 구현이 포함되어 있다. 그런 다음 헬퍼 함수는 의사 코드를 원하는 대상 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 판독을 위해; SM C35는 PM C36의 컴퓨터 코드에 대한 구문 해석을 제공하여 이러한 코드의 기능성에 대한 목적을 도출한다. CUBP은 코드 번역 C321에 의해 실행 세그먼트 형식 으로 수신된다. 코드 번역 C321은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의의 계산 언 어로 변환한다. 코드 번역 C321은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수도 수행한다. 코드 번역 C321의 완료된 실행 결과는 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323은 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 보다 간단한 형식으로 줄이다. 따라서 논리 감 소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 식 출력이 목적 모듈 (PM) C36의 반복 해석 C328로 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35에 의해 해석되는 관련 코드 섹션의 의도 된 기능을 적절히 설명한다. PM C36은 또한 데이터 (이진 / ASCII 등)에 은밀히 잠긴 코드 조각을 탐지 할 수 있다. 반복 해석 C328은 목적 연 관성 C326을 참조하여 해석된 목적 정의를 생성하기 위해 상호 연결된 모든 기능을 반복한다 (복합 목적 형식 C325에서). 내부 핵심 (IC) C333은 자동화 된 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가 가 직접 독점적으로 프로그래밍하는 LIZARD 의 영역이다. IC C333의 핵심 코드 C335 요소에는 기본 프레임 워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스 템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 가능하게 하는 표준화 된 라이브러리 및 스크립트를 제공 하여 SM C35 및 PM C36에 대한 일반 작업 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내에서 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 627은 는 CUBP 를 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명하기 위해 도 626으로부터의 논리 흐름을 계속한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의 반복 해석C328에 출력을 제출한다. 반복 해석 C328은 모든 상호 연결된 기능을 반복하여 목적 연관성 C326을 참조하여 해 석 된 목적 정의를 생성한다. 목적 정의 출력은 복합 목적 형식 C325로 존재하며 PM C36에 대한 모듈식 출력으 로 제출되므로 외부 핵심 (OC) C329, 따라서 LIZARD 으로 제출된다. 출력물은 목적 계층 맵 으로 표 시되며, CUBP 의 복합 목적 형식 C325 버전으로 표시된다. 내부 핵심 (IC) C333의 동일한 정의 및 적용은 전술 한 기능 및 모듈에 적용된다. 도 628은 IEC (Innate Error Correction) 의 논리 흐름을 계속한다. CUBP (Code Unit Buffer Pool) 은 단계 8212에서 (각 잠재적인 코드 유닛의) 루프에서 처리된다. 전체 코드 유닛 버퍼 풀 (CUBP) 의 목적 계층 맵 및 선택된 코드 유닛의 및 목적 계층 맵 은 P2SP에 제출되어 대칭 처 리 결과을 생성한다. 8218 단계는 내부 일관성 검사를 수행하여 선택된 코드 유닛의 8188 목적 계층 맵 4가 CUBP 8189에 포함 된 전체 코드 구조의 더 큰 목적 (목적 계층 맵 )과 정렬되는지 평가한다. 따 라서 8220 단계에서 CUBP 8198의 전체 코드 구조와 일치하는 목적을 갖지 않는 정렬되지 않은 코드 단위 (818 8)에 플래그가 지정된다. 따라서 단계 8220은 모듈식 출력을 MUPR (Misaligned Code Unit Purpose Retention) 에 제출한다. 단계 8224에서, 각각의 잘못 정렬 된 코드 유닛 목적은 코드 구조 청사진 의 목적 계 층 맵 를 따르는 각 유닛에 적합한 목적을 도출하기 위해 새로운 루프에서 반복된다. 8224 단계에서 적절 한 목적을 도출하는 프로세스는 SPR (Suitable Purpose Replacement) 에 의해 처리된다. 도 629는 IEC 의 단계 8218 및 8220에 관한 동작 세부 사항에 대해 상세히 설명한다. 해당 P2SP 인스턴스의 모듈 출력은 대칭 처리 결과 이다. 결과는 대칭 처리 결과 검증 (SPRV) 모듈의 8288 단계로 모듈러 입력으로 제출된다. 단계 8228은 대칭 처리 결과 에 저장된 각 정렬 통합 감지 (AID) 인스턴스 (P2SP 7000 내부 로직에서 생성됨) 결과를 분리한다. 그 후, 단계 8230은 각각의 AID 인스턴스 결과에 대한 루프를 호출한다. 루프 프롬프트 내에서는 선택한 AID 결과가 대칭 처리 결과 8232에 따라 잘못 정렬 된 것으로 간주되는지 해석한다. 프롬프트 에 대한 응답이 잘못 정렬되지 않 았다 이면 단계 가 활성화되어 루프를 다음 AID 결과로 진행시킨다. 프롬프트 에 대한 응답 이 예, 잘못 정렬 되었다이면 단계 가 활성화되어 선택된 AID 결과를 SPRV 에 대한 모듈 출력으로서 코드 유닛으로서 출력한다. 이러한 출력은 단계 8222로 제출되어 잘못 정렬 된 코드 유닛을 잘 못 정렬 된 코드 유닛 목적 보유 (MCUPR) 에 저장함으로써 플래그 유닛을 플래그한다. 따라서 PSRV 8226 모듈의 실행은 대칭 처리 결과 을 검증하여 잘못 정렬 된 코드 단위를 플래그 한다. 도 630은 단계 8224로부터의 IEC 의 논리 흐름을 계속한다. 8224 단계는 각 잘못 정렬 된 코드 단위 목적 을 반복하며 코드 구조 계획 의 목적 계층 맵 를 준수하는 SPR (적합한 목적 교체) 를 호출 하여 적합한 목적을 도출한다. 단계 8240에서, LIZARD는 대응하는 SPR 인스턴스에 의해 생성된 목적 대체를 실행 세그먼트로 변환하도록 호출된다. 이로 인해 단계 8242가 활성화되어 각 구문 교체 유닛이 코 드 구조 청사진의 관련 위치와 연관된다. 그 후 단계 8244에서 배포 패치 어셈블리 (DPA) 모듈의 호출을 통해 배포 패치 6270이 생성된다. 이러한 패치 에는 구문 대체 유닛 및 원래 앱체인 의 어떤 부분이 교체될 것인지에 대한 지침이 포함되어 있다. 도 631은 단계 8240에서 IEC 의 논리 흐름을 계속하며, 이는 LIZARD 를 호출하여 목적 대체를 실행 세그먼트 로 변환하여, 결과를 생성하여 SRUR (Syntax Replacement Unit Retention) 8246에 제출한다. 8242 단계는 각 구문 대체 유닛을 코드 구조 청사진 에서 해당 위치와 연관시킨다. 8242 단계에서는 UBL (Unit Blueprint Lookup) 모듈을 호출한다. UBL 모듈은 입력 데이터를 업그레이드 된 앱체인 출력으로 정렬하는 CSSP (Code Structure Streamline Processing) 8250 모듈로 출력을 생성한다. 따라 서 CSSP 8250은 8244 단계를 호출하여 구문 교체 유닛과 앱체인 의 교체할 부분에 대한 지침이 포함 된 배 포 패치를 만든다. 도 632는 본질적 오류 정정 (IEC) 8050 모듈의 내부 논리의 일부로서 단계 8224의 호출과 관련하여 SPR (적합한 목적 교체) 8252 모듈의 동작 및 기능을 도시한다. MCUPR (Misaligned Code Unit Purpose Retention) 모듈은 SPR 의 8254 단계에 모듈식 입력으로 제출된다. 8254 단계는 MCUPR 에서 각 잘못 정렬된 코 드 유닛 목적을 통해 루프를 시작한다. 단계 8256에서, LOM 은 코드 구조 청사진과 일치하고 호환되 는 선택된 잘못 정렬 된 코드 유닛에 대한 목적 교체 을 생성하기 위해 호출된다. 따라서 코드 구조 청사 진는 최종적으로 목적 교체를 포함하도록 수정되어 더 정확한 청사진 8260을 형성한다. 8254 단계 에서 호출 한 루프 내의 개별 목적 대체는 8240 단계로 제출되어 LIZARD 에서 처리된다. 단계 8240 에서, LIZARD 는 목적 대체를 실행 세그먼트 로 변환하기 위해 호출된다.도 633은 적합한 목적 교체 (SPR) 8252의 단계 8256에 관한 LOM 및 CTMP 의 내부 동작 절차를 도시 한다. 코드 구조 청사진 8260, 잘못 정렬된 코드 단위 및 준수 디자인 원칙 8262는 RIP (Replacement Invocation Prompt) 8266에 초기 입력으로 제공된다. RIP 은 LOM 와 직접 상호 작용하여 입력 기준 코드 구조 청사진 8260, 잘못 정렬된 코드 단위 및 준수 디자인 원칙 8262를 고려하여 목적 교체 (825 8)의 생성을 호출하는 프롬프트 을 생성한다. RIP 에 의해 생성된 프롬프트 은 LOM 의 IQR (Initial Query Reasoning) C802A 모듈에 제출된다. LOM 이 UBEC 사용자 에 의해 UBEC 플랫폼 내에서 직접 호출 될 때, IQR C802A는 UBEC 사용자 에 의해 제공된 초기 질문 / 주장을 수신한다. 그러나 LOM 의 이 인스턴스는 대신 RIP 에 의해 자동으로 호출된다. 제공된 프롬프트 은 LOM 에 의한 올바른 '가상 이해' 수정을 완료하여 프롬프트에 온전히 어드레스(address)/응답 하는데 중 요한, 프롬프트 에서 누락된 세부 사항을 해독하기 위하여 CKR (Central Knowledge Retention) 호 출에 의해 분석된다. IQR C802A에 의해 결과적인 작성된 누락 세부 사항은 SC (Survey Clarification) C803A에 모듈 식 입력으로 제출된다. SC C803A는 프롬프트 의 출처와 연계하여 보충 정보를 검색하므로 프롬프트 을 객관적으로 필요한 모든 상황에서 분석 할 수 있다. UBEC 사용자 에 의해 LOM 이 UBEC 플랫 폼 내에서 직접 호출 될 때, SC C803A는 질문 / 응답의 시작으로서 그 사용자 와 참여한다. 그러나 이 LOM 인스턴스는 대신 RIP 에 의해 자동으로 호출되므로 SC C803A는 RIP 과 연동하여 프 롬프트 에 관한 보충 정보를 검색한다. 프롬프트 의 완전하게 형성되고 정제된 버전은 SC C803A에 서 생성되며 주장 생성 (AC) C808A에 모듈 식 입력으로 제출된다. AC C808A는 CKR 을 직접 참조하고 계층 적 매핑 (HM) C807A를 통해 프롬프트 에 대한 일관된 응답을 구성하려고 시도한다. 합리적 어필 (RA) C811A는 CTMP 와의 논리 흐름 인터페이스를 수용하는 컨테이너 모듈이다. RA C811A는 CTMP 를 사용하 여 주장을 비판한다. 이러한 비판은 자체 비판 (AC C808A의 출력을 비판함으로써) 또는 IQR C802A (UBEC 사용자 또는 RIP )에 의해 처리 된 질문 / 주장의 원점에 대한 외부 비판의 형태 일 수 있다. AC C808A에 서 생성 된 주장이 RA C81 A에 의해 처리 된 자기 비판 테스트에 대한 상당한 측정에 실패한 경우; 유효한 비판 을 설명하기 위해 AC C808A의 새 인스턴스가 호출된다. RA C811A에 의해 처리 된 자기 비판 테스트를 지속적으 로 통과하는 AC C808A에 의해 높은 신뢰도의 주장이 생성되는 경우; 주장은 RIP 에서 제공하는 초기 프롬 프트 과 관련하여 이상적인 투자 결정 구성 12404로 참조되는 LOM의 132 모듈 식 출력으로 생성된다. 도 634는 CSE 의 단계 12402에 관한 LOM 의 합리적 어필 (RA) C811A의 내부 동작 절차를 더 상세 하게 도시한다. 주장 구성 (AC) C808A는 해당 입력 프롬프트 과 관련하여 AC C808A가 생성한 주장과 관련 하여 합리적 어필 (RA) C811A에 응답 프레젠테이션 C843을 제공한다. 논리 흐름의 이 단계에서 생성 된 주장은 사전 비판 결정 C847로 분류된다. 이것은 CTMP 에 의한 비판을 통해 아직 처리되지 않았음을 나타낸다. 따 라서 생성된 주장은 CTMP 인스턴스에 '주관적 의견' (C848) 입력으로 직접 제출되며 또한 CTMP 인 스턴스에 ‘객관적 사실'(C850) 입력을 제공하는 컨텍스트 구성 (CC) C817A에 제출된다. CC C817A는 AC C000A의 메타 데이터와 RIP 0266을 통해 제공된 잠재적 증거를 참조하여 비판적 사고를 위해 미가공 팩트 (raw fact)를 CTMP 에 제출한다. 이러한 입력 메타 데이터는 LOM 로그 집계 (Log Aggregate) 파일로 표시된다. LOM 로그 집계 에는 LOM 의 기본 작동 기능에서 생성되는 관련 로그 파일 모음이 포함되어 있다. CTMP 인스턴스가 작동을 마치면 사후 비판 결정 C851이 모듈 형 출력으로 생성된다. 초기 사전 비판 결정 C847 및 사후 비판 결정 C851은 두 입력 C847과 C851 사이의 잠재적 중복 범위를 결정하는 결정 비교 (DC) C818A 모듈에 제출된다. DC 818 A에서 제공하는 통일된 출력은 AC C808A 생성 주장을 대신하여 CTMP의 124 양보 C852 (잘못된)를 표시하거나 AC C808A 생성 주장을 대신하여 인지된 개선 C853을 나타낼 수 있다. 인수 응답 C852 및 C853은 모두 신뢰도가 낮은 결과 C845 또는 신뢰도가 높은 C846으로 분류 할 수 있다. 낮은 신뢰 결과 C845는 AC C808A에 의해 생성된 원래 주장이 결함이 있으며 재구성되어야 함을 나타낸다. 따라서 논리 흐름은 AC C808A의 새로운 인스턴스로 계속 이어진다. 높은 신뢰도 결과 C846은 AC C808A에 의해 생성 된 원래 주장이 장점이 있다는 것을 나타내므로 추출 된 결론 (해당 증거, 전제 등과 결합 됨)은 지식 검증 (KV) C805A에 제출 된다. 따라서 논리 흐름은 KV C805A의 새 인스턴스로 계속 진행되므로 CKR 846 및 LOM 는 최근 처리 된 주 장으로부터 이익을 얻을 수 있다. 도 635는 LOM 로그 집계 파일의 생성을 설명하기 위해 CSE 12400으로부터 단계 12402의 논리 흐름을 계 속한다. IQR (Initial Query Reasoning) C802A, Survey Clarification (SC) C803A, 주장 생성 (AC) C808A, HM (Hierarchical Mapping) C807A 및 KV (Knowledge Validation) C805A에서 생성 된 모듈 식 출력은 LOM Modular Log Collection (LMLC) 모듈에 제출된다. 따라서 LMLC 은 입력 로그 데이터를 LOM Log Aggregate 5502로 참조되는 읽기 가능한 단일 파일로 결합한다. 파일 은 대응하는 LOM 인스턴스의 전체 동작 상태를 포함하며, 따라서 LOM 인스턴스가 어떻게 다양한 결론에 도달했는지에 관한 정보를 제공한다. LOM로그 집계 는 합리적 어필 (RA) C811A의 CC C817A에 제출된다. 도 636은 합리적 어필 (RA) C811A에 정의 된 입력 및 출력 채널과 관련하여 CTMP 의 내부 동작을 도시하기 위해 도 634에 관한 동작 세부 사항을 확장한다. 사전 비판 결정 C847은 AC (주장 생성) C808A의 모듈 출력으로 제공(C843)된다. 의사 결정 C847은 주관적인 의견 C848으로 표시되므로 CTMP 의 두 가지 주요 입력 중 하 나를 충족한다. 주관적 의견 C848은 CTMP 의 기본 모듈 식 입력 및 SPMA (Selected Pattern Matching Algorithm)의 내부 표현으로 작동하는 입력 시스템 메타 데이터 C484에 제출된다. 이 인스턴스 구성의 경우; SPMA는 LOM 이다. 입력 시스템 메타 데이터 C484는 처리를 위해 이유 처리 C456 및 raw 인식 생성 (RP2) C465로 제출된다. 추론 처리 C456은 속성 특성을 비교하여 작성된 주장을 논리적으로 이해한다. RP2 C465는 LOM 의 입력 시스템 메타 데이터 C484를 구문 분석하여 LOM 의 알고리즘 인식을 나타내는 PCF (Perception Complex Format)의 인식을 생성한다. 이와 같이 생성 된 인지는 LOM 의 알고리즘 인지를 에 뮬레이트하는 인지 관찰자 에뮬레이터 (POE) C475에 제출된다. 추론 처리 C456은 규칙 처리를 호출하여 결국 이 인스턴스에서 LOM 인 SPMA 알고리즘을 반영하는 규칙 세트를 생성한다. 따라서 '사고'의 두 가지 모드 인 '아날로그'인식과 '디지털'규칙 세트 처리가 실행된다. 이 두 브랜치 C461과 C475는 직관과 논리를 가진 유사성 을 나타낸다. 사고 브랜치 C461과 C475가 생성 한 결과는 CDO (Critical Decision Output) C462로 전송되어 결 과 간의 충돌 또는 확증의 기본 요소를 평가한다. 높은 수준의 내부 확증 및 낮은 내부 충돌을 발견하면 CTMP 는 초기 입력 주관적 의견 C848과 관련하여 이진 승인 또는 차단 결정을 제공하며, 이는 높은 신뢰 결과 (C846)으로 참조된다. 낮은 수준의 내부 검증과 높은 수준의 내부 충돌이 있는 경우 CTMP 는 낮은 신뢰도 결과 C845로 참조되는 '신뢰할 수 없는 투표'를 제출한다. 따라서 CTMP 의 결과적 출력은 사후 비판 결정 C851으로 간주된다. 도 637은 CTMP 내에서 RP2 (Raw Perception Production) C465의 호출에 관한 세부 사항을 도시한다. LOM 는 주장 구성 (AC) C808A를 호출하여 목적 교체 을 생성한다. 그런 다음 목적 대체 은 데이터 를 언팩 하는 RP2 C465의 단계 5506에 제출되어 해당 AC C808A 인스턴스에서 발생하는 입력 시스템 메타 데이터 C484 내에서 디버깅 추적 C485 및 알고리즘 추적 C486의 인스턴스를 생성한다. 디버깅 추적 C485는 해당 입력 및 출력 변수 유형 및 내용과 함께 사용되는 변수, 함수, 메소드 및 클래스를 제공하는 코딩 레벨의 추적이다. 전체 기능 호출 체인 (기능 추적: 다른 기능을 호출하는 기능)이 제공된다. 알고리즘 추적 C486은 알고리즘 분 석과 결합 된 보안 데이터를 제공하는 소프트웨어 수준의 추적이다. 결과적 보안 결정 (승인 / 차단)은 결정 C847에 도달 한 방법에 대한 로지스틱스 추적과 함께 제공된다. 결정 C847 생성에 기여한 각 요소에 대한 적절 한 가중치가 포함된다. 그 후, RP2 C465는 생성 된 인식 결과에 관한 데이터를 처리를 위해 POE (Perception Observer Emulator) C475로 전송한다. 도 638은 CTMP 내에서 raw 인식 생성 (RP2) C465의 동작에 대해 상세히 설명한다. 초기에 단계 5506은 도 1209에서와 같이 해당 AC C808A 인스턴스에서 발생하는 입력 시스템 메타 데이터 C484 내에서 디버깅 트레이 스 C485 및 알고리즘 트레이스 C486의 인스턴스를 생성하기 위해 데이터를 언팩 하기 위해 발생한다. 단계 에서, 메트릭 프로세싱(C489)은 LOM 으로부터의 변수를 리버스 엔지니어링하여 LOM 에 의해 나 타나는 인공 지능으로부터의 인식을 추출한다. 그 후, 입력 시스템 메타 데이터 C484는 단계 5510에 의해 처리 되며, 메타 데이터 C484는 SMS (System Metadata Separation) C487을 통해 의미 있는 보안 원인-효과 관계로 분리된다. RP2 C465는 도 1209에도 표시된 바와 같이, 생성 된 인지 결과에 관한 데이터를 POE (Perception Observer Emulator) C475로 전송하여 처리한다. 도 639는 POE (Perception Observer Emulator) C475의 동작에 대해 상세하게 설명하고, 이를 인식 저장소 (PS) C478과 관련하여 그것과 Raw Perception Production (RP2) C465를 포함한다. 메트릭 처리 C489 및 SMS (System Metadata Separation) C487의 작동은 모두 PS C478에 저장되는 인식 5512/5514/5516의 생성을 유도한다. 결과 적 인식 5512/5514/5516은 AC (Assertion Construction) C808A를 통해 목적 대체 을 생성하는 LOM의 132 모듈 식 응답을 나타낸다. RP2 C465는 검색 기준으로 스토리지 검색 (SS) C480에 제공되는 비교 가능한 변수 형 식 데이터 포인트를 생성한다. 그 후 SS C480은 PS C478의 검색을 수행하여 PS C478에 저장된 기존의 인식과 일 치하는 것을 찾는다. 실행 SS C480의 결과 C716이 생성되어 가중치 계산 C718이 된다. 이러한 계산 C718은 PS C478에서 해당 인식의 올바른 분포를 찾아서 목적 대체 을 생성 한 LOM 알고리즘의 실행을 나타내 는 비교 가능한 변수 형식을 복제하고 일치 시키려고 한다. 도 640은 도 639의 POE (Perception Observer Emulator) C475 논리를 계속한다. 스토리지 검색 (SS) C480에서 결과 C716을 생성 한 후 가중치 계산 C718이 완료되어 액티브한 승인 C731 또는 블록 C730 결정을 내리기 위해 인식 5512/5514/5516의 어플리케이션 C729로 이어진다. LOM 및 대응하는 LOM 로그 aggregate 에의해 생성 된 목적 대체 는 입력 목적 교체 에 대한 긍정적 감정 (승인) C731 또는 부정적 감정 (블록)의 해석 이분법 을 달성하기 위해 어플리케이션 C729에 적용되는 데이터 향상 로그 C723이 도출되 게 하는 데이터 파싱 C724를 겪는다. 어플리케이션 C729의 실행이 성공적으로 완료되면 CRO (Critical Decision Output) C462에 의해 규칙 실행 (RE) C461의 모듈 식 출력과 동시에 처리되는 재정의 수정 조치 C476이 발생한 다. SCKD (Self-Critical Knowledge Density) C474 모듈은 보고 가능한 LOM 로그 Aggregate 5502의 범위를 벗 어나는 미지의 잠재적 지식 범위와 유형을 추정한다. 이런 식으로 처리 CTMP 인스턴스의 후속 비판적 사 고 기능은 인스턴스에 직접 알려지거나 알려지지 않은 모든 관련 지식의 잠재적 인 범위를 활용할 수 있다. 도 641은 도 639의 POE (Perception Observer Emulator) (C475)의 실행과 병행하여 동작하는 메모리 웹 C460 프로세스를 도시한다. LOM 에서 생성 한 목적 대체 은 모듈 식 입력으로 추론 처리 C456에 제출된다. 추론 처리 C456은 RIP 이 제공하는 프롬프트 에 응답하여 LOM 가 목적 대체 을 생성하기로 결정한 방법을 처리한다. 추론 처리 C456의 처리 결론은 추론 처리 C457의 실행이며, 이는 LOM 실행 동작과 세 번째로 일치하는 규칙을 정의한다. LOM의 132 실행 동작과 관련하여 규칙 동작에서 불일치가 발견되면 현재 존재하는 규칙이 수정되거나 새 규칙이 추가된다. 이러한 규칙은 나중에 해당하는 LOM 인스턴스 내에서 발견 된 의사 결정 행위를 비판하기 위해 CTMP 인스턴스 내에서 사용된다. CRSE (Critical Rule Scope Extender) C458은 알려진 인지를 활용하여 규칙 세트의 '중요한 사고' 범위를 확장하여 규칙 세트를 향상시켜 커렉트 룰(correct rules) C459를 생성한다. 그런 다음 커렉트 룰(correct rules) C459 가 메모리 웹 C460의 운영 관할권 내에서 규칙 구문 형식 분리 (RSFS) C499에 대한 모듈식 입력으로 제출된다. RSFS C499는 커렉트 룰(correct rules) C459를 유형별로 분리하고 구성한다. 따라서 모든 작업, 속성, 조건 및 개체는 RSFS C499 프로세싱 후에 별도로 나열된다. 이를 통해 CTMP 인스턴스는 카오틱 필드에서 발견된 부분과 발견되지 않은 부분을 식별 할 수 있다. 카오틱 필드 파싱 (CFP) C535는 LOM 로그 집계 를 혼돈 필드로 참조되는 단일 스캔 가능 단위로 결합하고 형식화한다. 카오틱 필드는 MR (Memory Recognition) C501에 모듈 식 입력으로 제출된다. MR C501은 RSFS C499의 실행 결과인 오리지널 규칙(original rules) C555도 수신 한다. MR C501은 CFP C535가 제공한 카오틱 필드를 스캔하여 오리지널 규칙 C555에 정의 된 알기 쉬운 개념을 인식한다. 이 MR C501 인스턴스 실행은 인식 된 규칙 세그먼트 C556을 생성한다. 그 후 RFP (규칙 이행 파서) C498은 MR C501에 의해 카오틱 필드 내에서 인식 또는 부족에 따라 태그가 지정된 오리지널 규칙 C555의 개별 부분을 수신한다. 그런 다음 RFP C498은 규칙 실행 (RE) C461에 따른 처리를 위해 혼돈 필드에서 어느 전체 규 칙 집합 (모든 부분의 조합)이 충분히 인식되었는지 논리적으로 추론 할 수 있다. RE C461의 실행이 성공적으로 완료되면 CDO (Critical Decision Output) C462에 의해 POE (Perception Observer Emulator) C475의 모듈 식 출력과 병렬로 처리되는 오버라이드 정정 작업 C476이 발생한다. 도 642는 PS (Perception Storage) C478과 APDM (Automated Perception Discovery Mechanism) C467 사이의 논 리 흐름 상호 작용에 대해 상세히 설명한다. PS C478에는 인지의 추측된 미지 각도 C473, 인지의 모든 각도 C472, 인지의 암시 각도 C471 및 인지의 적용 각도 C470의 네 가지 인지의 하위 집합이 포함되어 있다. 인지의 적용 각도(C470)는 선택된 패턴 매칭 알고리즘 (SPMA), 이 경우 LOM 의 알고리즘 동작을 연구하여 직접 가 져온 인식이다. 인지의 암시 각도 C471은 인지의 적용 각도 470C에서 Implication Derivation (ID) C477 및 APDM C467의 모듈식 실행을 통해 파생된 인식이다. 인지의 모든 각도 C472는 인지의 적용 각도 C470 및 인지의 암시 각도(C471)에 포함되지 않은 CTMP 인스턴스에 대한 알려진 인지의 전체 범위를 나타낸다. 인지의 추 측된 미지 각도 C473는 존재할 것으로 예상되나 CTMP 인스턴스가 아직 SCKD (Self-Critical Knowledge Density) C474 모듈에 따라 발견하지 못한 인식 범위를 나타낸다. ID C477은 인지의 적용 각도 C470의 개별 메 트릭을 분석하여 인지의 암시 각도 C471을 결정론적으로 유도하는 한편, APDM C467은 창의성 모듈 112를 통해 인지의 각도(C650)를 창조적으로 변화시켜 초기 두 입력 가중치 C652를 병합하는 신규 반복(C65)을 생성한다. 따라서 APDM C467 처리와 관련된 모든 인지 각도 C650은 LOM의 132 주장 생성 (AC) C808A 모듈에 의해 생성된 목적 대체 에 해당하고 이를 나타낸다. 도 643은 CTMP 의 CRSE (Critical Rule Scope Extender) C458에 관한 동작 세부 사항에 대해 상세히 설명 한다. RA (합리적 어필)(C811A) 인스턴스는 LOM 내에서 작동하고 CC (Context Construction)(C817A)를 호출하여 LOM 로그 aggregate를 카오틱 필드 파싱(CFP)(C535)으로 처리한다. CFP는 메모리 인지 (MR) C501에서 참조하는 CC C817A의 모듈식 출력에서 카오틱 필드를 생성한다. 현재 규칙 C534는 이 경우 LOM 인 SPMA (Selected Pattern Matching Algorithm)의 현재 기능 상태를 나타내는 규칙 세트를 보인다. 현재 규칙 C534는 논리적 '흑백'규칙이 메트릭 기반 인지로 변환되는 규칙 구문 파생 (RSD) C504 모듈에 모듈 식 입력으로 제출된다. 따라서 여러 규칙의 복잡한 배열은 다양한 그래디언트의 여러 메트릭을 통해 표현되는 단일 균일 인 지로 변환된다. RSD C504의 모듈 식 출력은 PM (인지 Matching) C503에 모듈 식 입력으로 제공된다. PM C503에서; CVF (Comparable Variable Format) 유닛은 RSD C504로부터 수신된 인지로부터 형성된다. 새로 형성된 CVF 는 유사한 색인을 가진 인지 Storage (PS) C478에서 관련 인지를 조회하는 데 사용된다. 잠재적 일치 항목은 규 칙 구문 생성 (RSG) C505에 모듈식 입력으로 제출된다. RSG C505는 인지 형식으로 저장된 이전에 확인 된 인지 를 수신하고 인지의 내부 메트릭 구성에 액세스한다. 이전에 확인된 인지 C468이 포함된 PS C478로부터 인지가 수신된다. 이러한 그래디언트 기반 메트릭 측정 단위는 원래 인지의 입력 / 출력 정보 흐름을 에뮬레이트 하는 이진 및 논리 규칙 세트로 변환된다. 따라서 RSG C505는 관련성이 있고 대중적이며 논리적 규칙으로 변환된 인 지인 인지 규칙 C537을 생성한다. 인지 (원래 인지 형식)에 많은 '회색 영역'을 정의한 많은 복잡한 메트릭 관 계가 있는 경우 '흑백'로컬 규칙은 규칙 세트 복잡성을 확장하여 이러한 '회색'영역을 포함한다. 따라서 인지 규칙 C537은 규칙 구문 형식 (RSF) 정의 모음에 의해 저장된다. 인지 규칙 C537은 메모리 인지 (MR) C501에 모 듈 식 입력으로 제출되며 CFP C535에 의해 생성 된 카오틱 필드에 대해 스캔 된다. 따라서 MR C501은 커렉트 룰 (Correct Rule) C533을 완성하는 추가 규칙 C536을 생성한다. 도 644는 CTMP 의 함의 도출 (ID) C477에 관한 동작 세부 사항에 대해 상세히 설명한다. 인지 저장소 (PS) (C478)의 인지의 적용 각도(C470)은 모듈식 입력으로 ID C477에 제출되어 인지의 암시 각도(C471)에 속하는 더 많은 인지를 생성한다. 인지의 적용 각도(C470)은 구체적으로 ID C477의 메트릭 조합(C493)으로 전송된다. 메트 릭 조합(C493)은 수신된 인지 각도(C650)를 메트릭 범주 (범위 C739, 유형 C740, 일관성 C741, 강도 C742)로 구분한다. 시스템 내 메트릭 가용성 및 참조가 반드시 이 네 가지 유형으로 제한되는 것은 아니다. 입력 인지 각도 C650은 LOM의 132 주장 생성 (AC)(C808A) 모듈에 의해 생성된 목적 대체와 관련이 있다. 메트릭 복 잡성 세트(C736)은 메트릭 확장 (ME)(C495)에 모듈식 입력으로 제출된다. ME C495를 사용하면 다중 및 다양한 인지 각도(C650)의 메트릭이 개별 데이터베이스 C739 / C740 / C741 / C742에 범주 적으로 저장된다. ME(C49 5)는 이전에 알려진 / 마주친 메트릭에서 추출된 세부사항 / 복잡성을 사용하여 수신된 메트릭의 현재 배치를 향상시킨다. 향상 및 복잡성 강화 완료 시, 메트릭은 메트릭 복잡성 세트 B(C737)로써 ME C495 모듈식 출력에 반환 된 후, 도 1217에 도시 된 바와 같이 인지의 암시 각도(C471)에 저장되도록 인지 각도(C650)로 다시 변환 된다. 도 645는 도 644의 개별 메트릭을 전체 인지 각도 C650으로 리버스 시키는 메트릭 변환 C494에 의해 처리되는 메트릭 복잡성 세트 B C737을 보여주면서 ID (Implication Derivation) C477의 논리 흐름을 계속한다. ID C477 에 의해 수행 된 강화 및 변환 프로세스에도 불구하고, 결과적인 인지 각도 C650은 여전히 LOM의 132 Assertion Construction (AC) C808A 모듈에 의해 생성된 목적 대체를 상당히 정확하게 표현한다. 따라서 메트릭 변 환(C494) 프로세스는 새로 도출되거나 암시된 인지 각도(C650)를 인지 저장소 (PS)(C478) 내의 인지의 암시 각 도(C471)에 제출한다. 도 646은 CTMP 의 CDO (Critical Decision Output) C462와 관련된 운영 세부 사항에 대해 자세히 설명한 다. CDO C462는 CTMP 의 주요 브랜치인 POE (인지 Observer Emulator) C475 (직관 브랜치)와 규칙 실행 (RE) C461 (논리 브랜치)의 모듈식 출력을 수신한다. 각 브랜치 C475 / 461은 각각의 중요한 결정 C521 (주요 모듈 출력)과 해당하는 '메타-메타 데이터'C521을 제출하여 초기 결정에 도달 한 이유를 정당화하는 맥락 변수 를 제공한다. POE C475의 인지 C516을 나타내는 결정 세트 C521과 RE C461의 이행된 규칙 C517이 메타 데이터 분류 모듈 (MCM) C488에 제출된다. MCM C488은 전통적인 구문 기반 정보 분류를 사용하여 디버깅 및 알고리즘 추적을 개별 범주로 분리한다. 그런 다음 이러한 범주를 사용하여 보안 위험 및 주제와 상관 관계가 있는 별도 의 보안 대응을 구성하고 생성 할 수 있다. POE C475의 인지 C526을 나타내는 직관적 결정 C514와 RE C461의 이 행 규칙 C517을 나타내는 사고 결정 C515가 MCM C488에 의해 방향 결정 비교 (DDC) C512의 내부 처리 로직 5520에 제출된다. DDC C512의 내부 처리 로직 5520은 직관적 결정 C514와 사고 결정 C515 간의 확증 또는 충돌 을 확인한다. DDC C512는 정적 하드코딩 된 정책(SHP)의 '컷오프 변수'를 참조한다. 컷오프 변수가 직관적 결정 C514와 사고 결정 C515 (예: 90 % +) 사이의 유사성에 도달하지 않으면 직접 비교 취소 5524 지시어가 발 생하여 최종적으로 도 647에 도시된 것처럼 신뢰성 없는 투표 5544를 제출하는 터미널 출력 제어 (TOC) C513로 이어질 수 있다. 직접 비교 취소 5524 단계는 CTMP 가 RIP 의 입력 프롬프트 과 관련하여 내부적으로 일관성 있게 작동 할 수 없음을 나타낸다. 내부 처리 로직 5520에 따라 '컷오프 변수가 충분히 충족 된 경우 최종 결정 출력 5522 단계가 호출되어 결정 C514 / C515를 TOC C513에 의해 수신 및 처리되는 단일 모 듈 출력으로 결합한다. 도 647은 도 646의 CDO (Critical Decision Output) C462의 논리 흐름을 계속하고 TOC (Terminal Output Control) C513의 동작 세부 사항을 상세하게 설명한다. TOC C513은 DDC (Direct Decision Comparison) C512가 (직접 비교 취소 5524 지시문 대신) 최종 결정 출력 5522를 제공 할 수 있는지 확인하는 프롬프트 5526으로 시작한다. 프롬프트 5526에 대한 응답이 Yes 5528 인 경우 최종 결정 출력 552에서 DDC C512가 제공 한 결합 된 최종 결정은 TOC C513의 모듈 식 출력으로 제출되므로 최종 중요 결정 5542 출력으로 전체 CTMP 인스턴스 의 모듈 식 출력으로 제출된다. . 프롬프트 5526에 대한 응답이 No 5530 인 경우 단계 5532가 호출되어 자체적 으로 인지 매칭(PM 5532)의 실행을 호출하고 해당 결과를 가져온다. 이행된 규칙 C517은 규칙 실행 (RE) C461의 중요 결정 + 메타-메타 데이터 C521에서 추출된다. 규칙 C517은 규칙 구문 파생 (RSD) C504에 의해 인지로 변환 된다. 그런 다음 PM 5532는 메타-메타 데이터를 참조하여 프롬프트 에서 강력한 내부 중첩과 사용 된 인 지의 확증이 있는지 확인한다. 프롬프트 에 대한 응답이 YES 인 경우 CTMP 대신 모듈식 출 력으로 신뢰 없음 투표 5544를 나타낸다. 프롬프트 에 대한 응답이 No 이면 단계 5540이 활성화되 어 직관적 결정 C514와 사고 결정 C515 사이에서 인지된 가장 위험이 덜한 결정을 선택한다. 따라서 최종 중요 결정 5542는 CDO C462, TOC C513 및 CTMP 에 모듈 식 출력으로 제출된다. 단계 5534에서의 논리는 직관적 결정 C514와 사고 결정 C515 사이의 단일성 결여가 알고리즘 신뢰의 일반적인 부족으로 인해 또는 이 둘 사이의 매우 반대 관점으로 인해 발생 하는지를 결정하기 위해 발생한다. 따라서 후자가 발생할 경우 잠재적 최종 중요 결정 5542는 여전히 모듈식 출력으로 식별할 수 있다. 신뢰 없는 투표 5544는 항상 합리적 어필 (RA) C811A 내 신뢰도가 낮은 결과 C845 논리 경로로 이어진다. 최종 중요 결정 5542는 최종 중요 결정 5542의 알고리즘 신뢰 도에 따라 RA C811A 내에서 높은 신뢰 결과 (C846) 또는 낮은 신뢰 결과 (C845) 논리 경로로 이어질 수 있다. 도 648은 목적 대체 를 실행 세그먼트 로 변환하기 위한 LIZARD 의 동작에 관한 세부 사항을 도시한다. 목적 대체 은 복합 목적 형식 C325로 존재하며 LIZARD 의 외부 핵심 (OC) C329 내에서 목적 모듈 C36의 반복 확장 C327에 제출된다. 반복 확장 C327은 세부성과 복잡성을 추가하여 간단한 목표 (목적 대체 내에 간접적으로 정의 됨)를 특정 복잡한 목적 정의로 발전시킨다. 그러므로 구문 모듈 (SM) C35의 논리 유도 C320에 제출되기 전에 입력의 최대 목적 연관성 C326 가능성이 실현되어 복합 목적 형식C325로 유지 된다. 내부 핵심 (IC) C333의 핵심 코드 C335 요소에는 기본 프레임 워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함되어 있다. 따라서 핵심 코드 C335는 기본 기능을 가능하게 하는 표준화 된 라이브러리 및 스크립트를 제공하여 SM C35 및 PM C36에 대한 일반 작업 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정 의는 LIZARD 내에서 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 649는 목적대체를 실행 세그먼트로 변환하기 위한 LIZARD 의 동작을 설명하기 위해 도 648 로부터의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM) C36에서 복합 목적 형식 C325로 수신되고 구문 모듈(SM) C35의 논리 유도 C320으로 전송된다. 논리 유도 C320은 초기 단순한 함수에서 논리적으로 필요한 함수 를 유도한다. 즉, 함수가 단순한 부모 함수의 암시로 인해 파생 함수로 형성 될 수 있는 경우; 논리 파생 C320 에 의해 형성된다. 생성된 결과는 정의된 복합 목적 형식 C325 데이터에 따라 작성된 함수 종속성 트리이다. 논 리 도출 C320은 내부 핵심 (IC) C333의 핵심 코드 C335 요소에서 상속 된 규칙 및 구문 C322 정의에 따라 작동 한다. 논리 도출 C320는 출력을 코드 번역 C321에 제출한다. 코드 번역 C321은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역 C321은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수도 수행한다. 따라서 PM C36은 SM C35를 호출하여 코드 번역 C321을 통해 입력 목적 대체의 결과적 실행 세그먼트 버전을 생성한다. 코드 번역 C321에서 마지막으로 생성되는 결과적 실행 세그먼트은 SM C35, 외부 핵심 (OC) C329 및 LIZARD 의 모듈식 출력이다. 실행 세그먼트 는 그 후 구문 대체 유닛 보유 (SRUR)에 저장된다. 도 650은 IEC (Innate Error Correction) 8050의 단계 8242와 관련하여 UBL (Unit Blueprint Lookup) 8248 모 듈의 동작 및 기능에 대해 상세히 설명한다. 단계 8286은 SRUR (Syntax Replacement Unit Retention) 8246에서 모듈 식 입력을 수신하므로 SRUR 8246에서 모든 구문 대체 유닛을 순환하는 루프를 시작했다. 8284 단계 는 SRUR에서 선택된 구문 대체 유닛을 검색한다. 연관된 코드 유닛 ID 8292는 8290 단계의 구문 대체 유 닛 8288에서 언팩된다. 동일한 UBL 인스턴스 내의 별도의 병렬 스레드에서 코드 구조 청사진 8260은 모 듈 식 입력으로 단계 8280에 제출된다. 8280 단계는 코드 구조 청사진 8260을 New 코드 구조 청사진 보유 (NCSBR) 8282에 설치한다. 도 651은 단계 8242의 내부 로직 내에서 UBL (Unit Blueprint Lookup) 8248 호출에 관한 도 1222의 로직 흐름 을 계속한다. 논리 흐름은 도 1222의 단계 8294에서 재개되며, 선택된 구문 교체 유닛 8288을 새로운 코드 구조 청사진 (NCSBR) 8282에 설치한다. 단계 8286에서 호출 된 반복 처리 루프가 완료되면 단계 8296이 호출된다. 단 계 8296은 코드 구조 간소화 처리 (CSSP) 8250을 통해 실행 세그먼트 의 이행 상태를 리버스 시킨다. 따라 서 CSSP 8250은 업그레이드 된 앱체인 를 모듈형 출력으로 생성한다.도 652는 도 651에서 CSSP 8250의 호출로부터 고유 오류 정정 (IEC) 의 논리 흐름을 계속한다. CSSP 8250은 원래 구문 구조를 나타내지만 잘못 정렬된 코드 유닛이 적합한 목적 대체로 대체된 업그레이드 된 앱체 인 를 생성한다. 업그레이드 된 앱체인 는 DPA (Deployment Patch Assembly) 6260에 제출되어 앱 체인 정정 패치 6270을 생성한다. 타겟 앱체인 은 ESC (Execution Stream Collection) 6700에 의해 처리 되므로 원래 실행 스트림 을 DPA 6260 인스턴스에 제출한다. 이를 통해 DPA 6260은 원래 형식으로 타겟 앱 체인 에 액세스 할 수 있다. DPA 6260은 오리지날 6060과 업그레이드 된 앱체인 의 차이에 액세스 할 수 있기 때문에 오리지날 앱체인 을 업그레이드 된 앱체인 로 변환하는 지침이 포함 된 앱체인 정정 패치 6270을 생성 할 수 있다. 8298 단계에서 앱체인 정정 패치 6270은 커스텀체인 생태계 빌더 (CEB)에 배포되어 타겟 앱체인 을 조작하여 컨텐츠를 업그레이드 된 앱체인 로 변환한다. 도 653은 앱체인 보안 하드닝 (ASH) 8044의 내부 동작 절차를 도시한다. ASH 는 코드 효율, 품질, 보안 및 안정성 5048을 수행하는 SPSI 내의 서브모듈이다. LOM 는 8300 단계에서 ARM 를 통해 보안 위협, 알려진 사례 및 잠재적 사례를 조사한다. 결과적인 새로운 확인되지 않은 정보는 단계 8302에서 CKR 에 저장되고 처리된다. 8304 단계에서 LOM 는 보안과 관련된 의미 있는 주장과 결론을 추출하여 보안 위협 지식 8306을 생성한다. 8308 단계에서 보안 위협 지식은 참조를 위해 인공 보안 위협 (AST) 123에 제출된 다. 도 654는 도 653으로부터 앱체인 보안 하드닝 (ASH) 의 논리 흐름을 계속한다. 8310 단계에서 ARM (13 4)는 공개 및 개인 데이터 아카이브에서 확인되지 않은 정보를 검색하고 확인되지 않은 정보를 8312 단계에서 CKR 에 저장한다. 단계 8314에서 LOM 및 CTMP 에서 확인되지 않은 정보를 확인하고 정보를 확 장하여 진실한 개념을 생성하면, 확인 된 지식은 CKR 에 저장되어 향후 호출을 통해 검색 할 수 있다. 도 655는 앱체인 보안 하드닝 (ASH) 8044의 8304 단계와 관련하여 LOM 및 CTMP 의 내부 동작 절차 를 도시한다. 보안 이론 8312, 확인되지 않은 보안 정보 8314 및 확인된 보안 지식 8310은 Deduction 호출 프롬 프트 (DIP) 8316의 초기 입력으로 제공된다. DIP 8316은 입력 기준 보안 이론 8312, 확인되지 않은 보안 정보 8314 및 확인된 보안 지식 8310을 고려하여 LOM 와 직접 상호 작용하는 프롬프트 8318을 생성하여 Confident 보안 주장 8320을 생성한다. DIP 8316에 의해 생성 된 프롬프트 8318은 LOM 의 IQR (Initial Query Reasoning) C802A 모듈에 제출된다. LOM 이 UBEC 사용자 에 의해 UBEC 플랫폼 내에서 직접 호출 될 때, IQR C802A는 UBEC 사용자 에 의해 제공된 초기 질문 / 주장을 수신한다. 그러나 이 LOM 인스턴스는 대신 DIP 8316에 의해 자동으로 호출된다. 제공된 프롬프트 8318은 LOM 에 의한 올바른 '가상 이해' 수정을 완료하여 프롬프트에 온전히 address/응답 하는데 중요한, 프롬프트 에서 누락 된 세부 사항을 해독하기 위하여 CKR (Central Knowledge Retention) 648 호출에 의해 분석된다. 결과물 인 IQR C802A에 의해 작성된 누락 된 세부 사항은 SC (Survey Clarification) C803A에 모듈 식 입력으로 제출된다. SC C803A는 프롬프트 8318의 출처와 연계하여 보충 정보를 검색하므로 프롬프트 8318을 객관적으로 필요한 모든 상황에서 분석 할 수 있다. UBEC 사용자 에 의해 LOM 이 UBEC 플랫폼 내에서 직접 호출 될 때, SC C803A는 질문 / 응답의 시작으로서 그 사용자 와 참여한다. 그러나 이 LOM 인스턴스 는 대신 DIP 8316에 의해 자동으로 호출되므로 SC C803A는 DIP 8316과 연동하여 프롬프트 8318과 관련된 보충 정보를 검색한다. 프롬프트 8318의 완전히 형성되고 정제 된 버전은 SC C803A에서 생산되며 주장 구성 (AC) C808A에 모듈 식 입력으로 제출된다. AC C808A는 CKR 을 직접 참조하거나 HM (Hierarchical Mapping) C807A를 통해 프롬프트 8318에 대한 일관된 응답을 구성하려고 시도한다. 합리적 어필 (RA) C811A는 CTMP (12 4)와의 논리 흐름 인터페이스를 포함하는 컨테이너 모듈이다. RA C811A는 CTMP 를 사용하여 주장을 비판 한다. 이러한 비판은 자체 비판 (AC C808A의 출력을 비판함으로써) 또는 IQR C802A (UBEC 사용자 또는 DIP 8316)에 의해 처리 된 질문 / 주장의 출처에 대한 외부 비판의 형태 일 수 있다. AC C808A에서 생성 된 주 장이 RA C81 A에 의해 처리된 자기 비판 테스트에 대한 상당한 측정에 실패한 경우; 유효한 비판을 설명하기 위 해 AC C808A의 새 인스턴스가 호출된다. RA C811A에 의해 처리 된 자기 비판 테스트를 지속적으로 통과하는 AC C808A에 의해 높은 신뢰도의 주장이 생성되는 경우; 주장은 DIP 0316에서 제공하는 초기 프롬프트 8318과 관련 하여 기밀 보안 주장 8320으로 참조되는 LOM의 132 모듈식 출력으로 생성된다. 도 656은 ASH 의 단계 8304와 관련하여 LOM 의 합리적 어필 (RA) C81A의 내부 동작 절차의 더 상세 한 내용을 도시한다. 주장 구성 (AC) C808A는 해당 입력 프롬프트 과 관련하여 AC C808A가 생성 한 주장 과 관련하여 합리적 어필 (RA) C811A에 응답 프레젠테이션 C843을 제공한다. 논리 흐름의 이 단계에서 생성 된 주장은 사전 비판 결정 C847로 분류된다. 이것은 CTMP 에 의한 비판을 통해 아직 처리되지 않았음을 나타 낸다. 따라서 생성 된 주장은 CTMP 인스턴스에 '주관적 의견' C848 입력으로 직접 제출되며 또한 CTMP 인스턴스에 ‘객관적 사실’ C850 입력을 제공하는 컨텍스트 구성 (CC) C8 7A에도 제출된다. CC C817A는 AC C808A의 메타 데이터와 RIP 을 통해 제공된 잠재적 증거를 참조하여 비판적 사고를 위해 미가공 팩트 를 CTMP 에 제출한다. 이러한 입력 메타 데이터는 LOM Log Aggregate 5502 파일로 표시된다. LOM 로그 집 계 에는 LOM 의 기본 작동 기능에서 생성되는 관련 로그 파일 모음이 포함되어 있다. CTMP 인 스턴스가 작동을 마치면 사후 비판 결정 C851이 모듈형 출력으로 생성된다. 초기 사전 비판 결정 C847 및 사후 비판 결정 C851은 두 입력 C847과 C851 사이의 잠재적 중복 범위를 결정하는 결정 비교 (DC) C818A 모듈에 제출 된다. DC 818A가 제공하는 통합 출력은 AC C808A 생성 주장을 대신하여 CTMP의 124 양보 C852 (잘못된)를 표시 하거나 AC C808A 생성 주장을 대신하여 인지된 개선 C853을 나타낼 수 있다. 인수 응답 C852 및 C853은 모두 신 뢰도가 낮은 결과 C845 또는 신뢰도가 높은 결과 C846으로 분류 할 수 있다. 낮은 신뢰도 결과 C845는 AC C808A 에 의해 생성 된 원래 주장이 결함이 있으며 재구성되어야 함을 나타낸다. 따라서 논리 흐름은 AC C808A의 새로 운 인스턴스로 계속 이어진다. 높은 신뢰도 결과 C846은 AC C808A에 의해 생성 된 원래 주장이 장점이 있다는 것을 나타내므로 추출 된 결론 (해당 증거, 전제 등과 결합됨)은 지식 검증 (KV) C805A에 제출된다. 따라서 논 리 흐름은 KV C805A의 새 인스턴스로 계속 진행되므로 CKR 846 및 LOM 는 최근 처리 된 주장으로부터 이익 을 얻을 수 있다. 도 657은 LOM 로그 집계 파일의 생성을 설명하기 위해 ASH 로부터의 단계 8304의 논리 흐름을 계 속한다. IQR (Initial Query Reasoning) C802A, Survey Clarification (SC) C803A, Assertion Construction (AC) C808A, HM (Hierarchical Mapping) C807A 및 KV (Knowledge Validation) C805A에서 생성된 모듈식 출력은 LOM 모듈러 로그 컬렉션 (LMLC) 5500 모듈에 제출된다. 따라서 LMLC 은 입력 로그 데이터를 LOM 로그 집 계 로 참조되는 읽기 가능한 단일 파일로 결합한다. 파일 은 대응하는 LOM 인스턴스의 전체 적인 동작 상태를 포함하며, 따라서 LOM 인스턴스가 어떻게 다양한 결론에 도달했는지에 관한 정보를 제 공한다. LOM 로그 집계 는 합리적 어필(RA) C811A의 CC C817A에 제출된다. 도 658은 합리적 어필 (RA)(C811A)에 정의 된 입력 및 출력 채널과 관련하여 CTMP 의 내부 동작을 도시하 기 위해 도 657에 관한 동작 세부 사항을 확장한 것이다. 사전 비판 결정(C847)은 AC (Assertion Construction) C808A의 모듈 출력으로 제공된다(C843). 의사 결정 C847은 주관적인 의견 C848으로 표시되므로 CTMP 의 두 가지 주요 입력 중 하나를 충족한다. 주관적 의견 C848은 CTMP 의 기본 모듈 식 입력 및 SPMA (Selected Pattern Matching Algorithm)의 내부 표현으로 작동하는 입력 시스템 메타 데이터 C484에 제출 된다. 이 인스턴스 구성의 경우; SPMA는 LOM 이다. 입력 시스템 메타 데이터 C484는 처리를 위해 추론 처 리 C456 및 미가공 인지 생성 (RP2) C465로 제출된다. 추론 처리 C456은 속성 특성을 비교하여 작성된 주장을 논리적으로 이해한다. RP2 C465는 LOM 의 입력 시스템 메타 데이터 C484를 구문 분석하여 LOM 의 알 고리즘 인지를 나타내는 PCF (Perception Complex Format)의 인지를 생성한다. 이러한 생성 된 인지는 LOM 에 대한 인지 알고리즘을 에뮬레이트하는 POE (Perception Observer Emulator) C475에 제출된다. 추론 처 리 C456은 규칙 처리를 호출하여 결국 이 인스턴스에서 LOM 인 SPMA 알고리즘을 반영하는 규칙 세트를 생 성한다. 따라서 '사고'의 두 가지 모드 인 '아날로그' 인지와 '디지털' 규칙 세트 처리가 실행된다. 이 두 브랜 치 C461과 C475는 직관과 논리를 가진 유사성을 나타낸다. 사고 브랜치 C461과 C475가 생성 한 결과는 CDO (Critical Decision Output) C462로 전송되어 결과 간의 충돌 또는 확증의 기본 요소를 평가한다. 높은 수준의 내부 확증 및 낮은 내부 충돌을 발견하면 CTMP 는 초기 입력 주관적 의견 C848과 관련하여 이진 승인 또는 차단 결정을 제공하며, 이는 높은 신뢰 결과 (C846)으로 참조된다. 낮은 수준의 내부 검증과 높은 수준의 내부 충돌이 있는 경우 CTMP 는 낮은 신뢰도 결과 C845로 참조되는 '신뢰할 수 없는 투표'를 제출한다. 따라서 CTMP 의 결과적 출력은 사후 비판 결정(C851)으로 간주된다. 도 659는 CTMP 내의 미가공 인지 생성 (RP2) C465의 호출에 관한 세부 사항을 도시한다. LOM 는 Assertion Construction (AC) C808A를 호출하여 신뢰 보안 주장(Confident Security Assertion) 8320을 생성한 다. 그런 다음 신뢰 보안 주장(Confident Security Assertion) 8320은 해당 AC C808A 인스턴스에서 시작하는 입력 시스템 메타 데이터 C484 내에서 디버깅 트레이스 C485 및 알고리즘 트레이스 C486의 인스턴스를 생성하기 위해 데이터를 언팩하는 RP2 C465의 5506 단계로 제출된다. 디버깅 추적 C485는 해당 입력 및 출력 변수 유형 및 내용과 함께 사용되는 변수, 함수, 메소드 및 클래스를 제공하는 코딩 수준의 추적이다. 전체 기능 호출 체 인 (기능 추적 : 다른 기능을 호출하는 기능)이 제공된다. 알고리즘 추적 C486은 알고리즘 분석과 결합 된 보안 데이터를 제공하는 소프트웨어 수준의 추적이다. 결과적 보안 결정 (승인 / 차단)은 결정 C847에 도달 한 방법 에 대한 로지스틱스 추적과 함께 제공된다. 결정 C847 생성에 기여한 각 요소에 대한 적절한 가중치가 포함된다. 그 후, RP2 C465는 생성 된 인지 결과에 관한 데이터를 처리를 위해 POE (Perception ObserverEmulator) C475로 전송한다. 도 660은 CTMP 내에서 RP2 (Raw Perception Production) C465의 동작에 대해 상세히 설명한다. 초기 단 계 5506은 도 659에서와 같이 해당 AC C808A 인스턴스에서 발생하는 입력 시스템 메타 데이터 C484 내에서 디버 깅 트레이스 C485 및 알고리즘 트레이스 C486의 인스턴스를 생성하기 위해 데이터를 언팩하기 위해 발생한다. 5508 단계에서 메트릭 프로세싱 C489는 LOM 의 변수를 리버스 엔지니어링하여 LOM 가 나타내는 인공 지능에서 인지를 추출한다. 그 후, 입력 시스템 메타 데이터 C484는 단계 5510에 의해 처리되며, 메타 데이터 C484는 SMS (System Metadata Separation) C487을 통해 의미 있는 보안 원인-효과 관계로 분리된다. 도 659에 의해 나타낸 바와 같이, RP2 C465는 생성 된 인지 결과에 관한 데이터를 처리를 위해 인지 관찰자 에뮬레이터 (POE)(C475)로 전송한다. 도 661은 인지 관찰자 에뮬레이터 (POE)(C475)의 동작에 대해 상세하게 설명하고, 인지 저장소 (PS)(C478)에 대 한 그것과 미가공 인지 생성 (RP2)(C465)의 관계를 포함한다. 메트릭 프로세싱 C489 및 SMS (System Metadata Separation) C487의 작동은 둘 다 PS C478에 저장된 인지 5512/5514/5516이 생성으로 이어진다. 결과적인 인지 5512/5514/5516은 주장 구성 (AC) C808A를 통해 목적 대체 을 생성하는 LOM의 132 모듈 식 응답을 나타 낸다. RP2 C465는 검색 기준으로 스토리지 검색 (SS) C480에 제공되는 비교 가능한 가변 형식 데이터 포인트를 생성한다. 이후 SS C480은 PS C478에 저장된 기존 인지와 일치를 찾기 위한 PS C478 검색을 수행한다. 실행 SS C480의 결과 C716이 생성되어 가중치 계산 C718으로 이어진다. 이러한 계산 C718은 PS C478에서 대응하는 인지 의 올바른 분포를 찾아서 신뢰 보안 주장(Confident Security Assertion) 8320을 생성 한 LOM 알고리즘 의 실행을 나타내는 비교 가능한 변수 형식을 복제하고 일치시키려고 시도한다. 도 662는 도 661로부터의 인지 관찰자 에뮬레이터 (POE)(C475) 로직을 계속한다. 스토리지 검색 (SS) C480에서 결과 C716을 생성 한 후 가중치 계산 C718이 완료되어 액티브한 승인 C731 또는 블록 C730 결정을 내리기 위해 인지 5512/5514/5516의 어플리케이션 C729로 이어진다. LOM 및 해당 LOM Log Aggregate 5502에 의해 생 성 된 목적 대체 은 데이터 구문 분석 C724를 수행하여 데이터 향상 로그 C723이 파생되어 어플리케이션 C729에 적용되어 입력 목적 대체 에 대한 긍정적 감정 (승인) C731 또는 부정적 감정 (블록) C730의 해석 이분법 을 달성한다. 어플리케이션 C729의 실행이 성공적으로 완료되면 CRE (Critical Decision Output) C462에 의해 규칙 실행 (RE) C461의 모듈식 출력과 병행하여 처리되는 override 수정 조치 C476이 발생한다. SCKD (Self-Critical Knowledge Density) C474 모듈은 보고 가능한 LOM Log Aggregate 5502의 범위를 넘어서는 알려지지 않은 잠재적 지식의 범위와 유형을 추정한다. 이런 식으로 처리 CTMP 인스턴스의 후속 비판적 사고 기능은 인스턴스에 의해 직접 알려지거나 알려지지 않은 모든 관련 지식의 잠재적 인 범위를 활용할 수 있 다. 도 663은 도 661의 인지 관찰자 에뮬레이터 (POE)(C475)의 실행과 병행하여 동작하는 메모리 웹 C460 프로세스 를 도시한다. LOM 에서 생성 한 신뢰 보안 주장(Confident Security Assertion) 8320은 추론 처리 C456에 모듈식 입력으로 제출된다. 추론 처리 C456은 LOM 가 DIP 8316에서 제공하는 프롬프트 8318에 응답하여 신 뢰 보안 주장(Confident Security Assertion) 8320을 생성하기로 결정한 방법을 처리한다. 추론 처리 C456의 처리 결론은 LOM의 132 실행 동작과 세 번째로 일치하는 규칙을 정의하는 추론 처리 C457의 실행이다. LOM의 132 실행 동작과 관련하여 규칙 동작에서 불일치가 발견되면 현재 기존 규칙이 수정되거나 새 규칙이 추가된다. 이러한 규칙은 나중에 해당 LOM 인스턴스에서 발견 된 의사 결정 동작을 비판하기 위해 CTMP 인스 턴스 내에서 사용된다. CRSE (Critical Rule Scope Extender) C458은 알려진 Perceptions를 활용하여 규칙 세 트의 '중요한 사고'범위를 확장하여 규칙 세트를 향상시켜 커렉트 룰(correct rules) C459를 생성한다. 커렉트 룰(correct rules) C459는 메모리 웹 C460의 운영 관할권 내에서 RSFS (규칙 구문 형식 분리) C499에 모듈 식 입력으로 제출된다. RSFS C499는 유형별로 커렉트 룰(correct rules) C459를 분리하고 구성한다. 따라서 RSFS C499 처리 후 모든 작업, 속성, 조건 및 개체가 별도로 나열된다. 이를 통해 CTMP 인스턴스는 카오틱 필 드에서 발견 된 부분과 발견되지 않은 부분을 식별 할 수 있다. 카오틱 필드 파싱 (CFP)(C535)는 LOM Log Aggregate 5502를 카오틱 필드로 참조되는 단일 스캔 가능 단위로 결합하고 형식화한다. 카오틱 필드는 MR (Memory Recognition) C501에 모듈식 입력으로 제출된다. MR C501은 RSFS C499의 실행 결과인 Original Rules C555도 수신한다. MR C501은 CFP C535에서 제공하는 카오틱 필드를 스캔하여 Original Rules C555에 정의 된 알 수 있는 개념을 인지한다. 이 MR C501 인스턴스 실행은 인지 된 규칙 세그먼트 C556을 생성한다. 그 후 RFP (규칙 이행 파서) C498은 MR C501에 의해 카오틱 필드 내에서 인지 또는 부족에 따라 태그가 지정된 Original Rules C555의 개별 부분을 수신한다. 그런 다음 RFP C498은 규칙 실행 (RE) C461에 따른 처리를 위해 혼돈 필드 에서 어떤 전체 규칙 집합 (모든 부분의 조합)이 충분히 인지되었는지를 논리적으로 추론 할 수 있다. RE C461의 실행이 성공적으로 완료되면 CDO (Critical Decision Output) C462에 의해 인지 관찰자 에뮬레이터 (POE)(C475)의 모듈 식 출력과 병렬로 처리되는 오버라이드 정정 작업(override corrective action) C476이 발 생한다. 도 664는 PS (Perception Storage) C478과 APDM (Automated Perception Discovery Mechanism) C467 사이의 논 리 흐름 상호 작용에 대해 상세히 설명한다. PS C478에는 인지의 추측된 미지 각도 C473, 인지의 모든 각도 C472, 인지의 암시 각도 C471 및 인지의 적용 각도 C470의 네 가지 인지의 하위 집합이 포함되어 있다. 인지의 적용 각도(C470)는 선택된 패턴 매칭 알고리즘 (SPMA), 이 경우 LOM 의 알고리즘 동작을 연구하여 직접 가 져온 인식이다. 인지의 암시 각도 C471은 인지의 적용 각도 470C에서 ID (Implication Derivation) C477 및 APDM C467의 모듈식 실행을 통해 파생된 인식이다. 인지의 모든 각도 C472는 인지의 적용 각도 C470 및 인지의 암시 각도(C471)에 포함되지 않은 CTMP 인스턴스에 대한 알려진 인지의 전체 범위를 나타낸다. 인지의 추 측된 미지 각도 C473는 존재할 것으로 예상되나 CTMP 인스턴스가 아직 SCKD (Self-Critical Knowledge Density) C474 모듈에 따라 발견하지 못한 인식 범위를 나타낸다. ID C477은 인지의 적용 각도 C470의 개별 메 트릭을 분석하여 인지의 암시 각도 C471을 결정론적으로 유도하는 한편, APDM C467은 창의성 모듈 112를 통해 인지의 각도(C650)를 창의적으로 변화시켜 초기 두 입력 가중치 C652를 병합하는 신규 반복(C65)을 생성한다. 따라서 APDM C467 처리와 관련된 모든 인지 각도 C650은 LOM의 132 주장 생성 (AC) C808A 모듈에 의해 생성된 신뢰 보안 주장(Confident Security Assertion) 8320에 해당하고 이를 나타낸다. 도 665은 CTMP 의 CRSE (Critical Rule Scope Extender) C458에 관한 동작 세부 사항에 대해 상세히 설명 한다. RA (합리적 어필)(C811A) 인스턴스는 LOM 내에서 작동하고 CC (Context Construction)(C817A)를 호출하여 LOM 로그 집계(aggregate)를 카오틱 필드 파싱(CFP)(C535)으로 처리한다. CFP는 메모리 인지 (MR) C501에서 참조하는 CC C817A의 모듈식 출력에서 카오틱 필드를 생성한다. 현재 규칙 C534는 이 경우 LOM 인 SPMA (Selected Pattern Matching Algorithm)의 현재 기능 상태를 나타내는 규칙 세트를 보인다. 현재 규칙 C534는 논리적 '흑백'규칙이 메트릭 기반 인지로 변환되는 규칙 구문 파생 (RSD) C504 모듈에 모듈 식 입 력으로 제출된다. 따라서 여러 규칙의 복잡한 배열은 다양한 그래디언트의 여러 메트릭을 통해 표현되는 단일 균일 인지로 변환된다. RSD C504의 모듈 식 출력은 PM (인지 매칭) C503에 모듈 식 입력으로 제공된다. PM C503 에서; CVF (Comparable Variable Format) 유닛은 RSD C504로부터 수신된 인지로부터 형성된다. 새로 형성된 CVF는 유사한 색인을 가진 인지 Storage (PS) C478에서 관련 인지를 조회하는 데 사용된다. 잠재적 일치 항목은 규칙 구문 생성 (RSG) C505에 모듈식 입력으로 제출된다. RSG C505는 인지 형식으로 저장된 이전에 확인 된 인 지를 수신하고 인지의 내부 메트릭 구성에 액세스한다. 이전에 확인된 인지 C468이 포함된 PS C478로부터 인지 가 수신된다. 이러한 그래디언트 기반 메트릭 측정 단위는 원래 인지의 입력 / 출력 정보 흐름을 에뮬레이트 하 는 이진 및 논리 규칙 세트로 변환된다. 따라서 RSG C505는 관련성이 있고 대중적이며 논리적 규칙으로 변환된 인지인 인지 규칙 C537을 생성한다. 인지 (원래 인지 형식)에 많은 '회색 영역'을 정의한 많은 복잡한 메트릭 관계가 있는 경우 '흑백'로컬 규칙은 규칙 세트 복잡성을 확장하여 이러한 '회색'영역을 포함한다. 따라서 인지 규칙 C537은 규칙 구문 형식 (RSF) 정의 모음에 의해 저장된다. 인지 규칙 C537은 메모리 인지 (MR) C501에 모 듈 식 입력으로 제출되며 CFP C535에 의해 생성 된 카오틱 필드에 대해 스캔 된다. 따라서 MR C501은 커렉트 룰 (Correct Rule) C533을 완성하는 추가 규칙 C536을 생성한다. 도 666는 CTMP 의 함의 도출 (ID) C477에 관한 동작 세부 사항에 대해 상세히 설명한다. 인지 저장소 (PS) (C478)의 인지의 적용 각도(C470)은 모듈식 입력으로 ID C477에 제출되어 인지의 암시 각도(C471)에 속하는 더 많은 인지를 생성한다. 인지의 적용 각도(C470)은 구체적으로 ID C477의 메트릭 조합(C493)으로 전송된다. 메트 릭 조합(C493)은 수신된 인지 각도(C650)를 메트릭 범주 (범위 C739, 유형 C740, 일관성 C741, 강도 C742)로 구분한다. 시스템 내 메트릭 가용성 및 참조가 반드시 이 네 가지 유형으로 제한되는 것은 아니다. 입력 인지 각도 C650은 LOM의 132 주장 생성 (AC)(C808A) 모듈에 의해 생성된 목적 대체와 관련이 있다. 메트릭 복 잡성 세트(C736)은 메트릭 확장 (ME)(C495)에 모듈식 입력으로 제출된다. ME C495를 사용하면 다중 및 다양한 인지 각도(C650)의 메트릭이 개별 데이터베이스 C739 / C740 / C741 / C742에 범주 적으로 저장된다. ME(C49 5)는 이전에 알려진 / 마주친 메트릭에서 추출된 세부사항 / 복잡성을 사용하여 수신된 메트릭의 현재 배치를 향상시킨다. 향상 및 복잡성 강화 완료 시, 메트릭은 메트릭 복잡성 세트 B(C737)로써 ME C495 모듈식 출력에 반환된 후, 도 667에 도시된 바와 같이 인지의 암시 각도(C471)에 저장되도록 인지 각도(C650)로 다시 변환된다. 도 667은 도 666의 개별 메트릭을 전체 인지 각도 C650으로 리버스 시키는 메트릭 변환 C494에 의해 처리되는 메트릭 복잡성 세트 B C737을 보여주면서 ID (Implication Derivation) C477의 논리 흐름을 계속한다. ID C477에 의해 수행 된 강화 및 변환 프로세스에도 불구하고, 결과적인 인지 각도 C650은 여전히 LOM의 132 Assertion Construction (AC) C808A 모듈에 의해 생성된 목적 대체를 상당히 정확하게 표현한다. 따라서 메트릭 변 환(C494) 프로세스는 새로 도출되거나 암시된 인지 각도(C650)를 인지 저장소 (PS)(C470) 내의 인지의 암시 각 도(C471)에 제출한다. 도 668은 CTMP 의 CDO (Critical Decision Output) C462와 관련된 운영 세부 사항에 대해 자세히 설명한 다. CDO C462는 CTMP 의 주요 브랜치인 POE (인지 Observer Emulator) C475 (직관 브랜치)와 규칙 실행 (RE) C461 (논리 브랜치)의 모듈식 출력을 수신한다. 각 브랜치 C475 / 461은 각각의 중요한 결정 C521 (주요 모듈 출력)과 해당하는 '메타-메타 데이터'C521을 제출하여 초기 결정에 도달 한 이유를 정당화하는 맥락 변수 를 제공한다. POE C475의 인지 C516을 나타내는 결정 세트 C521과 RE C461의 이행된 규칙 C517이 메타 데이터 분류 모듈 (MCM) C488에 제출된다. MCM C488은 전통적인 구문 기반 정보 분류를 사용하여 디버깅 및 알고리즘 추적을 개별 범주로 분리한다. 그런 다음 이러한 범주를 사용하여 보안 위험 및 주제와 상관 관계가 있는 별도 의 보안 대응을 구성하고 생성 할 수 있다. POE C475의 인지 C526을 나타내는 직관적 결정 C514와 RE C461의 이 행 규칙 C517을 나타내는 사고 결정 C515가 MCM C488에 의해 방향 결정 비교 (DDC) C512의 내부 처리 로직 5520에 제출된다. DDC C512의 내부 처리 로직 5520은 직관적 결정 C514와 사고 결정 C515 간의 확증 또는 충돌 을 확인한다. DDC C512는 정적 하드코딩 된 정책(SHP)의 '컷오프 변수'를 참조한다. 컷오프 변수가 직관적 결정 C514와 사고 결정 C515 (예: 90 % +) 사이의 유사성에 도달하지 않으면 직접 비교 취소 5524 지시어가 발 생하여 최종적으로 도 669에 도시된 것처럼 신뢰성 없는 투표 5544를 제출하는 터미널 출력 제어 (TOC) C513로 이어질 수 있다. 직접 비교 취소 5524 단계는 CTMP 가 RIP 의 입력 프롬프트 과 관련하여 내 부적으로 일관성 있게 작동 할 수 없음을 나타낸다. 내부 처리 로직 5520에 따라 '컷오프 변수가 충분히 충족 된 경우 최종 결정 출력 5522 단계가 호출되어 결정 C514 / C515를 TOC C513에 의해 수신 및 처리되는 단일 모 듈 출력으로 결합한다. 도 669는 도 668의 CDO (Critical Decision Output) C462의 논리 흐름을 계속하고 TOC (Terminal Output Control) C513의 동작 세부 사항을 상세하게 설명한다. TOC C513은 DDC (Direct Decision Comparison) C512가 (직접 비교 취소 5524 지시문 대신) 최종 결정 출력 5522를 제공 할 수 있는지 확인하는 프롬프트 5526으로 시 작한다. 프롬프트 5526에 대한 응답이 Yes 5528 인 경우 최종 결정 출력 552에서 DDC C512가 제공 한 결합 된 최종 결정은 TOC C513의 모듈 식 출력으로 제출되므로 최종 중요 결정 5542 출력으로 전체 CTMP 인스턴스 의 모듈 식 출력으로 제출된다. . 프롬프트 5526에 대한 응답이 No 5530 인 경우 단계 5532가 호출되어 자체적 으로 인지 매칭(PM 5532)의 실행을 호출하고 해당 결과를 가져온다. 이행된 규칙 C517은 규칙 실행 (RE) C461의 중요 결정 + 메타-메타 데이터 C521에서 추출된다. 규칙 C517은 규칙 구문 파생 (RSD) C504에 의해 인지로 변환 된다. 그런 다음 PM 5532는 메타-메타 데이터를 참조하여 프롬프트 에서 강력한 내부 중첩과 사용 된 인 지의 확증이 있는지 확인한다. 프롬프트 에 대한 응답이 YES 인 경우 CTMP 대신 모듈식 출 력으로 신뢰 없음 투표 5544를 나타낸다. 프롬프트 에 대한 응답이 No 이면 단계 5540이 활성화되 어 직관적 결정 C514와 사고 결정 C515 사이에서 인지된 가장 위험이 덜한 결정을 선택한다. 따라서 최종 중요 결정 5542는 CDO C462, TOC C513 및 CTMP 에 모듈 식 출력으로 제출된다. 단계 5534에서의 논리는 직관적 결정 C514와 사고 결정 C515 사이의 단일성 결여가 알고리즘 신뢰의 일반적인 부족으로 인해 또는 이 둘 사이의 매우 반대 관점으로 인해 발생 하는지를 결정하기 위해 발생한다. 따라서 후자가 발생할 경우 잠재적 최종 중요 결정 5542는 여전히 모듈식 출력으로 식별할 수 있다. 신뢰 없는 투표 5544는 항상 합리적 어필 (RA) C811A 내 신뢰도가 낮은 결과 C845 논리 경로로 이어진다. 최종 중요 결정 5542는 최종 중요 결정 5542의 알고리즘 신뢰 도에 따라 RA C811A 내에서 높은 신뢰 결과 (C846) 또는 낮은 신뢰 결과 (C845) 논리 경로로 이어질 수 있다. 도 670은 보안 위협 범위 8322에 기초한 자동화 리서치 메커니즘 (ARM) 처리를 도시한다. ARM은 LOM 의 132 일반 추정 및 의사 결정 기능을 향상시키기 위해 CKR 에 새로운 지식을 지속적으로 제공하려고 시 도한다. 보안 위협 범위 8322는 요청 되었으나 아직 사용할 수 없는 개념의 목록 C857B에서 알 수 있듯이 CKR 806에 관한 정보가 부족하거나 전혀 없다는 개념을 최종적으로 산출할 것으로 예상된다. 개념 정렬 및 우선 순 위 지정 (CSP) C821 B; 개념 정의는 세 개의 독립적 인 소스로부터 수신되며 정보 요청 (IR) C812B의 자원 (밴 드폭 등)의 우선 순위를 정하기 위해 집계된다. 이러한 모듈 IR C812B는 이 경우 보안 위협 범위 8322에서 구체 적으로 정의 된 정보를 얻기 위해 관련 소스에 액세스한다. 이러한 정보는 개념 유형에 따라 정의된다. 이러한 출처는 공개 뉴스 출처 C057C (공개 뉴스 기사 즉, 로이트, 뉴욕타임즈, 워싱턴 포스트 등), 공개 데이터 아카 이브 C857D (위키피디어, Quora 등의 정보 집계 모음) 및 소셜 미디어 C857E (예 : 페이스북, 트위터 피드 등) 로 나타난다. 이러한 정보 소스에 의해 제공된 데이터는 정보 정의가 요청한 개념 정의에 따라 정보 집계기 (IA) C821 B에서 수신되고 구문 분석된다. 검색 시간, 검색 소스와 같은 관련 메타 데이터가 유지된다. 그 후,정보는 CRA (Cross-Reference Analysis) C814B로 전송되며, 수신된 정보는 CKR 의 기존 지식을 고려하여 비교되고 구성된다. 이를 통해 CKR 이 현재 알고 있는 것과 모르는 것에 따라 신규 수신 정보가 평가되고 검증된다. 스타일로메트릭 스캐닝 (Stylometric Scanning, SS) (C808B)는 CRA C814B가 스타일러스 서명이 CKR 의 기존 지식으로 새로운 정보를 동화 할 것을 고려할 수 있는 보충 모듈이다. 누락 된 종속성 개념 C857F 는 초기 목표 개념을 이해하기 위한 토대로 논리적으로 이해되어야 하는 개념이다 (즉, 트럭 작동 방식을 이해 하려면 먼저 디젤 엔진 작동 방식을 연구하고 이해해야 함). 이러한 누락 된 개념은 처리를 위해 CSP C821 B로 전송된다. 활동 개념 목록 C857G는 CKR 내에서 가장 활동적으로 랭크 되는 인기 주제이다. 이러한 개념 C857G는 CCG (Creative Concept Generator) C820B로 전송 된 후 창의력 모듈 112를 통해 창의적으로 일치하여 새로운 잠재적 개념을 생성한다. 이 메커니즘은 이러한 혼합물 중 하나가 IR C812B에 연결된 소스 C857C, C857D, C857E에서 새로운 범위의 정보를 생성 할 가능성에 달려 있다. 스타일러스 사용 예: 신규 외부 데이터 (New Foreign Data)(C858A)는 알려진 CNN 기자가 제공 한 것으로 표시되어 있지만 군용 싱크 탱크의 시그니처와 매우 강력한 스타일이 일치를 보인다. 따라서, 그 내용은 주로 CKR 내에서 군용 싱크 탱크에 귀속되며, CNN으로부터 '공고'된 것으로 언급된다. 이를 통해 LOM 논리의 이후 실행 (예: CNN로부터의 컨텐츠라고 하는 미 래의 주장 불신)을 위한 추가 패턴 일치 및 음모 감지가 가능한다. 그 후, 내용이 CNN이 아닌 싱크 탱크에서 나 온 것처럼 단언 검증, 충돌 및 바이어스 평가가 평가된다. 도 671은 단계 8302에서 도 670으로부터 ASH 를 계속한다. 결과적으로 확인되지 않은 새로운 정보가 CKR 에서 저장되고 진행된다. CKR (Central Knowledge Retention) 648은 LOM의 데이터 기반 인텔리전스가 저 장 및 병합되는 곳이다. 정보 단위는 UKF (Unit Knowledge Format) C854F에 저장된다. UKF C854F는 사법적으로 분리 된 정보를 정의하기 위해 연결된 UKF 변형 체인으로 구성된다 (시간 및 소스는 동적으로 정의 됨). 지식 UKF 클러스터 C854F는 KCA C816D에 의해 처리되어 보안 위협 개념 8323을 형성한다. KCA (Knowledge Corroboration Analysis) 816D는 UKF Clustered 정보가 독단적 입장에 관한 증거를 확증하기 위해 비교되는 곳 이다. 이 알고리즘은 근거를 주장 할 때 증거를 부정하는 등 속성 소스의 신뢰성을 고려한다. 따라서 KCA C816D 의 처리가 완료된 후 CKR 은 토픽 8322에 대한 결정된 독단적 입장을 출력 할 수 있다. 도 672는 ARM 및 CKR 의 상세한 설명과 함께 도 671의 ASH 로 계속된다. 활동적인 개념 목록 C857G는 CKR 내에서 가장 활동적인 주제로 인기 있는 주제이다. 이러한 개념 C857G는 CCG (Creative Concept Generator) C820B로 전송 된 후 창의성 모듈 112를 통해 창의적으로 일치하여 새로운 잠재적 개념을 생 성한다. 도 673은 LOM이 보안에 관한 의미 있는 주장 및 결론을 추출하여 8308 단계에서 참조를 위해 AST 123에 제출되 는 보안 위협 지식을 생성하는 단계 8034를 도시한다. AST 123은 인공 익스플로잇으로 테스트 된 SED (Security Exploit Derivation) 8324 (보안 규칙 세트)를 수신한다. 익스플로잇이 수행 된 후 익스플로잇이 작동 한 경우 익스플로잇 DB(A192)에 통합되어야 하는 경우 결과 피드백 모듈이 결과를 제공한다.. 정보 공개 모듈은 다음 익 스플로잇이 어떻게 보여야 하는지에 대한 세부 사항을 창의성 모듈에 제공하며, 정보 공개 모듈과 익스플 로잇 DB A192 사이에 정보가 병합되며, 익스플로잇은 동일한 익스플로잇과 동시에 컴파일 된 보안 익스플로잇 배치(Complied Security Exploit Batch) A193으로 수행된다., 창의성 모듈은 정보 공개 모듈에 의한 결과에 기 초하여 이전 익스플로잇의 장점을 이용하고 익스플로잇의 알려진 취약점을 피하는 하이브리드 익스플로잇을 생 성한다. 도 674는 보안 위협 지식 이 LOM으로부터 AST 123으로 수신된 도 673으로부터 ASH 를 계속한다. 8326 단계에서 LOM 에 의해 개선 된 최신 버전의 AST 123은 I2GE 및 LIZARD 에 의해 참조된다. 도 675는 LASTARD 처리 AST 에 대한 세부 사항과 함께 도 674로부터 ASH 를 계속한다. 정적 핵심 C315는 주로 고정된 프로그램 모듈이 인간 프로그래머에 의해 하드 코딩 된 곳이다. 반복 모듈 C314는 동 적 셸 C198에서 모듈을 지능적으로 수정, 생성 및 삭제한다. 보안 성능에 대한 참조로 인공 보안 위협 (AST) 123을 사용하고 자동 코드 작성 방법을 처리하기 위해 반복 핵심(C347을 사용한다. 반복 핵심(C314)는 보안 개 선을 위해 동적 쉘(C198)을 반복하기 위한 주요 로직이다. 정적 핵심 복제 C346에서는 반 동적 외부 핵심 C329 를 포함한 정적 핵심 C315가 반복 지침의 기준으로 사용된다. 멀웨어 동작 정보는 DRR (Data Return Relay) C317을 통해 AST 123으로 전송되어 향후 반복에 도움이 된다. 도 676은 LIZARD 처리 AST 에 대한 세부 사항과 함께 도 675로부터 ASH 를 계속한다. 정적 핵심 C315 보안 규칙 세트 내에서 결과 피드백 및 정보 공개을 다시 AST 123으로 제공한다. 인공보안 위협 (AST) 123은 보안 규칙 세트의 효과를 테스트 하기 위한 가상 보안 시나리오를 제공한다. 보안 위협 은 보안 시나리오를 의미 있게 비교하기 위해 심각 도와 유형이 일관된다. 도 677은 I2GE 프로세싱 AST 에 대한 세부 사항과 함께 도 676의 ASH 를 계속한다. AST 123은 C867A에서 수신되어 보고서 5572를 보안 리뷰 모듈로 보내고 더 보내기을 통해 AST 123으로 다시 보낸다. 12GE 는 성숙되고 선택된 반복 진화 병렬 진화 경로를 갖는다. 반복 생성은 동일한 인공 보안 위 협 (AST) 123에 적응하며, 최고의 특성을 가진 경로는 결과적으로는 보안 위협에 가장 저항한다. 진화 경로 C867A : 사실상 포함되고 격리 된 일련의 규칙 세트 생성. 진화적 특성과 기준은 그러한 경로 X 특성 C867D에 의해 정의된다. 도 678은 단계 8328에서 ESC 으로부터 타겟 앱체인 의 실행 스트림 (코드)을 수신하는 LIZARD 로 ASH 처리를 계속한다. 8330 단계에서 LIZARD는 AST 123을 참조하는 반복 모듈의 호출을 반복한 다. 8332 단계는 한 번 AST 123의 공격을 받는 동안 안정적인 것으로 간주되면 LIZARD 은 다양한 에뮬레이 션을 위해 실행 스트림 (코드)을 I2GE 로 보낸다. 도 679는 ESC 을 통해 수신 된 타겟 앱체인 의 실행 을 수행하는 LIZARD 와 함께 ASH 를 계속한다. 반복 모듈(IM)(C314)는 동적 쉘(C198)의 모듈을 지능적으로 수정, 생성 및 제거한다. 보안 성능에 대한 참조로 인공 보안 위협 (AST) 123을 사용하고 자동 코드 작성 방법을 처리하기 위해 반복 핵심 (C347)를 사용한다. 반복 핵심(C347)는 보안 개선을 위해 동적 쉘(C198)을 반복하기 위한 기본 로직 이다. 반복 모듈 (IM) C314는 정적 핵심 (SC) C315를 사용하여 데이터에서 정의 된 목적에 따라 코드베이스를 구문 적으로 수정한다. 도 680은 병렬 진화 경로 C867AA 및 C867AB가 성숙되고 선택되는 방법 인 반복 진화 (I2GE 의 서브 세트) 를 수행하는 I2GE 와 함께 ASH 를 계속한다. 진화 경로 34C867AA 및 C867AB는 가상으로 포함되고 격리된 일련의 규칙 세트 생성이다. 진화 적 특성과 기준은 이러한 경로 특성 C867DB 및 C867DA에 의해 정의된 다. 반복 생성은 동일한 인공 보안 위협 (AST) 123에 적응하며, 최고의 특성을 가진 경로는 결과적으로는 보안 위협에 가장 저항한다. 버추얼 격리 390을 사용함으로써 두 진화 경로는 모두 자신의 성격 기준에 따라서만 반 복되도록 보장하기 위해 가상으로 격리된다. 모니터링 / 상호 작용 시스템 C868D는 AST 123에서 개념적 데이터 위험 트리거를 주입하는 플랫폼이다. 도 681은 단계 8332에서 ASH 를 도시한다. 일단 AST 123의 공격 하에서 안정된 것으로 간주되면, LIZARD 는 다양한 에뮬레이션을 위해 실행 스트림 (코드)을 I2GE 로 전송한다. I2GE 는 8334 단계에서 Target 앱체인 의 강화 된 실행 스트림 (코드)을 수신하고 I2GE 는 8336 단계의 진화 경로를 통해 AST 123으로 코드의 다양한 에뮬레이션을 수행한다. 8338 단계에서 실행 스트림 (코드)이 I2GE의 변형 에뮬레이 션을 통과하는가?를 확인한다. 통과 및 통과하지 않음. 도 682는 병렬 진화 경로 C867AA 및 C867AB가 성숙되고 선택되는 방법인 반복 진화 (I2GE 의 서브 세트)를 수행하는 I2GE 와 함께 도 681의 ASH 를 계속한다. 진화 경로 34C867AA 및 C867AB는 가상으로 포함 되고 격리된 일련의 규칙 세트 생성이다. 진화적 특성과 기준은 이러한 경로 특성 C867DB 및 C867DA에 의해 정 의된다. 반복 생성은 동일한 인공 보안 위협 (AST) 123에 적응하며, 최고의 특성을 가진 경로는 결과적으로는 보안 위협에 가장 저항한다. 버추얼 격리 390을 사용함으로써 두 진화 경로는 모두 자신의 성격 기준에 따라서 만 반복되도록 보장하기 위해 가상으로 격리된다. 모니터링 / 상호 작용 시스템 C868D는 AST 123에서 개념적 데 이터 위험 트리거를 주입하는 플랫폼이다. 반복 결론 프로세서 5554는 다음의 출력 결과를 제공한다: 통과 및 통과하지 않음. (그림 682에 8348 및 8342 표시가 누락됨). 도 683은 ASH (앱체인 보안 하드닝) 8044 프로세스를 종료한다. 8338 단계에서 실행 스트림 (코드)이 I2GE의 변 형 에뮬레이션을 통과합니까? . 만약 통과하지 못하면, 실행 스트림 (코드)은 LIZARD의 최신 단계이 며, 8346 단계에서 AST 123을 통해 이해되는 LOM의 132 기준에 따라 재 프로그램 된다. 8344 단계에서 통과 하는 경우 DPA (배포 패치 어셈블리) 6260 통해 강화된 보안 구성을 포함하는 배포 패치를 생성하고 8348 단계에서 타겟 앱체인 의 커스텀체인 생태계 빌더 (커스텀체인 Ecosystem Builder; CEB) 584에 앱체인 정 정 패치를 배포한다. 도 684는 선택된 앱체인 또는 레거시 프로그램이 다양한 특정 규정 (예를 들어, REST API 준수 등)을 준 수 함을 보장하는 앱체인 Regulatory Compliance (ARC) 8046을 도시한다. 8350 단계에서 LIZARD 은 구문 모듈 C35를 통해 타겟 앱체인 의 구문을 해석하고 8352 단계에서 목적 모듈 C36을 통해 타겟 앱체인의 목적 계층 맵 (PHM) 8354를 생성한다. 8358 단계에서 LIZARD 은 시스템 규정 및 지침의 구문을 해석하고 목적 모듈 C36을 통해 시스템 규정 및 지침의 목적 계층 맵 (PHM) 8362를 생성한다. 도 685는 ATM에 의해 시스템 규정 및 가이드라인을 목적 계층 맵으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 시스템 규정 및 가이드라인은 LUIGI으로부터 외 부 핵심 (OC) (C329)의 관할에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓸 수 있 는 프레임워크를 제공한다. 코드 작성; 목적 모듈 (PM) C36에서 복합 목적 형식(C325)을 수신한다. 복합 목적 형식(C325)는 '의사 코드'라고도 하는 임의 코드 구문으로 작성된다. 의사 코드는 if / else 문, while 루프 등 모든 프로그래밍 언어에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼 함수는 의사 코드를 원하는 목표 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 읽기; SM C35는 이러한 코드의 기능을 위한 목적을 도출하기 위해 PM C36에 대한 컴퓨터 코드의 구문 해석을 제공한다. 시스템 규정 및 가이드 라인은 코드 번역(C321)에 의해 데이터 스트림 A0 포맷으로 수신된다. 코드 번역(C321)은 SM C35에 서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역(C321)은 또한 알 려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수를 수행한다. 코드 번역(C321)의 완료된 실행 결과는 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323은 코드 논리를 단순한 폼으로 감소시켜 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수의 맵을 생성한다. 그러므로 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 출력이 목적 모듈 (PM) C36의 반복 해석 C328에 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35 가 해석 한 관련 코드 섹션의 의도 된 기능을 적절히 설명한다. PM C36은 또한 데이터 내에 비밀리에 잠긴 코드 조각 (이진 / ASCII 등)을 감지 할 수 있다. 반복 해석 C328은 모든 상호 연결된 함수를 반복하여 목적 연관성 C326을 참조하여 해석된 목적 정의 (복합 목적 형식 C325에서)를 생성한다. 내부 핵심 (IC) C333은 자동 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍 한 LIZARD의 영 역이다. IC C333의 핵심 코드 C335 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 사용할 수 있도록 표준화 된 라이브러리 및 스크립트를 제공함으로써 SM C35 및 PM C36에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정 의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 686는 도 685로부터의 논리 흐름을 계속하여 시스템 규정 및 가이드라인을 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36 의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 목적 연관성(C326)을 참조하여 상호 연결된 모든 함수 를 반복하여 해석된 목적 정의를 생성한다. 목적 정의 출력은 PM C36, 즉 외부 핵심 (OC) C329, 따라서 LIZARD에 대한 모듈 출력으로 제출된 복합 용도 형식 C325에 있다. 출력은 시스템 규정 및 가이드라인 의 복합 목적 형식 (Complex Purpose Format) C325 버전으로서 제공되는 목적 계층 맵 으로 라벨 링 된다. 동일한 정의와 내부 핵심 (IC) C333의 어플리케이션이 앞서 언급한 기능 및 모듈에 적용된다. 도 687은 도 686으로부터의 논리 흐름을 계속하고, 단계 8364에서 목적 계층 맵 8362 (시스템 규정 및 지침 8356으로부터 수신 됨) 및 목적 계층 맵 8354 (타겟 앱체인 으로부터 수신 됨)를 이용하여 목적 대 목적 대칭 처리 (P2SP) 7000 내에서 타겟 앱체인 에서 파생된 맵 내의 목적 중 어떤 것이 시스템 규정 및 지침 목적과 충돌하는지를 결정한다. 충돌이 발견되지 않으면 8370 단계에서 타겟 앱체인은 시스템 규정 및 지침을 준수한다. 충돌이 발견된 경우, 8372 단계에서 LUIGI 은 시스템 규정 및 지침 8356에 대한 앱체인 위반을 통보 받는다. 도 688은 단계 8374에서도 687로부터의 논리 흐름을 계속하여 LUIGI 가 문제의 앱체인이 시스템 규정 및 지침 8356을 위반한다는 것을 독립적으로 확인했는지를 판정한다. 확인되면, 타겟 앱체인 의 목적 계층 맵 8354를 조정하여 시스템 규정 및 지침 8356의 목적 계층 맵 8362과 매치 시킨다. 확인되지 않은 경우 ARC (따라서 SPSI )과 LUIGI 이 앱체인의 규정 준수에 동의하지 않는 이유를 알아보 기 위해 리뷰 세션이 시작된다. 도 689는 단계 8380에서도 688로부터의 논리 흐름을 계속한다. PRP 7050 내에서 확인됨에 기초한 시스템 규정 및 지침 8356의 목적 계층 맵 8362와 일치하도록 타겟 앱체인 의 목적 계층 맵 8354를 조정한다. PRP 7050은 업그레이드 된 목적 맵 8382를 LIZARD 으로 보낸다. LIZARD 은 업그레이드 된 목적 맵을 앱체인 Syntax로 변환하여 업그레이드 된 앱체인 에 배포한다.도 690은 업그레이드 된 목적 맵 을 업그레이드 된 앱 체인 으로 변환하기 위한 LIZARD 의 동 작에 관한 세부 사항을 도시한다. 업그레이드 된 목적 맵 는 복합 목적 형식 C325으로 존재하며 LIZARD 의 외부 핵심 (OC) C329 내에서 목적 모듈 C36의 반복 확장 C327에 제출된다. 반복 확장 C327은 세부 목표 와 복잡성을 추가하여 간단한 목표를 특정 복잡한 목적 정의로 발전시킨다. 그러므로 구문 모듈 (SM) C35의 논 리 유도 C320에 제출되기 전에 입력의 최대 목적 연관성 C326 가능성이 실현되어 복합 목적 형식 C325으로 유지 된다. 내부 핵심 (IC) C333의 핵심 코드 C335 요소에는 기본 프레임 워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함되어 있다. 따라서 핵심 코드 C335는 기본 기능을 가능하게 하는 표준화 된 라이브러리 및 스크립트를 제공하여 SM C35 및 PM C36에 대한 일반 작업 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정 의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 691은 업그레이드된 목적 맵을 업그레이드 된 앱체인 으로 변환하기 위한 LIZARD 의 동작 을 설명하기 위해 도 690으로부터의 논리 흐름을 계속한다. 입력 데이터는 PM (Purpose Module) C36에서 복합 목적 형식 C325로 수신되고 SM (Syntax Module) C35의 논리 유도 C320으로 전송된다. 논리 유도 C320은 초기 단순한 함수에서 논리적으로 필요한 함수를 유도한다. 즉, 함수가 단순한 부모 함수의 암시로 인해 파생 함수로 형성 될 수 있는 경우; 논리 파생 C320에 의해 형성된다. 생성된 결과는 정의된 복합 목적 형식 C325 데이터에 따라 작성된 함수 종속성 트리이다. 논리 도출 C320은 내부 핵심 (IC) C333의 핵심 코드 C335 요소에서 상속 된 규칙 및 구문 C322 정의에 따라 작동한다. 논리 도출 C320는 출력을 코드 번역 C321에 제출한다. 코드 번역 C321은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역 C321은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수도 수행한다. 따라서 PM C36은 SM C35를 호출 하여 코드 번역 C321을 통해 입력 업그레이드 된 목적 맵의 결과적 앱체인 구문 버전을 생성한다. 코드 번역 C321에서 마지막으로 생성되는 결과적 업그레이드 된 앱체인 는 SM C35, 외부 핵심 (OC) C329 및 LIZARD 의 모듈식 출력이다. 도 692는 도 691의 논리 흐름을 계속하여 업그레이드 된 목적 맵을 앱체인 구문로 변환하여 업그레이드된 앱체인를 생성하는 LIZARD의 작동을 도시한다. 배포 패치 어셈블리(DPA) 모듈은 앱체인 정정 패치을 생성하고 8386 단계 매포 앱체인 정정 패치를 CEB로 배포에서 커스텀체인 생태계 빌더 (CEB)로 배포된다. 도 693은 DLU 1160에서 발견 된 진단 정보를 처리하는 DLUA (진단 로그 단위 분석) 8048을 보여준다. 8388 단계 에서 LOM의 132 서브모듈 ARM 로부터 DLL 1160을 수신 한 후 8390 단계에서 CKR 에 저장하고 충돌 / 버그 / 오류 / 문제 등과 관련된 로그에 필터링한다. 8396 단계에서 CKR 에서 발견되는 다른 로그를 참조 하여 모든 오류 관련 로그에 대한 컨텍스트를 도출한다. LIZARD 은 8397 단계에서 오류를 포함하는 현재 상황 별 동작에 대한 목적 계층 맵 8398을 도출한다 (도 693에서 8396으로 잘못 표시됨). 도 694는 단계 8400 LOM의 132 서브 모듈 ARM 으로부터 수신 DLU 를 도시하고 이를 DLU 1182 (오타 DLUR)에 저장하기 위해 도 693으로부터의 논리 흐름을 계속한다. ARM은 LOM의 132 일반 추정 및 의사 결정 기능을 향상시키기 위해 CKR 에 새로운 지식을 지속적으로 제공하려고 시도한다. 모듈 IR C812B는 이 경우 보안 위협 범위 8322에서 구체적으로 정의 된 정보를 얻기 위해 관련 소스에 액세스한다. 이러한 정보는 개념 유형에 따라 정의된다. 이러한 출처는 공개 뉴스 출처 C857C (공개 뉴스 기사 즉, 로이트, 뉴욕타임즈, 워싱턴 포스트 등), 공개 데이터 아카이브 C857D (위키피디어, Quora 등의 정보 집계 모음) 및 소셜 미디어 C857E (예: 페이스북, 트위터 피드 등)로 나타난다. 이러한 정보 소스에 의해 제공된 데이터는 정보 정의가 요청한 개념 정 의에 따라 정보 집계기 (IA) C821 B에서 수신되고 구문 분석된다. 검색 시간, 검색 소스와 같은 관련 메타 데이 터가 유지된다. 그 후, 정보는 CRA (Cross-Reference Analysis) C814B로 전송되며, 수신된 정보는 CKR 의 기존 지식을 고려하여 비교되고 구성된다. 이를 통해 CKR 이 현재 알고 있는 것과 모르는 것에 따라 신규 수신 정보가 평가되고 검증된다. 스타일로메트릭 스캐닝 (Stylometric Scanning, SS) (C808B)는 CRA C814B가 스타일러스 서명이 CKR 의 기존 지식으로 새로운 정보를 동화 할 것을 고려할 수 있는 보충 모듈이다. 도 695는 충돌 / 버그 / 오류 / 문제 등과 관련된 로그의 단계 8402 필터를 도시하기 위해 도 694로부터의 논리 흐름을 계속한다. 8404 단계에서는 UKF 클러스터 필터링 5578을 통해 충돌 / 버그 / 오류 / 문제 등과 관련된 DLU 기반 정보를 요청한다. UKF 클러스터 보존 C854F는 UKF 클러스터 필터링 5578에 입력을 제공한다. CKR (Central Knowledge Retention) 648은 LOM의 132 개 데이터 기반 인텔리전스가 저장 및 병합되는 곳이다. 정보 단위는 UKF (Unit Knowledge Format)에 저장되며 UKF1 5580, UKF2 5582, UKF3 5584의 세 가지 유형이 있다. UKF2 5582B는 타겟 정보가 규칙 구문 형식 (RSF) C538에 저장되고 값 5592로 강조 표시되는 메인 포맷이다. 색인 5586은 디지털 저장 및 처리 호환 / 불만 기준점으로, 대규모 데이터 수집에 대한 리소스 효율적인 참조를 허용한다. 이 메인 정보 블록은 타임 스탬프 5590을 참조하며, 이는 UKF1 8550으로 알려진 색인 5586을 통한 별 도의 지식 단위에 대한 참조이다. 이러한 유닛은 UKF2 5582와 동일한 타임 스탬프 5590 섹션을 보유하지 않고, 대신 RSF C538 형식의 값 5592 섹터에 타임 스탬프에 대한 다수의 정보를 저장한다. RSF (규칙 구문 형식) C538 은 참조 규칙을 계속 추적하기 위한 일련의 구문 표준 세트이다. RSF C538 내의 여러 규칙 단위를 사용하여 단 일 객체 또는 동작을 설명 할 수 있다. UKF1 5580은 소스 특성 5588 섹터를 포함하며, 이는 UKF3 5584 인스턴스 의 인덱스 5586에 대한 참조이다. 이러한 단위 UKF3 5584는 타임 스탬프 섹션이 있지만 소스 속성 섹션이 없으 므로 UKF1 5580의 인버스이다. UKF3 5584가 RSF C538의 Value 5592 섹터에 Source Attribution 5588 및 5588 컨텐츠를 저장했기 때문이다. 소스 속성은 클레임 된 정보 소스를 추적하는 복잡한 데이터의 모음이다. 이러한 출처는 KCA (Knowledge Corroboration Analysis) C816D에서 처리 된 대로 확증 및 부정 요인으로 인해 신뢰성 및 진위 상태가 주어진다. 따라서 UKF 클러스터 5581 (도 695에 표시되어 있지 않음)은 관할권적으로 분리된 정"}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "보를 정의하기 위해 연결된 UKF 변형 체인으로 구성된다 (시간 및 소스는 동적으로 정의 됨). 요약: UKF2 5582 에는 메인 타겟 정보가 포함되어 있다. UKF1 5580은 타임 스탬프 정보를 포함하므로 무한 후퇴를 피하기 위해 타임 스탬프 필드 자체를 생략한다. UKF3 5584는 소스 속성 정보를 포함하므로 무한 후퇴를 피하기 위해 소스 필드 자체를 생략한다. 모든 UKF2 5582에는 최소한 하나의 UKF1 5580과 하나의 UKF3 5584가 수반되어야 한다. 그렇지 않으면 클러스터 (시퀀스)가 불완전한 것으로 간주되며 그 정보는 LOM (Systemwide General Logic)에서 아직 처리 할 수 없다. 중앙 UKF2 5582 (중앙 타겟 정보 포함)와 해당 UKF1 5580 및 UKF3 5584 장치 사이에는 연결된 다리 역할을 하는 UKF2 5582 장치가 있을 수 있다. KCA (Knowledge Corroboration Analysis) C816D는 독선적 입장에 관한 증거를 확증하기 위해 UKF Clustered 정보를 비교하는 곳이다. 이 알고리즘은 그러한 클레 임이 발생하거나 증거를 부정할 때, 소스 속성의 신뢰성을 고려한다. CKR 은 거짓으로 판단된 정보조차도 미래에 진실과 거짓을 구별하는 데 유용 할 수 있으므로 정보를 절대 삭제하지 않는다. 도 696은 단계 8396에서 도 695로부터의 논리를 계속하여 CKR 에서 발견 된 다른 로그의 참조를 통해 모든 에러 관련 로그에 대한 컨텍스트를 도출한다. 8406 단계에서 모든 오류 관련 로그를 반복하고 8408 단계에서 선 택한 오류 로그와 관련된 로그 기반 정보를 CKR 에서 검색한다. 단계 8410에서, 컨텍스트 화 된 행동이 오 류 관련 로그 보유 (ERLR) 8412에 추가된다. 도 697은 단계 8414에서 진단 로그 유닛 분석 (DLUA) 8048을 도시하며, 여기서 LIZARD 은 오류를 포함하는 현재 컨텍스트 화 된 행동에 대한 목적 계층 맵 8416을 도출하고 단계 8418에서 오류를 생성하는 실행 스트림 (코드)의 일부는 타겟 앱체인 에서 검색된다. 실행 세그먼트 (코드)의 선택된 부분은 8420에서 IEC (Innate Error Correction) 8050의 사용자 지정 호출을 통해 처리된다. 정제된 실행 세그먼트 는 단계 8424에서 정확한 실행을 테스트하기 위해 전체 실행 스트림 내에서 I2GE 의 가상화 된 환경에서 실행된다. 도 698은 오류 관련 로그 보유(ERLR)의 모든 컨텐츠를 목적 계층 맵으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 오류 관련 로그 보유(ERLR)의 컨텐츠는 외부 핵심 (OC)(C329)의 관할권에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓸 수 있는 프레 임워크를 제공한다. 코드 작성; 목적 모듈 (PM) C36에서 복합 목적 형식(C325)을 수신한다. 복합 목적 형식 (C325)는 '의사 코드'라고도 하는 임의 코드 구문으로 작성된다. 의사 코드는 if / else 문, while 루프 등 모 든 프로그래밍 언어에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼 함수는 의사 코드를 원 하는 목표 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 읽기; SM C35는 이러한 코드의 기 능을 위한 목적을 도출하기 위해 PM C36에 대한 컴퓨터 코드의 구문 해석을 제공한다. 오류 관련 로그 보유 (ERLR)는 코드 번역(C321)에 의해 데이터 스트림 A0 포맷으로 수신된다. 코드 번역(C321)은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역(C321)은 또 한 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수를 수행한다. 코드 번역(C321)의 완료된 실행 결 과는 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323은 코드 논리를 단순한 폼으로 감소시켜 규칙 및 구 문 C322의 정의에 따라 상호 연결된 함수의 맵을 생성한다. 그러므로 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 출력이 목적 모듈 (PM) C36의 반복 해석 C328에 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35가 해석 한 관련 코드 섹션의 의도 된 기능을 적절히 설명한다. PM C36은 또한 데이터 내에 비밀리에 잠긴 코드 조각 (이진 / ASCII 등)을 감지 할 수 있다. 반복 해석 C328은 모든 상호 연결된 함수를 반복하여 목적 연 관성 C326을 참조하여 해석된 목적 정의 (복합 목적 형식 C325에서)를 생성한다. 내부 핵심 (IC) C333은 자동 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍 한 LIZARD(12 0)의 영역이다. IC C333의 핵심 코드 C335 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 균형조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기 능을 사용할 수 있도록 표준화 된 라이브러리 및 스크립트를 제공함으로써 SM C35 및 PM C36에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러 한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 699는 도 698로부터의 논리 흐름을 계속하여 오류 관련 로그 보유(ERLR)의 모든 컨텐츠를 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 목적 연관성C326을 참조하여 상호 연결 된 모든 함수를 반복하여 해석된 목적 정의를 생성한다. 목적 정의 출력은 PM C36, 즉 외부 핵심 (OC) C329, 따 라서 LIZARD에 대한 모듈 출력으로 제출 된 복합 용도 형식 C325에 있다. 출력은 오류 관련 로그 보유 (ERLR)의 복합 목적 형식 (Complex Purpose Format) C325 버전으로서 제공되는 목적 계층 맵 으로 라벨링 된다. 동일한 정의와 내부 핵심 (IC) C333의 어플리케이션이 앞서 언급한 기능 및 모듈에 적용된다. 도 700은 진단 로그 유닛분석(DLUA , Diagnostic Log Unit Analysis) 8048, 에러를 생성하는 실행 세그먼트 (코드)의 일부가 타겟 앱체인 으로부터 검색되는 단계 8418 을 도시한다. 8432 단계에서 앱체인 순서로 오류 관련 로그 보유 (ERLR) 8430에서 모든 컨텍스트 화 된 오류 관련 로그(Contextualized Error Related Logs)를 반복하고, ‘선택된 에러 관련 로그 연관 앱체인이 검색 되었습니까?’의 체크를 수행한다. 예 이면 8444 ‘선택한 오류 관련 로그에 관한 위치 정보가 스캔되었는가’를 수행한다. 아니오인 경 우 ‘메타체인에서 앱체인 캐시 위치를 통해 앱체인 위치를 검색’하고 CCG (Content Claim Generator) 을 통해 앱체인의 내용에 대한 요청을 생성한다. 도 701은 단계 8456 ‘ERLR 8430으로부터의 로그에 저장된 정보 및 실행 스트림에 관한 스캔된 메타 데이터에 관한 세부 사항에 대해서는 실행 스트림의 실행 세그먼트를 스캔한다’ 와 실행 스트림과 관련하여 스캔된 메타 데이터에서 도 700의 논리를 계속한다. 단계 8450에서 ‘선택된 에러 관련 로그와 관련된 위치 정보가 스 캔에서 발견되었는가?’를 체크한다. 예인 경우 8420 단계 ‘선택된 실행 세그먼트(코드)의 부분을 IEC의 커스텀 호출을 통해 처리’로 진행한다. 아니오, 8446 단계’ 루프를 다음 사용 가능한 컨텍 스트 화 된 오류로 진행 ‘로 진행하고 8448 단계에서 ‘앱체인 순서대로 ERLR 8430의 모든 컨텍스트 화 된 오 류 관련 로그를 반복’한다. 도 702는 단계 8460 ‘정제 된 실행 스트림 세그먼트 는 선천적으로 정확한 실행을 테스트하기 위해 전체 실행 스트림 내에서 I2GE 의 가상화 된 환경에서 실행된다’로 도 701의 논리를 계속한다. 8466 단계에서 ‘정제된 실행 세그먼트가 올바르게 작동 했는가?’에 대한 점검이 수행된다. 예인 경우, LIZARD는 단계 8464에서 정제된 실행 세그먼트 8462에 대한 목적 계층 맵을 도출한다. 아니오인 경우, 단계 8476에서 ‘ DLUA의 이 인스턴스가 DLUA에서 DLU 시작에 의해 호출 되었습니까’에 대한 점검이 이루어진다. 예인 경 우, 단계 8474에서 (도 702에서 8476로 잘못 표시됨) 모듈식 출력 널 (null)로 모듈 실행을 종료하십시오. 아니 오인 경우, DLU 1182에 Meta-DLU를 제출한다. 도 703은 단계 8420 ‘실행 세그먼트 (코드)의 선택된 부분은 IEC (Innate Error Correction) 8050의 커스텀 호출을 통해 처리된다’와 함께 도 702로부터의 논리를 계속한다. 정제 된 실행 스트림 세그먼트 8462는 실행 스트림 내의 적절한 위치에 설치된다. 정제 된 실행 스트림은 8480에서 에뮬레이션 처리를 위해 I2GE 로 전송된다. 도 704는 단계 8460 ’정제 된 실행 스트림 세그먼트 는 선천적으로 정확한 실행을 테스트하기 위해 전체 실행 스트림 내에서 I2GE 의 가상화 된 환경에서 실행된다’로 도 703의 논리를 계속한다. 정제된 실행 스 트림 AO 8480은 프로세스를 시작하기 위해 진화 경로 A C867AA 및 진화 경로 B C867AB에 의해 수신된다. I2GE 는 병렬 진화 경로 C867AA 및 C867AB가 성숙되고 선택되는 방법인 반복 진화 (I2GE 의 서브 세트)를 수행한다. 진화 경로 34C867AA 및 C867AB는 가상으로 포함되고 격리된 일련의 규칙 세트 생성이다. 진화적 특성 과 기준은 이러한 경로 특성 C867DB 및 C867DA에 의해 정의된다. 반복 생성은 동일한 인공 보안 위협 (AST) 123 에 적응하며, 최고의 특성을 가진 경로는 결과적으로는 보안 위협에 가장 저항한다. 버추얼 격리 390을 사용함 으로써 두 진화 경로는 모두 자신의 성격 기준에 따라서만 반복되도록 보장하기 위해 가상으로 격리된다. 모니 터링 / 상호 작용 시스템 C868D는 AST 123에서 개념적 데이터 위험 트리거를 주입하는 플랫폼이다. 반복 결론 프로세서 5554는 다음의 출력 결과를 제공한다: 통과 및 통과하지 않음. (그림 682에 8348 및 8342 표시가 누락됨). 도 705는 단계 8486에서 에러를 포함하는 현재 컨텍스트 화 된 행동에 대해 LIZARD 가 목적 계층 맵 을 구동하는 도 704의 논리를 계속한다. 단계 8490에서는 목적 재정렬 처리 (PRP) 내에서 정제 된 실행 세그먼트의 맵 8494를 포함하도록 타겟 앱 체인의 목적 계층 맵을 조정하여 업그레이드 된 목적 맵 을 생성한다. LIZARD는 또한 단계 8492에서 정제 된 실행 세그먼트 8462에 대한 목적 계층 맵 8494를 도 출한다. 단계 8490에서 목적 재정렬 처리 (PRP) 내에서 정제 된 실행 세그먼트의 맵 8494를 포함하도록 타겟 앱 체인의 목적 계층 맵을 조정하여 업그레이드 된 목적 맵 을 생성한다. 단계에서 LIZARD는 또한 정제 된 실행 세그먼트 8462에 대한 목적 계층 맵 0494를 도출한다. 도 706은 컨텍스트 화 된 잉러 로그를 목적 계층 맵으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 컨텍스트 화 된 에러 로그는 외부 핵심 (OC) (C329)의 관할에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성; 목적 모듈 (PM) C36에서 복합 목적 형식(C325)을 수신한다. 복합 목적 형식(C325)는 '의사 코드'라고도 하는 임의 코드 구 문으로 작성된다. 의사 코드는 if / else 문, while 루프 등 모든 프로그래밍 언어에서 가장 일반적인 계산 연 산의 기본 구현을 포함한다. 그 후 헬퍼 함수는 의사 코드를 원하는 목표 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 읽기; SM C35는 이러한 코드의 기능을 위한 목적을 도출하기 위해 PM C36에 대한 컴퓨터 코드의 구문 해석을 제공한다. 컨텍스트 화 된 에러 로그는 코드 번역(C321)에 의해 믹스된 실행/ 데이터 스트림 포맷으로 수신된다. 코드 번역(C321)은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드 를 알려진 임의의 계산 언어로 변환한다. 코드 번역(C321)은 또한 알려진 계산 언어를 임의의 구문 유형으로 변 환하는 역함수를 수행한다. 코드 번역(C321)의 완료된 실행 결과는 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323은 코드 논리를 단순한 폼으로 감소시켜 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수의 맵을 생성한다. 그러므로 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 출력이 목적 모듈 (PM) C36의 반복 해석 C328에 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35가 해석 한 관련 코드 섹션의 의도 된 기능을 적 절히 설명한다. PM C36은 또한 데이터 내에 비밀리에 잠긴 코드 조각 (이진 / ASCII 등)을 감지 할 수 있다. 반 복 해석 C328은 모든 상호 연결된 함수를 반복하여 목적 연관성 C326을 참조하여 해석된 목적 정의 (복합 목적 형식 C325에서)를 생성한다. 내부 핵심 (IC) C333은 자동 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분 야의 전문가가 직접 독점적으로 프로그래밍한 LIZARD의 영역이다. IC C333의 핵심 코드 C335 요소에는 기 본 프레임워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 사용할 수 있도록 표준화 된 라이브러리 및 스 크립트를 제공함으로써 SM C35 및 PM C36에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스템 목 표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 707은 도 706으로부터의 논리 흐름을 계속하여 컨텍스트 화 된 에러 로그의 모든 컨텐츠를 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 목적 연관성C326을 참조하여 상호 연결 된 모든 함수를 반복하여 해석된 목적 정의를 생성한다. 목적 정의 출력은 PM C36, 즉 외부 핵심 (OC) C329, 따 라서 LIZARD에 대한 모듈 출력으로 제출 된 복합 용도 형식 C325에 있다. 출력은 컨텍스트 화 된 에러 로 그의 복합 목적 형식 (Complex Purpose Format) C325 버전으로서 제공되는 목적 계층 맵 으로 라 벨링 된다. 동일한 정의와 내부 핵심 (IC) C333의 어플리케이션이 앞서 언급한 기능 및 모듈에 적용된다. 도 708은 정제된 실행 세그먼트의 모든 컨텐츠를 목적 계층 맵으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 정제된 실행 세그먼트의 컨텐츠는 외부 핵심 (OC)(C329)의 관할권에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성; 목적 모듈 (PM) C36에서 복합 목적 형식(C325)을 수신한다. 복합 목적 형식(C325)는 '의사 코드'라고도 하는 임의 코드 구문으로 작성된다. 의사 코드는 if / else 문, while 루프 등 모든 프로그래밍 언어에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼 함수는 의사 코드를 원하는 목표 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 읽기; SM C35는 이러한 코드의 기능을 위한 목적을 도출하기 위 해 PM C36에 대한 컴퓨터 코드의 구문 해석을 제공한다. 정제된 실행 세그먼트는 코드 번역(C321)에 의해 실행 스트림 포맷으로 수신된다. 코드 번역(C321)은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려 진 임의의 계산 언어로 변환한다. 코드 번역(C321)은 또한 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수를 수행한다. 코드 번역(C321)의 완료된 실행 결과는 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323은 코드 논리를 단순한 폼으로 감소시켜 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수의 맵을 생성한 다. 그러므로 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 출력이 목적 모듈 (PM) C36의 반복 해석 C328에 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35가 해석 한 관련 코드 섹션의 의도 된 기능을 적절히 설명한다. PM C36은 또한 데이터 내에 비밀리에 잠긴 코드 조각 (이진 / ASCII 등)을 감지 할 수 있다. 반복 해 석 C328은 모든 상호 연결된 함수를 반복하여 목적 연관성 C326을 참조하여 해석된 목적 정의 (복합 목적 형식 C325에서)를 생성한다. 내부 핵심 (IC) C333은 자동 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍한 LIZARD의 영역이다. IC C333의 핵심 코드 C335 요소에는 기본 프 레임워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 사용할 수 있도록 표준화 된 라이브러리 및 스크립트 를 제공함으로써 SM C35 및 PM C36에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 709는 도 708로부터의 논리 흐름을 계속하여 정제된(refined) 실행 스트림을 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36 의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 목적 연관성C326을 참조하여 상호 연결된 모든 함수를 반복하여 해석된 목적 정의를 생성한다. 목적 정의 출력은 PM C36, 즉 외부 핵심 (OC) C329, 따라서 LIZARD에 대한 모듈 출력으로 제출 된 복합 용도 형식 C325에 있다. 출력은 컨텍스트 화 된 에러 로그 의 복합 목적 형식 (Complex Purpose Format) C325 버전으로서 제공되는 목적 계층 맵 으로 라벨 링 된다. 동일한 정의와 내부 핵심 (IC) C333의 어플리케이션이 앞서 언급한 기능 및 모듈에 적용된다. 도 710은 단계 8490인 목적 재정렬 처리 (PRP) 내에서 정제 된 실행 세그먼트의 맵 8494를 포함하도록 타겟 앱 체인의 목적 계층 맵을 조정하여 업그레이드 된 목적 맵 을 생성한다’에서의 진단 로그 유닛 분석 (DLUA) 을 도시한다. LIZARD는 8500단계에서 업그레이드 된 목적 맵을 앱체인 구문으로 변환한다. 업그레이드 된 앱체인 는 DPA (Deployment Patch Assembly) 에 제출되고 8502 단계에서 CEB (커스텀체인 Ecosystem Builder) 에 앱체인 정정 패치를 배포한다. 도 711은 LIZARD 가 UBEC 플랫폼 의 전체 커스텀 체인 생태계에 대한 목적 계층 맵을 구동하는 새로 운 앱 체인 개발 (NAD) 을 도시한다. 잠재적 중복, 협력 및 충돌 8508의 목적 계층 맵 내 영역을 해석한 다. 중복 협력 및 충돌 점검 (OC-3) 8520은 OC3 맵 으로 전송된다. LOM은 OC3 맵 을 수신한다. 앱 체인 소팅 메커니즘(ASM) 에 의해 OC3 8520으로부터 접수 된 새로운 제안된 변경는 PMA (Principled Modification Actuation) 에 제출된다. 도 712는 UBEC 플랫폼의 전체 커스텀체인 생태계를 목적 계층 맵으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. UBEC 플랫폼은 외부 핵심 (OC) (C329)의 관할에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성; 목적 모듈 (PM) C36에서 복합 목적 형식(C325)을 수신한다. 복합 목적 형식(C325)는 '의사 코드'라고도 하는 임의 코드 구 문으로 작성된다. 의사 코드는 if / else 문, while 루프 등 모든 프로그래밍 언어에서 가장 일반적인 계산 연 산의 기본 구현을 포함한다. 그 후 헬퍼 함수는 의사 코드를 원하는 목표 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 읽기; SM C35는 이러한 코드의 기능을 위한 목적을 도출하기 위해 PM C36에 대한 컴퓨터 코드의 구문 해석을 제공한다. UBEC 플랫폼은 코드 번역(C321)에 의해 믹스된 실행/데이터 스트림 포맷으로 수신된다. 코드 번역(C321)은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임 의의 계산 언어로 변환한다. 코드 번역(C321)은 또한 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함 수를 수행한다. 코드 번역(C321)의 완료된 실행 결과는 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323은 코드 논리를 단순한 폼으로 감소시켜 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수의 맵을 생성한다. 그 러므로 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 출력이 목적 모듈 (PM) C36의 반복 해석 C328에 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35가 해석 한 관련 코드 섹션의 의도 된 기능을 적절히 설명 한다. PM C36은 또한 데이터 내에 비밀리에 잠긴 코드 조각 (이진 / ASCII 등)을 감지 할 수 있다. 반복 해석 C328은 모든 상호 연결된 함수를 반복하여 목적 연관성 C326을 참조하여 해석된 목적 정의 (복합 목적 형식 C325에서)를 생성한다. 내부 핵심 (IC) C333은 자동 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍 한 LIZARD 의 영역이다. IC C333의 핵심 코드 C335 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 사용할 수 있도록 표준화 된 라이브러리 및 스크립트를 제공함으로써 SM C35 및 PM C36에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 713은 도 712로부터의 논리 흐름을 계속하여 UBEC 플랫폼의 전체 커스텀체인 생태계를 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 목적 연관성 C326을 참조하여 상호 연결된 모 든 함수를 반복하여 해석된 목적 정의를 생성한다. 목적 정의 출력은 PM C36, 즉 외부 핵심 (OC) C329, 따라서 LIZARD에 대한 모듈 출력으로 제출 된 복합 용도 형식 C325에 있다. 출력은 UBEC 플랫폼의 복합 목적 형식 (Complex Purpose Format) C325 버전으로서 제공되는 목적 계층 맵 으로 라벨링 된다. 동일한 정의 와 내부 핵심 (IC) C333의 어플리케이션이 앞서 언급한 기능 및 모듈에 적용된다. 도 714는 LIZARD가 전체 목적 계층 맵을 처리하여 개별 목적 요소들을 목적 밴드들 로 분류하는 오버랩 협력 및 충돌 체크 (OC3) 를 도시한다. 목적 밴드 는 밴드 A , 밴드 B , 밴드 C 및 밴드 D 로 구성된다. 도 715는 목적 계층 맵 을 일련의 목적 밴드로 변환하기 위한 LIZARD 의 동작에 관한 세부 사 항을 도시한다. 목적 계층 맵 은 복합 목적 형식 C325에 존재하며 LIZARD 의 외부 핵심 (OC) C329 내에서 목적 모듈 C36의 반복 확장 C327에 제출된다. 반복 확장 C327은 세부 사항과 복잡성을 추가하여 간단한 목표를 특정 복잡한 목적 정의로 발전시킨다. 따라서 입력의 최대 목적 연관 C326 가능성은 구문 모듈 (SM) C35 의 논리 파생 C320에 제출되기 전에 실현되고 복합 목적 형식 C325로 유지된다. IC C333의 핵심 코드 C335 요소 에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 사용할 수 있도록 표준화 된 라이브러리 및 스크립트를 제공함으로써 SM C35 및 PM C36에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스 템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 716은 목적 계층 맵을 일련의 목적 밴드로 변환하기 위한 LIZARD 의 동작을 설명하기 위해 도 715으로부터의 논리 흐름을 계속한다. 입력 데이터는 PM (Purpose Module) C36에서 복합 목적 형식 C325로 수신되고 SM (Syntax Module) C35의 논리 유도 C320으로 전송된다. 논리 유도 C320은 초기 단순한 함수에서 논 리적으로 필요한 함수를 유도한다. 즉, 함수가 단순한 부모 함수의 암시로 인해 파생 함수로 형성 될 수 있는 경우; 논리 파생 C320에 의해 형성된다. 생성된 결과는 정의된 복합 목적 형식 C325 데이터에 따라 작성된 함수 종속성 트리이다. 논리 도출 C320은 내부 핵심 (IC) C333의 핵심 코드 C335 요소 및 타겟 시스템 해석 감지 (TSID)를 통한 타겟 시스템 라이브러리 컬렉션에서 상속 된 규칙 및 구문 C322 정의에 따라 작동한다. 논 리 도출 C320는 출력을 코드 번역 C321에 제출한다. 코드 번역 C321은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역 C321은 알려진 계산 언어를 임의의 구문 유형으 로 변환하는 역함수도 수행한다. 따라서 PM C36은 SM C35를 호출하여 코드 번역 C321을 통해 입력 업그레이드 된 목적 맵의 결과적 밴드 버전을 생성한다. 코드 번역 C321에서 마지막으로 생성되는 결과적 목적 밴드 는 SM C35, 외부 핵심 (OC) C329 및 LIZARD 의 모듈식 출력이다. 도 717은 오버랩 협력 및 충돌 체크 (OC3) 를 도시한다. PBZO (목적 밴드 영역구성) 은 각 영역 8546을 반복하여 A영역, B영역, C영역 및 D영역를 사용하여 목적 밴드를 공통 존 으로 구성한다. 도 718은 OC3 맵 을 개발하기 위한 CTMP , LOM 및 I2GE 의 동작을 도시하기 위해 도 717으로부터의 논리 흐름을 계속한다. 일련의 단계는 단계 8546 각 영역을 통한 루프, 단계 8548 선택한 영역의 각 밴드를 통한 루프, 단계 8550 가장 일치하는 목적 요소 찾기 및 단계 8552 목적 요소의 앱체인 관할권 찾기 로 시작한다. LOM은 디자인 원칙 준수 8554와 관련하여 집단 단위로 선택된 앱체인 관할권을 조사하고 새로운 제안 변경 은 LOM 및 I2GE 의 입력을 기반으로 수행 한 설문 에 따라 생성된다. CTMP 및 LOM 는 모든 상호 작용에 필요에 따라 직접 상호 작용한다. 도 719는 OC3 맵 을 개발하기 위한 LIZARD 의 동작을 도시하기 위해 도 718으로부터의 논리 흐름을 계속한다. LIZARD는 새로 제안 된 변경 사항 에 대한 목적 계층 맵 를 도출한다 (설문 8558에 기초). 8566에서 OC3 맵 8522를 생성하기 위해 UBEC 플랫폼 으로부터 목적 계층 맵 및 목적 계층 맵 을 수신하는 목적 재정렬 처리 (PRP) 7050 내의 마스터 / 슬레이브 어피니티 1480을 통해 OC3 맵을 생성한다. 새로 제안 된 변경 사항 8560은 모두 PMA (Principled Modification Actuation) 8620에도 전송 되었다. 도 720은 새로 제안 된 변경 사항을 목적 계층 맵으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 새로 제안 된 변경 사항 의 유닛은 외부 핵심 (OC)(C329)의 관할권에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성; 목적 모듈 (PM) C36에서 복합 목적 형식(C325)을 수신한다. 복합 목적 형식(C325)는 '의사 코드'라고도 하는 임의 코 드 구문으로 작성된다. 의사 코드는 if / else 문, while 루프 등 모든 프로그래밍 언어에서 가장 일반적인 계 산 연산의 기본 구현을 포함한다. 그 후 헬퍼 함수는 의사 코드를 원하는 목표 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 읽기; SM C35는 이러한 코드의 기능을 위한 목적을 도출하기 위해 PM C36에 대한 컴퓨터 코드의 구문 해석을 제공한다. 새로 제안 된 변경 사항 유닛은 코드 번역(C321)에 의해 믹스 된 실행/데이터 스트림 포맷으로 수신된다. 코드 번역(C321)은 SM C35에서 인식되고 이해되는 임의의 (일 반) 코드를 알려진 임의의 계산 언어로 변환한다. 코드 번역(C321)은 또한 알려진 계산 언어를 임의의 구문 유 형으로 변환하는 역함수를 수행한다. 코드 번역(C321)의 완료된 실행 결과는 논리 감소 C323에 입력으로 전송된 다. 논리 감소 C323은 코드 논리를 단순한 폼으로 감소시켜 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수 의 맵을 생성한다. 그러므로 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 출력이 목적 모듈 (PM) C36의 반복 해석 C328에 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드 에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35가 해석 한 관련 코드 섹션의 의도 된 기능을 적절히 설명한다. PM C36은 또한 데이터 내에 비밀리에 잠긴 코드 조각 (이진 / ASCII 등)을 감지 할 수 있다. 반복 해석 C328은 모든 상호 연결된 함수를 반복하여 목적 연관성 C326을 참조하여 해석된 목적 정의 (복 합 목적 형식 C325에서)를 생성한다. 내부 핵심 (IC) C333은 자동 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍 한 LIZARD의 영역이다. IC C333의 핵심 코드 C335 요소 에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 사용할 수 있도록 표준화 된 라이브러리 및 스크립트를 제공함으로써 SM C35 및 PM C36에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스 템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 721은 도 720으로부터의 논리 흐름을 계속하여 새로 제안 된 변경 사항을 목적 계층 맵 으로 변 환하기 위한 LIZARD 의 동작을 설명한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 목적 연관성C326을 참조하여 상호 연결된 모든 함수를 반 복하여 해석된 목적 정의를 생성한다. 목적 정의 출력은 PM C36, 즉 외부 핵심 (OC) C329, 따라서 LIZARD 에 대한 모듈 출력으로 제출 된 복합 용도 형식 C325에 있다. 출력은 새로 제안 된 변경 사항의 복합 목 적 형식 (Complex Purpose Format) C325 버전으로서 제공되는 목적 계층 맵 으로 라벨링 된다. 동일한 정의와 내부 핵심 (IC) C333의 어플리케이션이 앞서 언급한 기능 및 모듈에 적용된다. 도 722는 비용과 일치하는 목적 요소를 찾기 위한 오버랩 협력 및 충돌 체크 (OC3) 를 도시한다. 프로세스는 8570을 처리하기 위한 영역을 시작함으로써 (A영역 8538) 시작된다. 그 뒤에 목적 요소 유형을 선택 하고 8576에 표시된 대로 영역에서 분리한다. 도 723은 목적 요소들의 앱체인 관할권들을 찾기 위해 오버랩 협력 및 충돌 체크 (OC3) 에 대한도 722로부터의 논리 흐름을 계속한다. 목적 요소 유형이 8572이고 8576에 표시된 대로 영역에서 분리하므로 8580에 이미 나와있는 것처럼 카테고리 참조를 제거한다. 다음 8582 단계에서 앱체인 관할권별로 구성한 다 (8584에 표시됨). 도 724는 LOM 이 디자인 원칙 준수 에 관한 집합 단위로서, 선택된 앱체인 관할권 을 조사하 는 오버랩 협력 및 충돌 체크 (OC3) 에 대한 도 723으로부터 논리 흐름을 계속한다. 8586 단계에서 앱체 인 관할권 은 8584에 표시된다. 8590 단계에서 LIZARD는 앱체인 으로서의LOM 및 CKR에서 수 신한 시스템 디자인 원칙 에 대한 목적 계층 맵 8592를 도출한다. 8594 단계에서 LIZARD 은 앱체인 관할권 에 대한 목적 계층 맵 8596을 도출한다. 도 725는 시스템 디자인 원칙을 목적 계층 맵으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 시스템 디자인 원칙은 외부 핵심 (OC) (C329)의 관할에 속하는 구문 모듈 (SM) C35에 제출된다. SM C35는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성; 목적 모듈 (PM) C36에서 복합 목적 형식(C325)을 수신한다. 복합 목적 형식(C325)는 '의사 코드'라고도 하는 임의 코드 구문으로 작 성된다. 의사 코드는 if / else 문, while 루프 등 모든 프로그래밍 언어에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼 함수는 의사 코드를 원하는 목표 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드 로 변환한다. 코드 읽기; SM C35는 이러한 코드의 기능을 위한 목적을 도출하기 위해 PM C36에 대한 컴퓨터 코 드의 구문 해석을 제공한다. 시스템 디자인 원칙은 코드 번역(C321)에 의해 믹스된 실행/데이터 스트림 포맷으로 수신된다. 코드 번역(C321)은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임 의의 계산 언어로 변환한다. 코드 번역(C321)은 또한 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함 수를 수행한다. 코드 번역(C321)의 완료된 실행 결과는 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323은 코드 논리를 단순한 폼으로 감소시켜 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수의 맵을 생성한다. 그 러므로 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 출력이 목적 모듈 (PM) C36의 반복 해석 C328에 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35가 해석 한 관련 코드 섹션의 의도 된 기능을 적절히 설명 한다. PM C36은 또한 데이터 내에 비밀리에 잠긴 코드 조각 (이진 / ASCII 등)을 감지 할 수 있다. 반복 해석 C328은 모든 상호 연결된 함수를 반복하여 목적 연관성 C326을 참조하여 해석된 목적 정의 (복합 목적 형식 C325에서)를 생성한다. 내부 핵심 (IC) C333은 자동 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍 한 LIZARD의 영역이다. IC C333의 핵심 코드 C335 요소에는 기본 프 레임워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 사용할 수 있도록 표준화 된 라이브러리 및 스크립트 를 제공함으로써 SM C35 및 PM C36에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스템 목표 C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 726은 시스템 디자인 원칙 를 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명하 기 위해 도 725로부터의 논리 흐름을 계속한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 모든 상호 연결된 기능을 반복하여 목적 연관성 C326을 참조하여 해석 된 목적 정의를 생성한다. 목적 정의 출력은 복합 목적 형식 C325로 존재하며 PM C36에 대한 모 듈 식 출력으로 제출되므로 외부 핵심 (OC) C329, 따라서 LIZARD 으로 제출된다. 출력물은 목적 계층 맵 으로 표시되며, 시스템 디자인 원칙의 복합 목적 형식 C325 버전으로 표시된다. 내부 핵심 (IC) C333의 동일한 정의 및 적용은 전술 한 기능 및 모듈에 적용된다. 도 727은 앱체인 관할권을 목적 계층 맵으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항 을 도시한다. 앱체인 관할권유닛은 외부 핵심 (OC)(C329)의 관할권에 속하는 구문 모듈 (SM) C35에 제출 된다. SM C35는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성; 목적 모듈 (PM) C36에서 복 합 목적 형식(C325)을 수신한다. 복합 목적 형식(C325)는 '의사 코드'라고도 하는 임의 코드 구문으로 작성된다. 의사 코드는 if / else 문, while 루프 등 모든 프로그래밍 언어에서 가장 일반적인 계산 연산의 기 본 구현을 포함한다. 그 후 헬퍼 함수는 의사 코드를 원하는 목표 계산 구문 (컴퓨터 언어)에 따라 실제 실행 코드로 변환한다. 코드 읽기; SM C35는 이러한 코드의 기능을 위한 목적을 도출하기 위해 PM C36에 대한 컴퓨터 코드의 구문 해석을 제공한다. 앱체인 관할권은 코드 번역(C321)에 의해 믹스된 실행/데이터 스트림 포맷으로 수신된다. 코드 번역(C321)은 SM C35에서 인식되고 이해되는 임의의 (일반) 코드를 알려진 임의 의 계산 언어로 변환한다. 코드 번역(C321)은 또한 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수 를 수행한다. 코드 번역(C321)의 완료된 실행 결과는 논리 감소 C323에 입력으로 전송된다. 논리 감소 C323은 코드 논리를 단순한 폼으로 감소시켜 규칙 및 구문 C322의 정의에 따라 상호 연결된 함수의 맵을 생성한다. 그 러므로 논리 감소 C323의 실행이 완료되면 해당 SM C35 인스턴스의 실행이 완료되고 SM C35의 모듈 출력이 목적 모듈 (PM) C36의 반복 해석 C328에 전송된다. PM C36은 SM C35를 사용하여 컴퓨터 코드에서 복합 목적 형식 C325의 목적을 도출한다. 이러한 목적 정의는 SM C35가 해석 한 관련 코드 섹션의 의도 된 기능을 적절히 설명 한다. PM C36은 또한 데이터 내에 비밀리에 잠긴 코드 조각 (이진 / ASCII 등)을 감지 할 수 있다. 반복 해석 C328은 모든 상호 연결된 함수를 반복하여 목적 연관성 C326을 참조하여 해석된 목적 정의 (복합 목적 형식 C325에서)를 생성한다. 내부 핵심 (IC) C333은 자동 유지 보수 / 자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접 독점적으로 프로그래밍 한 LIZARD의 영역이다. IC C333의 핵심 코드 C335 요소에는 기본 프 레임워크 및 라이브러리, 스레드 관리 및 로드 균형 조정 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템이 포함된다. 따라서 핵심 코드 C335는 기본 기능을 사용할 수 있도록 표준화 된 라이브러리 및 스크립트 를 제공함으로써 SM C35 및 PM C36에 대한 일반적인 작동 및 기능을 가능하게 한다. IC C333의 시스템 목표C336 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 정적 정책 변수로 작동하여 LIZARD 내의 다양한 동적 및 정적 기능을 안내한다. 도 728은 도 727로부터의 논리 흐름을 계속하여 앱체인 관할권을 목적 계층 맵 으로 변환하기 위한 LIZARD 의 동작을 설명한다. 구문 모듈 (SM) C35의 논리 감소 C323은 목적 모듈 (PM) C36의 반복 해석 C328에 출력을 제출한다. 반복 해석 C328은 목적 연관성C326을 참조하여 상호 연결된 모든 함수를 반복하여 해 석된 목적 정의를 생성한다. 목적 정의 출력은 PM C36, 즉 외부 핵심 (OC) C329, 따라서 LIZARD에 대한 모 듈 출력으로 제출 된 복합 용도 형식 C325에 있다. 출력은 앱체인 관할권의 복합 목적 형식 (Complex Purpose Format) C325 버전으로서 제공되는 목적 계층 맵 으로 라벨링 된다. 동일한 정의와 내부 핵심 (IC) C333의 어플리케이션이 앞서 언급한 기능 및 모듈에 적용된다. 도 729는 LOM이 디자인 원칙 준수 에 관한 집합 단위로서 선택된 앱 체인 관할권 을 조사하는 오버 랩 협력 및 충돌 체크 (OC3)를 도시한다. 목적 대 목적 대칭 처리(P2SP)는 LOM 에서 CKR 을 통해 목적 계층 맵를 통해 시스템 디자인 원칙 을 수신한다. P2SP은 또한 앱체인 관 할권의 목적 계층 맵을 받는다. P2SP는 대칭 처리 결과에 제출하여 앱체인 관할권의 목적 맵 이 전체의 시스템 디자인 원칙과 일치하는지 확인한다. 예, 일치한다 혹은 아니요, 일치하지 않는 다. 도 730은 도 729로부터의 수행된 조사에 따라 새로 제안된 변경이 생성되는 오버랩 협력 및 충돌 체크 (OC3) 로부터의 논리 흐름을 계속한다. 8600 단계에서, 앱체인 관할권의 목적 맵이 전체의 시스템 디자인 원칙과 일치하는지 확인한다. 예, 일치한다, 아니오 변경이 필요하다, 널(null) 출력 8606으로 모 듈 실행을 종료한다. 아니오 일치하지 않는다인 경우 PRP 내의 시스템 디자인 원칙의 맵과 일치하 도록 앱 체인 관할권의 목적 계층 맵을 조정한다. LIZARD 은 업그레이드 된 목적 맵 8610을 앱체인 소팅 매커니즘에서 새로 제안된 변경으로 참조되는 앱체인 구문으로 변환한다. 앱체인 구문은 ASM 을 통해 세 가지 범주의 앱체인으로 분류된다. 도 720은 신규 제안된 변경(New Proposed Changes)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 신규 제안 변경 유닛은 외부 코어 (Outer Core, OC)(C329)의 관할구역에 속하는 구문 모듈(Syntax Module, SM)(C35)에 제출한다. 구문 모듈(C3 5)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(Purpose Module, PM)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷 (C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while 루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼 (helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 PM(C36)의 컴퓨터 코드에 대한 구문적 해석을 제공하여 이러한 코드의 상기 기능 을 위한 목적을 도출한다. 신규 제안된 변경 유닛은 코드 변환(C321)에 의해 혼합 실행/데이터 스트림 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환 (translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소 (C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생 성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(Purpose Module, PM)(C36)의 반복 해석(C32 8)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관 성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(Inner Core, IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리 (Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜 (Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기 본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작 동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동 한다. 도 721은 신규 제안된 변경을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위 해 도 720의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석 (C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위 해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 출력은 신규 제안된 변경의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용 은 전술한 기능 및 모듈에 적용된다. 도 722는 비용과 일치하는 목적 요소를 찾기 위해 오버랩 협력 및 충돌 검사(Overlap Co-operation and Conflict, OC3)을 도시한다. 프로세스는 프로세싱를 위해 (영역 A 8538)영역을 개시하는 것으로 시 작된다. 그 다음에 목적 요소 유형를 선택하고 8576에 표시된 대로 영역에서 분리한다. 도 723은 목적 요소의 앱체인 관할구역(Appchain Jurisdictions)을 찾기 위해 오버랩 협력 및 충돌 검사 (OC3)에 대한 도 722의 논리 흐름을 계속한다. 8576에 도시된 바와 같이 목적 요소 유형와 영역에 서 분리(Isolate them from the Zone)는 이미 발생하였으므로, (8580과 같이) 카테고리 참조 제거 (Removes Category References)한다. 다음, (8584와 같이) 8582는 앱체인 관할구역에 의해 체계화 (Organize by Appchain Jurisdiction)한다. 도 724는 LOM가 디자인 원칙 준수와 관련된 집합 유닛으로 선택된 앱체인 관할구역을 조사하 는 오버랩 협력 및 충돌 검사(OC3)에 대한 도 723의 논리 흐름을 계속한다. 8586단계에서, 앱체인 관할구 역은 8584에 도시된다. 8590단계에서, LIZARD는 LOM 및 CKR로부터 앱체인으로 수신한 시스템 디자인 원칙에 대한 목적 계층 맵(Purpose Hierarchy Map)을 도출한다. 8594단계에서, LIZARD은 앱체인 관할구역(Appchain Jurisdictions)에 대한 목적 계층 맵을 도출한다. 도 725는 시스템 디자인 원칙(System Design Principles)을 목적 계층 맵(Purpose Hierarchy Map)(859 2)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 시스템 디자인 원칙 유닛는 외 부 코어(OC)(C329)의 관할구역에 속하는 구문 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(Purpose Module, PM)(C36)로부터 복합 목적 포맷 (C325)을 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드 에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드 의 구문적 해석을 제공한다. 시스템 디자인 원칙 유닛은 코드 변환(C321)에 의해 혼합 실행/데이터 스트 림 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려 져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변 환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소 (C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생 성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정 의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이 진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코 어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프 로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코 어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36) 에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정 적 정책 변수로 작동한다.도 726은 시스템 디자인 원칙를 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 725의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해 석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD(12 0)을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 출력은 시스템 디자인 원칙의 복 합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 727은 앱체인 관할구역(Appchain Jurisdictions)을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 앱체인 관할구역 유닛은 외부 코어(OC)(C329)의 관할 구역에 속하는 구문 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한 다. 코드 작성을 위해, 목적 모듈(Purpose Module, PM)(C36)로부터 복합 목적 포맷(C325)을 수신한다. 복합 목 적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한 다. 앱체인 관할구역 유닛은 코드 변환(C321)에 의해 혼합 실행/데이터 스트림 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수 (inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단 한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관 련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코 드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷 (C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보 수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역 이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크 립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가 능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 728은 앱체인 관할구역을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 727의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석 (C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위 해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 앱체인 관할구역의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용 은 전술한 기능 및 모듈에 적용된다. 도 729는 LOM이 디자인 원칙 준수와 관련된 집합 유닛으로 선택된 앱체인 관할구역을 조사하는 오 버랩 협업 및 충돌 검사(OC3; Overlap Co-operation and Conflict Check)을 도시한다. 목적 대 목적 대 칭 처리(Purpose to Purpose Symmetry Processing, P2SP)는 LOM에서 CKR을 통해 목적 계층 맵 을 통해 시스템 디자인 원칙을 수신한다. 또한, P2SP은 앱체인 관할구역의 목적 계층 맵을 수신한다. P2SP는 전체에서 앱체인 관할구역의 목적 맵이 시스템 디자인 원칙과 일치하는지 확인하는 대칭 처리 결과에 제출한다. 그 결과는 예, 일치함(Yes, it mateches) 또는 아니요, 일치 하지 않음(No, it doesn’t match) 이다. 도 730은 8558에 따라 신규 제안된 변경이 생성되는 도 729의 오버랩 협력 및 충돌 검사(OC3)로부터 논리 흐름을 계속한다. 8600단계에서, 앱체인 관할구역의 목적 맵은 전체에서 시스템 디자인 원칙과 일치하는 지 점검한다. 예, 일치함과 변경이 필요하지 않으며 무효의 출력으로 모듈 실행을 종료한다. 아니요, 일치하지 않음인 경우, 앱체인 관할구역의 목적 계층 맵을 목적 재정렬 처리(PRP) 내에서 시스 템 디자인 원칙의 맵과 일치하도록 조정한다. LIZARD은 업그레이드 된 목적 맵을 앱체인 분류 매커니즘(Appchain Sorting Mechanism)에서 신규 제안된 변경으로 참조되는 앱체인 구문으로 변환 한다. 앱체인 구문은 ASM을 통해 세 가지 다른 카테고리의 앱체인으로 분류된다 도 731은 업그레이드된 목적 맵을 신규 제안된 변경으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 업그레이드된 목적 맵은 복합 목적 포맷(C325)으로 존재하며 LIZARD의 외부 코어(OC)(C329) 내에서 목적 모듈(C36)의 반복 확장(C327)에 제출된다. 반복 확장(C327)은 특정 복합 목적 정의 로 발전시키기 위해 세부 사항과 복잡도를 추가한다. 따라서 입력의 최대 목적 연관성(C326) 포텐셜은 구문 모 듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에 실현되고, 복합 목적 포맷(C325)으로 유지된다. 내부 코어(IC)(C333)의 핵심 코드(C335) 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런 싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기 능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의 는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 732는 업그레이드된 목적 맵을 신규 제안된 변경으로 변환하기 위한 LIZARD의 작동을 설명 하기 위해 도 731의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)으로 수신되고 구문 모듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 기능에서 논리적으로 필요한 기능을 도출한다. 이는 만약 함수가 더 간단한 상위의 함수로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수의 트리이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(Inner Core, IC)(C333) 의 핵심 코드(C335) 요소와 대상 시스템 해석 검출(Target System Interpretation Detection, TSID)을 통해 타 겟 시스템 라이브러리 모음(Target System Library Collection)에서 상속된 규칙 및 구문(C322) 정의에 따라 작동한다. 논리적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환 (C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 따라서 PM(C36)은 코드 변환(C321)을 통해 입력 업그레이드된 목적 맵의 결과적인 앱체인 구문 버전을 생성하기 위해 SM(C35)을 호출한다. 코드 변환(C321)에 의해 최종적으로 생성되는 신규 제 안된 변경 유닛은 SM(C35), 외부 코어(OC)(C329) 및 LIZARD의 모듈식 출력이다. 도 733은 앱체인 구문은 앱체인 분류 메커니즘(Appchain Sorting Mechanism, ASM)을 통해 세 가지 다른 카테고리의 앱체인으로 분류되는 8614에서 기본 수정 작동(Principled Modification Actuation, PMA)을 도시한다. ASM은 다음과 같은 카테고리를 제공한다. 8622를 생성하는 앱체인, CEB로 직접 이동하는 8624를 수정하는 앱체인 및 앱체인 삭제 메커니즘(Appchain Deletion Mechanism, ADM)를 통해 커스텀체 인 인터페이스 모듈(Customchain Interface Module, CIM)으로 이동하는 8626을 삭제하기 위한 앱체인. LIZARD는 구문 모듈을 사용하여 새로운 앱체인을 로지스틱스 레이어(Logistics Layer) 형식으로 변환한다. 업그레이드된 목적 맵 내에 존재하는 모든 종속성 및 보완 관계는 8628으로 유지되었다. 로지스틱스 레이어 는 CEB(Customchain Ecosystem Builder)으로 전송한다. 도 734는 Appchains to Create으로 로지스틱스 레이어로 변환하는 LIZARD의 작동에 관한 세부 사항을 도시한다. 8622를 생성하기 위한 앱체인은 외부 코어(OC)(C329)의 관할구역에 속하는 구문 모듈 (SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모 듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코 드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계 산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의 사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출 하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. Appchains to Create는 코드 변환(C321)에 의해 혼합 실행/데이터 스트림 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의 (일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완 료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석 (C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용 한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관 성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수 를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임 워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 735는 Appchains to Create로 로지스틱스 레이어로 변환하기 위한 LIZARD의 작동을 설명하 기 위해 도 734의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD(12 0)을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)에 존재한다. 출력은 앱체인의 복합 목적 포맷(C325) 버전으로 Appchains to Create를 표시되고 로지스틱스 레이어 형식으로 코드화되는 로지스틱스 레이 어로 분류된다. 로지스틱스 레이어는 구문의 마이크로 배열이고, 복합 목적 포맷(C325)은 구문의 마 이크로 배열을 정의한다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 736은 8614의 기본 수정 작동(Principled Modification Actuation, PMA)을 도시한다. 앱체인 구문은 ASM을 통해 세 가지 다른 카테고리의 앱체인으로 분류된다. ASM은 각 앱체인를 통해 루프하는 PMA으로 앱체인을 수정에게 제공하며, 8634에서 다음에 이용할 수 있는 앱체인 및 DPA(Deployment Patch Assembly)으로 루프를 진행하기 위해 선택된 선택된 앱체인을 제출한다. DPA은 타겟 앱체인(Target Appchain)을 위해 앱체인 정정 패치(Appchain Correction Patch)(627 0)을 CEB(Customchain Ecosystem Builder)에 제공한다. 도 737은 LOM가 8638에서 OC3 맵을 수신하고 LOM가 8640에서 CKR로부터 창의적 디자인 원칙(Creative Design Principles)를 참조하는 신규 앱체인 개발(Creative Design Principles, NAD) 작동을 도시한다. 8644단계에서, LOM는 창의적 포텐셜 맵(Creative Potential Map)을 생성한다. 도 738은 LOM가 창의적 디자인(Creative Design)와 LOM를 창의적 포텐셜 맵(Creative Potential Map)을 생성하는 신규 앱체인 개발(New Appchain Development, NAPP) 작동을 설명하기 위해 도 737의 논리 흐름을 계속한다. LOM는 DPIP(Design Principle Invocation Prompt)에 의해 적 용되어 창의적 디자인 원칙를 생성한다. LOM는 창의적 디자인 원칙(Creative Design Principle)를 생성하기 위해 CKR을 사용한다. 도 739는 LOM이 창의적 디자인을 참조하고 LOM이 창의적 포텐셜 맵을 생성하는 신규 앱 체인 개발(NAD) 작동을 설명하기 위해 도 738의 논리 흐름을 계속한다. LOM은 창의적 변수 호출 프 롬프트(Creative Variance Invocation Prompt, CVIP)에 의해 창의적 디자인 원칙를 생성하기 위해 적용 된다. OC3 맵은 처리할 수 있는 섹션에서 LIZARD에 의해 분할되고 MSCR에 저장된다. 도 740은 OC3 맵이 LIZARD에 의해 처리할 수 있는 섹션들로 분할되고 MSCR에 저장되는 NAD(New Appchain Development) 작동을 도시하기 위해 도 739의 논리 흐름을 계속한다. LIZARD는 8656에 서 전체의 OC3 맵을 목적 계층 맵에서 앱체인 구문으로 변환한다. 앱체인은 8660단계에서 ESD(Execution Scope Discovery)에 의한 실행 범위에 따라 강조된다. 앱체인 스코프(Appchain Scope)는 8664단계에서, 실행 스코프 캐시 보유(Execution Scope Cache Retention, ESCR)에 저장된다. 8668단계에 서, ESCR에 저장된 각 실행 스코프(Execution Scope)를 반복(loop)한다. 도 741은 OC3 맵을 앱체인 구문 맵으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도 시한다. OC3 맵은 복합 목적 포맷(C325)으로 존재하며 LIZARD의 OC(Outer Core)(C329) 내에서 목적모듈(C36)의 반복 확장(C327)에 제출된다. 반복 확장(C327)은 특정 복합 목적 정의로 발전시키기 위해 세부 사 항과 복잡도를 추가한다. 따라서 입력의 최대 목적 연관성(C326) 포텐셜(potential)은 구문 모듈(SM)(C35)의 논 리적 미분(Logical Derivation)(C320)에 제출되기 전에 실현되고, 복합 목적 포맷(C325)으로 유지된다. 내부 코 어(IC)(C333)의 핵심 코드(C335) 요소는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능 을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 742는 OC3 맵을 앱체인 구문 맵으로 변환하기 위한 LIZARD의 작동을 도시하기 위해 도 741의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)으로 수신되고 구 문 모듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 기능에서 논리적으로 필요한 기능을 도출한다. 이는 만약 함수가 더 간단한 상위의 함수로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수의 트리이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC)(C333)의 핵심 코드 (C335) 요소로부터 상속된 규칙 및 구문(C322) 정의에 따라 작동한다. 논리적 미분(Logical Derivation)(C32 0)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 따라서 PM(C36)은 코드 변환(C321)을 통 해 입력 OC3 맵의 결과 앱체인 구문 버전을 생성하기 위해 SM(C35)를 호출한다. 코드 변환(C321)에 의해 최종적으로 생성되는 결과 앱체인 구문 맵 유닛은 SM(C35), 외부 코어(OC)(C329) 및 LIZARD의 모듈 식 출력이다. 도 743은 OC3 맵이 LIZARD에 의해 처리할 수 있는 섹션으로 분할되고 MSCR에 저장되는 NAD(New Appchain Development)를 도시한다. 실행 스코프 캐시 보유(Execution Scope Cache Retention, ESCR)는 ESCR에서 각 실행 스코프 저장을 통해 반복된다. 선택된 실행 범위에 따라 앱체인 구문 맵에서 이행된 앱체인을 추출한다. 8672단계에서, LIZARD는 이행된 앱체인(Fulfilled Appchain)을 목적 계층 맵 형식으로 변환한다. 8676에서 목적 계층 맵을 MSCR에 저장 하고 루프에 사용할 수 있는 실행 스코프가 남아 있는지 확인한다. 만약 NO인 경우, Terminates Look Execution이고 YES인 경우, 8668단계로 진행한다. 도 744는 이행된 앱체인(Fulfilled Appchain)을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 이행된 앱체인은 외부 코어(OC)(C329)의 관할구역에 속하는 구문 모 듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도 출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 이행된 앱체인은 코드 변환(C321)에 의해 혼합 실행/데이터 스트림 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반 적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려 진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결 된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되 면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328) 로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관 성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수 를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임 워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보 안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 745는 이행된 앱체인(Fulfilled Appchain)을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 744의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈 (PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목 적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 이행된 앱체인 의 복합 목적 포맷(C325) 버전으로 표시되는 로지스틱스 레이어로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 746은 LOM 상기 창의적 포텐셜 맵을 생성하는 NAD(New Appchain Development)를 도시한다. 오 버랩 협력 및 충돌 검사(Overlap CO-operation and Conflict Check, OC3)은 8690단계에서 선택된 맵 세 그먼트에서 각 맵 세그먼트를 통해 반복되는 맵 세그먼트 캐시 보유(Map Segment Cache Retention, MSCR) 내에서 OC3 맵으로 입력되고, 8692단계에서, 맵 세그먼트를 창의적 변수 호출 프롬프트 (CVIP)에 제출한다. 8693단계에서, LOM 및 CTMP는 모듈식으로 창의적 포텐셜 유닛을 생 성한다. 도 747은 창의적 포텐셜 맵을 생성하기 위한 LOM의 작동을 설명하기 위해 도 746의 논리 흐름을 계 속한다. 8693단계에서LOM 및 CTMP는 에서 모듈식으로 창의적 포텐셜 유닛을 생성하고, 창의적 포텐셜 맵이 시작된 적이 있는지8695보는 것을 확인한다. Yes인 경우, 8699단계에서 창의적 포텐셜 유닛 에 해당하는 창의적 포텐셜 맵의 섹션을 찾는다. 8700에서 창의적 포텐셜 유닛의 해당 섹션을 창의 적 포텐셜 유닛으로 대체한다. NO인 경우, 8698단계에서 OC3 맵을 창의적 포텐셜 맵 으로 복제한다. 도 748은 창의적 포텐셜 맵을 생성하는 LOM의 프로세스를 설명하기 위해 도 747의 논리 흐름을 계속 한다. 8700단계에서, 창의적 포텐셜 맵의 해당 섹션을 창의적 포텐셜 유닛으로 바꾸고 루프에 사용 할 수 있는 맵 세그먼트가 남아 있는지에서 확인한다. NO인 경우, 창의적 포텐셜 맵을 모듈 식 출력으로 제출한다. YES인 경우, 8704단계에서 루프를 다음 사용할 수 있는 맵 세그먼트 로 이동한다. 8706에서 MSCR의 맵에서 각 맵 세그먼트를 통해 반복한다. 도 749는 신규 앱체인 개발(New Appchain Development, NAD)의 8696단계와 관련하여 LOM 및 CTMP의 내부 작동 절차를 도시한다. 창의적 디자인 원칙, 선택된 맵 세그먼트 및 OC3 맵 은 CVIP(Creative Variance Invocation Prompt)8650)에 초기 입력으로 제공된다. CVIP은 입력 기 준 보안 이론, 미확인 보안 정보 및 확인된 보안 지식을 고려하여 confident 보안 주장 (Confident Security Assertion)의 생산을 적용하기 위해 LOM와 직접 상호 작용하는 프롬프트 을 생산한다. CVIP에 의해 생성된 프롬프트은 LOM의 초기 쿼리 추론(Initial Query Reasoning, IQR)(C802A) 모듈에 제출된다. LOM이 UBEC 사용자에 의해 UBEC 플랫폼 내에서 직접 호출될 때, IQR(C802A)는 UBEC 사용자에 의해 제공된 초기 질문/주장(assertion)을 수신한다. 그러나, 상 기 LOM 인스턴스는 대신 DIP에 의해 자동으로 호출된다. 제공된 프롬프트은 프롬프트에 게 완전히 주소/응답하기 위한 LOM에 정확한 '가상 이해'를 완료하기 위해 중요한 프롬프트로부터 누락된 세부 사항을 판독하기 위해 중앙 지식 보유(Central Knowledge Retention, CKR)의 호출(invocation)를 통해 분석된다. IQR(C802A)에 의해 생성된 결과 누락된 세부 사항(resultant Missing Details)은 모듈식 입력 으로 조사 구분(Survey Clarification, SC)(C803A)에 제출된다. 프롬프트은 객관적이고 모든 필요한 문 맥을 분석할 수 있도록 SC(C803A)는 보충 정보를 검색하여 프롬프트의 출처와 연결한다. UBEC 사용자 에 의해 LOM이 UBEC 플랫폼 내에서 직접 호출될 때, SC(C803A)는 질문/응답의 출처로서 그 사 용자와 연동한다. 그러나, 상기 LOM 인스턴스는 대신 DIP에 의해 자동으로 호출되므로 SC(C803A)는 프롬프트에 관한 보충 정보를 검색하기 위해 DIP과 연동한다. 프롬프트의 완전 한 형태와 개선된 버전은 SC(C803A)에서 생산되며 주장 생성(Assertion Construction, AC)(C808A)에 모듈식 입 력으로 제출된다. AC(C808A)는 CKR을 직접 참조하거나 계층적 매핑(Hierarchical Mapping, HM)(C807A)를 통해 프롬프트에 대한 일관된 응답을 구성하기 위해 시도한다. 합리적 어필(Rational Appeal, RA)(C811 A)는 CTMP와의 논리 흐름 인터페이스를 수용하는 컨테이너 모듈이다. 합리적 어필(RA)(C811A)는 주장을 비판하기 위해 CTMP를 사용한다. 이러한 비판은 (AC(C808A)의 출력을 비판함으로써)자체 비판의 형태 또는 (UBEC 사용자 또는 DIP) IQR(C802A)에 의해 처리된 질문/주장의 출처에 대한 외부 비판의 형태일 수 있다. 만약 AC(C808A)에서 생성된 주장이 RA(C811A)에 의해 처리된 자체 비판 테스트에 대한 중요한 측정에 실 패한 경우, AC(C808A)의 새로운 인스턴스는 유효한 비판을 설명하기 위해 호출된다. 만약 높은 신뢰도 주장은 RA(C811A)에 의해 처리된 자체 비판 테스트를 지속적으로 통과하는 AC(C808A)에 의해 생성되는 경우, 상기 주장 은 CVIP에서 제공하는 초기 프롬프트의 문맥에서 창의적 포텐셜 맵으로 참조되는 LOM의 모듈식 출력으로 생성된다. 도 750은 NAD의 8696단계와 관련하여 LOM의 합리적 어필(Rational Appeal, RA)(C811A)의 내부 작동 과정에 대한 세부 사항을 도시한다. 주장 생성(Assertion Construction, AC)(C808A)는 해당 입력 프롬프트 에 관해서 AC(C808A)에 의해 생성된 주장에 대한 합리적 어필(Rational Appeal, RA)(C811A)에 응답 프레 젠테이션(Response Presentation)(C843)을 제공한다. 논리 흐름의 상기 단계에서, 생성된 주장은 사전 비판적 결정(C847)으로 분류된다. 이는 CTMP에 의한 비판을 통해 아직 처리되지 않았음을 의미한다. 따라서 생성 된 주장은 '주관적 의견(Subjective Opinion)(C848)’ 입력으로 CTMP 인스턴스에 직접 제출되며 또한, CTMP 인스턴스에 ‘객관적 팩트(Objective Fact)(C850)’ 입력을 제공하는 문맥 구성(Context Construction, CC)(C817A)에 제출된다. CC(C817A)는 AC(C808A)의 메타데이터와 비판적 사고(critical thinking)를 위해 미가공 팩트(raw fact)를 CTMP에 제출하는 CVIP을 통해 제공되는 잠재적 (potential) 증거를 참조한다. 이러한 입력 메타데이터는 LOM 로그 집계 파일로 표시된다. LOM 로그 집계 는 LOM의 기본적인 운영 기능으로부터 생성된 관련 로그 파일의 모음이 포함되어 있다. CTMP 인스턴스가 작동을 마치면 사후 비판적 결정(C851)이 모듈식 출력으로 생성된다. 초기 사전 비판적 결정(C847) 및 사후 비판적 결정(C851)은 두 입력 C847과 C851 사이의 잠재적 중복의 범위를 결정하는 의사 결정 비교 (DC)(C818A) 모듈에 제출된다. DC(818A)가 제공하는 통합 출력은 주장을 생성하는 AC(C808A)을 대신하여 CTMP의 (부정확한) 양보(Concession)(C852) 또는 주장을 생성하는 AC(C808A)를 대신하여 인지된 개선 (perceived Improvement)(C853)을 나타낼 수 있다. 인수 응답인 C852 및 C853은 모두 낮은 신뢰도 결과(C845) 또는 높은 신뢰도 결과(C846)로 분류할 수 있다. 낮은 신뢰도 결과(C845)는 AC(C808A)에 의해 생성된 초기 주장 이 결함이 있고 재구성됨을 나타낸다. 따라서, 논리 흐름은 AC(C808A)의 신규 인스턴스로 계속 이어진다. 높은 신뢰도 결과(C846)은 AC(C808A)에 의해 생성된 초기 주장이 장점이 있음을 나타내므로 도출된 결론(해당 증거, 전제 등과 결합됨)이 지식 검증(Knowledge Validation, KV)(C805A)에 제출된다. 따라서 논리 흐름은 CKR 및 LOM가 최근에 처리된 주장으로부터 이점을 얻을 수 있도록 KV(C805A)의 새로운 인스턴스로 계속 진행된 다. 도 751은 LOM 로그 집계 파일의 생성을 설명하기 위해 NAD에서 8696단계의 논리 흐름을 계속한다. 초기 쿼리 추론((Initial Query Reasoning, IQR)(C802A), 조사 구분(Survey Clarification, SC)(C803A), 주장 생성(Assertion Construction, AC)(C808A), 계층적 매핑(Hierarchical Mapping, HM)(C807A) 및 지식 검증 (Knowledge Validation, KV)(C805A)에서 생성된 모듈식 출력은 LOM 모듈식 로그 모음(LOM Modular Log Collection, LMLC) 모듈에 제출된다. 따라서 LMLC은 입력 로그 데이터를 LOM 로그 집계로 참조된 읽을 수 있는 단일 파일로 결합한다. 파일은 해당 LOM 인스턴스의 전반적인 작동 상태를 포 함하므로, LOM 인스턴스가 다양한 결론에 도달한 방법에 대한 정보를 제공한다. LOM 로그 집계는 합 리적 어필(RA)(C811A)의 CC(C817A)에 제출된다. 도 752는 합리적 어필(RA)(C811A)에 정의된 입력 및 출력 채널과 관련하여 CTMP의 내부 작동을 설명하기 위해 도 751에 관한 작동 세부 사항을 확장한다. 사전 비판적 결정(C847)은 주장 생성(Assertion Construction, AC)(C808A)의 모듈식 출력으로 C843에 표시된다. CTMP의 두 가지 주요 입력 중 하나를 충 족하므로 결정(C847)은 주관적 의견(Subjective Opinion)(C848)으로 표시된다. 주관적 의견(C848)은 CTMP(12 4)의 기본적인 모듈식 입력 및 선택된 패턴 매칭 알고리즘(Selected Pattern Matching Algorithm, SPMA)의 내 부 표현으로 작동하는 입력 시스템 메타데이터(C484)에 제출된다. 상기 인스턴스 구성의 경우, SPMA는 LOM(13 2)이다. 입력 시스템 메타데이터(C484)는 처리를 위해 추론 처리(C456) 및 미가공 인식 생산(Raw Perception Production, RP2)(C465)으로 제출된다. 추론 처리(C456)은 속성 특성을 비교하여 만들어진 주장을 논리적으로 이해할 것이다. RP2(C465)는 LOM의 LOM의 알고리즘 인식을 나타내는 인식 복잡 포맷(Perception Complex Format, PCF)의 인식을 생성하기 위한 LOM으로부터 입력 시스템 메타데이터(C484)를 구문 분석한 다. 이러한 생성된 인식은 LOM의 알고리즘 인식을 에뮬레이트하는 인지 관찰자 애뮬레이터(Perception Observer Emulator, POE)(C475)에 제출된다. 추론 처리(C456)은 인스턴스에서 LOM인 SPMA 알고리즘을 반 영하는 규칙 집합을 최종적으로 생성하는 규칙 처리를 호출한다. 따라서 '사고(thinking)'의 두 가지 모드 인 '아날로그' 인식과 '디지털' 규칙 세트 처리가 실행된다. 상기 두 개의 브랜치 C461과 C475는 직관과 논리로 유사성을 나타낸다. 두 사고 브랜치인 C461과 C475에 의해 생성된 결과는 결과 사이의 충돌 또는 확증 (corroboration)의 기본적인 요소를 평가하는 비판적 결정 출력(CDO; Critical Decision Output)(C462)으로 전 송된다. 내부 확증의 높은 크기 및 내부 충돌의 낮은 크기을 발견하면, CTMP는 높은 신뢰도 결과(C846)으 로 언급되는 초기 입력 주관적 의견(C848)과 관련하여 2진수 승인 또는 차단 결정을 제공한다. 내부 확증의 낮 은 크기과 내부 충돌의 높은 크기라면, CTMP는 낮은 신뢰도 결과(C845)로 표시되는 '신뢰없는 투표('vote of no confidence)'를 제출한다. 따라서 CTMP의 결과 출력은 사후 비판적 결정(C851)으로 간주된다. 도 753은 CTMP 내에서 미가공 인식 생산(RP2)(C465)의 실시에 관한 세부 사항을 도시한다. LOM는 주 장 생성(AC)(C808A)을 호출하여 창의적 포텐셜 유닛을 생성한다. 그 다음, 창의적 포텐셜 유닛은 해당 AC(C808A) 인스턴스로부터 발생하는 입력 시스템 메타데이터(C484) 내에서 디버깅 추적(C485) 및 알고리즘 추적(C486)의 인스턴스를 생성하기 위한 데이터를 분석하는 RP2(C465)의 5506단계에 제출한다. 디버깅 추적 (C485)는 해당 입력, 출력 변수 유형 및 컨텐츠와 마찬가지로 사용되는 변수, 함수, 방법 및 분류를 제공하는 코딩 레벨 추적이다. 전체 기능 호출 체인(기능 추적: 다른 기능을 호출하는 기능)이 제공된다. 알고리즘 추적 (C486)은 알고리즘 분석과 결합된 보안 데이터를 제공하는 소프트웨어 레벨 추적이다. 결과 보안 결정(승인/차 단)은 결정(C847)에 도달한 방법에 대한 로지스틱 트레일(logistics trail)과 함께 제공된다. 결정(C847)을 생 성하기 위해 기여한 각 요인에 대한 적절한 가중치가 포함된다. 그 후, RP2(C465)는 처리를 위해 생성된 인식 결과에 관한 데이터를 인지 관찰자 애뮬레이터(POE)(C475)로 전송한다. 도 754는 CTMP 내에서 미가공 인식 생산(RP2)(C465)의 작동에 대해 자세히 설명한다. 도 753와 같이, 초기 단계는 해당 AC(C808A) 인스턴스에서 시작된 입력 시스템 메타데이터(C484) 내에서 디버깅 추적(C485) 및 알고리즘 추적(C486)의 인스턴스를 생성하도록 데이터를 분석하기 위해 발생한다. 5508단계에서, 메트릭 처리 (C489)는 LOM에 의해 제시된 인공 지능으로부터 인식을 추출하기 위한 LOM의 변수를 리버스 엔지니어 링한다. 그 후에, 입력 시스템 메타데이터(C484)는 시스템 메타데이터 분리(SMS)(C487)을 통해 중요한 보안 인 과 관계로 메타데이터(C484)를 분리하는 5510단계로 처리된다. 또한, 도 753에 의해 나타낸 바와 같이, RP2(C465)는 생성된 인식 결과에 관한 데이터를 처리를 위해 인지 관찰자 애뮬레이터(POE)(C475)로 전송한다. 도 755는 인지 저장(Perception Storage, PS)(C478)과의 관계 및 미가공 인식 생산(RP2)(C465)을 포함하는 인 지 관찰자 애뮬레이터(POE)(C475)의 작동에 대해 자세히 설명한다. 메트릭 처리(C489) 및 시스템 메타데이터 분 리(SMS)(C487)의 작동은 PS(C478)에 저장된 인식 5512/5514/5516의 생산으로 이어진다. 결과 인식 5512/5514/5516은 주장 생성(AC)(C808A)를 통해 목적 대체를 생성하는 LOM의 모듈식 응답을 나타낸 다. RP2(C465)는 검색 기준으로 스토리지 검색(SS)(C480)에 제공되는 비교 가능한 가변 포맷 데이터 포인트를 생성한다. 이후, SS(C480)은 PS(C478)에 저장된 기존 인식과 일치하는 PS(C478) 검색을 수행한다. 실행 SS(C480)의 결과(C716)은 가중치 계산(C718)으로 이어져 생성된다. 이러한 계산(C718)은 창의적 포텐셜 유닛 (Creative Potential Unit)을 생성한 LOM 알고리즘의 실행을 나타내는 비교 가능한 변수 형식을 복 제 및 일치시키기 위해 PS(C478)로부터 해당 인식의 정확한 분포를 찾기 위해 시도한다. 도 756은 도 755의 인지 관찰자 애뮬레이터(POE)(C475) 논리를 계속한다. 스토리지 검색(SS)(C480)에서 결과 (C716)를 생성한 후 가중치 계산(C718)은 능동적인 승인(C731) 또는 차단(C730) 결정을 내리기 위해 인식 5512/5514/5516의 어플리케이션(C729)으로 이어지도록 완료한다. LOM 및 해당 LOM 로그 집계에 의 해 생성된 창의적 포텐셜 맵은 파생되기 위해 데이터 개선 로그(C723)를 야기시키는 데이터 구문 분석 (C724)를 거치게 되며, 이는 입력 창의적 포텐셜 맵과 관련하여 긍정적 감정(승인)(C731) 또는 부정적 감 정(차단)(C730)의 해석 이분법을 달성하기 위해 어플리케이션(C729)에 적용된다. 애플리케이션(C729)의 실행이 성공적으로 완료되면 규칙 실행(RE)(C461)의 모듈식 출력과 병행하여 비판적 결정 출력(CDO; Critical Decision Output)(C462)에 의해 처리되는 오버라이드 수정 조치(C476)로 이어진다. 셀프 비판적 지식 밀도 (SCKD; Self-Critical Knowledge Density)(C474) 모듈은 보고할 수 있는 LOM 로그 집계의 범위를 넘어서 는 알려지지 않은 잠재적 지식의 범위와 유형을 추정한다. 상기 방법으로 CTMP 인스턴스 처리의 후속 비판 적 사고(critical thinking) 기능은 인스턴스에 의해 직접 알려져 있고 알려지지 않은 모든 관련 지식의 잠재적 인 범위를 활용할 수 있다 도 757은 도 756의 인지 관찰자 애뮬레이터(Perception Observer Emulator, POE)(C475)의 실행과 병행하여 작 동하는 메모리 웹(C460) 프로세스를 도시한다. LOM에서 생성된 창의적 포텐셜 맵은 추론 처리(C45 6)에 모듈식 입력으로 제출된다. 추론 처리(C456)은 LOM가 CVIP이 제공하는 프롬프트에 응답 하여 창의적 포텐셜 맵을 생성하기 위한 결정한 방법을 처리한다. 추론 처리(C456)의 처리 결론은LOM의 실행 동작과 세 번째로 일치하는 규칙을 정의하는 추론 처리의 실행(C457)이다. 만약 LOM의 실 행 동작과 관련하여 규칙 동작에서 불일치가 발견되면, 현재 존재하는 규칙들이 수정되거나 새로운 규칙이 추가 된다. 이러한 규칙은 나중에 해당 LOM 인스턴스에서 발견된 의사 결정 동작을 비판하기 위해 CTMP 인 스턴스 내에서 사용된다. 그 다음에, 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)은 알려진 인식을 활용하여 규칙 집합의 '비판적 사고(critical thinking)'범위를 확장하여 규칙 집합을 향상시켜 올바른 규칙(Correct Rules)(C459)을 생성한다. 올바른 규칙(C459)는 메모리 웹(C460)의 운영 관할구역 내에서 규칙 구문 포맷 분리(Rule Syntax Format Separation, RSFS)(C499)에 모듈식 입력으로 제출된다. RSFS(C499)는 유형별로 올바른 규칙(C459)을 분리하고 구성한다. 따라서 모든 조치, 특성, 조건 및 개체는 RSFS(C499) 처리 후 별도로 나열된다. 이를 통해 CTMP 인스턴스는 카오틱 필드(Chaotic Field)에서 발견된 부분과 그렇지 않은 부분을 식별할 수 있다. 카오틱 필드 구문 파싱(Chaotic Field Parsing, CFP)(C535)는 LOM 로그 집계 를 카오틱 필드로 참조되는 단일 스캔 가능한 유닛으로 결합하고 형식화한다. 카오틱 필드는 메모리 인식 (Memory Recognition, MR)(C501)에 모듈식 입력으로 제출된다. 또한, MR(C501)은 RSFS(C499)의 실행 결과인 원 본 규칙(C555)을 받는다. MR(C501)은 CFP(C535)에서 제공하는 카오틱 필드를 스캔하여 원본 규칙(C555)에 정의 된 알 수 있는 개념을 인식한다. 상기 MR(C501) 인스턴스 실행은 인식된 규칙 세그먼트(C556)을 생성한다. 그 후 규칙 이행 파서(Rule Fulfillment Parser, RFP)(C498)은 MR(C501)에 의해 카오틱 필드 내에서 인식 또는 부 족에 따라 태그가 지정된 원본 규칙(C555)의 개별 부분을 수신한다. 그 다음에, RFP(C498)은 규칙 실행 (RE)(C461)에 의해 처리를 수행하기 위해 카오틱 필드에서 어떤 전체 규칙 집합(모든 부분의 조합)가 충분히 인 식되었는지 논리적으로 추론할 수 있다. RE(C461)의 실행이 성공적으로 완료되면 비판적 결정 출력(CDO; Critical Decision Output)(C462)과 병행하여 인지 관찰자 애뮬레이터(POE)(C475)의 모듈식 출력에 의해 처리 되는 오버라이드 수정 조치(C476)로 이어진다. 도 758은 인지 저장(Perception Storage, PS)(C478)과 자동화된 인지 발견 메커니즘(Automated Perception Discovery Mechanism, APDM)(C467) 사이의 논리 흐름 상호 작용에 대해 자세히 설명한다. PS(C478)에는 인지의 추측된 미지 각도(Deduced Unknown Angles of Perception)(C473), 인지의 모든 각도(All Angles of Perception)(C472), 인지의 함축 각도(Implied Angles of Perception)(C471), 인지의 적용 각도(Applied Angles of Perception)(C470)과 같이 인식의 네 가지 하위 집합을 포함한다. 인지의 적용 각도(C470)은 상기 인스턴스에서 LOM인 선택된 패턴 매칭 알고리즘(SPMA)의 알고리즘 동작을 연구하여 직접 불러온 인식이다. 인지의 함축 각도(C471)은 인지의 적용 각도(C470)에서 암시 도출(implication Derivation, ID)(C477) 및 APDM(C467)의 모듈식 실행을 통해 도출된 인식이다. 인지의 모든 각도(C472)는 인지의 적용 각도(C470) 및 인지 의 함축 각도(C471)에 포함되지 않은 CTMP 인스턴스에 대한 알려진 인식의 전체 범위를 나타낸다. 인지의 추측된 미지 각도(C473)은 CTMP 셀프 비판적 지식 밀도(SCKD; Self-Critical Knowledge Density)(C474) 모듈에 따라 아직 발견되지 않은 상태에서 존재할 것으로 예상되는 인식의 범위를 나타낸다. APDM(C467)은 초기 두 입력 가중치(C652)를 결합하는 신규 반복(C653)을 생성하도록 창의성 모듈을 통해 인지의 각도(C650)의 구성을 창의적으로 서로 다르게 하지만, ID(C477)은 결정적으로 인지의 적용 각도(C470)을 도출하기 위해 인지 의 적용 각도(C470)의 개별 메트릭(metrics)를 분석한다. 따라서 APDM(C467) 처리와 관련된 모든 인지의 각도 (C650)은 LOM의 주장 생성(AC)(C808A) 모듈에 의해 생성된 창의적 포텐셜 맵에 해당하고 이를 나타 낸다. 도 759는 CTMP의 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)에 대한 작동 세부 사항에 대해 자세히 설명한다. 합리적 어필(RA; Rational Appeal)(C811A) 인스턴스는 LOM 로그 집계(LOM Log Aggregate)를 카오틱 필드 파싱(CFP; Chaotic Field Parsing)(C535)으로 처리하기 위해 LOM 내에서 작동하고 문맥 구성(CC; Context Construction)(C817A)를 호출한다. CFP는 메모리 인식(MR)(C501)에서 참조하 는 CC(C817A)의 모듈식 출력에서 카오틱 필드를 생성한다. 현재 규칙(C534)는 이 인스턴스에서 LOM인 선 택된 패턴 매칭 알고리즘(SPMA)의 현재 기능 상태를 나타내는 규칙 집합을 표시한다. 현재 규칙(C534)는 규칙 구문 미분(Rule Syntax Derivation, RSD)(C504) 모듈에 모듈식 입력으로 제출되며, 이는 논리적으로 '흑백' 규 칙들은 인식을 기반으로 메트릭을 변환하는 곳이다. 따라서 여러 규칙의 복잡한 배열은 다양한 그래디언트의 여 러 메트릭(metrics)를 통해 표현되는 단일 균일 인식으로 변환된다. RSD(C504)의 모듈식 출력은 인색 매칭 (Perception Matching, PM)(C503)에 모듈식 입력으로 제공된다. PM(C503)에서, 비교 가능한 가변 포맷 (Comparable Variable Format, CVF) 유닛은 RSD(C504)에서 수신한 인식으로 구성된다. 새로 형성된 CVF는 유사 한 인덱스를 가진 인지 저장(PS)(C478)에서 관련 인식을 검색하는 것으로 사용된다. 잠재적 일치 항목은 규칙 구문 생성(Rule Syntax Generation, RSG)(C505)에 모듈식 입력으로 제출된다. RSG(C505)는 인식 형식으로 저장 된 이전에 확인된 인식을 수신하고 인식의 내부 메트릭 구성에 접근한다. 인식은 이전에 확인된 인식(C468)이포함된 PS(C478)에서 수신된다. 이러한 메트릭(metrics)의 그래디언트 기반 측정은 원래 인식의 입력/출력 정보 흐름을 에뮬레이트하는 이진법 및 논리 규칙 집합으로 변환된다. 따라서 RSG(C505)는 관련성이 있고 대중적으로 고려되며 논리적 규칙으로 변환된 인식(Perceptions)인 인지 규칙(Perceptive Rules)(C537)을 생성한다. 만약 (초기 인식 포맷에서) 인식이 많은 '회색 영역'을 정의한 많은 복잡한 메트릭 관계가 있는 경우, '흑백' 로컬 규칙은 규칙 집합 복잡도를 확장함으로써 이러한 '회색' 영역을 포함한다. 따라서 인지 규칙(C537)은 규칙 구문 포맷(RSF) 정의의 모음으로 저장된다. 인지 규칙(C537)은 메모리 인식(MR)(C501)에 모듈식 입력으로 제출되며, 메모리 인식(MR)(C501)에서 CFP(C535)에 의해 생성된 카오스 필드에 대해 스캔된다. 따라서 MR(C501)은 유효성 있는 올바른 규칙(C533)을 완성하는 추가 규칙(C536)을 생성한다. 도 760은 CTMP의 암시 도출(Implication Derivation, ID)(C477)에 대한 작동 세부 사항에 대해 자세히 설 명한다. 인지 저장(PS)(C478)의 인지의 적용 각도(C470)은 인지의 함축 각도(C471)에 속하는 더 많은 인식을 생 성하기 위해 모듈식 입력으로 ID(C477)에 제출된다. 인지의 적용 각도(C470)은 구체적으로 ID(C477)의 메트릭 조합(C493)으로 전송된다. 메트릭 조합(C493)은 메트릭(metrics)의 카테고리에 대해 수신된 인지의 각도(C650) 을 범위(Scope)(C739), 유형(Type)(C740), 일관성(Consistency)(C741), 강도(Intensity)(C742)로 구분한다. 시 스템 내에서 메트릭 가용성 및 참조가 반드시 상기 네 가지 유형으로 제한되는 것은 아니다. 인지의 각도(C650) 입력은 LOM의 주장 생성(AC)(C808A) 모듈에 의해 생성된 목적 대체와 관련이 있다. 메트릭 복잡도 세트 A(C736)는 메트릭 확장(Metric Expansion, ME)(C495)에 모듈식 입력으로 제출된다. ME(C495)를 사용하여 여러 인식의 각도(C650) 및 다양한 각도의 메트릭은 개별 데이터베이스 C739, C740, C741, C742 카테고리 별로 저장된다. ME(C495)는 이전에 알려진/접한 메트릭에서 추출된 세부 사항/복잡도로 수신된 메트릭의 현재 배포를 향상시킨다. 향상 및 복잡도 강화 완료에 따라, 메트릭은 메트릭 복잡도 세트 B(C737)으로 ME(C495) 모듈식의 출력으로 반환되고 그 후에 도 761에 설명된 바와 같이, 인지의 함축 각도(C471)에 저장되도록 인지의 각도 (C650)로 다시 변환된다. 도 761은 개별 메트릭을 전체 인지의 각도(C650)으로 되돌리는 메트릭 변환(C494)에 의해 처리되는 메트릭 복잡 도 세트 B(C737)를 설명하는 도 760으로부터 암시 도출(ID)(C477)의 논리 흐름을 계속한다. ID(C477)에 의해 수 행된 향상 및 변환 프로세스에도 불구하고, 생성된 인지의 각도(C650)는 여전히 LOM의 주장 생성 (AC)(C808A) 모듈에 의해 생성된 창의적 포텐셜 맵의 합리적으로 정확한 묘사를 제공한다. 따라서 메트릭 변환(C494) 프로세스는 새로 도출/암시된 인식의 각도(C650)를 인지 저장(PS)(C478) 내의 인지의 함축 각도 (C471)에 제출한다. 도 762는 CTMP의 비판적 결정 출력(CDO; Critical Decision Output)(C462)에 대한 작동 세부 사항에 대해 자세히 설명한다. 비판적 결정 출력(CDO; Critical Decision Output)(C462)는 CTMP의 두 가지 주요 브랜 치로부터 모듈식의 출력을 수신하고, (직관력 브랜치로서) 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)와 (논리적 브랜치로서) 규칙 실행(RE; Rule Execution)(C461)가 있다. 각 브랜치 C475/461은 그것의 각각의 비판적 결정(Critical Decision)(C521) (메인 모듈식의 출력)뿐 아니라 해당하는 '메타-메타 데 이터(Meta-metadata)'(C521)을 제출하며, 이는 초기 중요 결정에 도달한 이유를 정당화하는 맥락 변수를 제공한 다. POE(C475)의 인식(C516)과 RE(C461)의 이행된 규칙(C517)을 나타내는 두 결정 세트(C521)는 메타데이터 분 류 모듈(Metadata Categorization Module, MCM)(C488)에 제출된다. MCM(C488)은 전통적인 구문 기반 정보 카테 고리화를 사용하여 디버깅 및 알고리즘 추적을 개별의 카테고리로 분류한다. 그러면 이러한 카테고리는 보안 위 험과 대상과의 상관관계를 가지고 분명한 보안 대응을 조직하고 생성할 수 있다. POE(C475)의 인식(C526)을 나 타내는 직관적 의사 결정(C514)와 RE(C461)의 이행된 규칙(C517)을 나타내는 사고 결정(C515)은 MCM(C488)에 의해 방향 결정 비교(DDC)(C512)의 내부 프로세싱 로직에 제출된다. DDC(C512)의 내부 프로세싱 로직 은 직관적 의사 결정(C514)와 사고 결정(C515) 사이의 확증 또는 충돌을 확인한다. DDC(C512)는 정적 하 드코드된 정책(Static Hardcod-ed Policy, SHP)의 '차단 변수(cutoff variable)'를 참조한다. 만약 차단 변수는 직관적 의사 결정(C514)와 사고 결정(C515) 사이에 유사성에 도달하지 않으면 (예를 들어, 90 % +), 무 효화 직접 비교는 직접 발생하며, 이는 도 763에 도시된 바와 같이, 확신없는 투표에 최종적으로 제출하도록 터미널 출력 제어(TOC)(C513)에 연결된다. 무효화 직접 비교 단계는 CTMP가 CVIP(865 0)의 프롬프트 입력과 관련하여 내부적으로 일관성 있는 작동할 수 없음을 의미한다. 만약 '차단 변수가 내부 프로세싱 로직에 따라 충분히 충족되면, 최종 비판적 출력(Final Critical Decision) 단계가 터미널 출력 제어(TOC)(C513)에 의해 수신 및 처리되는 단일 모듈식의 출력으로 두 결정 C514/C515를 결합하여 호출한다. 도 763은 도 762의 비판적 결정 출력(CDO; Critical Decision Output)(C462)의 논리 흐름을 계속하고 터미널 출력 제어(Terminal Output Control, TOC)(C513)의 작동 세부 사항을 자세히 설명한다. TOC(C513)은 방향 결정 비교(DDC)(C512)가 (무효화 직접 비교 지시 대신) 최종 비판적 출력(Final Critical Decision)을 제공할 수 있는지 확인하는 프롬프트으로 시작한다. 프롬프트에 대한 응답이 Yes인 경우, 최 종 비판적 출력(Final Critical Decision)에서 DDC(C512)에 의해 제공된 결합된 최종 결정은 TOC(C513) 의 모듈식 출력으로 제출되며, 따라서 최종 임계 결정으로 전체 CTMP 인스턴스의 모듈식 출력으로서 제출된다. 프롬프트에 대한 응답이 No인 경우, 5532단계가 자체적으로 인식 매칭(PM; Perception Matching)의 실행을 호출하고 해당 결과를 가져오게 되어 호출된다. 이행된 규칙(C517)은 규칙 실행 (RE)(C461)의 중요 결정 + 메타-메타 데이터(C521)에서 추출된다. 규칙(C517)은 규칙 구문 미분(RSD)(C504)에 의해 인식으로 변환된다. 그 다음에, PM는 프롬프트에서 강력한 내부 중복(strong internal overlap)과 사용된 인식의 확증(corroboration of Perceptions)이 있는지 결정하기 위해 메타-메타 데이터를 참조한다. 만약 프롬프트에 대한 응답이 예인 경우, 모듈식 출력으로 CTMP 대신하여 확신없는 투표를 나타낸다. 만약 프롬프트에 대한 응답이 No인 경우, 5540단계가 활성화되어 직관적 의사 결정(C514)와 사고 결정(C515) 사이에서 인식된 가장 위험이 덜한 결정을 선택한다. 따라서 최종 임계 결 정는 비판적 결정 출력(CDO; Critical Decision Output)(C462), TOC(C513) 및 CTMP에 모듈식 출력 으로 제출된다. 5534단계의 논리는 직관적 의사 결정(C514)와 사고 결정(C515) 사이의 일치성 부족이 알고리즘 에 대한 신뢰가 부족하거나, 둘 사이의 반대되는 관점 때문에 발생하는지 여부를 판별하기 위해 발생한다. 따라 서 후자가 발생할 경우, 잠재적인 최종 임계 결정는 여전히 모듈식 출력으로 식별할 수 있다. 확신없는 투표는 항상 합리적 어필(RA)(C811A) 내에서 신뢰도가 낮은 신뢰도 결과 (C845) 논리 경로로 이어진다. 최종 임계 결정는 최종 임계 결정 뒤에 알고리즘 신뢰도에 따라 RA(C811A) 내에서 높은 신뢰도 결 과(C846) 또는 낮은 신뢰도 결과(C845) 논리 경로로 이어질 수 있다. 도 764는 LOM이 창의적 포텐셜 맵을 생성하는 8644단계에서, 신규 앱체인 개발(NAD) 시작을 도시한 다. 8707단계에서, CDM은 창의적 포텐셜 맵을 처리하고 창의성 모듈를 통해 상이한 솔루션을 형성하고 이들을 I2GE로 테스트한다. 창의적 디자인 매니페스트(CDM)은 구문 창조 솔루션를 생산한다. 도 765는 CDM이 구문 창조 솔루션를 생성하는 도 764의 신규 앱체인 개발(NAD)의 논리를 계 속한다. 8710단계에서, LIZARD은 구문 창조 솔루션를 위한 목적 계층 맵을 도출하고 구문 창 조 솔루션의 맵을 포함하기 위해 UBEC 플랫폼의 목적 계층 맵을 조정한다. 도 766은 구문 창조 솔루션(Syntactical Creative Solutions)을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 구문 창조 솔루션는 외부 코어(OC)(C329)의 관할구역 에 속하는 구문 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기 능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. Appchains to Create은 코드 변환(C321)에 의해 혼합 실행/데이터 스트림 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인 식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문 (C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논 리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모 듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하 기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 767은 구문 창조 솔루션을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위 해 도 766의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석 (C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위 해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 구문 창조 솔루션의 복합 목적 포맷(C325) 버전으로 표시되는 로지스틱스 레이어로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적 용은 전술한 기능 및 모듈에 적용된다. 도 768은 구문 창조 솔루션의 목적 계층 맵을 포함하는 UBEC 플랫폼의 목적 계층 맵을 조정하는 8704 단계에서 신규 앱체인 개발(NAD) 프로세스를 도시한다. 목적 재조정 처리(Purpose Realignment Processing, PRP)은 업그레이드된 목적 맵을 만들기 위해 마스터/슬레이브 선호도 로부터 입력을 수신한다. 8716단계에서, LIZARD은 업그레이드된 목적 맵 내에서 구문 적 창의 적 솔루션의 8709 목적 계층 맵의 목적 구조를 선택한다. 일반적으로 NAD은 잠재적인 어플리케이션 기능이 누락된 특정 어플리케이션 에코 시스템 내에서 어플리케이션에 대한 용도를 찾으며, 이는 에코시스템과 같이 인지할 수 있는 이점을 제공할 수 있다. 도 769는 LIZARD이 로지스틱스 레이어 형태로 새로운 어플리케이션을 변환하기 위해 구문 모듈 (SM)(C35)을 사용하는 8717단계에서 프로세스를 설명하기 위해 도 768의 논리 흐름을 계속한다. 업그레이드된 목적 맵 내에 존재하는 모든 종속성 및 보완 유지되었다. 커스텀체인 생태계 빌더(Customchain Ecosystem Builder, CEB)는 로지스틱스 레이어를 수신하고 8718단계에서 UBEC 플랫폼과 일치하는 앱체인/ 마이크로체인를 구축한다. 도 770은 업그레이드된 목적 맵을 로지스틱스 레이어로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 업그레이드된 목적 맵 복합 목적 포맷(C325)에 존재하며, LIZARD의 외부 코 어(OC)(C329) 내에 목적 모듈(C36)의 반복 확장(C327)을 설명하기 위해 제출된다. 반복 확장(C327)은 간단한 목 표를 특정 복잡한 목적 정의로 발전시키기 위해 세부 사항과 복잡성을 추가한다. 따라서 입력의 최대 목적 연관 성(C326) 잠재성은 구문 모듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에 복합 목적 포맷(C325)으로 실현되고 유지된다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스 레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 771은 업그레이드된 목적 맵을 로지스틱스 레이어로 변환하기 위한 LIZARD의 작동을 설명하 기 위해 도 770의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM)(C36)에서 복합 목적 포맷(C325)으로 수 신되고 구문 모듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 기능에서 논리적으로 필요한 기능을 도출한다. 이는 만약 함수가 더 간단한 상위의 함수로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수의 트리이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC)(C333)의 핵심 코드 (C335) 요소로부터 상속된 규칙 및 구문(C322) 정의에 따라 작동한다. 논리적 미분(Logical Derivation)(C32 0)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 따라서 PM(C36)은 코드 변환(C321)을 통 해 입력 업그레이드된 목적 맵의 결과 앱체인 구문 버전을 생성하기 위해 SM(C35)를 호출한다. 코드 변환 (C321)에 의해 최종적으로 생성되는 결과 로지스틱스 레이어 유닛은 SM(C35), 외부 코어(OC)(C329) 및 LIZARD의 모듈식 출력이다. 도 772는 타겟 앱체인이 어플리케이션 상태 검사(Application State Inspection, ASI)에 의해 그 것의 유지보수 필요성에 대한 검사가 선택되는 8721단계에서 자동화 앱체인 유지보수(Automated Appchain Maintenance, A2M) 프로세스 시작을 도시한다. 초기 유지보수 필요성(Innate Maintenance Needs)은 만료된 캐시(Expired Caches), 감가 상각된 기능(Depreciated Functions), 감가 상각된 모듈 및 종속성(Depreciated Modules and Dependencies), 만료된 참조점(Expired Points of Reference) 및 경제적 안정성 교정(Economical Stability Calibration)으로 구성된다. 도 773은 도 772로부터 자동화 앱체인 유지보수(A2M) 프로세스 시작을 계속하며, 8730단계에서 앱체인 유 지보수 추적(Appchain Maintenance Tracking, AMT) 데이터베이스가 타겟 앱체인의 초기 유지보수 필요성 최신 상태를 포함하도록 업데이트한다. 앱체인의 모든 X 새로운 블록에 대해, 이러한 앱체인은 8732단계에서 적절한 유지보수 조치를 수행하도록 앱체인 유지보수 개발(AMD)에 의해 처리된다. 임의의 앱체인은 앱체인 유지보수 개발(AMD) 및 커스텀체인 인터페이스 모듈(CIM)에 제출되며, 이는 해결된 블록 공고(Solved Work New Block Announcement)을 8732단계로 제출한다. 8738단계에서, LIZARD은 하드웨어 구조 해석을 하드웨어 목적 맵으로 참조되는 목적 포맷으로 변환한다. 도 774는 LOM 및 CTMP를 사용하는 하드웨어 목적 맵에 기초한 이상적인 프레임워크 구조를 생 성하기 위한 향상된 프레임워크 개발(Enhanced Framework Development, EFD)을 도시한다. EFD(Enhanced Framework Development)는 (프로그래밍 언어와 같이) UBEC 플랫폼/BCHAIN 네트워크 및 레거시 시스템(Legacy system) 모두에서 기존 소프트웨어 프레임워크를 점검하고 잠재적으로 향상시킨다. EHD(Enhanced Hardware Development)은 DLCB(Dynamic Liquid Conductive Boards)을 포함하는 물리적 시스템을 수정하므로 핵심 하드웨어 구조를 최적화하고 업그레이드할 수 있다. 프레임워크 해석 메커니즘(FIM)는 프레임워크 구조 해석을 LIZARD으로 제공한다. 8740단계에서, LIZARD은 프레임워크 구조 해석 을 프레임워크 목적 맵으로 참조되는 목적 포맷으로 변환된다. (하드웨어 해석 메커니즘(Hardware Interpretation Mechanism, HIM)을 포함하는) 하드웨어 구조 조사(Hardware Structure Survey, HS2)는 하드웨어 구조 해석을 LIZARD으로 제공한다. 8744단계에서, LOM 및 CTMP는 하드웨어 목적 맵에 따라 이상적인 프레임워크 구조를 생성한다. 도 775는 하드웨어 구조 해석(Hardware Structure Interpretation)를 하드웨어 목적 맵(Hardware Purpose Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 하드웨어 구조 해석 는 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼 (helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 하드웨어 구조 해석은 코드 변환(C321)에 의해 하드웨어 사양 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한 다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감 소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식 으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35) 의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포 맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각 을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하 게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 776은 하드웨어 구조 해석를 하드웨어 목적 맵으로 변환하기 위한 LIZARD의 작동을 설명하 기 위해 도 775의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD(12 0)을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 하드웨어 구조 해석의 복 합 목적 포맷(C325) 버전으로 표시되는 하드웨어 목적 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 777은 프레임워크 구조 해석(Framework Structure Interpretation)을 프레임워크 목적 맵(Framework Purpose Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 프레임워크 구조 해 석은 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽 고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한 다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼 (helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 프레임워크 구조 해석은 코드 변환(C321)에 의해 프레임워크 사양 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수 (inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단 한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관 련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코 드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷 (C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보 수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역 이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크 립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가 능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 778은 프레임워크 구조 해석을 프레임워크 목적 맵으로 변환하기 위한 LIZARD의 작동을 설 명하기 위해 도 777의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생 성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 프레임워크 구조 해석 의 복합 목적 포맷(C325) 버전으로 표시되는 프레임워크 목적 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 779는 LOM 및 CTMP가 하드웨어 목적 맵에 따라 이상적인 프레임워크 구조를 생성하는 향상된 프레임워크 개발(EFD)을 도시한다. 8746단계에서, LOM은 하드웨어 구조 해석을 포함하는 하 드웨어 목적 맵을 수신한다. 8748단계에서, LOM는 중앙 지식 보유(Central Knowledge Retention, CKR)에서 효율성 원칙을 생성한다. 8744단계에서, LOM 및 CTMP는 하드웨어 목적 맵 에 따라 이상적인 프레임워크 구조를 생성한다. 도 780은 디자인 원칙 호출 프롬프트(Design Principle Invocation Prompt, DPIP)을 기반으로 CKR 에서 효율성 디자인 원칙을 생성하기 위해 LOM의 작동을 설명하기 위해 도 779의 논리 흐름을 계속한다. LOM은 효율성 디자인 원칙의 결정 프로세스를 가능하게 하는 ARM로 검색된 데이터로부터 CKR 내에 오버타임 개념을 구축한다. CKR은 선천적인 발전 추론을 통해 강력한 정의 기반을 구축하고 LOM이 출 력하는 어떤 결론도 정당화할 수 있다. 클러스터 구축(C854F)으로 CKR은 UKF(Unit Knowledge Format) 클러스터(C854F)로 알려진 '스태킹(stacking)' 구축 블록의 정보를 통해 개념적 결론에 도달한다. 상기 클러스터는 귀속 가능한 출처(attributable sources), 의심되는 정보 생성 시간, 효율성, 디자인 등 대상 정보 와 관련된 광범위의 메타 데이터를 포함한다. 각 UKF 클러스터(C854F)는 규칙 구문 포멧(RSF)(C538)을포함한다. 도 781은 향상된 프레임워크 개발(EFD)의 8744단계와 관련하여 LOM 및 CTMP의 내부 작동 절차 를 도시한다. 효율성 디자인 원칙, 안정성 디자인 원칙 및 하드웨어 목적 맵은 추론 호출 프 롬프트(Deduction Invocation Prompt, DIP)에 초기 입력으로 제공된다. DIP은 효율성 디자인 원칙 , 안정성 디자인 원칙 및 하드웨어 목적 맵을 고려하여 이상적인 프레임워크 구조의 생산을 호출하기 위해 LOM와 직접 상호 작용하는 프롬프트을 생산한다. DIP에서 생성된 프롬 프트는 LOM의 초기 쿼리 추론(IQR)(C802A) 모듈에 제출된다. LOM이 UBEC 사용자에 의해 UBEC 플랫폼 내에서 직접 호출될 때, IQR(C802A)는 UBEC 사용자에 의해 제공된 초기 질문/주장을 수 신한다. 그러나, 상기 LOM 인스턴스는 대신 DIP에 의해 자동으로 호출된다. 제공된 프롬프트 은 프롬프트에게 완전히 주소/응답하기 위한 LOM에 정확한 '가상 이해'를 완료하기 위해 중요한 프 롬프트로부터 누락된 세부 사항을 판독하기 위해 중앙 지식 보유(CKR)의 호출(invocation)를 통해 분석된다. IQR(C802A)에 의해 생성된 결과 누락된 세부 사항은 모듈식 입력으로 조사 구분(SC)(C803A)에 제출된 다. 프롬프트은 객관적이고 모든 필요한 문맥을 분석할 수 있도록 SC(C803A)는 보충 정보를 검색하여 프 롬프트의 출처와 연결한다. UBEC 사용자에 의해 LOM이 UBEC 플랫폼 내에서 직접 호출될 때, SC(C803A)는 질문/응답의 출처로서 그 사용자와 연동한다. 그러나 상기 LOM 인스턴스는 대신 DIP에 의해 자동으로 호출되므로 SC(C803A)는 프롬프트에 관한 보충 정보를 검색하기 위해 DIP과 연동한다. 프롬프트의 완전한 형태와 개선된 버전은 SC(C803A)에서 생산되며 주장 생성 (AC)(C808A)에 모듈식 입력으로 제출된다. AC(C808A)는 CKR을 직접 참조하거나 계층적 매핑(HM)(C807A)를 통해 프롬프트에 대한 일관된 응답을 구성하기 위해 시도한다. 합리적 어필(RA)(C811A)는 CTMP와의 논리 흐름 인터페이스를 수용하는 컨테이너 모듈이다. RA(C811A)는 주장을 비판하기 위해 CTMP를 사용한다. 이러한 비판은 (AC(C808A)의 출력을 비판함으로써)자체 비판의 형태 또는 (UBEC 사용자 또는 DIP) IQR(C802A)에 의해 처리된 질문/주장의 출처에 대한 외부 비판의 형태일 수 있다. 만약 AC(C808A)에 서 생성된 주장이 RA(C811A)에 의해 처리된 자체 비판 테스트에 대한 중요한 측정에 실패한 경우, AC(C808A)의 새로운 인스턴스는 유효한 비판을 설명하기 위해 호출된다. 만약 높은 신뢰도 주장은 RA(C811A)에 의해 처리된 자체 비판 테스트를 지속적으로 통과하는 AC(C808A)에 의해 생성되는 경우, 주장은 DIP에서 제공하는 초 기 프롬프트의 문맥에서 이상적인 프레임워크 구조으로 참조되는 LOM의 모듈식 출력으로 생성 된다. 도 782는 EFD의 8304단계와 관련하여 LOM의 합리적 어필(RA)(C811A)의 내부 작동 과정에 대한 세부 사항을 도시한다. 주장 생성(Assertion Construction, AC)(C808A)는 해당 입력 프롬프트에 관해서 AC(C808A)에 의해 생성된 주장에 대한 합리적 어필(RA)(C811A)에 응답 프레젠테이션(C843)을 제공한다. 논리 흐 름의 상기 단계에서 생성된 주장은 사전 비판적 결정(C847)으로 분류된다. 이는 CTMP에 의한 비판을 통해 아직 처리되지 않았음을 의미한다. 따라서 생성된 주장은 '주관적 의견(Subjective Opinion)(C848)’ 입력으로 CTMP 인스턴스에 직접 제출되며 또한, CTMP 인스턴스에 ‘객관적 팩트(Objective Fact)(C850)’ 입 력을 제공하는 문맥 구성(CC)(C817A)에 제출된다. CC(C817A)는 AC(C808A)의 메타데이터와 비판적 사고 (critical thinking)를 위해 미가공 팩트(raw fact)를 CTMP에 제출하는 DIP을 통해 제공되는 잠재 적 증거를 참조한다. 이러한 입력 메타데이터는 LOM 로그 집계 파일로 표시된다. LOM 로그 집계는 LOM의 기본적인 운영 기능으로부터 생성된 관련 로그 파일의 모음이 포함되어 있다. CTMP 인스턴스가 작동을 마치면 사후 비판적 결정(C851)이 모듈식 출력으로 생성된다. 초기 사전 비판적 결정(C847) 및 사후 비 판적 결정(C851)은 두 입력 C847과 C851 사이의 잠재적 중복의 범위를 결정하는 의사 결정 비교(DC)(C818A) 모 듈에 제출된다. DC(818A)가 제공하는 통합 출력은 주장을 생성하는 AC(C808A)을 대신하여 CTMP의 (부정확 한) 양보(Concession)(C852) 또는 주장을 생성하는 AC(C808A)를 대신하여 인지된 개선(C853)을 나타낼 수 있다. 인수 응답인 C852 및 C853은 모두 낮은 신뢰도 결과(C845) 또는 높은 신뢰도 결과(C846)로 분류할 수 있 다. 낮은 신뢰도 결과(C845)는 AC(C808A)에 의해 생성된 초기 주장이 결함이 있음을 나타내며 재구성해야 한다. 따라서, 논리 흐름은 AC(C808A)의 새로운 인스턴스로 계속 이어진다. 높은 신뢰도 결과(C846)은 AC(C808A)에 의 해 생성된 초기 주장이 장점이 있음을 나타내므로 도출된 결론(해당 증거, 전제 등과 결합됨)이 지식 검증 (KV)(C805A)에 제출된다. 따라서 논리 흐름은 CKR 및 LOM가 최근에 처리된 주장으로부터 이점을 얻을 수 있도록 KV(C805A)의 새로운 인스턴스로 계속 진행된다. 도 783은 LOM 로그 집계 파일의 생성을 설명하기 위해 EFD로부터 8744단계의 논리 흐름을 계속한다. 초기 쿼리 추론(IQR)(C802A), 조사 구분(SC)(C803A), 주장 생성(AC)(C808A), 계층적 매핑 (HM)(C807A) 및 지식 검증(KV)(C805A)에서 생성된 모듈식 출력은 LOM 모듈식 로그 모음(LOM Modular LogCollection, LMLC) 모듈에 제출된다. 따라서 LMLC은 입력 로그 데이터를 LOM 로그 집계로 참조된 읽을 수 있는 단일 파일로 결합한다. 파일은 해당 LOM 인스턴스의 전반적인 작동 상태를 포 함하므로, LOM 인스턴스가 다양한 결론에 도달한 방법에 대한 정보를 제공한다. LOM 로그 집계는 합 리적 어필(RA)(C811A)의 CC(C817A)에 제출된다. 도 784는 합리적 어필(RA)(C811A)에 정의된 입력 및 출력 채널과 관련하여 CTMP의 내부 동작을 설명하기 위해 도 783에 관한 작동 세부 사항을 확장한다. 사전 비판적 결정(C847)은 주장 생성(Assertion Construction, AC)(C808A)의 모듈식 출력으로 C843에 표시된다. CTMP의 두 가지 주요 입력 중 하나를 충 족하므로 결정(C847)은 주관적 의견(Subjective Opinion)(C848)으로 표시된다. 주관적 의견(C848)은 CTMP(12 4)의 기본적인 모듈식 입력 및 선택된 패턴 매칭 알고리즘(Selected Pattern Matching Algorithm, SPMA)의 내 부 표현으로 작동하는 입력 시스템 메타데이터(C484)에 제출된다. 상기 인스턴스 구성의 경우, SPMA는 LOM(13 2)이다. 입력 시스템 메타데이터(C484)는 처리를 위해 추론 처리(C456) 및 미가공 인식 생산(Raw Perception Production, RP2)(C465)으로 제출된다. 추론 처리(C456)은 속성 특성을 비교하여 만들어진 주장을 논리적으로 이해할 것이다. RP2(C465)는 LOM의 알고리즘 인식을 나타내는 인식 복잡 포맷(PCF)의 인식을 생성하기 위 한 LOM으로부터 입력 시스템 메타데이터(C484)를 구문 분석한다. 이러한 생성된 인식은 LOM의 알고리 즘 인식을 에뮬레이트하는 인지 관찰자 애뮬레이터(POE)(C475)에 제출된다. 추론 처리(C456)은 인스턴스에서 LOM인 SPMA 알고리즘을 반영하는 규칙 집합을 최종적으로 생성하는 규칙 처리를 호출한다. 따라서 '사고 (thinking)'의 두 가지 모드 인 '아날로그' 인식과 '디지털' 규칙 세트 처리가 실행된다. 상기 두 개의 브랜치 C461과 C475는 직관과 논리를 가진 유사성을 나타낸다. 두 사고 브랜치인 C461과 C475에 의해 생성된 결과는 결 과 사이의 충돌 또는 확증(corroboration)의 기본적인 요소를 평가하는 비판적 결정 출력(CDO; Critical Decision Output)(C462)으로 전송된다. 내부 확증의 높은 크기 및 내부 충돌의 낮은 크기을 발견하면, CTMP는 높은 신뢰도 결과(C846)으로 언급되는 초기 입력 주관적 의견(C848)과 관련하여 2진수 승인 또는 차단 결정을 제공한다. 내부 확증의 낮은 크기과 내부 충돌의 높은 크기라면, CTMP는 낮은 신뢰도 결과 (C845)로 표시되는 '신뢰없는 투표('vote of no confidence)'를 제출한다. 따라서 CTMP의 결과 출력은 사 후 비판적 결정(C851)으로 간주된다. 도 785는 CTMP 내에서 미가공 인식 생산(RP2)(C465)의 호출에 관한 세부 사항을 도시한다. LOM은 주 장 생성(AC)(C808A)을 호출하여 이상적인 프레임워크 구조를 생성한다. 그 다음, 이상적인 프레임워크 구 조는 해당 AC(C808A) 인스턴스로부터 발생하는 입력 시스템 메타데이터(C484) 내에서 디버깅 추적(C485) 및 알고리즘 추적(C486)의 인스턴스를 생성하기 위한 데이터를 분석하는 RP2(C465)의 5506단계에 제출한다. 디 버깅 추적(C485)는 해당 입력, 출력 변수 유형 및 컨텐츠와 마찬가지로 사용되는 변수, 함수, 방법 및 분류를 제공하는 코딩 레벨 추적이다. 전체 기능 호출 체인 (기능 추적: 다른 기능을 호출하는 기능)이 제공된다. 알고 리즘 추적(C486)은 알고리즘 분석과 결합된 보안 데이터를 제공하는 소프트웨어 레벨 추적이다. 결과 보안 결정 (승인/차단)은 결정(C847)에 도달한 방법에 대한 로지스틱 트레일(logistics trail)과 함께 제공된다. 결정 (C847)을 생성하기 위해 기여한 각 요인에 대한 적절한 가중치가 포함된다. 그 후, RP2(C465)는 처리를 위해 생 성된 인식 결과에 관한 데이터를 인지 관찰자 애뮬레이터(POE)(C475)로 전송한다. 도 786은 CTMP 내에서 미가공 인식 생산(RP2)(C465)의 작동에 대해 자세히 설명한다. 도 753와 같이, 초기 단계는 해당 AC(C808A) 인스턴스에서 시작된 입력 시스템 메타데이터(C484) 내에서 디버깅 추적(C485) 및 알고리즘 추적(C486)의 인스턴스를 생성하도록 데이터를 분석하기 위해 발생한다. 5508단계에서, 메트릭 처리 (C489)는 LOM에 의해 제시된 인공 지능으로부터 인식을 추출하기 위한 LOM의 변수를 리버스 엔지니어 링한다. 그 후에, 입력 시스템 메타데이터(C484)는 시스템 메타데이터 분리(SMS)(C487)을 통해 중요한 보안 인 과 관계로 메타데이터(C484)를 분리하는 5510단계로 처리된다. 또한, 도 785에 의해 나타낸 바와 같이, RP2(C465)는 생성된 인식 결과에 관한 데이터를 처리를 위해 인지 관찰자 애뮬레이터(POE)(C475)로 전송한다. 도 787은 인지 저장(PS)(C478)과의 관계 및 미가공 인식 생산(RP2)(C465)을 포함하는 인지 관찰자 애뮬레이터 (POE)(C475)의 작동에 대해 자세히 설명한다. 메트릭 처리(C489) 및 시스템 메타데이터 분리(SMS)(C487)의 작동 은 PS(C478)에 저장된 인식 5512/5514/5516의 생산으로 이어진다. 결과 인식 5512/5514/5516은 주장 생성 (AC)(C808A)를 통해 이상적인 프레임워크 구조을 생성하는 LOM의 모듈식 응답을 나타낸다. RP2(C465)는 검색 기준으로 스토리지 검색(SS)(C480)에 제공되는 비교 가능한 가변 포맷 데이터 포인트를 생성 한다. 이후, SS(C480)은 PS(C478)에 저장된 기존 인식과 일치하는 PS(C478) 검색을 수행한다. 실행 SS(C480)의 결과(C716)은 가중치 계산(C718)으로 이어져 생성된다. 이러한 계산(C718)은 이상적인 프레임워크 구조(Ideal Framework Structure)를 생성한 LOM 알고리즘의 실행을 나타내는 비교 가능한 변수 형식을 복제 및일치시키기 위해 PS(C478)로부터 해당 인식의 정확한 분포를 찾기 위해 시도한다. 도 788은 도 787의 인지 관찰자 애뮬레이터(POE)(C475) 논리를 계속한다. 스토리지 검색(SS)(C480)에서 결과 (C716)를 생성한 후, 가중치 계산(C718)은 능동적인 승인(C731) 또는 차단(C730) 결정을 내리기 위해 인식 5512/5514/5516의 어플리케이션(C729)으로 이어지도록 완료한다. LOM 및 해당 LOM 로그 집계에 의 해 생성된 이상적인 프레임워크 구조는 파생되기 위해 데이터 개선 로그(C723)를 야기시키는 데이터 구문 분석(C724)를 거치게 되며, 이는 이상적인 프레임워크 구조와 관련하여 긍정적 감정(승인)(C731) 또는 부 정적 감정(차단)(C730)의 해석 이분법을 달성하기 위해 어플리케이션(C729)에 적용된다. 애플리케이션 (C729)의 실행이 성공적으로 완료되면 규칙 실행(RE)(C461)의 모듈식 출력과 병행하여 비판적 결정 출력(CDO; Critical Decision Output)(C462)에 의해 처리되는 오버라이드 수정 조치(C476)로 이어진다. 셀프 비판적 지식 밀도(SCKD; Self-Critical Knowledge Density)(C474) 모듈은 보고할 수 있는 LOM 로그 집계의 범위를 넘 어서는 알려지지 않은 잠재적 지식의 범위와 유형을 추정한다. 상기 방법으로 CTMP 인스턴스 처리의 후속 비판적 사고 기능은 인스턴스에 의해 직접 알려져 있고 알려지지 않은 모든 관련 지식의 잠재적인 범위를 활용 할 수 있다. 도 789는 도 788의 인지 관찰자 애뮬레이터(POE)(C475)의 실행과 병행하여 작동하는 메모리 웹(C460) 프로세스 를 도시한다. LOM에서 생성된 이상적인 프레임워크 구조는 추론 처리(C456)에 모듈식 입력으로 제출 된다. 추론 처리(C456)은 LOM가 DIP에서 제공하는 프롬프트에 응답하여 이상적인 프레임워크 구조을 생성하기로 결정한 방법을 처리한다. 추론 처리(C456)의 처리 결론은 LOM의 실행 동작과 세 번째로 일치하는 규칙을 정의하는 추론 처리의 실행(C457)이다. 만약 LOM의 실행 동작과 관련하여 규칙 동 작에서 불일치가 발견되면, 현재 존재하는 규칙들이 수정되거나 새로운 규칙이 추가된다. 이러한 규칙은 나중에 해당 LOM 인스턴스에서 발견된 의사 결정 동작을 비판하기 위해 CTMP 인스턴스 내에서 사용된다. 그 다음에, 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)은 알려진 인식을 활용하여 규칙 집합의 '비판적 사고(critical thinking)'범위를 확장하여 규칙 집합을 향상시켜 올바른 규칙(Correct Rules)(C459)을 생성한다. 올바른 규칙(C459)는 메모리 웹(C460)의 운영 관할구역 내에서 규칙 구문 포맷 분리 (RSFS)(C499)에 모듈식 입력으로 제출된다. RSFS(C499)는 유형별로 올바른 규칙(C459)을 분리하고 구성한다. 따 라서 모든 조치, 특성, 조건 및 개체는 RSFS(C499) 처리 후 별도로 나열된다. 이를 통해 CTMP 인스턴스는 카오틱 필드(Chaotic Field)에서 발견된 부분과 그렇지 않은 부분을 식별할 수 있다. 카오틱 필드 파싱(Chaotic Field Parsing, CFP)(C535)는 LOM 로그 집계를 카오틱 필드로 참조되는 단일 스캔 가능한 유닛으로 결합 하고 형식화한다. 카오틱 필드는 메모리 인식(MR)(C501)에 모듈식 입력으로 제출된다. 또한, MR(C501)은 RSFS(C499)의 실행 결과인 원본 규칙(C555)을 받는다. MR(C501)은 CFP(C535)에서 제공하는 카오틱 필드를 스캔 하여 원본 규칙(C555)에 정의된 알 수 있는 개념을 인식한다. 상기 MR(C501) 인스턴스 실행은 인식된 규칙 세그 먼트(C556)을 생성한다. 그 후 규칙 이행 파서(Rule Fulfillment Parser, RFP)(C498)은 MR(C501)에 의해 카오 틱 필드 내에서 인식 또는 부족에 따라 태그가 지정된 원본 규칙(C555)의 개별 부분을 수신한다. 그 다음에, RFP(C498)은 규칙 실행(RE)(C461)에 의해 처리를 수행하기 위해 카오틱 필드에서 어떤 전체 규칙 집합(모든 부 분의 조합)가 충분히 인식되었는지 논리적으로 추론할 수 있다. RE(C461)의 실행이 성공적으로 완료되면 비판적 결정 출력(CDO; Critical Decision Output)(C462)과 병행하여 인지 관찰자 애뮬레이터(POE)(C475)의 모듈식 출 력에 의해 처리되는 오버라이드 수정 조치(C476)로 이어진다. 도 790은 인지 저장(PS)(C478)과 자동화된 인지 발견 메커니즘(APDM)(C467) 사이의 논리 흐름 상호 작용에 대해 자세히 설명한다. PS(C478)에는 인지의 추측된 미지 각도(Deduced Unknown Angles of Perception)(C473), 인지 의 모든 각도(All Angles of Perception)(C472), 인지의 함축 각도(Implied Angles of Perception)(C471), 인 지의 적용 각도(Applied Angles of Perception)(C470)과 같이 인식의 네 가지 하위 집합을 포함한다. 인지의 적용 각도(C470)은 상기 인스턴스에서 LOM인 선택된 패턴 매칭 알고리즘(SPMA)의 알고리즘 동작을 연구하 여 직접 불러온 인식이다. 인지의 함축 각도(C471)은 인지의 적용 각도(C470)에서 암시 도출(ID)(C477) 및 APDM(C467)의 모듈식 실행을 통해 도출된 인식이다. 인지의 모든 각도(C472)는 인지의 적용 각도(C470) 및 인지 의 함축 각도(C471)에 포함되지 않은 CTMP 인스턴스에 대한 알려진 인식의 전체 범위를 나타낸다. 인지의 추측된 미지 각도(C473)은 CTMP 인스턴스가 셀프 비판적 지식 밀도(SCKD; Self-Critical Knowledge Density)(C474) 모듈에 따라 아직 발견되지 않은 상태에서 존재할 것으로 예상되는 인식의 범위를 나타낸다. APDM(C467)은 초기 두 입력 가중치(C652)를 결합하는 신규 반복(C653)을 생성하도록 창의성 모듈을 통해 인지의 각도(C650)의 구성을 창의적으로 서로 다르게 하지만, ID(C477)은 결정적으로 인지의 적용 각도(C470)을 도출하기 위해 인지의 적용 각도(C470)의 개별 메트릭(metrics)를 분석한다. 따라서 APDM(C467) 처리와 관련된 모든 인지의 각도(C650)은 LOM의 주장 생성(AC)(C808A) 모듈에 의해 생성된 이상적인 프레임워크 구조에 해당하고 이를 나타낸다. 도 791은 CTMP의 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)에 대한 작동 세부 사항에 대해 자세히 설명한다. 합리적 어필(RA; Rational Appeal)(C811A) 인스턴스는 LOM 로그 집계(LOM Log Aggregate)를 카오틱 필드 파싱(CFP; Chaotic Field Parsing)(C535)으로 처리하기 위해 LOM 내에서 작동하고 문맥 구성(CC; Context Construction)(C817A)를 호출한다. CFP는 메모리 인식(MR)(C501)에서 참조하 는 CC(C817A)의 모듈식 출력에서 카오틱 필드를 생성한다. 현재 규칙(C534)는 이 인스턴스에서 LOM인 선택 된 패턴 매칭 알고리즘(SPMA)의 현재 기능 상태를 나타내는 규칙 집합을 표시한다. 현재 규칙(C534)는 규칙 구 문 미분(RSD)(C504) 모듈에 모듈식 입력으로 제출되며, 이는 논리적으로 '흑백' 규칙들은 인식을 기반으로 메트 릭을 변환하는 곳이다. 따라서 여러 규칙의 복잡한 배열은 다양한 그래디언트의 여러 메트릭(metrics)를 통해 표현되는 단일 균일 인식으로 변환된다. RSD(C504)의 모듈식 출력은 인색 매칭(PM)(C503)에 모듈식 입력으로 제 공된다. PM(C503)에서, 비교 가능한 가변 포맷(CVF) 유닛은 RSD(C504)에서 수신한 인식으로 구성된다. 새로 형 성된 CVF는 유사한 인덱스를 가진 인지 저장(PS)(C478)에서 관련 인식을 검색하는 것으로 사용된다. 잠재적 일 치 항목은 규칙 구문 생성(RSG)(C505)에 모듈식 입력으로 제출된다. RSG(C505)는 인식 형식으로 저장된 이전에 확인된 인식을 수신하고 인식의 내부 메트릭 구성에 접근한다. 인식은 이전에 확인된 인식(C468)이 포함된 PS(C478)에서 수신된다. 이러한 메트릭(metrics)의 그래디언트 기반 측정은 원래 인식의 입력/출력 정보 흐름을 에뮬레이트하는 이진법 및 논리 규칙 집합으로 변환된다. 따라서 RSG(C505)는 관련성이 있고 대중적으로 고려되 며 논리적 규칙으로 변환된 인식(Perceptions)인 인지 규칙(Perceptive Rules)(C537)을 생성한다. 만약 (초기 인식 포맷에서) 인식이 많은 '회색 영역'을 정의한 많은 복잡한 메트릭 관계가 있는 경우, '흑백' 로컬 규칙은 규칙 집합 복잡도를 확장함으로써 이러한 '회색' 영역을 포함한다. 따라서 인지 규칙(C537)은 규칙 구문 포맷 (RSF) 정의의 모음으로 저장된다. 인지 규칙(C537)은 메모리 인식(MR)(C501)에 모듈식 입력으로 제출되며, 메모 리 인식(MR)(C501)에서 CFP(C535)에 의해 생성된 카오스 필드에 대해 스캔된다. 따라서 MR(C501)은 유효성 있는 올바른 규칙(C533)을 완성하는 추가 규칙(C536)을 생성한다. 도 792는 CTMP의 암시 도출(ID)(C477)에 대한 작동 세부 사항에 대해 자세히 설명한다. 인지 저장 (PS)(C478)의 인지의 적용 각도(C470)은 인지의 함축 각도(C471)에 속하는 더 많은 인식을 생성하기 위해 모듈 식 입력으로 ID(C477)에 제출된다. 인지의 적용 각도(C470)은 구체적으로 ID(C477)의 메트릭 조합(C493)으로 전 송된다. 메트릭 조합(C493)은 메트릭(metrics)의 카테고리에 대해 수신된 인지의 각도(C650)을 범위 (Scope)(C739), 유형(Type)(C740), 일관성(Consistency)(C741), 강도(Intensity)(C742)로 구분한다. 시스템 내 에서 메트릭 가용성 및 참조가 반드시 상기 네 가지 유형으로 제한되는 것은 아니다. 인지의 각도(C650) 입력은 LOM의 주장 생성(AC)(C808A) 모듈에 의해 생성된 이상적인 프레임워크 구조와 관련이 있다. 메트릭 복잡도 세트 A(C736)는 메트릭 확장(ME)(C495)에 모듈식 입력으로 제출된다. ME(C495)를 사용하여 여러 인식의 각도(C650) 및 다양한 각도의 메트릭은 개별 데이터베이스 C739, C740, C741, C742 카테고리 별로 저장된다. ME(C495)는 이전에 알려진/접한 메트릭에서 추출된 세부 사항/복잡도로 수신된 메트릭의 현재 배포를 향상시킨 다. 향상 및 복잡도 강화 완료에 따라, 메트릭은 메트릭 복잡도 세트 B(C737)으로 ME(C495) 모듈식의 출력으로 반환되고 그 후에 도 793에 설명된 바와 같이, 인지의 함축 각도(C471)에 저장되도록 인지의 각도(C650)로 다시 변환된다. 도 793은 개별 메트릭을 전체 인지의 각도(C650)으로 되돌리는 메트릭 변환(C494)에 의해 처리되는 메트릭 복잡 도 세트 B(C737)를 설명하는 도 792로부터 암시 도출(ID)(C477)의 논리 흐름을 계속한다. ID(C477)에 의해 수행 된 향상 및 변환 프로세스에도 불구하고, 생성된 인지의 각도(C650)는 여전히 LOM의 주장 생성(AC)(C808A) 모듈에 의해 생성된 이상적인 프레임워크 구조의 합리적으로 정확한 묘사를 제공한다. 따라서 메트릭 변 환(C494) 프로세스는 새로 도출/암시된 인식의 각도(C650)를 인지 저장(PS)(C478) 내의 인지의 함축 각도(C47 1)에 제출한다. 도 794는 CTMP의 비판적 결정 출력(CDO; Critical Decision Output)(C462)에 대한 작동 세부 사항에 대해 자세히 설명한다. 비판적 결정 출력(CDO; Critical Decision Output)(C462)는 CTMP의 두 가지 주요 브랜 치로부터 모듈식의 출력을 수신하고, (직관력 브랜치로서) 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)와 (논리적 브랜치로서) 규칙 실행(RE; Rule Execution)(C461)가 있다. 각 브랜치 C475/461은 그것의 각각의 비판적 결정(Critical Decision)(C521) (메인 모듈식의 출력)뿐 아니라 해당하는 '메타-메타 데 이터(Meta-metadata)'(C521)을 제출하며, 이는 초기 중요 결정에 도달한 이유를 정당화하는 맥락 변수를 제공한 다. POE(C475)의 인식(C516)과 RE(C461)의 이행된 규칙(C517)을 나타내는 두 결정 세트(C521)는 메타데이터 분 류 모듈(MCM)(C488)에 제출된다. MCM(C488)은 전통적인 구문 기반 정보 카테고리화를 사용하여 디버깅 및 알고리즘 추적을 개별의 카테고리로 분류한다. 그러면 이러한 카테고리는 보안 위험과 대상과의 상관관계를 가지고 분명한 보안 대응을 조직하고 생성할 수 있다. POE(C475)의 인식(C526)을 나타내는 직관적 의사 결정(C514)와 RE(C461)의 이행된 규칙(C517)을 나타내는 사고 결정(C515)은 MCM(C488)에 의해 방향 결정 비교(DDC)(C512)의 내부 프로세싱 로직에 제출된다. DDC(C512)의 내부 프로세싱 로직은 직관적 의사 결정(C514)와 사 고 결정(C515) 사이의 확증 또는 충돌을 확인한다. DDC(C512)는 정적 하드코드된 정책(SHP)의 '차단 변수 (cutoff variable)'를 참조한다. 만약 차단 변수는 직관적 의사 결정(C514)와 사고 결정(C515) 사이에 유사성에 도달하지 않으면 (예를 들어, 90 % +), 무효화 직접 비교는 직접 발생하며, 이는 도 795에 도시된 바와 같이, 확신없는 투표에 최종적으로 제출하도록 터미널 출력 제어(TOC)(C513)에 연결된다. 무효화 직접 비 교 단계는 CTMP가 RIP의 프롬프트 입력과 관련하여 내부적으로 일관성 있는 작동할 수 없음을 의미한다. 만약 '차단 변수가 내부 프로세싱 로직에 따라 충분히 충족되면, 최종 비판적 출력 (Final Critical Decision) 단계가 터미널 출력 제어(TOC)(C513)에 의해 수신 및 처리되는 단일 모듈식 의 출력으로 두 결정 C514/C515 를 결합하여 호출한다. 도 795는 도 794의 비판적 결정 출력(CDO; Critical Decision Output)(C462)의 논리 흐름을 계속하고 터미널 출력 제어(TOC)(C513의 작동 세부 사항을 자세히 설명한다. TOC(C513)은 방향 결정 비교(DDC)(C512)가 (무효화 직접 비교 지시 대신) 최종 비판적 출력(Final Critical Decision) 을 제공할 수 있는지 확인하는 프롬프트으로 시작한다. 프롬프트에 대한 응답이 Yes인 경우, 최종 비판적 출력(Final Critical Decision)에서 DDC(C512)에 의해 제공된 결합된 최종 결정은 TOC(C513)의 모듈식 출력으로 제 출되며, 따라서 최종 임계 결정으로 전체 CTMP 인스턴스의 모듈식 출력으로 제출된다. 프롬프트 에 대한 응답이 No인 경우, 5532단계가 자체적으로 인식 매칭(PM; Perception Matching)의 실행을 호출하고 해당 결과를 가져오게 되어 호출된다. 이행된 규칙(C517)은 규칙 실행(RE)(C461)의 중요 결정 + 메타-메타 데이터(C521)에서 추출된다. 규칙(C517)은 규칙 구문 미분(RSD)(C504)에 의해 인식으로 변환된다. 그 다음에, PM는 프롬프트에서 강력한 내부 중복(strong internal overlap)과 사용된 인식의 확증 (corroboration of Perceptions)이 있는지 결정하기 위해 메타-메타 데이터를 참조한다. 만약 프롬프트 에 대한 응답이 예인 경우, 모듈식 출력으로 CTMP 대신하여 확신없는 투표를 나타낸다. 만약 프롬프트에 대한 응답이 No인 경우, 5540단계가 활성화되어 직관적 의사 결정(C514)와 사고 결정 (C515) 사이에서 인식된 가장 위험이 덜한 결정을 선택한다. 따라서 최종 임계 결정는 비판적 결정 출력 (CDO; Critical Decision Output)(C462), TOC(C513) 및 CTMP에 모듈식 출력으로 제출된다. 5534단계의 논 리는 직관적 의사 결정(C514)와 사고 결정(C515) 사이의 일치성 부족이 알고리즘에 대한 신뢰가 부족하거나, 둘 사이의 반대되는 관점 때문에 발생하는지 여부를 판별하기 위해 발생한다. 따라서 후자가 발생할 경우, 잠재적 인 최종 임계 결정는 여전히 모듈식 출력으로 식별할 수 있다. 확신없는 투표는 항상 합리적 어필 (RA)(C811A) 내에서 신뢰도가 낮은 신뢰도 결과(C845) 논리 경로로 이어진다. 최종 임계 결정는 최종 임 계 결정 뒤에 알고리즘 신뢰도에 따라 RA(C811A) 내에서 높은 신뢰도 결과(C846) 또는 낮은 신뢰도 결과 (C845) 논리 경로로 이어질 수 있다. 도 796은 CTMP 및 LOM가 8744단계에서 하드웨어 목적 맵에 따라 이상적인 프레임워크 구조 를 생성하는 향상된 프레임워크 개발(EFD)을 도시한다. 8752단계에서, I2GE는 이상적인 프레 임워크 구조를 하드웨어 해석 및 프레임워크 구조의 변형으로 스트레스 테스트한다. 8754단계에서, 프레 임워크 구조는 안정성을 입증하였으며, 8756단계에서, 프레임워크 구조는 안정성을 입증하지 않았다. 하드웨어 해석 메커니즘(HIM)은 I2GE에 하드웨어 구조 해석을 제공하기 위해 하드웨어 구조 조사 (HS2)과 상호 작용한다. 정적 하드코드된 정책(SHP)은 I2GE 스트레스 테스트를 위해 8752단계 에 입력을 제공한다. 도 797은 이상적인 프레임워크 구조가 I2GE로부터 LIZARD까지 모듈식 출력으로 제출되는 8758 단계에서 도 796의 향상된 프레임워크 개발(EFD; Enhanced Framework Development)의 논리 흐름을 계속 한다. LIZARD는 정제된 이상적인 프레임워크 구조(Refined Ideal Framework Structure)를 이상적인 프레임워크 목적 맵로서 목적 포맷으로 변환한다. 프레임워크 해석 메커니즘(FIM; Framework Interpretation Mechanism)은 프레임워크 구조 해석을 프레임워크 목적 맵으로 변환한다. 도 798은 정제된 프레임워크 구조 해석(Refined Framework Structure Interpretation)을 이상적인 프레 임워크 목적 맵(Ideal Framework Purpose Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항 을 도시한다. 정제된 프레임워크 구조 해석은 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기 본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실 제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C3 6)의 컴퓨터 코드의 구문적 해석을 제공한다. 정제된 프레임워크 구조 해석은 코드 변환(C321)에 의해 프 레임워크 사양 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된 다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목 적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이 터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조 하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내 부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으 로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브 러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따 라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수 로 작동한다. 도 799는 정제된 프레임워크 구조 해석을 이상적인 프레임워크 목적 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 798로부터의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소 (C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외 부 코어(OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 정제된 프레임워크 구조 해석의 복합 목적 포맷(C325) 버전으로 표시되는 이상적인 프레임워크 목 적 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 800은 8762단계에서 LIZARD가 정제된 이상적인 프레임워크 구조(Refined Ideal Framework Structure)를 목적 대 목적 대칭 처리(P2SP) 내의 이상적 프레임워크 목적 맵으로서 목적 포맷으로 변환하는 향상된 프레임워크 개발(EFD)을 도시한다. 또한, P2SP은 프레임워크 구조 해석 을 프레임워크 목적 맵으로 처리하고, 이상적인 프레임 목적 맵와 프레임워크 목적 맵 사이에 충돌이 있는지 확인하는 8774단계에서 대칭 처리 결과를 제출한다. 만약 충돌이 발견을 하 면, 니드 맵 매칭(NMM)(C114)에 따라 충돌을 정당화하는 추가 목적 장치가 있는지 확인하는 8780단계로 진행한 다. 그 결과는 정당화 또는 정당화되지 않음(Not Justified)가 된다. 8774단계에서, 다른 결과는 충돌 없음을 발견 이다. 도 801은 LIZARD의 다이나믹 쉘(Dynamic Shell)(C198)의 서브 모듈로서 동작하는 니드 맵 매칭 (NMM)(C114)의 작동 및 기능을 도시한다. NMM(C114) 인스턴스는 향상된 프레임워크 개발(EFD)에서 8780 단계의 작동을 처리하기 위해 생성된다. NMM(C114)의 모듈식 호출에 따라, 초기 구문 분석(C148)은 진행중인 NMM(C114) 인스턴스 내에서 참조를 위해 일시적으로 언급하는 스토리지의 각 관할구역 브랜치를 다운로드 한다. 브랜치 니드 계산으로, 각 브랜치와 관련된 정의에 따라 니드는 해당 부서와 연관된다. 상기 방법으로, 권한 검사(permission checks)는 NMM(C114) 인스턴스 내에서 구성할 수 있다. 예를 들어, 직원 능력에 따라 성 과를 매년 검토하는 영역 내에서 요청되었기 때문에 NMM(C114)는 모든 직원 CV를 다운로드하도록 인사 부서를 위한 요청을 승인했다. 따라서 부서 관할구역의 유효한 니드로 입증되었다. 따라서 니드 인덱스(C145)는 관할구 역 브랜치의 메인 스토리지 및 그들 각각의 니드이다. 상기 내부 참조는 NMM(C114) 및 그것을 제공하는 모든 모 듈의 작동에 대한 리소스 병목 현상이기 때문에, 시스템의 전반적인 효율성을 높이기 위해 빠른 데이터베이스 쿼리에 미리 최적화되어 있다. 대칭 처리 결과는 NMM(C114)의 검색 알고리즘(C144)에 모듈식 입력으로 입 력 목적(C139)을 제공된다. 입력 목적(C139)가 니드 액세스 개발 및 스토리지에 초기에 정의된 관할구역 브랜치에 따라 유효한 니드를 정의하는지 판별하므로, 검색 알고리즘(C144)는 컴파일된 니드 인덱스(C145)를 참조하고 검색한다. 따라서 니드 인덱스(C145)를 통한 검색 알고리즘(C144)의 완료된 실행은 NMM(C114)에서 모듈 식 출력으로 제출되고 니드 결과(C141)로 참조되는 승인/차단(C146) 응답을 생성한다. 따라서 니드 결과(C141) 는 EFD 처리 내에서 8780단계로 되돌아간다. 도 802는 I2GE가 하드웨어 해석 및 프레임워크 구조의 변형으로 이상적인 프레임워크 구조를 스트레스 테 스트하는 8752 단계에서 향상된 프레임워크 개발(EFD) 프로세스 시작을 도시한다. 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)에 제출하기 위해 5600단계의 공식 시스템 토큰이 있는 DLU를 자동화된 리서치 매커니즘(ARM)의 진단 로그 제출(DLS)에 제출하는 경우, 프레임워크 구조가 안정적인 것으로 입증됨 또는 프레임워크 구조가 안정적인 것으로 입증되지 않음으로 이어 진다. 8774단계에서, 목적 구성과 관련하여 이상적인 프레임 목적 맵과 프레임 워크 목적 맵 사이에 충돌이 있 는지 확인한다. 충돌이 발견(Conflicts Found)된 경우, NMM에 따라 정당화된 충돌을 야기시키는 추가 목 적 유닛이 있는지 확인하는 8780단계로 진행한다. 정당화되지 않음(Not Justified)인 경우, 5600 단계에 서 공식 시스템 토큰가 포함된 DLU를 SPSI에 제출하기 위해 자동화된 리서치 매커니즘(ARM)의 진단 로그 제출(DLS)에 제출한다. 또는 8780단계의 결과가 정당화됨인 경우, 사양 롤아웃 메커니즘 (Specification Rollout Mechanism, SRM)으로 진행된다. 또한, 충돌이 발견되지 않음인 경우, 사 양 롤아웃 메커니즘(SRM)으로 진행된다. 도 803은 8802단계에서 시작하는 추상 타겟 시스템 생성기(Abstract Target System Generator, ATSG) 시 작을 사용하는 추상 타겟 시스템(Abstract Target System)에 대한 향상된 하드웨어 개발(EFD) 프 로세스를 도시하며, 상기 8802 단계에서 LIZARD는 추상 타겟 시스템의 유용성을 해석한다. 8804단계 에서, LIZARD은 필수 사용자 기능과 관련된 목적 계층 맵 정의를 생성하는 니드 맵 매칭 (NMM)(C114)을 사용한다. LIZARD은 8808단계에서 목적 계층 맵을 기능 구문으로 변환한다. 8828단계에서, LOM 및 CTMP는 필수 사용자 기능에 따라 이상적인 하드웨어 구성을 생성한다. 이상적인 구성 호출 프 롬프트(ICIP)은 필요한 사용자 기능을 고려한 가장 효율적이고 안정적인 하드웨어 구성이 무엇인지(883 2)를 결정한다. 도 804는 LIZARD이 8834단계에서 이상적인 하드웨어 구성를 목적 계층 맵으로 변환하는 향상 된 하드웨어 개발(EHD) 프로세스를 도시한다. 8808단계에서 LIZARD은 목적 계층 맵을 8812단 계에서 CKR의 효율성 디자인 원칙를 생산하기 위해 LOM에 적용하는 기능 구문으로 변환 한다. 8816단계에서 LOM는 8828단계에서 이어지는 CKR로부터 안정성 디자인 원칙을 생성하며, 상기 8828단계에서 LOM와 CTMP는 필수 사용자 기능에 따라 이상적인 하드웨어 구성을 생산한다. LIZARD은 8834단계에서 이상적인 하드웨어 구성를 목적 계층 맵으로 변환한다. 도 805는 LOM가 디자인 원칙 호출 프롬프트(DPIP)을 기반으로 8812단계에서 CKR로부터 효율 디자인 원칙을 생성하는 향상된 하드웨어 개발(EFD) 프로세스를 도시한다. LOM은 효율성 디자인 원 칙의 결정 프로세스를 용이하게 하는 ARM에 의해 검색된 데이터로부터 CKR 내에 오버타임 개념 을 구축한다. CKR은 선천적인 발전 추론을 통해 강력한 정의 기반을 구축하고 LOM이 출력하는 어떤 결정 도 정당화할 수 있다. 클러스터 구축(C854F)으로, CKR은 유닛 지식 포맷(UKF) 클러스터(C854F)로 알려진 정보의 '스태킹(stacking)' 구축 블록(blocks)의 정보를 통해 개념적 결론에 도달한다. 상기 클러스터는 귀속 가능한 출처, 의심되는 정보 생성 시간, 효율성, 디자인 등 대상 정보와 관련된 광범위의 메타 데이터를 포함한다. 각 UKF 클러스터(C854F)는 규칙 구문 포멧(RSF)(C538)을 포함한다. 도 806은 LOM가 디자인 원칙 호출 프롬프트(DPIP)을 기반으로 8816단계에서 CKR로부터 안정성 디자인 원칙을 생성하는 향상된 하드웨어 개발(EFD) 프로세스를 도시한다. LOM은 안정성 디자인 원 칙의 결정 프로세스를 용이하게 하는 ARM에 의해 검색된 데이터로부터 CKR 내에 오버타임 개념 을 구축한다. CKR은 선천적인 발전 추론을 통해 강력한 정의 기반을 구축하고 LOM이 출력하는 어떤 결정 도 정당화할 수 있다. 클러스터 구축(C854F)으로, CKR은 유닛 지식 포맷(UKF) 클러스터(C854F)로 알려진 정보의 '스태킹(stacking)' 구축 블록(blocks)의 정보를 통해 개념적 결론에 도달한다. 상기 클러스터는 귀속 가능한 출처, 의심되는 정보 생성 시간, 효율성, 디자인 등 대상 정보와 관련된 광범위의 메타 데이터를 포함한다. 각 UKF 클러스터(C854F)는 규칙 구문 포멧(RSF)(C538)을 포함한다. 도 807은 향상된 하드웨어 개발(EHD)의 8828단계와 관련하여 LOM 및 CTMP의 내부 작동 절차를 도시한다. 효율성 디자인 원칙, 안정성 디자인 원칙 및 필수 사용자 기능은 이상적인 구성 호출 프롬프트(Idealistic Configuration Invocation Prompt, ICIP)에 초기 입력으로 제공된다.ICIP는 효율성 디자인 원칙, 안정성 디자인 원칙 및 필수 사용자 기능을 고려하여 이 상적인 하드웨어 구성의 생산을 호출하기 위해 LOM와 직접 상호 작용하는 프롬프트을 생산한 다. ICIP에서 생성된 프롬프트는 LOM의 초기 쿼리 추론(IQR)(C802A) 모듈에 제출된다. LOM이 UBEC 사용자에 의해 UBEC 플랫폼 내에서 직접 호출될 때, IQR(C802A)는 UBEC 사용자 에 의해 제공된 초기 질문/주장을 수신한다. 그러나, 상기 LOM 인스턴스는 대신 ICIP에 의해 자동으로 호출된다. 제공된 프롬프트은 프롬프트에게 완전한 주소/응답하기 위한 LOM에 정확 한 '가상 이해'를 완료하기 위해 중요한 프롬프트로부터 누락된 세부 사항을 판독하기 위해 중앙 지식 보 유(CKR)의 호출(invocation)를 통해 분석된다. IQR(C802A)에 의해 생성된 결과 누락된 세부 사항은 모듈식 입력으로 조사 구분(SC)(C803A)에 제출된다. 프롬프트은 객관적이고 모든 필요한 문맥을 분석할 수 있도 록 SC(C803A)는 보충 정보를 검색하여 프롬프트의 출처와 연결한다. UBEC 사용자에 의해 LOM이 UBEC 플랫폼 내에서 직접 호출될 때, SC(C803A)는 질문/응답의 출처로서 그 사용자와 연동한다. 그러 나 상기 LOM 인스턴스는 대신 DIP에 의해 자동으로 호출되므로 SC(C803A)는 프롬프트에 관한 보충 정보를 검색하기 위해 ICIP과 연동한다. 프롬프트의 완전한 형태와 개선된 버전은 SC(C803A) 에서 생산되며 주장 생성(AC)(C808A)에 모듈식 입력으로 제출된다. AC(C808A)는 CKR을 직접 참조하거나 계 층적 매핑(HM)(C807A)를 통해 프롬프트에 대한 일관된 응답을 구성하기 위해 시도한다. 합리적 어필 (RA)(C811A)는 CTMP와의 논리 흐름 인터페이스를 수용하는 컨테이너 모듈이다. RA(C811A)는 주장을 비판하 기 위해 CTMP를 사용한다. 이러한 비판은 (AC(C808A)의 출력을 비판함으로써)자체 비판의 형태 또는 (UBEC 사용자 또는 DIP) IQR(C802A)에 의해 처리된 질문/주장의 출처에 대한 외부 비판의 형태일 수 있다. 만약 AC(C808A)에서 생성된 주장이 RA(C811A)에 의해 처리된 자체 비판 테스트에 대한 중요한 측정에 실패한 경 우, AC(C808A)의 새로운 인스턴스는 유효한 비판을 설명하기 위해 호출된다. 만약 높은 신뢰도 주장은 RA(C811A)에 의해 처리된 자체 비판 테스트를 지속적으로 통과하는 AC(C808A)에 의해 생성되는 경우, 주장은 ICIP에서 제공하는 초기 프롬프트의 문맥에서 이상적인 하드웨어 구조로 참조되는 LOM 의 모듈식 출력으로 생성된다. 도 808은 EHD의 8828단계와 관련하여 LOM의 합리적 어필(RA)(C811A)의 내부 작동 과정에 대한 세부 사항을 도시한다. 주장 생성(AC)(C808A)는 해당 입력 프롬프트에 관해서 AC(C808A)에 의해 생성된 주장에 대한 합리적 어필(RA)(C811A)에 응답 프레젠테이션(C843)을 제공한다. 논리 흐름의 상기 단계에서 생성된 주장 은 사전 비판적 결정(C847)으로 분류된다. 이는 CTMP에 의한 비판을 통해 아직 처리되지 않았음을 의미한 다. 따라서 생성된 주장은 '주관적 의견(C848)’ 입력으로 CTMP 인스턴스에 직접 제출되며 또한, CTMP 인스턴스에 ‘객관적 팩트(C850)’ 입력을 제공하는 문맥 구성(CC)(C817A)에 제출된다. CC(C817A)는 AC(C808A)의 메타데이터와 비판적 사고를 위해 미가공 팩트(raw fact)를 CTMP에 제출하는 ICIP을 통해 제공되는 잠재적 증거를 참조한다. 이러한 입력 메타데이터는 LOM 로그 집계 파일로 표시된다. LOM 로그 집계는 LOM의 기본적인 운영 기능으로부터 생성된 관련 로그 파일의 모음이 포함되어 있다. CTMP 인스턴스가 작동을 마치면 사후 비판적 결정(C851)이 모듈식 출력으로 생성된다. 초기 사전 비판적 결정(C847) 및 사후 비판적 결정(C851)은 두 입력 C847과 C851 사이의 잠재적 중복의 범위를 결정하는 의사 결 정 비교(DC)(C818A) 모듈에 제출된다. DC(818A)가 제공하는 통합 출력은 주장을 생성하는 AC(C808A)을 대신하여 CTMP의 (부정확한) 양보(Concession)(C852) 또는 주장을 생성하는 AC(C808A)를 대신하여 인지된 개선 (C853)을 나타낼 수 있다. 인수 응답인 C852 및 C853은 모두 낮은 신뢰도 결과(C845) 또는 높은 신뢰도 결과 (C846)로 분류할 수 있다. 낮은 신뢰도 결과(C845)는 AC(C808A)에 의해 생성된 초기 주장이 결함이 있음을 나타 내며 재구성해야 한다. 따라서, 논리 흐름은 AC(C808A)의 새로운 인스턴스로 계속 이어진다. 높은 신뢰도 결과 (C846)은 AC(C808A)에 의해 생성된 초기 주장이 장점이 있음을 나타내므로 도출된 결론(해당 증거, 전제 등과 결합됨)이 지식 검증(KV)(C805A)에 제출된다. 따라서 논리 흐름은 CKR 및 LOM가 최근에 처리된 주장 으로부터 이점을 얻을 수 있도록 KV(C805A)의 새로운 인스턴스로 계속 진행된다. 도 809는 LOM 로그 집계 파일의 생성을 설명하기 위해 EHD에서 8828 단계의 논리 흐름을 계속한다. 초기 쿼리 추론((IQR)(C802A), 조사 구분(SC)(C803A), 주장 생성(AC)(C808A), 계층적 매핑(HM)(C807A) 및 지식 검증(KV)(C805A)에서 생성된 모듈식 출력은 LOM 모듈식 로그 모음(LMLC) 모듈에 제출된다. 따라서 LMLC은 입력 로그 데이터를 LOM 로그 집계로 참조된 읽을 수 있는 단일 파일로 결합한다. 파일 은 해당 LOM 인스턴스의 전반적인 작동 상태를 포함하므로, LOM 인스턴스가 다양한 결론에 도 달한 방법에 대한 정보를 제공한다. LOM 로그 집계는 합리적 어필(RA)(C811A)의 CC(C817A)에 제출된다. 도 810은 합리적 어필(RA)(C811A)에 정의된 입력 및 출력 채널과 관련하여 CTMP의 내부 동작을 설명하기 위해 도 809 에 관한 작동 세부 사항을 확장한다. 사전 비판적 결정(C847)은 주장 생성(AC)(C808A)의 모듈식 출력으로 C843에 표시된다. CTMP의 두 가지 주요 입력 중 하나를 충족하므로 결정(C847)은 주관적 의견 (Subjective Opinion)(C848)으로 표시된다. 주관적 의견(C848)은 CTMP의 기본적인 모듈식 입력 및 선택된 패턴 매칭 알고리즘(SPMA)의 내부 표현으로 작동하는 입력 시스템 메타데이터(C484)에 제출된다. 상기 인스턴스 구성의 경우, SPMA는 LOM이다. 입력 시스템 메타데이터(C484)는 처리를 위해 추론 처리(C456) 및 미가공 인식 생산(RP2)(C465)으로 제출된다. 추론 처리(C456)은 속성 특성을 비교하여 만들어진 주장을 논리적으로 이 해할 것이다. RP2(C465)는 LOM의 알고리즘 인식을 나타내는 인식 복잡 포맷(PCF)의 인식을 생성하기 위한 LOM으로부터 입력 시스템 메타데이터(C484)를 구문 분석한다. 이러한 생성된 인식은 LOM의 알고리즘 인식을 에뮬레이트하는 인지 관찰자 애뮬레이터(POE)(C475)에 제출된다. 추론 처리(C456)은 인스턴스에서 LOM인 SPMA 알고리즘을 반영하는 규칙 집합을 최종적으로 생성하는 규칙 처리를 호출한다. 따라서 '사고' 의 두 가지 모드 인 '아날로그' 인식과 '디지털' 규칙 세트 처리가 실행된다. 상기 두 개의 브랜치 C461과 C475 는 직관과 논리를 가진 유사성을 나타낸다. 두 사고 브랜치인 C461과 C475에 의해 생성된 결과는 결과 사이의 충돌 또는 확증의 기본적인 요소를 평가하는 비판적 결정 출력(CDO; Critical Decision Output)(C462)으로 전 송된다. 내부 확증의 높은 크기 및 내부 충돌의 낮은 크기을 발견하면, CTMP는 높은 신뢰도 결과(C846)으 로 언급되는 초기 입력 주관적 의견(C848)과 관련하여 2진수 승인 또는 차단 결정을 제공한다. 내부 확증의 낮 은 크기과 내부 충돌의 높은 크기라면, CTMP는 낮은 신뢰도 결과(C845)로 표시되는 '신뢰없는 투표('vote of no confidence)'를 제출한다. 따라서 CTMP의 결과 출력은 사후 비판적 결정(C851)으로 간주된다. 도 811은 CTMP 내에서 미가공 인식 생산(RP2)(C465)의 호출에 관한 세부 사항을 도시한다. LOM는 주 장 생성(AC)(C808A)을 호출하여 이상적인 프레임워크 구조를 생성한다. 그 다음, 창의적 포텐셜 유닛 은 해당 AC(C808A) 인스턴스로부터 발생하는 입력 시스템 메타데이터(C484) 내에서 디버깅 추적(C485) 및 알고리즘 추적(C486)의 인스턴스를 생성하기 위한 데이터를 분석하는 RP2(C465)의 5506단계에 제출한다. 디버깅 추적(C485)는 해당 입력, 출력 변수 유형 및 컨텐츠와 마찬가지로 사용되는 변수, 함수, 방법 및 분류를 제공하 는 코딩 레벨 추적이다. 전체 기능 호출 체인(기능 추적: 다른 기능을 호출하는 기능)이 제공된다. 알고리즘 추 적(C486)은 알고리즘 분석과 결합된 보안 데이터를 제공하는 소프트웨어 레벨 추적이다. 결과 보안 결정(승인/ 차단)은 결정(C847)에 도달한 방법에 대한 로지스틱 트레일(logistics trail)과 함께 제공된다. 결정(C847)을 생성하기 위해 기여한 각 요인에 대한 적절한 가중치가 포함된다. 그 후, RP2(C465)는 처리를 위해 생성된 인식 결과에 관한 데이터를 인지 관찰자 애뮬레이터(POE)(C475)로 전송한다. 도 812는 CTMP 내에서 미가공 인식 생산(RP2)(C465)의 작동에 대해 자세히 설명한다. 도 811와 같이, 초기 단계는 해당 AC(C808A) 인스턴스에서 시작된 입력 시스템 메타데이터(C484) 내에서 디버깅 추적(C485) 및 알고리즘 추적(C486)의 인스턴스를 생성하도록 데이터를 분석하기 위해 발생한다. 5508단계에서, 메트릭 처리 (C489)는 LOM에 의해 제시된 인공 지능으로부터 인식을 추출하기 위한 LOM의 변수를 리버스 엔지니어 링한다. 그 후에, 입력 시스템 메타데이터(C484)는 시스템 메타데이터 분리(SMS)(C487)을 통해 중요한 보안 인 과 관계로 메타데이터(C484)를 분리하는 5510단계로 처리된다. 또한, 도 811에 의해 나타낸 바와 같이, RP2(C465)는 생성된 인식 결과에 관한 데이터를 처리를 위해 인지 관찰자 애뮬레이터(POE)(C475)로 전송한다. 도 813은 인지 저장(PS)(C478)과의 관계 및 미가공 인식 생산(RP2)(C465)을 포함하는 인지 관찰자 애뮬레이터 (POE)(C475)의 작동에 대해 자세히 설명한다. 메트릭 처리(C489) 및 시스템 메타데이터 분리(SMS)(C487)의 작동 은 PS(C478)에 저장된 인식 5512/5514/5516의 생산으로 이어진다. 결과 인식 5512/5514/5516은 주장 생성 (AC)(C808A)를 통해 이상적인 하드웨어 구성을 생성하는 LOM의 모듈식 응답을 나타낸다. RP2(C46 5)는 검색 기준으로 스토리지 검색(SS)(C480)에 제공되는 비교 가능한 가변 포맷 데이터 포인트를 생성한다. 이 후, SS(C480)은 PS(C478)에 저장된 기존 인식과 일치하는 PS(C478) 검색을 수행한다. 실행 SS(C480)의 결과 (C716)은 가중치 계산(C718)으로 이어져 생성된다. 이러한 계산(C718)은 이상적인 프레임워크 구조(Ideal Framework Structure)를 생성한 LOM 알고리즘의 실행을 나타내는 비교 가능한 변수 형식을 복제 및 일치시키기 위해 PS(C478)로부터 해당 인식의 정확한 분포를 찾기 위해 시도한다. 도 814는 도 813의 인지 관찰자 애뮬레이터(POE)(C475) 논리를 계속한다. 스토리지 검색(SS)(C480)에서 결과 (C716)를 생성한 후 가중치 계산(C718)은 능동적인 승인(C731) 또는 차단(C730) 결정을 내리기 위해 인식 5512/5514/5516의 어플리케이션(C729)으로 이어지도록 완료한다. LOM 및 해당 LOM 로그 집계에 의 해 생성된 이상적인 프레임워크 구조는 파생되기 위해 데이터 개선 로그(C723)를 야기시키는 데이터 구문 분석(C724)를 거치게 되며, 이는 입력 이상적인 하드웨어 구성과 관련하여 긍정적 감정(승인)(C731) 또는 부정적 감정(차단)(C730)의 해석 이분법을 달성하기 위해 어플리케이션(C729)에 적용된다. 애플리케이션 (C729)의 실행이 성공적으로 완료되면 규칙 실행(RE)(C461)의 모듈식 출력과 병행하여 비판적 결정 출력(CDO;Critical Decision Output)(C462)에 의해 처리되는 오버라이드 수정 조치(C476)로 이어진다. 셀프 비판적 지식 밀도(SCKD; Self-Critical Knowledge Density)(C474) 모듈은 보고할 수 있는 LOM 로그 집계의 범위를 넘 어서는 알려지지 않은 잠재적 지식의 범위와 유형을 추정한다. 상기 방법으로 CTMP 인스턴스 처리의 후속 비판적 사고 기능은 인스턴스에 의해 직접 알려져 있고 알려지지 않은 모든 관련 지식의 잠재적인 범위를 활용 할 수 있다. 도 815는 도 814의 인지 관찰자 애뮬레이터(POE)(C475)의 실행과 병행하여 작동하는 메모리 웹(C460) 프로세스 를 도시한다. LOM에서 생성된 이상적인 하드웨어 구성은 추론 처리(C456)에 모듈식 입력으로 제출된 다. 추론 처리(C456)은 LOM가 ICOM이 제공하는 프롬프트에 응답하여 이상적인 하드웨어 구성 을 생성하기 위한 결정한 방법을 처리한다. 추론 처리(C456)의 처리 결론은 LOM의 실행 동작과 세 번째로 일치하는 규칙을 정의하는 추론 처리의 실행(C457)이다. 만약 LOM의 실행 동작과 관련하여 규칙 동 작에서 불일치가 발견되면, 현재 존재하는 규칙들이 수정되거나 새로운 규칙이 추가된다. 이러한 규칙은 나중에 해당 LOM 인스턴스에서 발견된 의사 결정 동작을 비판하기 위해 CTMP 인스턴스 내에서 사용된다. 그 다음에, 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)은 알려진 인식을 활용하여 규칙 집합의 ' 비판적 사고(critical thinking)'범위를 확장하여 규칙 집합을 향상시켜 올바른 규칙(C459)을 생성한 다. 올바른 규칙(C459)는 메모리 웹(C460)의 운영 관할구역 내에서 규칙 구문 포맷 분리(RSFS)(C499)에 모듈식 입력으로 제출된다. RSFS(C499)는 유형별로 올바른 규칙(C459)을 분리하고 구성한다. 따라서 모든 조치, 특성, 조건 및 개체는 RSFS(C499) 처리 후 별도로 나열된다. 이를 통해 CTMP 인스턴스는 카오틱 필드에서 발견된 부분과 그렇지 않은 부분을 식별할 수 있다. 카오틱 필드 파싱(CFP)(C535)는 LOM 로그 집계를 카오틱 필 드로 참조되는 단일 스캔 가능한 유닛으로 결합하고 형식화한다. 카오틱 필드는 메모리 인식(MR)(C501)에 모듈 식 입력으로 제출된다. 또한, MR(C501)은 RSFS(C499)의 실행 결과인 원본 규칙(C555)을 받는다. MR(C501)은 CFP(C535)에서 제공하는 카오틱 필드를 스캔하여 원본 규칙(C555)에 정의된 알 수 있는 개념을 인식한다. 상기 MR(C501) 인스턴스 실행은 인식된 규칙 세그먼트(C556)을 생성한다. 그 후 규칙 이행 파서(RFP)(C498)은 MR(C501)에 의해 카오틱 필드 내에서 인식 또는 부족에 따라 태그가 지정된 원본 규칙(C555)의 개별 부분을 수 신한다. 그 다음에, RFP(C498)은 규칙 실행(RE)(C461)에 의해 처리를 수행하기 위해 카오틱 필드에서 어떤 전체 규칙 집합(모든 부분의 조합)가 충분히 인식되었는지 논리적으로 추론할 수 있다. RE(C461)의 실행이 성공적으 로 완료되면 비판적 결정 출력(CDO; Critical Decision Output)(C462)과 병행하여 인지 관찰자 애뮬레이터 (POE)(C475)의 모듈식 출력에 의해 처리되는 오버라이드 수정 조치(C476)로 이어진다. 도 816은 인지 저장(PS)(C478)과 자동화된 인지 발견 메커니즘(APDM)(C467) 사이의 논리 흐름 상호 작용에 대해 상세히 설명한다. PS(C478)에는 인지의 추측된 미지 각도(C473), 인지의 모든 각도(C472), 인지의 함축 각도 (C471), 인지의 적용 각도(C470)와 같이 인식의 네 가지 하위 집합을 포함한다. 인지의 적용 각도(C470)은 상기 인스턴스가 LOM인 선택된 패턴 매칭 알고리즘(SPMA)의 알고리즘 동작을 연구하여 직접 불러온 인식이다. 인지의 함축 각도(C471)은 인지의 적용 각도(C470)에서 암시 도출(ID)(C477) 및 APDM(C467)의 모듈식 실행을 통 해 도출된 인식이다. 인지의 모든 각도(C472)는 인지의 적용 각도(C470) 및 인지의 함축 각도(C471)에 포함되지 않은 CTMP 인스턴스에 대한 알려진 인식의 전체 범위를 나타낸다. 인지의 추측된 미지 각도(C473)은 CTMP 인스턴스가 셀프 비판적 지식 밀도(SCKD; Self-Critical Knowledge Density)(C474) 모듈에 따라 아 직 발견되지 않은 상태에서 존재할 것으로 예상되는 인식의 범위를 나타낸다. APDM(C467)은 초기 두 입력 가중 치(C652)를 결합하는 신규 반복(C653)을 생성하도록 창의성 모듈을 통해 인지의 각도(C650)의 구성을 창의 적으로 서로 다르게 하지만, ID(C477)은 결정적으로 인지의 적용 각도(C470)을 도출하기 위해 인지의 적용 각도 (C470)의 개별 메트릭(metrics)를 분석한다. 따라서 APDM(C467) 처리와 관련된 모든 인지의 각도(C650)은 LOM의 주장 생성(AC)(C808A) 모듈에 의해 confident 보안 주장에 해당하고 이를 나타낸다. 도 817 CTMP의 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)에 대한 작동 세부 사항에 대해 자세히 설명한다. 합리적 어필(RA; Rational Appeal)(C811A) 인스턴스는 LOM 로그 집계(LOM Log Aggregate)를 카오틱 필드 파싱(CFP; Chaotic Field Parsing)(C535)으로 처리하기 위해 LOM 내에서 작동하고 문맥 구성(CC; Context Construction)(C817A)를 호출한다. CFP는 메모리 인식(MR)(C501)에서 참조하 는 CC(C817A)의 모듈식 출력에서 카오틱 필드를 생성한다. 현재 규칙(C534)는 이 인스턴스에서 LOM인 선택 된 패턴 매칭 알고리즘(SPMA)의 현재 기능 상태를 나타내는 규칙 집합을 표시한다. 현재 규칙(C534)는 규칙 구 문 미분(Rule Syntax Derivation, RSD)(C504) 모듈에 모듈식 입력으로 제출되며, 이는 논리적으로 '흑백' 규칙 들은 인식을 기반으로 메트릭을 변환하는 곳이다. 따라서 여러 규칙의 복잡한 배열은 다양한 그래디언트의 여러 메트릭(metrics)를 통해 표현되는 단일 균일 인식으로 변환된다. RSD(C504)의 모듈식 출력은 인색 매칭 (PM)(C503)에 모듈식 입력으로 제공된다. PM(C503)에서, 비교 가능한 가변 포맷(CVF) 유닛은 RSD(C504)에서 수신한 인식으로 구성된다. 새로 형성된 CVF는 유사한 인덱스를 가진 인지 저장(PS)(C478)에서 관련 인식을 검색 하는 것으로 사용된다. 잠재적 일치 항목은 규칙 구문 생성(RSG)(C505)에 모듈식 입력으로 제출된다. RSG(C50 5)는 인식 형식으로 저장된 이전에 확인된 인식을 수신하고 인식의 내부 메트릭 구성에 접근한다. 인식은 이전 에 확인된 인식(C468)이 포함된 PS(C478)에서 수신된다. 이러한 메트릭(metrics)의 그래디언트 기반 측정은 원 래 인식의 입력/출력 정보 흐름을 에뮬레이트하는 이진법 및 논리 규칙 집합으로 변환된다. 따라서 RSG(C505)는 관련성이 있고 대중적으로 고려되며 논리적 규칙으로 변환된 인식(Perceptions)인 인지 규칙(Perceptive Rules)(C537)을 생성한다. 만약 (초기 인식 포맷에서) 인식이 많은 '회색 영역'을 정의한 많은 복잡한 메트릭 관계가 있는 경우, '흑백' 로컬 규칙은 규칙 집합 복잡도를 확장함으로써 이러한 '회색' 영역을 포함한다. 따라 서 인지 규칙(C537)은 규칙 구문 포맷(RSF) 정의의 모음으로 저장된다. 인지 규칙(C537)은 메모리 인식 (MR)(C501)에 모듈식 입력으로 제출되며, 메모리 인식(MR)(C501)에서 CFP(C535)에 의해 생성된 카오스 필드에 대해 스캔된다. 따라서 MR(C501)은 유효성 있는 올바른 규칙(C533)을 완성하는 추가 규칙(C536)을 생성한다. 도 818은 CTMP의 암시 도출(ID)(C477)에 대한 작동 세부 사항에 대해 자세히 설명한다. 인지 저장 (PS)(C478)의 인지의 적용 각도(C470)은 인지의 함축 각도(C471)에 속하는 더 많은 인식을 생성하기 위해 모듈 식 입력으로 ID(C477)에 제출된다. 인지의 적용 각도(C470)은 구체적으로 ID(C477)의 메트릭 조합(C493)으로 전 송된다. 메트릭 조합(C493)은 메트릭(metrics)의 카테고리에 대해 수신된 인지의 각도(C650)을 범위(C739), 유 형(C740), 일관성(C741), 강도(C742)로 구분한다. 시스템 내에서 메트릭 가용성 및 참조가 반드시 상기 네 가지 유형으로 제한되는 것은 아니다. 인지의 각도(C650) 입력은 LOM의 주장 생성(AC)(C808A) 모듈에 의해 생성 된 목적 대체와 관련이 있다. 메트릭 복잡도 세트 A(C736)는 메트릭 확장(Metric Expansion, ME)(C495) 에 모듈식 입력으로 제출된다. ME(C495)를 사용하여 여러 인식의 각도(C650) 및 다양한 각도의 메트릭은 개별 데이터베이스 C739, C740, C741, C742 카테고리 별로 저장된다. ME(C495)는 이전에 알려진/접한 메트릭에서 추 출된 세부 사항/복잡도로 수신된 메트릭의 현재 배포를 향상시킨다. 향상 및 복잡도 강화 완료에 따라, 메트릭 은 메트릭 복잡도 세트 B(C737)으로 ME(C495) 모듈식의 출력으로 반환되고 그 후에 도 819에 설명된 바와 같이, 인지의 함축 각도(C471)에 저장되도록 인지의 각도(C650)로 다시 변환된다. 도 819은 개별 메트릭을 전체 인지의 각도(C650)으로 되돌리는 메트릭 변환(C494)에 의해 처리되는 메트릭 복잡 도 세트 B(C737)를 설명하는 도 818로부터 암시 도출(ID)(C477)의 논리 흐름을 계속한다. ID(C477)에 의해 수행 된 향상 및 변환 프로세스에도 불구하고, 생성된 인지의 각도(C650)는 여전히 LOM의 주장 생성(AC)(C808A) 모듈에 의해 생성된 목적 대체의 합리적으로 정확한 묘사를 제공한다. 따라서 메트릭 변환(C494) 프로세 스는 새로 도출/암시된 인식의 각도(C650)를 인지 저장(PS)(C478) 내의 인지의 함축 각도(C471)에 제출한다. 도 820는 CTMP의 비판적 결정 출력(CDO; Critical Decision Output)(C462)에 대한 작동 세부 사항에 대해 자세히 설명한다. 비판적 결정 출력(CDO; Critical Decision Output)(C462))는 CTMP의 두 가지 주요 브랜 치로부터 모듈식의 출력을 수신하고, (직관력 브랜치로서) 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)와 (논리적 브랜치로서) 규칙 실행(RE; Rule Execution)(C461)가 있다. 각 브랜치 C475/461은 그것의 각각의 비판적 결정(Critical Decision)(C521) (메인 모듈식의 출력)뿐 아니라 해당하는 '메타-메타 데 이터(Meta-metadata)'(C521)을 제출하며, 이는 초기 중요 결정에 도달한 이유를 정당화하는 맥락 변수를 제공한 다. POE(C475)의 인식(C516)과 RE(C461)의 이행된 규칙(C517)을 나타내는 두 결정 세트(C521)는 메타데이터 분 류 모듈(MCM)(C488)에 제출된다. MCM(C488)은 전통적인 구문 기반 정보 카테고리화를 사용하여 디버깅 및 알고 리즘 추적을 개별의 카테고리로 분류한다. 그러면 이러한 카테고리는 보안 위험과 대상과의 상관관계를 가지고 분명한 보안 대응을 조직하고 생성할 수 있다. POE(C475)의 인식(C526)을 나타내는 직관적 의사 결정(C514)와 RE(C461)의 이행된 규칙(C517)을 나타내는 사고 결정(C515)은 MCM(C488)에 의해 방향 결정 비교(DDC)(C512)의 내부 프로세싱 로직에 제출된다. DDC(C512)의 내부 프로세싱 로직은 직관적 의사 결정(C514)와 사 고 결정(C515) 사이의 확증 또는 충돌을 확인한다. DDC(C512)는 정적 하드코드된 정책(SHP)의 '차단 변 수'를 참조한다. 만약 차단 변수는 직관적 의사 결정(C514)와 사고 결정(C515) 사이에 유사성에 도달하지 않으 면 (예를 들어, 90 % +), 무효화 직접 비교는 직접 발생하며, 이는 도 821에 도시된 바와 같이, 확신없는 투표에 최종적으로 제출하도록 터미널 출력 제어(TOC)(C513)에 연결된다. 무효화 직접 비교 단계는 CTMP가 RIP의 프롬프트 입력과 관련하여 내부적으로 일관성 있는 작동할 수 없음을 의미한다. 만약 '차단 변수가 내부 프로세싱 로직에 따라 충분히 충족되면, 최종 비판적 출력(Final Critical Decision) 단계가 터미널 출력 제어(TOC)(C513)에 의해 수신 및 처리되는 단일 모듈식의 출력으로 두 결 정 C514/C515를 결합하여 호출한다. 도 821은 도 794의 비판적 결정 출력(CDO; Critical Decision Output)(C462)의 논리 흐름을 계속하고 터미널 출력 제어(TOC)(C513)의 작동 세부 사항을 자세히 설명한다. TOC(C513)은 방향 결정 비교(DDC)(C512)가 (무효화 직접 비교 지시 대신) 최종 비판적 출력(Final Critical Decision)을 제공할 수 있는지 확인하는 프롬프트으로 시작한다. 프롬프트에 대한 응답이 Yes인 경우, 최종 비판적 출력(Final Critical Decision)에서 DDC(C512)에 의해 제공된 결합된 최종 결정은 TOC(C513)의 모듈식 출력으로 제 출되며, 따라서 최종 임계 결정으로 전체 CTMP 인스턴스의 모듈식 출력으로서 제출된다. 프롬프트 에 대한 응답이 No인 경우, 5532단계가 자체적으로 인식 매칭(PM; Perception Matching)의 실행을 호출하고 해당 결과를 가져오게 되어 호출된다. 이행된 규칙(C517)은 규칙 실행(RE)(C461)의 중요 결정 + 메타-메타 데이터(C521)에서 추출된다. 규칙(C517)은 규칙 구문 미분(RSD)(C504)에 의해 인식으로 변환된다. 그 다음에, PM는 프롬프트에서 강력한 내부 중복(strong internal overlap)과 사용된 인식의 확증 (corroboration of Perceptions)이 있는지 결정하기 위해 메타-메타 데이터를 참조한다. 만약 프롬프트 에 대한 응답이 예인 경우, 모듈식 출력으로 CTMP 대신하여 확신없는 투표를 나타낸다. 만약 프롬프트에 대한 응답이 No인 경우, 5540단계가 활성화되어 직관적 의사 결정(C514)와 사고 결정 (C515) 사이에서 인식된 가장 위험이 덜한 결정을 선택한다. 따라서 최종 임계 결정는 비판적 결정 출력 (CDO; Critical Decision Output)(C462), TOC(C513) 및 CTMP에 모듈식 출력으로 제출된다. 5534단계의 논 리는 직관적 의사 결정(C514)와 사고 결정(C515) 사이의 일치성 부족이 알고리즘에 대한 신뢰가 부족하거나, 둘 사이의 반대되는 관점 때문에 발생하는지 여부를 판별하기 위해 발생한다. 따라서 후자가 발생할 경우, 잠재적 인 최종 임계 결정는 여전히 모듈식 출력으로 식별할 수 있다. 확신없는 투표는 항상 합리적 어필 (RA)(C811A) 내에서 신뢰도가 낮은 신뢰도 결과(C845) 논리 경로로 이어진다. 최종 임계 결정는 최종 임 계 결정 뒤에 알고리즘 신뢰도에 따라 RA(C811A) 내에서 높은 신뢰도 결과(C846) 또는 낮은 신뢰도 결과 (C845) 논리 경로로 이어질 수 있다. 도 822는 이상적인 하드웨어 구성(Ideal Hardware Configuration)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 이상적인 하드웨어 구성 은 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)으로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 이상적인 하드웨어 구성은 코드 변환(C321)에 의해 하드웨어 구문형식으로 수신 된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언 어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역 함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송 된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되 고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복 합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포 맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영 역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스 크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능 을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 823은 이상적인 하드웨어 구성을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하 기 위해 도 822의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD(12 0)을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 이상적인 하드웨어 구조의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 824는 이상적인 구성 호출 프롬프트(ICIP; Idealistic Configuration Invocation Prompt)이 이상적인 하드웨어 구성를 제공하는 향상된 하드웨어 개발(EHD) 프로세스를 도시한다. LIZARD은 이상적 인 하드웨어 구성를 8834 단계에서 목적 계층 맵으로 변환한다. 8836단계에서, LOM은 CKR에서 전기 엔지니어링 원칙을 생성하고 LIZARD으로 전송한다. LIZARD은 전기 엔지니 어링 원칙을 8840단계에서 목적 계층 맵으로 변환한다. 목적 대 목적 대칭 처리(P2SP)는 목 적 계층 맵 및 목적 계층 맵을 사용하고 8846단계에서 전기 엔지니어링 원칙의 목적 계층 맵 과 호환되는지 여부를 결정하는 대칭 처리 결과를 생성한다. 도 825는 LOM가 디자인 원칙 호출 프롬프트(DPIP)을 기반으로 8836단계에서 중앙 지식 보유 (CKR)로부터 전기 엔지니어링 원칙을 생성하는 향상된 하드웨어 개발(EHD) 프로세스를 도시한 다. LOM은 전기 엔지니어링 원칙의 결정 프로세스를 용이하게 하는 ARM에 의해 검색된 데이터로부터 CKR 내에 오버타임 개념을 구축한다. CKR은 선천적인 발전 추론을 통해 강력한 정의 기반을 구축하고 LOM이 출력하는 어떤 결정도 정당화할 수 있다. 클러스터 구축(C854F)으로, CKR은 유닛 지식 포맷 (UKF) 클러스터(C854F)로 알려진 정보의 '스태킹' 구축 블록(blocks)의 정보를 통해 개념적 결론에 도달한다. 상기 클러스터는 귀속 가능한 출처, 의심되는 정보 생성 시간, 효율성, 디자인 등 대상 정보와 관련된 광범위의 메타 데이터를 포함한다. 각 UKF 클러스터(C854F)는 규칙 구문 포멧(RSF)(C538)을 포함한다. 도 826은 전기 엔지니어링 원칙(Electrical Engineering Principles)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 전기 엔지니어링 원칙 은 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 전 기 엔지니어링 원칙은 코드 변환(C321)에 의해 원칙 구문 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코 드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function) 도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한 다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출 력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의 도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍 을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암 호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준 화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다 양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 827은 전기 엔지니어링 원칙을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 826의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해 석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD(12 0)을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 전기 엔지니어링 원칙의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정 의 및 적용은 전술한 기능 및 모듈에 적용된다.도 828은 다이나믹 하드웨어 배포 메커니즘(DHDM)에 대한 향상된 하드웨어 개발(EHD) 프로세스를 도시한다. 8846단계에서, 대칭 처리 결과는 이상적인 하드웨어 구성의 목적 계층 맵이 전기 엔지니어링 설계 원리의 목적 계층 맵과 호환되는지 여부를 확인하기 위해 8846단계에서 결정한다. 아니요, 호환되지 않음 (No, not compatible)면, 공식 시스템 토큰를 포함하는 DLU를 자동화된 리서치 매커니즘 (ARM)의 진단 로그 제출(DLS)에 제출한다. 8846 단계의 결과가 예, 호환됨(Yes, compatible)(884 8)인 경우, 8852단계에서 이상적인 하드웨어 구성을 DHDM에 제출한다. 도 829는 다이나믹 하드웨어 배포 메커니즘(DHDM)을 위해 향상된 하드웨어 개발(EHD)의 도 828로부 터 논리흐름을 계속하며, DLCB은 DLCB를 조사하기 위해 DLCB 모음을 대상으로 한다. 8864단 계에서 DLCB 타겟 모음의 다이나믹 수정 호출(DMIC)에 접근하고, 8866 단계에서 잠긴 DMIC을 가진 것과 잠금 해 제된 DMIC을 가진 것 사이에 DLCB을 분류한다. 8872단계에서, 이상적인 하드웨어 구성의 설치를 위해 잠금 해제 된 DMIC 캐시 보유(Unlocked DMIC Cache Retention)(UDCR)부터 사양 롤아웃 메커니즘(SRM)까지 모 든 DLCB를 제출한다. 8874단계에서, 잠긴 DMIC 캐시 보유(Locked DMIC Cache Retention, LDCR)의 모든 DLCB에 대해 제조사 협정 정산(Manufacturer Negotiation Settlement, MNS)을 시행한다. DLCB 원래의 제조사 는 사양 롤아웃 메커니즘(SRM)에 입력하는 MNS과 상호 작용한다. 도 830 내지 도 832는 188단계에서 시작하는 UBEC 자동 배포(UBEC Automated Deployment, UAD)을 위한 프로세스를 도시하며, 상기 188 단계에서 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)은 소프트웨어, 펌웨어 및 하드웨어 업데이트를 UBEC의 핵심 코드 구조에 제출한다. 배포 대상 메커니즘(Deployment Targeting Mechanism, DTM)은 수신된 업데이트를 배포 타겟으로 전달한 다. 8906 단계에서, UBEC/BCHAIN 하이브리드 코어 로직 인스턴스는 배포 타겟에 배포할 준비된다. 인터페이스 드라이버는 8908단계에서 배포 타겟의 관련 최신 사양을 완전히 준수하도록 업데이트된 다. 8910단계에서, 인터페이스 드라이버는 UBEC/BCHAIN 하이브리드 코어 로직의 선택된 인스턴스에 설치된 다. 8912단계에서, UBEC/BCHAIN 하이브리드 코어 로직의 인스턴스에서 조립된 업데이트된 어플리케이션은 배포 타겟에 제출한다. 도 831은 UBEC 자동 배포(UAD), UBEC/BCHAIN 하이브리드 코어 로직의 인스턴스가 배포 타겟에 배포 될 준비가 된단계를 위해 도 830의 프로세스를 계속한다. 8914단계에서, UBEC/BCHAIN 하이브리드 코어 로 직을 저장하는 인증된 스토리지 앱체인은 등록된 앱체인에 의해 제공된 앱체인 아이덴티티에 따라 메 타체인의 앱체인 업데이트을 조회한다. 8916 단계에서, UBEC/BCHAIN 하이브리드 코어 로직 컨텐 츠는 BCHAIN의 컨텐츠 클레임 생성기(CCG; Content Claim Generator)을 통해 생성된다. 도 832는 인터페이스 드라이버는 배포 타겟의 관련 최신 사양을 완전히 준수하도록 업데이트되는 UBEC 자동 배 포(UAD) 8908단계에 대한 도 831로부터의 프로세스를 계속한다. 8918단계에서, 인터페이스 사양은 배포 타겟 내의 정의에서 참조된다. 8922단계에서, 일반 인터페이스 드라이버 베이스는 인터페이스 사양을 준수하도록 수정하기 위해 참조된다. LIZARD은 8926단계에서 인터페이스 드라이버 베이 스를 목적 계층 맵으로 변환한다. LIZARD는 8926단계에서 인터페이스 사양을 목적 계층 맵으 로 변환한다. 도 833은 인터페이스 드라이버(Interface Drivers)를 목적 계층 맵(Purpose Hierarchy Map)으로 변 환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 인터페이스 드라이버는 외부 코어 (OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷 (C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 인터페이스 드라이버는 코드 변환(C321)에 의해 드라이버 사양 형식으로 수신된다. 코드 변환(C321)은 SM(C35) 에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환 (C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행 한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따 라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기 능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생 성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다 양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 834는 인터페이스 드라이버를 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 833의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해 석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD(12 0)을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 인터페이스 드라이버의 복 합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 835는 인터페이스 사양(Interface Specifications)을 목적 계층 맵(Purpose Hierarchy Map)으 로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 인터페이스 사양은 외부 코어 (OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷 (C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 인터페이스 사양은 코드 변환(C321)에 의해 프레임워크 사양 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에 서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환 (C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행 한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따 라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기 능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생 성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다 양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 836은 인터페이스 사양을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 835의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석 (C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위 해 모든 상호 연결된 기능을 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 출력은 인터페이스 사양의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용 은 전술한 기능 및 모듈에 적용된다.도 837은 인터페이스 드라이버는 배포 대상의 관련 최신 사양을 완전히 준수하도록 업데이트되는 8908단계에서 UBEC 자동 배포 세부 사항을 도시한다. 8932 단계에서, 목적 계층 맵 8930 및 8932는 마스터/슬레이브 선 호도에 슬레이브로써 인터페이스 드라이버의 파생된 맵과 마스터로써 인터페이스 사양의 파 생된 맵을 포함하는 목적 재조정 처리(PRP)에 제출된다. 8936단계에서, 인터페이스 사양과 호환되 도록 인터페이스 드라이버를 나타내는 업그레이드된 목적 맵이 생성된다. LIZARD는 업그레이드 된 목적 맵을 8938단계에서 인터페이스 드라이버로 변환한다. 도 838은 인터페이스 드라이버가 하이브리드 코어의 선택된 인스턴스에 설치되는 8910단계에서 UBEC 자동 배포 세부 사항을 도시한다. 8940단계에서, 모듈식 인터페이스 플러그인은 하이브리드 코어 로직 인스턴 스 내에서 선택된다. 8942단계에서, LIZARD는 미리 정의된 API 후크 참조를 사용하여 인터페 이스 드라이버를 모듈식 인터페이스 플러그인에 설치한다. 도 839는 LIZARD는 미리 정의된 API 후크를 사용하여 인터페이스 드라이버를 모듈식 인터페이스 플러그인에 설 치하는 8942단계에서 UBEC 자동 배포 세부 사항을 도시한다. 8942단계에서, LIZARD은 미리 정의된 API 후크 참조를 사용하여 인터페이스 드라이버를 모듈식 인터페이스 플러그인에 설치한다. 8946단계에서, 정의된 모든 API 후크 참조를 반복한다. 8950단계에서, 모듈식 인터페이스 플러그인 에 선택된 API 후크 참조 유닛가 존재하는지 확인한다. 유닛이 존재하지 않음인 경우, 그것은 공식 시스템과 함께 DLU를 제출한다. 유닛이 존재함인 경우, 후크 위치 캐시 보유(HLCR)의 선택된 API 후크 참조 유닛에 해당하는 모듈 인터페이스 플러그인 부분의 참조를 저장하는 8956단계로 진행 된다. 8960 단계에서, 선택된 API 후크 참조 유닛이 인터페이스에 존재하는지 확인한다. 유닛이 존재하지 않음인 경우, 5600에서 공식 시스템과 함께 DLU를 제출한다. 유닛이 존재함인 경우, 선택된 API 후 크 유닛에 해당하는 인터페이스 드라이버 부분의 참조를 저장한다. 도 840은 LIZARD는 미리 정의된 API 후크를 사용하여 인터페이스 드라이버를 모듈식 인터페이스 플러그인에 설 치하는 8942단계에서 UBEC 자동 배포을 도시하기 위해 도 839의 논리를 계속한다. 8966 단계에서, 후크 위치 캐시 보유(HLCR)의 API 후크 참조 유닛으로 참조되는 인터페이스 드라이버 및 모듈러 인 터페이스 플러그인에서 부분을 검색한다. 8970 단계에서 LIZARD은 인터페이스 플러그인 참조된 부분을 목적 계층 맵으로 변환하고, 8976단계에서 LIZARD은 인터페이스 드라이버 참조된 부분 을 목적 계층 맵으로 변환한다. 도 841은 모듈식 인터페이스 플러그인 참조 부분(Modular Interface Plugin Referenced Part)을 목적 계 층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 모 듈식 인터페이스 플러그인 참조 부분은 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출 된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부 터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작 성된다. 의사 코드에는 if/else문, while루프 등과 같은 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산 의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드 를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 모듈식 인터페이스 플러그인 참조 부분은 코드 변환 (C321)에 의해 드라이버 사양 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임 의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형 으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완 료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행 이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해 석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사 용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또 한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문 가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프 레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소 는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 842은 모듈식 인터페이스 플러그인 참조 부분을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 841의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈 (PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목 적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 모듈식 인터페 이스 플러그인 참조 부분의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 843은 인터페이스 드라이버 참조 부분(Interface Drivers Referenced Part)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 인터페이스 드라이 버 참조 부분은 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325) 를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등과 같은 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한 다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변 환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 인터페이스 드라이버 참조 부분은 코드 변환(C321)에 의해 프레임워크 사양 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환 (translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소 (C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생 성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정 의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이 진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코 어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프 로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코 어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36) 에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목 표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동 한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 도 844는 인터페이스 드라이버 참조 부분을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 843의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생 성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 인터페이스 드라이버 참조 부분의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 845는 8942단계의 UBEC 자동 배포(UAD; UBEC Automated Deployment) 세부 사항을 도시하며, LIZARD은 사전 정의된 API 후크(predefined API hooks)를 사용하여 인터페이스 드라이버(Interface Drivers)를 모듈식 인터페이스 플러그인(Modular Interface Plugin)에 설치한다. 목적 대 목적 대칭 처리 (P2SP; Purpose to Purpose Symmetry)은 모듈식 인터페이스 플러그인 참조 부분(Modular Interface Plugin Referenced Part)을 포함하는 목적 계층 맵(Purpose Hierarchy Map) 및 인터페이스 드라이 버 참조 부분(Interface Drivers Referenced Part)을 포함하는 목적 계층 맵(Purpose HierarchyMap)을 분석한다. 대칭 처리 결과(Symmetry Processing Result)는 모듈식 인터페이스 플러그인 참 조 부분(Modular Interface Plugin Referenced Part)의 목적 계층 맵가 인터페이스 드라이버 참조 부분(Interface Drivers Referenced Part)의 목적 계층 맵과 일치하는지 확인하기 위해 8982단계 에서 검토된다. 예, 일치함(Yes, congruent)으로, LIZARD을 통해 구문 모듈(SM; Syntax Module)(C35)를 사용하는8988단계로 진행하고, 모듈러 인터페이스 플러그인 참조 부분은 해당 인터페이스 드라 이버 참조(Interface Drivers Referenced)에 의해 충족되도록 수정된다. 아니요, 불일치(No, not congruent)인 경우, 공식 시스템(Official System)을 포함하는 진단 로그 유닛(DLU; Diagnostic Log Unit)를 제출한다. 도 846은 8912단계에서 UBEC 자동 배포(UAD) 세부 사항을 도시하며, 상기 8912단계는 하이브리드 코어 로 직의 인스턴스에서 조립된 업데이트된 애플리케이션이 배포 타겟에 제출된다. LIZARD은 8942 단계에서 미 리 정의된 API 후크를 사용하여 인터페이스 드라이버를 모듈식 인터페이스 플러그인에 설치한다. 8990단계에서, 포함된 애플리케이션 패키지로 표시되도록 LIZARD은 수정된 하이브리드 코어 로직 인스턴스 의 컨테이너 참조를 변경한다. 8992단계에서, 배포 타겟이 어플리케이션은 미가공 소스 코드 또는 이진으로 제출되었는지 확인한다. 도 847은 8912단계에서 UBEC 자동 배포(UDA) 세부 사항에 대한 도 846의 논리를 계속하며, 상기 8912단계 에서 하이브리드 코어 로직의 인스턴스로부터 조립된 업데이트 된 애플리케이션이 배포 타겟에 제출된다. (9000 으로 잘못 표시된) 9001단계에서 배포 타겟이 최신 배포 전략 루틴을 정의하는지 확인한다. 예 인 경우, UBEC/BCHAIN 애플리케이션이 정의된 배포 전략 루틴을 통해 배포 타겟에 제출되는 9006단계로 진행한다. 아니요인 경우, 5000단계에서 공식 시스템 토큰와 함께 DLU를 ARM의 진단 로그 제출(DLS)에 제출한다. 도 848은 레거시 API 및 프레임워크로 구성된 레거시 시스템를 포함하는 Stage 1 - Full Legacy의 앱체인 채택 단계(SA2)를 도시한다. 9112에서, 레거시 오퍼레이션에서 앱체인 으로 프로그램을 변환한다. SPSI는 레거시로 프로그램의 효율성 및 기능 업그레이드, 유지 관리 및 일반 수정을 수행한다. Stage 2 - Emulated Appchain Over Legacy는 레거시 API 및 프레임워크으 로 구성된 레거시 시스템을 포함하며, 상기 레거시 API 및 프레임워크는 앱체인 에뮬레이션 레이어 (AEL)을 포함한다. SPSI는 앱체인으로 프로그램의 효율성 및 기능 업그레이드, 유지보수 및 일반적 인 수정을 수행한다. 도 849는 레거시 시스템을 포함하는 Stage 2 - Emulated Appchain over Legacy의 앱체인 채택 단 계(SA2)를 도시하며, 상기 레거시 시스템은 앱체인 에뮬레이션 레이어(AEL)으로 구성된 레거 시 API 및 프레임워크을 포함한다. SPSI는 앱체인으로 프로그램의 효율성 및 기능 업그레이드, 유 지보수 및 일반적인 수정을 수행한다. 9122단계에서, 가용성, 안정성, 속도, 효율성, 보안 등을 향상시키기 위 해 BCHAIN 네트워크에 앱체인으로서 프로그램을 배포한다. SPSI는 앱체인으로서의 프로그램의 효율성 및 기능 업그레이드, 유지 보수 및 일반 수정을 수행한다. 도 850은 가용성, 안정성, 속도 등을 향상시키기 위해 BCHAIN 네트워크에 앱체인으로서 프로그램 구축을 포함하는 Stage 2 - Emulated Appchain over Legacy의 앱체인 채택 단계(SA2)의 BCHAIN 배포에 대 한 레거시(LBD)를 도시한다. 레거시 관리는 9020에서 타겟 앱체인이 BCHAIN 네트워크에 배포되도록 명시적으로 선택한다. 9204에서, 레거시 관리는 인증된 사용자 세션을 통해 BCHAIN 프로토콜의 사용 자 노드 상호 작용(UNI)과 인증을 수행한다. 도 851은 앱체인이 BCHAIN 네트워크에 배포될 때 타겟된 프로그램에서 BCHAIN 배포에 대한 레거시(LBD)을 도시하는 도 850의 논리를 계속한다. 9212단계에서, 앱체인으로서의 프로그램은 새로운 컨텐츠 알림 (NCA)을 통해 BCHAIN 네트워크에 제출된다. 606에서, 컨텐츠는 채굴기(miners)의 Mempool 데이터 스토리 지(Mempool Data Storage, MDS)에 제출되며 최종적으로 커스텀체인 인터페이스 모듈(CIM)을 통해 앱체인 의 다음 블록으로 채굴된다. 608에서, 새로 채굴된 블록의 컨텐츠는 캐시 부분들로 절단되고 캐시 시드를 제공 하는 채굴 노드(MNSCS)를 통해 캐싱 노드로 전송된다. 610에서, 캐시 부분은 점차적 및 자동적으로 캐시 선택 알고리즘(CSA)을 사용하여 데이터를 요청하는 노드에 가능한 최상의 가동 시간 및 다운로드 속도를 보장하는 서비스 최적화 영역으로 이동한다. 612에서, 노드는 캐싱 노드 CCG에서 컨텐츠를 할당한다. 일 단 다운로드되면 이러한 노드는 ESR을 통해 실행 스트림을 실행할 수 있으며, 이는 의도된 어플리케이션의 명시 로 이어진다.도 852는 레거시 관리가 9252단계에서, 배포 인터페이스(Deployment Interface)와 상호 작용하는 에뮬레이션 레이어 배포(ELD; Emulation Layer Deployment)를 도시한다. 9252단계에서, 레거시 관리는 타겟 시스템 유형을 배포 인터페이스(DI)로 전송한다. 9260단계에서, Dl는 타겟 시스템 유형 과 호환되는 사전 컴파일된 이진법(Pre-compiled Binary)로 응답한다. 9262단계에서, 사전 컴파일 된 이진법의 서명이 Dl에서 시작되었는지 확인한다. 9266단계에서, 레거시 관리는 사전 컴파일된 이진법 영구 루트 권한(Pre-Compiled Binary Persistent Root Permissions)를 부여한다. 사전 컴파일된 이진법은 의도된 타겟 시스템에서 실행되어 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)이 실행된다. 도 853은 배포 인터페이스(DI) 작동을 도시한다. 9274단계에서, 사용 가능한 모든 시스템 유형을 반복한다. LIZARD은 모듈식 앱체인 종속성를 9278 단계에서 목적 계층 맵 및 목적 계층 맵 으로 변환한다. 9290단계에서, 모듈식 앱체인 종속성의 목적 계층 맵은 업그레이드된 목적 맵 에 대해 PRP을 통해 AEL 소스 코드의 목적 계층 맵에 통합된다. 도 854는 LIZARD에 관한 모듈식 앱체인 종속성(Modular Appchain Dependencies)을 목적 계층 맵 (Purpose Hierar-chy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. LIZARD에 관한 모듈식 앱체인 종속성는 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36) 로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등과 같은 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연 산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코 드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. LIZARD에 관한 모듈식 앱체인 종속성는 코드 변 환(C321)에 의해 앱체인 구문 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임 의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형 으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따 라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실 행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문 가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프 레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소 는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 855는 LIZARD에 관한 모듈식 앱체인 종속성을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 854의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어 (OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 LIZARD에 관한 모듈식 앱체인 종속성의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵 으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 856은 I2GE에 관한 모듈식 앱체인 종속성(Modular Appchain Dependencies)을 목적 계층 맵 (Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. I2GE에 관한 모듈식 앱체인 종속성은 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제 출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기 본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실 제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C3 6)의 컴퓨터 코드의 구문적 해석을 제공한다. I2GE에 관한 모듈식 앱체인 종속성은 코드 변환(C32 1)에 의해 앱체인 구문 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일 반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알 려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실 행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완 료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석 (C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사 용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또 한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문 가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프 레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소 는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 857은 I2GE에 관한 모듈식 앱체인 종속성을 목적 계층 맵으로 변환하기 위한 LIZARD(12 0)의 작동을 설명하기 위해 도 856의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모 듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어 (OC)(C329), 따라서 LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 결과는 I2GE에 관한 모듈식 앱체인 종속성 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 858은 단계 9290에서 모듈식 앱체인 종속성의 목적 계층 맵이 PRP을 통해 AEL 소스 코드의 목적 계층 맵에 통합되는 배포 인터페이스(DI) 작동을 도시한다. 9294단계에서, LIZARD은 업그레이 드된 목적 맵을 선택된 시스템 유형과 관련된 적절한 구문으로 변환한다. 9298단계에서, 결과 사전 컴파일된 이진법은 사전 컴파일된 이진법 캐시 보존(PBCR)에 저장되고, 존재하는 경우 시스템 유형 에 대한 이전 이진법을 대체한다. 9300단계에서, 사용 가능한 다음 시스템으로 루프를 진행하고 선택된 시스템 유형을 식별하기 위해 사용 가능한 모든 시스템 유형를 통해 반복한다. 도 859는 업그레이드된 목적 맵을 사전 컴파일된 이진법으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 업그레이드된 목적 맵은 복합 목적 포맷(C325)에 존재하고 LIZARD의 외 부 코어(OC)(C329)내에서 목적 모듈(C36)의 반복 확장(C327)에 제출된다. 반복 확장(C327)은 단순한 목표를 특 정 복합 목적 정의로 발전시키기 위해 세부사항과 복잡도를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 가능성은 복합 목적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC)(C333)의 핵심 코드 (C335) 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메 모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 860은 업그레이드된 목적 맵을 사전 컴파일된 이진법으로 변환하기 위한 LIZARD의 동작을 도시하기 위해 도 859의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C32 5)으로 수신되고 구문 모듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 기능에서 논리적으로 필요한 기능을 도출한다. 이는 만약 함수가 더 간단한 상위의 함수로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분 (Logical Derivation)(C320)에 의해 형성되는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이 터에 따라 구축된 종속성 함수의 트리이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC)(C333)의 핵심 코드(C335) 요소로부터 상속된 규칙 및 구문(C322) 정의에 따라 작동한다. 논리적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유 형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 따라서 PM(C36)은 코드 변환(C321)을 통해 입력 업그레이도된 목적 맵의 결과 구문 버전을 생성하기 위해 SM(C35)를 호출한 다. 코드 변환(C321)에 의해 최종적으로 생성되는 결과 사전 컴파일된 이진 유닛은 SM(C35), 외부 코어 (OC)(C329) 및 LIZARD의 모듈식 출력이다. 도 861은 9298단계에서 배포 인터페이스(DI) 시작을 도시하고, 결과 사전 컴파일된 이진법은 PBCR에 저장되고, 이미 존재하는 경우 시스템 유형에 대한 이전 이진법을 대체한다. 9304단계에서, 사전 컴파일된 이진법에 대한 요청이 PBCR로 전송된다. 9305 단계에서(도 861에서 9304로 잘못 표시됨), 요청된 타겟 시스템 유형과 일치하는 해당 사전 컴파일된 이진법이 PBCR의 ELD을 통해 레거시 관리로 전송된다. 9260 단계에서, Dl는 타겟 시스템 유형과 호환되는 사전 컴파일된 이진법과 반응한다. 레거시 관리은 9254단계에서 타겟 시스템 유형을 전송한다. 도 862 내지 도 879는 BCHAIN 네트워크에 참여하지 않는 레거시 환경에서 앱체인을 실행할 수 있는 앱체인 에뮬레이터 레이어(AEL)의 작동 및 기능을 도시한다. 도 862는 정적 앱체인 처리(Static Appchain Processing, SAP)을 통한 사전 컴파일된 애플리케이션 스택 (Precompiled Application Stack, PAS) 인스턴스의 생성을 도시한다. SAP은 정적 앱체인 보유 를 생성 및 PAS에 모듈식 입력으로 제출하므로 해당 앱체인 컨텐츠를 해석한다. 어플리케이션 에뮬레이션 레이어(Application Emulation Layer, AEL)은 레거시 시스템 내에서 PAS 인스턴스 자 율성을 제공하므로, PAS에 컴파일 및 임베딩된다. AEL의 서브모듈은 타겟 시스템 해석 및 검출 (Target System Interpretation and Detection, TSID)이다. 따라서 상기 PAS는 임의의 시스템에서 호출될 경우, AEL은 일반적으로 기본 명령 세트에서 실행되고 타겟 시스템의 운영 체제, 장 치 드라이버 및 하드웨어를 검출하기 위해 시도한다. 따라서 AEL은 정적 앱체인 보유 를 완전히 실행되도록 하는 타겟 시스템에 대해 복잡한 코드를 실행하기 위한 적절한 변환 메커니즘을 호 출한다. 보유는 타겟된 앱체인을 위한 앱체인 실행 세그먼트와 데이터 세그먼트를 포함하며, 다른 앱체인과 마찬가지로 타겟된 앱체인은 LOM 와 LIZARD와 같이 작동에 의존 한다. 도 863은 앱체인 에뮬레이션 레이어(Appchain Emulation Layer, AEL)의 작동 및 기능을 도시한다. 정적 앱체인 처리(SAP)은 타겟된 앱체인을 포함하는 정적 앱체인 보유 인스턴스를 생성한다. 정적 앱체인 보유는 AEL의 실행 및 데이터 세그먼트 추출(EDSE) 모듈에 모듈식 입력으로 제출된다. EDSE은 9432단계에서 실행 스트림 모음(ESC)의 호출과 9434단계에서 데이터 스트림 정렬 (DSS)의 호출을 위한 컨테이너 모듈이다. 타겟 시스템은 정적 타겟 시스템 라이브러리 모음를 통해 타겟 시스템 해석 및 검출(TSID) 모듈에 의해 해석된다. 모음는 다양한 시스템 유형에 적용 할 수 있는 적절한 명령어 세트를 정의한다. 따라서 TSID는 정확한 계산 명령을 타겟 시스템(940 6)에 제출하도록 AEL의 내부 작동을 할 수 있는 타겟 시스템 명령어 세트를 생산한다. 실행 세그먼 트 변환(EST)이 타겟 시스템 명령어 세트를 해석하기 위해 9432단계에서 호출되며, 따라서 상기 타 겟 시스템 명령어 세트는 앱체인 구문을 적절한 레거시 데이터 세그먼트로 변환한다. 데이터 세그먼 트 변환(DST)은 타겟 시스템 명령어 세트를 해석하기 위해 9434단계를 호출되며, 따라서 상기 타겟 시스템 명령어 세트는 앱체인 구문을 적절한 레거시 데이터 세그먼트로 변환한다. EST 및 DST의 모듈식 출력은 모두 레거시 명령어 통합(LIU)에 제출되고, 상기 레거시 명령어 통합 (LIU)는 타겟 시스템 명령어 세트에 따라 정적 앱체인 보유를 제시(render)하도록 실행 스트 림 렌더링(ESR)의 실시간 인스턴스를 호출한다. AEL의 관할구역 외부 및 타겟 시스템 내부의 요소(타겟 시스템의 레거시 파일 시스템에 파일을 쓰는 것과 같은)를 조작하기 위한 시도는 외부 명령어 미들웨어(EIM)에 의해 처리된다. 따라서 LIU의 모듈식 출력은 배포할 수 있는 명령어 스트림(944 6)이다. 상기 명령어 스트림은 타겟 시스템에 의해 이해되고 실행되며, 정적 앱체인 보유 실행의 실질적인 명시를 의미하고 있으므로, 레거시 시스템에서 타겟 앱체인의 실행을 암시한다. 도 864는 외부 명령어 미들웨어(EIM)의 동작 및 기능을 도시한다. 레거시 명령어 통합(LIU) 모듈의 실행 스트림 렌더링(ESR) 인스턴스 내의 정적 앱체인 보유의 동작은 모듈식 출력으로 외부 명령어 제안 및 명령어 분리 준비 인덱스를 생산하도록 LIU을 야기한다. 이러한 출력인 9452 및 9454는 출력는 9456단계에서 수신되므로 EIM에 모듈식 입력으로 제출된다. 9458단계는 외부 명령어 제안를 목적 계층 맵로 변환하기 위해 LIZARD을 호출한다. 그 후 9466단계는 모듈식 입력 명 령어 목적 모음과 목적 계층 맵에 대해 목적 재조정 처리(PRP) 모듈을 호출하는 것을 실행한 다. 마스터/슬레이브 선호도은 명령어 목적 모음을 슬레이브로 정의한다. 따라서 PRP은 모듈 식 출력으로 명령어 목적 모음의 새로운 생성한다. 9468단계에서, LIU는 LIZARD의 니드 맵 매칭 (NMM)(C114) 서브모듈을 통해 명령어 분리 준비를 생성하기 위해 호출된다. 명령어 분리 준비상태 의 적용 가능성은 도 1230에 설명되어 있다. 도 865는 외부 명령어 제안(External Instruction Proposition)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD(의 작동에 관한 세부 사항을 도시한다. 외부 명령어 제안은 외부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레 임워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원 하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 외 부 명령어 제안은 코드 변환(C321)에 의해 ESR 명령어/명령 구문 형식으로 수신된다. 코드 변환 (C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감 소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식 으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35) 의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코 드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조 각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷 (C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보 수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역 이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크 립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가 능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 다양 한 동적 및 sialic iunclions wilhiii LIZARD을 설명하는 정책 변수로 작동한다. 도 866은 외부 명령어 제안을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위 해 도 865의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석 (C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위 해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 출력은 외부 명령어 제안의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용 은 전술한 기능 및 모듈에 적용된다. 도 867은 9468단계에서 도 864의 외부 명령어 미들웨어(EIM)의 논리 흐름을 계속하며, 이는 명령어 분리 준비 변수를 생성하기 위해 레거시 명령어 통합(LIU)을 호출한다. 준비 변수는 명령어 목적 모음이 대체 실행 구문의 간섭없이 실행되도록 타겟 시스템 내에서 충분히 격리되는지를 정의한다. 따라서 명령어 분리 준비 변수가 명령어 목적 모음을 타겟 시스템에 아직 배포할 수 있음을 나타내는지 평가하는 프롬프트이 활성화된다. 프롬프트에 대한 응답이 배포 준비 안됨(Deployment Not Ready)인 경우, 9478단계는 다음의 외부 명령어 제안가 레거시 명령어 통합(LIU)을 통해 실행 스트림 렌더링(ESR)에 의해 생성될 때까지 EIM의 실행을 중단하는 것을 활성화한다. 프롬 프트에 대한 응답은 배포 준비 완료(Deployment Ready)인 경우, 9476단계는 명령어 목적 모음 을 타겟 시스템 해석 및 검출(TSID)에 정의된 해당 구문으로 변환하기 위해 LIZARD을 호출한 다. 따라서 9476단계는 EIM를 위한 모듈식 출력인 배포할 수 있는 명령어 스트림을 생성하고 타겟 시스템 내에서 기본적으로 실행된다. 도 868은 LIZARD의 다이나믹 쉘(C198)의 서브모듈로서 작동하는 니드 맵 매칭(NMM)(C114)의 동작 및 기능 을 도시한다. NMM(C114) 인스턴스는 레거시 명령어 통합(LIU) 모듈의 9468단계 작업을 수행하기 위해 생 성된다. 타겟 시스템 해석 및 검출(TSID)은 니드 액세스, 개발 및 스토리지에 저장하기 위해 제출 된다. 따라서 TSID는 하위 카테고리로 분류되며 일련의 계층적 브랜치 및 레이어로 스토리지에 유 지된다. NMM(C114)의 모듈식 호출에 따라, 초기 구문 분석(C148)은 진행중인 NMM(C114) 인스턴스 내에서 참조할 수 있도록 임시적으로 유지하기 위한 스토리지으로부터 각 관할구역 브랜치를 다운로드한다. 브랜치 니드 계산(C149)으로, 각 지점과 관련된 정의에 따라 니드(needs)는 해당 부서와 연관된다. 상기 방식으로, NMM(C114) 인스턴스 내에서 권한 검사를 구성할 수 있다. 예를 들어, 직원의 능력에 따라 직원 성과를 매년 검 토하는 영역 내에서 요청 되었기 때문에 NMM(C114)는 모든 직원 CV를 다운로드하도록 인사부서에 요청을 승인했 다. 따라서 부서 관할구역의 유효한 필요성(needs)임을 입증되었다. 따라서 니드 인덱스(C145)는 관할구역 브랜 치와 및 각각의 니드의 메인 스토리지이다. 상기 내부 참조는 NMM(C114) 및 제공되는 모든 모듈의 작동에 대한 리소스 병목 현상이기 때문에, 시스템의 전반적인 효율성을 높이기 위해 빠른 데이터베이스 쿼리에 미리 최적화 되어 있다. 9468단계는 입력 목적(C139)를 NMM(C1140의 검색 알고리즘(C144)에 모듈식 입력으로 제공한다. 입력 목적(C139)가 니드 액세스 개발 및 스토리지에 초기에 정의된 관할구역에 따라 유효한 요구를 정의하는지 판별하므로, 검색 알고리즘(C144)는 컴파일된 니드 인덱스(C145)를 참조하고 검색한다. 따라서 니드 인덱스 (C145)를 통해 검색 알고리즘(C144)의 완료된 실행은 NMM(C114)의 모듈식 출력으로 제출되고 니드 결과(C141)로 참조되는 승인/차단(C146) 응답을 생성한다. 따라서 니드 결과(C141)는 명령어 분리 준비 변수로 외부 명 령어 미들웨어(EIM)의 내부 논리로 되돌아간다. 도 869는 명령어 목적 모음을 배포할 수 있는 명령어 스트림으로 변환하기 위한 LIZARD의 작 동에 관한 세부 사항을 도시한다. 명령어 목적 모음은 복합 목적 포맷(C325)으로 존재하며 LIZARD의 외부 코어(OC)(C329) 내에서 목적 모듈(C36)의 반복 확장(C327)에 제출된다. 반복 확장(C327)은 간단한 목표(명 령어 목적 모음내에서 직접 정의됨)를 특정 복합 목적 정의로 발전시키기 위해 세부 사항과 복잡도를 추 가한다. 따라서 입력의 최대 목적 연관성(C326) 가능성은 구문 모듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에 실현되고, 복합 목적 포맷(C325)으로 유지된다. 내부 코어(IC)(C333)의 핵 심 코드(C335) 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토 콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브 러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 870은 명령어 목적 모음을 배포할 수 있는 명령어 스트림으로 변환하기 위한 LIZARD의 작 동을 도시하기 위해 도 869의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM)(C36)로부터 복합 목적 포맷 (C325)으로 수신되고 구문 모듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미 분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수(functions)을 도 출한다. 이는 만약 함수가 더 간단한 상위의 함수로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수의 트리이다. 논리적 미분(Logical Derivation)(C320) 은 내부 코어(IC)(C333)의 핵심 코드(C335) 요소로부터 상속된 규칙 및 구문(C322) 정의에 따라 작동한다. 논리 적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(C35)에서 인 식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 따라 서 PM(C36)은 코드 변환(C321)을 통해 입력 명령어 목적 모음의 결과 버전을 생성하기 위해 SM(C35)를 호 출한다. 이러한 버전의 구문은 타겟 시스템 해석 및 검출(TSID)의 모듈식 출력으로 정의된다. 코드 변환 (C321)에 의해 최종적으로 생성되는 결과 배포할 수 있는 명령어 스트림은 SM(C35), 외부 코어(OC)(C329) 및 LIZARD의 모듈식 출력이다.도 871은 라이브 및 활성 앱체인을 배포할 수 있는 정적 앱체인 보유로 변환하는 정적 앱체인 처리 (SAP)의 작동 및 기능을 도시한다. SAP의 실행은 일반적으로 관리 인터페이스를 통해 UBEC 또는 일반 사용자에 의해 수동으로 호출된다. 9482단계에서, 앱체인(들) UBEC 사용자 /일반 사용자의 정의한 범위는 최종 모듈식 출력 정적 앱체인 보유을 포함해야 하므로, 제안 된 앱체인 모음은 관리 인터페이스에서 생성된다. 9484단계에서, 실행 및 데이터 세그먼트 모음 6902/6904는 제안된 앱체인 모음의 참조로부터 생성된다. 9486단계에서, 제안된 앱체인 모음은 수 정된 캐치 환경(MCE; Modified Catch Environment) 내에서 생성된 실행 스트림 렌더링(ESR) 인스 턴스에 의해 처리된다. 종속성 방법 및 디버깅 정보는 실행 세션으로부터 도출되기 위해 MCE는 다양한 이 벤트에 대한 트리거 포인트를 설치하는 커스텀 실행 환경이다. 그 후, 의존성 요청 이행(DRF; Dependency Request Fulfillment) 모듈이 MCE 인스턴스와 함께 SAP 인스턴스 내에서 호출된다. 9490단 계에서, 실행 또는 데이터 요청은 ESR 인스턴스에 의해 수행된다. 프롬프트는 ESR에 의한 실 행 또는 데이터 요청이 해당 모음 6902/6904에 존재하는지 판별하기 위해 실행 및 데이터 세그먼트 모음을 평가한다. Prompt에 대한 응답이 존재함(Dose Exist)인 경우, 프롬프트이 (ESR의) 해당 실행 또는 데이터 세그먼트가 LIZARD의 니드 매칭 맵(NMM)(C114) 서브모듈에 따라 정 당화되는지 평가하는 것을 호출된다. 프롬프트에 대해 존재하지 않음(Does Not Exist)의 응답은 도 875에서 평가된다. 도 872는 정적 앱체인 처리(SAP) 모듈의 9498단계에 작동 세부 사항을 자세히 설명한다. 제안된 앱체인 모음은 9500단계에 모듈식 입력으로 제출되며, 이는 모음을 나중에 앱체인 참조 캐시 보유 (ARCR)에 저장하는 독립적인 앱체인 참조로 분리한다. 9504단계는 ARCR내의 모든 앱체인 인스턴스를 순환하는 루프를 생성한다. 9508단계는 BCHAIN 프로토콜를 통해 BCHAIN 네트워크의 관련 캐시 노드에서 선택된 앱체인 인스턴스을 검색한다. 따라서 9508단계(도 1236에 자세히 설명됨)는 실행 스트림 모음(ESC)과 데이터 스트림 정렬(DSS)의 호출을 통해 9512단계에서 진행되 는 이행된 앱체인 인스턴스을 생성한다. ESC은 9518단계에 모듈식 입력으로 제출되는 실행 스트림 을 생성하며 또한, DSS은 9518단계에 모듈식 입력으로 제출되는 데이터 스트림을 생성한다. 9518단계는 다양한 실행 및 데이터 스트림을 실행 세그먼트 모음와 데이터 세그먼트 모음 로 수집한다. 9519단계는 9504단계에 의해 시작된 루프를 다음 사용할 수 있는 앱체인 인스턴스으 로 발전시키는 것을 이후에 진행한다. 도 873은 정적 앱체인 처리(SAP) 모듈의 9508단계에 대한 작동 세부 사항을 자세히 설명한다. 9508단계는 BCHAIN 프로토콜 기능 컨텐츠 클레임 생성기(CCG)를 호출한다. 따라서, 제안된 기준선 홉 경로 (PBHP)를 포함하는 콘텐츠 클레임 요청(CCR)이 생성된다. 요청된 앱체인 인스턴스의 일부를 포함하는 해당 캐시 노드에 최종적으로 도달하기 위해 CCR은 BCHAIN 네트워크에 제출된다. 결 과적으로 BCHAIN 프로토콜을 통해 메타체인의 와트 경제를 활용하여 경제적으로 보상받기 때문에 캐 시 노드는 CCR를 충족한다. 캐시 노드는 해당 CCR에 응답하여 해당 컨텐츠 클레임 이 행(CCF) 유닛을 생성한다. 새롭게 생성된 CCF는 SAP 인스턴스를 처리중인 노드의 컨텐 츠 클레임 렌더링(CCR) 모듈에 도달하는 BCHAIN 네트워크를 따라 이동한다. 컨텐츠 디코딩 명령어 는 CCF 응답을 제공하기 위해 참조되며, 따라서 이행된 앱체인 인스턴스를 생성한다. 따라서, 타겟된 앱체인의 실행 및 데이터 세그먼트가 검색되었다. 도 874는 정적 부가 처리(SAP) 인스턴스 내에서 의존성 요청 이행(DRF; Dependency Request Fulfillment) 서브모듈의 논리 흐름을 자세히 설명하며, 따라서 도 871를 재개한다. 프롬프트에 대 한 존재함 응답은 해당 실행 또는 데이터 세그먼트는 NMM(C114)에 따라 정당화됨인지 확인하는 9498단계를 호출한다. 프롬프트에 정당화됨 응답이 발생하면, 9524단계는 표시된 세그먼트 캐시 보 유(MSCR)에 포함될 실행 또는 데이터 세그먼트를 표시하여 호출한다. 프롬프트에 정당화되지 않음 응답에 대한 논리 흐름은 도 875에 도시한다. 9524단계의 결론은 DRF 인스턴스 처리의 결론을 암 시한다. 따라서, 9524단계 이후, 9526단계는 MSCR에서 발견된 해당 표시된 세그먼트를 포함하는 이행된 엡체인 인스턴스과 관련하여 호출된다. 9508단계는 BCHAIN 프로토콜를 통해 관련 캐시 노드에 서 선택된 앱체인 인스턴스를 검색하고, 따라서 도 873에 설명된 것과 같이, 이행된 앱체인 인스턴스 을 생성한다. 도 875는 수정된 캐치 환경(MCE; Modified Catch Environment)의 9486단계과 관련하여 정적 앱체인 처리 (SAP) 인스턴스 내의 의존성 요청 이행(DRF; Dependency Request Fulfillment) 서브모듈의 논리흐름에 대해 자세히 설명한다. 프롬프트에 대한 존재하지 않음 응답 및 프롬프트에 대한 정 당화되지 않음 응답은 모두 5600단계의 활성화로 이어지고, 공식 시스템 토큰이 포함된 진단 로그 유닛(DLU)에 생성 및 제출된다. 상기 토큰은 UBEC 플랫폼 내의 공식 기능인 경우, 해당 기능 또는 프로그램이 비이상적인 상태에 도달했음을 나타내기 위해 포함되어 있다. DLU는 진단 로그 제출 (DLS) 모듈에 제출되며, 이는 DLU를 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)에 공급하기 위해 LOM의 자동화된 리서치 메커니즘(ARM)에 의해 호출된다. 따라서 SPSI은 DLU에서 발견된 진단 정보를 진단 로그 유닛 분석(DLUA) 모듈로 처리할 수 있다. 이는 지정된 응답이 프롬프트 9492 및 9498에 대해 호출된 초기 이유를 피하기 위해 I2GE 그리고/또는 MCE에 해당 수정을 수행하도록 DLUA을 호출하여 나타내는 13005단계로 이어진다. 프롬프트에 대한 정당화됨 응답은 I2GE에서 에뮬레이트된 실행 스트림 렌더링(ESR) 인스턴스에 대해 스레 드 차단 관리(TBM)를 호출한다. 따라서 TBM은 DRF의 원래의 스레드가 처리되는 동안 I2GE 진화 분산 프로세스를 계속할 수 있도록 한다. 이는 운영 효율성을 달성하기 위해 수행된다. 도 876은 LIZARD의 다이나믹 쉘(C198)의 서브모듈로서 동작하는 니드 맵 매칭(NMM)(C114)의 작동 및 기능 을 도시한다. NMM(C114) 인스턴스는 정적 앱체인 처리(SAP)에서 데이터 요청 이행(DRF; Date Request Fulfillment)으로 9528단계의 작동을 처리하기 위해 생성된다. 실행 세그먼트 모음 및 데이터 세그 먼트 모음은 니드 엑세스, 개발 및 스토리지에 제출된다. 따라서, 모음 6902/6904는 하위 카테고리 로 분류되고 일련의 계층적 브랜치 및 레이어로 스토리지에 유지된다. NMM(C114)의 모듈식 호출에 따라, 초기 구문 분석(C148)은 진행중인 NMM(C114) 인스턴스 내에서 참조할 수 있도록 임시적으로 유지하기 위한 스토 리지으로부터 각 관할구역 브랜치를 다운로드한다. NMM(C114)의 모듈식 호출에 따라, 초기 구문 분석 (C148)은 진행중인 NMM(C114) 인스턴스 내에서 참조할 수 있도록 임시적으로 유지하기 위한 스토리지으로 부터 각 관할구역 브랜치를 다운로드한다. 브랜치 니드 계산(C149)으로, 각 지점과 관련된 정의에 따라 니드 (needs)는 해당 부서와 연관된다. 상기 방식으로, NMM(C114) 인스턴스 내에서 권한 검사를 구성할 수 있다. 예 를 들어, 직원의 능력에 따라 직원 성과를 매년 검토하는 영역 내에서 요청 되었기 때문에 NMM(C114)는 모든 직 원 CV를 다운로드하도록 인사부서에 요청을 승인했다. 따라서 부서 관할구역의 유효한 필요성(needs)임을 입증 되었다. 따라서 니드 인덱스(C145)는 관할구역 브랜치와 및 각각의 니드의 메인 스토리지이다. 이 내부 참조는 NMM(C114) 및 제공되는 모든 모듈의 작동에 대한 리소스 병목 현상이기 때문에, 시스템의 전반적인 효율성을 높 이기 위해 빠른 데이터베이스 쿼리에 미리 최적화되어 있다. 9530단계는 입력 목적(C139)를 NMM(C114)의 검색 알고리즘(C144)에 모듈식 입력으로 제공한다. 입력 목적(C139)가 니드 액세스 개발 및 스토리지에 초기에 정의된 관할구역 브랜치에 따라 유효한 요구를 정의하는지 판별하므로, 검색 알고리즘(C144)는 컴파일된 니드 인덱스(C145)를 참조하고 검색한다. 따라서 니드 인덱스(C145)를 통해 검색 알고리즘(C144)의 완료된 실행은 NMM(C114)의 모듈식 출력으로 제출되고 니드 결과(C141)로 참조되는 승인/차단(C146) 응답을 생성한다. 따라서 니드 결과(C141)는 DRF 및 SAP의 9498단계로 되돌아간다. 도 877은 수정된 캐치 환경(MCE; Modified Catch Environment)의 실행 스트림 렌더링(ESR; Execution Stream Rendering) 인스턴스로부터 실행 및 데이터 요청을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 외부 명령어 제안은 외 부 코어(OC)(C329)의 관할구역에 속하는 모듈(SM)(C35)에 제출된다. SM(C35)는 컴퓨터 코드를 읽고 쓰는 프레임 워크를 제공한다. 코드 작성을 위해, 목적 모듈(PM)(C36)로부터 복합 목적 포맷(C325)를 수신한다. 복합 목적 포맷(C325)는 '의사 코드'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 계산 연산의 기본 구현을 포함한다. 그 후 헬퍼(helper) 함수는 원 하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 외 부 명령어 제안은 코드 변환(C321)에 의해 ESR 명령어/명령 구문 형식으로 수신된다. 코드 변환 (C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감 소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식 으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35) 의 모듈식 출력이 목적 모듈(PM)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코 드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷 (C325) 내에서)를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 내부 코어(IC)(C333)은 자동화된 유지 보 수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역 이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스크 립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가 능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 878은 실행 및 데이터 요청을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설 명하기 위해 도 877의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생 성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 출력은 실행 및 데이터 요청의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 879는 정적 앱체인 처리(SAP) 프로세싱의 매크로 측면의 최종 개요를 도시한다. SAP은 관리 인 터페이스를 통해 UBEC 사용자 또는 일반 사용자에 의해 수동으로 호출된다. 9482단계는 제안 된 앱체인 모음을 모듈식 입력으로 수신한다. 9504단계에서, 루프는 앱체인 참조 캐시 보유(ARCR) 의 모든 앱체인 인스턴스를 통해 루프하여 시작한다. 9538단계에서, 이행된 앱체인 인스턴스이 표 시된 세그먼트 캐시 보유(MSCR)에서 검색되어 9540단계로 이어진다. 이행된 앱체인 인스턴스에는 LOM, CTMP 및 LIZARD에 대한 전체 앱체인과 같은 모듈식 종속성을 포함하여 선택한 앱체 인을 실행하도록 필요한 전체 실행 및 데이터 세그먼트 세트가 포함된다. 9540단계는 모든 이행 된 앱체인 인스턴스를 정적 앱체인 보유에 점진적으로 설치하며, 이는 각 송신(outgoing) 실행 또는 데이터 세그먼트는 MSCR에 의해 표시된 상태를 확인한다. 따라서 정적 앱체인 보유는 SAP의 최종 모듈식 출력으로 생성되고, 그 후 앱체인 에뮬레이션 레이어(AED)의 실행 및 데이터 세 그먼트 추출(EDSE) 모듈에 모듈 식 입력으로 제출된다. 신경경제학 형이상학의 만족(Neuroeconomic Metaphysical Contentment, NMC) 도 1000 내지 도1001은 이사회(Board of Directors, BD) 또는 독립 디렉터(Independent Director, ID)에 의해 운영되는 자금(Funds)을 관리하는 기부 구조(ES)를 도시한다. 도 1000은 UBEC 플랫폼 내에서 UBEC 사용자으로 작동하는 등록된 디렉터의 모음으로서 이사회 (BD)를 도시한다. 디렉터의 개인 자금은 메타체인의 와트 경제에 저장된다. 12014단계 에서, 디렉터은 와트 유닛 공약 절차(Watt Unit Pledge Procedure, WUP2)를 통해 ES의 투자 자본(IC) 인스턴스에 자금을 암호화된 방식으로 약속한다. WUP2 내에서 작동하는 암호화 기 능은 암호 코어(Cryptography Core, CC)에 의해 활성화된다. 따라서 이러한 자금의 암호화 과제 기반 하드 웨어는 BCHAIN 노드 내의 UPFA에서 발생하는 동안, 공약 자금(pledged funds)의 가상 할당은 IC에 등록된다. BD의 구조 내에서, BD의 현재 포트폴리오 지분을 나타내므로 지분 추적 보유(Stake Tracking Retention, STR)는 현재 및 과거의 모든 투자에 대한 디지털 기록을 유지한다. STR의 디지털 기록은 비디렉터인 UBEC 사용자에게 공개될 수 있거나 이사회(the Board)의 디렉터를 위해 독점적으로 비공개로 만들 수 있다. 정보 접근과 관련된 이러한 구분은 설정된 정책 보유 (Established Policy Retention, EPR)에 정의되며, 이는 이사회의 투자 특성을 정의하는 변수를 기록한다. 제안 추적 보유(Proposal Tracking Retention, PTR)는 디렉터에 의해 만들어진 제안 의 기록된 원장을 보관한다. PTR에서 추적된 제안은 일반적으로 EPR의 정책 정의에 대한 참조한 다. 이러한 제안은 디렉터 투표 메커니즘(Director Voting Mechanism, DVM)을 통해 디렉터에 의해 의결 된다. 도 1001은 기부 구조(ES; Endowment Structure) 내에서 작동하는 독립 디렉터(ID)를 도시한다. ID의 기능 범위는 EPR에서 정책을 조작하는 단독 독점적인 디렉터가 있다는 것을 제외하고 BD과 동일하고, PTR에서 디렉터 투표 메커니즘(DVM)을 통해 제안에 대해 제출하고 투표한 다.도 1002 내지 도1008은 암호화 디지털 경제 익스체인지(CDEE; Cryptographic Digital Economic Exchange) 및 그 종속성 모듈(LUIGI)에 관한 세부 사항을 도시한다. 도 1002는 CDEE의 보안 감독 기능을 도시한다. NMC의 핵심 모듈은 종합 상태 평가(CSE; Comprehensive State Evaluation)이다. CSE의 동작은 CDEE의 12024단계를 작동시킨다. 12024단계는 자금 이동 감시(FMO; Fund Movement Oversight)을 통해 실행되고, 앱 퍼블릭 자금 할당(APFA; App Public Funds Allocation) 인스턴스로 이동하는 펀드의 모니터링 및 규제를 포함한다. APFA 인스턴스는 관련 ES에 의해 투자를 위해 선택된 지정된 UBEC 앱에 속한다. APFA에 보유된 자금에 대한 암호화 액세 스는 BCHAIN 노드를 통해 유지된다. 이러한 노드는 관련 UBEC 앱의 관리자(maintainers)에 속한다. ES의 BD 및 ID은 LUIGI의 자금 회복 메커니즘(FRM; Funder Recovery Mechanism)에 접근할 수 있다. APFA 인스턴스의 최종 잔액 및 앱 이익 분배(APD; App Profit Distribution)의 수익 정보는 디지털 익스체인지 상태 보고(DSR; Digital Exchange Status Reporting)로 전달된다. 이러한 전달된 정보는 DESR에 의해 처리되고 CSE으로 전송된다. 따라서 CSE은 이 가장 최적의 투자 결정을 지능적으로 계산하도록 CSE으로 유도하여 더 많은 재 무 정보에 접근한다. BD 또는 ID이 UBEC 앱에 투자 할 때, 그들의 식별은 UBEC 앱의 앱 투자 등 록부(AIR; App Investment Registrar)에 기록된다. 이는 APD의 정확한 분배를 가능하게 한다. 도 1003은 UBEC 플랫폼 내에서 앱체인으로 작동하는 LUIGI를 도시한다. LUIGI은 CDEE 내의 자금 이동 감시(FMO) 및 자금 회복 메커니즘(FRM) 모듈에 의해 호출된다. LUIGI의 이러한 호출은 와트 유닛 무브먼트를 규제하고 CDEE 내의 와트 유닛 할당 안전의 보장을 제 공한다. UBEC 패스스루(UBEC Passthrough)은 UBEC 플랫폼 내에서 작동하는 앱체인으로부터 데 이터 전송 정보를 수신한다. 따라서 CDEE 내의 트래픽(traffic) 및 엑티비티(activity)은 본질적으로 UBEC 패스스루 훅과 연결된다. LUIGI 작업 위임(LTD; LUIGI Task Delegation)은 UBEC 패스스루로부 터의 수신 데이터가 LIZARD, LOM 또는 둘 다에 의해 처리되어야 하는지 결정한다. LIZARD의 앱 체인을 호출은 '관할 집행 및 인텐션 리더(Jurisdictional Enforcement and Intention Reader)' 처 리 모드가 선택되었음을 나타낸다. LOM 앱체인을 호출은 '지식 문의 및 사법 중재(Knowledge Enquiries and Judicial Arbitration)' 처리 모드가 선택되었음을 나타낸다. 그 후, 논리 흐름은 다이나 믹 API 커스터마이징(DAC; Dynamic API Customization)로 계속된다. DAC의 기능은 작업 유형(Task type) 372/376을 해석하고 선택한 API의 인터페이스를 선택한 작업 유형 372/376으로 커스터마이징하는 것이다. 지능형 결론 통합(ICU, Intelligent Conclusion Unification)에 전송되는 분석 결과를 생성하므로, 해당 알고리즘 LOM 및 LIZARD은 그들이 호출될 때 실행된다. ICU는 두 모듈이 병렬로 호출되었다고 가정할 때, LOM와 LIZARD 사이의 해석적/주관적 결론을 조정한다. 도 1004는 NMC 및 구체적으로 종합 상태 평가(CSE) 모듈과 관련하여 LUIGI의 작동 및 어플 리케이션을 계속 도시한다. 12026단계에서 나타낸 것과 같이, CSE 출력 이상적인 투자 결정 메이크업 (Ideal Investment Decision Makeup)은 UBEC 패스 스루를 통해 수신된다. LUIGI은 메이크업 가 수많은 하위 요소 투자 할당(Investment Allocations), 투자 인출(Investment Withdrawals), 이익 배분(Profit Allocations) 및 디렉터 통보(director notification)(1259 8)의 컨테이너(Container) 역할을 하는 것을 인지한다. 그 후 12028단계에서, LUIGI 작업 위임 (LTD) 모듈은 적절한 LUIGI 분석의 브랜치, 지식 문의 및 사법 중재(LOM) 및 관할 집행 및 인텐션 리더(Jurisdictional Enforcement and Intention Reader) (LIZARD)에 의해 분석되도록 해 당 데이터 출력 메이크업을 위임하도록 호출된다. 도 1005는 (앱체인으로서) LUIGI와 상호 작용하여 기능을 가능하게 하는 다양한 앱 체인을 도시한다. UBEC 플랫폼은 UBEC 앱체인과 함께 앱체인9836)으로 표시되며, 이는 LUIGI에 모듈식 데이터 입 력을 제공하기 위해 UBEC 패스 스루에 연결된다. LUIGI의 처리 결론에 따라, UBEC 포괄 리턴(UBEC Comprehensive Return)은 원래 논리 흐름을 계속 유지할 수 있도록 데이터를 UBEC 앱체인으로 다시 보낸다. LOM는 지식 문의 및 사법 중재 브랜치 내에서 처리할 수 있도록 코어 앱체인 역할을 한 다. 또한, LOM 및 LIZARD은 API 사용자 지정 정보를 다이나믹 API 커스터마이징(DAC; Dynamic API Customization)에 제공한다. 따라서 DAC는 (어떤 앱체인 132/120이 호출되는지에 따라) 필요에 따라 논리 프로세스의 관련 사용자 지정을 수행하기 위해 적절한 API 정보에 접근한다. 셀프 프로그래밍 셀프 혁신 (SPSI; Self Programming Self Innovation)은 LUIGI의 구성과 작동을 주기적, 지속적으로 감시, 유 지 및 업그레이드한다.도 1006은 관할 집행 및 인텐션 리더(Jurisdictional Enforcement and Intention Reader) 브랜치를 포함 하는 인터페이스와 관련하여 다이나믹 API 커스터마이징(DAC; Dynamic API Customization) 모듈에 관한 작동 세부 사항을 자세히 설명한다. 선택된 브랜치는 LIZARD를 호출하기 때문에, LIZARD 사용 API(LIZARD Usage API)는 DAC의 작동 내에 제공된다. LUIGI 작업 위임(LTD; LUIGI Task Delegation)은 작업 수신에 정의된 작업 유형을 결정한다. 따라서, 작업 유형은 DAC 내에서 408단계의 '작업 유형 해석'으로 전달된다. 따라서 제공된 작업 유형은 DAC 내에서 406단계에 대한 사용자 지정 범위를 나타낸다. 이는 선택된 브랜치에 제공되는 모듈식 명령어 세트를 생성한다. 모듈식 명령 어 세트는 LIZARD 사용 API에 따라 프로그래밍되며, 모듈식 입력으로서 LIZARD 입력에 전송된다. 따라서, 입력은 작업 데이터 세트를 갖는 작업에 관한 데이터 및 모듈식 명령어 세트(41 6)를 갖는 작업을 처리하기 위한 명령어를 수신한다. 이는 2개의 입력 412/416을 충족시키기 위해 LIZARD 의 실제 모듈식 실행으로 이어진다. LIZARD 인스턴스의 성공적이고 완전한 실행은 LIZARD 출력 을 생성한다. 출력은 인텔리전트 결론 통합(ICU; Intelligent Conclusion Unification) 모듈로 전달된다. ICU는 브랜치 372/376의 단일 통합 출력을 보장하도록 다른 모듈 실행 418/423 (LOM/LIZARD)의 여러 출력을 조정한다. 이것은 LUIGI 시정 조치(LCA; LUIGI Corrective Action)의 단순화된 입력 수신을 위해 허용한다. 도 1007은 지식 문의 및 사법 중재(Knowledge Inquiries and Judicial Arbitration) 브랜치를 포함하는 인터페이스와 관련하여 다이나믹 API 커스터마이징(DAC; Dynamic API Customization) 모듈에 관한 작동 세부 사항을 자세히 설명한다. 선택된 브랜치는 LOM를 호출하기 때문에, LOM 사용 API는 DAC의 작동 내에서 제공된다. LTD은 작업 수신에 정의된 과제 유형을 결정하고, 따라서 브랜치 에 대한 도 1006와 동일한 논리를 작동한다. 작업 유형은 DAC 내에서 408단계의 '작업 유형 해석'으 로 전달된다. 이는 선택된 브랜치에 제공되는 모듈식 명령어 세트를 생성한다. 모듈식 명령어 세트 은 LOM 사용 API에 따라 프로그래밍되며, 따라서 LOM 입력에 모듈식 입력으로 전송된다. 따라서 입력는 작업 데이터 세트를 갖는 작업과 모듈식 명령어 세트를 갖는 작업을 처리하기 위한 명령 어를 수신한다. 이는 2개의 입력 412/416을 충족시키기 위해 LOM의 실제 모듈식 실행으로 이어진다. LOM 인스턴스의 성공적이고 완전한 실행은 LOM 출력을 생성한다. 출력은 인텔리전트 결론 통합으로 전달되며, 이는 브랜치 372/376의 단일 통합 출력을 보장하도록 다른 모듈 실행 418/423 (LOM/LIZARD)의 여러 출력을 조정한다. 이는 LCA의 단순화된 입력 수신을 위해 허용한다. 모듈 식 실행 418과 423이 LTD에 의해 호출되는지 상기 단순화된 입력 수신이 필요하다. 도 1008은 금융 유동성 조작에서 LUIGI에게 독점적으로 속하는 화폐 유동성 조작 기능을 도시한다. LUIGI 보안 안클레이브(LSE; LUIGI Secure Enclave)는 오직 LUIGI만 액세스할 수 있는 정보 보유의 안전한 영역이다. 따라서 LUIGI의 코드를 작성할 수 있는 권한은 독점적으로 셀프 프로그래밍 셀프 혁신 (SPSI; Self Programming Self Innovation)에 속하고 LUIGI의 코드를 실행할 수 있는 권한은 독점적 으로 LUIGI에 속하기 때문에, LSE의 컨텐츠를 이론적으로 관찰할 수 있는 인간 관찰자는 없다. LSE 내부에는 이 개인 키의 암호화된 보유(Encrypted Retention)를 해독할 수 있는 LUIGI을 허 용하는 보유 암호 해독 키(Retention Decryption Key)가 있다. 이는 자금 조작 메커니즘(FMM; Fund Manipulation Mechanism)이 자금 회복 세션에서 메타체인의 와트 경제에 대해 자금을 조작할 수 있도록 한다. 와트 유동성 거버너(WLG; Watt Liquidity Governor)은 UBEC에서 들어오고 나가는 유동성 움직임의 과도한 급등을 모니터링하고 잠재적으로 차단할 수 있는 LUIGI의 서브세트 모듈이다. 이 는 UBEC 내에서 점진적이고 예측 가능한 경제를 보장한다. 자금 이동 감시(FMO)는 사기와 관련된 유 동성의 움직임을 모니터링하고 잠재적으로 차단하는 LUIGI의 서브세트 모듈이다. 자금 회복 메커니즘 (FRM)은 LUIGI의 서브세트 모듈로, -U- (Watt Unit) 자금의 정당한 소유자가 분실, 도난 또는 잘못 취급되었는지 메타체인의 와트 경제로부터 청구할 수 있다. Proof of Authority는 LSE 로 지스틱(logistics) 때문에 LUIGI에 의해 오직 암호적으로 생산가능성이 보장되는 고유의 암호화키이다. 그 러므로, Proof of Authority는 도 362 및 도 3623에 설명된 바와 같이, 민감한 고유 개인키(Security Sensitive Unique Private Key)를 공급하기 위해 UBMA 칩을 호출하여 사용한다. 도 1009 내지 도1011은 디렉터 투표 메커니즘(DVM; Director Voting Mechanism)의 기능과 사용을 도시 한다. 도 1009는 제안 투표 인터페이스(PVI; Proposal Voting Interface)를 통해 DVM과 상호 작용하는 이사회(BD)와 독립 디렉터(ID)의 디렉터 12006/12022를 도시한다. 12034단계에서, 승인된 제안(Authorized Proposal)은 디렉터 12006/12022에 의해 제출된다. 잠재적 승인된 제안의 다양한 유형은 디렉터 12006/12022에 의해 만들 수 있다. 독립 디렉터(ID; Independent Director)로, 유일한 단독 디렉터(sole Director)이고 합의 딜레마가 없기(no consensus dilemma) 때문에, 제안은 기 부 구조(ES) 내에서 명령으로 효과적으로 처리된다. 신규 디렉터 진입(New Director Admission)(1203 8)은 이사회가 신규 디렉터를 수용할 수 있는 가능성을 수반한다. 따라서 현재 현존하는 디렉터 는 신규 가능성 디렉터의 승인 여부를 의결한다. 상기 제안은 오직 BD에만 적용 가능하며 ID에는 적용되지 않는다. 신규 디렉터 진입의 적용 가능성(applicability)은 확립된 정 책 보존(EPR; Established Policy Retention)에 정의된 정책에 따라 달라진다. 따라서 이사회은 EPR의 정책 정의에 따른 새로운 디렉터 진입을 통해 합의된 검증(consensus verification) 여부 에 상관없이 신규 디렉터을 수용할 수 있다. 지분(Stake)을 갖는 디렉터 탈퇴(Director Withdrawal)는 이사회의 회원(membership)을 사임하는 동시에 디렉터에서 투자 자본 (IC)에서 그들의 투자 지분을 즉시 회수한다. 이사회은 EPR의 정책 시행을 통해 디렉터 가 전체 투자를 즉시 철회하는 것을 방지할 수 있다. 이는 투자 프로젝트에 대한 약속을 보장하고, 선택 되는 경우 디렉터들 사이의 신뢰 관계를 개선한다. 정책 규칙 추가는 EPR에서 유지되고 참조되는 새로운 정책에 대한 이사회의 잠재적 승인을 수반한다. 이러한 정책은 이사회 기능의 전반적인 행동과 이에 따른 종합 상태 평가(CSE; Comprehensive State Evaluation)에 의한 투자 할당 를 관리한다. 이러한 정책은 해당 정책 규칙 삭제 제안을 통해 삭제될 수 있다. 따라서 EPR의 기존 정책을 수정하기 위해 디렉터 12006/12022에 의해 시작된 조치는 정책 규칙 추가 이 벤트 직전에 발생하는 정책 규칙 삭제로 이어질 것이다. 따라서 기존 정책을 수정하기 위해 DVM 을 통해 디렉터이 수행한 투표는 단일 유닛으로 취급되는 제안, 정책 규칙 추가 및 정책 규칙 삭제의 결합 쌍에 대한 유효 투표이다. 수동 오버라이드 측정 추가은 CSE에 의해 생 성된 이상적인 투자 결정 메이크업에 영향을 미치는 오버라이드 측정 유지(OMR; Override Measure Retention)에 새로운 사용자 지정 규칙을 도입한다. 이러한 오버라이드 측정는 해당 투자 메이크 업와 관련하여 특정 BD 또는 ID을 고유하게 만드는 사용자 지정 특성을 정의한다. OMR에서 오버라이드 측정값이 정의되지 않은 ES은 CSE에서 유사한 이상적인 투자 결정 메 이크업을 받는다. 두 기부 구조(ES)이 정확히 동일한 시간에 생성되는 경우, (정의된 측정값을 포함할 수 없는) 동일한 OMR를 포함하는 두 구조로, 이론적으로 CSE에서 정확히 동일한 이상적인 투자 결정 구성를 받을 것이다. 승인된 제안 단계는 디렉터 12006/12022에 의해 12034단계에서 제출될 때, 120050단계는 제안 준수 절차(PCP; Proposal Compliance Procedure)를 통해 제안 준수를 해석하여 호출한다. 12050단계를 통해 PCP의 실행은 신규 승인된 제안서가 PTR의 과거 제안 및 EPR의 사전 설정된 정책과 양립할 수 있도록 한다. 규정준수에 잠재적 충돌의 예는 디렉터에 의 해 제출된 지분(Stake) 제안을 포함하는 디렉터 인출이고,. 관련 BD의 EPR는 그 러한 제안 12044/12036이 투자 자본(IC) 인스턴스에서 즉시 전체 투자 지분을 인출하도록 디렉터(1200 6)에 대해 의무화되거나 적용되지 않는다고 정의하고 있다. 비준수 제안(non-complaint Proposal)의 다 른 예는 EPR에 존재하지 않는 정책을 참조하는 정책 규칙 삭제 제안이다. 비준수 제안 의 추가 예는 OMR에 없는 오버라이드 측정을 참조하는 수동 오버라이드 측정 삭제 제안 이다. 도 1010은 예, 준수함(Yes, in Compliance) 시나리오를 포함하는 12050단계의 논리적 결론을 도시한다. PCP이 잠재적 승인된 제안이 과거 제안 및 사전 설정된 정책에 부합한다고 판단될 경우, 제안 은 제안 투표 인터페이스(PVI; Proposal Voting Interface)에 제출된다. PVI으로, 디렉 터은 잠재적 승인된 제안에 찬성 또는 반대할 수 있다. 제안에 대한 투표 인디케이트 승 인은 수동 오버라이드 측정 추가 또는 수동 오버라이드 측정 삭제인 경우, 제안은 12060단계를 통해 수동 오버라이드 측정 조작(MOM2; Manual Override Measure Manipulation)으로 전달 된다. 이는 오버라이드 측정 보유(OMR)에 명시되도록 수동 오버라이드 측정 변경 12040/12046에 관한 제 안으로 이어진다. 도 1011은 도 1010에서 강조된 예, 준수함(Yes, in Compliance) 및 준수하지 않음(No, Not in Compliance) 시나리오의 논리흐름을 도시한다. 시나리오가 발생하면, 12078단계가 실행되고, 이 단계는 제안 제출을 거부하고 PVI을 통해 (제안을 제출한) 디렉터에게 준수 제안 을 제출하기 위해 필요한 요구사항(requirements)을 알려준다. 이러한 요구사항은 거부된 특정 제안과 관련하여 사용자 정의할 수 있다. 상기 방식으로, 제출한 디렉터는 제안가 거부된 제안을정확한 측면을 인지하게 되고, 정확한 수정은 제안에 이를 준수하게 만들기 위해 요구된다. 또한, 도 1011에 대해 도시된 것은 PCP가 제안 추적 유지(PTR; Proposal Tracking Retention)에 요청을 하고 요청을 수신하는 방법이다. 과거의 제안은 PTR에 기록되며, 이는 PCP가 12034단계에서 현재 제안 제출의 준수를 결정할 수 있다. 독립 디렉터(ID; Independent Director)의 디렉터 는 이사회(BD)의 디렉터과 마찬가지로 제안 투표 인터페이스(PVI)에 접근할 수 없다. 이 는 디렉터에 의해 제정된 모든 조치가 잠재적으로 상충되는 이상(ideals)을 가진 여러 디렉터들 간에 합의에 도달할 필요가 없기 때문에 기부 구조((ES) 내에서 즉시 수용되고 시행되기 때문이다. 도 1012 내지 도 1014는 예비 스레드 개시(PTI; Preliminary Thread Initiation)의 기능과 사용을 도시 하며, 이는 종합 상대 평가(CSE; Comprehensive State Evaluation)의 적절한 실행을 준비하기 위한 시 작 시퀀스 역할을 한다. 도 1012는 12082단계에서 예비 스레드 개시(PTI; Preliminary Thread Initiation)의 초기 작동을 도시 한다. 12082단계에서, CSE 호출 간격은 선택된 이사회(BD) 또는 독립 디렉터(ID)의 확립 된 정책 보유(EPR)로부터 검색된다. 간격는 CSE 인스턴스를 생성하기 위해 관련 기부 구 조(ES)가 의도하는 빈도를 정의한다. 더 많은 와트 유닛은 시장과 기업 데이터에 더 최신의 이상적인 투 자 의사 결정의 렌더링을 달성하기 위해 CSE 인스턴스의 더 많은 반복을 호스팅하도록 BCHAIN 수 수료에 사용한다. 그 후 12086단계에서, CSE 최종 호출의 시간이 EPR에 정의된 값의 스토리지로 부터 검색된다. CSE 최종 호출 값은 지정된 BD 또는 ID 인스턴스와 관련된 특정 변수이다. 그 후, 12090단계는 현재 시간과 마지막 호출 사이의 시간이 호출 간격보다 큰지 확인 하여 실행된다. 계산된 시간 차이가 호출 간격보다 더 큼(Greater Than)이면, CSE는 12094단계로부터 호출된다. 계산된 시차가 호출 간격보다 더 적음(Lesser Than)이면, CSE는 12098단계로에 따라 호출되지 않는다. 12094단계의 작동은 타겟 투자 상황 해석(TICI; Target Investment Circumstances Interpretation)의 실행으로 이어진다. TICI 및 CSE의 작동은 12100단계의 이행을 의미하며, 이는 관련 투자자본(IC) 인스턴스에서 TICI 및 CSE 인스 턴스를 호스트하는 BCHAIN 노드으로 유동성이 이전되는 것을 설명한다. 따라서 기부 구조(ES)은 BCHAIN 네트워크를 통해 BCHAIN 수수료를 관련 BCHAIN 노드에 지불하면서 CSE이 수행한 지능 형 투자 분석의 서비스를 효과적으로 임대한다. TICI의 실행은 타겟 투자 상황을 생성하며, 이는 CSE에 의해 시장과 사업의 현재 상황을 정확하게 반영하는 정확한 이상적인 투자 의사 메이크업 를 생산하여 해석된다. TICI 결과 캐시는 타겟 투자 정황의 압축된 클론이며, 이는 향후의 단계 에서는 자동 오버라이더 측정 조작(AOM2; Automated Override Measure Manipulation)에 의해 잠재적으 로 참조될 수 있다. 캐시는 TICI의 개별 인스턴스를 호출하는 것을 방지하도록 생산 및 제작되며, 이는 동일한 결과를 도출하는 동시에 더 많은 계산 자원(resources)을 필요로 할 것이다. 도 1013은 12100단계으로부터 재개되는 예비 스레드 개시(PTI; Preliminary Threat Initiation)에 관한 추가의 동작 논리를 도시한다. 12100단계에 따라, 대응하는 투자 자본(IC)로부터 관련 BCHAIN 노드(78 6)의 성공적인 자금에 대해, 12102단계는 자동 오버라이더 측정 조작(AOM2; Automated Override Measure Manipulation)이 관련 기부 구조(ES)의 해당 EPR에서 호출을 위해 플래그되어 평가하여 호출된다. 특정 타겟 마인드(specified Target Mind)가 CSE에 의해 수행된 투자 결정을 안내하 기 위한 의도라면, 기부 구조(ES)는 AOM2을 활성화하는 것을 선택할 수 있다. EPR은 AOM2의 작동이 비활성화(disabled)되었음을 나태내는 경우, 12110단계는 PTI의 모듈식 실행을 나타내여 실행되고, 따라서 TICI 결과 캐시는 시스템의 효율을 높이기 위해 안전하게 삭제될 수 있다. EPR는 AOM2의 작동이 활성화되어 있음을 나타내는 경우, 12108단계가 EPR의 정의 된 AOM2 호출 간격를 검색하여 실행한다. 그 후 12116단계에서, 예비 스레드 개시(PTI) 인스턴스 를 호출한 해당 BD 또는 ID는 AOM2 마지막 호출의 시간을 검색한다. 후속 동작은 현재 시 간과 AOM2 마지막 호출 사이의 계산된 시간 차이가 AOM2 호출 간격보다 큰지 확인하는 12120단계 를 시행한다. 계산된 시간 차이는 AOM2 호출 간격보다 더 적음(Lesser Than)인 경우, 12132단계 는 TICI 결과 캐시를 삭제하고 AOM2 호출의 부족을 암시한다. 계산된 시간 차이가 AOM2 호출 간 격보다 더 큼(Greater Than)인 경우, AOM2 타겟 마인드 아이덴티티(AOM2 Target Mind Identity)는 12126단계에서 AOM2의 호출로 이어지는 12124단계에서 검색한다. 그 후 12128단계 에서, BCHAIN 네트워크상의 AOM2을 호스트(host)/운영(run)/실행(execute)하기 위한 자금은 해당 투자 자본(IC)으로부터 AOM2 인스턴스를 호스팅하는 관련 BCHAIN 노드로 인출된다.도 1014는 12124단계에서 시작하여, 도 1013에서 이전에 설명된 논리에 관한 추가 세부 사항을 도시한다. 12124 단계는 설정된 정책 보유(EPR; Established Policy Retention)로부터 AOM2 타겟 마인드 아이덴티티 를 검색하고, 자동화된 오버라이드 측정 조작(AOM2)에 제출한다. 그 후, 12124단계는 AOM2 자체 의 호출을 수반하는 12126단계로 이어진다. 12126 단계에서, AOM2의 호출은 AOM2의 실행을 용이 하게 하기 위해 12128단계에서 BCHAIN 수수료의 이전으로 이끄는 것이다. 디지털 마인드 추적(DMT; Digital Mind Tracking)은 AOM2 타겟 마인드 아이덴티티과 연관된 타겟 마인드를 에뮬레이트할 수 있다. TICI 결과 캐시는 타겟 투자 상황 해석(TICI; Target Investment Circumstances Interpretation)에서 생성되며 타겟 마인드에서 고려해야 하는 관련 타겟 투자 정황(Target Investment Circumstances)을 제공하는 AOM2에 모듈식 입력으로 전송된다. 따라서 AOM2 의 이행된 실행은 오버라이더 측정 보유(OMR; Override Measure Retention)에서 AOM2에 의해 수 행된 수정으로 이어진다. 이러한 수정은 OMR에 존재하는 기존의 재정의 조치의 판독을 필요로 하며, 따 라서 양방향성의 화살표(bidirectional arrow)는 AOM2과 관련 BD 12018 또는 12020의 OMR 사이 에 표시된다. 도 1015 내지 도 1026은 자동 오버라이더 측정 조작(AOM2; Automated Override Measure Manipulation) 의 기능과 작동을 도시한다. AOM2은 타겟 마인드의 반동 기준을 에뮬레이트하며, 이는 관련 기부 구조(ES)의 오버라이드 측정 보유(OMR)에서 제정된 조치를 제정, 수정 또는 제거하기 위해 AOM2 타겟 마인드 아이덴티티를 통해 확인되었다. AOM2의 작동의 실질적인 효과는 관련 ES이 AOM2 타겟 마인드 아이덴티티에서 확인한 바와 같이 타겟 마인드의 반응 및 경향에 도움이 되는 OMR를 포함한다는 것이다. OMR의 결과 메이크업은 타겟 투자 상황 해석(TICI)에 의해 생 성된 타겟 투자 정황 및 CSE에 의해 생성된 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)에 영향을 미친다. 도 1015는 TICI의 TICI 결과 캐시를 수신하는 12152단계로부터 시작하는 AOM2의 초기 작 동을 도시한다. 그 후 TICI 결과 캐시는 TICI에 의해 원래 처리된 타겟 투자 정황을 생성 하도록 12150단계에서 압축 해제되고 추출된다. 그 후, 12148단계는 포트폴리오 지분 보유(PSR; Portfolio Stake Retention)에서 현재 지분 포지션을 검색하여 진행된다. 현재 지분 포지션은 ES가 현재 관여하고 있는 다양한 액티브 투자(active investments)를 나타낸다. 그 후, 12142단계가 OMR의 현재의 액티브 오버라이드 측정을 모두 검색하고 액티브 오버라이드 측정으로 생성하여 처 리된다. 그 후, 12154단계가 이전에 처리된 모든 변수 액티브 오버라이드 측정(Active Override Measures), 현재 지분 포지션(Current Stake Position), 타겟 투자 정황(Target Investment Circumstances), and AOM2 타겟 마인드 아이덴티티(AOM2 Target Mind Identity)를 축적하여 (accumulates) 처리한다. 축적(accumulation)에 따라, 전술한 변수는 디지털 마인드 추적(DMT; Digital Mind Tracking)의 인스턴스를 적절하게 호출하기 위해 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)에 공급된다. 도 1016은 12154단계의 AOM2의 논리 흐름을 계속한다. 후속 12164단계는 우선 오버라이드 측정를 생성하는 MERM 및 DMT의 동작을 강조한다. 12154단계는 DMT으로 다시 전송되는 마인드 에뮬레이션 요청(Mind Emulation Request)을 생성하는 MERM를 호출한다.DMT는 AOM2 타겟 마인드 아이덴티티(AOM2 Target Mind Identity)으로 표시되는 타겟 마인드를 에뮬레이트하는 CTMP 기술을 사용하고, 따라서 특정 타겟 마인드와 연관된 마인드 인식 결과(Mind Perception Result)를 생성한다. 마인드 인식 결과는 원래 DMT이 호출된 MERM로 다시 전송된 다. 따라서 MERM는 최종 결과 선호되는 오버라이드 측정(final result Preferred Override Measures)를 정확하게 생성하기 위해 필요에 따라 DMT의 여러 인스턴스를 호출한다. 선호되는 오 버라이드 측정(Preferred Override Measures)은 특정 타겟 마인드에 의해 선택되고 따라서 선호 되는 것을 예상하는 오버라이드 측정을 나타낸다. 따라서 선호되는 오버라이드 측정의 생산에 따라, 12164단계는 완료되고, 12166단계는 12166단계는 이후 처리된다. 12166단계는 선호되는 오버라이드 측정(1216 2)을 목적 계층 맵으로 변환하기 위해 LIZARD을 호출한다. 그 후, LIZARD은 또한 1272단계에 서 엑티브 오버라이드 측정(Active Override Measures)을 목적 계층 맵(Purpose Hierarchy Map)(1217 4)으로 전환하기 위해 호출된다. 도 1017은 선호되는 오버라이드 측정(Preferred Override Measures)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 동작에 작동에 관한 세부 사항을 도시한다. 선호되는 오버라이드측정(Preferred Override Measures)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모 듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능 성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 측정는 코드 변환(C321) 에 의해 오버라이드 측정 구문(Override Measure Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코 드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function) 도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한 다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출 력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목 적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프 로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리 (Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1018은도 선호되는 오버라이드 측정(Preferred Override Measures)을 목적 계층 맵으로 변환 하기 위한 LIZARD의 작동을 설명하기 위해 도 1017의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소(C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C32 6)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329), 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325) 이 존재한다. 출력은 선호되는 오버라이드 측정의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1019는 액티브 오버라이드 측정(Active Override Measures)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 액티브 오버라이드 측정 (Active Override Measures)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능 성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 측정는 코드 변환(C321) 에 의해 오버라이드 측정 구문(Override Measure Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코 드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function) 도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한 다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목 적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프 로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리 (Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1020은 액티브 오버라이드 측정(Active Override Measures)을 목적 계층 맵으로 변환하기 위 한 LIZARD의 작동을 설명하기 위해 도 1019의 논리 흐름을 계속한다. 구문 모듈(SM)(C35)의 논리 감소 (C323)은 목적 모듈(PM)(C36)의 반복 해석(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외 부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(C325)이 존재한다. 출력은 액티브 오버라이드 측정의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분 류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1021은 도 1016의 논리 흐름을 계속한다. 액티브 오버라이드 측정(the Active Override Measures)의 목적 계층 맵은 맵을 원래의 앱체인 보유(Original Appchain Retention)으로 참조되는 앱체인 구문으로 변환하기 위해 LIZARD을 호출하여 12180단계로 제출된다. 선호되는 오버라이드 측 정(Preferred Override Measures)의 목적 계층 맵은 맵을 업그레이드된 앱체인 보유 (Upgraded Appchain Retention)로 참조되는 앱체인 구문으로 변환하기 위해 LIZARD을 호출 하여 12186단계로 제출된다. 12190단계는 앱체인 정정 패치을 만들 수 있도록 배포 패치 어셈블리(DPA; Deployment Patch Assembly)를 호출할 수 있기 때문에 목적 계층 맵 12174 및 12168은 앱체인 구문 으로 변환한다. 이러한 패치는 AOM2을 통해 에뮬레이션된 타겟 마인드에 의해 제안 된 액티브(원래) 오버라이드 측정(Active (original) Override Measures)과 신규 선호되는 오버라이드 측정의 실질적으로 관련이 있는 앱체인 보유 모두 사이의 차이점을 포함하고 있다. 도 1022는 액티브 오버라이드 측정(Active Override Measures)의 목적 계층 맵을 앱체인 구문 (Appchain Syntax)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 맵는 복합 목 적 포맷(C325)으로 존재하며 LIZARD의 OC(Outer Core)(C329) 내에서 목적 모듈(C36)의 반복 확장(C327)에 제출된다. 반복 확장(C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 맵에 정의됨) 세부 사항과 복잡도를 추가한다. 따라서 입력의 최대 목적 연관성(C326) 가능성은 구문 모듈(SM)(C35) 의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에 실현되고, 복합 목적 포맷(C325)으로 유지된다. 내 부 코어(IC)(C333)의 핵심 코드(C335) 요소는 기본 프레임워크 및 라이브러리, 스레드 관리 및 로드 밸런싱 스 크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능 을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1023은 액티브 오버라이드 측정(Active Override Measures)를 원래 앱체인 보유(Original Appchain Retention)로 참조되는 앱체인 구문(Appchain Syntax)으로 변환하기 위한 LIZARD의 작동을 설명하 기 위해 도 1022의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM)(C36)에서 복합 목적 포맷(C325)으로 수 신되고 구문 모듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수(functions)을 도출한다. 이 는 만약 함수가 더 간단한 상위의 함수로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경 우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수의 트리이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC)(C333)의 핵심 코드(C335) 요소로부터 상속된 규칙 및 구문(C322) 정의에 따라 작동한다. 논리적 미분 (Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 따라서 PM(C36)은 코드 변환(C321)을 통해 입력 액티브 오버라이드 측정의 결과 앱체인 구문 버전을 생 성하기 위해 SM(C35)를 호출한다. 코드 변환(C321)에 의해 최종적으로 생성되는 결과 원래 앱체인 보유 (Original Appchain Retention)는 SM(C35), 외부 코어(OC)(C329) 및 LIZARD의 모듈식 출력이다. 도 1024는 선호되는 오버라이드 측정(Preferred Override Measures)의 목적 계층 맵을 앱체인 구문으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 맵은 복합 목적 포맷(C325) 으로 존재하며 LIZARD의 OC(Outer Core)(C329) 내에서 목적 모듈(C36)의 반복 확장(C327)에 제출된다. 반 복 확장(C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 맵에 정의됨) 세부 사항과 복잡도를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 가능성은 복합 목 적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC)(C333)의 핵심 코드(C335) 요소는 기본 프레임워크 및 라 이브러리, 스레드 관리 및 로드 밸런싱 스크립트, 통신 및 암호화 프로토콜 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수 로 작동한다. 도 1025는 선호되는 오버라이드 측정(Preferred Override Measures)을 업그레이드된 앱체인 보유 (Upgraded Appchain Retention)로 참조되는 앱체인 구문(Appchain Syntax)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1024의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM)(C36)에서 복합 목적 포맷(C325)으로 수신되고 구문 모듈(SM)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된 다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수 (functions)를 도출한다. 이는 만약 함수가 더 간단한 상위의 함수로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수의 트리이다. 논리적 미분 (Logical Derivation)(C320)은 내부 코어(IC)(C333)의 핵심 코드(C335) 요소로부터 상속된 규칙 및 구문(C322) 정의에 따라 작동한다. 논리적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변 환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수 (inverse function)도 수행한다. 따라서 PM(C36)은 코드 변환(C321)을 통해 입력 선호되는 오버라이드 측정 의 결과 앱체인 구문 버전을 생성하기 위해 SM(C35)를 호출한다. 코드 변환(C321)에 의해 최종적 으로 생성되는 결과 앱체인 구문 버전(resultant Appchain Syntax Version)은 SM(C35), 외부 코어 (OC)(C329) 및 LIZARD의 모듈식 출력이다."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 3, "content": "도 1026은 도 1021에 도시된 논리를 요약하고 계속한다. 12194단계에서, DPA에서 12190단계를 통해 앱체 인 정정 패치(Appchain Correction Patch)를 성공적으로 생성할 때, 커스텀체인 에코시스템 빌더(CEB; CustomChain Ecosystem Builder)를 통해 관련 BD 또는 ID의 지속적인 오버라이더 측정 보 유(OMR; Override Measure Retention)을 지속하도록 전념한다. 앱체인 정정 패치를 설치하므로, CEB는 관련 OMR 인스턴스를 나타내는 기본 앱체인을 수정한다. 도 1027은 도 1012의 12100단계와 도 1013의 12128단계에 표시된 경제 개념에 대한 추가 세부 사항을 설명하는 유동성 투입의 개념(Concept of Liquidity Injection)을 도시한다. 개념은 지능형 투자 예측 서 비스의 투자에 대한 합의(consensus)는 기부 구조(ES; Endowment Structure)로 이루어지는 12202단계로 시작한다. 기부 구조(ES; Endowment Structure)은 투자 자본(IC)를 통해 예측 서비스 인 종합 상태 평가(CSE; Comprehensive State Evaluation)에 자금을 조달한다. 그 후 12204단계가 실행되며, 관 련 ES의 설정된 정책 보유(EPR; Established Policy Retention)에 정의된 CSE 호출 간격(1208 4)에 따라 CSE의 인스턴스를 호출한다. 큰 간격(larger Interval)은 더 적은 돈이 소비될 것을 의미하며, 이는 CSE으로부터 덜 정확한 투자 예측을 달성하는 반면, 그 반대의 경우도 적용된다. 12204 단계에 의해 CSE을 호출에 따라, 12206단계의 작동은 BCHAIN 프로토콜을 작동시키는 BCHAIN 노드에 걸쳐 컴퓨터의 작업이 수행됨을 의미하여 12206단계의 동작이 작동되며, 따라서 BCHAIN 네트워크 를 형성한다. 12206단계의 동작은 메타체인의 와트 경제를 발생시키는 관련 투자 자본 (IC) 인스턴스 내에 전략적으로 할당된 자금의 조작을 나타내는 12208단계의 동작을 의미한다. 자금은 IC 인스턴스 자체 내에 암호화된 방식으로 직접 존재하지 않지만, 자금을 보유한 BCHAIN 노드에 의 해 WUP2을 통해 서약된다. 따라서 모든 와트 유닛은 와트 경제에 의해 관리되며, 물리적 BCHAIN 노 드에 암호화되어 있다. 따라서 유동성 투입의 개념(Concept of Liquidity Injection)은 투자자/디 렉터 12006/12022에 대한 수요가 와트 유닛의 이전을 개시한다는 것을 (WUP2을 통해 관련 투자 자본 (IC) 인스턴스에 자금을 서약함) BCHAIN 노드에서 와트 경제 내에 (해당 타겟 투자 상황 해석 (TICI; Target Investment Circumstances Interpretation), 종합적 상태 평가(CSE; Comprehensive State Evaluation) 및 자동 오버라이더 측정 조작(AOM2; Automated Override Measure Manipulation) 인스턴스를 호스팅하기 위한 컴퓨터의 작업을 수행한) 다른 BCHAIN 노드에 나타낸다."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "[00]도 1028 내지 도 1030은 제안 준수 절차(PCP; Proposal Compliance Procedure)의 기능 및 작동을 도시하며, 제안 투표 인터페이스(PVI; with Proposal Voting Interface)와의 상호 작용에 해당된다. 도 1028은 PVI의 12034단계에서 논리가 시작되는 방법을 도시하며, 이는 디렉터 12006/12022에 의해 PCP에 (다양한 잠재적 승인된 제안) 승인된 제안(Authorized Proposal)의 제출을 나타낸 다. 따라서 PCP의 정당성이 활성화되며, 이는 승인된 제안가 이사회 12018/12230 또는 독립 디렉 터 12020/12232에 의해 제출되는지 확인한다. 옵션이 발생하면, 이후 12234단계가 지분 추적 보유(Stake Tracking Retention)에 저장된 정보에 따라 디렉터가 보유한 관련 투자 자본(IC) 인스턴 스의 투자 지분(Investment Stake)을 결정하여 활성화된다. 따라서 투자 지분(Investment Stake)은 생 산된다. 옵션가 발생하면, 논리(logic)는 또한 옵션으로 이어지는 12224단계로 스킵(skip)된다. 12234단계를 통해 투자 지분을 검색(retrieval)할 때, 12238단계는 제안 추적 보유(PTR; Proposal Tracking Retention)에 따라 관련 디렉터의 제안 레코드를 검색한다. 이러한 제안 레코 드(Proposal Record)에는 PTR를 통해 ES 내에 기록된 대로 특정 디렉터(specified Director)에 의해 이루어진 모든 과거 제안을 포함한다. 그 후 12240단계는 특정 디렉터가 디렉 터 제안 수당(DPA; Director Proposal Allowance)을 통해 제안을 제출할 수 있는 빈도를 계산한다. 도 1028에 설명되지 않은 12240단계 이후에 실행되는 논리는 결국 승인된 제안가 적합하다고 판명될 경우 12224단계의 활성화로 이어진다. 이는 PCP의 모듈식 출력으로 PVI의 12012단계로 제출되는 준수 제안(Compliant Proposal)으로 이어진다. 12012단계는 (이사회(BD; Board of Directors)의) 관 련 디렉터 또는 (독립 디렉터(ID; Independent Director)의) 디렉터에게 제출되는 준수 제안을 수반한다. 이사회 사이에 합의를 보장하므로 다수의 디렉터는 제안에 대한 찬성 또는 반대 투표를 할 수 있다. 단독 디렉터(sole Director)의 경우, 준수 제안은 기부 구조 (Endowment Structure)에 의해 자동으로 수락되고, 따라서 관련 제안 추적 보유(PTR; Tracking Retention) 인스턴스에 추가된다. 도 1029는 디렉터 투표 메커니즘(DVM; Director Voting Mechanism)의 서브 세트(subset)로서 작동하는 제안 투표 인터페이스(PVI; Proposal Voting Interface)를 도시하며, 따라서 제안 준수 절차(PCP; Proposal Compliance Procedure)과의 추가된 통합을 도시한다. 논리는 12240단계에서 재개되며, 상기 단계에서는 특정 디렉터의 디렉터 허용량(Director Allowance)을 계산하도록 디렉터 제안 허용량 (DPA; Director Proposal Allowance)을 호출한다. 12250단계는 승인된 제안(Authorized Proposal) 제출이 디렉터 허용량 및 제안 레코드에 따라 준수(Compliant) 또는 비준수(Not Compliant) 여부에 고려하여 처리된다. 제안 레코드에 의해 명시된 바와 같이, 디렉 터에 의해 제시된 최근 제안의 빈도가 디렉터 허용량을 초과한다면, 제안는 비준수 로 간주된다. 비준수(Not Compliant) 시나리오에 따라, PCP은 12078단계에 따라 제안 제출이 거부되어야 하는 DVM에 보고한다. 제안 레코드에 의해 제시된 제안의 빈도가 디 렉터 허용량에 정의된 임계값(threshold) 내에 있는 경우, 준수(Compliant) 시나리오는 제정된 다. 따라서 준수(Compliant) 시나리오는 현재 준수 제안을 PVI의 12012단계로 제출하여 12224 단계로 이어진다. 따라서 DVM의 12056단계는 PVI을 통해 다른 디렉터에게 투표하 기 위해 준수 제안을 제출한다. 도 1030은 디렉터 제안 허용량(DPA; Director Proposal Allowance)의 동작을 통해 디렉터 허용량 (Director Allowance) 변수를 생성하는 12240단계의 작동에 관한 추가 세부 사항을 도시한다. 12262단계 에서, 디렉터 허용량 배율(Director Allowance Multiplier)는 관련 이사회(BD) 인스턴스의 설정 된 정책 보유(EPR; Established Policy Retention)로부터 검색된다. 배율(Multiplier)은 해당 디렉터의 투자 지분(Investment Stake)과 관련하여 의도된 디렉터 허용량에 해당되는 선택된 비율을 나타 낸다. 따라서 디렉터의 제안 허용량은 기부 구조(ES; Endowment Structure)을 대신하여 투자한 규모와 관련이 있다. 그 후 12266단계 및 12268단계에서, 디렉터 허용량는 투자 지분을 포함하는 배율(Multiplier)를 곱하여 생산한다. 12268단계에 의해 지시된 바와 같이, 디렉터 허용량 는 디렉터이 하나의 제안을 제출할 수 있는 시간을 시간 창(time window)으로 나타낸다. 따라서 허용량가 24시간 이라면, 디렉터은 해당 24시간 동안 하나의 제안서를 제출할 수 있지만, (허용 량 기간이 재설정될 때까지) 더 이상은 할 수 없다. 상기 허용량 구현은 회원자격(membership)을 쉽게 얻을 수 있는 많은 디렉터을 포함하는 이사회(Boards)에 특히 유용하게 제공되는 스팸 남용 방지 메커니즘(spam abuse prevention mechanism)의 역할 (즉: 크라우펀딩(Crowdfunding))을 한다. 따라서 디 렉터 허용량은 12250단계로 전달되며, 이는 상세하게 설명된다. 12268단계는 간접적으로 12270단계의 활 성화로 이어지고, 최종 준수 제안(Last Compliant Proposal)이 디렉터에 의해 제출된 시기를 식 별하기 위해 제안 레코드를 점검한다. 비준수 제안(Non-compliant Proposals)은 디렉터 의 할당량(quota)에 포함되지 않는다. 따라서 최종 준수 제안은 12276단계에서 생성되고 해석된다. 12276단계는 최종 준수 제안이래로 계산된 시간이 더 많음(Greater Than) 또는 더 적음(Lesser Than) 인지 여부를 확인한다. 계산된 시간이 더 많음(Greater Than)인 경우, 승인된 제안 은 준수(Compliant)로 간주된다. 계산된 시간이 더 적음(Lesser Than)인 경우. 승인된 제안은 비준수(Not Compliant)로 간주된다. 도 1031은 법인 현황 보고(CSR; Corporate Status Reporting)의 작동 및 기능을 도시한다. CSR 는 작동 정보를 해당 법인체 추적 앱체인(Corporate Entity Tracking Appchain)에 제출하는 등록된 법인체에 의해 수행되는 정보 보고서를 관리한다. 이는 결국 기부 구조(ES; Endowment Structure)의 해당 이상적 인 투자 결정 메이크업(Ideal Investment Decision Makeup)를 처리하는 과정에서 모든 등록된 법인체의 작동 활동을 고려하도록 종합 상태 평가(CSE; Comprehensive State Evaluation)를 가능하게 한다. 법인 체 추적 앱체인(Corporate Entity Tracking Appchain)에 (재고, 판매, 직원 구성 등과 같이) 법인체의 작동 활동과 관련된 기록된 데이터의 주요 요소를 공시하는 것을 선택했다는 의미에서 법인체는 '등록'된다. CSR는 법인체 추적(CET; Corporate Entity Tracking)으로부터 모든 추적된 법인체를 통 해 반복되는 12288단계에서 CSE에 의해 시작된다. 그 후 12290단계에서, 법인체 아이덴티티(Corporate Entity Identity)는 12288단계에서 시작된 루프의 선택된 유닛으로부터 검색된다. 그 후 12292단계에서, CSR의 실행 인스턴스를 호스팅하는 BCHAIN 노드는 법인체 아이덴티티와 관련된 법인체 추적 앱체인는 (노드에 대해) 로컬로 업데이트되는지 확인한다. 그렇지 않은 경우, '아니요, 최신 아님 (No, not up to Date)' 시나리오가 컨텐츠 클레임 생성기(CCG; Content Claim Generator)을 통해 메타체인을 참조하여 관련 법인체 추적 앱체인을 검색하여 발생한다. CCG은 BCHAIN 네트워크 의 다양한 BCHAIN 노드에서 컨텐츠를 검색할 수 있는 BCHAIN 프로토콜(BCHAIN Protocol)의 핵 심 기능이다. 커스텀체인 인지 모듈(CRM; Customchain Recognition Module)은 BCHAIN 프로토콜의 다른 주요 기능으로, 등록된 앱체인에 정의된 앱체인 (및 확장에 의한 마이크로앱체인)을 자동 으로 유지 관리한다. 따라서 실시간 업데이트는 새로운 컨텐츠는 특정 앱체인에서 사용할 수 있는지 여부를 나타내기 위해 메타체인의 앱체인 업데이트에서 제공된다. 따라서 CRM은 특정 앱체인 이 (등록된 앱체인을 통해 등록되어) 로컬에 유지되는지를 계산할 수 있고, 특정 앱체인의 로컬 보유가 최신(up to date) 또는 최신이 아님(not up to date) 인지 12292단계에서 알린다. CCG이 특정 앱체인을 업데이트하기 위해 호출되면, 메타 체인의 다양한 요소가 최적화된 섹터 경로(Optimized Sector Routing), 앱체인 캐시 위치(Appchain Cache Location), 카오스 환경 추적 (Chaotic Environment Tracking) 및 위치 연합(Location Association)와 같은 CCG에 제공된다. 이는 CCG가 요청된 컨텐츠에 대해 BCHAIN 네트워크를 적절히 호출할 수 있으며, 결국 컨 텐츠 클레임 렌더링(CCR; Content Claim Rendering)이 법인체 추적 앱체인의 업되이트된 버전을 수신하고 검증하게 한다. 따라서 시나리오 1294 및 12296은 모두 법인체 아이덴티티에 대한 참조가 법인 체 추적 앱체인에 존재하는지 확인하는 12300단계로 이어진다. 도 1032는 12300단계부터 계속되는 법인체 현황 보고(CSR; Corporate Status Reporting)을 묘사하기 위 해 도 1031로부터 계속된다. 법인체 아이덴티티(Corporate Entity Identity)에 관한 참조가 법인체 추적 앱체인(Corporate Entity Tracking Appchain)에 존재하면, '예, 참조가 존재함(Yes, reference exists)’ 시나리오가 활성화된다. 시나리오은 해당 법인 아이덴티티 앱체인(Corporate Identity Appchain)을 참조하고, 법인체 자체에서 보고된 작동 정보를 보유한다. '아니요, 참조가 존재 하지 않음(No, reference does not exist)’ 시나리오에서, CSR의 실행은 오류 상태에 도달하며, 이는 진단 로그 유닛(DLU; Diagnostic Log Unit)가 5602단계를 통해 진단 로그 제출(DLS; Diagnostic Log Submission)에 제출됨을 의미한다. DLU 형식의 오류 보고서는 자동화된 리서치 매 커니즘(ARM; Automated Research Mechanism)에서 진단 로그 유닛 분석(DLUA; Diagnostic Log Unit Analysis) 서브모듈을 통해 오류 보고서를 처리하는 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)으로 전달된다. SPSI을 포함하는 오류 보고 피드백 루프(Error Reporting feedback loop)는 DLU에 의해 입증된 초기 오류 보고서에 대한 검증된 솔루션을 수용하기 위해, 결국 변경하기 위 해 CSR의 프로그래밍으로 이어진다. 이는 도 XYZ 시나리오에서 설명하는 SRIA의 개념을 따른다. 법인체 아이덴티티(Corporate Entity Identity)에 특정된 시나리오 논리 브랜치의 연속에서, 검색된 법 인 아이덴티티 앱체인(Corporate Identity Appchain)은 BCHAIN 프로토콜 모듈 실행 스트림 모음 (ESC; Execution Stream Collection), 데이터 스트림 정렬(DSS; Data Stream Sorting), 및 실행 스트림 렌더링(ESR; Execution Stream Rendering)을 통해 12308단계에서 렌더링된다. 따라서 논리는 도 1033에서 계속된다. 도 1033은 시나리오에서 논리 브랜치를 계속한다. ESR에서 법인 아이덴티티 앱체인(Corporate Identity Appchain)의 성공적인 렌더링은 앱체인 렌더링 결과(Appchain Rendering Results)를 생성한다. 앱체인 렌더링 결과는 법인체Corporate Entity에 대한 접근의 모든 필요한 API 포인트, 따라 서 법인체 아이덴티티(Corporate Entity Identity)를 포함한다. 이러한 API 포인트는 12312단계에서 작 동되는 법인체 API 보고(CEAR; Corporate Entity API Report) 모듈에 모듈식 입력으로 제출된다. CEAR에서 수행되는 API 호출(API invocation)은 BCHAIN 네트워크을 통해 수행된다. 따라서 등록된 법인체는 API를 CEAR에 적절하게 게시하기 위해 해당 관할구역에 활성 BCHAIN 노드이 있어 야 한다. 따라서 CEAR은 해당 법인체 API 결과를 생성한다. 그 후, 12320단계는 API 결과 을 해당 법인체 아이덴티티와 연관시키고 임시 세션 저장을 위해 법인 모음 캐시 보유(C3R; Corporate Collection Cache Retention)에 쌍을 제출한다. 그 후, 루프 논리(Loop logic)는 프롬프트 에 의해 유지되며, 12288단계에서 시작된 루프에 법인체가 남아 있는지 확인한다. 프롬프트에 대 한 응답이 예(Yes)인 경우, 논리의 흐름은 법인체 추적(CET; Corporate Entity Tracking)로부터 추적된 법인체를 통해 계속 반복하는 12332단계로 되돌아 간다. 도 1034는 논리의 흐름을 계속하고 프롬프트 에 대한 아니요(No) 응답의 시나리오를 자세히 설명한다. 도 1034는 12320단계 및 프롬프트으로부터 논리의 흐름을 계속하기 위해 도 1033의 일부 논리와 겹쳐진 다. 프롬프트에 대한 응답이 아니요(NO)인 경우, 법인 모음 캐시 보유(C3R; Corporate Collection Cache Retention)에서 LOM의 중앙 지식 보유(CKR; Central Knowledge Retention)으로 진행되는 실행 스트림 렌더링(ESR; Execution Stream Rendering) 세션 결과를 커밋 (commits)하는 12334단계가 활성화된다. C3R에 의해 수행된 데이터 스토리지는 BCHAIN 네트워크을 통해 BCHAIN 노드의 임시 세션 스토리지에 의해 유지된다. 이러한 임시 세션 스토리지는 일반적으로 랜덤 액세스 메모리(RAM; Random Access Memory) 형식이며, 이는 임시 스토리지 결과를 보관하는 효율적인 매체이지 만 시스템 재부팅 이후에는 정보를 유지할 수 없다. 그러므로 C3R가 BCHAIN 프로토콜 내에서 작동 할 때, ESR은 C3R에 대한 데이터 명령어를 작동하도록 세션 쓰기 데이터 세그먼트(Session Write Data Segment) 명령 유형(Command Type)을 사용한다. 세션 쓰기(Session Write) 명령 (Command)의 정의는 CSR를 나타내는 앱체인에 존재하는 실행 세그먼트에 의해 정의된다. 따라서 임시 세션 쓰기 데이터 세그먼트(temporary Session Write Data Segment) 명령 사용과 대조적으로, 영구 쓰기 데이터 세그먼트(Persistent Write Data Segment) 명령은 임시 ESR 세션 결과를 영구 CKR 스토리지에 커밋(commits)하는 12334단계에 사용된다. 12334단계 를 구체적으로 정의하는 앱체인 섹션에는 영구 쓰기(Persistent Write) 명령을 나타내는 실행 세그먼트이 포함되어 있다. 법인체의 12326단계 인지는 루프 자체를 시작하는 12332단계에서 오는 정보를 통해 루프 내에 남아있다. 따라서 루프 카운터(Loop counter) 12332단계에서 유지 관리된다. 도 1035는 시장 리서치 절차(MRP; Market Research Procedure)의 기능 및 작동을 도시한다. MRP(1234 0)은 서브모듈 리서치 호출 프롬프트(RIP; Research Invocation Prompt)을 통해 종합 상태 평가(CSE; Comprehensive State Evaluation)의 작동으로 시작된다. RIP은 12342단계에서 자동화된 리서치메커니즘(ARM; Automated Research Mechanism)을 통해 시장 활동 및 이벤트를 연구하는 LOM의 인스 턴스를 호출한다. ARM에 의해 수행된 리서치 결과는 확인되지 않은 새로운 정보(new and unconfirmed information)를 중앙 지식 보유(CKR; Central Knowledge Retention)에 저장하는 12344단계에서 처리된 다. 그 후 12346 단계에서, 대규모 시간 내에서, LOM은 시장 활동 및 이벤트와 관련하여 의미있고 유용한 주장 및 결론을 생성하기 위해 CKR에 저장된 확인되지 않은 새로운 정보를 점진적으로 상호 작용한다. 따 라서 LOM는 12346단계에서 시장 활동 지식(Market Activity Knowledge)을 생성하고, 지식 은 CSE에서 나중에 참조할 수 있도록 CKR에 저장된다. 도 1036은 MRP의 12346단계에 관한 실행 세부 사항에 대해 자세히 설명한다. 초기 ARM은 12350단 계에서 공개 소스 및 비공개 소스(public and private sources)로부터 확인되지 않은 정보(unconfirmed information)를 검색한다. 그 후 12354단계에서, LOM 및 CTMP는 확인되지 않은 정보를 확인하고 진 실한 개념을 생성하기 위해 이를 확장한다. 개념(concept)/주장(assertion) 내에서 발견되는 진실의 요소는 CTMP의 비판적 사고 능력(critical thinking abilities)에 의해 활성화되는 LOM의 객관성 추구 프로 그래밍(objectivity-seeking programming)에 의해 결정된다. 따라서 12356단계에서, LOM가 객관적인 진실 추구와 일치한다고 주장하는 확인된 지식(confirmed knowledge)은 시장 활동 지식(Market Activity Knowledge)으로 생성되고 나중에 CSE에서 참조할 수 있도록 CKR에 저장된다. 도 1037은 규제(Regulatory)/세금 리서치 절차(RTRP; Tax Research Procedure)의 기능 및 작동을 도시 한다. RTRP는 서브모듈 리서치 호출 프롬프트(RIP; Research Invocation Prompt)를 통한 종합 상태 평가(CSE; Comprehensive State Evaluation)의 작동에 의해 개시된다. RIP은 12362단계에 서 자동화된 리서치 메커니즘(ARM; Automated Research Mechanism)를 통해 세금 및 규제 코드를 연구하는 LOM 인스턴스를 호출한다. ARM에 의해 수행된 연구 결과는 확인되지 않은 새로운 정보를 중앙 지식 보유(CKR; Central Knowledge Retention)에 저장하는 12364단계에서 처리된다. 그 후 12366 단계에서, 대규모 시간 내에, LOM은 세금 및 규제 코드와 관련하여 의미있고 유용한 주장 및 결론을 생성하기 위해 CKR에 저장된 확인되지 않은 새로운 정보를 점진적으로 상호 작용한다. 따라서 LOM는 12366 단계에서 세금 책임 지식(Tax Liability Knowledge) 및 규제 준수 지식(Regulatory Compliance Knowledge)을 생성하고, 이는 CSE에서 나중에 참조할 수 있도록 CKR에 저장된다. 도 1038은 RTRP의 12366단계에 관한 실행 세부 사항에 대해 자세히 설명한다. 초기 ARM은 12350단 계에서 공개 소스 및 비공개 소스(public and private sources)로부터 확인되지 않은 정보(unconfirmed information)를 검색한다. 그 후 12376단계에서, LOM 및 CTMP는 확인되지 않은 정보를 확인하고 진 실한 개념을 생성하기 위해 이를 확장한다. 개념(concept)/주장(assertion) 내에서 발견되는 진실의 요소는 CTMP의 비판적 사고 능력(critical thinking abilities)에 의해 활성화되는 LOM의 객관성 추구 프로 그래밍(objectivity-seeking programming)에 의해 결정된다. 따라서 12378단계에서, LOM가 객관적인 진실 추구(objective thrush-seeking)와 일치한다고 주장하는 확인된 지식(confirmed knowledge)은 세금 책임 지식 (Tax Liability Knowledge)과 규제 준수 지식(Regulatory Compliance Knowledge)으로 생성되고 나중에 CSE에서 참조할 수 있도록 CKR에 저장된다. 도 1039 내지 도1087은 전체로서 NMC를 대신하여 지능적인 투자 조사(research)/계산(calculations)을 수 행하는 핵심 프로그램인 종합 상태 평가(CSE; Comprehensive State Evaluation) 모듈의 작동 및 기능을 도시한다. 도 1039는 (12402단계에서) 타겟 투자 정황(Target Investment Circumstances)을 모듈식 입력으로서 CSE에 제공하는 타겟 투자 상황 해석(TICI; Target Investment Circumstances Interpretation) 에 의해 CSE가 초기화되는 방법을 도시한다. TICI은 해당 기부 구조(ES; Endowment Structure)의 관련 포트폴리오 지분 보유(PSR; Portfolio Stake Retention) 인스턴스에서 포트 폴리오 지분 메이크업(Portfolio Stake Makeup)를 추출하는12382단계로 시작한다. 그 후 12386단계에서, 오버라이드 측정은 해당 기부 구조(ES)의 관련 오버라이드 측정 보유 (OMR)에서 추출한다. 오버라이드 측정은 선택된 기준을 통해 결과 이상적인 투자 결정 메이크업 (resultant Ideal Investment Decision Makeup)에 의도된 사용자 지정(customizations) 효과를 유도하 고 디렉터 투표 메커니즘(DVM; Director Voting Mechanism)을 통해 디렉터 12006/12022에 의해 투표한 다. 이러한 측정은 수동으로 (예를 들어, 건강한 자동화 산업/시장에 의존하는 가치에 투자하지 않는) 투자 사용자 지정(investment customizations) 또는 디지털 마인드 추적(DMT; Digital Mind Tracking) 에서 수행된 에뮬레이션을 통해 특정 개인에 의해 선택될 수 있다. 12390단계에서, 포트폴리오 지분 메이크업(Portfolio Stake Makeup) 및 오버라이드 측정(Override Measures)에 포함된 정보는 타겟 투자 정황(Target Investment Circumstances)이 되는 추상화 컨테이너(Abstraction Container)에 병합된다. 따라서 추상화 컨테이너은 모듈식 입력으로 CSE에 제출되고, 12402단계에서 일반적으로 처리된다. 12402단계에 의해 LOM 및 CTMP의 호출이 완료되면, 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)이 결국 생산된다. 메이크업은 CSE의 최종 모듈식 출력이다. 도 1040은 종합 상태 평가(CSE; Comprehensive State Evaluation)의 개시 논리 흐름을 계속한다. 12406 단계는 LOM을 통한 CKR이 CSE 처리를 위해 시장 활동 지식(Market Activity Knowledge) (도 1035 참조)을 생성하도록 시장 리서치 절차(MRP; Market Research Procedure)를 호출한다. MRP의 즉각적인 처리가 완료되면, 후속 단계는 논리 흐름을 계속한다. MRP 즉 시 처리 완료(instantaneous processing completion)는 12352단계의 완료로 정의되며, 여기서/이 때에 초기 확 인되지 않은 정보는 CKR에 저장된다. MRP 내의 후속 단계 12354 및 12356은 즉각적인 후 처리로 간 주된다. 이는 12354 및 12356 단계가 LOM 및 CTMP가 확인되지 않은 정보를 점진적으로 처리하고 그러 한 정보와 관련된 진실된 주장 및 결론을 도출하는 상당히 긴 기간에 걸쳐 발생하기 때문이다. 따라서, 12408단 계에서 CSE의 스레드 관리는 MRP의 12352단계가 완료될 때까지 12410단계로 계속 차단한다. 12410단계의 지속 및 작동에 따라, LOM을 통한 CKR이 CSE처리를 위한 세금 책임 지식(Tax Liability Knowledge) 및 규정 준수 지식(Regulatory Compliance Knowledge)을 생성할 수 있도 록 규제/세금 리서치 절차(RTRP; Regulatory/Tax Research Procedure)이 호출된다. RTRP의 즉각 적인 처리가 완료되면, 후속 단계는 논리 흐름을 계속한다. RTRP 즉시 처리 완료는 12374단계의 완료로 정의되며, 여기서/이 때에 초기 확인되지 않은 정보는 CKR에 저장된다. RTRP 내의 후속 단 계 12376 및 12378은 즉각적인 처리로 간주된다. 따라서 12412단계에서, CSE의 스레드 관리는 RTRP의 12374단계가 완료 될 때까지 12414단계로 계속 차단한다. 12414단계를 지속 및 작동에 따라, LOM을 통한 CKR이 CSE처리를 위해 법인 현황 API 결과(Corporate Status API Results)를 생 성할 수 있도록 법인 현황 보고(CSR: Corporate Status Report)가 호출된다. CSR의 즉각적인 처 리가 완료되면, 후속 단계는 논리 흐름을 계속한다. CSR 즉시 처리 완료는 12288단계의 루프의 시작으로 정의된다. CSR 내에서 12288단계의 루프의 전체 작동은 사후 처리로 간주된다. 따라서 12416단 계에서 CSE의 스레드 관리는 CSR의 12288단계가 시작될 때까지 12422단계로 계속 차단한다. 도 1041은 시장 리서치 절차(MRP; Market Research Procedure), 규제/세금 조사 절차(RTRP) 및 법인 현황 보고(CSR; Corporate Status Report)로부터 입력을 수신하는 12416단계의 논리 흐름을 계속 한다. 그 후, LOM를 통한 CKR이 암호화 디지털 경제 익스체인지(CDEE; Cryptographic Digital Economic Exchange)에서 UBEC 플랫폼 앱으로부터 정보 업데이트를 받을 수 있도록 디지털 익스체인지 상태 보고(DSR; Exchange Status Report)이 호출한다. DESR 즉시 처리가 완료되면 12424단계는 논리 흐름을 계속한다. 그 후, 단계 12426은 실행 조건이 충족될 때까지 실행 논리를 정지시킨다. 이러한 조건 은 MRP, RTRP, CSR 및 DESR이 모두 장기 처리 실행 논리 작동을 완료한 것으로 정의된다. 이는 각 모듈의 최종 모듈식 출력, 확인된 지식, CKR에 제출되는 것과 관련이 있다. 도 1042는 12426단계의 논리 흐름을 계속한다. 크기 X로 표시된 비율은 정적 하드코드된 정책(SHP; Static Hardcoded Policy)에서 정의되며 12426단계의 상태 점검에서 고려된다. 크기 X가 더 높은 경우, 12426단 계의 조건 트리거(condition trigger)를 달성하기 위해 기하급수적으로 더 오래 걸릴것이다. 역상관성이 적용된 다. 12426단계의 즉각적인 실행이 조건 점검에 대한 아니요(NO) 응답을 나타내는 경우, Y 시간 동안 CSE의 실행이 중지되고 Y는 SHP에서 정의되는 12432단계가 활성화된다. Y 시간이 경과한 후, 12426 단계는 예(Yes) 응답을 달성하기 위한 후속 시도로 재실행된다. 12426단계에 대한 예(Yes) 응답 은 12426단계의 조건 트리거가 충족되었음을 나타낸다. 따라서 CKR에서 시장 활동 지식(Market Activity Knowledge)을 생성하는 12434단계가 실행된다. 그 후 12436단계는 세금 책임 지식(produces Tax Liability Knowledge)을 생성하는 12434단계와 유사한 논리를 진행한다. 시장 활동 지식 및 세 금 책임 지식은 12402단계에서 진행된다. 12402단계는 CSE의 최종 출력, 이상적인 투자 결정 메 이크업을 생성하기 위해 LOM 및 CTMP를 호출하는 대규모 작동이다. 12402 단계는 타겟 투자 상황 해석(Target Investment Circumstances)에 의해 제공되는 CSE에 대한 메인 모듈식 입력이 기 때문에, 입력으로 타겟 투자 정황(Target Investment Circumstances)을 받는다. 도 1043은 도 1042와 동일한 논리를 설명하지만, 12402단계 이전에 실행된 12440단계 및 12442단계의 세부 사항 이 추가되어 실행된다. 12440단계는 CKR로부터 규제 준수 지식(Regulatory Compliance Knowledge)(1237 0)을 생성하고 또한 이를 12402단계로 제출한다. CKR에서 법인 운영 지식(Corporate Operations Knowledge)을 생성하고 또한 이를 12402단계로 제출한다. 이는 12402단계를 통해 이상적인 투자 결정 메 이크업(Ideal Investment Decision Makeup)를 생성하기 위해 LOM 및 CTMP의 호출된 인스턴스 의 작동을 가능하게 한다. CSE은 NMC의 핵심 모듈이며, 12402단계는 타겟 투자 정황(Target Investment Circumstances) 및 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)의 터미널 입력 및 출력(terminal inputs and outputs)을 포함하는 CSE의 핵심 작동 컨테이너이다. 도 1044는 LOM이 CKR로부터 시장 활동 지식(Market Activity Knowledge)을 생성하는 CSE의 12434단계에 관한 세부 사항을 도시한다. LOM은 NMC 지식 호출 프롬프트(NKIP; NMC Knowledge Invocation Prompt) 모듈에 의해 이러한 지식을 생성하도록 호출된다. 시장 활동 지 식은 UKF 클러스터(C854F)의 여러 인스턴스의 구축으로 설명된다. UKF 클러스터(C854F)의 개별 요소는 규칙 구문 포맷(Rule Syntax Format)(C538)에 저장된 UKF1, UKF2 및 UKF3 서브 유닛의 구성으로 자세히 설명된 다. 도 1045는 LOM이 CKR로부터 세금 책임 지식(Tax Liability Knowledge)을 생성하는 CSE의 12436단계에 관한 세부 사항을 도시한다. LOM은 NMC 지식 호출 프롬프트(NKIP; the NMC Knowledge Invocation Prompt) 모듈에 의해 그러한 지식을 생성하도록 호출된다. 세금 활동 지 식(Tax Activity Knowledge)은 UKF 클러스터(C854F)의 여러 인스턴스의 구축으로 설명된다. UKF 클러스 터(C854F)의 개별 요소는 규칙 구문 포맷(Rule Syntax Format)(C538)에 저장된 UKF1, UKF2 및 UKF3 서브 유닛 의 구성으로 자세히 설명된다. 도 1046은 LOM이 CKR로부터 규제 준수 지식(Regulatory Compliance Knowledge)을 생성하는 CSE의 12440단계에 관한 세부 사항을 도시한다. LOM은 NMC 지식 호출 프롬프트(NKIP; NMC Knowledge Invocation Prompt) 모듈에 의해 그러한 지식을 생성하도록 호출된다. 규정 준수 지 식(Regulatory Compliance Knowledge)은 UKF 클러스터(C854F)의 여러 인스턴스의 구축으로 설명된다. UKF 클러스터(C854F)의 개별 요소는 규칙 구문 포맷(Rule Syntax Format)(C538)에 저장된 UKF1, UKF2 및 UKF3 서브 유닛의 구성으로 자세히 설명된다. 도 1047은 LOM이 CKR로부터 법인 운영 지식(Corporate Operations Knowledge)을 생성하는 CSE의 12442단계에 관한 세부 사항을 도시한다. LOM은 NMC 지식 호출 프롬프트(NKIP; NMC Knowledge Invocation Prompt) 모듈에 의해 그러한 지식를 생성하도록 호출된다. 규제 준수 지 식(Regulatory Compliance Knowledge)은 UKF 클러스터(C854F)의 여러 인스턴스의 구축으로 설명된다. UKF 클러스터(C854F)의 개별 요소는 규칙 구문 포맷(Rule Syntax Format)(C538)에 저장된 UKF1, UKF2 및 UKF3 서브 유닛의 구성으로 자세히 설명된다. 도 1048은 종합 상태 평가(CSE; Comprehensive State Evaluation)의 12402단계와 관련하여 LOM 및 CTMP의 내부 작동 절차를 도시한다. 타겟 투자 정황(Target Investment Circumstances)은 이상적 인 구성 호출 프롬프트(ICIP; Idealistic Configuration Invocation Prompt)에 초기 입력으로서 공급된 다. ICIP은 입력 기준 타겟 투자 정황을 고려하여 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)의 생산을 호출하기 위해 LOM와 직접 상호 작용하는 프롬프트(1244 8)을 생산한다. ICIP에 의해 생성된 프롬프트은 초기 쿼리 추론(IQR; Initial Query Reasoning)(C802A) 모듈에 제출된다. UBEC 사용자에 의해 UBEC 플랫폼 내에서 LOM이 직접 호출 될 때, IQR(C802A)는 UBEC 사용자에 의해 제공된 초기 질문/주장을 수신한다. 그러나 상기 LOM의 인 스턴스는 대신 ICIP에 의해 자동으로 호출된다. 제공된 프롬프트은 프롬프트에게 완전히 주소/응답하기 위한 LOM에 정확한 '가상 이해'를 완료하기 위해 중요한 프롬프트로부터 누락된 세 부 사항을 판독하기 위해 중앙 지식 보유(CKR; Central Knowledge Retention)의 호출을 통해 분석된다. IQR(C802A)에 의해 생성된 결과 누락된 세부 사항은 모듈식 입력으로 조사 구분(SC; Survey Clarification)(C803A)에 제출된다. 프롬프트은 객관적이고 모든 필요한 문맥(context)을 분석할 수 있 도록 SC(C803A)는 보충 정보를 검색하여 프롬프트의 출처와 연결한다. UBEC 사용자에 의해 LOM이 UBEC 플랫폼 내에서 직접 호출될 때, SC(C803A)는 질문/응답의 출처로서 그 사용자와 연 동한다. 그러나 상기 LOM 인스턴스는 대신 ICIP에 의해 자동으로 호출되므로 SC(C803A)는 프롬프트 에 관한 보충 정보를 검색하기 위해 ICIP과 연동한다. 프롬프트의 완전한 형태와 개선된 버전은 SC(C803A)에서 생산되며 주장 생성(AC; Assertion Construction)(C808A)에 모듈식 입력으로 제출된다.AC(C808A)는 CKR을 직접 참조하거나 계층적 매핑(HM; Hierarchical Mapping)(C807A)를 통해 프롬프트 에 대한 일관된 응답을 구성하기 위해 시도한다. 합리적 어필(RA; Rational Appeal)(C811A)는 CTMP와의 논리 흐름 인터페이스를 수용하는 컨테이너 모듈이다. RA(C811A)는 주장을 비판하기 위해 CTMP를 사용한다. 이러한 비판은 (AC(C808A)의 출력을 비판함으로써) 자체 비판의 형태 또는 (UBEC 사용자 또는 DIP) IQR(C802A)에 의해 처리된 질문/주장의 출처에 대한 외부 비판의 형태일 수 있다. 만약 AC(C808A)에서 생성된 주장이 RA(C811A)에 의해 처리된 자체 비판 테스트에 대한 중요한 측정에 실패한 경우, AC(C808A)의 새로운 인스턴스는 유효한 비판을 설명하기 위해 호출된다. 만약 높은 신뢰도 주장은 RA(C811A)에 의해 처리된 자체 비판 테스트를 지속적으로 통과하는 AC(C808A)에 의해 생성되는 경우, 주장은 이상적인 구성 호출 프롬프트(ICIP; Idealistic Configuration Invocation Prompt)에서 제공하는 초기 프롬프트 의 문맥에서 이상적인 투자 결정 메이크업으로 참조되는 LOM의 모듈식 출력으로 생성된다. 도 1049는 종합 상태 평가(CSE; Comprehensive State Evaluation)의 12402단계와 관련하여 LOM의 합리적 어필(RA; Rational Appeal)(C811A)의 내부 작동 과정에 대한 세부 사항을 도시한다. 주장 생성(AC; Assertion Construction)(C808A)는 해당 입력 프롬프트에 관련하여 AC(C808A)에 의해 생성된 주장에 대 한 합리적 어필(RA)(C811A)에 응답 프레젠테이션(C843)을 제공한다. 논리 흐름의 상기 단계에서 생성된 주장은 사전 비판적 결정(Pre-Criticized Decision)(C847)으로 분류된다. 이는 CTMP에 의한 비판을 통해 아직 처 리되지 않았음을 의미한다. 따라서 생성된 주장은 '주관적 의견(Subjective Opinion)(C848)’ 입력으로 CTMP 인스턴스에 직접 제출되며 또한, CTMP 인스턴스에 ‘객관적 팩트(Objective Fact)(C850)’ 입 력을 제공하는 문맥 구성(CC; Context Construction)(C817A)에 제출된다. CC(C817A)는 AC(C808A)의 메타데이터 와 비판적 사고(critical thinking)를 위해 미가공 팩트(raw fact)를 CTMP에 제출하는 이상적인 구성 호 출 프롬프트(ICIP; Idealistic Configuration Invocation Prompt)을 통해 제공되는 잠재적 증거를 참조 한다. 이러한 입력 메타데이터는 LOM 로그 집계 파일로 표시된다. LOM 로그 집계는 LOM의 기 본적인 운영 기능으로부터 생성된 관련 로그 파일의 모음이 포함되어 있다. CTMP 인스턴스가 작동을 마치 면 사후 비판적 결정(C851)이 모듈식 출력으로 생성된다. 초기 사전 비판적 결정(initial Pre-Criticized Decision)(C847) 및 사후 비판적 결정(Post-Criticized Decision)(C851)은 두 입력 C847과 C851 사이의 잠재적 중복의 범위를 결정하는 의사 결정 비교(DC; Decision Comparison)(C818A) 모듈에 제출된다. DC(818A)가 제공 하는 통합 출력은 주장을 생성하는 AC(C808A)을 대신하여 CTMP의 (부정확한) 양보(Concession)(C852) 또 는 주장을 생성하는 AC(C808A)를 대신하여 인지된 개선(perceived Improvement)(C853)을 나타낼 수 있다. 인수 응답(Argument Responses)인 C852 및 C853은 모두 낮은 신뢰도 결과(C845) 또는 높은 신뢰도 결과(C846)로 분 류할 수 있다. 낮은 신뢰도 결과(C845)는 AC(C808A)에 의해 생성된 초기 주장이 결함이 있음을 나타내며 재구성 해야 한다. 따라서, 논리 흐름은 AC(C808A)의 새로운 인스턴스로 계속 이어진다. 높은 신뢰도 결과(C846)은 AC(C808A)에 의해 생성된 초기 주장이 장점이 있음을 나타내므로 도출된 결론(해당 증거, 전제 등과 결합됨)이 지식 검증(KV)(C805A)에 제출된다. 따라서 논리 흐름은 CKR 및 LOM가 최근에 처리된 주장으로부터 이 점을 얻을 수 있도록 KV(C805A)의 새로운 인스턴스로 계속 진행된다. 도 1050은 LOM 로그 집계(LOM Log Aggregate) 파일의 생성을 보여주기 위해 종합 상태 평가(CSE; Comprehensive State Evaluation)로부터 12402단계의 논리 흐름을 계속한다. 초기 쿼리 추론(IQR; Initial Query Reasoning)(C802A), 조사 구분(SC; Survey Clarification)(C803A), 주장 생성(AC; Assertion Construction)(C808A), 계층적 매핑(HM; Hierarchical Mapping)(C807A) 및 지식 검증(KV; Knowledge Validation)(C805A)에서 생성된 모듈식 출력은 LOM 모듈식 로그 모음(LOM Modular Log Collection, LMLC) 모듈에 제출된다. 따라서 LMLC은 입력 로그 데이터를 LOM 로그 집계로 참조된 읽을 수 있는 단일 파일로 결합한다. 파일은 해당 LOM 인스턴스의 전반적인 작동 상태를 포함하므로, LOM 인스턴스가 다양한 결론에 도달한 방법에 대한 정보를 제공한다. LOM 로그 집계는 합리적 어필 (RA; Rational Appeal)(C811A)의 CC(C817A)에 제출된다. 도 1051은 합리적 어필(RA; Rational Appeal)(C811A)에 정의된 입력 및 출력 채널과 관련하여 CTMP의 내 부 동작을 설명하기 위해 도 1049에 관한 작동 세부 사항을 확장한다. 사전 비판적 결정(Pre-Criticized Decision)(C847)은 주장 생성(AC; Assertion Construction)(C808A)의 모듈식 출력으로 C843에 표시된다. CTMP의 두 가지 주요 입력 중 하나를 충족하므로 결정(C847)은 주관적 의견(Subjective Opinion)(C848)으 로 표시된다. 주관적 의견(C848)은 CTMP의 기본적인 모듈식 입력 및 선택된 패턴 매칭 알고리즘(SPMA; Selected Pattern Matching Algorithm)의 내부 표현으로 작동하는 입력 시스템 메타데이터(C484)에 제출된다. 상기 인스턴스 구성의 경우, SPMA는 LOM이다. 입력 시스템 메타데이터(C484)는 처리를 위해 추론 처리 (Reason Processing)(C456) 및 미가공 인식 생산(RP2; Raw Perception Production)(C465)으로 제출된다. 추론처리(C456)은 속성 특성을 비교하여 만들어진 주장을 논리적으로 이해할 것이다. RP2(C465)는 LOM의 알고 리즘 인식을 나타내는 인식 복잡 포맷(PCF; Perception Complex Format)의 인식을 생성하기 위한 LOM으로 부터 입력 시스템 메타데이터(C484)를 구문 분석한다. 이러한 생성된 인식은 LOM의 알고리즘 인식을 에뮬 레이트하는 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)에 제출된다. 추론 처리(C456) 은 인스턴스에서 LOM인 SPMA 알고리즘을 반영하는 규칙 집합을 최종적으로 생성하는 규칙 처리를 호출한다. 따라서 '사고(thinking)'의 두 가지 모드 인 '아날로그' 인식과 '디지털' 규칙 세트 처리가 실행된다. 상기 두 개의 브랜치 C461과 C475는 직관과 논리를 가진 유사성을 나타낸다. 두 사고 브랜치인 C461 과 C475에 의해 생성된 결과는 결과 사이의 충돌 또는 확증(corroboration)의 기본적인 요소를 평가하는 비판적 결정 출력(CDO; Critical Decision Output)(C462)으로 전송된다. 내부 확증의 높은 크기 및 내부 충돌의 낮은 크기을 발견하면, CTMP는 높은 신뢰도 결과(C846)로 언급되는 초기 입력 주관적 의견(the initial input Subjective Opinion)(C848)과 관련하여 이진법 승인 또는 차단 결정을 제공한다. 내부 확증의 낮은 크기과 내부 충돌의 높은 크기라면, CTMP는 낮은 신뢰도 결과(C845)로 표시되는 '신뢰없는 투표('vote of no confidence)'를 제출한다. 따라서 CTMP의 결과 출력은 사후 비판적 결정(C851)으로 간주된다. 도 1052는 CTMP 내에서 미가공 인식 생산(RP2; Raw Perception Production)(C465)의 호출에 관한 세부 사 항을 도시한다. LOM은 주장 생성(AC; Assertion Construction)(C808A)을 호출하여 이상적인 투자 결정 메 이크업(Ideal Investment Decision Makeup)를 생성한다. 그 다음, 상기 메이크업는 해당 AC(C808A) 인스턴스로부터 발생하는 입력 시스템 메타데이터(C484) 내에서 디버깅 추적(C485) 및 알고리즘 추적 (C486)의 인스턴스를 생성하기 위한 데이터를 분석하는 RP2(C465)의 5506단계에 제출한다. 디버깅 추적 (Debugging Trace)(C485)는 해당 입력, 출력 변수 유형 및 컨텐츠와 마찬가지로 사용되는 변수, 함수, 방법 및 분류를 제공하는 코딩 레벨 추적이다. 전체 기능 호출 체인 (기능 추적: 다른 기능을 호출하는 기능)이 제공된 다. 알고리즘 추적(C486)은 알고리즘 분석과 결합된 보안 데이터를 제공하는 소프트웨어 레벨 추적이다. 결과 보안 결정(승인/차단)은 결정(C847)에 도달한 방법에 대한 로지스틱 트레일(logistics trail)과 함께 제공된다. 결정(C847)을 생성하기 위해 기여한 각 요인에 대한 적절한 가중치가 포함된다. 그 후, RP2(C465)는 처리를 위 해 생성된 인식 결과에 관한 데이터를 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)로 전송한다. 도 1053은 CTMP 내에서 미가공 인식 생산(RP2; Raw Perception Production)(C465)의 작동에 대해 자세히 설명한다. 도 1052와 같이, 초기 단계는 해당 AC(C808A) 인스턴스에서 비롯된 입력 시스템 메타데이터 (C484) 내에서 디버깅 추적(C485) 및 알고리즘 추적(C486)의 인스턴스를 생성하도록 데이터를 분석하기 위해 발 생한다. 5508단계에서, 메트릭 처리(C489)는 LOM에 의해 제시된 인공 지능으로부터 인식을 추출하기 위한 LOM의 변수를 리버스 엔지니어링한다. 그 후에, 입력 시스템 메타데이터(C484)는 시스템 메타데이터 분리 (SMS)(C487)을 통해 중요한 보안 인과 관계로 메타데이터(C484)를 분리하는 5510단계로 처리된다. 또한, 도 1052에 의해 나타낸 바와 같이, RP2(C465)는 생성된 인식 결과에 관한 데이터를 처리를 위해 인지 관찰자 애뮬 레이터(POE; Perception Observer Emulator)(C475)로 전송한다. 도 1054은 인지 저장(PS; Perception Storage)(C478)과의 관계 및 미가공 인식 생산(RP2; Raw Perception Production)(C465)을 포함하는 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)의 작동에 대해 자세히 설명한다. 메트릭 처리(C489) 및 시스템 메타데이터 분리(SMS; System Metadata Separation)(C487)의 작동은 PS(C478)에 저장된 인식 5512/5514/5516의 생산으로 이어진다. 결과 인식 5512/5514/5516은 주장 생성(AC)(C808A)를 통해 이상적인 투자 결정 구성(Ideal Investment Decision Makeup)을 생성하는 LOM의 모듈식 응답을 나타낸다. RP2(C465)는 검색 기준으로 스토리지 검색 (SS; Storage Search)(C480)에 제공되는 비교 가능한 가변 포맷 데이터 포인트를 생성한다. 그 후, SS(C480)은 PS(C478)에 저장된 기존 인식과 일치하는 PS(C478) 검색을 수행한다. 실행 SS(C480)의 결과(C716)은 가중치 계 산(C718)으로 이어져 생성된다. 이러한 계산(C718)은 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)을 생성한 LOM 알고리즘의 실행을 나타내는 비교 가능한 변수 형식을 복제하고 일치시키기 위해 PS(C478)로부터 해당 인식의 정확한 분포를 찾기 위해 시도한다. 도 1055는 도 1054의 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475) 논리를 계속한다. 스 토리지 검색(SS; Storage Search)(C480)에서 결과(C716)를 생성한 후 가중치 계산(C718)은 능동적인 승인 (Approve)(C731) 또는 차단(Block)(C730) 결정을 내리기 위해 인식 5512/5514/5516의 어플리케이션(C729)으로 이어지도록 완료한다. LOM 및 해당 LOM 로그 집계에 의해 생성된 이상적인 투자 결정 메이크업 (Ideal Investment Decision Makeup)은 파생되기 위해 데이터 개선 로그(C723)를 야기시키는 데이터 구문 분석(C724)를 거치게 되며, 이는 입력 이상적인 투자 결정 메이크업과 관련하여 긍정적 감정(승 인)(C731) 또는 부정적 감정(차단)(C730)의 해석 이분법을 달성하기 위해 어플리케이션(C729)에 적용된다. 애플리케이션(C729)의 실행이 성공적으로 완료되면 규칙 실행(RE; Rule Execution)(C461)의 모듈식 출력과 병행하여 비판적 결정 출력(CDO; Critical Decision Output)(C462)에 의해 처리되는 오버라이드 수정 조치(Override Corrective Action)(C476)로 이어진다. 셀프 비판적 지식 밀도(SCKD; Self-Critical Knowledge Density)(C474) 모듈은 보고할 수 있는 LOM 로그 집계의 범위를 넘어서는 알려지지 않은 잠재적 지식의 범위와 유형을 추정한다. 상기 방법으로 CTMP 인스턴스 처리의 후속 비판적 사고(critical thinking) 기능 은 인스턴스에 의해 직접 알려져 있고 알려지지 않은 모든 관련 지식의 잠재적인 범위를 활용할 수 있다. 도 1056은 도 1055의 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)의 실행과 병행하여 작동하는 메모리 웹(C460) 프로세스를 도시한다. LOM에서 생성된 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)은 추론 처리(Reason Processing)(C456)에 모듈식 입력으로 제출된다. 추 론 처리(C456)은 LOM가 이상적인 구성 호출 프롬프트(ICIP; Idealistic Configuration Invocation Prompt)이 제공하는 프롬프트에 응답하여 메이크업을 생성하기 위한 결정한 방법을 처리 한다. 추론 처리(C456)의 처리 결론은 LOM의 실행 동작과 세 번째로 일치하는 규칙을 정의하는 추론 처리 의 실행(C457)이다. 만약 LOM의 실행 동작과 관련하여 규칙 동작에서 불일치가 발견되면, 현재 존재하는 규칙들이 수정되거나 새로운 규칙이 추가된다. 이러한 규칙은 나중에 해당 LOM 인스턴스에서 발견된 의사 결정 동작을 비판하기 위해 CTMP 인스턴스 내에서 사용된다. 그런 다음 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)은 알려진 인식을 활용하여 규칙 집합의 '비판적 사고(critical thinking)'범위를 확장하여 규칙 집합을 향상시켜 올바른 규칙(Correct Rules)(C459)을 생성한다. 올바른 규칙 (C459)는 메모리 웹(C460)의 운영 관할구역 내에서 규칙 구문 포맷 분리(RSFS; Rule Syntax Format Separation)(C499)에 모듈식 입력으로 제출된다. RSFS(C499)는 유형별로 올바른 규칙(C459)을 분리하고 구성한 다. 따라서 모든 조치, 특성, 조건 및 개체는 RSFS(C499) 처리 후 별도로 나열된다. 이를 통해 CTMP 인스 턴스는 카오틱 필드(Chaotic Field)에서 발견된 부분과 그렇지 않은 부분을 식별할 수 있다. 카오틱 필드 구문 파싱(CFP; Chaotic Field Parsing)(C535)는 LOM 로그 집계를 카오틱 필드로 참조되는 단일 스캔 가능한 유닛으로 결합하고 형식화한다. 카오틱 필드는 메모리 인식(MR; Memory Recognition)(C501)에 모듈식 입력으로 제출된다. 또한, MR(C501)은 RSFS(C499)의 실행 결과인 원본 규칙(Original Rules)(C555)을 받는다. MR(C501) 은 CFP(C535)에서 제공하는 카오틱 필드를 스캔하여 원본 규칙(C555)에 정의된 알 수 있는 개념을 인식한다. 상 기 MR(C501) 인스턴스 실행은 인식된 규칙 세그먼트(C556)을 생성한다. 그 후 규칙 이행 파서(RFP; Rule Fulfillment Parser)(C498)은 MR(C501)에 의해 카오틱 필드 내에서 인식 또는 부족에 따라 태그가 지정된 원본 규칙(C555)의 개별 부분을 수신한다. 그런 다음 RFP(C498)은 규칙 실행(RE)(C461)에 의해 처리를 수행하기 위해 카오틱 필드에서 어떤 전체 규칙 집합(모든 부분의 조합)가 충분히 인식되었는지 논리적으로 추론할 수 있다. RE(C461)의 실행이 성공적으로 완료되면 비판적 결정 출력(CDO; Critical Decision Output)(C462)과 병행하여 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)의 모듈식 출력에 의해 처리되는 오버라이 드 수정 조치(Override Corrective Action)(C476)로 이어진다. 도 1057 인지 저장(PS; Perception Storage)(C478)과 자동화된 인지 발견 메커니즘(APDM; Automated Perception Discovery Mechanism)(C467) 사이의 논리 흐름 상호 작용에 대해 자세히 설명한다. PS(C478)에는 인지의 추측된 미지 각도(Deduced Unknown Angles of Perception)(C473), 인지의 모든 각도(All Angles of Perception)(C472), 인지의 함축 각도(Implied Angles of Perception)(C471), 인지의 적용 각도(Applied Angles of Perception)(C470)과 같이 인식의 네 가지 하위 집합을 포함한다. 인지의 적용 각도(C470)은 상기 인스턴스에서 LOM인 선택된 패턴 매칭 알고리즘(SPMA)의 알고리즘 동작을 연구하여 직접 불러온 인식이다. 인지의 함축 각도(C471)은 인지의 적용 각도(C470)에서 암시 도출(ID; implication Derivation)(C477) 및 APDM(C467)의 모듈식 실행을 통해 도출된 인식이다. 인지의 모든 각도(C472)는 인지의 적용 각도(C470) 및 인지 의 함축 각도(C471)에 포함되지 않은 CTMP 인스턴스에 대한 알려진 인식의 전체 범위를 나타낸다. 인지의 추측된 미지 각도(C473)은 CTMP 인스턴스가 셀프 비판적 지식 밀도(SCKD; Self-Critical Knowledge Density)(C474) 모듈에 따라 아직 발견되지 않은 상태에서 존재할 것으로 예상되는 인식의 범위를 나타낸다. APDM(C467)은 초기 두 입력 가중치(C652)를 결합하는 신규 반복(C653)을 생성하도록 창의성 모듈을 통해 인지의 각도(C650)의 구성을 창의적으로 서로 다르게 하지만, ID(C477)은 결정적으로 인지의 적용 각도(C470)을 도출하기 위해 인지의 적용 각도(C470)의 개별 메트릭(metrics)를 분석한다. 따라서 APDM(C467) 처리와 관련된 모든 인지의 각도(C650)은 LOM의 주장 생성(AC)(C808A) 모듈에 의해 생성된 이상적인 투자 결정 메이크업 (Ideal Investment Decision Makeup)에 해당하고 이를 나타낸다.도 1058은 CTMP의 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)에 대한 작동 세 부 사항에 대해 자세히 설명한다. 합리적 어필(RA; Rational Appeal)(C811A) 인스턴스는 LOM 로그 집계(LOM Log Aggregate)를 카오틱 필드 파싱(CFP; Chaotic Field Parsing)(C535)으로 처리하기 위해 LOM 내 에서 작동하고 문맥 구성(CC; Context Construction)(C817A)를 호출한다. CFP는 메모리 인식(MR)(C501)에서 참 조하는 CC(C817A)의 모듈식 출력에서 카오틱 필드를 생성한다. 현재 규칙(C534)는 이 인스턴스에서 LOM인 선택된 패턴 매칭 알고리즘(SPMA; Selected Pattern Matching Algorithm)의 현재 기능 상태를 나타내는 규칙 집합을 표시한다. 현재 규칙(C534)는 규칙 구문 미분(RSD; Rule Syntax Derivation)(C504) 모듈에 모듈식 입력 으로 제출되며, 이는 논리적으로 '흑백' 규칙들은 인식을 기반으로 메트릭을 변환하는 곳이다. 따라서 여러 규 칙의 복잡한 배열은 다양한 그래디언트의 여러 메트릭(metrics)를 통해 표현되는 단일 균일 인식으로 변환된다. 규칙 구문 미분(RSD; Rule Syntax Derivation)(C504)의 모듈식 출력은 인색 매칭(PM; Perception Matching)(C503)에 모듈식 입력으로 제공된다. PM(C503)에서, 비교 가능한 가변 포맷(CVF; Comparable Variable Format) 유닛은 규칙 구문 생성(RSD; Rule Syntax Generation)(C505)에서 수신한 인식으로 구성된다. 새로 형성된 CVF는 유사한 인덱스를 가진 인지 저장(PS)(C478)에서 관련 인식을 검색하는 것으로 사용된다. 잠 재적 일치 항목은 규칙 구문 생성(RSG; Rule Syntax Generation)(C505)에 모듈식 입력으로 제출된다. RSG(C505)는 인식 형식으로 저장된 이전에 확인된 인식을 수신하고 인식의 내부 메트릭 구성에 접근한다. 인식 은 이전에 확인된 인식(C468)이 포함된 PS(C478)에서 수신된다. 이러한 메트릭(metrics)의 그래디언트 기반 측 정은 원래 인식의 입력/출력 정보 흐름을 에뮬레이트하는 이진법 및 논리 규칙 집합으로 변환된다. 따라서 RSG(C505)는 관련성이 있고 대중적으로 고려되며 논리적 규칙으로 변환된 인식(Perceptions)인 인지 규칙 (Perceptive Rules)(C537)을 생성한다. 만약 (초기 인식 포맷에서) 인식이 많은 '회색 영역'을 정의한 많은 복 잡한 메트릭 관계가 있는 경우, '흑백' 로컬 규칙은 규칙 집합 복잡도를 확장함으로써 이러한 '회색' 영역을 포 함한다. 따라서 인지 규칙(C537)은 규칙 구문 포맷(RSF; Rule Syntax Format) 정의의 모음으로 저장된다. 인지 규칙(C537)은 메모리 인식(MR)(C501)에 모듈식 입력으로 제출되며, 메모리 인식(MR)(C501)에서 CFP(C535)에 의 해 생성된 카오스 필드에 대해 스캔된다. 따라서 MR(C501)은 유효성 있는 올바른 규칙(C533)을 완성하는 추가 규칙(C536)을 생성한다. 도 1059는 CTMP의 암시 도출(ID; Implication Derivation)(C477)에 대한 작동 세부 사항에 대해 자세히 설명한다. 인지 저장(PS; Perception Storage)(C478)의 인지의 적용 각도(Applied Angles of Perception)(C470)은 인지의 함축 각도(Implied Angles of Perception)(C471)에 속하는 더 많은 인식을 생성하 기 위해 모듈식 입력으로 ID(C477)에 제출된다. 인지의 적용 각도(C470)은 구체적으로 ID(C477)의 메트릭 조합 (C493)으로 전송된다. 메트릭 조합(C493)은 메트릭(metrics)의 카테고리에 대해 수신된 인지의 각도(C650)을 범 위(Scope)(C739), 유형(Type)(C740), 일관성(Consistency)(C741), 강도(Intensity)(C742)로 구분한다. 시스템 내에서 메트릭 가용성 및 참조가 반드시 상기 네 가지 유형으로 제한되는 것은 아니다. 인지의 각도(C650) 입력 은 LOM의 주장 생성(AC; Assertion Construction)(C808A) 모듈에 의해 생성된 이상적인 투자 결정 메이크 업(Ideal Investment Decision Makeup)와 관련이 있다. 메트릭 복잡도 세트 A(C736)는 메트릭 확장(ME; Metric Expansion)(C495)에 모듈식 입력으로 제출된다. ME(C495)를 사용하여 여러 인식의 각도(C650) 및 다양 한 각도의 메트릭은 개별 데이터베이스 C739, C740, C741, C742 카테고리 별로 저장된다. ME(C495)는 이전에 알 려진/접한 메트릭에서 추출된 세부 사항/복잡도로 수신된 메트릭의 현재 배포를 향상시킨다. 향상 및 복잡도 강 화 완료에 따라, 메트릭은 메트릭 복잡도 세트 B(C737)로 ME(C495) 모듈식의 출력으로 반환되고 그 후에 도 1060에 설명된 바와 같이, 인지의 함축 각도(C471)에 저장되도록 인지의 각도(C650)로 다시 변환된다. 도 1060은 개별 메트릭을 전체 인지의 각도(C650)로 되돌리는 메트릭 변환(C494)에 의해 처리되는 메트릭 복잡 도 세트 B(C737)를 설명하는 도 1059으로부터 암시 도출(ID; Implication Derivation)(C477)의 논리 흐름을 계 속한다. ID(C477)에 의해 수행된 향상 및 변환 프로세스에도 불구하고, 생성된 인지의 각도(the resultant Angles of Perception)(C650)는 여전히 LOM의 주장 생성(AC; Assertion Construction)(C808A) 모듈에 의 해 생성된 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)의 합리적으로 정확한 묘사 를 제공한다. 따라서 메트릭 변환(Metric Conversion)(C494) 프로세스는 새로 도출/암시된 인식의 각도(C650)를 인지 저장(PS)(C478) 내의 인지의 함축 각도(Implied Angles of Perception)(C471)에 제출한다. 도 1061는 CTMP의 비판적 결정 출력(CDO; Critical Decision Output)(C462)에 대한 작동 세부 사항에 대 해 자세히 설명한다. CDO(C462)는 CTMP의 두 가지 주요 브랜치로부터 모듈식의 출력을 수신하고, (직관력 브랜치로서) 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)와 (논리적 브랜치로서) 규칙 실행(RE; Rule Execution)(C461)가 있다. 각 브랜치 C475/461은 그것의 각각의 비판적 결정(CriticalDecision)(C521) (메인 모듈식의 출력)뿐 아니라 해당하는 '메타-메타 데이터(Meta-metadata)'(C521)을 제출하 며, 이는 초기 비판적 결정(initial critical decision)에 도달한 이유를 정당화하는 맥락 변수를 제공한다. POE(C475)의 인식(C516)과 RE(C461)의 이행된 규칙(C517)을 나타내는 두 결정 세트(C521)는 메타데이터 분류 모듈(MCM; Metadata Categorization Module)(C488)에 제출된다. MCM(C488)은 전통적인 구문 기반 정보 카테고 리화를 사용하여 디버깅 및 알고리즘 추적을 개별의 카테고리로 분류한다. 그러면 이러한 카테고리는 보안 위험 과 대상과의 상관관계를 가지고 분명한 보안 대응을 조직하고 생성할 수 있다. POE(C475)의 인식(C526)을 나타 내는 직관적 의사 결정(Intuitive Decision)(C514)와 RE(C461)의 이행된 규칙(C517)을 나타내는 사고 결정 (C515)은 MCM(C488)에 의해 방향 결정 비교(DDC)(C512)의 내부 프로세싱 로직에 제출된다. DDC(C512)의 내부 프로세싱 로직은 직관적 의사 결정(C514)와 사고 결정(C515) 사이의 확증 또는 충돌을 확인한다. DDC(C512)는 정적 하드코드된 정책(SHP; Static Hardcoded Policy)의 '차단 변수(cutoff variable)'를 참 조한다. 만약 차단 변수는 직관적 의사 결정(C514)와 사고 결정(C515) 사이에 유사성에 도달하지 않으면 (예를 들어, 90 % +), 무효화 직접 비교(Cancel Direct Comparison)는 직접 발생하며, 이는 도 1062에 도시된 바와 같이, 확신없는 투표(Vote of No Confidence)에 최종적으로 제출하도록 터미널 출력 제어(TOC; Terminal Output Control)(C513)에 연결된다. 무효화 직접 비교 단계는 CTMP가 이상적인 구성 호출 프롬프트(ICIP; Idealistic Configuration Invocation Prompt)의 프롬프트 입력과 관련하여 내 부적으로 일관성 있는 작동할 수 없음을 의미한다. 만약 '차단 변수가 내부 프로세싱 로직에 따라 충분히 충족되면, 최종 비판적 출력(Final Critical Decision) 단계가 터미널 출력 제어(TOC)(C513)에 의해 수 신 및 처리되는 단일 모듈식의 출력으로 두 결정 C514/C515를 결합하여 호출한다. 도 1062은 도 1061의 비판적 결정 출력(CDO; Critical Decision Output)(C462)의 논리 흐름을 계속하고 터미널 출력 제어(TOC; Terminal Output Control)(C513)의 작동 세부 사항을 자세히 설명한다. TOC(C513)은 방향 결정 비교(DDC; Direct Decision Comparison)(C512)가 (무효화 직접 비교(Cancel Direct Comparison) 지시 대 신) 최종 비판적 출력(Final Critical Decision)을 제공할 수 있는지 확인하는 프롬프트로 시작한 다. 프롬프트에 대한 응답이 Yes인 경우, 최종 비판적 출력(Final Critical Decision)에서 DDC(C512)에 의해 제공된 결합된 최종 결정은 TOC(C513)의 모듈식 출력으로 제출되며, 따라서 최종 임계 결정 으로 전체 CTMP 인스턴스의 모듈식 출력으로서 제출된다. 프롬프트에 대한 응답이 No인 경우, 5532단계가 자체적으로 인식 매칭(PM; Perception Matching)의 실행을 호출하고 해당 결과를 가져 오게 되어 호출된다. 이행된 규칙(C517)은 규칙 실행(RE; Rule Execution)(C461)의 비판적(critical) 결정 + 메타-메타 데이터(C521)에서 추출된다. 규칙(C517)은 규칙 구문 미분(RSD; Rule Syntax Derivation)(C504)에 의해 인식으로 변환된다. 그 다음에, PM는 프롬프트에서 강력한 내부 중복(strong internal overlap)과 사용된 인식의 확증(corroboration of Perceptions)이 있는지 결정하기 위해 메타-메타 데이터를 참조한다. 만약 프롬프트에 대한 응답이 예인 경우, 모듈식 출력으로 CTMP 대신하여 확신없는 투표(Vote of No Confidence)를 나타낸다. 만약 프롬프트에 대한 응답이 No인 경우, 5540단 계가 활성화되어 직관적 의사 결정(Intuitive Decision)(C514)와 사고 결정(Thinking Decision)(C515) 사이에 서 인식된 가장 위험이 덜한 결정을 선택한다. 따라서 최종 임계 결정는 비판적 결정 출력(CDO; Critical Decision Output)(C462), TOC(C513) 및 CTMP에 모듈식 출력으로 제출된다. 5534단계의 논리는 직관적 의 사 결정(C514)와 사고 결정(C515) 사이의 일치성 부족이 알고리즘에 대한 신뢰가 부족하거나, 둘 사이의 반대되 는 관점 때문에 발생하는지 여부를 판별하기 위해 발생한다. 따라서 후자가 발생할 경우, 잠재적인 최종 임계 결정는 여전히 모듈식 출력으로 식별할 수 있다. 확신없는 투표는 항상 합리적 어필(RA; Rational Appeal)(C811A) 내에서 신뢰도가 낮은 신뢰도 결과(C845) 논리 경로로 이어진다. 최종 임계 결정는 최종 임계 결정 뒤에 알고리즘 신뢰도에 따라 RA(C811A) 내에서 높은 신뢰도 결과()(C846) 또는 낮은 신뢰도 결과(C845) 논리 경로로 이어질 수 있다"}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 5, "content": "도 1063은 도 1042 및 도 1043로부터 종합 상태 평가(CSE; Comprehensive State Evaluation)의 요약 논 리를 계속한다. 알고리즘으로서의 CSE의 핵심 부분 기능은 12402단계에 있으며, 여기서 LOM 및 CTMP의 일차적 호출이 이루어진다. 12402단계의 완료된 실행은 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)을 생성한다. 이어서, 메이크업은 l2GE를 통해 스트레스 테스 트 및 수정되는 12450단계로 전송된다. 12450 단계는 변수에 의해 정의된 환경에서 이상적인 투자 결정 메이크 업의 성과를 모방하는 다양한 진화 경로를 생성하기 위해 l2GE를 호출하며, 세금 책임 지식(Tax Liability Knowledge), 시장 활동 지식(Market Activity Knowledge), 규제 준수 지식 (Regulatory Compliance Knowledge) 및 법인 운영 지식 (Corporate Operations Knowledge)가 있다. 12450단계의 작동 결과는 이상적인 투자 결정 메이크업이 정적 하드코드된 정책(SHP; StaticHardcoded Policy)에 정의된 안정성 요구 사항을 통과할 수 있는지를 판단하는 프롬프트로 전송된 다. 프롬프트에 대한 두 가지 포텐셜(potential) 반응은 이상적인 투자 결정 메이크업가 충분히 안정적임(Sufficiently Stable) 또는 충분히 안정적이지 않음(Not Sufficiently Stable)이라는 것이다. 충분히 안정적임(Sufficiently Stable) 응답은 CSE의 모듈식 출력으로 정제 된 투자 결 정 메이크업(Refined Investment Decision Makeup)의 최종적인 생산으로 이어진다. 도 1064는 종합 상태 평가(CSE; Comprehensive State Evaluation)에서 12450단계의 작동을 자세히 설명 한다. 초기 12460단계는 타겟 투자 정황(Target Investment Circumstances)을 목적 계층 맵으로 변환하기 위해 LIZARD를 호출하여 실행된다. 그 후, 맵는 12464단계로 전달되고 블랭크 전체론적 상황 상태(blank Wholistic Situation State)을 만든다. 12466상황은 논리 흐름의 상기 12464단계에서 맵의 실제 복제본(practical clone)이며, 이는 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)을 l2GE를 통해 측정하는 '환경'을 정의하는 전체 변수 범위를 캡슐화하기 위해 나중에 단일 변수로 참조된다. 12468단계에서, LIZARD은 시장 활동 지식(Market Activity Knowledge)을 목적 계층 맵으로 변환하기 위해 호출된다. 12470단계에서, LIZARD는 세금 책임 지식(Tax Liability Knowledge)을 목적 계층 맵으로 변환하기 위해 호출된다. 도 1065는 타겟 투자 정황(Target Investment Circumstances)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 타겟 투자 정황(Target Investment Circumstances)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능 성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 타겟 투자 정황은 코드 변환(C321)에 의해 지식 구문(Knowledge Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인 식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문 (C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논 리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모 듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷 (C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각 을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정 의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프 로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리 (Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1066은 타겟 투자 정황(Target Investment Circumstances)을 목적 계층 맵(Purpose Hierarchy Map))으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1065의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36) 의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 타겟 투자 정황의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1067은 시장 활동 지식(Market Activity Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)(1247 2)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 시장 활동 지식(Market Activity Knowledge)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드 를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출 하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 시장 활동 지식은 코드 변환(C321)에 의해 지식 구문(Knowledge Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의 (일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완 료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도 출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능 성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷 (C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동 화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함 한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1068은 시장 활동 지식(Market Activity Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)(1247 2)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1067의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해 석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 시장 활동 지식의 복합 목적 포맷(C325) 버전 으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1069는 종합 상태 평가(CSE; Comprehensive State Evaluation)에서 12450단계의 논리 흐름을 계속한 다. 논리는 도 1064에서 계속되고 12470단계에서 다시 시작되며, 이는 세금 책임 지식(Tax Liability Knowledge)에서 목적 계층 맵(Purpose Hierarchy Map)를 생성한다. 12476단계에서, LIZARD(12 0)은 규제 준수 지식(Regulatory Compliance Knowledge)을 목적 계층 맵으로 변환하기 위해 호 출된다. 12480 단계에서, LIZARD은 법인 운영 지식(Corporate Operations Knowledge)을 목적 계층 맵으로 변환하기 위해 호출된다. 그 후, 12484단계가 시장 활동 지식(Market Activity Knowledge)의 전체론적 상황 상태(Wholistic Situation State) 및 목적 계층 맵를 처리 하기 위해 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)을 호출하여 실행된 다. 상기 12484단계에서, 전체론적 상황 상태는 타겟 투자 정황(Target Investment Circumstances)의 목적 계층 맵의 동등한 컨텐츠를 포함한다. P2SP의 실행은 두 입력 변수의 호환성(compatibility)/일치성(congruency) 측정을 생성한다. 도 1070은 세금 책임 지식(Tax Liability Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으 로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 세금 책임 지식(Tax Liability Knowledge)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드 를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출 하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 세금 책임 지식은 코드 변환(C321)에 의해 지식 구문(Knowledge Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의 (일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완 료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도 출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능 성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷 (C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동 화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함 한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1071은 세금 책임 지식(Tax Liability Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으 로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1070의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석 (Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 세금 책임 지식의 복합 목적 포맷(C325) 버전 으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1072는 규정 준수 지식(Regulatory Compliance Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 규정 준수 지식(Regulatory Compliance Knowledge)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드 를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출 하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 규정 준수 지식은 코드 변환(C321)에 의해 지식 구문(Knowledge Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완 료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도 출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능 성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷 (C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동 화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함 한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1073은 규정 준수 지식(Regulatory Compliance Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1072의 논리 흐름을 계속한다. 구문 모 듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 규정 준수 지식의 복합 목적 포맷(C325) 버전 으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1074는 법인 운영 지식(Corporate Operations Knowledge)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 법인 운영 지식(Corporate Operations Knowledge)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드 를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출 하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 규정 준수 지식(Regulatory Compliance Knowledge)은 코드 변환(C321)에 의해 지식 구문(Knowledge Syntax) 형식으로 수신된다. 코드 변 환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수 (inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단 한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴 퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C3 5)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C32 6)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프 한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전 문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1075는 법인 운영 지식(Corporate Operations Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1074의 논리 흐름을 계속한다. 구문 모 듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 법인 운영 지식의 복합 목적 포맷(C325) 버전 으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1076은 종합 상태 평가(CSE; Comprehensive State Evaluation)에서 12450단계의 논리 흐름을 계속한 다. 논리는 도 1069에서 계속되고 12484단계에서 재개된다. 12484단계는 두 가지 입력 전체론적 상황 상태 (Wholistic Situation State) 및 시장 활동 지식(Market Activity Knowledge)의 목적 계층 맵 입력과 일치하는 대칭 처리 결과(Symmetry Processing Result)을 생성하기 위해 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)을 호출한다. 대칭 처리 결과(Symmetry Processing Result)은 시장 활동 지식(Market Activity Knowledge)의 목적 계층 맵가 전 체론적 상황 상태(Wholistic Situation State)과 일치(congruent)/호환(compatible) 되는지 평가하는 프롬프트로 전송된다. 타겟 투자 정황(Target Investment Circumstances)에 정의된 변수에는 시 장 활동 지식과의 비호환성(incompatibilities)을 포함해서는 안되기 때문에, 시스템에 의해 예상되는 결과는 일치한다는 것이다. 타겟 투자 정황은 12484단계에서 전체론적 상황 상태(Wholistic Situation State)에 대한 컨텐츠와 동일하기 때문에 참조된다. 12450단계의 지속적인 실행은 타겟 투자 정황 의 확립된 변수를 모순하는 변수를 포함하지 않기 위해 시장 활동 지식을 필요로 한다. 이는 시 장 활동 지식이 단언적으로 이상적인 투자 행위/응답에 영향을 미치는 정황(circumstances)의 요소이기 때문이다. 따라서 프롬프트에 대한 응답이 불일치(Not Congruent)인 경우, 진단 로그 제출(DLS; Diagnostic Log Submission)은 오류 보고서 제출(Error Report Submission) 역할을 하는 진단 로그 유닛 (DLU; Diagnostic Log Unit)와 함께 호출된다. 프롬프트에 대한 응답이 일치(Congruent) 로 간주되는 경우, 12496단계는 목적 재조정 처리(PRP; Purpose Realignment Processing)을 통해 시장 활동 지식의 목적 계층 맵와 일치하도록 전체론적 상황 상태을 조정하여 호출된다. 마스 터/슬레이브 선호도(Master/Slave Affinity)는 전체론적 상황 상태를 마스터로 정의하기 위해 12496단계에 공급되고, 시장 활동 지식의 목적 계층 맵이 슬레이브로 취급된다. 이것은 두 입력 12466 및 12472 사이에서 수행되는 차등 변경(differential changes)이 12496단계의 결과 출력으로서 제출되는 전체론적 상황 상태로 이행된다는 것을 의미한다. 따라서, 전체론적 상황 상태은 도 1077로 이어 지고 그 후, 12500단계에 의해 처리된다. 도 1077은 종합 상태 평가(CSE; Comprehensive State Evaluation)에서 12450단계의 논리 흐름을 계속한 다. 논리는 그림 1076에서 계속되고 12500단계에서 재개된다. 12500단계는 두 입력인 세금 책임 지식(Tax Liability Knowledge)의 전체론적 상황 상태(Wholistic Situation State) 및 목적 계층 맵 에 해당하는 대칭 처리 결과(Symmetry Processing Result)를 생산하기 위해 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)을 호출한다. 대칭 처리 결과는 세금 책임 지식의 목적 계층 맵는 전체론적 상황 상태과 일치/호환되는지 판단하는 프롬프트(1250 4)로 전송된다. 타겟 투자 정황(Target Investment Circumstances)및 시장 활동 지식(Market Activity Knowledge)에 정의된 변수는 세금 책임 지식과의 비호환성(incompatibilities)을 포함해서는 안 되기 때문에, 시스템에 의해 예상되는 결과는 일치한다는 것이다. 전체론적 상황 상태의 컨텐츠를 12500 단계에서 포함하고 나타내기 때문에, 타겟 투자 정황 및 시장 활동 지식은 참조된다. 12450단계 의 지속적인 실행은 타겟 투자 정황의 확립된 변수를 모순하는 변수를 포함하지 않기 위해 세금 책임 지 식을 필요로 한다. 이는 세금 책임 지식이 단언적으로 이상적인 투자 행위/응답에 영향을 미치는정황(circumstances)의 요소이기 때문이다. 따라서 프롬프트에 대한 응답이 불일치(Not Congruent)인 경우, 진단 로그 제출(DLS; Diagnostic Log Submission)은 오류 보고서 제출(Error Report Submission) 역할을 하는 진단 로그 유닛(DLU; Diagnostic Log Unit)와 함께 호출된다. 프롬프트 에 대한 응답이 일치(Congruent)로 간주되는 경우, 12512단계는 목적 재조정 처리(PRP; Purpose Realignment Processing)을 통해 세금 책임 지식의 목적 계층 맵과 일치하도록 전체론적 상황 상태를 조정하여 호출된다. 마스터/슬레이브 선호도는 전체론적 상황 상태를 마스터 로 정의하기 위해 12496단계에 공급되고, 세금 책임 지식의 목적 계층 맵이 슬레이브로 취급된다. 이것은 두 입력 12466 및 12474 사이에서 수행되는 차등 변경(differential changes)이 12512단계의 결과 출력으로서 제출되는 전체론적 상황 상태로 이행된다는 것을 의미한다. 따라서, 전체론적 상황 상 태은 도 1078로 이어지고 그 후, 12500단계에 의해 처리된다. 도 1078은 종합 상태 평가(CSE; Comprehensive State Evaluation)에서 12450단계의 논리 흐름을 계속한 다. 논리는 도 1077에서 계속되고 12500단계에서 재개된다. 12500단계는 두 입력인 규제 준수 지식(Regulatory Compliance Knowledge)의 전체론적 상황 상태(Wholistic Situation State) 및 목적 계층 맵 에 해당하는 대칭 처리 결과(Symmetry Processing Result)를 생산하기 위해 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)을 호출한다. 대칭 처리 결과는 규제 준수 지식의 목적 계층 맵는 전체론적 상황 상태과 일치/호환되는지 판단하는 프롬프트(1252 4)로 전송된다. 타겟 투자 정황(Target Investment Circumstances), 시장 활동 지식(Market Activity Knowledge) 및 세금 책임 지식(Tax Liability knowledge)에 정의된 변수는 규제 준수 지식 과의 비호환성(incompatibilities)을 포함해서는 안되기 때문에, 시스템에 의해 예상되는 결과는 일치한 다는 것이다. 전체론적 상황 상태의 컨텐츠를 12520단계에서 포함하고 나타내기 때문에, 타겟 투자 정황 , 시장 활동 지식 및 세금 책임 지식은 참조된다. 12450단계의 지속적인 실행은 타겟 투 자 정황의 확립된 변수를 모순하는 변수를 포함하지 않기 위해 규제 준수 지식을 필요로 한다. 이는 규제 준수 지식이 단언적으로 이상적인 투자 행위/응답에 영향을 미치는 정황(circumstances)의 요 소이기 때문이다. 따라서 프롬프트에 대한 응답이 불일치(Not Congruent)인 경우, 진단 로그 제 출(DLS; Diagnostic Log Submission)은 오류 보고서 제출(Error Report Submission) 역할을 하는 진단 로그 유닛(DLU; Diagnostic Log Unit)와 함께 호출된다. 프롬프트에 대한 응답이 일치 (Congruent)로 간주되는 경우, 12532단계는 목적 재조정 처리(PRP; Purpose Realignment Processing)을 통해 규제 준수 지식의 목적 계층 맵과 일치하도록 전체론적 상황 상태 를 조정하여 호출된다. 마스터/슬레이브 선호도는 전체론적 상황 상태를 마스터로 정의하 기 위해 12532단계에 공급되고, 규제 준수 지식의 목적 계층 맵이 슬레이브로 취급된다. 이것은 두 입력 12466 및 12478 사이에서 수행되는 차등 변경(differential changes)이 12532단계의 결과 출력으로서 제출되는 전체론적 상황 상태로 이행된다는 것을 의미한다. 따라서, 전체론적 상황 상태은 도 1079로 이어지고 그 후, 12540단계에 의해 처리된다. 도 1079는 종합 상태 평가(CSE; Comprehensive State Evaluation)에서 12450단계의 논리 흐름을 계속한 다. 논리는 도 1078에서 계속되고 12540단계에서 재개된다. 12540단계는 두 입력인 법인 운영 지식(Corporate Operations Knowledge)의 전체론적 상황 상태(Wholistic Situation State) 및 목적 계층 맵 에 해당하는 대칭 처리 결과(Symmetry Processing Result)를 생산하기 위해 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)을 호출한다. 대칭 처리 결과는 법인 운영 지식의 목적 계층 맵는 전체론적 상황 상태과 일치/호환되는지 판단하는 프롬프트(1254 4)로 전송된다. 타겟 투자 정황(Target Investment Circumstances), 시장 활동 지식(Market Activity Knowledge), 세금 책임 지식 및 규제 준수 지식(Regulatory Compliance Knowledge)에 정 의된 변수는 법인 운영 지식과의 비호환성(incompatibilities)을 포함해서는 안되기 때문에, 시스템에 의해 예상되는 결과는 일치한다는 것이다. 전체론적 상황 상태의 컨텐츠를 12540단계에서 포함하고 나타 내기 때문에, 타겟 투자 정황, 시장 활동 지식, 세금 책임 지식 및 규제 준수 지식 (Regulatory Compliance Knowledge)은 참조된다. 12450단계의 지속적인 실행은 타겟 투자 정황 의 확립된 변수를 모순하는 변수를 포함하지 않기 위해 법인 운영 지식을 필요로 한다. 이는 법인 운영 지식이 단언적으로 이상적인 투자 행위/응답에 영향을 미치는 정황(circumstances)의 요소이기 때문이다. 따라서 프롬프트에 대한 응답이 불일치(Not Congruent)인 경우, 진단 로그 제출(DLS; Diagnostic Log Submission)은 오류 보고서 제출(Error Report Submission) 역할을 하는 진단 로그 유닛 (DLU; Diagnostic Log Unit)와 함께 호출된다. 프롬프트에 대한 응답이 일치(Congruent)로 간주되는 경우, 12552단계는 목적 재조정 처리(PRP; Purpose Realignment Processing)을 통해 법인 운영 지식의 목적 계층 맵과 일치하도록 전체론적 상황 상태를 조정하여 호출된다. 마스 터/슬레이브 선호도는 전체론적 상황 상태를 마스터로 정의하기 위해 12552단계에 공급되고, 규 제 준수 지식의 목적 계층 맵이 슬레이브로 취급된다. 이것은 두 입력 12466 및 12482 사이에서 수행되는 차등 변경(differential changes)이 12466단계의 결과 출력으로서 제출되는 전체론적 상황 상태 로 이행된다는 것을 의미한다. 따라서, 전체론적 상황 상태은 도 1080로 이어지고 그 후, 12554 단계에 의해 처리된다. 도 1080은 종합 상태 평가(CSE; Comprehensive State Evaluation)에서 12450단계의 논리 흐름을 계속한 다. 전체론적 상황 상태(Wholistic Situation State)는 도 1079의 12552단계에 의해 수신된다. 따라서 12554단계는 LIZARD의 다이나믹 쉘(DS; Dynamic Shell)(C198)에 존재하는 서브 모듈인 니드 맵 매칭(NMM; Need Map Matching)(C114)에 12466단계를 공급한다. NMM(C114)는 12466단계를 12466단계 내에서 발견된 다양한 요소를 분류하는 관할구역으로 분석한다. 따라서 12556단계은 해당 NMM(C114) 인스턴스 내에 형성된 관할구역 브랜치에 의해 정의된 포텐셜(potential) 시나리오를 참조하기 위해 인공 보안 위협(AST; Artificial Security Threat)을 호출한다. 그 후 12558단계에서, AST 처리의 결과는 NMM(C114) 관할구역 브랜치에 의해 정의된 시나리오가 창의성 모듈(Creativity Module)을 통해 창의적으로 변화된다는 것이다. 도 1081은 LIZARD의 다이나믹 쉘(DS; Dynamic Shell)(C198)의 서브모듈로 작동하는 니드 맵 매칭(NMM; Need Map Matching)(C114)의 작동 및 기능을 도시한다. NMM(C114) 인스턴스는 종합 상태 평가(CSE; Comprehensive State Evaluation)의 12450단계의 작동을 제공하기 위해 생성된다. 전체론적 상황 상태 (Wholistic Situation State)은 니드 액세스 개발 및 스토리지(Need Access and Development and Storage)에 저장하기 위해 제출된다. 따라서 전체론적 상황 상태은 서브 카테고리로 분류되고 일 련의 계층적 브랜치 및 레이어으로 스토리지에 유지된다. NMM(C114)의 모듈식 호출에 따라, 초기 구문 분 석(Initial Parsing)(C148)은 진행중인 NMM(C114) 인스턴스 내에서 참조하기 위해 일시적으로 유지하도록 스토 리지에서 각 관할구역 브랜치를 다운로드한다. 브랜치 니드 계산(Calculate Branch Needs)(C149)으로, 각 브랜치와 관련된 정의에 따라, 니드(needs)는 해당 부서와 연관되어 있다. 상기 방법으로, 권한 검사 (permission checks)는 NMM(C114) 인스턴스 내에서 구성될 수 있다. 예를 들어, 직원의 능력에 따라 직원 성과 를 매년 검토하는 영역 내에서 요청되었기 때문에 NMM(C114)는 모든 직원 CV를 다운로드하도록 인사부서에 요청 을 승인했다. 따라서 부서 관할구역의 유효한 필요성(needs)임을 입증되었다. 따라서 니드 인덱스(C145)는 관할 구역 브랜치와 및 각각의 니드의 메인 스토리지이다. 이 내부 참조는 NMM(C114) 및 제공되는 모든 모듈의 작동 에 대한 리소스 병목 현상이기 때문에, 시스템의 전반적인 효율성을 높이기 위해 빠른 데이터베이스 쿼리에 미 리 최적화되어 있다. 인공 보안 위협(AST; Artificial Security Threat)은 입력 목적(Input Purpose)(C139)을 NMM(C114)의 검색 알고리즘(Search Algorithm)(C144)에 모듈식 입력으로 제공한다. 입력 목 적(C139)가 니드 액세스 개발 및 스토리지에 초기에 정의된 관할구역 브랜치에 따라 유효한 니드를 정의 하는지 판별하므로, 검색 알고리즘(C144)는 컴파일된 니드 인덱스(C145)를 통해 참조하고 검색한다. 따라서 니 드 인덱스(C145)를 통해 검색 알고리즘(C144)의 완료된 실행은 NMM(C114)의 모듈식 출력으로 제출되고 니드 결 과(C141)로 참조되는 승인/차단(C146) 응답을 생성한다. 따라서 니드 결과(C141)는 입력 목적(C139) 제출에 대 한 응답으로 AST로 되돌아간다. 도 1082는 종합 상태 평가(CSE; Comprehensive State Evaluation)에서 12450단계의 논리 흐름을 계속한 다. 논리는 단계 12558에서 재개된다. 그 후, 12560단계는 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)를 모듈식 입력으로 받아 실행된다. 메이크업는 메이크업를 정의하는 변수 세트에 모호한 범위가 존재할 수 있는 경우, 약간의 변형(Variations)를 생성하기 위해 입력 창의 적 변수(ICV; Input Creative Variance)에 의해 해석된다. I2GE에 의해 에뮬레이트되는 해당 진화 경로(Evolution Pathways)(C867A)를 포함하는 경로 특성(Pathway Personalities)(C867D)로 사용될 수 있으므로, 생성된 메이크업 변형(Makeup Variations)는 12564단계로 전송된다. 도 1083은 종합 상태 평가(CSE; Comprehensive State Evaluation)의 12564단계에서 확장한다. 도 1082 의 논리 흐름의 일부는 입력 창의적 변수(ICV; Input Creative Variance)에 의해 처리되어 메이크업 변 형(Makeup Variations)를 생성하는 이상적인 투자 결정 메이크업(Ideal Investment Decision"}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "Makeup)를 도시하기 위해 요약된다. 변형(Variations)는 12565단계에서 논리적으로 (logistically) 분석(unpacked)되며, 실행 액세스를 가능하게 하기 위해 암호화(encryption), 압축 (compression) 및 최적화(optimization)의 모든 레이어가 반전되는 것을 의미한다. 그 후 12566단계에서, 메이크업 변형(Makeup Variations)은 모니터링 상호작용 시스템(Monitoring Interaction System)(C868D)을 통해 경로 특성(Pathway Personalities) C867DA/C867DB로 설치된다. 모니터링 상호작용 시스템(C868D)는 l2GE에 의해 수행된 에뮬레이션(emulation)을 감시하고 조작하는 외부기능을 위해 API 레이어로 역할을 한 다. 설치된 변형는 각각 진화 경로(Evolution Pathway)(C867A)가 진화하는 방향을 정의하는 개별 경로 특성(Pathway Personality)(C867D)와 관련이 있다. 따라서, 다수의 변형에 따르면, 적어도 하나의 진화 경로(C867A)는 시스템이 추구하는 구성을 성공적으로 달성할 것을 예상된다. 상기 특정 인스턴스에서 추구하는 특정 메이크업은 전체론적 상황 상태(Wholistic Situation State)의 제공된 니드 맵 매칭(NMM; Need Map Matching)(C114) 관할구역 브랜치와 가장 호환되는 이상적인 투자 결정 메이크업의 변형이다. 진화 경로(C867A)의 독립 인스턴스는 데이터 독립성(data independence)과 교차 오염(cross- contamination)이 없음을 확신하는 가상 격리(Virtual Isolation)으로 분리된다. 따라서 결과는 논리적으 로 해당 경로 특성(C867D)에서 파생된 것으로 확신한다. 도 1084는 종합 상태 평가(CSE; Comprehensive State Evaluation)으로부터 12450단계의 문맥에서, 도 1083에 제공된 논리 흐름을 계속한다. l2GE에 관한 동일한 논리가 앞으로 반복 결론 프로세서(Iteration Conclusion Processor)에 진화 경로(Evolution Pathway)(C867A) 에뮬레이션(emulation)의 결과와 관련된 생산 결과를 제공하는 모니터링 상호작용 시스템(Monitoring Interaction System)(C868D)와 함께 도시되어 있 다. 프로세서는 l2GE 에뮬레이션의 결과와 관련하여 중요한 결론에 도달하고, 따라서 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)가 정적 하드코드된 정책(SHP; Static Hardcoded Processing)에 정의된 안정성 요구 사항을 통과할 수 있는지 확인하는 프롬프트로 이어진다. 반복 결론 프로세서에 의해 고려될 수 있는 두 포텐셜(potential) 결론/응답은 충분히 안정적임(Sufficiently Stable)과 충분히 안정적이지 않음(Not Sufficiently Stable)이 있다. 도 1085는 단일 진화 경로(Evolution Pathway)(C867A) 내에서 반복되는 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)의 특정 세대(generational) 반복을 도시함으로써, 도 1084에 도시 된 논 리 흐름을 자세히 설명한다. 따라서 경로(C867A)는 경로 특성(Pathway Personality)(C867D)에 정의된 메트릭 (metrics)을 따른다. 그러므로 진화 방향(evolutionary direction)이 정의된다. 경로 지정(Pathway Designation)은 주어진 진화 경로(C867A)의 상태를 결정한다. 이러한 상태는 안정됨으로 전달됨(Passed as Stable), 진화를 기다림(Pending Evolution), 포기/삭제(Abandoned/Deleted)로 지정할 수 있다. 도 1086은 프롬프트에서 재개되는 종합 상태 평가(CSE; Comprehensive State Evaluation)의 메 인 논리 흐름을 계속한다. 12450단계는 l2GE를 호출하는 메인 단계이며, 프롬프트으로 이어진다. 프롬프트에 대한 응답이 에뮬레이션(emulation)이 충분히 안정적이지 않음(Not Sufficiently Stable)인 경우, l2GE는 응답 코드를 수신하며, 아마 재량에 따라, 이전에 실패한 에뮬레이션과 차 이를 정의하는 변수의 분산을 포함하는 에뮬레이션을 다시 실행한다. 프롬프트에 대한 응답이 충분히 안정적임(Sufficiently Stable)인 경우, 12586단계는 정제된 투자 결정 메이크업(Refined Investment Decision Makeup)으로 에뮬레이션 결과를 생성하여 호출된다. 그 후 12588단계에서, 정제된 투자 결정 메이크업은 개별 요소인 투자 할당(Investment Allocations), 투자 인출(Investment Withdrawals), 이익 배분(Profit Allocations) 및 디렉터 통보(Director Notification)(1259 8)를 생산하기 위해 논리적으로(logistically) 분석(unpacked)된다."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 7, "content": "도 1087은 종합 상태 평가(CSE; Comprehensive State Evaluation)의 최종 개요 요약을 도시한다. 예비 스레드 개시(PTI; Preliminary Thread Initiation) 모듈은 타겟 투자 상황 해석(TICI; Target Investment Circumstances Interpretation)의 인스턴스를 시작한다. TICI은 내부 처리(Internal Processing) 메커니즘에 타겟 투자 정황(Target Investment Circumstances)을 생성한다. CSE의 전체 처리는 정제된 투자 결정 메이크업(Refined Investment Decision Makeup)을 섹션 (Section)에 나열된 개별 요소로 분석(unpacks)하는 12602단계로 이어진다. 투자 할당(Investment Allocations)는 요청하는 기부 구조(ES; Endowment Structure)를 투자해야 할 기업을 나타낸다. 이러한 기존 투자는 관련 포트폴리오 지분 보유(PSR; Portfolio Stake Retention) 인스턴스에서 추출된 포트폴 리오 지분 메이크업(Portfolio Stake Makeup)에 의해 초기에 정의된다. 따라서 지분 메이크업는 종합 상태 평가(CSE)에 의해 수신 및 고려되는 타겟 투자 정황(Target Investment Circumstances)으로 동화된다. 이익 배분(Profit Allocations)은 이러한 기업으로부터 이익을 인출해야 할 곳 (예를 들어, 관련 투자 자본(IC; Investment Capital) 인스턴스 또는 관련 디렉터 12006/12022 등의 개인 자금)을 나타낸다. 디렉터 통보(Director Notification)은 의도된 디렉터12006/12022 수령인에게 투자 결정 엑츄에이션(IDA; Investment Decision Actuation)가 직접적으로 수 행하기에는 너무 복잡하거나 초과할 수 있는 특정 투자 조치를 권고하도록 메시지가 전송되었음을 나타낸다. 따 라서, IDA는 관련 기부 구조(ES) 인스턴스 즉, 이사회(BD; Board of Directors) 12018 또는 독 립 디렉터(ID; Independent Director)에 대한 의도된 결과를 수행하기 위해 제공된 개별 요소를 실행한다."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "[00]도 1088 내지 도 1115는 디지털 마인드 추적(DMT; Digital Mind Tracking)의 작동 및 기능을 도시 하며, 이는 특정 인간 타겟(human targets)을 에뮬레이트(emulate)하기 위해 제기되는 디지털 반응 메커니즘의 '인식'perceptions)'과 '생각(thoughts)'을 에뮬레이트(emulates)한다. 도 1088은 디지털 마인드 추적(DMT; Digital Mind Tracking)의 동작에 관한 세부 사항을 도시한다. 타 겟 행동 리코딩(TBR; Target Behavior Recording) 모듈은 특정 타겟 마인드(Target Mind)로부터 직접적으로 행동 데이터 세트(BDS; Behavior Data Set) 정보와 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement) 모듈에 의해 구성되는 신경 매핑 연관(neurological mapping associations)을 수 신한다. BDS는 타겟 마인드와 관련하여 액션(Actions), 문장(Statements) 및 메 타데이터(Metadata)에 관한 정보를 포함한다. BDS 인스턴스는 DMT에 모듈식 입력으로 제 공되고 12714단계에서 수신된다. 12714단계는 BDS 정보가 그것의 구문 형식(syntax format)에서 목적 형식(purpose format)으로 변환하는 LIZARD을 통해 정규화(normalized)된 12718단계로 이어진다. 따라서 행동 목적 맵(Behavior Purpose Map)은 LIZARD의 모듈식 실행을 통해 BDS 인스턴스로 구성 된다. 그 후 12722단계에서, 행동 목적 맵은 타겟 마인드와 논리적으로(logistically) 연관된 개인 지능 프로파일(PIP; Personal Intelligence Profile) 인스턴스에 저장 및 유지된다. 그 후, LOM는 복잡한 심리학적 정의를 갖는 인간 특성(예를 들어, 내향적(introverted), 도덕적(judgmental), 냉 소적(cynical), 자기애 적(narcissistic) 등)의 다양한 유형을 분류하는 모음인 특성 템플릿 유형(Personality Template Types)을 생성하기 위해 12724단계에서 호출된다. 도 1089는 특성 템플릿 유형(Personality Template Types)을 생성되도록 호출되는 LOM 및 (앱체인 으로) 그것의 서브모듈을 정의하는 디지털 마인드 추적(DMT; Digital Mind Tracking)의 12724단계 에 관한 작동 세부 사항을 확장한다. 논리 흐름은 LOM이 자동화된 리서치 매커니즘(ARM; Automated Research Mechanism)을 소스(sources) (예를 들어, 심리학 연구 논문 등)를 통해 특성 유형을 연구하기 위해 정기적으로 호출하는 것을 설명하는 12728단계에서 시작한다. 12730단계에서, ARM에 의해 생성된 결 과 연구 정보는 확인되지 않은 지식(unconfirmed knowledge)으로 중앙 지식 보유(CKR; Central Knowledge Retention)에 저장된다. 그 후, LOM 및 CTMP는 (12730단계에서 제출되는) CKR에 저장된 확인되지 않은 지식에서 특성 유형에 관한 중요한 주장 및 결론을 추출하는 12732단계가 실행된다. LOM 및 CTMP가 확인되지 않은 지식에 대한 분석을 마무리할 때, 중요한 주장과 결론이 CKR에 보유를 위해 제 출된다. 그 후, 12734단계는 12732단계에서 도출된 중요한 주장과 결론을 나타내는 CKR에서 특성 템플릿 유형(Personality Template Types)을 생성하기 위해 호출된다. 도 1090은 도 1088에서 디지털 마인드 추적(DMT; Digital Mind Tracking)의 논리 흐름을 계속한다. LOM이 12724단계에서 특성 템플릿 유형(Personality Template Types)을 생성 한 후, 12736단계는 특성 템플릿 이행(PTF; Personality Template Fulfillment)에서 특성 템플릿 메이크업(Personality Template Makeup)을 생성하기 위해 호출된다. 특성 템플릿 메이크업은 타겟 마인드(Target Mind)의 특성 템플릿 기준(Personality Template Criteria)에 따라 특성 템플릿 유형 (Personality Template Types)에서 존재하는 특성 요소(personality elements)를 캡처한다. 12742단계 에서, LOM는 해당 개인 지능 프로파일(PIP; Personal Intelligence Profile) 인스턴스에서 타겟 마 인드와 일치하는 특성 뉘앙스 정의(Personality Nuance Definition)를 생성하기 위해 호출된다. 도 1091은 디지털 마인드 추적(DMT; Digital Mind Tracking)에서 12736단계의 작동 세부 사항에 대해 상세히 설명한다. 12734단계에서, LOM은 중앙 지식 보유(CKR; Central Knowledge Retention)로부터 특성 템플릿 유형(Personality Template Types)을 생성하기 위해 호출된다. 이는 12750단계가 호출되는 것으로 이어지며, 타겟 마인드(Target Mind)의 특성 템플릿 기준(Personality Template Criteria)는 LOM를 통해 해당 개인 지능 프로파일(PIP; Personal Intelligence Profile) 인스턴스에서 생성된다. 특성 템플릿 기준은 특성 템플릿 메이크업(Personality Template Makeup)의 생성을 가능하게 하 는 특정(certain) 특성 템플릿(Personality Template) 분류를 활성화하여 포텐셜(potential)을 가지는타겟 마인드(Target Mind)에 관한 개별 데이터를 나타낸다. 도 1092는 LOM이 CKR로부터 특성 템플릿 유형(Personality Template Types)을 생성하는 디지 털 마인드 추적(DMT; Digital Mind Tracking)의 12734단계에 관한 세부 사항을 도시한다. LOM은 특성 템플릿 호출 프롬프트(PTIP; Personality Template Invocation Prompt) 모듈에 의해 이러한 지식 을 생성하도록 호출된다. 규제 준수 지식(Regulatory Compliance Knowledge)은 UKF 클러스터 (C854F)의 여러 인스턴스의 구축으로 설명된다. UKF 클러스터(C854F)의 개별 요소는 규칙 구문 포맷(Rule Syntax Format)(C538)에 저장된 UKF1, UKF2 및 UKF3 서브 유닛의 구성으로 자세히 설명된다. 도 1093은 디지털 마인드 추적(DMT; Digital Mind Tracking)의 12736단계에서 특성 템플릿 이행(PTF; Personality Template Fulfillment)의 작동에 대해 자세히 설명한다. 12750단계에서, 타겟 마인드 (Target Mind)의 특성 템플릿 기준(Personality Template Criteria)은 해당 개인 지능 프로파일 (PIP; Personal Intelligence Profile) 인스턴스 LOM로부터 생성된다. 그 후, 12756단계는 특성 템 플릿 유형(Personality Template Types)을 포함하는 특성 템플릿 기준(Personality Template Criteria)의 정의를 이행하기 위해 PTF을 호출하여 실행된다. 그러므로, PTF는 특성 템 플릿 기준의 각각을 통해 을 순환하기 위해 루프를 시작하는 12762단계에서 호출된다. 루프 반복(Loop Iteration)에서 선택된 특성 템플릿 기준(Selected Personality Template Criteria)은 선택된 특성 템 플릿 기준 내에서 참조되는 특성 템플릿 유형(Personality Template Types)에 따라 해당 특성 템플릿 유형을 검색하는 12766단계에 의해 처리된다. 따라서 선택된 특성 템플릿 유형(Selected Personality Template Type)은 12766단계에서 생성된다. 12770단계에서, 선택된 특성 템플릿 유형 은 선택된 특성 템플릿 기준에서 정의된 존재의 크기에 따라 할당된다. 따라서 이러한 할당은 특 성 템플릿 메이크업(Personality Template Makeup)을 생성하기 위해 12770단계를 야기한다. 도 1094는 도 1093에서 특성 템플릿 이행(PTF; Personality Template Fulfillment)의 논리 흐름을 계속 한다. 12770단계는 선택된 특성 템플릿 기준(Selected Personality Template Criteria) 및 선택된 특성 템플릿 유형(Selected Personality Template Type)의 두 가지 모듈식 입력을 처리하여 모듈식 출력으로 특성 템플릿 메이크업(Personality Template Makeup)을 생성한다. 이어서, 프롬프트가 처리되며, 이는 12762단계에서 시작된 루프(Loop)의 특성 템플릿 기준(Personality Template Criteria)(1275 2)에서 처리되지 않은 유닛(units)이 남아 있는지 확인한다. 프롬프트에 대한 응답이 아니요(No)(1277 6)이면, 12780단계는 PTF에 대한 모듈식 출력으로 특성 템플릿 메이크업을 제출하여 작동된다. 12756단계는 특성 템플릿 메이크업(Personality Template Makeup)을 생산하도록 야기하는 PTF의 최초 호출자(original invoker)이다. 도 1095는 특성 템플릿 이행(PTF; Personality Template Fulfillment)의 메인 논리 흐름을 계속하고, 12742단계에서 도 1090로부터 재개된다. 특성 뉘앙스 정의(Personality Nuance Definition)는 12742단 계에서 생성되며 12784단계로 전송되며, 이는 특성 뉘앙스 정의를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위해 LIZARD을 호출한다. 12788단계에서, LIZARD는 특성 템플릿 메이크업 (Personality Template Makeup)을 목적 계층 맵으로 변환한다. 12792단계에서, 목적 계층 맵 12790 및 12786은 12792단계의 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing) 모듈에 의해 처리된다. 대칭 처리 결과(Symmetry Processing Result) 생성하므로, P2SP은 두 입 력 사이의 일치성(congruency)/호환성(compatibility)을 결정한다. 도 1096은 특성 뉘앙스 정의(Personality Nuance Definition)를 목적 계층 맵(Purpose Hierarchy Map) 으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 특성 뉘앙스 정의 (Personality Nuance Definition)는 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈 (SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제 공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문 으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해 SM(C35)는 이러한 코드의 기능성에 대한 목적 을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 특성 뉘앙스 정의(Personality Nuance Definition)은 코드 변환(C321)에 의해 상태 구문(State Syntax) 형식으로 수신된다. 코드 변환 (C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다.또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감 소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식 으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35) 의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코 드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은 밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조 하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내 부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직 접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워 크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메 모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1097은 특성 뉘앙스 정의(Personality Nuance Definition)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1096의 논리 흐름을 계속한다. 구문 모 듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 특성 뉘앙스 정의의 복합 목적 포맷(C325) 버 전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기 능 및 모듈에 적용된다. 도 1098은 특성 템플릿 메이크업(Personality Template Makeup)을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 특성 템플릿 메이크업(Personality Template Makeup)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35) 에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에 는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되 어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행가능 한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴 퓨터 코드의 구문적 해석을 제공한다. 특성 뉘앙스 정의(Personality Nuance Definition)은 코드 변환 (C321)에 의해 상태 구문(State Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환 (C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소 (C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의 도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목 적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333) 은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancingscripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함 한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1099는 특성 템플릿 메이크업(Personality Template Makeup)을 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1098의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석 (Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 특성 템플릿 메이크업(Personality Template Makeup)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1100은 특성 템플릿 메이크업(Personality Template Makeup)의 목적 계층 맵(Purpose Hierarchy Map) 및 특성 뉘앙스 정의(Personality Nuance Definition)의 목적 계층 맵(Purpose Hierarchy Map)을 처리하기 위해 호출된 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing) 인스턴스의 작동에 관한 도 1095의 논리 흐름을 계속한다. 12792 단계가 운영 프로세스 (operational process)를 완료한 후, 프롬프트은 맵이 맵과 일치(congruent)하고 호환 (compatible)되는지 확인한다. 프롬프트에 대한 응답이 예, 일치(Yes, Congruent)인 경우, 12802단계가 특성 템플릿 메이크업의 목적 계층 맵 복제로서 특성 목적 맵(Personality Purpose Map)를 생성하여 호출된다. 특성 뉘앙스 정의의 목적 계층 맵(Purpose Hierarchy Map)이 특성 목적 맵에 중요한 정보를 제공하지 않는 것을 인식되기 때문에 행해진다. 프롬프트에 대한 응답이 아니요, 불일치(No, not Congruent)인 경우, 목적 재조정 처리(PRP; Purpose Realignment Processing) 모듈은 (도 1101에 도시된 바와 같이) 특성 목적 맵을 생성하기 위해 호출된다. 도 1101은 프롬프트의 아니요, 불일치(No, Not Congruent) 응답에 관한 도 1100의 논리 흐름을 자세히 설명한다. 12806단계는 특성 뉘앙스 정의(Personality Nuance Definition)의 목적 계층 맵 (Purpose Hierarchy Map)과 일치하기 위해 특성 템플릿 메이크업(Personality Template Makeup)(1273 8)의 목적 계층 맵(Purpose Hierarchy Map)을 조정하여 목적 재조정 처리(PRP; Purpose Realignment Processing)를 호출한다. 따라서 맵에 표시된 어떤 요소가 맵에 삽입된다. 12806단계의 결과는 특성 목적 맵(Personality Purpose Map)을 생성하기 위해 12808단계에서 처리된다. 12810단계에 서, LIZARD는 특성 반응 시스템(Personality Reaction System)으로 언급되는 특성 반응의 구문 (Personality Reactionary Syntax)으로 특성 목적 맵을 변환한다. 도 1102는 특성 목적 맵(Personality Purpose Map)을 특성 반응의 구문(Personality Reactionary Syntax)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 맵은 복합 목적 포맷 (C325)으로 존재하며 LIZARD의 외부 코어(OC; Outer Core)(C329) 내에서 목적 모듈(PM; Purpose Module)(C36)의 반복 확장(Iterative Expansion)(C327)에 제출된다. 반복 확장(C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 맵에 정의됨) 세부 사항과 복잡도를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 포텐셜(potential)은 복합 목적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC)(C333)의 핵심 코드(C335) 요소는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리 및 로드 밸런싱 스크립트(Thread Management and Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템(Memory Management systems)을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트 를 제공하여 SM(Syntax Module)(C35) 및 PM(Purpose Module)(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1103은 특성 반응 시스템(Personality Reaction System)으로 언급되는 특성 반응의 구문 (Personality Reactionary Syntax)으로 특성 목적 맵(Personality Purpose Map)을 변환하기 위한LIZARD의 작동을 설명하기 위해 도 1102의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM; Purpose Module)(C36)의 복합 목적 포맷(C325)로 수신되고, 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에 서 논리적으로 필요한 함수(functions)를 도출한다. 이는 만약 함수가 더 간단한 상위의 함수로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형 성되는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수의 트리 (tree)이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC; Inner Core)(C333)의 핵심 코드(Core Code)(C335) 요소로부터 상속된 규칙 및 구문(Rules and Syntax)(C322) 정의에 따라 작동한다. 논리적 미분 (Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 따라서 PM(Purpose Module)(C36)은 코드 변환(C321)을 통해 입력 액티브 오버라이드 측정(Active Override Measures)의 결과 앱체인 구문 버전을 생성하기 위해 SM(Syntax Module)(C35)를 호출한다. 코드 변환(C321)에 의해 최종적으로 생성되는 결과 특성 반응 시스템(Personality Reaction System)은 SM(Syntax Module)(C35), 외부 코어(OC; Outer Core)(C329) 및 LIZARD의 모듈식 출력이다. 도 1104는 도 1101의 12810단계에서 재개되는 디지털 마인드 추적(DMT; Digital Mind Tracking)의 동작 및 논리 흐름을 도시한다. 12810단계는 LIZARD을 통해 특성 반응 시스템(Personality Reaction System)을 생성한 후, 12814단계는 타겟 마인드(Target Mind)의 타겟 마인드 아이덴티티(Target Mind Identity)을 검색하기 위해 호출된다. 12818단계는 타겟 마인드 아이덴티티와 연관된 특성 스냅샷 캐시 보유(PSCR; Personal Snapshot Cache Retention) 인스턴스를 검색한다. 프롬프트은 정의된 시간대(Defined Time Era)와 일치하는 PSCR(Personal Snapshot Cache Retention) 인스턴스에 저 장된 특성 반응 시스템(Personality Reaction System)의 이전 반복이 있는지 확인한다. 정의된 시간대 는 타겟 마인드(Target Mind)의 구성을 나타내는 시간 기간을 정의하므로 타겟 마인드 아이덴티티(Target Mind Identity)에서 참조된다. 예를 들어, 사람들은 일반적으로 일생동안 성숙, 이해, 경험 및 성격의 변화를 겪는다. 상기 방법에서, 정의된 시간대는 예전 버전과 최신 버전의 사람들을 있는 그대로 구별할 수 있다. 프롬 프트에 대한 응답이 예(Yes)인 경우, 12828단계는 PSCR 인스턴스에서 특성 반응 시스템 의 이전 반복을 삭제하여 활성화된다. 상기 방법에서, 정의된 시간대마다 오직 하나의 PSCR가 있 다. 12828단계 및 프롬프트에 대한 아니요(No) 응답 모두는 12830단계의 활성화로 이어지며, 타 겟 마인드 아이덴티티에 따라 정의된 시간대의 타겟 마인드와 연계된 PSCR 인스턴스로 현 재 특성 반응 시스템를 저장하고 유지하도록 변환한다. 도 1105는 재개되는 디지털 마인드 추적(DMT; Digital Mind Tracking)의 12830단계에서 자세히 설명하 며, 이는 특성 반응 시스템(Personality Reaction System)을 변환하고 해당 특성 스냅샷 캐시 보유 (PSCR; Personal Snapshot Cache Retention) 인스턴스에 저장한다. 12832단계에서, 커스터마이즈된 명 령 세트(Customized Command Set)는 기존 데이터 없이 CTMP의 앱체인 컨텐츠를 추출하도록 지시하는 실행 스트림 렌더링(ESR; Execution Stream Rendering)에 제출된다. 12836단계에서, 빈 CTMP 실행 베이스(Empty CTMP Execution Base)이 생성되며, 이는 ESR 인스턴스의 스냅샷 캡처 (snapshot capture)이다. ESR 인스턴스 내에서 CTMP 인스턴스가 아직 데이터를 처리하거나 보유하 지 않았기 때문에, 스냅샷(snapshot)은 '빈(empty’)'것으로 간주된다. 12840단계에서, 빈 CTMP 실행베이스 (Empty CTMP Execution Base)는 ESR의 새로운 인스턴스에서 렌더링된다. 따라서 12840단계는 12836단계의 역함수를 수행한다. 12844단계에서, 렌더링된 커스텀 CTMP 앱체인(Custom CTMP Appchain) 은 성격 반응 시스템 과 상호 작용하고, 따라서 커스텀 CTMP 인스턴스(Custom CTMP instance)에 서 타겟 마인드(Target Mind)의 특성을 효과적으로 캡처한다. 도 1106은 도 1105에서 디지털 마인드 추적(DMT; Digital Mind Tracking)에서 12830단계의 논리 흐름을 계속한다. 12844단계가 처리를 완료한 후, 커스터마이즈된 명령 세트(Customized Command Set)는 모든 변경 사항을 영구 스토리지에 커밋하기 위해 실행 스트림 렌더링(ESR; Execution Stream Rendering) 인 스턴스에 명령으로 제출된다. 커스터마이즈된 명령 세트는 영구 쓰기 데이터 세그먼트(Persistent Write Data Segment) 명령 유형(Command Type)을 포함한다. ESR이 영구 쓰기 데이터 세그먼트 명령(Commands)을 처리하면, 커스텀 CTMP 앱체인(Custom CTMP Appchain)은 CTMP 스냅샷 앱체인 보유(CTMP Snapshot Appchain Retention) 파일에 효과적으로 캡처된다.도 1107은 디지털 마인드 추적(DMT; Digital Mind Tracking)의 12846단계의 작동 세부 사항에 대해 자 세히 설명한다. 특성 반응 시스템(Personality Reaction System)는 모듈식 입력으로 12852단계로 전송 되며, 에뮬레이션 시나리오 생성(ESP; Emulation Scenario Production)을 통해 관련 에뮬레이션 시나리 오(Emulation Scenarios) 세트를 생성한다. ESP은 특성 반응 시스템의 범위(scope), 관 할구역(jurisdiction) 및 능력(capabilities)과 관련된 관련 에뮬레이션 시나리오(Relevant Emulation Scenarios)를 생성한다. 예를 들어, 전기공학 배경을 가진 특성은 주택 전기 배선 등에 관한 시나리오를 도출할 수 있다. 12858단계에서, 관련 에뮬레이션 시나리오를 통해 반복되는 루프(Loop)가 시작되며 따 라서, 루프의 반복마다 단일 유닛 선택된 에뮬레이션 시나리오(Selected Emulation Scenario)이 생성된 다. 12862단계에서, 선택된 에뮬레이션 시나리오는 에뮬레이션 제안(Emulation Proposition) 및 에뮬레이션 환경(Emulation Environment)을 포함하는 두 메인 변수를 생산하기 위해 분석(unpacked)된 다. 에뮬레이션 제안(Emulation Proposition)은 시나리오 주장으로 역할은 한다. 예를 들어, 벽이 전자 소켓이 제대로 접지되지 않을 수 있다. 에뮬레이션 환경(Emulation Environment)은 이벤트의 시간 및 위 치와 같이, 특성 반응 시스템과 관련된 커스텀 CTMP 앱체인(Custom CTMP Appchain) 인스턴스의 반응에 영향을 미칠 수 있는 변수를 정의한다. 도 1108은 디지털 마인드 추적(DMT; Digital Mind Tracking)의 12846단계의 작동을 자세히 설명하는 도 1107의 논리 흐름을 계속한다. 12862단계는 선택된 에뮬레이션 시나리오(Selected Emulation Scenario)(1286 0)에서 에뮬레이션 제안(Emulation Proposition) 및 에뮬레이션 환경(Emulation Environment)을 분석(unpacks)한다. 12868단계에서, 에뮬레이션 제안(Emulation Proposition) 입력 시스템 메타데이터 (Input System Metadata)(C484)로 커스텀 CTMP 앱체인(Custom CTMP Appchain) 인스턴스에 제출된다. 이 는 에뮬레이션 제안(Emulation Proposition)은 주관적 의견 분류(Subjective Opinion classification) 를 포함하는 커스텀 CTMP 앱체인 인스턴스에 모듈식 입력으로 제출됨을 나타낸다. 12870단계는 객관적 팩트 분류(Objective Fact classification)를 포함하는 커스텀 CTMP 앱체인 인스턴스에 로그(Logs)로 에뮬레이션 환경(Emulation Environment)을 제출한다. 따라서 CTMP 분류의 두 주요한 모듈 입력 (primary modular inputs)은 커스텀 CTMP 인스턴스에 대해 이행되었으며, 이는 객관적 팩트로 분류되는 입력 및 출력에 대한 비판적(critical) 사고를 만들도록 허용한다. 도 1109는 도 1108의 논리 흐름을 계속하며, 커스텀 CTMP(Custom CTMP) 인스턴스에 대한 두 가지 모듈 입력을 설명하고 또한, CTMP 작동을 위한 두 가지 주요 브랜치 즉, (논리적 사고) 규칙 실행(RE; Rule Execution)(C461) 및 (직관적 사고) 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)를 도 시한다. 이 작동 단계에서, 커스텀 CTMP(Custom CTMP) 인스턴스는 해당 특성 반응 시스템(Personality Reaction System)에 대한 편견이나 선호도 없이 작동하고 있다. 비판적 결정 출력(CDO; Critical Decision Output)(C462)는 CTMP 사양의 두 브랜치 C461/C475를 처리한다. 이 도면에서 강조되는 측면은 인식의 각도(Angles of Perception) C473/C472/C471/C470이 CTMP 사양의 두 브랜치 C461/C475를 모두 가 능하게 한다는 것이다. 도 1110은 도 1109의 논리 흐름을 계속하고 따라서, 디지털 마인드 추적(DMT; Digital Mind Tracking) 의 12846단계의 작동과 관련된 세부 사항을 자세히 설명한다. 커스텀 CTMP(Custom CTMP) 인스턴스는 실 행 스트림 렌더링(ESR; Execution Stream Rendering) 인스턴스 내에서 작동하고 따라서, 모듈식 출력으 로 결정 결과(Decision Result)를 생성한다. 커스텀 CTMP(Custom CTMP) 인스턴스에 대한 두 모 듈식 입력은 모두 (에뮬레이션 제안(Emulation Proposition)) 12868단계 및 (에뮬레이션 환경 (Emulation Environment)) 12870단계에 표시된다. 12868 및 12870 단계는 모두 12872단계의 실현과 완 성으로 이어지며, 이는 CTMP 결정 결과(CTMP Decision Result 12874)를 생성하기 비판적 결정 출력 (CDO; Critical Decision Output)(C462)의 내부 실행을 나타낸다. 그 후, 12876 단계가 정의된 허용 가능한 결 과 범위(defined Acceptable Result Scope)를 생성하기 위해 해당 선택된 에뮬레이션 시나리오 (Selected Emulation Scenario) 인스턴스를 분석하여 실행된다. 이 범위는 상한과 하한 경계로, CTMP 결정 결과가 해당 특성 반응 시스템(Personality Reaction System)의 특성과 호환된다고 간주될 수 있는 것을 위해 범위를 정의한다. 따라서 프롬프트는 CTMP 결정 결과(CTMP Decision Result)가 허용가능한 결과 범위(Acceptable Result Scope) 내에 속하는지 확인하여 활성화된다. 도 1111은 도 1110으로부터의 논리 흐름을 계속하고 따라서, 디지털 마인드 추적(DMT; Digital Mind Tracking)의 12846단계의 동작에 관한 세부 사항을 자세히 설명한다. 프롬프트에 대한 예(Yes) 응답은 12888단계를 실행하도록 이어진다. 12888 단계는 실행 스트림 렌더링(ESR; Execution Stream Rendering) 영구 쓰기 데이터 세그먼트(Persistent Write Data Segment) 명령 유형 (Command Type)을 통해 영구 스토리지(persistent storage)에 커스텀 CTMP(Custom CTMP)의 인지 의 각도(Angles of Perception) C473/C472/C471/C470 인스턴스를 커밋(commits)한다. 이는 Custom CTMP 인스턴스 내에서 영구적으로 유지되는 특성 반응 시스템(Personality Reaction System)와 연관되고 호환 되는 어떤 CTMP 사양 인식을 야기한다. 프롬프트에 대한 응답이 아니요(No)인 경우, 커스텀 CTMP(Custom CTMP)의 인식의 각도 C473/C472/C471/C470 인스턴스에서 해당 인식은 실행 스트림 렌더링 (ESR; Execution Stream Rendering) 세션 삭제 데이터 세그먼트(Session Delete Data Segment) 명 령 유형(Command Type)을 통해 삭제된다. 따라서 특성 반응 시스템와의 호환성 측정을 통해 확인 되지 않는 CTMP 사양 인식은 삭제되며 따라서, 커스텀 CTMP(Custom CTMP) 인스턴스에 유지되지 않는 다. 도 1112는 도 1111의 논리 흐름을 계속하고, 따라서 디지털 마인드 추적(DMT; Digital Mind Tracking) 의 12846단계의 동작에 관한 세부 사항을 자세히 설명한다. 12890단계가 발생하면, 5602단계가 또한, 진단 로그 유닛(DLU; Diagnostic Log Unit)를 진단 로그 제출(DLS; Diagnostic Log Submission) 모듈에 제출 하여 발생한다. 이는 프로그램의 향후 인스턴스보다 효율적인 기능 및 결과 생성을 가능하게 하기 위해 디지털 마인드 추적(DMT; Digital Mind Tracking) 그리고/또는 CTMP의 구조 및 작동을 포텐셜(potential) 수정을 만들기 위해 SPSI(Self Programming Self Innovation) 모듈을 허용한다. 12888단계와 12890단계 모두는 12858단계에서 의해 시작된 루프(Loop)에 관련 에뮬레이션 시나리오(Emulation Scenarios)가 남아 있는 지 확인하여 프롬프트를 호출한다. 프롬프트에 대한 응답이 예(Yes)인 경우, 12858단계의 루프(Loop)가 다음에 사용 가능한 선택된 에뮬레이션 시나리오(Selected Emulation Scenario)으로 반복 되는 12898단계를 호출한다. 프롬프트에 대한 응답이 아니요(No)인 경우, 12858단계의 루프 시퀀 스(Loop sequence)를 종료하는 12900단계를 활성화한다. 따라서 12900단계의 활성화는 12846단계의 작동 완료를 의미한다. 도 1113은 디지털 마인드 추적(DMT; Digital Mind Tracking)에서 12830단계의 기능과 작동에 대해 자세 히 설명한다. 12902단계는 엑티브 커스텀 CTMP(Custom CTMP) CTMP 스냅샷 앱체인 보유(CTMP Snapshot Appchain Retention)에 기록하는 해당 실행 스트림 렌더링(ESR; Execution Stream Rendering) 인 스턴스에 커스터마이즈된 명령 세트(Customized Command Set)를 제출한다. 따라서 12906단계에서 커스텀 CTMP 인스턴스 내에서 인식의 각도 C473/C472/C471/C470 인스턴스의 모든 인식은 새로 기록된 스냅샷 보 유(Snapshot Retention)에 유지된다. 12908단계에서, CTMP 스냅샷 앱체인 보유는 해당 타겟 마 인드 아이덴티티(Target Mind Identity)와 연관되고 특성 스냅샷 캐시 보유(PSCR; Personal Snapshot Cache Retention)모듈에 저장된다. 따라서, CTMP 스냅샷 앱체인 보유은 나중에 타겟 마인드 아 이덴티티과 관련하여 검색할 수 있다. 도 1114는 디지털 마인드 추적(DMT; Digital Mind Tracking)의 논리 흐름을 계속하고, 따라서 DMT 모듈의 호출, 메인 프로세싱 및 모듈식 출력 생성 방법을 설명한다. 12912단계에서, 마인드 에뮬레 이션 요청(Mind Emulation Request)은 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)을 통해 호출하는 UBEC 사용자로부터 수신된다. 12914단계에서, 마인드 에뮬레이션 요청 은 저장된 변수 예를 들어, 타당한 에뮬레이션 시나리오(Plausible Emulation Scenario) 및 타 겟 마인드 아이덴티티(Target Mind Identity)를 드러내기 위해 분석(unpacked)된다. 타겟 마인드 아이 덴티티은 UBEC 사용자가 직접 또는 간접적으로 찾고 있는 타겟 마인드(Target Mind)의 에 뮬레이션에 관한 식별 정보를 지칭한다. 타당한 에뮬레이션 시나리오은 렌더링된 버전의 타겟 마인드 에 에뮬레이션 시나리오를 제공하기 위해 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)에 의해 생성된 변수이다. MERM(Mind Emulation Request Module)가 UBEC 사용자에 의해 직접 또는 간접적으로 호출될 때마다, MERM는 각각 다른 타당한 에뮬레이션 시나리오을 갖 는 DMT의 다중 인스턴스를 호출한다. 따라서, 모든 호출된 DMT 인스턴스의 합은 MERM 처 리 레이어에서 타겟 마인드의 적절한 재구성으로 이어지고, 이는 UBEC 사용자의 요청에 대한 적절 한 통합된 응답(unified response)을 초래한다. 12918단계는 BCHAIN 네트워크(BCHAIN Network)에서 사용 가능한 모든 특성 스냅샷 캐시 보유(PSCR; Personal Snapshot Cache Retention) 인스턴스을 나 열하는 앱체인을 검색한다. 그 후, 12918 단계에서 검색된 앱체인에 타겟 마인드 아이덴티티(Target Mind Identity)와 일치하는 PSCR 인스턴스가 있는지 확인하는 프롬프트를 활성화한다. 12920단계에 대한 아니요(No) 응답은 에뮬레이션 요청 이행(Emulation Request Fulfillment)을 사용할수 없기 때문에, 12926단계에서 DMT 인스턴스의 모듈 실행 종료로 이어진다. 예 응답은 프롬프트 에서 발견된 해당 PSCR 인스턴스를 검색하는 12928단계의 실행으로 이어진다. 12928단계는 특성 스냅샷(Personality Snapshot)은 정의된 시간대에 대한 해당 PSCR 인스턴스에 존재하는지 확인 하는 프롬포트의 활성화로 이어진다. (시간대는 타겟 마인드 아이덴티티에 정의되어 있다.) 프롬 프트에 대한 응답이 아니요(No)인 경우, 현재 DMT 인스턴스의 모듈식 실행이 종료되는 12926단계를 활성화한다. 프롬프트에 대한 예(Yes) 응답은 12936단계의 실행으로 이어지며, 이는 해당 MERM 인스턴스에서 생성된 해당 특성 스냅샷 및 타당한 에뮬레이션 시나리오을 처리 하기 위해 특성 반응 렌더링(PR2; Personality Reaction Rendering)를 호출한다. 따라서, PR2는 해당 PSCR 인스턴스를 통해 타겟 마인드의 해석을 호출하며, 실행 가능한 커스텀 CTMP 인 스턴스를 유지한다. 도 1115는 특성 반응 렌더링(PR2; Personality Reaction Rendering)의 호출과 관련하여 디지털 마인드 추적(DMT; Digital Mind Tracking)의 논리 흐름을 계속한다. DMT은 12936단계에서 특성 스냅샷 (Personality Snapshot) 및 타당한 에뮬레이션 시나리오(Plausible Emulation Scenario)이 특성 반응 렌더링(PR2; Personality Reaction Rendering)에 의해 처리되는 12936단계의 도 1114에서 재개된 다. 이는 해당 특성 스냅샷 캐시 보유(PSCR; Personal Snapshot Cache Retention) 인스턴스에서 관련 CTMP 스냅샷 앱체인 보유(CTMP Snapshot Appchain Retention)를 추출하고 PR2에 모듈식 입력으 로 앱체인 보유(Appchain Retention)을 제출하는 12938단계의 실행으로 이어진다. 따라서 PR2는 앱체인 보유(Appchain Retention)를 데이터 스트림 정렬(DSS; Data Stream Sorting), 모듈 실행 스트림 모음(ESC; Execution Stream Collection) 및 실행 스트림 렌더링(ESR; Execution Stream Rendering)에 의한 처리로 제출되는12944단계에서 호출된다. CTMP 스냅샷 앱체인 보유에 해당하는 커스텀 CTMP 인스턴스가 현재 ESR에서 렌더링되고 있다. 12946단계는 관련 타당한 에뮬레이션 시 나리오를 PR2로 모듈식 입력으로 제공하는 해당 DMT 인스턴스의 메인 스레드를 호출한다. 따라서 타당한 에뮬레이션 시나리오는 타겟 마인드의 에뮬레이션을 나타내는 인식의 각도 C473/C472/C471/C470을 나타내므로 렌더링된 커스텀 CTMP 인스턴스에 제출된다. 12948단계에서 커스텀 CTMP2 인스턴스는 PR2 인스턴스에 대한 모듈식 출력으로 제출된 마인드 인식 결과(Mind Perception Result)을 생성하고 해당 DMT 인스턴스의 메인 스레드로 다시 반환된다. 따라서, 마 인드 인식 결과는 원래의 마인드 에뮬레이션 요청에 응답하여 해당 MERM에 제출하는 DMT의 12940단계에서 처리된다. 도 1116 내지 도 1145는 디지털 마인드 추적(DMT; Digital Mind Tracking)에 대한 스레드 호출 메커니 즘으로 작동하는 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 작동 및 기능 을 도시한다. 도 1116은 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 작동 및 기능을 도시 한다. UBEC 사용자는 직접적으로 (사용자 인터페이스) 간단한 중간의 플랫폼(simple Intermediate Platform)을 통한 MERM (및 디지털 마인드 추적(DMT; Digital Mind Tracking) 또는 간접 적으로 복잡하고 자율적은 중간 플랫폼(Intermediate Platform)를 통해 호출될 수 있다. 중간 플랫폼 (Intermediate Platform)의 예는 특정 오버라이드 측정(specified Override Measurement)(123880을 제 정하기 위해 특정 타겟 마인드(specified Target Mind)을 에뮬레이트하는 MERM와 DMT을 호출하는 NMC를 위해 기부 구조(ES; Endowment Structure)이다. 그러한 정의에 의해 도출된 포 텐셜(potential) 시나리오에 관한 관할구역 브랜치를 하도록 니드 맵 매칭(NMM; Need Map Matching)(C114) 인 스턴스에 공급하기 위해, 중간 플랫폼은 12958단계에서 처리되는 복잡한 시나리오 정의(Complex Scenario Definition)을 생성된다. 그 후, 12960단계는 I2GE를 통해 그리고 해당 NMM(C114) 인스 턴스에 의해 형성된 관할구역 브랜치로부터 복잡한 시나리오 정의(Complex Scenario Definition)의 다양 한 실행 시퀀스(Execution Sequences)를 처리하여 실행한다. 실행 시퀀스는 복잡한 시나리오 정 의가 수행할 수 있는 다양한 다른 방법을 나타낸다. 해당 인공 보안 위협(AST; Artificial Security Threat) 인스턴스에 모듈식 입력으로 제출된 포화 기준(Saturation Criteria)는 충분한 양의 실행 시퀀스(Execution Sequences)가 생성되었는지 평가하기 위해 나중에 참조된다. 따라서, I2GE 는 충분히 안정적인 양의 실행 시퀀스를 생성하기 위해 발생하는 처리의 양을 식별할 수 있다. 도 1117은 LIZARD의 다이나믹 쉘(DS; Dynamic Shell)(C198)의 서브모듈로 작동하는 니드 맵 매칭(NMM; Need Map Matching)(C114)의 작동 및 기능을 도시한다. NMM(C114) 인스턴스는 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 12960단계의 작동을 제공하기 위해 생성된다. 복잡한 시나리 오 정의(Complex Scenario Definition)은 니드 액세스 개발 및 스토리지(Need Access and Development and Storage)에 저장하기 위해 제출된다. 따라서 복잡한 시나리오 정의은 서브 카테고리로 분류되 고 일련의 계층적 브랜치 및 레이어으로 스토리지에 유지된다. NMM(C114)의 모듈식 호출에 따라, 초기 구 문 분석(Initial Parsing)(C148)은 진행중인 NMM(C114) 인스턴스 내에서 참조하기 위해 일시적으로 유지하도록 스토리지에서 각 관할구역 브랜치를 다운로드한다. 브랜치 니드 계산(Calculate Branch Needs)(C149)으로, 각 브랜치와 관련된 정의에 따라, 니드(needs)는 해당 부서와 연관되어 있다. 상기 방법으로, 권한 검사(permission checks)는 NMM(C114) 인스턴스 내에서 구성될 수 있다. 예를 들어, 직원의 능 력에 따라 직원 성과를 매년 검토하는 영역 내에서 요청되었기 때문에 NMM(C114)는 모든 직원 CV를 다운로드하 도록 인사부서에 요청을 승인했다. 따라서 부서 관할구역의 유효한 필요성(needs)임을 입증되었다. 따라서 니드 인덱스(C145)는 관할구역 브랜치와 및 각각의 니드의 메인 스토리지이다. 이 내부 참조는 NMM(C114) 및 제공되 는 모든 모듈의 작동에 대한 리소스 병목 현상이기 때문에, 시스템의 전반적인 효율성을 높이기 위해 빠른 데이 터베이스 쿼리에 미리 최적화되어 있다. I2GE는 입력 목적(Input Purpose)(C139)을 NMM(C114)의 검색 알 고리즘(Search Algorithm)(C144)에 모듈식 입력으로 제공한다. 입력 목적(C139)가 니드 액세스 개발 및 스토리 지에 초기에 정의된 관할구역 브랜치에 따라 유효한 니드를 정의하는지 판별하므로, 검색 알고리즘(C14 4)는 컴파일된 니드 인덱스(C145)를 통해 참조하고 검색한다. 따라서 니드 인덱스(C145)를 통해 검색 알고리즘 (C144)의 완료된 실행은 NMM(C114)의 모듈식 출력으로 제출되고 니드 결과(C141)로 참조되는 승인/차단(C146) 응답을 생성한다. 따라서 니드 결과(C141)는 입력 목적(C139) 제출에 대한 응답으로 I2GE로 되돌아간다. 도 1118은 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 12960단계에 관한 작 동 세부 사항에 대해 자세히 설명한다. 복잡한 시나리오 정의(Complex Scenario Definition)은 관할구 역 범주 브랜치(jurisdictional categorization branches)를 생성하기 위해 LIZARD의 니드 맵 매칭(NMM; Need Map Matching)(C114) 모듈에 제출된다. 이러한 브랜치는 12966단계에서 분석(unpacked)되며, 이는 12968 단계의 실행으로 이어진다. 12968단계에서, 복잡한 시나리오 정의의 관할구역 브랜치는 새로 호출된 I2GE 인스턴스의 각 진화 경로(Evolution Pathway)(C867A)의 베이스 제너레이션(base generation)(N1)으 로 설치된다. 이러한 설치는 I2GE의 모니터링 상호작용 시스템(Monitoring Interaction System)(C868D)를 통해 발생한다. I2GE 에뮬레이션(emulation)이 시작되면, 진화 경로(C867A)는 해당 경로 특성(Pathway Personality)(C867D) 정의에 따라 진화한다. 이러한 경로 특성(C867D)는 후속 단계에 설치되며, 이는 시퀀스 해석 방법론(Sequence Interpretation Methodologies) 변수 모음(collection)을 수신하고 I2GE 인스턴스에서 해당 특성(Personalities)(C867D)로 설치한다. 방법론(Methodologies) 변수는 MERM 관할구역 내에서 생산 및 유지되므로, MERM는 시나리오 시퀀스 해석에 다양한 방법과 스타 일을 고려할 수 있는 구성을 이미 갖추고 있다. 각 진화 경로(C867A)는 I2GE 인스턴스 내에서 가상 분리 (Virtual Isolation)을 통해 서로에 의해 논리적으로 분리된다. 따라서 진화 경로(C867A)에서 생성된 결과 가 다른 포텐셜(potential) 요인에 의해 편향되지 않고 영향을 받지 않는다는 암묵적인 보장이 있다. 도 1119는 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 12960단계의 기능과 작동에 대해 자세히 설명한다. 복잡한 시나리오 정의(Complex Scenario Definition)은 인공 보안 위협 (AST; Artificial Security Threat)모듈에 의해 환경 테스트를 받는 다중 병렬 진화 경로(Evolution Pathways)(C867A)에 의해 에뮬레이션(emulated)된다. I2GE 에뮬레이션 처리(emulation processing)가 완 료되면, 결과는 프롬프트에 모듈식 출력을 제출하는 반복 결론 프로세서(Iteration Conclusion processor)에 의해 처리된다. 프롬프트는 I2GE 에뮬레이션 세션(emulation session)에서 생 성된 안정화된 실행 시퀀스(Execution Sequences)의 양을 평가한다. 프롬프트에 대한 응답은 예, 충분하게 안정적임(Yes, Sufficiently Stable)은 포화 기준(Saturation Criteria)가 실행 시퀀스(Execution Sequence)의 분산 및 안정성에 대해 충족된 것으로 간주된다. 도 1120은 도 1118 및 도 1119의 기능에 대해 자세히 설명하고, 진화 경로(Evolution Pathway)(C867) 내에 순 차적으로 구축된 여러 제너레이션(multiple Generations)을 도시한다. 복잡한 시나리오 정의(Complex Scenario Definition)을 나타내고, 관할구역 브랜치는 LIZARD의 니드 맵 매칭(NMM; Need Map Matching)(C114) 모듈에 의해 생성되며, I2GE 에뮬레이션 세션(emulation session)에서 생성된 순차적인 제너레이션(sequential Generations)을 연관시키고 응답한다. 세션이 계속되면서, BCHAIN 네트워크 (BCHAIN Network)에서 호스팅되는 경로 지정(Pathway Designation)은 진화 경로(Evolution Pathway)(C867)이 될 수 있는 세 가지 상태를 나타내며 즉, 안정됨으로 전달됨(Passed as Stable), 진화를 기 다림(Pending Evolution), 포기/삭제(Abandoned/Deleted)가 있다. 해당 경로 특성(PathwayPersonality)(C867D)가 초기 경로(C867) 상태와 구성의 상속 결함(inherit flaw in composition) 그리고/또는 상속 비호환성(inherit incompatibility)을 표시하는 경우, 경로(C867)이 삭제될 수 있다. 도 1121은 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 논리 흐름을 계속한 다. 12960단계는 복잡한 시나리오 정의(Complex Scenario Definition)에서 파생된 다양한 실행 시퀀스 (Execution Sequences)를 생성한다. 12980단계에서, LIZARD은 복잡한 시나리오 정의를 목 적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위해 호출된다. 12984단계에서, 실행 시퀀스 는 새롭게 호출된 루프에서 반복된다. 12986단계에서, 목적 계층 맵은 컨텐츠에서 복제되고 베이스 목적 계층 맵로 라벨링된(labelled) 별도의 인스턴스로서 참조된다. 이러한 맵은 12984단계에서 시작 된 루프의 단일 반복 내에서 개별 인스턴스로서 나중에 사용된다. 따라서 12984단계 루프의 각 반복이 시작될 때, 베이스 목적 계층 맵은 목적 계층 맵의 컨텐츠로 재설정된다. 12992단계에서, LIZARD은 선택된 실행 시퀀스(Selected Execution Sequence)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환한다. 도 1122는 복잡한 시나리오 정의(Complex Scenario Definition)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 복잡한 시나리오 정의 (Complex Scenario Definition)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈 (SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제 공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문 으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목 적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 복잡한 시나리오 정의(Complex Scenario Definition)은 코드 변환(C321)에 의해 시나리오 구문(Scenario Syntax) 형식으로 수신된다. 코 드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변 환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수 (inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단 한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴 퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C3 5)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C32 6)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프 한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전 문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1123은 복잡한 시나리오 정의(Complex Scenario Definition)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1122의 논리 흐름을 계속한다. 구문 모 듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 복잡한 시나리오 정의(Complex Scenario Definition)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1124는 선택된 실행 시퀀스(Selected Execution Sequence)을 목적 계층 맵(Purpose Hierarchy Map)으로 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 선택된 실행 시퀀스(Selected Execution Sequence)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 의사 코드 를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출 하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 복잡한 시나리오 정의(Complex Scenario Definition)은 코드 변환(C321)에 의해 시나리오 구문(Scenario Syntax) 형식으로 수신된다. 코 드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변 환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수 (inverse function)도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단 한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴 퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C3 5)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C32 6)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프 한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전 문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1125 선택된 실행 시퀀스(Selected Execution Sequence)을 목적 계층 맵(Purpose Hierarchy Map) 으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1124의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36) 의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 선택된 실행 시퀀스(Selected Execution Sequence)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1126은 도 1121에서 논리 흐름을 계속함으로써, 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 작동 세부 사항을 자세히 설명한다. 따라서 논리 흐름은 LIZARD이 선택된 실행 시퀀스(Selected Execution Sequence)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하는 12992단계에서 재개된다. 12996단계에서, 복잡한 시나리오 정의(Complex Scenario Definition)의 목적 계층 맵과 선택된 실행 시퀀스의 목적 계층 맵는 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)의 호출된 인스턴스를 통해 처리되며, 따라서 대칭 처리 결과(Symmetry Processing Result)를 생성한다. 이는 프롬프트이 활성화되며, 이는 두 개의 목적 계층 맵 12982 및 12994가 서로 일치하고 호환되는지 확인하여 대칭 처리 결과을 해석한다. 아니요, 불일치(No, Not Congruent)를 나타내는 프롬프트에 대한 응답은 도 1127에 설명된다. 예, 일치(Yes, Congruent) 응답은 13006단계의 활성화로 이어지며, 이는 복잡한 시나리오 정의의 목적 계층 맵 이 일치하도록 선택된 실행 시퀀스의 목적 계층 맵를 재조정하여 목적 재조정 처리(PRP;Purpose Realignment Processing) 모듈을 호출한다. 따라서 마스터/슬레이브 선호도(Master/Slave Affinity) 변수는 맵가 슬레이브(Slave)이고 맵가 마스터(Master)임을 나타내는 모듈식 입력으로 해당 PRP 인스턴스에 제공된다. 이러한 선호도은 논리 흐름 구조에 따라 고정 변수로 정 의된다. 그러므로 13006단계의 완성은 도 1128의 13012단계에서 사용을 위해 참조되는 타당한 에뮬레이션 시나 리오(Plausible Emulation Scenario)을 생성한다. 도 1127은 프롬프트에 대한 아니요 불일치(No, Not Congruent)의 응답과 관련된 논리 흐름을 설 명하기 위해 도 1126의 논리 흐름을 계속한다. 그 후, 5600단계는 공식 시스템 토큰(Official System Token)이 포함된 진단 로그 유닛(DLU; Diagnostic Log Unit)를 제출하여 발생한다. 이 토큰(118 4)는 UBEC 플랫폼(UBEC Platform) 내의 공식 기능인 경우, 해당 기능 또는 프로그램이 비이상적인 상태 (non-ideal state)에 도달했음을 나타내도록 포함된다. 상기 DLU는 진단 로그 제출(DLS; Diagnostic Log Submission)에 제출되며, 이는 SPSI에 DLU를 공급하기 위해 LOM 자동화된 리서치 매커 니즘(ARM; Automated Research Mechanism)에 의해 호출된다. 따라서 SPSI은 진단 로그 유닛 분석 (DLUA; Diagnostic Log Unit Analysis) 모듈을 포함하는 DLU에서 발견된 진단 정보를 진행할 수 있다. 이는 초기 이유 아니요, 불일치(No, Not Congruent) 응답을 피하기 위해 I2GE 그리고/또는 MERM에 대한 해당 수정을 수행하기 위해 호출된 DLUA은 프롬프트에 호출되는 13005단계로 이어진다. 도 1128은 도 1126의 13006단계에서 재개되는 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 논리 흐름을 계속한다. 13006단계가 목적 재조정 처리(PRP; Purpose Realignment Processing) 모듈을 맵으로 후출 완료한 후, UBEC 사용자에 중간 플랫폼(Intermediate Platform)을 통해 MERM(Mind Emulation Request Module) 인스턴스에 대한 모듈식 입력으로 타겟 마인드 아이덴티티(Target Mind Identity)를 수신하는 13010단계가 실행한다. 그 후, 13012단계는 입력 으로 타겟 마인드 아이덴티티(Target Mind Identity) 및 타당한 에뮬레이션 시나리오(Plausible Emulation Scenario)을 마인드 에뮬레이션 요청(Mind Emulation Request)에 패킹(pack)하도록 처리된다. 13014단계에서 마인드 에뮬레이션 요청은 해당 디지털 마인드 추적(DMT; Digital Mind Tracking) 인스턴스에 제출된다. 따라서 DMT은 모듈식 출력으로 마인드 인식 결과(Mind Perception Result)를 생성하도록 절차를 제정한다. 13016단계에서, 마인드 인식 결과는 DMT 인스턴스로부터 수신되고 13018단계에 모듈 입력으로 제출되며, 이는 그것을 목적 계층 맵으 로 변환하기 위해 LIZARD를 호출한다. 도 1129는 도 1128의 13018단계에서 재개함으로써 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 논리 흐름을 계속한다. 13018단계는 마인드 인식 결과(Mind Perception Result)에서 목적 계층 맵(Purpose Hierarchy Map)을 생성한다. 13022단계에서 LIZARD은 타당한 에뮬레이션 시 나리오(Plausible Emulation Scenario)을 목적 계층 맵으로 변환한다. 13026단계는 두 개의 맵 13020 및 13024을 처리하기 위해 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)을 호출하며, 따라서 대칭 처리 결과(Symmetry Processing Result)을 생성한다. 프롬 프트에서 결과는 마인드 인식 결과(Mind Perception Result)의 목적 계층 맵(Purpose Hierarchy Map)이 타당한 에뮬레이션 시나리오(Plausible Emulation Scenario)을 목적 계층 맵 와 일치/호환되는지 해석하기 위해 분석된다. 프롬프트에 대한 응답이 아니요, 불일치(No, Not Congruent)인 경우, 논리 흐름은 5602단계에서 진단 로그 유닛(DLU; Diagnostic Log Unit)이 진 단 로그 제출(DLS; Diagnostic Log Submission) 모듈에 제출되었음을 나타내는 도 1127의 아니요, 불일 치4에 도시된 것과 동일한 절차를 따른다. 프롬프트에 대한 예, 일치(Yes, Congruent) 응 답에 관한 논리 흐름이 도 1134에 도시되어 있다. 도 1130은 마인드 인식 결과(Mind Perception Result)의 목적 계층 맵(Purpose Hierarchy Map) 으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 마인드 인식 결과(Mind Perception Result)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35) 에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에 는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되 어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36) 의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 복잡한 시나리오 정의(Complex Scenario Definition) 은 코드 변환(C321)에 의해 시나리오 구문(Scenario Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코 드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function) 도 수행한다. 코드 변환(C321)의 완료된 실행 결과는 논리 감소(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한 다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출 력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관 련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코 드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으 로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브 러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1131은 마인드 인식 결과(Mind Perception Result)을 목적 계층 맵(Purpose Hierarchy Map) 으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1130의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해 석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 마인드 인식 결과(Mind Perception Result)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정 의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1132는 타당한 에뮬레이션 시나리오(Plausible Emulation Scenario)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 타당한 에뮬레이 션 시나리오(Plausible Emulation Scenario)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임 워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수는 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 복잡한 시나리오 정의 (Complex Scenario Definition)은 코드 변환(C321)에 의해 시나리오 구문(Scenario Syntax) 형 식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선 택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환 (translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소 (Logical Reduction)(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완 료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도 출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능 성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다.반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷 (C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동 화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함 한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1133은 타당한 에뮬레이션 시나리오(Plausible Emulation Scenario)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1132의 논리 흐름을 계속한 다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관 성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프 한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 타당한 에뮬레이션 시나리오(Plausible Emulation Scenario)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1134는 도 1129에서 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 논리 흐 름을 계속한다. 프롬프트에 대한 예, 일치(Yes, Congruent) 응답은 13036단계의 실행으로 이어 진다. 13036단계는 목적 재조정 처리(PRP; Purpose Realignment Processing) 모듈을 통해 마인드 인식 결과(Mind Perception Result)의 목적 계층 맵(Purpose Hierarchy Map)과 일치하도록 타당한 에 뮬레이션 시나리오(Plausible Emulation Scenario)의 목적 계층 맵를 조정한다. 마스터/슬레이 브 선호도(Master/Slave Affinity)은 맵이 지정된 슬레이브이고 지정된 맵은 지정된 마 스터임을 나타내기 위해 모듈식 입력으로 해당 목적 재조정 처리(PRP; Purpose Realignment Processing) 인스턴스에 제출된다. 따라서 13036단계는 타당한 에뮬레이션 시나리오 변수에 존재했던 포텐셜 시나리 오(potential scenario)의 타겟 마인드의 이행을 나타내는 이행된 에뮬레이션 시나리오(Fulfilled Emulation Scenario)을 생성한다. 13042단계에서, 복잡한 시나리오 정의(Complex Scenario Definition)의 베이스 목적 계층 맵(Base Purpose Hierarchy Map) 및 이행된 에뮬레이션 시나리 오은 대칭 처리 결과(Symmetry Processing Result)를 생성하도록 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)에 의해 처리된다. 도 1135는 13042단계에서 도 1134로부터 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 논리 흐름을 계속한다. 12042단계가 대칭 처리 결과(Symmetry Processing Result)를 생성한 후, 결과는 프롬프트에 제출된다. 프롬프트은 이행된 에뮬레이션 시나리오 (Fulfilled Emulation Scenario)과 복잡한 시나리오 정의(Complex Scenario Definition)의 베이 스 목적 계층 맵(Base Purpose Hierarchy Map) 사이의 일치성 및 호환성을 해석한다. 프롬프트 에 대한 응답이 아니요, 불일치(No, Not Congruent)인 경우, 논리 흐름은 5602단계에서 진단 로그 유닛 (DLU; Diagnostic Log Unit)가 진단 로그 제출(DLS; Diagnostic Log Submission) 모듈에 제출됨을 나타내는 도 1127의 아니요, 불일치(No, Not Congruent) 응답으로 도시된 바와 같이 동일한 절차를 따른 다. 프롬프트에 대한 응답이 예, 일치(Yes, Congruent)인 경우, 복잡한 시나리오 정의의 베이스 목적 계층 맵을 이행된 에뮬레이션 시나리오(Fulfilled Emulation Scenario)와 일치하도록 조정 하기 위해 목적 재조정 처리(PRP; Purpose Realignment Processing)을 호출하는 13052단계가 발생한다. 따라서 마스터/슬레이브 선호도(Master/Slave Affinity)는 기본 목적 계층 맵을 슬레이브로 정 의하고 이행된 에뮬레이션 시나리오을 마스터로 정의하기 위해 모듈식 입력으로 해당 PRP 인스턴 스에 제공된다. 도 1136은 13052단계에서 도 1135로부터 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 논리 흐름을 계속한다. 도 1135에서 나타낸 바와 같이, 13052단계의 실행은 업그레이드된 목 적 맵(Upgraded Purpose Map)을 모듈식 출력으로 생성한다. 13058단계에서, 업그레이드된 목적 맵은 복잡한 시나리오 정의(Complex Scenario Definition)의 베이스 목적 계층 맵(Base Purpose Hierarchy Map)을 대체한다. 따라서 루프의 반복이 완료되므로, 12984단계의 루프에 아직 처리되지 않은 나머지 실행 시퀀스(Execution Sequences)가 남아 있는지 프롬프트가 해석한다. 프롬프트에 대한 예(Yes) 응답은 루프를 12984단계에서 다음의 사용 가능한 실행 시퀀스(Execution Sequence)로 진행하 도록 13066단계를 야기한다. 프롬프트에 대한 아니요(No) 응답은 베이스 목적 계층 맵 을 앱체인 구문으로 (따라서 더 이상 목적 형식(Purpose Format)이 아님). 변환하도록 LIZARD을 호출하는 13068단계로 이어진다. 도 1137는 복잡한 시나리오 정의(Complex Scenario Definition)의 베이스 목적 계층 맵(Base Purpose Hierarchy Map)을 앱체인 구문(Appchain Syntax)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 맵은 복합 목적 포맷(C325)으로 존재하며 LIZARD의 외부 코어(OC; Outer Core)(C329) 내에서 목적 모듈(PM; Purpose Module)(C36)의 반복 확장(Iterative Expansion)(C327)에 제출된다. 반복 확장(C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 맵에 정의됨) 세부 사항과 복잡도(complexity)를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미 분(Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 포텐셜 (potential)은 복합 목적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC)(C333)의 핵심 코드(C335) 요소는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리 및 로드 밸런싱 스크립 트(Thread Management and Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템(Memory Management systems)을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(Syntax Module)(C35) 및 PM(Purpose Module)(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(C336) 요 소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하 는 정적 정책 변수로 작동한다. 도 1138은 업그레이드된 앱체인 보유(Upgraded Appchain Retention)로 언급되는 앱체인 구문(Appchain Syntax)으로 베이스 목적 계층 맵(Base Purpose Hierarchy Map)을 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1137의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM; Purpose Module)(C36)의 복합 목 적 포맷(C325)로 수신되고, 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수(functions)를 도출한다. 이는 만약 함수가 더 간단한 상위의 함수(parent function)로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되 는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수(function dependencies)의 트리(tree)이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC; Inner Core)(C33 3)의 핵심 코드(Core Code)(C335) 요소로부터 상속된 규칙 및 구문(Rules and Syntax)(C322) 정의에 따라 작동 한다. 논리적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코 드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function) 도 수행한다. 따라서 PM(Purpose Module)(C36)은 코드 변환(C321)을 통해 입력 복잡한 시나리오 정의(Complex Scenario Definition)의 결과 앱체인 구문 버전(Appchain Syntax Version)을 생성하기 위해 SM(Syntax Module)(C35)를 호출한다. 코드 변환(C321)에 의해 최종적으로 생성되는 결과 업그레이드된 앱체인 보유(resultant Upgraded Appchain Retention)은 SM(Syntax Module)(C35), 외부 코어(OC; Outer Core)(C329) 및 LIZARD의 모듈식 출력이다. 도 1139는 13068단계에서 도 1136의 마인드 에뮬레이션 요청 모듈(MERM; Mind Emulation Request Module)의 논리 흐름을 계속한다. 12068단계는 업그레이드된 앱체인 보유(Upgraded Appchain Retention)을 생성하며, 이는 13078단계에서 나중에 참조하기 위해 배포 패치 어셈블리(DPA; Deployment Patch Assembly)에 모듈식 입력으로 제출된다. 12070단계에서, LIZARD은 목적 계층 맵 (Purpose Hierarchy Map)를 앱체인 구문(Appchain Syntax)으로 변환하며, 따라서 오리지널 앱체인 보유 (Original Appchain Retention)를 모듈식 출력으로 생성한다. 오리지널 앱체인 보유(Original Appchain Retention)는 모듈식 입력으로 배포 패치 어셈블리(DPA; Deployment Patch Assembly)에 또한 제 출된다. 그 다음, 13078단계는 모듈식 입력 12188 및 13074로부터 모듈식 출력으로 앱체인 정정 패치(Appchain Correction Patch)을 생성하기 위해 DPA을 호출하도록 처리된다. 13080단계에서, 앱체인 정정 패 치(Appchain Correction Patch)는 LIZARD에 의해 시나리오 구문(Scenario Syntax)으로 변환된다.따라서 13082단계에서, 마인드 에뮬레이션 응답(Mind Emulation Response)은 중간 플랫폼(Intermediate Platform)를 통해 UBEC 사용자에게 제출된다. 도 1140은 복잡한 시나리오 정의(Complex Scenario Definition)의 목적 계층 맵(Purpose Hierarchy Map)을 앱체인 구문(Appchain Syntax)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시 한다. 맵은 복합 목적 포맷(C325)으로 존재하며 LIZARD의 외부 코어(OC; Outer Core)(C329) 내에 서 목적 모듈(PM; Purpose Module)(C36)의 반복 확장(Iterative Expansion)(C327)에 제출된다. 반복 확장 (C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 맵에 정의됨) 세부 사항과 복잡도(complexity)를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 포텐셜(potentia l)은 복합 목적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC)(C333)의 핵심 코드(C335) 요소는 기본 프레 임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리 및 로드 밸런싱 스크립트(Thread Management and Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템(Memory Management systems)을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(Syntax Module)(C35) 및 PM(Purpose Module)(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(C336) 요 소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하 는 정적 정책 변수로 작동한다. 도 1141은 오리지널 앱체인 보유(Original Appchain Retention)로 언급되는 앱체인 구문(Appchain Syntax)으로 목적 계층 맵(Purpose Hierarchy Map)을 변환하기 위한 LIZARD의 작동을 설명하기 위 해 도 1140의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM; Purpose Module)(C36)의 복합 목적 포맷 (C325)로 수신되고, 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된 다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수 (functions)를 도출한다. 이는 만약 함수가 더 간단한 상위의 함수(parent function)로부터 영향으로 인해 도함 수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것 을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수(function dependencies)의 트리(tree)이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC; Inner Core)(C33 3)의 핵심 코드(Core Code)(C335) 요소로부터 상속된 규칙 및 구문(Rules and Syntax)(C322) 정의에 따라 작동 한다. 논리적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(Syntax Module)(C35)에서 인식하고 이해하는 임의의(일반적인) 코드(arbitrary (generic) code)를 알려진 선택된 계산 언어로 변환한다. 코드 변환(C321)은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수 (inverse function)도 수행한다. 따라서 PM(Purpose Module)(C36)은 코드 변환(C321)을 통해 입력 복잡한 시나 리오 정의(Complex Scenario Definition)의 결과 앱체인 구문 버전(Appchain Syntax Version)을 생성하기 위해 SM(Syntax Module)(C35)를 호출한다. 코드 변환(C321)에 의해 최종적으로 생성되는 결과 오리지 널 앱체인 보유(Original Appchain Retention)은 SM(Syntax Module)(C35), 외부 코어(OC; Outer Core)(C329) 및 LIZARD의 모듈식 출력이다. 도 1142는 앱체인 정정 패치(Appchain Correction Patch)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 앱체인 정정 패치(Appchain Correction Patch)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성 에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 앱체인 정정 패치(Appchain Correction Patch)는 코드 변환(C321)에 의해 인식 구문(Perception Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수 (inverse function)도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323) 에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴 스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위 해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절 히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석 (C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에 서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보 수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역 이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암 호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코 드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대 한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정 책 변수로 작동한다. 도 1143은 앱체인 정정 패치(Appchain Correction Patch)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1132의 논리 흐름을 계속한다. 구문 모 듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 앱체인 정정 패치(Appchain Correction Patch)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1144는 앱체인 정정 패치(Appchain Correction Patch)의 목적 계층 맵(Purpose Hierarchy Map)을 시나리오 구문(Scenario Syntax)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도 시한다. 맵은 복합 목적 포맷(C325)으로 존재하며 LIZARD의 외부 코어(OC; Outer Core)(C329) 내 에서 목적 모듈(PM; Purpose Module)(C36)의 반복 확장(Iterative Expansion)(C327)에 제출된다. 반복 확장 (C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 맵에 정의됨) 세부 사항과 복잡도(complexity)를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 포텐셜(potentia l)은 복합 목적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC)(C333)의 핵심 코드(C335) 요소는 기본 프레 임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리 및 로드 밸런싱 스크립트(Thread Management and Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템(Memory Management systems)을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(Syntax Module)(C35) 및 PM(Purpose Module)(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(C336) 요 소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하 는 정적 정책 변수로 작동한다. 도 1145은 마인드 에뮬레이션 응답(Mind Emulation Response)로 언급되는 시나리오 구문(Scenario Syntax)으로 목적 계층 맵(Purpose Hierarchy Map)을 변환하기 위한 LIZARD의 작동을 설명하기 위 해 도 1144의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM; Purpose Module)(C36)의 복합 목적 포맷 (C325)로 수신되고, 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된 다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수 (functions)를 도출한다. 이는 만약 함수가 더 간단한 상위의 함수(parent function)로부터 영향으로 인해 도함 수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것 을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수(function dependencies)의 트리(tree)이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC; Inner Core)(C33 3)의 핵심 코드(Core Code)(C335) 요소로부터 상속된 규칙 및 구문(Rules and Syntax)(C322) 정의에 따라 작동 한다. 논리적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은SM(Syntax Module)(C35)에서 인식하고 이해하는 임의의(일반적인) 코드(arbitrary (generic) code)를 알려진 선택된 계산 언어로 변환한다. 코드 변환(C321)은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수 (inverse function)도 수행한다. 따라서 PM(Purpose Module)(C36)은 코드 변환(C321)을 통해 입력 앱체인 정정 패치(Appchain Correction Patch)의 결과 앱체인 구문 버전(resultant Appchain Syntax Version)을 생성하기 위해 SM(Syntax Module)(C35)를 호출한다. 코드 변환(C321)에 의해 최종적으로 생 성되는 결과 마인드 에뮬레이션 반응(Mind Emulation Response)는 SM(Syntax Module)(C35), 외부 코어 (OC; Outer Core)(C329) 및 LIZARD의 모듈식 출력이다. 도 1146 내지 도1183는 타겟 마인드(Target Mind)의 신경 패턴(Neural Patterns)을 타겟 정황 상태(Target Circumstantial State)에서 캡처된(captured) 존재의 물리적 상태와 관련시키는 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement) 모듈의 작동 및 기능을 도시한다. 도 1146은 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement) 모듈을 소개한다. 작업에 방 해가 되지 않는 신경 스캐닝 디바이스(UNSD; Unobtrusive Neural Scanning Device)는 UBEC 사용자(10 6)의 기능을 수행하는 타겟 마인드(Target Mind)로부터 미가공 신경 패턴(Raw Neural Pattern) 을 수신한다. UBEC 사용자인 타겟 마인드(Target Mind)는 BCHAIN 네트워크를 통해 UNSD(Unobtrusive Neural Scanning Device) 모듈에 만들어질 수 있는 내부 표준 API 커뮤니케이션 (internal standardized API communications)를 가능하게 한다. 따라서 13096단계에서, UBEC 사용자의 미 가공 신경 패턴(Raw Neural Pattern) UNSD를 통해 다시 수신된다. 13098단계에서, LOM는 해당 개인 지능 프로파일(PIP; Personal Intelligence Profile) 및 라이프 행정 자동화(LAA; Life Administration Automation)을 통해 UBEC 사용자 의 타겟 정황 상태(Target Circumstantial State)과 신뢰도(Confidence)에 대해 보고한다. 따라서 LOM은 타겟 UBEC 사용자에 관 한 개인 정보를 유지하는 PIP와 사물 인터넷(IoT; Internet of Things)의 상호 작용을 통한 UBEC 사용자 의 디지털 라이프 스타일을 연결하는 LAA(Life Administration Automation)에 의해 제공되는 데이터 에 기반으로 타겟 정황 상태를 생성한다. 예를 들어, UBEC 사용자가 소유한 IoT 가능한 차량은 UBEC 사용자가 운정중이고 현재 교총 체증에 갇혀있다고 LAA을 통해 보고하고 있다. 따라서 이 예시 적인 정보는 LOM에 의해 생성된 바와 같이 타겟 정황 상태에 포함된다. 타겟 정황 상태 신뢰도 (Target Circumstantial State Confidence)는 LOM가 타겟 정황 상태에 관한 이러한 변수를 생성하는 신뢰도를 나타낸다. 예를 들어, 신뢰도(confident)는 LOM와 확장(extension) LAA에 의한 방법으로, UBEC 사용자은 실제로 자동차의 운전자이며 자동차가 실제로 교통 체증에 갇혀있다는 것이다. 13104단계에서, LOM은 잠재적인 신경 상태(potential Neural State)와 잠재적인 정황 상황(potential Circumstantial State) 사이의 학습된(learned) 상관 관계를 나타내는 신경 상태 연관 지식(Neural State Association Knowledge)을 생성한다. 신경 상태 연관 지식 신뢰도(Neural State Association Knowledge Confidence)은 LOM가 신경 상태 연관 지식(Neural State Association Knowledge)의 정확성 (accuracy)과 신뢰성(reliability)에 관한 알고리즘 신뢰도(algorithmic confidence)와 관련있다. 13110단계에 서, LIZARD는 신경 상태 연관 지식(Neural State Association Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환한다. 도 1147은 LOM이 CKR로부터 신경 상태 연관 지식(Neural State Association Knowledge)을 생 성하는 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement)의 13104단계에 관한 세부 사항 을 도시한다. LOM은 지식 호출 프롬프트(KIP; Knowledge Invocation Prompt) 모듈에 의해 이러한 지식을 생성하도록 호출된다. 규제 준수 지식(Regulatory Compliance Knowledge)은 UKF 클러스 터(C854F)의 여러 인스턴스의 구축으로 설명된다. UKF 클러스터(C854F)의 개별 요소는 규칙 구문 포맷(Rule Syntax Format)(C538)에 저장된 UKF1, UKF2 및 UKF3 서브 유닛의 구성으로 자세히 설명된다. 도 1148은 신경 상태 연관 지식(Neural State Association Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 신경 상태 연관 지식(Neural State Association Knowledge)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임 워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이 러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 앱체인 정 정 패치(Appchain Correction Patch)는 코드 변환(C321)에 의해 인식 구문(Perception Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환 (translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소 (Logical Reduction)(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완 료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관 련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코 드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으 로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브 러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1149는 신경 상태 연관 지식(Neural State Association Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1148의 논리 흐름을 계속한 다. . 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관 성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프 한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 신경 상태 연관 지식(Neural State Association Knowledge)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1150은 13104단계에서 도 1146의 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement)의 논리 흐름을 계속한다. 13104단계는 도 1147에 도시된 바와 같이, 신경 상태 연관 지식(Neural State Association Knowledge)을 생성하기 위해 LOM를 호출한다. 13114단계는 진화 경로 신경 상태 연관 지식(Neural State Association Knowledge) 변수 내에 존재하는 약간의 결과 변화(variance)로부터 경 로 특성(Pathway Personalities)과 따라서, 진화 경로(Evolution Pathways)를 생성한다. 13116단계는 내부적으 로 일관성을 보장하도록 스트레스 테스트하고 신경 상태 연관 지식을 조정하기 위해 I2GE를 호출한 다. 13118단계는 13116단계에서 리파인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)의 형태로 호출된 I2GE 인스턴스로부터 모듈식 출력을 수신한다. 13110단계에서, LIZARD은 신경 상태 연관 지식을 목적 계층 맵(Purpose Hierarchy Map)으로 변환한다. 13122단계는 리파인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위해 LIZARD을 호출한다. 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)은 두 개의 맵 13124와 13112를 처리하기 위해 호출되며, 그 논리 흐름은 도 1156에 도시한다. 도 1151은 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement)의 13114단계에 관한 작동 세 부 사항에 대해 자세히 설명한다. 신경 상태 연관 지식(Neural State Association Knowledge)은 메이크 업 변형(Makeup Variations)을 생성하기 위해 입력 창조적 변형(ICV; Creative Variance) 모듈 에 제출된다. 이러한 변형은 13130단계에서 분석(unpacked)되고, 이는 13132단계의 실행으로 이어진다. 새로 호출된 I2GE 인스턴스의 각 진화 경로(Evolution Pathway)(C867A)의 베이스 제너레이션 (generation)(N1)는 공백으로 시작된다. I2GE 에뮬레이션이(emulation) 시작되면, 진화 경로(EvolutionPathways)(C867A)은 해당 경로 특성(Pathway Personality)(C867D) 정의에 따라 진화한다. 이러한 경로 특성 (C867D)은 후속 스테이지2에 설치되며, 이는 메이크업 변형 변수 모음(variable collection)을 수신하며 I2GE 인스턴스에서 해당 특성(Personalities)(C867D)으로 설치한다. 각 진화 경로(C867A)는 I2GE 인스턴스 내에서 가상 분리(Virtual Isolation)을 통해 서로에 의해 논리적으로 분리된다. 따라 서 진화 경로(C867A)에서 생성된 결과가 다른 잠재적(potential) 요인에 의해 편향되지 않고 영향을 받지 않는 다는 암시적인 보증(implied guarantee)이 있다. 도 1152는 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement)의 13116단계의 기능과 작동 에 대해 자세히 설명한다. 복잡한 시나리오 정의(Complex Scenario Definition) 인공 보안 위협(AST; Artificial Security Threat) 모듈에 의해 환경 테스트를 받는 다중 병렬 진화 경로(multiple parallel Evolution Pathways)(C867A)에 의해 에뮬레이션(emulated)된다. I2GE 에뮬레이션 처리가 완료되면, 결과 는 프롬프트에 모듈식 출력을 제출하는 반복 결론 프로세서(Iteration Conclusion processor)에 서 처리된다. 프롬프트는 I2GE 에뮬레이션 세션(emulation session)에서 생성된 안정화된 신경 상 태 연관 지식(Neural State Associa-tion Knowledge)의 양을 평가한다. 프롬프트에 대한 응답은 예, 충분히 안정적임(Yes, Sufficiently Stable)으로 간주되며, 포화 기준(Saturation Criteria)가 리파인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)의 변 화(variance) 및 안정성에 대해 충족된다. 도 1153은 진화 경로(Evolution Pathway)(C867) 내에 순차적으로 구축된 다중 제너레이션(multiple Generations)을 도시한 도 1151 및 도 1152의 기능에 대해 상세히 설명한다. 신경 상태 연관 지식 (Neural State Association Knowledge)에서 생성되고 LIZARD의 니드 맵 매칭(NMM; Need Map Matching)(C114) 모듈에서 생성된 메이크업 변형(Makeup Variations)은 I2GE 에뮬레이션 세션 (emulation session)에서 생성된 순차적인 제너레이션(sequential Generations)을 상호 연관시키고 나타 낸다. 세션이 계속되면서, BCHAIN 네트워크(BCHAIN Network)에서 호스팅되는 경로 지정(Pathway Designation)은 진화 경로(Evolution Pathway)(C867)이 될 수 있는 세 가지 상태를 나타내며 즉, 안정됨 으로 전달됨(Passed as Stable), 진화를 기다림(Pending Evolution), 포기/삭제 (Abandoned/Deleted)가 있다. 해당 경로 특성(Pathway Personality)(C867D)가 초기 경로(C867) 상태와 구성의 상속 결함(inherit flaw in composition) 그리고/또는 상속 비호환성(inherit incompatibility)을 표시 하는 경우, 경로(C867)이 삭제될 수 있다. 도 1154는 리파인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 리파 인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨 터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모 든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드 의 구문적 해석을 제공한다. 상기 리파인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)는 코드 변환(C321)에 의해 인식 구문(Perception Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한 다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323)에 입력으 로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위 해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절 히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석 (C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에 서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역 이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암 호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코 드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대 한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정 책 변수로 작동한다. 도 1155는 리파인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1154의 논리 흐 름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함 수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 리파인된 신경 상태 연합 지식 (Refined Neural State Association Knowledge)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1156은 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement) 모듈의 동작 및 기능을 설명 하기 위해 도 1150의 논리 흐름을 계속한다. 13140단계에서, 목적 대 목적 대칭 처리(Purpose to Purpose Symmetry Processing, P2SP)는 신경 상태 연합 지식(Neural State Association Knowledge)의 목 적 계층 맵(Purpose Hierarchy Map)와 리파인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)의 목적 계층 맵(Purpose Hierarchy Map)을 처리하기 위해 호출된다. 13140단계의 처리는 프롬프트의 활성화로 이어지고, 이는 목적 계층 맵가 목적 계층 맵와 일치(congruent)하고 호환(compatible)되는지를 평가하기 위해 대칭 처리 결과(Symmetry Processing Result)를 해석한다. 프롬프트에 대한 아니요, 불일치(No, Not Congruent) 응답은 도 1162에서 실현되며, 이는 도 1127의 동일한 종료(termination)/진단 로그(diagnostic logic)를 따른다. 프롬프 트에 대한 예, 일치(Yes, Congruent) 응답은 13150단계 및 13154단계로 이어진다. 13150단계는 신경 상태 연관 지식(Neural State Association Knowledge)의 목적 계층 맵를 앱체인 구문 (Appchain Syntax)으로 변환하여 LIZARD을 호출하며 따라서, 오리지널 앱체인 보유(Original Appchain Retention)를 모듈식 출력으로 생성한다. 리파인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)의 목적 계층 맵(Purpose Hierarchy Map)을 앱체인 구문으로 변환하기 위해 마찬가지로, 13154단계는 LIZARD을 호출하며 따라서, 업그레이드된 앱체인 보유(Upgraded Appchain Retention)을 생성한다. 두 개의 보유(Retentions) 13151 및 13156은 도 1161에 설명된 바와 같이, 배 포 패치 어셈블리(DPA; Deployment Patch Assembly) 모듈에 모듈식 입력으로 사용된다. 도 1157은 신경 상태 연관 지식(Neural State Association Knowledge)의 목적 계층 맵(Purpose Hierarchy Map)을 앱체인 구문(Appchain Syntax)으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 맵은 복합 목적 포맷(C325)으로 존재하며 LIZARD의 외부 코어(OC; Outer Core)(C329) 내에서 목적 모듈(PM; Purpose Module)(C36)의 반복 확장(Iterative Expansion)(C327)에 제출된다. 반복 확장(C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 맵에 정의됨) 세부 사항과 복잡도(complexity)를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미 분(Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 포텐셜 (potential)은 복합 목적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC)(C333)의 핵심 코드(C335) 요소는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리 및 로드 밸런싱 스크립 트(Thread Management and Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템(Memory Management systems)을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(Syntax Module)(C35) 및 PM(Purpose Module)(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(C336) 요 소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하 는 정적 정책 변수로 작동한다.도 1158은 오리지널 앱체인 보유(Original Appchain Retention)로 언급되는 앱체인 구문(Appchain Syntax)으로 목적 계층 맵(Purpose Hierarchy Map)을 변환하기 위한 LIZARD의 작동을 설명하기 위 해 도 1157의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM; Purpose Module)(C36)의 복합 목적 포맷 (C325)로 수신되고, 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된 다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수 (functions)를 도출한다. 이는 만약 함수가 더 간단한 상위의 함수(parent function)로부터 영향으로 인해 도함 수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것 을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수(function dependencies)의 트리(tree)이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC; Inner Core)(C33 3)의 핵심 코드(Core Code)(C335) 요소로부터 상속된 규칙 및 구문(Rules and Syntax)(C322) 정의에 따라 작동 한다. 논리적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(Syntax Module)(C35)에서 인식하고 이해하는 임의의(일반적인) 코드(arbitrary (generic) code)를 알려진 선택된 계산 언어로 변환한다. 코드 변환(C321)은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수 (inverse function)도 수행한다. 따라서 PM(Purpose Module)(C36)은 코드 변환(C321)을 통해 입력 신경 상태 연관 지식(Neural State Association Knowledge)의 결과 앱체인 구문 버전(resultant Appchain Syntax Version)을 생성하기 위해 SM(Syntax Module)(C35)를 호출한다. 코드 변환(C321)에 의해 최종적으로 생 성되는 결과 오리지널 앱체인 보유(resultant Original Appchain Retention)는 SM(Syntax Module)(C35), 외부 코어(OC; Outer Core)(C329) 및 LIZARD의 모듈식 출력이다. 도 1159는 리파인된 신경 상태 연합 지식(Refined Neural State Association Knowledge)의 목적 계층 맵(Purpose Hierarchy Map)을 앱체인 구문(Appchain Syntax)으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 맵은 복합 목적 포맷(C325)으로 존재하며 LIZARD의 외부 코어(OC; Outer Core)(C329) 내에서 목적 모듈(PM; Purpose Module)(C36)의 반복 확장(Iterative Expansion)(C327)에 제 출된다. 반복 확장(C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 맵에 정 의됨) 세부 사항과 복잡도(complexity)를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분 (Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 포텐셜 (potential)은 복합 목적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC)(C333)의 핵심 코드(C335) 요소는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리 및 로드 밸런싱 스크립 트(Thread Management and Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템(Memory Management systems)을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(Syntax Module)(C35) 및 PM(Purpose Module)(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(C336) 요 소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하 는 정적 정책 변수로 작동한다. 도 1160은 업그레이드된 앱체인 보유(Upgraded Appchain Retention)로 언급되는 앱체인 구문(Appchain Syntax)으로 목적 계층 맵(Purpose Hierarchy Map)을 변환하기 위한 LIZARD의 작동을 설명하기 위 해 도 1159의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM; Purpose Module)(C36)의 복합 목적 포맷 (C325)로 수신되고, 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된 다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수 (functions)를 도출한다. 이는 만약 함수가 더 간단한 상위의 함수(parent function)로부터 영향으로 인해 도함 수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것 을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수(function dependencies)의 트리(tree)이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC; Inner Core)(C33 3)의 핵심 코드(Core Code)(C335) 요소로부터 상속된 규칙 및 구문(Rules and Syntax)(C322) 정의에 따라 작동 한다. 논리적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(Syntax Module)(C35)에서 인식하고 이해하는 임의의(일반적인) 코드(arbitrary (generic) code)를 알려진 선택된 계산 언어로 변환한다. 코드 변환(C321)은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수 (inverse function)도 수행한다. 따라서 PM(Purpose Module)(C36)은 코드 변환(C321)을 통해 입력 리파인된 신 경 상태 연합 지식(Refined Neural State Association Knowledge)의 결과 앱체인 구문 버전(resultant Appchain Syntax Version)을 생성하기 위해 SM(Syntax Module)(C35)를 호출한다. 코드 변환(C321)에 의 해 최종적으로 생성되는 결과 업그레이드된 앱체인 보유(Upgraded Appchain Retention)는 SM(SyntaxModule)(C35), 외부 코어(OC; Outer Core)(C329) 및 LIZARD의 모듈식 출력이다. 도 1161은 도 1156의 13158단계에서 논리 흐름을 재개함으로써 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement)의 동작 및 기능을 도시한다. 오리지널 앱체인 보유(Original Appchain Retention) 및 업그레이드된 앱체인 보유(Upgraded Appchain Retention)는 배포 패치 어셈블리 (DPA; Deployment Patch Assembly) 모듈에서 처리할 수 있도록 모듈식 입력으로 13158단계에 전송되며, 따라서 앱체인 정정 패치(Appchain Correction Patch)이 생성된다. DPA(Deployment Patch Assembly)은 앱체인 구문(Appchain Syntax)에서 입력 13152와 13156의 차이를 측정하고 정의하며, 따라 서 오리지널 앱체인 보유(Original Appchain Retention)를 업그레이드된 앱체인 보유(Upgraded Appchain Retention)로 변환하기 위한 앱체인 구문 명령어(Appchain Syntax instructions)를 생성한다. 이러한 명령어(Instructions)는 앱체인 정정 패치(Appchain Correction Patch)으로 참조되며, 해당 신 경학 맵핑 향상(NME; Neurologic Mapping Enhancement) 인스턴스의 세션(임시(temporary)/비영구(non- persistent)) 변수로 초기에 저장된다. 따라서 세션 쓰기 데이터 세그먼트(Session Write Data Segment) 명령 유형(Command Type)은 NME(Neurologic Mapping Enhancement) 인스턴스를 호스팅하는 실행 스트림 렌더링(ESR; Execution Stream Rendering) 인스턴스 내에서 사용된다. 13162단계에서, 앱체인 정 정 패치는 커스텀체인 에코시스템 빌더(CEB; CustomChain Ecosystem Builder) 모듈의 호출을 통해 중앙 지식 보유(CKR; Central Knowledge Retention) 스토리지를 지속하도록 전념한다. 13162단계에서, 수 행된 작동은 영구 쓰기 데이터 세그먼트(Persistent Write Data Segment)(64220 명령 유형(Command Type)을 호출하기 위해 호스트 실행 스트림 렌더링(ESR; Execution Stream Rendering) 인스턴스를 초래한다. 도 1162는 프롬프트에 대한 아니요, 불일치(No, Not Congruent)의 응답에 관한 논리 흐름을 설 명하기 위해 도 1156에서 논리 흐름을 계속한다. 그 후 공식 시스템 토큰(Official System Token)을 포 함하는 진단 로그 유닛(DLU; Diagnostic Log Unit)를 제출하는 5600단계가 발생한다. UBEC 플랫폼 내의 공식 기능(official function)인 경우, 이 토큰는 해당 기능 또는 프로그램이 비이상적인 상태에 도 달했음을 표시하기 위해 포함된다. DLU는 진단 로그 제출(DLS; Diagnostic Log Submission)에 제 출되며, 이는 DLU를 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)에 공급 하기 위해 LOM의 자동화된 리서치 매커니즘(ARM; Automated Research Mechanism)에 의해 호출된다. 따라서 SPSI(Self Programming Self Innovation)은 진단 로그 유닛 분석(DLUA; Diagnostic Log Unit Analysis) 모듈을 포함하는 DLU에서 찾은 진단 정보를 처리 할 수 ?있다. 이는 아니요, 불일치(No, not congruent) 응답이 프롬프트로 호출된 초기의 이유를 피하기 위해 I2GE 그리고/또는 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement)에 해당 수정을 실행하기 위해 호출되도록 DLUA을 나타내는 13005단계로 이어진다. 도 1163은 도 1146의 13110단계에서 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement)의 논리 흐름을 계속한다. 13110단계는 신경 상태 연관 지식(Neural State Association Knowledge)의 목적 계층 맵(Purpose Hierarchy Map)으로 변한하기 위해 LIZARD을 호출한다. 13162단계에서, LIZARD은 미가공 신경 패턴(Raw Neural Pattern)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위해 호출된다. 13168단계에서, LIZARD는 타겟 정황 상태(Target Circumstantial State)를 목적 계층 맵으로 변환하기 위해 호출된다. 13170단계에서, 목적 대 목적 대칭 처리(Purpose to Purpose Symmetry Processing, P2SP)가 목적 계층 맵와 목적 계층 맵를 처리하기 위해 호출되며, 따라서 대칭 처리 결과(Symmetry Processing Result)를 생성한다. 그 후, 프롬프트는 논리 흐름 이 도 1168에 도시된 대칭 처리 결과를 해석하기 위해 호출된다. 도 1164는 미가공 신경 패턴(Raw Neural Pattern)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 미가공 신경 패턴(Raw Neural Pattern)은 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C3 5)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위 해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한 다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코 드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포 함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의 사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 미가공 신경 패턴(Raw Neural Pattern)은 코드 변환(C321)에 의해 신경 구문(Neural Syntax) 형식으로 수신된다. 코드 변환 (C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323)에 입력으 로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위 해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절 히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석 (C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에 서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보 수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역 이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암 호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코 드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대 한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정 책 변수로 작동한다. 도 1165는 미가공 신경 패턴(Raw Neural Pattern)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1164의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석 (Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 미가공 신경 패턴(Raw Neural Pattern)의 복 합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1166는 타겟 정황 상태(Target Circumstantial State)를 목적 계층 맵으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 타겟 정황 상태(Target Circumstantial State)는 외 부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모 듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷 (C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while 루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼 (helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능 한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴 퓨터 코드의 구문적 해석을 제공한다. 상기 타겟 정황 상태(Target Circumstantial State)는 코드 변환 (C321)에 의해 상태 구문(State Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환 (C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한 다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출 력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정 의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이 진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(PurposeAssociations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않 고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드 (C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하 는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1167는 타겟 정황 상태(Target Circumstantial State)를 목적 계층 맵으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1166의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참 조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 PM(C36), 외부 코어(OC)(C329) 따라서, LIZARD을 위한 모듈식 출력으로 제출되는 복합 목적 포맷(Complex Purpose Format)(C325)이 존재한다. 출력은 타겟 정황 상태(Target Circumstantial State)의 복합 목적 포맷 (C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1168은 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement)의 동작 및 기능을 설명하기 위해 프롬프트에서 도 1163의 논리 흐름을 계속한다. 프롬프트는 미가공 신경 패턴(Raw Neural Pattern)의 목적 계층 맵이 신경 상태 연관 지식(Neural State Association Knowledge) 의 목적 계층 맵(Purpose Hierarchy Map)과 일치하며 호환 가능한지 결정하기 위한 대칭 처리 결과 (Symmetry Processing Result)를 해석한다. 아니요, 불일치(No, Not Congruent)의 프롬프트 에 대한 응답은 도 1169에 도시된 논리 흐름을 갖는다. 프롬프트에 대한 예, 일치(Yes, Congruent) 응답은 13180단계의 활성화로 이어지며, 이는 타겟 마인드(Target Mind)의 클레임된 정황 상태(Claimed Circumstantial State)를 생성하기 위해 미가공 신경 패턴(Raw Neural Pattern)을 처리하도록 신경 상태 연관 룩업(NSAL; Neural State Association Lookup) 모듈을 호출한다. NSAL(Neural State Association Lookup)는 클레임된 정황 상태(Claimed Circumstantial State)와 같이, 미가공 신경 패턴를 해석하고 존재하는 인식된 연관 암시(perceived association implication)를 제출하기 위해 (LOM에서 생성되는) 신경 상태 연관 지식(Neural State Association Knowledge)을 참조한다. 예를 들어, 신경 상태 연관 지식에 따르면, 미가공 신경 패턴의 구성은 타겟 마인드가 현재 교통 체증에 갇혀 있는 신뢰도의 높은 정도를 나타낸다. (따 라서 클레임된 정황 상태(Claimed Circumstantial State)에 표시된다.) 13184단계에서, LIZARD는 클레임된 정황 상태를 목적 계층 맵으로 변환하기 위해 호출된다. 13188단계에서, 목적 계층 맵 13186 및 13192는 도 1172에 도시된 다음의 논리 흐름과 함께, 목적 대 목적 대칭 처리(Purpose to Purpose Symmetry Processing, P2SP)에 의해 처리된다. 도 1169는 프롬프트에 대한 아니요, 불일치(No, Not Congruent)의 응답과 관련된 논리 흐름을 설명하기 위해 도 1156 및 도 1162로부터 논리 흐름을 계속한다. 그 후, 공식 시스템 토큰(Official System Token)을 포함하는 진단 로그 유닛(DLU; Diagnostic Log Unit)을 제출하는 5600단계가 발생한다. UBEC 플랫폼 내의 공식 기능(official function)인 경우, 이 토큰(Token)는 해당 기능 또는 프로그 램이 비이상적인 상태에 도달했음을 표시하기 위해 포함된다. DLU는 진단 로그 제출(DLS; Diagnostic Log Submission)에 제출되며, 이는 DLU를 자체 프로그래밍 자체 혁신(SPSI; Self Programming Self Innovation)에 공급하기 위해 LOM의 자동화된 리서치 매커니즘(ARM; Automated Research Mechanism)에 의해 호출된다. 따라서 SPSI(Self Programming Self Innovation)은 진단 로그 유닛 분 석(DLUA; Diagnostic Log Unit Analysis) 모듈을 포함하는 DLU에서 찾은 진단 정보를 처리 할 수 있다. 이는 아니요, 불일치(No, not congruent) 응답이 프롬프트로 호출된 초기의 이유를 피하기 위해 I2GE 그리고/또는 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement)에 해당 수정을 실행하기 위해 호출되도록 DLUA을 나타내는 13005단계로 이어진다. 도 1170는 클레임된 정황 상태(Claimed Circumstantial State)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 클레임된 정황 상태(Claimed Circumstantial State)는 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성 에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 클레임된 정황 상태(Claimed Circumstantial State)는 코드 변환(C321)에 의해 상태 구문(State Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수 (inverse function)도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323) 에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴 스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위 해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절 히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석 (C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에 서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보 수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역 이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암 호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코 드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대 한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정 책 변수로 작동한다. 도 1171는 클레임된 정황 상태(Claimed Circumstantial State)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1170의 논리 흐름을 계속한다. 구문 모 듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 출력은 클레임된 정황 상태(Claimed Circumstantial State)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1172는 도 1168에서 논리 흐름을 재개한 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement)의 작동 및 기능을 도시한다. 13194단계에서, 목적 대 목적 대칭 처리(Purpose to Purpose Symmetry Processing, P2SP)은 클레임된 정황 상태(Claimed Circumstantial State)의 계층 구조 맵(Purpose Hierarchy Map) 및 타겟 정황 상태(Target Circumstantial State)의 목적 계층 맵을 처리하기 위해 호출되며, 대칭 처리 결과(Symmetry Processing Result)를 생성한다. 프롬프트에서, 결과 은 목적 계층 맵이 목적 계층 맵와 일치하고 호환된다고 해석하는지에 관해서 해석된다. 아니요, 불일치(No, Not Congruent) 응답에 대한 논리 흐름은 도 1174에 도시된다. 프롬프트에 대한 응답이 예, 일치9Yes, Congruent)인 경우, 프롬프트가 타겟 정황 상태 신뢰도(Target Circumstantial State Confidence)가 높은지 낮은지를 해석하여 호출된다. 프롬프트에 대한 높 은 신뢰도(High Confidence) 응답은 결론(Conclusion)의 활성화로 이어지며, 이는 신경 상태 연 관 지식(Neural State Association Knowledge)의 해당 섹터(sector)가 연관 클레임(claims)에 대한 높 은 신뢰도를 나타내는 것으로 입증되었음을 명시한다. 도 1173은 예, 일치(Yes, Congruent) 응답을 포함하는 프롬프트에서 도 1172의 논리 흐름을 재 개한다. 결론(Conclusion)이 활성화에 따라, 13210단계는 LOM 및 CTMP에 높은 신뢰도의 증거를 전달하기 위해 호출되며, 따라서 중앙 지식 보유(CKR; Central Knowledge Retention)에 유지되는 바와 같이, 신경 상태 연관 지식(Neural State Association Knowledge)의 향후 반복(future iterations)에 영향을 미친다. 따라서 LOM와 CTMP를 호출하는 점진적인 자체 학습 루프(gradual self-learning loop)는 완전한 사이클(circle)로 되었다. 프롬프트에 대한 응답이 낮은 신뢰도(Low Confidence)인 경우, 13214단계는 타겟 정황 상태(Target Circumstantial State)의 정확한 신뢰 도(Accuracy Confidence)를 증가시켜 호출된다. 따라서 13216단계에서, 타겟 정황 상태는 타겟 마인드 (Target Mind)를 구성하는 참조와 함께 타겟 행동 리코딩(TBR; Target Behavior Recording)에 제출된다. 이는 타겟 정황 상태(Target Circumulous State)에 관한 새로운 정보를 기록하고 보유하기 위 해 타겟 마인드(Target Mind)와 연관성이 있는 개인 지능 프로파일(PIP; Personal Intelligence Profile) 인스턴스를 야기한다. 도 1174는 아니요, 불일치(No, Not Congruent) 응답을 포함하는 프롬프트 13204에서 도 1172의 논리 흐 름을 재개한다. 프롬프트은 타겟 정황 상태 신뢰도(Target Circumstantial State Confidence)의 값(value)이 높음(High) 또는 낮음(Low)인지 해석한다. 높은 신뢰도(High Confidence) 응답은 결론를 호출하며, 이는 새로운 미가공 신경 패턴(Raw Neural Pattern)이 학습하기 위해 LOM 및 CTMP에서 발견되었다는 것을 정의한다. 결론는 LOM 및 CTMP에 해당 타겟 정황 상태(Target Circumstantial State) 변수과 마찬가지로 미가공 신경 패턴(Raw Neural Pattern)을 제출하는 13226단계로 이어지고, 따라서 중앙 지식 보유(CKR; Central Knowledge Retention)에 유지된대로 신경 상태 연관 지식(Neural State Association Knowledge)의 향후 반복 (future iterations)에 영향을 미친다. 따라서 LOM와 CTMP를 호출하는 점진적인 자체 학습 루프 (gradual self-learning loop)는 완전한 사이클(circle)로 되었다. 프롬프트에 대한 응답이 낮은 신뢰 도(Low Confidence)인 경우, 13228단계는 호출된다. 타겟 정황 상태(Target Circumstantial State)의 정확한 신뢰도(Accuracy Confidence)를 증가시켜 호출된다. 따라서 13216단계에서, 타겟 정황 상태는 타겟 마인드(Target Mind)를 구성하는 참조와 함께 타겟 행동 리코딩(TBR; Target Behavior Recording)에 제출된다. 이는 타겟 정황 상태(Target Circumulous State)에 관한 새로 운 정보를 기록하고 보유하기 위해 타겟 마인드(Target Mind)와 연관성이 있는 개인 지능 프로파일(PIP; Personal Intelligence Profile) 인스턴스를 야기한다. 도 1175는 프롬프트에서 도 1172의 논리 흐름을 재개한다. 프롬프트의 응답 13200 및 13202는 각각은 논리 흐름의 고유한 독립적인 논리 흐름 경로로 이어지며, 프롬프트은 다른 두 개의 스레드 13200 및 13202의 진행 상태 또는 완료 상태와는 독립적인 그것의 고유한 병렬 스레드 호출(Parallel Thread Invocation)를 생성한다. 병렬 스레드 호출(Parallel Thread Invocation)은 타겟 정황 상태 신 뢰도(Target Circumstantial State Confidence)가 높거나 낮은지를 평가하는 프롬프트으로 이어 진다. 프롬프트에 대한 응답이 높은 신뢰도(High Confidence)인 경우, 13238단계가 호출된다. 13238단계는 신경 상태 연관 룩업(NSAL; Neural State Association Lookup)는 타겟 정황 상태(Target Circumstantial State) 및 신경 상태 연관 지식(Neural State Association Knowledge)에 참조함 으로써 글레임된 신경 패턴(Claimed Neural Pattern)을 생성한다. 따라서 13238단계는 도 1168에서 13180단계의 역함수(inverse function)를 수행한다. 13238단계 내에서 절차의 예는 다음과 같다. 타겟 정황 상 태는 타겟 마인드(Target Mind)가 현재 교통 체증에 갇혀 있고 늦게 작동한다고 정의한다. 따라 서 13100단계 및 신경 상태 연관 지식은 모듈식 입력으로 NSAL(Neural State Association Lookup)에 제출다. 따라서 NSAL는 그들이 타겟 정황 상태를 경험하기 때문에, 타겟 마인 드에서 존재하는 현재 신경 패턴의 최상 추정 표현(best estimate representation)을 정의하는 클레임 된 신경 패턴(Claimed Neural Pattern)을 생성한다. 13240단계에서, LIZARD은 도 1178에 도시된 바와 같이, 클레임된 신경 패턴을 목적 계층 맵으로 변환하기 위해 호출된다. 도 1176는 클레임된 신경 패턴(Claimed Neural Pattern)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 클레임된 신경 패턴(Claimed Neural Pattern)는 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성 에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 클레임된 신경 패턴(Claimed Neural Pattern)는 코드 변환(C321)에 의해 신경 구문(Neural Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한 다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323)에 입력으 로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위 해 의도된 기능성을 적절히 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감 지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복 합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프 로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리 (Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1177는 클레임된 신경 패턴(Claimed Neural Pattern)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1176의 논리 흐름을 계속한다. 구문 모 듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 출력은 클레임된 신경 패턴(Claimed Neural Pattern)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵 으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1178은 신경 경제 매핑 향상(NME; Neuroeconomic Mapping Enhancement)의 동작 및 기능을 계속하며, 도 1175의 13240단계에서 논리 흐름을 재개한다. 13240단계는 클레임된 신경 패턴(Claimed Neural Pattern)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위해 LIZARD를 호출한다. 13244단계는 목적 계층 맵 13242 및 13164를 처리하기 위해 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)을 호출하며, 따라서 대칭 처리 결과(Symmetry Processing Result)을 생성 한다. 프롬프트은 목적 계층 맵(Purpose Hierarchy Map)이 목적 계층 맵과 일치하고 호 환하는지 평가하기 위해 대칭 처리 결과(Symmetry Processing Result)을 해석한다. 프롬프트에 대한 두 가지 잠재적인(potential) 응답은 예, 일치(Yes, Congruent) 및 아니요, 불일치(No, Not Congruent)이며, 그 논리는 도 1179에 도시된다. 도 1179는 도 1178의 논리 흐름을 계속한다. 프롬프트은 응답 13250/13252로 이어질 수 있는 대칭 처리 결과(Symmetry Processing Result)를 해석한다. 아니요, 불일치(No, Not Congruent) 응답에 대 한 논리 흐름은 도 1181에서 평가된다. 예, 일치(Yes, Congruent) 응답은 신경 상태 연관 지식 신뢰도 (Neural State Association Knowledge Confidence) 값(value)의 현재 값을 해석하는 프롬프트의 활성화로 이어진다. 프롬프트에 대한 높은 신뢰도(High Confidence) 응답은 타겟 정황 상태 (Target Circumstantial State)및 신경 상태 연관 지식(Neural State Association Knowledge) 과 관련된 알고리즘 신뢰도가 증가했음을 나타내는 결론을 활성화한다. 따라서 LOM 및 CTMP에 대한 증가된 알고리즘 신뢰도(algorithmic confidence)의 새로운 증거(new evidence)를 제시하는 13262단계가 호출되며, 따라서 중앙 지식 보유(CKR; Central Knowledge Retention)에 유지된대로 신경 상태 연관 지식 (Neural State Association Knowledge)의 향후 반복(future iterations)에 영향을 미친다. 따라서 LOM및 CTMP를 호출하는 점진적인 자체 학습 루프(gradual self-learning loop)는 완전한 사이클 (circle)로 되었다. 낮은 신뢰도(Low Confidence) 응답에 대한 논리 흐름이 도 1180에 도시된다.도 1180은 프롬프트에서 도 1179의 논리 흐름을 계속하며, 낮은 신뢰도(Low Confidence) 응답에 관한 작동을 디스플레이한다. 이러한 응답(Response)은 결론(Conclusion)를 활성화하며, 이는 신경 상태 연관 지식 신뢰도(Neural State Association Knowledge Confidence)가 해당 타겟 정황 상태 신뢰도(Target Circumstantial State Confidence)의 크기(magnitude)에 따라 강화(strengthened)/증가 (increased)됨을 지시한다. 결론는 13266단계로 이어지고, LOM및 CTMP에 대한 증가된 알고리 즘 신뢰도의 해당 증거(evidence)는 중앙 지식 보유(CKR; Central Knowledge Retention)에서 유지된대로 신경 상태 연관 지식(Neural State Association Knowledge)의 향후 반복(future iterations)에 영향을 미친다. 따라서 LOM및 CTMP를 호출하는 점진적인 자체 학습 루프(gradual self-learning loop)는 완 전한 사이클(circle)로 되었다. 도 1181은 도 1179의 프롬프트에서 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement)의 논리 흐름을 계속한다. 아니요, 불일치(No, Not Congruent) 응답은 프롬프트을 활성화하며, 이는 신경 연관 지식 신뢰도(Neural State Association Knowledge Confidence)의 값(value)이 높음 (High) 또는 낮음(Low)인지 평가한다. 낮은 신뢰도(Low Confidence) 응답에 대한 논리 흐름이 도 1183에 도시된다. 높은 신뢰도(High Confidence) 응답은 프롬프트의 활성화로 이어지 며, 이는 신경 상태 연관 지식 신뢰도(Neural State Association Knowledge Confidence)과 타겟 정황 상태 신뢰도(Circumstantial State Confidence) 사이의 알고리즘 신뢰도 순위(algorithmic confidence ranking)를 비교한다. 프롬프트의 응답은 도 1182에서 평가된다. 도 1182는 도 1181의 프롬프트에서 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement)의 논리 흐름을 계속한다. 프롬프트는 신경 상태 연관 지식 신뢰도(Neural State Association Knowledge Confidence) 또는 타겟 정황 상태 신뢰도(Circumstantial State Confidence)가 알고리즘 신뢰도 에서 더 큰지 해석한다. 프롬프트에 대한 응답이 니어 상태 연합 지식(Near State Association knowledge)인 경우, 13280단계가 타겟 정황 상태 신뢰도(Circumstantial State Confidence)는 덜 신뢰적인 것으로 표시되어 호출된다. 프롬프트에 대한 응답이 타겟 정황 상태(Target Circumstantial State)인 경우, 13282단계가 신경 상태 연항 지식 신뢰도가 덜 신뢰적인것으로 표시되어 호출된다. 따라서 이 신뢰도 알고리즘은 알고리즘 신뢰도와 관련하여 안정적인 프레임의 참조를 발견하기 위해 찾으며, 따라서 신뢰 도 등급(rating)에 감소와 함께 약한 링크(weaker link)를 퍼니싱(punishing)한다. 두 개의 포텐셜 응답 (potential Responses) 13280과 13282는 모두 호출되는 13284단계로 이어지며, 이는 LOM와 CTMP에 증가된 알고리즘 신뢰도의 해당 증거를 전달되며, 따라서 중앙 지식 보유(CKR; Central Knowledge Retention)에서 유지된대로 신경 상태 연관 지식(Neural State Association Knowledge)의 향후 반 복(future iterations)에 영향을 미친다. 따라서 LOM및 CTMP를 호출하는 점진적인 자체 학습 루프 (gradual self-learning loop)는 완전한 사이클(circle)로 되었다. 도 1183은 도 1181의 프롬프트에서 신경학 맵핑 향상(NME; Neurologic Mapping Enhancement)의 논리 흐름을 계속한다. 프롬프트은 신경 상태 연관 지식 신뢰도(Neural State Association Knowledge Confidence)이 높은 값 또는 낮은 값인지 여부를 해석한다. 낮은 신뢰도(Low Confidence) 응답 에 대한 논리가 도시되며, 이는 신경 상태 연관 지식 신뢰도(Neural State Association Knowledge Confidence)의 알고리즘 신뢰도 레벨(algorithmic confidence level)을 표시하는 13286단계를 호출한다. 따라서 13288단계는 증가된 알고리즘 신뢰도의 해당 증거를 LOM 및 CTMP로 전달하며, 따라 서 중앙 지식 보유(CKR; Central Knowledge Retention)에서 유지된대로 신경 상태 연관 지식(Neural State Association Knowledge)의 향후 반복(future iterations)에 영향을 미친다. 따라서 LOM및 CTMP를 호출하는 점진적인 자체 학습 루프(gradual self-learning loop)는 완전한 사이클(circle)로 되었 다. 도 1184는 기부 구조(ES; Endowment Structure) 내에서 로그 집계(Log Aggregation)의 작동 및 적용을 도시한다. 로그 집계는 관리 콘솔(MC; Management Console)과 지능형 정보 및 구성 관리(I2CM; Intelligent Information and Configuration Management)의 두 가지 주요 모듈로 구성된 정보 관리 관할 구역이다. 모든 로그 정보 출력은 I2CM의 구성 및 배포 서비스(Configuration and Deployment Service)(C153)에 모듈식 입력으로 제출된다. 이사회(BD; Board of Directors) 인스턴스 또는 독립 디 텍터(ID; Independent Director) 인스턴스가 로그 집계 전체와 상호 작용하며, 이 방식으로 디텍터 12006/12022는 MC을 통해 제안 투표 인터페이스(PVI; Proposal Voting Interface)과 같은 다양한 ES 기능과 상호 작용할 수 있다. 구성 및 배포 서비스(Configuration and Deployment Service)(C153)은올바른 보안 구성 및 연결 설정으로 새로운 엔터프라이즈 자산(노트북, 노트북, 휴대 전화)을 배포하기 위한 인 터페이스이다. 장치를 추가하고 설정한 후에, 중간 관리자로 피드백 컨트롤을 포함하는 MC을 통해 조정할 수 있다. 서비스(C153)은 (UBEC 사용자과 같은). 새로운 사용자 계정의 배포도 관리한다. 이러한 배포는 사용자 계정을 포함하는 하드웨어의 연합, (다양한 사용 목적을 위한) 인터페이스의 사용자 정의 (customization), 고객(customer)/클라이언트(client) 변수의 목록(예를 들면, 비즈니스 유형, 제품 유형 등) 이 포함될 수 있다. 관할구역에 의한 분리(C154)를 사용하면, 태그된 정보의 풀이 관리 콘솔 사용자(Management Console User)의 관련 관할구역에 따라 독점적으로 분리된다. 이벤트에 의한 분리를 사용하면, 정보는 개 별 이벤트에 따라 구성된다. 모든 유형의 데이터는 장황함(verbosity)을 추가한 이벤트와 상관 관계가 있거나 제거된다. 지능형 컨텍스트화(Intelligent Contextualization)(C156)을 사용하면, 나머지 데이터가 이제 아일 랜드(islands), 의 클러스터, 이벤트 발생이 있는 각 아일랜드(islands)처럼 보인다. 상관 관계는 이벤트 분석 을 마스터시키기 위해 상호 플랫폼으로 만들게 된다. 과거 데이터(Historical data)는 (LIZARD에 반대하는 I2GE으로부터) 이벤트 패턴을 이해하기 위해 엑세스되고, CTMP는 비판적 사고 분석(critical thinking analysis)에 사용한다. 그래픽 프리젠테이션/ 시각 매니지먼트(Graphics Presentation/Visual Management)을 사용하면, 필요한 경우, 이 정보를 사용할 수 있음에도 불구하고 정보 소스(information source)(어떤 플랫폼)를 고려하지 않고 진행중 및 과거 이벤트 사건(historical event incidents)이 제공된다. MC 내의 직접 관리(Direct Management)(C161)은 관련 UBEC 사용자이 지정한 제어에 직접 액세스 (access)할 수 있음을 의미한다. 따라서 MC의 직접 관리(C161)은 I2CM의 수동 제어(Manual Controls)(C160)와 연결된다. 카테고리 및 관할구역(Category and Jurisdiction)(C162)를 통해, UBEC 사용자 은 관할구역 및 카테고리 액세스 정보의 범위를 정의하므로 사용자 노드 상호작용(UNI; User Node Interaction)을 통해 인증한다."}
{"patent_id": "10-2024-7015160", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "[00]도 1185 내지 도 1189는 레거시(Legacy) 및 BCHAIN 시스템에 대한 앱체인(Appchains) 및 레거시 프로그램의 작동과 관련하여 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)의 유 용한 예를 설명한다. 도 1185는 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)에 추가하여 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)의 개념을 설명하며, 기존의 레거시 애플리케이션 MPG(Methodology of Perpetual Giving)을 새롭고 입증된 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment) 모듈에 프로그래밍하고 재구성한다. 전체 작동은 (비 BCHAIN 프로토콜 활성화된) 레거시 시스템(Legacy System) 및 레거시 API와 프레임 워크(Legacy API and Framework)에서 발생한다. 따라서 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)은 일반적으로 BCHAIN 네트워크 내에서 독점적으로 실행되는 앱체인(Appchain)이다. 따라서 SPSI은 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)을 통해 레거시 시스템(Legacy System)에서 실행한다. 따라서 AEL이 레거시 및 프레 임 내에 존재하고 작동하는 요소를 엑세스하고 조작할 수 있도록 SPSI를 가능하게 한다. 13308단계 에서, SPSI은 MPG으로 효율성 및 기능 업그레이드, 유지 관리 및 일반 수정을 수행한다. 13310 단계 에서, NMC은 SPSI의 처리(processing)의 결과로 생산된다. 도 1186은 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)에 추가하여 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)의 개념을 설명하며, 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment)의 기존 반복을 NMC의 미래 이론 버전(Future Theoretical Version)으로 개선한다. 전체 작동은 (비 BCHAIN 프로토콜 활성화된) 레거시 시스템(Legacy System) 및 레거시 API와 프레임 워크(Legacy API and Framework)에서 발생한다. 따라서 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)은 일반적으로 BCHAIN 네트워크 내 에서 독점적으로 실행되는 앱체인(Appchain)이다. 따라서 SPSI은 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)을 통해 레거시 시스템(Legacy System)에서 실행한다. 따라서 AEL이 레거시 및 프레임 내에 존재하고 작동하는 요소를 엑세스하고 조작할 수 있도록 SPSI 를 가능하게 한다. 13308단계에서, SPSI은 MPG으로 효율성 및 기능 업그레이드, 유지 관리 및 일반 수정을 수행한다. 13314단계에서, NMC은 SPSI의 처리(processing)의 결과로 생산된다. 도 1187은 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)에 추가하여 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)의 개념을 설명하며, 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment)의 레거시 버전을 앱체인(Appchain)로서 NMC인 앱체인(Appchain)으로 변환한다. 전체 작동은 (비 BCHAIN 프로토콜 활성화된) 레거시 시스템(Legacy System) 및 레거시 API와 프레임 워크(Legacy API and Framework)에서 발생한다. 따라서 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)은 일반적으로 BCHAIN 네트워크 내 에서 독점적으로 실행되는 앱체인(Appchain)이다. 따라서 SPSI은 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)을 통해 레거시 시스템(Legacy System)에서 실행한다. 따라서 AEL이 레거시 및 프레임 내에 존재하고 작동하는 요소를 엑세스하고 조작할 수 있도록 SPSI 를 가능하게 한다. 11318단계에서, SPSI은 커스텀앱체인 에코시스템 빌더(CEB; Customchain Ecosystem Builder)의 호출을 통해 앱체인로써 NMC에 레거시 프로그램(Legacy Program)으로써 NMC를 변 환한다, 13320단계에서, 앱체인으로써 NMC은 SPSI의 작동 처리(processing)의 결과로 생산된다. 따라서 앱 체인변환으로서 최종 NMC는 AEL 내에서 작동한다. 도 1188은 레거시 시스템(Legacy System) 내에서 앱체인(Appchain)로서 NMC(Neuroeconomic Metaphysical Contentment)의 효율성과 기능성을 업그레이드하며, 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)과 함께 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)의 개념을 도시한다. 초기 NMC 버전은 AEL(Appchain Emulation Layer) 내에 앱체인으로 존재한다. 13324단계에서, SPSI(Self Programming Self Innovation)은 NMC의 효율성 및 기능 업그레 이드, 유지 보수 및 일반 수정을 수행한다. 이는 앱체인으로서 NMC의 미래 이론 버전(Future Theoretical Version)의 SPSI에 의해 정의되는 13326단계로 이어진다. 따라서 앱체인은 레거시 시스 템 내에서 직접 실행될 수 있으며 레거시 시스템 내에서 심지어 업그레이드할 수도 있다. 도 1189는 BCHAIN 네트워크 내에서 앱체인(Appchain)로서 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment)의 효율성과 기능을 업그레이드하는 셀프 프로그래밍 셀프 혁신 (SPSI; Self Programming Self Innovation)의 개념을 도시한다. 초기 NMC 버전은 BCHAIN 프로토콜 내에 앱체인(Appchain)으로 존재한다. 13332단계에서, SPSI(Self Programming Self Innovation)은 NMC의 효율성 및 기능 업그레이드, 유지 보수 및 일반 수정을 수행한다. 이는 앱체인 으로서 NMC의 미래 이론 버전(Future Theoretical Version)의 SPSI에 의해 정의되는 13334단 계로 이어진다. 따라서 앱체인은 BCHAIN 네트워크 내에서 직접 실행하고 BCHAIN 네트워크 내에 서 심지어 업그레이드할 수도 있다. 도 1190은 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation) 내에서 작동하는 다양한 서브 모듈의 개요를 도시한다. 자동화된 앱체인 개선(A2R; Automated Appchain Refinement)은 일상의 효 율성(efficiency)을 개선하고 사용성(usability) 및 신뢰성(reliability)을 향상시키기 위해 앱체인 (Appchains) 및 레거시 프로그램(Legacy Programs)을 검사한다. A2M(Automated Appchain Maintenance)는 더 이상 사용되지 않는 기능(Depreciated Functions)을 사용 가능한 기능으로 업 그레이드, 더 이상 사용되지 모듈 및 종속성(Depreciated Modules and Dependencies)을 사용 가능한 기 능으로 업그레이드, (콘텐츠 누락 등) 참조의 만료된 포인트를 삭제, 경제적 안정성 보정(Economical Stability Calibration)을 개선하기 위해 만료된 캐시(Expired Caches)를 삭제함으로써 선택된 앱 체인 또는 레거시 프로그램을 유지한다. 앱체인 보안 하드닝(ASH; Appchain Security Hardening)는 앱체인 또는 레거시 프로그램에서 침입 및 악용 지점을 자동으로 검사한다. 앱체인 규제 준수(ARC; Appchain Regulatory Compliance)은 선택된 앱체인 또는 레거시 프로그램이 다양하고 구체적인 규 제 (예를 들면, REST API 준수)와 일치하도록 보장한다. 진단 로그 유닛 분석(DLUA; Diagnostic Log Unit Analysis)은 오작동 진단 로그 유닛(DLU; Diagnostic Log Unit)를 수신하고 이러한 인식된 오작동 (malfunctions)을 해결하기 위한 적절한 규정을 제정한다. 선천적 오류 수정(IEC; (Innate Error Correction)은 중단된 루틴으로 이어질 수 있는 기본적인 절차 결함을 해결하기 위해 시도한다. IEC은 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment)과 관련하여 다 음 그림에서 사용 케이스로 사용됨을 나타내도록 강조 표시되어 있다. 새로운 앱체인 개발(NAD; New Appchain De-velopment)는 잠재적인(potential) 어플리케이션 기능 누락을 갖는 (UBEC 플랫폼과 같이) 지정 된 애플리케이션 에코 시스템 내에서 애플리케이션의 용도를 찾으며, 이는 이러한 에코시스템에 감지할 수 있게 유익하다. 향상된 프레임워크 개발(EFD; Enhanced Framework Development)는 UBEC 플랫폼/BCHAIN 네트워크 및 레거시 시스템 모두에 대한 (프로그래밍 언어와 같이) 기존 소프트웨어 프레임워크를 검사하 고 잠재적으로(potentially) 개선한다. 향상된 하드웨어 개발(EHD; Enhanced Hardware Development)은 동적 액체 전도성 보드(DLCB; Enhanced Hardware Development)을 포함하는 물리적 시스템을 수정하며, 따라서 핵심 하드웨어 구조를 최적화하고 업그레이드할 수 있다. 앱체인 타겟팅 메커니즘(ATM; AppchainTargeting Mechanism)은 처리 과정에서 어떤 앱체인을 선택해야하는지 다른 모듈에 알리는 지능적인 선택 알고리즘을 처리한다. 앱체인 타겟팅 메커니즘(ATM; Appchain Targeting Mechanism)은 자동화된 앱 체인 개선(A2R; Automated Appchain Refinement), 자동화 앱체인 유지보수(A2M; Automated Appchain Maintenance), 앱체인 보안 하드닝(ASH; Appchain Security Hardening), 앱체인 규제 준수(ARC; Appchain Regulatory Compliance), 진단 로그 유닛 분석(DLUA; Diagnostic Log Unit Analysis) 및 선천적 오류 수정(IEC; (Innate Error Correction) 모듈에 알린다. 다른 모듈에는 ATM과 논리 가 다른 고유의 선택 메커니즘을 가지고 있다. 도 1191 내지 도 1224는 중지된 루틴(halted routine)으로 이어질 수 있는 기본 절차 결함을 수정하기 위해 시 도하는 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)의 서브 모듈인 선천적 오류 수정(IEC; (Innate Error Correction)의 작동 및 기능을 도시한다. 도 1191은 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)의 서브 모듈인 선천적 오류 수정(IEC; (Innate Error Correction)의 작동 및 기능을 도시한다. 앱체인 타겟팅 메커니즘(ATM; Appchain Targeting Mechanism)은 호출된 실행 스트림 모음(ESC; Execution Stream Collection) 인스턴스에 모듈식 입력으로 제출되는 특정 타겟 앱체인(Target Appchain)을 선택한다. ESC 인스턴 스에서 모듈식 출력으로 생성된 실행 스트림은 IEC의 8170단계에 모듈식 입력으로 제출된다. 8170단계는 코드 구조 청사진(Code Structure Blueprint)를 생성하기 위해 앱체인의 실행 스트림을 분리한다. 8174단계에서, 코드 구조 블루프린트 내에 존재하는 선택된 코드 유닛(Selected Code Unit)은 프 로그램밍 루프(programming Loop)를 통해 순환된다. 따라서 8178단계에서, LIZARD가 선택된 코드 유닛 (Selected Code Unit)으로부터 목적 계층 맵(Purpose Hierarchy Map)을 생성하기 위해 호출된다. 8176단 계에서, LIZARD은 전체 코드 구조 블루프린트의 목적 계층 맵를 생성하기 위해 호출된다. 따 라서 목적 계층 맵 8180 및 8182는 모듈식 입력으로 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing) 모듈에 제출된다. P2SP의 처리의 완료에 따라, 대칭 처리 결과(Symmetry Processing Result)는 모듈식 출력으로 생성된다. 따라서 8186단계는 선택한 각 코드 유닛의 목적 계층 맵이 전체 코드 구조 청사진의 더 큰 목적 (목적 계층 맵)과 일치(aligns)하는지 평가하기 위해 대칭 처리 맵을 해석함으로써 내부 일관성을 수행하도록 실행된다. 도 1192는 선택된 코드 유닛(Selected Code Unit)를 목적 계층 맵(Purpose Hierarchy Map)으로 변 환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 선택된 코드 유닛(Selected Code Unit) 는 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구 문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈 (PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행 가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36) 의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 선택된 코드 유닛(Selected Code Unit)는 코드 변환 (C321)에 의해 이행된 실행 스트림(Fulfilled Execution Stream) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코 드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function) 도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논 리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위 해 SM(C35)를 사용한다. 이러한 목적 정의(purpose definition)는 SM(C35)에 의해 해석되는 관련 코트 섹션의 의도된 기능을 적절하게 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지 할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프 로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리 (Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(LoadBalancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1193는 선택된 코드 유닛(Selected Code Unit)를 목적 계층 맵(Purpose Hierarchy Map)으로 변 환하기 위한 LIZARD의 작동을 설명하기 위해 도 1192의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석 (Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 목적 모듈(PM; Purpose Module)(C36), 외부 코어(OC; Outer Core)(C329), 따라서 LIZARD에 모듈식 출력으로 제출되는 복합 목적 포맷(C325)에 존재한다. 출력은 클레임된 신경 패턴(Claimed Neural Pattern)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1194는 코드 구조 청사진(Code Structure Blueprint)을 목적 계층 맵(Purpose Hierarchy Map) 으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 코드 구조 청사진(Code Structure Blueprint)는 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성 에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 코드 구조 청사진(Code Structure Blueprint)는 코드 변환(C321)에 의해 다중 실행 스트림(Multiple Execution Streams) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환 (translating)하는 역함수(inverse function)도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소 (Logical Reduction)(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완 료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관 련 코드 섹션의 의도된 기능성을 적절하게 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으 로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브 러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스 템을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공 하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1195는 코드 구조 청사진(Code Structure Blueprint)을 목적 계층 맵(Purpose Hierarchy Map) 으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1194의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해 석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 목적 모듈(PM; Purpose Module)(C36), 외부 코어(OC; Outer Core)(C329), 따라서 LIZARD에모듈식 출력으로 제출되는 복합 목적 포맷(C325)에 존재한다. 출력은 코드 구조 청사진(Code Structure Blueprint)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1196은 선천적 오류 수정(IEC; (Innate Error Correction)에서 8170단계의 작동 세부 사항을 확장한 다. 8170단계는 타겟 앱체인(Target Appchain)의 실행 스트림(Execution Stream)을 분리한다. 따라 서 일단 실행 스트림 모음(ESC; Execution Stream Collection)이 실행 스트림을 IEC의 8170단계에 모듈식 입력으로 제출하면, 스트림은 8190단계에 모듈식 입력으로 제출된다. 8190단계는 실행 스트림 렌더 링(Execution Stream Rendering)을 호출하며 보충 앱체인(supplement Appchains)의 모든 관련 종속 성(dependences)을 해석 및 구축하며, 따라서 이행된 실행 스트림(led Execution Stream)을 생성한다. 스트림는 이행된 실행 스트림 8192/556의 각 이행된 실행 세그먼트을 통해 루프(Loop)하는 8194단계 에 모듈식 입력으로 제출된다. 도 1197은 선천적 오류 수정(IEC; (Innate Error Correction)의 8170단계의 논리 흐름을 계속한다. 이행 된 실행 스트림는 1194단계에 모듈식 입력으로 제출되며, 이는 도 1196에서 루프를 시작한다. 8196단계에 서 선택된 이행된 실행 세그먼트(Fulfilled Execution Segment)은 (메타 데이터와 함께) 이행된 실행 스 트림(Fulfilled Execution Stream) 내에서 상관적인 문맥(relational context)을 유지하면서, 코드 유닛 버퍼 풀(CUBP; Code Unit Buffer Pool)에 독립 및 저장된다. 프롬프트는 처리되지 않은 이행된 실 행 세그먼트는 8194단계에서 시작하는 루프에 남아 있는지 여부를 해석한다. 프롬프트에 대한 응답 이 예인 경우, 8206단계가 루프를 8194단계에서 다음 사용 가능한 이행된 실행 세그먼트로 진행되어 활성화된다. 프롬프트에 대한 응답이 아니요(No)인 경우, 8200단계가 CUBP의 전체 컨텐츠를 목적 계층 맵으로 커버(cover)하기 위해 LIZARD을 호출하도록 활성화한다. 도 1198는 코드 유닛 버퍼 풀(CUBP; Code Unit Buffer Pool)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 코드 유닛 버퍼 풀(CUBP; Code Unit Buffer Pool)는 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C32 5)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된 다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기 본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성 에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 코드 유닛 버퍼 풀(CUBP; Code Unit Buffer Pool)는 코드 변환(C321)에 의해 실행 세그먼트(Execution Segments) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계 산 언어로 변환한다. 또한, 코드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하 는 역함수(inverse function)도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함 수 맵을 생성하기 위해 코드 논리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해 당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목 적을 도출하기 위해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도 된 기능성을 적절하게 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목 적 포맷(C325) 내에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333) 은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함 한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1199는 코드 유닛 버퍼 풀(CUBP; Code Unit Buffer Pool)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1197의 논리 흐름을 계속한다. 구문 모 듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력은 목적 모듈(PM; Purpose Module)(C36), 외부 코어(OC; Outer Core)(C329), 따라서 LIZARD에 모듈식 출력으로 제출되는 복합 목적 포맷(C325)에 존재한다. 출력은 코드 유닛 버퍼 풀(CUBP; Code Unit Buffer Pool)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어 (IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1200은 선천적 오류 수정(IEC; (Innate Error Correction)의 논리 흐름을 계속한다. 상기 코드 유닛 버퍼 풀(CUBP; Code Unit Buffer Pool)은 8212단계에서 (각 잠재적 코드 유닛(potential Code Unit)의) 의 루프로 처리된다. 전체 코드 유닛 버퍼 풀(CUBP; Code Unit Buffer Pool)의 목적 계층 맵(Purpose Hierarchy Map) 및 선택된 코드 유닛(Selected Code Unit)의 목적 계층 맵(Purpose Hierarchy Map)는 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing)으로 제출되며, 다라서 대칭 처리 결과(Symmetry Processing Result)를 생성한다. 8218단계는 선택된 코드 유닛의 목적 계층 맵가 CUBP에 포함된 전체 코드 구조의 더 큰 목적 (목적 계층 맵)과 일치하는지 평가하기 위해 내부 일관성 검사를 수행한다. 따라서 8220단계에서, (CUBP 8198의) 전체 코드 구조와 일치하는 목적을 가지지 않은 잘못 정렬된 코드 유닛에 표시(flagged)된다. 따라서 8220단계는 모듈식 출력을 잘못 정렬된 코드 유닛 목적 보유(MUPR; Misaligned Code Unit Purpose Retention)에 제출한다. 8224단계에서, 각 잘못 정렬된 코드 유닛 목적은 코드 구조 청사진(Code Structure Blueprint)의 목적 계층 맵에 일치하는 각 유닛을 위해 적합한 목적을 도출하도록 새로운 루프(Loop)에서 반복된다. 8224단 계에서 적합한 목적을 도출하는 프로세스는 적합한 목적 대체(SPR; Suitable Purpose Replacement)에 의 해 처리된다. 도 1201은 선천적 오류 수정(IEC; (Innate Error Correction)의 8218단계 및 8220단계에 관한 작동 세부 사항에 대해 자세히 설명한다. 해당 목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing) 인스턴스의 모듈식 출력은 대칭 처리 결과(Symmetry Processing Result)이다. 결과는 대칭 처리 결과 검증(SPRV; Symmetry Processing Result Validation) 모듈의 8288단계에 모듈식 입력으 로 제출된다. 8228단계는 대칭 처리 결과에 저장된 각 얼라이먼트 통합 검출(AID; alignment Integration Detection) 인스턴스 (목적 대 목적 대칭 처리(P2SP; Purpose to Purpose Symmetry Processing) 내부 로직에서 생성됨) 결과를 분리한다. 그 후, 8230단계는 각 AID(Alignment Integration Detection) 인스턴스 결과에 대해 루프를 호출한다. 루프 프롬프트(Loop Prompt) 해석 내에서, 선 택된 AID 결과는 대칭 처리 결과(Symmetry Processing Result)에 따라 잘못 정렬된 것으로 고려되 는지 해석한다. 프롬프트에 대한 응답이 잘못 정렬되지 않은 경우, 8234단계가 루프를 다음 AID 결 과로 이동하여 활성화된다. 프롬프트에 대한 응답이 예, 잘못 정렬됨(Yes, Misaligned)인 경우, 8238단계는 선택한 AID 결과를 SPRV에 대한 모듈식 출력으로 코드 유닛으로 출력하여 활성화된다. 이러한 출력은 잘못 정렬된 코드 보유(MCUPR; Misaligned Code Unit Purpose Retention)에 저장되므로써 잘못 정렬된 코드 유닛(misaligned Code Unit)을 플러그(flags)하여 8222단계로 제출된다. 따라서 SPRV 모듈의 실행은 대칭 처리 결과을 검증하여 잘못 정렬된 코드 유닛에 플래그한다. 도 1202는 8224단계에서 선천적 오류 수정(IEC; (Innate Error Correction)의 논리 흐름을 계속한다. 8224단계는 각각의 잘못 정렬된 코드 단위 목적을 반복하며 코드 구조 청사진(Code Structure Blueprint)의 목적 계층 맵(Purpose Hierarchy Map 8182)과 일치하는 적합한 목적 대체(SPR; Suitable Purpose Replacement)의 호출(invocation)을 통해 적합한 목적을 도출한다. 8240단계에서, LIZARD은 해당 SPR 인스턴스에 의해 생성된 목적 대체(Purpose Replacements)를 실행 세그먼트 (Execution Segments)로 변환하기 위해 호출된다. 이는 코드 구조 청사진에서 각 구문 대체 유닛 (Syntax Replacement Unit)을 관련 플레이스(place)와 연관시키는 8242단계의 활성화로 이어진다. 그 후 8244 단계에서, 배포 패치(Deployment Patch)이 배포 패치 어셈블리(DPA; Deployment Patch Assembly) 모듈의 호출을 통해 생성된다. 이러한 패치에는 구문 대체 유닛(Syntax Replacement Units) 및 교체할 오 리지널 앱체인(original Appchain)의 일부에 대한 지침이 포함되어 있다.도 1203은 목적 대체(Purpose Replacements)를 실행 세그먼트(Execution Segments)로 변환하기 위해 LIZARD을 호출하는 8240단계에서 선천적 오류 수정(IEC; (Innate Error Correction)의 논리 흐름을 계속하며, 따라서 구문 대체 유닛 보유(SRUR; Syntax Replacement Unit Retention)에 결과를 생성하고 제출한다. 8242단계는 각 구문 대체 유닛(Syntax Replacement Unit)을 해당 플레이스(place)와 연관시킨다. 8242단계는 유닛 청사진 룩업(UBL; Unit Blueprint Lookup) 모듈을 호출하는 작업을 완료한다. UBL 모듈은 코드 구조 스트림라인 프로세싱(CSSP; Code Structure Streamline Processing) 모듈로 출력을 생성하며, 이는 업그레이드된 앱체인(Upgraded Appchain) 출력으로 입력 데이터를 배열한다. 따라 서 CSSP은 구문 교체 유닛(Syntax Replacement Units)과 이들이 교체할 앱체인의 부분에 대한 지침 을 포함하는 배포 패치(Deployment Patch)를 만들어 8244단계를 호출한다. 도 1204는 선천적 오류 수정(IEC; (Innate Error Correction) 모듈의 내부 로직의 부분으로 8224단계 호 출과 관련하여 적합한 목적 대체(SPR; Suitable Purpose Replacement) 모듈의 작동 및 기능을 도시한다. 잘못 정렬된 코드 유닛 목적 보유(MCUPR; Misaligned Code Unit Purpose Retention) 모듈은 SPR의 8254단계에 모듈식 입력으로 제출된다. 8254단계는 MCUPR의 각 잘못 정렬된 코드 단위 목적을 통해 루프 를 시작한다. 8256 단계에서, LOM가 코드 구조 청사진(Code Structure Blueprint)과 일치하고 호환 되는 선택된 잘못 정렬된 코드 유닛(Selected Misaligned Code Unit)에 대한 목적 대체(Purpose Replacement)를 생성하기 위해 호출된다. 따라서 코드 구조 청사진은 목적 대체(Purpose Replacements)을 포함하기 위해 최종적으로 수정되며, 따라서 정확한 청사진을 형성한다. 8254단계 에 의해 호출된 루프(Loop) 내의 개별 목적 대체(individual Purpose Replacement)는 LIZARD에 의 해 처리되기 위해 8240단계로 제출된다. 8240단계에서, LIZARD은 목적 대체을 실행 세그먼트(Execution Segments)로 변환하기 위해 호출된다. 도 1205는 적합한 목적 대체(SPR; Suitable Purpose Replacement)의 8256단계와 관련하여 LOM 및 CTMP의 내부 작동 절차를 도시한다. 코드 구조 청사진(Code Structure Blueprint), 잘못 정렬된 코 드 유닛(Misaligned Code Unit), 및 준수 디지인 원친(Compliance Design Principles)은 대체 호 출 프롬프트(RIP; Replacement Invocation Prompt)에 초기 입력으로 제공된다. RIP은 입력 기준 코드 구조 청사진, 잘못 정렬된 코드 유닛 및 준수 디자인 원칙을 고려하여 목적 대체 (Purpose Replacement)의 생성을 호출하기 위해 LOM와 직접 상호 작용하는 프롬프트을 생산 한다. RIP에 의해 생성된 프롬프트는 LOM의 초기 쿼리 추론(IQR; Initial Query Reasoning)(C802A) 모듈에 제출된다. LOM이 UBEC 사용자에 의해 UBEC 플랫폼 내에서 직접 호출 될 때, IQR(C802A)는 UBEC 사용자에 의해 제공된 초기 질문/주장(assertion)을 수신한다. 그러나, 상기 LOM의 인스턴스는 대신 RIP에 의해 자동으로 호출된다. 제공된 프롬프트은 프롬프트에 게 완전히 주소/응답하기 위한 LOM에 정확한 '가상 이해(virtual understanding)'를 완료하기 위해 비판적 프롬프트로부터 누락된 세부 사항(Missing Details)을 판독(decipher)하기 위해 중앙 지식 보유(CKR; Central Knowledge Retention)의 호출(invocation)를 통해 분석된다. IQR(C802A)에 의해 생성된 결과 누락된 세부 사항(resultant Missing Details)은 모듈식 입력으로 조사 구분(SC; Survey Clarification)(C803A)에 제 출된다. 프롬프트은 객관적이고 모든 필요한 문맥을 분석할 수 있도록 SC(C803A)는 보충 정보를 검색하여 프롬프트의 출처(origin)와 연결한다. LOM이 UBEC 사용자에 의해 UBEC 플랫폼 내에서 직 접 호출될 때, SC(C803A)는 질문/응답의 출처로서 그 사용자와 연동한다. 그러나, 상기 LOM의 인스턴 스는 대신 DIP에 의해 자동으로 호출되며, 따라서 SC(C803A)는 프롬프트에 관한 보충 정보를 검색 하기 위해 RIP과 연동한다. 프롬프트의 완전한 형태와 개선된 버전은 SC(C803A)에서 생산되며 주장 생성(AC; Assertion Construction,)(C808A)에 모듈식 입력으로 제출된다. AC(C808A)는 CKR을 직접 참조하 거나 계층적 매핑(HM, Hierarchical Mapping)(C807A)를 통해 프롬프트에 대한 일관된 응답을 구성하기 위해 시도한다. 합리적 어필(RA; Rational Appeal)(C811A)는 CTMP와의 논리 흐름 인터페이스(logic flow interface)를 수용(houses)하는 컨테이너 모듈(container module)이다. 합리적 어필(RA)(C811A)는 주장을 비판 (criticize)하기 위해 CTMP를 사용한다. 이러한 비판(criticisms)은 (AC(C808A)의 출력을 비판함으로써) 셀프 비판(self-criticisms)의 형태 또는 (UBEC 사용자 또는 RIP) IQR(C802A)에 의해 처리된 질문/ 주장의 오리진(origin)에 대한 외부 비판(external criticisms)의 형태일 수 있다. AC(C808A)에서 생성된 주장 이 RA(C811A)에 의해 처리된 셀프 비판 테스트(self-criticism test)의 중요한 측정(significant measure)을 실패한 경우, AC(C808A)의 새로운 인스턴스는 유효한 비판(valid criticisms)을 설명하기 위해 호출된다. 높은 신뢰도 주장(high confidence assertion)은 RA(C811A)에 의해 처리된 셀프 비판 테스트를 지속적으로 통과하는 AC(C808A)에 의해 생성되는 경우, 상기 주장은 RIP에서 제공되는 초기 프롬프트의 문맥에서 이상적인 투자 결정 메이크업(Ideal Investment Decision Makeup)으로 참조되는 LOM의 모듈식 출력으로 생성된다. 도 1206은 종합 상태 평가(CSE; Comprehensive State Evaluation)의 12402 단계와 관련하여 LOM의 합리적 어필(RA; Rational Appeal)(C811A)의 내부 작동 절차에 대한 세부 사항을 도시한다. 주장 생성(AC; Assertion Construction)(C808A)는 AC(C808A)에 의해 생성되는 주장에 관해서 합리적 어필(RA; Rational Appeal)(C811A)에 대한 응답 프레젠테이션(Response Presentation)(C843)을 제공한다. 논리 흐름의 상기 단계 에서, 생성된 주장(produced assertion)은 사전 비판적 결정(Pre-Criticized Decision)(C847)으로 분류된다. 이는 CTMP에 의한 비판(criticism)을 통해 아직 처리되지 않았음을 의미한다. 따라서 생성된 주장은 '주관 적 의견(Subjective Opinion)(C848)’ 입력으로 CTMP 인스턴스에 직접 제출되며, 또한 CTMP 인스턴 스에 ‘객관적 팩트(Objective Fact)(C850)’ 입력을 제공하는 문맥 구성(CC; Context Construction)(C817A)에 제출된다. CC(C817A)는 AC(C808A)의 메타데이터와 비판적 사고(critical thinking)를 위해 미가공 팩트(raw fact)를 CTMP에 제출하는 대체 호출 프롬프트(RIP; Replacement Invocation Prompt)을 통해 제공되 는 잠재적(potential) 증거를 참조한다. 이러한 입력 메타데이터는 LOM 로그 집계(LOM Log Aggregate) 파일로 표시된다. LOM 로그 집계는 LOM의 기본적인 작동 기능으로부터 생성된 관련 로그 파일의 모 음이 포함되어 있다. CTMP 인스턴스가 작동을 마치면, 사후 비판적 결정(Post-Criticized Decision)(C851)이 모듈식 출력으로 생성된다. 초기 사전 비판적 결정(Pre-Criticized Decision)(C847) 및 사 후 비판적 결정(Post-Criticized Decision)(C851)은 두 입력 C847과 C851 사이의 잠재적(potential) 중복의 범 위를 결정하는 의사 결정 비교(DC; Decision Comparison)(C818A) 모듈에 제출된다. DC(818A)에 의해 제공되는 통합 출력(unified output)은 주장을 생성하는 AC(C808A)을 대신하여 (부정확한) CTMP의 양보 (Concession)(C852) 또는 주장을 생성하는 AC(C808A)를 대신하여 인지된 개선(perceived Improvement)(C853)을 나타낼 수 있다. 인수 응답(Argument Responses)인 C852 및 C853은 모두 낮은 신뢰도 결과(Low Confidence Results)(C845) 또는 높은 신뢰도 결과(High Confidence Results)(C846)로 분류할 수 있다. 낮은 신뢰도 결과 (C845)는 AC(C808A)에 의해 생성된 오리지널 주장(original assertion)이 결함이 있고 재구성해야 됨을 나타나 며, 따라서 논리 흐름은 AC(C808A)의 신규 인스턴스로 계속 이어진다. 높은 신뢰도 결과(C846)은 AC(C808A)에 의해 생성된 오리지널 주장(original assertion)이 장점이 있음을 나타내며, 따라서 도출된 결론(drawn conclusions)(해당 증거, 전제 등과 결합됨)이 지식 검증(KV; Knowledge Validation)(C805A)에 제출된다. 따라 서 논리 흐름은 중앙 지식 보유(CKR; Central Knowledge Retention) 및 LOM가 최근에 처리된 주장으 로부터 이점을 얻을 수 있도록 KV(C805A)의 새로운 인스턴스로 계속 진행된다. 도 1207은 LOM 로그 집계(LOM Log Aggregate) 파일의 생성을 보여주기 위해 종합 상태 평가(CSE; Comprehensive State Evaluation)로부터 12402단계의 논리 흐름을 계속한다. 초기 쿼리 추론(IQR; Initial Query Reasoning)(C802A), 조사 구분(SC; Survey Clarification)(C803A), 주장 생성(AC; Assertion Construction)(C808A), 계층적 매핑(HM; Hierarchical Mapping)(C807A) 및 지식 검증(KV; Knowledge Validation)(C805A)에서 생성된 모듈식 출력은 LOM 모듈식 로그 모음(LMLC; LOM Modular Log Collection) 모듈에 제출된다. 따라서 LMLC은 입력 로그 데이터를 LOM 로그 집계로 참조된 읽을 수 있는 단일 파일로 결합한다. 파일은 해당 LOM 인스턴스의 전반적인 작동 상태를 포함하므로, LOM 인스턴스가 다양한 결론에 도달한 방법에 대한 정보를 제공한다. LOM 로그 집계는 합리적 어필(RA; Rational Appeal)(C811A)의 문맥 구성(CC; Context Construction)(C817A)에 제출된다. 도 1208은 합리적 어필(RA; Rational Appeal)(C811A)에 정의된 입력 및 출력 채널과 관련하여 CTMP의 내 부 동작을 설명하기 위해 도 1206에 관한 작동 세부 사항을 확장한다. 사전 비판적 결정(Pre-Criticized Decision)(C847)은 주장 생성(AC; Assertion Construction)(C808A)의 모듈식 출력으로 C843에 표시된다. CTMP의 두 가지 주요 입력 중 하나를 충족하므로 결정(C847)은 주관적 의견(Subjective Opinion)(C848)으 로 표시된다. 주관적 의견(C848)은 CTMP의 기본적인 모듈식 입력 및 선택된 패턴 매칭 알고리즘(SPMA; Selected Pattern Matching Algorithm)의 내부 표현으로 작동하는 입력 시스템 메타데이터(Input System Metadata)(C484)에 제출된다. 상기 인스턴스 구성의 경우, SPMA(Selected Pattern Matching Algorithm)는 LOM이다. 입력 시스템 메타데이터(C484)는 처리를 위해 추론 처리(Reason Processing)(C456) 및 미가공 인식 생산(RP2; Raw Perception Production)(C465)으로 제출된다. 추론 처리(C456)은 속성 특성(property attributes)을 비교하여 만들어진 주장을 논리적으로 이해할 것이다. RP2(C465)는 LOM의 알고리즘 인식을 나타내는 인식 복잡 포맷(PCF; Perception Complex Format)의 인식을 생성하기 위한 LOM으로부터 입력 시 스템 메타데이터(C484)를 구문 분석한다. 이러한 생성된 인식은 LOM의 알고리즘 인식을 에뮬레이트 (emulates)하는 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)에 제출된다. 추론 처리(C456)은 인스턴스에서 LOM인 SPMA 알고리즘을 반영하는 규칙 집합(rulesets)을 최종적으로 생성하는 규칙 처리를 호출한다. 따라서 '사고(thinking)'의 두 가지 모드 인 '아날로그' 인식과 '디지털' 규칙 세트 처리로 실행된다. 상기 두 개의 브랜치 C461과 C475는 직관(intuition)과 논리를 가진 유사성(similitudes)을 나타낸다. 두 사고 브랜치인 C461과 C475에 의해 생성된 결과는 결과 사이의 충돌(conflict) 또는 확증 (corroboration)의 기본적인 요소를 평가하는 비판적 결정 출력(CDO; Critical Decision Output)(C462)으로 전 송된다. 내부 확증의 높은 크기 및 내부 충돌의 낮은 크기을 발견하면, CTMP는 높은 신뢰도 결과(C846)로 언급되는 초기 입력 주관적 의견(input Subjective Opinion)(C848)과 관련하여 이진법 승인 또는 차단 결정을 제공한다. 내부 확증(internal corroboration)의 낮은 크기과 내부 충돌(internal conflict)의 높은 크기인 경 우, CTMP는 낮은 신뢰도 결과(C845)로 표시되는 '신뢰없는 투표('vote of no confidence)'를 제출한다. 따라서 CTMP의 결과 출력은 사후 비판적 결정(C851)으로 간주된다. 도 1209는 CTMP 내에서 미가공 인식 생산(RP2; Raw Perception Production)(C465)의 호출에 관한 세부 사 항을 도시한다. LOM은 주장 생성(AC; Assertion Construction)(C808A)을 호출하여 목적 대체(Purpose Replacement)를 생성한다. 그 다음, 상기 목적 대체(Purpose Replacement)는 해당 AC(C808A) 인스 턴스로부터 발생하는 입력 시스템 메타데이터(C484) 내에서 디버깅 추적(Debugging Trace)(C485) 및 알고리즘 추적(Algorithm Trace)(C486)의 인스턴스를 생성하기 위한 데이터를 분석(unpacks)하는 RP2(C465)의 5506단계 에 제출한다. 디버깅 추적(Debugging Trace)(C485)는 해당 입력, 출력 변수 유형 및 컨텐츠와 마찬가지로 사용 되는 변수, 함수, 방법 및 분류를 제공하는 코딩 레벨 추적(coding level trace)이다. 전체 기능 호출 체인 (full function call chain) (기능 추적: 다른 기능을 호출하는 기능)이 제공된다. 알고리즘 추적(C486)은 알 고리즘 분석과 결합된 보안 데이터를 제공하는 소프트웨어 레벨 추적(software level trace)이다. 결과 보안 결 정(resultant security decision) (승인/차단)은 결정(C847)에 도달한 방법에 대한 로지스틱 트레일(logistics trail)과 함께 제공된다. 결정(C847)을 생성하기 위해 기여된 각 요인에 대한 적절한 가중치가 포함된다. 그 후, RP2(C465)는 처리를 위해 생성된 인식 결과에 관한 데이터를 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)로 전송한다. 도 1210은 CTMP 내에서 미가공 인식 생산(RP2; Raw Perception Production)(C465)의 작동에 대해 자세히 설명한다. 도 1209와 같이, 초기 단계는 해당 AC(C808A) 인스턴스에서 비롯된 입력 시스템 메타데이터 (C484) 내에서 디버깅 추적(Debugging Trace)(C485) 및 알고리즘 추적(Algorithm Trace)(C486)의 인스턴스를 생성하도록 데이터를 분석(unpack)하기 위해 발생한다. 5508단계에서, 메트릭 처리(Metric Processing)(C489) 는 LOM에 의해 제시된 인공 지능으로부터 인식을 추출하기 위한 LOM의 변수를 리버스 엔지니어링 (reverse engineers)한다. 그 후에, 입력 시스템 메타데이터(Input System Metadata)(C484)는 시스템 메타데이 터 분리(SMS; System Metadata Separation)(C487)을 통해 중요한 보안 인과 관계로 메타데이터(C484)를 분리하 는 5510단계로 처리된다. 또한, 도 1209에 의해 나타낸 바와 같이, RP2(C465)는 생성된 인식 결과에 관한 데이 터를 처리를 위해 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)로 전송한다. 도 1211은 인지 저장(PS; Perception Storage)(C478)과의 관계 및 미가공 인식 생산(RP2; Raw Perception Production)(C465)을 포함하는 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)의 작동에 대해 자세히 설명한다. 메트릭 처리(Metric Processing)(C489) 및 시스템 메타데이터 분리(SMS; System Metadata Separation)(C487)의 작동은 PS(C478)에 저장된 인식 5512/5514/5516의 생산으로 이어진다. 결과 인 식(resulting Perceptions) 5512/5514/5516은 주장 생성(AC; Assertion Construction)(C808A)를 통해 목적 대 체(Purpose Replacement)을 생성하는 LOM의 모듈식 응답을 나타낸다. RP2(C465)는 검색 기준 (search criteria)으로 스토리지 검색(SS; Storage Search)(C480)에 제공되는 비교 가능한 가변 포맷 데이터 포인트를 생성한다. 그 후, SS(C480)은 PS(C478)에 저장된 기존 인식과 일치하기 위해 PS(C478)의 룩업 (lookup)을 수행한다. 실행 SS(C480)의 결과(C716)은 가중치 계산(C718)으로 이어져 생성된다. 이러한 계산 (C718)은 목적 대체(Purpose Replacement)를 생성한 LOM 알고리즘의 실행을 나타내는 비교 가능한 변수 형식(Comparable Variable Format)을 복제하고 일치시키기 위해 PS(C478)로부터 해당 인식의 정확한 분포 를 찾기 위해 시도한다. 도 1212는 도 1211의 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475) 논리를 계속한다. 스 토리지 검색(SS; Storage Search)(C480)에서 결과(C716)를 생성한 후, 가중치 계산(C718)은 능동적인 승인 (Approve)(C731) 또는 차단(Block)(C730) 결정을 내리기 위해 인식 5512/5514/5516의 어플리케이션(C729)으로 이어지도록 완료한다. LOM 및 해당 LOM 로그 집계(LOM Log Aggregate)에 의해 생성된 목적 대체 (Purpose Replacement)은 파생(derived)되기 위해 데이터 개선 로그(Data Enhanced Logs)(C723)를 야기시키는 데이터 구문 분석(Data Parsing)(C724)를 거치게 되며, 이는 입력 목적 대체과 관련하여 긍정적 감정(승인)(C731) 또는 부정적 감정(차단)(C730)의 해석 이분법(Interpretation Dichotomy)을 달성하기 위해 어플리케이션(C729)에 적용된다. 어플리케이션(C729)의 실행이 성공적으로 완료되면, 규칙 실행(RE; Rule Execution)(C461)의 모듈식 출력과 병행하여 비판적 결정 출력(CDO; Critical Decision Output)(C462)에 의해 처리되는 오버라이드 수정 조치(Override Corrective Action)(C476)로 이어진다. 셀프 비판적 지식 밀도(SCKD; Self-Critical Knowledge Density)(C474) 모듈은 보고할 수 있는 LOM 로그 집계의 범위를 넘어서는 알려 지지 않은 잠재적 지식의 범위와 유형을 추정한다. 상기 방법으로, CTMP 인스턴스 처리의 후속 비판적 사 고(critical thinking) 기능은 인스턴스에 의해 직접 알려져 있고 알려지지 않은 모든 관련 지식의 잠재적인 (potential) 범위를 활용할 수 있다. 도 1213은 도 1211의 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)의 실행과 병행하여 작동하는 메모리 웹(Memory Web)(C460) 프로세스를 도시한다. LOM에서 생성된 목적 대체(Purpose Replacement)은 추론 처리(Reason Processing)(C456)에 모듈식 입력으로 제출된다. 추론 처리(C456)은 LOM가 대체 호출 프롬프트(RIP; Replacement Invocation Prompt)에 의해 제공하는 프롬프트 에 응답하여 목적 대체을 생성하기 위한 결정한 방법을 처리한다. 추론 처리(C456)의 처리 결론은 LOM의 실행 동작과 세 번째로 일치하는 규칙을 정의하는 추론 처리의 실행(C457)이다. 만약 LOM의 실 행 동작과 관련하여 규칙 동작에서 불일치가 발견되면, 현재 존재하는 규칙들이 수정되거나 새로운 규칙이 추가 된다. 이러한 규칙은 나중에 해당 LOM 인스턴스에서 발견된 의사 결정 동작(decision making behaviors) 을 비판하기 위해 CTMP 인스턴스 내에서 사용된다. 그런 다음 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)은 알려진 인식을 활용하여 규칙 집합의 '비판적 사고(critical thinking)' 범위를 확장하여 규칙 집합을 향상시켜 올바른 규칙(Correct Rules)(C459)을 생성한다. 올바른 규칙(C459)는 메모리 웹 (C460)의 운영 관할구역 내에서 규칙 구문 포맷 분리(RSFS; Rule Syntax Format Separation)(C499)에 모듈식 입력으로 제출된다. RSFS(C499)는 유형별로 올바른 규칙(Correct Rules)(C459)을 분리하고 구성한다. 따라서 모 든 조치, 특성, 조건 및 개체는 RSFS(C499) 처리 후 별도로 나열된다. 이를 통해 CTMP 인스턴스는 카오틱 필드(Chaotic Field)에서 발견된 부분과 그렇지 않은 부분을 식별할 수 있다. 카오틱 필드 구문 파싱(CFP; Chaotic Field Parsing)(C535)는 LOM 로그 집계(LOM Log Aggregate)를 카오틱 필드로 참조되는 단일 스 캔 가능한 유닛으로 결합하고 형식화한다. 카오틱 필드는 메모리 인식(MR; Memory Recognition)(C501)에 모듈식 입력으로 제출된다. 또한, MR(C501)은 RSFS(C499)의 실행 결과인 오리지널 규칙(Original Rules)(C555)을 받는 다. MR(C501)은 CFP(C535)에서 제공하는 카오틱 필드를 스캔하여 원본 규칙(C555)에 정의된 알 수 있는 개념을 스캔한다. 상기 MR(C501) 인스턴스 실행은 인식된 규칙 세그먼트(C556)을 생성한다. 그 후 규칙 이행 파서(RFP; Rule Fulfillment Parser)(C498)은 MR(C501)에 의해 카오틱 필드 내에서 인식 또는 부족에 따라 태그가 지정된 원본 규칙(Original Rules)(C555)의 개별 부분을 수신한다. 그런 다음 RFP(C498)은 규칙 실행(RE; Rule Execution)(C461)에 의해 처리를 수행하기 위해 카오틱 필드에서 어떤 전체 규칙 집합(모든 부분의 조합)가 충 분히 인식되었는지 논리적으로 추론할 수 있다. RE(C461)의 실행이 성공적으로 완료되면 비판적 결정 출력(CDO; Critical Decision Output)(C462)과 병행하여 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)의 모듈식 출력에 의해 처리되는 오버라이드 수정 조치(Override Corrective Action)(C476)로 이어진다. 도 1214는 인지 저장(PS; Perception Storage)(C478)과 자동화된 인지 발견 메커니즘(APDM; Automated Perception Discovery Mechanism)(C467) 사이의 논리 흐름 상호 작용에 대해 자세히 설명한다. PS(Perception Storage)(C478)에는 인지의 추측된 미지 각도(Deduced Unknown Angles of Perception)(C473), 인지의 모든 각 도(All Angles of Perception)(C472), 인지의 함축 각도(Implied Angles of Perception)(C471), 인지의 적용 각도(Applied Angles of Perception)(C470)과 같이 인식의 네 가지 하위 집합을 포함한다. 인지의 적용 각도 (C470)은 상기 인스턴스에서 LOM인 선택된 패턴 매칭 알고리즘(SPMA)의 알고리즘 동작을 연구하여 직접 불 러온 인식이다. 인지의 함축 각도(C471)은 인지의 적용 각도(C470)에서 암시 도출(ID; implication Derivation)(C477) 및 APDM(Automated Perception Discovery Mechanism)(C467)의 모듈식 실행을 통해 도출된 인식이다. 인지의 모든 각도(C472)는 인지의 적용 각도(C470) 및 인지의 함축 각도(C471)에 포함되지 않은 CTMP 인스턴스에 대한 알려진 인식의 전체 범위를 나타낸다. 인지의 추측된 미지 각도(C473)은 CTMP 인스턴스가 셀프 비판적 지식 밀도(SCKD; Self-Critical Knowledge Density)(C474) 모듈에 따라 아직 발견되지 않은 상태에서 존재할 것으로 예상되는 인식의 범위를 나타낸다. APDM(Automated Perception Discovery Mechanism)(C467)은 초기 두 입력 가중치(C652)를 결합하는 신규 반복(C653)을 생성하도록 창의성 모듈을 통해 인지의 각도(C650)의 구성을 창의적으로 서로 다르게 하지만, 암시 도출(ID; implicationDerivation)(C477)은 결정적으로 인지의 적용 각도(C470)을 도출하기 위해 인지의 적용 각도(C470)의 개별 메트 릭(metrics)를 분석한다. 따라서 APDM(Automated Perception Discovery Mechanism)(C467) 처리와 관련된 모든 인지의 각도(C650)은 LOM의 주장 생성(AC; Assertion Construction)(C808A) 모듈에 의해 생성된 목적 대 체(Purpose Replacement)에 해당하고 이를 나타낸다. 도 1215는 CTMP의 비판적 규칙 범위 확장자(CRSE; Critical Rule Scope Extender)(C458)에 대한 작동 세 부 사항에 대해 자세히 설명한다. 합리적 어필(RA; Rational Appeal)(C811A) 인스턴스는 LOM 로그 집계(LOM Log Aggregate)를 카오틱 필드 파싱(CFP; Chaotic Field Parsing)(C535)으로 처리하기 위해 LOM 내 에서 작동하고 문맥 구성(CC; Context Construction)(C817A)를 호출한다. CFP(Chaotic Field Parsing)는 메모 리 인식(MR)(C501)에서 참조하는 CC(C817A)의 모듈식 출력에서 카오틱 필드(Chaotic Field)를 생성한다. 현재 규칙(C534)는 이 인스턴스에서 LOM인 선택된 패턴 매칭 알고리즘(SPMA; Selected Pattern Matching Algorithm)의 현재 기능 상태를 나타내는 규칙 집합(rulesets)을 표시한다. 현재 규칙(C534)는 규칙 구문 미분 (RSD; Rule Syntax Derivation)(C504) 모듈에 모듈식 입력으로 제출되며, 이는 논리적으로 '흑백' 규칙들은 인 식을 기반으로 메트릭(metric)을 변환하는 곳이다. 따라서 여러 규칙의 복잡한 배열은 다양한 그래디언트 (gradients)의 여러 메트릭(metrics)를 통해 표현되는 단일 균일 인식으로 변환된다. 규칙 구문 미분(RSD; Rule Syntax Derivation)(C504)의 모듈식 출력은 인색 매칭(PM; Perception Matching)(C503)에 모듈식 입력으로 제 공된다. PM(C503)에서, 비교 가능한 가변 포맷(CVF; Comparable Variable Format) 유닛은 규칙 구문 생성(RSD; Rule Syntax Generation)(C505)에서 수신한 인식으로 구성된다. 새로 형성된 CVF(Comparable Variable Forma t)는 유사한 인덱스를 가진 인지 저장(PS; Perception Storage)(C478)에서 관련 인식을 검색하는 것으로 사용된 다. 잠재적(potential) 일치 항목은 규칙 구문 생성(RSG; Rule Syntax Generation)(C505)에 모듈식 입력으로 제출된다. RSG(Rule Syntax Generation)(C505)는 인식 형식으로 저장된 이전에 확인된 인식을 수신하고 인식의 내부 메트릭 구성(internal metric makeup)에 접근한다. 인식은 이전에 확인된 인식(C468)이 포함된 PS(Perception Storage)(C478)에서 수신된다. 이러한 메트릭(metrics)의 그래디언트 기반 측정(gradient-based measures)은 원래 인식의 입력/출력 정보 흐름을 에뮬레이트(emulate)하는 이진법 및 논리 규칙 집합으로 변환 된다. 따라서 RSG()(C505)는 관련성이 있고 대중적으로 고려되며 논리적 규칙으로 변환된 인식(Perceptions)인 인지 규칙(Perceptive Rules)(C537)을 생성한다. 만약 (초기 인식 포맷(original Perception Format)에서) 인 식이 많은 '회색 영역(grey areas’)'을 정의한 많은 복잡한 메트릭 관계가 있는 경우, '흑백' 로컬 규칙은 규 칙 집합 복잡도를 확장함으로써 이러한 '회색' 영역을 포함한다. 따라서 인지 규칙(C537)은 규칙 구문 포맷 (RSF; Rule Syntax Format) 정의의 모음으로 저장된다. 인지 규칙(C537)은 메모리 인식(MR; Memory Recognition)(C501)에 모듈식 입력으로 제출되며, 메모리 인식(MR)(C501)에서 CFP(C535)에 의해 생성된 카오스 필드에 대해 스캔된다. 따라서 MR(Memory Recognition)(C501)은 유효성 있는 올바른 규칙(Correct Rules)(C533)을 완성하는 추가 규칙(Extra Rules)(C536)을 생성한다. 도 1216는 CTMP의 암시 도출(ID; Implication Derivation)(C477)에 대한 작동 세부 사항에 대해 자세히 설명한다. 인지 저장(PS; Perception Storage)(C478)의 인지의 적용 각도(Applied Angles of Perception)(C470)은 인지의 함축 각도(Implied Angles of Perception)(C471)에 속하는 더 많은 인식을 생성하 기 위해 모듈식 입력으로 암시 도출(ID; Implication Derivation)(C477)에 제출된다. 인지의 적용 각도(C470) 은 구체적으로 ID(Implication Derivation)(C477)의 메트릭 조합(C493)으로 전송된다. 메트릭 조합(Metric Combination)(C493)은 메트릭(metrics)의 카테고리에 대해 수신된 인지의 각도(Angles of Perception)(C650)을 범위(Scope)(C739), 유형(Type)(C740), 일관성(Consistency)(C741), 강도(Intensity)(C742)로 구분한다. 시스 템 내에서 메트릭 가용성(Metric availability) 및 참조(reference)가 반드시 상기 네 가지 유형으로 제한되는 것은 아니다. 인지의 각도(C650) 입력은 LOM의 주장 생성(AC; Assertion Construction)(C808A) 모듈에 의 해 생성된 목적 대체(Purpose Replacement)와 관련이 있다. 메트릭 복잡도 세트 A(Metric Complexity Set A)(C736)는 메트릭 확장(ME; Metric Expansion)(C495)에 모듈식 입력으로 제출된다. ME(Metric Expansion)(C495)를 사용하여 여러 인식의 각도(C650) 및 다양한 각도의 메트릭은 개별 데이터베이스 C739, C740, C741, C742 카테고리 별로 저장된다. ME(C495)는 이전에 알려진/접한 메트릭에서 추출된 세부 사항/복잡 도로 수신된 메트릭의 현재 배포를 향상시킨다. 향상 및 복잡도 강화 완료에 따라, 메트릭은 메트릭 복잡도 세 트 B(Metric Complexity Set B)(C737)로 ME(C495) 모듈식의 출력으로 반환되고 그 후에 도 1217에 설명된 바와 같이, 인지의 함축 각도(C471)에 저장되도록 인지의 각도(C650)로 다시 변환된다. 도 1217은 개별 메트릭을 전체 인지의 각도(Angles of Perception)(C650)로 되돌리는 메트릭 변환(Metric Conversion)(C494)에 의해 처리되는 메트릭 복잡도 세트 B(Metric Complexity Set B)(C737)를 설명하는 도 1216으로부터 암시 도출(ID; Implication Derivation)(C477)의 논리 흐름을 계속한다. 암시 도출(ID;Implication Derivation)(C477)에 의해 수행된 향상 및 변환 프로세스에도 불구하고, 생성된 인지의 각도(the resultant Angles of Perception)(C650)는 여전히 LOM의 주장 생성(AC; Assertion Construction)(C808A) 모듈에 의해 생성된 목적 대체(Purpose Replacement)의 합리적으로 정확한 묘사를 제공한다. 따라서 메트 릭 변환(Metric Conversion)(C494) 프로세스는 새로 도출/암시된 인식의 각도(C650)를 인지 저장(PS; Perception Storage)(C478) 내의 인지의 함축 각도(Implied Angles of Perception)(C471)에 제출한다. 도 1218는 CTMP의 비판적 결정 출력(CDO; Critical Decision Output)(C462)에 대한 작동 세부 사항에 대 해 자세히 설명한다. CDO(Critical Decision Output)(C462)는 CTMP의 두 가지 주요 브랜치로부터 모듈식 의 출력을 수신하고, (직관력 브랜(intuition branch)로서) 인지 관찰자 애뮬레이터(POE; Perception Observer Emulator)(C475)와 (논리적 브랜치(logical branch)로서) 규칙 실행(RE; Rule Execution)(C461)가 있 다. 각 브랜치 C475/461은 그것의 각각의 비판적 결정(Critical Decision)(C521) (메인 모듈식의 출력)뿐 아니 라 해당하는 '메타-메타 데이터(Meta-metadata)'(C521)을 제출하며, 이는 초기 비판적 결정(initial critical decision)에 도달한 이유를 정당화하는 맥락 변수를 제공한다. POE(Perception Observer Emulator)(C475)의 인 식(C516)과 RE(Rule Execution)(C461)의 이행된 규칙(Fulfilled Rules)(C517)을 나타내는 두 결정 세트 (Decision Sets)(C521)는 메타데이터 분류 모듈(MCM; Metadata Categorization Module)(C488)에 제출된다. MCM(Metadata Categorization Module)(C488)은 전통적인 구문(traditional syntax) 기반 정보 카테고리화를 사 용하여 디버깅(Debugging) 및 알고리즘 추적(Algorithm Traces)을 개별의 카테고리로 분류한다. 그러면 이러한 카테고리는 보안 위험과 대상과의 상관관계를 가지고 분명한 보안 대응을 조직하고 생성할 수 있다. POE(Perception Observer Emulator)(C475)의 인식(C526)을 나타내는 직관적 의사 결정(Intuitive Decision)(C514)와 RE(Rule Execution)(C461)의 이행된 규칙(C517)을 나타내는 사고 결정(C515)은 MCM(C488)에 의해 방향 결정 비교(DDC; Direction Decision Comparison)(C512)의 내부 프로세싱 로직(Internal Processing Logic)에 제출된다. DDC(Direction Decision Comparison)(C512)의 내부 프로세싱 로직은 직관적 의사 결정(Intuitive Decision)(C514)와 사고 결정(Thinking Decision)(C515) 사이의 확증 또는 충돌을 확인한 다. DDC(C512)는 정적 하드코드된 정책(SHP; Static Hardcoded Policy)의 '차단 변수(cutoff variable)' 를 참조한다. 만약 차단 변수는 직관적 의사 결정(Intuitive Decision)(C514)와 사고 결정(Thinking Decision)(C515) 사이에 유사성에 도달하지 않으면 (예를 들어, 90 % +), 무효화 직접 비교(Cancel Direct Comparison)는 직접 발생하며, 이는 도 1219에 도시된 바와 같이, 확신없는 투표(Vote of No Confidence)에 최종적으로 제출하도록 터미널 출력 제어(TOC; Terminal Output Control)(C513)에 연결된 다. 무효화 직접 비교(Cancel Direct Comparison) 단계는 CTMP가 대체 호출 프롬프트(RIP; Replacement Invocation Prompt)의 프롬프트 입력과 관련하여 내부적으로 일관성 있는 작동할 수 없음을 의미한다. 만약 '차단 변수가 내부 프로세싱 로직(Internal Processing Logic)에 따라 충분히 충 족되면, 최종 비판적 출력(Final Critical Decision) 단계가 터미널 출력 제어(TOC)(C513)에 의해 수신 및 처리되는 단일 모듈식의 출력으로 두 결정 C514/C515를 결합하여 호출한다. 도 1219은 도 1218의 비판적 결정 출력(CDO; Critical Decision Output)(C462)의 논리 흐름을 계속하고 터미널 출력 제어(TOC; Terminal Output Control)(C513)의 작동 세부 사항을 자세히 설명한다. TOC(Terminal Output Control)(C513)은 방향 결정 비교(DDC; Direct Decision Comparison)(C512)가 (무효화 직접 비교(Cancel Direct Comparison) 지시 대신) 최종 비판적 출력(Final Critical Decision)을 제공할 수 있는지 확인하는 프롬프트로 시작한다. 프롬프트에 대한 응답이 Yes인 경우, 최종 비판적 출력 (Final Critical Decision)에서 DDC(C512)에 의해 제공된 결합된 최종 결정은 TOC(C513)의 모듈식 출력 으로 제출되며, 따라서 최종 임계 결정으로 전체 CTMP 인스턴스의 모듈식 출력으로서 제출된다. 프 롬프트에 대한 응답이 No인 경우, 5532단계가 자체적으로 인식 매칭(PM; Perception Matching)의 실행을 호출하고 해당 결과를 가져오게 되어 호출된다. 이행된 규칙(Fulfilled Rules)(C517)은 규칙 실행(RE; Rule Execution)(C461)의 비판적(critical) 결정 + 메타-메타 데이터(C521)에서 추출된다. 규칙(C517)은 규칙 구문 미분(RSD; Rule Syntax Derivation)(C504)에 의해 인식으로 변환된다. 그 다음에, PM는 프롬프트에서 강력한 내부 중복(strong internal overlap)과 사용된 인식의 확증 (corroboration of Perceptions)이 있는지 결정하기 위해 메타-메타 데이터를 참조한다. 만약 프롬프트 에 대한 응답이 예인 경우, 모듈식 출력으로 CTMP 대신하여 확신없는 투표(Vote of No Confidence)를 나타낸다. 만약 프롬프트에 대한 응답이 No인 경우, 5540단계가 활성화되어 직관적 의사 결정(Intuitive Decision)(C514)와 사고 결정(Thinking Decision)(C515) 사이에서 인식된 가장 위 험이 덜한 결정을 선택한다. 따라서 최종 임계 결정(Final Critical Decision)는 비판적 결정 출력(CDO; Critical Decision Output)(C462), TOC(Terminal Output Control)(C513) 및 CTMP에 모듈식 출력으로 제출된다. 5534단계의 논리는 직관적 의사 결정(Intuitive Decision)(C514)와 사고 결정(Thinking Decision)(C515) 사이의 일치성 부족이 알고리즘에 대한 신뢰가 부족하거나, 둘 사이의 반대되는 관점 때문에 발생하는지 여부를 판별하기 위해 발생한다. 따라서 후자가 발생할 경우, 잠재적인(potential) 최종 임계 결정는 여전히 모 듈식 출력으로 식별할 수 있다. 확신없는 투표(Vote of No Confidence)는 항상 합리적 어필(RA; Rational Appeal)(C811A) 내에서 신뢰도가 낮은 신뢰도 결과(Low Confidence Result)(C845) 논리 경로로 이어 진다. 최종 임계 결정는 최종 임계 결정 뒤에 알고리즘 신뢰도에 따라 RA(Rational Appeal)(C811A) 내에서 높은 신뢰도 결과()(C846) 또는 낮은 신뢰도 결과(C845) 논리 경로로 이어질 수 있다. 도 1220는 목적 대체(Purpose Replacement)를 실행 세그먼트(Execution Segments)으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 목적 대체(Purpose Replacement)은 복합 목적 포맷(Complex Purpose Format)(C325)으로 존재하며 LIZARD의 외부 코어(OC; Outer Core)(C329) 내에서 목 적 모듈(PM; Purpose Module)(C36)의 반복 확장(Iterative Expansion)(C327)에 제출된다. 반복 확장(C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 목적 대체에 정의됨) 세부 사항과 복 잡도(complexity)를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 포텐셜(potentia l)은 복합 목적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC; Inner Core)(C333)의 핵심 코드(Core Code)(C335) 요소는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리 및 로드 밸런싱 스크립트(Thread Management and Load Balancing scripts), 통신 및 암호화 프로토콜 (Communication and Encryption protocols) 및 메모리 관리 시스템(Memory Management systems)을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(Syntax Module)(C35) 및 PM(Purpose Module)(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1221은 목적 대체(Purpose Replacement)을 실행 세그먼트(Execution Segments)로 변환하기 위 한 LIZARD의 작동을 설명하기 위해 도 1220의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM; Purpose Module)(C36)의 복합 목적 포맷(Complex Purpose Format)(C325)로 수신되고, 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수(functions)를 도출한다. 이 는 만약 함수가 더 간단한 상위의 함수(parent function)로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수(function dependencies)의 트리(tree)이다. 논리적 미분(Logical Derivation)(C320)은 내부 코어(IC; Inner Core)(C333)의 핵심 코드(Core Code)(C335) 요 소로부터 상속된 규칙 및 구문(Rules and Syntax)(C322) 정의에 따라 작동한다. 논리적 미분(Logical Derivation)(C320)은 출력을 코드 변환(C321)에 제출한다. 코드 변환(C321)은 SM(Syntax Module)(C35)에서 인 식하고 이해하는 임의의(일반적인) 코드(arbitrary (generic) code)를 알려진 선택된 계산 언어로 변환한다. 코 드 변환(C321)은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수(inverse function)도 수행한다. 따 라서 PM(Purpose Module)(C36)은 코드 변환(C321)을 통해 입력 목적 대체(Purpose Replacement)의 결과 실행 세그먼트(Execution Segments)을 생성하기 위해 SM(Syntax Module)(C35)를 호출한다. 코드 변환 (C321)에 의해 최종적으로 생성되는 결과 실행 세그먼트(Execution Segments)는 SM(Syntax Module)(C35), 외부 코어(OC; Outer Core)(C329) 및 LIZARD의 모듈식 출력이다. 그 후, 실행 세그먼트 은 구문 대체 유닛 보유(SRUR; Syntax Replacement Unit Retention)에 저장된다. 도 1222는 선천적 오류 수정(IEC; (Innate Error Correction)의 8242단계와 관련하여 유닛 청사진 룩업 (UBL; Unit Blueprint Lookup) 모듈의 작동 및 기능에 대해 자세히 설명한다. 8286단계는 구문 대체 유 닛 보유(SRUR; Syntax Replacement Unit Retention)에서 모듈식 입력을 수신하고, 따라서 SRUR에 서 모든 구문 대체 유닛(Syntax Replacement Units)을 순환하는 루프를 시작한다. 8284단계는 SRUR(Syntax Replacement Unit Retention)에서 선택된 구문 대체 유닛(Syntax Replacement Unit)을 검색 한다. 연관된 코드 장치 ID(Associated Code Unit ID)는 8290 단계의 구문 대체 유닛(Syntax Replacement Unit)에서 분석(unpacked)된다. UBL(Unit Blueprint Lookup)의 동일한 인스턴스 내의 별도의 병렬 스레드(parallel thread)에 대해, 코드 구조 청사진(Code Structure Blueprint)은 모듈식 입력으로 8280단계에 제출된다. 8280단계는 코드 구조 청사진(Code Structure Blueprint)을 새로운 코드구조 청사진 보유(NCSBR; New Code Structure Blueprint Retention)에 설치한다. 도 1223은 8242단계의 내부 논리 내에서 유닛 청사진 룩업(UBL; Unit Blueprint Lookup) 호출에 관한 도 1222의 논리 흐름을 계속한다. 논리 흐름은 1294단계의 도 1222에서 재개하며, 이는 선택된 구문 대체 유닛 (Syntax Replacement Unit)을 새로운 코드 구조 청사진 보유(NCSBR; New Code Structure Blueprint Retention)으로 설치한다. 8286단계에서 호출된 반복 처리 루프가 완료될 때, 8286단계가 호출된다. 8296 단계는 코드 구조 스크림라인 프로세싱(CSSP; Code Structure Streamline Processing)을 통해 실행 세그 먼트(Execution Segments)의 이행된 상태(Fulfilled status)를 역전시킨다. 따라서 CSSP은 업그레 이드된 앱체인(Upgraded Appchain)를 모듈식 출력으로 생성한다. 도 1224는 도 1223에서 코드 구조 스크림라인 프로세싱(CSSP; Code Structure Streamline Processing)의 호출로 선천적 오류 수정(IEC; (Innate Error Correction)의 논리 흐름을 계속한다. 코드 구조 스크림라 인 프로세싱(CSSP; Code Structure Streamline Processing)은 업그레이드된 앱체인(Upgraded Appchain)를 생성하며, 이는 오리지널 구문 구조(original syntactical structure)를 나타내지만 잘못 정렬된 코드 유닛(Misaligned Code Units)는 적합한 목적 대체(Suitable Purpose Replacements)로 대체된다. 업그레이드된 앱체인는 앱체인 정정 패치(Appchain Correction Patch)을 생성하기 위해 배포 패치 어셈블리(DPA; Deployment Patch Assembly)에 제출된다. 타겟 앱체인(Target Appchain)은 실행 스 트림 모음(ESC; Execution Stream Collection)에 의해 처리되며, 따라서 오리지널 실행 스트림(original Execution Stream)을 DPA(Deployment Patch Assembly) 인스턴스에 제출한다. 이는 그것의 오리지널 형식(original form)으로 타겟 앱체인(Target Appchain)에 액세스(access)할 수 있도록 DPA(Deployment Patch Assembly)을 가능하게 한다. DPA은 오리지널과 업그레이드된 앱체인(Upgraded Appchain) 사이의 차이에 액세스할 수 있기 때문에, 오리지널 앱체인(Original Appchain)을 업그 레이드된 앱체인으로 변환하는 지침(instructions)이 포함된 앱체인 정정 패치(Appchain Correction Patch)을 생성할 수 있다. 8298단계에서, 앱체인 정정 패치은 커스텀체인 에코시스템 빌더(CEB; Cus-tomchain Ecosystem Builder)에 배포되며, 이는 컨텐츠에 업그레이드된 앱체인으로 변환하기 위해 타겟 앱체인을 조작한다. 도 1225 내지 도 1242는 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment) 모듈에 관 한 사용 및 적용의 문맥에서 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)의 작동 및 기능 을 도시한다. AEL(Appchain Emulation Layer)을 통해 BCHAIN 네티워크에 참여하지 않는 레거시 환 경에서 앱체인(Appchains)을 실행할 수 있다. 도 1225는 정적 앱체인 처리(SAP; Static Appchain Processing)을 통해 사전 컴파일된 어플리케이션 스 택(PAS; Precompiled Application Stack) 인스턴스에 설치되는 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment) 모듈을 도시한다. SAP(Static Appchain Processing) 은 NMC(Neuroeconomic Metaphysical Contentment)의 앱체인(Appchain) 컨텐츠를 해석하며, 따라서 정적 앱체인 보유(Static Appchain Retention)을 생성하고 PAS(Precompiled Application Stack)에 모듈식 입력으로 제출한다. 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)은 PAS에 컴파일 및 임베드되며, 따라서 레거시 시스템(Legacy Systems) 내에서 PAS 인스턴스 자율성(autonomy)을 제공한다. AEL의 서브모듈은 타겟 시스템 해석 및 검출(TSID; Target System Interpretation and Detection)이다. 따라서 상기 PAS을 임의의 시스템에서 호출될 경우, AEL은 예비 기본 명령 어 세트(preliminarily basic instruction-set)에서 실행되고 타겟 시스템(Target System)의 작동 시스 템(Operating System), 디바이스 드라이버(Device Drivers), 하드웨어(Hardware)를 감지하 기 위해 모색한다. 따라서 AEL은 타겟 시스템에서 복잡한 코드를 실행하기 위해 적절한 변환 메커 니즘(translation mechanism)을 호출하며, 따라서 완전히 실행되기 위해 정적 앱체인 보유(Static Appchain Retention)를 가능하게 한다. 보유(Retention)에는 NMC에 대한 앱체인 실행 세그먼트 (Execution Segments) 및 데이터(Data) 세그먼트가 포함되어 있으며, 다른 앱체인 NMC 은 LOM 및 LIZARD과 같은 작동에 의존한다. 도 1226은 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)의 작동 및 기능을 도시한다. 정적 앱체인 처리(SAP; Static Appchain Processing)은 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment) 앱체인(Appchain)을 포함하는 정적 앱체인 보유(Static Appchain Retention) 인스턴스를 생성한다. 정적 앱체인 보유(Static Appchain Retention)는 AEL(Appchain Emulation Layer)의 실행 및 데이터 세그먼트 추출(EDSE; Execution and Data SegmentExtraction) 모듈에 대한 모듈식 입력으로 제출된다. EDSE(Execution and Data Segment Extraction)은 9432단계에서 실행 스트림 모음(ESC; Execution Stream Collection)의 호출 및 데 이터 스트림 정렬(DSS; Data Stream Sorting)의 호출을 위한 컨테이너(container) 모듈이다. 타겟 시스 템(Target System)은 정적 타겟 시스템 라이브러리 모음(Target System Library Collection)의 고 려를 통해 타겟 시스템 해석 및 검출(TSID; Target System Interpretation and Detection) 모듈에 의해 해석된다. 모음는 다양한 시스템(System) 유형에 적용할 수 있는 적절한 명령 세트(appropriate Instruction Sets)를 정의한다. 따라서 TSID는 타겟 시스템에게 올바른 계산 명령어를 제출 하기 위해 AEL의 내부 작동을 가능하게 하는 타겟 시스템 명령어 세트(Target System Instruction Set)를 생산한다. 실행 세그먼트 변환(EST; Execution Segment Translation)은 타겟 시스템 명령 어 세트(Target System Instruction Set)를 해석하기 위해 9432단계에서 호출되며, 따라서 앱체인 구문을 적절한 레거시 지침(appropriate legacy instructions)으로 변환한다. 데이터 세그먼트 변환(DST; Data Segment Translation)은 타겟 시스템 명령어 세트(Target System Instruction Set)를 해석하기 위 해9434단계에서 호출되며, 따라서 앱체인 구문을 데이터의 적절한 레거시 세그먼트(appropriate legacy segments of data)로 변환한다. 실행 세그먼트 변환(EST; Execution Segment Translation) 및 데이터 세 그먼트 변환(DST; Data Segment Translation)의 모듈식 출력은 모두 레거시 명령어 통합(LIU; Legacy Instruction Unification)에 제출되며, 이는 정의된 타겟 시스템 명령어 세트(Target System Instruction Set)에 따라 정적 앱체인 보유(Static Appchain Retention)를 렌더(render)하기 위해 실행 스트림 렌더링(ESR; Execution Stream Rendering)의 라이브 인스턴스(live instance)를 호출한다. (타겟 시스템(Target System)의 레거시 파일 시스템(legacy file system)에 파일 쓰기와 같이) AEL의 관할구역 및 타겟 시스템 내의 요소를 조작하기 위한 시도는 외부 명령어 미들웨어(EIM; External Instruction Middleware)에 의해 처리된다. 따라서 LIU(Legacy Instruction Unification)의 모듈식 출력은 타겟 시스템에 의해 이해 및 실행되며 정적 앱체인 보유의 실 행의 실제적인 표현을 암시하는 배포할 수 있는 명령어 스트림(Deployable Instruction Stream)이고, 따 라서 레거시 시스템에서 NMC 앱체인의 실행을 의미한다. 도 1227은 외부 명령어 미들웨어(EIM; External Instruction Middleware)의 작동 및 기능을 도시한다. 레거시 명령어 통합(LIU; Legacy Instruction Unification) 모듈의 실행 스트림 렌더링(ESR; Execution Stream Rendering) 인스턴스 내에 정적 앱체인 보유(Static Appchain Retention)의 작동은 모듈식 출력으로 외부 명령어 제안(External Instruction Proposition) 및 명령어 분리 준비상태(Instruction Isolation Readiness) 인텍스(index)를 생성하기 위해 LIU(Legacy Instruction Unification)을 야 기시킨다. 이러한 출력 9452 및 9454는 외부 명령어 미들웨어(EIM; External Instruction Middleware)에 모듈식 입력으로 제출되며, 따라서 출력는 9456단계에서 수신된다. 9458단계는 외부 명령어 제안 (External Instruction Proposition)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위해 LIZARD을 호출한다. 그 후, 9466 단계는 모듈식 입력 명령어 목적 모음(Instruction Purpose Collection) 및 목적 계층 맵을 위해 목적 재조정 처리(PRP; Purpose Realignment Processing) 모듈을 호출하여 실행된다. 마스터/슬레이브 선호도(Master/Slave Affinity)은 명령 어 목적 모음(Instruction Purpose Collection)을 슬레이브로 정의한다. 따라서 PRP은 명령어 목 적 모음(Instruction Purpose Collection)의 새로운 반복을 모듈식 출력으로 생성한다. 9468단계에서, LIU(Legacy Instruction Unification)는 LIZARD의 니드 맵 매칭(NMM; Need Map Matching)(C114) 서브 모 듈을 통해 명령어 분리 준비상태(Instruction Isolation Readiness)를 생성하기 위해 호출된다. 명령어 분리 준비상태의 적용 가능성(applicability)은 도 1230에 설명된다. 도 1228는 외부 명령어 제안(External Instruction Proposition)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한다. 외부 명령어 제안(External Instruction Proposition)는 외부 코어(OC; Outer Core)(C329)의 관할구역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타겟 계산 구 문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이 러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상기 외부 명령어 제안(External Instruction Proposition)는 코드 변환(C321)에 의해 ESR 지침/명령 구문 (ESR(Execution Stream Rendering) Instruction/Command Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코 드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function) 도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논 리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위 해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절 하게 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해 석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내 에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영 역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암 호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코 드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대 한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내 하는 정적 정책 변수로 작동한다. 도 1229는 외부 명령어 제안(External Instruction Proposition)를 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1228의 논리 흐름을 계속한다. 구문 모 듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력(purpose definition output)은 목적 모듈(PM; Purpose Module)(C36), 외부 코어(OC; Outer Core)(C329), 따라서 LIZARD에 모듈식 출력으로 제출되는 복합 목적 포맷(C325)에 존재한다. 출력은 외부 명령어 제안(External Instruction Proposition)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1230은 9468단계에서 도 1227의 외부 명령어 미들웨어(EIM; External Instruction Middleware)의 논 리 흐름을 계속하며, 이는 명령어 분리 준비상태(Instruction Isolation Readiness) 변수를 생성하기 위 해 레거시 명령어 통합(LIU; Legacy Instruction Unification)을 호출한다. 준비상태(Readiness) 변수는 명령어 목적 모음(Instruction Purpose Collection)이 대체 실행 구문(alternate execution syntaxes)의 간섭없이 실행될 타겟 시스템(Target System) 내에서 충분히 분리되는지 정의한다. 따라서 명령어 분리 준비상태(Instruction Isolation Readiness) 변수는 명령어 목적 모음(Instruction Purpose Collection)이 아직 타겟 시스템(Target System)에 배포할 수 있는 것을 나타내는지 평가하여 프 롬프트가 활성화된다. 프롬프트에 대한 응답이 배포 준비 안됨(Deployment Not Ready)인 경 우, 외부 명령어 제안(External Instruction Proposition)는 레거시 명령어 통합(LIU; Legacy Instruction Unification)을 통해 실행 스트림 렌더링(ESR; Execution Stream Rendering)에 의해 생성될 때까지, 9478단계는 외부 명령어 미들웨어(EIM; External Instruction Middleware)의 실행을 중 단하여 활성화된다. 프롬프트에 대한 응답이 배포 준비됨(Deployment Ready)인 경우, 9476단계는 명령어 목적 모음(Instruction Purpose Collection)를 통해 타겟 시스템 해석 및 검출(TSID; Target System Interpretation and Detection)에 의해 정의된 해당 구문으로 변환하기 위해 LIZARD을 호출 한다. 따라서 9476단계는 EIM에 대한 모듈식 출력이며 기본적으로 타겟 시스템(Target System) 내 에서 실행되는 배포할 수 있는 명령어 스트림(Deployable Instruction Stream)을 생성한다. 도 1231은 LIZARD의 다이나믹 쉘(DS; Dynamic Shell)(C198)의 서브모듈로 작동하는 니드 맵 매칭(NMM; Need Map Matching)(C114)의 작동 및 기능을 도시한다. NMM(Need Map Matching)(C114) 인스턴스는 레거시 명령 어 통합(LIU; Legacy Instruction Unification) 모듈의 9468단계의 작동을 제공하기 위해 생성된다. 타 겟 시스템 해석 및 검출(TSID; Target System Interpretation and Detection)은 니드 액세스 개발 및 스토리지(Need Access and Development and Storage)에 저장하기 위해 제출된다. 따라서 타겟 시스템 해석 및 검출(TSID; Target System Interpretation and Detection)은 서브 카테고리로 분류되고 일련의 계층 적 브랜치 및 레이어(hierarchal branches and layers)로 스토리지에 유지된다. NMM(C114)의 모듈식 호 출에 따라, 초기 구문 분석(Initial Parsing)(C148)은 진행중인 NMM(C114) 인스턴스 내에서 참조하기 위해 일시 적으로 유지하도록 스토리지에서 각 관할구역 브랜치를 다운로드한다. 브랜치 니드 계산(Calculate Branch Needs)(C149)으로, 각 브랜치와 관련된 정의에 따라, 니드(needs)는 해당 부서와 연관되어 있다. 상기 방법으로, 권한 검사(permission checks)는 NMM(C114) 인스턴스 내에서 구성될 수 있다. 예를 들어, 직원의 능 력(capabilities)에 따라 직원 성과(performance)를 매년 검토하는 영역 내에서 요청되었기 때문에, NMM(C11 4)는 모든 직원 CV를 다운로드하도록 인사부서(Human Resources department)에 요청을 승인했다. 따라서 부서 관할구역(department jurisdiction)의 유효한 필요성(needs)임을 입증되었다. 따라서 니드 인덱스(Need Index)(C145)는 관할구역 브랜치(Jurisdiction Branches)와 및 각각의 니드(needs)의 메인 스토리지이다. 이 내부 참조는 NMM(C114) 및 제공되는 모든 모듈의 작동에 대한 리소스 병목 현상(resource bottleneck)이기 때문 에, 시스템의 전반적인 효율성을 높이기 위해 빠른 데이터베이스 쿼리에 미리 최적화되어 있다. 9468단계는 입 력 목적(Input Purpose)(C139)을 NMM(C114)의 검색 알고리즘(Search Algorithm)(C144)에 모듈식 입력으로 제공 한다. 입력 목적(C139)가 니드 액세스 개발 및 스토리지에 초기에 정의된 관할구역 브랜치에 따라 유효한 니드를 정의하는지 판별하므로, 검색 알고리즘(C144)는 컴파일된 니드 인덱스(C145)를 통해 참조하고 검색한다. 따라서 니드 인덱스(C145)를 통해 검색 알고리즘(C144)의 완료된 실행은 NMM(C114)의 모듈식 출력으로 제출되고 니드 결과(C141)로 참조되는 승인/차단(C146) 응답을 생성한다. 따라서 니드 결과(C141)는 명령어 분리 준비상 태(Instruction Isolation Readiness) 변수로 외부 명령어 미들웨어(EIM; External Instruction Middleware)의 내부 논리로 되돌아간다. 도 1232는 명령어 목적 모음(Instruction Purpose Collection)를 있는 배포할 수 있는 명령어 스트림 (Deployable Instruction Stream)으로 변환하기 위한 LIZARD의 동작에 관한 세부 사항을 도시한다. 명령어 목적 모음(Instruction Purpose Collection)은 복합 목적 포맷(Complex Purpose Format)(C325)으 로 존재하며 LIZARD의 외부 코어(OC; Outer Core)(C329) 내에서 목적 모듈(PM; Purpose Module)(C36)의 반복 확장(Iterative Expansion)(C327)에 제출된다. 반복 확장(C327)은 특정 복합 목적 정의로 간단한 목표를 발전시키기 위해 (간접적으로 목적 대체(Purpose Replacement)에 정의됨) 세부 사항과 복잡도 (complexity)를 추가한다. 따라서 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)에 제출되기 전에, 입력의 최대 목적 연관성(Purpose Association)(C326) 포텐셜(potentia l)은 복합 목적 포맷(C325)으로 실현되고 유지된다. 내부 코어(IC; Inner Core)(C333)의 핵심 코드(Core Code)(C335) 요소는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리 및 로드 밸런싱 스크립트(Thread Management and Load Balancing scripts), 통신 및 암호화 프로토콜 (Communication and Encryption protocols) 및 메모리 관리 시스템(Memory Management systems)을 포함한다. 따라서 코어 코드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(Syntax Module)(C35) 및 PM(Purpose Module)(C36)에 대한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내하는 정적 정책 변수로 작동한다. 도 1233은 명령어 목적 모음(Instruction Purpose Collection)을 있는 배포할 수 있는 명령어 스트림 (Deployable Instruction Stream)으로 변환하기 위한 LAZARD의 동작을 설명하도록 도 1232의 논리 흐름을 계속한다. 입력 데이터는 목적 모듈(PM; Purpose Module)(C36)의 복합 목적 포맷(Complex Purpose Format)(C325)로 수신되고, 구문 모듈(SM; Syntax Module)(C35)의 논리적 미분(Logical Derivation)(C320)으로 전송된다. 논리적 미분(Logical Derivation)(C320)은 초기에 간단한 함수(functions)에서 논리적으로 필요한 함수(functions)를 도출한다. 이는 만약 함수가 더 간단한 상위의 함수(parent function)로부터 영향으로 인해 도함수(derivative function)로 형성될 수 있는 경우, 논리적 미분(Logical Derivation)(C320)에 의해 형성되 는 것을 의미한다. 생성된 결과는 정의된 복합 목적 포맷(C325) 데이터에 따라 구축된 종속성 함수(function dependencies)의 트리(tree)이다. 논리적 미분(Logical Derivation)(C320)은 타겟 시스템 해석 및 검출(TSID; Target System Interpretation and Detection)을 통해 내부 코어(IC; Inner Core)(C333)의 핵심 코드(Core Code)(C335) 요소와 타겟 시스템 라이브러리 모음(Target System Library Collection)으로부터 상속된 규칙 및 구문(Rules and Syntax)(C322) 정의에 따라 작동한다. 논리적 미분(Logical Derivation)(C320)은 출력 을 코드 변환(Code Translation)(C321)에 제출한다. 코드 변환(C321)은 SM(Syntax Module)(C35)에서 인식하고 이해하는 임의의(일반적인) 코드(arbitrary (generic) code)를 알려진 선택된 계산 언어로 변환한다. 코드 변환(C321)은 알려진 계산 언어를 임의의 구문 유형으로 변환하는 역함수(inverse function)도 수행한다. 따라서 PM(Purpose Module)(C36)은 코드 변환(C321)을 통해 입력 목적 대체(Purpose Replacement)의 결과 실행 세그먼트(Execution Segments)을 생성하기 위해 SM(Syntax Module)(C35)를 호출한다. 코드 변환(C321)에 의해 최종적으로 생성되는 결과 실행 세그먼트(Execution Segments)는 SM(Syntax Module)(C35), 외부 코 어(OC; Outer Core)(C329) 및 LIZARD의 모듈식 출력이다. 그 후, 실행 세그먼트은 구문 대체 유닛 보유(SRUR; Syntax Replacement Unit Retention)에 저장된다. 도 1234는 정적 앱체인 처리(SAP; Static Appchain Processing)의 작동 및 기능을 도시하며, 이는 라이 브 및 액티브 앱체인(live and active Appchains)을 배포할 수 있는 정적 앱체인 보유(Static Appchain Retention)로 변환한다. SAP(Static Appchain Processing)의 실행은 일반적으로 관리 인터페이스 (Administrative Interface)을 통해 UBEC 사용자 또는 일반 사용자(Generic User)에 의해 수 동으로 호출된다. 9482단계에서, 제안된 앱체인 모음(Proposed Appchain Collection)은 관리 인터페이스 (Administrative Interface)에서 생성되며, 따라서 UBEC 사용자/일반 사용자(Generic User) 이 최종 모듈식 출력 정적 앱체인 보유(Static Appchain Retention)에 포함하기를 원하는 앱체인의 범위를 정의한다. 9484단계에서, 실행 세그먼트 모음(Execution Segment Collections)/데이터 세그먼트 모음(Data Segment Collections)는 제안된 앱체인 모음의 참조로부터 생성된다. 9486단계에서, 제 안된 앱체인 모음은 수정된 캐치 환경(MCE; Modified Catch Environment) 내의 생성된 실행 스트 림 렌더링(ESR; Execution Stream Rendering) 인스턴스에 의해 처리된다. 의존성(dependency) 및 디버깅 정보(debugging information)는 실행 세션(execution session)으로부터 도출될 수 있기 위해, MCE(Modified Catch Environment)는 다양한 이벤트에 대한 트리거 지점(trigger points)을 설치하는 커스텀 실행 환경 (custom execution environment)이 있다. 그 후, 의존성 요청 이행(DRF; Dependency Request Fulfillment) 모듈이 MCE와 관련하여 SAP(Static Appchain Processing) 인스턴스 내에서 호 출된다. 9490단계에서, 실행 또는 데이터 요청은 ESR(Execution Stream Rendering) 인스턴스에 의해 구 성된다. 프롬프트는 ESR(Execution Stream Rendering)에 의해 구성되는 실행 또는 데이터 요청 (Execution or Data Request)은 모음(Collections) 6902/6904에 존재하는지 판별하기 위해 실행 (Execution) 및 데이터(Data) 세그먼트 모음(Segment Collections)을 평가한다. 프롬프트에 대한 응답이 존재함(Does Exist)인 경우, 프롬프트은 (실행 스트림 렌더링(ESR; Execution Stream Rendering)의) 해당 실행 또는 데이터 세그먼트Exe-cution 또는 Data Segment (ESR 6400)가 LIZARD(12 0)의 니드 맵 매칭(NMM; Need Map Matching)(C114) 서브모듈에 따라 정당화되는지 평가하여 호출된다. 프롬프트 에 대한 존재하지 않음(Does Not Exist)의 응답은 도 1238에서 평가된다. 도 1235는 정적 앱체인 처리(SAP; Static Appchain Processing) 모듈의 9498단계와 관련된 작동 세부 사 항을 자세히 설명한다. 제안된 앱체인 모음(Proposed Appchain Collection)은 9500단계에 모듈식 입력으 로 제출되며, 이는 모음을 나중에 앱체인 참조 캐시 보유(ARCR; Appchain Reference Cache Retention)에 저장하는 독립적인 앱체인(independent Appchain) 참조로 분리한다. 9504단계는 ARCR(Appchain Reference Cache Retention)내의 모든 앱체인 인스턴스를 순환(cycles)하는 루프 (Loop)를 생성한다. 9508단계는 BCHAIN 프로토콜를 통해 BCHAIN 네트워크의 관련 캐시 노드(Cache Node)에서 선택된 앱체인 인스턴스(Appchain Instance)을 검색한다. 따라서 9508단계(도 1236에 자 세히 설명됨)는 실행 스트림 모음(ESC; Execution Stream Collection)과 데이터 스트림 정렬(DSS; Data Stream Sorting)의 호출을 통해 9512단계에서 진행되는 이행된 앱체인 인스턴스(lled Appchain Instance)을 생성한다. 실행 스트림 모음(ESC; Execution Stream Collection)은 9518단계에 모듈 식 입력으로 제출되는 실행 스트림(Execution Stream)을 생성하며 또한, 데이터 스트림 정렬(DSS; Data Stream Sorting)은 9518단계에 모듈식 입력으로 제출되는 데이터 스트림(Data Stream)을 생성한다. 따라서 9518단계는 다양한 실행(Execution) 및 데이터(Data) 스트림(Streams)을 실행 세그먼트 모음(Execution Segment Collection)와 데이터 세그먼트 모음(Data Segment Collection)(690 4)로 수집한다. 9519단계는 9504단계에 의해 시작된 루프(Loop)를 다음 사용할 수 있는 앱체인 인스턴스 (Appchain Instance)으로 발전시키는 것을 이후에 진행한다. 도 1236은 정적 앱체인 처리(SAP; Static Appchain Processing) 모듈의 9508단계에 대한 작동 세부 사항 을 자세히 설명한다. 9508단계는 BCHAIN 프로토콜 기능 컨텐츠 클레임 생성기(CCG; Content Claim Generator)를 호출한다. 따라서, 제안된 기준선 홉 경로(PBHP; Proposed Baseline Hop Pathways) 를 포함하는 콘텐츠 클레임 요청(CCR; Content Claim Request)이 생성된다. (신경 경제 형이상학적 연구 (NMC; Neuroeconomic Metaphysical Contentment) 앱체인(Appchain)인 경우에) 요청된 앱체인 인스턴스(Appchain Instance)의 일부를 포함하는 해당 캐시 노드(Cache Node)에 최종적으로 도달하기 위해 CCR(Content Claim Request)은 BCHAIN 네트워크에 제출된다. 결과적으로 BCHAIN 프로토콜 을 통해 메타체인(Metachain)의 와트 경제(Watt Economy)를 활용(leveraging)하여 경제적으로 보상 받기 때문에 캐시 노드(Cache Node)는 CCR를 충족한다. 캐시 노드는 해당 CCR에 응답 하여 해당 컨텐츠 클레임 이행(CCF; Content Claim Fulfillment) 유닛을 생성한다. 새롭게 생성된 CCF는 SAP(Static Appchain Processing) 인스턴스를 처리중인 노드의 컨텐츠 클레임 렌더링 (CCR; Content Claim Rendering) 모듈에 도달하는 BCHAIN 네트워크를 따라 이동한다. 컨텐츠 디코 딩 명령어(Content Decoding Instructions)는 CCF 응답을 제공(render)하기 위해 참조되며, 따라 서 이행된 앱체인 인스턴스(Fulfilled Appchain Instance)를 생성한다. 따라서, 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment) 앱체인(Appchain)의 실행(Execution) 및 데이터 세그먼트(Data Segments)가 검색되었다. 도 1237는 정적 앱체인 처리(SAP; Static Appchain Processing) 인스턴스 내에서 의존성 요청 이행(DRF; Dependency Request Fulfillment) 서브모듈의 논리 흐름을 자세히 설명하며, 따라서 도 1234를 재개한다. 프롬프트에 대한 존재함(Does Exist) 응답은 해당 실행 또는 데이터 세그먼트(Execution or Data Segment)는 니드 맵 매칭(NMM; Need Map Matching)(C114)에 따라 정당화됨(Justified)인지 확인 하는 9498단계를 호출한다. 프롬프트에 정당화됨(Justified) 응답이 발생하면, 9524단계는 표시된 세그먼트 캐시 보유(MSCR; Marked Segment Cache Retention)에 포함될 실행 또는 데이터 세그먼트 Execution or Data segment ()를 표시하여 호출한다. 프롬프트에 정당화되지 않음(Not Justified) 응답에 대한 논리 흐름은 도 1238에 도시한다. 9524단계의 결론은 DRF(Dependency Request Fulfillment) 인스턴스 처리의 결론을 암시한다. 따라서 9524단계 이후, 9526단계는 MSCR(Marked Segment Cache Retention)에서 발견된 해당 표시된 세그먼트(Marked Segments)를 포함하는 이행된 엡체인 인스턴스 (lfilled Appchain Instance)와 관련하여 호출된다. 9508단계는 BCHAIN 프로토콜를 통해 관련 캐시 노드(Cache Node)에서 선택된 앱체인 인스턴스(Selected Appchain Instance)를 검색하고, 따라서 도 1236에 설명된 것과 같이, 이행된 앱체인 인스턴스(Fulfilled Appchain Instance)을 생성한다. 도 1238는 수정된 캐치 환경(MCE; Modified Catch Environment)의 9486단계과 관련하여 정적 앱체인 처 리(SAP; Static Appchain Processing) 인스턴스 내의 의존성 요청 이행(DRF; Dependency Request Fulfillment) 서브모듈의 논리 흐름에 대해 자세히 설명한다. 프롬프트에 대한 존재하지 않음(Does Not Exist) 응답 및 프롬프트에 대한 정당화되지 않음(Not Justified) 응답은 모두 5600단 계의 활성화로 이어지고, 공식 시스템 토큰(Official System Token)이 포함된 진단 로그 유닛(DLU; Diagnostic Log Unit)에 생성 및 제출된다. 상기 토큰(Token)은 UBEC 플랫폼 내의 공식 기능 인 경우, 해당 기능 또는 프로그램이 비이상적인 상태에 도달했음을 나타내기 위해 포함되어 있다. 진단 로그 유닛(DLU; Diagnostic Log Unit)는 진단 로그 제출(DLS; Diagnostic Log Submission) 모듈에 제출 되며, 이는 DLU를 셀프 프로그래밍 셀프 혁신(SPSI; Self Programming Self Innovation)에 공급하 기 위해 LOM의 자동화된 리서치 메커니즘(ARM; Automated Research Mechanism)에 의해 호출된다. 따 라서 SPSI(Self Programming Self Innovation)은 DLU(Diagnostic Log Unit)에서 발견된 진단 정보 를 진단 로그 유닛 분석(DLUA; Diagnostic Log Unit Analysis) 모듈로 처리할 수 있다. 이는 지정된 응 답이 프롬프트 9492 및 9498에 대해 호출된 초기 이유를 피하기 위해 I2GE 그리고/또는 수정된 캐치 환경 (MCE; Modified Catch Environment)에 해당 수정을 수행하도록 DLUA(Diagnostic Log Unit Analysis)을 호출하여 나타내는 13005단계로 이어진다. 프롬프트에 대한 정당화됨 (Justified) 응답은 I2GE에서 에뮬레이트된(emulated) 실행 스트림 렌더링(ESR; Execution Stream Rendering) 인스턴스에 대해 스레드 차단 관리(TBM; Thread Blocking Management)를 호출한다. 따 라서 TBM은 DRF의 오리지널 스레드(original thread)가 처리되는 동안 I2GE 진화 분산 프로 세스(evolutionary variance process)를 계속할 수 있도록 한다. 이는 운영 효율성을 달성하기 위해 수행된다. 도 1239은 LIZARD의 다이나믹 쉘(DS; Dynamic Shell)(C198)의 서브모듈로 작동하는 니드 맵 매칭(NMM; Need Map Matching)(C114)의 작동 및 기능을 도시한다. NMM(Need Map Matching)(C114) 인스턴스는 정적 앱체인 처리(SAP; Static Appchain Processing)에서 의존성 요청 이행(DRF; Dependency Request Fulfillment)의 9528단계의 작동을 제공하기 위해 생성된다. 실행 세그먼트 모음(Execution Segment Collection) 및 데이터 세그먼트 모음(Data Segment Collection)은 니드 액세스 개발 및 스토리지 (Need Access and Development and Storage)에 저장하기 위해 제출된다. 따라서 모음 6902/6904은 서브 카테고리로 분류되고 일련의 계층적 브랜치 및 레이어으로 스토리지에 유지된다. NMM(C114)의 모듈식 호출에 따라, 초기 구문 분석(Initial Parsing)(C148)은 진행중인 NMM(C114) 인스턴스 내에서 참조하기 위해 일시 적으로 유지하도록 스토리지에서 각 관할구역 브랜치를 다운로드한다. 브랜치 니드 계산(Calculate Branch Needs)(C149)으로, 각 브랜치와 관련된 정의에 따라, 니드(needs)는 해당 부서와 연관되어 있다. 상기 방법으로, 권한 검사(permission checks)는 NMM(C114) 인스턴스 내에서 구성될 수 있다. 예를 들어, 직원의 능 력에 따라 직원 성과를 매년 검토하는 영역 내에서 요청되었기 때문에 NMM(C114)는 모든 직원 CV를 다운로드하 도록 인사부서에 요청을 승인했다. 따라서 부서 관할구역의 유효한 필요성(needs)임을 입증되었다. 따라서 니드 인덱스(Need Index)(C145)는 관할구역 브랜치와 및 각각의 니드의 메인 스토리지이다. 이 내부 참조는 NMM(C114) 및 제공되는 모든 모듈의 작동에 대한 리소스 병목 현상(resource bottleneck)이기 때문에, 시스템의 전반적인 효율성을 높이기 위해 빠른 데이터베이스 쿼리에 미리 최적화되어 있다. 9350단계는 입력 목적(Input Purpose)(C139)을 NMM(C114)의 검색 알고리즘(Search Algorithm)(C144)에 모듈식 입력으로 제공한다. 입력 목 적(C139)가 니드 액세스 개발 및 스토리지에 초기에 정의된 관할구역 브랜치에 따라 유효한 니드를 정의 하는지 판별하므로, 검색 알고리즘(C144)는 컴파일된(compiled) 니드 인덱스(C145)를 통해 참조하고 검색한다. 따라서 니드 인덱스(C145)를 통해 검색 알고리즘(C144)의 완료된 실행은 NMM(C114)의 모듈식 출력으로 제출되고 니드 결과(Need Result)(C141)로 참조되는 승인/차단(C146) 응답을 생성한다. 따라서 니드 결과(C141)는 의존성 요청 이행(DRF; Dependency Request Fulfillment) 및 정적 앱체인 처리(SAP; Static Appchain Processing)의 9498단계로 되돌아간다. 도 1240는 수정된 캐치 환경(MCE; Modified Catch Environment)의 실행 스트림 렌더링(ESR; Execution Stream Rendering) 인스턴스로부터, 실행(Execution) 및 데이터(Data) 요청(Requests)을 목 적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동에 관한 세부 사항을 도시한 다. 외부 명령어 제안(External Instruction Proposition)는 외부 코어(OC; Outer Core)(C329)의 관할구 역에 속하는 구문 모듈(SM; Syntax Module)(C35)에 제출한다. 구문 모듈(SM)(C35)는 컴퓨터 코드를 읽고 쓸 수 있는 프레임워크를 제공한다. 코드 작성을 위해, 상기 목적 모듈(PM; Purpose Module)(C36)로부터 복합 목적 포 맷(Complex Purpose Format)(C325)를 수신한다. 상기 복잡 목적 포맷(C325)는 '의사 코드(pseudocode)'라고 하 는 임의의 코드 구문으로 작성된다. 의사 코드에는 if/else문, while루프 등 모든 프로그래밍 언어 중에서 가장 일반적인 상기 계산 작업의 기본 구현이 포함되어 있다. 그 후 헬퍼(helper) 함수(function)는 상기 원하는 타 겟 계산 구문 (컴퓨터 언어)에 따라 상기 의사 코드를 실제 실행가능한 코드로 변환한다. 코드 판독을 위해, SM(C35)는 이러한 코드의 기능성에 대한 목적을 도출하는 PM(C36)의 컴퓨터 코드의 구문적 해석을 제공한다. 상 기 외부 명령어 제안(External Instruction Proposition)는 코드 변환(C321)에 의해 ESR 지침/명령 구문 (ESR(Execution Stream Rendering) Instruction/Command Syntax) 형식으로 수신된다. 코드 변환(C321)은 SM(C35)에서 인식하고 이해하는 임의의(일반적인) 코드를 알려져 있고 선택된 계산 언어로 변환한다. 또한, 코 드 변환(C321)은 임의의 구문 유형으로 알려진 계산 언어를 변환(translating)하는 역함수(inverse function) 도 수행한다. 코드 변환(C321) 완료된 실행의 출력은 논리 감소(Logical Reduction)(C323)에 입력으로 전송된다. 논리 감소(C323)은 규칙 및 구문(C322)의 정의에 따라 상호 연결된 함수 맵을 생성하기 위해 코드 논 리를 간단한 형식으로 축소한다. 따라서 논리 감소(C323)의 실행이 완료되면 해당 SM(C35) 인스턴스의 실행이 완료되고 SM(C35)의 모듈식 출력이 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)으로 전송된다. PM(C36)은 컴퓨터 코드에서 복합 목적 포맷(C325)의 목적을 도출하기 위 해 SM(C35)를 사용한다. 이러한 목적 정의는 SM(C35)에 의해 해석되는 관련 코드 섹션의 의도된 기능성을 적절 하게 설명한다. 또한, PM(C36)은 데이터(이진법/ASCII 등)에 은밀히 잠긴 코드 조각을 감지할 수 있다. 반복 해 석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의(복합 목적 포맷(C325) 내 에서)를 생성하기 위해 모든 상호 연결된 기능을 루프한다. 내부 코어(IC; Inner Core)(C333)은 자동화된 유지 보수/자체 프로그래밍을 거치지 않고 관련 분야의 전문가가 직접, 독점적으로 프로그래밍하는 LIZARD의 영 역이다. IC(C333)의 핵심 코드(C335) 요소에는 기본 프레임워크 및 라이브러리(Fundamental Frameworks and Libraries), 스레드 관리(Thread Management) 및 로드 밸런싱 스크립트(Load Balancing scripts), 통신 및 암 호화 프로토콜(Communication and Encryption protocols) 및 메모리 관리 시스템을 포함한다. 따라서 코어 코 드(C335)는 기본 기능을 가능하게 하는 표준화된 라이브러리 및 스크립트를 제공하여 SM(C35) 및 PM(C36)에 대 한 일반적인 작동 및 기능을 가능하게 한다. IC(Inner Core)(C333)의 시스템 목적(System Objectives)(C336) 요소는 보안 정책 및 기업 목표를 정의한다. 이러한 정의는 LIZARD 내의 다양한 동적 및 정적 기능을 안내 하는 정적 정책 변수로 작동한다. 도 1241는 실행(Execution) 및 데이터(Data) 요청(Requests)을 목적 계층 맵(Purpose Hierarchy Map)으로 변환하기 위한 LIZARD의 작동을 설명하기 위해 도 1240의 논리 흐름을 계속한다. 구문 모듈(SM; Syntax Module)(C35)의 논리 감소(Logical Reduction)(C323)은 목적 모듈(PM; Purpose Module)(C36)의 반복 해석(Iterative Interpretation)(C328)에 출력을 제출한다. 반복 해석(C328)은 목적 연관성(Purpose Associations)(C326)을 참조하여 해석된 목적 정의를 생성하기 위해 모든 상호 연결된 함수를 루프한다. 목적 정의 출력(purpose definition output)은 목적 모듈(PM; Purpose Module)(C36), 외부 코어(OC; Outer Core)(C329), 따라서 LIZARD에 모듈식 출력으로 제출되는 복합 목적 포맷(C325)에 존재한다. 출력은 실행 (Execution) 및 데이터(Data) 요청(Requests)의 복합 목적 포맷(C325) 버전으로 표시되는 목적 계 층 맵으로 분류된다. 내부 코어(IC)(C333)의 동일한 정의 및 적용은 전술한 기능 및 모듈에 적용된다. 도 1242는 정적 앱체인 처리(SAP; Static Appchain Processing) 프로세싱의 마이크로 측면(macro aspects)에 대한 최종 개요를 도시한다. SAP(Static Appchain Processing)은 관리 인터페이스 (Administrative Interface)를 통해 UBEC 사용자 또는 일반 사용자(Generic User)에 의해 수 동으로 호출된다. 9482단계는 제안된 앱체인 모음(Proposed Appchain Collection)을 모듈식 입력으로 수 신되며, 이는 신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment) 앱체인 (Appchain)에 대한 참조를 포함한다. 루프(Loop)는 앱체인 참조 캐시 보유(ARCR; Appchain Reference Cache Retention)에서 모든 앱체인 인스턴스(Appchain Instances)을 순환하여 9504단계에서 시작 된다. 9538단계에서, 이행된 앱체인 인스턴스(Fulfilled Appchain Instance)는 표시된 세그먼트 캐시 보 유(MSCR; Marked Segment Cache Retention)에서 검색되며, 따라서 9540단계로 이어진다. 이행된 앱체인 인스턴스는 (신경 경제 형이상학적 연구(NMC; Neuroeconomic Metaphysical Contentment)의 경우 와 같이) 선택된 앱체인를 실행하도록 요구된 실행(Execution) 및 데이터(Data) 세그먼트 (Segments)의 전체 세트(set)가 들어 있으며, LOM, CTMP 따라서, LIZARD의 전체 앱체인 (Appchain)과 같은 모듈식 의존성(dependencies)을 포함한다. 9540단계는 모든 이행된 앱체인 인스턴스를 앱체인 보유(Static Appchain Retention)에 점진적으로 설치하며, 이는 각 발신(outgoing) 실행 (Execution) 및 데이터(Data) 세그먼트(Segments)가 표시된 세그먼트 캐시 보유(MSCR; Marked Segment Cache Retention)에 의해 표시된 상태(Marked status)를 확인한다. 따라서 정적 앱체인 보유 (Static Appchain Retention)는 정적 앱체인 처리(SAP; Static Appchain Processing)의 최종 모듈 식 출력으로 생성되며 앱체인 에뮬레이션 레이어(AEL; Appchain Emulation Layer)의 실행 및 데이터 세 그먼트 추출(EDSE; Execution and Data Segment Extraction) 모듈에 모듈식 입력으로 제출된다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12 도면13 도면14 도면15 도면16 도면17 도면18 도면19 도면20 도면21 도면22 도면23 도면24 도면25 도면26 도면27 도면28 도면29 도면30 도면31 도면32 도면33 도면34 도면35 도면36 도면37 도면38 도면39 도면40 도면41 도면42 도면43 도면44 도면45 도면46 도면47 도면48 도면49 도면50 도면51 도면52 도면53 도면54 도면55 도면56 도면57 도면58 도면59 도면60 도면61 도면62 도면63 도면64 도면65 도면66 도면67 도면68 도면69 도면70 도면71 도면72 도면73 도면74 도면75 도면76 도면77 도면78 도면79 도면80 도면81 도면82 도면83 도면84 도면85 도면86 도면87 도면88 도면89 도면90 도면91 도면92 도면93 도면94 도면95 도면96 도면97 도면98 도면99 도면100 도면101 도면102 도면103 도면104 도면105 도면106 도면107 도면108 도면109 도면110 도면111 도면112 도면113 도면114 도면115 도면116 도면117 도면118 도면119 도면120 도면121 도면122 도면123 도면124 도면125 도면126 도면127 도면128 도면129 도면130 도면131 도면132 도면133 도면134 도면135 도면136 도면137 도면138 도면139 도면140 도면141 도면142 도면143 도면144 도면145 도면146 도면147 도면148 도면149 도면150 도면151 도면152 도면153 도면154 도면155 도면156 도면157 도면158 도면159 도면160 도면161 도면162 도면163 도면164 도면165 도면166 도면167 도면168 도면169 도면170 도면171 도면172 도면173 도면174 도면175 도면176 도면177 도면178 도면179 도면180 도면181 도면182 도면183 도면184 도면185 도면186 도면187 도면188 도면189 도면190 도면191 도면192 도면193 도면194 도면195 도면196 도면197 도면198 도면199 도면200 도면201 도면202 도면203 도면204 도면205 도면206 도면207 도면208 도면209 도면210 도면211 도면212 도면213 도면214 도면215 도면216 도면217 도면218 도면219 도면220 도면221 도면222 도면223 도면224 도면225 도면226 도면227 도면228 도면229 도면230 도면231 도면232 도면233 도면234 도면235 도면236 도면237 도면238 도면239 도면240 도면241 도면242 도면243 도면244 도면245 도면246 도면247 도면248 도면249 도면250 도면251 도면252 도면253 도면254 도면255 도면256 도면257 도면258 도면259 도면260 도면261 도면262 도면263 도면264 도면265 도면266 도면267 도면268 도면269 도면270 도면271 도면272 도면273 도면274 도면275 도면276 도면277 도면278 도면279 도면280 도면281 도면282 도면283 도면284 도면285 도면286 도면287 도면288 도면289 도면290 도면291 도면292 도면293 도면294 도면295 도면296 도면297 도면298 도면299 도면300 도면301 도면302 도면303 도면304 도면305 도면306 도면307 도면308 도면309 도면310 도면311 도면312 도면313 도면314 도면315 도면316 도면317 도면318 도면319 도면320 도면321 도면322 도면323 도면324 도면325 도면326 도면327 도면328 도면329 도면330 도면331 도면332 도면333 도면334 도면335 도면336 도면337 도면338 도면339 도면340 도면341 도면342 도면343 도면344 도면345 도면346 도면347 도면348 도면349 도면350 도면351 도면352 도면353 도면354 도면355 도면356 도면357 도면358 도면359 도면360 도면361 도면362 도면363 도면364 도면365 도면366 도면367 도면368 도면369 도면370 도면371 도면372 도면373 도면374 도면375 도면376 도면377 도면378 도면379 도면380 도면381 도면382 도면383 도면384 도면385 도면386 도면387 도면388 도면389 도면390 도면391 도면392 도면393 도면394 도면395 도면396 도면397 도면398 도면399 도면400 도면401 도면402 도면403 도면404 도면405 도면406 도면407 도면408 도면409 도면410 도면411 도면412 도면413 도면414 도면415 도면416 도면417 도면418 도면419 도면420 도면421 도면422 도면423 도면424 도면425 도면426 도면427 도면428 도면429 도면430 도면431 도면432 도면433 도면434 도면435 도면436 도면437 도면438 도면439 도면440 도면441 도면442 도면443 도면444 도면445 도면446 도면447 도면448 도면449 도면450 도면451 도면452 도면600 도면601 도면602 도면603 도면604 도면605 도면606 도면607 도면608 도면609 도면610 도면611 도면612 도면613 도면614 도면615 도면616 도면617 도면618 도면619 도면620 도면621 도면622 도면623 도면624 도면625 도면626 도면627 도면628 도면629 도면630 도면631 도면632 도면633 도면634 도면635 도면636 도면637 도면638 도면639 도면640 도면641 도면642 도면643 도면644 도면645 도면646 도면647 도면648 도면649 도면650 도면651 도면652 도면653 도면654 도면655 도면656 도면657 도면658 도면659 도면660 도면661 도면662 도면663 도면664 도면665 도면666 도면667 도면668 도면669 도면670 도면671 도면672 도면673 도면674 도면675 도면676 도면677 도면678 도면679 도면680 도면681 도면682 도면683 도면684 도면685 도면686 도면687 도면688 도면689 도면690 도면691 도면692 도면693 도면694 도면695 도면696 도면697 도면698 도면699 도면700 도면701 도면702 도면703 도면704 도면705 도면706 도면707 도면708 도면709 도면710 도면711 도면712 도면713 도면714 도면715 도면716 도면717 도면718 도면719 도면720 도면721 도면722 도면723 도면724 도면725 도면726 도면727 도면728 도면729 도면730 도면731 도면732 도면733 도면734 도면735 도면736 도면737 도면738 도면739 도면740 도면741 도면742 도면743 도면744 도면745 도면746 도면747 도면748 도면749 도면750 도면751 도면752 도면753 도면754 도면755 도면756 도면757 도면758 도면759 도면760 도면761 도면762 도면763 도면764 도면765 도면766 도면767 도면768 도면769 도면770 도면771 도면772 도면773 도면774 도면775 도면776 도면777 도면778 도면779 도면780 도면781 도면782 도면783 도면784 도면785 도면786 도면787 도면788 도면789 도면790 도면791 도면792 도면793 도면794 도면795 도면796 도면797 도면798 도면799 도면800 도면801 도면802 도면803 도면804 도면805 도면806 도면807 도면808 도면809 도면810 도면811 도면812 도면813 도면814 도면815 도면816 도면817 도면818 도면819 도면820 도면821 도면822 도면823 도면824 도면825 도면826 도면827 도면828 도면829 도면830 도면831 도면832 도면833 도면834 도면835 도면836 도면837 도면838 도면839 도면840 도면841 도면842 도면843 도면844 도면845 도면846 도면847 도면848 도면849 도면850 도면851 도면852 도면853 도면854 도면855 도면856 도면857 도면858 도면859 도면860 도면861 도면862 도면863 도면864 도면865 도면866 도면867 도면868 도면869 도면870 도면871 도면872 도면873 도면874 도면875 도면876 도면877 도면878 도면879 도면1000 도면1001 도면1002 도면1003 도면1004 도면1005 도면1006 도면1007 도면1008 도면1009 도면1010 도면1011 도면1012 도면1013 도면1014 도면1015 도면1016 도면1017 도면1018 도면1019 도면1020 도면1021 도면1022 도면1023 도면1024 도면1025 도면1026 도면1027 도면1028 도면1029 도면1030 도면1031 도면1032 도면1033 도면1034 도면1035 도면1036 도면1037 도면1038 도면1039 도면1040 도면1041 도면1042 도면1043 도면1044 도면1045 도면1046 도면1047 도면1048 도면1049 도면1050 도면1051 도면1052 도면1053 도면1054 도면1055 도면1056 도면1057 도면1058 도면1059 도면1060 도면1061 도면1062 도면1063 도면1064 도면1065 도면1066 도면1067 도면1068 도면1069 도면1070 도면1071 도면1072 도면1073 도면1074 도면1075 도면1076 도면1077 도면1078 도면1079 도면1080 도면1081 도면1082 도면1083 도면1084 도면1085 도면1086 도면1087 도면1088 도면1089 도면1090 도면1091 도면1092 도면1093 도면1094 도면1095 도면1096 도면1097 도면1098 도면1099 도면1100 도면1101 도면1102 도면1103 도면1104 도면1105 도면1106 도면1107 도면1108 도면1109 도면1110 도면1111 도면1112 도면1113 도면1114 도면1115 도면1116 도면1117 도면1118 도면1119 도면1120 도면1121 도면1122 도면1123 도면1124 도면1125 도면1126 도면1127 도면1128 도면1129 도면1130 도면1131 도면1132 도면1133 도면1134 도면1135 도면1136 도면1137 도면1138 도면1139 도면1140 도면1141 도면1142 도면1143 도면1144 도면1145 도면1146 도면1147 도면1148 도면1149 도면1150 도면1151 도면1152 도면1153 도면1154 도면1155 도면1156 도면1157 도면1158 도면1159 도면1160 도면1161 도면1162 도면1163 도면1164 도면1165 도면1166 도면1167 도면1168 도면1169 도면1170 도면1171 도면1172 도면1173 도면1174 도면1175 도면1176 도면1177 도면1178 도면1179 도면1180 도면1181 도면1182 도면1183 도면1184 도면1185 도면1186 도면1187 도면1188 도면1189 도면1190 도면1191 도면1192 도면1193 도면1194 도면1195 도면1196 도면1197 도면1198 도면1199 도면1200 도면1201 도면1202 도면1203 도면1204 도면1205 도면1206 도면1207 도면1208 도면1209 도면1210 도면1211 도면1212 도면1213 도면1214 도면1215 도면1216 도면1217 도면1218 도면1219 도면1220 도면1221 도면1222 도면1223 도면1224 도면1225 도면1226 도면1227 도면1228 도면1229 도면1230 도면1231 도면1232 도면1233 도면1234 도면1235 도면1236 도면1237 도면1238 도면1239 도면1240 도면1241 도면1242"}
{"patent_id": "10-2024-7015160", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 UBEC 플랫폼을 구성하는 각각의 서브 모듈 / 종속성을 갖는 정보 생태계를 도시한다. 도 2는 제3자 어플리케이션 및 서비스 및 제3자 알고리즘의 세부 사항을 도시한다 도 3은 UBEC 플랫폼을 배치하기 위한 자동 배포 메커니즘을 도시한다. 도 4는 애플 iOS 장치에 최적화 된 배포 루틴 A를 도시한다. 도 5는 구글 플레이 스토어에 최적화 된 배포 루틴 B를 도시한다. 도 6은 다이렉트 하드웨어 사양이 SPSI에 의해 참조되어 인터페이스 드라이버를 생성하는 배포 루틴 C를 도시한 다. 도 7은 UBEC 플랫폼과 처음으로 상호 작용하는 비전문가 사용자의 사용 사례를 도시한 도면. 도 8은 기본적 운영 체제로서 UBEC 플랫폼을 실행하는 스마트 폰을 조작하는 사용자를 도시한다. 도 9는 UBEC 플랫폼 및 BCHAIN 네트워크를 통해 LOM에 의해 수행되는 자동 전화 통화 프로세스의 상세한 논리 흐름을 도시한다. 도 10은 인공 지능 개인 비서로서 개인 건강을 관리하기 위한 다수의 기능을 동작시키는 앱체인으로서의 LOM을 도시한다. 도 11 및 12는 UBEC 패스스루(Passthrough)가 앱체인으로서의 UBEC에서 발생하는 정보 트래픽을 수신함을 보여 준다. 도 13 및 14는 LIZARD 사용 API 및 LOM 사용 API의 사용 사양이 앱체인 자체에 의해 어떻게 정의 되는지 보여준 다; 도 15는 LUIGI에만 독점적으로 속하는 통화 유동성 조작(current liquidity manipulation) 기능을 도시한다. 도 16은 제출 검증 + 앱 체인 유지 보수 수행을 검증하기(Verification of Submission + Maintenance) 위한 LUIGI의 기능을 도시한다. 도 17은 계약 조건의 검증(Verification of Contractual Conditions)을 수행하기 위한 LUIGI의 기능을 도시한 다. 도 18은 충돌 해결 어필 시스템(Conflict Resolution Appeal System)으로서의 LUIGI의 기능을 도시한다. 도 19는 가상 난독화 행동 모니터링(Virtual Obfuscation Behavior Monitoring)을 갖는 사용자 노드 상호 작용 에 관한 LUIGI의 능력을 도시한다. 도 20은 앱체인 합병 후속 검증(Appchain Merge Followup Verification)에 관한 LUIGI의 기능을 도시한다. 도 21은 손실 자금 복구 및 사기 활동 반전(Lost Fund Recovery & Fraudulent Activity Reversal)에 관한 LUIGI의 기능을 도시한다. 도 22는 사용자 노드 상호 작용 (UNI; User Node Interaction)의 기능을 도시한다.도 23은 제공되는 생체 데이터(biometric data)의 양이 인증 프로세스(authentication process)를 위해 충분한 지 측정되고 확인됨을 도시한다. 도 24는 밴드 및 노드 연관성 앱체인(Band and Node Association Appchains)이 BCHAIN 프로토콜을 통해 커스텀 체인 생태계로부터 최신 버전으로 업데이트됨을 도시한다. 도 25는 충분한 양의 밴드 인증 토큰 (BAT; Band Authentication Tokens)이 임의의 단일 인증 토큰 (Authentication Tokens)과 일치하는 경우에만 성공적인 인증이 발생함을 도시한다. 도 26은 생체 밴드 분류 (BBC; Biometric Band Categorization)를 도시한다. 도 27은 커스텀체인 생태계를 형성하는 앱체인의 베이스 레이어 메카닉스(base layer mechanics of Appchain s)을 도시한다. 도 28은 UBEC 지원 장치(UBEC Enabled Device)와 관련된 커스텀체인 생태계의 기본 형태를 도시한다. 도 29는 UBEC 어플리케이션 개발 및 배포 프로세스(UBEC Application Development and Deployment)를 도시한다. 도 30은 내부 CEB 로직 프로세싱이 실행 + 데이터 보충 (Execution + Data Supplements)을 출력 함을 도시한다. 도 31은 CEB의 프로세스 완료 시 따르는 단계를 도시한다. 도 32는 커스텀체인 생태계로 알려진 일련의 앱체인으로서 작동하는 LOM을 도시한다. 도 33은 UBEC 시스템와이드 로직(UBEC Systemwide Logic)이 UBEC 플랫폼 내의 다른 앱체인과 상호 작용하는 LOM 컨테이너 앱체인(LOM Container Appchain)을 나타낸다 도 34는 CKR (Central Knowledge Retention)이 그 자체의 독립적인 앱체인으로서 어떻게 존재 하는지를 도시한 다. 도 35는 앱체인으로서 개인 정보 프로파일 (PIP; Personal Intelligence Profile)의 인스턴스를 도시한다. 도 36은 LOM 모듈 라이프 관리 및 자동화 (LAA; Life Administration and Automation)가 병렬 보충 앱체인 (parallel Supplemental Appchain)으로서 존재하는 방법을 도시한다. 도 37은 와트 유닛 통화 알고리즘(Watt Unit Currency Algorithm)을 도시한다. 도 38은 사용자 노드 상호 작용 (UNI; User Node Interaction)을 통한 사용자 인증의 통합으로 와트 유닛 구매 및 판매의 메커니즘을 도시한다. 도 39는 FMO 및 LEI의 기능이 사용자 프라이빗 펀드 할당 (UPFA, User Private Fund Allocation)에 대한 지식 및 액세스를 필요로 한다는 것을 도시한다. 도 40은 CDEE (Cryptographic Digital Economy Exchange)를 도시한다. 도 41은 ADE (App Directory and Exploration) 모듈에 등재 된 UBEC 앱이 투자 측면에서 유동성(liquidity)을 수신 및 발송하는 방법을 도시한다. 도 42는 UBEC 앱이 UBEC 사용자의 UPFA(User Private Fund Allocation)와 직접 상호 작용 함을 도시한다. 도 43은 UBEC 플랫폼 인터페이스 (UPI)와 캐시 작업 수락 (CWA; Cash Work Accpetance) 사이의 상호 작용을 도 시한다. 도 44는 CWSI가 메타 체인의 와트 경제를 참조하는 방법을 도시한다. 도 45는 BCHAIN 프로토콜 (BP)의 개요를 도시한다. 도 46은 BCHAIN 프로토콜이 자신의 하드웨어 및 다른 BCHAIN 노드의 하드웨어와 어떻게 동작 하는지를 도시한다. 도 47은 BCHAIN 네트워크 내에 존재하는 노드 상호 작용의 패러다임을 보여준다. 도 48은 해시 공고 교환 확증(hash accouncement exchange corroboration)이 어떻게 불량 BCHAIN 노드(RogueBCHAIN Node)가 BCHAIN 네트워크에 참여하지 못하게 하는지를 도시한다. 도 49는 BCHAIN 네트워크 내의 CCR 또는 CCF 패킷의 기본 이동 패턴(basic traveling pattern)을 도시한다. 도 50은 사실상 BCHAIN 네트워크의 적응 지능(Adaptive Intelligence)의 2 가지 기능을 도시한다. 도 51은 BCHAIN 네트워크 내의 다수의 섹터들(Sectors) 사이의 추천 된 여행의 알려진 '고속도로'를 도시한다. 도 52는 스태거드 릴리즈 컨텐츠(Staggered Release Contents) 를 도시한다. 도 53은 라이브 스트림 컨텐츠(Live Stream Content)를 도시한다. 도 54는 SCS (Strategy Corroboration System)가 TSC (Traffic Scope Consensus) 모듈을 사용하여 이중 범위 해시 수집(Dual Scope Hash collection)을 유도하는 것을 도시한다. 도 55는 해시 공고(Hash Announcements)가 섹터(Sectors)로 알려진 3 개의 상이한 트래픽 영역 사이에서 교환되 는 것으로 도시하고 있다. 도 56은 커스텀체인 스토리지(Customchain Storage)의 구조를 도시한다. 도 57은 노드 통계 조사 (NSS; Node Statistical Survey)가 4 개의 주요 인덱스를 계산하기 위해 주변 노드 (surrounding Nodes)의 거동에 관한 정보를 수집하는 것을 도시한다. 도 58은 노드 핑 프로세싱 (NPP; Node Ping Processing)의 세부 사항을 도시한다. 도 59는 전략 확증 시스템 (SCS; Strategy Corroboration System)을 도시한다. 도 60은 트래픽 범위 컨센서스 (TSC; Traffic Scope Consensus)가 노드 통계(NSS) 변수를 수신하고 NSS 변수 합성 평균 (NVCI; NSS Variables Composite Average)을 생성하기 위해 NVP를 호출하는 것을 도시한다. 도 61 내지 63은 NSS 가변 풀링 (NVP; NSS Variable Pooling)에 의해 성능 인자가 생성되고 가장 가까운 배수 X (the nearest multiple X)로 반내림 됨을 보여준다. 도 64는 동적 전략 적응 (DSA; Dynamic Strategy Adaptation)을 도시한다. 도 65는 전략 성능 해석 (SPI; Strategy Performance Interpretation)을 도시한다. 도 66 및 67은 데이터 세그먼트 헤비 앱체인(Data Segment heavy Appchain)으로서 동작하는 SPT (Strategy Performance Tracking)의 데이터베이스 구조를 도시한다. 도 68 내지 70은 최적화 된 전략 선택 알고리즘 (OSSA; Optimized Strategy Selection Algorithm)의 상세한 작 업을 도시한다. 도 71은 DSA (Dynamic Strategy Adaptation)에서 호출한 SCM (Strategy Creation Module)을 보여준다. 도 72는 전략 기준 구성(Strategy Criteria Composition)을 구성하는 다양한 기준을 도시한다. 도 73은 SCM이 모듈식 입출력을 처리하는 방법을 도시한다. 도 74는 창의성 모듈(Creativity Module)이 전략 기준 구성을 업데이트하기 위해 어떻게 사용되는지를 도시한다. 도 75는 UBEC 사용자가 사용자 노드 상호 작용 (UNI; User Node Interaction)에서 수행된 생체 인식(biometric recognition)을 통해 UBEC 플랫폼에 액세스 함을 도시한다. 도 76은 경제 인센티브 선택 (EIS; Economic Incentive Selection)에 대한 참조를 제공하는 CNRA (Computation and Network Resource Availability)가 호출되는 것을 도시한다. 도 77 내지 79는 진단 로그 제출 (DLS; Diagnostic Log Submission)을 도시한다. 도 80 내지 83은 EIS 및 작업 지불 클레임 처리(WPCP, Work Payment Claim Processing)을 보여준다. 도 84 내지 169는 CSR, MNSCS 및 MFDR과 함께 작동하는 DIM (Data Integrity Management) 기능을 보여준다. 도 170 내지 358은 BCHAIN 네트워크의 주요 핵심인 라우팅 로직(Routing Logic)에 대한 세부 사항을 제공한다. 도 359 내지 365는 UBEC / BCHAIN 마이크로칩 아키텍쳐(UBMA; UBEC/BCHAIN Mircrochip Architecture)로 디자인된 커스텀 프로세서의 구조를 보여준다. 도 366은 배포 패치 어셈블리 (DPA; Deployment Patch Assembly) 모듈의 세부 사항, 로지스틱스 레이어 (Logistics Layer) 및 커스텀체인 생태계 빌더 (CEB, Customschain Ecosystem Builder)와의 상호작용의 세부 사항을 도시한다. 도 367은 수정 패치 블록 추가 (CPBA; Correction Patch Block Addition)를 위한 프로세스를 도시한다. 도 368 내지 371은 앱체인 스왑 매커니즘 (ASM; Appchain Swap Mechanism) 시퀀스(sequence)를 도시한다. 도 372 내지 도 373은 로지스틱스 레이어 해석 (L2I) 시퀀스를 도시한다. 도 374 내지 도 375는 타겟 앱체인의 로지스틱스 레이어를 앱체인으로 변환하기 위한 LIZARD 프로세스를 도시한 다. 도 376은 로지스틱스 레이어 입력으로부터의 미가공 앱체인 조작 (RAM; Raw Appchain Manipulation) 프로세스를 도시한다. 도 377 내지 도 378은 LIZARD가 로지스틱스 레이어의 실행 가능한 논리 요소(Executable Logic Elements)를 실 행(Execution)으로 변환하는 프로세스를 도시한다. 도 379 내지 도 381은 LIZARD가 로지스틱스 레이어의 정적 데이터 요소(Static Data Elements)를 데이터로 변 환하는 프로세스를 도시한다. 도 382는 MCE에서 ESR에 의해 처리되는 실행 스트림(Execution Stream)에 대한 시퀀스를 도시한다. 도 383은 ESR의 예비 인스턴스(preliminary instance)가 잠재적 환경 범위(Potential Environmental Scope)를 찾는 것을 도시한다. 도 383 내지 도 385는 초기 렌더링 상태(Initial Rendering State)를 초기 렌더링 목적(Initial Rendering Purpose)으로 변환하는 LIZARD를 도시한다. 도 386 내지 도 387은 최종 렌더링 상태(Final Rendering State)를 최종 렌더링 목적(Final Rendering Purpose)으로 변환하는 LIZARD를 도시한다. 도 388 내지 도 402는 ESR의 예비 인스턴스가 CTMP 및 LOM을 이용하여 잠재적 환경 범위를 찾는 경우의 세부 사 항을 도시한다. 도 403 및 도 404는 미가공 앱체인 조작 (RAM; Raw Appchain Manipulation) 종속성 요청 이행 (DRF; Dependency Request Fulfillment)을 도시한다. 도 405 내지 도 407은 LIZARD가 실행 요청을 목적으로 변환하는 것을 도시한다. 도 408은 DRF를 갖는 RAW를 도시한다. 도 409는 업그레이드 된 실행 스트림 및 오리지널 실행 스트림을 갖는 DPA를 도시한다. 도 410은 ESC 및 업그레이드 된 실행 스트림을 갖는 EDSM을 도시한다. 도 411 내지 도 412는 업그레이드 된 데이터 스트림 및 오리지널 데이터 스트림을 갖는 DSDL을 도시한다. 도 413 내지 도 416은 업그레이드 된 실행 스트림 A0를 수신하는 ESDL을 도시한다. 도 417 내지 도 418은 ESR을 도시한다. 도 419 및 도 420은 조건부 명령 참조(Conditional Command Reference) 및 실행 시퀀스(Execution Sequence)를 갖는 커맨드 타입(Command Type)을 도시한다. 도 421 내지 도 424는 커맨드 타입에 기초한 MEL 실행을 도시한다. 도 425 내지 429는 데이터 스트림 A0 처리를 도시한다. 도 430은 NCA를 도시한다. 도 431은 ESR 및 렌더링 결과 처리 (R2P; Rendering Result Processing)를 도시한다.도 432 내지 도 436은 ESC를 도시한다. 도 437 내지 도 439는 DSS를 도시한다. 도 440 내지 도 442는 NSA를 도시한다. 도 443 내지 도 445는 P2SP를 나타낸다 도 446 및 도 447은 PRP를 나타낸다 도 448 내지 452는 SRIA (Symbiotic Recursive Intelligence Advancement)를 도시한다. 도 600 내지 도 603은 SPSI를 나타낸다 도 604는 커스텀체인 생태계 내에서 서로 상호 작용하는 공식 앱체인을 도시한다. 도 605는 SPSI 내에서 동작하는 다양한 서브 모듈의 개요를 도시한다. 도 606 내지 609 ATM을 나타낸다. 도 610 내지 616은 A2R을 나타낸다 도 617 및 도 618은 업그레이드 된 목적 맵(Upgraded Purpose Map)을 업그레이드 된 앱체인으로 변환하는 LIZARD를 도시한다. 도 619 내지 652은 IEC를 도시한다. 도 653 및 654는 ASH를 나타낸다 도 655 내지 659는 ASH와 관련하여 LOM 및 CTMP의 내부 작동 절차를 도시한다. 도 660은 CTMP 내의 RP2를 도시한다. 도 661 내지 662는 POE에 대해 자세히 설명한다. 도 663는 POE의 실행과 병행하여 동작하는 메모리 웹 프로세스를 도시한다. 도 664는 PS와 APDM 사이의 논리 흐름 상호 작용에 대해 상세히 설명한다. 도 665는 CRSE에 관한 동작 세부 사항에 대해 상세히 설명한다. 도 666 내지 667은 ID를 대해 자세히 설명한다. 도 668 내지 669는 CDO에 대해 자세히 설명한다. 도 670은 보안 위협 범위(Secutiry Threat Scope)에 기초한 ARM 처리를 도시한다. 도 671은 ASH 및 CKR을 도시한다. 도 672는 ARM 및 CKR을 구체화 한 ASH를 도시한다. 도 673 및 674는 AST에 제출 된 LOM 생성 보안 위협 지식(Secutiry Threat Knowledge)을 도시한다. 도 675 내지 676은 LIZARD 처리 AST에 대한 세부 사항과 함께 ASH를 도시한다. 도 677은 I2GE 처리 AST에 대한 세부 사항을 갖는 ASH를 도시한다. 도 678은 LIZARD가 ESC로부터 타겟 앱체인의 실행 스트림을 수신하는 ASH를 도시한다. 도 679는 LIZARD와 함께 ESC를 통해 수신된 타겟 앱체인의 실행을 수행하는 ASH를 도시한다. 도 680은 I2GE가 반복 진화(Iterative Evolution)를 수행하는 ASH를 도시한다. 도 681은 AST의 공격을 받는 ASH를 도시한다. 도 682는 I2GE가 반복 진화를 수행하는 ASH를 도시한다. 도 684는 ARC (Appchain Regulatory Compliance)를 도시한다. 도 685 내지 686은 시스템 규정 및 지침(System Regulations and Guidelines)을 목적 계층 맵(PurposeHierarchy Map)으로 변환하는 LIZARD를 도시한다. 도 687은 목적 계층 맵을 이용하는 것을 도시한다. 도 688은 LUIGI가 문제의 앱체인이 시스템 규정 및 지침을 위반하고 있음을 독립적으로 확인하였는지를 판단하 는 것을 도시한다. 도 689는 타겟 앱체인의 목적 계층 맵을 조정하는 것을 도시한다. 도 690 내지 692는 LIZARD가 업그레이드 된 목적 맵을 업그레이드 된 앱체인으로 변환하는 것을 보여준다 도 693 내지 697은 DLUA를 나타낸다 도 698 내지 699는 LIZARD가 ERLR을 목적 계층 맵으로 변환하는 것을 도시한다; 도 700 내지 705는 DLUA를 나타낸다 도 706 내지 707은 LIZARD가 컨텍스트 화 된 오류 로그(Contextualized Error Log)를 목적 계층 맵으로 변환하 는 것을 도시한다. 도 708 내지 709는 LIZARD가 리파인된 실행 세그먼트(Refined Execution Segment)를 목적 계층 맵으로 변환하 는 것을 도시한다. 도 710은 DLUA를 도시한다. 도 711은 NAD를 도시한다. 도 712 내지 713은 LIZARD가 UBEC 플랫폼의 전체 커스텀체인 생태계를 목적 계층 맵으로 변환하는 것을 도시한 다. 도 714는 오버랩 협력 및 충돌 체크 (OC3; Overlap Co-operation and Conflict Check)를 도시한다. 도 715 내지 716은 LIZARD가 목적 계층 맵을 일련의 목적 밴드(Purpose Bands)로 변환하는 것을 보여준다; 도 717은 OC3을 나타낸다 718 내지 719는 OC3 맵을 개발하기 위한 CTMP, LOM 및 I2GE의 동작을 도시한다. 720 내지 721은 LIZARD가 신규 제안된 변경(New Proposed Changes)을 목적 계층 맵으로 변환하는 것을 도시한 다. 도 722 내지 724는 오버랩 협력 및 충돌 체크 (OC3)를 도시한다. 도 725 내지 726은 LIZARD가 시스템 디자인 원리(System Design Principles)를 목적 계층 맵으로 변환하는 것 을 도시한다. 도 727 내지 728은 LIZARD가 앱체인 관할권(Appchain Jurisdictions)을 목적 계층 맵으로 변환하는 것을 도시 한다. 도 729 내지 730은 오버랩 협력 및 충돌 체크 (OC3)를 도시한다. 도 731 내지 732는 LIZARD가 업그레이드 된 목적 맵을 신규 제안된 변경으로 변환하는 것을 보여준다 도 733은 PMA (Principled Modification Actuation)를 도시한다. 도 734 내지 735는 LIZARD가 생성할 앱체인(Appchains to Create)을 로지스틱스 레이어로 변환하는 것을 도시한 다. 도 736은 PMA (Principled Modification Actuation)를 나타낸다 도 737 내지 740은 새로운 앱체인 개발 (NAD; New Appchain Development)을 도시한다. 도 741 내지 742는 OC3 맵을 앱체인 구문 맵(Appchain Syntax Map)으로 변환하는 LIZARD를 도시한다. 도 743은 NAD를 도시한다. 도 744 내지 745는 이행된 앱체인(Fulfilled Appchain)을 목적 계층 맵으로 변환하는 LIZARD를 도시한다.도 746 내지 754는 NAD를 나타낸다 도 755 내지 756은 POE를 나타낸다 도 757은 메모리 웹을 도시한다. 도 758은 PS와 APDM 사이의 논리 흐름에 대해 상세히 설명한다. 도 759는 CRSE를 도시한다. 도 760 내지 761는 ID를 도시한다. 도 762 내지 763은 CDO를 나타낸다 도 764 내지 765는 NAD를 나타낸다 도 766 내지 767은 구문 크리에이티브 솔루션(Syntactical Creative Solutions)을 목적 계층 맵으로 변환하는 LIZARD를 도시한다. 도 770 내지 771은 LIZARD가 업그레이드 된 목적 맵을 로지스틱스 레이어로 변환하는 것을 도시한다. 도 775 내지 776은 하드웨어 구조 해석(Hardware Structure Interpretation)을 하드웨어 목적 맵(Hardware Purpose Map)으로 변환하는 LIZARD를 도시한다. 도 777 내지 778은 프레임워크 구조 해석(Framework Structure Interpretation)을 프레임워크 목적 맵 (Framework Purpose Map)으로 변환하는 LIZARD를 도시한다 도 781 내지 784는 EFD에 관한 LOM 및 CTMP의 동작을 도시한다. 도 785 내지 786은 RP2를 나타낸다 도 787 내지 788은 POE를 도시한다. 도 789는 POE의 실행과 병행하여 동작하는 메모리 웹 프로세스를 도시한다. 도 790은 PS와 APDM 사이의 논리 흐름에 대해 상세히 도시한다. 도 791은 CRSE를 도시한다. 도 792 내지 793는 ID를 도시한다. 도 794 내지 795는 CDO를 나타낸다 도 798 내지 799는 리파인 된 프레임 워크 구조 해석(Refined Framework Structure Interpretation)을 이상적 인 프레임 워크 목적 맵(Ideal Framework Purpose Map)으로 변환하는 LIZARD를 도시한다. 도 801은 NMM을 도시한다. 도 807 내지 815는 EHD와 관련하여 LOM 및 CTMP를 도시한다. 도 816은 PS와 APDM 사이의 상호 작용에 대해 상세히 설명한다. 도 817은 CRSE를 도시한다. 도 818 내지 819는 ID를 도시한다. 도 820 내지 821은 CDO를 나타낸다. 도 822 내지 823은 이상적인 하드웨어 구성(Ideal Hardware Configuration)을 목적 계층 맵으로 변환하는 LIZARD를 도시한다. 도 826 내지 827은 전기 공학 원리(Electrical Engineering Principles)를 목적 계층 맵으로 변환하는 LIZARD 를 도시한다. 도 833 내지 834는 LIZARD가 인터페이스 드라이버(Interface Drivers)를 목적 계층 맵으로 변환하는 것을 도시 한다. 도 835 내지 836은 인터페이스 사양(Interface Specifications)을 목적 계층 맵으로 변환하는 LIZARD를 도시한다. 도 841 내지 842는 LIZARD가 모듈 식 인터페이스 플러그인 참조 부분(Modular Interface Drivers Referenced Part)을 목적 계층 맵으로 변환하는 것을 도시한다. 도 843 내지 844는 LIZARD가 인터페이스 드라이버 참조 파트(Interface Drivers Referenced Part)를 목적 계층 맵으로 변환하는 것을 도시한다. 도 854 내지 855는 LIZARD가 모듈식 앱체인 종속성(Modular Appchain Dependancies)을 목적 계층 맵으로 변환 하는 것을 도시한다. 도 856 내지 857은 LIZARD가 모듈식 앱체인 종속성을 목적 계층 맵으로 변환하는 것을 도시한다. 도 859 내지 860은 LIZARD가 업그레이드 된 목적 맵을 미리 컴파일 된 바이너리(Pre-Compiled Binary)로 변환 하는 것을 도시한다. 도 1000 내지 1001은 ES를 도시한다. 도 1002는 CDEE의 보안 감독 기능(security oversight functionality)을 도시한다. 도 1003 내지 1005는 LUIGI를 도시한다. 도 1006 내지 1007은 DAC에 대해 자세히 설명한다. 도 1008은 금융 유동성 조작(Financial Liquidity Manipulation)에서의 통화 유동성 조작 기능(currency liquidity manipulation)을 도시한다. 도 1009 내지 1011은 DVM을 나타낸다. 도 1012 내지 1014는 PTI를 나타낸다. 도 1015 내지 1026은 AOM2를 나타낸다. 도 1027은 유동성 주입(Liquidity Injection)을 도시한다; 도 1028 내지 1030은 PCP를 나타낸다. 도 1031 내지 1034는 CSR을 나타낸다. 도 1035 내지 1036은 MRP를 나타낸다. 도 1037 내지 1038은 RTRP를 나타낸다. 도 1039 내지 1087은 CSE를 나타낸다. 도 1088 내지 11 15는 DMT를 나타낸다. 도 1116 내지 1145는 MERM을 나타낸다. 도 1146 내지 1183은 NME를 나타낸다. 도 1184는 ES 내의 로그 집계(Log Aggregation)의 동작 및 적용을 도시한다. 도 1185 내지 1189는 레거시(Legacy) 및 BCHAIN 시스템에서 앱체인 및 레거시 프로그램(Legacy Programs)의 작 동과 관련하여 SPSI (Self Programming Self Innovation)의 사용 예를 도시한다. 도 1190은 SPSI 내에서 동작하는 다양한 서브 모듈(sub-modules)의 개요를 도시한다. 도 1191 내지 1224는 IEC (Innate Error Correction)의 작동 및 기능을 도시한다. 도 1225 내지 1242는 AEL (Appchain Emulation Layer)의 작동 및 기능을 도시한다."}
