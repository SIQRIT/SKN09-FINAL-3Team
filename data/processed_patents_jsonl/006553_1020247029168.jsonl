{"patent_id": "10-2024-7029168", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0142525", "출원번호": "10-2024-7029168", "발명의 명칭": "지능형, 다기능 로봇의 오프라인 동작 방법", "출원인": "엑스텐드 에이아이 인코포레이티드", "발명자": "폭스 해리"}}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "내부 인공지능을 갖추고 이를 사용하며 외부 인공지능에 연결되지 않은 경우 자율적으로 작동하는 지능형 다기능(multi-function) 로봇을 사용하는 방법으로서, 사전-초기화 프로세스 또는 로봇의 자율 동작 이전의 초기화 프로세스 동안 상기 로봇이 온라인 상태일 때 상기로봇이 특정 작업을 수행하는데 필요한 기능 및 데이터를 서버로부터 다운로드하는 단계, 로봇의 자율 동작 동안, 로봇은 외부 서버나 외부 인공지능을 사용하지 않으며; 로봇 자체에 기본적으로(natively) 있는 소프트웨어를 실행하는 단계, 상기 소프트웨어를 프로세싱하는 하드웨어는 로봇 자체에 있으며, 상기 로봇에 저장된 데이터는 사전구성된(preconfigured) 기능들을 수행하는데 필요한 데이터만을 포함하며; 상기 사전구성된 기능들을 수행하는데 필요한 것만을 포함하도록 온보드 하드웨어 프로세싱 파워를 제한하는 단계; 및 정의된 구내(premises) 내에서의 자율 이동을 위해 상기 로봇을 조정하는 단계를 포함하는 것을 특징으로 하는 지능형 다기능 로봇을 사용하는 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 로봇은 설계된 작업(task) 또는 작업들만을 수행하도록 초기화되는 것을 특징으로 하는 지능형 다기능 로봇을 사용하는 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 사전구성된 기능들은, 인공지능(AI), 사용자들과의 통신, 내비게이션, 사용자 추적, 음성 및 오디오 인식을 통한 개별 사용자 인식, 맵 생성을 포함하는 그룹으로부터 선택되는 것을 특징으로 하는 지능형 다기능 로봇을 사용하는 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "자율 이동이 가능하고 여러 기능 모듈들을 포함하는 지능형 다기능 로봇으로서, 브레인, 라우터 및 각 모듈의 기능적 피처들은 자체 격리된 가상 환경 컨테이너에서 동작하는 것을 특징으로 하는 지능형 다기능 로봇."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서, 각각의 모듈은 자체 격리된 가상 환경 컨테이너에서 패키징되고 및 배포된 독립적인 스크립트를 실행하는 것을특징으로 하는 지능형 다기능 로봇을 사용하는 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제4항에 있어서, 상기 기능적 피처들은 내비게이션, 이미지 프로세싱, 오디오 프로세싱 또는 비디오 프로세싱을 포함하는 것을특징으로 하는 지능형 다기능 로봇을 사용하는 방법. 공개특허 10-2024-0142525-3-청구항 7 다수의 로봇들을 관리하는 서버로서, 각각의 로봇은 지정된 일련의 작업들을 수행하며, 상기 서버는, 복수의 로봇들 각각에 대한 고유한 로봇 ID에 따라 로봇별 작업들 및 관련 스크립트들을 나열하는 로봇 관리 테이블; 상기 스크립트들을 실행하는데 필요한 동작 데이터를 저장하는 동작 데이터베이스; 상기 동작 데이터를 획득 및 업데이트하기 위한 적어도 하나의 알고리즘을 실행하는 프리프로세서; 및상기 서버가 특정 로봇과 네트워크로 통신할 때, 고유 로봇 ID 및 관련된 스크립트들에 따라 상기 복수의 로봇들 중 상기 특정 로봇을 초기화하는 초기화기(initializer)를 포함하는 것을 특징으로 하는 서버."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서, 상기 서버는, 상기 서버와 복수의 로봇들 간의 소프트웨어 및 데이터 업데이트를 조정하기 위한 서버 업데이터; 상기 특정 로봇이 상기 서버와 네트워크 통신 중일 때 적어도 상기 특정 로봇으로부터 전송된 핑(ping) 신호를식별하기 위한 핑 인식기(recognizer); 및상기 프리프로세서에 대한 명령들 및 입력을 수신하는 포털(portal)을 더 포함하는 것을 특징으로 하는 서버."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제7항에 있어서, 상기 프리프로세서는, 객체 인식, 얼굴 인식 및 OCR(광학 문자 인식) 능력 중 적어도 하나를 상기 복수의 로봇들에 제공하기 위한 이미지 프로세서; 오디오 인식, 음성 매칭, NLP(자연어 프로세싱), 음성 대 텍스트(speech to text) 및 텍스트 대 음성(text tospeech) 능력 중 적어도 하나를 상기 복수의 로봇들에 제공하기 위한 오디오 프로세서; 상기 복수의 로봇들에 대한 로컬 구내(local premises)의 맵을 프로세싱하는 네비게이터를 포함하는 것을 특징으로 하는 서버."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "내부 지능을 사용하고 외부 서버에 연결되지 않은 경우 자율적으로 기능하는 지능형 다작업(multi-task) 로봇을프로그래밍하는 방법으로서, 사전-초기화 프로세스 또는 로봇의 자율 동작 이전의 초기화 프로세스 동안, 상기 로봇에 대한 로우 리소스(lowresource) 프로세싱 작업과 외부 서버에 대한 하이 리소스 프로세싱 작업으로 프로세싱을 분할하는 단계; 로우 리소스 프로세싱 작업으로 상기 로봇을 초기화하는 단계, 상기 로우 리소스 프로세싱 작업은 상기 내부 지능을 제공하며;로봇의 자율 동작 동안, 상기 로봇은 내부 지능을 사용하고 그리고 외부 지능을 위해 상기 서버를 활용하지 않는 단계; 상기 로봇에 저장된 내부 지능을 위한 데이터는 사전구성된 기능들을 수행하는데 필요한 데이터만을 포함하는것을 특징으로 하는 프로그래밍 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서, 온보드 하드웨어 프로세싱 파워는 상기 내부 지능을 제공하는데 필요한 것만으로 구성되는 것을 특징으로 하는공개특허 10-2024-0142525-4-프로그래밍 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제10항에 있어서, 정의된 구내(premises) 내에서의 자율 이동을 위해 상기 로봇을 조정하는 단계를 더 포함하는 것을 특징으로 하는 프로그래밍 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제10항에 있어서, 상기 로우 리소스 프로세싱 작업은 기능적 피처들을 포함하고, 상기 기능적 피처들 각각은 자체 격리된 가상 환경 컨테이너에서 동작하는 것을 특징으로 하는 프로그래밍 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제12항에 있어서, 상기 로우 리소스 프로세싱 작업 중 하나는 상기 기능적 피처들을 동작시키기 위해 독립적인 스크립트를 실행하는 것을 특징으로 하는 프로그래밍 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제10항에 있어서, 상기 기능적 피처들은 내비게이션, 이미지 프로세싱, 오디오 프로세싱 또는 비디오 프로세싱을 포함하는 것을특징으로 하는 프로그래밍 방법."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "미리 정의된 일련의 작업들을 수행하는 로봇으로서, 각각의 작업은 여러 피처 요소들을 가지며, 상기 로봇은, 상기 로봇의 고유 ID 번호에 따라, 스크립트 및 상기 고유 ID 번호와 연관된 여러 가상 컨테이너들을 상기 로봇과 통신하는 서버로부터 다운로드하는 스크립터 -상기 여러 가상 컨테이너들 중 하나는 상기 여러 가상 컨테이너들을 지원하는 동작 데이터의 서브세트를 다운로드하도록 상기 서버와 통신하는 라우터이고, 상기 여러 가상컨테이너들 중 다른 하나는 상기 스크립트에 따라 상기 로봇을 제어하는 컨트롤러이고, 나머지 가상 컨테이너들각각은 상기 여러 피처 요소들 중 하나를 수행하며-; 및 상기 동작 데이터의 서브세트를 저장하는 로봇 데이터베이스 를 포함하고, 상기 스크립터는 상기 로봇이 상기 서버와 온라인 상태일 때 작동하고, 상기 컨트롤러는 상기 로봇이 상기 서버와 오프라인 상태일 때 작동하는 것을 특징으로 하는 로봇."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서, 상기 여러 피처 요소들은 시각(vision), 이동성(mobility), 스피치 및 오디오 중 적어도 하나를 포함하는 것을특징으로 하는 로봇."}
{"patent_id": "10-2024-7029168", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제16항에 있어서, 상기 여러 가상 컨테이너들 중 하나는 상기 로봇과 상기 로봇에 의한 서비스 수신자 사이의 인터페이스인 것을특징으로 하는 로봇."}
{"patent_id": "10-2024-7029168", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "내부 인공지능을 갖추고 이를 사용하며 외부 인공지능에 연결되지 않은 경우 자율적으로 작동하는 지능형 다기능 (multi-function) 로봇을 사용하는 방법이 제공되며, 상기 방법은, 사전-초기화 프로세스 또는 로봇의 자율 동작 이전의 초기화 프로세스 동안 상기 로봇이 온라인 상태일 때 상기 로봇이 특정 작업을 수행하는데 필요한 기능 (뒷면에 계속)"}
{"patent_id": "10-2024-7029168", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "일반적으로, 본 발명은 로봇 분야에 관한 것이며 특히 오프라인에서 동작하는 로봇에 관한 발명이다. 관련 출원들에 대한 상호 참조 본 출원은 2022년 1월 30일에 출원된 미국 가특허 출원 63/304,621, 2022년 2월 15일에 출원된 63/310,120, 2022년 9월 29일에 출원된 63/411,156 및 2023년 1월 2일에 출원된 63/478,170에 대한 우선권 및 이익을 주장 하며, 이들 모두는 본 출원에 참조로서 포함된다."}
{"patent_id": "10-2024-7029168", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "본 발명을 더 잘 이해하려면 로봇의 작동을 용이하게 하는 용어와 기본 요소를 이해하는 것이 유용하다. 현대의 로봇은 일반적으로 2개의 카테고리에 속한다. 첫 번째 카테고리는 일반적으로 조립 라인에서 사용되는 매우 특정적인 기능을 가진 비지능형 로봇이다. 또한, 지능형이고, 범용성이며, 때로는 모바일이기도 한 로봇이 존재하며, 이는 인공 지능(가령, 클라우드 인공 지능)으로부터 파생된 지능 또는 얼굴 및 객체 인식, 오디오 인 식 등과 같은 동작 알고리즘의 프로세싱으로부터 파생된 지능을 사용할 수 있다. 지능형 로봇은 일상생활에 점점 더 많은 부분을 차지하고 있다. 이러한 로봇은 (예를 들어) 의료 지원용으로, 레스토랑의 웨이터로서, 테이크어웨이 배달 서비스 등에서 이용된다. 이러한 로봇은 일반적으로 데이터와 기능을 저장하는 서버에 의해 제어된다. 이러한 로봇을 작동하는데 필요한 프로세싱 능력은 일반적으로 매우 크고 고가의 프로세서를 필요로 한다. 서버에 의해 제어되거나, 또는 데이터, 리소스 및 서비스에 액세스하기 위해서, 상기 로봇은 블루투스, 인터넷 등과 같은, 서버와의 통신을 위한 소정 형태의 통신 수단을 가져야만 한다. 지능형 온라인 로봇은 일반적으로 매우 많은 큰 분량의 데이터에 액세스할 수 있다. 이러한 데이터를 사용하면 항상 최신 상태를 유지하기 위해 필요한 동작 데이터 또는 기타 데이터를 안정적으로 가져올 수 있다. 이러한 능력이 없으면 복잡한 기능을 가진 로봇을 오프라인에서 작동시키는 것이 매우 어렵거나 심지어 불가능하다. 사 용 중에 로봇이 서버와 항상 통신하지 않을 수도 있다는 것을 알 수 있다. 예를 들어, 정전으로 인해 Wi-Fi 연 결이 차단되어, 로봇이 오프라인이 될 수 있다. 또는, 로봇은 서버와의 통신 범위를 벗어날 수도 있다. 따라서, 로봇이 오프라인에서 자율적으로 실행하기 위해서, 서버에 의해 제공되는 모든 기능을 로봇상에서 로컬로 제공 하는 것은, 크고 값비싼 프로세서와 저장 용량을 필요로 한다. 또한 이러한 모든 기능은, 독립적으로 작동하기 위해 결정을 내리는데 필요한 지능을 지원하기 위해 무거운(heavy) 동작 알고리즘을 실행시키는 프로세싱 능력 을 포함할 수 있다. 또한, 오프라인 상태에서도 사용가능한 모든 기능을 갖추기 위하여, 개별 로봇 상에 전체 서버 프로세싱 유닛을 장착하는 것은 실용적이지 않을 뿐만 아니라 비용-효율적이지도 않다. 본 발명을 실행하기 위해, 프로세서는 일반적으로 서버를 사용하여 작동하는 유사한 로봇의 평균 프로세서보다 크고 비용이 많이 드는데, 왜냐하면 서버는 로봇의 프로세서가 일반적으로 부담하는 힘든 프로세싱의 많은 부분 을 오프로드할 수 있기 때문이다. 본 명세서에 공개된 로봇은 오프라인으로 작동하기 때문에 그렇게 할 수 없다. 따라서, 본 발명의 로봇의 프로세서는 평균적인 서버 프로세서보다 훨씬 작은데, 전체 서버 프로세싱 유 닛을 임의의 합리적인 사이즈 또는 비용 효율성으로 각각의 로봇에 장착할 수 없기 때문이다. 따라서, 프로세서 는 평균적인 온라인 로봇의 그것보다 크지만, 평균적인 서버 프로세서보다는 작다. 따라서, 산업 및 관련 분야에서는, 외부 서버에서 이용가능한 프로세서, 데이터, 정보 및 ASI를 활용하지 않고 도, 로봇이 오프라인에서 효율적이고 효과적인 방식으로 자율적으로 동작할 수 있게 하는 장치 또는 시스템에 대한 요구가 존재한다."}
{"patent_id": "10-2024-7029168", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "이러한 목적 및 기타 목적을 달성하기 위해, 본 발명에 따른 디바이스는 로봇이 외부 서버에서 이용가능한 프로 세서, 데이터, 정보 및 ASI를 활용하지 않고도 오프라인에서 자율적으로 동작할 수 있게 한다. 따라서, 이러한 목적 및 기타 목적을 달성하기 위해, 여기에 공개된 발명은 내부 인공지능을 갖추고 이를 사용 하며 외부 인공지능에 연결되지 않은 경우 자율적으로 작동하는 지능형 다기능(multi-function) 로봇을 사용하 는 방법이며, 상기 방법은, 사전-초기화 프로세스 또는 로봇의 자율 동작 이전의 초기화 프로세스 동안 상기 로 봇이 온라인 상태일 때 상기 로봇이 특정 작업을 수행하는데 필요한 기능 및 데이터를 서버로부터 다운로드하는 단계, 로봇의 자율 동작 동안, 로봇은 외부 서버나 외부 인공지능을 사용하지 않으며; 로봇 자체에 기본적으로 (natively) 있는 소프트웨어를 실행하는 단계, 상기 소프트웨어를 프로세싱하는 하드웨어는 로봇 자체에 있으며, 상기 로봇에 저장된 데이터는 사전구성된(preconfigured) 기능들을 수행하는데 필요한 데이터만을 포함 하며; 상기 사전구성된 기능들을 수행하는데 필요한 것만을 포함하도록 온보드 하드웨어 프로세싱 파워를 제한 하는 단계; 및 정의된 구내(premises) 내에서의 자율 이동을 위해 상기 로봇을 조정하는 단계를 포함한다. 바람직한 실시예에서, 로봇은 설계된 작업 또는 작업들만을 수행하도록 초기화된다. 바람직하게는, 사전 구성된 기능은 인공지능(AI), 사용자들과의 통신, 내비게이션, 사용자 추적, 음성 및 오디오 인식을 통한 개별 사용자 인식, 맵 생성을 포함하는 그룹으로부터 선택된다. 본 발명의 다른 측면에 따르면, 본 발명은 자율 이동이 가능하고 여러 기능 모듈들을 포함하는 지능형 다기능 로봇으로 구성되며, 브레인, 라우터 및 각 모듈의 기능적 피처들은 자체 격리된 가상 환경 컨테이너에서 동작한 다. 또한, 각각의 모듈은 자체 격리된 가상 환경 컨테이너에서 패키징되고 및 배포된 독립적인 스크립트를 실행 한다. 상기 기능적 피처들은 내비게이션, 이미지 프로세싱, 오디오 프로세싱 또는 비디오 프로세싱을 포함한다. 본 발명의 다른 측면에 따르면, 본 발명은 다수의 로봇들을 관리하는 서버를 포함하고, 각각의 로봇은 지정된 일련의 작업들을 수행하며, 상기 서버는, 복수의 로봇들 각각에 대한 고유한 로봇 ID에 따라 로봇별 작업들 및 관련 스크립트들을 나열하는 로봇 관리 테이블; 상기 스크립트들을 실행하는데 필요한 동작 데이터를 저장하는 동작 데이터베이스; 상기 동작 데이터를 획득 및 업데이트하기 위한 적어도 하나의 알고리즘을 실행하는 프리프 로세서; 및 상기 서버가 특정 로봇과 네트워크로 통신할 때, 고유 로봇 ID 및 관련된 스크립트들에 따라 상기 복수의 로봇들 중 상기 특정 로봇을 초기화하는 초기화기(initializer)를 포함한다. 본 발명의 또 다른 측면은 내부 지능을 사용하고 외부 서버에 연결되지 않은 경우 자율적으로 기능하는 지능형 다작업(multi-task) 로봇을 프로그래밍하는 방법에 관한 것으로서, 상기 방법은: 사전-초기화 프로세스 또는 로 봇의 자율 동작 이전의 초기화 프로세스 동안, 상기 로봇에 대한 로우 리소스(low resource) 프로세싱 작업과 외부 서버에 대한 하이 리소스 프로세싱 작업으로 프로세싱을 분할하는 단계; 로우 리소스 프로세싱 작업으로 상기 로봇을 초기화하는 단계, 상기 로우 리소스 프로세싱 작업은 상기 내부 지능을 제공하며; 로봇의 자율 동 작 동안, 상기 로봇은 내부 지능을 사용하고 그리고 외부 지능을 위해 상기 서버를 활용하지 않는 단계; 상기 로봇에 저장된 내부 지능을 위한 데이터는 사전구성된 기능들을 수행하는데 필요한 데이터만을 포함한다. 바람직하게는, 온보드 하드웨어 프로세싱 능력은 상기 내부 지능을 제공하는데 필요한 것만으로 구성된다. 나아 가, 로봇은 정의된 구내 내에서 자율적인 이동하도록 조정된다. 로우 리소스 프로세싱 작업은 각각 자체 격리된 가상 환경 컨테이너에서 동작하는 기능적 피처들을 포함한다. 로우 리소스 프로세싱 작업 중 하나는 상기 기능 적 피처들을 동작시키기 위해 독립적인 스크립트를 실행한다. 상기 기능적 피처들은 내비게이션, 이미지 프로세 싱, 오디오 프로세싱 또는 스피치 프로세싱을 포함한다. 본 발명의 다른 측면에 따르면, 본 발명은 미리 정의된 일련의 작업들을 수행하는 로봇에 관한 것으로, 각각의 작업은 여러 피처 요소들을 가지며, 상기 로봇은, 상기 로봇의 고유 ID 번호에 따라, 스크립트 및 상기 고유 ID 번호와 연관된 여러 가상 컨테이너들을 상기 로봇과 통신하는 서버로부터 다운로드하는 스크립터, 상기 여러 가 상 컨테이너들 중 하나는 상기 여러 가상 컨테이너들을 지원하는 동작 데이터의 서브세트를 다운로드하도록 상 기 서버와 통신하는 라우터이고, 상기 여러 가상 컨테이너들 중 다른 하나는 상기 스크립트에 따라 상기 로봇을 제어하는 컨트롤러이고, 나머지 가상 컨테이너들 각각은 상기 여러 피처 요소들 중 하나를 수행하며; 및 상기 동작 데이터의 서브세트를 저장하는 로봇 데이터베이스를 포함하고, 상기 스크립터는 상기 로봇이 상기 서버와 온라인 상태일 때 작동하고, 상기 컨트롤러는 상기 로봇이 상기 서버와 오프라인 상태일 때 작동한다. 로봇이 작동하는데 필요한 개별 프로세싱 능력과 데이터 저장에 필요한 메모리는, 로봇이 전용 서버와 온라인 상태일 때 특정 작업을 수행하는데 필요한 기능과 데이터를 다운로드하는 초기화 프로세스를 사용함으로써, 현 실적으로 감소될 수 있다. 로봇은 설계된 작업 또는 작업들만을 수행하도록 초기화될 수 있다. 따라서, 작업에 필요한 데이터와 명령들만이 다운로드되므로, 더 적은 프로세싱 능력을 필요로 하고 따라서 더 저렴한 프로세서 와 메모리 유닛이 이용될 수 있다. 로봇과 서버 간의 지속적인 핑(ping) 동작으로 인하여, 로봇이 온라인 상태 라고 판단될 때 서버와 로봇 간의 양방향 업데이트가 허용될 수 있다. 따라서, 제한된 프로세싱 능력으로 실행될 수 있는 기능 최적화를 수용하도록 소프트웨어를 재설계함으로써, 데이터 저장 관점과 소프트웨어 측면에서 로봇이 설계될 수 있다. 이러한 작동 방식은 특히 노인을 대상으로 하는 돌봄 분야에서 데이터 보안, 신뢰성 및 사용성을 증가시킬 수도 있다. 노인의 경우, 적절한 채택(adoption) 및 사용 사례에 있어서 문제가 있는 것이 일반적이다. 기술에 그렇 게 정통하지 않은 노인은 로봇과의 신뢰 관계를 구축하는데 도움이 되는 꾸준하고 안정적인 사용 능력이 필요할 수 있다."}
{"patent_id": "10-2024-7029168", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "다음의 자세한 설명에서, 본 발명에 대한 철저한 이해를 제공하기 위해 수많은 구체적인 세부 사항들이 제시된 다. 그러나, 당업자는 이러한 구체적인 세부 사항이 없이도 본 발명이 실행될 수 있음을 이해할 것이다. 다른 경우에, 본 발명을 모호하게 하지 않기 위해 잘 알려진 방법, 절차 및 구성 요소는 자세히 설명되지 않았다. 기본적인 실시예에서, 본 발명은 내부 인공 지능을 갖추고 이를 사용하며 그리고 외부 인공지능에 연결되지 않 은 경우 자율적으로 동작하는 지능형 다기능 로봇을 이용하는 방법을 포함하며, 상기 방법은, 사전-초기화 프로 세스 또는 로봇의 자율 동작 이전의 초기화 프로세스 동안 상기 로봇이 온라인 상태일 때 상기 로봇이 특정 작 업을 수행하는데 필요한 기능 및 데이터를 서버로부터 다운로드하는 단계; 로봇의 자율 동작 동안, 로봇은 외부 서버나 외부 인공지능을 사용하지 않으며; 로봇 자체에 기본적으로(natively) 있는 소프트웨어를 실행하는 단계, 상기 소프트웨어를 프로세싱하는 하드웨어는 로봇 자체에 있으며, 상기 로봇에 저장된 데이터는 사전구성 된(preconfigured) 기능들을 수행하는데 필요한 데이터만을 포함하고; 상기 사전구성된 기능들을 수행하는데 필 요한 것만을 포함하도록 온보드 하드웨어 프로세싱 파워를 제한하는 단계; 및 정의된 구내(premises) 내에서의 자율 이동을 위해 상기 로봇을 조정하는 단계를 포함한다. 바람직한 실시예에서, 상기 로봇은 설계된 작업(task) 또는 작업들만 수행하도록 초기화된다. 바람직하게는, 상 기 사전구성된 기능들은, 인공지능(AI), 사용자들과의 통신, 내비게이션, 사용자 추적, 음성 및 오디오 인식을 통한 개별 사용자 인식, 맵 생성을 포함하는 그룹으로부터 선택된다. 본 발명의 다른 양상에 따르면, 본 발명은 자율 이동이 가능하고 여러 기능 모듈들을 포함하는 지능형 다기능 로봇을 포함하며, 여기서 브레인, 라우터 및 각 모듈의 기능적 피처들은 자체 격리된 가상 환경 컨테이너에서 동작한다. 또한, 각각의 모듈은 자체 격리된 가상 환경 컨테이너에서 패키징되고 및 배포된 독립적인 스크립트를 실행한다. 기능적 피처들은 내비게이션, 이미지 프로세싱, 오디오 프로세싱 또는 비디오 프로세싱을 포함한 다. 본 발명의 다른 양상에 따르면, 본 발명은 다수의 로봇들을 관리하는 서버를 포함하며, 각각의 로봇은 지정된 일련의 작업들을 수행하고, 상기 서버는, 복수의 로봇들 각각에 대한 고유한 로봇 ID에 따라 로봇별 작업들 및 관련 스크립트들을 나열하는 로봇 관리 테이블; 상기 스크립트들을 실행하는데 필요한 동작 데이터를 저장하는 동작 데이터베이스; 상기 동작 데이터를 획득 및 업데이트하기 위한 적어도 하나의 알고리즘을 실행하는 프리프 로세서; 및 상기 서버가 특정 로봇과 네트워크로 통신할 때, 고유 로봇 ID 및 관련된 스크립트들에 따라 상기 특정 로봇을 초기화하는 초기화기(initializer)를 포함한다. 본 발명의 다른 양상은 내부 지능을 사용하고 외부 서버에 연결되지 않은 경우 자율적으로 기능하는 지능형 다 작업(multi-task) 로봇을 프로그래밍하는 방법을 포함하며, 상기 방법은: 사전-초기화 프로세스 또는 로봇의 자 율 동작 이전의 초기화 프로세스 동안, 상기 로봇에 대한 로우 리소스(low resource) 프로세싱 작업과 외부 서 버에 대한 하이 리소스 프로세싱 작업으로 프로세싱을 분할하는 단계; 로우 리소스 프로세싱 작업으로 상기 로 봇을 초기화하는 단계, 상기 로우 리소스 프로세싱 작업은 상기 내부 지능을 제공하며; 로봇의 자율 동작 동안, 상기 로봇은 내부 지능을 사용하고 그리고 외부 지능을 위해 상기 서버를 활용하지 않는 단계를 포함하고, 상 기 로봇에 저장된 내부 지능을 위한 데이터는 사전구성된 기능들을 수행하는데 필요한 데이터만을 포함한다. 바람직하게는, 온보드 하드웨어 프로세싱 파워는 상기 내부 지능을 제공하는데 필요한 것만으로 구성된다. 또한, 상기 로봇은 정의된 구내(premises) 내에서의 자율 이동을 위해 조정된다. 로우 리소스 프로세싱 작업은 기능적 피처들을 포함하고, 상기 기능적 피처들 각각은 자체 격리된 가상 환경 컨테이너에서 동작한다. 로우 리 소스 프로세싱 작업 중 하나는 상기 기능적 피처들을 동작시키기 위해 독립적인 스크립트를 실행한다. 상기 기 능적 피처들은 내비게이션, 이미지 프로세싱, 오디오 프로세싱 또는 비디오 프로세싱을 포함한다. 본 발명의 다른 양상에 따르면, 본 발명은 미리 정의된 일련의 작업들을 수행하는 로봇을 포함하고, 각각의 작 업은 여러 피처 요소들을 가지며, 상기 로봇은 다음을 포함한다: 상기 로봇의 고유 ID 번호에 따라, 스크립트 및 상기 고유 ID 번호와 연관된 여러 가상 컨테이너들을 상기 로봇과 통신하는 서버로부터 다운로드하는 스크립 터 -상기 여러 가상 컨테이너들 중 하나는 상기 여러 가상 컨테이너들을 지원하는 동작 데이터의 서브세트를 다 운로드하도록 상기 서버와 통신하는 라우터이고, 상기 여러 가상 컨테이너들 중 다른 하나는 상기 스크립트에 따라 상기 로봇을 제어하는 컨트롤러이고, 나머지 가상 컨테이너들 각각은 상기 여러 피처 요소들 중 하나를 수 행하며-; 및 상기 동작 데이터의 서브세트를 저장하는 로봇 데이터베이스를 포함하고, 상기 스크립터는 상기 로 봇이 상기 서버와 온라인 상태일 때 작동하고, 상기 컨트롤러는 상기 로봇이 상기 서버와 오프라인 상태일 때 작동한다. 도 1은 기본적인 동작 소프트웨어 아키텍처를 보여준다. 로봇 프로세서(들): 프로세서는 산술, 논리, 입출력(I/O) 및 기타 기본 명령들과 같은 명령들을 관리한다. 바람 직한 실시예에서 사용되는 프로세서는 비제한적인 일례로서 1 Xavier 및 1 Nano이지만, 하나의 프로세서 또는 여러 프로세서를 포함하여 대안적인 구성들 및 컴포넌트들도 작동할 것이다. 임의의 회사의 프로세서들 또는 맞 춤형 프로세서들도 작동할 수 있다. 본 발명을 실행하기 위해, 프로세서들은 서버를 사용하여 작동하는 유사한 로봇의 평균 프로세서보다 일반적으 로 더 크고 더 고가인데, 왜냐하면 서버는 로봇의 프로세서들에게 일반적으로 할당되는 힘든(strenuous) 프로세 싱의 많은 부분을 오프로드할 수 있기 때문이다. 본 명세서에 개시된 로봇은 오프라인으로 작동하므로 이러한 것이 적용될 수 없다. 따라서, 본 발명의 로봇의 프로세서는 평균적인 서버 프로세서보다 훨씬 작은데, 이는 전 체 서버 프로세싱 유닛을 임의의 합리적인 사이즈 또는 비용 효율성으로 각각의 로봇에 장착할 수 없기 때문이 다. 따라서, 프로세서는 평균적인 온라인 로봇의 그것보다 크지만, 평균적인 서버 프로세서보다는 작다. 또한, 일반적으로 로봇의 프로세서에 할당되는 힘든 프로세싱의 많은 부분이 오프로드된다. 따라서, 서버는 동 작 중에 사용되지 않지만, 본 명세서에 개시된 사전 초기화 및 초기화 시스템을 통해 자율 동작 이전에 서버가 이용된다. 사전 초기화 프로세스 및 초기화 프로세스를 사용함으로써, 프로세싱을 더 빠른 시점으로 오프로드하 고 작동 중에 이점을 얻을 수 있다. 라우터: 라우터는 2개 이상의 패킷 교환 네트워크들 또는 서브 네트워크들을 연결하는 디바이스이다. 라우터는 두 가지 주요한 기능들을 제공한다. 데이터 패킷들을 의도된 IP 어드레스들로 포워딩함으로써 이러한 네트워크 들 사이에서 트래픽을 관리하고 그리고 여러 디바이스들이 동일한 인터넷 연결을 사용할 수 있도록 한다. 라우터는 서버가 준비한 데이터를 끌어내야만(pull down) 한다. 데이터를 받으면, 이것을 브레인으로 전송하고, 브 레인이 나머지 작업을 수행한다. 또한, 이하에서 설명되는 바와 같이, 라우터는 IAmAlive PING 신호를 전송하는 역할도 수행한다. 라우터가 내린 결정이나 수행한 작업에 대한 모든 참조는 라우터 자체의 지능 또는 의사 결정 능력을 참조할 수도 있고, 또는 대안적으로는 라우터가 브레인이나 스크립터와 같은 다른 도커(docker)에서 시 작된 실행가능한 커맨드들을 수행하는 것을 참조할 수도 있다. 브레인: 로봇은 감각들 및 능력들로 구성되어 있다. 이들은 다음을 포함할 수 있지만 이에 국한되지 않는다: 음성 인식 자연어 프로세싱(NLP) 시각(vision) 이동할 수 있는 능력 말할 수 있는 능력 로봇 스크린/얼굴에 있는 사용자 인터페이스. 브레인의 역할은 이러한 감각들과 능력들을 관리하고 로봇이 기능할 수 있는 '세상(world)'을 제공하는 것이다. 브레인은 임의의 주어진 로봇의 기능적 사양(functional specification)을 이행한다. 예를 들어, 의료용(clinic) 어시스턴트(보조) 로봇에서, 로봇의 역할은 환자를 등록하고, 생체 신호(vitals)를 측정하고, 환자를 검진 장소로 안내하고, 검진하는 동안 의사를 돕는 것이다. 이러한 일례에서 브레인은 로봇이 이러한 기능적 사양을 이행할 수 있도록 위에서 설명한 모든 컴포넌트들을 관리한다. 브레인은 로봇이 존재할 수 있는 폐쇄되고 정의된 세계를 생성한다. 로컬 데이터베이스: 데이터베이스는 전자적으로 저장되고 액세스되는 데이터의 조직화된 컬렉션이다. 간단히 말 해서, 로컬 데이터베이스는 로봇이 로봇 자체에서 액세스할 수 있는 데이터베이스이다. 예를 들어, 메모리 모듈, 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD) 등이다. 초기화 전에, 로봇에 있는 임의의 기존 데이터나 소프트웨어는 로컬 데이터베이스에 저장된다. 로봇의 초기화 단계에서, 로봇은 서버에 연결하고, 서버 데이터베이스로부터 소프트웨어와 데이터의 서브세트를 다운로드하여, 이를 로컬 데이터베이스에 로컬로 저장한다. 로컬 데이터베이스는 작동에 필요한 피처들에 대한 정보와 함께 데이터를 보관하며, 피처들에 의해서 직접 액세스될 수 있다. 임의의 시점에서 로봇이 핸들링하는 모든 데이터나 소프트웨어는 로컬 데이터베이스에 저장될 수 있다. MQTT 브로커(로컬): 업계에서 알려진 MQTT 브로커(https://mqtt.org/ 참조)는 MQTT 클라이언트가 통신할 수 있 도록 하며, 특히 이 경우에는 로컬 MQTT 브로커와 통신할 수 있도록 한다. 이것은 자체 호스팅(Self-Hosted) MQTT 브로커 또는 관리형 MQTT 브로커가 될 수 있다. 피처들: 피처들의 세트는 작동을 달성해야만 하는 로봇의 기능들의 세트이다. 여기에는 다음이 포함될 수 있다: 내비게이션: 현재 ROS에서 작동 중이다. 의도와 지능을 가지고 환경 주변에서 자율적으로 이동할 수 있는 능력 이다. 이미지 프로세싱: 객체 인식, 얼굴 인식, OCR(광학 문자 인식) 등을 담당한다. 오디오 프로세싱: 오디오 인식, 음성 매칭, NLP, STT, TTS 등을 담당한다. 페이스업(faceup): UX/UI, 디스플레이, 터치 스크린, 사용자 입력에 대한 응답 등을 담당한다. 피처들은 작동하는데 필요한 데이터를 로컬 데이터베이스로부터 획득한다. 획득된 피처들의 일례는, 네비게이션: 지도, 위치 이름; 이미지 프로세싱, 인식된 사람과 사물; 오디오 프로세싱, 인식된 음성 및 단어; 및 페이스앱(FaceApp), 스크린이다. 스크립터: 스크립터는 로봇의 피처들을 구성하는 도커의 다운로드 및 실행을 관리하는 역할을 한다. 브레인, 라우터 및 각각의 피처는 도커라고 지칭되는 가상 환경 컨테이너에서 실행된다. 각각의 모듈이 로봇의 머신 상에서 독립적인 스크립트로 실행되는 대신에, 모듈들 및 모듈들의 모든 종속성들(dependencies)(예를 들 어, 외부 라이브러리)은 자체 격리된 컨테이너에서 패키징되어 배포된다. 이를 통해 스크립터는 로봇의 머신에 서 직접 실행되는 단일 스크립트를 생성하여, 모든 로봇 모듈의 배포 및 버전 콘트롤을 관리할 수 있다. 도커커맨드를 사용하면, 예를 들어, 필요에 따라 모듈을 종료(shut down)하거나 파워 온할 수 있으며 또는 도커의 현재 버전이 최신 버전인지를 확인하고 필요한 경우 업데이트를 수행할 수 있다. 업데이트가 서버로부터 이용가 능한 경우, 서버는 라우터에 핑(ping)을 보내고, 라우터는 업데이트될 도커의 이름이 포함된 메시지를 스크립터 로 보낸다. 이후, 스크립터는 API(https://aws.amazon.com/what-is/api/ 참조) 호출을 사용하여, 업데이트된 도커를 서버로부터 다운로드한다. 도커가 다운로드되면, 스크립터는 브레인과 통신하여 업데이트된 도커를 재시 작할 최적의 시기를 결정한다. 로봇 서버: 서버는 네트워크를 통해 클라이언트라고 알려진 다른 컴퓨터에게 리소스, 데이터, 서비스 또는 프로 그램을 제공하는 컴퓨터 또는 시스템이다. 서버는 또한 관리형 포털(administrative portal)이며, 사용자 인터페이스를 통해, 해당 시설 관리자는 자신의 데이터를 관리하는데 사용할 수 있다(클리닉의 일례로서, 관리자는 포털을 통해 사용자, 사용자 정보 및 상태 (예: 의사 및 간호사)를 추가할 수 있다. 이후, 의사는 교대가 되면 검사실에 배정될 수 있다). 또 다른 일례예는 얼굴 인식 알고리즘 전체이다. 모든 힘든 작업은 서버 관리 포털에 의해 수행된다. 사용자는 사용자의 사진을 업로드한다. 그런 다음 서버는 해당 사진을 프로세싱하여, 로봇에서 얼굴 인식에 사용될 수 있 는 벡터로 변환한다. 이러한 작업이 완료된 이후, 이러한 벡터는 초기화 또는 업데이트 상태 동안 각 로봇에 다 운로드된다. MQTT 브로커(서버): 바람직한 실시예에서는, AWS IOT MQTT(아마존 웹 서비스: Amazon Web Services, 사물 인터 넷: IOT) 브로커가 활용되지만 다른 MQTT 브로커도 대안적으로 사용될 수 있다. 백엔드(Backend): 간단히 말해서 백엔드는 기술적 프로세스가 발생하는 곳이다. \"백-엔드 개발은 백그라운드에 서 웹사이트와 앱을 구동하는 서버 측 로직을 개발하는 것을 말한다. 여기에는 데이터베이스, 서버 및 애플리케 이션을 구축하는데 필요한 모든 코드가 포함된다.\" 사전-초기화 및 업데이트 프로세싱이 여기에서 발생한다. 프런트엔드: 간단히 말해서 프런트엔드는 사용자 상호작용이 발생하는 곳이다. 사전 초기화 및 업데이트된 정보 입력은 여기에서 사용자 인터페이스를 통해 발생한다. 서버 데이터베이스: 전자 데이터의 조직화된 컬렉션이다. 서버 데이터베이스에 저장된 데이터는 얼굴, 사람, 권 한 상태(authority status), 객체, 지도, 위치 이름, 인식된 단어 및 구문, 고객 데이터 또는 로봇과 그 기능이 적절하게 작동하는데 필요하거나 도움이 되는 기타 로봇 동작 데이터를 포함하지만 이에 국한되지는 않는다. 사용자 인터페이스: 웹 페이지나 전화 앱의 포털 또는 사용자 인터페이스의 임의의 적절한 수단을 통해, 사용자 는 자신이 적합하다고 생각하는 대로 로봇이 제대로 작동하는데 필요한 개인화된 데이터를 입력한다. 데이터 설정 및 사전 초기화: 초기화 단계는 로봇에 요구되는/원하는/필요한 데이터 및 서버로부터 로봇으로 업 로드되는 고객으로부터의 요구되는/원하는/필요한 데이터를 갖는다. 이러한 데이터는 초기화 프로세스를 위해 준비되도록 서버에 미리 설치될 필요가 있다. 이러한 데이터 설정 또는 사전 설치 단계 동안, 당신은 로봇 표준 기능들 또는 고객이 요구하는 특정한 로봇 기능을 추가할 수 있으며, 그리고 예를 들어, 로봇 환경, 직원 (staff) 및 인식해야 하는 알려진 다른 로봇 사용자, 지도, 위치 이름, 로봇 환경 제한(예컨대, 계단, 물품 보 관실(custodial closet) 등에서는 로봇이 허용되지 않음됨) 등과 같은 고객의 요구 사항을 추가할 수 있다. 이 것은 특정한 순서가 없을 수도 있다. 비유적으로 말하면, 사전 설치 단계는 로봇 설치자와 고객 사이의 대화와 유사한바, 초기화 프로세스 동안 다운로드될 수 있는 임의의 기본 데이터 이외에도, 고객의 요구 및 필요에 맞 게 효과적으로 동작하기 위하여 로봇이 어떤 정보를 필요로 할 것인지에 대한 대화와 유사하다. 데이터가 선택 되어 수집되면(예를 들어, 안면 인식의 경우, 인식된 사용자들의 이미지들이 촬영될 필요가 있다), 이는 서버 프런트엔드에 의해서 사용자 인터페이스를 통해 업로드될 것이다. 프로세싱을 필요로 하는 모든 데이터는 서버 백엔드에서 프로세싱될 것이며 결과 데이터는 서버 데이터베이스에 저장된다. 각각의 로봇은 바람직하게는 고유한 로봇 ID를 부여받는다. 이후, 데이터의 위치가 고유한 로봇 ID(포인터 또는 구조체 목록과 같이 해당 기술 분야에서 알려진 표준적인 관행이 있지만 아직까지 구체적인 방법은 없음)에 링 크되어, 초기화가 발생할 준비가 된다. 로봇 ID는 반복되는 숫자와 같이 간단한 것을 사용하거나 또는 고유한 숫자를 생성하는 보다 복잡한 수단을 사용하여 고유할 수 있다. 참고: 항상 고유할 것인 로봇 ID와 달리, 초기 화 단계 동안 로봇에 다운로드되는 데이터는 고유하지 않을 수도 있다. 예를 들어, 로봇들이 동일한 환경에서 사용될 수도 있으므로 유사하거나 동일한 데이터를 다운로드하는, 2개의 서로 다른 고유한 로봇 ID를 갖는 2개 의 로봇을 구비한 고객이 존재할 수도 있다. 로봇 서버 통신: 서버와 로봇은 초기화, 업데이트 및 IAmAlive PING의 세 가지 상황에서 통신해야만 한다. 서로 통신하기 위해 로봇은 서버 통신 디바이스와 라우터를 포함한다. IAmAlive PING: 에코 요청 및 에코 재생 메시지를 사용하여 호스트의 도달가능성(reachability)을 체크하는데 사용된다. 핑 도구(ping tool)는 발신자와 호스트 간의 연결을 확인하는데 사용된다. 서버는, 서버에 연결된 로 봇들을 알아내기 위해, 로봇이 IAmAlive ping을 전송하도록 요구한다. 이러한 IAmAlive는 바람직하게는 5분마다 보낼 수 있지만 매시간, 10분, 1분, 1밀리초 등과 같이 다른 많은 시간 프레임도 가능한다. 이를 통해 서버는 업데이트 등과 같은 통신을 위해 연결된 모든 로봇들을 알 수 있다. 초기화: 프로세스는 로봇 브레인이 로컬 데이터베이스를 체크하는 것으로 시작한다. 로봇이 아직 초기화되지 않 았기 때문에 로컬 데이터베이스(DB)에는 주요 정보와 데이터가 없다. 이것은 브레인이 초기화 프로세스를 시작 하기 위한 트리거이다. 로봇은 자신의 고유한 로봇 ID를 사용하고, 라우터를 통해 서버에 연결한다. 라우터는 제공된 로봇 ID를 사용하여 API 요청을 수행하여 서버로부터 데이터를 수집하기 시작한다. 이러한 데이터의 일 부는 회사(company) ID를 포함하며, 회사 ID는 서버에 저장되고 그리고 로봇이 어떤 회사에 속하는지와 해당 선 단(fleet)의 로봇들에 링크되어야 하는 데이터세트들을 기술하는데 사용된다. 그런 다음, 라우터는 로봇 ID와 회사 ID를 사용하여 후속 API 호출을 수행하여 데이터 초기화 프로세스를 완료한다. 데이터 설정 프로세스로부 터 로봇 ID와 연관된 올바른 데이터를 이미 알고 있는 서버는 로봇 라우터를 통해 요청된 데이터를 로봇에 전송 한다. 로봇은 데이터를 다운로드하고 이러한 데이터를 로컬 데이터베이스에 저장한다. 이러한 데이터를 로봇이 갖게되 면, 로봇은 로컬 데이터베이스로부터 데이터에 로컬적으로 액세스할 수 있으며, 오퍼레이션 바 업데이트 (operation bar updates) 및 IAmAlive PING을 위해 서버가 더 이상 필요하지 않다. 업데이트들: 서버 측: 데이터 설정 상태에서 논의된 정보 또는 임의의 추가 데이터가 업데이트될 필요가 있는 경우, 업데이 트 프로세스가 발생한다. 업데이트된 데이터가 고객 데이터인 경우, 업데이트 프로세스는 먼저 고객이 사용자 인터페이스를 통해 시스템에 있는 임의의 데이터를 추가하거나 빼야함을 요구한다(예컨대, 새로운 직원이 합류 하여 얼굴 인식 사진들이 필요한 경우, 사용자가 그만두었기에 얼굴 인식이 더 이상 필요하지 않고 얼굴 인식 사진을 삭제하도록 요청되는 경우, 리모델링이 발생하는 경우, 지도와 위치 이름을 변경해야 하는 경우 등등). 이것은 데이터 설정 사전 초기화 단계와 유사할 것이다. 그런 다음 서버는 로봇 ID가 정보 업데이트의 범위에 속하는 모든 로봇들에게 업데이트가 필요하다는 것을 전체적으로 및 부분적으로 통지할 필요가 있을 것이다. IAmAlive ping 덕분에, 로봇은 어떤 로봇들이 현재 서버에 연결되어 있으며 그리고 이들 로봇들 중 어떤 로봇이 데이터 업데이트와 연관된 로봇 ID를 갖는지를 전체적으로 또는 부분적으로 알 수 있다. 다음으로, 서버는 현 재 서버에 연결되어 있는 모든 로봇들과 데이터 및/또는 소프트웨어 업데이트와 연관된 로봇 ID를 갖는 로봇들 에게 업데이트 메시지를 보낸다(그리고 결국 서버에 연결될 때 아직 서버에 연결되지 않은 모든 로봇들에 도달 한다). 서버 관리자는 업데이트가 언제 발생할지 또는 로봇의 내부 AI가 로봇이 서버에 연결되어 작업들 사이에 서 다운타임이 있는 지점에서 업데이트를 다운로드하거나 두 가지를 조합하여 업데이트를 다운로드할지 결정할 수 있다. 업데이트는 데이터베이스 상의 서버 데이터가 라우터를 통해 전송되어 로컬 데이터베이스 상에 로컬로 저장되게 할 것인바, 이는 초기화 프로세스와 유사하다. 로봇 측: AI 또는 상태 머신 시스템은 로봇이 현재 로봇에 설치되지 않은 코드 세트를 필요로 하거나 또는 상기 코드 세트에 의해 도움을 받을 수 있다라고 판단할 것이다. 이러한 트리거는 예를 들어 로봇의 성능이 임의의 시간에서 임계값 이하이거나 전체적 또는 평균적으로 설정된 횟수 이하인 경우 수행될 수 있다. 트리거는 작업 성능이 최적이 아니거나 또는 불완전하거나(incomplete) 또는 실패한 경우일 수 있다. 대안적으로, 트리거는 이 전 업데이트 이후에 많은 시간이 경과된 경우를 추가로 포함할 수 있다. 트리거의 일례는, 로봇이 네비게이션 중에 원하는 목적지에 도달하지 못하게 하는 장애물(blockage)을 만나는 경우 또는 스피치 혹은 음성 인식에서 반복적으로 실패하는 경우를 포함할 수 있다. 로봇은 서버 측에서 이용될 수도 있는 로봇 측에 필요한 추가 스 크립트 또는 도커, 또는 일반 정보가 있는지를 자체적으로 판단할 수 있다. 로봇은 인터넷에 연결되거나 다음에 인터넷에 연결될 때 서버에 요청을 시작하여 서버로부터 업데이트를 수신할 수 있다. 서버로부터 다운로드하기 위한 API 호출이 이전에 설치된 코드의 업데이트된 버전 외에도 새로운(brand-new) 코드에 대한 정보를 포함할 수 있다는 점을 제외하면, 스크립터 또는 라우터는 서버 측 업데이트에 대해 설명된 것과 유사한 프로세스에서 상기 코드 및/또는 데이터를 다운로드할 수 있다. 이후, 스크립터와 브레인은 로봇을 재부팅할 최적의 시간을 결정하기 위해 통신할 수 있다. 컴포넌트 연결 목록: (중복 없음) 라우터 - 로컬 DB: 라우터는 로컬 DB를 설정하고 관리한다. 라우터는 API 호출을 위한 초기화 중에 로컬 DB에서 로봇 ID를 가져올 수 있다. MQTT 통신의 경우, 라우터는 서버 DB로부터 로봇 ID와 회사 ID를 가져온다. 라우터 는 서버와 로봇 프로세서 사이의 중개자이며, 여기서 데이터는 로컬 DB에 업로드되고, 상기 데이터는 라우터, 브레인 및 피처들에 의한 액세스를 위해 저장된다. 라우터 - MQTT 브로커(로컬): 라우터는 로컬 MQTT 브로커를 사용하여 브레인 및 스크립터와 통신한다. 라우터는 로컬 DB가 업데이트되었음을 브레인에게 알려주고, 환자 등록 양식(patient registration forms)을 브레인으로 전송하고, 재부팅 명령을 전송하고(재부팅 명령은 서버에서 오고, 브레인이 재부팅을 실행함), 브레인과 함께 \"I am alive\"를 실행한다. 이것은 또한 스크립터에게 도커 소프트웨어를 업데이트하라고 알려준다. 브레인은 로 컬 DB가 아직 설정되지 않은 것을 확인하면 라우터에 초기화 커맨드를 전송한다. 스크립터 - MQTT 브로커(로컬): 스크립터는 MQTT 브로커를 사용하여 라우터 및 브레인과 통신하여 새로운 도커 를 다운로드하고 로봇을 재부팅할 시기를 파악한다. 라우터는 스크립터에게 서버로부터 새로운 도커가 언제 이 용가능한지를 알려주고, 브레인은 스크립터에게 로봇을 재부팅할 준비가 되었을 때를 알려준다. 스크립터 - 로컬 DB: 로봇이 부팅되면 스크립터는 로컬 DB에 액세스하여 도커가 초기화되었는지를 확인한다. 그 렇지 않은 경우, 스크립터는 초기화를 시작한다. 초기화하는 동안 스크립터는 로컬 DB에 액세스하여 로봇 ID를 획득하며, 로봇 ID는 API 호출을 수행하는데 필요하다. 스크립터는 다운로드한 소프트웨어를 로컬 DB에 저장할 수 있다. 스크립터- 서버 백엔드: 스크립터가 로봇을 위한 새로운 소프트웨어를 다운로드할 때마다, 스크립터는 API 호출 을 통해 서버 백엔드에 액세스한다. 초기화하는 동안 스크립터는 서버에 로봇 ID를 제시하고, 이러한 로봇 ID에 대해 서버는 연관된 피처 세트를 이미 가지며, 서버는 스크립터에게 다운로드하도록 지시한다. 라우터 - MQTT 브로커(서버): 라우터는 서버의 MQTT 브로커를 사용하여 업데이트 통지와 브레인에 전달하는 데 이터를 수신한다. 업데이트 통지는 로컬 DB, 소프트웨어에 대한 것일 수 있으며 데이터는 등록 양식에 대한 것 일 수 있다. 재부팅 커맨드도 또한 서버 MQTT를 통해 전송된다. 라우터 - 서버 백엔드: \"I am alive\"에 대한 API 호출이 수행되고 라우터가 로봇의 로컬 DB에 저장한 데이터를 검색한다. 라우터는 서버 백엔드를 통해 서버에 새로운 데이터를 업데이트할 수도 있다. 로컬 DB - 피처들: 피처들은 안면 인식을 위한 안면 벡터(face vector), 네비게이션을 위한 지도/위치 이름, 텔 레프레즌스를 위한 사용자 데이터와 같이, 동작하는데 필요한 데이터를 로컬 DB로부터 액세스한다. 로컬 DB - 브레인: 브레인은 네비게이션을 위해 목적지로서 전송하기 위한 지도 위치들 등과 같이, 커맨드를 위 해 필요한 로컬 DB 상의 데이터에 액세스한다. 브레인 - MQTT 브로커(로컬): Brain은 MQTT를 통해 모든 피처들과 통신하고 \"I am alive\"를 수행한다. 브레인은 모든 피처들에게 커맨드를 전송하고 그리고 모든 피처들로부터 상태 업데이트를 수신한다. 브레인 - 서버 백엔드: (연결은 도시되지 않음) 이것은 소정의 데이터 다운로드 및 업로드 속도를 높이기 위한 선택적 연결이다. 브로커(로컬) - 피처: 피처들은 MQTT를 사용하여 커맨드를 수신하고 브레인에게 피드백을 제공한다. 예를 들어, 네비게이션을 위한 목표 엔드포인트, 스피치 투 텍스트(speech to text)를 위한 발음할 단어, 페이스앱(UI)을 위한 화면 전환 등이 있다. MQTT 브로커(서버) - 서버 백엔드: 업데이트 통지 및 선택한 데이터를 서버에서 라우터로 전달한다. 서버 백엔드 - 서버 프런트엔드: 서버 프런트엔드는 사용자 인터페이스에서 수신하고 개발자가 업로드한 데이터 를 백엔드로 트랜스퍼한다. 이것은 MQTT 및 API 호출을 통해 라우터로 전송되거나 서버 DB에 저장될 수 있다. 서버 백엔드 - 서버 DB: 서버 DB는 서버 백엔드에서 액세스, 프로세싱, 추가 또는 삭제될 수 있는 데이터를 저 장한다. 서버 프런트엔드 - 사용자 인터페이스: 개발자 또는 고객은 지도 데이터, 안면 벡터, 로봇 ID와 같은 데이터를 서버에 입력한다. 도 2는 서버측 구조를 도시한다. 서버 구조는 모든 회사들 또는 시설들의 모든 로봇들에 대한 데이터와 소프트웨어를 저장하고 액세스하는 체계 적인 방법을 포함할 것이다. 이러한 서버 구조는 단일 서버 또는 통신하는 여러 서버일 수 있다. 최상위 레벨에 서는 전체 서버 액세스(full server access)가 존재한다. 최상위 레벨 예를 들어, 모든 로봇을 운영하는 관리자 와 기술 직원이 보유할 수 있다. 이러한 레벨은 모든 로봇이 공유하는 일반 데이터를 가질 수 있다. 최상위 레 벨 아래에는 회사 레벨이 있을 수 있다. 대신에 이것이 하나이고 동일한 경우 회사/시설 레벨이 될 수 있다. 각 각의 회사는 고유한 회사 ID를 가지며, 이는 해당 회사의 모든 로봇에 공통적인 데이터베이스 데이터(로컬 데이 터베이스 참조), 필요한 경우 시설들의 세트, 그리고 각각 회사의 특정 로봇을 나타내는 로봇 ID 세트의 컬렉션 을 가리킨다. 회사 데이터의 일례로는, 페이스앱(FaceApp)에 표시할 회사 로고, 회사 애플리케이션, 회사 정책 및 표준, 회사 스태프 등이 있다. 더 낮은 레벨은 로봇 레벨이다. 로봇 레벨은 고유한 로봇 ID와 로봇-수준 데 이터를 포함할 수 있다. 로봇-수준 데이터의 일례로는 로봇 이름, 진단 또는 성능 데이터가 있다. 각각의 로봇 ID는 피처들의 세트를 나타낸다. 로봇들은 각각 상이하거나, 유사하거나, 또는 동일한 피처 세트를 포함할 수 있다. 각각의 피처는 피처 요건들의 세트(a set of feature requirements)를 가질 것이며, 이것은 피처들이 기 능하는데 필요한 도커들이다. 현재, 각각의 피처는 그 자신의 도커만을 필요로 하지만, 동작하기 위해 여러개의 도커들을 필요로 하는 피처들이 존재할 수도 있으며 또는 더 높은 효율성이나 효과로 동작하기 위해서 여러 도 킹들이 필요한 피처들이 있을 수도 있다. 예를 들어, 네비게이션은 장애물 회피를 위해 이미지 프로세싱에 의존 할 수 있다. 도커 종속성에 대한 이러한 피처들과 해당 종속성 레벨은 피처 요건 목록에 저장된다. 이를 통해, 로봇 초기화는 초기화 프로세스 동안에 어떤 피처들이 어디에 있는지, 어떤 데이터를 다운로드해야 하는지를 정 확히 알 수 있다. 또한, 이를 통해, 로봇의 의도된 기능에 따라 각 로봇에 도커를 적절히 할당할 수 있다. 이것은 성능과 비용을 개선하는데 적용될 수 있다. 예를 들어, 모든 로봇에 모든 도커들을 다운로드하고 작동시 키면, CPU가 과부하되거나 심지어 망가지거나 또는 작동하기 위해서는 훨씬 더 크고 더 비싼 CPU가 필요할 수 있다. 패키지 거래(package deal)로서 모든 소프트웨어를 제공하는 것보다, 각 로봇이 특정 기능에 필요한 도커 만 실행하는 것이 훨씬 더 효율적이고 비용 효율적이다. 도 3은 초기화를 위한 흐름도를 보여준다. 데이터 및 ID 생성(단계 101): 로봇은 로봇 ID, API URL 및 로컬 및 서버 브로커에 대한 MQTT 브로커 정보를 수신한다. 로컬 및 서버 브로커에 대한 MQTT 브로커 정보도 받을 수 있고, 또는 대안적으로 단계 6에서 이 정보를 끌어오는 스크립터가 이를 제공 할 수도 있다. 고객은 사용자 인터페이스를 사용하고 서버 프런트엔드와 서버 백엔드의 경로를 통해 서버 데이터베이스에 데이 터 세트를 업로드한다. 이러한 데이터 세트는 회사 ID와 연관될 수 있다. 로봇 ID(단계 102)는 이전 단계에서 생성된 데이터 세트의 선택된 피처 세트 및/또는 데이터 서브세트와 연관된 다. 로봇이 시작/부팅된다(단계 103). 또한 이러한 단계를 포함하여 이 단계까지의 임의의 시점에서 로봇이 조립될 수 있으며 그리고 스마트 연결이 초기화될 수 있다. 스크립터는 로컬 DB를 체크한다. 로컬 DB의 소정 부분은 비어 있다. 로봇이 이미 초기화된 경우 필드/파일/폴더 는 0이 아니어야 한다. 비어 있거나 존재하지 않는 필드는 로봇이 아직 초기화되지 않았음을 나타낸다. 다음으로, 스크립터가 트리거되어 초기화를 시작한다. 스크립터는 로봇의 로컬 저장소로부터 로봇 ID와 URL을 이미 가지고 있으며, 그리고 이들을 이용하여 서버에 API 요청을 수행하고 필요한 피처 세트를 다운로드한다. 이것은 라우터, 브레인 및 MQTT 브로커(로컬)을 포함할 수 있다. 로컬 MQTT 브로커에 대한 연결을 필요로 하는 모든 프로세서 모듈(단계 104)은 단계 1에서 로딩된 정보를 사용 하여 이를 수행한다. 브레인은 로컬 DB를 체크한다(105단계) 로컬 DB의 특정 부분이 비어 있으며, 로봇이 이미 초기화된 경우 필드/파일/폴더는 0이 아니어야 한다. 비어 있 거나 존재하지 않는 필드는 로봇이 아직 초기화되지 않았음을 나타낸다. 다음으로, 브레인이 초기화를 시작하도록 트리거된다(단계 106). 브레인은 초기화 프로세스를 시작하도록 라우터에 MQTT 커맨드를 전송한다. 라우터는 서버와 초기화 프로세스를 시작한다(단계 107). 라우터는 로봇의 로컬 저장소로부터 로봇 ID와 URL을 이미 가지고 있으며, 그리고 이들을 이용하여 서버에 대한 API 요청을 수행한다. 라우터는 API 요청을 통해 서버 DB에서 가져온 제 1 데이터 세트의 일부로서 서버로부터 회사 ID를 가져온다. 로봇 ID, 회사 ID 및 URL을 사용하는 후속 API 요청(단계 108)은 로봇의 로컬 데이터베이스를 구축하기 위해 수 행된다(이러한 단계는 단계 9 이전, 동안 또는 이후에 발생할 수 있음). 라우터는 얼굴 벡터, 지도 정보 등을 포함하되 이에 국한되지 않는 로봇에 대한 특정 사용자 정보를 로컬 데이 터베이스로 다운로드한다. 서버로부터 수신된 데이터는 서버에 언제 업로드되었는지에 대한 타임스탬프를 포함하고 있으며 라우터는 이를 업데이트 중에 향후 참조할 수 있도록 로봇의 로컬 데이터베이스에 저장한다. 라우터는 MQTT를 통해 로컬 데이터베이스가 설정되었음을 브레인에 핑(ping)한다. 라우터는 로봇 ID와 회사 ID를 사용하여 서버에서 오는 MQTT 토픽을 구독하고(단계 109), 서버와 IAmAlive 신호 를 시작한다(이 단계는 단계 8 이전, 동안 또는 이후에 발생할 수 있음). 업데이트 통지 및 데이터는 MQTT(큐에서)를 통해 라우터로 전송된다. 대기 중인 모든 업데이트 통지는 이 지점 에서 수신된다. 라우터는 API 호출을 사용하여 서버와 IAmAlive를 초기화한다. 피처 세트는 필요한 데이터를 로컬 DB로부터 직접 가져온다(단계 110)(이러한 단계는 단계 8 이후에 발생해야 하지만 단계 9 이전에 발생할 수 있음). 서버와의 I am Alive PING 로봇은 위에서 설명한 프로세스의 단계 7을 지나서 먼저 초기화 프로세스를 거쳐야 한다. 라우터는 사전 설정된 간격(2분 또는 5분마다 등)으로 API 호출을 통해 서버에 ping을 보내는 내부 클록을 시작 한다. 각각의 간격에서 라우터는 로봇의 로봇 ID 뿐만 아니라 제공된 URL을 이용하여 서버에 API 호출을 수행하여 로 봇이 온라인 상태임을 서버에 알려준다. 클록은 백그라운드에서 실행되며, 로봇의 정상적인 기능에 영향을 미치지 않는다. 서버로부터의 데이터 업데이트 도 4는 서버로부터의 데이터 업데이트 흐름도를 보여준다. 로봇은 앞서 설명한 프로세스의 단계 9를 지나서 먼저 초기화 프로세스를 거쳐야 한다. 로봇에 대한 새로운 데이터 및/또는 소프트웨어는 개발팀이나 사용자에 의해 서버에 업로드된다(단계 201)(단계 1 이전이나 아후에 발생할 수 있음). 서버는 서버 MQTT 브로커를 통해 라우터에 ping을 보내서 업데이트가 이용가능함을 알려준다(단계 202). 소프트웨어 대(versus) 데이터 업데이트에 대한 ping은 다른 MQTT 토픽에서 수행될 수 있으므로 라우터는 어떤 유형의 업데이트가 발생하고 있는지를 자동으로 알 수 있다. 라우터는 업데이트가 새 것인지 또는 데이터를 이미 가지고 있는지를 체크한다(단계 203). 업데이트 통지는 데이터가 언제 서버에 업로드되었는지에 대한 타임스탬프를 포함한다. 로봇은 이러한 타임스탬 프를 체크하여(단계 204) 로컬 데이터베이스에 저장된 타임스탬프와 이를 비교한다. 통지에 있는 타임스탬프가 데이터베이스의 타임스탬프보다 최신인 경우 업데이트는 새 것이고, 로봇은 업데이트 프로세스를 진행하여 단계 5로 이동한다. 그렇지 않은 경우 업데이트는 취소된다. 업데이트가 소프트웨어 업데이트인 경우, 라우터는 스크립터에 ping을 보내 업데이트를 수행한다. API 호출 후 스크립터는 라우터에 ping을 보내고 라우터는 서버에 ping을 보낸다. 업데이트가 데이터 업데이트인 경우 라우터는 초기화 프로세스에서 설명한 것과 동일한 API 호출을 수행하고(단 계 205), 신규 데이터를 로컬 데이터베이스에 기록한다. 라우터는 새로운 데이터만 다운로드하고 이미 가지고 있는 오래된 데이터는 다시 다운로드하지 않도록 최적화될 수 있다. 라우터는 데이터 업데이트로부터 새로운 타임스탬프를 획득하고, 향후 업데이트시 참조할 수 있도록 이를 로컬 데이터베이스에 기록한다. 라우터는 업데이트가 완료되었음을 알리는 MQTT 메시지를 서버 및/또는 브레인으로 전송한다(단계 206). 로봇으로부터의 데이터 업데이트 도 5는 로봇으로부터의 데이터 업데이트를 보여주는 흐름도이다. 로봇은 업데이트를 체크하도록 트리거된다(단계 301). 전술한 \"서버 로봇 통신\"을 참조하라. 로봇은 트리거에 관한 정보와 함께 서버에 피드백을 전송한다(단계 302). 이것은, 예를 들어, 작업의 성질(네비 게이션, 이미지 프로세싱 등), 시간 및 실패 위치일 수 있다. 또는 로봇은 자신의 성능을 분석하고 특정 소프트 웨어 또는 소프트웨어 카테고리를 서버에 요청할 수 있다. 실패 데이터가 서버에 의해 수집되면, 서버측은 이러한 데이터를 사용하여 로봇이 다운로드하기에 적합한 새로 운 소프트웨어가 있는지 결정할 수 있다.(단계 303). 이러한 결정은 서버에서 작업하는 인간 운영자 또는 서버 자체의 AI 소프트웨어에 의해 핸들링될 수 있다. 이미 필요하다고 판단한 소프트웨어를 로봇이 요청하는 경우, 서버를 운영하는 사람 또는 AI는 그러한 소프트웨어가 이용가능한지를 체크할 것이다. 서버는 로봇에 이용가능한 모든 소프트웨어의 저장소를 가지고 있다. 서버측의 사람이나 AI가 로봇이 다운로드 할 임의의 적절한 신규 소프트웨어를 이러한 저장소 내에서 식별할 수 없는 경우 업데이트는 취소된다. 검색 조 건은 로봇의 요청이나 로봇 트리거의 서버측 분석에 의해 결정된다. 스크립터는, 서버로부터 다운로드하기 위한 API 호출은 이전에 설치된 코드의 업데이트된 버전 외에도 이러한 새 코드에 대한 정보가 포함될 수 있다는 점 을 제외하면,소프트웨어 업데이트에 대해 설명된 것과 유사한 프로세스로 해당 코드를 다운로드할 수 있다. 그 런 다음 스크립터와 브레인은 로봇을 재부팅할 최적의 시간을 결정하기 위해 통신할 수 있다. 로봇은 업데이트가 소프트웨어인지 데이터인지를 체크한다. 새로운 소프트웨어가 이용가능한 경우, 서버는 MQTT 브로커(서버)를 통해 해당 새로운 소프트웨어에 대한 정보 와 함께 라우터에 ping을 보낸다(단계 304). 스크립터는 단계 4에서 수신한 정보를 사용하여 새로운 소프트웨어를 다운로드하기 위한 API 호출을 수행한다 (단계 305). 라우터는 로봇이 이제 새로운 소프트웨어를 다운로드했다는 것을 알리기 위해 서버 및/또는 브레인에 ping을 보 낸다(단계 306). 도커(Docker)는 컨테이너화된 애플리케이션을 빌드, 배포 및 관리하기 위한 오픈 소스 플랫폼이다. IBM에 의해 정의된 바와 같이, 도커는 개발자들이 컨테이너들을 빌드, 배포, 실행, 업데이트 및 관리할 수 있도록 하는 오 픈 소스 플랫폼이다. 컨테이너는 애플리케이션 소스 코드와 운영 체제(OS) 라이브러리 및 해당 코드를 모든 환 경에서 실행하는데 필요한 종속성을 결합하는 표준화되고 실행가능한 컴포넌트이다. 컨테이너는 분산 애플리케 이션들의 개발 및 배달을 간소화한다. 클라우드 기반 개발 및 하이브리드 멀티클라우드 환경으로 조직들이 전환 함에 따라 컨테이너는 점점 더 인기를 얻고 있다. 개발자는 리눅스(Linux) 및 기타 운영 체제에 내장된 기능을 직접 사용하여 도커 없이도 컨테이너를 만들 수 있지만, 도커는 보다 빠르고 쉽고 안전한 컨테이너화를 가능하 게 한다. 도커(Docker) 아키텍처는 해당 기술 분야에서 docker.inc로부터 상업적으로 이용가능하다. 도커는 컨테이너라 지칭되는 느슨하게(loosely) 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있는 기능을 제공한다. 격 리 및 보안 덕분에 주어진 호스트 상에서 동시에 여러 컨테이너를 실행할 수 있다. 컨테이너는 가벼울 뿐만 아 니라 애플리케이션을 실행하는데 필요한 모든 것을 포함하고 있으므로, 호스트에 현재 설치되어 있는 것에 의존 할 필요가 없다. 컨테이너는 리눅스(Linux) 커널에 내장된 프로세스 격리(process isolation) 및 가상화 기능을 통해 가능해졌다. 프로세스들 간에 리소스들을 할당하기 위한 콘트롤 그룹(control group)(Cgroup) 및 프로세스의 다 른 리소스들 또는 시스템 영역들에 대한 액세스 또는 가시성을 제한하기 위한 네임스페이스(namespaces)와 같은 이러한 기능들을 통해, 여러 애플리케이션 컴포넌트들은 호스트 운영 체제의 단일 인스턴스의 리소스들을 공유 할 수 있으며, 이는 하이퍼바이저가 여러 가상 머신(VM)이 단일 하드웨어 서버의 CPU, 메모리 및 기타 리소스를 공유할 수 있도록 하는 것과 매우 유사한 방식이다. 결과적으로, 컨테이너 기술은 VM의 모든 특징들과 장점들을 제공하는바, 애플리케이션 격리, 비용 효율적인 확장성 및 처분가능성(disposability)을 포함하는 장점과 더불 어 더 가벼운 무게, 향상된 개발자 생산성, 더 큰 리소스 효율성과 같은 중요한 추가 이점을 제공한다. 로봇의 초기화(즉, 로봇이 작동하는데 필요한 소프트웨어 및 데이터)는 앞서 언급된 도커 아키텍처에서 제공하 는 것과 같은 가상 컨테이너를 사용하여 구현될 수 있다. 가상 컨테이너는 가상 머신의 서브세트로 간주될 수 있으며, 초기화 프로세스는 미리 정의된 가상 컨테이너를 사용하여 로봇을 실행할 수 있다. 가상 컨테이너를 사 용하면 필요한 기능을 제공하기 위해 작업 요소의 모듈성이 제공된다. 도커(Docker)는 일종의 \"가상 컨테이너\"로, 이는 특정 코드 조각을 실행하기 위한 모든 종속성을 포함하는 소형 의 시뮬레이션형 운영 체제이다. 도커는 로봇의 하드웨어에서 직접 실행되지 않고 대신 각각 자체 가상 운영 체 제에 따라 작동한다. 따라서, 로봇의 하드웨어에서 실제로 실행되는 또 다른 코드 조각, 이 경우 스크립터에 의 해 초기화되어야 한다. 각각의 피처(얼굴 인식, NLP, OCR 등)는 자체 도커를 갖는다. 브레인은 의사결정자이며 성과나 작업 기능 모두에서 다재다능하고 유연하다(특화될 수 있음). 본 명세서에 개시된 발명을 설명하는 목적으로서, 스크립트는 특정 스크립터가 실행하는 코드이며, 초기화시 서 버에서 검색할 소프트웨어 패키지(도커) 세트를 알려준다. 스크립터는 로봇의 하드웨어에서 직접 실행되는 유일 한 코드라는 점에서 펌웨어와 유사하다. 다른 모든 코드는 가상 컨테이너(도커)에서 실행되며, 윈도우 (Windows), 매킨토시 OS(macOS0, 리눅스(Linux) 등과 같은 운영 체제(OS)와 비교될 수 있다. 작업을 정의하는 코드/소프트웨어를 스크립트가 포함할 수 있다는 점이 이해될 것이다. 예를 들어, 로봇은 의료 용 보조 로봇으로서의 작업을 갖는 것으로 지정될 수 있다. 로봇의 역할은 환자를 등록하고, 생체 신호를 측정 하고, 환자를 검사실로 안내하고, 검사 중에 의사를 돕는 것일 수 있다. 따라서, 스크립트는 \"의료용 어시스턴 트 로봇\"의 작업을 정의할 수 있다. 다음과 같은 점이 이해될 수 있는바, 단일 작업(single task)이 소정의 피 처들을 필요로 할 수 있다. 예를 들어, 환자를 검사실로 안내하기 위해, 스크립트는 로봇의 이동성을 제어할 수 있지만, 로봇은 정의된 구내 내에서 올바르게 이동하기 위해 해당 지역의 정확한 내비게이션 맵을 다운로드해야 하며 그리고 물체와 충돌하지 않도록 소정 형태의 물체 인식 기능을 필요로 할 수 있다. 이러한 시나리오에서, 네비게이션 능력과 물체 인식 능력은 해당 작업에 필요한 피처로 간주될 수 있다. 현재, 스크립트는 스크립터에 하드 코딩되어 있으며, 이는 스크립터가 초기화 중에 서버에서 끌어올 도커 세트 로 미리 로드되어 있다는 것을 의미한다. 하지만, 미래에는 이것이 소프트 코딩될 수도 있으며, 이는 다운로드 해야 할 피처 세트를 알지 못하는 경우에도 로봇이 시작할 수 있다는 것을 의미한다. 초기화시, 스크립터는 서 버의 \"초기화기(initializer)\"에게 로봇 ID를 제시할 수 있으며, 이는 (로봇 ID에 따라) 해당 로봇이 가져야 할 스크립트를 알고 있다. 스크립터가 스크립트를 수신하면, 스크립트에 자세히 설명된 도커 세트를 다운로드하고 론칭할 수 있다. 도커가 론칭되면, 라우터(도커들 중 하나)는 해당 로봇의 기능에 필요한 데이터를 다운로드함 으로써 초기화 프로세스를 완료한다. 소프트 코딩된 옵션이 또한 라우터의 초기화에 영향을 미칠 수 있는바, 라 우터는 로봇의 특정 피처 세트와 관련된 데이터만을 다운로드해야 하기 때문이다(예: 내비게이션이 없는 로봇의 경우 지도를 다운로드해서는 안 됨). 스크립터가 다운로드해야 하는 도커 세트와 함께 스크립트를 수신하면, 서 버로부터 어떤 데이터를 끌어와야 하는지를 라우터가 정확히 알 수 있도록 스크립터는 해당 목록을 라우터에 전 달해야 할 수도 있다. 또는 라우터가 다운로드한 데이터 선택은 스크립터의 경우와 매우 유사하게 서버의 \"초기 화기\"에 의해 처리될 수 있다. 라우터는 로봇 ID를 초기화기에게 제시할 수 있고, 초기화기는 어떤 데이터를 다 운로드해야 하는지 알려줄 수 있다. 소프트 코딩된 스크립트를 사용하면, 개발자는 제조 중에 로봇에 피처 세트를 하드 코딩하지 않고도, 어떤 피처 세트를 로봇이 가져야 하는지를 원격으로(서버를 통해) 선택할 수 있다. 스크립터는 재부팅 시점에 대해 브레인와 통신한다. 스크립터가 소프트웨어 업데이트를 다운로드하면, 새로운 소프트웨어가 로봇에서 실제로 실행되기 전에 로봇을 재부팅해야만 한다(OS 업데이트를 다운로드한 후 전화나 컴퓨터를 다시 시작하는 것과 같음). 이를 수행하기 전에 스크립터는 다시 시작하기에 이상적인 시간을 찾기 위 해 브레인와 통신하며, 따라서 중요한 작업 중간에 로봇을 멈추지 않도록 한다. 재부팅이 단순히 전원을 끄고 켜는 것일 경우 데이터에 영향을 미치지 않는다. 로봇들은 서버에 연결되면 집합적으로 작동할 수 있다. 예를 들어, 시설에 있는 여러 로봇들이 수행해야 할 작 업이 여러 개 있는 경우, 이들 로봇들은 예컨대, 해당 작업들을 시설-레벨 또는 플로어-레벨 작업 대기열 안으 로 서버에 업로드할 수 있으며, 이러한 작업들을 수신하면 서버는 작업들을 순서화하고 분류하여 로봇들로 다시 전송하여 효율성을 보다 적절하게 최적화할 수 있다. 서버는 로봇의 하드웨어보다 훨씬 더 많은 프로세싱 능력을 가지고 있다. 일반적인 서버 프로세서는 0.5TB 내지 6.0TB의 RAM을 가질 수 있는 반면에, 로봇의 CPU는 1GB 내지 64GB를 가질 것으로 예상된다. 초기화 프로세스 동안의 적어도 하나의 포인트에서 로봇은 서버에 연결되어야만 하며 업데이트 프로세스 중 적 어도 하나의 포인트에서 서버에 연결되어야만 한다. 로봇은 선택적으로 어느 포인트에서나 서버에 연결될 수 있 으며, 그렇다면 서버가 이러한 연결을 알 수 있도록 IamAlive PING을 수행한다. 이러한 시간 외에는 로봇은 기 능적 요구 사항에 따라 작동하기 위해 서버에 연결될 필요가 없다. 로봇 ID 내에 숨겨진 디테일 레벨 - 회사 ID, 시설 ID, 로봇 ID, 작업 ID, 하나의 ID 또는 여러 ID의 카테고리 ID 레벨은 하나의 ID 또는 여러 ID와 모두 그룹화되어 연관된다. 로봇 ID는 단순한 001, 002, 003 … 보다 더 많은 정보를 보유할 수 있다. 이것은 로봇 사용에 대한 정보를 포 함하는 더 복잡한 숫자 또는 ID일 수 있으므로 서버 또는 사람은 로봇 ID를 파싱하여 특정 기능 또는 피처들을 로봇에 매칭할 수 있다. 구현되는 경우, 이것은 초기화 프로세스의 성능을 향상시킬 수 있다. 이러한 파싱된 로 봇 ID는 회사 ID, 시설(Facility) ID, 플로어(Floor) ID, 작업(Task) ID, 카테고리 ID, 1 ID 또는 여러 ID의 카테고리 ID 디테일 레벨 또는 모두 1 ID 또는 여러 ID와 그룹화되어 연관된 것으로 지칭될 수 있다. 예를 들어, 로봇 ID가 64비트 코드 또는 여러 세트의 코드인 경우: 제 1 디지트 세트(또는 제 1 코드)는 로봇이 사용될 회사를 나타낼 수 있다. 제 2 디지트 세트(또는 제 2 코드)는 로봇이 사용될 시설을 나타낼 수 있다. 제 3 디지트 세트(또는 제 3 코드)는 로봇이 사용될 플로어를 나타낼 수 있다. 제 4 디지트 세트(또는 제 4 코드)는 로봇이 수행하려는 워크(work)의 카테고리를 나타낼 수 있다. 제 5 디지트 세트(또는 제 5 코드)는 로봇이 수행하려는 작업(task)을 나타낼 수 있다. 기타 등등. 업데이트: 서버측 대 로봇 시작 업데이트. 서버는 로봇 ID에 의해서 어떤 업데이트가 어떤 로봇에 관련되는지, 그리고 회사 ID에 의해서 고객 데이터가 업 데이트되었는지를 알아야 할 필요가 있을 것이다. 위에서 설명한 대로 더 자세한 로봇 ID가 이용되는 경우, 서 버는 어떤 로봇이 어떤 업데이트의 영향을 받는지를 파싱하는 일반적인 수단을 가질 것이다, - 위에 나열된 회 사 ID, 시설 ID, 로봇 ID, 작업 ID, 카테고리 ID 배포 레벨의 일례를 참조하라. 예를 들어, 회사 로고가 변경되 면, 이것은 모든 회사 ID 로봇에 영향을 미칠 것이다. 사무실을 리모델링하면, 이것은 모든 시설 ID 로봇에 영 향을 미칠 것이다. 절차가 변경되면, 이것은 관련된 모든 작업 ID 로봇에 영향을 미칠 것이다. 기타 등등. 대안 적으로, 또는 전술한 내용에 추가하여, 로봇은 자체 분석을 통해 서버에 어떤 유형의 업데이트를 요청해야 하는 지 알 수 있다. 예를 들어, 로봇은 필요한 도커와 데이터를 알고 그에 따라 적절한 업데이트만을 수신함을 알 수 있다. 업데이트에 대한 새로운 설명. 데이터 또는 소프트웨어 업데이트가 가능할 때마다, 서버는 업데이트가 발생한 날짜/시간 및 업데이트의 성질 (데이터인 경우 어떤 유형의 데이터인지, 소프트웨어/도커인 경우 어떤 도커를 업데이트할 것인지)에 대한 정보가 포함된 메시지를 라우터에 전송한다. 소프트웨어/도커 업데이트에서, 라우터는 서버에서 수신한 정보를 스크 립터에 전달하고, 스크립터는 그에 따라 새로운 도커를 다운로드한다. 데이터 업데이트인 경우, 라우터가 자체 적으로 업데이트를 핸들링한다. 라우터는 데이터용이고 스크립터는 소프트웨어용이다. 로봇은 새로운 데이터로 서버를 업데이트할 수 있다. 로봇은 API 호출을 사용하여 작동 중에 수집한 새로운 데 이터(얼굴 인식 데이터, 지도 데이터, 사용자 프로필 정보 등)로 데이터베이스를 업데이트할 수 있다. 이러한 데이터는 회사 ID, 시설 ID, 로봇 ID 등의 세부 정보에 설명된 대로 해당 회사 또는 시설의 다른 로봇들이 액세 스할 수 있는 데이터베이스의 소정 위치에 저장될 수 있다. 다양한 유형의 데이터가 다양한 액세스 레벨에 대해 지정될 수 있으며, 이는 고객 또는 개발 팀에 의해서 결정될 수 있다. 예를 들어, 회사는 특정 시설에 있는 로 봇들만이 새로운 안면 인식 데이터에 액세스할 수 있음을 원할 수 있으며 또는 해당 회사의 모든 시설에 있는 모든 로봇들에 대해 액세스가 활성화됨을 원할 수도 있다. 피처들과 작업들 사이의 관계 작업들을 피처들로 세분화할 수 있다. 예를 들어, \"접수 담당자(receptionist)\" 라는 작업은 스피치-투-텍스트, OSR, 이미지 인식, 및 데이터베이스와의 상호작용이라는 피처들을 필요로 할 수도 있는 하이-레벨 개념이다. 개 발에서는 로봇의 기능에 필수적인 것으로 간주되는 피처 세트를 완성하는데 중점을 둔다. 최종 고객이 시설에서 로봇이 수행하는 것을 보고 싶어할 수 있는 모든 고레벨 작업은 이러한 더 작은 피처들로 세분화된다. 초기화 프로세스 동안, 로봇은 각각 특정 피처를 활성화하는 도커들의 세트를 다운로드한다. 실제 작동 동안 로 봇은 이러한 피처들을 사용하여 원하는 작업들을 수행할 것이다. 작업-레벨 설명은 고객이 로봇에 대해 원하는 기능을 선택하는데 도움을 줄 수 있다. 피처들은 실제 도커들/코 드이다. 고객들이 로봇을 주문하면, 로봇이 수행하기를 원하는 작업 측면에서 옵션들이 고객들에게 제공된다. 사전 초기화 VS 사후 초기화 로봇 프로세서: 사전 초기화는 초기화되기 전에 로봇에 있는 소프트웨어의 양을 최소화하기 위해 스크립터와 로컬 DB 및 로봇 ID만을 갖는다. 이를 통해 배포에 있어 가장 큰 유연성과 효율성을 얻을 수 있는바, 로봇에 하드코딩하는 대신 에 로봇의 피처 세트를 원격으로 결정할 수 있기 때문이다. 이론적으로는, 3개의 동일한 초기화되지 않은 로봇 들이 3개의 완전히 다른 기능에 대해 초기화될 수 있다. 초기화 전에 로봇에 제공되는(하드코딩되는) 모든 것은, 로봇 ID, 선택한 피처 세트를 로봇에 다운로드하는 스크립터, 다운로드된 모든 소프트웨어와 데이터를 로 봇에 로컬로 저장하는 로컬 DB이다. 사후 초기화는 전체 기능을 위한 실제 도커들을 갖는다. 초기화가 완료되면 로봇은 전체 피처 세트를 갖게 된다. 스크립터는 해당 피처 세트에 필요한 모든 도커를 다운로드하고, 도커는 도커가 작동하는데 필요한 모든 데이터를 다운로드한다. 이제 본 발명의 실시예에 따라 오프라인 로봇을 초기화하고 업데이트하기 위한 시스템을 설명하는 도 6을 참조한다. 시스템은 네트워크 연결(예컨대, 인터넷)를 통해 여러 로봇들과 통신할 수 있는 서버 를 포함할 수 있다. 각각 다른 작업 세트가 할당된 두 개의 로봇(20A 및 20B)이 도시되어 있지만, 일부 실 시예에서 이들은 동일한 작업을 수행할 수 있다. 로봇A는 환자 등록, 생체 신호 측정, 환자를 검사실로 안 내하고 의사를 보조하는 작업을 담당하는 의료용 보조 로봇일 수 있다. 로봇B는 고객으로부터 주문을 접수 하고 메뉴에 대한 질문에 응답하고 음식을 서비스하는 작업을 담당하는 서비스 산업 로봇일 수 있다. 다음이 이 해될 것인바, 이러한 로봇은 또한 통신 및 판독을 위한 마이크, 스피커, 카메라 및 센서와 같은 액세서리들 그 리고 의약품 분배 또는 음식 제공을 위한 팔과 같은 작업을 수행하는데 필요한 기타 하드웨어 액세서리를 포함 할 수 있다. 의료용 어시스턴트 로봇의 일례가 대표 로봇으로 사용될 것이다. 이러한 로봇 설정은 진료소 관리자에 의해 제 공될 수 있으며, 로봇은 환자와 상호작용할 수 있다. 다른 실시예에서, 다른 유형의 로봇 및 사용자도 사용 될 수 있다. 시스템은 모든 회사 또는 모든 시설의 모든 로봇에 대한 데이터와 소프트웨어를 저장하고 액세스하는 체계적인 방법을 가질 수 있다. 가장 높은 레벨에서는 전체 서버 액세스가 존재한다. 이것은 예를 들어 모든 로 봇을 운영하는 관리자와 기술 직원이 보유할 수 있다. 이러한 레벨은 모든 로봇이 공유하는 일반 데이터를 가질 수 있다. 이러한 레벨 아래에는 회사 레벨이 있을 수 있다. 이것은 대신 하나이고 동일한 경우 회사/시설 레벨 이 될 수 있다. 각 회사는 고유한 회사 ID를 가질 수 있으며, 이는 해당 회사의 모든 로봇에 공통적인 데이터베이스 데이터 모음, 필요한 경우 시설들 세트, 그리고 각각 회사의 특정 로봇을 나타내는 로봇 ID 세트를 가리킨 다. 회사 데이터의 예로는 로봇 인터페이스에 표시할 회사 로고, 회사 애플리케이션, 회사 정책 및 표준, 회사 직원 등이 있다. 더 낮은 레벨로는 로봇 레벨이 있다. 로봇 레벨은 고유한 로봇 ID와 로봇 레벨 데이터를 포함 할 수 있다. 로봇 레벨 데이터의 예로는 예를 들어 로봇 이름, 진단 또는 성능 데이터가 있다. 서버는 또한 서버 데이터베이스, 프리프로세서, 초기화기, 서버 업데이터, 핑 인식기 및 포털을 더 포함할 수 있으며, 이는 프리프로세서 및 서버 업데이터에 대한 수동으로 정의된 지 침 및 입력을 수신한다. 이러한 요소들의 기능은 아래에서 더 자세히 설명된다. 로봇은 각각 초기화 프로세스 동안 서버과 통신하고, 로봇의 런타임 기능을 제어 및 관리하고, 서 버와 업데이트를 제공하고 수신할 수 있는 로봇 프로세서을 포함할 수 있다. 이제 도 7a를 참조하며, 도 7a는 로봇이 초기화되기 전 로봇 프로세서의 요소를 보여준다. 로봇 프로세 서는 스크립터, 로컬 데이터베이스 및 할당된 로봇 ID만으로 제조될 수 있다. 스크립터은 아래에서 더 자세히 설명되는 바와 같이 로봇의 피처 및 기능을 구성하는 가상 컨테이너의 다운로드 및 실행을 관리하는 역할을 한다. 로봇이 초기화될 때까지 로컬 데이터베이스은 비어 있을 수 있음을 이해할 것이다. 도 7b는 로봇이 초기화되면 런타임 시에 로봇 프로세서의 요소들을 도시한다. 런타임 시에, 로봇 프로 세서는 스크립터 및 로컬 데이터베이스과 함께 다중 피처 요소 가상 컨테이너, 컨트롤러 및 라우터를 포함할 수 있다. 컨트롤러는 로봇 업데이터를 포함할 수 있다. 이러한 요소의 기능은 아래에서 더 자세히 설명한다. 서버와 로봇은 자체 호스팅되거나 관리될 수 있는 MQTT(Message Queuing Telemetry Transport) 브로커 를 통해 통신할 수 있다. MQTT는 가벼운 메시징 프로토콜로서, 클라이언트가 소형의 코드 풋프린트를 필요로 하 고 그리고 신뢰할 수 없는 네트워크 또는 제한된 대역폭 리소스를 갖는 네트워크에 연결된 경우에 사용하기 위 한 것이다. 백엔드는 로봇 ID에 따라 모든 로봇에 대한 데이터와 소프트웨어 패키지를 포함하는 서버로 간 주될 수 있다. 서버와 라우터 둘다는 작은 메시지의 빠른 통신을 허용하는 MQTT 브로커에 연결될 수 있 다. 이들은 API 호출에 의해 수행되고 더 큰 다운로드를 포함하는 데이터 또는 소프트웨어 업데이트와 다를 수 있다. 로봇은 또한 모든 요소들(즉, 스크립터, 로컬 데이터베이스, 컨트롤러, 라우터 및 다중 피처 요소 가상 컨테이너) 간의 통신을 관리하기 위해 로컬로 MQTT 브로커를 사용할 수 있다. 이는 로 봇에 대한 결정을 내리는 컨트롤러에 특히 중요하다. 예를 들어, 로봇이 특정 목적지에 도착한 후 특정 스크린으로 변경해야만 하는 경우, 네비게이션 가상 컨테이너, 컨트롤러 및 로봇 UI 가상 컨테이너 간 에 통신이 필요하다. 네비게이션 가상 컨테이너는 MQTT를 통해 컨트롤러에 메시지를 보내 로봇이 목적 지에 도착했다는 것을 알릴 수 있다. 컨트롤러은 내부 논리에 따라 무엇을 해야할지를 결정한 이후, MQTT 메시지를 로봇 UI 가상 컨테이너에 전송하여, 이제 어떤 스크린을 표시할지를 알려준다. 로봇 UI 가상 컨테이너 는 이러한 메시지를 받은 후 요청된 스크린으로 변경하기 위해 필요한 모든 작업을 수행할 수 있다. 프리프로세서의 요소들이 도 8에 도시되어 있다. 대형 프로세서들을 필요로 하는 \"대규모 프로세싱\"은 서버 에서 수행될 수 있고 출력은 서버 데이터베이스에 저장될 수 있다. 서버 및 프리프로세서는 로 봇의 지능형 작동을 지원하기 위해 하이 리소스 프로세싱을 제공할 수 있다. 로봇이 초기화되면, 로봇 은 로봇에 대한 내부 지능을 제공하기 위해 로우 리소스 프로세싱 작업만을 필요로 할 수 있다. 프리프로세서는 이미지 프로세서, 오디오 프로세서 및 네비게이터를 포함할 수 있지만 이에 국한되지 않는다. 프리프로세서의 요소는 스크립트를 실행하고 로봇을 활성화하는데 필요한 운영 데이 터를 제공할 수 있다. 프리프로세서의 모든 하위 요소는 해당 기술 분야에서 알려진 표준 알고리즘을 사용 할 수 있다. 이미지 프로세서는 객체 인식, 얼굴 인식, OCR(광학 문자 인식) 등을 제공할 수 있다. 이미지 프로세서는 얼굴 인식을 위해 haar 분류기를 사용할 수 있다. 오디오 프로세서는 오디오 인식, 음성 매칭, NLP(자연어 프로세싱), 음성 대 텍스트, 텍스트 대 음성 등을 담당할 수 있다. 내비게이터는 ROS 내비게이션 스택을 사용하여 로컬 구내에 대한 지속적으로 업데이트된 맵을 프로세싱할 수 있다. 처음에는 내비게이션을 위해, 로봇이 수신한 정보로부터 부분적으로 작동할 수 있으며, 이는 아래 에서 더 자세히 설명된다. 단일 로봇은 초기 맵을 그리는 데 사용될 수 있으며, 초기 맵은 다른 로봇들이 자신의 내비게이션을 위한 기준으로 사용될 수 있다. 자신의 내비게이션 중에 다른 로봇들은 활성 상태인동안 센서로부터 수신한 입력을 사용하여 맵을 업데이트할 수 있다. 따라서, 맵은 지속적으로 업데이트될 수 있 다. 서버 데이터베이스는 프리프로세서의 요소의 출력을 저장할 수 있으며, 얼굴, 사람, 권한 상태, 객체, 지도, 위치 이름, 인식된 단어 및 구문, 고객 데이터 또는 로봇이 할당된 작업에 따라 올바르게 기능하는데 필요하거나 도움이 되는 기타 로봇 작동 데이터를 저장할 수 있지만 이에 국한되지는 않는다. 또한, 서버 데이 터베이스는 로봇당 작업 및 관련 스크립트를 열거하는 로봇 관리 테이블 목록을 저장할 수 있으며, 각각의 로봇은 수행할 작업 및 수신할 스크립트 및 데이터를 갖는다. 로봇 관리 테이블 목록은 또한 ID 번호 및/또는 고객 번호에 따라 로봇에 작업을 할당할 수 있다. 초기화기는 로봇 ID에 따라 로봇에 다운로드하기 위해 서버 데이터베이스로부터 기능에 대한 스크립트와 필요한 가상 컨테이너를 검색하기 위해 스크립터와 조정하는 역할을 할 수 있다. 서버 업데이터는 아래에서 더 자세히 설명하는 바와 같이 서버과 로봇 프로세서 모두에 대한 서버 및 데이터 업데이트를 조정할 수 있다. Ping 인식기는 로봇이 온라인 상태가 되는 경우 이를 등록하여 아래에서 보다 자세히 논의되는 대로 업 데이트를 제공할 수 있다. 포털은 적절한 UI 요소일 수 있으며, 예를 들어, 시설 관리자가 데이터를 관리하는데 사용될 수 있다. 예를 들어, 클리닉 관리자는 포털을 통해 사용자, 사용자 정보 및 상태, 의사 및 간호사를 추가할 수 있다. 그런 다음 교대가 시작되면 진료실에 의사가 배정될 수 있다. 사전 초기화, 로봇은 스크립터, 로컬 데이터베이스을 포함할 수 있으며 ID 번호를 가질 수 있다. 스크립터는 로봇의 스크립트와 가상 컨테이너(컨트롤러 33 및 라우터 34 포함)의 다운로드 및 실행을 초기 화기를 통해 관리할 수 있으며, 로봇 ID 번호 및 서버 데이터베이스의 관리 테이블 목록에 따라 로 봇의 기능에 필요한 피처 요소를 나타내는 가상 컨테이너를 관리할 수 있다. 각각의 가상 컨테이너는 자체 가상 환경에서 독립적으로 작동하는 코드 패킷으로 간주될 수 있다. 스크립터(가상 컨테이너 커맨드 사용) 는 또한 예를 들어 필요에 따라 가상 컨테이너를 종료하거나 전원을 켜거나, 가상 컨테이너의 현재 버전이 최신 버전인지 확인하고, 필요한 경우 업데이트를 수행할 수 있다(아래에서 논의되는 바와 같이). 스크립터에 의 해 실행되면 각 가상 컨테이너는 독립적으로 작동할 수 있다. 라우터는 지도, 위치 이름, 얼굴 인식 데이터 등과 같은 로봇 피처에 필요한 다운로드 데이터를 피처 요소 가상 컨테이너에 대해 핸들링할 수 있다. 라우터가 데이터를 수신하면, 이를 컨트롤러으로 보 낼 수 있다. 라우터는 데이터 패킷을 의도된 IP 주소로 전달하고 여러 디바이스들이 동일한 인터넷 연결을 사용하도록 허용하여 서버과 로봇 간의 트래픽을 관리할 수 있다. 라우터는 또한 아래에서 더 자세 히 설명하는 것처럼 I Am Alive ping 신호를 보내는 것을 담당할 수 있다. 컨트롤러은 피처 요소 가상 컨테이너를 사용하여 로봇의 지능 및 기능을 관리할 수 있다. 로봇(2 0)은 감각 및 능력을 포함할 수 있다. 이는 음성 인식, 자연어 프로세싱, 시각, 움직이는 능력, 말하는 능력 및 사용자 인터페이스(예컨대, 로봇 스크린/얼굴)를 통해 환자와 소통하는 능력일 수 있지만 이에 국한되지 않는다. 예를 들어, 의료용 어시스턴트 로봇에서 로봇의 역할은 환자를 등록하고, 생체 신호를 측정하고, 환자 를 검사실로 안내한 다음, 검사 중에 의사를 돕는 것이다. 컨트롤러는 로봇이 이러한 기능 사양을 이행하는 데 필요한 모든 컴포넌트들을 관리할 수 있다. 컨트롤러은 로봇이 존재하는 폐쇄되고 정의된 세계를 생 성할 수 있다. 각각의 로봇은 다른 로봇과 구별하기 위해 고유한 ID를 가질 수 있다. 설정 프로세스의 일부로서 관리자가 (포털 57을 통해) 입력한 각각의 데이터 세트는 고유한 고객 번호를 또한 가질 수 있다. 초기화 중에 로봇 에 다운로드된 데이터는 고유하지 않을 수 있다. 2개의 다른 ID를 가진 2개의 로봇을 가진 관리자는 둘 다 동일한 환경에서 작동할 수 있으므로 유사하거나 동일한 데이터를 가질 수 있다. 각 로봇 ID는 피처 세트를 가 리킬 수 있다. 도 6에 도시된 바와 같이, 각 로봇은 다르거나, 유사하거나, 동일한 피처 세트를 포함할 수 있다. 각각의 피처는 기능하는데 필요한 피처 요건들의 세트를 가질 수 있다. 예를 들어, 내비게이션은 장애물 회피를 위해 이미지 프로세싱에 의존할 수 있다. 이를 통해 스크립터(관련된 스크립트에 따라)는 초기화 프 로세스 중에 어떤 피처들이 어디로 가야하는지, 어떤 데이터를 다운로드해야 하는지를 정확히 알 수 있다. 또한 로봇의 의도된 기능에 따라 가상 환경 컨테이너를 로봇에 적절히 할당할 수 있다. 로봇이 자신의 가상 환경 컨테이너들 및 관련 데이터로 초기화되면 작동을 위해 부팅될 수 있다. 피처 요소 가상 컨테이너는 앞서 설명한 바와 같이 피처들에 대한 기능 및 지능을 제공할 수 있다. 도 7b는 음성, 시각, 이동성 및 오디오와 같은 피처들을 나타내는 가상 컨테이너들(32a-d)을 도시한다. 도시되지 않은 다른 특징도 사용될 수 있음을 이해할 수 있을 것이다. 로봇 UI는 환자 또는 고객과 통신하고 이로부터 입력을 수신하는데 사용될 수 있다. 여기에서 위에서 논의 한 바와 같이, 로봇은 통신이 이루어지고 판독값(예: 환자 생체 지표)을 수집할 수 있도록 하는 마이크, 스 피커, 카메라 및 센서와 같은 액세서리들와 로봇 팔과 같이 특정 작업을 수행하는 부속 장치를 포함할 수 있다. 로컬 데이터베이스는 맵, 위치 이름, 인식된 사람 등과 같이 피처 요소 가상 컨테이너가 작동하기 위해 필요로 하는, 초기화 프로세스 동안 서버 데이터베이스로부터 다운로드된 데이터의 서브세트를 저장할 수 있다. 서버으로부터 수신된 모든 데이터에는 업로드된 시점의 타임스탬프가 포함될 수 있다. 로컬 데이터베 이스는 메모리 모듈, 하드 디스크 드라이브(HDD) 또는 솔리드 스테이트 드라이브(SSD)일 수 있다. 서버와 로봇 사이에 진행 중인 업데이트가 있을 수 있다. 서버은 로봇에 대한 소프트웨어 및 데이터 업데이트를 가질 수 있고, 로봇은 데이터 요청을 서버에 제공할 수 있다. 시스템 데이터도 지속 적으로 업데이트될 수 있다. 예를 들어, 업데이트된 데이터가 고객 데이터인 경우, 업데이트 프로세스는 먼저 관리자가 포털을 통해 시스템의 임의의 데이터를 추가하거나 빼야할 것을 요구한다. 또 다른 일례는 얼굴 인식 사진을 필요로 하는 새로운 직원을 추가하는 경우이거나 또는 환자가 퇴원해서 얼굴 인식 사진을 삭 제할 수 있는 경우이다. 다른 일례는 지도 및 위치 이름 등이 변경되는 경우이다. 서버 측 업데이트가 있는 경우, 서버 업데이터는 로봇 ID가 정보 업데이트의 범위에 속하는 모든 로봇들에 대해 전체 및/또는 일부 업데이트가 필요하다는 것을 라우터에 핑(ping)할 수 있다. 라우터는 로컬 데 이터베이스의 데이터 타임스탬프에 따라 업데이트가 신규한 것인지를 체크한 다음, 업데이트할 가상 컨테이 너의 이름과 함께 스크립터에 메시지를 보낼 수 있다. 요소 피처 가상 컨테이너, 라우터 및 컨트롤 러을 포함하여 모든 가상 컨테이너가 업데이트될 수 있다. 컨트롤러는 현재 설치되어 있지 않은 스크립트 또는 스크립트의 일부/코드 집합을 로봇이 필요로 하거 나 그 도움을 받을 수 있다고 판단할 수 있다. 컨트롤러는 로봇의 성능이 임의의 시점에서 또는 전체적으로 또는 평균적으로 설정된 횟수만큼 임계값 아래에 있다고 판단할 수 있다. 또한, 컨트롤러는 작업의 성능이 최적이 아니거나 불완전하거나 실패했는지도 판단할 수 있다. 컨트롤러는 로봇에 필요한 추가 스크립트 또는 가상 환경 컨테이너 또는 일반 정보가 누락되어 서버에서 다운로드해야 하는지 여부도 판단할 수 있다. 이러한 컨트롤러는 로봇 업데이터를 더 포함할 수 있다. 로봇 업데이터는 이전 업데이트 이후 일 정 시간이 지났음을 판단할 수 있다. 일례는 로봇이 네비게이션 중에 원하는 목적지에 도달하지 못하게 하 는 장애물을 만나거나 음성 또는 음성 인식에 반복적으로 실패하는 경우를 들 수 있다. 로봇 업데이터는 또한 서버에서 이용가능할 수 있는 로봇에 필요한 추가 스크립트 또는 가상 컨테 이너 또는 일반 정보가 있는지 여부를 판별할 수 있다. 컨트롤러는 인터넷에 연결되거나 인터넷에 다시 연 결될 때 초기화기에 업데이트를 수신하라는 요청을 시작할 수 있다. 스크립터는 추가 스크립트 또는 가 상 컨테이너를 다운로드할 수 있다. 서버 데이터베이스는 로봇에 대한 모든 사용가능한 소프트웨어를 저장할 수 있다. 로봇에 대한 적 절한 새로운 소프트웨어를 초기화기가 서버 데이터베이스에서 식별할 수 없는 경우, 업데이트는 취소된 다. 업데이트 검색을 위한 조건은 로봇의 요청에 의해 결정되거나 또는 컨트롤러가 수행한 임의의 성능 분 석 결과에 대한 서버측 분석에 의해 결정될 수 있다. Ping 인식기는 어떤 로봇들이 서버에 현재 연결되어 있는지를 알 수 있으며, 이들 로봇들 중 데이 터 업데이트와 연관된 로봇 ID를 가진 로봇을 전체적으로 또는 부분적으로 알 수 있다. 그런 다음 서버 업데이 터는 현재 서버에 연결된 모든 로봇들과 이들 중 데이터 업데이트와 연관된 로봇 ID를 가진 로봇 들에게 업데이트 메시지를 보낼 수 있다(그리고 결국에는 아직 서버에 연결되지 않은 모든 로봇들에게도, 이들이 종내에는 서버에 연결될 때 도달할 것이다). 서버 관리자는 업데이트가 언제 발생할지 결정할 수 있 거나, 또는 로봇이 서버에 연결되어 있으며 작업들 사이에 다운타임이 있는 시점에서 라우터가 업 데이트를 다운로드하거나 또는 이 둘의 조합을 사용할 수 있다. 업데이트는 라우터를 통해 전송된 서버 데이터베이스의 서버 데이터가 로컬 데이터베이스에 로컬로 저장되게 할 수 있다. 라우터는 업데이트 중에 나중에 참조할 수 있도록 이 정보를 로컬 데이터베이스에 저장할 수 있다. 서버로부터 업데이트가 가능한 경우, 서버 업데이터는 라우터에게 핑(ping)할 수 있으며, 라우터 는 업데이트할 가상 컨테이너의 이름이 포함된 메시지를 스크립터로 전송한다. 스크립터은 API 호 출을 사용하여, 업데이트된 가상 컨테이너를 서버로부터 다운로드할 수 있다. 업데이트된 가상 컨테이너가 다운로드되면, 스크립터은 컨트롤러과 통신하여 로봇이 중요한 작업 중간에 있는 경우 로봇을 중단 하지 않도록 로봇을 다시 시작할 최적의 시간을 결정할 수 있다. 로봇은 해당 작업에 대해 로봇을 초기화하기 위해 서버와의 네트워크 연결을 필요로 한다. 또한, 로봇이 서버으로부터 임의의 업데이트(예를 들어, 업데이트된 내비게이션 맵)를 수신하기 위해서 네트워크 연결이 필요하며, 그 반대의 경우에도 마찬가지 이다. 라우터는 \"I Am Alive\" 핑(ping) 신호를 보낼 수 있다. 핑 신호는 로봇이 서버과 온라인 상태일 때 핑 (ping) 인식기에 의해 수신될 수 있다. 라우터는 서버에 핑을 보내도록 설정된 내부 클록을 포함할 수 있다. 핑 신호는 5분마다, 매시간마다, 매10분마다, 1분, 1밀리초 등과 같이 미리 정의된 시간 간격으로 전 송될 수 있다. 각각의 시간 간격에서 라우터는 제공된 URL 뿐만 아니라 로봇의 ID를 사용하여 핑 인식기 에 API 호출을 수행하여, 로봇이 온라인 상태임을 서버에 알릴 수 있다. 따라서, 로봇은 일반적으로 로봇의 프로세서들에게 부과되는 힘든 프로세싱의 대부분을 오프로드할 수 있으 며, 따라서 더 작고 저렴한 프로세서들이 설치되게 할 수 있다. 이는 성능과 비용을 개선하는데 유용할 수 있다. 예를 들어, 모든 로봇 상에서 모든 가상 컨테이너들을 다운로드하고 작동시키면, 서버 중앙 프로세싱 장 치(CPU)에 과부하가 걸리거나 심지어 망가질 수 있으며, 작동하려면 훨씬 더 크고 비싼 서버 CPU가 필요할 수 있다. 각 로봇이 특정 기능에 필요한 가상 컨테이너만을 실행하는 것이 훨씬 더 효율적이고 비용효율적이다. 또 한, 중앙 서버를 갖고, 동일하거나/상이한 작업들을 수행하는 여러 로봇을 서빙하는 것은, 하나의 로봇의 업데 이트가 다른 로봇에 도움이 될 수 있으므로 유리할 수 있다. 구체적으로 달리 명시하지 않는 한, 앞서 논의한 내용에서 알 수 있듯이, 명세서 전체에서 \"프로세싱\", \"컴퓨팅\", \"계산\", \"결정\" 또는 이와 유사한 용어를 사용한 논의는 컴퓨팅 시스템의 레지스터 및/또는 메모리 내의 데이터를 컴퓨팅 시스템의 메모리, 레지스터 또는 이와 유사한 다른 정보 저장, 전송 또는 표시 장치 내의 다른 데이터로 조작 및/또는 변환하는, 클라이언트/서버 시스템, 모바일 컴퓨팅 디바이스, 스마트 어플라이언스, 클라우드 컴퓨팅 유닛 또는 유사한 전자 컴퓨팅 디바이스 등과 같은 임의 유형의 범용 컴퓨터의 동작 및/또는 프로세스를 지칭한다는 것을 알 수 있다. 본 발명의 실시예는 본 명세서에서의 동작을 수행하기 위한 장치를 포함할 수 있다. 이러한 장치는 원하는 목적 을 위해 특별히 구성될 수 있거나, 일반적으로 적어도 하나의 프로세서와 적어도 하나의 메모리를 갖는 컴퓨팅 장치 또는 시스템을 포함할 수 있으며, 이는 컴퓨터에 저장된 컴퓨터 프로그램에 의해 선택적으로 활성화되거나 재구성된다. 소프트웨어에 의해 지시될 때 결과적인 장치는 범용 컴퓨터를 본 명세서에서 논의된 바와 같이 창 의적인 요소로 전환할 수 있다. 명령들은 원하는 컴퓨터 플랫폼과 함께 작동하는 창의적인 장치를 정의할 수 있 다. 이러한 컴퓨터 프로그램은 광 디스크, 자기 광 디스크, 판독 전용 메모리(ROM), 휘발성 및 비휘발성 메모리, 랜덤 액세스 메모리(RAM), 전기적으로 프로그래밍가능한 판독 전용 메모리(EPROM), 전기적으로 소거 및 프로그래밍가능한 판독 전용 메모리(EEPROM), 자기 또는 광 카드, 플래시 메모리, 디스크 온 키 또는 전자 지침 을 저장하고 컴퓨터 시스템 버스에 결합할 수 있는 다른 유형의 미디어를 포함하되 이에 국한되지 않는 컴퓨터 판독 가능 저장 매체에 저장될 수 있다. 컴퓨터 판독 가능 저장 매체는 클라우드 스토리지에 구현될 수도 있다. 일부 범용 컴퓨터는 데이터 네트워크 및/또는 모바일 통신 네트워크와의 통신을 가능하게 하기 위해 적어도 하 나의 통신 요소를 포함할 수 있다. 여기에 제시된 프로세스 및 디스플레이는 어떤 특정 컴퓨터 또는 다른 장치와는 본질적으로 관련이 없다. 다양 한 범용 시스템은 여기의 가르침에 따라 프로그램과 함께 사용될 수 있거나, 원하는 방법을 수행하기 위해 보다 특수화된 장치를 구성하는 것이 편리할 수 있다. 이러한 다양한 시스템에 대한 원하는 구조는 아래 설명에서 나 타난다. 또한, 본 발명의 실시예는 어떤 특정 프로그래밍 언어와 관련하여 설명되지 않는다. 다양한 프로그래밍 언어가 여기에 설명된 대로 발명의 가르침을 구현하는데 사용될 수 있음을 알 수 있을 것이다. 본 발명의 특정한 특징들이 여기에 설명되고 예시되었지만, 많은 수정예들, 대체예들, 변경예들 및 등가물들이 이제 해당 분야의 통상의 기술자에게 떠오를 것이다. 따라서 첨부된 청구항은 본 발명의 진정한 정신에 속하는모든 수정예들 및 변형예들을 포괄하도록 의도된 것으로 이해되어야 한다."}
{"patent_id": "10-2024-7029168", "section": "도면", "subsection": "도면설명", "item": 1, "content": "발명으로 간주되는 주제는 명세서의 결론 부분에서 특별히 지적되고 명확하게 청구된다. 하지만, 조직 및 작동 방법, 그리고 그 목적, 특징 및 이점과 관련하여 본 발명은 첨부 도면과 함께 읽혀질 때 다음의 자세한 설명을 참조하면 가장 잘 이해될 수 있다. 도면들은 다음과 같다. 도 1은 기본적인 운영 소프트웨어 아키텍처를 보여준다. 도 2는 서버측 구조를 보여준다. 도 3은 초기화를 위한 흐름도이다. 도 4는 서버로부터의 데이터 업데이트를 보여주는 흐름도이다. 도 5는 로봇으로부터의 데이터 업데이트를 보여주는 흐름도이다. 도 6은 본 발명의 바람직한 실시예에 따라 구성되고 동작하는, 오프라인에서 작동하도록 로봇을 초기화하기 위 한 시스템의 개략적인 도면이다. 도 7a 및 도 7b는 본 발명의 바람직한 실시예에 따라 구성되고 동작하는, 초기화시 및 런타임시에서 도 6의 로 봇 프로세서의 요소들의 개략적인 도면이다. 도 8은 본 발명의 바람직한 실시예에 따라 구성되고 동작하는 도 6의 프리프로세서의 요소들의 개략적 도면이다. 설명의 단순성과 명확성을 위해서, 도면에 도시된 요소들이 반드시 축척대로 그려진 것은 아니라는 점을 이해할 수 있을 것이다. 예를 들어, 명확성을 위해 일부 요소들의 치수는 다른 요소에 비해 과장되어 있을 수 있다. 또 한 적절하다고 생각되는 경우, 도면 간에 참조 번호를 반복하여 해당 또는 유사한 요소를 나타낼 수도 있다."}
