{"patent_id": "10-2014-7024197", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2014-0128381", "출원번호": "10-2014-7024197", "발명의 명칭": "컨텍스트 기반 검색 쿼리 형성 기법", "출원인": "마이크로소프트 코포레이션", "발명자": "바이 펭"}}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "문서 내의 텍스트에 대한 사용자의 선택을 수신하는 단계와,상기 선택된 텍스트에 대해 하나 이상의 쿼리 확장 기법(query expansion techniques)을 적용하는 것에 의해 적어도 부분적으로 생성된 쿼리들을 포함하는 복수의 후보 쿼리들을 획득하는 단계와,하나 이상의 처리 구성요소(processing elements)에 의해 상기 복수의 후보 쿼리들에 대해 랭킹을 매기는 단계를 포함하되, 상기 랭킹은 (i) 상기 선택된 텍스트와 추가 텍스트의 전부 또는 일부를 포함하는 상기 문서 내의 텍스트를 포함하는 컨텍스트(context)로부터 도출된 언어 모델(language model)과 (ii) 휴먼-리뷰어(human-reviewer)가 상기 쿼리와 쌍을 이루는(paired with the query) 문서의 컨텐트와 관련된 쿼리를 구비하는 것으로 식별하는 문서와 쿼리 쌍(document and query pairs) 세트를 이용하여 트레이닝된 인공지능 시스템(artificial intelligencesystem)에 적어도 부분적으로 기초하여 수행되는방법."}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 쿼리 확장 기법은 쿼리 로그(query log)에 K-평균 알고리즘(K-means algorithm)을 적용하는 것, 쿼리 로그를 파싱(parsing)하여 생성한 2부 쿼리-문서 그래프(bipartite query-document graph) 상에서 랜덤 워크(random walk)를 수행하는 것, 쿼리 로그로부터 생성된 쿼리-흐름 그래프(query-flow graph) 상에서 페이지랭크알고리즘(PageRank algorithm)을 실행하는 것, 쿼리 로그로부터 용어 연관 패턴(term association patterns)을마이닝하는 것 중 적어도 하나를 포함하는방법."}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,상기 컨텍스트는 사전정의된 수의 단어나 문자를 포함하는 상기 문서의 텍스트 부분을 포함하고,상기 텍스트 부분은 상기 선택된 텍스트가 상기 텍스트 부분의 실질적으로 가운데 오도록 위치하는방법."}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 랭킹은 상기 언어 모델에 적어도 부분적으로 기초하고,상기 언어 모델은 상기 복수의 후보 쿼리들 중 하나 내의 단어 수와, 상기 선택된 텍스트 내의 단어 수와, 상기컨텍스트 내의 단어 수에 적어도 부분적으로 기초하는방법."}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "공개특허 10-2014-0128381-3-제 1 항에 있어서,상기 랭킹은 상기 언어 모델에 적어도 부분적으로 기초하고,상기 언어 모델은 상기 복수의 후보 쿼리들 중 하나의 쿼리 내의 단어가 상기 쿼리 내의 바로 직전 단어(immediately preceding word)에 의존하는 바이그램 언어 모델(bi-gram language model)을 포함하는방법."}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1 항에 있어서,상기 복수의 후보 쿼리들을 적어도 부분적으로 상기 랭킹에 따른 순서대로 만든 리스트 내에서 상기 사용자에게제시하는 단계와,상기 사용자에 의한 상기 복수의 후보 쿼리들 중 하나의 선택을 수신하는 단계와,상기 후보 쿼리들 중 상기 선택된 하나를 검색 엔진에 제출하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "컴퓨터-실행가능 명령어를 포함하는 하나 이상의 컴퓨터-판독가능 매체로서,상기 명령어는 프로세서에 의해 실행되어 컴퓨팅 시스템으로 하여금,사용자에 의한 문서 내의 텍스트에 대한 선택을 커맨드(as a command)로서 해석하여 상기 선택된 텍스트에 적어도 부분적으로 기초하여 하나 이상의 검색 쿼리들을 상기 사용자에게 제공하는 것과,상기 선택된 텍스트에 적어도 부분적으로 기초하여 복수의 후보 쿼리들을 획득하는 것과,상기 문서에 의해 제공되는 컨텍스트에 적어도 부분적으로 기초하여 상기 후보 쿼리들의 랭킹을 매기는 것을 수행하도록 하는컴퓨터-판독가능 매체."}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 7 항에 있어서,상기 텍스트에 대한 상기 선택이 상기 사용자가 터치스크린 디스플레이 상에 디스플레이된 텍스트를 가로질러포인팅 도구(pointing implement)를 드래깅하는 것 또는 상기 사용자가 터치스크린 디스플레이 상에 디스플레이된 텍스트 둘레에 대략 원형이나 타원형 형상으로 포인팅 도구를 움직이는 것을 포함하는컴퓨터-판독가능 매체."}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 7 항에 있어서,상기 컨텍스트는 상기 문서 중 상기 선택된 텍스트를 적어도 부분적으로 포함하는 텍스트 섹션을 포함하고,상기 랭킹을 매기는 것은 상기 후보 쿼리들 및 쿼리 집단(query corpus) 중 하나 내의 복수의 단어들에 적어도부분적으로 기초하여 상기 후보 쿼리들의 랭킹을 매기는 바이그램 언어 모델을 사용하는 것을 포함하는공개특허 10-2014-0128381-4-컴퓨터-판독가능 매체."}
{"patent_id": "10-2014-7024197", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 7 항에 있어서,상기 컨텍스트는 상기 문서 중 상기 선택된 텍스트를 포함하는 텍스트 섹션을 포함하고,상기 랭킹을 매기는 것은 문서/쿼리 쌍들(document/query tuples)의 데이터 세트를 사용하는 인공지능 시스템을사용하는 것을 포함하며,상기 문서/쿼리 집합들 각각에서 문서와 쿼리 사이의 대응관계(correspondence)는 휴먼 리뷰어에 의해 인증된것인컴퓨터-판독가능 매체.명 세 서기 술 분 야많은 인터넷 검색 기법은 사용자가 브라우징하고 있는 웹 페이지에 의해 트리거된다. 즉, 사용자는 해당 웹 페 [0001]이지 상의 컨텐츠를 소비한 후 검색을 개시하기로 결정하게 된다. 검색을 구현하기 위해서는 사용자가 웹 페이지를 떠나 검색 엔진에 액세스해야 한다. 사용자는 웹 페이지로부터 단어를 복사하여 검색창에붙여넣기하거나, 검색창 또는 검색 엔진 웹 페이지에 입력하기 위해 직접 검색 쿼리를 작성할 것이다. 이들 검색 쿼리를 생성하는 기법은 모두 명료성의 결여, 복수의 의미를 갖는 검색어, 검색어들 사이의 불분명한 관계등과 같은 단점을 갖고 있다.검색 결과가 나온 후 사용자는 검색 인터페이스를 떠나 웹 브라우징으로 돌아올 수도 있다. 이처럼 웹 페이지 [0002]와 검색 인터페이스를 번갈아 사용하는 것은 비효율적이다. 더욱이, 다양한 사용자 인터페이스(예컨대, 텍스트선택, 복사, 붙여넣기 등)와의 상호작용은 이동전화, 태블릿 컴퓨터, 게임 콘솔, 텔레비전 등과 같이 텍스트 입력 성능이 제한된 장치 또는 폼팩터(form factor)가 작은 장치의 경우 특히 더 불편하다. 전통적인 컴퓨터가아닌 장치를 사용하여 웹 페이지나 기타 전자 문서에 액세스하는 사용자의 수가 증가함에 따라, 문서 소비와 검색을 부드럽게 통합할 필요성 역시 증대될 것이다. 이러한 기능을 수행할 수 있으면서 향상된 검색 쿼리를 제공하는 시스템이 있다면 사용자들에게 유용할 것이다.배 경 기 술개요 [0003]본 개요는 후속하여 발명의 상세한 설명 부분에서 설명되는 개념들 중 선택된 것들을 단순화된 형태로 소개하고 [0004]자 제공되는 것이다. 본 개요는 청구항의 청구대상의 핵심적인 특징이나 필수적인 특징들을 밝히고자 함이 아니며, 청구항의 청구대상의 범위를 결정하는 데 도움이 되고자 함도 아니다.본 개시내용은 웹 페이지나 다른 문서 상의 사용자 관심 영역 및 주변 컨텍스트를 모두 이용하여 복수의 검색 [0005]쿼리를 생성하고 랭킹을 매기는 기법에 대해 설명한다. 웹 페이지를 브라우징하는 동안 사용자는 웹 페이지로부터 텍스트를 선택한다. 텍스트를 선택하면, 복수의 후보 쿼리들을 생성하기 위한 시작점으로서 그 텍스트를사용하라는 커맨드(command)가 생성되는데, 이 쿼리들은 선택된 텍스트와 관련된 결과들을 산출할 수 있는 검색쿼리들이다. 여러 유형의 검색 쿼리 확장 또는 검색 쿼리 재형성 기법을 적용하여 선택된 텍스트로부터 목수의후보 쿼리들을 생성한다. 이어서, 사용자는 이들 검색 쿼리들 중 하나를 선택하여 검색 엔진에 제출할 수있다. 따라서, 브라우징 동작이 검색 동작과 결합되어, 간단히 웹 페이지로부터 텍스트를 선택한 후 후보 쿼리들 중 하나를 선택하는 것에 의해 \"브라우징에서 검색까지\"를 가능하게 하는 인터페이스가 생성된다.후보 쿼리들 세트 중 하나의 검색 쿼리로 사용자를 인도하기 위해, 문서의 컨텍스트가 고려된다. 브라우징된 [0006]웹 페이지에 의해 제공되는 컨텍스트에 비추어 후보 쿼리들을 평가함으로써 각각의 후보 쿼리의 랭킹이 매겨진다. 브라우징된 웹 페이지는 후보 쿼리들의 용어의 불명확성을 해소하거나 후보 쿼리들을 동일한 웹 페이지에공개특허 10-2014-0128381-5-관련된 이전 검색 쿼리들과 비교하는 데 사용될 수 있는 단어들을 포함하고 있을 수 있으므로, 주변 컨텍스트를고려하는 것은 후보 쿼리들의 랭킹을 매기는 데 도움이 된다.후보 쿼리들의 랭킹은 언어 모델, 분류 기법(classification method), 또는 이들의 조합에 의해 수행될 수 [0007]있다. 언어 모델은 선택된 텍스트와 주변 컨텍스트가 주어졌을 때 후보 쿼리의 확률(probability)을 결정하는모델로서 구현될 수 있다. 분류 기법은 웹 페이지 상의 선택된 텍스트 및 연관된 쿼리들을 포함하는 트레이닝데이터를 이용한다. 휴먼 리뷰어(human reviewers)는 웹 페이지의 선택된 텍스트로 인해 사용자가 그 연관 검색 쿼리를 만들게 될지를 판단한다. 그렇다고 판단되면, 선택된 텍스트와 쿼리 쌍은 머신 학습 시스템(machinelearning system)에 의해 이용되어, 주어진 선택된 텍스트 및 컨텍스트에 대해 후보 쿼리의 신뢰 수준(confidence level)을 예측하는 함수를 학습하게 된다.도면의 간단한 설명첨부하는 도면을 참조하여 발명의 상세한 설명이 기술된다. 도면에서 참조 부호의 최고 자리수는 해당 참조부 [0008]호가 처음 등장하는 도면을 나타낸다. 상이한 도면에서 동일한 참조부호를 사용하는 것은 유사하거나 동일한아이템을 나타내는 것이다.도 1은 쿼리 형성기를 포함하는 정보-처리 시스템을 나타내는 예시적인 아키텍처이다.도 2는 도 1의 아키텍처로부터 예시적인 데이터와 컴포넌트를 개략적으로 나타낸다.도 3은 선택된 텍스트를 갖는 예시적인 문서를 도시한다.도 4는 텍스트 선택을 위한 2가지 예시적인 사용자 인터페이스를 보여준다.도 5는 사용자가 텍스트를 선택하는 것에 응답하여 랭킹이 매겨진 후보 쿼리들의 리스트를 제공하는 예시적인방법을 나타내는 예시적인 흐름도이다.발명을 실시하기 위한 구체적인 내용예시적인 아키텍처 [0009]도 1은 사용자가 로컬 컴퓨팅 장치(104)와 상호작용하여 검색 쿼리를 획득할 수 있는 아키텍처(100)를 [0010]도시한다. 로컬 컴퓨팅 장치(104)는 데스크탑 컴퓨터, 노트북 컴퓨터, 태블릿 컴퓨터, 스마트폰, 게임 콘솔,텔레비전 등과 같은 임의의 컴퓨팅 장치일 수 있다. 로컬 컴퓨팅 장치(104)는 네트워크(106)를 통해 하나 이상의 네트워크-액세스가능 컴퓨팅 장치(108)와 통신할 수 있다. 네트워크(106)는 LAN, WAN, 인터넷, 전화 네트워크, 케이블 네트워크, 피어-투-피어 네트워크, 메쉬 네트워크 등과 같은 임의의 데이터 통신 네트워크 중 하나이상의 유형일 수 있다. 네트워크-액세스가능 컴퓨팅 장치(108)는 네트워크 서버, 웹 서버, 파일 서버, 슈퍼컴퓨터, 데스크탑 컴퓨터 등과 같은 컴퓨팅 장치들의 임의의 유형 또는 유형들의 조합일 수 있다. 네트워크-액세스가능 컴퓨팅 장치(108)는 하나 이상의 검색 엔진(110)에 통신가능하게 접속되거나 이를 포함할 수 있다. 검색 엔진(들)(110)은 검색 서비스를 제공하는 개체(entity)에 의해 유지되는 하나 이상의 전용 컴퓨팅 장치 상에서 구현될 수 있다.정보-처리 시스템(112)은 하나 이상의 장소에 걸쳐 분산되어 있는 메모리(116)와 하나 이상의 프로세싱 구성요 [0011]소들(114)을 포함한다. 프로세싱 구성요소들(114)은 CPU, GPU(graphical processing units), 싱글 코어 프로세서, 멀티 코어 프로세서, ASIC(application specific integrated circuits) 등의 임의의 조합을 포함할 수있다. 하나 이상의 프로세싱 구성요소(들)(114)은 하드웨어 구현에 더하여 소프트웨어 및/또는 펌웨어로 구현될 수 있다. 프로세싱 구성요소(들)(114)의 소프트웨어 또는 펌웨어 구현은 임의의 적절한 프로그래밍 언어로기술되어 전술한 다양한 기능을 수행하는 컴퓨터- 또는 머신- 실행가능 명령어를 포함할 수 있다. 프로세싱 구성요소(들)(114)의 소프트웨어 구현은 메모리(116) 내에 그 전체 또는 일부가 저장될 수 있다.메모리(116)는 프로세싱 구성요소(들)(114) 상에 로딩되어 실행될 수 있는 명령어들의 프로그램과 이들 프로그 [0012]램의 실행 중에 생성되는 데이터를 저장할 수 있다. 메모리(116) 상에 저장되는 프로그램과 데이터의 예로는로컬 컴퓨팅 장치(104)에 이용가능한 하드웨어 및 소프트웨어 리소스의 동작을 제어하는 운영 체제, 네트워크-액세스가능한 컴퓨팅 장치(들)(108), 하드웨어 장치들과 상호작용하기 위한 드라이버, 네트워크(106) 및 다른컴퓨팅 장치들과 데이터를 주고받을 수 있는 통신 프로토콜, 추가적인 소프트웨어 애플리케이션 등이 있다. 로공개특허 10-2014-0128381-6-컬 컴퓨팅 장치(104) 및/또는 네트워크-액세스가능 컴퓨팅 장치(들)(108)의 구성 및 종류에 따라, 메모리(116)는 (RAM과 같은) 휘발성일 수도 있고, (ROM이나 플래시 메모리와 같은) 비휘발성일 수도 있다.정보-처리 시스템(112)은 착탈가능형 저장부, 비-착탈가능형 저장부, 로컬 저장부 및/또는 원격 저장부와 같은 [0013]추가적인 컴퓨터-판독가능 매체도 포함할 수 있다. 메모리(116) 및 임의의 연관된 컴퓨터-판독가능 매체는 컴퓨터 판독가능 명령어, 데이터 구조, 프로그램 모듈 및 기타 데이터의 저장을 제공할 수 있다. 컴퓨터-판독가능 매체는 적어도 두 가지 종류의 컴퓨터-판독가능 매체, 즉, 컴퓨터 저장 매체와 통신 매체를 포함할 수 있다.컴퓨터 저장 매체는 컴퓨터 판독가능 명령어, 데이터 구조, 프로그램 모듈, 또는 기타 데이터와 같은 정보 저장 [0014]을 위한 임의의 기법이나 방법에서 구현되는 휘발성 및 비휘발성, 착탈가능형 및 비착탈가능형 매체를포함한다. 컴퓨터 저장 매체의 예로는 RAM, ROM, EEPROM, 플래시 메모리 또는 기타 메모리 기법, CD-ROM, DVD또는 기타 광학 저장부, 자기 카세트, 자기 테이프, 자기 디스크 저장부 또는 기타 자기 저장 장치, 또는 기타저장 장치, 또는 컴퓨터에 의해 액세스될 수 있는 정보를 저장하는 데 사용될 수 있는 기타 비-전송형 매체가있으나, 여기에 제한되지는 않는다.반면, 통신 매체는 컴퓨터 판독가능 명령어, 데이터 구조, 프로그램 모듈, 또는 기타 데이터를 반송파와 같은 [0015]변조된 데이터 신호 또는 기타 전송 메커니즘에 구현할 수 있다. 본 명세서의 정의에 따르면 컴퓨터 저장 매체는 통신 매체를 포함하지 않는다.정보-처리 시스템(112)은 로컬 컴퓨팅 장치(104)와 네트워크-액세스가능 컴퓨팅 장치(들)(108) 중 하나 또는 모 [0016]두 상에 그 전체 또는 일부가 존재할 수 있다. 따라서, 정보-처리 시스템(112)은 다양한 물리적 및 데이터 컴포넌트가 하나 이상의 장소에 위치하면서 함께 작동하여 정보-처리 시스템(112)의 역할을 수행하는 분산형 시스템일 수 있다. 어떤 구현예에서는, 정보-처리 시스템(112)의 모든 특징이 로컬 컴퓨팅 장치(104) 상에 존재할수 있다. 다른 구현예에서, 로컬 컴퓨팅 장치(104)는 단순히 디스플레이 데이터를 수신하고 사용자 입력 신호를 네트워크-액세스가능 컴퓨팅 장치(들)(108)과 같은 다른 장치로 전송하는 씬 클라이언트(thin client)일 수도 있는데, 이는 정보-처리 시스템(112)을 포함한다.정보-처리 시스템(112)은 사용자(102)를 위해 검색 쿼리를 형성하는 쿼리 형성기(118)를 포함할 수 있다. 어떤 [0017]실시예에서, 쿼리 형성기(118)는 메모리(116) 내에 전체 또는 부분적으로 존재하는 저장부일 수 있다. 다른 실시예에서, 쿼리 형성기(118)는 ASIC의 일부와 같이 프로세싱 구성요소(들)(114)의 일부로서 구현될 수도 있다.정보-처리 시스템(112) 자체와 같이, 쿼리 형성기(118)는 로컬 컴퓨팅 장치(104)와 네트워크-액세스가능 컴퓨팅장치(들)(108) 중 하나 또는 모두 상에 전체 또는 일부가 존재할 수 있다. 쿼리 형성기(118)의 일부 또는 전부가 복수의 컴퓨팅 장치 상에 중복적으로 위치하는 경우, 어느 컴퓨팅 장치를 사용하여 쿼리 형성기(118)를 구현할지는 관련 처리 속도, 네트워크(106)를 통한 정보 전송 속도 및/또는 다른 요인에 따라 선택될 수 있다.도 2는 도 1에 도시한 아키텍처(100)의 쿼리 형성기(118)과 다른 부분을 통한 정보와 데이터의 흐름을 나타내고 [0018]있다. 사용자(102)가 문서로부터 텍스트를 선택하면, 쿼리 형성기(118)에 대한 입력이 제공되어 쿼리를 형성하도록 한다. 선택된 텍스트(202)와 컨텍스트(204)는 검색 개시 모듈(206)에 의해 수신된다. 선택된 텍스트(202)는 문서로부터 텍스트를 선택하기 위한 임의의 통상적인 메커니즘을 이용하여 텍스트의 단락(들)을 선택하거나 나타내도록 로컬 컴퓨팅 장치(104)와 상호작용하는 사용자(102)에 의해 선택될 수 있다. 컨텍스트(204)는선택된 텍스트(202)를 둘러싸거나 그 주위에 위치하는 다른 텍스트를 포함할 수 있다. 컨텍스트(204)는 해당문서의 의도되거나 예상되는 용도에 기초하는 문서의 분류(classification)도 포함할 수 있다. 예를 들어, 문서가 웹 페이지이고, 그 웹 페이지가 상품과 서비스 판매를 위한 상업 웹 페이지인 것으로 식별되면, 컨텍스트(204)는 사용자(102)가 구매할 상품이나 서비스를 검색할 것 같다고 인식할 것이다. 텍스트(202)를 선택하기전의 사용자(102)의 이전 동작 또한 컨텍스트(204)를 제공할 수 있다. 이를테면, 사용자(102)가 최근 제출한검색 쿼리들은 사용자가 현재 검색하고 있는 토픽이나 분야에 관한 컨텍스트(204)를 제공할 수 있다.검색 개시 모듈(206)은 해당 선택된 텍스트(202)를 선택한 사용자로부터의 단일 입력을 텍스트의 선택 [0019](selection of text)으로 해석하고, 그 선택된 텍스트(202)에 기초하여 검색 쿼리를 생성하라는 커맨드로 해석한다. 예컨대, 사용자(102)가 문서로부터 연속하는 일련의 텍스트를 선택하도록 커서를 움직인다면, 그 사용자(102)는 검색 쿼리 제안을 받기 위해 이 텍스트를 다른 인터페이스로 붙여넣기 하거나 이동시킬 필요가 없다.검색 개시 모듈(206)은 텍스트를 선택하는 것 자체를 하나 이상의 검색 쿼리를 생성하라는 커맨드로 해석할 수있다. 이처럼 검색 개시 모듈(206)이 두 가지 역할을 수행하므로, 사용자는 단 한 번의 입력 또는 로컬 컴퓨팅장치(104)와의 상호작용만으로 텍스트를 선택하고 검색 쿼리를 요청할 수 있게 된다.공개특허 10-2014-0128381-7-검색 개시 모듈(206)은 선택된 텍스트(202), 컨텍스트(204), 검색 쿼리를 생성하라는 커맨드를 쿼리 형성기 [0020](118)에 전달한다. 쿼리 형성기(118)는 선택된 텍스트(202)로부터 후보 쿼리들을 생성하는 후보 쿼리 생성기(208)를 포함할 수 있다. 후보 쿼리 생성기(208)는 선택된 텍스트(202)에 쿼리 확장 또는 쿼리 재형성 기법을적용한다. 후보 쿼리 생성기(208)는 동의어 포함시키기, 단어의 대체할 수 있는 형태학적인 형태(alternatemorphological forms)를 추가하기, 철자가 틀린 단어의 철자를 고치기 및/또는 단어의 대체할 수 있는 철자를제공하기 등을 이용하여 선택된 텍스트(202)로부터 후보 쿼리들을 생성할 수 있다. 사용자가 관심 텍스트를 정확하게 선택하지 못하면, 예를 들어, (손가락을 사용하여) 텍스트 주위에 타원을 그림으로써 텍스트를선택하면, 의도치 않게 한 단어나 어구가 두 부분으로 나뉘게 될 수도 있다. 사후 처리 작업은 선택된 텍스트로부터 무관한 문자들을 제거하거나 관련된 문자들을 앞이나 뒤에 덧붙이는 것을 포함할 수 있다. 어떤 실시예에서는 문서와 연관되는 쿼리들의 쿼리 로그(query log)를 사용하여 후보 쿼리들을 생성한다. 쿼리 로그를 사용하는 쿼리 확장 기법으로는 쿼리 로그에 K-평균 알고리즘(K-means algorithm)을 적용하는 것, 쿼리 로그를 파싱(parsing)하여 생성한 2부 쿼리-문서 그래프(bipartite query-document graph) 상에서 랜덤 워크(randomwalk)를 수행하는 것, 쿼리 로그로부터 생성된 쿼리-흐름 그래프(query-flow graph) 상에서 페이지랭크 알고리즘(PageRank algorithm)을 실행하는 것, 쿼리 로그로부터 용어 연관 패턴(term association patterns)을 마이닝하는 것 등이 있다.후보 쿼리 생성기(208)는 후보 쿼리들을 직접 생성할 수도 있고, 선택된 텍스트(202)를 다른 모듈이나 쿼리 형 [0021]성기(118) 외부의 시스템(이를테면, 검색 엔진과 연관된 쿼리 재형성기 모듈)으로 전달할 수도 있다. 후보 쿼리 생성기(208)는 선택된 텍스트(202)를 다른 시스템이나 모듈로 전달한 후 외부 모듈이나 시스템으로부터 후보쿼리들을 수신함으로써 후보 쿼리들을 효과적으로 생성할 수 있다. 후보 쿼리 생성기(208)는 선택된 텍스트(202)로부터 임의의 개수의 쿼리를 생성할 수 있다. 어떤 실시예에서, 후보 쿼리 생성기(208)에 의해 생성된후보 쿼리의 개수는 사전정의된 수일 수 있는데, 예를 들어, 3 개일 수도 있고, 10 개일 수도 있다.다수의 후보 쿼리를 획득한 후, 쿼리 랭킹 모듈(210)은 이들 쿼리가 선택된 텍스트(202)와 컨텍스트(204)에 대 [0022]응할 확률이나 가능성에 기초하여 후보 쿼리들의 랭킹을 매긴다. 쿼리 형성기(118)는 후보 쿼리들을 생성하고,검색 엔진(110)으로 질의를 제출하지 않고도 이들 후보 쿼리들의 랭킹을 매기는 것을 모두 수행함으로써, 검색엔진(110)의 부담을 줄일 수 있다.쿼리 랭킹 모듈(210)은 하나 이상의 랭킹 기법에 따라 하나 이상의 후보 쿼리들의 랭킹을 매길 수 있다. 사용 [0023]될 수 있는 랭킹 기법으로는 언어 모델(212)과 인공지능(AI) 시스템(214)이 있다. 각각은 독립적으로 사용될수도 있고 함께 사용될 수도 있다.언어 모델(212)은 컨텍스트(204)와 선택된 데이터(202)의 바이그램 언어 모델(bi-gram language model)을 생성 [0024]할 수 있다. 컨텍스트(204)는 선택된 텍스트(202)를 포함하는 문서의 텍스트 부분을 포함할 수 있다. 따라서,컨텍스트(204)는 선택된 텍스트에 문서 중의 추가 텍스트를 더한 것일 수 있다. 언어 모델(212)은 각 후보 쿼리들 내의 단어 수, 선택된 텍스트(202) 내의 단어 수, 컨텍스트(204)를 구성하는 텍스트 부분 내의 단어 수에기초하여 후보 쿼리 생성기(208)로부터의 복수의 쿼리들의 랭킹을 결정할 수 있다. 언어 모델(212)을 구현하는세부사항에 대해서는 후술하기로 한다.인공지능 시스템(214)은 지원 벡터 머신(support vector machine), 신경회로망(neural network), 엑스퍼트 시 [0025]스템(expert system), 베이지안 신뢰 네트워크(Bayesian belief network), 퍼지 로직 엔진(fuzzy logicengine), 데이터 퓨전 엔진(data fusion engine) 등과 같은 임의 유형의 인공지능 또는 머신 시스템으로서 구현될 수 있다. 인공지능 시스템(214)은 휴먼 라벨 트레이닝 데이터(human-labeled training data)로부터 생성될수 있다. <문서, 쿼리> 쌍의 집합(corpus)은 문서 및 과거의 문서 소비와 하나 이상의 사용자의 검색 습성으로부터 획득한 이들 문서와 연관된 쿼리들을 나타내는데, 이는 트레이닝 데이터의 전부 또는 일부 역할을 할 수있다. 어떤 실시예에서, <문서, 쿼리>쌍은 검색 엔진(110)에 자신의 브라우징 및 검색 습성을 제공하도록 선택한 사용자들의 검색 엔진(110)으로부터 얻은 검색 로그(search logs)로부터 획득될 수 있다. 브라우징 및 검색데이터는 자신의 데이터를 기증하기로 선택한 사용자들의 프라이버시를 보호하도록 익명화(anonymized)될 수 있다. 휴먼 라벨러(human labeler)들은 <문서, 쿼리>쌍을 리뷰하고 문서와 쿼리 사이에 인과관계(causalrelationship)이 존재하는지 판단한다. 달리 말해서, 휴먼 라벨러들은 <문서, 쿼리> 쌍의 컨텐트가 사용자로하여금 그 쌍 내의 쿼리를 제출하도록 하는 가능성에 대한 자신들의 주관적인 평가에 기초하여 각 쌍에 라벨을부여한다. 인공지능 시스템(214)의 구현을 위한 세부사항은 후술하도록 한다.쿼리 형성기(118)가 쿼리들을 형성하고 이들 쿼리들에 대해 랭킹을 매기면, 사용자(102)에게는 랭킹이 매겨진 [0026]공개특허 10-2014-0128381-8-쿼리들의 리스트가 제공될 것이다. 높은 랭킹을 갖는 쿼리들은 낮은 랭킹을 갖는 쿼리들에 비해 리스트 내에서더 앞자리 또는 더 눈에 잘 띄는 자리에 배치될 수 있다. 사용자(102)는 후보 쿼리들 중 하나를 선택하고 그쿼리에 기초하여 하나 이상의 엔진들(110) 상에서 검색을 개시할 수 있다.검색 엔진(들)(110)은 쿼리를 네트워크(106)나 다른 데이터 저장부에 제출하고, 검색 알고리즘, 선택된 쿼리, [0027]네트워크(106) 내에서 이용가능한 데이터에 따라 검색 결과(216)를 수신할 수 있다. 검색 엔진들(110)은 선택된 검색 쿼리를 처리하기 위해 통상의 검색 기법을 사용할 수 있다.예시적인 언어 모델 [0028]언어 모델(212)은 컨텍스트(204)에 기초하여 후보 쿼리들의 랭킹을 매긴다. 후보 쿼리들은 조건부 확률 [0029](conditional probability) p(q｜s,c)에 의해 랭킹이 매겨지는데, 이는 선택된 텍스트(202: s로 표시)와 컨텍스트(204: c로 표시)가 주어졌을 때 후보 쿼리들 중 하나의 쿼리인 쿼리 q가 생성될 확률을 나타낸다. 언어 모델(212)은 q = qw1, qw2, qwNq, s = sw1, sw2, swNs, c = cw1, cw2, cwNc라고 가정하는데, qwi, swi, cwi는 각각 쿼리 q, 선택된 텍스트 s, 컨텍스트 c 내의 i번째 단어를 나타낸다. 언어 모델(212)에서, Nq는 쿼리 q의 단어 길이, Ns는 선택된 텍스트 s의 단어 길이, Nc는 컨텍스트 c의 단어 길이를 나타낸다.언어 모델(212)은 선택된 텍스트 s와 컨텍스트 c가 주어지면 각 쿼리 단어 qwi는 그 직전 단어 qwi-1에만 의존한 [0030]다고 가정한다. 이 가정은 바이그램 언어 모델의 경우 적용되는 가정과 유사하다. 유니그램 모델(uni-grammodel)은 쿼리 내의 단어 수준의 관계(term-level relationship)는 포착하지 못하므로 어떤 실시예에는 바이그램 표시가 바람직하다. 반면, n-그램 (n≥3) 방식은 계산 복잡도가 높아 온라인 쿼리 제안용으로는 지나치게시간이 많이 소요될 우려가 있다. 그러나, 프로세싱 성능이 계속해서 증가함에 따라 3-그램 (또는 그 이상) 방식의 계산 복잡도로 인한 시간 소요가 줄어들게 될 것이므로, 언어 모델(212)은 n-그램 (n≥3) 방식을 수용하도록 조정될 수 있다.위와 같은 정의 및 가정에 기초하면, 선택된 텍스트(202)와 컨텍스트(204)가 주어졌을 때 후보 쿼리들 중 하나 [0031]의 쿼리가 생성될 확률은 아래와 같다.[0032]위 수식에서는 쿼리가 길수록 확률이 작아진다. 이러한 영향을 완화하기 위해 확률에 추가적인 가중치를 곱하 [0033]되, 긴 쿼리에는 큰 가중치를 곱하도록 한다. 수정된 확률은 다음과 같이 계산될 수 있다.[0034]여기에서 Λ는 1보다 큰 상수이다. [0035]p(qwi｜s, c)를 계산하기 위한 공식은 [0036][0037]이며, 후보 쿼리들 각각이 동일한 선택된 텍스트 s 및 컨텍스트 c에 기초하여 랭킹이 매겨지므로 p(s, c)는 무 [0038]시해도 된다.전체 쿼리 집합(global query corpus)은 p(qwi) 값을 추정하는 데 사용될 수 있다. 쿼리 집합 Q가 주어진 [0039]경우, p(qwi)의 값은 다음과 같이 계산된다.[0040]여기서, ｜Q(qwi)｜는 qwi를 포함하는 쿼리 집합 내의 쿼리 수를 나타내고, ｜Q｜는 전체 쿼리 집합 내의 쿼리의 [0041]총 수를 나타낸다.공개특허 10-2014-0128381-9-수식 (4)를 평탄화한 버전(smoothed version)은 [0042][0043]이며, a는 0과 1 사이의 상수이다. [0044]수식 (3)에서 또 다른 확률을 다음과 같이 유도할 수 있다. 임의의 쿼리 단어 qwi에 대해 선택된 텍스트 s와 [0045]컨텍스트 c는 독립적이라고 가정한다.[0046]함수를 단순화하기 위해, 언어 모델(212)은 임의의 쿼리 단어 qwi에 대해 선택된 텍스트 s 또는 컨텍스트 c의 [0047]단어들이 독립적으로 생성될 수 있다고 가정한다. 따라서,[0048]이며, 여기서 p(swj｜qwi)는 qwi가 존재할 때 swj가 qwi와 함께 나타날 확률이다. 이 확률은 전체 쿼리 집합을 [0049]이용하여 계산될 수 있는데:[0050]｜Q(swj)∩Q(qwi)｜는 swj와 qwi를 전체 쿼리 집합 내에 포함하는 쿼리들의 개수이고, ｜Q(qwi)｜는 단어 qwi를 [0051]포함하는 쿼리 집합 내의 쿼리들의 개수이며, a ∈ (0, 1)이 평탄화에 사용된다.p(cwj｜qwi)의 값은 동시에 계산될 수 있다. 수식 (7) 및 (8)에 따르면, p(s｜qwi)와 p(c｜qwi)의 값들은 Ns가 [0052]항상 Nc보다 작으므로 균형이 맞지 않는다(unbalanced). 이처럼 균형이 맞지 않는 문제를 해결하기 위해 p(s｜qwi)와 p(c｜qwi)의 정규화된 값(normalized values)들이 사용될 수 있다.p(s｜qwi)의 정규화된 공식은 다음과 같다. [0053][0054]마찬가지로, p(c｜qwi)의 정규화된 공식은 다음과 같이 계산될 수 있다. [0055][0056]p(qwi-1｜s, c, qwi-1)을 계산하기 위한 공식은 다음과 같으며, [0057][0058]p(qwi-1｜s, c)는 수식 (3)에 의해 계산될 수 있다. 선택된 텍스트(202)와 컨텍스트(204)가 동일할 경우 모든 [0059]후보 쿼리들에 대해 p(s, c)가 동일한 값을 취하는데,[0060]p(qwi-1)은 수식 (5)에 의해 계산되며, p(qwi｜qwi-1)은 qwi-1이 존재할 때 qwi가 qwi-1 직후에 나타날 확률이다. [0061]그러나, 전체 쿼리 집합을 이용하여 이 확률을 계산할 경우, 전체 쿼리 집합이 드물기 때문에 단어 qwi-1과 qwi가공개특허 10-2014-0128381-10-연속으로 나타나기 어려울 수도 있다. 이를 해결하기 위해 p(qwi｜qwi-1)는 qwi-1이 존재하는 경우 qwi가 qwi-1과함께 나타날 확률(qwi와 qwi-1이 바로 연달아 나타날 필요는 없음)로서 추정되는데, 이는 수식 (9)에 의해 계산할 수 있다.마지막으로, 확률 p(s, c｜qwi, qwi-1)를 계산하는 공식은 아래와 같다. 단순화해서, 언어 모델(212)은 두 개의 [0062]쿼리 단어 qwi와 qwi-1에 따라 독립적이다. 따라서, 다음 수식이 성립한다.[0063]수식 (7)과 마찬가지로, 언어 모델(212)은 두 개의 쿼리 단어 qwi와 qwi-1에 따라, 선택된 텍스트 s나 컨텍스트 [0064]c 내의 단어들은 독립적으로 생성될 수 있다고 가정한다. 그러므로,[0065]이며, 여기서 p(swj｜qwi, qwi-1)은 전체 쿼리 집합에 의해 다음과 같이 추정될 수 있다. [0066][0067]여기서 ｜Q(swj)∩Q(qwi)∩Q(qwi-1)｜은 단어 swj, qwi, qwi-1을 동시에 포함하는 전체 쿼리 집합 내의 쿼리들의 [0068]개수를 나타낸다. ｜Q(swi)∩Q(qwi-1)｜과 a는 수식 (9)에서와 유사한 의미를 갖는다.수식 (10)과 마찬가지로, 확률 p(s｜qwi, qwi-1)은 정규화될 수 있는데, [0069][0070] p(c｜qwi, qwi-1)의 값도 마찬가지로 계산되고 정규화될 수 있다. [0071]예시적인 인공지능 시스템 [0072]인공지능 시스템(214)은 후보 쿼리들의 랭킹을 매기는 분류 기법을 구현할 수 있다. 분류 기법에서는, 휴먼 리 [0073]뷰어들이 문서들 및 그 문서들과 연관된 쿼리들 q 사이의 연관성을 평가한다. 휴먼 리뷰어들이 라벨을 붙이기전에는 문서의 컨텐트가 쿼리를 야기했는지, 아니면 문서와 쿼리 사이의 연관성이 그저 우연이거나 문서와 무관한 것인지를 알 수 없다.휴먼 라벨러(human labeler)들은 문서-쿼리 쌍 중 하나로부터의 쿼리를 문서의 컨텐트와 연관된 것, 문서의 컨 [0074]텐트와 연관되지 않은 것, 또는 문서의 컨텐트와 막연하게 연관된 것으로 분류한다. 따라서, 휴먼 라벨러들은<문서, 쿼리> 쌍들의 집합을 리뷰한다. 이 쌍들은 사용자들의 실제 브라우징 및 검색 습성에 의해 생성되고 전체 쿼리 집합 내에 저장될 수 있다. 이는 언어 모델(212)에 의해 사용된 것과 동일한 전체 쿼리 집합일 수 있다. <문서, 쿼리> 상 내의 각 문서는 문서로부터 선택된 텍스트 s와 그 선택된 텍스트 s를 포함하는 컨텍스트c로서 표시될 수 있다. 그러므로, 휴먼 라벨러들의 작업은 <s, c>와 q 쌍에 라벨을 붙이는 것일 수 있는데, 이들 쌍들은 인공지능 시스템(214)을 위한 트레이닝 데이터로서 추후 사용된다. 어떤 실시예에서는 쿼리가 문서의 컨텐트와 연관되어 있다고 라벨이 붙여진 <s, c>와 q 쌍만이 트레이닝 데이터로서 이용될 수 있다.인공지능 시스템(212)은 트레이닝 데이터를 이용하여 함수 f(<s, c>q) -> {-1, +1}를 학습한다. 함수 f는 도 2 [0075]의 선택된 텍스트(202), 컨텍스트(204), 쿼리 후보들과 같은 새로운 데이터에 적용되어 각각의 후보 쿼리가 문서의 컨텐트와 연관될 신뢰 수준(confidence level)을 예측한다. 다양한 쿼리 후보들에 대한 신뢰 수준을 이용하여 쿼리 랭킹 모듈(210)에 의해 쿼리 후보의 랭킹을 매길 수 있다.공개특허 10-2014-0128381-11-문서-쿼리 관계에 대해 수동으로 라벨을 부여하는 것은 지루할 것이다. 유사-트레이닝 데이터(pseudo-training [0076]data)를 이용하여 수동 라벨링 노력을 감소시키고 더 많은 트레이닝 데이터를 획득함으로써, 함수 f의 정확도를향상시킬 수 있다. 유사-트레이닝 데이터는 사용자가 쿼리와 쌍을 이루는 문서를 본 직후 그 사용자들에 의해제출된 전체 쿼리 집합 내의 검색 쿼리들을 식별하는 것에 의해 생성될 수 있다. 이처럼 시간적 관계가 가까우면, 문서의 컨텐트로 인해 사용자가 쿼리 q를 생성하였음을 암시하게 된다. 문서의 컨텐트 c와 검색 쿼리 q 사이의 유사도를 자동으로 텍스트 비교(automatic textual comparison)하면 검색 쿼리 q와 유사한 문서 내의 어구(phrase) p를 찾을 수도 있고 아닐 수도 있을 것이다. 그러한 어구 p를 자동 분석에 의해 찾으면, 주변 컨텍스트 c가 주어질 때, 어구 p가 검색 쿼리 q를 야기하거나 유도했을 것이라고 가정된다. 이는 수동 라벨링 없이도인공지능 시스템(214)을 위한 트레이닝 데이터에 추가될 수 있는 (<p, c>, q) 쌍을 생성한다.예시적인 사용자 인터페이스 [0077]도 3은 로컬 컴퓨팅 장치(104) 상에 디스플레이될 수 있는 예시적인 문서(300)를 나타낸다. 문서(300)는 웹 페 [0078]이지, 텍스트 문서, 워드 프로세싱 문서, 스프레드시트 문서, 또는 HTML이나 XML과 같은 마크업 언어로 기록된문서를 포함하는 기타 임의의 유형의 문서일 수 있으며, 여기에 한정되지는 않는다. 문서(300)는 사용자(102)에 의해 선택된 텍스트의 컨텍스트에 대한 여러 개의 예를 보여주고 있다.사용자가 선택한 텍스트(302)는 사용자(102)가 선택한 단어(들)를 둘러싸는 굵은 사각형으로 도시되어 있다. [0079]사용자(102)는 부분적인 단어나 글자 하나를 선택할 수도 있을 것이다. 선택된 텍스트(302)는 사용자가 주의를기울이고 있는 문서(300)의 부분을 나타낸다. 선택된 텍스트(302)는 문서(300)의 컨텍스트 내에 존재한다. 언어 모델(212)이나 인공지능 시스템(214)에 의해 컨텍스트로서 간주되는 문서(300)의 양은 변할 수 있다.어떤 실시예에서는 전체 문서(300)가 선택된 텍스트(302)에 대한 컨텍스트를 제공할 수 있다. 전체 문서(300) [0080]는 여러 페이지를 포함할 수 있는데, 이들 중 일부는 디스플레이되지 않고, 일부는 사용자에게 보이지 않을 수도 있다. 컨텍스트를 더 좁게 보면 선택된 텍스트(302)를 포함하는 문장(304)만을 포함할 수도 있다. 다른 실시예에서, 컨텍스트는 선택된 텍스트(302)를 포함하는 문단(306), 선택된 텍스트(302)를 포함하는 컬럼(또는 웹페이지 레이아웃 내의 프레임: 308), 또는 선택된 텍스트(302)를 포함하는 문서(300)의 페이지(310)로 정의될수 있다. 문장, 문단 및/또는 페이지 없이 이들 문서를 포함하는 임의 종류의 문서에 대해서는, 컨텍스트가 전체 문서(300)의 더 크거나 작은 부분으로 정의될 수 있다.컨텍스트는 사전정의된 개수의 단어나 문자를 갖으면서 선택된 텍스트(302)를 포함하는 텍스트 부분(312)일 수 [0081]있다. 예컨대, 선택된 텍스트(302)를 포함하는 문서(300) 내의 60 단어 세그먼트가 컨텍스트로서 사용될 수 있다. 이 텍스트 부분(312)은 복수 개의 문장, 문단, 컬럼 등에 걸쳐 존재할 수 있고, 문장, 문단, 컬럼 등의 중간에서 시작하거나 중간에서 끝날 수도 있다. 60 단어 길이는 단순히 예시를 위한 것이며, 컨텍스트는 100 단어, 20 단어와 같은 임의의 길이를 가질 수도 있고, 단어가 아니라 문자를 기초로 할 수도 있으며, 20 문자,100 문자, 500 문자, 또는 다른 수의 단어나 문자를 포함할 수 있다.어떤 실시예에서, 선택된 텍스트(302)는 텍스트 부분(312)의 실질적으로 가운데 위치할 수 있다. 예를 들어, [0082]선택된 텍스트(302)가 3 단어를 포함하고, 텍스트 부분(312)이 60 단어를 포함하면, 선택된 텍스트(302)는 컨텍스트를 이루는 텍스트 부분(312)의 시작으로부터 약 23 또는 24 단어(즉, 60 - 3 = 57; 57 ÷ 2 = 23.5) 위치에 있을 수 있다. 어떤 실시예에서는 선택된 텍스트(302)가 텍스트 부분(312)의 중간 50%에 위치할 수도 있고(즉, 처음 1/4와 나중 1/4 내에는 위치하지 않음), 텍스트 부분(308)의 중간 20%에 위치할 수도 있다 (즉, 처음40%와 나중 50% 내에는 위치하지 않음).텍스트 부분(308) 내의 단어나 문자를 계산하는 것은 컨텍스트가 검색 쿼리들의 랭킹을 매기는 데 가장 유용할 [0083]단어들에 기초하도록 하기 위해 불용어(stop words)를 배제할 수도 있다. 이를테면, \"a\", \"the\", \"and\",\"it\", 그리고 기타 유형의 불용어가 컨텍스트의 20 단어 내에 포함된다면, 선택된 텍스트 주변을 중심으로 하는20-단어 컨텍스트(302)는 검색 쿼리들의 랭킹을 매기는 데 덜 도움이 될 것이다. 따라서, 컨텍스트를 이루는텍스트 부분(302) 내의 사전정의된 개수의 단어들은 불용어를 제외한 사전정의된 수의 단어들일 수 있다. 도 3은 문서(300) 내의 사전형성된 검색 쿼리(314)의 위치도 보여주고 있다. 사전형성된 검색 쿼리(314)는 사 [0084]용자가 텍스트를 선택하기 전 문서의 일부와 연관된 것일 수도 있다. 예컨대, 사전형성된 검색 쿼리(314)는 문서(300) 내의 특정 단어, 문장, 문단, 컬럼, 페이지 등과 연관될 수 있다. 본 실시예는 사전형성된 검색 쿼리(314)가 선택된 텍스트(302) 직전에 오는 문장과 연관된 것으로 도시하고 있다. 문서(300)가 선택된 텍스트공개특허 10-2014-0128381-12-(302)의 컨텍스트로 간주되는 정도에 따라, 사전형성된 검색 쿼리(314)는 선택된 텍스트(302)와 같은 문서(300)부분 내에 포함될 수도 있고, 그렇지 않을 수도 있다. 예를 들어, 선택된 텍스트(302)를 포함하는 문장(304)이컨텍스트이면, 사전형성된 검색 쿼리(314)는 선택된 텍스트(302)와 동일한 문서(300) 부분과 연관되지 않는다.그러나, 컨텍스트가 문단(306)이면, 사전형성된 검색 쿼리(314)는 선택된 텍스트(302)와 동일한 문서(300) 부분과 연관된다.문서(300)가 포함하는 사전형성된 검색 쿼리(314)의 수는 0, 1, 또는 복수 개일 수 있다. 사전형성된 검색 쿼 [0085]리(들)(314)은 사용자가 문서(300)의 연관된 부분을 소비할 때 수행할 것으로 예상되는 쿼리일 수 있다. 사전형성된 검색 쿼리(들)(314)는 문서(300)의 특정 부분 내에 삽입하기 위해 인간 저자(human author)에 의해 수동으로 만들어질 수도 있다. 이와는 달리, 또는 이에 더하여, 하나 이상의 사전형성된 검색 쿼리(들)(314)은 문서(300)를 보는 다른 사용자들로부터의 쿼리 로그를 분석하여 결정한 후 생성될 수도 있다.도 2에 도시한 후보 쿼리 생성기(208)는 선택된 텍스트(302)로부터 생성된 다른 검색 쿼리들과 함께 사전형성된 [0086]검색 쿼리(들)(314)을 획득할 수 있다. 어떤 실시예에서, 후보 쿼리 생성기(208)는 사용자에게 제시되는 검색쿼리 리스트 내의 문서(300)와 연관된 모든 사전형성된 검색 쿼리(들)(314)을 포함할 수 있다. 다른 실시예에서, 후보 쿼리 생성기(208)는 컨텍스트의 정의에 따라, 선택된 텍스트(302)와 동일한 문서(300) 부분과 연관되는 사전결정된 검색 쿼리(들)(314)만을 포함할 수도 있다. 또 다른 실시예에서는, 선택된 텍스트(302)의 위치에 가장 가까운 문서(300) 내의 위치와 연관되는 사전결정된 검색 쿼리(들)(314) 중 정해진 수(이를테면, 1, 2,3개)만이 사용자에게 제시되는 검색 쿼리 리스트에 포함된다.사용자가 후보 쿼리 리스트로부터 하나의 쿼리를 선택하면, 그 선택된 쿼리는 후속하여 문서(300)를 제시하기 [0087]위한 사전결정된 검색 쿼리(314)로서 사용될 수 있다. 그 사전결정된 검색 쿼리(314)는 원래 검색 쿼리를 생성한 선택된 텍스트(302)의 위치와 연관될 수 있다. 따라서, 문서(300)와 연관된 사전정의된 검색 쿼리(314)의개수는 시스템의 사용이 증가함에 따라 증가할 수 있다.도 4는 터치스크린 장치 상에서 텍스트를 선택하는 데 사용되는 2 가지 예시적인 사용자 인터페이스(400, 402) [0088]를 도시한다. 도 1의 로컬 컴퓨팅 장치는 터치스크린 디스플레이를 포함하는 장치로서 구현될 수 있다. 첫 번째 사용자 인터페이스(400)에서는, 사용자가 선택할 텍스트의 시작 부분에 있는 지점(404)으로부터 자신의 선택하고자 하는 텍스트의 끝 부분에 있는 지점(406)까지 터치스크린 표면을 가로질러 자신의 손가락(또는 스타일러스와 같은 기타 포인팅 도구)을 드래그(drag)한다. 사용자는 텍스트 가운데를 지나도록 손가락을 드래그할 수도 있고, 텍스트에 밑줄을 긋는 것처럼 텍스트의 아래쪽을 따라 드래그할 수도 있으며, 텍스트 흐름에 일반적으로 일치하는 기타 이동 방향(예컨대, 영어의 경우는 왼쪽에서 오른쪽으로이지만, 상이한 언어인 경우 이동 방향이 달라질 수도 있음)을 따라 드래그할 수도 있다. 시스템이 선택된 텍스트로부터 검색 쿼리를 형성하도록 하는 신호는 손가락이 끝 지점(406)에서 멈추는 경우 그 손가락의 움직임이 멈추는 것, 터치스크린 표면으로부터손가락을 들어올리는 것, 끝 지점(406)에서 터치스크린을 두드리는 것(tap) 등일 수 있다.두 번째 사용자 인터페이스(402)에 도시되어 있듯이, 사용자는 사용자가 선택하고자 하는 텍스트 주위를 대략 [0089]원형으로(in a generally circular shape) 스타일러스(또는 손가락과 같은 기타 포인팅 도구)를 움직임으로써텍스트를 선택할 수도 있다. 여기서 대략 원형이라 함은 원형보다는 타원형에 가까울 수도 있고, 시작 지점(408)과 끝 지점(410)이 맞닿는 닫힌 원(closed circle)일 수도 있으며, 시작 지점(408)이 끝 지점(410)과 상이한 위치에 있는 열린 호(open arc) 모양일 수도 있다.이 실시예에서는 선택된 텍스트의 오른쪽 아래에 있는 지점(408)에서 시작하여 시계 방향으로 이동하여 선택된 [0090]텍스트의 오른쪽 위에 있는 지점(410)까지 가도록 원형을 그리고 있다. 어떤 실시예에서는 시계 방향으로 그려진 원과 반시계 방향으로 그려진 원이 모두 동일한 결과를 가져올 수 있다. 그러나, 다른 실시예에서는 시계방향으로 (또는 반시계 방향으로) 원을 그린 경우에만 검색 쿼리의 생성이 개시될 수도 있다. 시스템으로 하여금 선택된 텍스트로부터 검색 쿼리들을 형성하도록 하는 신호는 스타일러스의 움직임이 끝 지점(410)에서 멈추는 것, 터치스크린 표면으로부터 스타일러스를 들어올리는 것, 스타일러스 시작 지점(408)으로 돌아와서 원이닫히는 것, 끝 지점(410)에서 터치스크린을 탭하는 것, 또는 텍스트 선택이 끝나고 검색 쿼리 생성이 시작되는것을 나타낼 수 있는 기타 제스쳐를 포함한다.도 4에 도시된 사용자 인터페이스(402 또는 404)는 사용자가 여러 개의 명령을 내리거나, 키보드를 사용하거나, [0091]자신이 소비하고 있던 문서 외의 인터페이스로 스위칭할 필요 없이 검색 프로세스를 개시할 수 있도록 해주는편리한 방법을 제공한다.공개특허 10-2014-0128381-13-예시적인 프로세스 [0092]이해를 용이하게 하기 위해, 본 명세서에서 논의되는 프로세스는 독립된 블럭으로 표시된 분리된 동작으로서 설 [0093]명된다. 그러나, 이처럼 분리되어 설명한 동작들이 그 수행에 있어 반드시 정해진 순서대로 수행되어야 하는것으로 해석해서는 안 된다. 기술된 프로세스들의 수행 순서는 한정사항으로 해석되어서는 안 되고, 설명된 프로세스 블럭 중 임의의 블럭(들)이 임의의 순서로 결합되어 본 프로세스 또는 대체적인 프로세스를 구현할 수있다. 또한, 제공된 동작들 중 하나 이상이 수정되거나 생략될 수 있다.프로세스들은 논리적 흐름도 내의 블럭들의 모음으로 도시되어 있는데, 이는 하드웨어, 소프트웨어, 또는 하드 [0094]웨어와 소프트웨어의 조합으로 구현될 수 있는 일련의 동작들을 나타낸다. 논의를 위해, 프로세스들은 도 1 내지 4에 도시된 아키텍쳐, 시스템, 사용자 인터페이스를 참조하여 기술된다. 그러나, 프로세스들은 이와는 다른아키텍쳐, 시스템 및/또는 사용자 인터페이스를 이용하여 수행될 수도 있다.도 5는 후보 쿼리들을 식별하여 사용자에게 제시하는 프로세스(500)를 나타내는 흐름도이다. 단계(502)에서는 [0095]문서 내의 텍스트에 대한 사용자의 선택이 수신된다. 사용자는 도 1에 도시한 사용자(102일 수 있고, 선택은정보-처리 시스템(112)에 의해 수신될 수 있다. 선택된 텍스트는 연속하는 한 개, 두 개, 세 개, 네 개의 단어등과 같이 연속하는 일련의 텍스트들일 수도 있고, 문서 내의 여러 위치로부터 선택된 복수 개의 단어들 또는단어들의 조합일 수도 있다. 문서는 웹 페이지, 텍스트 문서, 워드 프로세싱 문서, 전자책, 기타 임의 유형의문서일 수 있다.단계(504)에서는 복수 개의 후보 쿼리들이 획득된다. 후보 쿼리들은 후보 쿼리 생성기(208)로부터 직접 또는 [0096]간접적으로 획득될 수 있다. 후보 쿼리들은 단계(502)에서 선택된 텍스트에 하나 이상의 쿼리 확장 기법을 적용하여 생성된다. 쿼리 확장 기법은 선택된 텍스트를 이전 쿼리 로그와 비교하여 선택된 텍스트에 기초하여 이전 쿼리 로그로부터 하나 이상의 쿼리들을 식별해내는 임의의 기법들을 포함할 수 있다. 예시적인 기법으로서는 쿼리 로그(query log)에 K-평균 알고리즘(K-means algorithm)을 적용하는 것, 쿼리 로그를 파싱(parsing)하여 생성한 2부 쿼리-문서 그래프(bipartite query-document graph) 상에서 랜덤 워크(random walk)를 수행하는것, 쿼리 로그로부터 생성된 쿼리-흐름 그래프(query-flow graph) 상에서 페이지랭크 알고리즘(PageRankalgorithm)을 실행하는 것, 쿼리 로그로부터 용어 연관 패턴(term association patterns)을 마이닝하는 것을포함한다.단계(506)에서는 문서와 연관된 사전형성된 쿼리들이 존재하는지 판단한다. 사전형성된 쿼리들은 과거의 검색 [0097]동작의 쿼리 로그에 기초하여 식별될 수도 있고, 휴먼 에디터(human editor)에 의해 생성될 수도 있으며, 검색쿼리 생성을 위한 기타 기법에 의해 생성될 수도 있다. 사전형성된 쿼리들은 특정 단어, 문장, 문단, 페이지등 도 3의 사전형성된 쿼리(314)와 같은 문서 내의 특정 부분과 연관될 수 있다. 사용자가 선택한 텍스트가 사전형성된 쿼리와 동일한 문서 부분인 경우, 프로세스(500)는 \"네\" 경로를 따라 단계(508)로 진행한다. 그러나,문서가 사전형성된 쿼리들과 연관되지 않거나 문서와 연관된 사전형성된 쿼리들이 선택된 텍스트를 포함하는 문서 부분과 연관되지 않으면, 프로세스(500)는 \"아니오\" 경로를 따라 단계(510)로 진행한다.단계(508)에서 사전형성된 쿼리는 단계(504)에서 획득된 후보 쿼리 세트 내에 포함된다. 사전형성된 쿼리는 미 [0098]리 형성되어 있어서 생성을 위한 별도의 처리나 분석을 요하지 않기 때문에 단계(504)에서 획득된 다른 쿼리들에 비해 빨리 획득될 수 있다.단계(510)에서는 단계(508)에서 식별된 사전형성된 쿼리들을 포함하여 단계(504)에서 획득된 후보 쿼리들의 랭 [0099]킹이 매겨진다. 후보 쿼리들의 랭킹은 단계(502)에서 선택된 텍스트에 기초하여 사용자가 원하는 결과를 가져올 가능성이 더 높은 쿼리들에 더 높은 랭킹을 부여하는 방식으로 수행된다. 랭킹은 문서에 의해 제공되는 컨텍스트를 고려하는 언어 모델(512)에 따라 수행될 수 있다. 컨텍스트는 단계(502)에서 사용자가 선택한 텍스트를 포함하는 문서 내의 텍스트와 추가 텍스트에 의해 표현된다(즉, 컨텍스트는 사용자가 선택한 텍스트에 더하여 적어도 하나의 추가적인 단어나 문자를 포함한다). 이와는 달리, 또는 이에 더하여, 인공지능 시스템(514)에 의해 랭킹을 매길 수도 있다. 인공지능 시스템(514)은 휴먼 리뷰어에 의해 인증된 문서와 쿼리 쌍 세트(aset of document and query pairs) (즉, 트레이닝 데이터)를 이용하여 트레이닝된다. 휴먼 리뷰어들은 문서와쿼리 쌍을 평가하여 쿼리와 쌍을 이루는 문서의 컨텐트와 관련된 쿼리를 갖는 것들을 식별해낸다.단계(516)에서는 후보 쿼리들이 랭킹에 따른 순서대로 랭킹이 매겨진 리스트 내에서 사용자에게 제시된다. 랭 [0100]킹이 매겨진 리스트는 사용자가 검색 쿼리를 선택하는 동안 문서와 선택된 텍스트를 볼 수 있도록 사용자가 텍공개특허 10-2014-0128381-14-스트를 선택한 문서도 함께 디스플레이하는 인터페이스를 통해 사용자에게 표시된다. 이와는 달리, (장치의 디스플레이 면적이 문서와 리스트를 모두 표시하기에 너무 작은 경우는) 문서가 더 이상 표시되지 않고, 대신 리스트로 문서를 대체할 수도 있다. 리스트를 팝업 상자나 드롭-다운 메뉴 등을 이용하여 제시하는 것과 같이 리스트를 디스플레이하는 추가적인 기법들을 고려할 수도 있다. 따라서, 단계(502)에서 텍스트를 선택하면 선택된 텍스트 및 이를 둘러싼 컨텍스트에 기초한 관련도(relevance) 순서대로 랭킹이 매겨진 추천 쿼리 리스트가디스플레이되게 된다.단계(518)에서는 리스트로부터의 후보 쿼리들 중 하나에 대한 사용자의 선택이 수신된다. 사용자는 리스트로부 [0101]터 아이템을 선택하는 데 사용되는 임의의 통상적인 기법을 이용하여 선택을 수행할 수 있다. 따라서, 사용자는 단계(502)에서 검색할 단어들을 선택함에 있어 자신의 의도를 가장 잘 나타내는 검색 쿼리를 리스트로부터취할 수 있게 된다.단계(520)에서는 사용자가 선택한 쿼리가 검색 엔진(들)(110)과 같은 하나 이상의 검색 엔진들로 제출된다. 이 [0102]어서 사용자는 검색 엔진으로부터 검색 결과를 수신할 수 있다. 그러므로, 본 방법(500)을 이용함으로써, 사용자는 문서로부터 선택된 단어들을 단순히 검색하는 것에 비해 더 효과적으로 결과를 생성하도록 설계된 검색 쿼리에 기초하여 검색 결과를 획득할 수 있고, 문서 및/또는 검색 엔진 인터페이스와의 상호작용을 최소화하면서그러한 결과를 얻을 수 있게 된다.결론 [0103]전술한 발명의 대상은 하드웨어, 소프트웨어, 또는 하드웨어와 소프트웨어의 조합으로 구현될 수 있다. 본 발 [0104]명이 구조적 특성 및/또는 방법적 동작에 특유한 표현을 이용하여 기술되었지만, 첨부하는 특허청구범위에 정의된 청구대상은 전술한 구체적인 특성이나 동작으로 제한되지 않는다. 오히려, 전술한 구체적인 특성이나 동작은 청구항을 구현하는 예시적인 형태로서 개시된 것이다.공개특허 10-2014-0128381-15-도면도면1공개특허 10-2014-0128381-16-도면2공개특허 10-2014-0128381-17-도면3공개특허 10-2014-0128381-18-도면4공개특허 10-2014-0128381-19-도면5공개특허 10-2014-0128381-20-"}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "문서로부터 텍스트가 선택되면, 사용자가 그 선택된 텍스트에 기초한 검색을 개시하기 원하는 것으로 인식함으로 써 검색을 보조하는 기법에 관한 것이다. 선택된 텍스트에 기초하여 사용자에게 쿼리 제안(query suggestions) 을 제공하는데, 이 쿼리 제안은 문서에 의해 제공되는 컨텍스트에 기초하여 랭킹이 매겨진다. 사용자는 마우스 를 사용하거나, 터치스크린 상의 텍스트 주위에 원을 그리거나, 기타 입력 기법을 이용하여 텍스트를 선택할 수 있다. 선택된 텍스트에 적용된 쿼리 재형성 또는 쿼리 확장 기법에 기초하여 쿼리가 제안될 수 있다. 문서에 의해 제공되는 컨텍스트는 언어 모델 및/또는 인공지능 시스템에 의해 사용되어, 선택된 텍스트 및 컨텍스트에 기초하여 예측되는 관련도 순서(order of relevance)에 따라 쿼리 제안의 랭킹을 매기게 된다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "많은 인터넷 검색 기법은 사용자가 브라우징하고 있는 웹 페이지에 의해 트리거된다. 즉, 사용자는 해당 웹 페 이지 상의 컨텐츠를 소비한 후 검색을 개시하기로 결정하게 된다. 검색을 구현하기 위해서는 사용자가 웹 페이 지를 떠나 검색 엔진에 액세스해야 한다. 사용자는 웹 페이지로부터 단어를 복사하여 검색창에 붙여넣기하거나, 검색창 또는 검색 엔진 웹 페이지에 입력하기 위해 직접 검색 쿼리를 작성할 것이다. 이들 검 색 쿼리를 생성하는 기법은 모두 명료성의 결여, 복수의 의미를 갖는 검색어, 검색어들 사이의 불분명한 관계 등과 같은 단점을 갖고 있다. 검색 결과가 나온 후 사용자는 검색 인터페이스를 떠나 웹 브라우징으로 돌아올 수도 있다. 이처럼 웹 페이지 와 검색 인터페이스를 번갈아 사용하는 것은 비효율적이다. 더욱이, 다양한 사용자 인터페이스(예컨대, 텍스트 선택, 복사, 붙여넣기 등)와의 상호작용은 이동전화, 태블릿 컴퓨터, 게임 콘솔, 텔레비전 등과 같이 텍스트 입 력 성능이 제한된 장치 또는 폼팩터(form factor)가 작은 장치의 경우 특히 더 불편하다. 전통적인 컴퓨터가 아닌 장치를 사용하여 웹 페이지나 기타 전자 문서에 액세스하는 사용자의 수가 증가함에 따라, 문서 소비와 검 색을 부드럽게 통합할 필요성 역시 증대될 것이다. 이러한 기능을 수행할 수 있으면서 향상된 검색 쿼리를 제 공하는 시스템이 있다면 사용자들에게 유용할 것이다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "개요 본 개요는 후속하여 발명의 상세한 설명 부분에서 설명되는 개념들 중 선택된 것들을 단순화된 형태로 소개하고 자 제공되는 것이다. 본 개요는 청구항의 청구대상의 핵심적인 특징이나 필수적인 특징들을 밝히고자 함이 아 니며, 청구항의 청구대상의 범위를 결정하는 데 도움이 되고자 함도 아니다. 본 개시내용은 웹 페이지나 다른 문서 상의 사용자 관심 영역 및 주변 컨텍스트를 모두 이용하여 복수의 검색 쿼리를 생성하고 랭킹을 매기는 기법에 대해 설명한다. 웹 페이지를 브라우징하는 동안 사용자는 웹 페이지로 부터 텍스트를 선택한다. 텍스트를 선택하면, 복수의 후보 쿼리들을 생성하기 위한 시작점으로서 그 텍스트를 사용하라는 커맨드(command)가 생성되는데, 이 쿼리들은 선택된 텍스트와 관련된 결과들을 산출할 수 있는 검색 쿼리들이다. 여러 유형의 검색 쿼리 확장 또는 검색 쿼리 재형성 기법을 적용하여 선택된 텍스트로부터 목수의 후보 쿼리들을 생성한다. 이어서, 사용자는 이들 검색 쿼리들 중 하나를 선택하여 검색 엔진에 제출할 수 있다. 따라서, 브라우징 동작이 검색 동작과 결합되어, 간단히 웹 페이지로부터 텍스트를 선택한 후 후보 쿼리 들 중 하나를 선택하는 것에 의해 \"브라우징에서 검색까지\"를 가능하게 하는 인터페이스가 생성된다. 후보 쿼리들 세트 중 하나의 검색 쿼리로 사용자를 인도하기 위해, 문서의 컨텍스트가 고려된다. 브라우징된 웹 페이지에 의해 제공되는 컨텍스트에 비추어 후보 쿼리들을 평가함으로써 각각의 후보 쿼리의 랭킹이 매겨진 다. 브라우징된 웹 페이지는 후보 쿼리들의 용어의 불명확성을 해소하거나 후보 쿼리들을 동일한 웹 페이지에관련된 이전 검색 쿼리들과 비교하는 데 사용될 수 있는 단어들을 포함하고 있을 수 있으므로, 주변 컨텍스트를 고려하는 것은 후보 쿼리들의 랭킹을 매기는 데 도움이 된다. 후보 쿼리들의 랭킹은 언어 모델, 분류 기법(classification method), 또는 이들의 조합에 의해 수행될 수 있다. 언어 모델은 선택된 텍스트와 주변 컨텍스트가 주어졌을 때 후보 쿼리의 확률(probability)을 결정하는 모델로서 구현될 수 있다. 분류 기법은 웹 페이지 상의 선택된 텍스트 및 연관된 쿼리들을 포함하는 트레이닝 데이터를 이용한다. 휴먼 리뷰어(human reviewers)는 웹 페이지의 선택된 텍스트로 인해 사용자가 그 연관 검 색 쿼리를 만들게 될지를 판단한다. 그렇다고 판단되면, 선택된 텍스트와 쿼리 쌍은 머신 학습 시스템(machine learning system)에 의해 이용되어, 주어진 선택된 텍스트 및 컨텍스트에 대해 후보 쿼리의 신뢰 수준 (confidence level)을 예측하는 함수를 학습하게 된다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "예시적인 아키텍처 도 1은 사용자가 로컬 컴퓨팅 장치와 상호작용하여 검색 쿼리를 획득할 수 있는 아키텍처를 도시한다. 로컬 컴퓨팅 장치는 데스크탑 컴퓨터, 노트북 컴퓨터, 태블릿 컴퓨터, 스마트폰, 게임 콘솔, 텔레비전 등과 같은 임의의 컴퓨팅 장치일 수 있다. 로컬 컴퓨팅 장치는 네트워크를 통해 하나 이상 의 네트워크-액세스가능 컴퓨팅 장치와 통신할 수 있다. 네트워크는 LAN, WAN, 인터넷, 전화 네트워 크, 케이블 네트워크, 피어-투-피어 네트워크, 메쉬 네트워크 등과 같은 임의의 데이터 통신 네트워크 중 하나 이상의 유형일 수 있다. 네트워크-액세스가능 컴퓨팅 장치는 네트워크 서버, 웹 서버, 파일 서버, 슈퍼컴 퓨터, 데스크탑 컴퓨터 등과 같은 컴퓨팅 장치들의 임의의 유형 또는 유형들의 조합일 수 있다. 네트워크-액세 스가능 컴퓨팅 장치는 하나 이상의 검색 엔진에 통신가능하게 접속되거나 이를 포함할 수 있다. 검 색 엔진(들)은 검색 서비스를 제공하는 개체(entity)에 의해 유지되는 하나 이상의 전용 컴퓨팅 장치 상에 서 구현될 수 있다. 정보-처리 시스템은 하나 이상의 장소에 걸쳐 분산되어 있는 메모리와 하나 이상의 프로세싱 구성요 소들을 포함한다. 프로세싱 구성요소들은 CPU, GPU(graphical processing units), 싱글 코어 프로 세서, 멀티 코어 프로세서, ASIC(application specific integrated circuits) 등의 임의의 조합을 포함할 수 있다. 하나 이상의 프로세싱 구성요소(들)은 하드웨어 구현에 더하여 소프트웨어 및/또는 펌웨어로 구현 될 수 있다. 프로세싱 구성요소(들)의 소프트웨어 또는 펌웨어 구현은 임의의 적절한 프로그래밍 언어로 기술되어 전술한 다양한 기능을 수행하는 컴퓨터- 또는 머신- 실행가능 명령어를 포함할 수 있다. 프로세싱 구 성요소(들)의 소프트웨어 구현은 메모리 내에 그 전체 또는 일부가 저장될 수 있다. 메모리는 프로세싱 구성요소(들) 상에 로딩되어 실행될 수 있는 명령어들의 프로그램과 이들 프로그 램의 실행 중에 생성되는 데이터를 저장할 수 있다. 메모리 상에 저장되는 프로그램과 데이터의 예로는 로컬 컴퓨팅 장치에 이용가능한 하드웨어 및 소프트웨어 리소스의 동작을 제어하는 운영 체제, 네트워크- 액세스가능한 컴퓨팅 장치(들), 하드웨어 장치들과 상호작용하기 위한 드라이버, 네트워크 및 다른 컴퓨팅 장치들과 데이터를 주고받을 수 있는 통신 프로토콜, 추가적인 소프트웨어 애플리케이션 등이 있다. 로컬 컴퓨팅 장치 및/또는 네트워크-액세스가능 컴퓨팅 장치(들)의 구성 및 종류에 따라, 메모리 는 (RAM과 같은) 휘발성일 수도 있고, (ROM이나 플래시 메모리와 같은) 비휘발성일 수도 있다. 정보-처리 시스템은 착탈가능형 저장부, 비-착탈가능형 저장부, 로컬 저장부 및/또는 원격 저장부와 같은 추가적인 컴퓨터-판독가능 매체도 포함할 수 있다. 메모리 및 임의의 연관된 컴퓨터-판독가능 매체는 컴 퓨터 판독가능 명령어, 데이터 구조, 프로그램 모듈 및 기타 데이터의 저장을 제공할 수 있다. 컴퓨터-판독가 능 매체는 적어도 두 가지 종류의 컴퓨터-판독가능 매체, 즉, 컴퓨터 저장 매체와 통신 매체를 포함할 수 있다. 컴퓨터 저장 매체는 컴퓨터 판독가능 명령어, 데이터 구조, 프로그램 모듈, 또는 기타 데이터와 같은 정보 저장 을 위한 임의의 기법이나 방법에서 구현되는 휘발성 및 비휘발성, 착탈가능형 및 비착탈가능형 매체를 포함한다. 컴퓨터 저장 매체의 예로는 RAM, ROM, EEPROM, 플래시 메모리 또는 기타 메모리 기법, CD-ROM, DVD 또는 기타 광학 저장부, 자기 카세트, 자기 테이프, 자기 디스크 저장부 또는 기타 자기 저장 장치, 또는 기타 저장 장치, 또는 컴퓨터에 의해 액세스될 수 있는 정보를 저장하는 데 사용될 수 있는 기타 비-전송형 매체가 있으나, 여기에 제한되지는 않는다. 반면, 통신 매체는 컴퓨터 판독가능 명령어, 데이터 구조, 프로그램 모듈, 또는 기타 데이터를 반송파와 같은 변조된 데이터 신호 또는 기타 전송 메커니즘에 구현할 수 있다. 본 명세서의 정의에 따르면 컴퓨터 저장 매체 는 통신 매체를 포함하지 않는다. 정보-처리 시스템은 로컬 컴퓨팅 장치와 네트워크-액세스가능 컴퓨팅 장치(들) 중 하나 또는 모 두 상에 그 전체 또는 일부가 존재할 수 있다. 따라서, 정보-처리 시스템은 다양한 물리적 및 데이터 컴 포넌트가 하나 이상의 장소에 위치하면서 함께 작동하여 정보-처리 시스템의 역할을 수행하는 분산형 시스 템일 수 있다. 어떤 구현예에서는, 정보-처리 시스템의 모든 특징이 로컬 컴퓨팅 장치 상에 존재할 수 있다. 다른 구현예에서, 로컬 컴퓨팅 장치는 단순히 디스플레이 데이터를 수신하고 사용자 입력 신호 를 네트워크-액세스가능 컴퓨팅 장치(들)과 같은 다른 장치로 전송하는 씬 클라이언트(thin client)일 수 도 있는데, 이는 정보-처리 시스템을 포함한다. 정보-처리 시스템은 사용자를 위해 검색 쿼리를 형성하는 쿼리 형성기를 포함할 수 있다. 어떤 실시예에서, 쿼리 형성기는 메모리 내에 전체 또는 부분적으로 존재하는 저장부일 수 있다. 다른 실 시예에서, 쿼리 형성기는 ASIC의 일부와 같이 프로세싱 구성요소(들)의 일부로서 구현될 수도 있다. 정보-처리 시스템 자체와 같이, 쿼리 형성기는 로컬 컴퓨팅 장치와 네트워크-액세스가능 컴퓨팅 장치(들) 중 하나 또는 모두 상에 전체 또는 일부가 존재할 수 있다. 쿼리 형성기의 일부 또는 전부 가 복수의 컴퓨팅 장치 상에 중복적으로 위치하는 경우, 어느 컴퓨팅 장치를 사용하여 쿼리 형성기를 구현 할지는 관련 처리 속도, 네트워크를 통한 정보 전송 속도 및/또는 다른 요인에 따라 선택될 수 있다. 도 2는 도 1에 도시한 아키텍처의 쿼리 형성기과 다른 부분을 통한 정보와 데이터의 흐름을 나타내고 있다. 사용자가 문서로부터 텍스트를 선택하면, 쿼리 형성기에 대한 입력이 제공되어 쿼리를 형성하 도록 한다. 선택된 텍스트와 컨텍스트는 검색 개시 모듈에 의해 수신된다. 선택된 텍스트 는 문서로부터 텍스트를 선택하기 위한 임의의 통상적인 메커니즘을 이용하여 텍스트의 단락(들)을 선택하 거나 나타내도록 로컬 컴퓨팅 장치와 상호작용하는 사용자에 의해 선택될 수 있다. 컨텍스트는 선택된 텍스트를 둘러싸거나 그 주위에 위치하는 다른 텍스트를 포함할 수 있다. 컨텍스트는 해당 문서의 의도되거나 예상되는 용도에 기초하는 문서의 분류(classification)도 포함할 수 있다. 예를 들어, 문 서가 웹 페이지이고, 그 웹 페이지가 상품과 서비스 판매를 위한 상업 웹 페이지인 것으로 식별되면, 컨텍스트 는 사용자가 구매할 상품이나 서비스를 검색할 것 같다고 인식할 것이다. 텍스트를 선택하기 전의 사용자의 이전 동작 또한 컨텍스트를 제공할 수 있다. 이를테면, 사용자가 최근 제출한 검색 쿼리들은 사용자가 현재 검색하고 있는 토픽이나 분야에 관한 컨텍스트를 제공할 수 있다. 검색 개시 모듈은 해당 선택된 텍스트를 선택한 사용자로부터의 단일 입력을 텍스트의 선택 (selection of text)으로 해석하고, 그 선택된 텍스트에 기초하여 검색 쿼리를 생성하라는 커맨드로 해석 한다. 예컨대, 사용자가 문서로부터 연속하는 일련의 텍스트를 선택하도록 커서를 움직인다면, 그 사용자 는 검색 쿼리 제안을 받기 위해 이 텍스트를 다른 인터페이스로 붙여넣기 하거나 이동시킬 필요가 없다. 검색 개시 모듈은 텍스트를 선택하는 것 자체를 하나 이상의 검색 쿼리를 생성하라는 커맨드로 해석할 수 있다. 이처럼 검색 개시 모듈이 두 가지 역할을 수행하므로, 사용자는 단 한 번의 입력 또는 로컬 컴퓨팅 장치와의 상호작용만으로 텍스트를 선택하고 검색 쿼리를 요청할 수 있게 된다.검색 개시 모듈은 선택된 텍스트, 컨텍스트, 검색 쿼리를 생성하라는 커맨드를 쿼리 형성기 에 전달한다. 쿼리 형성기는 선택된 텍스트로부터 후보 쿼리들을 생성하는 후보 쿼리 생성기 를 포함할 수 있다. 후보 쿼리 생성기는 선택된 텍스트에 쿼리 확장 또는 쿼리 재형성 기법을 적용한다. 후보 쿼리 생성기는 동의어 포함시키기, 단어의 대체할 수 있는 형태학적인 형태(alternate morphological forms)를 추가하기, 철자가 틀린 단어의 철자를 고치기 및/또는 단어의 대체할 수 있는 철자를 제공하기 등을 이용하여 선택된 텍스트로부터 후보 쿼리들을 생성할 수 있다. 사용자가 관심 텍스트를 정 확하게 선택하지 못하면, 예를 들어, (손가락을 사용하여) 텍스트 주위에 타원을 그림으로써 텍스트를 선택하면, 의도치 않게 한 단어나 어구가 두 부분으로 나뉘게 될 수도 있다. 사후 처리 작업은 선택된 텍스트 로부터 무관한 문자들을 제거하거나 관련된 문자들을 앞이나 뒤에 덧붙이는 것을 포함할 수 있다. 어떤 실시예 에서는 문서와 연관되는 쿼리들의 쿼리 로그(query log)를 사용하여 후보 쿼리들을 생성한다. 쿼리 로그를 사 용하는 쿼리 확장 기법으로는 쿼리 로그에 K-평균 알고리즘(K-means algorithm)을 적용하는 것, 쿼리 로그를 파 싱(parsing)하여 생성한 2부 쿼리-문서 그래프(bipartite query-document graph) 상에서 랜덤 워크(random walk)를 수행하는 것, 쿼리 로그로부터 생성된 쿼리-흐름 그래프(query-flow graph) 상에서 페이지랭크 알고리 즘(PageRank algorithm)을 실행하는 것, 쿼리 로그로부터 용어 연관 패턴(term association patterns)을 마이 닝하는 것 등이 있다. 후보 쿼리 생성기는 후보 쿼리들을 직접 생성할 수도 있고, 선택된 텍스트를 다른 모듈이나 쿼리 형 성기 외부의 시스템(이를테면, 검색 엔진과 연관된 쿼리 재형성기 모듈)으로 전달할 수도 있다. 후보 쿼 리 생성기는 선택된 텍스트를 다른 시스템이나 모듈로 전달한 후 외부 모듈이나 시스템으로부터 후보 쿼리들을 수신함으로써 후보 쿼리들을 효과적으로 생성할 수 있다. 후보 쿼리 생성기는 선택된 텍스트 로부터 임의의 개수의 쿼리를 생성할 수 있다. 어떤 실시예에서, 후보 쿼리 생성기에 의해 생성된 후보 쿼리의 개수는 사전정의된 수일 수 있는데, 예를 들어, 3 개일 수도 있고, 10 개일 수도 있다. 다수의 후보 쿼리를 획득한 후, 쿼리 랭킹 모듈은 이들 쿼리가 선택된 텍스트와 컨텍스트에 대 응할 확률이나 가능성에 기초하여 후보 쿼리들의 랭킹을 매긴다. 쿼리 형성기는 후보 쿼리들을 생성하고, 검색 엔진으로 질의를 제출하지 않고도 이들 후보 쿼리들의 랭킹을 매기는 것을 모두 수행함으로써, 검색 엔진의 부담을 줄일 수 있다. 쿼리 랭킹 모듈은 하나 이상의 랭킹 기법에 따라 하나 이상의 후보 쿼리들의 랭킹을 매길 수 있다. 사용 될 수 있는 랭킹 기법으로는 언어 모델과 인공지능(AI) 시스템이 있다. 각각은 독립적으로 사용될 수도 있고 함께 사용될 수도 있다. 언어 모델은 컨텍스트와 선택된 데이터의 바이그램 언어 모델(bi-gram language model)을 생성 할 수 있다. 컨텍스트는 선택된 텍스트를 포함하는 문서의 텍스트 부분을 포함할 수 있다. 따라서, 컨텍스트는 선택된 텍스트에 문서 중의 추가 텍스트를 더한 것일 수 있다. 언어 모델은 각 후보 쿼 리들 내의 단어 수, 선택된 텍스트 내의 단어 수, 컨텍스트를 구성하는 텍스트 부분 내의 단어 수에 기초하여 후보 쿼리 생성기로부터의 복수의 쿼리들의 랭킹을 결정할 수 있다. 언어 모델을 구현하는 세부사항에 대해서는 후술하기로 한다. 인공지능 시스템은 지원 벡터 머신(support vector machine), 신경회로망(neural network), 엑스퍼트 시 스템(expert system), 베이지안 신뢰 네트워크(Bayesian belief network), 퍼지 로직 엔진(fuzzy logic engine), 데이터 퓨전 엔진(data fusion engine) 등과 같은 임의 유형의 인공지능 또는 머신 시스템으로서 구현 될 수 있다. 인공지능 시스템은 휴먼 라벨 트레이닝 데이터(human-labeled training data)로부터 생성될 수 있다. <문서, 쿼리> 쌍의 집합(corpus)은 문서 및 과거의 문서 소비와 하나 이상의 사용자의 검색 습성으로 부터 획득한 이들 문서와 연관된 쿼리들을 나타내는데, 이는 트레이닝 데이터의 전부 또는 일부 역할을 할 수 있다. 어떤 실시예에서, <문서, 쿼리>쌍은 검색 엔진에 자신의 브라우징 및 검색 습성을 제공하도록 선택 한 사용자들의 검색 엔진으로부터 얻은 검색 로그(search logs)로부터 획득될 수 있다. 브라우징 및 검색 데이터는 자신의 데이터를 기증하기로 선택한 사용자들의 프라이버시를 보호하도록 익명화(anonymized)될 수 있 다. 휴먼 라벨러(human labeler)들은 <문서, 쿼리>쌍을 리뷰하고 문서와 쿼리 사이에 인과관계(causal relationship)이 존재하는지 판단한다. 달리 말해서, 휴먼 라벨러들은 <문서, 쿼리> 쌍의 컨텐트가 사용자로 하여금 그 쌍 내의 쿼리를 제출하도록 하는 가능성에 대한 자신들의 주관적인 평가에 기초하여 각 쌍에 라벨을 부여한다. 인공지능 시스템의 구현을 위한 세부사항은 후술하도록 한다. 쿼리 형성기가 쿼리들을 형성하고 이들 쿼리들에 대해 랭킹을 매기면, 사용자에게는 랭킹이 매겨진 쿼리들의 리스트가 제공될 것이다. 높은 랭킹을 갖는 쿼리들은 낮은 랭킹을 갖는 쿼리들에 비해 리스트 내에서 더 앞자리 또는 더 눈에 잘 띄는 자리에 배치될 수 있다. 사용자는 후보 쿼리들 중 하나를 선택하고 그 쿼리에 기초하여 하나 이상의 엔진들 상에서 검색을 개시할 수 있다. 검색 엔진(들)은 쿼리를 네트워크나 다른 데이터 저장부에 제출하고, 검색 알고리즘, 선택된 쿼리, 네트워크 내에서 이용가능한 데이터에 따라 검색 결과를 수신할 수 있다. 검색 엔진들은 선택 된 검색 쿼리를 처리하기 위해 통상의 검색 기법을 사용할 수 있다. 예시적인 언어 모델 언어 모델은 컨텍스트에 기초하여 후보 쿼리들의 랭킹을 매긴다. 후보 쿼리들은 조건부 확률 (conditional probability) p(q｜s,c)에 의해 랭킹이 매겨지는데, 이는 선택된 텍스트(202: s로 표시)와 컨텍 스트(204: c로 표시)가 주어졌을 때 후보 쿼리들 중 하나의 쿼리인 쿼리 q가 생성될 확률을 나타낸다. 언어 모 델은 q = qw1, qw2, qwNq, s = sw1, sw2, swNs, c = cw1, cw2, cwNc라고 가정하는데, qwi, swi, cwi는 각각 쿼 리 q, 선택된 텍스트 s, 컨텍스트 c 내의 i번째 단어를 나타낸다. 언어 모델에서, Nq는 쿼리 q의 단어 길 이, Ns는 선택된 텍스트 s의 단어 길이, Nc는 컨텍스트 c의 단어 길이를 나타낸다. 언어 모델은 선택된 텍스트 s와 컨텍스트 c가 주어지면 각 쿼리 단어 qwi는 그 직전 단어 qwi-1에만 의존한 다고 가정한다. 이 가정은 바이그램 언어 모델의 경우 적용되는 가정과 유사하다. 유니그램 모델(uni-gram model)은 쿼리 내의 단어 수준의 관계(term-level relationship)는 포착하지 못하므로 어떤 실시예에는 바이그 램 표시가 바람직하다. 반면, n-그램 (n≥3) 방식은 계산 복잡도가 높아 온라인 쿼리 제안용으로는 지나치게 시간이 많이 소요될 우려가 있다. 그러나, 프로세싱 성능이 계속해서 증가함에 따라 3-그램 (또는 그 이상) 방 식의 계산 복잡도로 인한 시간 소요가 줄어들게 될 것이므로, 언어 모델은 n-그램 (n≥3) 방식을 수용하도 록 조정될 수 있다. 위와 같은 정의 및 가정에 기초하면, 선택된 텍스트와 컨텍스트가 주어졌을 때 후보 쿼리들 중 하나 의 쿼리가 생성될 확률은 아래와 같다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "위 수식에서는 쿼리가 길수록 확률이 작아진다. 이러한 영향을 완화하기 위해 확률에 추가적인 가중치를 곱하 되, 긴 쿼리에는 큰 가중치를 곱하도록 한다. 수정된 확률은 다음과 같이 계산될 수 있다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "여기에서 Λ는 1보다 큰 상수이다. p(qwi｜s, c)를 계산하기 위한 공식은"}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "이며, 후보 쿼리들 각각이 동일한 선택된 텍스트 s 및 컨텍스트 c에 기초하여 랭킹이 매겨지므로 p(s, c)는 무 시해도 된다. 전체 쿼리 집합(global query corpus)은 p(qwi) 값을 추정하는 데 사용될 수 있다. 쿼리 집합 Q가 주어진 경우, p(qwi)의 값은 다음과 같이 계산된다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "여기서, ｜Q(qwi)｜는 qwi를 포함하는 쿼리 집합 내의 쿼리 수를 나타내고, ｜Q｜는 전체 쿼리 집합 내의 쿼리의 총 수를 나타낸다.수식 를 평탄화한 버전(smoothed version)은"}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "이며, a는 0과 1 사이의 상수이다. 수식 에서 또 다른 확률을 다음과 같이 유도할 수 있다. 임의의 쿼리 단어 qwi에 대해 선택된 텍스트 s와 컨텍스트 c는 독립적이라고 가정한다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "함수를 단순화하기 위해, 언어 모델은 임의의 쿼리 단어 qwi에 대해 선택된 텍스트 s 또는 컨텍스트 c의 단어들이 독립적으로 생성될 수 있다고 가정한다. 따라서,"}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "이며, 여기서 p(swj｜qwi)는 qwi가 존재할 때 swj가 qwi와 함께 나타날 확률이다. 이 확률은 전체 쿼리 집합을 이용하여 계산될 수 있는데:"}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "｜Q(swj)∩Q(qwi)｜는 swj와 qwi를 전체 쿼리 집합 내에 포함하는 쿼리들의 개수이고, ｜Q(qwi)｜는 단어 qwi를 포함하는 쿼리 집합 내의 쿼리들의 개수이며, a ∈ (0, 1)이 평탄화에 사용된다. p(cwj｜qwi)의 값은 동시에 계산될 수 있다. 수식 및 에 따르면, p(s｜qwi)와 p(c｜qwi)의 값들은 Ns가 항상 Nc보다 작으므로 균형이 맞지 않는다(unbalanced). 이처럼 균형이 맞지 않는 문제를 해결하기 위해 p(s｜ qwi)와 p(c｜qwi)의 정규화된 값(normalized values)들이 사용될 수 있다. p(s｜qwi)의 정규화된 공식은 다음과 같다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 10, "content": "마찬가지로, p(c｜qwi)의 정규화된 공식은 다음과 같이 계산될 수 있다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 11, "content": "p(qwi-1｜s, c, qwi-1)을 계산하기 위한 공식은 다음과 같으며,"}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 12, "content": "p(qwi-1｜s, c)는 수식 에 의해 계산될 수 있다. 선택된 텍스트와 컨텍스트가 동일할 경우 모든 후보 쿼리들에 대해 p(s, c)가 동일한 값을 취하는데,"}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 13, "content": "p(qwi-1)은 수식 에 의해 계산되며, p(qwi｜qwi-1)은 qwi-1이 존재할 때 qwi가 qwi-1 직후에 나타날 확률이다. 그러나, 전체 쿼리 집합을 이용하여 이 확률을 계산할 경우, 전체 쿼리 집합이 드물기 때문에 단어 qwi-1과 qwi가연속으로 나타나기 어려울 수도 있다. 이를 해결하기 위해 p(qwi｜qwi-1)는 qwi-1이 존재하는 경우 qwi가 qwi-1과 함께 나타날 확률(qwi와 qwi-1이 바로 연달아 나타날 필요는 없음)로서 추정되는데, 이는 수식 에 의해 계산 할 수 있다. 마지막으로, 확률 p(s, c｜qwi, qwi-1)를 계산하는 공식은 아래와 같다. 단순화해서, 언어 모델은 두 개의 쿼리 단어 qwi와 qwi-1에 따라 독립적이다. 따라서, 다음 수식이 성립한다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 14, "content": "수식 과 마찬가지로, 언어 모델은 두 개의 쿼리 단어 qwi와 qwi-1에 따라, 선택된 텍스트 s나 컨텍스트 c 내의 단어들은 독립적으로 생성될 수 있다고 가정한다. 그러므로,"}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 15, "content": "이며, 여기서 p(swj｜qwi, qwi-1)은 전체 쿼리 집합에 의해 다음과 같이 추정될 수 있다."}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 16, "content": "여기서 ｜Q(swj)∩Q(qwi)∩Q(qwi-1)｜은 단어 swj, qwi, qwi-1을 동시에 포함하는 전체 쿼리 집합 내의 쿼리들의 개수를 나타낸다. ｜Q(swi)∩Q(qwi-1)｜과 a는 수식 에서와 유사한 의미를 갖는다. 수식 과 마찬가지로, 확률 p(s｜qwi, qwi-1)은 정규화될 수 있는데,"}
{"patent_id": "10-2014-7024197", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 17, "content": "p(c｜qwi, qwi-1)의 값도 마찬가지로 계산되고 정규화될 수 있다. 예시적인 인공지능 시스템 인공지능 시스템은 후보 쿼리들의 랭킹을 매기는 분류 기법을 구현할 수 있다. 분류 기법에서는, 휴먼 리 뷰어들이 문서들 및 그 문서들과 연관된 쿼리들 q 사이의 연관성을 평가한다. 휴먼 리뷰어들이 라벨을 붙이기 전에는 문서의 컨텐트가 쿼리를 야기했는지, 아니면 문서와 쿼리 사이의 연관성이 그저 우연이거나 문서와 무관 한 것인지를 알 수 없다. 휴먼 라벨러(human labeler)들은 문서-쿼리 쌍 중 하나로부터의 쿼리를 문서의 컨텐트와 연관된 것, 문서의 컨 텐트와 연관되지 않은 것, 또는 문서의 컨텐트와 막연하게 연관된 것으로 분류한다. 따라서, 휴먼 라벨러들은 <문서, 쿼리> 쌍들의 집합을 리뷰한다. 이 쌍들은 사용자들의 실제 브라우징 및 검색 습성에 의해 생성되고 전 체 쿼리 집합 내에 저장될 수 있다. 이는 언어 모델에 의해 사용된 것과 동일한 전체 쿼리 집합일 수 있 다. <문서, 쿼리> 상 내의 각 문서는 문서로부터 선택된 텍스트 s와 그 선택된 텍스트 s를 포함하는 컨텍스트 c로서 표시될 수 있다. 그러므로, 휴먼 라벨러들의 작업은 <s, c>와 q 쌍에 라벨을 붙이는 것일 수 있는데, 이 들 쌍들은 인공지능 시스템을 위한 트레이닝 데이터로서 추후 사용된다. 어떤 실시예에서는 쿼리가 문서 의 컨텐트와 연관되어 있다고 라벨이 붙여진 <s, c>와 q 쌍만이 트레이닝 데이터로서 이용될 수 있다. 인공지능 시스템은 트레이닝 데이터를 이용하여 함수 f(<s, c>q) -> {-1, +1}를 학습한다. 함수 f는 도 2 의 선택된 텍스트, 컨텍스트, 쿼리 후보들과 같은 새로운 데이터에 적용되어 각각의 후보 쿼리가 문 서의 컨텐트와 연관될 신뢰 수준(confidence level)을 예측한다. 다양한 쿼리 후보들에 대한 신뢰 수준을 이용 하여 쿼리 랭킹 모듈에 의해 쿼리 후보의 랭킹을 매길 수 있다.문서-쿼리 관계에 대해 수동으로 라벨을 부여하는 것은 지루할 것이다. 유사-트레이닝 데이터(pseudo-training data)를 이용하여 수동 라벨링 노력을 감소시키고 더 많은 트레이닝 데이터를 획득함으로써, 함수 f의 정확도를 향상시킬 수 있다. 유사-트레이닝 데이터는 사용자가 쿼리와 쌍을 이루는 문서를 본 직후 그 사용자들에 의해 제출된 전체 쿼리 집합 내의 검색 쿼리들을 식별하는 것에 의해 생성될 수 있다. 이처럼 시간적 관계가 가까우 면, 문서의 컨텐트로 인해 사용자가 쿼리 q를 생성하였음을 암시하게 된다. 문서의 컨텐트 c와 검색 쿼리 q 사 이의 유사도를 자동으로 텍스트 비교(automatic textual comparison)하면 검색 쿼리 q와 유사한 문서 내의 어구 (phrase) p를 찾을 수도 있고 아닐 수도 있을 것이다. 그러한 어구 p를 자동 분석에 의해 찾으면, 주변 컨텍스 트 c가 주어질 때, 어구 p가 검색 쿼리 q를 야기하거나 유도했을 것이라고 가정된다. 이는 수동 라벨링 없이도 인공지능 시스템을 위한 트레이닝 데이터에 추가될 수 있는 (<p, c>, q) 쌍을 생성한다. 예시적인 사용자 인터페이스 도 3은 로컬 컴퓨팅 장치 상에 디스플레이될 수 있는 예시적인 문서를 나타낸다. 문서는 웹 페 이지, 텍스트 문서, 워드 프로세싱 문서, 스프레드시트 문서, 또는 HTML이나 XML과 같은 마크업 언어로 기록된 문서를 포함하는 기타 임의의 유형의 문서일 수 있으며, 여기에 한정되지는 않는다. 문서는 사용자 에 의해 선택된 텍스트의 컨텍스트에 대한 여러 개의 예를 보여주고 있다. 사용자가 선택한 텍스트는 사용자가 선택한 단어(들)를 둘러싸는 굵은 사각형으로 도시되어 있다. 사용자는 부분적인 단어나 글자 하나를 선택할 수도 있을 것이다. 선택된 텍스트는 사용자가 주의를 기울이고 있는 문서의 부분을 나타낸다. 선택된 텍스트는 문서의 컨텍스트 내에 존재한다. 언 어 모델이나 인공지능 시스템에 의해 컨텍스트로서 간주되는 문서의 양은 변할 수 있다. 어떤 실시예에서는 전체 문서가 선택된 텍스트에 대한 컨텍스트를 제공할 수 있다. 전체 문서 는 여러 페이지를 포함할 수 있는데, 이들 중 일부는 디스플레이되지 않고, 일부는 사용자에게 보이지 않을 수 도 있다. 컨텍스트를 더 좁게 보면 선택된 텍스트를 포함하는 문장만을 포함할 수도 있다. 다른 실 시예에서, 컨텍스트는 선택된 텍스트를 포함하는 문단, 선택된 텍스트를 포함하는 컬럼(또는 웹 페이지 레이아웃 내의 프레임: 308), 또는 선택된 텍스트를 포함하는 문서의 페이지로 정의될 수 있다. 문장, 문단 및/또는 페이지 없이 이들 문서를 포함하는 임의 종류의 문서에 대해서는, 컨텍스트가 전 체 문서의 더 크거나 작은 부분으로 정의될 수 있다. 컨텍스트는 사전정의된 개수의 단어나 문자를 갖으면서 선택된 텍스트를 포함하는 텍스트 부분일 수 있다. 예컨대, 선택된 텍스트를 포함하는 문서 내의 60 단어 세그먼트가 컨텍스트로서 사용될 수 있 다. 이 텍스트 부분은 복수 개의 문장, 문단, 컬럼 등에 걸쳐 존재할 수 있고, 문장, 문단, 컬럼 등의 중 간에서 시작하거나 중간에서 끝날 수도 있다. 60 단어 길이는 단순히 예시를 위한 것이며, 컨텍스트는 100 단 어, 20 단어와 같은 임의의 길이를 가질 수도 있고, 단어가 아니라 문자를 기초로 할 수도 있으며, 20 문자, 100 문자, 500 문자, 또는 다른 수의 단어나 문자를 포함할 수 있다. 어떤 실시예에서, 선택된 텍스트는 텍스트 부분의 실질적으로 가운데 위치할 수 있다. 예를 들어, 선택된 텍스트가 3 단어를 포함하고, 텍스트 부분이 60 단어를 포함하면, 선택된 텍스트는 컨텍 스트를 이루는 텍스트 부분의 시작으로부터 약 23 또는 24 단어(즉, 60 - 3 = 57; 57 ÷ 2 = 23.5) 위치 에 있을 수 있다. 어떤 실시예에서는 선택된 텍스트가 텍스트 부분의 중간 50%에 위치할 수도 있고 (즉, 처음 1/4와 나중 1/4 내에는 위치하지 않음), 텍스트 부분의 중간 20%에 위치할 수도 있다 (즉, 처음 40%와 나중 50% 내에는 위치하지 않음). 텍스트 부분 내의 단어나 문자를 계산하는 것은 컨텍스트가 검색 쿼리들의 랭킹을 매기는 데 가장 유용할 단어들에 기초하도록 하기 위해 불용어(stop words)를 배제할 수도 있다. 이를테면, \"a\", \"the\", \"and\", \"it\", 그리고 기타 유형의 불용어가 컨텍스트의 20 단어 내에 포함된다면, 선택된 텍스트 주변을 중심으로 하는 20-단어 컨텍스트는 검색 쿼리들의 랭킹을 매기는 데 덜 도움이 될 것이다. 따라서, 컨텍스트를 이루는 텍스트 부분 내의 사전정의된 개수의 단어들은 불용어를 제외한 사전정의된 수의 단어들일 수 있다. 도 3은 문서 내의 사전형성된 검색 쿼리의 위치도 보여주고 있다. 사전형성된 검색 쿼리는 사 용자가 텍스트를 선택하기 전 문서의 일부와 연관된 것일 수도 있다. 예컨대, 사전형성된 검색 쿼리는 문 서 내의 특정 단어, 문장, 문단, 컬럼, 페이지 등과 연관될 수 있다. 본 실시예는 사전형성된 검색 쿼리 가 선택된 텍스트 직전에 오는 문장과 연관된 것으로 도시하고 있다. 문서가 선택된 텍스트의 컨텍스트로 간주되는 정도에 따라, 사전형성된 검색 쿼리는 선택된 텍스트와 같은 문서 부분 내에 포함될 수도 있고, 그렇지 않을 수도 있다. 예를 들어, 선택된 텍스트를 포함하는 문장이 컨텍스트이면, 사전형성된 검색 쿼리는 선택된 텍스트와 동일한 문서 부분과 연관되지 않는다. 그러나, 컨텍스트가 문단이면, 사전형성된 검색 쿼리는 선택된 텍스트와 동일한 문서 부분 과 연관된다. 문서가 포함하는 사전형성된 검색 쿼리의 수는 0, 1, 또는 복수 개일 수 있다. 사전형성된 검색 쿼 리(들)은 사용자가 문서의 연관된 부분을 소비할 때 수행할 것으로 예상되는 쿼리일 수 있다. 사전 형성된 검색 쿼리(들)는 문서의 특정 부분 내에 삽입하기 위해 인간 저자(human author)에 의해 수동 으로 만들어질 수도 있다. 이와는 달리, 또는 이에 더하여, 하나 이상의 사전형성된 검색 쿼리(들)은 문 서를 보는 다른 사용자들로부터의 쿼리 로그를 분석하여 결정한 후 생성될 수도 있다. 도 2에 도시한 후보 쿼리 생성기는 선택된 텍스트로부터 생성된 다른 검색 쿼리들과 함께 사전형성된 검색 쿼리(들)을 획득할 수 있다. 어떤 실시예에서, 후보 쿼리 생성기는 사용자에게 제시되는 검색 쿼리 리스트 내의 문서와 연관된 모든 사전형성된 검색 쿼리(들)을 포함할 수 있다. 다른 실시예에 서, 후보 쿼리 생성기는 컨텍스트의 정의에 따라, 선택된 텍스트와 동일한 문서 부분과 연관되 는 사전결정된 검색 쿼리(들)만을 포함할 수도 있다. 또 다른 실시예에서는, 선택된 텍스트의 위치 에 가장 가까운 문서 내의 위치와 연관되는 사전결정된 검색 쿼리(들) 중 정해진 수(이를테면, 1, 2, 3개)만이 사용자에게 제시되는 검색 쿼리 리스트에 포함된다. 사용자가 후보 쿼리 리스트로부터 하나의 쿼리를 선택하면, 그 선택된 쿼리는 후속하여 문서를 제시하기 위한 사전결정된 검색 쿼리로서 사용될 수 있다. 그 사전결정된 검색 쿼리는 원래 검색 쿼리를 생성 한 선택된 텍스트의 위치와 연관될 수 있다. 따라서, 문서와 연관된 사전정의된 검색 쿼리의 개수는 시스템의 사용이 증가함에 따라 증가할 수 있다. 도 4는 터치스크린 장치 상에서 텍스트를 선택하는 데 사용되는 2 가지 예시적인 사용자 인터페이스(400, 402) 를 도시한다. 도 1의 로컬 컴퓨팅 장치는 터치스크린 디스플레이를 포함하는 장치로서 구현될 수 있다. 첫 번 째 사용자 인터페이스에서는, 사용자가 선택할 텍스트의 시작 부분에 있는 지점으로부터 자신의 선택 하고자 하는 텍스트의 끝 부분에 있는 지점까지 터치스크린 표면을 가로질러 자신의 손가락(또는 스타일러 스와 같은 기타 포인팅 도구)을 드래그(drag)한다. 사용자는 텍스트 가운데를 지나도록 손가락을 드래그할 수 도 있고, 텍스트에 밑줄을 긋는 것처럼 텍스트의 아래쪽을 따라 드래그할 수도 있으며, 텍스트 흐름에 일반적으 로 일치하는 기타 이동 방향(예컨대, 영어의 경우는 왼쪽에서 오른쪽으로이지만, 상이한 언어인 경우 이동 방향 이 달라질 수도 있음)을 따라 드래그할 수도 있다. 시스템이 선택된 텍스트로부터 검색 쿼리를 형성하도록 하 는 신호는 손가락이 끝 지점에서 멈추는 경우 그 손가락의 움직임이 멈추는 것, 터치스크린 표면으로부터 손가락을 들어올리는 것, 끝 지점에서 터치스크린을 두드리는 것(tap) 등일 수 있다. 두 번째 사용자 인터페이스에 도시되어 있듯이, 사용자는 사용자가 선택하고자 하는 텍스트 주위를 대략 원형으로(in a generally circular shape) 스타일러스(또는 손가락과 같은 기타 포인팅 도구)를 움직임으로써 텍스트를 선택할 수도 있다. 여기서 대략 원형이라 함은 원형보다는 타원형에 가까울 수도 있고, 시작 지점 과 끝 지점이 맞닿는 닫힌 원(closed circle)일 수도 있으며, 시작 지점이 끝 지점과 상 이한 위치에 있는 열린 호(open arc) 모양일 수도 있다. 이 실시예에서는 선택된 텍스트의 오른쪽 아래에 있는 지점에서 시작하여 시계 방향으로 이동하여 선택된 텍스트의 오른쪽 위에 있는 지점까지 가도록 원형을 그리고 있다. 어떤 실시예에서는 시계 방향으로 그려 진 원과 반시계 방향으로 그려진 원이 모두 동일한 결과를 가져올 수 있다. 그러나, 다른 실시예에서는 시계 방향으로 (또는 반시계 방향으로) 원을 그린 경우에만 검색 쿼리의 생성이 개시될 수도 있다. 시스템으로 하여 금 선택된 텍스트로부터 검색 쿼리들을 형성하도록 하는 신호는 스타일러스의 움직임이 끝 지점에서 멈추 는 것, 터치스크린 표면으로부터 스타일러스를 들어올리는 것, 스타일러스 시작 지점으로 돌아와서 원이 닫히는 것, 끝 지점에서 터치스크린을 탭하는 것, 또는 텍스트 선택이 끝나고 검색 쿼리 생성이 시작되는 것을 나타낼 수 있는 기타 제스쳐를 포함한다. 도 4에 도시된 사용자 인터페이스(402 또는 404)는 사용자가 여러 개의 명령을 내리거나, 키보드를 사용하거나, 자신이 소비하고 있던 문서 외의 인터페이스로 스위칭할 필요 없이 검색 프로세스를 개시할 수 있도록 해주는 편리한 방법을 제공한다.예시적인 프로세스 이해를 용이하게 하기 위해, 본 명세서에서 논의되는 프로세스는 독립된 블럭으로 표시된 분리된 동작으로서 설 명된다. 그러나, 이처럼 분리되어 설명한 동작들이 그 수행에 있어 반드시 정해진 순서대로 수행되어야 하는 것으로 해석해서는 안 된다. 기술된 프로세스들의 수행 순서는 한정사항으로 해석되어서는 안 되고, 설명된 프 로세스 블럭 중 임의의 블럭(들)이 임의의 순서로 결합되어 본 프로세스 또는 대체적인 프로세스를 구현할 수 있다. 또한, 제공된 동작들 중 하나 이상이 수정되거나 생략될 수 있다. 프로세스들은 논리적 흐름도 내의 블럭들의 모음으로 도시되어 있는데, 이는 하드웨어, 소프트웨어, 또는 하드 웨어와 소프트웨어의 조합으로 구현될 수 있는 일련의 동작들을 나타낸다. 논의를 위해, 프로세스들은 도 1 내 지 4에 도시된 아키텍쳐, 시스템, 사용자 인터페이스를 참조하여 기술된다. 그러나, 프로세스들은 이와는 다른 아키텍쳐, 시스템 및/또는 사용자 인터페이스를 이용하여 수행될 수도 있다. 도 5는 후보 쿼리들을 식별하여 사용자에게 제시하는 프로세스를 나타내는 흐름도이다. 단계에서는 문서 내의 텍스트에 대한 사용자의 선택이 수신된다. 사용자는 도 1에 도시한 사용자(102일 수 있고, 선택은 정보-처리 시스템에 의해 수신될 수 있다. 선택된 텍스트는 연속하는 한 개, 두 개, 세 개, 네 개의 단어 등과 같이 연속하는 일련의 텍스트들일 수도 있고, 문서 내의 여러 위치로부터 선택된 복수 개의 단어들 또는 단어들의 조합일 수도 있다. 문서는 웹 페이지, 텍스트 문서, 워드 프로세싱 문서, 전자책, 기타 임의 유형의 문서일 수 있다. 단계에서는 복수 개의 후보 쿼리들이 획득된다. 후보 쿼리들은 후보 쿼리 생성기로부터 직접 또는 간접적으로 획득될 수 있다. 후보 쿼리들은 단계에서 선택된 텍스트에 하나 이상의 쿼리 확장 기법을 적 용하여 생성된다. 쿼리 확장 기법은 선택된 텍스트를 이전 쿼리 로그와 비교하여 선택된 텍스트에 기초하여 이 전 쿼리 로그로부터 하나 이상의 쿼리들을 식별해내는 임의의 기법들을 포함할 수 있다. 예시적인 기법으로서 는 쿼리 로그(query log)에 K-평균 알고리즘(K-means algorithm)을 적용하는 것, 쿼리 로그를 파싱(parsing)하 여 생성한 2부 쿼리-문서 그래프(bipartite query-document graph) 상에서 랜덤 워크(random walk)를 수행하는 것, 쿼리 로그로부터 생성된 쿼리-흐름 그래프(query-flow graph) 상에서 페이지랭크 알고리즘(PageRank algorithm)을 실행하는 것, 쿼리 로그로부터 용어 연관 패턴(term association patterns)을 마이닝하는 것을 포함한다. 단계에서는 문서와 연관된 사전형성된 쿼리들이 존재하는지 판단한다. 사전형성된 쿼리들은 과거의 검색 동작의 쿼리 로그에 기초하여 식별될 수도 있고, 휴먼 에디터(human editor)에 의해 생성될 수도 있으며, 검색 쿼리 생성을 위한 기타 기법에 의해 생성될 수도 있다. 사전형성된 쿼리들은 특정 단어, 문장, 문단, 페이지 등 도 3의 사전형성된 쿼리와 같은 문서 내의 특정 부분과 연관될 수 있다. 사용자가 선택한 텍스트가 사 전형성된 쿼리와 동일한 문서 부분인 경우, 프로세스는 \"네\" 경로를 따라 단계로 진행한다. 그러나, 문서가 사전형성된 쿼리들과 연관되지 않거나 문서와 연관된 사전형성된 쿼리들이 선택된 텍스트를 포함하는 문 서 부분과 연관되지 않으면, 프로세스는 \"아니오\" 경로를 따라 단계로 진행한다. 단계에서 사전형성된 쿼리는 단계에서 획득된 후보 쿼리 세트 내에 포함된다. 사전형성된 쿼리는 미 리 형성되어 있어서 생성을 위한 별도의 처리나 분석을 요하지 않기 때문에 단계에서 획득된 다른 쿼리들 에 비해 빨리 획득될 수 있다. 단계에서는 단계에서 식별된 사전형성된 쿼리들을 포함하여 단계에서 획득된 후보 쿼리들의 랭 킹이 매겨진다. 후보 쿼리들의 랭킹은 단계에서 선택된 텍스트에 기초하여 사용자가 원하는 결과를 가져 올 가능성이 더 높은 쿼리들에 더 높은 랭킹을 부여하는 방식으로 수행된다. 랭킹은 문서에 의해 제공되는 컨 텍스트를 고려하는 언어 모델에 따라 수행될 수 있다. 컨텍스트는 단계에서 사용자가 선택한 텍스트 를 포함하는 문서 내의 텍스트와 추가 텍스트에 의해 표현된다(즉, 컨텍스트는 사용자가 선택한 텍스트에 더하 여 적어도 하나의 추가적인 단어나 문자를 포함한다). 이와는 달리, 또는 이에 더하여, 인공지능 시스템 에 의해 랭킹을 매길 수도 있다. 인공지능 시스템은 휴먼 리뷰어에 의해 인증된 문서와 쿼리 쌍 세트(a set of document and query pairs) (즉, 트레이닝 데이터)를 이용하여 트레이닝된다. 휴먼 리뷰어들은 문서와 쿼리 쌍을 평가하여 쿼리와 쌍을 이루는 문서의 컨텐트와 관련된 쿼리를 갖는 것들을 식별해낸다. 단계에서는 후보 쿼리들이 랭킹에 따른 순서대로 랭킹이 매겨진 리스트 내에서 사용자에게 제시된다. 랭 킹이 매겨진 리스트는 사용자가 검색 쿼리를 선택하는 동안 문서와 선택된 텍스트를 볼 수 있도록 사용자가 텍스트를 선택한 문서도 함께 디스플레이하는 인터페이스를 통해 사용자에게 표시된다. 이와는 달리, (장치의 디 스플레이 면적이 문서와 리스트를 모두 표시하기에 너무 작은 경우는) 문서가 더 이상 표시되지 않고, 대신 리 스트로 문서를 대체할 수도 있다. 리스트를 팝업 상자나 드롭-다운 메뉴 등을 이용하여 제시하는 것과 같이 리 스트를 디스플레이하는 추가적인 기법들을 고려할 수도 있다. 따라서, 단계에서 텍스트를 선택하면 선택 된 텍스트 및 이를 둘러싼 컨텍스트에 기초한 관련도(relevance) 순서대로 랭킹이 매겨진 추천 쿼리 리스트가 디스플레이되게 된다. 단계에서는 리스트로부터의 후보 쿼리들 중 하나에 대한 사용자의 선택이 수신된다. 사용자는 리스트로부 터 아이템을 선택하는 데 사용되는 임의의 통상적인 기법을 이용하여 선택을 수행할 수 있다. 따라서, 사용자 는 단계에서 검색할 단어들을 선택함에 있어 자신의 의도를 가장 잘 나타내는 검색 쿼리를 리스트로부터 취할 수 있게 된다. 단계에서는 사용자가 선택한 쿼리가 검색 엔진(들)과 같은 하나 이상의 검색 엔진들로 제출된다. 이 어서 사용자는 검색 엔진으로부터 검색 결과를 수신할 수 있다. 그러므로, 본 방법을 이용함으로써, 사용 자는 문서로부터 선택된 단어들을 단순히 검색하는 것에 비해 더 효과적으로 결과를 생성하도록 설계된 검색 쿼 리에 기초하여 검색 결과를 획득할 수 있고, 문서 및/또는 검색 엔진 인터페이스와의 상호작용을 최소화하면서 그러한 결과를 얻을 수 있게 된다. 결론 전술한 발명의 대상은 하드웨어, 소프트웨어, 또는 하드웨어와 소프트웨어의 조합으로 구현될 수 있다. 본 발 명이 구조적 특성 및/또는 방법적 동작에 특유한 표현을 이용하여 기술되었지만, 첨부하는 특허청구범위에 정의 된 청구대상은 전술한 구체적인 특성이나 동작으로 제한되지 않는다. 오히려, 전술한 구체적인 특성이나 동작 은 청구항을 구현하는 예시적인 형태로서 개시된 것이다.도면 도면1 도면2 도면3 도면4 도면5"}
{"patent_id": "10-2014-7024197", "section": "도면", "subsection": "도면설명", "item": 1, "content": "첨부하는 도면을 참조하여 발명의 상세한 설명이 기술된다. 도면에서 참조 부호의 최고 자리수는 해당 참조부 호가 처음 등장하는 도면을 나타낸다. 상이한 도면에서 동일한 참조부호를 사용하는 것은 유사하거나 동일한 아이템을 나타내는 것이다. 도 1은 쿼리 형성기를 포함하는 정보-처리 시스템을 나타내는 예시적인 아키텍처이다. 도 2는 도 1의 아키텍처로부터 예시적인 데이터와 컴포넌트를 개략적으로 나타낸다. 도 3은 선택된 텍스트를 갖는 예시적인 문서를 도시한다. 도 4는 텍스트 선택을 위한 2가지 예시적인 사용자 인터페이스를 보여준다. 도 5는 사용자가 텍스트를 선택하는 것에 응답하여 랭킹이 매겨진 후보 쿼리들의 리스트를 제공하는 예시적인 방법을 나타내는 예시적인 흐름도이다."}
