{"patent_id": "10-2018-0152188", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2020-0066427", "출원번호": "10-2018-0152188", "발명의 명칭": "로그 수집 시스템 및 그 수집 방법", "출원인": "주식회사 리얼타임테크", "발명자": "박정환"}}
{"patent_id": "10-2018-0152188", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "복수의 사용자의 요청에 대한 응답을 수행하는 로그 수집 시스템으로서,상기 요청에 대한 애플리케이션을 수행한 결과를 응답하기 위해 생성되는 스레드(Thread)와,상기 스레드에 상기 사용자의 요청에 대한 정보를 저장하는 후킹된 서브릿(Servlet)과,데이터베이스에 작업을 요청시, 상기 스레드를 이용하여 저장된 상기 요청에 대한 정보와 상기 데이터베이스에요청한 작업에 대한 정보를 함께 저장하는 후킹된 데이터베이스 인터페이스(Database Interface)를 포함하는 로그 수집 시스템."}
{"patent_id": "10-2018-0152188", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 스레드는 상기 사용자의 요청에 대해 각각의 TLS(Thread Local Storage)를 가지며,상기 후킹된 서블릿은 상기 TLS에 상기 요청에 대한 정보를 저장하는 로그 수집 시스템."}
{"patent_id": "10-2018-0152188", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 2 항에 있어서,상기 후킹된 데이터베이스 인터페이스는 해당하는 상기 스레드의 TLS에 접근하여 상기 요청에 대한 정보를 불러드려 상기 데이터베이스에 요청한 정보를 함께 저장하는 로그 수집 시스템."}
{"patent_id": "10-2018-0152188", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "복수의 사용자의 요청에 대한 응답을 수행하는 로그 수집 방법으로서,복수의 사용자의 요청을 와스(WAS:Web Application Server)에 각각 전달하는 제 1 단계(S10)와,상기 와스가 스레드를 생성하여 상기 요청에 해당하는 후킹된 서블릿을 실행하는 제 2 단계(S20)와,상기 후킹된 서블릿에 의해 상기 스레드에 상기 사용자의 요청에 대한 정보를 저장하는 제 3 단계(S30)와,상기 후킹된 서블릿의 애플리케이션이 동작 중 상기 요청에 따라 필요시, 후킹된 데이터베이스 인터페이스를 통해 데이터베이스에게 작업을 요청하는 제 4 단계(S40)와,상기 후킹된 데이터베이스 인터페이스에서 상기 스레드를 이용하여 저장된 상기 요청에 대한 정보와 상기 데이터베이스에 요청한 작업에 대한 정보를 함께 저장하는 제 5 단계(S50)를 포함하는 로그 수집 방법."}
{"patent_id": "10-2018-0152188", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4 항에 있어서,상기 스레드는 상기 사용자의 각각의 요청에 대해 각각의 TLS(Thread Local Storage)를 가지며,상기 후킹된 서블릿은 상기 TLS에 상기 요청에 대한 정보를 저장하는 로그 수집 방법."}
{"patent_id": "10-2018-0152188", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 5 항에 있어서,상기 후킹된 데이터베이스 인터페이스는 해당하는 상기 스레드의 TLS에 접근하여 상기 요청에 대한 정보를 불러드려 상기 데이터베이스에 요청한 정보를 함께 저장하는 로그 수집 방법.공개특허 10-2020-0066427-3-"}
{"patent_id": "10-2018-0152188", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 대용량으로 발생하는 로그들을 행위(Action)로 정의하여 정형화 된 형태로 처리하고, 행위들의 연속성 을 룰로 정의하여 비정상적인 접근을 탐지하며, 인공지능 학습에 적합함과 아울러 고속으로 처리할 수 있는 행위 기반 룰 처리 장치 및 그 처리 방법을 제공하는 것을 목적으로 한다. 상기 목적을 달성하기 위해, 본 발명에 따른 로그 수집 시스템은, 복수의 사용자의 요청에 대한 응답을 수행하는 로그 수집 시스템으로서, 상기 요청에 대한 애플리케이션을 수행한 결과를 응답하기 위해 생성되는 스레드 (Thread)와, 상기 스레드에 상기 사용자의 요청에 대한 정보를 저장하는 후킹된 서브릿(Servlet)과, 데이터베이 스에 작업을 요청시, 상기 스레드를 이용하여 저장된 상기 요청에 대한 정보와 상기 데이터베이스에 요청한 작업 에 대한 정보를 함께 저장하는 후킹된 데이터베이스 인터페이스(Database Interface)를 포함한다."}
{"patent_id": "10-2018-0152188", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 로그 수집 시스템 및 그 수집 방법에 관한 것으로, 더욱 상세하게는 소스 코드를 수정하거나 파일을 교체하지 않고 로드되는 클래스를 변조할 수 있는 로그 수집 시스템 및 그 수집 방법에 관한 것이다."}
{"patent_id": "10-2018-0152188", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "일반적인 웹서버(Web Server)는 이미지나 HTML 파일과 같은 정적인 데이터를 처리하는 서버이다. 반면, 와스 (WAS: Web Application Server)는 웹서버(정적 데이터 처리)와 웹컨테이너(동적 데이터 처리)가 합쳐진 서버로 정적인 데이터는 물론 동적인 데이터(jsp, asp, Servlet, php 등)를 처리하며, DB(데이터베이스)와 연결되어 데 이터를 주고 받거나 프로그램으로 데이터 조작을 수행할 수 있다. 즉, 초기 웹서버는 정적인 데이터만을 처리하였지만 점차 웹서버가 널리 사용되면서, 웹서버에서 데이터를 입력 하고 조회하는 동적인 기능이 요구되었다. 이러한 요구에 부합하는 와스는 프로그램 실행 환경과 DB의 접속 기 능을 제공하고, 복수의 트랜잭션을 관리하며, 업무를 처리하는 비지니스 로직을 수행한다. 그런데, 이러한 와스에서 출력하는 Http Access 로그와, DB에서 출력하는 DB 로그는 하나의 사용자 행위에 의해 생성된다. 예를 들면, 사용자가 로그인 버튼을 클릭하면, Http Access 로그인 페이지에 접속하는 로그(Http Access 로그)와, DB의 사용자 테이블에서 생성되는 로그인 비교 로그(DB 로그)는 모두 하나의 사용자 행위에 의 해 생성된다. 하지만, Http Access 로그와, DB 로그는 각각 남겨지는 로그의 형태상 이를 한꺼번에 확인할 수 없는 문제점이 있었다. 즉, DB 로그와 짝을 이루는 Http Access 로그가 무엇인지 알 수 없는 문제점이 있었다. 이러한 문제점을 해결하기 위해서는 와스의 애플리케이션(사이트)에 직접적인 소스 코드 수정을 수행해야 하지 만 이는 애플리케이션의 수많은 페이지 각각에 직접 소스 코드를 수정해야 하는 문제점이 있었다. 게다가, 이러한 애플리케이션의 소스 코드 수정은 보안상 타사에 위탁(委託)할 수 없으며, 이 애플리케이션을 운용하는 운용사의 입장에서는 이러한 소스 코드의 수정에 인력과, 비용을 소비할 수 없는 문제점이 있었다."}
{"patent_id": "10-2018-0152188", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "이에 본 발명은 상기한 바와 같은 요구에 부응하기 위해 제안된 것으로서, 그 목적은 클래스 로더가 클래스의 바이너리를 보내기 이전에 바이너리 상태에서의 바이트 코드의 수정을 통해 애플리케이션의 소스 코드를 수정하 거나 파일의 교체하지 않고 로드되는 클래스를 변조할 수 있는 로그 수집 시스템 및 그 수집 방법을 제공하는 것이다."}
{"patent_id": "10-2018-0152188", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "상기 목적을 달성하기 위해, 본 발명에 따른 로그 수집 시스템은, 복수의 사용자의 요청에 대한 응답을 수행하 는 로그 수집 시스템으로서, 상기 요청에 대한 애플리케이션을 수행한 결과를 응답하기 위해 생성되는 스레드 (Thread)와, 상기 스레드에 상기 사용자의 요청에 대한 정보를 저장하는 후킹된 서브릿(Servlet)과, 데이터베이 스에 작업을 요청시, 상기 스레드를 이용하여 저장된 상기 요청에 대한 정보와 상기 데이터베이스에 요청한 작 업에 대한 정보를 함께 저장하는 후킹된 데이터베이스 인터페이스(Database Interface)를 포함한다. 또한, 본 발명에 따른 로그 수집 시스템에서, 상기 스레드는 상기 사용자의 요청에 대해 각각의 TLS(Thread Local Storage)를 가지며, 상기 후킹된 서블릿은 상기 TLS에 상기 요청에 대한 정보를 저장한다. 또한, 본 발명에 따른 로그 수집 시스템에서, 상기 후킹된 데이터베이스 인터페이스는 해당하는 상기 스레드의 TLS에 접근하여 상기 요청에 대한 정보를 불러드려 상기 데이터베이스에 요청한 정보를 함께 저장한다. 한편, 상기 목적을 달성하기 위해, 본 발명에 따른 로그 수집 방법은, 복수의 사용자의 요청에 대한 응답을 수 행하는 로그 수집 방법으로서, 복수의 사용자의 요청을 와스(WAS:Web Application Server)에 각각 전달하는 제 1 단계(S10)와, 상기 와스가 스레드를 생성하여 상기 요청에 해당하는 후킹된 서블릿을 실행하는 제 2 단계(S20)와, 상기 후킹된 서블릿에 의해 상기 스레드에 상기 사용자의 요청에 대한 정보를 저장하는 제 3 단계 (S30)와, 상기 후킹된 서블릿의 애플리케이션이 동작 중 상기 요청에 따라 필요시, 후킹된 데이터베이스 인터페 이스를 통해 데이터베이스에게 작업을 요청하는 제 4 단계(S40)와, 상기 후킹된 데이터베이스 인터페이스에서 상기 스레드를 이용하여 저장된 상기 요청에 대한 정보와 상기 데이터베이스에 요청한 작업에 대한 정보를 함께 저장하는 제 5 단계(S50)를 포함한다. 또한, 본 발명에 따른 로그 수집 방법에서, 상기 스레드는 상기 사용자의 각각의 요청에 대해 각각의 TLS(Thread Local Storage)를 가지며, 상기 후킹된 서블릿은 상기 TLS에 상기 요청에 대한 정보를 저장한다. 또한, 본 발명에 따른 로그 수집 방법에서, 상기 후킹된 데이터베이스 인터페이스는 해당하는 상기 스레드의 TLS에 접근하여 상기 요청에 대한 정보를 불러드려 상기 데이터베이스에 요청한 정보를 함께 저장한다."}
{"patent_id": "10-2018-0152188", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명에 의하면, 클래스 로더가 클래스의 바이너리를 보내기 이전에 바이너리 상태에서의 바이트 코드의 수정 을 통해 애플리케이션의 소스 코드를 수정하거나 파일의 교체하지 않고 로드되는 클래스를 변조할 수 있는 효과 가 있다."}
{"patent_id": "10-2018-0152188", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 본 발명의 실시예에 대해 관련 도면들을 참조하여 상세히 설명하기로 한다. 도 1은 본 발명에 따른 로그 수집 시스템의 전체 구성을 나타내는 시스템 구성도이다. 도 1을 참조하면, 본 발명에 따른 로그 수집 시스템은 복수의 사용자의 요청에 대한 응답을 수행하는 로그 수집 시스템이다. 이러한 로그 수집 시스템은 스레드(Thread : 110)와, 후킹된 서브릿(Hooked Servlet : 122)과, 후킹된 데이터베이스 인터페이스(Hooked Database Interface : 130)를 갖는 와스(Web Application Server : 100)와, 데이터베이스를 포함한다. 일반적으로, 스레드는 컴퓨터 프로그램 수행시 프로세스 내부에 존재하는 수행 경로, 즉 일련의 실행 코드 로, 실제 작업을 담당한다. 프로세스 생성시 하나의 주 스레드가 생성되어 대부분의 작업을 처리하고, 주 스레 드가 종료되면 프로세스도 종료된다. 하나의 운영 체계에서 여러 개의 프로세스가 동시에 실행되는 환경이 멀티 태스킹이고, 하나의 프로세스 내에서 다수의 스레드가 동시에 수행되는 것이 멀티스레딩이다. 본 발명에서는 이 러한 스레드가 복수의 사용자의 요청에 대한 애플리케이션을 수행한 결과를 응답하기 위해 생성된다. 이러한 스레드는 와스 내부에서 와스와 통신한다. 또한, 이러한 스레드는 복수의 사용자 에 따라 복수의 스레드가 각각 형성된다. 즉, 복수의 사용자가 100개일 경우, 100개의 사용자(1 0)에게 각각 1개씩 100개의 스레드가 생성된다. 후킹된 서블릿은 스레드에 사용자의 요청에 대한 정보를 저장하는 역할을 수행한다. 사용자 가 와스에 자원 정보(예를 들면, 페이지 정보나, 로그인 정보, 애플리케이션 정보 등)를 요청하면, 일반적 인 서브릿은 스레드에 상기 요청에 대한 정보를 저장한다. 또한, 필요시 데이터베이스에 저장되 어 있는 데이터베이스 정보들을 불러드린다. 이때, 데이터베이스 로그(query) 들이 일반적인 서블릿의 어느 액 세스 로그(Access Log)와 매칭되는 것인지, 즉 어느 사용자의 요청에 의해 수행되는 것인지 알 수 없고, 이 를 해결하기 위해서는 애플리케이션의 수정을 통해 애플리케이션이 액세스 로그와, 데이터베이스 로 그를 매칭시켜서 하나의 애플리케잉션 로그로 생성해야만 한다. 하지만, 본 발명에 따른 로그 수집 시스템 에서는 스레드가 사용자 요청에 대해 각각의 TLS(Thread Local Storage)를 가지며, 후킹된 서 브릿은 이러한 스레드의 TLS에 사용자의 요청에 대한 정보를 저장한다. 여기서, TLS란 스레드가 각각 가지게 되는 독립 공간이다. 또한, 후킹된 데이터베이스 인터페이스는 후킹된 서브릿이 데이터베이스에 작업을 요청시, 스레 드를 이용하여 저장된 상기 사용자의 요청에 대한 정보와, 데이터베이스에 요청한 작업에 대한 정보를 함께 스레드에 저장한다. 즉, 후킹된 서블릿은 스레드가 생성한 TLS에 사용자의 요 청에 대한 정보를 저장하고, 데이터베이스의 정보가 필요한 경우, 후킹된 데이터베이스 인터페이스는 후킹된 서블릿에 요청한 사용자에 해당하는 스레드의 TLS에 접근하여 상기 사용자의 요청에 대한 정보를 불러드려 데이터베이스에 요청한 정보를 함께 저장한다. 이에 의해, 복수의 사용자 중 하 나의 사용자에 의해 생성되는 하나의 스레드의 TLS에, 후킹된 서블릿이 저장하는 사용자의 요청에 대한 정보와, 후킹된 데이터베이스 인터페이스가 데이터베이스에 요청한 정보가 함께 저장됨 으로써, 일반적인 와스에서 애플리케이션의 수정을 통해 액세스 로그의 내용과 데이터베이스 로그의 내용 의 매칭을 수행하지 않고, 후킹을 통해 실제 해당 모듈이 동작할 때, 후킹된 서브릿과, 후킹된 데이터베이 스 인터페이스을 감지하여 기록하게 된다. 즉, 스레드의 TLS에 스레드를 키(key)값으로 하여, 사용자의 요청 정보를 저장하고, 이후 후킹된 데이터베이스 인터페이스에서 상기 스레드 정보를 가지고 TLS에서 사용자의 요청 정보를 불러드려 데이터베이스의 쿼리(query) 정보와 함께 로깅하게 된다. 이러한 TLS는 스레드가 각각 가지게 되는 독립 공간으로, 사용자가 와스에 요청을 하게 되면, 반 드시 하나의 스레드를 할당받아 동작하기 때문에, 초반 후킹 과정에서 후킹된 서브릿이 TLS에 요청 정보를 저장하게 된다. 그후, HttpAccess나 데이터베이스 인터페이스 접근과 같은 로그 대상의 메서드(함수)가 호출되면 TLS에 저장된 요청 정보와 맵핑하여 로그로 남기게 된다. 도 2는 본 발명에 따른 로그 수집 시스템에서 클래스 로더의 구조를 나타내는 도면이다. 도 2를 참조하면, 본 발명에 따른 로그 수집 시스템에서는 애플리케이션의 수정이나 파일의 교체 없 이 로드되는 클래스를 변조할 수 있다. 기본적인 클래스 로더의 구조는 Jar File 또는 단일 Class File의 바 이트 배열인 바이너리를 JVM(Java Virtual Machine : 4)에게 넘겨주어 클래스 로딩을 하는 구조이다. 여기서, 클래스 로더(Class Loader)란 다음과 같다. 자바는 클래스라는 파일로 프로그램이 구성되며, 이러한 클 래스를 읽어오는 모듈을 클래스 로더라 하고, 기본적으로 클래스 로더는 JVM에 기본적으로 탑재되어 있다. 본 발명에서 후킹을 수행하는 후킹 모듈의 클래스 로더는 JVM에게 바이너리를 주기 직전, 바이너리 상 태에서의 바이트 코드(어셈블리와 같은 역할) 수정을 통해, 실제 애플리케이션의 소스 코드 수정이나 파일 교체 없이 로드 되는 클래스를 변조할 수 있다. 도 3은 본 발명에 따른 로그 수집 시스템에서 클래스 로더의 처리 상태를 나타내는 도면이다. 일반적인 와스의 기본 부팅 과정은 JVM의 클래스 로더가 와스의 최초 실행을 담당하는 Jar File을 로드하여 실행하고, 해당 와스의 Jar File은 코어 클래스와 와스의 커스텀 클래스 로더를 로드하게 된다. 그후 커스텀 클래스 로더가 애플리케이션(예를 들면, 사이트 등), 플러그인(JDBC, Graphic Library) 들을 로드하며 와스가 동작한다. 즉, 와스의 기본적인 부팅 과정에서, JVM의 클래스 로더가 와스 의 최초 실행 Jar File을 로드하여 실행하고, 해당 와스의 Jar File은 코어 클래스와, 와스의 커스텀 클래스 로더를 로딩하게 된다. 그후, 커스텀 클래스 로더가 애플리케이션(사이트), 플러그인(JDBC, Graphic Library) 들을 로드하며 와스가 동작한다. 하지만, 도 3에 나타낸 바와 같이, 본 발명에 따른 로그 수집 시스템에서는, 와스에 직접적인 수정 없이 후킹 모듈을 이용하여 실행하게 된다. 클래스 로더는 부모 클래스 로더를 이용하는 메커니즘을 가진다. 즉, 하위 클래스 로더는 상위 클래스 로더를 이용하게 된다. 이에 의거하여, 후킹 모듈의 클래스 로더를 통해 와스를 실행하여 와스의 기본 클래스 로더를 후킹 모듈의 클래스 로더가 되도록 하고, 와스 내부적으로 사용되는 커스텀 클래스 로더를 바이트 코드 패칭을 통해 후킹 클래스 로더로서 동작하도록 한다. 이에 의해 와스가 로딩하는 애플리케이션과, 플러그 인(JDBC, Graphic Library : 9)들을 런타임 중 간(실행 중간)에 수정할 수 있다. 도 4는 본 발명에 따른 로그 수집 시스템의 처리 상태를 나타내는 도면이다. 본 발명에 따른 로그 수집 방법은 총 5개의 단계에 의해 수행된다. 복수의 사용자의 요청에 대한 응답을 수행하는 로그 수집 방법으로서, 제 1 단계(S10)에서는, 복수의 사용 자의 각각의 요청을 복수의 스레드를 통해 와스에 각각 전달한다. 즉, 1개의 사용자의 요청을 1개의 스레드를 통해 와스에 전달되므로, 예를 들어 100개의 사용자의 각각의 요청이 와스 에 전달되기 위해서는 100개의 스레드가 생성된다. 이때, 스레드는 사용자의 각각의 요청에 대해 각각의 TLS(Thread Local Storage)를 가진다. 제 2 단계(S20)에서는, 와스가 스레드를 생성하여 사용자의 요청에 해당하는 후킹된 서블릿(12 2)을 실행한다. 또한, 제 3 단계(S30)에서는 후킹된 서블릿에 의해 스레드의 TLS에 사용자의 요청에 대한 정보를 저장한다. 즉, 후킹된 서블릿은 TLS에 요청에 대한 정보를 저장한다. 제 4 단계(S40)에서는 후킹된 서블릿의 애플리케이션이 동작 중 요청에 따라 필요시, 후킹된 데이터 베이스 인터페이스를 통해 데이터베이스에게 작업을 요청한다. 제 5 단계(S50)에서는 후킹된 데이터베이스 인터페이스에서 스레드의 TLS를 이용하여 저장된 사용자 의 요청에 대한 정보와 데이터베이스에 요청한 작업에 대한 정보를 함께 저장한다. 즉, 후킹된 데이터 베이스 인터페이스는 해당하는 스레드의 TLS에 접근하여 상기 요청에 대한 정보를 불러드려 상기 데 이터베이스에 요청한 정보를 함께 저장한다. 이러한 TLS는 스레드가 각각 가지게 되는 독립 공간으로, 사용자가 와스에 요청을 하게 되면, 반 드시 하나의 스레드를 할당받아 동작하기 때문에, 초반 후킹 과정에서 후킹된 서브릿이 TLS에 요청 정보를 저장하게 된다. 그후, HttpAccess나 데이터베이스 인터페이스 접근과 같은 로그 대상의 메서드(함수)가 호출되면 TLS에 저장된 요청 정보와 맵핑하여 로그로 남기게 된다. 즉, 본 발명에 따른 로그 수집 시스템은 스레드의 TLS를 활용하여, TLS에 (Key : Thread, Value : Request) 구조로 저장한다. 이에 의해, 사용자의 요청에 대한 액세스 로그가 생성된다. 이후, 사용자의 스레드 정보를 key 값으로 TLS를 검색하고, 사용자의 요청 정보와 같이 데이터베이스 로그(query)를 로깅 인터페이스(Logging Interface)로 전달하게 된다. 이상의 설명은 본 발명의 기술 사상을 예시적으로 설명한 것에 불과한 것으로서, 본 발명이 속하는 기술 분야에 서 통상의 지식을 가진 자라면 본 발명의 본질적인 특성에서 벗어나지 않는 범위에서 다양한 수정 및 변형이 가 능할 것이다. 따라서, 본 발명에 개시된 실시예들은 본 발명의 기술 사상을 한정하기 위한 것이 아니라 설명하 기 위한 것이고, 이러한 실시예에 의하여 본 발명의 기술 사상의 범위가 한정되는 것은 아니다. 본 발명의 보호 범위는 아래의 청구범위에 의하여 해석되어야 하며, 그와 동등한 범위 내에 있는 모든 기술 사상은 본 발명의 권리범위에 포함되는 것으로 해석되어야 할 것이다."}
{"patent_id": "10-2018-0152188", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명에 따른 로그 수집 시스템의 전체 구성을 나타내는 시스템 구성도. 도 2는 본 발명에 따른 로그 수집 시스템에서 클래스 로더의 구조를 나타내는 도면. 도 3은 본 발명에 따른 로그 수집 시스템에서 클래스 로더의 처리 상태를 나타내는 도면. 도 4는 본 발명에 따른 로그 수집 시스템의 처리 상태를 나타내는 도면."}
