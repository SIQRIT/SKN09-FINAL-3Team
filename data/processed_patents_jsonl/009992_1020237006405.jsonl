{"patent_id": "10-2023-7006405", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0043179", "출원번호": "10-2023-7006405", "발명의 명칭": "자연 솔루션 언어", "출원인": "브레인 코그니티브스 피티이. 엘티디.", "발명자": "바이라주, 라미링가 라주"}}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하는 방법으로서, 사용자의 컴퓨팅 장치의 프로세서에 의해, 구축될 솔루션을 나타내는 글로벌 의도 진술을 수신하는 단계로서,상기 글로벌 의도 진술이 자연 언어의 형태로 수신되고 잠재성 상태로 설정되는, 수신 단계; 사용자의 프로세서에 의해, 상기 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술의 세부 사항을 수신하는 단계로서, 에이전트가 솔루션을 실행하는 인간 에이전트 또는 기계 에이전트이며, 하나 이상의 에이전트의세부 사항이 자연 언어의 형태로 수신되고, 각 에이전트는 잠재성 상태로 설정되는, 수신 단계; 상기 사용자의 프로세서에 의해, 상기 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도진술과 연관된 개체의 세부사항을 수신하는 단계로서, 상기 각 로컬 의도 진술 및 각 개체의 세부사항이 자연언어의 형태로 수신되고 잠재성 상태로 각각 설정되며, 상기 각 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내며, 상기 각 개체가 해당 로컬 의도 진술에 의해 표시된 단계에 참여하는, 수신 단계; 상기 프로세서에 의해, 상기 각 로컬 의도 진술에 하나 이상의 에이전트를 할당하는 단계로서, 상기 로컬 의도진술에 할당된 에이전트의 세부 사항이 사용자에 의해 수정 가능한 할당 단계; 상기 각 로컬 의도 진술에 대해, 사용자의 프로세서에 의해 자연 언어 형태로, 각각의 로컬 의도 진술의 특성을규정하는 하나 이상의 속성을 수신하는 단계; 상기 각 개체에 대해, 사용자의 프로세서에 의해 자연 언어 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당하는 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 수신하는 단계; 상기 프로세서에 의해, 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 하는 조합 개체 상태(CES)의 집합을 형성하는 단계로서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES가 잠재성 상태에 있는, 집합 형성 단계; 상기 글로벌 의도 진술과 연관된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 수신 로컬 의도진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 단계; 상기 글로벌 의도 진술과 연관된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 응답하여, 사용자의 프로세서에 의해 자연 언어 형태로 로컬 의도 진술들 간의 관계를 수신하는 단계로서, 상기 관계는, 하나의 로컬 의도진술의 트리거 CES가 솔루션의 다른 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 종료인지 여부를 나타내는, 수신 단계; 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 상기 프로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상태로 존재하게 되는 경우의 시작 시간을 기록하는 단계; 및 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 상기 프로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 종료 시간을 기록하는 단계를 포함하는 컴퓨터 구현 솔루션의 구축 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1항에 있어서, 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 프로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이공개특허 10-2023-0043179-3-잠재성 상태로 존재하게 되는 경우의 지오그래픽 위치 좌표를 기록하는 단계를 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1항에 있어서, 상기 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 상기 프로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 지오그래픽 위치 좌표를 기록하는 단계를 포함하는 것을 특징으로하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1항에 있어서, 상기 로컬 의도 진술에 대해, 사용자의 프로세서에 의해 자연 언어 형태로, 하나 이상의 하위 로컬 의도 진술및 각 하위 로컬 의도 진술과 연관된 개체의 세부 사항을 수신하는 단계로서, 상기 각 하위 로컬 의도 진술 및각 개체가 각각 잠재성 상태로 설정되고, 상기 각 하위 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내고, 상기 각 개체가 해당 하위 로컬 의도 진술에 의해 표시된 단계에 참여하는, 수신 단계; 상기 프로세서에 의해, 상기 각 하위 로컬 의도 진술에 하나 이상의 에이전트를 할당하는 단계로서, 상기 로컬의도 진술에 할당된 에이전트의 세부 사항이 사용자에 의해 수정 가능한 할당 단계; 상기 각 하위 로컬 의도 진술에 대해, 사용자의 프로세서에 의해 자연 언어 형태로, 상기 각각의 하위 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성을 수신하는 단계; 상기 각 개체에 대해, 사용자의 프로세서에 의해 자연 언어 형태로, 상기 각각의 개체의 특성을 규정하고 각각의 개체를 해당하는 하위 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 수신하는 단계; 상기 프로세서에 의해, 상기 각 하위 로컬 의도 진술에 대해, 상기 각각의 하위 로컬 의도 진술의 개체의 모든가능한 조합을 기반으로 하는 CES의 집합을 형성하는 단계로서, 상기 각각의 하위 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 CES이고, 상기 집합 내의 각 CES가 잠재성 상태로 있는, 집합 형성 단계; 상기 사용자의 프로세서에 의해 자연 언어 형태로, 로컬 의도 진술들 간의 관계 및 하나 이상의 하위 로컬 의도진술을 수신하는 단계로서, 상기 관계는, 하나의 로컬 의도 진술의 트리거 CES가 하위 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지의 여부를 나타내고, 상기 관계는, 하나의 하위 로컬 의도 진술의 트리거 CES가 로컬의도 진술의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 종료인지 여부를 나타내는, 수신 단계.를 추가로 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1항에 있어서, 상기 솔루션이 실행될 때, 상기 로컬 의도 진술에 대해, 에이전트의 프로세서에 의해 자연 언어 형태로, 하나 이상의 하위 로컬 의도 진술및 각 하위 로컬 의도 진술과 연관된 개체의 세부 사항을 수신하는 단계로서, 상기 각 하위 로컬 의도 진술 및각 개체가 각각 잠재성 상태로 설정되고, 상기 각 하위 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내고, 각 개체가 해당 하위 로컬 의도 진술에 표시된 단계에 참여하는, 수신 단계; 상기 프로세서에 의해, 상기 각 하위 로컬 의도 진술에 하나 이상의 에이전트를 할당하는 단계로서, 상기 하위로컬 의도 진술에 할당된 에이전트의 세부 사항이 에이전트에 의해 수정 가능한 할당 단계; 상기 각 하위 로컬 의도 진술에 대해, 자연 언어의 형태로 에이전트의 프로세서에 의해, 각각의 하위 로컬 의도진술의 특성을 규정하는 하나 이상의 속성을 수신하는 단계; 상기 각 개체에 대해, 자연 언어의 형태로 에이전트의 프로세서에 의해, 각각의 개체의 특성을 규정하고 각각의개체를 해당하는 하위 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 수신하는 단계; 상기 프로세서에 의해, 상기 각 하위 로컬 의도 진술에 대해, 각각의 하위 로컬 의도 진술의 개체의 모든 가능공개특허 10-2023-0043179-4-한 조합을 기반으로 하는 CES의 집합을 형성하는 단계로서, 각각의 하위 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 CES이고, 집합 내의 각 CES가 잠재성 상태에 있는 집합 형성 단계; 및에이전트의 프로세서에 의해 자연 언어 형태로, 상기 로컬 의도 진술과 하나 이상의 하위 로컬 의도 진술 간의관계를 수신하는 단계로서, 상기 관계는, 하나의 하위 로컬 의도 진술의 트리거 CES가 다른 하위 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지를 나타내는,수신 단계 를 추가로 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1항에 있어서, 상기 각 로컬 의도 진술의 각 개체에 대해, 연관된 에이전트의 프로세서에 의해, 각각의 개체에 대한 값을 수신하는 단계를 추가로 포함하고, 상기 각각의 개체에 대한 값을 수신하는 단계가 수신된 값을 기반으로, 잠재성상태를 각각의 개체에 대한 현실 상태로 변경시키는 이벤트의 기록이며, 상기 값은 자연 언어, 프로그래밍언어, 이미지, 생체 인식, 및 제스처의 형태의 입력이고, 자연 언어는 텍스트 또는 음성 형태인 것을 특징으로하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1항에 있어서, 상기 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성 중 적어도 하나는,하나 이상의 미리 규정된 조건이 충족되면, 솔루션을 실행하는 동안 잠재성 상태로 존재하게 되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1항에 있어서, 상기 사용자의 프로세서에 의해 자연 언어 형태로, 상기 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나이상의 에이전트, 개체 및 속성과 연관된 정보가 솔루션의 실행 중에 수신되는 사용자 인터페이스를 구성하기위해 사용자 입력을 수신하는 단계를 추가로 포함하고, 상기 사용자 인터페이스가 디스플레이 장치의 디스플레이 속성을 기반으로 동적으로 조정 가능한 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1항에 있어서, 상기 프로세서에 의해, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성과연관된 수신된 정보를 분석하는 단계; 및 상기 프로세서에 의해, 자연 솔루션 언어 문법 데이터베이스와의 통신을 기반으로 분석된 정보를 수정하여 정보에서 하나 이상의 문법 수정을 수행하는 단계를 추가로 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 1항에 있어서, 상기 프로세서에 의해, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성과연관된 수신된 정보를 분석하는 단계; 및 상기 프로세서에 의해, 자연 솔루션 언어 문법 데이터베이스와의 통신을 기반으로 분석된 정보로부터 중복 텍스트를 제거하는 단계를 추가로 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "공개특허 10-2023-0043179-5-제 1항에 있어서, 상기 프로세서에 의해, 수신된 글로벌 의도 진술을 기반으로, 상기 하나 이상의 로컬 의도 진술, 또는 하나 이상의 에이전트, 또는 하나 이상의 개체, 또는 하나 이상의 속성, 또는 이들의 조합을 자동 덧붙이는(auto-populating) 단계를 추가로 포함하고, 상기 자동 덧붙임 단계가 자연 솔루션 언어 문법 데이터베이스와의 통신을 기반으로 하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 1항에 있어서, 상기 로컬 의도 진술은 2 이상의 병렬 로컬 의도 진술을 포함하며, 하나의 로컬 의도 진술의 트리거 CES는 2 이상의 병렬 로컬 의도 진술의 CES 집합에 영향을 미치고, 그리고 2 이상의 병렬 로컬 의도 진술의 트리거 CES는 또 다른 로컬 의도 진술의 CES 집합에 영향을 미치거나 솔루션구축의 종료인 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 1항에 있어서, 상기 로컬 의도 진술은 2 이상의 대체 로컬 의도 진술을 포함하며, 상기 하나의 로컬 의도 진술의 트리거 CES는 2 이상의 대체 로컬 의도 진술의 CES 집합에 영향을 미치고, 그리고 2 이상의 대체 로컬 의도 진술의 트리거 CES는 또 다른 로컬 의도 진술의 CES 집합에 영향을 미치거나 솔루션구축의 종료인 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 1항에 있어서, 상기 로컬 의도 진술은 내포된 로컬 의도 진술을 포함하고, 상기 내포된 로컬 의도 진술의 트리거 CES는 다른솔루션의 로컬 의도 진술의 CES 집합에 영향을 미치는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 1항에 있어서, 상기 로컬 의도 진술은 반복 로컬 의도 진술을 포함하고, 상기 반복 로컬 의도 진술의 트리거 CES는 다른 로컬의도 진술의 CES 집합에 영향을 미치거나 또는 N 반복 후 솔루션 구축의 종료이고, 여기서 N은 1보다 큰 것을특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 1항에 있어서, 상기 사용자의 프로세서에 의해 자연 언어 형태로, 로컬 의도 진술과 연관된 2 이상의 대체 개체의 세부 사항을수신하는 단계를 추가로 포함하며, 상기 2 이상의 대체 개체 각각이 잠재성 상태로 각각 설정되고, 상기 2 이상의 대체 개체 중 하나는 해당 로컬 의도 진술에 의해 표시된 단계에 참여하고, 상기 2 이상의 대체 개체 중 다른 하나는 트리거 CES의 일부가 아닌 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제 1항에 있어서, 상기 프로세서에 의해, 다음 식을 기반으로 솔루션과 연관된 다수의 잠재성 상태를 결정하는 단계를 추가로 포공개특허 10-2023-0043179-6-함하는 것을 특징으로 하는 방법:((2^(b1-c1-e1))x(2^(b2-c2-e2))+(2^(b2-c2-e2))x(2^(b3-c3-e3))+........+(2^(bK-1-cK-1-eK-1)) x (2^(bK-cK-eK))+(2^(bK-cK-eK)))-1상기 식에서, K는 로컬 의도 진술의 총 수이고,bi는 i번째 로컬 의도 진술과 연관된 개체, 속성, 및 에이전트의 총 수이고,ci는 상수인 i번째 로컬 의도 진술과 연관된 개체, 속성 및 에이전트의 총 수이고, ei는 i번째 로컬 의도 진술에 영향을 미치는 트리거 CES의 수이다."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제 1항에 있어서, 상기 프로세서에 의해, 하나 이상의 자연 솔루션 언어 응용 프로그래밍 인터페이스를 사용하여 외부 시스템과통신하는 단계를 추가로 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 1항에 있어서, 상기 프로세서에 의해, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 개체, 하나 이상의 속성,하나 이상의 에이전트의 값을 기반으로 하나 이상의 리포트를 생성하는 단계를 추가로 포함하고, 상기 하나 이상의 리포트는 하나 이상의 미리 규정된 기술을 기반으로 생성되는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제 1항에 있어서, 상기 프로세서에 의해, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 개체, 하나 이상의 속성,하나 이상의 에이전트의 값을 분석하는 단계; 및 상기 프로세서에 의해, 분석을 기반으로 하나 이상의 논리적 추론을 도출하는 단계로서, 상기 하나 이상의 논리적 추론은 하나 이상의 미리 규정된 모델을 기반으로 도출되는 도출 단계를 추가로 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제 1항에 있어서, 상기 로컬 의도 진술과 연관된 에이전트가 기계 에이전트인 경우, 로봇 프로세스 자동화 엔진으로부터의 프로세서에 의해, 상기 로컬 의도 진술에 대한 새로운 하위 로컬 의도 진술 및 새로운 하위 로컬 의도 진술에 대한 하나 이상의 새로운 개체 및 속성을 추가하기 위한 입력을 수신하는단계; 상기 로봇 프로세스 자동화 엔진으로부터의 프로세서에 의해, 하나 이상의 새로운 개체 및 속성을 로컬 의도 진술에 추가하기 위한 입력을 수신하는 단계; 또는 상기 로봇 프로세스 자동화 엔진으로부터의 프로세서에 의해, 로컬 의도 진술 또는 연관된 개체 또는 연관된 속성을 수정하기 위한 입력을 수신하는 단계를 추가로 포함하는 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위공개특허 10-2023-0043179-7-한 컴퓨팅 장치로서, 프로세서; 및상기 프로세서에 결합된 메모리로서, 제 1항 내지 제 21항 중 어느 한 항의 방법을 수행하기 위해 프로세서에의해 실행 가능한 명령을 포함하는 메모리를 포함하는 컴퓨팅 장치."}
{"patent_id": "10-2023-7006405", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "기계 실행 가능 코드를 포함하는 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한 명령을 저장한 비 일시적 컴퓨터 판독 가능 매체로서, 상기 기계 실행 가능코드는, 프로세서에 의해 실행될 때, 상기 프로세스가, 사용자로부터, 구축될 솔루션을 나타내는 글로벌 의도 진술을 수신하는 단계로서, 상기 글로벌 의도 진술이 자연 언어의 형태로 수신되고 잠재성 상태로 설정되는, 글로벌 의도 진술의 수신 단계; 사용자로부터, 글로벌 의도 진술과 연관된 하나 이상의 에이전트의 세부 사항을 수신하는 단계로서, 에이전트가솔루션을 실행하는 인간 에이전트 또는 기계 에이전트이며, 하나 이상의 에이전트의 세부 사항이 자연 언어의형태로 수신되고, 각 에이전트가 잠재성 상태로 설정되는, 에이전트의 세부 사항 수신 단계;사용자로부터, 상기 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체의 세부사항을 수신하는 단계로서, 상기 각 로컬 의도 진술 및 각 개체의 세부사항이 자연 언어의 형태로 수신되고 잠재성 상태로 각각 설정되고, 상기 각 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내고, 각개체가 해당 로컬 의도 진술에 의해 표시된 단계에 참여하는, 수신 단계; 하나 이상의 에이전트를 각 로컬 의도 진술에 할당하는 단계로서, 상기 로컬 의도 진술에 할당된 에이전트의 세부 사항이 사용자에 의해 수정 가능한 할당 단계; 상기 각 로컬 의도 진술에 대해, 사용자로부터 자연 언어의 형태로, 각각의 로컬 의도 진술의 특성을 규정하는하나 이상의 속성을 수신하는 단계; 상기 각 개체에 대해, 사용자로부터 자연 언어의 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 수신하는 단계; 상기 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 하는 조합 개체상태(CES) 집합을 형성하는 단계로서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES가 잠재성 상태로 있는 조합 개체 상태 집합의 형성 단계; 상기 글로벌 의도 진술과 연관된 단지 하나의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 상기 수신 로컬 의도 진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 단계;상기 글로벌 의도 진술과 연관된 하나 이상의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 사용자로부터자연 언어의 형태로, 로컬 의도 진술들 간의 관계를 수신하는 단계로서, 상기 관계는, 하나의 로컬 의도 진술의트리거 CES가 솔루션의 다른 로컬 의도 진술의 CES 집합에 영향을 미치거나 솔루션의 구축 종료인지 여부를 나타내는, 수신 단계; 상기 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상태로 존재하게 되는 경우의 시작 시간을 기록하는 수단: 및 상기 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로존재하게 되는 경우의 정지 시간을 기록하는 단계를 수행하도록 하는, 비 일시적 컴퓨터 판독 가능 매체."}
{"patent_id": "10-2023-7006405", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "자연 언어 기반 설계를 사용하여 애플리케이션 또는 솔루션 논리를 컴퓨터에 전달할 때 '프로그래밍 코드'를 효 과적으로 대체하는 컴퓨터 구현 방법에 관한 것이다. NSL은, 소외된(alien) 기호나 키워드를 전혀 참조하지 않고, 컴퓨터 구현 방법을 사용하여 표준적이고 친숙한 자연 언어와 유사한 구성(영어뿐만 아니라 모든 자연 언 (뒷면에 계속)"}
{"patent_id": "10-2023-7006405", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 명세서에 기술된 발명의 대상은, 본 출원의 해당 PCT 출원번호 PCT/SG2020/050004의 명세서가 출원되고 청구 된 주 특허(인도 특허출원 번호 201941001135)의 명세서에서 청구된 발명을 개선 또는 변형한 것이다. 본 발명은 정보 기술 분야에 관한 것이다. 보다 구체적으로, 본 발명은 솔루션을 설계하고 전개하기 위한 컴퓨 터 구현 방법, 시스템, 및 컴퓨터 판독 가능 매체에 관한 것이다."}
{"patent_id": "10-2023-7006405", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "소프트웨어 엔지니어링, 설계 및 아키텍처 관행은 지난 60년 동안 상당히 변화하고 발전했다. 단순화를 위해, 연산 논리를 컴퓨터에 전달하는 여러 레벨의 추상화(abstraction) 레벨을 다음 두 그룹으로 나눌 수 있다: 프로그래밍 언어를 통해 전달되는 고급 응용 논리; 및 컴퓨터와 그 조작을 보다 직접적으로 중재하거나 처 리하는 운영체제 및 이하(operating-systems-and-below). 주로 널리 사용되는 다음의 세 가지 운영 체제가 있다: Microsoft Windows, Apple Mac OS X, 및 Linux. 그러나 수백 개의 프로그래밍 언어가 있다. 일반적으로 말해서, 모든 프로그래밍 언어는 코드(자연 언어 및 산술에서 제거된 특정 의미와 기능을 가진 기호)에 의해 광범위하게 구동된다. 소프트웨어 전문가와 엔지니어가 모든 프 로그래밍 언어를 마스터하고 솔루션 생성 또는 유지 관리에 참여하는 데는 몇 주에서 몇 달이 걸린다. 결과적으 로, 솔루션 사용자는 일반적으로 기술 전문가의 개입 없이 상황에 따라 솔루션을 생성하거나 수정할 수 없다. 수년에 걸쳐, 정보 기술의 배후에 있는 컴퓨팅 및 통신 능력은 상당히 크게 성장했다. 일반적으로, 소프트웨어 설계 및 관리 기술은 구성 요소 기반 설계, 서비스 지향 아키텍처, 웹 서비스, 비즈니스 프로세스 관리 및 민첩 한 프로젝트 관리 방법론으로 이동하면서 향상되었다. 동시에, 이동 부품의 수가 급증함에 따라 기술 환경은 더 욱 복잡해졌다. 일반 사용자는 가능한 것에 비해 솔루션 설계에 직접 참여하거나 지속적으로 영향을 미칠 수 있 는 위치에 있지 않기 때문에, 컴퓨터로부터 계속 소외되어 왔다. 사용자가 기술 전문가 및 중재자에게 과도하게 의존하는 것은 프로그래밍 언어가 자연 언어와 매우 다르기 때문이다. 기술 시스템은 컴퓨터 언어가 자연 언어 와 거의 동일하게 기술적이고 창의적이며 혁신적인 기회를 실현하지 못하였다. 자연 솔루션 언어(Natural Solution Language, NSL)는 프로그래밍 코드를 통해 컴퓨터에 솔루션 또는 응용 논리 를 전달할 필요를 배제함으로써 변형 효과를 생성한다. NSL에 의해, 사용자는, 자연 언어 자체와 거의 동일한 자연 언어 구조를 사용하여, 사용자의 요건을 기술 전문가에게 전달하는 바와 같이, 솔루션 논리를 컴퓨터에 직 접 전달할 수 있다. NSL은, NSL-TF 라고 하는 '기술 프레임워크' 계층에 의존하며, 이는 그들의 운영 체제의 불가결한 부분인 것처 럼 기능한다. NSL은 기존의 기능과 프로세스가 정보로 변환되는 '차별화 원리'라는 단순하지만 강력한 방법에 의해 추진된다. NSL은 근본적으로 모든 솔루션 논리가 개체 및 해당 관계와 관련된다는 사실에 의해 영향을 받 는다. NSL은 사용자에게 권한을 부여하고, 모든 관련 개체를 사용자 인터페이스 레벨로 가져옴으로써 솔루션 설계, 유 지 관리, 및 관련 조작을 민주화한다. NSL의 특징, 용어, 개념 및 적용은 인도 특허 출원번호 201941001135 및 해당 PCT 출원번호 PCT/SG2020/050004 에 보다 자세히 설명되어 있다. 인도 특허 출원번호 201941001135 및 해당 PCT 출원번호 PCT/SG2020/050004의 설명은 본 명세서에 참고로 포함된다."}
{"patent_id": "10-2023-7006405", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "발명의 개요 본 발명은 현재 사용 중인 임의의 확립된 기존 솔루션 프레임워크와 NSL의 동등성(equivalence) 원리를 확립하 는 NSL 기술 프레임워크(NSL-TF)와 통합되는 추가적인 특징 및 개념에 관한 것이다. BET(Binary Entities)의 솔루션을 정량화하고 BET가 여러 섭스트레이트(substrate)에 존재할 수 있도록 함으로써, NSL은 섭스트레이트 크 로스오버 및 섭스트레이트 태깅(tagging)을 가능하게 하여 기존 시스템에 없는 가장 효율적인 솔루션을 구축하 는 데 잠재적으로 강력한 영향을 미칠 수 있다. NSL은 인간 에이전트와 기계 에이전트 간의 정보 비대칭 및 기능적 비대칭을 제거하는 것을 목표로 한다. 분석 엔진과 추론 엔진은 인간의 행동을 복제하거나 경우에 따라 대량의 데이터를 처리하고 빠른 결정을 내리고 인간 의 개입 없이 행동할 수 있는 능력을 통해 인간 지능을 능가함으로써 기계의 진정한 잠재력을 발휘하도록 돕는 다."}
{"patent_id": "10-2023-7006405", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "시스템, 디바이스 또는 장치 및 방법이 본 명세서에서 예시 및 실시예를 통해 설명되지만, 당업자는 솔루션을 제공하기 위한 시스템 및 방법이 설명된 실시예 또는 도면으로 제한되지 않음이 이해될 것이다. 도면 및 설명은 개시된 특정 형태로 제한하려는 것이 아님을 이해해야 한다. 오히려, 그 의도는 첨부된 청구 범 위의 정신과 범위 내에 있는 모든 수정, 동등물 및 대안을 포함하는 것이다. 본 명세서에서 사용된 임의의 제목 은 구성 목적으로만 사용되며, 설명 또는 청구 범위를 제한하지 않는다. 본 명세서에서 사용된 바와 같이, \"할 수 있다(may)\"라는 단어는 의무적 의미(예를 들어, 필수를 의미함)보다는 허용적 의미(예를 들어, 잠재적이라는 의미)로 사용된다. 유사하게, \"포함하다(include)\" 및 \"포함하는(including)\"이라는 단어는 포함하는 것을 의미 하지만 이에 제한되지 않는다. 다음 설명은 특허 출원을 할 때 발명자에게 알려진 본 발명을 수행하기 위해 현재 고려되는 최선의 방법 및 시 스템, 디바이스 또는 장치에 대해 완전하고 유익한 설명이다. 물론, 다음의 설명, 첨부 도면 및 첨부된 청구 범 위를 고려하여 관련 기술 분야의 숙련자에게는 많은 수정 및 개조가 명백할 것이다. 본 명세서에 설명된 시스템, 디바이스 또는 장치 및 방법에는 어느 정도의 특이성이 제공되지만, 본 기술은 사용자의 필요에 따라 더 크거나 더 적은 특이성을 가지고 구현될 수 있다. 또한, 본 기술의 일부 특징은 다음 단락에서 설명하는 다 른 특징의 해당 사용 없이 이점을 얻기 위해 사용될 수 있다. 이와 같이, 본 기술은 청구 범위에 의해서만 정의되기 때문에, 본 설명은 본 기술의 원리를 단지 예시하는 것으로 간주되어야 하며 그에 제한되지는 않는다. 예비 사항으로서, 다음 논의 및 첨부된 청구 범위의 목적을 위한 용어 \"또는\"의 정의는 포괄적인 것이다. 즉, 용어 \"또는\"은 상호 배타적인 두 가지 대안을 구별하기 위한 것이 아니다. 오히려 두 요소 사이의 결합으로 사 용될 때 \"또는\"이라는 용어는 하나의 요소 자체, 다른 요소 자체, 요소의 조합 및 순열을 포함하는 것으로 정의 된다. 예를 들어, 용어 \"A\" 또는 \"B\"를 사용하는 설명은 \"A\" 자체, \"B\" 자체, 및 \"AB\" 및/또는 \"BA\"와 같은 이 들의 임의의 조합을 포함한다. 본 설명은 예시적인 실시예에 관한 것이며, 첨부된 청구 범위는 본 명세서에서 설명된 실시예로 제한되지 않아야 한다는 점에 주목해야 한다. 본 명세서의 설명을 위해, 프로세서는 마이크로프로세서, 마이크로 컴퓨터, 마이크로 컨트롤러, 디지털 신호 프 로세서, 중앙 처리장치, 상태 기계, 논리 회로, 및/또는 동작 명령을 기반으로 신호를 조작하는 임의의 디바이 스로 구현될 수 있다. 다른 능력들 중에서, 프로세서는 프로세서에 연결된 비 일시적 컴퓨터 판독 가능 저장 매 체에 저장된 컴퓨터 판독 가능 명령을 페치(fetch)하고 실행할 수 있다. 비 일시적 컴퓨터 판독 가능 저장 매체 는 예를 들어, 휘발성 메모리(예를 들어, RAM) 및/또는 비 휘발성 메모리(예를 들어, EPROM, 플래시 메모리, NVRAM, 멤리스터(memristor) 등)를 포함할 수 있다. 본 명세서의 설명을 위해, 메모리는 컴퓨팅 장치의 메모리일 수 있고, 예를 들어 휘발성 메모리(예를 들어, RAM) 및/또는 비 휘발성 메모리(예를 들어, EPROM, 플래시 메모리, NVRAM, 멤리스터 등)를 포함하는 임의의 비 일시적 컴퓨터 판독 가능 저장 매체를 포함할 수 있다. 본 명세서의 설명을 위해, 모듈은 무엇보다도 특정 작업을 수행하거나 특정 데이터 유형을 구현하는 루틴, 프로 그램, 객체, 구성 요소, 데이터 구조 등을 포함한다. 모듈은 컴퓨팅 장치의 애플리케이션을 보완하는 모듈, 예 를 들어 운영 체제의 모듈을 더 포함한다. 운영 체제는 배치 운영 체제, 시분할 운영 체제, 분산 운영 체제, 네 트워크 운영 체제 및 실시간 운영 체제 중 적어도 하나를 포함한다. 아래 나열된 각각의 용어는 컴퓨터 구현 NSL 방법론과 관련하여 특정 역할 및 애플리케이션을 가지고 있다. 이 러한 개별 기술적 및 방법론적 요소는 NSL과 관련하여 설명된 역할을 가지고 있다. 자연 솔루션 언어(NSL)는 자연 언어와 유사한 방식으로 기계와 통신함으로써 프로그래밍 언어를 효과적으로 대 체할 것이라고 주장된다. 자연 솔루션 언어(NSL)가 혁신적인 기술적 효과를 유발하려면, 컴퓨터로 구현된 방법 을 적용해야 한다. 이 방법은 상황에 따라 개체와 그 관계에 대한 민감한 접근 방식을 필요로 한다. 개체와 그 관계는 서로 다른 변형으로 나타나며, 이러한 변형들 각각은 적절하게 규정되고 처리되어야 한다. NSL의 센트럴 도그마: 모든 솔루션은 에이전트의 의도성의 컨텍스트에서 개체와 개체의 관계에 관한 것이다. 모 든 솔루션은 하나의 원하는 상태로부터 다른 원하는 상태로 이동하는 것이다. 대부분의 솔루션은 일련의 연결된 솔루션 상태를 통해 원하는 상태로 이동하는 것이다. 개체(entities): 개별적인 것은 어느 것이나 개체가 된다. 즉, 고유한 지위를 가지고 있고 정보로 표현할 수 있 는 것이 개체이다. 언어에서, 개체는 단어, 기호 또는 숫자로 표시된다. 예: 자동차가 개체가 될 수 있는 것처 럼, 모래 알갱이도 개체가 될 수 있다. 차별화된 개체: 개별적이면서 동시에 기타 개체와 상이한 것이 차별화된 개체이다. 즉, 일부 다른 개체와 비교 할 때, 상이한 것이다. 자연 언어에서 이들은 단어로 표현된다. 예를 들어, '펜'은 '종이'와 다르다. 차별화되지 않은 개체: 개별적이고 또한 일부 다른 개체 또는 개체들과 동일한 것은 다른 개체 또는 개체들에서 차별화되지 않은 것으로 간주된다. 이러한 '반복(recurrences)'은 시공간에서 발생한다. 이들 반복은 수학 영역 에 속하며 숫자로 표시된다. 솔루션 설계 관점에서, 하나의 개체가 결과에 영향을 주지 않고 일부 다른 개체로 효과적으로 대체될 수 있는 경우, 해당 개체는 공간 또는 시간에서 반복되는 것으로 간주된다. 예를 들어, 탁자 위에 펜과 종이가 있으면, 우리는 탁자 위에 \"펜과 종이가 있다\"라고 말한다. 그런데 탁자 위에 펜이 하나 있고 '또 다른 펜'이 있으면, \"탁자 위에 펜이 두 개 있다\"라고 말한다. WWW(Way World Works) 원리: 전형적인 기술보다는, NSL은 솔루션 아키텍처의 새로운 패러다임을 생성하는 과학 과 기술의 이해가 혼합된 것이다. WWW는 오늘날의 과학이 이해하고 인식하는 방식으로 우주나 자연이 기능하는 방식을 안내하는 원리이다. NSL 논리는 세계가 작동하는 방식에 대한 모든 과학적 통찰력을 활용하고 인간 에이 전트(human agent)가 컴퓨터를 사용하여 찾는 솔루션과 관련하여 특정 혁신적인 방법론을 제공한다. 예: 모든 것들이 입자들로 구성되어 있다는 것, 입자들이 결합할 때 신생(emergent)의 속성이 생기는 것, 모든 일이 시공 간에서 일어나는 것, 모든 이벤트는 에너지에 의해 주도된다는 것 등이 www 원리이다. 이들은 차례로 에이전트가 수행하는 일과 지시된 변경을 통해 원하는 상태로부터 다른 상태로 이동하는 방법과 관련이 있다. 잠재적 개체 대 비잠재적 개체: 솔루션 설계는 개체 및 이들의 관계를 포함한다. 이러한 개체는 솔루션 설계의 컨텍스트에서 실제 세계로부터 선택된다. 솔루션과 관련하여 보유하고 있는 잠재성을 위해 선택된 것들을 '잠재 적 개체'라고 선언된다. 솔루션 관련 '잠재적 집합(set)'에 포함되지 않은 것들은 제외되며, 솔루션 생태계의 관점에서 관련성이 없다. 솔루션 생태계: 솔루션 설계자는 '실제 세계'로부터 잠재적 개체를 선택하고 사용하여 이들 간의 관계를 설정한 다. 잠재적 개체 간의 관계는 확립된 변경 경로를 따라 솔루션을 가질 수 있는 방식으로 조합하고 상호 작용하 는 것과 같다. 독립 개체: 이들은 이진 이벤트가 발생하는 레벨의 개체이다. 즉, 잠재성과 현실 사이의 전환이 발생하여 이들 이 참여하는 조합 개체 상태의 변경을 초래한다. 예: 펜이 존재하게 되거나 사라질 수 있다. 독립 개체 이벤트 가 발생하면, 그것이 속한 조합 생태계의 상태를 변경할 수 있다. 종이와 함께 잠재적 개체로 존재한다면, 이들 은 함께 2∧2 또는 4의 잠재적 조합 상태를 유발할 수 있다. 암시적 개체: 많은 경우, 다른 개체에 연결된 개체는 암시되고 무시된다. 예: 사람이 거리에 들어가면, 이것은 그가 입는 옷과 관련하여 그곳에 있다는 것을 의미한다. 여기서 옷은 암시되어 있다. 마찬가지로, 인간 에이전 트가 숨을 쉴 수 있는 공기가 있음을 암시한다. 객실 예약의 경우, 정보 입력을 위한 '에이전트'의 존재가 암시 될 수 있다. 솔루션 설계자는 이러한 암시된 개체가 주어진 것으로 간주한다. 대부분의 경우 속성조차도 암시된 다. 모든 변경은 '변경 유닛'(SI) 내에서 발생한다. 변경은 물리적 상호 작용이 공간과 시간에서 발생할 때만 발생한다. 하나의 독립 개체의 공간과 시간이 알려지면, 다른 개체의 공간과 시간 속성이 암시될 수 있다. 그렇 지 않은 경우에도, 솔루션 설계자의 경우 이러한 속성을 지정하지 않아도 설계자가 동일하게 지정하지 않도록 하는 설계의 본질이 변경되지 않을 수 있다. 공유(shared) 개체: 공유 개체는 많은 로컬 또는 글로벌 의도 진술(statement-of-intent, SI)에서 공통된 개체 이다. 임의의 의도 진술에 대한 트리거(trigger) 상태의 일부인 독립적 개체가 많이 있다. 의도 진술이 트리거 상태에 있으면, 트리거와 연관된 경과 시간 동안, 해당 개체는 임의의 다른 의도 진술과 관련하여 참여할 수 없 다. 그러나 일단 트리거된 변경이 완료되면, 참여 개체는 모든 관련 의도 진술에서 공유 개체로 다시 사용 가능 하게 된다. 속성: 속성도 하나의 개체이지만 그 존재를 위해 다른 개체에 종속하는 속성이다. 이러한 종속 개체를 명시적으 로 속성이라고 한다. 종속성은 다른 독립 개체의 존재로 인한 하나의 개체의 존재로서 규정된다. 예를 들어, 펜 은 공간과 시간에 존재할 수 있다. 여기서, 공간과 시간은 속성 또는 종속적인 개체로 간주된다. \"공간 단위\" 또는 \"시간 단위\"는 그 자체로 개체라고 할 수 있는 자격이 있는 것에 주목해야 한다. 그들은 상위 레벨 개체에 종속되므로, 그들을 속성이라고 한다. 펜이 삭제되면, 속성은 자동으로 삭제된다. 일부 암시적 정보는 인식되지 만 솔루션의 중심이 아닐 수 있으므로 무시된다. 예: 누군가 옷을 잘 입든 못 입든 관심을 가질 수 있다. 그러 나 셔츠의 색상은 신경 쓰지 않을 수 있다. 때로는 암시적 정보를 알 수 없거나 액세스할 수 없는 경우가 있다. 예: 자신의 몸에 있는 세포의 수를 모를 수도 있고, 다시 말하면, 대부분의 사람들은 몸에 '비장'이라는 기관이 있다는 사실을 모를 수도 있다. 속성은 컨텍스트가 요구하는 대로 개체와 연관된 암시적 및 연관된 정보를 표면 화하는 데서 발생한다. 속성의 레벨: 속성이 존재할 수 있는 레벨의 수에는 제한이 없다. 제1 레벨은 '일차 속성', 제2 레벨은 '이차 속성', 제3 레벨은 '삼차 속성' 등과 같이 불린다. 예: 제1 레벨에서 인도로 공간이 규정된 경우, 각 주는 2차 레벨에 있고, 각 도시는 3차 레벨에 있다. 자연 속성 값: 주어진 솔루션에서 속성 값으로 첨부된 임의의 정보는 이 범주에 속한다. 따라서 공간 좌표와 시 간은 표준 필수 속성이므로 자연스럽게 이 범주에 속한다. 무게, 부피, 색상 등과 같이 개체에서 추출된 임의의 속성 값도 이 범주에 속한다. 유도된 속성 값: 이름이 나타내는 바와 같이, 모든 유도된 속성 값은 이 범주에 속해야 한다. 간단히 말하면, 서로 다른 종류의 확립된 통계기법을 적용하여 도출한 모든 값은 이 범주에 속하게 된다. 예: 확률, 상관관계, 변동성, 평균, 비율, 각종 측정치, 회귀분석 등. 이러한 값은, 상황에 따라, 실시간으로 또는 배치(batch) 모드 를 통해 유도될 수 있다. NSL은 솔루션 설계자 또는 사용자가 찾고 있는 것을 지정하는 유연성을 주는 이러한 옵션을 제공한다.정보적 개체: 정보적 개체는 자신이 소유하고 있는 표상적(representational) 개체를 생태계의 다른 에이전트와 통신할 목적으로 인간 에이전트에 의해 인위적으로 생성된 개체이다. 진실 값: 표상적 개체가 '실제 개체' 또는 '기타 표상적 개체'를 나타내는 것으로 알려져 있지만, 진실 값은 자 연 고유의 불확실성이나 인간 에이전트의 이해, 동기 또는 의도를 포함한 여러 요인으로 인해 달라질 수 있다. 예: \"X\"가 \"Y\" 위치에 있다고 표현할 수 있지만, 올바른 진술일 수도 아닐 수도 있다. 맞으면 \"참\"으로 간주하 고 부정확하면 \"거짓\"으로 간주한다. 물리적 현실: 모든 개체 (실제, 지각적 및 정보적 개체)는 물리적 세계에 '물리적으로' 존재한다. 실제 개체와 관련하여 이러한 결론에 도달하는 것은 직관적이지만, 지각 및 정보 개체도 공간과 시간이라는 물리적 현실에 존재한다는 사실을 분명히 알아야 한다. 그들이 표상적 개체인 것으로부터 가치를 도출한다는 사실은 물리적인 존재의 성격을 바꾸지 않는다. 변경 드라이버: 변경 유닛의 변경을 가져오는 개체는 그 속성과 함께 변경 드라이버로 알려져 있다. 속성도 개 체이지만, 이들은 독립적 개체에 종속된다. 독립적인 개체를 더욱 차별화하는 속성 계층은 얼마든지 있을 수 있 다. 임의의 변경 드라이버는 슬롯이 있으며, 모든 슬롯은 변환 경로에 연결된다. 각 슬롯을 변경 구성 요소라고 한다. 각 드라이버는 고유하고 개별적인 ID 및 고유 정보를 가지고 있다. 변경 유닛(CU): 변경 유닛은 자연 언어 관점에서 의도 진술에 의해 설명되는 것이다. 임의의 종류의 가치는 제 어된 변경을 통해서만 발생하며, 변경 유닛 내에서만 발생한다. 인간 에이전트가 원하거나 의도하는 글로벌 변 경 유닛에 도달하는 것은 로컬 변경 유닛을 함께 짜맞추는(knitting) 것에 의한다(문장을 조합하여 단락 만들기). 단순성을 위해, NSL에서는 이러한 변경 유닛을 의도 진술과 동의어로 취급한다. 따라서, 본 명세서에 서 CU와 SI를 교호적으로 사용한다. 로컬 의도 진술은 자연 언어 측면에서 의도 진술(문장)로 표현되는 로컬 ' 변경 유닛'이다. 글로벌 의도 진술은 자연 언어 측면에서 글로벌 의도 진술(문단)로 표현되는 '글로벌 변경 유 닛'이다. 이벤트: 모든 이벤트는 하나의 로컬 의도 진술 등에 도달한다. 모든 이벤트는 하나의 상태로부터 다른 상태, 즉 잠재적 상태로부터 현실로 또는 그 반대의 경우로 전환되는 개별 개체에 관한 것이다. 개별 개체가 LSI로 출발 하거나 LSI로부터 도착하는 방식으로 이벤트가 발생하면, 조합 집합의 상태가 전체적으로 변경된다. LSI에 6 개 의 가변 개체가 있는 경우, 조합 개체가 존재할 수 있는 64 개의 서로 다른 상태가 있을 수 있다. 개별 개체 레 벨에서 이진 상태가 변경되면 LSI의 64 개 상태 중 어느 하나로 이어질 수 있다. 63 개의 다른 상태가 비 트리 거(non-trigger) 조합 개체 상태에 있을 수 있지만, 64 번째 상태는 다른 LSI 상태 또는 자체에 영향을 미치는 트리거 상태에 있게 된다. 이진 상태(Binary States): NSL 솔루션 설계에서, 모든 개체 상태는 이진 상태에서만 존재하는 것으로 표현된다. 즉, 그들은 잠재성 상태 또는 현실 상태에 존재한다. 모든 상태는 이산적(discrete)이며 중간 상태가 없다. 이러한 관점에서, 각 단어는 이진 상태로 작동하며, 문장과 문단도 이진 상태로 존재한다. 에이전트는 개 체를 보는 유리한 지점만 계속 변경한다. 확대하거나 축소하면서, 유리한 지점이 변경되지만, 각 유리한 지점은 이진 상태에 있다. NSL 솔루션 설계에서 이진 상태를 선택하는 것은 디지털 대 아날로그를 선택하는 것과 유사 하게, 이산 상태와 연속 상태에 대한 선택이다. 이벤트가 발생하면, 중간 상태를 제외하고 상태 전환이 있게 된 다. 이론적으로 이러한 이진 상태는 '참 또는 거짓' 값을 할당하여 나타낼 수도 있다. 경과 시간: 설명된 바와 같이, 트리거 상태가 의도 진술에서 달성될 때, 그것은 자신의 의도 진술을 포함하는 하나 이상의 의도 진술에서 하나 이상의 변경을 촉진한다. 모든 변경에는 시간이 걸린다. 이러한 기간을 '경과 시간'이라고 한다. 변경이 인간 에이전트에 의해 주도되든 기계 에이전트에 의해 주도되든 항상 경과 시간이 수 반된다. 어떤 경우에는, 이러한 변경은 몇 초 만에 발생할 수 있으며, 다른 경우에는 시간이 몇 시간 또는 며칠 이 걸릴 수 있다. 필요한 변경을 생성하는 상호 작용에 관련된 모든 개체는 경과 시간 동안 점유되고, 이전 작 업이 완료된 후에만 임의의 다른 트리거에 참여할 수 있게 된다. 자연 솔루션 언어(NSL): 이것은 약간 수정된 자연 언어의 수정 버전, 컴퓨터 구현 방법이며, 여기에서 의도 진 술만을 캡처하고 모든 서술적 진술을 의도 진술에 종속되게 만드는 형태로 사물이 재구성(recast)된다. 이들 의 도 진술은 다음 두 가지 상태로 존재한다: i) 정적 의도 진술: 이들은 의도를 표현하지만 그들을 현실로 변환하는 능력이 부족하다. 정적 개체 상태는 다 른 상태에서 변경을 유발할 수 있는 특성이 없는 개체 상태이다. 시스템에 6 개의 변수가 있는 경우(독립 개체 및 그들의 속성), 이들은 잠재적으로 64 개의 상이한 상태로 존재할 수 있다. 그러나 모든 변수가 '현실' 상태에 있을 때 64 번째 상태만이 변경을 유발할 수 있다. 다른 모든 개체 상태를 '정적 개체' 상태라고 한다. 이와 관련하여 주목해야 할 점은 의도 진술(SI)이 원하는 변경의 성질을 설명하는 또 다른 독립적인 개체로, '변경 유닛'에 참여한다는 것이다. SI의 존재는 임의의 후속 조치로, 에이전트의 의도에 의해 백업되어야 한다는 사실 에 기인한다. ii) 동적 의도 진술: 이들은 독립 개체 레벨에서 이벤트의 영향을 받는 것과 같이, 트리거 조합 개체 상태라고 하는 특정 원하는 상태에 도달할 때 집합적으로 유발하는 의도 진술 뒤에서 개체를 유발하는 기본 변환이다. 동 적 개체 상태는 자신을 포함하여 하나 이상의 개체 상태를 추가로 변경할 수 있는 능력이 있는 개체 상태이다. 이전의 예에서, 64 번째 상태는 '동적 개체' 상태이다. 즉, 정적 의도 진술이 동적이 되고 의도 진술을 이행하 기 위해서, 트리거 CES에 의해 전원이 공급되어야 한다. 유리한 지점(vantage points): 각 기본 개체는 개별 레벨에서 이진 상태로 존재한다. 개체는 또한 조합하여 조 합 개체를 형성한다. 유리한 지점은 개체를 볼 수 있는 상대적 위치를 나타낸다. 더 높은 유리한 지점(모든 하 위 집합으로 구성된 차별화 사다리의 더 높은 단계)에서 개체를 전체적으로 본다면, 연결된 개체가 상당히 많아 진다. 반대로, 더 낮은 유리한 지점(차별화 사다리의 더 낮은 단계)에 있는 개체를 본다면 연결된 개체가 훨씬 더 적어진다. 예: 차별화 방향에서 바라볼 수 있는 더 높은 유리한 지점 'A'를 상상해 본다. 'A'는 차별화 하위 집합 'A-B'를 가질 수 있다. 이것이 'C'와 조합하면, 제2 레벨의 더욱 차별화된 하위 집합 'A-B-C'를 갖는다. 'A-B'는 하위 집합 'A-B-C'만을 포함한다. 'A-B'는 'A'에 비해 차별화 방향으로 연결된 개체가 적다. 또 다른 방법은 높은 유리한 지점 개체가 낮은 유리한 지점 개체에 비해 더 많은 정보를 전달하는 것이다. 유리한 지점 전환: 차별화는 연결된 CES 및 ECES를 통해 수평적으로 진행된다. 수평 차별화의 예는 도 18a에 나 타나 있다. 차별화는, 클래스, 하위 클래스, 임의의 수의 하위-하위 클래스의 생성을 통해, 트랜잭션 클래스 또 는 하위 트랜잭션 클래스에 이르기까지 수직 방향으로 할 수도 있다. 수직 차별화의 예는 도 18b에 나타나 있다. 수직 차별화 트리(tree) 아래로 내려갈 때, 차별화의 범위는 계속 증가한다. '판정(adjudication)' 또는 '최적의 차별화'를 위해 솔루션 설계자는 트랜잭션 클래스가 상황에 따라 적용할 상위 레벨 또는 하위 레벨 차 별화 사이를 전환할 여지를 남겨둘 수 있다. 더 많은 정보를 빼거나 무시함에 따라 더 높은 유리한 지점으로 이 동한다. 예를 들어 피자 배달 애플리케이션을 만들 때, '피자'라는 정보를 무시하면 음식 배달이 된다. 음식이 라는 정보를 무시하면 배달이 된다. 여기서, 정보가 존재하지만 더 높은 유리한 지점에서는 정보가 무시된다. 또한, NSL에서 모든 개체는 이진 상태로 존재한다. 노드는 개체의 존재를 나타낸다. 변형선(transformational line)은 개체들 간의 관계를 나타낸다. 노드들 사이의 화살표는 차별화 방향을 나타낸다. 유리한 지점은 임의의 노드에 앉아서 차별화 방향을 바라보는 것을 나타낸다. 차별화 노드의 맨 끝은 차별화 노드 집합의 최대 차별화 끝을 나타낸다. 하나는 노드 집합을 취하고, 각 노드에 개체 특정 정보를 첨부함으로써 동일하게 차별화할 수 있다. 각 노드에 대한 모든 개체 특정 정보를 의도적으로 스위치 오프할 수 있는 경우, 차별화된 노드 또는 개 체만 남는다. 차별화되지 않은 개체는 동일한 개체와 같다. 이것은 시스템에서 개체 또는 'BET' 카운트를 취할 수 있는 방법이다. 예측이나 추천을 하는 관점으로부터 시스템을 관찰할 수 있다. 더욱 차별화된 레벨에서 예측 에 대한 신뢰도가 높아지는 상황이 있을 것이다. 예를 들어, 사람은 그것이 동물이고 개이며 검은색이라고 확신 한다. 그것이 동물이고 개라고 확신하지만 그 색에 대해 확신이 없다면, 예측이나 추천을 하기 위한 안전한 경 로는 개의 유리한 지점으로 전환하는 것이다. 개인지 다른 동물인지조차 불명확하다면, '동물'의 유리한 지점에 서 추천하는 편이 나을 것이다. 이 예는 도 43에 나와 있다. 정보나 지식의 레벨에 맞게 서로 다른 레벨이나 유 리한 지점 사이를 전환하는 것을 유리한 지점 전환이라고 한다. 이는 NSL이 취급하는 판정의 원리와 유사하다. 방향성: 이것은 개체 값의 추가 또는 개체 값의 삭제를 기반으로 차별화 트리를 위 또는 아래로 이동하는 것에 관한 것이다. 새로운 개체 값을 추가하면 양의 차별화 방향으로 이동하게 된다. 값을 삭제함으로써, 음의 차별 화 방향으로 이동하게 되고, 즉 '비 차별화' 또는 '일반화' 또는 '통합'의 방향으로 이동한다. 조합 개체 상태(CES): 독립 개체(그들의 속성을 드래그하여 얻은)가 다른 독립 개체와 결합할 때, 이들은 차별 화되고 그들 자신의 신생의 속성을 가진 조합 상태를 발생시킨다. CES는 문장과 동일한, 변경 유닛을 각각 나타 내는, 로컬 의도 진술(LSI)에 수용(housed)된다. 더 큰 원하는 변경으로 이어지는 이러한 LSI의 수집은 문단과 동일한, 글로벌 의도 진술(GSI)이라고 한다. LSI에서 CES의 크기는 참여하는 독립 개체의 수에 비례한다. 각 LSI는 2∧n 개 상태를 향유(entertain)하며, 여기서, 'n'은 독립된 개체의 수이고, 각 독립된 개체는 '잠재성' 또는 '현실' 상태로 존재할 수 있다. 기본적으로, 각 로컬 의도 진술에는 다음 두 종류의 조합 개체 상태가 있 다: i) 비 트리거 CES: 이것은 다른 로컬 의도 진술 또는 이들이 속한 동일한 LSI 내에서 조합 개체 상태에서 변경 을 일으키지 않는 개체 조합이다. 예를 들어, 이진 변수로서 4 개의 독립 개체가 있는 경우, 이들은 2∧4 개의 개체 상태, 즉 16 개의 CES를 발생시킨다. 이 상태 중, 15 개 상태는 어떠한 변경도 트리거하지 않으므로 비 트 리거 CES가 된다. ii) 트리거 CES: 이 조합 개체 상태는 하나 이상의 다른 LSI 또는 동일한 LSI 내에서 변경을 트리거한다. 트리 거 CES는 모든 독립 개체와 그 속성이 현실 상태에 있는 것이다. 한 LSI의 CES가 다른 LSI의 CES에 영향을 미치 면 해당 문장이 연결된다. LSI는 GSI 실현에 대한 참여를 기반으로 함께 그룹화되어 단락을 만든다. 예를 들어, 이전 예에서와 같이, 16 번째 상태는 4 개의 독립 개체가 모두 해당 상태의 현실 상태에 있기 때문에 트리거 상 태이다. 에이전트: 에이전트도 개체이다. 에이전트는 솔루션의 작성자이자 솔루션의 소비자이다. 에이전트는 목적에 따 라 움직이므로 '자연'과 차별화된다. 즉, 그들은 유리한 변경을 추구하고 불리한 변경을 회피한다. 모든 솔루션 이 제어된 변경을 처리하므로, 모든 변경 유닛은 인간 에이전트든 기계 에이전트든지, 에이전트의 영향을 받는 것으로 가정된다. 모든 변경에는 에너지가 필요하기 때문에, 에이전트는 그들에 고유한 에너지를 사용하거나 하 나 이상의 조합적 개체에서 차용하고 미리 결정된 경로를 따르거나 자유 의지를 적용하여 변경으로의 방향성을 제공한다. 인간 에이전트: '이해 관계자(stakeholder)'라고도 하는 인간 에이전트는 솔루션 환경에서 부과하는 요구 사항 에 따라 여러 역할을 수행한다. 일부 변경 유닛은 필요한 인간 에이전트에 의해 구동된다. 예를 들어, 일부 '하 드 자산(hard asset)'의 물리적 전달에는 인간 에이전트가 개입해야 한다. 에이전트 기능: 의도 진술 내에서 발생하는 에이전트 기능은 다음의 세 계층의 의도 진술로 나눌 수 있다: i) 물리적 기능: 물리적 기능은 의도 진술의 중추를 형성하는 조합 개체 상태(CES)를 가져오는 독립 개체의 참 여와 관련된다. 물리적 기능은 솔루션을 촉진하는 주요 기능을 제공하는 반면, 다른 두 범주는 직접 또는 간접 적으로 물리적 기능을 지원한다. ii) 정보 기능: 정보 기능은 조합 개체 상태에 연결되고 정보를 제공하는 기능만 제공하지만, 물리적 기능에는 관여하지 않는 개체와 관련된다. 확장적으로, 이러한 정보 기능은 의도 진술 및 이를 주도하는 에이전트와 연결 된다. 정보 기능은 에이전트에게 충분한 정보를 제공하고 동적 솔루션 재 설계 및 분석, 기계 학습 및 인공 지 능과 같은 기타 부가 가치 기능에서 역할을 수행한다. iii) 마인드(mind) 기능: 컴퓨터로 구현된 NSL 관점에서 마인드 기능은 현실 세계에서 인간 마인드의 기능을 모 방한다. 이러한 기능은 개체 상태를 '예측'하고, 원하는 변환을 가져오는 과정에서 물리적 기능을 안내한다. 예 상은 일반적으로 미래와 관련된 '시간적 측면'에 적용한다. 그러나 예측은 불확실성이 있는 모든 상황에 적용될 수 있다. 이론적으로 불확실성은 과거 또는 현재의 것들과 관련될 수 있다. 예를 들어, 어떤 사람은 어제 무슨 일이 있었는지 또는 현재 다른 방에서 무슨 일이 일어나고 있는지 완전히 알지 못하지만 예상하려고 시도할 수 있다. '예상' 또는 \"추측'의 수정은 모든 이벤트의 사례에서 발생할 수 있다. 그러한 기대가 현재 물리적 기능 과 관련이 있다면, 이들은 영향을 미치는 개체로서의 물리적 기능으로 피드백된다. 정보 기능과 같은 유사한 역 할을 하는 것 외에도, 마인드 기능은 사전 계획 및 최적화 문제에도 도움이 된다. 정보 권한: 이는 특정 독립 또는 조합 개체 및 이와 관련된 의도 진술에 관한 정보에 대한 인간 에이전트의 권 리이다. 결정 권한: 이는 개인 또는 조합적 개체의 잠재성 또는 현실 상태를 변경하는 인간 에이전트의 권리와 이에 연 결된 의도의 진술이다. 기계 에이전트: 인간 에이전트 또는 다른 기계 에이전트가 설계한 대로 변경 유닛이 기계 에이전트에 의해 구동 되는 '컴퓨터'와 동의어이므로, 입력에 대한 응답으로 적절한 출력이 생성되도록 한다. 기계 에이전트는 본질적 으로 입력을 소비하고, 이들 중 제어된 변경을 가져오고(이러한 입력을 처리하고), 출력을 생성하는 능력에서 인간 에이전트를 모방한다. 어떤 의미에서 인간 에이전트는 기계 에이전트로 구동되는 자질을 부여한다. 사용자 인터페이스(UI): 개체는 데이터베이스 또는 사용자 인터페이스 레벨에서 서로 다른 추상화 레벨로 존재 할 수 있다. 인간 에이전트가 '정보 권한' 또는 '결정 권한'을 행사하는 곳이 바로 사용자 인터페이스 레벨이다. UI는 '사용자'가 솔루션의 생성 또는 사용을 담당하므로 NSL에서 매우 중요한 역할을 하므로, 모든 일은 후드(hood) 아래에서가 아닌 후드 위에서 발생하다. NSL은 UI를 '필수 속성'으로 만들어 UI 레벨에서 개체 의 동작을 구동한다. 이러한 속성은 개체가 UI 레벨에서 표시되는 방식, 그 주소(화면과 화면의 위치), 및 탐색또는 정보 입력 등에 민감하게 반응하는지 여부 등을 지정한다. NSL 기술 프레임워크: NSL이 가져오는 혁신적인 기술 효과는 고유한 방법과 기술 프레임워크의 조합 때문이다. NSL은 '사용자'가 솔루션의 주요 드라이버인 광범위한 애플리케이션 요구 사항을 충족하는 표준화된 기술 프레 임워크를 기반으로 한다. 이 문서에 설명된 모든 혁신적인 방법을 캡슐화하는 기술 프레임워크는 컴퓨터로 전달 되는 임의의 종류의 애플리케이션 논리를 수용하기 위해 운영 체제의 맨 위에 있다. 사실상, 사용자는 이 기반"}
{"patent_id": "10-2023-7006405", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "이 되는 기술 프레임워크에 구애 받지 않고 자연 언어와 같은 방법으로 NSL을 사용할 수 있게 된다. 요약하면, NSL 기술 프레임워크는 차별화 원리를 기반으로 NSL 뒤에 있는 원리와 방법에 생명을 불어 넣는 기존 운영 체제 위에 얇은 추가 계층이다. 또한, 대부분의 인간 에이전트 기능을 자동화하는 데 도움이 된다. 그러나 때때로 개 선을 위해 NSL 기술 프레임워크는 변함없이 유지될 것이다. 운영 체제와 마찬가지로, 어떠한 코드도 사용하지 않고 자연 언어 구조를 통해 NSL 논리를 컴퓨터에 전달한다. 기술 전환 프레임워크(TTF): NSL이 갖는 가장 중요한 것 중 하나는, NSL 방법과 NSL 기술 프레임워크(NSL-TF)를 사용하여 제어된 차별화를 다루는 동일한 원리를 기반으로 임의의 프로그래밍 코드를 NSL 형식과 같은 자연 언 어로 변환하는 가능으로, 사용자 또는 이해 관계자의 직접적인 사용 및 영향을 위한 논리를 표시할 수 있다. TTF는 각 프로그래밍 언어의 키워드, 연산자, 기호 및 기능과 해당 표현을 NSL로 캡슐화하는 행렬(matrix) 기반 /타일 기반 접근 방식에 우선한다. TTF는 코드의 구성을 분석하고, 코드가 기술되어 있는 프로그래밍 언어를 식 별하고, 행렬을 사용하여, 모든 키워드, 연산자, 기호, 함수 또는 이들의 조합에 해당하고 일치하는 NSL을 선택 한다. 기술 재전환 프레임워크(TRF): NSL이 가져오는 혁신적인 프레임워크는 NSL로 구성된 임의의 솔루션을 프로그래 밍 언어로 변환하는 기능이다. TRF는 TTF의 기반이 되는 동일한 행렬 기반 접근 방식을 기반으로 한다. TRF는 NSL 구성을 이해하고, 프로그래밍 언어에서 일치하는 키워드와 함수를 식별하여, 사용자가 선택한 임의의 프로 그래밍 언어로 코드를 구축한다. a. 전환 360°Any to Any(A2A): TRF는 TTF와 함께 360°Any to Any(\"A2A\")라고 하는 체제의 전체 수명 주기를 완료하며, 이는 임의의 프로그래밍 언어 또는 임의의 자연 언어로 된 솔루션을 임의의 다른 프로그래밍 언어 또 는 자연 언어로 변환하는 기능이다. 의미가 일정하고 다양한 자연 언어로 표현될 수 있는 것처럼, 솔루션 논리 는 임의의 프로그래밍 또는 자연 언어 섭스트레이트로 표현될 수 있다. NSL에서는 솔루션은 규범적 정보로 알려 진 특수한 종류의 정보이다. 잠재성 상태로 표현된 규범적 정보는, 조치를 취하면 현실이 되고 그 지시문은 클 래스 레벨에서 수행되며, 멤버들이 도착하면 트랜잭션 레벨에서 현실이 발생한다. 규정된 클래스에 도달하는 임 의의 멤버는 클래스와 동일한 방식으로 동작한다. 이것들은 전통적인 프로세스를 대체하고 있다. 도달한 이벤트 는 잠재성 텍스트에서 선택되며, 발생하면 모든 것이 자연 언어 형식으로 표현될 수 있게 된다. 즉, NSL이 준수 하는 특정 차별화 주기가 있으며, 여기서 차별화는 적절하고 문맥적으로 표현되며, NSL에 따른 이러한 차별화는 임의의 섭스트레이트에서 표현할 수 있다. NSL은 TTF 및 TRF를 통해 각 섭스트레이트에 내장된 솔루션 논리를 추출하여 원래 섭스트레이트에서 처리하는 것과 동일한 방식으로 처리할 수 있다. 이 A2A는 입력이 동일하고 출 력이 다양한 프로그래밍 또는 자연 언어로 구축된 모든 솔루션에서 동일하다는 원리로 테스트되었다. 요컨대, NSL 구조는 허브(HUB) 역할을 하며 다른 프로그래밍 언어는 스포크(spokes)와 같다. 예를 들어, 프로그래밍 언 어를 다른 프로그래밍 언어로 전환해야 하는 경우, 프로그래밍 언어는 NSL이라는 허브를 접촉한 다음, 다른 프 로그래밍 언어로 분기(branch)해야 한다. 이해 관계자 참여 센터(SEC): 이것은 사용자 인터페이스와 동의어이다. SEC는 임의의 에이전트와 관련하여 잠재 성을 보유하고 구조화된 방식으로 사용자 인터페이스 레벨에서 동일하게 제시하는 모든 개체를 인식하는 능력을 갖는다. NSL은 모든 변경 유닛이 한 에이전트 또는 명확하게 소유권을 설정하는 다른 에이전트에 의해 구동된다 는 사실을 기반으로 관련 개체를 인식한다. 모든 개체가 명확하게 지정된 결정 및 정보 권한을 갖는다는 추가 사실은 에이전트 간 개체 배포 및 탐색을 쉽게 만든다. SEC는 문맥적으로 구동되는 이해관계자에게 고도로 맞춤 화된 인터페이스를 제공한다. 각 이해 관계자에게 분산되고 안전한 환경을 제공한다. 개인화된 방식으로 사용자 에게 맞게 조정된다. 미션 제어 센터(MCC): MCC는 책임을 수행하거나 필요를 충족하는 인간 에이전트의 정규 과정에서 중요한 개체를 함께 한데 모은다. 이러한 중요한 개체는 정보 권한 또는 결정 권한이 있는 에이전트와 관련된 개체 중에서 함 께 모은다. 분산 MCC는 특정 에이전트 또는 에이전트들과 관련된 개체를 먼저 자동으로 인식하고, 다음에 에이 전트의 기능에 중요한 개체를 선택하는, 시스템의 기능에 관한 것이다. MCC는 SEC(Stakeholder Engagement Center)의 문맥성(contextuality)을 또 다른 레벨로 끌어 올린다. 그것은 '시간' 또는 '이벤트'에 그 자체를 문맥적으로 맞게 조정된다. 관련 SSA 주기를 더 잘 구동하는 모든 관련 'BET'를 전면에 내세운다. 무엇보다도 정 보 제공 또는 실행 가능한 조치도 문맥적으로 사용할 수 있다. 솔루션의 정량화: 정보가 정보 이론에서 '비트'로 정량화되는 것처럼, NSL은 개체 관계들 간의 거리 식별을 통 해 솔루션을 정량화한다. (a) 이진 이벤트: 개체 관계들 간의 거리는 한 CES로부터 다른 CES로 가져 오는 데 걸리는 최소 수의 이진 이벤 트로 측정될 수 있다. 예를 들어, 개체 1이 'A'이고 개체 2가 'AB'이고 개체 3이 'ABC'인 경우, 개체 '1'로부터 개체 '3'으로 얻기 위해 발생해야 하는 최소 이진 이벤트의 수는 '2'이다. 원리는, 무시 또는 인식된 경우, 그 들이 합병하든가, 2개의 개체가 동일해지는 차별화이다. NSL은 구조와 프로세스의 차이를 제거하고, 중요한 것 은 차별화의 방향성일 뿐이다. (b) 공간: 각 CES는 명시적이거나 암시적이며 공간에서 작동하기 때문에, 얼마나 많은 거리를 커버했는지 수집 할 수 있다. (c) 시간: 각 CES와 연관된 명시되거나 명시되지 않은 시간이 있기 때문에, 시간을 잠재적으로 평가할 수 있으 므로 거리를 시간으로 측정할 수 있다. 기본 변경 유닛: 기본 변경 유닛은 개체와 결과 트리거 상태 간의 모든 트랜잭션 상호 작용이 발생하는 기본 유 닛이다. 기본 변경 유닛은 존재하는 유리한 지점에 관계없이 동일한 방식으로 존재하고 작동한다. 더 높은 유리 한 지점에서 정보 계층은 더 많은 정보를 전달하는 경향이 있다. 순차(Sequential) 변경 유닛: 이는, 기본 CU가 트리거될 때 하나 이상의 이벤트를 통해 영향을 미칠 수 있는 CU 이다. 순차 CU는 'AND' 연산자 원리를 활용한다. CES 상태는 기본 CU 및 순차적 CU 내에서 유지되어 E-CES를 형 성한다. 예를 들어, 차를 준비하려면, 티백을 컵에 넣고 주전자에 물을 채우고 주전자에 물을 끓인 다음, 5 컵 에 끓인 물을 붓고 컵에 설탕을 넣어야 한다. 이것은 차를 준비하는 순차적 단계이다. 동적 자연 언어: 솔루션은 작용 중인 규범적 정보이다. 일반적으로 NSL은 모든 주어, 목적어 및 원하는 변환(동 사 또는 동작 단어)의 형태로 자연 언어보다 훨씬 더 많은 문맥 정보를 포함한다. NSL은 명사(개체)와 부사(속 성)에 형용사(속성)를 붙여 유닛(목적이나 목표를 달성하기 위한 의도 또는 단계의 진술)를 변경함으로써 모든 개체의 고유성을 식별하기 위해 차별화의 기본 원리를 사용한다. 따라서 NSL은 자연 언어+와 동일하다. 모든 것은 이진 개체(Binary Entity, BET)이다: NSL에서, 구별되고 불연속적인 모든 것은 개체라고 불린다. 이 러한 개체는 고유하거나(차별화된 별개의 개체) 또는 동일(차별화된 별개의 개체)하다. 고유한 개체는 단어로 표시되고 동일한 개체는 숫자로 표시된다. 용어 BET라는 용어는 잠재성 또는 현실 상태에 있는 모든 개별 개체 를 의미한다. 일반적으로 정보의 문맥에서 'BIT'(Binary Digit)라는 단어가 존재하므로, 'BET'는 솔루션의 문맥 에서 존재하는 'BIT'의 하위 집합이다. 각 BET는 전달하고 동결된 많은 BIT 정보로 인해 차별화된 상태에 있다. 이벤트는 BIT 레벨에만 도착한다. 모든 비트가 동결되기 때문에, 느슨하게 결합할 수 있는 능력을 상실한다. 예: 펜은 많은 원자로 구성되어 있다. 펜이 동결되면, 원자를 빼서 '그 원자를 제외한 펜'이라고 부를 수 없다. 모든 유리한 지점에서의 BET: 솔루션은 구성 요소로 분해될 수 있다. 그것이 분해됨에 따라, 장(Chapter) 레벨, 단락 레벨, 확장 조합 개체 상태 레벨, 변경 유닛 레벨, 개체 레벨 및 속성 레벨에서 다양한 유리한 지점을 통 과할 수 있다. NSL의 관점에서 기억해야 할 한 가지 중요한 것은 BET와 구별되는 모든 것을 보는 것이다. BET 상태는 속성, 일반 개체, 에이전트 및 이들의 조합, 변경 유닛, 변경 유닛 수집, 솔루션 생태계 및 모든 상위 레벨의 BET 수집에 부여된다. 모든 유리한 지점에서, NSL은 각 BET를 이진 변수로 취급한다. 솔루션 생태계는 이벤트가 길을 찾고 멤버에게 자신을 태그할 수 있도록 잠재성과 멤버십이 배치되는 방식으로 설정된다. BET는 서로 다른 섭스트레이트에 존재하며 모든 섭스트레이트에서 BET의 모든 표현은 고유한 ID를 갖는다. 예: (a)개 체를 나타내는 이미지 또는 비디오는 자체 ID를 갖는다. 각 표현은 BET의 형태로 자체 BIT 양자를 소비할 수 있 다. (b) 끝에서 끝(end to end) 통신 요금 청구 솔루션은 BET이다. 고객 프로파일링, 주소 확인, 청구서 생성 등과 같이 이 통신 솔루션을 구성하는 변경 유닛도 BET이며, 이는 모든 개체에 부착된 마지막 속성까지 계속된 다. BIT 및 BET: 'BET'(이진 개체)는 솔루션에 대한 것이고, BIT(이진 숫자)는 정보에 대한 것이다. 확장하여 BET는 '솔루션 이론'이고, BIT는 정보 이론이다. 일반적으로 정보는 'BIT'의 수로 측정된다. 본질적으로 의미하는 바 는 모든 비트가 '0' 또는 '1'인 이진 상태에 있다는 것이다. 정보는 모든 비트의 위치가 결정되거나 어떤 의미 에서 차별화될 때만 발생한다. 정보의 크기를 계산하기 위해서, 모든 비트의 상태를 무시하고 정보에 포함된 비 트 수만 계산한다. 마찬가지로, 솔루션 생태계에서, 각 BET의 상태를 무시하여 'BET'의 수를 셀 수 있다. 'BIT'와 'BET'는 문맥성에 의해서만 차별화되는 상관관계가 높은 개념이다. 하나는 일반적으로 정보에 관한 것이고, 다른 하나는 일반적으로 솔루션에 관한 것이다. 'BET'는 어떠한 차별화도 없는 '원초의 개체 (Primordial Entity)'와 같다. 'BET'는 도 1에 표시되어 있다. 모든 개체가 해당 상태에 도달하면, 모든 개체가 동일해지고 셀 수 있게 된다. 예를 들어, 1 GB 비디오는 BITS의 상태를 무시한다. 중요한 것은 비디오를 구성하 는 비트 수이다. 마찬가지로, NSL에서, 솔루션의 정량화는 솔루션을 구성하는 BETS의 수를 세어 수행된다. 변경 유닛(CU) 클록: NSL에서 사물의 본질에 의해, 모든 사물은 CU의 잠재성 또는 현실에 존재하며, 보다 구체 적으로는 CU 구성 요소에 존재한다. CU에 대한 차별화는, 트랜잭션 레벨에 도달할 때까지, 클래스 레벨로부터 여러 레벨의 하위 클래스로 진행된다. 많은 경우, 솔루션 생태계에서 어떤 개체의 탄생과 죽음(삭제), 더 나아 가 개체의 존재 기간과 나이를 추적하는 것이 중요할 것이다. 모든 개체는 시간과 공존한다. 즉, 시간은 항상 모든 CU의 CES의 일부이다. 시간은 물리적 계층의 변경 드라이버(CD) 또는 정보 계층의 정보 드라이버(ID)로 CU 에 있을 수 있지만, 대부분 암시적 개체로 취급된다. “공기”가 인간에게 암시된 개체라면, “시간”은 변경 유닛에게 암시된 개체이다. 별도로 언급할 필요는 없다. 모든 상황과 시나리오를 수용하는 근본적인 솔루션 지 원 레벨인 '구문(syntactic) 레벨'에서, 모든 개체의 시간적 공존이 제공되어야 한다. '의미론적(semantic) 레 벨'에서, 그 속성을 사용하거나 사용하지 않는 것은 솔루션 설계자의 몫이며 '시간'을 암시된 개체로 받아들인 다. 시간을 추적하는 것의 유용성은 분석으로부터 추론 도출에 이르기까지 다양한 범위로 확장될 수 있다. 예: 펜과 3개의 다른 변수가 있는 CU를 상상해 본다. CU에는 4개의 변수가 있기 때문에, 잠재적으로 16 개의 서로 다른 CES(2^4 상태)를 가질 수 있다. 펜이 가장 먼저 도착한다면, CES 넘버 1은 잠재성으로부터 현실로 바뀔 수 있다. 시스템은 그 잠재성이 '현실 CES 1'로 대체되었기 때문에 그 잠재성의 시간과 그 잠재성이 죽은(삭제 또 는 제거) 시간을 추적한다. 또 다른 개체가 도착하면, 그 CES는 잠재성이 되고 또 다른 CES, 말하자면 CES 넘버 5는 현실이 된다. 또한 시스템은, NSL이 느슨하게 결합된 단일 개체 상태를 제공하므로, 개별 개체(CES뿐만 아 니라)도 추적할 수 있다. '트리거 CES'에 도달하면, 현실 상태와 트리거 CES에서 발생하는 확장된 CES와의 사이 의 지연 시간을 추적할 수도 있다. 트리거와 원인을 트리거하는 하나 이상의 이벤트 사이에는 항상 지연 시간이 있다. 이 정보를 갖는 것은 다양한 문맥성에서 솔루션 사용자에게 큰 가치가 있다. 시간 도함수(derivatives): BET의 출생 또는 사망 시간을 기반으로 모든 유리한 지점의 BET 존재 기간을 도출할 수 있다. 트리거가 생성하는 각 이벤트와 관련하여 트리거 시작 및 트리거 상태 종료(end)를 캡처하고 경과 시 간을 도출할 수 있다. CU의 경우, 유휴 상태에 있는 시간의 비율과 트리거 상태에 있는 시간의 비율도 계산할 수 있다. 개체가 유휴 상태(트리거 상태에 참여하지 않음)인 시간과 활성인 시간의 비율을 확립할 수 있다. 다 양한 유리한 지점에서 '이벤트와 기간' 사이에 확립된 상관관계는 분석과 행동을 위한 막대한 기회를 제공한다. 시간과 공간 좌표의 조합은 이러한 분석 및 조치 기회를 또 다른 레벨로 끌어올린다.. 변경 유닛(CU) 공간 좌표: '시간'과 '공간' 모두 편재하다. 모든 개체는 그들이 속한 섭스트레이트에 관계없이 공간에 존재한다. 노골적으로 선택하든 그렇지 않든, '공간'은 항상 어떤 존재와 관련하여 암시적으로 존재한다. 구문 레벨의 시스템이 모든 개체에 대한 시간 관련 속성 값의 태그 지정을 제공하는 것처럼, 시스템 은 임의의 개체의 공간 좌표에 대한 태그 지정도 제공한다. 이들은 2차원일 수도 있고 3차원일 수도 있다. 모든 개체는 물리적인 동시에 정보를 제공하기 때문에, 개체의 존재와 상호 작용은 공간 좌표에 구속된다. 개체가 트 리거되면, 트리거가 생성하는 변경된 상태도 거리로 표현할 수 있다. 예: 존(John)이 트리거 상태 발생 시 장소 A로부터 B로 이동할 때, 이동한 미터 수로 거리를 측정할 수 있다. 이는 경과 시간을 측정하는 것과 같다. 공간 과 시간의 속성 값은 인간 에이전트 기능과 마찬가지로, 기계 에이전트 기능에도 동일하게 적용할 수 있다. 또 한, NSL에서 모든 개체는 이진 상태(BET)로 존재한다. 각 상태 변경은 이벤트이다. 모든 이벤트는 시간과 공간 에서 발생한다. 따라서 모든 개체에는 각각 공간 좌표와 함께 '존재하는' 및 '존재하지 않게 되는'을 나타내는 시간과 공간의 속성 값(타임 스탬프)가 첨부되어 있다. 이것은 출생지와 사망지와 함께 사람의 출생 시간과 사 망 시간과 동일하다. 이것은 잠재성 상태뿐만 아니라 현실 상태에도 적용된다. 잠재성의 종료는 현실의 시작이 며 그 반대도 마찬가지이다. 이 규칙은 모든 유리한 지점에 적용된다. 공간적 거리: 솔루션을 제공하는 과정에서 커버된 거리는 각각의 CU에 의해 커버된 거리를 누적함으로써 도출될 수 있다. 이러한 거리는 횡단한 실제 거리를 기반으로 계산하거나 까마귀가 날 때 이론적으로 계산할 수 있다. 이러한 측정은 특정 솔루션을 참조하여 연결된 CU 또는 관련 CU 중 임의의 CU에서 임의의 CU에 대한 것일 수 있 다. 기능적 거리: NSL은 연관된 방향성을 갖는 선으로 연결된 3 차원으로 넓은 노드의 네트워크 후에 모델화된다. NSL은 임의의 유형의 데이터베이스를 정규화하는 기능이 있어 '다국어 지속성(polyglot persistence)'을 가능하 게 한다. 모든 개체는 잠재성이든 현실이든 관계없이 노드 내부에 있다. 이들 각각의 개체는 각각의 섭스트레이트에 있는 'ID, 언어/숫자, 이미지 등'의 형태로 많은 아바타를 취할 수 있다. 한 섭스트레이트에서 다른 섭스 트레이트로의 교차는 동등성의 원리와 진리 값이 보존되는 한 허용된다. 평등은 클래스들 간에, 클래스에서 멤 버로(연역(deductive) 과정), 멤버에서 클래스(귀납 과정)로 적용된다. 모든 노드는 가장 가까운 이웃 원리에 따라 서로 연결된다. 동일한 트랜잭션의 노드를 연결된 노드라고 한다. 동일한 솔루션 생태계의 모든 노드를 관 련 노드라고 한다. NSL은 노드 네트워크에 의해 관리되기 때문에, 솔루션 생태계의 모든 것은 본질적으로 상대 적이다. 과학의 '우주론적 원리'와 마찬가지로, 선택된 임의의 노드 또는 유리한 지점이 중심 기준점이 된다. 즉, 절대적인 기준점은 없으며 모든 것은 상대적이다. 노드에 연결된 선에는 방향성이 있기 때문에, 일반적으로 정보 흐름이나 차별화에 방향성이 있다. 노드 네트워크는 모든 자유도를 제공한다. 계층적(hierarchical) 모델 은 정보 및 의사 결정 흐름과 관련하여 만들어진 특정 선택에서 발생하지만 근본적인 것은 아니다. 이 배경에서, 임의의 두 노드를 선택하고 기능적 거리를 측정할 수 있다. 다른 노드에 도달하기 위해 횡단해야 하 는 경우, 노드 수를 계산해야 한다. 이것은 무엇보다도 두 노드 사이의 관계의 근접성을 판단하는 데 도움이 된 다. 기능적 거리의 예는 도 19에 나타나 있다. 노드의 로컬 네트워크로서의 CU: 지구상에는 수많은 종과 유기체가 있다. 그러나 그 모든 종은 예외 없이 모두 '세포'로 이루어져 있다. 모든 유기체의 기본 구성요소(building block)는 '세포'이다. 마찬가지로 임의의 솔루 션의 기본 유닛은 '변경 유닛'(CU)이다. 모든 변경 유닛은 '노드의 로컬 네트워크'로 구성된다. 노드는 개체의 존재 식별을 나타낸다. 노드의 연결은 노드들 간의 차별화 방향을 나타내는 화살표(또는 동등물)가 있는 '변환 라인'(TL)을 통해 표현된다. 노드는 노드에 매달린 고유하거나 동일한 개체로 차별화된다. CU는 그들에 부착된 '의도 진술'로 차별화되는 '주 노드(principal node)'로 시작한다. 노드 33은 노드의 로컬 네트워크로서 CU를 나타낸다. CU는 초기 레벨에서 주 노드를 차별화하는 '독립 개체'와 관련된 노드를 가진다. 초기 레벨에서 노드 수에 대한 이론적인 제한은 없다. 여러 레벨의 속성이 있을 수 있으며, 임의의 수의 레벨에는 여러 속성이 있을 수 있다. 즉, 4 계층화(4 FOUR LAYERED) CU로 알려진 4 개 레벨의 노드가 있다. 이 개체의 로컬 네트워크의 특 성은 트리거 조건이 충족될 때 노드의 하나 이상의 로컬 네트워크에서 이벤트를 발생시키는 속성이 있다는 것이다. 이 특성은 변경 드라이버의 드라이버(driver of change driver, DCD)라고 한다. NSL에서는 '변경 드라이버'라고도 한다. 실제로 로컬 네트워크의 트리거된 상태는 자신을 포함하여 노드의 임의의 로컬 노드 네 트워크(즉, 정보 계층)의 임의의 계층에서 변경을 구동할 수 있다. 4 계층화 CU: 400년의 과학에 의해 확립된 바와 같이, 세계가 원리를 작동하는 방식으로부터 모든 사람이 배워 왔다. 에이전트가 존재하는 경우 전면에 나오는 몇 가지 원리가 있다. i. 에이전트는 생존을 위한 솔루션을 끊임없이 모색하고 있다. ii. 모든 솔루션은 제어되고 지시된 변경으로부터 발생한다. iii. 즉, 에이전트는 SSA 주기에 의해 제어되는 목적에 따라 구동된다. iv. 에이전트는, 본질적으로 인간의 경우 진화 과정을 통해, 그리고 기계 에이전트의 경우 인간 에이전트에 의 해 복잡성과 무한대를 극복하도록 설계된다. v. 즉, 에이전트 시스템은 필요에 따라 불연속/구별된 상태에 의해 구동된다. vi. 넓게 말해서, 이산 상태는 객체, 객체의 속성 및 임의의 종류의 변경과 관련된다. vii. 임의의 변경은 변경 유닛(CU)이 경험하는 원인과 결과의 원리에 의해 구동되고, SSA 주기는 변경 유닛에 고유한 것이다. viii. 임의의 고유한 불연속/구별 상태는 자연 언어로 나타낼 수 있다. ix. 동일한 임의의 불연속/구별 상태는 숫자로 나타낼 수 있다. NSL에서 CU는 노드의 로컬 네트워크이다. 주 노드는 'LSI' 또는 CU 이름 형태로 해당 로컬 네트워크를 나타낸다. 노드의 로컬 네트워크에는 물리적 및 정보적인 두 가지 유형의 계층이 있다. 그러나 노드의 각 로컬 네트워크에 암시적이거나 고유한 것은 2 이상의 계층이다. 그 중 하나는 '질문 계층'이다. 이것은 지식이 풍부 한 CU(들)에 앉아 있는 에이전트(들)로부터 질문을 하고 답을 구하는 무지한 에이전트(들)를 나타낸다. CU 내에 서 기능을 수행하려면 CU의 에이전트가 지식이 있어야 한다. 의문(질문)을 제기하는 에이전트의 정보 및 결정 권한에 따라, 지식이 풍부한 에이전트는 답변을 제공하거나 제공하지 않을 의무가 있다. 다른 암시적 계층은 ' 측정 계층'(자연 언어에서 감탄문이라고 함)이다. 측정에는 다음과 같은 특성이 있다:(i) 그들은 물리적 또는 정보 계층의 강조 표시된 부분이다. (ii) 일반적으로 강조 표시된 부분은 사물에 더 큰 초점을 맞추기 위해 속성 값으로 더욱 차별화된다. 예: 강조 표시된 부분이 '고객에게 제품 배송'인 경우, 차별화 속성은 30분 미만 또는 초과 배송일 수 있다. (iii) 측정의 제3 속성은 주어진 차별화 속성을 가진 강조 표시 부분의 상태에 대해 에이전트가 취하는 뷰 (view)이다. 이를 일반적으로 규범이라고 한다. 예: 배송 시간이 30분 미만이면 양호하고, 그 이상이면 불량으"}
{"patent_id": "10-2023-7006405", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "로 간주된다. 이 예는 도 29에 나타나 있다. 요약하면, NSL은 CU를 4 계층화로 간주하고, 도 30에 동일하게 표 시된다. CU의 4개 계층은 다음과 같다: 1. 질문 계층: 이 계층은 잠재되어 있으며, '무지한 에이전트'가 질문을 제기할 때 호출된다. 무지한 에이전트 는 각 CU에 앉아 정보 권한 및 결정 권한(IRDR)을 소유한, 권한 부여된 에이전트로부터 답변을 제공받는다. 2. 물리적 계층: 자연 언어의 명령문 또는 규범적 진술과 동일하다. 3. 정보 계층: 자연 언어의 서술적 진술 또는 선언적 진술과 동일하다. 4. 측정 계층: 자연 언어의 감탄문과 동일하다. 서술적 진술(descriptive statement)을 규범적 진술로 변환하는 데 도움이 되는 의문문. '하늘이 파랗다'와 같 은 서술적 진술이 있을 수 있다. 이것은 '하늘이 파랗습니까?'라는 질문이나 의문을 제기함으로써 규범적 진술 로 전환될 수 있다. 이 규범적 진술의 자격을 갖춘 멤버는 파란색이거나 파란색이 아닌 이진 상태('예' 또는 ' 아니오')에 있다. 도 34는 이진법 상태에서 서술적 진술을 규범적 진술로 변환하는 데 도움이 되는 의문문을 나 타낸다. 옵션이 많을 때, '규범적 진술'로 생성된 의문문은 객관식 질문의 형태를 취한다. 예: '하늘은 무슨 색 인입니까?', 제공되는 옵션은 A, B, C, D, E이며 '파란색'은 그 중 하나이다. 파란색만이 그 멤버가 될 자격이 있다. 도 35는 서술적 진술을 복수 옵션이 있는 규범적 진술로 변환하는 데 도움이 되는 의문문을 나타낸다. 개체의 아바타: 모든 개체는 물리적이며 한 형태 또는 다른 형태로 표현되어야 한다. 모든 개체에는 ID, 이름 및 대부분의 경우 이미지가 있다. 예를 들어, 사람은 이름, 식별 번호 또는 사진을 가질 수 있으며, 이는 물리 적인 사람을 세 가지 형태 모두의 표현과 동일시한다. 각 표현은 섭스트레이트 전체에서 동등성을 유지하기 위 해 특정 양의 비트를 취한다. 종이에 섭스트레이트된 이름, 또는 사람을 묘사하는 영상에 인물을 나타내는 이미 지는 각각 다른 양의 바이트 정보를 갖게 된다. 여러 섭스트레이트에서 동일한 개체의 이러한 다양한 표현을 개 체의 아바타라고 한다. 밀접하게 결합된 개체: 에이전트 및 일반 개체는 의도된 변경을 생성하기 위해 문맥적으로 함께 모인다. 종종 개체의 조합이 함께 도착하거나 출발할 수 있다. 밀접하게 결합된 개체는 함께 작동하는 개체이다. 밀접하게 결 합된 개체의 예: 트럭과 운전자가 함께 도착하고 출발한다. 밀접하게 결합된 개체는 독립적으로 작동할 수 없다. 밀접하게 결합된 개체가 참여하는 어떠한 변경에서도, 그들은 함께 참여해야 한다. 그들 중 하나가 행동 에서 빠진 어떠한 경우도 있을 수 없다. 변경에 함께 참여하는 여러 개체의 예를 밀접하게 결합된 개체라고 한 다. 예를 들어, 수술을 하는 동안, 의사는 지정된 의복, 장갑, 마스크 등을 착용하고 들어온다. 밀접하게 결합 된 개체의 예는 도 2에 나타나 있다. 느슨하게 결합된 개체: 느슨하게 결합된 개체는 변경에 참여하기 위해 별도로 도착하는 단일 개체이다. 느슨하 게 결합된 개체의 예: 펜과 종이가 교환 유닛에 별도로 도착할 수 있다. 그들은 느슨하게 결합된 개체이다. 그 들은 독립적으로 도착할 수 있다. 느슨하게 결합된 개체의 예는 도 3에 나타나 있다. 대체(substitute) 개체: 개체의 대체는 (a) 독립 개체 레벨, (b) 속성 레벨, 및 (c) CU 레벨에서 발생할 수 있 다. '대체'라는 단어는 후속 상태가 동일한 일련의 이벤트를 생성하는 경우에만 사용된다. 변형 경로가 다르면, 대체 개체라고 불릴 수 없다. 대체가 발생하면 가장 가까운 이웃이 그 차이를 알아차리지 못한다. 트리거 상태 의 효과는 동일하게 유지되어야 한다. 예를 들어, 연필은 글을 쓸 때 펜 대신 사용할 수 있다. 시스템은 수신자 가 원래 개체인지 대체 개체인지 여부에 관계없이 어떤 개체가 변경에 참여했는지조차 알지 못하도록 동적으로 작동한다. 복제된(cloned) 개체: 솔루션의 일부로서 때때로 서로를 차별화하지 않고 소프트 자산의 복사본을 만들 필요가 있다. 이러한 동일하고 차별화되지 않은 소프트 자산을 복제된 개체라고 한다. 예: 조직 정책은 이메일을 통해 모든 직원에게 전달되어야 하며, 이메일의 각 사본은 동일하고 차별화되지 않는다. NSL 시스템은 솔루션 설계의 일부로서 개체 복사를 제공한다. 복제된 개체 중에서 어느 것이 원본 개체이고 어느 것이 복제된 개체인지를 구분할 수 없다. 네거티브 개체: 일반적으로 중요한 변경 드라이버(CD)가 트리거 CES의 일부인 경우이다. 그러나 드문 경우에, 중요한 것은 개체의 존재가 아니라 개체의 부재일 수 있다. 예: 배송이 이루어지기 위해서는, 개체로서의 '비' 가 존재하지 않는 것이 중요할 수 있다. 이 예는 도 20에 나타나 있다. NSL은 속성 레벨에서 이를 처리하는 대 체 방법을 제공하는 n-잠재성 및 n-현실을 제공한다. 매립(embedded) 변경 유닛: 매립 변경 유닛(Embedded Change Unit, eCU)은 CU 내의 CU이다. eCU는 소위 수직 차별화의 일부이다. 이들은 상위 레벨 CU, 위의 기본 CU 또는 바로 위의 eCU의 트리거에서만 트리거된다. 여러 레벨의 eCU가 있는 경우, 속성 레벨이 정의되는 방식과 유사하게 일차, 이차, 삼차 등으로 지칭된다. 모든 eCU 레벨에는 연결된 eCU가 얼마든지 있을 수 있다. eCU에는 두 가지 종류, 즉 하위 CU와 반복적(recursive) CU가 있다. 반복적 CU든 하위 CU든, 기능의 본질은 같다. 매립 CU는 연결된 더 작은 CU를 통해 상위 레벨 CU의 기능 을 여러 단계로 나눈다. 예: 더 높은 레벨의 CU는 도시의 한쪽 끝에서 다른 쪽 끝으로 이동하는 작업을 처리할 수 있다. 매립 CU는 도시를 나갈 때까지 연결된 10 개의 도로를 건너도록 기능을 분해할 수 있다. 도시 진입은 CU 1의 매립 CU를 트리거하고, 마지막 거리로부터의 진출은 상위 레벨 CU를 트리거하여 '도시로부터의 진출' 이 벤트를 상위 레벨 CU2에 배치한다. 즉, 매립 CU의 GSI는 상위 레벨 CU를 트리거하여 다음 CU에서 이벤트를 생성 하도록 한다. 매립 CU의 계층이 얼마든지 있을 수 있다는 것은 우연이다. 하위 레벨 CU의 GSI는 도 39에 도시된 상위 레벨 CU를 트리거한다. 하위 CU: CU가 많은 하위의 더 작은 CU로 분할될 때, 이들 각각은 하위 CU가 된다. 예를 들어, 10분이 걸리는 활동(기본 CU)은 태스크라고 하는 1~2분(minute-or-two) 세그먼트로 구성된 더 작은 변경 유닛으로 나눌 수 있 다. 하위 CU가 없는 경우 기본 CU(CU1)는 출력을 순차적 CU(CU2)에 배치할 수 있다. 그러나 솔루션 설계자가 연 결된 더 작은 CU(하위 CU)에 규정된 단계를 통해 활동이 체계적으로 구동되어야 한다고 의도한 경우, 설계자는 그러한 선택을 갖게 된다. 하나 이상의 연결된 하위 CU를 도입할 수 있다. 기본 CU(CU1)가 트리거되면 일차 매 립 CU 레벨에 있는 하위 CU-집합에 의존한다. 매립 CU 집합에는 자체 매립 GSI가 있다. 해당 GSI를 트리거할 때, 매립 CU가 존재하지 않은 경우 발생하는 것과 마찬가지로, 이제 기본 CU2에서 이벤트가 발생한다. 이 프로 세스는 존재하는 매립 CU의 더 많은 레벨(2차, 3차 등)과 관련하여 어떠한 깊이에서도 발생할 수 있다. 이차 CU 는 GSI를 통해 기본 레벨(각 작업)의 각각의 개별 CU에 서비스를 제공한다. 즉, 일차 레벨의 하위 CU1(작업 1) 은 이차 레벨 GSI에서 서비스를 제공하고, 일차 레벨의 하위 CU2(작업 2)에서 이벤트를 발생시킨다. 이 프로세 스는 임의의 수의 레벨로 계속될 수 있다. NSL은 각 작업이 이차 레벨의 하위 작업 수에 의해 서비스될 수 있는 능력을 제공한다. 일차 레벨의 여러 작업 중 각각은 고유한 이차 레벨을 개별적으로 가질 수 있으며, 이러한 각 이차 레벨에서 수용할 수 있는 작업 수에는 어떠한 제한도 없다. 이것은 매립 CU를 통해 구축된 차별화 트리가 분기되는 방식이다. 주요 레벨에서, 속성과 관련하여 차별화가 발생하는 방식과 매립 CU로 인해 발생하는 차별 화 방식 사이에는 차이가 없다. 반복적 CU: 반복적 CU와 하위 CU 사이에는 근본적인 차이점이 없다. 둘 다 경우에 따라 기본 CU 또는 반복적 CU 또는 하위 CU의 상위 레벨에 종속된다. 그들 사이의 주요하고 유일한 차이점은 반복적 CU가 반복을 처리하므로, 숫자와 수학적 구성을 처리한다는 것이다. 하위 CU에는 고유한 개체 및 고유한 변환이 포함된다. 예를 들어 활 동에 매립된 각 일련의 작업은 하위 CU 경우에서 고유하다. 설거지는 씻지 않은 접시를 식탁에서 싱크대로 옮기 기, 수도 꼭지 열기, 세정 스펀지 적시기, 스펀지에 비누 바르기, 접시 세척 등의 작업을 포함한다. 반대로 반 복적 CU는 어떤 종류의 공간 및 시간에서의 반복을 포함한다. 하위 CU의 경우, 접시 세척과 관련하여, 기본 CU1 이 트리거되고 모든 작업은 매립 하위 CU 레벨에서 수행된다. 그 결과, 하위 CU 레벨의 GSI는 세척된 접시를 그 것이 야기한 이벤트로서 기본 CU2에 배치하게 된다. 이것은, 솔루션 설계자가 일차 레벨 작업을 통해 시스템에 표준 운영 절차를 부과하지 않기로 선택했다면, 어쨌든 발생했을 것이다(기본 CU1이 깨끗한 접시를 CU2에 배 치). 솔루션이 접시를 10번 세척해야 하는 것을 요구한 경우, 기본 CU2에 넣기 전에 반복적 CU가 중요하다. 수 행되는 작업은 고유하지 않고 반복적이다. 반복적 CU1은 한 번 세척한 접시를 다음 반복적 CU에 배치하고, 두 번째는 두 번 씻은 접시를 세 번째에 배치하는 식으로 계속된다. 열 번째 세척이 발생한 GSI이기도 한 마지막 반복적 CU는 기본 CU2에 10번 세척된 접시를 배치한다. 이러한 각 반복적 CU의 변경 드라이버(CD)는 점진적으로 변경되는 해당 접시의 속성 값이 있는 동일한 에이전트 및 동일한 접시이다. 제1 반복적 CU에서, 접시는, 제2 '세척된 1', 제3 '세척된 2' 등에서 '세척된 0'의 속성을 갖게 된다. 내포된(nested) CU(nCU): 모든 변경 유닛에 고유한 것은 SSA 주기와 같은 프랙탈(fractal)의 재생(playout)이 다. 에이전트의 존재 하에, 감각은 환경에서 사물을 감지하고, 마음은 많은 가능성 중에서 적절한 선택을 하며, 신체는 변경 주기를 완료하는 데 필요한 에너지를 제공한다. 내포된 CU는 트랜잭션 레벨에서 훨씬 더 많은 정보력을 제공하기 위해 기본 CU에 추가된 CU의 추가 계층이다. 이는 기본 CU의 SSA 주기 내의 SSA 주기와 같다. NSL은 SSA 또는 변경 유닛의 계층 수에 제한을 두지 않는다. 원하는 솔루션에 따라, 솔루션 설계자는 기본 변경 유닛 내에서 필요한 만큼 세분화된 SSA를 추가할 수 있는 유연성이 있고, 내포된 CU는 자신이 속한 기본 CU 또 는 상위 레벨 내포 CU를 포함하여 하나 이상의 CU에서 하나 이상의 이벤트를 유발할 수 있다. 예를 들어 내포된 CU는 '기본 CU 의도의 현실'을 잠재성으로 변환하여 특정 상황에서 비 활성화할 수 있다. 내포된 CU가 발생하는 이벤트는 항상 연결된 기본 CU의 문맥성에 있는 반면, 그들의 트리거는 기본 CU 또는 상위 레벨 내포 CU의 트리 거와 독립적일 수 있다. 내포된 CU의 CD는 독립된 개체 또는 기본 또는 상위 레벨 CU 개체의 속성(예를 들어, 개체 또는 CES의 현실 상태 확률)일 수 있다. 내포된 CU는 '조건부 잠재성'을 자신을 포함한 하나 이상의 CU의 잠재성으로 변환할 수도 있다. 예를 들어, 비는 기본 CU에 있는 비옷의 조건부 잠재성을 한 잠재성으로 변환할 수 있으므로, 기본 CU의 트리거를 비옷의 입수 가능성에 조건부로 할 수 있다. 내포된 CU는 완곡하게 내포된 마 음이라고 한다. 내포된 CU는 더 거친 CU를 더 세분화된 연결 CU로 나눈다. 반대로 내포된 CU는 상위 레벨 CU에 존재하는 문맥성에 더 큰 문맥성을 적용한다. 예: 더 높은 레벨의 CU 문맥성은 인간 에이전트, 차량 및 제품과 같은 CD가 있는 경우, 제품을 제공하는 것일 수 있다. 상위 레벨 CU의 묵시적 조건은 날씨가 정상이라는 것이다. '비'의 문맥성을 그림으로 가져오는 내포 CU가 생성될 수 있다. 더 높은 레벨의 CU는 비가 내리지 않을 때까지 내포된 CU가 존재하지 않는 것처럼 계속 작동한다. 비가 내리고 있다는 조건에서, 상위 레벨의 거동이 바뀔 수 있다. 상위 레벨 CU의 트리거를 중지하고 트랜잭션을 포기하는 결과를 가져올 수 있거나, 또는 우산과 같은 추가 CD를 도입하는 조건부 잠재성을 생성할 수 있다. 이 예는 도 40에 나타나 있다. CD 도착 확률이 낮으 면, 해당 문맥성이 상위 레벨 CU의 거동에 영향을 미칠 수 있다. 예: 의사가 도착할 확률이 매우 낮은 경우, 환 자에게 나중에 오도록 요청할 수 있다. 하나 이상의 연결된 내포 CU가 있을 수 있다. 또한, 임의의 수의 레벨의 내포된 CU, 문맥성 내의 문맥성이 있을 수 있다. 내포된 SSA 및 잔여 정보: 내포된 SSA는 의미 있는 정보를 사용하고 이에 따라 행동한다. 경우에 따라, 시간이 지남에 따라 많은 정보가 축적되어 SSA 주기의 형태로 값을 찾지 못할 수 있다. 이를 잔여 정보라고 한다. 내포 된 마음은 내포된 SSA의 임의의 수의 계층으로 볼 수 있다. 정보에 조치를 취할 수 없는 경우, 내포된 CU의 마 지막 계층에 있는 정보 계층에 위치한다. 내포된 SSA에서 나오는 임의의 액션을 솔루션 클래스에 CU로 추가할 수 있다. CU를 추가하면 더 많은 정보가 추가되거나 트랜잭션 형태로 더 많은 정보가 생성된다. 잔여 정보는 내 포된 모든 SSA 주기 레벨에 남을 수 있다. 일반 확률: 확률은 이벤트 발생 가능성의 정량화이다. NSL은 개체가 이벤트에 따라 구동되는 바와 같이, 잠재성 과 현실 사이를 전환할 수 있는 개체 기반 모델이다. NSL은 모든 유리한 지점에서 BET에 통계적 방법을 적용할 수 있는 능력을 제공한다. 확률은 가능한 결과에 대한 유리한 결과의 비율로 규정된다. 그것은 과거 이벤트의 관찰을 기반으로 한다. 예: 제품 배송이 1시간 이내에 이루어지면 유리한 것으로 간주될 수 있다. 다른 것은 해 당 제품의 1,000회 경우에 걸쳐 동일하게 유지되고, 규정된 시간 내에 800회 발생할 수 있다. 그러면, 그 다음 제품이 배송될 확률은 80%가 된다. NSL에서 모든 트랜잭션 클래스는 위의 '솔루션 클래스' 내에 있다. 확률을 모두 계산하기 위해서, 주어진 솔루션 클래스에 대한 트랜잭션 정보를 수집해야 한다. 이러한 계산은, 확률이 최근 트랜잭션마다 크게 달라지지 않는다면, 대부분의 경우 NSL의 배치 모드에서 수행될 수 있다. 확률 적용의 사용 사례는 간단하고 많다. 예: 의사가 다음 시간에 도착할 확률은 얼마인가? 확률이 80%이면 환자가 기다리는 것이 좋다. 확률의 적용은 고급 계획 및 최적화(Advanced Planning and Optimization, APO), 분석, 로봇 프로 세스 자동화(RPA), 조건부 잠재성의 도입, 기계 학습 등에까지 확장된다. 차별화된 확률: 확률 계산에 있어서 다양한 변형에 대한 사례가 만들어질 수 있다. 확률은 차별화 트리의 다양 한 유리한 지점에 할당될 수 있다. 예: 범죄자가 특정 국가, 주, 도시 또는 지역에 있을 확률은 얼마인가? GSI 내의 특정 LSI에서 제1 이벤트가 발생할 가능성은 얼마나 되나? 이 대체 CU가 다른 대체 CU에 비해 먼저 트리거 할 가능성은 얼마나 되나? 베이지안(Bayesian) 논리: 베이지안 논리는 특히 기계 학습과 관련하여 중요성이 높아지고 있다. 이는 이벤트와 관련될 수 있는 조건에 대한 사전 지식을 기반으로 한 이벤트의 확률에 관한 것이다. 이는 '조건부 확률'과도 밀접한 관련이 있다. 예: A와 B가 이미 존재하는 상황에서, 'C'가 도착할 확률은 얼마인가? A, B, C가 이미 존 재하는 상황에서, 'D'가 도착할 확률은 얼마인가? 이 예는 도 21에 나타나 있다. NSL 프레임워크는 '문맥성'을 제공한다. 즉, 기존의 CES 또는 ECES가 개체의 도착 또는 출발에 의해 영향을 받는 것과 동일한 도착 또는 출발 개체가 도착하는 환경의 컨텍스트에 놓이도록 제공한다. NSL에서, '조건성(conditionality)'은 어떤 행동을 할 수 있는 근거가 되는 어떤 상태의 존재에 지나지 않는다. 변경은 최근접 이웃 원리를 기반으로 솔루션 생태계 전체에 전파된다. 이러한 기본 속성이 NSL에 존재한다는 점을 감안할 때, 베이지안 논리 또는 '조건부 확률'은모든 유리한 지점에서 매우 자연스럽게 처리될 수 있다. 조건부 잠재성: 솔루션 생태계의 세계에는 매우 많은 개체가 있다. 세계에 존재하는 모든 것은 가능성이다. 솔 루션 설계자는 잠재성으로 우주에서 이러한 가능성을 선택한다. 잠재성의 세계와 가능성의 세계 사이에서, NSL 은 가능성이 예비로 저장될 수 있고 '조건부 잠재성'이라는 특정 조건을 충족할 때 잠재성으로 변환될 수 있는 중간 상태를 생성하는 기능을 제공한다. 조건부 잠재성은 특정 조건이 충족될 때만 자신을 잠재성으로 변환하는 특별한 종류의 잠재성이다. 이들은 속성 레벨에서 단락이나 책 전체에 이르기까지 존재할 수 있지만, 충족되는 특정 조건에서만 트리거되는 잠재성이다. 그렇지 않으면, 그들은 트리거 속성을 결정하기 위해 무시되는 음영 잠재성과 같다. 예: 비옷은 기본 CU에서 '조건부 확률'로 존재할 수 있다. 그러나 '조건부 잠재성'이 '잠재성' 이 될 때까지, 기본 CU의 트리거 목적으로 고려되지 않을 수 있다. 실체가 현실이 되기 위해서는, 개체가 잠재 성에서 첫 번째가 되는 것이 필수적이다. 전체 솔루션 생태계가 환경의 지시에 따라 거동을 동적으로 변경할 수 있으므로, 이는 NSL에서 매우 강력한 구성이다. 이것이 도입하는 유연성은 속성으로부터 솔루션 생태계의 가장 높은 유리한 지점에 이르기까지 다양하다. 이 권한의 행사는 특정 조건이 충족되고 에이전트의 정보 권한 및 의 사 결정 권한이 적용되는 경우에만 제한된다. 얽힌(entangled) CU: 이 구성은 공식 및 방정식과 같이 자주 접하는 수학적 표현을 다루기 위해 NSL에 도입된다. 얽힌 CU는 조건부로 서로에게 영향을 줄 수 있는 속성과 항상 공존한다. 얽힌 CU의 거동은, 값이 결 정될 때 그들의 카운터파트 값을 결정하는 얽힌 입자와 동의어이다. 즉, 서로에게 불가분의 의존 관계가 있다. a. 공식: 이들은 '수량들 사이의 일반적인 관계 구성'으로 정의된다. 이들은 상위 집합으로 볼 수 있다. 예: 'A'는 'B'보다 크다. 이들은 방정식의 가능성을 포함하지만 다른 일반 공식으로도 확장될 수 있는 표현이다. b. 방정식: 이들은 '두 표현식의 동등성을 주장하는 진술'로 정의된다. 이는 '주어'가 거동을 결정하거나 '객체'를 결정하는 일반 문장과 달리 '주어'가 '객체'의 값과 동일하여 서로의 값을 결정할 수 있는 특수한 속 성을 갖는 객체와 유사하다. 이것은 동일한 개체와 그들이 형성하는 집합에 대한 관계만을 위한 장소가 있는 수 학의 컨텍스트에서 보아야 한다. 얽힌 CU의 방향성: 얽힌 CU 들 중 '차별화 방향성'은 다음 두 종류가 있다. a. 양방향: 이것은 '방정식'과 관련하여 얽힌 CU에 적용된다. 이러한 경우, CU 중 하나에서 트리거 상태를 결정 하는 이벤트는 어떤 CU가 다른 CU보다 우선하는지 결정한다. 예: A+B = C+D. NSL에서, A+B는 얽힌 CU 중 하나에 속하고, C+D는 다른 CU에 속한다. A+B 값이 먼저 결정되면 선행 CU가 되고, C+D 값이 먼저 결정되면 선행 CU가 된다. 방정식의 경우, 등식 부호(=)는 두 CU 모두 상수로 존재해야 한다. i. 조건부 트리거: '얽힌 CU'의 트리거 특성은 CU 내의 모든 변경 드라이버가 도착하면 트리거가 발생하는 일반 CES 기반 트리거와 다르다. 조건부 트리거의 경우, 다음 CU의 상태도 중요하다. 그 상태는 하나의 변수를 제외 한 모든 변수가 값 결정을 기다리는 것이어야 한다. 'A+B' 값이 결정되면, 'A+B' CU가 다음 CU에서 'C'에 대한 값을 트리거 및 제공하기 위해 'D'와 수학식 표현 '+'가 도착해야 한다. ii. 가치 함수: 위의 경우, 한 CU는 조건부 트리거 상태의 이행을 기반으로 다른 CU에서 값을 생성한다. iii. 조건부 함수: 솔루션 설계자가 얽힌 상태와 관련하여 결정해야 할 동등 또는 비 동등 조건을 찾으려는 경 우, 단일 대안 CU로 작동한다. 예: A+B = C+D이면, CU2를 트리거하고, 같지 않으면 CU3을 트리거한다. b. 일 방향: 이는 방정식 이외의 수식에 적용된다. 예: 'A+B' > 'C+D'. 이 경우, 'A+B'는 항상 선행하는 CU이고, 다음 CU 'C+D'도 '>' 기호를 수반한다. CU 'C+D'의 값은 'C+D' 값이 도착한 조건에서 'A+B' CU에 의해 결정된다. 'C+D' 값이 도착하지 않는 한, 단일 대체 CU는 트리거되지 않는다. 그러나 이러한 값이 도착하면, 대 체 CU 중 하나('>' 값이 있는 하나 또는 '< 또는 =' 값이 있는 하나)가 트리거된다. 연결된 CU: 생태계의 모든 CU 및 개체는 서로 관련되어 있다. 그 관계가 얼마나 가깝고 먼가의 문제일 뿐이다. 이것은 인간이 1촌, 2촌, 3촌 형태의 친척을 갖는 것과 유사하다. 연결된 CU는 특정 GSI의 생태계에 속하는 CU 이다. 연결된 GSI가 많을 수 있지만, 그 중 하나가 이행되면 이벤트에 의해 수행된 선택을 기반으로, 연결된 다 른 GSI가 사라진다. 예를 들어, 파일과 도시락을 들고 목적지에 도착하려는 고객의 글로벌 의도를 충족하기 위 해서, 두 명의 개별 에이전트가 해당 개체(파일과 도시락)을 연결된 CU 시스템에 공급할 수 있다. 연결된 CU의 예는 도 5에 나타나 있다. 관련 개체 및 CU: 관련 개체는 솔루션 생태계에 직·간접적으로 속한 모든 개체를 의미한다. 솔루션 생태계로부 터 들어오고 나가는 개체도 포함된다. 이는 모든 클래스와 모든 트랜잭션으로 확장된다. 관련 CU는 동일한 글로벌 의도로 연결되지 않을 수 있는 CU이다. 연결된 CU 생태계는 어떤 면에서 관련 CU 생태계의 하위 집합이다. 관련 CU 시스템의 예: 후보자에게 최종 제안서가 작성되면, 재무 관리자와 고용 관리자 모두에게 통보된다. 재 무 관리자는 예산을 책정해야 하고, 고용 관리자는 신입 사원을 위한 물류를 준비해야 하며, 면접관은 면접 절 차를 진행해야 한다. 관련 CU의 예는 도 6에 나타나 있다. 기본 변경 유닛의 상대성: 모든 유리한 지점에 있는 개체는 구조를 가지고 있다. 수평 구조와 수직 구조가 있다. 개체는 변경 유닛에 분산된다. 변경 유닛은 솔루션의 일부이고, 솔루션은 비즈니스에 도움이 된다. 기본 적으로 모든 솔루션은 하나 이상의 변경 유닛으로 구성된다. 유닛 변경은 입력을 소비하고 출력을 생성한다. 솔 루션이 하나를 초과한 변경 유닛으로 구성된 경우, 제1 변경 유닛으로부터의 출력이 제2 변경 유닛의 입력이 된 다. 제2 변경 유닛의 유리한 지점으로부터, 출력은 반드시 입력이다. 마찬가지로 변경 유닛은 솔루션에 속한다. 솔루션은 비즈니스 유닛에 도움이 되는 경우가 있다. 사업 유닛은 더 큰 사업 부문 또는 수직으로 접힐 수 있다. 변경 유닛 내에는 하위 구조와 상위 구조가 있다. 변경 유닛의 상대성은 솔루션 또는 해당 구성 요소가 표시되는 유리한 지점에 따라 달라진다. 모든 개체와 CU는 서로 관련되어 있다. 원하는 상태에 도달하기 위해, 개체와 CU는 많은 로컬 조합 개체 상태(CES)를 통해 전환해야 한다. 이러한 모든 변환 상태는 원인 및 결과 원 리로 인해 달성되는 바로 다음 상태를 지칭하는 가장 가까운 이웃 개념에 따라 지시된 변경 및 기능을 통해 달 성된다. 희망의 실현과 관련하여 연결 및/또는 관련된 모든 변경 유닛에는 문맥상 ID가 할당된다. 생태계는 에 이전트의 이익에 따라 자체적으로 변경될 수 있으며, 에이전트에게 중요한 개체만 표시된다. 선택된 모든 CU는 참조 프레임을 결정하고, 생태계의 임의의 개체와의 거리를 평가한다. 솔루션의 각 변경 유닛은 에이전트를 희 망의 실현에 더 가깝게 하고 상대적인 위치를 갖는다. 이에 대한 예는 도 7에 나타나 있다. 불확실성의 제어된 감소: 모든 솔루션은 변경의 결과이다. 무작위 변경은 원하는 변경으로 이어질 가능성이 매 우 낮다. 솔루션은 하나의 '차선적 CES'로부터 또 다른 '최적의 CES'로의 변환에 관한 것이다. 변환이 신뢰할 수 있으려면, 변경이 제어된 변경이어야 한다. 인간 에이전트는 환경을 '감지'하여 환경을 응시함으로써 변경을 제어한다. 예: '검색'은 환경을 응시하는 한 가지 메커니즘이다. 에이전트는 계속해서 올바른 개체를 '선택'한 다음, 선택한 개체에 대해 '행동'을 한다. 이러한 제어된 행동은 원하는 CES(최적 CES)에 도달할 때까지 에이전 트를 한 CES로부터 다른 CES로 유도한다. 변경을 제어하려면 마인드 기능이 필요하다. 또한 신체 기능(액추에이 터)도 필요하다. 둘 다 제어된 에너지에 의해 구동된다. 인간의 몸과 뇌는 섭취하는 음식을 통해 에너지를 저장 하고 그러한 에너지의 방출을 제어할 수 있도록 잘 갖추어져 있다. 이것이 본질적으로 의미하는 바는 하나의 CES로부터 다른 CES로 이동하려면 'SSA' 주기의 전환이 필요하다는 것이다. NSL에서, 마인드의 기능은 정의된 멤버십 기준으로 잠재성 개체의 식별을 통해 표현된다. 클래스 레벨 구성 요소가 있는 CU는 한 번에 하나의 CU SSA 주기로 변경 경로를 배치한다. 이러한 일련의 SSA 주기는 이상적인 상황에서 솔루션에 도달한다. 때때로 이 러한 변환 경로(연결된 CU)는 인간 에이전트에 의해 즉석에서 생성된다. 그러나 대부분의 경우, 상황이 본질적 으로 반복적이라는 사실에 기반한 저장 절차이다. 이는 솔루션 설계자가 반복되는 멤버십의 도착을 예상하여 배 치된 솔루션 클래스 레벨 CU를 사용하는 것이다. 솔루션 클래스: 솔루션 아키텍트는 클래스 및 하위 클래스를 규정하고 잠재적인 레벨 단락을 생성한다. 이벤트 는 멤버 레벨에 도달하고, 적절한 클래스를 선택한다. 그것은 항상 욕망이 형성되고 변경 드라이버와 에이전트 가 선택되는 것으로 시작된다. 트랜잭션 논리의 개체로부터 솔루션 논리의 유리한 지점에 있는 개체를 분리하는 것이 중요하다. 솔루션 논리에서 변수는 개체 관계의 원리를 나타내는 '모든 LSI', '모든 인간 에이전트', '모 든 펜', '모든 종이' 등이다. 모든 클래스에는 암시적 또는 명시적 멤버십 결정 기준이 있다. 한쪽 끝에는 '빛 이 있는지 없는지'와 같은 이진 상태일 수 있다. 다른 쪽 끝에는 전 세계 70억 인구 중 누구라도 멤버로 즐길 수 있는 클래스인 '사람'이 될 수 있다. 그러한 경우, 규칙은 클래스가 70억 명 중 아무거나 한 번에 한 명만 허용한다는 것이다. 하위 솔루션 클래스: '트랜잭션 클래스'에 이르기까지 솔루션 사이에 임의의 수의 하위 클래스가 있을 수 있다. 예: 세계가 클래스 레벨 개체인 경우, USA는 하위 클래스가 될 수 있고, 캘리포니아는 하위-하위-클래스(sub- sub-class)가 될 수 있다. 하위 클래스는 클래스의 멤버라는 점에 유의해야 한다. 트랜잭션 클래스: 트랜잭션 클래스는 솔루션 클래스의 멤버이다. 트랜잭션이 수행될 때, 사용자는 솔루션 클래 스가 허용하고 잠재성 상태에 있는 다양한 가능성과 옵션 중에서 선택할 수 있다. 그것은 트랜잭션이 재생되는 트랜잭션 클래스에 있다. 명시된 트랜잭션 변경 드라이버(CD)가 CU의 물리적 계층에 배치되어야 한다. 트랜잭션 이 재생되려면, '최소 멤버십 기준'을 충족해야 한다. 예를 들어, CU가 인간의 정보를 명시하고, 개가 도착하면 최소 기준을 충족하지 않는다.차별화된 트랜잭션 클래스: 이것은 '최소 멤버십 기준'을 충족하는 것보다 훨씬 더 많은 트랜잭션 클래스 개체 가 전달해야 하는 훨씬 더 많은 정보가 있는 것이다. 예: 도착한 펜은 색상, 제조사, 도착 시간, 도착 장소 등 과 같은 추가 정보를 가지고 있을 수 있다. 하위 트랜잭션 클래스: 솔루션 생성의 일부로서 솔루션 설계자는 세부 사항을 언급하지 않고 트랜잭션 클래스를 규정한다. 트랜잭션 클래스에 도착하는 에이전트는 하위 트랜잭션 클래스라고 하는 트랜잭션의 하위 클래스를 만들 자유가 있다. 예: 솔루션 설계자는 편지를 쓰기 위한 CU를 규정하지만, 편지를 쓰는 에이전트는 편지의 스 타일과 내용을 선택한다. 이 기능은 트랜잭션을 수행하는 모든 에이전트가 트랜잭션 레벨에서 솔루션의 설계자 가 될 수 있도록 한다. 이는 정보 및 결정 권한을 적용한 동일한 솔루션 환경을 사용하여 가능하다. 클래스 내 에 클래스 생성 도입을 통해, NSL은 모든 트랜잭션 수행자와 사용자를 '기획자 및 설계자'로 전환한다. 이것은 계획에 따라 자유도를 제한하는 경우에 전제로 한다. 트랜잭션 레벨의 에이전트가 자신의 운명을 개척하는 데 도움이 된다. 한 가지 시나리오는 솔루션 설계자가 제시한 제약에 국한되는 것이다. 이러한 시나리오에서는 규 정된 제약에 따라 행동할 수 있지만, 기존 솔루션 환경에서 더 높은 레벨의 설계 범위 내에서 계획 및 설계할 수는 없다. 예: 트랜잭션 에이전트에게 트랜잭션을 계획하고 설계할 수 있는 유연성이 주어진다면 어떻게 될까? 시스템 레벨의 제약은 트랜잭션 에이전트가 식민지에 있는 100채의 어떤 집에도 하루에 10번의 배달을 해야 한 다는 것이다. 이용 가능한 자유도 내에서 트랜잭션 에이전트는 솔루션 설계자가 계획하는 데 사용한 것과 동일 한 설계 시스템을 사용할 수 있다. 첫 시간에 'x' 집에, 두 번째 시간에 'y' 집에 배달하는 식으로 계획을 세울 수 있다. 모든 계획 또는 알고리즘은 이치에 맞는 제약을 설정하는 것이다. 백만 가지 가능성이 있는 동안, 에 이전트는 일부 기준 및 계획에 따라 일부 제약을 둔다. 은유적으로, 현재의 시스템은 감각 정보를 기반으로 환 경에 반응할 수 있는 진화 설계 동물과 비교할 수 있다. 그러나 동물들은 고차 인지 기능을 수행할 수 있는 전 두엽 피질(prefrontal cortex)이 없기 때문에 계획을 세울 수 없다. 트랜잭션 하위 클래스의 도입은 동물에게 전두엽 피질을 장착하고 인간으로 만드는 것과 같다. 이제 생각하고 계획할 수 있는 동물이 있다. 하위 트랜잭 션 클래스는 이와 유사하다. 그것은 사람들에게 힘을 실어주는 강력하고 훌륭한 방법이다. NSL은 모두 제어된 차별화에 관한 것이다. 개체가 기존 CES에 추가되면, 해당 개체는 CES 또는 ECES를 더욱 차 별화한다. 어떠한 개체도 삭제하거나 개체의 가치를 무시하면 사물은 일반화(비 차별화)의 방향으로 향하는 경 향이 있다. 모든 솔루션 설계는 CES 또는 ECES 형태의 클래스 연결을 통한 클래스의 최적 차별화를 중심으로 한 다. 이러한 클래스는 다른 이름으로 사용되지만 동일한 의미를 갖는다. 예: 제약, 규칙, 제한, 절차, 알고리즘, 가설, 프로세스, 구조, 집합, 지침, 규정, 법률 및 시스템. 이들은 모두 동의어이며 같은 의미이다. 그들은 특 정 멤버를 인정하고 다른 멤버를 거부함으로써 가능성을 축소한다. 자연에는 개체나 클래스에 대한 개념이 없다. 자연에서 모든 것은 자연의 근본적인 힘에 의해 작동하며 연속적이다. 에이전트 시스템에서만 클래스 및 멤버 형태의 개체 도입이 발생한다. 개체는 무한의 복잡성을 극복하기 위해 배제된 중간 원리에 의해 작동한다. 진화(Evolution)는 모든 살아있는 존재를 위한 개체 기반 모델을 생성하였다. 살아있는 존재는 방향성 에너지를 통해 생존을 위해 중요한 개체를 향하는 경향이 있다. 인위적으로 생성된 '기계 에이전트'도 동일한 개체 기반 모델을 따른다. 에이전트는 클래스 생성을 통해 예상하고, 도착하는 멤버는 기대를 충족한다. 설명에서 언급한 바와 같이, 에이전트는 클래스와 관련하여 클래스 또는 멤버를 일치시키는 기능을 갖추고 있다. 여러 클래스 레 벨의 CES 또는 ECES를 생성하여 클래스를 차별화할 수 있다. '트랜잭션 클래스'에서 최종 하강이 발생하기 전에 해당 클래스 내에 임의의 수의 하위 클래스가 있을 수 있다. 일반적으로 권한이 부여된 솔루션 설계자는 트랜잭 션 클래스 레벨까지 클래스의 차별화를 처리한다. 이후, 트랜잭션 시점에서 주어진 역할을 수행하는 에이전트는 클래스의 제약 내에서 작동하고 트랜잭션을 관리한다. 솔루션에서 지정된 날짜에 고객에게 서비스를 제공해야 한다고 지정한 경우, 역할 소유자는 해당 사양을 준수해야 한다. 그러나 이러한 제한 내에서, 역할 소유자는 여 러 자유도를 갖는다. 역할 소유자는 아침, 오후 또는 저녁에 고객 서비스를 선택할 수 있다. 여기서 최소 멤버 십 기준은 하루이다. 이러한 자유도에 의해, 많은 선택을 할 여지가 많이 있다. 실제로 에이전트(역할 보유자로 서)가 이 상황을 처리하는 방식은 트랜잭션 성능을 우연히 발견하지 않는 것이다. 즉, 트랜잭션 클래스의 범위 내에서 하위 트랜잭션 클래스를 생성한다. 예: 에이전트는 특정한 날에 10명의 고객에게 서비스를 제공할 임무 를 부여한다. 에이전트는 그 날에 모든 고객에게 서비스가 제공되는 한 주문에 상관없이 해당 고객에게 임의의 순서로 자유롭게 서비스를 제공할 수 있다. 에이전트는 마음 속에 하위 트랜잭션 클래스(STC)를 생성하여 계획 활동을 시작한다. 하루 동안 에이전트는 해당 클래스에 대한 멤버십이 계획대로 발생하도록 하여 해당 STC를 실 행한다. 이것은 사람들이 현실 세계에서 인간 에이전트로 작동하는 방식이다. 트랜잭션 에이전트는 솔루션 설계 자가 설계한 대로 트랜잭션 클래스의 범위 내에 있기 때문에, 설계와 관련하여 충돌을 일으키지 않는다. 트랜잭 션 에이전트는 원하는 대로 이러한 STC를 생성할 수 있는 권한을 체계적으로 부여받는다. 이러한 STC가 일회성 활동과 관련된 경우, 할 일 항목의 형태를 취한다. 반복되는 활동과 관련되어 타임라인을 가로지르는 경우, 동일한 활동을 동일한 방식으로 다시 수행하게 하는 습관과 동일하다. 차별화를 향한 하강: 솔루션 클래스로부터 차별화된 트랜잭션 클래스까지의 하강이 발생함에 따라 각 레벨의 멤 버는 위의 클래스에 태그가 지정된다. 예: 세계-미국-캘리포니아. 이렇게 하면 끊어지지 않은 차별화 트리를 체 계적으로 캡처해야 한다는 요구 사항이 유지된다. 개체가 속할 수 있는 섭스트레이트에 관계없이 모든 것이 정 보이다. 따라서 정보에 따른 행동에는 '물리적 섭스트레이트에서의 행동'도 포함된다. 예: 편지를 받은 것에 대 한 응답으로 편지를 쓰는 것은 정보에 따라 행동하는 것이다. 펄럭이는 종이 위에 문진을 얹는 것도 정보에 따 른 행동이다. 이때 발생하는 질문은 '에이전트는 언제 정보에 따라 행동해야 하는가? 라는 것이다. 이 질문에 대한 간단한 대답은 새로운 정보를 생성하는 데 소비된 노력이 새로운 정보의 이점보다 적을 때 에이전트가 정 보에 따라 행동해야 한다는 것이다. 예: 어두운데 책을 읽고 싶다면, 일어나서 불을 켜는 것은 가치 있는 노력 이. 불을 켜는 행위에 소비되는 물리적 에너지 비용은 책을 읽는 이점보다 적다. 이러한 원리에 따라, '차별화 된 트랜잭션 클래스' 정보가 더 많은 경우, 여기에 내포된 SSA 주기를 부가하고, 새로운 가치 있는 정보를 생성 하는 것이 합리적일 수 있다. 최소 멤버십 기준: 최소 멤버십 기준은 클래스 레벨의 차별화를 다룬다. 멤버십은 클래스 레벨에서 첨부된 제약 의 형식으로 규정되고, 멤버의 도착 기준을 의무화한다. 멤버가 여러 계층의 정보를 가지고 도착하는 동안, 입 장에는 최소한의 관련 정보만 고려되는 반면, 다른 모든 정보는 무시된다. 예를 들어, 승객이 여행을 위해 공항 터미널에 도착하면, 체크인 카운터에서 탑승권을 발급받기 위한 최소 요구 사항은 항공권과 여권이다. 보안 검 색 차원에서, 탑승권과 수하물 검색은 보안 검색을 위한 최소한의 기준이다. 마지막으로 항공기 탑승을 위해서 는 스탬프가 찍힌 탑승권이 비행기 탑승을 위한 최소한의 기준이다. 운전면허증, 직장번호, 전화번호 등과 같이, 체크할 다양한 것들이 있다. 다만, 각 확인 단계에서는 최소 멤버십 기준만을 확인하고, 그 외의 사항은 무시한다. 이 예는 도 8에 나타나 있다. 변동성: 개체가 클래스에 멤버로 들어갈 때, 최소 멤버십 기준만 충족한다. 예: 어떤 사람이 클럽 멤버인 경우, 멤버십 카드를 지참하면 클럽에 입장할 수 있다. 최소 멤버십 기준을 충족한 후, 자격을 갖춘 각 멤버는 더 많 은 정보를 전달한다. 예: 멤버는 입장 시간, 성별, 키, 체중, 피부색 및 수많은 기타 정보를 가지고 다닌다. 트 랜잭션 규모가 커질수록 데이터라는 정보의 양도 증가한다. 이러한 데이터는 의미 있는 정보를 식별하기 위해 다양한 방식으로 구성되고 해석될 수 있다. 데이터 또는 정보의 변동성은 여러 가지 방법에서 통계적으로 평가 된다. 평균, 중앙값, 최빈값, 비율, 범위, 분산, 표준 편차 등을 식별하는 확립된 방법이 있다. 분석 및 추론 도출에서 이들의 유용성은 아무리 강조해도 지나치지 않는다. 이 예는 도 22에 나타나 있다. NSL은 BET의 모든 유리한 지점에서 통계 분석을 수행할 수 있는 가능성을 제공한다. 또한, 가장 가까운 이웃을 통해 모든 BET의 연결성을 최대한 활용한다. 그에 추가하여, NSL을 사용하여 데이터 시각화 기술을 더 잘 배포할 수 있다. 예약된 개체 및 예약된 CU: NSL에서 생성된 모든 솔루션은 동적 솔루션 딕셔너리(Dynamic Solution Dictionary, DSD)라고 하는 라이브러리에 선별 및 저장된다. 솔루션에 포함된 BET와 함께 DSD에 저장된 각각의 이러한 솔루션은 동일한 것을 재생성하거나 재설계하는 대신 어떠한 솔루션 설계자도 재사용할 수 있다. NSL은 다양한 유리한 지점에서 기존 BET를 사용할 수 있는 능력을 제공함으로써 솔루션 논리 구축의 중복성을 최소화 한다. 이러한 재사용 가능한 개체를 예약된 개체라고 한다. 전체 CU를 재사용할 수 있는 경우 예약된 CU라고 한 다. 동적 솔루션 딕셔너리: DSD는 NSL의 모든 솔루션 및 솔루션 구성 요소의 단일 중앙 저장소이다. 생각할 수 있는 모든 솔루션은 다양한 소스에서 제공된 DSD에 있어야 한다. 가장 낮은 레벨의 속성으로부터 가장 높은 레벨의 책이나 도서관에 이르기까지 모든 유리한 위치에 있는 개체가 DSD에 존재한다. DLD(솔루션 생성) 엔진이 이 DSD 에 연결되어 존재하지 않는 어떠한 솔루션도 즉시 구축하고 DSD에 기여할 수 있다. DLD는 GSI를 자체 생성하고, 유휴 시간 동안 LSI를 통해 GSI를 활성화하여 지속적으로 DSD를 강화할 수 있다. 이것은 노력과 결과에 할당된 점수를 기반으로 한 '포인트 시스템'을 기반으로 한다. 이것은 할당된 가치를 기반으로 하는 수익, 비용, 및 이 익의 원리에 의해 주도되는 비즈니스 기능과 다소 유사하다. GSI를 자체 생성할 수 있는 경우, 내포된 SSA 주기 는 인간 에이전트가 생각하고 작동하는 방식만 모방(emulate)한다. 모든 솔루션 또는 해당 구성 요소는 NSL의 백화점에서 사용 가능한 것으로 시각화할 수 있다. 백화점은 매장에서 사용할 수 없는 어떠한 제품도 즉시 조립 하는 기계 에이전트 구동 조립 라인에 연결된다. 개체는 고유한 ID를 가진 모든 유리한 지점에 존재할 수 있다. 다른 유리한 지점에 있는 각 개체는 이진 상태에 있는 해당 유리한 지점으로부터 찍은 스냅샷(snapshot)과 같다. 개체는 가장 가까운 이웃이라는 개념을 통해 함께 연결된다. DSD에는 사용자가 솔루션 세계에 참여하는 동적 사용자 인터페이스가 있어야 한다.섭스트레이트: 다른 시스템의 개체와 동등성을 확립하기에 충분한 수의 멤버 개체를 포함하는, 자체 속성 및 규 칙 집합을 갖는 임의의 자체 포함 시스템은 섭스트레이트이다. 위에서 언급한 '규칙'은 다음과 동의어이다: (a) 제약, (b) 속성, (c) CU, (d) 원리, (e) 잠재성, (f) 법률, (g) 알고리즘 또는 임의의 기타 동의어 이름. 예: 물리적 섭스트레이트는 원자로 구성되는 고유한 섭스트레이트를 가지고 있으며, 해당 개체와 연관된 질량을 갖 는 3차원 세계에서 작동한다. 마찬가지로, 영어는 특정 종류의 알파벳으로 구성된 섭스트레이트이다. 개체가 표 현되거나 암시된 것일 수 있는 것처럼, 섭스트레이트도 솔루션 생태계에서 표현되거나 암시될 수 있다. 모든 섭 스트레이트와 개체는 '물리적 실재'에 속하며, 예외 없이 시공간에 표현된다. 모든 개체는 어떤 물리적 형태로 존재해야 하며 공간과 시간에 내재되어 있어야 한다. 물리적인 모든 것은 그것과 연관된 고유성을 가지고 있기 때문에, 정의상 정보이기도 한다. 현대 물리학에서는 현실의 물리적 양태와 정보적 양태 사이의 경계가 사라졌 다. 개체는 솔루션 전체에서 한 섭스트레이트로부터 다른 섭스트레이트로 이동한다. 묵시적 섭스트레이트는, NSL 솔루션이 명시적으로 언급되지 않은 경우에도, 기본적으로 하나의 섭스트레이트 또는 다른 섭스트레이트에 저장된다는 사실을 나타낸다. 예를 들어, 솔루션 설계자는 NSL 플랫폼에서 솔루션을 생성할 수 있다. 사용자 인 터페이스를 사용하여 솔루션을 생성하는 것은 데이터가 물리적으로 데이터베이스에 저장된 경우에만 가능하다. '클래스의 클래스'로서의 섭스트레이트: 섭스트레이트는 '클래스의 클래스'이다. 각 섭스트레이트는 솔루션 클 래스 레벨에서 많은 수의 개체를 포함하는 시스템이다. 섭스트레이트에 포함된 개체는 자신이 속한 섭스트레이 트의 특성에 종속된다. 즉, 섭스트레이트에 관련된 제약 또는 규칙은 섭스트레이트의 각 개체에 적용된다. 예: 물리적 섭스트레이트의 '바위'는 자연의 물리적 법칙과 관련된 기본 법칙에 의해 지시된 바와 같이 무거울 것이다. 자연 언어의 섭스트레이트에 있는 '단어 바위'는 자연 언어 문법과 같은 자연 언어의 법칙을 지배하게 된다. 인간이 환경에서 많은 개체를 인식할 수 있는 능력이 있는 것처럼, 여러 섭스트레이트를 인식할 수 있는 능력을 가질 수 있다. 섭스트레이트 및 그 특성: 섭스트레이트는 관찰, 기록 및 통신에 사용되는 매체이다. 인간이 사용할 수 있는 섭 스트레이트는 여러 가지가 있다. 오디오/비디오/이미지는 일반적으로 알려진 섭스트레이트이다. 각 섭스트레이 트에는 개체의 진리 값을 동일시하는 고유한 구성 집합이 있다. 섭스트레이트와 관련하여 특성에는 몇 가지 공 통점이 있다. 예를 들어, 황동으로 만든 모든 조각상(statue)은 유사한 속성을 갖는다. 황동 조각상은 임의의 개인을 나타낼 수 있다. 그러나 사진이나 이미지를 통해 동일한 개인을 나타낼 수 있다. 이미지의 특성은 다시 유사성을 갖는다. 각 섭스트레이트에는 고유한 특성이 있다. 3 차원 표현은 구성 면에서 2차원 표현과 크게 다 르다. 마찬가지로, 개체를 나타내는 종이에 쓰여진 텍스트는 동일한 개체를 나타내는 이미지와 많이 다르다. 섭스트레이트 태깅 및 섭스트레이트 크로스오버: 모든 개체는 다수의 섭스트레이트에 상주할 수 있다. 모든 개 체는 본질적으로 물리적이고 정보적이다. 개체는 여러 표현을 가질 수 있으며, 표현은 여러 섭스트레이트에 존 재할 수 있다. 각 섭스트레이트와 그 구성 표현에는 고유한 특성을 지닌다. 예를 들어, 사람 조각상에는 고유한 특성 집합이 있다. 그것은 무거울 수 있고, 철이나 황동으로 만들어지며, 한 위치로부터 다른 위치로 이동하는 데 시간이 걸린다. 사람의 이미지는 매우 다른 특성을 가지고 있다. 더 가볍고 쉽게 이동할 수 있으며 훨씬 적 은 공간을 차지하며 훨씬 적은 정보를 담을 수 있고, 2차원 형태를 갖는다. 솔루션이 실행되려면, 중요한 형식 (섭스트레이트) 또는 표현에 대한 결정을 규정해야 한다. 때때로 의사가 직접 수술을 수행해야 한다. 경우에 따 라 의사가 전화를 걸어 상담하고 솔루션을 제시할 수 있다. 표현이 변경되면 섭스트레이트도 변경된다. 따라서 모든 개체와 해당 개체의 표현이 상주하는 섭스트레이트와 함께 그 표현이 솔루션 관점으로부터 중요해지는 것 이 중요하다. 전자기적 형태의 표현은 물리적 개체에 비해 훨씬 빠른 속도로 움직인다. 섭스트레이트 교차 및 섭스트레이트 태깅의 개념은 잠재적으로 가장 효율적인 솔루션을 구축하는 데 강력한 영향을 미칠 수 있다. NSL 에 의해 부여된 역동성과, 원활한 섭스트레이트의 태그 부착 및 크로스오버를 조합함으로써, 솔루션 전망을 진 정으로 변경시키고, 새로운 시대의 획기적인 솔루션을 도출할 수 있다. 동등성 원리: 수학의 방정식은 A=B=C=D일 때 동등성 원리에 의해 작동하며, 이들은 교환 가능하게 된다. 마찬가 지로, 많은 섭스트레이트는 다른 섭스트레이트 또는 동일한 섭스트레이트 내에서 동등한 개체를 가질 수 있다. 예: '분자 배열이 라마와 동일시됨'의 집합이 '라마의 조각상'과 동일한 섭스트레이트에 동등함에 따라, 물리적 섭스트레이트의 '라마'는 언어 섭스트레이트에서 동등한 개체, 이미지 섭스트레이트 '이미지 라마'에서, 인지 기섭스트레이트판(뇌)에서 '단어 라마'를 가질 수 있다. NSL은 섭스트레이트를 포함하여 세계의 모든 개체를 물 리적 세계에 존재하는 것으로 취급한다. 마찬가지로, 구별되는 모든 것이 개체가 될 자격이 있기 때문에, 또한 섭스트레이트를 포함하여 세계의 모든 개체를 정보로 취급한다. 각 섭스트레이트의 모든 개체는 정의상 정보이 어야 한다. 이는 섭스트레이트 전체의 모든 동등한 개체가 동일한 정보를 전달한다는 의미는 아니다. 복제된 개 체를 제외하고는 서로 다른 섭스트레이트에 상주하는 동일한 개체들 간에 정보 비대칭이 존재한다. 예: 편지가100 명에게 전자적으로 복사되는 경우. 동등성 원리가 요구하는 모든 것은 '최소 멤버십 기준(MMC)의 충족'이다. MMC가 찾는 것은 멤버십 기준을 충족하는 것과 같은 최소한의 필수 정보이다. 임의의 추가 정보는 환영하지만 필수는 아니다. 섭스트레이트의 A를 살펴봄으로써, 다른 섭스트레이트 또는 동일한 섭스트레이트에 서 동일한 것으로 다른 개체를 식별할 수 있으면, 동등성 요구 사항이 충족된다. '물리적 라마'는 10^50비트의 정보를 전달하고, '단어 라마'는 32비트의 정보를 전달하고, '이미지 라마'는 10^7비트의 정보를 전달하는 경우 일 수 있다. 동일한 개체들 간의 정보 콘텐츠는 다를 수 있다. 동등성 원리에 따라 섭스트레이트 간에 크로스오 버가 발생할 때, 진리 값이 보존되어야 하는 것은 부수적이다. 예: '물리적 라마'가 '단어 라마'와 같을 때, 진 리 값이 보존된다. '물리적 라마'가 '단어 크리슈나(Krishna)'와 동일시될 때 진리 값은 보존되지 않는다. 표상적 개체: NSL에서 모든 것은 본질적으로 문맥적이고 상대적이다. CU의 물리적 계층(CD로서)에 있는 문맥적 으로 관련된 개체는 무엇이든지 '실제 개체'가 된다. 그것과 '동등한 관계'를 가진 다른 모든 개체는 표상적 개 체가 될 것이다. 다시 말해, '실제 또는 표상적'인 것은 문맥성에 기반을 두고 있으며 본질적으로 상대적이다. 실제 개체인지 표상적 개체인지를 결정하기 위해, 어떤 섭스트레이트도 다른 섭스트레이트보다 우위를 차지하지 않는다. 변경 유닛은 동시에 다른 섭스트레이트로부터 변경 드라이버(CD)를 가질 수 있다. 예: 메시지는 하나의 CD가 될 수 있고, '물리적 펜'은 또 다른 CD가 될 수 있으며, '이미지'는 각각 상이한 섭스트레이트에 속하지만 동일한 CU에 있는 또 다른 CD가 될 수 있다. 번들된(bundled) 섭스트레이트: 섭스트레이트들 사이에 많은 친화성이 있을 때, 그들은 번들된다. 예: 정보 기 술에서, 추상화 계층은 NSL 용어의 섭스트레이트에 불과하다. 이러한 섭스트레이트는 전자기력, 정보 비트, 기 호, 데이터베이스, 논리 및 기능 계층, UI 등에 의해 제어될 수 있다. 그들은 공생 관계를 가지고 있기 때문에 함께 번들된다. 이 번들된 거동은 다른 많은 섭스트레이트 그룹에도 적용된다. 예: 뇌는 정보를 캡처하는 섭스 트레이트, 정보를 저장하는 섭스트레이트, 정보를 처리하는 섭스트레이트 등 많은 섭스트레이트를 즐긴다. 관련 섭스트레이트: 내부의 작은 변동과 관련된 섭스트레이트 내에 많은 섭스트레이트가 있을 수 있다. 예: 하 드(hard) 자산이 섭스트레이트 범주인 경우, 고정 자산 및 재고라고 하는 2개의 분기(branch)가 있다. 이들은 하드 자산의 광범위한 섭스트레이트 내의 섭스트레이트이다. 마찬가지로, 자연 언어가 섭스트레이트인 경우, 계 층이 있는 세계에는 7,000 개의 자연 언어가 있다. 마찬가지로, 세계의 무생물은 둘 다 같은 물리적 세계에 속 하기 때문에 생물과 관련이 있다. 계층적(hierarchical) 섭스트레이트: 섭스트레이트가 더 광범위하게 또는 좁게 정의되는 경우가 있다. 섭스트레 이트를 '하드 자산'으로 정의할 수 있거나, 섭스트레이트의 유리한 지점으로 내려가서 '고정 자산' 섭스트레이 트와 '변동 자산' 섭스트레이트로 범위를 좁힐 수 있다. 속성을 통해 독립된 개체에 적용되는 차별화 원리는 보 다 차별화된 섭스트레이트에도 적용될 것이다. 물리적 연속체(Physical Continuum): 물리적 연속체의 원리는 솔루션이 정보를 제공하고, 정보가 한 섭스트레이 트 또는 다른 섭스트레이트에 물리적으로 저장되어야 하며, SSA 주기가 연속적으로 수행된다는 기본 전제를 다 룬다. 물리적 연속체의 원리는 불연속 상태와 진리 값을 보존함으로써 섭스트레이트들 간에 연속적인 스레드 (thread)와 정보 교환을 유지한다. 물리적 연속체의 원리는, 연속성의 물리적 사슬을 끊지 않고 진리 값과 불연 속성을 보존하면서 서로 다른 섭스트레이트에 저장되는 정보를 다룬다. 문제 상태로부터 전이 상태로의 지속적 인 전환이 있기 때문에, 각 상태는 본질적으로 조합적이다. 한 상태로부터 다른 상태로의 이동은 또한 하나의 조합 개체 상태로부터 다른 조합적 개체 상태로의 전이로 보아야 한다. NSL에는 상태의 연속체를 저장할 수 있 는 능력이 있다. 개체가 명시적이든 암시적이든 NSL에는 모든 상태를 캡처하고 섭스트레이트를 연결하는 모델을 갖는다. 플랫폼은 진실 값을 캡처하기에 충분히 중요한 최소한의 정보를 저장할 수 있는 기능이 있지만, 모든 섭스트레이트가 동일한 양의 정보를 전달하는 것은 아니다. 예를 들어, 시각 장애인은 귀, 냄새 및 촉각을 통해 더 많은 정보를 감지할 수 있다. 사람들은 종종 정보를 동화하는 다양한 방법을 가지고 있다. 사람이 어두운 방 에 있으면, 시력이 그 목적에 부합하지 않을 수 있다. SSA 주기는 지속적으로 회전하며, 각 SSA 주기는 불연속 적인 변경 유닛이다. 그러나 현실에서 발생하는 이벤트는 하나의 섭스트레이트 또는 다른 섭스트레이트에 의해 캡처된다. 현실을 정확하게 전달하기 위해 진리 값을 보존하는 일정한 섭스트레이트 교차가 있다. 문제 상태로 부터 해결 상태로의 에너지 흐름은 연속적이다. 따라서 SSA 주기는 임의의 섭스트레이트에서 표상적 카운터파트 를 찾고 각 섭스트레이트는 물리적으로 저장된다. 물리적 연속체의 원리는, 표현을 동일시하는 데 충분한 구성 을 가짐으로써 진리 값을 보존하면서, 상이한 섭스트레이트에 저장되는 정보를 처리한다. 이 예는 도 9에 나타 나 있다. 공생 섭스트레이트(Symbiotic Substrates): 그것이 인간 에이전트이든 기계 에이전트이든, 솔루션에 이르는 물 리적 연속체는 고립되어 달성될 수 없다. 섭스트레이트들 간의 원활한 전환 또는 교차는 물리적 연속체와 솔루 션을 향한 진행을 유지하는 데 필요하다. 예: IT의 경우, 예를 들어, 구속된 섭스트레이트에 입력이 제시되고, 그로부터의 출력이 취득되는 장소인 사용자 인터페이스가 없는 경우, 물리적 연속체를 유지할 수 없다. 섭스트레이트의 특성: 특정 섭스트레이트에 속하는 개체는 이러한 섭스트레이트의 특성에 의해 영향을 받는다. 예: 물리적 섭스트레이트는 원자로 구성되고, 자연 언어는 '알파벳'으로 구성되며, 디지털 이미지는 화소로 구 성된다. 주어진 섭스트레이트에 있는 개체의 특성은 해당 개체가 상호 작용하는 방식에 의해서도 영향을 받는다. 물리적 섭스트레이트 개체는 자연이 지시하는 제약 또는 규칙과 동일한 자연의 근본적인 힘에 의해 구 동된다. 예를 들어, 빛은 진공 상태에서 일정한 속도로 이동하고, 두 개의 물리적 몸체가 동일한 공간과 시간을 차지할 수 없으며, 이와 유사한 것은 자연이 지시하는 몇 가지 제약 사항이다. 언어 섭스트레이트는 해당 언어 의 문법(제약 또는 규칙)을 준수해야 한다. 지각 섭스트레이트는 뇌의 분자가 자신을 배열하고 표상적 개체로 작용할 수 있는 방식에 따라 달라진다. 뇌의 활동은 뉴런이 발화(fire)하거나 발화하지 않는 조건에 따라 결정 된다. 이러한 각각의 '제약 기반' 또는 규칙 기반 동작은 이와 연관된 SSA(Sense, Select, and Act) 주기에 의 해 결정된다. 이러한 SSA 주기는 고유한 각각의 섭스트레이트에서 허용된 변환 경로를 기반으로 발견된다. 섭스 트레이트 규칙을 식별하고 적용하는 것은 발명하는 것이 아니라 적용하는 것이다. 그러한 풍부한 지식 베이스는 이들 섭스트레이트 각각에 대해 이미 존재한다. 섭스트레이트는 에이전트의 정신적 분류이므로, 상당히 많은 수 의 섭스트레이트 클래스가 있을 수 있다. 개체와 마찬가지로, 이러한 섭스트레이트는 중요하지 않은 것일 수 있 다. 때로는 암시적인 것일 수도 있다. 섭스트레이트의 라벨링: 모든 개체는 '공간 및 시간'과 공존하는 현실에 내재되어 있다. 이 현실, 즉 자연은 합 의된 대로 사물을 분류하지 않는다. '자연'에서는 모든 것이 계속해서 무한을 향하고 있다. 개별 개체를 생성하 고 복잡성을 극복하기 위해 분류하는 것은 에이전트이다. 에이전트는 감지, 선택 및 행동(SSA 주기 수행)과 관 련하여 제한된 능력을 가지고 있다. 따라서 에이전트는 자신이 다루는 개체를 최적화해야 한다. 앞서 설명한 바 와 같이, 이러한 분류는 섭스트레이트와 섭스트레이트에 내장된 개체 모두에 관한 것일 수 있다. 섭스트레이트 와 개체는 서로 밀접하게 연관되어 있고 분리할 수 없기 때문에, 그것들은 마치 일정한 동료이며 동전의 양면인 것 같다. 따라서 그것들을 다루는 한 가지 방법은 모든 섭스트레이트를 개체의 속성으로 표현하는 것이다. 개체 는 속한 섭스트레이트에 대해 라벨을 지정할 수 있다. 섭스트레이트는 또한 해당 섭스트레이트의 모든 개체를 횡단하는 섭스트레이트의 특성에 의해 차별화된다. 예: 물리적 섭스트레이트 개체는 그들과 연관된 질량 또는 무게를 갖는다. 그 다음, 그것이 속하는 섭스트레이트의 문맥에서 그것에 특이적인 특성에 의해 더 차별화될 수 있다. 물리적 섭스트레이트의 개체는 고체 또는 액체일 수 있다. 이러한 라벨링은 대부분 기계 에이전트에 의해 자동화된 방식으로 수행될 수 있다. 자동화의 범위는 섭스트레이트 속성 특성 뒤에 있는 예측 가능성 또는 반복 에 따라 달라진다. 자동화가 불가능한 경우, 솔루션 설계자 또는 사용자는 섭스트레이트에 정확한 라벨을 지정 하는 데 도움을 주어야 한다. 속성으로서의 섭스트레이트: NSL에서 모든 것은 상대적이고, 즉 방향에 대해, 중요한 것에 대해, 의도가 무엇인 가에 대해 상대적이다. 개체의 관점에서 사물을 볼 때, 그 섭스트레이트는 그것의 하위 집합 또는 속성이 된다. 이것은 자신이 인도인이라고 선언하는 것과 같다. 여기서 인도는 속성이다. 국가로서의 '인도'의 관점에서 볼 때, 인도의 각 항목은 그 구성 요소가 될 것이며, 따라서 하위 집합 또는 속성이 된다. 섭스트레이트 뒤의 역학: 섭스트레이트를 가로지르는 물리적 연속체가 유지되는 방법은 다음 예시에서 볼 수 있 다. 이 예시는 WWW 원리와 에이전트가 실제 세계와 기술 세계에서 솔루션을 추구하는 방법에 의해 구동된다. 솔 루션을 향한 행진(march)이 일어나는 동안 연속성의 사슬이 끊어지지 않는다는 것을 관찰할 수 있다. 솔루션은 '에이전트'의 컨텍스트에세서만 명백해진다. 자연은 자연의 네 가지 근본적인 힘을 기반으로 작용할 뿐이고 특 별한 선호는 없다. 자연은 어떠한 솔루션도 찾지 않지만 에이전트는 솔루션을 찾는다. 에이전트가 솔루션을 찾 을 때, 연속성 체인, 물리적 연속체는 주로 전자기력에 의해 구동된다. 어떤 경우에는 중력이 역할을 하지만, 자연의 다른 두 가지 근본적인 힘인 강한 힘과 약한 힘은 솔루션의 관점에서 물질적이지 않은 것으로 무시될 수 있다. 인간 에이전트가 갈증을 해소하기 위해 네트를 통해 물 한 병을 주문하는 시나리오를 상상해 보아야 한다. 모든 것은 갈증을 전달하는 분자 재배열의 형태로 '뇌의 섭스트레이트'에 도착하는 일종의 메시지를 초래 하는 '신체의 섭스트레이트'에서 경험되는 일부 화학적 불균형으로 시작된다. 물을 마시고 싶은 욕망이 '뇌의 섭스트레이트'에서 생겨나면, 그 욕망이나 소망을 외부 세계로 전달하거나 릴레이 해야 한다. 즉, 뇌는 그 정보 에 따라 행동해야 한다. 뇌는 혀까지 확장되는 인간 신경계의 섭스트레이트에 의존한다. 동등성 원리에 기초한 신경계로부터의 명령에 따라 근육계가 활성화된다. 혀의 움직임은 공기 중의 분자 섭스트레이트에서 진동을 생 성하여 다시 동등성 원리를 보존한다. 그렇게 함으로써 에이전트는 부수적으로 언어의 섭스트레이트에 의존하게된다. 여기서 생각을 강화하기 위해, 동등성은 신경계의 특정 고유 신호가 동등한 혀의 특정 움직임을 갖는다는 것을 의미한다. 혀의 특정한 움직임은 공기 중에 특정한 고유한 진동을 유발하는 식이다. 공기 분자의 섭스트레 이트를 통해 생성되는 소리와 함께, 욕망의 표현은 '폰(phone) 시스템 섭스트레이트'를 통해 이루어진다. 공기 분자의 진동을 기반으로, 폰의 다이어프램은 이를 '전자기 섭스트레이트'에서 동등한 전자기파로 변환한다. 전 자기파의 각 유형은 특정 표현을 충족한다. 상대방의 폰에 도달하는 신호에서, 전자기 섭스트레이트는 신호를 해당 위치의 공기 분자 섭스트레이트로 전달한다. 상대편에서 전화를 받는 교환원 고막의 섭스트레이트는 고객 의 욕구를 교환원의 두뇌에 전파할 것이다. 동등성 원리를 보존하면서, 교환원은 정보를 신경계의 섭스트레이트 로 전달하고, 이 신경계는 이를 손 근육계의 섭스트레이트로 전달하며, 이는 다시 UI 섭스트레이트 레벨에서 컴 퓨터에 세부 정보를 입력하고, 다시 정보를 컴퓨터의 후드 아래 섭스트레이트로 전송한다. 컴퓨터의 후드 아래 섭스트레이트는 통신 네트워크의 섭스트레이트에 정보를 전달한다. 통신 네트워크는 배달원의 후드 아래 스마트 폰 섭스트레이트에 정보를 전달하고, 배달원은 해당 스마트폰의 UI 섭스트레이트에 정보를 배치한다. 그 UI로부 터 방사되는 전자기파는 배달원의 시각 피질(visual cortex)의 섭스트레이트에 정보를 전달하는 또 다른 섭스트 레이트로서 역할을 한다. 뇌, 신경계, 근육계와 같은 일련의 섭스트레이트 전달을 통해 배달원은 이제 물리적 섭스트레이트 레벨의 정보에 따라 행동한다. 앞서 언급한 바와 같이, 물리적 섭스트레이트 레벨에서 정보에 따 라 행동하는 것은 지각 섭스트레이트 레벨이나 언어 섭스트레이트 레벨에서 정보에 따라 행동하는 것과 다르지 않다. 배달 에이전트는 선반에서 병을 집어 들고 물리적 섭스트레이트를 통해 이동하는 자전거를 타고 고객의 문 앞에 도착한다. 지불이 신용 카드를 통해 이루어지면, 컴퓨터의 번들 섭스트레이트 내에서 발생하는 일련의 섭스트레이트 교차가 다시 발생하고 지불이 이루어진다. 고객은 물리적 섭스트레이트에 있는 물병을 집어 들고 물을 마신다. 물은 신체의 위장 섭스트레이트를 통과하고 장내 벽을 통해 흡수될 때 신체 순환계의 섭스트레이 트로 차례로 전달된다. 이제 신체의 화학적 균형은 물과 관련하여 회복되고, 그 정보는 내부에서 일어나는 분자 의 일부 재배열을 통해 신체에 의해 뇌의 섭스트레이트로 전달된다. 마지막으로 갈증이 해소된다. 결코, 위의 예시에서 섭스트레이트의 관련은 철저한(exhaustive) 것이 아니다. 이 예시는 모든 솔루션이 동등성 원리를 유 지하는 많은 섭스트레이트들 사이에 많은 교차를 필요로 한다는 점을 강조하기 위한 것이다. 또한 섭스트레이트 는 에이전트가 에이전트 내의 개체로 개념화한 클래스라는 점을 강조한다. 묵시적으로 임의의 솔루션 설계에서 많은 개체를 사용할 수 있으며, 주목할 가치가 있는 개체만 지정된다. 편지를 쓰기 위해서, 펜, 종이, 사람, 의 도를 특정할 수 있고, 테이블, 의자, 방의 쾌적함 등의 환경을 주어진 것으로 받아들일 수 있다. 섭스트레이트 의 경우에도 동일한 원리가 적용된다. 언급할 가치가 있는 섭스트레이트만 언급하고 다른 것들은 기정 사실로 받아들인다. 예: 신체와 뇌의 섭스트레이트를 인식하고 많은 하위 섭스트레이트를 무시할 수 있다. 섭스트레이트 라이브러리: 모든 것은 그들이 속한 섭스트레이트에 관계없이 NSL 관점에서 정보를 제공한다. 개 체는 여러 섭스트레이트에 동시에 존재할 수 있다. 그러나 동등성 원리와 진리 값은 보존되어야 한다. 각 섭스 트레이트에 다양한 양의 정보가 있는 정보 비대칭성이 있을 것이다. '최소 자격 정보'의 존재는 서로 다른 섭스 트레이트에 있는 '개체의 평등'을 확립하기에 충분하다. 예: '단어 펜'을 보면, '물리적 펜'과의 동등성을 확립 할 수 있다. '물리적 펜'에 있는 정보의 양은 훨씬 더 높지만(엄청난 양의 불연속/독특한 상태를 수용하기 때문) '단어 펜'에 있는 약간의 정보의 양은 그 동등성을 확립하기에 충분하다. '최소 자격 정보' 기준을 충족 하였다. 모든 섭스트레이트는 에이전트의 정신적 구성물이다. 그들은 클래스의 클래스이다. 예: 펜 자체가 하나 의 클래스이며 물리적 섭스트레이트에 있을 수 있다. '물리적 섭스트레이트'도 클래스이다. '펜 클래스'가 '물 리적 섭스트레이트'라는 섭스트레이트에 있을 때, NSL은 '클래스 안의 클래스'라는 상황을 만난다. 이 예는 도 37에 나타나 있다. 정보 기술의 모든 것은 궁극적으로 언어의 표상적 레벨에서 처리된다. 물리적 섭스트레이트 의 추가 정보는 해당 추가 정보를 언어 용어로 표현되는 '물리적 섭스트레이트의 클래스'에 매달린 속성 값의 형태로 표현함으로써 캡처된다. 또한 이 섭스트레이트가 상주하는 공간과 시간 외부에는 아무것도 떨어질 수 없 기 때문에, 모든 섭스트레이트의 상위 집합(superset)이 '물리적 섭스트레이트'라는 점에 유의하여야 한다. 물 리적 섭스트레이트는 모든 고유한 상태를 캡처해야 하므로, 그 안에 있는 정보가 최대이기 때문에 상위 집합이 다. NSL은, i. 물리적 섭스트레이트, ii. 생명체 섭스트레이트, iii. 언어 섭스트레이트 iv. 이미지 섭스트레이 트, v. 은유/속담/관용구 섭스트레이트에 초점을 맞추는 섭스트레이트 라이브러리를 갖는다. 도 38은 섭스트레 이트 라이브러리에서 식별된 5개의 섭스트레이트를 나타낸다. 섭스트레이트 라이브러리는 다음을 처리한다: 1. 먼저, 구조화된 속성을 통해 모든 개체에 대한 모든 추가 정보를 확립한다. 2. 이러한 개체를 각 섭스트레이트와 관련된 제약에 적용하기 위한 프로세스를 확립한다. 3. 해당 개체가 다른 개체와 개별적으로 또는 조합하여 가질 수 있는 상호 작용과 관련하여 제약을 추가로 확립 한다.4. 만들 수 있는 예측과 도출할 수 있는 추론을 입력한다. 5. 기계 에이전트가 인간 에이전트와 같거나 더 나은 추론을 도출하도록 한다. 섭스트레이트 및 차별화: 각각의 섭스트레이트가 자신의 특성을 갖는다는 것이 주어진다. 또한 섭스트레이트의 각 개체가 속성으로 섭스트레이트의 라벨을 전달하는 것이 주어진다. 또한 서로 다른 섭스트레이트가 섭스트레 이트에 걸쳐 개체에 대해 서로 다른 양의 정보를 전달한다는 것도 확립되었다. 작용할 수 있는 정보는 상이한 섭스트레이트에 대해 다를 수 있다. 물리적 섭스트레이트의 코끼리는 그것과 연관된 엄청난 양(예: 10^40비트) 의 고유 정보(모든 세포와 기능을 세는 경우)를 가지고 있다. (이미지를 통해) 액세스할 수 있는 정보는 10^7비 트일 수 있다. 그럼에도 불구하고 '코끼리'라는 단어에 8개의 알파벳이 있는 8 바이트에 불과한 언어 섭스트레 이트의 정보보다 훨씬 더 많다. 인간은 섭스트레이트들 간의 정보 비대칭성으로 인해 사용할 수 있는 이 추가 정보를 이용한다. 추가 정보에 따라 행동하기 위하여, 각 섭스트레이트의 특성이 제공하는 SSA 주기에 의존해야 한다. 섭스트레이트 SSA 주기 기능의 레벨: 상이한 섭스트레이트 개체가 상이한 양의 정보를 전달하는 것이 주어진다. 동등성 원리는 서로 다른 섭스트레이트에 있는 개체들 간의 정보 비대칭성에 관계없이 여전히 보존된다. 또한 서로 다른 섭스트레이트가 서로 다른 특성과 그 구성 요소가 따르는 규칙을 전달하는 것이 주어진다. 예: 반복 하기 위해, 물리적 섭스트레이트는 자연의 근본적인 힘에 구속된다. 언어 섭스트레이트는 문법에 구속된다. 각 개체는 그것이 속한 섭스트레이트에 관계없이 정보 개체이다. '문진'은 정보 개체이고, '단어 펜'도 정보 개체 이다. 정보 개체로서의 '문진'의 존재와 거동은 물리적 섭스트레이트의 법칙에 구속된다. 정보 개체이기도 한 '단어 펜'의 존재와 거동은 자연 언어 문법이 정한 법칙에 구속된다. 정보에 따라 행동한다는 것은 '지향성 에 너지'를 통해 정보를 변경하는 것을 의미한다. 이러한 제어된 에너지는 SSA 주기의 적용을 통해 이루어진다. 감 지(S), 선택(S) 및 행동(A) 주기는 제어된 에너지 적용을 필요로 한다. 정보가 속한 섭스트레이트에 관계없이, 정보에 따라 행동하면 항상 에이전트에 의해 제어된 에너지가 적용된다. 테이블 위의 문진을 움직이는 것은 정 보에 따라 행동하는 것이다. 다른 단어 옆에 단어를 쓰는 것도 정보에 따라 행동하는 것이다. SSA 주기는 제약,"}
{"patent_id": "10-2023-7006405", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "변환 경로, 규칙, 원리, 법률 또는 참조할 수 있는 임의의 다른 동의어 이름을 지정한다. 사물의 요약과 섭스트 레이트는, 임의의 섭스트레이트의 정보가 작용할 수 있고, 개체가 먼저 자신이 속한 섭스트레이트의 제약에 종 속되고 그 다음에는 NSL 솔루션 프레임워크 제한에 종속된다는 것이다. 예: 문진이 테이블에 대해 눌려지면, 문 진은 물리적 섭스트레이트 원리에 따라 아래로 떨어진다. 마찬가지로, '단어 펜'은 영어에서 명사로 인식되어 처리된다. 섭스트레이트에 대한 SSA 주기는 다음 레벨에서 존재할 수 있다. a. 속성 레벨에서: 모든 개체는 속성으로서 속한 섭스트레이트에 대해 라벨링된다. 해당 섭스트레이트 속성은 특정 속성에 대해 더욱 차별화된다. 일반적으로, 개체는 해당 섭스트레이트에 보편적인 일부 특성을 물려받을 수 있다. 예: '물리적 섭스트레이트'의 모든 개체는 질량을 가진다. 그러나 다른 개체와 비교하여 일부 차별화 되는 속성을 가진 일부 개체가 있을 수 있다. 예: 물리적 섭스트레이트의 일부 개체는 고체 및 기타 액체이거나, 또는 일부는 금속 원자 및 기타 비금속 원자로 구성될 수 있다. 개체의 차별화 섭스트레이트 속성 트리는 상황에 따라 임의의 길이로 될 수 있다. 이것은 기술 세계의 '데이터 유형'과 유사하다. SSA 주기는 그 안에 있는 정보에 따라 작동하도록 이러한 차별화 속성 트리에 첨부될 수 있다. '바위'는 특정 크기보다 작은 것은 바위가 아니지만, 특정 크기보다 큰 조약돌은 바위가 아니라 볼더(boulder)라는 속성 차별화를 가질 수 있 다. 섭스트레이트 속성에 의해 결정되는 개체의 멤버십 기준은 개체 외부의 모든 것을 부적절하거나 비논리적인 것으로 간주한다. 에이전트 중 하나가 조약돌을 가리키며 바위라고 말하면, 이 경우 기계 에이전트는 그것이 부 적절한 분류라고 결론을 내리고 다른 에이전트에게 부적절한 분류라고 말함으로써 정정한다. 이 분류는 감독 알 고리즘을 사용하는 기계 에이전트에 의해 수행된다. b. CES 레벨에서: 개체는 무언가를 유발하기 위해 상호 작용을 시작하기 전에 CU에 모인다. 섭스트레이트 특성 은 일부 개체가 공존하도록 허용하고, 일부 다른 개체가 공존하도록 허용하지 않을 수 있다. 예: 솔루션 플레이 아웃의 역학이 특정 개체가 공존하는 것을 허용하거나 허용하지 않는 특정 크기의 방. 큰 기계는 그 방에 맞지 않을 수 있지만, 컴퓨터는 그 방에 있을 수 있다. 이러한 제약은 주어진 CES 섭스트레이트의 속성 레벨에서 지 정될 수 있으므로 기계 에이전트가 올바른 종류의 추론을 도출할 수 있다. 추론은 인공 지능 기술을 사용하여 기계 에이전트에 의해 추론된다. c. 트리거 CES 레벨에서: 또 다른 일련의 제약 또는 SSA 주기의 적용은 허용된 상호 작용과 허용되지 않은 상호 작용에 관한 것이다. 물리적 섭스트레이트에서, 사람이 벽을 통과하여 걷거나 물 위를 걷는 것은 허용되지 않거 나 가능하다. 이러한 제약은 '트리거 CES' 레벨에서도 지정될 수 있다. 보다 차별화된 특성 레벨에서 제약을 탐색하기 전에 많은 제약 자체가 더 높은 유리한 지점에서 나타날 것을 주목할 수 있다. 예: 어떤 고체도 다른 고 체를 통과할 수 없다. 문제는 더 낮은 차별화 레벨에서 너무 많은 컴퓨팅 성능을 소비하지 않고 더 높은 유리한 지점 자체에서 해결된다. d. 확장된 CES 레벨에서: 마찬가지로, 원인 레벨과 결과 레벨에 관련된 SSA 주기가 있다. 이는 변경 드라이버 (DCD)의 드라이버와 동일하다. 예: 사람은 조준하고 발사할 수 있으나, 반대 방향으로는 불가능하다. 정보 계층의 섭스트레이트: 개체는 물리 계층이나 정보 계층에 있을 수 있다. 물리적 계층 개체는 변경 드라이 버(CD)라고 하며, 정보 계층 개체는 정보 드라이버(ID)라고 한다. 물리적 계층에 나타나는 것은 무엇이든지 정 보 계층에도 나타날 수 있다. 섭스트레이트 라벨링 원리는 정보 계층의 개체에도 적용된다. 두 계층들 간의 유 일한 차이점은 물리 계층의 개체만 트리거 기능에 영향을 미치고, 정보 계층 개체는 영향을 미치지 않는다는 것 이다. CU의 소유자는 물리적 계층과 정보 계층 모두에서 정보에 액세스할 수 있다. 정보 계층에서 자주 발생하 는 섭스트레이트의 몇 가지 예는 다음과 같다: 구조화된 텍스트, 구조화되지 않은 텍스트, 이미지, 테이블, 메 시지, 측정값 등. 유례 없는 것과 같은 기계에 권한 부여: NP-복잡성 문제(비결정론적 다항식)의 복잡성은 기계를 너무 심하게 강 타하여 슈퍼 컴퓨터조차도 식별하기 쉽지만 해결하기 쉽지 않은 특정 문제를 해결할 수 없다. NSL은 감지 및 액 추에이터 기능으로 기계에 권한을 부여하고 분석 엔진 및 추론 엔진의 계층을 연결함으로써 기계의 진정한 잠재 력을 열어준다. SSA 주기는 에이전트 시스템에 존재한다. NSL은 임의의 수의 수직 또는 수평 SSA 구조를 제공한 다. 이러한 SSA의 배포는 사람뿐만 아니라 기계의 추론 및 분석 기능을 단순화하는 데 도움이 된다. 일반적으로 기계는 인간보다 뛰어난 저장 및 계산 기능을 갖추고 있을 수 있다. 추론 엔진과 분석 엔진을 추가하면, 인간의 거동을 복제하거나 또는 경우에 따라 대량의 데이터를 처리하고 빠른 결정을 내리고 인간의 도움 없이 행동할 수 있는 능력으로 인간 지능을 능가함으로써 기계의 진정한 잠재력을 발휘하는 데 도움이 된다. NSL 구조는 많 은 인간 기능을 대체하고 잠재적으로 세계를 장악하는 기계로 이어질 수 있다. 기능적 비대칭성: 기능적 비대칭성은 기계 에이전트에 대해 이용 가능하지 않은 충분한 SSA 주기를 지칭한다. 정보 비대칭은 기계 에이전트가 이용할 수 없는 충분한 정보를 지칭한다. 인간은 줄을 읽고 줄 사이를 읽을 수 있다. 행간 읽기는 인간이 관련될 수 있는 문맥 정보를 지칭한다. 비슷한 문맥에서 인간의 이해에도 비대칭의 경우가 있다. 원자력 과학자는 핵 물리학을 이해하는 데 경찰관보다 더 나은 위치에 있을 수 있다. 범죄 현장에 대한 경험 많은 형사의 견해는 해당 주제와 그다지 관련이 없는 화학자의 견해보다 훨씬 나을 수 있다. NSL은 이전과는 전혀 달리 기계에 권한을 부여하기 위해 비대칭성을 해체하는 임무를 시작한다. 이러한 비대칭성은 추 론 엔진과 분석 엔진을 도입함으로써 체계적으로 제거된다. 기계는 줄만 읽을 수 있지만 일반 인간이 할 수 있 는 만큼 줄 사이를 읽을 수 있는 능력이 없을 수 있다. NSL은 기계에 권한을 부여하는 고유한 잠재력을 제공한 다. 기계는 정보 저장, 정보 검색, 대량 데이터 처리 및 응답 시간과 관련하여 인간에 비해 훨씬 우수하다. 인 간과 기계 사이에 정보 및 기능적 비대칭성이 연결되면, 기계는 추론의 척도를 유리하게 기울일 수 있다. 기계 는 인간과 마찬가지로 목적과 기대치를 제공받아야 한다. 그들은 행간을 읽을 수 있는 제3 의 눈을 가져야 하며, SSA 주기를 수행할 목적 의식을 가져야 한다. 그들은 많은 문맥 정보뿐만 아니라 예측 및 계획의 개념을 제공받아야 한다. 정보 비대칭: NSL은 400년의 과학으로부터 이익을 얻는다. '기술 솔루션'을 배경으로 '세상이 작동하는 방 식'(WWW)을 재해석한다. '세계가 작동하는 방식'에 대해 새로운 것을 발견한 것은 아니지만, 기술 솔루션을 다 루는 방법을 발명하였다. NSL이 내린 가장 중요한 결론 중 하나는 세상의 모든 것이 물리적이며 시간과 공간에 내재되어 있다는 것이다. 동시에 세상의 모든 것은 정보적이며, 물리적인 것과 정보적인 것의 차이는 단지 개념 적일 뿐이다. 한 걸음 더 나아가, 시간과 공간을 하나의 개체로 취급하여 정보를 제공하기도 한다. 세상의 모든 개체는 에너지를 동력으로 하여 끊임없는 변경을 겪는다. 에이전트는 자신에게 중요한 정적 및 동적 개체만 솔 루션 생태계에서 캡처한다. 에이전트(인간과 기계 모두)는 그들이 제공하는 방향성 에너지를 통해 개체와 개체 의 거동을 제어한다. 이것의 의미는 모든 '지시된 행동'이 '지시된 방식으로 정보에 따라 행동하는 것'과 동일 하다는 것이다. 많은 섭스트레이트와 그 안에 내장된 개체로 구성된 이 세계에서는, 하나의 개체가 상호 정보를 전달하는 상대편을 가질 수 있는 현실이 존재한다. 상호 정보는 하나의 개체를 보고 다른 개체에 대한 정보를 추론할 수 있는 정보이다. NSL은 이러한 개체를 표상적 개체라고 한다. 이러한 표상적 개체는 동일한 섭스트레 이트에 있거나 상이한 섭스트레이트에 걸쳐 있을 수 있다. 예: 사람과 조각상이 동일한 물리적 섭스트레이트에 앉아 있고 서로를 나타낼 수 있다. 표상적 개체가 상이한 섭스트레이트에 있는 경우가 더 자주 있다. 물리적 라 마는 물리적 섭스트레이트에 있을 수 있고, 단어 라마는 언어 섭스트레이트에 있을 수 있고, 이미지 라마는 서 로를 나타내는 이미지의 섭스트레이트에 있을 수 있다. 하나의 개체 표현에서 다른 섭스트레이트의 다른 개체로의 교차는 진리 값에 의해 확립된 동등성 원리에 따라 발생할 수 있다. 물리적 법칙을 존중하는 '시작 CES'로부 터 '종료 CES(GSI)'까지 유지되는 물리적 연속체의 유지를 보존하는 것은 이러한 동등성 원리이다. 개체가 상호 정보를 소유할 수 있고, 따라서 일부 다른 개체를 대표할 수 있는 품질을 획득할 수 있다면, 이러한 표상적 개 체 중 실재 개체라고 할 수 있는 자격은 무엇인가? 이에 대한 대답은 간단 명쾌하다. 그것은 이해 관계자(GSI) 의 요망과 솔루션 설계자의 선택에 관련되어 있다. 인간 에이전트와 기계 에이전트 사이에는 정보 비대칭이 존 재한다. 문장을 읽을 때, 인간 에이전트는 행간을 읽기 때문에 기계 에이전트보다 훨씬 더 많은 정보를 소유하 게 된다. 예: '코끼리가 숲속을 걷고 있다'라는 문장에서, 인간 에이전트는 기계 에이전트보다 훨씬 더 많은 정 보를 생성한다. 인간은 자신의 방식으로 코끼리의 크기, 숲의 본질, 풍경을 상상하고 있다. 마찬가지로, 인간 에이전트들 간에도 정보 비대칭이 있다. 예: 두 친구가 세 번째 공통 친구를 보면, 그들은 친구에 대해 같은 결 론을 내린다. 그러나 보다 차별화된 레벨에서, 그 친구에 대한 그들의 견해는 상당히 다를 것이다. 인간 에이전 트들 사이에서 이러한 종류의 비대칭을 '귀(ear) 사이 비대칭'이라고 부를 수 있다. 바로 이러한 원리가 '수직 적 CU 차별화' 레벨에서 정보 차이와 관련하여 적용된다. 동적 사용자 인터페이스: NSL은 자연 언어를 사용하여 솔루션을 개발하기 위한 플랫폼을 제공한다. NSL은 자연 언어와 수학적 구성을 사용하는 임의의 솔루션 개발을 가능하게 하며, 사용되는 수천 개의 자연 언어 중 어느 것에도 구애 받지 않는다. NSL은 솔루션 논리를 투명하게 만든다. 솔루션 민주화라는 비전에 따라, NSL은 동적 사용자 인터페이스(CDUI)를 개발하였고, 이 인터페이스는 이전 패러다임 그래픽 사용자 인터페이스로부터 동적 텍스트를 수용하는 인터페이스로 이동한다. 모든 솔루션은 문장과 단락으로 그 자체를 나타낸다. 도 10은 잠재 성과 현실 사이의 동적 전환의 예를 나타낸다. 또한 사용자 인터페이스는 자체 구성 가능하고 문맥상 동적으로 구동된다. 역동성과 문맥성은 함께 간다. 동적 솔루션 딕셔너리(DSD)는 솔루션 'BET'에 대한 분산 및 안전한 액 세스를 이해 관계자(인간 에이전트)에게 개별적으로 제공하기 위해 동적으로 자체 조정된다. 액세스 권한은 각 이해 관계자가 소유한 정보 및 결정 권한(IRDR)에 의해 관리된다. 서버 기능 대 검색 기능: NSL 솔루션은 투명하다. 솔루션 논리는 후드 위에 있다. 정보 형식의 솔루션 가용성을 통해 플랫폼 사용자는 솔루션, 솔루션 구성 요소 및 트랜잭션을 검색할 수 있다. 서버 기능은 도 11에 나타나 있다. NSL은 도 12에 도시된 것처럼 솔루션 클래스와 트랜잭션 클래스를 두 개의 서로 다른 계층 클래스로 본다. 트랜잭션은 솔루션 클래스에서 이벤트 도착으로 간주된다. 논리를 포함한 모든 솔루션은 연결된 클래스의 문자열로 표시되고, 이는 적격 멤버가 이벤트 형태로 도착할 수 있다. 따라서 NSL은 처리 기능이 거의 필요하지 않으며, 검색 원리에 더 많이 의존한다. NSL에서는 도 13에 나타낸 바와 같이 트랜잭션과 논리를 모두 검색할 수 있다. 서버 기능은 검색보다 훨씬 느리다. 서버 기능은 홉(hop) 기능과 같다. 데이터는 데이터베이스로부터 논리로의 홉을 통해 결합된다. 서버 기능은 다른 책을 참조하고, 데이터를 취득하고 주류 논리로 돌아온 다음, 또 다른 책으로 재 지향되어 다른 일부 정보를 참조하도록 한 것이다. 서버 기능은 프로그래밍 코드에 있는 논 리에 의해 결합된 데이터베이스 스키마(schema)에 따라 작동한다. 이것은 이전 패러다임에 많은 기술이 필요한 이유를 설명한다. 논리는 개발자가 작성한다. 데이터베이스 스키마는 데이터베이스 전문가에 의해 함께 정리된 다. 사용자 인터페이스는 UI 전문가에 의해 정리된다. 비즈니스 분석가는 고객 요구 사항을 이해한다. 그러나 중국인의 속삭임으로 인해 지식의 격차가 크다. 스키마는 때때로 매우 복잡할 수 있다. 데이터가 너무 많은 테 이블에 분산되어 육안으로 스키마를 보는 것만으로는 솔루션 논리를 쉽게 조합할 수 없다. NSL은 검색 원리를 기반으로 한다. NSL은 솔루션 논리를 어떤 트랜잭션 논리와도 다르게 취급하지 않는다. NSL은 차별화만 다룬다. 솔루션 클래스의 차별화는 트랜잭션의 추가 차별화로 이어진다. 트랜잭션은 솔루션 클래스에 달려 있다. 솔루션 마이닝(mining): 솔루션은 많은 섭스트레이트에 존재한다. 프로그래밍 언어, 비디오, 표준 운영 절차, 순서도, 이미지, 오디오 파일은 솔루션을 수용하는 섭스트레이트 중 일부이다. 솔루션 마이닝은 번역 서비스를 지칭한다. 솔루션 마이닝은 모든 섭스트레이트로부터 정보를 추출하고, 이를 자연 솔루션 언어로 변환하는 데 도움이 된다. 솔루션 마이닝에는 세 가지 유형의 환경이 있다: a. 충분한 솔루션 환경: 충분한 솔루션은 이산성과 진리 값을 유지하면서 각 구성 요소를 매핑하는 데 사용할 수 있는 문법 또는 구성이 있는 섭스트레이트를 나타낸다. b. 솔루션 부족 환경: 솔루션 부족 섭스트레이트는 솔루션 논리에 필요한 완전한 정보를 갖지 않는다. 비즈니스 프로세스 모델링 표기법(BPMN)과 같은 솔루션 섭스트레이트는 논리를 설명하거나 함께 정리하는 데 도움이 되는 상세한 레벨의 모든 정보를 갖지 않는다. 입도(granularity)와 세부 사항이 없다. c. 솔루션 래비시(lavish) 환경: 솔루션 래비시 섭스트레이트에는 논리를 확립하는 데 필요한 것보다 더 많은 정보가 있다. 섭스트레이트로서의 비디오는 각 프레임에 많은 정보를 포함한다. 비디오의 각 프레임을 통해 추출된 정보는 많은 중복(redundant) 정보를 발생시킨다. 따라서 비디오로부터 솔루션을 추출하려면 중복 정보를 제거하고 솔루션 관점에서 중요한 정보를 식별해야 한다. 한편, 여러 트랜잭션 정보로부터 알 수 있듯이, 개선 된 솔루션을 위한 여지가 있을 수 있다. 이 개념은 도 14에 표현되어 있다. NSL을 사용한 기계 학습: NSL 구조는 기계 학습 및 인공 지능과 같은 이전 패러다임의 새로운 기술에 원활하게 정렬하는 데 매우 적합하다. 기계 학습은 벡터 공간을 이용한다. 벡터 공간(선형 공간이라고도 함)은 벡터라고 하는 객체의 집합으로, 함께 추가되고 스칼라라고 하는 숫자로 곱할(\"축척\") 수 있다. NSL에서 벡터 공간은 중 요한 개체와 동일시된다. 실제 세계의 객체가 조합과 동일시되는 것처럼, 기계 학습은 벡터 공간을 사용하여 객 체를 규정한다. NSL 구성은 자연 언어를 기반으로 하고 현재 시점에서 기계가 감지할 수 있는 것을 훨씬 뛰어넘 는 감각적 경험에 관여하고 있기 때문에 개체 분류에 깊이와 유연성을 갖고 있다. 실제 세계의 객체가 조합과 동일시되는 것처럼, 기계 학습은 벡터 공간을 사용하여 객체를 규정한다. NSL 구성은 자연 언어를 기반으로 하 고 현재 시점에서 기계가 감지할 수 있는 것보다 훨씬 더 많은 감각 경험을 사용하기 때문에 개체 분류에 깊이 와 유연성을 갖고 있다. 인공 지능의 추론: 인공 지능은 인간과 마찬가지로 추론을 도출하는 데 장애물에 부딪혔다. 인간과 유사한 추론 기술을 기계에 구축하는 연구를 강화하기 위해 다양한 접근 방식이 취해졌다. 인공 지능에서는 원하는 목표로 이어지는 결론을 도출하기 위해 추론 규칙이 적용된다. 추론 규칙은 긍정 논법(Modus Ponens) 규칙, 부정 논법 (Modus Tollens) 규칙, 가상 삼단논법(Hypothetical syllogism), 선언적 삼단논법(Disjunctive Syllogism rule), 덧셈 규칙(Addition rule), 단순화 규칙(Simplification rule), 해결 규칙(Resolution rule) 등으로 구 성된다. NSL은 기계에서 인간의 거동과 추론 능력을 모방할 수 있는 최고의 구조를 가지고 있다. 내포된 SSA 주 기는 감지 및 액추에이터 기능과 함께 기계가 학습 및 도면 작업에서 우위를 점하도록 한다. NSL은 잠재적 클래 스와 잠재적 멤버를 허용하기 위해 클래스 레벨에서 제약을 부가할 자유를 제공한다. NSL 구조에는 5가지 레벨 의 제약이 있으며, 이는 시스템에 기존 시스템보다 확실한 우위를 부여한다. 인간은 수천 년 동안 자연 언어를 사용해 왔으며, 변경을 지시되고 제어된 차별화로 인한 가치 창출로 이해했으며, 일상적인(day-to-day) 문제를 해결하는 수단으로 수학을 광범위하게 사용해 왔다. 물리학의 제약, 에이전트 시스템, 자연 언어의 문법, 및 수 학의 제약은 기계에서 거의 인간과 같은 거동을 구축하는 데 도움이 된다. NSL은 일반 인공 지능을 조장하는 자 연스러운 구조를 가지고 있다. 우수한 기계 지원 솔루션을 향하여: NSL은 인간과 기계 사이의 장벽을 제거한다. NSL 구조를 통해 기계는 정보 에 기초한 예측을 하고, 더 현명한 조치를 제안하며, 정확한 결정을 내릴 수 있다. 기계는 패턴을 인식할 수 있 다. 인간 에이전트와 비교할 때, 기계는 더 효율적으로 작업하고 정보를 더 빠르게 처리하며, 정보를 잊어버리 거나 잃지 않고 방대한 양의 정보를 저장할 수 있다. NSL 구조를 통해 기계가 생명체와 동일한 방식으로 정보를 볼 수 있기 때문에, 지금 개발자 없는 개발이 가능하다. NSL은 모든 솔루션을 정보 형식으로 변환하므로, 기계 에 쉽게 입력할 수 있다. 우수한 훈련으로 기계를 무장하면, 인공 일반 지능의 진화가 가능해지며, 결과적으로 보다 정확한 예측, 결정 및 조치가 가능하다. 개발자 없는 개발: 프로그래밍 세계에서 대부분의 솔루션은 기본 CU(내장된 CU 포함) 레벨과 동등하게 처리된다. NSL의 중심 도그마는 '에이전트와 그들의 목적(소원)'이라는 컨텍스트에서 모든 솔루션을 '개체와 그 들의 관계'로 축소한다. 관계는 정적(CES)이거나 동적(ECES)이다. NSL은 ECES를 특별한 정보 클래스로 취급하므 로 '프로세스'가 필요하지 않다. 모든 에이전트는 개체(일부 특수 속성 포함)이며, 모든 목적은 에이전트가 선 택한 CES이다. 'CES' 또는 'ECES'는 개체의 관계에 관한 것이다. 개체가 조합되면, 각 조합은 느슨하게 결합된 결과이지만, 그 자체로 개체라고 할 수 있는 단일 개체이다. 따라서 가장 복잡한 조합 형태를 포함한 모든 개체 는 이진 상태로만 존재한다. 이는, 유리한 지점이 변할 수 있지만, 이진 개체라고 하는 기본 성질은 변경되지 않을 것이라는 것을 의미한다. 모든 유리한 지점에 있는 개체는 가장 가까운 이웃을 통해 서로 연결되거나 관련 된다. 예: 탐(Tom)의 친구가 5집 떨어진 곳에 살고 있다면, 탐은 다른 4집을 건너지 않고 그곳으로 갈 수 있다. 개체 관계는 솔루션과 관련하여 개체의 문맥상의 결합(contextual-coming-together-of-entities)이나 다름없다. 솔루션은 소원성취나 다름 없고, 이는 바로 '선택된 CES'이다. DLD는 모든 개체를 선택한 CES(GSI)에 자동으로 연결한다. 글로벌 의도 진술(Global Statement of Intent, GSI)의 컨텍스트에서 잠재성 개체의 자동 선택은 구조화된 다음의 3단계 프로세스를 따른다. a. LSI(로컬 의도 진술)의 컨텍스트 선택 b. CD(변경 드라이버)의 컨텍스트 선택 c. DCD(변경 드라이버의 드라이버)의 컨텍스트 선택. DLD는 문맥상 검색을 수행하고 GSI에 의해 설정된 목표를 충족하는 올바른 종류의 문맥상 개체를 식별할 수 있 는 능력을 갖는다. 이 과정에서 DLD는 모든 문맥상 개체를 결합한다. DLD는 기계 학습 기술을 사용하여 자동화 된 솔루션 구축 프로세스를 가장 효율적으로 만든다. NSL 프레임워크는 이를 최대한 효율적으로 처리할 수 있는 기반을 마련한다. DLD 엔진은 솔루션 콘텐츠를 처리하기 위해 NLP, ANN, 가장 가까운 이웃의 기술/구성 요소를 사용한다. NLP 기술은 명명된 개체 인식, 단어 명확화, 개체 동의어 구성 요소를 포함한다. ANN 기술은 확률 모 델, 문장 인코더, 심화 학습(Deep learning) 구성 요소를 포함한다. DLD 엔진은 다양한 순열 및 조합에 대한 확 률 모델을 사용하여 예측한다. 분석 엔진 및 로봇 프로세스 자동화: 기본 CU에 추가된 내포된 SSA 주기의 여러 레벨이 있을 수 있다. 유일한 요구 사항은 조치를 취할 가치가 있는 추가 차별화 정보가 있다는 것이다. 더 높은 레벨에서 사용 가능한 부분 정보도 조치를 취할 수 있다. 예: 라마가 야채를 가져온 경우, 내포된 SSA 주기는 물리적 계층에 '야채'를 배치 하고 요리할 수 있다. 라마는 내포된 SSA 주기의 정보 계층에 '잔여 정보'로 배치될 수 있다. 내포된 SSA 주기 의 결과가 정보 계층 레벨에서 분석 및 통찰력의 형태로 생태계의 각 CU에 공급되는 경우, 분석 엔진으로 솔루 션에 전원을 공급하는 것과 같다. 대안으로, 내포된 SSA 주기의 결과가 물리적 계층에서 기계 에이전트가 소유 한 CU에 전원을 공급하는 경우, 로봇 프로세스 자동화(RPA)와 관련된다. 물리적 계층에 관련된 액추에이터가 없 다면, RPA는 '컴퓨터 섭스트레이트'의 사물에 영향을 미치는 소프트웨어 봇 종류(bots' kind)가 될 것이다. 연 관된 액추에이터가 있는 경우, 그 정교함에 따라 RPA는 '물리적 섭스트레이트'에 영향을 미치는 것으로 확장될 수 있다. 분석 엔진은 서술적(descriptive) 통계 및/또는 추론 통계 기술을 사용하여 데이터를 처리한다. 분석 엔진은 인공 지능 기술, 기계 학습 기술, 자연 언어 처리 기술, 심화 학습 기술 및 공지의 기술을 사용함으로써, 데이터(빅 데이터)에 대한 서술적, 진단적, 예측적 및/또는 규범적 분석을 수행한다. 도 15는 분 석 엔진의 예를 나타낸다. 또한 NSL은 매우 강력한 분석 엔진을 제공한다. 이는 개체와 CU를 가능한 한 세분화 하여 소스에서 정보를 처리할 수 있기 때문에 가능하다. eCU 및 nCU는 정보를 사용하고 전례 없는 통찰력을 생 성할 수 있는 훨씬 더 세분화된 기능을 제공한다. 분석 엔진 기능과 RPA의 차이점은 NSL에서 매우 미미하다. 분 석 엔진은 필요에 따라 자체 소비 또는 솔루션 생태계 전반의 전파에 대한 통찰력을 생성한다. RPA는 한 단계만 더 나아가면 된다. 실행될 '물리적 계층'에 배치되는 통찰력이다. 이러한 작업은 인간의 노력을 최소화하고 솔 루션의 품질을 향상시키기 위해 기계 에이전트에 의해 구동된다. 정보 권한 및 결정 권한: 이름이 나타내는 바와 같이 정보 권한은 문제의 개체에 관한 정보에 대한 액세스를 제 공한다. 예: 에이전트는 '펜의 존재 여부'를 알 수 있는 액세스를 갖는다. 개체에 대한 정보 권한만 있는 경우, 해당 개체는 주어진 에이전트가 소유한 CU의 정보 계층에 있다. 결정 권한이 있는 경우, 에이전트는 개체에 영 향을 미칠 수 있다. 예: '펜'의 경우, 에이전트는 이를 사용하여 솔루션 설계에서 제공하는 내용을 쓰거나 수행 할 수 있다. 이러한 개체는 지정된 에이전트가 소유한 CU의 물리적 계층에 있다. 위에서 언급한 정보 권한 및 결정 권한의 예는 도 26에 나타나 있다. 에이전트들 간의 관계는 화살표를 통해 시각적으로 지정될 수 있다: 정보 오른쪽 화살표 및 결정 오른쪽 화살표 는 얇은 화살표와 굵은 화살표로 구분할 수 있다. A) 일 방향 화살표: 화살표가 'A'로부터 나와서 화살표 끝이 'B'를 가리키는 것으로 표시되면 일 방향 화살표이다. 이것이 의미하는 바는 'B'가 가진 정보 권한과 결정 권한 이 무엇이든 그 권리도 'A'에게 전달되지만 그 반대는 전달되지 않는다는 것이다. 'B'에 대한 결정 권한을 갖는 다는 것은 'A'가 'B'로 하여금 스스로 할 수 있는 권한이 있는 모든 것을 'B'로 하여금 하도록 강요할 권한이 있음을 의미한다. 예: B가 탁자 한 귀퉁이에 문진을 놓는 힘이 있다면, 'A'는 B에게 탁자 귀퉁이에 문진을 놓도 록 강제할 수 있다. 정보 권한 및 결정 권한의 일 방향 화살표 예는 도 27a에 나타나 있다. B) 양방향 화살표: 이 경우 A와 B를 연결하는 화살표는 양쪽 끝에 포인터가 있다. 이것이 의미하는 바는 A가 B의 모든 정보를 가지 고 있고, B가 주어진 일을 하도록 강제할 수 있는 능력(결정 권한이 있는 경우)과 그 반대의 경우도 있다는 것 이다. 정보 권한과 결정 권한의 양방향 화살표의 예는 도 27b에 나타나 있다. 제어된 변경: NSL에서 모든 변경은 변경 유닛(CU)에서 발생한다. 모든 CU는 제어된 변경 사항을 처리한다. 변경 은 CU로 들어오는 이벤트의 형태이고, 그것이 유발하는 이벤트의 형태로 CU로부터 나간다. 변경은 항상 잠재성 상태와 현실 상태 사이를 전환하는 개체의 형태이다. 또한 현실 상태가 잔류 정보(최소 멤버십 기준을 충족하는 것 이상의 정보)를 여러 번 전달하는 경우도 있다. 예: 한 사람이 클럽 멤버인 경우, 멤버십 카드를 소지하고 있으면 입장할 수 있다. 그러나 그/그녀가 입장할 때마다, 멤버십 카드에 관한 정보보다 훨씬 더 많은 정보를 클럽에 가지고 들어갈 것이다. 그/그녀는 자신의 키, 피부색, 체중 등을 가지고 다닌다. 이 추가 정보는 NSL에 서 잔여 정보로 알려져 있다. 이 예는 도 25에 나타나 있다. 변경, 정보 소비 및 생성, 입력 및 출력, 개체 상태 변경은 본질적으로 모두 동의어라는 것도 주목할 가치가 있 다. 왜냐하면 정보는 '구별되고 불연속적인' 모든 것이기 때문이다. 구별되고 불연속적인 것은 모두 개체이다. 에너지는 개체의 상태를 변경한다. 이것은 모두가 잘 알고 있는 원인과 결과의 원리와 같다. 에이전트 세계에서, 솔루션 생태계는 솔루션의 컨텍스트에서 중요한 개체만 캡처하고 처리한다. 기술 용어에서, 이들은 일반적으로 입력 및 출력이라고 한다. 위에서 언급한 '제어된 변경'은 컨트롤러의 존재를 지칭하고, 해당 컨트 롤러는 에이전트이다. 해당 에이전트는 기계 에이전트 또는 인간 에이전트일 수 있다. 결론은 모든 변경 유닛이 에이전트에 의해 구동되며, 적어도 하나의 에이전트가 제어된 변경을 구동하기 위해 변경 유닛에 존재한다는 것 이다. 변경 유닛은 중요한 개체를 전달한다: 변경 유닛에 속하는 개체는 이를 소유한 에이전트(들)에 액세스 가능하고 이를 소유한 에이전트(들)에 의해 제어 가능하다. 개체에 대한 이러한 액세스 및 제어는 정보 권한 및 결정 권 한을 통해 지정된다. 이러한 권리는 에이전트와 관련된 개체 모두에 의해 '속성 값'으로서 전달된다. 에이전트들 사이의 관계는 또한 IRDR을 통해 특정될 수 있다: 에이전트가 개체를 소유하고 개체가 에이전트에 의해 소유되는 것은 당연하다. 그러나 솔루션 생태계에는 서로 다른 역할을 수행하는 많은 에이전트가 있다. 이 러한 역할 소유자 간의 관계는 IRDR을 통해 지정할 수도 있다. 에이전트가 다른 에이전트나 개체에 대한 의사 결정 권한을 가지고 있는 경우, 정보 권한 없이는 의사 결정 권한을 행사할 수 없으므로, 정보 권한도 가지고 있음을 의미한다. 그러나 에이전트나 개체에 대한 결정 권한 없이 에이전트가 정보 권한을 갖는 경우가 많이 있 다. CU는 잠재성과 현실의 노드의 로컬 네트워크이다. 현실은 잠재성(또는 말하자면 클래스)의 적격 멤버이다. IRDR 은 잠재성 및 현실 개체에 동일하게 적용된다. 기본적으로 IRDR의 원리는 개체가 잠재성 상태 또는 현실 상태에 속하는지에 관계없이 동일하다. 잠재성 또는 클래스 개체는 솔루션 설계자에 의해서 처리된다. 솔루션 설계 권 한을 소유한 사람이 해당 권한을 행사할 수 있다. 논의한 바와 같이, 모든 솔루션은 차별화된 클래스에 관한 것 이다. 클래스 레벨 차별화는 클래스 레벨 CES 및 ECES 구성을 통해 발생한다. 잠재성 또는 클래스 레벨 차별화는 수평 및 수직 모두에서 발생한다. A) 잠재성 개체가 잠재성 CES 또는 ECES로 결합될 때 수평적 차별화가 발생한다. B) 수직적 차별화는 잠재성 개체가 여러 레벨을 통해 더욱 차별화될 때 발생한다. 이 수직적 차별화는, 하강이 트랜잭션 클래스에 닿을 때까지 클래스로부터 하위 클래스로, 하위 하위 클래스 등으로의 하강을 통해 달성된다. 트랜잭션 이벤트가 발생하는 트랜잭션 클래스(작업)에 있다. 구성에서 NSL은 또한 '트랜잭션 클래스'로부터 '하위 트랜잭션' 클래스로의 추가 하강을 제공한다. 이러한 하위 트랜잭션 클래스는 트랜잭션 소유자에 의해 생성될 수 있다. 클래스의 관점에서, 하위 클래스는 멤버이다. 하위 클래스의 관점에서, 하위 하위 클래스는 멤버이다. 이 하강은 최종 트랜잭션 현실이 발생할 때까지 계속될 수 있다(작업 발생). 잠재성(클래스)이든 현실(멤버)이든 모든 개체는 정보이다. 차별화가 본질적으로 수직이든 수평이든 가 장 가까운 이웃 개념을 따른다. IRDR의 연속체는 깨질 수 없으며, IRDR은 개체가 잠재적 개체인지 현실 개체인지에 대해 구애 받지 않는다. IRDR의 원리는 동일하다. 모든 개체에 대해 항상 IRDR 사양이 있어야 한다. 그들은 동일한 가장 가까운 이웃 원 리를 고수한다. 클래스/잠재성 및 멤버/현실 관계는 깨지거나 다른 기반에서 취급될 수 없다. 클래스 및 트랜잭션은 상호 연결된 개체 및 관계의 중단되지 않은 체인이다. 이들은 동일한 기반에서 취급되어 야 한다. 기본 NSL 프레임워크는 노드의 3차원 네트워크를 제공한다. 솔루션 설계자가 IRDR에 제공할 수 있는 모든 자유도를 사용할 수 있다. 즉, 계층 구조는 필요가 아닌 특정 선택에서 발생한다. IRDR이 일 방향 화살표 인 경우 계층 구조가 나타날 수 있다. 그러나 모든 종류의 3차원 네트워크 구조와 정보 흐름은 필요에 따라 사 용될 수 있다. IRDR의 양도 또는 위임: 솔루션 설계자는 IRDR을 솔루션 생태계 내의 에이전트에 양도하거나 위임할 수 있다. 양도는 솔루션 설계자에 의해 지정된 제약 내에서 정보 권한을 다른 에이전트에게 전달할 수 있는 정보 권한이 있는 에이전트와 관련된다. 위임은 솔루션 설계자에 의해 지정된 제약 내에서 다른 에이전트에게 해당 권한을 전달할 수 있는 결정 권한이 있는 에이전트와 관련이 있다. 이러한 제약은 제한된 시간 동안 에이전트 수를 제 한하기 위해 양도 또는 위임이 발생하도록 하는 것과 관련될 수 있다. 이벤트 기반 양도 또는 위임일 수도 있다. IRDR의 양도 및 위임은 도 28에 나타나 있다. IRDR에 대한 조건부 잠재성: 솔루션 설계자는 또한 조건부 잠재성을 제공할 수 있다. 즉, 주어진 경우, 에이전 트의 IRDR은 문맥적으로 변경될 수 있다. 이는 매우 다양한 솔루션 설계를 제공하는 고유한 기능임이 입증될 것 이다.추론 엔진: NSL은 솔루션이 작용할 수 있는 차별화된 클래스를 중심으로 하는 특별한 클래스의 정보임을 인식한 다. '정보'라는 단어는 자연 언어의 섭스트레이트에 있는 정보라는 제한된 문맥에서 사용되고 있다. 자연 언어 는 '의미 중심'이다. NSL은 솔루션 중심이다. NSL은 자연 언어의 특수 클래스이므로 자연 언어의 하위 집합이다. 자연 언어는 세상의 모든 것을 취급하고 솔루션으로 이어지는지 여부에 대해 중립적이다. NSL은 솔루 션만을 취급한다. NSL은 자연 언어(숫자와 수학이 함축됨)에서 중요한 개체를 선택한다. NSL은 행동할 정보를 지속적으로 찾고 있기 때문에, '정보'와 '그 정보가 전달하는 의미'에 크게 의존한다. 토큰화(tokenization) 방 식, 룰 기반 POS 태깅 방식, 확률적 POS 태깅 방식, 마르코프(Markov) 모델, 은폐 마르코프 모델 방식 등을 이 용하는 추론 엔진은 정보에 대한 올바른 의미 도출에 특화되어 매우 중요한 역할을 한다. 정보는 문맥적으로 매 우 많은 수의 섭스트레이트에 상주한다. '물리적, 생물학적, 이미지'는 쉽게 식별할 수 있는 몇 가지 가능한 섭 스트레이트 중 일부에 불과하다. 각 섭스트레이트에는 그것이 유도되는 고유한 특성, 원리 및 제약을 갖는다. 개체는 또한 자신이 속한 섭스트레이트의 특성에 의해 구속된다. 각 섭스트레이트가 주도하는 제약과 원리는 종 종 명확하다. 그러한 각각의 섭스트레이트 원리는 정적으로 차별화된 클래스 레벨 개체와 동일하다. 예: 모든 몸체는 중력에 의해 구속되어 있다. 이 클래스 레벨 사양에 맞는 몸체들만이 멤버가 될 수 있다. 추론 엔진이 수행하는 모든 것은 개체가 있는 적용 가능한 각 섭스트레이트에 내포된 SSA 주기를 연결하는 것이다. 모든 솔 루션 클래스 또는 클래스들은 일반적으로 NSL 개체 잠재성과 동일하다. SSA 주기가 이러한 섭스트레이트 레벨에 서 실행될 때마다 멤버십 기준 충족 여부를 확인한다. 도 16은 추론 엔진의 예를 나타낸다. NSL의 추론 엔진이 의존하는 몇 가지 제약과 원리는 다음과 같다: a. 물리학의 제약: 물리적 섭스트레이트는 네 가지 기본 힘과 같은 물리 법칙에 의해 지배된다. 예를 들어: 문 장에서 사람이 지상으로부터 10층으로 점프하였다고 명시한 경우, 물리적 섭스트레이트 제약은 문장을 비논리적 인 것으로 분류한다. b. 생명 과학의 제약: SSA 주기는 자연 선택 시스템이 모든 레벨, 모든 유리한 지점에서 발생하는 방식으로 설 정되고 연결된다. SSA 주기에서 어떠한 중단도 기계가 이해할 수 없는 효과를 생성한다. 예를 들어, 150년 이상 의 인간 수명에 대한 알려진 증거가 없는 경우, 생명 과학을 포함하는 솔루션은 다른 중요한 파라미터 중에서 연령 제약에 관한 현재의 개념을 갖추고 있다. c. 수학의 제약. 예를 들어, 수학에는 공리(AXIOMS)가 있다. 이러한 공리는 클래스 레벨 진술이다. 삼각형의 모 든 내각의 합은 180°이다. 마찬가지로 원의 둘레는 2πr이다. 시스템은 수학의 모든 알려진 제약을 지속적으로 확인한다. d. 자연 언어의 제약: 자연 언어의 모든 문장에는 동사가 있어야 하며, 모든 고유한 개체는 명사로 식별되고, 형용사는 명사만 수식할 수 있으며, 부사는 동사를 수식하는 제약 중 일부이다. e. NSL 및 에이전트 시스템의 제약: SSA 주기는 에이전트 시스템을 위한 것이며, 에이전트는 목적 주도형이며, 지속적으로 보다 바람직한 상태로 이행하려고 하고 있다고 설명한다. 에이전트, 일반 개체 및 목적은 분리할 수 없으며, 모든 변경 드라이버의 도착은 변경을 가져오는 데 필수이며, 에이전트 없이 변경을 트리거할 수 없으며, 개체는 적절한 속성에 연결되어야 하며, 변경 유닛은 올바른 에이전트에 연결되어야 하고, 모든 변경이 시공간에서 발생한다. f. 확률의 원리: SSA 주기는 현실에 더 많은 빛을 비추는 추가 정보를 생성한다. 좀 더 세분화하면, 개체가 있 는지 없는지 맨 아래에 있는 수학적 구성만 남는다. 확률은 0과 1 사이일 수 있다. 휘발유 없이 자동차가 달릴 가능성은 얼마나 될까요? 항공편의 기술적 문제로 인해 1시간 지연되는 경우, 제임스가 제 시간에 런던에 도착 할 수 있는 가능성은 얼마나 될까요? 이러한 질문에 대한 답변은 고급 계획 및 최적화 목적과 매우 관련이 있다. 불확실성의 정량화는 확률 공리, 조건부 확률, 조건부 독립 확률, 확률론적 추론(즉, 관찰된 증거가 주어 진 질의 명제에 대한 사후 확률 계산) 등과 같은 확률 원리를 적용함으로써 수행된다. 전체 공동 배포는 모든 질문에 대한 답변을 도출할 수 있는 \"지식 기반\"으로 사용된다. g. 상관 관계의 원리: 상관 관계는 다른 개체에 대한 개체의 가용성을 지칭한다. 상관 관계는 -1과 1 사이에서 달라질 수 있다. 매우 강한 상관관계가 있거나 상관관계가 전혀 없을 수 있다. 과거 또는 현재 데이터의 가용성 은 두 개체 들간의 관계의 강도와 방향을 이해하는 데 도움이 될 수 있다. 이력 데이터를 기반으로 하는 많은 사용 사례가 있을 수 있다. 여름철과 제설 기계는 어떤 상관관계가 있을까요? 4/5의 CGPA와 더 높은 학업을 선 택하는 학생 사이의 상관관계는 무엇일까요? 또한, 누군가가 다른 개체에 대한 지식을 기반으로 한 개체에 대해 무언가를 추론할 수 있는 경우, 개체는 연관되거나 상관된 것으로 간주된다. 상관관계는 양 또는 음일 수 있다. 상관 관계는 도 23에 표시되어 있다. 임의의 두 개체 간의 상관 관계는 상관 계수로 표현되는 -1 내지 +1 범위의 정도 문제이다. 예: 고객 장소까지의 거리를 알면, 제품을 배송하는 데 걸리는 시간과 그 반대의 경우에 대 해 대략적인 결론을 도출할 수 있다. 말을 보면, 우승 가능성을 알 수 있다. 회사를 알면 해당 연도에 얼마나 많은 수익을 창출할 수 있는지 알 수 있다. 트리거 CES를 보면 주기 시간을 알 수 있다. 개체에 대한 정보가 없 는 경우, 상관 관계는 사용 가능한 다른 정보를 기반으로 더 많은 정보에 입각한 결론을 도출하는 데 도움이 될 수 있다. '배달인'이 '확실한 배송'과 높은 상관관계가 있다는 것을 알게 되면, 시스템은 더 민감한 배송을 위 해 그 사람을 선택할 가능성이 높다. 상관 계수는 상관 관계가 있는 개체에 대한 개체의 속성 값으로 표현될 수 있다. 이러한 개체는 개별 개체 또는 CES일 수도 있다. 이것은 에이전트의 속성으로 개체에 IRDR을 연결하는 것 과 같다. 상관 계수의 경우, NSL은 '상관 속성 분기', 개체 및 해당 계수를 지정한다. 점점 더 많은 트랜잭션 데이터 또는 정보가 도착함에 따라 지속적으로 업데이트된다. 이러한 값은 대부분 배치 모드에서 생성될 수 있 다. 상관 관계에 대한 가장 최근 트랜잭션의 영향이 높은 경우, 실시간 평가에 의존할 수 있다. 통계적 유의성 이 있는 경우에만 이러한 상관 속성 값을 유지하도록 강제될 수 있다는 것은 말할 필요도 없다. 대부분의 경우 상호 정보가 있어야 한다. 예: '토요일'에 '생산'에 대한 상관 계수가 있는 경우, '생산'은 '토요일'에 대한 상 관 계수를 가질 수 있다. 또한 상관 관계 속성 값 생성은 실제로 중요한 항목의 영향을 받는다. 뛰는 심장과 사 무실에 출근하는 사람 사이의 상관관계는 높을 수 있지만, 그 정보는 부가가치가 아니다. 가치의 '개체-상관'과 관련하여 DSD에 예약된 개체 기반을 유지하는 것이 좋다. 이렇게 하면 새로운 솔루션이 개발될 때마다 이러한 가치의 상관 관계를 식별해야 하는 추가 노력이 줄어든다. h. 회귀 분석의 원리: 상관 관계와 회귀 분석 모두는 개체 간의 관계를 취급한다. 회귀 분석은 하나 이상의 독 립 변수 값이 주어진 종속 변수 값을 예측하는 데 중점을 둔다. 회귀 분석은 도 24에 나타나 있다. 회귀 분석의 적용 중 하나는 LSI를 '종속 변수'로 처리하고, 다른 모든 변경 드라이버(CD)를 독립 변수로 처리하는 것이다. 회귀 공식은 트리거 CES에 연결될 수 있다. CU가 제품 배송을 처리하는 경우, 배송의 파라미터 값에 대해 보다 정확한 예측을 할 수 있다. i. 개체들 간 거리: 모든 개체는 다른 모든 개체와 관련된다. NSL은 차별화 원리에 따라 작동한다. NSL은 솔루 션 생태계에 참여하는 모든 잠재적 개체에 대한 이진 트리 구조를 가지고 있다. 모든 잠재성은 클래스이다. 클 래스는 수직 또는 수평이 될 수 있다. 거리는 한 개체를 다른 개체와 분리하는 이벤트의 수를 지칭한다. 거리는 또한 솔루션이 작동하는지 여부에 대한 제약을 결정하는 데 중요한 역할을 한다. 예를 들어, 원하는 상태가 10 개 이벤트로 떨어져 있는 경우, 솔루션 설계자는 바로 다음 변경 유닛에 원하는 상태를 배치할 수 없다. 시스템 은 설계자에게 시정 조치를 취하도록 상기시킬 수 있다. j. 질문 원리: 솔루션은 정보 제공이므로, 솔루션 설계자에게 고유한 기회를 제공한다. 설계자는 구조화된 방식 으로 답변을 추출하기 위해 일련의 질문을 할 수 있다. 특정 질문에 대한 답변을 얻으면, 현재 현실에 대한 지 식이 확고한 기반을 유지한다. 질문을 기반으로, 바로 다음 상태에 대한 결론을 내릴 수도 있다. 예를 들어, 누 군가 자신의 현재 위치에 대해 질문을 받았고 \"아일랜드\"라고 대답했다면, 이 사람은 한 시간 안에 미국에 있을 가능성이 낮다. 마찬가지로 최근 답변에 대해 임의의 모순을 확인할 수도 있다. 자연 선택 프로세스는 추론 엔진이 제시한 단순화된 규칙을 적용함으로써 매우 정교해진다. 구조화된 추론 메커 니즘을 적용하면 기계가 정보에 입각한 결정을 내릴 수 있다. 기계는 훨씬 더 많은 데이터를 처리하고 인간보다 수백만 배 빠른 속도로 정보를 처리할 수 있다. 일상 생활에서, 인간은 선택을 필터링하고 결정에 도달하기 위 해 수학, 물리학 또는 자연 언어로부터 파생된 학습을 적용하지 않을 수 있다. 이것은 때때로 인간에게 항상 도 움이 되지 않는 결정을 내릴 수 있다. NSL의 추론 엔진은, 모든 노이즈를 제거하고, 기계 시스템을 조정하여, 이러한 모든 분야의 완전한 지식을 가진 인간과 같이 결정을 내리는 데 중요한 개체를 처리한다. 물리학이나 수 학 또는 에이전트 시스템에 제시된 법칙은 그 수가 적다. 그러나 과학에 의해 이해되고 있는 바와 같이, 이러한 제약과 원리는 주변에서 일어나는 모든 일을 설명하는 데 도움이 된다. 정보를 이용할 수 없기 때문에 복잡성이 발생한다. SSA는 여러 유리한 지점에서 운영되고 있다. 인체에서도 SSA는 핵 레벨, 세포 레벨 및 신체 레벨에 이르기까지 작동하고 있다. SSA의 분산에 의해, 복잡함을 단순하게 만든다. SSA를 추가하면 더 많은 정보가 생 성된다. 이로 인해, 방대한 양의 데이터가 분석과 의사 결정에 이용할 수 있게 되고, 복잡함의 레벨이 저하된다. 구조화는 일을 단순화하는 데 도움이 된다. 구조화된 추론 메커니즘을 적용하면 기계가 정보에 입각 한 결정을 내릴 수 있다. 자연 선택 과정은 NSL 분석 엔진과 NSL 추론 엔진이 제시한 단순화된 규칙을 적용함으 로써 매우 정교해진다. 분석 엔진과 추론 엔진은 서로 밀접하게 연결되어 있다. 추론 엔진은 기계가 인간과 같 은 방식으로 사물을 해석할 수 있도록 의미를 제공한다. 분석 엔진은 분석 및 의사결정 지원 시스템을 위한 툴 (tool)을 제공한다. 솔루션을 지원하고 개선하기 위해 실시간으로 성능을 측정하는 데 도움이 된다. NSL은 고유 의 간소화된 의사결정 지원 메커니즘에 의해 추론에 걸리는 시간을 크게 줄인다. 이러한 원리를 기반으로, NSL추론 엔진은 인간 에이전트와 기계 에이전트 간의 정보 및 기능적 비대칭성을 완전히 없애는 추론을 도출할 수 있는 잠재성을 가지고 있다. 추론 엔진은 추론 또는 결론에 도달하거나 특정 솔루션을 도출하기 위해 지식 기반 으로부터 정보 또는 지식을 얻는다. 추론 엔진은 특정 솔루션을 도출하기 위해 순방향 연결 또는 역방향 연결 방법을 사용한다. 추론 엔진은 심화 학습 알고리즘을 사용하여 사실 및/또는 규칙으로부터 결론 또는 추론을 도 출한다. 지식 베이스에 저장된 지식이나 사실은 데이터베이스의 형태로 유지된다. 솔루션을 구축하려면 솔루션 아키텍트가 솔루션에 특정한 데이터를 저장하고 검색할 데이터베이스가 필요하다. 이 데이터베이스는 솔루션 아 키텍트가 제공하는 개체 및 속성의 메타 데이터를 저장함으로써 NSL 플랫폼에 의해 제공된다. 솔루션을 실행/실 시하는 동안, 데이터는 솔루션 설계자가 의도한 정확한 형식으로 최종 사용자로부터의 입력으로 사용된다. 질문 이 올 때마다 데이터는 알려진 방법을 사용하여 데이터베이스로부터 액세스 및/또는 검색된다. 질문 기반 액세 스는 SQL(Structured Query Language) 및/또는 NoSQL(Not only Structured Query Language)로 구성된다. 지식 기반은 또한 그래프 구조의 형태로 저장되며, 여기서 데이터는 알려진 수단을 사용함으로써 그래프로부터 액세 스 및/또는 검색될 수 있다. 일반 동등성 행렬(GEM): NSL은 세계가 작동하는 방식(WWW)의 원리를 기반으로 한다. NSL은 과학의 발견으로부터 얻어진 이해를 통해 이러한 현실을 포괄적으로 다루고 있다. 그것은 매우 확 고한 기반에 있는 글로벌 지식 기반을 다룬다. 에이전트의 관점에서 본 WWW는 개체와 개체의 관계에 관한 것이다. 개체와 변경의 역학은 NSL 매핑에서 포괄적으로 다루어진다. NSL의 구성은 세계에 솔루션 기회를 제공하는 솔루션 논리 및 지식의 본체를 총체적으로 나타낸다. 일반 동등성 행렬(GEM)은 임의의 기존 솔루션 프레임워크 및 NSL 구성 요소와 관련하여 솔루션 및 해당 구성 요소를 동일시하는 데 의존한다. 그 과정은 '차세대 솔루션 프레임워크 구축에 있어 NSL의 순수성 보존 원리'에 의해 주도된다. 솔루션이 현재 어디에 있든 관계없이 그들 은 모두 개체와 해당 관계로 구성된다. 솔루션의 모든 개체는 중요하고, 고유하며, 물리적이며, 동시에 정보를 제공하는 개체이다. 모든 제어 정보는 먼저 의미를 제공하기 위해 표현되고 확장하여 솔루션을 제공한다. 이것 은 7,000개의 필연성의 자연 언어 모두와 동일하며, '의미'만 을 취급한다. NSL의 경우, 거주지와 표현 방식에 관계없이 다루는 것은 '솔루션'이다. GEM에는 다음과 같은 하위 집합이 있다: k. 솔루션 동등성 행렬(SEM): i. 구문 레벨 동등성: 이 동등성 행렬은 NSL의 구문 구조가 기존 솔루션 프레임워크 전반에 걸쳐 대부분의 요 구 사항을 충족해야 한다는 것을 확립하기 위해 준비되었다. 이 동등성을 확립하는 과정에서, NSL은 임의의 기 존 솔루션 프레임워크에서 구조에 대해 일치하는 요소가 없을 때마다 동등한 구조를 제공하였다. 이것은 NSL 프 레임워크의 구성으로 임의의 상황을 처리하는 NSL의 능력을 향상시켰고, NSL 구성을 훨씬 더 성숙하고 포괄적으 로 만들었다. ii. 의미론적 레벨 동등성: 이 동등성 행렬은 NSL의 관행이 다른 기존 솔루션 관행에 매핑됨을 확립하기 위해 준비된다. 이를 통해 기존 솔루션의 격차를 확인하고 'NSL로 동일하게 작동'할 수 있는 기회를 제공하였다. l. 프로그래밍 언어 동등성 행렬(PLEM): 이 동등성은 Translation-360(T360) 이니셔티브의 컨텍스트에 있다. NSL은 개체 기반 모델이다. 중요한 것은 솔루션의 컨텍스트에서 개체와 개체의 관계이다. 구별되고 불연속적인 것은 모두 개체이다. 느슨하게 결합된 개체는 자체 개체 상태를 갖는 CES를 발생시킨다. 개체는 고유(단어 또는 기호로 표시됨)하거나 동일(숫자로 표시됨)하다. 세계의 모든 별개의 상태는 공간과 시간의 물리적 현실(그 자 체가 섭스트레이트로 취급됨)에 내재되어 있다. 그들이 속한 섭스트레이트에 관계없이, 세상의 모든 구별되는 것들은 또한 본질적으로 정보로 간주될 것이다. 언어는 그 자체로 섭스트레이트이다. 모든 물리적 사물은 '동등 성 원리'를 확립하는 이 섭스트레이트에서 카운터파트를 통해 표현될 수 있다. 솔루션은 개체 클래스와 해당 관 계를 선택하고, 솔루션으로 이어지는 변환 경로가 생성된다. 솔루션에서 모든 것에는 자격을 갖춘 멤버가 트랜 잭션 시간에 도착하는 클래스 레벨 개체가 있다. NSL은 임의의 종류의 솔루션에 중요한 개체 및 관계를 선택할 수 있는 프레임워크를 제공한다. 이 프레임워크는 세상이 작동하는 방식 원리를 기반으로 한다. 세계의 작용은 과학에 의해 뒷받침되는, 수년에 걸친 지식의 확장으로 인해 매우 잘 이해되고 있다. NSL은 솔루션의 성질에 관 계없이 모든 솔루션 시나리오를 캡처할 수 있다. NSL은 '동등성 원리'를 따른다. NSL은 서로 다른 섭스트레이트 에서 매우 효과적으로 솔루션을 조화롭게 조정하였다. 그렇게 함으로써 솔루션이 상이한 섭스트레이트에 존재할 수 있다는 사실을 확립하였다. 또한 솔루션이 어디에 있든 관계없이 NSL 프레임워크가 솔루션의 본질을 우아하 게 캡처할 수 있다는 사실도 확립하였다. 이것은 다양한 자연 언어 섭스트레이트 뒤에 있는 의미를 정확하게 캡 처하는 것과 유사하다. 이 배경에서 모든 프로그래밍 언어는 NSL 프레임워크에 매핑되며 그 반대도 마찬가지이 다. 그것은, 동등성 원리를 기반으로 한 '프로그래밍 언어 동등성 행렬'을 확립함으로써 수행되었다. 행렬은 행 과 열로 나타내진다. 행렬의 모든 행에는 변수 역할을 하는 고유 ID가 있다. 모든 행은 구조, 상태(상수/변수) 및 함수의 고유성을 나타낸다. 열은 NSL 구성과 상이한 프로그래밍 언어 및 해당 구성을 나타낸다. 행은 고유성을 나타내지만, 동일한 행의 열은 동일성, 즉 동등성을 나타낸다. 서로 다른 프로그래밍 언어로 테스트된 모든 솔루션에서 공통적인 한 가지는 솔루션이 작동한다는 것, 즉 기능에 모호성이 없다는 것이다. 그것은 또한 전자 가 항상 확실히 솔루션으로 가는 길을 찾을 수 있다는 것을 의미한다. 복잡성은 프로그래밍 언어와 관련하여 개 체 또는 개체 집합의 고유성을 결정하고 올바른 행에 배치하는 것과 관련된다. JSON 기반 정규 표현을 통해 각 행의 고유 변수 id-s와 NSL 구성 간에 동등 관계가 먼저 확립된다. NSL에 '대한(to)' 임의의 프로그래밍 언어를 수행해야 하는 경우, JSON 형식의 ID를 필요한 경우 해당 언어의 동등한 구성으로 대체할 수 있다. 따라서 기술 번역 프레임워크(Technology Translation Framework)가 확립된다. 동일한 원리에 따라, NSL은 동일한 행의 변 수 id-s를 특정 언어 구성으로 대체함으로써 임의의 프로그래밍 언어로 다시 번역된다. 따라서 기술 재번역 프 레임워크(TRF)가 확립된다. 채워진 행에 많은 열이 있을 수 있지만, 다른 열은 널(null) 값으로 적용할 수 없는 상태로 남아 있을 수 있다. 많은 프로그래밍 언어에서, 행의 하나 또는 두 개의 열이 거의 채워지지 않는 경우 가 있다. 행렬은 프로그래밍 언어의 성질에 따라 밀도가 높거나 낮다. 범용 언어(예: Java, Python 등)의 경우 밀도가 높고 특수 목적 언어(COBOL, Fortran 등)의 경우 희박하다. 이는 대부분의 다른 프로그래밍 언어와 비교 할 때 해당 프로그래밍 언어에서 해당 구성의 고유성을 말해준다. 프로그래밍 언어 전체에서 일부 구조의 고유 성을 제공할 필요가 있기 때문에, 행렬의 행수는 증가한다. 각각의 행은 때때로 인터페이스, 논리 및 지속성 계 층으로부터의 구성을 함께 가져온다. 과거의 프로그래밍 관행은 비 표준 구조로 축적되었다. API 및 래퍼의 출 현은, 거동을 구동하는 알고리즘에 액세스하지 않고 입력 및 출력 레벨에서만 이해되는 고유 거동으로 이어진다. 프로그래밍 언어의 각 구성은 인프라 구조(하드웨어)에 의해 지원된다. T360은 하드웨어/운영 체계 및 임의의 외부 장치 생태계와 함께 구성의 거동을 설명함으로써 모든 구성을 전체적으로 커버한다. m. 자연 언어 동등성 행렬(Natural Languages Equivalence Matrix, NLEM): NSL 프레임워크는 개체-컨텍스트-ID 기반 프레임워크이다. NSL 솔루션의 기능/논리를 구동하는 것은 ID이다. 솔루션의 내부 활동에 모두에서 중요한 것은 이러한 ID이다. 자연 언어는 특히 인간 에이전트 및 솔루션 환경과의 인터페이스 컨텍스트에서 사용된다. 행은 고유성을 나타내고, 열은 특정 자연 언어에 대한 '동등성'을 나타낸다. 제1 열은 ID를 나타내고 나머지 열 은 상이한 자연 언어를 나타낸다. CU 내의 모든 변경 드라이버(CD)는 대부분 단일 단어 또는 짧은 구문이다. 이 들은 또한 명사, 형용사, 부사, 전치사 또는 간단한 구와 같은 대부분 품사이다. DSD에는 CD 및 이에 상응하는 것이 상이한 자연 언어로 수용되어 있다. DSD는 여러 언어의 기존 사전에서 이를 차용하였다. 언어 간 문장 생 성을 위해, DSD에서 사용할 수 있는 수백 개의 동사를 빌려 명사와 명사구(문장의 주어를 나타냄)를 접두사로 붙이고 적절한 명사와 명사구(문장의 목적어를 나타냄)를 사용하여 접미사를 채움으로써 문장을 만들 수 있다. 대부분의 CU는 본질적으로 반복되기 때문에, DSD에는 문맥적으로 선택하여 사용할 수 있는 많은 수의 CU 설명 문장이 포함되어 있으며, DSD에는 다른 모든 언어의 문장 동등물이 포함된다. 자연 솔루션 언어-기술 프레임워크(NSL-TF): NSL-TF는 NSL 런타임 환경의 설계 및 구현을 담당한다. NSL-TF는 Java 및 Spring 기술을 사용하여 개발되었다. 분산 마이크로 서비스로 설계된 여러 모듈로 구성된다. NSL-TF에 있는 여러 모듈은 개체, 다양한 유형의 CU, 트랜잭션 클래스, 예약된 CU, 자연 언어 번역 등과 같이 NSL에 있는 모든 구조를 설계하고 구성하는 기능을 제공하는 역할을 한다. NSL에서, 일반 개체 생성, 새 속성의 추가에 의 한 개체 업데이트, 새로운 하위 개체의 추가에 의한 개체 업데이트, 전체 개체 업데이트, 기본 변경 유닛 생성, 기본 변경 유닛 업데이트, 계층 내의 참여 항목(예, 속성)의 수정에 의한 CU 업데이트, 계층 수정에 의한 CU 업 데이트, GSI 생성, GSI 업데이트, 반복적 CU 추가, 대체 CU 추가는 JSON(Java Script Object Notation) 스키마 및 기타 알려진 방법을 사용함으로써 수행된다. NSL-TF 아키텍처는 코어와 트랜잭션을 포함한다. 코어는 CU 서 비스, 일반 개체 서비스 및 문맥상 ID 서비스를 포함한다. 트랜잭션은 트리거 CU 실행 서비스와 DCD 실행 서비 스를 포함한다. NSL-TF에서 데이터베이스는 모든 형태의 정보를 보유한다. NSL 플랫폼은 다국어(polyglot) 지속 성을 제공한다. 다국어 지속성은 솔루션 생태계의 런타임을 지원하기 위한 여러 데이터베이스의 공존을 지칭한 다. 메시징(messaging) 및 기타 비동기(asynchronous) 사용을 위해, TF는 Kafka 및/또는 MQ(Messaging Queue) 관련 기술을 사용한다. 사용자 인증 및 권한 부여를 위해, Key cloak 및 Spring Securities와 같은 IAM(Identity and Access Management) 기술이 사용된다. NSL-TF 아키텍처는 도 17에 표시된 대로 여러 모듈에 작동 가능하게 연결된다. 애니메이션화 자연 언어: 이것은 기존의 방식과 비교하여 1% 미만의 노력으로 임의의 솔루션을 구축할 수 있는 프로세스이다. 프로그래밍 코드를 완전히 제거할 수 있는 길을 열어주는 NSL을 사용하여 심지어는 복잡한 솔루 션도 구축될 수 있다. 애니메이션화 자연 언어에는 다음과 같은 요소가 있다: a) 별개의/불연속적인 상태: NSL은 정보를 중요한 별개의/불연속적인 것으로 규정한다. 중요한 모든 것은 개체 로 표현된다. NSL은 '이진 개체'(BET) 기반 모델이다. 개체의 개념은 에이전트 시스템의 컨텍스트에서만 의미가있다. 에이전트는 세계의 패턴을 인식한다. 에이전트는 세상에서 사물과 사물의 상호 작용을 분류하여 생존 요 구 사항이 더 잘 충족되도록 한다. 패턴 인식 및 분류는 연속성을 개별(구별된) 상태로 변환한다. 이것은 현실 세계의 무한과 복잡성을 극복하기 위해 수행된다. 에이전트가 정보를 저장, 처리 및 작업할 수 있는 능력은 유 한하고 제한적이다. 비디오는 초당 30 프레임이 눈앞에 돌아가는 것을 통해 세상의 실시간 경험을 캡처한다. 두 프레임 사이에는 무한대가 있다. 그러나 그 모든 정보를 무시하는 것은 각각의 프레임에 포함된 정보를 인식하 는 것만큼 중요하다. 에이전트에게 남은 유일한 선택은 더 나은 생존을 위해 충분이 개별적이고 최적화된 방식 으로 정보를 캡처하는 것이다. 부수적으로, 개별 개체와 이들이 유발하는 개별 이벤트에 대한 지식은 임의의 솔 루션을 구축하는 데 충분하다. b) 이진 개체(BET): NSL은 에이전트 시스템에서 개체의 진정한 성질을 인식하는 접근 방식을 취한다. 에이전트 시스템에서 개체의 진정한 성질은 이진 상태로 존재한다는 것이다. 이진 개체(BET)는 정보를 정량화하는 이진 디지트(BIT)와 유사하다. 'BIT'는 정보의 기본 단위이다. 'BET'는 솔루션의 기본 단위이다. NSL BET는 솔루션을 정량화한다. '비트'가 '0' 또는 '1' 상태에 존재하는 것처럼, BET는 '단순한 클래스' 또는 '수식된 멤버를 포함 하는 클래스'의 형태로 존재한다. 즉, 잠재성 또는 현실성의 상태로 존재한다. 에이전트의 행동에는 항상 '생각'이 선행된다. 에이전트는 도약하기로 결정한 다음 도약한다. 일부 행동은 본능적인 레벨이다. 몸에는 '무 의식 기능'이라고 하는 '자동 사고' 능력이 몸에 배어 있다. 생각은 기대 속에서 마음속에 만들어지는 패턴이다. 이 생각 기능 또는 예상 기능은 이진 상태의 '클래스' 측면과 동일하다. 어떤 멤버도 클래스 외부에 존재할 수 없다. c) 클래스 관계: 클래스가 다른 클래스와 조합할 때, 두 클래스가 함께 새로운 클래스(조합 개체 상태)를 형성 한다. 클래스는 함께 더 큰 차별화에 기여한다. 예: 'A'와 'B'가 조합하면, 그들은 'AB'가 되고, AB는 A 또는 B 와 차별화된다. 이 예는 도 31에 나타나 있다. 각 클래스는 '제약'으로도 보아야 한다. 클래스는 자격을 갖춘 멤버만 허용한다. 예: 클래스가 '펜'인 경우, '조약돌' 또는 '나뭇잎'은 해당 클래스에 들어갈 수 없다. 이 예 는 도 32에 나타나 있다. 그런 의미에서 클래스는 제약이다. 가능성을 줄임으로써 클래스는 사물에 집중한다. 클래스를 조합하여 초점을 점점 더 선명하게 할 수 있다. NSL이 실제로 중요한 개체 또는 개체 집합에 도달하는 것은 가능성을 지속적으로 제거하는 이 방법론을 통해서이다. A, B, C(ABC)의 조합이 필요한 경우, A, B, C, AB, BC 또는 CA만으로는 기준 집합을 충족하지 않는다. 세 가지가 동시에 존재해야 한다. 정보 기술에서 원하는 차별화가 발생하도록 클래스를 조합하는 이 프로세스는 'AND' 연산자를 통해 처리된다. 조합이 분기되면 'OR' 연산자를 통해 동일하게 처리된다. 'NOT' 연산자는 클래스와 멤버 간의 전환을 처리한다. 'NOT'은 '클래스'(잠 재성)를 '멤버가 있는 클래스'(실제)로 또는 그 반대로 변환한다. d) 클래스의 동의어: 세계는 다른 이름으로 '클래스'를 지칭한다. 그 과정에서, 이러한 동의어의 확산과 이와 관련된 다양한 해석으로 인해 발생하는 상당한 혼란도 있다. 하루가 끝나면 그들은 모두 같은 것을 의미한다. 그러한 동의어의 문제는 사람들이 그것들을 다른 것으로 생각하는 경향이 있다는 것이다. 게다가 그들은 혼란을 가중시키는 다른 의미를 부여한다. 다음은 '클래스'에 대한 많은 동의어의 샘플 목록이다: A. 잠재성 B. 제약 C. 규칙 D. 알고리즘 E. 시스템 F. 프로세스 G. 구조 H. 제한 I. 필터 J. 예상 K. 솔루션 L. 규제 M. 결정 N. 선택 O. 선발 P. 주의 Q. 정리 R. 공리 S. 통로 T. 채널 위에서 알 수 있는 것은 위의 각 용어가 가능성의 어레이로부터 가능성을 제한한다는 것이다. 덜 원하는 위치로 부터 더 원하는 위치로 얻을 수 있는 가능성의 이러한 일련의 방향성 감소를 통해 이루어진다. 모든 가능한 솔 루션은 NSL 런타임 환경에서 클래스 레벨 CES와 확장된 CES를 생성함으로써 달성될 수 있다. e) 클래스 및 멤버 관계: NSL은 클래스를 연결하여 임의의 차별화된 솔루션을 생성하는 방법을 공개하였다. NSL 은 또한 솔루션 환경과 관련된 또 다른 종류의 관계를 가지고 있다. 그 관계는 클래스와 멤버 사이이다. 연결 및 관련 클래스를 사용하여 솔루션을 생성하면 그 자체로는 트릭을 수행하지 않는다. NSL 런타임에 배치하고 환 경에 노출해야 한다. 그 다음 솔루션은 환경으로부터 지정된 클래스로 멤버를 흡입하고, 멤버를 흡출하고, 다른 지정된 클래스에 흡수된다. 숨을 들이쉬고 내쉬는 것은 입력 및 출력, 또는 이벤트 또는 출력 이벤트와 동일하 다. f) 멤버에 대한 클래스: 이것은 이미 배치된 모든 솔루션에 적용되며, 모든 클래스와 그 관계는 이미 확립되어 있다. 해야 할 남은 모든 일은 자격을 갖춘 멤버를 노드의 로컬 네트워크에 허용하기 위해 환경을 응시하는 것 이다. 노드의 로컬 네트워크가 노드의 다른 로컬 네트워크에 대해 자격을 갖춘 멤버를 생성하도록 한다. 클래스 대 멤버 관계 상황에서, 멤버의 입장은 가능한 클래스를 기반으로 한다. 즉, 기존의 '클래스'가 없으면, '멤 버'가 있을 수 없다. g) 클래스에 대한 멤버: 이러한 상황에서, 에이전트는 환경의 개체를 인식하고 그들의 센스를 이해하려고 노력 한다. 이는 마주치는 개체의 적절한 분류를 통해 수행된다. 기계 학습의 대부분은 감독 방식 또는 감독되지 않 은 방식으로 이러한 클래스를 식별하는 것이다. 예: 어떤 사람이 창 밖을 내다보고 있는데 특정 새를 알아볼 수 없다면, 친구에게 물어보고 친구는 '오! 바로 비둘기'라고 한다. 친구의 경우, 비둘기가 어떤 클래스에 속하는 지 알고 있었기 때문에, 클래스로부터 멤버로 옮겼다. 개인의 경우, 개인은 해당 개체가 속한 클래스에 대해 이 전에 알지 못했기 때문에 멤버로부터 클래스로 이동하였다. 대부분의 학습은 이러한 방식으로 진행된다. 클래스 는 기존 클래스의 컨텍스트에서 어떠한 새로운 환경도 이해할 수 있도록 정신적 구성을 가능하게 한다. 솔루션 설계자는 솔루션을 구축하는 프로세스에서 올바른 클래스와 그들 관계를 식별함으로써 그 통찰력(acumen)을 발 휘한다. 이것이 NSL에서 자연 언어가 애니메이션화되는 방식이다. 모든 실제적인 목적을 위해, 애니메이션화된 자연 언어는 살아있는 존재의 거동을 완벽하게 모방한다. 클래스와 멤버 관계 간의 토글(toggle)은 자연 언어를 동적으로 만든다. 자연 언어를 애니메이션화 하는 것은 솔루션 집 합(클래스 집합)으로 들어오고 나가는 멤버이다. 모든 솔루션은 이제 '애니메이션화 자연 언어'의 형태로 표상 적 카운터파트를 가질 수 있다. 이것은 모든 자연 언어의 표상적인 능력에 대한 자연스러운 확장이다. 모든 자 연 언어는 정적인 방식으로 현실의 어떠한 복잡성도 포괄적으로 묘사할 수 있다. NSL이 하는 모든 것은 이러한 자연 언어를 애니메이션화 함으로써 생생하게 만드는 것이다. 매직 미러(Magic Mirror): '애니메이션화 자연 언어'는 NSL의 진정한 성질을 설명하는 강력한 방법 중 하나이다. 동일하게 강력한 또 다른 은유는 NSL을 매직 미러로 시각화하는 것이다. 수천 개의 자연 언어가 수천 년 동안 현실 세계의 모든 것을 효과적으로 표현하는 능력에 대해 테스트되었다. 어떤 의미에서 자연 언어는 현 실 세계의 개체를 반영하는 거울이다. 거울에 관한 한 가지는 모든 물리적 이미지를 정확하게 캡처한다는 것이다. 그러나 그것은 단지 거울일 뿐이다. 거울 속의 개체는 현실 세계의 개체를 반영하고 그에 의해 영향을 받는 다. 그러나 모든 실용적인 목적을 위해. 미러링된 개체는 실제 세계의 개체에 영향을 주지 않는다. 매직 미러에 관해서는 다른 이야기이다. 이 매직 미러는 제어된 전자기력으로 구성된다. 이러한 제어는 '정보 기술' 미러에 서 여러 레벨의 추상화에 의해 얻어진다. 이러한 제어된 전자기력을 여러 레벨의 추상화 및 자연 언어와 결합함으로써 NSL은 매직 미러를 현실로 만든다. 매직 미러의 성질: 매직 미러의 개체는 서로 상호 작용할 수 있다. 그들은 다른 매직 미러 카운터 파트의 개체 와 상호 작용할 수 있다. 그들은 또한 '미러링된 존재'의 경계를 매끄럽게 넘을 수 있다. 그들은 '화면 밖으로 뛰쳐나와' 현실 세계의 개체와 원활하게 상호 작용할 수 있다. 인간과 기계 에이전트에 의해 촉진되는 이러한 제어된 개체 상호 작용은 많은 마법 속성을 얻는다. 그들이 속한 섭스트레이트(물리적 세계, 이미지 세계, 자연 언어 세계 등)에 관계없이, 개체는 솔루션에 중요한 것에 의해서만 영향을 받는다. 가장 흥미롭게도 이러한 개 체 중 다수는 빛의 속도로 이동할 수 있으며 초당 수십억 번 상태를 변경할 수 있다. 타이핑 어웨이(Typing Away) 솔루션: NSL의 솔루션의 기록과 관련하여, NSL 런타임에 이러한 솔루션을 타이핑 어웨이하고 작동하게 만드는 데 제한된 시간이 걸린다. UI, 데이터베이스 인터페이스 및 모바일 지원을 가능하 게 하는 데 많은 노력이 필요하지 않다. 또한 솔루션 개발은 임의의 자연 언어로 수행할 수 있으며, 임의의 다 른 솔루션 언어로 번역될 수 있다. 또 다른 중요한 추가 이점은 선택한 프로그래밍 언어 환경에서 솔루션을 재 구성하고, 입력 및 출력 동등성을 보존하는 기능이다. 문맥성 및 조건성: 모든 개체는 고유하며 자체 속성을 갖는다. 에이전트 시스템에서, 개체는 에이전트가 솔루션 을 찾을 때 중요한 것이다. 에이전트의 유리한 지점에서 개체는 대부분 거시적이다. 이러한 개체는 이미 서로 다른 유형의 수조 개의 원자와 입자로 구성되어 있다. 무수히 많은 불연속적/특이한 상태는 개체 속성의 문맥상 차별화에 기여한다. 예를 들어 펜은 글을 쓸 수 있는 속성을 갖게 되고, 종이는 쓸 수 있는 속성을 갖게 된다. 에이전트는 목적을 달성하기 위해 이러한 개체에 의존한다. 예: 어떤 사람은 배고픔을 채우기 위해 사과 하나만 을 필요로 한다. 이 경우 원자 형태의 수조 개의 불연속/특이한 상태가 함께 모여(조합적 불연속/특이한 상태) 사과를 형성하였을 수 있다. 그러나 같은 사람이 편지를 써야 한다면, 그 사람은 이제 편지를 쓰기 위해 펜과 종이가 필요할 것이다. '사과'가 '배를 채우는' 이벤트를 생성하듯이, '펜과 종이'의 조합은 '쓰는 종이'의 이 벤트를 생성하는 능력이 있다. NSL 패러다임의 개체는 제외된 중간의 원리로 작동한다. 즉, 개체는 이진 상태로 존재하거나 존재하지 않는다. 솔루션이 이미 설계된 어떠한 환경에서도, 멤버의 도착을 용이하게 하기 위해 먼 저 클래스가 생성된다. 위의 경우에, 실제 사과가 (잠재적으로) 도착하기 전에 사과 클래스가 먼저 있었다. '사 과 반' 또는 '사과 1/4'과 같은 중간 상태는 제공되지 않는다. 사과가 클래스 내부로 도착하면, '클래스 사과' 를 현실로 만들었을 이벤트로서 알려져 있다. 사과가 떠나면 그것 또한 하나의 이벤트이다. 이제 '클래스 사 과'는 멤버가 없어지고 다시 잠재성으로 상황을 전환한다. 원하는 편지 쓰기 이벤트를 생성하기 위해서는 펜과 종이라는 두 개체가 필요하다. NSL 이론은 '펜과 종이'의 조합, 즉 공생 자체가 고유한 특성을 가질 것을 요구 한다. 이진 변수 형태의 두 개체가 있으므로, 솔루션 관점에서 조합 상태는 다음 네 가지 상이한 상태가 될 수 있다. 1. 펜과 종이 모두 잠재성 안에 있다(클래스만 존재). 2. 펜은 클래스 펜에 매달린 부재로 도착하였으므로, 펜은 현실 상태이고, 종이는 잠재성 상태이다. 3. 또 다른 가능성은 종이가 도착하여 상태를 현실로 만들었지만 종이가 아직 도착하지 않았다는 상태이다. 4. 네 번째 조합 상태는 펜과 종이 모두 현실에 있다는 것이다. 네 번째 상태만이 '서면 편지'라는 원하는 이벤트를 발생시킬 수 있는 능력을 가지고 있음에 주목하여야 한다. 즉, 해당 조합만이 원하는 이벤트를 발생시키는 조건을 충족한다. 나머지 세 가지 조합은 '널-이벤트'(이벤트 없음)를 생성한다. 펜과 종이 개체를 사용하는 원하는 이벤트 및 널 이벤트가 도 36에 나타나 있다. 단일 개체 모델과 조합 개체 모델의 차이점은 이벤트가 조합에 있는 각 개체에 대해 개별적으로 발생할 수 있다는 것이다. 즉, CES는 독립된 개체처럼 작동하지만, 느슨하게 결합된 많은 개체와 속성으로 구성되어 있다는 점에서 다르다. 모든 실질적인 목적을 위해 둘 이상의 개체로 구성된 CES는 그 안에 포함된 각 개체가 속성인 것처럼 작동한다. 유리한 지점을 전환하여 GSI의 관점에서 사물을 보면, 모든 CU와 그 안에 포함된 개체가 함께 모여 GSI의 속성이 된다. 모든 조합은 문맥적이며 상대적인, 즉, 다른 것에 대한 개체이다. 그러나 조합에 관련된 모 든 개체의 존재만이 이벤트를 트리거하는 '조건'을 충족한다. 이진 상태에 10개의 개체가 있는 경우 가능한 조 합은 2^10이다. 그러나 1024번째 조합 개체 상태만이 원하는 이벤트를 트리거하는 조건을 충족한다. 이것 이 문맥성(CES 또는 ECES)과 조건성의 주요 차이점이다. 조건성은 트리거 속성을 갖는 해당 문맥성이다. 덧붙여 서, 개체가 '불변' 상태(멤버는 클래스에 항상 있음)에 있는 경우, 가능한 조합 개체 상태의 수가 그에 따라 줄 어든다. 10개 중 9개가 '상수'라면, 조합된 개체 상태는 두 개뿐이며, 10번째 개체는 잠재성 또는 현실에 있고, 다른 모든 개체는 어떤 경우에든 존재한다. 그 존재가 당연시되고 진술하지 않기로 선택한 묵시적 개체가 있다.예: 편지를 쓰는 것과 관련하여 테이블과 의자를 주어진 것으로 간주할 수 있다. 조건이 충족되면 작업이 자동 으로 수행되도록 '기계 에이전트'와 관련하여 변경 경로가 명확하게 설정된다. '인간 에이전트'의 경우, 트리거 조건이 충족되면 일반적으로 역할 수행자가 필요에 따라 변경을 지시할 수 있는 능력이 있다고 가정한다. NSL은 이진 개체(BET) 원리를 기반으로 한다. 이진 개체는 잠재성 또는 현실 상태에 존재하는 개체이다. BIT가 정보와 관련되는 것처럼 BET는 솔루션과 관련된다. 흥미롭게도 이러한 BET의 이진 상태는 유리한 지점에 관계없 이 동일하게 유지된다. 이는 생태계의 모든 'BET'가 가장 가까운 이웃 원리를 통해 서로 연결되어 있는 결과이 다. 두 개의 'BET'가 함께 연결되면, 해당 조합은 이제 이진 상태로 존재하는 원리에 따라 관리된다. 두 개의 이진 개체가 함께 연결되면, 가능한 네 가지 상태가 있다. 이 조합이 현실 상태에 있기 위해서는 상태 전이가 세 가지 잠재성 상태를 거쳐야 한다. 예: 두 개체 모두 잠재성 상태에 있고, 둘 중 하나는 현실 상태에 있고, 다른 하나는 잠재성 상태에 있다. 제1 개체는 잠재성 상태에 있는 반면, 제2 개체는 현실 상태에 있다. '두 개 의 이진 개체의 조합'이라는 현실 상태를 평가하는 관점에서 볼 때, 위의 세 가지 상태는 모두 여전히 잠재성 상태이다. 두 실체가 모두 현실 상태에 있을 때만, 두 이진 개체의 조합적 실체 상태는 현실 상태에 있다. 즉, 도 41에 표시된 두 개의 이진 개체 모델의 조합과 연관된 세 가지 '잠재성의 음영'이 있다. CU 내에서 '비 트리 거 조합 개체 상태'와 동일한 '잠재성의 음영'에 대한 공식은 '2^n-1'이다. 마지막 CU가 GSI인 10개의 순차 CU 의 극단적인 경우. 각 CU는 다음 이벤트에서 하나의 이벤트만 유발하므로 잠재성의 음영 수를 추정할 수 있다. 이 숫자는 GSI의 변수 수로 2를 올린 숫자에 가깝다. 상당히 높은 '잠재성의 음영'이 존재할 것이다. 이론적으 로 가능한 '잠재성의 음영'이 매우 많을 수밖에 없다. 그러나 실제로는 주어진 '잠재성 경로'만 트랜잭션 시간 에 사용되는 경향이 있다. 예: GSI의 물리적 계층에서, 아래에 열거된 잠재적 ECES가 있을 수 있다. 그라운드 상태는 다음과 같다. -(CU1)A'B'C'D'-(CU2) E'F'G'-(CU3)H'I'J'-(CU4)K'L'M'N'O'. 지정된 GSI의 생태계에서 이벤트가 발생함에 따라, GSI가 충족되기 전에 '잠재성 상태'(잠재성의 음영)에서 아 래와 같이 많은 전환이 있을 것이다: - ..................... - ..................... - ABC'D - E'F'G - H'I'J - K'L'MN'O - ..................... - ..................... - ABCD - EF'G - H'I'J - K'L'MNO - ..................... - ..................... - ..................... - ABCD - EFG - HIJ - KLMNO 모든 'BET'가 현실 상태로 변환되면서, 위와 같이 GSI가 실현된다. 예에서 A로부터 O까지의 각 문자는 CU의 물 리 계층에서 'BET'와 동일한 변경 드라이버를 나타낸다. 프라임이 있는 문자(예: B')는 '잠재성' 상태에서 'BET'로 읽는다. '프라임'(')이 없는 문자는 현실 상태에서 'BET'으로 읽힌다. 디폴트 개시 ECES는 GSI CU를 포 함하여 모든 CU에 걸친 그라운드 상태 CES의 조합이다. 다른 극단은 모든 BET가 GSI에 속하는 모든 CU에 걸쳐 현실 상태에 있을 때 GSI가 실현되는 곳이다. 선택한 예에서 가능한 수백 가지의 모든 잠재성 상태를 '잠재성의 음영'이라고 한다. 다시 말하면, GSI의 잠재성 상태의 어느 것도 GSI의 잠재성 상태에 속하며, 실제로는 'GSI 현실 상태'(프라임이 붙지 않은 GSI)라는 단 하나의 상태밖에 존재하지 않는다. 선택된 잠재성의 음영을 통과하는 경로는 이 트랜잭션에 고유하다. 다음에는 다를 가능성이 크다. 모든 트랜잭 션은 '잠재성의 음영'을 통한 전환의 지문 뒤에 있다. 서로 다른 잠재성의 음영을 통해 전이할 때, 서로 다른 에이전트에 대해 관찰할 수 있는 패턴이 있다. 이것은 뒤에 남겨진 '문맥상 지문'과 동일하다. 이 역동성으로부 터 많은 정보를 수집하여, '분석 및 기계 학습' 기술을 새로운 레벨의 효율성으로 끌어올릴 수 있다. 유리한 지 점을 GSI로 전환하면, '잠재성의 음영'이 극적으로 증가하고, '컨텍스트 지문'이 훨씬 더 강력해진다. '문맥성지문'은 '잠재성의 음영'의 총 수에 대해 '실현된 잠재성'(실현되지 않은 많은 것은 제외)에서 발생한다. 이러 한 '문맥상 지문(fingerprints)'은 '문맥적 트랜잭션 잠재성 경로'라는 대체 문구와 동의어이다. 잠재성 정리(theorem)의 음영: NSL에서 일련의 연결된 'BET'는 솔루션(소망 충족)으로 이어진다. BET는 CU의 물 리적 계층에 있는 CES의 일부이거나 ECES(확장된 CES)의 일부이므로 연결된다. 'BET'는 이진 개체를 나타낸다. 'BET'는 잠재성 상태(클래스만 존재하는 경우)와 현실(클래스에 자격을 갖춘 멤버가 있는 경우) 사이를 전환 (toggle)한다. 이것은 이진 변수가 '0' 또는 '1'을 수용하는 정보 이론의 '비트'(이진 디지트)와 동의어이다. CU의 물리적 계층이 수용하는 이진 개체 CES의 수는 2^b 공식에 의해 결정되는데, 여기서 'b'는 CES에서 BET의 수이다. 예: BET가 물리적 계층에 있는 6개의 CD(변경 드라이버)가 있는 경우, 2^6 CES(64 CES)가 있다. 그 중 64 번째 CES만이 목표를 트리거하고 실현하는 것과 관련하여 현실 상태(모든 CD가 도착했을 것임)에 있을 것이다. 단일 CU 시스템에서 잠재성의 음영에 대한 정리: 이 단일 CU 시스템에서 잠재성의 음영은 2^b-1이 될 것이고, 여기서 'b'는 주어진 CU에서 BET의 수를 나타낸다. 'b'가 6이면, 총 CES는 64일 것이고; 잠재성의 음영은 비 트 리거 상태라고도 하는 64-1이다. 시스템은 63가지 잠재성의 음영을 갖는다는 것이 관찰된다. '잠재성'의 정 의는 한 클래스가 현실화될 수 있는 잠재력이다. 63개 상태 모두는 현실화 될 잠재력을 보유한다. 잠재성 상태 는 63개 상태 중 어느 하나에 속할 수 있지만, 여전히 잠재성 상태에 속하는 것으로 분류된다. 잠재성 상태의 잠재성은 현실 상태와 잠재성 상태를 구분하는 이벤트의 수를 기반으로 한다. GSI 현실 상태가 GSI가 현실이 되 기 위해 최소한 25개의 이벤트가 필요한 경우, 잠재성 상태에 속하는 이벤트의 수는 24(25-1)이다. 마지막 이벤 트는 '글로벌 의도 진술'을 현실로 만든다. 잠재성 정리의 음영은 임의의 GSI 환경에서 이론적으로 존재할 수 있는 잠재성 상태의 최대 수를 정량화한다. 그러나 개체(이벤트라고 함)의 도착/출발 특성에 따라, 현실의 경로 는 CES에 많은 BET가 있기 때문에 그 수의 CES만을 통과하여 전환된다. 위의 경우에는, 상태가 6개밖에 없다. 모든 BET의 기본 상태는 잠재성 상태에 있고, 64번째 상태가 발생하기 전에 5번 더 전환된다. 이는 도착만 고려 한다는 것을 전제로 한다(멤버의 클래스로부터의 출발 및 재 도착은 제공하지 않음). CD가 도착하는 순서에 따 라, 잠재성의 음영의 잠재성 경로가 결정된다. 다중 CU 시스템의 잠재성의 음영에 대한 정리: 거의 모든 경우에, 최종 소원 성취로 이어지는 순차적으로 연결 된 다수의 CU(마지막 CU에서)가 있다. 다중 CU 시스템에서 잠재성의 음영에 대한 정리는 다음과 같다: ((2^(b-c-e)) x (2^(b-c-e)) + (2^(b-c-e)) x (2^(b-c-e)) + (2^(b-c-e)) x (2^(b-c-e)) + (2^(b-c-e)) x ,,,,,,,,,,(최후의 CU까지)...........(2^(b-c-e)) + (2^(b-c-e)))-1 상기 식에서, b는 각 CU의 BET(CD)의 수를 나타내는 변수이고; 'x'는 곱셈 기능 외에 CU의 커넥터 역할을 하는 수학적 곱셈 기호이고; 'x' 기호 앞이나 뒤의 각 수학 단위의 각각은 각각의 CU(예: '(2^(n-y-z))'는 제1 CU를 나타내고, '(2^(n-y- z)) + (2^(n-y-z))'는 두 번째 방식을 나타냄)를 나타내고; 'c'는 CU에서 '상수'로 존재하는 'BET'의 수를 나타내고(항상 현실 상태에서 이진 가변성을 수용하지 않음); 'e'는 동일한 '연결된 순차 CU'에 속하는 선행 CU 중 하나 이상이 CU에서 발생하는 이벤트의 수를 의미하고(이 는 동일한 단락에 속하는 선행 문장이 이어지는 순차 문장에서 이벤트를 일으키는 것과 동일함(CU)); 모든 변수는 각 CU의 컨텍스트에 특이한 값을 전달하는 본질적으로 문맥적(문맥상 변수)이다. 예: 'b, c, e'와 같은 변수는 각 CU에 특이한 값을 갖는다. CU1의 'b'는 6이 될 수 있고, CU2의 'b'는 4가 될 수 있다. 모든 산 술 함수는 산술 표준 규칙을 따르기보다는 순차적으로 수행되어야 한다. 예: 16 x 4 + 4 x 8 + 8. 이 산술 방정 식을 풀기 위해, 순차적 단계는 다음과 같이 나타내진다: 제1 단계: 16 x 4 = 64; 제2 단계: 64 + 4 = 68; 제3 단계: 68 x 8 = 544; 및 제4 단계: 544 + 8 = 552. 위의 방법은 '잠재성의 음영 정리'의 목적을 위해 따라야 할 것이다. 동일한 문제가 일반적인 수학적 규칙을 사용하여 수행되는 경우, 산술은 다음과 같은 방식으로 수행 된다: (16 x 4) + (4 x 8) + 8 및 결과는 104이다. 정의에 의해 제1 CU에 어떤 선행 CU도 없는 시나리오에서는 선행 CU 또는 CU에 의해 발생하는 적어도 하나의 이벤트가 적용되지 않는다. 정리는 제1 CU 'e'가 '0'이고, 이 전 CU의 영향이 없기 때문에 이를 제공한다. 제2 CU 이후에는 이전 CU로부터 발생한 이벤트가 오직 1인 경우, 잠재성 상태의 수가 절반에 불과하다. 이전에 연결된 CU로 인해 발생하는 각 CU의 이벤트 수가 증가함에 따라, 잠재성 CES 경로(또는 잠재성의 음영)는 각 이벤트에 대해 ½ 비율로 계속 떨어진다. 이전 CU로부터의 이벤트가3개 있는 경우, 잠재성 CES의 수는 ½ x ½ x ½로 떨어지며, 이는 1/8과 동일하다. 이에 대한 이유는 예를 통 해 설명된다. 아래에 예시된 6 CU 시스템에서 잠재성의 음영을 결정하기 위해 이 정리를 적용한다고 가정한다. 1. CU1은 6개의 CD를 갖는다; 상수 0; 이벤트(연결된 CU로부터) 0 - 제1 CU는 연결된 순차 CU로부터 어떤 이벤 트도 갖지 않는다. 이벤트는 관련 CU에서만 또는 외부 에이전트가 제공한 대로 도착한다. 2. CU2는 4개의 CD를 갖는다; 상수 0; 연결된 CU 1로부터의 이벤트. 3. CU3는 5개의 CD를 갖는다; 상수 2; 연결된 CU 2로부터의 이벤트. 4. CU4는 3개의 CD를 갖는다; 상수 0; 연결된 CU 1로부터의 이벤트. 5. CU5는 5개의 CD를 갖는다; 상수 1; 연결된 CU 2로부터의 이벤트. 6. CU6는 4개의 CD를 갖는다; 상수 2; 연결된 CU 1로부터의 이벤트. 위의 예에 정리를 적용하면, ((2^(6-0-0)) x (2^(4-0-1)) + (2(4-0-1)) x (2^(5-2-2)) + (2^(5-2-2)) x (2^(3- 0-1)) + (2^(3-0-1)) x (2^(5-1-2)) + (2^5-1-2)) x (2^(4-2-1)) + (2^(4-2-1)))-1이다. 이는 (x+x+x+x+x+)-1이다. 이는 (64 x 8 + 8 x 2 + 2 x 4 + 4 x 4 + 4 x 2 + 2)-1이다. 이는 33386-1이다. 즉, 위의 예에는 33385개의 잠재성의 음영이 있다. 상수의 영향: 상수의 영향을 다루는 예와 함께 단순화된 방식으로 설명된다. 예: 이 예에서 CU1에 대한 CES는 A B C D와 같은 BET를 갖는다. 이러한 이진 개체(BET)가 정상적인 과정에서 수용할 수 있는 상태의 수는 16 개(공 식 2^b에 의해 제어됨)이고, 여기서 'b'는 4이고, CES는 16이다. 'A'와 'B'가 상수인 경우, 이제 ABC'D'/ABC'D/ABCD'/ 및 ABCD만 허용되는 상태이므로, CES는 4(2^(4-2))로 떨어질 것이다. 이벤트의 영향: 이벤트의 영향을 다루는 예와 함께 단순화된 방식으로 설명된다. 예: CU1에 대한 CES는 4개의 BET(즉, ABCD)가 있고, 그 뒤에 3개의 BET(즉, EFG)가 있는 CU2가 있다. CU1이 트리거되면, 한 경우에 CU2에서 BET 'E'를 현실로 전환하는 이벤트가 발생한다. 정상적인 과정에서, CU1과 CU2 사이의 ECES는 다음 공식 2^4(어 떤 상수도 없는 제1 CU의 BET 수, 여기서 논의 목적으로 만들어진 가정임) x 2^3에 의해 관리된다. 이는 ECES(128 조합 개체 상태)의 2^7과 동일하다. 그러나 실제로 ECES의 수는 CU1의 16개 CES 중 어느 것도 CU1이 트리거되고 트리거 프로세스가 완료될 때까지 BET 'E'가 현실로 바뀌지 않는다는 단순한 이유 때문에 그렇게 많 지 않을 것이다(여기서 트리거 프로세스 시간은 10분임을 가정). 모든 실용적인 목적을 위해, CU1의 CES는, CU1 트리거 프로세스가 완료될 때까지 CU2의 CES 절반과만 공존할 수 있다. 'E' BET는 CU1의 트리거 프로세스가 완 료되기 전에는 현실로 전환할 수 없다. CU2의 조합 개체 상태는 다음과 같다: 1. E'F'G' 2. E F'G' 3. E'F G' 4. E'F'G 5. E F G' 6. E F'G 7. E'F G 8. E F G BET 'E'는, CU1의 트리거 프로세스가 완료될 때까지, 현실로 전환할 수 없으므로, 검정색(볼드체)으로 표시된 CU2의 8개 CES 중 4개(즉, 2,5,6 및 8개의 조합 개체 상태)는 존재할 수 없다. CU1의 비 트리거 CES 중 어느 것 도 CU2의 E'를 현실 상태로 전환할 수 없다. CU1의 트리거 CES도 10분의 트리거 프로세스 시간이 완료될 때까지 CU2의 E'를 현실 상태로 전환할 수 없다. 이 효과로 인해, CU1 CES와 CU2 CES 사이의 확장된 조합 개체 상태는 16 x 4 조합(16 x 8 조합 아님)으로만 제한된다. 그러나 CU1의 경우, 64번째 CES(모든 BET가 실제로 존재하는 ABCD)는 CU1 트리거를 발생한다. '트리거가 완료되는 데 걸리는 10분'의 개입 기간에서, E는 계속해서 잠재성(E') 상태에 있게 되어 4개의 CES(1, 3, 4 및 7) 중 어느 하나가 CU1에서 64번째 CES와 조합한다. 트리거 프로 세스가 완료되면, CU1의 64번째 CES도 E가 현실 상태에 있는 다른 4개의 CES(2, 5, 6 및 8)와 공존할 수 있다. '잠재성의 음영 정리', ....'+ ((2^n-p-z))'… '트리거 CES'의 이러한 특수한 성질에서 발생한다. 실현된 잠재성의 최소 수: 6 CU 시스템에서 잠재성의 음영을 결정하기 위한 예로서 \"다중 CU 시스템의 잠재성의 음영에 대한 정리\"에서 언급한 바와 같이, 총 33385개의 잠재성의 음영 또는 잠재성 경로가 관찰된다. 솔루션이 실행될 때마다, 이러한 '잠재성의 음영 또는 잠재성 경로'의 제한된 수만 실현된다. 즉, 각 트랜잭션은 '잠재성 의 음영'이라는 모래 중에 '실현된 잠재성'이라는 고유한 발자국을 남긴다. 일 예에서, 제1 CU에는 64개의 CES 를 발생시키는 6개의 BET가 있으며, 마지막(63개 상태)을 제외한 모든 상태는 잠재성의 음영에 속한다. 실현된 잠재성의 기본을 이해하기 위해, 단일 CU 시스템으로 실험을 시작하였다. 단일 CU 시스템에 하나의 BET 'A'만 있는 경우(논쟁을 위해), 해당 BET는 A' 또는 A이며, 여기서 A'는 그라운드 상태를 나타낸다. 그라운드 상태와 현실 상태 사이에는, 중간 상태가 관찰되지 않는다. 이 경우에는 '잠재성의 음영'이 없다. 그러나 3개의 BET가 있는 단일 CU 시스템에는 다양한 잠재성의 음영이 있다. 그라운드 상태(모든 3개의 BET가 잠재성 상태에 있음) 와 CES 잠재성 상태로 2번의 점프로 이어지는 2개의 이벤트가 있다. 예: 1. A'B'C' 2. A B'C' 3. A'B C' 4. A'B'C 5. A B C' 6. A B'C 7. A'B C 8. A B C 그라운드 상태도 잠재성으로 간주한다면, 현실의 최종 상태 이전에 잠재성의 세 가지 음영이 있을 것이다. 검정 색(볼드체)으로 표시된 잠재성의 실현된 음영(즉, 1, 4, 6 및 8)이 발생하는데, 이때, 'C'가 먼저 도착하고, 'B'가 도착하기 전에 'A'가 다음에 도착하여 원하는 트리거 CES가 발생한다. 여기서 잠재성 CES의 실현 순서는, B가 도착하여 트리거 상태 8이 실현되기 전에, 1-4-6이다. 실현 잠재성의 발자취이다. 일반적인 원리로서, 실현 잠재성은 1+ 이벤트 수이며, 여기서 1은 그라운드 상태를 나타낸다. 위의 예에서, '트리거 CES'가 실현되기 전 에 3개의 실현 잠재성과 2개의 이벤트가 있다. 다중 CU 시스템에서, 중간 CU 트리거 상태도 '실현된 잠재성'으로 간주된다. GSI 트리거 CES만 현실 상태로 간 주된다. NSL에서, 모든 것은 문맥적이고 상대적이다. 위의 예에서, 문맥성은 글로벌 의도진술(GSI)의 실현과 관 련이 있다. 모든 '실현된 잠재성' 또는 '잠재성 경로'는 GSI 실현의 속성이다. '잠재성의 음영'을 배경으로 실 현된 잠재성의 최소 수에 대한 정리는 서로 곱한 각 CU의 BET 수가 될 것이다. 위에 열거된 예에서, 잠재성 경 로에는 33385개의 음영이 있지만, 상수를 고려한 후 실현된 잠재성(그라운드 상태 + CU에서 발생할 수 있는 이 벤트 수)은 오직 (6 x 4 x (5-2) x 3 x (5-1) x (4- 2))-1이고, 이는 1727(즉, 1728-1)이다. 잠재성 음영의 최소 이벤트 수: 잠재성 음영의 최소 이벤트 수에 대한 정리는 연결된 CU의 모든 BET를 함께 더 하고, 각 CU의 상수를 뺀 값에서 GSI를 충족하는 1(최종 이벤트)을 뺀 값에서 발생한다. 위에 열거된 예에서, 잠재성의 음영에서 21개의 이벤트가 될 것이다. ((6+4+(5-2)++(5-1)+(4-2))-1. 총 이벤트는 GSI 현실 상태 를 구현하는 이벤트를 포함하여 22개이다. 일 방향성 이벤트: 잠재성의 음영에서 일어나는 이벤트의 최소 수는 이벤트의 일 방향성을 전제로 한다. 즉, 개 별 BET의 이벤트가 잠재성으로부터 현실로 흐르는 것이지 그 반대가 아니라고 가정한다. 멤버는 이벤트를 일으 키는 클래스에 도착한다. 양방향 이벤트: '실현된 잠재성'의 최소 수는 이벤트의 일 방향성을 전제로 한다. 이는 정리가 '실현된 잠재 성'의 최소 수의 컨텍스트에 있기 때문이다. 이벤트를 유발하는 개별 BET로부터 탈퇴하는 멤버가 제공되면 이벤 트의 양방향성이 높아진다. 어떤 그러한 출발도 잠재성의 음영 내에서 이벤트의 수를 추가할 것이다. 예: '사람'이 도착, 즉 이벤트 1이다. '펜'이 도착, 즉 또 다른 이벤트이다. 그러나 '사람' 클래스에 있던 '사람'이 이제 떠나면서 이벤트도 발생한다. 이 예는 양방향 이벤트가 이론적으로 주어진 GSI에 대한 잠재성의 모든 음영을 커버할 수 있다는 지점을 만들기 위해 확장될 수 있다. 위의 '실현된 잠재성'에 명시된 예에서, CES 형식의 실현된 잠재성의 수는 트리거 CES 8 이전에 1-4-6으로 나열된다. 그러나 'C'가 CU로부터 출발하면, 실현된 잠재 성 CES는 '2'가 된다. 이후 'B'가 도착하면, 실현된 잠재성 CES는 '5'가 된다. 마찬가지로 'A'가 출발하고 'B' 가 도착하면 실현 잠재성 CES는 '7'이 된다. '잠재성의 음영 정리'는 모든 가능한 잠재성의 음영을 확립한다. '실현된 잠재성'에 관한 정리는 가능한 실현된 잠재성의 최소 수만을 확립한다. 이것이 일어나기 위해서는, 이 벤트의 일 방향성만이 우선해야 한다. 그러나 이벤트의 양방향성이 제공되는 경우, 트리거 전에 CU 내에서 여러 번 도착 및 출발할 수 있다. 이들은 GSI 내의 이벤트에 추가될 수 있을 뿐만 아니라 실현된 잠재성의 최소 수를 훨씬 넘어서는 '실현된 잠재성'의 수를 향상시킬 수 있다. 대체(alternative) CU: 연결된 CU와 동일한 GSI 생태계에 속하는 CU를 호출할 수 있다. GSI 생태계 외부에 영향 을 미치는 경우, 영향을 받는 CU를 '관련 CU'라고 한다. 연결된 CU가 동일한 단락에 속해 있으면, 이렇게 연결 된 CU를 순차 CU라고 한다. 이들은 'AND' 기능에 의해 관리된다. 잠재성의 음영 정리가 이러한 연결된 CU에 적 용된다는 것은 당연한 것이다. 그러나 대체 단락(대체 CU의 영향으로 인해 생성됨)에 연결된 모든 GSI 생태계에 도 동일하게 적용된다. 대체 CU는 'OR' 기능에 의해 관리되는 GSI에 대한 대체 경로를 제공한다. NSL은 이미 GSI 컨텍스트에서 경로 수를 세는 프로세스를 확립하였다. 잠재성 음영 정리는 기존의 모든 GSI 경로에 직접 적 용될 수 있다. 수학에서 순열 및 조합 조정: NSL은 솔루션의 컨텍스트에서 객체/개체의 순열 및 조합을 다시 검토한다. 당분간 NSL은 CU가 일반적으로 말해서 조합만 고려하므로 '순열'을 무시한다. BET가 도착하는 순서는 일부 특수한 경우 에만 관련된다. 이러한 객체/개체는 솔루션과 관련하여 '이진 상태'의 형태를 취하며, 여기서 이들은 'BET'로 변환된다. 이진 개체가 CU에서 조합할 때, 발생하는 조합 상태(CES)의 수는 아래 설명하는 예에 나와 있다. 예: CU의 CD/BET가 3이면, 2^3 'CES'로 이어지며, 이는 8 CES이다(2^b 공식에 따름). 1. A'B'C' 2. A B'C' 3. A'B C' 4. A'B'C 5. A B C' 6. A B'C 7. A'B C 8. A B C 그러나 객체/개체의 '조합' 공식은 다음과 같은 결과를 가져온다. 조합의 공식은 n!/(n-r)! 이다. 'n'이 개체 수인 경우, 'r'은 한 번의 조합을 나타낸다. 3개의 이진 개체인 경우, 'n'은 6(잠재성 상태 3개와 현실 상태 3 개)이며, 총 조합은 6!/(6-3)!3! = 720/6x6 = 20이다. 본 명세서에서 상기 나열된 조합에 더하여, 다음 조합 도 포함된다: 1. A'A B' 2. A'A B 3. A'A C' 4. A'A C 5. B'B A' 6. B'B A 7. B'B C' 8. B'B C 9. C'C A' 10. C'C A 11. C'C B' 12. C'C B 따라서 총 조합은 20(8 및 12)이 된다. 본질적으로 이진 개체는 잠재성 상태와 현실 상태 사이에 동시에 공존할 수 없다. 따라서 제2 집합(12 조합)은 제외된다. 그 결과의 조합은 2^b 공식과 일치하는 8개뿐이다. 조합 공식이 산출하는 숫자 20과 BET 공식이 산출하는 숫자 8 사이의 차이를 어떻게 설명할 수 있는지에 대한 질문이 발생한다. 개체와 비교하여 'BET'의 특수한 성질을 취함으로써 차이점을 설명할 수 있다. BET는 항상 개 체 쌍으로 제공되지만 임의의 주어진 시간에 그 중 하나만 존재한다. 제1 BET는 잠재성 개체이고 다른 하나는 현실 개체이다. 일반적으로 잠재성과 현실 모두는 동시에 존재할 수 없다. 조합에 도달하는 것과 관련하여 모든 BET가 고려된다. 그 결과 BET 카운트(b)는 항상 조합 공식에서 'r'과 동일하고, 'n'은 항상 BET 수(2b)의 두 배 이다. 위의 모든 사항을 고려할 때, 기존 공식의 '개체 조합'과 BET 관련 공식에 따른 'BET 조합'의 차이점이 설명된다. 위의 예에서, 차이는 12(20-8)이다. 이 모든 12개의 개체 조합 사례에서, 동일한 개체의 잠재성과 실 체가 모두 존재하였다. 이들은 BET 모델에서 허용되지 않는 조합으로 규정된다. 나머지 조합은 BET 공식 '2^b' 가 산출하는 것과 동일한 8이다. 허용되지 않는 BET 조합을 식별하는 공식은 다음과 같이 나타낼 수 있다: (n!/(n-r)! x r!)-2^b 순열: 이들은 순서도 중요한 조합이다. 순열은 일반적으로 CU가 있는 BET와 관련하여 중요하지 않다. 그러나 순 열은 CU들 간의 관계와 관련하여 특별한 역할을 한다. 예: A. 고객 요청 등록 B. 고객 장소로의 이동 C. 제품 배송 이 예에서, 각 CU는 순서에 민감하다. 즉, 'C' 다음에 'B'가 올 수 없다. 조합: 일반적으로 말하자면, CU 내에 서 BET가 도착하는 순서는 중요하지 않다. 예: '편지 쓰기'의 경우, '사람'이나 '펜' 또는 '종이'가 언제 CU에 도착했는지는 중요하지 않다. 중요한 것은 모든 개체가 '편지 쓰기'를 목적으로 존재했는지 여부이다. 드문 경 우지만 CU에서도 순서가 중요할 수 있다. 예: CU에서는 사무실 소년, 간호사, 의사, 환자가 순서대로 도착하는 것이 중요할 수 있다. 순열에서는 BET가 배열되는 순서도 중요하다. 주문은 CU에서 CES의 일부 특별한 경우에 중요한 역할을 할 수 있 다. 그러나 GSI 내의 모든 CU의 경우, CU가 나타나는 순서가 가장 중요하다. 다음 공식은 BET의 순열(순서가 중 요한 조합)에 적용된다: 2^b x b! 위의 예에 따라, 이것은 2^3 x 3!으로 변환되고, 이것은 48과 같다. 개체에 대한 종래의 순열 공식은 다음과 같 다: n!/(n-r)!. 위의 예에 이 공식을 적용하면, 다음과 같이 된다: 6!/(6-3)! = 720/6 = 120. 조합 공식의 경우와 마찬가지로, 여기에서도 허용되지 않는 순열, 즉 120-48 = 72가 발생한다. 동일한 BET의 잠 재성 상태와 현실 상태가 모두 존재하는 72개의 허용되지 않는 순열이 있다. 이러한 허용되지 않은 순열이 무시 되면, 나머지 순열은 BET 공식이 산출하는 숫자와 일치한다. 2^b x b! 위의 예에 따라, 이것은 2^3 x 3! = 8 x 6 = 48로 변환된다. 허용되지 않는 순열을 식별하는 공식은 (n!/(n-r)!)-((2^b) x b!). 여기서 'n'은 총 개체 수이고, 'r'은 선택한 집합의 개체 수, 'b'는 이진 개체(BET)의 수이다. 위에서 선택한 예에 따른 결과는 다음 과 같다: (6!/(6-3)!)-(2^3) x 3!) = (720/6)-(8 x 6) = 120-48 = 72. 유리한 지점 및 BET: 다음은 '잠재성의 음영'에 대해 가장 눈에 띄는 몇 가지 사항이다. 유리한 지점이 무엇이 든 관계없이, 모든 BET는 이진 상태에 있다. '다중 CU 시스템의 잠재성 음영에 대한 정리'에서, 정리는 6 CU 시 스템 예에서 잠재성의 음영을 결정하는 데 적용되며, 여기서 GSI 이행에는 '잠재성 상태'와 '현실 상태'라는 두 가지 상태만 있다. '잠재성의 음영'은 33385개이었지만, 이들은 집합적으로 오직 하나의 '잠재성' 상태에만 속 하였다. 해당 GSI의 '현실 상태'는, GSI CU의 모든 BET가 현실 상태에 있을 때 단 하나이었다.유리한 지점 전환: 더 높은 유리한 지점에는 많은 차별화된 연결 개체 또는 속성(BET)이 있다. GSI에는 그와 연 결된 BET가 임의의 수로 있을 수 있다. 어떤 유리한 지점을 선택할 수 있든 간에, 해당 유리한 지점의 'BET'는 항상 이진 상태에 있다. 잠재성의 음영에는 여러 가지가 있을 수 있지만, 항상 하나의 현실 상태만 있다. NSL 생태계의 모든 BET는 연결되어 있다. 모든 BET는 별개/불연속적이지만 연결되어 있다. BET를 볼 수 있는 유리한 지점은 BET의 성질을 변경한다. 그것은 권한이 부여된 에이전트 또는 이해 관계자에게 중요한 것과 관련이 있다. 글로벌 의도 진술의 실현 관점에서 관찰하면, 현실 상태는 단 하나이며, GSI CU의 모든 BET가 현실 상태 에 있을 때이다. '잠재성 음영 정리'의 6 CU 시스템 예에서 잠재성 음영을 결정하기 위해, 잠재성의 음영은 33385개이지만 현실은 하나뿐이다. 동일한 예에서 유리한 지점이 CU1로 전환되면, 그 안에 6개의 BET가 있으므 로 64개의 CES가 된다. 유리한 지점은 트리거를 가져오는 해당 CES이기 때문에, 64 번째 CES는 현실 CES가 되고, 다른 모든 63 CES는 잠재성의 음영을 나타낸다. 유리한 지점이 GSI CU일 때, 33385개의 잠재성의 음영이 있었다. 제1 CU의 64번째 CES는, 유리한 지점이 GSI CU로 전환되었기 때문에, 더 이상 '현실 상태'가 아니다. 제1 CU 64번째 CES는 유리한 지점이 전환됨에 따라 '잠재성의 음영'에 참여할 뿐이다. 잠재성의 음영에 있는 모 든 참여 개체는 선택된 유리한 지점의 원인을 제공하는 속성과 동등한 지위를 가정한다. 개체와 속성이 CES에 참여하는 것처럼, 'CES'도 ECES(확장된 CES)에 참여한다. 선택된 유리한 지점이 특정 CES인 경우, 참여하는 모 든 멤버가 잠재성의 음영에 기여한다. 그 CES는 해당 CES에 참여하는 모든 BET가 현실이 될 때까지 잠재성을 계 속 유지할 것이다. 선택된 유리한 지점이 '독립적인 개체'인 경우, 모든 속성이 잠재성의 음영에 기여한다. 다 운스트림 BET가 없는 가장 기본적인 형태의 BET-BET의 유리한 지점을 선택할 수 있다면, 그러한 BET는 잠재성의 음영이 없을 것이다. 오직 하나의 잠재성 상태, 즉 멤버십이 없는 클래스가 있다. 애플리케이션 및 사용 사례: '잠재성의 음영' 및 이와 관련된 정리를 뒷받침할 수 있는 사용 사례 및 애플리케 이션은 얼마든지 있다. NSL은 솔루션 생태계의 모든 개체를 BET로 변환함으로써 변혁적인 접근 방식을 취한다. NSL에서 솔루션을 개발하는 것은 과학만큼이나 예술이다. NSL 구조와 툴은 매우 광범위하므로 창의적으로 사용 하는 것이 매우 중요하다. 하위 트랜잭션 클래스(솔루션에 전두엽 피질(prefrontal cortex)을 추가하는 것과 같 은 것), 섭스트레이트 개체 라이브러리의 개념, 및 여기에서 부분적으로 취급되는 잠재성의 음영과 같은 기능은 상당히 변혁적이다. NSL은 BET 구조에서 가장 차별화된다. 개체가 선택되고 'BET'로 변환되면 가장 중요한 몇 가지 성질을 얻는다. 그 중 하나는 모든 유리한 지점에서 'BET'의 특성과 같은 프랙탈(fractal)을 유지하는 것 이다. 이는 솔루션 설계자와 트랜잭션 실행자에게 임의의 종류의 문맥성 또는 조건성을 'BET'에 적용할 수 있는 완전한 유연성을 제공한다. 논의된 바와 같이, '문맥성'은 상황에 따라 하나 이상의 BET와 조합되는 하나 이상 의 BET이다. '조건성'은 올바른 컨텍스트가 자체 이벤트를 생성할 수 있도록 지정된 컨텍스트에 트리거 특성을 적용하는 것에 관한 것이다. 유리한 지점이 무엇이든 각 'BET'는 임의의 다른 'BET'를 첨부하여 차별화할 수 있 다. 추가된 BET는 선택된 BET의 속성이 된다. NSL을 임의의 다른 솔루션 프레임워크와 상당히 분리된 것은 이러 한 유연성, 투명성 및 단순성이다. 상상력은 임의의 유리한 지점에서 임의의 BET에 차별화된 BET를 추가하는 것 과 관련하여 한계 사항이다. 병렬 CU: 우선 연결된 CU는 동일한 GSI 에코시스템에 속하는 것들이다. GSI 생태계는 메인 GSI 또는 대체 CU 및 대체 GSI(메인 GSI와 관련된 다양한 시나리오)를 수용하는 GSI를 포함한다. 예: '현금결제' 또는 '신용카드' 결 제로 배송한다. GSI까지 경로를 설정하는 순차 CU(AND) 기능과, 동일하거나 대체 GSI로 이어지는 대체 CU(OR) 및 이에 연결된 시퀀스이다. 각 대체 GSI는 별도의 단락이지만 연결된 GSI의 생태계에 속하는 단락이다. CU에서 발생한 이벤트가 연결된 단락의 경계를 넘어 다른 단락의 이벤트에 영향을 미치는 경우 해당 이벤트를 관련 이 벤트라고 한다. 이러한 배경에서, NSL은 '병렬 CU'의 품질을 평가한다. 병렬 CU는 두 가지 특성을 갖는다: 1) 이러한 CU의 트리거는 해당 CU의 트리거와 독립적이다. 2) 전체적으로 GSI가 실현되려면, 모든 병렬 CU도 트리거되어야 한다. 이것은 병렬 CU가 '대체 CU'와 구별되는 방식이다. 대체 CU의 경우, 하나의 경로를 선택하면 다른 경로는 의미를 잃는다. 그러나 병렬 CU의 경우, 이들이 속한 분기도 GSI가 실현되도록 지속된다. 병렬 CU는 연결된 동일한 GSI 생태계의 메인 또는 대체 단락에 속한다. 병렬 CU는 메인 또는 대체 단락의 분기로, 이들은 메인 또는 대체 단락의 지정된 세그먼트와 병렬로 실행된다. 1. 병렬 CU 분기: 하나 이상의 CU로 구성된다. 2. 메인 CU 경로: 단순화를 위해 '병렬 CU 분기'와 관련하여 메인 또는 대체 단락에 속하는 세그먼트를 '메인 CU 경로'라고 한다. 3. CU를 발생시키는 병렬 CU 분기: 이들은 병렬 분기가 발생하는 CU이다. 4. 병렬 CU 분기 정점 CU: 이들은 병렬 U 분기가 정점을 이루는 CU이다. 예: 'CU1-CU2-CU3-CU4-CU5-CU6'이 GSI를 나타낸다고 가정한다. '메인 CU 세그먼트'에 해당하는 '병렬 CU 분 기'라는 특성을 가진 CU1으로부터 나오는 분기가 있을 수 있다. 다음과 같은 방식으로 흐를 수 있다. CU1-PCU1-PCU2-CU4-CU5 …… . 여기서, PCU는 '병렬 CU'를 의미한다. 이 예에서 'CU2 및 CU3'은 메인 CU 세그먼트를 나타내고, PCU1 및 PCU2는 '병렬 CU' 분기를 나타낸다. 이 병렬 CU 분기는 CU1으로부터 시작하여 CU4에서 절정에 이른다. 이 예는 도 57에 나타나 있다. 병렬 CU 분기의 컨텍스트에서 잠재성의 음영 정리: 표준 '잠재성의 음영 정리'는 다음과 같다: ((2^(b-c-e))x(2^(b-c-e))+(2^(b-c-e))x(2^(b-c-e))+(2^(b-c-e))x(2^(b-c-e))+( 2^(b-c-e))x ...... (마지막 CU까지) ...... (2^(b-c-e))+(2^(b-c-e)))-1 '병렬 CU 분기'는 GSI와 관련하여 새로운 경로를 생성한다. 이러한 경우, 두 가지 경로가 존재하게 된다. 한 경 로에는 '메인 CU 세그먼트'가 있고, 다른 경로에는 '병렬 CU 분기'가 있다. '병렬 CU 분기'는 CU1-PCU1-PCU2- CU4-CU5…… 이 예에서 경로는 CU4에서 절정에 이른다. 병렬 CU 분기는 GSI 생태계에 추가적인 잠재성의 음영을 제공한다. 추가 잠재성의 음영에 대한 정리는 '잠재성의 음영 정리'가 지시하는 것과 정확히 동일하다. 정점 CU 바로 뒤에 각 PCU 및 정점 CU에 대한 정리의 수학적 세그먼트를 삽입해야 한다. 예: …………. x(2^(b-c- e))+(2^(b-c-e))…… 등등. 즉, PCU1-PCU2-CU4에 의해 생성된 음영이다. 정점 CU4 음영은 이전 병렬 CU 분기의 PCU로부터 CU4에서 생성된 이벤트에 의해 영향을 받는다. 예: CU4가 4개의 가변 BET를 갖고 병렬 분기로부터 그 안에 생성된 이벤트가 2인 경우, 허용된 CES는 2^(4-2)가 되며, 이는 4개의 허용된 CES(또는 추가 잠재성의 음 영)이다. 병렬 CU 분기를 포함하는 잠재성의 총 음영은, '1' 아래에 열거된 표준 정리에, 병렬 CU 분기가 기여 하는 잠재성 마이너스 1의 음영을 곱한 것에 의해 안내된다. 따라서 평행 분기가 존재하는 잠재성의 음영에 대 한 정리는 다음과 같이 말할 수 있다: (메인 경로의 잠재성의 음영)x(병렬 CU 분기가 기여하는 잠재성의 음영)-1. 병렬 CU 분기와 관련된 수학적 세그먼트는 정점 CU 바로 뒤에 삽입하는 것이 권고된다. 정보 출처에서의 애플리케이션: 정보의 개념화에서 뚜렷하고 불연속적인 모든 것이 정보이다. 따라서 모든 것은 섭스트레이트에 관계없이 정보를 제공한다. 예: 섭스트레이트가 '물리적', '생명체', 이미지 또는 자연 언어인 지 여부에 관계없이, 이들 각각은 다양한 양의 정보를 전달한다. 이 예는 도 42에 나타나 있다. 이 개념화에서 정보는 존재하는 모든 것에 내재되어 있다. Claude Shannon이 개념화한 커뮤니케이션과 관련이 없다. 반면 에이 전트가 인식하거나 에이전트가 무시하거나 에이전트에게 알려지지 않은 정보는 상대적인 정보이다. 이러한 개념 화에서, 구별성/이산성은 '펜'과 같은 절대적인 것 또는 펜이 왼쪽이나 오른쪽에 위치하는 것과 같은 변경 자체 의 본성에 동일하게 적용될 수 있다. '세계가 작동하는 방식'은 에너지가 변경과 변혁을 일으킨다는 것을 나타 낸다. 이는 에너지가 새로운 정보를 생성한다는 것을 의미한다. 실현 불가능한 '절대 영도'의 온대가 가상적으 로 달성된 세상에서는, 더 이상 새로운 정보는 생성될 수 없다. 에너지로 유발된 모든 인식되는 변경은 이벤트 이다. 이벤트는 임의적이거나 제어될 수 있다. 에이전트 시스템에만 있다. 이벤트는 특정 최종 목표를 달성하기 위해 제어된다. 이벤트는 새로운 정보와 동의어이다. 인식된 변환/변경 이벤트와 정보 사이의 라인이 흐려진다. 그들 모두는 동의어이다. NSL은 연결된 이진 개체 또는 'BET'의 형태로 제어된 변경을 구성한다. 모든 것이다 른 이진 개체에 연결된 이진 개체이므로, 에이전트는 이러한 조합 이진 개체 상태의 유리한 지점의 어느 하나에 자신을 배치할 수 있다. 에이전트가 CU의 유리한 위치에 있는 경우, 다운스트림 연결된 BET가 함께 이진 상태를 생성한다. 필름의 프레임과 같은 각각의 상태는 시스템의 다른 프레임과 연결된다. 차이점은 각 프레임이 모든 다운스트림 개체를 포함한다는 것이다. 통계적 특성을 포함하는 NSL의 대부분의 특성은 이러한 각 유리한 지점 에서 적용할 수 있다. 이러한 기능을 모든 유리한 지점에 적용할 수 있는 기능은 바로 정보원에서의 기능 적용 이라 부른다. 예: 개체 'A'가 CU에 도착하는 것과 관련하여 '확률'과 같은 통계 기능을 적용할 수 있다. 유리한 지점이 개체 'A'인 경우, 'A'에 통계적 특성 '확률'을 적용하였다. 동일한 CU에 'A', 'B', 'C' 세 개의 개체 조 합이 있는 경우, 해당 'ABC' 조합 개체 상태에 '확률' 통계 특성을 동일하게 적용할 수 있다. 유리한 지점 'ABC'의 관점에서 볼 때, '확률'의 적용 가능성은 동일하게 유효하다. 과거, 현재 및 미래: 올바른 관점에서 '시간'을 두는 것이 필요하다. 모든 솔루션은 에이전트 시스템의 제어된 변경에서 발생한다. 모든 변경은 제 시간에 일어난다. '시간'이 무엇인지에 대한 질문이 생긴다. NSL은 시간을우주의 총 변화량의 파생물로 본다. NSL은 표준화된 '스케일'을 사용하여 공간을 측정한다. NSL은 방의 길이와 같은 변하지 않는 공간을 다른 변하지 않는 척도 단위로 측정하여 해당 척도의 방에서 반복되는 유닛의 수를 결 정한다. 마찬가지로, NSL은 '시간 단위'라고 부를 수 있는 형태의 표준화된 반복 변화로 우주의 모든 변경을 측 정한다. 시간당 초 수 또는 1년 동안 일출 횟수가 될 수 있다. 세상은 에너지에 의해 구동되는 흐름(flux) 속에 있다. 일부 변경은 예측 가능하고 다른 변경 사항은 예측할 수 없다. 일부 변경은 제어할 수 있고 다른 변경 사 항은 제어할 수 없다. 우주에는 오직 현재만이 존재한다. 과거는 현재의 '기록된 기억'이다. 미래는 현재에 기 록된 기대의 메모리이며, 흥미롭게도 현재는 덧없는 것이다. 나노초, 피코초, 펨토초마다 변화하고 있다. 심지 어 펨토초의 단위조차도 자릿수 차이로 작은 프라그먼트가 있다. 지정된 것보다 작은 시간 단위를 캡처하는 에 이전트 시스템 레벨에는 제한이 있다. 인간 에이전트는 어떤 100분의 1초 미만의 시간도 인식하지 않는다. 인간 에이전트에게 '현재'는 그보다 작을 수 없다. 기계 에이전트의 더 작은 시간 단위를 기록하는 능력이 훨씬 더 높더라도, 인간 에이전트보다 몇 자릿수 더 크다. 이들은 가능한 '현재의 길이'의 가장 작은 단위이지만, 현재 는 에이전트의 선택과 관련이 있다. 예: '현재 무엇을 하고 계십니까?'와 같은 질문에 대해서, 에이전트는 다양 한 방식으로 문맥상 용어 또는 상대적인 용어로 그와 관련될 수 있다. 그것은 이 분, 이 시간, 오늘, 올해 등이 다. 현재의 유리한 지점은 매우 광범위하게 다를 수 있다. 이러한 선택은 의사 소통 방법과 솔루션 구축 방법에 영향을 미친다. '현재'는 절대적으로 존재하지 않는다. '현재'는 일시적이고 상대적이다. 그것은 단지 그것을 정의하거나 바라는 방식에 따라 존재한다. 자연 언어에서 '시제'의 기준점은 현재를 정의하는 방식이다. 누군가 는 '나는 '분/시/일/주/월/년 전에' 이러 저러한 곳에 있었다. 나는 '분/시/일/주/월/년' 이러 저러한 곳에 있 다. 나는 다음 '분/시/일/주/월/년'에는 이러저러한 곳에 있을 것이다. 현재의 개념화는 컨텍스트와 관련이 있 다는 점에 유의하여야 한다. NSL은 어떤 다른 개체와도 마찬가지로 '시간'도 개체로 취급한다(공간도 개체로 취 급되는 것처럼). 다른 개체 또는 어떤 다른 조합과 결합할 때도 자신의 존재 컨텍스트를 규정한다. 개체의 수명 주기: 솔루션 생태계의 모든 개체는 또한 그것과 연관된 수명 주기를 가지고 있다. 솔루션 레벨 개 체는 트랜잭션 레벨 개체에 비해 수명이 더 긴 경향이 있다. 일부 솔루션 구성 요소(예: 주어진 CU)는 다른 구 성 요소에 비해 오래 지속될 수 있다. 모든 개체(솔루션 개체 또는 트랜잭션 개체)에는 연관된 생년월일(생성 시간) 및 소멸 날짜(삭제 시간)가 있다. 삭제된 개체는 설계자가 결정할 수 있는 대로 리포지토리(repository) 에 계속 남아 있을 수 있다. 개체가 수정되면, 이전 양식은 소멸(삭제)되고 새 양식이 탄생(생성)된다. 트랜잭 션 CU는 트랜잭션이 완료될 때까지만 지속된다. 사람과 마찬가지로, 모든 개체가 똑같이 활동하는 것은 아니다. 이는 솔루션 클래스 개체 및 트랜잭션 클래스 개체에 동일하게 적용된다. 일부 개체는 광범위하게 사용된다. 개 체가 트리거 상태에 참여하는 경우, 활성 상태로 간주되며 그렇지 않으면 유휴 상태로 간주된다. NSL API: NSL의 성공은 다른 솔루션 환경과 공존할 수 있는 능력에 가장 크게 의존할 것이다. 웹 서비스와 같은 다른 솔루션 및 솔루션 구성 요소와 원활하게 통합하는 능력은 성공을 위해 매우 중요하다. NSL은 다른 솔루션 환경에 기여하고 동일한 이점을 얻는다. NSL API는 프로세스에서 자연 언어 구성만 사용하여 NSL 프레임워크의 순수성을 보존한다. NSL 문법: NSL 문법은 자연 솔루션 언어 문법을 나타낸다. NSL 문법의 목적은 솔루션을 처리할 목적으로 자연 언어에 애니메이션을 적용할 기본 규칙이나 제약 또는 제한을 설정하는 것이다. NSL 문법은 자연 언어 문법 내 의 문법이다. 즉, NSL 문법은 규칙 또는 제약 또는 제한 내의 규칙 또는 제약 또는 제한에 관한 것이다. 예를 들어, NSL 문법은 자연 언어 문법을 존중하고 그 위에 문법을 오버레이한다. NSL에 의해 형성된 문장은 여전히 자연 언어의 관점에서 문법적으로 정확해야 한다. 솔루션을 효과적으로 처리하기 위해 NSL이 범위 내에서 허용 되는 일부 자유가 있다. NSL은 자연 언어(수학적 구조와 함께)도 코드의 한 형태라는 믿음에 근거한다. 모든 사 람은 아주 어릴 때부터 이것에 익숙하다. 이것은, NSL이 이러한 언어를 언급할 때, '자연'이라는 단어를 사용하 는 이유이다. 인공적으로 생성된 프로그래밍 언어이자 코드의 또 다른 형태인 프로그래밍 언어는 정보 기술 초 기부터 '솔루션 생성'을 취급한다. 그러나 그들은 인간 에이전트를 기계 에이전트로부터 소외시켰다. NSL은 이 이상 현상을 수정한다. 솔루션을 완전히 투명하고, 여러 번 효과적으로 만든다. NSL 및 NSL 문법은 자연 언어를 취하고 품사를 BET로 변환한다. 그렇게 함으로써, NSL은 자연 언어를 애니메이션화 하여 임의의 자연 언어에서 임의의 복잡한 솔루션을 개발한다. NSL 문법은 자연 언어 및 그 문법에 편승한다. 자연 언어는 정보(전통적으로 이해되는 정보)를 위한 반면, NSL 문법은 솔루션을 위한 것이다. NSL 문법은 자연 언어 위에 위치하며, 개체(품사)를 더 완전하게 만들고, NSL 준 수 방식으로 그들을 구조화하며, '개체'를 'BET'로 변환하고, 'BET'는 기술 백본(backbone) 및 NSL 런타임 환경 에 배치된다. NSL 문법은 자연 언어를 애니메이션화 하고, 자연 언어가 환경에서 개체를 감지하고, 환경으로부 터 개체를 선택하고, 사용 가능한 개체에 따라 환경에 영향을 미치고, 에이전트가 목표를 실현하도록 돕고, 자연 언어로 솔루션을 가능하게 한다. NSL 런타임 환경: 임의의 자연 언어 텍스트가 자연 언어 문법을 준수하고 NSL 문법을 준수할 때, 자연 언어 텍 스트는 NSL 런타임 환경에서 작성되어 임의의 복잡성의 임의의 솔루션을 생성할 수 있다. NSL은 프로그래밍 언 어를 완전히 대체한다. 또한, NSL 고유의 기능을 사용하여 솔루션을 강화하고, NSL을 임의의 프로그래밍 언어 기반 솔루션보다 2세대 선점하여 범용 인공 지능 구현을 가속화 한다. 솔루션 NSL 방식의 구축: 도 44는 NSL에서 솔루션 구축 프로세스의 흐름도를 나타낸다. '기본' 레벨에서 솔루션 을 구축하기 위해 다음 접근 방식이 취해진다: 단계 1: 간단한 영어 활성 음성 문장으로, 최종적 또는 전체적 희망 사항을 지정한다. 예: '친구가 편지를 받음' 단계 2: 최종 소원에 이르기까지의 모든 단계를 간단하고 평이한 영어로 지정한다. 예: A. '사람이 편지를 쓴다' B. '소년이 편지를 보낸다' C. '우체부가 편지를 수집한다' D. '친구'가 받은 편지에 이르기까지. 단계 3: 문장을 실행 가능하게 만드는 데 필요한 모든 것을 식별한다. A. 입력: 1. 에이전트: 이 경우 그것은 '사람'이다 2. 사물: 사람이 편지를 쓰려면 다음이 필요하다: i. 펜 ii. 종이 3. 속성: 사물은 속성을 부여해야 할 수 있다. i. 파란색 잉크(솔루션 설계자가 펜에 대해 이를 지정할 수 있음) ii. 어두운 음영(이것은 속성의 속성이다: 아두운 음영 청색 잉크) iii. 흰색(이는 '종이'의 속성일 수 있음) 4. 행동: 위 단계 2의 제1 예에서 '쓰기'는 팔수 행동이다. B. 출력: 위 예시에서 출력은 '글자'이다. 도 45는 NSL의 구축 솔루션 프로세스의 예를 나타낸다. 가장 기본적인 레벨에서, 필요한 것은 위의 '3 단계'를 모두 거치는 것이다. 완성된 NSL 제1 문장은 아래와 같이 읽는다. '사람은 짙은 색의 파란색 잉크 펜과 흰 종이 를 사용하여 편지를 쓴다'. 중요한 모든 입력과 출력은 클래스의 형태로 존재하는 것으로 먼저 인식되어야 한다. 이를 잠재성이라고 한다. A. 사람- 에이전트 B. 쓰기- ('대기' 모드 또는 잠재성 상태일 때, '클래스'임) C. 펜- 사물 D. 종이- 사물 E. 파란색 잉크- 속성 F. 어두운 음영- 속성의 속성 G. 흰색- 속성 H. 편지- 사물 항목 'A' 내지 'G'는 입력이고, 'H'는 위에서 언급한 출력이다. 모든 입력이 도착하고, 모든 입력이 도착한 경우에만, 문장이 출력을 생성한다. 이 경우에는 '편지'이다. 모든 입력은 자격을 갖춘 멤버의 형태로 문장의 클래스에 도착한다. NSL의 용어에서, 멤버가 없는 클래스는 '잠재성 상태'에 있는 것으로 간주되고, 멤버가 도착한 클래스는 '현실 상태'에 있는 것으로 간주된다. 문장 내의 모든 클래스의 모든 멤버가 도착하면, 문장은 아래에 나타낸 바와 같은 방식으로 읽혀진다. '사람 라마'는 어두운 음 영, 파란색 잉크 및 흰색 종이를 사용하여 편지를 썼다. 제1 문장은 중요한 모든 것이 클래스 레벨에서만 회색으로 표시되었다. 멤버가 클래스에 도착하면, 색상이 빨간 색으로 변한다. 클래스 '사람'에 도착한 멤버가 상당히 구별되었기 때문에(예: Rama 대 John 대 Peter), 그러한 멤버가 명확하게 명시되었다. 그러나 도착하는 멤버가 종이나 펜과 같이 차별화되지 않는 경우에는, 색상을 변 경하는 것으로 충분하였다(클래스만 회색이고 멤버가 있는 클래스는 빨간색이다). 차별화 속성 클래스가 사물 앞에 있고 도착하는 멤버가 클래스 뒤에 오는 것에 유의하여야 한다. 예: '사람' 클래스는 '라마'에 의해 계승 되었다. 설계자는 사용자의 이해와 경험을 특별하게 만들기 위해, 노드, 라인, 방향성 설정, 상자, 색상, 윗첨 자, 전환 메커니즘을 사용하는 유연성을 갖는다. 다이얼 돌리기: NSL에서, 팀은 확고한 기반에서 굵은 문장으로부터 평이한 문장으로 토글을 설정하였다. NSL에 서, 모든 언어에 대해 '굵은 문장을 프로그래밍 언어로', 및 '프로그래밍 언어를 굵은 문장으로' 변환하는 프로 세스가 있다. NSL은 다이얼을 돌려서 자연 언어로 직접 솔루션을 구축하고(평평한 문장), 이를 노드 구조의 네 트워크(두꺼운 문장)로 토글할 수 있도록 하려고 한다. NSL 문법 기반 솔루션이 솔루션 개발 프로세스를 상당히 가속화하고 솔루션 개발이 보다 직관적이고 재미있다는 것은 어느 정도 확립되어 있다. 도 47a 내지 도 47c는 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여, 컴퓨터 구현 솔루션을 구축하기 위한 방법을 묘사하는 흐름도를 나타낸다. 이 방법에 따르면, 단계에서, 구축될 솔루션을 나타내는 글로벌 의도 진술이 사용자로부터 컴퓨팅 장치의 프로세서에 의해 수신된다. 전반적인 의도 진술은 자연 언어의 형태로 수신되며, 잠재성 상태로 설정된다. 단계에서, 전체적인 의도 진술과 연관된 하나 이상의 에이전트의 세부사항이 사용자로부터 프로세서에 의해 수신된다. 에이전트는 솔루션을 실행하는 인 간 에이전트 또는 기계 에이전트이다. 하나 이상의 에이전트에 대한 세부 사항은 자연 언어 형태로 수신되고, 각 에이전트는 잠재성 상태로 설정된다. 또한, 단계에서, 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체의 세부사항이 사용자로부터 프로세서에 의해 수신된다. 각 로컬 의도 진술 및 각 개체의 세부 사항은 자연 언어 형식으로 수신되며, 각각 잠재성 상태로 설정된다. 각 로컬 의 도 진술은 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 해당 로컬 의도 진술에 의해 표시된 단계에 참 여한다. 단계에서, 프로세서에 의해 하나 이상의 에이전트가 각 로컬 의도 진술에 할당된다. 로컬 의도 진술에 할당된 에이전트의 세부 사항은 사용자에 의해 수정될 수 있다. 단계에서, 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성이 자연 언어의 형태로 사용자로부터 프로세 서에 의해 수신된다. 또한, 단계에서, 각각의 개체에 대해, 각각의 개체의 특성을 규정하고 각각의 개체 를 해당하는 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성은 자연 언어의 형태로 사용자로부터 프로세서에 의해 수신된다. 단계에서, 각 로컬 의도 진술에 대해, 프로세서에 의해 각각의 로컬 의도 진 술의 개체의 모든 가능한 조합을 기반으로 CES(combinatorial-entity-states) 집합이 형성된다. 각각의 로컬 의 도 진술의 모든 개체를 기반으로 형성된 CES는 트리거 조합 개체 상태(트리거 CES)이며, 집합 내의 각 CES는 잠 재성 상태에 있다. 단계에서, 글로벌 의도 진술과 연관된 단지 하나의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 수신된 로컬 의도 진술의 트리거 CES가 솔루션 구축의 종료로서 식별된다. 단계에서, 전 체 의도 진술과 연관된 하나 이상의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 로컬 의도 진술 간의 관 계가 자연 언어의 형태로 사용자로부터 프로세서에 의해 수신된다. 관계는 하나의 로컬 의도 진술의 트리거 CES 가 솔루션의 다른 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 완료인지 여부를 나 타낸다. 단계에서, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성은 잠재성 상태로 존재하게 되는 경우에, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이 상의 에이전트, 개체 및 속성 각각에 대해, 시작 시간이 프로세서에 의해 기록된다. 또한, 단계에서, 각 각의 전체적인 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태 로 존재하게 되는 경우, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성 각각에 대해, 프로세서에 의해 정지 시간이 기록된다. NSL은 하나 이상의 컴퓨터 시스템에서 구현되거나 이를 포함할 수 있다. 도 48은 컴퓨팅 환경의 일반화된 예를 도시한다. 컴퓨팅 환경은 설명된 실시형태의 사용 또는 기능의 범위에 대해 어떠한 제한도 제안하지않는다. 도 48을 참조하면, 컴퓨팅 환경은 적어도 하나의 처리 장치 및 메모리를 포함한다. 처리 장 치는 컴퓨터 실행 가능 명령을 실행하고, 실제 또는 가상 프로세서일 수 있다. 다중 처리 시스템에서, 다 중 처리 장치는 컴퓨터 실행 가능 명령을 실행하여 처리 능력을 높인다. 메모리는 휘발성 메모리(예를 들 어, 레지스터, 캐시, RAM), 비 휘발성 메모리(예를 들어, ROM, EEPROM, 플래시 메모리 등) 또는 이 둘의 조합일 수 있다. 일부 실시형태에서, 메모리는 설명된 기술을 구현하는 프레임워크를 저장한다. 컴퓨팅 환경은 추가 기능을 가질 수 있다. 예를 들어, 컴퓨팅 환경은 저장소, 하나 이상의 입력 장 치, 하나 이상의 출력 장치 및 하나 이상의 통신 연결을 포함한다. 버스, 컨트롤러 또는 네 트워크와 같은 상호 연결 메커니즘(미도시)은 컴퓨팅 환경의 구성 요소를 상호 연결한다. 일반적으로, 운 영 체제 소프트웨어(미도시)는 컴퓨팅 환경에서 실행되는 다른 소프트웨어에 대한 운영 환경을 제공하고, 컴퓨팅 환경의 구성 요소의 활동을 조정한다. 저장소는 제거 가능하거나 제거 불가능할 수 있으며, 자기 디스크, 자기 테이프 또는 카세트, CD-ROM, CD-RW, DVD 또는 정보를 저장하는 데 사용될 수 있으며 컴퓨팅 환경 내에서 액세스될 수 있는 기타 임의 의 매체를 포함할 수 있다. 일부 실시형태에서, 저장소는 프레임워크에 대한 명령을 저장한다. 입력 장치는 키보드, 마우스, 펜, 트랙볼, 터치 스크린 또는 게임 컨트롤러와 같은 터치 입력 장치, 음성 입력 장치, 스캐닝 장치, 디지털 카메라, 또는 컴퓨팅 환경에 입력을 제공하는 다른 장치일 수 있다. 출 력 장치(들)는 디스플레이, 프린터, 스피커, 또는 컴퓨팅 환경으로부터의 출력을 제공하는 다른 장 치일 수 있다. 통신 연결(들)은 통신 매체를 통해 다른 컴퓨팅 개체로의 통신을 가능하게 한다. 통신 매체는 컴퓨터 실 행 가능 명령, 오디오 또는 비디오 정보, 또는 변조된 데이터 신호의 기타 데이터와 같은 정보를 전달한다. 변 조된 데이터 신호는 신호의 정보를 인코딩하는 방식으로 하나 이상의 특성이 설정되거나 변경된 신호이다. 제한 되지 않는 예로서, 통신 매체는 전기, 광학, RF, 적외선, 음향 또는 기타 캐리어로 구현되는 유선 또는 무선 기 술을 포함한다. 구현은 컴퓨터 판독 가능 매체의 일반적인 컨텍스트에서 설명될 수 있다. 컴퓨터 판독 가능 매체는 컴퓨팅 환경 내에서 액세스할 수 있는 임의의 사용 가능한 매체이다. 제한되지 않는 예로서, 컴퓨팅 환경 내에서 컴퓨 터 판독 가능 매체는 메모리, 저장소, 통신 매체 및 이들의 임의의 조합을 포함한다. 기술된 실시형태를 참조하여, 본 발명의 개시 내용의 원리를 기술하고 예시하였는 바, 기술된 실시형태는 이러 한 원리로부터 벗어나지 않고 배열 및 세부 사항에서 수정될 수 있음을 인식할 것이다. 본 발명의 개시 내용의 원리가 적용될 수 있는 많은 가능한 실시형태의 관점에서, 본 발명에서는 청구범위 및 그 등가물의 범위 및 사 상 내에 올 수 있는 모든 그러한 실시형태를 본 발명의 개시내용으로서 주장한다. 본 발명이 상술한 실시형태와 관련되어 있지만, 당업자는 본 발명이 묘사된 실시형태에 제한되지 않는다는 것을 인식할 것이다. 본 발명의 개시내용은 첨부된 청구범위의 사상 및 범위 내에서 수정 및 변경되어 실시될 수 있 다. 따라서, 이는 본 발명을 한정하는 것이 아니라 예시적인 것으로 간주되어야 한다. 당업자에 의해 이해되는 바와 같이, 전술한 예시, 시연, 및 방법의 단계는 범용 또는 특수 목적 컴퓨터와 같은 프로세서 기반 시스템상의 적절한 코드에 의해 구현될 수 있다. 또한, 본 기술의 상이한 구현은 본 명세서에서 설명된 일부 또는 모든 단계를 상이한 순서로 또는 실질적으로 동시에, 즉 병렬로 수행할 수 있다는 점에 유의 해야 한다. 또한, 기능은 다양한 프로그래밍 언어로 구현될 수 있다. 당업자에 의해 이해되는 바와 같이, 이러 한 코드는 저장된 코드를 실행하기 위해 프로세서 기반 시스템에 의해 액세스될 수 있는, 메모리 칩, 로컬 또는 원격 하드 디스크, 광학 디스크 또는 기타 매체와 같은 하나 이상의 유형의(tangible) 기계 판독 가능 매체에 저장될 수 있거나 또는 저장되도록 구성될 수 있다. 유형의 매체는 종이 또는 지침이 인쇄되는 다른 적절한 매 체를 포함할 수 있음에 유의해야 한다. 예를 들어, 명령은 종이 또는 다른 매체의 광학 스캐닝을 통해 전자적으 로 캡처된 다음, 필요한 경우 적절한 방식으로 컴파일, 해석 또는 처리되고, 컴퓨터 메모리에 저장될 수 있다. 상세한 설명은 당업자가 본 개시 내용을 만들고 사용할 수 있도록 제시되고, 특허 획득을 위한 요건의 컨텍스트 에서 제공된다. 본 설명은 본 발명의 개시 내용을 수행하기 위해 현재 고려되는 최선의 방법이다. 바람직한 실 시형태에 대한 다양한 수정은 당업자에게 명백할 것이며, 본 개시 내용의 일반적인 원리는 다른 실시형태에 적 용될 수 있고, 본 개시 내용의 일부 특징은 다른 특징의 해당하는 사용 없이 사용될 수 있다. 따라서, 본 개시 내용은 도시된 실시형태로 제한되는 것이 아니라 본 명세서에 설명된 원리 및 특징과 일치하는 가장 넓은 범위에 부합되어야 한다. 일 구현 예에 따르면, 본 발명은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴 퓨터 구현 솔루션을 구축하는 방법에 관한 것으로, 상기 방법은 다음 단계를 포함한다: 사용자의 컴퓨팅 장치의 프로세서에 의해, 구축될 솔루션을 나타내는 글로벌 의도 진술을 수신하는 단계로서, 글로벌 의도 진술이 자연 언어의 형태로 수신되고 잠재성 상태로 설정되는, 수신 단계; 사용자의 프로세서에 의해, 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술의 세부 사항을 수신하는 단계로서, 에이전트가 솔루션을 실행하는 인간 에 이전트 또는 기계 에이전트이며, 하나 이상의 에이전트의 세부 사항이 자연 언어의 형태로 수신되고, 각 에이전 트는 잠재성 상태로 설정되는, 수신 단계; 사용자의 프로세서에 의해, 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체의 세부사항을 수신하는 단계로서, 각 로컬 의도 진술 및 각 개체의 세부사항이 자연 언어의 형태로 수신되며 잠재성 상태로 각각 설정되며, 각 로컬 의도 진술은 솔루션 을 구축하기 위한 단계를 나타내며, 각 개체는 해당 로컬 의도 진술에 의해 표시된 단계에 참여하는, 수신 단계; 프로세서에 의해, 각 로컬 의도 진술에 하나 이상의 에이전트를 할당하는 단계로서, 로컬 의도 진술에 할 당된 에이전트의 세부 사항은 사용자에 의해 수정 가능한 할당 단계; 각 로컬 의도 진술에 대해, 사용자의 프로 세서에 의해 자연 언어 형태로 각각의 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성을 수신하는 단계; 각 개체에 대해, 사용자의 프로세서에 의해 자연 언어 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당하는 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 수신하는 단계; 프로세서에 의해, 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 하는 조합 개체 상태 (CES)의 집합을 형성하는 단계로서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES가 잠재성 상태에 있는, 집합 형성 단계; 글로벌 의도 진술과 연 관된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 수신된 로컬 의도 진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 단계; 글로벌 의도 진술과 연관된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 응답하여, 사용자의 프로세서에 의해 자연 언어 형태로 로컬 의도 진술들 간의 관계를 수신하는 단계로서, 관계 는 하나의 로컬 의도 진술의 트리거 CES가 솔루션의 다른 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 종료인지 여부를 나타내는, 수신 단계; 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 프로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상태로 존재하게 되는 경우의 시작 시간을 기록하는 단계; 및 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속 성에 대해, 프로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 종료 시간을 기록하는 단계. 예시적인 구현에 따르면, 상술한 방법은, 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 프로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상태로 존재하게 되는 경우의 지오그래픽 위치 좌표를 기록하 는 단계를 포함한다. 예시적인 구현에 따르면, 상술한 방법은, 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 프로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 지오그래픽 위치 좌표를 기록하는 단계를 포함한다. 일 예시적인 구현에 따르면, 상술한 방법은 다음 단계를 포함한다: 로컬 의도 진술에 대해, 사용자의 프로세서 에 의해 자연 언어 형태로, 하나 이상의 하위 로컬 의도 진술 및 각 하위 로컬 의도 진술과 연관된 개체의 세부 사항을 수신하는 단계로서, 각 하위 로컬 의도 진술 및 각 개체가 각각 잠재성 상태로 설정되고, 각 하위 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내고, 각 개체는 해당 하위 로컬 의도 진술에 의해 표시된 단 계에 참여하는, 수신 단계; 프로세서에 의해, 각 하위 로컬 의도 진술에 하나 이상의 에이전트를 할당하는 단계 로서, 로컬 의도 진술에 할당된 에이전트의 세부 사항이 사용자에 의해 수정 가능한 할당 단계; 각 하위 로컬 의도 진술에 대해, 사용자의 프로세서에 의해 자연 언어 형태로, 각각의 하위 로컬 의도 진술의 특성을 규정하 는 하나 이상의 속성을 수신하는 단계; 각 개체에 대해, 사용자의 프로세서에 의해 자연 언어 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당하는 하위 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 수신하는 단계; 프로세서에 의해, 각 하위 로컬 의도 진술에 대해, 각각의 하위 로컬 의도 진술의 개체 의 모든 가능한 조합을 기반으로 하는 CES의 집합을 형성하는 단계로서, 각각의 하위 로컬 의도 진술의 모든 개 체를 기반으로 형성된 CES가 트리거 CES이고, 집합 내의 각 CES가 잠재성 상태에 있는, 집합 형성 단계; 사용자의 프로세서에 의해 자연 언어 형태로, 로컬 의도 진술들 간의 관계 및 하나 이상의 하위 로컬 의도 진술을 수 신하는 단계로서, 관계는, 하나의 로컬 의도 진술의 트리거 CES가 하위 로컬 의도 진술의 CES 집합에 영향을 미 치고 있는지의 여부를 나타내고, 그리고 관계는 하나의 하위 로컬 의도 진술의 트리거 CES가 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 종료인지 여부를 나타내는, 수신 단계. 예시적인 구현에 따르면, 솔루션이 실행될 때, 상술한 방법은 다음 단계를 포함한다: 로컬 의도 진술에 대해, 에이전트의 프로세서에 의해 자연 언어 형태로, 하나 이상의 하위 로컬 의도 진술 및 각 하위 로컬 의도 진술과 연관된 개체의 세부 사항을 수신하는 단계로서, 각 하위 로컬 의도 진술 및 각 개체가 각각 잠재성 상태로 설정 되고, 각 하위 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내고, 각 개체는 해당 하위 로컬 의도 진 술에 표시된 단계에 참여하는, 수신 단계; 프로세서에 의해, 각 하위 로컬 의도 진술에 하나 이상의 에이전트를 할당하는 단계로서, 하위 로컬 의도 진술에 할당된 에이전트의 세부 사항이 에이전트에 의해 수정 가능한 할당 단계; 각 하위 로컬 의도 진술에 대해, 자연 언어의 형태로 에이전트의 프로세서에 의해, 각각의 하위 로컬 의 도 진술의 특성을 규정하는 하나 이상의 속성을 수신하는 단계; 각 개체에 대해, 자연 언어의 형태로 에이전트 의 프로세서에 의해, 각각의 개체의 특성을 규정하고 각각의 개체를 해당하는 하위 로컬 의도 진술의 다른 개체 와 차별화하는 하나 이상의 속성을 수신하는 단계; 프로세서에 의해, 각 하위 로컬 의도 진술에 대해, 각각의 하위 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 하는 CES의 집합을 형성하는 단계로서, 각각의 하 위 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 CES이고, 집합 내의 각 CES가 잠재성 상태에 있는 집합 형성 단계; 및 에이전트의 프로세서에 의해 자연 언어 형태로, 로컬 의도 진술과 하나 이상의 하위 로컬 의도 진술 간의 관계를 수신하는 단계로서, 관계는, 하나의 하위 로컬 의도 진술의 트리거 CES가 다른 하 위 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 로컬 의도 진술의 CES 집합에 영향을 미치고 있는 지를 나타내는, 수신 단계. 예시적인 구현에 따르면, 상술한 방법은, 각 로컬 의도 진술의 각 개체에 대해, 연관된 에이전트의 프로세서에 의해, 각각의 개체에 대한 값을 수신하는 단계를 포함하고, 여기서 각각의 개체에 대한 값을 수신하는 단계는, 수신된 값을 기반으로, 잠재성 상태를 각각의 개체에 대한 현실 상태로 변경시키는 이벤트의 기록이며, 값은 자 연 언어, 프로그래밍 언어, 이미지, 생체 인식, 및 제스처의 형태의 입력이고, 자연 언어는 텍스트 또는 음성 형태이다. 예시적인 구현에 따르면, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성 중 적어도 하나는, 하나 이상의 미리 규정된 조건이 충족되면, 솔루션을 실행하는 동안 잠재성 상태로 존재하게 된다. 예시적인 구현에 따르면, 상술한 방법은, 사용자의 프로세서에 의해 자연 언어 형태로, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성과 연관된 정보가 솔루션의 실행 중에 수신되는 사 용자 인터페이스를 구성하기 위해 사용자 입력을 수신하는 단계를 포함하고, 여기서 사용자 인터페이스는 디스 플레이 장치의 디스플레이 속성을 기반으로 동적으로 조정 가능하다. 예시적인 구현에 따르면, 상술한 방법은, 프로세서에 의해, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하 나 이상의 에이전트, 개체 및 속성과 연관된 수신된 정보를 분석하는 단계; 및 프로세서에 의해, 자연 솔루션 언어 문법 데이터베이스와의 통신을 기반으로 분석된 정보를 수정하여 정보에서 하나 이상의 문법 수정을 수행 하는 단계를 포함한다. 예시적인 구현에 따르면, 상술한 방법은, 프로세서에 의해, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하 나 이상의 에이전트, 개체 및 속성과 연관된 수신된 정보를 분석하는 단계; 및 프로세서에 의해, 자연 솔루션 언어 문법 데이터베이스와의 통신을 기반으로 분석된 정보로부터 중복 텍스트를 제거하는 단계를 포함한다. 예시적인 구현에 따르면, 상술한 방법은, 프로세서에 의해, 수신된 글로벌 의도 진술을 기반으로, 하나 이상의 로컬 의도 진술, 또는 하나 이상의 에이전트, 또는 하나 이상의 개체, 또는 하나 이상의 속성, 또는 이들의 조 합을 자동 덧붙이는(auto-populating) 단계를 포함하고, 여기서 자동 덧붙임은 자연 솔루션 언어 문법 데이터베 이스와의 통신을 기반으로 한다. 예시적인 구현에 따르면, 로컬 의도 진술은 2 이상의 병렬 로컬 의도 진술을 포함하며, 여기서 하나의 로컬 의 도 진술의 트리거 CES는 2 이상의 병렬 로컬 의도 진술의 CES 집합에 영향을 미치고, 그리고 2 이상의 병렬 로 컬 의도 진술의 트리거 CES는 또 다른 로컬 의도 진술의 CES 집합에 영향을 미치거나 솔루션 구축의 종료이다. 예시적인 구현에 따르면, 로컬 의도 진술은 2 이상의 대체 로컬 의도 진술을 포함하며, 여기서 하나의 로컬 의 도 진술의 트리거 CES는 2 이상의 대체(alternate) 로컬 의도 진술의 CES 집합에 영향을 미치고, 그리고 2 이상 의 대체 로컬 의도 진술의 트리거 CES는 또 다른 로컬 의도 진술의 CES 집합에 영향을 미치거나 솔루션 구축의 종료이다. 예시적인 구현에 따르면, 로컬 의도 진술은 내포된 로컬 의도 진술을 포함하고, 여기서 내포된 로컬 의도 진술 의 트리거 CES는 다른 솔루션의 로컬 의도 진술의 CES 집합에 영향을 미친다. 예시적인 구현에 따르면, 로컬 의도 진술은 반복 로컬 의도 진술을 포함하고, 여기서 반복 로컬 의도 진술의 트 리거 CES는 다른 로컬 의도 진술의 CES 집합에 영향을 미치거나 또는 N 반복 후 솔루션 구축(여기서 N은 1보다 큼)의 종료이다. 예시적인 구현에 따르면, 상술한 방법은, 사용자의 프로세서에 의해 자연 언어 형태로, 로컬 의도 진술과 연관 된 2 이상의 대체(substitute) 개체의 세부 사항을 수신하는 단계를 포함하며, 여기서 2 이상의 대체 개체 각각 은 잠재성 상태로 각각 설정되며, 2 이상의 대체 개체 중 하나는 해당 로컬 의도 진술에 의해 표시된 단계에 참 여하고, 2 이상의 대체 개체 중 다른 하나는 트리거 CES의 일부가 아니다. 예시적인 구현에 따르면, 상술한 방법은 프로세서에 의해, 다음 식을 기반으로 솔루션과 연관된 다수의 잠재성 상태를 결정하는 단계를 포함한다: ((2^(b1-c1-e1))x(2^(b2-c2-e2))+(2^(b2-c2-e2))x(2^(b3-c3-e3))+........+(2^(bK-1-cK-1-eK-1)) x (2^(bK-cK- eK))+(2^(bK-cK-eK)))-1 상기 식에서, K는 로컬 의도 진술의 총 수이고, bi는 i번째 로컬 의도 진술과 연관된 개체, 속성, 및 에이전트의 총 수이고, ci는 상수인 i번째 로컬 의도 진술과 연관된 개체, 속성 및 에이전트의 총 수이고, ei는 i번째 로컬 의도 진술에 영향을 미치는 트리거 CES의 수이다. 예시적인 구현에 따르면, 상술한 방법은, 프로세서에 의해, 하나 이상의 자연 솔루션 언어 응용 프로그래밍 인 터페이스(NSL API)를 사용하여 외부 시스템과 통신하는 단계를 포함한다. 예시적인 구현에 따르면, 상술한 방법은, 프로세서에 의해, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하 나 이상의 개체, 하나 이상의 속성, 하나 이상의 에이전트의 값을 기반으로 하나 이상의 리포트를 생성하는 단 계를 포함하고, 여기서 하나 이상의 리포트는 하나 이상의 미리 규정된 기술을 기반으로 생성된다. 예시적인 구현에 따르면, 상술한 방법은, 프로세서에 의해, 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하 나 이상의 개체, 하나 이상의 속성, 하나 이상의 에이전트의 값을 분석하는 단계; 및 프로세서에 의해, 분석을 기반으로 하나 이상의 논리적 추론을 도출하는 단계를 포함하고, 여기서 하나 이상의 논리적 추론은 하나 이상 의 미리 규정된 모델을 기반으로 도출된다. 예시적인 구현에 따르면, 상술한 방법은, 로컬 의도 진술과 연관된 에이전트가 기계 에이전트인 경우, 다음 단 계를 포함한다: 로봇 프로세스 자동화 엔진으로부터의 프로세서에 의해, 로컬 의도 진술에 대한 새로운 하위 로 컬 의도 진술 및 새로운 하위 로컬 의도 진술에 대한 하나 이상의 새로운 개체 및 속성을 추가하기 위한 입력을 수신하는 단계; 로봇 프로세스 자동화 엔진으로부터의 프로세서에 의해, 하나 이상의 새로운 개체 및 속성을 로 컬 의도 진술에 추가하기 위한 입력을 수신하는 단계; 또는 로봇 프로세스 자동화 엔진으로부터의 프로세서에 의해, 로컬 의도 진술 또는 연관된 개체 또는 연관된 속성을 수정하기 위한 입력을 수신하는 단계. 예시적인 구현에 따르면, 본 발명은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하는 방법에 관한 것으로, 이 방법은 다음 단계를 포함한다: 컴퓨팅 장치의 프로세서 에 의해, 구축될 솔루션을 나타내는 글로벌 의도 진술을 입력하도록 사용자에게 프롬프트를 제공하는 단계로서, 글로벌 의도 진술이 자연 언어의 형태로 수신되고 잠재성 상태로 설정되는 프롬프트 제공 단계; 프로세서에 의 해, 글로벌 의도 진술과 연관된 하나 이상의 에이전트의 세부 사항을 입력하도록 사용자에게 프롬프트를 제공하 는 단계로서, 에이전트가 솔루션을 실행하는 인간 에이전트 또는 기계 에이전트이며, 하나 이상의 에이전트의 세부 사항이 자연 언어 형태로 수신되고 각 에이전트가 잠재성 상태로 설정되는 프롬프트 제공 단계; 프로세서에 의해, 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체의 세부 사항을 입력하도록 사용자에게 프롬프트를 제공하는 단계로서, 각 로컬 의도 진술 및 각 개체의 세부사항이 자 연 언어의 형태로 수신되고 잠재성 상태로 각각 설정되며, 각 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 해당 로컬 의도 진술에 의해 표시된 단계에 참여하는 프롬프트 제공 단계; 프로세서에 의 해, 하나 이상의 에이전트를 각 로컬 의도 진술에 할당하는 단계로서, 로컬 의도 진술에 할당된 에이전트의 세 부 사항이 사용자에 의해 수정 가능한 할당 단계; 각 로컬 의도 진술에 대해, 프로세서에 의해, 각각의 로컬 의 도 진술의 특성을 규정하는 하나 이상의 속성을 자연 언어의 형태로 입력하도록 사용자에게 프롬프트를 제공하 는 단계; 프로세서에 의해, 각각의 개체의 특성을 규정하고 각각의 개체를 해당 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 자연 언어 형태로 입력하도록 사용자에게 프롬프트를 제공하는 단계; 프로세서 에 의해, 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 한 조합 개 체 상태(CES) 집합을 형성하는 단계로서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES가 잠재성 상태에 있는 조합 개체 상태의 형성단계; 글로벌 의도 진술과 연관된 단지 하나의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 솔루션 구축의 종료로서 수 신된 로컬 의도 진술의 트리거 CES를 식별하는 단계; 글로벌 의도 진술과 연관된 하나 이상의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 프로세서에 의해b 로컬 의도 진술들 간의 관계를 자연 언어의 형태로 입력하도 록 사용자에게 프롬프트를 제공하는 단계로서, 관계는, 하나의 로컬 의도 진술의 트리거 CES가 솔루션의 다른 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 종료인지를 나타내는, 프롬프트 제공 단계; 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 프 로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속 성이 잠재성 상태로 존재하게 되는 경우의 시작 시간을 기록하는 단계; 및 각각의 글로벌 의도 진술, 하나 이상 의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 프로세서에 의해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 정 지 시간을 기록하는 단계. 예시적인 구현에 따르면, 본 발명은, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하 여 컴퓨터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 컴퓨팅 장치는, 프로세서; 및 다음 단계를 수행하도록 프로세서에 의해 수행 가능한 명령을 포함하고 프로세서에 결합된 메모리를 포함한다: 구축될 솔루 션을 나타내는 글로벌 의도 진술을 사용자로부터 수신하는 단계로서, 글로벌 의도 진술이 자연 언어의 형태로 수신되고 잠재성 상태로 설정되는, 글로벌 의도 진술의 수신 단계; 사용자로부터, 글로벌 의도 진술과 연관된 하나 이상의 에이전트의 세부 사항을 수신하는 단계로서, 에이전트가 솔루션을 실행하는 인간 에이전트 또는 기 계 에이전트이며, 하나 이상의 에이전트의 세부 사항이 자연 언어의 형태로 수신되고, 각 에이전트가 잠재성 상 태로 설정되는, 에이전트의 세부 사항 수신 단계; 사용자로부터, 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체의 세부사항을 수신하는 단계로서, 각 로컬 의도 진술 및 각 개 체의 세부사항이 자연 언어의 형태로 수신되고 잠재성 상태로 각각 설정되고, 각 로컬 의도 진술이 솔루션을 구 축하기 위한 단계를 나타내고, 각 개체는 해당 로컬 의도 진술에 의해 표시된 단계에 참여하는, 수신 단계; 하 나 이상의 에이전트를 각 로컬 의도 진술에 할당하는 단계로서, 로컬 의도 진술에 할당된 에이전트의 세부 사항 이 사용자에 의해 수정 가능한 할당 단계; 각 로컬 의도 진술에 대해, 사용자로부터 자연 언어의 형태로, 각각 의 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성을 수신하는 단계; 각 개체에 대해, 사용자로부터 자연 언어의 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 수신하는 단계; 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 하는 조합 개체 상태(CES) 집합을 형성하는 단계로서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES가 잠재성 상태에 있는 조합 개체 상태 집합의 형성 단계; 글로벌 의도 진술과 연관된 단지 하나의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 수신된 로컬 의도 진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 단계; 글로벌 의도 진술과 연관된 하나 이상의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 사용자로부터 자연 언어의 형태로, 로컬 의도 진술들 간의 관계를 수신하는 단계로서, 관계는, 하나의 로컬 의도 진술의 트리거 CES가 솔루션의 다른 로 컬 의도 진술의 CES 집합에 영향을 미치거나 솔루션의 구축 종료인지 여부를 나타내는, 수신 단계; 각각의 글로 벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상태로 존재하게 되는 경우의 시작 시간을 기록하는 수단: 및 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에 이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 정지 시간을 기록하는 단계. 예시적인 구현에 따르면, 본 발명은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 컴퓨팅 장치는 다음의 수단을 포함한다: 사용 자로부터, 구축될 솔루션을 나타내는 글로벌 의도 진술을 수신하는 수단으로서, 글로벌 의도 진술이 자연 언어 의 형태로 수신되고 잠재성 상태로 설정되는 수신 수단; 사용자로부터, 글로벌 의도 진술과 연관된 하나 이상의 에이전트의 세부 사항을 수신하는 수단으로서, 에이전트가 솔루션을 실행하는 인간 에이전트 또는 기계 에이전 트이며, 하나 이상의 에이전트의 세부 사항이 자연 언어의 형태로 수신되고, 각 에이전트가 잠재성 상태로 설정 되는 수신 수단; 사용자로부터, 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술 과 연관된 개체의 세부사항을 수신하는 수단으로서, 각 로컬 의도 진술 및 각 개체의 세부사항이 자연 언어의 형태로 수신되고 잠재성 상태로 각각 설정되고, 각 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내고, 각 개체가 해당 로컬 의도 진술에 의해 표시된 단계에 참여하는, 수신 수단; 하나 이상의 에이전트를 각 로컬 의도 진술에 할당하는 수단으로서, 로컬 의도 진술에 할당된 에이전트의 세부 사항이 사용자에 의해 수정 가능 한 할당 수단; 각 로컬 의도 진술에 대해, 사용자로부터 자연 언어의 형태로, 각각의 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성을 수신하는 수단; 각 개체에 대해, 사용자로부터 자연 언어의 형태로, 각각의 개체 의 특성을 규정하고 각각의 개체를 해당 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 수신하 는 수단; 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 하는 조합 개체 상태(CES) 집합을 형성하는 수단으로서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트 리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES가 잠재성 상태에 있는 조합 개체 상태의 형성 수단; 글로벌 의도 진술과 연관된 단지 하나의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 수신된 로컬 의도 진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 수단; 글로벌 의도 진술과 연관된 하나 이상의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 사용자로부터 자연 언어의 형태로 로컬 의도 진술들 간의 관계를 수 신하는 수단으로서, 관계는, 하나의 로컬 의도 진술의 트리거 CES가 솔루션의 다른 로컬 의도 진술의 CES 집합 에 영향을 미치거나 솔루션의 구축 종료인지 여부를 나타내는, 수신 수단; 각각의 글로벌 의도 진술, 하나 이상 의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상태로 존재하게 되는 경우의 시작 시간을 기록 하는 수단: 및 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 정지 시간을 기록하는 수단. 예시적인 구현에 따르면, 본 발명은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 컴퓨팅 장치는, 프로세서; 및 프로세서에 결 합된 메모리로서, 메모리가 상술한 방법을 수행하기 위해 프로세서에 의해 실행 가능한 명령을 포함하는 메모리 를 포함한다. 예시적인 구현에 따르면, 본 발명은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 컴퓨팅 장치는 프로세서; 및 다음 단계를 수 행하도록 프로세서에 의해 수행 가능한 명령을 포함하고 프로세서에 결합된 메모리를 포함한다: 구축될 솔루션 을 나타내는 글로벌 의도 진술을 입력하도록 사용자에게 프롬프트를 제공하는 단계로서, 글로벌 의도 진술이 자 연 언어의 형태로 수신되고 잠재성 상태로 설정되는 프롬프트 제공 단계; 글로벌 의도 진술과 연관된 하나 이상 의 에이전트의 세부 사항을 입력하도록 사용자에게 프롬프트를 제공하는 단계로서, 에이전트가 솔루션을 실행하 는 인간 에이전트 또는 기계 에이전트이며, 하나 이상의 에이전트의 세부 사항이 자연 언어 형태로 수신되고 각 에이전트가 잠재성 상태로 설정되는 프롬프트 제공 단계; 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진 술 및 각 로컬 의도 진술과 연관된 개체의 세부사항을 입력하도록 사용자에게 프롬프트를 제공하는 단계로서, 각 로컬 의도 진술 및 각 개체의 세부사항이 자연 언어의 형태로 수신되고 잠재성 상태로 각각 설정되며, 각 로 컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 해당 로컬 의도 진술에 의해 표시된 단계 에 참여하는 프롬프트 제공 단계; 하나 이상의 에이전트를 각 로컬 의도 진술에 할당하는 단계로서, 로컬 의도 진술에 할당된 에이전트의 세부 사항이 사용자에 의해 수정 가능한 할당 단계; 각 로컬 의도 진술에 대해, 자연 언어의 형태로, 각각의 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성을 입력하도록 사용자에게 프롬프트 를 제공하는 단계; 각 개체에 대해, 자연 언어 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당 로 컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 입력하도록 사용자에게 프롬프트를 제공하는 단계; 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 조합 개체 상태(CES) 집합을 형성하는 단계로서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES가 잠재성 상태로 있는 조합 개체 상태 집합의 형성단계; 글로벌 의도 진 술과 연관된 단지 하나의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 수신된 로컬 의도 진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 단계; 글로벌 의도 진술과 연관된 하나 이상의 수신된 로컬 의도 진술 을 결정하는 것에 응답하여, 자연 언어의 형태로, 로컬 의도 진술들 간의 관계를 입력하도록 사용자에게 프롬프 트를 제공하는 단계로서, 관계는, 하나의 로컬 의도 진술의 트리거 CES가 솔루션의 다른 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 종료인지 여부를 나타내는, 프롬프트 제공 단계; 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성의 각각에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상태로 존재하게 되는 경우의 시작 시간을 기록하는 단계; 및 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성의 각각에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 정지 시간을 기록하는 단계. 예시적인 구현에 따르면, 본 발명은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 컴퓨팅 장치는 다음의 수단을 포함한다: 구축 될 솔루션을 나타내는 글로벌 의도 진술을 입력하도록 사용자에게 프롬프트를 제공하는 수단으로서, 글로벌 의 도 진술이 자연 언어 형태로 수신되고 잠재성 상태로 설정되는 프롬프트 제공 수단; 글로벌 의도 진술과 연관된 하나 이상의 에이전트의 세부 사항을 입력하도록 사용자에게 프롬프트를 제공하는 수단으로서, 에이전트가 인간 에이전트 또는 솔루션을 실행하는 기계 에이전트이며, 하나 이상의 에이전트의 세부 사항이 자연 언어 형태로 수신되고 각 에이전트가 잠재성 상태로 설정되는 프롬프트 제공 수단; 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체의 세부사항을 입력하도록 사용자에게 프롬프트를 제공하는 수단으로서, 각 로컬 의도 진술 및 각 개체의 세부사항이 자연 언어의 형태로 수신되고 잠재성 상태로 각각 설 정되며, 각 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 해당 로컬 의도 진술에 의해 표시된 단계에 참여하는 프롬프트 제공 수단; 하나 이상의 에이전트를 각 로컬 의도 진술에 할당하는 수단으로 서, 로컬 의도 진술에 할당된 에이전트의 세부 사항이 사용자에 의해 수정 가능한 할당 수단; 각 로컬 의도 진 술에 대해, 각각의 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성을 자연 언어의 형태로 입력하도록 사용 자에게 프롬프트를 제공하는 수단; 각 개체에 대해, 자연 언어 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 입력하도록 사용자에게 프롬프트를 제공하는 수단; 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 한 조합 개체 상태(CES) 집합을 형성하는 수단으로서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES 가 트리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES가 잠재성 상태로 있는 조합 개체 상태 집합의 형 성수단; 글로벌 의도 진술과 연관된 단지 하나의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 수신된 로 컬 의도 진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 수단; 글로벌 의도 진술과 연관된 하나 이상의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 자연 언어의 형태로, 로컬 의도 진술들 간의 관계를 입력하 도록 사용자에게 프롬프트를 제공하는 수단으로서, 관계는, 하나의 로컬 의도 진술의 트리거 CES가 솔루션의 다 른 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 종료인지 여부를 나타내는, 프롬프 트 제공 수단; 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재 성 상태로 존재하게 되는 경우의 시작 시간을 기록하는 수단; 및 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각 각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 정지 시간을 기록하는 수단. 예시적인 구현에 따르면, 본 발명은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 컴퓨팅 장치는 프로세서; 및 프로세서에 결합 되고 상술한 방법을 수행하도록 프로세서에 의해 수행 가능한 명령을 포함하는 메모리를 포함한다. 예시적인 구현에 따르면, 본 발명은, 프로세서에 의해 실행될 때 프로세스가 다음 단계를 수행하게 하는 기계 실행 가능 코드를 포함하는 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한 명령을 저장한 비 일시적 컴퓨터 판독 가능 매체에 관한 것이다: 사용자로부터, 구축될 솔루션을 나타내는 글로벌 의도 진술을 수신하는 단계로서, 글로벌 의도 진술이 자연 언어의 형태로 수 신되고 잠재성 상태로 설정되는, 글로벌 의도 진술의 수신 단계; 사용자로부터, 글로벌 의도 진술과 연관된 하 나 이상의 에이전트의 세부 사항을 수신하는 단계로서, 에이전트가 솔루션을 실행하는 인간 에이전트 또는 기계 에이전트이며, 하나 이상의 에이전트의 세부 사항이 자연 언어의 형태로 수신되고, 각 에이전트가 잠재성 상태 로 설정되는, 에이전트의 세부 사항 수신 단계; 사용자로부터, 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체의 세부사항을 수신하는 단계로서, 각 로컬 의도 진술 및 각 개체 의 세부사항은 자연 언어의 형태로 수신되고 잠재성 상태로 각각 설정되고, 각 로컬 의도 진술은 솔루션을 구축 하기 위한 단계를 나타내고, 각 개체는 해당 로컬 의도 진술에 의해 표시된 단계에 참여하는, 수신 단계; 하나 이상의 에이전트를 각 로컬 의도 진술에 할당하는 단계로서, 로컬 의도 진술에 할당된 에이전트의 세부 사항이 사용자에 의해 수정 가능한 할당 단계; 각 로컬 의도 진술에 대해, 사용자로부터 자연 언어의 형태로, 각각의 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성을 수신하는 단계; 각 개체에 대해, 사용자로부터 자연 언 어의 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당 로컬 의도 진술의 다른 개체와 차별화하는 하 나 이상의 속성을 수신하는 단계; 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조 합을 기반으로 하는 조합 개체 상태(CES) 집합을 형성하는 단계로서, 각각의 로컬 의도 진술의 모든 개체를 기 반으로 형성된 CES가 트리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES가 잠재성 상태로 있는 조합 개 체 상태 집합의 형성 단계; 글로벌 의도 진술과 연관된 단지 하나의 수신된 로컬 의도 진술을 결정하는 것에 응 답하여, 수신된 로컬 의도 진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 단계; 글로벌 의도 진술과 연 관된 하나 이상의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 사용자로부터 자연 언어의 형태로, 로컬 의도 진술들 간의 관계를 수신하는 단계로서, 관계는, 하나의 로컬 의도 진술의 트리거 CES가 솔루션의 다른 로 컬 의도 진술의 CES 집합에 영향을 미치거나 솔루션의 구축 종료인지 여부를 나타내는, 로컬 의도 진술들 간의 관계 수신 단계; 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성 에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상태로 존재하게 되는 경우의 시작 시간을 기록하는 수단: 및 각각의 글로벌 의도 진술, 하나 이상의 로 컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 정지 시간을 기록하는 단계. 예시적인 구현에 따르면, 본 발명은, 프로세서에 의해 실행될 때 프로세스가 다음 단계를 수행하게 하는 기계 실행 가능 코드를 포함하는 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한 명령을 저장한 비 일시적 컴퓨터 판독 가능 매체에 관한 것이다: 구축될 솔루션을 나타내는 글로벌 의도 진술을 입력하도록 사용자에게 프롬프트를 제공하는 단계로서, 글로벌 의도 진술이 자연 언어의 형태로 수신되고 잠재성 상태로 설정되는 프롬프트 제공 단계; 글로벌 의도 진술과 연관된 하나 이상의 에이전트의 세부 사항을 입력하도록 사용자에게 프롬프트를 제공하는 단계로서, 에이전트가 솔루션을 실행하는 인간 에이전트 또는 기계 에이전트이며, 하나 이상의 에이전트의 세부 사항이 자연 언어 형태로 수신되고 각 에 이전트가 잠재성 상태로 설정되는 프롬프트 제공 단계; 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체의 세부사항을 입력하도록 사용자에게 프롬프트를 제공하는 단계로서, 각 로컬 의도 진술 및 각 개체의 세부사항이 자연 언어의 형태로 수신되고 잠재성 상태로 각각 설정되며, 각 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내며, 각 개체가 해당 로컬 의도 진술에 의해 표시된 단계에 참여하는 프롬프트 제공 단계; 하나 이상의 에이전트를 각 로컬 의도 진술에 할당하는 단계로서, 로컬 의도 진 술에 할당된 에이전트의 세부 사항이 사용자에 의해 수정 가능한 할당 단계; 각 로컬 의도 진술에 대해, 자연 언어의 형태로, 각각의 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성을 입력하도록 사용자에게 프롬프트 를 제공하는 단계; 각 개체에 대해, 자연 언어의 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당 로컬 의도 진술의 다른 개체와 차별화하는 하나 이상의 속성을 입력하도록 사용자에게 프롬프트를 제공하는 단 계; 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 한 조합 개체 상 태(CES) 집합을 형성하는 단계로서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 조합 개체 상태(트리거 CES)이고, 집합 내의 각 CES는 잠재성 상태로 있는 조합 개체 상태 집합의 형성단계; 글로벌 의도 진술과 연관된 단지 하나의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 수신된 로컬 의도 진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 단계; 글로벌 의도 진술과 연관된 하나 이상의 수신된 로컬 의 도 진술을 결정하는 것에 응답하여, 자연 언어의 형태로, 로컬 의도 진술들 간의 관계를 입력하도록 사용자에게 프롬프트를 제공하는 단계로서, 관계는, 하나의 로컬 의도 진술의 트리거 CES가 솔루션의 다른 로컬 의도 진술 의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 종료인지 여부를 나타내는, 프롬프트 제공 단계; 각각 의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로 벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상태로 존재하 게 되는 경우의 시작 시간을 기록하는 단계; 및 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 정지 시간을 기록하는 단계.예시적인 구현에 따르면, 본 발명은, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하 여 컴퓨터 구현 솔루션을 구축하기 위한 시스템(도 49 참조)에 관한 것으로, 시스템은 프로세서; 및 글로벌 의도 진술 모듈, 로컬 의도 진술 모듈, CES 모듈, 관계 모듈, 및 프로세서 에 결합된 클록 모듈을 포함하고, 여기서 글로벌 의도 진술 모듈, 로컬 의도 진술 모듈, CES 모듈, 관계 모듈, 및 클록 모듈은 서로 작동 가능하게 연결되며, 글로벌 의도 진술 모듈은, 사용자로부터, 구축될 솔 루션을 나타내는 글로벌 의도 진술을 수신하는 단계로서, 글로벌 의도 진술이 자연 언어의 형태로 수신되고 잠 재성 상태로 설정되는, 글로벌 의도 진술 수신 단계; 및 사용자로부터, 글로벌 의도 진술과 연관된 하나 이상의 에이전트의 세부 사항을 수신하는 단계로서, 에이전트가 솔루션을 실행하는 인간 에이전트 또는 기계 에이전트 이며, 하나 이상의 에이전트의 세부 사항이 자연 언어의 형태로 수신되고, 각 에이전트가 잠재성 상태로 설정되 는, 수신 단계를 포함하고; 로컬 의도 진술 모듈은, 사용자로부터, 글로벌 의도 진술과 연관된 하나 이상의 로 컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체의 세부사항을 수신하는 단계로서, 각 로컬 의도 진술 및 각 개체의 세부사항이 자연 언어의 형태로 수신되고 각각 잠재성 상태로 설정되며, 각 로컬 의도 진술이 솔루션을 구축하기 위한 단계를 나타내고, 각 개체는 해당하는 로컬 의도 진술에 의해 표시된 단계에 참여하는, 수신 단 계; 하나 이상의 에이전트를 각 로컬 의도 진술에 할당하는 단계로서, 로컬 의도 진술에 할당된 에이전트의 세 부 사항이 사용자에 의해 수정 가능한, 할당 단계; 각 로컬 의도 진술에 대해, 사용자로부터 자연 언어의 형태 로, 각각의 로컬 의도 진술의 특성을 규정하는 하나 이상의 속성을 수신하는 단계; 각 개체에 대해, 사용자로부 터 자연 언어의 형태로, 각각의 개체의 특성을 규정하고 각각의 개체를 해당 로컬 의도 진술의 다른 개체와 차 별화하는 하나 이상의 속성을 수신하는 단계를 수행하도록 구성되고; CES 모듈은, 각 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합을 기반으로 한 조합 개체 상태(CES) 집합을 형성하는 단계로 서, 각각의 로컬 의도 진술의 모든 개체를 기반으로 형성된 CES가 트리거 조합 개체 상태(트리거 CES)이고, 집 합 내의 각 CES는 잠재성 상태로 있는, 조합 개체 상태 집합의 형성 단계; 글로벌 의도 진술과 연관된 단지 하 나의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 수신된 로컬 의도 진술의 트리거 CES를 솔루션 구축의 종료로서 식별하는 단계를 수행하도록 구성되고; 관계 모듈은, 글로벌 의도 진술과 연관된 하나 이상의 수신된 로컬 의도 진술을 결정하는 것에 응답하여, 사용자로부터 자연 언어의 형태로, 로컬 의도 진술들 간의 관계를 수신하는 단계로서, 관계는 하나의 로컬 의도 진술의 트리거 CES가 솔루션의 다른 로컬 의도 진술의 CES 집합에 영향을 미치고 있는지 또는 솔루션 구축의 종료인지 여부를 나타내는, 수신 단계를 수행하도록 구성되고; 클록 모듈은, 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 잠재성 상 태로 존재하게 되는 경우의 시작 시간을 기록하는 단계; 및 각각의 글로벌 의도 진술, 하나 이상의 로컬 의도 진술, 하나 이상의 에이전트, 개체 및 속성에 대해, 각각의 글로벌 의도 진술, 각각의 로컬 의도 진술, 각각의 에이전트, 각각의 개체 및 각각의 속성이 현실 상태로 존재하게 되는 경우의 정지 시간을 기록하는 단계를 수행 하도록 구성된다."}
{"patent_id": "10-2023-7006405", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 발명의 특징, 양태 및 장점은 첨부 도면을 참조하여 다음의 상세한 설명을 읽을 때 더 잘 이해될 것이다: 도 1은 BET의 예를 나타낸다. 도 2는 긴밀하게 결합된 개체의 예를 나타낸다. 도 3은 느슨하게 결합된 개체의 예를 나타낸다. 도 4는 예약된 개체의 예를 나타낸다. 도 5는 연결된 변경 유닛의 예를 나타낸다. 도 6은 관련 변경 유닛의 예를 나타낸다. 도 7은 기본 변경 유닛의 상대성의 예를 나타낸다. 도 8은 최소 멤버십 기준의 예를 나타낸다. 도 9는 물리적 연속체(Contimuum) 원리의 예를 나타낸다. 도 10은 잠재성(potentiality)과 현실 사이의 동적 전환의 예를 나타낸다. 도 11은 서버 기능의 예를 나타낸다. 도 12는 솔루션 및 트랜잭션(transaction)을 통한 검색의 예를 나타낸다. 도 13은 NSL에서 검색 가능한 트랜잭션 및 논리의 예를 나타낸다. 도 14는 솔루션 래비시 환경(Solution Lavish Environment)의 예를 나타낸다. 도 15는 분석 엔진의 예를 나타낸다. 도 16은 추론 엔진의 예를 나타낸다. 도 17은 NSL-기술 프레임워크 아키텍처의 예를 나타낸다. 도 18a 및 18b는 유리한 지점 전환(Vantage Point Switching)의 예를 나타낸다. 도 19는 기능적 거리의 예를 나타낸다. 도 20은 네거티브 개체의 예를 나타낸다. 도 21은 베이지안(Bayesian) 논리의 예를 나타낸다. 도 22는 가변성의 예를 나타낸다. 도 23은 상관 원리의 예를 나타낸다. 도 24는 회귀 분석의 예를 나타낸다. 도 25는 NSL의 잔여 정보의 예를 나타낸다. 도 26은 정보 권한 및 결정 권한의 예를 나타낸다. 도 27a는 정보 권한과 결정 권한의 일 방향 화살표의 예를 나타낸다. 도 27b는 정보 권한과 결정 권한의 양방향 화살표의 예를 나타낸다.도 28은 정보 권한 및 결정 권한의 양도 및 위임의 예를 나타낸다. 도 29는 지정된 시간 프레임 또는 지정된 시간 프레임 이상 내에 고객에게 제품을 배송하는 예를 나타낸다. 도 30은 4개의 계층화된 CU의 예를 나타낸다. 도 31은 클래스 관계의 예를 나타낸다. 도 32는 자격을 갖춘 멤버만 허용하는 클래스의 예를 나타낸다. 도 33은 노드의 로컬 네트워크인 CU의 예를 나타낸다. 도 34는 이진법 상태에서 서술적 진술을 규범적 진술 (prescrptive statement)로 변환하는 것을 돕는 의문문의 예를 나타낸다. 도 35는 서술적 진술을 복수 옵션이 있는 규범적 진술로 변환하는 데 도움이 되는 의문문의 예를 나타낸다. 도 36은 펜과 종이 개체를 사용하여 원하는 이벤트와 널(null) 이벤트의 예를 나타낸다. 도 37은 클래스 내의 클래스의 예를 나타낸다. 도 38은 섭스트레이트 라이브러리에서 5개의 식별된 섭스트레이트의 예를 나타낸다. 도 39는 하위 레벨 CU의 GSI가 상위 레벨 CU를 트리거할 예를 나타낸다. 도 40은 내포된(nested) CU가 상위 레벨 CU에 존재하는 문맥성(contextuality)에 더 큰 문맥성을 적용하는 예를 나타낸다. 도 41은 2 개의 이진 개체 모델의 조합에서 잠재성의 음영의 예를 나타낸다. 도 42는 섭스트레이트에 관계없이 다양한 양의 정보를 전달하는 예를 나타낸다. 도 43은 유리한 지점 전환의 예를 나타낸다. 도 44는 NSL의 구축 솔루션 프로세스의 흐름도를 나타낸다. 도 45는 NSL에서 구축 솔루션 프로세스의 예를 나타낸다. 도 46은 병렬 CU의 예를 나타낸다. 도 47a 내지 도 47c는 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연 언어를 사용하여 컴퓨터 구현 솔루션을 구축하는 방법을 묘사한 흐름도를 나타낸다. 도 48은 NSL에 대한 일반화된 컴퓨터 네트워크 배열을 나타낸다. 도 49는 컴퓨터 구현 솔루션을 설계하고 배포하기 위한 시스템을 나타낸다."}
