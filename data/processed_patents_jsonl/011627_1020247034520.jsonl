{"patent_id": "10-2024-7034520", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0161176", "출원번호": "10-2024-7034520", "발명의 명칭": "다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱 시스템", "출원인": "씨 3.에이아이, 인크.", "발명자": "찬코타제, 데이비드"}}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "사용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 변환들의 시퀀스를 식별하는 단계;상기 입력 데이터세트와 연관된 제1 컨텍스트를 식별하는 단계;상기 제1 컨텍스트에 기초하여 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하는 단계;상기 제1 실행 엔진에 상기 변환들의 시퀀스를 구현하는 제1 코드를 제공하는 단계; 및상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진을 이용하여 상기 제1코드를 실행하는 단계를 포함하는방법."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 사용자 인터페이스는다수의 사용자 인터페이스들 중 하나를 포함하고,각각의 사용자 인터페이스는하나 이상의 사용자들로 하여금, 입력 데이터세트들 상에서 수행될 변환들의 시퀀스들을 정의하도록 구성되는,방법."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 변환들의 시퀀스와 연관된 그래프를 저장하는 단계; 및상기 그래프에 기초하는 상기 제1 코드를 생성하는 단계를 더 포함하는방법."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 제1 컨텍스트는상기 변환들의 시퀀스 동안 사용자 또는 애플리케이션 상호 작용들의 양 또는 레벨을 표현하는 상호 작용성 컨텍스트 차원;공개특허 10-2024-0161176-3-상기 변환들의 시퀀스 동안 프로세스될 데이터의 크기 또는 양을 표현하는 데이터 크기 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터의 유형을 표현하는 데이터 유형 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터가 구조화되었는지 또는 비구조화되었는지 여부를 표현하는 데이터 모양 컨텍스트 차원;상기 변환들의 시퀀스 동안 데이터를 프로세스하는 과정에서 필요한 보안의 레벨을 표현하는 보안 프로파일 컨텍스트 차원;상기 변환들의 시퀀스 동안 데이터를 프로세스하기 위해 필요한 리소스들의 양 또는 레벨을 표현하는 리소스 가용성 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터가 개인 식별 가능 정보를 포함하는지 여부를 표현하는 개인 식별가능 정보(PII) 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터 또는 그 결과들이 보유되어야 하는 기간을 표현하는 보유 정책컨텍스트 차원; 및상기 변환들의 시퀀스 동안 계산들에 포함될 데이터의 전체 양 또는 레벨을 표현하는 계산 포괄성 컨텍스트 차원중 적어도 하나에 기초하는,방법."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,지정된 데이터 상에서 상기 변환들의 시퀀스를 수행하기 위한 요청을 수신하는 단계;상기 요청과 연관된 제2 컨텍스트를 식별하는 단계 - 상기 제2 컨텍스트는 상기 제1 컨텍스트와 상이함 -;상기 제2 컨텍스트에 기초하여 상기 지정된 데이터 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 상기실행 엔진들 중 제2 실행 엔진을 선택하는 단계 - 상기 제2 실행 엔진은 상기 제1 실행 엔진과 상이함 -;상기 제2 실행 엔진에 상기 변환들의 시퀀스를 구현하는 제2 코드를 제공하는 단계; 및상기 지정된 데이터 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제2 실행 엔진을 이용하는 상기 제2 코드를 실행하는 단계를 더 포함하는방법."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,식별자와 함께 데이터 저장소 내에 상기 입력 데이터세트 상에서 수행될 상기 변환들의 시퀀스를 식별하는 정보를 저장하는 단계를 더 포함하고,상기 요청은 상기 식별자를 포함하는,방법."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "공개특허 10-2024-0161176-4-제1항에 있어서,상기 변환들의 시퀀스를 식별하는 단계는상기 사용자 인터페이스를 통해 상기 입력 데이터세트 상에서 수행될 다수의 변환들을 식별하는 단계; 및각각의 변환에 대해, 상기 변환을 정의하고 노드에 서명하는 방향성 비순환 그래프 내에 상기 노드를 생성하는단계를 포함하는,방법."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "사용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 변환들의 시퀀스를 식별하고,상기 입력 데이터세트와 연관된 제1 컨텍스트를 식별하고,상기 제1 컨텍스트에 기초하여 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하고,상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진을 이용하여 상기 변환들의 시퀀스를 구현하는 제1 코드를 실행하도록 구성되는적어도 하나의 프로세싱 디바이스를 포함하는장치."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 사용자 인터페이스는다수의 사용자 인터페이스들 중 하나를 포함하고,각각의 사용자 인터페이스는하나 이상의 사용자들로 하여금, 입력 데이터세트들 상에서 수행될 변환들의 시퀀스들을 정의하도록 구성되는,장치."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제8항에 있어서,상기 적어도 하나의 프로세싱 디바이스는상기 변환들의 시퀀스와 연관된 그래프를 저장하고,상기 그래프에 기초하여 상기 제1 코드를 생성하도록더 구성되는,장치.공개특허 10-2024-0161176-5-청구항 11 제8항에 있어서,상기 제1 컨텍스트는상기 변환들의 시퀀스 동안 사용자 또는 애플리케이션 상호 작용들의 양 또는 레벨을 표현하는 상호 작용성 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터의 크기 또는 양을 표현하는 데이터 크기 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터의 유형을 표현하는 데이터 유형 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터가 구조화되었는지 또는 비구조화되었는지 여부를 표현하는 데이터 모양 컨텍스트 차원;상기 변환들의 시퀀스 동안 데이터를 프로세싱하는 과정에서 필요한 보안의 레벨을 표현하는 보안 프로파일 컨텍스트 차원;상기 변환들의 시퀀스 동안 데이터를 프로세스하기 위해 필요한 리소스들의 양 또는 레벨을 표현하는 리소스 가용성 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터가 개인 식별 가능 정보를 포함하는지 여부를 표현하는 개인 식별가능 정보(PII) 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터 또는 그 결과들이 보유되어야 하는 기간을 표현하는 보유 정책컨텍스트 차원; 및상기 변환들의 시퀀스 동안 계산들에 포함될 데이터의 전체 양 또는 레벨을 표현하는 계산 포괄성 컨텍스트 차원중 적어도 하나에 기초하는,장치."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제8항에 있어서,상기 적어도 하나의 프로세싱 디바이스는지정된 데이터 상에서 상기 변환들의 시퀀스를 수행하기 위한 요청을 수신하고,상기 요청과 연관된 제2 컨텍스트를 식별하고 - 상기 제2 컨텍스트는 상기 제1 컨텍스트와 상이함 -,상기 제2 컨텍스트에 기초하여 상기 지정된 데이터 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 상기실행 엔진들 중 제2 실행 엔진을 선택하고 - 상기 제2 실행 엔진은 상기 제1 실행 엔진과 상이함 -,상기 지정된 데이터 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제2 실행 엔진을 이용하여 상기 변환들의 시퀀스를 구현하는 제2 코드를 실행하도록더 구성되는,장치."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제13항에 있어서,상기 적어도 하나의 프로세싱 디바이스는식별자와 함께 데이터 저장소 내에 상기 입력 데이터세트 상에서 수행될 상기 변환들의 시퀀스를 식별하는 정보공개특허 10-2024-0161176-6-를 저장하도록 더 구성되고,상기 요청은 상기 식별자를 포함하는,장치."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제8항에 있어서,상기 변환들의 시퀀스를 식별하기 위해, 상기 적어도 하나의 프로세싱 디바이스는상기 사용자 인터페이스를 통해 상기 입력 데이터세트 상에서 수행될 다수의 변환들을 식별하고,각각의 변환에 대해, 상기 변환을 정의하고 노드를 서명하는 방향성 비순환 그래프 내에 상기 노드를 생성하도록 구성되는,장치."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "실행되는 경우 하나 이상의 프로세서들로 하여금, 사용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 변환들의 시퀀스를 식별하고,상기 입력 데이터세트와 연관된 제1 컨텍스트를 식별하고,상기 제1 컨텍스트에 기초하여 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하고,상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진을 이용하여 상기 변환들의 시퀀스를 구현하는 제1 코드를 실행하도록 하는컴퓨터 판독 가능 프로그램 코드를 저장하는비-일시적 컴퓨터 판독 가능 매체."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서,상기 사용자 인터페이스는다수의 사용자 인터페이스들 중 하나를 포함하고,각각의 사용자 인터페이스는하나 이상의 사용자들로 하여금, 입력 데이터세트들 상에서 수행될 변환들의 시퀀스들을 정의하도록 구성되는,비-일시적 컴퓨터 판독 가능 매체."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제15항에 있어서,실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 상기 변환들의 시퀀스와 연관된 그래프를 저장하고,공개특허 10-2024-0161176-7-상기 그래프에 기초하여 상기 제1 코드를 생성하도록 하는컴퓨터 판독 가능 프로그램 코드를 더 저장하는,비-일시적 컴퓨터 판독 가능 매체."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제15항에 있어서,상기 제1 컨텍스트는상기 변환들의 시퀀스 동안 사용자 또는 애플리케이션 상호 작용들의 양 또는 레벨을 표현하는 상호 작용성 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터의 크기 또는 양을 표현하는 데이터 크기 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터의 유형을 표현하는 데이터 유형 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터가 구조화되었는지 또는 비구조화되었는지 여부를 표현하는 데이터 모양 컨텍스트 차원;상기 변환들의 시퀀스 동안 데이터를 프로세싱하는 과정에서 필요한 보안의 레벨을 표현하는 보안 프로파일 컨텍스트 차원;상기 변환들의 시퀀스 동안 데이터를 프로세스하기 위해 필요한 리소스들의 양 또는 레벨을 표현하는 리소스 가용성 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터가 개인 식별 가능 정보를 포함하는지 여부를 표현하는 개인 식별가능 정보(PII) 컨텍스트 차원;상기 변환들의 시퀀스 동안 프로세스될 데이터 또는 그 결과들이 보유되어야 하는 기간을 표현하는 보유 정책컨텍스트 차원; 및상기 변환들의 시퀀스 동안 계산들에 포함될 데이터의 전체 양 또는 레벨을 표현하는 계산 포괄성 컨텍스트 차원중 적어도 하나에 기초하는,비-일시적 컴퓨터 판독 가능 매체."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제15항에 있어서,실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 지정된 데이터 상에서 상기 변환들의 시퀀스를 수행하기위한 요청을 수신하고,상기 요청과 연관된 제2 컨텍스트를 식별하고 - 상기 제2 컨텍스트는 상기 제1 컨텍스트와 상이함 -,상기 제2 컨텍스트에 기초하여 상기 저장된 데이터 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 상기실행 엔진들 중 제2 실행 엔진을 선택하고 - 상기 제2 실행 엔진은 상기 제1 실행 엔진과 상이함 -,상기 지정된 데이터 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제2 실행 엔진을 이용하여 상기 변환들의 시퀀스를 구현하는 제2 코드를 실행하도록 하는컴퓨터 판독 가능 프로그램 코드를 더 저장하는공개특허 10-2024-0161176-8-비-일시적 컴퓨터 판독 가능 매체."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제20항에 있어서,실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 식별자와 함께 데이터 저장소 내에 상기 입력 데이터세트 상에서 수행될 상기 변환들의 시퀀스를 식별하는 정보를 저장하도록 하는컴퓨터 판독 가능 프로그램 코드를 더 저장하고,상기 요청은 상기 식별자를 포함하는,비-일시적 컴퓨터 판독 가능 매체."}
{"patent_id": "10-2024-7034520", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제15항에 있어서,실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 상기 변환들의 시퀀스를 식별하도록 하는 상기 컴퓨터판독 가능 프로그램 코드는실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 상기 사용자 인터페이스를 통해 상기 입력 데이터세트상에서 수행될 다수의 변환들을 식별하고,각각의 변환에 대해, 상기 변환을 정의하고 노드를 서명하는 방향성 비순환 그래프 내에 상기 노드를 생성하도록 하는컴퓨터 판독 가능 프로그램 코드를 포함하는,비-일시적 컴퓨터 판독 가능 매체."}
{"patent_id": "10-2024-7034520", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "방법은 사용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 변환들의 시퀀스를 식별하는 단계 를 포함한다. 상기 방법은 또한 상기 입력 데이터세트와 연관된 제1 컨텍스트를 식별하는 단계를 포 함한다. 상기 방법은 상기 제1 컨텍스트에 기초하여 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행 하기 위해 이용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하는 단계를 포함한다. 게다가, 상기 방법은 상기 제1 실행 엔진에 상기 변환들의 시퀀스를 구현하는 제1 코드를 제공하는 단계 및 상기 입 력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진을 이용하여 상기 제1 코드를 실행하는 단계를 포함한다."}
{"patent_id": "10-2024-7034520", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 일반적으로 데이터 프로세싱 시스템들에 관한 것이다. 보다 구체적으로, 본 개시는 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱 시스템에 관한 것이다."}
{"patent_id": "10-2024-7034520", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "머신 러닝 또는 인공 지능(machine learning or artificial intelligence; ML/AI) 알고리즘들 또는 다른 데이 터 프로세싱 알고리즘들을 구현하기 위해 이용되는 것과 같은 다양한 데이터 프로세싱 시스템들은 데이터를 획 득하고 프로세스하기 위해 이용되는 폭넓은 기술들과 도구들을 지원할 수 있다. 특정한 데이터 프로세싱 시스 템의 디자인은 종종 데이터 프로세싱 시스템에 의해 프로세스될 데이터의 크기나 양, 데이터 프로세싱 시스템에 의해 프로세스될 데이터의 유형(들) 및 데이터 프로세싱 시스템의 필요로 하거나 원하는 퍼포먼스와 같은 특성 들에 관하여 초기에 만들어진 가정들의 세트를 기초로 한다. 이러한 가정들은 종종 인터페이스 (프런트엔드) 레벨 및 구현 (백엔드) 레벨에서 데이터 프로세싱 시스템에 대한 디자인 결정들에 큰 영향을 준다. 인터페이스 또는 프런트엔드 레벨에서의 디자인 결정들은 전형적으로 데이터 프로세싱 시스템에 액세스하는 사용자들 또는 애플리케이션들과 상호 작용하기 위해 이용될 사용자 인터페이스 또는 다른 인터페이스의 디자인을 결정하는 것 을 포함한다. 구현 또는 백엔드 레벨에서의 디자인 결정들은 전형적으로 원하는 데이터 프로세싱 동작들을 수"}
{"patent_id": "10-2024-7034520", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "행하기 위해 실행될 컴파일링 코드를 포함한다.발명의 내용"}
{"patent_id": "10-2024-7034520", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시는 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱 시스템에 관한 것이다. 첫 번째 실시예에서, 방법은 사용자 인터페이스를 통해 입력 데이터세트(input dataset) 상에서 수행될 변환들 의 시퀀스(sequence of transformations)를 식별하는 단계를 포함한다. 상기 방법은 상기 입력 데이터세트와 연관된 제1 컨텍스트를 식별하는 단계를 포함한다. 상기 방법은 상기 제1 컨텍스트에 기초하여 상기 입력 데이 터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하는 단계를 더 포함한다. 게다가, 상기 방법은 상기 제1 실행 엔진에 상기 변환들의 시퀀스를 구현하는 제1 코드를 제공하는 단계 및 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진을 이용하여 상기 제1 코드를 실행하는 단계를 포함한다. 두 번째 실시예에서, 장치는 사용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 변환들의 시퀀스를 식별 하도록 구성되는 적어도 하나의 프로세싱 디바이스를 포함한다. 상기 적어도 하나의 프로세싱 디바이스는 또한 상기 입력 데이터세트와 연관된 제1 컨텍스트를 식별하도록 구성된다. 상기 적어도 하나의 프로세싱 디바이스 는 또한 상기 제1 컨텍스트에 기초하여 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 이 용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하도록 더 구성된다. 게다가, 상기 적어도 하나의 프로세싱 디바이스는 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진을 이용하 여 상기 변환들의 시퀀스를 구현하는 제1 코드를 실행하도록 구성된다. 세 번째 실시예에서, 비-일시적 컴퓨터 판독 가능 매체는 실행되는 경우 하나 이상의 프로세서들로 하여금, 사 용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 변환들의 시퀀스를 식별하도록 하는 컴퓨터 판독 가능 프로그램 코드를 저장한다. 상기 매체는 또한 실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 상기 입 력 데이터세트와 연관된 제1 컨텍스트를 식별하도록 하는 컴퓨터 판독 가능 프로그램 코드를 저장한다. 상기 매체는 실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 상기 제1 컨텍스트에 기초하여 상기 입력 데이터 세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하도록 하는 컴퓨터 판독 가능 프로그램 코드를 더 저장한다. 게다가, 상기 매체는 실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진 을 이용하여 상기 변환들의 시퀀스를 구현하는 제1 코드를 실행하도록 하는 컴퓨터 판독 가능 프로그램 코드를 저장한다. 다른 기술적 특징들은 후술하는 도면들, 설명들 및 청구항들로부터 당업자에게 손쉽게 명백해질 수 있다."}
{"patent_id": "10-2024-7034520", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "아래에 설명된 도 1 내지 도 5 및 본 개시의 원리들을 설명하기 위해 이용되는 다양한 실시예들은 단지 예시를 위한 것이며, 본 개시의 범위를 제한하는 방식으로 해석되어서는 안 된다. 당업자는 본 개시의 원리들이 적절하게 배열되는 디바이스 또는 시스템에서 구현될 수 있음을 이해할 것이다. 위에서 언급된 바와 같이, 머신 러닝 또는 인공 지능(ML/AI) 알고리즘들 또는 다른 데이터 프로세싱 알고리즘들 을 구현하기 위해 이용되는 것과 같은 다양한 데이터 프로세싱 시스템들은 데이터를 획득하고 프로세스하기 위 해 이용되는 폭넓은 기술들과 도구들을 지원할 수 있다. 특정한 데이터 프로세싱 시스템의 디자인은 종종 데이 터 프로세싱 시스템에 의해 프로세스될 데이터의 크기나 양, 데이터 프로세싱 시스템에 의해 프로세스될 데이터 의 유형(들) 및 데이터 프로세싱 시스템의 필요로 하거나 원하는 퍼포먼스와 같은 특성들에 관하여 초기에 만들 어진 가정들의 세트를 기초로 한다. 이러한 가정들은 종종 인터페이스 (프런트엔드) 레벨 및 구현 (백엔드) 레 벨에서 데이터 프로세싱 시스템에 대한 디자인 결정들에 큰 영향을 준다. 인터페이스 또는 프런트엔드 레벨에 서의 디자인 결정들은 전형적으로 데이터 프로세싱 시스템에 액세스하는 사용자들 또는 애플리케이션들과 상호 작용하기 위해 이용될 사용자 인터페이스 또는 다른 인터페이스의 디자인을 결정하는 것을 포함한다. 구현 또 는 백엔드 레벨에서의 디자인 결정들은 전형적으로 원하는 데이터 프로세싱 동작들을 수행하기 위해 실행될 컴 파일링 코드를 포함한다. 불행하게도, 데이터 프로세싱 시스템의 디자인에 대한 가정들의 초기 세트는, 특히 가정들의 초기 세트 밖의 이 용 케이스들에 대해, 종종 최적이 아닌 데이터 프로세싱 시스템의 생성으로 이어진다. 더욱이, 상이한 데이터 프로세싱 시스템 디자인들에 걸쳐 공통되어야 하는 것과 공통되어서는 안 되는 것 사이에 충돌이 종종 있다. 예를 들어, 프런트엔드 디자인들에 걸친 공통성(commonality)은 사용자가 상이한 데이터 프로세싱 시스템 디자 인들 간의 인터페이스들에 더 익숙해지는 데 도움이 될 수 있으므로 바람직할 수 있으며, 이는 데이터 프로세싱 시스템들의 이용 편의성을 높일 수 있다. 그에 반해서, 백엔드 디자인들 간의 공통성은 상이한 데이터 프로세 싱 시스템 디자인들에 대한 구현들의 최적화들이 전형적으로 데이터 프로세싱 시스템들에 대한 특정한 이용 케 이스들에 의존하기 때문에 바람직하지 않을 수 있다. 상이한 이용 케이스들에서 동일한 데이터 프로세싱 시스 템 디자인을 활용하기 위한 시도는 전형적으로 임의의 이점들보다 더 큰 다양한 단점들로부터 고통받을 수 있다. 예를 들어, 스트리밍 데이터에 유용한 인터페이스는 일괄-프로세스된 데이터(batch-processed data)에 이용하기에 최고의 인터페이스가 아닐 수 있다(그 반대도 마찬가지이다). 다른 예시로서, 임의의 주어진 시간 에 작은 양들의 데이터를 프로세스하는 데 유용한 데이터 탐색 도구(data exploration tool)는 큰 양들의 데이 터를 프로세스하기 위해 시도하는 경우 덜 유용하거나 심지어 비-기능적(non-functional)일 수 있다. 심지어 다수의 구현들이 이용되도록 제공되더라도, 사용자들 스스로는 종종 특정한 데이터에 대해 주어진 시간에 어떠 한 구현이 이용되어야 할지를 선택해야 한다. 본 개시는 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱 시스템을 제공한다. 아래에 서 보다 자세히 설명되는 바와 같이, 데이터 프로세싱 시스템은 하나 이상의 사용자가 데이터 및 데이터에 적용 될 변환들(코드)을 식별하기 위해 이용될 수 있는 적어도 하나의 프런트엔드(인터페이스)를 지원할 수 있다. 구현에 의존하여, 데이터 프로세싱 시스템은 단일 프런트엔드 또는 다수의 프런트엔드들의 이용을 지원할 수 있 다. 데이터 프로세싱 시스템은, 예를 들어 데이터베이스 내에, 변환들을 캡처하고 변환들을 식별하는 정보를 저장할 수 있다. 데이터 프로세싱 시스템은 데이터 프로세싱 동작들을 수행하기 위해 또한 데이터와 연관된 정 보 및 컨텍스트를 이용할 수 있다. 예를 들어, 데이터 프로세싱 시스템은 컨텍스트에 의존하여 (다수의 백엔드 들을 표현하는) 다수의 실행 엔진들 가운데서 특정한 실행 엔진을 선택할 수 있고, 수행될 변환들을 구현하는 코드는 특정한 실행 엔진에 대해 생성되거나 그렇지 않으면 획득될 수 있다. 특정한 실행 엔진은 데이터 상에 서 데이터 프로세싱 동작들을 수행하기 위해 코드를 실행할 수 있다. 특정한 컨텍스트는 그 예시들이 아래에 제공되는 다수의 요인들에 기초하여 달라질 수 있다. 이용을 위해 선택된 특정한 실행 엔진 또한 상이한 사용 자들 또는 애플리케이션들이 상이한 컨텍스트들과 연관되거나 동일한 사용자 또는 애플리케이션과 연관된 컨텍 스트가 시간이 지남에 따라 변경되는 경우와 같은 때, 달라질 수 있다. 데이터 변환들을 수행하기 위한 상이한 코드는 저장된 정보에 기초하여 생성되거나 그렇지 않으면 획득될 수 있고, 상이한 코드는 상이한 실행 엔진들 에 의해 실행될 수 있다. 이는 동일한 변환들의 시퀀스로 하여금, 그 결과로서 한 번 이상 요청되고 하나 이상 의 실행 엔진들을 이용하여 수행되도록 할 수 있다. 이러한 방식으로, 데이터 프로세싱 시스템은 적어도 하나의 사용자 또는 애플리케이션이 데이터 변환들(코드)을 실행하기 위해 시도하는 컨텍스트에 가장 적합한 실행 엔진(백엔드)을 동적으로 선택할 수 있다. 상이한 사용 자들 또는 애플리케이션들에 대해 선택된 실행 엔진들은 그들의 상이한 컨텍스트들 기초하여 달라질 수 있고, 단일한 사용자 또는 애플리케이션에 대해 선택된 실행 엔진은 변경되는 컨텍스트들에 기초하여 시간이 지남에 따라 달라질 수 있다. 결과적으로, 적어도 하나의 사용자가 데이터 변환들을 정의하는 코드를 한 번 수동으로 작성하거나 또는 다른 방식으로 제공할 수 있으며, 사용자(들)가 각각의 실행 엔진에 대해 코드를 다시 작성할필요 없이 데이터 변환들은 상이한 실행 엔진들을 이용하여 수행될 수 있다. 본질적으로, 데이터 프로세싱 시 스템은 인터페이스(프런트엔드)의 선택을 구현(백엔드)의 선택으로부터 디커플링할 수 있으므로, 어떤 프런트엔 드가 이용되는 것과 상관없이 적절한 백엔드가 선택되고 이용될 수 있다. 종합적으로, 이는 데이터 프로세싱 시스템으로 하여금, 수행되고 있는 중인 데이터 프로세싱의 특성에 의존하여 상이한 실행 엔진들 간에 스위칭하 도록 한다. 이는 이용 케이스들이 시간이 지남에 따라 변경되거나 애플리케이션들이 시간이 지남에 따라 진화 하는 것들을 포함하여, 다수의 시나리오들에서 극히 유용할 수 있다. 데이터 프로세싱 시스템은 따라서 상호 작용적이고, 복제 가능하며, 중복적이고, 안정적인 신뢰할 수 있는 데이터 프로세싱 도구를 제공할 수 있다. 본 개시에 따라 디자인된 데이터 프로세싱 시스템을 이용하여 획득될 수 있는 특정한 이점들 또는 장점들의 다 양한 예시들이 아래에 제공된다. 도 1은 본 개시에 따라 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱을 지원하는 예시 적인 시스템을 설명한다. 예를 들어, 여기에 도시된 시스템은 프런트엔드 상에 하나 이상의 인터페 이스들을 제공하고 백엔드 상에 실행 엔진 선택을 제공하는 기능적인 아키텍처를 갖는 데이터 프로세싱 시스템 을 지원하기 위해 이용될 수 있으며, 이는 아래에서 더 자세히 설명된다. 도 1에 도시된 바와 같이, 시스템 은 사용자 디바이스들(102a 내지 102d), 하나 이상의 네트워크들, 하나 이상의 애플리케이션 서버들 및 하나 이상의 데이터베이스들과 연관된 하나 이상의 데이터베이스 서버들을 포함한다. 각각 의 사용자 디바이스(102a 내지 102d)는, 예를 들어 유선 또는 무선 연결을 통해, 네트워크를 통해 통신한 다. 각각의 사용자 디바이스(102a 내지 102d)는 데스크톱 컴퓨터, 랩톱 컴퓨터, 스마트폰 및 태블릿 컴퓨터와 같이, 적어도 하나의 사용자에 의해 정보를 제공하거나 수신하기 위해 이용되는 임의의 적합한 디바이스 또는 시스템을 표현한다. 그러나, 임의의 다른 또는 추가적인 유형들의 사용자 디바이스들이 시스템 내에서 이 용될 수 있다. 네트워크는 시스템의 다양한 구성 요소들 간의 통신을 용이하게 한다. 예를 들어, 네트워크는 인터넷 프로토콜(internet protocol; IP) 패킷들, 프레임 릴레이 프레임들(frame relay frames), 비동기 전송 모드(asynchronous transfer mode; ATM) 셀들 또는 네트워크 주소들 간 다른 적합한 정보를 통신할 수 있다. 네트워크는 하나 이상의 로컬 영역 네트워크들(local area networks; LANs), 대도시 영역 네트워크들 (metropolitan area networks; MANs) 광역 네트워크들(wide area networks; WANs), 인터넷과 같은 글로벌 네트 워크의 전체나 일부 또는 하나 이상의 위치들에 있는 임의의 다른 통신 시스템이나 시스템들을 포함할 수 있다. 일부 경우들에서, 네트워크는 데이터 프로세싱 동작들을 수행하는 회사 또는 다른 조직 내의 적어도 하나 의 네트워크를 포함할 수 있다. 애플리케이션 서버는 네트워크에 커플링되고, 데이터베이스 서버에 커플링되거나 통신한다. 애 플리케이션 서버는 아래에서 더 자세히 설명되는 바와 같이, 프런트엔드 상의 하나 이상의 인터페이스들 및 백엔드 상의 실행 엔진 선택을 제공하는 데이터 프로세싱 기능 아키텍처를 지원한다. 예를 들어, 애플리케 이션 서버는 하나 이상의 애플리케이션들을 실행할 수 있으며, 이는 사용자들로 하여금, 적어도 하나 의 인터페이스를 통해 데이터 및 데이터에 적용될 변환들을 식별하도록 할 수 있다. 식별된 데이터 및 식별된 변환들과 연관된 정보는 데이터베이스 내의 저장소를 위해 애플리케이션 서버에서 데이터베이스 서버 로 전송될 수 있다. 하나 이상의 애플리케이션들은 또한 사용자들 또는 애플리케이션들로 하여금, 데이터 프로세싱 동작들을 시작하도록 할 수 있으며, 이는 애플리케이션 서버로 하여금, 데이터 서버(10 8)를 통해 데이터베이스로부터 정보를 검색하도록 할 수 있다. 하나 이상의 애플리케이션들은 하나 이상의 선택된 실행 엔진들에 의한 실행을 위한 코드를 생성하거나 그렇지 않으면 획득하기 위해 검색된 정보를 이용할 수 있다. 특정한 사용자 또는 애플리케이션에 대해 선택된 각각의 실행 엔진은 해당 사용자 또는 애플 리케이션과 연관된 특정한 컨텍스트에 기초하여 결정될 수 있다. 데이터베이스 서버는 애플리케이션 서버 내에서 정보를 저장하기 위해 이용될 수도 있으며, 이 경우 애플리케이션 서버 자체가 데이터 프로 세싱 동작들을 지원하기 위해 이용되는 정보를 저장할 수 있다. 데이터베이스 서버는 데이터베이스 내에서 애플리케이션 서버 및 사용자 디바이스들(102a 내지 102d)에 의해 이용되고, 생성되고 또는 수집되는 다양한 정보를 저장하고 검색을 용이하게 하기 위해 동작한다. 예를 들어, 데이터베이스 서버는 하나 이상의 사용자들에 의해 정의된 대로 데이터에 적용될 데이터 변환 들과 관련된 다양한 정보를 저장할 수 있다. 데이터베이스 서버는 또한 다양한 사용자들 또는 애플리케이 션들에 대한 컨텍스트들의 상이한 특성들에 기초하여 특정한 실행 엔진들이 어떻게 선택되는지 식별하는 정보와 같은, 다양한 실행 엔진들과 관련된 정보를 저장할 수 있다. 도 1은 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱을 지원하는 시스템의 일례 를 설명하지만, 다양한 변경들이 도 1에 가해질 수 있다. 예를 들어, 시스템은 임의의 수의 사용자 디바 이스들(102a 내지 102d), 네트워크들, 애플리케이션 서버들, 데이터베이스 서버들 및 데이터베 이스들을 포함할 수 있다. 또한, 이러한 구성 요소들은 임의의 적합한 위치들에 위치될 수 있으며, 큰 영 역에 걸쳐 분산될 수 있다. 게다가, 도 1은 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로 세싱이 이용될 수 있는 하나의 예시적인 동작 환경을 설명하지만, 이 기능성은 임의의 다른 적합한 시스템 내에 서 이용될 수 있다. 도 2는 본 개시에 따라 다중-인터페이스 프런트엔드 빛 백엔드를 갖춘 지능형 데이터 프로세싱을 지원하는 예시 적인 디바이스를 설명한다. 예를 들어, 디바이스의 하나 이상의 인스턴스들은 도 1의 애플리케이션 서버의 기능성을 적어도 부분적으로 구현하기 위해 이용될 수 있다. 그러나, 애플리케이션 서버의 기능성은 임의의 다른 적합한 방식으로 구현될 수 있다. 일부 실시예들에서, 도 2 내에 도시된 디바이스 는 도 1 내의 사용자 디바이스(102a 내지 102d), 애플리케이션 서버 또는 데이터베이스 서버의 적어 도 일부를 형성할 수 있다. 그러나, 이러한 구성 요소들 각각은 임의의 다른 적합한 방식으로 구현될 수 있다. 도 2에 도시된 바와 같이, 디바이스는 적어도 하나의 프로세싱 디바이스, 적어도 하나의 저장 디바이 스, 적어도 하나의 통신 유닛 및 적어도 하나의 입력/출력(I/O) 유닛을 포함하는 컴퓨팅 디바이 스 또는 시스템을 나타낸다. 프로세싱 디바이스는 메모리에 로딩될 수 있는 명령어들을 실행할 수 있다. 프로세싱 디바이스는 임의의 적합한 수(들) 및 유형(들)의 프로세서들 또는 임의의 적합한 배열 내 다른 프로세싱 디바이스들을 포함한다. 프로세싱 디바이스들의 예시적인 유형들은 하나 이상의 마이크로 프로세서들, 마이크로컨트롤러들, 디지털 신호 프로세서들(digital signal processors; DSPs), 특정 애플리케이 션 집적 회로들(application specific integrated circuits; ASICs), 현장 프로그래머블 게이트 어레이들 (field programmable gate arrays; FPGAs) 또는 이산 회로부(discrete circuitry)를 포함한다. 메모리 및 영구 저장소는 (일시적 또는 영구적 베이시스(permanent basis)의 데이터, 프로그램 코드 및/또는 다른 적합한 정보와 같은) 정보의 저장 및 검색을 용이하게 할 수 있는 임의의 구조(들)를 표현하는 저 장 디바이스들의 예시들이다. 메모리는 랜덤 액세스 메모리 또는 임의의 다른 적합한 휘발성 또는 비-휘발성 저장 디바이스(들)를 나타낼 수 있다. 영구 저장소는 읽기 전용 메모리(read only memory), 하 드 드라이브, 플래시 메모리 또는 광 디스크(optical disc)와 같이 데이터의 장기 저장을 지원하는 하나 이상의 구성 요소들 또는 디바이스들을 포함할 수 있다. 통신 유닛은 다른 시스템들 또는 디바이스들과의 통신을 지원한다. 예를 들어, 통신 유닛은 네트워 크와 같은 유선 또는 무선 네트워크를 통한 통신들을 용이하게 하는 네트워크 인터페이스 카드 또는 무선 트랜시버(wireless transceiver)를 포함할 수 있다. 통신 유닛은 임의의 적합한 물리적 또는 무선 통신 링크(들)를 통한 통신을 지원할 수 있다. I/O 유닛은 데이터의 입력 및 출력을 허용한다. 예를 들어, I/O 유닛은 키보드, 마우스, 키패드, 터 치스크린 또는 다른 적합한 입력 디바이스를 통해 사용자 입력을 위한 연결을 제공할 수 있다. I/O 유닛 은 또한 디스플레이, 프린터 또는 다른 적합한 출력 디바이스로 출력을 전송(send)할 수 있다. 그러나, 디바이 스가 원격으로 액세스될 수 있는 서버 또는 다른 디바이스를 표현하는 것과 같이, 디바이스에 로컬 I/O가 필요하지 않는 경우, I/O 유닛은 생략될 수 있다. 도 2는 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱을 지원하는 디바이스의 일 례를 설명하지만, 다양한 변경들이 도 2에 가해질 수 있다. 예를 들어, 컴퓨팅 및 통신 디바이스들과 시스템들 은 폭 넓은 다양한 구성들로 제공되며, 도 2는 임의의 특정한 컴퓨팅 또는 통신 디바이스나 시스템으로 본 개시 를 제한하지 않는다. 도 3은 본 개시에 따라 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱 시스템의 예시적 인 아키텍처를 설명한다. 설명의 편의를 위해, 도 3에 도시된 아키텍처는 도 1에 도시된 시스템 내의 애플리케이션 서버에 의해 구현되거나 지원되는 것으로 설명되며, 애플리케이션 서버는 도 2에 도시된 디바이스의 하나 이상의 인스턴스들을 이용하여 구현될 수 있다. 그러나, 도 3에 도시된 아키텍처는 임의의 다른 적합한 디바이스 및 임의의 다른 적합한 시스템과 함께 이용될 수 있다. 도 3에 도시된 바와 같이, 아키텍처는 일반적으로 제작 환경(authoring environment)과 연관된 기능 들 및 실행 환경(execution environment)과 연관된 기능들로 나뉜다. 제작 환경은 일반적으로 데이 터 및 데이터 변환들(코드)을 정의할 수 있는 기능들을 포함하고, 여기서 데이터 변환들과 연관된 정보는 데이터베이스 또는 다른 적합한 저장소 위치(들)에 저장될 수 있다. 실행 환경은 일반적으로 코드가 변 환(필요한 경우)되고 요청에 따라 데이터 변환들을 수행하기 위해 실행될 수 있는 기능들을 포함한다. 이 예시적인 실시예에서, 제작 환경은 적어도 하나 이상의 사용자들에 의해 적어도 하나의 입력 데이 터세트에 적용될 적어도 하나의 데이터 변환들의 세트를 정의하기 위해 이용될 수 있다. 예를 들어, 제작 환경은 이용 가능한 하나 이상의 프런트엔드들을 표현하는 하나 이상의 인터페이스들을 포함할 수 있 다. 각각의 인터페이스는 적어도 하나의 사용자로 하여금, 데이터세트를 로딩하고 데이터세트 상에서 수행될 동작들을 정의하도록 할 수 있다. 단일 인터페이스 또는 다수의 인터페이스들 이 구현에 의존하여 아키텍처 내에 제공될 수 있다는 점을 참고해야 한다. 각각의 인터페이스는 애 플리케이션 프로그래밍 인터페이스(application programming interface; API)와 같이, 데이터에 적용될 변환들 을 정의하는 데이터 및 정보를 수신하도록 구성되는 임의의 적합한 로직을 포함한다. 여기에서 이용될 수 있는 인터페이스들의 특정한 예시적인 유형들로는 판다스(Pandas) API 및 구조화 쿼리 언어(Structure Query Language; SQL) API를 포함할 수 있다. 트래킹 모듈은 인터페이스(들)을 이용하여 하나 이상의 사용자들에 의해 각각의 데이터세트 에 적용되는 각각의 변환들의 시퀀스를 트래킹하기 위해 인터페이스(들)과 함께 이용된다. 다시 말 해, 트래킹 모듈은 각각의 사용자가 인터페이스를 이용하여 데이터세트를 수정하는 방법을 식별 할 수 있으며, 트래킹 모듈은 데이터베이스 내에 이 정보를 저장할 수 있다. 트래킹 모듈은 변 환들의 시퀀스를 식별하는 정보를 생성할 수 있고 임의의 적합한 방식으로 데이터베이스 내에 각각의 변환 들의 시퀀스와 연관된 정보를 저장할 수 있다. 예를 들어, 일부 경우들에서, 트래킹 모듈은 데이터세트 에 적용되는 각각의 변환들의 시퀀스를 식별하는 방향성 비순환 그래프(directed acyclic graph; DAG)를 생성할 수 있다. 컨텍스트 모듈은 또한 사용자가 변환들의 시퀀스를 수행하는 각각의 컨텍스트에 대한 정보를 식별하 기 위해 제작 환경 내에서 이용되며, 이 정보는 또한 데이터베이스 내에 저장되거나 실행 환경 에 제공될 수 있다. 컨텍스트 모듈에 의해 식별되거나 생성될 수 있는 정보들의 예시적인 유형들은 아래 에 설명된다. 이 예시에서, 트래킹 모듈 및 컨텍스트 모듈은 변환들의 시퀀스 및 선택적으로 컨텍스 트를 \"저장_변환들(save_transformations)\" 액션(action)의 일환으로서 집합적으로 데이터를 저장하는 것으로 도시된다. 일부 경우들에서, 각각의 변환들의 시퀀스에 대한 저장된 데이터는 사용자-정의 식별자 (ID) 또는 다른 유형의 식별과 연관될 수 있다. 또한, 일부 경우들에서, 컨텍스트 모듈은 데이터베이스 내의 저장소에 대한 트래킹 모듈에 컨텍스트 정보를 제공할 수 있거나, 트래킹 모듈은 데이터 베이스 내의 저장소에 대한 컨텍스트 모듈에 변환들의 시퀀스 정보를 제공할 수 있거나, 컨텍스트 모 듈은 실행 환경에 직접적으로 컨텍스트 정보를 제공할 수 있다. 여기에서 사용자들은 데이터세트에 적용될 변환들의 시퀀스를 정의할 때 임의의 지원되는 인터페이스 를 자유롭게 이용할 수 있다는 점을 참고해야 한다. 일부 실시예들에서, 예를 들어, 제작 환경은 하 나 이상의 미리 정의되거나 미리 설치된 인터페이스들을 포함할 수 있으며, 사용자들은 그러한 특정 한 인터페이스들을 이용하도록 제한될 수 있다. 다른 실시예들에서, 하나 이상의 인터페이스들은 (제작 환경 내에서 하나 이상의 미리 정의되거나 미리 설치되는 인터페이스들이 이용되거나 이용되지 않든) 필요로 하거나 원하는 대로 제작 환경 내에 설치될 수 있다. 일반적으로, 제작 환경은 인터페 이스들이 사용자들에게 어떻게 또는 언제 이용 가능하도록 만들어질 수 있는 지와 관계없이, 임의의 적절한 수와 유형들의 인터페이스들을 포함할 수 있다. 따라서, 이 접근은 상이한 사용자들로 하여 금, 입력 데이터세트들 상에서 수행되는 변환들의 시퀀스 및 다른 정보를 정의하기 위해 필요로 하거나 원 하는 대로 다양한 인터페이스들을 이용하도록 할 수 있다. 일단 하나 이상의 변환들의 시퀀스들이 제작 환경 내에서 적어도 하나의 인터페이스를 이용하여 정의 되면, 각각의 변환들의 시퀀스는 이후의 실행 환경 내에서 적용될 수 있다. 이 예시적인 실시예에서, 실 행 환경은 (각각의 정의된 변환들의 시퀀스가 처음 실행되는 동안) 변환들의 시퀀스를 실행하고 사용자들 에 의해 정의된 입력 데이터세트들을 프로세스하기 위해 이용될 수 있다. 하나 이상의 사용자들 및/또는 하나 이상의 애플리케이션들 또한 (변환들의 시퀀스들의 이후의 실행들이 실행되는 동안) 동일한 변환들의 시퀀스들이 그들의 입력 데이터에 수행되도록 요청할 수 있다. 하나 이상의 사용자들 은 이전에-정의된 데이터 변환들을 입력 데이터에 적용하고자 하는 사용자들을 표현하고, 하나 이상 의 애플리케이션들은 입력 데이터로 이전에-정의된 데이터 변환들의 애플리케이션을 요청하는 (하나 이상의 컴퓨팅 디바이스들 또는 다른 디바이스들에 의해 실행되는) 로직을 표현한다. 하나 이상의 사용자들은 하나 이상의 사용자들과 동일할 수도 있고 동일하지 않을 수도 있다는 점을 참고해야 한다. 이 예시에서, 이전에-정의된 데이터 변환의 애플리케이션은 \"런_변환들(run_transformations)\" 요청을 이용하 여 요청될 수 있다. 일부 경우들에서, 이전에-정의된 데이터 변환은 요청 내의 이전에-정의된 데이터 변 환과 연관된 사용자-정의 식별자 또는 다른 유형의 식별을 포함함으로써, 요청될 수 있다. 실행 모듈은 일반적으로 사용자들과 그들의 입력 데이터세트들에 대한 변환들의 시퀀스들의 실 행들 및 사용자들/애플리케이션들과 그들의 입력 데이터에 대한 변환들의 시퀀스들의 실행들을 컨트롤하도록 동작한다. 수행될 각각의 변환들의 시퀀스에 대해, 실행 모듈은 프로세스될 데이터와 연관 된 현재 컨텍스트(current context)를 식별하는 정보를 수신할 수 있다. 각각의 현재 컨텍스트는 컨 텍스트 모듈을 이용하여 식별된다. 예를 들어, 컨텍스트 모듈은 전술된 대로 각각의 사용자에 대한 컨텍스트에 관한 정보를 식별하기 위해 이용될 수 있으며, 컨텍스트 모듈은 사용자 또는 애플리 케이션이 각각의 요청에 대한 변환들의 시퀀스의 퍼포먼스를 요청하는 컨텍스트에 관한 정보를 식별 하기 위해 이용될 수 있다. 컨텍스트 모듈은 데이터 변환들이 발생하는 컨텍스트와 연관된 임의의 적합한 특성(들)을 식별하기 위해 이용될 수 있다. 예를 들어, 컨텍스트 모듈은 각각의 데이터 변환들의 시퀀스와 연관된 상이한 컨텍스트 차원들에 대한 값들을 결정할 수 있다. 일부 실시예들에서, 컨텍스트 모듈에 의해 이용될 수 있는 상이한 컨텍스트 차원들의 예시들은 다음의 컨텍스트 차원들 중 임의의 하나 또는 임의의 조합을 포함할 수 있다. 상 호 작용성 컨텍스트 차원(interactivity context dimension)은 변환들의 시퀀스 내에서의 데이터의 프로세싱 동 안 사용자 또는 애플리케이션 상호 작용들의 양 또는 레벨을 표현할 수 있다. 데이터 크기 컨텍스트 차원(data size context dimension)은 변환들의 시퀀스 동안 프로세스될 데이터의 크기 또는 양을 대략적으로 나타낼 수 있다. 데이터 유형 컨텍스트 차원(data type context dimension)은 실-시간, 일괄 프로세스 또는 스트리밍 데 이터와 같이, 변환들의 시퀀스 동안 프로세스될 데이터의 유형을 표현할 수 있다. 데이터 모양 컨텍스트 차원 (data shape context dimension)은 변환들의 시퀀스 동안 프로세스될 데이터가 구조화되었는지 또는 비구조화되 었는지 여부를 표현할 수 있으며, 만약 비구조화되었다면, (이미지 데이터, 비디오 데이터, 오디오 데이터 등과 같이) 프로세스될 비구조화된 데이터의 특정한 유형을 표현할 수 있다. 보안 프로파일 컨텍스트 차원(security profile context dimension)은 변환들의 시퀀스 동안 데이터를 프로세싱하는 과정에서 필요한 보안의 레벨을 표 현할 수 있다. 리소스 가용성 컨텍스트 차원(resource availability context dimension)은 변환들의 시퀀스 동안 데이터를 프로세스하기 위해 필요할 수 있는 프로세싱 리소스들, 메모리 리소스들 또는 다른 리소스들의 양 또는 레벨을 표현할 수 있다. 개인 식별 가능 정보(personal identifiable information; PII) 컨텍스트 차 원(PII context dimension)은 변환들의 시퀀스 동안 프로세스될 데이터가 개인 식별 가능 정보를 포함하는지 여 부를, 그리고 만약 그렇다면, 어떻게 해당 데이터가 다루어져야 하는지를 표현할 수 있다. 보유 정책 컨텍스트 차원(retention policy context dimension)은 변환들의 시퀀스 동안 프로세스될 데이터 또는 그 결과들이 보유 되어야 하는 기간을 표현할 수 있다. 계산 포괄성 컨텍스트 차원(computation comprehensiveness context dimension)은 변환들의 시퀀스 동안 계산들(computations)에 포함될 데이터의 전체 양 또는 레벨을 표현할 수 있다. 구현들에 의존하여, 컨텍스트는 불연속 값들 또는 주어진 값들의 범위 내에서 연속적인 값들을 이용하여 이러한 컨텍스트 차원들 중 하나 이상의 각각에 따라 정의될 수 있다. (사용자, 사용자, 또는 애플리케이션 중 하나에 대해) 수행될 변환들의 시퀀스 각각에 대해, 실 행 모듈은 프로세스될 데이터와 연관된 현재 컨텍스트를 식별하는 정보를 수신할 수 있다. 실행 모 듈은 또한, 요청에 포함된 식별자와 연관된 변환들의 시퀀스 또는 사용자에 의해 정의된 변환들 의 시퀀스를 정의하는 정보를 검색하는 것과 같이, 데이터베이스로부터 수행될 특정한 변환들의 시퀀스에 대한 정보를 획득할 수 있다. 일부 경우들에서, 예를 들어, 데이터베이스는 수행될 변환들의 시퀀스와 연 관된 (방향성 비순환 그래프와 같은) 정보를 획득하기 위해 이용될 수 있는 \"검색_변환들 (retrieve_transformations)\" 요청을 이용하여 쿼리될 수 있다. 수행될 변환들의 시퀀스 각각에 대해, 실행 모듈은 변환들의 시퀀스를 수행하기 위해 이용될 다수의 실행 엔진들 중 하나를 선택하기 위해 획득된 정보의 적어도 일부를 이용할 수 있다. 실행 엔진들은 요청 된 변환들의 시퀀스들을 수행하기 위해 상이한 도구들 또는 기술들을 이용할 수 있는 상이한 백엔드들을 표현한 다. 상이한 유형들의 머신 러닝이나 인공 지능(ML/AI) 알고리즘들 또는 다른 데이터 프로세싱 알고리즘들을 지 원하는 백엔드들과 같이, 임의의 적합한 실행 엔진들은 데이터 변환들을 수행하기 위해 여기에서 이용될 수 있다. 일부 경우들에서, 실행 모듈은 프로세스될 데이터의 현재 컨텍스트에 기초하여 수행될 변 환들의 시퀀스 각각에 대해서 이용될 특정한 실행 엔진을 선택할 수 있다. 특정 예시로서, 실행 모듈은 컨텍스트 차원들의 값들의 상이한 조합들을 실행 엔진들 중 상이한 것들에 매핑하는 인-메모리 데 이터 구조(in-memory data structure) 또는 다른 메커니즘을 이용할 수 있다. 따라서, 실행 모듈은 현재 컨텍스트의 값들을 가져와 해당 값들에 매핑되는 실행 엔진을 선택할 수 있다. 수행될 변환들의 시퀀스 각각에 대해, 실행 모듈은 선택된 실행 엔진에 의해 실행될 실행 엔진-특정 코드를 더 생성할 수 있다. 예를 들어, 실행 모듈은 수행될 변환들의 시퀀스와 연관된 방향성 비순 환 그래프를 순회(traverse)할 수 있고, 선택된 실행 엔진을 위한 코드가 생성될 수 있는 적합한 방 식으로 방향성 비순환 그래프를 수정할 수 있다. 방향성 비순환 그래프에 수행될 수 있는 수정들 (modifications)의 예시 유형들은 방향성 비순환 그래프로부터 하나 이상의 노드들을 제거하는 것, 하나 이상의 다른 노드들로 방향성 비순환 그래프 내 하나 이상의 노드들을 대체하는 것 및/또는 방향성 비순환 그래프 내 하나 이상의 노드들의 위치(들)나 순서(들)를 섞는 것을 포함할 수 있다. 방향성 비순환 그래프 내 각각의 노 드는 일반적으로 변환들의 시퀀스의 일부로 수행될 데이터 동작을 표현한다. 방향성 비순환 그래프의 노드들이 수정되는 특정한 방식들은 코드가 실행될 특정한 실행 엔진과 같이, 다수의 요인들에 기초하여 달라 질 수 있으며, 일부 경우들에서 방향성 비순환 그래프에 수정들이 필요하지 않을 수 있다. 수정되거나 수정되 지 않은 방향성 비순환 그래프는 선택된 실행 엔진을 위한 코드를 생성하기 위해 이용될 수 있다. 컴파일러는 또한 요청에 응답하여 수신된 보다-일반적인 아티팩트들(more-generic artifacts)에 기초하여 실행 엔진-특정 아티팩트들을 생산하기 위해 이용될 수 있다. 코드가 어떤 방식으로 생성되든, 코드(33 4)는 원하는 변환들의 시퀀스를 수행하기 위해 선택된 실행 엔진에 의해 실행될 수 있다. 실행 엔진을 위한 코드의 생성이 (사용자들(306, 318) 또는 애플리케이션들이 변환들의 시퀀스 들의 실행을 요청한 후와 같은) 런-타임(run-time) 동안 수행되는 것으로 위에서 설명되지만, 다른 접근들 또 한 코드를 생성하기 위해 이용될 수 있다. 예를 들어, 각각의 실행 엔진을 위한 코드는 각각의 변환들의 시퀀스와 연관된 데이터가 획득되고 데이터베이스 내에 저장된 후 생성될 수 있다. 일부 경우들에서, 각각의 실행 엔진을 위한 코드도 데이터베이스 내에 저장될 수 있다. 일단 (특정 한 요청에 응답하는 것과 같이) 특정한 실행 엔진이 식별되면, 적절한 변환들의 시퀀스에 대해 미리- 생성된 코드가 획득되어 (추가적인 컴파일링 없이) 해당 특정한 실행 엔진에 실행을 위해 제공될 수 있다. 일반적으로, 본 개시는 요청 수신 및 코드 생성의 임의의 특정한 순서로 제한되지 않는다. 여기에서 볼 수 있듯이, 이 접근은 제작 환경으로 하여금, 임의의 원하는 데이터 변환들의 시퀀스들을 정 의하기 위해 이용되도록 할 수 있고, 여기에서 데이터 변환들의 시퀀스들을 정의하는 정보는 나중에 이용하기 위한 데이터베이스 또는 다른 위치(들)에 저장될 수 있다. 이는 제작 환경 내 임의의 적합한 인터페 이스(들)을 이용하여 달성될 수 있다. 또한, 이 접근은 실행 환경으로 하여금, 요청된 대로 변환들 의 시퀀스들을 실행하기 위해 이용되도록 할 수 있고, 이는 (적어도 부분적으로) 데이터베이스 또는 다른 위치(들)로부터 검색된 정보에 기초한다. 다른 무엇보다도, 수행될 각각의 변환들의 시퀀스에 대한 실행 엔진 은 연관된 컨텍스트에 기초하여 동적으로 선택될 수 있다. 이러한 방식으로, 아키텍처는 구현에 기초하여 다양한 이점들 또는 장점들을 제공할 수 있다. 다음은 아 키텍처를 이용하여 획득될 수 있는 다양한 유형들의 이점들 또는 장점들의 비-제한적인 예시들이다. 예를 들어, 아키텍처는 코드를 한 번 개발된 다음 상이한 이용 케이스들(상이한 컨텍스트들)에 거쳐 재이용될 수 있도록 할 수 있다. 예를 들어, 사용자는 제작 환경 내에서 데이터세트를 이용하여 데이터 변환들의 시퀀스를 수행하기 위한 코드를 작성할 수 있으며, 여기에서 해당 변환들의 시퀀스는 하나의 컨텍스트 와 연관되고 하나의 실행 엔진에 의해 실행을 위한 코드를 생성하기 위해 이용될 수 있다. 해당 코드는 상이한 컨텍스트들과 연관될 수 있는 다른 실행 엔진들의 임의의 수에 의한 실행을 위해 실행 모듈에 의해 나중에 번역될 수 있다. 사용자에 대한 원래 이용을 위해 선택된 특정한 실행 엔진 및 후속 요 청과 함께 이용하기 위해 선택된 특정한 실행 엔진은 해당 동작들과 연관된 특정한 컨텍스트들 에 기초하여 달라질 수 있다. 이는 동일한 변환들의 시퀀스를 실행하기 위해 이용되는 컨텍스트들 및 실행 엔 진들로 하여금, (무엇보다도) 사용자(306, 318) 또는 애플리케이션의 변화하는 요구 사항들에 기초하 여 달라질 수 있도록 한다. 또 다른 예시로서, 아키텍처는 시스템-구동 백엔드들(system-driven backends) 및 사용자-구동 백엔드들 (user-driven backends) 중에서 선택할 때 유연성을 제공하기 위해 이용될 수 있다. 예를 들어, 일부 실시예들 에서, 실행 모듈은 사용자들(306, 318) 및/또는 애플리케이션들로 하여금, 그들의 데이터를 프로세스 하기 위해 이용될 실행 엔진들을 선택하도록 할 수 있다. 다른 무엇보다도, 이는 사용자(306, 318) 또는 애플리케이션으로 하여금, 특정한 데이터와 함께 이용하기 위한 특정한 실행 엔진을 선택하도록 할수 있으며, 이는 특정한 실행 엔진이 특정한 유형들의 데이터 프로세싱 작업들을 수행할 때 좋은 결과를 제공하는 것으로 알려져 있는 경우 유용할 수 있다. 그러나, 실행 모듈은 사용자(306, 318) 또는 애플리 케이션이 실행 엔진을 구체적으로 식별하지 않거나 사용자(306, 318) 또는 애플리케이션이 실행 엔진의 동적 선택을 구체적으로 요청하는 경우와 같이, 이용될 실행 엔진을 동적으로 선택할 수도 있 다. 또 다른 예시로서, 아키텍처는 데이터 프로세싱 작업들을 수행하기 위한 가치-실현-시간(time-to-value)을 가속화하기 위해 이용될 수 있다. 예를 들어, 데이터-집약적 워크로드들(data-intensive workloads)은 종종 시 간이 지남에 따라 백엔드 요구 사항들을 변경하는 것을 포함할 수 있고, 이는 대게 데이터-집약적 워크로드들에 이용되는 실행 엔진에 대한 시간-소모적 변경들(time-consuming changes)을 수반한다. 아키텍처를 이용하 면, 데이터 변환들의 시퀀스들을 제작하는 복잡성이 줄어들 수 있고, 동일한 데이터 변환들의 시퀀스는 활용되 어 (사용자(306, 318)/애플리케이션 또는 동적으로 아키텍처에 의해 선택된 실행 엔진을 포함하 는) 임의의 수의 실행 엔진들 상에서 코드를 실행하기 위해 이용될 수 있다. 일부 경우들에서, 사용 자는 변환을 정의하기 위해 단일 인터페이스를 이용할 수 있고, 변환을 수행하기 위해 이용되는 특정 한 백엔드는 (동적으로 달라질 수 있는) 수행되는 데이터 프로세싱 작업의 특성에 의존하여 변경될 수 있다. 이는 데이터 프로세싱 작업들을 수행하기 위해 필요한 시간을 크게 줄일 수 있다. 또 다른 예시로서, 아키텍처는 이용할 실행 엔진들을 선택할 때, 서버-인식(server-aware) 및 클라이 언트-인식(client-aware) 결정들을 내리기 위해 이용될 수 있다. 즉, 고객들(사용자들(306, 318) 및/또는 애플 리케이션들)은 그들의 특정한 설치들(installations)에 의존하여 클라이언트들 또는 서버들로 동작하는 디 바이스들을 이용하는 로직을 구현할 수 있다. 이에 대한 특정한 예시로서, 일부 설치들은 선언적 프로그래밍 (declarative programming)을 지원할 수 있는 반면, 다른 설치들은 명령형 프로그래밍(imperative programming)을 지원할 수 있다. 그러므로, 상이한 실행 엔진들은 상이한 유형들의 고객 설치들에 대해 맞춤 설정될 수 있다. 일부 실시예들에서, 아키텍처는 선언적 및 명령형 프로그래밍의 이점들을 모두 활 용할 수 있는 자체-선언적 프로그래밍(self-declarative programming)을 이용한다. 아키텍처는 동적으로-선택된 실행 엔진들을 이용하여 코드를 실행할 때 여전히 높은 수준의 퍼포먼스 를 달성할 수 있다는 점을 참고해야 한다. 그 이유는, 다른 이유들 중에서도, 아키텍처가 사용자들(306, 318), 및/또는 애플리케이션들의 요구 사항들에 가장 적합한 상이한 실행 엔진들을 선택할 때(및 필 요한 경우 상이한 실행 엔진들 간에 스위칭할 때), 아키텍처는 리소스 효율성들, 시간 효율성들 및 신뢰성들(reliabilities)을 사용자들(306, 318) 및/또는 애플리케이션들에게 제공할 수 있기 때문이다. 예를 들어, 시간 효율성들은 상호 작용적 및 비-상호 작용적 컨텍스트들 간의 좋은 트레이드-오프들(trade- offs)을 제공함으로써 획득될 수 있다. 일부 경우들에서, 예를 들어, 이는 낮은 신뢰성에서 더 빠른 출력들 또 는 높은 신뢰성에서 더 느린 출력들이 가능하게 할 수 있다. 더욱이, 아키텍처는 심지어 최소한의 리소스 들이 데이터를 프로세스하기 위해 이용 가능하더라도, 실-시간 및 스트리밍 데이터를 포함하는 광범위한 데이터 유형들 상에서 데이터 변환들을 수행하기 위해 이용될 수 있다. 게다가, 데이터 프로세싱 작업들에 대한 컨텍 스트들의 보안-관련 측면들이 아키텍처 내에서 식별되고 수용될 수 있다. 각각의 변환들의 시퀀스에 대해 선택된 실행 엔진에 의해 코드의 실행을 통해 생성되는 결과들은 임 의의 적합한 방식으로 이용될 수 있다. 예를 들어, 각각의 실행 엔진에 의해 생성된 결과들은 변환들의 시퀀스의 퍼포먼스를 시작한 사용자(306, 318) 또는 애플리케이션에 적합한 인터페이스 또는 다른 메 커니즘을 통해 제공될 수 있다. 데이터 프로세싱 작업들 및 데이터 프로세싱 작업들에 의해 프로세스되는 데이 터는 모두 크게 달라질 수 있으므로, 실행 엔진들에 의해 생성된 결과들은 임의의 적합한 목적들에 이용될 수 있다. 도 3과 관련하여 도시되거나 설명되는 기능들은 임의의 적합한 방식으로, 컴퓨팅 디바이스와 같은 전자 디바이 스 내에서 구현될 수 있다는 점을 참고해야 한다. 예를 들어, 일부 실시예들에서, 도 3과 관련하여 도시되거나 설명되는 기능들의 적어도 일부는 애플리케이션 서버, 디바이스 또는 다른 디바이스의 하나 이상의 프로세싱 디바이스들에 의해 실행되는 하나 이상의 소프트웨어 애플리케이션들 또는 다른 소프트웨어 명령어들 을 이용하여 구현되거나 지원될 수 있다. 다른 실시예들에서, 도 3과 관련하여 도시되거나 설명되는 기능들의 적어도 일부는 전용 하드웨어 구성 요소들을 이용하여 구현되거나 지원될 수 있다. 일반적으로, 도 3과 관련하 여 도시되거나 설명되는 기능들은 임의의 적합한 하드웨어 또는 임의의 적합한 하드웨어와 소프트웨어/펌웨어 명령어들의 조합을 이용하여 수행될 수 있다.도 3은 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱 시스템의 아키텍처의 일례 를 설명하지만, 다양한 변경들이 도 3에 가해질 수 있다. 예를 들어, 기능들 및 구성 요소들이 특정한 요구 사 항들에 따라 아키텍처 내에서 추가되거나, 생략되거나, 결합되거나, 더 세분화되거나, 복제되거나 또는 임 의의 다른 적합한 구성으로 배치될 수 있다. 특정한 예시로서, 아키텍처는 임의의 적합한 수의 인터페이 스들 및 임의의 적합한 수의 실행 엔진들을 포함할 수 있다. 도 4는 본 공개에 따라 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱을 위한 예시적인 방법을 설명한다. 설명의 편의를 위해, 도 4에 도시된 방법은 도 1에 도시된 시스템 내 애플리 케이션 서버 상에서 구현되거나 지원되는 것으로 설명되며, 여기에서 애플리케이션 서버는 도 2에 도 시된 디바이스의 하나 이상의 인스턴스들을 이용하여 구현될 수 있다. 그러나, 도 4에 도시된 방법 은 임의의 다른 적합한 디바이스 및 임의의 다른 적합한 시스템을 이용하여 수행될 수 있다. 도 4에 도시된 바와 같이, 사용자가 입력 데이터세트를 로딩하고 단계에서 입력 데이터세트에 적용될 변환 들의 시퀀스를 정의하도록 하는 인터페이스가 제공된다. 이는 예를 들어, 사용자에게 적어도 하나의 인터 페이스를 제시하는 애플리케이션 서버의 프로세싱 디바이스를 포함할 수 있다. 인터페이스 는 사용자로 하여금, 데이터세트를 로딩하고 데이터세트를 수반하여 수행될 변환들의 시퀀 스를 식별하도록 할 수 있다. 입력 데이터세트와 연관된 컨텍스트는 단계에서 식별된다. 이는 예를 들어, 하나 이상의 컨텍스트 차원들의 하나 이상의 값들을 결정하기 위해 컨텍스트 모듈을 이용하는 애플 리케이션 서버의 프로세싱 디바이스를 포함할 수 있다. 변환들의 시퀀스 내에서 변환을 정의하는 정보는 단계에서 획득되고 단계에서의 그래프 내 노드를 생 성하기 위해 이용된다. 이는 예를 들어, 인터페이스를 이용하는 사용자에 의해 정의되는 변환과 연 관된 정보를 획득하기 위해 트래킹 모듈을 이용하는 애플리케이션 서버의 프로세싱 디바이스를 포함할 수 있다. 이는 또한 변환을 식별하고 선택적으로 노드를 서명하는 방향성 비순환 그래프 내에서 해당 노드를 생성하는 애플리케이션 서버의 프로세싱 디바이스를 포함할 수 있다. 사용자가 단계에 서 변환들을 계속 정의하는 한, 프로세스는 변환들에 대한 정보를 수집하고 그래프 내 노드들을 생성하기 위해 단계 내지 단계를 반복할 수 있다. 일단 터미널 변환이 사용자에 의해 제공되면, 완성된 그래프가 단계에서 저장소 내에 저장된다. 이는 예를 들어, 데이터베이스 내 방향성 비순환 그래프를 저장하 는 애플리케이션 서버의 프로세싱 디바이스를 포함할 수 있다. 방향성 비순환 그래프는 백엔드-애그 노스틱(backend-agnostic) 변환들의 시퀀스를 표현할 수 있거나, 방향성 비순환 그래프는 백엔드-애그노스틱 변 환들의 시퀀스를 생성하기 위해 이용될 수 있다. 변환들의 시퀀스를 수행하기 위해 이용될 실행 엔진은 단계에서 식별된 컨텍스트에 기초하여 식별된다. 이는 예를 들어, 실행 모듈을 이용하는 애플리케이션 서버의 프로세싱 디바이스가 어떻게 입력 데이터세트와 연관된 컨텍스트 차원(들)의 값(들)이 실행 엔진들 중 특정한 하나에 매핑되는지 결정 하는 것을 포함할 수 있다. 선택된 실행 엔진에 의해 실행될 코드는 단계에서 생성된다. 이는 예를 들어, 선택된 실행 엔진에 기초하여 (필요한 경우) 방향성 비순환 그래프를 수정하기 위해 실행 모듈(32 6)을 이용하는 애플리케이션 서버의 프로세싱 디바이스를 포함할 수 있다. 이는 또한 실행 엔진-특 정 코드를 생산하기 위해 수정되거나 수정되지 않은 방향성 비순환 그래프 또는 다른 정보를 컴파일하는 컴파일러를 포함할 수 있다. 코드는 단계에서 데이터 상에 변환들의 시퀀스를 수행하기 위해 선택된 실행 엔진을 이용하여 실행될 수 있다. 이는 예를 들어, 실행 엔진-특정 코드를 실행하고 입력 데이터세트 상에 변환들의 시퀀스를 수행하기 위해 선택된 실행 엔진을 이용하는 애플리케이션 서버의 프 로세싱 디바이스를 포함할 수 있다. 코드 실행의 결과들은 단계에서 적어도 하나의 적합한 목적지에 제공된다. 이는 예를 들어, 인터페이스를 통해 사용자에게 데이터 프로세싱 결과들을 제공하는 선택 된 실행 엔진을 포함할 수 있다. 이 포인트에서, 동일한 사용자, 또 다른 사용자 또는 애플리케이션에 의해 동일한 변환들의 시 퀀스에 대해 요청될 수 있다. 결과적으로, 단계에서 변환들의 시퀀스에 대한 요청이 수신되었는지 여부에 대한 결정이 이루어진다. 이는 예를 들어, 사용자 또는 애플리케이션으로부터 변환들의 시퀀스를 식 별하는 요청이 수신되었는지 여부를 결정하는 애플리케이션 서버의 프로세싱 디바이스를 포함할 수 있다. 일부 경우들에서, 요청은 적용될 변환들의 시퀀스 및 변환들의 시퀀스가 적용될 데이터를 식별할 수 있다. 프로세스는 그 다음 단계들(414 내지 420)을 수행하지만, 이번에는 현재 컨텍스트는 새 로운 요청에 대해 결정되고 (사용자에 대해 처음에 이용된 것과 동일한 실행 엔진일 수도 있고 아닐 수도 있는) 적절한 실행 엔진을 선택하는 데 이용된다. 여기에서 단계들(414 내지 420)은 요청들의 임의의 수에 기초하여 몇 번이고 반복될 수 있으며, 각각의 요청은 그것의 고유한 컨텍스트 와 연관될 수 있다. 도 4는 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱을 위한 방법의 일례를 설명 하지만, 다양한 변경들이 도 4에 가해질 수 있다. 예를 들어, 일련의 단계들로 도시되어 있지만, 도 4 내의 다 양한 단계들은 겹치거나, 병렬로 발생하거나, 상이한 순서로 발생하거나 몇 번이고 반복하여 발생할 수 있다. 특정한 예시로서, 위에서 언급한 바와 같이, 실행 엔진-특정 코드는 요청의 수신 전에 하나 이상의 실행 엔진들에 대해 생성될 수 있다. 도 5는 본 개시에 따라 선택된 백엔드에 의한 실행을 위한 실행 엔진-특정 코드를 생성하기 위한 예시적인 프로 세스를 설명한다. 도 5에 도시된 프로세스는 예를 들어, 인터페이스를 통해 사용자 입력을 수 집하는 프로세스를 표현하고, 여기에서 사용자 입력은 수행될 데이터 변환들의 시퀀스를 정의한다. 도 5에 도 시된 프로세스는 또한 트래킹 모듈이 데이터 변환들의 시퀀스에 대한 정보를 어떻게 생성할 수 있는 지와, 실행 모듈이 선택된 실행 엔진에 의한 실행을 위한 적합한 실행 엔진-특정 코드를 생산하 기 위해 이 정보를 이용하는지를 설명한다. 도 5에 도시된 바와 같이, 하나 이상의 데이터 소스들은 하나 이상의 사용자들로부터 데이터를 획득 하기 위해 이용될 수 있는 (하나 이상의 인터페이스들과 같은) 하나 이상의 인터페이스들을 표현한다. 일 부 실시예들에서, 각각의 데이터 소스는 상이한 프로그래밍 언어 및 상이한 데이터 저장소 메커니즘과 연 관될 수 있다. 구현에 의존하여, 여기에서 이용하기 위해 제공되는 단일 데이터 소스 또는 다수의 데이터 소스들이 있을 수 있다. 각각의 사용자는 하나 이상의 특정한 프로그래밍 언어들로 데이터 변환들의 시퀀스들을 정의하는 코드를 작성하기 위해 하나 이상의 도구들을 이용할 수 있다. 일부 실시예들에서, 각각의 사용자에 의해 액 세스되고 이용되는 도구는 사용자에 의해 이용되는 데이터 소스에 의존하여 달라질 수 있으므로, 상이한 데이터 소스들은 상이한 도구들과 연관될 수 있다. 일부 경우들에서, 예를 들어, 도구는 판다스 프로그래밍 언어(Pandas programming language)를 이용하는 주피터 랩 도구(JUPYTER LAB 도구)를 표현할 수 있다. 물론, 상이한 도구들이 원하는 경우 상이한 프로그래밍 언어들을 지원하기 위해 제공될 수 있다. 각각의 도구는 수행될 동작들의 시퀀스를 정의하기 위해 이용될 수 있으며, 여기에서 동작들의 시퀀스는 사용자에 의해 정의되는 데이터 변환들의 시퀀스를 표현한다. 시퀀스 내의 각각의 동작은 셀에 의해 표현될 수 있으며, 각각의 셀은 사용자에 의해 정의되는 적어도 하나의 동작을 식별할 수 있다. 이 예시에서, 첫 번째 셀은 하나 이상의 소스 데이터 파일들을 로딩하는 요청을 나타낸다. 두 번째 셀 은 하나 이상의 데이터 통합 동작들(data integration operations)을 수행하는 적어도 하나의 요청을 표현하고, 여기에는 프로세싱을 위한 소스 데이터를 준비하기 위한 임의의 적합한 동작(들)을 포함할 수 있다. 세 번째 셀은 특징 엔지니어링(feature engineering)과 관련된 적어도 하나의 요청을 표현하고, 여기에는 더 프로 세스될 소스 데이터의 특징들을 식별하기 위해 필요한 임의의 적합한 동작(들)을 포함할 수 있다. 네 번째 셀 은 머신 러닝 파이프라인(machine learning pipeline) 또는 다른 데이터 프로세싱 아키텍처에 (식별된 특 징들과 같은) 프로세스된 데이터를 공급하는(feeding) 것과 관련된 적어도 하나의 요청을 표현한다. 다섯 번째 셀은 동작들의 시퀀스를 압축하는 패키지를 업데이트하는 요청을 표현한다. 물론, 셀들에 의해 표현 되는 동작들은 사용자에 의해 정의되는 특정한 데이터 변환들의 시퀀스에 기초하여 달라질 수 있다. 일부 경우들에서, 셀들은 특정한 사용자들을 특정한 셀들에 연관시키고 및/또는 셀들의 무단 수 정(unauthorized modification)을 방지하기 위해 (사용자들의 디지털 키들을 이용하는 것과 같이) 디지털적으로 서명될 수 있다. 도구를 이용하여 사용자에 의해 생성된 각각의 사용자-정의된 동작들의 시퀀스는 (실행되는 경우) 사 용자-정의된 동작들의 시퀀스를 수행하기 위해 이용될 수 있는 시스템-생성된 코드로 변환된다. 일부 경 우들에서, 시스템-생성된 코드는 방향성 비순환 그래프를 이용하여 정의될 수 있으며, 방향성 비순환 그래 프는 다수의 노드들을 포함한다. 방향성 비순환 그래프 내에서 각각의 노드는 수행될 하나 이상의 동작들을 표현하고, 각각의 노드는 도구를 이용하여 생성된 셀들 중 하나에 대응할 수 있다. 예를 들어, 각각의 노드는 대응하는 셀 내에서 수행되는 특정한 동작(들)을 식별하는 하나 이상의 데 이터 사양들(data specifications)(\"데이터 스펙들(data specs)\")을 포함할 수 있다. 노드들 내에서 정 의되는 정보는 도구를 이용하는 사용자에 의해 생성되는 코드의 모든 라인에 대응하는 동작들을 식별할 수 있다. 따라서, 방향성 비순환 그래프의 노드들은 사용자-정의된 동작들의 시퀀스를 구현하기 위해 필요한 로직을 표현할 수 있다. 그러나, 방향성 비순환 그래프는 특정한 실행 엔진에 묶이지 않는다는 점 에서 일반적일 수 있다. 여기에서 볼 수 있듯이, 노드들은 노드들이 노드들로/로부터의/사이의 화살표들에 의해 정의되는 특정한 시퀀스로 정렬되어 있기 때문에, 방향성 비순환 그래프를 형성한다. 일부 경 우들에서, 방향성 비순환 그래프는 사용자가 변환들의 시퀀스를 정의하기 위해 인터페이스를 이용하 는 경우, 트래킹 모듈이 생성하여 데이터베이스 내에 저장할 수 있는 아이템들 중 적어도 하나이다. 사용자가 (사용자에 의해 정의되는 최종 변환을 의미하는) 터미널 변환을 실행한 후, 방향성 비순환 그래프는 데이터페이스 내에 저장될 수 있다. 또한, 특정한 실행 엔진은 사용자와 연관된 현재 컨텍스트에 기초하여 위에서 설명한 대로 선택될 수 있다. 선택된 실행 엔진 상에 방향성 비순환 그래프 에 의해 정의되는 변환들의 시퀀스를 실행하기 위해, 방향성 비순환 그래프는 선택된 실행 엔진에 의한 실 행을 위해 적합한 코드로 변환될 수 있다. 방향성 비순환 그래프는 수행될 동작들을 통칭적으로 (generically) 정의하기 때문에, 방향성 비순환 그래프는 코드가 실행될 실행 엔진에 특정한 코드 로 쉽게 변환될 수 있다. 그 다음에 코드는 컴파일되거나 또는 그렇지 않으면 준비되어 실행을 위한 선택된 실행 엔진으로 전송될 수 있다. 동일한 변환들의 시퀀스가 (요청을 통한 것과 같이) 다시 요 청되지만 상이한 실행 엔진이 선택되는 경우, 방향성 비순환 그래프는 다시 검색되어 해당 선택된 실행 엔 진에 의한 실행을 위해 코드를 생성하기 위해 이용될 수 있다. 코드가 특정한 실행 엔진 을 위해 생성된 후, 코드가 (예를 들어 데이터베이스 내에) 저장되어 지연 없이 요청되면 나중에 다 시 코드가 실행될 수 있다. 코드 내에서 수행되는 특정한 동작들은 전형적으로 (다른 무엇보다도) 코드를 실행하기 위해 이용될 실행 엔진에 의존하여 달라질 수 있다는 점을 참고해야 한다. 방향성 비순환 그래프는 사용자-정의된 동 작들의 시퀀스의 일부로 수행될 동작들을 통칭적으로 정의하는 데이터 스펙들 또는 다른 정보를 포함하기 때문 에, 특정한 실행 엔진의 지식은 실행 모듈로 하여금, 데이터 스펙들을 실행 엔진-특정 코드로 변환하 도록 하는 로직을 생성하기 위해 이용될 수 있다. 이용 가능한 모든 실행 엔진들을 위한 적합한 로직을 정의함으로써, 실행 모듈은 사용자-정의된 동작들의 시퀀스들의 실행들이 요청될 때마다 방향성 비순환 그 래프들을 적합한 코드로 변환할 수 있다. 도 5는 선택된 백엔드에 의한 실행을 위한 실행 엔진-특정 코드를 생성하기 위한 프로세스의 일례를 설명 하지만, 다양한 변경들이 도 5에 가해질 수 있다. 예를 들어, 사용자에 의해 정의된 코드는 임의의 적합한 수 의 동작들을 포함할 수 있고, 이러한 동작들은 선택된 실행 엔진에 의해 실행될 임의의 적합한 동작들로 변환될 수 있다. 또한, 도 5에 도시된 특정한 코드는 특정한 실행 엔진와 관련이 있으며, 임의의 다 른 적합한 코드가 실행 엔진에 의존하여 생성될 수 있다. 다음은 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱 시스템을 구현하는 본 개시의 예 시적인 실시예들을 설명한다. 그러나, 다른 실시예들이 본 개시의 교시들(teachings)에 따라 이용될 수 있다. 첫 번째 실시예에서, 방법은 사용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 변환들의 시퀀스를 식별 하는 단계를 포함한다. 상기 방법은 상기 입력 데이터세트와 연관된 제1 컨텍스트를 식별하는 단계를 포함한다. 상기 방법은 상기 제1 컨텍스트에 기초하여 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하는 단계를 더 포함한다. 게다가, 상기 방 법은 상기 제1 실행 엔진에 상기 변환들의 시퀀스를 구현하는 제1 코드를 제공하는 단계 및 상기 입력 데이터세 트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진을 이용하여 상기 제1 코드를 실행하는 단 계를 포함한다. 두 번째 실시예에서, 장치는 사용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 변환들의 시퀀스를 식별 하도록 구성되는 적어도 하나의 프로세싱 디바이스를 포함한다. 상기 적어도 하나의 프로세싱 디바이스는 또한 상기 입력 데이터세트와 연관된 제1 컨텍스트를 식별하도록 구성된다. 상기 적어도 하나의 프로세싱 디바이스 는 또한 상기 제1 컨텍스트에 기초하여 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 이 용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하도록 더 구성된다. 게다가, 상기 적어도 하나의 프로세싱 디바이스는 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진을 이용하 여 상기 변환들의 시퀀스를 구현하는 제1 코드를 실행하도록 구성된다. 세 번째 실시예에서, 비-일시적 컴퓨터 판독 가능 매체는 실행되는 경우 하나 이상의 프로세서들로 하여금, 사 용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 변환들의 시퀀스를 식별하도록 하는 컴퓨터 판독 가능프로그램 코드를 저장한다. 상기 매체는 또한 실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 상기 입 력 데이터세트와 연관된 제1 컨텍스트를 식별하도록 하는 컴퓨터 판독 가능 프로그램 코드를 저장한다. 상기 매체는 실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 상기 제1 컨텍스트에 기초하여 상기 입력 데이터 세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 이용될 다수의 실행 엔진들 중 제1 실행 엔진을 선택하도록 하는 컴퓨터 판독 가능 프로그램 코드를 더 저장한다. 게다가, 상기 매체는 실행되는 경우 상기 하나 이상의 프로세서들로 하여금, 상기 입력 데이터세트 상에서 상기 변환들의 시퀀스를 수행하기 위해 상기 제1 실행 엔진 을 이용하여 상기 변환들의 시퀀스를 구현하는 제1 코드를 실행하도록 하는 컴퓨터 판독 가능 프로그램 코드를 저장한다. 다음 특징들 중 하나 또는 임의의 적합한 조합이 첫 번째, 두 번째 또는 세 번째 실시예와 함께 이용될 수 있다. 사용자 인터페이스는 다수의 사용자 인터페이스들 중 하나를 포함할 수 있으며, 각각의 사용자 인터페이 스는 하나 이상의 사용자들로 하여금, 입력 데이터세트들 상에서 수행될 변환들의 시퀀스들을 정의하도록 구성 될 수 있다. 변환들의 시퀀스와 연관된 그래프는 저장될 수 있고, 제1 코드는 그래프에 기초하여 생성될 수 있 다. 제1 컨텍스트는 변환들의 시퀀스 동안 사용자 또는 애플리케이션 상호 작용들의 양 또는 레벨을 표현하는 상호 작용성 컨텍스트 차원; 변환들의 시퀀스 동안 프로세스될 데이터의 크기 또는 양을 표현하는 데이터 크기 컨텍스트 차원; 변환들의 시퀀스 동안 프로세스될 데이터의 유형을 표현하는 데이터 유형 컨텍스트 차원; 변환 들의 시퀀스 동안 프로세스될 데이터가 구조화되었는지 또는 비구조화되었는지 여부를 표현하는 데이터 모양 컨 텍스트 차원; 변환들의 시퀀스 동안 데이터를 프로세싱하는 과정에서 필요한 보안의 레벨을 표현하는 보안 프로 파일 컨텍스트 차원; 변환들의 시퀀스 동안 데이터를 프로세스하기 위해 필요한 리소스들의 양 또는 레벨을 표 현하는 리소스 가용성 컨텍스트 차원; 변환들의 시퀀스 동안 프로세스될 데이터가 개인 식별 가능 정보를 포함 하는지 여부를 표현하는 개인 식별 가능 정보(PII) 컨텍스트 차원; 변환들의 시퀀스 동안 프로세스될 데이터 또 는 그 결과들이 보유되어야 하는 기간을 표현하는 보유 정책 컨텍스트 차원; 및 변환들의 시퀀스 동안 계산들에 포함될 데이터의 전체 양 또는 레벨을 표현하는 계산 포괄성 컨텍스트 차원 중 적어도 하나에 기초할 수 있다. 지정된 데이터 상에서 변환들의 시퀀스를 수행하기 위한 요청 요청이 수신될 수 있으며, 요청과 연관된 제2 컨 텍스트가 식별될 수 있고(제2 컨텍스트는 제1 컨텍스트와 상이할 수 있음), 지정된 데이터 상에서 변환들의 시 퀀스를 수행하기 위해 이용될 실행 엔진들 중 제2 실행 엔진이 제2 컨텍스트에 기초하여 선택될 수 있고(제2 실 행 엔진은 제1 실행 엔진과 상이할 수 있음), 변환들의 시퀀스를 구현하는 제2 코드가 지정된 데이터 상에서 변 환들의 시퀀스를 수행하기 위해 제2 실행 엔진을 이용하여 실행될 수 있다. 입력 데이터세트 상에서 수행될 변 환들의 시퀀스를 식별하는 정보는 식별자와 함께 데이터 저장소 내에 저장될 수 있고, 요청은 식별자를 포함할 수 있다. 변환들의 시퀀스는 사용자 인터페이스를 통해 입력 데이터세트 상에서 수행될 다수의 변환들을 식별 하고, 각각의 변환에 대해, 변환을 정의하고 노드를 서명하는 방향성 비순환 그래프 내에 노드를 생성함으로써, 식별될 수 있다. 일부 실시예들에서, 이 특허 문서 내 설명된 다양한 기능들은 컴퓨터 판독 가능 프로그램 코드로부터 형성되고 컴퓨터 판독 가능 매체에 구현되는 컴퓨터 프로그램에 의해 구현되거나 지원된다. \"컴퓨터 판독 가능 프로그램 코드\"라는 문구는 소스 코드, 목적 코드(object code) 및 실행 가능 코드를 포함하는 임의의 유형의 컴퓨터 코 드를 포함한다. \"컴퓨터 판독 가능 매체\"라는 문구는 읽기 전용 메모리(read only memory; ROM), 랜덤 액세스 메모리(random access memory; RAM) 하드 디스크 드라이브(hard disk drive; HDD), 컴팩트 디스크(compact disc; CD), 디지털 비디오 디스크(digital video disc; DVD) 또는 임의의 다른 유형의 메모리와 같은, 컴퓨터 에 의해 액세스될 수 있는 임의의 유형의 매체를 포함한다. \"비-일시적\" 컴퓨터 판독 가능 매체는 일시적인 전 기적 또는 다른 신호들을 전송하는 유선, 무선, 광학 또는 다른 통신 링크들을 제외한다. 비-일시적 컴퓨터 판 독 가능 매체는 데이터가 영구적으로 저장되는 매체 및 다시 쓸 수 있는 광 디스크 또는 지울 수 있는 저장 디 바이스와 같이 데이터가 저장되고 나중에 덮어쓸 수 있는 매체를 포함한다. 이 특허 문서 전체에서 이용되는 특정 단어들과 문구들의 정의들을 제시하는 것이 유리할 수 있다. \"애플리케 이션\" 및 \"프로그램\"이라는 용어들은 하나 이상의 컴퓨터 프로그램들, 소프트웨어 구성 요소들, 명령어들의 세 트들, 절차들, 기능들, 객체들, 클래스들, 인스턴스들, 관련 데이터 또는 (소스 코드, 객체 코드 또는 실행 가 능 코드를 포함하는) 적절한 컴퓨터 코드에서의 구현을 위해 적용된 그 부분을 지칭한다. \"통신하다\"라는 용어 와 그 파생어들은 직접 및 간접 통신 모두를 포괄한다. \"포함하다(include)\" 및 \"포함하다(comprise)\"라는 용 어들과 그 파생어들은 제한 없는 포함을 의미한다. \"또는(or)\"이라는 용어는 포함적이며, 및/또는(and/or)을 의미한다. \"연관된\"이라는 문구와 그 파생어들은 포함하다, 포함되다, 상호 연결하다, 함유하다, 함유되다, 연 결하다 또는 함께 연결하다, 커플링하다 또는 함께 커플링하다, 통신할 수 있다, 협력하다, 끼우다 (interleave), 병치하다(juxtapose), 근접하다(be proximate to), 바운드되다 또는 함께 바운드되다, 가지다,속성을 가지다, 관계가 있다 또는 함께 관계가 있다 등을 의미할 수 있다. \"적어도 하나\" 및 \"하나 이상의\"이 라는 문구들이 아이템들의 목록과 함께 이용되는 경우, 하나 이상의 목록 아이템들의 조합들이 이용될 수 있고, 목록에서의 오직 하나의 아이템이 필요할 수 있다. 예를 들어, \"A, B 및 C 중 적어도 하나\"에는 다음의 조합들 중 하나를 포함한다: A, B, C, A 및 B, A 및 C, B 및 C 그리고 A, B 및 C. 본 개시의 설명은 특정한 요소, 단계 또는 기능이 청구 범위에 포함되어야 하는 필수적 또는 중요한 요소라는 것을 암시하는 것으로 해석되어서는 안 된다. 특허 기술 사상의 범위는 허용되는 청구항에 의해서만 정의된 다. 더욱이, 어떤 청구항들도 기능을 식별하는 특정한 문구에 의해 뒤따르는 \"~하는 수단(means for)\" 또는 \"~ 하는 단계(step for)\"라는 정확한 단어들이 명시적으로 특정한 청구항 내에서 이용되지 않는 한, 첨부된 청구항 들 또는 청구항 요소들과 관련하여 미국 특허법 제112조 (f)항을 적용하지 않는다. 청구항 내에서 \"메커니즘\", \"모듈\", \"디바이스\", \"유닛\", \"구성 요소\", \"요소\", \"멤버\", \"장치\", \"머신\", \"시스템\", \"프로세서\" 또는 \"컨트 롤러\"와 같은 (그러나 제한되지는 않는) 용어들의 이용은 관련 기술 분야 당업자들에게 알려진 구조들을 지칭하 는 것으로 이해되고 의도되며, 청구항들 자체의 특징들에 의해 더 수정되거나 향상되며, 미국 특허법 제112조 f 항을 적용하기 위한 의도가 아니다. 본 개시는 특정 실시예들 및 일반적으로 연관되는 방법들을 설명했지만, 이러한 실시예들 및 방법들의 변화들 (alterations) 및 치환들(permutations)은 당업자들에게 명백할 것이다. 이에 따라, 예시적인 실시예들에 대한 전술된 설명은 본 개시를 정의하거나 제한하지 않는다. 이하 청구항들에 의해 정의되는 바와 같이, 다른 변경 들(changes), 대체들(substitutions) 및 변화들도 본 개시의 취지(spirit) 및 범위로부터 벗어나지 않고 가능하 다."}
{"patent_id": "10-2024-7034520", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시를 보다 완전하게 이해하기 위해, 첨부된 도면들과 함께 결합하여, 후술하는 설명이 참조된다. 도 1은 본 개시에 따라 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱을 지원하는 예시 적인 시스템을 설명한다. 도 2는 본 개시에 따라 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱을 지원하는 예시 적인 디바이스를 설명한다. 도 3은 본 개시에 따라 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱 시스템의 예시적 인 아키텍처를 설명한다. 도 4는 본 개시에 따라 다중-인터페이스 프런트엔드 및 백엔드를 갖춘 지능형 데이터 프로세싱을 위한 예시적인 방법을 설명한다. 도 5는 본 개시에 따라 선택된 백엔드에 의한 실행을 위한 실행 엔진-특정 코드를 생성하기 위한 예시적인 프로 세스를 설명한다."}
