{"patent_id": "10-2021-7041941", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0024147", "출원번호": "10-2021-7041941", "발명의 명칭": "복합 태스크 기계 학습 시스템 및 방법", "출원인": "삼성전자주식회사", "발명자": "레이 아빅"}}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "태스크(task)를 수행하기 위한 미지의 명령(unknown command)을 수신하는 단계;상기 미지의 명령에 관한 프롬프트(prompt)를 생성하는 단계;상기 프롬프트에 대한 응답으로 하나 이상의 명령어들(instructions) - 상기 하나 이상의 명령어들 각각은 상기태스크의 적어도 일부의 수행에 관한 정보를 제공함 - 을 수신하는 단계;상기 하나 이상의 명령어들 중 각 명령어에 대해 적어도 하나의 액션(action)을 결정하는 단계; 및적어도 하나의 프로세서에 의해, 상기 하나 이상의 명령어들 중 각 명령어에 대한 상기 적어도 하나의 액션에기초하여, 상기 태스크를 수행하기 위한 복합 액션(complex action)을 생성하는(creating) 단계를 포함하는, 복합 태스크 기계 학습(complex task machine learning) 방법."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서, 상기 하나 이상의 명령어들 중 각 명령어에 대한 상기 적어도 하나의 액션을 결정하는단계는, 상기 하나 이상의 명령어들 중 적어도 하나에 기초하여, 지식 베이스(knowledge base)에서 애플리케이션 컨텍스트(application context) 또는 컨텍스트-특정적 액션(context-specific action)을 식별하는 단계를포함하는, 복합 태스크 기계 학습 방법."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1 항에 있어서, 상기 하나 이상의 명령어들 중 각 명령어에 대한 상기 적어도 하나의 액션을 결정하는단계는:상기 하나 이상의 명령어들 중 적어도 하나에 기초하여, 애플리케이션 컨텍스트 또는 컨텍스트-특정적 액션이지식 베이스에서 제공되지 않음을 식별하는 단계;상기 애플리케이션 컨텍스트 또는 상기 컨텍스트-특정적 액션에 관한 정보에 대한 요청을 생성하는(generating)단계; 및상기 요청에 대한 응답으로 상기 애플리케이션 컨텍스트 또는 상기 컨텍스트-특정적 액션에 관한 상기 정보를수신하는 단계를 포함하는, 복합 태스크 기계 학습 방법."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3 항에 있어서, 상기 애플리케이션 컨텍스트 또는 상기 컨텍스트-특정적 액션에 관한 정보에 대한 상기 요청은, 상기 애플리케이션 컨텍스트 또는 상기 컨텍스트-특정적 액션을 지시하기(indicating) 위한 하나 이상의 선택 가능한 아이템들을 제공하는, 사용자 인터페이스(user interface)에 표시되는, 복합 태스크 기계 학습 방법."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1 항에 있어서, 상기 복합 액션을 생성하는 단계는 상기 하나 이상의 명령어들 중 적어도 하나에 대한 상기결정된 적어도 하나의 액션을 상기 하나 이상의 명령어들 중 다른 하나의 명령어의 상기 결정된 적어도 하나의액션에 의존적인 것으로 등록하는(registering) 단계를 포함하는, 복합 태스크 기계 학습 방법."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1 항에 있어서, 상기 하나 이상의 명령어들 중 제1 명령어의 상기 적어도 하나의 액션을 제1 디바이스가 수행할 것을 명령하는(instructing) 단계; 및 상기 하나 이상의 명령어들 중 제2 명령어의 상기 적어도 하나의 액션을 제2 디바이스가 수행할 것을 명령하는공개특허 10-2022-0024147-3-(instructing) 단계를 더 포함하는, 복합 태스크 기계 학습 방법."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1 항에 있어서,상기 태스크를 수행하기 위한 상기 복합 액션을 상기 미지의 명령에 상응하는 하나 이상의 파라미터들와 연관되도록 저장하는 단계; 및상기 미지의 명령과 공통으로 하나 이상의 특징들(features)을 포함하는 후속 명령을 수신함에 응답하여, 상기복합 액션을 실행하는(executing) 단계를 더 포함하는, 복합 태스크 기계 학습 방법."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "적어도 하나의 메모리; 및상기 적어도 하나의 메모리와 결합된 적어도 하나의 프로세서로서, 상기 적어도 하나의 프로세서는:태스크를 수행하기 위한 미지의 명령을 수신하고;상기 미지의 명령에 관한 프롬프트를 생성하며;상기 프롬프트에 대한 응답으로 하나 이상의 명령어들 - 상기 하나 이상의 명령어들 각각은 상기 태스크의 적어도 일부의 수행에 관한 정보를 제공함 - 을 수신하고;상기 하나 이상의 명령어들 중 각 명령어에 대해 적어도 하나의 액션을 결정하며; 상기 하나 이상의 명령어들 중 각 명령어에 대한 상기 적어도 하나의 액션에 기초하여, 상기 태스크를 수행하기 위한 복합 액션을 생성하도록 구성되는 적어도 하나의 프로세서를 포함하는, 복합 태스크 기계 학습을 위한전자 디바이스."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8 항에 있어서, 상기 하나 이상의 명령어들 중 각 명령어에 대한 상기 적어도 하나의 액션을 결정하기 위해,상기 적어도 하나의 프로세서는, 상기 하나 이상의 명령어들 중 적어도 하나에 기초하여, 지식 베이스에서 애플리케이션 컨텍스트 또는 컨텍스트-특정적 액션을 식별하도록 구성되는, 복합 태스크 기계 학습을 위한 전자 디바이스."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제8 항에 있어서, 상기 하나 이상의 명령어들 중 각 명령어에 대한 상기 적어도 하나의 액션을 결정하기 위해,상기 적어도 하나의 프로세서는:상기 하나 이상의 명령어들 중 적어도 하나에 기초하여, 애플리케이션 컨텍스트 또는 컨텍스트-특정적 액션이지식 베이스에서 제공되지 않음을 식별하고;상기 애플리케이션 컨텍스트 또는 상기 컨텍스트-특정적 액션에 관한 정보에 대한 요청을 생성하며;상기 요청에 대한 응답으로 상기 애플리케이션 컨텍스트 또는 상기 컨텍스트-특정적 액션에 관한 상기 정보를수신하도록 구성되는, 복합 태스크 기계 학습을 위한 전자 디바이스."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10 항에 있어서, 상기 애플리케이션 컨텍스트 또는 상기 컨텍스트-특정적 액션에 관한 정보에 대한 상기 요청은, 상기 애플리케이션 컨텍스트 또는 상기 컨텍스트-특정적 액션을 지시하기(indicate) 위한 하나 이상의 선택가능한 아이템들을 제공하는, 사용자 인터페이스에 표시되는, 복합 태스크 기계 학습을 위한 전자 디바이스."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제8 항에 있어서, 상기 복합 액션을 생성하기 위해, 상기 적어도 하나의 프로세서는 상기 하나 이상의 명령어들중 적어도 하나에 대한 상기 결정된 적어도 하나의 액션을 상기 하나 이상의 명령어들 중 다른 하나의 명령어의상기 결정된 적어도 하나의 액션에 의존적인 것으로 등록하도록 구성되는, 복합 태스크 기계 학습을 위한 전자공개특허 10-2022-0024147-4-디바이스."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제8 항에 있어서, 상기 적어도 하나의 프로세서는:상기 하나 이상의 명령어들 중 제1 명령어의 상기 적어도 하나의 액션을 제1 디바이스가 수행할 것을 명령하고(instruct); 상기 하나 이상의 명령어들 중 제2 명령어의 상기 적어도 하나의 액션을 제2 디바이스가 수행할 것을 명령하도록(instruct) 더 구성되는, 복합 태스크 기계 학습을 위한 전자 디바이스."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제8 항에 있어서, 상기 적어도 하나의 프로세서는:상기 태스크를 수행하기 위한 상기 복합 액션을 상기 미지의 명령에 상응하는 하나 이상의 파라미터들와 연관되도록 저장하고;상기 미지의 명령과 공통으로 하나 이상의 특징들(features)을 포함하는 후속 명령을 수신함에 응답하여, 상기복합 액션을 실행하도록 더 구성되는, 복합 태스크 기계 학습을 위한 전자 디바이스."}
{"patent_id": "10-2021-7041941", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "전자 디바이스의 적어도 하나의 프로세서로 하여금 제1 항 내지 제7 항 중 어느 한 항의 방법을 수행하도록 하는, 명령어들(instructions)을 포함하는 컴퓨터 프로그램을 구현하는 컴퓨터 판독가능 매체(computer readablemedium)."}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "복합 태스크(complex task) 기계 학습을 위한 전자 디바이스는 적어도 하나의 메모리 및 상기 적어도 하나의 메 모리와 결합된 적어도 하나의 프로세서를 포함한다. 상기 적어도 하나의 프로세서는 태스크를 수행하기 위한 미 지의 명령(unknown command)을 수신하고 상기 미지의 명령에 관한 프롬프트(prompt)를 생성하도록 구성된다. 상 (뒷면에 계속)"}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 일반적으로 기계 학습 시스템에 관한 것이다. 보다 구체적으로, 본 개시는 복합 태스크 기계 학습 (complex task machine learning) 시스템 및 방법에 관한 것이다."}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "자연어 이해(natural language understanding: NLU)는 현대 디지털 개인 비서(personal assistant: PA)가 사용 자의 자연어(NL) 명령들(commands) 을 액션들(actions) 로 변환할 수 있게 하는 현대 디지털 개인 비서의 핵심 구성요소이다. 디지털 개인 비서는 전형적으로 단일 디바이스 상의 상이한 애플리케이션들에서 단순한 태스크들 /액션들의 제한된 세트를 수행할 수 있다. 이러한 애플리케이션 액션들이 자연어 명령들을 통해 호출될 수 있도 록 하기 위해, 개발자들은 개별 애플리케이션들에 대한 액션들에 상응하는 NLU 스킬들(skills)을 구축한다. 그 러나, 다수의 애플리케이션들, 디바이스들, 및 애플리케이션들에 걸친 컨텍스트 정보의 전달을 필요로 하는 복 합 태스크들 또는 액션들은 일반적으로 NLU 스킬들에 의해 지원되지 않는다."}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시는 복합 태스크 기계 학습 시스템 및 방법을 제공한다."}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "제1 실시예에서, 복합 태스크 기계 학습 방법은 태스크를 수행하라는 미지의 명령(unknown command)을 수신하는 단계 및 상기 미지의 명령에 관한 프롬프트(prompt)를 생성하는 단계를 포함한다. 상기 방법은 또한 상기 프롬 프트에 대한 응답으로 하나 이상의 명령어들(instructions)을 수신하는 단계를 포함하고, 상기 하나 이상의 명 령어들 각각은 상기 태스크의 적어도 일부의 수행에 관한 정보를 제공한다. 상기 방법은 상기 하나 이상의 명령 어들 중 각 명령어에 대한 적어도 하나의 액션을 결정하는 단계를 포함한다. 또한, 상기 방법은 적어도 하나의프로세서에 의해, 상기 하나 이상의 명령어들 중 각 명령어에 대한 상기 적어도 하나의 액션에 기초하여, 상기 태스크를 수행하기 위한 복합 액션(complex action)을 생성하는 단계를 포함한다. 제2 실시예에서, 복합 태스크 기계 학습을 위한 전자 디바이스는 적어도 하나의 메모리 및 상기 적어도 하나의 메모리와 결합된 적어도 하나의 프로세서를 포함한다. 상기 적어도 하나의 프로세서는 태스크를 수행하라는 미 지의 명령을 수신하고 상기 미지의 명령에 관한 프롬프트를 생성하도록 구성된다. 상기 적어도 하나의 프로세서 는 또한 상기 프롬프트에 응답하여 하나 이상의 명령어들을 수신하도록 구성되며, 상기 하나 이상의 명령어들 각각은 상기 태스크의 적어도 일부의 수행에 관한 정보를 제공한다. 상기 적어도 하나의 프로세서는 상기 하나 이상의 명령어들 중 각 명령어에 대해 적어도 하나의 액션을 결정하도록 더 구성된다. 또한, 상기 적어도 하나 의 프로세서는, 상기 하나 이상의 명령어들 중 각 명령어에 대한 상기 적어도 하나의 액션에 기초하여, 상기 태 스크를 수행하기 위한 복합 액션을 생성하도록 구성된다. 제3 실시예에서, 비일시적 컴퓨터 판독가능 매체가 컴퓨터 프로그램을 구현한다. 상기 컴퓨터 프로그램은, 실행 되는 경우, 전자 디바이스의 적어도 하나의 프로세서로 하여금 태스크를 수행하라는 미지의 명령을 수신하고 상 기 미지의 명령에 관한 프롬프트를 생성하도록 하는, 명령어들을 포함한다. 상기 컴퓨터 프로그램은 또한, 실행 되는 경우, 상기 적어도 하나의 프로세서로 하여금 상기 프롬프트에 대한 응답으로 하나 이상의 명령어들을 수 신하도록 하는, 명령어들을 포함하며, 상기 하나 이상의 명령어들 각각은 상기 태스크의 적어도 일부의 수행에 관한 정보를 제공한다. 상기 컴퓨터 프로그램은, 실행되는 경우, 상기 적어도 하나의 프로세서로 하여금 상기 하나 이상의 명령어들 중 각 명령어에 대해 적어도 하나의 액션을 결정하도록 하는, 명령어들을 더 포함한다. 또한, 상기 컴퓨터 프로그램은, 실행되는 경우, 상기 적어도 하나의 프로세서로 하여금, 상기 하나 이상의 명령 어들 중 각 명령어에 대한 상기 적어도 하나의 액션에 기초하여, 상기 태스크를 수행하기 위한 복합 액션을 생 성하도록 하는, 명령어들을 포함한다."}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 2, "content": "기타 기술적 특징들은 이하의 도면, 설명, 및 청구범위로부터 본 개시가 속하는 기술분야의 통상의 지식을 가진 자에게 쉽게 이해될 수 있다."}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "하기 상세한 설명에 착수하기 전에, 본 특허 문서 전체에 걸쳐 사용되는 특정 단어들 및 문구들의 정의를 설명 하는 것이 유리할 수 있다. 하기 상세한 설명에 착수하기 전에, 본 특허 문서 전체에 걸쳐 사용되는 특정 단어 들 및 문구들의 정의를 설명하는 것이 유리할 수 있다. \"포함하다(include)\" 및 \"구비하다(comprise)\"라는 용어 들 및 그 파생어들은 제한 없는 포함을 의미한다. \"또는(or)\"이라는 용어는 \"및/또는(and/or)\"을 의미하는 포괄 적인 용어이다. \"~와 연관된(associated with)\"이라는 문구 및 그 파생문구들은 포함하다(include), ~내에 포함 되다(be included within), ~와 상호연결되다(interconnect with), 함유하다(contain), ~내에 함유되다(be contained within), ~에 또는 ~와 연결하다(connect to or with), ~에 또는 ~와 결합하다(couple to or with), ~와 통신가능하다(be communicable with), ~와 협력하다(cooperate with), 인터리빙하다(interleave), 병치하 다(juxtapose), ~에 근접하다(be proximate to), ~에 또는 ~와 결속되다(be bound to or with), 가지다(have), ~의 특성을 가지다(have a property of), ~에 또는 ~와 관계성을 가지다(have a relationship to or with) 등 을 의미한다. 또한, 하기 설명되는 다양한 기능들(functions)은 하나 이상의 컴퓨터 프로그램들에 의해 구현되거나 또는 지원 될 수 있으며, 상기 하나 이상의 컴퓨터 프로그램들 각각은 컴퓨터 판독가능 프로그램 코드(computer readable program code)로 구성되고 컴퓨터 판독가능 매체(computer readable medium)에서 구현된다. \"애플리케이션 (application)\" 및 \"프로그램(program)\"이라는 용어들은 하나 이상의 컴퓨터 프로그램들, 소프트웨어 구성요소 들, 명령어들(instructions)의 세트들, 프로시저들(procedures), 기능들(functions), 객체들(objects), 클래스 들(classes), 인스턴스들(instances), 관련 데이터, 또는 적절한 컴퓨터 판독가능 프로그램 코드의 구현에 적합 한 이들의 일부를 의미한다. \"컴퓨터 판독가능 프로그램 코드\"라는 문구는, 소스 코드(source code), 객체 코드 (object code), 및 실행가능 코드(executable code)를 포함하는 모든 유형의 컴퓨터 코드를 포함한다. \"컴퓨터 판독가능 매체\"라는 문구는, 읽기 전용 메모리(read only memory: ROM), 랜덤 액세스 메모리(random access memory: RAM), 하드 디스크 드라이브, 컴팩트 디스크(compact disc: CD), 디지털 비디오 디스크(digital video disc: DVD), 또는 다른 어떤 유형의 메모리와 같이, 컴퓨터에 의해 액세스될 수 있는 어떠한 유형의 매체라도 포함한다. \"비일시적(non-transitory)\" 컴퓨터 판독가능 매체는 일시적인 전기적 또는 기타 신호들을 전송하는 유선, 무선, 광학적, 또는 기타 통신 링크들을 제외한다. 비일시적 컴퓨터 판독가능 매체는 데이터가 영구적으 로 저장될 수 있는 매체들 및, 다시쓰기가능(rewritable) 광디스크 또는 소거가능(erasable) 메모리 디바이스와 같이, 데이터가 저장되고 추후에 덮어 쓰일(overwritten) 수 있는 매체들을 포함한다. 본 명세서에서, 특징(feature)(예를 들면, 수(number), 기능(function), 동작(operation), 또는 부품(part)과 같은 구성요소(component))을 \"가지다(have)\", \"가질 수 있다(may have)\", \"포함하다(include)\", 또는 \"포함할 수 있다\"와 같은, 용어들 및 문구들은 상기 특징의 존재를 나타내며 다른 특징들의 존재를 배제하지 않는다. 또 한, 본 명세서에서, \"A 또는 B(A or B)\", \"A 및/또는 B 중 적어도 하나(at least one of A and/or B)\", 또는 \"A 및/또는 B 중 하나 이상(one or more of A and/or B)\"이라는 문구들은 A 및 B의 모든 가능한 조합들을 포함 할 수 있다. 예를 들면, \"A 또는 B\", \"A 및 B 중 적어도 하나\", 및 \"A 또는 B 중 적어도 하나\"는 적어도 하 나의 A(at least one A)를 포함하는 것, 적어도 하나의 B(at least one B)를 포함하는 것, 또는 적어 도 하나의 A 및 적어도 하나의 B를 포함하는 것을 모두 나타낼 수 있다. 또한, 본 명세서에서, \"제1(first)\" 및 \"제2(second)\"라는 용어들은 중요도와 상관 없이 다양한 구성요소들을 수식할 수 있으며 상기 구성요소들을 제 한하지 않는다. 이러한 용어들은 단지 하나의 구성요소를 다른 것과 구별하기 위해 사용된다. 예를 들면, 제1 사용자 디바이스 및 제2 사용자 디바이스는, 상기 디바이스들의 순서 또는 중요도와 상관 없이, 서로 다른 사용 자 디바이스들을 나타낼 수 있다. 본 개시의 범위를 벗어나지 않고, 제1 구성요소가 제2 구성요소로 표기될 수 있고 그 반대의 경우도 마찬가지이다. 어떤 구성요소(예를 들면, 제1 구성요소)가 다른 구성요소(예를 들면, 제2 구성요소)와 (작동 가능하게 (operatively) 또는 통신 가능하게(communicatively)) \"결합(coupled with/to)\" 또는 \"연결(connected with/to)\"된다고 언급될 때, 상기 구성요소는 상기 다른 구성요소와 직접 또는 제3 구성요소를 통해 결합 또는 연결될 수 있음을 이해할 수 있을 것이다. 반면에, 어떤 구성요소(예를 들면, 제1 구성요소)가 다른 구성요소 (예를 들면, 제2 구성요소)와 \"직접 결합(directly coupled with/to)\" 또는 \"직접 연결(directly connected with/to)\"된다고 언급될 때, 상기 구성요소와 상기 다른 구성요소 사이에 다른 구성요소(예를 들면, 제3 구성요소)가 개재되지 않음을 이해할 수 있을 것이다. 본 명세서에서, \"~하도록 구성된(또는 설정된)(configured(or set) to)\"이라는 문구는, 상황에 따라, \"~에 적합 한(suitable for)\", \"~할 능력이 있는(having the capacity to)\", \"~하도록 설계된(designed to)\", \"~하도록 적응된(adapted to)\", \"~하도록 만들어진(made to)\", 또는 \"~할 수 있는(capable of)\"이라는 문구들과 상호교 환적으로 사용될 수 있다. \"~하도록 구성된(또는 설정된)\"이라는 문구가 본질적으로 \"~하도록 하드웨어적으로 특별히 설계된(specifically designed in hardware to)\"이라는 의미를 나타내는 것은 아니다. 오히려, \"~하도 록 구성된\"이라는 문구는 디바이스가 다른 디바이스 또는 부품들과 함께 동작(operation)을 수행할 수 있음을 의미할 수 있다. 예를 들면, \"A, B, 및 C를 수행하도록 구성된(또는 설정된) 프로세서\"라는 문구는 메모리 디바 이스에 저장된 하나 이상의 소프트웨어 프로그램들을 실행함으로써 상기 동작들을 수행할 수 있는 범용 (generic-purpose) 프로세서(예를 들면, CPU 또는 애플리케이션 프로세서), 또는 상기 동작들을 수행하기 위한 전용(dedicated) 프로세서(예를 들면, 내장형(embedded) 프로세서)를 의미할 수 있다. 본 명세서에서 사용된 용어들 및 문구들은 단지 본 개시의 일부 실시예들을 설명하기 위해 제공되는 것이지 본 개시의 다른 실시예들의 범위를 제한하고자 제공되는 것이 아니다. 문맥상 명확히 달리 언급되지 않는 한 \"a\", \"an\", 및 \"the\"라는 단수 형태들은 복수 형태의 언급을 포함한다는 것을 이해해야 할 것이다. 본 명세서에서 사 용되는, 기술적 및 과학적 용어들 및 문구들을 포함하는, 모든 용어들 및 문구들은 본 개시의 실시예들이 속하"}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "는 기술분야의 통상의 지식을 가진 자에 의해 통상적으로 이해되는 바와 동일한 의미들을 가진다. 통상적으로"}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "사용되는 사전들에서 정의된 바와 같은, 용어들 및 문구들은 관련 기술분야의 맥락에서 그 의미와 일치하는 의 미를 갖는 것으로 해석되어야 하며, 본 명세서에서 명시적으로 정의되지 않는 한 이상적이거나 지나치게 형식적 인 의미로 해석되어서는 안 된다는 것을 또한 이해할 것이다. 경우에 따라서, 본 명세서에서 정의된 용어들 및 문구들은 본 개시의 실시예들을 배제하는 것으로 해석될 수 있다. 본 개시의 실시예들에 따른 \"전자 디바이스\"의 예들은 스마트폰, 태블릿 개인용 컴퓨터(personal computer: PC), 휴대 전화(mobile phone), 비디오폰, 전자책 단말기(e-book reader), 데스크탑(desktop) PC, 랩탑 (laptop) 컴퓨터, 노트북 컴퓨터, 워크스테이션, 개인 휴대 정보 단말기(personal digital assistant: PDA), 휴대용 멀티미디어 플레이어(portable multimedia player: PMP), MP3 플레이어, 모바일 의료 디바이스, 카메라, 또는 웨어러블 디바이스(예를 들면, 스마트 안경, 머리 착용형 디바이스(head-mounted device: HMD), 전자 의류(electronic clothes), 전자 팔찌, 전자 목걸이, 전자 액세서리, 전자 문신, 스마트 거울, 또는 스마 트 워치(smart watch)) 중 적어도 하나를 포함할 수 있다. 전자 디바이스의 다른 예들은 스마트 가전제품(smart home appliance)를 포함한다. 상기 스마트 가전제품의 예들은 텔레비전, 디지털 비디오 디스크(digital video disc: DVD) 플레이어, 오디오 플레이어, 냉장고, 에어컨, 청소기, 오븐, 전자레인지, 세탁기, 드라이기, 공기 청정기, 셋탑 박스(set-top box), 가정 자동화 제어 패널(home automation control panel), 보안 제어 패널, TV 박스(예를 들면, 삼성 홈싱크(SAMSUNG HOMESYNC), 애플TV(APPLETV), 또는 구글 TV(GOOGLE TV)), 게임 콘솔 (예를 들면, 엑스박스(XBOX), 플레이스테이션(PLAYSTATION), 또는 닌텐도(NINTENDO)), 전자 사전, 전자 키 (key), 캠코더(camcorder), 또는 전자 액자 중 적어도 하나를 포함할 수 있다. 전자 디바이스의 또 다른 예들은 다양한 의료 디바이스들(예를 들면, 다양한 휴대용 의료 측정 디바이스들(예를 들면, 혈당 측정 디바이스, 심박 측정 디바이스, 또는 체온 측정 디바이스), 자기공명 혈관조영(magnetic resonance angiography: MRA) 디바이 스, 자기공명 영상(magnetic resonance imaging: MRI) 디바이스, 컴퓨터 단층촬영(computed tomography: CT) 디바이스, 영상화 디바이스, 또는 초음파 디바이스), 네비게이션 디바이스, 범지구 위치확인 시스템(global positioning system: GPS) 수신기, 사고 데이터 기록장치(event data recorder: EDR), 비행 데이터 기록장치 (flight data recorder: FDR), 자동차 인포테인먼트(infotainment) 디바이스, 항해(sailing) 전자 디바이스(예 를 들면, 항해 네비게이션 디바이스 또는 자이로컴퍼스(gyro compass)), 항공전자기기(avionics), 보안 디바이 스들, 차량용 헤드 유닛들(vehicular head units), 산업용 또는 가정용 로봇들, 자동 현금 입출금기들 (automatic teller machines: ATMs), 판매시점 관리(point of sales: POS) 디바이스들, 또는 사물인터넷 (Internet of Things: IoT) 디바이스들(예를 들면, 전구, 다양한 센서들, 전기 또는 가스 계량기, 스프링클러 (sprinkler), 화재 경보기(fire alarm), 온도 조절장치(thermostat), 가로등, 토스터(toaster), 피트니스 장비, 온수 탱크, 히터(heater), 또는 보일러) 중 적어도 하나를 포함한다. 전자 디바이스의 다른 예들은 가구 또는 건물(building)/구조물(structure)의 적어도 일부, 전자 보드(electronic board), 전자 서명(electronic signature) 수신 디바이스, 프로젝터(projector), 또는 다양한 측정 디바이스들(예를 들면, 물, 전기, 가스, 또 는 전자파 측정 디바이스들)을 포함한다. 본 개시의 다양한 실시예들에 따르면, 전자 디바이스는 상기 열거된 디바이스들 중 하나 또는 이들의 조합일 수 있음을 유의하라. 본 개시의 일부 실시예들에 따르면, 상기 전자 디 바이스는 플렉서블(flexible) 전자 디바이스일 수 있다. 본 명세서에 개시된 상기 전자 디바이스는 상기 열거된디바이스들에 제한되지 않으며 기술 발전에 따라 새로운 전자 디바이스들을 포함할 수 있다. 하기 설명에서, 전자 디바이스들은, 본 개시의 다양한 실시예들에 따라, 첨부된 도면을 참조하여 설명된다. 본 명세서에서, \"사용자(user)\"라는 용어는 상기 전자 디바이스를 사용하는 인간 또는 다른 디바이스(예를 들면, 인공지능(artificial intelligent) 전자 디바이스)를 나타낼 수 있다. 기타 특정 단어들 및 문구들에 대한 정의들은 본 특허 문서 전체에 걸쳐 제공될 수 있다. 본 개시가 속하는 기 술분야의 통상의 지식을 가진 자는, 대부분은 아닐지라도 많은 경우, 그러한 정의들이 그와 같이 정의된 단어들 및 문구들의 선행(prior) 사용뿐만 아니라 향후(future) 사용에도 적용됨을 이해해야 할 것이다. 본 출원에서의 어떤 설명도 어떤 특정 요소(elememt), 단계(step), 또는 기능(function)이 청구 범위(claim scope)에 포함되어야 하는 필수 요소임을 암시하는 것으로 해석되어서는 안 된다. 특허 대상(patented subject matter)의 범위는 오직 청구항들에 의해서만 정의된다. 이하에서 논의되는 도 1 내지 도 12, 및 본 개시의 다양한 실시예들은 첨부 도면을 참조하여 설명된다. 그러나, 본 개시는 이러한 실시예들에 제한되지 않으며, 이들에 대한 모든 변경들 및/또는 균등물들(equivalents) 또는 대체물들(replacements)도 또한 본 개시의 범위에 속함을 이해해야 할 것이다. 상술된 바와 같이, 기존 디지털 개인 비서들은 전형적으로 단일 디바이스 상의 상이한 애플리케이션들에서 오직 단순한 태스크들 또는 액션들의 제한된 세트만 수행한다. 이러한 애플리케이션 액션들이 자연어 명령들(natural language commands)을 통해 호출될 수 있도록 하기 위해, 개발자들은 개별 애플리케이션들에 대한 액션들에 상 응하는 자연어 이해(natural language understanding: NLU) 스킬들(skills)을 구축한다. 그러나, 다수의 애플 리케이션들, 디바이스들, 및 애플리케이션들에 걸친 컨텍스트 정보(context information)의 전달을 필요로 하는 복합 태스크들 또는 액션들은 일반적으로 NLU 스킬들에 의해 지원되지 않는다. 애플리케이션이 다수의 공개 (public) 애플리케이션 프로그래밍 인터페이스들(application programming interfaces: APIs)을 지원하지 않는 경우에도, 복합 태스크들의 티칭(teaching) 을 가능하게 하는 기존 접근법들은 사용자들이 각 애플리케이션 내 의 오직 제한된 수의 미리-정의된 액션들(pre-defined actions)만을 이용할 수 있도록 한다. 또한, 이러한 접근 법들은 사용자들이 이러한 액션들을 수동으로 탐색하고 선택할 것을 요구하는데, 이는 매우 번거로운 일이다. 본 개시의 다양한 실시예들은, 개인 비서(PA) 서비스 또는 NLU 서비스에 의해 달리 인식될 수 없는, 복합 태스 크들을 인식하도록 학습되도록 구성된 학습 에이전트(learning agent)를 갖는 시스템을 제공한다. 일부 실시예 들에서, 상기 학습 에이전트는, 복합 태스크가 알려져 있지 않음을 인식하는 경우, 상기 복합 태스크를 수행하 기 위한 각 단계(step)를 제공할 수 있는 명령어들(instructions)을 명확히 하도록 에이전트 사용자 인터페이스 (agent user interface)를 통해 사용자에게 프롬프팅할(prompt) 수 있다. 상기 학습 에이전트는, 상기 복합 태 스크에 이용할 애플리케이션(들), 각 애플리케이션이 수행할 액션(들), 및 각 액션에 대한 슬롯(들) 또는 파라 미터(들)을 결정하는 것을 포함하여, 상기 복합 태스크를 수행하는 방법을 결정하기 위해, 각각의 명확한 명령 어를 처리할 수 있다. 예를 들면, 하나 이상의 액션들을 통해 획득되는 정보 및 상기 복합 태스크의 후속 액션 에서의 이들의 연관된 파라미터들을 이용하여, 상기 복합 태스크를 커스터마이징하고(customize) 각 액션 간의 통합(integration)을 제공하기 위해, 액션들 간의 의존성들(dependencies)이 생성될 수 있다. 일단 각각의 명확 한 명령어가 처리되면, 향후에 동일 또는 유사한 액션을 수행하기 위해, 복합 태스크 객체(complex task object)가 생성 및 저장될 수 있다. 본 개시의 일부 실시예들에서, 복합 액션의 각 액션을 생성하기 위해, 미리-구축된 애플리케이션-특정적 스킬들 (pre-built application-specific skills)(예를 들면, 애플리케이션 개발자들에 의해 제공되는 스킬들)이 제공 되고 상기 학습 에이전트와 연관하여 저장될 수 있다. 새로운 복합 태스크에 대한 액션을 결정할 때, 상기 학습 에이전트는 애플리케이션-특정적 액션들을 할당하기 위해 상기 미리-구축된 스킬들을 이용할 수 있다. 또한, 일 부 실시예들에서, 액션들이 상기 API들로부터 생성될 수 있도록, 다양한 애플리케이션들을 위한 API들의 세트가 표준화된 포맷(standardized format)의 지식 베이스(knowledge base) 에 저장될 수 있어, 애플리케이션을 위한 미리-구축된 스킬들 중 하나가 아닐 수 있는, 상기 애플리케이션에 의해 제공되는 추가적 기능들(functions)을 지원하는 데 도움이 될 수 있다. 본 개시의 다양한 실시예들은 또한 멀티-디바이스 복합 태스크들을 위한 복합 태스크 학습 시스템을 포함한다. 멀티-디바이스 복합 태스크들을 위한 상기 복합 태스크 학습 시스템은, 예를 들면, 스마트 텔레비전들, 스마트 폰들, 스마트 워치들 또는 기타 웨어러블들(wearables), 스마트 냉장고들, 스마트 오븐들, 기타 스마트 가전들 (smart appliances), 및/또는 기타 스마트 디바이스들과 같은 다수의 스마트 디바이스들과 같은, 다수의 디바이스들을 관여시키고자 하는 태스크들과 관련된 발화들(utterances)을 수신할 수 있다. 멀티-디바이스 복합 태스 크들을 위한 상기 복합 태스크 학습 시스템은, 멀티-디바이스 복합 태스크가 알려져 있지 않음을 인식하는 경우, 상기 멀티-디바이스 복합 태스크를 수행하기 위한 각 단계를 제공할 수 있는 명령어들을 명확히 하도록 에이전트 사용자 인터페이스를 통해 사용자에게 프롬프팅할 수 있는, 학습 에이전트(learning agent)를 포함한 다. 상기 학습 에이전트는, 상기 복합 태스크에 이용할 디바이스들, 상기 복합 태스크에 이용할 그러한 디바이 스들 상의 애플리케이션들, 각 애플리케이션이 수행할 액션(들), 및 각 액션에 대한 슬롯(들) 또는 파라미터(들)을 결정하는 것을 포함하여, 상기 복합 태스크를 수행하는 방법을 결정하기 위해, 각각의 명확한 명령어를 처리할 수 있다. 다수의 디바이스들을 이용하는 동일 또는 유사한 태스크가 향후에 수행될 수 있도록, 멀티-디바이스 복합 태스크 객체가 생성되고 저장될 수 있다. 본 개시의 다양한 실시예들은, 특정 데이터세트들 (datasets)로부터의 베이스라인 알고리즘들(baseline algorithms)보다 우수한 성능을 나타내면서, 보다 효율적 인 자연어 명령어 처리(natural language instruction processing)를 더 제공한다. 도 1은, 본 개시의 다양한 실시예들에 따른, 예시적인 네트워크 구성을 도시한다. 도 1에 도시된 네트워크 구성의 실시예는 단지 예시를 위한 것이다. 본 개시의 범위를 벗어나지 않고 네트워크 구성의 다른 실시예들이 이용될 수 있다. 본 개시의 실시예들에 따르면, 전자 디바이스는 네트워크 구성에 포함될 수 있다. 전자 디바이스 는 버스, 프로세서, 메모리, 입출력(input/output: IO) 인터페이스, 디스플레이 , 통신 인터페이스, 또는 이벤트 처리 모듈(event processing module) 중 적어도 하나를 포함 할 수 있다. 일부 실시예들에서, 전자 디바이스는 상기 구성요소들 중 적어도 하나를 제외할 수 있거나 또 는 다른 구성요소를 추가할 수 있다. 버스는 구성요소들(120 내지 180)을 서로 연결하고 상기 구성요소들 간에 통신들(예를 들면, 제어 메시지 들 및/또는 데이터)을 전달하기 위한 회로를 포함한다. 프로세서는 중앙 처리 장치(central processing unit: CPU), 애플리케이션 프로세서(application processor: AP), 또는 통신 프로세서(communication processor: CP) 중 하나 이상을 포함한다. 프로세서는 전자 디바이스의 다른 구성요소들 중 적어도 하나에 대해 제어를 수행하고 및/또는 통신과 관련된 동작(operation) 또는 데이터 처리(data processing)를 수 행할 수 있다. 일부 실시예들에서, 프로세서는 그래픽 처리 장치(graphics processor unit: GPU)일 수 있 다. 본 개시의 다양한 실시예들에 따르면, 프로세서는 발화들(utterances)을 수신하거나, 발화 내의 태스 크 또는 명령이 알려져 있는지 여부를 결정하거나, 명령어들(instructions)을 명확히 하기 위한 프롬프트들 (prompts)을 발행하거나(issue), 명확한 명령어들을 수행하기 위한 애플리케이션들, 액션들, 파라미터들, 디바 이스들, 또는 기타 기준들(criteria)을 결정하기 위해 상기 명확한 명령들을 처리하거나, 상기 처리된 명확한 명령어들에 기초하여 복합 태스크를 구축하거나, 또는 기타 태스크들을 수행할 수 있다. 메모리는 휘발성 및/또는 비휘발성 메모리를 포함할 수 있다. 예를 들면, 메모리는 전자 디바이스 의 적어도 하나의 다른 구성요소와 관련된 명령들(commands) 또는 데이터를 저장할 수 있다. 본 개시의 실 시예들에 따르면, 메모리는 소프트웨어 및/또는 프로그램을 저장할 수 있다. 프로그램은, 예를 들면, 커널(kernal), 미들웨어(middleware), 애플리케이션 프로그래밍 인터페이스(application programming interface: API), 및/또는 애플리케이션 프로그램(또는 \"애플리케이션\")을 포함한다. 커널, 미들웨어, 또는 API의 적어도 일부는 운영 체제(operating system: OS)로 표시될 수 있 다. 일부 실시예들에서, 메모리는, 전자 디바이스, 전자 디바이스, 전자 디바이스, 또는 서버에 저장될 수 있는, 모델에 의해 이용되는 외부 메모리(external memory)일 수 있다. 커널은 다른 프로그램들(예를 들면, 미들웨어, API, 또는 애플리케이션 프로그램)에서 구 현되는 동작들(operations) 또는 기능들(functions)을 수행하는 데 이용되는 시스템 자원들(예를 들면, 버스 , 프로세서, 또는 메모리)을 제어 또는 관리할 수 있다. 커널은, 미들웨어, API, 또는 애플리케이션이 상기 시스템 자원들을 제어 또는 관리하기 위해 전자 디바이스의 개 별 구성요소들을 액세스할 수 있도록 하는, 인터페이스를 제공한다. 애플리케이션은, 발화들(utterances) 을 수신하거나, 발화 내의 태스크 또는 명령이 알려져 있는지 여부를 결정하거나, 명령어들(instructions)을 명 확히 하기 위한 프롬프트들(prompts)을 발행하거나(issue), 명확한 명령어들을 수행하기 위한 애플리케이션들, 액션들, 파라미터들, 디바이스들, 또는 기타 기준들(criteria)을 결정하기 위해 상기 명확한 명령들을 처리하거 나, 상기 처리된 명확한 명령어들에 기초하여 복합 태스크를 구축하거나, 또는 기타 태스크들을 수행하는, 애플 리케이션을 포함할 수 있다.미들웨어는, 예를 들면, API 또는 애플리케이션이 커널과 데이터를 통신할 수 있도록 하는, 릴레이(relay)로 기능할 수 있다. 복수의 애플리케이션들이 제공될 수 있다. 미들웨어는, 예를 들면, 전자 디바이스의 상기 시스템 자원들(예를 들면, 버스, 프로세서, 또는 메모리)을 이용하는 우선순위를 상기 복수의 애플리케이션들 중 적어도 하나에 할당함으로써, 애플리케이션들로 부터 수신되는 작업 요청들(work requests)을 제어할 수 있다. API는, 애플리케이션이 커널 또는 미들웨어로부터 제공되는 기능들(functions)을 제어할 수 있도록 하는, 인터페이스이다. 예를 들면, API는 파일링 제어(filing control), 윈도우 제어, 이미지 처리, 또는 텍스트 제어를 위한 적어도 하나의 인터페이스 또는 기능(예를 들면, 명령(command))을 포함한다. 일부 실시예들에서, API는, 이전에 저장된 액션들에 기초하여 또는 표준화된 포맷으로 저장된 애플리케이 션 API들에 기초하여 미리-구축된(pre-built) 또는 구축 가능한(buildable) 액션들을 제공하는 데 이용되는, API 및 액션 지식 베이스(API and action knowledge base)를 포함한다. IO 인터페이스는, 예를 들면, 사용자 또는 다른 외부 디바이스들로부터 입력된 명령들 또는 데이터를 전자 디바이스의 다른 구성요소(들)로 전달할 수 있는, 인터페이스로서의 역할을 한다. 또한, IO 인터페이스 는 전자 디바이스의 다른 구성요소(들)로부터 수신된 명령들 또는 데이터를 상기 사용자 또는 상기 다른 외부 디바이스로 출력할 수 있다. 디스플레이는, 예를 들면, 액정 디스플레이(liquid crystal display: LCD), 발광 다이오드(light emitting diode: LED) 디스플레이, 유기 발광 다이오드(organic light emitting diode: OLED) 디스플레이, 퀀 텀 닷 발광 다이오드(quantum light emitting diode: QLED) 디스플레이, 미세전자기계 시스템 (microelectromechanical systems: MEMS) 디스플레이, 또는 전자 종이 디스플레이를 포함할 수 있다. 디스플레 이는 또한, 다중-초점 디스플레이와 같은, 깊이-인식(depth-aware) 디스플레이일 수 있다. 디스플레이 는 또한 다양한 콘텐츠(예를 들면, 텍스트, 이미지들, 비디오들, 아이콘들(icons), 또는 기호들(symbol s))를 상기 사용자에게 표시할 수 있다. 디스플레이는 터치스크린을 포함할 수 있고, 예를 들면, 전자 펜 또는 상기 사용자의 신체 일부를 이용한 터치, 제스처(gesture), 근접(proximity), 또는 호버링(hovering) 입력 을 수신할 수 있다. 통신 인터페이스는, 예를 들면, 전자 디바이스와 외부 전자 디바이스(예를 들면, 제1 전자 디바이스 , 제2 전자 디바이스, 또는 서버) 간에 통신을 설정할 수 있다. 예를 들면, 통신 인터페이스 는, 상기 외부 전자 디바이스와 통신하기 위해, 무선 또는 유선 통신을 통해 네트워크(162 또는 164)와 연 결될 수 있다. 통신 인터페이스는, 자연어 쿼리들(queries) 또는 발화(utterance)에 관하여 통신 인터페이 스에 의해 수신되는 신호들, 결정된 인텐트(intent) 및 슬롯 태그들에 관한 신호들, 자연어 쿼리에 기초하 여 수행될 액션들에 관한 신호들, 명확한 명령어들에 관한 또는 이들을 포함하는 신호들, 에이전트 사용자 인터 페이스에 대한 입력으로부터의 신호들, 또는 기타 신호들과 같은, 신호들을 전송 및 수신하기 위한, 유선 또는 무선 송수신기(transceiver) 또는 다른 어떤 구성요소일 수 있다. 전자 디바이스는, 물리량을 계측하거나 전자 디바이스의 활성화 상태를 검출하고 게측된 또는 검출된 정보를 전기 신호로 변환할 수 있는, 하나 이상의 센서들을 더 포함한다. 예를 들면, 센서는 하나 이상의 터치 입력용 버튼들, 하나 이상의 카메라들, 제스처 센서, 자이로스코프(gyroscope) 또는 자이로 센서(gyro sensor), 기압(air pressure) 센서, 자기 센서 또는 자력계(magnetometer), 가속도 센서 또는 가속도계 (accelerometer), 그립(grip) 센서, 근접(proximity) 센서, 컬러(color) 센서(예를 들면, 적녹청(red green blue: RGB) 센서), 생체물리(bio-physical) 센서, 온도 센서, 습도 센서, 조도(illumination) 센서, 자외선 (ultraviolet: UV) 센서, 근전도(electromyography: EMG) 센서, 뇌파(electroencephalogram: EEG) 센서, 심전 도(electrocardiogram: ECG) 센서, IR 센서, 초음파 센서, 홍채(iris) 센서, 지문 센서 등을 포함할 수 있다. 상기 센서(들)는 여기에 포함된 상기 센서들 중 적어도 하나를 제어하기 위한 제어 회로를 더 포함할 수 있다. 이러한 센서(들) 중 어떤 것이라도 전자 디바이스 내에 위치할 수 있다. 상기 무선 통신은, 셀룰러 통신 프로토콜(cellular communication protocol)로서, 예를 들면, 롱텀 에벌루션 (long term evolution: LTE), 롱텀 에벌루션-어드밴스드(long term evolution-advanced: LTE-A), 5세대 무선 시스템(5th generation wireless system: 5G), 밀리미터파 또는 60 GHz 무선 통신, 무선 USB, 코드 분할 다중 접속(code division multiple access: CDMA), 광대역 코드 분할 다중 접속(wideband code division multiple access: WCDMA), 범용 이동 통신 시스템(universal mobile telecommunication system: UMTS), 무선 광대역 (wireless broadband: WiBro), 또는 세계 이동 통신 시스템(global system for mobile communication: GSM) 중적어도 하나를 이용할 수 있다. 상기 유선 연결은, 예를 들면, 범용 직렬 버스(universal serial bus: USB), 고 선명 멀티미디어 인터페이스(high definition multimedia interface: HDMI), 권장 표준 232(recommended standard 232: RS-232), 또는 재래식 전화 서비스(plain old telephone service: POTS) 중 적어도 하나를 포함 할 수 있다. 네트워크는, 컴퓨터 네트워크(예를 들면, 로컬 영역 네트워크(local area network: LAN) 또는 광역 네트워크(wide area network: WAN)), 인터넷, 또는 전화 네트워크와 같은, 적어도 하나의 통신 네트워크를 포함할 수 있다. 제1 및 제2 외부 전자 디바이스들(102 및 104) 및 서버는 각각 전자 디바이스와 동일 또는 상이한 유 형의 디바이스일 수 있다. 본 개시의 특정 실시예들에 따르면, 서버는 하나 이상의 서버들의 그룹을 포함 한다. 또한, 본 개시의 특정 실시예들에 따르면, 전자 디바이스 상에서 실행되는 동작들(operations) 전부 또는 일부는 다른 전자 디바이스 또는 다수의 다른 전자 디바이스들(예를 들면, 전자 디바이스들(102 및 104) 또는 서버) 상에서 실행될 수 있다. 나아가, 본 개시의 특정 실시예들에 따르면, 전자 디바이스가 어 떤 기능 또는 서비스를 자동적으로 또는 요청에 따라 수행해야 하는 경우, 전자 디바이스는, 상기 기능 또 는 서비스를 자체적으로 또는 추가적으로 실행하지 않고, 다른 디바이스(예를 들면, 전자 디바이스들(102 및 104) 또는 서버)에 대해 이들과 연관된 적어도 일부 기능들을 수행하도록 요청할 수 있다. 상기 다른 전자 디바이스(예를 들면, 전자 디바이스들(102 및 104) 또는 서버)는 상기 요청된 기능들 또는 추가적 기능들 을 실행하고 실행 결과를 전자 디바이스에 전달할 수 있다. 전자 디바이스는 수신된 결과를 그대로 또는 추가적으로 처리함으로써 요청된 기능 또는 서비스를 제공할 수 있다. 이를 위해, 예를 들면, 클라우드 컴 퓨팅(cloud computing), 분산 컴퓨팅(distributed com), 또는 클라이언트-서버 컴퓨팅(client-server computing) 기법이 이용될 수 있다. 도 1은 전자 장치가 네트워크를 통해 외부 전자 디바이스 또는 서버와 통신하기 위해 통신 인터페이스를 포함하는 것을 도시하고 있지만, 본 개시의 실시예들 에 따르면, 전자 디바이스는 별도의 통신 기능 없이 독립적으로 동작될 수 있다. 서버는 전자 디바이스(또는 이것의 적절한 서브세트)와 동일 또는 유사한 구성요소들(110-180)을 포 함할 수 있다. 서버는 전자 디바이스 상에서 구현되는 동작들(또는 기능들) 중 적어도 하나를 수행함 으로써 전자 디바이스를 구동하는 것을 지원할 수 있다. 예를 들면, 서버는, 전자 디바이스에 구현된 프로세서를 지원할 수 있는, 처리 모듈(processing module) 또는 프로세서를 포함할 수 있다. 서버 는 또한, 전자 디바이스에 구현된 이벤트 처리 모듈을 지원할 수 있는, 이벤트 처리 모듈(미도 시)을 포함할 수 있다. 예를 들면, 이벤트 처리 모듈은, 다른 요소들(예를 들면, 프로세서, 메모리 , 입출력 인터페이스, 또는 통신 인터페이스)로부터 획득된, 정보의 적어도 일부를 처리할 수 있고 이를 다양한 방식으로 상기 사용자에게 제공할 수 있다. 도 1에서, 이벤트 처리 모듈은 프로세서와 분리된 모듈인 것으로 도시되어 있지만, 이벤트 처리 모듈 의 적어도 일부는 프로세서 또는 적어도 하나의 다른 모듈에 포함 또는 구현될 수 있거나, 또는 이벤 트 처리 모듈의 전반적 기능(overall function)이 프로세서 또는 다른 프로세서에 포함 또는 구현될 수 있다. 이벤트 처리 모듈은 메모리에 저장된 적어도 하나의 프로그램과 연동하여 본 개시의 실시예들에 따른 동작들을 수행할 수 있다. 도 1은 네트워크 구성의 일 예를 도시하고 있지만, 도 1에 대해 다양한 변경이 이루어질 수 있다. 예를 들 면, 네트워크 구성은 각 구성요소를 어떤 개수로 어떤 적절한 배치로도 포함할 수 있다. 일반적으로, 컴퓨 팅 및 통신 시스템들은 매우 다양한 구성으로 구현되며, 도 1은 본 개시의 범위를 어떤 특정한 구성으로 제한하 지 않는다. 도 1은 본 특허 문서에 개시된 다양한 특징들이 이용될 수 있는 하나의 동작 환경(operational environment)을 도시하고 있지만, 이러한 특징들은 다른 어떤 적절한 시스템에서도 이용될 수 있다. 도 2는, 본 개시의 다양한 실시예들에 따른, 예시적인 복합 태스크 학습 시스템 아키텍처를 도시한다. 아 키텍처는 적어도 하나의 호스트(host) 디바이스 및 적어도 하나의 전자 디바이스를 포함한다. 일부 실시예들에서, 호스트 디바이스는 서버일 수 있고, 전자 디바이스는 전자 디바이스일 수 있다. 일부 실시예들에서, 호스트 디바이스 및 전자 디바이스는 동일한 디바이스 또는 엔티티 (entity)일 수 있다. 호스트 디바이스는, 자연어 이해(NLU) 서비스 및 애플리케이션 프로그래밍 인터 페이스(API) 지식 기반(knowledge base: KB) 서비스를 이용하여 호스트 디바이스에 의해 실행되는 개 인 비서(personal assistant: PA) 서비스로부터의 NLU 명령들에서 제공되는 복합 태스크들을 수행하는 것 을 학습하는, 학습 에이전트 서비스(learning agent service)를 포함한다. PA 서비스는 전자 디바이 스로부터 쿼리들 또는 발화들을 수신하기 위해 자동 음성 인식(automated speech recognition: ASR) 서비 스와 협력한다. 본 개시의 다양한 실시예들에서, NLU 서비스는, 도메인들(domains), 이용하고자 하는애플리케이션들, 및 수행될 액션들과 같은, 자연어(NL) 발화들의 인텐트(intent) 를 결정하는 데 이용되고 상기 발화들에 대한 슬롯 또는 파라미터 값들을 채우는(fill), 신경망(neural network)과 같은, 확률적 NLU 모델을 포함할 수 있다. 전자 디바이스는, PA 서비스에서의 호스트 디바이스로 전송되는, 전자 디바이스의 사용자 로부터의 쿼리들 또는 발화들을 수신하도록 구성된 음성 인터페이스(speech/voice interface)를 포함한다. PA 서비스는, NLU 서비스를 이용하여, PA 서비스에 의해 수신되는 NL 발화들을 파싱할(parse) 수 있고, PA 서비스는 다양한 태스크들이 수행되도록 할 수 있다. PA 서비스에 의해 전자 디바이스 로부터 수신되는 발화가 NLU 서비스에 의해 이해될 수 없거나 또는 효과적으로 파싱될 수 없는 경우, 또는 상기 발화가 달리 호스트 디바이스에 알려지지 않은 경우, 학습 에이전트 서비스는 호스트 디바 이스에 대해 상기 발화 내의 상기 복합 태스크를 티칭하는(teach)데 이용될 수 있다. 전자 디바이스 상의 학습 에이전트 서버 인터페이스는 학습 에이전트 서비스에 정보를 제공하기 위해 학습 에이전트 서비스와 통신할 수 있어, 새로운 복합 태스크를 완료하는 방법을 학습 에이전트 서비스에 알려줄 수 있다. 이 기능(functionality)의 예로, 본 개시의 다양한 실시예들에서, 전자 디바이스의 사용자가, 호스트 비다 이스의 PA 서비스에 의해 전자 디바이스로부터 수신된 발화에 포함된 미인식된(unrecognized) 복합 태스크를 완료하는 방법을 학습 에이전트 서비스에 티칭하는 명확한 명령어들을 학습 에이전트 서비 스에 제공할 수 있도록 하는 에이전트 사용자 인터페이스(user interface: UI) 가 전자 디바이스 상에 표시될 수 있다. PA 서비스에 의해 수신된 발화 내의 복합 태스크가 미인식된 경우, 학습 에이 전트 서비스는, 상기 사용자에게 상기 복합 태스크에 관한 추가적 정보를 제공할 것을 요청하는 프롬프트 를 에이전트 UI에 표시하기 위해, 학습 에이전트 서버 인터페이스에 명령(command)을 전송할 수 있다. 상기 사용자는 명확한 명령어들을 다양한 포맷으로 제공할 수 있다. 예를 들면, 사용자가, \"다음주 월요 일에 태국 레스토랑에서 앨리스(Alice)와 저녁 식사를 스케줄링해\"와 같이, 3개의 별개 애플리케이션들인, 레스 토랑 탐색 애플리케이션(restaurant search application), 캘린더 애플리케이션(calendar application), 및 이 메일 애플리케이션(email application)을 이용하여 이벤트를 스케줄링하는 상기 복합 태스크를 완수하기 원한다 고 가정하자. 이 명령에 상응하는 인텐트 또는 태스크를 이해하는 데 실패하는 경우, PA 서비스 및 학습 에이전트 서비스는 이 태스크를 PA 서비스 및 학습 에이전트 서비스에 티칭할 것을 에이전트 UI를 통해 상기 사용자에게 프롬프팅한다. 일부 실시예들에서, 상기 사용자는, 에이전트 UI를 열고, 새로운 태스크를 가르쳐 주기 위해 NL 명령들 또는 발화들과 같은 명령들을 제공함으로써, 상기 태스크의 티칭 을 개시할 수 있다. 복합 태스크를 수행하는 방법을 PA 서비스 및 학습 에이전트 서비스에 티칭할 때, 상기 사용자는, 각 각이 수행될 상기 복합 태스크 내의 하나의 단계를 제공하는, 하나 이상의 추가적 발화들을 제공할 수 있다. 이 는 PA 서비스 및 학습 에이전트 서비스가 상기 추가적인 명확한 발화들 각각에서의 각 개별 태스크를 수행하고 각 개별 태스크를 수행하는 새로운 복합 태스크를 구축 및 저장할 수 있도록 한다. 상기 새로운 복합 액션을 구축하기 위해, 학습 에이전트 서비스는 NLU 서비스를 이용하여 상기 명확한 명령어들을 파싱 하고 상기 명확한 명령어들에 이용할 애플리케이션들, 상기 명확한 명령어들 및 상기 결정된 애플리케이션들에 기초하여 수행할 액션들, 및 상기 액션들에 대한, 슬롯들과 같은, 파라미터들을 결정할 수 있다. 일부 실시예들 에서, NLU 서비스는 미리-구축된 스킬들의 세트로부터 각 액션을 결정할 수 있다. 각각의 미리-구축 된 스킬은 특정 애플리케이션과 연관될 수 있고, 예를 들면, 미리-구축된 스킬들이 PA 서비스와 호환 가능 하고 NLU 서비스에 의해 인식 가능하도록 보장하는, 상기 특정 애플리케이션의 개발자들이 이용 가능한 PA 스킬 개발 도구들(development tools)을 이용하여 상기 미리-구축된 스킬들을 제공함으로써, 상기 특정 애플리 케이션의 상기 개발자에 의해 정의 및 제공될 수 있다. 일부 실시예들에서, 명확한 명령어에 대한 액션을 결정하기 위해, 학습 에이전트 서비스는 API KB 서비스 를 이용하여, 명확한 명령어들에 대한 새로운 스킬들을 구축하는 데 이용될 수 있는, 특정 애플리케이션들 을 위한 다양한 API 호출들을 포함하는 API 및 액션 지식 베이스를 액세스할 수 있다. 애플리케이션 개발 자들은, 예를 들면, API 지식 기반의 웹 서비스 또는 독립형 통합 개발 환경(integrated development environment: IDE)을 통해, 그들의 API들을 API 및 액션 지식 베이스(API and actions knowledge base)에 등록할(register) 수 있다. 각각의 애플리케이션 개발자는 또한 API 및 액션 지식 베이스의 표준화된 포맷에 따라 래퍼 함수(wrapper function)를 구현할 수 있다. 각각의 명확한 명령어가 처리됨에 따라, 호스트 디바이스는 서버 액션 모듈(server action module)에 의해 각각의 개별 태스크가 수행되도록 할 수 있다. 호스트 디바이스의 서버 액션 모듈은 네트워크 또는 클라우드를 통해 전자 디바이스의 디바이스 액션 모듈(device action module)과 통신한다. 구성요소들(206, 212, 216, 및 218)과 같은, 다른 구성요소들도 또한 유사한 방식으로 네트워크를 통 해 통신할 수 있음을 이해할 것이다. 서버 액션 모듈은, 서버 액션 모듈이 이전에-학습된 복합 태스 크를 수행하도록 디바이스 액션 모듈에 명령하고 있는 경우 복합 태스크일 수도 있는, 액션을 수행하도록 디바이스 액션 모듈에 명령을 전송한다. 이에 응답하여, 디바이스 액션 모듈은 전자 디바이스에 의해 저장 및 실행되는 하나 이상의 디바이스 애플리케이션들에 대해 상기 액션을 수행하도록 지시한다. 상기 사용자에 의해 제공되는 각각의 명확한 명령어에 대한 각 액션이 결정되고 수행되는 경우, 상기 복합 태스 크의 각 개별 액션을 실행하기 위한 명령들을 포함하는 복합 태스크 객체(complex task object)가 생성될 수 있 다. 상기 복합 태스크 객체는 호스트 디바이스에 의해 저장될 수 있다. PA 서비스가 상기 저장된 복 합 태스크와 동일 또는 유사한 후속 발화를 수신하는 경우, PA 서비스는 상기 사용자로부터의 추가적 입력 없이 상기 복합 태스크가 수행되도록 할 수 있다. 일부 실시예들에서, 명확한 명령어들을 제공하기 위해, 상기 사용자는 가능한 명확한 명령어들의, 에이전트 UI에 표시된, 리스트로부터 명확한 명령어를 선택할 수 있 다. 또한, 일부 실시예들에서, 상기 사용자는, 문장 또는 다른 발화와 같은, 명령을 에이전트 UI의 텍스트 입력 영역(text input area)에 입력함으로써 명확한 명령어들을 제공할 수 있다. 도 2는 복합 태스크 학습 시스템 아키텍처의 일 예를 도시하고 있지만, 도 2에 대해 다양한 변경이 이루어 질 수 있다. 예를 들면, 복합 태스크 학습 시스템 아키텍처에서, PA 서비스는 서버 액션 모듈, 학습 에이전트 서비스, ASR 서비스, 또는 NLU 서비스 중 하나 이상을 PA 서비스의 기능 (functionality)의 일부로서 포함할 수 있다. 또한, 음성 인터페이스, 학습 에이전트 서버 인터페이스 , 에이전트 UI, 및 디바이스 액션 모듈의 기능(functionality)은 단일 엔티티 내에 포함될 수 있다. 또한, API 및 액션 지식 베이스, 및 미리-구축된 스킬들의 세트는 별개의 데이터 저장소들 (data stores) 또는 데이터베이스들 내에, 또는 동일한 데이터 저장소 또는 데이터베이스에 포함될 수 있다. 도 3은, 본 개시의 다양한 실시예들에 따른, 예시적인 복합 태스크 학습 에이전트 시스템을 도시한다. 시 스템은 복합 태스크들을 학습하도록 구성된 학습 에이전트를 포함한다. 일부 실시예들에서, 학습 에 이전트는 도 2의 학습 에이전트 서비스일 수 있다. 복합 태스크를 수행하라는 명령어(instruction)를 포함하는, PA 서비스와 같은 PA 서비스에 의해 수신되는 발화(utterance)와 같은, 발화가 NLU 엔진 에 의해 수신된다. 발화에 포함된 상기 복합 태스크가 NLU 엔진에 알려져 있지 않거나 또는 NLU 엔진에 의해 결정될 수 없는 것으로 간주되는 경우, 학습 에이전트는, 예를 들면, 에이전트 UI 를 통해, 명령어들을 명확하게 하도록 사용자에게 프롬프팅할 수 있다. 상기 프롬프트에 응답하여, 상기 사용자 는, 상기 복합 태스크를 수행하기 위한 단계(step)를 제공하는, 명확한 명령어를 NLU 엔진에 제공할 수 있다. 이 기능(functionality)의 예로, 발화가 \"다음주 월요일 태국 레스토랑에서 앨리스(Alice)와의 저녁 식사 를 스케줄링해\"라는 발화를 포함하는 경우, 상기 사용자는 에이전트 UI를 통해 상기 복합 태스크가 미지의 것임을 통지 받고 하나 이상의 명확한 명령어들을 제공하도록 프롬프팅 받을 수 있다. 예를 들면, 월요일에 태 국 레스토랑에서 앨리스(Alice)와의 저녁 식사를 스케줄링하는 방법을 학습 에이전트에 티칭하기 위해, 상 기 사용자는 \"저녁 식사를 위한 태국 레스토랑을 탐색해(search a Thai restaurant for dinner)\", \"다음주 월 요일에 저녁 식사를 스케줄링해(schedule a dinner next Monday)\", 및 \"이메일을 통해 앨리스와 이벤트를 공유 해(share the event with Alice via email)\"라는 3개의 명확한 명령어들을 제공할 수 있다. 일부 실시예 들에서, 상기 사용자는 한 번에 하나의 명확한 명령어를 제공할 수 있으며, 여기서 학습 에이전트는 각각의 명확한 명령어를 처리하고 다음 명확한 명령어에 대해 상기 사용자에게 프롬프팅할 수 있다. 다른 실시예들에서, 학습 에이전트가 상기 복합 태스크가 생성될 때까지 각각의 명확한 명령어를 처리함과 함께, 상기 사용자는 단일 프롬프트에 응답하여 모든 명확한 명령어들을 제공할 수 있다. 또한, 일부 실시 예들에서, 학습 에이전트가 각각의 명확한 명령어와 연관된 태스크를 수행하는 것을 더 돕기 위해, 상기 사용자는 상기 액션에 이용할 애플리케이션의 명칭(name)을 명확한 명령어들 중 하나 이상에 포함할 수 있다. 사용자가 상기 애플리케이션의 명칭을 제공하지 않는 경우, NLU 엔진은, 상기 명확한 명령어 의 발화에 기초하여, 상기 이용될 애플리케이션을 결정하려고 시도할 수 있다. 각각의 명확한 명령어에 기 초하여 상기 이용할 애플리케이션을 결정하고 애플리케이션을 이용하여 각각의 명확한 명령어에 대해 각각 의 서브태스크, 액션, 또는 API 호출을 수행함으로써, 명확한 명령어들을 이용하여 상기 복합 태스크가 생 성될 수 있다. 제공되는 특정 명확한 명령어들에 따라, 동일한 애플리케이션에 의해 다수의 액션들이 수행될 수 있음을 이해할 것이다. 시스템은, 각각의 명확한 명령어에 대한 애플리케이션, 액션, 및 파라미터(들)을 이해하기 위해 각각 의 명확한 명령어를 처리하고, 예를 들면, 제2 수신된 명확한 명령어에 대한 제2 액션이 제1 수신된 명확한 명령어에 대한 제1 액션에 의존함을 등록함으로써, 상기 복합 태스크 내의 상기 액션에 대한 모든 의존성들을 등록하는, 앱/액션 의존성 등록 모듈(register app/action dependence module) 을 더 포함한 다. 앱/액션 의존성 등록 모듈은 또한, 상이한 애플리케이션들, 액션들, 파라미터들, 또는 액션들에 대한 의존성들에 대한 선택들(selections)을 제공하기 위해, 에이전트 UI를 통해 추가적 입력을 수신할 수 있다. 앱/액션 의존성 등록 모듈이 명확한 명령어에 대한 애플리케이션, 액션, 파라미터들, 및 의존 성들을 결정한 후, API/액션 실행 모듈(API/action execution module)은, 예를 들면, 상기 결정된 액션을 수행하라는 명령을 네트워크를 통해 전자 디바이스로 전송함으로써, 명확한 명령어에 대한 상기 액션 을 수행한다. 예를 들면, 도 2에 도시된 바와 같이, 네트워크는 네트워크일 수 있고, 디바이스 애플 리케이션에 의한 수행을 위해 상기 액션을 수행하라는 명령을 호스트 디바이스로부터 네트워크 를 통해 전자 디바이스의 디바이스 액션 모듈로 전송하도록, API/액션 실행 모듈이 서버 액션 모듈에 의해 수행될 수 있다. 명확한 명령어에 대한 상기 액션의 실행 후, 결정 블록에서, 학습 에이전트는, 예를 들면, 호스 트 디바이스의 프로세서를 통해, 상기 복합 태스크가 완료되었는지 여부를 결정한다. 그렇지 않은 경 우, 다음 명확한 명령어에 대해 수행할 액션을 결정하기 위해, NLU 엔진 및 학습 에이전트에 의 해 다음 명확한 명령어가 처리된다. 각각의 명확한 명령어는, 결정 블록에서 학습 에이전트 가 상기 복합 태스크가 완료되었음을 결정할 때까지, 이런 방식으로 핸들링된다. 블록에서, 향후 새 로운 복합 태스크를 수행하기 위해 실행될 수 있는 명령어들, 스크립트들(scripts), 또는 프로그램들의 세트 또 는 레시피(recipe)를 제공하는, 복합 태스크 객체(complex task object)가 생성된다. 상기 새로운 복합 태스크 객체는, 호스트 디바이스와 같은 서버, 및/또는 전자 디바이스와 같은 사용자의 전자 디바이스에 의 해 호스팅되는, 액션 데이터베이스(action database)에 저장될 수 있다. 도 3은 복합 태스크 학습 에이전트 시스템의 일 예를 도시하고 있지만, 도 3에 대해 다양한 변경이 이루어 질 수 있다. 예를 들면, 모든 명확한 명령어들이 동시에 처리되는 경우, 결정 블록은 시스템에 서 수행되지 않을 수 있다. 또한, API/액션 실행 모듈은, 각각의 명확한 명령어에 대한 각 액션이 학 습 에이전트 및 앱/액션 의존성 등록 모듈에 의해 결정될 때까지, 각각의 명확한 명령어의 각 액션을 수행하지 않을 수 있다. 나아가, API 및 액션 지식 베이스는 또한, 미리-구축된 스킬들의 세 트와 같은, 애플리케이션들에 대한 미리-구축된 스킬들도 포함할 수 있다. 도 4는, 본 개시의 다양한 실시예들에 따른, 예시적인 복합 태스크 학습 프로세스를 도시한다. 설명의 편 의를 위해, 프로세스는 도 1에서의 전자 디바이스들(101, 102, 104) 또는 서버 중 어떤 것의 프로세 서(들)에 의해 실행되거나 또는 달리 이용되는 것으로 설명될 수 있다. 그러나, 프로세스는 어떤 적 절한 디바이스(들)에 의해 어떤 적절한 시스템에서도 이용될 수 있다. 프로세스는, 시스템 아키텍처 및/또는 시스템과 같은, 본 개시의 다양한 실시예들과 관련하여 설명되는 복합 태스크 학습 시스템 (complex task learning system)과 함께 이용될 수 있다. 블록에서, 프로세서는 복합 태스크를 수행하라는 명령을 포함하는 발화를 수신한다. 결정 블록에서, 상기 프로세서는 상기 명령이 이해되었는지 여부를 결정한다. 이해된 경우, 상기 프로세서는 상기 수신된 발화 에 상응하는 상기 복합 태스크를 수행한다. 예를 들면, 상기 발화가 \"다음주 월요일에 태국 레스토랑에서 앨리 스(Alice)와의 저녁 식사를 스케줄링해\"라는 발화를 포함하고 이러한 유형의 발화에 대한 복합 태스크가 이전의 복합 태스크 학습 프로세스에서 이미 생성되어 있는 경우, 상기 프로세서는 이러한 유형의 복합 액션을 이미 인 식할 수 있고, 상기 수신된 발화에 상응하는 상기 복합 태스크를 이행하기(fulfill) 위해, 이전에 생성 및 저장 된 복합 태스크 객체가 검색되고(retrieved) 실행될 수 있다. 그 시점에서, 프로세스는 블록에서 종 료된다. 상기 프로세서가 결정 블록에서 상기 발화가 이해되지 않았음을 결정하는 경우, 프로세스는 블록 으로 이동한다. 블록에서, 상기 프로세서는 명확한 명령어에 대한 프롬프트를 생성하고 상기 프롬프 트에 대한 응답으로 명확한 명령어를 수신한다. 블록에서, 상기 프로세서는 상기 명확한 명령어에 기초하 여 애플리케이션, 액션, 및 하나 이상의 파라미터들을 결정한다. 블록에서, 상기 프로세서는 상기 액션에 대한 모든 의존성들을 등록한다. 예를 들면, 이전의 명확한 명령어에 대한 이전의 액션이 이미 결정되어 있는경우, 상기 프로세서는 블록에서 그 다음 명확한 명령어에 대한 그 다음 액션이 상기 제1 액션에 또는 상 기 제1 액션의 파라미터에 의존적인 것으로 등록할 수 있다. 특정한 예로, 상기 프로세서가 상기 제1 명령어에 대한 상기 제1 액션이 레스토랑 탐색 애플리케이션을 이용하여 태국 레스토랑을 탐색하는 것이라고 결정하는 경 우, 상기 프로세서는 상기 제2 액션 동안 찾아낸(found) 태국 레스토랑에 대한 레스토랑 정보를 결정하거나, 또 는 상기 레스토랑 정보를 이용하기 위해 사용자로부터 입력을 수신할 수 있다. 상기 제2 액션이, 상기 태국 레 스토랑에서 저녁 식사를 하는 데 다른 사용자를 초대하는, 캘린더 초대장(calendar invite)을 상기 다른 사용자 에게 이메일로 보내는 액션인 경우, 상기 이메일의 본문(body)은 상기 레스토랑 탐색 애플리케이션을 이용하여 획득된 상기 레스토랑 정보를 포함하도록 설정될 수 있다. 그러므로, 상기 프로세서는, 상기 제1 액션을 이용하 여 검색된 레스토랑 정보를 상기 이메일 본문에 포함하도록, 상기 제2 액션에 대한 의존성을 설정할 수 있다. 따라서, 의존성들의 등록은 복합 태스크가 상기 복합 태스크의 상이한 액션들 간에(심지어 애플리케이션들에 걸 쳐) 정보를 공유할 수 있도록 한다. 이런 식으로, 상기 복합 태스크는 단지 일련의 별개 액션들을 수행하는 것 이 아니라, 상기 상이한 액션들 및 이들의 연관된 애플리케이션들 및 파라미터들에 의해 커스터마이징된 (customized) 태스크를 수행한다. 그 시점에서, 프로세스는 블록으로 이동한다. 블록에서, 상기 프로세서는, 상기 액션에 대해 결정된 애플리케이션 및 결정된 파라미터(들) 또는 슬롯(들)에 기초하여, 블록에서 결정된 상기 액션을 실행한다. 결정 블록에서, 상기 프로세서는, 예 를 들면, 각각의 명확한 명령어가 처리되었는지 여부와 같이, 상기 복합 태스크가 완료되었는지 여부를 결정한 다. 완료되지 않은 경우, 상기 프로세서는 블록으로 루프-백하여(loop back) 상기 사용자에게 그 다음 명 확한 명령어에 대해 프롬프팅한다. 일단 각각의 명확한 명령어가 처리되고 실행되면, 상기 프로세서는 결정 블 록에서 상기 복합 태스크가 완료되었다고 결정한다. 그러한 경우, 프로세스는 블록으로 이동한 다. 블록에서, 상기 프로세서는 복합 태스크 객체를 생성하고, 학습된 액션들 및 의존성들을 포함하는, 상 기 복합 태스크 객체를 액션 지식 베이스에 저장하여, 동일 또는 유사한 복합 태스크 명령을 포함하는 발화가 수신되는 경우 상기 복합 액션이 다시 수행될 수 있도록 한다. 프로세스는 블록에서 종료된다. 도 4는 복합 태스크 학습 프로세스의 일 예를 도시하고 있지만, 도 4에 대해 다양한 변경이 이루어질 수 있다. 예를 들면, 일련의 단계들로 도시되어 있지만, 도 4에서의 다양한 단계들은 중첩되거나, 병렬적으로 발생 하거나, 상이한 순서로 발생하거나, 또는 몇 번이라도 발생할 수 있다. 또한, 사용자가 이전에 복합 태스크를 생성했을 수 있다 하더라도, 상기 사용자는 이러한 유형의 복합 태스크에 대해 동일한 애플리케이션들, 액션들, 및/또는 파라미터들이 다시 사용되는 것을 더 이상 원하지 않을 수 있다. 특정한 예로, 상기 사용자는, 저장된 복합 태스크 객체를 생성하기 위해 이전에 사용된 상기 이메일 애플리케이션 이외에, 상이한 이메일 애플리케이 션이 사용되기를 원할 수 있다. 그러한 경우, 상기 프로세서는, 이전에 생성 및 저장된 복합 태스크 객체가 블 록에서 수신된 상기 발화에 포함된 복합 태스크에 이용될 것인지 여부를 검증하는(verifying), 프롬프트를 상기 사용자에게 출력할 수 있다. 그렇지 않은 경우, 상기 프로세스는 새로운 복합 태스크의 생성을 시작할 수 있다. 나아가, 상기 프로세서는 예전 데이터를 삭제하고 새로운 데이터를 추가함으로써, 예를 들면, 더 이상 이 용되지 않을 하나의 이메일 애플리케이션에 대한 식별자(identifier)를 삭제하고 이용될 다른 새로운 이메일 애 플리케이션에 대한 식별자를 추가함으로써, 이전에 생성 및 저장된 복합 태스크 객체를 수정할(modify) 수 있다. 또한, 블록에서 상기 프로세서는 다수의 명확한 명령어들을 동시에 수신하기 위한 프롬프트를 생성 할 수 있고, 상기 다수의 명확한 명령어들은, 도 4에 도시된 방식으로, 순차적으로, 동시에, 또는 다른 어떤 적 절한 방식으로 처리될 수 있다(이 경우 단계는 생략될 수 있음). 도 5는, 본 개시의 다양한 실시예들에 따른, 예시적인 애플리케이션 및 액션 등록 프로세스를 도시한다. 설명의 편의를 위해, 프로세스는 도 1에서의 전자 디바이스들(101, 102, 104) 또는 서버 중 어떤 것 의 프로세서(들)에 의해 실행되거나 또는 달리 이용되는 것으로 설명될 수 있다. 그러나, 프로세스는 어떤 적절한 디바이스(들)에 의해 어떤 적절한 시스템에서도 이용될 수 있다. 프로세스는, 시스템 아키텍처 및/또는 시스템과 같은, 본 개시의 다양한 실시예들과 관련하여 설명되는 복합 태스크 학습 시스템 과 함께 이용될 수 있다. 일부 실시예들에서, 프로세스는 앱/액션 의존성 등록 모듈에 포함되거나, 또는 이에 의해 또는 이를 이용하여 수행된다. 블록에서, 프로세서는, 복합 태스크를 학습하기 위한 프롬프트에 대한 응답으로 제공되는, 다음 명확한 명 령어를 수신한다. 예를 들면, \"다음주 월요일에 태국 레스토랑에서 앨리스(Alice)와의 저녁 식사를 스케줄링 해\"라는 발화에 대하여, 상기 프로세서는 이 태스크를 수행하는 방법에 관한 명령어들을 명확히 하기 위한 프롬 프트를 발행할 수 있다. 특정한 예로, 사용자는, 제1 명확한 명령어로서 \"저녁 식사를 위한 태국 레스토랑을 탐 색해\", 제2 명확한 명령어로서 \"다음주 월요일에 저녁 식사를 스케줄링해\", 및 제3 명확한 명령어로서 \"이메일을 통해 이벤트를 앨리스(Alice)와 공유해\"와 같은, 일련의 명확한 명령어들을 제공할 수 있다. 상기 명확한 명 령어들은, 함께(together), 한 번에 하나씩, 또는 다른 어떤 적절한 방식으로, 수신될 수 있다. 각각의 다음 명 령어에 대한 새로운 프롬프트가 발행될 수 있고, 프로세스가 이전 명령어를 처리한 후 블록으로 루프 -백하는(loop back) 경우, 상기 다음 명령어가 블록에서 수신된다. 블록에서, 상기 프로세서는, 상기 명령어에 대해, 이용할 애플리케이션, 이용할 액션 또는 API 호출, 및 상기 액션에 이용할 하나 이상의 슬롯(키(key), 값(value)) 쌍들과 같은 하나 이상의 파라미터들을 결정한다. 일부 실시예들에서, 상기 애플리케이션, 액션, 및 파마리터들을 결정하는 단계는 NLU 엔진을 이용하여 수행될 수 있다. 결정 블록에서, 상기 프로세서는 상기 액션을 수행하기 위한 모든 파라미터들이 블록에서 추출되었는지 여부를 결정한다. 그러한 경우, 프로세스는 블록으로 이동한다. 블록에서, 상기 프로세서는 상기 액션의 파라미터들에 따라 상기 액션을 실행하고 새로운 결과 객체(result object)를 생성한다. 블록에서, 애플리케이션 컨텍스트 결과들이 상기 새로운 결과 객체로 업데이트된다. 상기 새로 운 결과 객체는 이전의 액션들 또는 API 호출들 및 결과 반환들(result returns)로부터 상기 복합 태스크에 대 한 컨텍스트 정보 세트에 추가된다. 상기 새로운 결과 객체는 후속 명확한 명령어들의 처리 시 애플리케이션들 또는 액션들 간의 의존성들을 생성하는 데 이용될 수 있다. 일 예로, \"저녁 식사를 위한 태국 레스토랑을 탐색 해\"라는 제1 명확한 명령어에 대한 상기 새로운 결과 객체는 상기 결정된 애플리케이션이 레스토랑 탐색 애플리 케이션이고, 상기 액션 또는 API 호출은 탐색을 수행하는 것이며, 상기 파라미터들은 \"태국\" 및 상기 파라미터 에 대한 연관된 슬롯 태그(들)를 포함한다는 것을 포함할 수 있다. 다른 예로, \"다음주 월요일에 저녁 식사를 스케줄링해\"라는 제2 명확한 명령어에 대한 상기 새로운 결과 객체는 상기 결정된 애플리케이션이 캘린더 애플 리케이션이고, 상기 액션 또는 API 호출은 캘린더 엔트리(calendar entry)를 생성하는 것이며, 상기 파라미터들 은 날짜, 시간, 및 장소와 같은 캘린더 엔트리 세부사항들(calendar entry specifics) 및 상기 파라미터들에 대 한 연관된 슬롯 태그(들)를 포함한다는 것을 포함할 수 있다. 프로세스는 블록으로 루프-백하여 다음 명확한 명령어를 처리할 수 있다. 추가적인 명확한 명령어들이 없는 경우, 프로세스는 종료된다. 프로세스 의 종료 시, 각각의 명확한 명령어는 결정된 애플리케이션, 액션, 및 파라미터(들)를 가질 것이며, 향후의 태스크들을 위해 복합 태스크 객체가 구축될 수 있다. 상기 프로세서가 결정 블록에서 상기 태스크를 수행하는 데 모든 파라미터들이 이용 가능한 것은 아니라고 결정하는 경우, 프로세스는 결정 블록으로 이동한다. 예를 들면, 블록에서 \"이메일로 앨리스 (Alice)와 이벤트를 공유해\"라는 제3 명확한 명령어가 수신되는 경우, 이메일 본문 또는 메시지 파라미터는 상 기 NLU 엔진을 이용하여 추출되지 않았을 수 있다. 그러한 경우, 상기 프로세서는 결정 블록에서 이메일을 통해 캘린더 초대장을 전송하는 액션을 수행하는 데 이용되는 이 파라미터가 누락되었다고 결정한다. 결정 블록 에서, 상기 프로세서는 상기 사용자가 새로운 정보를 입력하는지 여부를 결정한다. 일부 실시예들에서, 에 이전트 UI(220 또는 320)는, 예를 들면, 텍스트 입력 필드(text input field)를 제공함으로써, 상기 누락된 파 라미터에 대한 파라미터 값을 입력하라는 프롬프트를 상기 사용자에게 발행할 수 있다. 상기 프롬프트는 또한 상기 파라미터에 대한 컨텍스트 정보를 선택하는 옵션(option)을 포함할 수 있다. 일부 실시예들에서, 에이전트 UI(220 또는 320)는, 이전의 명확한 명령어에 대해 이전에-수행된 레스토랑 탐색으로부터의 레스토랑 정보와 같 은, 이전의 액션들 또는 API 호출들로부터 반환된(returned) 모든 컨텍스트 정보 결과들뿐만 아니라, 현재 및 이전 명령어들로부터의 슬롯 값들을 표시할 수 있다. 상기 사용자는 새로운 정보를 제공할 것인지 또는 상기 누 락된 파라미터에 이용될 컨텍스트 정보를 선택할 것인지 선택할 수 있다. 상기 프로세서가 결정 블록에서 상기 사용자가 새로운 정보를 입력할 것으로 결정하는 경우, 블록에 서, 상기 프로세서는 상기 사용자로부터, 에이전트 UI에 입력된 정보와 같은, 새로운 정보를 수신한다. 예 를 들면, 상기 이메일 본문 파라미터가 누락된 경우, 상기 사용자는 블록에서 상기 이메일 본문에 포함될 텍스트를 입력할 수 있으며, 이는 상기 파라미터 값으로 이용될 수 있다. 블록에서, 상기 프로세서는, 존 재하는 경우, 이전의 액션 또는 API 호출 컨텍스트 결과들에 관해 입력된 애플리케이션 파라미터에 대한 의존성 을 등록한다. 예를 들면, 상기 사용자가 앨리스(Alice)와 상기 태국 이벤트를 공유하는 상기 이메일에 대한 본 문을 입력하기로 선택하는 경우, 상기 프로세서는, 이 복합 액션에 대해, 상기 이메일에 대한 본문이 사용자 입 력이 되도록 등록할 수 있다. 프로세스는 결정 블록으로 루프-백하여 다른 어떤 파라미터들이 누락되 었는지 여부를 결정한다. 상기 프로세서가 결정 블록에서 상기 사용자에 의해 새로운 정보가 입력되지 않을 것이라고 결정하는 경우, 프로세스는 블록으로 이동한다. 블록에서, 상기 프로세서는 상기 사용자에 의해 이전의 애플리케이션 컨텍스트 결과들로부터 선택된 정보를 수신한다. 예를 들면, 현재의 명확한 명령어가 \"이메일을통해 앨리스(Alice)와 이벤트를 공유해\"이고 상기 누락된 파라미터가 상기 이메일 본문인 경우, 상기 사용자는 이전 명령어들에 대한 다양한 반환된 결과들 및 슬롯 값들을 제시 받을 수 있다. 이러한 옵션들 중 하나는 이전 액션을 위한 레스토랑 탐색 애플리케이션으로부터 반환되는 레스토랑 정보일 수 있다. 상기 사용자가 이 레스토 랑 정보를 선택하는 경우, 상기 프로세서는 상기 이메일 본문으로 사용될 상기 레스토랑 정보에 대한 상기 선택 을 수신하고, 블록에서 상기 액션을 실행할 때 이 정보를 파라미터로 이용할 수 있다. 블록에서, 상 기 프로세서는, 이 복합 태스크의 후속 수행들도 반환된 레스토랑 정보를 이메일 본문 파라미터로 이용하도록, 이 선택에 대한 상기 애플리케이션 파라미터들 및 컨텍스트 결과 의존성을 등록한다. 예를 들면, 이 의존성은 레스토랑 \"RestaurantApp.Restaurant -> email\"의 포맷일 수 있다. 프로세스는 결정 블록으로 루프- 백하여 다른 파라미터들이 누락되었는지 여부를 결정한다. 도 5는 애플리케이션 및 액션 등록 프로세스의 일 예를 도시하고 있지만, 도 5에 대해 다양한 변경이 이루 어질 수 있다. 예를 들면, 일련의 단계들로 도시되어 있지만, 도 5에서의 다양한 단계들은 중첩되거나, 병렬적 으로 발생하거나, 상이한 순서로 발생하거나, 또는 몇 번이라도 발생할 수 있다. 특정한 예로, 상기 사용자가 새로운 정보를 입력하는 경우, 상기 사용자가 이전의 애플리케이션 결과 또는 파라미터를 선택하지 않았기 때문 에 아무런 의존성도 생성되지 않을 수 있도록, 블록은 블록으로 이동하지 않고 결정 블록으로 되돌아 갈 수 있다. 도 6은, 본 개시의 다양한 실시예들에 따른, 예시적인 애플리케이션, 액션, 및 슬롯 추출 프로세스를 도시 한다. 설명의 편의를 위해, 프로세스는 도 1에서의 전자 디바이스들(101, 102, 104) 또는 서버 중 어 떤 것의 프로세서(들)에 의해 실행되거나 또는 달리 이용되는 것으로 설명될 수 있다. 그러나, 프로세스 는 어떤 적절한 디바이스(들)에 의해 어떤 적절한 시스템에서도 이용될 수 있다. 프로세스는, 시스템 아키텍처 및/또는 시스템과 같은, 본 개시의 다양한 실시예들과 관련하여 설명되는 복합 태스크 학습 시스템과 함께 이용될 수 있다. 일부 실시예들에서, 프로세스는 도 5에서의 블록의 프로세스의 일부 이다. 블록에서, 프로세서는 학습 에이전트에서 다음 명확한 명령어를 수신한다. 명확한 명령어가 수신되는 경우, 상기 프로세서는 상기 명확한 명령어의 발화에 대해 이용될 애플리케이션, 액션, 및 슬롯(들)을 결정하려 고 시도한다. 상기 학습 에이전트에서 블록에서의 상기 다음 명령어를 수신하기 전에, 상기 프로세서는 상 기 다음 명령어를, NLU 서비스 또는 NLU 엔진과 같은, NLU 엔진에 이미 입력했을 수 있다. 상기 NLU 엔진에 의한 처리 후, 결정 블록에서, 상기 프로세서는 상기 NLU 엔진이 상기 명령어에 이용할 애플리케이 션을 결정했는지 여부를 결정한다. 충분한 신뢰도(confidence)로 애플리케이션이 결정되는 경우, 프로세스(60 0)는 결정 블록으로 이동한다. 결정 블록에서 충분한 신뢰도로 애플리케이션이 결정되지 않은 경우, 프로세스는 블록으로 이동한다. 블록에서, 상기 프로세서는, 예를 들면, 에이전트 UI(220 또는 320)를 통해, 하나 이상의 애플리케이션 제안들(application suggestions)을 사용자에게 출력한다. 일부 실시예 들에서, 상기 애플리케이션 제안들은 관련될 가능성이 가장 높은 것에서부터 관련될 가능성이 가장 낮은 것으로 순위 매겨진 애플리케이션 제안들의 순위 리스트(ranked list)일 수 있다. 상기 사용자는, 예를 들면, 상기 사 용자가 상기 사용자의 전자 장치에 현재 저장된 모든 애플리케이션들을 브라우징할(browse) 수 있도록 하는 메 뉴를 여는 것에 의해, 상기 애플리케이션 제안들 중 하나를 선택하거나 또는 상이한 선택을 할 수 있다. 블록에서, 상기 명령어의 도메인(domain)이 이전 블록들로부터의 결정된 또는 선택된 애플리케이션에 의해 이제 알려짐과 함께, 상기 프로세서는, 액션 및 상기 액션에 대해 가능한 슬롯(들)을 결정하기 위해, 상기 명령 어를 상기 NLU 엔진에 제공한다. 일부 실시예들에서, 블록에서 이용되는 상기 NLU 엔진은 이전 블록들에서 결정 또는 선택된 상기 애플리케이션에 대한 명령들(commands)을 해석하도록 구성된 애플리케이션-특정적 (application-specific) NLU 엔진이다. 결정 블록에서, 상기 프로세서는 충분한 신뢰도로 액션이 결정되었 는지 여부를 결정한다. 그러한 경우, 프로세스는 블록으로 이동한다. 그렇지 않은 경우, 프로세스 는 블록으로 이동한다. 블록에서, 상기 프로세서는, 예를 들면, 에이전트 UI(220 또는 320)를 통해, 선택을 위한 API 및/또는 액션 제안들을 상기 사용자에게 출력한다. 일부 실시예들에서, 상기 프로세서는 미리-정의된 애플리케이션 스킬들 및 API 호출들의 순위 조합된 리스트(ranked combined list)를 출력할 수 있 다. 상기 수신된 명령어 내의 상기 태스크를 수행하기 위해, 상기 사용자에 의해 상기 리스트 내의 상기 액션들 또는 API 호출들 중 하나가 선택될 수 있다. 일부 실시예들에서, 상기 사용자는 또한 상이한 액션들을 선택하거 나 또는 액션 또는 API 호출을 구축할 수 있다. 블록에서, 상기 프로세서는, 상기 선택된 액션에 대한 하 나 이상의 파라미터들을 결정하기 위해, 상기 명령어를, 애플리케이션-특정적 NLU 엔진일 수 있는, 상기 NLU 엔 진에 제공한다.블록에서, 상기 프로세서는 상기 액션에 대한 하나 이상의 추출된 슬롯들을 수신힌다. 상기 하나 이상의 추출된 슬롯들은, 상기 액션을 이행하기 위한 적어도 하나의 파라미터를 제공하는, 하나 이상의 키(key) 및 값 (value) 쌍들을 포함할 수 있다. 예를 들면, 프로세스에서 결정된 액션이 이메일을 전송하기 위해 이메일 애플리케이션을 이용하는 것인 경우, 추출된 슬롯은, 상기 이메일이 앨리스(Alice)에게 전송될 것임을 지시하는, (@contact, Alice)의 키 및 값 쌍을 포함할 수 있다. 예를 들면, 상기 이메일에 대한 본문 또는 메시 지가 알려지지 않은 경우와 같이, 상기 액션을 이행하기(fulfill) 위한 어떠한 슬롯들도 아직 알려지지 않은 경 우, 상기 액션에 대한 누락된 파라미터들은 도 5와 관련하여 설명된 바와 같이 결정될 수 있다. 블록에서, 상기 프로세서는 블록에서 수신된 상기 명령어를 이행하는 데 이용될 다음 애플리케이션, 액션, 및 모든 결정된 슬롯들을 반환하고(return) 설정한다. 도 6은 애플리케이션, 액션, 및 슬롯 추출 프로세스의 일 예를 도시하고 있지만, 도 6에 대해 다양한 변경 이 이루어질 수 있다. 예를 들면, 일련의 단계들로 도시되어 있지만, 도 6에서의 다양한 단계들은 중첩되거나, 병렬적으로 발생하거나, 상이한 순서로 발생하거나, 또는 몇 번이라도 발생할 수 있다. 또한, 다음 명령어가 상 기 학습 에이전트에 의해 수신되기 전에 파싱되지 않는 실시예들에서, 상기 다음 명령어에 대한 NL 발화를 파싱 하기 위해, 결정 블록 전에 추가적 단계가 포함될 수 있다. 나아가, 예를 들면, 상기 프로세서가 블록 에서 애플리케이션 선택 및 액션 선택을 수신하고 상기 프로세서가, 상기 선택된 애플리케이션 및 액션에 대한 하나 이상의 추출된 슬롯들을 결정 및 수신하기 위해, 블록에서 상기 명령어를 상기 NLU 엔진에 제공 하는 경우, 프로세스는 블록으로부터 블록으로 이동할 수 있다. 도 7은, 본 개시의 다양한 실시예들에 따른, 예시적인 액션 및 API 제안 프로세스(action and API suggestion process)를 도시한다. 설명의 편의를 위해, 프로세스는 도 1에서의 전자 디바이스들(101, 102, 104) 또는 서버 중 어떤 것의 프로세서(들)에 의해 실행되거나 또는 달리 이용되는 것으로 설명될 수 있다. 그러나, 프로세스는 어떤 적절한 디바이스(들)에 의해 어떤 적절한 시스템에서도 이용될 수 있다. 프로세스는, 시스템 아키텍처 및/또는 시스템과 같은, 본 개시의 다양한 실시예들과 관련하여 설명되는 복합 태스크 학습 시스템과 함께 이용될 수 있다. 일부 실시예들에서, 프로세스는 도 6에서의, 블록과 같이, 프로세스의 일부일 수 있다. 블록에서, 상기 프로세서는 명령어 및 결정된 애플리케이션을 수신한다. 일부 실시예들에서, 결정된 애플 리케이션에도 불구하고 NLU 엔진에 의해 액션이 결정될 수 없는 경우, 상기 프로세서는 상기 의도되는 액션을 수행하기 위해 상기 사용자가 선택할 애플리케이션 액션들 및/또는 API 호출들의 순위 리스트(ranked list)를 생성할 수 있다. 블록에서, 상기 프로세서는 상기 결정된 애플리케이션에 대한 미리-정의된 스킬들의 세트 를 결정한다. 상기 미리-정의된 스킬들은 상기 미리-구축된 스킬들의 세트에 포함될 수 있다. 애플리케이 션 개발자는, IDE와 같은 표준 스킬 개발 도구들을 이용하여, PA 서비스에 의해 이용될 상기 애플리케이션 개발자의 애플리케이션에 상응하는 새로운 스킬들을 개발 및 추가할 수 있다. 일부 실시예들에서, 미리-구축된 스킬들은, 자바스크립트 객체 표기법(JavaScript Object Notation: JSON) 포맷과 같은, 표준화된 포맷으로 액션 결과들을 반환할 수 있다. 일부 실시예들에서, NLU 서비스 또는 NLU 엔진과 같은, 상기 NLU 엔진은, 발화에 대한 신뢰도 점수들(confidence scores)에 기초하여, 사용자에게 제안할 상기 미리-정의된 스킬들의 세 트에 어느 스킬들을 포함시킬지 결정할 수 있다. 예를 들면, 상기 프로세서는, 상기 NLU 엔진이 액션이 해당 스 킬 유형에 상응할지 확신하지 못하는 경우, 특정 미리-구축된 스킬들을 상기 세트에 포함시키거나 또는 상기 세 트로부터 제외할 것을 선택할 수 있다. 다른 실시예들에서, 상기 프로세서는 애플리케이션에 대한 모든 미리-구 축된 스킬들을 검색할(retrieve) 수 있다. 블록에서, 예를 들면, 가장 관련 있거나 또는 의도되는 액션일 가능성이 가장 높은 것에서부터 가장 관련이 없거나 의도되는 액션일 가능성이 가장 낮은 순서로 상기 스킬들을 순위 매김으로써, 상기 프로세서는 상기 애플리케이션에 의해 수행 가능한 상기 검색된(retrieved) 미리-구축된 스킬들로부터 순위 리스트(ranked list)를 생성한다. 일부 실시예들에서, 상기 스킬들의 순위 리스트를 생성하 는 단계는 상기 액션에 대한 NLU 모델 신뢰도 점수들에 기초하거나 또는, 어느 스킬들이 사용자들에 의해 가장 자주 선택되는가와 같이, 다른 기준들에 기초할 수 있다. 프로세스는 또한, 예를 들면, API 및 액션 지식 베이스(224 또는 324)로부터, API 호출들의 세트를 결정하 는 단계를 포함한다. 상기 API 및 액션 지식 베이스는, 개발자들에 의해 추가되는, 사용자-친화적이고 표준화된 포맷인, 애플리케이션 또는 디바이스 API들을 포함할 수 있다. 이는 사용자들이 미리-구축된 애플리케이션 스킬 들 이외의(beyond) 액션들을 티칭 또는 수행할 수 있도록 한다. 애플리케이션 개발자들은, 예를 들면, API 지식 베이스의 웹 서비스 또는 독립형 IDE를 통해, 그들의 API들을 API 및 액션 지식 베이스(224 또는 324)에 등록할 수 있다. 상기 애플리케이션 개발자들은 또한, 사용자들이 상기 PA를 통해 상기 API들을 실행할 수 있도록, API및 액션 지식 베이스(224 또는 324)의 표준화된 포맷에 따라 래퍼 함수(wrapper function)를 구현할 수 있다. 미리-구축된 스킬들 및 API 호출들 모두에 대하여, PA 서비스는, NL 명령어를 파싱한 후 실행되는 액션들 과 같은, 다른 액션들과 동일한 방식으로 애플리케이션 액션들을 모니터링 및 제어할 수 있다. 이러한 액션들은 음성 명령들(voice commands) 또는 PA 서비스 UI-기반 입력에 의해 호출되기(invoked) 때문에, 상기 PA는 미리 -구축된 스킬들 액션의 일부로서 구현된 상응하는 프로그램, 상기 API 지식 베이스로부터의 상기 래퍼 함수, 또 는 이 둘 모두를 실행할 수 있다. 애플리케이션 또는 액션 의존성들의 학습 및 JSON 입출력 표준화로 인해, 하 나의 액션 또는 애플리케이션으로부터의 반환된 결과들(returned results)은, 어떠한 복잡한(elaborate) 데이터 변환(data transformation)도 없이, 다른 액션 또는 애플리케이션으로 라우팅될(routed) 수 있다. 상기 프로세 서는, 카테고리 명칭, 액션 명칭, API 설명, 통합 자원 식별자(uniform resource identifier: URI) 또는 통합 자원 지시자(uniform resource locator: URL), 파라미터들, 출력 포맷, 이행 함수(fulfillment function), 또 는 기타 메타-정보(meta-information)와 같은, API 메타-정보를 이용하여, 상기 사용자의 NL 명령어로부터 API 검색(retrieval)을 수행할 수 있다. 블록에서, 상기 프로세서는 상기 수신된 명령어 및 상기 결정된 애플리케이션에 기초하여 발화 표현 (utterance representation)을 생성한다. 예를 들면, 상기 발화 표현은 상기 결정된 애플리케이션의 명칭 및 상 기 발화된 액션을 포함할 수 있다. 일부 실시예들에서, 상기 발화 표현은, 상기 발화 또는 액션의 의미론 (semantics)을 나타내는, 특정 차원의 벡터일 수 있다. 블록에서, 상기 프로세서는 상기 수신된 발화 및 상기 결정된 애플리케이션에 기초하여 API 표현(API representation)을 생성한다. 예를 들면, 상기 API 표현은, 상기 표현이 상기 애플리케이션의 호출(invocation)을 포함하고 상기 액션 및 파라미터들이 상기 발화로부터의 정보로 대체됨과 함께, 상기 애플리케이션에 대한 API 호출과 같이 포맷화될 수 있다. 일부 실시예들에서, 상기 API 표현은, 상기 API 액션의 의미론(semantics)을 나타내는, 특정 차원의 벡터일 수 있다. 블록에서, 상 기 프로세서는, 상기 사용자의 의도되는 액션과 관련될 수 있는 API 호출들에 대한 포맷들을 결정하기 위해, 상 기 발화 표현과 상기 API 표현 간의 유사도(similarity)를 결정한다. 일부 실시예들에서, 상기 발화 표현과 상 기 API 표현 간의 상기 유사도는 상기 발화 표현 벡터와 상기 API 표현 벡터 간의, 코사인 거리(cosine distance)와 같은, 적절한 거리를 측정함으로써 계산될 수 있다. 블록에서, 상기 프로세서는, 블록에 서의 상기 결정된 유사도에 기초하여, API 호출들의 순위 리스트를 생성한다. 블록에서, 상기 프로세서는, 예를 들면, 에이전트 UI(220 또는 320)에, 순위 매겨진 미리-정의된 애플리케 이션 스킬들 및 API 호출들의 조합된 리스트(combined list)를 사용자들에게 출력 및 표시한다. 상기 사용자는, 상기 사용자가 상기 명확한 발화에서 의도한 상기 태스크를 수행할, 액션 또는 API 호출을 선택할 수 있다. 블 록에서, 상기 프로세서는 상기 선택된 액션 또는 상기 액션에 이용될 API 호출을 수신한다. 상기 프로세서 는, 예를 들면, 도 6에서 설명된 바와 같이, 상기 액션을 수행하기 위한 적절한 파라미터들을 결정할 수 있고, 예를 들면, 도 5에 설명된 바와 같이, 모든 누락된 파라미터들을 결정할 수 있다. 각각의 명확한 명령어가 처리 된 후 복합 태스크 객체를 생성할 때, 상기 복합 태스크 객체는, 상기 복합 태스크 객체를 이용하는 향후의 태 스크들(future tasks)도 또한 상기 선택된 액션들 또는 API 호출들을 이용하도록, 프로세스에서 정의된 대 로 이용할 어떤 액션 또는 API 호출이라도 포함할 것이다. 도 7은 액션 및 API 제안 프로세스의 일 예를 도시하고 있지만, 도 7에 대해 다양한 변경이 이루어질 수 있다. 예를 들면, 일련의 단계들로 도시되어 있지만, 도 7에서의 다양한 단계들은 중첩되거나, 병렬적으로 발생 하거나, 상이한 순서로 발생하거나, 또는 몇 번이라도 발생할 수 있다. 또한, 상기 프로세서는 미리-정의된 스 킬들 및 API 호출들의 조합된 리스트를 출력하지 않을 수 있으며 대신에 미리-정의된 스킬들 및 API 호출들의 별개의 리스트들을 출력할 수 있다. 나아가, 상기 사용자는 오직 미리-정의된 스킬들만 보거나 또는 오직 API 호출들만 보는 것을 선택할 수 있다. 도 8은, 본 개시의 다양한 실시예들에 따른, API 메타-정보의 예시적 세트를 도시한다. 메타-정보는, API 호출들의 생성 및 사용자들에게 API 호출들을 제안하기 위한 데이터의 검색에 이용되는 메타-정보의 표준화 된 세트를 제공하기 위해, API 및 액션 지식 베이스(224 또는 324)에 저장될 수 있다. API 및 액션 지식 베이스 (224 또는 324)는 개발자들에 의해 추가되는, 사용자-친화적이고 표준화된 포맷인, 애플리케이션 또는 디바이스 API들을 포함할 수 있다. 이는 사용자들이 미리-구축된 애플리케이션 스킬들 이외의(beyond) 액션들을 티칭 또 는 수행할 수 있도록 한다. 애플리케이션 개발자들은 그들의 API들을 상기 API 및 액션 지식 베이스에 등록할 수 있으며, 상기 애플리케이션 개발자들은 상기 API 및 액션 지식 베이스의 표준화된 포맷에 따라 래퍼 함수 (wrapper function)를 구현할 수 있다. 미리-구축된 스킬들 및 API 호출들 모두에 대하여, PA 서비스는, NL 명령어를 파싱한 후 실행되는 액션들과 같은, 다른 액션들과 동일한 방식으로 애플리케이션 액션들을 모니터링 및 제어할 수 있다. 도 8에 도시된 바와 같이, 메타-정보는, 각각이 속성 설명(attribute description) 및 속성에 대한 값을 갖는, 다양한 속성들(attributes)을 포함할 수 있다. 예를 들면, 도 8에 도시된 바와 같이, 속성들은 카테고리, 액션, 설명(description), URI, 파라미터들, 응답(response), 및 이행(fulfillment) 속성을 포함할 수 있다. 메타-정보는 각 속성의 설명 및 상기 속성의 값을 포함할 수 있다. 예를 들면, 도 8에서의 예는 카테고리 속성에 대한 설명이 \"API 카테고리의 명칭\"이며 \"메시지들(Messages)\"의 예시적 카테고리를 갖는 것을 보여준다. 상기 액션 속성에 대한 설명은 \"카테고리 내 API에 의해 수행되는 액션(action performed by API in category)\"이며 \"전송(Send)\"의 예시적 액션을 가진다. 상기 설명 속성에 대한 설명은 \"API 설명(API description)\"이며 \"지정된 메시지를 To, Cc, 및 Bcc 헤더들 내의 수신자들에게 전송(sends the specified message to the recipients in the To, Cc, and Bcc headers)\"의 예시적 설명을 가진다. 상기 URI 속성에 대한 설명은 \"API 호출 URI(API call URI)\"이며 \"https://www.googleapis.com/upload/gmail/v1/users/userid/messages/send\"의 예시적 URI를 가진다. 상기 파라미터 속성에 대한 설명은 \"API 호출 파라미터들(API call parameters)\"이며, 메시지 API 카테고리 내 의 메시지를 전송하는 API 호출에 이용될 파라미터들을 지시하는(indicate), \"userid, uploadtype, raw message\"의 예시적 파라미터들을 가진다. 상기 응답 속성에 대한 설명은 \"응답 객체 템플릿(response object template)\"이며, 이 API 호출에 대한 응답에 의해 메시지 자원 객체(message resource object)가 제공됨을 지 시하는, \"메시지 자원 객체(message resource object)\"의 예시적 객체를 가진다. 상기 이행 속성에 대한 설명은 \"API 호출에 대한 래퍼 함수(wrapper function for API call)\"이며, 파라미터들과 같은, 메시지의 전송을 이행 하기 위해 모든 추가적인 정보를 포함하는, 상기 메시지를 전송하는 API의 함수(function)를 지시하는, \"sendMessage()\"의 예시적 이행 래퍼 함수(fulfillment wrapper function)를 가진다. 도 8은 API 메타-정보의 세트의 일 예를 도시하고 있지만, 도 8에 대해 다양한 변경이 이루어질 수 있다. 예를 들면, 상기 메타-정보는 다른 또는 추가적인 어떤 속성들, 설명들, 및 값들이라도 포함할 수 있다. 또한, 도 8에 도시된 특정 값들은 단지 예들일 뿐이며, 애플리케이션 및 상기 애플리케이션에 대한 API 함수들 (functions)에 따라, 각 카테고리에 대해 다른 값들이 이용될 수 있음을 이해할 것이다. 도 9는, 본 개시의 다양한 실시예들에 따른, 예시적인 복합 태스크 생성 프로세스를 도시한다. 설명의 편 의를 위해, 프로세스는 도 1에서의 전자 디바이스들(101, 102, 104) 또는 서버 중 어떤 것의 프로세 서(들)에 의해 실행되거나 또는 달리 이용되는 것으로 설명될 수 있다. 그러나, 프로세스는 어떤 적 절한 디바이스(들)에 의해 어떤 적절한 시스템에서도 이용될 수 있다. 프로세스는, 시스템 아키텍처 및/또는 시스템과 같은, 본 개시의 다양한 실시예들과 관련하여 설명되는 복합 태스크 학습 시스템과 함께 이용될 수 있다. 일부 실시예들에서, 프로세스는 복합 태스크 객체를 생성하기 위한 블록 또는 블록 의 일부일 수 있다. 블록에서, 프로세서는 파라미터 딕셔너리(parameter dictionary) 및 복합 태스크 스크립트(complex task script)를 초기화한다. 블록에서, 상기 프로세서는, 상기 프로세서 및 학습 에이전트에 의해 결정된 대로, 사용자에 의해 제공되는 명확한 명령어들 중 하나에 대한 다음 애플리케이션, 액션, 및 슬롯(들)을 수신한다. 예를 들면, 상기 명확한 명령어가 이메일 애플리케이션을 이용하여 레스토랑에 관한 이메일을 연락처에 전송하 는 것이었던 경우, 블록에서 검색된 상기 애플리케이션, 액션, 및 슬롯(들)은 이메일 애플리케이션에 대한 식별자(identifier), 미리-구축된 액션 또는 API 호출 형태의 이메일 전송 액션(send email action), 및 @person 슬롯 유형을 포함할 수 있다. 블록에서, 상기 프로세서는, 예를 들면, 상기 API 및 액션 지식 베 이스로부터, 블록에서 검색된 상기 액션에 대한 액션/API 호출 래퍼 스크립트(action/API call wrapper script)를 검색한다. 상기 프로세서는 또한 상기 래퍼 스크립트를 상기 복합 태스크 스크립트에 첨부하거나 또 는 상기 래퍼를 포함하도록 상기 복합 태스크 스크립트를 업데이트한다. 예를 들면, 상기 명확한 명령어가 이메 일 애플리케이션을 이용하여 레스토랑에 관한 이메일을 연락처에 전송하는 것이었던 경우, 상기 검색된 액션 또 는 API 호출은 \"EmailApp.sendEmail()\"로 포맷화된 API 호출일 수 있다. 이 액션은 실행 가능한 복합 태스크 객 체를 구축하는 데 이용할 상기 복합 태스크 스크립트에 첨부된다. 블록에서, 상기 프로세서는 상기 명령어의 티칭(teaching) 동안 이전에 결정된 액션 또는 API 호출 파라미 터들을 검색한다. 예를 들면, 상기 명확한 명령어가 이메일 애플리케이션을 이용하여 레스토랑에 관한 이메일을 연락처에 전송하는 것이었던 경우, 상기 페치된(fetched) 액션 파라미터들은 \"{EmailApp.email.body, EmailApp.email.recipient}\"를 포함하고 이것으로 포맷화될 수 있다. 블록에서, 상기 프로세서는 블록에서 검색된 상기 액션 또는 API 호출 파라미터들에 대한 모든 슬롯 의존성들 또는 컨텍스트 결과 의존성 들을 검색한다. 예를 들면, 상기 명확한 명령어가 이메일 애플리케이션을 이용하여 레스토랑에 관한 이메일을 연락처에 전송하는 것이었던 경우, 검색된 슬롯 의존성은, 상기 검색된 @person 파라미터가 상기 이메일 애플리 케이션에 대한 의존성을 가짐을 지시하는, \"@person -> EmailApp\"을 포함할 수 있다. 다른 예로, 검색된 컨텍스 트 결과 의존성은, 레스토랑 탐색 애플리케이션으로부터 획득된 레스토랑 정보가 상기 이메일 애플리케이션을 이용하여 액션을 이행하는 데 이용될 것임을 지시하는, \"RestaurantApp.Restaurant -> EmailApp\"일 수 있다. 블록에서, 상기 프로세서는, 의존성들을 나타내기 위해, 현재 액션 또는 API 호출 파라미터들을 키들 (keys)로 이용하고 상응하는 슬롯 키들 또는 컨텍스트 결과들을 값들(values)로 이용하여, 상기 검색된 파라미 터들 및 연관된 의존성들을 포함하도록 상기 파라미터 딕셔너리를 업데이트한다. 예를 들면, 상기 명확한 명령 어가 이메일 애플리케이션을 이용하여 레스토랑에 관한 이메일을 연락처에 전송하는 것이었던 경우, 상기 파라 미터 딕셔너리는, 전송될 이메일이 레스토랑 탐색 애플리케이션으로부터 검색된 레스토랑 정보를 상기 이메일의 본문에 포함할 것이고 상기 이메일이 @person 슬롯과 연관된 발화 내의 용어(term)에 전송될 것임을 지시하는, \"{EmailApp.email.body = RestaurantApp.Restaurant, EmailApp.email.recipient = @person}\"과 같은 정보를 포함하도록 업데이트될 수 있다. 결정 블록에서, 상기 프로세서는, 예를 들면, 각각의 명확한 명령어가 블록들(904-912)에서 처리되었는지 여부와 같이, 상기 복합 태스크가 완료되었는지 여부를 결정한다. 완료되지 않은 경우, 프로세스는 블록 으로 돌아가서 다음 애플리케이션, 액션, 및 슬롯(들)을 검색한다. 상기 프로세서가 결정 블록에서 상기 복합 태스크가 완료되었다고 결정하는 경우, 프로세스는 블록으로 이동한다. 블록에서, 상 기 프로세서는 블록에서 검색된 상기 애플리케이션들, 액션들, 및 파라미터들을 상기 파라미터 딕셔너리에 저장된 상기 연관된 의존성들과 결합함으로써 상기 복합 태스크 스크립트를 최적화한다. 상기 프로세서는 또한 상기 결합된 정보를, 지금-학습된 복합 태스크를 수행하도록 추후에 호출될 수 있는, 실행 가능한 프로그램과 같은, 복합 태스크 객체로 변환할 수 있다. 블록에서, 상기 프로세서는, 복합 태스크 프로그램 및 파라미 터 딕셔너리를 포함할 수 있는, 상기 복합 태스크 객체를 출력한다. 상기 복합 태스크 객체는, 사용자가 추후에 동일한 복합 태스크를 이용할 수 있도록, 상기 사용자와 연관하여 저장될 수 있다. 일부 실시예들에서, 상기 복 합 태스크 객체는, 호스트 디바이스와 같은 서버에, 또는 전자 디바이스와 같은 사용자의 전자 디바 이스에, 저장될 수 있다. 프로세스는 블록에서 종료된다. 도 9는 복합 태스크 생성 프로세스의 일 예를 도시하고 있지만, 도 9에 대해 다양한 변경이 이루어질 수 있다. 예를 들면, 일련의 단계들로 도시되어 있지만, 도 9에서의 다양한 단계들은 중첩되거나, 병렬적으로 발생 하거나, 상이한 순서로 발생하거나, 또는 몇 번이라도 발생할 수 있다. 또한, 프로세스는, 예를 들면, 블 록 후, 생성되는 상기 복합 태스크의 각각의 수신되는 액션을 실행하는 단계를 포함할 수 있어, 이에 따라, 새로운 복합 태스크를 처음 생성하는 경우, 각각의 검색된 액션이 실행되고 상기 복합 태스크의 향후 실 행을 위해 복합 태스크 객체가 추후에 생성된다. 도 10a 및 도 10b는, 본 개시의 다양한 실시예들에 따른, 에이전트 UI의 예들을 도시한다. 도 10a는 액션 제안 표시 모드(action suggestion display mode)의 에이전트 UI를 도시하며, 도 10b는 파라미터 선택 모드(parameter selection mode)의 에이전트 UI를 도시한다. 에이전트 UI는, 티칭(teaching) 프로 세스에 관한 다양한 정보가 상기 학습 에이전트와 상호작용하도록 사용자에게 표시될 수 있는, UI 윈도우(100 2)를 포함한다. 예를 들면, UI 윈도우는, 에이전트 UI를 통해 현재 상기 학습 에이전트에 티칭되고 (taught) 있는, 사용자로부터 수신된 복합 태스크 발화를 표시하는, 발화 표시 영역(utterance display area)을 포함할 수 있다. 일부 실시예들에서, PA 서비스가 미지의 복합 태스크를 포함하는 발화를 수신하 는 경우, 상기 학습 에이전트는 상기 사용자의 전자 디바이스 상에 에이전트 UI를 호출할(invoke) 수 있 다. 다른 실시예들에서, 상기 사용자는 새로운 복합 태스크를 상기 학습 에이전트에 티칭하는 것을 시작하기 위 해 에이전트 UI를 여는 것을 선택할 수 있다. UI 윈도우는 또한, 상기 복합 태스크에 대한 새로운 액션을 추가하는 것을 시작하도록 선택될 수 있는, 명령 추가 버튼(add command button) 도 포함한다. 명령 추가 버튼의 선택 시, 에이전트 UI(100 0)는, 예를 들면, 발화를 통해 또는 에이전트 UI에 명령을 입력함으로써, 새로운 명확한 명령어를 제공할 것을 상기 사용자에게 프롬프팅할 수 있다. 상기 복합 태스크가 완료된 경우, 예를 들면, 도 9와 관련하여 설명 된 방식으로, 상기 복합 액션을 저장하도록 저장 버튼(save button)이 선택될 수 있다. 일부 실시예들에 서, 저장 버튼은, 상기 사용자가 상기 명확한 명령어에 대해 상기 에이전트 UI에서의 적절한 옵션들을 선 택한 경우, 각각의 별개의 명확한 명령어 액션을 저장하는 데 이용될 수 있다. 상기 복합 태스크에 대한 각각의새로운 명령이 추가됨에 따라, 각각의 명확한 명령어에 대한 별개의 액션 영역들이 UI 윈도우에 표 시될 수 있다. 예를 들면, \"태국 레스토랑에서 앨리스(Alice)와의 저녁 식사를 스케줄링해\"라는 원본 발화가 상 기 학습 에이전트에 티칭되는(taught) 경우, 상기 사용자는 \"저녁 식사를 위한 태국 레스토랑을 탐색해(search a thai restaurant for dinner)\", \"다음주 월요일에 저녁 식사를 스케줄링해(schedule a dinner next Monday)\", 및 \"이메일로 이벤트를 앨리스와 공유해(share the event with alice via email)\"라는 명확한 명령 어들을, 각각의 명확한 명령어가 별개의 액션 영역에 표시되는 상태로, 제공할 수 있다. 각각의 액션 영역 내 아이콘(icon)은 해당 특정 액션 영역에 대한 상기 명확한 명령어가 완료되었 는지 여부를 지시할 수 있다. 예를 들면, 도 10a 및 도 10b에 도시된 바와 같이, 처음 2개의 명확한 명령어들에 대한 액션 영역들은 각각 상기 2개의 명확한 명령어들이 티칭되어 완료되었음을 지시하기 위한 체크 표시 아이콘(check mark icon)을 가진다. 상기 제3 명확한 명령어에 대한 액션 영역은, 이 명확한 명령어가 상 기 학습 에이전트에 여전히 티칭되어야 하거나 또는 현재 티칭되는 중임을 지시하는, \"i\" 아이콘을 포함한다. 액션 영역들 각각은 또한 상기 명확한 명령어에 대한 학습된 애플리케이션을 지시하는 아이콘도 포함할 수 있다. 예를 들면, 도 10a 및 도 10b에 도시된 바와 같이, 상기 제1 명확한 명령어에 대한 액션 영역은 식사 애플리케이션 아이콘(dining application icon)을 표시하고, 상기 제2 명확한 명령어에 대한 액션 영역 은 캘린더 애플리케이션 아이콘(calendar application icon)을 표시하며, 상기 제3 명확한 명령어에 대한 액션 영역은 이메일 애플리케이션 아이콘(email application icon)을 표시한다. 애플리케이션이 명확한 명령어에 대해 여전히 학습되어야 하는 경우, 에이전트 UI는 액션 영역에 아이콘을 표시하지 않을 수 있다. 도 10a에서, 티칭 영역은 상기 제3 명확한 명령어에 대한 액션 유형을 선택하는 옵션들을 표시 하고 있다. 따라서, 상기 제3 명확한 명령어에 대한 애플리케이션은 이미 결정되었으며, 상기 이메일 아이콘은 상기 제3 명확한 명령어에 대한 액션 영역에 추가되어 있다. 상기 애플리케이션이 이미 결정되지 않았다 면, 도 10a에서 상기 이메일 아이콘이 표시되는 영역은 공백(blank)으로 나타날 수 있다. 도 10a 및 도 10b에 도시된 바와 같이, 에이전트 UI의 티칭 영역은 상기 사용자를 위해 선택 가능 한 다양한 정보 및 아이템들을 제공할 수 있다. 예를 들면, 도 10a에서, 티칭 영역은 선택 가능한 액션 유형들의 리스트를 표시한다. 이러한 선택 가능한 액션 유형들은, 예를 들면, 도 6, 도 7, 및 도 8과 관련하여 상술된 방식으로, 상기 학습 에이전트가 검색하고 티칭 영역에서 상기 사용자에게 제시하는, 조합된 미리 -구축된 스킬들 및 API 호출들의 순위 리스트(ranked list) 내에 있을 수 있다. 예를 들면, 상기 NLU 엔진에 의 한 명확한 명령어 발화의 파싱으로부터 애플리케이션이 결정될 수 없는 경우, 티칭 영역은 애플리케이션 제안들을 유사하게 표시할 수 있다. 다른 예로, 도 10b에 도시된 바와 같이, 티칭 영역은 액션들에 대한 파라미터들 및 의존성들을 설정하는 옵션들을 표시할 수 있다. 예를 들면, 도 10b에 도시된 바와 같이, 티칭 영 역은 특정 액션을 명명하기 위한 타이틀 텍스트 입력 박스(title text input box), 상기 제1 명확한 명령 어에 대한 액션을 수행할 때 찾아낸 레스토랑 옵션을 선택하기 위한 레스토랑 선택 UI 객체(restaurants selection UI object), 및 이메일을 통해 앨리스(Alice)와 공유할 캘린더 이벤트에 대한 이벤트 유형을 선택하 기 위한 이벤트 유형 선택 UI 객체(event type selection UI object)를 표시한다. 따라서, 도 10b는, 이 예에 서, 하나의 애플리케이션으로부터의 레스토랑 정보가 다른 애플리케이션을 통한 저녁 식사 이벤트의 공유 시 이 용될 수 있도록, 상기 복합 태스크 내의 이전 액션들이 상기 학습 에이전트에 티칭됨으로써 애플리케이션들에 걸쳐 정보가 제공될 수 있음을 도시하고 있다. 또한 도 4, 도 5, 및 도 6과 관련하여 설명된 바와 같이, 에이전 트 UI를 통해 상기 학습 에이전트에 티칭되는 애플리케이션 간 의존성들(inter-application dependencies)은, 상기 사용자가 상기 학습 에이전트에 티칭된 상기 복합 태스크를 다시 수행하는 경우 상기 애 플리케이션 간 의존성들이 유지될 수 있도록, 상기 학습 에이전트에 등록될 수 있다. 도 10a 및 도 10b는 에이전트 UI의 예들을 도시하고 있지만, 도 10a 및 도 10b에 대해 다양한 변경이 이 루어질 수 있다. 예를 들면, 도 10a 및 도 10b에 도시된 특정 사용자 인터페이스들은 단지 예들일 뿐이며 에이 전트 UI의 외양, 구조, 배치, 크기, 및 기타 속성들은 달라질 수 있음을 이해할 것이다. 특정한 예로, 에 이전트 UI는, 에이전트 UI가 표시되고 있는 전자 디바이스의 유형에 기초하여, 배치, 치수 (dimension), 또는 크기가 달라질 수 있다. 또한, 예를 들면, 티칭 영역 및 액션 영역들이 에이전 트 UI의 상이한 영역들에 위치하는 경우, 상기 에이전트 UI의 다양한 섹션들(sections)도 또한 재배치될 수 있다. 나아가, 상기 복합 태스크에 대해 제출되는 명확한 명령어의 수에 따라, 에이전트 UI는 액션 영 역을 몇 개라도 표시할 수 있음을 또한 이해할 것이다. 또한, 에이전트 UI는, 상기 사용자에 의해 이전에 생성된 모든 복합 액션들의 리스트를 보여주는 표시 화면(display screen)과 같은, 상이한 표시 화면들 을 포함할 수 있다.도 11은, 본 개시의 다양한 실시예들에 따른, 예시적인 멀티-디바이스(multi-device) 복합 태스크 학습 시스템 아키텍처를 도시한다. 아키텍처는 적어도 하나의 호스트 디바이스, 제1 전자 디바이스, 및 하나 이상의 추가적 전자 디바이스들을 포함한다. 일부 실시예들에서, 호스트 디바이스는 서버 일 수 있으며, 전자 디바이스는 전자 디바이스일 수 있다. 각각의 추가적 전자 디바이스(110 5)는 전자 디바이스 및/또는 전자 디바이스와 유사한 구성요소들을 가질 수 있다. 호스트 디바이스 는, 호스트 디바이스에 의해 실행되는 PA 서비스로부터의 NLU 명령들에서 제공되는 복합 태 스크들을 수행하는 것을 학습하기 위해 NLU 서비스 및 API KB 서비스를 이용하는, 학습 에이전트 서비스를 포함한다. PA 서비스는 전자 디바이스로부터 쿼리들(queries) 또는 발화들 (utterances)을 수신하기 위해 ASR 서비스와 협력한다. 본 개시의 다양한 실시예들에서, NLU 서비스 는, 도메인, 이용하고자 하는 애플리케이션들, 및 수행될 액션들과 같은, NL 발화들의 인텐트(intent)를 결정하는 데 이용되고, 상기 발화들에 대한 슬롯 또는 파라미터 값들을 채우는, 신경망과 같은, 확률적 NLU 모 델을 포함할 수 있다. 전자 디바이스는, PA 서비스에서의 호스트 디바이스로 전송되는, 전자 디바이스의 사 용자로부터의 쿼리들 또는 발화들을 수신하도록 구성된, 음성 인터페이스(speech/voice interface)를 포 함한다. 상기 발화들은, 적어도 하나의 추가적 전자 디바이스와 같은, 복합 태스크를 수행하기 위한 하나 이상의 다른 디바이스들을 이용하라는 명령들을 포함할 수 있다. PA 서비스는 PA 서비스에 의해 수 신되는 NL 발화들을 파싱하기 위해 NLU 서비스를 이용할 수 있으며, PA 서비스는 다양한 태스크들 이 수행되도록 할 수 있다. PA 서비스에 의해 전자 디바이스로부터 수신되는 발화가 NLU 서비스 에 의해 이해될 수 없거나 또는 효과적으로 파싱될 수 없는 경우, 또는 상기 발화가 달리 호스트 디바이 스에 알려지지 않은 경우, 학습 에이전트 서비스는 상기 발화 내의 상기 복합 태스크를 호스트 디 바이스에 티칭하는 데 이용될 수 있다. 전자 디바이스 상의 학습 에이전트 서버 인터페이스 는, 학습 에이전트 서비스에 정보를 제공하여 새로운 복합 태스크를 완료하는 방법을 학습 에이전트 서비 스에 알려 주기 위해, 학습 에이전트 서비스와 통신할 수 있다. 이 기능(functionality)의 예로, 본 개시의 다양한 실시예들에서, 전자 디바이스의 사용자가, 호스트 디 바이스의 PA 서비스에 의해 전자 디바이스로부터 수신되는 발화에 포함된 미인식된 멀티-디 바이스 복합 태스크를 완료하는 방법을 학습 에이전트 서비스에 티칭하는, 명확한 명령어들을 학습 에이 전트 서비스에 제공할 수 있도록 하는, 에이전트 UI가 전자 디바이스 상에 표시될 수 있다. PA 서비스에 의해 수신된 발화 내의 멀티-디바이스 복합 태스크가 미인식된 경우, 학습 에이전트 서비스 는 상기 사용자가 상기 복합 태스크에 관한 추가적 정보를 제공할 것을 요청하는 프롬프트를 에이전트 UI에 표시하라는 명령을 학습 에이전트 서버 인터페이스에 전송할 수 있다. 상기 사용자는 명확한 명령어들을 다양한 포맷으로 제공할 수 있다. 예를 들면, 사용자가 \"난 오븐에서 양지머리를 요리하고 싶어(I want to cook brisket in the oven)\"라고 발화함으로써 3개의 상이한 디바이스들 및/또는 애플리케이션들을 이 용하여 양지머리를 요리하는 복합 태스크를 완수하기를 원한다고 가정하자. 이 명령에 상응하는 인텐트/태스크 를 이해하는 데 실패하는 경우, PA 서비스 및 학습 에이전트 서비스는 이 태스크를 PA 서비스 및 학습 에이전트 서비스에 티칭하도록 에이전트 UI를 통해 상기 사용자에게 프롬프팅한다. 일부 실시예들에서, 상기 사용자는 상기 태스크를 티칭하기 위해, 에이전트 UI를 열고, NL 명령들 또는 발화들과 같은, 명령들을 제공함으로써 새로운 태스크의 티칭을 개시할 수 있다. 복합 태스크를 수행하는 방법을 PA 서비스 및 학습 에이전트 서비스에 티칭할 때, 상기 사용자는, 각각이 상기 멀티-디바이스 복합 태스크에서의 하나의 단계를 제공하는, 하나 이상의 추가적 발화들을 제공할 수 있고, 이에 따라 PA 서비스 및 학습 에이전트 서비스는 상기 추가적인 명확한 발화들 각각에 대 한 각각의 개별 태스크가 수행되도록 할 수 있다. 각각의 개별 태스크를 수행하는 새로운 복합 태스크가 PA 서 비스 및 학습 에이전트 서비스에 의해 구축되고 저장될 수 있다. 상기 새로운 멀티-디바이스 복합 액션을 구축하기 위해, 학습 에이전트 서비스는 NLU 서비스를 이용하여 각각의 명확한 명령어를 파 싱하고 상기 명확한 명령어에 이용할 디바이스 및 디바이스 애플리케이션, 상기 결정된 디바이스 및 애플리케이 션에 기초하여 수행할 액션, 및 상기 액션에 대한, 슬롯(들)과 같은, 파라미터(들)를 결정할 수 있다. 일부 실 시예들에서, NLU 서비스는 미리-구축된 스킬들의 세트로부터 상기 액션을 결정할 수 있다. 각각의 미리-구축된 스킬은 특정 애플리케이션과 연관될 수 있고 상기 특정 애플리케이션의 개발자에 의해 정의되고 제 공될 수 있는데, 예를 들면, 미리-구축된 스킬들이 PA 서비스와 호환 가능하고 NLU 서비스에 의해 인식 가능함을 보장하는, 상기 개발자들이 이용 가능한 PA 스킬 개발 도구들(PA skill development tools)을 이용하여 상기 미리-구축된 스킬들을 제공함으로써, 상기 개발자들에 의해 상기 미리-구축된 스킬들이 제공될 수 있다. 일부 실시예들에서, 명확한 명령어에 대한 액션을 결정하기 위해, 학습 에이전트 서비스는 API 지식 기반 서비스을 이용하여, 명확한 명령어들에 대한 새로운 스킬들을 구축하는 데 이용될 수 있는, 특정 애플리 케이션들에 대한 다양한 API 호출들을 포함하는, API 및 액션 지식 베이스를 액세스할 수 있다. 애플리케 이션 개발자들은, 예를 들면, API 지식 베이스의 웹 서비스 또는 독립형 IDE를 통해, 그들의 API들을 API 및 액션 지식 베이스에 등록할 수 있다. 각각의 애플리케이션 개발자는 또한 API 및 액션 지식 베 이스의 표준화된 포맷에 따라 래퍼 함수(wrapper function)를 구현할 수 있다. 각각의 명확한 명령어가 처리됨에 따라, 호스트 디바이스는 각각의 개별 태스크가 서버 액션 모듈 에 의해 수행되도록 할 수 있다. 호스트 디바이스의 서버 액션 모듈은 네트워크 또는 클라우드 를 통해 전자 디바이스들 각각의 디바이스 액션 모듈과 통신한다. 구성요소들(1106, 1112, 1116, 및 1118)과 같은, 다른 구성요소들도 또한 유사한 방식으로 네트워크를 통해 통신할 수 있음을 이해할 것 이다. 서버 액션 모듈은 액션을 수행하기 위해 명령을 적절한 전자 디바이스(1104 또는 1105)의 디바이스 액션 모듈에 전송한다. 디바이스 액션 모듈은 상기 액션을 수행할 특정 전자 디바이스에 대해 상기 액션의 수행을 명령한다(instruct). 이 기능(functionality)의 예로, \"나는 오븐에서 양지머리를 요리하고 싶어\"라는 원본 발화(original utterance)에 대한 명확한 명령어들이 \"양지머리에 대한 레시피를 탐색해(search recipe for brisket)\"라는 제 1 명령어, \"내 오븐을 예열해(pre-heat my oven)\"라는 제2 명령어, 및 \"양지머리를 요리하는 방법에 관한 비디 오들을 탐색해(search for videos on how to cook brisket)\"라는 제3 명령어를 포함한다고 고려하자. 학습 에 이전트 서비스는 각각의 명확한 명령어를 처리할 수 있다. 예를 들면, 상기 제1 명령어에 대하여, 학습 에이전트 서비스는 수행할 액션이 양지머리 레시피에 대해 상기 사용자의 스마트폰 상에서 레시피 애플리 케이션을 탐색하는 것임을 학습할 수 있다. 상기 제2 명령어에 대하여, 학습 에이전트 서비스는 수행할 액션이 상기 제1 명령어에 대해 반환된 상기 레시피 정보에 열거된 온도에 기초하여 스마트 오븐 디바이스를 예 열하는 것임을 학습할 수 있다. 상기 제3 명령어에 대하여, 학습 에이전트 서비스는 수행할 액션이 스마 트 텔레비전 디바이스의 비디오 스트리밍 애플리케이션에서 양지머리의 요리에 관한 교육용 비디오들 (instructional videos)을 탐색하는 것임을 학습할 수 있다. 일부 실시예들에서, 학습 에이전트 서비스는 또한 이용할 적절한 디바이스들을 찾기 위해 사용자의 전자 디바이스들 중 하나에서 현재 동기화된 디바이스 리 스트 내의 디바이스들을 이용할 수 있다. 또한, 일부 실시예들에서, 사용자는, 프롬프팅 받는 경우, 이용할 디 바이스들을 입력할 수 있다. 상기 사용자에 의해 제공되는 각각의 명확한 명령어에 대한 각 액션이 결정되는 경우, 멀티-디바이스 복합 태스 크를 위한 특정 디바이스들 상에서 개별 태스크들을 실행하기 위한 명령들을 포함하는, 멀티-디바이스 복합 태 스크 객체가 생성될 수 있다. 상기 복합 태스크 객체는 호스트 디바이스에 의해 저장된다. PA 서비스 가 상기 저장된 복합 태스크와 동일 또는 유사한 후속 발화를 수신하는 경우, PA 서비스는 상기 복 합 태스크가 상기 사용자로부터의 추가적 입력 없이 수행되도록 할 수 있다. 일부 실시예들에서, 명확한 명령어 들을 제공하기 위해, 상기 사용자는, 에이전트 UI에 표시된, 가능한 명확한 명령어들의 리스트로부터 명 확한 명령어를 선택할 수 있다. 또한, 일부 실시예들에서, 상기 사용자는, 발화와 유사한 문장(sentence)과 같 은, 명령을 에이전트 UI의 텍스트 입력 영역에 입력함으로써 명확한 명령어들을 제공할 수 있다. 도 11은 멀티-디바이스 복합 태스크 학습 시스템 아키텍처의 일 예를 도시하고 있지만, 도 11에 대해 다 양한 변경이 이루어질 수 있다. 예를 들면, 멀티-디바이스 복합 태스크 학습 시스템 아키텍처에서, PA 서 비스는 서버 액션 모듈, 학습 에이전트 서비스, ASR 서비스, 또는 NLU 서비스 중 하나 이상을 PA 서비스의 기능(functionality)의 일부로 포함할 수 있다. 또한, 음성 인터페이스 , 학습 에이전트 서버 인터페이스, 에이전트 UI, 및 디바이스 액션 모듈의 기능 (functionality)은 단일 엔티티 내에 포함될 수 있다. 나아가, API 및 액션 지식 베이스, 및 미리-구축된 스킬들의 세트는 별개의 데이터 저장소들 또는 데이터베이스들 내에, 또는 동일한 데이터 저장소 또는 데 이터베이스에 포함될 수 있다. 도 12는, 본 개시의 다양한 실시예들에 따른, 멀티-디바이스 복합 태스크 학습 에이전트 시스템을 도시한 다. 시스템은 복합 태스크들을 학습하도록 구성된 학습 에이전트를 포함한다. 일부 실시예들에서, 학습 에이전트는 도 11의 학습 에이전트 서비스일 수 있다. PA 서비스와 같은 PA 서비스에의해 수신되는 발화와 같은, 발화는 멀티-디바이스 복합 태스크를 수행하라는 명령어를 포함하며 NLU 엔 진에 의해 수신된다. 발화에 포함된 상기 멀티-디바이스 복합 태스크가 NLU 엔진에 알려져 있지 않거나 또는 NLU 엔진에 의해 결정될 수 없는 것으로 간주되는 경우, 학습 에이전트는, 예를 들면, 제1 전자 디바이스 상의 에이전트 UI를 통해, 명령어들을 명확히 하도록 사용자에게 프롬프팅할 수 있다. 상기 프롬프트에 응답하여, 상기 사용자는 명확한 명령어를, 상기 복합 태스크를 수행하기 위한 단 계를 제공하는, NLU 엔진에 제공할 수 있다. 이 기능(functionality)의 예로, 발화가 \"난 오븐에서 양지머리를 요리하고 싶어\"라는 발화를 포함하는 경우, 상기 사용자는 에이전트 UI를 통해 상기 복합 태스크가 미지의 것임을 통지 받고, 하나 이상의 명 확한 명령어들을 제공하도록 프롬프팅 받을 수 있다. 예를 들면, 오븐에서 양지머리를 요리하는 것을 돕는 방법 을 학습 에이전트에 티칭하기 위해, 상기 사용자는 \"양지머리에 대한 레시피를 탐색해\", \"내 오븐을 예열 해\", 및 \"양지머리를 요리하는 방법에 관한 비디오들을 탐색해\"라는 3개의 명확한 명령어들을 제공할 수 있다. 일부 실시예들에서, 상기 사용자는 한 번에 하나의 명확한 명령어를 제공할 수 있으며, 여기서 학 습 에이전트는 각각의 명확한 명령어를 처리하고 다음 명확한 명령어에 대해 상기 사용자에 게 프롬프팅한다. 다른 실시예들에서, 상기 복합 태스크가 생성될 때까지 학습 에이전트가 각각의 명확한 명령어를 차례로 또는 동시에 처리함과 함께, 상기 사용자는 단일 프롬프트에 응답하여 모든 명확한 명령어들 을 제공할 수 있다. 또한, 일부 실시예들에서, 학습 에이전트가 각각의 명확한 명령어와 연 관된 태스크를 수행하도록 더 보조하기 위해, 상기 사용자는, 상기 명확한 명령어들 중 하나 이상에, 상기 액션 에 이용할 디바이스 및/또는 애플리케이션의 명칭을 포함할 수 있다. 사용자가 상기 디바이스 및/또는 애플리케 이션의 명칭을 제공하지 않는 경우, NLU 엔진은, 명확한 명령어의 상기 발화에 기초하여, 이용될 상기 디바이스 또는 애플리케이션을 결정하려고 시도할 수 있다. 상기 복합 태스크는, 각각의 명확한 명령어에 기초하여 이용할 디바이스들 및 애플리케이션들을 결정하고 각각의 명확한 명령어에 대한 각각의 서브태스크 (subtask), 액션, 또는 API 호출을 수행함으로써, 명확한 명령어들을 이용하여 생성될 수 있다. 제공되는 특정 명확한 명령어들에 따라, 동일 디바이스 또는 동일 애플리케이션에 의해 다수의 액션들이 수행될 수 있음을 이해할 것이다. 시스템은, 명확한 명령어에 대한 애플리케이션, 액션, 및 파라미터(들)를 이해하기 위해 각각의 명 확한 명령어를 처리하고, 예를 들면, 제2 수신된 명확한 명령어에 대한 제2 액션 및/또는 제2 디바이스가 제1 수신된 명확한 명령어에 대한 제1 액션 및/또는 제1 디바이스에 의존한다는 것을 등록함으로써, 상기 복합 태스크 내의 액션에 대한 모든 의존성들을 등록하는, 앱/액션 의존성 등록 모듈(register app/action dependence module)을 더 포함한다. 앱/액션 의존성 등록 모듈은 또한, 상이한 디바이스들, 애플리 케이션들, 액션들, 파라미터들, 또는 액션들에 대한 의존성들에 대한 선택들을 제공하기 위해, 상기 제1 디바이 스 상의 에이전트 UI를 통해 추가적 입력을 수신할 수 있다. 앱/액션 의존성 등록 모듈은, 디바이 스들 및/또는 디바이스 애플리케이션들에 대한 의존성들의 결정 및 등록을 제공하면서, 도 5, 도 6, 및 도 7과 관련하여 설명된 기능들(functions)과 유사한 기능들을 수행할 수 있다. 앱/액션 의존성 등록 모듈이 명 확한 명령어에 대해 상기 디바이스, 애플리케이션, 액션, 파라미터들, 및 의존성들을 결정한 후, API/액 션 실행 모듈(API/action execution module)은, 예를 들면, 상기 결정된 액션을 수행하라는 명령을 네트 워크를 통해 추가적 전자 디바이스에 전송함으로써, 상기 명확한 명령어에 대한 상기 액션을 수행 한다. 예를 들면, 네트워크는 네트워크일 수 있고, API/액션 실행 모듈은 서버 액션 모듈 에 의해 수행되어, 특정 디바이스 상의 디바이스 애플리케이션에 의한 수행을 위해, 상기 액션을 수행하 라는 명령을 호스트 디바이스로부터 네트워크를 통해 전자 디바이스 또는 추가적 전자 디바 이스(1105 또는 1205)의 디바이스 액션 모듈에 전송할 수 있다. 이 기능(functionality)의 예로, \"난 오븐에서 양지머리를 요리하고 싶어\"라는 원본 발화에 대한 명확한 명령어 들이 \"양지머리에 대한 레시피를 탐색해\"라는 제1 명령어, \"내 오븐을 예열해\"라는 제2 명령어, 및 \"양지머리를 요리하는 방법에 관한 비디오들을 탐색해\"라는 제3 명령어를 포함하는 것을 고려하자. 학습 에이전트는 각각의 디바이스 액션을 학습하기 위해 이러한 명확한 명령어들 각각을 처리할 수 있다. 예를 들면, 상기 제1 명령어에 대하여, 학습 에이전트 서비스는 수행할 상기 액션이 양지머리 레시피에 대해 상기 사용자의 스 마트폰 상의 레시피 애플리케이션을 탐색하는 것임을 학습할 수 있다. 상기 제2 명령어에 대하여, 학습 에이전 트는 수행할 상기 액션이 상기 제1 명령어에 대해 반환된 레시피 정보에 열거된 온도에 기초하여 스마트 오븐 디바이스를 예열함과 함께, 상기 제1 명령어 액션으로부터 획득된 온도 정보에 대한 오븐 디바이스 및 애 플리케이션의 의존성을 등록하는 것임을 학습할 수 있다. 상기 제3 명령어에 대하여, 학습 에이전트는 수 행할 상기 액션이 스마트 텔레비전 디바이스의 비디오 스티리밍 애플리케이션 상에서 양지머리 요리에 관한 교육용 비디오들을 탐색하는 것임을 학습할 수 있다. 일부 실시예들에서, 학습 에이전트는 또한 이용할 적 절한 디바이스들을 찾기 위해 사용자의 전자 디바이스들 중 하나에서 현재 동기화된 디바이스 리스트 내의 디바 이스들을 이용할 수 있다. 또한, 일부 실시예들에서, 사용자는, 프롬프팅 받는 경우, 이용할 디바이스들을 입력 할 수 있다. 명확한 명령어에 대한 상기 액션의 실행 후, 결정 블록에서, 학습 에이전트는, 예를 들면, 호스트 디바이스의 프로세서를 통해, 상기 복합 태스크가 완료되었는지 여부를 결정한다. 완료되지 않은 경우, 다음 명확한 명령어를 수행하기 위한 디바이스, 애플리케이션, 및/또는 액션을 결정하기 위해, NLU 엔진 및 학습 에이전트에 의해 다음 명확한 명령어가 처리된다. 결정 블록 에서 학습 에이전트가 상기 복합 태스크가 완료되었음을 결정할 때까지, 각각의 명확한 명령어가 이런 방 식으로 핸들링된다. 상기 복합 태스크가 완료된 경우, 예를 들면, 도 9와 관련하여 상술된 바와 같이, 향후 상 기 학습된 디바이스들에 걸쳐 새로운 복합 태스크를 수행하도록 실행될 수 있는, 명령어들, 스크립트들, 또는 프로그램들의 세트 또는 레시피를 제공하는, 복합 태스크 객체가 생성된다. 상기 새로운 복합 태스크 객체는, 호스트 디바이스와 같은 서버, 및/또는 전자 디바이스 또는 추가적 전자 디바이스(1105 또는 120 5)와 같은 사용자의 전자 디바이스에 의해 호스팅되는, 액션 데이터베이스에 저장될 수 있다. 도 12는 멀티-디바이스 복합 태스크 학습 에이전트 시스템의 일 예를 도시하고 있지만, 도 12에 대해 다 양한 변경이 이루어질 수 있다. 예를 들면, 결정 블록은, 예를 들면, 모든 명확한 명령어들이 동시 에 처리되는 경우, 시스템에서 수행되지 않을 수 있다. 또한, 각각의 명확한 명령어에 대한 각 액 션이 학습 에이전트 및 앱/액션 의존성 등록 모듈에 의해 결정될 때까지, API/액션 실행 모듈 은 각각의 명확한 명령어의 각 액션을 수행하지 않을 수 있다. 나아가, API 및 액션 지식 베이스 는 또한, 미리-구축된 스킬들의 세트와 같은, 애플리케이션들에 대한 미리-구축된 스킬들도 포함할 수 있다."}
{"patent_id": "10-2021-7041941", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "본 개시가 예시적 실시예들과 함께 설명되었지만, 다양한 변경들 및 변형들이 본 개시가 속하는 기술분야의 통 상의 지식을 가진 자에게 시사될 수 있다. 본 개시는 그러한 변경들 및 변형들이 첨부된 청구항들의 범위에 속 하는 것으로 포괄하고자 한 것이다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10a 도면10b 도면11 도면12"}
{"patent_id": "10-2021-7041941", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시 및 그 이점의 보다 완전한 이해를 위해, 첨부된 도면과 함께 이하의 설명이 이루어지며, 여기서 동일한 참조 번호는 동일한 부분을 나타낸다. 도 1은, 본 개시의 다양한 실시예들에 따른, 예시적인 네트워크 구성을 도시한다. 도 2는, 본 개시의 다양한 실시예들에 따른, 예시적인 복합 태스크 학습 시스템 아키텍처(complex task learning system architecture)를 도시한다. 도 3은, 본 개시의 다양한 실시예들에 따른, 예시적인 복합 태스크 학습 에이전트 시스템(complex task learning agent system)을 도시한다. 도 4는, 본 개시의 다양한 실시예들에 따른, 예시적인 복합 태스크 학습 프로세스를 도시한다. 도 5는, 본 개시의 다양한 실시예들에 따른, 예시적인 애플리케이션 및 액션 등록(registration) 프로세스를 도 시한다. 도 6은, 본 개시의 다양한 실시예들에 따른, 예시적인 애플리케이션, 액션, 및 슬롯 추출(extraction) 프로세스 를 도시한다. 도 7은, 본 개시의 다양한 실시예들에 따른, 예시적인 액션 및 애플리케이션 프로그래밍 인터페이스 (application programming interface: API) 제안(suggestion) 프로세스를 도시한다. 도 8은, 본 개시의 다양한 실시예들에 따른, 예시적인 API 메타-정보(meta-information) 세트를 도시한다. 도 9는, 본 개시의 다양한 실시예들에 따른, 예시적인 복합 태스크 생성 프로세스를 도시한다. 도 10a 및 도 10b는, 본 개시의 다양한 실시예들에 따른, 에이전트 사용자 인터페이스(agent user interface)의 예들을 도시한다. 도 11은, 본 개시의 다양한 실시예들에 따른, 예시적인 멀티-디바이스 복합 태스크 학습 시스템 아키텍처를 도 시한다.도 12는, 본 개시의 다양한 실시예들에 따른, 예시적인 멀티-디바이스 복합 태스크 학습 에이전트 시스템을 도 시한다."}
