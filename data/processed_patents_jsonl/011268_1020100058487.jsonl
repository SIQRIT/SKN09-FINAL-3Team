{"patent_id": "10-2010-0058487", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2011-0138551", "출원번호": "10-2010-0058487", "출원인": "한국과학기술원", "발명자": "김탁곤"}}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "가상 세계 엔진과 플러그인으로 연결되고, 입력 이벤트를 받아들이는 인식 블록, 상기 인식 블록의 인식 결과에따라 상기 지능형 가상 에이전트의 동작을 결정하는 판단 블록, 및 상기 판단 블록에서 결정된 동작을 수행하는행위 블록을 포함하는 지능형 가상 에이전트;상기 판단 블록에 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈;상기 인지 모듈, 학습 모듈, 또는 명령 모듈에 플러그인으로 연결되는 AI 모듈; 및상기 AI 모듈에 플러그인으로 연결되는 AI 알고리즘 모듈을 포함하는 것을 특징으로 하는 플러그인 기반 계층적지능형 가상 에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 인지 모듈에 플러그인으로 연결되는 AI 모듈은 감정인지 AI 모듈, 상황인지 AI 모듈, 또는 사건인지 AI 모듈을 포함하는 것을 특징으로 하는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,상기 학습 모듈에 플러그인으로 연결되는 AI 모듈은 대화학습 AI 모듈, 감정학습 AI 모듈, 또는 행동학습 AI 모듈을 포함하는 것을 특징으로 하는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 명령 모듈에 플러그인으로 연결되는 AI 모듈은 대화구사 AI 모듈, 감정표현 AI 모듈, 또는 행동표현 AI 모듈을 포함하는 것을 특징으로 하는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1 항에 있어서,상기 인식 블록이 받아들이는 입력 이벤트는 지능형 가상 에이전트 관련 이벤트, 사용자 이벤트, 또는 가상 세계 이벤트 중 적어도 하나 이상으로 구성된 것을 특징으로 하는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1 항에 있어서,상기 인식 블록은 상기 인식 블록이 받아들이는 입력 이벤트를 시스템 정보와 관련된 이벤트와 사용자 정보와관련된 이벤트로 필터링하는 이벤트 필터를 더 포함하는 것을 특징으로 하는 플러그인 기반 계층적 지능형 가상에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서,상기 지능형 가상 에이전트 프레임워크는 복수의 지능형 가상 에이전트들을 포함하고, 상기 지능형 가상 에이전트들 간에 상호 작용하는 것을 특징으로 하는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "공개특허 10-2011-0138551-3-제 1 항에 있어서,상기 판단 블록에 상기 인지 모듈, 상기 학습 모듈, 또는 상기 명령 모듈이 동적 링크 라이브러리로 연결되고,상기 인지 모듈, 상기 학습 모듈, 또는 상기 명령 모듈 각각에 AI 모듈이 동적 링크 라이브러리로 연결되며,상기 AI 모듈에 상기 AI 알고리즘 모듈이 동적 링크 라이브러리로 연결되는 것을 특징으로 하는 플러그인 기반계층적 지능형 가상 에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1 항에 있어서,상기 AI 알고리즘 모듈은 사례기반 학습 알고리즘 또는 확률기반 학습 알고리즘인 것을 특징으로 하는 플러그인기반 계층적 지능형 가상 에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 1 항에 있어서,상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각에 DEVS 형식론을 적용함으로써, 상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각이 포함하는 서브 모듈들이 상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각의 시뮬레이션 시간에 동기화되어 시뮬레이션을 수행하는 것을 특징으로 하는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크."}
{"patent_id": "10-2010-0058487", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 1 항에 있어서,상기 지능형 가상 에이전트의 동작에 대한 시나리오 초기값을 제공하는 스토리 텔링 블록을 더 포함하는 것을특징으로 하는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크.명 세 서기 술 분 야본 발명은 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크에 관한 것으로서, 더욱 상세하게는 지능형 [0001]가상 에이전트와 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈 중에서 적어도 하나 이상을 선택하거나 조합함으로써, 진화적이고 개방적인 지능형 가상 에이전트 프레임워크에 관한 것이다.배 경 기 술가상세계란 가상현실과 달리 여러 사용자가 아바타를 활용하여 거주하고 상호작용할 수 있는 컴퓨터 기반의 시 [0002]뮬레이션 세계라고 정의된다. 가상세계는 게임과 커뮤니티 기술에 인간의 상상력이 더해져서 발전한 형태로써오늘날 가상세계의 형태로 발전하고 있다.이런 가상세계는 단순한 오락 사교 분야를 넘어 실생활에 도움을 주는 기능성 가상세계 분야까지 매우 다양하게 [0003]발전하고 있으며, 게임 기술과 시뮬레이션 기술은 각각 별개의 영역으로 발전해 오다가 점차 가상세계의 수요확장으로 양 기술이 융합되고 있다.최근 가상세계 표준화에 힘입어 사용자가 구현한 시뮬레이션 콘텐츠가 대량으로 확보되고 있으며, 분야별 현실 [0004]세계 복제율이 높은 가상세계에서는 현실세계 활동을 일부 수행할 수 있게 되고 있다. 예를 들어 인기가수의 팬미팅을 하는데 기획사가 운영하는 가상세계에서 미팅을 가질 수 있게 된다. 이러한 가상세계 구현 기술로 인해 많은 인간 활동이 가상세계로 이동함에 따라 교통량, 에너지 소비가 감소하 [0005]므로, 가상세계 구현 기술은 사회간접비용, CO2 절감 등의 효과가 있는 녹색 기술(Green Technology)이다.기존에는 서비스 주체별로 독자적인 방식으로 구축하여 서비스를 제공하는 닫힌 가상세계에서 주로 참여자간의 [0006]커뮤니티 형성, 특정 서비스 영역에 중점을 두었으나, 프레임워크 기반의 가상 세계 기술 확보가 중요해지게 됨에 따라 다수의 이종 가상 세계간의 동적인 상호 연결을 위한 개방성, 생명, 진화, 소통(커뮤니케이션), 사실적공개특허 10-2011-0138551-4-시뮬레이션이 가능한 가상세계가 필요하다.또한, 이를 통해, 문화, 관광, 교육, 게임 등의 다양한 서비스 분야에서 공통적으로 쉽게 활용이 가능하고, 개 [0007]방형 가상세계 구현에 필요한 저작도구, 시뮬레이션(물리, 인공지능) 및 대규모 가상세계를 지원하는 가상세계서버 운영 및 관리 기술 등 차세대 개방형 가상세계 프레임워크를 개발할 필요가 있다.특히, 세컨드라이프(Second Life)와 같은 3D 기반의 온라인 가상세계는 종래의 MMORPG 게임과는 달리 사용자들 [0008]이 가상세계 속에서 자신이 거주할 집을 짓거나 의상, 액세서리, 자동차 등을 직접 제작할 수 있을 뿐 아니라,가상세계의 결제수단인 가상화폐를 이용하여 다양한 경제활동과 사교활동을 펼칠 수 있다는 점이 큰 특징이다.이러한 온라인 가상세계에서는 사용자들에게 보다 풍부한 경험과 몰입감을 제공하기 위해 사용자들의 아바타 외에 이들과 상호작용하는 자율 캐릭터들의 역할이 매우 중요하다. 이러한 가상세계 자율 캐릭터들을 지능형 가상에이전트들(Intelligent Virtual Agents, IVA)이라 부른다. IVA들이 자신에게 주어진 역할에 따라 사용자와 자연스러운 상호작용을 진행하기 위해서는 자연어 대화 능력, 감정의 인식과 표현 능력, 행동 계획 능력, 학습 능력 등 다양한 학문들의 통합된 종합 지능이 요구된다. 따라서 지능형 가상 에이전트는 다양한 학문 분야의 성과물들의 총 집합체라 할 수 있다. 그러므로 사용자의 몰 [0009]입감을 증대시키기 위한 지능형 가상 에이전트를 서비스하기 위해서는 각 학문 분야의 성과물을 빠르게 적용할수 있으며, 사용자의 요구사항을 빠르게 적용할 수 있는 지능형 가상 에이전트 프레임워크가 요구된다. 따라서가상세계에 적용될 지능형 가상 에이전트 프레임워크는 사용자들이 자신의 요구사항을 반영할 수 있는 개방적인특징과 각 학문 분야의 최신 결과물을 반영할 수 있는 개방적이고, 진화적인 특징이 필요하다.발명의 내용해결하려는 과제따라서, 본 발명이 해결하고자 하는 과제는 사용자가 시뮬레이션 컨텐츠를 스스로 설계 구현할 수 있으며, 진화 [0010]적이고 개방적인 지능형 가상 에이전트 프레임워크를 제공할 수 있는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크를 제공하는 것이다.과제의 해결 수단본 발명은 상기 첫 번째 과제를 달성하기 위하여, 가상 세계 엔진과 플러그인으로 연결되고, 입력 이벤트를 받 [0011]아들이는 인식 블록, 상기 인식 블록의 인식 결과에 따라 상기 지능형 가상 에이전트의 동작을 결정하는 판단블록, 및 상기 판단 블록에서 결정된 동작을 수행하는 행위 블록을 포함하는 지능형 가상 에이전트; 상기 판단블록에 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈; 상기 인지 모듈, 학습 모듈, 또는 명령모듈에 플러그인으로 연결되는 AI 모듈; 및 상기 AI 모듈에 플러그인으로 연결되는 AI 알고리즘 모듈을 포함하는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크를 제공한다.상기 인지 모듈에 플러그인으로 연결되는 AI 모듈은 감정인지 AI 모듈, 상황인지 AI 모듈, 또는 사건인지 AI 모 [0012]듈을 포함한다.또한, 상기 학습 모듈에 플러그인으로 연결되는 AI 모듈은 대화학습 AI 모듈, 감정학습 AI 모듈, 또는 행동학습 [0013]AI 모듈을 포함한다.또한, 상기 명령 모듈에 플러그인으로 연결되는 AI 모듈은 대화구사 AI 모듈, 감정표현 AI 모듈, 행동표현 AI [0014]모듈을 포함한다.본 발명의 일 실시예에 의하면, 상기 인식 블록이 받아들이는 입력 이벤트는 지능형 가상 에이전트 관련 [0015]이벤트, 사용자 이벤트, 또는 가상 세계 이벤트 중 적어도 하나 이상으로 구성될 수 있다.또한, 상기 인식 블록은 상기 인식 블록이 받아들이는 입력 이벤트를 시스템 정보와 관련된 이벤트와 사용자 정 [0016]보와 관련된 이벤트로 필터링하는 이벤트 필터를 더 포함할 수 있다.본 발명의 다른 실시예에 의하면, 상기 지능형 가상 에이전트 프레임워크는 복수의 지능형 가상 에이전트들을 [0017]포함하고, 상기 지능형 가상 에이전트들 간에 상호 작용할 수 있다.또한, 상기 지능형 가상 에이전트의 판단 블록에 상기 인지 모듈, 상기 학습 모듈, 또는 상기 명령 모듈이 동적 [0018]링크 라이브러리로 연결되고, 상기 인지 모듈, 상기 학습 모듈, 또는 상기 명령 모듈 각각에 AI 모듈이 동적 링공개특허 10-2011-0138551-5-크 라이브러리로 연결되며, 상기 AI 모듈에 상기 AI 알고리즘 모듈이 동적 링크 라이브러리로 연결될 수 있다.또한, 상기 AI 알고리즘 모듈은 사례기반 학습 알고리즘 또는 확률기반 학습 알고리즘일 수 있다. [0019]본 발명의 또 다른 실시예에 의하면, 상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각에 DEVS 형식론 [0020]을 적용함으로써, 상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각이 포함하는 서브 모듈들이 상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각마다 시뮬레이션 시간에 동기화되어 시뮬레이션을 수행할 수있다.또한, 상기 지능형 가상 에이전트의 동작에 대한 시나리오 초기값을 제공하는 스토리 텔링 블록을 더 포함할 수 [0021]있다.발명의 효과본 발명에 따르면, 지능형 가상 에이전트와 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈 중에 [0022]서 적어도 하나 이상을 선택하거나 조합함으로써, 사용자 중심의 개방적이고 진화적인 지능형 가상 에이전트 프레임워크를 제공할 수 있다.또한, 본 발명에 따르면, 지능형 가상 에이전트를 구성하는 인식 블록, 판단 블록, 및 행위 블록 각각에 대하여 [0023]DEVS 형식론을 적용함으로써, 인식 블록, 판단 블록, 및 행위 블록 각각이 포함하는 서브 모듈들이 각각의 모듈마다 시뮬레이션 시간에 동기화되어 시뮬레이션을 수행할 수 있다.도면의 간단한 설명도 1은 본 발명의 일 실시예에 따른 계층적 플러그인 기반 지능형 가상 에이전트 프레임워크의 구성도를 도시한 [0024]것이다.도 2는 본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크에 있어서의 지능형가상 에이전트 자동 합성 방법을 나타낸 것이다.도 3은 본 발명의 일 실시예에 따른 지능형 가상 에이전트의 개념도를 도시한 것이다.도 4는 도 3에 도시된 인식 블록(300)을 보다 상세하게 나타낸 것이다.도 5는 도 3에 도시된 판단 블록(310)을 보다 상세하게 나타낸 것이다.도 6a는 판단 블록(310)이 포함하는 각 모듈들이 실행되는 순서의 일 실시예를 나타낸 것이다.도 6b는 판단 블록(310)이 포함하는 각 모듈들이 실행되는 순서의 다른 실시예를 나타낸 것이다.도 7은 판단 블록 내의 학습 모듈의 개념도를 도시한 것이다.도 8은 도 3에 도시된 행위 블록(320)을 보다 상세하게 나타낸 것이다.도 9는 도 3에 도시된 스토리 텔링 블록(330)을 보다 상세하게 나타낸 것이다.도 10은 DEVS 추상화 시뮬레이터의 구조를 나타낸 것이다.도 11은 원자 모델에 대응하는 시뮬레이터가 주고 받는 메시지 및 처리 알고리즘을 나타낸 것이다.도 12는 결합 모델에 대응하는 코디네이터 알고리즘을 나타낸 것이다.도 13은 시뮬레이션 프로세서 간의 메시지 교환의 예를 나타낸 것이다.발명을 실시하기 위한 구체적인 내용본 발명에 관한 구체적인 내용의 설명에 앞서 이해의 편의를 위해 본 발명이 해결하고자 하는 과제의 해결 방안 [0025]의 개요 혹은 기술적 사상의 핵심을 우선 제시한다.본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크는 가상 세계 엔진과 플러 [0026]그인으로 연결되고, 입력 이벤트를 받아들이는 인식 블록, 상기 인식 블록의 인식 결과에 따라 상기 지능형 가상 에이전트의 동작을 결정하는 판단 블록, 및 상기 판단 블록에서 결정된 동작을 수행하는 행위 블록을 포함하는 지능형 가상 에이전트; 상기 판단 블록에 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈; 상기 인지 모듈, 학습 모듈, 또는 명령 모듈에 플러그인으로 연결되는 AI 모듈; 및 상기 AI 모듈에 플러그인으로공개특허 10-2011-0138551-6-연결되는 AI 알고리즘 모듈을 포함한다.이하, 바람직한 실시예를 들어 본 발명을 더욱 상세하게 설명한다. 그러나 이들 실시예는 본 발명을 보다 구체 [0027]적으로 설명하기 위한 것으로, 본 발명의 범위가 이에 의하여 제한되지 않는다는 것은 당업계의 통상의 지식을가진 자에게 자명할 것이다. 본 발명이 해결하고자 하는 과제의 해결 방안을 명확하게 하기 위한 발명의 구성을본 발명의 바람직한 실시예에 근거하여 첨부 도면을 참조하여 상세히 설명하되, 도면의 구성요소들에 참조번호를 부여함에 있어서 동일 구성요소에 대해서는 비록 다른 도면상에 있더라도 동일 참조번호를 부여하였으며 당해 도면에 대한 설명시 필요한 경우 다른 도면의 구성요소를 인용할 수 있음을 미리 밝혀둔다. 아울러 본 발명과 관련된 공지 기능 혹은 구성에 대한 구체적인 설명 그리고 그 이외의 제반 사항이 본 발명의 요지를 불필요하게 흐릴 수 있다고 판단되는 경우, 그 상세한 설명을 생략한다.도 1은 본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크의 구성도를 도시한 [0028]것이다.가상 세계 엔진(100)은 지능형 가상 에이전트(120~122)와 플러그인(Plug-in)을 인터페이스로 하여 연결된다. [0029]즉, 가상 세계 엔진(100)과 지능형 가상 에이전트(120~122)는 플러그인을 통해 구분되며, 적어도 하나 이상의지능형 가상 에이전트가 가상 세계 엔진과 연결될 수 있다. 가상 세계 엔진(100)과 연결되는 지능형 가상 에이전트(120~122)는 선택되거나 조합될 수 있으며, 지능형 가상 에이전트 간에도 상호 작용을 할 수 있다.지능형 가상 에이전트(120~122)는 가상 세계 엔진(100)에서 동작하며 기본적으로 이산 사건 시스템 명세 (DEVS) [0030]형식론에 의거하여 모델이 기술되므로 DEVS 형식론의 4가지 함수를 기본 API(application programminginterface)로 정의한다. 지능형 가상 에이전트 프레임워크의 내부 모듈 사이의 통신은 가상 세계 시뮬레이션 엔진에서 정의한 메시지 타 [0031]입으로 메시지를 생성하여 전달하고, 가상 세계 시뮬레이션 엔진이 해당 시뮬레이션 모듈에 전달한다.지능형 가상 에이전트(120~122)는 입력 이벤트를 받아들이는 인식 블록, 상기 인식 블록의 인식 결과에 따라 상 [0032]기 지능형 가상 에이전트의 동작을 결정하는 판단 블록, 및 상기 판단 블록에서 결정된 동작을 수행하는 행위블록을 포함하여 구성된다.인식 블록은 가상 세계, 사용자 및 타 에이전트로부터 발생된 사건들을 지능형 가상 에이전트에서 인식하기 위 [0033]하여 이들 사건들을 처리하는 블록이다. 인식 블록에서는 사건들을 필터링하고, 정보들을 융합하는 역할을 담당한다상기 인식 블록이 받아들이는 입력 이벤트는 지능형 가상 에이전트 관련 이벤트, 사용자 이벤트, 또는 가상 세 [0034]계 이벤트 중 적어도 하나 이상으로 구성된다. 또한, 상기 인식 블록은 상기 인식 블록이 받아들이는 입력 이벤트를 시스템 정보와 관련된 이벤트와 사용자 정보와 관련된 이벤트로 필터링하는 이벤트 필터를 더 포함할 수있다.판단 블록은 인식 블록에서 전달받은 사건들에 대해서 어떤 동작을 수행하는 블록으로, 가상 세계 에이전트에서 [0035]두뇌의 역할을 담당하는 블록이다. 판단 블록에서 수행된 결과들은 또 다른 사건으로서 행위 블록으로전달된다.지능형 가상 에이전트(120~122)의 판단모듈은 인지 모듈, 학습 모듈, 감정 모듈 또는 명령 모듈과 플러그인을 [0036]인터페이스로 하여 연결된다. 예를 들어, 지능형 가상 에이전트 중 에이전트 2(121)는 학습모듈(131) 및 감정모듈(132)과 플러그인을 인터페이스로 하여 연결된다. 상기 인지 모듈에 플러그인으로 연결되는 AI 모듈은 감정인지 AI 모듈, 상황인지 AI 모듈, 사건인지 AI 모듈을 [0037]포함한다.상기 학습 모듈에 플러그인으로 연결되는 AI 모듈은 대화학습 AI 모듈, 감정학습 AI 모듈, 행동학습 AI 모듈을 [0038]포함한다.상기 명령 모듈에 플러그인으로 연결되는 AI 모듈은 대화구사 AI 모듈, 감정표현 AI 모듈, 행동표현 AI 모듈을 [0039]포함한다.이하, 인지 모듈, 학습 모듈, 감정 모듈 또는 명령 모듈을 행위 모델로 정의하기로 한다. [0040]AI 모듈은 각 행위 모델에 플러그인으로 연결된다. [0041]공개특허 10-2011-0138551-7-예를 들면, 학습 모듈(131)은 대화 학습 AI 모듈(141) 및 감정 학습 AI 모듈(142)과 플러그인을 인터페이스로 [0042]하여 연결된다. 즉, 행위 모델과 AI 모듈이 플러그인을 통해 구분된다.AI 알고리즘 모듈은 AI 모듈과 플러그인으로 연결된다. [0043]예를 들면, 대화학습 AI 모듈(141)은 사례기반 학습 알고리즘(151) 및 확률기반 학습 알고리즘(152)과 플러그인 [0044]을 인터페이스로 하여 연결된다. 즉, AI 모듈과 AI 알고리즘이 플러그인을 통해 구분된다.행위 블록은 판단 블록에서 전달받은 사건들에 대해서 실제 동작을 수행하는 주체가 된다. 즉, 사건들에 따라 [0045]에이전트의 동작을 제어하는 블록이다.스토리 텔링 블록은 가상 세계에서 제공되는 다양한 콘텐츠들에 대하여 가상 에이전트가 이들을 지원하도록 가 [0046]상 에이전트들의 동작에 대한 초기값과 시나리오에 따른 사건 발생을 담당한다. 이상과 같이 본 발명의 일 실시예에 따른 지능형 가상 에이전트 프레임워크는 플러그인 기반으로 계층적으로 이 [0047]루어져 있음을 알 수 있다. 또한, 기존에 존재하는 가상 세계 엔진, 지능형 가상 에이전트, AI 모듈, AI 알고리즘이 선택과 조합을 통해 재사용될 수 있다.도 2는 본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크에 있어서의 지능형 [0048]가상 에이전트 자동 합성 방법을 나타낸 것이다.도 2를 참조하면, 지능형 가상 에이전트들 간의 상호 작용 관계(200) 및 지능형 가상 에이전트와 동적 링크 라 [0049]이브러리(dynamic link library, DLL) 형식으로 연결되고, 인지 모듈, 학습 모듈, 감정 모듈 등으로 구성된 행위 모델(210)이 도시되어 있다. 또한, 인지 모듈, 학습 모듈, 또는 명령 모듈이 지능형 가상 에이전트의 판단 블록에 동적 링크 라이브러리로 [0050]연결되고, 인지 모듈, 학습 모듈, 상기 명령 모듈 각각에 AI 모듈이 동적 링크 라이브러리로 연결되며, AI 모듈에 AI 알고리즘 모듈이 동적 링크 라이브러리로 연결될 수 있다.본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크는 복수의 지능형 가상 에 [0051]이전트들을 포함하고, 지능형 가상 에이전트들 간에 상호 작용하는 것을 알 수 있다.또한, 지능형 가상 에이전트들 간의 상호 작용에는 변화를 주지 않고도, 각 지능형 가상 에이전트에 대응하는 [0052]행위 모델(210) 구성요소들의 조합을 변경함으로써, 내부 구조 변경이 가능한 프레임워크(230)를 제공할 수 있다. 도 3은 본 발명의 일 실시예에 따른 지능형 가상 에이전트의 개념도를 도시한 것이다. [0053]인식 블록(300)은 지능형 가상 에이전트에 입력되는 다양한 사건들을 분류하고 이들을 통합하는 블록이다. 따라 [0054]서 인식 블록(300)은 사용자와 가상세계 그리고 타 지능형 가상 에이전트에서 발생한 사건들을 관리한다.인식 블록(300)의 입력은 정의된 IVA관련 이벤트, 사용자 이벤트, 가상세계 이벤트 집합이며, 인식 블록(300)의 [0055]출력은 융합된 시스템 이벤트와 융합된 사용자 이벤트 집합으로 정의된다. 또한 인식 블록은 이벤트 필터 모듈과 정보 융합 모듈로 구성된다.판단 블록(310)은 지능형 가상 에이전트의 두뇌 역할을 하는 블록으로서, 받아들인 입력 이벤트를 판단하는 블 [0056]록이다. 판단 블록은 기본적으로 인지 모듈, 학습 모듈, 명령 모듈로 구분될 수 있다. 이러한 기본적인 모듈은지능형 가상 에이전트의 판단 블록에서 판단을 내릴 수 있도록 하는 기본적인 모듈이므로 사용자의 요구사항의변경에 유연하게 대응될 수 있도록 설계되어야 한다. 따라서 각 세부 모듈은 계층적으로 구성되며, 해당 세부모듈의 동작을 세밀하게 구현하기 위해서는 새로운 계층을 추가하거나 기존 계층을 분화시킬 수 있도록 설계된다판단 블록(310)에 인지 모듈, 학습 모듈, 또는 명령 모듈이 동적 링크 라이브러리로 연결될 수 있다. 나아가 인 [0057]지 모듈, 학습 모듈, 또는 명령 모듈 각각에 AI 모듈이 동적 링크 라이브러리로 연결되며, AI 모듈에 AI 알고리즘 모듈이 동적 링크 라이브러리로 연결될 수 있다. 이와 같이 동적 링크 라이브러리로 연결되는 구조이므로,각 구성요소의 선택과 조합이 자유롭다.행위 블록(320)은 판단 블록(310)이 판단한 결과를 토대로 결정된 행위를 출력하는 모듈이다. [0058]스토리 텔링 블록(330)은 가상 세계가 시작될 때의 초기값을 설정한다. [0059]공개특허 10-2011-0138551-8-도 4는 도 3에 도시된 인식 블록(300)을 보다 상세하게 나타낸 것이다. [0060]인식 블록(300)은 이벤트 필터(410), 시스템 정보 융합부(420), 및 사용자 정보 융합부(430)를 포함하여 이루어 [0061]진다.이벤트 필터(410)는 가상 세계의 이벤트들(상황 변화, 사용자 입력 등)에 대하여 선택적으로 인식이 가능하도록 [0062]하는 필터이다.이벤트 필터(410)는 IVA 관련 이벤트, 사용자 이벤트, 가상 세계 이벤트를 입력으로 받고, 시스템 정보 융합부 [0063](420) 또는 사용자 정보 융합부(430)로 해당하는 이벤트를 필터링하여 출력한다. 즉, 사용자, 가상 세계, 시스템 등에서 발생한 이벤트는 인식 블록(300)의 이벤트 필터(410)로 입력된다.이벤트 필터(410)는 가상 세계 및 사용자에서 발생한 중복 이벤트의 관리 및 이벤트의 가중치를 관리한다. 그리 [0064]고 이벤트 필터(410)에서 발생한 이벤트들은 시스템 정보 융합부(420)와 사용자 정보 융합부(430)로 입력되어각각 메시지를 처리한다. 시스템 정보 융합부(420)는 이벤트 필터(410)로부터 입력받은 이벤트에 기초하여 시스템 융합 이벤트를 생성한 [0065]다. 특히, 시스템 정보 융합부(420)는 시스템 상에서 발생하고 지능형 가상 에이전트에서 처리되어야 하는 스토리 텔링과 같은 이벤트들을 융합한다.사용자 정보 융합부(430)는 이벤트 필터(410)로부터 입력받은 이벤트에 기초하여 사용자 융합 이벤트를 생성한 [0066]다.사용자 정보 융합부(430)는 사용자의 클릭 혹은 드래그 앤 드롭과 같은 사용자가 발생시키는 이벤트들에 따라 [0067]사용자 이벤트들을 융합한다. 사용자 정보 융합부(430)는 사용자, 가상세계, 그리고 타 에이전트에서 발생시키는 이벤트들을 관련 있는 이벤트들을 융합시켜 판단 블록에서 이들을 용이하게 처리할 수 있도록 한다.도 5는 도 3에 도시된 판단 블록(310)을 보다 상세하게 나타낸 것이다. [0068]인식 블록(300)로부터 시스템 융합 이벤트 또는 사용자 융합 이벤트를 받아들이고, 이에 기초하여 인지 모듈, [0069]학습 모듈, 명령 모듈의 출력값을 생성한다.인지 모듈에는 감정인지 AI 모듈, 상황인지 AI 모듈, 사건인지 AI 모듈 등이 있고, 학습 모듈에는 대화학습 AI [0070]모듈, 감정학습 AI 모듈, 행동학습 AI 모듈 등이 있으며, 명령 모듈에는 대화구사 AI 모듈, 감정표현 AI 모듈,행동표현 AI 모듈 등이 있으나 이에 한정되지 않는다.인지 모듈은 인식 블록(300)에서 융합된 이벤트들을 받아서 지능형 가상 에이전트로 하여금 이벤트들을 인식, [0071]인지할 수 있도록 한다. 이러한 인지에는 발생된 사건에 따라서 지능형 에이전트의 현재 감정이 어떤 상태인지인지하는 감정 인지 AI 모듈, 가상 세계 등에서 발생한 이벤트에 따라서 현재 지능형 가상 에이전트가 어떤 환경에 있으며 어떤 상황 가운데 있는지 인지하는 상황 인지 AI 모듈, 그리고 그 외적으로 발생하는 사건을 인지하는 사건 인지 AI 모듈로 나뉜다. 이러한 AI 모듈은 사용자의 요구에 따라 세분화 될 수 있다.학습 모듈은 지능형 가상 에이전트로 하여금 다양한 학습을 가능하도록 학습에 관련된 모듈이다. 이러한 학습에 [0072]는 사용자와의 대화를 하기 위한 대화 학습 AI 모듈, 사건에 따라 에이전트의 다음 감정을 결정하게 하는 감정학습 AI 모듈, 에이전트의 동작을 가능하도록 하는 행동 학습 AI 모듈이 있다. 이들 학습 모듈들은 인공지능 분야에서 활발히 연구되고 있으며 인공지능 분야의 연구 성과물을 반영할 수 있도록 설계된다. 학습 모듈에서는명령 블록에게 대화, 감정, 행동을 표현하도록 판단 블록 내에서 이벤트를 발생시킨다.명령 모듈은 지능형 가상 에이전트와 사용자 간의 대화, 에이전트의 감정 표현 및 행동을 할 수 있도록 명령을 [0073]내리는 체계이다. 따라서 명령 블록은 학습 블록에서 발생된 이벤트에 따라 명령 블록에서 행위 블록에 해당되는 이벤트를 발생시킨다. 예를 들어, 대화 구사 모델은 에이전트가 사용자와 대화를 수행하기 위해서 대화를 생성하여 지능형 가상 에이전트의 행위 블록에 전달한다. 이와 같이 감정 표현 블록은 감정의 표현을 위해서 가상에이전트로 하여금 에이전트의 외모 변화, 표정 변화, 제스쳐 발생 등의 이벤트를 생성한다. 그리고 행동 표현블록은 가상 에이전트의 이동, 회전과 같이 감정으로 인하여 발생되는 행동을 제외한 행동 표현 이벤트를 발생시킨다.판단 블록은 인식 블록으로부터 온 융합이벤트로부터 판단을 하고 그것을 이벤트로 내보낸다. 결과로 출력되는 [0074]행위 메시지는 입력과 마찬가지로 사용자 이벤트, 가상 세계 이벤트, 타 IVA 이벤트가 있으며 행위 블록으로 연공개특허 10-2011-0138551-9-결될 수도 있고 그냥 IVA 밖으로 출력될 수도 있다.도 6a는 판단 블록(310)이 포함하는 각 모듈들이 실행되는 순서의 일 실시예를 나타낸 것이다. [0075]판단 블록은 기본적으로 인식블록에서 인식된 융합 메세지를 바탕으로 현재 IVA 상황, 환경, 및 외부 메세지 등 [0076]을 종합적으로 인지하여 학습 블록으로 결과를 보낸다. 그 결과를 받은 학습 블록은 인지한 결과를 자신이 원래가지고 있던 경험에 비추어 결과를 명령 블록으로 내보내고 또한 스스로 학습할 내용을 학습한다. 마지막으로결과를 받은 명령 블록은 최종적으로 행위 메세지를 내보낸다. 하지만 이 모듈들이 실행되는 순서는 구현하기에따라 얼마든지 다른 시퀀스로 이어질수 있다. 물론 최종적으로 명령 블록을 통해 행위 메세지가 나가는 것은 일정하지만 학습 블록과 인지 블록을 거치는 과정이 얼마든지 다를 수 있다.도 6b는 판단 블록(310)이 포함하는 각 모듈들이 실행되는 순서의 다른 실시예를 나타낸 것이다. [0077]융합 메세지가 학습 블록으로 이어지면서 학습 블록의 학습된 내용과 함께 처리된다. 처리된 결과는 인지 블록 [0078]으로 이어져서 인지 과정을 거치고 그 결과가 명령블록으로 이어져서 행위 메세지로 출력된다. 행위 메세지가출력될 때 그 출력도 학습되어야 할 필요가 있다면 다시 학습 블록으로 이어져 학습될 수도 있다.도 7은 판단 블록 내의 학습 모듈의 개념도를 도시한 것이다. [0079]학습 모듈 내에서 다양한 학습 모델들이 시스템 융합 이벤트와 사용자 융합 이벤트를 입력으로 받아 계산을 수 [0080]행하고 계산된 결과를 경쟁 모델로 전달하여 경쟁 모델에서 이를 처리하여 사용자 이벤트, 가상 세계 이벤트,다른 IVA로 전달해야 하는 이벤트를 생성하는 과정을 보여준다. 도 7에 도시된 바와 같이 지능형 가상 에이전트프레임워크는 계층적인 구조를 사용하여 자세한 세부 모델들로 각 모듈이 구성될 수 있으며 이렇게 구성된 모델들의 결과를 취합하는 경쟁 모델을 사용자가 구현하고, 초기값을 입력함으로써, 지능형 가상 에이전트 프레임워크의 진화적인 특징을 구현할 수 있다.도 8은 도 3에 도시된 행위 블록(320)을 보다 상세하게 나타낸 것이다. [0081]판단 블록을 거친 행위 메세지는 행위 블록을 통해 행동 메세지로 변환된다. 인식, 판단을 거쳐서 가공된 이벤 [0082]트들을 토대로 실제 행동을 결정한다. 이벤트만으로는 GUI나 엔진에서 알 수 없기 때문에 그에 맞게 한번 더 변환하는 과정이 필요한 것이다.다양한 메세지 생성자들이 가공된 이벤트를 분석해서 각각에 필요한 이벤트를 만들어 낸다. 도 8을 참조하면, [0083]행위 블록 안에 5가지 메시지 생성자를 만들어 놓았다. 대화 메시지 생성자는 IVA가 다른 IVA나 사용자에 보내는 대화 메시지를 생성한다. IVA 행동 메시지 생성자는 [0084]IVA의 행동을 결정하는 메시지이다. GUI 메시지로 변환되어 출력된다. 표정 메시지 생성자는 IVA의 표정을 결정하는 메시지이다. GUI 메시지로 변환되어 출력된다. 시스템 메시지 생성자는 시뮬레이션 엔진에게 보내는 내부메시지를 생성한다. 내부 메시지로는 에러 코드나, 특수한 메시지가 생성될 것이다. 스토리 메시지 생성자는 스토리 텔링 블록에 보내는 메시지가 생성된다. 스토리 텔링 블록은 이전 내용에 따라서 다음 반응을 할 것이다.스토리 텔링 메시지는 현재 IVA를 사용한 스토리 텔링에서 얼마만큼 진행되었는지를 스토리 텔링 블록에 전달하며 스토리 텔링 블록에서 특별히 동작해야 하는 시나리오에 대한 이벤트를 요청하는 메시지이다. 이는 스토리텔링 블록에서 시나리오를 초기화하는데 모든 예외상황과 스토리를 고려하여 모든 시나리오를 초기화할 수 없기때문에 사용자의 반응에 따라서 초기화하는 루틴을 만들기 위해서 설계되었다.도 9는 도 3에 도시된 스토리 텔링 블록(330)을 보다 상세하게 나타낸 것이다. [0085]스토리 텔링 블록(330)은 가상 세계에서 제공되는 다양한 콘텐츠들에 대하여 가상 에이전트가 이들을 지원하도 [0086]록 가상 에이전트들의 동작에 대한 초기값과 시나리오에 따른 사건 발생을 담당한다.IVA는 외부 이벤트가 없더라도 기본적으로 어떠한 행동을 할 수 있다. 예를 들어 상점의 주인 역할을 하는 IVA [0087]라면, 이 IVA는 계속해서 사람들을 끌어 모으고 물건을 팔기 위해서 판촉행위를 할 수도 있고, 잘 안 팔리는 상황이라면 풀이 죽어서 가만히 앉아 있는 행동을 할 수도 있다. 이러한 시나리오들이 IVA 내부에 있으면서 외부입력이 없을 때에 계속해서 IVA를 움직이고 사용자와 시스템에게 이벤트를 내보낼 수 있다. 스토리 텔링 블록은이 역할을 해준다. 물론 외부 입력이 생긴다면 IVA의 인식, 판단, 행동 블록으로 이어질 것이다.스토리 텔링 블록은 시스템 이벤트와 스토리 텔링 이벤트를 받아서 Event dispatcher를 통해 시나리오를 실행한 [0088]다. Event dispatcher는 이벤트를 받아서 필요한 시나리오를 골라서 실행을 명령하고 해당하는 시나리오는 필요한 이벤트를 생성하여 출력한다. 출력된 이벤트는 다시 스토리 텔링 블록으로 돌아오거나 IVA로 이어질 것이다.공개특허 10-2011-0138551-10-이상에서 살펴본 인식 블록(300), 판단 블록(310), 행위 블록(320)은 DEVS(Discrete Event System [0089]Specification) 형식론을 기반으로 설계되고 구현된다. 인식 블록(300), 판단 블록(310), 및 행위 블록(320) 각각에 DEVS 형식론을 적용함으로써, 인식 블록(300), 판단 블록(310), 및 행위 블록(320) 각각이 포함하는 서브모듈들이 상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각마다 시뮬레이션 시간에 동기화되어 시뮬레이션을 수행할 수 있다.이하에서는 인식 블록(300), 판단 블록(310), 행위 블록(320) 각각에 적용되는 DEVS 형식론에 대하여 보다 상세 [0090]하게 살펴보기로 한다.지능형 가상 에이전트는 DEVS 모델로 구현이 되며 DEVS 모델에 대한 실행 환경에 의해서 실행된다. 따라서 외부 [0091]에 공개되는 인터페이스는 DEVS 모델의 실행과 관련이 있다. DEVS 모델은 3개의 세트와 4개의 함수로 이루어져있는데, 여기서 이 4개의 함수가 외부 인터페이스로서 공개된다고 할 수 있다4개의 함수는 다음의 수학식 1과 같이 표현될 수 있다. [0092]수학식 1[0093]DEVS 모델은 내부적으로 Object 모델을 호출한다. Object 모델은 지능형 가상 에이전트에서 시뮬레이션 모델이 [0094]수행해야 할 동작을 명세하고 이를 구현한다. 이러한 Object 모델은 해당 시뮬레이션 모델이 수행해야 하는 오퍼레이션이 구현되어 있어 DEVS 모델과 함께 시뮬레이션을 수행할 수 있게 한다Object 모델은 지능형 가상 에이전트 프레임워크 내의 시뮬레이션 모델이 실질적으로 수행해야 하는 동작을 정 [0095]의하고 이를 구현한다. 즉, 시뮬레이션 모델이 실질적으로 수행하는 동작들을 클래스 다이어그램의 함수로 정의하고 이들의 입력, 출력 값을 정의하고 이를 바탕으로 객체 모델을 구현한다. 가상 에이전트가 수행해야 하는동작이 정의되고, 이들 동작을 수행하기 위한 입출력 값이 정의되었다면 이들 인터페이스를 바탕으로 지능형 가상 에이전트의 각 모듈을 담당하는 전문가들은 자신의 지식을 바탕으로 모델의 동작에 해당되는 알고리즘을 구현한다. 이를 통하여 각 분야의 전문가들은 가상 세계와 시뮬레이션의 이론을 모르더라도 자신의 전문 분야에집중할 수 있으며 이들 결과를 가상 세계에 적용할 수 있다.이러한 오브젝트에 대한 내용은 특별히 정의되어 있지 않다. 각 DEVS 모델은 자신의 기능에 맞는 API를 정의하 [0096]고 API를 공개한다. 그리하여 오브젝트 함수를 개발하여 상세 내용을 구현하는 개발자는 그 인터페이스를 맞추어서 개발할 수 있다.DEVS 형식론은 복잡한 시스템을 구성요소 별로 나누어 각각의 모델을 만든 후, 이를 합쳐서 전체 시스템을 표현 [0097]할 수 있도록 되어있다. DEVS 형식론에는 시스템 구성 요소를 나타내는 원자 모델(Atomic Model)과 여러 모델을합쳐서 새로운 모델을 구성할 수 있는 결합 모델(Coupled Model)이 있다. 이 두 가지 종류의 모델을 사용하여시스템을 계층적이고 모듈러하게 표현할 수 있다.원자 모델은 시간 명세 상태 천이(Timed State Transition) 레벨에서 시스템의 동작을 표현한다. 원자 모델은 [0098]대상 시스템의 상태를 State로 표현한다. State는 외부의 입력이 들어오거나 혹은 정해진 시간이 흐르면 다른State로 변화한다. 원자 모델의 명세(Specification)은 다음의 수학식 2과 같다.공개특허 10-2011-0138551-11-수학식 2[0099]원자 모델은 3개의 집합(X, Y, S)과 4개의 함수(δext, δint, λ, ta) 로 구성되어 있다. [0100]입력 이벤트의 집합(Intput Events Set, X)은 외부에서 현 모델로 들어올 수 있는 모든 이벤트를 모아놓은 집합 [0101]이다. 출력 이벤트의 집합(Output Events Set, Y)은 모델에서 외부로 내보내는 모든 이벤트를 모아놓은 집합이다. 상태 집합(States Set, S)은 모델이 가질 수 있는 모든 상태를 모아놓은 집합이다. 한 시점에서 모델은 하나의 상태에 있게 된다. 이전 상태에서 현재 상태(s)로 천이한 시점을 기준으로, 현재 상 [0102]태에 머물고 있는 시간을 경과 시간 (elapsed time, e) 이라고 한다. 하나의 상태에는 그 상태에서 머물 수 있는 최대 시간이 정해져 있는데, 이 값은 시간 전진 함수(Time Advance Function, ta)에 의해서 구해진다. 따라서 현재 상태를 s라고 하면 경과 시간은 0≤e≤ta(s)가 된다. 현재 상태(s)와 현재 상태에 머문 시간(e)을 합쳐서 모델의 전체 상태(Total State, Q) 라고 한다. 외부 상태 천이 함수(External Transition Function, δext)은 외부에서 입력 이벤트가 발생했을때, 내부 상태를 [0103]변화시키기 위한 함수이다. 입력 이벤트가 발생했을 때, 모델은 하나의 전체 상태에 있게 되고, 각 경우에 대해서 어떤 상태로 이동할 것인지를 기술한 함수가 외부 상태 천이 함수이다. 외부로부터 아무런 이벤트도 발생하지 않고, 현 상태에 머물 수 있는 시간이 다 흐르면(e=ta(s)), 내부 상태 천 [0104]이에 의해서 다른 상태로 이동하게 된다. 내부 상태 천이 함수(Internal Transition Function, δint)은 내부 상태 천이가 발생했을 경우, 어떤 상태에서 [0105]어느 상태로 이동할 것인지 기술해 놓은 함수이다. 내부 상태 천이가 발생하기 바로 직전에 현 상태에서의 출력이 먼저 발생하게 된다. 출력 함수(Output Function, λ)는 현 상태에서 어떠한 출력을 발생할 것인지 기술하는함수이다. 가상 세계 엔진은 이상의 4개의 함수를 호출해서 지능형 가상 에이전트를 실행한다.상술한 원자 모델의 동작을 정리하면 다음과 같다. [0106]1. 원자 모델은 한번에 한가지 상태(s∈S)에 머물고 있다. [0107]2. 한 상태(s∈S)에 최대로 머물 수 있는 시간은 ta(s)이다. [0108]3. 한 상태(s∈S)에 머물고 있을 때 (0≤e≤ta(s)) 외부 입력 이벤트가 발생하면 외부 상태 천이 함수(δext)에 [0109]의해서 다른 상태로 이동하게 된다.4. 한 상태에 머물 수 있는 시간이 모두 경과하면(e=ta(s)), 출력 함수(λ)에 의해 출력을 내보내고, 내부 상태 [0110]천이 함수(δint)에 의해서 다른 상태로 이동하게 된다.결합 모델(Coupled Model)은 여러 모델을 내부적으로 연결하여 만든 모델이다. 내부 구성요소가 되는 모델은 [0111]Atomic Model일 수도 있고, Coupled Model일 수도 있다. 따라서 모델들을 계속 합쳐서 더욱 큰 시스템을 표현할수 있게 된다. 다음의 수학식 3은 Coupled Model의 명세이다.공개특허 10-2011-0138551-12-수학식 3[0112]결합 모델은 3개의 집합(X, Y, M)과 3개의 관계(EIC, EOC, IC), 하나의 함수(SELECT)로 이루어져 있다. 입력 [0113]이벤트 집합, 출력 이벤트 집합은 앞서 설명한 원자 모델과 동일하다. 내부 구성 요소 모델의 집합(M)은 내부적으로 포함하고 있는 모델의 집합이다. 3개의 관계는 현 결합 모델의 입출력과 내부 구성 요소, 혹은 구성 요소모델 사이의 연결 관계를 표현한다. 외부 입력 연결 관계(EIC)는 현 결합 모델의 입력 이벤트와 내부 구성 요소 모델의 입력 이벤트 사이의 연결 관 [0114]계를 나타낸다. 만약 서로 연결되어 있다면, 현 결합 모델로 입력 이벤트가 발생할 경우, 연결된 내부 구성 요소 모델들의 입력 이벤트가 발생한 것으로 간주하는 것이다. 즉, 이벤트를 단순히 전달하는 역할을 한다. 이러한 역할 때문에 모델의 입출력 이벤트 집합을 입출력 포트라고도 한다. 따라서 외부 입력 연결 관계는 현 결합모델의 입력 포트와 내부 모델의 입력 포트를 연결한 것이 되고, 입력 포트에 이벤트가 발생하면, 그 연결 통로를 따라서 내부 모델로 이벤트가 전달되는 형식으로 이해할 수 있다. 외부 출력 연결 관계(EOC)는 내부 구성 요소 모델의 출력 이벤트(포트)와 결합 모델의 출력 이벤트(포트)를 연 [0115]결한 것이다. 내부 구성 요소 모델에서 발생한 출력 이벤트가 현 결합 모델의 출력 이벤트로 변환되어 외부로전달된다. 내부 연결 관계(IC)는 내부 구성 요소 모델 사이의 입출력을 연결한 것이다. 내부 구성 요소 모델의 출력 이벤 [0116]트가 다른 구성요소 모델의 입력으로 전달된다. 선택 함수(SELECT)는 내부 구성 요소 모델 사이의 우선 순위를 결정해주는 함수이다. 만약 두 모델이 같은 시 [0117]간에 스케쥴 되어 있다면 두 모델 중 어느 모델부터 실행할 것이지를 정해주는 함수이다.이하에서는 DEVS 모델을 시뮬레이션하기 위한 시뮬레이터의 구조와 알고리즘에 대해서 간략히 살펴보기로 한다. [0118]도 10은 DEVS 추상화 시뮬레이터의 구조를 나타낸 것이다. [0119]DEVS 형식론의 가장 큰 특징 중의 하나가 모델과 시뮬레이터의 분리이다. 도 6을 참조하면, DEVS 모델과 시뮬레 [0120]이터의 관계를 보여준다. 도 10의 왼편은 모델의 구성을 보여준다. 최상위 M123 결합 모델이 있고, 이 모델은 다시 원자 모델 M1과 결합 [0121]모델 M23, 결합 모델 M23은 다시 원자 모델 M2, M3으로 이루어져 있는 것을 알 수 있다. 이렇듯 모델 구성에서각 단말은 원자 모델이, 중간 노드는 결합 모델이 위치하는 것을 알 수 있다. 도 10의 오른편의 시뮬레이터도 모델과 동일한 계층 구조를 갖는다. 원자 모델에는 시뮬레이터(Simulator)라고 [0122]하는 시뮬레이션 프로세스가, 결합 모델에는 코디네이터(Coordinator)라고 하는 시뮬레이션 프로세스가 위치한다.DEVS 형식론에서 모델 자체는 수동적인 개체이다. 모델은 기 정해진 집합과 함수들로 이루어져 있을 뿐, 실제적 [0123]으로 정해져 있는 함수를 호출하는 것은 모델에 연결되어 있는 시뮬레이션 프로세스이다. 즉, 시뮬레이터와 코디네이터가 서로 시뮬레이션 메시지를 표 1과 같이 주고 받으면서, 각각 담당하고 있는 모델의 함수 및 정보를공개특허 10-2011-0138551-13-참조하여 시뮬레이션을 진행한다.표 1[0124]이하에서는 시뮬레이터 알고리즘에 대하여 보다 상세하게 살펴보기로 한다. [0125]시뮬레이터는 계층 구조 상의 자신의 상위 코디네이터와 메시지를 주고 받는다. [0126]도 11은 원자 모델에 대응하는 시뮬레이터가 주고 받는 메시지 및 처리 알고리즘을 나타낸 것이다. [0127]시뮬레이터는 상위 코디네이터로부터 (x,t),(*,t)메시지를 받고, (y,t), (done,tN) 메시지를 보낸다 [0128]원자 모델은 하나의 상태에서 머물 수 있는 시간이 정해져 있다. 어떤 시각 t에서 어떤 상태 s가 되었다면, 그 [0129]상태는 외부 입력이 없다면, t + ta(s)시각까지 머물 수 있게 된다. 이것을 시뮬레이션 하기 위해서 시각 t에서상태 변환을 할 때, t + ta(s)값을 구해서 미리 스케줄해 놓게 된다.(*,t) 메시지는 미리 스케줄해 놓은 시간(t)이 다 되었음을 의미한다. 시뮬레이터가 이 메시지를 받으면, 출력 [0130]이벤트를 발생시키고(y=λ(s)), 발생된 이벤트를 상위 코디네이터에게 전달한다((y,t)). 이 후, 내부 상태 천이함수로 모델의 상태를 변경한다(s’= δint(s)). 또한, 시간 전진 함수를 이용하여 변경된 상태에서 머물 수 있는 시간을 구한다. 이 시간을 현재 시간에 더해서 다음 스케줄 시간을 구한 다음, (done,tN)메시지로 상위 코디네이터에게 보고하게 된다. 이때, tN = t + ta(s’)이 된다. 한 모델에서 발생한 출력 이벤트는 코디네이터를 거치면서 입력 이벤트로 변화되어 전달된다. 입출력을 구분하 [0131]기 위해서 x, y의 구분을 두었을 뿐, 두 메시지는 사실상 동일한 것이다. 시뮬레이터가 (x,t)메시지를 받으면외부 상태 천이 함수를 실행하여 모델의 상태를 변경시킨다(s’=δext(s,e,x)). 앞선 경우와 마찬가지로, 모델의상태가 변화하였으므로, 바뀐 상태에 대한 스케줄을 다시 하여 상위 코디네이터에 새로운 스케줄을 알려준다((done,tN)).도 12는 결합 모델에 대응하는 코디네이터 알고리즘을 나타낸 것이다. [0132]코디네이터는 자신의 상위 코디네이터로부터 (x,t),(*,t)를 받고, 하위 시뮬레이터 및 코디네이터로부터 (y,t), [0133](done,tN)을 받는다. 또한 상위 코디네이터로(y,t),(done,tN)를 보내고, 하위 코디네이터/시뮬레이터로(x,t),(*,t)를 보낸다. 코디네이터가 하는 일은 크게 두 가지이다. 출력 이벤트를 적절히 전달하는 일과 하위 모델들의 스케줄 시간을 [0134]관리하는 일이다. 코디네이터가 (x,t)를 받으면 외부 모델에서 발생한 출력 메시지가 전달된 것이다. 코디네이터는 받은 (x,t)를 [0135]자신의 EIC관계에 의해서 전달되어야 하는 내부 모델에게 전달한다. 내부 모델이 원자 모델이든, 결합모델이든, 상관없이 (x,t)메시지의 처리가 끝나면 (done,tN)메시지를 돌려주게 되어있다. 코디네이터가 하위 모델로부터 (done,tN)메시지를 받으면, 각 모델들을 시간이 빠른 순서로 정렬한다. 만약 모 [0136]든 하위 프로세서가 메시지 처리를 종료하고 (done,tN)메시지를 보냈다면, 코디네이터는 그 중 가장 작은 시간값(tmin)을 자신의 상위 코디네이터에게 (done,tN=tmin)메시지로 보고한다. 모델 구조 중 최상위에 위치한 코디네이터는 특별히 시간 진행의 역할을 맡는다. 최상위 코디네이터가 하위 모 [0137]델로부터 (done,tN)을 받으면, 가장 작은 다음 스케쥴 시간값(tmin)을 가지는 하위 모델에게 (*,tmin)메시지를공개특허 10-2011-0138551-14-보내서 시뮬레이션을 진행시키는 역할을 한다. 상위 코디네이터로부터 (*,t)를 받으면, 자신의 하위 모델들 중 가장 작은 다음 스케쥴 시간(tmin)을 가지는 모 [0138]델의 프로세서로 (*,t)를 전달한다. 이때, 반드시 t=tmin의 관계가 성립한다. 만약 두 개 이상의 모델이 같은 시간 최소값을 가지고 있다면, 선택 함수(SELECT)를 사용하여 어떤 모델 프로세서로 (*,t)를 전달할 지 결정한다.(*,t)를 전달받은 모델이 (y,t)를 보내오면, IC, EOC등의 관계에 따라 다른 내부 모델 프로세서로 전달하거나,자신의 상위 코디네이터에게 전달한다. IC에 따라 다른 내부 모델 프로세서로 전달할 경우, (x,t)로 변환하여전달하고 전달 받은 모델들이 (done,tN)메시지를 보내는 것을 기다린다.하위 프로세서가 전달된 (*,t), (x,t) 메시지 처리를 끝내고 (done,tN)을 보내오면 상술한 바와 같이 가장 작은 [0139]시간값(tmin)을 자신의 상위 코디네이터에게 (done,tN=tmin)메시지로 보고한다.도 13은 시뮬레이션 프로세서 간의 메시지 교환의 예를 나타낸 것이다. [0140]원자 모델 M1~M4, 결합 모델 M12, M34, M1234로 이루어져 있고, 원자 모델의 스케줄 시간을 각각 5,6,15,8이라 [0141]고 가정하자. 시뮬레이션 순서는 다음과 같이 진행된다.1. 최상위 코디네이터는 하위 모델 중 가장 빠른 시간이 5임을 알고 있다. 따라서 (*,5)를 C:M12로 전달한다. [0142]2. C:M12는 자신의 하위 모델인 M1의 스케줄 시간이 5임을 알기 때문에 S:M1으로 (*,5)를 전달한다. [0143]3. S:M1은 (*,5)을 받으면 먼저 출력 함수를 실행하여 출력 (y,5)를 발생, C:M12로 전달한다. 이때 y가 out이라 [0144]고 하자.4. C:M12는 연결 관계를 검색하여 (y,5)를 전달한다. M1.out이 M12.out으로 연결되어 있기 때문에 (EOC) [0145]C:M1234로 전달한다.5. C:M1234는 연결 관계를 검색하여 (y,5)를 전달한다. M12.out이 M34.in으로 연결되어 있기 때문에 (IC) [0146]C:M34로 전달한다. 이때 (x,5)로 변환하여 전달한다.6. C:M34는 연결 관계를 검색하여 (x,5)를 전달한다. M34.in이 M4.in으로 연결되어 있기 때문에 (EIC) S:M4로 [0147]전달한다.7. S:M4는 모델의 외부 상태 천이 함수를 실행하여 상태를 변화한 후, 시간 전진 함수를 수행하여 다음 스케줄 [0148]시간을 새롭게 구한다. 새로 얻은 값이 10이기 때문에 (done,10)을 보낸다. M3의 스케줄 시간이 15이기 때문에C:M34는 작은 값인 10을 선택하여 (done,10)을 C:M1234로 보낸다.8. 한편, S:M1은 모델의 내부 상태 천이 함수를 실행하여 상태를 변화한 후, 시간 전진 함수를 수행하여 다음 [0149]스케줄 시간을 구한다. 이때 새로 얻은 값이 9이기 때문에 (done,9)를 보낸다.9. C:M12는 M1의 9와 M2의 6을 비교하여 작은 값인 6을 C:M1234로 보낸다. [0150]10. C:M1234는 전체 하위 모델의 스케줄 시간 6, 10 중 작은 값이 6이기 때문에 C:M12로 (*,6)을 보내게 되고, [0151]이후 1~9번을 반복하게 된다.M1과 M2의 시작 시간이 모두 5 라고 가정한 경우 SELECT가 필요하게 된다. [0152]1. 최상위 코디네이터는 하위 모델 중 가장 빠른 시간이 5임을 알고 있다. 따라서 (*,5)를 C:M12로 전달한다. [0153]2. C:M12는 자신의 하위 모델인 M1, M2의 스케줄 시간이 모두 5임을 알고 있다. 하지만 두 모델 중 어느 모델에 [0154]게 먼저 (*,5)를 전달해야 하는지 정해야 한다.3. 이 경우, SELECT 함수의 필요성이 생긴다. SELECT는 두 개 이상의 모델이 같은 스케줄 시간을 가질 때, 어떤 [0155]모델을 먼저 수행할 것인지 선택하는 역할을 한다. DEVSim++에서는 모델 사이의 우선순위를 정함으로써 SELECT의 역할을 하도록 하였다. 모델 간 우선 순위가 M1>M2라면, C:M12는 M1으로 (*,5)를 전달한다.4. 이후는 동일한 순서로 진행된다. [0156]DEVS를 이용한 지능형 가상 에이전트 프레임 워크를 구성하는 것은 DEVS 모델과 오브젝트 모델이다. 이 각 모델 [0157]은 모델 구현의 전문성과 개발 속도 등을 위하여 분리되어 개발될 수 있다.IVA 프레임워크에 대한 요구사항이 주어질 때, 이것을 분석하여 IVA 프레임워크를 설계한다. 설계한 결과를 토 [0158]공개특허 10-2011-0138551-15-대로 DEVS를 이용한 이산 사건 모델과 세세한 역할을 수행하는 오브젝트 모델로 구분한다. 주로 DEVS Formalism을 전문으로 하는 M&S 전문가가 이산 사건 모델을 DEVS Formalism을 이용하여 설계하고 해당 분야를 잘 아는 전문가가 Object 모델을 UML을 이용하여 구현할 수 있다.본 발명의 실시예들은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 [0159]독 가능 매체에 기록될 수 있다. 상기 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등을단독으로 또는 조합하여 포함할 수 있다. 상기 매체에 기록되는 프로그램 명령은 본 발명을 위하여 특별히 설계되고 구성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판독 가능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD-ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체(magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를포함한다. 상기된 하드웨어 장치는 본 발명의 동작을 수행하기 위해 하나 이상의 소프트웨어 모듈로서 작동하도록 구성될 수 있으며, 그 역도 마찬가지이다.이상과 같이 본 발명에서는 구체적인 구성 요소 등과 같은 특정 사항들과 한정된 실시예 및 도면에 의해 설명되 [0160]었으나 이는 본 발명의 보다 전반적인 이해를 돕기 위해서 제공된 것일 뿐, 본 발명은 상기의 실시예에 한정되는 것은 아니며, 본 발명이 속하는 분야에서 통상적인 지식을 가진 자라면 이러한 기재로부터 다양한 수정 및변형이 가능하다. 따라서, 본 발명의 사상은 설명된 실시예에 국한되어 정해져서는 아니되며, 후술하는 특허청구범위뿐 아니라 이 특허청구범위와 균등하거나 등가적 변형이 있는 모든 것들은 본 발명 사상의 범주에 속한다고 할 것이다.부호의 설명100:가상 세계 엔진 120:Agent1 [0161]121:Agent2 122:Agent3131:학습모듈 132:감정모듈141:대화학습 142:감정학습151:사례기반 학습 알고리즘 152:확률기반 학습 알고리즘300:인식블록 310:판단블록320:행위블록 330:스토리 텔링 블록410:이벤트 필터 420:시스템 정보 융합부430:사용자 정보 융합부공개특허 10-2011-0138551-16-도면도면1도면2공개특허 10-2011-0138551-17-도면3도면4도면5공개특허 10-2011-0138551-18-도면6a도면6b도면7도면8공개특허 10-2011-0138551-19-도면9도면10도면11공개특허 10-2011-0138551-20-도면12도면13공개특허 10-2011-0138551-21-"}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크에 관한 것으로서 가상 세계 엔진과 플러그인 으로 연결되고, 입력 이벤트를 받아들이는 인식 블록, 인식 블록의 인식 결과에 따라 지능형 가상 에이전트의 동 작을 결정하는 판단 블록, 및 판단 블록에서 결정된 동작을 수행하는 행위 블록을 포함하는 지능형 가상 에이전 트; 판단 블록에 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈; 인지 모듈, 학습 모듈, 또는 명 령 모듈에 플러그인으로 연결되는 AI 모듈; 및 AI 모듈에 플러그인으로 연결되는 AI 알고리즘 모듈을 포함하는 것을 특징으로 하며, 지능형 가상 에이전트와 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈 중 에서 적어도 하나 이상을 선택하거나 조합함으로써, 진화적이고 개방적인 지능형 가상 에이전트 프레임워크를 제 공할 수 있다."}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크에 관한 것으로서, 더욱 상세하게는 지능형 가상 에이전트와 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈 중에서 적어도 하나 이상을 선 택하거나 조합함으로써, 진화적이고 개방적인 지능형 가상 에이전트 프레임워크에 관한 것이다."}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "가상세계란 가상현실과 달리 여러 사용자가 아바타를 활용하여 거주하고 상호작용할 수 있는 컴퓨터 기반의 시 뮬레이션 세계라고 정의된다. 가상세계는 게임과 커뮤니티 기술에 인간의 상상력이 더해져서 발전한 형태로써 오늘날 가상세계의 형태로 발전하고 있다. 이런 가상세계는 단순한 오락 사교 분야를 넘어 실생활에 도움을 주는 기능성 가상세계 분야까지 매우 다양하게 발전하고 있으며, 게임 기술과 시뮬레이션 기술은 각각 별개의 영역으로 발전해 오다가 점차 가상세계의 수요 확장으로 양 기술이 융합되고 있다. 최근 가상세계 표준화에 힘입어 사용자가 구현한 시뮬레이션 콘텐츠가 대량으로 확보되고 있으며, 분야별 현실 세계 복제율이 높은 가상세계에서는 현실세계 활동을 일부 수행할 수 있게 되고 있다. 예를 들어 인기가수의 팬 미팅을 하는데 기획사가 운영하는 가상세계에서 미팅을 가질 수 있게 된다. 이러한 가상세계 구현 기술로 인해 많은 인간 활동이 가상세계로 이동함에 따라 교통량, 에너지 소비가 감소하 므로, 가상세계 구현 기술은 사회간접비용, CO2 절감 등의 효과가 있는 녹색 기술(Green Technology)이다. 기존에는 서비스 주체별로 독자적인 방식으로 구축하여 서비스를 제공하는 닫힌 가상세계에서 주로 참여자간의 커뮤니티 형성, 특정 서비스 영역에 중점을 두었으나, 프레임워크 기반의 가상 세계 기술 확보가 중요해지게 됨 에 따라 다수의 이종 가상 세계간의 동적인 상호 연결을 위한 개방성, 생명, 진화, 소통(커뮤니케이션), 사실적시뮬레이션이 가능한 가상세계가 필요하다. 또한, 이를 통해, 문화, 관광, 교육, 게임 등의 다양한 서비스 분야에서 공통적으로 쉽게 활용이 가능하고, 개 방형 가상세계 구현에 필요한 저작도구, 시뮬레이션(물리, 인공지능) 및 대규모 가상세계를 지원하는 가상세계 서버 운영 및 관리 기술 등 차세대 개방형 가상세계 프레임워크를 개발할 필요가 있다. 특히, 세컨드라이프(Second Life)와 같은 3D 기반의 온라인 가상세계는 종래의 MMORPG 게임과는 달리 사용자들 이 가상세계 속에서 자신이 거주할 집을 짓거나 의상, 액세서리, 자동차 등을 직접 제작할 수 있을 뿐 아니라, 가상세계의 결제수단인 가상화폐를 이용하여 다양한 경제활동과 사교활동을 펼칠 수 있다는 점이 큰 특징이다. 이러한 온라인 가상세계에서는 사용자들에게 보다 풍부한 경험과 몰입감을 제공하기 위해 사용자들의 아바타 외 에 이들과 상호작용하는 자율 캐릭터들의 역할이 매우 중요하다. 이러한 가상세계 자율 캐릭터들을 지능형 가상 에이전트들(Intelligent Virtual Agents, IVA)이라 부른다. IVA들이 자신에게 주어진 역할에 따라 사용자와 자 연스러운 상호작용을 진행하기 위해서는 자연어 대화 능력, 감정의 인식과 표현 능력, 행동 계획 능력, 학습 능 력 등 다양한 학문들의 통합된 종합 지능이 요구된다. 따라서 지능형 가상 에이전트는 다양한 학문 분야의 성과물들의 총 집합체라 할 수 있다. 그러므로 사용자의 몰 입감을 증대시키기 위한 지능형 가상 에이전트를 서비스하기 위해서는 각 학문 분야의 성과물을 빠르게 적용할 수 있으며, 사용자의 요구사항을 빠르게 적용할 수 있는 지능형 가상 에이전트 프레임워크가 요구된다. 따라서 가상세계에 적용될 지능형 가상 에이전트 프레임워크는 사용자들이 자신의 요구사항을 반영할 수 있는 개방적인 특징과 각 학문 분야의 최신 결과물을 반영할 수 있는 개방적이고, 진화적인 특징이 필요하다."}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "따라서, 본 발명이 해결하고자 하는 과제는 사용자가 시뮬레이션 컨텐츠를 스스로 설계 구현할 수 있으며, 진화 적이고 개방적인 지능형 가상 에이전트 프레임워크를 제공할 수 있는 플러그인 기반 계층적 지능형 가상 에이전 트 프레임워크를 제공하는 것이다."}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명은 상기 첫 번째 과제를 달성하기 위하여, 가상 세계 엔진과 플러그인으로 연결되고, 입력 이벤트를 받 아들이는 인식 블록, 상기 인식 블록의 인식 결과에 따라 상기 지능형 가상 에이전트의 동작을 결정하는 판단 블록, 및 상기 판단 블록에서 결정된 동작을 수행하는 행위 블록을 포함하는 지능형 가상 에이전트; 상기 판단 블록에 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈; 상기 인지 모듈, 학습 모듈, 또는 명령 모듈에 플러그인으로 연결되는 AI 모듈; 및 상기 AI 모듈에 플러그인으로 연결되는 AI 알고리즘 모듈을 포함하 는 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크를 제공한다. 상기 인지 모듈에 플러그인으로 연결되는 AI 모듈은 감정인지 AI 모듈, 상황인지 AI 모듈, 또는 사건인지 AI 모 듈을 포함한다. 또한, 상기 학습 모듈에 플러그인으로 연결되는 AI 모듈은 대화학습 AI 모듈, 감정학습 AI 모듈, 또는 행동학습 AI 모듈을 포함한다. 또한, 상기 명령 모듈에 플러그인으로 연결되는 AI 모듈은 대화구사 AI 모듈, 감정표현 AI 모듈, 행동표현 AI 모듈을 포함한다. 본 발명의 일 실시예에 의하면, 상기 인식 블록이 받아들이는 입력 이벤트는 지능형 가상 에이전트 관련 이벤트, 사용자 이벤트, 또는 가상 세계 이벤트 중 적어도 하나 이상으로 구성될 수 있다. 또한, 상기 인식 블록은 상기 인식 블록이 받아들이는 입력 이벤트를 시스템 정보와 관련된 이벤트와 사용자 정 보와 관련된 이벤트로 필터링하는 이벤트 필터를 더 포함할 수 있다. 본 발명의 다른 실시예에 의하면, 상기 지능형 가상 에이전트 프레임워크는 복수의 지능형 가상 에이전트들을 포함하고, 상기 지능형 가상 에이전트들 간에 상호 작용할 수 있다. 또한, 상기 지능형 가상 에이전트의 판단 블록에 상기 인지 모듈, 상기 학습 모듈, 또는 상기 명령 모듈이 동적 링크 라이브러리로 연결되고, 상기 인지 모듈, 상기 학습 모듈, 또는 상기 명령 모듈 각각에 AI 모듈이 동적 링크 라이브러리로 연결되며, 상기 AI 모듈에 상기 AI 알고리즘 모듈이 동적 링크 라이브러리로 연결될 수 있다. 또한, 상기 AI 알고리즘 모듈은 사례기반 학습 알고리즘 또는 확률기반 학습 알고리즘일 수 있다. 본 발명의 또 다른 실시예에 의하면, 상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각에 DEVS 형식론 을 적용함으로써, 상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각이 포함하는 서브 모듈들이 상기 인 식 블록, 상기 판단 블록, 및 상기 행위 블록 각각마다 시뮬레이션 시간에 동기화되어 시뮬레이션을 수행할 수 있다. 또한, 상기 지능형 가상 에이전트의 동작에 대한 시나리오 초기값을 제공하는 스토리 텔링 블록을 더 포함할 수 있다."}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명에 따르면, 지능형 가상 에이전트와 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈 중에 서 적어도 하나 이상을 선택하거나 조합함으로써, 사용자 중심의 개방적이고 진화적인 지능형 가상 에이전트 프 레임워크를 제공할 수 있다. 또한, 본 발명에 따르면, 지능형 가상 에이전트를 구성하는 인식 블록, 판단 블록, 및 행위 블록 각각에 대하여 DEVS 형식론을 적용함으로써, 인식 블록, 판단 블록, 및 행위 블록 각각이 포함하는 서브 모듈들이 각각의 모듈 마다 시뮬레이션 시간에 동기화되어 시뮬레이션을 수행할 수 있다."}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 발명에 관한 구체적인 내용의 설명에 앞서 이해의 편의를 위해 본 발명이 해결하고자 하는 과제의 해결 방안 의 개요 혹은 기술적 사상의 핵심을 우선 제시한다. 본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크는 가상 세계 엔진과 플러 그인으로 연결되고, 입력 이벤트를 받아들이는 인식 블록, 상기 인식 블록의 인식 결과에 따라 상기 지능형 가 상 에이전트의 동작을 결정하는 판단 블록, 및 상기 판단 블록에서 결정된 동작을 수행하는 행위 블록을 포함하 는 지능형 가상 에이전트; 상기 판단 블록에 플러그인으로 연결되는 인지 모듈, 학습 모듈, 또는 명령 모듈; 상 기 인지 모듈, 학습 모듈, 또는 명령 모듈에 플러그인으로 연결되는 AI 모듈; 및 상기 AI 모듈에 플러그인으로연결되는 AI 알고리즘 모듈을 포함한다. 이하, 바람직한 실시예를 들어 본 발명을 더욱 상세하게 설명한다. 그러나 이들 실시예는 본 발명을 보다 구체 적으로 설명하기 위한 것으로, 본 발명의 범위가 이에 의하여 제한되지 않는다는 것은 당업계의 통상의 지식을 가진 자에게 자명할 것이다. 본 발명이 해결하고자 하는 과제의 해결 방안을 명확하게 하기 위한 발명의 구성을 본 발명의 바람직한 실시예에 근거하여 첨부 도면을 참조하여 상세히 설명하되, 도면의 구성요소들에 참조번호 를 부여함에 있어서 동일 구성요소에 대해서는 비록 다른 도면상에 있더라도 동일 참조번호를 부여하였으며 당 해 도면에 대한 설명시 필요한 경우 다른 도면의 구성요소를 인용할 수 있음을 미리 밝혀둔다. 아울러 본 발명 과 관련된 공지 기능 혹은 구성에 대한 구체적인 설명 그리고 그 이외의 제반 사항이 본 발명의 요지를 불필요 하게 흐릴 수 있다고 판단되는 경우, 그 상세한 설명을 생략한다. 도 1은 본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크의 구성도를 도시한 것이다. 가상 세계 엔진은 지능형 가상 에이전트(120~122)와 플러그인(Plug-in)을 인터페이스로 하여 연결된다. 즉, 가상 세계 엔진과 지능형 가상 에이전트(120~122)는 플러그인을 통해 구분되며, 적어도 하나 이상의 지능형 가상 에이전트가 가상 세계 엔진과 연결될 수 있다. 가상 세계 엔진과 연결되는 지능형 가상 에이 전트(120~122)는 선택되거나 조합될 수 있으며, 지능형 가상 에이전트 간에도 상호 작용을 할 수 있다. 지능형 가상 에이전트(120~122)는 가상 세계 엔진에서 동작하며 기본적으로 이산 사건 시스템 명세 (DEVS) 형식론에 의거하여 모델이 기술되므로 DEVS 형식론의 4가지 함수를 기본 API(application programming interface)로 정의한다. 지능형 가상 에이전트 프레임워크의 내부 모듈 사이의 통신은 가상 세계 시뮬레이션 엔진에서 정의한 메시지 타 입으로 메시지를 생성하여 전달하고, 가상 세계 시뮬레이션 엔진이 해당 시뮬레이션 모듈에 전달한다. 지능형 가상 에이전트(120~122)는 입력 이벤트를 받아들이는 인식 블록, 상기 인식 블록의 인식 결과에 따라 상 기 지능형 가상 에이전트의 동작을 결정하는 판단 블록, 및 상기 판단 블록에서 결정된 동작을 수행하는 행위 블록을 포함하여 구성된다. 인식 블록은 가상 세계, 사용자 및 타 에이전트로부터 발생된 사건들을 지능형 가상 에이전트에서 인식하기 위 하여 이들 사건들을 처리하는 블록이다. 인식 블록에서는 사건들을 필터링하고, 정보들을 융합하는 역할을 담당 한다 상기 인식 블록이 받아들이는 입력 이벤트는 지능형 가상 에이전트 관련 이벤트, 사용자 이벤트, 또는 가상 세 계 이벤트 중 적어도 하나 이상으로 구성된다. 또한, 상기 인식 블록은 상기 인식 블록이 받아들이는 입력 이벤 트를 시스템 정보와 관련된 이벤트와 사용자 정보와 관련된 이벤트로 필터링하는 이벤트 필터를 더 포함할 수 있다. 판단 블록은 인식 블록에서 전달받은 사건들에 대해서 어떤 동작을 수행하는 블록으로, 가상 세계 에이전트에서 두뇌의 역할을 담당하는 블록이다. 판단 블록에서 수행된 결과들은 또 다른 사건으로서 행위 블록으로 전달된다. 지능형 가상 에이전트(120~122)의 판단모듈은 인지 모듈, 학습 모듈, 감정 모듈 또는 명령 모듈과 플러그인을 인터페이스로 하여 연결된다. 예를 들어, 지능형 가상 에이전트 중 에이전트 2는 학습모듈 및 감정 모듈과 플러그인을 인터페이스로 하여 연결된다. 상기 인지 모듈에 플러그인으로 연결되는 AI 모듈은 감정인지 AI 모듈, 상황인지 AI 모듈, 사건인지 AI 모듈을 포함한다. 상기 학습 모듈에 플러그인으로 연결되는 AI 모듈은 대화학습 AI 모듈, 감정학습 AI 모듈, 행동학습 AI 모듈을 포함한다. 상기 명령 모듈에 플러그인으로 연결되는 AI 모듈은 대화구사 AI 모듈, 감정표현 AI 모듈, 행동표현 AI 모듈을 포함한다. 이하, 인지 모듈, 학습 모듈, 감정 모듈 또는 명령 모듈을 행위 모델로 정의하기로 한다. AI 모듈은 각 행위 모델에 플러그인으로 연결된다. 예를 들면, 학습 모듈은 대화 학습 AI 모듈 및 감정 학습 AI 모듈과 플러그인을 인터페이스로 하여 연결된다. 즉, 행위 모델과 AI 모듈이 플러그인을 통해 구분된다. AI 알고리즘 모듈은 AI 모듈과 플러그인으로 연결된다. 예를 들면, 대화학습 AI 모듈은 사례기반 학습 알고리즘 및 확률기반 학습 알고리즘과 플러그인 을 인터페이스로 하여 연결된다. 즉, AI 모듈과 AI 알고리즘이 플러그인을 통해 구분된다. 행위 블록은 판단 블록에서 전달받은 사건들에 대해서 실제 동작을 수행하는 주체가 된다. 즉, 사건들에 따라 에이전트의 동작을 제어하는 블록이다. 스토리 텔링 블록은 가상 세계에서 제공되는 다양한 콘텐츠들에 대하여 가상 에이전트가 이들을 지원하도록 가 상 에이전트들의 동작에 대한 초기값과 시나리오에 따른 사건 발생을 담당한다. 이상과 같이 본 발명의 일 실시예에 따른 지능형 가상 에이전트 프레임워크는 플러그인 기반으로 계층적으로 이 루어져 있음을 알 수 있다. 또한, 기존에 존재하는 가상 세계 엔진, 지능형 가상 에이전트, AI 모듈, AI 알고리 즘이 선택과 조합을 통해 재사용될 수 있다. 도 2는 본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크에 있어서의 지능형 가상 에이전트 자동 합성 방법을 나타낸 것이다. 도 2를 참조하면, 지능형 가상 에이전트들 간의 상호 작용 관계 및 지능형 가상 에이전트와 동적 링크 라 이브러리(dynamic link library, DLL) 형식으로 연결되고, 인지 모듈, 학습 모듈, 감정 모듈 등으로 구성된 행 위 모델이 도시되어 있다. 또한, 인지 모듈, 학습 모듈, 또는 명령 모듈이 지능형 가상 에이전트의 판단 블록에 동적 링크 라이브러리로 연결되고, 인지 모듈, 학습 모듈, 상기 명령 모듈 각각에 AI 모듈이 동적 링크 라이브러리로 연결되며, AI 모듈 에 AI 알고리즘 모듈이 동적 링크 라이브러리로 연결될 수 있다. 본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크는 복수의 지능형 가상 에 이전트들을 포함하고, 지능형 가상 에이전트들 간에 상호 작용하는 것을 알 수 있다. 또한, 지능형 가상 에이전트들 간의 상호 작용에는 변화를 주지 않고도, 각 지능형 가상 에이전트에 대응하는 행위 모델 구성요소들의 조합을 변경함으로써, 내부 구조 변경이 가능한 프레임워크를 제공할 수 있 다. 도 3은 본 발명의 일 실시예에 따른 지능형 가상 에이전트의 개념도를 도시한 것이다. 인식 블록은 지능형 가상 에이전트에 입력되는 다양한 사건들을 분류하고 이들을 통합하는 블록이다. 따라 서 인식 블록은 사용자와 가상세계 그리고 타 지능형 가상 에이전트에서 발생한 사건들을 관리한다. 인식 블록의 입력은 정의된 IVA관련 이벤트, 사용자 이벤트, 가상세계 이벤트 집합이며, 인식 블록의 출력은 융합된 시스템 이벤트와 융합된 사용자 이벤트 집합으로 정의된다. 또한 인식 블록은 이벤트 필터 모듈 과 정보 융합 모듈로 구성된다. 판단 블록은 지능형 가상 에이전트의 두뇌 역할을 하는 블록으로서, 받아들인 입력 이벤트를 판단하는 블 록이다. 판단 블록은 기본적으로 인지 모듈, 학습 모듈, 명령 모듈로 구분될 수 있다. 이러한 기본적인 모듈은 지능형 가상 에이전트의 판단 블록에서 판단을 내릴 수 있도록 하는 기본적인 모듈이므로 사용자의 요구사항의 변경에 유연하게 대응될 수 있도록 설계되어야 한다. 따라서 각 세부 모듈은 계층적으로 구성되며, 해당 세부 모듈의 동작을 세밀하게 구현하기 위해서는 새로운 계층을 추가하거나 기존 계층을 분화시킬 수 있도록 설계된 다 판단 블록에 인지 모듈, 학습 모듈, 또는 명령 모듈이 동적 링크 라이브러리로 연결될 수 있다. 나아가 인 지 모듈, 학습 모듈, 또는 명령 모듈 각각에 AI 모듈이 동적 링크 라이브러리로 연결되며, AI 모듈에 AI 알고리 즘 모듈이 동적 링크 라이브러리로 연결될 수 있다. 이와 같이 동적 링크 라이브러리로 연결되는 구조이므로, 각 구성요소의 선택과 조합이 자유롭다. 행위 블록은 판단 블록이 판단한 결과를 토대로 결정된 행위를 출력하는 모듈이다. 스토리 텔링 블록은 가상 세계가 시작될 때의 초기값을 설정한다. 도 4는 도 3에 도시된 인식 블록을 보다 상세하게 나타낸 것이다. 인식 블록은 이벤트 필터, 시스템 정보 융합부, 및 사용자 정보 융합부를 포함하여 이루어 진다. 이벤트 필터는 가상 세계의 이벤트들(상황 변화, 사용자 입력 등)에 대하여 선택적으로 인식이 가능하도록 하는 필터이다. 이벤트 필터는 IVA 관련 이벤트, 사용자 이벤트, 가상 세계 이벤트를 입력으로 받고, 시스템 정보 융합부 또는 사용자 정보 융합부로 해당하는 이벤트를 필터링하여 출력한다. 즉, 사용자, 가상 세계, 시스 템 등에서 발생한 이벤트는 인식 블록의 이벤트 필터로 입력된다. 이벤트 필터는 가상 세계 및 사용자에서 발생한 중복 이벤트의 관리 및 이벤트의 가중치를 관리한다. 그리 고 이벤트 필터에서 발생한 이벤트들은 시스템 정보 융합부와 사용자 정보 융합부로 입력되어 각각 메시지를 처리한다. 시스템 정보 융합부는 이벤트 필터로부터 입력받은 이벤트에 기초하여 시스템 융합 이벤트를 생성한 다. 특히, 시스템 정보 융합부는 시스템 상에서 발생하고 지능형 가상 에이전트에서 처리되어야 하는 스토 리 텔링과 같은 이벤트들을 융합한다. 사용자 정보 융합부는 이벤트 필터로부터 입력받은 이벤트에 기초하여 사용자 융합 이벤트를 생성한 다. 사용자 정보 융합부는 사용자의 클릭 혹은 드래그 앤 드롭과 같은 사용자가 발생시키는 이벤트들에 따라 사용자 이벤트들을 융합한다. 사용자 정보 융합부는 사용자, 가상세계, 그리고 타 에이전트에서 발생시키 는 이벤트들을 관련 있는 이벤트들을 융합시켜 판단 블록에서 이들을 용이하게 처리할 수 있도록 한다. 도 5는 도 3에 도시된 판단 블록을 보다 상세하게 나타낸 것이다. 인식 블록로부터 시스템 융합 이벤트 또는 사용자 융합 이벤트를 받아들이고, 이에 기초하여 인지 모듈, 학습 모듈, 명령 모듈의 출력값을 생성한다. 인지 모듈에는 감정인지 AI 모듈, 상황인지 AI 모듈, 사건인지 AI 모듈 등이 있고, 학습 모듈에는 대화학습 AI 모듈, 감정학습 AI 모듈, 행동학습 AI 모듈 등이 있으며, 명령 모듈에는 대화구사 AI 모듈, 감정표현 AI 모듈, 행동표현 AI 모듈 등이 있으나 이에 한정되지 않는다. 인지 모듈은 인식 블록에서 융합된 이벤트들을 받아서 지능형 가상 에이전트로 하여금 이벤트들을 인식, 인지할 수 있도록 한다. 이러한 인지에는 발생된 사건에 따라서 지능형 에이전트의 현재 감정이 어떤 상태인지 인지하는 감정 인지 AI 모듈, 가상 세계 등에서 발생한 이벤트에 따라서 현재 지능형 가상 에이전트가 어떤 환 경에 있으며 어떤 상황 가운데 있는지 인지하는 상황 인지 AI 모듈, 그리고 그 외적으로 발생하는 사건을 인지 하는 사건 인지 AI 모듈로 나뉜다. 이러한 AI 모듈은 사용자의 요구에 따라 세분화 될 수 있다. 학습 모듈은 지능형 가상 에이전트로 하여금 다양한 학습을 가능하도록 학습에 관련된 모듈이다. 이러한 학습에 는 사용자와의 대화를 하기 위한 대화 학습 AI 모듈, 사건에 따라 에이전트의 다음 감정을 결정하게 하는 감정 학습 AI 모듈, 에이전트의 동작을 가능하도록 하는 행동 학습 AI 모듈이 있다. 이들 학습 모듈들은 인공지능 분 야에서 활발히 연구되고 있으며 인공지능 분야의 연구 성과물을 반영할 수 있도록 설계된다. 학습 모듈에서는 명령 블록에게 대화, 감정, 행동을 표현하도록 판단 블록 내에서 이벤트를 발생시킨다. 명령 모듈은 지능형 가상 에이전트와 사용자 간의 대화, 에이전트의 감정 표현 및 행동을 할 수 있도록 명령을 내리는 체계이다. 따라서 명령 블록은 학습 블록에서 발생된 이벤트에 따라 명령 블록에서 행위 블록에 해당되 는 이벤트를 발생시킨다. 예를 들어, 대화 구사 모델은 에이전트가 사용자와 대화를 수행하기 위해서 대화를 생 성하여 지능형 가상 에이전트의 행위 블록에 전달한다. 이와 같이 감정 표현 블록은 감정의 표현을 위해서 가상 에이전트로 하여금 에이전트의 외모 변화, 표정 변화, 제스쳐 발생 등의 이벤트를 생성한다. 그리고 행동 표현 블록은 가상 에이전트의 이동, 회전과 같이 감정으로 인하여 발생되는 행동을 제외한 행동 표현 이벤트를 발생 시킨다. 판단 블록은 인식 블록으로부터 온 융합이벤트로부터 판단을 하고 그것을 이벤트로 내보낸다. 결과로 출력되는 행위 메시지는 입력과 마찬가지로 사용자 이벤트, 가상 세계 이벤트, 타 IVA 이벤트가 있으며 행위 블록으로 연결될 수도 있고 그냥 IVA 밖으로 출력될 수도 있다. 도 6a는 판단 블록이 포함하는 각 모듈들이 실행되는 순서의 일 실시예를 나타낸 것이다. 판단 블록은 기본적으로 인식블록에서 인식된 융합 메세지를 바탕으로 현재 IVA 상황, 환경, 및 외부 메세지 등 을 종합적으로 인지하여 학습 블록으로 결과를 보낸다. 그 결과를 받은 학습 블록은 인지한 결과를 자신이 원래 가지고 있던 경험에 비추어 결과를 명령 블록으로 내보내고 또한 스스로 학습할 내용을 학습한다. 마지막으로 결과를 받은 명령 블록은 최종적으로 행위 메세지를 내보낸다. 하지만 이 모듈들이 실행되는 순서는 구현하기에 따라 얼마든지 다른 시퀀스로 이어질수 있다. 물론 최종적으로 명령 블록을 통해 행위 메세지가 나가는 것은 일 정하지만 학습 블록과 인지 블록을 거치는 과정이 얼마든지 다를 수 있다. 도 6b는 판단 블록이 포함하는 각 모듈들이 실행되는 순서의 다른 실시예를 나타낸 것이다. 융합 메세지가 학습 블록으로 이어지면서 학습 블록의 학습된 내용과 함께 처리된다. 처리된 결과는 인지 블록 으로 이어져서 인지 과정을 거치고 그 결과가 명령블록으로 이어져서 행위 메세지로 출력된다. 행위 메세지가 출력될 때 그 출력도 학습되어야 할 필요가 있다면 다시 학습 블록으로 이어져 학습될 수도 있다. 도 7은 판단 블록 내의 학습 모듈의 개념도를 도시한 것이다. 학습 모듈 내에서 다양한 학습 모델들이 시스템 융합 이벤트와 사용자 융합 이벤트를 입력으로 받아 계산을 수 행하고 계산된 결과를 경쟁 모델로 전달하여 경쟁 모델에서 이를 처리하여 사용자 이벤트, 가상 세계 이벤트, 다른 IVA로 전달해야 하는 이벤트를 생성하는 과정을 보여준다. 도 7에 도시된 바와 같이 지능형 가상 에이전트 프레임워크는 계층적인 구조를 사용하여 자세한 세부 모델들로 각 모듈이 구성될 수 있으며 이렇게 구성된 모델 들의 결과를 취합하는 경쟁 모델을 사용자가 구현하고, 초기값을 입력함으로써, 지능형 가상 에이전트 프레임워 크의 진화적인 특징을 구현할 수 있다. 도 8은 도 3에 도시된 행위 블록을 보다 상세하게 나타낸 것이다. 판단 블록을 거친 행위 메세지는 행위 블록을 통해 행동 메세지로 변환된다. 인식, 판단을 거쳐서 가공된 이벤 트들을 토대로 실제 행동을 결정한다. 이벤트만으로는 GUI나 엔진에서 알 수 없기 때문에 그에 맞게 한번 더 변 환하는 과정이 필요한 것이다. 다양한 메세지 생성자들이 가공된 이벤트를 분석해서 각각에 필요한 이벤트를 만들어 낸다. 도 8을 참조하면, 행위 블록 안에 5가지 메시지 생성자를 만들어 놓았다. 대화 메시지 생성자는 IVA가 다른 IVA나 사용자에 보내는 대화 메시지를 생성한다. IVA 행동 메시지 생성자는 IVA의 행동을 결정하는 메시지이다. GUI 메시지로 변환되어 출력된다. 표정 메시지 생성자는 IVA의 표정을 결정 하는 메시지이다. GUI 메시지로 변환되어 출력된다. 시스템 메시지 생성자는 시뮬레이션 엔진에게 보내는 내부 메시지를 생성한다. 내부 메시지로는 에러 코드나, 특수한 메시지가 생성될 것이다. 스토리 메시지 생성자는 스 토리 텔링 블록에 보내는 메시지가 생성된다. 스토리 텔링 블록은 이전 내용에 따라서 다음 반응을 할 것이다. 스토리 텔링 메시지는 현재 IVA를 사용한 스토리 텔링에서 얼마만큼 진행되었는지를 스토리 텔링 블록에 전달하 며 스토리 텔링 블록에서 특별히 동작해야 하는 시나리오에 대한 이벤트를 요청하는 메시지이다. 이는 스토리 텔링 블록에서 시나리오를 초기화하는데 모든 예외상황과 스토리를 고려하여 모든 시나리오를 초기화할 수 없기 때문에 사용자의 반응에 따라서 초기화하는 루틴을 만들기 위해서 설계되었다. 도 9는 도 3에 도시된 스토리 텔링 블록을 보다 상세하게 나타낸 것이다. 스토리 텔링 블록은 가상 세계에서 제공되는 다양한 콘텐츠들에 대하여 가상 에이전트가 이들을 지원하도 록 가상 에이전트들의 동작에 대한 초기값과 시나리오에 따른 사건 발생을 담당한다. IVA는 외부 이벤트가 없더라도 기본적으로 어떠한 행동을 할 수 있다. 예를 들어 상점의 주인 역할을 하는 IVA 라면, 이 IVA는 계속해서 사람들을 끌어 모으고 물건을 팔기 위해서 판촉행위를 할 수도 있고, 잘 안 팔리는 상 황이라면 풀이 죽어서 가만히 앉아 있는 행동을 할 수도 있다. 이러한 시나리오들이 IVA 내부에 있으면서 외부 입력이 없을 때에 계속해서 IVA를 움직이고 사용자와 시스템에게 이벤트를 내보낼 수 있다. 스토리 텔링 블록은 이 역할을 해준다. 물론 외부 입력이 생긴다면 IVA의 인식, 판단, 행동 블록으로 이어질 것이다. 스토리 텔링 블록은 시스템 이벤트와 스토리 텔링 이벤트를 받아서 Event dispatcher를 통해 시나리오를 실행한 다. Event dispatcher는 이벤트를 받아서 필요한 시나리오를 골라서 실행을 명령하고 해당하는 시나리오는 필요 한 이벤트를 생성하여 출력한다. 출력된 이벤트는 다시 스토리 텔링 블록으로 돌아오거나 IVA로 이어질 것이다.이상에서 살펴본 인식 블록, 판단 블록, 행위 블록은 DEVS(Discrete Event System Specification) 형식론을 기반으로 설계되고 구현된다. 인식 블록, 판단 블록, 및 행위 블록 각 각에 DEVS 형식론을 적용함으로써, 인식 블록, 판단 블록, 및 행위 블록 각각이 포함하는 서브 모듈들이 상기 인식 블록, 상기 판단 블록, 및 상기 행위 블록 각각마다 시뮬레이션 시간에 동기화되어 시뮬레 이션을 수행할 수 있다. 이하에서는 인식 블록, 판단 블록, 행위 블록 각각에 적용되는 DEVS 형식론에 대하여 보다 상세 하게 살펴보기로 한다. 지능형 가상 에이전트는 DEVS 모델로 구현이 되며 DEVS 모델에 대한 실행 환경에 의해서 실행된다. 따라서 외부 에 공개되는 인터페이스는 DEVS 모델의 실행과 관련이 있다. DEVS 모델은 3개의 세트와 4개의 함수로 이루어져 있는데, 여기서 이 4개의 함수가 외부 인터페이스로서 공개된다고 할 수 있다 4개의 함수는 다음의 수학식 1과 같이 표현될 수 있다. 수학식 1"}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "DEVS 모델은 내부적으로 Object 모델을 호출한다. Object 모델은 지능형 가상 에이전트에서 시뮬레이션 모델이 수행해야 할 동작을 명세하고 이를 구현한다. 이러한 Object 모델은 해당 시뮬레이션 모델이 수행해야 하는 오 퍼레이션이 구현되어 있어 DEVS 모델과 함께 시뮬레이션을 수행할 수 있게 한다 Object 모델은 지능형 가상 에이전트 프레임워크 내의 시뮬레이션 모델이 실질적으로 수행해야 하는 동작을 정 의하고 이를 구현한다. 즉, 시뮬레이션 모델이 실질적으로 수행하는 동작들을 클래스 다이어그램의 함수로 정의 하고 이들의 입력, 출력 값을 정의하고 이를 바탕으로 객체 모델을 구현한다. 가상 에이전트가 수행해야 하는 동작이 정의되고, 이들 동작을 수행하기 위한 입출력 값이 정의되었다면 이들 인터페이스를 바탕으로 지능형 가 상 에이전트의 각 모듈을 담당하는 전문가들은 자신의 지식을 바탕으로 모델의 동작에 해당되는 알고리즘을 구 현한다. 이를 통하여 각 분야의 전문가들은 가상 세계와 시뮬레이션의 이론을 모르더라도 자신의 전문 분야에 집중할 수 있으며 이들 결과를 가상 세계에 적용할 수 있다. 이러한 오브젝트에 대한 내용은 특별히 정의되어 있지 않다. 각 DEVS 모델은 자신의 기능에 맞는 API를 정의하 고 API를 공개한다. 그리하여 오브젝트 함수를 개발하여 상세 내용을 구현하는 개발자는 그 인터페이스를 맞추 어서 개발할 수 있다. DEVS 형식론은 복잡한 시스템을 구성요소 별로 나누어 각각의 모델을 만든 후, 이를 합쳐서 전체 시스템을 표현 할 수 있도록 되어있다. DEVS 형식론에는 시스템 구성 요소를 나타내는 원자 모델(Atomic Model)과 여러 모델을 합쳐서 새로운 모델을 구성할 수 있는 결합 모델(Coupled Model)이 있다. 이 두 가지 종류의 모델을 사용하여 시스템을 계층적이고 모듈러하게 표현할 수 있다. 원자 모델은 시간 명세 상태 천이(Timed State Transition) 레벨에서 시스템의 동작을 표현한다. 원자 모델은 대상 시스템의 상태를 State로 표현한다. State는 외부의 입력이 들어오거나 혹은 정해진 시간이 흐르면 다른 State로 변화한다. 원자 모델의 명세(Specification)은 다음의 수학식 2과 같다.수학식 2"}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "원자 모델은 3개의 집합(X, Y, S)과 4개의 함수(δext, δint, λ, ta) 로 구성되어 있다. 입력 이벤트의 집합(Intput Events Set, X)은 외부에서 현 모델로 들어올 수 있는 모든 이벤트를 모아놓은 집합 이다. 출력 이벤트의 집합(Output Events Set, Y)은 모델에서 외부로 내보내는 모든 이벤트를 모아놓은 집합이 다. 상태 집합(States Set, S)은 모델이 가질 수 있는 모든 상태를 모아놓은 집합이다. 한 시점에서 모델은 하나의 상태에 있게 된다. 이전 상태에서 현재 상태(s)로 천이한 시점을 기준으로, 현재 상 태에 머물고 있는 시간을 경과 시간 (elapsed time, e) 이라고 한다. 하나의 상태에는 그 상태에서 머물 수 있 는 최대 시간이 정해져 있는데, 이 값은 시간 전진 함수(Time Advance Function, ta)에 의해서 구해진다. 따라 서 현재 상태를 s라고 하면 경과 시간은 0≤e≤ta(s)가 된다. 현재 상태(s)와 현재 상태에 머문 시간(e)을 합쳐 서 모델의 전체 상태(Total State, Q) 라고 한다. 외부 상태 천이 함수(External Transition Function, δext)은 외부에서 입력 이벤트가 발생했을때, 내부 상태를 변화시키기 위한 함수이다. 입력 이벤트가 발생했을 때, 모델은 하나의 전체 상태에 있게 되고, 각 경우에 대해 서 어떤 상태로 이동할 것인지를 기술한 함수가 외부 상태 천이 함수이다. 외부로부터 아무런 이벤트도 발생하지 않고, 현 상태에 머물 수 있는 시간이 다 흐르면(e=ta(s)), 내부 상태 천 이에 의해서 다른 상태로 이동하게 된다. 내부 상태 천이 함수(Internal Transition Function, δint)은 내부 상태 천이가 발생했을 경우, 어떤 상태에서 어느 상태로 이동할 것인지 기술해 놓은 함수이다. 내부 상태 천이가 발생하기 바로 직전에 현 상태에서의 출력 이 먼저 발생하게 된다. 출력 함수(Output Function, λ)는 현 상태에서 어떠한 출력을 발생할 것인지 기술하는 함수이다. 가상 세계 엔진은 이상의 4개의 함수를 호출해서 지능형 가상 에이전트를 실행한다. 상술한 원자 모델의 동작을 정리하면 다음과 같다. 1. 원자 모델은 한번에 한가지 상태(s∈S)에 머물고 있다. 2. 한 상태(s∈S)에 최대로 머물 수 있는 시간은 ta(s)이다. 3. 한 상태(s∈S)에 머물고 있을 때 (0≤e≤ta(s)) 외부 입력 이벤트가 발생하면 외부 상태 천이 함수(δext)에 의해서 다른 상태로 이동하게 된다. 4. 한 상태에 머물 수 있는 시간이 모두 경과하면(e=ta(s)), 출력 함수(λ)에 의해 출력을 내보내고, 내부 상태 천이 함수(δint)에 의해서 다른 상태로 이동하게 된다. 결합 모델(Coupled Model)은 여러 모델을 내부적으로 연결하여 만든 모델이다. 내부 구성요소가 되는 모델은 Atomic Model일 수도 있고, Coupled Model일 수도 있다. 따라서 모델들을 계속 합쳐서 더욱 큰 시스템을 표현할 수 있게 된다. 다음의 수학식 3은 Coupled Model의 명세이다.수학식 3"}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "결합 모델은 3개의 집합(X, Y, M)과 3개의 관계(EIC, EOC, IC), 하나의 함수(SELECT)로 이루어져 있다. 입력 이벤트 집합, 출력 이벤트 집합은 앞서 설명한 원자 모델과 동일하다. 내부 구성 요소 모델의 집합(M)은 내부적 으로 포함하고 있는 모델의 집합이다. 3개의 관계는 현 결합 모델의 입출력과 내부 구성 요소, 혹은 구성 요소 모델 사이의 연결 관계를 표현한다. 외부 입력 연결 관계(EIC)는 현 결합 모델의 입력 이벤트와 내부 구성 요소 모델의 입력 이벤트 사이의 연결 관 계를 나타낸다. 만약 서로 연결되어 있다면, 현 결합 모델로 입력 이벤트가 발생할 경우, 연결된 내부 구성 요 소 모델들의 입력 이벤트가 발생한 것으로 간주하는 것이다. 즉, 이벤트를 단순히 전달하는 역할을 한다. 이러 한 역할 때문에 모델의 입출력 이벤트 집합을 입출력 포트라고도 한다. 따라서 외부 입력 연결 관계는 현 결합 모델의 입력 포트와 내부 모델의 입력 포트를 연결한 것이 되고, 입력 포트에 이벤트가 발생하면, 그 연결 통로 를 따라서 내부 모델로 이벤트가 전달되는 형식으로 이해할 수 있다. 외부 출력 연결 관계(EOC)는 내부 구성 요소 모델의 출력 이벤트(포트)와 결합 모델의 출력 이벤트(포트)를 연 결한 것이다. 내부 구성 요소 모델에서 발생한 출력 이벤트가 현 결합 모델의 출력 이벤트로 변환되어 외부로 전달된다. 내부 연결 관계(IC)는 내부 구성 요소 모델 사이의 입출력을 연결한 것이다. 내부 구성 요소 모델의 출력 이벤 트가 다른 구성요소 모델의 입력으로 전달된다. 선택 함수(SELECT)는 내부 구성 요소 모델 사이의 우선 순위를 결정해주는 함수이다. 만약 두 모델이 같은 시 간에 스케쥴 되어 있다면 두 모델 중 어느 모델부터 실행할 것이지를 정해주는 함수이다. 이하에서는 DEVS 모델을 시뮬레이션하기 위한 시뮬레이터의 구조와 알고리즘에 대해서 간략히 살펴보기로 한다. 도 10은 DEVS 추상화 시뮬레이터의 구조를 나타낸 것이다. DEVS 형식론의 가장 큰 특징 중의 하나가 모델과 시뮬레이터의 분리이다. 도 6을 참조하면, DEVS 모델과 시뮬레 이터의 관계를 보여준다. 도 10의 왼편은 모델의 구성을 보여준다. 최상위 M123 결합 모델이 있고, 이 모델은 다시 원자 모델 M1과 결합 모델 M23, 결합 모델 M23은 다시 원자 모델 M2, M3으로 이루어져 있는 것을 알 수 있다. 이렇듯 모델 구성에서 각 단말은 원자 모델이, 중간 노드는 결합 모델이 위치하는 것을 알 수 있다. 도 10의 오른편의 시뮬레이터도 모델과 동일한 계층 구조를 갖는다. 원자 모델에는 시뮬레이터(Simulator)라고 하는 시뮬레이션 프로세스가, 결합 모델에는 코디네이터(Coordinator)라고 하는 시뮬레이션 프로세스가 위치한 다. DEVS 형식론에서 모델 자체는 수동적인 개체이다. 모델은 기 정해진 집합과 함수들로 이루어져 있을 뿐, 실제적 으로 정해져 있는 함수를 호출하는 것은 모델에 연결되어 있는 시뮬레이션 프로세스이다. 즉, 시뮬레이터와 코 디네이터가 서로 시뮬레이션 메시지를 표 1과 같이 주고 받으면서, 각각 담당하고 있는 모델의 함수 및 정보를참조하여 시뮬레이션을 진행한다. 표 1"}
{"patent_id": "10-2010-0058487", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "이하에서는 시뮬레이터 알고리즘에 대하여 보다 상세하게 살펴보기로 한다. 시뮬레이터는 계층 구조 상의 자신의 상위 코디네이터와 메시지를 주고 받는다. 도 11은 원자 모델에 대응하는 시뮬레이터가 주고 받는 메시지 및 처리 알고리즘을 나타낸 것이다. 시뮬레이터는 상위 코디네이터로부터 (x,t),(*,t)메시지를 받고, (y,t), (done,tN) 메시지를 보낸다 원자 모델은 하나의 상태에서 머물 수 있는 시간이 정해져 있다. 어떤 시각 t에서 어떤 상태 s가 되었다면, 그 상태는 외부 입력이 없다면, t + ta(s)시각까지 머물 수 있게 된다. 이것을 시뮬레이션 하기 위해서 시각 t에서 상태 변환을 할 때, t + ta(s)값을 구해서 미리 스케줄해 놓게 된다. (*,t) 메시지는 미리 스케줄해 놓은 시간(t)이 다 되었음을 의미한다. 시뮬레이터가 이 메시지를 받으면, 출력 이벤트를 발생시키고(y=λ(s)), 발생된 이벤트를 상위 코디네이터에게 전달한다((y,t)). 이 후, 내부 상태 천이 함수로 모델의 상태를 변경한다(s’= δint(s)). 또한, 시간 전진 함수를 이용하여 변경된 상태에서 머물 수 있 는 시간을 구한다. 이 시간을 현재 시간에 더해서 다음 스케줄 시간을 구한 다음, (done,tN)메시지로 상위 코디 네이터에게 보고하게 된다. 이때, tN = t + ta(s’)이 된다. 한 모델에서 발생한 출력 이벤트는 코디네이터를 거치면서 입력 이벤트로 변화되어 전달된다. 입출력을 구분하 기 위해서 x, y의 구분을 두었을 뿐, 두 메시지는 사실상 동일한 것이다. 시뮬레이터가 (x,t)메시지를 받으면 외부 상태 천이 함수를 실행하여 모델의 상태를 변경시킨다(s’=δext(s,e,x)). 앞선 경우와 마찬가지로, 모델의 상태가 변화하였으므로, 바뀐 상태에 대한 스케줄을 다시 하여 상위 코디네이터에 새로운 스케줄을 알려준다 ((done,tN)). 도 12는 결합 모델에 대응하는 코디네이터 알고리즘을 나타낸 것이다. 코디네이터는 자신의 상위 코디네이터로부터 (x,t),(*,t)를 받고, 하위 시뮬레이터 및 코디네이터로부터 (y,t), (done,tN)을 받는다. 또한 상위 코디네이터로(y,t),(done,tN)를 보내고, 하위 코디네이터/시뮬레이터로 (x,t),(*,t)를 보낸다. 코디네이터가 하는 일은 크게 두 가지이다. 출력 이벤트를 적절히 전달하는 일과 하위 모델들의 스케줄 시간을 관리하는 일이다. 코디네이터가 (x,t)를 받으면 외부 모델에서 발생한 출력 메시지가 전달된 것이다. 코디네이터는 받은 (x,t)를 자신의 EIC관계에 의해서 전달되어야 하는 내부 모델에게 전달한다. 내부 모델이 원자 모델이든, 결합 모델이든, 상관없이 (x,t)메시지의 처리가 끝나면 (done,tN)메시지를 돌려주게 되어있다. 코디네이터가 하위 모델로부터 (done,tN)메시지를 받으면, 각 모델들을 시간이 빠른 순서로 정렬한다. 만약 모 든 하위 프로세서가 메시지 처리를 종료하고 (done,tN)메시지를 보냈다면, 코디네이터는 그 중 가장 작은 시간 값(tmin)을 자신의 상위 코디네이터에게 (done,tN=tmin)메시지로 보고한다. 모델 구조 중 최상위에 위치한 코디네이터는 특별히 시간 진행의 역할을 맡는다. 최상위 코디네이터가 하위 모 델로부터 (done,tN)을 받으면, 가장 작은 다음 스케쥴 시간값(tmin)을 가지는 하위 모델에게 (*,tmin)메시지를보내서 시뮬레이션을 진행시키는 역할을 한다. 상위 코디네이터로부터 (*,t)를 받으면, 자신의 하위 모델들 중 가장 작은 다음 스케쥴 시간(tmin)을 가지는 모 델의 프로세서로 (*,t)를 전달한다. 이때, 반드시 t=tmin의 관계가 성립한다. 만약 두 개 이상의 모델이 같은 시 간 최소값을 가지고 있다면, 선택 함수(SELECT)를 사용하여 어떤 모델 프로세서로 (*,t)를 전달할 지 결정한다. (*,t)를 전달받은 모델이 (y,t)를 보내오면, IC, EOC등의 관계에 따라 다른 내부 모델 프로세서로 전달하거나, 자신의 상위 코디네이터에게 전달한다. IC에 따라 다른 내부 모델 프로세서로 전달할 경우, (x,t)로 변환하여 전달하고 전달 받은 모델들이 (done,tN)메시지를 보내는 것을 기다린다. 하위 프로세서가 전달된 (*,t), (x,t) 메시지 처리를 끝내고 (done,tN)을 보내오면 상술한 바와 같이 가장 작은 시간값(tmin)을 자신의 상위 코디네이터에게 (done,tN=tmin)메시지로 보고한다. 도 13은 시뮬레이션 프로세서 간의 메시지 교환의 예를 나타낸 것이다. 원자 모델 M1~M4, 결합 모델 M12, M34, M1234로 이루어져 있고, 원자 모델의 스케줄 시간을 각각 5,6,15,8이라 고 가정하자. 시뮬레이션 순서는 다음과 같이 진행된다. 1. 최상위 코디네이터는 하위 모델 중 가장 빠른 시간이 5임을 알고 있다. 따라서 (*,5)를 C:M12로 전달한다. 2. C:M12는 자신의 하위 모델인 M1의 스케줄 시간이 5임을 알기 때문에 S:M1으로 (*,5)를 전달한다. 3. S:M1은 (*,5)을 받으면 먼저 출력 함수를 실행하여 출력 (y,5)를 발생, C:M12로 전달한다. 이때 y가 out이라 고 하자. 4. C:M12는 연결 관계를 검색하여 (y,5)를 전달한다. M1.out이 M12.out으로 연결되어 있기 때문에 (EOC) C:M1234로 전달한다. 5. C:M1234는 연결 관계를 검색하여 (y,5)를 전달한다. M12.out이 M34.in으로 연결되어 있기 때문에 (IC) C:M34로 전달한다. 이때 (x,5)로 변환하여 전달한다. 6. C:M34는 연결 관계를 검색하여 (x,5)를 전달한다. M34.in이 M4.in으로 연결되어 있기 때문에 (EIC) S:M4로 전달한다. 7. S:M4는 모델의 외부 상태 천이 함수를 실행하여 상태를 변화한 후, 시간 전진 함수를 수행하여 다음 스케줄 시간을 새롭게 구한다. 새로 얻은 값이 10이기 때문에 (done,10)을 보낸다. M3의 스케줄 시간이 15이기 때문에 C:M34는 작은 값인 10을 선택하여 (done,10)을 C:M1234로 보낸다. 8. 한편, S:M1은 모델의 내부 상태 천이 함수를 실행하여 상태를 변화한 후, 시간 전진 함수를 수행하여 다음 스케줄 시간을 구한다. 이때 새로 얻은 값이 9이기 때문에 (done,9)를 보낸다. 9. C:M12는 M1의 9와 M2의 6을 비교하여 작은 값인 6을 C:M1234로 보낸다. 10. C:M1234는 전체 하위 모델의 스케줄 시간 6, 10 중 작은 값이 6이기 때문에 C:M12로 (*,6)을 보내게 되고, 이후 1~9번을 반복하게 된다. M1과 M2의 시작 시간이 모두 5 라고 가정한 경우 SELECT가 필요하게 된다. 1. 최상위 코디네이터는 하위 모델 중 가장 빠른 시간이 5임을 알고 있다. 따라서 (*,5)를 C:M12로 전달한다. 2. C:M12는 자신의 하위 모델인 M1, M2의 스케줄 시간이 모두 5임을 알고 있다. 하지만 두 모델 중 어느 모델에 게 먼저 (*,5)를 전달해야 하는지 정해야 한다. 3. 이 경우, SELECT 함수의 필요성이 생긴다. SELECT는 두 개 이상의 모델이 같은 스케줄 시간을 가질 때, 어떤 모델을 먼저 수행할 것인지 선택하는 역할을 한다. DEVSim++에서는 모델 사이의 우선순위를 정함으로써 SELECT 의 역할을 하도록 하였다. 모델 간 우선 순위가 M1>M2라면, C:M12는 M1으로 (*,5)를 전달한다. 4. 이후는 동일한 순서로 진행된다. DEVS를 이용한 지능형 가상 에이전트 프레임 워크를 구성하는 것은 DEVS 모델과 오브젝트 모델이다. 이 각 모델 은 모델 구현의 전문성과 개발 속도 등을 위하여 분리되어 개발될 수 있다. IVA 프레임워크에 대한 요구사항이 주어질 때, 이것을 분석하여 IVA 프레임워크를 설계한다. 설계한 결과를 토 대로 DEVS를 이용한 이산 사건 모델과 세세한 역할을 수행하는 오브젝트 모델로 구분한다. 주로 DEVS Formalism 을 전문으로 하는 M&S 전문가가 이산 사건 모델을 DEVS Formalism을 이용하여 설계하고 해당 분야를 잘 아는 전 문가가 Object 모델을 UML을 이용하여 구현할 수 있다. 본 발명의 실시예들은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 상기 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등을 단독으로 또는 조합하여 포함할 수 있다. 상기 매체에 기록되는 프로그램 명령은 본 발명을 위하여 특별히 설계 되고 구성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판독 가 능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD- ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체 (magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도 록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다. 상기된 하드웨어 장치는 본 발명의 동작을 수행하기 위해 하나 이상의 소프트웨어 모듈로서 작동하 도록 구성될 수 있으며, 그 역도 마찬가지이다. 이상과 같이 본 발명에서는 구체적인 구성 요소 등과 같은 특정 사항들과 한정된 실시예 및 도면에 의해 설명되 었으나 이는 본 발명의 보다 전반적인 이해를 돕기 위해서 제공된 것일 뿐, 본 발명은 상기의 실시예에 한정되 는 것은 아니며, 본 발명이 속하는 분야에서 통상적인 지식을 가진 자라면 이러한 기재로부터 다양한 수정 및 변형이 가능하다. 따라서, 본 발명의 사상은 설명된 실시예에 국한되어 정해져서는 아니되며, 후술하는 특허청 구범위뿐 아니라 이 특허청구범위와 균등하거나 등가적 변형이 있는 모든 것들은 본 발명 사상의 범주에 속한다 고 할 것이다."}
{"patent_id": "10-2010-0058487", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 일 실시예에 따른 계층적 플러그인 기반 지능형 가상 에이전트 프레임워크의 구성도를 도시한 것이다. 도 2는 본 발명의 일 실시예에 따른 플러그인 기반 계층적 지능형 가상 에이전트 프레임워크에 있어서의 지능형 가상 에이전트 자동 합성 방법을 나타낸 것이다. 도 3은 본 발명의 일 실시예에 따른 지능형 가상 에이전트의 개념도를 도시한 것이다. 도 4는 도 3에 도시된 인식 블록을 보다 상세하게 나타낸 것이다. 도 5는 도 3에 도시된 판단 블록을 보다 상세하게 나타낸 것이다. 도 6a는 판단 블록이 포함하는 각 모듈들이 실행되는 순서의 일 실시예를 나타낸 것이다. 도 6b는 판단 블록이 포함하는 각 모듈들이 실행되는 순서의 다른 실시예를 나타낸 것이다. 도 7은 판단 블록 내의 학습 모듈의 개념도를 도시한 것이다. 도 8은 도 3에 도시된 행위 블록을 보다 상세하게 나타낸 것이다. 도 9는 도 3에 도시된 스토리 텔링 블록을 보다 상세하게 나타낸 것이다. 도 10은 DEVS 추상화 시뮬레이터의 구조를 나타낸 것이다. 도 11은 원자 모델에 대응하는 시뮬레이터가 주고 받는 메시지 및 처리 알고리즘을 나타낸 것이다. 도 12는 결합 모델에 대응하는 코디네이터 알고리즘을 나타낸 것이다. 도 13은 시뮬레이션 프로세서 간의 메시지 교환의 예를 나타낸 것이다."}
