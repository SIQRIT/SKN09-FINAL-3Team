{"patent_id": "10-2021-0183355", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0094308", "출원번호": "10-2021-0183355", "발명의 명칭": "저장 장치, 그것을 포함하는 호스트 시스템, 및 그것의 동작 방법", "출원인": "삼성전자주식회사", "발명자": "엄준용"}}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "제 1 로그를 생성하는 호스트 장치;적어도 하나의 제 2 로그를 생성하는 저장 장치; 및 상기 제 1 로그를 저장하고, 상기 제 1 로그 및 상기 적어도 하나의 제 2 로그에 대응하는 복합 로그들을 저장하는 공유 메모리를 포함하고,상기 저장 장치는,상기 공유 메모리로부터 상기 제 1 로그를 읽고,상기 제 1 로그 및 상기 적어도 하나의 제 2 로그에 타임스탬프와 로그 타입 정보를 추가함으로써 상기 복합 로그들을 생성하고, 상기 복합 로그들을 상기 공유 메모리에 쓰는 것을 특징으로 하는 호스트 시스템."}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 호스트 장치는 상기 제 1 로그를 생성한 후에 상기 공유 메모리의 호스트 로그 영역에 상기 제 1 로그를쓰는 것을 특징으로 하는 호스트 시스템."}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,상기 저장 장치는 레지스터 폴링 방식 혹은 인터럽트 방식에 의해 상기 공유 메모리에 상기 제 1 로그가 쓰여진것을 인지하는 라이브 디버그 유닛을 포함하는 호스트 시스템."}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 3 항에 있어서, 상기 라이브 디버그 유닛은 상기 공유 메모리에 상기 제 1 로그가 쓰여진 후, 상기 공유 메모리로부터 상기 제1 로그를 읽는 것을 특징으로 하는 호스트 시스템."}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 3 항에 있어서,상기 라이브 디버그 유닛은 상기 제 1 로그 및 상기 적어도 하나의 제 2 로그를 통일된 포맷으로 동기화함으로써, 상기 복합 로그들을 생성하고, 상기 생성된 복합 로그들을 상기 공유 메모리의 복합 로그 영역에 쓰는 것을특징으로 하는 호스트 시스템."}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1 항에 있어서,상기 적어도 하나의 제 2 로그는, 적어도 하나의 호스트 인터페이스 회로에서 생성된 인터페이스 로그와 프로세서에서 생성된 디바이스 로그를 포함하는 호스트 시스템."}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서,상기 타임스탬프는 상기 저장 장치의 타임스탬프 혹은 셋 피쳐(set feature)을 통해 상기 호스트 장치로부터 전공개특허 10-2023-0094308-3-달받은 타임스탬프 인 것을 특징으로 하는 호스트 시스템."}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1 항에 있어서,상기 저장 장치는 상기 공유 메모리의 복합 로그 영역에 대응하는 버퍼가 가득 찼는 지를 판별하고, 상기 버퍼가 가득 찼을 때 상기 호스트 장치에 버퍼 풀 정보를 공지하는 것을 특징으로 하는 호스트 시스템."}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "저장 장치의 동작 방법에 있어서,호스트 장치의 호스트 로그 생성을 감지하는 단계;상기 호스트 로그 생성을 감지할 때, 공유 메모리로부터 상기 호스트 로그를 읽는 단계;상기 저장 장치 내부에서 생성하는 디바이스 로그들을 수집하는 단계;타임스탬프를 이용하여 상기 호스트 로그 및 상기 디바이스 로그들의 각각에 대응하는 복합 로그를 생성하는 단계; 및상기 복합 로그를 상기 공유 메모리에 쓰는 단계를 포함하는 방법."}
{"patent_id": "10-2021-0183355", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "적어도 하나의 비휘발성 메모리 장치; 및상기 적어도 하나의 비휘발성 메모리 장치를 제어하는 제어기를 포함하고,상기 제어기는 전반적인 동작을 제어하고, 라이브 디버그 유닛을 실행하는 적어도 하나의 프로세서를 포함하고,상기 라이브 디버그 유닛은, 외부의 호스트 장치의 제 1 로그 및 내부의 장치들의 제 2 로그들을 수집하고, 상기 수집된 로그들에 타임스탬프 및 로그 타입을 추가하고, 상기 추가된 로그들을 시간 순으로 정렬함으로써 복합 로그들을 생성하고, 상기 생성된 복합 로그들을 공유 메모리에 저장하는 것을 특징으로 하는 저장 장치."}
{"patent_id": "10-2021-0183355", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명에 따른 호스트 시스템은, 제 1 로그를 생성하는 호스트 장치, 적어도 하나의 제 2 로그를 생성하는 저장 장치, 및 상기 제 1 로그를 저장하고, 상기 제 1 로그 및 상기 적어도 하나의 제 2 로그에 대응하는 복합 로그들 을 저장하는 공유 메모리를 포함하고, 상기 저장 장치는, 상기 공유 메모리로부터 상기 제 1 로그를 읽고, 상기 제 1 로그 및 상기 적어도 하나의 제 2 로그에 타임스탬프와 로그 타입 정보를 추가함으로써 상기 복합 로그들을 생성하고, 및 상기 복합 로그들을 상기 공유 메모리에 쓰는 것을 특징으로 한다."}
{"patent_id": "10-2021-0183355", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 저장 장치, 그것을 포함하는 호스트 시스템 및 그것의 동작 방법에 관한 것이다."}
{"patent_id": "10-2021-0183355", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "일반적으로, 호스트 시스템은 호스트 장치(host device) 및 저장 장치(storage device)를 포함한다. 저장 장치 는 메모리 제어기와 메모리 장치를 포함한다. 호스트 시스템 내에서 호스트 장치와 저장 장치는 UFS(Universal Flash Storage), SATA(Serial Advanced Technology Attachment), SCSI(Small Computer Small Interface), SAS(Serial Attached SCSI), eMMC(embedded Multi Media Card) 등과 같은 다양한 인터페이스 표준을 통해 서로 연결된다. 호스트 장치는 저장 장치와 별개로 내부에 호스트 메모리를 포함한다. 최근에는 호스트 메모리를 저 장 장치의 캐시 메모리로 활용하는 기술이 연구되고 있다."}
{"patent_id": "10-2021-0183355", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 디버깅을 효율적으로 수행하는 저장 장치, 그것을 포함하는 호스트 시스템 및 그것의 동작 방법을 제 공하는 데 있다."}
{"patent_id": "10-2021-0183355", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 실시 예에 따른 실시 예에 따른 호스트 시스템은, 제 1 로그를 생성하는 호스트 장치; 적어도 하나의 제 2 로그를 생성하는 저장 장치; 및 상기 제 1 로그를 저장하고, 상기 제 1 로그 및 상기 적어도 하나의 제 2 로그에 대응하는 복합 로그들을 저장하는 공유 메모리를 포함하고, 상기 저장 장치는, 상기 공유 메모리로부터 상기 제 1 로그를 읽고, 상기 제 1 로그 및 상기 적어도 하나의 제 2 로그에 타임스탬프와 로그 타입 정보를 추 가함으로써 상기 복합 로그들을 생성하고, 및 상기 복합 로그들을 상기 공유 메모리에 쓰는 것을 특징으로 한다. 본 발명의 실시 예에 따른 저장 장치의 동작 방법은, 호스트 장치의 호스트 로그 생성을 감지하는 단계; 상기 호스트 로그 생성을 감지할 때, 공유 메모리로부터 상기 호스트 로그를 읽는 단계; 상기 저장 장치 내부에서 생 성하는 디바이스 로그들을 수집하는 단계; 타임스탬프를 이용하여 상기 호스트 로그 및 상기 디바이스 로그들의 각각에 대응하는 복합 로그를 생성하는 단계; 및 상기 복합 로그를 상기 공유 메모리에 쓰는 단계를 포함할 수 있다. 본 발명의 실시 예에 따른 저장 장치는, 적어도 하나의 비휘발성 메모리 장치; 및 상기 적어도 하나의 비휘발성 메모리 장치를 제어하는 제어기를 포함하고, 상기 제어기는 전반적인 동작을 제어하고, 라이브 디버그 유닛을 실행하는 적어도 하나의 프로세서를 포함하고, 상기 라이브 디버그 유닛은, 외부의 호스트 장치의 제 1 로그 및 내부의 장치들의 제 2 로그들을 수집하고, 상기 수집된 로그들에 타임스탬프 및 로그 타입을 추가하고, 상기 추 가된 로그들을 시간 순으로 정렬함으로써 복합 로그들을 생성하고, 상기 생성된 복합 로그들을 공유 메모리에 저장하는 것을 특징으로 한다."}
{"patent_id": "10-2021-0183355", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 실시 예에 따른 저장 장치, 그것을 포함하는 호스트 시스템, 및 그것의 동작 방법은, 로그 정보를 통 합 관리하기 위한 메모리를 공유함으로써, 디버깅의 시간을 줄이고, 효과적으로 디버깅을 수행할 수 있다."}
{"patent_id": "10-2021-0183355", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "아래에서는 도면들을 이용하여 본 발명의 기술 분야에서 통상의 지식을 가진 자가 용이하게 실시 할 수 있을 정 도로 본 발명의 내용을 명확하고 상세하게 기재할 것이다. 일반적으로, 데이터 센터용 저장 장치는, 제품 출하 후 엔드 유저(End User)의 제품 사용에 따른 이슈 생성할 때 분석이 어려운 경우가 많다. 데이터 센터의 특성상 여러 개의 장치가 장착되어 있다. 이러한 이슈는 서버의 응용 혹은 커널, BIOS 설정 등 호스트 장치에 의해 생성 할 수도 있고, 저장 장치의 잘못된 동작에 의해서도 생 성 할 수 있다. 따라서 문제를 정확하게 분석하기 위해서 호스트 장치와 저장 장치의 상호 작용이 복합적으로 확인되어야 한다. 하지만, 현존하는 로깅 정보는 호스트 장치와 저장 장치의 각각에 남기고 있다. 또한, 각각의 로그는 다른 포맷(Format)으로 구성 되고, 각각의 시간을 기준으로 하기 때문에 각각의 동작만이 확인되고 있다. 게다가, 호스트 장치와 저장 장치 사이의 상호작용을 확인하기 위해 로그 정보를 맞추는 것은 추가적인 작업이 필요하다. 본 발명의 실시 예에 따른 호스트 시스템 및 그것의 로그 정보 관리 방식은, 공유 메모리를 이용하여 호스트 장 치와 저장 장치의 디버깅(debugging) 정보를 동기화함으로써 로깅(logging)할 수 있다. 호스트 장치와 저장 장 치는 디버깅 정보를 저장하는 공유 메모리를 공유할 수 있다. 저장 장치는 공유 메모리를 관리하는 라이브 디버 그 유닛(live debug unit)을 구비할 수 있다. 여기서 라이브 디버깅 유닛은 호스트 시스템의 디버깅 로그 (debugging log)와 저장 장치의 디버깅 로그를 관리하도록 공유 메모리를 제어할 수 있다. 본 발명은 공유 메모 리에 저장된 디버깅 정보를 이용하여 QoS(Quality of Service) 불량 등과 같은 호스트 장치와 저장 장치 사이의 동작을 종합적으로 분석 가능하게 한다. 도 1은 본 발명의 디버깅 정보를 관리하는 개념을 설명하기 위한 호스트 시스템을 예시적으로 보여주는 도면 이다. 도 1을 참조하면, 호스트 시스템은 호스트 장치, 저장 장치, 및 공유 메모리를 포함할 수 있다. 공유 메모리는 호스트 장치 및 저장 장치의 각각의 디버깅 정보를 저장하도록 구현될 수 있다. 예 를 들어, 공유 메모리는 호스트 장치의 제 1 로그 정보(LOG_HST)를 저장하거나, 저장 장치의 제 2 로그 정보(LOG_DVC)를 저장할 수 있다. 여기서 제 1 로그 정보(LOG_HST)는 호스트 장치를 구동하는 데 생성 하는 시스템 로그, 커널 로그 등을 포함할 수 있다. 또한, 제 2 로그 정보(LOG_DVC)는 저장 장치를 구동하 는데 생성하는 디바이스 로그, 호스트 인터페이스 로그(예를 들어, PCIe 로그, NVMe 로그) 등을 포함할 수 있다. 실시 예에 있어서, 제 1 로그 정보(LOG_HST)와 제 2 로그 정보(LOG_DVC)는 동일한 로그 포맷(log format)으로 공유 메모리에 저장될 수 있다. 본 발명의 실시 예에 따른 호스트 시스템의 디버깅 정보 관리 방식은, 공유 메모리에 디버깅 정보를 저 장함으로써, 인터페이스의 오버헤드를 최소화시키고, 로그 동기화 문제를 해결할 수 있다. 도 2는 본 발명의 실시 예에 따른 호스트 시스템을 예시적으로 보여주는 도면이다. 도 2을 참조하면, 호스 트 시스템은 호스트 장치 및 저장 장치를 포함할 수 있다. 호스트 장치는 적어도 하나의 프로세서를 포함할 수 있다. 적어도 하나의 프로세서는 호스트 장치의 전반적인 동작을 제어하도록 구현될 수 있다. 예를 들어, 프로세서는, CPU(Central Processing Unit), 어플리케 이션 프로세서, 모뎀 통합 어플리케이션 프로세서, SoC, 집적 회로 등 일 수 있다. 프로세서는 운영 체제를 실 행하도록 구현될 수 있다. 운영 체제는 파일 관리를 위한 파일 시스템(file system)을 포함할 수 있다. 예를 들 어, 파일 시스템은 FAT(File Allocation Table), FAT32, NTFS(NT File System), HFS(Hierarchical File System), JSF2(Journaled File System2), XFS, ODS-5(On-Disk Structure-5), UDF, ZFS, UFS(Unix File System), ext2, ext3, ext4, ReiserFS, Reiser4, ISO 9660, Gnome VFS, BFS, 혹은 WinFS 등과 같은 다양한 파 일 시스템들 중에서 적어도 어느 하나를 포함할 수 있다. 공유 메모리는 호스트 장치의 호스트 로그(예를 들어, 제 1 로그 정보(Log_HST))를 저장하거나, 저장 장치의 복합 로그(예를 들어, 제 2 로그 정보(Log_DVC)를 저장하도록 구현될 수 있다. 여기서 복합 로그는 장치 로그, 호스트 인터페이스 로그 등을 포함할 수 있다. 또한, 공유 메모리는 호스트 로그를 저장하는 호스트 로그 영역과 복합 로그를 저장하는 복합 로그 영역를 포함할 수 있다. 호스트 로그 영역은 커널 로그, 시스템 로그 등과 같이 호스트 장치의 로그 정보를 등록하는 영역이 다. 호스트 장치는 호스트 로그 영역에 로그를 쓰면서 동시에 테일 포인터(tail pointer)를 업데이트 할 수 있다. 이로써, 저장 장치의 라이브 디버그 유닛은 이미 등록된 로그와 새롭게 등록된 로그를 구분할 수 있다. 호스트 장치가 호스트 로그를 호스트 로그 영역에 등록할 때, 라이브 디버그 유닛 은 이러한 호스트 로그 등록 사실을 실시간으로 인지할 수 있다. 예를 들어, 라이브 디버그 유닛은SFR(Special Function Resister) 폴링(polling) 방식, NVMe doorbell(도어벨) 인터페이스 방식, 인터럽트 방식 등과 같은 방식으로 호스트 로그 등록을 인지할 수 있다. 또한, 호스트 장치와 저장 장치가 직접적으 로 공유 메모리의 호스트 로그 영역에 접근/공유함으로써 호스트 로그를 저장 장치에 전달하는 데 필요한 오버헤드가 최소화될 수 있다. 복합 로그 영역은 호스트 로그와 PCIe 로그, NVMe 로그, 디바이스 로그 등이 종합적으로 쓰여지는 영역이 다. 라이브 디버그 유닛에 의해 복합 로그 영역에 복합 로그가 쓰여질 수 있다. 호스트 장치와 저장 장치는 복합 로그 영역을 읽음으로써 디버깅을 할 수 있다. 한편, 복합 로그 영역이 가득 찰 때, 공유 메모리는 이러한 사실을 호스트 장치에 공지하도록 구현될 수 있다. 실시 예에 있어서, 공유 메모리는 SRAM(Static Random Access Memory), DRAM(Dynamic RAM), SDRAM(Synchronous RAM) 등과 같은 휘발성 메모리, 혹은 PRAM(Phase-change RAM), MRAM(Magneto-resistive RAM), ReRAM(Resistive RAM), FRAM(Ferro-electric RAM) 등과 같은 비휘발성 메모리로 구현될 수 있다. 한편, 도 2에 도시된 공유 메모리는 호스트 장치의 외부에 배치되고 있다. 하지만, 본 발명이 여기에 제한되지 않을 것이다. 공유 메모리는 호스트 장치의 내부의 구성이거나, 저장 장치의 내부 구 성일 수도 있다. 저장 장치는 적어도 하나의 비휘발성 메모리 장치(NVM(s), 210) 및 제어기를 포함할 수 있다. 비휘발성 메모리 장치(NVM(s), 210)는 낸드 플래시 메모리(NAND Flash Memory), 수직형 낸드 플래시 메모리 (Vertical NAND; VNAND), 노아 플래시 메모리(NOR Flash Memory), 저항성 램(Resistive Random Access Memory: RRAM), 상변화 메모리(Phase-Change Memory: PRAM), 자기저항 메모리(Magnetoresistive Random Access Memory: MRAM), 강유전체 메모리(Ferroelectric Random Access Memory: FRAM), 스핀주입 자화반전 메모리(Spin Transfer Torque Random Access Memory: STT-RAM) 등이 될 수 있다. 비휘발성 메모리 장치는 워드라인들 과 비트라인들에 연결된 복수의 메모리 셀들을 갖는 복수의 메모리 블록들을 포함할 수 있다. 여기서 복수의 메 모리 셀들의 각각은 적어도 하나의 비트를 저장할 수 있다. 제어기는 비휘발성 메모리 장치를 제어하도록 구현될 수 있다. 예를 들어, 제어기는 호스트 장 치로부터 입출력 요청(읽기 요청 혹은 쓰기 요청)을 수신하여, 비휘발성 메모리 장치에 대응하는 입 출력 동작(읽기 동작 혹은 프로그램 동작)을 수행할 수 있다. 제어기는 적어도 하나의 프로세서 및 라이브 디버그 유닛을 포함할 수 있다. 적어도 하나의 프 로세서는 저장 장치의 전반적인 동작을 제어하도록 구현될 수 있다. 라이브 디버그 유닛은, 호스트 시스템에서 생성하는 로그들을 수집하도록 구현될 수 있다. 예를 들어, 라이브 디버그 유닛은 호스트 로그 생성시 공유 메모리로부터 호스트 로그를 읽을 수 있다. 또한, 라 이브 디버그 유닛은 저장 장치의 내부에서 생성하는 로그들(디바이스 로그, PCIe 로그, NVMe 로그 등)을 수집할 수 있다. 도 2에 도시된 바와 같이, 디바이스 로그는 프로세서에서 생성되고, PCIe 로그는 PCIe 인터페이스 회로에서 생성되고, NVMe 로그는 NVMe 인터페이스 회로에서 생성될 수 있다. 또한, 라이브 디버그 유닛은 수집된 로그들에 타임스탬프(timestamp), 로그 타입(log type) 등 추가하고, 추가된 로그들을 시간 순서로 정렬함으로써 복합 로그들을 생성하고, 복합 로그들을 공유 메모리의 복합 로그 영역에 저장할 수 있다. 여기서 타임스탬프는 호스트 장치의 타임스탬프 혹은 저장 장치의 타임스탬프일 수 있다. 실시 예에 있어서, 호스트 장치의 타임스탬프는 셋 피쳐(Set Feature) 커맨드를 통 하여 호스트 장치로부터 전송될 수 있다. 정리하면, 라이브 디버그 유닛은 호스트 장치와 저장 장치의 로그들을 수집하고, 수집된 로그들 에 디버깅 동작에 이용할 수 있는 정보를 추가하고, 추가된 로그들을 시간 순으로 정리하고, 정리된 로그들을 종합적인 로그로 구성하여 관리할 수 있다. 실시 예에 있어서, 라이브 디버그 유닛은 하드웨어적으로, 소프트웨어적으로, 혹은 펌웨어적으로 구현될 수 있다. 일반적인 호스트 시스템은 호스트 장치와 저장 장치의 각각에 대응하는 로그 정보를 남긴다. 이 때문에, 호스트 장치와 저장 장치 사이의 상호 작용을 파악하기 위해서, 각각의 디버깅 정보를 맞추기 위해서 많은 시간과 노력이 요구되고 있다. 게다가, 로그를 잘못 추출 한 경우, 이슈를 다시 재현하고 로그를 추출하는 과정이 반복되어 야 한다. 또한, 호스트 장치와 저장 장치 사이의 상호 작용을 파악하기 위해, 인터페이스(예를 들어, PCIe)를 모니터링 하는 물리적인 디버깅 툴이 직접 연결되어야 한다. 이러한 물리적인 디버깅 툴은 로그를 추출 하고, 추출된 로그를 호스트 장치와 저장 장치의 각각에서 추출한 로그와 비교함으로써, 디버깅 동작을 수행하고 있다. 이러한 방식은 호스트 장치와 저장 장치 사이의 상호작용에 따른 정확한 이슈를 파악하는데 어려움이 많 다. 본 발명의 실시 예에 따른 호스트 시스템은, 호스트 시스템 내부의 여러 장치들(100, 200)의 동작들을 복합적으로 로깅하고, 수집된 로그들을 타임라인 기반으로 정리하여 공유 메모리에 저장함으로써, 공유 메 모리에 저장된 복합 로그들을 분석함으로써, 간단하게 종합적인 디버깅 동작을 수행할 수 있다. 즉, 본 발 명의 호스트 시스템은 공유 메모리에 저장된 통합된 로그 정보를 이용하여 종합적으로 이슈 분석을 가 능하게 한다. 도 3은 본 발명의 실시 예에 따른 호스트 시스템에서 통합 로그의 관리 메커니즘을 예시적으로 보여주는 도면이 다. 도 3을 참조하면, 통합 로그의 관리 메커니즘은 다음과 같이 진행될 수 있다. 호스트 장치는 호스트 장치의 로그(Log_1)를 공유 메모리의 호스트 로그 영역에 쓸 수 있 다(S1). 새로운 호스트 로그(Log_1)가 공유 메모리에 쓰여질 때, 라이브 디버그 유닛은 이것을 즉시 인지할 수 있다(S1). 이러한 인지 방식은, 예를 들어, 레지스터 폴링(Register Polling) 방식, 인터럽트 (Interrupt) 방식일 수 있다. 이후에, 라이브 디버그 유닛은 공유 메모리로부터 호스트 로그(Log_1) 를 읽어 올 수 있다(S3). 저장 장치의 각각의 모듈들(프로세서, PCIe 인터페이스 모듈, NVMe 인터페이스 모듈 등)은 대응하는 로그들(Log_2, Log_3, Log_4)를 라이브 디버그 유닛로 전달할 수 있다(S4). 라이브 디버그 유닛은 수집된 로그들(Log_1, Log_2, Log_3, Log_4)을 통합 포맷으로 동기화하고, 동기화된 로그들을 공유 메모리(12 0)의 복합 로그 영역에 쓸 수 있다(S5). 여기서 통합 포맷으로 동기화할 때, 타임스탬프가 이용될 수 있다. 이러한 타임스탬프 값은 저장 장치의 타임스탬프 혹은 셋 피쳐(Set Feature)를 통해 전달 받은 호스 트 장치의 타임스탬프를 기준으로 구성될 수 있다. 실시 예에 있어서, 복합 로그는 로그 타입, 타임스탬프, 로그의 조합으로 구성될 수 있다. 예를 들어, 제 1 로그의 복합 로그는 [Host][00:00:05]Log_1으로 구성되고, 제 2 로그의 복합 로그는 [PCIe][00:00:13]Log_2, 제 3 로그의 복합 로그는 [NVMe][00:00:18]Log_3, 제 4 로그의 복합 로그는 [Device][00:00:33]Log_4로 구성될 수 있다. 한편, 공유 메모리는 복합 로그 영역의 버퍼가 가득 찬 경우 호스트 장치에게 이러한 사실을 공 지할 수 있다(S6). 호스트 장치는 로그를 저장하는 동안 생성하는 로그를 더블 버퍼링(Double Buffering) 방식으로 처리할 수 있다. 여기서 공지 방식은 AER(Asynchronous Event Request) 방식, sideband 인터페이스 방식 등등 이용 가능하다. 호스트 장치는 복합 로그를 파일(nvme_log)로 저장할 수 있다(S7). 도 4는 본 발명의 실시 예에 따른 저장 장치의 라이브 디버그 유닛의 동작을 예시적으로 보여주는 흐 름도이다. 도 1 내지 도 4를 참조하면, 라이브 디버그 유닛은 다음과 같이 동작할 수 있다. 라이브 디버그 유닛은 실시간으로 호스트 로그를 감지할 수 있다(S110). 호스트 로그가 감지될 때, 라이브 디버그 유닛은 공유 메모리로부터 호스트 로그를 읽어 올 수 있다(S120). 라이브 디버그 유닛은 저장 장치 내부의 모듈들(221, 228, 229)의 각각으로부터 로그를 수집할 수 있다(S130). 라이브 디버그 유 닛은 타임스탬프를 이용하여 수집된 로그에 대응하는 복합 로그를 생성할 수 있다(S140). 라이브 디버그 유닛은 복합 로그를 공유 메모리에 쓸 수 있다(S150). 도 5는 본 발명의 실시 예에 따른 공유 메모리의 동작을 예시적으로 보여주는 흐름도이다. 도 1 내지 도 5 를 참조하면, 공유 메모리는 다음과 같이 동작할 수 있다. 공유 메모리는 호스트 장치로부터 새로운 호스트 로그를 수신할 수 있다(S210). 여기서 수신된 호스 트 로그는 호스트 장치의 쓰기 요청에 의해 전달될 수 있다. 공유 메모리는 저장 장치로부터 복 합 로그를 수신할 수 있다(S220). 여기서 복합 로그는 호스트/저장 장치의 통합 로그일 수 있다. 공유 메모리 는 복합 로그를 저장하는 버퍼 공간이 가득 찼는 지를 판별할 수 있다(S230). 만일, 버퍼 공간이 가득 찼 다면, 공유 메모리는 버퍼 풀 조건을 호스트 장치에 공지할 수 있다(S240). 도 6은 본 발명의 실시 예에 따른 호스트 시스템의 로그 관리 동작을 예시적으로 보여주는 래더다이어그램 이다. 도 1 내지 도 6를 참조하면, 호스트 시스템의 로그 관리 동작은 다음과 같이 진행될 수 있다. 호스트 장치와 저장 장치는 공유 메모리를 설정할 수 있다. 여기서 공유 메모리는 호스트 장치의 일부 구성이거나 저장 장치의 일부 구성일 수 있다. 실시 예에 있어서, 공유 메모리는 호스트 로그 영역과 복합 로그 영역으로 분리 설정될 수 있다. 호스트 장치는 공유 메모리의 호스트 로그 영역에 호스트Host의 장치의 로그를 쓰고, 동시 에 호스트 로그 영역의 테일 포인터(Tail Pointer)를 업데이트할 수 있다(S10). 라이브 디버그 유닛은 호스트 로그 영역의 테일 포인터를 폴링(polling)하고 있다(S20). 테일 포인터 의 폴링 업데이트를 인지하면, 라이브 디버그 유닛는 호스트 장치가 새롭게 작성한 로그를 읽고 (S21), 디버그 동작에서 로그를 쉽게 확인 가능하도록 타임스템프, 로그 타입 등의 정보를 읽혀진 로그에 추가 함으로써 복합 로그를 생성하고, 공유 메모리의 헤드 포인터를 업데이트 할 수 있다(S22). 라이브 디버그 유닛은 생성된 복합 로그를 공유 메모리의 복합 로그 영역에 쓸 수 있다(S23). 라이브 디버그 유닛은 디바이스 로그를 수집할 수 있다. 즉, 디바이스 로그는 라이브 디버그 유닛에 쓰여질 수 있다(S30). 라이브 디버그 유닛은 타임스템프, 로그 타입 등의 정보를 수집된 디바이스 로그에 추가함으로써 복합 로그를 생성하고, 생성된 복합 로그를 공유 메모리의 복합 로그 영역에 쓸 수 있 다(S31). 라이브 디버그 유닛은 공유 메모리의 복합 로그 영역이 가득 찼는 지를 체크할 수 있다(S40). 만일, 복합 로그 영역이 가득 찰 경우, 저장 장치는 호스트 장치 쪽으로 복합 로그 영역이 가득 찼다는 정보를 NVMe의 AER (Asynchronous Event Request)를 통해 알려줄 수 있다(S41). 호스트 장치는 복합 로그 영역에서 복합 로그를 읽으면서 RAE (Retain Asynchronous Event) 비트를 클리어(clear)함으로써 라이브 디버그 유닛가 새로운 로그를 쓸 수 있도록 한다(S42). 호스트 장치는 복합 로그 영역에서 읽혀진 로그 정보를 파일로 저장함으로써 관리할 수 있다. 실시 예에 있어서, 복합 로그 영역이 가득 찬 상황에서, 호스트 장치가 대응하는 영역을 읽지 못할 경우, 초기 설정에 따라 라이브 디버그 유닛은 이후 생성하는 로그를 저장하지 않거나, 기존 로그를 덮어 쓸 수 있다. 한편, 호스트 장치는 저장해 두었던 복합 로그 정보를 읽고, 복합 로그 정보를 디버깅에 이용할 수 있다. 이 때, 호스트 장치는 로그 타입 등의 정보로 필터링 함으로써 이용될 수 있다. 도 7은 본 발명의 실시 예에 따른 저장 장치를 예시적으로 보여주는 도면이다. 도 7를 참조하면, 저장 장 치는 적어도 하나의 비휘발성 메모리 장치 및 그것을 제어하는 제어기를 포함할 수 있다. 제어기는 호스트 인터페이스 회로, 휘발성 메모리 인터페이스 회로, 적어도 하나의 프로세서 , 버퍼 메모리, 에러 정정 회로, 플래시 변환 계층 매니저, 패킷 매니저, 및 암호 장 치를 포함할 수 있다. 호스트 인터페이스 회로는 호스트와 패킷(packet)을 송수신하도록 구현될 수 있다. 호스트로부터 호스트 인터페이스 회로로 전송되는 패킷은 커맨드(command) 혹은 비휘발성 메모리 장치에 쓰여질 데이터를 포함할 수 있다. 호스트 인터페이스 회로로부터 호스트로 전송되는 패킷은 커맨드에 대한 응답(response) 혹은 비휘발성 메모리 장치로부터 읽혀진 데이터를 포함할 수 있다. 호스트 인터페이스 회로는 HPB(Host Performance Buffer) 기능을 지원하도록 구현될 수 있다. 실시 예에 있어서, 호스트 인터페이스 회로는 UFS(Universal Flash Storage), eMMC(embedded Multi Media Card), SATA(Serial Advanced Technology Attachment) 버스, SCSI(Small Computer Small Interface) 버스, NVMe(Non-Volatile Memory Express) 버스, 혹은 SAS(Serial Attached SCSI) 버스 등을 통하여 호스트 장치 에 연결될 수 있다. 메모리 인터페이스 회로는 비휘발성 메모리 장치에 쓰여질 데이터를 비휘발성 메모리 장치로 송 신하거나, 비휘발성 메모리 장치로부터 읽혀진 데이터를 수신할 수 있다. 이러한 메모리 인터페이스 회로 는 JDEC(Joint Electron Device Engineering Council) 혹은 ONFI(Open NAND Flash Interface)와 같은 표 준 규약을 준수하도록 구현될 수 있다. 적어도 하나의 프로세서는 저장 장치의 전반적인 동작을 제어하도록 구현될 수 있다. 적어도 하나의 프로세서는 도 1 내지 도 6에서 설명된 라이브 디버그 유닛(LDU)을 구동하도록 구현될 수 있다. 라이브 디 버그 유닛(LDU)은 호스트/저장 장치의 로그를 수집하고, 통합 로그를 생성하고, 통합 로그를 공유 메모리에 저 장하도록 구현될 수 있다. 버퍼 메모리는 휘발성 메모리(예를 들어, SRAM(Static Random Access Memory), DRAM(Dynamic RAM), SDRAM(Synchronous RAM) 등) 혹은 비휘발성 메모리 (플래시 메모리, PRAM(Phase-change RAM), MRAM(Magneto- resistive RAM), ReRAM(Resistive RAM), FRAM(Ferro-electric RAM) 등)로 구현될 수 있다. ECC 회로는 프로그램 동작시 에러 정정 코드(error correction code)를 생성하고, 리드 동작시 에러 정정 코드를 이용하여 데이터(DATA)의 복구하도록 구현될 수 있다. 즉, ECC 회로는 비휘발성 메모리 장치 로부터 수신된 데이터(DATA)의 페일 비트(fail bit) 혹은 에러 비트(error bit)를 정정하기 위한 에러 정정 코 드(error correction code; ECC)를 생성할 수 있다. ECC 회로는 비휘발성 메모리 장치로 제공되는 데이터의 에러 정정 인코딩을 수행함으로써, 패리티(parity) 비트가 부가된 데이터(DATA)를 형성할 수 있다. 패 리티 비트는 비휘발성 메모리 장치에 저장될 수 있다. 또한, ECC 회로는 비휘발성 메모리 장치로부터 출력된 데이터(DATA)에 대하여 에러 정정 디코딩을 수 행할 수 있다. ECC 회로는 패리티를 사용하여 에러를 정정할 수 있다. ECC 회로는 LDPC(low density parity check) code, BCH code, turbo code, 리드-솔로몬 코드(Reed-Solomon code), convolution code, RSC(Recursive Systematic Code), TCM(Trellis-coded Modulation), BCM(Block Coded Modulation) 등의 코디드 모듈레이션(Coded Modulation)을 사용하여 에러를 정정할 수 있다. 한편, 에러 정정 회로에서 에러 정정이 불가능할 때, 리드 리트라이(read retry) 동작이 수행될 수 있다. 플래시 변환 계층 매니저는 어드레스 맵핑, 웨어-레벨링, 가비지 콜렉션과 같은 여러 기능을 수행할 수 있 다. 어드레스 맵핑 동작은 호스트로부터 수신한 논리 어드레스를, 비휘발성 메모리 장치 내에 데이터를 실 제로 저장하는 데 사용되는 물리 어드레스로 바꾸는 동작이다. 웨어-레벨링은 비휘발성 메모리 장치 내의 블록들이 균일하게 사용되도록 하여 특정 블록의 과도한 열화를 방지하기 위한 기술로, 예시적으로 물리 블록들 의 이레이즈 카운트들을 밸런싱하는 펌웨어 기술을 통해 구현될 수 있다. 가비지 콜렉션은, 블록의 유효 데이터 를 새 블록에 복사한 후 기존 블록을 이레이즈 하는 방식을 통해 비휘발성 메모리 장치 내에서 사용 가능 한 용량을 확보하기 위한 기술이다. 패킷 매니저는 호스트와 협의된 인터페이스의 프로토콜에 따른 패킷을 생성하거나, 호스트로부터 수신된 패킷으로부터 각종 정보를 파싱 할 수 있다. 또한, 버퍼 메모리는 비휘발성 메모리 장치에 기록될 데 이터 혹은 비휘발성 메모리 장치로부터 읽혀진 데이터를 임시로 저장할 수 있다. 실시 예에 있어서, 버퍼 메모리는 제어기 내에 구비되는 구성일 수 있다. 다른 실시 예에 있어서, 버퍼 메모리는 제어기 의 외부에 배치될 수도 있다. 암호 장치는, 저장 제어기로 입력되는 데이터에 대한 암호화(encryption) 동작과 복호화(decryption) 동작 중에서 적어도 하나를, 대칭 키 알고리즘(symmetric-key algorithm)를 이용하여 수행할 수 있다. 암호 장 치는 AES(Advanced Encryption Standard) 알고리즘을 이용하여 데이터의 암호화 및 복호화를 수행할 수 있다. 암호 장치는 암호화 모듈 및 복호화 모듈을 포함할 수 있다. 실시 예에 있어서, 암호 장치는 하드웨어적/소프트웨어적/펌웨어적으로 구현될 수 있다. 암호 장치는 SED(Self Encryption Disk) 기능 혹은 TCG(Trusted Computing Group) 보안 기능을 수행할 수 있다. SED 기능은 암호 알고리즘을 이용하여 비휘발성 메모리 장치에 암호화된 데이터를 저장하거나, 비휘 발성 메모리 장치로부터 암호화된 데이터를 복호화 할 수 있다. 이러한 암/복호화 동작은 내부에서 생성된 암호화키를 사용하여 수행될 수 있다. TCG 보안 기능은 저장 장치의 사용자 데이터에 대한 접근 제어를 가 능하게 하는 메커니즘을 제공할 수 있다. 예를 들어, TCG 보안 기능은 외부 장치와 저장 장치 사이의 인증 절차를 수행할 수 있다. 실시 예에 있어서, SED 기능 혹은 TCG 보안 기능은 옵션적으로 선택 가능하다. 한편, 본 발명의 실시 예에 따른 저장 장치는 디버깅 정보를 관리하기 위한 전용 프로세서를 구비할 수 있다. 도 8은 본 발명의 다른 실시 예에 따른 호스트 시스템을 예시적으로 보여주는 도면이다. 도 8를 참조하면, 호스트 시스템은 호스트 장치, 공유 메모리, 및 저장 장치(200a)를 포함할 수 있다. 호스트 시스 템은 도 2에 도시된 호스트 시스템과 비교하여 통합 로그를 관리하기 위한 인공지능 프로세서를 갖는다. 인공지능 프로세서는 호스트 로그의 생성을 모니터링하고, 호스트 로그 생성시 공유 메모리 로부터 호스트 로그를 읽고, 저장 장치(200a)의 내부 구성들로부터 로그 생성시 디바이스 로그들을 수집하고,호스트 로그 및 디바이스 로드들을 동일한 포맷으로 통합 로그로 만들어 공유 메모리에 전달할 수 있다. 또한, 인공지능 프로세서는 공유 메모리의 버퍼 풀을 모니터링하고, 버퍼 풀을 인지할 때 버퍼의 상 태를 호스트 장치로 공지할 수 있다. 한편, 본 발명의 공유 메모리는 호스트 장치의 내부 구성이거나, 저장 장치의 내부 구성일 수 있다. 도 9a는 호스트 장치의 호스트 버퍼 메모리를 공유 메모리로 이용하는 호스트 시스템을 보여 주는 도면이고, 도 9b는 저장 장치(1200a)의 버퍼 메모리를 공유 메모리로 이용하는 호스트 시스템 (1000a)을 보여주는 도면이다. 도 9a를 참조하면, 호스트 시스템은 호스트 장치 및 저장 장치를 포함할 수 있다. 호스트 장 치는 호스트 장치와 저장 장치이 서로 공유하는 공유 메모리 기능을 수행하는 호스트 버퍼 메모리를 포함할 수 있다. 호스트 버퍼 메모리는 도 2에 도시된 공유 메모리의 기능을 수행하 도록 구현될 수 있다. 저장 장치는 호스트 장치 및 저장 장치의 로그들을 수집하고, 수집된 로그들에 부가 정보를 추가하여 시간 순서로 정렬한 복합 로그를 생성하는 라이브 디버그 유닛을 포함할 수 있다. 도 9b를 참조하면, 호스트 시스템(1000a)은 도 9b에 도시된 그것과 비교하여 저장 장치(1200a)의 버퍼 메모리 에 상술된 공유 메모리 기능을 수행할 수 있다. 라이브 디버그 유닛(1205a)은 호스트 장치(1100a) 및 저 장 장치(1200a)에서 생성된 로그들을 수집하여 통합 로그 형태로 변환하여 관리할 수 있다. 한편, 본 발명의 실시 예에 따른 호스트 시스템은 호스트 장치와 저장 장치 사이에 보안 기능을 수행하기 위한 별도의 장치를 더 포함할 수 있다. 도 10은 본 발명의 다른 실시 예에 따른 호스트 시스템을 예시적으로 보여주는 도면이다. 도 10을 참조하 면, 호스트 시스템은 호스트 장치, 보안 칩, 및 복수의 저장 장치들(3310, 3320, 쪋 , 33k0, k는 2 이상의 정수)를 포함할 수 있다. 보안 칩은 저장 장치들(3310, 3320, 쪋 , 33k0)의 각각과 호스트 장치 사이에 연결되고, 데이터 통신의 보안을 담당하도록 구현될 수 있다. 호스트 장치와 장치들(3310, 3320, 쪋 , 33k0)의 각각은, 도 1 내지 도 9에서 설명된 디버깅 메커니즘을 구현하기 위한 통합 로그를 관리하기 위한 메모리를 공유하고 있다. 한편, 본 발명의 저장 장치는 데이터 서버 시스템에 적용 가능하다. 도 11은 본 발명의 실시 예에 따른 메모리 장치가 적용된 데이터 센터를 예시적으로 보여주는 도면이다. 도 11 을 참조하면, 데이터 센터는 각종 데이터를 모아두고 서비스를 제공하는 시설로서, 데이터 저장 센터라고 지칭될 수도 있다. 데이터 센터는 검색 엔진 및 데이터 베이스 운용을 위한 시스템일 수 있으며, 은행 등 의 기업 혹은 정부기관에서 사용되는 컴퓨팅 시스템일 수 있다. 데이터 센터는 어플리케이션 서버들(7100 내지 7100n) 및 저장 서버들(7200 내지 7200m)을 포함할 수 있다. 어플리케이션 서버들(7100 내지 7100n)의 개 수 및 저장 서버들(7200 내지 7200m)의 개수는 실시 예에 따라 다양하게 선택될 수 있고, 어플리케이션 서버들 (7100 내지 7100n)의 개수 및 저장 서버들(7200 내지 7200m)의 개수는 서로 다를 수 있다. 어플리케이션 서버 혹은 저장 서버는 프로세서(7110, 7210) 및 메모리(7120, 7220) 중 적어도 하 나를 포함할 수 있다. 저장 서버를 예시로 설명하면, 프로세서는 저장 서버의 전반적인 동작 을 제어할 수 있고, 메모리에 액세스하여 메모리에 로딩된 명령어 및/혹은 데이터를 실행할 수 있 다. 메모리는 DDR SDRAM(Double Data Rate Synchronous DRAM), HBM(High Bandwidth Memory), HMC(Hybrid Memory Cube), DIMM(Dual In-line Memory Module), Optane DIMM 혹은 NVMDIMM(Non-Volatile DIM M)일 수 있다. 실시 예에 따라, 저장 서버에 포함되는 프로세서의 개수 및 메모리의 개수는 다양하게 선택될 수 있다. 실시 예에서, 프로세서와 메모리는 프로세서-메모리 페어를 제공할 수 있다. 실시 예에서, 프로세서와 메모리의 개수는 서로 다를 수도 있다. 프로세서는 단일 코 어 프로세서 혹은 다중 코어 프로세서를 포함할 수 있다. 저장 서버에 대한 상기 설명은, 어플리케이션 서버에도 유사하게 적용될 수 있다. 실시 예에 따라, 어플리케이션 서버는 저장 장치를 포함 하지 않을 수도 있다. 저장 서버는 적어도 하나 이상의 저장 장치를 포함할 수 있다. 저장 서버 에 포함되는 저장 장치의 개수는 실시 예에 따라 다양하게 선택될 수 있다. 어플리케이션 서버들(7100 내지 7100n) 및 저장 서버들(7200 내지 7200m)은 네트워크를 통해 서로 통신할 수 있다. 네트워크는 FC(Fiber Channel) 혹은 이더넷(Ethernet) 등을 이용하여 구현될 수 있다. 이 때, FC는 상대적으로 고속의 데이터 전송에 사용되는 매체이며, 고성능/고가용성을 제공하는 광 스위치를 사용할 수있다. 네트워크의 액세스 방식에 따라 저장 서버들(7200 내지 7200m)은 파일 저장, 블록 저장, 혹은 오브 젝트 저장으로서 제공될 수 있다. 실시 예에서, 네트워크는 SAN(Storage Area Network)와 같은 저장 전용 네트워크일 수 있다. 예를 들어, SAN은 FC 네트워크를 이용하고 FCP(FC Protocol)에 따라 구현된 FC-SAN일 수 있다. 다른 예를 들어, SAN은 TCP/IP 네트워크를 이용하고 iSCSI(SCSI over TCP/IP 혹은 Internet SCSI) 프로토콜에 따라 구현된 IP-SAN일 수 있다. 다른 실시 예에서, 네트워크는 TCP/IP 네트워크와 같은 일반 네트워크일 수 있다. 예를 들어, 네트워크는 FCoE(FC over Ethernet), NAS(Network Attached Storage), NVMe-oF(NVMe over Fabrics) 등 의 프로토콜에 따라 구현될 수 있다. 이하에서는, 어플리케이션 서버 및 저장 서버를 중심으로 설명하기로 한다. 어플리케이션 서버 에 대한 설명은 다른 어플리케이션 서버(7100n)에도 적용될 수 있고, 저장 서버에 대한 설명은 다 른 저장 서버(7200m)에도 적용될 수 있다. 어플리케이션 서버는 사용자 혹은 클라이언트가 저장 요청한 데이터를 네트워크를 통해 저장 서버 들(7200 내지 7200m) 중 하나에 저장할 수 있다. 또한, 어플리케이션 서버는 사용자 혹은 클라이언트가 리드 요청한 데이터를 저장 서버들(7200 내지 7200m) 중 하나로부터 네트워크를 통해 획득할 수 있다. 예 를 들어, 어플리케이션 서버는 웹 서버 혹은 DBMS(Database Management System) 등으로 구현될 수 있다. 어플리케이션 서버는 네트워크를 통해 다른 어플리케이션 서버(7100n)에 포함된 메모리(7120n) 혹 은 저장 장치(7150n)에 액세스할 수 있고, 혹은 네트워크를 통해 저장 서버(7200 ~ 7200m)에 포함된 메모 리(7220 ~ 7220m) 혹은 저장 장치(7250 ~ 7250m)에 액세스할 수 있다. 이로써, 어플리케이션 서버는 어 플리케이션 서버들(7100 ~ 7100n) 및/혹은 저장 서버들(7200 ~ 7200m)에 저장된 데이터에 대해 다양한 동작들을 수행할 수 있다. 예를 들어, 어플리케이션 서버는 어플리케이션 서버들(7100 ~ 7100n) 및/혹은 저장 서버 들(7200 ~ 7200m) 사이에서 데이터를 이동 혹은 카피(copy)하기 위한 커맨드를 실행할 수 있다. 이 때 데이터는 저장 서버들(7200 ~ 7200m)의 저장 장치로(7250 ~ 7250m)부터 저장 서버들(7200 ~ 7200m)의 메모리들(7220 ~ 7220m)을 거쳐서, 혹은 바로 어플리케이션 서버들(7100 ~ 7100n)의 메모리(7120 ~ 7120n)로 이동될 수 있다. 네트워크를 통해 이동하는 데이터는 보안 혹은 프라이버시를 위해 암호화된 데이터일 수 있다. 저장 서버를 예시로 설명하면, 인터페이스는 프로세서와 제어기의 물리적 연결 및 NIC와 제어기의 물리적 연결을 제공할 수 있다. 예를 들어, 인터페이스는 저장 장치를 전용 케이블로 직접 접속하는 DAS(Direct Attached Storage) 방식으로 구현될 수 있다. 또한, 예를 들어, 인터 페이스는 ATA(Advanced Technology Attachment), SATA(Serial ATA), e-SATA(external SATA), SCSI(Small Computer Small Interface), SAS(Serial Attached SCSI), PCI(Peripheral Component Interconnection), PCIe(PCI express), NVMe(NVM express), IEEE 1394, USB(universal serial bus), SD(secure digital) 카드, MMC(multi-media card), eMMC(embedded multi-media card), UFS(Universal Flash Storage), eUFS(embedded Universal Flash Storage), CF(compact flash) 카드 인터페이스 등과 같은 다양한 인 터페이스 방식으로 구현될 수 있다. 저장 서버는 스위치 및 NIC을 더 포함할 수 있다. 스위치는 프로세서의 제어에 따라 프로세서와 저장 장치를 선택적으로 연결시키거나, NIC과 저장 장치를 선택적으 로 연결시킬 수 있다. 실시 예에서 NIC는 네트워크 인터페이스 카드, 네트워크 어댑터 등을 포함할 수 있다. NIC는 유선 인터페이스, 무선 인터페이스, 블루투스 인터페이스, 광학 인터페이스 등에 의해 네트워크에 연결될 수 있다. NIC는 내부 메모리, DSP, 호스트 버스 인터페이스 등을 포함할 수 있으며, 호스트 버스 인터페이스 를 통해 프로세서 및/혹은 스위치 등과 연결될 수 있다. 호스트 버스 인터페이스는, 앞서 설명한 인터페이스의 예시들 중 하나로 구현될 수도 있다. 실시 예에서, NIC는 프로세서, 스위치 , 저장 장치 중 적어도 하나와 통합될 수도 있다. 저장 서버(7200 ~ 7200m) 혹은 어플리케이션 서버(7100 ~ 7100n)에서 프로세서는 저장 장치(7130 ~ 7130n, 7250 ~ 7250m) 혹은 메모리(7120 ~ 7120n, 7220 ~ 7220m)로 커맨드를 전송하여 데이터를 프로그램 혹은 리드할 수 있다. 이 때 데이터는 ECC(Error Correction Code) 엔진을 통해 에러 정정된 데이터일 수 있다. 데이터는 데 이터 버스 변환(Data Bus Inversion: DBI) 혹은 데이터 마스킹(Data Masking: DM) 처리된 데이터로서, CRC(Cyclic Redundancy Code) 정보를 포함할 수 있다. 데이터는 보안 혹은 프라이버시를 위해 암호화된 데이터일 수 있다. 저장 장치(7150 ~ 7150m, 7250 ~ 7250m)는 프로세서로부터 수신된 리드 커맨드에 응답하여, 제어 신호 및 커맨 드/어드레스 신호를 NAND 플래시 메모리 장치(7252 ~ 7252m)로 전송할 수 있다. 이에 따라 NAND 플래시 메모리 장치(7252 ~ 7252m)로부터 데이터를 리드하는 경우, RE(Read Enable) 신호는 데이터 출력 제어 신호로 입력되어, 데이터를 DQ 버스로 출력하는 역할을 할 수 있다. RE 신호를 이용하여 DQS(Data Strobe)를 생성할 수 있다. 커맨드와 어드레스 신호는 WE(Write Enable) 신호의 상승 엣지 혹은 하강 엣지에 따라 페이지 버퍼에 래 치 될 수 있다. 실시 예에 있어서, 저장 장치(7150 ~ 7150m, 7250 ~ 7250m)는 도 1 내지 도 10에서 설명된 바와 같이 디버깅 동작을 위한 통합 로그 관리를 할 수 있다. 제어기는 저장 장치의 동작을 전반적으로 제어할 수 있다. 실시 예에서, 제어기는 SRAM(Static Random Access Memory)을 포함할 수 있다. 제어기는 라이트 커맨드에 응답하여 낸드 플래시 에 데이터를 라이트 할 수 있고, 혹은 리드 커맨드에 응답하여 낸드 플래시로부터 데이터를 리드할 수 있다. 예를 들어, 라이트 커맨드 및/혹은 리드 커맨드는 저장 서버 내의 프로세서, 다른 저장 서버(7200m) 내의 프로세서(7210m) 혹은 어플리케이션 서버(7100, 7100n) 내의 프로세서(7110, 7110n)로부터 제공될 수 있다. DRAM은 낸드 플래시에 라이트 될 데이터 혹은 낸드 플래시로부터 리드된 데 이터를 임시 저장(버퍼링)할 수 있다. 또한, DRAM은 메타 데이터를 저장할 수 있다. 여기서, 메타 데이터 는 사용자 데이터 혹은 낸드 플래시를 관리하기 위해 제어기에서 생성된 데이터이다. 본 발명에서는 Host System과 SSD 장비의 Log를 공유 메모리를 활용하여 관리하고 저장하는 메커니즘을 통해 Device와 Host System의 동작을 종합적으로 고려해야 해결할 수 있는 어려운 이슈를 해결할 수 있는 Solution을 제공한다."}
{"patent_id": "10-2021-0183355", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "한편, 상술된 본 발명의 내용은 발명을 실시하기 위한 구체적인 실시 예들에 불과하다. 본 발명은 구체적이고 실제로 이용할 수 있는 수단 자체뿐 아니라, 장차 기술로 활용 할 수 있는 추상적이고 개념적인 아이디어인 기 술적 사상을 포함 할 것이다."}
{"patent_id": "10-2021-0183355", "section": "도면", "subsection": "도면설명", "item": 1, "content": "이하에 첨부되는 도면들은 본 실시 예에 관한 이해를 돕기 위한 것으로, 상세한 설명과 함께 실시 예들을 제공 한다. 도 1은 본 발명의 디버깅 정보를 관리하는 개념을 설명하기 위한 호스트 시스템을 예시적으로 보여주는 도면 이다. 도 2는 본 발명의 실시 예에 따른 호스트 시스템을 예시적으로 보여주는 도면이다. 도 3은 본 발명의 실시 예에 따른 호스트 시스템에서 통합 로그의 관리 메커니즘을 예시적으로 보여주는 도면이 다. 도 4는 본 발명의 실시 예에 따른 저장 장치의 라이브 디버그 유닛의 동작을 예시적으로 보여주는 흐 름도이다. 도 5는 본 발명의 실시 예에 따른 공유 메모리의 동작을 예시적으로 보여주는 흐름도이다. 도 6은 본 발명의 실시 예에 따른 호스트 시스템의 로그 관리 동작을 예시적으로 보여주는 래더다이어그램 이다. 도 7은 본 발명의 실시 예에 따른 저장 장치를 예시적으로 보여주는 도면이다. 도 8은 본 발명의 다른 실시 예에 따른 호스트 시스템을 예시적으로 보여주는 도면이다. 도 9a는 호스트 장치의 호스트 버퍼 메모리를 공유 메모리로 이용하는 호스트 시스템을 보여 주는 도면이고, 도 9b는 저장 장치(1200a)의 버퍼 메모리를 공유 메모리로 이용하는 호스트 시스템 (1000a)을 보여주는 도면이다. 도 10은 본 발명의 다른 실시 예에 따른 호스트 시스템을 예시적으로 보여주는 도면이다. 도 11은 본 발명의 실시 예에 따른 메모리 장치가 적용된 데이터 센터를 예시적으로 보여주는 도면이다."}
