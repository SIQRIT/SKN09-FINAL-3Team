{"patent_id": "10-2009-7015354", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2010-0014329", "출원번호": "10-2009-7015354", "출원인": "더 보잉 컴파니", "발명자": "코마르, 클로드"}}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "인간행동을 시뮬레이션하기 위한 장치로서,네트워크 데이터 처리 시스템(100)의 저장 시스템에 위치한 소스 코드(402, 510, 600)로서, 인간행동을 예측하기 위한 언어로 작성된 소스 코드(402, 510, 600);와네트워크 데이터 처리 시스템(100)의 하드웨어에서 실행되는 해석기(404, 518, 1700)로서, 언어 해석기(1704)및 통신 모듈(1702)을 포함하는 해석기(404, 510, 600);와네트워크 데이터 처리 시스템(100)의 하드웨어에서 실행되는 GUI(그래픽 유저 인터페이스) 프로세서(406, 522,524, 528, 2600)로서, 수신된 인터프리티드 소스 코드를 형성하기 위해 언어 해석기(1704)로부터 인터프리티드소스 코드를 수신하고 상기 수신된 인터프리티드 소스 코드를 사용하여 장치 의존적인 출력을 생성하는 GUI 프로세서(406, 522, 524, 528, 2600); 및GUI 프로세서(406, 522, 524, 528, 2600)와 통신하는 한 세트의 장치들(408, 523, 530, 532, 2618)로서, 장치의존적인 출력을 표시하는 한 세트의 장치들(408, 523, 530, 532, 2618)을 구비하고, 상기 언어 해석기(1704)는 새로운 정의 및 인터프리티드 소스 코드를 생성하기 위해 인공 지능(802, 3202)을 이용하는 소스 코드(402, 510, 600)를 가지고 시뮬레이션을 수행하고, 상기 한 세트의 장치들(408, 523, 530, 532, 2618)은 받아들인 사용자 입력을 형성하도록 사용자 입력을 받고,받아들인 사용자 입력을 GUI 프로세서(406, 522, 524, 528, 2600)로 보내며,상기 통신 모듈(1702)은 GUI 프로세서(406, 522, 524, 528, 2600)로부터는 상기 받아들인 사용자 입력을 수신하고 언어 해석기(1704)로부터는 새로운 정의를 수신하고, 언어 해석기(1704)에 의해 실행되는 변형된 소스 코드를 형성하기 위해 상기 받아들인 사용자 입력 및 상기 새로운 정의를 가지고 소스 코드(402, 510, 600)를 변형하는, 인간행동을 시뮬레이션하기 위한 장치."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 해석기(404, 518, 1700)는 제1 암호화 및 복호화 모듈(1706, 2602)을 더 포함하고, GUI 프로세서(406,522, 524, 528, 2600)는 제2 암호화 및 복호화 모듈(1706, 2602)을 더 포함하고, 상기 제1 암호화 모듈(1706,2602)은 암호화된 출력을 형성하기 위해 장치 의존적인 출력을 암호화하고 상기 암호화된 출력을 제2 암호화 및복호화 모듈(1706, 2602)로 보내고, 제2 암호화 및 복호화 모듈(1706, 2602)은 상기 수신된 인터프리티드 소스코드를 형성하기 위해 암호화된 출력을 복호화하는, 인간행동을 시뮬레이션하기 위한 장치."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 언어 해석기(1704)는, 식별된 토큰들을 형성하기 위해 소스 코드(402, 510, 600)에서 토큰들을 식별시키는 언어 분석기;와상기 식별된 토큰들을 사용하여 명령문들을 생성하는 문법 구문분석기 (1730); 및인공 지능(802, 3202)을 사용하여 문법 구문분석기(1730)에 의해 생성된 상기 명령문들을 실행하는 실행 모듈(1732)을 포함하는, 인간행동을 시뮬레이션하기 위한 장치."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서,상기 통신 모듈은, 등록 모듈(1726);과- 2 -공개특허 10-2010-0014329입력 모듈(1724); 및디스패처 모듈(1722)을 포함하는, 인간행동을 시뮬레이션하기 위한 장치."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서, 상기 저장 시스템은 복수의 저장 장치들인, 인간행동을 시뮬레이션하기 위한 장치."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 복수의 저장 장치들은 네트워크 데이터 처리 시스템(100)에서 서로 다른 장소들에 존재하는, 인간행동을시뮬레이션하기 위한 장치."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,GUI 프로세서(406, 522, 524, 528, 2600)는 상기 하드웨어의 제1 부분에서 실행되고, 해석기(404, 518, 1700)는 상기 하드웨어의 제2 부분에서 실행되는, 인간행동을 시뮬레이션하기 위한 장치."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,언어 해석기(1704)는 소스 코드(402, 510, 600)에서 상기 언어로 토큰들을 식별시키고, 상기 언어를 위해 명령문들을 생성하고, 명령문들로부터 액션들을 실행하는, 인간행동을 시뮬레이션하기 위한 장치."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서,언어 해석기(1704)는 한 세트의 장치 의존적인 출력 스트림들의 형식으로 장치 의존적인 출력을 생성하는, 인간행동을 시뮬레이션하기 위한 장치."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "인간행동을 시뮬레이션하기 위해 컴퓨터로 구현된 방법으로서,검색된 데이터를 형성하기 위해 네트워크 데이터 처리 시스템(100)의 저장 시스템에 저장된 소스 코드(402,510, 600)로부터 데이터를 검색하는 단계;와결과들을 생성하도록 네트워크 데이터 처리 시스템(100)에서 실행되는 해석기(404, 518, 1700)를 사용하여 상기인간행동에 대한 시뮬레이션을 수행하기 위해 상기 검색된 데이터를 해석하는 단계;와네트워크 데이터 처리 시스템(100)에서 수행되는 GUI 프로세서(406, 522, 524, 528, 2600)를 사용하여 상기 결과들로부터 이 결과들을 나타내기 위해 사용될 수 있는 장치 의존적인 데이터를 생성하는 단계; 및인간행동을 예측하기 위하여 차후의 해석들에서 이용되는 새로운 데이터를 제공하는 변형된 소스 코드를 형성하기 위해 상기 결과들을 사용하여 상기 소스 코드(402, 510, 600)를 변형하는 단계;를 포함하는, 인간행동을 시뮬레이션하기 위해 컴퓨터로 구현된 방법."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제15항에 있어서,한 세트의 장치들(408, 523, 530, 532, 2618) 상에서 상기 장치 의존적인 데이터를 나타내는 단계를 더 포함하는, 인간행동을 시뮬레이션하기 위해 컴퓨터로 구현된 방법."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "- 3 -공개특허 10-2010-0014329제16항에 있어서,받아들인 사용자 입력을 형성하기 위해 상기 해석기(404, 518, 1700)에서 한 세트의 장치들(408, 523, 530,532, 2618)로부터 사용자 입력을 받는 단계;와 상기 변형된 소스 코드를 형성하기 위해 상기 받아들인 사용자 입력을 사용하여 해석기(404, 518, 1700)에 의해소스 코드(402, 510, 600)를 변형하는 단계; 및상기 변형된 소스 코드를 사용하여 해석기(404, 518, 1700)에서 상기 인간행동에 대한 시뮬레이션의 수행을 계속하는 단계;를 더 포함하는, 인간행동을 시뮬레이션하기 위해 컴퓨터로 구현된 방법."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제15항에 있어서, 암호화된 형식으로 해석기(404, 518, 1700)로부터의 결과들을 GUI 프로세서(406, 522, 524, 528, 2600)로 보내는 단계를 더 포함하는, 인간행동을 시뮬레이션하기 위해 컴퓨터로 구현된 방법."}
{"patent_id": "10-2009-7015354", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제15항에 있어서, GUI 프로세서(406, 522, 524, 528, 2600)는 복수의 서로 다른 데이터 처리 시스템에 위치하는, 인간행동을 시뮬레이션하기 위해 컴퓨터로 구현된 방법.명 세 서기 술 분 야본 개시는 향상된 데이터 처리 시스템을 제공하는데, 상세하게는 데이터 처리를 위한 방법 및 장치를 제공한다. [0001]더욱 상세하게는, 본 개시는 인간행동을 모델링하고 시뮬레이션하기 위하여 컴퓨터로 구현되는 방법, 장치, 및컴퓨터에서 사용가능한 프로그램 코드에 관한 것이다.본 개시는 “인간행동의 모델링 및 시뮬레이션 프레임워크”라는 명칭으로 2007년 3월 1일에 가출원 된 미국 특 [0002]허출원번호 제60/892,422호와 관련이 있고, 이 미국 특허출원의 우선권의 이익을 주장하고, 이 미국 특허출원은본 명세서에 참조로서 통합된다.배 경 기 술인간행동은 인간들에 의하여 행하여진 활동들의 모음이다. 이 활동들은 예컨대, 문화, 태도들, 감정들, 가치들, [0003]윤리들, 권위, 설득, 및/또는 강압과 같은 요인들에 의해 영향받는다. 인간들의 행동은 이하의 한 범주에 속하게 되는데, 일부 행동은 보편적인 것이고, 일부 행동은 특이한 것으로 고려되고, 일부 다른 행동은 수용할 수있는 것으로 고려되고, 그 밖의 행동은 수용 범위 밖이다. 인간들의 행동은 철학, 사회학, 및 인류학과 같은 많은 학구적인 학문에 의해 연구되어 왔다. 보다 최근에는, 컴퓨터를 사용하는 것이 인간행동의 연구에 적용되어왔다.게다가, 인간행동의 시뮬레이션들은 군사적인 훈련들 및 계획을 수행하기 위해 사용되어 왔다. 인간행동 시뮬레 [0004]이션은 또한 경제적 또는 사회적 행동들과 같은 다른 상황들을 예측하는 데에 대해 사용될 수 있다. 인간행동을예측하기 위한 능력은 훈련 프로그램들을 개발하는 데 유용할 것이다. 피훈련자들이 다양한 자극들에 대해 어떻게 반응할지에 대한 지식은 훈련 프로그램들을 개발하고 변경하는데 사용될 수 있다.현재의 모델들 및 시뮬레이션 프로그램들은 다양한 이유들로 인하여 인간행동을 적절하게 시뮬레이션하지 못한 [0005]다. 예를 들어, 현재 이용가능한 시뮬레이션 프로그램들은 특별한 유형의 시뮬레이션에 대해서만 적합하다. 결과적으로, 다른 유형의 시뮬레이션이 요구될 때, 그 시뮬레이션을 수행하기 위해 새로운 프로그램을 작성할 것이 요구된다. 게다가, 관계들의 수와 이 관계들을 변경하는 능력이 제한된다. 그러므로, 훈련 프로그램에서 사용하도록 인간행동을 모델링하고 시뮬레이션하기 위해 컴퓨터로 구현되는 개선 [0006]된 방법, 장치, 및 컴퓨터로 사용가능한 프로그램 코드를 가지는 것이 유리할 것이다.- 4 -공개특허 10-2010-0014329발명의 상세한 설명유익한 실시예들은 인간행동을 시뮬레이션하기 위한 컴퓨터로 구현된 방법, 장치, 및 컴퓨터에서 사용가능한 프 [0007]로그램 코드를 제공한다. 소스 코드는 네트워크 데이터 처리 시스템의 저장 시스템에 위치한다. 이 소스 코드는인간행동을 예측하기 위한 언어로 작성된다. 해석기는 네트워크 데이터 처리 시스템의 하드웨어 상에서 실행되고, 해석기는 언어 해석기 및 통신 모듈을 포함한다. 언어 해석기는 새로운 정의 및 인터프리티드 소스 코드(interpreted source code)를 생성하기 위해 인공 지능을 사용하여 상기 소스 코드를 가지고 시뮬레이션을 수행한다. GUI(그래픽 사용자 인터페이스) 프로세서는 네트워크 데이터 처리 시스템의 하드웨어 상에서 실행된다.GUI 프로세서는 수신된 인터프리티드 소스 코드를 형성하기 위해 언어 해석기로부터 인터프리티드 소스 코드를수신하고 수신된 인터프리티드 소스 코드를 사용하여 장치 의존적인 출력을 생성한다. 한 세트의 장치들이 GUI프로세서와 통신한다. 이 한 세트의 장치들은 장치 의존적인 출력을 표시하고, 받아들인 사용자 입력을 형성하기 위해 사용자 입력을 받고, 받아들인 사용자 입력을 GUI 프로세서로 보낸다. 통신 모듈은 GUI 프로세서로부터는 받아들인 사용자 입력을, 언어 해석기로부터는 새로운 정의를 수신하고, 언어 해석기에 의해 실행되는 변경된 소스 코드를 형성하기 위해 받아들인 사용자 입력 및 새로운 정의를 가지고 소스 코드를 변경한다.다른 유익한 실시예는 인간행동을 시뮬레이션하기 위한 컴퓨터로 구현된 방법을 제공한다. 데이터는 검색된 데 [0008]이터를 형성하기 위해 네트워크 데이터 처리 시스템의 저장 시스템에 저장된 소스 코드로부터 검색된다. 검색된데이터는 결과들을 생성하기 위해 네트워크 데이터 처리 시스템에서 실행되는 해석기를 사용하여 인간행동의 시뮬레이션을 수행하도록 해석된다. 장치 의존적인 데이터가 네트워크 데이터 처리 시스템에서 실행되는 GUI 프로세서를 사용한 결과들로부터 생성된다. 장치 의존적인 데이터는 결과들을 나타내기 위해 사용될 수 있다. 소스코드는 변경된 소스 코드를 형성하기 위해 결과들을 사용하여 변경된다. 변경된 소스 코드는 인간행동을 예측하기 위하여 수반되는 해석들에서 이용되는 새로운 데이터를 제공한다.다른 유익한 실시예는 인간행동을 시뮬레이션하기 위한 데이터 처리 시스템을 제공한다. 이 데이터 처리 시스템 [0009]은 검색된 데이터를 형성하기 위해 네트워크 데이터 처리 시스템의 저장 시스템에 저장된 소스 코드로부터 데이터를 검색하기 위한 검색 수단을 포함한다. 해석 수단은 결과들을 생성하기 위해 네트워크 데이터 처리 시스템에서 수행되는 해석기를 사용하여 인간행동의 시뮬레이션을 수행하도록 검색된 데이터를 해석하기 위해 존재한다. 데이터 처리 시스템은 또한 네트워크 데이터 처리 시스템에서 실행되는 GUI 프로세서를 사용한 결과들로부터 장치 의존적인 데이터를 생성하기 위한 생성 수단을 포함한다. 장치 의존적인 데이터는 결과들을 나타내기위해 사용될 수 있다. 변경 수단은 변경된 소스 코드를 생성하기 위하여 결과들을 사용한 소스 코드를 변경하기위해 존재한다. 변경된 소스 코드는 인간행동을 예측하기 위하여 수반되는 해석들에서 이용되는 새로운 데이터를 제공한다.이 특징들, 기능들, 및 장점들은 본 개시의 다양한 실시예들에서 독립적으로 달성될 수 있고, 이에 다른 실시예 [0010]들이 결합될 수 있다. 실 시 예이제 도면들, 특히 도 1 내지 도 2를 참조하면, 데이터 처리 환경들의 예시적인 도면들이 제공되는데, 이 도면 [0065]들에는 설명을 위한 실시예들이 구현될 수 있다. 도 1 내지 도 2는 단지 예시적인 것이고, 다른 유익한 실시예들이 구현될 수 있는 환경들에 대하여 어떠한 제한을 하거나 내포하고자 하는 것이 아님을 이해하여야 한다. 도시된 환경들에 대하여 여러 가지 변경들이 가해질 수 있다.본 명세서에서 사용될 때, \"중의 적어도 하나\"라는 문구가 항목들의 목록과 함께 사용되는 경우에는 하나 이상 [0066]의 항목들의 서로 다른 조합들이 사용될 수 있고 목록에서의 각 항목 중 하나만은 필수적이라는 것을 의미한다.예를 들어, \"항목 A, 항목 B, 및 항목 C 중의 적어도 하나\"라는 문구는 예컨대, 항목 A 또는 항목 A와 항목 B를제한 없이 포함할 수 있다. 이 예는 항목 A와 항목 B와 항목 C 또는 항목 B와 항목 C도 포함할 수 있다.이제 도면들을 참조하면, 도 1은 유익한 실시예들이 구현될 수 있는 데이터 처리 시스템들의 네트워크의 도식적 [0067]표현을 도시한다. 이러한 도시된 예들에서, 네트워크 데이터 처리 시스템(100)은 인간행동의 모델링 및 시뮬레이션 개발 프레임워크를 구현하기 위하여 이용된다. 이 프레임워크는 인간행동을 예측하기 위한 능력을 제공한다.네트워크 데이터 처리 시스템(100)은 유익한 실시예들이 구현될 수 있는 컴퓨터들 및 다른 장치들의 네트워크이 [0068]다. 네트워크 데이터 처리 시스템(100)은 네트워크(102)를 포함하는데, 여기서 네트워크(102)는 네트워크 데이- 5 -공개특허 10-2010-0014329터 처리 시스템(100) 내에서 함께 연결된 다양한 장치들 및 컴퓨터들 사이의 통신 연결들을 제공하기 위하여 사용되는 매체이다. 네트워크(102)는 유무선 통신 링크들 및/또는 광섬유 케이블들과 같은 연결부들을 포함할 수있다.도시된 예에서, 서버(104) 및 서버(106)는 저장소(108)와 함께 네트워크(102)에 연결된다. 게다가, 클라이언트 [0069]들(110, 112, 및 114)도 네트워크(102)에 연결된다. 이 클라이언트들(110, 112, 및 114)은, 예컨대, 퍼스널 컴퓨터들(PC), 워크스테이션 컴퓨터들, 개인용 정보단말기(PDA)들이 될 수 있다. 도시된 예에서, 서버(104)는 부팅 파일들, 운영 시스템(OS) 이미지들, 및 어플리케이션들과 같은 데이터를 클라이언트들(110, 112, 및 114)에게 제공한다. 클라이언트들(110, 112, 및 114)은 이 예에서 서버(104) 및 서버(106)에 대한 클라이언트들이다.네트워크 데이터 처리 시스템(100)은 부가적인 서버들, 클라이언트들, 및 도시되지 않은 다른 장치들을 포함할수 있다. 유익한 실시예들에서 인간행동을 예측하기 위한 프레임워크는 네트워크 데이터 처리 시스템(100)에서하나 이상의 데이터 처리 시스템들을 사용하여 구현될 수 있다.이제 도 2를 참조하여, 데이터 처리 시스템의 도면이 예시적인 실시예에 따라서 도시된다. 설명을 위한 예에서, [0070]데이터 처리 시스템(200)은 통신 패브릭(202)을 포함하는데, 여기서 통신 패브릭(202)은 프로세서부(204), 메모리(206), 영구 저장소(208), 통신부(210), 입출력(I/O)부(212), 및 표시부(214) 사이의 통신을 제공한다.프로세서부(204)는 메모리(206)에 적재될 수 있는 소프트웨어를 위한 명령어들을 실행하는 일을 한다. 프로세서 [0071]부(204)는 구체적인 구현에 따라서 한 세트의 하나 이상의 프로세서들이거나 하나의 멀티-프로세서 코어일 수있다. 게다가, 프로세서부(204)는 단일칩 상에서 주 프로세서가 보조 프로세서들과 함께 존재하는 하나 이상의이종형 프로세서 시스템들을 사용하여 구현될 수 있다. 다른 설명을 위한 예에서와 같이, 프로세서부(204)는 동일한 유형의 복수의 프로세서들을 포함하는 대칭형 멀티-프로세서 시스템일 수 있다. 메모리(206)는 이 예들에서, 예컨대 램(RAM)이거나 기타 다른 적절한 휘발성 또는 비휘발성 저장 장치일 수 있 [0072]다. 영구 저장소(208)는 구체적인 구현에 따라서 다양한 형태들을 취할 수 있다. 예를 들어, 영구 저장소(208)는 하나 이상의 구성요소들 또는 장치들을 포함할 수 있다. 예를 들어, 영구 저장소(208)는 하드 드라이브, 플래시 메모리, 재기록형 광디스크, 재기록형 마그네틱 테이프, 또는 이들의 몇 가지 조합일 수 있다. 영구 저장소(208)에 의하여 사용되는 매체는 또한 분리가능할 수도 있다. 예를 들어, 분리가능한 하드 드라이브가 영구저장소(208)를 위하여 사용될 수 있다.통신부(210)는 이 예들에서, 다른 데이터 처리 시스템들 또는 장치들과의 통신을 제공한다. 이 예들에서, 통신 [0073]부(210)는 네트워크 인터페이스 카드이다. 통신부(210)는 물리적인 통신 링크들과 무선 통신 링크들 중의 어느하나 또는 양쪽 모두를 사용하여 통신을 제공할 수 있다.입출력부(212)는 데이터 처리 시스템(200)에 연결될 수 있는 다른 장치들과의 데이터 입출력을 허용한다. 예를 [0074]들어, 입출력부(212)는 키보드 및 마우스를 통해 사용자 입력을 위한 연결을 제공할 수 있다. 게다가, 입출력부(212)는 프린터로 출력을 보낼 수 있다. 표시부(214)는 사용자에게 정보를 표시하기 위한 메커니즘을 제공한다.운영 시스템을 위한 명령어들과 어플리케이션들 또는 프로그램들은 영구 저장소(208)에 위치한다. 이 명령어들 [0075]은 프로세서부(204)에 의해 실행되기 위하여 메모리(206)로 적재될 수 있다. 다른 실시예들의 프로세스들은 컴퓨터로 구현되는 명령어들을 사용하여 프로세서부(204)에 의하여 수행될 수 있는데, 여기서 명령어들은 메모리(206)와 같은 메모리에 위치할 수 있다. 이 명령어들은 프로세서부(204)의 프로세서에 의해 판독되고 실행될 수있는 프로그램 코드, 컴퓨터에서 사용가능한 프로그램 코드, 또는 컴퓨터에서 판독가능한 프로그램 코드를 가리킨다. 다른 실시예들에서 프로그램 코드는 메모리(206) 또는 영구 저장소(208)와 같이 컴퓨터에서 판독가능한상이한 물리적 또는 유형적인 매체에서 구현될 수 있다. 프로그램 코드(216)는 선택적으로 분리될 수 있는 컴퓨터 판독가능한 매체(218)에 함수 형태로 위치하고, 프로 [0076]세서부(204)에 의해 실행되기 위하여 데이터 처리 시스템(200)으로 적재되거나 전송될 수 있다. 이 예들에서 프로그램 코드(216)와 컴퓨터에서 판독가능한 매체(218)는 컴퓨터 프로그램 제품(220)을 형성한다. 일례로, 컴퓨터에서 판독가능한 매체(218)는 예컨대 광디스크 또는 마그네틱 디스크와 같이 유형적인 형태일 수 있는데, 여기서 광디스크 또는 마그네틱 디스크는 영구 저장소(208)의 일부인 하드 드라이브와 같은 저장 장치로 전송하기위하여 영구 저장소(208)의 일부인 드라이브 또는 다른 장치로 삽입되거나 배치된다. 유형적인 형태에 있어서,컴퓨터에서 판독가능한 매체(218)는 하드 드라이브, 썸 드라이브 또는 데이터 처리 시스템(200)에 연결되는 플래시 메모리와 같은 영구 저장소의 형태를 취할 수 있다. 컴퓨터에서 판독가능한 매체(218)의 유형적인 형태는컴퓨터에서 기록가능한 저장 매체를 가리키기도 한다. 일부 예들에서, 컴퓨터에서 판독가능한 매체(218)는 분리- 6 -공개특허 10-2010-0014329가능하지 않을 수 있다.이와 달리, 프로그램 코드(216)는 통신부(210)에 대한 통신 링크 및/또는 입출력부(212)에 대한 연결을 통하여 [0077]컴퓨터에서 판독가능한 매체(218)로부터 데이터 처리 시스템(200)으로 전송될 수 있다. 상기 통신 링크 및/또는상기 연결은 설명을 위한 예들에서 물리적이거나 무선일 수 있다. 컴퓨터에서 판독가능한 매체는 또한 프로그램코드를 담고 있는 통신 링크들 또는 무선 전송들과 같은 무형의 매체 형태를 취할 수 있다. 데이터 처리 시스템(200)을 위하여 도시된 다른 구성요소들이 다른 실시예들이 구현될 수 있는 방식에 대하여 [0078]구조적인 제한들을 가하는 것을 의미하지는 않는다. 설명을 위한 다른 실시예들은 데이터 처리 시스템(200)에대하여 도시된 것들을 대체하거나 추가하는 구성요소들을 포함하는 데이터 처리 시스템에서 구현될 수 있다. 도2에 도시된 다른 구성요소들은 도시된 설명을 위한 예들로부터 변경이 가해질 수 있다.일례로, 데이터 처리 시스템(200)의 저장 장치는 데이터를 저장할 수 있는 임의의 하드웨어 장치이다. 메모리 [0079](206), 영구 저장소(208) 및 컴퓨터에서 판독가능한 매체(218)는 유형적인 형태의 저장 장치들의 예들이다.다른 예에서, 버스 시스템은 통신 패브릭(202)을 구현하기 위하여 사용될 수 있고, 시스템 버스 또는 입출력 버 [0080]스와 같은 하나 이상의 버스들을 포함할 수 있다. 물론, 버스 시스템은 이 버스 시스템에 부착된 상이한 구성요소들 또는 장치들 사이의 데이터 전송을 제공하는 임의의 적절한 유형의 구조를 사용하여 구현될 수 있다. 게다가, 통신부는 모뎀 또는 네트워크 어댑터와 같은, 데이터 송수신을 위하여 사용되는 하나 이상의 장치들을 포함할 수 있다. 게다가, 메모리는 예컨대, 메모리(206)이거나 통신 패브릭(202)에 존재할 수 있는 인터페이스 및메모리 제어기 허브에서 발견되는 것과 같은 캐시(cache)일 수 있다.도시된 예에서, 네트워크 데이터 처리 시스템(100)은 서로 통신하기 위하여 티시피아이피(TCP/IP) 프로토콜을 [0081]사용하는 네트워크들과 게이트웨이들의 세계적인 집합을 나타내는, 네트워크(102)를 포함하는 인터넷이다.물론, 네트워크 데이터 처리 시스템(100)은 또한 인터넷에 부가적으로 또는 인터넷 대신에 수많은 다른 유형의네트워크들로 구현될 수 있다. 이들 다른 네트워크들은 예컨대, 인트라넷, 랜(LAN), 및 왠(WAN)을 포함할 수 있다. 도 1은 예로서 든 것이지 다른 실시예들에 대한 구조의 제한을 의도한 것은 아니다. 이제 도 2를 참조하면, 데이터 처리 시스템의 도면이 설명을 위한 실시예에 따라서 도시된다. 데이터 처리 시스 [0082]템(200)은 도 1의 서버들(104 및 106) 및 클라이언트들(110, 112, 및 114)과 같은 서버들 및 클라이언트들을 구현하기 위해 사용될 수 있다. 이러한 설명을 위한 예에서, 데이터 처리 시스템(200)은 통신 패브릭(202)을 포함하는데, 여기서 통신 패브릭(202)은 프로세서부(204), 메모리(206), 영구 저장소(208), 통신부(210), 입출력(I/O)부(212), 및 표시부(214) 사이의 통신을 제공한다.프로세서부(204)는 메모리(206)에 적재될 수 있는 소프트웨어를 위한 명령어들을 실행하는 일을 한다. 프로세서 [0083]부(204)는 구체적인 구현에 따라서 한 세트의 하나 이상의 프로세서들이거나 하나의 멀티-프로세서 코어일 수있다. 게다가, 프로세서부(204)는 단일칩 상에서 주 프로세서가 보조 프로세서들과 함께 존재하는 하나 이상의이종형 프로세서 시스템들을 사용하여 구현될 수 있다. 다른 설명을 위한 예에서와 같이, 프로세서부(204)는 동일한 유형의 복수의 프로세서들을 포함하는 대칭형 멀티-프로세서 시스템일 수 있다. 메모리(206)는 이 예들에서, 예컨대 램(RAM)이거나 기타 다른 적절한 휘발성 또는 비휘발성 저장 장치일 수 있 [0084]다. 영구 저장소(208)는 구체적인 구현에 따라서 다양한 형태들을 취할 수 있다. 예를 들어, 영구 저장소(208)는 하나 이상의 구성요소들 또는 장치들을 포함할 수 있다. 예를 들어, 영구 저장소(208)는 하드 드라이브, 플래시 메모리, 재기록형 광디스크, 재기록형 마그네틱 테이프, 또는 이들의 몇 가지 조합일 수 있다. 영구 저장소(208)에 의하여 사용되는 매체는 또한 분리가능할 수도 있다. 예를 들어, 분리가능한 하드 드라이브가 영구저장소(208)를 위하여 사용될 수 있다.통신부(210)는 이 예들에서, 다른 데이터 처리 시스템들 또는 장치들과의 통신을 제공한다. 이 예들에서, 통신 [0085]부(210)는 네트워크 인터페이스 카드이다. 통신부(210)는 물리적인 통신 링크들과 무선 통신 링크들 중의 어느하나 또는 양쪽 모두를 사용하여 통신을 제공할 수 있다.입출력부(212)는 데이터 처리 시스템(200)에 연결될 수 있는 다른 장치들과의 데이터 입출력을 허용한다. 예를 [0086]들어, 입출력부(212)는 키보드 및 마우스를 통해 사용자 입력을 위한 연결을 제공할 수 있다. 게다가, 입출력부(212)는 프린터로 출력을 보낼 수 있다. 표시부(214)는 사용자에게 정보를 표시하기 위한 메커니즘을 제공한다.운영 시스템과 어플리케이션들 또는 프로그램들을 위한 명령어들이 영구 저장소(208)에 위치한다. 이 명령어들 [0087]은 프로세서부(204)에 의해 실행되기 위하여 메모리(206)로 적재될 수 있다. 다른 실시예들의 프로세스들은 컴- 7 -공개특허 10-2010-0014329퓨터로 구현되는 명령어들을 사용하여 프로세서부(204)에 의하여 수행될 수 있는데, 여기서 명령어들은 메모리(206)와 같은 메모리에 위치할 수 있다. 이 명령어들은 프로세서부(204)의 프로세서에 의해 판독되고 실행될 수있는 프로그램 코드, 컴퓨터에서 사용가능한 프로그램 코드, 또는 컴퓨터에서 판독가능한 프로그램 코드를 가리킨다. 다른 실시예들에서 프로그램 코드는 메모리(206) 또는 영구 저장소(208)와 같이 컴퓨터에서 판독가능한상이한 물리적 또는 유형적인 매체에서 구현될 수 있다. 프로그램 코드(216)는 선택적으로 분리될 수 있는 컴퓨터에서 판독가능한 매체(218)에서 함수 형태로 위치하고, [0088]프로세서부(204)에 의해 실행되기 위하여 데이터 처리 시스템(200)으로 적재되거나 전송될 수 있다. 이 예들에서 프로그램 코드(216)와 컴퓨터에서 판독가능한 매체(218)는 컴퓨터 프로그램 제품(220)을 형성한다. 일례로,컴퓨터에서 판독가능한 매체(218)는 예컨대 광디스크 또는 마그네틱 디스크와 같이 유형적인 형태일 수 있는데,여기서 광디스크 또는 마그네틱 디스크는 영구 저장소(208)의 일부인 하드 드라이브와 같은 저장 장치로 전송하기 위하여 영구 저장소(208)의 일부인 드라이브 또는 다른 장치로 삽입되거나 배치된다. 유형적인 형태에 있어서, 컴퓨터에서 판독가능한 매체(218)는 하드 드라이브, 썸 드라이브 또는 데이터 처리 시스템(200)에 연결되는플래시 메모리와 같은 영구 저장소의 형태를 취할 수도 있다. 컴퓨터에서 판독가능한 매체(218)의 유형적인 형태는 컴퓨터에서 저장가능한 저장 매체를 가리키기도 한다. 일부 예들에서, 컴퓨터에서 판독가능한 매체(218)는분리가능하지 않을 수 있다.이와 달리, 프로그램 코드(216)는 통신부(210)에 대한 통신 링크 및/또는 입출력부(212)에 대한 연결을 통하여 [0089]컴퓨터에서 판독가능한 매체(218)로부터 데이터 처리 시스템(200)으로 전송될 수 있다. 상기 통신 링크 및/또는상기 연결은 설명을 위한 예들에서 물리적이거나 무선일 수 있다. 컴퓨터에서 판독가능한 매체는 또한 프로그램코드를 담고 있는 통신 링크들 또는 무선 전송들과 같은 무형의 매체 형태를 취할 수 있다. 데이터 처리 시스템(200)을 위하여 도시된 다른 구성요소들이 다른 실시예들이 구현될 수 있는 방식에 대하여 [0090]구조적인 제한들을 가하는 것을 의미하지는 않는다. 설명을 위한 다른 실시예들이 데이터 처리 시스템(200)에대하여 도시된 것들에 추가하여 또는 이를 대신하는 구성요소들을 포함하는 데이터 처리 시스템에서 구현될 수있다. 도 2에서 보인 다른 구성요소들은 도시된 설명을 위한 예들로부터 변경이 가해질 수 있다.일례로, 데이터 처리 시스템(200)의 저장 장치는 데이터를 저장할 수 있는 임의의 하드웨어 장치이다. 메모리 [0091](206), 영구 저장소(208) 및 컴퓨터에서 판독가능한 매체(218)는 유형적인 형태의 저장 장치들의 예들이다.다른 예에서, 버스 시스템은 통신 패브릭(202)을 구현하기 위하여 사용될 수 있고, 시스템 버스 또는 입출력 버 [0092]스와 같은 하나 이상의 버스들을 포함할 수 있다. 물론, 버스 시스템은 이 버스 시스템에 부착된 상이한 구성요소들 또는 장치들 사이의 데이터 전송을 제공하는 임의의 적절한 유형의 구조를 사용하여 구현될 수 있다. 게다가, 통신부는 모뎀 또는 네트워크 어댑터와 같은, 데이터 송수신을 위하여 사용되는 하나 이상의 장치들을 포함할 수 있다. 게다가, 메모리는 예컨대, 메모리(206)이거나 통신 패브릭(202)에 존재할 수 있는 인터페이스 및메모리 제어기 허브에서 발견되는 것과 같은 캐시(cache)일 수 있다.클라이언트로서, 데이터 처리 시스템(200)은 다양한 형태들을 취할 수 있다. 예를 들어, 데이터 처리 시스템 [0093](200)은 타블렛 컴퓨터, 랩탑 컴퓨터, 워크스테이션, PC, 전화 장치, 또는 PDA의 형태를 취할 수 있다. 다른 실시예들은 한 그룹의 사람들이 일련의 액션들 및/또는 이벤트들을 겪을 때 개인적으로 및/또는 집단적으 [0094]로 어떻게 반응할 수 있는지를 예측하는데 사용될 수 있는 시뮬레이션 환경을 제공한다. 이러한 방식으로, 여러가지 \"만약의 경우\"에 대한 시나리오들이 시뮬레이션될 수 있는데, 그 결과들은 상기 그룹들에 취해질 최종적인한 세트의 액션들에 대한 의사결정을 돕기 위해 사용된다. 다른 실시예들은 인간행동을 시뮬레이션하기 위하여 컴퓨터로 구현되는 방법, 장치, 및 컴퓨터에서 사용가능한 [0095]프로그램 코드를 제공한다. 한 실시예에서, 소스 코드는 도 1에서 도시된 바와 같이 네트워크 데이터 처리 시스템(100)과 같은 네트워크 데이터 처리 시스템의 저장 시스템에 위치한다. 이 소스 코드는 인간행동을 예측하기위해 사용된다. 해석기는 네트워크 데이터 처리 시스템의 하드웨어에서 동작한다. 이 해석기는 새로운 정의 및인터프리티드 소스 코드(interpreted source code)를 생성하기 위하여 소스 코드를 가지고 시뮬레이션을 수행한다. 네트워크 데이터 처리 시스템의 하드웨어에서 실행되는 GUI(Graphical User Interface) 프로세서는 인터프리티드 소스 코드를 수신하고 이 인터프리티드 소스 코드를 사용하여 장치 의존적인 출력을 생성한다. 이 장치의존적인 출력은 GUI 프로세서와 통신하는 한 세트의 장치들로 보내진다. 이 장치들은 장치 의존적인 출력을 표시하고 사용자의 입력을 받는다. 이 받아들인 사용자의 입력은 GUI 프로세 [0096]서로 보내지는데, 이후 GUI 프로세서는 받아들인 사용자의 입력을 해석기로 보낸다. 해석기는 소스 코드를 변경- 8 -공개특허 10-2010-0014329하거나 수정하기 위하여 받아들인 사용자 입력 및 새로운 정의를 사용한다. 이 예들에서, 새로운 정의는 기존의소스 코드를 변경하거나 기존의 소스 코드에 새로운 정보를 추가하기 위하여 사용되는 정보이다. 이 변경된 소스 코드는 이후에 새로운 정의들 및 새로운 인터프리티드 소스 코드를 생성하기 위하여 실행된다. 이러한 식으로, 피드백 루프는 이러한 유익한 실시예들에서 소스 코드를 수정하기 위하여 생성된다.다음으로 도 3을 참조하면, 시뮬레이션 시스템을 설명하는 도면이 유익한 실시예에 따라서 도시된다. 시스템 [0097](300)은 도 1의 네트워크 데이터 처리 시스템(100)에서 구현될 수 있는 시뮬레이션 시스템의 예이다. 특히, 시스템(300)은 도 2에서의 데이터 처리 시스템(200)과 같은 하나 이상의 데이터 처리 시스템들을 사용하여 구현될수 있다.이 예들에서, 정의(302)는 액션들(304)을 기초로 하여 시스템(300)에 의해 처리된다. 액션들(304)은 인간행동을 [0098]시뮬레이션하기 위하여 정의(302)에 적용된다. 액션들(304)은 이 예들에서 시스템(300)의 사용자에 의하여 선택될 수 있다. 액션들(304)은 또한 설정 파일로부터 또는 프로그램이나 프로세스에 의해서 선택될 수 있다. 정의(302)는 이 예들에서 시뮬레이션을 위하여 사용되는 소스 코드의 일부이다.시스템(300)은 액션들(304)을 이용하여 정의(302)를 변경해서 정의(306)를 생성한다. 도시된 예들에서, 정의 [0099](306)는 정의(302)에서 취해진 액션들(304)을 기초로 한 결과들을 제공하기 위하여 출력으로 이용되는 새로운정의이다. 게다가, 정의(306)는 정의(302)를 변경하기 위하여 사용되는데, 이후에 시뮬레이션의 수행을 계속하도록 사용된다. 이 연속적인 피드백에 의해 여러 가지 반복들로부터 학습하는 능력이 시스템(300)에 제공된다.게다가, 이전의 시뮬레이션들의 결과들은 시스템(300)으로 하여금 이전의 시뮬레이션들로부터 학습가능하도록정의(302)에 저장된다. 이 예들에서, 정의(302)는 인간들의 집단과 이 인간들의 집단이 살고 있는 환경을 표현한 것이다. 환경에 대한 [0100]서술은 유무형적인 형태 모두의 자산을 포함한다. 게다가, 정의(302)는 또한 인간들의 집단과 환경에 적용되는여러 가지 이벤트들이나 입력에 대한 액션들 및 리액션들을 한정하는 내부적인 관계들에 추가하여 그 집단에 거주할 수 있는 상이한 인간들에 대한 서술을 포함한다. 시스템(300)은 일정한 액션들이 정의(302)에서 서술된 인간들의 집단에 대하여 취해졌을 때 그 결과와 다양한 [0101]리액션들 및/또는 영향을 예측하기 위하여 시뮬레이션 도구로서 사용될 수 있다. 다시 말해, 액션들(304)이 정의(302)에 대하여 적용되거나 취해졌을 때, 시스템(300)이 예컨대 경제적, 사회적, 및 심리학적인 것과 같은 영향들에 접근(access)하도록 프로그램될 수 있다. 설명을 위한 예들에서, 정의(302)는 컴퓨터 언어를 사용하여 작성된다. 도시된 예들에서, 컴퓨터 언어는 시뮬레 [0102]이션을 수행하기 위하여 해석기를 사용하는 인터프리티드 언어지만, 실행을 위하여 컴파일을 요하지 않는다. 시뮬레이션 프로세스에 포함된 다양한 객체들을 정의하는 것이 가능하다면 어떠한 언어라도 사용될 수 있다. 예를들어, C 및 C++는 이 예들에서 사용될 수 있는 인터프리티드 언어들의 예들이다. 이 예들에서, 객체들의 정의는인간들 및 이 인간들이 살고 있는 환경들을 포함한다. 다른 유익한 실시예들은 정의(302) 및 액션들(304) 뿐만아니라 시스템(300)에 대한 프레임워크를 제공한다. 이제 도 4를 참조하면, 인간행동의 모델링 및 시뮬레이션 개발 프레임워크에 대한 도면이 유익한 실시예에 따라 [0103]서 도시된다. 프레임워크(400)는 도 3에서의 시스템(300)의 구조에 대한 예이다. 이 예에서, 프레임워크(400)는소스 코드(402), 해석기(404), GUI 프로세서(406), 및 장치들(408)을 포함한다.소스 코드(402)는 데이터베이스를 위한 모든 정보를 포함하는 프레임워크(400) 내에서의 모듈이다. 시뮬레이션 [0104]에 대하여 알려진 모든 것은 이 특별한 구성요소에 저장된다. 소스 코드(402)는 시뮬레이션을 수행하는데 필요한 모든 정보를 포함한다. 이 정보는 예컨대, 인간들의 집단에 대한 정의 및 이 정의를 사용하여 시뮬레이션을수행하는데 필요한 코드를 포함한다. 소스 코드(402)는 결과들을 제공하기 위하여 사용되는 코드뿐만 아니라 정의에서 취해질 수 있는 액션들을 포함하기도 한다. 소스 코드(402)를 위하여 사용되는 언어는 인간행동을 시뮬레이션하고 예측하는데 특유한 기능들 및 특징들을 [0105]포함하도록 변경될 수 있다. 이러한 특징들을 가진 언어를 인간행동정의언어(Human Behavior DefinitionLanguage; HBDL)라고 한다. HBDL은 C 또는 C++과 같이 현재 이용가능한 언어들을 사용하여 구현될 수 있다. 물론, 임의의 인터프리티드 언어가 이 예들에서 HBDL을 구현하기 위해 사용될 수 있다.게다가, HBDL은 인간행동의 시뮬레이션을 제공하기 위하여 변경부분들을 가진 기존의 언어를 사용하는 것보다는 [0106]완전히 새로운 언어를 사용해서 구현될 수 있다. 설명을 위한 실시예들에서, 여러 가지 언어들이 HBDL의 상이한구성요소들을 구현하기 위하여 사용될 수 있다. 이 예들에서, 소스 코드(402)는 HBDL로 작성된 데이터베이스로- 9 -공개특허 10-2010-0014329서, 상이한 지리적으로 장소들에 위치할 수 있는 여러 저장 장치들에 분산될 수 있다.해석기(404)는 시뮬레이션을 수행하기 위하여 소스 코드(402)로부터 데이터(410)를 수집한다. 이러한 설명을 위 [0107]한 예들에서, 데이터(410)는 인간들에게 적용되는 액션들뿐만 아니라 인간들의 집단 및 그들의 환경에 대한 정의들을 포함한다. 게다가, 데이터(410)는 또한 소스 코드(402)를 생성하기 위해 사용되는 프로그래밍 언어로 작성된 명령문들 또는 행들을 포함한다. 데이터(410) 내의 이들 명령문들은 시뮬레이션을 수행하도록 해석기(404)에 의해 사용된다.데이터(410) 내의 명령문들은 예컨대, 합성 인간을 시뮬레이션하는 인공 지능 프로그램을 위한 코드를 포함할 [0108]수 있다. 이 명령문들은 또한 예컨대, 퍼지 논리(Fuzzy Logic), 뉴럴 네트워크(Neural Network)들, 및 시뮬레이션을 수행하기 위해 사용되는 다른 프로세스들을 포함할 수 있다. 게다가, 데이터(410)는 또한 그 결과를 제공하기 위하여 그래픽 사용자 인터페이스(GUI)를 생성하는 프로세스들 또는 코드를 포함할 수 있다. 이러한 방식으로, 소스 코드(402)는 시뮬레이션을 수행하는데 필요한 프로세스들이나 코드뿐만 아니라 인간들의 집단과 환경에 대한 정보 양쪽 모두를 포함한다. 구현예에 따라서는, 이 명령문들이 C 또는 C++로 된 것일 수 있다. 이와달리, 명령문들은 해석기(404)가 실행을 위하여 C 또는 C++ 명령문들로 번역하는 하이 레벨 언어로 된 것일 수있다.이 시뮬레이션은 그래픽 데이터(412)를 생성하고, 그래픽 데이터(412)는 GUI 프로세서(406)로 보내진다. 이 예 [0109]들에서, 그래픽 데이터(412)는 네트워크를 느려지게 만들 수 있는 대용량 데이터 전송을 요하지는 않는 형식이다. 예시적 실시예들에서, 그래픽 데이터(412)는 프리미티브(primitive)들의 형식을 취한다. 비트맵들이나 더많은 데이터가 전송될 것이 요구되는 다른 형식들보다는 차라리 프리미티브들을 전송함으로써, 네트워크에서 사용되는 대역폭의 양이 감소된다. 일부 경우들에 있어서, 그래픽 데이터(412)에서의 약간의 비트맵들을 보낼 필요가 있을 수 있으나, 가능한 경우 프리미티브들이 사용된다. 대신에, 그래픽 데이터(412)는 장치 데이터(414)를 생성하기 위하여 GUI 프로세서(406)에 의해 처리되고, 장치 [0110]데이터(414)는 장치들(408)에 의해 표시된다. 이 예들에서, 장치 데이터(414)는 예컨대, 장치들(408)에 의해 표시되는 비트맵들 또는 픽셀 데이터일 수 있다.장치들(408)은 또한 장치 데이터(416)를 생성하기 위하여 사용자의 입력을 받을 수 있고, 장치 데이터(416)는 [0111]GUI 프로세서(406)가 수신한다. GUI 프로세서(406)는 전송을 위하여 네트워크 자원들의 사용을 적게 요하는 형식으로 장치 데이터(416)를 번역한다. 이 예들에서, 사용자 입력(418)은 해석기(404)로 보내진다. 데이터(410)로부터 시뮬레이션한 결과들과 사용자 입력(418)은 변경들(420)을 생성하기 위하여 사용된다. 변경들(420)은 소스 코드(402)를 덮어쓰거나 변경하기 위하여 사용된다. 이 변경들은 소스 코드(402)에서 정의들을 변경하기 위해 사용된다. 변경들(420)은 도 3에서의 정의(306)와 유사한데, 정의(306)는 도 3에서의 정의(302)를 수정하기위해 사용된다. 이러한 방식으로, 소스 코드(402)는 해석기(404)에 의해 수행된 시뮬레이션 결과들 및 장치들(408)로부터 받아들인 사용자 입력을 고려하여 변경될 수 있다. 변경들(420)은 또한 예컨대, 해석기(404)에 의해서 수행되는 시뮬레이션에 적용되거나 포함된 액션들의 모음을 [0112]포함할 수 있다. 이 예들에서 이 액션들의 모음 및 변경들(420)은 장치들(408)에서 생성된 사용자 입력으로부터받을 수 있다. 데이터(410)는 도 3의 정의들(302) 및 액션들(304)과 같은 정보를 포함할 수 있다. 변경들(420)은 도 3의 정의 [0113](306)에 대한 수정들과 같은 정보를 포함할 수 있다. 이러한 수정들은 예컨대, 기존 정의들에 대한 변경들이거나 새로운 정의들을 부가하는 것일 수 있다. 그래픽 데이터(412)는 이 예들에서 도 3에서의 정의(306)를 제공하기 위해 사용된다.프레임워크(400)에서의 상이한 모듈들에 대하여 설명하는 것은 이러한 모듈들이 구현될 수 있는 방식에 대한 구 [0114]조적인 제한들을 의미하고자 의도한 것이 아니다. 예를 들어, 서로 다른 모듈들은 프레임워크(400)에서 서로 다른 특징들을 구현하기 위해 서로 다른 서브 모듈들 또는 프로세스들을 포함할 수 있다. 또한, 특별한 모듈은 단일한 데이터 처리 시스템에서 구현될 수 있거나, 복수의 데이터 처리 시스템들을 통해 분산될 수 있다.프레임워크(400)의 모듈성에 있어서, 서로 다른 모듈들은 하드웨어 자원들의 사용을 최대화하기 위하여 네트워 [0115]크를 통하여 서로 다른 장소들로 분산될 수 있다. 프레임워크(400)에서의 이러한 모듈성에 의해 또한 일부 기능들의 집중화가 이루어지는 한편, 다른 기능들이 네트워크 데이터 처리 시스템에서의 원거리 장소들로 이동되거나 분산되도록 한다. 예를 들어, 집중화된 환경에 그래픽 처리 및 장치 의존적인 데이터를 배치하고 나서 네트워크를 통하여 원거리 장치로 이 정보를 보내는 것은 이점이 적다. 그래픽 데이터는 일반적으로, 용량이 크고- 10 -공개특허 10-2010-0014329네트워크를 느리게 할 수 있다. 결과적으로, 이러한 유형의 정보 및 처리의 집중화는 호출시간, 데이터 전송,및 데이터 동기화의 측면에서 문제들을 야기한다. 프레임워크(400)는 프레임워크(400)에 대한 구현들이 이러한문제들을 피할 수 있도록 설계된다.다음으로 도 5를 참조하면, 프레임워크에서의 모듈들의 분산을 설명하는 도면이 유익한 실시예에 따라서 도시된 [0116]다. 이 예에서, 시스템(500)에 도시된 서로 다른 모듈들은 도 4에서의 프레임워크(400)로부터 온 것들이다. 이도시된 예에서 볼 수 있는 바와 같이, 시스템(500)은 인터넷(502), LAN(504), WAN(506), 및 LAN(508)을 포함한다. 서로 다른 네트워크들은 도 1에 도시된 네트워크(102)의 구성요소들의 일례이다.도시된 바와 같이, 소스 코드(510)는 저장 장치(512, 514, 및 516)에 위치한다. 저장 장치(512)는 LAN(504)에 [0117]연결되고, 저장 장치(514)는 WAN(506)에 연결되고, 저장 장치(516)는 LAN(508)에 연결된다. 상이한 네트워크들에 서로 다른 장치들로부터의 소스 코드(510)를 분산시키는 것은 소스 코드(510)가 저장될 수 있는 방식의 일례이다.소스 코드(510)는 또한 여러 장소들에 저장되는 것보다는 차라리 특별한 네트워크상의 단일한 저장 시스템에 저 [0118]장될 수 있다. 소스 코드(510)를 저장하는 일부 저장 장치들은 소스 코드(510)의 복사본을 저장하는 백업장치들일 수 있다. 이러한 구현예를 이용하면, 그 구현을 특별한 하나의 장소로 제한하지 않고 다른 장소들에서 발견될 수 있는 장점들을 활용하기 위하여 시스템의 일부들을 다른 장소로 이동시키는 것이 가능하다. 해석기(518)는 이 예에서 데이터 처리 시스템(520)에 위치한다. 데이터 처리 시스템(520)은 도 2에서의 데이터 [0119]처리 시스템(200)과 같은 데이터 처리 시스템을 사용하여 구현될 수 있다. 데이터 처리 시스템(520)은 LAN(508)에 연결된다. 해석기(518)는 시뮬레이션을 수행하기 위하여 서로 다른 네트워크들을 통해 서로 다른 저장 장치들에 있는 소스 코드(510)로부터 데이터를 수집한다. 시뮬레이션의 결과들은 GUI 프로세서(522)로 보내지는데, GUI 프로세서(522)는 데이터 처리 시스템(520)에 위치 [0120]하기도 한다. GUI 프로세서(522)는 장치들(523)에서의 표시를 위하여 장치 데이터를 생성한다. 게다가, 해석기(518)는 데이터 처리 시스템(526)에서 수행되는 GUI 프로세서(524) 및 데이터 처리 시스템(530)에서 수행되는GUI 프로세서(528)에 그래픽 데이터를 보낼 수 있다. GUI 프로세서(524)는 장치들(530) 상에 표시하기 위한 장치 데이터를 생성하는 한편, GUI 프로세서(528)는 장치들(532) 상에 표시하기 위한 장치 데이터를 생성한다.GUI 프로세서들(522, 524, 및 528)은 각각 장치들(523, 530, 및 532)에 가깝게 위치한다.이러한 방식으로, 이 프로세서들에 의해 생성된 데이터는 대용량의 네트워크 자원들을 사용할 것을 요하지 않는 [0121]다. 이 예들에서, 도 4에서의 프레임워크(400)에서 설명된 GUI 프로세서 모듈은 시스템(500) 내의 여러 다른 장소들에 복사되는데, 이는 대용량의 네트워크 자원들을 사용하거나 네트워크가 느려질 수 있는 방식으로 네트워크를 통하여 원거리 장치로 그래픽 데이터를 전송하는 식의 사용을 최소화하기 위함이다.이제 도 6을 참조하면, 소스 모듈 코드를 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 소스 [0122]코드(600)는 도 4에서의 소스 코드(402)에 대한 더 상세한 설명이다.소스 코드(600)는 정의(602), 액션들(604), 및 GUI 언어(606)를 포함한다. 정의(602) 및 액션들(604)은 환경에 [0123]서의 인간들의 집단을 시뮬레이션하는 것을 대상으로 한다. GUI 언어(606)는 결과들을 제공하고 시뮬레이션의최종 사용자로부터 사용자 입력을 받기 위하여 채택된다. GUI 언어(606)를 이용하여, 소스 코드(600)는 장치들상에서 결과들을 나타내는 외관을 제어한다. 결과들의 이러한 외관은 이 예들에서 GUI 언어(606)를 사용하여 제어된다.게다가, 소스 코드(600)는 이 예들에서 적응성(adaptive)이 있고 개방적이다. 소스 코드(600)는 시뮬레이션을 [0124]위한 정보와 시뮬레이션을 실행하거나 수행하기 위하여 사용되는 실제적인 언어를 모두 포함한다. 소스 코드(600)는 데이터베이스를 판독하고 해석하는 종래의 어플리케이션으로부터 만들어진 의사결정을 제거한다. 대조적으로, 소스 코드(600)는 정보 및 어플리케이션 모두를 포함하는 데이터베이스인데, 이 데이터베이스에서의 정보 및 어플리케이션은 시뮬레이션들을 수행하여 생성된 결과들을 기초로 하여 변경될 수 있다.데이터(608)는 도 4의 해석기(404)와 같은 해석기로의 데이터 흐름을 나타낸다. 변경들(610)은 해석기로부터 수 [0125]신되는 소스 코드(600)에 대한 수정들을 나타낸다. 데이터(608)는 시뮬레이션을 수행하는데 사용하기 위하여 정의(602), 액션들(604), 및 GUI 언어(606)에서부터 해석기까지의 정보를 포함한다. 이 예들에서, 소스 코드(600)는 자유로운 형식의 데이터베이스이다.이 설명을 위한 예들에서, 소스 코드(600)는 HBDL로 작성된다. 자유로운 형식의 데이터베이스로서, 소스 코드 [0126]- 11 -공개특허 10-2010-0014329(600)는 다른 구성요소들 간에 분리자들의 석세스(success)를 요하지 않는다. 소스 코드(600) 내의 프로그램은단일한 행을 사용하여 작성될 수 있다. 소스 코드(600)는 또한 루프들, 케이스(case) 명령문들, 조건문들, 및시뮬레이션의 수행을 변경하기 위한 다른 유사한 명령문들을 포함한다. 게다가, 소스 코드(600)는 코드의 부분들을 저장하는 객체들을 포함한다. 결과적으로, 객체들은 반복될 필요없 [0127]이 몇 번이고 호출될 수 있다. 게다가, 소스 코드(600) 내에서, 객체들은 디폴트 매개변수들을 포함하도록 목록화되고 정의될 수 있다. 이러한 방식으로, 지능적인 객체들을 생성하는 것이 소스 코드(600) 내에서 가능하다.또한, 다른 유형의 변수들이 소스 코드(600) 내에서 정의될 수 있다. 이러한 유형들의 변수들은 특별한 작업들 [0128]을 대상으로 할 수 있다. 예를 들어, 소스 코드(600)는 종래의 수치적인 유형들뿐만 아니라, 인간들, 개인들,가족, 액션, 타임라인, 날짜, 다른 것들과 같은 유형들을 포함할 수 있다. 게다가, 소스 코드(600)는 시뮬레이션들을 수행하기 위한 실행 모델을 기초로 하는 타임라인을 제공한다. 인공 지능적인 구성요소들은 이러한 구성요소들을 지원하기 위한 함수 명령들과 함께 소스 코드(600) 내에서 제공될 수 있다.소스 코드(600) 내에서, 정의(602)는 인간들의 집단 및 이 인간들의 집단이 살고 있는 환경을 서술한다. 액션들 [0129](604)은 시뮬레이션하는 동안 정의(602)에 적용되는 영향들을 나타낸다. 이 예들에서, 액션들(604)은 타임라인에 입력되는 이벤트들을 가리키는 코드의 일부들이거나 단편들이다.이 예들에서, 시뮬레이션을 사용하는 인간들뿐만 아니라 시뮬레이션에 참여하는 인간들이 소스 코드(600)에 의 [0130]하여 처리된다. 시뮬레이션에 참여하는 인간들은 실제 인간들이거나 합성 인간들일 수 있다. 정의(602), 액션들(604), 및 GUI 언어(606)는 매개변수들뿐만 아니라 기능 코드를 포함한다. 다른 정보와 함께 기능 코드 및 매개변수들이 해석기에 의한 해석용 데이터(608)로서의 출력된다. 소스 코드(600)로 이러한 정보를 이동시킴으로써, 소스 코드(600)는 시뮬레이션에 대한 제어권을 가질 수 있다. [0131]이러한 방식으로, 시뮬레이션은 현재 사용되는 스타일들과 언어들로 작성된 것들과 같은 특정 어플리케이션이더 이상 아니다. 예를 들어, 일단 특별한 항목이 정의(602)에서 정의되면, 이 항목은 액션들(604)에 있는 소정의 한 세트의 액션들과 함께 사용될 수 있다. 예를 들어, 액션들(604)에서 수행되는 액션들과 함께 사용되는 정의(602)에서 유형 X인 인간이 정의될 수 있다. 결과적으로, 인간 X를 재코딩(recoding) 하지 않고 무한개의 시뮬레이션들이 생성되어 수행될 수 있으며 각각의 시뮬레이션을 위하여 수행될 수 있다.게다가, 소스 코드(600) 내에 위치한 GUI 언어(606)를 가지는 것은 정의(602) 및 액션들(604)이 사용자들에게 [0132]보이는 표시를 제어할 수 있다는 것을 의미한다. 이러한 방식으로, 소스 코드(600)는 본질적으로 시뮬레이션의사용자들이 보는 것에 대하여 담당하는 데이터베이스이다. 이러한 특징은 또한 정의들 및 지식의 재사용을 지원하여 어플리케이션을 위한 시뮬레이션 또는 각각의 시뮬레이션을 위한 프로그램을 맞춤형식으로 쓰지 않고서도무한한 수의 시뮬레이션들이 생성되도록 한다.현재의 시스템들은 스크래치 기억매체로부터 코드화된 하나의 시뮬레이션에서 정적인 데이터를 채용한다. 기껏 [0133]해야, 하나의 객체를 시뮬레이션하는 코드가 라이브러리에 보관되지만, 각각의 객체들을 위한 액션은 각각의 시뮬레이션에 대해 유일하다. 액션은 전형적으로 개별적인 프로그램으로 작성된다. 결과적으로, 현재 사용되는 기술들은 시뮬레이션의 각각의 특별한 유형을 위해 실질적인 코딩을 요한다. 게다가, 현재 관행에 있어서, GUI는전형적으로 재사용되며 어플리케이션의 통제하에 있다. 결과적으로, 이 인터페이스들은 어플리케이션을 다시 코딩하거나 재작성하지 않고서는 특별한 시뮬레이션을 변 [0134]경시킬 수 없다. 이러한 방식으로, 유익한 실시예들에서의 소스 코드 설계에 있어서, 시뮬레이션들을 위하여 현재 사용되는 기술들에 비해 결과들을 표시하고 사용자의 입력을 받는데 더 큰 유연성이 제공된다. GUI 언어(606)는 도 4에서의 GUI 프로세서(406)와 같은 GUI 프로세서를 통하여 해석기에 의해 선택적으로 보내 [0135]지는 코드를 제공한다. 이 코드는 다양한 표시부들에서 제공되는 입력 및 출력 제어들뿐만 아니라 최종 사용자에게 표시들 또는 시각정보들을 제공한다. GUI 언어(606)는 모든 최종 사용자가 자신들의 화면들에서 보는 것과모든 사용자가 시스템과 상호작용하는 방식을 제어한다. 이 설명을 위한 예들에서, GUI 언어(606)는 HBDL의 부분집합이다. 구체적인 구현에 따라서, GUI 언어(606)는 다른 유익한 특징들을 제공하기 위해 다른 언어를 사용하여 구현될 수 있다. 이러한 방식으로, 다른 유익한 실시예들은 소스 코드(600)에 대한 제어를 보여준다.소스 코드(600) 내에서 GUI 언어(606)에 의해 제어되는 입력 및 출력을 가지는 것의 장점은 최종 장치에서 제공 [0136]되는 사용자 인터페이스가 시뮬레이션에 의해 제어될 수 있다는 것이다. 시뮬레이션은 종종 서로 다른 배경들을가진 사용자들을 포함한다. 다양한 사용자 인터페이스들을 맞춤제작하는 능력은 이 사용자들이 시스템을 빨리이해하도록 돕는다. 그래서, 시뮬레이션들을 실행하기 위한 학습 곡선은 감소한다. 게다가, 가장 관련 있는 정- 12 -공개특허 10-2010-0014329보만이 서로 다른 사용자들에게 제공되는데, 이는 시뮬레이션의 타당성을 높인다.예를 들어, 서로 다른 사용자들은 특별한 시뮬레이션을 위하여 서로 다른 사용자 인터페이스들을 필요로 할 수 [0137]있다. 일부 사용자들에게는 정의(602)에 적용하기 위하여 액션들(604)로부터 특별한 액션을 선택하기 위한 사용자 인터페이스가 제공될 수 있다. 다른 사용자들은 정의(602)에서 정의된 합성 인간을 대신할 수 있다. 이러한유형의 사용자에게는 액션들을 선택하는 사용자들과는 다른 사용자 인터페이스가 제공된다.게다가, 수행되고 있는 서로 다른 시뮬레이션들은 또한 서로 다른 유형들의 인터페이스들을 요한다. 이러한 유 [0138]형의 구조는 또한 사용자 인터페이스들을 동적으로 추가하거나 단순화하는 능력을 제공한다. 이러한 방식으로,사용자 인터페이스들은 구현에 의존적인 방식으로 제공될 수 있다.부가적으로, 서로 다른 시뮬레이션들은 새로운 매개변수들 및 새로운 환경들을 강요할 것이다. 이러한 새롭고 [0139]변화하는 상황들은 서로 다른 데이터 집합들이 분석될 것이라는 것을 의미한다. 이러한 상황들은 또한 개입될서로 다른 사용자들 또는 전문가들을 위한 요구를 포함할 수 있다. 임박한 작업의 변화무쌍한 속성을 갖는 이유형은 소스 코드(600)를 통해 제공되는 융통성 있는 적응성 환경을 필요로 한다. 소스 코드(600)는 정의(602),액션들(604), 및 GUI 언어(606) 내에서 이러한 패러다임을 제공한다.이러한 설명을 위한 예들에서, GUI 프로세서는 소스 코드(600)의 제어하에 있고, 현재 사용되는 시뮬레이션 시 [0140]스템들에서 일반적으로 일어나는 것과 같은 정적 어플리케이션이 아니다. GUI 언어(606)는 하드웨어를 위한 추상 레이어(a layer of abstraction)를 제공한다. GUI 언어(606)의 내용은 시뮬레이션 프로세스가 예상할 수 있는 방식으로 일어나는 것과 다양한 사용자들 및 장치들로부터 적절한 정보가 오고 가는 것을 보장한다. GUI 언어(606)는 해석기 및 GUI 프로세서가 구현되는 임의의 하드웨어에서 실행되기 위해 필요한 모든 코드를 포함한다. 이러한 방식으로, 하드웨어 주변을 둘러싸는 더 낮은 레이어 부분들만이 하드웨어 수정들이 있을 때 재작성될 필요가 있다.이러한 설명을 위한 예들에서, GUI 언어(606)는 실행시간 동안 사용자 인터페이스의 필수적인 요소들을 만들기 [0141]위해 다양한 구성들을 제공한다. 이러한 요소들은 예를 들어, 마우즈 추적 움직임, 마우스 클릭 움직임, 아날로그 조이스틱, 메뉴들, 윈도우들, 다이얼로그 박스들, 체크박스들, 라디오 버튼들, 리스트 박스들, 및 폼들을 포함한다. 이러한 또는 다른 요소들을 사용하면, GUI를 구현하는 것이 더 쉬워진다. 게다가, GUI 언어(606)를 사용하여 GUI를 만들면서 생성된 출력은 추후에 사용하기 위해 GUI 언어(606) 내에 저장될 수 있다.GUI 언어(606)는 소스 코드(600)가 사람들의 집단과 그들이 살고 있는 환경에 대한 시뮬레이션과 관련해서 입력 [0142]을 나타내고 수신하도록 하는 많은 수의 서로 다른 특징들을 제공한다. GUI 언어(606)는 한 세트의 3차원 프리미티브들을 제공한다. 이 3차원 프리미티브들은 가상 카메라 및 보임창(view port)을 제어하기 위한 한 세트의명령어들과 같은 특징들을 지원한다. 벡터 및 메트릭스 연산들을 포함하는 수학적인 함수들도, 다른 유형의 그래픽 파일 형식들을 들여오고 내보내는 능력과 함께 포함된다.GUI 언어(606) 내에서 제공되는 특징들은 또한 단지 3차원 데이터인 것보다는 더 많이 담고 있는 3차원 객체들 [0143]을 생성하는 것을 포함한다. 예를 들어, 이 3차원 객체들은 예컨대, 가격, 무게, 색, 값, 또는 이 3차원 객체들에 대한 규칙들과 같은 다른 정보들 포함할 수 있다. 물론, 임의의 종류의 정보가 이 3차원 객체들에 포함되거나 관련될 수 있다.게다가, GUI 언어(606)는 또한 3차원 모델 및 스택과 이 모델 및 스택을 취급하기 위한 일군의 명령어들을 포함 [0144]한다. 이 3차원 모델 및 스택에 의해서 서로 다른 3차원 개체들에 적용될 복잡한 변환들이 생성될 수 있다. 이러한 방식으로, 객체들이 일시적으로 영향을 받는 서로 다른 세계들이 생성될 수 있다. GUI 언어(606)는 대용량 3차원 데이터베이스들을 간편하게 생성하고 유지보수하게 한다. 이 데이터베이스들은 [0145]정의(602) 내에서 발견될 수 있다. 데이터베이스들은 객체의 크기, 복잡성, 또는 성질에 불구하고 임의의 3차원객체를 나타내기 위해 사용될 수 있다.게다가, GUI 언어(606)는 GUI 개발 언어를 제공한다. 이 언어에 의해서 소스 코드(600)는 모든 최종 사용자 장 [0146]치의 룩앤필(look and feel)을 제어할 수 있다. GUI 언어(606)는 점들, 선들, 곡선들 및 표면들과 같은 이차원프리미티브들을 포함할 수 있다. 게다가, 한 세트의 2차원 제어 객체들 또한 존재한다. 이 2차원 제어 객체들은예컨대, 윈도우들, 다이얼로그 박스들, 리퀘스터들, 체크박스들, 라디오 버튼들, 및 메뉴들을 포함한다. 다음으로 도 7을 참조하면, 소스 코드의 정의 부분을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 정의 [0147](700)는 도 6에서의 정의(602)에 대한 더 상세한 설명이다. 정의(700)는 자산들(702), 인간들(704), 및 내부 관- 13 -공개특허 10-2010-0014329계들(706)을 포함한다.자산들(702)은 인간들이 존재하는 환경에서의 유형 자산들(708) 및 무형 자산들(710) 모두를 포함한다. 유형 자 [0148]산들(708)은 생물 및 무생물인 객체들 모두를 포함한다. 생물인 객체들은 예컨대, 가축류, 새들, 박테리아 및식물들을 포함할 수 있다. 무생물인 객체들은 예컨대, 집, 산, 호수, 자동차, 테이블, 펜, 항공기, 또는 총을포함할 수 있다.무형 자산들(710)은 예컨대, 시뮬레이션되고 있는 인간들의 집단을 위한 규칙들, 법들, 및 규정들을 포함할 수 [0149]있다. 무형 자산들(710)은 또한 자산들을 다루기 위하여 해석기에 의하여 사용되는 정보를 포함할 수 있다. 이정보는 또한 일반 코드, 라이브러리들, 및 루틴들을 포함한다.더 구체적으로, 이러한 유형의 자산은, 예컨대 수학 라이브러리, 그래픽 라이브러리, 2차원 프리미티브들의 라 [0150]이브러리, 3차원 프리미티브들의 라이브러리, 모델 및 스택 관리 라이브러리, 인공 지능 라이브러리, 입출력 라이브러리, 암호화 라이브러리, 네트워킹 라이브러리, 시스템 호출 라이브러리, 및 시간 관리 라이브러리를 포함한다. 달리 말해, 무형 자산들(710)은 시뮬레이션을 수행하기 위해 필요한 임의의 정보를 포함할 수 있다.인간들(704)은 인간들의 집단에서 나타나는 다양한 인간 특성들을 묘사한다. 인간들(704)은 인간들의 집단 내의 [0151]사람들 사이의 다양한 가족 계보들 및 관계들을 상세히 설명하는 정보를 포함할 수 있다. 게다가, 인간들(704)은 다양한 개인들을 위한 심리적인 프로파일들을 생성하기 위하여 필요한 정보를 포함한다.내부 관계들(706)은 정의(700)에서 인공 지능에 의해 사용되는 액션들 및 리액션들을 포함한다. 이 액션들 및 [0152]리액션들은 다양한 방식들로 유발될 수 있다. 예를 들어, 유발자(trigger)는 무작위이거나, 경고에 기초하거나,상태기계이거나, 정의(700)에 적용되는 한 세트의 이벤트들에 대한 리액션일 수 있다. 자산들(702) 내에서의 서로 다른 객체들은 필요한 함수들과 계산들을 수행하기 위하여 무형 자산들(710)에 의존 [0153]할 수 있다. 일반 코드, 라이브러리들, 및 루틴들은 서로 다른 프로그래밍 작업들을 지원하기 위해 필요한 코드이다. 이 서로 다른 구성요소들은 시뮬레이션을 수행하는데 사용하기 위하여 데이터로서 해석기로 보내질 수 있다. 3차원 객체들은 다른 세계를 구성하는 모든 객체들로서 생물 및 무생물 객체들을 포함한다.이제 도 8을 참조하면, 객체의 블록도가 유익한 실시예에 따라서 도시된다. 이 예에서, 객체(800)는 도 6에서의 [0154]정의(602) 내에 있는 객체의 예시적 구현예이다. 이 설명을 위한 예에서, 객체(800)는 인공 지능(802), 특성들(804), 및 내부 관계들(806)을 포함한다.인공 지능(802)은 특별한 객체를 시뮬레이션하기 위해 사용된 코드를 포함한다. 이 예들에서, 객체(800)는 [0155]인간, 식물, 또는 동물과 같이 살아 있는 객체이다. 인공 지능(802)은 선택된 객체의 액션들 및 리액션들을 시뮬레이션하기 위해 필요한 코드를 포함한다.특성들(804)은 특별한 객체를 위한 특성들의 식별을 포함한다. 예를 들어, 만약 객체(802)가 사람이라면, 특성 [0156]들(804)은 예컨대, 신장, 체중, 피부색, 머리카락의 색, 눈의 색, 체형, 및 사람의 임의의 다른 적절한 특성을포함할 수 있다. 특성들(804)은 예컨대, 그 사람이 얼마나 빨리 달릴 수 있는지, 그 사람의 민첩함, 및 그 사람의 체력과 같은 다른 육체적인 특성들을 포함할 수 있다. 특성들(804)에서 육체적이지 않은 특성들은 예컨대 끈기, 열정, 감성들, 지능, 및 대인 관계들과 같은 것들을 [0157]포함할 수 있는데 이에 제한되는 것은 아니다. 특성들(804)은 객체(800)의 액션들 및 리액션들을 시뮬레이션하기 위해 인공 지능(802)에 의해 사용된다. 특히, 특성들(804)은 도시된 예들에서 인간행동을 시뮬레이션하기 위해 사용된다.인공 지능(802)의 복잡성 및 특성들(804) 내에서의 특성들의 수는 구체적인 구현예에 따라서 다를 것이다. 현실 [0158]의 객체들과 구별될 수 없는 시뮬레이션을 만들기 위하여 요구되는 능력이 증가함에 따라서 이 구성요소들의 복잡성은 증가한다.내부 관계들(806)은 이벤트들을 유발하기 위하여 인공 지능(802)에 의해 사용될 수 있는 액션들 및 리액션들을 [0159]포함한다. 이 이벤트들은 예컨대, 객체(800)에 의해 취해진 액션들을 포함한다. 이 액션들은 객체(800)에 의해시작될 수 있고, 또는 이 액션들은 객체(800)에 취해진 액션들에 반응하여 발생한 것들일 수 있다. 객체(800)에의해 취해진 이 액션들은 객체(800)를 대상으로 한 것일 수 있고, 또는 시뮬레이션 동안에 객체(800)가 존재하는 환경을 기초로 하여 객체(800)에 의해 인식된 것들일 수 있다.이제 도 9를 참조하면, 객체에 대한 도면이 유익한 실시예에 따라서 도시된다. 이 예에서, 객체(900)는 도 6에 [0160]- 14 -공개특허 10-2010-0014329서의 정의(602)를 가지고 시뮬레이션될 수 있는 무생물 객체의 예이다. 객체(900)는 예컨대, 자동차, 펜, 항공기, 산, 또는 호수일 수 있다.이 예에서, 객체(900)는 모델(902) 및 특성들(904)을 포함한다. 모델(902)은 특별한 객체를 시뮬레이션하기 위 [0161]해 사용되는 코드를 포함한다. 모델(902)은 특별한 객체의 기능들을 시뮬레이션하기 위해 코드를 포함한다. 예를 들어, 만일 객체(900)가 자동차라면 일정한 결과들을 생성하는 자동차에서 다양한 액션들이 수행될 수 있다.예를 들어, 엔진이 켜질 수 있고 바퀴가 구를 수 있다.모델(902)은 예컨대, 수학적인 모델이다. 예를 들어, 한 세트의 유한 상태 기계들이 자동차의 기능들과 동작을 [0162]모델링하기 위해 사용될 수 있다. 시간이 지나면서 환경에 노출되고 사용되는 것을 통해 모델링되고 있는 객체가 노화되는 것을 시뮬레이션하기 위한 것들과 같은 다른 기능들 및 프로세스들이 모델(902)에 포함될 수 있다.특성들(904)은 예컨대, 타이어 크기, 엔진 크기, 페인트 색, 라디오 종류, 및 내부 공간의 크기와 같은 자동차 [0163]의 다양한 특성들을 식별시킨다. 게다가, 특성들(904)은 또한 객체(900)를 위한 자동차의 특징들에 대한 다른정보를 포함할 수 있다. 예를 들어, 타이어의 접지면적이 특성들(904) 내에서 특별한 타이어 유형을 위해 식별될 수 있다.모델(902)은 자동차를 운전하는 사용자, 특성들(904)에서 식별되는 타이어들에서 발생하는 손상과 마모와 같이 [0164]객체(900)에 의해 취해진 다양한 액션들에 대하여 자동차가 반응하는 것을 시뮬레이션하기 위해 사용된다. 이러한 손상과 마모는 특성들(904) 내에 기록된다. 손상과 마모는 모델(902) 내에 있는 알고리즘의 일부일 수 있다.게다가, 자동차의 예에서 모델(902)이 노화된 것을 나타내기 위하여 태양과 우박과 같은 환경적인 노출이 모델(902)에 의해 고려될 수 있다. 도 8에서의 객체(800) 및 도 9에서의 객체(900)에 의해 수행된 서로 다른 액션들이 이 객체들에서 수행될 수 있고, 도 6에서의 액션들(604) 내에서 정의될 수 있다.이제 도 10을 참조하면, 액션 객체에 대한 도면이 유익한 실시예에 따라서 도시된다. 이 예에서, 액션 객체 [0165](1000)는 도 6에서의 액션들(604) 내에서 발견될 수 있는 액션의 예이다.액션 객체(1000)는 액션(1002), 객체(1004), 사용자 권한들(1006), 및 GUI(1008)를 포함한다. 액션(1002)은 예 [0166]컨대, 대화하기, 때리기, 움직이기, 앉기, 붙잡기, 말하기, 또는 바라보기와 같은 것들이 수행될 수 있는 액션일 수 있다. 객체(1004)는 액션이 취해질 수 있는 객체에 대한 식별자이다. 사용자 권한들(1006)은 특별한 사용자가 객체(1004)에 대해 액션(1002)을 취할 수 있는지 여부를 결정한다. GUI(1008)는 특별한 사용자에게 제공되는 사용자 인터페이스의 유형을 식별시킨다.객체(1004)는 생명이 없는 객체 또는 생명이 있는 객체일 수 있다. 사용자 권한들(1006)은 일정한 사용자들이 [0167]객체에 대해 선별적인 액션들을 취할 수 있을지 여부를 결정하기 위해 사용된다. 일부 경우들에서는, 특별한 사용자가 객체에 대해 액션을 취하는 것이 바람직하지 않다. GUI(1008)는 객체와의 사용자 상호작용들이 어떻게발생할지 뿐만 아니라 객체에 대한 액션이 사용자에게 제공되는 방식을 식별시킨다.도 8, 9, 및 10에서의 객체에 대한 설명들은 현재 이용가능한 프로그래밍 언어들 및 방법론들을 사용하여 도 6 [0168]에서의 소스 코드(600)가 구현될 수 있는 하나의 방법을 설명할 목적으로 제시된다. 그러나, 이 예들은 도 6에서의 소스 코드(600)가 구현될 수 있는 방식에 대한 제한들을 의미하는 것으로 의도한 것은 아니다.이제 도 11을 참조하면, 액션들을 적용하는 것을 설명하는 도면이 유익한 실시예에 따라서 도시된다. 이 예들에 [0169]서, 타임라인(1100)은 도 6에서의 정의(602)와 같은 정의가 시뮬레이션 중에 받는 영향들을 도시한다. 이 설명을 위한 예들에서, 도 6에서의 액션들(604)과 같은 액션들은 타임라인(1100) 상에서 이벤트들을 가리킨다. 이액션들은 코드의 단편들 또는 일부들이다. 특히, 액션들은 이벤트들(1102), 이벤트들(1104), 이벤트들(1106),및 이벤트들(1108)을 포함한다. 이 예에서, 이벤트들(1102)은 시간 슬롯(1110)에서 적용된다. 이벤트들(1104)은시간 슬롯(1112) 중에 발생하고, 이벤트들(1106)은 시간 슬롯(1114) 중에 적용된다. 이벤트들(1108)은 시간 슬롯(1116) 동안 발생한다. 이 이벤트들은 본질적으로 순차적이거나 이벤트 드리븐(event driven)일 수 있다. 다시 말해, 이벤트들은 해석기에 의해 보내지거나 생성된 다양한 메시지들에 반응하여 적용될 수 있다.이 예들에서, 타임라인(1100)의 실행에 의해 발행되는 마스터 인터럽트는 필요하다면 실행 중간에 이 이벤트들 [0170]을 인터럽트하고, 시뮬레이션은 시뮬레이션의 다음 시간 슬롯으로 즉시 넘어간다. 소스 코드의 실행이 순차적이거나 이벤트 드리븐인 경우에 해당하는 현재 사용되는 프로그램 언어들과는 달리, 소스 코드에서 액션들은 유익한 실시예들에서 시간 기반 실행 모델을 따른다. 이 예들에서, 시간 슬롯들은 다양한 크기를 가질 수 있다. 예를 들어, 각각의 시간 슬롯은 일주일, 하루, 한 시간, 일분, 또는 시간의 일정한 다른 기간을 나타낼 수 있다.- 15 -공개특허 10-2010-0014329도시된 실시예들에서, 타임라인(1100)은 이하에서 더 상세하게 서술되는 스케줄러의 감독하에 흘러간다. 스케줄 [0171]러는 타임라인(1100)과 관련이 있거나 이에 붙어 있는 이벤트들(1102, 1104, 1106, 및 1108)을 실행한다. 스케줄러는 이 이벤트들에 대하여 완전한 제어를 가지고, 필요에 따라서 이벤트들을 인터럽트할 수 있다. 게다가,스케줄러는 메모리 관리자 및 메모리 복구 장치를 실행한다. 이러한 식으로 인터럽트된 작업을 위하여 할당된모든 메모리는 이후의 이벤트들에서 이용가능하게 될 수 있다.이제 도 12를 참조하면, 스케줄러 인터럽트를 가진 타임라인 상에서 액션들을 적용하는 것을 설명하는 도면이 [0172]유익한 실시예에 따라서 도시된다. 이 예에서, 타임라인(1200)은 이벤트들(1202) 및 이벤트들(1204)을포함한다. 이벤트들(1202)은 타임라인(1200) 상에서 시간 슬롯(1206) 동안에 실행을 시작한다. 이 예에서, 이벤트들(1202)은 입력(1208), 결정들(1210), 및 처리(1212)를 포함한다. 이벤트들(1202)은 시간 슬롯(1206) 중에실행을 시작한다. 시간 슬롯(1206)이 끝났을 때, 스케줄러는 지점(1214)에서 이벤트들(1202)의 실행을 인터럽트한다. 이후에 실행은 시간 슬롯(1206) 다음에 시작하는 시간 슬롯(1216)을 위한 이벤트들(1204)로 이동한다. 이예에서, 시간 슬록(1206) 및 시간 슬롯(1216) 사이에는 어떠한 겹침도 존재하지 않는다.다음으로 도 13을 참조하면, 시간 슬롯들이 겹치는 이벤트들의 적용을 설명하는 도면이 유익한 실시에에 따라서 [0173]도시된다. 이 예에서, 스케줄러는 다양한 시간 슬롯들에 부착된 이벤트들(1302, 1304, 1306, 및 1308)을 가지는타임라인(1300)을 실행한다. 이벤트들(1302)은 시간 슬롯(1310)에 부착된다. 이벤트들(1304)은 시간 슬롯(1312)에 부착되거나 관련된다. 이벤트들(1306 및 1308)은 각각 시간 슬롯들(1314 및 1316)에 부착된다.이 설명을 위한 예에서, 서로 다른 시간 슬롯들은 서로 겹칠 수 있다. 달리 말해, 하나의 시간 슬롯은 다른 시 [0174]간 슬롯보다 더 긴 시간 기간 동안 지속될 수 있다. 도시된 바와 같이, 시간 슬롯(1310) 및 시간 슬롯(1312)은서로 겹친다. 결과적으로, 이벤트들(1302) 및 이벤트들(1304)은 시간 슬롯들(1310) 및 시간 슬롯들(1312)이 겹치는 시간의 특정 기간 동안 동시에 실행될 수 있다. 이 특별한 예에서, 이벤트들(1302)은 실행되는데 더 많은시간이 제공된다.시간 슬롯들이 겹치는 것은 그 겹침이 일어나는 시간의 순간 동안에 이벤트들이 병합되는 것을 의미하지 [0175]않는다. 이 설명을 위한 예들에서, 만일 어떤 이유로든 시간 슬롯(1310)을 위한 이벤트들(1302)의 인터럽트가발생하고, 만일 이 인터럽트가 시간 슬롯(1312)의 시작 전 또는 실행 동안에 발생한다면, 제어는 시간 슬롯(1312)으로 넘어간다. 그러나, 만일 이 인터럽트가 시간 슬롯(1310) 동안에 그러나 시간 슬롯(1312)이 종료한후에 발생한다면, 제어는 시간 슬롯(1314)에서의 이벤트들(1306)의 실행으로 넘어간다.이제 도 14, 15, 및 16을 참조하면, 지속적인 이벤트들을 설명하는 도면들이 유익한 실시예를 따라서 도시된다. [0176]도시된 바와 같이, 타임라인(1400)은 시간 슬롯(1408)에 부착되거나 할당된 이벤트들(1402), 지속적인 이벤트(1404), 및 이벤트들(1406)을 포함한다. 이벤트들(1410)은 타임라인(1400)에서의 시간 슬롯(1412)과 관련이 있다. 이벤트들(1414)은 시간 슬롯(1416)에 부착되는 한편, 이벤트들(1418)은 시간 슬롯(1420)에 부착된다. 이벤트들은 인터럽트 할 수 없도록 만들어지거나 확장들이 주어질 수 있다. 이러한 유형의 이벤트는 최종 사용자로부터 또는 아직 종료되지는 않았으나 필요한 일부 다른 이벤트로부터 오는 입력을 기다릴 때 존재할 수 있다.이러한 예들에서, 이러한 유형의 이벤트는 지속적인 이벤트(1404)와 같은 지속적인 이벤트이다. 지속적인 이벤트(1404)는 이 이벤트가 완전히 발생할 때까지 하나의 시간 슬롯에서부터 다른 시간 슬롯까지 걸쳐서 수행될 수있다.도 15에서 도시된 바와 같이, 지속적인 이벤트(1404)는 시간 슬롯(1412)에 부착된다. 도 16에서 지속적인 이벤 [0177]트(1404)는 시간 슬롯(1416)으로 확장되거나 이동된다. 지속적인 이벤트(1404)는 이러한 예들에서 이러한 특별한 시간 슬롯 동안에 완성된다.이제 도 17을 참조하면, 해석기를 설명하는 도면이 유익한 실시예에 따라서 도시된다. 해석기(1700)는 도 4에서 [0178]의 해석기(404)에 대한 더 상세한 설명이다. 해석기(1700)는 하나의 언어로 작성된 소스 코드를 다른 언어로 작성된 목적 코드로 변환하는 프로그램이다. 해석기(1700)는 또한 해석기가 소스 코드의 처리를 수행하는 동안 목적 코드를 실행한다. 이 목적 언어는 다른 고수준 언어로 또는 특별한 데이터 처리 시스템 또는 프로세서에 의해 사용되는 언어로 작성될 수 있다.정확하게 해석되고 실행되는 임의의 프로그램에 대하여, 소스 코드는 해당 언어에 의해 정의된 구문들에 따라 [0179]구조화된다. 특히, 이 구문들은 구문론상의 구문들이다. 구문들의 완전한 집합은 소스 코드를 위한 언어의 문법을 형성한다. 이 구문들에 따라 구조화되지 않거나 문법적으로 부정확한 임의의 코드는 해석기(1700)에 의해 버려진다. - 16 -공개특허 10-2010-0014329해석기(1700)는 통신 모듈들(1702) 및 언어 해석기(1704)를 포함한다. 게다가, 해석기(1700)는 암호화/복호화 [0180]모듈들(1706)을 포함하고, 암호화/복호화 모듈들(1706)은 도 4에서의 GUI 프로세서(406)와 같은 GUI 프로세서와해석기(1700) 사이에서 정보를 안전하게 주고 받을 수 있게 한다. 이 설명을 위한 예들에서, 언어 해석기(1704)는 HBDL(1708)을 수신한다. HBDL(1708)은 도 4에서의 소스 코드 [0181](402)와 같은 소스 코드 모듈로부터 수신된, 도 4에서의 데이터(410)와 같은 데이터의 예이다. HBDL(1708)은 시뮬레이션을 수행하기 위하여 언어 해석기(1704)에 의해 해석된다. 그 결과들은 암호화를 위하여 암호화/복호화모듈(1706)로 보내지는 인터프리티드 HBDL(IHBDL)(1710)이다. 암호화 이후에, 암호화 결과들은 암호화된 인터프리티드 HBDL(EIHBDL)(1712)로서 도 4에서의 GUI 프로세서(406)와 같은 GUI 프로세서로 보내진다. EIHBDL(1712)은 도 4에서의 그래픽 데이터(412)의 예이다. 한 세트의 장치들로부터 GUI 프로세서에 의해 수집된 바와 같이사용자 입력은 암호화된 HBDL(EHBDL)(1714)로서 수신된다. EHBDL(1714)은 도 4에서의 사용자 입력(418)의 예이다. 이 암호화된 정보는 복호화되고 HBDL(1716)로서 통신 모듈들(1702)로 보내진다.HBDL(1716)은 소스 코드를 변경하기 위해 사용되는 사용자 입력의 예이다. 이 변경은 예컨대, 소스 코드 내에서 [0182]정의들을 바꾸거나 정의들에 적용될 액션들을 선택하는 것일 수 있다. 게다가, 언어 해석기(1704)의 출력은 소스 코드를 수정하는데 사용하기 위해 HBDL(1718)로서 통신 모듈(1702)로 보내진다. HBDL(1716) 및 HBDL(1718)은 HBDL(1720)을 형성하기 위해 통신 모듈들(1702)에 의해 사용되고, HBDL(1720)은 소스 코드를 변경하기 위해사용된다. HBDL(1720)은 소스 코드를 변경하기 위해 사용되는 도 4에서의 변경들(420)에 대한 형식의 예이다.도시된 바와 같이, HBDL(1718)은 소스 코드를 변경하기 위하여 언어 해석기(1704)에 의해 생성된 출력에 대한피드백을 제공한다.더 구체적으로, 통신 모듈들(1702)은 디스패처 모듈(1722), 입력 모듈(1724), 및 등록 모듈(1726)을 포함한다. [0183]언어 해석기(1704)는 형태소 분석기(1728), 문법 구문분석기(1730), 및 실행 모듈들(1732)을 포함한다.언어 해석기(1704)는 형태소 분석, 문법 구문분석, 및 의사결정을 다루는 모듈들을 포함한다. 데이터가 [0184]HBDL(1708)로서 수신될 때, 형태소 분석기(1728)는 HBDL(1708)내의 데이터를 소스 코드 언어에서의 개별적인 토큰들 또는 단어들로 구분한다. 이 설명을 위한 예들에서, 소스 코드는 HBDL로 작성된다. 달리 말해, 형태소 분석기(1728)는 HBDL(1708)에서 서로 다른 토큰들 또는 구성 요소들을 식별한다. 이 토큰들은 문법 구문분석기(1730)로 보내지는데, 문법 구문분석기(1730)는 이 토큰들을 HBDL(1708)을 위하여 의미 있는 문장들 또는 명령문들로 분류한다. 일단 HBDL(1708)에서 문장 또는 명령문이 구성되면, 문법 구문분석기(1730)는 실행 모듈(1732)로 이 문장을 보낸다. 그 후 결과적으로 이 명령문을 기초로 하는 액션이 취해진다.실행 모듈(1732)은 시뮬레이션들을 수행하기 위한 많은 서로 다른 서브모듈들을 포함한다. 이 예들에서, 실행 [0185]모듈(1732)은 인터프리티드 HBDL(IHBDL)(1710) 및 HBDL(1718)을 생성한다. HBDL(1710)은 그래픽 프리미티브들과 같은 그래픽 데이터의 형태를 취한다. HBDL(1718)은 소스 코드를 변경하기 위해 사용되는, 변경되었거나 새로운 정의이다. HBDL(1718)는 소스 코드를 변경하거나 재작성하는데 사용하기 위하여 입력 모듈(1724)로 보내진다. 입력 모듈(1724)은 HBDL(1718)에서의 새로운 정의를 디스패처 모듈(1722)로 전달하는데, 디스패처 모듈(1722)은 HBDL(1720)이 소스 코드로 작성되도록 분배한다. 이 설명을 위한 실시예들에서, 문법 구문분석기(1730)는 형태소 분석기(1728) 및 실행 모듈(1732)을 [0186]시작시킨다. 문법 구문분석기(1730)는 형태소 분석기(1728)로부터 토큰들을 요청한다. 형태소 분석기(1728)는토큰들을 생성하기 위하여 HBDL(1708)로부터 문자들을 수신한다. 토큰이 생성될 때마다, 형태소 분석기(1728)는그 토큰을 문법 구문분석기(1730)로 보낸다. 문법 구문분석기(1730)는 그 토큰을 사용하여 하나 이상의 구문분석 트리들을 생성한다. 구문분석 트리가 완성되면, 문법 구문분석기(1730)는 완성된 구문분석 트리를 기초로 하여 실행 모듈(1732)에 의하여 실행될 액션을 요청한다.이 설명을 위한 예들에서, 각각의 구문분석 트리는 제작물을 나타낸다. 일련의 토큰들이 제작물을 위한 정의와 [0187]일치할 때마다, 제작물은 종료 또는 실행되는 한 세트의 하나 이상의 액션들을 가진다. 문법 구문분석기(1730)로부터의 요청에 응하여, 임의의 의미론적 오류들이 액션들을 위한 명령어들에서 발견되는지 여부를 판단하기위하여 실행 모듈(1732)은 의미론적인 분석을 수행한다. 만약 오류가 발생하면, 그 오류는 보고된다. 그렇지 않으면, 한 세트의 액션들을 위한 명령어들이 실행된다. 액션들이 그 방법에 따라 할당되어 완성된 제작물들에 대하여 종료된 상태로 비-단말(non-terminal) 호출자들로의 재귀적 복귀가 이루어진다.이 예들에서, 실행 모듈(1732)은 문법 구문분석기(1730)에 의해 만들어진 구문분석 트리들에서 생성된 명령어들 [0188]이 의미상으로 올바른지 여부를 판단한다. 만약 의미상의 오류들이 발생하면, 실행 모듈(1732)은 이 예들에서- 17 -공개특허 10-2010-0014329오류를 생성하고 그 명령어를 무시한다. 그러나, 일부 경우에는 실행 모듈(1732)이 정정되기에 충분한 정보가존재한다면 이 오류들이 정정될 수 있다.사용자 입력이 EHBDL(1714)로서 수신될 때, 암호화/복호화 모듈들(1706)은 HBDL(1716)을 형성하기 위하여 정보 [0189]를 복호화한다. HBDL(1716)은 HBDL이 암호화되지 않은 형태로 되어 있는 사용자 입력이며, HBDL은 등록 모듈들(1702)에 의해 수신된다. 등록 모듈(1726)은 사용자 입력을 보내는 각각의 사용자들을 등록하고 유효성을 확인한다. 이 등록 모듈은 권한을 부여받거나 등록된 사용자들만이 시스템으로 입력을 보내는 것이 허용된다는 것을보증한다. 예를 들어, 등록 모듈(1726)은 특별한 사용자를 위한 비밀번호에 대한 유효성을 확인할 수 있다.일단 사용자에 대한 유효성이 확인되면, HBDL(1716)로 된 사용자 입력은 입력 모듈(1724)로 전달된다. 입력 모 [0190]듈(1724)은 모든 형태의 입력을 한군데로 모으는 구심점으로 동작하고, 특정한 명령어들을 가진 입력을 디스패처 모듈(1722)로 보낸다. 입력 모듈(1724)은 입력을 처리하기 위하여 디스패처 모듈(1722)이 필요로 하는 명령어들을 부가할 수 있다. 이 예들에서 입력은 소스 코드에서 수정될 것을 정의한다.특정한 명령어들은 이 예들에서 특별한 사용자에 의해 소스 코드의 어떤 부분들이 변경될 수 있는가에 대한 명 [0191]령어들과 같은 명령어들을 포함한다. 예를 들어, 사용자 입력이 정의를 변경한다면, 명령어는 소스 코드의 어떤부분이 수정될지를 알려준다. 입력에 의해 변경될 소스 코드 부분은 입력을 생성하는 사용자에 대한 식별자 및입력 그 자체를 사용하여 식별될 수 있다.그 다음에, 디스패처(dispatcher) 모듈(1722)은 HBDL(1720)이 소스 코드로 돌려보내질 때 소스 코드의 적절한 [0192]부분이 재작성되는 것을 보증한다. 디스패처 모듈(1722)은 사용자에 대한 식별자, 입력, 작성될 소스 코드 부분을 가지고 폴리시(policy)를 사용하여 소스 코드를 작성할지 여부를 판단한다. 이 폴리시는 입력에 대한 응답으로 소스 코드에 기입(write)이 이루어져야 하는지 여부를 판단하기 위하여 사용되는 한 세트의 규칙들이다. 이폴리시는 권한 없는 사용자가 등록 모듈(1726)을 통과할 수 있는 경우들을 막기 위하여 여분의 정보를제공한다. 예를 들어, 권한 없는 사용자는 진정한 사용자로 위장할 수 있고, 입력을 보낼 수 있다. 폴리시는 이입력에 대하여 진정한 사용자에 의하여 만들어지지 않았거나 진정한 사용자에 의하여 행해진 입력의 특징이 아닌 변화들이라고 식별할 수 있다. 이 경우에, 이 입력은 디스패처 모듈(1722)에 의해 거절된다. 이 예들에서, 각각의 사용자는 사용자가 부가하거나 변경할 수 있는 그들 자신의 한 세트의 액션 세트를 [0193]가진다. 결과적으로, 사용자들은 소스 코드의 액션 부분을 변경할 수만 있다. 실행 모듈(1732)로부터의 출력,HBDL(1718)은 액션들뿐만 아니라 정의들을 재작성하기 위해 사용될 수 있다. 이 예들에서, 언어 해석기(1704)는시스템에서 다른 사용자로도 취급된다. 그러나, 해석기는 영구적으로 권한을 부여받은 사용자이다. 디스패처 모듈(1722)은 언어 해석기(1704)에 대하여 HBDL(1718)을 사용해서 정의들을 재작성하기 위한 것으로 이해한다.결과적으로, 시뮬레이션의 임의의 주어진 지점에서, 실제의 인간인 최종 사용자는 데이터베이스에서 정의된 임 [0194]의의 인간을 대신할 수 있다. 이 데이터 흐름을 통해서, 해석기(1700)는 소스 코드를 재작성하거나 변경할 수있다. 시간이 흘러가고 시뮬레이션들이 진행되는 동안에, 정의들은 소스 코드를 재작성하기 위해 끊임없이 생성된다. 입력 모듈(1724)은 시뮬레이션에서 실행되고 있는 \"가상 세계\"와 시스템과 통신하는 장치들에서의 사용자들에 [0195]의한 사용자 입력을 통해 수신되는 것으로서의 \"현실 세계\" 사이의 연결을 제공한다. 디스패처 모듈(1722)은 소스 코드를 변경하기 위하여 새로운 정의들을 작성하기 위한 메커니즘을 제공한다.다음으로 도 18을 참조하면, 형태소 분석기를 위한 데이터 흐름을 설명하는 도면이 유익한 실시예에 따라서 도 [0196]시된다. 도시된 바와 같이, 형태소 분석기(1800)는 소스(1802)를 수신하고, 토큰들(1804)을 생성하기 위해 소스(1802)를 처리한다. 형태소 분석기(1800)는 도 17에서의 형태소 분석기(1728)의 예이다. 형태소 분석기(1800)는문자단위로 소스(1802)로부터 내용을 읽고, 소스(1802)로부터 들어오는 문자들을 토큰들(1804) 등의 토큰들을가리키는 기본 단위들로 분류한다. 이러한 예들에서 정규 표현식들(1806)에서의 한 세트의 토큰 설명들을 사용하여 소스(1802)에서의 문자들을 토 [0197]큰들(1804)로 분류하는 것이 수행된다. 정규 표현식들(1806)은 소스(1802) 내의 문자들을 토큰들(1804)로 분류하기 위해 필요한 설명들을 포함한다. 이 예들에서, 정규 표현식들(1806)은 스크립트들을 사용해서 구현될 수있다. 이 스크립트들은 문자들을 토큰들로 분류하는데 사용하기 위한 문자 패턴들을 설명하는 언어 기호들을 이용한다.정규 표현식들(1806)에서 정의된 각각의 정규 표현식은 기호가 할당된다. 이 기호는 전형적으로 숫자이다. 형태 [0198]소 분석기(1800)에 의해 토큰들(1804)에서 생성된 토큰은 정규 표현식들(1806)에서의 특별한 정규 표현식을 위- 18 -공개특허 10-2010-0014329한 기호를 사용하여 식별된다.형태소 분석기(1800)는 정규 표현식들(1806) 외에도 예약어들(1808)도 사용한다. 토큰이 소스(1802) 내에서 식 [0199]별될 때 예약어들(1808) 내의 단어들 또한 기호가 할당된다. 예약어는 언어에서 특별한 문법적인 의미를 지닌단어이고, 그 언어에서 식별자로서 사용될 수 없다.이제 도 19를 참조하면, 문법 구문분석기에 의해 수행되는 파싱(parsing) 또는 구문분석을 설명하는 도면이 유 [0200]익한 실시예에 따라서 도시된다. 도 19에서 도시된 구문분석은 도 17에서의 문법 구문분석기(1730)에 의해 수행될 수 있다. 트리(1900)는 토큰들을 분류하기 위하여 문법 구문분석기에 의해 사용될 수 있는 구문분석 트리의예이다. 이 예에서, 명령문(1902)에 대한 구문분석이 설명된다. 명령문(1902)은 \"var1=20\"이다. 이 명령문은 해석기에 의해 수행될 액션들을 다루고 정의하기 위하여 사용된다.특히, 문법 구문분석기는 제작물들이라고도 불리는 한 세트의 구문 구조들을 기초로 하여 형태소 분석기에 의해 [0201]만들어지는 토큰들 사이의 관계들을 식별한다. 각각의 제작물은 논리 단위를 나타내고, 전형적으로 다른 논리단위들에서는 토큰들을 사용하여 정의된다. 대부분의 언어들은 두 가지 광역 유형의 논리 단위들을 정의한다.이 논리 단위들은 이 예들에서 명령문들 및 식들이다. 일반적으로 식들은 값들을 제공하는 구문론상의 언어 구조들이다. 명령문들은 변수들의 상태를 바꾸거나, 프로그램의 흐름을 제어하거나, 당해 언어에 의해 지원되는다른 연산들을 수행하는 구문론상의 구조들이다.문법 구문분석기는 일련의 토큰들을 논리 단위들로 분류하고, 이 논리 단위들을 기초로 하여 실행 모듈에게 액 [0202]션들을 실행하라고 지시한다. 이 예에서, 명령문(1902)은 형태소 분석기에 의해 생성되는 일련의 토큰들을 포함한다. 이 토큰들은 변수명(1904), 등호(1906), 식(1908), 및 개행문자(1910)이다. 식(1908)은 정수인 정수(1912)를 포함한다. 변수명(1904)을 위한 값은 var1이고; 등호(1906)를 위한 값은 =이고; 정수(1912)를 위한 값은 20이고; 개행문자(1910)를 위한 값은 이다. 도시된 바와 같이, 일련의 토큰들이 주어지면 문법 구문분석기는 스트림에서의 토큰들의 순서를 기초로 하여 문법을 재생성한다.이제 도 20을 참조하면, 구문분석 트리의 다른 예를 설명하는 도면이 유익한 실시예에 따라서 도시된다. 이 예 [0203]에서, 구문분석 트리(2000)는 명령문(2002)로부터 생성된다. 이 예에서, 명령문(2002)은output=var1+var2*var3이다. 이 예에서, 명령문(2002)을 위한 토큰들은 변수명(2004), 등호(2006), 변수명(2008), 덧셈(2010), 변수명 [0204](2012), 곱셈(2014), 변수명(2016), 및 개행문자(2018)를 포함한다. 변수명(2004)은 값으로 OUTPUT을 가지고;등호(2006)는 값으로 =를 가지고; 변수명(2008)은 값으로 var1를 가지고; 덧셈(2010)은 값으로 +를 가지고; 변수명(2012)은 값으로 var2를 가지고; 곱셈(2014)은 값으로 *를 가지고; 변수명(2016)은 값으로 var3를 가지고;개행문자(2018)는 값으로 을 가진다. 명령문(2002)에 대한 \"=\" 기호의 반대편 식은 토큰들인 변수명(2008),덧셈(2010), 변수명(2012), 곱셈(2014), 및 변수명(2016)에 의하여 한정된다. 노드들을 식별시키는 것과 관련하여 식들 및 당해 언어에서의 식들의 사용법에 대한 식별자는 구문분석 트리 [0205](2000) 내에서 토큰들의 위치를 통해 표시된다. 예를 들어, 식(2020)은 식들(2022 및 2026)이 연산자(2024)를사용하여 연산이 되는 것을 나타낸다. 이 경우에, 연산자(2024)는 덧셈(2010)이다. 식(2020)은 또한 식(2026)을포함하는데, 식(2026)은 식들(2028 및 2030)이 연산자(2032)를 사용하여 연산이 되는 것으로 식별한다. 이 예에서, 식(2022)은 변수명(2008)을 포함하는 반면, 식(2026)은 연산자(2032)를 식들(2028 및 2030)에 적용한 결과들을 포함한다.이제 도 21을 참조하면, 해석기에서의 실행 모듈에 대한 도면이 유익한 실시예에 따라 도시된다. 이 예에서 실 [0206]행 모듈(2100)은 도 17에서의 실행 모듈(1732)에 대한 더 상세한 설명이다. 도시된 바와 같이, 실행 모듈(2100)은 마스터 타임라인 제어 모듈(2102), 수학 모듈(2104), 물리학 모듈(2106), 인공 지능(AI) 모듈(2108), 보고서 생성기(2110), 및 그래픽 모듈(2112)을 포함한다.마스터 타임라인 제어 모듈(2102)은 실행 모듈(2100) 내에서 시간의 경과에 따라서 이벤트들을 정의들에 적용하 [0207]는데 사용되는 스케줄러이다. 수학 모듈(2104) 및 물리학 모듈(2106)은 서로 다른 객체들에 대한 액션들의 효과들을 판단하는데 필요한 연산들을 제공한다. 인공 지능 모듈(2108)은, 이벤트들이 마스터 타임라인 제어 모듈(2102)에 의해 정의들에 적용되는 동안, 인간행동의 시뮬레이션을 돕기 위하여 상이한 인공 지능 구성요소들을위한 소스 코드들 실행하는데 사용되는 구성요소이다.그래픽 모듈(2112)은 최종 장치들에서의 표시를 위해 GUI 프로세서에 보내기 위한 그래픽 데이터를 생성한다. [0208]- 19 -공개특허 10-2010-0014329보고서 생성기(2110)는 이 예들에서 두 개 유형의 출력들을 생성한다. 출력 중 하나의 유형은 소스 코드를 변경하기 위해 사용되는 새로운 정의이다. 이 생성된 출력은, 예를 들어 도 17에서의 HBDL(1718)이다. 보고서 생성기(2110)에 의해 생성되는 출력의 다른 유형은 그래픽 데이터이고, 이 예들에서 이 그래픽 데이터 또한 HBDL 형식으로 구성된다. 이 출력은 예를 들어, 도 17에서의 IHBDL(1710)이다.그래픽 모듈(2112)은 시뮬레이션의 결과들을 사용자에게 나타내는 출력을 생성하기 위해 사용되는 많은 서로 다 [0209]른 유형의 프로세스들을 포함한다. 이러한 유형의 프로세스들은 2차원 그래픽 파이프라인들, 2차원 그래픽 프리미티브들, 3차원 그래픽 파이프라인들, 3차원 그래픽 프리미티브들, 2차원 및 3차원 모델과 스택들, 표시 목록생성기, 그리고 2차원 및 3차원 렌더링 엔진들을 포함한다. 그래픽 프로세스들의 다른 유형들뿐만 아니라 이 유형들은 사용자에게 나타내기 위한 출력을 생성하는데 사용하기 위해 그래픽 모듈(2112)에 존재할 수 있다.이제 도 22를 참조하면, 토큰들을 생성하기 위한 프로세스의 순서도가 유익한 실시예에 따라서 도시된다. 도 22 [0210]에서 설명된 프로세스는 도 17에서의 형태소 분석기(1728)와 같은 소프트웨어 구성요소에서 구현될 수 있다.프로세스는 소스로부터 다음 문자를 받음으로써 시작된다(연산 2200). 이 예들에서, 문자들의 소스는 도 17에서 [0211]의 HBDL(1708)이다. 문자는 큐에 배치된다(연산 2202).다음으로, 큐에서의 문자열이 정규 표현식이나 예약어와 일치하는지 여부에 대하여 판단된다(연산 2204). 만일 [0212]일치한다면, 큐에서의 문자열을 사용하여 토큰이 생성된다(연산 2206). 그 후에 큐는 비워진다(연산 2208). 그 후에, 소스에서 파일의 끝 부분인지 여부에 대하여 판단된다(연산 2210). 만일 파일의 끝이라면, 프로세스는 [0213]종료된다. 그렇지 않다면, 다음 문자를 얻기 위하여 연산(2200)으로 돌아간다. 만일 연산(2204)에서 문자열이일치하지 않으면, 프로세스는 상술한 바와 같이 연산(2210)을 수행한다.이제 도 23을 참조하면, 인간행동의 시뮬레이션을 수행하기 위한 프로세스의 순서도가 유익한 실시예에 따라서 [0214]도시된다. 도 23에서 도시된 프로세스는 도 4에서의 프레임워크(400)와 같은 프레임워크로 구현될 수 있다. 특히, 이 시뮬레이션은 도 6에서의 소스 코드(600)와 같은 소스 코드를 사용하여 수행될 수 있다.프로세스는 소스 코드 내의 정의에 의해 정의된 한 세트의 인간들을 가상 환경에 거주시킴으로써 시작한다(연산 [0215]2300). 이 예들에서, 정의는 도 6에서의 정의(602)와 같은 정의이다. 프로세스는 인간행동을 시뮬레이션한 결과를 형성하기 위하여 소스 코드 내에서 액션들을 사용해서 가상 환경에서의 한 세트의 인간들에 대해 한 세트의액션들을 실행한다(연산 2302). 이 예들에서, 한 세트의 액션들은 도 6에서의 액션들(604)과 같은 액션들로부터취해질 수 있다.그 후에, 형식화된 출력을 형성하기 위하여 소스 코드에서 그래픽 인터페이스 언어를 사용한 결과로부터 출력이 [0216]생성된다(연산 2304). 이 예들에서, GUI 언어는 도 6에서의 GUI 언어(606)일 수 있다. 그 후에, 시뮬레이션이수행될 때 네트워크 데이터 처리 시스템의 한 세트의 장치들 상에서 형식화된 출력이 표현되고(연산 2306), 그후에 프로세스는 종료한다. 이러한 방식으로, 다른 유익한 실시예들은 시뮬레이션이 수행되는 동안 수정될 수 있는 소스 코드를 통해 인간 [0217]행동을 시뮬레이션한다. 게다가, GUI 언어는 결과가 사용자에게 제공되는 방식이 시뮬레이션 그 자체에 의해 수정되고 제어되도록 한다.이제 도 24를 참조하면, 명령문들 또는 제작물들을 생성하기 위한 프로세스의 순서도가 유익한 실시예에 따라 [0218]도시된다. 도 19에서 도시된 프로세스는 도 17에서의 문법 구문분석기(1730)과 같은 소프트웨어 구성요소로 구현될 수 있다.프로세스는 처리를 위해 다음 토큰을 얻음으로써 시작된다(연산 2400). 이 예들에서, 토큰은 도 17에서의 형태 [0219]소 분석기(1728)와 같은 형태소 분석기로부터 수신된다. 토큰에 대하여 파일의 끝인지에 대하여 판단된다(연산2402). 만일 파일의 끝이 아니라면, 토큰이 구문분석 트리에 들어맞는지에 대하여 판단된다(연산 2404). 만일토큰이 구문분석 트리에 들어맞지 않는다면, 오류가 생성되고(연산 2406), 그리고 나서 프로세스는 연산(2400)으로 보내진다.그렇지 않다면, 토큰이 구문분석 트리를 완성하는지에 대하여 판단된다(연산 2408). 만일 토큰이 구문분석 트리 [0220]를 완성한다면, 완성된 구문분석 트리에 대응하는 제작물들을 위한 명령어들이 실행된다(연산 2410). 그 후에,프로세스는 호출자에게 재귀적으로 보내지고(연산 2412), 그 후에 프로세스는 상술한 바와 같이 연산(2400)으로보내진다. - 20 -공개특허 10-2010-0014329연산(2408)을 다시 참조하면, 구문분석 트리가 완성되지 않은 경우 또한 프로세스는 연산(2400)으로 보내진다. [0221]연산(2402)을 다시 참조하면, 파일에 도달한 경우에는 문법이 부분적으로 재생성되었는지 여부에 대하여 판단된다(연산 2414). 이 연산은 불완전한 명령문들 또는 제작물들이 존재하는지 여부에 대하여 판단하기 위해 수행된다. 이러한 판단은 불완전한 구문분석 트리들이 존재하는지 여부에 대하여 알아보기 위해 구문분석 트리들을 조사함으로써 이루어질 수 있다. 문법이 부분적으로 재생성되는 경우에는 오류가 생성되고(연산 2416), 그 후에프로세스는 종료된다. 그렇지 않으면, 프로세스는 오류를 생성하지 않고 종료된다.이제 도 25를 참조하면, 제작물들을 위해 명령문들을 실행하기 위한 프로세스의 순서도가 유익한 실시예에 따라 [0222]서 도시된다. 도 25에서 도시된 프로세스는 도 17에서의 실행 모듈(1732)과 같은 소프트웨어 구성요소로 구현될수 있다.프로세스는 제작물을 위한 한 세트의 명령어들에 대해 의미론적인 분석을 수행함으로써 시작된다(연산 2500). [0223]이 연산은 제작물을 위한 임의의 명령어들에서 의미론적인 오류들이 발생하는지를 판단하기 위해 수행된다. 이예들에서 한 세트의 명령어들은 하나 이상의 명령어들이다. 그 후에, 의미론적인 에러가 존재하는지 여부에 대하여 판단된다(연산 2502).의미론적인 오류가 존재하지 않는 경우, 프로세스는 한 세트의 명령어들을 실행하고(연산 2504), 그 후에 프로 [0224]세스는 종료된다. 연산(2502)에서 의미론적인 오류가 발생하는 경우에는, 그 오류는 보고되고(연산 2506), 그후에 프로세스는 종료된다. 일정한 경우들에 있어서, 프로세스는 종료되지 않고 명령어들의 실행을 허용하기 위하여 오류를 정정하려고 시도할 수 있다. 이제 도 26을 참조하면, GUI 프로세서를 설명하는 도면이 유익한 실시예에 따라서 도시된다. GUI 프로세서 [0225](2600)는 도 4에서의 GUI 프로세서(406)의 더 상세한 설명이다. 이 예에서, GUI 프로세서(2600)는 암호화/복호화 모듈들(2602), 그래픽 모듈(2604), 출력 모듈(2606), 입력 모듈(2608), 및 HBDL 생성기(2610)를 포함한다. 이 설명을 위한 예들에서, GUI 프로세서(2600)는 도 6에서의 소스 코드(600)와 같은 소스 코드로부터 수신된 명 [0226]령문들을 실행한다. 특히, 명령문들은 도 6에서의 소스 코드(600)에서 GUI 언어(606)로부터의 명령문들을 포함한다. 표시들을 생성하기 위한 실제 코드는 별도의 어플리케이션에서 존재하는 것이 아니라 소스들 내에 존재한다.GUI 프로세서(2600)는 명령문들을 실행하고 사용자 입력을 수신한다. GUI 프로세서(2600)는 도 17에서의 해석기 [0227](1700)와 같은 해석기로부터 암호화된 인터프리티드 HBDL(EHBDL)(2612)을 수신한다. 암호화/복호화 모듈(2602)은 인터프리티드 HBDL(IHBDL)(2614)을 형성하기 위해 정보를 복호화하고, 이 IHBDL(2614)은 그래픽 모듈(2604)에 의해 처리된다. 이 예들에서, IHBDL(2614)은 장치들(2618)을 위한 표시를 생성하기 위해 사용될 수 있는프리미티브들 또는 한 세트의 명령문들을 나타낸다. 그래픽 모듈(2604)은 장치들(2618)에서 표시되기 위한 픽셀들을 생성하고, 그 데이터를 출력 모듈(2606)로 보내 [0228]고, 그리고 차례로 출력 모듈(2606)은 장치(2616)로서 데이터를 장치들(2618)로 전송할 수 있다. 사용자 입력은입력 모듈(2608)에 의해 장치들(2618)로부터 장치(2620)로서 수신된다. 이 모듈은 이 장치 데이터를 HBDL 생성기(2610)로 보내고, HBDL 생성기(2610)는 HBDL(2622)의 형태로 이 사용자 입력을 나타낸다. HBDL(2622)은 HBDL로 작성된 사용자 입력이다. 이 입력은 암호화/복호화 모듈(2602)에 의해 암호화되고, 암호화된HBDL(EHBDL)(2624)로서 해석기로 보내진다.이 설명을 위한 예들에서, GUI 프로세서(2600)는 장치들(2618)에 가까운 하드웨어에서 실행된다. 사실, 많은 경 [0229]우에 GUI 프로세서(2600)의 일부는 서버와 같은 데이터 처리 시스템에서 실행되는 다른 부분들과 함께 장치들(2618) 상에서 실제로 실행될 수 있다. GUI 프로세서(2600)는 데이터를 나타내는데 필요한 네트워크 자원들의사용을 줄이는 방식으로 장치들(2618)에 가깝게 위치한다. 게다가, 이 예들에서 GUI 프로세서(2600)는, 데이터를 나타내고 사용자 입력을 수신함에 있어서 지연시간을 줄이도록 배치된다. 이제 도 27을 참조하면, GUI 프로세서를 통한 데이터 흐름을 설명하는 도면의 순서도가 유익한 실시예를 따라서 [0230]도시된다. 이 예에서, 그래픽 모듈(2700)은 도 26에서의 그래픽 모듈(2604)의 예이다. 이 예들에서 그래픽 모듈(2700)은 프리미티브들(2702)의 형태로 인터프리티드 HBDL을 수신한다. 이 프리미티브들은 해석기로 소스 코드를 해석한 결과들이다. 그래픽 모듈(2700)은 비트맵들을 위한 픽셀들과, 이 비트맵들이 어떻게 조작되거나 표시될지를 식별시키는 데이 [0231]터를 생성하기 위하여 이 프리미티브들을 처리한다. 이 정보는 비트맵 데이터(2704)로서 클라이언트 프로세스- 21 -공개특허 10-2010-0014329(2706)로 보내진다. 이 예들에서, 클라이언트 프로세스(2706)는 도 19에서의 장치들(1918)에서의 장치들과 같은장치들에서 수행되는 프로세스이다. 이 클라이언트 프로세스는 표시부(2708) 상에 비트맵 데이터를 표시하기 위해 필요한 연산들을 수행한다. 이러한 식으로, 표시를 위한 이미지들을 렌더링하기 위해 필요한 그래픽 처리가그래픽 모듈(2700)에 의해 수행된다. 클라이언트 프로세스(2706)는 제공된 비트맵 데이터를 표시하기만 하고,프리미티브들로부터 비트맵 그래픽을 렌더링하기 위해 필요한 처리 능력 및 다른 프로세스들을 요하지 않는다.이러한 처리 구분을 이용하여, 데이터를 표시하는 장치들은 워크스테이션들에서 사용되는 것들과 같은 그래픽들을 렌더링하는데 사용되는 그래픽 파이프라인들 및 다른 그래픽 프로세서들을 필요로 하지 않는다. 결과적으로, 그래픽들은 프리미티브들을 다루기 위해 보통 충분한 처리 능력을 가지지 않은 많은 서로 다른 장 [0232]치들 상에서 나타내질 수 있다. 예를 들어, 클라이언트 프로세스(2706) 및 표시부(2708)는 모바일폰, PDA, 또는타블렛 PC에서 구현될 수 있다.입력 장치(2710)는 표시부(2708)에서 표시되고 있는 데이터에 대한 사용자 입력을 수신한다. 이 사용자 입력은 [0233]버튼을 선택하거나, 데이터를 입력하거나, 명령을 보내는 등의 그래픽을 조작할 수 있다. 사용자가 표시부(2708) 상에서 비트맵들을 조작해서 표시된 이미지를 변경할 때, 표시되고 있는 이미지의 변경에서의 차이 또는수정들은 클라이언트 프로세스(2706)에 의해 식별된다. 이미지에서의 이 차이들은 서로 다른 데이터(2712)를 형성하고, 서로 다른 데이터(2712)는 HBDL 생성기(2714)로 보내진다.HBDL 생성기(2714)는 도 26에서의 HBDL 생성기(2610)와 유사하다. HBDL 생성기(2210)는 정보에서 이 변화 또는 [0234]델타를 식별하고, 해석기로 전송하기 위해 이 변화 또는 델타를 HBDL(2716)로 번역한다. HBDL(2716)는 소스 코드 모듈의 언어로 된 명령문들 또는 코드를 포함하고, 소스 코드에 대한 수정들을 만들기 위해 사용될 수 있다.그래픽 모듈(2700)은 서로 다른 비트맵들을 위한 픽셀들을 생성하기 위해 프리미티브들(2702)을 사용한다. 이제 도 28을 참조하면, 표시부의 조작을 설명하는 도면을 유익한 실시예에 따라서 도시한다. 이 설명을 위한 [0235]예에서, 표시부(2800)는 도 27에서의 표시부(2708)에서 표시되는 표시부의 예이다. 표시부(2800)는 프리미티브들로부터 생성된 비트맵들을 사용하여 표시된다. 이 예에서, 비트맵들은 슬라이더(2802) 및 필드(2804)와 같은서로 다른 구성요소들을 나타내기 위해 사용된다. 슬라이더(2802) 및 필드(2804)를 나타내기 위해 사용되는 비트맵 데이터는 이 비트맵들이 어떻게 처리될지를 가리키는 데이터와 함께 보내진다. 이 예에서, 슬라이더(2802)는 도 28에서의 위치(2806)로부터 도 29에서의 표시부(2902) 내에서의 위치(2900)까지 사용자 입력을 통해 움직일 수 있는데, 도 29에서의 표시부(2902)는 표시부(2800)의 수정된 버전이다. 게다가, 50 등의 값이 도 29에서의 표시부(2902)에서 도시된 바와 같이 필드(2804)에 입력될 수 있다. 비트맵들에서 이러한 수정들은 유익한실시예에 따라서 GUI 프로세서로 보내지고, 그 후 GUI 프로세서는 이러한 수정들에 기초하여 소스 코드를 위한적절한 명령문을 생성한다.이제 도 30을 참조하면, 비트맵에서의 수정들을 식별하기 위한 프로세스의 순서도가 유익한 실시예에 따라 도시 [0236]된다. 도 30에서 설명된 프로세스는 도 27에서의 클라이언트 프로세스(2706)와 같은 장치에서의 클라이언트 프로세스에서 구현될 수 있는 프로세스의 예이다.프로세스는 사용자 입력을 감시함으로써 시작된다(연산 3000). 사용자 입력이 표시부에서 검출되는지에 대해 판 [0237]단된다(연산 3002). 사용자 입력이 검출되지 않는 경우에는, 프로세스는 연산(3000)으로 보내진다. 그렇지 않은경우에는, 사용자 입력이 제어를 조작하는지 여부에 대해 판단된다(연산 3004). 사용자 입력이 제어를 조작하는경우에는, 제어에 대해 가해진 수정이 비트맵에서 식별된다(연산 3006). 비트맵에서의 이러한 차이 또는 수정부분은 GUI 프로세서로 돌려 보내지고(연산 3008), 그 후에 프로세스는 추가적인 사용자 입력을 감시하기 위해연산(3000)으로 보내진다. 데이터 수정 부분은 구체적인 구현에 따라서 수정된 실제의 비트맵이거나 비트맵의위치에서의 변화에 대한 식별자일 수 있다. 물론, 실시예에 따라서 다른 유형들의 수정들이 이용될 수 있다. 다시 연산(3004)을 참조하면, 사용자 입력이 제어를 조작하지 않는 경우에는, 사용자 입력이 필드에서의 데이터 [0238]항목인지 여부에 대해 판단된다(연산 3010). 사용자 입력이 데이터의 항목이 아닌 경우에는, 프로세스는 연산(3000)으로 보내진다. 그렇지 않은 경우에는, 프로세스는 연산(3006)을 진행하여, 비트맵에서 가해진 변화를 식별한다.이 예들에서 사용자 입력에 대해 행해진 특별한 결정들은 필드들에 대한 수정들 및 도 21에서의 실행 모듈 [0239](2100)과 같은 표시부에서의 제어들을 식별시키기 위한 것들이다. 관심 있는 비트맵에 대한 임의의 유형의 수정에 대해 판단될 수 있다. 예를 들어, 특별한 버튼이 선택되었거나 회전되었는지 여부에 대한 수정이 존재할 수있다.- 22 -공개특허 10-2010-0014329이제 도 31을 참조하면, 차이 데이터를 다루기 위한 프로세스의 순서도가 유익한 실시예를 따라 도시된다. 도 [0240]31에서 설명된 프로세스는 도 26에서의 GUI 프로세서(2600)와 같은 GUI 프로세서에서 구현될 수 있다. 특히, 도31에서 설명된 프로세스는 도 27에서의 HBDL 생성기(2714)에서 구현될 수 있다. 프로세스는 클라이언트 프로세스로부터 차이 데이터를 수신함으로써 시작된다(연산 3100). 이 예들에서, 차이 [0241]데이터는 사용자 입력을 통해 만들어진 비트맵에서의 수정들을 포함한다. 그 후 프로세스는 이 차이를 기초로하여 사용자 입력을 식별한다(연산 3102). 이 사용자 입력은 예를 들어, 슬라이드 위치의 수정, 데이터 필드로의 데이터 항목, 또는 일부 다른 사용자 입력으로서 식별될 수 있다. 연산(3102)에서 만들어진 식별자는 장치로보내진 원래의 비트맵과 수정된 비트맵을 비교함으로써 만들어진다. 예를 들어, 만일 그 차이가 이러한 유형의제어를 따라서 슬라이더를 상향으로 움직이는 것으로 식별되는 경우에는, 사용자 입력은 인간의 적시성(timeliness)을 수정하는 것일 수 있다. 이러한 유형의 차이에 대한 예가 실행 모듈(2100)의 관점에서 도 21에서 설명된다.그 후에, 사용자 입력은 소스 코드에 의해 사용되는 형식으로 변환된다(연산 3104). 이 예들에서, 사용자 입력 [0242]은 HPDL 형식으로 수정된다. 변환된 사용자 입력은 해석기로 보내지고(연산 3106), 그 후에 프로세스는 종료된다.이제 도 32를 참조하면, 인간 트랜스페어런시 패러다임(Human Transparency Paradigm)을 제공하는데 사용하기 [0243]위한 구성요소들을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 설명을 위한 예에서, 시뮬레이션(3200)은 도 4에서의 프레임워크(400)와 같은 프레임워크를 사용하여 수행된다. 특히, 시뮬레이션(3200)은 도 4에서의 해석기(404)와 같은 해석기에 의하여 소스 코드의 해석을 통해 수행된다.이 특별한 예에서, 시뮬레이션(3200)은 인공 지능(Artificial Intelligence; AI)(3202)을 포함하고, 인공 지능 [0244](3202)은 시뮬레이션(3200) 내에서 인간을 나타낸다. 인공 지능(3202)에 의해 실행되는 이러한 인간은 이 예들에서 합성 인간이다. 인공 지능(3202)을 위한 코드는 시뮬레이션(3200)을 위해 사용되는 다른 정보와 함께 정의(3204)로부터 검색된다. 정의(3204)는 도 4에서의 소스 코드(402)와 같은 소스 코드에 존재한다. 정의(3204)는합성 인간뿐만 아니라 다른 인간들과 그 인간들이 시뮬레이션(3200)을 위해 존재하는 환경에 대한 정의를 포함한다.결과들이 시뮬레이션(3200) 동안 생성됨에 따라, 이 결과들은 사용자 입력(3208)으로서 통신 모듈들(3206)로 보 [0245]내진다. 이 예에서, 이러한 통신 모듈들은 또한 도 4에서의 해석기(404)와 같은 해석기에 존재한다. 통신 모듈들(3206)은 시뮬레이션(3200)으로부터 사용자 입력(3208)을 취하고, 새로운 정의들을 정의(3204)로 변경하거나작성한다. 이것은 변경된 소스 코드를 형성하고, 그 후 변경된 소스 코드는 부가적인 결과들을 만들어 내기 위해 시뮬레이션(3200)에 의해 사용된다. 인공 지능(3202)은 이 예들에서 현실의(live) 사용자와 같은 방식으로프레임워크에 접속한다.게다가, 시뮬레이션(3200)으로부터의 결과들(3210)은 사용자(3214)에게 나타내기 위한 장치(3212)로 보내진다. [0246]이 예들에서, 사용자(3214)는 실제 인간이다.설명을 위한 실시예들은 인간 트랜스페어런시 패러다임을 사용할 수 있게 한다. 이 패러다임에서, 정의(3204)로 [0247]재작성된 인공 지능(3202)에 의해서 생성된 사용자 입력(3208)은 사용자(3214)로부터의 현실의 사용자 입력으로대체될 수 있다. 달리 말해, 사용자(3214)는 시뮬레이션(3200) 내에서 인공 지능(3202)을 통해 시뮬레이션된 합성 인간에 의해서 생성된 사용자 입력(3208) 대신에 새로운 정의들을 정의(3204)로 변경하거나 작성하기 위해사용자 입력(3216)을 통신 모듈들(3206)로 보낼 수 있다. 이 예들에서, 사용자(3214)는 사용자 입력(3216)을 제공하는 주제별 전문가(subject matter expert)일 수 있다. 이 예들에서, 사용자 입력(3216)은 시뮬레이션(3200) 동안 제공된다. 이 사용자 입력은 장치(3212)에서 수신되고 표시된 결과들에 대한 응답일 수 있다.인공 지능(3202)에 의해 시뮬레이션된 합성 인간은 합성 인간을 위한 고유 식별자(Unique Identifier; [0248]UI)(3218)와 결합된 사용자 입력(3208)을 생성한다. 사용자 입력(3208)은 시뮬레이션 동안(3200) 인공 지능(3202)에 의해 생성된다. 사용자 입력(3216)은 고유 식별자(3218)와 결합된다. 사용자 입력(3208)은 통신 모듈들(3206)로 보내진다. 통신 모듈들(3206)은 사용자 입력(3208)을 사용하여 새로운 정의들을 추가하거나 현재의정의들을 변경함으로써 정의(3204)를 변경한다. 통신 모듈들(3206)은 고유 식별자(3218)에 의거하여 정의(3204)중 어느 부분을 변경할지를 분간한다.사용자(3214)가 사용자 입력(3216)을 생성하는 경우에, 사용자 입력(3216)은 통신 모듈들(3206)에 의해 수신된 [0249]다. 이 설명을 위한 예들에서, 사용자 입력(3216)은 또한 고유 식별자(3218)를 포함할 수 있다. 이러한 식으로,- 23 -공개특허 10-2010-0014329통신 모듈들(3206)은 고유 식별자(3218)와 결합된 합성 인간을 위한 정의(3204)를 변경한다.이러한 식으로, 사용자(3214)는 시뮬레이션(3200) 내에서 인공 지능(3202)을 통해 시뮬레이션된 합성 인간을 대 [0250]신할 수 있다. 통신 모듈들(3206)로 보내진 요청들을 기초로 하여, 사용자(3214)는 조정기에서 인공 지능(3202)을 켜고 끌 수 있다.사용자 입력(3208)을 사용자 입력(3216)으로 교환하는 것을 시작할 때, 장치(3212)에서 있는 사용자(3214)는 통 [0251]신 모듈들(3206)로 요청을 보낸다. 이 시점에서, 사용자(3214)는 통신 모듈들(3206)에 접속하여 인증된 것으로한다. 통신 모듈들(3206)은 사용자(3214)가 인공 지능(3202)을 켜고 끄는 것에 대한 권한을 부여받았는지 여부에 대해 판단한다. 달리 말해, 통신 모듈들(3206)은 사용자(3214)가 합성 인간을 대신할 수 있을지 여부를 판단한다. 사용자(3214)가 권한을 부여받은 경우에는, 통신 모듈들(3206)은 인공 지능(3202)을 정지하라는 플래그(flag)를 설정한다. 달리 말해, 인공 지능(3202)을 위한 함수들은 시뮬레이션(3200) 내에서 더 이상 호출되지않는다.이 시점에서, 사용자(3214)는 고유 식별자(3218)를 포함하는 사용자 입력(3216)을 생성한다. 구체적인 구현에 [0252]따라서, 고유 식별자(3218)는 사용자(3214)가 장치(3212)에서 사용자 입력을 보내는 것을 인식하는 것을 기초로하여 통신 모듈들(3206)에 의해 추가될 수 있다.이제 도 33을 참조하면, 합성 인간을 현실의 인간으로 대체하는 프로세스의 순서도가 유익한 실시예에 따라서 [0253]도시된다. 이 예에서, 도 33에서 설명된 프로세스는 도 4에서의 해석기(404)와 같은 해석기에서 구현될 수있다. 특히, 프로세스는 해석기(404) 내에서의 통신 모듈들에서 구현될 수 있다.프로세스는 합성 인간을 대신할 사용자로부터 요청을 받음으로써 시작된다(연산 3300). 그 후에, 사용자가 모의 [0254](simulated) 인간을 대신할 권한을 부여받았는지 여부에 대해 판단된다(연산 3302). 이 예들에서, 시뮬레이션동안 어떤 사용자들이 합성 인간들을 대신할지를 정의하는 목록이나 데이터베이스를 사용자와 비교함으로써 판단된다. 예를 들어, 일정한 사용자들은 특정 영역에서 주제별 전문가들이고 그 특정 영역들에 대해 합성 인간들을 대신하도록 허가받았을 수 있다. 예를 들어, 특정 사용자는 정치학에 관해 주제별 전문가일 수 있다. 그 사용자는 시뮬레이션에서 정치가인 합성 인간을 대신하도록 허가받을 수 있다. 그러나, 그 주제별 사용자는 농부나 군인인 합성 인간을 대신하도록 허가받지 못할 수 있는데, 이는 그 주제별 전문가가 그 분야에서 전문적 지식을 소유하고 있지 않기 때문이다. 어떤 사용자들이 합성 인간들을 대신할지에 대한 특별한 규칙들은 전적으로 구체적인 구현에 의존한다. 사용자 [0255]가 합성 인간을 대신할 권한을 부여받은 경우에는, 합성 인간을 위한 인공 지능의 사용이 정의들에서 오프(trunoff)된다(연산 3304).그 후에, 프로세스는 사용자로부터 사용자 입력을 기다린다(연산 3306). 사용자 입력을 받은 때에는, 사용자 입 [0256]력이 정의들에서 새로운 정의를 작성하는지 여부에 대해 판단된다(연산 3308). 사용자 입력이 새로운 정의를 작성하는 것인 경우에는, 사용자 입력은 새로운 정의를 작성하기 위한 형식으로 형식이 지정된다(연산 3310). 그후에, 정의는 소스 코드로 작성되고(연산 3312), 그 후에 프로세스는 상술한 바와 같이 연산(3306)으로 보내진다.연산(3308)을 다시 참조하면, 사용자 입력이 새로운 정의를 작성하지 않는 것인 경우에는, 사용자 입력이 인공 [0257]지능을 온(turn on)시키는 것인지 여부에 대해 판단된다(연산 3314). 사용자 입력이 인공 지능을 온시키는 것이아닌 경우에는, 프로세스는 연산(3306)으로 보내진다. 그렇지 않은 경우에는, 인공 지능은 합성 인간을 시뮬레이션하는데 사용하기 위해 다시 온되고(연산 3316), 그 후에 프로세스는 종료된다. 연산(3316)은 시뮬레이션에서 합성 인간을 다시 배치시키고 시뮬레이션으로부터 현실의 인간을 제거한다.연산(3302)을 참조하면, 사용자가 합성 인간을 대신하는 권한을 부여받지 않은 경우에는, 에러 메시지가 생성되 [0258]고(연산 3318), 그 후에 프로세스는 종료된다.프레임워크에 의해 제공된 시뮬레이션들은 100% 확실하게 인간행동을 예측하도록 의도되지는 않으나, 결정하거 [0259]나 수정할 수 있는 가능성들을 제공하도록 의도된다. 시뮬레이션들로부터의 결과들은 프레임워크에 의해 만들어진 시뮬레이션들 없이는 가능하지 않은 안내 및 예측들을 제공한다.다른 유익한 실시예들에서, 소스 코드(600)는 도 6에서의 정의(602), 액션들(604), 및 GUI 언어(606)에서의 서 [0260]로 다른 특징들을 제공하기 위해 구체적으로 설계된 언어를 사용하여 구현될 수 있다. 다른 유익한 실시예들에서, 도 6에서의 소스 코드(600)는 또한 다른 기존의 언어들 또는 프로그래밍 방법론들로부터 기능들 및 특징들- 24 -공개특허 10-2010-0014329을 포함할 수 있다.다른 유익한 실시예들에서, 인공지능 시스템들이 예컨대 도 6에서의 정의(602) 및/또는 액션들(604)과 같은 소 [0261]스 코드(600)의 일부들을 구현하기 위해 사용될 수 있다. 일부 유익한 실시예들에서, 인공 지능은 뉴럴 네트워크의 형태(또는 다른 인공 지능의 형태들)로 다양한 객체들을 시뮬레이션하기 위해 사용될 수 있다. 예를 들어,뉴럴 네트워크는 인간 또는 동물과 같이 생명이 있거나 살아 있는 객체를 시뮬레이션하기 위해 사용될 수 있다.인공 지능은 예컨대, 형식주의와 통계 분석으로 특징지어지는 기계 학습이 이용되는 종래의 인공 지능일 수 있 [0262]다. 게다가, 인공 지능은 예컨대, 컴퓨터 지능(Computational Intelligence)의 형태일 수 있다. 컴퓨터 지능은반복적인 진화나 학습을 포함한다. 이러한 유형의 인공 지능은 경험적인 데이터를 기초로 학습할 수 있다. 컴퓨터 지능의 예로는 뉴럴 네트워크, 퍼지 논리, 및 유전자 알고리즘(Genetic Algorithm)들을 포함할 수 있는데,이에 제한되지는 않는다. 이 프로그래밍 기술들은 도 6에서의 소스 코드 내에서 추가적인 특징들을 보충하거나제공하기 위해 사용될 수 있다. 다른 유익한 실시예들에서, 도 6에서의 소스 코드(600)는 다양한 프로그래밍 기술들에 추가하거나 결합시켜 기존의 프로그래밍 언어를 사용하여 구현될 수 있다.하나의 유익한 실시예에서, 뉴럴 네트워크와 같은 프로그래밍 기술은 도 6에서의 소스 코드(600)의 일부들을 구 [0263]현하기 위해 사용될 수 있다. 예를 들어, 도 6에서의 정의(602)의 일부 또는 전부는 뉴럴 네트워크들을 사용하여 구현될 수 있다. 뉴럴 네트워크는 생물학적인 뉴럴 네트워크들을 기초로 하는 수학적인 연산 모델이다. 뉴럴네트워크들은 비선형 통계 데이터 모델링 풀(pool)들을 제공하고, 입력들과 출력들 사이에서의 복잡한 관계들을모델링하기 위해 사용될 수 있다. 뉴럴 네트워크들은 도 6에서의 정의(602) 내에서 다양한 객체들을 위한 학습기능들을 제공하기 위해 채택될 수 있다.일례로, 뉴럴 네트워크 기술들은 도 6에서의 소스 코드(600)의 정의(602) 내에서의 사람들, 동물들, 또는 다른 [0264]적절한 객체들 등의 상이한 객체들을 위한 학습 특징을 제공하기 위해 이용될 수 있다. 이러한 유형의 예에서,NN은 뉴럴 네트워크 형식의 변수를 나타낸다. 선언의 예는 “NN n;”일 수 있다. 이 예에서, 이러한 유형의 명령문은 뉴럴 네트워크 변수를 선언한다. 자식들(children)인, n.input, n.output, 및 n.hidden 또한 생성될 수있다. 이들 다른 변수들은 뉴럴 네트워크에서의 입력, 출력, 및 히든 레이어들을 나타낸다. 이 레이어들에 의해서 사용자는 뉴런들을 서로 다른 레이어들에 추가하는 것이 가능하다. 이 서로 다른 레이어들에 있어서, 입력뉴런들은 입력 뉴럴 네트워크 레이어에 대한 자식들로서 추가될 수 있다.도 34를 참조하면, 명령문들(3400 및 3402)은 입력 뉴런들의 예들이다. 명령문(3400)에서 섹션(3404)은 뉴럴 네 [0265]트워크 n을 위한 입력 뉴런으로서의 \"왼쪽 피연산자(left operand)\"를 선언한다. 이 입력 구성원은 또한 입력뉴런들의 전체 개수를 읽기 위해 사용될 수 있다. 구성원 \"input\"의 값은 새로운 구성원이 추가될 때마다 1씩증가된다. 결과적으로 \"input\"의 값은 입력 뉴런들의 전체 개수이다. 이 명령문들은 C 언어 또는 다른 언어들예컨대, C+ 및/또는 객체지항-C와 같은 언어를 사용하여 구현될 수 있는 HBDL 의사코드(pseudo code)의 예들이다. 이 예들에서, 입력 뉴런 변수들은 0에서부터 1까지 범위의 값을 가질 수 있다. 각각의 입력 뉴런 변수는 최소 [0266]범위 및 최대 범위를 가진다. 이 범위들에 의해서 그 범위 내에서는 사용자가 임의의 값을 입력하는 것이 가능하다. 구체적인 구현에 따라서 이 값들은 또한 사용하기 전에 정규화될 수 있다. 도 35를 참조하면, 명령문들(3500 및 3502)은 입력 뉴런 왼쪽 피연산자를 위해 정의된 입력 범위들의 예들이다. [0267]이 예에서, 명령문(3500)은 -10이라는 최소값을 정의하고 명령문(3502)은 10이라는 최대값을 정의한다.이제 도 36을 참조하면, 입력 행동을 위한 명령문의 도면이 유익한 실시예에 따라서 도시된다. 명령문(3600)에 [0268]의해 입력 뉴런이 사용되기 전에 입력 뉴런이 변경되는 것이 가능하다. 달리 말해, 입력 뉴런은 입력 뉴런에 의해서 사용자 입력에 대한 조작을 가능하게 하는 뉴런이 부착 또는 결합된 코드를 가질 수 있다. 예를 들어, 사용자 입력은 짧을 수도 길 수도 있다. 이 예에서, 뉴런의 입력 행동은 길고 짧음을 해석하여 0과 1사이에서 평가한다. 명령문(3600)은 이러한 유형의 행동을 입력 뉴런에 부착하기 위해 사용될 수 있는 코드의 예이다.이제 도 37을 참조하면, 출력 선언을 도시하는 도면이 유익한 실시예를 따라서 도시된다. 명령문(3700)은 출력 [0269]뉴럴 네트워크 레이어에 자식들을 추가하기 위해 사용되는 명령문의 예이다.이제 도 38을 참조하면, 뉴럴 네트워크에서의 출력 범위들을 위한 명령문들을 설명하는 도면이 유익한 실시예를 [0270]따라서 도시된다. 이 예에서 명령문들(3800 및 3802)은 출력 뉴런을 위해 설정될 수 있는 범위들의 예들이다.최소 및 최대 범위가 명령문들(3800 및 3802)에 의해 설정된다.- 25 -공개특허 10-2010-0014329이 특별한 예에서, 출력 뉴런에 대해서 최대값은 50인 반면에, 최소값은 -50이다. 게다가, 사용자는 암시적인 [0271]정규화된 출력을 특정된 범위들 내의 값으로 변환할 수 있다. 예를 들어, 출력 1은 50으로, 출력 0.5는 0으로변환될 수 있다. 게다가, 출력 뉴런은 또한 출력을 조작하기 위한 코드와 결합될 수 있다.이제 도 39를 참조하면, 출력 행동을 변경하기 위한 명령문을 설명하는 도면이 유익한 실시예를 따라서 도시된 [0272]다. 명령문(3900)은 출력 뉴런과 결부될 수 있는 코드의 예이다. 이 예에서, 사용자 출력은 로우(low)와 하이(high)일 수 있다. 이 특별한 예에서, 뉴런의 출력 행동은 0과 1 사이에 있는 값을 로우와 하이로 해석할 수 있다. 이제 도 40을 참조하면, 히든 레이어들을 위한 명령문들을 설명하는 도면이 유익한 실시예를 따라서 도시된다. [0273]명령문들(4000 및 4002)은 임의의 뉴럴 네트워크의 히든 레이이어들을 선언하기 위해 사용될 수 있는 명령문들의 예들이다. 이 예들에서, 히든 레이어의 순서는 히든 레이어 선언들의 순서를 따른다. 히든 레이이어 변수의값은 특별한 히든 레이어에 할당된 뉴런들의 수를 특정한다. 이 예들에서, 명령문들(4000 및 4002)은 2개의 히든 레이어들을 선언한다. 명령문(4000)에 의해 정의된 제1 레이어는 5개의 뉴런들을 포함하고, 명령문(4002)에의해 선언된 제2 레이어는 3개의 뉴런들을 정의한다.이제 도 41을 참조하면, 코드(4100)는 뉴럴 샘플 값을 특정하기 위해 사용되고 있는 샘플 뉴럴 네트워크 구성원 [0274]을 설명한다. 상이한 샘플이 지정될 수도 있다. 각각의 입력 및 출력 뉴런은 명령문들 내에서 \"sample [int]\"를포함한다. 뉴럴 네트워크가 완성되면, 사용자는 뉴럴 네트워크를 훈련시킬 수 있고 사용할 수 있다.이제 도 42를 참조하면, 뉴럴 네트워크를 훈련시키기 위한 예시적인 명령문들이 유익한 실시예를 따라 [0275]도시된다. 명령문들(4200, 4202, 및 4204)은 뉴럴 네트워크의 훈련을 수행하기 위해 사용되는 명령문들의 예들이다. 명령문(4200)은 뉴럴 네트워크가 500회 훈련될 것이라는 것을 가리킨다. 명령문(4202)은 300회, 그리고명령문(4204)은 200회의 훈련을 가리킨다. 이 예들에서 훈련은, 저장되고 있는 결과들과 함께 누적된다. 이 상이한 결과들은 특별한 객체를 위하여 도 6에서의 정의(602) 또는 소스 코드(602) 내에 저장될 수 있다.이제 도 43을 참조하면, 뉴럴 네트워크에서의 계산 함수를 설명하는 도면이 유익한 실시예를 따라서 도시된다. [0276]이 예에서, 명령문(4300 및 4302)은 입력 뉴런이 함수를 실행하여 결과를 반환시키도록 하는데 사용되는 명령문들의 예를 제공한다. 이 예들에서, 명령문(4304)은 명령문들(4300 및 4302)의 다른 표현이다. 이제 도 44를 참조하면, 뉴럴 네트워크의 예를 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, [0277]코드(4400)는 뉴럴 네트워크를 훈련하고 실행하기 위한 명령문들과 함께 뉴럴 네트워크의 정의를 포함한다. 입력 선언들은 섹션(4402)에 존재한다. 입력 범위들은 섹션(4404 및 4406)에 존재한다. 뉴런들과 결합된 코드는명령문들(4408 및 4410)에 존재한다. 출력 범위들은 섹션(4412)에 존재하고 출력을 위한 행동은 명령문(4414)에존재한다.히든 레이어들은 섹션(4416)에서 정의되고, 그 기능은 명령문(4418)에 존재한다. 샘플들은 섹션(4420)에 존재할 [0278]수 있고, 명령문(4422)은 훈련 명령문의 예이다. 섹션(4424)은 뉴럴 네트워크를 동작시키기 위해 사용되는 명령문들의 예들을 설명한다. 섹션(4424) 내에서의 명령문(4426)은 결과들을 표시한다.이제 도 45를 참조하면, 뉴럴 네트워크 연산의 결과들을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 [0279]예에서, 표시화면(4500)은 도 44에서의 코드(4400)로부터의 표시 명령문(4426)에 대한 응답으로 생성된 표시화면의 예이다. 뉴럴 네트워크들과 함께, 도 6에서의 정의(602) 내에서의 객체들의 다양한 속성들 및 특성들을 다루기 위해 동 [0280]적 리스트(dynamic list)들이 사용될 수 있다. 동적 리스트들은 도 8에서의 객체(800)에서의 특성들 및 도 9에서의 객체(900)에 대한 특성들(904)과 같은 특성들을 정의하기 위해 사용될 수 있다. 예를 들어, 동적 리스트들은 구성요소들, 수용능력들, 특성들, 또는 객체를 위한 다른 적절한 매개변수들의 식 [0281]별자를 제공하기 위해 사용될 수 있다. 예를 들어, 객체가 자동차라면, 동적 리스트는 바퀴들, 엔진, 차제, 페인트, 변속기, 창문들, 및 다른 구성요소들과 같은 구성요소들을 식별하기 위해 사용될 수 있다. 구성요소들이자동차에 부가되거나 자동차로부터 제거됨에 따라, 리스트는 이 수정들을 식별하기 위해 변경될 수 있다.다른 유익한 실시예들에서, 임의의 변수가 리스트에서 사용될 수 있다. 동적 리스트들에 있어서, 예상되는 구성 [0282]요소들 또는 매개변수들을 기초로 하여 리스트 크기들을 미리 정의하도록 하여야 함으로써 정의들이 제한되지는않는다. 대신에, 리스트 크기는 다양한 매개변수들 또는 구성요소들이 특별한 정의에 추가되거나 특별한 정의로부터 제거됨에 따라서 변할 수 있다.- 26 -공개특허 10-2010-0014329도 46을 참조하면, 리스트의 예를 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 코드(4600)는 [0283]명령문(4600)에서의 리스트 1을 정의한다. 명령문들(4602, 4604, 및 4606)은 리스트 1에서의 값으로 3개의 변수들을 식별한다. 이 예에서, 리스트 1은 어레이로서 동작한다. 코드(4600) 내에서의 명령문(4608)은 어레이의 크기를 식별시키는 값을 반환하는 크기 함수의 예이다. 이 예에서, 명령문(4608)은 3이라는 값을 반환한다.명령문들(4610 및 4612)은 코드(4600) 내에서의 리스트를 검색하기 위해 사용되는 명령문들의 예들이다. 명령문 [0284](4610)은 참에 상응하는 2라는 값을 반환하고, 명령문(4612)은 거짓에 상응하는 0이라는 값을 반환한다. 명령문들(4610 및 4612)에서의 이 검색 함수들은 리스트가 특정 값을 포함하는지 여부를 판단하기 위해 사용될 수 있다. 특정 값이 리스트 내에 존재하는 경우에는, 리스트 내에서의 그 값에 대한 인덱스가 반환된다. 그렇지 않은경우에는 0이라는 값이 반환된다.이제 도 47을 참조하면, 리스트로부터 변수를 삭제하는 것을 설명하는 도면이 유익한 실시예를 따라서 [0285]도시된다. 이 예에서, 코드(4700)는 섹션(4702)에서 정의된 바와 같은 리스트를 포함한다. 명령문(4704)은 코드(4700) 내에서의 리스트로부터 항목을 삭제하기 위해 사용될 수 있는 삭제함수이다. 명령문(4704)은 특별한 항목이 리스트 내에 존재하는지 여부에 대해 판단하기 위해 리스트를 검색한다. 항목이 존재한다면, 그 항목은 리스트로부터 삭제된다. 명령문(4704)은 삭제된 항목을 식별시키기 위한 인덱스를 반환한다. 그렇지 않은 경우에는, 명령문(4704)은 0을 반환한다. 이 예에서, 25라는 값은 코드(4700) 내의 리스트에 존재하지 않고, 0이 반환되며, 아무런 액션도 취해지지 않는다. 이 예에서, 항목들은 값을 식별함으로써 삭제된다.이제 도 48을 참조하면, 항목들을 삭제하기 위한 코드의 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, [0286]코드(4800)는 섹션(4802)에서의 리스트를 정의한다. 명령문들(4804 및 4806)은 인덱스 값들을 기초로 하여 리스트에서 항목들을 삭제하기 위해 사용되는 명령문들이다. 명령문이 리스트의 크기보다 작은 인덱스 값을 식별하는 경우에는, 그 항목은 리스트 내에 위치하고 있는 것이며 삭제된다. 그 후 그 함수는 삭제된 항목에 대한 값을 반환한다. 그렇지 않은 경우에는, 그 항목이 리스트에 존재하지 않는다는 것을 의미하는 0을 반환한다. 섹션(4802)에서 정의된 바와 같이 단지 세 개의 항목들만이 리스트에 존재하기 때문에, 명령문(4804)은 0을 반환한다. 명령문(4806)에 의해, 명령문(4808)에서 정의된 항목이 삭제되면서, 20이 반환된다.이제 도 49를 참조하면, 리스트에서 항목들을 조작하기 위한 코드를 설명하는 도면이 유익한 실시예를 따라서 [0287]도시된다. 이 예에서, 코드(4900)는 리스트에서 항목들을 조작하기 위해 사용될 수 있다. 이 예들에서, 코드(4900)는 스택의 리스트를 사용하기 위한 넣기(push) 및 꺼내기(pop) 함수들을 포함한다. 명령문(4902)은 조작들이 가해지는 리스트를 식별시킨다. 이 예에서, 섹션(4904)은 리스트에 가해지는 세 개의 넣기들을식별시킨다. 명령문(4906)은 리스트에 가해지는 꺼내기를 설명한다. 명령문(4906)은 리스트의 앞에서부터 꺼내진 항목들로부터의 값을 반환한다.이러한 유형의 함수들은 컴퓨터 시스템들에서의 스택들을 조작하기 위해 사용되는 것들과 유사하다. 넣기(pus [0288]h)는 특별한 항목을 리스트의 상단으로 넣거나 이동시키기 위해 사용된다. 꺼내기(pop)는 리스트의 상단에서 항목에 대한 값을 반환하기 위해 사용된다. 만일 꺼내기 명령문이 값 또는 매개변수를 포함한다면, 이 명령문은매개변수의 값에 따라서 스택으로부터 값들을 꺼내거나 반환한다. 명령문(4908)에서는 꺼내지고 있는 항목이 3이라는 인덱스 값을 가진 항목인데, 이 예들에서는 리스트에서 3번째 항목이다. 이제 도 50을 참조하면, 큐로서 리스트를 사용하는 것을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 [0289]예에서, 코드(5000)는 큐로서 리스트를 조작하기 위해 사용될 수 있는 큐에 넣기(enqueue) 및 큐에서 꺼내기(dequeue) 함수들을 설명한다. 명령문(5002)에서 보인 바와 같은 큐에 넣기 함수는 리스트의 하단에 인자(argument)를 추가한다.명령문(5004)에서 보인 바와 같은 큐에서 꺼내기 함수는 리스트로부터 상단 항목을 삭제하고, 그 항목의 값을 [0290]반환한다. 이 예에서, 명령문(5002)은 리스트 1에 항목을 추가하고, 명령문(5006)은 그 큐의 상단에 다른 항목을 추가한다. 이제, 명령문(5002)에서의 항목은 그 큐에서 두 번째이다. 명령문(5008)은 다른 항목들을 큐에서더 아래쪽으로 밀어내면서 또 다른 항목을 그 큐로 추가한다.이제 도 51을 참조하면, 리스트로부터 항목들을 읽는 것을 설명하는 도면이 유익한 실시예를 따라서 도시된다. [0291]이 예에서, 코드(5100)는 섹션(5102)에서 정의된 바와 같이 리스트의 상단과 하단으로부터 항목들을 읽는 것을설명한다. 명령문(5104)은 리스트의 상단에 위치한 항목을 읽고, 명령문(5106)은 리스트의 하단에 포함된 항목을 읽는다.이제 도 52를 참조하면, 리스트에서 정렬 속성을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 코드 [0292]- 27 -공개특허 10-2010-0014329(5200)는 리스트를 위해 정렬 상태를 식별시키기 위해 사용되는 명령문들을 포함한다. 명령문(5202)은 정렬 상태가 리스트를 위해 설정되어 있는지 여부를 식별시킨다. 명령문(5202)이 참(true)으로 설정되어 있다면, 항목들은 그 값에 따라 리스트로 삽입된다. 명령문(5204)은 정렬 순서를 식별시킨다.명령문(5204)이 참과 같은 것으로 설정되어 있다면, 리스트는 가장 작은 것에서부터 가장 큰 것까지 내림차순으 [0293]로 정렬된다. 이 예에서, 명령문(5204)은 거짓(false)으로 설정되어 있다. 결과적으로, 항목들은 섹션(5206)에서 보인 바와 같이 내림차순으로 리스트에 추가된다. 게다가, 추가적인 명령문들이 다양한 순서로 리스트를 정렬하기 위해 사용될 수 있다.도 6에서의 소스 코드(600)를 구현하기 위해 사용될 수 있는 프로그래밍 기술의 다른 예가 퍼지 논리이다. 퍼지 [0294]논리을 구현하기 위해 사용되는 언어의 예가 프롤로그(Prolog)이고, 프롤로그는 퍼지 논리 또는 인공 지능 프로그래밍을 위해 사용될 수 있는 논리 프로그래밍 언어이다.도시된 예들에서, 퍼지 논리 시스템은 논리적인 명령문들을 기초로 할 수 있고, 논리적인 명령문들에서 피연산 [0295]자는 여러 집합으로부터 취해진 조건들(terms)이다. 일례로, 그 집합들은 예컨대, 연료, 거리, 및 속력일 수 있다. 연료는 적음, 보통, 및 많음이라는 3개의 조건을 포함할 수 있다. 거리는 근거리와 원거리일 수 있다. 이예들에서, 속력은 낮음, 보통, 및 높음일 수 있다. 이 집합들은 연료가 적거나 거리가 가까우면 속력는 낮다는것과 같은 규칙들을 적용하기 위해 사용될 수 있다. 연료가 보통이고 거리가 멀면 속력은 보통이라는 다른 규칙도 있다. 연료가 많고 거리가 멀면 속력이 높다는 제3의 규칙도 있다. 퍼지 논리를 이용하여, 그 집합의 서로다른 구성원들을 위한 범위들이 설정될 수 있다. 이 범위들은 최소 및 최대 범위를 포함한다.이제 도 53을 참조하면, 연료 거리 및 속력을 사용하여 퍼지 논리를 구현한 예가 유익한 실시예를 따라서 도시 [0296]된다. 이 예에서, 코드(5300)는 섹션(5302)에서의 이 집합들을 정의한다. 연료는 정수인 반면에, 거리 및 속력은 실수형 변수들이다. 섹션(5304)은 연료의 최소 및 최대 범위가 0과 100 사이에 존재하는 것처럼 식별시킨다. 연료를 위한 시작과 종료 조건들은 섹션(5306)에서 정의된다. 이 섹션은 퍼지 집합의 왼쪽 및 오른쪽 끝들을 식 [0297]별시킨다. 섹션들(5308, 5310, 및 5312)은 연료를 위한 조건들을 식별시킨다. 섹션(5308)은 사다리꼴의 조건을식별시키고, 섹션(5310)은 삼각형의 조건을 식별시키고, 섹션(5312)은 정규분포(bell curve) 조건을식별시킨다.거리를 위한 유사한 정의들이 섹션(5314)에 존재한다. 이 예에서, 퍼지 논리를 위한 규칙들은 섹션(5316)에서 [0298]정의된다. 섹션(5318)은 연료 및 거리를 위한 초기 값을 식별시킨다. 명령문(5320)은 속력을 계산하기 위해 사용된다.도 6에서의 소스 코드(600) 내에 있는 다양한 객체들을 시뮬레이션하기 위해 사용될 수 있는 다른 유형의 프로 [0299]그래밍 기술에는 진화 연산(Evolutionary Computation)을 포함될 수 있다. 진화 연산은 인공 지능의 한 유형이다. 한 가지 특정한 방법 또는 방법론이 유전자 알고리즘이다. 이 알고리즘은 해들을 식별하기 위해 사용되는검색 기술이다. 이러한 유형의 기술은 전역 검색 자기학습 유형의 기술로서 여겨진다. 유전자 알고리즘에 있어서, 염색체들뿐만 아니라 유전자들이 선언될 수 있다. 적합도 함수, 선택 프로세스, 및 재조합 함수들 또한 이러한 유형의 기술을 사용하여 특정된다.이제 도 54를 참조하면, 유전자 알고리즘을 사용하여 방정식을 푸는 것을 설명하는 도면이 유익한 실시예를 따 [0300]라서 도시된다. 이 예에서, 코드(5400)는 방정식 2X+3Y=20을 풀기 위해 사용된다.이 예에서, 두 개의 유전자들이 섹션(5402)에서 초기화된다. 이 두 개의 유전자들은 변수들 X 및 Y에 대응한다. [0301]섹션(5404)에서 염색체들이 유전자들에 추가된다. 적합도 함수를 위한 코드는 명령문(5406)에서 식별될 수있다. 선택 함수를 위한 코드는 명령문(5408)을 사용하여 특정될 수 있다. 재조합 함수를 위한 코드는 명령문(5410)에서 특정될 수 있다.이 함수들을 위한 코드는 특별한 명령문을 위한 임의의 이용가능한 함수를 사용하여 구현될 수 있다. 이 선택 [0302]프로세스들은 코드에 의해 특정된 바와 같이 가장 적절한 또는 가장 적합한 염색체를 선택하기 위해 사용된다.예를 들어, 룰렛 휠 선택(Roulette Wheel Selection) 프로세스가 사용될 수 있다. 명령문(5410)에서의 재조합함수와 관련하여, 이 명령문은 새로운 세대의 염색체들을 만들기 위한 코드를 식별시키기 위해 사용될 수 있다.일례로, 이진 변수 교차(cross-over) 방법이 사용될 수 있다. 명령문(5412)은 프로세스를 위한 오류 한계를 특 [0303]정하고, 명령문(5414)은 코드(5400) 내에서 진화 함수를 호출한다. 이 예들에서, 가장 적합한 염색체의 오류 한계가 명령문(5412)에서 특정된 오류보다 적은 경우에는 언제나, 명령문(5414)에서 식별된 진화 프로세스가 정지- 28 -공개특허 10-2010-0014329된다. 코드(5400)에서 정의된 바와 같이 프로세스를 수행함으로써, 유전자 X는 염색체에 가장 잘 들어맞는 X의값들을 반환하고 유전자 Y는 염색체에 가장 잘 들어맞는 Y의 값들을 반환한다.이제 도 55A 및 55B를 참조하면, 소스 코드에서의 객체를 위한 코드를 설명하는 도면이 유익한 실시예를 따라서 [0304]도시된다. 이 예에서, 코드(5500)는 숲의 형태인 객체를 위한 정의의 예이다. 섹션(5502)은 숲에서의 나무들에대한 색들을 식별시킨다. 코드(5500)에서의 섹션(5504)은 숲을 위한 격자눈금을 식별시킨다. 섹션(5506)은 숲을위한 격자눈금에 존재할 수 있는 나무들을 정의한다. 섹션(5508)은 숲을 위해 한 줄의 나무를 식별시킨다. 섹션(5510)은 섹션(5508)에서 정의된 바와 같이 한 줄 이상의 나무들을 포함하는 나무들의 구획을 생성하기 위해 사용된다. 섹션(5512)은 숲을 나타내기 위해 사용될 수 있는 코드의 예이다. 이 예들에서, 행들(5514 및 5516)은숲 내에서 무작위성을 제공하기 위해 사용되는 번역 명령문들이다. 예컨대 회전 및/또는 축척 명령문들과 같은다른 명령문들 또한 이 명령문들에 추가하여 또는 이 명령문들 대신에 사용될 수 있다.이 예들에서, 코드(5500)는 C 언어를 사용하여 작성된다. 물론, 임의의 언어가 숲을 위한 정의를 생성하기 위해 [0305]사용될 수 있다. 게다가, 숲에 대한 표현은 도 6에서의 소스 코드(600)에서의 정의(602)에 존재할 수 있는 하나의 객체에 대한 예이다. 물론, 구체적인 구현에 따라서 임의의 언어를 사용해서 또는 임의의 객체를 위하여 코드가 생성될 수 있다.서로 다른 도시된 실시예들에서 순서도들 및 블록도들은 장치, 방법들, 및 컴퓨터 프로그램 제품들의 일부 가능 [0306]한 구현들의 구조, 기능, 및 동작을 설명한다. 이 점과 관련하여, 순서도 또는 블록도들에서의 각각의 블록은특정한 함수나 기능들을 구현하기 위한 하나 이상의 실행가능한 명령어를 포함하는, 컴퓨터에서 사용가능하거나판독가능한 프로그램 코드의 모듈, 부분, 일부를 나타낼 수 있다. 일부 다른 구현들에서, 블록에서 언급된 함수또는 기능들은 도면에서 언급된 순서와 달리 구현될 수 있다. 예를 들어 일정한 경우에 있어서는 포함된 기능에따라서, 연속하여 도시된 두 개의 블록들이 실질적으로 동시에 실행될 수 있고, 또는 이 블록들이 때때로 반대순서로 실행될 수 있다.서로 다른 유익한 실시예들은 전체가 하드웨어로 된 실시예, 전체가 소프트웨어로 된 실시예, 또는 하드웨어 및 [0307]소프트웨어 구성요소 양자를 포함하는 실시예의 형태를 취할 수 있다. 일부 실시예들은 형식들에 제한받지 않고예컨대 펌웨어, 상주 소프트웨어, 및 마이크로 코드와 같은 것들을 포함하는 소프트웨어로 구현된다.게다가, 서로 다른 실시예들은 컴퓨터에서 사용가능하거나 컴퓨터에서 판독가능한 매체로부터 접속할 수 있는 [0308]컴퓨터 프로그램 제품의 형태를 취할 수 있는데, 여기서 매체는 명령어들을 실행시키는 임의의 장치나 시스템또는 컴퓨터에 의해서 혹은 이들과 연계하여 사용하기 위한 프로그램 코드를 제공한다. 본 개시의 목적상, 컴퓨터에서 사용가능하거나 컴퓨터에서 판독가능한 매체는 일반적으로 프로그램을 포함, 저장, 전달, 전파, 또는 전송할 수 있는 임의의 유형적인 장치가 될 수 있는데, 여기서 프로그램은 명령어를 실행하는 시스템, 기구, 또는장치에 의해서 혹은 이들과 연계하여 사용하기 위한 것이다.컴퓨터에서 사용가능하거나 컴퓨터에서 판독가능한 매체는 예컨대, 제한이 없이 전자적, 자기적, 광학적, 전자 [0309]기적, 적외선, 또는 반도체 시스템이거나, 전파 매체가 될 수 있다. 컴퓨터에서 판독가능한 매체의 제한 없는예들은 반도체 또는 고체(solid state) 메모리, 자기 테이프, 분리가능한 컴퓨터 디스켓, 램(RAM), 롬(ROM), 강자기(rigid magnetic) 디스크, 및 광학 디스크를 포함한다. 광학 디스크는 씨디롬(CD-ROM), 씨디알더블유(CD-R/W), 및 디브이디(DVD)를 포함할 수 있다. 이 예들에서, 물리적 또는 유형적인 컴퓨터에서 판독가능한 매체는기록가능한 컴퓨터 저장 매체를 가리킨다. 게다가, 컴퓨터에서 사용가능하거나 컴퓨터에서 판독가능한 매체는 컴퓨터에서 판독가능하거나 컴퓨터에서 사용 [0310]가능한 프로그램 코드를 포함하거나 저장할 수 있고, 그래서 컴퓨터에서 판독가능하거나 사용가능한 프로그램코드가 컴퓨터에서 실행될 때, 컴퓨터에서 판독가능하거나 사용가능한 프로그램 코드를 실행함으로써 컴퓨터가통신 링크를 통하여 컴퓨터에서 판독가능하거나 사용가능한 다른 프로그램 코드를 전송하게 한다. 이 통신 링크는 예컨대, 제한 없이 물리적이거나 무선인 매체를 사용할 수 있다. 컴퓨터에서 판독가능하거나 사용가능한 프로그램 코드를 저장 및/또는 실행하기 위해 적절한 데이터 처리 시스 [0311]템은 시스템 버스와 같은 통신 패브릭을 통한 기억 소자들에 직접 또는 간접적으로 연결된 하나 이상의 프로세서들을 포함할 것이다. 기억 소자들은 프로그램 코드를 실제 실행하는 동안 사용된 로컬 메모리, 벌크 저장소,및 캐시 메모리들을 포함할 수 있는데, 여기서 캐시 매모리는 코드를 실행하는 동안 코드가 벌크 저장소로부터검색되는 횟수를 줄이기 위하여 컴퓨터에서 판독가능하거나 컴퓨터에서 사용가능한 프로그램 코드 중 적어도 일부의 임시 저장소를 제공한다. - 29 -공개특허 10-2010-0014329입출력 또는 I/O 장치들은 직접 시스템에 연결되거나 I/O 제어기들을 통해서 시스템에 연결될 수 있다. 이 장치 [0312]들은 예컨대, 키보드들, 터치 스크린 디스플레이들, 및 포인팅 장치들을 제한 없이 포함할 수 있다. 다른 통신어댑터들은 또한 시스템에 연결될 수 있는데, 이 시스템은 데이터 처리 시스템이 공개 또는 비공개 네트워크들을 통하여 다른 데이터 처리 시스템들 또는 원거리 프린터들이나 저장 장치들에 연결될 수 있도록 한다. 한정하지 않는 예들은 모뎀들과, 네트워크 어댑터들을 들 수 있는데, 이들은 현재 이용가능한 유형의 통신 어댑터들중 단지 일부이다.본 개시의 서술은 설명 및 해설을 위하여 제시된 것이고, 공개된 형태로 본 개시를 제한하거나 총망라하고자 의 [0313]도된 것은 아니다. 당업자들에게는 다양한 변경들과 변형들이 명백할 것이다. 게다가, 서로 다른 유익한 실시예들은 다른 유익한 실시예들과 비교된 바와 같이 서로 다른 장점들을 제공할 수 있다. 채택된 실시예 또는 실시예들은, 본 개시의 원리들이나 실용적인 응용을 가장 잘 설명하고 당업자가 특별한 사용에 맞추어진 다양한 변형들과 함께 다양한 실시예들에 대한 개시를 이해할 수 있도록 하기 위한 목적으로 선택되고 서술된다. 도면의 간단한 설명본 개시의 특성이라고 여겨지는 신규한 특징들이 첨부된 청구항들에서 설명된다. 그러나, 선호되는 사용 [0011]모드와, 이의 부가적인 목적들 및 장점들뿐만 아니라 개시 그 자체는 이하의 유익한 실시예의 상세한 설명을 참조하여 본 명세서에서 첨부한 도면들과 결부시켜 읽으면 가장 잘 이해될 것이다. 도 1은 유익한 실시예들이 구현될 수 있는 데이터 처리 시스템들의 네트워크의 회화적 표현이다. [0012]도 2는 유익한 실시예에 따른 데이터 처리 시스템의 도면이다. [0013]도 3은 유익한 실시예에 따라서 시뮬레이션 시스템을 설명하는 도면이다. [0014]도 4는 유익한 실시예에 따른 인간행동의 모델링 및 시뮬레이션 개발 프레임워크에 대한 도면이다. [0015]도 5는 유익한 실시예에 따라서 프레임워크에서의 모듈들의 분산을 설명하는 도면이다. [0016]도 6은 유익한 실시예에 따라서 소스 모듈 코드를 설명하는 도면이다. [0017]도 7은 유익한 실시예에 따라서 소스 코드의 정의 부분을 설명하는 도면이다. [0018]도 8은 유익한 실시예에 따른 객체의 블록도이다. [0019]도 9는 유익한 실시예에 따른 객체의 도면이다. [0020]도 10은 유익한 실시예에 따른 액션 객체의 도면이다. [0021]도 11은 유익한 실시예에 따라서 액션들을 적용하는 것을 설명하는 도면이다. [0022]도 12는 유익한 실시예에 따라서 스케줄러 인터럽트를 가진 타임라인 상에서 액션들을 적용하는 것을 도시하는 [0023]도면이다.도 13은 유익한 실시예에 따라서 시간 슬롯들이 겹치는 이벤트들의 적용을 설명하는 도면이다. [0024]도 14, 15, 및 16은 유익한 실시예에 따라서 지속적인 이벤트들을 설명하는 도면들이다. [0025]도 17은 유익한 실시예에 따라서 해석기를 설명하는 도면이다. [0026]도 18은 유익한 실시예에 따라서 형태소 분석기를 위한 데이터 흐름을 설명하는 도면이다. [0027]도 19는 유익한 실시예에 따라서 문법 구문분석기에 의해 수행되는 파싱(parsing) 또는 구문분석을 설명하는 도 [0028]면이다.도 20은 유익한 실시예에 따라서 구문분석 트리의 다른 예를 설명하는 도면이다. [0029]도 21은 유익한 실시예에 따라서 해석기에서의 실행 모듈에 대한 도면이다. [0030]도 22는 유익한 실시예에 따라서 토큰들을 생생하기 위한 프로세스의 순서도이다. [0031]도 23은 유익한 실시예에 따라서 인간행동의 시뮬레이션을 수행하기 위한 프로세스의 순서도이다. [0032]도 24는 유익한 실시예에 따라서 명령문들 또는 제작물들을 생성하기 위한 프로세스의 순서도이다. [0033]- 30 -공개특허 10-2010-0014329도 25는 유익한 실시예에 따라서 제작물들을 위한 명령문들을 실행하기 위한 프로세스의 순서도이다. [0034]도 26은 유익한 실시예에 따라서 GUI 프로세서를 설명하는 도면이다. [0035]도 27은 유익한 실시예에 따라서 GUI 프로세서를 통한 데이터 흐름을 설명하는 도면이다. [0036]도 28은 유익한 실시예에 따라서 표시부를 설명하는 도면이다. [0037]도 29는 유익한 실시예에 따라서 표시부의 조작을 설명하는 도면이다. [0038]도 30은 유익한 실시예에 따라서 비트맵에서의 수정들을 식별시키기 위한 프로세스의 순서도이다. [0039]도 31은 유익한 실시예에 따라서 차이 데이터를 다루기 위한 프로세스의 순서도이다. [0040]도 32는 유익한 실시예에 따라서 인간 트랜스페어런시 패러다임(Human Transparency Paradigm)을 제공하는데 사 [0041]용하기 위한 구성요소들을 설명하는 도면이다.도 33은 유익한 실시예에 따라서 합성 인간을 현실의 인간으로 대체하는 프로세스의 순서도이다. [0042]도 34는 유익한 실시예에 따른 입력 뉴런들의 예들의 도면이다. [0043]도 35는 유익한 실시예에 따라서 입력 뉴런의 왼쪽 피연산자를 위해 정의된 입력 범위들의 예들의 도면이다. [0044]도 36은 유익한 실시예에 따른 입력 행동을 위한 명령문의 도면이다. [0045]도 37은 유익한 실시예에 따라서 출력 선언을 설명하는 도면이다. [0046]도 38은 유익한 실시예에 따라서 뉴럴 네트워크에서의 출력 범위들에 대한 명령문들을 설명하는 도면이다. [0047]도 39는 유익한 실시예에 따라서 출력 행동을 변경하기 위한 명령문이다. [0048]도 40은 유익한 실시예에 따라서 히든 레이어들을 위한 명령문들을 설명하는 도면이다. [0049]도 41은 유익한 실시예에 따라서 샘플 뉴럴 네트워크를 설명하는 도면이다. [0050]도 42는 유익한 실시예에 따라서 뉴럴 네트워크를 훈련시키는 예시적인 명령문들이다. [0051]도 43은 유익한 실시예에 따라서 뉴럴 네트워크에서의 계산 함수를 설명하는 도면이다. [0052]도 44는 유익한 실시예에 따라서 뉴럴 네트워크에서의 예를 설명하는 도면이다. [0053]도 45는 유익한 실시예에 따라서 뉴럴 네트워크 연산의 결과들을 설명하는 도면이다. [0054]도 46은 유익한 실시예에 따라서 리스트의 예들 설명하는 도면이다. [0055]도 47은 유익한 실시예에 따라서 리스트로부터 변수를 삭제하는 것을 설명하는 도면이다. [0056]도 48은 유익한 실시예에 따라서 항목들을 삭제하기 위한 코드의 도면이다. [0057]도 49는 유익한 실시예에 따라서 리스트에서의 항목들을 조작하기 위한 코드를 설명하는 도면이다. [0058]도 50은 유익한 실시예에 따라서 큐로서 리스트를 사용하는 것을 설명하는 도면이다. [0059]도 51은 유익한 실시예에 따라서 리스트에서 항목들을 읽는 것을 설명하는 도면이다. [0060]도 52는 유익한 실시예에 따라서 리스트에서의 정렬 특성을 설명하는 도면이다. [0061]도 53은 유익한 실시예에 따라서 연료 거리 및 속력을 사용하여 퍼지 논리를 구현한 예이다. [0062]도 54는 유익한 실시예에 따라서 유전자 알고리즘을 사용하여 방정식을 푸는 것을 설명하는 도면이다. [0063]도 55A 및 도 55B는 유익한 실시예에 따라서 소스 코드에서의 객체를 위한 코드를 설명하는 도면이다. [0064]- 31 -공개특허 10-2010-0014329도면 도면1 도면2- 32 -공개특허 10-2010-0014329 도면3 도면4- 33 -공개특허 10-2010-0014329 도면5- 34 -공개특허 10-2010-0014329 도면6 도면7 도면8- 35 -공개특허 10-2010-0014329 도면9 도면10 도면11- 36 -공개특허 10-2010-0014329 도면12 도면13- 37 -공개특허 10-2010-0014329 도면14 도면15- 38 -공개특허 10-2010-0014329 도면16 도면17 도면18- 39 -공개특허 10-2010-0014329 도면19 도면20 도면21- 40 -공개특허 10-2010-0014329 도면22 도면23- 41 -공개특허 10-2010-0014329 도면24 도면25- 42 -공개특허 10-2010-0014329 도면26 도면27 도면28- 43 -공개특허 10-2010-0014329 도면29 도면30- 44 -공개특허 10-2010-0014329 도면31 도면32- 45 -공개특허 10-2010-0014329 도면33 도면34 도면35 도면36- 46 -공개특허 10-2010-0014329 도면37 도면38 도면39 도면40 도면41 도면42 도면43- 47 -공개특허 10-2010-0014329 도면44- 48 -공개특허 10-2010-0014329 도면45 도면46 도면47- 49 -공개특허 10-2010-0014329 도면48 도면49 도면50- 50 -공개특허 10-2010-0014329 도면51 도면52- 51 -공개특허 10-2010-0014329 도면53- 52 -공개특허 10-2010-0014329 도면54- 53 -공개특허 10-2010-0014329 도면55a- 54 -공개특허 10-2010-0014329 도면55b- 55 -공개특허 10-2010-0014329"}
{"patent_id": "10-2009-7015354", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "인간행동을 시뮬레이션하기 위한 컴퓨터로 구현된 방법, 장치, 및 컴퓨터에서 사용가능한 프로그램 코드. 인간행 동을 예측하기 위한 언어로 작성된 소스 코드는 네트워크 데이터 처리 시스템 내에서 저장 시스템에 위치한다. 하드웨어 상에서 실행되는 해석기는 언어 해석기 및 통신 모듈을 포함한다. 언어 해석기는 새로운 정의 및 인터 프리티드 소스 코드를 생성하기 위해 인공 지능을 사용하여 소스 코드를 가지고 시뮬레이션을 수행한다. GUI 프 로세서는 언어 해석기로부터 인터프리티드 소스 코드를 수신하고 장치 의존적인 출력을 생성한다. 장치들은 장치 의존적인 출력을 표시하고, 사용자 입력을 받아들이고, 받아들인 사용자 입력을 GUI 프로세서로 보낸다. 통신 모 듈은 GUI 프로세서로부터는 받아들인 사용자 입력을, 언어 해석기로부터는 새로운 정의를 수신하고, 언어 해석기 에 의해 실행되는 변형된 소스 코드를 형성하도록 소스 코드를 변형한다."}
{"patent_id": "10-2009-7015354", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 향상된 데이터 처리 시스템을 제공하는데, 상세하게는 데이터 처리를 위한 방법 및 장치를 제공한다. 더욱 상세하게는, 본 개시는 인간행동을 모델링하고 시뮬레이션하기 위하여 컴퓨터로 구현되는 방법, 장치, 및 컴퓨터에서 사용가능한 프로그램 코드에 관한 것이다. 본 개시는 “인간행동의 모델링 및 시뮬레이션 프레임워크”라는 명칭으로 2007년 3월 1일에 가출원 된 미국 특 허출원번호 제60/892,422호와 관련이 있고, 이 미국 특허출원의 우선권의 이익을 주장하고, 이 미국 특허출원은 본 명세서에 참조로서 통합된다."}
{"patent_id": "10-2009-7015354", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인간행동은 인간들에 의하여 행하여진 활동들의 모음이다. 이 활동들은 예컨대, 문화, 태도들, 감정들, 가치들, 윤리들, 권위, 설득, 및/또는 강압과 같은 요인들에 의해 영향받는다. 인간들의 행동은 이하의 한 범주에 속하 게 되는데, 일부 행동은 보편적인 것이고, 일부 행동은 특이한 것으로 고려되고, 일부 다른 행동은 수용할 수 있는 것으로 고려되고, 그 밖의 행동은 수용 범위 밖이다. 인간들의 행동은 철학, 사회학, 및 인류학과 같은 많 은 학구적인 학문에 의해 연구되어 왔다. 보다 최근에는, 컴퓨터를 사용하는 것이 인간행동의 연구에 적용되어 왔다. 게다가, 인간행동의 시뮬레이션들은 군사적인 훈련들 및 계획을 수행하기 위해 사용되어 왔다. 인간행동 시뮬레 이션은 또한 경제적 또는 사회적 행동들과 같은 다른 상황들을 예측하는 데에 대해 사용될 수 있다. 인간행동을 예측하기 위한 능력은 훈련 프로그램들을 개발하는 데 유용할 것이다. 피훈련자들이 다양한 자극들에 대해 어떻 게 반응할지에 대한 지식은 훈련 프로그램들을 개발하고 변경하는데 사용될 수 있다. 현재의 모델들 및 시뮬레이션 프로그램들은 다양한 이유들로 인하여 인간행동을 적절하게 시뮬레이션하지 못한 다. 예를 들어, 현재 이용가능한 시뮬레이션 프로그램들은 특별한 유형의 시뮬레이션에 대해서만 적합하다. 결 과적으로, 다른 유형의 시뮬레이션이 요구될 때, 그 시뮬레이션을 수행하기 위해 새로운 프로그램을 작성할 것 이 요구된다. 게다가, 관계들의 수와 이 관계들을 변경하는 능력이 제한된다. 그러므로, 훈련 프로그램에서 사용하도록 인간행동을 모델링하고 시뮬레이션하기 위해 컴퓨터로 구현되는 개선 된 방법, 장치, 및 컴퓨터로 사용가능한 프로그램 코드를 가지는 것이 유리할 것이다. - 4 -공개특허 10-2010-0014329발명의 상세한 설명 유익한 실시예들은 인간행동을 시뮬레이션하기 위한 컴퓨터로 구현된 방법, 장치, 및 컴퓨터에서 사용가능한 프 로그램 코드를 제공한다. 소스 코드는 네트워크 데이터 처리 시스템의 저장 시스템에 위치한다. 이 소스 코드는 인간행동을 예측하기 위한 언어로 작성된다. 해석기는 네트워크 데이터 처리 시스템의 하드웨어 상에서 실행되 고, 해석기는 언어 해석기 및 통신 모듈을 포함한다. 언어 해석기는 새로운 정의 및 인터프리티드 소스 코드 (interpreted source code)를 생성하기 위해 인공 지능을 사용하여 상기 소스 코드를 가지고 시뮬레이션을 수행 한다. GUI(그래픽 사용자 인터페이스) 프로세서는 네트워크 데이터 처리 시스템의 하드웨어 상에서 실행된다. GUI 프로세서는 수신된 인터프리티드 소스 코드를 형성하기 위해 언어 해석기로부터 인터프리티드 소스 코드를 수신하고 수신된 인터프리티드 소스 코드를 사용하여 장치 의존적인 출력을 생성한다. 한 세트의 장치들이 GUI 프로세서와 통신한다. 이 한 세트의 장치들은 장치 의존적인 출력을 표시하고, 받아들인 사용자 입력을 형성하 기 위해 사용자 입력을 받고, 받아들인 사용자 입력을 GUI 프로세서로 보낸다. 통신 모듈은 GUI 프로세서로부터 는 받아들인 사용자 입력을, 언어 해석기로부터는 새로운 정의를 수신하고, 언어 해석기에 의해 실행되는 변경 된 소스 코드를 형성하기 위해 받아들인 사용자 입력 및 새로운 정의를 가지고 소스 코드를 변경한다. 다른 유익한 실시예는 인간행동을 시뮬레이션하기 위한 컴퓨터로 구현된 방법을 제공한다. 데이터는 검색된 데 이터를 형성하기 위해 네트워크 데이터 처리 시스템의 저장 시스템에 저장된 소스 코드로부터 검색된다. 검색된 데이터는 결과들을 생성하기 위해 네트워크 데이터 처리 시스템에서 실행되는 해석기를 사용하여 인간행동의 시 뮬레이션을 수행하도록 해석된다. 장치 의존적인 데이터가 네트워크 데이터 처리 시스템에서 실행되는 GUI 프로 세서를 사용한 결과들로부터 생성된다. 장치 의존적인 데이터는 결과들을 나타내기 위해 사용될 수 있다. 소스 코드는 변경된 소스 코드를 형성하기 위해 결과들을 사용하여 변경된다. 변경된 소스 코드는 인간행동을 예측하 기 위하여 수반되는 해석들에서 이용되는 새로운 데이터를 제공한다. 다른 유익한 실시예는 인간행동을 시뮬레이션하기 위한 데이터 처리 시스템을 제공한다. 이 데이터 처리 시스템 은 검색된 데이터를 형성하기 위해 네트워크 데이터 처리 시스템의 저장 시스템에 저장된 소스 코드로부터 데이 터를 검색하기 위한 검색 수단을 포함한다. 해석 수단은 결과들을 생성하기 위해 네트워크 데이터 처리 시스템 에서 수행되는 해석기를 사용하여 인간행동의 시뮬레이션을 수행하도록 검색된 데이터를 해석하기 위해 존재한 다. 데이터 처리 시스템은 또한 네트워크 데이터 처리 시스템에서 실행되는 GUI 프로세서를 사용한 결과들로부 터 장치 의존적인 데이터를 생성하기 위한 생성 수단을 포함한다. 장치 의존적인 데이터는 결과들을 나타내기 위해 사용될 수 있다. 변경 수단은 변경된 소스 코드를 생성하기 위하여 결과들을 사용한 소스 코드를 변경하기 위해 존재한다. 변경된 소스 코드는 인간행동을 예측하기 위하여 수반되는 해석들에서 이용되는 새로운 데이터 를 제공한다. 이 특징들, 기능들, 및 장점들은 본 개시의 다양한 실시예들에서 독립적으로 달성될 수 있고, 이에 다른 실시예 들이 결합될 수 있다. 실 시 예 이제 도면들, 특히 도 1 내지 도 2를 참조하면, 데이터 처리 환경들의 예시적인 도면들이 제공되는데, 이 도면 들에는 설명을 위한 실시예들이 구현될 수 있다. 도 1 내지 도 2는 단지 예시적인 것이고, 다른 유익한 실시예 들이 구현될 수 있는 환경들에 대하여 어떠한 제한을 하거나 내포하고자 하는 것이 아님을 이해하여야 한다. 도 시된 환경들에 대하여 여러 가지 변경들이 가해질 수 있다. 본 명세서에서 사용될 때, \"중의 적어도 하나\"라는 문구가 항목들의 목록과 함께 사용되는 경우에는 하나 이상 의 항목들의 서로 다른 조합들이 사용될 수 있고 목록에서의 각 항목 중 하나만은 필수적이라는 것을 의미한다. 예를 들어, \"항목 A, 항목 B, 및 항목 C 중의 적어도 하나\"라는 문구는 예컨대, 항목 A 또는 항목 A와 항목 B를 제한 없이 포함할 수 있다. 이 예는 항목 A와 항목 B와 항목 C 또는 항목 B와 항목 C도 포함할 수 있다. 이제 도면들을 참조하면, 도 1은 유익한 실시예들이 구현될 수 있는 데이터 처리 시스템들의 네트워크의 도식적 표현을 도시한다. 이러한 도시된 예들에서, 네트워크 데이터 처리 시스템은 인간행동의 모델링 및 시뮬레 이션 개발 프레임워크를 구현하기 위하여 이용된다. 이 프레임워크는 인간행동을 예측하기 위한 능력을 제공한 다. 네트워크 데이터 처리 시스템은 유익한 실시예들이 구현될 수 있는 컴퓨터들 및 다른 장치들의 네트워크이 다. 네트워크 데이터 처리 시스템은 네트워크를 포함하는데, 여기서 네트워크는 네트워크 데이 - 5 -공개특허 10-2010-0014329터 처리 시스템 내에서 함께 연결된 다양한 장치들 및 컴퓨터들 사이의 통신 연결들을 제공하기 위하여 사 용되는 매체이다. 네트워크는 유무선 통신 링크들 및/또는 광섬유 케이블들과 같은 연결부들을 포함할 수 있다. 도시된 예에서, 서버 및 서버는 저장소와 함께 네트워크에 연결된다. 게다가, 클라이언트 들(110, 112, 및 114)도 네트워크에 연결된다. 이 클라이언트들(110, 112, 및 114)은, 예컨대, 퍼스널 컴 퓨터들(PC), 워크스테이션 컴퓨터들, 개인용 정보단말기(PDA)들이 될 수 있다. 도시된 예에서, 서버는 부 팅 파일들, 운영 시스템(OS) 이미지들, 및 어플리케이션들과 같은 데이터를 클라이언트들(110, 112, 및 114)에 게 제공한다. 클라이언트들(110, 112, 및 114)은 이 예에서 서버 및 서버에 대한 클라이언트들이다. 네트워크 데이터 처리 시스템은 부가적인 서버들, 클라이언트들, 및 도시되지 않은 다른 장치들을 포함할 수 있다. 유익한 실시예들에서 인간행동을 예측하기 위한 프레임워크는 네트워크 데이터 처리 시스템에서 하나 이상의 데이터 처리 시스템들을 사용하여 구현될 수 있다. 이제 도 2를 참조하여, 데이터 처리 시스템의 도면이 예시적인 실시예에 따라서 도시된다. 설명을 위한 예에서, 데이터 처리 시스템은 통신 패브릭을 포함하는데, 여기서 통신 패브릭은 프로세서부, 메모 리, 영구 저장소, 통신부, 입출력(I/O)부, 및 표시부 사이의 통신을 제공한다. 프로세서부는 메모리에 적재될 수 있는 소프트웨어를 위한 명령어들을 실행하는 일을 한다. 프로세서 부는 구체적인 구현에 따라서 한 세트의 하나 이상의 프로세서들이거나 하나의 멀티-프로세서 코어일 수 있다. 게다가, 프로세서부는 단일칩 상에서 주 프로세서가 보조 프로세서들과 함께 존재하는 하나 이상의 이종형 프로세서 시스템들을 사용하여 구현될 수 있다. 다른 설명을 위한 예에서와 같이, 프로세서부는 동 일한 유형의 복수의 프로세서들을 포함하는 대칭형 멀티-프로세서 시스템일 수 있다. 메모리는 이 예들에서, 예컨대 램(RAM)이거나 기타 다른 적절한 휘발성 또는 비휘발성 저장 장치일 수 있 다. 영구 저장소는 구체적인 구현에 따라서 다양한 형태들을 취할 수 있다. 예를 들어, 영구 저장소 는 하나 이상의 구성요소들 또는 장치들을 포함할 수 있다. 예를 들어, 영구 저장소는 하드 드라이브, 플 래시 메모리, 재기록형 광디스크, 재기록형 마그네틱 테이프, 또는 이들의 몇 가지 조합일 수 있다. 영구 저장 소에 의하여 사용되는 매체는 또한 분리가능할 수도 있다. 예를 들어, 분리가능한 하드 드라이브가 영구 저장소를 위하여 사용될 수 있다. 통신부는 이 예들에서, 다른 데이터 처리 시스템들 또는 장치들과의 통신을 제공한다. 이 예들에서, 통신 부는 네트워크 인터페이스 카드이다. 통신부는 물리적인 통신 링크들과 무선 통신 링크들 중의 어느 하나 또는 양쪽 모두를 사용하여 통신을 제공할 수 있다. 입출력부는 데이터 처리 시스템에 연결될 수 있는 다른 장치들과의 데이터 입출력을 허용한다. 예를 들어, 입출력부는 키보드 및 마우스를 통해 사용자 입력을 위한 연결을 제공할 수 있다. 게다가, 입출력부 는 프린터로 출력을 보낼 수 있다. 표시부는 사용자에게 정보를 표시하기 위한 메커니즘을 제공한다. 운영 시스템을 위한 명령어들과 어플리케이션들 또는 프로그램들은 영구 저장소에 위치한다. 이 명령어들 은 프로세서부에 의해 실행되기 위하여 메모리로 적재될 수 있다. 다른 실시예들의 프로세스들은 컴 퓨터로 구현되는 명령어들을 사용하여 프로세서부에 의하여 수행될 수 있는데, 여기서 명령어들은 메모리 와 같은 메모리에 위치할 수 있다. 이 명령어들은 프로세서부의 프로세서에 의해 판독되고 실행될 수 있는 프로그램 코드, 컴퓨터에서 사용가능한 프로그램 코드, 또는 컴퓨터에서 판독가능한 프로그램 코드를 가리 킨다. 다른 실시예들에서 프로그램 코드는 메모리 또는 영구 저장소와 같이 컴퓨터에서 판독가능한 상이한 물리적 또는 유형적인 매체에서 구현될 수 있다. 프로그램 코드는 선택적으로 분리될 수 있는 컴퓨터 판독가능한 매체에 함수 형태로 위치하고, 프로 세서부에 의해 실행되기 위하여 데이터 처리 시스템으로 적재되거나 전송될 수 있다. 이 예들에서 프 로그램 코드와 컴퓨터에서 판독가능한 매체는 컴퓨터 프로그램 제품을 형성한다. 일례로, 컴퓨 터에서 판독가능한 매체는 예컨대 광디스크 또는 마그네틱 디스크와 같이 유형적인 형태일 수 있는데, 여 기서 광디스크 또는 마그네틱 디스크는 영구 저장소의 일부인 하드 드라이브와 같은 저장 장치로 전송하기 위하여 영구 저장소의 일부인 드라이브 또는 다른 장치로 삽입되거나 배치된다. 유형적인 형태에 있어서, 컴퓨터에서 판독가능한 매체는 하드 드라이브, 썸 드라이브 또는 데이터 처리 시스템에 연결되는 플 래시 메모리와 같은 영구 저장소의 형태를 취할 수 있다. 컴퓨터에서 판독가능한 매체의 유형적인 형태는 컴퓨터에서 기록가능한 저장 매체를 가리키기도 한다. 일부 예들에서, 컴퓨터에서 판독가능한 매체는 분리 - 6 -공개특허 10-2010-0014329가능하지 않을 수 있다. 이와 달리, 프로그램 코드는 통신부에 대한 통신 링크 및/또는 입출력부에 대한 연결을 통하여 컴퓨터에서 판독가능한 매체로부터 데이터 처리 시스템으로 전송될 수 있다. 상기 통신 링크 및/또는 상기 연결은 설명을 위한 예들에서 물리적이거나 무선일 수 있다. 컴퓨터에서 판독가능한 매체는 또한 프로그램 코드를 담고 있는 통신 링크들 또는 무선 전송들과 같은 무형의 매체 형태를 취할 수 있다. 데이터 처리 시스템을 위하여 도시된 다른 구성요소들이 다른 실시예들이 구현될 수 있는 방식에 대하여 구조적인 제한들을 가하는 것을 의미하지는 않는다. 설명을 위한 다른 실시예들은 데이터 처리 시스템에 대하여 도시된 것들을 대체하거나 추가하는 구성요소들을 포함하는 데이터 처리 시스템에서 구현될 수 있다. 도 2에 도시된 다른 구성요소들은 도시된 설명을 위한 예들로부터 변경이 가해질 수 있다. 일례로, 데이터 처리 시스템의 저장 장치는 데이터를 저장할 수 있는 임의의 하드웨어 장치이다. 메모리 , 영구 저장소 및 컴퓨터에서 판독가능한 매체는 유형적인 형태의 저장 장치들의 예들이다. 다른 예에서, 버스 시스템은 통신 패브릭을 구현하기 위하여 사용될 수 있고, 시스템 버스 또는 입출력 버 스와 같은 하나 이상의 버스들을 포함할 수 있다. 물론, 버스 시스템은 이 버스 시스템에 부착된 상이한 구성요 소들 또는 장치들 사이의 데이터 전송을 제공하는 임의의 적절한 유형의 구조를 사용하여 구현될 수 있다. 게다 가, 통신부는 모뎀 또는 네트워크 어댑터와 같은, 데이터 송수신을 위하여 사용되는 하나 이상의 장치들을 포함 할 수 있다. 게다가, 메모리는 예컨대, 메모리이거나 통신 패브릭에 존재할 수 있는 인터페이스 및 메모리 제어기 허브에서 발견되는 것과 같은 캐시(cache)일 수 있다. 도시된 예에서, 네트워크 데이터 처리 시스템은 서로 통신하기 위하여 티시피아이피(TCP/IP) 프로토콜을 사용하는 네트워크들과 게이트웨이들의 세계적인 집합을 나타내는, 네트워크를 포함하는 인터넷이다. 물론, 네트워크 데이터 처리 시스템은 또한 인터넷에 부가적으로 또는 인터넷 대신에 수많은 다른 유형의 네트워크들로 구현될 수 있다. 이들 다른 네트워크들은 예컨대, 인트라넷, 랜(LAN), 및 왠(WAN)을 포함할 수 있 다. 도 1은 예로서 든 것이지 다른 실시예들에 대한 구조의 제한을 의도한 것은 아니다. 이제 도 2를 참조하면, 데이터 처리 시스템의 도면이 설명을 위한 실시예에 따라서 도시된다. 데이터 처리 시스 템은 도 1의 서버들(104 및 106) 및 클라이언트들(110, 112, 및 114)과 같은 서버들 및 클라이언트들을 구 현하기 위해 사용될 수 있다. 이러한 설명을 위한 예에서, 데이터 처리 시스템은 통신 패브릭을 포함 하는데, 여기서 통신 패브릭은 프로세서부, 메모리, 영구 저장소, 통신부, 입출력 (I/O)부, 및 표시부 사이의 통신을 제공한다. 프로세서부는 메모리에 적재될 수 있는 소프트웨어를 위한 명령어들을 실행하는 일을 한다. 프로세서 부는 구체적인 구현에 따라서 한 세트의 하나 이상의 프로세서들이거나 하나의 멀티-프로세서 코어일 수 있다. 게다가, 프로세서부는 단일칩 상에서 주 프로세서가 보조 프로세서들과 함께 존재하는 하나 이상의 이종형 프로세서 시스템들을 사용하여 구현될 수 있다. 다른 설명을 위한 예에서와 같이, 프로세서부는 동 일한 유형의 복수의 프로세서들을 포함하는 대칭형 멀티-프로세서 시스템일 수 있다. 메모리는 이 예들에서, 예컨대 램(RAM)이거나 기타 다른 적절한 휘발성 또는 비휘발성 저장 장치일 수 있 다. 영구 저장소는 구체적인 구현에 따라서 다양한 형태들을 취할 수 있다. 예를 들어, 영구 저장소 는 하나 이상의 구성요소들 또는 장치들을 포함할 수 있다. 예를 들어, 영구 저장소는 하드 드라이브, 플 래시 메모리, 재기록형 광디스크, 재기록형 마그네틱 테이프, 또는 이들의 몇 가지 조합일 수 있다. 영구 저장 소에 의하여 사용되는 매체는 또한 분리가능할 수도 있다. 예를 들어, 분리가능한 하드 드라이브가 영구 저장소를 위하여 사용될 수 있다. 통신부는 이 예들에서, 다른 데이터 처리 시스템들 또는 장치들과의 통신을 제공한다. 이 예들에서, 통신 부는 네트워크 인터페이스 카드이다. 통신부는 물리적인 통신 링크들과 무선 통신 링크들 중의 어느 하나 또는 양쪽 모두를 사용하여 통신을 제공할 수 있다. 입출력부는 데이터 처리 시스템에 연결될 수 있는 다른 장치들과의 데이터 입출력을 허용한다. 예를 들어, 입출력부는 키보드 및 마우스를 통해 사용자 입력을 위한 연결을 제공할 수 있다. 게다가, 입출력부 는 프린터로 출력을 보낼 수 있다. 표시부는 사용자에게 정보를 표시하기 위한 메커니즘을 제공한다. 운영 시스템과 어플리케이션들 또는 프로그램들을 위한 명령어들이 영구 저장소에 위치한다. 이 명령어들 은 프로세서부에 의해 실행되기 위하여 메모리로 적재될 수 있다. 다른 실시예들의 프로세스들은 컴 - 7 -공개특허 10-2010-0014329퓨터로 구현되는 명령어들을 사용하여 프로세서부에 의하여 수행될 수 있는데, 여기서 명령어들은 메모리 와 같은 메모리에 위치할 수 있다. 이 명령어들은 프로세서부의 프로세서에 의해 판독되고 실행될 수 있는 프로그램 코드, 컴퓨터에서 사용가능한 프로그램 코드, 또는 컴퓨터에서 판독가능한 프로그램 코드를 가리 킨다. 다른 실시예들에서 프로그램 코드는 메모리 또는 영구 저장소와 같이 컴퓨터에서 판독가능한 상이한 물리적 또는 유형적인 매체에서 구현될 수 있다. 프로그램 코드는 선택적으로 분리될 수 있는 컴퓨터에서 판독가능한 매체에서 함수 형태로 위치하고, 프로세서부에 의해 실행되기 위하여 데이터 처리 시스템으로 적재되거나 전송될 수 있다. 이 예들에 서 프로그램 코드와 컴퓨터에서 판독가능한 매체는 컴퓨터 프로그램 제품을 형성한다. 일례로, 컴퓨터에서 판독가능한 매체는 예컨대 광디스크 또는 마그네틱 디스크와 같이 유형적인 형태일 수 있는데, 여기서 광디스크 또는 마그네틱 디스크는 영구 저장소의 일부인 하드 드라이브와 같은 저장 장치로 전송하 기 위하여 영구 저장소의 일부인 드라이브 또는 다른 장치로 삽입되거나 배치된다. 유형적인 형태에 있어 서, 컴퓨터에서 판독가능한 매체는 하드 드라이브, 썸 드라이브 또는 데이터 처리 시스템에 연결되는 플래시 메모리와 같은 영구 저장소의 형태를 취할 수도 있다. 컴퓨터에서 판독가능한 매체의 유형적인 형 태는 컴퓨터에서 저장가능한 저장 매체를 가리키기도 한다. 일부 예들에서, 컴퓨터에서 판독가능한 매체는 분리가능하지 않을 수 있다. 이와 달리, 프로그램 코드는 통신부에 대한 통신 링크 및/또는 입출력부에 대한 연결을 통하여 컴퓨터에서 판독가능한 매체로부터 데이터 처리 시스템으로 전송될 수 있다. 상기 통신 링크 및/또는 상기 연결은 설명을 위한 예들에서 물리적이거나 무선일 수 있다. 컴퓨터에서 판독가능한 매체는 또한 프로그램 코드를 담고 있는 통신 링크들 또는 무선 전송들과 같은 무형의 매체 형태를 취할 수 있다. 데이터 처리 시스템을 위하여 도시된 다른 구성요소들이 다른 실시예들이 구현될 수 있는 방식에 대하여 구조적인 제한들을 가하는 것을 의미하지는 않는다. 설명을 위한 다른 실시예들이 데이터 처리 시스템에 대하여 도시된 것들에 추가하여 또는 이를 대신하는 구성요소들을 포함하는 데이터 처리 시스템에서 구현될 수 있다. 도 2에서 보인 다른 구성요소들은 도시된 설명을 위한 예들로부터 변경이 가해질 수 있다. 일례로, 데이터 처리 시스템의 저장 장치는 데이터를 저장할 수 있는 임의의 하드웨어 장치이다. 메모리 , 영구 저장소 및 컴퓨터에서 판독가능한 매체는 유형적인 형태의 저장 장치들의 예들이다. 다른 예에서, 버스 시스템은 통신 패브릭을 구현하기 위하여 사용될 수 있고, 시스템 버스 또는 입출력 버 스와 같은 하나 이상의 버스들을 포함할 수 있다. 물론, 버스 시스템은 이 버스 시스템에 부착된 상이한 구성요 소들 또는 장치들 사이의 데이터 전송을 제공하는 임의의 적절한 유형의 구조를 사용하여 구현될 수 있다. 게다 가, 통신부는 모뎀 또는 네트워크 어댑터와 같은, 데이터 송수신을 위하여 사용되는 하나 이상의 장치들을 포함 할 수 있다. 게다가, 메모리는 예컨대, 메모리이거나 통신 패브릭에 존재할 수 있는 인터페이스 및 메모리 제어기 허브에서 발견되는 것과 같은 캐시(cache)일 수 있다. 클라이언트로서, 데이터 처리 시스템은 다양한 형태들을 취할 수 있다. 예를 들어, 데이터 처리 시스템 은 타블렛 컴퓨터, 랩탑 컴퓨터, 워크스테이션, PC, 전화 장치, 또는 PDA의 형태를 취할 수 있다. 다른 실시예들은 한 그룹의 사람들이 일련의 액션들 및/또는 이벤트들을 겪을 때 개인적으로 및/또는 집단적으 로 어떻게 반응할 수 있는지를 예측하는데 사용될 수 있는 시뮬레이션 환경을 제공한다. 이러한 방식으로, 여러 가지 \"만약의 경우\"에 대한 시나리오들이 시뮬레이션될 수 있는데, 그 결과들은 상기 그룹들에 취해질 최종적인 한 세트의 액션들에 대한 의사결정을 돕기 위해 사용된다. 다른 실시예들은 인간행동을 시뮬레이션하기 위하여 컴퓨터로 구현되는 방법, 장치, 및 컴퓨터에서 사용가능한 프로그램 코드를 제공한다. 한 실시예에서, 소스 코드는 도 1에서 도시된 바와 같이 네트워크 데이터 처리 시스 템과 같은 네트워크 데이터 처리 시스템의 저장 시스템에 위치한다. 이 소스 코드는 인간행동을 예측하기 위해 사용된다. 해석기는 네트워크 데이터 처리 시스템의 하드웨어에서 동작한다. 이 해석기는 새로운 정의 및 인터프리티드 소스 코드(interpreted source code)를 생성하기 위하여 소스 코드를 가지고 시뮬레이션을 수행한 다. 네트워크 데이터 처리 시스템의 하드웨어에서 실행되는 GUI(Graphical User Interface) 프로세서는 인터프 리티드 소스 코드를 수신하고 이 인터프리티드 소스 코드를 사용하여 장치 의존적인 출력을 생성한다. 이 장치 의존적인 출력은 GUI 프로세서와 통신하는 한 세트의 장치들로 보내진다. 이 장치들은 장치 의존적인 출력을 표시하고 사용자의 입력을 받는다. 이 받아들인 사용자의 입력은 GUI 프로세 서로 보내지는데, 이후 GUI 프로세서는 받아들인 사용자의 입력을 해석기로 보낸다. 해석기는 소스 코드를 변경 - 8 -공개특허 10-2010-0014329하거나 수정하기 위하여 받아들인 사용자 입력 및 새로운 정의를 사용한다. 이 예들에서, 새로운 정의는 기존의 소스 코드를 변경하거나 기존의 소스 코드에 새로운 정보를 추가하기 위하여 사용되는 정보이다. 이 변경된 소 스 코드는 이후에 새로운 정의들 및 새로운 인터프리티드 소스 코드를 생성하기 위하여 실행된다. 이러한 식으 로, 피드백 루프는 이러한 유익한 실시예들에서 소스 코드를 수정하기 위하여 생성된다. 다음으로 도 3을 참조하면, 시뮬레이션 시스템을 설명하는 도면이 유익한 실시예에 따라서 도시된다. 시스템 은 도 1의 네트워크 데이터 처리 시스템에서 구현될 수 있는 시뮬레이션 시스템의 예이다. 특히, 시 스템은 도 2에서의 데이터 처리 시스템과 같은 하나 이상의 데이터 처리 시스템들을 사용하여 구현될 수 있다. 이 예들에서, 정의는 액션들을 기초로 하여 시스템에 의해 처리된다. 액션들은 인간행동을 시뮬레이션하기 위하여 정의에 적용된다. 액션들은 이 예들에서 시스템의 사용자에 의하여 선택 될 수 있다. 액션들은 또한 설정 파일로부터 또는 프로그램이나 프로세스에 의해서 선택될 수 있다. 정의 는 이 예들에서 시뮬레이션을 위하여 사용되는 소스 코드의 일부이다. 시스템은 액션들을 이용하여 정의를 변경해서 정의를 생성한다. 도시된 예들에서, 정의 는 정의에서 취해진 액션들을 기초로 한 결과들을 제공하기 위하여 출력으로 이용되는 새로운 정의이다. 게다가, 정의는 정의를 변경하기 위하여 사용되는데, 이후에 시뮬레이션의 수행을 계속하 도록 사용된다. 이 연속적인 피드백에 의해 여러 가지 반복들로부터 학습하는 능력이 시스템에 제공된다. 게다가, 이전의 시뮬레이션들의 결과들은 시스템으로 하여금 이전의 시뮬레이션들로부터 학습가능하도록 정의에 저장된다. 이 예들에서, 정의는 인간들의 집단과 이 인간들의 집단이 살고 있는 환경을 표현한 것이다. 환경에 대한 서술은 유무형적인 형태 모두의 자산을 포함한다. 게다가, 정의는 또한 인간들의 집단과 환경에 적용되는 여러 가지 이벤트들이나 입력에 대한 액션들 및 리액션들을 한정하는 내부적인 관계들에 추가하여 그 집단에 거 주할 수 있는 상이한 인간들에 대한 서술을 포함한다. 시스템은 일정한 액션들이 정의에서 서술된 인간들의 집단에 대하여 취해졌을 때 그 결과와 다양한 리액션들 및/또는 영향을 예측하기 위하여 시뮬레이션 도구로서 사용될 수 있다. 다시 말해, 액션들이 정 의에 대하여 적용되거나 취해졌을 때, 시스템이 예컨대 경제적, 사회적, 및 심리학적인 것과 같은 영 향들에 접근(access)하도록 프로그램될 수 있다. 설명을 위한 예들에서, 정의는 컴퓨터 언어를 사용하여 작성된다. 도시된 예들에서, 컴퓨터 언어는 시뮬레 이션을 수행하기 위하여 해석기를 사용하는 인터프리티드 언어지만, 실행을 위하여 컴파일을 요하지 않는다. 시 뮬레이션 프로세스에 포함된 다양한 객체들을 정의하는 것이 가능하다면 어떠한 언어라도 사용될 수 있다. 예를 들어, C 및 C++는 이 예들에서 사용될 수 있는 인터프리티드 언어들의 예들이다. 이 예들에서, 객체들의 정의는 인간들 및 이 인간들이 살고 있는 환경들을 포함한다. 다른 유익한 실시예들은 정의 및 액션들 뿐만 아니라 시스템에 대한 프레임워크를 제공한다. 이제 도 4를 참조하면, 인간행동의 모델링 및 시뮬레이션 개발 프레임워크에 대한 도면이 유익한 실시예에 따라 서 도시된다. 프레임워크는 도 3에서의 시스템의 구조에 대한 예이다. 이 예에서, 프레임워크는 소스 코드, 해석기, GUI 프로세서, 및 장치들을 포함한다. 소스 코드는 데이터베이스를 위한 모든 정보를 포함하는 프레임워크 내에서의 모듈이다. 시뮬레이션 에 대하여 알려진 모든 것은 이 특별한 구성요소에 저장된다. 소스 코드는 시뮬레이션을 수행하는데 필요 한 모든 정보를 포함한다. 이 정보는 예컨대, 인간들의 집단에 대한 정의 및 이 정의를 사용하여 시뮬레이션을 수행하는데 필요한 코드를 포함한다. 소스 코드는 결과들을 제공하기 위하여 사용되는 코드뿐만 아니라 정 의에서 취해질 수 있는 액션들을 포함하기도 한다. 소스 코드를 위하여 사용되는 언어는 인간행동을 시뮬레이션하고 예측하는데 특유한 기능들 및 특징들을 포함하도록 변경될 수 있다. 이러한 특징들을 가진 언어를 인간행동정의언어(Human Behavior Definition Language; HBDL)라고 한다. HBDL은 C 또는 C++과 같이 현재 이용가능한 언어들을 사용하여 구현될 수 있다. 물 론, 임의의 인터프리티드 언어가 이 예들에서 HBDL을 구현하기 위해 사용될 수 있다. 게다가, HBDL은 인간행동의 시뮬레이션을 제공하기 위하여 변경부분들을 가진 기존의 언어를 사용하는 것보다는 완전히 새로운 언어를 사용해서 구현될 수 있다. 설명을 위한 실시예들에서, 여러 가지 언어들이 HBDL의 상이한 구성요소들을 구현하기 위하여 사용될 수 있다. 이 예들에서, 소스 코드는 HBDL로 작성된 데이터베이스로 - 9 -공개특허 10-2010-0014329서, 상이한 지리적으로 장소들에 위치할 수 있는 여러 저장 장치들에 분산될 수 있다. 해석기는 시뮬레이션을 수행하기 위하여 소스 코드로부터 데이터를 수집한다. 이러한 설명을 위 한 예들에서, 데이터는 인간들에게 적용되는 액션들뿐만 아니라 인간들의 집단 및 그들의 환경에 대한 정 의들을 포함한다. 게다가, 데이터는 또한 소스 코드를 생성하기 위해 사용되는 프로그래밍 언어로 작 성된 명령문들 또는 행들을 포함한다. 데이터 내의 이들 명령문들은 시뮬레이션을 수행하도록 해석기(40 4)에 의해 사용된다. 데이터 내의 명령문들은 예컨대, 합성 인간을 시뮬레이션하는 인공 지능 프로그램을 위한 코드를 포함할 수 있다. 이 명령문들은 또한 예컨대, 퍼지 논리(Fuzzy Logic), 뉴럴 네트워크(Neural Network)들, 및 시뮬레이 션을 수행하기 위해 사용되는 다른 프로세스들을 포함할 수 있다. 게다가, 데이터는 또한 그 결과를 제공 하기 위하여 그래픽 사용자 인터페이스(GUI)를 생성하는 프로세스들 또는 코드를 포함할 수 있다. 이러한 방식 으로, 소스 코드는 시뮬레이션을 수행하는데 필요한 프로세스들이나 코드뿐만 아니라 인간들의 집단과 환 경에 대한 정보 양쪽 모두를 포함한다. 구현예에 따라서는, 이 명령문들이 C 또는 C++로 된 것일 수 있다. 이와 달리, 명령문들은 해석기가 실행을 위하여 C 또는 C++ 명령문들로 번역하는 하이 레벨 언어로 된 것일 수 있다. 이 시뮬레이션은 그래픽 데이터를 생성하고, 그래픽 데이터는 GUI 프로세서로 보내진다. 이 예 들에서, 그래픽 데이터는 네트워크를 느려지게 만들 수 있는 대용량 데이터 전송을 요하지는 않는 형식이 다. 예시적 실시예들에서, 그래픽 데이터는 프리미티브(primitive)들의 형식을 취한다. 비트맵들이나 더 많은 데이터가 전송될 것이 요구되는 다른 형식들보다는 차라리 프리미티브들을 전송함으로써, 네트워크에서 사 용되는 대역폭의 양이 감소된다. 일부 경우들에 있어서, 그래픽 데이터에서의 약간의 비트맵들을 보낼 필 요가 있을 수 있으나, 가능한 경우 프리미티브들이 사용된다. 대신에, 그래픽 데이터는 장치 데이터를 생성하기 위하여 GUI 프로세서에 의해 처리되고, 장치 데이터는 장치들에 의해 표시된다. 이 예들에서, 장치 데이터는 예컨대, 장치들에 의해 표 시되는 비트맵들 또는 픽셀 데이터일 수 있다. 장치들은 또한 장치 데이터를 생성하기 위하여 사용자의 입력을 받을 수 있고, 장치 데이터는 GUI 프로세서가 수신한다. GUI 프로세서는 전송을 위하여 네트워크 자원들의 사용을 적게 요하는 형 식으로 장치 데이터를 번역한다. 이 예들에서, 사용자 입력은 해석기로 보내진다. 데이터 로부터 시뮬레이션한 결과들과 사용자 입력은 변경들을 생성하기 위하여 사용된다. 변경들은 소 스 코드를 덮어쓰거나 변경하기 위하여 사용된다. 이 변경들은 소스 코드에서 정의들을 변경하기 위 해 사용된다. 변경들은 도 3에서의 정의와 유사한데, 정의는 도 3에서의 정의를 수정하기 위해 사용된다. 이러한 방식으로, 소스 코드는 해석기에 의해 수행된 시뮬레이션 결과들 및 장치들 로부터 받아들인 사용자 입력을 고려하여 변경될 수 있다. 변경들은 또한 예컨대, 해석기에 의해서 수행되는 시뮬레이션에 적용되거나 포함된 액션들의 모음을 포함할 수 있다. 이 예들에서 이 액션들의 모음 및 변경들은 장치들에서 생성된 사용자 입력으로부터 받을 수 있다. 데이터는 도 3의 정의들 및 액션들과 같은 정보를 포함할 수 있다. 변경들은 도 3의 정의 에 대한 수정들과 같은 정보를 포함할 수 있다. 이러한 수정들은 예컨대, 기존 정의들에 대한 변경들이거 나 새로운 정의들을 부가하는 것일 수 있다. 그래픽 데이터는 이 예들에서 도 3에서의 정의를 제공하 기 위해 사용된다. 프레임워크에서의 상이한 모듈들에 대하여 설명하는 것은 이러한 모듈들이 구현될 수 있는 방식에 대한 구 조적인 제한들을 의미하고자 의도한 것이 아니다. 예를 들어, 서로 다른 모듈들은 프레임워크에서 서로 다 른 특징들을 구현하기 위해 서로 다른 서브 모듈들 또는 프로세스들을 포함할 수 있다. 또한, 특별한 모듈은 단 일한 데이터 처리 시스템에서 구현될 수 있거나, 복수의 데이터 처리 시스템들을 통해 분산될 수 있다. 프레임워크의 모듈성에 있어서, 서로 다른 모듈들은 하드웨어 자원들의 사용을 최대화하기 위하여 네트워 크를 통하여 서로 다른 장소들로 분산될 수 있다. 프레임워크에서의 이러한 모듈성에 의해 또한 일부 기능 들의 집중화가 이루어지는 한편, 다른 기능들이 네트워크 데이터 처리 시스템에서의 원거리 장소들로 이동되거 나 분산되도록 한다. 예를 들어, 집중화된 환경에 그래픽 처리 및 장치 의존적인 데이터를 배치하고 나서 네트 워크를 통하여 원거리 장치로 이 정보를 보내는 것은 이점이 적다. 그래픽 데이터는 일반적으로, 용량이 크고 - 10 -공개특허 10-2010-0014329네트워크를 느리게 할 수 있다. 결과적으로, 이러한 유형의 정보 및 처리의 집중화는 호출시간, 데이터 전송, 및 데이터 동기화의 측면에서 문제들을 야기한다. 프레임워크는 프레임워크에 대한 구현들이 이러한 문제들을 피할 수 있도록 설계된다. 다음으로 도 5를 참조하면, 프레임워크에서의 모듈들의 분산을 설명하는 도면이 유익한 실시예에 따라서 도시된 다. 이 예에서, 시스템에 도시된 서로 다른 모듈들은 도 4에서의 프레임워크로부터 온 것들이다. 이 도시된 예에서 볼 수 있는 바와 같이, 시스템은 인터넷, LAN, WAN, 및 LAN을 포함한 다. 서로 다른 네트워크들은 도 1에 도시된 네트워크의 구성요소들의 일례이다. 도시된 바와 같이, 소스 코드는 저장 장치(512, 514, 및 516)에 위치한다. 저장 장치는 LAN에 연결되고, 저장 장치는 WAN에 연결되고, 저장 장치는 LAN에 연결된다. 상이한 네트워크들 에 서로 다른 장치들로부터의 소스 코드를 분산시키는 것은 소스 코드가 저장될 수 있는 방식의 일례 이다. 소스 코드는 또한 여러 장소들에 저장되는 것보다는 차라리 특별한 네트워크상의 단일한 저장 시스템에 저 장될 수 있다. 소스 코드를 저장하는 일부 저장 장치들은 소스 코드의 복사본을 저장하는 백업장치들 일 수 있다. 이러한 구현예를 이용하면, 그 구현을 특별한 하나의 장소로 제한하지 않고 다른 장소들에서 발견 될 수 있는 장점들을 활용하기 위하여 시스템의 일부들을 다른 장소로 이동시키는 것이 가능하다. 해석기는 이 예에서 데이터 처리 시스템에 위치한다. 데이터 처리 시스템은 도 2에서의 데이터 처리 시스템과 같은 데이터 처리 시스템을 사용하여 구현될 수 있다. 데이터 처리 시스템은 LAN(50 8)에 연결된다. 해석기는 시뮬레이션을 수행하기 위하여 서로 다른 네트워크들을 통해 서로 다른 저장 장 치들에 있는 소스 코드로부터 데이터를 수집한다. 시뮬레이션의 결과들은 GUI 프로세서로 보내지는데, GUI 프로세서는 데이터 처리 시스템에 위치 하기도 한다. GUI 프로세서는 장치들에서의 표시를 위하여 장치 데이터를 생성한다. 게다가, 해석기 는 데이터 처리 시스템에서 수행되는 GUI 프로세서 및 데이터 처리 시스템에서 수행되는 GUI 프로세서에 그래픽 데이터를 보낼 수 있다. GUI 프로세서는 장치들 상에 표시하기 위한 장 치 데이터를 생성하는 한편, GUI 프로세서는 장치들 상에 표시하기 위한 장치 데이터를 생성한다. GUI 프로세서들(522, 524, 및 528)은 각각 장치들(523, 530, 및 532)에 가깝게 위치한다. 이러한 방식으로, 이 프로세서들에 의해 생성된 데이터는 대용량의 네트워크 자원들을 사용할 것을 요하지 않는 다. 이 예들에서, 도 4에서의 프레임워크에서 설명된 GUI 프로세서 모듈은 시스템 내의 여러 다른 장 소들에 복사되는데, 이는 대용량의 네트워크 자원들을 사용하거나 네트워크가 느려질 수 있는 방식으로 네트워 크를 통하여 원거리 장치로 그래픽 데이터를 전송하는 식의 사용을 최소화하기 위함이다. 이제 도 6을 참조하면, 소스 모듈 코드를 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 소스 코드는 도 4에서의 소스 코드에 대한 더 상세한 설명이다. 소스 코드는 정의, 액션들, 및 GUI 언어를 포함한다. 정의 및 액션들은 환경에 서의 인간들의 집단을 시뮬레이션하는 것을 대상으로 한다. GUI 언어는 결과들을 제공하고 시뮬레이션의 최종 사용자로부터 사용자 입력을 받기 위하여 채택된다. GUI 언어를 이용하여, 소스 코드는 장치들 상에서 결과들을 나타내는 외관을 제어한다. 결과들의 이러한 외관은 이 예들에서 GUI 언어를 사용하여 제 어된다. 게다가, 소스 코드는 이 예들에서 적응성(adaptive)이 있고 개방적이다. 소스 코드는 시뮬레이션을 위한 정보와 시뮬레이션을 실행하거나 수행하기 위하여 사용되는 실제적인 언어를 모두 포함한다. 소스 코드 는 데이터베이스를 판독하고 해석하는 종래의 어플리케이션으로부터 만들어진 의사결정을 제거한다. 대조 적으로, 소스 코드는 정보 및 어플리케이션 모두를 포함하는 데이터베이스인데, 이 데이터베이스에서의 정 보 및 어플리케이션은 시뮬레이션들을 수행하여 생성된 결과들을 기초로 하여 변경될 수 있다. 데이터는 도 4의 해석기와 같은 해석기로의 데이터 흐름을 나타낸다. 변경들은 해석기로부터 수 신되는 소스 코드에 대한 수정들을 나타낸다. 데이터는 시뮬레이션을 수행하는데 사용하기 위하여 정 의, 액션들, 및 GUI 언어에서부터 해석기까지의 정보를 포함한다. 이 예들에서, 소스 코드(60 0)는 자유로운 형식의 데이터베이스이다. 이 설명을 위한 예들에서, 소스 코드는 HBDL로 작성된다. 자유로운 형식의 데이터베이스로서, 소스 코드 - 11 -공개특허 10-2010-0014329는 다른 구성요소들 간에 분리자들의 석세스(success)를 요하지 않는다. 소스 코드 내의 프로그램은 단일한 행을 사용하여 작성될 수 있다. 소스 코드는 또한 루프들, 케이스(case) 명령문들, 조건문들, 및 시뮬레이션의 수행을 변경하기 위한 다른 유사한 명령문들을 포함한다. 게다가, 소스 코드는 코드의 부분들을 저장하는 객체들을 포함한다. 결과적으로, 객체들은 반복될 필요없 이 몇 번이고 호출될 수 있다. 게다가, 소스 코드 내에서, 객체들은 디폴트 매개변수들을 포함하도록 목록 화되고 정의될 수 있다. 이러한 방식으로, 지능적인 객체들을 생성하는 것이 소스 코드 내에서 가능하다. 또한, 다른 유형의 변수들이 소스 코드 내에서 정의될 수 있다. 이러한 유형들의 변수들은 특별한 작업들 을 대상으로 할 수 있다. 예를 들어, 소스 코드는 종래의 수치적인 유형들뿐만 아니라, 인간들, 개인들, 가족, 액션, 타임라인, 날짜, 다른 것들과 같은 유형들을 포함할 수 있다. 게다가, 소스 코드는 시뮬레이 션들을 수행하기 위한 실행 모델을 기초로 하는 타임라인을 제공한다. 인공 지능적인 구성요소들은 이러한 구성 요소들을 지원하기 위한 함수 명령들과 함께 소스 코드 내에서 제공될 수 있다. 소스 코드 내에서, 정의는 인간들의 집단 및 이 인간들의 집단이 살고 있는 환경을 서술한다. 액션들 은 시뮬레이션하는 동안 정의에 적용되는 영향들을 나타낸다. 이 예들에서, 액션들은 타임라인 에 입력되는 이벤트들을 가리키는 코드의 일부들이거나 단편들이다. 이 예들에서, 시뮬레이션을 사용하는 인간들뿐만 아니라 시뮬레이션에 참여하는 인간들이 소스 코드에 의 하여 처리된다. 시뮬레이션에 참여하는 인간들은 실제 인간들이거나 합성 인간들일 수 있다. 정의, 액션들 , 및 GUI 언어는 매개변수들뿐만 아니라 기능 코드를 포함한다. 다른 정보와 함께 기능 코드 및 매개 변수들이 해석기에 의한 해석용 데이터로서의 출력된다. 소스 코드로 이러한 정보를 이동시킴으로써, 소스 코드는 시뮬레이션에 대한 제어권을 가질 수 있다. 이러한 방식으로, 시뮬레이션은 현재 사용되는 스타일들과 언어들로 작성된 것들과 같은 특정 어플리케이션이 더 이상 아니다. 예를 들어, 일단 특별한 항목이 정의에서 정의되면, 이 항목은 액션들에 있는 소정 의 한 세트의 액션들과 함께 사용될 수 있다. 예를 들어, 액션들에서 수행되는 액션들과 함께 사용되는 정 의에서 유형 X인 인간이 정의될 수 있다. 결과적으로, 인간 X를 재코딩(recoding) 하지 않고 무한개의 시 뮬레이션들이 생성되어 수행될 수 있으며 각각의 시뮬레이션을 위하여 수행될 수 있다. 게다가, 소스 코드 내에 위치한 GUI 언어를 가지는 것은 정의 및 액션들이 사용자들에게 보이는 표시를 제어할 수 있다는 것을 의미한다. 이러한 방식으로, 소스 코드는 본질적으로 시뮬레이션의 사용자들이 보는 것에 대하여 담당하는 데이터베이스이다. 이러한 특징은 또한 정의들 및 지식의 재사용을 지원 하여 어플리케이션을 위한 시뮬레이션 또는 각각의 시뮬레이션을 위한 프로그램을 맞춤형식으로 쓰지 않고서도 무한한 수의 시뮬레이션들이 생성되도록 한다. 현재의 시스템들은 스크래치 기억매체로부터 코드화된 하나의 시뮬레이션에서 정적인 데이터를 채용한다. 기껏 해야, 하나의 객체를 시뮬레이션하는 코드가 라이브러리에 보관되지만, 각각의 객체들을 위한 액션은 각각의 시 뮬레이션에 대해 유일하다. 액션은 전형적으로 개별적인 프로그램으로 작성된다. 결과적으로, 현재 사용되는 기 술들은 시뮬레이션의 각각의 특별한 유형을 위해 실질적인 코딩을 요한다. 게다가, 현재 관행에 있어서, GUI는 전형적으로 재사용되며 어플리케이션의 통제하에 있다. 결과적으로, 이 인터페이스들은 어플리케이션을 다시 코딩하거나 재작성하지 않고서는 특별한 시뮬레이션을 변 경시킬 수 없다. 이러한 방식으로, 유익한 실시예들에서의 소스 코드 설계에 있어서, 시뮬레이션들을 위하여 현 재 사용되는 기술들에 비해 결과들을 표시하고 사용자의 입력을 받는데 더 큰 유연성이 제공된다. GUI 언어는 도 4에서의 GUI 프로세서와 같은 GUI 프로세서를 통하여 해석기에 의해 선택적으로 보내 지는 코드를 제공한다. 이 코드는 다양한 표시부들에서 제공되는 입력 및 출력 제어들뿐만 아니라 최종 사용자 에게 표시들 또는 시각정보들을 제공한다. GUI 언어는 모든 최종 사용자가 자신들의 화면들에서 보는 것과 모든 사용자가 시스템과 상호작용하는 방식을 제어한다. 이 설명을 위한 예들에서, GUI 언어는 HBDL의 부 분집합이다. 구체적인 구현에 따라서, GUI 언어는 다른 유익한 특징들을 제공하기 위해 다른 언어를 사용 하여 구현될 수 있다. 이러한 방식으로, 다른 유익한 실시예들은 소스 코드에 대한 제어를 보여준다. 소스 코드 내에서 GUI 언어에 의해 제어되는 입력 및 출력을 가지는 것의 장점은 최종 장치에서 제공 되는 사용자 인터페이스가 시뮬레이션에 의해 제어될 수 있다는 것이다. 시뮬레이션은 종종 서로 다른 배경들을 가진 사용자들을 포함한다. 다양한 사용자 인터페이스들을 맞춤제작하는 능력은 이 사용자들이 시스템을 빨리 이해하도록 돕는다. 그래서, 시뮬레이션들을 실행하기 위한 학습 곡선은 감소한다. 게다가, 가장 관련 있는 정 - 12 -공개특허 10-2010-0014329보만이 서로 다른 사용자들에게 제공되는데, 이는 시뮬레이션의 타당성을 높인다. 예를 들어, 서로 다른 사용자들은 특별한 시뮬레이션을 위하여 서로 다른 사용자 인터페이스들을 필요로 할 수 있다. 일부 사용자들에게는 정의에 적용하기 위하여 액션들로부터 특별한 액션을 선택하기 위한 사용 자 인터페이스가 제공될 수 있다. 다른 사용자들은 정의에서 정의된 합성 인간을 대신할 수 있다. 이러한 유형의 사용자에게는 액션들을 선택하는 사용자들과는 다른 사용자 인터페이스가 제공된다. 게다가, 수행되고 있는 서로 다른 시뮬레이션들은 또한 서로 다른 유형들의 인터페이스들을 요한다. 이러한 유 형의 구조는 또한 사용자 인터페이스들을 동적으로 추가하거나 단순화하는 능력을 제공한다. 이러한 방식으로, 사용자 인터페이스들은 구현에 의존적인 방식으로 제공될 수 있다. 부가적으로, 서로 다른 시뮬레이션들은 새로운 매개변수들 및 새로운 환경들을 강요할 것이다. 이러한 새롭고 변화하는 상황들은 서로 다른 데이터 집합들이 분석될 것이라는 것을 의미한다. 이러한 상황들은 또한 개입될 서로 다른 사용자들 또는 전문가들을 위한 요구를 포함할 수 있다. 임박한 작업의 변화무쌍한 속성을 갖는 이 유형은 소스 코드를 통해 제공되는 융통성 있는 적응성 환경을 필요로 한다. 소스 코드는 정의, 액션들, 및 GUI 언어 내에서 이러한 패러다임을 제공한다. 이러한 설명을 위한 예들에서, GUI 프로세서는 소스 코드의 제어하에 있고, 현재 사용되는 시뮬레이션 시 스템들에서 일반적으로 일어나는 것과 같은 정적 어플리케이션이 아니다. GUI 언어는 하드웨어를 위한 추 상 레이어(a layer of abstraction)를 제공한다. GUI 언어의 내용은 시뮬레이션 프로세스가 예상할 수 있 는 방식으로 일어나는 것과 다양한 사용자들 및 장치들로부터 적절한 정보가 오고 가는 것을 보장한다. GUI 언 어는 해석기 및 GUI 프로세서가 구현되는 임의의 하드웨어에서 실행되기 위해 필요한 모든 코드를 포함한 다. 이러한 방식으로, 하드웨어 주변을 둘러싸는 더 낮은 레이어 부분들만이 하드웨어 수정들이 있을 때 재작성 될 필요가 있다. 이러한 설명을 위한 예들에서, GUI 언어는 실행시간 동안 사용자 인터페이스의 필수적인 요소들을 만들기 위해 다양한 구성들을 제공한다. 이러한 요소들은 예를 들어, 마우즈 추적 움직임, 마우스 클릭 움직임, 아날로 그 조이스틱, 메뉴들, 윈도우들, 다이얼로그 박스들, 체크박스들, 라디오 버튼들, 리스트 박스들, 및 폼들을 포 함한다. 이러한 또는 다른 요소들을 사용하면, GUI를 구현하는 것이 더 쉬워진다. 게다가, GUI 언어를 사 용하여 GUI를 만들면서 생성된 출력은 추후에 사용하기 위해 GUI 언어 내에 저장될 수 있다. GUI 언어는 소스 코드가 사람들의 집단과 그들이 살고 있는 환경에 대한 시뮬레이션과 관련해서 입력 을 나타내고 수신하도록 하는 많은 수의 서로 다른 특징들을 제공한다. GUI 언어는 한 세트의 3차원 프리 미티브들을 제공한다. 이 3차원 프리미티브들은 가상 카메라 및 보임창(view port)을 제어하기 위한 한 세트의 명령어들과 같은 특징들을 지원한다. 벡터 및 메트릭스 연산들을 포함하는 수학적인 함수들도, 다른 유형의 그 래픽 파일 형식들을 들여오고 내보내는 능력과 함께 포함된다. GUI 언어 내에서 제공되는 특징들은 또한 단지 3차원 데이터인 것보다는 더 많이 담고 있는 3차원 객체들 을 생성하는 것을 포함한다. 예를 들어, 이 3차원 객체들은 예컨대, 가격, 무게, 색, 값, 또는 이 3차원 객체들 에 대한 규칙들과 같은 다른 정보들 포함할 수 있다. 물론, 임의의 종류의 정보가 이 3차원 객체들에 포함되거 나 관련될 수 있다. 게다가, GUI 언어는 또한 3차원 모델 및 스택과 이 모델 및 스택을 취급하기 위한 일군의 명령어들을 포함 한다. 이 3차원 모델 및 스택에 의해서 서로 다른 3차원 개체들에 적용될 복잡한 변환들이 생성될 수 있다. 이 러한 방식으로, 객체들이 일시적으로 영향을 받는 서로 다른 세계들이 생성될 수 있다. GUI 언어는 대용량 3차원 데이터베이스들을 간편하게 생성하고 유지보수하게 한다. 이 데이터베이스들은 정의 내에서 발견될 수 있다. 데이터베이스들은 객체의 크기, 복잡성, 또는 성질에 불구하고 임의의 3차원 객체를 나타내기 위해 사용될 수 있다. 게다가, GUI 언어는 GUI 개발 언어를 제공한다. 이 언어에 의해서 소스 코드는 모든 최종 사용자 장 치의 룩앤필(look and feel)을 제어할 수 있다. GUI 언어는 점들, 선들, 곡선들 및 표면들과 같은 이차원 프리미티브들을 포함할 수 있다. 게다가, 한 세트의 2차원 제어 객체들 또한 존재한다. 이 2차원 제어 객체들은 예컨대, 윈도우들, 다이얼로그 박스들, 리퀘스터들, 체크박스들, 라디오 버튼들, 및 메뉴들을 포함한다. 다음으로 도 7을 참조하면, 소스 코드의 정의 부분을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 정의 는 도 6에서의 정의에 대한 더 상세한 설명이다. 정의는 자산들, 인간들, 및 내부 관 - 13 -공개특허 10-2010-0014329계들을 포함한다. 자산들은 인간들이 존재하는 환경에서의 유형 자산들 및 무형 자산들 모두를 포함한다. 유형 자 산들은 생물 및 무생물인 객체들 모두를 포함한다. 생물인 객체들은 예컨대, 가축류, 새들, 박테리아 및 식물들을 포함할 수 있다. 무생물인 객체들은 예컨대, 집, 산, 호수, 자동차, 테이블, 펜, 항공기, 또는 총을 포함할 수 있다. 무형 자산들은 예컨대, 시뮬레이션되고 있는 인간들의 집단을 위한 규칙들, 법들, 및 규정들을 포함할 수 있다. 무형 자산들은 또한 자산들을 다루기 위하여 해석기에 의하여 사용되는 정보를 포함할 수 있다. 이 정보는 또한 일반 코드, 라이브러리들, 및 루틴들을 포함한다. 더 구체적으로, 이러한 유형의 자산은, 예컨대 수학 라이브러리, 그래픽 라이브러리, 2차원 프리미티브들의 라 이브러리, 3차원 프리미티브들의 라이브러리, 모델 및 스택 관리 라이브러리, 인공 지능 라이브러리, 입출력 라 이브러리, 암호화 라이브러리, 네트워킹 라이브러리, 시스템 호출 라이브러리, 및 시간 관리 라이브러리를 포함 한다. 달리 말해, 무형 자산들은 시뮬레이션을 수행하기 위해 필요한 임의의 정보를 포함할 수 있다. 인간들은 인간들의 집단에서 나타나는 다양한 인간 특성들을 묘사한다. 인간들은 인간들의 집단 내의 사람들 사이의 다양한 가족 계보들 및 관계들을 상세히 설명하는 정보를 포함할 수 있다. 게다가, 인간들 은 다양한 개인들을 위한 심리적인 프로파일들을 생성하기 위하여 필요한 정보를 포함한다. 내부 관계들은 정의에서 인공 지능에 의해 사용되는 액션들 및 리액션들을 포함한다. 이 액션들 및 리액션들은 다양한 방식들로 유발될 수 있다. 예를 들어, 유발자(trigger)는 무작위이거나, 경고에 기초하거나, 상태기계이거나, 정의에 적용되는 한 세트의 이벤트들에 대한 리액션일 수 있다. 자산들 내에서의 서로 다른 객체들은 필요한 함수들과 계산들을 수행하기 위하여 무형 자산들에 의존 할 수 있다. 일반 코드, 라이브러리들, 및 루틴들은 서로 다른 프로그래밍 작업들을 지원하기 위해 필요한 코드 이다. 이 서로 다른 구성요소들은 시뮬레이션을 수행하는데 사용하기 위하여 데이터로서 해석기로 보내질 수 있 다. 3차원 객체들은 다른 세계를 구성하는 모든 객체들로서 생물 및 무생물 객체들을 포함한다. 이제 도 8을 참조하면, 객체의 블록도가 유익한 실시예에 따라서 도시된다. 이 예에서, 객체는 도 6에서의 정의 내에 있는 객체의 예시적 구현예이다. 이 설명을 위한 예에서, 객체는 인공 지능, 특성들 , 및 내부 관계들을 포함한다. 인공 지능은 특별한 객체를 시뮬레이션하기 위해 사용된 코드를 포함한다. 이 예들에서, 객체는 인간, 식물, 또는 동물과 같이 살아 있는 객체이다. 인공 지능은 선택된 객체의 액션들 및 리액션들을 시 뮬레이션하기 위해 필요한 코드를 포함한다. 특성들은 특별한 객체를 위한 특성들의 식별을 포함한다. 예를 들어, 만약 객체가 사람이라면, 특성 들은 예컨대, 신장, 체중, 피부색, 머리카락의 색, 눈의 색, 체형, 및 사람의 임의의 다른 적절한 특성을 포함할 수 있다. 특성들은 예컨대, 그 사람이 얼마나 빨리 달릴 수 있는지, 그 사람의 민첩함, 및 그 사람 의 체력과 같은 다른 육체적인 특성들을 포함할 수 있다. 특성들에서 육체적이지 않은 특성들은 예컨대 끈기, 열정, 감성들, 지능, 및 대인 관계들과 같은 것들을 포함할 수 있는데 이에 제한되는 것은 아니다. 특성들은 객체의 액션들 및 리액션들을 시뮬레이션하 기 위해 인공 지능에 의해 사용된다. 특히, 특성들은 도시된 예들에서 인간행동을 시뮬레이션하기 위 해 사용된다. 인공 지능의 복잡성 및 특성들 내에서의 특성들의 수는 구체적인 구현예에 따라서 다를 것이다. 현실 의 객체들과 구별될 수 없는 시뮬레이션을 만들기 위하여 요구되는 능력이 증가함에 따라서 이 구성요소들의 복 잡성은 증가한다. 내부 관계들은 이벤트들을 유발하기 위하여 인공 지능에 의해 사용될 수 있는 액션들 및 리액션들을 포함한다. 이 이벤트들은 예컨대, 객체에 의해 취해진 액션들을 포함한다. 이 액션들은 객체에 의해 시작될 수 있고, 또는 이 액션들은 객체에 취해진 액션들에 반응하여 발생한 것들일 수 있다. 객체에 의해 취해진 이 액션들은 객체를 대상으로 한 것일 수 있고, 또는 시뮬레이션 동안에 객체가 존재하 는 환경을 기초로 하여 객체에 의해 인식된 것들일 수 있다. 이제 도 9를 참조하면, 객체에 대한 도면이 유익한 실시예에 따라서 도시된다. 이 예에서, 객체는 도 6에 - 14 -공개특허 10-2010-0014329서의 정의를 가지고 시뮬레이션될 수 있는 무생물 객체의 예이다. 객체는 예컨대, 자동차, 펜, 항공 기, 산, 또는 호수일 수 있다. 이 예에서, 객체는 모델 및 특성들을 포함한다. 모델은 특별한 객체를 시뮬레이션하기 위 해 사용되는 코드를 포함한다. 모델은 특별한 객체의 기능들을 시뮬레이션하기 위해 코드를 포함한다. 예 를 들어, 만일 객체가 자동차라면 일정한 결과들을 생성하는 자동차에서 다양한 액션들이 수행될 수 있다. 예를 들어, 엔진이 켜질 수 있고 바퀴가 구를 수 있다. 모델은 예컨대, 수학적인 모델이다. 예를 들어, 한 세트의 유한 상태 기계들이 자동차의 기능들과 동작을 모델링하기 위해 사용될 수 있다. 시간이 지나면서 환경에 노출되고 사용되는 것을 통해 모델링되고 있는 객체 가 노화되는 것을 시뮬레이션하기 위한 것들과 같은 다른 기능들 및 프로세스들이 모델에 포함될 수 있다. 특성들은 예컨대, 타이어 크기, 엔진 크기, 페인트 색, 라디오 종류, 및 내부 공간의 크기와 같은 자동차 의 다양한 특성들을 식별시킨다. 게다가, 특성들은 또한 객체를 위한 자동차의 특징들에 대한 다른 정보를 포함할 수 있다. 예를 들어, 타이어의 접지면적이 특성들 내에서 특별한 타이어 유형을 위해 식별 될 수 있다. 모델은 자동차를 운전하는 사용자, 특성들에서 식별되는 타이어들에서 발생하는 손상과 마모와 같이 객체에 의해 취해진 다양한 액션들에 대하여 자동차가 반응하는 것을 시뮬레이션하기 위해 사용된다. 이러 한 손상과 마모는 특성들 내에 기록된다. 손상과 마모는 모델 내에 있는 알고리즘의 일부일 수 있다. 게다가, 자동차의 예에서 모델이 노화된 것을 나타내기 위하여 태양과 우박과 같은 환경적인 노출이 모델 에 의해 고려될 수 있다. 도 8에서의 객체 및 도 9에서의 객체에 의해 수행된 서로 다른 액션들 이 이 객체들에서 수행될 수 있고, 도 6에서의 액션들 내에서 정의될 수 있다. 이제 도 10을 참조하면, 액션 객체에 대한 도면이 유익한 실시예에 따라서 도시된다. 이 예에서, 액션 객체 는 도 6에서의 액션들 내에서 발견될 수 있는 액션의 예이다. 액션 객체는 액션, 객체, 사용자 권한들, 및 GUI를 포함한다. 액션은 예 컨대, 대화하기, 때리기, 움직이기, 앉기, 붙잡기, 말하기, 또는 바라보기와 같은 것들이 수행될 수 있는 액션 일 수 있다. 객체는 액션이 취해질 수 있는 객체에 대한 식별자이다. 사용자 권한들은 특별한 사용 자가 객체에 대해 액션을 취할 수 있는지 여부를 결정한다. GUI는 특별한 사용자에게 제공되 는 사용자 인터페이스의 유형을 식별시킨다. 객체는 생명이 없는 객체 또는 생명이 있는 객체일 수 있다. 사용자 권한들은 일정한 사용자들이 객체에 대해 선별적인 액션들을 취할 수 있을지 여부를 결정하기 위해 사용된다. 일부 경우들에서는, 특별한 사 용자가 객체에 대해 액션을 취하는 것이 바람직하지 않다. GUI는 객체와의 사용자 상호작용들이 어떻게 발생할지 뿐만 아니라 객체에 대한 액션이 사용자에게 제공되는 방식을 식별시킨다. 도 8, 9, 및 10에서의 객체에 대한 설명들은 현재 이용가능한 프로그래밍 언어들 및 방법론들을 사용하여 도 6 에서의 소스 코드가 구현될 수 있는 하나의 방법을 설명할 목적으로 제시된다. 그러나, 이 예들은 도 6에 서의 소스 코드가 구현될 수 있는 방식에 대한 제한들을 의미하는 것으로 의도한 것은 아니다. 이제 도 11을 참조하면, 액션들을 적용하는 것을 설명하는 도면이 유익한 실시예에 따라서 도시된다. 이 예들에 서, 타임라인은 도 6에서의 정의와 같은 정의가 시뮬레이션 중에 받는 영향들을 도시한다. 이 설명 을 위한 예들에서, 도 6에서의 액션들과 같은 액션들은 타임라인 상에서 이벤트들을 가리킨다. 이 액션들은 코드의 단편들 또는 일부들이다. 특히, 액션들은 이벤트들, 이벤트들, 이벤트들, 및 이벤트들을 포함한다. 이 예에서, 이벤트들은 시간 슬롯에서 적용된다. 이벤트들은 시간 슬롯 중에 발생하고, 이벤트들은 시간 슬롯 중에 적용된다. 이벤트들은 시간 슬 롯 동안 발생한다. 이 이벤트들은 본질적으로 순차적이거나 이벤트 드리븐(event driven)일 수 있다. 다 시 말해, 이벤트들은 해석기에 의해 보내지거나 생성된 다양한 메시지들에 반응하여 적용될 수 있다. 이 예들에서, 타임라인의 실행에 의해 발행되는 마스터 인터럽트는 필요하다면 실행 중간에 이 이벤트들 을 인터럽트하고, 시뮬레이션은 시뮬레이션의 다음 시간 슬롯으로 즉시 넘어간다. 소스 코드의 실행이 순차적이 거나 이벤트 드리븐인 경우에 해당하는 현재 사용되는 프로그램 언어들과는 달리, 소스 코드에서 액션들은 유익 한 실시예들에서 시간 기반 실행 모델을 따른다. 이 예들에서, 시간 슬롯들은 다양한 크기를 가질 수 있다. 예 를 들어, 각각의 시간 슬롯은 일주일, 하루, 한 시간, 일분, 또는 시간의 일정한 다른 기간을 나타낼 수 있다. - 15 -공개특허 10-2010-0014329도시된 실시예들에서, 타임라인은 이하에서 더 상세하게 서술되는 스케줄러의 감독하에 흘러간다. 스케줄 러는 타임라인과 관련이 있거나 이에 붙어 있는 이벤트들(1102, 1104, 1106, 및 1108)을 실행한다. 스케 줄러는 이 이벤트들에 대하여 완전한 제어를 가지고, 필요에 따라서 이벤트들을 인터럽트할 수 있다. 게다가, 스케줄러는 메모리 관리자 및 메모리 복구 장치를 실행한다. 이러한 식으로 인터럽트된 작업을 위하여 할당된 모든 메모리는 이후의 이벤트들에서 이용가능하게 될 수 있다. 이제 도 12를 참조하면, 스케줄러 인터럽트를 가진 타임라인 상에서 액션들을 적용하는 것을 설명하는 도면이 유익한 실시예에 따라서 도시된다. 이 예에서, 타임라인은 이벤트들 및 이벤트들을 포함한다. 이벤트들은 타임라인 상에서 시간 슬롯 동안에 실행을 시작한다. 이 예에서, 이벤 트들은 입력, 결정들, 및 처리를 포함한다. 이벤트들은 시간 슬롯 중에 실행을 시작한다. 시간 슬롯이 끝났을 때, 스케줄러는 지점에서 이벤트들의 실행을 인터럽트 한다. 이후에 실행은 시간 슬롯 다음에 시작하는 시간 슬롯을 위한 이벤트들로 이동한다. 이 예에서, 시간 슬록 및 시간 슬롯 사이에는 어떠한 겹침도 존재하지 않는다. 다음으로 도 13을 참조하면, 시간 슬롯들이 겹치는 이벤트들의 적용을 설명하는 도면이 유익한 실시에에 따라서 도시된다. 이 예에서, 스케줄러는 다양한 시간 슬롯들에 부착된 이벤트들(1302, 1304, 1306, 및 1308)을 가지는 타임라인을 실행한다. 이벤트들은 시간 슬롯에 부착된다. 이벤트들은 시간 슬롯(131 2)에 부착되거나 관련된다. 이벤트들(1306 및 1308)은 각각 시간 슬롯들(1314 및 1316)에 부착된다. 이 설명을 위한 예에서, 서로 다른 시간 슬롯들은 서로 겹칠 수 있다. 달리 말해, 하나의 시간 슬롯은 다른 시 간 슬롯보다 더 긴 시간 기간 동안 지속될 수 있다. 도시된 바와 같이, 시간 슬롯 및 시간 슬롯은 서로 겹친다. 결과적으로, 이벤트들 및 이벤트들은 시간 슬롯들 및 시간 슬롯들이 겹 치는 시간의 특정 기간 동안 동시에 실행될 수 있다. 이 특별한 예에서, 이벤트들은 실행되는데 더 많은 시간이 제공된다. 시간 슬롯들이 겹치는 것은 그 겹침이 일어나는 시간의 순간 동안에 이벤트들이 병합되는 것을 의미하지 않는다. 이 설명을 위한 예들에서, 만일 어떤 이유로든 시간 슬롯을 위한 이벤트들의 인터럽트가 발생하고, 만일 이 인터럽트가 시간 슬롯의 시작 전 또는 실행 동안에 발생한다면, 제어는 시간 슬롯 으로 넘어간다. 그러나, 만일 이 인터럽트가 시간 슬롯 동안에 그러나 시간 슬롯이 종료한 후에 발생한다면, 제어는 시간 슬롯에서의 이벤트들의 실행으로 넘어간다. 이제 도 14, 15, 및 16을 참조하면, 지속적인 이벤트들을 설명하는 도면들이 유익한 실시예를 따라서 도시된다. 도시된 바와 같이, 타임라인은 시간 슬롯에 부착되거나 할당된 이벤트들, 지속적인 이벤트 , 및 이벤트들을 포함한다. 이벤트들은 타임라인에서의 시간 슬롯과 관련이 있 다. 이벤트들은 시간 슬롯에 부착되는 한편, 이벤트들은 시간 슬롯에 부착된다. 이벤 트들은 인터럽트 할 수 없도록 만들어지거나 확장들이 주어질 수 있다. 이러한 유형의 이벤트는 최종 사용자로 부터 또는 아직 종료되지는 않았으나 필요한 일부 다른 이벤트로부터 오는 입력을 기다릴 때 존재할 수 있다. 이러한 예들에서, 이러한 유형의 이벤트는 지속적인 이벤트와 같은 지속적인 이벤트이다. 지속적인 이벤 트는 이 이벤트가 완전히 발생할 때까지 하나의 시간 슬롯에서부터 다른 시간 슬롯까지 걸쳐서 수행될 수 있다. 도 15에서 도시된 바와 같이, 지속적인 이벤트는 시간 슬롯에 부착된다. 도 16에서 지속적인 이벤 트는 시간 슬롯으로 확장되거나 이동된다. 지속적인 이벤트는 이러한 예들에서 이러한 특별 한 시간 슬롯 동안에 완성된다. 이제 도 17을 참조하면, 해석기를 설명하는 도면이 유익한 실시예에 따라서 도시된다. 해석기는 도 4에서 의 해석기에 대한 더 상세한 설명이다. 해석기는 하나의 언어로 작성된 소스 코드를 다른 언어로 작 성된 목적 코드로 변환하는 프로그램이다. 해석기는 또한 해석기가 소스 코드의 처리를 수행하는 동안 목 적 코드를 실행한다. 이 목적 언어는 다른 고수준 언어로 또는 특별한 데이터 처리 시스템 또는 프로세서에 의 해 사용되는 언어로 작성될 수 있다. 정확하게 해석되고 실행되는 임의의 프로그램에 대하여, 소스 코드는 해당 언어에 의해 정의된 구문들에 따라 구조화된다. 특히, 이 구문들은 구문론상의 구문들이다. 구문들의 완전한 집합은 소스 코드를 위한 언어의 문법 을 형성한다. 이 구문들에 따라 구조화되지 않거나 문법적으로 부정확한 임의의 코드는 해석기에 의해 버 려진다. - 16 -공개특허 10-2010-0014329해석기는 통신 모듈들 및 언어 해석기를 포함한다. 게다가, 해석기는 암호화/복호화 모듈들을 포함하고, 암호화/복호화 모듈들은 도 4에서의 GUI 프로세서와 같은 GUI 프로세서와 해석기 사이에서 정보를 안전하게 주고 받을 수 있게 한다. 이 설명을 위한 예들에서, 언어 해석기는 HBDL을 수신한다. HBDL은 도 4에서의 소스 코드 와 같은 소스 코드 모듈로부터 수신된, 도 4에서의 데이터와 같은 데이터의 예이다. HBDL은 시 뮬레이션을 수행하기 위하여 언어 해석기에 의해 해석된다. 그 결과들은 암호화를 위하여 암호화/복호화 모듈로 보내지는 인터프리티드 HBDL(IHBDL)이다. 암호화 이후에, 암호화 결과들은 암호화된 인터프 리티드 HBDL(EIHBDL)로서 도 4에서의 GUI 프로세서와 같은 GUI 프로세서로 보내진다. EIHBDL(171 2)은 도 4에서의 그래픽 데이터의 예이다. 한 세트의 장치들로부터 GUI 프로세서에 의해 수집된 바와 같이 사용자 입력은 암호화된 HBDL(EHBDL)로서 수신된다. EHBDL은 도 4에서의 사용자 입력의 예이 다. 이 암호화된 정보는 복호화되고 HBDL로서 통신 모듈들로 보내진다. HBDL은 소스 코드를 변경하기 위해 사용되는 사용자 입력의 예이다. 이 변경은 예컨대, 소스 코드 내에서 정의들을 바꾸거나 정의들에 적용될 액션들을 선택하는 것일 수 있다. 게다가, 언어 해석기의 출력은 소 스 코드를 수정하는데 사용하기 위해 HBDL로서 통신 모듈로 보내진다. HBDL 및 HBDL 은 HBDL을 형성하기 위해 통신 모듈들에 의해 사용되고, HBDL은 소스 코드를 변경하기 위해 사용된다. HBDL은 소스 코드를 변경하기 위해 사용되는 도 4에서의 변경들에 대한 형식의 예이다. 도시된 바와 같이, HBDL은 소스 코드를 변경하기 위하여 언어 해석기에 의해 생성된 출력에 대한 피드백을 제공한다. 더 구체적으로, 통신 모듈들은 디스패처 모듈, 입력 모듈, 및 등록 모듈을 포함한다. 언어 해석기는 형태소 분석기, 문법 구문분석기, 및 실행 모듈들을 포함한다. 언어 해석기는 형태소 분석, 문법 구문분석, 및 의사결정을 다루는 모듈들을 포함한다. 데이터가 HBDL로서 수신될 때, 형태소 분석기는 HBDL내의 데이터를 소스 코드 언어에서의 개별적인 토 큰들 또는 단어들로 구분한다. 이 설명을 위한 예들에서, 소스 코드는 HBDL로 작성된다. 달리 말해, 형태소 분 석기는 HBDL에서 서로 다른 토큰들 또는 구성 요소들을 식별한다. 이 토큰들은 문법 구문분석기 로 보내지는데, 문법 구문분석기는 이 토큰들을 HBDL을 위하여 의미 있는 문장들 또는 명령 문들로 분류한다. 일단 HBDL에서 문장 또는 명령문이 구성되면, 문법 구문분석기는 실행 모듈 로 이 문장을 보낸다. 그 후 결과적으로 이 명령문을 기초로 하는 액션이 취해진다. 실행 모듈은 시뮬레이션들을 수행하기 위한 많은 서로 다른 서브모듈들을 포함한다. 이 예들에서, 실행 모듈은 인터프리티드 HBDL(IHBDL) 및 HBDL을 생성한다. HBDL은 그래픽 프리미티브들 과 같은 그래픽 데이터의 형태를 취한다. HBDL은 소스 코드를 변경하기 위해 사용되는, 변경되었거나 새 로운 정의이다. HBDL는 소스 코드를 변경하거나 재작성하는데 사용하기 위하여 입력 모듈로 보내진 다. 입력 모듈은 HBDL에서의 새로운 정의를 디스패처 모듈로 전달하는데, 디스패처 모듈 은 HBDL이 소스 코드로 작성되도록 분배한다. 이 설명을 위한 실시예들에서, 문법 구문분석기는 형태소 분석기 및 실행 모듈을 시작시킨다. 문법 구문분석기는 형태소 분석기로부터 토큰들을 요청한다. 형태소 분석기는 토큰들을 생성하기 위하여 HBDL로부터 문자들을 수신한다. 토큰이 생성될 때마다, 형태소 분석기는 그 토큰을 문법 구문분석기로 보낸다. 문법 구문분석기는 그 토큰을 사용하여 하나 이상의 구문분 석 트리들을 생성한다. 구문분석 트리가 완성되면, 문법 구문분석기는 완성된 구문분석 트리를 기초로 하 여 실행 모듈에 의하여 실행될 액션을 요청한다. 이 설명을 위한 예들에서, 각각의 구문분석 트리는 제작물을 나타낸다. 일련의 토큰들이 제작물을 위한 정의와 일치할 때마다, 제작물은 종료 또는 실행되는 한 세트의 하나 이상의 액션들을 가진다. 문법 구문분석기 로부터의 요청에 응하여, 임의의 의미론적 오류들이 액션들을 위한 명령어들에서 발견되는지 여부를 판단하기 위하여 실행 모듈은 의미론적인 분석을 수행한다. 만약 오류가 발생하면, 그 오류는 보고된다. 그렇지 않 으면, 한 세트의 액션들을 위한 명령어들이 실행된다. 액션들이 그 방법에 따라 할당되어 완성된 제작물들에 대 하여 종료된 상태로 비-단말(non-terminal) 호출자들로의 재귀적 복귀가 이루어진다. 이 예들에서, 실행 모듈은 문법 구문분석기에 의해 만들어진 구문분석 트리들에서 생성된 명령어들 이 의미상으로 올바른지 여부를 판단한다. 만약 의미상의 오류들이 발생하면, 실행 모듈은 이 예들에서 - 17 -공개특허 10-2010-0014329오류를 생성하고 그 명령어를 무시한다. 그러나, 일부 경우에는 실행 모듈이 정정되기에 충분한 정보가 존재한다면 이 오류들이 정정될 수 있다. 사용자 입력이 EHBDL로서 수신될 때, 암호화/복호화 모듈들은 HBDL을 형성하기 위하여 정보 를 복호화한다. HBDL은 HBDL이 암호화되지 않은 형태로 되어 있는 사용자 입력이며, HBDL은 등록 모듈들 에 의해 수신된다. 등록 모듈은 사용자 입력을 보내는 각각의 사용자들을 등록하고 유효성을 확인 한다. 이 등록 모듈은 권한을 부여받거나 등록된 사용자들만이 시스템으로 입력을 보내는 것이 허용된다는 것을 보증한다. 예를 들어, 등록 모듈은 특별한 사용자를 위한 비밀번호에 대한 유효성을 확인할 수 있다. 일단 사용자에 대한 유효성이 확인되면, HBDL로 된 사용자 입력은 입력 모듈로 전달된다. 입력 모 듈은 모든 형태의 입력을 한군데로 모으는 구심점으로 동작하고, 특정한 명령어들을 가진 입력을 디스패 처 모듈로 보낸다. 입력 모듈은 입력을 처리하기 위하여 디스패처 모듈이 필요로 하는 명령 어들을 부가할 수 있다. 이 예들에서 입력은 소스 코드에서 수정될 것을 정의한다. 특정한 명령어들은 이 예들에서 특별한 사용자에 의해 소스 코드의 어떤 부분들이 변경될 수 있는가에 대한 명 령어들과 같은 명령어들을 포함한다. 예를 들어, 사용자 입력이 정의를 변경한다면, 명령어는 소스 코드의 어떤 부분이 수정될지를 알려준다. 입력에 의해 변경될 소스 코드 부분은 입력을 생성하는 사용자에 대한 식별자 및 입력 그 자체를 사용하여 식별될 수 있다. 그 다음에, 디스패처(dispatcher) 모듈은 HBDL이 소스 코드로 돌려보내질 때 소스 코드의 적절한 부분이 재작성되는 것을 보증한다. 디스패처 모듈은 사용자에 대한 식별자, 입력, 작성될 소스 코드 부분 을 가지고 폴리시(policy)를 사용하여 소스 코드를 작성할지 여부를 판단한다. 이 폴리시는 입력에 대한 응답으 로 소스 코드에 기입(write)이 이루어져야 하는지 여부를 판단하기 위하여 사용되는 한 세트의 규칙들이다. 이 폴리시는 권한 없는 사용자가 등록 모듈을 통과할 수 있는 경우들을 막기 위하여 여분의 정보를 제공한다. 예를 들어, 권한 없는 사용자는 진정한 사용자로 위장할 수 있고, 입력을 보낼 수 있다. 폴리시는 이 입력에 대하여 진정한 사용자에 의하여 만들어지지 않았거나 진정한 사용자에 의하여 행해진 입력의 특징이 아 닌 변화들이라고 식별할 수 있다. 이 경우에, 이 입력은 디스패처 모듈에 의해 거절된다. 이 예들에서, 각각의 사용자는 사용자가 부가하거나 변경할 수 있는 그들 자신의 한 세트의 액션 세트를 가진다. 결과적으로, 사용자들은 소스 코드의 액션 부분을 변경할 수만 있다. 실행 모듈로부터의 출력, HBDL은 액션들뿐만 아니라 정의들을 재작성하기 위해 사용될 수 있다. 이 예들에서, 언어 해석기는 시스템에서 다른 사용자로도 취급된다. 그러나, 해석기는 영구적으로 권한을 부여받은 사용자이다. 디스패처 모 듈은 언어 해석기에 대하여 HBDL을 사용해서 정의들을 재작성하기 위한 것으로 이해한다. 결과적으로, 시뮬레이션의 임의의 주어진 지점에서, 실제의 인간인 최종 사용자는 데이터베이스에서 정의된 임 의의 인간을 대신할 수 있다. 이 데이터 흐름을 통해서, 해석기는 소스 코드를 재작성하거나 변경할 수 있다. 시간이 흘러가고 시뮬레이션들이 진행되는 동안에, 정의들은 소스 코드를 재작성하기 위해 끊임없이 생성 된다. 입력 모듈은 시뮬레이션에서 실행되고 있는 \"가상 세계\"와 시스템과 통신하는 장치들에서의 사용자들에 의한 사용자 입력을 통해 수신되는 것으로서의 \"현실 세계\" 사이의 연결을 제공한다. 디스패처 모듈은 소 스 코드를 변경하기 위하여 새로운 정의들을 작성하기 위한 메커니즘을 제공한다. 다음으로 도 18을 참조하면, 형태소 분석기를 위한 데이터 흐름을 설명하는 도면이 유익한 실시예에 따라서 도 시된다. 도시된 바와 같이, 형태소 분석기는 소스를 수신하고, 토큰들을 생성하기 위해 소스 를 처리한다. 형태소 분석기는 도 17에서의 형태소 분석기의 예이다. 형태소 분석기는 문자단위로 소스로부터 내용을 읽고, 소스로부터 들어오는 문자들을 토큰들 등의 토큰들을 가리키는 기본 단위들로 분류한다. 이러한 예들에서 정규 표현식들에서의 한 세트의 토큰 설명들을 사용하여 소스에서의 문자들을 토 큰들로 분류하는 것이 수행된다. 정규 표현식들은 소스 내의 문자들을 토큰들로 분류 하기 위해 필요한 설명들을 포함한다. 이 예들에서, 정규 표현식들은 스크립트들을 사용해서 구현될 수 있다. 이 스크립트들은 문자들을 토큰들로 분류하는데 사용하기 위한 문자 패턴들을 설명하는 언어 기호들을 이 용한다. 정규 표현식들에서 정의된 각각의 정규 표현식은 기호가 할당된다. 이 기호는 전형적으로 숫자이다. 형태 소 분석기에 의해 토큰들에서 생성된 토큰은 정규 표현식들에서의 특별한 정규 표현식을 위 - 18 -공개특허 10-2010-0014329한 기호를 사용하여 식별된다. 형태소 분석기는 정규 표현식들 외에도 예약어들도 사용한다. 토큰이 소스 내에서 식 별될 때 예약어들 내의 단어들 또한 기호가 할당된다. 예약어는 언어에서 특별한 문법적인 의미를 지닌 단어이고, 그 언어에서 식별자로서 사용될 수 없다. 이제 도 19를 참조하면, 문법 구문분석기에 의해 수행되는 파싱(parsing) 또는 구문분석을 설명하는 도면이 유 익한 실시예에 따라서 도시된다. 도 19에서 도시된 구문분석은 도 17에서의 문법 구문분석기에 의해 수행 될 수 있다. 트리는 토큰들을 분류하기 위하여 문법 구문분석기에 의해 사용될 수 있는 구문분석 트리의 예이다. 이 예에서, 명령문에 대한 구문분석이 설명된다. 명령문은 \"var1=20\"이다. 이 명령문은 해 석기에 의해 수행될 액션들을 다루고 정의하기 위하여 사용된다. 특히, 문법 구문분석기는 제작물들이라고도 불리는 한 세트의 구문 구조들을 기초로 하여 형태소 분석기에 의해 만들어지는 토큰들 사이의 관계들을 식별한다. 각각의 제작물은 논리 단위를 나타내고, 전형적으로 다른 논리 단위들에서는 토큰들을 사용하여 정의된다. 대부분의 언어들은 두 가지 광역 유형의 논리 단위들을 정의한다. 이 논리 단위들은 이 예들에서 명령문들 및 식들이다. 일반적으로 식들은 값들을 제공하는 구문론상의 언어 구 조들이다. 명령문들은 변수들의 상태를 바꾸거나, 프로그램의 흐름을 제어하거나, 당해 언어에 의해 지원되는 다른 연산들을 수행하는 구문론상의 구조들이다. 문법 구문분석기는 일련의 토큰들을 논리 단위들로 분류하고, 이 논리 단위들을 기초로 하여 실행 모듈에게 액 션들을 실행하라고 지시한다. 이 예에서, 명령문은 형태소 분석기에 의해 생성되는 일련의 토큰들을 포함 한다. 이 토큰들은 변수명, 등호, 식, 및 개행문자이다. 식은 정수인 정수 를 포함한다. 변수명을 위한 값은 var1이고; 등호를 위한 값은 =이고; 정수를 위한 값 은 20이고; 개행문자를 위한 값은 이다. 도시된 바와 같이, 일련의 토큰들이 주어지면 문법 구문분석 기는 스트림에서의 토큰들의 순서를 기초로 하여 문법을 재생성한다. 이제 도 20을 참조하면, 구문분석 트리의 다른 예를 설명하는 도면이 유익한 실시예에 따라서 도시된다. 이 예 에서, 구문분석 트리는 명령문로부터 생성된다. 이 예에서, 명령문은 output=var1+var2*var3이다. 이 예에서, 명령문을 위한 토큰들은 변수명, 등호, 변수명, 덧셈, 변수명 , 곱셈, 변수명, 및 개행문자를 포함한다. 변수명은 값으로 OUTPUT을 가지고; 등호는 값으로 =를 가지고; 변수명은 값으로 var1를 가지고; 덧셈은 값으로 +를 가지고; 변 수명은 값으로 var2를 가지고; 곱셈은 값으로 *를 가지고; 변수명은 값으로 var3를 가지고; 개행문자는 값으로 을 가진다. 명령문에 대한 \"=\" 기호의 반대편 식은 토큰들인 변수명, 덧셈, 변수명, 곱셈, 및 변수명에 의하여 한정된다. 노드들을 식별시키는 것과 관련하여 식들 및 당해 언어에서의 식들의 사용법에 대한 식별자는 구문분석 트리 내에서 토큰들의 위치를 통해 표시된다. 예를 들어, 식은 식들(2022 및 2026)이 연산자를 사용하여 연산이 되는 것을 나타낸다. 이 경우에, 연산자는 덧셈이다. 식은 또한 식을 포함하는데, 식은 식들(2028 및 2030)이 연산자를 사용하여 연산이 되는 것으로 식별한다. 이 예에 서, 식은 변수명을 포함하는 반면, 식은 연산자를 식들(2028 및 2030)에 적용한 결과 들을 포함한다. 이제 도 21을 참조하면, 해석기에서의 실행 모듈에 대한 도면이 유익한 실시예에 따라 도시된다. 이 예에서 실 행 모듈은 도 17에서의 실행 모듈에 대한 더 상세한 설명이다. 도시된 바와 같이, 실행 모듈(210 0)은 마스터 타임라인 제어 모듈, 수학 모듈, 물리학 모듈, 인공 지능(AI) 모듈, 보 고서 생성기, 및 그래픽 모듈을 포함한다. 마스터 타임라인 제어 모듈은 실행 모듈 내에서 시간의 경과에 따라서 이벤트들을 정의들에 적용하 는데 사용되는 스케줄러이다. 수학 모듈 및 물리학 모듈은 서로 다른 객체들에 대한 액션들의 효과 들을 판단하는데 필요한 연산들을 제공한다. 인공 지능 모듈은, 이벤트들이 마스터 타임라인 제어 모듈 에 의해 정의들에 적용되는 동안, 인간행동의 시뮬레이션을 돕기 위하여 상이한 인공 지능 구성요소들을 위한 소스 코드들 실행하는데 사용되는 구성요소이다. 그래픽 모듈은 최종 장치들에서의 표시를 위해 GUI 프로세서에 보내기 위한 그래픽 데이터를 생성한다. - 19 -공개특허 10-2010-0014329보고서 생성기는 이 예들에서 두 개 유형의 출력들을 생성한다. 출력 중 하나의 유형은 소스 코드를 변경 하기 위해 사용되는 새로운 정의이다. 이 생성된 출력은, 예를 들어 도 17에서의 HBDL이다. 보고서 생성 기에 의해 생성되는 출력의 다른 유형은 그래픽 데이터이고, 이 예들에서 이 그래픽 데이터 또한 HBDL 형 식으로 구성된다. 이 출력은 예를 들어, 도 17에서의 IHBDL이다. 그래픽 모듈은 시뮬레이션의 결과들을 사용자에게 나타내는 출력을 생성하기 위해 사용되는 많은 서로 다 른 유형의 프로세스들을 포함한다. 이러한 유형의 프로세스들은 2차원 그래픽 파이프라인들, 2차원 그래픽 프리 미티브들, 3차원 그래픽 파이프라인들, 3차원 그래픽 프리미티브들, 2차원 및 3차원 모델과 스택들, 표시 목록 생성기, 그리고 2차원 및 3차원 렌더링 엔진들을 포함한다. 그래픽 프로세스들의 다른 유형들뿐만 아니라 이 유 형들은 사용자에게 나타내기 위한 출력을 생성하는데 사용하기 위해 그래픽 모듈에 존재할 수 있다. 이제 도 22를 참조하면, 토큰들을 생성하기 위한 프로세스의 순서도가 유익한 실시예에 따라서 도시된다. 도 22 에서 설명된 프로세스는 도 17에서의 형태소 분석기와 같은 소프트웨어 구성요소에서 구현될 수 있다. 프로세스는 소스로부터 다음 문자를 받음으로써 시작된다(연산 2200). 이 예들에서, 문자들의 소스는 도 17에서 의 HBDL이다. 문자는 큐에 배치된다(연산 2202). 다음으로, 큐에서의 문자열이 정규 표현식이나 예약어와 일치하는지 여부에 대하여 판단된다(연산 2204). 만일 일치한다면, 큐에서의 문자열을 사용하여 토큰이 생성된다(연산 2206). 그 후에 큐는 비워진다(연산 2208). 그 후에, 소스에서 파일의 끝 부분인지 여부에 대하여 판단된다(연산 2210). 만일 파일의 끝이라면, 프로세스는 종료된다. 그렇지 않다면, 다음 문자를 얻기 위하여 연산으로 돌아간다. 만일 연산에서 문자열이 일치하지 않으면, 프로세스는 상술한 바와 같이 연산을 수행한다. 이제 도 23을 참조하면, 인간행동의 시뮬레이션을 수행하기 위한 프로세스의 순서도가 유익한 실시예에 따라서 도시된다. 도 23에서 도시된 프로세스는 도 4에서의 프레임워크와 같은 프레임워크로 구현될 수 있다. 특 히, 이 시뮬레이션은 도 6에서의 소스 코드와 같은 소스 코드를 사용하여 수행될 수 있다. 프로세스는 소스 코드 내의 정의에 의해 정의된 한 세트의 인간들을 가상 환경에 거주시킴으로써 시작한다(연산 2300). 이 예들에서, 정의는 도 6에서의 정의와 같은 정의이다. 프로세스는 인간행동을 시뮬레이션한 결과 를 형성하기 위하여 소스 코드 내에서 액션들을 사용해서 가상 환경에서의 한 세트의 인간들에 대해 한 세트의 액션들을 실행한다(연산 2302). 이 예들에서, 한 세트의 액션들은 도 6에서의 액션들과 같은 액션들로부터 취해질 수 있다. 그 후에, 형식화된 출력을 형성하기 위하여 소스 코드에서 그래픽 인터페이스 언어를 사용한 결과로부터 출력이 생성된다(연산 2304). 이 예들에서, GUI 언어는 도 6에서의 GUI 언어일 수 있다. 그 후에, 시뮬레이션이 수행될 때 네트워크 데이터 처리 시스템의 한 세트의 장치들 상에서 형식화된 출력이 표현되고(연산 2306), 그 후에 프로세스는 종료한다. 이러한 방식으로, 다른 유익한 실시예들은 시뮬레이션이 수행되는 동안 수정될 수 있는 소스 코드를 통해 인간 행동을 시뮬레이션한다. 게다가, GUI 언어는 결과가 사용자에게 제공되는 방식이 시뮬레이션 그 자체에 의해 수 정되고 제어되도록 한다. 이제 도 24를 참조하면, 명령문들 또는 제작물들을 생성하기 위한 프로세스의 순서도가 유익한 실시예에 따라 도시된다. 도 19에서 도시된 프로세스는 도 17에서의 문법 구문분석기과 같은 소프트웨어 구성요소로 구 현될 수 있다. 프로세스는 처리를 위해 다음 토큰을 얻음으로써 시작된다(연산 2400). 이 예들에서, 토큰은 도 17에서의 형태 소 분석기와 같은 형태소 분석기로부터 수신된다. 토큰에 대하여 파일의 끝인지에 대하여 판단된다(연산 2402). 만일 파일의 끝이 아니라면, 토큰이 구문분석 트리에 들어맞는지에 대하여 판단된다(연산 2404). 만일 토큰이 구문분석 트리에 들어맞지 않는다면, 오류가 생성되고(연산 2406), 그리고 나서 프로세스는 연산 으로 보내진다. 그렇지 않다면, 토큰이 구문분석 트리를 완성하는지에 대하여 판단된다(연산 2408). 만일 토큰이 구문분석 트리 를 완성한다면, 완성된 구문분석 트리에 대응하는 제작물들을 위한 명령어들이 실행된다(연산 2410). 그 후에, 프로세스는 호출자에게 재귀적으로 보내지고(연산 2412), 그 후에 프로세스는 상술한 바와 같이 연산으로 보내진다. - 20 -공개특허 10-2010-0014329연산을 다시 참조하면, 구문분석 트리가 완성되지 않은 경우 또한 프로세스는 연산으로 보내진다. 연산을 다시 참조하면, 파일에 도달한 경우에는 문법이 부분적으로 재생성되었는지 여부에 대하여 판단된 다(연산 2414). 이 연산은 불완전한 명령문들 또는 제작물들이 존재하는지 여부에 대하여 판단하기 위해 수행된 다. 이러한 판단은 불완전한 구문분석 트리들이 존재하는지 여부에 대하여 알아보기 위해 구문분석 트리들을 조 사함으로써 이루어질 수 있다. 문법이 부분적으로 재생성되는 경우에는 오류가 생성되고(연산 2416), 그 후에 프로세스는 종료된다. 그렇지 않으면, 프로세스는 오류를 생성하지 않고 종료된다. 이제 도 25를 참조하면, 제작물들을 위해 명령문들을 실행하기 위한 프로세스의 순서도가 유익한 실시예에 따라 서 도시된다. 도 25에서 도시된 프로세스는 도 17에서의 실행 모듈과 같은 소프트웨어 구성요소로 구현될 수 있다. 프로세스는 제작물을 위한 한 세트의 명령어들에 대해 의미론적인 분석을 수행함으로써 시작된다(연산 2500). 이 연산은 제작물을 위한 임의의 명령어들에서 의미론적인 오류들이 발생하는지를 판단하기 위해 수행된다. 이 예들에서 한 세트의 명령어들은 하나 이상의 명령어들이다. 그 후에, 의미론적인 에러가 존재하는지 여부에 대 하여 판단된다(연산 2502). 의미론적인 오류가 존재하지 않는 경우, 프로세스는 한 세트의 명령어들을 실행하고(연산 2504), 그 후에 프로 세스는 종료된다. 연산에서 의미론적인 오류가 발생하는 경우에는, 그 오류는 보고되고(연산 2506), 그 후에 프로세스는 종료된다. 일정한 경우들에 있어서, 프로세스는 종료되지 않고 명령어들의 실행을 허용하기 위 하여 오류를 정정하려고 시도할 수 있다. 이제 도 26을 참조하면, GUI 프로세서를 설명하는 도면이 유익한 실시예에 따라서 도시된다. GUI 프로세서 는 도 4에서의 GUI 프로세서의 더 상세한 설명이다. 이 예에서, GUI 프로세서는 암호화/복호 화 모듈들, 그래픽 모듈, 출력 모듈, 입력 모듈, 및 HBDL 생성기를 포함한다. 이 설명을 위한 예들에서, GUI 프로세서는 도 6에서의 소스 코드와 같은 소스 코드로부터 수신된 명 령문들을 실행한다. 특히, 명령문들은 도 6에서의 소스 코드에서 GUI 언어로부터의 명령문들을 포함 한다. 표시들을 생성하기 위한 실제 코드는 별도의 어플리케이션에서 존재하는 것이 아니라 소스들 내에 존재한 다. GUI 프로세서는 명령문들을 실행하고 사용자 입력을 수신한다. GUI 프로세서는 도 17에서의 해석기 와 같은 해석기로부터 암호화된 인터프리티드 HBDL(EHBDL)을 수신한다. 암호화/복호화 모듈 은 인터프리티드 HBDL(IHBDL)을 형성하기 위해 정보를 복호화하고, 이 IHBDL은 그래픽 모듈(260 4)에 의해 처리된다. 이 예들에서, IHBDL은 장치들을 위한 표시를 생성하기 위해 사용될 수 있는 프리미티브들 또는 한 세트의 명령문들을 나타낸다. 그래픽 모듈은 장치들에서 표시되기 위한 픽셀들을 생성하고, 그 데이터를 출력 모듈로 보내 고, 그리고 차례로 출력 모듈은 장치로서 데이터를 장치들로 전송할 수 있다. 사용자 입력은 입력 모듈에 의해 장치들로부터 장치로서 수신된다. 이 모듈은 이 장치 데이터를 HBDL 생성 기로 보내고, HBDL 생성기는 HBDL의 형태로 이 사용자 입력을 나타낸다. HBDL은 HBDL 로 작성된 사용자 입력이다. 이 입력은 암호화/복호화 모듈에 의해 암호화되고, 암호화된 HBDL(EHBDL)로서 해석기로 보내진다. 이 설명을 위한 예들에서, GUI 프로세서는 장치들에 가까운 하드웨어에서 실행된다. 사실, 많은 경 우에 GUI 프로세서의 일부는 서버와 같은 데이터 처리 시스템에서 실행되는 다른 부분들과 함께 장치들 상에서 실제로 실행될 수 있다. GUI 프로세서는 데이터를 나타내는데 필요한 네트워크 자원들의 사용을 줄이는 방식으로 장치들에 가깝게 위치한다. 게다가, 이 예들에서 GUI 프로세서는, 데이터 를 나타내고 사용자 입력을 수신함에 있어서 지연시간을 줄이도록 배치된다. 이제 도 27을 참조하면, GUI 프로세서를 통한 데이터 흐름을 설명하는 도면의 순서도가 유익한 실시예를 따라서 도시된다. 이 예에서, 그래픽 모듈은 도 26에서의 그래픽 모듈의 예이다. 이 예들에서 그래픽 모듈 은 프리미티브들의 형태로 인터프리티드 HBDL을 수신한다. 이 프리미티브들은 해석기로 소스 코드 를 해석한 결과들이다. 그래픽 모듈은 비트맵들을 위한 픽셀들과, 이 비트맵들이 어떻게 조작되거나 표시될지를 식별시키는 데이 터를 생성하기 위하여 이 프리미티브들을 처리한다. 이 정보는 비트맵 데이터로서 클라이언트 프로세스 - 21 -공개특허 10-2010-0014329로 보내진다. 이 예들에서, 클라이언트 프로세스는 도 19에서의 장치들에서의 장치들과 같은 장치들에서 수행되는 프로세스이다. 이 클라이언트 프로세스는 표시부 상에 비트맵 데이터를 표시하기 위 해 필요한 연산들을 수행한다. 이러한 식으로, 표시를 위한 이미지들을 렌더링하기 위해 필요한 그래픽 처리가 그래픽 모듈에 의해 수행된다. 클라이언트 프로세스는 제공된 비트맵 데이터를 표시하기만 하고, 프리미티브들로부터 비트맵 그래픽을 렌더링하기 위해 필요한 처리 능력 및 다른 프로세스들을 요하지 않는다. 이러한 처리 구분을 이용하여, 데이터를 표시하는 장치들은 워크스테이션들에서 사용되는 것들과 같은 그래픽들 을 렌더링하는데 사용되는 그래픽 파이프라인들 및 다른 그래픽 프로세서들을 필요로 하지 않는다. 결과적으로, 그래픽들은 프리미티브들을 다루기 위해 보통 충분한 처리 능력을 가지지 않은 많은 서로 다른 장 치들 상에서 나타내질 수 있다. 예를 들어, 클라이언트 프로세스 및 표시부는 모바일폰, PDA, 또는 타블렛 PC에서 구현될 수 있다. 입력 장치는 표시부에서 표시되고 있는 데이터에 대한 사용자 입력을 수신한다. 이 사용자 입력은 버튼을 선택하거나, 데이터를 입력하거나, 명령을 보내는 등의 그래픽을 조작할 수 있다. 사용자가 표시부 상에서 비트맵들을 조작해서 표시된 이미지를 변경할 때, 표시되고 있는 이미지의 변경에서의 차이 또는 수정들은 클라이언트 프로세스에 의해 식별된다. 이미지에서의 이 차이들은 서로 다른 데이터를 형 성하고, 서로 다른 데이터는 HBDL 생성기로 보내진다. HBDL 생성기는 도 26에서의 HBDL 생성기와 유사하다. HBDL 생성기는 정보에서 이 변화 또는 델타를 식별하고, 해석기로 전송하기 위해 이 변화 또는 델타를 HBDL로 번역한다. HBDL는 소스 코 드 모듈의 언어로 된 명령문들 또는 코드를 포함하고, 소스 코드에 대한 수정들을 만들기 위해 사용될 수 있다. 그래픽 모듈은 서로 다른 비트맵들을 위한 픽셀들을 생성하기 위해 프리미티브들을 사용한다. 이제 도 28을 참조하면, 표시부의 조작을 설명하는 도면을 유익한 실시예에 따라서 도시한다. 이 설명을 위한 예에서, 표시부는 도 27에서의 표시부에서 표시되는 표시부의 예이다. 표시부는 프리미티브 들로부터 생성된 비트맵들을 사용하여 표시된다. 이 예에서, 비트맵들은 슬라이더 및 필드와 같은 서로 다른 구성요소들을 나타내기 위해 사용된다. 슬라이더 및 필드를 나타내기 위해 사용되는 비 트맵 데이터는 이 비트맵들이 어떻게 처리될지를 가리키는 데이터와 함께 보내진다. 이 예에서, 슬라이더(280 2)는 도 28에서의 위치로부터 도 29에서의 표시부 내에서의 위치까지 사용자 입력을 통해 움 직일 수 있는데, 도 29에서의 표시부는 표시부의 수정된 버전이다. 게다가, 50 등의 값이 도 29에 서의 표시부에서 도시된 바와 같이 필드에 입력될 수 있다. 비트맵들에서 이러한 수정들은 유익한 실시예에 따라서 GUI 프로세서로 보내지고, 그 후 GUI 프로세서는 이러한 수정들에 기초하여 소스 코드를 위한 적절한 명령문을 생성한다. 이제 도 30을 참조하면, 비트맵에서의 수정들을 식별하기 위한 프로세스의 순서도가 유익한 실시예에 따라 도시 된다. 도 30에서 설명된 프로세스는 도 27에서의 클라이언트 프로세스와 같은 장치에서의 클라이언트 프 로세스에서 구현될 수 있는 프로세스의 예이다. 프로세스는 사용자 입력을 감시함으로써 시작된다(연산 3000). 사용자 입력이 표시부에서 검출되는지에 대해 판 단된다(연산 3002). 사용자 입력이 검출되지 않는 경우에는, 프로세스는 연산으로 보내진다. 그렇지 않은 경우에는, 사용자 입력이 제어를 조작하는지 여부에 대해 판단된다(연산 3004). 사용자 입력이 제어를 조작하는 경우에는, 제어에 대해 가해진 수정이 비트맵에서 식별된다(연산 3006). 비트맵에서의 이러한 차이 또는 수정 부분은 GUI 프로세서로 돌려 보내지고(연산 3008), 그 후에 프로세스는 추가적인 사용자 입력을 감시하기 위해 연산으로 보내진다. 데이터 수정 부분은 구체적인 구현에 따라서 수정된 실제의 비트맵이거나 비트맵의 위치에서의 변화에 대한 식별자일 수 있다. 물론, 실시예에 따라서 다른 유형들의 수정들이 이용될 수 있다. 다시 연산을 참조하면, 사용자 입력이 제어를 조작하지 않는 경우에는, 사용자 입력이 필드에서의 데이터 항목인지 여부에 대해 판단된다(연산 3010). 사용자 입력이 데이터의 항목이 아닌 경우에는, 프로세스는 연산 으로 보내진다. 그렇지 않은 경우에는, 프로세스는 연산을 진행하여, 비트맵에서 가해진 변화를 식 별한다. 이 예들에서 사용자 입력에 대해 행해진 특별한 결정들은 필드들에 대한 수정들 및 도 21에서의 실행 모듈 과 같은 표시부에서의 제어들을 식별시키기 위한 것들이다. 관심 있는 비트맵에 대한 임의의 유형의 수정 에 대해 판단될 수 있다. 예를 들어, 특별한 버튼이 선택되었거나 회전되었는지 여부에 대한 수정이 존재할 수 있다. - 22 -공개특허 10-2010-0014329이제 도 31을 참조하면, 차이 데이터를 다루기 위한 프로세스의 순서도가 유익한 실시예를 따라 도시된다. 도 31에서 설명된 프로세스는 도 26에서의 GUI 프로세서와 같은 GUI 프로세서에서 구현될 수 있다. 특히, 도 31에서 설명된 프로세스는 도 27에서의 HBDL 생성기에서 구현될 수 있다. 프로세스는 클라이언트 프로세스로부터 차이 데이터를 수신함으로써 시작된다(연산 3100). 이 예들에서, 차이 데이터는 사용자 입력을 통해 만들어진 비트맵에서의 수정들을 포함한다. 그 후 프로세스는 이 차이를 기초로 하여 사용자 입력을 식별한다(연산 3102). 이 사용자 입력은 예를 들어, 슬라이드 위치의 수정, 데이터 필드로 의 데이터 항목, 또는 일부 다른 사용자 입력으로서 식별될 수 있다. 연산에서 만들어진 식별자는 장치로 보내진 원래의 비트맵과 수정된 비트맵을 비교함으로써 만들어진다. 예를 들어, 만일 그 차이가 이러한 유형의 제어를 따라서 슬라이더를 상향으로 움직이는 것으로 식별되는 경우에는, 사용자 입력은 인간의 적시성 (timeliness)을 수정하는 것일 수 있다. 이러한 유형의 차이에 대한 예가 실행 모듈의 관점에서 도 21에 서 설명된다. 그 후에, 사용자 입력은 소스 코드에 의해 사용되는 형식으로 변환된다(연산 3104). 이 예들에서, 사용자 입력 은 HPDL 형식으로 수정된다. 변환된 사용자 입력은 해석기로 보내지고(연산 3106), 그 후에 프로세스는 종료된 다. 이제 도 32를 참조하면, 인간 트랜스페어런시 패러다임(Human Transparency Paradigm)을 제공하는데 사용하기 위한 구성요소들을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 설명을 위한 예에서, 시뮬레이션 은 도 4에서의 프레임워크와 같은 프레임워크를 사용하여 수행된다. 특히, 시뮬레이션은 도 4 에서의 해석기와 같은 해석기에 의하여 소스 코드의 해석을 통해 수행된다. 이 특별한 예에서, 시뮬레이션은 인공 지능(Artificial Intelligence; AI)을 포함하고, 인공 지능 은 시뮬레이션 내에서 인간을 나타낸다. 인공 지능에 의해 실행되는 이러한 인간은 이 예들 에서 합성 인간이다. 인공 지능을 위한 코드는 시뮬레이션을 위해 사용되는 다른 정보와 함께 정의 로부터 검색된다. 정의는 도 4에서의 소스 코드와 같은 소스 코드에 존재한다. 정의는 합성 인간뿐만 아니라 다른 인간들과 그 인간들이 시뮬레이션을 위해 존재하는 환경에 대한 정의를 포함 한다. 결과들이 시뮬레이션 동안 생성됨에 따라, 이 결과들은 사용자 입력으로서 통신 모듈들로 보 내진다. 이 예에서, 이러한 통신 모듈들은 또한 도 4에서의 해석기와 같은 해석기에 존재한다. 통신 모듈 들은 시뮬레이션으로부터 사용자 입력을 취하고, 새로운 정의들을 정의로 변경하거나 작성한다. 이것은 변경된 소스 코드를 형성하고, 그 후 변경된 소스 코드는 부가적인 결과들을 만들어 내기 위 해 시뮬레이션에 의해 사용된다. 인공 지능은 이 예들에서 현실의(live) 사용자와 같은 방식으로 프레임워크에 접속한다. 게다가, 시뮬레이션으로부터의 결과들은 사용자에게 나타내기 위한 장치로 보내진다. 이 예들에서, 사용자는 실제 인간이다. 설명을 위한 실시예들은 인간 트랜스페어런시 패러다임을 사용할 수 있게 한다. 이 패러다임에서, 정의로 재작성된 인공 지능에 의해서 생성된 사용자 입력은 사용자로부터의 현실의 사용자 입력으로 대체될 수 있다. 달리 말해, 사용자는 시뮬레이션 내에서 인공 지능을 통해 시뮬레이션된 합 성 인간에 의해서 생성된 사용자 입력 대신에 새로운 정의들을 정의로 변경하거나 작성하기 위해 사용자 입력을 통신 모듈들로 보낼 수 있다. 이 예들에서, 사용자는 사용자 입력을 제 공하는 주제별 전문가(subject matter expert)일 수 있다. 이 예들에서, 사용자 입력은 시뮬레이션 동안 제공된다. 이 사용자 입력은 장치에서 수신되고 표시된 결과들에 대한 응답일 수 있다. 인공 지능에 의해 시뮬레이션된 합성 인간은 합성 인간을 위한 고유 식별자(Unique Identifier; UI)와 결합된 사용자 입력을 생성한다. 사용자 입력은 시뮬레이션 동안 인공 지능 에 의해 생성된다. 사용자 입력은 고유 식별자와 결합된다. 사용자 입력은 통신 모듈 들로 보내진다. 통신 모듈들은 사용자 입력을 사용하여 새로운 정의들을 추가하거나 현재의 정의들을 변경함으로써 정의를 변경한다. 통신 모듈들은 고유 식별자에 의거하여 정의 중 어느 부분을 변경할지를 분간한다. 사용자가 사용자 입력을 생성하는 경우에, 사용자 입력은 통신 모듈들에 의해 수신된 다. 이 설명을 위한 예들에서, 사용자 입력은 또한 고유 식별자를 포함할 수 있다. 이러한 식으로, - 23 -공개특허 10-2010-0014329통신 모듈들은 고유 식별자와 결합된 합성 인간을 위한 정의를 변경한다. 이러한 식으로, 사용자는 시뮬레이션 내에서 인공 지능을 통해 시뮬레이션된 합성 인간을 대 신할 수 있다. 통신 모듈들로 보내진 요청들을 기초로 하여, 사용자는 조정기에서 인공 지능(320 2)을 켜고 끌 수 있다. 사용자 입력을 사용자 입력으로 교환하는 것을 시작할 때, 장치에서 있는 사용자는 통 신 모듈들로 요청을 보낸다. 이 시점에서, 사용자는 통신 모듈들에 접속하여 인증된 것으로 한다. 통신 모듈들은 사용자가 인공 지능을 켜고 끄는 것에 대한 권한을 부여받았는지 여부 에 대해 판단한다. 달리 말해, 통신 모듈들은 사용자가 합성 인간을 대신할 수 있을지 여부를 판단 한다. 사용자가 권한을 부여받은 경우에는, 통신 모듈들은 인공 지능을 정지하라는 플래그 (flag)를 설정한다. 달리 말해, 인공 지능을 위한 함수들은 시뮬레이션 내에서 더 이상 호출되지 않는다. 이 시점에서, 사용자는 고유 식별자를 포함하는 사용자 입력을 생성한다. 구체적인 구현에 따라서, 고유 식별자는 사용자가 장치에서 사용자 입력을 보내는 것을 인식하는 것을 기초로 하여 통신 모듈들에 의해 추가될 수 있다. 이제 도 33을 참조하면, 합성 인간을 현실의 인간으로 대체하는 프로세스의 순서도가 유익한 실시예에 따라서 도시된다. 이 예에서, 도 33에서 설명된 프로세스는 도 4에서의 해석기와 같은 해석기에서 구현될 수 있다. 특히, 프로세스는 해석기 내에서의 통신 모듈들에서 구현될 수 있다. 프로세스는 합성 인간을 대신할 사용자로부터 요청을 받음으로써 시작된다(연산 3300). 그 후에, 사용자가 모의 (simulated) 인간을 대신할 권한을 부여받았는지 여부에 대해 판단된다(연산 3302). 이 예들에서, 시뮬레이션 동안 어떤 사용자들이 합성 인간들을 대신할지를 정의하는 목록이나 데이터베이스를 사용자와 비교함으로써 판 단된다. 예를 들어, 일정한 사용자들은 특정 영역에서 주제별 전문가들이고 그 특정 영역들에 대해 합성 인간들 을 대신하도록 허가받았을 수 있다. 예를 들어, 특정 사용자는 정치학에 관해 주제별 전문가일 수 있다. 그 사 용자는 시뮬레이션에서 정치가인 합성 인간을 대신하도록 허가받을 수 있다. 그러나, 그 주제별 사용자는 농부 나 군인인 합성 인간을 대신하도록 허가받지 못할 수 있는데, 이는 그 주제별 전문가가 그 분야에서 전문적 지 식을 소유하고 있지 않기 때문이다. 어떤 사용자들이 합성 인간들을 대신할지에 대한 특별한 규칙들은 전적으로 구체적인 구현에 의존한다. 사용자 가 합성 인간을 대신할 권한을 부여받은 경우에는, 합성 인간을 위한 인공 지능의 사용이 정의들에서 오프(trun off)된다(연산 3304). 그 후에, 프로세스는 사용자로부터 사용자 입력을 기다린다(연산 3306). 사용자 입력을 받은 때에는, 사용자 입 력이 정의들에서 새로운 정의를 작성하는지 여부에 대해 판단된다(연산 3308). 사용자 입력이 새로운 정의를 작 성하는 것인 경우에는, 사용자 입력은 새로운 정의를 작성하기 위한 형식으로 형식이 지정된다(연산 3310). 그 후에, 정의는 소스 코드로 작성되고(연산 3312), 그 후에 프로세스는 상술한 바와 같이 연산으로 보내진 다. 연산을 다시 참조하면, 사용자 입력이 새로운 정의를 작성하지 않는 것인 경우에는, 사용자 입력이 인공 지능을 온(turn on)시키는 것인지 여부에 대해 판단된다(연산 3314). 사용자 입력이 인공 지능을 온시키는 것이 아닌 경우에는, 프로세스는 연산으로 보내진다. 그렇지 않은 경우에는, 인공 지능은 합성 인간을 시뮬레 이션하는데 사용하기 위해 다시 온되고(연산 3316), 그 후에 프로세스는 종료된다. 연산은 시뮬레이션에 서 합성 인간을 다시 배치시키고 시뮬레이션으로부터 현실의 인간을 제거한다. 연산을 참조하면, 사용자가 합성 인간을 대신하는 권한을 부여받지 않은 경우에는, 에러 메시지가 생성되 고(연산 3318), 그 후에 프로세스는 종료된다. 프레임워크에 의해 제공된 시뮬레이션들은 100% 확실하게 인간행동을 예측하도록 의도되지는 않으나, 결정하거 나 수정할 수 있는 가능성들을 제공하도록 의도된다. 시뮬레이션들로부터의 결과들은 프레임워크에 의해 만들어 진 시뮬레이션들 없이는 가능하지 않은 안내 및 예측들을 제공한다. 다른 유익한 실시예들에서, 소스 코드는 도 6에서의 정의, 액션들, 및 GUI 언어에서의 서 로 다른 특징들을 제공하기 위해 구체적으로 설계된 언어를 사용하여 구현될 수 있다. 다른 유익한 실시예들에 서, 도 6에서의 소스 코드는 또한 다른 기존의 언어들 또는 프로그래밍 방법론들로부터 기능들 및 특징들 - 24 -공개특허 10-2010-0014329을 포함할 수 있다. 다른 유익한 실시예들에서, 인공지능 시스템들이 예컨대 도 6에서의 정의 및/또는 액션들과 같은 소 스 코드의 일부들을 구현하기 위해 사용될 수 있다. 일부 유익한 실시예들에서, 인공 지능은 뉴럴 네트워 크의 형태(또는 다른 인공 지능의 형태들)로 다양한 객체들을 시뮬레이션하기 위해 사용될 수 있다. 예를 들어, 뉴럴 네트워크는 인간 또는 동물과 같이 생명이 있거나 살아 있는 객체를 시뮬레이션하기 위해 사용될 수 있다. 인공 지능은 예컨대, 형식주의와 통계 분석으로 특징지어지는 기계 학습이 이용되는 종래의 인공 지능일 수 있 다. 게다가, 인공 지능은 예컨대, 컴퓨터 지능(Computational Intelligence)의 형태일 수 있다. 컴퓨터 지능은 반복적인 진화나 학습을 포함한다. 이러한 유형의 인공 지능은 경험적인 데이터를 기초로 학습할 수 있다. 컴퓨 터 지능의 예로는 뉴럴 네트워크, 퍼지 논리, 및 유전자 알고리즘(Genetic Algorithm)들을 포함할 수 있는데, 이에 제한되지는 않는다. 이 프로그래밍 기술들은 도 6에서의 소스 코드 내에서 추가적인 특징들을 보충하거나 제공하기 위해 사용될 수 있다. 다른 유익한 실시예들에서, 도 6에서의 소스 코드는 다양한 프로그래밍 기 술들에 추가하거나 결합시켜 기존의 프로그래밍 언어를 사용하여 구현될 수 있다. 하나의 유익한 실시예에서, 뉴럴 네트워크와 같은 프로그래밍 기술은 도 6에서의 소스 코드의 일부들을 구 현하기 위해 사용될 수 있다. 예를 들어, 도 6에서의 정의의 일부 또는 전부는 뉴럴 네트워크들을 사용하 여 구현될 수 있다. 뉴럴 네트워크는 생물학적인 뉴럴 네트워크들을 기초로 하는 수학적인 연산 모델이다. 뉴럴 네트워크들은 비선형 통계 데이터 모델링 풀(pool)들을 제공하고, 입력들과 출력들 사이에서의 복잡한 관계들을 모델링하기 위해 사용될 수 있다. 뉴럴 네트워크들은 도 6에서의 정의 내에서 다양한 객체들을 위한 학습 기능들을 제공하기 위해 채택될 수 있다. 일례로, 뉴럴 네트워크 기술들은 도 6에서의 소스 코드의 정의 내에서의 사람들, 동물들, 또는 다른 적절한 객체들 등의 상이한 객체들을 위한 학습 특징을 제공하기 위해 이용될 수 있다. 이러한 유형의 예에서, NN은 뉴럴 네트워크 형식의 변수를 나타낸다. 선언의 예는 “NN n;”일 수 있다. 이 예에서, 이러한 유형의 명 령문은 뉴럴 네트워크 변수를 선언한다. 자식들(children)인, n.input, n.output, 및 n.hidden 또한 생성될 수 있다. 이들 다른 변수들은 뉴럴 네트워크에서의 입력, 출력, 및 히든 레이어들을 나타낸다. 이 레이어들에 의해 서 사용자는 뉴런들을 서로 다른 레이어들에 추가하는 것이 가능하다. 이 서로 다른 레이어들에 있어서, 입력 뉴런들은 입력 뉴럴 네트워크 레이어에 대한 자식들로서 추가될 수 있다. 도 34를 참조하면, 명령문들(3400 및 3402)은 입력 뉴런들의 예들이다. 명령문에서 섹션은 뉴럴 네 트워크 n을 위한 입력 뉴런으로서의 \"왼쪽 피연산자(left operand)\"를 선언한다. 이 입력 구성원은 또한 입력 뉴런들의 전체 개수를 읽기 위해 사용될 수 있다. 구성원 \"input\"의 값은 새로운 구성원이 추가될 때마다 1씩 증가된다. 결과적으로 \"input\"의 값은 입력 뉴런들의 전체 개수이다. 이 명령문들은 C 언어 또는 다른 언어들 예컨대, C+ 및/또는 객체지항-C와 같은 언어를 사용하여 구현될 수 있는 HBDL 의사코드(pseudo code)의 예들이 다. 이 예들에서, 입력 뉴런 변수들은 0에서부터 1까지 범위의 값을 가질 수 있다. 각각의 입력 뉴런 변수는 최소 범위 및 최대 범위를 가진다. 이 범위들에 의해서 그 범위 내에서는 사용자가 임의의 값을 입력하는 것이 가능 하다. 구체적인 구현에 따라서 이 값들은 또한 사용하기 전에 정규화될 수 있다. 도 35를 참조하면, 명령문들(3500 및 3502)은 입력 뉴런 왼쪽 피연산자를 위해 정의된 입력 범위들의 예들이다. 이 예에서, 명령문은 -10이라는 최소값을 정의하고 명령문은 10이라는 최대값을 정의한다. 이제 도 36을 참조하면, 입력 행동을 위한 명령문의 도면이 유익한 실시예에 따라서 도시된다. 명령문에 의해 입력 뉴런이 사용되기 전에 입력 뉴런이 변경되는 것이 가능하다. 달리 말해, 입력 뉴런은 입력 뉴런에 의 해서 사용자 입력에 대한 조작을 가능하게 하는 뉴런이 부착 또는 결합된 코드를 가질 수 있다. 예를 들어, 사 용자 입력은 짧을 수도 길 수도 있다. 이 예에서, 뉴런의 입력 행동은 길고 짧음을 해석하여 0과 1사이에서 평 가한다. 명령문은 이러한 유형의 행동을 입력 뉴런에 부착하기 위해 사용될 수 있는 코드의 예이다. 이제 도 37을 참조하면, 출력 선언을 도시하는 도면이 유익한 실시예를 따라서 도시된다. 명령문은 출력 뉴럴 네트워크 레이어에 자식들을 추가하기 위해 사용되는 명령문의 예이다. 이제 도 38을 참조하면, 뉴럴 네트워크에서의 출력 범위들을 위한 명령문들을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서 명령문들(3800 및 3802)은 출력 뉴런을 위해 설정될 수 있는 범위들의 예들이다. 최소 및 최대 범위가 명령문들(3800 및 3802)에 의해 설정된다. - 25 -공개특허 10-2010-0014329이 특별한 예에서, 출력 뉴런에 대해서 최대값은 50인 반면에, 최소값은 -50이다. 게다가, 사용자는 암시적인 정규화된 출력을 특정된 범위들 내의 값으로 변환할 수 있다. 예를 들어, 출력 1은 50으로, 출력 0.5는 0으로 변환될 수 있다. 게다가, 출력 뉴런은 또한 출력을 조작하기 위한 코드와 결합될 수 있다. 이제 도 39를 참조하면, 출력 행동을 변경하기 위한 명령문을 설명하는 도면이 유익한 실시예를 따라서 도시된 다. 명령문은 출력 뉴런과 결부될 수 있는 코드의 예이다. 이 예에서, 사용자 출력은 로우(low)와 하이 (high)일 수 있다. 이 특별한 예에서, 뉴런의 출력 행동은 0과 1 사이에 있는 값을 로우와 하이로 해석할 수 있 다. 이제 도 40을 참조하면, 히든 레이어들을 위한 명령문들을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 명령문들(4000 및 4002)은 임의의 뉴럴 네트워크의 히든 레이이어들을 선언하기 위해 사용될 수 있는 명령문들 의 예들이다. 이 예들에서, 히든 레이어의 순서는 히든 레이어 선언들의 순서를 따른다. 히든 레이이어 변수의 값은 특별한 히든 레이어에 할당된 뉴런들의 수를 특정한다. 이 예들에서, 명령문들(4000 및 4002)은 2개의 히 든 레이어들을 선언한다. 명령문에 의해 정의된 제1 레이어는 5개의 뉴런들을 포함하고, 명령문에 의해 선언된 제2 레이어는 3개의 뉴런들을 정의한다. 이제 도 41을 참조하면, 코드는 뉴럴 샘플 값을 특정하기 위해 사용되고 있는 샘플 뉴럴 네트워크 구성원 을 설명한다. 상이한 샘플이 지정될 수도 있다. 각각의 입력 및 출력 뉴런은 명령문들 내에서 \"sample [int]\"를 포함한다. 뉴럴 네트워크가 완성되면, 사용자는 뉴럴 네트워크를 훈련시킬 수 있고 사용할 수 있다. 이제 도 42를 참조하면, 뉴럴 네트워크를 훈련시키기 위한 예시적인 명령문들이 유익한 실시예를 따라 도시된다. 명령문들(4200, 4202, 및 4204)은 뉴럴 네트워크의 훈련을 수행하기 위해 사용되는 명령문들의 예들 이다. 명령문은 뉴럴 네트워크가 500회 훈련될 것이라는 것을 가리킨다. 명령문은 300회, 그리고 명령문은 200회의 훈련을 가리킨다. 이 예들에서 훈련은, 저장되고 있는 결과들과 함께 누적된다. 이 상 이한 결과들은 특별한 객체를 위하여 도 6에서의 정의 또는 소스 코드 내에 저장될 수 있다. 이제 도 43을 참조하면, 뉴럴 네트워크에서의 계산 함수를 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 명령문(4300 및 4302)은 입력 뉴런이 함수를 실행하여 결과를 반환시키도록 하는데 사용되는 명령문 들의 예를 제공한다. 이 예들에서, 명령문은 명령문들(4300 및 4302)의 다른 표현이다. 이제 도 44를 참조하면, 뉴럴 네트워크의 예를 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 코드는 뉴럴 네트워크를 훈련하고 실행하기 위한 명령문들과 함께 뉴럴 네트워크의 정의를 포함한다. 입 력 선언들은 섹션에 존재한다. 입력 범위들은 섹션(4404 및 4406)에 존재한다. 뉴런들과 결합된 코드는 명령문들(4408 및 4410)에 존재한다. 출력 범위들은 섹션에 존재하고 출력을 위한 행동은 명령문에 존재한다. 히든 레이어들은 섹션에서 정의되고, 그 기능은 명령문에 존재한다. 샘플들은 섹션에 존재할 수 있고, 명령문은 훈련 명령문의 예이다. 섹션은 뉴럴 네트워크를 동작시키기 위해 사용되는 명령 문들의 예들을 설명한다. 섹션 내에서의 명령문은 결과들을 표시한다. 이제 도 45를 참조하면, 뉴럴 네트워크 연산의 결과들을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 표시화면은 도 44에서의 코드로부터의 표시 명령문에 대한 응답으로 생성된 표시화 면의 예이다. 뉴럴 네트워크들과 함께, 도 6에서의 정의 내에서의 객체들의 다양한 속성들 및 특성들을 다루기 위해 동 적 리스트(dynamic list)들이 사용될 수 있다. 동적 리스트들은 도 8에서의 객체에서의 특성들 및 도 9에 서의 객체에 대한 특성들과 같은 특성들을 정의하기 위해 사용될 수 있다. 예를 들어, 동적 리스트들은 구성요소들, 수용능력들, 특성들, 또는 객체를 위한 다른 적절한 매개변수들의 식 별자를 제공하기 위해 사용될 수 있다. 예를 들어, 객체가 자동차라면, 동적 리스트는 바퀴들, 엔진, 차제, 페 인트, 변속기, 창문들, 및 다른 구성요소들과 같은 구성요소들을 식별하기 위해 사용될 수 있다. 구성요소들이 자동차에 부가되거나 자동차로부터 제거됨에 따라, 리스트는 이 수정들을 식별하기 위해 변경될 수 있다. 다른 유익한 실시예들에서, 임의의 변수가 리스트에서 사용될 수 있다. 동적 리스트들에 있어서, 예상되는 구성 요소들 또는 매개변수들을 기초로 하여 리스트 크기들을 미리 정의하도록 하여야 함으로써 정의들이 제한되지는 않는다. 대신에, 리스트 크기는 다양한 매개변수들 또는 구성요소들이 특별한 정의에 추가되거나 특별한 정의로 부터 제거됨에 따라서 변할 수 있다. - 26 -공개특허 10-2010-0014329도 46을 참조하면, 리스트의 예를 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 코드는 명령문에서의 리스트 1을 정의한다. 명령문들(4602, 4604, 및 4606)은 리스트 1에서의 값으로 3개의 변수 들을 식별한다. 이 예에서, 리스트 1은 어레이로서 동작한다. 코드 내에서의 명령문은 어레이의 크 기를 식별시키는 값을 반환하는 크기 함수의 예이다. 이 예에서, 명령문은 3이라는 값을 반환한다. 명령문들(4610 및 4612)은 코드 내에서의 리스트를 검색하기 위해 사용되는 명령문들의 예들이다. 명령문 은 참에 상응하는 2라는 값을 반환하고, 명령문은 거짓에 상응하는 0이라는 값을 반환한다. 명령문 들(4610 및 4612)에서의 이 검색 함수들은 리스트가 특정 값을 포함하는지 여부를 판단하기 위해 사용될 수 있 다. 특정 값이 리스트 내에 존재하는 경우에는, 리스트 내에서의 그 값에 대한 인덱스가 반환된다. 그렇지 않은 경우에는 0이라는 값이 반환된다. 이제 도 47을 참조하면, 리스트로부터 변수를 삭제하는 것을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 코드는 섹션에서 정의된 바와 같은 리스트를 포함한다. 명령문은 코드 내에서의 리스트로부터 항목을 삭제하기 위해 사용될 수 있는 삭제함수이다. 명령문은 특별한 항 목이 리스트 내에 존재하는지 여부에 대해 판단하기 위해 리스트를 검색한다. 항목이 존재한다면, 그 항목은 리 스트로부터 삭제된다. 명령문은 삭제된 항목을 식별시키기 위한 인덱스를 반환한다. 그렇지 않은 경우에 는, 명령문은 0을 반환한다. 이 예에서, 25라는 값은 코드 내의 리스트에 존재하지 않고, 0이 반환 되며, 아무런 액션도 취해지지 않는다. 이 예에서, 항목들은 값을 식별함으로써 삭제된다. 이제 도 48을 참조하면, 항목들을 삭제하기 위한 코드의 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 코드는 섹션에서의 리스트를 정의한다. 명령문들(4804 및 4806)은 인덱스 값들을 기초로 하여 리스 트에서 항목들을 삭제하기 위해 사용되는 명령문들이다. 명령문이 리스트의 크기보다 작은 인덱스 값을 식별하 는 경우에는, 그 항목은 리스트 내에 위치하고 있는 것이며 삭제된다. 그 후 그 함수는 삭제된 항목에 대한 값 을 반환한다. 그렇지 않은 경우에는, 그 항목이 리스트에 존재하지 않는다는 것을 의미하는 0을 반환한다. 섹션 에서 정의된 바와 같이 단지 세 개의 항목들만이 리스트에 존재하기 때문에, 명령문은 0을 반환한 다. 명령문에 의해, 명령문에서 정의된 항목이 삭제되면서, 20이 반환된다. 이제 도 49를 참조하면, 리스트에서 항목들을 조작하기 위한 코드를 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 코드는 리스트에서 항목들을 조작하기 위해 사용될 수 있다. 이 예들에서, 코드 는 스택의 리스트를 사용하기 위한 넣기(push) 및 꺼내기(pop) 함수들을 포함한다. 명령문은 조작 들이 가해지는 리스트를 식별시킨다. 이 예에서, 섹션은 리스트에 가해지는 세 개의 넣기들을 식별시킨다. 명령문은 리스트에 가해지는 꺼내기를 설명한다. 명령문은 리스트의 앞에서부터 꺼내 진 항목들로부터의 값을 반환한다. 이러한 유형의 함수들은 컴퓨터 시스템들에서의 스택들을 조작하기 위해 사용되는 것들과 유사하다. 넣기(pus h)는 특별한 항목을 리스트의 상단으로 넣거나 이동시키기 위해 사용된다. 꺼내기(pop)는 리스트의 상단에서 항 목에 대한 값을 반환하기 위해 사용된다. 만일 꺼내기 명령문이 값 또는 매개변수를 포함한다면, 이 명령문은 매개변수의 값에 따라서 스택으로부터 값들을 꺼내거나 반환한다. 명령문에서는 꺼내지고 있는 항목이 3 이라는 인덱스 값을 가진 항목인데, 이 예들에서는 리스트에서 3번째 항목이다. 이제 도 50을 참조하면, 큐로서 리스트를 사용하는 것을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 코드는 큐로서 리스트를 조작하기 위해 사용될 수 있는 큐에 넣기(enqueue) 및 큐에서 꺼내기 (dequeue) 함수들을 설명한다. 명령문에서 보인 바와 같은 큐에 넣기 함수는 리스트의 하단에 인자 (argument)를 추가한다. 명령문에서 보인 바와 같은 큐에서 꺼내기 함수는 리스트로부터 상단 항목을 삭제하고, 그 항목의 값을 반환한다. 이 예에서, 명령문은 리스트 1에 항목을 추가하고, 명령문은 그 큐의 상단에 다른 항목 을 추가한다. 이제, 명령문에서의 항목은 그 큐에서 두 번째이다. 명령문은 다른 항목들을 큐에서 더 아래쪽으로 밀어내면서 또 다른 항목을 그 큐로 추가한다. 이제 도 51을 참조하면, 리스트로부터 항목들을 읽는 것을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 코드는 섹션에서 정의된 바와 같이 리스트의 상단과 하단으로부터 항목들을 읽는 것을 설명한다. 명령문은 리스트의 상단에 위치한 항목을 읽고, 명령문은 리스트의 하단에 포함된 항목 을 읽는다. 이제 도 52를 참조하면, 리스트에서 정렬 속성을 설명하는 도면이 유익한 실시예를 따라서 도시된다. 코드 - 27 -공개특허 10-2010-0014329는 리스트를 위해 정렬 상태를 식별시키기 위해 사용되는 명령문들을 포함한다. 명령문은 정렬 상 태가 리스트를 위해 설정되어 있는지 여부를 식별시킨다. 명령문이 참(true)으로 설정되어 있다면, 항목 들은 그 값에 따라 리스트로 삽입된다. 명령문은 정렬 순서를 식별시킨다. 명령문이 참과 같은 것으로 설정되어 있다면, 리스트는 가장 작은 것에서부터 가장 큰 것까지 내림차순으 로 정렬된다. 이 예에서, 명령문은 거짓(false)으로 설정되어 있다. 결과적으로, 항목들은 섹션에 서 보인 바와 같이 내림차순으로 리스트에 추가된다. 게다가, 추가적인 명령문들이 다양한 순서로 리스트를 정 렬하기 위해 사용될 수 있다. 도 6에서의 소스 코드를 구현하기 위해 사용될 수 있는 프로그래밍 기술의 다른 예가 퍼지 논리이다. 퍼지 논리을 구현하기 위해 사용되는 언어의 예가 프롤로그(Prolog)이고, 프롤로그는 퍼지 논리 또는 인공 지능 프로 그래밍을 위해 사용될 수 있는 논리 프로그래밍 언어이다. 도시된 예들에서, 퍼지 논리 시스템은 논리적인 명령문들을 기초로 할 수 있고, 논리적인 명령문들에서 피연산 자는 여러 집합으로부터 취해진 조건들(terms)이다. 일례로, 그 집합들은 예컨대, 연료, 거리, 및 속력일 수 있 다. 연료는 적음, 보통, 및 많음이라는 3개의 조건을 포함할 수 있다. 거리는 근거리와 원거리일 수 있다. 이 예들에서, 속력은 낮음, 보통, 및 높음일 수 있다. 이 집합들은 연료가 적거나 거리가 가까우면 속력는 낮다는 것과 같은 규칙들을 적용하기 위해 사용될 수 있다. 연료가 보통이고 거리가 멀면 속력은 보통이라는 다른 규칙 도 있다. 연료가 많고 거리가 멀면 속력이 높다는 제3의 규칙도 있다. 퍼지 논리를 이용하여, 그 집합의 서로 다른 구성원들을 위한 범위들이 설정될 수 있다. 이 범위들은 최소 및 최대 범위를 포함한다. 이제 도 53을 참조하면, 연료 거리 및 속력을 사용하여 퍼지 논리를 구현한 예가 유익한 실시예를 따라서 도시 된다. 이 예에서, 코드는 섹션에서의 이 집합들을 정의한다. 연료는 정수인 반면에, 거리 및 속력 은 실수형 변수들이다. 섹션은 연료의 최소 및 최대 범위가 0과 100 사이에 존재하는 것처럼 식별시킨다. 연료를 위한 시작과 종료 조건들은 섹션에서 정의된다. 이 섹션은 퍼지 집합의 왼쪽 및 오른쪽 끝들을 식 별시킨다. 섹션들(5308, 5310, 및 5312)은 연료를 위한 조건들을 식별시킨다. 섹션은 사다리꼴의 조건을 식별시키고, 섹션은 삼각형의 조건을 식별시키고, 섹션은 정규분포(bell curve) 조건을 식별시킨다. 거리를 위한 유사한 정의들이 섹션에 존재한다. 이 예에서, 퍼지 논리를 위한 규칙들은 섹션에서 정의된다. 섹션은 연료 및 거리를 위한 초기 값을 식별시킨다. 명령문은 속력을 계산하기 위해 사 용된다. 도 6에서의 소스 코드 내에 있는 다양한 객체들을 시뮬레이션하기 위해 사용될 수 있는 다른 유형의 프로 그래밍 기술에는 진화 연산(Evolutionary Computation)을 포함될 수 있다. 진화 연산은 인공 지능의 한 유형이 다. 한 가지 특정한 방법 또는 방법론이 유전자 알고리즘이다. 이 알고리즘은 해들을 식별하기 위해 사용되는 검색 기술이다. 이러한 유형의 기술은 전역 검색 자기학습 유형의 기술로서 여겨진다. 유전자 알고리즘에 있어 서, 염색체들뿐만 아니라 유전자들이 선언될 수 있다. 적합도 함수, 선택 프로세스, 및 재조합 함수들 또한 이 러한 유형의 기술을 사용하여 특정된다. 이제 도 54를 참조하면, 유전자 알고리즘을 사용하여 방정식을 푸는 것을 설명하는 도면이 유익한 실시예를 따 라서 도시된다. 이 예에서, 코드는 방정식 2X+3Y=20을 풀기 위해 사용된다. 이 예에서, 두 개의 유전자들이 섹션에서 초기화된다. 이 두 개의 유전자들은 변수들 X 및 Y에 대응한다. 섹션에서 염색체들이 유전자들에 추가된다. 적합도 함수를 위한 코드는 명령문에서 식별될 수 있다. 선택 함수를 위한 코드는 명령문을 사용하여 특정될 수 있다. 재조합 함수를 위한 코드는 명령문 에서 특정될 수 있다. 이 함수들을 위한 코드는 특별한 명령문을 위한 임의의 이용가능한 함수를 사용하여 구현될 수 있다. 이 선택 프로세스들은 코드에 의해 특정된 바와 같이 가장 적절한 또는 가장 적합한 염색체를 선택하기 위해 사용된다. 예를 들어, 룰렛 휠 선택(Roulette Wheel Selection) 프로세스가 사용될 수 있다. 명령문에서의 재조합 함수와 관련하여, 이 명령문은 새로운 세대의 염색체들을 만들기 위한 코드를 식별시키기 위해 사용될 수 있다. 일례로, 이진 변수 교차(cross-over) 방법이 사용될 수 있다. 명령문은 프로세스를 위한 오류 한계를 특 정하고, 명령문은 코드 내에서 진화 함수를 호출한다. 이 예들에서, 가장 적합한 염색체의 오류 한 계가 명령문에서 특정된 오류보다 적은 경우에는 언제나, 명령문에서 식별된 진화 프로세스가 정지 - 28 -공개특허 10-2010-0014329된다. 코드에서 정의된 바와 같이 프로세스를 수행함으로써, 유전자 X는 염색체에 가장 잘 들어맞는 X의 값들을 반환하고 유전자 Y는 염색체에 가장 잘 들어맞는 Y의 값들을 반환한다. 이제 도 55A 및 55B를 참조하면, 소스 코드에서의 객체를 위한 코드를 설명하는 도면이 유익한 실시예를 따라서 도시된다. 이 예에서, 코드는 숲의 형태인 객체를 위한 정의의 예이다. 섹션은 숲에서의 나무들에 대한 색들을 식별시킨다. 코드에서의 섹션은 숲을 위한 격자눈금을 식별시킨다. 섹션은 숲을 위한 격자눈금에 존재할 수 있는 나무들을 정의한다. 섹션은 숲을 위해 한 줄의 나무를 식별시킨다. 섹션 은 섹션에서 정의된 바와 같이 한 줄 이상의 나무들을 포함하는 나무들의 구획을 생성하기 위해 사 용된다. 섹션은 숲을 나타내기 위해 사용될 수 있는 코드의 예이다. 이 예들에서, 행들(5514 및 5516)은 숲 내에서 무작위성을 제공하기 위해 사용되는 번역 명령문들이다. 예컨대 회전 및/또는 축척 명령문들과 같은 다른 명령문들 또한 이 명령문들에 추가하여 또는 이 명령문들 대신에 사용될 수 있다. 이 예들에서, 코드는 C 언어를 사용하여 작성된다. 물론, 임의의 언어가 숲을 위한 정의를 생성하기 위해 사용될 수 있다. 게다가, 숲에 대한 표현은 도 6에서의 소스 코드에서의 정의에 존재할 수 있는 하나 의 객체에 대한 예이다. 물론, 구체적인 구현에 따라서 임의의 언어를 사용해서 또는 임의의 객체를 위하여 코 드가 생성될 수 있다. 서로 다른 도시된 실시예들에서 순서도들 및 블록도들은 장치, 방법들, 및 컴퓨터 프로그램 제품들의 일부 가능 한 구현들의 구조, 기능, 및 동작을 설명한다. 이 점과 관련하여, 순서도 또는 블록도들에서의 각각의 블록은 특정한 함수나 기능들을 구현하기 위한 하나 이상의 실행가능한 명령어를 포함하는, 컴퓨터에서 사용가능하거나 판독가능한 프로그램 코드의 모듈, 부분, 일부를 나타낼 수 있다. 일부 다른 구현들에서, 블록에서 언급된 함수 또는 기능들은 도면에서 언급된 순서와 달리 구현될 수 있다. 예를 들어 일정한 경우에 있어서는 포함된 기능에 따라서, 연속하여 도시된 두 개의 블록들이 실질적으로 동시에 실행될 수 있고, 또는 이 블록들이 때때로 반대 순서로 실행될 수 있다. 서로 다른 유익한 실시예들은 전체가 하드웨어로 된 실시예, 전체가 소프트웨어로 된 실시예, 또는 하드웨어 및 소프트웨어 구성요소 양자를 포함하는 실시예의 형태를 취할 수 있다. 일부 실시예들은 형식들에 제한받지 않고 예컨대 펌웨어, 상주 소프트웨어, 및 마이크로 코드와 같은 것들을 포함하는 소프트웨어로 구현된다. 게다가, 서로 다른 실시예들은 컴퓨터에서 사용가능하거나 컴퓨터에서 판독가능한 매체로부터 접속할 수 있는 컴퓨터 프로그램 제품의 형태를 취할 수 있는데, 여기서 매체는 명령어들을 실행시키는 임의의 장치나 시스템 또는 컴퓨터에 의해서 혹은 이들과 연계하여 사용하기 위한 프로그램 코드를 제공한다. 본 개시의 목적상, 컴퓨 터에서 사용가능하거나 컴퓨터에서 판독가능한 매체는 일반적으로 프로그램을 포함, 저장, 전달, 전파, 또는 전 송할 수 있는 임의의 유형적인 장치가 될 수 있는데, 여기서 프로그램은 명령어를 실행하는 시스템, 기구, 또는 장치에 의해서 혹은 이들과 연계하여 사용하기 위한 것이다. 컴퓨터에서 사용가능하거나 컴퓨터에서 판독가능한 매체는 예컨대, 제한이 없이 전자적, 자기적, 광학적, 전자 기적, 적외선, 또는 반도체 시스템이거나, 전파 매체가 될 수 있다. 컴퓨터에서 판독가능한 매체의 제한 없는 예들은 반도체 또는 고체(solid state) 메모리, 자기 테이프, 분리가능한 컴퓨터 디스켓, 램(RAM), 롬(ROM), 강 자기(rigid magnetic) 디스크, 및 광학 디스크를 포함한다. 광학 디스크는 씨디롬(CD-ROM), 씨디알더블유(CD- R/W), 및 디브이디(DVD)를 포함할 수 있다. 이 예들에서, 물리적 또는 유형적인 컴퓨터에서 판독가능한 매체는 기록가능한 컴퓨터 저장 매체를 가리킨다. 게다가, 컴퓨터에서 사용가능하거나 컴퓨터에서 판독가능한 매체는 컴퓨터에서 판독가능하거나 컴퓨터에서 사용 가능한 프로그램 코드를 포함하거나 저장할 수 있고, 그래서 컴퓨터에서 판독가능하거나 사용가능한 프로그램 코드가 컴퓨터에서 실행될 때, 컴퓨터에서 판독가능하거나 사용가능한 프로그램 코드를 실행함으로써 컴퓨터가 통신 링크를 통하여 컴퓨터에서 판독가능하거나 사용가능한 다른 프로그램 코드를 전송하게 한다. 이 통신 링크 는 예컨대, 제한 없이 물리적이거나 무선인 매체를 사용할 수 있다. 컴퓨터에서 판독가능하거나 사용가능한 프로그램 코드를 저장 및/또는 실행하기 위해 적절한 데이터 처리 시스 템은 시스템 버스와 같은 통신 패브릭을 통한 기억 소자들에 직접 또는 간접적으로 연결된 하나 이상의 프로세 서들을 포함할 것이다. 기억 소자들은 프로그램 코드를 실제 실행하는 동안 사용된 로컬 메모리, 벌크 저장소, 및 캐시 메모리들을 포함할 수 있는데, 여기서 캐시 매모리는 코드를 실행하는 동안 코드가 벌크 저장소로부터 검색되는 횟수를 줄이기 위하여 컴퓨터에서 판독가능하거나 컴퓨터에서 사용가능한 프로그램 코드 중 적어도 일 부의 임시 저장소를 제공한다. - 29 -공개특허 10-2010-0014329입출력 또는 I/O 장치들은 직접 시스템에 연결되거나 I/O 제어기들을 통해서 시스템에 연결될 수 있다. 이 장치 들은 예컨대, 키보드들, 터치 스크린 디스플레이들, 및 포인팅 장치들을 제한 없이 포함할 수 있다. 다른 통신 어댑터들은 또한 시스템에 연결될 수 있는데, 이 시스템은 데이터 처리 시스템이 공개 또는 비공개 네트워크들 을 통하여 다른 데이터 처리 시스템들 또는 원거리 프린터들이나 저장 장치들에 연결될 수 있도록 한다. 한정하 지 않는 예들은 모뎀들과, 네트워크 어댑터들을 들 수 있는데, 이들은 현재 이용가능한 유형의 통신 어댑터들 중 단지 일부이다. 본 개시의 서술은 설명 및 해설을 위하여 제시된 것이고, 공개된 형태로 본 개시를 제한하거나 총망라하고자 의 도된 것은 아니다. 당업자들에게는 다양한 변경들과 변형들이 명백할 것이다. 게다가, 서로 다른 유익한 실시예 들은 다른 유익한 실시예들과 비교된 바와 같이 서로 다른 장점들을 제공할 수 있다. 채택된 실시예 또는 실시 예들은, 본 개시의 원리들이나 실용적인 응용을 가장 잘 설명하고 당업자가 특별한 사용에 맞추어진 다양한 변 형들과 함께 다양한 실시예들에 대한 개시를 이해할 수 있도록 하기 위한 목적으로 선택되고 서술된다."}
