{"patent_id": "10-2022-7032326", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0149545", "출원번호": "10-2022-7032326", "발명의 명칭": "양자 회로들을 위한 효율적인 양자 적응적 실행 방법", "출원인": "인터내셔널 비지네스 머신즈 코포레이션", "발명자": "감베타, 제이"}}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "시스템으로서, 상기 시스템은,컴퓨터 실행가능 컴포넌트들(computer executable components)을 저장하는 메모리; 및상기 메모리에 저장된 컴퓨터 실행가능 컴포넌트들을 실행하는 프로세서; 를 포함하고, 상기 컴퓨터 실행가능컴포넌트들은,양자 태스크(quantum task)를 수행하기 위한 양자 프로그램(quantum program)을 수신하는 수신 컴포넌트(receiving component) - 상기 양자 프로그램은 제1 프로그램 및 제2 프로그램을 포함함 - ;상기 제1 프로그램을 컴파일(compile)하는 적응적 컴파일링 컴포넌트(adaptive compiling component);상기 컴파일된 제1 프로그램을 실행하는 실행 컴포넌트(executing component);상기 컴파일된 제1 프로그램을 실행하는 것에 기초하여 출력을 수신하는 제2 수신 컴포넌트(second receivingcomponent);상기 제1 프로그램을 실행하는 것으로부터 상기 수신된 출력에 기초하여 상기 제2 프로그램을 컴파일하는 제2적응적 컴파일링 컴포넌트(second adaptive compiling component); 및상기 컴파일된 제2 프로그램을 실행하는 제2 실행 컴포넌트(second executing component)를 포함하는, 시스템."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "청구항 1에 있어서, 상기 시스템은 결정 컴포넌트(determining component)를 더 포함하고, 상기 결정 컴포넌트는 하나 또는 그 이상의 회로 입력들에 적용(apply)되는 하나 또는 그 이상의 회로 출력들을 이용하는, 시스템."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "청구항 1 및 청구항 2 중 어느 한 항에 있어서, 상기 제1 프로그램은 상기 제1 프로그램으로부터 이전에(previously) 생성된 하나 또는 그 이상의 출력들에 기초하여 정의(define)되는,시스템."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "청구항 1 내지 청구항 3 중 어느 한 항에 있어서, 상기 제2 프로그램은 상기 제2 프로그램으로부터 이전에 수신된 하나 또는 그 이상의 출력들에 기초하여 정의되는, 시스템."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "청구항 1 내지 청구항 4 중 어느 한 항에 있어서, 상기 수신 컴포넌트는 상기 컴파일된 제1 프로그램을, 제1 양자 하드웨어 디바이스(first quantum hardware device) 상에서 실행되도록 적응되는 제1 리컴파일 프로그램(first recompiled program)으로 리컴파일(recompile)하는, 시스템."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "청구항 5에 있어서, 상기 제1 출력을 수신하는 것은 상기 리컴파일된 제1 프로그램을 실행하는 것에 기초하는, 공개특허 10-2022-0149545-3-시스템."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "청구항 5 및 청구항 6 중 어느 한 항에 있어서, 상기 컴파일된 제1 프로그램을 제2 리컴파일 프로그램(secondrecompiled program)으로 리컴파일하는 것은 제2 양자 하드웨어 디바이스(second quantum hardware device) 상에서 실행되도록 적응되는, 시스템."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "청구항 7에 있어서, 제2 출력을 수신하는 것은 상기 리컴파일된 제2 프로그램을 실행하는 것에 기초하는,시스템."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "청구항 1 내지 청구항 8 중 어느 한 항에 있어서, 상기 제2 프로그램을 컴파일하는 것은 상기 수신된 제1 출력과 상기 수신된 제2 출력 중 어느 하나를 선택하는 것에 기초하는, 시스템."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "컴퓨터로 구현되는(computer-implemented) 방법으로서, 상기 방법은,양자 태스크(quantum task)를 수행하기 위한 양자 프로그램(quantum program)에 동작적으로 결합된 시스템에 의해, 상기 양자 프로그램을 수신하는 단계 - 상기 양자 프로그램은 제1 프로그램 및 제2 프로그램을 포함함 - ;상기 시스템에 의해, 상기 제1 프로그램을 컴파일하는 단계;상기 시스템에 의해, 상기 컴파일된 제1 프로그램을 실행하는 단계;상기 시스템에 의해, 상기 컴파일된 제1 프로그램을 실행하는 것에 기초하여 출력을 수신하는 단계;상기 시스템에 의해, 상기 제1 프로그램을 실행하는 것으로부터 상기 수신된 출력에 기초하여 상기 제2 프로그램을 컴파일하는 단계; 및상기 시스템에 의해, 상기 컴파일된 제2 프로그램을 실행하는 단계를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "청구항 10에 있어서, 상기 컴퓨터 구현 방법은,상기 시스템에 의해, 하나 또는 그 이상의 회로 입력들에 적용되는 하나 또는 그 이상의 회로 출력들을 결정하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "청구항 10 및 청구항 11 중 어느 한 항에 있어서, 상기 컴퓨터 구현 방법은,상기 시스템에 의해, 상기 제1 프로그램으로부터 이전에(previously) 생성된 하나 또는 그 이상의 출력들에 기초하여 정의되는 상기 제1 프로그램을 이용하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "청구항 10 내지 청구항 12 중 어느 한 항에 있어서, 상기 컴퓨터 구현 방법은,공개특허 10-2022-0149545-4-상기 시스템에 의해, 상기 제2 프로그램으로부터 이전에 수신된 하나 또는 그 이상의 출력들에 기초하여 정의되는 상기 제2 프로그램을 이용하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "청구항 10 내지 청구항 13 중 어느 한 항에 있어서, 상기 컴퓨터 구현 방법은,상기 시스템에 의해, 상기 컴파일된 제1 프로그램을 제1 양자 하드웨어 디바이스 상에서 실행되도록 적응되는제1 리컴파일 프로그램(first recompiled program)으로 리컴파일(recompile)하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "청구항 14에 있어서, 상기 컴퓨터 구현 방법은,상기 시스템에 의해, 상기 리컴파일된 제1 프로그램을 실행하는 것에 기초하여 상기 제1 출력을 수신하는 단계를 더 포함하는,컴퓨터 구현 방법."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "청구항 10 내지 청구항 15 중 어느 한 항에 있어서, 상기 컴퓨터 구현 방법은,상기 시스템에 의해, 상기 컴파일된 제1 프로그램을 제2 양자 하드웨어 디바이스 상에서 실행되도록 적응되는제2 리컴파일 프로그램으로 리컴파일하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "청구항 16에 있어서, 상기 컴퓨터 구현 방법은,상기 시스템에 의해, 상기 리컴파일된 제2 프로그램을 실행하는 것에 기초하여 상기 제2 출력을 수신하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "청구항 10 내지 청구항 17 중 어느 한 항에 있어서, 상기 컴퓨터 구현 방법은,상기 시스템에 의해, 상기 수신된 제1 출력과 상기 수신된 제2 출력 중 어느 하나를 선택하는 것에 기초하여 상기 제2 프로그램을 컴파일하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "양자 회로들(quantum circuits)의 양자 적응적 실행(quantum adaptive execution)을 용이하게 하는 컴퓨터 프로그램 제품으로서, 상기 컴퓨터 프로그램 제품은 컴퓨터 판독가능 저장 매체(computer readable storagemedium) - 상기 컴퓨터 판독가능 저장 매체는 그것으로 구현된 프로그램 명령들을 가짐 - 를 포함하며, 상기 프로그램 명령들은 프로세서에 의해 실행가능하되, 상기 프로세서로 하여금,상기 프로세서에 의해, 양자 태스크(quantum task)를 수행하기 위한 양자 프로그램 - 상기 양자 프로그램은 제1프로그램 및 제2 프로그램을 포함함 - 을 수신하고;상기 프로세서에 의해, 상기 제1 프로그램을 컴파일하고;상기 프로세서에 의해, 상기 컴파일된 제1 프로그램을 실행하고;공개특허 10-2022-0149545-5-상기 프로세서에 의해, 상기 컴파일된 제1 프로그램을 실행하는 것에 기초하여 출력을 수신하고,상기 프로세서에 의해, 상기 제1 프로그램을 실행하는 것으로부터 상기 수신된 출력에 기초하여 상기 제2 프로그램을 컴파일하고,상기 프로세서에 의해, 상기 컴파일된 제2 프로그램을 실행하게 하는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "청구항 19에 있어서, 상기 프로그램 명령들은 상기 프로세서로 하여금,상기 프로세서에 의해, 하나 또는 그 이상의 회로 입력들에 적용되는 하나 또는 그 이상의 회로 출력들을 결정하게 하도록, 상기 프로세서에 의해 더 실행가능한, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "청구항 19 및 청구항 20 중 어느 한 항에 있어서, 상기 프로그램 명령들은 상기 프로세서로 하여금,상기 프로세서에 의해, 상기 제1 프로그램으로부터 이전에(previously) 생성된 하나 또는 그 이상의 출력들에기초하여 정의되는 상기 제1 프로그램을 이용하도록, 상기 프로세서에 의해 더 실행가능한, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "청구항 19 내지 청구항 21 중 어느 한 항에 있어서, 상기 프로그램 명령들은, 상기 프로세서로 하여금,상기 프로세서에 의해, 상기 제2 프로그램으로부터 이전에 수신된 하나 또는 그 이상의 출력들에 기초하여 정의되는 상기 제2 프로그램을 이용하도록, 상기 프로세서에 의해 더 실행가능한, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "청구항 19 내지 청구항 22 중 어느 한 항에 있어서, 상기 프로그램 명령들은, 상기 프로세서로 하여금,상기 프로세서에 의해, 상기 컴파일된 제1 프로그램을 제1 양자 하드웨어 디바이스 상에서 실행되도록 적응되는제1 리컴파일 프로그램(first recompiled program)으로 리컴파일(recompile)하도록, 상기 프로세서에 의해 더실행가능한, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "청구항 23에 있어서, 상기 프로그램 명령들은, 상기 프로세서로 하여금,상기 프로세서에 의해, 상기 리컴파일된 제1 프로그램을 실행하는 것에 기초하여 상기 제1 출력을 수신하도록,상기 프로세서에 의해 더 실행가능한, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7032326", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "청구항 19 내지 청구항 24 중 어느 한 항에 있어서, 상기 프로그램 명령들은, 상기 프로세서로 하여금,상기 프로세서에 의해, 상기 컴파일된 제1 프로그램을 제2 양자 하드웨어 디바이스 상에서 실행되도록 적응되는제2 리컴파일 프로그램(second recompiled program)으로 리컴파일하도록, 상기 프로세서에 의해 더 실행가능한, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2022-7032326", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "이전의 양자 회로들(quantum circuits)과 중간 결과들에 기초하여 양자 적응적 실행 방법(quantum adaptive execution method)를 용이하게 할 수 있는 시스템들 및 방법들이 개시된다. 이는 특정 백엔드와 이전의 양자 회 로 종속성(quantum circuits dependencies)에 대한 최적화된 적응적 컴파일 방법(optimized adaptive (뒷면에 계속)"}
{"patent_id": "10-2022-7032326", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 양자 회로 종속성(quantum circuits dependencies) 및 이전의(previous) 양자 회로들 (quantum circuits)에 의해 생성된 중간 결과들에 기초하는 양자 적응적 실행 방법(quantum adaptive execution method)과 관련된다. 특정 백엔드 양자 회로(backend quantum circuit) 및 이전의 종속적인 양자 회 로들을 위해 최적화된 적응적 컴파일 방법(adaptive compilation methodology)이 이용되고 그에 따라 양자 회로 를 실행하는 양자 백엔드(quantum backend)로 잡 디스패쳐(job dispatcher)에 의해 그 회로를 방향변경 (redirect)한다."}
{"patent_id": "10-2022-7032326", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "양자 프로그래밍(quantum programming)은 양자 프로그램들로 일컬어지는 일련의 명령들을 어셈블링 (assembling)하는 프로세스이다. 양자 프로그램들은 양자 컴퓨터(quantum computer) 상에서 실행가능한 잡들 (jobs)로도 알려져 있다. 양자 프로그램은 양자 회로들의 집합(collection)을 가질 수 있다. 잡(job)에서 양자 회로는 종속성(dependencies)을 가질 수 있고 이전의 양자 회로들의 결과는 다음의(next) 양자 회로를 실행하는 데 사용될 수 있다. 양자 회로가 실행될 때, 양자 컴퓨터에 의해 결과가 생성되는데, 이들 양자 회로 결과들 중 일부는 이전의 양자 회로들에 의해 생성된 중간 결과들에 종속된다. 종래의 많은 양자 회로 최적화 기술들은, 최적의 결과를 제공하기 위해 양자 회로들을 향상시키는 것에 중점을 두고 있다. 종래의 양자 회로 최적화 기술 들에 있어서는, 그것에 의해 사용자가 하나의 양자 컴퓨터에서 단지 하나의 양자 프로그램만을 실행시킬 수 있 다. 모든 잡들(회로들의 리스트)을 직렬 방식으로 보내고 그 순서대로 각각의 잡들을 실행하는 종래의 기술은 실행될 그 다음의 회로까지 에러 또는 노이즈(예컨대, 주변 케이블들, 다른 하드웨어, ...에 의해 생성되는)의 전파를 초래할 수 있고, 따라서 바람직하지 않은 양자 프로그램 실행을 초래한다."}
{"patent_id": "10-2022-7032326", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "다음은 발명의 하나 또는 그 이상의 실시예들에 관한 기본적인 이해를 제공하기 위한 요약을 제시한다."}
{"patent_id": "10-2022-7032326", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 2, "content": "이러한 요약은 핵심 및 중요한 구성요소들을 확인하려고 의도된 것이 아니라, 구체적인 실시예들 또는 청구항들"}
{"patent_id": "10-2022-7032326", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 3, "content": "의 범위를 설명하려고 의도된 것이다. 요약의 유일한 목적은 이후에 제시되는 더 상세한 설명에 대한 서론으로 서 간략화된 형태로 개념들을 제시한다. 여기에 설명되는 하나 또는 그 이상의 실시예들에 있어서, 시스템들, 컴퓨터 구현 방법들, 장치들 및/또는 컴퓨터 프로그램 제품들은 이전의 양자 회로들과 그것의 중간 결과들에 기 초하여 양자 적응적 실행 방법(quantum adaptive execution method)의 생성을 용이하게 한다. 일 실시예에 따라, 시스템은 프로세서를 포함하며, 프로세서는 메모리에 동작적으로 결합되고, 이하의 컴퓨터 실행가능 컴포넌트들(computer executable components)을 실행한다. 상기 컴퓨터 실행가능 컴포넌트들은, 양자 태스크(quantum task)를 수행하기 위한 양자 프로그램(quantum program) - 상기 양자 프로 그램은 제1 프로그램과 제2 프로그램을 포함함 - 을 수신하는 수신 컴포넌트(receiving component); 상기 제1 프로그램을 컴파일(compile)하는 적응적 컴파일링 컴포넌트(adaptive compiling component); 상기 컴파일된 제 1 프로그램을 실행하는 실행 컴포넌트(executing component); 상기 컴파일된 제1 프로그램을 실행하는 것에 기 초하여 출력을 수신하는 제2 수신 컴포넌트(second receiving component); 상기 제1 프로그램을 실행하는 것으 로부터 상기 수신된 출력에 기초하여 상기 제2 프로그램을 컴파일하는 제2 적응적 컴파일링 컴포넌트; 및 상기 컴파일된 제2 프로그램을 실행하는 제2 실행 컴포넌트를 포함한다. 선택적 일 측면에서, 상기 시스템은 결정 컴포넌트(determining component)를 더 포함하고, 상기 결정 컴포넌트는 하나 또는 그 이상의 회로 입력들에 적용되는 하나 또는 그 이상의 회로 출력들을 이용한다. 선택적 일 측면에서, 상기 제1 프로그램은 상기 제1 프로그램으로부터 이전에 생성된 하나 또는 그 이상 의 출력들에 기초하여 정의된다. 또 다른 선택적 측면에서, 상기 제2 프로그램은 상기 제2 프로그램으로부터 이전에 수신된 하나 또는 그 이상의 출력에 기초하여 정의된다. 일 실시예에 따라, 컴퓨터로 구현되는(computer-implemented) 방법이 개시된다. 상기 컴퓨터 구현 방법 은, 하기 동작들을 수행하기 위해 컴퓨터 실행가능 컴포넌트들을 실행하도록, 메모리에 동작적으로 결합되는 프 로세서를 사용하는 단계, 즉, 양자 태스크(quantum task)를 수행하기 위한 양자 프로그램(quantum program)- 상기 양자 프로그램은 제1 프로그램 및 제2 프로그램을 포함함 - 을 수신하기 위해 상기 프로세서를 사용하는 단 계를 포함한다. 적응적 컴파일링 컴포넌트는 제1 프로그램을 컴파일하고 상기 실행 컴포넌트는 상기 컴파일된 제1 프로그램을 실행한다. 상기 제2 수신 컴포넌트는 상기 컴파일된 제1 프로그램을 실행하는 것에 기초하여 출 력을 수신한다. 상기 제2 적응적 컴파일링 컴포넌트는 상기 제1 프로그램을 실행하는 것으로부터 상기 수신된 출력에 기초하여 상기 제2 프로그램을 컴파일한다. 그런 다음 상기 제2 실행 컴포넌트는 상기 컴파일된 제2 프 로그램을 실행한다. 선택된 일 측면에서, 상기 컴퓨터 구현 방법은, 상기 시스템에 의해, 하나 또는 그 이상의 회로 입력들 에 적용되는 하나 또는 그 이상의 회로 출력들을 결정하는 단계를 더 포함한다. 또 다른 선택적 측면에서, 상기 컴퓨터 구현 방법은, 상기 시스템에 의해, 상기 제1 프로그램으로부터 이전에 생성된 하나 또는 그 이상의 출력들에 기초하여 정의되는 상기 제1 프로그램을 이용하는 단계를 더 포함 한다. 또 다른 선택적 측면에서, 상기 컴퓨터 구현 방법은, 상기 시스템에 의해, 상기 제2 프로그램으로부터 이전에 수신된 하나 또는 그 이상의 출력들에 기초하여 정의되는 상기 제2 프로그램을 이용하는 단계를 더 포함 한다. 일 실시예에 따라, 컴퓨터 구현 방법은, 하기 동작들을 수행하기 위해 컴퓨터 실행가능 컴포넌트들을 실 행하도록, 메모리에 동작적으로 결합되는 프로세서를 사용하는 단계, 즉, 하나 또는 그 이상의 회로 입력들에 적용되는 하나 또는 그 이상의 회로 출력들을 결정하도록 상기 프로세서를 사용하는 단계를 포함한다. 상기 제1 프로그램은 상기 제1 프로그램으로부터 이전에 생성된 하나 또는 그 이상의 출력들에 기초하여 정의된다. 상기 제2 프로그램은 상기 제2 프로그램으로부터 이전에 수신된 하나 또는 그 이상의 출력들에 기초하여 정의된다. 상기 수신 컴포넌트는 상기 컴파일된 제1 프로그램을 제1 양자 하드웨어 디바이스 상에서 실행되도록 적응되는 제1 리컴파일 프로그램(first recompiled program)으로 리컴파일(recompile)한다. 제1 출력을 수신하는 것은 상기 리컴파일된 제1 프로그램을 실행하는 것에 기초한다. 그런 다음, 상기 컴파일된 제1 프로그램은 제2 양자 하드웨어 디바이스 살에서 실행되도록 적응되는 제2 리컴파일 프로그램(second recompiled program)으로 리컴파 일된다. 상기 제2 출력은 상기 리컴파일된 제2 프로그램을 실행하는 것에 기초하여 수신된다. 상기 제2 프로그 램은 상기 수신된 제1 출력과 상기 수신된 제2 출력 중 어느 하나를 선택하는 것에 기초하여 컴파일된다."}
{"patent_id": "10-2022-7032326", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하의 상세한 설명은 단순히 설명을 위한 것이지, 실시예들 및/또는 실시예들의 적용 또는 사용들을 제"}
{"patent_id": "10-2022-7032326", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "한하려는 의도는 아니다. 더욱이, 앞에서의 요약 섹션에서, 또는 상세한 설명 섹션에서 제시되는 표현 또는 함 축된 어떤 정보에 의해 본 발명의 범위를 제한하려는 의도는 아니다. 이제 도면을 참조하여 하나 또는 그 이상 의 실시예들이 설명되는데, 여기서 참조부호들은 전반적으로 유사한 구성요소들을 지칭하는데 사용된다. 이하의 설명에서, 설명 목적으로, 하나 또는 그 이상의 실시예들에 관한 더 철저한 이해를 제공하기 위해, 다수의 구체 적인 세부사항들이 제시된다. 하지만, 여러 경우들에 있어서, 이러한 하나 또는 그 이상의 실시예들은 이러한 구체적인 세부사항들 없이도 실시될 수 있다는 것은 분명하다. 본 발명은 일반적으로 이전의 양자 회로들과 그것의 중간 출력들에 기초하여 양자 회로들을 위한 양자 적응적 실행 방법(quantum adaptive execution method)를 사용하는 시스템들 및 방법들과 관련된다. 이는 특정 백엔드와 이전의 양자 회로 종속자들(dependents)을 위해 최적화된 적응적 컴파일(adaptive compilation) 결과 를 생성할 수 있고, 따라서 잡 디스패쳐에 의해 올바른 양자 백엔드로 방향변경(redirect)할 수 있다. 여기에 개시되는 실시예들은, 생성되는 에러들의 수가 줄어들 수 있도록 하는 그러한 조합 방식으로 이전 회로들의 결 과들로 다음의(next) 양자 회로를 향상시킬 수 있고, 시스템 효율이 향상될 수 있고 양자 컴퓨터에서 향상된 조 건부 로직(conditional logic)이 달성될 수 있다. 실시예들은 제1 회로 또는 프로그램을 이용하고, 그 프로그램 을 분석(analyze)하고 그것을 컴파일할 수 있다. 그런 다음, 그 다음 시퀀스 또는 제2 프로그램은, 이전의 시퀀 스 출력과 그것의 내부 코드(internal code)에 기초하여 컴파일된다. 실행되는 양자 시퀀스에 기초하여 변경할 수 있는 양자 컴퓨터 상의 몇 가지 파라미터들이 있다. 이러한 컴파일(compilation)을 통해 얻어지는 결과들은 양자 산물(quantum product)을 변경하는데 사용될 수 있고, 여기서 리컴파일(recompilation)을 위해 게이트들/ 파라미터들이 변경될 수 있고, 그리하여 감소된 에러율(error rate)로 최적의 결과가 얻어지도록 한다. 따라서, 실시예들은 이용가능한 컴퓨터 백엔드들을 사용하여 많은 가능한 백엔드들에 양자 프로그램을 분산시키고 하나 의 양자 컴퓨터에서 실행되는 하나의 양자 프로그램과 연관된 제약조건들(constraints)을 제거한다. 오늘날의 디지털 세상에서, 데이터는 많은 응용분야들에서 주요 인자 역할을 한다. 누군가에 의해 취해 진 행위(들)은 종종 위성 영상, 바이오 메디컬 분야, 스마트폰, 소셜 매체, 및 다른 응용분야들을 통해 디지털 족적을 남길 수 있다. 급속도로 성장하는 기술은 머신-생성 데이터에서의 기하급수적 증가를 초래해 왔다. 빅 데이터는 데이터 탐색과 이용에 있어서 신기원을 제시하며, 그것은 양(volume), 다양성(variety) 및 속도 (velocity)에 있어서 많고 높은 데이터를 포함하는 그러한 것이다. 소프트웨어 공학(software engineering)에 있어서 현대적인 발전들은 서비스형 소프트웨어(software as services)(즉, SaaS)를 활용하는 결과를 가져왔는 데, 이러한 서비스형 소프트웨어는 컴퓨터 기반시설(computer infrastructure) 및 유지보수(maintenance)에 관 한 리소스들을 확장하는 것 대신에, 조직들이 핵심 사업들에 집중할 수 있도록 하는 상당한 이점을 제공한다. 예를 들어, 입력으로서 데이터 인스턴스들의 세트(a set of data instances)를 이용하는 서비스로서 '빅-데이터' 클러스터링 소프트웨어('big-data' clustering software)는, 데이터 클러스터링을 위한 컴퓨테이션 들을 수행할 수 있고 출력으로서 클라이언트에게 분할(partition)된 데이터를 리턴할 수 있다. 빅 데이터는, 예 를 들어 소셜 매체(social media)에서 생성된 콘텐츠를 추적하고, 웹(web)으로부터의 웹 페이지 이미지들 및 센 서스 데이터(census data)를 분석하고, 사물인터넷(Internet of Things, IoT) 센서들로부터 요구되는 데이터들 을 획득하고, 사이버 보안(cyber-security)을 위해 스마트폰들과 네트워크 트래픽 데이터에 대한 활동 추적과 같은, 데이터 마이닝(data mining)을 위한 여러가지 시나리오들에서 사용될 수 있다. 빅데이터가 데이터 분석학 에서 보편화됨에 따라, 데이터 샘플링 및 데이터 디멘젼 피쳐(data dimension features)에 대한 수요가 급격히 증가하고 있다. 따라서, 본질적으로 원시적인 것으로서 양자 컴퓨팅은 점점 더 많은 관심을 받고 있다. 양자 컴퓨팅은 일반적으로 컴퓨팅 및 정보 처리 기능들을 수행하기 위해 양자-역학 현상(Quantum- mechanical phenomena)을 사용하는 것이다. 양자 컴퓨팅은 고전적인 컴퓨팅과는 대조적으로 보여질 수 있다. 고 전적인 컴퓨팅은 일반적으로 트랜지스터들을 이용하여 바이너리(binary) 값들로 동작한다. 즉, 고전적인 컴퓨터 들은 0과 1 중 어느 하나인 비트 값들로 동작할 수 있는 반면, 양자 컴퓨터들은 0과 1의 중첩들 (superpositions)을 포함하는 양자 비트들로 동작하고, 다수의 양자 비트들을 얽히게(entangle) 만들 수 있고, 그래서 간섭(interference)을 사용할 수 있다. 초전도체 큐비트들(superconducting qubits)은, 그것이 거시적 수준에서 양자-역학 동작 특성(양자 정보 처리를 위해 사용될 수 있도록 하는)을 나타낼 수 있으므로(예컨대,기존의 집적 회로 기술들에 의해 설계되고 제조됨), 완전히 작동하는(fully-operational) 양자 컴퓨터들을 구성 하도록 하는 유망한 경로를 제공한다. 양자 컴퓨테이션은 고전적인 컴퓨팅 비트 대신에 그것의 필수적인 유닛으 로서 큐비트(qubit)를 사용한다. 큐비트(예컨대, 양자 바이너리 디지트)는 고전적인 비트의 양자 역학적 유사체 (quantum-mechanical analogue)이다. 고전적인 비트들이 두 개의 기본 상태들(예컨대, 0 또는 1) 중 단지 하나 만을 이용할 수 있음에 반해, 큐비트들은 그러한 기본 상태들의 중첩들(예컨대, α|0> + β|1>, 여기서, α와 β는 |α|2 + |β|2 = 1 인 복소수 스칼라들임)을 사용할 수 있고, 다수의 큐비트들은 이론적으로 같은 수의 고 전적인 비트들보다 기하급수적으로 많은 정보를 유지하는 것을 가능하게 한다. 따라서 양자 컴퓨터들(예컨대, 단지 고전적인 비트들 대신에 큐비트들을 이용하는 컴퓨터)는, 이론상으로, 고전적인 컴퓨터들에게 극히 어려울 수 있는 문제들을 빠르게 해결할 수 있다. 고전적인 컴퓨터들의 비트들은 단순히 0과 1 중 하나의 값을 갖는 바 이너리 디지트들이다. 두 개의 구별되는 상태들을 갖는 대부분의 디바이스는 고전적인 비트, 즉 스위치, 밸브, 마그네트, 코인 등을 표현하는 역할을 수행할 수 있다. 양자의 신비성을 띠는 큐비트들은 0과 1 상태의 중첩을 가질 수 있다. 큐비트는 예컨대, 0.63과 같은 중간 값을 가질 수 있다는 것은 아니고, 큐비트의 상태가 측정될 때, 그 결과는 0과 1 중 어느 하나이다. 그러나 컴퓨테이션의 과정에서, 큐비트는 마치 그것이 상태들의 혼합 (muxture)- 예컨대, 63 퍼센트의 0과 37 퍼센트의 1 - 인 것처럼 동작할 수 있다. 양자 컴퓨팅은 일반적으로 컴퓨팅 및 정보 처리 기능들을 수행하기 위해 양자-역학 현상을 사용하는 것 이다. 양자 컴퓨팅은 고전적인 컴퓨팅과는 대조적으로 보여질 수 있다. 고전적인 컴퓨팅은 일반적으로 트랜지스 터들을 이용하여 바이너리 값들로 동작한다. 즉, 고전적인 컴퓨터들은 0과 1 중 어느 하나인 비트 값들로 동작 할 수 있는 반면, 양자 컴퓨터들은 0과 1의 중첩들을 포함하는 양자 비트들(큐비트들)로 동작하며, 다수의 양자 비트들을 얽히게 만들 수 있고, 그래서 간섭을 사용할 수 있다. 양자 컴퓨팅은 그것들의 컴퓨테이션 복잡성으로 인해 많은 실제적인 목적을 위해 고전적인 컴퓨터에서 해결될 수 없는 문제들을 해결할 수 있는 잠재력을 가진 다. 그러나, 양자 컴퓨팅은, 예를 들어, 진폭 추정(amplitude estimation)을 수행하도록 확률 분포의 양자 상태 를 준비하기 위해 매우 전문적인 기술들을 필요로 한다. 양자 프로그래밍은 양자 컴퓨터 상에서 실행가능한 명 령들의 시퀀스들 - 양자 프로그램들로 일컬어짐 - 을 어셈블링하는 프로세스이다. 양자 프로그램은 양자 회로들의 집합을 가질 수 있다. 양자 회로가 실행될 때, 양자 컴퓨터에 의해 결과 가 생성된다. 이들 회로들 중 일부는 다른 회로들에 종속적일 수 있고, 이전의 회로들에 의해 생성된 중간 결과 들에 기초할 수 있다. 문제의 특징은 양자 회로들이 그것의 실행동안 종속성들을 가질 때이다. 그러므로, 이들 실시예들은, 종속성들과 이전의 양자 회로들에 의해 생성된 결과들에 기초하여 양자 회로의 최적화를 관리할 수 있는 시스템(들) 및 방법(들)을 제안한다. 이것은 하나의 양자 컴퓨터에서 실행되는 하나의 양자 프로그램과 연 관된 제약조건들을 완화시키는 것을 용이하게 할 수 있다. 여기서의 실시예들은 다양한 특징들 및 노이즈 품질 (noise quality)로 몇몇 양자 컴퓨터들 상에서 실행하도록 반복적인 알고리즘들을 최적화한다. 이러한 실시예들 의 장점은 양자 컴퓨터들의 세트 상에 양자 프로그램을 적응시키는 것일 수 있고 상이한 양자 백엔드들에서 실 행하기 위해 그것을 분할(split)할 수 있다는 것이다. 이는 실행 시간을 단축할 수 있고 그에 따라 양자 회로를 실행하는 양자 백엔드에서 효율적인 양자 회로를 생성할 수 있다. 본 발명의 컴퓨터 처리 시스템들, 방법들, 장치들 및/또는 컴퓨터 프로그램 제품들은 기술의 향상, 컴퓨 터 네트워크, 인터넷 등을 통해 발생되는 새로운 문제들을 해결하기 위해 이용될 수 있다. 도 1은, 여기에 설명된 하나 또는 그 이상의 실시예들에 따라 도시된 가변적인 컴퓨팅 컴포넌트들을 사 용하여 데이터에 억세스하고 그 데이터를 처리할 수 있는 시스템의 일 예에 관한 블록 다이어그램을 나타 낸다. 시스템은 머신 러닝(machine learning)을 사용하여, 그리고 신경망 또는 다른 유형의 모델을 트레이 닝(training)하여, 많은 양의 다양한 형태의 데이터를 평가(assess)하고 식별(identify)하는 처리를 용이하게 할 수 있다. 시스템은 또한 여기에 설명된 하나 또는 그 이상의 실시예들에 따른 맥락으로 개인 수준에 대 한 예측 권고(predictive recommendations)를 생성할 수도 있다. 본 명세서에 설명된 시스템들(예컨대, 시스템 등), 장치들, 처리들의 측면들(aspects)은 머신(들) 내에 구현되는, 예컨대, 하나 또는 그 이상의 머신들 과 연관된 하나 또는 그 이상의 컴퓨터 판독가능 매체들에 구현되는, 머신-실행가능 컴포넌트(들)(machine- executable component(s))을 구성할 수 있다. 이러한 컴포넌트(들)은, 하나 또는 그 이상의 머신들, 예컨대, 컴 퓨터(들), 컴퓨팅 디바이스(들), 가상 머신(들) 등에 의해 실행될 때, 그 머신(들)로 하여금 여기에 설명되는 동작들을 수행하도록 할 수 있다. 본 명세서 내에 설명되는 하나 또는 그 이상의 실시예들에 이용되는 유사한 구성요소들에 관한 반복적인 설명은 설명의 간결함을 위해 생략되었다. 시스템은, 이전의 양자 회로들과 중간 결과들에 기초하여 양자 회로들의 양자 적응적 실행을 용이 하게 하여, 특정 백엔드 및 이전의 양자 회로 종속자들(dependents)을 위해 최적화된 적응적 컴파일(adaptive compilation)을 생성하고, 양자 회로들을 실행하는 것 및 리턴 결과들에 기초하여 적절한 양자 백엔드로 잡 디스패쳐(job dispatcher)에 의해 방향변경(redirect)한다. 시스템은 많은 양의 다양한 형태의 데이터를 평가하고 식별하는 처리를 용이하게 할 수 있다. 시스 템은 또한 여기에 설명되는 하나 또는 그 이상의 실시예들에 따른 맥락의 결과를 가져오는 개인 수준에 대 한 예측 권고도 생성할 수 있다. 본 명세서 내에 설명되는 시스템들(예컨대, 시스템 등), 장치들 또는 처 리들의 측면들은, 머신(들) 내에 구현되는, 예컨대 하나 또는 그 이상의 머신들과 연관된 하나 또는 그 이상의 컴퓨터 판독가능 매체들에 구현되는, 머신-실행가능 컴포넌트(들)을 구성할 수 있다. 이러한 컴포넌트(들)은, 하나 또는 그 이상의 머신들, 예컨대, 컴퓨터(들), 컴퓨팅 디바이스(들), 가상 머신(들) 등에 의해 실행될 때, 그 머신(들)로 하여금 여기에 설명되는 동작들을 수행하도록 할 수 있다. 여기에 설명되는 하나 또는 그 이상의 실시예들에 이용되는 유사한 구성요소들에 관한 반복적인 설명은 설명의 간결함을 위해 생략되었다. 시스템은 서버 디바이스, 하나 또는 그 이상의 네트워크들 및 하나 또는 그 이상의 디바이스들(도 시되지 않음)을 선택적으로 포함할 수 있다. 시스템은 또한 컴퓨터 실행가능 컴포넌트들을 실행하는 적어 도 하나의 프로세서 - 적어도 하나의 프로세서는 메모리에 동작적으로 결합됨 - 를 포함하거나 그렇지 않으면 상기 적어도 하나의 프로세서와 연관될 수 있다. 시스템은 시스템 버스를 더 포 함할 수 있다. 시스템 버스는 양자 태스크를 수행하기 위한 양자 프로그램을 수신하는 수신 컴포넌트 (receiving component)(이것으로 한정되는 것은 아님)를 포함하는 다양한 컴포넌트들을 동작적으로 결합시 킬 수 있다. 상기 양자 프로그램은 제1 프로그램을 포함한다. 적응적 컴파일링 컴포넌트(adaptive compiling component)는 제1 프로그램을 컴파일하고, 실행 컴포넌트(executing component)는 컴파일된 제1 프 로그램을 실행한다. 이러한 시스템의 장점들은 에러들을 식별하고, 실행 방법들(execution methods)을 향 상시켜 효율을 개선하고, 파라미터들을 변경하여 오리지널 코드에 대한 변경에 의해 최적의 결과들을 제공한다. 하나의 구현에서, 수신 컴포넌트(receiving component)는 양자 태스크를 수행하기 위한 양자 프로 그램을 수신한다. 양자 프로그램은 제1 프로그램을 포함한다. 제1 프로그램은 제1 프로그램으로부터 이전에 생 성된 하나 또는 그 이상의 출력들에 기초하여 정의된다. 제2 프로그램은 제2 프로그램으로부터 이전에 수신된 하나 또는 그 이상의 출력들에 기초하여 정의된다. 수신 컴포넌트는 컴파일된 제1 프로그램을 제1 양자 하드웨 어 디바이스 상에서 실행하도록 적응되는 제1 리컴파일 프로그램(first recompiled program)으로 리컴파일 (recompile)한다. 적응적 컴파일링 컴포넌트는 제1 프로그램을 컴파일하고, 실행 컴포넌트는 컴파일 된 제1 프로그램을 실행한다. 이러한 실시예의 장점은, 이전의 출력들에 기초하여 최적의 결과들을 제공하도록 하나 또는 그 이상의 회로 출력들이 하나 또는 그 이상의 회로 입력들에 적용된다는 것이다. 제1 프로그램은 제 1 프로그램으로부터 이전에 생성된 하나 또는 그 이상의 출력들에 기초하여 정의된다. 수신 컴포넌트는 컴 파일된 제1 프로그램을 제1 양자 하드웨어 디바이스 상에서 실행되도록 적응되는 제1 리컴파일 프로그램으로 리 컴파일한다. 양자 회로는 회로 컴포저(circuit composer)를 사용함으로써 생성될 수 있다. 회로 컴포저는 어떻게 양 자 회로를 생성하는지를 시각적으로 배울 수 있도록 하고, 프로그램 실행동안 큐비트들에 무엇이 일어나는지에 관한 스토리를 표사한다. 회로의 입력 상태를 조작(manipulate)하기 위해, 양자 컴퓨팅의 기본적인 동작들이 적 용될 필요가 있다. 게이트들(gates)의 사용을 통해, 양자 로직이 합쳐질 수 있고 그에 따라 양자 회로를 생성할 수 있다. 개별 백엔드 시스템은 이 회로를 컴파일하는데 사용된다. 위의 단락에서 언급한 바와 같이, 이들 실시 예들은 양자 회로의 효율적인 양자 적응적 실행 방법를 제안한다. 양자 회로는 양자 컴퓨터(백엔드)에서 실행되 는 양자 게이트들의 순서 리스트이다. 잡(job)에서 양자 회로는 종속성들을 가질 수 있고, 이전의 양자 회로들 의 결과는 그 다음의 양자 회로를 실행하기 위해 필요하다. 따라서, 이러한 실시예들은 상이한 특징들 및 노이 즈 품질로 몇몇 양자 컴퓨터들을 위한 반복적 알고리즘을 최적화하는데 중점을 두고 있다. 양자 프로그램이 수 신될 때, 제1 프로그램은 컴파일되고 실행된다. 제1 컴파일 프로그램의 출력이 수신되고 제2 프로그램이 컴파일 되고 실행된다. 이 기술을 통해, 상이한 백엔드들에서 실행하도록 프로그램을 분할함으로써 실행 시간이 향상되 고(예컨대, 종래의 기술들을 통해서 하는 것보다 더 빠름), 그에 따라 백엔드에서 효율적인 양자 회로를 생성한 다. 시스템은 디바이스들에 통신상으로 결합될 수 있는 어떤 적절한 컴퓨팅 디바이스 또는 컴퓨팅 디바 이스들의 세트일 수 있다. 디바이스들의 예들은, 서버 컴퓨터, 컴퓨터, 모바일 컴퓨터, 메인프레임 컴퓨터, 자 동화된 테스팅 시스템, 네트워크 스토리지 디바이스, 통신 디바이스, 웹 서버 디바이스, 네트워크 스위칭 디바 이스, 네트워크 라우팅 디바이스, 게이트웨이 디바이스, 네트워크 허브 디바이스, 네트워크 브릿지 디바이스,컨트롤 시스템, 또는 다른 어떤 적절한 컴퓨팅 디바이스(이러한 예들로 한정되는 것은 아님)를 포함할 수 있다. 디바이스는, 시스템들과 정보를 주고받을 수 있는 어떤 디바이스 및/또는 시스템에 의해 제공되는 정 보를 이용할 수 있는 다른 어떤 적절한 디바이스일 수 있다. 시스템들, 컴포넌트들, 모델들 또는 디바이스 들에게 통신 컴포넌트들(도시되지 않음)이 구비될 수 있다는 것이 이해되어야 한다. 상기 통신 컴포넌트들은 하 나 또는 그 이상의 네트워크들을 통해 시스템, 컴포넌트들, 모델들, 디바이스들 등 사이의 통신을 가능하게 한 다. 시스템들의 다양한 컴포넌트들은 직접적으로 연결될 수도 있고 또는 하나 또는 그 이상의 통신망들 (networks)을 통해서 연결될 수도 있다. 이러한 통신망들은 유선 또는 무선 통신망들을 포함할 수 있는데, 유선 또는 무선 통신망들은, 예컨대, 셀룰러 통신망(cellular network), 광역 통신망(wide area network, WAN)(예컨 대, 인터넷), 또는 근거리 통신망(local area network, LAN)를 포함할 수 있으나 이러한 예로 한정되는 것은 아 니다. 이러한 통신망을 이용하는 통신의 예들은 셀룰러, 광역통신(WAN), 와이파이(wireless fidelity, Wi-Fi), 와이맥스(Wi-Max), 무선랜(WLAN), 무선 통신(radio commouncation), 마이크로웨이브 통신(microwave commouncation), 위성 통신(satallite communication), 광 통신(optical communication), 음파 통신(sonic communication), 또는 다른 어떤 적절한 통신 기술을 포함할 수 있으나, 이러한 예로 한정되는 것은 아니다. 더 욱이, 앞서 언급된 시스템들 및/또는 디바이스들은 몇명의 콤퍼넌트들 사이의 상호작용과 관련하여 설명되었다. 이러한 시스템들 및 컴포넌트들은 그 안에 명시된 이러한 컴포넌트들 또는 서브-컴포넌트들, 그 명시된 컴포넌 트들 또는 서브-컴포넌트들 중 몇몇 및/또는 추가 컴포넌트들을 포함할 수 있다. 서브-컴포넌트들은 또한 상위 컴포넌트들(parent components) 내에 포함되기보다는 오히려 다른 컴포넌트들에 통신상으로 결합되는 컴포넌트 들로서 구현될 수도 있다. 더 나아가, 하나 또는 그 이상의 컴포넌트들 및/또는 서브-컴포넌트들은 전체 기능을 제공하는 하나의 컴포넌트로 결합될 수 있다. 컴포넌트들은 또한, 간결함을 위해 본 명세서 내에 구체적으로 설 명되지 않은 하나 또는 그 이상의 다른 컴포넌트들과 상호작용할 수도 있는데, 이러한 하나 또는 그 이상의 다 른 컴포넌트들은 당업자들에게 알려진 것이다. 도 2는 여기에 설명된 하나 또는 그 이상의 실시예들에 따라 묘사된 가변적인 컴퓨팅 컴포넌트들을 사용 하여 데이터에 억세스하고 그 데이터를 처리할 수 있는 시스템(100, 도 1)의 또 다른 실시예에 관한 블록 다이 어그램을 나타낸다. 여기에 설명된 하나 또는 그 이상의 실시예들에 이용되는 유사한 구성요소들에 관한 반복적 인 설명은 간결함을 위해 생략되었다. 시스템은 컴파일된 제1 프로그램을 실행하는 것에 기초하여 출력을 수신하는 제2 수신 컴포넌트 를 더 포함할 수 있다. 제2 적응적 컴파일링 컴포넌트(second adaptive compiling component)는 제1 프로그램을 실행하는 것으로부터 그 수신된 출력에 기초하여 제2 프로그램을 컴파일한다. 제2 실행 컴포넌트 (second executing component)는 컴파일된 제2 프로그램을 실행한다. 하나의 구현 예에서, 제2 수신 컴포 넌트는 컴파일된 제1 프로그램을 실행하는 것에 기초하여 출력을 수신한다. 제2 적응적 컴파일링 컴포넌트 는 제1 프로그램을 실행하는 것으로부터 그 수신된 출력에 기초하여 제2 프로그램을 컴파일하고 제2 실행 컴포넌트는 컴파일된 제2 프로그램을 실행한다. 컴파일된 제1 프로그램은, 제2 양자 하드웨어 디바이스 상 에서 실행되도록 적응되는 제2 리컴파일 프로그램으로 리컴파일된다. 제2 출력은 리컴파일된 제2 프로그램을 실 행하는 것에 기초하여 수신된다. 제2 프로그램은 수신된 제1 출력과 수신된 제2 출력 중 하나를 선택하는 것에 기초하여 컴파일된다. 이전의 양자 회로 종속자들(dependents)은 잡 디스패쳐에 의해 적절한 또는 최적의 양자 백엔드로 방향변경(redirect)하는데 사용될 수 있다. 이러한 방법의 장점은 제1 프로그램의 출력을 이용한다는 것일 수 있고 또한 양자 산물(quantum product)을 변경함으로써 양자 회로들의 그 다음 세트를 향상 시킨다는 것일 수 있다. 양자 프로그램은 양자 회로들의 집합을 가질 수 있다. 양자 회로가 실행될 때, 양자 컴퓨터에 의해 결과 가 생성된다. 이들 회로들 중 일부는, 다른 회로들에 종속적일 수 있고, 이전의 회로들에 의해 생성된 중간 결 과들에 기초할 수 있다. 그러므로, 시스템은 그것의 종속성들에 기초하여 회로들의 최적화를 관리할 필요 가 있다. 시스템은 이전의 양자 회로들 및 중간 결과들에 기초하여 양자 회로들을 컴파일한다. 이러한 시 스템의 장점은 양자 회로를 위해 양자 결과들을 향상시킨다는 것이고 컴파일 유닛에 이들 결과들을 사용하 여 특정 백엔드를 위한 최적화된 출력을 생성하는 적응적 컴파일 방법(adaptive compilation methodology)을 생 성한다는 것이다. 또한, 이전의 양자 회로 종속자들은 잡 디스패쳐에 의해 적절하거나 최적인 양자 백엔드 로 방향변경하는데 사용될 수 있다. 결과적인 후 처리 유닛은 그러한 로직을 적용하고, 컴파일러 유닛들 및 잡 디스패쳐를 위한 데이터의 입력/출력을 관리한다. 도 3은 양자 회로를 생성할 수 있는 회로 컴포저(circuit composer)의 일 예를 나타낸다. 도면에서 보여지는 바와 같이, 양자 회로는 양자 회로들을 어떻게 생성하는지를 시각적으로 학습하게 할 수 있는 회로 컴 포저를 사용하여 만들어졌다. 블록 302로 나타낸 바와 같이, 회로 컴포저는 게이트들을 포함한다. 그 것은, 예컨대, 왼쪽에서 오른쪽으로, 프로그램 동안 큐비트들에게 무엇이 일어났는지에 관한 스토리를 나타낸다. 그것은 회로 컴포저를 보여주는데, 그 툴은 회로 상에서 양자 연산들(quantum operations)을 드 래그 앤 드롭(drag and drop) 하는 것을 허용한다. 양자 로직 게이트는 작은 수의 큐비트들로 연산하는 기본적 인 양자 회로이고, 컴퓨팅의 기본적인 연산들은 게이트들로 알려져 있다. 회로의 입력 상태를 조작하기 위해, 양자 컴퓨팅의 기본적인 연산들이 적용되고, 이들은 양자 게이트들로 알려져 있다. 양자 회로의 기준(basis) 게 이트들 및 토폴로지(topology)는 양자 프로세서의 특성들로 일컬어진다. 기준 게이트들은 태생적으로 물리적인 하드웨어에 의해 지원된다. 블록 302에서 보여지는 바와 같이, 양자 회로에서 게이트의 특정 목적을 가진 다양 한 게이트들이 있다. 이들 게이트들의 사용을 통해, 양자 로직은 합쳐질 수 있고 그 결과 블록 304로 나타낸 것 과 같은 양자 회로가 된다. 이 회로에서 네 개의 큐비트들이 셋업되었고 0에서부터 3까지 번호가 매겨졌다. 그 런 다음 큐비트들에게 측정 연산(measure operation)이 즉시 적용되며, 이것은 0 또는 1의 출력을 추출한다. q[0] 과 q[1]로 라벨링된 블록 306과 308이 파울리(Pauli) X 게이트를 갖도록, 회로에 게이트가 배치(place)된 다. 블록 310은 q[0]에서 q[1]로 그리고 q[1]에서 q[2]로의 CX 게이트 토글(toggle)을 보여준다. 이와 유사하게, 블록 312에서 CX 게이트가 더해져 q[0]에서 q[3]으로 토글한다. 컴퓨테이션의 결과들을 읽어내기 위 해, 블록 314로 나타낸 것과 같이 q[2]와 q[3] 둘 다에 대해 큐비트들이 측정된다. 이 회로를 컴파일하기 위해 개별 백엔드 시스템이 사용된다. 회로가 하드웨어에 맞도록 회로를 언팩(unpack)하려면 q[3] 게이트와 같은 게 이트들 중 일부가 필요할 수 있다. 이들 실시예들은 양자 회로들에게 프로그램의 효율적인 양자 적응적 실행 방법를 제공하는 방법 및 시스 템을 제안한다. 이러한 작업 흐름에 있어서, 양자 컴퓨터(백엔드들)에서 하나의 양자 회로를 실행하기 위해, 하 나의 잡(job)의 일부인 회로들은 컴파일되어 특정 하드웨어에 최적화되고 적응될 수 있다. 파라미터들은 컴파일 계층(compilation layer)이 최적의 방법으로 회로들을 컴파일할 수 있도록 조정된다. 이 점에서, 잡에서 하나의 특정 회로는 다른 회로들로부터 생성된 중간 결과들의 종속성을 가질 수 있다. 이 경우에 있어서, 잡 디스패쳐 와 결합되는 컴파일러 기반구조(compiler infrastructure)는 양자 회로를 재편성할 수 있고 이전의 회로의 실행 에 의해 생성된 결과들을 포함할 수 있다. 제2 최적화는 실행시이고, 여기서 컴파일러 유닛은 하나 또는 몇 개 의 양자 백엔드들에서 이전의 회로의 실행에 의해 생성되는 특정 결과를 기다릴 수 있다. 도 4는 양자 회로 생성기의 상세 플로우 챠트의 일 예를 나타내는데, 양자 회로를 생성하고 그 회로를 실행하며 그에 따라 결과들을 인터프리트(interpret)하기 위해, 회로 컴포저를 사용하는 프로세스를 나타낸다. 프로세스는 블록 404로 나타낸 것과 같이 그래픽 유저 인터페이스를 사용하여 양자 회로가 시뮬레이션 (simulate)되는 것에서 시작한다. 블록 406으로 나타낸 것과 같이 시각화 툴(visualization tool)을 오픈할 때, 블록 408로 나타낸 것과 같이 미리 정해진 리스트로부터 디바이스가 선택된다. 디바이스가 선택되면, 블록 410으로 나타낸 것과 같이 게이트들이 토폴로지(topology)에 맵핑(map)된다. 선이 그어진 한 장의 페이퍼를 닮 은 한 세트의 수평 라인들이 나타나는데, 왼쪽에서 오른쪽으로의 이러한 라인들은 양자 와이어들(quantum wires)로 일컬어진다. 양자 와이어는 단일 큐비트를 나타낸다. 와이어의 좌측에 있는 표기법은 그 와이어가 어 느 큐비트를 나타내는지를 가리키고, 각각의 큐비트는 초기에 |0> 상태에 있다는 것을 보여준다. 양자 컴퓨터로 부터 이 출력을 가져오기 위해, 블록 412로 표시된 것과 같이 큐비트가 측정되어야 하고 큐비트가 더해(add)질 수 있다. 측정은 큐비트들에 대해 극적인 효과를 가지며, 그래서 그것은 연산 자체로 간주되고, 측정 명령과 함 께 표현된다. 측정 결과는 고전적인 비트로 기록되고, 양자 와이어와 동일한 방식으로 고전적인 와이어로 그려 진다. 양자 와이어와 고전적인 와이어는 와이어의 좌측에서의 표기법에 의해 구별된다. 여기서, 양자 와이어들 은 q[0], q[1] 등으로 마킹(mark)되고, 고전적인 와이어들은 c1, c2 등으로 마킹된다. 측정 명령에서 나오는 수 직 와이어는 양자 와이어에서 고전적인 와이어로 흐르는 정보를 묘사한다. 블록 414로 나타낸 것과 같이 양자 회로가 완료되고 블록 416으로 나타낸 것과 같이 회로를 실행한다. 블록 418로 나타낸 것과 같이 백엔드가 선택 되는데, 그것은 양자 컴퓨터의 고전적인 시뮬레이터와 실제 양자 컴퓨터 중 어느 하나로 일컬어지는 용어이며 이는 또한 양자 시스템으로도 일컬어진다. 블록 420으로 나타낸 바와 같이 샷들(shots)의 넘버(예컨대, 양자 회 로가 실행되는 횟수(the number of times))가 선택된다. 블록 422로 나타낸 것과 같이 회로가 실행되면, 블록 424로 나타낸 것과 같이 시스템은 선택된 샷들의 넘버에 기초하여 반복을 수행할 것이다. 만약 더 이상의 반복 이 없다면, 블록 426에서 실행은 생성된 결과 리포트들과 함께 완료된다. 이러한 프로세스를 통해, 양자 회로가 만들어지고, 선택된 게이트들/파라미터들에 따라 실행된다. 도 5는 양자 회로의 효율적인 양자 적응적 실행 방법(quantum adaptive execution method)의 플로우챠 트의 일 예를 나타낸다. 양자 프로그램은 잡(job)으로 일컬어지고 양자 회로들의 리스트로 구성된다. 양자 회로는 양자 컴퓨터(백엔드)에서 실행되는 양자 게이트들의 순서 리스트이다. 잡에서 양자 회로는 종속성을 가질 수 있고 이전의 양자 회로들의 결과는 다음의 양자 회로를 실행하는데 이용된다. 따라서, 이들 실시예들은 상이한 특징들 및 노이즈 품질로 몇몇 양자 컴퓨터들을 위한 반복적인 알고리즘을 최적화한다. 현재의 기술 상태로는, 사용자들은 일반적으로 하나의 양자 컴퓨터에서 하나의 양자 프로그램을 실행한다. 여기에 개시된 실시예들은, 많은 가능한 백엔드들에 양자 프로그램을 분산(회로들에서 분할)시키기 위해 이용가능한 양자 컴퓨터 백엔드들 의 사용을 용이하게 할 수 있다. 이는 단일 양자 컴퓨터에서 실행되는 단일 양자 프로그램과 연관된 제약조건들 을 제거한다. 블록 502로 나타낸 것과 같이, 프로세스는 양자 태스크를 수행하기 위한 양자 프로그램을 수신하 는 수신 컴포넌트(receiving component)로 시작하는데, 여기서 양자 프로그램은 제1 프로그램과 제2 프로그램을 포함한다. 504로 나타낸 것과 같이, 적응적 컴파일링 컴포넌트(adaptive compiling component)는 제1 프로그램 을 컴파일한다. 블록 506으로 나타낸 것과 같이 실행 컴포넌트(executing component)는 컴파일된 제1 프로그램 을 실행한다. 이들 방법들(methods)은 하나 또는 그 이상의 회로 입력들에 적용되는 하나 또는 그 이상의 회로 출력들을 이용한다. 제1 프로그램은 제1 프로그램으로부터 이전에 생성된 하나 또는 그 이상의 출력들에 기초하 여 정의된다. 제2 프로그램은 제2 프로그램으로부터 이전에 생성된 하나 또는 그 이상의 출력들에 기초하여 정 의된다. 수신 컴포넌트는 컴파일된 제1 프로그램을 제1 양자 하드웨어 디바이스 상에서 실행되도록 적응되는 제 1 리컴파일 프로그램으로 리컴파일한다. 이 단계시, 컴파일된 제1 프로그램을 제2 리컴파일 프로그램으로 리컴 파일하는 것은 제2 양자 하드웨어 디바이스 상에서 실행되도록 적응된다. 블록 508로 나타낸 것과 같이 제2 수 신 컴포넌트는 컴파일된 제1 프로그램을 실행하는 것에 기초하여 출력을 수신한다. 블록 510으로 나타낸 것과 같이 제2 적응적 컴파일링 컴포넌트는 제1 프로그램을 실행하는 것으로부터 수신된 출력에 기초하여 제2 프로그 램을 컴파일한다. 블록 512로 나타낸 것과 같이 제2 실행 컴포넌트는 컴파일된 제2 프로그램을 실행한다. 제2 출력을 수신하는 것은 리컴파일된 제2 프로그램을 실행하는 것에 기초하고, 제2 프로그램을 컴파일하는 것은 수 신된 제1 출력과 수신된 제2 출력 중 어느 하나를 선택하는 것에 기초한다. 이러한 방법을 통해, 이들 실시예들 은 양자 프로그램을 적응시키기 위해 많은 양자 컴퓨터들을 이용하고, 상이한 백엔드에서 실행하기 위해 프로그 램을 분할함으로써 실행 시간을 단축하고 그에 따라 백엔드에서 양자 회로를 생성한다. 이러한 방법의 장점은 실행시간을 최적화하는 것일 수 있고 사용자/서비스들과 양자 백엔드 사이에서 데이터(예컨대, 잡들 및 회로 들)의 전후를 제거하는 것일 수 있다. 따라서, 종속성들을 갖는 잡 또는 회로 당(per) 평균 실행 시간이 감소된 다. 양자 컴퓨터들에 관한 최적화 문제들을 해결하기 위해, VQE 또는 QAOA 와 같은 다양한 알고리즘들이 사 용될 수 있다. VQE 알고리즘은 양자/고전적 하이브리드 알고리즘이며, 이는 큰 매트릭스의 고유값들 (eigenvalues)를 결정하는데 사용될 수 있다. 고유값(eigenvalue)은 주어진 조건들 하에서 0이 아닌 해 (nonzero solution)를 갖는 미분 방정식(고유함수(eigenfunction))에 대한 파라미터들의 값들의 세트이다. 이 알고리즘은 양자 시스템들을 시뮬레이션하기 위한 하이브리드 양자-고전적 알고리즘으로서 소개되었다. VQE를 사용하는 양자 시뮬레이션의 몇몇 예들은 응집 물질 물리학(condensed matter physics)에서 모델 시스템들 및 분자 전자 슈뢰딩거 방정식(molecular electronic Schrodinger equation)을 해결하는 것을 포함한다. 도 6은 변분-양자 아이젠솔버(Variational-Quantum Eigensolver(VQE)) 알고리즘에 대한 양자 회로의 일 예를 나타낸다. 발견적 추적 상태들(heuristic trail states)의 준비는 두 가지 유형의 양자 게이트들, 즉 회전 각들(θ)에 의해 결정된 604로 나타낸 단일-큐비트 게이트 U(θ)와 큐비트들의 쌍들에 작용하는 606으로 나타낸 얽힘 드리프트 연산(entangling drift operation) Uent을 포함한다. 606에서 블록들은 블록 602로 나타낸 것과 같이 상이한 N 큐비트들에 얽혀(entangle) 있어, 검색(search)이 더 넓은 공간에 이를 수 있도록 한다. 이 알고 리즘은 D-회 반복되고 이 프로세스가 더 오래 실행될수록, 시스템이 더 많은 파라미터들을 최적화하도록 학습한 다. 프로세스의 종료에서, 큐비트들이 측정되고 0과 1 중 어느 하나로 리턴한다. 개별 측정은 최적화 문제에 대 한 잠재적인 답을 제공한다. 이 알고리즘이 608에서 θ와 같은 고정된 파라미터로 D회 실행되면, 최적화가 실행 되어 최적의 결과를 얻을 수 있다. 이 기술을 통해, 알고리즘은 바이너리 최적화 문제를 연속적인 최적화 문제 로 실행한다. QAOA 알고리즘은 조합적 최적화 문제들을 해결하도록 설계된 또다른 하이브리드 양자-고전적 변분 알고리즘이다. 이 알고리즘은 양의 정수(positive integer) p에 의존하고 근사 품질(approximation quality)은 p가 증가됨에 따라 향상된다. 이 알고리즘을 구현하는 양자 회로는 통합 게이트들(unitary gates)을 가지며 회 로의 깊이(depth)는 제약조건들의 p 배로 선형적으로 증가한다. 만약 p가 입력 싸이즈에 관계없이 고정된 값이 라면, 알고리즘은 고전적 전처리(preprocessing)로 일컬어지는 효율적인 방법을 사용한다. 만약 p가 입력 싸이 즈에 따라 증가한다면, 다른 전략이 제안된다. 이들 실시예들은 VQE 또는 QAOA 알고리즘으로 제한되는 것은 아 니며, 주어진 문제에 따라 양자 최적화를 위해 어떠한 적절한 알고리즘이 사용될 수 있다. VQE 알고리즘에서, 하나의 양자 회로의 출력은 또 하나의 양자 회로의 입력의 일부일 수 있다. 일반적으 로, VQE 알고리즘은 동일한 백엔드 상에서 실행되고 결과를 얻을 수 있다. 그러나, 만약 VQE는 알고리즘은 분할 되고 양자 회로들이 상이한 백엔드들에서 실행된다면, 최적의 결과가 얻어질 수 있다. VQE 알고리즘은 어떤 유 형의 게이트 또는 백엔드를 사용함으로써 다양한 구성들(상이한 에러 게이터들)로 상이한 벡엔드들에서 실행될 수 있다. 양자 회로가 다양한 양자 게이트들을 사용할 수 있고 에러 게이터들이 이용가능한 백엔드에 기초하여 다양할 수 있기 때문에, 이는 최종 결과의 성능(performance)에 영향을 미칠 것이다. 사용자에 의해 제공되는 컴파일된 양자 회로는, 백엔드 특성들, 큐비트들(T1, T2, 리드아웃 에러, 주파수 등), 그리고 종래 기술에서 정 의된 다른 일반적인 특성들(냉장고 온도, 펄스들을 위한 디폴트 파라미터 등)과 함께 사용될 수 있다(사용자 입 력). 위에서 언급된 VQE 알고리즘은 그것의 백엔드 특성들과 함께 사용자에 의해 작성된 오리지널 양자 회로로 회로를 컴파일하기 위해 사용될 수 있다. 백엔드의 구성은 이전의 회로들의 결과들과 함께 회로를 실행할 수 있 다. 동일한 백엔드에서 많은 VQE 알고리즘들(양자 프로그램)을 실행하는 것 대신에, 그것은 (오리지널 양자 프 로그램을 체크하는) 백엔드로서 사용될 수 있는 양자 회로들로 분할될 수 있다. 백엔드의 특성들 및 구성과 하 나의 양자 회로의 이전의 결과는 그 다음의 컴파일에 종속된다. 그것으로, 시스템은 양자 회로를 위해 백엔드 실행을 선택할 수 있고 양자 프로그램을 동시에 병렬화하여 총 실행 시간을 단축할 수 있다. 도 7은 VQE 양자 고전적 알고리즘의 플로우챠트의 예를 나타낸다. 위의 단락에서 언급된 바와 같이, VQE 알고리즘은 큰 매트릭스 H의 고유값들을 찾아내는데 사용될 수 있는 양자/고전적 하이브리드 알고리즘이다. VQE 는 주어진 해밀턴(Hamiltonian)의 가장 낮은 고유값(eigenvalue)의 상한(upper bound)을 찾을 수 있게 한다. VQE는 하이브리드, 즉 양자-고전적 알고리즘이고 따라서 그것은 고전적 컴퓨터 뿐만 아니라 양자 컴퓨터 상에서 모든 컴퓨테이션들을 수행한다. 702로 나타낸 것과 같이, 계산은 양자 처리 유닛(Quantum Processing Unit)에서 파라미터들의 주어진 세트에 대한 기대 값 또는 에너지 레벨들을 계산함으로써 시작한다. 파라미터들의 세트가 주어지면, 블록 704로 나타낸 것과 같이 양자 상태가 준비된다. 블록 706으로 나타낸 것과 같이 측정 조건 (measurement terms)에 기초하여, 708로 나타낸 것과 같이 H의 기대 값이 계산된다. 양자 프로세서에서 이 값을 획득할 시, 블록 710으로 나타낸 것과 같이 고전적인 프로세서에서 다른 최적화가 수행된다. 가장 정확한 결과 를 찾아내기 위해 블록 712로 나타낸 것과 같이 기대 값들에 대해 평균이 계산된다. 블록 716으로 나타낸 것과 같이 파라미터들의 새로운 세트를 찾아내기 위해 블록 714로 나타낸 것과 같이 최적화 과정이 수행된다. 만약 블록 718로 나타낸 것과 같이 더 많은 반복들이 있으면, 프로세스는 블록 702로부터 반복된다. 만약 수행될 더 이상의 반복들이 없다면, 블록 720으로 나타낸 것과 같이 가설풀이(ansatz) 파라미터의 고전적 최적화가 생성된 다. 가설풀이는 많은 상태들을 커버할 수 있도록 하는 것이며 더 작은 수의 파라미터들을 가져 컨트롤과 최적화 가 더 쉽도록 하는 것이다. 이 방법(methodology)은 반복적 양자 위상 추정(iterative quantum phase estimation) 및 양자 위상 추정 알고리즘(quantum phase estimation) 알고리즘에 비해 큰 장점을 갖는다. 도 8은 여기에 설명되는 하나 또는 그 이상의 실시예들에 따라 양자 컴퓨팅 잡들의 적응적 컴파일 (adaptive compilation)을 용이하게 할 수 있는 시스템의 일 예(이러한 예로 한정되는 것은 아님)의 다이 어그램을 나타낸다. 여기에 설명되는 다양한 실시예들에서 이용되는 유사한 구성요소들 및/또는 프로세스들은 간결함을 위해 생략되었다. 다수의 실시예들에 따라, 시스템은 도 8에서의 시스템의 대안적 실시예(이러한 예로 한정되는 것은 아님)를 포함할 수 있다. 몇몇 실시예들에서, 이 시스템은 인터페이스 컴포넌트인 잡 시스 템(Job System)을 포함할 수 있다. 잡 시스템은 엔티티(entity)(예컨대, 프로그래머, 디바이스, 컴퓨 터, 로봇, 머신, 인공지능 구동 모듈, 인간 등)로부터 양자 프로그램을 수신할 수 있다. 몇몇 실시예들에서, 인 터페이스 컴포넌트는, 도 1을 참조하여 위에서 설명된 것과 같이 변경된 양자 프로그램 컴파일(quantum program compilation)을 생성하기 위해, 그러한 양자 프로그램을 적응적 컴파일 컴포넌트(adaptive compilation component)로 보낼 수 있다. 몇몇 실시예들에서, 도 1을 참조하여 위에서 설명된 하나 또는 그 이상의 실행 기준(run criteria)에 기초하여 블록 808로 나타낸 것과 같이, 양자 디바이스가 양자 유닛들로 부터 선택될 수 있다. 몇몇 실시예들에서, 적응적 컴파일 컴포넌트는, 큐(queue) - 여기서 실행 순서 위치 가 결정될 수 있음 - 에서 변경된 양자 프로그램 컴파일(quantum program compilation)의 실행 순서 위치(run order position)에 기초하여, 변경된 양자 프로그램을 실행하기 위해 선택된 양자 유닛들의 그러한 큐에 대해 변경된 양자 프로그램 컴파일(quantum program compilation)을 디스패치할 수 있다. 몇몇 실시예들에서, 선택 컴포넌트(selection component)에 의해 선택되는 양자 디바이스는 적응적 컴파일 컴포넌트에 의해 생 성된 그 변경된 양자 프로그램 컴파일을 실행할 수 있고 인터페이스 컴포넌트는 그러한 실행의 결과들을 관리할 수 있다. 예를 들어, 인터페이스 컴포넌트는 인터페이스 컴포넌트로 양자 프로그램을 전송하 는 엔티티에 결과들을 리턴할 수 있고, 및/또는 결과 후 처리(result post processing)를 통해 예컨대, 메모리 와 같은 메모리 디바이스에 그러한 결과들을 저장할 수 있다. 후 처리 유닛(post processing unit)은 이전의 회로로부터 얻어지는 결과들을 분석할 수 있고, 제2 프로그램 파라미터들과 함께 그 다음의 컴파일에 대비하 여 그것을 사용하기 위해 데이터를 저장할 수 있다. 결과 후 처리 유닛은 이 로직의 적용을 담당하는 것이고 컴 파일러 유닛들과 잡 디스패쳐에 푸쉬할 데이터의 입력/출력을 관리한다. 몇몇 실시예들에 있어서, 양자 적응적 실행 시스템은 다양한 기술들과 연관될 수 있다. 예를 들어, 양자 적응적 컴파일 시스템(quantum adaptive compilation system)은 고전적인 컴파일러 기술들, 양자 기반 컴파일 러 기술들, 고전적 컴퓨터 워크로드 스케쥴링 기술들, 양자 컴퓨터 워크로드 스케쥴링 기술들, 양자 공학 기술 들, 양자 컴퓨테이션 기술들, 양자 컴퓨터 기술들, 양자 하드웨어 및/또는 소프트웨어 기술들, 양자 시뮬레이터 기술들, 고전적 도메인 및/또는 양자 도메인 데이터 처리 기술들, 기계 러닝 기술들, 인공 지능 기술들, 및/또 는 다른 기술들과 연관될 수 있다. 몇몇 실시예들에 있어서, 양자 적응적 실행 시스템은 시스템들, 디바이스들, 컴포넌트들, 동작 단계들, 및/또는 위에서 확인된 여러 가지 기술들과 연관된 처리 단계들에 대해 기술적인 향상을 제공할 수 있다. 예를 들어, 양자 적응적 컴파일 시스템은, 그러한 양자 디바이스(들)에서 실행 대기 중인 하나 또는 그 이상의 양자 프로그램들(예컨대, 그 다음의 양자 프로그램(들)) 뿐만 아니라, 하나 또는 그 이상의 양자 디바이스들을 분석 할 수 있고(예를 들어, 구성, 특성들, 이용가능성 등과 같은 양자 디바이스의 하나 또는 그 이상의 속성들을 분 석할 수 있고), 특정한 순간에 어떤 양자 디바이스(예컨대, 그 다음의 이용가능한 양자 디바이스, 다른 양자 디 바이스 대비 가장 높은 수준의 충실도를 갖는 양자 디바이스 등) 상의 그러한 양자 프로그램의 실행을 가능하게 하기 위해 어떤 양자 프로그램의 하나 또는 그 이상의 구성요소들(예컨대, 양자 회로(들), 펄스 스케쥴(들) 등)을 더 변경할 수 있다. 이 예에서, 양자 적응적 컴파일 시스템은, a) 양자 프로그램을 수신하고(예컨대, 인 터페이스 컴포넌트를 통해), b) 실행할 회로들 및 이용가능한 백엔드들(예컨대, 양자 디바이스들)을 분석 하고, 및/또는 c) 이용가능한 백엔드의 그 다음 반복에서 실행을 준비할 수 있는 변경된 양자 프로그램 컴파일 (quantum program compilation)을 생성할 수 있다(예컨대, 수신된 양자 프로그램의 하나 또는 그 이상의 구성요 소들의 변경에 의해). 그러므로, 이 예에서는, 양자 적응적 컴파일 시스템은 양자 적응적 컴파일레이션 시스템 으로 전송된 어떤 양자 프로그램의 실행 시간의 감소를 용이하게 할 수 있고, 및/또는 양자 적응적 컴파일 시스 템으로 전송된 양자 프로그램들의 기능에서 각각의 사용을 안정화하기 위해 양자 디바이스들의 작업부하들 (workloads)의 밸런싱(예컨대, 양자 디바이스들의 레이턴시(latency)를 감소시키는 것)을 가능하게 할 수 있다. 몇몇 실시예들에 있어서, 양자 적응적 실행 시스템은 고전적인 컴퓨팅 디바이스 및/또는 양자 컴퓨팅 디 바이스(예컨대, 양자 프로세서, 양자 하드웨어, 초전도 회로 등)와 연관된 처리 유닛(예컨대, 프로세서)에 기술 적인 향상을 제공할 수 있다. 예를 들어, 어떤 시간에 어떤 양자 디바이스에 의해 실행될 수 있는 변경된 양자 프로그램 컴파일을 생성하기 위해, 수신된 양자 프로그램의 하나 또는 그 이상의 구성요소들(예컨대, 양자 회로 (들), 펄스 스케쥴(들) 등)의 컴파일(예컨대, 프로그래밍 언어 번역) 및/또는 변경을 수행함에 의해, 양자 적응 적 컴파일 시스템은, 양자 적응적 컴파일 시스템으로 전송된 어떤 양자 프로그램의 실행 시간의 감소 및/또는 양자 디바이스의 레이턴시의 감소를 용이하게 할 수 있고, 그것에 의해 그러한 양자 디바이스와 연관된 처리 유 닛(예컨대, 프로세서)의 효율 및/또는 성능을 향상시킨다. 몇몇 실시예들에 있어서, 양자 적응적 실행 시스템은, 본질적으로 매우 기술적인 문제들, 추상적이지 않 은 문제들, 및 인간에 의한 정신적 행위들의 세트로 수행될 수 없는 문제들을 해결하기 위해, 하드웨어 또는 소 프트웨어를 이용할 수 있다. 몇몇 실시예들에 있어서는, 여기에 설명되는 하나 또는 그 이상의 프로세스들은, 위에서 확인된 다양한 기술들과 관련되어 있는 정의된 태스크들을 실행하기 위해, 하나 또는 그 이상의 전용 컴 퓨터들(예컨대, 전용 처리 유닛, 전용 고전적 컴퓨터, 전용 양자 컴퓨터 등)에 의해 수행될 수 있다. 몇몇 실시 예들에 있어서, 양자 적응적 컴파일 시스템 및/또는 그것의 컴포넌트들은, 위에서 언급된 기술들에서의 향상, 양자 컴퓨팅 시스템들, 클라우드 컴퓨팅 시스템들, 컴퓨터 아키텍쳐, 및/또는 또 다른 기술의 이용을 통해 발생 하는 새로운 문제들을 해결하기 위해 이용될 수 있다. 여기에 설명된 양자 적응적 컴파일 시스템 및/또는 그것의 컴포넌트들에 의해 실행될 수 있는 다양한 연 산들은 인간의 마음의 역량보다 더 큰 연산들이므로, 인간의 마음에서 복제될 수 없는 또는 인간에 의해 수행될 수 없는 전기적 컴포넌트들, 기계적 컴포넌트들, 및 회로망의 다양한 조합들을 양자 적응적 컴파일 시스템이 이 용할 수 있다는 것이 이해되어야 할 것이다. 예를 들어, 어떤 시 구간 동안 양자 적응적 컴파일 시스템에 의해 처리된 데이터의 양, 그러한 데이터를 처리하는 속도, 또는 처리된 데이터의 유형들은 동일한 시 구간 동안 인 간의 마음에 의해 처리될 수 있는 양, 속도 또는 데이터 유형보다 더 많고, 더 빠르고, 또는 다를 수 있다. 몇 가지 실시예들에 따라, 또한 양자 적응적 컴파일 시스템은, 여기에 설명된 다양한 동작들을 또한 수 행하는 한편, 하나 또는 그 이상의 다른 기능들을 수행하는 쪽으로 전적으로 동작(예컨대, 전적으로 파워 온 (power on), 전적으로 실행 등)할 수 있다. 그러한 동시적 멀티-동작 실행은 인간의 마음의 역량을 뛰어넘는 것 이라는 점이 이해되어야 한다. 또한 양자 적응적 컴파일 시스템은, 인간 사용자와 같은 엔티티에 의해 수동으로 얻기에 불가능한 정보를 포함할 수 있다는 것도 이해되어야 한다. 예를 들어, 양자 적응적 컴파일 시스템, 수신 컴포넌트, 적응적 컴파일 컴포넌트, 실행 컴포넌트, 제2 수신 컴포넌트, 제2 적응적 컴파 일링 컴포넌트, 제2 실행 컴포넌트 및/또는 양자 디바이스(들)에 포함된 정보의 유형, 양, 및/또는 다양성은, 인간 사용자에 의해 수동으로 얻어진 정보보다 더 복잡할 수 있다. 본 발명의 주제의 다양한 측면들에게 맥락을 제공하기 위해, 이하의 논의 뿐만 아니라 도 9는 개시된 주 제의 다양한 측면들이 구현될 수 있는 적합한 환경의 일반적인 설명을 제공하도록 의도된다. 도 9는 여기에 설 명되는 하나 또는 그 이상의 실시예들이 용이하게 될 수 있는 동작 환경들의 예(이러한 것들로 한정되는 것은 아님)에 관한 블록 다이어그램을 나타낸다. 여기에 설명되는 다른 실시예들에 이용되는 유사한 구성요소들의 반 복적인 설명은 간결함을 위해 생략된다. 도 9를 참조하여, 본 발명의 다양한 측면들을 구현하기 위한 적절한 동작 환경은 또한 컴퓨터(91 2)를 포함할 수 있다. 컴퓨터는 또한 처리 유닛, 시스템 메모리, 및 시스템 버스를 포함할 수 있다. 시스템 버스는 시스템 메모리(이러한 예로 한정되는 것은 아님)를 포함하는 시스템 컴포넌 트들을 처리 유닛에 결합한다. 처리 유닛은 다양한 이용가능한 프로세서들 중 어떤 것일 수 있다. 또 한 듀얼 마이크로프로세서들 및 다른 멀티프로세서 아키텍쳐들이 처리 유닛으로 이용될 수도 있다. 시스템 버스는 메모리 버스 또는 메모리 컨트롤러를 포함하는 버스 구조(들), 주변 버스 또는 외부 버스, 및 또는 로컬 버스의 몇몇 유형들 중 어떤 것일 수 있고, 이는 산업 표준 아키텍쳐(Industrial Standard Architecture, ISA), 마이크로-채널 아키텍쳐(Micro-Channel Architectre, MSA), 확장 ISA(Extended ISA, EISA), 인텔리전트 드라이버 일렉트로닉스(Intelligent Drive Electronics, IDE), VESA 로컬 버스(VESA Local BUS, VLB), 주변 컴 포넌트 인터커넥트(Peripheral Component Interconnect, PCI), 카드 버스, 범용 직렬 버스(Universal Serial Bus, USB), 어드밴스드 그래픽스 포트(Advanced Graphics Port, AGP), 파이어와이어(Firewire, IEEE 1394), 및 소형 컴퓨터 시스템즈 인터페이스(Small Computer Systems Interface, SCSI)를 포함하는 이용가능한 다양한 버 스 아키텍쳐들 중 어떤 것을 사용하는 것일 수 있으나 이러한 예로 한정되는 것은 아니다. 시스템 메모리는 또한 휘발성 메모리(volatile memory) 및 비휘발성 메모리(non-valatile memory)를 포함할 수 있다. 스타트-업(start-up) 동안과 같이 컴퓨터 내에서 구성요소들 사이의 정보 를 전송하기 위해 기본적인 루틴들을 포함하는, 기본 입력/출력 시스템(basic input/output system, BIOS)는 비 휘발성 메모리에 저장된다. 컴퓨터는 또한 착탈식/고정식(removable/non-removable), 휘발성/비휘발 성 컴퓨터 스토리지 매체를 포함할 수 있다. 예를 들어, 도 9는 디스크 스토리지를 보여준다. 디스크 스토 리지는 또한 자기 디스크 드라이브(magnetic disc drive), 플로피 디스크 드라이브(floppy disk drive), 테이프 드라이브(tape drive), 재즈 드라이브(Jaz drive), 짚 드라이브(Zip drive), LS-100 드라이브, 플래쉬 메모리 카드, 또는 메모리 스틱과 같은 디바이스들을 포함할 수 있으나, 이러한 예로 한정되는 것은 아니다. 디 스크 스토리지는 또한 다른 스토리지 매체와는 독립적인 또는 다른 스토리지 매체와 결합된 스토리지 매체 를 포함할 수 있다. 시스템 버스에 대한 디스크 스토리지의 연결을 용이하게 하기 위해, 일반적으로 인터페이스와 같은 착탈식 또는 고정식 인터페이스가 사용된다. 도 9는 또한 소프트웨어를 도시하는데, 소 프트웨어는 적절한 동작 환경에서 설명된 기본적인 컴퓨터 리소스들과 사용자들 사이의 중개자 (intermediary)로서 작용한다. 예를 들어, 이러한 소프트웨어는 또한 운영 체제를 포함할 수 있다. 운영 체제는 디스크 스토리지 상에 저장될 수 있으며, 컴퓨터의 리소스들을 컨트롤하고 할당하도록 동작한다. 시스템 어플리케이션들은, 예를 들어, 시스템 메모리와 디스크 스토리지 둘 중 어느 하 나에 저장된 프로그램 모듈들 및 프로그램 데이터를 통해 운영 체제에 의한 리소스들의 관리를 이용한다. 본 발명은 여러 가지 운영 체제들 또는 운영 체제들의 조합들로 구현될 수 있다는 것이 이해되어야 할 것이다. 사용자는 입력 디바이스(들)을 통해 컴퓨터에 명령들 또는 정보를 입력한다. 입력 디바이 스들은, 마우스와 같은 포인팅 디바이스, 트랙볼, 스타일러스, 터치패드, 키보드, 마이크로폰, 조이스틱, 게임 패드, 위성 접시(satellite dish), 스캐너, TV 튜너 카드, 디지털 카메라, 디지털 비디오 카메라, 웹 카메 라 등을 포함할 수 있으나, 이러한 예로 한정되는 것은 아니다. 이들 및 다른 입력 디바이스들은 인터페이스 포 트(들)을 경유하여 시스템 버스를 통해 처리 유닛에 연결된다. 인터페이스 포트(들)는, 예 를 들어, 직렬 포트, 병렬 포트, 게임 포트, 및 범용 직렬 버스(USB)를 포함할 수 있다. 출력 디바이스(들)은 입력 디바이스(들)와 동일한 유형의 포트들 중 일부를 사용한다. 따라서, 예를 들어, 컴퓨터 에 입력을 제공하기 위해, 그리고 컴퓨터에서 출력 디바이스로 정보를 출력하기 위해 USB 포트 가 사용될 수 있다. 출력 어댑터는 다른 출력 다비이스들 중에서 특별한 어댑터들을 필요로 하는 모 니터들, 스피커들, 및 프린터들과 같은 몇몇 출력 다비이스들이 있음을 나타내기 위해 제공된다. 출력 어 댑터들은 출력 디바이스와 시스템 버스 사이의 연결 수단을 제공하는 비디오 카드 및 사운드 카 드를 포함한다. 도 9에서는 예를 들기 위해 나타낸 것이며 이러한 예로 한정되는 것은 아니다. 다른 디바이스들 및/또는 디바이스들의 시스템들은 원격 컴퓨터(들)와 같은 입력 및 출력 기능들을 모두 제공한다는 것에 주목해야 한다. 컴퓨터는 원격 컴퓨터(들)와 같은 하나 또는 그 이상의 원격 컴퓨터들에 대한 논리적 연결들 을 사용하는 네트워킹된 환경에서 동작할 수 있다. 원격 컴퓨터(들)은 컴퓨터, 서버, 라우터, 네트워크 PC, 워크스테이션, 마이크로프로세서 기반의 기기(mricroprocessor-based appliance), 피어 디바이스(peer device) 또는 다른 공용 네트워크 노드 등일 수 있고, 일반적으로는 컴퓨터와 관련하여 설명된 구성요소들 중 많은 것 또는 전부를 포함할 수도 있다. 간략화를 위해, 단지 메모리 스토리지 디바이스 만이 원격 컴 퓨터(들)와 함께 도시되어 있다. 원격 컴퓨터(들)은 네트워크 인터페이스를 통해 컴퓨터에 논리적으로 연결되고, 그런 다음 통신 연결을 통해 물리적으로 연결된다. 네트워크 인터페이스는 근 거리 통신망(local-area networks, LAN), 광역 통신망(wide-area networks, WAN), 셀룰러 통신망(cellular networks) 등과 같은 유선 및/또는 무선 통신망들을 포함한다. LAN 기술들은 광섬유 분산 데이터 인터페이스 (Fiber Distributed Data Interface, FDDI), 동선 분산 데이터 인터페이스(Copper Distributed Data Interface, CDDI), 이더넷(Ethernet), 토큰 링(Token Ring) 등을 포함한다. WAN 기술들은, 포인트-투-포인트 링크들(point-to-point links), 집적형 서비스 디지털 네트워크(Integraged Services Digital Networks, ISD N)과 같은 회로 스위칭 네트워크 및 그것들의 변형들, 패킷 스위칭 네트워크들(packet switching networks), 및 디지털 구독자 회선들(Digital Subscriber Lines, DSL)을 포함하지만, 이러한 예들로 한정되는 것은 아니다. 통 신 연결(들)은 네트워크 인터페이스를 시스템 버스에 연결하기 위해 이용되는 하드웨어/소프트 웨어를 지칭한다. 통신 연결은 명확한 설명을 위해 컴퓨터 내에 나타내었지만, 그것은 또한 컴퓨터 의 외부에 있을 수도 있다. 네트워크 인터페이스에 대한 연결을 위한 하드웨어/소프트웨어는 또한, 일반 전화 등급 모뎀들, 케이블 모뎀들 및 DSL 모뎀들을 포함하는 모뎀들, ISDN 어댑터들, 및 이더넷 카드들과 같은 내부 및 외부 기술들을 포함할 수 있으나, 이러한 것들은 단지 예를 든 것이므로 다른 것들도 있을 수 있 다. 이제 도 10을 참조하면, 예시적인 클라우드 컴퓨팅 환경이 도시되어 있다. 보여지는 바와 같이, 클라우드 컴퓨팅 환경은 하나 또는 그 이상의 클라우드 컴퓨팅 노드들을 포함한다. 예를 들어, 개 인용 디지털 보조기기(personal digital assistant, PDA) 또는 셀룰러 전화기(1054A), 데스크탑 컴퓨터 (1054B), 랩탑 컴퓨터(1054C), 및/또는 자동차의 컴퓨터 시스템(1054N)과 같은 클라우드 소비자들에 의해 사용 되는 로컬 컴퓨팅 디바이스들은 상기 클라우드 컴퓨팅 노드들을 이용하여 통신할 수 있다. 비록 도 10에 나타내지는 않았으나, 클라우드 컴퓨팅 노드들은 양자 플랫폼(예컨대, 양자 컴퓨터, 양자 하드웨어, 양자 소프트웨어 등)을 더 포함할 수 있으며, 클라우드 소비자들에 의해 사용되는 로컬 컴퓨팅 디바이스들은 이러한 양자 플랫폼을 이용하여 통신할 수 있다. 노드들은 서로 간에 통신할 수 있다. 그들은 로컬, 커뮤니티, 퍼블릭, 또는 위에서 설명된 하이브리드 클라우드들, 또는 그것들의 조합과 같은 하나 또는 그 이상의 네트워크 들에서 물리적으로 또는 가상으로 그룹핑될 수 있다(도시되지 않음). 이는 클라우드 컴퓨팅 환경이 클라 우드 소비자가 로컬 컴퓨팅 디바이스 상에서 리소스들을 유지할 필요가 없는 서비스들과 같은 기반구조, 플랫폼 들 및/또는 소프트웨어를 제공할 수 있도록 한다. 도 10에 보여진 컴퓨팅 디바이스들의 유형들(1054A-N)은 단지 설명을 위한 의도인 것이 이해되어야 하고, 컴퓨팅 노드들 및 클라우드 컴퓨팅 환경은 네트워크 및 /또는 네트워크 주소지정 연결(network addressable connection)의 어떤 유형을 통해(예컨대, 웹 브라우저를 사 용하여) 컴퓨터화된 디바이스의 어떤 유형과 통신할 수 있다는 것이 이해되어야 한다. 이제 도 11을 참조하면, 클라우드 컴퓨팅 환경(1150, 도 11)에 의해 제공된 기능적 추상화 계층들 (functional abstraction layers)의 세트가 보여진다. 도 11에 보여지는 컴포넌트들, 계층들(layers), 및 기능 들(functions)은 단지 예를 들어 설명하려는 의도인 것이고 발명의 실시예들은 그것으로 한정되는 것이 아니라 는 점이 미리 이해되어야 한다. 도시된 바와 같이 이하의 계층들과 해당 기능들이 제공된다. 하드웨어 및 소프트웨어 계층은 하드웨어 및 소프트웨어 컴포넌트들을 포함한다. 하드웨어 컴포넌 트들의 예들은 메인프레임들, RISC(Reduced Instruction Set Computer) 아키텍쳐 기반의 서버들,서버들, 블레이드(blade) 서버들, 스토리지 디바이스들, 및 네트워크 및 네트워킹 컴포넌트 들을 포함한다. 몇몇 실시예들에 있어서, 소프트웨어 컴포넌트들은 네트워크 어플리케이션 서버 소프트웨 어, 양자 플랫폼 라우팅 소프트웨어, 및/또는 양자 소프트웨어(도 11에 도시되지 않음)를 포함한다. 가상화 계층(Virtualization layer(은 추상화 계층(abstraction layer)을 제공한다. 추상화 계층 으로부터 가상 엔티티들의 다음의 예들, 즉, 가상 서버들, 가상 스토리지, 가상 통신망들 - 가상 사설 통신망들(virtual private networks)을 포함함 - , 가상 어플리케이션들 및 운영 체제들, 및 가상 클라이언트들이 제공될 수 있다. 일 실시예에서, 관리 계층(management layer)은 이하에서 설명되는 기능들을 제공할 수 있다. 리 소스 공급(Resource provisioning)은 컴퓨팅 리소스들 및 다른 리소스들의 동적 조달(dynamic procurement)을 제공한다. 컴퓨팅 리소스들 및 다른 리소스들은 클라우드 컴퓨팅 환경 내에서 태스크들을 수행 하는데 이용된다. 계량 및 가격 설정(Metering and Pricing)은, 리소스들이 클라우드 컴퓨팅 환경 내에서 이용됨에 따라, 비용 추적(cost tracking), 및 이들 리소스들의 소비에 대한 과금(billing) 및 비용청구 (invoicing)를 제공한다. 일 실시예에서, 이들 리소스들은 어플리케이션 소프트웨어 라이센스들을 포함할 수 있 다. 보안은 데이터 및 다른 리소스들을 위한 보호 뿐만 아니라, 클라우드 소비자들 및 태스크들을 위한 신원 확 인(identity verification) 기능을 제공한다. 사용자 포탈(user portal)은 소비자들 및 시스템 관리자들 을 위한 클라우드 컴퓨팅 환경에 대한 접근을 제공한다. 서비스 수준 관리는 요구되는 서비스 수준들이 충족되도록 클라우드 컴퓨팅 리소스 할당 및 관리를 제공한다. 서비스 수준 동의(Service Level Agreement, SLA) 계획(planning) 및 이행(fulfillment)은 SLA에 따라 장래 요구가 예상되는 클라우드 컴퓨팅 리소스 들을 위한 사전준비(pre-arrangement) 및 조달을 제공한다. 작업부하들 계층(Workloads layer)은 클라우드 컴퓨팅 환경이 이용될 수 있는 기능 (functionality)의 예들을 제공한다. 이 계층으로부터 제공될 수 있는 작업부하들 및 기능들의 예들은, 맵핑 및 내비게이션(mapping and navigation), 소프트웨어 개발 및 라이프싸이클 관리, 가상 교실 교육 전 달, 데이터 분석 처리(data analytics processing), 거래 처리(transaction processing), 및 양자 상태 준비 소프트웨어를 포함하나, 이러한 예들로 한정되는 것은 아니다. 본 발명은 어떤 가능한 통합의 기술적 세부 수준에서 시스템, 방법, 장치 및/또는 컴퓨터 프로그램 제품 일 수 있다. 컴퓨터 프로그램 제품은 컴퓨터 판독가능 스토리지 매체(또는 매체들)을 포함할 수 있고, 컴퓨터 판독가능 스토리지 매체(또는 매체들)는 컴퓨터 판독가능 스토리지 매체(또는 매체들)에 대한 컴퓨터 판독가능 프로그램 명령들을 가진다. 컴퓨터 판독가능 프로그램 명령들은 프로세서로 하여금 본 발명의 측면들(aspects) 을 수행하도록 하기 위한 것이다. 컴퓨터 판독가능 스토리지 매체는 명령 실행 디바이스에서 사용하기 위한 명 령들을 보유 및 저장할 수 있는 유형적인(tangible) 디바이스일 수 있다. 컴퓨터 판독가능 스토리지 매체는, 예 를 들어, 전자 스토리지 디바이스, 자기 스토리지 디바이스, 광학 스토리지 디바이스, 전자기 스토리지 디바이 스, 반도체 스토리지 디바이스, 또는 앞서 언급한 것들의 어떤 적절한 조합일 수 있으나, 이러한 것들로 한정되 는 것은 아니다. 컴퓨터 판독가능 스토리지 매체의 더 많은 구체적인 예들의 리스트(전체를 다 열거한 것은 아 님)는 또한, 휴대용 컴퓨터 디스켓, 하드 디스크, 랜덤 억세스 메모리(random access memory, RAM), 읽기 전용 메모리(read-only memory, ROM), 소거가능 프로그램가능 읽기 전용 메모리(erasable programmable read-only memory, EPROM 또는 플래쉬 메모리), 스태틱 랜덤 억세스 메모리(static random access memory, SRAM), 휴대용 컴팩트 디스크 읽기 전용 메모리(portable compact disc read-only memory, CD-ROM), 디지털 다용도 디스크 (digital versatile disk, DVD), 메모리 스틱, 플로피 디스크, 펀치-카드들 또는 기록된 명령들을 갖는 홈 (groove)에서 볼록한 구조들과 같은 기계적으로 인코딩된 디바이스, 및 앞서 열거한 것들의 어떤 적절한 조합을 포함할 수 있다. 여기서 사용되는 것과 같이, 컴퓨터 판독가능 스토리지 매체는, 무선 전파(radio waves) 또는 다른 자유롭게 전파되는 전자기파, 도파관 또는 다른 전송 매질을 통해 전파되는 전자기파(예컨대, 광섬유 케이 블을 통과하는 광 펄스), 또는 와이어를 통해 전송되는 전기적 신호와 같은 일시적인 신호들 그 자체로 구성되 는 것은 아니다. 여기에 설명되는 컴퓨터 판독가능 프로그램 명령들은, 예를 들어, 인터넷, 근거리 통신망, 광역 통신망 및/또는 무선 통신망과 같은 통신망을 통해 컴퓨터 판독가능 스토리지 매체로부터 각각의 컴퓨팅/처리 디바이스 들로, 또는 내부 컴퓨터 또는 외부 스토리지 디바이스로 다운로드될 수 있다. 통신망은 동선 전송 케이블, 광 전송 섬유, 무선 전송, 라우터, 방화벽, 스위치, 게이트웨이 컴퓨터 및/또는 엣지 서버를 포함할 수 있다. 각각 의 컴퓨팅/처리 디바이스에서 네트워크 어댑터 카드 또는 네트워크 인터페이스는, 각각의 컴퓨팅/처리 디바이스내 컴퓨터 판독가능 스토리지 매체에 저장하기 위해 통신망으로부터 컴퓨터 판독가능 프로그램 명령들을 수신하 고 컴퓨터 판독가능 프로그램 명령들을 전송한다. 본 발명의 동작들을 수행하기 위한 컴퓨터 판독가능 프로그램 명령들은 어셈블러 명령(assembler instructions), 명령-세트-아키텍쳐(instruction-set-architecture, ISA) 명령, 머신 명령(machine instructions), 머신 종속 명령(machine dependent instructions), 마이크로코드, 펌 웨어 명령(firmware instructions), 상태-세팅 데이터(state-setting data), 집적 회로망용 구성 데이터 (configuration data for integrated circuitry), 또는 하나 또는 그 이상의 프로그래밍 언어들의 어떤 조합으 로 작성된 소스 코드 또는 객체 코드(object code)일 수 있다. 상기 프로그래밍 언어들은 스몰토크(Smalltalk), C++ 등과 같은 객체 지향 프로그래밍 언어(object oriented programming language), 및 \"C\" 프로그래밍 언어 또는 유사 프로그래밍 언어들과 같은 절차형 프로그래밍 언어들을 포함한다. 컴퓨터 판독가능 프로그램 명령들 은 독립형(stand-alone) 소프트웨어 패키지로서 사용자의 컴퓨터 상에서 전적으로, 사용자의 컴퓨터 상에서 부 분적으로 실행될 수 있고, 사용자의 컴퓨터 상에서 부분적으로 그리고 원격 컴퓨터 상에서 부분적으로 실행될 수 있고, 또는 원격 컴퓨터 또는 서버 상에서 전적으로 실행될 수 있다. 후자의 시나리오에 있어서, 원격 컴퓨 터는 근거리 통신망(LAN) 또는 광역 통신망(WAN)을 포함하는 어떤 유형의 통신망을 통해 사용자의 컴퓨터에 연 결될 수 있고, 또는 그 연결은 외부 컴퓨터에 대해 이뤄질 수 있다(예컨대, 인터넷 서비스 공급자(Internet Service Provider)를 사용하여 인터넷을 통해서). 몇몇 실시예들에 있어서, 본 발명의 측면들을 수행하기 위해, 예를 들어, 프로그램가능 로직 회로망(programmable logic circuitry), 필드-프로그램가능 게이트 어레이 (field-programmable gate arrays, FPGA), 또는 프로그램가능 로직 어레이(Programmable logic arrays, PLA)를 포함하는 전기 회로망(electronic circuitry)은 전기 회로망을 고객 맞춤 제작(customize)하기 위해 컴퓨터 판 독가능 프로그램 명령들의 상태 정보를 이용함으로써 컴퓨터 판독가능 프로그램 명령들을 실행할 수 있다. 본 발명의 측면들은 여기서 발명의 실시예들에 따른 방법들, 장치들(시스템들), 및 컴퓨터 프로그램 제 품들의 플로우챠트 설명들 및/또는 블록 다이어그램들을 참조하여 설명된다. 플로우챠트 설명들 및/또는 블록 다이어그램들에서 플로우챠트 설명들 및/또는 블록 다이어그램들의 각각의 블록, 및 블록들의 조합들은 컴퓨터 판독가능 프로그램 명령들에 의해 구현될 수 있다는 것이 이해된다. 이들 컴퓨터 판독가능 프로그램 명령들은 머신(machine)을 생성하기 위해 범용 컴퓨터(general purpose computer), 전용 컴퓨터(special purpose computer), 또는 다른 프로그램가능 데이터 처리 장치의 프로세서에게 제공될 수 있으며, 그리하여 컴퓨터 또는 다른 프로그램가능 데이터 처리 장치의 프로세서를 통해 실행될 때 그 명령들이 플로우챠트 및/또는 블록 다이 어그램 블록 또는 블록들에 명시된 기능들/동작들을 구현하기 위한 수단을 생성하도록 한다. 이들 컴퓨터 판독 가능 프로그램 명령들은 또한 컴퓨터 판독가능 스토리지에 저장될 수 있으며, 컴퓨터 판독가능 스토리지는 컴퓨 터, 프로그램가능 데이터 처리 장치, 및/또는 다른 디바이스들이 특정 방식으로 기능하도록 지시할 수 있다. 그 리하여, 내부에 저장된 명령들을 갖는 컴퓨터 판독가능 스토리지 매체가 플로우챠트 및/또는 블록 다이어그램의 블록 또는 블록들에 명시된 기능/동작의 측면들을 구현하는 명령들을 포함하는 제조 물품을 포함하도록 한다. 컴퓨터 판독가능 프로그램 명령들은 또한 컴퓨터, 다른 프로그램가능 데이터 처리 장치, 또는 다른 다바이스 상 으로 로딩되어 컴퓨터, 다른 프로그램가능 장치 또는 다른 디바이스 상에서 수행될 일련의 동작들(operational acts)로 하여금 컴퓨터로 구현된 프로세스를 생성하게 할 수 있다. 그리하여 컴퓨터, 다른 프로그램가능 장치, 또는 다른 디바이스 상에서 실행되는 명령들이 플로우챠트 및/또는 블록 다이어그램의 블록 또는 블록들에 명시 된 기능들/동작들을 구현하도록 한다. 도면들에서 플로우챠트 및 블록 다이어그램들은 본 발명의 다양한 실시예들에 따른 시스템들, 방법들, 및 컴퓨터 프로그램 제품들의 가능한 구현의 아키텍쳐, 기능성, 및 동작을 보여준다. 이 점에서, 플로우챠트 또 는 블록 다이어그램들에서의 각각의 블록은 모듈, 세그먼트, 또는 명령들의 일부분을 나타낼 수 있으며, 이는 명시된 논리적 기능(들)을 구현하기 위한 하나 또는 그 이상의 실행가능한 명령들을 포함한다. 몇몇 다른 구현 들에 있어서, 블록들에 기재되어 있는 기능들은 도면들에 기재되어 있는 순서를 벗어나서 발생할 수도 있다. 예 를 들어, 연속해서 보여지는 두 개의 블록들은, 사실, 실질적으로 동시에 일어날 수 있고, 또는 블록들은 때로 는 관련된 기능에 따라 역순으로 실행될 수도 있다. 또한, 블록 다이어그램들 및/또는 플로우챠트 그림의 각각 의 블록, 및 블록 다이어그램들 및/또는 플로우챠트 그림에서의 블록들의 조합들은 명시된 기능들 또는 동작들 (acts)을 수행하거나 전용 하드웨어와 컴퓨터 명령들의 조합들을 수행하는 전용 하드웨어 기반 시스템들에 의해 구현될 수 있다는 것이 주목될 수 있다. 본 발명의 주제는 위에서 컴퓨터 및/또는 컴퓨터들 상에서 실행되는 컴퓨터 프로그램 제품의 컴퓨터-실 행가능 명령들의 일반적인 맥락에서 설명되었지만, 통상의 기술자들은 이러한 본 발명이 다른 프로그램 모듈들 과 조합하여 구현될 수도 있다는 것을 이해할 것이다. 일반적으로, 프로그램 모듈들은 특정 태스크들을 수행하 고 및/또는 특정 추상적인 데이터 유형들을 구현하는 루틴들, 프로그램들, 컴포넌트들, 데이터 구조들 등을 포함한다. 더욱이, 통상의 기술자들은, 본 발명의 컴퓨터 구현 방법들이 다른 컴퓨터 시스템 구성들과 함께 실시 될 수 있다는 것을 이해할 것이다. 다른 컴퓨터 시스템 구성들은, 컴퓨터들, 핸드-헬드 컴퓨팅 디바이스들 (hand-held computing devices)(예컨대, PDA, 폰), 마이크로프로세서 기반 또는 프로그램가능 소비자 또는 산 업용 전자제품 등 뿐만 아니라, 단일-프로세서 또는 멀티 프로세서 컴퓨터 시스템들, 멀티-컴퓨팅 디바이스들, 메인프레임 컴퓨터들을 포함한다. 도시된 본 발명의 측면들은 또한 분산형 컴퓨팅 환경들에서 실시될 수 있다. 분산형 컴퓨팅 환경들에서는 태스크들이 통신 네트워크를 통해 연결된 원격 처리 디바이스들에 의해 수행된다. 그러나, 전부는 아니지만 본 발명의 측면들은 독립형 컴퓨터들 상에서 실행될 수 있다. 분산형 컴퓨팅 환경에서, 프로그램 모듈들은 로컬 및 원격 메모리 스토리지 디바이스들 모두에 위치할 수 있다. 본 명세서에서 사용되는 것과 같이, \"컴포넌트\", \"시스템\", \"플랫폼\", 인터페이스\" 등의 용어들은 컴퓨 터-관련 엔티티 또는 하나 또는 그 이상의 특정 기능들을 갖는 동작 머신과 관련된 엔티티를 지칭할 수 있고, 및/또는 컴퓨터-관련 엔티티 또는 하나 또는 그 이상의 특정 기능들을 갖는 동작 머신과 관련된 엔티티를 포함 할 수 있다. 여기에 개시되는 엔티티들은 하드웨어, 하드웨어와 소프트웨어의 조합, 소프트웨어, 또는 실행 중 인 소프트웨어 중 하나일 수 있다. 예를 들어, 컴포넌트는 프로세서 상에서 실행되는 프로세스, 프로세서, 객체 (object), 실행 파일, 실행의 쓰레드(thread), 프로그램, 및/또는 컴퓨터일 수 있으나, 이러한 예들로 한정되는 것은 아니다. 예로서, 서버 상에서 실행되는 어플리케이션과 서버 둘 모두가 컴포넌트일 수 있다. 하나 또는 그 이상의 컴포넌트들은 프로세스 내에 상주할 수 있고 및/또는 실행의 쓰레드와 컴포넌트는 하나의 컴퓨터 상에 로컬화될 수 있고 및/또는 두 개 또는 그 이상의 컴퓨터들 사이에 분산될 수 있다. 또 다른 예에서, 각각의 컴 포넌트들은 다양한 데이터 구조들이 저장된 다양한 컴퓨터 판독가능 매체로부터 실행될 수 있다. 컴포넌트들은 예를 들어 하나 또는 그 이상의 데이터 패킷들(예컨대, 로컬 시스템, 분산된 시스템에서 또 다른 컴포넌트와, 및/또는 인터넷과 같은 네트워크를 통해 신호로 다른 시스템들과 상호작용하는 하나의 컴포넌트로부터의 데이터)을 갖는 신호에 따라 로컬 및/원격 프로세스들을 통해 통신할 수 있다. 또 다른 예로서, 컴포넌트는 전 기 또는 전자 회로망에 의해 동작되는 기계적 부품들에 의해 제공되는 특정 기능을 갖는 장치일 수 있는데, 이 는 프로세서에 의해 실행되는 소프트웨어 또는 펌웨어 어플리케이션에 의해 동작된다. 그러한 경우에 있어서, 프로세서는 장의 내부 또는 장치의 외부에 있을 수 있고 소프트웨어 또는 펌웨어 어플리케이션의 적어도 일부에 서 실행될 수 있다. 또 다른 예로서, 컴포넌트는 기계적인 부품들이 없이 전자 컴포넌트들을 통해 특정 기능을 제공하는 장치일 수 있는데, 여기서 전자 컴포넌트들은 전자 컴포넌트의 기능의 적어도 일부를 제공하는 소프트 웨어 또는 펌웨어를 실행하기 위한 프로세서 또는 다른 수단을 포함할 수 있다. 일 측면에서, 컴포넌트는 가상 머신을 통해, 예컨대, 클라우드 컴퓨팅 시스템 내에서, 전자 컴포넌트를 에뮬레이트(emulate)할 수 있다. 또한, \"또는\" 이라는 용어는 배타적인 \"또는\" 이라기보다는 포괄적인 \"또는\" 을 의미하려는 의도이다. 즉, 만약 달리 명시되지 않거나 문맥상 명확하지 않다면, \"X는 A 또는 B를 이용한다\" 라는 것은 자연적 포괄적 순열들 중 어떤 것을 의미하려는 의도이다. 즉, 만약 X가 A를 이용하고, X가 B를 이용하고, 또는 X가 A와 B 둘 모두를 이용한다면, \"X는 A 또는 B를 이용한다\"는 전술한 예들 중 어떤 것에도 만족된다. 더욱이, 본 명세서 및 첨부된 도면들에 사용되는 \"하나\" 및 \"한\" 이라는 것은 다르게 특정되거나 문맥상 단일 형태를 가리키는 것으로 명확하지 않다면, 일반적으로 \"하나 또는 그 이상\"을 의미하는 것으로 해석되어야 한다. 여기에 사용되는 바와 같이, \"예\" 및/또는 \"예시\" 라는 용어는, 하나의 예, 하나의 사례, 설명을 위한 예로서의 역할을 한다는 의미로 이용된다. 의심을 피하기 위해, 여기에 개시되는 본 발명의 주제는 그러한 예들로 한정되는 것은 아니다. 또한, \"예\" 및/또는 \"예시\" 로서 여기에 설명되는 어떤 측면 또는 디자인은 다른 측면들 또는 디자인들에 비해 더 선 호되거나 더 유리한 것으로 반드시 해석되는 것은 아니며, 또한, 당해 기술 분야에서 통상의 기술을 가진 자들 에게 알려진 동등한 예시적인 구조들 및 기술들을 배제하는 것을 의미하지는 않는다. 본 명세서에 이용되고 있는 바와 같이, \"프로세서\" 라는 용어는 실질적으로 어떤 컴퓨팅 처리 유닛 또는 디바이스를 지칭할 수 있다. 이러한 컴퓨팅 처리 유닛 또는 디바이스는 단일-코어 프로세서들, 소프트웨어 멀티 쓰레드 실행 기능을 갖는 단일-프로세서들, 멀티-코어 프로세서들, 소프트웨어 멀티쓰레드 실행 기능을 갖는 멀 티-코어 프로세서들, 하드웨어 멀티쓰레드 기술을 갖는 멀티-코어 프로세서들, 병렬 플랫폼들, 및 분산형 공유 메모리(distributed shared memory)를 갖는 병렬 플랫폼들을 포함하나, 이러한 예들로 한정되는 것은 아니다. 또한, 프로세서는 집적 회로, 어플리케이션 전용 집적 회로(application specific integrated circuit, ASIC), 필드 프로그램가능 게이트 어레이(field programmable gate array, FPGA), 프로그램가능 로직 컨트롤러 (programmable logic controller, PLC), 복합 프로그램가능 로직 디바이스(complex programmable logic device, CPLD), 이산 게이트(discrete gate) 또는 트랜지스터 로직(transistor logic), 이산 하드웨어 컴포넌 트들, 또는 여기에 설명되는 기능들을 수행하도록 설계된 전술한 것들의 어떤 조합을 일컬을 수 있다. 나아가, 공간 사용을 최적화하거나 사용자 장비의 성능을 향상시키기 위해, 프로세서들은 나노-스케일 아키텍쳐들 - 예컨대, 분자 및 양자-도트 기반 트랜지스터들, 스위치들 및 게이트들, 그러나 이러한 것들로 한정되는 것은 아님 - 을 이용할 수 있다. 또한, 프로세서는 컴퓨팅 처리 유닛들의 조합으로 구현될 수도 있다. 본 명세서 내에서, \"저장하다\", \"저장\", \"스토리지\", \"데이터 저장\", \"데이터 스토리지\", \"데이터베이스\" 와 같은 용어, 그리고 어 떤 컴포넌트의 동작과 기능과 관련된 실질적으로 다른 어떤 정보 스토리지 컴포넌트 라는 용어는 \"메모리 컴포 넌트\", \"메모리\"에 구현된 엔티티들, 또는 메모리를 포함하는 컴포넌트들을 일컫는 것으로 이용된다. 여기에 설 명되는 메모리 및/또는 메모리 컴포넌트들은 휘발성 메모리 또는 비휘발성 메모리일 수 있고, 또는 휘발성 메모 리와 비휘발성 메모리 모두를 포함할 수 있다는 것이 이해되어야 할 것이다. 예를 들어(이러한 예로 한정되는 것은 아님), 비휘발성 메모리는 읽기 전용 메모리(ROM), 프로그램가능 ROM(PROM), 전기적 프로그램가능 ROM(EPROM), 전기적 소거가능 ROM(EEPROM), 플래쉬 메모리, 또는 비휘발성 랜덤 억세스 메모리(RAM)(예컨대, 강 유전성(Rerroelectric) RAM(FeRAM))을 포함할 수 있다. 휘발성 메모리는 RAM을 포함할 수 있는데, 이는 예컨대 외부 캐시 메모리로 동작할 수 있다. 예를 들어(이러한 예로 한정되는 것은 아님), RAM은 예를 들어 싱크로너스 (synchronous) RAM(SRAM), 다이나믹(dynamic) RAM(DRAM), 싱크로너스(synchronous) DRAM(SDRAM), 더블 데이터 레이트(double data rate) SDRAM(DDR SDRAM), 향상된(enhanced) SDRAM(ESDRAM), 싱크링크(Synchlink) DRAM(SLDRAM), 다이렉트 램버스(direct Rambus) RAM(DRRAM), 다이렉트 램버스 다이나믹(direct Rambus dynamic) RAM(DRDRAM), 및 램버스 다이나믹(Rambus dynamic) RAM(RDRAM)과 같이 다양한 형태로 이용가능하다. 또한, 여기에서 시스템들 또는 컴퓨터 구현 방법들의 개시된 메모리 컴포넌트들은 이것들 및 다른 어떤 적절한 유형들의 메모리 - 이러한 것들로 한정되는 것은 아님 - 를 포함하도록 의도된다. 위에서 설명된 것은 시스템들 및 컴퓨터 구현 방법들의 단순한 예들을 포함한다. 물론, 본 발명을 설명 하려는 목적으로 컴포넌트들 또는 컴퓨터 구현 방법들의 모든 생각해낼 수 있는 조합들을 설명하는 것은 불가능 하지만, 당해 기술 분야에서 통상의 기술을 가진 자는 본 발명의 많은 추가적인 조합들 및 순열들이 가능하다는 것을 알 수 있을 것이다. 더 나아가, 상세한 설명, 청구항들, 및 도면들에서 \"포함하다\", \"갖다\", \"구비하다\" 등과 같은 용어가 사용되는 범위 내에서, \"포함하는(comprising)\" 이 청구항에서 전환어(transitional word)로 서 이용될 때 해석되는 것과 같이, 그러한 용어는 \"포함하는\" 이라는 용어와 유사한 방식으로 포괄적인 것으로 의도된다. 다양한 실시예들에 관한 설명들은 예시의 목적으로 제공된 것이지 실시예들을 빠짐없이 열거하거나 개시 된 실시예들로 한정하려는 의도는 아니다. 설명된 실시예들의 범위 및 사상을 벗어남이 없이 많은 변경들 및 변 형들이 있을 수 있다는 것은 당해 기술 분야에서 통상의 기술을 가진 자들에게는 분명할 것이다. 여기에 사용된 용어는 실시예들의 원리, 시장에서 발견되는 기술에 대한 실제적인 적용 또는 기술적 향상을 가장 잘 설명하기 위해 선택되었다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11"}
{"patent_id": "10-2022-7032326", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 적응적 컴파일(adaptive compilation)을 생성하기 위해 이전의 양자 회로들 및 중간 결과들에 기 초하여 양자 회로들의 양자 적응적 실행을 용이하게 하는 시스템 구현의 일 예의 블록 다이어그램을 나타낸다. 도 2는 적응적 컴파일(adaptive compilation)을 생성하기 위해 이전의 양자 회로들 및 중간 결과들에 기 초하여 양자 회로들의 양자 적응적 실행을 용이하게 하는 시스템 구현의 일 예의 블록 다이어그램을 나타낸다. 도 3은 양자 회로를 생성할 수 있는 회로 컴포저(circuit composer)의 일 예를 나타낸다. 도 4는 양자 회로 생성기의 상세 플로우챠트의 일 예를 나타낸다. 도 5는 양자 회로의 효율적인 양자 적응적 실행 방법(quantum adaptive execution method)의 플로우챠 트의 일 예를 나타낸다. 도 6은 변분-양자 아이젠솔버(Variational-Quantum Eigensolver, VQE) 알고리즘을 위한 양자 회로의 일 예를 나타낸다. 도 7은 고전적인 VQE 양자 알고리즘의 플로우챠트의 일 예를 나타낸다. 도 8은 여기에 설명되는 하나 또는 그 이상의 실시예들에 따라 양자 컴퓨팅 잡들(jobs)의 적응적 컴파일 (adaptive compilation)을 용이하게 할 수 있는 시스템의 일 예(이러한 예로 한정되는 것은 아님)의 다이어그램 을 나타낸다. 도 9는 여기에 설명되는 하나 또는 그 이상의 실시예들이 용이해질 수 있는 동작 환경의 일 예(이러한 예로 한정되는 것은 아님)의 블록 다이어그램을 나타낸다. 도 10은 본 발명의 하나 또는 그 이상의 실시예들에 따른 클라우드 컴퓨팅 환경(cloud computing environment)의 일 예(이러한 예로 한정되는 것은 아님)의 블록 다이어그램을 나타낸다. 도 11은 본 발명의 하나 또는 그 이상의 실시예에 따른 추상화 모델 계층들(abstraction model layer s)의 일 예(이러한 예로 한정되는 것은 아님)의 블록 다이어그램을 나타낸다."}
