{"patent_id": "10-2023-0108259", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0027022", "출원번호": "10-2023-0108259", "발명의 명칭": "데이터를 동기화하기 위한 네트워크 장치, 시스템, 및 CXL 스위칭 장치의 동작 방법", "출원인": "삼성전자주식회사", "발명자": "이영현"}}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "CXL(Compute Express Link) 기반의 시스템에 있어서,입력 벡터 데이터와 부분 행렬의 행렬곱 연산을 수행하도록 구성되고, 인터럽트 신호, 및 출력 벡터 데이터와특성 데이터를 포함하는 패킷을 출력하도록 구성된 복수의 CXL 프로세싱 장치들; 및상기 인터럽트 신호 및 상기 패킷을 기초로 상기 출력 벡터 데이터에 대한 연산을 수행함으로써 상기 출력 벡터데이터를 동기화하도록 구성되고, 동기화된 벡터 데이터를 상기 복수의 CXL 프로세싱 장치들에 제공하도록 구성된 CXL 스위칭 장치를 포함하는, 시스템."}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서,상기 CXL 스위칭 장치는,상기 출력 벡터 데이터를 저장하는 메모리;상기 인터럽트 신호에 응답하여, 상기 특성 데이터를 기초로 인스트럭션 신호를 상기 메모리에 저장하도록 구성된 컨트롤 로직; 및상기 메모리에 저장된 인스트럭션 신호를 기초로 연산 동작을 확인하도록 구성되고, 상기 연산 동작에 따라 상기 동기화된 벡터 데이터를 생성하도록 구성되고, 상기 동기화된 벡터 데이터를 상기 메모리에 저장하도록 구성된 컴퓨트 로직을 포함하는 것을 특징으로 하는, 시스템."}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2 항에 있어서,상기 컨트롤 로직은,상기 인터럽트 신호에 응답하여 호출 신호를 출력하도록 구성된 인터럽트 핸들러;상기 호출 신호에 응답하여, 상기 특성 데이터로부터 상기 인스트럭션 신호를 인코딩하도록 구성되고, 상기 인스트럭션 신호를 상기 메모리에 전달하도록 구성된 인코더;상기 저장된 인스트럭션 신호를 상기 메모리에서 상기 컴퓨트 로직으로 출력하는 스케줄링 동작을 수행하도록구성된 스케줄러; 및상기 동기화된 벡터 데이터를 상기 복수의 CXL 프로세싱 장치들에 제공하도록 상기 메모리를 제어하도록 구성된컨트롤러를 포함하는 것을 특징으로 하는, 시스템."}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2 항에 있어서,상기 컴퓨트 로직은,상기 연산 동작을 확인하기 위해 상기 인스트럭션 신호를 디코딩하도록 구성된 디코더; 및 상기 디코딩된 인스트럭션 신호에 따라 상기 연산 동작을 수행하도록 구성되고, 상기 동기화된 벡터 데이터를상기 메모리에 전달하도록 구성된 복수의 연산 블록들을 포함하는 것을 특징으로 하는, 시스템."}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2 항에 있어서,공개특허 10-2025-0027022-3-상기 메모리는,상기 출력 벡터 데이터 및 상기 동기화된 벡터 데이터를 임시적으로 저장하도록 구성된 제1 버퍼; 및상기 인스트럭션 신호를 순차적으로 큐잉(queuing)하도록 구성된 제2 버퍼를 포함하는 것을 특징으로 하는, 시스템."}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1 항에 있어서,상기 복수의 CXL 프로세싱 장치들은,인공지능 모델의 가중치 행렬의 제1 부분 행렬과 제1 입력 벡터 데이터의 행렬곱 연산을 수행하도록 구성된 제1CXL 프로세싱 장치; 및상기 제1 부분 행렬과 다른 제2 부분 행렬과 상기 제1 입력 벡터 데이터의 행렬곱 연산을 수행하도록 구성된 제2 CXL 프로세싱 장치를 포함하는 것을 특징으로 하는, 시스템."}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1 항에 있어서,상기 복수의 CXL 프로세싱 장치들은,제1 부분 행렬과 제1 입력 벡터 데이터의 행렬곱 연산을 수행하도록 구성된 제1 CXL 프로세싱 장치; 및상기 제1 부분 행렬과 제2 입력 벡터 데이터의 행렬곱 연산을 수행하도록 구성된 제2 CXL 프로세싱 장치를 포함하는 것을 특징으로 하는, 시스템."}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1 항에 있어서,상기 복수의 CXL 프로세싱 장치들은, 각각복수의 장치 메모리들;상기 복수의 장치 메모리들을 제어하도록 구성된 메모리 컨트롤러; 및상기 행렬곱 연산을 수행하도록 구성되고, 상기 인터럽트 신호 및 상기 패킷을 상기 CXL 스위칭 장치에 전달하도록 구성된 프로세싱-인-메모리를 포함하는 것을 특징으로 하는, 시스템."}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "CXL(Compute Express Link) 스위칭 장치의 동작 방법에 있어서,복수의 CXL 프로세싱 장치들 각각으로부터 복수의 패킷들 및 인터럽트 신호를 수신하는 단계, 상기 복수의 패킷들 각각은 벡터 데이터와 특성 데이터를 포함하고;상기 복수의 패킷들 및 상기 인터럽트 신호를 기초로 상기 벡터 데이터에 대한 연산을 수행함으로써, 상기 벡터데이터를 동기화하는 단계; 및동기화된 벡터 데이터를 상기 복수의 CXL 프로세싱 장치들에 출력하는 단계를 포함하는, 동작 방법."}
{"patent_id": "10-2023-0108259", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "네트워크 장치에 있어서,복수의 프로세싱 장치들로부터 수신된 복수의 패킷들의 벡터 데이터를 저장하는 메모리;복수의 프로세싱 장치들로부터 수신된 복수의 인터럽트 신호들에 응답하여. 복수의 패킷들의 특성 데이터를 기초로 인스트럭션 신호를 상기 메모리에 저장하도록 구성된 컨트롤 로직; 및상기 메모리에 저장된 인스트럭션 신호를 기초로 연산 동작을 확인하도록 구성되고, 상기 메모리에 저장된 벡터공개특허 10-2025-0027022-4-데이터에 대해 상기 연산 동작을 수행함으로써, 상기 저장된 벡터 데이터를 동기화하도록 구성되고, 동기화된벡터 데이터를 출력하도록 구성된 컴퓨트 로직을 포함하는 것을 특징으로 하는, 네트워크 장치."}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "데이터를 동기화하기 위한 네트워크 장치, 시스템, 및 CXL(Compute Express Link) 스위칭 장치의 동작 방법이 개 시된다. 본 개시의 기술적 사상에 따른 CXL 기반의 시스템은, 입력 벡터 데이터와 부분 행렬의 행렬곱 연산을 수 행하고, 행렬곱 연산의 결과로 출력된 출력 벡터 데이터를 출력하는 복수의 CXL 프로세싱 장치들, 및 복수의 CXL 프로세싱 장치들로부터 수신된 출력 벡터 데이터를 동기화하고, 동기화된 벡터 데이터를 복수의 CXL 프로세싱 장 치들에 제공하는 CXL 스위칭 장치를 포함한다."}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시의 기술적 사상은 전자 장치에 관한 것이며, 구체적으로는 데이터를 동기화하기 위한 네트워크 장치, 시 스템, 및 CXL 스위칭 장치의 동작 방법에 관한 것이다."}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능(AI), 빅데이터, 엣지 컴퓨팅(Edge Computing)과 같은 기술이 발전함에 따라, 장치에서 많은 양의 데이 터를 빠르게 처리하고자 하는 요구가 대두되고 있다. 복잡한 연산을 수행하는 고대역폭 애플리케이션에서 더 빠 른 데이터 처리와 더 효율적인 메모리 액세스가 필요하다. 예를 들면, LLM(Large-Language Model)과 같은 초거 대 인공지능 모델에서 인터페이스를 위한 대용량의 파라미터들을 처리할 필요가 있다. 이를 위해, 다수의 GPU 혹은 FPGA 장치 등의 처리 장치에 가중치 행렬이 분할 저장되고 각 장치가 데이터를 병렬적으로 연산하는 기술 이 개발되고 있다. 이때, 각 장치에서 분할적으로 연산된 데이터 또는 결과는 부분적인 정보를 가지므로, 전체 적인 정보를 갖는 결과나 데이터가 필요하며, 이러한 전체 결과나 데이터를 위한 데이터의 동기화 과정이 필요 하다. 일반적으로 동기화 과정의 경우, 각 장치에서 연산된 부분적인 데이터가 어느 하나의 장치에 모두 전달되 고, 하나의 장치가, 전체적인 정보를 포함하는 데이터를 동기화하며 동기화된 데이터를 다시 각 장치에 재전송 한다. 그런데, 이러한 동기화 과정은 장치와 장치 간의 병목 및 혼잡이 발생하여 연산의 지연(Latency)이 길어 질 수 있다."}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시의 기술적 사상은, 레이턴시를 줄이고 데이터를 효율적으로 연산하기 위해 데이터를 동기화하는 네트워 크 장치, 시스템, 및 CXL 스위칭 장치의 동작 방법을 제공하는 것이다."}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시의 기술적 사상에 따른 CXL(Compute Express Link) 기반의 시스템은, 입력 벡터 데이터와 부분 행렬의 행렬곱 연산을 수행하도록 구성되고, 인터럽트 신호, 및 출력 벡터 데이터와 특성 데이터를 포함하는 패킷을 출 력하도록 구성된 복수의 CXL 프로세싱 장치들, 및 인터럽트 신호 및 패킷을 기초로 출력 벡터 데이터에 대한 연 산을 수행함으로써 출력 벡터 데이터를 동기화하도록 구성되고, 동기화된 벡터 데이터를 복수의 CXL 프로세싱 장치들에 제공하도록 구성된 CXL 스위칭 장치를 포함한다. 또한, 본 개시의 기술적 사상에 따른 CXL 스위칭 장치의 동작 방법은, 복수의 CXL 프로세싱 장치들 각각으로부 터 복수의 패킷들 및 인터럽트 신호를 수신하는 단계, 복수의 패킷들 및 인터럽트 신호를 기초로 벡터 데이터에 대한 연산을 수행함으로써, 벡터 데이터를 동기화하는 단계, 및 동기화된 벡터 데이터를 복수의 CXL 프로세싱 장치들에 출력하는 단계를 포함한다. 복수의 패킷들 각각은 벡터 데이터와 특성 데이터를 포함한다. 또한, 본 개시의 기술적 사상에 따른 CXL 기반의 네트워크 장치는, 복수의 CXL 프로세싱 장치들로부터 수신된 복수의 패킷들의 벡터 데이터를 저장하는 메모리, 복수의 CXL 프로세싱 장치들로부터 수신된 복수의 인터럽트 신호들에 응답하여. 복수의 패킷들의 특성 데이터를 기초로 인스트럭션 신호를 메모리에 저장하도록 구성된 컨 트롤 로직, 및 메모리에 저장된 인스트럭션 신호를 기초로 연산 동작을 확인하도록 구성되고, 메모리에 저장된 벡터 데이터에 대해 연산 동작을 수행함으로써, 저장된 벡터 데이터를 동기화하도록 구성되고, 동기화된 벡터 데이터를 출력하도록 구성된 컴퓨트 로직을 포함한다."}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시의 기술적 사상에 의하면, 많은 양의 데이터를 처리하는 상황에서 레이턴시를 줄일 수 있는 효과가 있다. 또한, 본 개시의 기술적 사상에 의하면, CXL 기반의 처리 장치와 CXL 기반의 네트워크 장치 간의 경로에서 발생 할 수 있는 병목(bottle-neck) 및 혼잡(Congestion)을 줄일 수 있는 효과가 있다. 본 개시의 실시예들에서 얻을 수 있는 효과는 이상에서 언급한 효과들로 제한되지 아니하며, 언급되지 아니한"}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 2, "content": "다른 효과들은 이하의 기재로부터 본 개시의 실시예들이 속하는 기술분야에서 통상의 지식을 가진 자에게 명확 하게 도출되고 이해될 수 있다. 즉, 본 개시의 실시예들을 실시함에 따른 의도하지 아니한 효과들 역시 본 개시"}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 3, "content": "의 실시예들로부터 당해 기술분야의 통상의 지식을 가진 자에 의해 도출될 수 있다."}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 첨부한 도면을 참조하여 본 개시의 실시예에 대해 상세히 설명한다. 도 1은 본 개시의 예시적인 실시예에 따른 시스템을 나타내는 블록도이다. 도 1을 참조하면, 시스템은 CXL(compute express link) 프로토콜들을 지원할 수 있다. CXL은 원격 I/O 장치 의 구성 가능성에 사용될 수 있는 NVMeoF(Non-Volatile Memory express over fabric)와 같은 다른 프로토콜에 대한 상대방(counterpart)으로서 기능할 수 있다. 여기에서 사용되는 \"구성 가능한(composable)\"은 주어진 장치 (예컨대, 특정 클러스터의 캐시 일관성 인에이블된 장치)가 워크로드의 적어도 일부를 실행하기 위해 네트워크 의 다른 부분(예컨대, 제2 클러스터의 적어도 하나의 다른 캐시 일관성 인에이블된 장치)으로부터 자원(예컨대, 메모리, 컴퓨팅 및/또는 네트워크 자원)을 요청 및/또는 획득할 수 있는 속성을 나타낼 수 있다. 일부 실시예들 에서, \"구성 가능성(composability)\"은 임의의 어플리케이션 또는 워크로드를 구동하기 위해 임의의 적합한 구 성으로의 물리적 및 가상의 컴퓨팅, 스토리지 및 패브릭 자원들의 유동적 풀의 사용을 포함할 수 있다. CXL은 PCIe(Peripheral Component Interconnect Express) 5.0에 기반한 통신을 위한 개방형 산업 표준으로, 고정적인, 비교적 짧은 패킷 크기를 제공할 수 있으며, 그 결과 비교적 높은 대역폭과 비교적 낮은 고정 대기시 간을 제공할 수 있다. 이와 같이, CXL은 캐시 일관성을 지원할 수 있으며 CXL은 메모리에 대한 연결들을 생성하 는 데에 매우 적합할 수 있다. CXL은 또한 서버에서 호스트와 가속기, 메모리 장치들 및 네트워크 인터페이스 회로들(또는 \"네트워크 인터페이스 컨트롤러\" 또는 네트워크 인터페이스 카드(NIC)) 간의 연결을 제공하기 위해 또한 사용될 수 있다. CXL과 같은 캐시 일관성 프로토콜은 예컨대, 스칼라, 벡터 및 버퍼링된 메모리 시스템에 서 이기종 처리(heterogeneous processing)를 위해 채용될 수도 있다. CXL은 채널, 리타이머(retimer), 시스템 의 PHY 계층, 인터페이스의 논리적 측면 및 프로토콜을 PCIe 5.0로부터 활용하여 캐시-일관성 인터페이스를 제 공하는 데 사용될 수 있다. CXL 트랜잭션 계층은 단일 링크 상에서 동시에 작동하는 3개의 다중화된 하위 프로 토콜들을 포함할 수 있으며 CXL.io, CXL.cache 및 CXL.memory라고 지칭될 수 있다. CXL.io에는 PCIe와 유사할 수 있는 I/O 시멘틱을 포함할 수 있다. CXL.cache는 캐싱 시멘틱(caching semantic)를 포함 할 수 있고 CXL.memory는 메모리 시멘틱(memory samantic)을 포함할 수 있고, 캐싱 시멘틱 및 메모리 시멘틱은 모두 선택사 항일 수 있다. PCIe와 마찬가지로 CXL은 (i)분할가능한 x16, x8 및 x4의 기본 너비, (ii) 8GT/s 및 16GT/s, 128b/130b로 성능저하 가능한 32GT/s의 데이터 속도, (iii) 300W(x16 커넥터에서 75W) 및 (iv) 플러그 앤 플레 이(plug and play)를 지원할 수 있다. 플러그 앤 플레이를 지원하기 위해 PCIe 또는 CXL 장치 링크는 Gen1의PCIe에서 트레이닝을 시작하고, CXL을 협상하고 Gen 1-5 트레이닝을 완료한 후 CXL 트랜잭션을 시작할 수 있다. 시스템은 CXL 호스트, CXL 스위치, 및 제1 내지 제n CXL 프로세싱 장치들(110_1, 110_2, ..., 110_n)을 포함할 수 있다. n은 2 이상의 정수일 수 있다. CXL 호스트는, CPU(central processing unit), 어플리케이션 프로세서(Application Processor, AP), 시스 템 온 칩(System-On-a-Chip, SoC) 등과 같이 데이터를 처리할 수 있다. CXL 호스트는, 운영 체제 (operating system, OS) 및/또는 다양한 응용 프로그램(application)을 수행할 수 있다. CXL 호스트는, 호 스트 메모리에 연결될 수 있다. CXL 호스트는, 물리 계층, 다중-프로토콜 멀티플렉서, 인터페이스 회로들, 일관성/캐시 회로, 버스 회로, 적어도 하나의 코어 및 입출력 장치를 포함할 수 있다. CXL 호스트는, CXL 인터페이스를 통해 연결되어, 제1 내지 제n CXL 프로세싱 장치들(110_1, 110_2, ..., 110_n)의 동작을 전반적으 로 제어할 수 있다. CXL 인터페이스는 데이터 압축 및 암호화, 인공지능(AI) 같은 특수 작업 부하의 급속한 혁 신으로 인해 CXL 호스트와 제1 내지 제n CXL 프로세싱 장치들(110_1, 110_2, ..., 110_n)가 함께 동작하는 이기종 컴퓨팅 환경에서 호스트 장치와 반도체 장치의 오버헤드 및 대기 시간을 줄이고 호스트 메모리와 장치 메모리 공간을 공유할 수 있게 해주는 인터페이스이다. CXL 호스트와 제1 내지 제n CXL 프로세싱 장치들 (110_1, 110_2, ..., 110_n)는 CXL 인터페이스를 통해 매우 높은 대역폭으로 메모리 일관성을 유지할 수 있다. CXL 인터페이스는 3가지 하위 프로토콜 CXL.io, CXL.cache, CXL.mem을 포함한다. CXL.io는 PCIe 인터페이스를 이용하며, 시스템에서 장치 검색, 인터럽트 관리, 레지스터에 의한 액세스 제공, 초기화 처리 및 신호 오류 처 리 등에 사용한다. CXL.cache는 반도체 장치에 포함된 가속기 등의 연산장치가 호스트 장치의 호스트 메모리에 액세스할 때 사용될 수 있다. CXL.mem은 호스트 장치가 반도체 장치에 포함된 장치 메모리에 액세스할 때 사용 될 수 있다. CXL 스위치는, 인터럽트 신호 및 패킷을 기초로 출력 벡터 데이터에 대한 연산을 수행함으로써, 출력 벡터 데이터를 동기화할 수 있다. CXL 스위치는, 동기화된 벡터 데이터를 제1 내지 제n CXL 프로세싱 장치들 (110_1, 110_2, ..., 110_n)에 제공할 수 있다. 본 개시의 CXL 스위치는 CXL 스위칭 장치, CXL 기반의 네 트워크 장치로 지칭될 수 있다. 메모리 풀에 대한 CXL 연결들의 사용은 네트워크에 의해 함께 연결된 복수개의 서버를 포함하는 시스템에서 다양한 이점을 제공할 수 있다. 예를 들어, CXL 스위치는 CXL 패킷에 대한 패 킷-스위칭 기능을 제공하는 것 외에 추가 기능을 가질 수 있다. CXL 스위치는 메모리 풀을 하나 이상의 CXL 호스트 및/또는 하나 이상의 네트워크 인터페이스 회로에 연결하는데 사용될 수 있다. 이에 따르면, (i) 메모리의 집합이 서로 다른 특성들을 갖는 다양한 타입의 메모리를 포함할 수 있도록 하며, (ii) CXL 스위 치가 메모리 집합을 가상화하고 다른 특성(예컨대, 액세스 주파수)의 데이터를 적절한 타입의 메모리에 저 장할 수 있도록 하며, (iii) CXL 스위치가 RDMA(remote direct memory access)를 지원하여 RDMA가 서버의 처리 회로에서 거의 또는 전혀 관여하지 않고 수행될 수 있도록 한다. 본 개시에서 \"메모리를 가상화한다\"는 것 은 처리 회로와 메모리 사이에서 메모리 주소 변환을 수행하는 것을 의미한다. CXL 스위치는 (i) 단일 레 벨 스위칭을 통해 메모리 및 가속기 분리를 지원하고, (ii) 자원이 도메인들 사이에서 오프-라인되고 온-라인되 도록 지원하고, 요구에 따라 도메인들에 걸쳐 시간 다중화를 가능하게 하며 (iii) 다운스트림 포트의 가상화를 지원할 수 있다. CXL은, 집합된 장치들이 LD-ID (논리 장치 식별자)를 각각 갖는 다수의 논리 장치들로 분할된 상태에서, 일대다(one-to-many) 및 다대일(many-to-one) 스위칭을 가능하게 하는 집합 메모리를 구현하는 데 사 용될 수 있다. 예컨대, (i) CXL은 다수의 루트 포트들을 하나의 엔드포인트에 연결하고 (ii) 하나의 루트 포트 를 다수의 엔드포인트들에 연결하고 또는 (iii) 다수의 루트 포트들을 다수의 엔트포인트들에 연결할 수 있다. 이러한 실시예에서, 물리적 장치는 각각의 개시자(initiator)에게 가시적인 복수의 논리적 장치로 분할될 수 있 다. 장치는 하나의 물리적 기능(PF)과 복수(예를 들어, 16)의 분리된 논리적 장치들을 가질 수 있다. 일부 실시 예들에서 논리 장치들의 개수(예를 들어, 파티션들의 개수)는 제한될 수 있고(예를 들어, 16 개까지), 하나의 제어 파티션( 장치를 제어하기 위해 사용되는 물리적 기능일 수 있음)이 또한 존재할 수 있다. CXL 스위치(10 0)는, 네트워크 또는 패브릭(fabric)에 연결되도록 구성되는 다수의 입출력 포트들을 포함할 수 있다. 예를 들 면 CXL 스위치의 각 입출력 포트는 CXL 인터페이스를 지원하고 CXL 프로토콜을 구현할 수 있다. 일부 실시예들에서, CXL 스위치는 컨트롤 로직, 메모리, 및 컴퓨트 로직을 포함할 수 있다. 컨트롤 로직은, 인터럽트 신호에 응답하여, 특성 데이터를 기초로 인스트럭션 신호를 메모리에 저장 할 수 있다. 예를 들면, 컨트롤 로직은, 제1 내지 제n CXL 프로세싱 장치들(110_1, 110_2, ..., 110_n)로 부터 수신된 복수의 인터럽트 신호들에 응답하여, 복수의 패킷들의 특성 데이터를 기초로 인스트럭션 신호를 메모리에 저장할 수 있다. 메모리는 휘발성 메모리로 구현될 수 있다. 휘발성 메모리는, 예를 들면, SRAM(Static Random Access Memory)을 포함할 수 있으나, 이에 한정되는 것은 아니다. 다른 예를 들면, 휘발성 메모리는, DRAM(Dynamic Random Access Memory), 모바일 DRAM, DDR SDRAM(Double Data Rate Synchronous Dynamic Random Access Memory), LPDDR (Low Power DDR) SDRAM, GDDR (Graphic DDR) SDRAM, RDRAM(Rambus Dynamic Random Access Memory) 등일 수 있다. 메모리는, 제1 내지 제n CXL 프로세싱 장치들(110_1, 110_2, ..., 110_n)로부터 제공된 출력 벡터 데이터를 임시 저장할 수 있다. 메모리는, 컨트롤 로직로부터 제공된 인스트럭션 신호를 임시 저장할 수 있다. 또한, 메모리는 제1 내지 제n CXL 프로세싱 장치들(110_1, 110_2, ..., 110_n)로부터 수신된 복수의 패킷들의 벡터 데이터를 저장할 수 있다. 컴퓨트 로직은, 메모리에 저장된 인스트럭션 신호를 기초로 연산 동작을 확인할 수 있다. 컴퓨트 로 직은, 메모리에 저장된 벡터 데이터에 대해 연산 동작을 수행함으로써, 저장된 벡터 데이터를 동기화 할 수 있다. 컴퓨트 로직은, 연산 동작에 따라 동기화된 벡터 데이터를 생성할 수 있다. 컴퓨트 로직(10 3)은, 동기화된 벡터 데이터를 메모리에 저장할 수 있다. 제1 내지 제n CXL 프로세싱 장치들(110_1, 110_2, ..., 110_n)은 CXL 스위치의 하위에 연결됨으로써, 메 모리 풀로 구성될 수 있다. 제1 내지 제n CXL 프로세싱 장치들(110_1, 110_2, ..., 110_n) 각각은, 입력 벡터 데이터와 부분 행렬의 행렬곱 연산을 수행할 수 있다. 제1 내지 제n CXL 프로세싱 장치들(110_1, 110_2, ..., 110_n) 각각은, 패킷 및 인터럽트 신호를 CXL 스위치에 출력할 수 있다. 패킷은, 출력 벡터 데이터와 특성 데이터를 포함할 수 있다. 하나의 클록 사이클마다 전달되는 데이터의 단위는 패킷으로 지칭될 수 있다. CXL 사 양에 따른 패킷은 플릿(flit, Flow control unIT)으로 지칭될 수도 있다. 패킷은 프로토콜 ID 필드, 복수의 슬 롯들 및 CRC 필드를 포함할 수 있다. 프로토콜 ID는 링크(예, CXL)가 지원하는 다수의 프로토콜을 식별하기 위 한 정보일 수 있다. 슬롯은 적어도 하나의 메시지를 포함하는 영역일 수 있다. 메시지는 유효(valid) 필드, 동 작 코드(opcode) 필드, 어드레스(ADDR) 필드 및 예비(RSVD) 필드 등을 포함할 수 있다. 메시지에 포함되는 필드 의 개수, 필드의 크기 및 필드의 종류는 프로토콜에 따라 상이할 수 있다. 메시지에 포함되는 필드들 각각은 적 어도 하나의 비트를 포함할 수 있다. 유효 필드는 메시지가 유효한 메시지임을 나타내는 1 비트를 포함할 수 있 다. 동작 코드 필드는 메시지에 대응하는 동작을 정의하는 복수의 비트들을 포함할 수 있다. 어드레스 필드는 동작 코드 필드와 관련된 어드레스를 나타내는 복수의 비트들을 포함할 수 있다. 예비 필드는 추가적인 정보가 포함될 수 있는 영역일 수 있다. 따라서, 프로토콜에 의해 메시지에 새롭게 추가되는 정보는 예비 필드에 포함 될 수 있다. CRC 필드는 전송 에러 감지(transmission error detection)를 위해 사용되는 비트들을 포함할 수 있다. 도 2a, 도 2b, 및 도 2c는 본 개시의 예시적인 실시예에 따른 시스템의 동작을 설명하기 위한 도면들이다. 도 2a, 도 2b, 및 도 2c에서 설명의 편의상 복수의 CXL 프로세싱 장치들은 제1 CXL 프로세싱 장치(110_1) 및 제2 CXL 프로세싱 장치(110_2)를 포함하는 것으로 가정한다. 도 2a를 참조하면, 복수의 CXL 프로세싱 장치들 각각은 부분 행렬에 관한 정보를 미리 저장할 수 있다. 예를 들 면, 제1 CXL 프로세싱 장치(110_1)는 제1 부분 행렬에 관한 정보를 저장할 수 있고, 제2 CXL 프로세싱 장 치(110_2)는 제2 부분 행렬에 관한 정보를 저장할 수 있다. 부분 행렬에 관한 정보는, 복수의 CXL 프로세 싱 장치들 각각에 구비된 레지스터에 저장될 수 있다. 일부 실시예들에서, 복수의 CXL 프로세싱 장치들 각각에 저장된 부분 행렬은 인공지능 모델의 가중치 행렬에서 일부분에 해당될 수 있다. 예를 들면, 제1 부분 행렬 과 제2 부분 행렬은 인공지능 모델의 가중치 행렬에서 컬럼 별로 분할된 행렬일 수 있다. 하지만, 이 에 한정되는 것은 아니다. 인공지능 모델은, 예를 들면, GPT-3, GPT-4 등의 LLM(Large Language Model), CNN(Convolution Neural Network), RPN(Region Proposal Network) 등 다양한 종류의 모델들을 포함할 수 있다. 다른 실시예들에서, 복수의 CXL 프로세싱 장치들 각각에 저장된 부분 행렬은 동일할 수 있다. 예를 들면, 제1 부분 행렬과 제2 부분 행렬은 동일할 수 있다. 복수의 CXL 프로세싱 장치들 각각은 부분 행렬과 입력 벡터 데이터의 행렬곱 연산을 수행할 수 있다. 예를 들면, 제1 CXL 프로세싱 장치(110_1)는 제1 부분 행렬과 제1 입력 벡터 데이터의 행렬곱 연산을 수행할 수 있다. 제2 CXL 프로세싱 장치(110_2)는 제2 부분 행렬과 제2 입력 벡터 데이터의 행렬곱 연산을 수행할 수 있다. 입력 벡터 데이터는 벡터 값들을 포함하는 데이터일 수 있다. 입력 벡터 데이터는 임베딩 벡터로 지칭될 수 있다. 일부 실시예들에 따른 부분 행렬이 인공지능 모델의 가중치 행렬의 일부인 경우, 복수의 CXL 프로세싱 장치들 각각에 입력되는 입력 벡터 데이터는 동일할 수 있다. 예를 들면, 제1 입력벡터 데이터와 제2 입력 벡터 데이터는 동일할 수 있다. 다른 실시예들에 따른 부분 행렬이 CXL 프로 세싱 장치마다 동일한 경우, 복수의 CXL 프로세싱 장치들 각각에 입력되는 입력 벡터 데이터는 동일하거나 다를 수 있다. 복수의 CXL 프로세싱 장치들 각각에서 행렬곱 연산이 수행된 경우, 복수의 CXL 프로세싱 장치들 각각에서 출력 벡터 데이터가 생성될 수 있다. 출력 벡터 데이터는 벡터 값들을 포함하는 데이터일 수 있다. 예를 들면, 제1 CXL 프로세싱 장치(110_1)는 제1 출력 벡터 데이터를 생성할 수 있고, 제2 CXL 프로세싱 장치(110_2)는 제 2 출력 벡터 데이터를 생성할 수 있다. 복수의 CXL 프로세싱 장치들 각각은 패킷 및 인터럽트 신호를 CXL 스위치에 전달할 수 있다. 일부 실시예 들에서, 패킷은 출력 벡터 데이터와 특성 데이터를 포함할 수 있다. 특성 데이터는 CXL 스위치에서 동기화 에 필요한 정보를 포함할 수 있다. 동기화에 필요한 정보는 예를 들면, 연산의 종류, 임베딩 벡터(예, 출력 벡 터 데이터)의 길이, 임베딩 벡터의 시작 주소, 각 CXL 프로세싱 장치의 정보(예, ID 등), 모델 정보 등을 포함 할 수 있다. 예를 들면, 제1 CXL 프로세싱 장치(110_1)는 제1 패킷(PKT1) 및 제1 인터럽트 신호(IRT1)를 CXL 스위치에 제공할 수 있다. 제2 CXL 프로세싱 장치(110_2)는 제2 패킷(PKT2) 및 제2 인터럽트 신호(IRT2)를 CXL 스위치에 제공할 수 있다. CXL 스위치는 복수의 CXL 프로세싱 장치들 각각으로부터 패킷 및 인터럽트 신호를 수신할 수 있다. 패킷의 출력 벡터 데이터는 메모리에 저장될 수 있다. 예를 들면, 제1 벡터 데이터(VD1) 및 제2 벡터 데이터(VD 2)가 메모리에 저장될 수 있다. 제1 벡터 데이터(VD1)는 제1 출력 벡터 데이터에 대응되고, 제2 벡터 데이터(VD2)는 제2 출력 벡터 데이터에 대응될 수 있다. CXL 스위치는, 인터럽트 신호에 응답하여, 패킷의 특성 데이터를 기초로 인스트럭션 신호를 생성할 수 있다. 인스트럭션 신호는, 메모리의 주소, 임 베딩 벡터의 길이, 임베딩 벡터의 시작 주소, 연산 정보, 및 모델 정보 등을 포함할 수 있다. 예를 들면, 컨트 롤 로직은 제1 패킷(PKT1)의 제1 특성 데이터를 기초로 제1 인스트럭션 신호(INST1)를 생성하고, 제1 인스 트럭션 신호(INST1)를 메모리에 저장할 수 있다. 예를 들면, 컨트롤 로직은 제2 패킷(PKT2)의 제2 특 성 데이터를 기초로 제2 인스트럭션 신호를 생성하고, 제2 인스트럭션 신호를 메모리에 저장할 수도 있다. 도 2b를 참조하면, 복수의 CXL 프로세싱 장치들, 예를 들면 제1 CXL 프로세싱 장치(110_1) 및 제2 CXL 프로세싱 장치(110_2) 각각은, CXL 스위치로부터 동기화 완료 신호를 수신할 때까지, 대기할 수 있다. CXL 스위치 는 인스트럭션 신호를 기초로 저장된 벡터 데이터에 대한 연산을 수행할 수 있다. 예를 들면, 컨트롤 로직 은 스케줄링 제어 신호(SCNT)를 메모리에 출력할 수 있다. 스케줄링 제어 신호(SCNT)는 메모리 에 저장된 제1 인스트럭션 신호(INST1)를 출력할 것을 지시하는 신호일 수 있다. 메모리는 스케줄링 제어 신호(SCNT)에 응답하여 제1 인스트럭 신호(INST1)를 출력할 수 있다. 한편, 컨트롤 로직은 메모리에 저장된 제1 벡터 데이터(VD1) 및 제2 벡터 데이터(VD2)를 출력하도록 메모리를 제어할 수도 있다. 컴퓨트 로직은 메모리로부터 제1 인스트럭 신호(INST1)를 수신할 수 있다. 그리고, 컴퓨트 로직은 메모 리에 저장된 제1 벡터 데이터(VD1) 및 제2 벡터 데이터(VD2)를 획득할 수 있다. 제1 벡터 데이터(VD1)는 제1 출력 벡터 데이터에 대응되고, 제2 벡터 데이터(VD2)는 제2 출력 벡터 데이터에 대응될 수 있다. 컴퓨트 로직은 제1 인스터럭션 신호(INST1)를 디코딩하여 연산 동작을 확인할 수 있다. 예를 들어, 연산 동작은 합산 동작일 수 있지만, 이에 한정되는 것은 아니며, ADD 연산, MAX 연산 등 다양한 종류를 하나 이상 포함할 수 있다. 도 2b에서 연산 동작은 합산 동작인 것으로 가정한다. 컴퓨트 로직은, 제 1 출력 벡터 데이터 및 제2 출력 벡터 데이터를 연산(예를 들면, 합산)함으로써, 동기화된 벡터 데이 터를 생성할 수 있다. 도 2c를 참조하면, 컴퓨트 로직은, 동기화 완료 신호(SCS) 및 동기화된 벡터 데이터(SVD)를 순차적으로 출 력할 수 있다. 예를 들면, 컴퓨트 로직은, 동기화 완료 신호(SCS)를 먼저 출력할 수 있다. 동기화 완료 신 호(SCS)는 제1 CXL 프로세싱 장치(110_1) 및 제2 CXL 프로세싱 장치(110_2)에 전달될 수 있다. 제1 CXL 프로세 싱 장치(110_1) 및 제2 CXL 프로세싱 장치(110_2)는 동기화 완료 신호(SCS)에 응답하여 벡터 데이터가 동기화된 것을 확인할 수 있다. 한편, 연산 동작이 완료되는 대로, 동기화된 벡터 데이터(SVD)는 복수의 CXL 프로세 싱 장치들 각각에 병렬적으로 전달될 수 있다. 예를 들면, 컴퓨트 로직은, 동기화된 벡터 데이터(SVD)를 메모리에 저장할 수 있다. 컨트롤 로직은 메모리 제어 신호(MCNT)를 메모리에 제공할 수 있다. 메모리 제어 신호(MCNT)는 동기화된 벡터 데이터(SVD)를 출력하도록 메모리를 제어하기 위한 신호일 수 있 다. 메모리는 메모리 제어 신호(MCNT)에 응답하여 동기화된 벡터 데이터(SVD)를 출력할 수 있다. 복수의 CXL 프로세싱 장치들 각각은, 동기화된 벡터 데이터(SVD)를 수신하고, 동기화된 벡터 데이터(SVD)를 이용하여 추가적인 연산을 수행할 수 있다. 일부 실시예들에서, 제1 CXL 프로세싱 장치(110_1) 및 제2 CXL 프로세싱 장치(110_2)는 동기화된 벡터 데이터(SVD)를 기초로 연산을 추가적으로 수행할 수 있다. 예를 들면, 제1 CXL 프로세 싱 장치(110_1) 및 제2 CXL 프로세싱 장치(110_2)는 벡터 데이터의 각 행의 평균을 계산함으로써, 새로운 임베 딩 벡터를 생성할 수 있다. 제1 CXL 프로세싱 장치(110_1) 및 제2 CXL 프로세싱 장치(110_2)는 CXL 호스트(1 0)에 의해 제공된 쿼리에 대한 결과 값을 나타내는 인덱스를 CXL 스위치를 통해 CXL 호스트에 전달할 수 있다. 또한, 제1 CXL 프로세싱 장치(110_1) 및 제2 CXL 프로세싱 장치(110_2)는 행렬 결과 값을 나타내는 데 이터를 CXL 스위치를 통해 CXL 호스트에 전달할 수 있다. 도 3은 본 개시의 예시적인 실시예에 따른 컨트롤 로직을 나타내는 블록도이다. 도 3을 참조하면, 컨트롤 로직은 인터럽트 신호에 응답하여 인터럽트 루틴을 실행할 수 있다. 인터럽트 루 틴은, 패킷에 포함된 동기화에 필요한 정보를 인스트럭션 신호로 인코딩하고, 인코딩된 인스트럭션 신호를 인스 트럭션 큐에 저장하는 일련의 동작을 의미할 수 있다. 이를 위해, 컨트롤 로직은 인터럽트 핸들러, 인코더, 스케줄러, 및 컨트롤러를 포함할 수 있다. 인터럽트 핸들러는, 인터럽트 신호에 응답하여 호출 신호를 출력할 수 있다. 호출 신호는 인코더를 인에이블 하기 위한 신호일 수 있다. 호출 신호는 인코더에 전달될 수 있다. 인코더는, 호출 신호에 응답하여, 특성 데이터로부터 인스트럭션 신호를 인코딩할 수 있다. 그리고, 인코 더는, 인스트럭션 신호를 메모리에 전달할 수 있다. 스케줄러는 메모리를 모니터링하고, 스케줄링 동작을 수행할 수 있다. 스케줄링 동작은, 메모리(10 2)에 저장된 하나 이상의 인스트럭션 신호를 출력하는 순서를 CXL 프로세싱 장치 등의 특성에 따라 결정하고, 출력 순서에 따라서 인스트럭션 신호를 출력하는 것일 수 있다. 메모리에 저장된 인스트럭션 신호는, 스케 줄링 동작에 의해, 메모리에서 컴퓨트 로직으로 출력될 수 있다. 컨트롤러는 메모리를 제어할 수 있다. 예를 들면, 컨트롤러는, 메모리에 저장된 벡터 데이 터(예, 제1 벡터 데이터(VD1) 및 제2 벡터 데이터(VD2))를 출력하도록 메모리를 제어할 수 있다. 예를 들 면, 컨트롤러는, 동기화된 벡터 데이터(SVD)를 복수의 CXL 프로세싱 장치들에 제공하도록 메모리를 제어할 수 있다. 도 4는 본 개시의 예시적인 실시예에 따른 메모리를 나타내는 블록도이다. 도 4를 참조하면, 메모리는, 제1 버퍼 및 제2 버퍼를 포함할 수 있다. 제1 버퍼는, 출력 벡터 데이터(예, 제1 벡터 데이터(VD1) 및 제2 벡터 데이터(VD2)), 및 동기화된 벡터 데 이터(SVD)를 임시적으로 저장할 수 있다. 제1 버퍼는 메모리 버퍼로 지칭될 수 있다. 제2 버퍼는, 인스트럭션 신호를 순차적으로 큐잉(queuing)할 수 있다. 일부 실시예들에서, 제2 버퍼 는, 복수의 엔트리들로 구성되는 큐(또는 인스트럭션 큐)로 구현될 수 있다. 하지만, 이에 한정되는 것은 아니 다. 일부 실시예들에서, 스케줄러는 메모리의 인스트럭션 큐를 모니터링할 수 있다. 도 5는 본 개시의 예시적인 실시예에 따른 컴퓨트 로직을 나타내는 블록도이다. 도 5를 참조하면, 컴퓨트 로직은, 디코더 및 제1 내지 제m 연산 블록들(520_1, 520_2, ..., 520_m) 을 포함할 수 있다. m은 2 이상의 정수일 수 있다. 디코더는, 연산 동작을 확인하기 위해 인스트럭션 신호를 디코딩할 수 있다. 제1 내지 제m 연산 블록들(520_1, 520_2, ..., 520_m) 중 적어도 하나는, 디코딩된 인스트럭션 신호에 따라 연 산 동작을 수행할 수 있다. 제1 내지 제m 연산 블록들(520_1, 520_2, ..., 520_m)은 서로 다른 연산 동작을 수 행하기 위한 하드웨어 로직 연산기로 구현될 수 있다. 제1 내지 제m 연산 블록들(520_1, 520_2, ..., 520_m) 중 적어도 하나는, 동기화된 벡터 데이터(SVD)를 메모리에 전달할 수 있다. 도 6은 본 개시의 예시적인 실시예에 따른 CXL 프로세싱 장치를 나타내는 블록도이다. 도 6을 참조하면, 일부 실시예들에 따른 CXL 프로세싱 장치는 CXL-PNM(Processing-Near Memory)로 구현될 수 있다. CXL-PNM은 LLM 모델 등의 인공지능 모델에서 데이터를 처리하는 데 이용될 수 있다. CXL 프로세싱 장 치는 CXL 컨트롤러, PNM, 인터페이스, 및 복수의 장치 메모리들(620, 630)을 포함할 수 있다. CXL 컨트롤러는 인터페이스를 통해 복수의 장치 메모리들(620, 630)과 통신할 수 있다. CXL 컨트롤러 는 인터페이스를 통해 복수의 장치 메모리들(620, 630) 각각을 제어할 수 있다. PNM은 데이터 처리 동작을 수행할 수 있다. PNM은 행렬 연산 및 벡터 연산을 할 수 있다. 일부 실시 예들에서, PNM은 행렬곱 연산에 필요한 부분 행렬에 관한 정보를 저장하는 레지스터를 포함할 수 있다. PNM은 인터럽트 신호 및 패킷을 CXL 스위치에 전달할 수 있다. 일부 실시예들에서, CXL 컨트롤러 와 PNM은 하나의 반도체 칩에 집적될 수 있으나, 이에 한정되는 것은 아니다. 복수의 장치 메모리들(620, 630), 예를 들면, 휘발성 메모리로 구현될 수 있다. 도 6에 도시된 바와 달리, 다른 실시예들에 따른 CXL 프로세싱 장치는 CXL 기반의 GPU로 구현될 수 있다. 또는, 또 다른 실시예들에 따른 CXL 프로세싱 장치는 FPGA 기반으로 설계된 NPU로도 구현될 수 있다. 도 7a 및 도 7b은 비교예와 본 개시의 예시적인 실시예에 따른 데이터 흐름을 설명하기 위한 도면이다. 구체적 으로, 도 7a는 비교예에 따른 데이터 흐름을 설명하기 위한 도면이고, 도 7b는 본 개시의 예시적인 실시예에 따 른 데이터 흐름을 설명하기 위한 도면이다. 도 7a를 참조하면, CXL-PNM 장치들(721a, 722a, 723a, 724a)은, CXL 스위치(710a)의 하위에 연결됨으로써, 메 모리 풀로 구성될 수 있다. 이에 따라 CXL-PNM 장치들(721a, 722a, 723a, 724a)은, LLM 모델과 같은 인공지능 모델의 벡터 데이터를 병렬적으로 처리할 수 있다. CXL-PNM 장치들(721a, 722a, 723a, 724a) 각각에서 수행되는 처리 동작은, 인공지능 모델의 전체적인 처리 동작의 일부분에 해당될 수 있다. 따라서, CXL-PNM 장치들(721a, 722a, 723a, 724a) 각각에서 처리된 벡터 데이터에 대한 동기화 작업이 필요하다. 이를 위해, CXL-PNM 장치들 (721a, 722a, 723a, 724a) 중 일부 CXL-PNM 장치들(722a, 723a, 724a)은 각자 처리한 벡터 데이터를 패킷에 포 함시키고, 각 패킷을 CXL 스위치(710a)를 거쳐 특정된 CXL-PNM 장치(721a)에 전송할 수 있다. 그리고, 특정된 CXL-PNM 장치(721a)는 수신된 각 패킷을 이용하여 부분적으로 처리된 벡터 데이터를 동기화하고, 동기화된 벡터 데이터를 포함하는 패킷을 CXL 스위치(710a)를 거쳐 일부 CXL-PNM 장치들(722a, 723a, 724a)에 재전송할 수 있 다. 전술한 처리 과정에서, 홉(HOP)이 발생할 수 있다. 홉(HOP)은 컴퓨터 네트워크에서 출발지와 목적지 사이에 위치한 경로의 한 부분이다. 패킷은 브리지, 라우터, 게이트웨이를 거치면서 출발지에서 목적지로 경유하는데, 패킷이 다음 네트워크 장비로 이동할 때마다 홉이 하나 발생한다. 하나의 CXL-PNM 장치에서 CXL 스위치(710a)로 패킷이 이동되는 케이스(또는 경로)에서 홉(HOP)이 발생할 수 있다. 또한, CXL 스위치(710a)에서 하나의 CXL- PNM 장치로 패킷이 이동되는 케이스에서 홉(HOP)이 발생할 수 있고, 따라서, 각 패킷이 일부 CXL-PNM 장치들 (722a, 723a, 724a)에서 CXL 스위치(710a)로 이동될 때, 3개의 홉(HOP)이 발생할 수 있다. 그리고, 각 패킷이 CXL 스위치(710a)에서 특정된 CXL-PNM 장치(721a)로 이동될 때, 3개의 홉(HOP)이 발생할 수 있다. 즉, 패킷들이 일부 CXL-PNM 장치들(722a, 723a, 724a)에서 CXL 스위치(710a)를 거쳐 특정된 CXL-PNM 장치(721a)에 전송될 때, 6개의 홉(HOP)이 발생할 수 있다. 이와 같이, 동기화된 벡터 데이터를 포함하는 패킷이 특정된 CXL-PNM 장 치(721a)에서 일부 CXL-PNM 장치들(722a, 723a, 724a) 각각으로 전송될 때도, 6개의 홉(HOP)이 발생할 수 있다. 도 7a에 따른 패킷 전송 과정에 따르면, 모든 패킷들이 하나의 CXL-PNM 장치(예, 721a)에 전송되면, 각 CXL-PNM 장치 및 CXL 스위치(710a)로 구성되는 경로(path)에서 병목(bottle-neck)이 발생할 수 있다. 한편 도 7b를 참조하면, CXL-PNM 장치들(721b, 722b, 723b, 724b)은, CXL 스위치(710b)의 하위에서 메모리 풀 로 구성됨으로써, 인공지능 모델의 벡터 데이터 (예, 임베딩 벡터)를 부분적으로 및 병렬적으로 처리할 수 있다. 본 개시의 CXL 스위치(710b)는, CXL-PNM 장치들(721b, 722b, 723b, 724b) 대신에, 도 7a의 CXL-PNM 장치 (721a)에서 수행되는 동기화 처리 작업을 수행할 수 있다. 즉, CXL-PNM 장치들(721b, 722b, 723b, 724b) 각각 에서 처리된 벡터 데이터가 CXL 스위치(710b)에 전송되고, CXL 스위치(710b)가 동기화 작업을 수행함으로써 동 기화된 벡터 데이터를 생성하며, 동기화된 벡터 데이터를 CXL-PNM 장치들(721b, 722b, 723b, 724b) 각각에 재전 송할 수 있다. 이에 따르면, 각 패킷이 CXL-PNM 장치들(721b, 722b, 723b, 724b) 각각에서 CXL 스위치(710b)로 전송될 때, 4개의 홉(HOP)이 발생할 수 있다. 그리고, 동기화된 벡터 데이터를 포함하는 패킷이 CXL 스위치 (710b)에서 CXL-PNM 장치들(721b, 722b, 723b, 724b) 각각으로 전송될 때, 4개의 홉(HOP)이 발생할 수 있다. 도 7b에 따른 패킷 전송 과정에 따르면, 도 7a의 비교예 보다 상대적으로 더 적은 홉(HOP)이 발생될 수 있으므 로, 병목(bottle-neck)이 발생하는 것을 줄일 수 있는 효과가 있다. 또한, 각 CXL-PNM 장치와 CXL 스위치 (710b) 간의 경로에서 발생할 수 있는 혼잡(Congestion)을 예방하는 효과가 있다. 또한, 많은 양의 데이터를 처 리하는 상황에서 레이턴시를 줄일 수 있는 효과가 있다. 또한, 많은 양의 데이터를 처리하는 연산이나 복잡한 연산 등에서 데이터를 빠르고 효율적으로 처리하는 효과가 있다. 도 8은 본 개시의 예시적인 실시예에 따른 CXL 스위칭 장치의 동작 방법을 설명하기 위한 흐름도이다. 도 8을 참조하면, 본 개시의 CXL 스위칭 장치의 동작 방법은, 도 1의 CXL 스위치의 동작 방법으로서, 단계 S10, 단계 S20, 및 단계 S30을 포함할 수 있다. 단계 S10에서, CXL 스위칭 장치는 복수의 CXL 프로세싱 장치들 각각으로부터 복수의 패킷들 및 인터럽트 신호를 수신한다. 각 패킷은 벡터 데이터와 특성 데이터를 포함할 수 있다. 일부 실시예들에서, 단계 S10는 제1 CXL 프 로세싱 장치로부터 제1 패킷 및 제1 인터럽트 신호를 수신하는 단계 및 제2 CXL 프로세싱 장치로부터 제2 패킷 및 제2 인터럽트 신호를 수신하는 단계를 포함할 수 있다. 도 2a를 참조하여 예를 들면, CXL 스위치는 제1 CXL 프로세싱 장치(110_1)로부터 제1 패킷(PKT1) 및 제1 인터럽트 신호(IRT1)를 수신한다. 그리고, CXL 스위치 는 제2 CXL 프로세싱 장치(110_2)로부터 제2 패킷(PKT2) 및 제2 인터럽트 신호(IRT2)를 수신한다. 단계 S20에서, CXL 스위칭 장치는, 복수의 패킷들 및 인터럽트 신호를 기초로 벡터 데이터에 대한 연산을 수행 함으로써, 벡터 데이터를 동기화한다. 도 2a 및 도 2b를 참조하여 예를 들면, CXL 스위치는 인터럽트 신호 에 응답하여 인스트럭션 신호를 생성하고, 인스트럭션 신호를 기초로 각 패킷의 벡터 데이터를 연산함으로써 벡 터 데이터를 동기화한다. 단계 S30에서, CXL 스위칭 장치는 동기화된 벡터 데이터를 복수의 CXL 프로세싱 장치들에 출력한다. 도 2c를 참 조하여 예를 들면, 컴퓨트 로직은, 동기화된 벡터 데이터(SVD)를 메모리에 저장한다. 컨트롤 로직 은 메모리 제어 신호(MCNT)를 메모리에 제공한다. 메모리는 메모리 제어 신호(MCNT)에 응답하여 동기화된 벡터 데이터(SVD)를 출력한다. 동기화된 벡터 데이터(SVD)는 제1 CXL 프로세싱 장치(110_1) 및 제2 CXL 프로세싱 장치(110_2)에 병렬적으로 전달된다. 일부 실시예들에서, 본 개시의 CXL 스위칭 장치의 동작 방법은, 동기화 완료 신호를 복수의 CXL 프로세싱 장치 들에 출력하는 단계를 더 포함할 수 있다. 일부 실시예들에서, 동기화 완료 신호를 복수의 CXL 프로세싱 장치들 에 출력하는 단계는 단계 S30 이전에 수행될 수 있다. 도 9는 도 8의 단계 S20의 예시적인 실시예를 설명하기 위한 흐름도이다. 도 9를 참조하면, 단계 S20는, 단계 S210, 단계 S220, 및 단계 S230를 포함할 수 있다. 단계 S210에서, CXL 스위칭 장치는 벡터 데이터를 버퍼한다. 도 2a 및 도 4를 참조하여 예를 들면, 제1 출력 벡 터 데이터에 대응되는 제1 벡터 데이터(VD1)가 제2 버퍼에 저장되고, 제2 출력 벡터 데이터에 대응되는 제2 벡터 데이터(VD2)가 제2 버퍼에 저장된다. 단계 S220에서, CXL 스위칭 장치는, 인터럽트 신호에 응답하여, 특성 데이터를 기초로 인스트럭션 신호를 생성 한다. 도 2a, 및 도 2b를 참조하여 예를 들면, 컨트롤 로직은, 제1 패킷(PKT1)의 제1 특성 데이터를 기초 로 제1 인스트럭션 신호(INST1)를 생성하고, 제1 인스트럭션 신호(INST1)를 메모리에 저장한다. 단계 S230에서, CXL 스위칭 장치는, 인스트럭션 신호에 따라 연산 동작을 수행함으로써, 동기화된 벡터 데이터 를 생성한다. 도 2a, 및 도 2b를 참조하여 예를 들면, 컨트롤 로직은 스케줄링 제어 신호(SCNT)를 메모리 에 출력한다. 메모리는 스케줄링 제어 신호(SCNT)에 응답하여 제1 인스트럭 신호(INST1)를 출력한다. 컨트롤 로직은 메모리에 저장된 제1 벡터 데이터(VD1) 및 제2 벡터 데이터(VD2)를 출력하도록 메모리 를 제어한다. 컴퓨트 로직은 메모리로부터 제1 인스트럭 신호(INST1), 제1 벡터 데이터(VD1), 및 제2 벡터 데이터(VD2)를 수신한다. 컴퓨트 로직은 제1 인스터럭션 신호(INST1)를 디코딩하여 연산 동작 을 확인한다. 컴퓨트 로직은, 제1 출력 벡터 데이터 및 제2 출력 벡터 데이터를 연산(예를 들면, 합산)함으로써, 동기화된 벡터 데이터를 생성한다. 도 10은 도 9의 단계 S220의 예시적인 실시예를 설명하기 위한 흐름도이다. 도 10을 참조하면, 단계 S220은 단계 S221, 단계 S222, 단계 S223, 단계 S224를 포함할 수 있다. 단계 S221에서, CXL 스위칭 장치는, 인터럽트 신호에 응답하여 호출 신호를 출력한다. 단계 S221은 도 3의 인터 럽트 핸들러에 의해 수행될 수 있다. 단계 S222에서, CXL 스위칭 장치는, 호출 신호에 응답하여, 특성 데이터로부터 인스트럭션 신호를 인코딩한다. 단계 S222은 도 3의 인코더에 의해 수행될 수 있다. 단계 S223에서, CXL 스위칭 장치는, 인코딩된 인스트럭션 신호를 큐잉한다. 단계 S223은 도 3의 인코더에 의해 수행될 수 있다.단계 S224에서, CXL 스위칭 장치는, 큐잉된(queued) 인스트럭션 신호를 스케줄링 순서에 따라 출력한다. 단계 S224는 도 3의 스케줄러에 의해 수행될 수 있다. 도 11은 도 9의 단계 S230의 예시적인 실시예를 설명하기 위한 흐름도이다. 도 11을 참조하면, 단계 S230은 단계 S231 및 단계 S232를 포함한다. 단계 S231에서, CXL 스위칭 장치는, 연산 동작을 확인하기 위해 인스트럭션 신호를 디코딩한다. 단계 S231는 도 5의 디코더에 의해 수행될 수 있다. 단계 S232에서, CXL 스위칭 장치는, 디코딩된 인스트럭션 신호에 따라 연산 동작을 수행한다. 단계 S232는 도 5 의 제1 내지 제m 연산 블록들(520_1, 520_2, ..., 520_m) 중 적어도 하나에 의해 수행될 수 있다. 본 개시의 범위 또는 기술적 사상을 벗어나지 않고 본 개시의 구조가 다양하게 수정되거나 변경될 수 있음은 이 분야에 숙련된 자들에게 자명하다. 상술한 내용을 고려하여 볼 때, 만약 본 개시의 수정 및 변경이 아래의 청구 항들 및 동등물의 범주 내에 속한다면, 본 개시가 이 발명의 변경 및 수정을 포함하는 것으로 여겨진다. 이상과 같이 도면과 명세서에서 예시적인 실시예들이 개시되었다. 본 명세서에서 특정한 용어를 사용하여 실시 예들을 설명되었으나, 이는 단지 본 개시의 기술적 사상을 설명하기 위한 목적에서 사용된 것이지 의미 한정이"}
{"patent_id": "10-2023-0108259", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "나 특허청구범위에 기재된 본 개시의 범위를 제한하기 위하여 사용된 것은 아니다. 그러므로 본 기술분야의 통 상의 지식을 가진 자라면 이로부터 다양한 변형 및 균등한 타 실시예가 가능하다는 점을 이해할 것이다. 따라서, 본 개시의 진정한 기술적 보호범위는 첨부된 특허청구범위의 기술적 사상에 의해 정해져야 할 것이다."}
{"patent_id": "10-2023-0108259", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 개시의 예시적인 실시예에 따른 시스템을 나타내는 블록도이다. 도 2a, 도 2b, 및 도 2c는 본 개시의 예시적인 실시예에 따른 시스템의 동작을 설명하기 위한 도면들이다. 도 3은 본 개시의 예시적인 실시예에 따른 컨트롤 로직을 나타내는 블록도이다. 도 4는 본 개시의 예시적인 실시예에 따른 메모리를 나타내는 블록도이다. 도 5는 본 개시의 예시적인 실시예에 따른 컴퓨트 로직을 나타내는 블록도이다. 도 6은 본 개시의 예시적인 실시예에 따른 CXL 프로세싱 장치를 나타내는 블록도이다. 도 7a 및 도 7b은 비교예와 본 개시의 예시적인 실시예에 따른 데이터 흐름을 설명하기 위한 도면이다. 도 8은 본 개시의 예시적인 실시예에 따른 시스템의 동작 방법을 설명하기 위한 흐름도이다. 도 9는 도 8의 단계 S20의 예시적인 실시예를 설명하기 위한 흐름도이다. 도 10은 도 9의 단계 S220의 예시적인 실시예를 설명하기 위한 흐름도이다. 도 11은 도 9의 단계 S230의 예시적인 실시예를 설명하기 위한 흐름도이다."}
