{"patent_id": "10-2007-0128076", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2009-0061177", "출원번호": "10-2007-0128076", "출원인": "한국전자통신연구원", "발명자": "손강민"}}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "멀티 쓰레드 프로그래밍을 수행하기 위한 멀티 쓰레딩 프레임워크로서,특정 어플리케이션으로부터 전달된 단위 작업들을 그 단위 작업에 포함된 단위 작업 정보에 따라 그 처리 순서를 재정의하고, 상기 재정의된 처리 순서에 따라 상기 단위 작업들을 쓰레드 풀에 전달하여 병렬 처리하는 작업스케줄러와,상기 특정 어플리케이션이 수행되는 장치를 검출하여 그 어플리케이션 내부에서 사용되는 리소스를 정의하는 디바이스 나열자와,상기 작업 스케줄러 또는 디바이스 나열자를 통해 수행되는 상기 특정 어플리케이션에 관련된 리소스를 관리하는 리소스 매니저와,상기 특정 어플리케이션에 관련된 각종 기능들을 수행하는 다수의 모듈들을 플러그인 형태로 관리하고, 이러한플러그인 모듈을 상기 작업 스케줄러로 제공하는 플러그인 매니저를 포함하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 멀티 쓰레딩 프레임워크는,상기 멀티 쓰레딩 프레임워크의 메모리 단편화(memory fragmentation)를 포함하는 메모리 관련 문제를 방지하기위한 메모리 관리를 수행하는 메모리 매니저를 더 포함하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항 또는 제 2 항에 있어서,상기 특정 어플리케이션은, 작성된 게임 코드를 이용하여 상기 멀티 쓰레딩 프레임워크에 가상함수(virtualfunction)로 오버라이딩(over-writing)하여 사용하며, 각종 어플리케이션에 대한 초기화, 입력값 갱신, 입력값가공 처리, 상태 업데이트 및 종료와 관련된 기능을 수행하고, 이로부터 필요한 단위 작업을 구성하여 상기 작업 스케줄러로 제공하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 3 항에 있어서,상기 특정 어플리케이션은,상기 멀티 쓰레딩 프레임워크를 기반으로 동작하는 각종 어플리케이션에 대한 초기화 기능을 수행하는 초기화부와,상기 특정 어플리케이션에 대한 각 루프마다 입력값을 갱신하고, 상기 갱신된 입력값을 상기 특정 어플리케이션에 따라 가공 처리하며, 게임 관련 상태의 업데이트를 수행하는 게임 루프부와,상기 특정 어플리케이션의 종료 시 메모리 정리 및 네트워크 접속 종료를 포함하는 종료 프로세스를 처리하는종료부를 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4 항에 있어서,상기 게임 루프부는,- 3 -공개특허 10-2009-0061177상기 특정 어플리케이션에 대한 매 루프마다 사용자의 입력 및 네트워크 입력을 포함하는 입력값을 갱신하는 업데이트 입력부와,상기 업데이트 입력부로부터 수거된 입력값을 어플리케이션에 따라 가공 처리하는 프로세스 입력부와,상기 특정 어플리케이션에 대한 게임 애니메이션, 물리 시뮬레이션, 인공지능 업데이트 및 화면 갱신을 포함하는 게임 관련 상태의 업데이트를 수행하는 게임 업데이트부를 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1 항 또는 제 2 항에 있어서,상기 작업 스케줄러는, 플랫폼의 코어 개수에 따라 싱글 쓰레드 모드 또는 멀티 쓰레드 모드를 수행하는 동적로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 6 항에 있어서,상기 작업 스케줄러는, 상기 싱글 쓰레드 모드에서 기 설정된 프레임율에 따라 런타임 옵션 레벨을 증가 또는감소시킨 후에, 해당 단위 작업의 옵션 레벨과 상기 증가 또는 감소된 런타입 옵션 레벨을 비교하여 상기 단위작업을 수행 또는 취소하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 6 항에 있어서,상기 작업 스케줄러는, 상기 멀티 쓰레드 모드에서 상기 멀티 쓰레딩 프레임워크의 동작 종료, 단위 작업의 유효성 검사 및 입력된 단위 작업의 저장을 수행함과 동시에 작업 큐의 검사, 사용 가능한 쓰레드 존재 여부 체크및 작업 스케줄링을 수행하여 병렬 처리하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 8 항에 있어서,상기 작업 스케줄링은, 기 설정된 프레임율과 CPU 부하에 따라 상기 쓰레드 풀의 용량을 증가 또는 감소시키거나 상기 런타임 옵션 레벨을 증가 또는 감소시킨 후에, 상기 옵션 레벨 및 런타임 옵션 레벨을 비교하여 상기단위 작업을 수행 또는 취소하는 방식으로 수행되는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 9 항에 있어서,상기 단위 작업은, 글로벌 시리얼 번호, 로컬 시리얼 번호, 상기 옵션 레벨 및 정의된 작업 정보를 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 1 항 또는 제 2 항에 있어서,상기 플러그인 모듈은, 상기 단위 작업에 사용하는 기능들을 모듈 단위로 구현 및 배치하여 특정 엔진을 구성하는 것을 특징으로 하는 동적 로드 배런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 11 항에 있어서,상기 플러그인 모듈은,- 4 -공개특허 10-2009-0061177상기 특정 어플리케이션에 대해 DirectX 또는 OpenGL을 포함하는 그래픽 라이브러리를 통해 화면에 폴리곤을 랜더링하는 기능을 수행하는 플러그인과,상기 특정 어플리케이션에 대한 사실적 표현을 수행하도록 물리 시뮬레이션을 담당하는 역할을 수행하는 플러그인과,상기 특정 어플리케이션에 사용되는 NPC(Non-Player Character)의 자동 제어를 수행하는 플러그인과,상기 특정 어플리케이션의 구성을 소스 코드의 수정 없이 외부에서 변형 가능하도록 하는 인터페이스를 제공하고, 스크립트 언어를 사용할 수 있도록 다양한 인터페이스를 지원하는 역할을 수행하는 플러그인과,상기 특정 어플리케이션에 대한 부가 기능들을 정의한 플러그인을 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "멀티 쓰레드 프로그래밍을 수행하기 위한 멀티 쓰레딩 프레임워크를 이용하여 프로세싱을 수행하는 방법으로서,상기 멀티 쓰레딩 프레임워크의 플랫폼의 코어 개수에 따라 싱글 쓰레드 모드 또는 멀티 쓰레드 모드로 절환하는 제 1 단계와,상기 싱글 쓰레드 모드일 경우 기 설정된 프레임율에 따라 런타임 옵션 레벨을 증가 또는 감소시킨 후에, 해당단위 작업의 옵션 레벨과 상기 증가 또는 감소된 런타입 옵션 레벨을 비교하여 상기 단위 작업을 수행 또는 취소하는 제 2 단계와,상기 멀티 쓰레드 모드일 경우 상기 멀티 쓰레딩 프레임워크의 동작 종료, 단위 작업의 입력 유무 검사 및 입력된 단위 작업의 저장을 수행함과 동시에 작업 큐의 검사, 사용 가능한 쓰레드 존재 여부 체크 및 작업 스케줄링을 수행하는 제 3 단계를 포함하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱 방법."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 13 항에 있어서,상기 프로세싱 방법은,상기 제 3 단계 이후에, 상기 기 설정된 프레임율과 CPU 부하에 따라 상기 쓰레드 풀의 용량을 증가 또는 감소시키거나 상기 런타임 옵션 레벨을 증가 또는 감소시킨 후에, 상기 옵션 레벨 및 런타임 옵션 레벨을 비교하여상기 단위 작업을 수행 또는 취소하는 제 4 단계를 더 포함하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱 방법."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 13 항 또는 제 14 항에 있어서,상기 제 1 단계는,상기 멀티 쓰레딩 프레임워크의 초기화 모드에서 특정 어플리케이션이 동작할 경우 현재 플랫폼의 코어 개수를측정하는 1-1단계와,상기 측정된 현재 플랫폼의 코어 개수가 1보다 큰 값인지를 체크하는 1-2단계와,상기 측정된 현재 플랫폼의 코어 개수가 1인 경우 상기싱글 쓰레드 모드로 동작하는 1-3단계와,상기 측정된 현재 플랫폼의 코어 개수가 1보다 큰 값인 경우 상기 특정 어플리케이션이 동작 중인 메인 쓰레드를 제외한 n-1개의 쓰레드를 쓰레드 풀에 생성한 후, 상기 멀티 쓰레드 모드로 동작하는 1-4단계를 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱방법."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "- 5 -공개특허 10-2009-0061177제 13 항 또는 제 14 항에 있어서,상기 제 2 단계는,상기 기 설정된 프레임율에 따라 상기 런타임 옵션 레벨을 증가 또는 감소시킨 후에, 상기 멀티 쓰레딩 프레임워크의 작업 큐에 상기 단위 작업의 입력이 있는지를 체크하는 2-1 단계와,상기 단위 작업의 입력이 있을 경우 해당 단위 작업의 옵션 레벨과 상기 증가 또는 감소시킨 런타임 옵션 레벨을 비교하는 2-2 단계와,상기 단위 작업의 옵션 레벨이 상기 런타임 옵션 레벨을 초과하지 않은 경우 상기 단위 작업을 실행하고, 상기단위 작업의 옵션 레벨이 상기 런타임 옵션 레벨을 초과한 경우 상기 단위 작업을 취소하는 2-3 단계를 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱 방법"}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제 16 항에 있어서,상기 제 2-1 단계는,상기 멀티 쓰레딩 프레임워크의 프레임율이 상기 기 설정된 프레임율보다 낮은지를 체크하는 단계와,상기 프레임율이 낮지 않고, 일정 수준의 프레임율을 유지하면 상기 런타임 옵션 레벨을 증가시키는 단계와,상기 프레임율이 상기 기 설정된 프레임율보다 낮으면 상기 런타임 옵션 레벨을 감소시키는 단계를 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱방법."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제 13 항 또는 제 14 항에 있어서,상기 제 3 단계는,상기 멀티 쓰레딩 프레임워크의 동작 종료 신호 여부를 체크한 후에 상기 동작 종료 신호가 없을 경우 상기 단위 작업의 입력이 있는지를 체크하는 제 3-1 단계와,상기 단위 작업의 입력이 없을 경우 상기 동작 종료 신호 여부의 체크를 재수행하고, 상기 단위 작업의 입력이있을 경우 상기 단위 작업을 작업 큐에 저장하는 제 3-2 단계와,상기 제 3-1 단계 및 제 3-2 단계의 수행과 동시에 상기 작업 큐에 수행될 단위 작업이 있는지를 체크하는 제3-3 단계와,상기 작업 큐에 수행될 단위 작업이 존재할 경우 상기 쓰레드 풀에 사용 가능한 유휴 쓰레드(idle thread)가 있는지를 체크하는 제 3-4 단계와,상기 쓰레드 풀에 사용 가능한 쓰레드가 있을 경우 상기 유휴 쓰레드를 이용하여 작업 스케줄링을 수행하는 제3-5 단계를 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱방법."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 14 항에 있어서,상기 제 4 단계는,상기 멀티 쓰레딩 프레임워크의 프레임율이 상기 기 설정된 프레임율보다 낮은 경우 상기 멀티 쓰레딩 프레임워크의 CPU 부하에 여유가 있는지를 체크하는 제 4-1 단계와,상기 CPU 부하에 여유가 없을 경우 상기 쓰레드 풀의 용량이 '최초 설정된 코어 개수-1'을 초과했는지 체크하는제 4-2 단계와,- 6 -공개특허 10-2009-0061177상기 쓰레드 풀의 용량이 '최초 설정된 코어 개수-1'을 초과하지 않은 경우 상기 런타임 옵션 레벨을 감소시키는 제 4-3 단계와,상기 쓰레드 풀의 용량이 '최초 설정된 코어 개수-1'을 초과한 경우 상기 쓰레드 풀의 용량을 감소시키는 제 4-4 단계와,상기 CPU 부하에 여유가 있을 경우 상기 쓰레드 풀 용량을 증가시키는 제 4-5 단계와,상기 프레임율이 낮지 않고 일정 수준의 프레임율을 유지하는 경우 상기 CPU 부하에 여유가 있을 경우에만 선택적으로 상기 런타임 옵션 레벨을 증가시키는 제 4-6 단계와,상기 옵션 레벨과 상기 증가 또는 감소된 런타임 옵션 레벨을 비교하여 상기 단위 작업을 수행 또는 취소하는제 4-7 단계를 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱방법."}
{"patent_id": "10-2007-0128076", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제 19 항에 있어서,상기 제 4-7 단계는,상기 쓰레드 풀의 용량 및 런타임 옵션 레벨을 조정한 후에 상기 작업 큐에 저장된 상기 단위 작업을 추출하는단계와,상기 추출된 단위 작업의 옵션 레벨이 상기 런타임 옵션 레벨을 초과하는지를 체크하는 단계와,상기 단위 작업의 옵션 레벨이 상기 런타임 옵션 레벨을 초과하지 않은 경우 상기 단위 작업을 유휴 쓰레드에할당하여 수행하는 단계와,상기 단위 작업의 옵션 레벨이 상기 런타임 옵션 레벨을 초과한 경우 상기 단위 작업을 취소하는 단계를 포함하는 것을 특징으로 하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱방법.명 세 서발명의 상세한 설명 기 술 분 야본 발명은 멀티 쓰레딩 프레임워크(Multi-threading Framework)에 관한 것으로, 더욱 상세하게는 싱글 코어 프 <1>로세스를 포함하는 멀티 코어 프로세스 환경에서 동적 로드 밸런싱을 지원하는데 적합한 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크 및 이를 이용한 프로세싱 방법에 관한 것이다.본 발명은 정보통신부 및 정보통신연구진흥원의 IT신성장동력핵심기술개발사업의 일환으로 수행한 연구로부터 <2>도출된 것이다[과제관리번호: 2006-S-044-02, 과제명: 멀티코아 CPU 및 MPU 기반 크로스 플랫폼 게임 기술개발]. 배 경 기 술잘 알려진 바와 같이, 컴퓨터 분야의 기술이 발달함에 따라 하나의 작업뿐만 아니라 다수의 작업을 동시에 실행 <3>해야하는 경우가 빈번하게 발생한다. 예를 들면, 키보드 입력, 모니터 출력, 네트워크 입출력, 파일 저장 등을동시에 처리해야 하게 되는데, 이러한 다중 입출력 처리를 포함하여 동시에 여러 작업을 처리하는 것을 다중 처리(Multiprocessing)라고 한다.이러한 다중 처리는 멀티 태스킹(Multitasking), 다중화(Multiplexing) 등의 방법으로 제공되는데, 전자의 경우 <4>다수의 작업을 다수의 프로세스(또는, 쓰레드)들이 나누어 처리하는 것을 의미하고, 후자의 경우 한 프로세스내에서 다수의 작업을 처리하는 것을 의미한다.특히, 멀티 태스킹은 여러 작업(즉, 태스크)을 병행하여 처리하는 것으로서, 운영체제(OS)는 멀티 태스킹을 위 <5>- 7 -공개특허 10-2009-0061177해 프로세스를 다수 개 실행시키거나(멀티 프로세스) 쓰레드를 다수 개 실행시키는 기법(멀티 쓰레드)을 사용한다.여기에서, 멀티 프로세스는 독립적으로 처리해야할 작업의 수만큼 프로세스를 만들어 작업을 수행하는데, 각 프 <6>로세스들이 독립적으로 작업을 처리하여 구현이 간편하지만 병렬 처리 해야할 작업 수만큼 프로세스를 생성해야하는 단점이 있고, 프로세스가 많이 생성될수록 메모리 사용량이 증가하며, 프로세스 스케줄링 횟수도 많아져프로그램 성능이 떨어지게 된다. 이러한 멀티 프로세스의 다른 문제점은 프로세스들 사이에 데이터를 공유하기위해서는 운영체제의 도움을 받아 프로세스간 통신을 수행해야 하기 때문에 프로그램 구현이 복잡해지는 단점이있다.반면에, 멀티 쓰레드는 프로세스들이 서로 독립적으로 실행되는 것에 비해 프로세스 내에서 독립적으로 실행되 <7>는 작업을 의미하는 것으로, 프로세스 내에서 다수의 쓰레드를 실행시켰을 때 외부에서는 그 쓰레드들 전체가하나의 프로세스처럼 취급되고, 특정 프로세스에서 쓰레드를 생성하면 새로 만들어진 쓰레드는 원래 프로세스의이미지를 복사하여 사용하는 것이 아니라 원래 프로세스 이미지를 같이 사용하며, 같은 프로세스에서 생성된 쓰레드들은 스택(stack)을 제외한 이미지 영역을 서로 공유하기 때문에 쓰레드가 생성되는데 필요한 메모리량은프로세스가 생성되는데 필요로 하는 메모리량보다 상대적으로 훨씬 적고, 쓰레드 생성 시간도 매우 짧으며(프로세스 생성에 비해 상대적으로 수십배 빨리 생성된다), 쓰레드간 스케줄링도 프로세스간 스케줄링보다 상대적으로 빠르게 이루어지는 장점이 있다.한편, 멀티 쓰레드 컴퓨터 자원들을 동적으로 할당하는 종래 기술로서, 2003년 출원된 제0091764호(스레드 유형 <8>에 근거한 컴퓨터 자원의 동적 할당, 2003년 12월 16일 출원됨)에서는 복수의 물리적 부시스템들을 포함하는 멀티 스레드 컴퓨터 자원들에 스레드를 연관된 특정 유형에 근거하여 동적으로 할당하는 장치, 프로그램 제품 및방법이 개시되었는데, 컴퓨터내의 동일한 물리적 부시스템들 내에 존재하는 자원들에 스레드 유형이 할당되어,특정 스레드 유형의 신규 생성된 스레드 및/또는 재활성 스레드들이 그들 각각의 스레드 유형에 할당된 자원에동적으로 할당되도록 해줌으로써, 동일한 유형을 공유하는 스레드들은 컴퓨터의 동일한 물리적 부시스템 내에존재하는 컴퓨터 자원들에 일반적으로 할당되고, 이는 컴퓨터 내에 존재하는 다수의 물리적 부시스템들 간의 상호 트래픽을 줄여주는 기술 사상에 대해 기재하고 있다.또한, 멀티 코어 구조에서의 스레드를 스케줄링하는 종래의 기술로서, 2006년 출원된 제0097396호(멀티코어 구 <9>조에서의 스케줄링, 2006년 10월 2일 출원됨)에서는 멀티 코어 프로세서에서 스레드를 스케줄링하는 방법 및 장치가 개시되었는데, 실행 가능한 트랜잭션들은 하나 이상의 분배 큐와 멀티 레벨 스케줄러를 이용하여 스케줄링되며, 이러한 분배 큐는 실행에 대한 적임의 순서로 실행 가능한 리스트를 열거하며, 멀티 레벨 스케줄러는 다수의 링크된 개별의 실행 가능한 트랜잭션 스케줄러를 포함하고, 이들 각각은 실행을 위한 가장 적임의 실행 가능한 트랜잭션을 결정하는 스케줄링 알고리즘을 포함하며, 가장 적임의 실행 가능한 트랜잭션은 멀티 레벨 스케줄러로부터 하나 이상의 분배 큐로 출력되는 기술 사상에 대해 기재하고 있다. 발명의 내용 해결 하고자하는 과제이와 같이, 종래에는 멀티프로세서 기반에서 하나의 프로세서에 포함된 자원이 다른 프로세서에 할당되는 것을 <10>최소화하여 프로세서간 통신을 최소화하는 기법, 멀티 코어 구조들 내에서 스레드들을 할당하기 위해 사용되는스케줄링에서 유발되는 문제점을 해소하는 기법 등에 관한 기술이 제안되어 있으나, 하드웨어 자원을 최대한 사용해야 하는 예를 들면, 3D 온라인 게임 분야 등에서는 싱글 쓰레드 기반의 프로그래밍에 최적화되어 있어 멀티코어 환경에서는 오히려 프로그램 동작 성능을 감소시키는 요인으로 작용하고 있는 실정이다.이에 따라, 본 발명은 멀티 코어 프로세서의 성능을 향상시킴과 동시에 싱글 코어 및 멀티 코어 프로세서에 적 <11>용하여 멀티 쓰레드 프로그래밍을 수행할 수 있는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크 및 이를 이용한 프로세싱 방법을 제안하고자 한다.또한, 본 발명은 플러그인 기반으로 필요한 기능을 추가 및 제거 가능하도록 함과 동시에, 동적 로드 밸런싱 기 <12>능을 통해 코어의 개수에 관계없이 병렬 처리 기반의 응용 프로그램을 개발할 수 있는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크 및 이를 이용한 프로세싱 방법을 제안하고자 한다. 과제 해결수단- 8 -공개특허 10-2009-0061177일 관점에서 본 발명은, 멀티 쓰레드 프로그래밍을 수행하기 위한 멀티 쓰레딩 프레임워크로서, <13>특정 어플리케이션으로부터 전달된 단위 작업들을 그 단위 작업에 포함된 단위 작업 정보에 따라 그 처리 순서 <14>를 재정의하고, 상기 재정의된 처리 순서에 따라 상기 단위 작업들을 쓰레드 풀에 전달하여 병렬 처리하는 작업스케줄러와, 상기 특정 어플리케이션이 수행되는 장치를 검출하여 그 어플리케이션 내부에서 사용되는 리소스를정의하는 디바이스 나열자와, 상기 작업 스케줄러 또는 디바이스 나열자를 통해 수행되는 상기 특정 어플리케이션에 관련된 리소스를 관리하는 리소스 매니저와, 상기 특정 어플리케이션에 관련된 각종 기능들을 수행하는 다수의 모듈들을 플러그인 형태로 관리하고, 이러한 플러그인 모듈을 상기 작업 스케줄러로 제공하는 플러그인 매니저를 포함하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 제공한다.다른 관점에서 본 발명은, 멀티 쓰레드 프로그래밍을 수행하기 위한 멀티 쓰레딩 프레임워크를 이용하여 프로세 <15>싱을 수행하는 방법으로서, 상기 멀티 쓰레딩 프레임워크의 플랫폼의 코어 개수에 따라 싱글 쓰레드 모드 또는멀티 쓰레드 모드로 절환하는 제 1 단계와, 상기 싱글 쓰레드 모드일 경우 기 설정된 프레임율에 따라 런타임옵션 레벨을 증가 또는 감소시킨 후에, 해당 단위 작업의 옵션 레벨과 상기 증가 또는 감소된 런타입 옵션 레벨을 비교하여 상기 단위 작업을 수행 또는 취소하는 제 2 단계와, 상기 멀티 쓰레드 모드일 경우 상기 멀티 쓰레딩 프레임워크의 동작 종료, 단위 작업의 입력 유무 검사 및 입력된 단위 작업의 저장을 수행함과 동시에 작업큐의 검사, 사용 가능한 쓰레드 존재 여부 체크 및 작업 스케줄링을 수행하는 제 3 단계를 포함하는 동적 로드밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱 방법을 제공한다. 효 과본 발명은, 특정 어플리케이션으로부터 전달된 단위 작업들을 그 단위 작업에 포함된 단위 작업 정보에 따라 그 <16>처리 순서를 재정의하고, 재정의된 처리 순서에 따라 단위 작업들을 쓰레드 풀에 전달하여 병렬 처리하는 작업스케줄러를 포함하는 멀티 쓰레딩 프레임워크를 구현함으로써, 복잡한 멀티 쓰레드 프로그래밍 작업을 간편하게수행할 수 있고, 코어의 개수에 관계없이 동일한 방식으로 프로그래밍 모델을 적용할 수 있으며, 쓰레드 풀의개수, 단위 작업의 옵션 레벨 및 런타임 옵션 레벨을 이용하여 동적 로드 밸런싱 기능을 제공할 수 있다. 발명의 실시를 위한 구체적인 내용본 발명의 기술요지는, 특정 어플리케이션으로부터 전달된 단위 작업들을 그 단위 작업에 포함된 단위 작업 정 <17>보에 따라 그 처리 순서를 재정의하고, 재정의된 처리 순서에 따라 단위 작업들을 쓰레드 풀에 전달하여 병렬처리하는 작업 스케줄러를 포함하는 멀티 쓰레딩 프레임워크를 이용하여 싱글 쓰레드 모드 또는 멀티 쓰레드 모드의 단위 작업을 수행한다는 것이며, 이러한 기술적 수단을 통해 종래 기술에서의 문제점을 해결할 수 있다.이하 첨부된 도면을 참조하여 본 발명의 바람직한 실시 예에 대하여 상세하게 설명한다. <18> 실 시 예도 1은 본 발명의 일 실시 예에 따라 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크의 구성도로서, 게임 <19>어플리케이션부(Game App, 100), 프레임워크부(Framework, 200) 및 플러그인부(Plug-Ins, 300)를 포함한다.도 1을 참조하면, 게임 어플리케이션부(100)는 초기화부(Initialize, 102), 업데이트 입력부(Update Input, <20>104), 프로세스 입력부(106), 게임 업데이트부(Update Game, 108) 및 종료부(Terminate, 110)를 포함하여 사용자가 작성하는 게임 코드로 프레임워크의 기본 구조에 원하는 기능을 가상함수(virtual function)로 오버라이딩(over-writing)하여 사용하며, 기본적인 프레임워크의 기능을 사용하고자 할 경우, 오버라이딩한 함수에서 슈퍼(super 또는 parent) 클래스의 메쏘드(method)를 호출하는 기능을 수행한다.여기에서, 초기화부(102)는 멀티 쓰레딩 프레임워크를 기반으로 동작하는 어플리케이션에 필요한 각종 초기화 <21>기능을 수행하고, 업데이트 입력부(104)는 게임 루프에 포함되어 매 루프마다 사용자의 입력, 네트워크 입력 등의 입력값을 갱신하는 기능을 수행하며, 프로세스 입력부(106)는 업데이트 입력부(104)로부터 수거된 입력값을어플리케이션에 따라 가공 처리(즉, 프로세스)하는 기능을 수행하고, 게임 업데이트부(108)는 게임 애니메이션,물리 시뮬레이션, 인공지능 업데이트, 화면 갱신 등의 게임 관련 상태의 업데이트를 수행하며, 종료부(110)는특정 어플리케이션의 수행을 종료하는 경우, 메모리의 정리, 네트워크 접속 종료 등의 종료 프로세스를 처리한다. 이러한 각각의 수행 모듈에서는 병렬화가 필요한 작업을 단위 작업으로 구성하여 작업 스케줄러(202)에 전달하고, 작업 스케줄러(202)에서는 해당 작업들을 쓰레드 풀로 전달하여 해당 작업들에 대한 병렬 처리를 수행한다. 여기에서, 쓰레드 풀의 상태는 현재 쓰레드 풀 내에 존재하는 쓰레드의 개수로 표현 가능하고, 쓰레드 풀- 9 -공개특허 10-2009-0061177의 개수는 현재 CPU의 코어 개수를 초과하지 않으며, 예를 들어 쿼드 코어 CPU인 경우 코어수(n)는 '2'가 되고,쓰레드 풀의 개수는 '1'이 된다. 한편, HTT(Hyper-Threading Technology) 기술과 같은 SMT(SimultaneousMulti-Threading) 기술이 적용된 프로세서 혹은 어플리케이션의 성격 및 상황에 따라서 쓰레드의 개수를 CPU의코어 개수보다 더 많이 사용할 수도 있다.그리고, 프레임워크부(200)는 작업 스케줄러(Job Scheduler, 202), 디바이스 나열자(Device Enumerator, 204), <22>메모리 매니저(Memory Mgr, 206), 리소스 매니저(Resource Mgr, 208) 및 플러그인 매니저(Plug-In Mgr, 210)를포함하여 병렬 처리를 위한 멀티 쓰레드 기능을 수행하고, 예를 들어 게임 개발에 필요한 기본적인 게임 루프(loop)를 제공하며, 쓰레드 풀(thread pool) 방식으로 쓰레드 관리를 수행하고, 병렬 처리가 필요한 모듈에서단위 작업을 정의하고, 이를 유휴(idle) 상태의 쓰레드에 할당하여 해당 작업을 수행한다.여기에서, 작업 스케줄러(202)는 게임 어플리케이션부(100)의 각 수행 모듈에서 생성한 단위 작업들이 전달되어 <23>이들을 단위 작업에 포함된 단위 작업 정보(예를 들면, 글로벌 시리얼 번호, 로컬 시리얼 번호, 옵션 레벨, 정의된 작업 정보 등)를 사용하여 그 처리 순서를 재정의하고, 재정의된 처리 순서에 따라 쓰레드 풀에 전달하여병렬 작업을 수행하며, 디바이스 나열자(204)는 어플리케이션이 수행되는 하드웨어에서 활용 가능한 장치(예를들면, 네트워크 카드, 비디오 카드, 메모리 크기, CPU 종류 및 개수, 물리 가속 장치 등)를 검출하고 이를 어플리케이션 내부에서 활용 가능한 형태의 리소스로 정의하는 기능을 수행한다.이러한 단위 작업 정보 중에서 옵션 레벨은 게임 어플리케이션 구동 시에 게임의 진행에 필수적인 단위 작업은 <24>1로, 게임의 진행에 영향을 주지 않은 단위 작업은 상대적으로 1보다 큰 값을 설정되는 것을 의미하는데, 이러한 옵션 레벨을 작업 스케줄러(202)가 갖고 있는 런타임 옵션 레벨(Runtime Option Level, 특정 임계값)과 비교하여 초과하는 작업들은 수행하지 않음으로써 동적 로드 밸런싱을 구현할 수 있으며, 중간 옵션 레벨값은 게임의 성격에 맞게 Try & Error 방식으로 조정을 수행할 수 있다.예를 들면, 게임 어플리케이션 개발 시 개발자가 옵션 레벨의 단계를 5단계로 설정한 경우, 게임의 진행에 반드 <25>시 반영되어야 할 단위 작업(예를 들면, 3D 화면을 구성하는 버텍스, 기본 텍스쳐, 기본 그림자, 애니메이션등)은 1로, 게임의 진행에는 영향을 주지 않지만 보다 화려한 효과를 표현하기 위한 작업(예를 들면, 화려한 텍스쳐, 복잡한 그림자, 특수 효과를 위한 파티클, 날씨 효과 등)은 5로 설정한 후에, 게임 실행 시 프레임워크내부에서 구동 옵션 레벨을 3으로 설정하고, 매 프레임마다 FPS(Frame per second, 초당 프레임율), CPU의 사용율 등을 고려하여 런타입 옵션 레벨을 동적으로 업데이트하며, 이러한 런타임 옵션 레벨은 작업 스케줄러(202)에 전달된 단위 작업의 옵션 레벨과 비교하여 런타임 옵션 레벨을 초과하는 옵션 레벨을 갖고 있는 단위 작업은수행을 취소하게 된다.그리고, 메모리 매니저(206)는 게임 어플리케이션부(100)에서 메모리 단편화(memory fragmentation) 등과 같은 <26>메모리 관련 문제를 방지하는 메모리 관리를 수행하며, 리소스 매니저(208)는 디바이스 나열자(204)로부터 검출된 각종 하드웨어 리소스와 게임 어플리케이션부(100)에서 사용하는 게임 관련 리소스(예를 들면, 텍스트, 버텍스, 애니메이션 데이터 등)를 관리하는 역할을 수행하고, 플러그인 매니저(210)는 각종 기능들을 수행하는 관리자들을 플러그인 형태로 관리(예를 들면, 플러그인의 탑재, 구성, 제거 등)하는 기능을 수행한다.한편, 플러그인부(300)는 랜더링부(Rendering, 302, 304), 물리부(Physics. 306), 인공지능부(AI : Artificial <27>Intelligence, 308), 스크립트 매니저(Script Mgr, 310) 및 유틸리티부(Utility, 312)를 포함하여 프레임워크부(200)에서 사용하는 기능들을 모듈 단위로 구현하고, 필요한 기능을 배치하여 예를 들면, 원하는 게임 엔진을구성한다.여기에서, 랜더링부(302, 304)는 DirectX, OpenGL 등과 같은 그래픽 라이브러리를 통해 화면에 폴리곤을 랜더링 <28>하는 기능을 수행하는 플러그인이고, 물리부(306)는 사실적인 표현을 위한 물리 시뮬레이션을 담당하는 역할을수행하는 플러그인이며, 인공지능부(308)는 게임 어플리케이션부(100)에서 사용되는 NPC(Non-Player Character)의 자동 제어를 수행하는 플러그인이고, 스크립트 매니저(310)는 게임 어플리케이션부(100)의 구성을 소스 코드의 수정 없이 외부에서 변형 가능한 인터페이스를 제공하는 역할을 수행하는 플러그인으로, Lua, Python,Rudy 등과 같은 스크립트 언어를 사용할 수 있도록 다양한 인터페이스를 지원하며, 특히 게임 어플리케이션부(100)의 초기화 시 플러그인 매니저(210)에서 플러그인을 실시간으로 구성하기 위해 필요한 요소이다.또한, 유틸리티부(312)는 게임 어플리케이션부(100)에서 사용하는 다양한 부가 기능들을 정의한 플러그인을 의 <29>미한다.한편, 멀티 쓰레딩 프레임워크는 각종 내부 객체를 플랫폼에 맞추어 생성하는 프레임워크 팩토리, 이벤트를 처 <30>- 10 -공개특허 10-2009-0061177리하는 이벤트 핸들러, 쓰레드를 제어하는 쓰레드 관리자, 프레임워크의 각종 기능을 제어하는 프레임워크 인터페이스 및 플랫폼별로 구현되는 프레임워크 구현부를 더 포함할 수 있고, 외부 응용 프로그램은 프레임워크 인터페이스를 상속받아 구현됨으로써, 각종 플러그인을 추가하여 원하는 형태의 게임 엔진을 구성할 수 있다.또한, 멀티 쓰레딩 프레임워크는 플러그인 인터페이스와 작업 스케줄러(202)가 포함되는데, 플러그인 인터페이 <31>스는 각종 기능들을 플러그인 방식으로 연결하여 필요에 따라 특정 플러그인을 추가하는 형태를 가지며, 작업스케줄러(202)에서는 플러그인이나 응용 프로그램에서 병렬 처리가 필요한 작업을 구현하는 기능을 제공하는 것으로, 병렬 처리가 필요한 부분을 단위 작업으로 구현하여 제공하면 그에 따라 병렬 처리를 수행한다.다음에, 상술한 바와 같은 구성을 갖는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크에서 프레임워크의 <32>초기화 시 현재 플랫폼의 개수에 따라 싱글 쓰레드 모드 또는 멀티 쓰레드 모드로 선택 동작하는 과정에 대해설명한다.도 2는 본 발명에 따라 멀티 쓰레딩 프레임워크의 초기화 과정을 도시한 플로우차트이다. <33>도 2를 참조하면, 멀티 쓰레딩 프레임워크의 초기화 모드에서(단계S202), 작업 스케줄러(202)에서는 특정 어플 <34>리케이션이 동작할 경우 현재 플랫폼의 코어 개수를 측정한다(단계S204).그리고, 작업 스케줄러(202)에서는 측정된 현재 플랫폼의 코어 개수가 1보다 큰 값인지를 체크한다(단계S206). <35>상기 단계(S206)에서의 체크 결과, 측정된 현재 플랫폼의 코어 개수가 1보다 큰 값이 아닌 1인 경우 싱글 쓰레 <36>드 모드로 동작하고(단계S208), 측정된 현재 플랫폼의 코어 개수가 1보다 큰 값인 경우 작업 스케줄러(202)에서는 현재 특정 어플리케이션이 동작 중인 메인 쓰레드를 제외한 n-1개의 쓰레드를 쓰레드 풀(thread pool)에 생성한 후(단계S210), 멀티 쓰레드 모드로 동작한다(단계S212). 여기에서, 싱글 쓰레드 모드로 동작할 경우, 즉싱글 코어로 멀티 쓰레딩을 사용하면 콘텍스트 스위칭 등의 영향으로 성능의 저하가 발생할 수 있으며, 쓰레드의 생성 및 관리의 부하를 최소화하기 위해 미리 쓰레드를 생성하고, 이러한 쓰레드를 단위 작업이 발생할 때마다 재활용하는 방식으로 쓰레드 풀을 통해 쓰레드들을 관리할 수 있다. 또한, HTT(Hyper-Threading Technology)기술과 같은 SMT(Simultaneous Multi-Threading) 기술이 적용된 프로세서 혹은 어플리케이션의 성격 및 상황에따라서 쓰레드의 개수를 CPU의 코어 개수보다 더 많이 사용할 수도 있다.다음에, 상술한 바와 같이 멀티 쓰레딩 프레임워크의 초기화 과정을 수행한 후 싱글 코어에 따른 싱글 쓰레드 <37>모드를 수행하는 과정에 대해 설명한다.도 3은 본 발명에 따라 멀티 쓰레딩 프레임워크의 싱글 쓰레드 모드를 수행하는 과정을 도시한 플로우차트이다. <38>도 3을 참조하면, 멀티 쓰레딩 프레임워크의 싱글 쓰레드 모드에서(단계S302), 작업 스케줄러(202)에서는 프레 <39>임워크의 동작 종료 신호가 있는지를 체크한 후에(단계S304), 동작 종료 신호가 있을 경우 프레임워크의 동작을종료하고(단계S306), 동작 종료 신호가 없을 경우 작업 스케줄러(202)에서는 시스템의 프레임율이 F보다 낮은지를 체크한다(단계S308). 여기에서, F는 런타임 옵션 레벨의 증가 또는 감소를 위해 기 설정된 프렘임 기준값을의미하는 것으로, 예를 들면, 30 frame/second, 60 frame/second 등으로 설정될 수 있다.상기 단계(S308)에서의 체크 결과, 시스템의 프레임율이 F보다 낮지 않고 일정 수준의 프레임율을 유지하는 경 <40>우 작업 스케줄러(202)에서는 현재 런타임 옵션 레벨을 증가시키고(단계S310), 시스템의 프레임율이 F보다 낮은경우 작업 스케줄러(202)에서는 현재 런타임 옵션 레벨을 감소시킨다(단계S312). 여기에서, 런타임 옵션 레벨은특정 어플리케이션에 대한 단위 작업에 할당되어 그 작업 순서 및 처리 여부를 판단하기 위한 옵션 레벨과 비교하기 위한 특정 임계값을 의미한다.그리고, 작업 스케줄러(202)에서는 작업 큐 등에 적재되어 단위 작업의 입력이 있는지를 체크한 후에(단계 <41>S314), 단위 작업의 입력이 있을 경우 작업 스케줄러(202)에서는 해당 단위 작업의 옵션 레벨과 현재 증가 또는감소시킨 런타임 옵션 레벨을 비교하여 현재 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과하는지를 체크한다(단계S316).상기 단계(S316)에서의 체크 결과, 현재 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과하지 않은 <42>경우 작업 스케줄러(202)에서는 해당 단위 작업을 실행하고(단계S318), 현재 단위 작업의 옵션 레벨이 시스템의런타임 옵션 레벨을 초과한 경우 작업 스케줄러(202)에서는 해당 단위 작업을 취소한다(단계S320).따라서, 본 발명은 싱글 쓰레드 모드에서 단위 작업의 프레임율에 따라 현재 런타임 옵션 레벨을 증가 또는 감 <43>소시키고, 단위 작업의 입력이 있으면 그 단위 작업의 옵션 레벨과 시스템의 런타임 옵션 레벨을 비교하여 해당- 11 -공개특허 10-2009-0061177단위 작업을 실행 또는 취소할 수 있다.다음에, 멀티 쓰레딩 프레임워크의 멀티 쓰레드 모드에서 프레임워크의 동작 종료, 단위 작업의 입력 유무 검사 <44>및 입력된 단위 작업의 저장을 수행함과 동시에 작업 큐의 검사, 사용 가능한 쓰레드 존재 여부 및 작업 스케줄링을 수행하여 병렬 처리하는 과정에 대해 설명한다.도 4는 본 발명에 따라 멀티 쓰레딩 프레임워크의 멀티 쓰레드 모드를 수행하는 과정을 나타낸 플로우차트이다. <45>도 4를 참조하면, 멀티 쓰레딩 프레임워크의 멀티 쓰레드 모드에서(단계S402), 작업 스케줄러(202)에서는 프레 <46>임워크의 동작 종료 신호가 있는지를 체크한 후에(단계S404), 동작 종료 신호가 없을 경우 작업 스케줄러(202)에서는 단위 작업의 입력이 있는지를 체크하며(단계S406), 단위 작업의 입력이 없을 경우 작업 스케줄러(202)에서는 동작 종료 신호가 있는지를 체크하는 단계S404를 재수행하고, 단위 작업의 입력이 있을 경우 작업 스케줄러(202)에서는 입력된 해당 단위 작업을 작업 큐에 저장(적재)한다(단계S408).한편, 작업 스케줄러(202)에서는 상술한 단계S404 내지 단계S408까지의 과정을 수행함과 동시에 단계S410 내지 <47>단계S414까지의 과정을 동시에 수행하는, 즉 병렬 처리하게 되는데, 작업 스케줄러(202)에서는 작업 큐에 수행될 단위 작업이 있는지, 즉, 작업 큐가 비었는지를 체크한다(단계S410).상기 단계(S410)에서의 체크 결과, 작업 큐에 수행될 단위 작업이 존재할 경우 작업 스케줄러(202)에서는 쓰레 <48>드 풀에 사용 가능한 쓰레드(즉, 유휴 쓰레드, idle thread)가 있는지를 체크하고(단계S412), 쓰레드 풀에 사용가능한 쓰레드가 있을 경우 작업 스케줄러(202)에서는 사용 가능한 쓰레드(유휴 쓰레드)를 이용하여 작업 스케줄링을 수행한다(단계S414).한편, 상술한 본 발명에서는 도 4와 같이 단계별 과정이 완료된 후, 종료하는 것으로 하여 도시하였으나, 동작 <49>종료 체크 단계(S404) 후에 동작 종료 시에만 종료하는 것이며, 그 외의 경우에는 멀티 쓰레드 모드의 과정(즉,병렬 처리 과정)을 지속적으로 수행할 수 있음은 물론이다.따라서, 멀티 쓰레딩 프레임워크의 멀티 쓰레드 모드에서 단위 작업의 입력 유무 검사 후 해당 단위 작업을 작 <50>업 큐에 저장함과 동시에 작업 큐를 검사한 후, 수행될 단위 작업이 있을 경우 사용 가능한 쓰레드가 있는지 체크하여 그에 따라 작업 스케줄링을 수행할 수 있다.다음에, 멀티 쓰레딩 프레임워크의 작업 스케줄링 모드에서 시스템의 프레임율을 체크한 후, CPU 부하에 따라 <51>옵션 레벨 증가, 옵션 레벨 감소 또는 쓰레드 풀 용량 증가를 수행한 후, 작업 큐에서 단위 작업을 추출하고,옵션 레벨과 런타임 옵션 레벨의 비교 결과에 따라 작업을 실행하거나 취소하는 과정에 대해 설명한다.도 5는 본 발명에 따라 멀티 쓰레딩 프레임워크의 작업 스케줄링 모드를 수행하는 과정을 나타낸 플로우차트이 <52>다.도 5를 참조하면, 멀티 쓰레딩 프레임워크의 작업 스케줄링 모드에서(단계S502), 작업 스케줄러(202)에서는 시 <53>스템의 프레임율이 F보다 낮은지를 체크한다(단계S504). 여기에서, F는 런타임 옵션 레벨의 증가 또는 감소를위해 기 설정된 프렘임 기준값을 의미하는 것으로, 예를 들면, 30 frame/second, 60 frame/second 등으로 설정될 수 있다.상기 단계(S504)에서의 체크 결과, 시스템의 프레임율이 F보다 낮은 경우 작업 스케줄러(202)에서는 현재 CPU <54>부하에 여유가 있는지를 체크한 후에(단계S506), CPU 부하에 여유가 없을 경우, 즉 CPU(멀티코어 프로세서에서는 각각의 코어)가 100%활용될 경우 작업 스케줄러(202)에서는 현재 쓰레드 풀의 용량이 '최초 설정된 코어 개수-1(즉, n-1)'을 초과했는지 검사 체크한다(단계S508).상기 단계(S508)에서의 체크 결과 현재 쓰레드 풀의 용량이 '최초 설정된 코어 개수-1'을 초과하지 않은 경우 <55>작업 스케줄러(202)에서는 시스템의 런타임 옵션 레벨을 감소시키며(단계S510), 현재 쓰레드 풀의 용량이 '최초설정된 코어 개수-1'을 초과한 경우 작업 스케줄러(202)에서는 쓰레드 풀의 용량을 감소시킨다(단계S512). 여기에서, 단계 512에서 쓰레드 풀의 용량이 '최초 설정된 코어 개수-1'을 초과하면 현재 시스템의 병렬 처리 용량을 초과하여 사용한 것으로, 이는 멀티 코어 프로세서에서도 콘택스트 스위칭이 발생하여 불필요한 CPU 부하가발생되며, 단계S510에서는 런타임 옵션 레벨을 감소시켜 단위 작업의 수행량을 경감시킬 수 있다. 또한,HTT(Hyper-Threading Technology) 기술과 같은 SMT(Simultaneous Multi-Threading) 기술이 적용된 프로세서 혹은 어플리케이션의 성격 및 상황에 따라서 쓰레드의 개수를 CPU의 코어 개수보다 더 많이 사용할 수도 있다.한편, 상기 단계(S506)에서의 체크 결과, CPU 부하에 여유가 있을 경우, 즉 CPU(멀티코어 프로세서에서는 각각 <56>- 12 -공개특허 10-2009-0061177의 코어)가 100%활용되지 않은 경우 작업 스케줄러(202)에서는 쓰레드 풀 용량을 증가시킨다(단계S514). 여기에서, 단계S514에서는 쓰레드 풀 용량을 증가시켜 단위 작업의 수행량을 증가시킬 수 있다.또한, 상기 단계(504)에서의 체크 결과, 시스템의 프레임율이 F보다 낮지 않고 일정 수준의 프레임율을 유지하 <57>는 경우 작업 스케줄러(202)에서는 CPU 부하를 검사한 후, CPU 부하에 여유가 있을 경우에만 선택적으로 현재런타임 옵션 레벨을 증가시킨다(단계S516). 이러한 런타임 옵션 레벨의 증가는 복잡한 단위 작업을 수행할 수있도록 한다.그리고, 작업 스케줄러(202)에서는 상술한 과정과 같이 쓰레드 풀의 용량과 런타임 옵션 레벨을 조정한 후에 작 <58>업 큐에 저장(적재)된 해당 단위 작업을 추출하고(단계S518), 해당 단위 작업의 옵션 레벨이 시스템의 런타임옵션 레벨을 초과하는지를 체크한다(단계S520).상기 단계(S520)에서의 체크 결과, 해당 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과하지 않은 <59>경우 작업 스케줄러(202)에서는 해당 단위 작업을 유휴 쓰레드에 할당하여 해당 단위 작업을 수행하고(단계S522), 해당 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과한 경우 작업 스케줄러(202)에서는 해당 단위 작업을 취소한다(단계S524).따라서, 멀티 쓰레딩 프레임워크의 작업 스케줄링 모드에서 시스템의 프레임율, CPU 부하 및 쓰레드 풀 용량에 <60>따라 시스템의 런타임 옵션 레벨과 쓰레드 풀 용량을 조정하고, 해당 단위 작업을 추출하여 그 옵션 레벨을 런타임 옵션 레벨과 비교하여 해당 단위 작업을 수행하거나 취소할 수 있다.도 6은 본 발명에 따라 멀티 쓰레딩 프레임워크에서 단위 작업의 구조 및 작업 스케줄링을 예시한 도면이다. <61>도 6을 참조하면, 단위 작업(Unit Job)의 경우 크게 4부분으로 구성되어 있다. 'Global'의 경우 작업 스케줄러 <62>로부터 부여받는 고유번호로 특정 작업 모듈별로 부여받게 되고(번호 27), 'Local'의 경우 해당 모듈내에서 자유롭게 부여하는 시리얼 번호로 단위 작업간의 선후관계를 정의하며(번호 28), 'Option_Level(즉, 옵션 레벨)'의 경우 단위 작업의 복잡도를 나타내며(번호 29), 이는 게임 응용프로그램 개발 단계에서 개발자가 자유롭게설정할 수 있다. 여기에서, 'Unit Job(단위 작업)'은 수행할 작업을 정의(번호 30)하는 것으로 종래 쓰레드 프로그래밍에서의 쓰레드 콜백 함수(thread callback function)에 해당한다.이러한 단위 작업에 대한 작업 스케줄링 방법에 대해 설명하면, 먼저 작업 리스트(job list, 작업 큐)에 저장된 <63>작업을 작업 스케줄러(202)가 글로벌 시리얼 번호(Global)와 로컬 시리얼 번호(Local)를 통하여 꺼내올 수 있는지 판단하고, 마지막으로 단위 작업(Unit Job)의 옵션 레벨(Option_Lever)이 현재 시스템의 런타임 옵션 레벨보다 낮은 경우에만 실제 쓰레드에 할당하여 작업을 수행하게 되는데, 도 6에 도시한 바와 같이 글로벌 시리얼은'0'으로 모두 물리 작업(Physics)을 수행하는 모듈로 가정하였고, 시스템의 런타임 옵션 레벨은 '3'으로 설정된것으로 하여 설명하면, 단위작업을 {글로벌, 로컬, 옵션레벨}로 표시할 경우, 작업 리스트에는 {0,1,1}-{0,2,2}-{0,2,3}-{0,3,4}순으로 저장되어 있으며, {0,1,1}의 경우 이전 작업이 없고, 단위 작업의 옵션 레벨도런타임 옵션 레벨인 3보다 작기 때문에 아무런 제약 없이 유휴 쓰레드(Thread#1)에 할당이 가능하며(번호 31),{0,2,2}의 경우 로컬 시리얼 때문에 {0,1,1}이 완료되어야 유휴 쓰레드에 할당이 가능하고, 단위 작업의 옵션레벨이 런타임 옵션 레벨인 3보다 작기 때문에 {0,0,1}작업이 완료되는 't6' 시점에서 유휴 쓰레드(Thread#1)에할당되며, {0,2,3}의 경우 {0,2,2}와 동일한 로컬 시리얼을 갖고, 단위작업의 옵션 레벨이 런타임 옵션 레벨인3을 초과하지 않기 때문에 동시에 유휴 쓰레드(Thread#2)에 할당이 가능하다. 이때, {0,2,2}와 {0,2,3}작업은동시에 수행된다(32).한편, {0,3,4} 작업의 경우 {0,2,2}와 {0,2,3}작업이 완료되는 't7' 시점에 할당이 가능하지만, 단위작업의 옵 <64>션 레벨이 4로 런타임 옵션 레벨인 3을 초과하므로 {0,3,4} 작업은 취소된다(번호 33).도 7은 본 발명에 따른 멀티 쓰레딩 프레임워크와 일반적인 멀티 쓰레드 프로그래밍 모델을 비교한 도면이다. <65>도 7을 참조하면, 일반적인 멀티쓰레드 프로그래밍 모델에서는 병렬처리 작업의 설계, 쓰레드 생성 API 호출, <66>쓰레드간 경합 방지를 위한 동기화 작업, 쓰레드 관리 API 호출, 수동 로드 밸런싱 등의 작업을 수행해야 하며,특정 플랫폼에 최적화되는 모델로 타 플랫폼에서는 동작 성능의 저하가 발생한다.한편, 본 발명에서 제안하는 쓰레드 풀 기반의 단위작업 프로그래밍 모델은 병렬처리 단위작업 설계, 작업 <67>할당, 자동 쓰레드 관리, 동기화 및 로드 밸런싱의 작업을 수행하며, 특히 작업을 할당한 이후에는 작업 및 쓰레드의 관리가 자동적으로 이루어지며, 본 발명에서 제안하는 작업 스케줄러를 사용할 경우 자동 로드 밸런싱이가능하여 싱글코어와 멀티코어에 동시에 적용이 가능하며 각각의 플랫폼에서 최적화된 성능을 기대할 수 있다.- 13 -공개특허 10-2009-0061177이러한 멀티 쓰레딩 프레임워크는 플랫폼 코어 개수에 관계없이 최적의 동작 성능을 기대할 수 있고, 쓰레드 풀및 옵셥 레벨의 제어를 통하여 동적 로드 밸런싱을 구현하고 있다.이상의 설명에서는 본 발명의 바람직한 실시 예들을 제시하여 설명하였으나 본 발명이 반드시 이에 한정되는 것 <68>은 아니며, 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자라면 본 발명의 기술적 사상을 벗어나지 않는범위 내에서 여러 가지 치환, 변형 및 변경이 가능함을 쉽게 알 수 있을 것이다.도면의 간단한 설명도 1은 본 발명의 일 실시 예에 따라 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크의 구성도, <69>도 2는 본 발명에 따라 멀티 쓰레딩 프레임워크의 초기화 과정을 도시한 플로우차트, <70>도 3은 본 발명에 따라 멀티 쓰레딩 프레임워크의 싱글 쓰레드 모드를 수행하는 과정을 도시한 플로우차트, <71>도 4는 본 발명에 따라 멀티 쓰레딩 프레임워크의 멀티 쓰레드 모드를 수행하는 과정을 나타낸 플로우차트, <72>도 5는 본 발명에 따라 멀티 쓰레딩 프레임워크의 작업 스케줄링 모드를 수행하는 과정을 나타낸 플로우차트, <73>도 6은 본 발명에 따라 멀티 쓰레딩 프레임워크에서 단위 작업의 구조 및작업 스케줄링을 예시한 도면, <74>도 7은 본 발명에 따른 멀티 쓰레딩 프레임워크와 일반적인 멀티 쓰레드 프로그래밍 모델을 비교한 도면. <75><도면의 주요부분에 대한 부호의 설명> <76>100 : 게임 어플리케이션부 200 : 프레임워크부 <77>300 : 플러그인부 202 : 작업 스케줄러 <78>204 : 디바이스 나열자 206 : 메모리 매니저 <79>208 : 리소스 매니저 210 : 플러그인 매니저 <80>도면 도면1- 14 -공개특허 10-2009-0061177 도면2- 15 -공개특허 10-2009-0061177 도면3- 16 -공개특허 10-2009-0061177 도면4- 17 -공개특허 10-2009-0061177 도면5- 18 -공개특허 10-2009-0061177 도면6 도면7- 19 -공개특허 10-2009-0061177"}
{"patent_id": "10-2007-0128076", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크에 관한 것으로, 본 발명은, 특정 어플리케이션 으로부터 전달된 단위 작업들을 그 단위 작업에 포함된 단위 작업 정보에 따라 그 처리 순서를 재정의하고, 재정 의된 처리 순서에 따라 단위 작업들을 쓰레드 풀에 전달하여 병렬 처리하는 작업 스케줄러와, 특정 어플리케이션 이 수행되는 장치를 검출하여 그 어플리케이션 내부에서 사용되는 리소스를 정의하는 디바이스 나열자와, 작업 스케줄러 또는 디바이스 나열자를 통해 수행되는 특정 어플리케이션에 관련된 리소스를 관리하는 리소스 매니저 와, 특정 어플리케이션에 관련된 각종 기능들을 수행하는 다수의 모듈들을 플러그인 형태로 관리하고, 이러한 플 러그인 모듈을 상기 작업 스케줄러로 제공하는 플러그인 매니저를 포함하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 구현함으로써, 병렬 처리 기반의 응용 프로그램 개발 시간 및 비용을 단축하고, 병렬 처리 프레임워크의 재활용성을 극대화할 수 있는 것이다."}
{"patent_id": "10-2007-0128076", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 멀티 쓰레딩 프레임워크(Multi-threading Framework)에 관한 것으로, 더욱 상세하게는 싱글 코어 프 <1> 로세스를 포함하는 멀티 코어 프로세스 환경에서 동적 로드 밸런싱을 지원하는데 적합한 동적 로드 밸런싱을 지 원하는 멀티 쓰레딩 프레임워크 및 이를 이용한 프로세싱 방법에 관한 것이다. 본 발명은 정보통신부 및 정보통신연구진흥원의 IT신성장동력핵심기술개발사업의 일환으로 수행한 연구로부터 <2> 도출된 것이다[과제관리번호: 2006-S-044-02, 과제명: 멀티코아 CPU 및 MPU 기반 크로스 플랫폼 게임 기술 개발]."}
{"patent_id": "10-2007-0128076", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "잘 알려진 바와 같이, 컴퓨터 분야의 기술이 발달함에 따라 하나의 작업뿐만 아니라 다수의 작업을 동시에 실행 <3> 해야하는 경우가 빈번하게 발생한다. 예를 들면, 키보드 입력, 모니터 출력, 네트워크 입출력, 파일 저장 등을 동시에 처리해야 하게 되는데, 이러한 다중 입출력 처리를 포함하여 동시에 여러 작업을 처리하는 것을 다중 처 리(Multiprocessing)라고 한다. 이러한 다중 처리는 멀티 태스킹(Multitasking), 다중화(Multiplexing) 등의 방법으로 제공되는데, 전자의 경우 <4> 다수의 작업을 다수의 프로세스(또는, 쓰레드)들이 나누어 처리하는 것을 의미하고, 후자의 경우 한 프로세스 내에서 다수의 작업을 처리하는 것을 의미한다. 특히, 멀티 태스킹은 여러 작업(즉, 태스크)을 병행하여 처리하는 것으로서, 운영체제(OS)는 멀티 태스킹을 위 <5> - 7 -공개특허 10-2009-0061177해 프로세스를 다수 개 실행시키거나(멀티 프로세스) 쓰레드를 다수 개 실행시키는 기법(멀티 쓰레드)을 사용한 다. 여기에서, 멀티 프로세스는 독립적으로 처리해야할 작업의 수만큼 프로세스를 만들어 작업을 수행하는데, 각 프 <6> 로세스들이 독립적으로 작업을 처리하여 구현이 간편하지만 병렬 처리 해야할 작업 수만큼 프로세스를 생성해야 하는 단점이 있고, 프로세스가 많이 생성될수록 메모리 사용량이 증가하며, 프로세스 스케줄링 횟수도 많아져 프로그램 성능이 떨어지게 된다. 이러한 멀티 프로세스의 다른 문제점은 프로세스들 사이에 데이터를 공유하기 위해서는 운영체제의 도움을 받아 프로세스간 통신을 수행해야 하기 때문에 프로그램 구현이 복잡해지는 단점이 있다. 반면에, 멀티 쓰레드는 프로세스들이 서로 독립적으로 실행되는 것에 비해 프로세스 내에서 독립적으로 실행되 <7> 는 작업을 의미하는 것으로, 프로세스 내에서 다수의 쓰레드를 실행시켰을 때 외부에서는 그 쓰레드들 전체가 하나의 프로세스처럼 취급되고, 특정 프로세스에서 쓰레드를 생성하면 새로 만들어진 쓰레드는 원래 프로세스의 이미지를 복사하여 사용하는 것이 아니라 원래 프로세스 이미지를 같이 사용하며, 같은 프로세스에서 생성된 쓰 레드들은 스택(stack)을 제외한 이미지 영역을 서로 공유하기 때문에 쓰레드가 생성되는데 필요한 메모리량은 프로세스가 생성되는데 필요로 하는 메모리량보다 상대적으로 훨씬 적고, 쓰레드 생성 시간도 매우 짧으며(프로 세스 생성에 비해 상대적으로 수십배 빨리 생성된다), 쓰레드간 스케줄링도 프로세스간 스케줄링보다 상대적으 로 빠르게 이루어지는 장점이 있다. 한편, 멀티 쓰레드 컴퓨터 자원들을 동적으로 할당하는 종래 기술로서, 2003년 출원된 제0091764호(스레드 유형 <8> 에 근거한 컴퓨터 자원의 동적 할당, 2003년 12월 16일 출원됨)에서는 복수의 물리적 부시스템들을 포함하는 멀 티 스레드 컴퓨터 자원들에 스레드를 연관된 특정 유형에 근거하여 동적으로 할당하는 장치, 프로그램 제품 및 방법이 개시되었는데, 컴퓨터내의 동일한 물리적 부시스템들 내에 존재하는 자원들에 스레드 유형이 할당되어, 특정 스레드 유형의 신규 생성된 스레드 및/또는 재활성 스레드들이 그들 각각의 스레드 유형에 할당된 자원에 동적으로 할당되도록 해줌으로써, 동일한 유형을 공유하는 스레드들은 컴퓨터의 동일한 물리적 부시스템 내에 존재하는 컴퓨터 자원들에 일반적으로 할당되고, 이는 컴퓨터 내에 존재하는 다수의 물리적 부시스템들 간의 상 호 트래픽을 줄여주는 기술 사상에 대해 기재하고 있다. 또한, 멀티 코어 구조에서의 스레드를 스케줄링하는 종래의 기술로서, 2006년 출원된 제0097396호(멀티코어 구 <9> 조에서의 스케줄링, 2006년 10월 2일 출원됨)에서는 멀티 코어 프로세서에서 스레드를 스케줄링하는 방법 및 장 치가 개시되었는데, 실행 가능한 트랜잭션들은 하나 이상의 분배 큐와 멀티 레벨 스케줄러를 이용하여 스케줄링 되며, 이러한 분배 큐는 실행에 대한 적임의 순서로 실행 가능한 리스트를 열거하며, 멀티 레벨 스케줄러는 다 수의 링크된 개별의 실행 가능한 트랜잭션 스케줄러를 포함하고, 이들 각각은 실행을 위한 가장 적임의 실행 가 능한 트랜잭션을 결정하는 스케줄링 알고리즘을 포함하며, 가장 적임의 실행 가능한 트랜잭션은 멀티 레벨 스케 줄러로부터 하나 이상의 분배 큐로 출력되는 기술 사상에 대해 기재하고 있다."}
{"patent_id": "10-2007-0128076", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "발명의 내용 해결 하고자하는 과제 이와 같이, 종래에는 멀티프로세서 기반에서 하나의 프로세서에 포함된 자원이 다른 프로세서에 할당되는 것을 <10> 최소화하여 프로세서간 통신을 최소화하는 기법, 멀티 코어 구조들 내에서 스레드들을 할당하기 위해 사용되는 스케줄링에서 유발되는 문제점을 해소하는 기법 등에 관한 기술이 제안되어 있으나, 하드웨어 자원을 최대한 사 용해야 하는 예를 들면, 3D 온라인 게임 분야 등에서는 싱글 쓰레드 기반의 프로그래밍에 최적화되어 있어 멀티 코어 환경에서는 오히려 프로그램 동작 성능을 감소시키는 요인으로 작용하고 있는 실정이다. 이에 따라, 본 발명은 멀티 코어 프로세서의 성능을 향상시킴과 동시에 싱글 코어 및 멀티 코어 프로세서에 적 <11> 용하여 멀티 쓰레드 프로그래밍을 수행할 수 있는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크 및 이 를 이용한 프로세싱 방법을 제안하고자 한다. 또한, 본 발명은 플러그인 기반으로 필요한 기능을 추가 및 제거 가능하도록 함과 동시에, 동적 로드 밸런싱 기 <12> 능을 통해 코어의 개수에 관계없이 병렬 처리 기반의 응용 프로그램을 개발할 수 있는 동적 로드 밸런싱을 지원 하는 멀티 쓰레딩 프레임워크 및 이를 이용한 프로세싱 방법을 제안하고자 한다. 과제 해결수단 - 8 -공개특허 10-2009-0061177일 관점에서 본 발명은, 멀티 쓰레드 프로그래밍을 수행하기 위한 멀티 쓰레딩 프레임워크로서, <13> 특정 어플리케이션으로부터 전달된 단위 작업들을 그 단위 작업에 포함된 단위 작업 정보에 따라 그 처리 순서 <14> 를 재정의하고, 상기 재정의된 처리 순서에 따라 상기 단위 작업들을 쓰레드 풀에 전달하여 병렬 처리하는 작업 스케줄러와, 상기 특정 어플리케이션이 수행되는 장치를 검출하여 그 어플리케이션 내부에서 사용되는 리소스를 정의하는 디바이스 나열자와, 상기 작업 스케줄러 또는 디바이스 나열자를 통해 수행되는 상기 특정 어플리케이 션에 관련된 리소스를 관리하는 리소스 매니저와, 상기 특정 어플리케이션에 관련된 각종 기능들을 수행하는 다 수의 모듈들을 플러그인 형태로 관리하고, 이러한 플러그인 모듈을 상기 작업 스케줄러로 제공하는 플러그인 매 니저를 포함하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 제공한다. 다른 관점에서 본 발명은, 멀티 쓰레드 프로그래밍을 수행하기 위한 멀티 쓰레딩 프레임워크를 이용하여 프로세 <15> 싱을 수행하는 방법으로서, 상기 멀티 쓰레딩 프레임워크의 플랫폼의 코어 개수에 따라 싱글 쓰레드 모드 또는 멀티 쓰레드 모드로 절환하는 제 1 단계와, 상기 싱글 쓰레드 모드일 경우 기 설정된 프레임율에 따라 런타임 옵션 레벨을 증가 또는 감소시킨 후에, 해당 단위 작업의 옵션 레벨과 상기 증가 또는 감소된 런타입 옵션 레벨 을 비교하여 상기 단위 작업을 수행 또는 취소하는 제 2 단계와, 상기 멀티 쓰레드 모드일 경우 상기 멀티 쓰레 딩 프레임워크의 동작 종료, 단위 작업의 입력 유무 검사 및 입력된 단위 작업의 저장을 수행함과 동시에 작업 큐의 검사, 사용 가능한 쓰레드 존재 여부 체크 및 작업 스케줄링을 수행하는 제 3 단계를 포함하는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크를 이용한 프로세싱 방법을 제공한다. 효 과 본 발명은, 특정 어플리케이션으로부터 전달된 단위 작업들을 그 단위 작업에 포함된 단위 작업 정보에 따라 그 <16> 처리 순서를 재정의하고, 재정의된 처리 순서에 따라 단위 작업들을 쓰레드 풀에 전달하여 병렬 처리하는 작업 스케줄러를 포함하는 멀티 쓰레딩 프레임워크를 구현함으로써, 복잡한 멀티 쓰레드 프로그래밍 작업을 간편하게 수행할 수 있고, 코어의 개수에 관계없이 동일한 방식으로 프로그래밍 모델을 적용할 수 있으며, 쓰레드 풀의 개수, 단위 작업의 옵션 레벨 및 런타임 옵션 레벨을 이용하여 동적 로드 밸런싱 기능을 제공할 수 있다. 발명의 실시를 위한 구체적인 내용 본 발명의 기술요지는, 특정 어플리케이션으로부터 전달된 단위 작업들을 그 단위 작업에 포함된 단위 작업 정 <17> 보에 따라 그 처리 순서를 재정의하고, 재정의된 처리 순서에 따라 단위 작업들을 쓰레드 풀에 전달하여 병렬 처리하는 작업 스케줄러를 포함하는 멀티 쓰레딩 프레임워크를 이용하여 싱글 쓰레드 모드 또는 멀티 쓰레드 모 드의 단위 작업을 수행한다는 것이며, 이러한 기술적 수단을 통해 종래 기술에서의 문제점을 해결할 수 있다. 이하 첨부된 도면을 참조하여 본 발명의 바람직한 실시 예에 대하여 상세하게 설명한다. <18> 실 시 예 도 1은 본 발명의 일 실시 예에 따라 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크의 구성도로서, 게임 <19> 어플리케이션부(Game App, 100), 프레임워크부(Framework, 200) 및 플러그인부(Plug-Ins, 300)를 포함한다. 도 1을 참조하면, 게임 어플리케이션부는 초기화부(Initialize, 102), 업데이트 입력부(Update Input, <20> 104), 프로세스 입력부, 게임 업데이트부(Update Game, 108) 및 종료부(Terminate, 110)를 포함하여 사용 자가 작성하는 게임 코드로 프레임워크의 기본 구조에 원하는 기능을 가상함수(virtual function)로 오버라이딩 (over-writing)하여 사용하며, 기본적인 프레임워크의 기능을 사용하고자 할 경우, 오버라이딩한 함수에서 슈퍼 (super 또는 parent) 클래스의 메쏘드(method)를 호출하는 기능을 수행한다. 여기에서, 초기화부는 멀티 쓰레딩 프레임워크를 기반으로 동작하는 어플리케이션에 필요한 각종 초기화 <21> 기능을 수행하고, 업데이트 입력부는 게임 루프에 포함되어 매 루프마다 사용자의 입력, 네트워크 입력 등 의 입력값을 갱신하는 기능을 수행하며, 프로세스 입력부는 업데이트 입력부로부터 수거된 입력값을 어플리케이션에 따라 가공 처리(즉, 프로세스)하는 기능을 수행하고, 게임 업데이트부는 게임 애니메이션, 물리 시뮬레이션, 인공지능 업데이트, 화면 갱신 등의 게임 관련 상태의 업데이트를 수행하며, 종료부는 특정 어플리케이션의 수행을 종료하는 경우, 메모리의 정리, 네트워크 접속 종료 등의 종료 프로세스를 처리한 다. 이러한 각각의 수행 모듈에서는 병렬화가 필요한 작업을 단위 작업으로 구성하여 작업 스케줄러에 전 달하고, 작업 스케줄러에서는 해당 작업들을 쓰레드 풀로 전달하여 해당 작업들에 대한 병렬 처리를 수행 한다. 여기에서, 쓰레드 풀의 상태는 현재 쓰레드 풀 내에 존재하는 쓰레드의 개수로 표현 가능하고, 쓰레드 풀 - 9 -공개특허 10-2009-0061177의 개수는 현재 CPU의 코어 개수를 초과하지 않으며, 예를 들어 쿼드 코어 CPU인 경우 코어수(n)는 '2'가 되고, 쓰레드 풀의 개수는 '1'이 된다. 한편, HTT(Hyper-Threading Technology) 기술과 같은 SMT(Simultaneous Multi-Threading) 기술이 적용된 프로세서 혹은 어플리케이션의 성격 및 상황에 따라서 쓰레드의 개수를 CPU의 코어 개수보다 더 많이 사용할 수도 있다. 그리고, 프레임워크부는 작업 스케줄러(Job Scheduler, 202), 디바이스 나열자(Device Enumerator, 204), <22> 메모리 매니저(Memory Mgr, 206), 리소스 매니저(Resource Mgr, 208) 및 플러그인 매니저(Plug-In Mgr, 210)를 포함하여 병렬 처리를 위한 멀티 쓰레드 기능을 수행하고, 예를 들어 게임 개발에 필요한 기본적인 게임 루프 (loop)를 제공하며, 쓰레드 풀(thread pool) 방식으로 쓰레드 관리를 수행하고, 병렬 처리가 필요한 모듈에서 단위 작업을 정의하고, 이를 유휴(idle) 상태의 쓰레드에 할당하여 해당 작업을 수행한다. 여기에서, 작업 스케줄러는 게임 어플리케이션부의 각 수행 모듈에서 생성한 단위 작업들이 전달되어 <23> 이들을 단위 작업에 포함된 단위 작업 정보(예를 들면, 글로벌 시리얼 번호, 로컬 시리얼 번호, 옵션 레벨, 정 의된 작업 정보 등)를 사용하여 그 처리 순서를 재정의하고, 재정의된 처리 순서에 따라 쓰레드 풀에 전달하여 병렬 작업을 수행하며, 디바이스 나열자는 어플리케이션이 수행되는 하드웨어에서 활용 가능한 장치(예를 들면, 네트워크 카드, 비디오 카드, 메모리 크기, CPU 종류 및 개수, 물리 가속 장치 등)를 검출하고 이를 어플 리케이션 내부에서 활용 가능한 형태의 리소스로 정의하는 기능을 수행한다. 이러한 단위 작업 정보 중에서 옵션 레벨은 게임 어플리케이션 구동 시에 게임의 진행에 필수적인 단위 작업은 <24> 1로, 게임의 진행에 영향을 주지 않은 단위 작업은 상대적으로 1보다 큰 값을 설정되는 것을 의미하는데, 이러 한 옵션 레벨을 작업 스케줄러가 갖고 있는 런타임 옵션 레벨(Runtime Option Level, 특정 임계값)과 비교 하여 초과하는 작업들은 수행하지 않음으로써 동적 로드 밸런싱을 구현할 수 있으며, 중간 옵션 레벨값은 게임 의 성격에 맞게 Try & Error 방식으로 조정을 수행할 수 있다. 예를 들면, 게임 어플리케이션 개발 시 개발자가 옵션 레벨의 단계를 5단계로 설정한 경우, 게임의 진행에 반드 <25> 시 반영되어야 할 단위 작업(예를 들면, 3D 화면을 구성하는 버텍스, 기본 텍스쳐, 기본 그림자, 애니메이션 등)은 1로, 게임의 진행에는 영향을 주지 않지만 보다 화려한 효과를 표현하기 위한 작업(예를 들면, 화려한 텍 스쳐, 복잡한 그림자, 특수 효과를 위한 파티클, 날씨 효과 등)은 5로 설정한 후에, 게임 실행 시 프레임워크 내부에서 구동 옵션 레벨을 3으로 설정하고, 매 프레임마다 FPS(Frame per second, 초당 프레임율), CPU의 사용 율 등을 고려하여 런타입 옵션 레벨을 동적으로 업데이트하며, 이러한 런타임 옵션 레벨은 작업 스케줄러 에 전달된 단위 작업의 옵션 레벨과 비교하여 런타임 옵션 레벨을 초과하는 옵션 레벨을 갖고 있는 단위 작업은 수행을 취소하게 된다. 그리고, 메모리 매니저는 게임 어플리케이션부에서 메모리 단편화(memory fragmentation) 등과 같은 <26> 메모리 관련 문제를 방지하는 메모리 관리를 수행하며, 리소스 매니저는 디바이스 나열자로부터 검출 된 각종 하드웨어 리소스와 게임 어플리케이션부에서 사용하는 게임 관련 리소스(예를 들면, 텍스트, 버텍 스, 애니메이션 데이터 등)를 관리하는 역할을 수행하고, 플러그인 매니저는 각종 기능들을 수행하는 관리 자들을 플러그인 형태로 관리(예를 들면, 플러그인의 탑재, 구성, 제거 등)하는 기능을 수행한다. 한편, 플러그인부는 랜더링부(Rendering, 302, 304), 물리부(Physics. 306), 인공지능부(AI : Artificial <27> Intelligence, 308), 스크립트 매니저(Script Mgr, 310) 및 유틸리티부(Utility, 312)를 포함하여 프레임워크 부에서 사용하는 기능들을 모듈 단위로 구현하고, 필요한 기능을 배치하여 예를 들면, 원하는 게임 엔진을 구성한다. 여기에서, 랜더링부(302, 304)는 DirectX, OpenGL 등과 같은 그래픽 라이브러리를 통해 화면에 폴리곤을 랜더링 <28> 하는 기능을 수행하는 플러그인이고, 물리부는 사실적인 표현을 위한 물리 시뮬레이션을 담당하는 역할을 수행하는 플러그인이며, 인공지능부는 게임 어플리케이션부에서 사용되는 NPC(Non-Player Characte r)의 자동 제어를 수행하는 플러그인이고, 스크립트 매니저는 게임 어플리케이션부의 구성을 소스 코 드의 수정 없이 외부에서 변형 가능한 인터페이스를 제공하는 역할을 수행하는 플러그인으로, Lua, Python, Rudy 등과 같은 스크립트 언어를 사용할 수 있도록 다양한 인터페이스를 지원하며, 특히 게임 어플리케이션부 의 초기화 시 플러그인 매니저에서 플러그인을 실시간으로 구성하기 위해 필요한 요소이다. 또한, 유틸리티부는 게임 어플리케이션부에서 사용하는 다양한 부가 기능들을 정의한 플러그인을 의 <29> 미한다. 한편, 멀티 쓰레딩 프레임워크는 각종 내부 객체를 플랫폼에 맞추어 생성하는 프레임워크 팩토리, 이벤트를 처 <30> - 10 -공개특허 10-2009-0061177리하는 이벤트 핸들러, 쓰레드를 제어하는 쓰레드 관리자, 프레임워크의 각종 기능을 제어하는 프레임워크 인터 페이스 및 플랫폼별로 구현되는 프레임워크 구현부를 더 포함할 수 있고, 외부 응용 프로그램은 프레임워크 인 터페이스를 상속받아 구현됨으로써, 각종 플러그인을 추가하여 원하는 형태의 게임 엔진을 구성할 수 있다. 또한, 멀티 쓰레딩 프레임워크는 플러그인 인터페이스와 작업 스케줄러가 포함되는데, 플러그인 인터페이 <31> 스는 각종 기능들을 플러그인 방식으로 연결하여 필요에 따라 특정 플러그인을 추가하는 형태를 가지며, 작업 스케줄러에서는 플러그인이나 응용 프로그램에서 병렬 처리가 필요한 작업을 구현하는 기능을 제공하는 것으로, 병렬 처리가 필요한 부분을 단위 작업으로 구현하여 제공하면 그에 따라 병렬 처리를 수행한다. 다음에, 상술한 바와 같은 구성을 갖는 동적 로드 밸런싱을 지원하는 멀티 쓰레딩 프레임워크에서 프레임워크의 <32> 초기화 시 현재 플랫폼의 개수에 따라 싱글 쓰레드 모드 또는 멀티 쓰레드 모드로 선택 동작하는 과정에 대해 설명한다. 도 2는 본 발명에 따라 멀티 쓰레딩 프레임워크의 초기화 과정을 도시한 플로우차트이다. <33> 도 2를 참조하면, 멀티 쓰레딩 프레임워크의 초기화 모드에서(단계S202), 작업 스케줄러에서는 특정 어플 <34> 리케이션이 동작할 경우 현재 플랫폼의 코어 개수를 측정한다(단계S204). 그리고, 작업 스케줄러에서는 측정된 현재 플랫폼의 코어 개수가 1보다 큰 값인지를 체크한다(단계S206). <35> 상기 단계(S206)에서의 체크 결과, 측정된 현재 플랫폼의 코어 개수가 1보다 큰 값이 아닌 1인 경우 싱글 쓰레 <36> 드 모드로 동작하고(단계S208), 측정된 현재 플랫폼의 코어 개수가 1보다 큰 값인 경우 작업 스케줄러에서 는 현재 특정 어플리케이션이 동작 중인 메인 쓰레드를 제외한 n-1개의 쓰레드를 쓰레드 풀(thread pool)에 생 성한 후(단계S210), 멀티 쓰레드 모드로 동작한다(단계S212). 여기에서, 싱글 쓰레드 모드로 동작할 경우, 즉 싱글 코어로 멀티 쓰레딩을 사용하면 콘텍스트 스위칭 등의 영향으로 성능의 저하가 발생할 수 있으며, 쓰레드 의 생성 및 관리의 부하를 최소화하기 위해 미리 쓰레드를 생성하고, 이러한 쓰레드를 단위 작업이 발생할 때마 다 재활용하는 방식으로 쓰레드 풀을 통해 쓰레드들을 관리할 수 있다. 또한, HTT(Hyper-Threading Technology) 기술과 같은 SMT(Simultaneous Multi-Threading) 기술이 적용된 프로세서 혹은 어플리케이션의 성격 및 상황에 따라서 쓰레드의 개수를 CPU의 코어 개수보다 더 많이 사용할 수도 있다. 다음에, 상술한 바와 같이 멀티 쓰레딩 프레임워크의 초기화 과정을 수행한 후 싱글 코어에 따른 싱글 쓰레드 <37> 모드를 수행하는 과정에 대해 설명한다. 도 3은 본 발명에 따라 멀티 쓰레딩 프레임워크의 싱글 쓰레드 모드를 수행하는 과정을 도시한 플로우차트이다. <38> 도 3을 참조하면, 멀티 쓰레딩 프레임워크의 싱글 쓰레드 모드에서(단계S302), 작업 스케줄러에서는 프레 <39> 임워크의 동작 종료 신호가 있는지를 체크한 후에(단계S304), 동작 종료 신호가 있을 경우 프레임워크의 동작을 종료하고(단계S306), 동작 종료 신호가 없을 경우 작업 스케줄러에서는 시스템의 프레임율이 F보다 낮은지 를 체크한다(단계S308). 여기에서, F는 런타임 옵션 레벨의 증가 또는 감소를 위해 기 설정된 프렘임 기준값을 의미하는 것으로, 예를 들면, 30 frame/second, 60 frame/second 등으로 설정될 수 있다. 상기 단계(S308)에서의 체크 결과, 시스템의 프레임율이 F보다 낮지 않고 일정 수준의 프레임율을 유지하는 경 <40> 우 작업 스케줄러에서는 현재 런타임 옵션 레벨을 증가시키고(단계S310), 시스템의 프레임율이 F보다 낮은 경우 작업 스케줄러에서는 현재 런타임 옵션 레벨을 감소시킨다(단계S312). 여기에서, 런타임 옵션 레벨은 특정 어플리케이션에 대한 단위 작업에 할당되어 그 작업 순서 및 처리 여부를 판단하기 위한 옵션 레벨과 비교 하기 위한 특정 임계값을 의미한다. 그리고, 작업 스케줄러에서는 작업 큐 등에 적재되어 단위 작업의 입력이 있는지를 체크한 후에(단계 <41> S314), 단위 작업의 입력이 있을 경우 작업 스케줄러에서는 해당 단위 작업의 옵션 레벨과 현재 증가 또는 감소시킨 런타임 옵션 레벨을 비교하여 현재 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과하는지 를 체크한다(단계S316). 상기 단계(S316)에서의 체크 결과, 현재 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과하지 않은 <42> 경우 작업 스케줄러에서는 해당 단위 작업을 실행하고(단계S318), 현재 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과한 경우 작업 스케줄러에서는 해당 단위 작업을 취소한다(단계S320). 따라서, 본 발명은 싱글 쓰레드 모드에서 단위 작업의 프레임율에 따라 현재 런타임 옵션 레벨을 증가 또는 감 <43> 소시키고, 단위 작업의 입력이 있으면 그 단위 작업의 옵션 레벨과 시스템의 런타임 옵션 레벨을 비교하여 해당 - 11 -공개특허 10-2009-0061177단위 작업을 실행 또는 취소할 수 있다. 다음에, 멀티 쓰레딩 프레임워크의 멀티 쓰레드 모드에서 프레임워크의 동작 종료, 단위 작업의 입력 유무 검사 <44> 및 입력된 단위 작업의 저장을 수행함과 동시에 작업 큐의 검사, 사용 가능한 쓰레드 존재 여부 및 작업 스케줄 링을 수행하여 병렬 처리하는 과정에 대해 설명한다. 도 4는 본 발명에 따라 멀티 쓰레딩 프레임워크의 멀티 쓰레드 모드를 수행하는 과정을 나타낸 플로우차트이다. <45> 도 4를 참조하면, 멀티 쓰레딩 프레임워크의 멀티 쓰레드 모드에서(단계S402), 작업 스케줄러에서는 프레 <46> 임워크의 동작 종료 신호가 있는지를 체크한 후에(단계S404), 동작 종료 신호가 없을 경우 작업 스케줄러 에서는 단위 작업의 입력이 있는지를 체크하며(단계S406), 단위 작업의 입력이 없을 경우 작업 스케줄러에 서는 동작 종료 신호가 있는지를 체크하는 단계S404를 재수행하고, 단위 작업의 입력이 있을 경우 작업 스케줄 러에서는 입력된 해당 단위 작업을 작업 큐에 저장(적재)한다(단계S408). 한편, 작업 스케줄러에서는 상술한 단계S404 내지 단계S408까지의 과정을 수행함과 동시에 단계S410 내지 <47> 단계S414까지의 과정을 동시에 수행하는, 즉 병렬 처리하게 되는데, 작업 스케줄러에서는 작업 큐에 수행 될 단위 작업이 있는지, 즉, 작업 큐가 비었는지를 체크한다(단계S410). 상기 단계(S410)에서의 체크 결과, 작업 큐에 수행될 단위 작업이 존재할 경우 작업 스케줄러에서는 쓰레 <48> 드 풀에 사용 가능한 쓰레드(즉, 유휴 쓰레드, idle thread)가 있는지를 체크하고(단계S412), 쓰레드 풀에 사용 가능한 쓰레드가 있을 경우 작업 스케줄러에서는 사용 가능한 쓰레드(유휴 쓰레드)를 이용하여 작업 스케 줄링을 수행한다(단계S414). 한편, 상술한 본 발명에서는 도 4와 같이 단계별 과정이 완료된 후, 종료하는 것으로 하여 도시하였으나, 동작 <49> 종료 체크 단계(S404) 후에 동작 종료 시에만 종료하는 것이며, 그 외의 경우에는 멀티 쓰레드 모드의 과정(즉, 병렬 처리 과정)을 지속적으로 수행할 수 있음은 물론이다. 따라서, 멀티 쓰레딩 프레임워크의 멀티 쓰레드 모드에서 단위 작업의 입력 유무 검사 후 해당 단위 작업을 작 <50> 업 큐에 저장함과 동시에 작업 큐를 검사한 후, 수행될 단위 작업이 있을 경우 사용 가능한 쓰레드가 있는지 체 크하여 그에 따라 작업 스케줄링을 수행할 수 있다. 다음에, 멀티 쓰레딩 프레임워크의 작업 스케줄링 모드에서 시스템의 프레임율을 체크한 후, CPU 부하에 따라 <51> 옵션 레벨 증가, 옵션 레벨 감소 또는 쓰레드 풀 용량 증가를 수행한 후, 작업 큐에서 단위 작업을 추출하고, 옵션 레벨과 런타임 옵션 레벨의 비교 결과에 따라 작업을 실행하거나 취소하는 과정에 대해 설명한다. 도 5는 본 발명에 따라 멀티 쓰레딩 프레임워크의 작업 스케줄링 모드를 수행하는 과정을 나타낸 플로우차트이 <52> 다. 도 5를 참조하면, 멀티 쓰레딩 프레임워크의 작업 스케줄링 모드에서(단계S502), 작업 스케줄러에서는 시 <53> 스템의 프레임율이 F보다 낮은지를 체크한다(단계S504). 여기에서, F는 런타임 옵션 레벨의 증가 또는 감소를 위해 기 설정된 프렘임 기준값을 의미하는 것으로, 예를 들면, 30 frame/second, 60 frame/second 등으로 설정 될 수 있다. 상기 단계(S504)에서의 체크 결과, 시스템의 프레임율이 F보다 낮은 경우 작업 스케줄러에서는 현재 CPU <54> 부하에 여유가 있는지를 체크한 후에(단계S506), CPU 부하에 여유가 없을 경우, 즉 CPU(멀티코어 프로세서에서 는 각각의 코어)가 100%활용될 경우 작업 스케줄러에서는 현재 쓰레드 풀의 용량이 '최초 설정된 코어 개 수-1(즉, n-1)'을 초과했는지 검사 체크한다(단계S508). 상기 단계(S508)에서의 체크 결과 현재 쓰레드 풀의 용량이 '최초 설정된 코어 개수-1'을 초과하지 않은 경우 <55> 작업 스케줄러에서는 시스템의 런타임 옵션 레벨을 감소시키며(단계S510), 현재 쓰레드 풀의 용량이 '최초 설정된 코어 개수-1'을 초과한 경우 작업 스케줄러에서는 쓰레드 풀의 용량을 감소시킨다(단계S512). 여기 에서, 단계 512에서 쓰레드 풀의 용량이 '최초 설정된 코어 개수-1'을 초과하면 현재 시스템의 병렬 처리 용량 을 초과하여 사용한 것으로, 이는 멀티 코어 프로세서에서도 콘택스트 스위칭이 발생하여 불필요한 CPU 부하가 발생되며, 단계S510에서는 런타임 옵션 레벨을 감소시켜 단위 작업의 수행량을 경감시킬 수 있다. 또한, HTT(Hyper-Threading Technology) 기술과 같은 SMT(Simultaneous Multi-Threading) 기술이 적용된 프로세서 혹 은 어플리케이션의 성격 및 상황에 따라서 쓰레드의 개수를 CPU의 코어 개수보다 더 많이 사용할 수도 있다. 한편, 상기 단계(S506)에서의 체크 결과, CPU 부하에 여유가 있을 경우, 즉 CPU(멀티코어 프로세서에서는 각각 <56> - 12 -공개특허 10-2009-0061177의 코어)가 100%활용되지 않은 경우 작업 스케줄러에서는 쓰레드 풀 용량을 증가시킨다(단계S514). 여기에 서, 단계S514에서는 쓰레드 풀 용량을 증가시켜 단위 작업의 수행량을 증가시킬 수 있다. 또한, 상기 단계에서의 체크 결과, 시스템의 프레임율이 F보다 낮지 않고 일정 수준의 프레임율을 유지하 <57> 는 경우 작업 스케줄러에서는 CPU 부하를 검사한 후, CPU 부하에 여유가 있을 경우에만 선택적으로 현재 런타임 옵션 레벨을 증가시킨다(단계S516). 이러한 런타임 옵션 레벨의 증가는 복잡한 단위 작업을 수행할 수 있도록 한다. 그리고, 작업 스케줄러에서는 상술한 과정과 같이 쓰레드 풀의 용량과 런타임 옵션 레벨을 조정한 후에 작 <58> 업 큐에 저장(적재)된 해당 단위 작업을 추출하고(단계S518), 해당 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과하는지를 체크한다(단계S520). 상기 단계(S520)에서의 체크 결과, 해당 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과하지 않은 <59> 경우 작업 스케줄러에서는 해당 단위 작업을 유휴 쓰레드에 할당하여 해당 단위 작업을 수행하고(단계 S522), 해당 단위 작업의 옵션 레벨이 시스템의 런타임 옵션 레벨을 초과한 경우 작업 스케줄러에서는 해 당 단위 작업을 취소한다(단계S524). 따라서, 멀티 쓰레딩 프레임워크의 작업 스케줄링 모드에서 시스템의 프레임율, CPU 부하 및 쓰레드 풀 용량에 <60> 따라 시스템의 런타임 옵션 레벨과 쓰레드 풀 용량을 조정하고, 해당 단위 작업을 추출하여 그 옵션 레벨을 런 타임 옵션 레벨과 비교하여 해당 단위 작업을 수행하거나 취소할 수 있다. 도 6은 본 발명에 따라 멀티 쓰레딩 프레임워크에서 단위 작업의 구조 및 작업 스케줄링을 예시한 도면이다. <61> 도 6을 참조하면, 단위 작업(Unit Job)의 경우 크게 4부분으로 구성되어 있다. 'Global'의 경우 작업 스케줄러 <62> 로부터 부여받는 고유번호로 특정 작업 모듈별로 부여받게 되고(번호 27), 'Local'의 경우 해당 모듈내에서 자 유롭게 부여하는 시리얼 번호로 단위 작업간의 선후관계를 정의하며(번호 28), 'Option_Level(즉, 옵션 레벨)' 의 경우 단위 작업의 복잡도를 나타내며(번호 29), 이는 게임 응용프로그램 개발 단계에서 개발자가 자유롭게 설정할 수 있다. 여기에서, 'Unit Job(단위 작업)'은 수행할 작업을 정의(번호 30)하는 것으로 종래 쓰레드 프 로그래밍에서의 쓰레드 콜백 함수(thread callback function)에 해당한다. 이러한 단위 작업에 대한 작업 스케줄링 방법에 대해 설명하면, 먼저 작업 리스트(job list, 작업 큐)에 저장된 <63> 작업을 작업 스케줄러가 글로벌 시리얼 번호(Global)와 로컬 시리얼 번호(Local)를 통하여 꺼내올 수 있는 지 판단하고, 마지막으로 단위 작업(Unit Job)의 옵션 레벨(Option_Lever)이 현재 시스템의 런타임 옵션 레벨보 다 낮은 경우에만 실제 쓰레드에 할당하여 작업을 수행하게 되는데, 도 6에 도시한 바와 같이 글로벌 시리얼은 '0'으로 모두 물리 작업(Physics)을 수행하는 모듈로 가정하였고, 시스템의 런타임 옵션 레벨은 '3'으로 설정된 것으로 하여 설명하면, 단위작업을 {글로벌, 로컬, 옵션레벨}로 표시할 경우, 작업 리스트에는 {0,1,1}- {0,2,2}-{0,2,3}-{0,3,4}순으로 저장되어 있으며, {0,1,1}의 경우 이전 작업이 없고, 단위 작업의 옵션 레벨도 런타임 옵션 레벨인 3보다 작기 때문에 아무런 제약 없이 유휴 쓰레드(Thread#1)에 할당이 가능하며(번호 31), {0,2,2}의 경우 로컬 시리얼 때문에 {0,1,1}이 완료되어야 유휴 쓰레드에 할당이 가능하고, 단위 작업의 옵션 레벨이 런타임 옵션 레벨인 3보다 작기 때문에 {0,0,1}작업이 완료되는 't6' 시점에서 유휴 쓰레드(Thread#1)에 할당되며, {0,2,3}의 경우 {0,2,2}와 동일한 로컬 시리얼을 갖고, 단위작업의 옵션 레벨이 런타임 옵션 레벨인 3을 초과하지 않기 때문에 동시에 유휴 쓰레드(Thread#2)에 할당이 가능하다. 이때, {0,2,2}와 {0,2,3}작업은 동시에 수행된다. 한편, {0,3,4} 작업의 경우 {0,2,2}와 {0,2,3}작업이 완료되는 't7' 시점에 할당이 가능하지만, 단위작업의 옵 <64> 션 레벨이 4로 런타임 옵션 레벨인 3을 초과하므로 {0,3,4} 작업은 취소된다(번호 33). 도 7은 본 발명에 따른 멀티 쓰레딩 프레임워크와 일반적인 멀티 쓰레드 프로그래밍 모델을 비교한 도면이다. <65> 도 7을 참조하면, 일반적인 멀티쓰레드 프로그래밍 모델에서는 병렬처리 작업의 설계, 쓰레드 생성 API 호출, <66> 쓰레드간 경합 방지를 위한 동기화 작업, 쓰레드 관리 API 호출, 수동 로드 밸런싱 등의 작업을 수행해야 하며, 특정 플랫폼에 최적화되는 모델로 타 플랫폼에서는 동작 성능의 저하가 발생한다. 한편, 본 발명에서 제안하는 쓰레드 풀 기반의 단위작업 프로그래밍 모델은 병렬처리 단위작업 설계, 작업 <67> 할당, 자동 쓰레드 관리, 동기화 및 로드 밸런싱의 작업을 수행하며, 특히 작업을 할당한 이후에는 작업 및 쓰 레드의 관리가 자동적으로 이루어지며, 본 발명에서 제안하는 작업 스케줄러를 사용할 경우 자동 로드 밸런싱이 가능하여 싱글코어와 멀티코어에 동시에 적용이 가능하며 각각의 플랫폼에서 최적화된 성능을 기대할 수 있다. - 13 -공개특허 10-2009-0061177이러한 멀티 쓰레딩 프레임워크는 플랫폼 코어 개수에 관계없이 최적의 동작 성능을 기대할 수 있고, 쓰레드 풀 및 옵셥 레벨의 제어를 통하여 동적 로드 밸런싱을 구현하고 있다. 이상의 설명에서는 본 발명의 바람직한 실시 예들을 제시하여 설명하였으나 본 발명이 반드시 이에 한정되는 것 <68>"}
{"patent_id": "10-2007-0128076", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 3, "content": "은 아니며, 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자라면 본 발명의 기술적 사상을 벗어나지 않는 범위 내에서 여러 가지 치환, 변형 및 변경이 가능함을 쉽게 알 수 있을 것이다."}
