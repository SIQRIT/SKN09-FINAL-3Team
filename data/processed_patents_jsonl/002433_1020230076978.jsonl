{"patent_id": "10-2023-0076978", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0057320", "출원번호": "10-2023-0076978", "발명의 명칭": "다중 정밀도 NPU의 메모리 병목 해결을 위한 블록 기반 GEMM 연산 방법 및 시스템", "출원인": "한양대학교 산학협력단", "발명자": "서지원"}}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "데이터 연산 시스템에 의해 수행되는 블록 기반 연산 방법에 있어서,뉴럴 프로세싱 유닛(Neural Processing Unit)의 메모리 크기와 연산 정밀도에 기초하여 용량 인식 기반의 메모리 할당을 통해 메모리 공간에 데이터를 할당하는 단계; 및 상기 메모리 공간에 저장된 데이터를 이용하여 블록 기반 GEMM(GEneral Matrix Multiplication) 연산을 수행하는 단계 를 포함하는 블록 기반 연산 방법."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 할당하는 단계는,뉴럴 프로세싱 유닛의 메모리 크기에 기초하여 정밀도 및 잔여 로컬 메모리 공간을 조절하여 신경망 모델의 파라미터들을 로컬 메모리에 저장하는 단계를 포함하는 블록 기반 연산 방법."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 할당하는 단계는,상기 뉴럴 프로세싱 유닛에 대해 메모리 트래픽에 대한 바이너리 계산량의 비율을 나타내는 바이너리 연산 강도를 분석하는 단계를 포함하는 블록 기반 연산 방법."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서,상기 저장하는 단계는,데이터 재사용 기회를 증가시키기 위해 잔여 메모리 공간을 사용하여 활성화 및 가중치 파라미터 데이터를 획득하는 단계를 포함하는 블록 기반 연산 방법."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,상기 수행하는 단계는,로컬 메모리에 저장된 활성화 및 가중치 파라미터 데이터를 이용하여 블록 기반 GEMM 연산을 수행하는 단계 를 포함하는 블록 기반 연산 방법."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 수행하는 단계는, 공개특허 10-2024-0057320-3-프리페치(prefetch)를 통해 미리 로드할 수 있는 타일 그룹으로 구성된 블록 그룹을 이용한 블록 기반 스케줄링을 수행하는 단계 를 포함하는 블록 기반 연산 방법."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제5항에 있어서,상기 수행하는 단계는, 실행 연산 및 저장 연산을 타일 그룹당 이중 버퍼링을 적용하고, 로드 연산을 블록 그룹당 이중 버퍼링을 적용하는 단계 를 포함하는 블록 기반 연산 방법."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 뉴럴 프로세싱 유닛은, 다중 정밀도 뉴럴 프로세싱 유닛(Precision-scalable neural processing unit;PSNPU)인 것을 특징으로 하는 블록 기반 연산 방법."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "데이터 연산 시스템에 있어서, 뉴럴 프로세싱 유닛(Neural Processing Unit)의 메모리 크기와 연산 정밀도에 기초하여 용량 인식 기반의 메모리 할당을 통해 메모리 공간에 데이터를 할당하는 데이터 할당부; 및 상기 메모리 공간에 저장된 데이터를 이용하여 블록 기반 GEMM(GEneral Matrix Multiplication) 연산을 수행하는 GEMM 연산부 를 포함하는 데이터 연산 시스템."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 데이터 할당부는,뉴럴 프로세싱 유닛의 메모리 크기에 기초하여 정밀도 및 잔여 로컬 메모리 공간을 조절하여 신경망 모델의 파라미터들을 로컬 메모리에 저장하는 것을 특징으로 하는 데이터 연산 시스템."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서,상기 데이터 할당부는,상기 뉴럴 프로세싱 유닛에 대해 메모리 트래픽에 대한 바이너리 계산량의 비율을 나타내는 바이너리 연산 강도를 분석하는 것을 특징으로 하는 데이터 연산 시스템."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제10항에 있어서,상기 GEMM 연산부는,데이터 재사용 기회를 증가시키기 위해 잔여 메모리 공간을 사용하여 활성화 및 가중치 파라미터 데이터를 획득하는 공개특허 10-2024-0057320-4-것을 특징으로 하는 데이터 연산 시스템."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제9항에 있어서,상기 GEMM 연산부는,로컬 메모리에 저장된 활성화 및 가중치 파라미터 데이터를 이용하여 블록 기반 GEMM 연산을 수행하는 것을 특징으로 하는 데이터 연산 시스템."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서,상기 GEMM 연산부는,프리페치(prefetch)를 통해 미리 로드할 수 있는 타일 그룹으로 구성된 블록 그룹을 이용한 블록 기반 스케줄링을 수행하는 것을 특징으로 하는 데이터 연산 시스템."}
{"patent_id": "10-2023-0076978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제13항에 있어서,상기 GEMM 연산부는,실행 연산 및 저장 연산을 타일 그룹당 이중 버퍼링을 적용하고, 로드 연산을 블록 그룹당 이중 버퍼링을 적용하는 것을 특징으로 하는 데이터 연산 시스템."}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "다중 정밀도 NPU의 메모리 병목 해결을 위한 블록 기반 GEMM 연산 방법 및 시스템이 개시된다. 일 실시예에 따 른 데이터 연산 시스템에 의해 수행되는 블록 기반 연산 방법은, 뉴럴 프로세싱 유닛(Neural Processing Unit)의 메모리 크기와 연산 정밀도에 기초하여 용량 인식 기반의 메모리 할당을 통해 메모리 공간에 데이터를 할당하는 단계; 및 상기 메모리 공간에 저장된 데이터를 이용하여 블록 기반 GEMM(GEneral Matrix Multiplication) 연산 을 수행하는 단계를 포함할 수 있다."}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "아래의 설명은 NPU의 메모리 병목을 해결하기 위한 스케줄링 기술에 관한 것이다."}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능 양자화는 계속해서 증가하는 인공지능 모델 크기를 정확도 손실이 거의 없이 축소시키는 매우 효과적 인 경량화 기법이다. 그리고, 다중 정밀도 NPU(Precision-scalable neural processing unit; PSNPU)는 인공지 능 양자화 기법의 이점을 모두 활용하는 양자화된 인공지능 모델에 특화된 연산기이며, 런타임 내에서 곱셈 정 밀도를 변경할 수 있는 NPU 구조를 통해 높은 정밀도 연산보다 낮은 정밀도 연산으로 더 많은 인자들을 계산하 며, 양자화된 인공지능 모델을 더 적은 소모 전력으로 동작할 수 있을 뿐만 아니라, 더 빨리 계산이 가능하다. 기존에는 NPU 등 병렬 프로세서에서 가용한 모든 자원 활용을 극대화하기 위해 전체 워크로드를 타일로 구분하 여 가용 가능한 연산 코어에 균형적으로 할당하는 타일링 기반 GEMM 연산을 수행하였다. 하지만, 이러한 기존 의 타일 기반 GEMM 연산은 다중 정밀도 NPU의 특성을 고려하지 않아 낮은 정밀도 연산에서 메모리 병목이 심하 고, 따라서 다중 정밀도 NPU의 하드웨어 자원을 모두 활용하지 못했다."}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "낮은 정밀도 연산에서 더 많은 연산할 데이터들을 다중 정밀도 NPU 로컬 메모리에 할당하는 용량 인식 기반의 메모리 할당 방법 및 시스템을 제공할 수 있다. 다중 정밀도 NPU의 메모리 병목을 해결할 수 있는 블록 기반 GEMM 연산 방법 및 시스템을 제공할 수 있다."}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "데이터 연산 시스템에 의해 수행되는 블록 기반 연산 방법은, 뉴럴 프로세싱 유닛(Neural Processing Unit)의 메모리 크기와 연산 정밀도에 기초하여 용량 인식 기반의 메모리 할당을 통해 메모리 공간에 데이터를 할당하는 단계; 및 상기 메모리 공간에 저장된 데이터를 이용하여 블록 기반 GEMM(GEneral Matrix Multiplication) 연산 을 수행하는 단계를 포함할 수 있다. 상기 할당하는 단계는, 뉴럴 프로세싱 유닛의 메모리 크기에 기초하여 정밀도 및 잔여 로컬 메모리 공간을 조절 하여 신경망 모델의 파리미터들을 로컬 메모리에 저장하는 단계를 포함할 수 있다. 상기 할당하는 단계는, 상기 뉴럴 프로세싱 유닛에 대해 메모리 트래픽에 대한 바이너리 계산량의 비율을 나타 내는 바이너리 연산 강도를 분석하는 단계를 포함할 수 있다. 상기 할당하는 단계는, 데이터 재사용 기회를 증가시키기 위해 잔여 메모리 공간을 사용하여 활성화 및 가중치 파라미터 데이터를 획득하는 단계를 포함할 수 있다. 상기 수행하는 단계는, 로컬 메모리에 저장된 활성화 및 가중치 파라미터 데이터를 이용하여 블록 기반 GEMM 연 산을 수행하는 단계를 포함할 수 있다. 상기 수행하는 단계는, 프리페치(prefetch)를 통해 미리 로드할 수 있는 타일 그룹으로 구성된 블록 그룹을 이 용한 블록 기반 스케줄링을 수행하는 단계를 포함할 수 있다. 상기 수행하는 단계는, 실행 연산 및 저장 연산을 타일 그룹당 이중 버퍼링을 적용하고, 로드 연산을 블록 그룹 당 이중 버퍼링을 적용하는 단계를 포함할 수 있다. 상기 뉴럴 프로세싱 유닛은, 다중 정밀도 뉴럴 프로세싱 유닛(Precision-scalable neural processing unit; PSNPU)인 것일 수 있다. 데이터 연산 시스템은, 뉴럴 프로세싱 유닛(Neural Processing Unit)의 메모리 크기와 연산 정밀도에 기초하여 용량 인식 기반의 메모리 할당을 통해 메모리 공간에 데이터를 할당하는 데이터 할당부; 및 상기 메모리 공간에 저장된 데이터를 이용하여 블록 기반 GEMM(GEneral Matrix Multiplication) 연산을 수행하는 GEMM 연산부를 포 함할 수 있다."}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "다중 정밀도 NPU의 낮은 정밀도 연산에서 발생하는 메모리 병목 문제를 해결할 수 있다. 또한, 특정 다중 정밀도 NPU에 국한되지 않고 다양한 구조의 다중 정밀도 NPU에 적용될 수 있다."}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 실시예를 첨부한 도면을 참조하여 상세히 설명한다. 도 1 내지 도 4는 일 실시예에 있어서, 다중 정밀도 NPU를 설명하기 위한 도면이다. 데이터 연산 시스템은 다중 정밀도 NPU에서 사용되는 기존의 스케줄링 기술을 사용하여 메모리 병목 문제를 해 결할 수 있는지 여부와, 해당 문제를 해결하지 못할 경우 메모리 병목 현상을 해결하기 위해 추가로 필요한 온 칩 메모리 크기를 분석할 수 있다. 데이터 연산 시스템은 용량 인식 기반 메모리 할당 및 블록 레벨 스케줄링 과 같은 온칩 스크래치패드 메모리로 메모리 바인드 문제를 최소화하는 새로운 NPU 스케줄링 동작을 제공할 수 있다. 이에, 데이터 재사용을 최대화하고, 효율적인 데이터 프리페치라는 두 가지의 측면에서 성능을 향상시킬 수 있다. 용량 인식 기반 메모리 할당을 사용함으로써 입력 스크래치패드(IS) 메모리의 총 활용도를 높여 온칩 메모리에 더 많은 데이터를 저장할 수 있다. 또한, 용량 인식 기반 메모리 할당을 사용하면 데이터 재사용으로 인해 기준선보다 동일한 수의 연산을 수행하는데 필요한 데이터 이동이 적다. 한편, 블록 레벨 스케줄링은 여 러 단위 연산을 통합하여 데이터 프리패치를 개선할 수 있다. 새로운 NPU 스케줄링 기술의 효과를 평가하기 위해 Gemmini NPU 플랫폼을 사용하여 RISC-V 환경에 다중 정밀도 NPU가 적용될 수 있다. 실시예에서 제안하는 새로운 NPU 스케줄링 동작을 설명하기 전에, 우선적으로 다중 정밀도 NPU에 대하여 설명하 기로 한다. PSMA(Precision-Scalable Multiply-Accumulate)는 정밀도가 감소함에 따라 더 많은 요소 연산을 병렬로 수행하여 심층 신경망(DNN)이 더 적은 에너지로 더 빠르게 처리할 수 있도록 한다. PSMA는 비트 직렬 및 비트 병렬의 두 가지 아키텍처로 분류될 수 있다. 비트 직렬 아키텍처는 단일 MAC(multiply-accumulate) 장 치에서 복수 개의 주기로 복수 개의 요소의 이진 연산을 수행하는 반면, 비트 병렬 아키텍처는 단일 MAC 장치에 서 단일 주기로 복수 개의 저정밀(정밀도가 낮은) MAC를 수행한다. 비트 병렬 아키텍처는 최근 뛰어난 영역 및 에너지 효율성을 보여준 바 있다. 따라서, 본 발명에서는 활성화 및 가중치 파라미터 모두에 대해 8비트, 4비 트 및 2비트 데이터로 작동할 수 있는 비트 병렬 다중 정밀도 NPU에서 하드웨어 리소스를 효율적으로 사용하는 것을 목표로 한다. 도 1은 비트 병렬 PSMA의 프로세싱 요소(PE)를 나타낸 것으로, 하나의 PE는 2×2비트 곱셈 연산을 수행하는 16 비트 브릭(bb)으로 구성되며, 동일한 shift-add 영역에 속하는 비트 브릭이 하나의 활성화와 하나의 가중치를 관리한다. PE의 모든 shift-add 출력이 추가되어 PE 출력이 생성된다. 예를 들어, 활성화가 8비트이고 가중치 정밀도가 2비트(A8W2)인 경우 shift-add 영역은 4비트 브릭으로 그룹화되며 PE 하나가 4개의 (활성화 × 가중치) MAC를 수행할 수 있다. 이 경우, PE에는 사이클당 40비트(활성화: 8비트 × 4 = 32비트, 가중치: 2비 트 × 4 = 8비트)가 필요하다. 따라서, 더 빠른 저정밀 다중 정밀도 NPU 연산을 달성하려면 A8W8에 필요한 16 비트(활성화: 8비트 Х 1 = 8비트, 가중치: 8비트 Х 1 = 8비트)보다 더 많은 데이터를 가져와야 한다. 행렬 곱셈 유닛(Matrix Multiplication Unit; MMU)의 구조는 주로 시스톨릭 공간 배열(TPU 유사)과 병렬 벡터 엔진(NVDLA 유사)로 분류된다. TPU와 유사한 NPU는 NVDLA와 유사한 NPU보다 높은 클럭 주파수를 나타낼 수 있 으며, 높은 면적 오버헤드로 더 많은 전력을 소비할 수 있다. 따라서, 병렬 벡터 엔진 아키텍처는 많은 모바일 NPU와 해당 다중 정밀도 NPU에 사용되어 왔다. 병렬 벡터 엔진은 MMU에 의해 계산된 부분 합계를 재활용하기 위해 별도의 누적 스크래치 패드(Accumulative Scratchpad; AccS)가 있는 가중치 고정 데이터 흐름으로 연산한 다. Gemmini는 RISC-V 환경에서 하드웨어와 소프트웨어 스택을 제공하는 오픈 소스 NPU 프레임워크이다. SoC 환경 에서 효과적인 데이터 액세스 지연 시간 은닉을 위해 Gemmini는 격리된 실행 액세스, 이중 버퍼링, 예약 스테이 션 및 캐시 버스트와 같은 많은 아키텍처 기술을 지원하도록 설계되었다. Gemmini는 세 가지 유형의 하위 레벨 명령어(insts)(로드 (LD), 실행(EX), 저장(ST))를 제공하며, 연산당 여러 하위 레벨 명령어(low-insts)를 실행 하여 명령어 페치를 줄일 수 있다. 이러한 명령어는 예약 스테이션의 종속성 검사와 이중 버퍼링을 사용하여 별 도로 수행할 수 있다. 도 4는 A8W8 동작에 대한 타일 명령 실행의 예를 보여준다. 각 LD, EX, ST 타일은 여러 개의 하위 레벨 명령어 로 구성된다. 또한, 타일 그룹은 EX 타일과 EX 타일에 종속된 다른 타일(LD 및 ST 타일)로 구성된다. 타일 그 룹은 타일 명령어(tile-inst)의 형태로 실행될 수 있으며 병렬로 실행될 수 있다. 도 4에서는 LD, EX, ST 타일 의 밝기로 서로 다른 인접 타일 명령이 구분된다. 입력 스크래치패드(IS)에 두 개의 버퍼(이중 버퍼)를 할당하 면 현재 타일 그룹의 EX 타일과 다음 타일 그룹의 LD 타일이 동시에 실행된다.Gemmini의 효과적인 데이터 액세스 지연 시간 은닉의 이점을 활용하기 위해, Gemmini 아키텍처는 도 2와 같이 다중 정밀도 NPU용으로 재설계될 수 있다. 실시예에서 구성된 다중 정밀도 NPU는 Bitblade 아키텍처를 포함하 는 MMU로 구성되며 활성화 및 가중치 모두에 대해 8비트, 4비트, 2비트 연산을 제공한다. 9가지 연산 모드가 있다. 또한, MMU 작동을 제어하는 EX 하위 레벨 명령어는 활성화와 가중치의 정밀도가 지정될 수 있다. 정밀 도가 낮은 연산에서 액세스할 여러 입력 스크래치패드(IS) 행 주소를 공유하여 명령어의 길이를 줄일 수 있다. 데이터 연산 시스템은 다중 정밀도가 낮은 연산을 지원하기 위해 입력 스크래치패드(IS) 내 뱅크 수를 증가시키 고 입력 스크래치패드(IS)를 효율적으로 사용하기 위해 복수 개의 작은 비트 폭 데이터를 8비트 데이터로 압축 하여 저장할 수 있다. 구체적으로, 입력 스크래치패드(IS) 내 뱅크 수를 4개에서 16개로 증가시키고, 활성화와 가중치를 위한 입력 스크래치패드(IS) 영역을 활성화 및 가중치 데이터가 동일한 뱅크에 저장될 때 일반적으로 발생하는 뱅크 충돌을 피하기 위해 분리할 수 있다. 또한, 데이터 연산 시스템은 8비트 폭으로 요소를 사전 압 축하고 8비트, 4비트 또는 2비트 정밀도 중 하나로 압축하여 부분 합(Psum)으로 DRAM에 저장하여 8비트 입력 스 크래치패드(IS) 저장 공간과 DRAM 대역폭을 효과적으로 사용할 수 있다. 그러나, 정밀도가 낮은 연산에서 부분 합(Psum)의 비트 폭을 줄일 수 있다고 하더라도, 정밀도가 낮은 연산에서 AccS의 여분의 메모리 공간이 입력 스 크래치패드(IS)의 여분의 메모리 공간만큼 크지 않기 때문에 합계는 원래 Gemmini와 동일한 32비트 데이터로 저 장될 수 있다. 또한 AccS의 추가 메모리 공간을 활용하려면 메모리 컨트롤러에 더 많은 뱅크와 같은 추가 하드 웨어 로직 오버헤드가 있어야 한다. 실시예에서는 다중 정밀도 NPU의 메모리 병목을 해결할 수 있는 블록 기반 GEMM연산 기법을 통해 다중 정밀도 NPU의 로컬 메모리 사용률을 높여 연산 강도를 높이고, 제한된 메모리 대역폭을 효과적으로 활용하는 동작에 대 하여 설명하기로 한다. 실시예에 따르면, 기존 타일링 기반 GEMM 연산으로 해결하지 못하던 메모리 병목 문제 를, 다중 정밀도 NPU 특성에 최적화된 블록 기반 GEMM 연산을 통해 해결하므로, 기존 기술을 대체하는 대안으로 써 작용할 수 있음을 밝힌다. 도 5는 일 실시예에 있어서, 데이터 연산 시스템의 하드웨어 구성을 설명하기 위한 블록도이고, 도 6은 일 실시 예에 있어서, 블록 기반 연산 방법을 설명하기 위한 흐름도이다. 데이터 연산 시스템의 프로세서는 데이터 할당부 및 GEMM 연산부를 포함할 수 있다. 이러한 프 로세서의 구성요소들은 데이터 연산 시스템에 저장된 프로그램 코드가 제공하는 제어 명령에 따라 프로세서에 의해 수행되는 서로 다른 기능들(different functions)의 표현들일 수 있다. 프로세서 및 프로세서의 구성요소 들은 도 6의 블록 기반 연산 방법이 포함하는 단계들(610 내지 620)을 수행하도록 데이터 연산 시스템을 제어할 수 있다. 이때, 프로세서 및 프로세서의 구성요소들은 메모리가 포함하는 운영체제의 코드와 적어도 하나의 프 로그램의 코드에 따른 명령(instruction)을 실행하도록 구현될 수 있다. 프로세서는 블록 기반 연산 방법을 위한 프로그램의 파일에 저장된 프로그램 코드를 메모리에 로딩할 수 있다. 예를 들면, 데이터 연산 시스템에서 프로그램이 실행되면, 프로세서는 운영체제의 제어에 따라 프로그램의 파일 로부터 프로그램 코드를 메모리에 로딩하도록 데이터 연산 시스템을 제어할 수 있다. 이때, 데이터 할당부 및 GEMM 연산부 각각은 메모리에 로딩된 프로그램 코드 중 대응하는 부분의 명령을 실행하여 이후 단계들(610 내지 620)을 실행하기 위한 프로세서의 서로 다른 기능적 표현들일 수 있다. 단계에서 데이터 할당부는 뉴럴 프로세싱 유닛(Neural Processing Unit)의 메모리 크기와 연산 정밀 도에 기초하여 용량 인식 기반의 메모리 할당을 통해 메모리 공간에 데이터를 할당할 수 있다. 데이터 할당부 는 뉴럴 프로세싱 유닛의 메모리 크기에 기초하여 정밀도 및 잔여 로컬 메모리 공간을 조절하여 신경망 모 델의 파라미터들을 로컬 메모리에 저장할 수 있다. 데이터 할당부는 뉴럴 프로세싱 유닛에 대해 메모리 트래픽에 대한 바이너리 계산량의 비율을 나타내는 바이너리 연산 강도를 분석할 수 있다. 데이터 할당부(51 0)는 데이터 재사용 기회를 증가시키기 위해 잔여 메모리 공간을 사용하여 활성화 및 가중치 파라미터 데이터를 획득할 수 있다. 이때, 뉴럴 프로세싱 유닛은, 다중 정밀도 뉴럴 프로세싱 유닛(Precision-scalable neural processing unit; PSNPU)일 수 있다. 단계에서 GEMM 연산부는 메모리 공간에 저장된 데이터를 이용하여 블록 기반 GEMM(GEneral Matrix Multiplication) 연산을 수행할 수 있다. GEMM 연산부는 로컬 메모리에 저장된 활성화 및 가중치 파라미 터 데이터를 이용하여 블록 기반 GEMM 연산을 수행할 수 있다. GEMM 연산부는 프리페치(prefetch)를 통해 미리 로드할 수 있는 타일 그룹으로 구성된 블록 그룹을 이용한 블록 기반 스케줄링을 수행할 수 있다. GEMM 연산부는 실행 연산 및 저장 연산을 타일 그룹당 이중 버퍼링을 적용하고, 로드 연산을 블록 그룹당 이중버퍼링을 적용할 수 있다. 도 7은 일 실시예에 있어서, 블록 기반 연산 동작을 설명하기 위한 도면이다. 정밀도가 낮은 연산에서는 PSMA가 더 많은 요소뿐만 아니라 더 많은 비트 레벨 데이터를 처리해야 한다. 도 4 를 참고하면, A2W2와 A8W8 연산을 비교하여 PSMA의 특성을 보여준다. 예제에서 볼 수 있듯이, 각 A2W2 연산은 각 A8W8 연산보다 4배 적은 데이터를 필요로 하지만, 연산 속도는 16배 더 빠르며 A2W2에서 데이터를 훨씬 더 빨리 가져와야 한다. 따라서, 정밀도가 낮은 연산은 다중 정밀도 NPU에서 연산을 수행하기 위해 더 많은 양의 데이터를 필요로 하므로 메모리 바운드가 더 많아진다. PSMA는 재구성 가능한 로직(shift-add) 영역 오버헤드의 단점과 함께 저비트 데이터를 신속하게 계산하도록 설 계되었다. 정밀도가 낮은 연산이 메모리 바운드가 있고 최대 계산 속도를 달성할 수 없는 경우 재구성 가능한 영역 오버헤드를 희생하여 최대 성능이 증가하지 않는다. 따라서, 기존의 스케줄링이 정밀도가 낮은 연산의 메 모리 병목 현상을 해결할 수 있는지 분석해야 한다. 그렇지 못할 경우, 일반 NPU와 비교하여 다중 정밀도 NPU 에 필요한 추가 로컬 메모리의 양을 결정해야 한다. 데이터 연산 시스템은 루프라인 모델을 사용하여 다중 정밀도 NPU의 성능 병목 현상을 분석할 수 있다. 루프라 인 모델은 성능 병목 현상에 대한 통찰력과 해당 애플리케이션에서 결정할 수 있는 연산 강도(operational intensity; OI)를 기반으로 성능 추정을 제공할 수 있다. 데이터 연산 시스템은 도 1에서 정의된 시스템 파라미터를 기반으로 트랜스포머 기반 네트워크 모델에서 자주 사용되는 행렬 곱셈 연산의 타일 크기, 정밀도 및 OI 간의 상관 관계를 분석할 수 있다. 도 3을 참고하면, 행렬 곱셈(O[I][J] = A[I][K] × W[K][J])의 타일 그룹 구조를 나타낸 것이다. 기 설정된 기 준 이상의 타일 그룹(큰 타일 그룹)은 DRAM 액세스를 줄이고 데이터 전송 지연 시간을 숨길 수 있다. 따라서 a, w, o의 크기를 결정하는 itile, jtile, ktile은 온칩 메모리가 제한된 최대값이어야 한다. 또한, 각각의 a, w, o 타일은 도 2와 이중 버퍼링 방식을 적용하기 위해 같이 각각의 IS와 AccS의 절반을 사용해야 한다. A와 W 행 렬의 (최대 n, m)와 (AnWm의 n, m) 비율인 apack과 wpack의 경우, 요소는 IS와 AccS에 각각 8비트와 32비트 데이 터 유형으로 저장될 수 있다(수학식 1). 수학식 1:"}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "데이터 연산 시스템은 다중 정밀도 NPU는 정밀도에 따라 계산 특성이 다르기 때문에 정수 연산 횟수가 아닌 이 진 연산의 횟수를 기준으로 OI를 분석할 수 있다. 이는, 계산 특성과 관련된 요소의 비트 폭을 반영할 수 있기 때문이다. 다중 정밀도 NPU의 로컬 메모리 크기의 오버헤드를 8비트 고정 정밀도 NPU의 오버헤드와 비교하여 분석하기 위해 A8W8 연산에서 itile, jtile, ktile이 최적의 타일 크기라고 가정하기로 한다. 데이터 연산 시스템 은 OI 방정식을 기반으로 최적화 스케줄링없이 정밀도에 의존하는 OI를 분석할 수 있다. 수학식 2:"}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "수학식 2 및 도 1에서, 행렬 A, W, O의 각 타일은 aik, wkj, oij로 표시되며, aik, wkj, oij의 각 비트별 크기는 각 각 Itilektile8/apack, jtilektile8/wpack, itilejtile8이다. Psum은 AccS에 itilejtile32로 저장되지만, Psum은 itilejtile8과 같이 DRAM으로 이동된다.A8W8 작동 시 apack, wpack은 1이지만, apack, wpack은 정밀도가 낮아질수록 증가한다. 따라서, 다중 정밀도 NPU가 일반 NPU와 동일한 OI를 갖는 경우, itile, jtile, ktile은 각각 apack, wpack 및 apack×wpack 만큼 증가해야 한다(수학 식 2). 이는 (최대(apack), 최대wpack)에 의해 더 큰 IS와 AccS를 요구한다(수학식 1 기반). 데이터 연산 시스템은 기존 스케줄링에서 가장 높은 정밀도 연산과 동일한 OI를 달성하기 위해 가장 낮은 정밀 도 연산에 필요한 로컬 메모리의 양을 표시할 수 있다. 기존 스케줄링은 로컬 메모리에 이미 존재하는 A, W, Psum 행렬 중 하나를 재사용하여 데이터 설치 공간을 줄이고 OI를 증가시킬 수 있다. 예를 들어, 출력 재사용 (OR) 체계는 모든 타일 명령어의 입력 데이터와 가중치 파라미터를 읽고 2wpackapack/ktile 항이 수학식 2에서 무시 할 수 있게 되도록 Psum을 재사용하고, 가중치 재사용(weight-reuse; WR)은 가중치 파라미터를 재사용하여 apack/itile이 무시할 수 있게 한다. 여기서, 데이터 연산 시스템은 안정적인 상태에서의 OI를 표시할 수 있다. 도 7(b)(WR의 경우)에서 정상 상태 의 타일 명령어는 하나의 aik 타일에서 두 개의 oij를 계산할 수 있다. 따라서, WR 사례의 평균 OI는 읽기 타일 ai가 있거나 없는 두 타일 명령어의 계산량에 대한 데이터 이동 비율로 근사화될 수 있다. OR 및 WR 사례에서 OI를 추정하는 데 사용되는 방정식은 다음과 같다. 수학식 3:"}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "수학식 4:"}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "WR 또는 OR 스케줄링에서, A2W2가 A8W8과 동일한 OI를 나타내려면 IS의 양이 추가로 필요하며, 이는 수학식 1, 3, 4의 비교를 통해 얻을 수 있다. OI를 유지하기 위해서는 연산 정밀도에 따라 OR의 타일 그룹 크기를 각각 itile 및 jtile에서 apack, wpack에서 apack과 wpack 만큼 늘려야 한다. 또한, 모든 정밀 연산에서 메모리 바운드 문제 를 방지하기 위해서는 수학식 1과 같이, AccS를 wpack×apack만큼 증가시켜야 한다. WR에서, jtile, ktile은 각각 wpack, apack×wpack, IS와 AccS는 각각 최대(wpack){itile+jtile최대(apack)}/{itile+jtile}, 최대(wpack)만큼 증가해야 한다. 이전에 분석된 단순 스케줄링과 비교하여 OR 및 WR은 OI를 높이고 필요한 IS 크기를 줄이지만 8비트 고 정 정밀도 NPU보다 더 많은 로컬 메모리 또는 더 높은 메모리 대역폭이 필요하다. 데이터 연산 시스템은 다중 정밀도 NPU 스케줄링을 제공할 수 있다. 일반적인 스케줄링은 일반적으로 로컬 메 모리 및 대상 워크로드 크기에 관계없이 모든 NPU에 적용할 수 있다. 그러나 다중 정밀도 NPU는 일반적으로 일 반적인 스케줄링 파라미터를 가정할 때 메모리 제한 문제로 인해 상당한 성능 저하를 보인다. 데이터 연산 시 스템은 OI를 개선할 수 있도록 IS 메모리에 더 많은 요소를 통합하기 위해 DRAM 액세스 감소를 위해 모바일 NPU 의 큰 로컬 메모리와 낮은 정밀도 연산에서 작은 데이터 크기를 활용할 수 있다. 그러나 기존 타일 레벨 스케 줄링에서 가져온 요소의 수는 여전히 제한되어 있다. 주된 이유는 AccS에서 부분 합의 비트 폭이 원래 비트 폭 (일반적으로 32비트)에 남아있기 때문에 타일 그룹의 크기를 늘릴 수 없고, 타일 그룹의 종속성으로 인해 프리 페치를 효율적으로 수행할 수 없기 때문이다. 데이터 연산 시스템은 일반적인 타일 레벨 스케줄링의 한계를 보완하기 위해 용량 인식 기반 메모리 할당(CMA) 과 블록 레벨 스케줄링을 수행할 수 있다. 이는, 온칩 메모리에 더 많은 데이터를 저장할 수 있도록 함으로써 더 효과적인 데이터 재사용 기능과 데이터 프리페치라는 두 가지 성능 향상 기회를 제공한다. 첫째, CMA는 데 이터 재사용 기회를 개선할 수 있으며, 이는 적은 데이터 불러오기로 동일한 수의 계산을 수행함으로써 OI를 증 가시킨다. 또한, 데이터 연산 시스템은 집단적으로 프리페치될 수 있는 타일 집합으로 구성된 블록 그룹을 통 해 블록 레벨 스케줄링에서 메모리 대역폭을 효율적으로 사용할 수 있다. CMA 및 블록 레벨 스케줄링은 일반적 인 데이터 재사용 기반 NPU 스케줄링에 적용할 수 있는 다중 정밀도 NPU 스케줄링 기술이다. WR 기반 스케줄링 에 CMA와 블록 레벨 스케줄링을 도입하여 하드웨어 오버헤드 없이 다중 정밀도 NPU의 메모리 바운드 문제를 성공적으로 해결할 수 있다. 다음으로, 대용량 메모리 환경에서 타일 레벨 스케줄링의 한계에 대하여 설명하기로 한다. 에너지가 제한된 모 바일 환경에서 모바일 NPU는 DRAM 액세스를 최소화하기 위해 대규모 IS 메모리를 특징으로 한다. 대규모 IS 메 모리에서 대부분의 AI 모델 레이어는 k차원의 타일을 여러 개 가질 필요가 없다. 또한, 낮은 정밀도 조건에서 는 k차원에서 타일링이 거의 필요하지 않다. 타일링 없이 WR의 모든 타일 명령어에서 수행되는 읽기 및 쓰기 연산의 Psum이 필요하지 않으며, DRAM에 대한 단일 쓰기만으로 출력을 계산할 수 있기 때문에 OI가 증가할 수 있다. k차원에서 타일링이 적용되지 않더라도 타일 레벨 스케줄링의 한계로 인해 WR은 큰 로컬 메모리를 완전히 활용 하지 못한다. TVM과 Gemmini는 로드, 실행 및 저장을 단일 실행 유닛으로 캡슐화하고 하드웨어 타일 그룹 간의 종속성을 확인하거나 소프트웨어의 가상 스레드를 통해 동기화하는 동안 효율적인 종속성 모니터링 및 분리 액 세스 실행을 달성할 수 있다. HW 또는 SW 기술을 사용하여 효율적으로 종속성 검증을 수행하려면 IS 및 AccS의 절반에 타일 명령어를 할당해야 한다. 또한, IS 및 AccS의 공간이 할당된 후에는 연산 중에 다른 타일 그룹에 의해 액세스되지 않아야 한다. 그러나, 이러한 제한은 두 가지 이유로 다중 정밀도 NPU에 불리하다. 첫째, 정밀도가 낮아져도 AccS에 저장된 출력 요소의 비트 폭은 변경되지 않으므로, itile 및 jtile의 크기는 수학식 1만큼 증가할 수 없다. 도 7(a)와 같 이 k차원을 A8W8에 타일링하지 않으면 ktile이 증가할 수 없으며 IS의 활용도가 떨어질 것이다. 둘째, 복잡한 종속성을 제거하기 위해 메모리 할당 위치가 고유 주소에 미리 정의되는 경우가 많기 때문에 다음 타일 명령어 에 대한 데이터를 프리페치할 수 없다. 예를 들어, 도 7(b) 및 도 7(c)와 같이, 타일 레벨 스케줄링의 예에서 메모리 활용도가 낮은 것이 주요 성능 병목 현상임에도 불구하고 로드는 빈번하게 유휴(idle) 상태이다. 데이터 연산 시스템은 용량 인식 기반 메모리 할당을 통해 타일 레벨 스케줄링의 한계를 극복할 수 있다. 정밀 도가 낮은 연산에서는 IS가 작고 워크로드 크기가 큰 경우, ktile을 늘려 IS를 최대한 활용할 수 있다. 그러나, 충분한 IS 메모리 크기 때문에 k차원에 타일링이 적용되지 않으면 ktile은 이미 k차원으로 최대화된다. 따라서, k차원에 대해 타일링을 수행하지 않을 경우, A8W8에서도 활성화 및 가중치 파라미터의 정밀도에 따른 총 IS 사 용량은 각각 최대 1/apack, 1/wpack이다. 스크래치 패드의 크기를 늘리지 않고 타일 크기를 늘릴 수는 없지만, 이전에 참조된 타일을 다른 타일 명령어에 서 재사용하면 OI가 증가할 수 있다. CMA는 추가 메모리 공간을 사용할 수 있는 경우 이전 타일 그룹의 데이터 를 유지하면서 데이터를 할당하여 추가 데이터 재사용 기회를 창출한다. 도 7(a)는 일반적인 메모리 할당과 CMA를 보여준다. 일반적인 메모리 할당은 이전 타일 그룹에서 페치된 데이 터에 현재 타일 그룹 데이터를 덮어쓴다. 그러나, CMA는 데이터 재사용 기회를 증가시키기 위해 추가 메모리 공간을 사용하여 더 많은 활성화 및 가중치 파라미터 데이터(a1, a2, a3, w1, w2, w3)를 획득할 수 있다. 도 7(c)는 추가적인 데이터 재사용을 통한 빠른 컴퓨팅 프로세스의 타임라인을 보여준다. 처음 4개의 타일 명령어 는 나중에 순차적으로 재사용될 wj를 가져오며, 그 성능은 도 7(b)의 초기 상태와 차이가 없다. 도 7(c)와 같 이 다섯 번째 타일 명령어에서 ai를 로드하면 사전에 설정된 모든 wj로 계산할 수 있다. 따라서, 적은 데이터 전송으로 동일한 워크로드를 관리하고 신속하게 계산할 수 있다. 따라서 CMA는 OI를 개선하고 메모리 액세스를 줄여 전력 소비를 줄임으로써 성능을 향상시킬 수 있다. CMA를 사용하면 다른 타일 그룹에 의해 할당된 메모리를 덮어쓰지 않고 더 많은 데이터를 프리페치할 수 있다. 다음으로, 메모리 바운드 워크로드를 효율적으로 프리페치하기 위한 블록 레벨 스케줄링 기술을 소개한다. 블 록 그룹은 프리페치를 통해 미리 로드할 수 있는 타일 그룹으로 구성될 수 있다. 도 7(a) 및 도 7(d)에서 블록 그룹을 기준으로 블록 레벨 스케줄링이 수행될 수 있다. 데이터 연산 시스템은 하나의 블록 그룹을 구성하는 a0 및 w0 외에 a1, a2, a3, w1, w2, w3를 로딩할 수 있다. 블록 레벨 스케줄링의 주요 특징은 실행 및 저장 연산이 여전히 타일 그룹당 이중 버퍼링을 적용하지만 로드 연산은 블록 그룹당 이중 버퍼링을 적용한다는 점이다. 효 과적인 프리페치를 통해 제공되는 성능 향상은 도 7(c)와 도 7(d)를 비교하여 확인할 수 있다. 다중 정밀도 NPU의 성능 저하의 주요 원인은 메모리 병목 현상이지만, 도 7(c)에 표시된 타일 레벨 스케줄링은 로드 유닛을 유휴 상태로 만든다. 한편, 도 7(d)에 나타난 블록 레벨 스케줄링은 항상 로드 유닛을 활성화하여 메모리 활용 도를 극대화할 수 있다.블록 레벨 스케줄링의 OI(OIBlock)를 얻기 위해 블록 그룹 크기와 타일 그룹 크기 간의 상관 관계를 살펴보기로 한다. 타일 그룹의 타일 크기는 itile, jtile, ktile로 표현되므로 블록 그룹의 크기는 각각 iblock, jblock, kblock로 표현될 수 있다. 여기서, iblock과 jblock의 크기는 각각 itile과 jtile에 적어도 apack과 wpack을 곱한 값이다. 정밀 도가 낮을수록 CMA(iblock ≥itile × apack, jblock ≥ jtile × wpack)를 통해 더 많은 타일 명령어(a 및 w)를 가져올 수 있기 때문이다. 따라서 iblock 및 jblock을 기준으로 OIBlock이 다음과 같이 표현될 수 있다. 수학식 5:"}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "블록 레벨 스케줄링 및 WR은 동시에 적용할 수 있는 직교 방법이다. 블록 레벨 스케줄링이 WR에 적용될 때 OI는 다음과 같다. 수학식 6:"}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "데이터 연산 시스템은 CMA를 통해 데이터 재사용 기회를 늘려 OI를 성공적으로 증가시키고 블록 레벨 스케줄링 을 통한 효과적인 프리패칭을 통해 효과적인 대역폭을 추가적을 증가시켜 성능을 개선할 수 있다. 도 8은 일 실시예에 있어서, 블록 기반 연산 동작의 기술적 효과를 설명하기 위한 그래프이다. 도 8을 참고하면, 다중 정밀도 NPU에서 타일링 기반 GEMM 연산과 블럭 기반 GEMM연산의 차이를 비교한 그래프이 다. O[I][J]=A[I][K]×W[K][J] 행렬곱에서 행렬곱의 크기를 [I]-[J]-[K]로 표기할 때, 도 8의 행렬곱의 크기 는 [512]-[512]-[512, 1024, 2048]이다. 일부 경우를 제외한 거의 모든 곳에서 블록 기반 GEMM 연산이 타일링 기반 GEMM 연산 방식보다 더 나은 결과를 보여주었으며, 최대 2.26 배 더 높은 결과를 보여주는 것을 확인할 수 있다. 실시예에 따르면, 다중 정밀도 NPU의 하드웨어 특성을 이해하고, 다중 정밀도 NPU 특성이 고려된 블록 기반 GEMM 연산을 통해 기존 타일링 기반 GEMM 연산에서 문제되었던 낮은 로컬 메모리 사용률을 높이고, 제한된 메모 리 대역폭을 효과적으로 활용하여 낮은 정밀도 연산에서도 메모리 병목 현상을 최소화할 수 있다. 이상에서 설명된 장치는 하드웨어 구성요소, 소프트웨어 구성요소, 및/또는 하드웨어 구성요소 및 소프트웨어 구성요소의 조합으로 구현될 수 있다. 예를 들어, 실시예들에서 설명된 장치 및 구성요소는, 예를 들어, 프로 세서, 콘트롤러, ALU(arithmetic logic unit), 디지털 신호 프로세서(digital signal processor), 마이크로컴 퓨터, FPGA(field programmable gate array), PLU(programmable logic unit), 마이크로프로세서, 또는 명령 (instruction)을 실행하고 응답할 수 있는 다른 어떠한 장치와 같이, 하나 이상의 범용 컴퓨터 또는 특수 목적 컴퓨터를 이용하여 구현될 수 있다. 처리 장치는 운영 체제(OS) 및 상기 운영 체제 상에서 수행되는 하나 이상 의 소프트웨어 애플리케이션을 수행할 수 있다. 또한, 처리 장치는 소프트웨어의 실행에 응답하여, 데이터를 접근, 저장, 조작, 처리 및 생성할 수도 있다. 이해의 편의를 위하여, 처리 장치는 하나가 사용되는 것으로 설"}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "명된 경우도 있지만, 해당 기술분야에서 통상의 지식을 가진 자는, 처리 장치가 복수 개의 처리 요소 (processing element) 및/또는 복수 유형의 처리 요소를 포함할 수 있음을 알 수 있다. 예를 들어, 처리 장치 는 복수 개의 프로세서 또는 하나의 프로세서 및 하나의 콘트롤러를 포함할 수 있다. 또한, 병렬 프로세서 (parallel processor)와 같은, 다른 처리 구성(processing configuration)도 가능하다. 소프트웨어는 컴퓨터 프로그램(computer program), 코드(code), 명령(instruction), 또는 이들 중 하나 이상의 조합을 포함할 수 있으며, 원하는 대로 동작하도록 처리 장치를 구성하거나 독립적으로 또는 결합적으로(collectively) 처리 장치를 명령할 수 있다. 소프트웨어 및/또는 데이터는, 처리 장치에 의하여 해석되거나 처리 장치에 명령 또는 데이터를 제공하기 위하여, 어떤 유형의 기계, 구성요소(component), 물리적 장치, 가상 장치(virtual equipment), 컴퓨터 저장 매체 또는 장치에 구체화(embody)될 수 있다. 소프트웨어는 네트워크로 연결된 컴퓨터 시스템 상에 분산되어서, 분산된 방법으로 저장되거나 실행될 수도 있다. 소프트웨어 및 데이터 는 하나 이상의 컴퓨터 판독 가능 기록 매체에 저장될 수 있다. 실시예에 따른 방법은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 상기 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등 을 단독으로 또는 조합하여 포함할 수 있다. 상기 매체에 기록되는 프로그램 명령은 실시예를 위하여 특별히 설계되고 구성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판 독 가능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD-ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체 (magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도 록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다."}
{"patent_id": "10-2023-0076978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "이상과 같이 실시예들이 비록 한정된 실시예와 도면에 의해 설명되었으나, 해당 기술분야에서 통상의 지식을 가 진 자라면 상기의 기재로부터 다양한 수정 및 변형이 가능하다. 예를 들어, 설명된 기술들이 설명된 방법과 다 른 순서로 수행되거나, 및/또는 설명된 시스템, 구조, 장치, 회로 등의 구성요소들이 설명된 방법과 다른 형태 로 결합 또는 조합되거나, 다른 구성요소 또는 균등물에 의하여 대치되거나 치환되더라도 적절한 결과가 달성될 수 있다. 그러므로, 다른 구현들, 다른 실시예들 및 특허청구범위와 균등한 것들도 후술하는 특허청구범위의 범위에 속한 다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8"}
{"patent_id": "10-2023-0076978", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1 내지 도 4는 일 실시예에 있어서, 다중 정밀도 NPU를 설명하기 위한 도면이다. 도 5는 일 실시예에 있어서, 데이터 연산 시스템의 하드웨어 구성을 설명하기 위한 블록도이다. 도 6은 일 실시예에 있어서, 블록 기반 연산 방법을 설명하기 위한 흐름도이다. 도 7은 일 실시예에 있어서, 블록 기반 연산 동작을 설명하기 위한 도면이다. 도 8은 일 실시예에 있어서, 블록 기반 연산 동작의 기술적 효과를 설명하기 위한 그래프이다."}
