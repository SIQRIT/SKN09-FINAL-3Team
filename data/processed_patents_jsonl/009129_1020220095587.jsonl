{"patent_id": "10-2022-0095587", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0017644", "출원번호": "10-2022-0095587", "발명의 명칭": "사이버 위협 정보 처리 장치, 사이버 위협 정보 처리 방법 및 사이버 위협 정보 처리하는 소", "출원인": "주식회사 샌즈랩", "발명자": "김기홍"}}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "데이터를 저장하는 하나 이상의 저장장치; 및입력 받거나 상기 하나 이상의 저장장치에 저장된 데이터를 실행하는 프로세서;를 포함하고,상기 프로세서는, 기계 학습 기반 악성 코드 탐지 모델에 의해 학습되고 상기 저장장치에 저장된 학습된 데이터를 수신하고 상기수신한 데이터에 포함된 파일 타입에 따라 상기 수신한 데이터 필터링하고, 제 3 악성 코드 탐지 모델에 상기 필터링한 데이터이 악성 여부를 질의하고, 상기 질의 결과에 따라 상기 필터링한 데이터에 레이블링(Labeling) 정보를 부여하고, 상기 필터링한 데이터의 원본 샘플 데이터에 대해 메타데이터를 생성하고, 상기 메타데이터에 기반하여 상기 원본 샘플 데이터의 악성 코드 특징 정보를 추출하고, 및상기 악성 코드 특징 정보와 상기 레이블링 정보에 기반하여 상기 기계 학습 기반 악성 코드 탐지 모델의 성능을 평가하고 평가 결과를 제공하는, 사이버 위협 정보 처리 장치."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1항에 있어서 상기 질의 결과는 상기 제 3 악성 코드 탐지 모델이 상기 필터링한 데이터로부터 탐지된 악성 행위 탐지 개수인사이버 위협 정보 처리 장치."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 2항에 있어서, 상기 레이블링 정보는 상기 악성 행위 탐지 개수에 따라 부여되는 사이버 위협 정보 처리 장치."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1항에 있어서, 상기 생성한 원본 샘플 데이터의 메타데이터는 상기 하나 이상의 저장 장치에 저장되는 사이버 위협 정보 처리장치."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1항에 있어서, 상기 악성 코드 특징 정보는 상기 원본 샘플 데이터의 벡터화 데이터인 사이버 위협 정보 처리 장치."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1항에 있어서, 상기 평가 결과는 상기 입력 데이터에 포함되는 파일 타입에 따라 실시간 제공되는 사이버 위협 정보 처리장치."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "기계 학습 기반 악성 코드 탐지 모델에 의해 학습된 데이터를 수신하고 상기 수신한 데이터에 포함된 파일 타입에 따라 상기 수신한 데이터 필터링하는 단계;공개특허 10-2024-0017644-3-제 3 악성 코드 탐지 모델에 상기 필터링한 데이터이 악성 여부를 질의하고, 상기 질의 결과에 따라 상기 필터링한 데이터에 레이블링(Labeling) 정보를 부여하는 단계;상기 필터링한 데이터의 원본 샘플 데이터에 대해 메타데이터를 생성하고, 상기 메타데이터에 기반하여 상기 원본 샘플 데이터의 악성 코드 특징 정보를 추출하는 단계; 및상기 악성 코드 특징 정보와 상기 레이블링 정보에 기반하여 상기 기계 학습 기반 악성 코드 탐지 모델의 성능을 평가하고 평가 결과를 제공하는 단계;를 포함하는 사이버 위협 정보 처리 방법."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 7항에 있어서 상기 질의 결과는 상기 제 3 악성 코드 탐지 모델이 상기 필터링한 데이터로부터 탐지된 악성 행위 탐지 개수인사이버 위협 정보 처리 방법."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 8항에 있어서, 상기 레이블링 정보는 상기 악성 행위 탐지 개수에 따라 부여되는 사이버 위협 정보 처리 방법."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 7항에 있어서, 상기 생성한 원본 샘플 데이터의 메타데이터는 하나 이상의 저장 장치에 저장되는 사이버 위협 정보 처리 방법."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 7항에 있어서, 상기 악성 코드 특징 정보는 상기 원본 샘플 데이터의 벡터화 데이터인 사이버 위협 정보 처리 방법."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 7항에 있어서, 상기 평가 결과는 상기 입력 데이터에 포함되는 파일 타입에 따라 실시간 제공되는 사이버 위협 정보 처리방법."}
{"patent_id": "10-2022-0095587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "기계 학습 기반 악성 코드 탐지 모델에 의해 학습된 데이터를 수신하고 상기 수신한 데이터에 포함된 파일 타입에 따라 상기 수신한 데이터 필터링하는 모듈;제 3 악성 코드 탐지 모델에 상기 필터링한 데이터이 악성 여부를 질의하고, 상기 질의 결과에 따라 상기 필터링한 데이터에 레이블링(Labeling) 정보를 부여하는 모듈;상기 필터링한 데이터의 원본 샘플 데이터에 대해 메타데이터를 생성하고, 상기 메타데이터에 기반하여 상기 원본 샘플 데이터의 악성 코드 특징 정보를 추출하는 모듈; 및상기 악성 코드 특징 정보와 상기 레이블링 정보에 기반하여 상기 기계 학습 기반 악성 코드 탐지 모델의 성능을 평가하고 평가 결과를 제공하는 모듈;을 포함하는; 컴퓨터로 실행 가능한 사이버 위협 정보 처리하는 소프트웨어를 저장하는 저장매체."}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "개시하는 실시 예는 기계 학습 기반 악성 코드 탐지 모델에 의해 학습된 데이터를 수신하고 상기 수신한 데이터 에 포함된 파일 타입에 따라 상기 수신한 데이터 필터링하는 단계; 제 3 악성 코드 탐지 모델에 상기 필터링한 데이터이 악성 여부를 질의하고, 상기 질의 결과에 따라 상기 필터링한 데이터에 레이블링(Labeling) 정보를 부 여하는 단계; 상기 필터링한 데이터의 원본 샘플 데이터에 대해 메타데이터를 생성하고, 상기 메타데이터에 기반 하여 상기 원본 샘플 데이터의 악성 코드 특징 정보를 추 출하는 단계; 및 상기 악성 코드 특징 정보와 상기 레 이블링 정보에 기반하여 상기 기계 학습 기반 악성 코드 탐지 모델의 성능을 평가하고 평가 결과를 제공하는 사 이버 위협 정보 처리 방법포함하는 사이버 위협 정보 처리 방법을 제공한다."}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "개시하는 실시 예들은 사이버 위협 정보 처리 장치, 사이버 위협 정보 처리 방법 및 사이버 위협 정보 처리하는 소프트웨어를 저장하는 저장매체에 관한 것이다."}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "신종 또는 변종 등의 악성코드를 중심으로 점차 고도화 되고 있는 사이버 보안 위협의 피해가 커지고 있다. 이 러한 피해를 조금이라도 줄이고 조기에 대응하기 위해서 다차원의 패턴 구성 및 각종 복합 분석 등을 통해서 대 응 기술에 대한 고도화를 병행해 나가고 있다. 그러나, 최근의 사이버 공격은 제어 범위 내에 적절하게 대응되 기 보다는 오히려 나날이 위협이 증가하고 있는 추세이다. 이러한 사이버 공격은 기존 ICT (Information and Communication Technology) 기반 시설을 넘어서 우리 삶에 직접적으로 영향을 끼치는 금융, 교통, 환경, 건강 등에 까지 위협을 가하고 있다. 현존하는 대부분의 사이버 보안 위협을 탐지하고 대응하는 기반 기술 중에 하나는 사이버 공격 또는 악성 코드 에 대한 패턴을 데이터베이스를 사전에 생성하고 데이터 흐름이 필요한 곳에 적절한 모니터링 기술을 활용한다. 기존의 기술은 모니터링된 패턴과 일치하는 데이터 흐름 또는 코드가 탐지되면 위협을 식별하여 대응하는 방식 을 바탕으로 발전되어 왔다. 이와 같은 종래의 기술은 사전에 확보된 패턴과 일치하면 빠르고 정확하게 탐지할 수 있다는 장점이 있지만, 패턴이 확보되지 않거나 우회하는 신종, 변종 위협의 경우 탐지 자체가 불가능하거나 분석하는데 매우 시간이 오래 소요되는 문제점이 있었다. 종래의 기술은 인공지능 분석을 활용하더라도 악성코드 자체를 탐지하고 분석하는 기술을 고도화하는 방법에 초 점이 맞춰져 있다. 그러나 근본적으로 사이버 보안 위협을 대응하기 위한 원천적인 기술은 존재하지 않아 이러 한 방법만으로 신종 악성코드나 그 악성코드의 변종에 대응하기 힘들며 한계가 있다는 문제점이 있다. 예를 들면 이미 발견된 악성 코드 자체를 탐지하고 분석하는 기술만으로는 그 탐지나 분석 시스템을 속이기 위 한 디코이(decoy) 정보나 가짜 정보에 대응하지 못하고 혼선이 발생하는 문제점이 있다. 학습할 데이터가 충분히 있는 대량 생산의 악성코드의 경우는 그 특징 정보를 충분히 확보할 수 있기 때문에 악 성 여부 및 악성코드 종류를 구분할 수 있다. 그러나, 상대적으로 수량이 작게 만들어져 정교하게 공격하는 APT (Advanced Persistent Threat) 공격의 경우는 학습 데이터와 일치하지 않는 경우가 많고 타겟팅(targeting)된 공격이 대다수를 이루고 있기 때문에 기존 기술은 고도화하더라도 한계점이 존재한다. 또한 종래에는 악성 코드, 공격 코드 또는 사이버 위협에 대한 설명을 하는 방법과 표현 기법이 분석가의 입장 이나 분석 시각에 따라 달랐다. 예를 들면 악성 코드와 공격 행위를 기술하는 방식은 전세계적으로 표준이 되지 않아 같은 사건, 같은 악성코드를 탐지하여도 해당 분야의 전문가의 설명이 달라 혼동이 되는 문제점이 있었다. 심지어 악성코드 탐지 명 또한 통일이 되지 않아 같은 악성 파일임에도 불구하고 어떤 공격이 정확하게 수행되 었는지 식별되지 못하거나 다르게 정리되었다. 따라서 식별된 공격 기법을 정규화되고 표준화된 방식으로 설명 하지 못하는 문제점이 있었다. 종래의 악성 코드 탐지 및 분석 방법은 악성코드 자체의 탐지를 중시하여 매우 유사한 악성 행위를 수행하는 악 성 코드의 경우 생성하는 공격자가 다른 경우 공격자들을 식별하지 못하는 문제점이 있었다. 위와 같은 문제점들과 연결되어 종래의 방식은 이러한 개별적인 케이스 집중된 탐지 방법에 의해 추후 가까운 미래에 어떤 사이버 위협 공격이 있을지 예측하기 어려운 문제점이 있었다. 한편 기계 학습 기반의 사이버 위협 정보를 처리하는 인텔리전스 플랫폼이나 악성 코드 탐지 모델의 경우 그 성 능을 즉시 검증하기 어려워 보안 조치가 실시간으로 될 수 없는 경우도 있다."}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "이하에서 개시하는 실시 예의 목적은, 인공 지능으로 학습된 데이터와 정확하게 일치하지 않는 악성 코드라도 탐지하고 대응할 수 있고 악성 코드의 변종에 대응할 수 있는 사이버 위협 정보 처리 장치, 사이버 위협 정보 처리 방법 및 사이버 위협 정보 처리하는 프로그램을 저장하는 저장매체를 제공하는 것이다. 실시 예의 다른 목적은 악성 코드의 변종이라도 매우 빠른 시간 내에 악성 코드, 공격 기법, 공격자와 공격 예 측 방법을 식별할 수 있는 사이버 위협 정보 처리 장치, 사이버 위협 정보 처리 방법 및 사이버 위협 정보 처리 하는 프로그램을 저장하는 저장매체를 제공하는 것이다. 실시 예의 다른 목적은 악성코드 탐지 명 등이 통일되지 않거나 사이버 공격 기법이 정확하게 기술되지 못하는 악성 코드의 정보를 정규화되고 표준화된 방식으로 제공할 수 있는 사이버 위협 정보 처리 장치, 사이버 위협정보 처리 방법 및 사이버 위협 정보 처리하는 프로그램을 저장하는 저장매체를 제공하는 것이다. 실시 예의 다른 목적은 매우 유사한 악성 행위를 수행하는 악성 코드를 생성하는 다른 공격자들을 식별하고 미 래에 어떤 사이버 위협 공격이 있을지 예측이 가능한 사이버 위협 정보 처리 장치, 사이버 위협 정보 처리 방법 및 사이버 위협 정보 처리하는 프로그램을 저장하는 저장매체를 제공하는 것이다. 실시 예의 다른 목적은 사이버 정보를 처리하는 인텔리전스 플랫폼, 특히 기계 학습 기반의 악성 코드 탐지 모 델의 성능을 실시간으로 검증하고 개선할 수 있는 사이버 위협 정보 처리 장치, 사이버 위협 정보 처리 방법 및 사이버 위협 정보 처리하는 프로그램을 저장하는 저장매체를 제공하는 것이다."}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "개시하는 실시 예는, 데이터를 저장하는 하나 이상의 저장장치; 입력 받거나 상기 하나 이상의 저장장치에 저장 된 데이터를 실행하는 프로세서;를 포함하고, 상기 프로세서는, 기계 학습 기반 악성 코드 탐지 모델에 의해 학 습되고 상기 저장장치에 저장된 학습된 데이터를 수신하고 상기 수신한 데이터에 포함된 파일 타입에 따라 상기 수신한 데이터 필터링하고, 제 3 악성 코드 탐지 모델에 상기 필터링한 데이터이 악성 여부를 질의하고, 상기 질의 결과에 따라 상기 필터링한 데이터에 레이블링(Labeling) 정보를 부여하고, 상기 필터링한 데이터의 원본 샘플 데이터에 대해 메타데이터를 생성하고, 상기 메타데이터에 기반하여 상기 원본 샘플 데이터의 악성 코드 특징 정보를 추출하고, 상기 악성 코드 특징 정보와 상기 레이블링 정보에 기반하여 상기 기계 학습 기반 악성 코드 탐지 모델의 성능을 평가하고 평가 결과를 제공하는, 사이버 위협 정보 처리 장치를 제공한다. 다른 관점에서 실시 예는 기계 학습 기반 악성 코드 탐지 모델에 의해 학습된 데이터를 수신하고 상기 수신한 데이터에 포함된 파일 타입에 따라 상기 수신한 데이터 필터링하는 단계; 제 3 악성 코드 탐지 모델에 상기 필 터링한 데이터이 악성 여부를 질의하고, 상기 질의 결과에 따라 상기 필터링한 데이터에 레이블링(Labeling) 정 보를 부여하는 단계; 상기 필터링한 데이터의 원본 샘플 데이터에 대해 메타데이터를 생성하고, 상기 메타데이 터에 기반하여 상기 원본 샘플 데이터의 악성 코드 특징 정보를 추출하는 단계; 및 상기 악성 코드 특징 정보와 상기 레이블링 정보에 기반하여 상기 기계 학습 기반 악성 코드 탐지 모델의 성능을 평가하고 평가 결과를 제공 하는 단계;를 포함하는 사이버 위협 정보 처리 방법을 제공한다. 상기 질의 결과는 상기 제 3 악성 코드 탐지 모델이 상기 필터링한 데이터로부터 탐지된 악성 행위 탐지 개수일 수 있다. 상기 레이블링 정보는 상기 악성 행위 탐지 개수에 따라 부여될 수 있다. 상기 생성한 원본 샘플 데이터의 메타데이터는 상기 하나 이상의 저장 장치에 저장될 수 있다. 상기 악성 코드 특징 정보는 상기 원본 샘플 데이터의 벡터화 데이터일 수 있다. 상기 평가 결과는 상기 입력 데이터에 포함되는 파일 타입에 따라 실시간 제될 수 있다. 다른 관점에서 실시 예는 기계 학습 기반 악성 코드 탐지 모델에 의해 학습된 데이터를 수신하고 상기 수신한 데이터에 포함된 파일 타입에 따라 상기 수신한 데이터 필터링하는 모듈; 제 3 악성 코드 탐지 모델에 상기 필 터링한 데이터이 악성 여부를 질의하고, 상기 질의 결과에 따라 상기 필터링한 데이터에 레이블링(Labeling) 정 보를 부여하는 모듈; 상기 필터링한 데이터의 원본 샘플 데이터에 대해 메타데이터를 생성하고, 상기 메타데이 터에 기반하여 상기 원본 샘플 데이터의 악성 코드 특징 정보를 추출하는 모듈; 및 상기 악성 코드 특징 정보와 상기 레이블링 정보에 기반하여 상기 기계 학습 기반 악성 코드 탐지 모델의 성능을 평가하고 평가 결과를 제공 하는 모듈;을 포함하는; 컴퓨터로 실행 가능한 사이버 위협 정보 처리하는 소프트웨어를 저장하는 저장매체를 제공한다."}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "이하에서 개시하는 실시예에 따르면 머신 러닝으로 학습된 데이터와 정확하게 일치하지 않는 악성 코드라도 탐 지하고 대응할 수 있고 악성 코드의 변종에 대응할 수 있다. 실시예에 따르면 악성 코드의 변종이라도 매우 빠른 시간 내에 악성 코드, 공격 기법 및 공격자를 식별할 수 있 고 나아가 추후의 특정 공격자의 공격 기법을 예측할 수 있다. 실시예에 따르면 이러한 악성 코드 여부, 공격 기법, 공격 식별자 및 공격자를 기반으로 사이버 공격 구현 방식 을 정확히 식별하고 이를 표준화된 모델로 제공할 수 있다. 실시예에 따르면 악성코드 탐지 명 등이 통일되지않거나 사이버 공격 기법이 정확하게 기술되지 못하는 악성 코드의 정보를 정규화되고 표준화된 방식으로 제공 할 수 있다. 또한 기존에 알려지지 않은 악성 코드를 생성 가능성과 이를 개발할 수 있는 공격자들을 예측하고 미래에 어떤 사이버 위협 공격이 있을지 예측 가능한 수단을 제공할 수 있다. 실시 예에 따르면 이러한 악성 코드에 대한 상세한 기술적인 정보 이외에 일반인이 이해할 수 있는 자연어 기반 의 태그 정보를 제공하여 악성코드 식별과 유포 대응 정보 생성을 쉽게 수행 할 수 있다. 그리고 실시 예에 따르면 필요한 정보를 각종 사회 이슈 기반 주요 키워드를 통해 트랜드 파악 등의 추가적인 인텔리전스를 확보 할 수 있다. 실시 예에 따르면 사이버 정보를 처리하는 인텔리전스 플랫폼, 특히 기계 학습 기반의 악성 코드 탐지 모델의 성능을 실시간으로 검증하고 개선할 수 있다."}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하에서는 첨부한 도면을 참조하여 실시 예를 예시하여 상세히 기술하도록 한다. 실시 예에서 프레임워크, 모 듈, 응용 프로그램 인터페이스 등은 물리 장치 결합된 장치로 구현할 수도 있고 소프트웨어로 구현할 수도 있다. 실시 예가 소프트웨어로 구현될 경우 저장매체에 저장되고 컴퓨터 등에 설치되어 프로세서에 의해 실행될 수 있 다. 사이버 위협 정보 처리 장치 및 사이버 위협 정보 처리 방법의 실시 예들을 상세히 개시하면 다음과 같다. 도 1은 사이버 위협 정보 처리 방법의 일 실시 예를 예시한 도면이다. 사이버 위협 정보 처리 방법의 일 실시 예를 설명하면 다음과 같다. 사이버 위협 정보 처리 장치로 입력된 파일의 전처리를 수행한다(S1000). 파일의 전처리를 통해 파일을 식별할 수 있는 식별 정보를 얻을 수 있다. 파일의 전처리 수행의 일 예는 다음과 같다. 수신한 파일로부터 파일의 출처 정보, 파일을 얻은 수집 정보, 파일의 사용자 정보 등을 포함한 여러 가지 메타 정보를 얻을 수 있다. 예를 들어 파일이 URL (uniform resource locator)을 포함하거나 또는 전자메일에 포함된 경우 파일에 대한 수집 정보를 얻을 수 있다. 사용자 정보는 파일의 생성, 업로드 또는 최종 저장한 사용자 정 보 등을 포함할 수 있다. 전처리 과정에서 파일의 메타 정보로서 IP(internet protocol) 정보, 이에 기반한 국 가 정보, API(Application Programming Interface) key 정보, 예를 들면 분석을 의뢰한 사용자의 API 정보 등 을 얻을 수 있다. 전처리 과정에서 파일의 해쉬(Hash) 값을 추출할 수도 있다. 해쉬 값이 이미 사이버 위협 정보 처리 장치에 알 려진 것이라면 이를 기반으로 파일의 종류나 위험 정도를 식별할 수 있다. 만약 이미 알려진 파일이 아니라면 기 저장된 정보 또는 필요한 경우 외부의 레퍼런스 웹 사이트(reference website)에 해쉬 값과 파일 정보를 조회하여 파일 종류 식별을 위한 분석 정보를 얻을 수 있다. 예를 들어 외부 의 레퍼런스 웹 사이트로서 한국인터넷진흥원에서 운영하는 C-TAS(Cyber Threats Analysis System), CTA(Cyber Threat Alliance)의 운영시스템, VitusTotal 등의 사이트로부터 파일 종류에 따른 정보를 얻을 수 있다. 예를 들면, 파일의 MD5 (Message-Digest algorithm 5), SHA1 (Secure Hash Algorithm 1), SHA 256 등의 해쉬 함수의 해쉬 값을 이용하여 해당 사이트에서 파일을 검색할 수 있다. 그리고 검색 결과를 이용해 상기 파일을 식별할 수 있다. 파일을 분석을 수행하는 일 예로서, 입력된 파일이 모바일 네트워크를 통해 전송될 경우 네트워크 트래픽을 통 해 전송되는 패킷은 네트워크 전송 패킷의 재조합 기술 등을 사용하여 입력된 파일이 모바일 악성 의심 코드인 경우 이를 저장할 수 있다. 패킷의 재조합 기술은 수집된 네트워크 트래픽에서 하나의 실행 코드에 해당하는 일 련의 패킷들을 재 조합하며, 재 조합된 패킷들에 의해 전송되는 파일이 모바일 악성 의심 코드인 경우 이 파일 이 저장된다. 만약 이 단계에서 전송 파일 내에 모바일 악성 의심 코드 추출이 되지 않은 경우 파일 내에 다운로드 URL에 직 접 접속하여 모바일 악성 의심 코드를 다운로드하여 저장할 수도 있다. 상기 입력된 파일과 관련된 악성 행위(malicious activity) 분석 정보 생성한다(S2000). 입력된 파일과 관련된 악성 행위의 분석 정보는 파일 자체에 대한 정보를 분석하는 정적 분석 정보나 입력된 파 일로부터 얻은 정보를 실행하여 악성 행위 여부를 판별할 수 있는 동적 분석 정보를 포함할 수 있다. 이 단계의 분석 정보는 입력된 파일과 관련된 실행 파일로부터 가공된 정보를 이용하거나 파일과 관련된 메모리 분석을 수행하는 심층 분석 정보를 포함할 수 있다. 심층 분석은 악성 행위를 정확하게 식별할 수 있도록 인공 지능 분석을 포함할 수 있다. 이 단계의 분석 정보는 또한 파일과 관련하여 이미 저장된 분석 정보나 또는 생성된 분석 정보를 서로 연관시켜 공격 행위나 공격자에 대한 연관 관계를 추정할 수 있는 연관관계 분석 정보를 포함할 수 있다. 이 단계에서 다수의 분석 정보는 전체 분석 결과로 제공되기 위해 취합될 수 있다. 예를 들어 하나의 파일에 대한 정적 분석 정보, 동적 분석 정보, 심층 분석 정보, 연관관계 분석 정보 등은 정 확한 공격 기법과 공격자 식별을 위해 통합 분석될 수 있다. 통합 분석은 분석 정보 사이의 중복된 부분을 제거 하고 분석 정보 간 공통의 정보는 정확도를 높이는데 사용될 수 있다. 예를 들어 여러 분석과 경로를 통해 수집된 사이버 위협 침해 정보(indicator of compromise, IoC)들은 정보들 사이에 노멀라이징(normalizing)하거나 인리치먼트(enrichment) 수행을 통해 표준화 작업을 수행할 수 있다. 분석 정보의 획득하는 실시 예에서 반드시 위의 기술된 모든 분석 정보를 순서에 따라 산출할 필요는 없다. 예 를 들어 정적 분석 정보 획득과 동적 분석 정보 획득은 어느 하나만 진행될 수도 있으며 정적 분석 정보 보다 동적 분석 정보를 먼저 수행할 수도 있다. 심층 분석 정보는 반드시 정적 분석 또는 동적 분석을 수행한 후 진행될 필요가 없으며, 연관 관계 분석도 심층 분석 정보 없이 수행될 수도 있다. 따라서 위 분석 정보를 획득하는 처리 순서는 변경될 수도 있으며 선택적으로 이루어질 수도 있다. 또한 위에 기술한 분석 정보의 획득 과정과 예측 정보의 생성 과정은 파일로부터 획득한 정보에 기초하여 병렬적으로 수행 될 수 있다. 예를 들면 동적 분석이 수행이 완료되지 않더라도 연관관계 분석 정보를 생성할 수도 있다. 마찬가 지로 동적 분석 수행이나 심층 분석 수행이 동시에 진행될 수 있다. 이러한 경우 위에서 예시한 전처리 과정(S1000)은 파일의 정보를 얻거나 식별하기 위한 것이므로 정적 분석, 동 적 분석, 심층 분석 또는 연관 분석이 개별적이나 병렬적으로 수행될 경우 각 분석 단계에 일부로서 각각 수행 될 수 있다. 이 단계에 대한 상세한 실시 예는 아래에서 후술한다. 상기 입력된 파일과 관련된 악성 행위의 예측 정보를 생성할 수 있다(S3000). 분석 정확도를 높이기 위해 위의 분석된 여러 가지 정보의 데이터 세트를 이용하여 악성 행위의 발생 여부, 공 격 기법, 공격자 그룹 등에 대한 예측 정보를 생성할 수 있다. 예측 정보의 생성은 이미 분석된 데이터 세트에 대한 인공지능 분석을 통해 수행될 수 있다. 예측 정보의 생성 은 필수적인 단계가 아니며 인공지능 분석을 위해 적절하게 분석된 데이터 세트가 마련되어 조건이 만족될 경우 추후 악성 공격 행위에 대한 예측 정보를 생성할 수 있다. 실시 예는 여러 가지 분석 정보들을 기반으로 인공 지능 기반의 머신 러닝을 수행한다. 실시 예는 분석된 정보 에 대한 데이터 세트를 기반으로 예측 정보를 생성할 수 있다. 예를 들면 인공 지능으로 학습된 데이터를 바탕 으로 추가적인 분석 정보를 생성하고 다시 생성된 분석 정보는 다시 새로운 학습 데이터로서 인공 지능의 입력 데이터로 이용될 수 있다. 여기서 예측 정보는 악성 코드 제작자 정보, 악성 코드 공격 방법 정보, 악성 코드 공격 그룹 예측, 악성 코드 유사도 예측 정보, 및 악성 코드 확산도 예측 정보 등을 포함할 수 있다. 생성된 예측 정보는 악성 코드 자체의 위험도를 예측한 제 1 예측 정보와 악성 코드의 공격자, 공격 그룹, 유사 도, 확산도 등을 예측한 제 2 예측 정보 등을 포함할 수 있다. 이러한 제 1 예측 정보와 제 2 예측 정보를 포함하는 예측 분석 정보는 서버나 데이터 베이스에 저장될 수 있다. 이에 대한 상세한 실시 예는 이하에서 후술한다. 상기의 분석 정보 또는 예측 정보에 대한 후처리 후 상기 입력된 파일과 관련된 사이버 위협 정보를 제공한다 (S4000). 실시 예는 분석 정보 또는 예측 정보에 기초하여 악성 코드 종류 및 악성 코드의 위험도를 결정한다. 그리고 실 시 예는 악성 코드에 대한 프로파일링 정보를 생성한다. 따라서 파일 분석을 통해 파일에 대한 자체 분석을 수 행한 결과나 추가 및 예측 분석을 수행한 결과를 저장할 수 있다. 생성되는 프로파일링 정보는 악성 코드에 대 한 공격 기법이나 공격자에 대한 라벨링을 포함한다. 사이버 위협 정보는 위의 전처리가 수행된 정보, 생성되거나 식별된 분석 정보, 생성된 예측 정보 또는 이 정보 들의 취합 정보나 이 정보들을 기반으로 결정된 정보를 포함할 수 있다. 제공되는 사이버 위협 정보에는 입력된 파일과 관련하여 데이터 베이스에 저장된 분석 정보를 이용하거나 위에 서 분석되거나 예측된 정보가 포함될 수 있다. 실시 예에 따르면 사용자가 입력된 파일에 대한 악성 행위뿐만 아니라 이미 저장된 파일이나 악성 행위에 대해 사이버 위협 정보를 조회할 경우 이에 대한 정보를 제공할 수 있다. 이러한 통합 분석 정보는 해당 파일에 대응하여 서버나 데이터 베이스에 표준화된 포맷으로 저장될 수 있다. 이 러한 통합 분석 정보는 표준화된 포맷으로 저장되어 사이버 위협 정보를 검색 또는 조회에 사용될 수 있다. 사용자의 사이버 위협 정보의 조회에 대항 추가적인 예시는 이하에서 상세히 후술한다. 도 2는 개시하는 실시 예에 따라 분석 정보 생성하는 과정에서 정적 분석 정보를 얻는 예를 개시한다. 개시하는 실시 예에 따른 정적 분석 정보를 획득하는 단계는, 입력된 파일의 구조 정보를 얻고 분석하는 단계를 포함할 수 있다(S2110). 실시 예는 파일이 실행되지 않는 환경에서 먼저 식별된 파일 기본적인 구조 정보를 분석할 수 있다. 이 단계에 서는 예를 들어 파일의 종류가 ELF(Executable and Linkable Format), PE(Portable Executable), APK(Android Application Package) 등에 파일 종류가 다르더라도 파일의 위 파일 구조나 그 구조로부터 추출할 수 있는 정보 를 획득하거나 분석한다. 참고로 예시하는 정적 분석에서 파일의 식별은 개시한 전처리 단계에서 수행될 수도 있는데 이러한 경우 S210 단계의 분석 단계는 전처리 단계와 함께 수행될 수 있다. 그리고 입력된 파일의 패턴 분석을 수행할 수 있다(S2120). 여기서는 식별된 파일에 대해 파일 패턴을 분석하는 경우로서 파일에 어떤 조치를 취하지 않고 파일 자체를 오 픈하여 추출할 수 있는 여러 스트링(string) 등을 확인하여 파일의 패턴을 얻을 수 있다. 입력된 파일이 제작과 관련된 정보를 얻고 분석할 수 있다(S2130). 실시 예는 파일이 가지고 있는 고유 정보나 메타 정보, 예를 들면 파일 제작자 정보, 실행 파일인 경우 코드사 이닝(codesigning) 정보 등을 얻을 수 있다. 그리고 입력된 파일의 환경 정보를 분석할 수 있다(S2140). 여기서는 대상 파일이 갖추어야 할 시스템 환경적 구성 요소 정보 등에 정보를 얻을 수 있다. 그리고 입력된 파일과 관련된 여러 가지 기타 정보들을 분석하고 저장한다(S2150). 이러한 파일의 수행 없이 파일 자체의 정적 정보를 특정 파일 포맷, 예를 들어 JSON (JavaScript Object Notation)과 같은 데이터 포맷 으로 저장할 수 있다. 정적 분석의 예는 파일 자체를 분석하는 것으로서 코딩 기반의 취약 항목 존재 여부, 인터페이스 또는 함수의 호출 구조 문제, 또는 파일의 바이너리 구조 등을 얻을 수 있다. 위에서 개시한 정적 정보를 분석하는 일 예를 편의상 플로우 차트로 나타내었으나, 위 단계들은 반드시 위에서 기술되거나 도면에서 표시된 순서로 수행될 필요가 없다. 또한 파일에 따라 이 도면에서 개시한 모든 단계를 수 행할 필요도 없으며 정적 분석 정보를 얻기 위해 일부 단계, 예를 들면 구조 정부 분석, 제작 관련 정보 분석 및 환경 정보 분석을 선택적으로 수행할 수도 있다. 즉 이에 대한 실시 순서와 실시 단계의 선택의 당업자의 선 택에 따라 달라질 수 있다. 개시된 실시 예에 따라 정적 분석 정보를 획득하는 예들을 간략하게 설명하면 다음과 같다. 정적 분석을 수행하는 일 예로서, 전처리 과정에서 입력된 파일의 해쉬(Hash) 값을 추출할 경우 추출된 파일의 해쉬 값과, 악성코드에 대해 이미 저장된 해쉬 값과 비교하여 상기 입력된 파일이 악성코드 여부를 분석할 수 있다. 분석된 기반으로 파일 내에 악성 코드가 있는지 탐지할 수 있다. 만약, 입력 파일이 모바일 데이터 인 경우 입력된 파일로부터 모바일 악성 의심 코드의 코드 정보를 추출한다. 여기서, 코드 정보란 모바일 악성 의심 코드를 실행하지 않고 코드 자체로부터 추출할 수 있는 정보를 의미하는 것으로, 예를 들어, 해쉬(Hash) 정보, 코드 크기 정보, 파일 헤더 정보, 코드 내에 포함되어 있는 식별 가능한 문자열 정보 및 동작 플랫폼 정보 등을 포함할 수 있다.설명한 바와 같이 이와 같이 획득된 정적 분석 정보는 해당 파일에 대응하여 저장될 수 있다. 도 3은 개시하는 실시 예에 따라 분석 정보 생성하는 과정에서 동적 분석 정보를 얻는 예를 개시한다. 전처리로부터 식별된 파일 정보 또는 정적 분석 정보 중 적어도 하나에 기반하여 식별된 파일의 실행 환경에서 실행된 결과 데이터에 따른 동적 분석 정보를 획득할 수 있다 개시하는 실시 예에 따른 동적 분석 정보를 획득하는 단계는 파일이 실행 중인 환경에서 다양한 입출력 데이터 를 분석하거나 또는 파일 실행 시 실행 환경과 상호작용의 변화를 분석하여 취약하거나 위험한 이상현상을 탐지 하는 단계이다. 일반적으로 가상화 환경에서 파일을 직접적으로 실행하여 이상 여부를 분석한다. 동적 분석을 수행하기 위해 실시 예는 입력 파일을 실행하기 위한 동적 분석 환경을 생성하고 준비한다(S2210). 입력된 파일의 타입을 식별한 경우 각각의 파일의 타입에 따라 어떤 실행 환경이 필요한지 알 수 있다. 예를 들 면 파일에 따라 윈도우 운영체제, 리눅스 운영체제, 모바일 기기 운영체제에서 실행되는 파일인지 식별할 수 있 다. 준비된 분석 환경에서 악성 코드 여부를 판별하기 위해 획득된 파일을 실행한다(S2220). 동적 분석 정보를 획득하기 위해 이러한 실행 환경에서 파일을 실행하여 해당 시스템에서 발생하는 이벤트를 수 집할 수 있다(S2230). 예를 파일 자체, 프로세스, 메모리, 레지스트리, 네트워크의 시스템에 대한 이벤트 또는 각 시스템의 설정을 변경시키는 이벤트를 수집할 수 있다. 그리고, 수집된 이벤트들을 개별적으로 또는 취합하 여 분석한다. 수집된 결과를 취합한 후 동적 분석을 위한 환경을 다시 복구한다(S2240). 이와 같이 획득된 결과는 해당 파일에 대응된 동적 분석 정보로 저장될 수 있다. 이하에서 이와 같은 동적 분석 정보를 획득하는 실시 예에 따라 동적 분석 정보를 수집하고 분석하는 예를 간략 하게 개시한다. 동적 분석의 일 실시 예로서, 입력된 파일이 모바일 기기 운영 체제에서 동작하는 파일로 식별된 경우, 파일을 모바일 단말 또는 모바일 단말 환경과 동일하게 구성된 에뮬레이터나 가상화 환경에서 직접 실행한다. 그리고 파일 내에 모바일 악성 의심 코드가 실행된 후에 단말에 발생하는 모든 변화, 즉 행위 정보를 추출하고 기록한 다. 행위 정보는 단말의 운영체제(OS) 환경에 따라 상이하나, 통상적으로 프로세스, 파일, 메모리 및 네트워크 정보 등의 이벤트 정보를 포함할 수 있다. 동적 분석의 다른 실시 예로서 전처리 과정에서 입력된 파일의 해쉬(Hash) 값을 추출되지 않고 사용자 단말에서 해쉬 값이 추출된 경우라도, 단말에서 추출된 파일의 해쉬 값을 인텔리전스 플랫폼을 통해 수신할 수 있다. 데이터베이스에 해당 파일의 해쉬 값이 이미 저장되지 않는 경우 수신된 파일을 가상 또는 실제의 운영체제에서 실행시키고, 실행 시에 발생되는 행위를 실시간으로 수집하고 수집된 동적분석 정보를 데이터베이스에 이미 저 장된 정보와 비교할 수 있다. 상기 비교 결과 이미 정의된 위험도를 초과하는 경우 입력된 파일이 악성 코드를 포함하고 있다고 판단할 수 있 고, 해당 파일의 해쉬 값을 데이터 베이스에 저장하여 추후 정적 분석 등에 이용할 수 있다. 악성 코드에 따라 행위 주체가 되는 제 1 프로세스가 시스템에 위험한 행위를 발생하는 경우도 있다. 그러나, 경우에 따라 상기 제 1 의 프로세스의 행위가 추가적으로 자식 프로세스인 제 2 프로세스를 추가로 생성하고 상 기 제 2 프로세스가 시스템에 악성 행위를 수행하는 경우도 있다. 이러한 경우, 동적 분석의 일 실시 예는 최초의 제 1 의 프로세스의 행위가 실행 시스템에 발생시키는 이벤트들 을 저장하고, 추가적으로 제 1 프로세스의 자식 프로세스인 제 2 프로세스를 추출 또는 확인하여 상기 제 2 프 로세스에 따른 악성 행위의 이벤트를 저장할 수도 있다. 이와 같이 이 예에서 동적 분석은 최초의 제 1 프로세 스와 그와 연결될 제 2, 3의 프로세스의 이벤트 정보도 종합적으로 분석하여 식별된 파일이 악성 코드를 포함하 는지 판단할 수 있다. 입력된 파일의 실행 결과에 따라 알려지지 않은 악성 코드의 특성이 없는 경우는 악성 코드의 특성을 가지고 있 더라도 탐지하기 어려운 경우 있다. 이러한 경우 동적 분석의 또 다른 실시 예는 식별된 파일이 실행 시에 외부 와 통신하는 네트워크 프로세스를 모니터링하고 분석하여 상기 실행 프로세스의 악성 행위를 탐지할 수 있다. 예를 들면 식별된 파일을 실행한 경우 외부와 통신하는 네트워크 이벤트를 모니터링할 수 있다. 파일 실행에 따 라 로컬 어드레스 오브젝트(local address object)를 생성한 프로세스 아이디(Process IDentifier, PID)를 저 장한다. 그리고, 상기 파일 실행과 관련된 네트워크 이벤트가 발생될 경우 해당 네트워크 이벤트의 IRP(Interior Router Protocol) 정보로부터 로컬 어드레스 오브젝트 정보들을 추출할 수 있다. 상기 프로세스 아이디가 생성한 로컬 어드레스 오브젝트와 상기 네트워크 이벤트와 관련된 로컬 어드레스 오브 젝트들을 비교하여 악성 행위를 판단하는 동적 분석을 수행할 수 있다. 예를 들면 상기 네트워크 이벤트에 따라 송수신되는 패킷의 패턴이나 또는 패킷 전송을 유발하는 C&C (Control and Command) 서버를 확인하여 악성 행위 여부를 판단할 수 있다. 동적 분석의 또 다른 실시 예로서, 주소 결정 프로토콜(Address Resolution Protocol, ARP) 스푸핑 (spoofing) 공격을 방지하기 위해 ARP 정보를 모니터닝할 수도 있다. 일반적으로 로컬 영역 네트워크에서 장비의 IP(internet protocol) 주소와 MAC (media access control) 주소간의 대응은 ARP 이나 Neighbor Discovery Protocol (NDP) 이 사용될 수 있다. ARP 스푸핑 공격은 공격자가 IP 패킷을 전송할 경우 수신 네트워크 장비의 MAC 주소가 아닌 자신의 MAC 주소에 대응하는 ARP 메시지를 전송하여 이루어진다. 전송된 메시지를 수신한 네트워크 장비는 전송 패킷을 정상적인 IP 주소가 아닌 공격자로 전송하도록 한다. 실시 예는 이러한 공격에 대응하기 위하여 네트워크 장비들로부터 직접 수집된 ARP 정보와, 가상 네트워크에 포 함된 네트워크 장비들의 SNMP (Simple Network Management Protocol) 정보 내의 ARP 정보를 비교함으로써 ARP 스푸핑 공격 발생 여부를 판단할 수 있다. 즉, 동적 분석의 일 실시 예는, 호스트가 네트워크에 연결된 장비들에 ARP 정보 요청 메시지를 전송하여 회신된 ARP 응답 메시지에 포함된 제 1 ARP 정보와, 가상 네트워크에 접속된 장비들의 SNMP 정보 내에 포함된 제 2 ARP 정보를 비교하여 제 1 ARP 정보와 제 2 ARP 정보가 다른 경우 ARP 스푸닝 공격이 발생했다고 판단할 수 있다. 이 실시 예는 이러한 동적 분석의 방식을 이용하여 ARP 스푸핑 공격을 탐지하고 호스트 장비에 저장될 기밀 정 보 유출을 방지할 수 있다. 동적 분석 방식의 또 다른 실시에는 가상 환경을 회피하도록 하는 악성 코드를 분석할 수 있는 방법이다. 여기 서 관리 서버와 네트워크를 통해 연결된 단말은 관리 서버에 저장된 제 1 OS (operating system) 이미지를 이용 해 부팅을 수행할 수 있다. 단말이 부팅된 후 상기 제 1 OS에 기초하여 악성 코드를 분석한 후, 상기 단말은 관 리 서버로부터 제 2 OS 이미지를 수신하고, 수신된 제 2 OS 이미지를 이용해 초기화를 수행한다. 그리고 상기 단말이 악성 코드가 분석 종료된 시그니처를 상기 관리 서버로 전송하도록 한다. 따라서, 제 1 OS에 기초하여 악성 코드를 분석 후에 발행된 악성 행위가 있더라도 상기 관리 서버는 단말이 제 1 OS을 단말에서 삭제하도록 하고 원본 OS 이미지와 동일한 제 2 OS를 기초로 단말이 부팅하도록 함으로써 단말에 악성 행위 발생을 방지하 도록 할 수 있다. 악성 코드는 외부의 서버와 통신하며 추가적인 명령을 발생시키고 파일을 수신하도록 할 수 있다. 그런데 동적 분석을 수행할 수 있는 서버가 중지된 경우는 이러한 동적 분석에 매우 오랜 시간이 소요될 수 있 고 해당 행위가 사전 차단된 경우에도 동적 분석을 수행할 수 없는 경우가 있다. 동적 분석을 통해 네트워크 행위를 분석하기 위해서는 악성 코드가 사용하는 명령 제어 서버(C&C 서버), 추가적 인 악성 코드를 다운로드하기 위한 다운로드 서버 또는 악성 코드들끼리 정보를 주고 받거나 해커와 정보를 주 고 받는 커뮤니케이션 패킷 등의 정보를 추출하여 분석해야 한다. 그러나, 이와 같이 관련 서버가 작동하지 않 는 경우에는 그러한 정보의 추출할 수 없다. 여기서 개시하는 동적 분석 방법의 또 다른 실시 예는 서버가 동작 중지된 경우에도 동적 분석을 수행하도록 할 수 있다. 예를 들어 네트워크 접속 유도 장치가 악성 코드에 감염된 클라이언트 단말과 관리 서버에 사이에서 단말의 접 속 요청을 처리하도록 하여 동적 분석을 진행하도록 할 수도 있다. 네트워크 접속 유도 장치는 단말로부터 접속요청을 수신하고 이를 악성 코드 행위를 유발시키는 C&C 서버로 전달하도록 할 수 있다. 그리고, 만약 상기 네 트워크 접속 유도 장치가 일정 시간 내에 C&C 서버로부터 응답 패킷을 수신하지 못하면, 상기 네트워크 접속 유 도 장치는 별도의 가상의 응답 패킷과 접속 요청을 함께 상기 단말에 전송하도록 한다. 이후에 상기 단말로부터 수신된 악성 코드 분석에 관련된 데이터를 추출할 수 있다. 가상의 응답 패킷을 이용하는 예는 가상의 응답 패킷 TCP 세션을 생성하기 위한 패킷 형식이면 충분하다. 악성 코드가 사용하는 일반적인 TCP (Transmission Control Protocol) 프로토콜은 TCP 세션만 생성하도록 상기 클라 이언트 단말이 전송하는 데이터 패킷을 생성할 수 있다. 그리고 상기 데이터 패킷으로부터 악성 코드의 동적 분 석에 필요한 중요 정보들을 추출할 수 있다. 이와 같이 하면 관리 서버가 동작하지 않더라도 네트워크 접속 유 도 장치의 동작을 이용하여 동적 분석을 수행할 수 있다. 이와 같이 실시 예는 수신된 파일을 실행하여 발행하는 이벤트를 분석할 수 하고 동적 분석 정보를 데이터베이 스에 저장할 수 있다. 도 4는 개시하는 실시 예에 따라 분석 정보 생성하는 과정에서 심층 분석 정보를 얻는 예를 개시한다. 개시하는 실시 예에 따른 심적 분석 정보를 획득하는 단계는 수신된 파일 포함하는 실행 가능한 파일 디스어셈 블링(disassembling)하여 기계 언어 레벨에서 분석하여 악성 행위를 유발하는 공격 기법이나 공격자를 식별하는 특징을 포함한다. 심층 분석 정보는 기술한 정적 분석이나 동적 분석의 결과를 이용하여 얻을 수도 있고, 분석자의 해석 기준에 따라 실행 가능한 파일을 악성 행위를 유발하는 파일로 분석할 수 있다. 또한 심층 분석 정보는 파일 자체의 분석 정보나 또는 파일을 여러 번 가공한 정보를 포함할 수 있고 이미 저장 된 정보를 기반으로 수행될 수 있다. 심층 분석은 디스어셈블링(disassembling), 디스어셈블된 기계언어레벨의 코드추출, 공격행위(TTP)식별, 공격자 식별, 테인트분석(taint analysis)을 수행하는 단계를 포함할 수 있다. 도면을 참조하여 상세히 예시하면 다음과 같다. 입력된 파일이 실행 가능한 파일을 포함할 경우 심층 분석은 실행 가능한 파일을 디스어셈블(disassemble)한다 (S2410). 디스어셈블(disassemble)된 어셈블리 코드(assembly code)들은 OP-CODE(operation code)와 피연산자(operand) 를 포함할 수 있다. OP-CODE(operation code)는 명령어 코드로 호칭할 수는 기계 언어 명령어를 나타내고, 피연 산자(operand)는 실행 동작에 필요한 정보, 즉 기계 언어 명령어의 대상 데이터나 메모리 위치를 나타낸다. 이하에서는 편의상 디스어셈블(disassemble)된 어셈블리 코드(assembly code)들 중 OP-CODE를 제외한 부분을 ASM-CODE로 호칭하도록 한다. 따라서, 이하에서 ASM-CODE 는 피연산자(operand) 부분을 포함할 수 있다. 디스어셈블링(disassembling)을 통해 오브젝트 코드 형식의 실행 가능한 파일은 특정 형식, 예를 들면 어셈블러 언어 형식의 코드 또는 디스어셈블된 코드로 변환된다. 이러한 디스어셈블된 코드로부터 일정 형식을 가진 OP- CODE (operation code) 와 ASM-CODE를 추출할 수 있다 (S2420). 추출된 디스어셈블드 코드를 일정 형식의 데이터 포맷을 변환할 수 있다. 일정 형식의 데이터 포맷의 변환 예시 는 아래에서 개시한다. 심층 분석은 추출된 디스어셈블된 코드나 상기 일정 형식으로 변환된 데이터 포맷을 기반으로 공격행위를 식별 할 수 있다(S2430). 디스어셈블된 코드 내에 OP-CODE는 수행될 연산을 특정하는 기계 언어 명령어의 일부인데, 사이버 보안 상 공격 행위 또는 공격 기법(Terrorist Tactics, Techniques, and Procedures, 이하 TTP)을 유발하는 OP-CODE는 해당 공격 행위 별로 매우 유사한 값이나 포맷을 가질 수 있다. 따라서, 이러한 OP-CODE와 ASM-CODE 를 분석하면 특 정 공격 행위를 구별할 수 있다. 실행 가능한 파일로부터 디스어셈블된 코드들을 추출하고 추출된 디스어셈블된 코드들은 실행 함수에 따라 분리 될 수 있다. 예를 들면 디스어셈블된 코드로부터 추출된 OP-CODE와 ASM-CODE 또는 상기 디스어셈블된 코드의 재조합된 코드 는 퍼지 해쉬(Fuzzy Hashing) 방식 또는 CTPH (context triggered piecewise hashes) 방식 등의 해쉬 값이나 이를 일정 형식의 코드로 변환할 수 있다. 실시 예는 실행 가능한 파일의 디스어셈블된 코드를 일정 형식으로 변환하고 사이버 보안 전문가 집단들이 공통 적으로 인정하는 공격 행위 세부 요소들로 매칭하도록 하여 그 공격행위를 식별할 수 있다. 그리고 이미 추출된 디스어셈블된 코드들과 공격행위(TTP) 별 매칭 관계를 저장한 데이터베이스에 기반하여 공 격행위(TTP)를 식별하도록 할 수 있다. 이 경우 추출된 디스어셈블된 코드들의 CTPH 알고리즘에 따른 퍼지 해쉬 값이나 이를 일정 형식으로 변환한 데이터와 공격 행위(TTP) 별 매칭 유사도를 고속으로 수행할 수 있다. 이러한 보안 전문가 집단의 공격 행위를 저장한 데이터 베이스의 일 예로서 MITRE ATT&CK 등의 정보를 저장한 데이터베이스를 예로 들 수 있다. MITRE ATT&CK은 실제 보안 공격 기법이나 행위에 대한 데이터 베이스의 하나 로서, 특정 보안 공격 기법이나 행위들을 매트릭스 형식의 구성 요소들로 표시함으로써, 공격 기법과 행위들을 일정한 데이터 세트 형식으로 식별할 수 있도록 한다. MITRE ATT&CK는 해커 또는 악성 코드의 공격 기법에 대한 내용을 공격의 단계 별로 분류하여 CVE 코드(Common Vulnerabilities and Exposures Code)의 매트릭스로 표현한다. 실시 예는 디스어셈블된 코드를 분석함으로써 여러 가지 공격 행위들 중 특정 공격 행위를 식별하되, 식별된 타 입의 공격 행위가 전문가 단체들이 인정하는 실제 수행되는 공격 코드들에 매칭되도록 함으로써 공격 행위 식 별이 전문적이면서 공통으로 인식되는 요소들로 표현되도록 할 수 있다. 디스어셈블된 코드 내에 OP-CODE는 특정 행위를 유발시키는 기계 언어 명령어이므로, 동일한 공격 행위를 유발 하는 파일의 OP-CODE 는 매우 유사할 수 있다. 그러나 동일 공격 행위와 이를 유발하는 파일에 포함된 OP- CODE가 정확하게 완전히 동일한 것은 아니므로, 실시 예는 OP-CODE를 포함하는 디스어셈블링된 코드에 대해 인 공 지능 기반의 머신 러닝을 수행하도록 할 수 있다. 머신 러닝이 수행되면 임계 치 이상의 유사도를 가진 공격 코드의 포함 여부와 공격 코드의 공격 기법이 식별될 수 있다. 따라서, 동일한 악성 행위를 유발시키는 파일들의 디스어셈블링된 코드들이 완전히 동일하지 않더라도 디스어셈 블링된 코드기반으로 악성 행위를 수행하는 파일을 식별할 수 있다. 머신 러닝 알고리즘으로 Perceptron, Logistic Regression, Support Vector Machines, Multilayer Perceptron 등의 알고리즘이 사용될 수 있다. 디스어셈블된 코드들의 퍼지 해쉬 값들의 유사도를 AI(Artificial Intelligence; 이하 AI) 알고리즘을 이용하여 기존에 학습된 MITRE ATT&CK과 같은 공격 기법의 공격 코드들로 매칭하여 최종적으로 악성 코드임을 탐지할 수 있다 그리고 실시 예는 인공 지능 머신 러닝의 결과를 이용하면 보다 정확성을 가지고 신속하게 디스어셈블된 코드에 대응되는 공격 행위 또는 공격 행위의 취약 요소들을 식별할 수 있다. 이에 대한 구체적인 실시 예들은 이하에서 도면을 참고하여 상세히 개시한다. 심층 분석의 실시 예는 디스어셈블된 코드와 인공 지능 기반의 머신 러닝 결과를 이용해 유사 공격 행위를 유발 하는 공격자도 식별하는 단계를 포함할 수도 있다(S2440). 마찬가지로 공격자 식별에 대한 구체적인 예는 후술 한다 그리고 심층 분석의 실시 예는 파일이 없는(fileless) 악성 코드의 경우도 특정 시점에서 시스템의 메모리 분석 을 통해 공격 행위가 있는지 여부에 대해 판단할 수 있는 테인트분석(taint analysis)을 포함할 수 있다 (S2450). 심층 분석은 실행 파일의 디스어셈블링된 코드를 처리하는 것에 기반하며 이에 따른 공격 기법이나 공격자의 식 별, 또는 테인트 분석은 선택적으로 수행될 수도 있다. 이와 같이 수행된 최종 심층 분석 정보는 해당 파일에 대응되는 심층 분석 정보로 데이터베이스에 저장할 수 있 다. 도 5는 심층 분석의 일 예로서 악성 코드를 디스어셈블링하여 악성 행위가 포함된 파일임을 판단하는 예를 개시 한다. 기술한 바와 같이 실행 가능한 파일을 디스어셈블링을 수행하면 어셈블리 언어 형식의 코드의 형식인 OP-CODE 와 ASM-CODE를 얻을 수 있다. 예를 들어 EXE 실행 파일 내에 특정 함수 A는 디스어셈블러(disassembler)를 거치면 OP-CODE를 포함하는 디스어 셈블링된 코드 또는 디스어셈블드 코드(disassembled cocde)로 변환될 수 있다. 만약 EXE 실행 파일이 악성 행위를 유발하는 악성 코드인 경우, 이러한 행위를 유발하는 함수나 코드 부분을 디 스어셈블링하면 악성 행위를 유발하는 디스어셈블드 코드 세트를 얻을 수 있다. 디스어셈블드 코드 세트는 상기 악성 행위 또는 악성 코드에 대응되는 OP-CODE 세트 또는 OP-CODE 와 ASM- CODE가 조합된 세트를 포함할 수 있다. 악성 행위가 동일하더라도 이를 수행하도록 하는 악성 코드의 알고리즘이나 실행 파일의 디스어셈블링 결과가 정확하게 같지 않기 때문에 인공 지능 기반의 유사도 분석을 통해 입력된 악성 코드가 특정 디스어셈블드 코드 세트와 대응되는지를 식별할 수 있다. 이렇게 특정 디스어셈블드 코드 세트와 대응되는 악성 행위를, MITRE ATT&CK와 같은 전문적이고 공용의 공격 방 식 또는 공격 기법에 대응시켜 공격 기법 (TTP)를 식별하는데 사용할 수 있다. 또는 특정 디스어셈블드 코드 내 OP-CODE 세트 또는 OP-CODE 와 ASM-CODE가 조합된 세트를 MITRE ATT&CK에서 정의한 공격 기법 요소들과 대응시켜 공격 기법을 판단하는데 사용할 수 있다. 이 도면은 실행 파일, 해당 실행 파일의 디스어셈블드 코드 세트와 MITRE ATT&CK에서 공격 기법 요소들에 대응 되는 공격 기법을 대응한 예를 나타낸다. 도 6은 개시하는 실시 예에 따라 분석 정보 생성하는 과정에서 연관관계 분석 정보를 산출하는 일 예를 개시한 다. 상기 얻은 여러 가지 분석 정보들은 사이버 위협 침해 정보로 이용될 수 있는데, 사이버 위협 침해 정보에 기반 해 공격자 또는 공격 기법의 연관관계를 나타내는 연관관계 분석 정보를 생성한다. 사이버 위협 침해 정보(indicator of compromise, IoC)는 시스템이나 네트워크 상에 발생하는 실제 또는 잠재적 인 사이버 보안 위협 행위, 공격 행위 또는 악성 행위를 식별하는 여러 가지 정보들을 지칭한다. 예를 들면, 사 이버 위협 침해 정보(IoC)는 이러한 행위들을 지칭하는 파일, 로그 정보 상에 나타나는 여러 흔적들, 파일 자체, 경로 등 또는 이런 행위를 추론하도록 하는 정보들을 나타낸다. 이미 분석된 정적, 동적, 심층 분석 정보 등과 식별된 파일을 이용하여, 분석 정보와 공격 행위 사이의 IP 정보 의 연관관계(S2510), 이메일에 포함되거나 웹사이트의 호스트네임의 연관관계(S2520), URL의 연관관계(S2530), 파일의 코드사인(codesign)의 연관 관계들(S2540)을 얻을 수 있다. 여기서 예시하는 연관관계 분석 정보를 획득하는 과정은 일 예로서 반드시 예시한 순서를 따르거나 모든 연관관 계가 분석되어야 하는 것은 아니다. 예를 들어 분석 정보와 공격행위 사이의 IP 와 URL의 연관관계만 이용해도 관련 파일에 대한 연관관계를 얻어낼 수 있다. 이러한 연관관계 분석 정보는 정확하게 공격기법 또는 공격자를 추론하는데 사용될 수 있다. 정적 분석, 동적 분석, 심층 분석 등으로 공격 행위나 공격자가 식별되지 않더라도 분석된 정보들 간의 연관관 계를 이용하면 공격 행위와 공격자를 추정할 수 있는 정보를 얻을 수 있다. 이에 대한 상세한 설명은 이하에서 도면을 참조하여 설명한다. 이러한 연관 관계 분석 정보는 수신되는 파일에 대해 지속적이고 누적적으로 저장하고 추후 새로운 파일을 수신 할 때마다 저장된 연관관계 분석 정보는 다시 업데이트할 수 있다. 위에서 분석한 여러 가지 분석 정보를 기반으로 사이버 위협 침해 정보를 얻는다. 그리고 사이버 위협 침해 정보(IoC)를 이용해 공격 행위나 공격자를 식별할 수 있는 여러 가지 연관관계 정보를 얻을 수 있다(S2550). 이러한 사이버 위협 침해 정보(IoC)는 추후에 공격 기법을 추론하는 연관관계 분석 정보를 얻는데 이용될 수 있 다. 연관 관계 분석과 이를 이용하여 공격자를 추적 또는 공격 행위를 추론할 수 있는 예는 이하에서 상세히 설 명한다. 그리고 획득된 연관관계 분석 정보는 해당 파일에 대응하여 다시 서버나 데이터 베이스에 저장될 수 있다. 설명한 바와 같이 위와 같이 분석된 정보들은 취합되어 중복 제거, 표준화, 인리치먼트 (enrichment) 과정을 통 해 표준화될 수 있다. 예를 들면 정적 분석 정보, 동적분석 정보, 심층분석 정보, 연관관계분석 정보들은 사용 자에게 제공되거나 추후 사이버 위협 정보를 갱신 또는 재생산하기 위해 표준화된 포맷으로 저장될 수 있다. 여기서 각 분석 정보들의 중복되거나 공통된 분석 정보는 중복된 부분을 제거하고, 부족한 부분의 데이터의 인 리치먼트(enrichment) 작업 등을 수행할 수 있다. 그리고 사용자의 조회 질의에 따라 또는 서비스 정책에 따라 사이버 위협 정보로 제공될 수 있다. 사이버 위협 정보로 제공에 대해서도 이하에서 상세히 설명한다. 이러한 사이버 위협 정보는 사용자에게 직접 제공될 수도 있고 아래에서 설명하는 사이버 위협 예측 정보로 생 성된 후 사용자의 요청이나 서비스에 따라 제공될 수도 있다. 도 7은 개시한 실시 예에 따라 연관관계 분석 정보를 얻는 과정의 일 예를 개시한 도면이다. 이 도면에서 파일 A-1 , A-2 , B-1 은 악성 행위를 유발할 수 있는 파일을 지칭하고, 서버 (가) , 서버 (나)는 악성 행위를 유발시키는 C&C 서버를 나타낸다. 개시한 실시 예에 따라 파일 A-1의 파일을 수신하여 동적 분석을 수행한 경우, 파일 A-1 실행 시에 서 버 (가) 를 접속하는 것을 확인하였다고 가정한다. 실시 예는 악성 코드에 대한 여러 가지 분석 정보를 저장하는 데이터 베이스로부터 파일 A-1 과 유사한 파 일 A-2 의 저장된 분석 정보를 얻을 수 있다. 파일 A-2 의 분석 정보로부터 동일한 서버인 서버 (가) 가 파일 A-1 과 파일 A-2 을 활용한다는 것을 파악할 수 있고 이러한 정보로부터 서버 (가) 는 동일 공격 기법 또는 동일 서버를 이용하는 해커임을 추정할 수 잇다. 실시 예에 따라 이미 분석된 파일인 파일 A-2 이 서버 (가) 뿐만 아니라 서버 (나) 도 접속하 는 경우 파일 A-2 의 연관 관계로서 서버 (나) 의 정보를 저장할 수 있다. 만약 파일 A-1 과 파일 A-2 과는 전혀 다른 파일이지만 파일 B-1 의 분석 정보가 서버 (나) 를 접속한 기록을 저장했다면 파일 형식이 다르지만 서버 (가) 와 서버 (나) 는 동일한 공격 자 그룹 또는 동일한 기법을 이용하는 공격자 그룹일 수 있다. 따라서, 이와 같이 파일과 관련된 여러 가지 분석 정보에 대해 연관관계를 분석하면 악성 행위를 유발하는 공격 자, 공격 기법 등에 대한 그룹핑 정보를 얻을 수 있고, 이러한 연관관계 분석 정보는 공격자나 공격자 그룹을 식별하는데 활용될 수 있다. 이하에서는 사이버 위협 예측 정보를 설명하는 예를 개시한다. 파일의 식별 정보와 얻은 분석 정보들 중 적어도 하나 이상의 정보를 이용하거나 취합한 데이터 세트에 기초하 여 사이버 위협 예측 정보를 생성할 수 있다 도 8은 실시 예에 따라 사이버 위협 정보의 예측 정보 생성하는 일 예를 개시한다. 도면을 참조하여 사이버 위 협 정보의 예측 정보를 생성하는 예를 설명하면 다음과 같다. 분석 정보에 대한 데이터 세트가 확보되면 그 데이터 세트를 기초로 추후에 발생할 공격 행위와 관련된 예측 정 보 생성이 가능하다. 위와 같이 추출된 분석 정보에 따른 데이터 세트를 인공 지능 기반의 학습 데이터 세트로 가공하고, 가공된 학 습 데이터 세트를 기초로 인공 지능 분석을 수행하면 공격 행위와 관련된 여러 가지 예측 정보 생성이 가능하다. 이렇게 생성된 예측 정보의 데이터 세트는 다시 새로운 학습 데이터 세트로 반복적으로 생성 또는 가공할 수 있 다. 이 도면의 실시 예는 위의 분석 정보의 데이터 세트를 인공 지능 학습을 통해 악성 코드 제작자의 예측 정보 (S3110), 악성 코드 공격 방법의 예측 정보(S3120), 악성 코드 공격 그룹의 예측 정보(S3130), 악성 코드 유사 도 예측 정보(S3140), 악성 코드 확산도 예측 정보(S3150) 등을 생성하는 예를 개시한다. 여기서 예측 정보의 순서는 일 예로서 예측 정보 획득의 순서의 변경이 가능하다. 예를 들면 악성 코드 유사도 예측 정보(S3140)와 악성 코드 확산도 예측 정보(S3150)의 순서는 변경될 수 있으며 나머지 예측 정보의 생성도 반드시 예시된 순서에 따를 필요가 없다. 또한 예시한 유사도 예측 정보 이외에 사이버 위협 정보와 관련된 추가적인 예측 정보 생성도 가능하다. 이렇게 생성한 악성 코드의 예측 정보는 자체 위험도를 예측하는 위험도 예측 정보와 공격자, 공격 그룹, 유사 도, 확산도 등을 각각 예측하는 예측 정보 또는 그 예측 정보를 종합적으로 표시하는 악성 코드의 종합 예측 정 보로 나뉘어 데이터베이스에 저장될 수 있다. 위와 같은 사이버 위협 정보의 분석 정보와 예측 정보를 이용하면 입력된 파일과 관련된 악성 코드의 종류를 식 별하고 이에 대한 위험도를 결정할 수 있다. 또한 입력된 파일과 관련된 악성 코드의 기록을 포함한 프로파일링 정보를 생성하여 저장될 수 있는데, 저장된 악성 코드와 관련된 분석 정보, 예측 정보, 위험도 또는 프로파일링 정보는 사용자가 이를 쉽게 조회할 수 있도 록 추가로 가공될 수 있다. 사용자에게 사이버 위협 정보를 제공하는 일 예를 개시하면 다음과 같다. 특정 파일을 기준으로 여러 가지 연관 관계 분석 정보가 발생될 수 있어서 사이버 위협 침해 정보(IoC)를 매우 많은 데이터 통신량이 필요할 수 있다. 실시 예는 사이버 보안의 위협에 신속하게 대처하기 위해서는 이러한 정 보를 빠른 시간 내에 공유, 저장, 조회, 및 업데이트할 수 있다. 위와 같은 분석 정보들에 기초하여 실시 예는 보안 이벤트가 발생하면 발생된 보안 이벤트에 관련된 사이버 위 협 침해 정보(IoC)를 암호화 소켓 통신을 통해 사이버 위협 침해 정보(IoC) 저장 서버나 다른 사용자 단말기들 에 P2P 소켓 통신을 이용해 조회를 요청할 수 있다. 그리고 사이버 위협 침해 정보(IoC) 저장 서버나 다른 사용 자 단말기들 중 사이버 위협 침해 정보(IoC)를 빨리 수신하는 정보를 사이버 위협 침해 정보(IoC)로 이용할 수 있다. 또 다른 예로서, 사이버 위협 정보를 제공하는 또 다른 예로서 사용자가 사용하는 단말에서 상기와 같이 분석된 악성 코드에 대한 정보를 조회할 경우 조회된 정보를 다음과 같이 제공할 수 있다. 예를 들어 사용자가 사용하는 단말이 파일의 해쉬 값을 산출한 경우, 산출된 해쉬 값에 대해 텍스트 형식으로 악성 코드 여부의 조회하는 질의를 서버로 전송할 수 있다. 해쉬 값과 질의를 수신한 서버가 위와 같이 악성 코 드 정보가 저장된 데이터 베이스에 상기 해쉬 값을 전달하고 이에 대한 조회 결과를 수신한다. 조회 결과를 수 신한 서버는 그 결과를 상기 해쉬 값에 대응되는 텍스트 값으로 사용자 단말에 다시 리턴할 수 있다. 저장된 악성 코드에 대한 정보를 기반으로 사용자의 요청에 따라 사이버 위협 정보를 제공하는 다른 예를 도면 을 참조하여 설명하면 다음과 같다. 도 9는 실시 예에 따라 사이버 위협 정보를 제공하기 위한 악성 코드 질의들의 예를 개시한다. 사이버 위협 정보 처리에 대한 실시 예는 위와 같이 산출한 분석 정보와 예측 정보를 기초로 식별한 악성 코드 를 여러 가지 메타 정보와 함께 저장할 수 있다. 위에서 설명한 바와 같이 사용자는 악성 코드 정보가 저장된 데이터 베이스에 예시한 바와 같은 조회를 요청할 수 있다. Query (A)를 참고하면, 사용자는 실시 예에 따른 사이버 위협 정보가 저장된 데이터베이스에 Query (A)와 같이 악성 코드와 관련된 기간, 특정 악성 코드의 수량, 탐지명, 파일 타입, 유포지, 코드사인 및 파일 크기 등의 카 테고리로 악성 코드를 질의할 수 있다. 그러면 사이버 위협 정보가 저장된 데이터 베이스는 서버를 통해 Query 에 대응되는 사이버 위협 정보나 악성 코드 정보를 리턴한다. 다른 예로 사용자는 이 도면의 Query (B)에서 예시한 바와 같이 악성 코드와 관련된 특정일, 특정 악성 코드의 수량, 파일 타입, 유포지 여부, 자식 프로세스의 생성 여부 등을 질의할 수 있다. Query (C)에서 예시하는 바와 같이 사용자는 악성 코드와 관련된 기간, 특정 악성 코드의 수량, 파일 타입, 유 포지 정보, 파일 명 정보, 악성 코드 수행에 따른 공격 행위, 파일 크기에 정보를 이용하여 악성 코드에 대한 정보를 질의할 수 있다. Query (D)의 예는 악성 코드와 관련된 기간, 특정 악성 코드의 수량, 파일 타입, 유포지 주소 및 악성 코드의 통계 정보를 이용하여 악성 코드에 대한 정보를 질의할 수 있다. 설명한 바와 같이 사이버 위협 정보 처리 방법의 실시 예는 분석 정보, 예측 정보는 사용자의 조회 문의에 대해 대응되는 악성 코드 정보를 제공하기 위해 악성 코드에 위와 같은 조건에 맞는 정보를 데이터베이스에 함께 저 장한다. 따라서, 서버는 해당 질의 조건과 일치하는 악성 코드에 대한 정보를 데이터베이스부터 얻어 사용자에게 전송할 수 있다. 예시한 바와 같이 사용자는 파일의 여러 가지 메타 정보를 이용해 악성 코드 정보를 조회할 수 있다. 사용자는 보호해야 하는 정보나 시스템이 악성 코드에 의해 피해나 위협이 될 수 있는 정보를 미리 얻을 수 있다. 도 10은 사이버 위협 정보 처리 장치의 일 실시 예를 개시한 도면이다. 이 도면의 실시 예는 사이버 위협 정보 처리 장치를 개념적으로 예시하는데 이 도면을 참조하여 사이버 위협 정보 처리 장치의 실시 예를 설명하면 다 음과 같다. 개시하는 사이버 위협 정보 처리 장치는 물리장치인 데이터베이스 및 서버 및 데이터베이스 와 상기 물리장치 상에서 구동되는 응용 프로그래밍 인터페이스 Application Programming Interface, API) 포함하는 플랫폼 을 포함한다. 이하에서 플랫폼은 사이버 위협 인텔리전스 플랫폼(cyber threat intelligence platform; CTIP) 또는 간략하게 인텔리전스 플랫폼으로 호칭한다. 서버는 중앙연산장치(central processing unit, CPU) 나 프로세서와 같은 연산장치를 포함하고 데이터베 이스에 데이터를 저장하거나 읽을 수 있다. 서버는 입력되는 보안 관련 데이터를 연산 및 처리하며 파일을 실행하여 여러 가지 보안 이벤트를 발생시 키고 관련된 데이터를 처리하도록 한다. 그리고 서버는 여러 가지 사이버 보안 관련 데이터의 입출력을 제어하고 인텔리전스 플랫폼에서 처리된 데이터를 데이터베이스에 저장할 수 있다. 서버는 데이터 입력을 위한 네트워크 장치나 네트워크의 보안 장치를 포함할 수 있다. 서버의 중앙 처리장치, 프로세서 또는 연산장치는 이하의 도면에서 예시하는 프레임워크나 해당 프레임 워크 내의 모듈을 수 행할 수 있다. 실시 예에 따른 인텔리전스 플랫폼은 사이버 위협 정보의 처리를 위한 응용 프로그래밍 인터페이스(AP I)를 제공한다. 예를 들어 인텔리전스 플랫폼은, 네트워크와 연결된 네트워크 보안 장치나 악성 행위를 스캔 및 감지하는 사이버 악성 행위 방지 프로그래밍 소프트웨어로부터 파일이나 데이터를 입력받을 수 있다. 예를 들어 실시 예에 따른 인텔리전스 플랫폼은 보안 이벤트를 제공하는 SIEM (Security Information and Event Management) API, 실행 환경에 대한 데이터를 제공하는 EDR (Environmental Data Retrieval) API, 네트워크 트래픽을 정의된 보안 정책에 따라 모니터하고 제어하는 파이어월(firewall) API 등의 기능을 제공할 수 있다. 또한 인텔리전스 플랫폼은 내부와 외부 네트워크 사이에 방화벽과 유사한 역할을 수행하는 IPS (Intrusion Prevention Systems )의 API의 역할도 제공할 수 있다. 실시 예에 따른 인텔리전스 플랫폼의 응용 프로그래밍 인터페이스(API)는 사이버 보안의 공격 행 위를 수행하는 악성 코드를 포함하는 파일들을 여러 클라이언트 기기들 (1010, 1020, 1030) 로부터 수신할 수있다. 실시 예에 따른 인텔리전스 플랫폼은 전처리부(미도시), 분석 프레임 워크와 예측 프레임 워크 및 AI 엔진 및 후처리부(미도시)을 포함할 수 있다. 인텔리전스 플랫폼의 전처리부는 클라이언트 기기들(1010, 1020, 1030)로부터 수신된 여러 가지 파일들 에 대한 사이버 위협 정보를 분석할 수 있도록 전처리를 수행한다. 예를 들면 전처리부는 수신된 파일을 처리하여 그 파일로부터 파일의 출처 정보, 파일을 얻은 수집 정보, 파일 의 사용자 정보 등을 포함한 여러 가지 메타 정보를 얻을 수 있다. 예를 들어 파일이 URL (uniform resource locator)을 포함하거나 또는 전자메일에 포함된 경우 파일에 대한 수집 정보를 얻을 수 있다. 사용자 정보는 파 일의 생성, 업로드 또는 최종 저장한 사용자 정보 등을 포함할 수 있다. 전처리 과정에서 파일의 메타 정보로서 IP(internet protocol) 정보, 이에 기반한 국가 정보, API(Application Programming Interface) key 정보 등을 얻을 수 있다. 인텔리전스 플랫폼의 전처리부(미도시)는 입력된 파일의 해쉬(Hash) 값을 추출할 수 있다. 해쉬 값이 이 미 사이버 위협 정보 처리 장치에 알려진 것이라면 이를 기반으로 파일의 종류를 식별할 수 있다. 만약 이미 알려진 파일이 아니라면 운영하는 C-TAS(Cyber Threats Analysis System), CTA(Cyber Threat Alliance)의 운영시스템, VitusTotal 등의 사이버 위협 정보의 레퍼런스 인터넷 사이트에 해쉬 값과 파일 정보 를 조회하여 파일 종류 식별을 위한 분석 정보를 얻을 수 있다. 설명한 바와 같이 입력된 파일의 해쉬 값은 MD5 (Message-Digest algorithm 5), SHA1 (Secure Hash Algorithm 1), SHA 256 등의 해쉬 함수의 해쉬 값이 될 수 있다. 분석 프레임 워크는 입력된 파일로부터 악성 코드에 대한 분석 정보를 생성할 수 있다. 분석 프레임 워크는 정적 분석 모듈, 동적분석 모듈, 심층분석 모듈 및 연관관계분석 모듈 등 여러 가지 분석 방식에 따른 분석 모듈을 포함할 수 있다. 정적 분석 모듈은 입력된 파일과 관련된 악성 행위의 분석 정보는 파일 자체에 대한 악성 코드 관련 정보 를 분석할 수 있다. 동적분석 모듈은 입력된 파일로부터 얻은 여러 가지 정보들을 기반으로 여러 행위를 수행함으로써 악성 코드 관련 정보를 분석할 수 있다. 심층분석 모듈은 입력된 파일과 관련된 실행 가능한 파일을 가공한 정보를 이용하거나 실행 가능한 파일 과 관련된 메모리 분석을 수행하여 악성 코드 관련 정보를 분석할 수 있다. 심층분석 모듈은 악성 행위 를 정확하게 식별할 수 있도록 인공 지능 분석을 포함할 수 있다. 연관관계분석 모듈은 입력된 파일과 관련하여 이미 저장된 분석 정보들이나 또는 생성된 분석 정보들을 서로 연관시켜 공격 행위나 공격자에 대한 연관 관계를 추정할 수 있는 연관관계 분석 정보를 포함할 수 있다. 분석 프레임 워크는 정적 분석 모듈, 동적분석 모듈, 심층분석 모듈 및 연관관계분석 모듈로부터 분석된 정보들을 악성 코드의 특성과 행위에 대한 분석 결과들을 서로 결합하고, 결합된 최종 정보를 사용자에게 제공할 수 있다. 예를 들어 분석 프레임 워크는 하나의 파일에 대한 정적 분석 정보, 동적 분석 정보, 심층 분석 정보, 연 관관계 분석 정보 등은 정확한 공격 기법과 공격자 식별을 위해 통합 분석할 수 있다. 분석 프레임 워크 는 분석 정보들 사이에 중복된 부분을 제거하고 분석 정보들 사이에 공통의 정보는 정확도를 높이는데 사용한다. 분석 프레임 워크는 제공하는 정보를 표준화할 수 있는데, 예를 들면 여러 분석과 경로를 통해 수집된 사 이버 위협 침해 정보(indicator of compromise, IoC)들을 노멀라이징(normalizing)하거나 인리치먼트 (enrichment) 작업한다. 그리고 최종 표준화된 악성 코드 또는 악성 행위에 대한 분석 정보를 생성할 수 있다. 분석 프레임 워크의 정적 분석 모듈, 동적분석 모듈, 심층분석 모듈 및 연관관계분석 모듈은 분석되는 데이터의 정확성을 높이기 위해 분석 대상 데이터에 인공지능 분석에 따른 머신 러닝이 나 딥 러닝 기법을 수행할 수 있다. AI 엔진은 분석 프레임 워크의 분석 정보 생성을 위해 인공지능 분석 알고리즘을 수행할 수 있다. 이러한 정보는 데이터 베이스에 저장될 수 있고 서버는 사용자나 클라이언트 요청에 따라 데이터 베이스에 저장된 악성 코드 또는 악성 행위에 대한 분석 정보를 사이버 위협 인텔리전스 정보로 제공할 수 있다. 예측 프레임 워크은 제1예측정보생성모듈, 제2예측정보생성모듈 등 예측 정보에 따라 다수 의 예측정보생성모듈들을 포함할 수 있다. 예측 프레임 워크은 분석 정확도를 높이기 위해 위의 분석된 여러 가지 정보의 데이터 세트를 이용하여 악성 행위의 발생 여부, 공격 기법, 공격자 그룹 등에 대한 예측 정 보를 생성할 수 있다. 예측 프레임 워크는 분석 프레임 워크가 분석한 분석 정보에 대한 데이터 세트를 기반으로 AI 엔진 을 이용하여 인공지능 분석 알고리즘을 수행하여 입력된 파일과 관련된 악성 행위에 대한 예측 정보를 생 성할 수 있다. AI 엔진은 분석 정보에 대한 데이터 세트에 대해 인공 지능 기반의 머신 러닝으로 학습하여 추가적인 분 석 정보를 생성하고, 추가 생성된 분석 정보는 다시 새로운 학습 데이터로서 인공 지능의 입력 데이터로 이용될 수 있다. 예측 프레임 워크가 생성하는 예측 정보는 악성 코드 제작자 정보, 악성 코드 공격 방법 정보, 악성 코드 공격 그룹 예측, 악성 코드 유사도 예측 정보, 및 악성 코드 확산도 예측 정보 등을 포함할 수 있다. 위와 같이 여러 가지 악성 코드나 공격 행위 등에 관련된 예측 정보를 생성한 예측 프레임 워크는 생성한 예측 정보들을 데이터베이스에 저장할 수 있다. 그리고 사용자의 요청에 따라 또는 공격 징후에 따라 생 성한 예측정보를 사용자에게 제공할 수 있다. 서버는 설명한 바와 같이 데이터 베이스에 저장된 분석 정보 또는 예측 정보에 대한 후처리 후 상 기 입력된 파일과 관련된 사이버 위협 정보를 제공할 수 있다. 서버의 프로세서는 생성된 분석 정보 또는 예측 정보에 기초하여 악성 코드 종류 및 악성 코드의 위험도 를 결정하는 작업을 수행한다. 서버의 프로세서는 악성 코드에 대한 프로파일링 정보를 생성할 수 있다. 데이터베이스는 파일 분 석을 통해 파일에 대한 자체 분석을 수행한 결과나 추가 및 예측 분석을 수행한 결과를 저장할 수 있다. 서버에 의해 사용자에게 제공되는 사이버 위협 정보는, 기술된 전처리가 수행된 정보, 생성되거나 식별된 분석 정보, 생성된 예측 정보 또는 이 정보들의 취합 정보나 이 정보들을 기반으로 결정된 정보를 포함할 수 있 다. 제공되는 사이버 위협 정보에는 입력된 파일과 관련하여 데이터 베이스에 저장된 분석 정보를 이용하거나 위에 서 분석되거나 예측된 정보가 포함될 수 있다. 실시 예에 따르면 사용자가 입력된 파일에 대한 악성 행위뿐만 아니라 이미 저장된 파일이나 악성 행위에 대해 사이버 위협 정보를 조회할 경우 이에 대한 정보를 제공할 수 있다. 이러한 통합 분석 정보는 해당 파일에 대응하여 서버나 데이터 베이스에 표준화된 포맷으로 저장될 수 있다. 이 러한 통합 분석 정보는 표준화된 포맷으로 저장되어 사이버 위협 정보를 검색 또는 조회하는데 사용될 수 있다. 도 11은 개시하는 실시 예에 따라 분석 프레임 워크 중 정적 분석 모듈의 기능을 상세히 설명하기 위한 일 예를 나타낸다. 이 도면을 참조하여 정적 분석 모듈의 수행 과정을 예시하면 다음과 같다. 개시한 바와 같이 인텔리전스 플랫폼의 분석 프레임 워크는 정적분석 모듈을 포함할 수 있 다. 정적분석 모듈은 파일 자체를 분석할 수 있는데, 파일 또는 파일의 메타 정보 등에 기초하여 코딩 기반 의 취약 항목 존재 여부, 인터페이스 또는 함수의 호출 구조 문제, 또는 파일의 바이너리 구조 등 파일과 관련 하여 악성 행위에 연관될 수 있는 정보를 얻을 수 있다. 정적분석 모듈은 파일구조분석 모듈, 파일패턴분석 모듈, 파일제작정보분석 모듈, 파일환경분석 모듈, 및 파일관련분석 모듈를 포함할 수 있다. 정적분석 모듈 중 파일구조분석 모듈는 파일이 실행되지 않는 환경에서 식별된 파일의 기본적인 구조 정보를 분석할 수 있다. 파일구조분석 모듈는 예를 들어 파일의 종류가 ELF(Executable and Linkable Format), PE(Portable Executable), APK(Android Application Package) 등에 파일 종류가 다르더라도 파일의 위 파일 구조나 그 구조 로부터 추출할 수 있는 정보를 획득하거나 분석한다. 파일패턴분석 모듈은 파일의 패턴 분석을 수행할 수 있는데, 식별된 파일에 어떤 조치를 취하지 않고 파 일 자체를 오픈하여 추출할 수 있는 여러 스트링(string) 등을 확인하여 파일의 패턴을 얻을 수 있다. 파일제작정보분석 모듈은 입력된 파일이 제작과 관련된 정보를 얻고 분석할 수 있다. 파일제작정보분석 모듈은 파일이 가지고 있는 고유 정보나 메타 정보, 예를 들면 파일 제작자 정보, 실행 파일인 경우 코 드사이닝(codesigning) 정보 등을 얻을 수 있다. 파일환경분석 모듈은 입력된 파일의 환경 정보를 분석할 수 있다. 파일환경분석 모듈은 대상 파 일이 갖추어야 할 시스템 환경적 구성 요소 정보 등에 정보를 얻을 수 있다. 파일관련분석 모듈은 그리고 입력된 파일과 관련된 여러 가지 기타 메타 정보들을 분석할 수 있다. 정적분석 모듈은 입력된 파일의 수행 없이 개시한 바와 같이 얻고 분석된 파일 자체의 정적 정보를 JSON (JavaScript Object Notation)과 같은 데이터 포맷으로 변환하여 데이터베이스에 저장할 수 있다. 서버는 데이터베이스에 저장된 파일에 대한 정적 분석 정보를 사용자에 제공할 수 있다. 분석프레임워크의 정적분석 모듈은 입력된 파일의 해쉬(Hash) 값과, 데이터베이스에 악성 코드에 대해 이미 저장된 해쉬 값을 비교하여 상기 입력된 파일이 악성코드 여부를 분석할 수 있다. 그리고 입 력 파일의 악성 코드에 대해 분석된 정보는 데이터베이스에 저장할 수 있다. 분석프레임워크의 정적분석 모듈은 입력 파일이 모바일 데이터 인 경우 입력된 파일로부터 모바 일 악성 의심 코드의 코드 정보를 추출할 수 있다. 악성 의심 코드의 코드 정보는 해쉬(Hash) 정보, 코드 크기 정보, 파일 헤더 정보, 코드 내에 포함되어 있는 식별 가능한 문자열 정보 및 동작 플랫폼 정보 등을 포함할 수 있다. 분석프레임워크의 정적분석 모듈은 분석한 분석정보를 기반으로 파일 내에 악성 코드가 있는지 탐지할 수 있다. 그리고 탐지된 악성 코드와 관련된 정적 분석 정보를 데이터베이스에 저장할 수 있다. 도 12는 개시하는 실시 예에 따라 분석 프레임 워크 중 동적분석 모듈의 기능을 상세히 설명하기 위한 일 예를 나타낸다. 이 도면을 참조하여 동적분석 모듈의 수행 과정을 예시하면 다음과 같다. 예시한 인텔리전스 플랫폼의 분석 프레임 워크는 동적분석 모듈을 포함할 수 있다. 동적 분석 모듈은 전처리된 파일 정보 또는 정적 분석 정보 중 적어도 하나에 기반하여 식별된 파일의 실행 환경에서 실행된 결과 데이터에 따른 동적 분석 정보를 획득할 수 있다. 동적분석 모듈은 파일이 실행 중인 환경에서 다양한 입출력 데이터를 분석하거나 또는 파일 실행 시 실 행 환경과 상호작용의 변화를 분석하여 취약하거나 위험한 이상현상을 탐지할 수 있다. 동적분석 모듈은 가상화 환경 등을 생성하고 생성된 가상화 환경에서 파일을 직접적으로 실행하여 이상 여부를 분석할 수 있다. 분석 프레임 워크의 동적분석 모듈은 환경준비 모듈, 파일실행 모듈, 행위수집 모 듈, 분석결과취합 모듈, 및 분석환경복구 모듈를 포함할 수 있다. 환경준비 모듈은 입력 파일과 관련된 실행 파일을 실행하기 위한 동적 분석 환경을 생성하고 준비한다. 환경준비 모듈은 실행 파일의 타입을 식별한 경우 각각의 파일의 타입에 따라 어떤 실행 환경이 필요한 지 식별할 수 있다. 예를 들면 파일에 따라 윈도우 운영체제, 리눅스 운영체제, 모바일 기기 운영체제에서 실행 되는 파일인지 식별할 수 있다. 환경준비 모듈은 실행 파일을 실행하기 위해 식별된 환경을 준비할 수 있다. 파일실행 모듈은 환경준비 모듈이 준비한 분석 환경에서 실행 파일이 악성 코드 포함하고 있는지 여부를 판별하기 위해 파일을 실행한다. 행위수집 모듈은 동적 분석 정보를 획득하기 위해 실행 환경에서 실행된 파일의 실행 중에 시스템에서 발생하는 이벤트를 수집할 수 있다. 예를 들어 행위수집 모듈은 파일 자체, 프로세스, 메모리, 레지스트 리, 네트워크의 시스템에 대한 이벤트 또는 각 시스템의 설정을 변경시키는 이벤트를 수집할 수 있다. 분석결과취합 모듈은 행위수집 모듈이 수집한 이벤트들을 개별적으로 또는 취합하여 분석한다. 분석환경복구 모듈은 수집된 결과를 취합한 후 동적 분석을 위한 환경을 다시 복구한다. 동적분석 모듈은 이와 같이 획득된 결과를 해당 파일 또는 파일의 악성 코드에 대응된 동적 분석 정보로 데이터베이스에 저장할 수 있다. 동적분석 모듈이 위 실시 예에 따라 동적 분석 정보를 수집하고 분석하는 예를 간략하게 개시하면 다음 과 같다. 동적 분석의 일 실시 예로서, 동적분석 모듈은 입력된 파일이 모바일 기기 운영 체제에서 동작하는 파일 로 식별된 경우, 파일을 모바일 단말 또는 모바일 단말 환경과 동일하게 구성된 에뮬레이터나 가상화 환경을 생 성할 수 있다. 그리고 동적분석 모듈은 생성한 에뮬레이터나 가상화 환경에서 상기 파일을 직접 실행할 수 있다. 동적분석 모듈은 파일 내에 모바일 악성 의심 코드가 실행된 후에 단말에 발생하는 모든 변화, 즉 행위 정보를 추출하고 기록할 수 있다. 행위 정보는 단말의 운영체제(OS) 환경이 다른 경우라도 프로세스, 파일, 메모리 및 네트워크 정보 등의 이벤트 정보를 포함할 수 있다. 동적 분석의 다른 실시 예로서 동적분석 모듈은 전처리 과정에서 입력된 파일의 해쉬(Hash) 값을 추출되 지 않고 사용자 단말에서 추출된 경우라도 단말에서 추출된 파일의 해쉬 값을 인텔리전스 플랫폼을 통해 수신할 수 있다. 데이터베이스에 해당 파일의 해쉬 값이 이미 저장되지 않는 경우 동적분석 모듈은 수신된 파일을 가상 또는 실제의 운영체제에서 실행시키고, 실행 시에 발생되는 행위를 실시간으로 수집하고 수집된 동적분석 정보를 데이터베이스에 이미 저장된 정보와 비교할 수 있다. 상기 비교 결과 이미 정의된 위험도를 초과하는 경우 입력된 파일이 악성 코드를 포함하고 있다고 판단할 수 있 고, 동적분석 모듈은 악성 코드에 대응되는 파일의 해쉬 값을 데이터베이스에 저장할 수 있다. 저 장된 악성 해쉬 값은 추후 정적 분석 등에 이용할 수 있다. 악성 코드는 외부의 서버와 통신하며 추가적인 명령을 발생시키고 파일을 수신하도록 할 수 있다. 그런데 동적 분석을 수행할 수 있는 플랫폼과 서버가 중지된 경우는 이러한 동적 분석에 매우 오랜 시간이 소요 될 수 있고 해당 행위가 사전 차단된 경우에도 동적 분석을 수행할 수 없는 경우가 있다. 실시 예에 따른 동적분석 모듈은 네트워크 행위를 분석할 경우, 악성 코드가 사용하는 명령 제어 서버 (C&C 서버), 추가적인 악성 코드를 다운로드하기 위한 다운로드 서버 또는 악성 코드들끼리 정보를 주고 받거나 해커와 정보를 주고 받는 커뮤니케이션 패킷 등의 정보를 추출하여 분석할 수 있다. 여기서 개시하는 동적분석 모듈은 서버가 동작 중지된 경우에도 동적 분석을 수행하도록 할 수 있 다. 예를 들어 네트워크 접속 유도 장치(미도시)가 악성 코드에 감염된 클라이언트 단말과 인텔리전스 플랫폼 또는 서버에 사이에서 단말의 접속 요청을 처리하도록 하여 동적 분석을 진행하도록 할 수도 있 다. 네트워크 접속 유도 장치(미도시)는 단말로부터 접속 요청을 수신하고 이를 악성 코드 행위를 유발시키는 C&C 서버로 전달하도록 할 수 있다. 그리고, 만약 상기 네트워크 접속 유도 장치가 일정 시간 내에 C&C 서버로부터 응답 패킷을 수신하지 못하면, 상기 네트워크 접속 유도 장치는 별도의 가상의 응답 패킷과 접속 요청을 함께 상기 단말에 전송하도록 한다. 이후에 상기 단말로부터 수신된 악성 코드 분석에 관련된 데이터를 추출할 수 있다. 가상의 응답 패킷을 이용하는 예는 가상의 응답 패킷 TCP 세션을 생성하기 위한 패킷 형식이면 충분하다. 악성 코드가 사용하는 일반적인 TCP (Transmission Control Protocol) 프로토콜은 TCP 세션만 생성하도록 상기 클라 이언트 단말이 전송하는 데이터 패킷을 생성할 수 있다. 그리고 상기 데이터 패킷으로부터 악성 코드의 동적 분 석에 필요한 중요 정보들을 추출할 수 있다. 이와 같이 하면 관리 서버가 동작하지 않더라도 네트워크 접속 유 도 장치의 동작을 이용하여 동적 분석을 수행할 수 있다. 도 13은 개시하는 실시 예에 따라 분석 프레임 워크 중 심층분석 모듈의 기능을 상세히 설명하기 위한 일 예를 나타낸다. 이 도면을 참조하여 심층분석 모듈의 수행 과정을 예시하면 다음과 같다. 인텔리전스 플랫폼의 분석 프레임 워크는 심층분석 모듈을 포함할 수 있다. 심층분석 모 듈은 수신된 파일 포함하는 실행 가능한 파일 디스어셈블링하여 기계 언어 레벨에서 분석하여 악성 행위 를 유발하는 공격 기법이나 공격자를 식별할 수 있다. 심층분석 모듈은 기술한 정적 분석이나 동적 분석의 기반으로 심층 분석 정보를 얻을 수도 있고, 분석자 의 해석 기준에 따라 실행 가능한 파일을 악성 행위를 유발하는 파일을 이용하여 분석할 수도 있다. 심층분석 모듈은 파일 자체의 분석 정보나 또는 파일을 여러 번 가공한 정보를 포함할 수 있고 이미 저 장된 정보를 기반으로 심층 분석 정보를 생성할 수 있다 심층분석 모듈은 또한, 심층 분석은 디스어셈블링(disassembling) 모듈, 기계언어코드추출 모듈 , 공격행위(TTP)식별 모듈, 공격자식별 모듈, 테인트분석(taint analysis)모듈를 포함할 수 있다. 분석 프레임 워크는 심층분석 모듈은 AI 엔진을 이용하여 인공 지능 기반의 머신 러닝 알 고리즘을 수행하고, 그 결과로 심층분석 정보를 얻을 수 있다. 디스어셈블링(disassembling) 모듈은 입력된 파일이 실행 가능한 파일을 포함할 경우 실행 가능한 파일 을 디스어셈블(disassemble)한다. 실행 가능한 파일이 디스어셈블링(disassembling)되면 오브젝트 코드 형식의 특정 형식, 예를 들면 어셈블러 언 어 형식의 코드로 변환된다. 기계언어코드추출모듈은 일정 형식을 가진 OP-CODE (operation code)와 ASM-CODE를 포함하는 디스어셈 블드 코드를 추출할 수 있다. 일정 형식을 가진 OP-CODE (operation code)는 악성 코드와 관련된 OP-CODE 부분 을 의미하는 것으로 추출된 OP-CODE를 포함하는 디스어셈블드 코드는 악성 코드 또는 악성 행위와 관련된 부분 을 지칭한다. 기계언어코드추출모듈은 디스어셈블드 코드를 일정 형식의 데이터 포맷을 변환할 수 있다. 일정 형식의 데이터 포맷의 변환 예시는 아래에서 개시한다. 실행 가능한 파일의 디스어셈블드 코드를 사이버 보안 전문가 집단들이 공통적으로 인정하는 공격 행위 세부 요 소들로 매칭하도록 하여 그 공격행위를 식별할 수 있다. 공격행위(TTP)식별 모듈은 추출된 디스어셈블드 코드나 일정 형식으로 변환된 포맷의 데이터를 기반으로 공격행위, 공격기법 및 공격 프로세스를 식별할 수 있다. 공격행위(TTP)식별 모듈은 실행 가능한 파일의 디스어셈블드 코드를 기반의 퍼지 해쉬 값을 사이버 보안 전문가 집단들이 공통적으로 인정하는 공격 행위 세부 요소들로 매칭하도록 하여 그 공격행위를 식별할 수 있다. 공격행위(TTP)식별 모듈은 이미 추출된 디스어셈블드 코드들과 공격행위(TTP) 별 매칭 관계를 저장한 데 이터베이스 또는 외부 레퍼런스 데이터베이스에 기반하여 공격행위(TTP)를 식별하도록 할 수 있다. 공격 행위(TTP)식별 모듈은 AI 엔진의 머신 러닝을 이용하여 추출된 디스어셈블드 코드들의 CTPH 알고 리즘 등의 퍼지 해쉬 값과 공격행위(TTP) 별 매칭 유사도를 고속으로 수행하여 공격행위 또는 공격기법을 분류 할 수 있다.. 디스어셈블드 코드 내 OP-CODE는 수행될 연산을 특정하는 기계 언어 명령어의 일부인데, 사이버 보안 상 공격기 법 또는 공격행위(Terrorist Tactics, Techniques, and Procedures, 이하 TTP)를 유발하는 OP-CODE 를 포함하 는 디스어셈블드 코드는 해당 공격 행위 별로 매우 유사한 값이나 포맷을 가질 수 있다. 따라서, 이러한 OP-CODE와 ASM-CODE의 조합인 디스어셈블드 코드를 분석하면 특정 타입의 공격 행위를 구별할 수 있다. 예를 들면 공격행위(TTP)식별 모듈는 실행 가능한 파일로부터 추출된 디스어셈블드 코드를 퍼지 해쉬 (Fuzzy Hashing) 방식 또는 CTPH (context triggered piecewise hashes) 방식의 해쉬 값으로 변환할 수 있다. 공격행위(TTP)식별 모듈과 함께 수행되는 AI 엔진의 머신 러닝 알고리즘으로 Perceptron, Logistic Regression, Support Vector Machines, Multilayer Perceptron 등의 알고리즘이 사용될 수 있다. 또 한 AI 엔진으로 앙상블 머신 러닝 알고리즘이나 자연어 처리 알고리즘도 사용할 수 있다. 이에 대한 예는 이하에서 상세히 개시한다. 보안 전문가 집단의 공격 행위를 저장한 데이터 베이스의 일 예로서 MITRE ATT&CK은 실제 보안 공격 기법이나 행위에 대한 데이터 베이스인데 공격행위(TTP)식별 모듈은 추출한 OP-CODE을 포함하는 디스어셈블드 코 드이 변환된 해쉬 값을 MITRE ATT&CK의 데이터베이스 상의 일정한 데이터 세트 형식 또는 식별자로 식별할 수 있도록 한다. MITRE ATT&CK는 해커 또는 악성 코드의 공격 기법에 대한 취약 요소들을 CVE 코드(Common Vulnerabilities and Exposures Code)의 매트릭스로 표현한다. 실시 예는 디스어셈블드 코드를 분석함으로써 여러 가지 공격 행위들 중 특정 공격 행위를 식별하되, 식별된 타 입의 공격 행위가 전문가 단체들이 인정하는 공격 행위의 요소들로 매칭되도록 함으로써 공격 행위 식별이 전문 적이면서 공통으로 인식되는 요소들로 표현되도록 할 수 있다. 설명한 바와 같이 OP-CODE는 특정 행위를 유발시키는 기계 언어 명령어이므로, 동일한 공격 행위를 유발하는 파 일의 디스어셈블드 코드는 매우 유사할 수 있다. 그러나 공격 행위와 이를 유발하는 파일의 디스어셈블드 코드 가 정확하게 매칭되는 것은 아니므로 코드 상 일부 차이가 있을 수 있다. 공격행위(TTP)식별 모듈은 추출한 디스어셈블드 코드를 일정 형식으로 변환한 코드에 대해 AI 엔진 의 머신 러닝 수행하도록 한다. 따라서, 동일한 악성 행위를 유발시키는 파일들의 OP-CODE들이 완전히 동 일하지 않더라도 공격행위(TTP)식별 모듈은 머신 러닝과 추출된 OP-CODE 기반의 퍼지 해쉬 값과 그에 대 응하는 공격 요소를 매칭하여 공격 행위 등을 식별할 수 있다. 공격행위(TTP)식별 모듈은 디스어셈블드 코드들의 유사도를 AI 알고리즘을 이용하여 MITRE ATT&CK과 같 은 공격 기법에 매칭하여 최종적으로 해당 파일이 악성 코드임을 탐지할 수 있다. 이에 대한 구체적인 예는 후술 한다. 공격자식별 모듈은 추출된 디스어셈블드 코드와 인공 지능 기반의 머신 러닝 결과를 이용해 유사 공격 행위를 유발하는 공격자도 식별하는 단계를 포함할 수도 있다. 마찬가지로 공격자 식별에 대한 구체적인 예는 후술한다 테인트분석(taint analysis)모듈은 파일이 없는(fileless) 악성 코드의 경우도 특정 시점에서 시스템의 메모리 분석을 통해 공격 행위가 있는지 여부에 대해 판단할 수 있다. 심층분석 모듈은 해당 파일이나 그 파일로부터 식별된 악성 코드에 대응되는 심층 분석 정보를 데이터베 이스에 저장할 수 있다. 도 14은 개시하는 실시 예에 따라 분석 프레임 워크 중 연관관계분석 모듈의 기능을 상세히 설명하기 위한 일 예를 나타낸다. 이 도면을 참조하여 연관관계분석 모듈의 수행 과정을 예시하면 다음과 같다. 인텔리전스 플랫폼의 분석 프레임 워크는 연관관계분석 모듈을 포함할 수 있다. 연관관계 분석 모듈은 분석 프레임 워크가 분석하는 여러 가지 분석 정보들을, 사이버 위협 침해 정보 (IoC)에 기반하여 공격자 또는 공격 기법 사이에 연관관계로 표현되도록 연관관계 분석 정보를 생성한다. 연관관계분석 모듈은 분석 정보와 공격 행위 사이의 IP 정보의 연관관계를 분석하는 제 1 연관관계분석 모듈, 이메일에 포함되거나 웹사이트 등에 포함된 호스트네임의 연관관계를 분석하는 제 2 연관관계분석 모듈 , URL의 연관관계를 분석하는 제 3 연관관계분석 모듈 , 파일의 코드사인(codesign)의 연관 관계를 분석하는 제 4 연관관계분석 모듈 , 공격 기법들 사이의 연관관계를 분석하는 제 5 연관관계분석 모듈 등을 포함할 수 있다.이 도면에 표시된 모듈들은 예시에 불과하며, 이 도면에 표시되지 않더라도 연관관계분석 모듈은 공격 기법과 공격자를 판단하기 위해 분석된 정보들 사이에 여러 가지 연관관계들을 분석할 수 있는 모듈들을 포함할 수 있다. 예를 들면 연관관계분석 모듈은 생성한 연관관계 정보들을 취합하거나 통합하는 통합 분석 모 듈을 포함할 수도 있다. 연관관계분석 모듈은 정확하게 공격기법 또는 공격자를 추론하는데 사용되는 연관관계 분석 정보를 생성 할 수 있다. 연관관계분석 모듈은 수신되는 파일이나 악성 코드에 대해 지속적이고 누적적으로 분석 정보들을 저장하 고 추후 새로운 파일이나 악성 코드가 분석될 때마다 관련된 연관관계 분석 정보를 다시 업데이트하여 데이터베 이스에 저장한다. 연관관계분석 모듈은 위에서 분석한 여러 가지 분석 정보(정적분석정보, 동적분석정보, 심층분석정보 등)를 기반으로 사이버 위협 침해 정보를 얻을 수 있다. 연관관계분석 모듈은 사이버 위협 침해 정보(IoC)를 이용해 공격 행위나 공격자를 식별할 수 있는 여러 가지 연관관계 정보를 얻을 수 있으며 이와 같이 분석된 연관관계 분석 정보를 데이터베이스에 저장할 수 있다. 위에서 개시한 바와 같이 인텔리전스 플랫폼의 분석 프레임 워크는 분석된 정보들을 종합하여 중 복 제거, 표준화, 인리치먼트 과정을 통해 표준화된 정보를 데이터베이스에 저장할 수 있다. 인텔리전스 플랫폼는 정적 분석 정보, 동적분석 정보, 심층분석 정보, 연관관계분석 정보들을 사이버 위 협 정보를 갱신 또는 재생산하기 위해 표준화된 포맷으로 데이터베이스에 저장할 수 있다. 여기서 인텔리전스 플랫폼는 각 분석 정보들의 중복되거나 공통된 분석 정보의 중복된 부분을 제거하고, 부족한 부분의 데이터의 인리치먼트(enrichment) 작업 등을 수행할 수 있다. 인텔리전스 플랫폼는 후 처리를 통해 표준화된 정보를 사이버 공격들의 방지하기 위해 고안된 표준인 STIX 이나 TAXII 등의 포맷으로 저장할 수 있다. 서버 는 사용자의 조회 질의에 따라 또는 서비스 정책에 따라 분석 프레임 워크가 생성한 분석 정 보 등을 표준화된 사이버 위협 정보로 제공할 수 있다. 사이버 위협 정보로 제공 방법에 대해서도 이하에서 상 세히 후술한다. 이러한 사이버 위협 정보는 사용자의 요청이나 서비스에 따라 제공할 수도 있다. 도 15는 개시하는 실시 예에 따라 예측 프레임 워크의 예측정보생성 모듈의 기능을 상세히 설명하기 위한 일 예 를 나타낸다. 이 도면을 참조하여 예측 프레임 워크의 수행 과정을 예시하면 다음과 같다. 예시한 인텔리전스 플랫폼의 예측 프레임 워크는 예측정보생성모듈을 포함할 수 있다. 예 측정보생성모듈은 생성하는 예측정보에 따라 다수의 정보예측모듈들을 포함할 수 있다. 이 예에서는 예 측정보생성모듈이 제1정보예측모듈, 제2정보예측모듈, 제3정보예측모듈, 제4정보예측 모듈, 및 제5정보예측모듈을 포함하는 예를 나타낸다. 예측 프레임 워크는 이전에 예시한 분석 프레임 워크(미도시)가 생성한 분석정보들을 이용할 수 있다. 예측 프레임 워크는 여러 가지 분석 정보들에 따른 데이터 세트를 인공 지능 기반의 학습 데이터 세트로 가공하고, AI 엔진은 가공된 학습 데이터 세트를 기초로 인공 지능 분석을 수행할 수 있다. 예측 프레임 워크과 AI 엔진의 수행을 통해 공격 행위와 관련된 여러 가지 예측 정보 생성할 수 있다. 이 예에서는 제1정보예측모듈는 인공 지능 학습을 통해 악성 코드 제작자의 예측 정보를 생성할 수 있다. 제2정보예측모듈는 악성 코드 공격 방법의 예측 정보를 생성하고 제3정보예측모듈는 악성 코드 공 격 그룹의 예측 정보를 생성할 수 있다. 그리고 제4정보예측모듈는 악성 코드 유사도 예측 정보를 생성하 고, 제5정보예측모듈는 악성 코드 확산도 예측 정보를 생성하는 예를 나타낸다. 구체적인 예측 정보의 생성의 예는 이하에서 후술한다. 예측 프레임 워크는 생성한 예측 정보를 데이터베이스에 저장할 수 있다. 예를 들면 예측 프레임 워크는 특정 악성 코드에 대해 그 악성코드의 위험 자체를 예측한 악성코드 위험 도 예측 정보를 생성하여 데이터베이스에 저장할 수 있다. 그리고 예측 프레임 워크는 특정 악성 코드에 대해 예측한 제작자, 공격방법, 공격 그룹, 유사도, 확산 도의 예측 정보를 데이터베이스에 저장할 수 있다. 개시한 바와 같이 인텔리전스 플랫폼은 분석 정보 또는 예측 정보에 기초하여 악성 코드 종류 및 악성 코 드의 위험도를 생성할 수 있다. 그리고 인텔리전스 플랫폼은 악성 코드에 대한 프로파일링 정보를 생성 할 수 있다. 인텔리전스 플랫폼은 파일 분석을 통해 파일에 대한 자체 분석을 수행한 결과나 추가 및 예측 분석을 수 행한 결과를 데이터베이스에 저장할 수 있다. 인텔리전스 플랫폼이 제공하는 사이버 위협 정보는, 위의 전처리를 수행한 정보, 생성한 분석 정보, 생 성한 예측 정보 또는 이 정보들의 취합 정보나 이 정보들을 기반으로 추가 후 처리된 정보를 포함할 수 있다. 따라서 제공되는 사이버 위협 정보에는 입력된 파일과 관련하여 통합 분석 이러한 예시한 인텔리전스 플랫폼에 의해 제공되는 통합 분석 정보는, 입력된 파일에 대응하여 서버 에 의해 데이터베이스에 표준화된 포맷으로 저장될 수 있다. 이러한 통합 분석 정보는 표준화된 포 맷으로 저장되어 사이버 위협 정보를 검색 또는 조회에 사용될 수 있다. 이하에서는 각 처리 단계 또는 모듈에 따른 상세한 실시 예들을 개시한다. 도 16은 개시하는 실시 예에 따라 정적 분석을 수행하는 일 예를 나타낸다. 도면을 참조하여 실시 예에 따른 정 적 분석 방법의 일 예를 설명하며 다음과 같다. 설명한 바와 같이 정적 분석을 수행하기 이전에 전처리 단계나 정적 분석의 초기 단계에서 파일의 종류를 식별 수 있다. 이 도면은 파일의 종류로서 편의상 ELF, EXE, ARK 파일이 식별된 경우를 예시하지만 실시예의 적용은 이에 국한되지 않는다. 악성코드의 정적 분석 또는 탐지는 위와 같은 파일 자체가 가지고 있는 성격과 기존에 확인된 패턴 데이터베이 스와 비교 하는 과정을 기반으로 동작할 수 있다. 정적 정보 추출기는 입력된 파일의 구조를 파싱하여 구조 정보를 얻을 수 있다. 파싱된 파일의 구조 상 패턴(pattern)은 데이터베이스(DB)에 이미 저장된 악성 코드의 패턴과 비교될 수 있다. 파싱된 파일의 구조 특징과 패턴은 상기 파싱된 파일의 메타 정보가 될 수 있다. 위에 개시된 예에서는 표시하지 않았으나 개시하는 실시예의 정적 분석에서도 머신 러닝 엔진이 사용될 수 있다. 데이터베이스는 이미 저장된 악성 코드의 학습된 특징들을 포함하는 데이터 세트를 저장할 수 있다. AI 엔진은 위와 같이 파상된 파일로부터 얻은 메타 정보를 머신 러닝을 통해 학습하고, 데이터베이스에 이미 저장된 데이터 세트를 비교하여 악성코드 여부를 판단할 수 있다. 정적 분석을 통해 악성 코드로 분석된 파일은 파일의 구조적 특징은 악성 코드와 관련된 데이터 세트로 다시 저 장될 수 있다. 도 17은 개시하는 실시 예에 따라 동적 분석을 수행하는 일 예를 나타낸다. 도면을 참조하여 실시 예에 따른 동 적 분석 방법의 일 예를 설명하며 다음과 같다. 설명한 바와 같이 동적 분석을 수행하기 이전에 전처리 단계나 동적 분석의 초기 단계에서 파일의 종류를 식별 수 있다. 마찬가지로 이 예시에서 파일의 종류로서 편의상 ELF, EXE, ARK 파일이 식별된 경우를 예시한다. 전처리를 통해 동적 분석 대상이 되는 파일 종류를 식별할 수 있다. 식별된 파일은 각 파일의 종류와 타입에 따 라 가상 환경에서 실행될 수 있다. 예를 들어 식별된 파일이 ELF 파일인 경우 대기 큐(Que)를 거쳐 리눅스 가상 환경(Virtual Machine, VM)의 운영 체제에서 실행될 수 있다. ELF 파일이 실행될 경우 발생하는 이벤트는 행위 로그(log)에 기록될 수 있다. 이와 같이 각각의 식별 파일의 종류 별로 윈도우, 리눅스, 모바일 운영체제 시스템을 가상으로 구축한 후 가상 시스템의 실행 이벤트를 기록한다. 그리고 데이터베이스에 이미 저장된 악성 코드의 실행 이벤트들과 기록한 실행 이벤트들을 비교할 수 있 다. 위에서 예시하지 않았으나 동적 분석의 경우에도 머신 러닝을 통해 기록한 실행 이벤트들을 학습하고, 학습 된 데이터가 이미 저장된 악성 코드의 실행 이벤트들과 유사한지 판단할 수 있다. 동적 분석의 경우 파일에 따라 가상 환경을 구축해야 하고 이에 따라 분석 및 탐지 시스템의 규모가 커질 수 있 다. 도 18은 개시하는 실시 예에 따라 심층 분석을 수행하는 일 예를 나타낸다. 도면을 참조하여 실시 예에 따른 심 층 분석 방법의 일 예를 설명하며 다음과 같다. 설명한 바와 같이 심층 분석을 수행하기 이전에 전처리 단계나 심층 분석의 초기 단계에서 파일의 종류를 식별 수 있다. 개시된 예는 식별된 파일이 ELF, EXE, ARK 의 실행 가능한 바이너리 파일을 예시한다. 실행 가능한 바이너리 파일을 디스어셈블(disassemble)을 수행하면 CPU(Central Processing Unit)의 명령어 집 합 중 함수들의 구조를 분석할 수 있다. 심층 분석은 동적 분석과 다르게 바이너리 파일을 디스어셈블하여 추출된 코드를 기반으로 동작하기 때문에 상 대적으로 시스템 규모가 간단하게 분석이 가능하다. 그리고 심층 분석은 별도의 엔진 없이 추출된 코드들을 정 규화 하는 과정을 통해 만들어진 데이터를 기초로 인공지능 분석을 수행할 수 있다. 이 도면에서 디스어셈블드 코드는 OP-CODE와 ASM-CODE의 결합으로 표현된다. 실시 예는 OP-CODE 와 ASM-CODE를 기반으로 두 가지 코드를 조합하고, 조합된 코드 중 의미가 있는 코드 블록 (Code Block)을 추출할 수 있다. OP-CODE 와 ASM-CODE을 포함하는 디스어셈블된 코드의 코드 블록(Code Block)은 일정한 형식을 변환하여 해당 코드가 악성 코드와 관련되었는지, 어떤 악성 코드이지 또는 어떤 공격자가 개발했는지를 식별할 수 있다. 이를 판단하기 위한 코드 블록(Code Block)의 데이터 변환 방식을 여러 가지 과정이 있다. 디스어셈블된 코드의 데이터 변환 과정은 데이터의 처리 속도와 정확도에 따라 선택적으로 적용될 수 있으나 이 도면에서는 정규화 과정과 벡터화 과정만을 표기하였다. OP-CODE와 ASM-CODE의 결합 코드의 추출된 코드 블록(Code Block)을 정규화 과정과 벡터화 과정을 수행할 수 있 다. 즉 바이너리 코드의 OP-CODE 와 ASM-CODE 조합으로 코드 블록(Code Block)을 추출하고 이 코드 블록(Code Block)의 특징 정보를 벡터화시킨 후 다양한 특징 정보를 통해 학습된 데이터와 비교하여 공격 행위 등을 식별 하도록 한다. 동일한 실행 파일이라도 이와 같이 추출된 코드 블록(Code Block)이 모두 다를 수 있기 때문에 실시 예는 추출 된 코드 블록(Code Block)를 악성 코드로 판단하고 분류하는 방식으로 머신 러닝 또는 인공 지능(AI) 방식을 이 용할 수 있다. 그리고 실시 예는 정규화 및 벡터화 과정이 수행된 최종 데이터를 인공 지능을 통해 학습시킨다. 학습된 데이 터는 데이터베이스에 이미 저장된 공격 기법(TTP)과 공격자 또는 공격 그룹의 데이터와 비교되어 악성 코 드 여부 등의 정보를 얻을 수 있다. 실시 예는 악성 코드의 핵심 부분인 구성 요소를 MITRE ATT&CK 모델을 기반으로 분류하고 구분할 수 있다. 이에 대한 구체적인 실시 예는 이하에서 더욱 상세하게 개시된다. 도 19는 개시하는 실시 예에 따라 바이너리 코드에서 추출된 코드들로 공격 기법을 매칭하는 일 예를 나타낸다. 여기에서는 공격 기법을 매칭하는 일 예로 표준화된 모델을 사용하는 예를 개시한다. 여기서 표준화된 모델로 MITRE ATT&CK® Framework를 예시한다. 예를 들어 사이버 보안 상 “악성 행위” 라고 하는 것은 분석가에 따라 해석 방식이 다르고 각자가 가지고 있 는 식견에 따라서 다르게 해석하는 경우가 많았다. 국제적으로 시스템 상에서 발생하는 “악성 행위”를 표준화 하고 모두가 같은 해석을 할 수 있도록 전문가들 사이에 많은 노력을 수행되고 있다. 미국 연방정부의 지원을 받으며 국가안보관련 업무를 수행하던 비영리 연구 개발 단체인 MITRE(https://attack.mitre.org)에서 “악성 행위” 에 대한 정의를 연구하였고 그에 따라 ATT&CK® Framework 이라는 것을 만들고 공표하였다. 이 프레임 워크는 사이버 위협 또는 악성코드에 대해 모두 가 같은 “악성 행위”를 정의 할 수 있도록 정의하였다. MITRE ATT&CK® Framework (이하, MITRE ATT&CK®)는 공격자들의 최신 공격 기술 정보를 정리한 것으로서 Adversarial Tactics, Techniques, and Common Knowledge의 약어이다. MITRE ATT&CK® 은, 실제 사이버 공격 사례를 관찰한 후 공격자의 악의적 행위(Adversary behaviors)에 대해서 공격 방법(Tactics)과 기술 (Techniques)을 분석하여 다양한 공격 그룹들의 공격 기법들에 대한 정보들을 분류하고 목록화한 표준적인 데이 터이다. MITRE ATT&CK® 은 전통적인 사이버 킬체인의 개념과는 약간 관점을 달리하여 지능화된 공격의 탐지를 향상시키 기 위해 위협적인 전술과 기술을 체계화(패턴화)한 것이다. 원래 ATT&CK는 MITRE에서 윈도우 운영체제를 사용 하는 기업 환경에 사용되는 해킹 공격에 대해서 방법(Tactics), 기술(Techniques), 절차(Procedures) 등 TTP를 문서화하는 것으로 시작되었다. 그 이후 ATT&CK은 공격자로부터 발생한 일관된 공격 행동 패턴에 대한 분석을 기반으로 TTP 정보를 매핑하여 공격자의 행위를 식별해 줄 수 있는 프레임워크로 발전하였다. 개시하는 실시 예에서 언급하는 악성 행위는, MITRE ATT&CK® 와 같은 표준화된 모델에 기반하여 악성 코드를 공격 기법에 매칭하여 표현할 수 있는데 표준화된 모델이 어떤 것이든 악성 코드를 요소 별로 식별하고 분류하 여 공격 식별자에 매칭할 수 있다. 이 도면의 예 어떻게 악성 코드의 악성 행위와 MITRE ATT&CK 모델 기반으로 공격 기법이 매칭되는지를 개념적으 로 나타낸다. 실행 파일 EXE는 파일 실행 시에 수행되는 여러 가지 함수들(Function A, B, C, D, E,…, N,…, Z)을 포함할 수 있다. 그 함수들 중 적어도 하나의 함수를 포함하는 함수 그룹은 하나의 공격 방법(tactic)을 수행할 수 있 다. 이 도면의 예에서 함수 A, B, C는 공격 방법(tactic) A에 대응되고, 함수 D, B, F는 공격 방법(tactic) B에 대 응되는 예를 개시한다. 유사하게 함수 Z, R, C는 공격 방법(tactic) C에 대응되고, 함수 K 및 F는 공격 방법 (tactic) D에 대응된다. 실시 예는 각 공격 방법(tactic)에 대응되는 함수들의 집합과 특정 디스어셈블드 코드 의 부분을 대응시킬 수 있다. 데이터베이스는 이미 인공 지능으로 학습된 디스어셈블드 코드들에 대응될 수 있는 의 공격 방법 (Tactics), 기술(Techniques), 절차(Procedures) (TTP)의 공격 식별자 (T-ID)를 저장하고 있다. 공격 방법(Tactics), 기술(Techniques), 절차(Procedures) (TTP)의 공격 식별자 (T-ID)는 표준화된 모델을 따 르며 여기 도면의 예시는 사이버 위협 정보의 표준화된 모델로 MITRE ATT&CK®를 예시하였다. 따라서, 실시 예는 바이너리 파일에서 디스어셈블드 코드로부터 추출한 결과 데이터를 표준화된 공격 식별자로 매칭시킬 수 있다. 공격 식별자를 매칭하는 보다 구체적인 방식은 아래에서 개시한다. 도 20은 개시하는 실시 예에 따라 OP-CODE를 포함하는 코드 세트와 공격 기법을 매칭하는 일 예를 나타낸다. 대부분의 인공지능 엔진은 악성 코드의 다양한 특징 정보를 바탕으로 학습된 데이터 셋(data set)을 이용해 악 성 코드를 판별한다. 그러면 악성 코드의 악성 여부는 판단이 되지만 이러한 방식은 악성 코드가 왜 악성 코드 인지에 대한 설명을 하기 힘들었다. 그러나 예시한 바와 같이 표준화된 공격 방법(TTP)의 식별자로 대응시키면 해당 악성 코드가 어떤 위협 요소가 있는지 식별이 가능하다. 따라서, 실시 예는 보안 관리자에게 사이버 위협 정보를 정확하게 전달하도록 하고, 보안 관리자가 사이버 위협 정보를 체계적이고 장기적으로 관리할 수 있도록 할 수 있다. 실시 예는 디스어셈블드 코드를 기반으로 공격 방법(TTP)을 식별하기 위한 인공 지능 학습용 데이터 셋을 생성 할 때 단순히 공격 방법(TTP)의 식별자 또는 라벨링 만을 구분할 뿐만 아니라 공격 방법(TTP)을 어떻게 구현했 는지에 대한 특징을 중요한 요소로 반영할 수 있다. 동일한 공격 방법(TTP)을 구현하는 악성 코드라도 개발자에 따라 동일한 코드로 생성하는 것은 불가능하다. 즉, 공격 방법(TTP)의 기술은 인간 구술 언어 형태로 되어 있으나, 개발자에 따라 이를 구현 방식과 코드 작성 방법 이 동일하지 않다. 이러한 코드 작성의 차이는 개발자의 역량이나 프로그램 로직을 구현하는 방식이나 습관에 따르는데 이러한 차 이는 바이너리 코드 또는 이를 디스어셈블된 OP-CODE 와 ASM-CODE의 차이로 나타낸다. 그래서 단순히 결과적인 공격 방법(TTP)의 타입에 따라 공격 식별자를 부여하거나 대응시키면 악성 코드를 생성 하는 공격자 또는 공격자 그룹까지 정확하게 식별하기 힘들다. 반대로 디스어셈블된 OP-CODE 와 ASM-CODE의 특성을 중요한 변수로 반영시켜서 모델링을 수행하면 특정 악성코 드나 공격 도구를 개발한 개발자 혹은 자동으로 생성하는 도구 자체까지도 식별이 가능하다. 개시하는 실시 예는 디스어셈블된 OP-CODE 와 ASM-CODE 결합 코드의 고유한 특성에 따라 현대의 사이버 전에서 굉장히 중요한 위협 인텔리전스를 생성하도록 할 수 있다. 즉, 이러한 고유 특성에 기초하면 실시 예는 공격 코 드 또는 악성 코드를 어떻게 동작을 하는지, 이것을 누가 어떤 의도로 개발했는지에 대한 내용을 함께 식별할 수 있다. 그리고 추후에 해당 공격자가 계속해서 공격하는 특징 정보를 바탕으로 취약한 시스템을 보완할 수 있고 사이버 보안 위협에 대한 능동적이고 선제적인 대응이 가능하도록 할 수 있다. 이러한 개념 상에서 실시 예는 단순히 OP-CODE 기반으로 공격 결과에 따른 공격 기법을 식별하는 방식과 성능에 서 전혀 다른 결과를 제공한다. 실시 예는 공격 방법(TTP)를 구현하기 위해 사용된 코딩 기법을 정확하게 식별하여 분류하기 위해 디스어셈블된 OP-CODE 와 ASM-CODE을 조합된 특징에 기초한 디스어셈블드 코드의 데이터 세트를 생성할 수 있다. 이렇게 생성 된 데이터 세트로부터 고유한 특성을 식별하도록 모델링하면 공격 방법(TTP)뿐만 아니라 개발자의 특징 정보, 즉 개발자 (또는 자동화된 제작 도구)가 누구인지까지 식별이 가능하다. 이 도면은 위에서 설명한 방식으로 모델링된 OP-CODE 데이터 세트를 공격 식별자에 매칭하는 예를 나타낸다. 이 예에서 제 1 OP-CODE 세트(OP-CODE set #1)는 공격 기법 식별자 T1011에 매칭되고, 제 2 OP-CODE 세트(OP- CODE set #2)는 공격 기법 식별자 T2013에 매칭됨을 나타낸다. 그리고 제 3 OP-CODE 세트(OP-CODE set #3)는 공격 기법 식별자 T1488에 매칭할 수 있고, 제 N번째 OP-CODE 세트(OP-CODE set #N)는 임의의 공격 기법 식별자 T1XXX에 매칭됨을 나타낸다. 표준화된 모델인 MITRE ATT&CK®은 공격 기법의 식별자를 요소 별로 매트릭스 형식 으로 표현하지만, 실시 예는 공격 기법의 식별자 이외에 공격자 또는 공격 도구를 추가로 식별할 수 있다. 이 도면은 편의 상 OP-CODE 데이터 세트로 표시하였으나 OP-CODE 와 ASM-CODE을 포함하는 디스어셈블드 코드의 데이터 세트로 공격 기법을 식별하면 OP-CODE 데이터 세트만으로 공격 기법을 식별하는 것보다 더욱 세분화된 공격 기법을 식별할 수 있다. 실시 예에 따라 디스어셈블드 코드의 데이터 세트의 조합을 분석하면 공격 기법 식별자 뿐만 아니라 공격자 또 는 공격 그룹의 식별할 수도 있다. 따라서, 실시 예는 기존의 기술보다 인텔리전스 정보 획득 차원에서 고도화된 기술을 제공할 수 있을 뿐만 아니 라 종래의 보안 영역에서 해결하지 못한 문제를 해결할 수 있다. 위와 같이 복잡한 환경에서 정확한 인텔리전스 정보를 확보하기 위해 빠른 데이터처리와 알고리즘이 요구된다. 이하에서는 이와 관련된 추가적인 실시 예와 그에 따른 성능에 대해 개시하도록 한다.도 21은 개시하는 실시 예에 따라 사이버 위협 정보를 처리하는 흐름을 예시한 도면이다. 이 도면에서 식별된 파일이 ELF, EXE, ARK 의 실행 가능한 바이너리 파일인 경우를 예로 하여 설명한다. 이 단 계의 처리 과정은 위에서 개시한 심층 분석과 관련된다. 먼저 제 1 단계로서 OP-CODE 코드를 포함하는 디스어셈블드 코드를 추출하는 과정의 일 상세한 예를 설명하면 다음과 같다. 소스 코드를 컴파일(complie)하면 실행 파일이 생성된다. 원시 소스 코드는 실행 가능한 각 운영체제(OS) 환경에서 컴파일러에 의해 기계의 처리에 적합한 형태의 새로운 데이터로 생성된다. 새롭게 구성된 바이너리 데이터는 사람이 읽기에는 적합하지 않은 형태로 되어 있어 실행 파일 형태로 만들어진 파일을 인간이 해석해서 그 내부 로직을 파악하는 것은 불가능하다. 그러나 보안 시스템의 취약점 분석과 다양한 목적을 위해서 그 역과정을 수행하여 기계어의 해석이나 분석을 수 행하는데 설명한 바와 같이 디스어셈블 과정이라고 한다. 디스어셈블 과정은 특정 운영체제의 중앙처리장치 (CPU)와 처리 비트 수(32비트, 64비트 등) 에 맞춰서 수행될 수 있다. 예시한 ELF, EXE, ARK 의 실행 파일을 각각 디스어셈블을 수행하면 디스어셈블된 어셈블리 코드를 획득할 수 있 다. 디스어셈블된 코드는 OP-CODE 와 ASM-CODE가 조합된 코드를 포함할 수 있다. 실시 예는 디스어셈블 도구를 기반으로 실행 파일을 분석하여 실행 파일로부터 OP-CODE 와 ASM-CODE을 추출할 수 있다. 개시하는 실시 예는 추출된 OP-CODE 와 ASM-CODE을 그대로 이용하지 않고 각 함수 별로 재구성하여 OP-CODE 배 열을 다시 구성한다. OP-CODE 배열을 재정리할 경우 원본 바이너리 데이터도 함께 포함하여 데이터의 해석을 충 분히 수행할 수 있도록 데이터를 재구성할 수 있다. 이러한 재배열를 통해 OP-CODE 와 ASM-CODE의 새로운 조합 은 공격 기법뿐만 아니라 공격자를 식별할 수 있는 기초 데이터를 제공한다. 제 2 단계로 어셈블리 데이터를 처리하는 과정(ASM)을 상세히 설명하면 다음과 같다. 어셈블리 데이터 처리 과정은 OP-CODE와 필요한 ASM-CODE 만을 분리한 후 인간 또는 컴퓨터가 읽기 좋은 형태로 재구성된 데이터를 기반으로 유사도를 분석하고 정보를 추출하는 과정이다. 이 단계에서 디스어셈블된 어셈블리 데이터는 일정한 데이터 형식으로 변환될 수 있다. 이러한 데이터 형식의 변환은 데이터 처리 속도를 높이고 데이터의 정확한 분석을 위해 아래 기술된 변환 방식 들은 모두 적용될 필요없이 선택적으로 적용될 수 있다. 재배열된 OP-CODE 와 ASM-CODE의 조합의 어셈블리 데이터로부터 여러 가지 함수를 추출할 수 있다. 하나의 실행 파일을 디스어셈블하면 프로그램 크기에 따라 다르지만 평균적으로 약, 7,000~12,000개 정도 되는 함수를 포함할 수 있다. 이 함수들은 프로그래머가 필요에 따라 구현한 함수도 있으며 운영체제에서 기본적으로 제공하는 함수들도 있다. 실제 ASM-CODE를 분석하면 약 87%~91% 정도의 함수가 운영체제에서 기본적으로 제공하는 함수(OS supported)이 고 프로그래머가 프로그램 로직을 위해서 실제 구현한 ASM-CODE는 약 10% 정도이다. 운영체제에서 제공한 함수 는 함수 명과 함께 운영체제 설치 시에 기본적으로 설치되는 각종 DLL, SO 파일 등에 포함되는 함수들(Default function)이다. 이러한 운영체제 제공 함수들은 이미 분석하여 저장하여 분석 대상 데이터로부터 필터링할 수 있다. 이렇게 분석해야 할 코드만 분리하면 이후 처리 속도와 성능을 높일 수 있다. 실시 예는 프로그램의 기능적 분석을 정확하게 수행하기 위해서 OP-CODE를 함수 단위로 분리해서 처리할 수 있 다. 실시 예는 모든 의미적 분석의 최소 단위를 어셈블리 코드에 포함된 함수를 기반하여 수행할 수 있다. 분석 성능과 처리 속도를 높이기 위해 실시 예는 의미가 정확하지 않은 연산자 수준의 함수들은 필터링하고 정 보량이 임계 치 보다 작은 함수들 도 분석 대상에서 제거할 수 있다. 함수들의 필터링의 여부와 정도는 실시 예 에 따라 다르게 설정할 수 있다. 실시 예는 함수에 따라 정리된 OP-CODE 로부터 디스어셈블러가 출력 시 제공하는 주석 데이터를 제거할 수 있다. 그리고 실시 예는 디스어셈블된 코드를 재배열할 수 있다. 예를 들면, 디스어셈블러가 출력하는 디스어셈블된 코드는 [ASM-CODE, OP-CODE, 파라미터]의 순서를 가질 수 있 다. 실시 예는 어셈블리 데이터로부터 파라미터 데이터를 제거하고 위 순서의 디스어셈블된 코드를 [OP-CODE, ASM- CODE] 순서로 재정리 또는 재구성할 수 있다. 이렇게 재정된 디스어셈블된 코드는 정규화 또는 벡터화하여 처리 하기 용이하다. 그리고 처리 속도를 현격하게 높일 수 있다. 특히 [OP-CODE, ASM-CODE] 의 조합을 가지는 디스어셈블된 코드 중 ASM-CODE 부분은 데이터의 길이가 달라 서로 비교하기 용이하지 않다. 따라서 해당 어셈블리 데이터의 고유성을 확인하기 위해서 데이터를 특정 크기의 데이 터 포맷으로 정규화시킬 수 있다. 예를 들면 실시 예는 [OP-CODE, ASM-CODE] 조합의 디스어셈블된 코드의 고유 성을 확인하기 위해서 데이터 부분을 정규화하기 용이한 특정 길이의 데이터 세트, 예를 들면 CRC(cyclic redundancy check) 데이터로 변환시킬 수 있다. 일 예로서 [OP-CODE, ASM-CODE] 조합의 디스어셈블된 코드에서 OP-CODE 부분은 제 1 길이의 CRC 데이터로, ASM-CODE 부분은 제 2 길이의 CRC 데이터로 각각 변환하는 것도 가능하다. OP-CODE와 ASM-CODE 변환된 정규화 데이터는 각각 해당 변환 이전의 각각 코드의 고유성을 유지할 수 있도록 한 다. 고유성을 가지고 변환된 정규화 데이터의 유사도 판단 속도를 빠르게 하기 위해 상기 정규화된 데이터를 벡 터화(Vectorization)를 수행할 수 있다. 설명한 바와 같이 데이터 변환 과정으로서 정규화 또는 벡터화 과정은 데이터 처리 속도를 높이고 데이터의 정 확한 분석을 선택적으로 적용될 수도 있다. 정규화 과정과 벡터화 과정의 상세한 예는 다시 아래에서 상세히 개시한다. 제 3단계로서 디스어셈블드 코드를 분석하는 데이터의 분석과정을 상세히 설명하면 다음과 같다. 이 과정에서도 데이터 처리 속도를 높이고 데이터의 정확한 분석을 위해 여러 가지 데이터 형식의 변환이 사용 될 수 있는데, 아래 개시하는 기술된 변환 방식들은 모두 적용할 필요없이 그 중 일부를 선택적으로 적용할 수 있다. 이러한 변환된 데이터에 기초하여 변환된 디스어셈블드 코드 내의 함수 별 데이터 세트를 기반으로 악성 코드와 유사도를 분석하는 단계이다. 실시 예는 코드 간 유사도를 수행하기 위해 벡터화된 OP-CODE 와 ASM-CODE의 데이터 세트들을 바이트 데이터로 다시 변환할 수 있다. 재변환된 바이트 데이터를 기반으로 블록 단위의 해쉬 값을 추출하고 블록 단위의 고유 값을 기반으로 전체 데 이터의 해쉬 값을 생성할 수 있다. 해쉬 값은 바이트 데이터의 부분인 블록 단위의 비교를 효율적으로 수행하기 위해서 각 블록 단위의 고유 값을 추출하도록 지정된 단위의 해쉬 값을 추출하여 비교할 수 있다. 이와 같이 지정된 단위의 해쉬 값을 추출하고 2개 이상의 데이터의 유사도를 비교하기 위해 퍼지 해쉬(Fuzzy Hashing) 기법이 사용될 수 있다. 예를 들면 실시 예는 퍼지 해쉬(Fuzzy Hashing) 중 CTPH(Context Triggered Piecewise Hashing) 방식을 사용하여 블록 단위로 추출된 해쉬 값과 기 저장된 악성 코드 중 일부 단위의 해쉬 값을 서로 비교하여 유사도를 판단할 수 있다. 정리하면 실시 예는 OP-CODE 및 ASM-CODE의 조합 코드가 특정 기능을 함수 단위로 구현한다는 사실에 기반하여, 각 특정 기능의 고유성을 확인하기 위해서 OP-CODE 와 ASM-CODE의 디스어셈블된 코드의 고유 값을 생성한다. 그 리고 이 고유 값을 기반으로 디스어셈블된 코드의 OP-CODE와 ASM-CODE중 블록 단위의 고유 값을 추출하여 유사 도 연산을 수행할 수 있다. 블록 단위의 해쉬 값을 추출 하는 상세한 예도 아래에서 도면을 참조하여 개시하도록 한다. 설명한 바와 같이 실시 예는 유사도 연산을 수행할 경우 블록 단위 해쉬 값을 이용할 수 있다. 추출된 블록 단위 해쉬 값은 String Data (Byte Data) 로 구성되어 있고 String Data (Byte Data)는 수치화 값 들로 코드 간의 유사도를 비교할 수 있다. 만약 수십억 개의 디스어셈블된 코드 데이터 세트의 바이트 비교를 수행하면 하나의 유사도 결과를 얻는데 엄청난 시간을 소비할 수 있다. 따라서 실시 예는 String Data (Byte Data)는 수치화 값으로 변환할 수 있는데 이러한 수치화 값에 기반하면 인 공지능 기술을 활용해 유사도 분석을 빠르게 수행할 수 있다. 실시 예는 추출된 블록 단위의 해쉬 값의 String Data (Byte Data) 를 N-gram 데이터 기반으로 벡터화시킬 수 있다. 이 도면의 실시 예는 연산 속도를 높이기 위해 블록 단위의 해쉬 값을 2-gram 데이터로 벡터화 수행하는 경우를 예시한다. 그런데 실시 예는 블록 단위의 해쉬 값을 반드시 2-gram 데이터로 변환할 필요는 없으며 3- gram, 4-gram,…, N-gram의 데이터로 벡터화 변환하는 것도 가능하다. N-gram의 데이터에서 N이 증가할수록 데 이터의 특성을 정확하게 반영할 수 있지만 데이터의 처리 시간의 속도가 증가한다. 기술한 바와 같이 데이터 처리 속도를 높이고 데이터의 정확한 분석을 위해 바이트 변환, 해쉬의 변환 및 아래 의 N-gram 변환은 선택적으로 적용할 수 있다. 예시한 2-gram 변환 데이터는 최대 65,536 차원을 가진다. 학습 데이터의 차원이 높아질수록, 데이터의 분포가 희박해(sparse)지며, 이에 따라 분류 성능에 악영향을 끼칠 수 있다. 그리고 학습 데이터의 차원이 높아지면 데 이터를 학습하기 위한 시간 복잡도와 공간 복잡도가 증가한다. 이러한 문제점을 해결하기 위해 실시 예는 다양한 텍스트 표현 기반의 여러 가지 자연어 처리 알고리즘으로 처 리할 수 있다. 이 실시 예에서는 이러한 알고리즘으로 TF-IDF(Term Frequency-Inversed Document Frequency) 기법을 예로 하여 설명한다. 이 단계의 학습 데이터의 유사도를 처리하기 위한 일 예로서, 고차원 데이터 중에서 공격 식별자 또는 클래스 (T-ID)를 판단할 경우 의미 있는 특징(패턴)을 선택하기 위해 TF-IDF(Term Frequency-Inversed Document Frequency) 기법을 사용할 수 있다. 일반적으로, TF-IDF 기법은 검색 엔진에서 유사도가 높은 문서를 찾기 위해 사용되는데 이를 계산하는 수학식들은 다음과 같다. 수학식 1"}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "여기서 는 특정 문서 에서 특정 단어 의 빈도율을 의미하고 그 단어가 반복적으로 나올수록 높은 값을 갖는다. 수학식 2"}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "는 특정 단어 를 포함하는 문서 의 비율의 역수 값으로, 단어가 여러 문서에서 흔하게 나 타날수록 낮은 값을 갖는다. 수학식 3"}
{"patent_id": "10-2022-0095587", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "는 와 를 곱한 값으로, 어떤 단어가 어떤 문서에 더 적합한지 수치 화시킬 수 있다. TF-IDF 방식은 수학식 1에 의한 단어의 빈도와 수학식 2에 의한 역문서빈도 (문서의 빈도에 특정한 역수)를 이 용하여 수학식 3과 같이 문서 단어 행렬 내의 단어의 중요도에 따라 가중치를 반영하는 하는 방식이다. 실시 예에서 블록 단위의 코드 상의 단어의 특징 또는 패턴에 기반하여 해당 단어가 포함된 문서를 공격 식별자 (T-ID)라고 추론할 수 있다. 따라서, 블록 단위의 코드로부터 추출된 패턴에 대해서 TF-IDF를 계산하면, 특정 공격 식별자(T-ID) 내에서 빈번하게 나타나는 패턴을 추출하거나 또는 특정 공격 식별자(T-ID)와 관련 없는 패 턴을 가지는 코드를 제거할 수 있다. 예를 들어, 특정 패턴 A는 모든 공격 식별자(T-ID)들에서 발현되는 패턴이라고 했을 때, 특정 패턴 A에 대한 TF-IDF 값은 낮게 측정될 것이다. 그리고 이러한 패턴은 실제 공격 식별자(T-ID)를 구분하기 위해 불필요한 패 턴임을 판단할 수 있다. TF-IDF와 같은 자연어의 유사도 판단을 위한 알고리즘은 머신 러닝 알고리즘의 학습을 통해 수행될 수도 있다. 실시 예는 이러한 불필요한 패턴을 제거하여 불필요한 연산을 줄이고 추론 시간을 단축시킬 수 있다. 상세하게 실시 예는 변환되어 블록 단위 코드의 데이터에 대해, 여러 가지 자연어 처리의 텍스트 표현에 기초한 유사도 알고리즘을 수행할 수 있다. 유사도 알고리즘을 통해 공격 식별자와 관련이 없는 패턴의 코드는 제거하 여 아래 수행되는 알고리즘 수행과 머신 러닝에 따른 분류 과정의 수행을 크게 단축시킬 수 있다. 실시 예는 블록 단위의 코드 상의 특징 또는 패턴을 기반하여 공격 식별자의 패턴을 분류하기 위해 분류 모델링 을 수행할 수 있다. 실시 예는 벡터화된 블록 단위의 코드 특징 또는 패턴이 알려진 공격 식별자의 패턴인지를 학습하고, 이를 정확한 공격 기법이나 구현방식으로 분류할 수 있다. 실시 예는 악성 코드와 유사한 코드 패턴 이 있다고 판단된 코드에 대해 정확한 공격 구현 방식, 즉 공격 식별자와 공격자를 분류를 위해 여러 가지 앙상 블 머신 러닝 모델들을 이용한다. 앙상블 머신 러닝 모델들은 준비된 데이터를 여러 개의 분류 노드들을 생성하고 각 분류 노드의 대한 노드의 예 측을 결합하여 정확한 예측을 수행하는 기법이다. 위에서 설명한 바와 같이 블록 단위의 코드 상의 단어의 특징 또는 패턴이 어떤 공격 구현 방식인지, 즉 공격 식별자 또는 공격자인지 분류하는 앙상블 머신 러닝 모델들을 수행한다. 앙상블 머신 러닝 모델들을 적용 시에 과탐과 오탐을 방지하기 위해 준비된 데이터의 분류를 위한 임계 값을 설 정할 수 있다. 설정된 탐지 임계 값 이상의 데이터들만 분류하고 설정된 탐지 임계 값에 도달하지 못하는 데이 터는 분류 수행을 하지 않을 수 있다. 기술 바와 같이 데이터 처리 속도를 높이고 데이터의 정확한 분석을 위해 여러 가지 데이터 형식의 변환이 사용 될 수 있다. 위에서 기술한 데이터 변환 방식을 앙상블 머신 러닝 모델들에 적용한 구체적인 실시 예는 이하에 서 상세히 설명한다. 제 4단계로서 공격 기법(TTP)을 식별하여 라벨링을 부여하는 프로파일링 하는 과정을 설명하면 다음과 같다. 이미 분석된 공격 코드 또는 악성 코드에 기반하여 입력된 바이너리 데이터의 OP-CODE와 ASM-CODE를 포함하는 디스어셈블드 코드의 특징 추출을 통해 벡터화시키는 예를 위에서 기술하였다. 이렇게 벡터화된 데이터는 머신 러닝 모델링을 통해 학습된 후 특정 공격 기법으로 분류되고 분류된 코드들은 프로파일링 과정에서 상기 분류된 데이터의 라벨링이 수행된다.라벨링은 크게 두 부분에 수행될 수 있는데 하나는 표준화된 모델에서 정의한 공격 식별자에 대한 고유 인덱스 를 붙이는 것이고 다른 하나는 공격 코드를 작성한 사용자에 대한 정보를 기입하는 것이다. 라벨링은 표준화된 모델, 예를 들면 MITRE ATT&CK에서 반영된 공격 식별자(T-ID)에 따라 부여하도록 하여 추가 적인 작업 없이 사용자에게 정확한 정보를 전달할 수 있도록 한다. 그리고 라벨링은 공격 식별자뿐만 아니라 해당 공격 식별자를 구현한 공격자를 구별할 수 있도록 부여된다. 따 라서 공격 식별자뿐만 아니라 공격자와 그에 따른 구현 방식을 식별할 수 있도록 제공할 수 있다. 실시 예는 기존에 분류된 디스어셈블된 코드(OP-CODE, ASM-CODE, 또는 그 조합)의 데이터 세트를 학습한 데이터 를 기반으로 고도화된 프로파일링이 가능한다. 실시 예는 위에서 개시한 정적 분석, 동적 분석, 또는 연관 분석 의 데이터도 라벨링을 수행하는 참고 데이터로 활용할 수 있다. 따라서 기존에 분석되지 않은 데이터 세트라고 하더라도 정적, 동적, 및 연관 분석의 결과를 함께 고려하면 매우 빠르고 효율적으로 프로파일링 데이터를 확보 할 수 있다. 위에서 3단계의 악성 코드와 유사한 패턴을 가지는 코드를 학습하고 학습된 데이터가 분류되는 과정과 4단계의 분류된 데이터의 프로파일링 과정은 머신 러닝에 알고리즘에 의해 함께 진행될 수 있다. 이에 대한 상세한 예는 아래에서 개시한다. 그리고 프로파일링된 데이터 세트의 실제 예도 아래에서 도면을 참 고하여 예시하도록 한다. 도 22는 개시하는 실시 예의 데이터 변환의 일 예로서 디스어셈블드 코드의 OP-CODE 및 ASM-CODE를 정규화된 코 드로 변환한 값을 예시한 도면이다. 설명한 바와 같이 실행 파일의 디스어셈블링을 수행하면 OP-CODE 및 ASM-CODE가 결합된 데이터가 출력된다. 실시 예는 디스어셈블링된 데이터로부터 함수 별로 출력되는 주석 데이터를 제거하고 처리가 용이하도록 OP- CODE, ASM-CODE, 및 대응 파라미터의 배치 순서를 변경할 수 있다. 재구성된 OP-CODE와 ASM-CODE를 정규화된 코드 데이터로 변경하는데, 이 도면의 예는 정규화된 코드 데이터로 CRC 데이터를 예시한다. 일 예로 OP-CODE는 CRC-16로 변환하고 ASM-CODE로 CRC-32로 변환할 수 있다. 예시한 표의 첫 번째 행에서 OP-CODE의 push함수를 0x45E9의 CRC-16 데이터로 변경하고, ASM-CODE의 55를 0xC9034AF6의 CRC-32 데이터로 변경한 것을 예시한다. 두 번째 행에서는 OP-CODE의 mov함수를 0x10E3의 CRC-16 데이터로 변경하고, ASM-CODE의 8B EC 를 0x3012FD2C 의 CRC-32 데이터로 변경하였다. 세 번째 행에서는 OP-CODE의 lea함수를 0xAACE의 CRC-16 데이터로 변경하고, ASM-CODE의 8D 45 0C를 0x9214A6AA의 CRC-32 데이터로 변경하였다. 네 번째 행에서 OP-CODE의 push함수를 0x45E9의 CRC-16 데이터로 변경하고, ASM-CODE의 50를 0xB969BE79의 CRC-32 데이터로 변경한 것을 예시한다. 이 예와 다르게 CRC 데이터와 다른 다른 정규화 코드 데이터나 길이가 다른 코드 데이터를 사용할 수도 있다. 이렇게 디스어셈블링된 코드를 정규화된 코드로 변경하면 각 코드의 고유성을 확보하면서 이후의 연산, 유사도 산출 및 벡터화 수행을 용이하게 빠르게 수행할 수 있다. 도 23은 개시하는 실시 예의 데이터 변환의 일 예로서 디스어셈블드 코드의 OP-CODE 및 ASM-CODE의 벡터화된 값 을 예시한 도면이다. 이 도면에서는 정규화된 OP-CODE 의 코드(위의 예에 따르면 CRC-16)와 정규화된 ASM-CODE (위의 예에 따르면 CRC-32)를 각각 벡터화시킨 결과를 예시한다. 정규화된 OP-CODE 의 코드를 벡터화한 값(OP-CODE Vector)와 정규화된 ASM-CODE의 코드를 벡터화한 값(ASM- CODE Vector)을 이 도면에 표 형식으로 나타내었다. 이 도면의 각 행의 OP-CODE Vector 값과 ASM-CODE Vector 값은 각각 도 22의 각 행의 OP-CODE의 정규화 값과 ASM- CODE의 정규화 값에 대응된다. 예를 들어, 도 22의 표의 네 번째 행의 CRC 데이터 0x45E9와 0xB969BE79의 벡터화 값들은 각각 이 도면의 표의 네 번째 행의 17897와 185 105 121 44이 된다. 이렇게 정규화된 데이터에 대해 벡터화를 수행하면 디스어셈블링된 OP-CODE의 함수와 ASM-CODE가 각각 고유 특 징을 포함하면서 벡터화 값으로 변화된다. 도 24는 개시하는 실시 예의 데이터 변환의 일 예로서 코드의 블록 단위를 해쉬 값으로 변환하는 예를 개시한 도면이다. 유사도 분석을 수행하기 위해서 벡터화된 각 OP-CODE 및 ASM-CODE 의 데이터 세트는 바이트 데이터 형태로 재변 환이 수행된다. 재변환된 바이트 데이터는 블록 단위의 해쉬 값으로 변환될 수 있다. 그리고 다시 블록 단위의 해쉬 값들에 기반하여 전체 재변환된 바이트 데이터의 해쉬 값을 생성한다. 실시 예는 재변환된 해쉬 값을 산출하는데 MD5(Message-Digest algorithm 5), SHA1 (Secure Hash Algorithm 1), SHA 256이 등의 해쉬 값을 사용될 수도 있는데, 데이터 사이의 유사도 판단을 위한 퍼지 해쉬(Fuzzy Hash) 함수를 이용할 수 있다. 이 도면의 표에서 첫 번째 행은 데이터에 포함될 수 있는 사람이 가독할 수 있는 character를 나타낸다. 재변환 된 바이트 데이터 중 블록 단위에 포함되는 값은 이와 같은 가독성의 character들을 포함할 수 있다. 각 character들은 두 번째 행의 아스키 값(ascii val)인 97, 98, 99, 100, …., 48, 49에 대응될 수 있다. 첫 번째 행의 character 값들을 포함하는 데이터를 세그먼트하여 아스키 값들의 합산이 가능한 블록으로 분리할 수 있다. 표의 세 번째 행은 4개의 character 를 가지는 블록 단위 내에서 각 character 값에 대응되는 아스키 값의 합산 값을 나타낸다. 첫 번째 블록의 경우 그 블록 내 character 에 대응되는 아스키 값(ascii val) 97, 98, 99, 100의 합(ascii sum)인 394의 값을 가질 수 있다. 그리고 마지막 행은 블록 단위의 아스키 값의 합이 Base 64의 표현으로 변환된 경우를 나타낸다. 문자(letter) K는 첫 번째 블록의 합산이 된다. 이러한 방식으로 해당 데이터에 대해 Kaq6KaU라는 시그니처를 얻을 수 있다. 이러한 시그니처를 기반으로 두 개의 블록 단위 데이터에 대한 유사도를 산출할 수 있다. 이 실시 예는 재변환된 바이트 데이터 중 코드에 포함된 블록 단위들에 대해 유사도 판단을 위한 퍼지 해쉬 함 수로 해쉬 값을 산출하고, 산출된 해쉬 값들을 기반으로 유사도를 판단할 수 있다. 유사도 판단을 위한 퍼지 해 쉬 함수로 CTPH(Context Triggered Piecewise Hashing)를 예시하였으나 데이터의 유사도를 산출할 수 있는 다 른 퍼지 해쉬 함수를 사용하는 것도 가능하다. 도 25는 개시하는 실시 예에 따른 앙상블 머신 러닝 모델의 일 예를 나타낸 도면이다. 실시 예는 앙상블 머신 러닝 모델을 이용하여 악성 코드로 판단되는 파일의 공격 식별자(T-ID)를 정확하게 분류 할 수 있다. String Data (Byte Data)로 구성된 블록 단위를 해쉬 값은 N-gram 특징 정보 기반으로 수치화시킨 후 이것이 공 격 식별자(T-ID) 또는 분류될 클래스인지를 판단하기 위해 TF-IDF 등의 기법으로 유사도를 계산할 수 있다. 불필요한 연산을 줄여 공격 기법 식별의 성능을 높이기 위해 실시 예는 위 해쉬 값 중 유사도를 기반으로 불필 요한 패턴을 제거할 수 있다. 그리고 불필요한 패턴이 제거된 데이터를 앙상블 머신 러닝을 통해 모델링하여 공격 식별자를 분류할 수 있다. 앙상블 머신 러닝 모델의 여러 개의 분류 노드의 학습 결과들을 결합하기는 방식으로 보팅(Voting), 배깅 (Bagging), 부스팅(Booting) 등의 방식이 있다 이러한 방식들을 적절히 조합한 앙상블 머신 러닝 모델은 학습데이터의 분류 정확도를 높이는데 기여할 수 있다. 여기서는 일 예로서 배깅 방식의 랜덤 포레스트(Random Forest) 방식을 적용하는 경우를 예를 들어 공격 식별자 를 보다 정확하게 분류하는 방법을 설명한다. 랜덤 포레스트(Random Forest) 방식은 많은 수의 디시전 트리(Decision Tree) 생성하여 단일 디시전 트리에 의 한 분류 오류를 낮추고 일반화된 분류 결과를 얻는 방식이다. 실시 예는 준비된 데이터에 대해 적어도 하나 이 상의 디시전 트리(Decision Tree)를 이용한 랜덤 포레스트(Random Forest) 학습 알고리즘을 적용할 수 있다. 여 기서 준비된 데이터는 블록 단위의 퍼지 해쉬 값으로부터 불필요한 패턴이 제거된 데이터를 의미한다. 블록 단위 해쉬 값의 유사도 판단을 위해 적어도 하나 이상의 노드를 가진 디시전 트리(Decision Tree)모델을 수행한다. 디시전 트리(Decision Tree)의 정보 획득(information gain) 정도에 따라 1개 이상의 클래스(공격 식별자; T-ID)를 구분할 수 있는 특징 값(여기서는 블록 단위 해쉬 값을 기초로 한 분류 패턴의 발현 개수)에 대해 비교 조건을 최적화할 수 있다. 이를 위해 도면에서 예시한 바와 같은 디시전 트리(Decision Tree)를 생성할 수 있다. 이 도면에서 위 쪽의 사각형(2510, 2520, 2530, 2540)들은 인 터미널 노드로서 클래스를 구분하는 조건을 의미 하고 아래 쪽의 사각형 부분(2610, 2620, 2630)은 터미널 노드로 분류되는 클래스를 의미한다. 예를 들어 랜덤 포레스트(Random Forest) 모델을 앙상블 머신 러닝 모델로 적용할 경우, 1개 이상의 디시전 트 리(Decision Tree)를 이용하여 앙상블 기법을 사용하는 분류 모델이다. 랜덤 포레스트(Random Forest) 모델을 구성하는 디시전 트리(Decision Tree)의 입력 데이터의 특징을 다르게 하여 다양한 디시전 트리(Decision Tre e)를 구성한다. 여러 개 생성된 디시전 트리(Decision Tree) 모델에 대해 분류를 수행하고 다수결 투표 기법을 사용하여 최종 분류 클래스를 결정한다. 각 노드의 테스트는 병렬적으로 진행될 수 있어 계산 효율이 높다. 클래스를 분류할 경우 과탐과 오탐을 방지하기 위해 임계값을 설정하고 하한 임계값 이하의 값은 버리고, 탐지 임계값 이상의 데이터 대상으로 분류를 수행할 수 있다. 도 26은 개시하는 실시 예에 따라 머신 러닝으로 데이터를 학습하고 분류하는 흐름을 예시한 도면이다. 입력 데이터의 프로파일링은 분류 단계(S2610)과 학습 단계(S2620)를 포함할 수 있다. 실시 예에서 학습 단계(S2620)는 (a) 해쉬 값 추출 과정, (b) N-gram 패턴 추출 과정, (c) 자연어 처리 분석 (TF-IDF 분석) 과정, (d) 패턴 선택 과정, (e) 모델 학습 과정 등을 포함할 수 있다. 그리고 실시 예에서 분류 단계(S2610)는, (a) 해쉬 값 추출 과정, (b) N-gram 패턴 추출 과정, (f) 패턴 선택 과정, (g) 벡터화에 의한 분류 과정 등을 포함할 수 있다. 실시 예에 따른 프로파일링 단계 중 분류 단계(S2620)를 먼저 설명하면 다음과 같다. 실행 파일 집합이나 처리된 파일로부터 입력 데이터를 수신한다. 데이터베이스에 저장된 실행 파일 집합들로부터 입력 데이터를 수신하거나 또는 위에서 예시한 처리 과정으로부 터 전달되는 실행 파일이 포함된 입력 데이터를 수신한다. 입력 데이터는 OP-CODE 와 ASM-CODE 코드를 포함하는 디스어셈블된 코드를 변환시킨 데이터로 벡터화시킨 데이터일 수 있다. 입력 데이터인 디스어셈블된 코드로부터 퍼지 해쉬(Fuzzy Hash) 값을 추출(a)하고 특정 함수에 대한 N-gram 패 턴 데이터를 추출한다(b). 이때 기존의 의미 패턴 집합 중 악성 코드와 유사하다고 판단한 패턴을 포함한 2- gram 의 패턴 데이터를 선택할 수 있다(f). 선택한 패턴의 N-gram 데이터를 벡터화 데이터로 변환하고 벡터화 데이터를 의미가 패턴이 결정된 함수로 분류 할 수 있다(g). 실시 예에 따른 프로파일링 단계 중 학습 단계(S2610)는 다음과 같이 수행된다. 만약 입력된 데이터가 새로운 파일이라면 입력 데이터인 디스어셈블된 코드로부터 퍼지 해쉬(Fuzzy Hash) 값을 추출한다(a).추출된 퍼지 해쉬(Fuzzy Hash) 값을 N-gram 데이터(이 예에서는 2-gram)로 벡터화시킨다(b). 추출된 특정 패턴에 대해 TF-IDF 와 같은 자연어 처리 분석을 수행한다(c) 기존의 공격 식별자(T-ID)와 관련된 패턴을 가지는 데이터 세트 중 유사도가 높은 데이터 세트를 선택하고 나머 지는 필터링한다(d). 이때 기존의 의미 패턴 집합에 저장된 데이터 세트들과 비교하여 공격 식별자(T-ID)와 관 련된 패턴을 가지는 데이터 세트의 일부 또는 전부의 특징을 포함한 샘플 데이터 세트들을 선택할 수 있다. 추출된 샘플 데이터 세트를 기반으로 벡터화한 N-gram 데이터를 학습시킬 수 있다(e). N-gram 의 벡터화 데이터를 분류 모델에 입력하여 공격 식별자(T-ID) 별로 확률을 얻는다. 예를 들어 N-gram 구 조의 벡터화 데이터가 특정 공격 식별자(T-ID) T1027일 확률이 A%이고, 공격 식별자 T1055일 확률이 (100-A)%인 확률 등의 확률을 얻을 수 있다. 분류 모델은 적어도 하나 이상의 디시전 트리를 포함하는 랜덤 포레스트 등의 앙상블 머신 러닝 모델을 이용할 수 있다. 여기서 분류 모델에 기반하여 벡터화한 N-gram 데이터가 어떤 공격 기법 또는 공격자인지 판단할 수 있다. 분류 모델(e)의 분류 결과 또는 기존의 저장된 패턴의 선택(f) 결과에 따라 입력 데이터를 분류하여 라벨링을 수행한다(g). 최종 라벨링이 수행된 결과는 다음의 도면을 참조하여 예시한다. 도 27은 개시하는 실시 예에 따라 입력 데이터를 학습하고 분류하여 공격 식별자와 공격자를 라벨링한 예를 나 타낸 도면이다. 이 도면은 프로파일러의 결과로서 공격 식별자, 공격자 또는 공격 그룹, 어셈블리 코드에 대응되는 퍼지 해쉬 값, 그에 대응되는 N-gram(여기서는 2-gram 데이터로 기재)를 각각 표 형식으로 나타낸 도면이다. 실시 예에 따라 프로파일링이 완료되면 다음과 같은 공격 방법의 구현과 관련하여 분류된 데이터를 얻을 수 있 다. 실시 예에 의한 프로파일링에 따라 공격 식별자(T-ID)와 공격자 또는 공격자 그룹(Attacker or Group)에 각각 라벨링될 수 있다. 여기서 공격 식별자(T-ID)는 설명한 바와 같이 표준화된 모델에 따를 수 있는데 이 예에서는 MITRE ATT&CK®에 서 제공하는 공격 식별자(T-ID)를 부여한 결과를 예시한다. 위에서 기술한 바와 같이 식별된 공격자 또는 공격자 그룹(Attacker or Group)에도 라벨링이 추가될 수 있다. 이 도면은 공격자 또는 공격자 그룹(Attacker or Group)의 라벨링으로 공격자 TA504를 식별한 예를 나타낸다. SHA-256 (size)는 각각의 공격 식별자(T-ID) 또는 공격자 그룹(Attacker or Group)에 대응되는 악성 코드의 퍼 지 해쉬 값과 데이터 사이즈을 나타낸다. 설명한 바와 같이 이러한 악성 코드는 OP-CODE 와 ASM-CODE의 재배치 와 조합에 대응될 수 있다. 그리고 N-gram으로 표시한 섹션의 값은 공격 식별자(T-ID) 또는 공격자 그룹과 악성 코드의 퍼지 해쉬 값에 대 응되는 N-gram 패턴 데이터로서, 이 예에서는 2-gram 데이터의 일부로 표시하였다. 이 도면에서 예시한 바와 같이 악성 코드(OP-CODE 와 ASM-CODE)의 퍼지 해쉬 값과 N-gram 패턴 데이터에 대응되 는 공격 식별자(T-ID) 또는 공격자 그룹이 라벨링되어 저장될 수 있다. 예시한 라벨링된 데이터는 앙상블 머신 러닝의 참조 데이터로 이용될 수 있고, 분류 모델의 참조 데이터로 이용 될 수도 있다. 이하에서 개시한 실시 예들의 성능 결과를 예시한다. 도 28은 실시 예에 따라 공격 식별자를 식별한 결과를 나타낸 도면이다. 이 도면은 유클리언 디스턴스 매트릭스(Euclidean Distance Matrix)를 예시하는데, 유클리언 디스턴스 매트릭스 (Euclidean Distance Matrix)는 두 데이터 세트 사이의 유사도를 나타낼 수 있다. 이 도면에서 밝은 부분은 두 데이터 세트의 유사도가 낮은 것을 의미하고 어두운 부분은 두 데이터 세트의 유사 도가 높은 것을 의미한다. 이 도면에서 T10XX는 공격 식별자(T-ID)를 의미하고 괄호 안에 character T, K, L은 각각 해당 공격 식별자(T- ID)에 따른 공격 기법을 작성한 공격자 그룹을 의미한다. 즉, 행과 열은 각각의 공격자 그룹들(T, K, L)이 생성한 공격 식별자(T-ID)들을 의미하며 행과 열은 동일한 의 미를 가진다. 예를 들어 T1055(K)는 L 공격자 그룹이 생성한 T1055 공격을 의미하고, T1055(K)는 K 공격자 그룹 이 생성한 동일한 공격 방법 T1055를 의미한다. 각각의 데이터 세트의 샘플들은 자신의 샘플을 포함하기 때문에 다른 샘플들과의 거리를 각각 계산하면 왼쪽 위 에서 오른쪽 아래의 대각선 방향으로 동일성이 높은 분포를 나타낸다. 이 도면을 보면 동일한 공격 식별자(T-ID)의 경우 공격자 그룹이 다르더라도 유사한 특징을 나타내는 것을 확인 할 수 있다. 예를 들어 T1027의 공격 식별자는 공격 그룹이 T 또는 K라고 하더라도 공격 기법이 유사하면 유사 도가 높게 평가될 수 있다. 따라서, 위의 실시 예와 같이 추출한 데이터 세트를 기반으로 학습을 진행하면 동일한 공격자가 구현한 같은 공 격 기법(T-ID)에 대한 특징은 명확하게 식별되고(가장 어두운 부분), 다른 공격자가 구현한 동일한 공격 기법 (T-ID)은 유사도가 높은 것(중간 어두운 부분)을 확인할 수 있다. 따라서, 이와 같이 OP-CODE 와 ASM-CODE 의 조합에 기초한 샘플 데이터를 추출하여 적용해 공격 기법을 분류하 면 공격자가 다른 경우라고 하더라도 특정의 공격 기법 또는 식별자(T-ID)를 확실하게 분류해 낼 수 있다. 반대 로 OP-CODE 와 ASM-CODE 의 조합을 통해 악성 코드 내부에 구현된 특정 코드를 명확하게 식별할 수 있을 뿐만 아니라 공격자, 공격 식별자를 포함함 공격 구현 방식을 식별할 수 있다. 도 29는 실시 예에 따라 공격 식별자에 따른 그램 데이터 패턴을 예시한 도면이다. 이 도면은 서로 다른 공격 식별자 (T-ID)가 다른 경우 그램 데이터의 패턴을 예시한 도면이다. 예를 들어 공격 식별자 T1027과 T1055를 포함한 각각의 악성 코드를 2-gram의 패턴 데이터로 변환하여 실시예에 따라 분류하면 공격 식별자 (T-ID)가 별로 다른 그램 패턴을 보인다. 즉, OP-CODE 와 ASM-CODE 의 조합을 기반으로 악성 코드 내 공격 기법들을 식별하는 실시 예에 따르면 공격 식 별자 (T-ID)별로 그램 데이터의 패턴이 나뉠 수 있다. 이 결과는 본 실시예에 따르면 공격자가 같더라도 악성 코드 내 숨겨진 여러 가지 공격 식별자 (T-ID)들을 명확 하게 식별할 수 있다는 것을 의미한다. 도 30은 개시한 사이버 위협 정보를 처리하는 실시 예의 성능을 예시한 도면이다. 이 도면은 개시한 실시예의 성능 중 공격 식별자 또는 공격자를 분류하는 연산 속도에 대한 성능을 예시한 것이다. 가로축은 데이터베이스에 저장된 데이터의 양을 나타내고 세로축은 공격 식별자를 분류하는데 소요되는 시간을 나타낸다. 데이터베이스에 저장된 퍼지 해쉬 데이터의 데이터의 개수를 증가시키면서, 일반적인 샘플을 각각 N : 1 (N대 1)로 비교하면 데이터의 개수 에 따라 처리 시간이 기하급수적으로 증가할 수 있다. 예를 들어 단순히 해쉬 값 이나 퍼지 해쉬 값의 유사도만을 비교하면(ssdeep로 표시) 비교하는 데이터의 양에 따라 소요시간이 매우 증가 한다. 그러나 실시 예의 앙상블 머신 러닝 모델의 디시전 트리(Decision Tree) 모델을 이용하면 공격 식별자 등을 분 류하는 추론 시간이 데이터의 개수가 증가해도 증가하지 않는다. 즉 최적화된 비교 트리를 생성하는 디시전 트리(Decision Tree) 모델은 노드를 병렬적으로 처리할 수 있으므로 데이터 개수가 증가해도 계산 속도에 큰 영향을 받지 않는 장점이 있다. 도 31은 사이버 위협 정보의 탐지하는 탐지 엔진들을 이용하여 탐지 명을 제공하는 예를 나타낸 도면이다. 악성코드 탐지 분야의 다양한 엔진들이 개발되어 사이버 위협 정보를 탐지 수행이 되고 있다. 인공 지능 분석이 늘어나면서 악성 코드의 탐지 능력이 증가하였다고 하더라도 탐지된 악성 코드를 제대로 설명하고 그 정보를 제 공하지 못하면 이러한 탐지 능력의 효용성이 매우 떨어진다. 이 도면은 VirusTotal 사이트에서 제공하는 해외 유명의 탐지 엔진들(왼쪽)과, 각 그 탐지 엔진이 제공하 는 동일한 악성 코드의 탐지명(오른편)을 예시한 것이다. 동일한 악성 코드의 식별과 전달이 정확하게 이루어지지 않기 때문에 해당 악성 코드가 어떤 이유로 탐지되었는 지 식별하기 어렵다. 따라서 보안 담당자가 해당 정보에 기초하여 어떤 오브젝트에 대한 조치를 취해야 하는지 대응책을 찾기 힘들었고 보안 위협에 대한 리스크에 대응하기 힘들었다. 그러나 개시하는 실시 예는 표준화된 모델인 MITRE ATT&CK 등에서 제공하는 공격 식별자의 매트릭스 요소와 그 조합으로 사이버 위협 정보를 제공하고 표준화된 식별자(T-ID)로 악성 코드에 대한 정보 제공함으로써 범용성과 효율성을 매우 높일 수 있다. 이하에서는 개시한 실시 예에 기반하여 공격자 추적하고 새로운 공격을 예측할 수 있는 예를 부연하여 설명한다. 도 32는 실시 예에 따라 새로운 악성 코드와 공격 방식을 예시하는 일 예를 나타낸 도면이다. 코드의 개발자는 코드를 생성하는데 본인만의 고유의 습관들, 예를 들어 변수명 선언, 함수 호출 구조, 파라미 터 호출 방법 등을 사용하는 경향이 매우 높다. 프로그램의 개발이 논리의 흐름과 경험에 기반해 생성되기 때문 에 이러한 습관을 완전히 변경하는 것은 매우 어려운 것이다. 이러한 근거에 기반하여 실시 예는 코드 상의 이와 같은 결과물들을 개발자의 핑거 프린팅로 사용하여 공격자를 추적할 수 있다. 악성 코드의 공격 식별자(T-ID)를 기반으로 학습 데이터를 구성할 경우 위와 같은 특징 정보를 이용해서 개발자 를 특정할 수 있다. 악성 코드의 디스어셈블된 코드는 이러한 개발자의 고유 특성이나 습관을 반영하고 있다. 특정 해커가 특정 공격 기법을 구현하기 위해서 본인이 인지하지 못한 본인만의 사용하는 기법을 사용할 수 있 으며 그 코드의 복잡도가 증가할수록 특정 개발자를 지정할 수 있는 가능성이 높아진다. 또한 각 공격 식별자(T-ID) 별 OP-CODE 와 ASM-CODE 의 코드 블록을 조합하면 아직 알려지지 않은 신종 또는 변종의 악성 코드 탐지에도 사용될 수 있다. 이 도면은 아래와 실시 예에 따라 디스어셈블된 OP-CODE 와 ASM-CODE의 조합을 통해 현존하지 않는 새로운 TTP 의 조합을 만드는 예를 개시한다. 이 예에서 T1044, T1039, T1211,…, T-N은 각각 공격 식별자(T-ID)들을 예시한다. 각 공격 식별자에 대응하는 OP-CODE 1 ~ N 세트는 각각의 각 공격 식별자의 악성 코드에 포함되는 코드 세트를 의미한다. 여기서 예시한 바와 같이 malware 악성 코드는 기존에 알려진 공격 식별자T1044의 OP-CODE 1, T1039의 OP- CODE2, T1211의 OP-CODE3, 및, T-N의 OP-CODE 1 등을 조합을 포함하는 악성 코드라고 하자. 이러한 OP-CODE의 조합의 세트를 포함하는 malware 악성 코드는 이미 알려진 코드일 수도 있고 알려지지 않은 코드일 수도 있다. 유사한 방식으로 T1044의 OP-CODE 3, T1039의 OP-CODEN, T1211의 OP-CODE4 및, T-N의 OP-CODE 2 등을 포함하는 새로운 공격 기법을 찾을 수 있다. 또는 T1044의 OP-CODE 4, T1039의 OP-CODE4, T1211의 OP-CODE2 및, T-N의 OP-CODE 3 등을 포함하는 새롭고 알 려지지 않은 공격 기법을 찾을 수도 있다. 위에서는 편의상 OP-CODE의 조합만으로 공격 기법을 찾는 예를 개시하였으나, OP-CODE와 ASM-CODE를 조합하여 디스어셈블드 코드를 생성하면 공격 기법을 찾을 뿐만 아니라 공격자나 공격 그룹도 식별할 수 있다. 유사하게 OP-CODE와 ASM-CODE를 포함하는 디스어셈블드 코드의 재조합을 통해 새로운 코드 세트를 생성할 수 있 다. 실행 파일의 함수에 대응되는 OP-CODE 뿐만 아니라 실행 파일의 대상이나 저장 위치를 나타내는 ASM-CODE를 재구성하거나 또는 재조합된 디스어셈블드 코드를 생성할 수 있다. 이러한 재구성 디스어셈블드 코드를 머신 러닝을 통해 학습하여 기존에 분석된 악성 코드와 비교하면 세분화된 새로운 방식의 공격 기법과 이를 생성하는 공격자를 식별하는 것을 넘어 추후 공격 예측이 가능하다. 이렇게 새로운 TTP 의 조합과 공격 경로의 조합은 지금까지 존재 하지 않았던 새로운 사이버 위협 또는 악성코 드의 공격 방법을 만들어 낼 수 있는데, 실시 예는 이렇게 기존의 디스어셈블된 코드 세트를 조합하여 공격 가 능한 코드가 생성되는지 확인할 수 있다. 공격 가능한 코드인지 여부는 동적 분석 등의 테스트 등을 통해 확인 할 수도 있다. 따라서 실시 예는 디스어셈블된 코드 세트의 조합을 통해 향후 있을 보안 위협에 대응할 수 있는 정보를 제공할 수 있어 이에 대한 선제적인 대응이 가능하다. 예를 들면 조합된 코드에 기반하여 각 공격 기법(TTP) 별 사용 빈도나 사용 했을 때 성공 가능성 등의 값을 반 영한 코드를 생성할 수 있다. 또는 인공 지능을 학습을 통해 성공 확률이 높은 새로운 코드 블록 조합의 공격 코드나 악성 코드를 미리 생성 할 수 있다. 그리고 이러한 정보를 반영하여 기존 보안 제품들이 대응 할 수 있는 패턴을 생성하거나 내부 시스 템의 취약한 부분의 보안성을 강화할 수 있는 정보를 제공할 수 있다. 도 33은 사이버 위협 정보 처리 방법의 다른 일 실시 예를 예시한 도면이다. 입력된 실행 파일을 디스어셈블링하여 디스어셈블된 코드를 얻고 상기 디스어셈블된 코드를 재구성하여 재구성 된 디스어셈블드 코드를 얻는다(S3110). 디스어셈블된 코드를 얻고 재구성하는 예는 도 18 및 도 21 등을 참조하여 설명하였다. 상기 재구성된 디스어셈블드 코드를 일정한 포맷의 데이터 세트로 변환한다. 재구성된 디스어셈블드 코드를 일정한 포맷의 데이터 세트로 변환하는 예는 도 18, 도 21, 도 22, 도 23, 도 24 등에 예시하였다. 상기 변환된 일정한 포맷의 데이터 세트에 기초하여 유사 여부를 판단하고 상기 판단에 따라 상기 실행 파일에 포함된 사이버 위협 공격 기법을 적어도 하나 이상의 정형화된 공격 식별자로 분류한다(S3130) 이 단계의 유사도 판단과 공격 식별자의 분류하는 예는 도 19, 도 20, 도 21, 도 25, 도 26, 도 27 등을 참조하 여 설명하였다. 도 34는 사이버 위협 정보 처리 장치의 다른 일 실시 예를 예시한 도면이다. 사이버 위협 정보 처리 장치의 다른 일 실시예는 프로세서를 포함하는 서버, 데이터베이스, 및 인 텔리전스 플랫폼을 포함할 수 있다. 인텔리전스 플랫폼은 응용 프로그램 인터페이스(Application Programming Interface) , 프레임워 크, 여러 가지 알고리즘과 수행 모듈을 실행하는 분석및예측모듈, AI 엔진을 포함할 수 있 다. 데이터베이스는 이미 분류된 악성 코드 또는 악성 코드의 패턴 코드를 저장할 수 있다. 서버의 프로세서는 응용 프로그램 인터페이스(Application Programming Interface) 로부터 수신된 실행 파일을 디스어셈블링하여 디스어셈블된 코드를 획득하고 상기 디스어셈블된 코드를 재구성하여 재구성된 디스어셈블드 코드를 얻는 제 1 모듈의 수행할 수 있다. 제 1 모듈의 수행 과정의 예는 도 18, 도 21, 도 22, 도 23, 도 24 등에 예시하였다. 그리고 서버의 프로세서는 상기 재구성된 디스어셈블드 코드를 특정 포맷의 데이터 세트로 변환하는 코드 처리 모듈을 수행하도록 하는 제 2 모듈을 수행할 수 있다.제 2 모듈의 수행 과정의 예는 도 18, 도 21, 도 22, 도 23, 도 24 등에 예시하였다. 서버의 프로세서는 상기 변환된 특정 포맷의 데이터 세트에 기초하여 상기 저장된 악성코드와 유사 여부 를 판단하고 상기 판단에 따라 상기 변환된 특정 포맷의 데이터 세트를 적어도 하나 이상의 정형화된 공격 식별 자로 분류하는 제 3 모듈을 수행할 수 있다. 제 3 모듈)의 수행 과정의 예는 도 19, 도 20, 도 21, 도 25, 도 26, 도 27 등을 참조하여 설명하였다. 도 35는 사이버 위협 정보 처리 방법의 다른 일 실시 예를 예시한 도면이다. 입력된 실행 파일을 디스어셈블링하여 디스어셈블된 코드를 얻고 상기 디스어셈블된 코드를 재구성하여 재구성 된 디스어셈블드 코드를 얻는다(S3110). 디스어셈블된 코드를 얻고 재구성하는 예는 도 18 및 도 21 등을 참조하여 설명하였다. 상기 재구성된 디스어셈블드 코드를 처리하여 해쉬 함수로 변환하고 상기 해쉬 함수를 N 그램(N-gram) 데이터로 변환한다. 재구성된 디스어셈블드 코드를 일정한 포맷의 데이터 세트로 변환하는 예는 도 21, 도 24 등에 예시하였다. 상기 변환된 N 그램(N-gram) 데이터의 블록 단위의 코드에 대해 앙상블 머신 러닝을 수행하여 상기 블록 단위의 코드를 상기 블록 단위의 코드가 수행하는 공격 기법의 식별자 및 상기 블록 단위의 코드를 생성한 공격자의 식 별자로 프로파일링한다(S3130) 이 단계의 공격 기법의 식별자와 공격자의 식별자를 프로파일링하는 예는 도 19, 도 20, 도 21, 도 25, 도 26, 도 27 등을 참조하여 설명하였다. 도 36은 사이버 위협 정보 처리 장치의 다른 일 실시 예를 예시한 도면이다. 사이버 위협 정보 처리 장치의 다른 일 실시예는 프로세서를 포함하는 서버, 데이터베이스, 및 인 텔리전스 플랫폼을 포함할 수 있다. 인텔리전스 플랫폼은 응용 프로그램 인터페이스(Application Programming Interface) , 프레임워 크, 여러 가지 알고리즘과 수행 모듈을 실행하는 분석및예측모듈, AI 엔진을 포함할 수 있 다. 데이터베이스는 이미 분류된 악성 코드 또는 악성 코드의 패턴 코드를 저장할 수 있다. 서버의 프로세서는 응용 프로그램 인터페이스(Application Programming Interface) 로부터 수신된 실행 파일을 입력된 실행 파일을 디스어셈블링하여 디스어셈블된 코드를 얻고 상기 디스어셈블된 코드를 재구성 하여 재구성된 디스어셈블드 코드를 얻는 제 1 모듈의 수행할 수 있다. 제 1 모듈의 수행 과정의 예는 도 18 및 도 21 등을 예시하였다. 그리고 서버의 프로세서는 상기 재구성된 디스어셈블드 코드를 처리하여 해쉬 함수로 변환하고 상기 해쉬 함수를 N 그램(N-gram) 데이터로 변환하는 제 2 모듈을 수행할 수 있다. 제 2 모듈의 수행 과정의 예는 도 21, 도 24 등에 예시하였다. 서버의 프로세서는 상기 변환된 N 그램(N-gram) 데이터의 블록 단위의 코드에 대해 앙상블 머신 러닝을 수행하여 상기 블록 단위의 코드를 상기 블록 단위의 코드가 수행하는 공격 기법의 식별자 및 상기 블록 단위의 코드를 생성한 공격자의 식별자로 프로파일링하는 제 3 모듈을 수행할 수 있다. 제 3 모듈의 수행 과정의 예는 도 19, 도 20, 도 21, 도 25, 도 26, 도 27 등을 참조하여 설명하였다. 따라서 개시한 실시예에 따르면 머신 러닝으로 학습된 데이터와 정확하게 일치하지 않는 악성 코드라도 탐지하 고 대응할 수 있고 악성 코드의 변종에 대응할 수 있다. 실시예에 따르면 악성 코드의 변종이라도 매우 빠른 시간 내에 악성 코드, 공격 기법 및 공격자를 식별할 수 있 고 나아가 추후의 특정 공격자의 공격 기법을 예측할 수 있다. 실시예에 따르면 이러한 악성 코드 여부, 공격 기법, 공격 식별자 및 공격자를 기반으로 사이버 공격 구현 방식 을 정확히 식별하고 이를 표준화된 모델로 제공할 수 있다. 실시예에 따르면 악성코드 탐지 명 등이 통일되지 않거나 사이버 공격 기법이 정확하게 기술되지 못하는 악성 코드의 정보를 정규화되고 표준화된 방식으로 제공 할 수 있다. 또한 기존에 알려지지 않은 악성 코드를 생성 가능성과 이를 개발할 수 있는 공격자들을 예측하고 미래에 어떤 사이버 위협 공격이 있을지 예측 가능한 수단을 제공할 수 있다. 도 37은 사이버 위협 정보 처리를 위한 다른 일 실시 예를 설명하기 위한 예시도이다. 악성 코드는 모바일 메시지, 전자 메일 등을 여러 사용자들이 이용하는 전자 문서 등을 통해 유포될 수 있다. 이 도면은 문자메시지의 피싱(SMS phishing), 즉 스미싱(Smishing)으로 유포되는 SMS 문자 메시지의 예시를 나 타낸다. 악성 코드는 예시한 문자 메시지를 수신한 사용자가 문자 메시지에 포함된 링크를 클릭하면 사용자의 모바일 기 기에서 실행되도록 설계된다. 여기서 이러한 악성 코드 유포를 위한 링크는 다양한 형태의 웹 페이지 또는 실행 가능한 모바일 앱의 경로를 포함할 수 있다. 여기서는 모바일 문자 메시지를 예시하였으나 이러한 악성코드를 유포시키는 전자 문서는 블로그, SNS 또는 전 자 메일와 같은 전자 문서나 전자 문서에 첨부된 다른 문서를 포함한다. 종래의 이러한 악성 코드의 특징을 기술적으로 표현한 정보를 공개하여 해당 분야의 기술자가 아닌 일반적인 사 용자는 이러한 악성 코드에 대한 정보를 검색하여도 어떤 악성 코드인지 구분하거나 이해하기 힘들었다. 이하에서는 사용자에게 악성코드 검색 결과의 편의를 제공할 수 있는 실시 예를 개시한다. 도 38은 사용자가 실시 예에 따른 사이버 위협 정보 처리 장치에 악성 코드를 검색한 결과의 예를 나타낸다. 사용자가 위와 같은 스미싱 문자 메시지의 악성 코드를 검색한 경우, 실시 예는 해당 악성코드의 특징을 나타낼 수 있는 정보, 예를 들면 그 악성 코드의 코드블록의 해쉬 함수 결과 값을 제공할 수 있다. 이 예에서는 검색된 악성 코드의 MD5, SHA-1, SHA-256 해쉬 함수 결과 값을 제공한다. 악성 코드 검색 결과를 제공하는 일 예는 악성 코드의 파일 사이지(file size), 파일 타입(EXE)과 비트 수(32 bit), 및 알려진 날짜를 제공할 수 있다. 악성 코드 검색 결과를 제공하는 일 예는 AI 엔진 검색에 따라 분류된 악성코드 분류와, 이 악성코드를 검색할 수 있는 기술적인 정보를 태그(tag) 값으로 제공한다. 위에서 개시한 바와 같이 전자 문서를 통해 전달되거나 연결되는 실행파일에 포함되는 악성 코드를 식별한 경우, 해당 악성 코드에 관련된 사이버 위협 침해 정보(IoC)는 그 악성 코드의 연관 관계 분석 등을 통해 얻을 수 있다. 예를 들면 사이버 위협 침해 정보(IoC)는 악성 코드와 관련된 IP, Hostname, URL, Hash 값 등을 포함 한다. 앞의 예시에서 이 문자 메시지를 통해 유포되는 악성 코드에 관련된 사이버 위협 침해 정보(IoC)는 URL은 “ https//abc.com/1823f”이다. . 위에 개시한 실시 예에 따르면, 예시한 메시지에 의해 유포되는 실행파일을 코드블록으로 변환하고, 변환된 코 드블록을 기반으로 악성코드를 식별하고 그 공격 기법과 공격자를 식별할 수 있다. 그리고 사용자가 이 악성코 드를 검색하는 경우 사이버 위협 침해 정보(IoC)로서 URL인 “https//abc.com/1823f”를 결과 정보로 제공할 수 있다. 이러한 방식은 악성코드의 기술적인 특징 정보를 제공하는 것이다. 그러나 이러한 악성 코드 검색 결과 정보는 일반인들에게는 악성 코드에 대한 식별과 관련 정보를 식별하도록 하는데 한계가 있을 수 있다.도 39는 사용자가 악성 코드를 검색할 경우 사이버 위협 정보를 처리하는 방법의 일 예를 개시한다. 수신된 실행 파일을 일정 포맷의 코드블록으로 변환할 수 있다(S3310). 그리고 변환된 코드블록에 기초하여 기 분류된 악성코드와 유사도를 판단하고 상기 실행 파일이 포함하는 악성 코드를 식별 및 분류해 낼 수 있다(S3320). 이에 대한 실시 예는 도 10 내지 도 36개시한 예에 따른다. 실시 예는 상기 식별 및 분류된 악성코드와 연관된 전자 문서가 가진 자연어를 추출하고, 그 추출된 자연어를 상기 식별 및 분류된 악성코드와 대응시켜 등록 또는 저장할 수 있다(S3330). 그리고 사용자가 사이버 위협 정보 처리 장치의 실시 예에 악성코드 검색 요청하면, 사이버 위협 정보 처리 장 치의 실시 예는 악성코드의 기술적인 정보뿐만 아니라 악성코드를 포함하거나 유도한 전자 문서의 자연어를 검 색 결과 정보로 제공한다. 그런데 여기서 개시하는 실시 예는 이러한 기술적인 특징 정보 이외에 사용자에게 악성코드가 실행되도록 유도 하도록 한 메시지의 자연어를 검출하고 처리하여 그 결과를 사용자에게 제공할 수 있다(S3340). 따라서 사용자가 관련 악성코드를 검색할 경우 악성코드의 기술적인 특징 정보뿐만 아니라 자연어 처리 결과 정 보를 함께 제공하여 사용자가 해당 특징을 쉽게 파악하게 할 수 있다. 도 40은 실시 예에 따른 사이버 위협 정보 처리 장치의 다른 일 예를 개시한다. 인텔리전스 플랫폼의 응용 프로그래밍 인터페이스(API)는 클라이언트로부터 사이버 보안의 공격 행위를 수행하는 악성 코드와 그와 관련된 전자 문서들을 포함하는 파일을 수신할 수 있다. 인텔리전스 플랫폼의 정보처리프레임워크는 파일로부터 여러 가지 메타 정보를 얻을 수 있고, 전 자 메일 등 전자 문서 등에 관련된 정보를 수집할 수 있다. 정보처리프레임워크는 수신된 파일 내에 실행 파일을 추출하여 분석프레임워크와 AI 엔진(2123 0)에 전달하여 실행 파일 내에 악성 코드를 분석하도록 할 수 있고, 예측 프레임워크에 전달하여 향후 미래의 공격 기법 등에 대한 예측 분석을 수행한다. 이에 대해서는 도 10 내지 도 36의 실시 예를 참고할 수 있 다. 정보처리프레임워크는 수신한 파일과 관련된 전자 문서와 메타 정보로부터 사이버 위협 정보(IoC)를 추 출할 수 있다. 예를 들면 파일 내에 포함된 URL, Hostname, IP 정보 등 사이버 위협 정보(IoC)를 추출할 수 있 다. 위에서 위에서 예시한 문자 메시지의 경우 정보처리프레임워크는 문자 메시지로부터 “ https://abc.com/1823f” 의 URL 정보를 추출할 수 있다. 정보처리프레임워크는 수신한 파일과 관련된 전자 문서와 메타 정보로부터 그 파일 내 추출된 악성 코드 에 관련된 키워드를 자연어 기반으로 추출할 수 있다. 위에서 예시한 문자 메시지의 경우 정보처리프레임워크는 문자 메시지로부터 설날, 대출, 이자 등의 자 연어 기반의 키워드를 추출할 수 있다. 인텔리전스 플랫폼는 추출한 자연어 기반의 키워드 등을 데이터베이스에 등록하여 저장하도록 한 다. 그리고 추후에 어떤 클라이언트가 인텔리전스 플랫폼에 이 악성코드에 대한 검색하거나 정보를 조회한 경우, 정보처리프레임워크는 클라이언트에게 악성코드의 특징 정보뿐만 아니라 사이버 위협 정보(IoC)와 관련 자연어 기반의 키워드를 제공할 수 있다. 정보처리프레임워크는 자연어 기반의 키워드가 검색에 용이하도록 해시태그와 함께 제공할 수 있다. 위에서 개시한 바와 같이 서버는 중앙처리장치를 이용해 개시한 프레임워크 등의 동작을 수행하도록 하 고 위 정보들을 데이터베이스에 저장시킬 수 있다. 그리고 서버는 사용자가 악성 코드를 검색할 경우 사용자 인터페이스를 통해 위에 예시한 정보를 제공할 수 있다. 도 41은 실시 예에 따라 사이버 위협 정보를 처리하여 사용자에게 악성코드에 대한 정보를 제공하는 예를 나타 낸 도면이다. 이 도면은 위에서 예시한 동일한 문자 메시지와 그 악성 코드에 관련된 정보를 추출하여 저장한 후 사용자의 검 색 요청에 따라 정보를 제공한 예를 나타낸다. 사용자가 예시한 스미싱 문자 메시지의 악성 코드를 검색한 경우, 실시 예는 검색 요청한 악성 코드의 MD5, SHA-1, SHA-256 해쉬 함수 결과 값을 제공한다. 악성 코드 검색 결과의 예는 악성 코드의 파일 사이지(file size), 파일 타입(EXE)과 비트 수(32 bit), 및 알려 진 날짜 등을 포함한다. 그리고 악성 코드 검색 결과의 예는 요청된 악성코드에 관련된 사이버 위협 침해 정보(IoC)인 URL, “ https//abc.com/1823f”을 포함한다. 그리고 그리고 악성 코드 검색 결과의 예는 해쉬 태그(#)와 악성 코드를 유포시킨 전자 문서에 포함된 키워드 (설날, 대출, 이자)를 결합한 결과를 사용자에게 제공한다. 따라서 사용자는 실시 예에 따라 악성 코드 검색할 경우 악성 코드의 기술적인 특징 정보 이외에 그 악성코드와 관련된 사이버 위협 침해 정보(IoC)와 관련 키워드에 대한 정보를 함께 얻을 수 있다. 실시 예에 따르면 이러한 악성 코드에 대한 상세한 기술적인 정보 이외에 일반인이 이해할 수 있는 자연어 기반 의 태그 정보를 제공하여 악성코드 식별과 유포 대응 정보 생성을 쉽게 수행 할 수 있다. 그리고 실시 예에 따 르면 필요한 정보를 각종 사회 이슈 기반 주요 키워드를 통해 트랜드 파악 등의 추가적인 인텔리전스를 확보 할 수 있다. 악성 코드 제작자는 안티 바이러스 탐지를 피하기 위해 지속적으로 신종 또는 변종 악성코드를 생성한다. 일상 생활에서 이러한 악성 코드 데이터도 끊임없이 생산되지만, 새로운 형태의 정상적인 소프트웨어나 데이터도 계 속 생산 및 개발되고 있다. 기계 학습 기반의 분류 모델은 여러 가지 실행 파일들을 입력받아 지속적으로 정상 또는 악성 파일여부에 대한 분류를 수행한다. 어떤 통계에 따르면 하루에 수집되는 샘플 데이터 또는 파일의 약 66%는 새로운 데이터 또는 파일이다. 따라서, 기계 학습 분류 모델의 과거 데이터를 기반으로 학습을 수행한 모델은 새로운 데이터와 파일 에 탐지 또는 분류 성능이 떨어질 가능성이 높다. 여기서는 편의상 기계 학습 기반의 악성 코드 탐지 모델을 학습 모델이라고 호칭하는데, 위에서 개시한 바와 같 이 실시 예들에 따른 사이버 위협 정보 처리 장치 또는 그 방법은 이런 학습 모델을 포함한다. 이하에서는 이 학습 모델이 과거에 입력되었던 데이터나 새로운 데이터가 입력되는 경우에도 지속적으로 모델 성능을 실시간으로 검증하고 유지할 수 있는 실시 예들을 개시한다. 그리고 이러한 모델 성능을 검증할 수 있는 사이버 위협 정보 처리 장치, 그 방법 및 그 절차들을 수행하는 컴퓨터로 실행가능한 프로그램의 실시 예를 개 시한다. 도 42는 사이버 위협 정보를 처리하는 모델을 검증할 수 있는 사이버 위협 정보 처리 방법의 일 실시예를 예시 한 도면이다. 사이버 위협 정보를 처리하는 기계 학습 기반 악성 코드 탐지 모델을 평가하기 위해 평가 대상 데이터를 입력받 는다(S3910). 여기서 기계 학습 기반 악성 코드 탐지 모델은 사이버 위협 정보를 분석, 검출, 예측하는 모델이 될 수 있다. 기술한 도 10, 도 11 내지 도 19, 도 21, 도 34, 도 36, 도 40에서 개시한 모델들은 여기서 언급하는 기계 학습 기반 악성 코드 탐지 모델이 될 수 있다. 기계 학습 기반 악성 코드 탐지 모델들이 출력하는 데이터를 평가할 수 있도록 검증 모델의 실시 예는 데이터를 수신하는데 이하에서는 수신하는 데이터를 평가 대상 데이터로 호칭한다. 평가 대상 데이터에 대한 평가를 진행하기 위한 준비로서 입력된 데이터에 대해 필터링을 수행한다. 상기 필터링된 평가 대상 데이터에 대해 악성 여부에 대한 레이블링을 수행한다(S3920). 평가 데이터의 레이블 링은 평가 대상 데이터에 대한 정상 또는 악성 판단을 의미한다. 평가 대상 데이터가 악성 코드 포함하거나 또 는 악성 행위를 수행하는지를 결정하여 해당 평가 데이터에 악성 여부에 대한 레이블링을 수행한다. 평가 대상 데이터에 대한 레이블링을 수행할 경우 제 3 학습 모델이나 악성 코드 분류 모델의 질의 결과를 이용할 수 있다. 이에 대한 상세한 예를 이하에서 개시한다. 평가 대상 데이터에 대해 전처리를 수행한다(S3930). 여기서 기계 학습 기반 악성 코드 탐지 모델이 출력하는 평가 대상 데이터의 원본 데이터를 확보하고 그 원본 데이터의 특징 정보를 추출할 수 있다. 기계 학습 기반 악 성 코드 탐지 모델이 적절히 동작하는지 확인하기 위해 기계 학습 기반 악성 코드 탐지 모델에 입력된 원본 데 이터 또는 그 원본 데이터의 특징 정보를 확인하는 단계이다. 전처리를 수행하여 추출한 평가 대상 데이터의 특징 정보를 검증 모델에 입력하여 예측된 결과 데이터와 상기 레이블링에 기반하여 평가된 결과 데이터를 생성하고 제공한다(S3940). 평가 결과 데이터는 예를 들어 모델 성능과 관련된 스코어나 모델의 악성 정보 분류에 대한 데이터일 수 있다. 도 43은 기계 학습 기반 악성 코드 탐지 모델의 성능을 검증하는 모델의 개념을 예시한 예시도이다. 기계 학습 기반으로 사이버 위협 정보를 학습하고 처리하는 모델을 검증하기 위해 사이버 위협 정보를 생성, 분 류, 검출하는 학습 모델 및 검증 모델을 예시하였다. 검증 모델은 실시간으로 자동으로 모델을 성능을 평가한 결과를 표출할 수 있다. 따라서, 학습 모델을 포함하는 사이버 위협 정보의 처리 장치의 성능이 떨어질 경우 이하에서 기술하는 여러 가지 조치를 실시간으로 수행할 수 있다. 예시하는 학습 모델은 학습데이터를 생성 또는 구성하는 모듈, 생성된 학습 데이터로 모델을 학습하는 모듈을 포함할 수 있다. 예를 들어 학습 모델은 도 16 내지 도 18, 도 21, 도 26에 포함된 사이버 위협 정보를 생성, 분류, 검출 하는 학습 모델이 될 수 있다. 학습 모델은 사이버 위협 정보를 탐지, 검출 또는 분류하기 위해 학습 데이터를 구성하고 여러 가지 기 계 학습을 이용할 수 있다. 개시한 예에서 검증 모델은 학습 모델로부터 실시간으로 학습된 모델 결과 데이터를 입력받을 수 있다. 검증 모델은 학습 모델이 출력하는 모델 결과 데이터를 평가 대상 데이터로서 입력받고 이를 검 증하고 검증된 모델 결과를 표출할 수 있다. 검증 모델은 데이터 준비 모듈, 데이터 레이블링 모듈, 데이터 전처리 모듈, 및 모델 평가 모듈을 포함할 수 있다. 데이터 준비 모듈은 학습 모델이 학습한 모델 결과 데이터를 입력받고 이를 필터링하여 평가 대 상 데이터를 준비할 수 있다. 이하에서 검증 모델이 입력 받는 학습 모델의 결과 데이터를 피드 데이터(feed data)로 호칭한다. 데이터 준비 모듈는 학습 모델로부터 피드 데이터(feed data)를 다운로드한다. 데이터 준비 모듈 는 다운로드한 피드 데이터 중 최근의 일정 시간 내 입력된 데이터를 필터링하여 평가 대상 데이터 또는 검증 데이터로 준비한다. 위에서 기술한 바와 같이 수집되는 데이터의 상당한 량의 신규 샘플 데이터를 포함할 수 있다. 따라서, 최근의 일정 시간 내 입력된 데이터는 과거 샘플링을 수행했던 샘플 데이터와 신규 샘플 데이터가 함께 포함될 수 있다. 참고로 기계 학습에서 입력 데이터의 변화에 따라 모델을 재학습할 때, 과거 데이터는 필요하지 않는 경우도 있 다. 그러나, 악성 코드를 탐지할 경우 과거의 악성 코드 데이터가 현재에도 위협이 될 수 있기 때문에 신규 샘 플만 사용할 경우, 과거 악성코드 데이터에 대한 분류 성능을 보장할 수 없다. 따라서, 여기서 신규 샘플 데이 터와 과거 샘플 데이터에 대해 학습 모델의 검증과 그에 따른 학습 모델의 업데이트가 수행될 수 있다. 검증 모델는 개시한 사이버 위협 정보 처리 장치의 데이터 베이스로부터 특정 시간 대의 피드 데이터를 다운로드 할 수 있다. 예를 들면 데이터 준비 모듈는 위에서 개시한 인텔리전스 플랫폼 실시 예 의 데이터 베이스로부터 특정 시간대인 2022년 04월 25일 00시 00분부터 2022년 04월 25일 00시 10분까지 다운로드했다고 가정한다. 데이터 준비 모듈이 다운로드한 피드 데이터는 위 시간대에 검색된 파일의 목록, 그 목록의 각 파일의 해쉬 정보(예, SHA256 해쉬 값), 분석 날짜, 그 파일의 타입 정보를 포함할 수 있다. 데이터 준비 모듈은 검증 모델의 검증에 필요한 특정 타입의 파일을 제외한 다른 타입의 파일은 필터링을 통해 제거한다. 데이터 준비 모듈이 특정 타입의 파일을 필터링할 경우 예를 들어 파일의 확장 자 등을 이용할 수 있다. 데이터 레이블링 모듈은 학습 모델의 성능을 평가하기 위해 데이터 준비 모듈이 필터링한 파일의 해쉬 정보를 적어도 하나 이상의 다른 사이버 위협 정보 처리 장치 또는 플랫폼에 질의하여 상기 필터링 한 파일의 샘플 데이터가 악성 행위를 포함하는지 판단할 수 있다. 데이터 레이블링 모듈은 적어도 하나 이상의 제 3의 사이버 위협 정보 처리 장치 또는 제 3의 악성 코드 식별 플랫폼에 준비된 특정 샘플 데이터의 악성 여부를 질의한다. 데이터 레이블링 모듈은 질의 결과로부터 샘플 데이터에 포함된 악성 코드 탐지 개수(여기서는 positive_count로 표시)를 얻는다. 예를 들어 질의한 제 3의 악성 코드 식별 플랫폼이 해당 샘플 데이터로부터 악성 코드 탐지 개수가 10개라면 탐지된 개수인 10개를 기반으로 해당 샘플 데이터의 악성 여부를 레이블링한다. 어느 경우도 해당 샘플 데이터를 정상과 악성으로 구분할 수 있는 절대적인 수치가 존재하지 않는다. 따라서, 악성 코드 식별 플랫폼이 해당 샘플 데이터내 악성 코드 탐지 개수가 제 1 특정 값 이하인 경우 정상으로 설정 하고, 제 2 특정 값 이상인 경우 악성이라고 설정할 수 있다. 그리고 해당 샘플 데이터를 악성으로 탐지한 개수(positive_count)가 제 1 특정 값과 제 2 특정 값 사이인 경우 해당 샘플 데이터에 대해서는 잡음으로 간주하여 학습 모델을 평가하는 값에 사용하지 않을 수 있다. 예를 들어 위의 예에서 제 1 특정 값을 0, 제 2 특정 값을 20이라고 한 경우, 특정 샘플 데이터 내 악성 코드 탐지 개수(positive_count)가 0인 경우 그 샘플 데이터를 정상으로 판정하고, 특정 샘플 데이터 내 악성 코드 탐지 개수(positive_count)가 20이상인 경우 악성으로 판정한다. 그리고 특정 샘플 데이터 내 악성 코드 탐지 개수가 1개 이상이고 19개 이하인 경우 과탐이나 오탐으로 인한 오 류로 간주하여 학습 모델을 평가하는 데는 사용하지 않는다. 따라서, 데이터 레이블링 모듈은 피드 데이터에 포함되는 샘플 데이터의 해쉬 정보(예, SHA256 등)의 해 쉬 목록에 대해 악성 코드 탐지 개수(positive_count)를 기반으로 상기 샘플 데이터를 레이블링하여 저장한다. 데이터 레이블링 모듈은, 해당 샘플 데이터에 대해 해쉬 정보에 따른 악성 탐지 개수(positive_count)와 레이블링 값을 데이터 베이스에 저장할 수 있다. 데이터 레이블링 모듈은 상기 악성 탐지 개수와 레이블 링 값을 별도의 데이터 베이스에 저장할 수 있는데 이 예에서는 편의상 제 2 데이터 베이스 또는 레이블링 데이 터 베이스(DB)로 호칭한다. 데이터 전처리 모듈은 원본 샘플 데이터를 검증 모델에 입력할 수 있도록 가공한다. 위에서 개시한 것처럼 인텔리전스 플랫폼의 데이터 베이스는 수집한 파일과 그 파일에 대한 해쉬 정보(예, SHA256 해쉬 값)을 저장한다. 데이터 전처리 모듈은 인텔리전스 플랫폼의 학습 모델이 정상적인 성능으로 동작하는지 검증하기 위해 데이터 베이스에 저장된 해쉬 정보를 이용할 수 있다. 데이터 전처리 모듈은 이와 같이 사전에 저장된 샘플 데이터를 인텔리전스 플랫폼의 데이터 베이 스로부터 다운로드한다. 데이터 전처리 모듈은 다운로드한 샘플 데이터에 대해 타입 별 분석 모듈로부터 상기 그 샘플 데이터의 메타데이터를 추출할 수 있다. 메타 데이터는 상기 샘플 데이터의 악성 행위와 관련된 특징 정보를 포함할 수 있다. 예를 들어 메타 데이터는 JSON 파일 형식을 가질 수 있는데 도 21의 제 2 단계에 표시되는 벡터화 정보 이거나 벡터화 되기 전의 정보일 수 있어 메타데이터의 재활용이 가능하고 해당 샘플 데이터를 다시 분석하는데 효율적 으로 사용할 수 있다. 데이터 전처리 모듈은 데이터 베이스에 저장된 샘플 데이터의 메타데이터를 이용하여 검증 모델 의 모델 검증에 활용할 수 있도록 메타데이터를 벡터화하고 벡터화한 메타데이터를 사용할 수 있다. 데이터 전처리 모듈이 기 저장된 샘플 데이터의 메타데이터를 벡터화하는 방식은 도 21에서 기술하였다. 데이터 전처리 모듈는 샘플 데이터의 특징을 가진 벡터화 데이터를 별도의 데이터 베이스에 저장하는데, 이 예에서는 편의상 제 3 데이터 베이스 또는 메타데이터 데이터 베이스(DB)로 호칭한다. 모델 평가 모듈은 데이터 전처리 모듈이 준비한 기 저장된 샘플 데이터의 벡터화된 데이터와 데 이터 레이블링 모듈이 생성한 레이블링 데이터를 이용하여 학습 모델을 검증할 수 있다. 모델 평가 모듈은 데이터 전처리 모듈의 벡터화된 데이터를 학습 모델에 입력하여 상기 벡터화된 데이터가 악성인지 여부를 검출하고, 이를 상기 데이터 레이블링 모듈이 생성한 레이블링 데이 터와 비교한다. 모델 평가 모듈은 학습 모델의 여러 가지 성능을 비교할 수 있는 특정 형식의 검증 데이터를 생 성하고 저장한다. 모델 평가 모듈이 검증 데이터를 저장하는 데이터 베이스를 여기서는 제 4 데이터 베 이스 또는 검증 결과 데이터베이스(DB)라고 호칭한다. 모델 평가 모듈이 생성하는 학습 모델의 성능 결과는 JSON 형식의 데이터의 레포트일 수도 있고, 실시간 대시보드(dashboard) 방식의 그래프로 표출될 수도 있다. 모델 평가 모듈이 생성하는 학습 모델의 성능 결과에 대해서는 이하에서 상세하게 개시한다. 도 44은 실시 예에 따라 사이버 위협 정보를 처리하는 모델을 검증하는 모델과 그 방법의 다른 일 예를 개시한 도면이다. 위에서 개시한 학습 모델의 실시간 검증 모델에 대한 다른 실시 예를 개시하면 다음과 같다. 데이터 준비 모듈은 특정 시간 대의 피드 데이터를 데이터베이스로부터 다운로드하고, 다운로드 데이터 중 확장자 등의 정보에 기반하여 학습 모델의 검증에 필요한 특정 타입의 파일을 제외한 다른 타입의 파일은 필 터링을 통해 제거한다. 피드 데이터는 상기 특정 시간 대의 신규 샘플 데이터와 이미 분석된 샘플 데이터를 포 함할 수 있다. 데이터 레이블링 모듈은 데이터의 악성 여부를 분류하는 제 3 분류 모델 또는 제 3의 악성 코드 탐지 플랫폼에 상기 필터링된 입력 데이터가 악성인지를 질의한다. 예를 들면 제 3 분류 모델은 구글의 바이러스 토 탈(Virus Total) 플랫폼과 같은 악성 코드 탐지 모델일 수 있다. 그리고 데이터 레이블링 모듈은 제 3 분류 모델로부터 상기 질의한 샘플 데이터와 관련된 안티 바이러스 탐지 개수, 즉 악성 행위 탐지 개수를 수신한다. 데이터 레이블링 모듈은 제 3 분류 모델로부터 상기 필터링된 입력 데이터와 관련된 악성 행위 탐지 개 수에 기반하여 상기 입력 데이터의 악성 여부를 레이블링한다. 그리고 데이터 레이블링 모듈은 상기 레 이블링한 정보를 제 2 데이터 베이스인 레이블링 데이터 베이스에 저장한다. 데이터 전처리 모듈은 상기 입력 데이터와 관련된 원본 샘플 데이터를 얻기 위해 원본 샘플 데이터가 저 장된 샘플 데이터 베이스로부터 원본 샘플 데이터를 다운로드한다. 학습 모델의 성능을 평가하고 검증하기 위해 데이터 전처리 모듈은 학습 모델 입력 이전에 상기 입력 데 이터와 관련된 원본 샘플 데이터를 확보한다. 그리고 데이터 전처리 모듈은 다운로드한 원본 샘플 데이터를 타입 별 분석을 통해 메타데이터를 추출한 다. 샘플 데이터의 메타데이터는 벡터화된 데이터 또는 벡터화 이전의 데이터와 같이 원본 샘플 데이터의 특징 정보일 수 있다. 데이터 전처리 모듈은 원본 샘플 데이터의 특징 정보로서 추출한 메타 데이터를 제 3 데이터베이스인 메타데이터 데이터 베이스에 저장한다. 모델 평가 모듈은 상기 벡터화된 데이터를 학습 모델에 입력하여 모델의 결과를 수신하고, 상 기 저장된 레이블링 정보를 비교하여 학습 모델의 성능을 평가하고 검증할 수 있는 결과 데이터를 얻을 수 있다. 모델 평가 모듈은 결과 데이터를 제 4 데이터베이스인 검증 결과 데이터 베이스에 저장한다. 따라서, 실시 예는 입력된 데이터를 제 3 분류 모델 또는 악성 코드 탐지 플랫폼에 질의하여 얻은 레이블링 정 보와 입력된 데이터와 관련된 기 저장 샘플 데이터의 학습 모델 결과를 비교하여 학습 모델의 성능을 실시간으 로 확인할 수 있다. 이 실시 예에서 데이터 준비 모듈, 데이터 레이블링 모듈, 데이터 전처리 모듈, 및 모델 평가 모듈는 컴퓨터에서 실행가능한 소프트웨어로 구현되거나 별도의 하드웨어로 구현될 수도 있다. 예를 들어 소프트웨어로 구현될 경우 컴퓨터의 프로세서는 위에서 예시한 데이터 준비 모듈, 데이터 레 이블링 모듈, 데이터 전처리 모듈, 및 모델 평가 모듈를 각각 수행하고, 각 데이터는 저 장 장치인 예시한 데이터 베이스(들)에 저장할 수 있다. 도 45는 위에서 개시한 사이버 위협 정보를 처리하는 실시 예에 따라 기계 학습 기반 악성 코드 탐지 모델의 검 증 결과 데이터를 나타낸 예를 개시한 도면이다. 개시한 실시 예에 따른 검증 모델은 검증 결과 데이터 베이스에 저장한 데이터를 대시보드에 실시간으로 표출하 여 학습 모델의 성능을 즉시 확인하고 유지하도록 조치할 수 있는 정보를 제공할 수 있다. 검증 모델은 예시한 바와 같이 제 2 내지 4 데이터 베이스에 각각 저장된 레이블링 정보, 파일의 특징 정보인 메타 데이터, 및 검증 결과 데이터를 이용해 학습 모델의 성능을 표출할 수 있다. 이 도면에서 그래프의 세로축은 학습 모델의 정확도 나타내고, 가로축은 시간 단위의 변화를 나타낸다. 여기서, 그래프는 2022년 4월 23일 0시부터 2022년 4월 25일 12시까지 6시간 단위로 학습 모델의 정확도를 표시한 것으 로 입력 데이터가 실행 파일(Executable file)인 경우를 학습 모델에 따른 성능을 나타낸다. 그래프상의 값 상 학습 모델의 정확도가 낮아지는 경우 이를 사용자가 즉시 확인할 수 있다. 따라서, 사용자는 이 그래프로부터 특정 실행 파일에 대한 학습 모델 성능이 낮을 경우 기계 학습 모델의 알고리즘 등을 수정하거나 다른 알고리즘 으로 대체하거나 재학습을 수행하도록 할 수 있다. 도 46는 개시한 사이버 위협 정보를 처리하는 실시 예에 따라 학습 모델의 검증 결과 데이터를 나타낸 다른 예 를 개시한 도면이다. 이 도면은 입력 데이터가 실행 파일이 아닌 경우(Non- Executable file) 인 경우 각 파일 타입 별 학습 모델 성 능을 나타낸 그래프이다. 이 도면에서 파일 타입으로서 PDF 파일, RTF 파일, HWP 파일, HWPX 파일, DOC 파일, DOCX 파일, PPT 파일, PPTX 파일, XLS 파일, XLSX 파일 PS 파일, ODT 파일 등을 예시하였다. 성능 그래프의 가로축은 시간을 나타내고 그래프의 세로축은 각 파일 타입 별 학습 모델의 성능을 나타낸 그래 프이다. 사용자는 성능 그래프로부터 해당 파일에 대한 학습 모델 성능이 낮아지는지 확인할 수 있다. 그리고 학습 모델 의 성능이 낮아지는 경우 기계 학습 모델의 알고리즘 등을 수정하거나 다른 알고리즘으로 대체하거나 재학습을 수행하도록 할 수 있다. 도 47는 개시한 사이버 위협 정보를 처리하는 실시 예에 따라 학습 모델의 검증 결과 데이터를 다른 예를 개시 한 도면이다. 이 도면은 입력 데이터가 여러 가지 이미지 파일 타입인 경우 학습 모델의 성능을 검증한 결과를 예시한다. 이미지 파일 타입은 JPG/JPEG 파일, PNG 파일, BMP 파일, GIF 파일, ICO 파일, EPS 파일, EMF 파일, TIFF 파일, SVG 파일, 및 PSD 파일 등 등을 예시하였다. 성능 그래프의 가로축은 시간을 나타내고 그래프의 세로축은 각 파일 타입 별 학습 모델의 성능을 나타낸 그래 프이다. 마찬가지로 사용자는 성능 그래프로부터 특정 이미지 파일에 대한 학습 모델 성능이 낮을 경우 기계 학 습 모델의 알고리즘 등을 수정하거나 다른 알고리즘으로 대체하거나 재학습을 수행하도록 할 수 있다. 도 48은 개시한 사이버 위협 정보를 처리하는 실시 예에 따라 학습 모델의 검증 결과 데이터를 통계적으로 표시 한 일 예이다. 실시 예에 따른 학습 모델의 검증 모델은 입력 데이터에 대한 정상 또는 악성 분류 정보에 실시간 통계 정보 및 여러 가지 분석 정보를 표출할 수 있다. 실시 예에 따른 검증 모델은 학습 모델의 성능 검증 뿐만 아니라 이를 기반으로 통계 정보를 제공함으로써 사용 자에게 사이버 위협 정보 처리 모델에 대한 여러 가지 인사이트(insight)를 도출하도록 할 수 있다. 이 도면에서 검증 모델이 제공하는 분석 정보의 예는, 일정 시간 단위의 입력 데이터에 대해 메타데이터 통계 정보량(No. of Metadata), 입력 데이터에 대한 결과 데이터 양(No. of Reports), 특정 시간 단위의 입력 데이 터의 크기(Queue size), 시간당 입력되는 데이터의 타입(Feed data), 지난 기간 대비 동일 기간의 날짜 별 유효 샘플 데이터의 량(No of Validation Sample), 입력 데이터의 파일 타입 별 통계 (File Type PI), 입력 데이터 의 레이블링 통계 (Labeling PI), 악성 행위에 대한 위협 타입 별의 통계 (Threat Type) 및 기존 데이터에서 분 석되지 않은 신규 데이터의 양(First Seen) 등에 대한 정보를 포함한다. 예시한 도면에서 메타데이터 통계 정보량(No. of Metadata)은 7,333,825개, 입력 데이터에 대한 결과 데이터 양 (No. of Reports)는 10,003,114개임을 예시한다. 특정 시간 단위의 입력 데이터의 크기(Queue size)는 시간에 따라 입력 데이터의 양이 크게 변화하는지 등을 알 수 있다. 시간당 입력되는 데이터의 타입(Feed data)은 특정 시간 단위로 입력 데이터에 포함되는 파일 타입별의 양을 제 공한다. 지난 기간 대비 동일 기간의 날짜 별 유효 샘플 데이터의 량(No of Validation Sample)은, 여기서 지난 3개월 대비의 유효 샘플 데이터와 그 샘플 데이터의 정상 또는 악성 여부를 표시한다. 입력 데이터의 파일 타입 별 통계 (File Type PI)는 파이 그래프 형식으로 입력 데이터의 파일 타입을 표시한다. 입력 데이터의 레이블링 통계 (Label PI)는 입력 데이터를 다른 분류 모델에 질의하여 해당 데이터가 정상 또는 악성인지의 통계를 나타낸다. 그리고 악성 행위에 대한 위협 타입 별의 통계 (Threat Type)는 입력 데이터가 악성인 경우 위협 타입을 직관적 으로 제공한다. 실시 예는 입력 데이터의 종류 및 해당 데이터 별 학습 모델의 성능과 시간별 추이 및 위협 타입 등을 사용자에 게 실시간으로 제공할 수 있다. 사용자는 학습 모델에 대한 검증 결과를 실시간으로 얻고 특정 파일, 특정 위협 또는 특정 학습 알고리즘에 대한 성능을 즉시 확인할 수 있다. 그리고 학습 모델에 사용되는 기계 학습의 알고리즘을 변수를 조절하거나 적용 알고리즘을 일부 변경하거나 또 는 변환하거나 입력 데이터 세트를 변환하여 학습하거나 재학습을 수행한다. 이러한 방식으로 학습 모델의 성능 이 지속적으로 평가 및 유지되도록 할 수 있다. 이하에서는 위와 같이 검증 모델의 실시간 자동 검증을 통해 얻은 정보에 기반해 기계 학습 기반의 악성 코드 탐지 모델의 성능이 떨어진 경우 사용자가 모델의 성능을 다시 높일 수 있는 예를 개시한다. 도 49는 위에서 예시한 기계 학습 기반의 악성 코드 탐지 모델의 성능을 개선하는 일 실시예를 개시한다. 여기서는 기계 학습 모델의 성능이 떨어진 경우 학습 모델을 재학습하기 위해 입력 데이터를 다음과 같이 변경 할 수 있다. 이 실시 예에서는 학습 모델을 재학습하기 위해 샘플 데이터 베이스로부터 원본 샘플 데이터를 다운로드할 필요가 없다. 샘플 데이터 베이스로부터 원본 샘플 데이터를 다운로드할 경우 위에서 개시한 바와 같이 전처리를 수행하고 특 징 정보인 벡터화 과정을 수행한다. 그러나, 개시한 바와 같이 제 3 데이터 베이스에 메타데이터를 저장하였기 때문에 학습 모델은 재학습을 위해 제 3 데이터 베이스로부터 입력 데이터의 메타데이터를 조회한다. 학습 모델은 메타데이터를 벡터화하여 학습 데이터를 생성하고 생성한 학습 데이터를 기반으로 재학습을 수행한다. 그리고 학습 모델은 모델 평가를 위한 데이터를 생성한다. 저장된 메타데이터를 기반으로 벡 터화 데이터를 생성하므로 학습 모델의 재학습 시간을 단축시킬 수 있다. 그리고 학습 모델은 모델 평가를 위해 검증 모델로 입력 데이터를 출력하고 검증 모델은 학습 모델이 출력하는 데이터를 이용하여 실시간 자동 검증 모델을 수행할 수 있다. 개시한 기계 학습 기반 악성 코드 탐지 모델을 검증하는 사이버 위협 정보 처리 방법 및 장치는 컴퓨터에서 실 행가능한 소프트웨어로 구현될 수도 있다. 그러한 경우 기계 학습 기반 악성 코드 탐지 모델에 의해 학습된 데 이터를 수신하고 상기 수신한 데이터에 포함된 파일 타입에 따라 상기 수신한 데이터 필터링하는 모듈, 제 3 악 성 코드 탐지 모델에 상기 필터링한 데이터이 악성 여부를 질의하고, 상기 질의 결과에 따라 상기 필터링한 데 이터에 레이블링(Labeling) 정보를 부여하는 모듈, 상기 필터링한 데이터의 원본 샘플 데이터에 대해 메타데이 터를 생성하고, 상기 메타데이터에 기반하여 상기 원본 샘플 데이터의 악성 코드 특징 정보를 추출하는 모듈, 및 상기 악성 코드 특징 정보와 상기 레이블링 정보에 기반하여 상기 기계 학습 기반 악성 코드 탐지 모델의 성 능을 평가하고 평가 결과를 제공하는 모듈을 포함할 수 있다."}
{"patent_id": "10-2022-0095587", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 사이버 위협 정보 처리 방법의 일 실시 예를 예시한 도면 도 2는 개시하는 실시 예에 따라 분석 정보 생성하는 과정에서 정적 분석 정보를 얻는 예를 개시한 도면 도 3은 개시하는 실시 예에 따라 분석 정보 생성하는 과정에서 동적 분석 정보를 얻는 예를 개시한 도면 도 4은 개시하는 실시 예에 따라 분석 정보 생성하는 과정에서 심층 분석 정보를 얻는 예를 개시한 도면 도 5는 심층 분석의 일 예로서 악성 코드를 디스어셈블링하여 악성 행위가 포함된 파일임을 판단하는 예를 개시 한 도면 도 6은 개시하는 실시 예에 따라 분석 정보 생성하는 과정에서 연관관계 분석 정보를 산출하는 일 예를 개시한 도면 도 7은 개시한 실시 예에 따라 연관관계 분석 정보를 얻는 과정의 일 예를 개시한 도면 도 8은 실시 예에 따라 사이버 위협 정보의 예측 정보 생성하는 일 예를 개시한 도면 도 9는 실시 예에 따라 사이버 위협 정보를 제공하기 위한 악성 코드 질의들의 예를 개시한 도면 도 10은 사이버 위협 정보 처리 장치의 일 실시 예를 개시한 도면 도 11은 개시하는 실시 예에 따라 분석 프레임 워크 중 정적 분석 모듈의 기능을 상세히 설명하기 위한 일 예를 나타낸 도면 도 12는 개시하는 실시 예에 따라 분석 프레임 워크 중 동적분석 모듈의 기능을 상세히 설명하기 위한 일 예를 나타낸 도면 도 13은 개시하는 실시 예에 따라 분석 프레임 워크 중 심층분석 모듈의 기능을 상세히 설명하기 위한 일 예를 나타낸 도면 도 14은 개시하는 실시 예에 따라 분석 프레임 워크 중 연관관계분석 모듈의 기능을 상세히 설명하기 위한 일 예를 나타낸 도면 도 15는 개시하는 실시 예에 따라 예측 프레임 워크의 예측정보생성 모듈의 기능을 상세히 설명하기 위한 일 예 를 나타낸 도면 도 16은 개시하는 실시 예에 따라 정적 분석을 수행하는 일 예를 나타낸 도면 도 17은 개시하는 실시 예에 따라 동적 분석을 수행하는 일 예를 나타낸 도면 도 18은 개시하는 실시 예에 따라 심층 분석을 수행하는 일 예를 나타낸 도면 도 19는 개시하는 실시 예에 따라 바이너리 코드에서 추출된 코드들로 공격 기법을 매칭하는 일 예를 나타낸 도 면 도 20은 개시하는 실시 예에 따라 OP-CODE를 포함하는 코드 세트와 공격 기법을 매칭하는 일 예를 나타낸 도면도 21은 개시하는 실시 예에 따라 사이버 위협 정보를 처리하는 흐름을 예시한 도면 도 22는 개시하는 실시 예에 따라 OP-CODE 및 ASM-CODE를 정규화된 코드로 변환한 값을 예시한 도면 도 23은 개시하는 실시 예에 따라 OP-CODE 및 ASM-CODE의 벡터화된 값을 예시한 도면 도 24는 개시하는 실시 예에 따라 코드의 블록 단위를 해쉬 값으로 변환하는 예를 개시한 도면 도 25는 개시하는 실시 예에 따른 앙상블 머신 러닝 모델의 일 예를 나타낸 도면 도 26은 개시하는 실시 예에 따라 머신 러닝으로 데이터를 학습하고 분류하는 흐름을 예시한 도면 도 27은 개시하는 실시 예에 따라 학습 데이터로 공격 식별자와 공격자를 식별하여 라벨링을 수행한 예를 나타 낸 도면 도 28은 실시 예에 따라 공격 식별자를 식별한 결과를 나타낸 도면 도 29는 실시 예에 따라 공격 식별자에 따른 그램 데이터 패턴을 예시한 도면 도 30은 개시한 사이버 위협 정보를 처리하는 실시 예의 성능를 예시한 도면 도 31은 사이버 위협 정보의 탐지하는 엔진들의 탐지 엔진들을 탐지 명을 제공하는 예를 나타낸 도면 도 32는 실시 예에 따라 새로운 악성 코드와 공격 방식을 예시하는 일 예를 나타낸 도면 도 33은 사이버 위협 정보 처리 방법의 다른 일 실시 예를 예시한 도면 도 34는 사이버 위협 정보 처리 장치의 다른 일 실시 예를 예시한 도면 도 35는 사이버 위협 정보 처리 방법의 다른 일 실시 예를 예시한 도면 도 36은 사이버 위협 정보 처리 장치의 다른 일 실시 예를 예시한 도면 도 37은 사이버 위협 정보 처리를 위한 다른 일 실시 예를 설명하기 위한 예시도 도 38은 사용자가 실시 예에 따른 사이버 위협 정보 처리 장치에 악성 코드를 검색한 결과의 예를 나타낸 도면 도 39는 사용자가 악성 코드를 검색할 경우 사이버 위협 정보를 처리하는 방법의 일 예를 개시한 도면 도 40은 실시 예에 따른 사이버 위협 정보 처리 장치의 다른 일 예를 개시한 도면 도 41은 실시 예에 따라 사이버 위협 정보를 처리하여 사용자에게 악성코드에 대한 정보를 제공하는 예를 나타 낸 도면 도 42는 사이버 위협 정보를 처리하는 모델을 검증할 수 있는 사이버 위협 정보 처리 방법의 일 실시예를 예시 한 도면 도 43은 기계 학습 기반 악성 코드 탐지 모델의 성능을 검증하는 모델의 개념을 예시한 예시도 도 44은 실시 예에 따라 사이버 위협 정보를 처리하는 모델을 검증하는 모델과 그 방법의 다른 일 예를 개시한 도면 도 45는 위에서 개시한 사이버 위협 정보를 처리하는 실시 예에 따라 기계 학습 기반 악성 코드 탐지 모델의 검 증 결과 데이터를 나타낸 예를 개시한 도면 도 46는 개시한 사이버 위협 정보를 처리하는 실시 예에 따라 학습 모델의 검증 결과 데이터를 나타낸 다른 예 를 개시한 도면 도 47는 개시한 사이버 위협 정보를 처리하는 실시 예에 따라 학습 모델의 검증 결과 데이터를 다른 예를 개시 한 도면 도 48은 개시한 사이버 위협 정보를 처리하는 실시 예에 따라 학습 모델의 검증 결과 데이터를 통계적으로 표시 한 일 예를 나타낸 도면 도 49는 위에서 예시한 기계 학습 기반의 악성 코드 탐지 모델의 성능을 개선하는 일 실시예를 개시한 도면"}
