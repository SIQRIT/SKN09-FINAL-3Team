{"patent_id": "10-2020-0167970", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0078819", "출원번호": "10-2020-0167970", "발명의 명칭": "딥러닝 연산 수행 방법 및 장치", "출원인": "삼성전자주식회사", "발명자": "김동영"}}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "텐서 연산(tensor operation)을 수행하는 가산기 트리(adder tree) 기반의 텐서 코어(tensor core); 및상기 텐서 코어의 출력을 입력으로 사용하여 벡터 연산(vector operation)을 수행하는 MAC(multiplier andaccumulator) 기반의 벡터 코어(vector core)를 포함하는 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 텐서 연산은행렬-행렬 곱셈 연산을 포함하고,상기 벡터 연산은벡터-행렬 곱셈 연산, 벡터-벡터 곱셈 연산, 요소별 연산(element-wise operation) 중 적어도 하나를 포함하는,연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 벡터 코어는상기 벡터 연산을 수행하는 MAC 기반의 ALU(arithmetic logic unit)를 포함하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 벡터 코어는풀링(pooling) 연산 및 비선형 함수(non-linear function) 연산 중 적어도 하나를 수행하는 기능 유닛(functional unit)를 포함하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 기능 유닛은상기 풀링 연산 및 상기 비선형 함수 연산 중 적어도 하나를 수행하기 위한 룩업 테이블(look-up table)공개특허 10-2022-0078819-3-를 포함하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 벡터 코어는가중치 데이터를 저장하는 가중치 버퍼를 포함하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 벡터 코어가 상기 벡터 연산을 수행함에 있어서, 상기 텐서 코어의 출력을 재사용하기 위한 데이터를 저장하는 로컬 버퍼(local buffer)를 더 포함하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 텐서 코어는상기 벡터 코어가 제1 텐서 연산의 출력을 입력으로 사용하여 제1 벡터 연산을 수행할 때, 제2 텐서 연산을 병렬적으로 수행하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서,상기 벡터 코어는풀링 연산 및 비선형 함수 연산 중 적어도 하나를 수행하는 기능 유닛;상기 벡터 연산을 수행하는 MAC 기반의 ALU;가중치 데이터를 저장하는 가중치 버퍼;상기 텐서 코어의 출력 및 상기 ALU의 출력 중 적어도 하나를 상기 기능 유닛의 입력으로 선택하는 제1 멀티플렉서(multiplexer)를 포함하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 벡터 코어는상기 기능 유닛의 출력 및 상기 제1 멀티플렉서 중 적어도 하나를 상기 ALU의 입력으로 선택하는 제2 멀티플렉서공개특허 10-2022-0078819-4-를 포함하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제9항에 있어서,상기 벡터 코어는상기 기능 유닛의 출력 및 상기 ALU의 출력 중 적어도 하나를 상기 벡터 코어의 출력으로 선택하는 제3 멀티플렉서를 포함하는, 연산 장치"}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1항에 있어서,상기 텐서 코어는상기 벡터 연산의 수행 블록 단위로 상기 텐서 연산을 위한 순회(traversal)를 수행하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1항에 있어서,상기 텐서 코어는컨볼루션 연산을 수행하고,상기 벡터 코어는풀링 연산 및 비선형 함수 연산 중 적어도 하나를 수행하는 기능 유닛;상기 벡터 연산을 수행하는 MAC 기반의 ALU; 및가중치 데이터를 저장하는 가중치 버퍼를 포함하고.상기 기능 유닛은상기 컨볼루션 연산의 출력을 입력으로 수신하여 제1 활성화 함수(activation function) 연산을 수행하고,상기 ALU는상기 가중치 데이터 및 상기 활성화 함수 연산 결과 사이의 뎁스와이즈 컨볼루션(depthwise convolution) 연산을 수행하고,상기 기능 유닛은상기 뎁스와이즈 컨볼루션 연산 결과를 입력으로 수신하여 제2 활성화 함수 연산을 수행하는, 연산 장치."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "가산기 트리 기반의 텐서 코어를 이용하여 텐서 연산을 수행하는 단계; 및MAC 기반의 벡터 코어를 이용하여 상기 텐서 코어의 출력을 입력으로 사용하여 벡터 연산을 수행하는 단계공개특허 10-2022-0078819-5-를 포함하는 연산 방법."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서,제1항에 있어서,상기 텐서 연산은행렬-행렬 곱셈 연산을 포함하고,상기 벡터 연산은벡터-행렬 곱셈 연산, 벡터-벡터 곱셈 연산, 요소별 연산(element-wise operation) 중 적어도 하나를 포함하는,연산 방법."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제14항에 있어서,상기 텐서 연산을 수행하는 단계는컨볼루션 연산을 수행하는 단계를 포함하고,상기 벡터 연산을 수행하는 단계는상기 컨볼루션 연산의 출력을 입력으로 수신하여 제1 활성화 함수 연산을 수행하는 단계;가중치 데이터 및 상기 활성화 함수 연산 결과 사이의 뎁스와이즈 컨볼루션 연산을 수행하는 단계; 및상기 뎁스와이즈 컨볼루션 연산 결과를 입력으로 수신하여 제2 활성화 함수 연산을 수행하는 단계를 포함하는, 연산 방법."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제14항에 있어서,상기 텐서 연산을 수행하는 단계는상기 벡터 연산의 수행 블록 단위로 상기 텐서 연산을 위한 순회(traversal)를 수행하는 단계를 포함하는, 연산 방법."}
{"patent_id": "10-2020-0167970", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "하드웨어와 결합되어 제14항 내지 제17항 중 어느 하나의 항의 방법을 실행시키기 위하여 컴퓨터 판독 가능한기록매체에 저장된 컴퓨터 프로그램."}
{"patent_id": "10-2020-0167970", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "딥러닝 연산 수행 방법 및 장치가 개시된다. 일 실시예에 따른 연산 장치는 텐서 연산(tensor operation)을 수 행하는 가산기 트리(adder tree) 기반의 텐서 코어(tensor core) 및 텐서 코어의 출력을 입력으로 사용하여 벡터 연산(vector operation)을 수행하는 MAC(multiplier and accumulator) 기반의 벡터 코어(vector core)를 포함한 다."}
{"patent_id": "10-2020-0167970", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "아래 실시예들은 딥러닝 연산 수행 방법 및 장치에 관한 것으로, 구체적으로는 가산기 트리(adder tree) 기반의 인공신경망 가속기에 MAC(multiplier and accumulator) 기반의 코프로세서(co-processor)로 구성된 연산 장치에 관한 것이다."}
{"patent_id": "10-2020-0167970", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공신경망(Artificial Neural Network)은 컴퓨터 과학적 아키텍쳐(computational architecture)를 참조하여 구현된다. 최근 인공신경망 기술이 발전함에 따라, 다양한 종류의 전자 시스템에서 인공신경망을 활용하여 입 력 데이터를 분석하고 유효한 정보를 추출하는 연구가 활발히 진행되고 있다. 인공신경망을 처리하는 장치는 복잡한 입력 데이터에 대한 많은 양의 연산을 필요로 한다. 인공지능 애플리케 이션은 서버와 클라이언트 사이의 네트워크 연결에 의한 정교하지만 반응이 느린 서비스가 대부분이다. 이는 딥 러닝의 핵심 알고리즘인 인공 신경망의 컴퓨팅이 일반적인 AP(application processor)에 비해 1000배 이상의 수 준의 컴퓨팅을 요구하기 때문이다. 이러한 높은 계산적 요구를 에너지 효율적으로 구현하기 위한 아키텍처(architecture)를 개시한다."}
{"patent_id": "10-2020-0167970", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시예에 따른 연산 장치는 텐서 연산(tensor operation)을 수행하는 가산기 트리(adder tree) 기반의 텐서 코어(tensor core); 및 상기 텐서 코어의 출력을 입력으로 사용하여 벡터 연산(vector operation)을 수행하는 MAC(multiplier and accumulator) 기반의 벡터 코어(vector core)를 포함한다. 상기 텐서 연산은 행렬-행렬 곱셈 연산을 포함하고, 상기 벡터 연산은 벡터-행렬 곱셈 연산, 벡터-벡터 곱셈 연 산, 요소별 연산(element-wise operation) 중 적어도 하나를 포함할 수 있다. 상기 벡터 코어는 상기 벡터 연산을 수행하는 MAC 기반의 ALU(arithmetic logic unit)를 포함할 수 있다. 상기 벡터 코어는 풀링(pooling) 연산 및 비선형 함수(non-linear function) 연산 중 적어도 하나를 수행하는 기능 유닛(functional unit)를 포함할 수 있다. 상기 기능 유닛은 상기 풀링 연산 및 상기 비선형 함수 연산 중 적어도 하나를 수행하기 위한 룩업 테이블 (look-up table)를 포함할 수 있다. 상기 벡터 코어는 가중치 데이터를 저장하는 가중치 버퍼를 포함할 수 있다. 일 실시예에 따른 연산 장치는 상기 벡터 코어가 상기 벡터 연산을 수행함에 있어서, 상기 텐서 코어의 출력을 재사용하기 위한 데이터를 저장하는 로컬 버퍼(local buffer)를 더 포함할 수 있다. 상기 텐서 코어는 상기 벡터 코어가 제1 텐서 연산의 출력을 입력으로 사용하여 제1 벡터 연산을 수행할 때, 제 2 텐서 연산을 병렬적으로 수행할 수 있다. 상기 벡터 코어는 풀링 연산 및 비선형 함수 연산 중 적어도 하나를 수행하는 기능 유닛; 상기 벡터 연산을 수 행하는 MAC 기반의 ALU; 가중치 데이터를 저장하는 가중치 버퍼; 상기 텐서 코어의 출력 및 상기 ALU의 출력 중 적어도 하나를 상기 기능 유닛의 입력으로 선택하는 제1 멀티플렉서(multiplexer)를 포함할 수 있다. 상기 벡터 코어는 상기 기능 유닛의 출력 및 상기 제1 멀티플렉서 중 적어도 하나를 상기 ALU의 입력으로 선택 하는 제2 멀티플렉서를 포함할 수 있다. 상기 벡터 코어는 상기 기능 유닛의 출력 및 상기 ALU의 출력 중 적어도 하나를 상기 벡터 코어의 출력으로 선 택하는 제3 멀티플렉서를 포함할 수 있다. 상기 텐서 코어는 상기 벡터 연산의 수행 블록 단위로 상기 텐서 연산을 위한 순회(traversal)를 수행할 수 있 다. 상기 텐서 코어는 컨볼루션 연산을 수행하고, 상기 벡터 코어는 풀링 연산 및 비선형 함수 연산 중 적어도 하나 를 수행하는 기능 유닛; 상기 벡터 연산을 수행하는 MAC 기반의 ALU; 및 가중치 데이터를 저장하는 가중치 버퍼를 포함하고. 상기 기능 유닛은 상기 컨볼루션 연산의 출력을 입력으로 수신하여 제1 활성화 함수(activation function) 연산을 수행하고, 상기 ALU는 상기 가중치 데이터 및 상기 활성화 함수 연산 결과 사이의 뎁스와이즈 컨볼루션(depthwise convolution) 연산을 수행하고, 상기 기능 유닛은 상기 뎁스와이즈 컨볼루션 연산 결과를 입력으로 수신하여 제2 활성화 함수 연산을 수행할 수 있다. 일 실시예에 따른 연산 방법은 가산기 트리 기반의 텐서 코어를 이용하여 텐서 연산을 수행하는 단계; 및 MAC 기반의 벡터 코어를 이용하여 상기 텐서 코어의 출력을 입력으로 사용하여 벡터 연산을 수행하는 단계를 포함한 다. 상기 텐서 연산은 행렬-행렬 곱셈 연산을 포함하고, 상기 벡터 연산은 벡터-행렬 곱셈 연산, 벡터-벡터 곱셈 연 산, 요소별 연산(element-wise operation) 중 적어도 하나를 포함할 수 있다. 상기 텐서 연산을 수행하는 단계는 컨볼루션 연산을 수행하는 단계를 포함하고, 상기 벡터 연산을 수행하는 단 계는 상기 컨볼루션 연산의 출력을 입력으로 수신하여 제1 활성화 함수 연산을 수행하는 단계; 가중치 데이터 및 상기 활성화 함수 연산 결과 사이의 뎁스와이즈 컨볼루션 연산을 수행하는 단계; 및 상기 뎁스와이즈 컨볼루 션 연산 결과를 입력으로 수신하여 제2 활성화 함수 연산을 수행하는 단계를 포함할 수 있다. 상기 텐서 연산을 수행하는 단계는 상기 벡터 연산의 수행 블록 단위로 상기 텐서 연산을 위한 순회(traversa l)를 수행하는 단계를 포함할 수 있다."}
{"patent_id": "10-2020-0167970", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "실시예들에 대한 특정한 구조적 또는 기능적 설명들은 단지 예시를 위한 목적으로 개시된 것으로서, 다양한 형 태로 변경되어 구현될 수 있다. 따라서, 실제 구현되는 형태는 개시된 특정 실시예로만 한정되는 것이 아니며, 본 명세서의 범위는 실시예들로 설명한 기술적 사상에 포함되는 변경, 균등물, 또는 대체물을 포함한다. 제1 또는 제2 등의 용어를 다양한 구성요소들을 설명하는데 사용될 수 있지만, 이런 용어들은 하나의 구성요소 를 다른 구성요소로부터 구별하는 목적으로만 해석되어야 한다. 예를 들어, 제1 구성요소는 제2 구성요소로 명 명될 수 있고, 유사하게 제2 구성요소는 제1 구성요소로도 명명될 수 있다. 어떤 구성요소가 다른 구성요소에 \"연결되어\" 있다고 언급된 때에는, 그 다른 구성요소에 직접적으로 연결되어 있거나 또는 접속되어 있을 수도 있지만, 중간에 다른 구성요소가 존재할 수도 있다고 이해되어야 할 것이다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\" 또는 \"가지다\" 등의 용어는 설명된 특징, 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것이 존재함 으로 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부분품 또는 이들 을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 해당 기술 분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가진다. 일반적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의미를 갖는 것으로 해석되어야 하며, 본 명세서에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적인 의미로 해석되지 않는다. 이하, 실시예들을 첨부된 도면들을 참조하여 상세하게 설명한다. 첨부 도면을 참조하여 설명함에 있어, 도면 부호에 관계없이 동일한 구성 요소는 동일한 참조 부호를 부여하고, 이에 대한 중복되는 설명은 생략하기로 한 다. 도 1a는 인공신경망(Artificial Neural Network)를 이용한 딥러닝 연산 방법을 설명하기 위한 도면이다. 딥러닝(Deep Learning) 등을 포함하는 인공지능(AI) 알고리즘은 인공신경망(Artificial Neural Network, ANN) 에 입력 데이터를 입력시키고, 컨볼루션 등의 연산을 통해 출력 데이터를 학습하는 것을 특징으로 한다. 인공신경망은 생물학적 뇌를 모델링한 컴퓨터 과학적 아키텍쳐(Computational Architecture)를 의미할 수 있다. 인공신경망 내에서, 뇌의 뉴런들에 해당되는 노드들은 서로 연결되어 있고, 입력 데이터를 처리하기 위하여 집합적으로 동작한다. 다양한 종류의 뉴럴 네트워크들을 예로 들면, 컨볼루션 뉴럴 네트워크 (Convolutional Neural Network, CNN), 회귀 뉴럴 네트워크(Recurrent Neural Network, RNN), 딥 빌리프 네트 워크(Deep Belief Network, DBN), 제한된 볼츠만 기계(Restricted Boltzman Machine, RBM) 방식 등이 있으나, 이에 제한되지 않는다. 피드-포워드(feed-forward) 뉴럴 네트워크에서, 뉴럴 네트워크의 뉴런들은 다른 뉴런들 과의 연결들(links)을 갖는다. 이와 같은 연결들은 뉴럴 네트워크를 통해, 한 방향으로, 예를 들어 순방향 (forward direction)으로 확장될 수 있다. 도 1a를 참조하면, 인공신경망에 입력 데이터가 입력되고, 하나 이상의 레이어(layer)를 포함하는 인공 신 경망(예를 들어, 컨볼루션 뉴럴 네트워크(Convolution Neural Network, CNN))를 통해 출력 데이터가 출력되는 구조가 도시된다. 인공신경망은 2개 이상의 레이어를 보유한 딥 뉴럴 네트워크(deep neural networ k)일 수 있다. 컨볼루션 뉴럴 네트워크는 입력 데이터로부터 테두리, 선 색 등과 같은 \"특징들(features)\"을 추출하기 위해 이용될 수 있다. 컨볼루션 뉴럴 네트워크는 복수의 레이어를 포함할 수 있다. 각각의 레이어는 데이 터를 수신할 수 있고, 해당 레이어에 입력되는 데이터를 처리하여 해당 레이어에서 출력되는 데이터를 생성할 수 있다. 레이어에서 출력되는 데이터는, 컨볼루션 뉴럴 네트워크에 입력된 이미지 또는 입력된 특징맵 (feature map)을 하나 이상의 필터(filter)의 가중치(weight) 값과 컨볼루션 연산하여 생성한 특징맵일 수 있다. 컨볼루션 뉴럴 네트워크의 초기 레이어들은 입력으로부터 에지들 또는 그레디언트들과 같은 낮은 레 벨의 특징들을 추출하도록 동작될 수 있다. 컨볼루션 뉴럴 네트워크의 다음 레이어들은 이미지 내의 눈, 코 등과 같은 점진적으로 더 복잡한 특징들을 추출할 수 있다. 도 1b는 딥 러닝 연산에서 입력으로 제공되는 입력 특징맵의 데이터와 필터를 설명하기 위한 도면이다. 도 1b를 참조하면, 입력 특징맵은 인공신경망에 입력되는 이미지의 픽셀 값 또는 수치 데이터의 집합일 수 있으나, 이에 제한되지 않는다. 도 1b에서 입력 특징맵은 인공신경망을 통해 학습할 대상이 되는 이미지 의 픽셀 값으로 정의될 수 있다. 예를 들어, 입력 특징맵은 256×256의 픽셀과 K의 깊이(depth)를 가질 수 있다. 그러나, 상기 값은 예시적인 것이고, 입력 특징맵의 픽셀 크기가 상기 예시로 한정되는 것은 아 니다. 필터(110-1 내지 110-n)은 N개로 형성될 수 있다. 복수의 필터(110-1 내지 110-n) 각각은 n by n(n×n)의 가 중치(weight) 값을 포함할 수 있다. 예를 들어, 복수의 필터(110-1 내지 110-n) 각각은 3×3의 픽셀과 K의 깊 이값을 가질 수 있다. 그러나, 상기 필터의 크기는 예시적인 것이고, 복수의 필터(110-1 내지 110-n) 각각의 크기가 상기 예시로 한정되는 것은 아니다. 도 1c 가산기 트리(adder tree)를 이용한 딥러닝 연산 방법을 설명하기 위한 도면이고, 도 1d는 복수의 MAC(multiplier and accumulator)을 이용한 딥 러닝 연산 방법을 설명하기 위한 도면이다. 도 1c를 참조하면, 가산기 트리 기반의 연산 장치는 두 데이터의 곱을 계산하는 복수의 곱셈기, 인접한 두 곱셈 기의 출력의 합 또는 인접한 두 가산기의 합을 계산하는 가산기 및 최종 출력 데이터를 누적 합산하는 하나의 누산기(accumulator)를 포함할 수 있다. 가산기 트리 기반의 연산 장치는 적은 수의 누산기(예를 들어, 하나의 누산기)만을 사용하기 때문에, 저전력으로 컨볼루션 연산을 수행할 수 있다. 도 1d를 참조하면, MAC 기반의 연산 장치는 복수의 프로세싱 엘리먼트(PE; Processing Element)들로 이루어져 있으며, 각 프로세싱 엘리먼트에 입력 데이터를 입력함으로써 동시에 많은 연산을 할 수 있다. MAC 기반의 연 산 장치의 각 프로세싱 엘리먼트는 ACC = ACC + (A x B) 연산을 수행하는 MAC으로 구성될 수 있다. 딥러닝 연산은 전체 수행 시간 중에 계산(computation) 시간의 비중이 높은 계산 바운드(computation-bound) 연 산과 전체 수행 시간 중에 메모리 액세스(memory access) 시간의 비중이 높은 메모리 바운드(memory-bound) 연 산 등 서로 다른 특징을 가진 연산이 혼재 되어있다. 예를 들어, 행렬-행렬 곱셈 연산과 같은 텐서 연산 (tensor operation)은 전체 수행 시간 중에 계산 시간의 비중이 높은 계산 바운드 특성을 지니고, 벡터-행렬 곱 셈 연산, 벡터-벡터 곱셈 연산, 요소별 연산(element-wise operation)과 같은 벡터 연산(vector operation)은 전체 수행 시간 중에 메모리 액세스 시간의 비중이 높은 메모리 바운드 특성을 지닐 수 있다. 높은 정확도 및 더 복잡하고 다양한 어플리케이션 지원을 위해 인공신경망에서 보간(interpolation) 연산, 다양 한 종류의 비선형 함수 추정(non-linear function estimation) 연산, 뎁스와이즈 컨볼루션 연산 등의 벡터 연산 에 대한 요구가 증가하고 있다. 그러나, 종래의 가산기 트리 구조의 연산 장치는 메모리 바운드 연산 수행 시 이용 효율(utilization)이 낮아 비효율적이다. 예를 들어, 뎁스와이즈 컨볼루션(depth-wise convolution) 연산은 각 입력 채널의 입력 특징맵 (input feature map) 별로 컨볼루션 연산을 수행하는데, 가산기 트리 구조 기반의 연산 장치를 이용하여 뎁스와 이즈 컨볼루션 연산을 수행하는 경우 사용되지 않는 곱셈기들이 존재하게 되어 자원 이용 효율(resource utilization)이 낮아질 수 있다. 또한, 로직(logic) 공정 미세화 속도에 비해 메모리 공정 미세화 속도가 더 느려 상대적으로 로직의 집적도가 향상되고 있다. 따라서 종래의 가산기 트리 기반의 연산 장치에서 메모리 대 역폭(memory bandwidth) 부족 문제는 향후 심화될 전망이다. 반면에, MAC 기반의 연산 장치는 MAC 유닛마다 누산기가 있기 때문에, 벡터 연산 수행에 적합할 수 있다. 예를 들어, MAC 기반의 연산 장치는 각 채널 별로 컨볼루션 연산을 수행하는 뎁스와이즈 컨볼루션 연산 수행에 적합 할 수 있다. 그러나, MAC 기반의 연산 장치는 모든 MAC 유닛에서 누산기를 필요로 하기 때문에 전력 소모가 많 을 수 있다. 예를 들어, 가산기 트리 기반의 연산 장치를 이용하여 일반적인 컨볼루션 연산을 수행하는 경우에 는 하나의 누산기만 있으면 충분하지만, MAC 기반의 연산 장치를 이용하여 일반적인 컨볼루션 연산을 수행하는 경우에는 모든 누산기가 동작하게 되어 전력 효율이 떨어질 수 있다. 따라서, MAC 기반의 연산 장치는 벡터 연 산(예를 들어, 뎁스와이즈 컨볼루션 연산과 같은 데이터의 병렬 처리 연산)에는 적합하나 텐서 연산(예를 들어, 일반적인 컨볼루션 연산) 수행에는 적합하지 않을 수 있다. 일 실시예에 따른 연산 장치는 가산기 트리 기반의 인공신경망 가속기에 MAC 기반의 코프로세서(co- processor)로 구성되어, 가산기 트리 기반의 인공신경망 가속기에서 텐서 연산을 수행하고 MAC 기반의 코프로세 서에서 벡터 연산을 효율적으로 수행할 수 있다. 일 실시예에 따른 연산 장치의 동작 방법은 아래에서, 도 2 내지 도 8을 참조하여 상세히 설명된다. 도 2는 일 실시예에 따른 연산 장치의 하드웨어 구현의 예를 도시한 도면이다. 도 2를 참조하면, 일 실시예에 따른 연산 장치는 텐서 코어 및 벡터 코어를 포함한다. 나아가, 연산 장치는 로컬 버퍼 및 온칩 메모리 및 인스트럭션 펫칭 및 컨트롤 유닛(instruction fetching and control unit.)(이하, 컨트롤 유닛으로 지칭한다)을 더 포함할 수 있다. 도 2의 실시예에서 연산 장치의 각각의 구성요소들은 기능 및 논리적으로 분리될 수 있음을 나타나기 위해 별도로 도면에 표시한 것이며, 물리 적으로 반드시 별도의 구성요소이거나 별도의 코드로 구현되는 것을 의미하는 것은 아니다. 일 실시예에 따른 텐서 코어는 도 1a 내지 도 1d를 참조하여 설명한 텐서 연산을 수행하는 가산기 트리 기 반의 인공신경망 가속기일 수 있고, 벡터 코어는 벡터 연산을 수행하는 MAC 기반의 코프로세서일 수 있다. 일 실시예에 따른 연산 장치는 텐서 연산의 출력을 입력으로 사용하는 벡터 연산이 있을 때, 텐서 연산의 출력 을 온칩 메모리에 라이트-백(write-back) 한 뒤 벡터 연산을 수행하는 것이 아니라, 텐서 연산의 출력을 벡터 연산의 입력으로 사용하여 온칩 메모리에 라이트-백 하지 않고 벡터 연산을 수행할 수 있다. 이를 통해, 연산 장치는 벡터 연산의 메모리 대역폭 요구 사항(memory bandwidth requirement)를 줄이고 계산 자원 이용 효율(computation resource utilization)을 향상시킬 수 있다. 일 실시예에 따른 연산 장치는 데이터 재사용을 위해 로컬 버퍼를 포함할 수 있다. 데이터 재사용의 의미 는 기 로딩된 데이터(예를 들어, 가중치 또는 입력 특징맵)을 반복적으로 사용하여 연산을 수행하는 것을 의미 하고, 데이터 재사용을 통해 데이터 로드 횟수와 연산 횟수를 줄일 수 있다.도 3은 일 실시예에 따른 벡터 코어의 하드웨어 구현의 예를 도시한 도면이다. 도 3을 참조하면, 일 실시예에 따른 벡터 코어는 기능 유닛, 가중치 버퍼 및 ALU(arithmetic logic unit)를 포함할 수 있다. 도 3의 실시예에서 연산 장치의 각각의 구성요소들은 기능 및 논리적으로 분리될 수 있음을 나타나기 위해 별도로 도면에 표시한 것이며, 물리적으로 반드시 별도의 구성요소이거나 별도 의 코드로 구현되는 것을 의미하는 것은 아니다. 일 실시예에 따른 기능 유닛은 풀링(pooling) 연산 및 비선형 함수(non-linear function) 연산 중 적어도 하나를 수행할 수 있다. 기능 유닛은 풀링 연산 및 비선형 함수 연산 중 적어도 하나를 수행하기 위한 룩 업 테이블(look-up table)을 포함할 수 있다. 일 실시예에 따른 가중치 버퍼는 가중치 데이터를 저장할 수 있다. 일 실시예에 따른 ALU는 벡터 연산을 수행하는 MAC 기반의 산술 논리 장치일 수 있다. 나아가, 벡터 코어는 텐서 코어의 출력 및 ALU의 출력 중 적어도 하나를 기능 유닛의 입력 으로 선택하는 제1 멀티플렉서(multiplexer), 기능 유닛의 출력 및 제1 멀티플렉서 중 적어도 하나를 ALU의 입력으로 선택하는 제2 멀티플렉서 및 기능 유닛의 출력 및 ALU의 출력 중 적어도 하나를 벡터 코어의 출력으로 선택하는 제3 멀티플렉서를 포함할 수 있다. 아래에서, 도 4 내지 도 7b를 참조하여 텐서 코어 및 벡터 코어를 포함한 연산 장치의 구체적인 동작 방법을 설명한 다. 도 4는 일 실시예에 따른 연산 장치의 동작 방법을 설명하기 위한 도면이다. 도 4를 참조하면, 도면은 텐서 코어만 사용하여 텐서 연산 및 벡터 연산이 혼합된 연산을 수행할 때 소요 되는 계산 시간(computation time) 및 메모리 액세스 시간(memory access time)을 도시한 도면이고, 도면(42 0)은 텐서 코어 및 벡터 코어를 포함하는 일 실시예에 따른 연산 장치를 사용하여 텐서 연산 및 벡터 연산이 혼 합된 연산을 수행할 때 소요되는 계산 시간 및 메모리 액세스 시간(을 도시한 도면이다. 도 4에서, 연산은 제1 연산, 제2 텐서 연산, 제3 텐서 연산, 제1 벡터 연산 및 제2 벡터 연산을 포함하며, 제1 텐서 연산의 출력이 제1 벡터 연산의 입력이고, 제2 텐서 연산의 출력이 제2 벡터 연산의 입력이라 가정한다. 일 실시예에 따른 연산 장치는 벡터 코어가 텐서 코어와 함께 병렬적으로 연산을 수행함으로써 벡터 연산의 계산 시간을 하이딩(hiding)하여 전체 계산 시간을 단축할 수 있다. 보다 구체적으로, 도면을 참조하면, 텐서 코어만 사용하는 연산 장치는 텐서 연산이 끝나야 벡터 연산을 수행할 수 밖에 없고, 벡터 연산이 끝나야 다음 텐서 연산을 수행할 수 밖에 없다. 예를 들어, 텐서 코어만 사 용하는 연산 장치는 제1 벡터 연산이 끝나야 제2 텐서 연산을 수행할 수 밖에 없다. 반면에, 도면을 참조하면, 일 실시예에 따른 연산 장치는 텐서 연산을 수행하는 텐서 코어와 벡터 연 산을 수행하는 벡터 코어를 독립적으로 구비하고 있기 때문에, 벡터 코어가 텐서 코어와 함께 병렬적으로 연산을 수행할 수 있다. 예를 들어, 일 실시예에 따른 연산 장치의 텐서 코어는 벡터 코어 가 제1 벡터 연산을 수행하는 중에 제2 텐서 연산을 수행할 수 있다. 또한, 일 실시예에 따른 연산 장치 의 텐서 코어는 벡터 코어가 제2 벡터 연산을 수행하는 중에 제3 텐서 연산을 수행할 수 있다. 일 실시예에 따른 연산 장치는 벡터 연산을 수행하는데 최적화된 벡터 코어로 벡터 연산을 수행함으로써 텐서 코어로만 연산을 수행할 때 대비 하드웨어 이용 효율(hardware utilization)을 향상시킬 수 있다. 또한, 일 실시예에 따른 연산 장치는 텐서 연산의 출력을 온칩 메모리에 라이트-백(write-back) 한 뒤 벡 터 연산을 수행하지 않고, 텐서 연산의 출력을 벡터 연산의 입력으로 사용하여 벡터 연산을 수행할 수 있다. 그 결과, 연산 장치는 온칩 메모리 엑세스 에너지를 감축할 수 있다. 또한, 연산 장치는 텐서 연산의 메모리 엑세스 유휴 시간(memory access idle time)을 줄일 수 있고, 그 결과 전체 연산 수행 시간을 단축할 수 있다. 보다 구체적으로, 도면을 참조하면, 텐서 코어만 사용하는 연산 장치는 텐서 연산의 출력을 온칩 메모리 에 라이트-백 한 뒤 벡터 연산을 수행할 수 밖에 없다. 예를 들어, 텐서 코어만 사용하는 연산 장치는 제 1 텐서 연산의 출력을 온칩 메모리에 라이트-백 한 뒤 제1 벡터 연산을 수행할 수 있다. 반면에, 도면을 참조하면, 일 실시예에 따른 연산 장치는 텐서 연산의 출력을 벡터 연산의 입력으로 사용 하여 온칩 메모리에 라이트-백 하지 않고 벡터 연산을 수행할 수 있다. 예를 들어, 일 실시예에 따른 연산 장치는 제1 텐서 연산의 출력을 제1 벡터 연산으로 입력으로 사용하고, 제2 텐서 연산의 출력을 제2 벡터 연 산의 입력으로 사용할 수 있다. 도 5a 내지 도 5b는 일 실시예에 따른 연산 장치를 이용하여 뎁스와이즈 컨볼루션 블록을 처리하는 예시를 설명 하기 위한 도면이다. 도 5a를 참조하면, 일 실시예에 따른 뎁스와이즈 컨볼루션 블록은 컨볼루션 연산(예를 들어, 1x1 컨볼루션 연산), 뎁스와이즈 컨볼루션 연산(예를 들어, 3x3 뎁스와이즈 컨볼루션 연산) 및 컨볼루션 연산(예를 들어, 1x1 컨볼루션 연산)을 포함할 수 있다. 전술한 바와 같이, 컨볼루션 연산(510, 530)은 계산 바운드 의 텐서 연산일 수 있고, 뎁스와이즈 컨볼루션 연산은 메모리 바운드의 벡터 연산일 수 있다. 보다 구체적으로, 컨볼루션 연산 결과에 활성화 함수 연산(예를 들어, ReLu 함수 연산)을 수행한 출력은 뎁스와이즈 컨볼루션 연산의 입력일 수 있다. 출력은 뎁스와이즈 컨볼루션 연산 결과에 활성화 함수 (activation function) 연산(예를 들어, ReLu 함수 연산)을 수행한 출력은 뎁스와이즈 컨볼루션 연산의 입 력일 수 있다. 일 실시예에 따른 연산 장치의 텐서 코어는 컨볼루션 연산을 수행하고, 벡터 코어는 컨볼루션 연산의 출력을 입력으로 수신할 수 있다. 컨볼루션 연산의 출력을 입력으로 수신한 벡터 코어 의 기능 유닛은 컨볼루션 연산의 출력에 제1 활성화 함수 연산을 수행할 수 있다. 벡터 코어의 ALU는 가중치 버퍼로부터 가중치 데이터를 수신하고, 기능 유닛으로부터 활성 화 함수 연산 결과를 수신하여, 가중치 데이터 및 활성화 함수 연산 결과 사이의 뎁스와이즈 컨볼루션 연산 을 수행할 수 있다. 기능 유닛은 뎁스와이즈 컨볼루션 연산 결과를 입력으로 수신하여 제2 활성화 함수 연산을 수행할 수 있고, 벡터 코어는 제2 활성화 함수 연산 수행 결과를 온칩 메모리에 라이트-백할 수 있다. 텐서 코어는 제2 활성화 함수 연산 수행 결과를 리드(read)하여 컨볼루션 연산을 수행할 수 있다. 도 5b를 참조하면, 도면은 텐서 코어만 사용하여 뎁스와이즈 컨볼루션 블록을 처리할 때 소요되는 계산 시 간 및 메모리 액세스 시간을 도시한 도면이고, 도면은 텐서 코어 및 벡터 코어를 포함하는 일 실시예에 따 른 연산 장치를 사용하여 뎁스와이즈 컨볼루션 블록을 처리할 때 소요되는 계산 시간 및 메모리 액세스 시간을 도시한 도면이다. 일 실시예에 따른 연산 장치는 벡터 연산을 수행하는데 최적화된 벡터 코어로 벡터 연산을 수행함으로써 텐서 코어로만 연산을 수행할 때 대비 하드웨어 이용 효율(hardware utilization)을 향상시킬 수 있다. 예를 들어, 연산 장치는 텐서 코어의 기능 유닛을 통해 풀링 연산 및 비선형 함수 연산을 수행할 수 있고, 텐서 코어의 ALU를 통해 뎁스와이즈 컨볼루션 연산을 수행할 수 있다. 또한, 일 실시예에 따른 연산 장치는 텐서 연산의 출력을 온칩 메모리에 라이트-백(write-back) 한 뒤 벡 터 연산을 수행하지 않고, 텐서 연산의 출력을 벡터 연산의 입력으로 사용하여 벡터 연산을 수행할 수 있다. 그 결과, 연산 장치는 온칩 메모리 엑세스 에너지를 감축할 수 있다. 또한, 연산 장치는 텐서 연산의 메모리 엑세스 유휴 시간(memory access idle time)을 줄일 수 있고, 그 결과 전체 연산 수행 시간을 단축할 수 있다. 보다 구체적으로, 도면을 참조하면, 텐서 코어만 사용하는 연산 장치는 텐서 연산의 출력을 온칩 메모리 에 라이트-백 한 뒤 벡터 연산을 수행할 수 밖에 없다. 예를 들어, 텐서 코어만 사용하는 연산 장치는 컨 볼루션 연산의 출력을 온칩 메모리에 라이트-백 한 뒤 뎁스와이즈 컨볼루션 연산을 수행할 수 있다. 반면에, 도면을 참조하면, 일 실시예에 따른 연산 장치는 텐서 연산의 출력을 벡터 연산의 입력으로 사용 하여 온칩 메모리에 라이트-백 하지 않고 벡터 연산을 수행할 수 있다. 예를 들어, 일 실시예에 따른 연 산 장치는 컨볼루션 연산의 출력을 뎁스와이즈 컨볼루션 연산의 입력으로 사용할 수 있다. 도 6a 내지 도 6b는 일 실시예에 따른 벡터 연산의 유휴 시간을 줄이기 위한 방법을 설명하기 위한 도면이다. 도 6a를 참조하면, 벡터 코어에서 뎁스와이즈 컨볼루션 블록을 가속하기 위해 1x1 컨볼루션 연산과 3x3 뎁스와 이즈 컨볼루션 연산을 연속적으로 수행하는데 있어, 행(row) 혹은 열(column)방향으로 1x1 컨볼루션 연산을 수 행할 경우 3x3 뎁스와이즈 컨볼루션 연산을 수행하기 위해 3x3 입력 특징맵이 준비될 때 까지 유휴 시간이 발생 할 수 있다. 나아가, 이 경우 로컬 버퍼의 데이터 재사용율이 떨어져 3x3 뎁스와이즈 컨볼루션 연산을 위해 로컬 버퍼 및/또는 온칩 메모리의 엑세스 시간이 증가할 수 있다. 이하, 설명의 편의를 위하여 1x1 컨볼루션 연 산 및 3x3 뎁스와이즈 컨볼루션 연산을 기준으로 설명하지만, 실시예들은 다른 사이즈의 블록에 대해서도 적용 될 수 있다. 도 6b를 참조하면, 일 실시예에 따른 텐서 코어는 벡터 연산의 수행 블록 단위로 텐서 연산을 위한 순회 (traversal)를 수행할 수 있다. 보다 구체적으로, 뎁스와이즈 컨볼루션 연산이 3x3 블록 단위로 수행되는 경우, 텐서 코어는 1x1 컨볼루션 연산을 수행할 때 3x3 block 단위로 순회함으로써, 3x3 뎁스와이즈 컨볼 루션 연산의 입력이 준비되기 까지 기다리는 유휴 시간을 최소화하고, 3x3 뎁스와이즈 컨볼루션의 입력 특징맵 의 로컬 버퍼에서의 재사용율을 최대화하여 온칩 메모리와 로컬 버퍼의 엑세스 시간을 최소화하 여 전체 연산 수행 시간 및 소모 전력을 개선할 수 있다. 도 7a 내지 도 7b은 일 실시예에 따른 벡터 연산을 수행하는 방법을 설명하기 위한 도면이다. 도 7a를 참조하면, 일 실시예에 따른 벡터 코어는 최대/ 최소 풀링 연산 및/또는 비선형 함수 연산 등의 벡터 연산을 수행할 수 있다. 벡터 코어는 기능 유닛을 통해 최대/최소(min/max) 풀링 연산을 위한 최대/최소 비교 연산을 수행할 수 있다. 보다 구체적으로, 벡터 코어는 외부로부터 입력 데이터를 수신하여 기능 유닛에서 이전 싸 이클(cycle)에 검출한 최대/최소값 및 현재 입력에 기초하여 최대/최소 연산을 수행한 후, 제2 멀티플렉서(35 0)에 새로운 최대/최소값을 저장할 수 있다. 벡터 코어는 풀링 윈도우(pooling window)의 모든 요소 (element)에 대해 최대/최소 연산을 수행하면 최종 최대/최소 풀링 결과를 출력할 수 있다. 또한, 기능 유닛은 효율적으로 기본적인 비선형 함수(예를 들어, ReLU, ReLU6, PReLU 등) 연산을 제공하기 위한 룩업 테이블을 포함할 수 있다. 보다 구체적으로, 벡터 코어는 외부로부터 입력 데이터를 수신하여 기능 유닛에서 미리 저장된 룩업 테이블을 탐색하여 비선형 함수 연산을 수행할 수 있다. 도 7b를 참조하면, 일 실시예에 따른 벡터 코어는 평균 풀링(average pooling) 연산 및 보간 연산 및/또는 선형 근사(linear approximation) 연산을 활용한 비선형 함수 연산을 수행할 수 있다. 벡터 코어는 ALU를 통해 평균 풀링 연산을 수행할 수 있다. 보다 구체적으로, 벡터 코어는 외 부로부터 입력 데이터를 수신하여 기능 유닛을 바이패스(bypass)한 뒤, ALU에서 누산 연산을 수행할 수 있다. 풀링 윈도우의 모든 요소에 대해 누산 연산을 수행한 벡터 코어는 누산 결과를 풀링 윈도우 크 기로 나눈 최종 평균 풀링 결과를 출력할 수 있다. 또한, 벡터 코어는 ALU를 통해 보간 연산 및/또는 선형 근사 연산을 활용한 비선형 함수 연산을 수행 할 수 있다. 보다 구체적으로, 벡터 코어는 외부로부터 입력 데이터를 수신하여 기능 유닛을 바이패 스(bypass)한 뒤, ALU에서 ACC = ACC + (A x B) 연산을 수행할 수 있다. 모든 청크(chunk)에 대해 ACC = ACC + (A x B) 연산을 수행한 벡터 코어는 최종 결과를 출력할 수 있다. 이상에서 설명된 실시예들은 하드웨어 구성요소, 소프트웨어 구성요소, 및/또는 하드웨어 구성요소 및 소프트웨 어 구성요소의 조합으로 구현될 수 있다. 예를 들어, 실시예들에서 설명된 장치, 방법 및 구성요소는, 예를 들 어, 프로세서, 콘트롤러, ALU(arithmetic logic unit), 디지털 신호 프로세서(digital signal processor), 마 이크로컴퓨터, FPGA(field programmable gate array), PLU(programmable logic unit), 마이크로프로세서, 또는 명령(instruction)을 실행하고 응답할 수 있는 다른 어떠한 장치와 같이, 범용 컴퓨터 또는 특수 목적 컴퓨터를 이용하여 구현될 수 있다. 처리 장치는 운영 체제(OS) 및 상기 운영 체제 상에서 수행되는 소프트웨어 애플리 케이션을 수행할 수 있다. 또한, 처리 장치는 소프트웨어의 실행에 응답하여, 데이터를 접근, 저장, 조작, 처 리 및 생성할 수도 있다. 이해의 편의를 위하여, 처리 장치는 하나가 사용되는 것으로 설명된 경우도 있지만,"}
{"patent_id": "10-2020-0167970", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "해당 기술분야에서 통상의 지식을 가진 자는, 처리 장치가 복수 개의 처리 요소(processing element) 및/또는 복수 유형의 처리 요소를 포함할 수 있음을 알 수 있다. 예를 들어, 처리 장치는 복수 개의 프로세서 또는 하 나의 프로세서 및 하나의 컨트롤러를 포함할 수 있다. 또한, 병렬 프로세서(parallel processor)와 같은, 다른 처리 구성(processing configuration)도 가능하다. 소프트웨어는 컴퓨터 프로그램(computer program), 코드(code), 명령(instruction), 또는 이들 중 하나 이상의 조합을 포함할 수 있으며, 원하는 대로 동작하도록 처리 장치를 구성하거나 독립적으로 또는 결합적으로 (collectively) 처리 장치를 명령할 수 있다. 소프트웨어 및/또는 데이터는, 처리 장치에 의하여 해석되거나 처리 장치에 명령 또는 데이터를 제공하기 위하여, 어떤 유형의 기계, 구성요소(component), 물리적 장치, 가상 장치(virtual equipment), 컴퓨터 저장 매체 또는 장치, 또는 전송되는 신호 파(signal wave)에 영구적으로,또는 일시적으로 구체화(embody)될 수 있다. 소프트웨어는 네트워크로 연결된 컴퓨터 시스템 상에 분산되어서, 분산된 방법으로 저장되거나 실행될 수도 있다. 소프트웨어 및 데이터는 컴퓨터 판독 가능 기록 매체에 저장될 수 있다. 실시예에 따른 방법은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등을 단 독으로 또는 조합하여 포함할 수 있으며 매체에 기록되는 프로그램 명령은 실시예를 위하여 특별히 설계되고 구 성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판독 가능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD-ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체(magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다. 위에서 설명한 하드웨어 장치는 실시예의 동작을 수행하기 위해 하나 또는 복수의 소프트웨어 모듈로서 작동하 도록 구성될 수 있으며, 그 역도 마찬가지이다."}
{"patent_id": "10-2020-0167970", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "이상과 같이 실시예들이 비록 한정된 도면에 의해 설명되었으나, 해당 기술분야에서 통상의 지식을 가진 자라면 이를 기초로 다양한 기술적 수정 및 변형을 적용할 수 있다. 예를 들어, 설명된 기술들이 설명된 방법과 다른 순서로 수행되거나, 및/또는 설명된 시스템, 구조, 장치, 회로 등의 구성요소들이 설명된 방법과 다른 형태로 결합 또는 조합되거나, 다른 구성요소 또는 균등물에 의하여 대치되거나 치환되더라도 적절한 결과가 달성될 수 있다. 그러므로, 다른 구현들, 다른 실시예들 및 특허청구범위와 균등한 것들도 후술하는 특허청구범위의 범위에 속한 다."}
{"patent_id": "10-2020-0167970", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1a는 인공신경망(Artificial Neural Network)를 이용한 딥러닝 연산 방법을 설명하기 위한 도면이다. 도 1b는 딥 러닝 연산에서 입력으로 제공되는 입력 특징맵의 데이터와 필터를 설명하기 위한 도면이다. 도 1c 가산기 트리(adder tree)를 이용한 딥러닝 연산 방법을 설명하기 위한 도면이고, 도 1d는 복수의 MAC(multiplier and accumulator)을 이용한 딥 러닝 연산 방법을 설명하기 위한 도면이다. 도 2는 일 실시예에 따른 연산 장치의 하드웨어 구현의 예를 도시한 도면이다. 도 3은 일 실시예에 따른 벡터 코어의 하드웨어 구현의 예를 도시한 도면이다. 도 4는 일 실시예에 따른 연산 장치의 동작 방법을 설명하기 위한 도면이다. 도 5a 내지 도 5b는 일 실시예에 따른 연산 장치를 이용하여 뎁스와이즈 컨볼루션 블록을 처리하는 예시를 설명 하기 위한 도면이다. 도 6a 내지 도 6b는 일 실시예에 따른 벡터 연산의 유휴 시간을 줄이기 위한 방법을 설명하기 위한 도면이다. 도 7a 내지 도 7b은 일 실시예에 따른 벡터 연산을 수행하는 방법을 설명하기 위한 도면이다."}
