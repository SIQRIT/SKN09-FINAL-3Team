{"patent_id": "10-2022-0185331", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0103297", "출원번호": "10-2022-0185331", "발명의 명칭": "제로 스키핑 기능이 있는 비동기식 인메모리 컴퓨팅 장치 및 제로 스키핑 방법", "출원인": "삼성전자주식회사", "발명자": "김재록"}}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨팅 장치에 있어서,가중치들을 저장하는 메모리;클럭과 비동기로 동작하고, 상기 메모리의 복수의 행(row)들과 대응되는 서브 회로들을 포함하는 셀프 타임(self-timed) 회로; 및상기 셀프 타임 회로를 제어하는 제어 회로를 포함하고,상기 서브 회로들 중 제1 서브 회로가 제1 값을 입력받고 상기 제1 서브 회로의 제1 이웃 서브 회로로부터 출력신호를 수신한 경우, 상기 제1 서브 회로의 대응 행의 액세스를 스킵하고, 상기 제1 서브 회로의 제2 이웃 서브회로에 상기 수신된 출력 신호를 전달하며, 상기 제1 서브 회로가 제2 값을 입력받고 상기 제1 이웃 서브 회로로부터 상기 출력 신호를 수신한 경우, 상기 제1 서브 회로의 대응 행의 가중치들 및 상기 제2 값에 대한 연산을 수행하도록 하고, 상기 제1 서브 회로의 대응 행을 액세스 한 후 상기 제2 이웃 서브 회로로 전달할 다른 출력 신호를 생성하고, 상기 생성된 다른 출력 신호를 상기 제2 이웃 서브 회로에 전달하는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 제1 서브 회로는,상기 제2 값을 입력받고 상기 출력 신호를 수신한 경우 워드라인(Word line) 구동 신호 및 프리차지(pre-charge) 신호를 생성하는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 워드라인 구동 신호에 의해 상기 제1 서브 회로의 상기 대응 행의 상기 가중치들 및 상기 제2 값에 대한상기 연산이 수행되는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서,상기 프리차지 신호는,상기 연산이 끝난 경우 생성되는,컴퓨팅 장치.공개특허 10-2024-0103297-3-청구항 5 제2항에 있어서,상기 프리차지 신호에 의해 상기 제2 이웃 서브 회로의 대응 행을 액세스하기 위해 비트라인(bit line)들 및 비트라인 바(bit line bar)들이 프리차지되는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,상기 제1 이웃 서브 회로로 전달할 상기 다른 출력 신호는,상기 제2 이웃 서브 회로의 상기 대응 행의 상기 비트라인들이 프리차지된 경우 생성되는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 제1 서브 회로의 대응 행의 가중치들 및 상기 제2 값에 대한 연산의 결과에서 정해진 개수의 비트들을 입력받고 상기 입력된 비트들과 이전 비트들을 누산하는 누산기를 더 포함하는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 누산기는,상기 입력된 비트들의 최상위 비트 및 상기 입력된 비트들과 상기 이전 비트들을 누산한 결과에 의해 결정된 캐리 비트를 기초로 업다운 카운터의 카운팅 방향을 결정하는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 누산기는,상기 입력된 비트들과 상기 이전 비트들을 누산한 상기 결과 및 상기 업다운 카운터의 카운팅 방향에 기초하여출력 비트들을 생성하는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제7항에 있어서,상기 제어 회로는,공개특허 10-2024-0103297-4-상기 누산기가 상기 입력된 비트들과 상기 이전 비트들을 누산한 것을 검출함으로써 제2 값을 입력받은 상기 제2 이웃 서브 회로의 대응 행을 액세스 하도록 상기 셀프 타임 회로를 제어하는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "컴퓨팅 장치에 있어서,가중치들을 저장하는 메모리;상기 메모리의 복수의 행(row)들과 대응되는 서브 회로들을 포함하는 셀프 타임(self-timed) 회로 - 상기 서브회로들 중 제1 서브 회로가 제1 값을 입력받고 상기 제1 서브 회로의 제1 이웃 서브 회로로부터 출력 신호를 수신한 경우, 상기 제1 서브 회로의 대응 행의 액세스를 스킵하고, 상기 제1 서브 회로의 제2 이웃 서브 회로에상기 수신된 출력 신호를 전달하며, 상기 제1 서브 회로가 제2 값을 입력받고 상기 제1 이웃 서브 회로로부터상기 출력 신호를 수신한 경우, 상기 제1 서브 회로의 대응 행의 가중치들 및 상기 제2 값에 대한 연산을 수행하도록 하고, 상기 제1 서브 회로의 대응 행을 액세스 한 후 상기 제2 이웃 서브 회로로 전달할 다른 출력 신호를 생성하고, 상기 생성된 다른 출력 신호를 상기 제2 이웃 서브 회로에 전달함-;상기 셀프 타임 회로를 제어하는 제어 회로; 및상기 제1 서브 회로의 대응 행의 가중치들 및 상기 제2 값에 대한 연산의 결과에서 정해진 개수의 비트들을 입력받고 상기 입력된 비트들과 이전 비트들을 누산하는 누산기를 포함하는,컴퓨팅 장치."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "컴퓨팅 장치에 의해 수행되는, 제로 스키핑 방법에 있어서,상기 컴퓨팅 장치는, 가중치들을 저장하는 메모리; 클럭과 비동기로 동작하고, 상기 메모리의 복수의 행(row)들과 대응되는 서브 회로들을 포함하는 셀프 타임(self-timed) 회로; 및 상기 셀프 타임 회로를 제어하는 제어 회로를 포함하고,상기 서브 회로들 중 제1 서브 회로가 제1 값을 입력받고 상기 제1 서브 회로의 제1 이웃 서브 회로로부터 출력신호를 수신한 경우,상기 제1 서브 회로의 대응 행의 액세스를 스킵하는 동작; 및상기 제1 서브 회로의 제2 이웃 서브 회로에 상기 수신된 출력 신호를 전달하는 동작을 포함하고,상기 제1 서브 회로가 제2 값을 입력받고 상기 제1 이웃 서브 회로로부터 상기 출력 신호를 수신한 경우,상기 제1 서브 회로의 대응 행의 가중치들 및 상기 제2 값에 대한 연산을 수행하도록 하는 동작; 상기 제1 서브 회로의 대응 행을 액세스 한 후 상기 제2 이웃 서브 회로로 전달할 다른 출력 신호를 생성하는동작; 및상기 생성된 다른 출력 신호를 상기 제2 이웃 서브 회로에 전달하는 동작을 포함하는,제로 스키핑 방법."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "공개특허 10-2024-0103297-5-제12항에 있어서,상기 제1 서브 회로는,상기 제2 값을 입력받고 상기 출력 신호를 수신한 경우 워드라인(Word line) 구동 신호 및 프리차지(pre-charge) 신호를 생성하는,제로 스키핑 방법."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서,상기 워드라인 구동 신호에 의해 상기 제1 서브 회로의 상기 대응 행의 상기 가중치들 및 상기 제2 값에 대한상기 연산이 수행되는,제로 스키핑 방법."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제13항에 있어서,상기 프리차지 신호는,상기 연산이 끝난 경우 생성되는,제로 스키핑 방법."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제13항에 있어서,상기 프리차지 신호에 의해 상기 제2 이웃 서브 회로의 대응 행을 액세스하기 위해 비트라인(bit line)들 및 비트라인 바(bit line bar)들이 프리차지되는,제로 스키핑 방법."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서,상기 제1 서브 회로의 상기 대응 행을 액세스 한 후 상기 제2 이웃 서브 회로로 전달할 상기 다른 출력 신호를생성하는 동작은,상기 제1 서브 회로의 상기 대응 행을 액세스 한 후 상기 제2 이웃 서브 회로의 상기 대응 행의 상기 비트라인들이 프리차지된 경우 상기 제2 이웃 서브 회로로 전달할 상기 다른 출력 신호를 생성하는 동작을 포함하는,제로 스키핑 방법."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제12항에 있어서,상기 컴퓨팅 장치는,공개특허 10-2024-0103297-6-상기 제1 서브 회로의 대응 행의 가중치들 및 상기 제2 값에 대한 연산의 결과에서 정해진 개수의 비트들을 입력받고 상기 입력된 비트들과 이전 비트들을 누산하는 누산기를 더 포함하는,제로 스키핑 방법."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서,상기 누산기는,상기 입력된 비트들의 최상위 비트 및 상기 입력된 비트들과 상기 이전 비트들을 누산한 결과에 의해 결정된 캐리 비트를 기초로 업다운 카운터의 카운팅 방향을 결정하는,제로 스키핑 방법."}
{"patent_id": "10-2022-0185331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제19항에 있어서,상기 누산기는,상기 입력된 비트들과 상기 이전 비트들을 누산한 상기 결과 및 상기 업다운 카운터의 카운팅 방향에 기초하여출력 비트들을 생성하는,제로 스키핑 방법."}
{"patent_id": "10-2022-0185331", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "컴퓨팅 장치가 개시된다. 일 실시 예는 가중치들을 저장하는 메모리, 클럭과 비동기로 동작하고, 메모리의 복수 의 행(row)들과 대응되는 서브 회로들을 포함하는 셀프 타임(self-timed) 회로, 및 셀프 타임 회로를 제어하는 제어 회로를 포함하고, 서브 회로들 중 제1 서브 회로가 제1 값을 입력받고 제1 서브 회로의 제1 이웃 서브 회로 로부터 출력 신호를 수신한 경우, 제1 서브 회로의 대응 행의 액세스를 스킵하고, 제1 서브 회로의 제2 이웃 서 브 회로에 수신된 출력 신호를 전달하며, 제1 서브 회로가 제2 값을 입력받고 제1 이웃 서브 회로로부터 출력 신 호를 수신한 경우, 제1 서브 회로의 대응 행의 가중치들 및 제2 값에 대한 연산을 수행하도록 하고, 제1 서브 회 로의 대응 행을 액세스 한 후 제2 이웃 서브 회로로 전달할 다른 출력 신호를 생성하고, 생성된 다른 출력 신호 를 제2 이웃 서브 회로에 전달한다."}
{"patent_id": "10-2022-0185331", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "아래 실시예들은 비동기식 인메모리 컴퓨팅 장치 및 이의 제로 스키핑 방법에 관한 것이다."}
{"patent_id": "10-2022-0185331", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능(Artificial Intelligence, AI) 시스템 구현에 사용되는 딥 뉴럴 네트워크(Deep Neural Network, DN N)의 연산 처리 속도를 높이기 위해 입력 데이터에 0이 존재하는 경우 곱셈 연산 결과가 0이 되는 것을 이용하 여 입력 데이터 0에 대한 곱셈 연산이 실행되지 않을 수 있다. 이러한 입력 제로 스키핑(skipping)을 구현하기 위해 입력 전처리(input preprocessing) 과정이 필요하며 이를 위한 주변 회로(peripheral circuit)가 요구될 수 있다. 입력 전처리 과정에서 0이 아닌 입력 데이터의 인덱스가 따로 저장되고, 해당 인덱스의 데이터를 곱 셈기로 읽을 수 있도록 데이터가 따로 저장될 수 있다. 제로 스키핑을 위해 MAC(multiply-and-accumulate) 연 산 전 입력 전처리를 거쳐야 하므로 입력 전처리 과정에 별도의 시간이 할당되어야 하며 이를 위한 주변 회로의 면적 차지, 복잡성, 및 에너지 소모의 비효율이 야기될 수 있다."}
{"patent_id": "10-2022-0185331", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시 예에 따른 컴퓨팅 장치는 가중치들을 저장하는 메모리; 클럭과 비동기로 동작하고, 상기 메모리의 복수 의 행(row)들과 대응되는 서브 회로들을 포함하는 셀프 타임(self-timed) 회로; 및 상기 셀프 타임 회로를 제어 하는 제어 회로를 포함하고, 상기 서브 회로들 중 제1 서브 회로가 제1 값을 입력받고 상기 제1 서브 회로의 제 1 이웃 서브 회로로부터 출력 신호를 수신한 경우, 상기 제1 서브 회로의 대응 행의 액세스를 스킵하고, 상기 제1 서브 회로의 제2 이웃 서브 회로에 상기 수신된 출력 신호를 전달하며, 상기 제1 서브 회로가 제2 값을 입 력받고 상기 제1 이웃 서브 회로로부터 상기 출력 신호를 수신한 경우, 상기 제1 서브 회로의 대응 행의 가중치 들 및 상기 제2 값에 대한 연산을 수행하도록 하고, 상기 제1 서브 회로의 대응 행을 액세스 한 후 상기 제2 이 웃 서브 회로로 전달할 다른 출력 신호를 생성하고, 상기 생성된 다른 출력 신호를 상기 제2 이웃 서브 회로에 전달한다. 상기 제1 서브 회로는, 상기 제2 값을 입력받고 상기 출력 신호를 수신한 경우 워드라인(Word line) 구동 신호 및 프리차지(pre-charge) 신호를 생성할 수 있다. 상기 워드라인 구동 신호에 의해 상기 제1 서브 회로의 상기 대응 행의 상기 가중치들 및 상기 제2 값에 대한 상기 연산이 수행될 수 있다. 상기 프리차지 신호는, 상기 연산이 끝난 경우 생성될 수 있다. 상기 프리차지 신호에 의해 상기 제2 이웃 서브 회로의 대응 행을 액세스하기 위해 비트라인(bit line)들 및 비 트라인 바(bit line bar)들이 프리차지될 수 있다. 상기 제1 이웃 서브 회로로 전달할 상기 다른 출력 신호는, 상기 제2 이웃 서브 회로의 상기 대응 행의 상기 비 트라인들이 프리차지된 경우 생성될 수 있다. 상기 컴퓨팅 장치는 상기 제1 서브 회로의 대응 행의 가중치들 및 상기 제2 값에 대한 연산의 결과에서 정해진 개수의 비트들을 입력받고 상기 입력된 비트들과 이전 비트들을 누산하는 누산기를 더 포함할 수 있다. 상기 누산기는, 상기 입력된 비트들의 최상위 비트 및 상기 입력된 비트들과 상기 이전 비트들을 누산한 결과에 의해 결정된 캐리 비트를 기초로 업다운 카운터의 카운팅 방향을 결정할 수 있다. 상기 누산기는, 상기 입력된 비트들과 상기 이전 비트들을 누산한 상기 결과 및 상기 업다운 카운터의 카운팅 방향에 기초하여 출력 비트들을 생성할 수 있다. 상기 제어 회로는, 상기 누산기가 상기 입력된 비트들과 상기 이전 비트들을 누산한 것을 검출함으로써 제2 값 을 입력받은 상기 제2 이웃 서브 회로의 대응 행을 액세스 하도록 상기 셀프 타임 회로를 제어할 수 있다. 일 실시 예에 따른 컴퓨팅 장치는 가중치들을 저장하는 메모리; 상기 메모리의 복수의 행(row)들과 대응되는 서 브 회로들을 포함하는 셀프 타임(self-timed) 회로 - 상기 서브 회로들 중 제1 서브 회로가 제1 값을 입력받고 상기 제1 서브 회로의 제1 이웃 서브 회로로부터 출력 신호를 수신한 경우, 상기 제1 서브 회로의 대응 행의 액 세스를 스킵하고, 상기 제1 서브 회로의 제2 이웃 서브 회로에 상기 수신된 출력 신호를 전달하며, 상기 제1 서 브 회로가 제2 값을 입력받고 상기 제1 이웃 서브 회로로부터 상기 출력 신호를 수신한 경우, 상기 제1 서브 회 로의 대응 행의 가중치들 및 상기 제2 값에 대한 연산을 수행하도록 하고, 상기 제1 서브 회로의 대응 행을 액 세스 한 후 상기 제2 이웃 서브 회로로 전달할 다른 출력 신호를 생성하고, 상기 생성된 다른 출력 신호를 상기 제2 이웃 서브 회로에 전달함-; 상기 셀프 타임 회로를 제어하는 제어 회로; 및 상기 제1 서브 회로의 대응 행 의 가중치들 및 상기 제2 값에 대한 연산의 결과에서 정해진 개수의 비트들을 입력받고 상기 입력된 비트들과 이전 비트들을 누산하는 누산기를 포함한다. 일 실시 예에 따른 컴퓨팅 장치에 의해 수행되는 제로 스키핑 방법에 있어서, 상기 컴퓨팅 장치는, 가중치들을 저장하는 메모리; 클럭과 비동기로 동작하고, 상기 메모리의 복수의 행(row)들과 대응되는 서브 회로들을 포함 하는 셀프 타임(self-timed) 회로; 및 상기 셀프 타임 회로를 제어하는 제어 회로를 포함하고, 상기 서브 회로 들 중 제1 서브 회로가 제1 값을 입력받고 상기 제1 서브 회로의 제1 이웃 서브 회로로부터 출력 신호를 수신한 경우, 상기 제1 서브 회로의 대응 행의 액세스를 스킵하는 동작; 및 상기 제1 서브 회로의 제2 이웃 서브 회로 에 상기 수신된 출력 신호를 전달하는 동작을 포함하고, 상기 제1 서브 회로가 제2 값을 입력받고 상기 제1 이 웃 서브 회로로부터 상기 출력 신호를 수신한 경우, 상기 제1 서브 회로의 대응 행의 가중치들 및 상기 제2 값 에 대한 연산을 수행하도록 하는 동작; 상기 제1 서브 회로의 대응 행을 액세스 한 후 상기 제2 이웃 서브 회로 로 전달할 다른 출력 신호를 생성하는 동작; 및 상기 생성된 다른 출력 신호를 상기 제2 이웃 서브 회로에 전달 하는 동작을 포함한다.상기 제1 서브 회로는, 상기 제2 값을 입력받고 상기 출력 신호를 수신한 경우 워드라인(Word line) 구동 신호 및 프리차지(pre-charge) 신호를 생성할 수 있다. 상기 워드라인 구동 신호에 의해 상기 제1 서브 회로의 상기 대응 행의 상기 가중치들 및 상기 제2 값에 대한 상기 연산이 수행될 수 있다. 상기 프리차지 신호는, 상기 연산이 끝난 경우 생성될 수 있다. 상기 프리차지 신호에 의해 상기 제2 이웃 서브 회로의 대응 행을 액세스하기 위해 비트라인(bit line)들 및 비 트라인 바(bit line bar)들이 프리차지될 수 있다. 상기 제1 서브 회로의 상기 대응 행을 액세스 한 후 상기 제2 이웃 서브 회로로 전달할 상기 다른 출력 신호를 생성하는 동작은, 상기 제1 서브 회로의 상기 대응 행을 액세스 한 후 상기 제2 이웃 서브 회로의 상기 대응 행 의 상기 비트라인들이 프리차지된 경우 상기 제2 이웃 서브 회로로 전달할 상기 다른 출력 신호를 생성하는 동 작을 포함할 수 있다. 상기 컴퓨팅 장치는, 상기 제1 서브 회로의 대응 행의 가중치들 및 상기 제2 값에 대한 연산의 결과에서 정해진 개수의 비트들을 입력받고 상기 입력된 비트들과 이전 비트들을 누산하는 누산기를 더 포함할 수 있다. 상기 누산기는, 상기 입력된 비트들의 최상위 비트 및 상기 입력된 비트들과 상기 이전 비트들을 누산한 결과에 의해 결정된 캐리 비트를 기초로 업다운 카운터의 카운팅 방향을 결정할 수 있다. 상기 누산기는, 상기 입력된 비트들과 상기 이전 비트들을 누산한 상기 결과 및 상기 업다운 카운터의 카운팅 방향에 기초하여 출력 비트들을 생성할 수 있다."}
{"patent_id": "10-2022-0185331", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "실시 예들에 대한 특정한 구조적 또는 기능적 설명들은 단지 예시를 위한 목적으로 개시된 것으로서, 다양한 형 태로 변경되어 구현될 수 있다. 따라서, 실제 구현되는 형태는 개시된 특정 실시예로만 한정되는 것이 아니며, 본 명세서의 범위는 실시예들로 설명한 기술적 사상에 포함되는 변경, 균등물, 또는 대체물을 포함한다. 제1 또는 제2 등의 용어를 다양한 구성요소들을 설명하는데 사용될 수 있지만, 이런 용어들은 하나의 구성요소 를 다른 구성요소로부터 구별하는 목적으로만 해석되어야 한다. 예를 들어, 제1 구성요소는 제2 구성요소로 명 명될 수 있고, 유사하게 제2 구성요소는 제1 구성요소로도 명명될 수 있다. 어떤 구성요소가 다른 구성요소에 \"연결되어\" 있다고 언급된 때에는, 그 다른 구성요소에 직접적으로 연결되어 있거나 또는 접속되어 있을 수도 있지만, 중간에 다른 구성요소가 존재할 수도 있다고 이해되어야 할 것이다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\" 또는 \"가지다\" 등의 용어는 설명된 특징, 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것이 존재함 으로 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부분품 또는 이들 을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 해당 기술 분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가진다. 일반적으로 사용되 는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의미를 갖는 것으로해석되어야 하며, 본 명세서에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적인 의미로 해석되지 않는다. 이하, 실시예들을 첨부된 도면들을 참조하여 상세하게 설명한다. 첨부 도면을 참조하여 설명함에 있어, 도면 부호에 관계없이 동일한 구성 요소는 동일한 참조 부호를 부여하고, 이에 대한 중복되는 설명은 생략하기로 한 다. 도 1은 일 실시 예에 따른 컴퓨팅 장치를 설명하는 블록도이다. 컴퓨팅 장치는 메모리와 인메모리(in-memory) 컴퓨팅 연산을 위한 주변 회로를 포함하는 인메모리 컴 퓨팅 장치를 나타낼 수 있다. 컴퓨팅 장치는 딥 뉴럴 네트워크(DNN)의 MAC(multiply-and-accumulate) 연 산 처리를 수행하며 이에 대한 가속기 회로로서 구현될 수 있다. 메모리는 6T(Transistors) 또는 8T 정적 임의 접근 메모리(Static Random Access Memory, SRAM) 매크로에 해당할 수 있다. 이하, 본 개시에서 메모리는 메모리 셀이 64x64 어레이 형태로 배치된 것을 전제로 설명 된다. 메모리의 하나의 행(row)은 8비트(bit)에 해당하는 가중치(weight) 데이터를 8개 포함할 수 있다. 8비트 가중치 데이터는 2의 보수(2's complement) 형태로 저장되어 있을 수 있다. 각각의 가중치 데이터는 십진수로 나타내는 경우 -128 내지 +127의 범위 이내의 값을 가질 수 있다. 컴퓨팅 장치의 주변 회로는 셀프 타임(self-timed) 회로, 제어 회로, 프리차지(pre-charge)부 (또는 프리차지 회로), 연산부(또는 연산 회로), 및 누산기를 포함할 수 있다. 셀프 타임 회로는 클럭과 비동기로 동작할 수 있고, 메모리의 복수의 행들과 대응되는 서브 회로들을 포함할 수 있다. 셀프 타임 회로의 서브 회로들과 메모리의 행들(예: 64개의 행들)이 각각 연결될 수 있다. 서브 회로는 핸드 셰이킹(hand-shaking, HS) 블록(또는, HS 회로 블록)으로도 표현될 수 있다. 프리차지부와 연산부는 각각 메모리의 열(column)들(예: 64개의 열들)과 연결될 수 있다. 프리 차지부는 SRAM에 해당하는 메모리의 읽기 및/또는 쓰기 과정에서 메모리의 열에 대응하는 비트 라인(bit line, BL)들 및 비트라인 바(bit line bar, BLB)들을 프리차지(또는, 미리 충전)하도록 구성될 수 있 다. 연산부는 열 멀티플렉서(column multiplexer)와 메모리 셀에 저장된 데이터에 의해 발생하는 전압차 를 증폭시킴으로써 저장된 가중치 데이터를 읽는 감지 증폭기(sense amplifier, SA)를 포함할 수 있다. 누산기는 14비트 비동기 누산기(asynchronous accumulator) 회로들을(예: 8개의 14비트 비동기 누산기 들)을 포함할 수 있다. 각각의 14비트 비동기 누산기 회로는 연산부로부터 메모리의 각각의 행에 대 한 8비트(또는, 8비트 데이터) 연산 결과들을 입력 받고, 입력된 비트와 이전에 입력된 비트를 누산(또는, 가산)함으로써 14비트 데이터를 출력할 수 있다. 누산기의 연산 동작에 대하여 도 7 내지 도 8을 참조하 여 아래에서 상세하게 설명된다. 제어 회로는 셀프 타임 회로를 제어할 수 있다. 제어 회로는 누산기가 입력된 비트와 이 전에 입력된 비트를 누산한 것을 검출함으로써 메모리의 다음 행을 액세스 하도록 셀프 타임 회로를 제어할 수 있다. 메모리의 행에 액세스하는 것은 입력 특징 데이터(또는, 입력 액티베이션)가 0이 아닌 경우에 응답하여 대 응하는 메모리의 행에 대한 연산을 수행하는 것을 나타낼 수 있다. 입력 특징 데이터가 0인 경우, 곱셈 연산 결과가 0이 되는 것을 이용하여 대응하는 메모리의 행에 대한 액 세스는 스킵(skip)될 수 있다. 입력 특징 데이터가 1인 경우, 메모리의 행에 저장된 가중치 및 입력 특징 데이터에 대한 곱셈 연산은 메모리의 행에 저장된 가중치를 읽는 동작에 해당할 수 있다. 도 2는 일 실시 예에 따른 제로 스키핑 방법의 예시를 설명하는 도면이다. 메모리(예: 도 1을 참조하여 설명된 메모리)는 예를 들어, 64개의 행들을 포함할 수 있다. 행 내지 행은 인덱스 값이 0 내지 3에 해당하는 메모리의 각각의 행을 나타낼 수 있다. 메모리의 각 행은, 예를 들어, 64개의 메모리 셀들을 포함할 수 있다.셀프 타임 회로(예: 도 1을 참조하여 설명된 셀프 타임 회로)는 서브 회로들을 포함할 수 있다. 서 브 회로들의 개수는 메모리의 행들의 개수와 동일할 수 있다. 서브 회로들 각각은 메모리의 행들 각 각과 대응될 수 있다. 서브 회로 내지 서브 회로는 인덱스 값이 0 내지 3에 해당하는 메모리의 각각의 행에 대응하는 각각의 서브 회로를 나타낼 수 있다. 도 2를 참조하면, 입력 특징 데이터에 따라 셀프 타임 회로의 메모리에 대한 액세스 스킵 여부가 달 라질 수 있다. 입력 특징 데이터에 따라 메모리의 각각의 행에 대한 대응하는 서브 회로의 액세스 여부가 달라질 수 있다. 서브 회로의 입력 특징 데이터가 1이므로, 서브 회로는 서브 회로의 대응 행에 액세스할 수 있고, 대응 행에 저장된 가중치들과 입력 특징 데이터에 기반한 연산(예: 곱셈 연산)을 수행할 수 있다. 서브 회로의 입력 특징 데이터가 0이므로, 서브 회로는 대응 행의 액세스를 스킵할 수 있다. 서브 회로는 행에 저장된 가중치들과 입력 특징 데이터에 기반한 연산을 스킵할 수 있다. 서브 회로의 입력 특징 데이터가 0이므로, 서브 회로는 대응 행의 액세스를 스킵할 수 있다. 서브 회로는 행에 저장된 가중치들과 입력 특징 데이터에 기반한 연산을 스킵할 수 있다. 서브 회로의 입력 특징 데이터가 1이므로, 서브 회로는 서브 회로의 대응 행에 액세스할 수 있고, 대응 행에 저장된 가중치들과 입력 특징 데이터에 기반한 연산(예: 곱셈 연산)을 수행할 수 있다."}
{"patent_id": "10-2022-0185331", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "요약하면, 서브 회로는 행에 액세스함으로써 행의 가중치들 및 입력 특징 데이터에 대한 곱셈 연산을 수행할 수 있고, 누산기(예: 도 1을 참조하여 설명된 누산기)에서 그 결과 비트가 홀드(hold)될 수 있다. 행 및 행의 액세스가 스킵될 수 있다. 서브 회로는 행에 액세스함으로써 행 의 가중치들 및 입력 특징 데이터에 대한 곱셈 연산을 수행할 수 있다. 누산기에서 그 결과 비트와 행을 읽음으로써 홀드된 비트가 누산될 수 있다. 입력 특징 데이터에 기초하여 메모리의 64개의 행에 각각 포함된 8비트 가중치들에 대해 위의 동작이 수행 될 수 있다. 도 3은 일 실시 예에 따른 셀프 타임 회로의 동작을 설명하는 도면이다. 셀프 타임 회로(예: 도 1의 셀프 타임 회로 또는 도 2의 셀프 타임 회로)는 클럭과 비동기로 동작하 고, 메모리(예: 도 1의 메모리 또는 도 2의 메모리)의 복수의 행들과 대응되는 서브 회로들을 포함할 수 있다. 도 3을 참조하면, 셀프 타임 회로는 서브 회로들(310, 320, 330, 340)을 포함할 수 있다. 서브 회로들(310, 320, 330, 340) 각각은 도 2의 서브 회로들(221, 222, 223, 224) 각각의 예시에 해당할 수 있다. 설명의 편의 상 4개의 서브 회로들(310, 320, 330, 340)을 도 3에 도시하였을 뿐, 셀프 타임 회로의 서브 회로들이 4개인 것으로 제한되는 것은 아니다. 서브 회로들(310, 320, 330, 340) 각각은 메모리의 row[0] 내지 row[3](예: 도 2 의 행 내지 행) 각각에 대응할 수 있다. INPUT[0] 내지 INPUT[3] 각각은 서브 회로들(310, 320, 330, 340) 각각에 입력된 입력 특징 데이터를 나타낼 수 있다. 도 3에 도시된 예에서, 서브 회로들(310, 320, 330, 340) 각각은 HS 회로와 MUX를 포함할 수 있다. HS 회로에 대한 설명은 도 5를 통해 후술한다. MUX[0]은 인메모리 컴퓨팅 연산의 시작 신호를 나타낼 수 있다. 제어 회로(예: 도 1의 제어 회로)는 MUX[0]을 1(또는, 하이(high) 신호)로 만듦으로써 연산이 시작되도록 셀프 타임 회로를 제어할 수 있다. 서브 회로가 INPUT[0]=1을 입력받고 하이 신호인 MUX[0] 신호를 수신한 경우, row[0](예: 도 2의 행 )의 가중치들 및 INPUT[0]=1에 대한 연산이 수행될 수 있다. 서브 회로는 row[0]를 액세스 한 후 서 브 회로의 HS 회로는 서브 회로로 전달할 하이 신호인 REQ[0] 신호를 생성할 수 있다. 서브 회로 의 MUX는 INPUT[0]=1에 따라 REQ[0] 신호를 서브 회로로 전달할 수 있다. REQ[0] 신호는 도 3에 도시된 MUX[1] 신호에 해당할 수 있다. 서브 회로가 INPUT[1]=0을 입력받고 서브 회로로부터 REQ[0] 신호(즉, MUX[1] 신호)를 수신한 경우, row[1](예: 도 2의 행)의 액세스가 스킵될 수 있다. 서브 회로의 HS 회로는 INPUT[1]=0이므로 REQ[1]을 생성하지 않을 수 있다. 서브 회로의 MUX는 INPUT[1]=0에 따라 MUX[1] 신호를 서브 회로으 로 전달할 수 있다. 서브 회로가 INPUT[2]=0을 입력받고 서브 회로로부터 MUX[2] 신호(즉, MUX[1] 신호)를 수신한 경우, row[2](예: 도 2의 행)의 액세스가 스킵될 수 있다. 서브 회로의 HS 회로는 INPUT[1]=0이므로 REQ[2]을 생성하지 않을 수 있다. 서브 회로의 MUX는 서브 회로에 MUX[2] 신호를 전달할 수 있다. MUX[2] 신호가 MUX[3] 신호로서 서브 회로로 전달될 수 있다. 서브 회로가 INPUT[3]=1을 입력받고 서브 회로로부터 MUX[3] 신호를 수신한 경우, row[3](예: 도 2 의 행)의 가중치들 및 INPUT[3]=1에 대한 연산이 수행될 수 있다. 서브 회로는 row[3]를 액세스 한 후 서브 회로의 HS 회로는 이웃 서브 회로(미도시)로 전달할 하이 신호인 REQ[3] 신호를 생성할 수 있다. 서브 회로의 MUX는 REQ[3] 신호를 이웃 서브 회로에 전달할 수 있다. 도 4는 일 실시 예에 따른 제로 스키핑 방법을 설명하는 흐름도이다. 아래의 동작들은 컴퓨팅 장치(예: 도 1을 참조하여 설명된 컴퓨팅 장치)에 의해 수행될 수 있다. 동작 410-1과 동작 410-2는 입력 특징 데이터가 0 또는 1인지 여부에 따라 수행될 수 있다. 이하, 입력 특징 데이터는 INPUT으로 표현될 수 있다. 동작 410-1에서, 제1 서브 회로가 제1 값을 입력받고 제1 서브 회로의 제1 이웃 서브 회로로부터 출력 신호를 수신할 수 있다. 제1 값은 INPUT=0을 나타낼 수 있다. 제1 이웃 서브 회로는 제1 서브 회로보다 대응하는 메 모리 행의 인덱스 값이 1만큼 작은 서브 회로를 나타낼 수 있다. 제1 이웃 서브 회로의 출력 신호는 하이 신호 인 MUX 신호를 나타낼 수 있다. 동작 420-1에서, 제1 서브 회로의 대응 행의 액세스가 스킵될 수 있다. INPUT=0이므로, 제1 서브 회로는 대응 행의 액세스를 스킵할 수 있다. 동작 430-1에서, 제1 서브 회로의 제2 이웃 서브 회로에 수신된 출력 신호가 전달될 수 있다. 제2 이웃 서브 회로는 제1 서브 회로보다 대응하는 메모리 행의 인덱스 값이 1만큼 큰 서브 회로를 나타낼 수 있다. 동작 410-2에서, 제1 서브 회로가 제2 값을 입력받고 제1 이웃 서브 회로로부터 출력 신호를 수신할 수 있다. 제2 값은 INPUT=1을 나타낼 수 있다. 동작 420-2에서, 제1 서브 회로의 대응 행의 가중치들 및 제2 값에 대한 연산이 수행될 수 있다. 동작 430-2에서, 제1 서브 회로의 대응 행을 액세스 한 후 제2 이웃 서브 회로로 전달할 다른 출력 신호가 생성 될 수 있다. 다른 출력 신호는 하이 신호인 REQ 신호를 나타낼 수 있다. 동작 440에서, 생성된 다른 출력 신호가 제2 이웃 서브 회로에 전달될 수 있다. 다른 출력 신호(또는, REQ 신 호)는 하이 신호인 MUX 신호로서 제2 이웃 서브 회로에 전달될 수 있다. 도 5 내지 도 6은 일 실시 예에 따른 서브 회로의 동작을 설명하는 도면이다. 도 5는 메모리의 인덱스 값이 n(n은 0 이상의 정수)인 행 row[n]에 대응하는 서브 회로의 HS 회로의 개략도이다. 서브 회로의 HS 회로에 INPUT[n], MUX[n], 및 DONE 신호가 입력되고 EN_WL[n], EN_PRE[n], 및 REQ[n] 신호가 출력될 수 있다. INPUT[n]은 인덱스 값이 n에 해당하는 메모리의 row[n]에 대응하는 입력 특징 데이터를 나타 낼 수 있다. n이 0인 경우, MUX[0]은 인메모리 컴퓨팅 연산의 시작 신호를 나타낼 수 있다. n이 1 이상인 경 우, MUX[n]은 REQ[n-1] 또는 MUX[n-1]을 나타낼 수 있다. INPUT[n-1]=1인 경우 하이 신호인 REQ[n-1] 신호는 MUX[n]을 하이 신호로 만들고, INPUT[n-1]=0인 경우 하이 신호인 MUX[n-1]는 MUX[n]을 하이 신호로 만들 수 있 다.서브 회로는 INPUT[n]=1을 입력받고 하이 신호인 MUX[n]을 수신한 경우 EN_WN[n] 신호 및 EN_PRE[n] 신호를 생 성할 수 있다. EN_WL[n]은 row[n]의 워드라인 구동 신호를 나타낼 수 있다. EN_WL[n]이 하이인 경우 row[n]을 액세스함으로써 입력 특징 데이터와 row[n]의 가중치에 대한 연산(또는, 곱셈 연산)이 수행될 수 있다. INPUT=1과 row[n]에 저 장된 가중치에 대한 곱셈 연산은 row[n]에 저장된 가중치를 읽는 동작에 해당할 수 있다. EN_PRE[n]는 row[n+1]에 액세스 하기 위한 메모리의 비트라인들 및 비트라인 바들의 프리차지(pre-charge) 신호 를 나타낼 수 있다. EN_PRE[n]은 INPUT[n]과 row[n]의 가중치에 대한 연산이 끝난 경우 하이가 될 수 있다. EN_PRE[n]이 하이인 경우 프리차지부(예: 도 1을 참조하여 설명된 프리차지부)에 의해 메모리의 열들이 프 리차지(또는, 미리 충전)될 수 있다. DONE 신호는 서브 회로의 핸드 셰이킹 동작을 구현하기 위한 신호를 나타낼 수 있다. Row[n]에 저장된 가중치 를 읽는 동작(또는, 곱셈 연산)이 끝난 경우, DONE 신호는 로우가 될 수 있다. Row[n+1]에 액세스 하기 위해 비트라인들 및 비트라인 바들의 프리차지가 끝난 경우, DONE 신호는 하이가 될 수 있다. 서브 회로는 다이나믹 로직 회로(Dynamic logic circuit)를 포함할 수 있다. 다이나믹 로직 회로에 입력되는 DONEB(DONEBB)가 하이(high)이고 EN_F(EN_B)가 하이인 경우 출력이 로우(low)가 될 수 있다. 다이나믹 로직 회로에 입력되는 DONEB(DONEBB)가 로우인 경우 출력이 하이가 될 수 있다. 도 6을 참조하면, D_F는 DONEB가 입 력되는 다이나믹 로직 회로의 출력을 나타내고, D_B는 DONEBB가 입력되는 다이나믹 로직 회로의 출력을 나타낼 수 있다. 도 6은 서브 회로의 동작을 설명하기 위한 신호들의 타이밍도이다. DONE 신호가 반전된 DONEB 신호가 로우이므로 다이나믹 로직 회로의 출력인 D_F가 하이이다. INPUT[n]=1을 입 력받고 MUX[n]이 하이인 경우, EN_F가 하이가 된다. 따라서 시점에서, EN_F와 D_F의 곱출력인 EN_WL 또한 하이가 된다. EN_WL[n]이 하이인 시간 동안, row[n]을 액세스함으로써 입력 특징 데이터와 row[n]의 가중치에 대한 연산(또는, 곱셈 연산)이 수행될 수 있다. INPUT=1과 row[n]에 저장된 가중치에 대한 곱셈 연산은 row[n]에 저 장된 가중치를 읽는 동작에 해당할 수 있다. Row[n]에 저장된 가중치를 읽는 동작이 끝난 경우, DONE 신호는 로우가 된다. 따라서 D_F는 로우가 되고, D_F 가 반전된 EN_B는 하이가 된다. EN_WL[n]은 로우가 된다. DONEBB신호가 로우이므로 다이나믹 로직 회로의 출 력인 D_B가 계속해서 하이이다. 따라서 시점에서, EN_B와 D_B의 곱출력인 EN_PRE[n] 또한 하이가 된다. EN_PRE[n]이 하이인 시간 동안, row[n+1]에 액세스 하기 위해 비트라인들 및 비트라인 바들이 프리차지 될 수 있다. 프리차지가 끝난 경우, DONE 신호는 하이가 된다. 따라서 D_B와 EN_PRE[n]이 로우가 되고, D_B가 반전된 REQ 신호가 시점에서 하이가 된다. 도 6에 도시된 바와 달리 신호들이 하이 또는 로우가 되는 시점들 사이에 딜레이가 나타날 수 있다. 도 7 내지 도 8은 일 실시 예에 따른 누산기의 동작을 설명하는 도면이다. 도 7은 14비트 비동기 누산기 회로의 누산 동작을 도시한다. 누산기(예: 도 1을 참조하여 설명된 누산기)는 14비트 비동기 누산기 회로들을 포함할 수 있다. 각각의 14비트 비동기 누산기 회로는 메모리(예: 도 1을 참조하여 설명된 메모리 또는 도 2를 참조하여 설명된 메 모리)의 각각의 행에 대한 8비트(또는, 8비트 데이터) 연산 결과들을 입력 받고, 입력된 비트와 이전에 입 력된 비트를 누산(또는, 가산)함으로써 14비트 데이터를 출력할 수 있다. 도 7을 참조하면, 14비트 비동기 누산기 회로는 입력 및 가산된 8비트 데이터를 홀드(hold)하는 D 플립플롭들, 8비트 비동기 가산기(asynchronous adder), 카운터 인에이블(ENB), 및 6비트 업다운 카운터(updown counter)를 포함할 수 있다.8비트 비동기 가산기는 입력된 8비트와 이전 8비트를 더할 수 있다. 그 결과는 D 플립플롭에 홀드되어 다 음에 입력되는 8비트와 누산될 수 있다. 카운터 인에이블은 8비트 비동기 가산기에 입력되는 8비트의 최상위 비트(Most Significant Bit, MSB) 및 입력되는 8비트와 이전 8비트를 누산한 결과에 의해 결정된 캐리(carry) 비트를 기초로 6비트 업다운 카운터의 카운팅 방향을 결정할 수 있다. 메모리에 저장된 8비트 가중치 데이터는 2의 보수 형태로 저장되어 있을 수 있다. 부호 확장(sign extension) 을 고려하면, 8비트 비동기 가산기에 입력되는 8비트의 MSB가 1인 경우 111111는 -1을 의미하고, MSB가 0인 경우 000000는 0을 의미할 수 있다. MSB가 1이고, 입력되는 8비트와 이전 8비트를 누산한 결 과에 의해 결정된 캐리 비트가 0인 경우 -1+0=-1이므로 카운터 인에이블은 6비트 업다운 카운터에게 클럭 신호와 다운(down) 카운트 신호를 보낼 수 있다. MSB가 0이고, 입력되는 8비트와 이전 8비트를 누산한 결 과에 의해 결정된 캐리 비트가 1인 경우 0+1=1이므로 카운터 인에이블은 6비트 업다운 카운터에게 클 럭 신호와 업(up) 카운트 신호를 보낼 수 있다. 6비트 업다운 카운터는 클럭 신호마다 동작하며 업/다운 카운트 신호(또는, 카운팅 방향)에 기초하여 14비 트 비동기 누산기 회로의 14비트 출력 중 상위 6비트를 결정할 수 있다. 도 8을 참조하면, MSB가 1이고 누산에 의해 결정된 캐리 비트가 1인 경우 -1+1=0이므로 카운터 인에이블은 클럭 신호를 생성하지 않는다. MSB가 0이고 누산에 의해 결정된 캐리 비트가 0인 경우 0+0=0이므로 카운터 인 에이블은 클럭 신호를 생성하지 않는다. MSB가 1이고 누산에 의해 결정된 캐리 비트가 0이거나 MSB가 0이 고 누산에 의해 결정된 캐리 비트가 1인 경우에만 카운터 인에이블이 클럭 신호를 생성하고 6비트 업다운 카운터의 카운팅 방향이 변하므로 누산 동작의 오버헤드(overhead)가 상당히 감소할 수 있다. 14비트 비동기 누산기 회로는 입력된 8비트와 이전 8비트를 누산한 결과 및 6비트 업다운 카운터의 카운팅 방향에 기초하여 14비트 출력 비트를 생성할 수 있다. 제어 회로(예: 도 1의 제어 회로)는 14비트 비동기 누산기 회로가 입력된 8비트와 이전 8비트를 누산한 것 을 검출함으로써 메모리의 다음 행을 액세스 하도록 셀프 타임 회로(예: 도 1을 참조하여 설명된 셀프 타임 회 로)를 제어할 수 있다. 도 7 내지 도 8을 참조하여 설명된 14비트 비동기 누산기 회로의 누산 동작은 메모리의 임의의 행의 가중치 및 입력 특징 데이터에 대한 연산이 끝나고 다음 행을 액세스하기 위해 비트라인들 및 비트라인 바들이 프리차지되 는 동안 수행될 수 있다. 연산(또는, 곱셈 연산)과 누산은 파이프라이닝(pipelining) 방식으로 수행될 수 있다. 다른 일 실시 예에 따르면, 메모리의 각각의 행에 4비트에 해당하는 가중치 데이터가 저장되는 경우, 누산기는 10비트 비동기 누산기 회로를 포함할 수 있다. 각각의 10비트 비동기 누산기 회로는 4비트 비동기 가산기 및 6 비트 업다운 카운터를 포함할 수 있다. 이상에서 설명된 실시예들은 하드웨어 구성요소, 소프트웨어 구성요소, 및/또는 하드웨어 구성요소 및 소프트웨 어 구성요소의 조합으로 구현될 수 있다. 예를 들어, 실시예들에서 설명된 장치, 방법 및 구성요소는, 예를 들 어, 프로세서, 콘트롤러, ALU(arithmetic logic unit), 디지털 신호 프로세서(digital signal processor), 마 이크로컴퓨터, FPGA(field programmable gate array), PLU(programmable logic unit), 마이크로프로세서, 또는 명령(instruction)을 실행하고 응답할 수 있는 다른 어떠한 장치와 같이, 범용 컴퓨터 또는 특수 목적 컴퓨터를 이용하여 구현될 수 있다. 처리 장치는 운영 체제(OS) 및 상기 운영 체제 상에서 수행되는 소프트웨어 애플리 케이션을 수행할 수 있다. 또한, 처리 장치는 소프트웨어의 실행에 응답하여, 데이터를 접근, 저장, 조작, 처 리 및 생성할 수도 있다. 이해의 편의를 위하여, 처리 장치는 하나가 사용되는 것으로 설명된 경우도 있지만,"}
{"patent_id": "10-2022-0185331", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "해당 기술분야에서 통상의 지식을 가진 자는, 처리 장치가 복수 개의 처리 요소(processing element) 및/또는 복수 유형의 처리 요소를 포함할 수 있음을 알 수 있다. 예를 들어, 처리 장치는 복수 개의 프로세서 또는 하 나의 프로세서 및 하나의 컨트롤러를 포함할 수 있다. 또한, 병렬 프로세서(parallel processor)와 같은, 다른 처리 구성(processing configuration)도 가능하다. 소프트웨어는 컴퓨터 프로그램(computer program), 코드(code), 명령(instruction), 또는 이들 중 하나 이상의 조합을 포함할 수 있으며, 원하는 대로 동작하도록 처리 장치를 구성하거나 독립적으로 또는 결합적으로(collectively) 처리 장치를 명령할 수 있다. 소프트웨어 및/또는 데이터는, 처리 장치에 의하여 해석되거나 처리 장치에 명령 또는 데이터를 제공하기 위하여, 어떤 유형의 기계, 구성요소(component), 물리적 장치, 가상 장치(virtual equipment), 컴퓨터 저장 매체 또는 장치, 또는 전송되는 신호 파(signal wave)에 영구적으로, 또는 일시적으로 구체화(embody)될 수 있다. 소프트웨어는 네트워크로 연결된 컴퓨터 시스템 상에 분산되어서, 분산된 방법으로 저장되거나 실행될 수도 있다. 소프트웨어 및 데이터는 컴퓨터 판독 가능 기록 매체에 저장될 수 있다. 실시예에 따른 방법은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등을 단 독으로 또는 조합하여 저장할 수 있으며 매체에 기록되는 프로그램 명령은 실시예를 위하여 특별히 설계되고 구 성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판독 가능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD-ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체(magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다. 위에서 설명한 하드웨어 장치는 실시예의 동작을 수행하기 위해 하나 또는 복수의 소프트웨어 모듈로서 작동하 도록 구성될 수 있으며, 그 역도 마찬가지이다."}
{"patent_id": "10-2022-0185331", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "이상과 같이 실시예들이 비록 한정된 도면에 의해 설명되었으나, 해당 기술분야에서 통상의 지식을 가진 자라면 이를 기초로 다양한 기술적 수정 및 변형을 적용할 수 있다. 예를 들어, 설명된 기술들이 설명된 방법과 다른 순서로 수행되거나, 및/또는 설명된 시스템, 구조, 장치, 회로 등의 구성요소들이 설명된 방법과 다른 형태로 결합 또는 조합되거나, 다른 구성요소 또는 균등물에 의하여 대치되거나 치환되더라도 적절한 결과가 달성될 수 있다. 그러므로, 다른 구현들, 다른 실시예들 및 청구범위와 균등한 것들도 후술하는 청구범위의 범위에 속한다."}
{"patent_id": "10-2022-0185331", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1 은 일 실시 예에 따른 컴퓨팅 장치를 설명하는 블록도이다. 도 2는 일 실시 예에 따른 제로 스키핑 방법의 예시를 설명하는 도면이다. 도 3은 일 실시 예에 따른 셀프 타임 회로의 동작을 설명하는 도면이다. 도 4는 일 실시 예에 따른 제로 스키핑 방법을 설명하는 흐름도이다. 도 5 내지 도 6은 일 실시 예에 따른 서브 회로의 동작을 설명하는 도면이다. 도 7 내지 도 8은 일 실시 예에 따른 누산기의 동작을 설명하는 도면이다."}
