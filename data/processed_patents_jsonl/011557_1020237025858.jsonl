{"patent_id": "10-2023-7025858", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0121151", "출원번호": "10-2023-7025858", "발명의 명칭": "디지털 곱셈기 회로망의 수치 정밀도", "출원인": "그록, 인크.", "발명자": "베르너, 제프리"}}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "방법에 있어서,제1 포맷의 피연산자 및 상기 제1 포맷의 또다른 피연산자에 대응하는 디지털 비트들들을 하나 이상의 스토리지레지스터 회로들에 저장하는 동작;피연산자를 제1 복수의 피연산자들로 분해하는 동작;다른 피연산자를 제2 복수의 피연산자들로 분해하는 동작;복수의 곱셈기 회로들의 각 곱셈기 회로를 사용하여, 복수의 부분 결과들 중 대응하는 부분 결과를 생성하기 위해, 상기 제1 복수의 피연산자들의 각각의 제1 피연산자와 상기 제2 복수의 피연산자들의 각각의 제2 피연산자를 곱하는 동작;누산기 회로에 저장된 제2 포맷의 완전한 결과를 생성하기 위하여, 상기 제2 포맷을 사용하여 누산기 회로에서복수의 부분 결과들을 누산하는 동작; 및상기 제2 포맷의 완전한 결과를 출력 포맷의 출력 결과로 변환하는 동작을 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 방법은,툼-쿡 분해 알고리즘을 적용하여, 상기 피연산자 및 상기 다른 피연산자를 분해하는 동작; 및분해에 앞서서, 상기 피연산자 및 상기 다른 피연산자를 부동 소수점 포맷에서 정수 포맷으로 변환하는 동작을 더 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 방법은,누산 전에, 상기 제1 포맷으로부터의 상기 복수의 부분 결과들을 상기 제2 포맷으로 변환하는 동작을 더 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 방법은,복수의 지수 값들을 생성하기 위해 상기 피연산자 및 상기 다른 피연산자의 대응하는 지수 부분을 가산하는 동작; 및복수의 시프트된 부분 결과들의 대응하는 시프트된 부분 결과를 생성하기 위하여, 상기 복수의 지수 값들의 대공개특허 10-2023-0121151-3-응하는 지수 값에 기초하여, 누산 전에 상기 복수의 부분 결과들의 각각의 부분 결과를 시프트하는 동작을 더 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 방법은,누산 전에, 상기 대응하는 시프트된 부분 결과를 상기 제1 포맷으로부터 상기 제2 포맷으로 변환하는 동작을 더 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 제1 포맷은,INT8 포맷, INT16 포맷, BF16 포맷, FP16 포맷, 및 FP32 포맷 중 하나로부터 선택되고,상기 출력 포맷은,FP32 포맷 및 FP64 포맷 중 하나인, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 제2 포맷의 완전한 결과를 출력 포맷의 출력 결과로 변환하는 동작은,상기 출력 포맷에 기초하여 상기 누산기 회로에 저장된 상기 완전한 결과를 절단하는 동작을 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서,상기 방법은,상기 복수의 부분 결과들 중에서 가장 작은 부분 결과부터 상기 복수의 부분 결과들 중에서 가장 큰 부분 결과까지, 상기 복수의 부분 결과들을 누산하는 동작을 더 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "정수 곱셈을 위한 방법에 있어서,제1 포맷의 피연산자 및 상기 제1 포맷의 또다른 피연산자에 대응하는 디지털 비트들들을 저장하는 동작;피연산자 및 다른 피연산자를 복수의 피연산자들로 분해하는 동작;복수의 부분 결과들 중 대응하는 부분 결과를 생성하기 위해, 피연산자들의 제1 부분집합의 각각의 제1 피연산자와 피연산자들의 제2 부분집합의 각각의 제2 피연산자를 곱하는 동작;공개특허 10-2023-0121151-4-제2 포맷을 사용하여 누산기 회로에서 상기 복수의 부분 결과들을 누산함으로써 제2 포맷의 완전한 결과를 생성하는 동작을 포함하는, 정수 곱셈을 위한 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 방법은,툼-쿡 분해 알고리즘을 사용하여 상기 피연산자를 피연산자들의 상기 제1 부분집합으로 분해하는 동작; 및상기 툼-쿡 분해 알고리즘을 사용하여 상기 다른 피연산자를 피연산자들의 상기 제2 부분집합으로 분해하는 동작을 더 포함하는, 정수 곱셈을 위한 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제9항에 있어서,상기 제1 포맷은,INT8 포맷, INT16 포맷, BF16 포맷, FP16 포맷, 및 FP32 포맷 중 하나로부터 선택되고,상기 제2 포맷은,트루포인트 포맷인, 정수 곱셈을 위한 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제9항에 있어서,상기 누산기 회로는,상기 제2 포맷의 상기 완전한 결과를 저장하기 위해 구성되는(configured) 레지스터를 포함하고,상기 레지스터의 사이즈는 128비트인, 정수 곱셈을 위한 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제9항에 있어서,스트리밍 프로세서의 복수의 구성요소들은,상기 정수 곱셈의 연산을 수행하는, 정수 곱셈을 위한 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서,상기 복수의 구성요소들은,상기 누산기 회로 및 복수의 정수 곱셈기들, 각각의 제1 연산자와 각각의 제2 연산자를 곱하기 위해 구성되는공개특허 10-2023-0121151-5-상기 복수의 정수 곱셈기들의 각각의 정수 곱셈기를 포함하는, 정수 곱셈을 위한 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제9항에 있어서,상기 정수 곱셈을 위한 방법은,상기 제2 포맷의 완전한 결과를 출력 포맷의 출력 결과로 변환하는 동작을 더 포함하는, 정수 곱셈을 위한 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서,상기 출력 포맷은,FP32 포맷 및 FP64 포맷 중 하나인, 정수 곱셈을 위한 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제1 어레이 및 제2 어레이의 입력 피연산자들 간의 요소별 연산을 수행하기 위한 방법에 있어서, 상기 입력 피연산자들의 지수들을 복수의 지수 범위로 분류하는 동작;상기 제1 어레이로부터 상기 입력 피연산자들의 제1 부분집합을, 각각의 지수 범위를 각자 가지는 제1 복수의그룹들로 분류하는 동작;상기 제2 어레이로부터 상기 입력 피연산자들의 제2 부분집합을, 각각의 지수 범위를 각자 가지는 제2 복수의그룹들로 분류하는 동작;제1 그룹들에서 제1 정규화된 피연산자들과 제2 그룹들에서 제2 정규화된 피연산자들을 생성하기 위해, 상기 제1 복수의 그룹들 및 상기 제2 복수의 그룹들의 각 그룹으로부터의 피연산자들을, 대응하는 지수 범위 내로 정규화하는 동작;상기 제1 복수의 그룹들의 각 그룹 및 상기 제2 복수의 그룹들의 각 그룹의 각각의 중간 결과를 생성하기 위해,상기 제1 정규화된 피연산자들의 대응하는 부분집합 및 상기 제2 정규화된 피연산자들의 대응하는 부분집합에요소별 연산을 실행하는 동작;상기 각각의 중간 결과들과 복수의 중간 결과들의 이전에 획득된 하나 이상의 중간 결과들의 누산을 실행하는동작을 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서,상기 입력 피연산자들의 상기 제1 어레이는,활성화 행렬을 포함하고,상기 입력 피연산자들의 상기 제2 어레이는,공개특허 10-2023-0121151-6-가중치 행렬을 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18항에 있어서,상기 요소별 연산은,상기 활성화 행렬 및 상기 가중치 행렬의 대응하는 요소들 간의 요소별 곱셈을 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제17항에 있어서,상기 입력 피연산자들은,FP16 포맷, FP32 포맷, 및 BF16 포맷 중 하나에서 선택된 수치 포맷을 가지는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제17항에 있어서,상기 방법은,누산에 앞서서, 상기 각각의 중간 결과를 정의된 범위로 정렬하는 동작을 더 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제17항에 있어서, 상기 방법은,상기 제1 복수의 그룹들 및 상기 제2 복수의 그룹들의 모든 그룹들이 완전한 경우, 최종 결과를 생성하기 위해최종 중간 결과의 최종 누산을 실행하는 동작; 및상기 최종 결과의 최종 포맷으로의 최종 변환을 실행하는 동작을 더 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제22항에 있어서,상기 방법은,상기 최종 변환까지 오류가 발생하지 않는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제22항에 있어서,공개특허 10-2023-0121151-7-상기 최종 포맷은,FP32 포맷, FP64 포맷, 및 FP128 포맷 중 하나로부터 선택되는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제17항에 있어서,상기 방법은,누산에 앞서서, 각각의 중간 결과를 트루포인트 포맷으로 변환하는 동작을 더 포함하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "제17항에 있어서,스트리밍 복수의 구성요소들은,제1 어레이와 제2 어레이의 입력 피연산자들 간의 요소별 연산의 단계들을 수행하는, 방법."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "비일시적 컴퓨터 판독가능 기록 매체에 있어서,명령들이 프로세서에 의해 실행될 때, 상기 프로세서로 하여금,제1 포맷의 피연산자 및 상기 제1 포맷의 또다른 피연산자에 대응하는 디지털 비트들들을 저장하고,피연산자 및 다른 피연산자를 복수의 피연산자들로 분해하고,복수의 부분 결과들 중 대응하는 부분 결과를 생성하기 위해, 피연산자들의 제1 부분집합의 각각의 제1 피연산자와 피연산자들의 제2 부분집합의 각각의 제2 피연산자를 곱하고,제2 포맷을 사용하여 누산기 회로에서 상기 복수의 부분 결과들을 누산함으로써 제2 포맷의 완전한 결과를 생성하도록 하는 명령들이 저장된,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "제27항에 있어서,상기 비일시적 컴퓨터 판독가능 기록 매체는,실행되는 경우, 상기 프로세서로 하여금,툼-쿡 분해 알고리즘을 사용하여 상기 피연산자를 피연산자들의 제1 부분집합으로 분해하고,툼-쿡 분해 알고리즘을 사용하여 상기 다른 피연산자를 피연산자들의 제2 부분집합으로 분해하는 명령들을 더 포함하는,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "공개특허 10-2023-0121151-8-제27항에 있어서,상기 제1 포맷은,INT8 포맷, INT16 포맷, BF16 포맷, FP16 포맷, 및 FP32 포맷 중 하나로부터 선택되고,상기 제2 포맷은,트루포인트 포맷인,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "제27항에 있어서,상기 누산기 회로는,상기 제2 포맷의 상기 완전한 결과를 저장하기 위해 구성되는 레지스터를 포함하고,상기 레지스터의 사이즈는 128비트인,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "제27항에 있어서,상기 프로세서는,스트리밍 프로세서인, 비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제31항에 있어서,상기 스트리밍 프로세서는,상기 누산기 회로 및 복수의 정수 곱셈기들, 각각의 제1 피연산자와 각각의 제2 피연산자를 곱하기 위해 구성되는 상기 복수의 정수 곱셈기들의 각각의 정수 곱셈기들을 포함하는,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "제27항에 있어서,상기 비일시적 컴퓨터 판독가능 기록 매체는,실행되는 경우, 상기 프로세서로 하여금,상기 제2 포맷의 완전한 결과를 출력 포맷의 출력 결과로 변환하도록 하는 명령들을 더 포함하는,공개특허 10-2023-0121151-9-비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제33항에 있어서,상기 출력 포맷은,FP32 포맷 및 FP64 포맷 중 하나인,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "비일시적 컴퓨터 판독가능 기록 매체에 있어서,명령들이 프로세서에 의해 실행될 때, 상기 프로세서로 하여금,제1 어레이 및 제2 어레이의 입력 피연산자들의 지수들을 복수의 지수 범위로 분류하고,상기 제1 어레이로부터 상기 입력 피연산자들의 제1 부분집합을, 각각의 지수 범위를 각자 가지는 제1 복수의그룹들로 분류하고,상기 제2 어레이로부터 상기 입력 피연산자들의 제2 부분집합을, 각각의 지수 범위를 각자 가지는 제2 복수의그룹들로 분류하고,제1 그룹들에서 제1 정규화된 피연산자들과 제2 그룹들에서 제2 정규화된 피연산자들을 생성하기 위해, 상기 제1 복수의 그룹들 및 상기 제2 복수의 그룹들의 각 그룹으로부터의 피연산자들을, 대응하는 지수 범위 내로 정규화하고,상기 제1 복수의 그룹들의 각 그룹 및 상기 제2 복수의 그룹들의 각 그룹의 각각의 중간 결과를 생성하기 위해,상기 제1 정규화된 피연산자들의 대응하는 부분집합 및 상기 제2 정규화된 피연산자들의 대응하는 부분집합에요소별 연산을 실행하고,상기 각각의 중간 결과들과 복수의 중간 결과들의 이전에 획득된 하나 이상의 중간 결과들의 누산을 실행하도록하는 명령들이 저장된, 비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "제35항에 있어서,상기 입력 피연산자들의 상기 제1 어레이는,활성화 행렬을 포함하고,상기 입력 피연산자들의 상기 제2 어레이는,가중치 행렬을 포함하는,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "공개특허 10-2023-0121151-10-제36항에 있어서,상기 요소별 연산은,상기 활성화 행렬 및 상기 가중치 행렬의 대응하는 요소들 간의 요소별 곱셈을 포함하는,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "제35항에 있어서,상기 입력 피연산자들은,FP16 포맷, FP32 포맷, 및 BF16 포맷 중 하나에서 선택된 수치 포맷을 가지는,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_39", "content": "제35항에 있어서,상기 비일시적 컴퓨터 판독가능 기록 매체는,실행되는 경우, 상기 프로세서로 하여금,누산에 앞서서, 상기 각각의 중간 결과를 정의된 범위로 정렬하도록 하는 명령들을 더 포함하는,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "제35항에 있어서,상기 비일시적 컴퓨터 판독가능 기록 매체는,실행되는 경우, 상기 프로세서로 하여금,상기 제1 복수의 그룹들 및 상기 제2 복수의 그룹들의 모든 그룹들이 완전한 경우, 최종 결과를 생성하기 위해최종 중간 결과의 최종 누산을 실행하고,상기 최종 결과의 최종 포맷으로의 최종 변환을 실행하도록 하는 명령들을 더 포함하는, 비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "제40항에 있어서,상기 비일시적 컴퓨터 판독가능 기록 매체는,상기 최종 변환까지 오류가 발생하지 않는,공개특허 10-2023-0121151-11-비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "제40항에 있어서,상기 최종 포맷은,FP32 포맷, FP64 포맷, 및 FP128 포맷 중 하나로부터 선택되는,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_43", "content": "제35항에 있어서,상기 비일시적 컴퓨터 판독가능 기록 매체는,실행되는 경우, 상기 프로세서로 하여금,누산에 앞서서, 각각의 중간 결과를 트루포인트 포맷으로 변환하도록 하는 명령들을 더 포함하는,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_44", "content": "제35항에 있어서,상기 프로세서는,스트리밍 프로세서인,비일시적 컴퓨터 판독가능 기록 매체."}
{"patent_id": "10-2023-7025858", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "일 실시에에서, 곱셈기 회로망은 제1 포맷의 피연산자들을 곱한다. 하나 이상의 스토리지 레지스터 회로들은 제 1 포맷의 피연산자 및 또다른 피연산자에 대응하는 디지털 비트들을 저장한다. 분해 회로는 피연산자를 제1 복 수의 피연산자들로 분해하고, 그 밖의 피연산자를 제2 복수의 피연산자들로 분해한다. 각 곱셈기 회로는 복수의 부분 결과들의 대응하는 부분 결과를 생성하기 위해 제1 복수의 피연산자들의 각각의 제1 피연산자를 제2 복수의 피연산자들의 각각의 제2 피연산자와 곱한다. 누산기 회로는 누산기 회로에 저장되는 제2 포맷의 완전한 결과를 생성하기 위해 제2 포맷을 사용하여 복수의 부분 결과들을 누산한다. 변환 회로는 제2 포맷의 완전한 결과를 절 단하고 절단된 결과를 출력 포맷의 출력 결과로 변환한다."}
{"patent_id": "10-2023-7025858", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "아래 개시는 디지털 곱셈기 회로망의 수치 정밀도에 관한 것이다."}
{"patent_id": "10-2023-7025858", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "본 개시는 디지털 회로(digital circuits), 특히, 디지털 곱셈기 회로망(digital multiplier circuitry)의 수 치 정밀도를 위한 시스템 및 방법에 관한 것이다. 디지털 회로는 0과 1(즉, 비트(bits))로 표시되는(represented) 논리 신호(logic signals)를 처리한다. 디지 털 곱셈-누산기(multiply-accumulator)는 다수의 디지털 입력 값들(multiple digital input values)을 수신하 고(receiving), 입력 값들의 곱(product of the input values)을 결정하고(determining), 그 결과들을 더할 수 있는(summing the results) 전자 회로(electronic circuit)이다. 디지털 곱셈-누산 연산(digital multiply- accumulate operations)을 수행하는 것은 많은 문제들(a number of challenges)이 제기될(raise) 수 있다. 예 를 들어, 곱해지는 데이터 값들(data values)은 많은 서로 다른 데이터 유형들로(in a number of different data types) 디지털로(digitally) 표시될(represented) 수 있다. 그러나, 시스템이 처리하기 위해 필요한 모 든 서로 다른 데이터 유형들을 처리하기 위해(handle) 서로 다른 곱셈기들을 포함하는 것(including)은 회로 면 적(circuit area)이 소모되고(consume) 복잡도(complexity)가 증가(increase)할 수 있다.서로 다른 데이터 유형들의 디지털 곱셈이 특히(particularly) 유용한(useful) 하나의 특정 응용(one particular application)은, 기계 학습(machine learning)(인공지능(artificial intelligence)이라고도 함)이 다. 이러한 응용분야들은 곱셈-누산기에서 대량의 데이터 값들(large volumes of data values)을 수신할 수 있 다. 따라서, 이러한 시스템은 다양한 시스템 기능들(various system functions)을 이행하기 위해(carry out) 다수의 서로 다른 데이터 유형들을 처리할 수 있는 특히 빠르고(fast) 효율적인(efficient), 그리고/또는 정확 한(accurate) 곱셈-누산기가 요구될 수 있다. 본 개시의 실시예들은 디지털 다중모드 곱셈기(digital multimodal multiplier) 시스템 및 방법에 적용된다 (pertain to). 일 실시예에서, 본 개시는 복수의 다중모드 곱셈기 회로들을 포함하는 회로를 포함하며, 다중모 드 곱셈기 회로들은 하나 이상의 제1 피연산자들(first operands) 및 하나 이상의 제2 피연산자들(second operands)에 대응하는 디지털 비트들(digital bits)를 저장하는(storing) 하나 이상의 스토리지 레지스터 회로 들(storage register circuits)을 포함한다. 제1 모드에서, 하나 이상의 스토리지 회로들은 제1 데이터 유형 (first data type)을 가지는 하나의 제1 피연산자 및 하나의 제2 연산자를 저장한다. 제2 모드에서, 하나 이상 의 스토리지 레지스터 회로들은 제2 데이터 유형(second data type)을 가지는 제1 복수의 피연산자들(a first plurality of operands) 및 제2 복수의 피연산자들(a second plurality of operands)을 저장한다. 복수의 곱 셈기 회로들(plurality of multiplier circuits plurality of multiplier circuits)은 하나 이상의 제1 피연산 자들 및 하나 이상의 제2 피연산자들을 수신하도록 구성된다. 제1 모드에서, 하나의 제1 피연산자 및 하나의 제2 피연산자는 복수의 곱셈기 회로들의 하나 이상에서 곱해진다. 제2 모드에서, 제1 복수의 피연산자들의 제1 피연산자는 제2 복수의 피연산자들의 제1 피연산자와 곱해지고, 제1 복수의 피연산자들의 제2 피연산자는 제2 복수의 피연산자들의 제2 피연산자와 복수의 곱셈기 회로들에서 곱해진다. 일 실시예에서, 제1 피연산자들은 가중치(weights)이고 제2 피연산자들은 활성화 값들(activation values)이다. 일 실시예에서, 제1 데이터 유형(a first data type)을 가지는 하나의 제1 피연산자 및 하나의 제2 피연산자는 부동 소수점 값들(floating point values)을 포함하고, 제2 데이터 유형(a second data type)을 가지는 제1 복 수의 피연산자들 및 제2 복수의 피연산자들은 정수 값들(integer values)을 포함한다. 일 실시예에서, 복수의 곱셈기 회로들 중 적어도 하나는 제1 모드 및 제2 모드 모두에서 피연산자들을 곱하기 위해 사용된다. 또다른 실시예에서, 제1 모드에서 피연산자들을 곱하기 위해 사용되는 곱셈기 회로들의 수는 제2 모드에서 피연산자들을 곱하기 위해 사용되는 곱셈기 회로들의 수와 같다. 일 실시예에서, 제1 데이터 유형을 가지는 하나의 제1 피연산자 및 하나의 제2 피연산자는 제2 데이터 유형을 가지는 제1 복수의 피연산자들 및 제2 복수의 피연산자들 보다 더 많은 비트 수(a greater number of bits)를 포함한다. 일 실시예에서, 곱셈기 회로망(multiplier circuitry)은 제1 포맷(a first format)의 피연산자와 또다른 피연 산자를 곱하기 위해 사용된다. 곱셈기 회로망의 하나 이상의 스토리지 레지스터 회로들은 제1 포맷의 피연산자 및 제1 포맷의 또다른 피연산자(another operand)에 대응하는 디지털 비트들을 저장한다. 곱셈기 회로망의 분 해 회로(decomposing circuit)는 피연산자를 제1 복수의 피연산자들로 분해하고(decompose), 그 밖의 피연산자 (other operand)를 제2 복수의 피연산자들로 분해한다. 곱셈기 회로망은 복수의 곱셈기 회로들을 더 포함한다. 각 곱셈기 회로는 복수의 부분 결과들의 대응하는 부분 결과를 생성하기 위해 제1 복수의 피연산자들의 각각의 제1 피연산자와 제2 복수의 피연산자들의 각각의 제2 피연산자를 곱한다. 복수의 곱셈기 회로들과 결합된 (coupled) 누산기(accumulator)는 누산기 회로에 저장된 제2 포맷의 완전한 결과(complete result)를 생성하기 위하여 제2 포맷을 사용하여 복수의 부분 결과들(the plurality of partial results)을 누산한다 (accumulates). 변환 회로(conversion circuit)는 제2 포맷의 완전한 결과를 출력 포맷(output format)의 출 력 결과(output result)로 변환한다(converts). 또다른 실시예에서, 정수 곱셈(integer multiplication)을 위한 방법이 본 명세서에서 제시된다(presented). 방법은, 제1 포맷(format)의 피연산자(operand) 및 상기 제1 포맷의 또다른 피연산자(another operand)에 대응 하는 디지털 비트들들(digital bits)을 하나 이상의 스토리지 레지스터 회로들(storage register circuits)에 저장하는 동작(storing)과 피연산자와 다른 피연산자를 복수의 피연산자들로 분해하는 동작(decomposing)과 복 수의 부분 결과들(partial results) 중 대응하는 부분 결과를 생성하기 위해, 피연산자들의 제1 부분집합 (subset)의 각각의 제1 피연산자와 피연산자들의 제2 부분집합의 각각의 제2 피연산자를 곱하는 동작(multiplying)과 제2 포맷을 사용하여 누산기 회로에서 상기 복수의 부분 결과들을 누산함으로써 제2 포맷의 완 전한 결과를 생성하는 동작(generating)을 포함한다. 일 실시예에서, 제1 어레이(a first array) 및 제2 어레이(a second array)의 입력 피연산자들(input operands) 간의 요소별 연산(element-wise operations)을 수행하기(performing) 위한 방법이 본 명세서에서 제 시된다. 적어도 하나의 방법은, 입력 피연산자들의 지수들(exponents)을 복수의 지수 범위(exponent ranges)로 분류하는 동작(sorting)과 제1 어레이로부터 입력 피연산자들의 제1 부분집합을, 각각의 지수 범위를 각자 가지 는 제1 복수의 그룹들(a first plurality of groups)로 분류하는 동작과 제2 어레이로부터 입력 피연산자들의 제2 부분집합을, 각각의 지수 범위를 각자 가지는 제2 복수의 그룹들(a second plurality of groups)로 분류하 는 동작과 제1 그룹들에서 제1 정규화된 피연산자들(first normalized operands in the first groups)과 제2 그룹들에서 제2 정규화된 피연산자들(second normalized operands in the second groups)을 생성하기 위해, 제 1 복수의 그룹들 및 제2 복수의 그룹들의 각 그룹으로부터의 피연산자들을, 대응하는 지수 범위 내로 정규화하 는 동작(normalizing)과 제1 복수의 그룹들의 각 그룹 및 상기 제2 복수의 그룹들의 각 그룹의 각각의 중간 결 과(intermediate result)를 생성하기 위해, 제1 정규화된 피연산자들의 대응하는 부분집합 및 제2 정규화된 피 연산자들의 대응하는 부분집합에 요소별 연산(element-wise operations)을 실행하는 동작과 각각의 중간 결과들 과 복수의 중간 결과들의 이전에 획득된(previously obtained) 하나 이상의 중간 결과들의 누산을 실행하는 동 작을 포함한다. 일 실시예에서, 본 명세서에서 설명된 기술들(techniques)은 하드웨어 설명 언어 프로그램(hardware description language program)에 통합되고(incorporated), 하드웨어 설명 언어 프로그램은 실행될 때 디지털 회로를 발생시키는(produce) 명령들(instructions)의 세트(sets)를 포함한다. 하드웨어 설명 언어 프로그램은 컴퓨터 메모리(computer memory)(예: 데이터 스토리지 시스템(data storage system))와 같은 비일시적 컴퓨터 판독가능 기록 매체에 저장될 수 있다. 일부 그 밖의 실시예에서, 본 명세서에 설명되는 방법들의 동작들(operations of methods)은 컴퓨터 메모리(예: 데이터 스토리지 시스템)와 같은 비일시적 컴퓨터 판독가능 기록 매체에 저장된 명령어 세트에 따라 프로세서에 의해 실행된다. 다음의 상세한 설명(detailed description) 및 첨부된 도면들(accompanying drawings)은 본 개시의 특성 (nature) 및 장점들(advantages)을 보다 잘 이해할 수 있도록 한다."}
{"patent_id": "10-2023-7025858", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "뒤따르는 내용에서, 설명의 목적을 위해, 본 개시의 완전한 이해(thorough understanding)를 제공하기 위하여 수많은 예시들과 구체적인 세부사항들이 진술되어 있다(set forth). 이러한 예시들 및 세부사항들은 청구범위 의 요소 또는 청구범위 전체를 부당하게(unduly) 제한하는 것으로 해석되어서는 안 된다. 당업자에게는 서로 다른 청구항의 언어에 기초하여, 청구된 주제가 이들 예시들의 특징의 일부 또는 전부를 포함할 수 있으며, 본 명세서에 기재된 특징들 및 기술들의 동등한 수정(equivalent modifications)을 더 포함할 수 있음이 명백할 것 이다(evident). 수치 정밀도(numerical precision)는 인공지능(AI) 및 기계 학습(ML) 응용에 필수적이다(necessary). 그러나, 덧셈(addends)이 유효숫자(significand)에 의해 지원되는(supported) 범위(range)보다 작은 경우, 수치 정밀도 는 종종 희생된다(sacrificed). 예를 들어, 부동 소수점 16비트(FP16) 덧셈을 누적하기 위한 부동 소수점 32비 트(FP32)와 같은 높은 정밀도의 포맷(higher precision format)을 사용하여, 오류 누산(error accumulation)을 최소화하는 접근법(approaches)가 알려져 있지만, 이러한 접근법은 많은 수의 FP32 유효숫자 비트(예: 23비트) 가 요구된다. 정수 누산(integer accumulation)은 손실은 적지만(loss-less), 큰 레지스터들(large registers)이 요구되고, 계산(calculations)이 느려질 수 있다. 본 개시는 정수 포맷의 피연산자들(예: 8비트(INT8) 또는 4비트(INT4) 정수 포맷 피연산자들)을 사용하여, FP32 수치 표현(numerical representation)과 동등하거나 더 나은 수치 정밀도를 제공하는 컴퓨팅 시스템을 설명한다. 하나 이상의 실시예들에서, 본 명세서에서 제시되는 컴퓨팅 시스템은 피연산자들을 부동 소수점 포 맷에서 정수 포맷으로 변환하고, 복수의 부분 곱셈 결과들을 생성하기 위해, 복수의 정수 곱셈들을 수행하기 위 한 툼-쿡 분해 알고리즘(Toom-Cook decomposition algorithm)을 구현한다(implements). 부분 곱셈 결과들 (partial multiplication results)은 그런 다음, 적절한 거듭제곱(appropriate power)(즉, 1, 10, 100)으로 정 렬되도록(aligned) 시프트된다(shifted). 그 후, 부분 곱셈 결과들은 TruePoint쪠(TP) 수치 정밀도(즉, 고정 소수점 포맷 표현(fixed point format representation)을 사용하여 하나 이상의 누산 레지스터들(accumulation registers)에서 누산된다. 최종 곱셈 결과는 누적된 결과(accumulated result)를 원하는 수치 정밀도(예: FP32 수치 표현)로 반올림함으로써(rounding) 얻어진다(obtained). 본 개시의 실시예에 따르면, 텐서 스트리밍 프로세서(TSP)는 본 명세서에서 제시된 컴퓨터 시스템의 코어 프로 세서 모듈(core processor module)로 활용될(utilized) 수 있다. TSP는 특히, AI 및 ML 응용에 적합하다. TSP는 캘리포니아 마운틴뷰에 있는 Groq, Inc. 에서 상용 판매되는(commercially available) 장치이다. 상거 래에서의 사용에서, Groq TSP Node™ 가속기 카드(Accelerator Card)는 단일(single) Groq Chipl™ 장치를 호 스팅하는 x16 PCI-Express(PCle) 2-슬롯 확장 카드(slot expansion card)로 사용가능하다. 이제 도 1을 참조하면, 도 1은 일 예시적인 실시예에 따른 TSP 코어를 도시한다. TSP코어(AI 프로세 서 및/또는 ML 프로세서라고도 함)는 입력 데이터를 Al 및/또는 ML 응용을 위한(예: 훈련 또는 추론 (inference))가중치 세트(weight sets)(예: 훈련된(trained) 또는 훈련되는 중인(being trained))와 곱하고 더 하기 위해 최적화된 메모리 및 산술 모듈들(arithmetic modules)을 포함한다. 도 1에 나타낸 바와 같이, TSP 코어는 벡터에 대한 연산(즉, 값들의 1차원 어레이(one-dimensional arrays of values))을 수행하기 위한 벡터 프로세서(vector processor)(VXM)를 포함한다. TSP 코어의 그 밖의 요소들은 처리 속도 (processing speed)를 최적화하기 위해 VXM의 양쪽에(either side) 대칭적으로(symmetrically) 배열된다 (arranged). 도 1에 도시된 바와 같이, VXM은 메모리 모듈들(MEMs)(111,112)에 바로 인접한다(directly adjacent). 스위치 행렬 유닛(switch matrix units)(SXMs)(113 및 114)은 데이터의 라우팅(routing of data) 을 제어하기 위해 VXM의 양 측면에 배열된다. TSP 코어는 수치 변환 연산(numeric conversion operations)을 위한 수치 해석 모듈들(numerical interpretation modules)(NIM)(115 및 116)과 행렬 곱셈 (matrix multiplications)을 위한 행렬 곱셈 유닛(matrix multiplication units)(MXM)(117 및 118)을 더 포함 한다. 명령 제어 유닛(ICU)은 모든 기능 블록들(all functional blocks)(110 내지 118)에 걸쳐 데이터의 흐름(flow of data) 및 동작들의 실행(execution of operations)을 제어한다. TSP 코어는 칩-투-칩 (chip-to-chip)(C2C) 회로(123 및 124) 및 외부 통신 회로(external communication circuit)(예: PCIe)와 같은 통신 회로를 더 포함할 수 있다. TSP 코어는, 예를 들어, 부트 연산(boot operations), 클락 리셋 (clock resets), 일부 그 밖의 저레벨 설정 동작(some other low-level setup operations), 또는 이들의 일부 조합을 제어하기 위한 칩 제어 유닛(chip control unit)(CCU)을 더 포함할 수 있다.도 2a는 일 실시예에 따른 다중모드 곱셈기 회로를 도시한다. 도 2a의 다중모드 곱셈기 회로(multimodal multiplier circuit)는 도 1의 VXM, MXM 및/또는 MXM의 빌딩 블록(building block)일 수 있다. 본 개시의 특징 및 장점은 서로 다른 모드들에서 서로 다른 비트 수(different numbers of bits)의 서로 다른 데이터 유형들을 수신하고 처리할 수 있는 다중모드 곱셈기 회로를 포함하고, 예를 들어, 유리하게 (advantageously) 회로 면적을 감소시키고(reduce) 데이터 처리의 속도 및 효율을 개선(improve)할 수 있는 회 로망(circuitry)을 공유하는 것(share)이다. 예를 들어, 다중모드 곱셈기 회로는 곱해질 입력 피연산자들 을 표현하는(representing) 디지털 비트들을 저장하는 하나 이상의 입력 스토리지 레지스터 회로를 포함할 수 있다. 스토리지 레지스터 회로는 서로 다른 모드들에서 함께 곱해질 서로 다른 수의 피연산자들을 저 장할 수 있고, 피연산자들은 서로 다른 데이터 유형과 서로 다른 비트 수를 가질 수 있다. 스토리지 레지스터 회로는 복수의 플립 플롭들(flip flops) 또는 당업자에게 알려진 그 밖의 디지털 스토리지 회로(digital storage circuits)와 같은 디지털 비트들을 저장하는 회로이다. 예를 들어, 단일 스토리지 레지스터 회로는 서 로 다른 디지털 값들(예: 피연산자들)을 저장하기 위해 다수의 스토리지 레지스터들로 분할될(partitioned) 수 있다. 일 실시예에서, 제1 모드에서, 하나 이상의 스토리지 레지스터 회로는 제1 데이터 유형(a first data type)을 가지는 하나의 제1 연산자 및 하나의 제2 연산자를 저장하고, 제2 모드에서, 하나 이상의 스토리 지 레지스터 회로는 제2 데이터 유형(a second data type)을 가지는 제1 복수의 피연산자들 및 제2 복수의 피연 산자들을 저장한다. 복수의 곱셈기 회로는, 예를 들어, 하나 이상의 제1 피연산자들 및 하나 이상의 제2 피연산자들을 수신하도록 구성될 수 있다. 본 명세서에서 개시된 다양한 실시예들에 도시된 바와 같이, 곱셈기 들은 모드들 간에 공유될 수 있다. 예를 들어, 제1 모드에서, 제1 데이터 유형을 가지는 두개의 피연산자들이 하나 이상의 복수의 곱셈기 회로에서 곱해질 수 있다. 제2 모드에서, 제1 복수의 피연산자들 및 제2 복수 의 피연산자들은 복수의 곱셈기 회로에서 곱해진다. 제2 모드에서 곱해지는 제1 복수의 피연산자들 및 제 2 복수의 피연산자들은, 예를 들어, 제1 모드에서 곱해지는 제1 피연산자 및 제2 피연산자보다 더 적은 비트를 가질 수 있다. 그러나, 하나 이상의 곱셈기 회로들은 두 모드들 모두에서 사용될 수 있다. 예를 들어, 일 실 시예에서, 복수의 곱셈기 회로들 중 적어도 하나는 제1 모드 및 제2 모드 모두에서 피연산자들을 곱하기 위해 사용된다. 또다른 실시예에서, 제1 모드에서 피연산자들을 곱하기 위해 사용되는 곱셈기 회로들의 수는, 제2 모드에서 피연산자들을 곱하기 위해 사용되는 곱셈기 회로들의 수와 같다. 도 2a에 더 도시된 바와 같이, 일부 실시예들에서, 다중모드 곱셈기 회로는 다중모드 곱셈-누산기 회로를 형성하기 위해 조합될(combined) 수 있다. 예를 들어, 다중모드 회로의 출력은 서로 다른 데이터 유형들 또는 심지어 서로 다른 모드에서 서로 다른 출력 곱의 수(different numbers of output products)를 가지는 출 력 곱셈값들(output product values)을 포함할 수 있다. 복수의 그 밖의 다중모드 곱셈기들의 출력 곱은 다중모드 곱셈-누산기를 발생시키기 위해(produce) 다중모드 곱셈기의 출력 곱과 가산기에서 합산될 (summed) 수 있다. 추가적으로, 본 명세서에 개시된 그 밖의 실시예들에서, 입력 레지스터는 입력 값(예: 또다른 곱셈-누산기의 출력)을 수신할 수 있고, 가산기는, 예를 들어, 로컬로 생성된 곱(locally generated products)을 그 밖의 다중모드 곱셈 누산기들에서 생성된 합들과 합할 수 있다. 출력 레지스터는, 예를 들어, 합산된 결과(summed result)를 저장할 수 있고, 결과를 추가적인 곱셈-누산기 회로와 결합할 수 있 다. 이러한 다중모드 곱셈-누산기 회로의 어레이(array)는, 예를 들어, 서로 다른 데이터 유형들을 가지는 대 량의 피연산자들(large volumes of operands)을 처리하도록 구성될 수 있다. 본 개시의 실시예들은 특히, 예를 들어, 하나 이상의 제1 피연산자들은 가중치이고 하나 이상의 제2 피연산자들은 활성화 값들(activation values)인 기계 학습(인공지능이라고도 함) 디지털 처리 회로 응용에서 유리할(advantageous) 수 있다. 도 2b는 또다른 실시예에 따른 다중 모드 회로를 도시한다. 도 2b의 다중모드 곱셈기 회로는 도 1의 VXM, MXM 및/또는 MXM의 빌딩 블록일 수 있다. 이 예시에서, 스토리지 레지스터 회로는 하나 이상의 제1 피연산자들에 대응하는 디지털 비트들을 저장할 수 있다. 마찬가지로, 제2 스토리지 레지스터 회로는 하나 이상의 제2 피연산자들에 대응하는 디지털 비트들을 저장할 수 있다. 위에서 언급했듯이, 레지스터들(200 및 201)은, 예를 들어, 하나의 분할된 레지스터(one partitioned register) 또는 다수의 별개의 레지스터들 (multiple distinct registers)일 수 있다. 제1 모드에서, 제1 스토리지 레지스터 회로 및 제2 스토리지 레지스터 회로는 각각 제1 데이터 유형(예: OpA 및 Op, 각각)을 가지는 하나의 제1 피연산자 및 하나의 제 2 피연산자를 저장할 수 있고, 제2 모드에서, 제1 스토리지 레지스터 회로는 제1 복수의 피연산자들(예: Op1 및 Op2)를 저장하고, 제2 스토리지 레지스터 회로는 제2 데이터 유형을 가지는 제2 복수의 피연산자들 (예: Op3 및 Op4)를 저장한다. 일 실시예에서, 제1 데이터 유형을 가지는 피연산자들은, 예를 들어, 제2 데이터 유형을 가지는 피연산자들보다 더 큰 비트 수를 포함할 수 있다. 일 실시예에서, 제1 데이터 유형을 가지는 피연산자들은, 예를 들어, 부동 소수점 값들을 포함할 수 있고, 제2 데이터 유형을 가지는 피연산자들은, 예를 들어, 정수 값들을 포함할 수 있 다. 도 2a를 다시 참조하면, 제1 곱셈기 회로 및 제2 곱셈기 회로는 제1 스토리지 레지스터 회로 및 제2 스토리지 레지스터 회로과 결합된다. 제1 모드에서, 제1 스토리지 레지스터 회로의 하나의 제1 피연산자(예: OpA) 및 제2 스토리지 레지스터 회로의 하나의 제2 피연산자(예: OpB)는 제1 곱셈기 회로 에 결합된다. 제2 모드에서, 제1 스토리지 레지스터 회로의 제1 복수의 피연산자들의 제1 피연산자 (예: Op1 및 Op2 중 Op1) 및 제2 스토리지 레지스터 회로의 제2 복수의 피연산자들의 제1 피연산자(예: Op3 및 Op4 중 Op3)는 제1 곱셈기 회로에 결합되고, 제1 스토리지 레지스터 회로의 제1 복수의 피연 산자들의 제2 피연산자(예: Op1 및 Op2 중 Op2) 및 제2 스토리지 레지스터 회로의 제2 복수의 피연산자들 의 제2 피연산자(예: Op3 및 Op4 중 Op4)는 제2 곱셈기 회로에 결합된다. 이 예시에서, 선택 회로들 (select circuits)(예: 멀티플렉서(multiplexers))(202 및 203)은 입력 스토리지 레지스터들의 피연산자들을 모드 제어 신호(mode control signal)에 기초하여 특정한 곱셈기들(particular multipliers)에 결합하는 데에 사용될 수 있다. 예를 들어, 제1 모드에서, 선택 회로는 레지스터으로부터 OpA를 곱셈기의 하 나의 입력에 결합할 수 있고, 선택 회로는 레지스터으로부터 OpB를 곱셈기의 또다른 입력에 결 합할 수 있다. 제2 모드에서, 레지스터들(200 및 201)은 각 곱셈 처리 사이클(multiplication processing cycle)에서 각각 두 개의 필연산자들을 수신하고 저장할 수 있다. 따라서, 제2 모드에서, 선택 회로는 Op1을 곱셈기의 하나의 입력에 결합하고, Op2를 곱셈기의 하나의 입력에 결합한다. 마찬가지로, 제2 모드에서, 선택 회로는 Op3을 곱셈기의 또다른 입력에 결합하고, Op4를 곱셈기의 또다른 입력에 결합한다. 따라서, 일부 모드들에서, 데이터는, 예를 들어, 병렬로(in parallel) 곱해질 수 있고 곱셈기들은 다수의 모드들에서 공유될 수 있다. 위에서 언급했듯이, 제1 데이터 유형(예: 부동 소수점 값들)을 가지는 피연산자들은 제2 데이터 유형(예: 정 수)을 가지는 피연산자들보다 더 큰 비트 수를 가질 수 있다. 따라서, 곱셈기 회로는, 예를 들어, 곱셈기 회로보다 큰 비트 수를 가지는 입력들을 곱하도록 구성될 수 있다. 이 예시에서, 곱셈기로 들어가는 (entering) 제2 데이터 유형을 가지는 피연산자들은 곱셈기 회로의 확장된 비트 용량(extended bit capabilities)과 맞추기(match) 위해 부호 확장될(sign extended) 수 있다. 예를 들어, 다중모드 곱셈기 회로 는 제1 스토리지 레지스터 회로 및 제2 스토리지 레지스터 회로의 출력들과 결합되는 부호 확장 회로 (sign extension circuit)를 더 포함하여, 예를 들어, 제2 모드에서, 제1 스토리지 레지스터 회로의 제1 복수의 연산자들(예: Op1)의 하나 및 제2 스토리지 레지스터 회로의 제2 복수의 피연산자들(예: Op3) 의 하나를 수신할 수 있다. 부호 확장 회로(sign extension circuit)는, 예를 들어, 숫자의 부호(양 (positive)/음(negative))와 값을 보존하면서(preserving), 각 이진수(each binary number)(예: Op1 및 Op3)의 비트 수를 증가시킬 수 있다. 또다른 선택 회로는 모드 제어 신호를 수신하여 곱셈기의 입력들을 제 2 데이터 유형의 피연산자들을 수신하기 위한 부호 확장 회로의 출력들과 결합하거나, 대안적으로, 제1 데 이터 유형의 피연산자들을 수신하기 위해 선택 회로들(202 및 203)의 출력들과 결합한다. 위에서 언급했듯이, 일부 응용들에서 입력 레지스터들(200 및 201)과 결합된 피연산자들은 부동 소수점 숫자일 수 있다. 따라서, 다중모드 곱셈기 회로는 가산기 회로을 더 포함할 수 있다. 한 모드에서, 스토리지 레 지스터 회로 내의 한 피연산자(예: 부동 소수점 피연산자)의 지수 비트(exponent bits) 및 스토리지 레지 스터 회로 내의 제2 피연산자(예: 부동 소수점 피연산자)의 지수 비트는 가산기 회로에 결합된다(부 동 소수점이 사용되는 경우, 점선으로 지정됨(designated)). 부동 소수점 값들은 \"유효숫자 x베이스지수\"의 포 맷을 가질 수 있고, 예를 들어, 두 FP 피연산자들의 지수는 가산기에서 더해지고 FP 피연산자들의 유효숫 자들(가수(mantissa)라고도 함)은 곱셈기에서 곱해진다. 부동 소수점 숫자는, 예를 들어, 정수보다 더 많 은 비트를 사용하는 시스템에서 표현될 수 있고, 따라서 곱셈기는, 예를 들어, 제2 데이터 유형을 가지는 피연산자들만을 곱하는 곱셈기보다 더 많은 비트를 가질 수 있다. 아래에서 더 상세하게 설명되는 바와 같이, 곱셈기들(210 및 211) 및 가산기의 출력들은 더 처리되어 그 밖의 곱셈기 출력들에 더해질 수 있다. 본 명세서에서 설명되는 기술들의 하나의 응용 예시는 기계 학습 프로세서(인공지능 프로세서, 예: 신경망 (neural networks))이다. 이러한 프로세서들은 다량의(volumes of) 곱셈-누산 함수들이 필요할 수 있고, 부호 있는 정수(signed integer), 부호없는 정수(unsigned integer), 또는 부동 소수점(예: FP16 IEEE754)과 같은 다양한 서로 다른 데이터 유형들로 대표되는 입력 데이터를 유연하게 처리하기 위한 많은 응용들에서 바람직할 (desirable) 수 있다. 따럿, 일 실시예에서, 제1 피연산자는 가중치이고 제2 피연산자는 활성화 값이며, 본 명세서에 설명된 회로 및 방법은 기계학습 프로세서에서 구현된다. 예를 들어, 한 모드는 부동 소수점(FP) 숫자 를 곱하도록 기계학습 프로세서를 구성할 수 있다. 따라서, 가중치에 대응하는 제1 FP 피연산자는 레지스터 에 저장될 수 있고, 활성화(예: 입력 이미지의 픽셀 값(pixel value)에 대응하는 제2 FP 피연산자는 레지 스터에 저장될 수 있다. 도 2b에 나타낸 예시에서, 제1 FP 피연산자 및 제2 FP 피연산자의 유효숫자는, 예를 들어, 와이드 비트 포맷 곱셈기(wide bit format multiplier)에 결합되고, FP 피연산자들의 지수 비 트들은 출력 곱(예: OpA*OpB x expout_exp)을 발생시키기(produce) 위해 가산기에 결합된다. 제2 모드에서, 기계학습 프로세서는 정수를 곱할 수 있다. 제2 모드에서, 예를 들어, 두 8비트 정수는 각 레지스터들(200 및 201)에 저장될 수 있다. 보다 구체적으로, 두 개의 정수 가중치(integer weights)가 레지스터에 저장될 수 있고, 두 개의 정수 활성화(integer activations)가 레지스터에 저장될 수 있다. 하나의 활성화 및 하 나의 가중치는 부호 확장 회로에 결합되어 정수가 곱셈기의 더 넓은 포맷(wider format)과 맞추도록 하고, 예를 들어, 또다른 활성화 및 가중치는 곱셈기에 결합되어 병렬로 유리하게 곱해지도록 할 수 있다. 곱셈 기 및 곱셈기의 출력(예: Op1*Op3 및 Op2*Op4)은, 예를 들어, 아래에서 더 상세히 설명되는 바와 같 이, 그 밖의 곱셈기 출력들과 함께 더 결합될 수 있다. 활성화와 가중치는, 예를 들어, 도 2b에 도시된 기술들 을 사용하여 대안적으로 함께 곱해질 수도 있다. 도 2c는 또다른 실시예에 따른 다중모드 곱셈기 회로를 도시한다. 도 2c의 다중모드 곱셈기 회로(multimodal multiplier circuit)는 도 1의 VXM, MXM 및/또는 MXM의 빌딩 블록(building block)일 수 있다. 이 예시에서, 하나 이상의 피연산자들, A는 제1 스토리지 레지스터 회로에서 수신될 수 있고, 하나 이상의 제2 피연산자들, B는 제2 스토리지 레지스터 회로에서 수신될 수 있다. 복수의 곱셈기들(232 내지 235)은 하나 이상의 피연산자들을 수신하기 위해 레지스터들(230 및 231)의 특정 세그먼트(particular segments)에 결 합될 수 있다. 이 예시에서, 서로 다른 피연산자들, 또는 각 피연산자의 구성요소들은 곱셈기들(232 내지 23 5)이 효율적으로 공유될 수 있도록 모드에 기초하여 레지스터들(230 및 231)의 서로 다른 위치에 배치될 수 있 다. 예를 들어, 한 모드에서 A와 B는 모두 4개의 피연산자들 A0 내지 A3 및 B0 내지 B3(예: 총 8비트 정수)에 대응한다. 따라서, 피연산자들 A0 내지 A3은 각각 레지스터 세그먼트(230A 내지 230D)에 저장되고, 피연산자들 B0 내지 B3은 각각 레지스터 세그먼트(231A 내지 231D)에 저장된다. 곱셈기는 피연산자 A0 및 B0을 수신 하기 위해 레지스터의 세그먼트(230A)에 결합된 하나의 입력 및 레지스터의 세그먼트(231A)에 결합된 제2 입력을 가진다. 마찬가지로, 곱셈기는 피연산자 A1 및 B1을 수신하기 위해 세그먼트(230B)에 결합된 하나의 입력 및 세그먼트(231B)에 결합된 제2 입력을 가지고, 곱셈기는 피연산자 A2 및 B2을 수신하기 위 해 세그먼트(230C)에 결합된 하나의 입력 및 세그먼트(231C)에 결합된 제2 입력을 가지고, 곱셈기는 피연 산자 A3 및 B3을 수신하기 위해 세그먼트(230D)에 결합된 하나의 입력 및 세그먼트(231D)에 결합된 제2 입력을 가진다. 따라서, 한 모드에서, 곱셈기들(232 내지 235)은 8비트 정수 피연산자들의 두개의 세트들을 곱할 수 있다. 곱셈기들(232 내지 235)의 출력 곱셈 값들, C0=A0B0, C1=A1B1, C2=A2B2, 그리고 C3=A3B3는, 예를 들어, 모드들 중 하나에서 제1 출력(Out1)을 제공할 수 있는 레지스터에 저장될 수 있다. C0 내지 C3은 아래에 서 설명되는 것과 같은 그 밖의 다중모드 곱셈기 회로들의 출력 곱셈에 연결되고(concatenated) 더해질(added) 수 있다. 또다른 모드에서, 회로는 더 많은 비트 수의 서로 다른 데이터 유형을 가지는 피연산자들 A 및 B를 수신할 수 있다. 예를 들어, 피연산자들 A 및 B는 16비트의 부동 소수점 숫자들일 수 있다. 따라서, 이러한 피연산자들 은 레지스터들(230 내지 231)의 서로 다른 레지스터 세그먼트들의 구성요소로서 저장될 수 있다. 예를 들어, 하나의 피연산자 A는 레지스터의 두 개의 레지스터 세그먼트의 두 개의 구성요소들로서 저장될 수 있고, 또다른 피연산자 B는 레지스터의 두 개의 레지스터 세그먼트의 두 개의 구성요소들로서 저장될 수 있다. 일 실시예에서, 피연산자 A는 A0에서 수신되고 레지스터 세그먼트(230A)에 저장되는 제1 구성요소(예: 저차 비 트(lower order bits)) 및 A2에서 수신되고 레지스터 세그먼트(230C)에 저장되는 제2 구성요소(예: 고차 비트 (higher order bits))를 포함할 수 있다. 피연산자 B는, 예를 들어, B0에서 수신되고 레지스터 세그먼트(231 A)에 저장되는 제1 구성요소(예: 저차 비트(lower order bits)) 및 B1에서 수신되고 레지스터 세그먼트(231B)에 저장되는 제2 구성요소(예: 고차 비트(higher order bits))를 포함할 수 있다. 본 개시의 실시예들은 서로 다 른 모드들에서 선택적으로 서로 다른 입력 비트들을 서로 다른 레지스터 세그먼트들로 결합할 수 있다. 예를 들어, 이 모드에서, 입력 A0에서의 A의 제1 구성요소는 레지스터 세그먼트(230B)에 결합되고 저장될 수 있고, 입력 A2에서의 A의 제2 구성요소는 레지스터 세그먼트(230D)에 결합되고 저장될 수 있다. 마찬가지로, 입력 B0 에서의 B의 제1 구성요소는 레지스터 세그먼트(230C)에 결합되고 저장될 수 있고, 입력 B1에서의 B의 제2 구성 요소는 레지스터 세그먼트(231D)에 결합되고 저장될 수 있다. 서로 다른 모드들을 위한 서로 다른 레지스터 세 그먼트들에서의 입력들의 선택적인 배열(selective arrangement)은 선택 회로들(예: 멀티플렉서들)(250 내지253)을 사용하여 도 2c에 도시되어 있다. 따라서, 이 모드에서, 곱셈기는 피연산자 A의 제1 구성요소(A0 에서의) 및 피연산자 B의 제1 구성요소(B0에서의)를 수신하고, 곱셈기는 피연산자 A의 제1 구성요소(A0에 서의) 및 피연산자 B의 제1 구성요소(B0에서의)를 수신하고, 곱셈기는 피연산자 A의 제2 구성요소(A2에서 의) 및 피연산자 B의 제1 구성요소(B0에서의)를 수신하고, 곱셈기는 피연산자 A의 제1 구성요소(A2에서의) 및 피연산자 B의 제1 구성요소(B1에서의)를 수신한다. 즉, 곱셈기들(232 내지 235)은 다음과 같은 A0B0, A0B1, 및 A2B1 곱셈을 수행하고, A0이 A의 저차(최하위(less significant)) 비트이고, A2는 A의 고차(최상위(more significant)) 비트이고, B0이 B의 저차(최하위(less significant)) 비트이고, B1는 B의 고차(최상위(more significant)) 비트이다. 입력들의 구성요소들의 출력 곱셈 값들 C0 내지 C3은, 예를 들어, 레지스터에 저장될 수 있다. 이 모드에 서, 곱셈기들(232 내지 235)의 출력들은 시프트 회로들(240 내지 243)에 결합될 수 있다. 시프트 회로들(240 내지 243)의 출력들은 입력들의 출력 곱 A*B을 발생시키기 위해 가산기 회로에 결합될 수 있다. 예를 들어, C0 은 0의 정상 시프트 값(normal shift value)을 가질 수 있는 시프트 회로에 결합될 수 있고, C1은 N(N은 입력 구성요소의 비트 수이다. 예를 들어, 각 곱셈기의 8비트 구성요소인 경우, N=8임) 정상 시프트 값(normal shift value)을 가질 수 있는 시프트 회로에 결합될 수 있고, C2는 N의 정상 시프트 값(normal shift value)을 가질 수 있는 시프트 회로에 결합될 수 있고, C3은 2N의 정상 시프트 값(normal shift value)을 가질 수 있는 시프트 회로에 결합될 수 있다. 예를 들어, 각 시프트 회로는 왼쪽 시프트(left shift)를 수행할 수 있다. 따라서, 이 예시에서, 저차 비트의 곱 A0B0은 시프트되지 않고, 고차 비트와 저차 비트의 곱 인 A2B0와 B1A0은 N씩 시프트되고, 고차 비트들의 곱인 A2B1은 2N씩 시프트된다. 위와 같이, 일부 실시예들에 서, C0은 시프트되지 않을 수 있기 때문에 시프터(shifter)가 포함되지 않을 수 있다. 그러나, 일 실시예 에서, 부동 소수점 피연산자들의 지수 비트들, expA, expB는 가산기 회로에 입력되어 함께 더해질 수 있고, 그 결과는 각 시프트 회로에 의해 수행되는 시프트를 증가시키는 데에 사용된다. 예를 들어, 가산기 회 로의 출력은 각 시프트 회로(240 내지 243)의 제어 입력에 결합되어, 지수 비트(expA 및 expB)의 합이 각 시프트 회로의 시프트를 증가시킬 수 있다(예: expA=1; expB=2; 각 시프트를 3씩 증가시킨다). 시프트 회로들 의 출력들은 가산기 회로에서 합해지는데(summed), 가산기 회로는, 예를 들어, 복수의 N-비트 가산기 들로 구성될 수 있다. 시프트되고(shifted) 더해진(added) 출력 곱셈 값들은 모드 중 하나에서 제2 출력(Out 2)을 제공할 수 있으며, 이는, 예를 들어, 고정 소수점 표현(fixed point representation)일 수 있다. 따라서, 일부 실시예들에서, 입력들의 곱셈(multiplication)은 출력 곱들(output products)이 제3 데이터 타입 으로 변환될 수 있으며, 이는 아래에서 설명되는 바와 같이, 다른 다중모드 곱셈기 회로의 출력 곱에 더해질 수 있다. 도 3은 또다른 실시예에 따른 다중모드 곱셈기 회로를 도시한다. 도 3의 다중모드 곱셈기 회로(multimodal multiplier circuit)는 도 1의 VXM, MXM 및/또는 MXM의 빌딩 블록(building block)일 수 있다. 본 개시의 일부 실시예는 한 모드에서 충분히 긴 비트 길이를 포함해서, 피연산자들을 높은 정밀도로 수신하고 처리할 수 있어서, 또다른 모드에서인 경우, 다수의 저차 비트 길이 피연산자들은 복수의 병렬 곱셈기들에서 처 리될 수 있다. 이 예시에서, 레지스터들(300 및 301) 및 곱셈기는 한 모드에서 제1 데이터 유형(예: 부동 소수점(float))의 피연산자들을 처리할 수 있고, 시스템의 비트 표현들(bit representations)의 차 (difference)는 또다른 모드에서 제2 데이터 유형(예: 정수(integer))을 가지는 N(N은 정수, 예: N=4)개의 피 연산자들을 처리할 수 있다. 곱셈기는 각 레지스터(300 및 301)로부터 하나의 피연산자를 처리할 수 있고, 곱셈기(310 및 311)는 각 레지스터들(300 및 301)의 두 개의 피연산자들을 제2 모드에서 결합할 수 있다. 또한, 도 3에 나타낸 다중모드 곱셈기 회로는 두 개의 추가적인 피연산자들(Op5, Op6)에 대응하는 디지털 비트 들들을 저장하기 위한 제3 스토리지 레지스터 회로 및 두 개의 추가적인 피연산자들(Op7, Op8)에 대응하는 디지털 비트들들을 저장하기 위한 제4 스토리지 레지스터 회로를 더 포함할 수 있고, Op5 내지 Op8은 제1 데이터 유형(예: INT8 v. FP16)보다 더 적은 비트의 제2 데이터 유형을 가진다. 일 실시예에서, 레지스터(30 2)는 가중치 값들을 저장하고, 레지스터는 활성화 값들을 저장한다. 도 3의 회로는 곱셈기들(312 및 313)을 더 포함할 수 있다. 선택 회로들(322 및 323)은 레지스터들(302 및 303)의 피연산자들을 곱셈기 회로들(312 및 313)에 결합한다. 예를 들어, 곱셈기 회로는 스토리지 레지스 터 회로(302 및 303)에 결합되어 스토리지 레지스터 회로로부터 피연산자(예: Op5)를 수신하고 스토리지 레지스터 회로로부터 또다른 피연산자(예: Op7)를 수신할 수 있다. 마찬가지로, 곱셈기 회로는 스토 리지 레지스터 회로로부터 피연산자(예: Op6)를 수신하고 스토리지 레지스터 회로로부터 또다른 피연 산자(예: Op8)를 수신하기 위해 스토리지 레지스터 회로(302 및 303)에 결합될 수 있다. 기계 학습 응용에서, Op들 Op5 내지 Op6은 가중치들이고, Op7 내지 Op8은 활성화 값들이다. 따라서, 각 곱셈기의 출력은 활성화에가중치를 곱한 값이다. 유리하게도, 제2 모드에서 4개의 곱셈이 병렬로 수행될 수 있다. 제2 모드에서, 각 곱 셈기(310 내지 313)의 출력들은 가산기에 결합될 수 있으며, 이는, 예를 들어, 합산(sum)(또는 누산 (accumulate))될 수 있다. 최종 출력(final output)은 출력 레지스터에 저장될 수 있다. 일 실시예에서, 곱셈 기들(310 내지 313)로부터의 출력들의 곱들은, 예를 들어, 입력 레지스터의 대응하는 값들에 더해진다. 아래에서 더 설명되는 바와 같이, 일부 실시예들은, 예를 들어, 곱셈기들의 열(column of multipliers)(미도 시)을 따라 활성화 및 가중치(x*wt)의 곱들을 누산할 수 있다. 따라서, 이 예시에서, 입력 레지스터는 4 개의 정수들의 값들(Al, A2, A3, A4)을 저장할 수 있고, 이는 곱셈기들(310 내지 313)로부터의 4개의 대응하는 출력 곱들(R1, R2, R3, R4)에 더해진다. 그 결과는 출력 레지스터에 대응하는 4개의 출력 값들(A1+R1, A2+R2, A3+R3, A4+R4)이며, 이는, 예를 들어, 곱셈기들의 또다른 그룹의 입력 레지스터에 결합될 수 있다. 아래에서 더 상세하게 설명되는 바와 같이, 곱셈기의 일부 실시예들은 제1 모드에서, 부동 소수점 값들을 발생시킬 수 있고, 이는 그런 다음 고정 소수점(fixed point)과 같은, 넓은 동적 범위(wide dynamic range)와 정확도(accuracy)를 달성하기 위한(achieve) 확장된 비트 길이를 가지는, 제3 데이터 유형으로 변환된다. 일 실시예에서, 고정 소수점 값(fixed point value)은 제2 데이터 유형(예: 8비트 정수)을 가지는 피연산자들(예: Op4*Op2, Op5*Op7, Op6*Op8)의 곱들에 의해 발생되는 비트 수의 적어도 N(예: N=4)배와 동등한(equivalent) 비 트 수를 포함할 수 있다. 따라서, 같은 가산기 및 출력 레지스터는, 예를 들어, 하나의 확장된 길이 의 데이터 유형(one extended length data type) 또는 다수의 정수 데이터 유형들(multiple integer data types)을, 저장하기 위해 사용될 수 있고, 예를 들어, 이는 감소된 회로 면적을 포함하는 이점들을 가진다. 도 4는 또다른 실시예에 따른 다중모드 곱셈기 회로를 도시한다. 도 4의 다중모드 곱셈기 회로(multimodal multiplier circuit)는 도 1의 VXM, MXM 및/또는 MXM의 빌딩 블록(building block)일 수 있다. 이 예시에서, 곱셈기의 출력은 선택 회로에 결합된다. 제1 모드에서, 곱셈기의 출력 곱과 가산 기로부터의 합산된 지수들은 비정규화 회로(denormalizer circuit)에 결합될 수 있다. 예를 들어, 제1 모드에서, 비정규화 회로는 곱셈기 회로로부터 부동 소수점 곱과 가산기 회로로부터의 합산 된 지수들을 수신할 수 있고, 고정 소수점 값을 발생시킬 수 있다. 예를 들어, 고정 소수점 값은 동적 범위 (dynamic range) 및 정밀도(precision)를 유리하게 최적화하는 데 사용될 수 있다. 일 실시예에서, 고정 소수 점 값은 제2 데이터 유형을 가지는 피연산자들의 곱들에 의해 발생되는 비트 수의 적어도 N 배와 동등한 비트 수를 포함한다. 따라서, 레지스터들 및 가산기들은 제1 모드에서 하나의 확장된 고정 소수점 숫자들을 처리하 고, 제2 모드에서 제2 데이터 타입의 N개의(예: 도 3에서 N=4로 도시됨) 출력 곱 결과들을 처리하도록 구성된다. 예를 들어, 일 구현(implementation)에서, 숫자의 고정 소수점 표현은, 제1 모드에서, 확장된 비트 길이(예: 90 내지 100 비트)를 가질 수 있다. 제2 모드에서, 곱셈기의 제1 출력 곱은 그 밖의 곱셈기들 (예: 위에서 언급한, 곱셈기 또는 곱셈기들(311 내지 313))보다 더 큰 제1 비트 길이를 가진다. 따라서, 하나 이상의 곱셈기들의 출력 곱들은 부호 확장될(sign extended) 수 있고(예: 450에서), 제2 모드에서, 출력 곱들의 비트 길이가 동일하도록 할 수 있다. 복수의 곱셈기들의 출력 곱들의 최종 비트 길이는, 제2 모드에서, 예를 들어, 제1 모드에서의 비정규화 회로로부터의 고정 소수점 숫자의 비트 길이와 실질적으로 (substantially) 동일할 수 있다. 이 예시에서, 제1 모드와 제2 모드 간에 비트 수를 균등화하는 것(equalizing)은, 예를 들어, 연결 회로 (concatenation circuit)를 사용하여 곱셈기 출력들을 연결하는 것을 포함할 수 있다. 따라서, 제2 모드 에서, 선택 회로는 곱셈기의 출력을 연결 회로의 하나의 입력에 결합하고, 연결 회로의 그 밖의 입력은, 예를 들어, 도 4에 나타낸 곱셈기 회로와 같은 그 밖의 곱셈기 회로들의 출력들에 결합될 수 있다. 또한, 일부 실시예들에서, 예를 들어, 아래에 설명된 더하기(addition) 중에 개별 값들(individual values)을 분리하기(isolate) 위해 제2 모드에서 연결된 값들(concatenated values) 사이에 추가 패딩 비트 (additional padding bits)가 더해질 수 있다. 도 3에 도시된 바와 같이, 그 밖의 예시적인 실시예들은 제2 데이터 유형을 가지고 제2 모드 동안 수신되는 추 가적인 피연산자들을 위한 더 많은 병렬 곱셈 경로들(more parallel multiplication paths)을 포함하기 위해 확장될 수 있다. 예를 들어, Int8 값의 4개의 곱셈을 함께 곱하고, 연결하고, 더하고, 출력 레지스터에 저장할 수 있다. 도 4를 다시 참조하면, 실질적으로 동일한 비트 수를 가질 수 있는 연결 회로 및 비정규화 회로의 출 력은 가산기에 선택적으로 결합된다. 가산기는 또한 입력 레지스터로부터 디지털 값을 수신하 도록 구성될 수 있는데, 예를 들어, 하나 이상의 그 밖의 다중모드 곱셈기 유닛들(one or more other multimodal multiplier units)을 사용하여 발생되는 값일 수 있다. 제1 모드에서, 입력 레지스터는 확장된 길이의 고정 소수점 숫자를 포함하고, 제2 모드에서, 입력 레지스터는 연결 회로에 의해 수신된 값들의 동일한 숫자를 포함할 수 있다(예: 4개의 8비트 정수). 따라서, 가산기는, 제1 모드에서, 둘 이상 의 고정 소수점 숫자들 또는, 제2 모드에서, 제2 포맷의 값들의 다수의 어레이들을 수신하고 합산할 수 있다. 결과들은 레지스터에 저장된다. 도 4의 예시에서, 예를 들어, 출력 레지스터은 하나의 고정 소수점 숫자 또는 두 개의 숫자를 저장할 수 있다. 도 5는 또다른 실시예에 따른 다중모드 곱셈-누산기 회로를 도시한다. 도 5의 다중모드 곱셈-누산기 회로 (multimodal multiply-accumulator circuit)는 도 1의 VXM, MXM 및/또는 MXM의 빌딩 블록 (building block)일 수 있다. 이 예시에서, 복수의 다중모드 곱셈기들은 병렬로 구성되고, 곱셈기들의 출력들 은 곱셈-누산기를 형성하기 위해 가산기 회로의 입력들과 결합된다. 더하여, 곱셈-누산기 회로들의 그룹들 (groups of multiply-accumulator circuits)은 직렬로(in series) 구성될 수 있다. 예를 들어, 다중모드 곱셈 기 회로들(510A 내지 510N)은 입력 피연산자들을 제1 데이터 유형 또는 제2 데이터 유형으로 수신할 수 있고, 입력들의 서로 다른 유형들을 처리하기 위한 곱셈기 회로들을 구성하기 위한 모드 제어 신호(\"모드\")를 수신할 수 있다. 각 다중모드 곱셈기 회로(510A 내지 510N)는 제1 모드에서 제1 데이터 유형(예: FP16)을 가지는 피연 산자들의 쌍을 수신할 수 있다. 대안적으로, 각 다중모드 곱셈기 회로(510A 내지 510N)는 제2 모드에서 제2 데 이터 유형(예: INT8)을 가지는 피연산자들의 복수의 쌍들을 수신할 수 있다. 피연산자들의 쌍들은, 예를 들어, 신경망의 활성화 값들 및 가중치일 수 있고, 도 5의 회로는 기계학습 데이터 처리 회로에 포함될 수 있다. 각 다중모드 곱셈기(510A 내지 510N)의 출력들은 가산기에 결합될 수 있고, 예를 들어, 도 3의 가산기 또는 도 4의 가산기에 대응할 수 있다(일부 실시예들에서). 제1 모드에서, 가산기는 제3 데이 터 유형(예: 고정 소수점)을 가지는 값들을 합산하고, 각 다중모드 곱셈기(510A 내지 510N)는 입력 피연산자들 의 곱을 제1 데이터 유형(예: 부동 소수점(float))에서 제3 데이터 유형(예: 확장된 길이 고정 소수점(extended length fixed point))으로 위에서 언급한 바와 같이 변환한다. 제2 모드에서, 가산기는 제2 데이터 유형 (예: 정수)을 가지는 값들을 합산한다. 일 실시예에서, 각 다중모드 곱셈기(510A 내지 510N)의 특정 곱셈기로 부터의 곱셈 값들은 대응하는 곱셈기들로부터의 곱셈 값들에 더해진다. 예를 들어, 도 3을 참조하면, 하나의 다중모드 곱셈기(510A)의 곱셈기로부터의 곱은 그 밖의 다중모드 곱셈기들(510B 내지 510N)의 곱셈기(31 1)로부터의 곱에 더해지고, 하나의 다중모드 곱셈기(510A)의 곱셈기로부터의 곱은 그 밖의 다중모드 곱셈 기들(510B 내지 510N)의 곱셈기로부터의 곱에 더해진다. 따라서, 곱셈기 회로들의 어레이의 곱셈기들의 열들로부터의 결과들은 독립적으로(예: 값들의 어레이들로서) 조합될 수 있다. 가산기의 출력들은 출력 레지스터 회로에 저장되고, 이는, 예를 들어, 제1 모드에서 제3 데이터 유형의 단일 출력 값을 저장하며, 예를 들어, 제2 모드에서 제2 데이터 유형을 가지는 다수의 출력 값들을 저장한다. 일부 실시예들에서, 각의 곱셈-누산기 회로(500 내지 502)는 또다른 다중모드 곱셈-누산기 회로의 출력 레지스터 회로에 결합된 입력을 가지는 입력 레지스터 회로를 포함할 수 있다. 예를 들어, 곱셈 누산기 회로는 입력 레지스터를 포 함할 수 있고, 이는, 예를 들어, 시스템이 동작중인 모드에 기초하여 곱셈-누산기로부터의 하나 이상의 합 을 수신하도록 구성된다. 따라서, 곱셈-누산기 회로들(500 및 501)이 제1 모드인 경우, 입력 레지스터는 제3 데이터 유형(예: 확장된 고정 값)을 가질 수 있는 단일 입력 값을 수신하고 저장하며, 곱셈-누산기 회로들 (500 및 501)이 제2 모드인 경우, 입력 레지스터는 제2 데이터 유형(예: 4개의 정수 값들)을 가지는 복수 의 입력 값들을 수신하고 저장한다. 레지스터의 출력은 가산기 회로에 결합될 수 있다. 따라서, 제1 모드에서, 복수의 값들, 각 다중모 드 곱셈기(510A 내지 510N)으로부터의 하나는 함께 더해지고 레지스터의 단일 입력 값에 더 더해질 수 있 다. 대안적으로, 제2 모드에서, 각 다중모드 곱셈기(510A 내지 510N)으로부터의 다수의 값들과 입력 레지스터 로부터의 다수의 값들은 더해지고, 특정 열들(columns)에 대응하는 값들은 특정 열들에 대응하는 그 밖의 값들에 더해진다. 예를 들어, 입력 레지스터에 4개의 값들이 있고, 제2 모드에서 각각의 다중모드 곱셈기 (510A 내지 510N)에 4개의 곱셈기들이 사용되는 경우, 레지스터의 4개의 값 중 첫 번째 값은 곱셈기(510A 내지 510N) 각각에서 N 곱셈기들(도 3 참조)의 값과 더해질 수 있고, 레지스터의 4개의 값 중 두 번 째 값은 곱셈기(510A 내지 510N) 각각에서 곱셈기들(도 3 참조)의 값과 더해지는 식으로, 출력 레지스터 에는 4개의 합산된 출력 값들의 결과를 낳을 수 있다. 출력 레지스터 회로의 출력은 다중모드 곱셈- 누산기 회로에 결합되고, 유사한 프로세스는, 예를 들어, 반복될(repeated) 수 있다. 도 6은 실시예에 따른 다중모드 곱셈을 위한 방법을 도시한다. 동작 601에서, 하나 이상의 제1 피연산자들에 해당하는 디지털 비트들이 제1 스토리지 레지스터 회로에 저장된다. 동작 602에서, 하나 이상의 제2 피연산자 들에 해당하는 디지털 비트들이 제2 스토리지 레지스터 회로에 저장된다. 제1 모드에서, 제1 스토리지 레지스터 회로 및 제2 스토리지 레지스터 회로는 제1 데이터 유형을 가지는 제1 피연산자 및 제2 피연산자를 저장할 수 있다. 제2 모드에서, 제1 스토리지 레지스터 회로 및 제2 스토리지 레지스터 회로는 제2 데이터 유형을 가 지는 제1 복수의 피연산자들 및 제2 복수의 피연산자를 저장할 수 있다. 동작 603에서, 제1 모드에서, 제1 스 토리지 레지스터 회로 내의 하나의 제1 피연산자 및 제2 스토리지 레지스터 회로 내의 하나의 제2 피연산자는 제1 스토리지 레지스터 회로 및 제2 스토리지 레지스터 회로에 결합된 제1 곱셈기 회로에서 곱해진다. 동작 604에서, 제2 모드에서, 제1 스토리지 레지스터 회로 내의 복수의 제1 피연산자들 중 하나와 제2 스토리지 레지 스터 회로 내의 복수의 제2 피연산자들 중 하나는 제1 곱셈기 회로를 사용하여 곱해진다. 또한, 또다른 제1 스 토리지 레지스터 회로 내의 복수의 제1 피연산자들 중 하나 및 제2 스토리지 레지스터 회로 내의 복수의 제2 피 연산자들 중 하나는 제2 곱셈기 회로를 사용하여 곱해진다. 일부 실시예들에서, TSP 코어를 기반으로 하는, 컴퓨터 시스템과 같은 디지털 시스템은, 부동 소수점 포맷 이나 정수 포맷을 활용하여(utilize) 산술 계산(arithmetic calculations) (예: 곱셈(multiplication) 및 더하 기(addition))이 정수 포맷으로 수행되는 동안 입력 피연산자들의 표현을 압축된 포맷(compressed format)으로 저장한다. 보다 구체적으로, TP 포맷은 FP16 곱의 누산을 고정 소수점 수치로 표현한 것으로, 행렬 곱셈 루프 (matrix multiplication loop)에서 더 높은 정밀도의 계산의 필요를 피할 수(avoid) 있다. TP 포맷은 더 높은 정밀도의 FP 수치 표현(예: FP64 수치 정밀도)과 비교할만한(comparable) 정확도를 가지는 누산 결과에 대한 고 정 소수점 수치 표현을 표현한다. MXM 117 및/또는 MXM 118의 출력에서 곱의 합(sum of products)은 TP 포맷 (즉, 고정 소수점 손실이 적은 정수 표현)에서 예를 들어, 23비트의 유효숫자만 있는 FP32 수치 표현으로 변환 된다. 도 7은 실시예에 따른 부분 곱셈 결과의 누산에 기초한 TP 포맷의 곱셈기 회로(multiplier circuity)를 도시한 다. 도 7의 곱셈기 회로는 VXM, MXM 및/또는 MXM의 빌딩 블록(building block)일 수 있다. 일부 실시예들에서, 도 7의 곱셈기 회로는 예를 들어, MXM 및/또는 MXM와 같은 곱셈기들의 어레이의 구성요소이다. 하나 이상의 스토리지 레지스터 회로(700 및 701)는 제1 포맷의 피연산자 및 제1 포맷의 또다른 피연산자에 대응하는 디지털 비트들을 저장한다. 제1 포맷은 INT4 포맷, INT8 포맷, INT16 포맷, FP16 포맷(예: IEEE 754 표준에 따름) 및 FP32 포맷(예: IEEE 754 표준에 따름) 또는 일부 그 밖의 수치 표현 포맷이 다. 변환 회로들(702 및 703)은 피연산자 및 그 밖의 피연산자의 분해에 앞서서 피연산자와 그 밖의 피연산자 를 부동 소수점 포맷으로부터 정수 포맷으로 변환할 수 있다. 변환 회로들(702 및 703)은 피연산자의 제1 포맷 이 부동 소수점 포맷이고 그 밖의 피연산자가 정수 포맷인 경우, 예를 들어, 모드 신호(mode signal)에 기초하 여 바이패스될(bypassed) 수 있다. 모드 신호는 제1 포맷이 정수 포맷(예: INT4, INTS, INT16) 일 때 제1 값 (예: \"0\")을 가지는 비트 신호이고, 제1 포맷이 부동 소수점 포맷(예: FP16, FP32) 일 때 제2 값(예: \"1\")을 가 지는 비트 신호이다. 분해 회로는 피연산자를 제1 복수의 피연산자들(예: 더 작은 정수 숫자들)로 분해한다. 분해 회로는 그 밖의 피연산자를 제2 복수의 피연산자들(예: 더 작은 정수 숫자들)로 분해한다. 분해 회로는 예를 들 어, 툼-쿡 분해 알고리즘(Toom-Cook decomposition algorithm)을 적용하여 피연산자 및 그 밖의 피연산자를 분 해할 수 있다. 툼-쿡 분해 알고리즘에 대한 세부사항들은 아래에 더 제공된다. 제1 복수의 곱셈기들(706A, ..., 706N) 및 제2 복수의 곱셈기들(708A, ..., 708N)은 정수 곱셈기들이다. 제1 포맷이 정수 포맷인 경우, 제1 복수의 피연산자들의 각 피연산자는 분해 회로로부터 제1 복수의 곱셈기들 (706A, ..., 706N)의 각 곱셈기뿐만 아니라 제2 복수의 곱셈기들(708A, ..., 708M)의 각 곱셈기로 라우팅된다 (routed). 마찬가지로, 제2 복수의 피연산자들의 각 피연산자는 분해 회로로부터 제1 복수의 곱셈기들 (706A, ..., 706N)의 각 곱셈기뿐만 아니라 제2 복수의 곱셈기들(708A, ..., 708M)의 각 곱셈기로 라우팅된다 (routed). 제1 복수의 피연산자들 및 제2 복수의 피연산자들로부터의 각 피연산자들의 쌍은 제1 복수의 곱셈기 들 및 제2 복수의 곱셈기들(706A, ..., 706N, 708A, ..., 708M)의 대응하는 곱셈기에서 상호적으로(mutually) 곱해져서 복수의 부분 결과들 중 대응하는 부분 결과를 생성한다. 곱셈기들(706A, ..., 706N, 708A, ..., 708M)에 의해 생성된 부분 결과들은 대응하는 레지스터들(709A, ..., 709N, 710A, ..., 710M)에 저장된다. 제1 포맷이 부동 소수점 포맷인 경우, 제1 복수의 피연산자들의 각 피연산자로부터의 유효숫자 부분 (significand portion)은 분해 회로로부터 제1 복수의 곱셈기들(706A, ..., 706N)의 각 곱셈기뿐만 아니 라 제2 복수의 곱셈기들(708A, ..., 708M)의 각 곱셈기로 라우팅된다(routed). 마찬가지로, 제2 복수의 피연산 자들의 각 피연산자로부터의 유효숫자 부분(significand portion)은 분해 회로로부터 제1 복수의 곱셈기들 (706A, ..., 706N)의 각 곱셈기뿐만 아니라 제2 복수의 곱셈기들(708A, ..., 708M)의 각 곱셈기로 라우팅된다 (routed). 제1 복수의 피연산자들 및 제2 복수의 피연산자들로부터의 유효숫자 부분들의 각 쌍은 제1 복수의곱셈기들 및 제2 복수의 곱셈기들(706A, ..., 706N, 708A, ..., 708M) 중 대응하는 곱셈기에서 상호적으로 곱해 져 대응하는 레지스터(709A, ..., 709N, 710A, ..., 710M)에 저장되는 대응하는 부분 결과를 생성한다. 또한, 제1 복수의 피연산자들의 각 피연산자로부터의 지수 부분은 분해 회로로부터 제1 복수의 가산기들(705A, ..., 705N)의 각 가산기뿐만 아니라 제2 복수의 가산기들(707A, ..., 707M)의 각 가산기로 라우팅된다. 마찬가 지로, 제2 복수의 피연산자들의 각 피연산자로부터의 지수 부분은 분해 회로로부터 제1 복수의 가산기들 (705A, ..., 705N)의 각 가산기뿐만 아니라 제2 복수의 가산기들(707A, ..., 707M)의 각 가산기로 라우팅된다. 제1 복수의 피연산자들 및 제2 복수의 피연산자들로부터의 지수 부분들의 각 쌍은 제1 복수의 가산기들 및 제2 복수의 가산기들(705A, ..., 705N, 707A, ..., 707M) 중 대응하는 가산기에서 상호적으로 합산되어 대응하는 지 수 Exp11, ..., ExpN1, Exp1M, ..., ExpNM를 생성한다. 제1 포맷이 부동 소수점 포맷인 경우, 제1 복수의 가산기 들 및 제2 복수의 가산기들 및 제2 복수의 가산기들(705A, ..., 705N, 707A, ..., 707M)은 활용되지 않는다 (not utilized). 이러한 경우에는, 가산기들(705A, ..., 705N, 707A, ..., 707M)은 모드 신호에 기초하여 꺼 질 수 있고(turned off), 가산기들(705A, ..., 705N, 707A, ..., 707M)의 입력들로 라우팅되는 모든 0비트들 또는 가산기들(705A, ..., 705N, 707A, ..., 707M)은 일부 그 밖의 방식으로 바이패스되고, 그 출력들은 활용되 지 않는다. 제1 포맷이 부동 소수점 포맷인 경우, 대응되는 레지스터(709A, ..., 709N, 710A, ..., 710M)에 저장되는 각 부분 결과는 대응하는 시프트 회로(713A, ..., 713N, 714A, ..., 714N)에서 대응하는 가산기(705A, ..., 705N, 707A, ..., 707M)로부터의 출력되는 각각의 지수 Exp11, ..., ExpN1, Exp1M, ..., ExpNM의 값과 동등한 비트 수만 큼 시프트된다. 각 시프트된 부분 결과는 대응하는 변환 회로들(715A, ..., 715N, 716A, ..., 716M)로 전해진 다(passed onto). 변환 회로들(715A, ..., 715N, 716A, ..., 716M)은 복수의 부분 결과들을 TP 포맷 즉, 고정 소수점 수치 표현으로 변환한다. 각 시프트된 부분 결과의 TP 수치 표현에서의 소수점(decimal point)의 위치 (position)는 각각의 지수 Exp11, ..., ExpN1, Exp1M, ..., ExpNM에 기초한다. 제1 포맷이 정수 포맷인 경우, 시프팅(shifting) 및 변환(conversion)은 필요하지 않고(not required), 즉, 시 프트 회로들(713A, ..., 713N, 714A, ..., 714N) 및 변환 회로들(715A, ..., 715N, 716A, ..., 716M)은 예를 들어, 모드 신호의 적절한 값(appropriate value)에 의해 제어되는 대응하는 디멀티플렉서들 (demultiplexers)(711A, ..., 711N, 712A, ..., 712M)을 사용하여 바이패스된다. 이러한 경우, 레지스터들 (709A, ..., 709N, 710A, ..., 710M)에 저장되는 부분 결과들은 예를 들어, 모드 신호의 적절한 값 (appropriate value)에 의해 제어되는 대응하는 멀티플렉서들(multiplexers)(717A, ..., 717N, 718A, ..., 718M)을 통해 누산기 회로로 바로(directly) 제공된다. 제1 포맷이 부동 소수점 포맷인 경우, 변환 회로 들(715A, ..., 715N, 716A, ..., 716M)의 출력들에서의 시프트된 부분 결과들은 예를 들어, 모드 신호의 적절한 값(appropriate value)에 의해 제어되는 대응하는 멀티플렉서들(multiplexers)(717A, ..., 717N, 718A, ..., 718M)을 통해 누산기 회로로 바로(directly) 제공된다. 누산기 회로는 누산기 회로의 레지스터에 또한 저장되는 제2 포맷의 완전한 결과(complete result)를 생성하기(generate) 위해 제2 포맷(즉, TP 수치 표현)을 사용하여 복수의 부분 결과들(또는 복수의 시프트된 부 분 결과들)을 누산한다. 바람직한 실시예(preferred embodiment)에서, 오류의 누산(accumulation of an error)을 최소화하기 위해, 누산기 회로는 복수의 부분 결과들 중 가장 작은 부분 결과에서 복수의 부분 결과들 중 가장 큰 부분 결과까지 누산한다. 도 7은 단일 누산기 회로(single accumulator circuit)를 도시하고 있지만, 도 7의 곱셈기 회로(multiplier circuity)는 복수의 누산기 회로들을 포함할 수 있으며, 예를 들어, 단일 누산 단계(single accumulation stage) 또는 다수의 누산 단계들(multiple accumulation stages)로 연결될(connected) 수 있다. 일 실시예에서, 누산기 회로는 적어도 80비트를 포함한다. 또다른 실시예에 서, 누산기 회로는 96비트를 포함한다. 또 다른 실시예에서, 누산기 회로는 128 비트를 포함한다. 그러나, 128비트보다 큰 누산기 회로도 활용될 수 있다. 도시적인 실시예(illustrative embodiment)에서, FP16 행렬 곱셈 연산이 예를 들어, 91비트 정수의 정밀도의 누 산을 위해 누산기 회로를 활용할 때(예: MXM 또는MXM)에서 누산기 회로의 레지스터는, 22 압축된 캐리 비트와 3 개의 상태 비트(status bits)가 캐리 정보(carry information)에 사용되어 더 빠른 클록 주파수(faster clock frequency)를 사용한 계산을 가능하게 하도록 적어도 116비트의 폭을 가진다. 누산된 곱 셈기 결과들은 91비트 정수 정밀도의 누산기 회로의 116비트 레지스터에서 91비트 정수 정밀도의 절단/변 환(truncation/conversion) 회로를 사용하여 누산기 회로의 출력에 결합된 FP32로 변환된다. 절단/ 변환 회로는 NIM 또는 NIM의 일부일 수 있고, 변환은 누산된 곱셈기 결과들이 MXM 또는MXM로부터 VXM으로 스트리밍될 때(streamed) 발생할 수 있다. 또다른 실시예에서, INT8 행렬 곱셈 연산 및 누산, 누산기 회로의 레지스터에서 각 부분 출력 합산 (partial output sum)의 폭은 25비트이다. 누산기 회로의 레지스터에서 총 4개의 부분 합이 100비트로 연 결되어 INT32 정밀도를 달성한다. 누산기 회로의 레지스터에 있는 나머지 비트는 사용되지 않는다. 누산 기 회로의 레지스터에서 발생되고 저장된 값은 완전히 손실이 적은(full loss-less) INT32 포맷, 즉, INT32 수치 표현의 TP 포맷이다. 또 다른 실시예에서, 완전한 합산 연산(full sum operation)을 수행하는 NIM 내의 누산기(또는 NIM 내의)는 112비트의 워드에서 압축된 캐리 비트를 90비트로 해결한(resolve) 다음, 238 90비트의 TP 숫자들을 단 일 INT128까지 누산할 수 있는 최대 용량으로 다수의 256x256 행렬 곱셈 출력값들을 누산할 수 있다. 행렬 곱 셈이 인터리브된(interleaved) 경우 부분(중간(interim)) 결과들이 별도로(separately) 더해진다. VXM 110은 다음 클록 사이클(next clock cycle)까지 지속되는(persistent) 캐리를 포함하는 임의의 정밀도 산술 명령어 (arbitrary precision arithmetic instruction)를 포함할 수 있다. 초기 ADD_MOD, 일련의 ADD MOD_CI 명령어, 최종 캐리 비트를 얻기 위한 선택적 최종 ADD MOD_CI INT32 0,0을 사용하여 모든 사이즈의 INT가 누산기 회로 에 누적될 수 있다. 누산기 회로의 사이즈 때문에 누산기 회로에서 누산하는 동안 반올림(rounding)(즉, 절단 (truncation))이 적용되지 않는다. 최종 누산 결과에 유일한 반올림(즉, 절단)을 적용하여 원하는 부동 소수점 정밀도(예: FP16, FP32, FP 64 자릿수(recision) 또는 일부 그 밖의 부동 소수점 정밀도)의 최종 곱셈 결과를 얻는다. 하나 이상의 실시예들에서, 입력 피연산자들의 유효숫자들은 정수 포맷(예: 변환 회로(702 및 703)에 서)으로 변환되어 곱셈기들(706A, ..., 706N, 708A, ..., 708M)이 융합된 곱셈 누산 연산(fused multiply accumulate operation) 대신에 융합된 내적 연산(fused dot product operation)을 수행할 수 있도록 한다. 융 합된 내적 연산 결과는 누산기 회로의 레지스터 내에서 얻어지고 저장되어 미리 정의된(pre-defined) 정밀 도, 예를 들어, 적어도 80비트의 정밀도를 유지한다(maintain). 예를 들어, 도 7의 곱셈기 회로가 기능 유닛 (functional units)(예: MXM 및/또는 MXM)에서 빌딩 블록으로 활용되는 경우, 융합 내적 연산의 최 대 320개 부분 결과들이 어떠한 절단 없이 누산기 회로에 누산될 수 있다. 누산 회로의 레지스터에 저장된 제2 포맷(예: TP 포맷)의 누산된 결과는 완전한 곱셈 결과를 나타낸다 (represents). 누산기 회로의 레지스터에 결합된 절단/변환 회로는 제2 포맷(예: TP 숫자)의 완전한 곱셈 결과를 출력 레지스터에 저장된 출력 포맷의 출력 결과로 변환한다. 절단/변환 회로는 먼저 누 산기 회로의 레지스터에 저장된 완전한 곱셈 결과의 부분(portion)을 선택적으로 절단함으로써, 완전한 곱 셈 결과를 제2 포맷으로부터 출력 포맷으로 변환할 수 있다. 절단 후, 절단/변환 회로는 완전한 곱셈 결 과(즉, 절단된 누산 결과)를 출력 포맷, 예를 들어, FP32 포맷, FP64 포맷, FP128 포맷, 또는 일부 그 밖의 부 동 소수점 포맷으로 변환한다. 절단/변환 회로에 의한 변환은 도 7에 나타낸 바와 같이, \"Out_Format\" 신 호를 통해 절단/변환 회로로 제공되는 원하는 출력 정밀도에 기초할 수 있다. 예를 들어, IEEE 754 표준에 따라 FP32 형식으로 반올림(즉, 절단)할 때, 지수를 나타내는 데는 8비트를, 유효 숫자(significand)를 나타내는 데는 23비트를 사용한다. 예를 들어, 누산기 회로에서 누산된 최종 누적 결과를 잘림/변환 회로에서 FP32 포맷 정밀도로 잘림하면 약 4.98 테라플롭(teraflops)의 계산 속도 (calculation rate)를 제공하는 것으로 나타낼 수 있습니다. \"1 테라플롭스\" 은 초당 백만 초당 부동 소수점 연산의 컴퓨팅 속도를 나타내며, FP32 유닛과 동등한 정밀도의 수치 결과를 제공한다는 점에 유의한다. IEEE 754 표준에 따른 FP16 포맷으로의 반올림(즉, 절단)은 IEEE 754 표준에 따라 지수는 5비트를, 유효숫자는 10비 트를 사용한다. 누산기 회로에서의 누산과 절단/변환 회로에서의 FP16 포맷 정밀도로의 최종 누산 결과의 절단이 약 403 테라플롭의 계산 속도를 제공함이 나타낸다. 또한, 8개의 지수 비트 및 유효숫자에 대한 7비트의 FP16 표현으로의 반올림(즉, 절단)이 활용될 수 있고, 이는 bfloat16 또는 BF16로 표시된다(denoted). 누산기 회로에서의 누산과 절단/변환 회로에서 최종 누적 결과를 BF16 포맷 정밀도로 절단하면 약 44.78 테라플롭의 계산 속도를 제공하는 것으로 나타낼 수 있다. 하나 이상의 실시예에서, 전술한 바와 같이(as aforementioned), 분해 회로는 더 빠른 정수 곱셈(faster integer multiplications)에 적합한 더 작은 정수를 얻기 위해 툼-쿡 분해 알고리즘을 적용하여 큰 정수의 분해 를 수행한다. 대안적으로, 분해 회로는 툼-쿡3 분해 알고리즘을 적용할 수 있다. 툼-쿡 알고리즘(또는, 대안적으로, 툼-쿡3 알고리즘)을 적용하는 분해 회로는 디지털 곱셈기 회로와는 별도로 VXM, MXM 및/또는 MXM의 빌딩 블록이 될 수 있다.툼-쿡 분해 알고리즘의 단순화된 버전(simplified version)이 정수 23과 35를 곱하는 경우를 예로 들어 설명되 어 있다. 분해된 정수(decomposed integers) 23과 35를 나타내는 다음 다항식이 얻어진다: p(x)=2x + 3, q(x)=3x + 5, 여기서 p(x)는 23을 더 작은 정수 2와 3으로 분해한 것을 나타내고, q(x)는 35를 더 작은 정수 3 과 5로 분해한 것을 나타내며, 여기서 x는 10이다. 따라서, 곱셈의 결과는 p(x)*q(x) = r(x)가 된다. 제1 숫 자와 제2 숫자의 유효숫자를 툼-쿡 알고리즘에 따라 제1 복수의 연산자들 및 제2 복수의 연산자들로 분해하는 것은, 더 작은 정수들이 상호적으로 결합된 다항식 (2x + 3)*(3x + 5) = ax2 + bx + c= r(x)을 산출하며 (yield), 여기서 a, b, 및 c는 미지의 매개변수(unknown parameters)이다. p*q=r로부터, c = 15라는 것이 결정될 수 있다. p*q=r1로부터, x와 c를 대입하면 a + b= 25; 그리고 p(-1)*q(-1)=r(-1)에서 x 와 c를 대입하면 a- b=-13이다. 두 개의 미지수를 가지는 두 개의 선형 방정식 a+b=25, a-b = -13에서, a= 6, b= 19임이 결정될 수 있다. 따라서, 곱셈의 결과 p(x)*q(x) = r(x) = 6x2 + 19x + 15가 된다. r(x)에서 x = 10을 대입하면 곱셈의 결과는 r = 600 + 190 + 15 = 805로 얻을 수 있다. 또다른 예시에서, 정수 7과 22가 곱해진다. 이 경우, 두 개의 정수 곱셈 연산이 생기고(occur), 매번 부분 결 과는 14가 되지만, 적절한 최종 곱셈 결과 154를 산출하는 더해져야 하는 올바른 숫자(correct number)는 140과 14이다. 그러나, 부동 소수점 숫자를 반올림하는 경우와 같이 대략적인 최종 결과(approximate final result) 를 얻기 위해 최하위 유효숫자(least significant digit)가 절단될 때 문제가 발생할 수 있다. 그런 다음, 숫 자를 일(ones), 십(tens), 백(hundreds)의 자리 열로 시프트하고(예: 시프트 회로들(713A,쪋, 713N,714A, ...., 714M)에서 수행됨), 최하위 유효숫자(예: 절단/변환 회로에서)를 반올림하는 것은, 10과 10을 곱하 여 최종 곱셈 결과가 154가 아닌 100으로 산출한다. 부분 곱셈 결과인 14에서 최하위 숫자만 빼더라도 (dropped) 최종 곱셈 결과는 근사치일 뿐이다. 이 예시는 누산기 회로에서의 부분 곱의 누산의 정밀도가 계산 속도(computational speed) 및/또는 전력 소모(power dissipation)를 희생할 경우 어떤 일이 발생하는지 도시한다. 하나 이상의 실시예들에서, 도 7의 곱셈기 회로에 입력되는 피연산자는 부호가 있거나(signed) 부호없는 (unsigned) 정수 포맷(예: INT4 또는 INT8) 또는 부동-소수점 포맷(예: FP16 또는 FP32 포맷)으로 표현된다. 도 7의 곱셈기 회로는 입력 피연산자들의 포맷, 예를 들어, INT 8 포맷 또는 FP16 포맷을 식별하도록 구성될 수 있다. INT8 포맷의 피연산자들은 INT32 누산과 INT8 곱셈이 필요하며, FP16 포맷의 입력 피연산자들은 FP32 누 산과 FP16 곱셈이 필요하다. 도 7의 곱셈기 회로는 INT8 곱셈, INT16 곱셈(INT64 누산 포함), INT32 곱셈 (INT128 누산 포함) 뿐만 아니라, INT8 피연산자와 INT4 피연산자 간의 곱셈(예: 가중치 정밀도가 필요하지 않 은 경우)도 지원한다. 일반적으로, INT8 곱셈(INT32 누산 포함)은 추론 응용들(inference applications)을 위한 충분한 정밀도 (precision) 및 정확도(accuracy)를 가진다. 정밀도와 정확도는 서로 다른 두 가지 요구사항(requirements)이 라는 점에 유의해야 한다. 정밀도 요구사항(precision requirement)은 곱셈 결과(예: 16비트 곱셈 결과)를 표 현하기 위한 비트 수와 관련된다. 정확도 요구사항(accuracy requirement)은 곱셈 결과가 수학적으로 올바른지 여부(mathematically correct or not), 예를 들어, 16비트 결과가 수학적으로 올바른지 여부와 관련된다. 훈련된 모델들(trained models)은 이전 학습 반복(previous learning iteration)의 가중치와 현재 학습 반복 (current learning iteration)의 가중치 간의 수렴 차이(converging differences)를 계산할 수 있는 충실도 (fidelity)가 필요하기 때문에 Al 및/또는 ML 응용(예: TSP코어 100에서 수행됨)의 모델은 일반적으로 숫자의 부동 소수점 표현을 사용함에 유의한다. 그렇지않으면(otherwise), 차이(differences)가 미리 결정된 임계값 (predetermined threshold values)보다 커서, 즉 차이가 수렴하기에는 너무 커서 학습된 모델들은 수렴하지 못 한다. 도 7의 곱셈기 회로망(VXM, MXM 및/또는 MXM의 빌딩 블록으로서)은 입력 피연산자들(즉, 훈련 가중치들)을 정수 곱셈을 위해 부동 소수점 포맷에서 정수 포맷으로 변환하기 위한 변환 회로들(702 및 703) 뿐만 아니라, 최종 누산 결과를 누산기 회로로부터 부동 소수점 포맷으로 다시 변환하기 위한 절단/ 변환 회로을 포함한다. 하나 이상의 실시예들에서, 도 7의 곱셈기 회로는 부동 소수점 유형 산술 (floating point type arithmetic)과 정수 유형 산술(integer type arithmetic) 사이에서 공유되는 MXM 및/또는 MXM의 공통된 회로망(common circuitry)의 일부일 수 있다. 도 7의 곱셈기 회로망의 입력 피연산자들은 정수 포맷(예: INT8)이거나 부동 소수점 포맷(예: FP16)이다. 도 7 의 곱셈기 회로망은 부동 소수점 포맷 또는 정수 포맷의 입력들을 다룰(handle) 수 있다. 하나 이상의 실시예 들에서, 각 곱셈기(706A, ..., 706N, 708A, ..., 708M)는 부호 있는 정수, 부호 없는 정수 또는 부동 소수점 수자인 피연산자를 입력할 수 있다. 각 곱셈기(706A, ..., 706N, 708A, ..., 708M)은 (예: 적절한 내부 회로망(appropriate internal circuitry)을 사용하여) 입력 데이터 유형을 식별하고, 필요한 경우 필요한 변환(예: 부동 소수점 포맷에서 정수 포맷으로)을 수행하고, 부분 곱을 생성하기 위해 정수 곱셈 연산을 수행한다. 그런 다음, TP 포맷을 사용하여 누산 회로에 부분 곱을 누산하여 최종 곱셈 결과를 부분 곱의 합으로 얻을 수 있다. 하나 이상의 실시예들에서, 입력 피연산자들이 INT8 포맷인 경우, 도 7의 곱셈기 회로망은 두 세트의 정수 입력 피연산자들에 대한 연산을 수행할 수 있고, 최종 출력 곱은 두 개의 24비트 수량(two 24-bit quantities), 즉, 정수 곱의 합산이다. 유리하게도, 24비트는 255에서 255 사이의 곱의 합산(즉, INT 8 포맷의 최대 피연산자 들)을 보유하기에(hold) 충분하다(sufficient). 최종 곱은 어레이의 각 열에 대한 전체 어레이의 열별로 로컬 로 합산될 수 있다(예: VXM, MXM 및/또는 MXM의 부분으로). 정수 곱셈의 경우 오버플로(overflow)의 위험(risk)이 없음에 유의한다. 그러나, 부동 소수점 숫자의 곱셈의 경우, 오버플로가 생길 수 있다. 따라서, 피연산자들은, 예를 들어, 변환 회로(702, 703) 또는 변환 회로 (715A, ..., 715N, 716A, ..., 716M)에서 TP 포맷으로 변환된다. 부동 소수점 및 누산 연산의 곱은, 그러므로, 누산기 회로에서 TP 포맷으로 유지된다. 따라서, 도 7의 곱셈기 회로망은 곱셈 및 합산의 결과 를 TP 포맷으로 유지할 수 있고, 이는 매우 작은 숫자부터 매우 큰 숫자까지 다양한 범위에 걸치는(spanning) 피연산자들에 대해 절대적인 정확도(absolute accuracy)를 유지하는 데 유리할 수 있다. TP 포맷은 완전한 숫 자를 고정 소수점 포맷으로 유지하고 최종 결과를 고정 소수점 TP 숫자와 지수로 출력한다(원하는 부동 소수점 포맷으로의 변환 전). 부분 곱셈 결과들의 누산을 위해 TP 포맷을 활용함으로써, 도 7의 곱셈기 회로망은 입력 피연산자들, 예를 들어, FP16 포맷의 행렬 곱셈을 수용하지만, 예를 들어, FP32 포맷인, 출력인 최종 곱셈 결과를 생성하고, 이는 FP16 포맷보다 훨씬 더 정확하다(예: 가수(mantissa)를 위한 23비트와 지수를 위한 8비트 때문에). 따라서, 정 수 곱셈기들을 활용하고 TP 포맷의 부분 곱의 누산을 수행함으로써, 도 7의 곱셈기 회로망은 임계값 미만의 정 밀도 손실로 FP32 연산을 효과적으로 수행한다. 대안적으로, 도 7의 곱셈기 회로망은 곱셈 결과를 적절한 비트 수로 절단해 FP64(또는 FP128) 결과를 생성한다. TP 포맷에 기반한 누산에 정수 곱셈은 AI및/또는 ML 업무량(workload)에 대한 향상된 정밀도를 제공한다는 점에 유의해야 한다. 도 8은 서로 다른 포맷들을 사용하여 수행되는 내적 곱셈을 위한 샘플 사이즈의 함수로서 내적 정밀도(dot product precisions)의 그래프이다. 플롯은 FP32 기반 곱셈을 사용하여 수행된 내적 연 산에 대한 샘플 사이즈의 함수로서 내적 정밀도를 나타낸다. 플롯은 FP32 분류된 곱셈(sorted multiplications)을 사용하여 수행된 내적 연산의 샘플 사이즈의 함수로서 내적 정밀도를 나타낸다. 플롯들 (802 및 804)에서 내적 연산의 정밀도가 샘플 사이즈가 증가할수록, 즉, 누산 연산의 횟수가 증가할수록 나빠짐 (worsens)이 관찰될(observed) 수 있다. 플롯은 FP16 포맷의 입력 피연산자들로 도 7의 곱셈기 회로망에 의해 수행된 내적 연산에 대한 샘플 사이즈의 함수로서 내적 정밀도를 나타내고, TP 포맷으로 수행된 부분 곱의 누산(예: 누산기 회로), 및 FP32 포맷으로 출력되는 최종 곱셈 결과를 나타낸다. 플롯으로부터 TP 포맷을 활용하는 내적 연산의 정밀도는 기존의 FP32 곱셈 및 FP32 분류된 곱셈의 그것보다 우수하다(superior) 는 것이 관찰될 수 있다. 또한, TP 포맷에 기반한 내적 연산의 정밀도는 누산 연산의 수가 증가함에 따라(즉, 샘플 사이즈가 증가함에 따라) 거의 변하지 않는다(virtually unchanged). 그러므로, TP 기반 계산은 가장 정확한 부동 소수점 결과를 제공하는 동시에, 개선된 지연시간(latency)과 처리 량(throughput)을 제공한다. 동일한 가중치와 동일한 입력을 사용하여 CPU 또는 GPU의 단일 코어에서 ML 모델 을 훈련할 때 동일한 정확도를 달성하려면, CPU 또는 GPU 기반 시스템은, 예를 들어, FP128 정밀도 포맷으로 누 산해야 한다. 유리하게도, TSP 코어에서 실행되는 제시된(presented) TP 기반 곱하기-누산(multiply- and-accumulate)(MAC) 연산은 FP16 피연산자들을 활용하고 GPU 또는 CPU보다 훨씬 나은(significantly better) 정확도로, FP32 결과를 생성한다. 고정밀 수치 계산(higher-precision numeric calculations)을 위한 에너지(energy) 및 수행 비용(performance cost)은 많은 응용 분야에서 상당할(significant) 수 있다. 그러나, 부동 소수점 포맷을 활용하는 계산에서 TP 포맷은 저전력 계산(low power calculations)을 위한 핵심 요소(key enabler)가 될 수도 있다. FP16 포맷의 피연산자의 곱을 계산하는 데 필요한 에너지는 더 넓은 포맷(예: FP32 또는 FP64 포맷)으로 표현되는 피연산자 들의 곱을 산출하는 데 필요한 에너지보다 적은 것으로 알려져 있다. 예를 들어, FP32 기반 계산은 FP16 기반 계산에 비해 약 4배의 에너지를 소비하는 것으로 나타날 수 있다. 예를 들어, 단일 반올림 단계(single rounding step)가 있는 320-요소 융합 내적(320-element fused dot product)의 경우, 도 7의 곱셈기 회로망에 서 적용된 혼합-정밀도의 에너지 이점을 취하려면, 입력 피연산자들은 FP16 포맷인 반면 내적은 누산된 다음FP32 포맷으로 출력된다. 예를 들어, TSP 코어의 320-요소 SIMD 명령어들은 명령어 추출(instruction fetch) 및 디코딩 에너지(decode energy)가 320개의 연산에 걸쳐 상환될(amortized) 수 있다. MEM(111 및 112)의 각 MEM 슬라이스는 약 8,000개의 320-요소 벡터에 액세스할 수 있으므로 기존 캐시 계층구조 (traditional cache hierarchies)에 비해 SRAM 액세스 비용을 낮게 유지할 수 있다. 도 9는 실시예에 따른 TP 기반 누산과 정수 곱셈을 위한 방법을 도시한다. 동작 901에서, 제1 포맷의 피연산자 및 제1 포맷의 또다른 피연산자에 대응되는 디지털 비트들이 하나 이상의 스토리지 레지스터 회로들에 저장된다. 동작 902에서, 피연산자는 제1 복수의 피연산자들로 분해되고, 그 밖의 피연산자는 제2 복수의 피연 산자들로 분해된다. 동작 903에서, 복수의 곱셈기 회로들의 각 곱셈기 회로를 사용하여, 복수의 부분 결과들 중 대응하는 부분 결과를 생성하기 위해, 제1 복수의 피연산자들의 각각의 제1 피연산자는 제2 복수의 피연산자 들의 각각의 제2 피연산자에 곱한다. 동작 904에서, 누산기 회로에 저장된 제2 포맷의 완전한 결과를 생성하기 위해, 제2 포맷을 사용하여 누산기 회로에서 복수의 부분 결과들이 누산된다. 동작 905에서, 제2 포맷의 완전 한 결과는 출력 포맷의 출력 결과로 변환된다. 본 개시의 실시예들은 요소별 연산, 예를 들어, 활성화 행렬 및 가중치 행렬의 요소별 곱셈-MATMUL을 수행하기 위한 입력 피연산자들(예: 활성화 및 가중치)의 FP 수치 표현(예: FP32 또는 BF16)의 변환을 위한 방법과 또한 관련된다. 일부 실시예들에서, 제1 방법에서, 입력 피연산자들의 모든 지수들이 범위별로 분류된다. 일 실시 예에서, 제1 방법의 제1 서브-방법에서, 모든 입력 숫자들(예: 행렬 요소들)은 먼저 각각의 지수 범위를 갖는 그룹들로 분류되어 사전-처리된다. 각 지수들은 다음 범위들의 하나 이내임에 유의한다: 2n-2에서 1, 2nx2-4에 서 2n-1, 2nx3-6에서 2nx2-3, 2nx4-8에서 2nx3-5, 2nx5-10에서 2nx4-7, 2nx6-12에서 2nx5-9, 2nx7-14에서 2nx6-11, 2nx8-16에서 2nx7-13, 2nx9-34에서 2nx8-15, 여기서, n은 지수를 표현하는 비트의 수이다. 두번째로, 각 그룹으 로부터의 숫자들(예: 행렬 요소들)은 정규화 전에 각 그룹이 어느 범위에 있었는지를 추적하면서(keeping track) MATMUL의 정의된 지수 범위 내로 정규화된다. 세번째로, 요소별 연산(예: 곱셈)은 제2 단계에서 얻어진 각 활성화 그룹 및 가중치 그룹으로부터 정규화된 숫자들에 대해 수행된다. 네번째로, 중간 결과는 원래의 범 위(original range)와 일치하도록 조정된다(adjusted). 다섯번째로, 이전 그룹 결과(들)의 누산이 수행된다. 여섯번째로, 만약 임의의 그룹들이 남았다면, 세번째, 네번째 및 다섯번째 단계들이 반복된다. 일곱번째로, 모 든 그룹들이 완성되면(completed), 최종 누산 및 최종 포맷으로의 변환이 수행된다. 제1 방법의 제1 서브-방법 은 중간 결과에 대해 TP 포맷을 활용하고, 최종 변환까지 오류가 발생하지 않는다(no error is introduced). 제1 방법의 제1 서브-방법은 (올림(roundup) (입력들의 지수 범위/행렬의 지수 범위))2를 필요로하고 (requires), 행렬 x 행렬 사이즈/MATMUL 행렬 사이즈와 완성을 위한 사전-처리 및 사후-처리 주기를 더한(plus) 값을 전달한다(passes). 또다른 예시에서, 제1 방법의 제2 서브-방법에서, 모든 행렬 가중치들은 먼저 동일한 범위에 속하도록 사전-처 리된다. 각각의 행렬 가중치의 지수는 다음 범위 중 하나의 이내이다: 2n-2에서 1, 2nx2-4에서 2n-1, 2nx3-6에 서 2nx2-3, 2nx4-8에서 2nx3-5, 2nx5-10에서 2nx4-7, 2nx6-12에서 2nx5-9, 2nx7-14에서 2nx6-11, 2nx8-16에서 2nx7-13, 2nx9-34에서 2nx8-15, 여기서 n은 지수의 비트 수이다. 두번째로, 가장 큰 중간 지수(largest intermediate exponent) N이 사전-처리되고, 지수가 (e-log2(m)-s)보다 작은 모든 값이 0으로 처리(zeroed out)되며, 여기서 m은 수행해야 할 연산의 수, e는 최종 포맷의 사이즈 지수(size exponent), s는 변환을 위한 사이즈 유효숫자이며, e>N이다. 세번째로, 활성화는 재-정렬되고 0으로 처리된 값들은 제거된다. 네번째로, 모든 행렬 활성화들은 동일 범위 내에 속하도록 사전-처리된다. 다섯번째로, 각 그룹이 어느 범위에 있었는지 를 추적하면서(keeping track) 활성화들의 각 그룹은 MATMUL의 지수 범위 내로 정규화된다. 여섯번째로, 요소 별 연산(element-wise operation)(예: 곱셈(multiplication)이 현재의 정규화된 활성화 그룹 및 사전-처리된 가중치에서 수행된다. 일곱번째로, 중간 결과는 원래의 범위(original range)와 일치하도록 조정된다 (adjusted). 여덟번째로, 이전 그룹들의 결과(들)의 누산이 수행된다. 아홉번째로, 모든 그룹들이 완성되면, 최종 누산 및 최종 포맷으로의 변환이 수행된다. 제1 방법의 제2 서브-방법은 최종 변환에서 차이를 만들지 않 는 값을 미리 버린다(throws away). 제1 방법의 제2 서브-방법은 중간 결과들에서 TP 포맷을 활용한다. 제1 방법의 제2 서브-방법은 최하위 비트(LSB) 영역(region)에 오류가 발생할 가능성을 가지며, 제1 방법의 제1-서 브 방법보다 더 많은 사전 처리가 필요하다. 일부 그 밖의 실시예들에서, 한정된 범위(limited range)의 제2 방법에서, 오직 입력 피연산자들의 지수들의 최 상위 비트들(MSBs)(예: 활성화들 및 가중치들)만이 활용된다. 일 실시예에서, 제2 방법의 제1 서브-방법에서, 입력 피연산자들의 사전-처리는 먼저 수행되고, 오직 각 입력 숫자의 지수의 m개의 MSB들만이 사용된다. 두번 째로, 0의 내부 오류(zero internal error)를 위해 n개의 유효비트들로, 여기서 n=올림(roundup)(유효 비트 입 력(significant bits in)/행렬 유닛에서의 유효 비트(significant bits in matrix unit)), 또는 0이 아닌 내부 오류(non-zero internal error)를 위해 n=절단(truncation)(유효 비트 입력(significant bits in)/행렬 유닛에 서의 유효 비트(significant bits in matrix unit)), 입력 숫자들을 쪼개서(breaking) 입력 숫자들은 사전-처 리된다. 세번째로, 요소별 연산(예: 곱셈)은 제2 단계에서 얻어진 각 활성화 그룹 및 가중치 그룹으로부터 정 규화된 숫자들에 대해 수행된다. 네번째로, 중간 결과는 원래의 범위(original range)와 일치하도록 조정된다 (adjusted). 다섯번째로, 이전 그룹 결과(들)의 누산이 수행된다. 여섯번째로, 만약 임의의 그룹들이 남았다 면, 세번째, 네번째 및 다섯번째 단계들이 반복된다. 일곱번째로, 모든 그룹들이 완성되면(completed), 최종 누산이 수행되고, 원래의 범위로의 조정(adjustment) 및 최종 포맷으로의 변환이 뒤따른다. 제2 방법의 제1 서 브-방법은 두가지 방식으로 정밀도 오류가 발생된다. 첫번째로, 정밀도 오류가 지수들을 제한함에 따라 발생한 다. 두번째로, 행렬에서의 서브-유효숫자 곱하기 유효숫자 비트의 수가 입력 유효숫자 비트의 수보다 작은 경 우, 정밀도 오류는 0이 아니다(non-zero). 제2 방법의 제1 서브-방법은 제1 방법의 제1 서브-방법 및 제1 방법 의 제2 서브 방법을 위한 것보다 훨씬 적은(significantly less) 행렬을 완성하기 위한 패스들(passes)의 수를 필요로 한다(requires). FP32인 최종 포맷으로의 변환을 위해, 제2 방법의 제1 서브-방법은 서브-유효숫자들에 따라(즉, 절단 또는 올림이 제2 단계에서 수행되는지 여부에 따라) 행렬을 완성하기 위해 오직 4개에서 9개의 패스들만을 필요로한다. 또다른 실시예에서, 제2 방법의 제2 서브-방법에서, 모든 활성화들의 사전-처리는 \"1\"인(특정 비트 및 m-1개의 MSB들이 후에 사용된다) 가장 높은 지수 비트(highest exponent bit)로의 정규화를 포함하여 먼저 수행된다. 두번째로, 0의 내부 오류(zero internal error)를 위해, n개의 유효비트들로, 여기서 n=올림(roundup)(유효 비 트 입력(significant bits in)/행렬 유닛에서의 유효 비트(significant bits in matrix unit)), 또는 0이 아닌 내부 오류(non-zero internal error)를 위해 n=절단(truncation)(유효 비트 입력(significant bits in)/행렬 유닛에서의 유효 비트(significant bits in matrix unit)), 활성화들을 쪼개서(breaking) 활성화들은 사전-처 리된다. 세번째로, 모든 가중치들은 사전-처리되고, \"1\"인 가장 높은 지수 비트(highest exponent bit)로 정규 화되고, 그 비트와 m-1개의 MSB들을 그 후에 사용한다. 네번째로, 0의 내부 오류(zero internal error)를 위해, n개의 유효비트들로, 여기서 n=올림(roundup)(유효 비트 입력(significant bits in)/행렬 유닛에서의 유 효 비트(significant bits in matrix unit)), 또는 0이 아닌 내부 오류(non-zero internal error)를 위해 n=절 단(truncation)(유효 비트 입력(significant bits in)/행렬 유닛에서의 유효 비트(significant bits in matrix unit)), 정규화된 가중치들을 쪼개서(breaking) 정규화된 가중치들은 사전-처리된다. 네번째로, 요소별 연산 (예: 곱셈)이 각 활성화 그룹에서 수행되고, 가중치 그룹은 제2 단계와 제4 단계에서 얻어진다. 여섯번째로, 중간 결과는 원래의 유효숫자와 일치하도록 조정된다(adjusted). 일곱번째로, 이전 그룹들 결과(들)과의 누산 이 수행된다. 여덟번째로, 만약 임의의 그룹들이 남았다면, 세번째, 네번째, 다섯번째, 여섯번째, 및 일곱번째 단계들이 반복된다. 아홉번째로, 모든 그룹들이 완성되면(completed), 최종 누산이 수행되고, 원래의 범위로의 조정(adjustment) 및 최종 포맷으로의 변환이 뒤따른다. 제2 방법의 제2 서브-방법은 두가지 방식으로 잠재적 인 정밀도 오류를 발생시킨다. 첫번째로, 잠재적인 정밀도 오류는 지수들을 제한하는 것 때문에 일어날 수 있 다(occur). 두번째로, 행렬에서의 서브-유효숫자 곱하기 유효숫자 비트의 수가 입력 유효숫자 비트의 수보다 작은 경우, 잠재적인 정밀도 오류가 발생될 수 있다. 행렬을 완성하기 위해 필요되는 패스들(passes)의 수는 제2 방법의 제2 서브-방법을 위한 것이 제1 방법의 제1 서브-방법 및 제1 방법의 제2 서브 방법을 위한 것보다 훨씬 적다(significantly less). FP32인 최종 포맷으로의 변환을 위해, 제2 방법의 제2 서브-방법은 서브-유효 숫자들에 따라(즉, 절단 또는 올림이 제2 단계에서 수행되는지 여부에 따라) 행렬을 완성하기 위해 오직 4개에 서 9개의 패스들만을 필요로한다. 제2 방법의 제2 서브-방법은 제2 방법의 제1 서브-방법보다 더 정확해질 (more accurate) 가능성(potential)을 가진다. 또다른 실시예에서, 제2 방법의 제3 서브-방법에서, 제1 단계는 입력 지수들의 포맷이 행렬 단위의 범위만을 사 용하도록 강제하는 것(force)이다. 두번째로, 모든 입력 숫자들(활성화들 및 가중치들)은 0의 내부 오류(zero internal error)를 위해, n개의 유효비트들로, 여기서 n=올림(roundup)(유효 비트 입력(significant bits in)/ 행렬 유닛에서의 유효 비트(significant bits in matrix unit)), 또는 0이 아닌 내부 오류(non-zero internal error)를 위해 n=절단(truncation)(유효 비트 입력(significant bits in)/행렬 유닛에서의 유효 비트 (significant bits in matrix unit)), 쪼개져서(breaking) 사전-처리된다. 세번째로, 요소별 연산(예: 곱셈) 이 각 활성화 그룹 및 제2 단계에서 얻어진 가중치 그룹에 대해 수행된다. 네번째로, 중간 결과는 원래의 범위(original range)와 일치하도록 조정된다(adjusted). 다섯번째로, 이전 그룹 결과(들)의 누산이 수행된다. 여 섯번째로, 만약 임의의 그룹들이 남았다면, 세번째, 네번째 및 다섯번째 단계들이 반복된다. 일곱번째로, 모든 그룹들이 완성되면(completed), 최종 누산이 수행되고, 원래의 범위로의 조정(adjustment) 및 최종 포맷으로의 변환이 뒤따른다. 제2 방법의 제3 서브-방법은 입력 범위가 지수의 행렬의 제한된 범위와 맞도록(match) 강제 한다(force). 만약, 제2 단계에서 올림이 사용되면, 최종 변환까지 오류가 발생하지 않는다. 제2 방법의 제3 서브-방법은 제2 방법의 제1 서브-방법의 처리량(throughput)과 맞는다(matches). 그러나, 제2 방법의 제3 서 브-방법은 행렬 요소들의 처리 동안 임의의 정밀도 또는 범위 오류를 발생시키지 않는다. 일부 그 밖의 실시예들에서, 제3 방법에서, 지수들은 N개의 m-비트 단위로 쪼개진다. 일 실시예에서, 제3 방법 의 제1 서브-방법에서, 모든 입력 숫자들(즉, 활성화들 및 가중치들)의 사전-처리가 지수 부분을 행렬 단위 지 수 사이즈 아래 사이즈(under the size)의 동등한 비트들(또는 동등한 비트들에 가까운(near equal bits))로 쪼 개서 먼저 수행된다. 두번째로, 제1 단계에서 생성된 입력 숫자들의 n개의 유효숫자들로의 사전-처리가 수행되 며, 여기서, 0의 내부 오류(zero internal error)를 위해, n=올림(roundup)(유효 비트 입력(significant bits in)/행렬 유닛에서의 유효 비트(significant bits in matrix unit)), 또는 0이 아닌 내부 오류(non-zero internal error)를 위해 n=절단(truncation)(유효 비트 입력(significant bits in)/행렬 유닛에서의 유효 비트 (significant bits in matrix unit))이다. 세번째로, 요소별 연산(예: 곱셈)이 각 활성화 그룹 및 제2 단계에 서 얻어진 가중치 그룹에 대해 수행된다. 네번째로, 중간 결과는 원래의 범위(original range)와 일치하도록 조정된다(adjusted). 다섯번째로, 이전 그룹 결과(들)의 누산이 수행된다. 여섯번째로, 만약 임의의 그룹들이 남았다면, 세번째, 네번째 및 다섯번째 단계들이 반복된다. 일곱번째로, 모든 그룹들이 완성되면(completed), 최종 누산 및 최종 포맷으로의 변환이 수행된다. 제3 방법의 제1 서브-방법은 중간 결과들을 위해 TP 포맷을 활용하고, 제2 단계에서 올림이 사용되는 경우, 최종 변환까지 오류가 발생되지 않는다. 제3 방법의 제1 서브- 방법은 각 행렬을 완성하기 위해 N개의 동등한 지수 곱하기 N개의 동등한 지수 곱하기 N개의 유효숫자 곱하기 N 개의 유효숫자 패스들을 필요로 한다. FP32의 FP16 완전한 범위로의 변환은(즉, FP32 포맷을 가지는 입력 피연 산자들과 최종 출력 포맷이 FP16), 완전한 정밀도의 제3 방법의 제1 서브-방법은, 행렬 연산을 완성하기 위해 예를 들어, 2x2x3x3x=36개의 패스들을 필요로 한다. 그 밖의 실시예에서, 한정된 유효숫자의 제3 방법의 제2 서브-방법에서, 모든 입력 숫자들(즉, 활성화들 및 가 중치들)의 사전-처리가 지수 부분을 행렬 단위 지수 사이즈 아래 사이즈(under the size)의 동등한 비트들(또는 동등한 비트들에 가까운(near equal bits))로 쪼개서 먼저 수행된다. 두번째로, 모든 유효숫자들은 행렬 단위 유효숫자의 사이즈를 맞추기 위해 절단된다. 세번째로, 요소별 연산(예: 곱셈)이 각 활성화 그룹 및 제2 단계 에서 얻어진 가중치 그룹에 대해 수행된다. 네번째로, 중간 결과는 원래의 범위(original range)와 일치하도록 조정된다(adjusted). 다섯번째로, 이전 그룹 결과(들)의 누산이 수행된다. 여섯번째로, 만약 임의의 그룹들이 남았다면, 세번째, 네번째 및 다섯번째 단계들이 반복된다. 일곱번째로, 모든 그룹들이 완성되면(completed), 최종 누산 및 최종 출력 포맷으로의 변환이 수행된다. 제3 방법의 제2 서브-방법은 원래의 입력 숫자들의 완전 한 범위(complete range)를 지키지만(keeps) 내부 행렬(internal matrix)에 대한 정밀도를 제한한다. 제3 방 법의 제2 서브-방법을 적용함으로써, FP32 포맷의 각 행렬을 위한 패스들의 수는 4개뿐이다. BF16 포맷의 각 행렬에 대한 패스들의 수도 4이지만, 제3 방법의 제2 서브-방법은 최종 변환까지 BF16포맷보다 더 나은 FP32포 맷을 위한 정밀도를 제공한다. 일부 실시예들에서, 행렬 곱셈의 일부로서 누산은 확장된 변수 정밀도 TP 포맷으로 수행될 수 있다. 주어진 행 렬 다중 누산(matrix multiple accumulation)(MATMUL)을 위해 요구되는 누산된 정밀도의 양은 동적으로 (dynamically) 변경될 수 있다(changed). 실시예에서, 내부 행렬의 사이즈인 NxN번의 FP16 MATMUL을 수행하는 경우, 최종 누산과 최종 출력 포맷을 얻기 위한 변환에서 확장(extension)은 필요하지 않다. 또다른 실시예에 서, 예를 들어, 216x216xNxN번의 FP16 MATMUL을 수행하는 경우, 중간 누산(intermediate accumulation)(즉, 부분 곱들의 누산)은 누산 동안 최종 결과의 오버플로(overflowing)를 막기 위해서 32비트로 확장되기 위해 필요된다. 또다른 실시예에서, 예를 들어, 264x264xNxN번의 FP16 MATMUL을 수행하는 경우, 중간 누산 (intermediate accumulation)(즉, 부분 곱들의 누산)은 누산 동안 최종 결과의 오버플로(overflowing)를 막기 위해서 128비트로 확장되기 위해 필요된다. 이러한 각 경우들에서, 최종 포맷으로의 최종 변환까지 정밀도 또 는 정확도에 오류가 발생하지 않는다. 더하여, 이러한 각 경우들에서, 최소 최종 포맷(minimum final format) 은 누산동안 오버플로 없는 최종 결과의 완전한 범위를 유지하기 위해 FP32이다. 또다른 실시예에서, 예를 들어, 256x256의 FP16행렬에서 216x216x256x256번의 FP32 MATMUL을 수행하는 경우, 중 간 누산(즉, 부분 곱들의 누산)은 누산 동안 최종 결과의 오버플로(overflowing)를 막기 위해서 총 512비트로 확장된다. 중간 누산의 확장을 위해 필요되는 총 512비트는, 예를 들어, FP32 MATMUL의 사이즈를 위해 필요되 는 32비트, 더하기 FP32 TP를 위한 564비트, 빼기 FP16을 위한 90비트, 더하기 올림 log236비트(즉, 6비트)한 것이며, 하나의 FP32 행렬 연산으로서 36개의 256x256 기본 행렬 사이즈를 가정한 완전한 범위 및 TP 정밀도를 위한 FP16 연산이 필요하다. 다시, 최종 변환으로의 최종 변환까지 정밀도 또는 정확도에 오류가 발생하지 않 는다. 이러한 경우, 최소 최종 출력 포맷은 누산동안 오버플로 없는 최종 결과를 위한 완전한 범위를 유지하기 위해 FP64이다. 도 10은 실시예에 따른 요소별 행렬 연산 동안의 부동 소수점 변환을 위한 방법을 도시한다. 요소별 행렬 연산 들(예: 행렬 곱셈)의 일부로서의 누산은 확장된 변수 정밀도 TP 포맷으로 수행될 수 있다. 단계 1001에서, 입 력 숫자들(예: 활성화 행렬 및 가중치 행렬의 요소들)은 사전처리된다. 단계 1002에서, 다음 활성화 행렬이 불 러와지고(loaded), 현재 활성화 행렬이 된다. 단계 1003에서, 다음 가중치 행렬이 불러와지고, 현재 가중치 행 렬이 된다. 일부 경우에서, (예를 들어, 다음 활성화 행렬 및 다음 가중치 행렬이 처음으로(for the first time) 불러와지는 경우) 단계 1002 및 단계 1003은 동시에 또는 거의 동시에(simultaneously or near simultaneously) 수행될 수 있음에 유의한다. 또한, 다음 활성화 행렬을 불러오는 단계 1002는 매 다음 가중치 행렬마다 다시 시작된다(restarted). 단계 1004에서, 현재 활성화 행렬 및 현재 가중치 행렬의 대응되는 요소 들 간의 요소별 연산(예: 요소별 곱셈)이, 예를 들어, TP 포맷을 사용하여 수행된다. 현재 활성화 행렬이 마지 막 활성화 행렬이 아닌 경우, 방법은 단계 1002로 돌아가 현재 활성화 행렬이 되는 다음 활성화 행렬을 불러온 다. 반면에, 현재 활성화 행렬이 마지막 활성화 행렬(the last activations matrix)인 경우, 방법은 현재 가중 치 행렬이 되는 다음 가중치 행렬을 불러오기 위한 단계 1003으로 돌아간다(returns)(이는 또한, 단계 1002에서 의 다음 활성화 행렬 불러오기의 재시작을 초기화한다). 단계 1005에서, 누산이, 예를 들어, 앞에서 언급한 확 장된 변수 정밀도 TP 포맷에서 수행된다. 만약 현재 갖우치 행렬이 마지막 가중치 행렬이 아닌 경우, 다음 가 중치 행렬의 불러오기가 수행되고(단계 1003), 누산은 단계 1004에서 얻어진 중간 연산 결과에 적용되고, 새롭 게 불러와진(newly loaded) 가중치 행렬은 요소별 연산을 위해 사용된다. 모든 가중치 행렬들이 불러와지고 단 계 1005에서의 누산이 종료된 후, 최종(다사이클) 합산 및 최종 포맷으로의 변환이 단계 1006에서 수행된다. 도 11은 일 실시예에 따른 컴퓨터-판독가능 매체로부터 명령어들을 읽을 수 있고 프로세서(또는 제어기)에서 명 령어들을 실행하는 예시적인 컴퓨팅 기계의 구성요소들을 도시하는 블록도이다. 본 명세서에서 설명되는 컴퓨 터는 도 11에 나타난 단일 컴퓨팅 기계를 포함할 수 있고, 가상 머신(virtual machine), 도 11에 나타낸 컴퓨팅 장치들의 다수의 노드들(multiple nodes) 또는 컴퓨팅 장치들의 그 밖의 적합한 정렬을 포함하는 분산된 컴퓨팅 시스템(distributed computing system)을 포함할 수 있다. 본 명세서에 설명된 컴퓨터는 설명된 함수들 (described functions)을 실행하기 위해 이전의 도면에서 설명된 임의의 요소들에 의해 사용될 수 있다. 예를 들어, 도 11은 컴퓨터 시스템의 예시적인 형태의 컴퓨팅 기계의 도식적 표현(diagrammatic representation)을 묘사한 것(depicts)으로, 컴퓨터-판독가능 매체에 저장될 수 있는, 기계로 하여금 본 명세서 에 논의된 하나 이상의 프로세스를 수행하도록 하는, 명령들(예: 소프트웨어, 프로그램 코드, 또는 기계 코드)이 있다. 일부 실시예들에서, 컴퓨팅 기계는 독립 실행형 장치(standalone device)로서 동작하거나 그 밖 의 기계들에 연결될 수 있다(connected)(예: 네트워크로 연결됨(networked)). 네트워크로 연결된 배포에서 (networked deployment), 기계는 서버 기계(server machine) 또는, 서버-클라이언트 네트워크 환경(server- client network environment)에서 클라이언트 기계(client machine)의 용량(capacity) 또는 피어-투-피어 (peer-to-peer)(또는 분산된(distributed)) 네트워크 환경에서 피어 기계로서 동작할 수 있다. 도 11에 설명된 컴퓨팅 기계의 구조는 임의의 소프트웨어, 하드웨어, 또는 위 도면들에 나타낸 결합된 구성요소 들에 대응할 수 있다. 예를 들어, 컴퓨팅 기계는 캘리포니아 마운틴뷰의 그록 주식회사(Groq, Inc. of Mountain View, California)에서 설계되고 제조된 텐서 스트리밍 프로세서(tensor streaming processor), 개인 용 컴퓨터(personal computer)(PC), 태블릿 PC, 셋-탑 박스(set-top box)(STB), 개인용 디지털 어시스턴트 (personal digital assistant)(PDA), 휴대전화(cellular telephone), 스마트폰(smartphone), 웹 어플라이언스 (web appliance), 네트워크 라우터(network router), 사물인터넷(internet of things)(IoT) 장치(device), 스 위치 또는 브리지(switch or bridge), 또는 해당 기계가 취할 조치(actions)를 구체화하는 명령들을 실행 할 수 있는 모든 기계 일 수 있다. 또한, \"기계(machine)\"라는 용어는 단일 기계만이 도시되어 있지만, 본 명 세서에서 논의된 하나 이상의 방법론들(methodologies)을 수행하기 위해 개별적으로(individually) 또는 공동으 로(jointly) 명령어들을 실행하는 기계의 임의의 집합(any collection)을 포함하는 것으로 간주되어야 한 다.예시적인 컴퓨터 시스템은 하나 이상의 프로세서들(일반적으로, 프로세서)(예: 중앙 처리 장치 (central processing unit)(CPU), 그래픽 처리 유닛(graphics processing unit)(GPU), 디지털 신호 프로세서 (digital signal processor)(DSP), 하나 이상의 애플리케이션 특정 집적 회로들(application specific integrated circuits)(ASICs), 하나 이상의 무선-주파수 집적 회로들(radio-frequency integrated circuits)(RFICs), 또는 이들의 임의의 조합), 메인 메모리(main memory) 및 정적 메모리(static memory)를 포함하고, 이들은 버스(bus)를 통해 서로 통신하도록 구성된다. 컴퓨터 시스템은 그래픽 디스플레이 유닛(graphics display unit)(예: 플라즈마 디스플레이 패널(plasma display panel)(PDP), 액정 디스플레이(liquid crystal display)(LCD), 프로젝터(projector), 또는 음극선관(cathode ray tube)(CRT))을 더 포함할 수 있다. 컴퓨터 시스템은 또한 영숫자 입력 장치(alphanumeric input device)(예: 키보드(keyboard)), 커서 제어 장치(cursor control device)(예: 마우스(mouse), 트 랙볼(trackball), 조이스틱(joystick), 모션 센서(motion sensor) 또는 그 밖의 포인팅 기구(pointing instrument)), 스토리지 유닛(storage unit), 신호 생성 장치(signal generation device)(예: 스 피커(speaker)) 및 네트워크 인터페이스 장치(network interface device)를 포함할 수 있고, 이들 또한 버스를 통해 통신하도록 구성된다. 스토리지 유닛은 본 명세서에 설명된 방법론들 또는 기능들 중 하나 이상을 구체화하는(embodying) 명령 어들이 저장되는 컴퓨터-판독가능 매체를 포함한다. 명령어들은 또한, 완전히 또는 적어도 부분적으로, 메인 메모리 또는 프로세서 내(예: 프로세서들의 캐시 메모리 내)에 존재할(reside) 수 있다. 따라서, 컴퓨터 시스템에 의해 실행되는 동안, 메인 메모리 및 프로세서는 또한 컴퓨터-판독가능 매체를 형성할(constitute) 수 있다. 명령어들은 네트워크 인터페이스 장치를 통 해 네트워크를 걸쳐 송신되거나 수신될 수 있다. 컴퓨터-판독가능 매체는 단일 매체(single medium)인 것으로 예시적인 실시예에 나타냈지만, \"컴퓨터-판 독가능 매체\"라는 용어는 명령들(예: 명령들)을 저장할 수 있는 단일 매체 또는 복수의 매체들(예: 중앙 집중식(centralized) 또는 분산된(distributed) 데이터베이스, 또는 관련 캐시들 및 서버들)을 포함하는 것으로 간주되어야 한다. 컴퓨터-판독가능 매체는 기계에 의한 실행을 위한, 그리고 기계가 본 명세서에서 개시 된 방법론들 중 하나 이상을 수행하도록 하는 명령들(예: 명령들)를 저장할 수 있는 임의의 매체를 포함 할 수 있다. 컴퓨터-판독가능 매체는 고체 메모리(solid-state memories), 광학 매체(optical media) 및 자기 매체(magnetic media) 형태의 데이터 저장소들(data repositories)을 포함할 수 있지만, 이에 제한되 지는 않는다. 컴퓨터-판독가능 매체는 신호 또는 반송파(carrier wave)와 같은 일시적 매체(transitory medium)를 포함하지 않는다. 위의 상세한 설명은 다양한 실시예들에 대한 도시적이고 예시적인 설명을 제공한다. 본 개시는 물리적 회로망 (physical circuitry)(예: 집적 회로(integrated circuit))로서의 다양한 기술 및 실시예들을 도시하지만, 당 업자에게는 이러한 기술 및 혁신(innovations)이 VHDL 또는 베릴로그(Verilog)와 같은 하드웨어 설명 언어 프로 그램(hardware description language program)으로 구체화될 수도 있다는 것이 이해되어야 한다. 하드웨어 기 술 언어(hardware description language)(HDL)는 디지털 논리 회로를 포함하여, 전자 회로(electronic circuits)의 구조 및 작동방식(behavior)을 설명하는 데에 사용되는 전문화된 컴퓨터 언어(specialized computer language)이다. 하드웨어 설명 언어(hardware description language)는 전자 회로의 자동화된 분석 (automated analysis) 및 시뮬레이션(simulation)을 가능하게 하는 회로에 대한 정확하고(accurate) 공식적인 (formal) 설명을 도출한다. HDL 설명은 넷리스트(netlist)(예: 물리적 전자 구성요소의 사양(specification of physical electronic components) 및 이들이 서로 연결되는 방식)로 합성될(synthesized) 수 있으며, 이를 배치하고 라우팅하여 본 명세서에서 설명되는 요소들과 기능들을 포함하여 집적 회로를 창작하는 데(create)에 사용되는 마스크 세트(set of masks)를 발생시킬(produce) 수 있다. 본 명세서에 설명된 임의의 단계들(steps), 동작들(operations) 또는 프로세스들(processes)은 하나 이상의 하 드웨어 또는 소프트웨어 모듈들을 단독으로 또는 그 밖의 장치들과 조합하여 수행되거나 구현될 수 있다. 일 실시예에서, 소프트웨어 모듈은 컴퓨터 프로그램 코드를 포함하는 컴퓨터-판독가능 매체를 포함하는 컴퓨터 프 로그램 제품(computer program product)으로 구현되며, 이는 설명된 단계들, 동작들 또는 프로세스들의 일부 또 는 전부를 수행하기 위한 컴퓨터 프로세서에 의해 실행될 수 있다. 본 개시의 실시예들은 본 명세서의 동작들을 수행하기 위한 장치와 관련될 수도 있다. 이 장치는 필요한 목적 을 위해 특별히(specially) 형성되거나, 컴퓨터에 저장된 컴퓨터 프로그램에 의해 선택적으로 활성화되거나 재 구성되는(activated or reconfigured) 범용 컴퓨팅 장치(general-purpose computing device)로 구성될 수있다. 이러한 컴퓨터 프로그램은 컴퓨터 시스템 버스(computer system bus)에 결합될 수 있는 비일시적, 유형 의(tangible) 컴퓨터 판독가능 저장 매체, 또는 전자 명령들을 저장하기에 적합한 임의의 유형의 매체에 저장될 수 있다. 또한, 본 상세한 설명에서 언급된 임의의 컴퓨팅 시스템은 단일 프로세서를 포함할 수도 있고, 향상 된 컴퓨팅 능력(increased computing capability)을 위해 다수의 프로세서 설계들을 사용하는 아키텍처들 (architectures)일 수도 있다. 본 개시의 일부 실시예들은 프로세서(예: 텐서 스트리밍 프로세서 또는 인공 지능 프로세서), 적어도 하나의 컴 퓨터 프로세서(예: 호스트 서버), 및 비일시적 컴퓨터-판독가능 저장 매체를 포함하는 시스템과 더 관련될 수 있다. 저장 매체는 컴퓨터 실행가능 명령들을 저장할 수 있으며, 이는 적어도 하나의 컴퓨터 프로세서에서 동 작하는 컴파일러(compiler)에 의해 실행될 때, 적어도 하나의 컴퓨터 프로세서가 본 명세서에서 설명된 동작들 및 기술들(operations and techniques)을 수행하기 위해 작동가능하게 한다. 마지막으로, 본 상세한 설명에 사용된 언어는 주로 가독성(readability) 및 지시적인 목적(instructional purposes)으로 선택되었으며, 발명 주제(inventive subject matter)를 기술하거나(delineate) 한정하기 위해 (circumscribe) 선택되지 않았을 수 있다. 따라서, 본 개시의 범위(scope of the disclosure)는 본 상세한 설 명에 의해 제한되는 것이 아니라, 본 명세서에 기초하여 출원되는 모든 청구항에 의해 제한되는 것이 바람직하 다. 따라서, 실시예들의 개시는 다음 청구범위에 기재된 개시의 범위를 도시하기 위한 것이지, 제한하기 위한 것이 아니다."}
{"patent_id": "10-2023-7025858", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일 실시예에 따른 텐서 스트리밍 프로세서(tensor streaming processor(TSP)) 장치에 기초한 컴퓨터 시 스템을 도시한다. 도 2a는 일 실시예에 따른 다중모드 곱셈기 회로를 도시한다. 도 2b는 일 실시예에 따른 다중모드 곱셈기 회로를 도시한다. 도 2c는 일 실시예에 따른 다중모드 곱셈기 회로를 도시한다. 도 3은 일 실시예에 따른 다중모드 곱셈기 회로의 예시를 도시한다. 도 4는 일 실시예에 따른 다중모드 곱셈기 회로의 또다른 예시를 도시한다. 도 5는 또다른 실시예에 따른 곱셈-누산기 회로를 도시한다. 도 6은 실시예에 따른 다중모드 곱셈을 위한 방법을 도시한다. 도 7은 실시예에 따른 부분 곱셈 결과들의 누산에 기초한 TruePointTM (TP) 포맷의 곱셈기 회로망을 도시한다. 도 8은 TP(TruePoint) 기반 기계-학습 작업량 계산(computations for a machine-learning workload)의 개선된 (improved) 정밀도를 도시하는 그래프이다. 도 9는 실시예에 따른 TP 기반 누산과 정수 곱셈을 위한 방법을 도시한다. 도 10은 실시예에 따른 요소별 행렬 연산 중(during element-wise matrix operations) 부동 소수점 숫자들 (floating point numbers)의 변환 방법을 도시한다.도 11은 실시예에 따른 상거래에 사용되는 컴퓨팅 기계를 도시한다."}
