{"patent_id": "10-2020-0022920", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0108107", "출원번호": "10-2020-0022920", "발명의 명칭": "메모리 시스템 및 그것의 동작방법", "출원인": "에스케이하이닉스 주식회사", "발명자": "신희찬"}}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "존드 네임스페이스(Zoned-Namespace)가 적용된 메모리 시스템에 있어서,복수의 SLC(Single Level Cell) 버퍼들 및 셀 당 멀티-비트 데이터가 저장되며, 복수의 존들 각각에 대응하는복수의 메모리 블록들을 포함하는 메모리 장치; 및호스트로부터 복수의 응용 프로그램들에 대한 프로그램 커맨드를 수신하면, 상기 응용 프로그램들 각각이 나타내는 존들을 오픈 존으로 설정하여 상기 존들에 대응하는 메모리 블록들에 대해 프로그램 동작들을 동시에 수행하도록 상기 메모리 장치를 제어하고, 상기 오픈 존을 제1 내지 제3 오픈 존들로 나누어 상기 프로그램 동작을수행하도록 상기 메모리 장치를 제어하며, 상기 제1 오픈 존으로 설정된 제1 존에 대한 영역 및 제2 오픈 존으로 설정된 제2 존들에 대한 영역들이 할당된 라이트 버퍼를 포함하는 컨트롤러를 포함하되,상기 컨트롤러는오픈 존의 개수가 설정 가능한 개수에 도달한 상태에서 상기 호스트로부터 새로운 응용 프로그램에 대한 프로그램 커맨드를 추가 수신하면, 상기 새로운 응용 프로그램에 대한 존인 타겟 존이 상기 제1 존과 일치하지 아니한경우에, 상기 제1 존 및 상기 제2 존들 중 어느 하나의 존을 빅팀 존으로 검출하고, 상기 빅팀 존을 상기 제3오픈 존으로 설정한 이후, 상기 빅팀 존에 대응하는 데이터를 상기 라이트 버퍼로부터 리드하여 제1 SLC 버퍼에저장하며, 상기 타겟 존을 상기 제1 오픈 존으로 설정한 이후 상기 타겟 존에 대해 상기 라이트 버퍼의 영역을할당하여 상기 타겟 존에 대응하는 제1 데이터를 상기 라이트 버퍼에 저장하는메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서,상기 컨트롤러는존에 대한 정보에 기초하여 상기 타겟 존에 대응하는 제2 데이터가 제2 SLC 버퍼에 저장된 경우에, 상기 제2 데이터를 상기 SLC 버퍼로부터 리드하도록 상기 메모리 장치를 제어하는메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2 항에 있어서,상기 제1 데이터는 제1 데이터 피스 및 제2 데이터 피스를 포함하고,상기 제1 및 제2 데이터 피스들은 순차적으로 상기 라이트 버퍼에 저장되는메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3 항에 있어서,상기 컨트롤러는상기 제2 데이터를 리드하는 동안 상기 제2 데이터 피스를 상기 타겟 존에 대응하는 타겟 메모리 블록에 프로그공개특허 10-2021-0108107-3-램하도록 상기 메모리 장치를 제어하는메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4 항에 있어서,상기 컨트롤러는상기 리드된 제2 데이터와 상기 제1 데이터 피스를 상기 타겟 메모리 블록에 프로그램하도록 상기 메모리 장치를 제어하는메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1 항에 있어서,상기 제2 존들에 대해 각각 할당된 영역들의 크기는 프로그램 단위이며, 상기 제1 오픈 존으로 설정된 상기 타겟 존에 대해 할당된 영역의 크기는 상기 프로그램 단위보다 큰메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1 항에 있어서,상기 컨트롤러는 우선순위에 따라 상기 빅팀 존을 검출하되,상기 컨트롤러는 제1 순위로서 묵시적 오픈 존에 해당하는 존을 상기 빅팀 존으로 검출하고;제2 순위로서 상기 라이트 버퍼에 저장된 상기 제1 및 제2 존들 각각에 대응하는 데이터 중 사이즈가 가장 작은데이터에 대응하는 존을 상기 빅팀 존으로 검출하며,제3 순위로서 상기 제1 및 제2 존들 각각에 대응하는 데이터 중 프로그램된 시점이 가장 오래된 존을 상기 빅팀존으로 검출하는메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1 항에 있어서,상기 컨트롤러는상기 빅팀 존에 할당된 영역을 해제하고,상기 제1 존을 상기 제2 오픈 존으로 설정한 이후, 상기 제1 존에 할당된 영역의 크기를 프로그램 단위로 변경하는 메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "공개특허 10-2021-0108107-4-제1 항에 있어서,상기 컨트롤러는상기 빅팀 존에 대응하는 데이터를 상기 제1 SLC 버퍼에 저장한 이후에 존에 대한 정보를 업데이트하는메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1 항에 있어서,호스트로부터 제공되는 데이터는 상기 라이트 버퍼에 저장되고,상기 호스트로부터 제공되는 상기 데이터의 사이즈는 상기 프로그램 단위보다 작은메모리 시스템."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "존드 네임스페이스(Zoned-Namespace)가 적용된 메모리 시스템의 동작 방법에 있어서,호스트로부터 복수의 응용 프로그램들을에 대한 프로그램 커맨드를 수신하면, 상기 응용 프로그램들 각각이 나타내는 존들을 오픈 존으로 설정하여 상기 존들에 대응하는 메모리 블록들에 대해 프로그램 동작들을 동시에 수행하는 단계;상기 오픈 존을 제1 내지 제3 오픈 존들로 나누어 상기 프로그램 동작을 수행하는 단계; 오픈 존의 개수가 설정 가능한 개수에 도달한 상태에서 상기 호스트로부터 새로운 응용 프로그램에 대한 프로그램 커맨드를 추가 수신하면, 상기 새로운 응용 프로그램에 대한 존인 타겟 존이 제1 오픈 존으로 설정된 제1 존과 일치하지 아니한 경우에, 상기 제1 존 및 제2 오픈 존으로 설정된 제2 존들 중 어느 하나의 존을 빅팀 존으로을 검출하는 단계;상기 빅팀 존을 상기 제3 오픈 존으로 설정한 이후 상기 제3 오픈 존에 대응하는 데이터를 상기 라이트 버퍼로부터 리드하여 제1 SLC 버퍼에 저장하는 단계;상기 타겟 존을 상기 제1 오픈 존으로 설정한 이후 상기 타겟 존에 대해 라이트 버퍼의 영역을 할당하는 단계;및상기 타겟 존에 대응하는 제1 데이터를 상기 라이트 버퍼에 저장하는 단계를 포함하는 메모리 시스템의 동작방법."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11 항에 있어서,존에 대한 정보에 기초하여 상기 타겟 존에 대응하는 제2 데이터가 제2 SLC 버퍼에 저장된 경우에, 상기 제2 데이터를 상기 제2 SLC 버퍼로부터 리드하는 단계를 더 포함하는 메모리 시스템의 동작 방법."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12 항에 있어서,상기 제1 데이터는 제1 데이터 피스 및 제2 데이터 피스를 포함하되,공개특허 10-2021-0108107-5-상기 제1 데이터를 상기 라이트 버퍼에 저장하는 단계는상기 제1 및 제2 데이터 피스들을 순차적으로 상기 라이트 버퍼에 저장하는 단계를 포함하는 메모리 시스템의 동작 방법."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13 항에 있어서,상기 제2 데이터를 리드하는 동안 상기 제2 데이터 피스를 상기 타겟 존에 대응하는 타겟 메모리 블록에 프로그램하는 단계를 더 포함하는 메모리 시스템의 동작 방법."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14 항에 있어서,상기 리드된 제2 데이터와 상기 제1 데이터 피스를 상기 타겟 메모리 블록에 프로그램하는 단계를 더 포함하는 메모리 시스템의 동작 방법."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제11 항에 있어서,상기 제2 존들에 대해 각각 할당된 영역들의 크기는 프로그램 단위이며, 상기 제1 오픈 존으로 설정된 상기 타겟 존에 대해 할당된 영역의 크기는 상기 프로그램 단위보다 큰메모리 시스템의 동작 방법."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제11 항에 있어서,상기 빅팀 존을 검출하는 단계는우선순위에 따라 상기 빅팀 존을 검출하는 단계를 포함하되,상기 우선순위에 따라 상기 빅팀 존을 검출하는 단계는제1 순위로서 묵시적 오픈 존에 해당하는 존을 상기 빅팀 존으로 검출하는 단계;제2 순위로서 상기 라이트 버퍼에 저장된 상기 제1 및 제2 존들 각각에 대응하는 데이터 중 사이즈가 가장 작은데이터에 대응하는 존을 상기 빅팀 존으로 검출하는 단계; 및제3 순위로서 상기 제1 및 제2 존들 각각에 대응하는 데이터 중 프로그램된 시점이 가장 오래된 존을 상기 빅팀존으로 검출하는 단계를 포함하는 메모리 시스템의 동작 방법."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제11 항에 있어서,공개특허 10-2021-0108107-6-상기 빅팀 존에 할당된 영역을 해제하는 단계; 및상기 제1 존을 상기 제2 오픈 존으로 설정한 이후, 상기 제1 존에 할당된 영역의 크기를 프로그램 단위로 변경하는 단계를 더 포함하는 메모리 시스템의 동작 방법."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제11 항에 있어서,상기 빅팀 존에 대응하는 데이터를 상기 제1 SLC 버퍼에 저장한 이후에 존에 대한 정보를 업데이트하는 단계를 더 포함하는 메모리 시스템의 동작 방법."}
{"patent_id": "10-2020-0022920", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제11 항에 있어서,호스트로부터 제공되는 데이터는 상기 라이트 버퍼에 저장되고,상기 호스트로부터 제공되는 상기 데이터의 사이즈는 상기 프로그램 단위보다 작은메모리 시스템의 동작 방법."}
{"patent_id": "10-2020-0022920", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명의 실시 예들에 따른 존드 네임스페이스(Zoned-Namespace)가 적용된 메모리 시스템에 있어서, 복수의 SLC(Single Level Cell) 버퍼들 및 셀 당 멀티-비트 데이터가 저장되며, 복수의 존들 각각에 대응하는 복수의 메 모리 블록들을 포함하는 메모리 장치; 및 호스트로부터 복수의 응용 프로그램들에 대한 프로그램 커맨드를 수신 (뒷면에 계속)"}
{"patent_id": "10-2020-0022920", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 메모리 시스템에 관한 것으로, 보다 구체적으로는 SLC 버퍼를 사용하여 존드 네임 스페이스(Zoned Name Space)에 포함된 오픈 존의 개수를 증가시키기 위한 메모리 시스템 및 그것의 동작방법에 관한 것이다."}
{"patent_id": "10-2020-0022920", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "최근 컴퓨터 환경에 대한 패러다임(paradigm)이 언제, 어디서나 컴퓨터 시스템을 사용할 수 있도록 하는 유비쿼 터스 컴퓨팅(ubiquitous computing)으로 전환되고 있다. 이로 인해 휴대폰, 디지털 카메라, 노트북 컴퓨터 등과 같은 휴대용 전자 장치의 사용이 급증하고 있다. 이와 같은 휴대용 전자 장치는 일반적으로 메모리 장치를 이용 하는 메모리 시스템, 다시 말해 데이터 저장 장치를 사용한다. 데이터 저장 장치는 휴대용 전자 장치의 주 기억 장치 또는 보조 기억 장치로 사용된다. 메모리 장치를 이용한 데이터 저장 장치는 기계적인 구동부가 없어서 안정성 및 내구성이 뛰어나며, 또한 정보 의 액세스 속도가 매우 빠르고 전력 소모가 적다는 장점이 있다. 이러한 장점을 갖는 메모리 시스템의 일 예로 데이터 저장 장치는, USB(Universal Serial Bus) 메모리 장치, 다양한 인터페이스를 갖는 메모리 카드, 솔리드 스테이트 드라이브(SSD: Solid State Drive) 등을 포함한다."}
{"patent_id": "10-2020-0022920", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명의 실시 예에 따른 메모리 시스템은 라이트 버퍼의 용량이 가득 찬 경우에, SLC 버퍼에 호스트 데이터를 저장함으로써 복수의 존들 중 오픈 존의 개수를 증가시킬 수 있다."}
{"patent_id": "10-2020-0022920", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 실시 예에 따른 존드 네임스페이스(Zoned-Namespace)가 적용된 메모리 시스템에 있어서, 복수의 SLC(Single Level Cell) 버퍼들 및 셀 당 멀티-비트 데이터가 저장되며, 복수의 존들 각각에 대응하는 복수의 메모리 블록들을 포함하는 메모리 장치; 및 호스트로부터 복수의 응용 프로그램들에 대한 프로그램 커맨드를 수 신하면, 상기 응용 프로그램들 각각이 나타내는 존들을 오픈 존으로 설정하여 상기 존들에 대응하는 메모리 블 록들에 대해 프로그램 동작들을 동시에 수행하도록 상기 메모리 장치를 제어하고, 상기 오픈 존을 제1 내지 제3 오픈 존들로 나누어 상기 프로그램 동작을 수행하도록 상기 메모리 장치를 제어하며, 상기 제1 오픈 존으로 설 정된 제1 존에 대한 영역 및 제2 오픈 존으로 설정된 제2 존들에 대한 영역들이 할당된 라이트 버퍼를 포함하는 컨트롤러를 포함하되, 상기 컨트롤러는 오픈 존의 개수가 설정 가능한 개수에 도달한 상태에서 상기 호스트로부 터 새로운 응용 프로그램에 대한 프로그램 커맨드를 추가 수신하면, 상기 새로운 응용 프로그램에 대한 존인 타 겟 존이 상기 제1 존과 일치하지 아니한 경우에, 상기 제1 존 및 상기 제2 존들 중 어느 하나의 존을 빅팀 존으 로 검출하고, 상기 빅팀 존을 상기 제3 오픈 존으로 설정한 이후, 상기 빅팀 존에 대응하는 데이터를 상기 라이 트 버퍼로부터 리드하여 제1 SLC 버퍼에 저장하며, 상기 타겟 존을 상기 제1 오픈 존으로 설정한 이후 상기 타 겟 존에 대해 상기 라이트 버퍼의 영역을 할당하여 상기 타겟 존에 대응하는 제1 데이터를 상기 라이트 버퍼에 저장하는 메모리 시스템이 제시된다. 본 발명의 일 실시 예에 따른 존드 네임스페이스(Zoned-Namespace)가 적용된 메모리 시스템의 동작방법에 있어 서, 호스트로부터 복수의 응용 프로그램들을에 대한 프로그램 커맨드를 수신하면, 상기 응용 프로그램들 각각이 나타내는 존들을 오픈 존으로 설정하여 상기 존들에 대응하는 메모리 블록들에 대해 프로그램 동작들을 동시에 수행하는 단계; 상기 오픈 존을 제1 내지 제3 오픈 존들로 나누어 상기 프로그램 동작을 수행하는 단계; 오픈 존의 개수가 설정 가능한 개수에 도달한 상태에서 상기 호스트로부터 새로운 응용 프로그램에 대한 프로그램 커 맨드를 추가 수신하면, 상기 새로운 응용 프로그램에 대한 존인 타겟 존이 제1 오픈 존으로 설정된 제1 존과 일 치하지 아니한 경우에, 상기 제1 존 및 제2 오픈 존으로 설정된 제2 존들 중 어느 하나의 존을 빅팀 존으로을 검출하는 단계; 상기 빅팀 존을 상기 제3 오픈 존으로 설정한 이후 상기 제3 오픈 존에 대응하는 데이터를 상기 라이트 버퍼로부터 리드하여 제1 SLC 버퍼에 저장하는 단계; 상기 타겟 존을 상기 제1 오픈 존으로 설정한 이후 상기 타겟 존에 대해 라이트 버퍼의 영역을 할당하는 단계; 및 상기 타겟 존에 대응하는 제1 데이터를 상기 라 이트 버퍼에 저장하는 단계를 포함하는 메모리 시스템의 동작방법이 제시된다."}
{"patent_id": "10-2020-0022920", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 실시 예에 따른 메모리 시스템은 오픈 존의 개수를 증가시킴으로써 보다 많은 개수의 응용 프로그램 들로부터 수신된 요청을 동시에 처리할 수 있다."}
{"patent_id": "10-2020-0022920", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 본 발명에 따른 바람직한 실시 예를 첨부한 도면을 참조하여 상세히 설명한다. 하기의 설명에서는 본 발 명에 따른 동작을 이해하는데 필요한 부분만이 설명되며 그 이외 부분의 설명은 본 발명의 요지를 흩뜨리지 않 도록 생략될 것이라는 것을 유의하여야 한다. 이하, 도면들을 참조하여 본 발명의 실시 예들에 대해서 보다 구체적으로 설명하기로 한다. 도 1A 내지 도 1C은 종래 기술에 따른 메모리 시스템의 저장 방법을 설명하기 위한 도면이다. 인공지능(AI), 빅 데이터(Big Data) 및 클라우드(Cloud)와 같은 기술들은 데이터센터(Datacenter)를 통해 동작 한다. 데이터센터는 플래시 메모리로 구현된 메모리 시스템을 포함하며, 하나의 메모리 시스템에 대하여 복수의 응용 프로그램들이 구동된다. 복수의 응용 프로그램들은 컴퓨터, 핸드폰 등과 같은 호스트에 의해 구동될 수 있 다. 복수의 응용 프로그램들 각각은 논리 블록 주소들(Logical Block Address:LBA)에 데이터를 저장하고, 메모 리 시스템은 하나의 메모리 블록에 논리 블록 주소들에 저장된 데이터를 저장한다. 메모리 시스템은 서로 다른 응용 프로그램들로부터 제공된 데이터를 하나의 메모리 블록에 저장한 이후에, 논리 블록 주소(Logical Block Address)와 상기 메모리 블록에 대한 물리 주소를 맵핑한다. 도 1A는 하나의 메모리 시스템에 대하여 3개의 응용 프로그램들이 구동되는 경우를 일 예로 설명한다. 복수의 논리 블록 주소들은 복수의 응용 프로그램들에 각각 대응하는 영역들로 구분되며, 복수의 응용 프로그램 들은 대응하는 영역에 포함된 논리 블록 주소들에 데이터를 저장한다. 도 1에 도시된 바와 같이, 제1 응용 프로 그램(APP1)은 3개의 논리 블록 주소들에 데이터를 저장하고, 제2 응용 프로그램(APP2)은 2개의 논리 블록 주소 들에 데이터를 저장하며, 제3 응용 프로그램(APP3)은 3개의 논리 블록 주소들에 데이터를 저장한다. 메모리 시 스템은 제1 내지 제3 응용 프로그램들(APP1-APP3) 각각에 대응하는 영역들에 저장된 데이터를 하나의 메모리 블 록(BLOCK)에 프로그램한다. 따라서, 하나의 메모리 블록(BLOCK)은 제1 내지 제3 응용 프로그램들(APP1-APP3) 각 각에 대한 데이터를 모두 포함한다. 도 1B는 제1 응용 프로그램이 데이터를 이레이즈한 경우에, 메모리 시스템에서의 소거 동작을 나타낸다. 메모리 시스템은 리드 및 프로그램 동작은 페이지 단위로 수행하는 반면에 소거 동작은 메모리 블록 단위로 수 행한다. 하나의 메모리 블록(BLOCK)에 복수의 응용 프로그램들에 대한 데이터가 저장된 상태에서 제1 응용 프로 그램(APP1)이 프로그램된 데이터에 대한 소거 명령을 이슈한 경우에, 메모리 시스템은 상기 제1 응용 프로그램 (APP1)에 대응하는 데이터를 무효화할 수 있다. 도 1B에 도시된 바와 같이, 메모리 블록(BLOCK)에 포함된 데이 터 중 제1 응용 프로그램(APP1)에 대응하는 데이터는 무효(INVALID)이며, 제2 및 제3 응용 프로그램들(APP2, APP3)에 대응하는 데이터는 유효하다. 메모리 블록에 포함된 무효 데이터의 크기가 증가하면 메모리 시스템의 가용 용량이 줄어들게 되므로, 메모리 시스템은 가비지 컬렉션 동작을 수행하여 무효 데이터가 저장된 영역을 가용 영역으로 전환한다. 도 1C는 메모리 블록(BLK)에 대한 가비지 컬렉션 동작을 나타낸 도면이다. 메모리 시스템은 메모리 블록(BLK)에 저장된 유효 데이터를 빈 메모리 블록에 카피한다. 도 1C를 참조하면, 메 모리 시스템은 무효 데이터인 제1 응용 프로그램에 대한 데이터를 제외하고, 유효 데이터인 제2 및 제3 응용 프 로그램들(APP2,APP3)에 대한 데이터를 빈 메모리 블록에 카피한다. 메모리 시스템은 유효 데이터를 빈 메모리 블록에 카피한 이후에, 메모리 블록에 저장된 모든 유효 데이터를 무효화하고, 상기 메모리 블록에 대해 소거 동작을 수행한다. 메모리 시스템은 무효 데이터를 포함하는 메모리 블록에서 유효 데이터만 빈 메모리 블록으로 카피한 이후에, 상기 메모리 블록에 대한 소거 동작을 수행하여 가비지 컬렉션 동작을 수행한다. 하나의 응용 프로그램에서 발생한 소거 명령으로 인해 메모리 블록에 포함된 무효 데이터의 크기가 증가한다. 무효 데이터를 제거하기 위한 가비지 컬렉션이 발생하면 진행 중이던 리드 및 프로그램 동작이 일시적으로 중단 되므로, 서비스 품질이 하락하는 문제가 발생한다. 존드 네임 스페이스(Zoned Namespace)를 활용한 데이터 처리 시스템은 복수의 응용 프로그램들 간 성능 간섭과 가비지 컬렉션 동작의 발생으로 인한 성능 저하 문제를 해결 할 수 있다. 도 2는 존드 네임 스페이스를 활용한 데이터 처리 시스템의 저장방법을 설명하기 위한 도면이다. 존드 네임 스페이스(Zoned-Namespace: ZNS)는 네임 스페이스를 존(Zone) 단위로 나눠 사용하는 기술을 의미한다. 네임 스페이스는 논리 블록으로 포맷할 수 있는 비휘발성 메모리의 크기를 의미한다. 존드 네임 스페이스를 활용한 데이터 처리 시스템에서, 복수의 응용 프로그램들은 각자 정해진 존의 논리 블록 주소들에 순차 적으로 데이터를 저장한다. 복수의 논리 블록 주소들이 존 단위로 나눠질 뿐만 아니라, 메모리 시스템의 물리 영역들도 존 단위로 나눠진다. 하나의 존은 동일한 응용 프로그램에 대한 데이터를 저장하므로, 하나의 존 안에 저장된 데이터의 속성은 유사하다. 또한, 존에 포함된 논리 블록 주소들은 연속적이며, 존드-네임 스페이스를 적용한 메모리 시스템에서 각 존에 대응하는 메모리 블록은 항상 시퀄셜하게 프로그램된다. 도 2에 도시된 도면을 참조하면, 하나의 네임 스페이스(NAMESPACE)는 복수의 존들(ZONE_1-ZONE_N)로 구성된다. 상기 복수의 존들(ZONE_1-ZONE_N) 각각의 크기는 모두 동일하다. 하나의 응용 프로그램은 하나의 존에 대응할 수 있으며, 경우에 따라 하나의 응용 프로그램은 복수의 존들에 대응할 수도 있다. 하나의 존은 연속된 복수의 논리 블록 주소들을 포함한다. 메모리 장치 내부 영역 또한 존 단위로 나눠지며, 논리 영역에서의 존들은 물리 영역에서의 존들과 각각 대응된다. 물리 영역에서의 존들 각각의 크기는 동일하며, 상기 존들 각각의 크기는 이 레이즈 단위의 정수배일 수 있다. 일 예로 하나의 존은 이레이즈 단위인 메모리 블록에 대응할 수 있으며, 도 2 에 도시된 제1 내지 제N 메모리 블록들(BLK_1-BLK_N)은 각각 제1 내지 제 N 존들(ZONE_1-ZONE_N)에 대응된다. 제1 내지 제3 응용 프로그램들(APP1-APP3)이 각각 제1 내지 제3 존들(ZONE_1-ZONE_3)에 대응하는 경우를 예로 들면, 제1 응용 프로그램(APP1)는 제1 존(ZONE_1)에 포함된 논리 블록 주소들에 데이터를 저장한다. 상기 제1 존(ZONE_1)에 포함된 논리 블록 주소들은 연속적이며, 호스트는 메모리 시스템으로 프로그램 커맨드와 함께 존 에 대한 식별 정보 및 프로그램 데이터를 제공한다. 메모리 시스템은 상기 존에 대한 식별 정보에 기초하여 제1 존(ZONE_1)에 포함된 논리 블록 주소들에 저장된 데이터를 상기 제1 존(ZONE_1)에 대응하는 제1 메모리 블록 (BLK_1)에 순차 프로그램한다. 마찬가지 방식으로, 제2 메모리 블록(BLK_2) 및 제3 메모리 블록(BLK_3)에 각각 제2 존(ZONE_2) 및 제3 존 (ZONE_3)에 대한 데이터가 저장된다. 존드 네임 스페이스를 활용한 메모리 시스템의 경우에, 서로 다른 응용 프 로그램으로부터 제공된 데이터는 존 단위로 구분된 메모리 장치의 내부 영역들 중 서로 다른 영역에 저장된다. 따라서, 하나의 응용 프로그램에서의 소거 동작은 다른 응용 프로그램에 대한 데이터에 영향을 주지 아니한다. 존드 네임 스페이스가 적용된 메모리 시스템의 경우에, 존에 대응하는 메모리 블록에 데이터가 순차적으로 저장 된 이후, 존 단위로 삭제되므로 가비지 컬렉션 동작이 필요 없게 된다. 따라서, 존드 네임 스페이스가 적용된 메모리 시스템의 경우에 라이트 증폭 팩터(Write Amplification Factor: WAF)가 매우 낮은 값을 갖는다. WAF는 가비지 컬렉션 등을 이유로 메모리 시스템 내부에서 추가적인 프로그램이 발생하는 정도를 의미하며, 메모리 장 치에서 실제 프로그램된 크기를 호스트 요청에 따라 프로그램된 크기로 나누어 구한다. 가비지 컬렉션 동작을 수행하지 아니할 경우에 WAF의 값은 '1'의 값에 가까울 수 있다. 메모리 시스템은 프로그램할 수 있는 횟수가 한정되어 있으며, 존드 네임 스페이스를 활용한 메모리 시스템의 경우에 가비지 컬렉션 동작에 따른 프로그램 동작이 발생하지 아니하므로, 메모리 시스템의 수명이 증가한다. 또한, 오버 프로비전 영역의 크기가 감소된다. 오버 프로비전 영역은 호스트가 인지하지 못하는 메모리 장치 내 부의 예비 영역으로, 가비지 컬렉션 등 메모리 시스템의 백그라운드 동작을 위한 영역이다. 종래의 메모리 시스 템은 논리 블록 주소와 물리 주소 사이의 맵핑 정보에 대한 테이블을 컨트롤러 내부의 휘발성 메모리에 저장한 다. 반면, 존드 네임 스페이스를 활용한 메모리 시스템의 경우에, 메모리 장치를 동일 크기의 존 단위로 나눠서 사용하고, 존 내에서 시퀀셜하게 프로그램을 수행하므로 별도의 맵핑 테이블이 필요하지 않다. 따라서, 존드 네 임 스페이스를 활용한 메모리 시스템은 상기 휘발성 메모리를 효율적으로 사용할 수 있다. 호스트가 메모리 시스템으로 한번에 제공하는 데이터의 크기는 메모리 시스템의 프로그램 단위와 상이하다. TLC 메모리 장치의 경우에 상기 프로그램 단위는 LSB(Least Significant Bit) 페이지, CSB(Central Significant Bit) 페이지 및 MSB(Most Significant Bit) 페이지의 크기를 합한 값일 수 있으며, 상기 프로그램 단위는 상기 호스트가 상기 메모리 시스템으로 한번에 제공하는 데이터의 크기보다 크다. 따라서 메모리 시스템은 호스트와 메모리 장치 사이에 위치한 컨트롤러 내부의 라이트 버퍼에 프로그램 데이터를 임시 저장하고, 저장된 데이터의 사이즈가 프로그램 단위를 만족하면 메모리 블록에 상기 데이터를 프로그램한다. 메모리 시스템은 존 별로 라이 트 버퍼의 영역을 할당할 수 있으며, 하나의 존에 할당되는 영역의 크기는 프로그램 단위일 수 있다. 오픈 존은 라이트 버퍼의 영역이 할당된 존을 의미하며, 메모리 시스템은 오픈 존에 대한 메모리 블록에 대해서만 프로그 램 동작을 수행한다. 라이트 버퍼는 휘발성 메모리로 구현되므로, 메모리 시스템의 전원이 페일되면 라이트 버퍼에 저장된 데이터가 상실될 우려가 존재한다. 따라서, 메모리 시스템은 비상 전원을 구비하며, 전원 페일이 발생할 경우에 메모리 시스템은 비상 전원에 의해 공급되는 전원을 사용하여 라이트 버퍼에 저장된 데이터를 비휘발성 메모리에 백업한다. 비상 전원이 전원을 제공할 수 있는 시간은 제한적이며, 제한된 시간동안 메모리 시스템이 라이트 버퍼로 부터 비휘발성 메모리로 백업할 수 있는 데이터의 크기도 제한적이다. 따라서, 라이트 버퍼의 사이즈는 비상 전 원에 의한 전원이 공급되는 시간 동안 백업될 수 있는 데이터의 크기로 정해진다. 라이트 버퍼의 사이즈는 제한 적이므로, 라이트 버퍼의 영역들이 할당되는 존들의 개수도 제한적이다. 따라서, 동시에 존재할 수 있는 오픈 존들의 개수는 제한적이며, 동시에 존재할 수 있는 오픈 존들의 개수가 제한되면 동시에 구동할 수 있는 응용 프로그램들의 개수가 제한된다. 데이터 센터가 서버에 연결된 경우에 복수의 응용 프로그램들을 동시에 구동할 필요가 크므로, 동시에 구동할 수 있는 응용 프로그램들의 개수가 제한되는 것은 문제이다. 도 3은 존이 가질 수 있는 상태를 설명하기 위한 도면이다. 존들 각각이 가질 수 있는 상태에 따라 존들은 크게 액티브 존(ACTIVE ZONES)과 인액티브 존(INACTIVE ZONES)으 로 구분된다. 액티브 존(ACTIVE ZONES)은 오픈 존(OPEN ZONES)과 클로즈드 존(CLOSED)을 포함하며, 인액티브 존(INACTIVE ZONES)은 엠티 존(EMPTY)과 풀 존(FULL)을 포함한다. 오픈 존의 개수는 전술한 바와 같이 라이트 버퍼의 용량에 의해 제한된다. 뿐만 아니라 클로즈드 존의 개수도 제한되며, 따라서 액티브 존(ACTIVE ZONES)의 개수는 제한된다. 앞서 설명한 오픈 존(OPEN ZONES)은 명시적 오픈 존(Explicitly Opened Zone)과 묵시적 오픈 존(Implicitly Opened Zone)으로 구분될 수 있다. 호스트가 명시적으로 어떤 존을 오픈 존으로 전환시키라는 커맨드를 메모리 시스템으로 제공한 경우에, 상기 커맨드에 따라 전환된 오픈 존은 명시적 오픈 존(OPENED_EXP)이다. 만약 호스 트가 명시적으로 커맨드를 제공하지 아니하고 프로그램 커맨드 및 존에 대한 식별 정보만 메모리 시스템으로 제 공한 경우에, 메모리 시스템은 자체적으로 상기 존을 오픈 존으로 전환하고 프로그램 동작을 수행한다. 메모리 시스템에 의해 자체적으로 전환되는 오픈 존은 묵시적 오픈 존(OPENED_IMP)이다. 라이트 버퍼의 모든 영역들이 오픈 존들에 할당된 상태에서, 오픈 존이 아닌 다른 존에 대한 프로그램 커맨드가 발생한 경우에, 메모리 시스 템은 오픈 존들 중 어느 하나의 오픈 존을 클로즈드 존(CLOSED)으로 전환한다. 클로즈드 존은 오픈 존으로부터 전환될 수 있다. 메모리 시스템은 오픈 존에 대응하는 메모리 블록의 모든 페이지들에 데이터가 모두 프로그램된 경우에, 오픈 존을 클로즈드 존(CLOSED)으로 전환한 이후에 클로즈드 존(CLOSED)을 풀 존(FULL)으로 전환한다. 풀 존(FULL)은 대응하는 메모리 블록에 빈 영역이 존재하지 아니하는 존을 의미한다. 응용 프로그램이 상기 풀 존(FULL) 또는 액티브 존에 대해 소거 명령을 메모리 시스템으로 제공하면, 메모리 시스템은 소거 명령에 대한 존에 대응하는 메모리 블록에 대해 이레이즈 동작을 수행한 이후 상기 존을 엠티 존으로 전환한다. 엠티 존(EMPTY)은 대응하는 메모리 블록이 빈 메모리 블록인 존을 의미한다. 앞서 설명한 바와 같이, 액티브 존에 포함된 존들의 개수는 제한된다. 만약 라이트 버퍼의 모든 영역들이 오픈 존들에 할당되고, 클로즈드 존의 개수도 더 이상 증가시킬 수 없는 상황에서 새로운 응용 프로그램이 구동됨에 따라 오픈 존이 생성 되어야할 경우에, 메모리 시스템은 더 이상 새로운 오픈 존을 할당할 수 없다. 따라서, 액 티브 존에 포함된 존들의 개수가 임계치에 도달한 경우에, 더 이상 동시에 구동할 수 있는 응용 프로그램의 개 수가 증가할 수 없게 되는 문제가 발생한다. 도 4는 동시에 구동할 수 있는 응용 프로그램의 개수가 제한되는 문제를 설명하기 위한 도면이다. 설명의 편의를 위해 라이트 버퍼의 영역들은 총 6개의 존들에 할당되며, 클로즈드 존의 개수는 허용되는 개수에 도달한 경우를 예로 들어 설명한다. 앞서 설명한 바와 같이, 오픈 존에 할당되는 라이트 버퍼의 영역의 크기는 프로그램 단위이며, 오픈 존들마다 할당된 영역의 크기는 동일하다. 도 4는 라이트 버퍼의 영역들이 제1 내지 제6 존들(ZONE1-ZONE6)에 할당된 경 우를 나타낸다. 라이트 버퍼의 각 영역에는 대응되는 존에 대한 프로그램 데이터가 임시적으로 저장된다. 클로 즈드 존의 개수는 허용되는 개수에 도달하여 더 이상 증가할 수 없으며, 제7 존(ZONE7)은 클로즈드 존에 해당하 지 아니한 경우로 설명한다. 제7 존(ZONE7)에 대응하는 응용 프로그램이 프로그램 커맨드(CMD_PGM_ZONE7)를 메모리 시스템으로 제공한 경우 에, 메모리 시스템은 오픈 존에 해당하는 제1 내지 제6 존들(ZONE1-ZONE6) 중 어느 하나의 존을 클로즈드 존으 로 전환하고, 제7 존(ZONE7)에 라이트 버퍼 영역을 할당하여 상기 제7 존(ZONE7)을 오픈 존으로 전환함으로써 상기 제7 존(ZONE7)에 대응하는 응용 프로그램의 프로그램 커맨드(CMD_PGM_ZONE7)에 응답한 프로그램 동작을 수 행할 수 있다. 만약, 클로즈드 존의 개수는 허용되는 개수에 도달한 상태인 경우에, 제1 내지 제6 존들(ZONE1- ZONE6) 중 어느 하나의 존을 클로즈드 존으로 전환하지 못한다. 따라서, 제7 존(ZONE7)에 대응하는 응용 프로그램의 프로그램 커맨드(CMD_PGM_ZONE7)에 응답한 프로그램 동작을 수행하지 못하는 문제가 발생한다. 본 발명의 일 실시예에 따른 메모리 시스템은 오픈 존을 제1 내지 제3 오픈 존들로 세분할 수 있다. 제1 오픈 존(OPENDED_ACT)은 가장 최근에 수신한 프로그램 커맨드에 대응하는 존을 의미하고, 제2 오프 존(OPENED_ALLO C)은 라이트 버퍼의 영역이 할당된 오픈 존을 의미하며, 제3 오픈 존(OPENDED_UNALLOC)은 라이트 버퍼의 영역이 할당되지 아니한 오픈 존을 의미할 수 있다. 메모리 시스템은 액티브 존에 해당하는 존들의 개수가 임계치에 도 달한 상태에서 라이트 버퍼의 영역을 새로운 존에 할당해야 하는 경우에, 제2 오픈 존(OPENED_ALLOC)에 해당하 는 존들 중 어느 하나의 존인 타겟 존을 제3 오픈 존(OPENDED_UNALLOC)으로 전환하고, 상기 타겟 존에 대응하는 라이트 버퍼의 영역에 저장된 데이터를 SLC 버퍼에 프로그램할 수 있다. 이후 상기 타겟 존에 대한 프로그램 커 맨드를 수신할 경우에, 메모리 시스템은 상기 타겟 존을 제1 오프 존(OPEN_AC)로 전환하고, 상기 SLC 버퍼에 저 장된 데이터를 리드한 이후에, 상기 리드된 데이터와 상기 프로그램 커맨드에 대응하는 데이터로 프로그램 단위 를 형성하여 메모리 블록에 프로그램할 수 있다. 상기 일 예로, 메모리 블록은 하나의 셀에 복수 개의 비트들을 저장할 수 있는 멀티 레벨 셀들을 포함할 수 있다. 본 발명의 일 실시예에 따르면, 메모리 시스템은 SLC 버퍼를 호스트 데이터를 임시 저장하는 메모리로 사용함으로써 동시에 구동되는 응용 프로그램들의 개수를 증가시킬 수 있다. 도 5는 본 발명의 일 실시예에 따른 데이터 처리 시스템에 대한 블록도이다. 도 5를 참조하면, 데이터 처리 시스템은, 호스트 및 메모리 시스템을 포함한다. 그리고, 호스트는, 전자 장치, 예컨대 휴대폰, MP3 플레이어, 랩탑 컴퓨터 등과 같은 휴대용 전자 장치들, 또는 데스크탑 컴퓨터, 게임기, TV, 프로젝터 등과 같은 전자 장치들을 포함, 즉 유무선 전자 장치들을 포함한 다. 또한, 호스트는, 적어도 하나의 운영 시스템(OS: operating system) 혹은 복수의 운영 시스템들을 포함할 수 있으며, 또한 사용자의 요청에 상응한 메모리 시스템과의 동작 수행을 위해 운영 시스템을 실행한다. 여기서, 호스트는, 사용자 요청에 해당하는 복수의 커맨드들을 메모리 시스템으로 전송하며, 그에 따 라 메모리 시스템에서는 커맨드들에 해당하는 동작들, 즉 사용자 요청에 상응하는 동작들을 수행한다. 운 영 시스템은 호스트의 기능 및 동작을 전반적으로 관리 및 제어하고, 데이터 처리 시스템 또는 메모 리 시스템을 사용하는 사용자와 호스트 간에 상호 동작을 제공한다. 또한, 메모리 시스템은, 호스트의 요청에 응답하여 동작하며, 특히 호스트에 의해서 액세스되는 데이터를 저장한다. 다시 말해, 메모리 시스템은, 호스트의 주 기억 장치 또는 보조 기억 장치로 사 용될 수 있다. 여기서, 메모리 시스템은 호스트와 연결되는 호스트 인터페이스 프로토콜에 따라, 다 양한 종류의 저장 장치(솔리드 스테이트 드라이브(SSD: Solid State Drive), MMC, eMMC(embedded MMC))들 중 어느 하나로 구현될 수 있다. 아울러, 메모리 시스템을 구현하는 저장 장치들은, DRAM(Dynamic Random Access Memory), SRAM(Static RAM) 등과 같은 휘발성 메모리 장치와, ROM(Read Only Memory), MROM(Mask ROM), PROM(Programmable ROM), EPROM(Erasable ROM), EEPROM(Electrically Erasable ROM), FRAM(Ferromagnetic ROM), PRAM(Phase change RAM), MRAM(Magnetic RAM), RRAM(Resistive RAM), 플래시 메모리 등과 같은 비휘발성 메모리 장치로 구현될 수 있다. 메모리 시스템은 메모리 장치, 및 컨트롤러를 포함한다. 여기서, 컨트롤러 및 메모리 장치는 하나의 반도체 장치로 집적될 수 있다. 일 예로, 컨트롤러 및 메모리 장치는 하나의 반도체 장치로 집적되어 SSD, PC 카드(PCMCIA: Personal Computer Memory Card International Association), SD 카드(SD, miniSD, microSD, SDHC), 유니버설 플래시 기억 장치(UFS) 등으로 구성할 수 있다. 또한, 다른 일 예로, 메모리 시스템은, 컴퓨팅 시스템을 구성하는 다양한 구성 요소들 중 하나(컴퓨터, 스마트폰, 휴대용 게임기) 등을 구성할 수 있다. 한편, 메모리 시스템에서의 메모리 장치는, 전원이 공급되지 않아도 저장된 데이터를 유지할 수 있으 며, 특히 라이트(write) 동작을 통해 호스트로부터 제공된 데이터를 저장하고, 리드(read) 동작을 통해 저 장된 데이터를 호스트로 제공한다. 여기서, 메모리 장치는, 복수의 메모리 블록(memory block)들을 포함하며, 각각의 메모리 블록들은, 복수의 페이지들(pages)을 포함하며, 또한 각각의 페이지들은, 복수의 워드 라인(WL: Word Line)들이 연결된 복수의 메모리 셀들을 포함한다. 또한, 메모리 장치는, 복수의 메모리 블 록들(152,154,156)이 각각 포함된 복수의 플래인들(plane)을 포함하며, 특히 복수의 플래인들이 각각 포함된 복수의 메모리 다이(memory die)들을 포함할 수 있다. 아울러, 메모리 장치는, 비휘발성 메모리 장치, 일 예 로 플래시 메모리가 될 수 있으며, 이때 플래시 메모리는 3차원(dimension) 입체 스택(stack) 구조가 될 수 있 다. 그리고, 메모리 시스템에서의 컨트롤러는, 호스트로부터의 요청에 응답하여 메모리 장치를 제어한다. 예컨대, 컨트롤러는, 메모리 장치로부터 리드된 데이터를 호스트로 제공하고, 호스트 로부터 제공된 데이터를 메모리 장치에 저장하며, 이를 위해 컨트롤러는, 메모리 장치의 리드, 라이트, 프로그램(program), 이레이즈(erase) 등의 동작을 제어한다. 메모리 시스템은 앞서 도 2를 참조하여 설명한 존드 네임 스페이스가 적용된 메모리 시스템일 수 있 다. 따라서, 메모리 장치에 포함된 메모리 블록들 각각은 복수의 존들에 대응할 수 있으며, 각 메모리 블 록에 데이터가 시퀀셜하게 프로그램될 수 있다. 컨트롤러는 존 정보 관리부, 라이트 버퍼 관리부, SLC 버퍼 관리부, 낸드 관리부, 존 상태 관리부 및 메모리를 포함할 수 있다. 여기서, 메모리는, 휘발성 메모리로 구현될 수 있으며, 예컨대 정적 랜덤 액세스 메모리(SRAM: Static Random Access Memory), 또는 동적 랜덤 액세스 메모리(DRAM: Dynamic Random Access Memory) 등으로 구현될 수 있다. 아울러, 메모리는 컨트롤러의 내부에 존재하거나, 또는 컨트롤러의 외부에 존재할 수 있으며, 이때 메모리 인터페이스를 통해 컨트롤러로부터 데이터가 입출력되는 외부 휘발성 메모리로 구현 될 수도 있다. 또한, 메모리는, 호스트와 메모리 장치 간 데이터 라이트 및 리드 등의 동작을 수행하기 위해 필요한 데이터, 및 데이터 라이트 및 리드 등의 동작 수행 시의 데이터를 저장하며, 이러한 데이터 저장을 위해, 프로그램 메모리, 데이터 메모리, 라이트 버퍼(buffer)/캐시(cache), 리드 버퍼/캐시, 데이터 버퍼/캐시, 맵(map) 버퍼/캐시 등을 포함한다. 도 6은 본 발명의 일 실시예에 따른 제1 내지 제3 오픈 존들을 설명하기 위한 도면이다. 제1 오픈 존(OPENDED_ACT)은 가장 최근에 수신한 프로그램 커맨드에 대한 존을 의미한다. 메모리 시스템은 존의 식별자에 대한 정보(ID_ZONE) 및 상기 존에 대한 정보(INFO_ZONE)을 수신하면 프로그램 커맨드에 대한 존 의 상태를 제1 오픈 존(OPENED_ACT)으로 설정할 수 있다. 메모리 시스템는 라이트 버퍼의 영역을 제1 오픈 존(OPENDED_ACT)에 할당할 수 있으며, 상기 제1 오픈 존 (OPENDED_ACT)에 할당되는 영역의 크기는 프로그램 단위보다 클 수 있다. 일 예로, 상기 제1 오픈 존 (OPENED_ACT)에 할당되는 영역의 크기는 최소 프로그램 단위의 두 배일 수 있다. 메모리 시스템은 프로그 램 커맨드에 대한 존의 상태를 제1 오픈 존(OPENED_ACT)으로 설정한 이후, SLC 버퍼에 상기 존에 대한 데이터가 저장되어 있는지 여부를 확인할 수 있다. 상기 SLC 버퍼에 상기 존에 대한 데이터가 저장되어 있는 경우에, 메 모리 시스템은 SLC 버퍼에 저장된 데이터를 리드하고, 리드된 데이터와 라이트 버퍼에 저장된 데이터로 프 로그램 단위를 구성한 뒤, 상기 프로그램 단위를 구성하는 데이터를 메모리 블록에 프로그램할 수 있다. 상기 메모리 블록은 멀티-레벨 셀을 포함할 수 있다. 후술하는 바와 같이, 메모리 시스템은 SLC 버퍼로부터 데이터를 리드하는 시간동안 라이트 버퍼에 버퍼링 된 데이터를 프로그램하지 못하고 대기함에 따라 발생하는 성능 저하를 방지하기 위해, 파이프라이닝 스킴을 사 용할 수 있다. 구체적으로, 라이트 버퍼에 제1 및 제2 데이터가 순차 버퍼링되고, 상기 제1 데이터는 SLC 버퍼 에 저장된 데이터와 프로그램 단위를 구성할 수 있으며, 상기 제2 데이터는 프로그램 단위를 구성하는 경우에, 메모리 시스템은 상기 SLC 버퍼로부터 데이터를 리드하는 동안 상기 제2 데이터를 프로그램하고, 이후 상 기 프로그램 단위를 구성하는 제1 데이터와 SLC 버퍼로부터 리드된 데이터를 프로그램할 수 있다. 따라서, 라이 트 버퍼는 SLC 버퍼로부터 데이터를 리드하는 동안 프로그램할 데이터를 저장할 수 있는 공간이 추가적으로 필 요하므로, 제1 오픈 존(OPEN_ACT)에 대해 할당된 라이트 버퍼 영역의 크기는 프로그램 단위보다는 클 수 있다. 제2 오픈 존(OPENED_ALLOC)은 프로그램 단위의 라이트 버퍼의 영역이 할당된 존을 의미한다. 메모리 시스템 은 새로운 프로그램 커맨드를 수신하여 제1 오픈 존(OPEND_ACT)에 해당하는 존이 변경될 때, 기존의 존의 상태를 제2 오픈 존(OPENED_ALLOC)으로 변경할 수 있다. 예를 들어, 제1 존의 상태가 제1 오픈 존(OPEND_ACT)인 상태에서 제2 존에 대한 프로그램 커맨드를 수신하면, 메모리 시스템은 상기 제2 존의 상태를 제1 오픈 존 (OPENED_ACT)으로 변경하고, 상기 제1 존의 상태를 제2 오픈 존(OPENED_ALLOC)으로 변경할 수 있다. 메모리 시 스템은 제2 오픈 존(OPEND_ALLOC)에 대해 라이트 버퍼의 영역을 할당할 수 있으며, 할당되는 영역의 크기는 프로그램 단위일 수 있다. 제3 오픈 존(OPENED_UNALLOC)은 라이트 버퍼의 영역이 할당되지 아니하고, SLC 버퍼에 데이터가 저장된 존을 의 미한다. 라이트 버퍼의 모든 영역들이 할당된 상태에서, 라이트 버퍼의 영역이 할당되지 아니한 존에 대한 프로 그램 커맨드를 수신하면, 메모리 시스템은 라이트 버퍼의 영역이 할당된 존들 중 일정 조건 하에 하나의 존의 상태를 제3 오픈 존(OPEND_UNALLOC)으로 변경할 수 있다. 메모리 시스템은 라이트 버퍼에 저장된 제3 오픈 존(OPENED_UNALLOC)에 대한 데이터를 SLC 버퍼에 저장할 수 있다. 추후 상기 제3 오픈 존 (OPENED_UNALLOC)에 대한 프로그램 커맨드를 수신하면, 메모리 시스템은 상기 제3 오픈 존 (OPENED_UNALLOC)을 제1 오픈 존(OPENED_ACT)으로 변경하고, SLC 버퍼에 저장된 데이터를 리드할 수 있다. 메 모리 시스템은 리드된 데이터와 프로그램 데이터로 프로그램 단위를 구성한 이후 프로그램 동작을 수행할 수 있다. 메모리 시스템은 라이트 버퍼의 영역이 할당된 존들 중 묵시적 오픈 존에 해당하는 존을 우선적으로 제3 오픈 존(OPENED_UNALLC)으로 변경할 수 있다. 묵시적 오픈 존은 호스트의 명시적 명령에 의해 생성된 존이 아니 라, 메모리 시스템이 호스트로부터 수신한 프로그램 커맨드에 응답하여 자체적으로 생성한 존이므로, 메모리 시스템은 명시적 오픈 존에 대해 우선적으로 라이트 버퍼 영역을 할당할 수 있다. 라이트 버퍼의 영역이 할당된 존들 중 묵시적 오픈 존에 해당하는 존이 복수개인 경우에, 메모리 시스템은 라이트 버퍼에 저장된 데이터의 양이 적은 존을 우선적으로 제3 오픈 존으로(OPENED_UNALLOC)으로 변경할 수 있 다. 메모리 시스템은 존의 상태를 제3 오픈 존으로(OPEND_UNALLOC)으로 변경할 때, 라이트 버퍼에 저장된 상기 제3 오픈 존(OPEND_UNALLOC)에 대한 데이터를 SLC 버퍼에 저장할 수 있다. 또한 상기 SLC 버퍼에 저장된 데이터는 추후 상기 제3 오픈 존(OPEND_UNALLOC)에 대한 프로그램 커맨드가 수신되면, 상기 SLC 버퍼로부터 리 드될 수 있다. 상기 SLC 버퍼에 데이터가 프로그램되는 시간 및 상기 SLC 버퍼로부터 데이터가 리드되는 시간은 성능 저하를 유발할 수 있으므로, 메모리 시스템은 성능 저하를 최소화하고자 SLC 버퍼에 프로그램/리드되는 데 이터의 사이즈가 가장 작은 존을 우선적으로 제3 오픈 존으로(OPEND_UNALLOC)으로 변경할 수 있다. 라이트 버퍼의 영역이 할당된 존들 중 묵시적 오픈 존에 해당하고, 라이트 버퍼에 저장된 데이터의 양이 동일한 존이 복수 개 존재하는 경우에, 메모리 시스템은 가장 오래 전에 프로그램된 존을 우선적으로 제3 오픈 존 (OPNED_UNALLOC)으로 변경할 수 있다. 메모리 시스템은 보다 빈번히 프로그램되는 존에 대해 우선적으로 라이트 버퍼 영역을 할당함으로써 프로그램 성능을 향상시킬 수 있다. 도 7A 내지 7D는 본 발명의 일 실시예에 따라 존의 상태를 제1 내지 제3 오픈 존들로 변경하는 방법을 설명하기 위한 도면이다. 도 7A 내지 도 7D는 도 4와 마찬가지로 설명의 편의를 위해 라이트 버퍼의 영역들은 총 6개의 존들에 할당되며, 클로즈드 존의 개수는 허용되는 개수에 도달한 경우를 예로 들어 설명한다. 도 7A는 라이트 버퍼의 영역들이 제 1 내지 제6 존들(ZONE1-ZONE6)에 할당된 경우를 나타내며, 제1 존(ZONE1)의 상태는 제1 오픈 존(OPEN_ACT)이고, 제2 내지 제6 존들(ZONE2-ZONE6)의 상태는 제2 오픈 존(OPEN_ALLOC)인 경우를 나타낸다. 라 이트 버퍼의 각 영역에는 대응되는 존에 대한 프로그램 데이터가 임시적으로 저장된다. 클로즈드 존의 개수는 허용되는 개수에 도달하여 더 이상 증가할 수 없으며, 제7 존(ZONE7)은 클로즈드 존에 해당하지 아니한 경우로 설명한다. 제2 내지 제6 오픈 존들(ZONE2-ZONE6)에 할당되는 라이트 버퍼의 영역의 크기는 프로그램 단위이며, 제1 오픈 존(ZONE1)에 할당되는 라이트 버퍼의 영역의 크기는 프로그램 단위보다 클 수 있다. 메모리 시스템은 호스 트로부터 제7 존에 대한 프로그램 커맨드(CMD_PGM_ZONE7)을 수신하면, 제1 내지 제6 존들(ZONE1-ZONE6) 중 어느 하나의 존의 상태를 제3 오픈 존(OPEN_UNALLOC)으로 변경할 수 있다. 앞서 설명한 바와 같이, 메모리 시스템 은 일정 조건 하에 제1 내지 제6 존들(ZONE1-ZONE6) 중 제3 오픈 존(OPEN_UNALLOC)으로 변경할 존을 결정 할 수 있다. 예를 들어, 제1 존(ZONE1)은 묵시적 오픈 존에 해당하고, 제2 내지 제6 존들(ZONE2-ZONE6)는 명시 적 오픈 존에 해당하는 경우에, 메모리 시스템은 상기 제1 존(ZONE1)의 상태를 제3 오픈 존 (OPENED_UNALLOC)으로 변경할 수 있다. 이후 메모리 시스템은 라이트 버퍼의 영역들 중 제1 존(ZONE1)에 대응하는 영역에 저장된 데이터를 SLC 버퍼에 저장할 수 있다. 도 7B는 라이트 버퍼의 영역들 중 제1 존(ZONE1)에 대응하는 영역에 저장된 데이터를 SLC 버퍼에 저장하는 방법 을 설명하기 위한 도면이다. 라이트 버퍼(WRITE BUFFER)는 컨트롤러에 포함될 수 있으며, DRAM과 같은 휘발성 메모리로 구현될 수 있다. 라 이트 버퍼(WRITE BUFFER)의 각 영역에는 제1 내지 제6 존들에 대한 데이터(DATA_ZONE1-DATA_ZONE6)가 저장될 수 있다. SLC BUFFER는 메모리 장치에 포함된 비휘발성 메모리 블록이며, 하나의 셀에 한 비트의 데이터를 저장 할 수 있는 싱글-레벨 셀들을 포함할 수 있다. 메모리 시스템은 제1 존(ZONE1)의 상태를 제3 오픈 존(OPEND_UNALLOC)으로 변경한 이후에, 라이트 버퍼 (WRITE BUFFER)에 저장된 제1 존에 대한 데이터(DATA_ZONE1)을 SLC 버퍼에 프로그램할 수 있다. 메모리 시스템 은 상기 제1 존에 대한 데이터(DATA_ZONE1)가 SLC 버퍼에 저장되면, 상기 제1 존에 대한 데이터 (DATA_ZONE1)가 저장된 물리 주소를 존에 대한 정보에 기록할 수 있다. 추후 상기 제1 존(ZONE1)에 대한 프로그 램 커맨드를 수신하면, 메모리 시스템은 상기 존에 대한 정보에 기초하여 SLC 버퍼로부터 상기 제1 존에 대한 데이터(DATA_ZONE1)를 리드할 수 있다. 메모리 시스템은 상기 제1 존에 대한 데이터(DATA_ZONE1)을 SLC 버퍼에 저장한 이후에, 제7 존(ZONE7)의 상태를 제1 오픈 존(OPENED_ACT)로 변경할 수 있다. 메모리 시스템은 기존에 제1 존(ZONE1)에 할당된 라이 트 버퍼의 영역을 제7 존(ZONE7)에 할당할 수 있다. 상기 제7 존(ZONE7)에 할당된 영역의 크기는 프로그램 단위 보다 클 수 있다. 메모리 시스템은 라이트 버퍼에 상기 제7 존(ZONE7)에 대한 데이터를 저장하고, 저장된 데이터가 프로그램 단위를 구성하면 메모리 블록에 프로그램할 수 있다. 도 7C는 라이트 버퍼의 영역들이 제2 내지 제7 존들(ZONE2-ZONE7)에 할당된 경우를 나타내며, 제7 존(ZONE7)의 상태는 제1 오픈 존(OPEN_ACT)이고, 제2 내지 제6 존들(ZONE2-ZONE6)의 상태는 제2 오픈 존(OPEN_ALLOC)인 경 우를 나타낸다. 또한, 라이트 버퍼의 영역이 할당되지 아니한 제1 존(ZONE1)의 상태는 제3 오픈 존 (OPENED_UNALLOC)이다. 메모리 시스템은 제1 존에 대한 프로그램 커맨드(CMD_PGM_ZONE1)을 호스트로부터 수신하면, 제2 내지 제7 존들(ZONE2-ZONE7) 중 어느 하나의 존의 상태를 제3 오픈 존(OPENED_UNALLOC)으로 변경할 수 있다. 일 예로, 제2 내지 제7 존들(ZONE2-ZONE7)이 모두 명시적 오픈 존들인 경우에, 메모리 시스템은 라이트 버퍼에 저장 된 제2 내지 제7 존들(ZONE2-ZONE7)에 대한 데이터의 사이즈를 비교할 수 있다. 라이트 버퍼에 저장된 제2 내지 제7 존들(ZONE2-ZONE7)에 대한 데이터 중 제2 존(ZONE2)에 대한 데이터의 사이즈가 가장 작은 경우에, 메모리 시스템은 상기 제2 존(ZONE2)의 상태를 제3 오픈 존(OPENED_UNALLOC)으로 변경할 수 있다. 메모리 시스템 은 앞서 도 7B를 참조하여 설명한 바와 같이, 라이트 버퍼에 저장된 제2 존(ZONE2)에 대한 데이터를 SLC 버퍼에 프로그램할 수 있다. 메모리 시스템은 제2 존(ZONE2)에 대한 데이터가 저장된 물리 주소를 존에 대 한 정보에 기록할 수 있다. 메모리 시스템은 제7 존(ZONE7)의 상태를 제2 오픈 존(OPENED_ALLOC)으로 변경할 수 있다. 메모리 시스템 은 제2 존(ZONE2)의 상태를 제3 오픈 존(OPENED_UNALLOC)으로 변경하고, 제7 존(ZONE7)의 상태를 제2 오 픈 존(OPENED_ALLOC)으로 변경한 이후에, 제1 존(ZONE1)의 상태를 제1 오픈 존(OPENED_ACT)로 변경할 수 있다. 메모리 시스템은 제1 존(ZONE1)에 대해 라이트 버퍼 영역을 할당할 수 있으며, 할당된 영역의 크기는 프로 그램 단위보다 클 수 있다. 메모리 시스템은 라이트 버퍼에 호스트로부터 제공된 데이터를 저장할 수 있으 며, 존에 대한 정보에 기초하여 SLC 버퍼에 제1 존(ZONE1)에 대한 데이터가 저장되어 있는지 여부를 확인할 수 있다. SLC 버퍼에 제1 존(ZONE1)에 대한 데이터가 저장된 경우에 메모리 시스템은 SLC 버퍼로부터 상기 제 1 존(ZONE1)에 대한 데이터를 리드한 이후에 라이트 버퍼에 저장된 데이터와 함께 메모리 블록에 프로그램할 수 있다. 도 7D는 SLC 버퍼로부터 제1 오픈 존에 대한 데이터를 리드한 이후에 라이트 버퍼에 저장된 데이터와 함께 프로 그램하는 방법을 설명하기 위한 도면이다. 도 7D에 도시된 SLC 버퍼는 도 7B에 도시된 SLC 버퍼와 동일한 버퍼일 수 있다. 라이트 버퍼에는 호스트로부터 제공된 제1 존에 대한 데이터(DATA_ZONE1`)이 저장되어 있으며, SLC 버퍼에는 제1 존(ZONE1)의 상태가 제3 오픈 존(OPENED_UNALLOC)으로 변경될 때 라이트 버퍼로부터 제공된 제1 존에 대한 데이터(DATA_ZONE1)가 저장될 수 있다. 설명의 편의를 위해 라이트 버퍼에 저장된 제1 존에 대한 데이터(DATA_ZONE1`)와 SLC 버퍼에 저장된 제1 존에 대한 데이터(DATA_ZONE1)의 사이즈의 합은 프로그램 단위를 구성하는 경우를 예로 들어 설명한다. 메모리 시스템은 존에 대한 정보에 기초하여 SLC 버퍼로부터 제1 존에 대한 데이터(DATA_ZONE1)를 리드할 수 있다. SLC 버퍼로부터 제1 존에 대한 데이터(DATA_ZONE1)를 리드하는 동안 라이트 버퍼에 저장된 제1 존에 대한 데이터(DATA_ZONE1`)는 메모리 블록(TLC BLK)에 프로그램되지 아니할 수 있다. 상기 메모리 블록(TLC BL K)은 셀 당 3 비트의 데이터를 저장하는 메모리 블록을 일 예로 설명한다. 전술한 바와 같이 존드 네임 스페이스를 사용하는 데이터 처리 시스템의 경우에, 각 존에 대응하는 메모리 블록에 대해 시퀀셜 프로그램이 수 행될 수 있다. 시퀀셜 프로그램은 연속되는 논리 블록 주소를 갖는 데이터가 메모리 블록에 프로그램되는 경우 를 의미한다. 일 예로, 상기 연속된 논리 블록 주소는 오름차순일 수 있다. 따라서, 커맨드가 제공된 순서에 따 라 논리 블록 주소의 크기가 상이하며, 먼저 제공된 커맨드에 대응하는 논리 블록 주소는 나중에 제공된 커맨드 에 대응하는 논리 블록 주소보다 값이 작을 수 있다. SLC 블록에 저장된 제1 존에 대한 데이터(DATA_ZONE1)의 논리 블록 주소는 라이트 버퍼에 저장된 제1 존에 대한 데이터(DATA_ZONE1`)의 논리 블록 주소보다 작을 수 있 으며, 만약 라이트 버퍼에 저장된 제1 존에 대한 데이터(DATA_ZONE1`)가 SLC 블록에 저장된 제1 존에 대한 데이 터(DATA_ZONE1)보다 먼저 프로그램될 경우에 연속성이 유지되지 못하는 경우가 발생할 수 있다. 따라서, SLC 버 퍼로부터 제1 존에 대한 데이터(DATA_ZONE1)를 리드하는 동안 라이트 버퍼에 저장된 제1 존에 대한 데이터 (DATA_ZONE1`)는 메모리 블록(TLC BLK)에 프로그램되지 아니할 수 있다. 메모리 시스템은 SLC 버퍼로부터 제1 존에 대한 데이터(DATA_ZONE1)를 리드한 이후에, 상기 리드된 제1 존 에 대한 데이터(DATA_ZONE1)와 라이트 버퍼에 저장된 제1 존에 대한 데이터(DATA_ZONE1`)를 메모리 블록(TLC BLK)에 프로그램할 수 있다. SLC 블록으로부터 상기 제1 존에 대한 데이터(DATA_ZONE1)를 리드하는 동안 라이트 버퍼에 저장된 제1 존에 대한 데이터(DATA_ZONE1`)는 프로그램되지 못하므로, 성능 저하가 발생할 수 있다. 따 라서, 본 발명의 일 실시예에 따르면 메모리 시스템은 SLC 블록으로부터 제1 존에 대한 데이터 (DATA_ZONE1)를 리드하는 동안 파이프 라이닝 스킴에 따라 라이트 버퍼에 저장된 제1 존에 대한 후속 데이터 (DATA_ZONE1``)를 우선적으로 메모리 블록(TLC BLK)에 프로그램할 수 있다. 도 8은 파이프 라이닝 스킴에 따른 프로그램 동작을 설명하기 위한 도면이다. 도 8을 참조하면, SLC 버퍼로부터 제1 존에 대한 데이터(DATA_ZONE1)을 리드하는 동작(SLC READ)이 완료된 이후 SLC 버퍼로부터 리드된 제1 존에 대한 데이터(DATA_ZONE1)와 라이트 버퍼에 저장된 제1 존에 대한 데이터 (DATA_ZONE1`)을 메모리 블록(TLC BLK)에 프로그램하는 동작(TLC WRITE1)을 수행한 이후에, 라이트 버퍼에 저장 된 제1 존에 대한 후속 데이터(DATA_ZONE1``)에 대한 프로그램 동작(TLC WRITE2)를 수행하는 경우보다 SLC 버퍼 로부터 제1 존에 대한 데이터(DATA_ZONE1)을 리드하는 동작(SLC READ)을 수행하는 동안 제1 존에 대한 후속 데 이터(DATA_ZONE1``)에 대한 프로그램 동작(TLC WRITE2)을 수행한 이후 제1 존에 대한 데이터(DATA_ZONE1`)을 메모리 블록(TLC BLK)에 프로그램하는 동작(TLC WRITE1)을 수행하는 경우 프로그램 성능이 더 높은 것을 확인할 수 있다. 라이트 버퍼에 제1 존에 대한 데이터(DATA_ZONE1`) 및 제1 존에 대한 후속 데이터(DATA_ZONE1``)가 저장된 경우 에, 제1 존에 대한 데이터(DATA_ZONE1`) 및 제1 존에 대한 후속 데이터(DATA_ZONE1``)는 메모리 블록에 순차적 으로 프로그램되어야 논리 블록 주소의 연속성이 물리 주소에서도 유지될 수 있다. 다만, 라이트 버퍼에 저장된 제1 존에 대한 데이터(DATA_ZONE1`)에 대한 프로그램 동작이 일시적으로 중지됨에 따라 발생하는 성능 저하를 방지하기 위해, 만약 제1 존에 대한 후속 데이터(DATA_ZONE1``)의 크기가 프로그램 단위를 구성하는 경우에, 메 모리 시스템은 제1 존에 대한 후속 데이터(DATA_ZONE1``)를 라이트 버퍼에 저장된 제1 존에 대한 데이터 (DATA_ZONE1`)보다 먼저 메모리 블록(TLC BLK)에 프로그램할 수 있다. 다만, 제1 존에 대한 데이터 (DATA_ZONE1`)와 제1 존에 대한 후속 데이터(DATA_ZONE1``)가 물리 주소에도 순차적으로 프로그램될 수 있도록, 메모리 시스템은 제1 존에 대한 데이터(DATA_ZONE1`)가 프로그램될 영역이 아닌 후순위 영역에 상기 제1 존에 대한 후속 데이터(DATA_ZONE1``)를 프로그램할 수 있다. 예를 들어, 메모리 시스템은 메모리 블록(TLC BLK)의 제1 페이지 및 제2 페이지에 제1 존에 대한 데이터 (DATA_ZONE1`)와 제1 존에 대한 후속 데이터(DATA_ZONE1``)를 순차 프로그램함으로써 논리 블록 주소의 연속성 을 물리 주소에서도 유지할 수 있다. 만약, 상기 제1 존에 대한 데이터(DATA_ZONE1`)에 대한 프로그램 동작이 SLC 버퍼로부터 제1 존에 대한 데이터(DATA_ZONE1)를 리드하는 동작으로 인해 중단된 경우에, 메모리 시스템 은 제2 페이지에 제1 존에 대한 후속 데이터(DATA_ZONE1``)를 먼저 프로그램한 이후에, 제1 페이지에 제1 존에 대한 데이터(DATA_ZONE1`) 및 SLC 버퍼로부터 리드된 제1 존에 대한 데이터(DATA_ZONE1)를 프로그램할 수 있다. 다시 도 5로 돌아와, 존 정보 관리부는 존에 대한 정보(INFO_ZONE)을 업데이트하여 메모리에 저장할 수 있다. 존에 대한 정보(INFO_ZONE)는 존의 식별자, 존의 상태, 존에 대응하는 메모리 블록의 주소 등에 대한 정보를 포함할 수 있다. 존 정보 관리부는 호스트로부터 존의 식별자에 대한 정보(ID_ZONE) 및 프로 그램 커맨드(PGM_CMD)가 제공되면, 메모리로부터 존에 대한 정보(INFO_ZONE)을 리드할 수 있다. 존 정보 관리부는 존의 식별자에 대한 정보(ID_ZONE) 및 상기 존에 대한 정보(INFO_ZONE)을 존 상태 관리부로제공할 수 있다. 존 상태 관리부은 상기 존의 식별자에 대한 정보(ID_ZONE) 및 상기 존에 대한 정보(INFO_ZONE)에 기초하여 프로그램 커맨드(PGM_CMD)에 대한 존의 상태를 제1 오픈 존(OPENED_ACT)로 변경할 수 있다. 또한, 존 상태 관리 부는 라이트 버퍼의 영역을 상기 제1 오픈 존(OPENED_ACT)에 할당하도록 라이트 버퍼 관리부를 제어 할 수 있다. 존 상태 관리부는 SLC 버퍼에 상기 프로그램 커맨드에 대한 존에 대한 데이터가 저장되어 있 는지 여부를 확인하도록 SLC 버퍼 관리부를 제어할 수 있다. 또한, 존 상태 관리부는 새로운 프로그램 커맨드를 수신하여 제1 오픈 존(OPEND_ACT)에 해당하는 존이 변 경될 때, 기존의 존의 상태를 제2 오픈 존(OPENED_ALLOC)으로 변경할 수 있다. 존 상태 관리부은 라이트 버퍼의 영역이 할당되지 아니한 존에 대한 프로그램 커맨드를 수신하면, 라이트 버퍼의 영역이 할당된 존들 중 하나의 존의 상태를 제3 오픈 존(OPEND_UNALLOC)으로 변경할 수 있다. 추후 상기 제3 오픈 존(OPENED_UNALLO C)에 대한 프로그램 커맨드를 수신하면, 존 상태 관리부는 상기 제3 오픈 존(OPENED_UNALLOC)을 제1 오픈 존(OPENED_ACT)으로 변경하고, SLC 버퍼에 저장된 데이터를 리드하도록 SLC 버퍼 관리부를 제어할 수 있다. 라이트 버퍼 관리부는 상기 존 상태 관리부의 제어 하에 라이트 버퍼의 영역을 상기 제1 오픈 존 (OPENED_ACT)에 할당할 수 있다. 상기 제1 오픈 존(OPEN_ACT)에 대해 할당된 라이트 버퍼 영역의 크기는 프로그 램 단위보다는 클 수 있다. 라이트 버퍼 관리부는 제2 오픈 존(OPEND_ALLOC)에 대해 라이트 버퍼의 영역을 할당할 수 있으며, 할당되는 영역의 크기는 프로그램 단위일 수 있다. 라이트 버퍼 관리부는 제3 오픈 존 (OPENED_UNALLOC)으로 상태가 변경된 존에 대해 할당된 라이트 버퍼의 영역을 회수할 수 있다. SLC 버퍼 관리부는 상기 존 상태 관리부의 제어 하에 SLC 버퍼에 상기 프로그램 커맨드에 대한 존에 대한 데이터가 저장되어 있는지 여부를 확인할 수 있다. 상기 SLC 버퍼에 상기 존에 대한 데이터가 저장되어 있 는 경우에, SLC 버퍼 관리부는 SLC 버퍼에 저장된 데이터를 리드하도록 메모리 장치를 제어할 수 있 다. 또한, SLC 버퍼 관리부는 라이트 버퍼에 저장된 제3 오픈 존(OPENED_UNALLOC)에 대한 데이터를 SLC 버 퍼에 저장하도록 메모리 장치를 제어할 수 있다. 추후 상기 제3 오픈 존(OPENED_UNALLOC)에 대한 프로그램 커맨드를 수신하면, SLC 버퍼 관리부는 상기 제3 오픈 존(OPENED_UNALLOC)을 제1 오픈 존(OPENED_ACT)으 로 변경하고, SLC 버퍼에 저장된 데이터를 리드하도록 메모리 장치를 제어할 수 있다. 낸드 관리부는 라이트 버퍼에 저장된 존에 대한 데이터를 대응하는 메모리 블록에 프로그램하도록 메모리 장치를 제어할 수 있다. 낸드 관리부은 상기 SLC 버퍼에 프로그램 커맨드에 대한 존에 대한 데이터가 저장되어 있는 경우에, SLC 버퍼로부터 리드된 데이터와 라이트 버퍼에 저장된 데이터로 프로그램 단위를 구성 한 뒤, 상기 프로그램 단위를 구성하는 데이터를 메모리 블록에 프로그램하도록 메모리 장치를 제어할 수 있다. 상기 메모리 블록은 멀티-레벨 셀을 포함할 수 있다. 낸드 관리부는 SLC 버퍼로부터 데이터를 리드하는 시간동안 라이트 버퍼에 버퍼링된 데이터를 프로그램하 지 못하고 대기함에 따라 발생하는 성능 저하를 방지하기 위해, 파이프라이닝 스킴을 사용할 수 있다. 구체적으 로, 라이트 버퍼에 제1 및 제2 데이터가 순차 버퍼링되고, 상기 제1 데이터는 SLC 버퍼에 저장된 데이터와 프로 그램 단위를 구성할 수 있으며, 상기 제2 데이터는 프로그램 단위를 구성하는 경우에, 낸드 관리부는 상기 SLC 버퍼로부터 데이터를 리드하는 동안 상기 제2 데이터를 프로그램하고, 이후 상기 프로그램 단위를 구성하는 제1 데이터와 SLC 버퍼로부터 리드된 데이터를 프로그램하도록 메모리 장치를 제어할 수 있다. 도 9A 및 9B는 본 발명의 일 실시예에 따른 메모리 시스템의 동작 방법을 나타낸 순서도이다. 단계 S902에서, 컨트롤러는 호스트로부터 존의 식별자에 대한 정보(ID_ZONE) 및 프로그램 커맨드 (PGM_CMD)를 수신할 수 있다. 존의 식별자에 대한 정보(ID_ZONE)는 상기 프로그램 커맨드(PGM_CMD)에 대응하는 존에 대한 식별자를 포함할 수 있다. 예를 들어, 호스트의 응용 프로그램이 제1 존(ZONE_1)에 대한 프로그 램 커맨드를 이슈한 경우에, 상기 존의 식별자는 상기 제1 존(ZONE_1)을 가리킬 수 있다. 단계 S904에서, 컨트롤러는 상기 프로그램 커맨드(PGM_CMD)에 대한 존의 상태가 제1 오픈 존(OPENED_ACT) 에 해당하는지 여부를 판단할 수 있다. 컨트롤러는 메모리에 저장된 존에 대한 정보에 기초하여 상기 프로그램 커맨드(PGM_CMD)에 대한 존의 상태를 확인할 수 있다. 상기 존에 대한 정보는 존의 상태에 대한 정보 를 포함할 수 있다. 단계 S906에서, 컨트롤러는 상기 프로그램 커맨드(PGM_CMD)에 대한 존의 상태가 제1 오픈 존(OPENED_ACT) 에 해당하는 경우에(단계 S904에서 'Y'), 상기 프로그램 커맨드(PGM_CMD)에 대응하는 데이터를 메모리 블록에프로그램하도록 메모리 장치를 제어할 수 있다. 단계 S908에서, 컨트롤러는 상기 프로그램 커맨드(PGM_CMD)에 대한 존의 상태가 제1 오픈 존(OPENED_ACT) 에 해당하지 아니한 경우에(단계 S904에서 'N'), 상기 존의 상태를 제1 오픈 존(OPENED_ACT)으로 변경할 수 있 다. 단계 S910에서, 컨트롤러는 라이트 버퍼의 잔여 용량과 임계치(TH)의 크기를 비교할 수 있다. 상기 임계치 (TH)는 제1 오픈 존(OPENED_ACT)에 할당하기 위해 필요한 용량으로서, 일 예로 프로그램 단위의 2배일 수 있다. 단계 S912에서, 컨트롤러는 라이트 버퍼의 잔여 용량이 임계치(TH)보다 큰 경우에(단계 S910에서 'Y'), 상 기 제1 오픈 존(OPENED_ACT)에 라이트 버퍼의 영역을 할당할 수 있다. 상기 할당된 영역의 크기는 프로그램 단 위의 2배일 수 있다. 단계 S914에서, 컨트롤러는 라이트 버퍼의 잔여 용량이 임계치(TH)보다 작거나 같은 경우에(단계 S910에서 'N'), 라이트 버퍼의 영역이 할당된 존들 중 빅팀 존(VICTIM)을 선택할 수 있다. 상기 빅팀 존(VICTIM)을 선정 하는 기준은 앞서 설명한 바와 같이, 묵시적 오픈 존인지 여부, 라이트 버퍼에 저장된 데이터의 크기 및 프로그 램 동작이 수행된 시점 등일 수 있다. 단계 S916에서, 컨트롤러는 빅팀 존(VICTIM)의 상태를 제3 오픈 존(OPENED_UNALLOC)으로 변경할 수 있다. 단계 S918에서, 컨트롤러는 라이트 버퍼에 저장된 상기 빅팀 존(VICTIM)에 대한 데이터를 SLC 버퍼에 프로 그램하도록 메모리 장치를 제어할 수 있다. 컨트롤러는 이후 빅팀 존(VICTIM)에 할당된 라이트 버퍼 의 영역을 해제할 수 있다. 단계 S920에서, 컨트롤러는 상기 빅팀 존(VICTIM)에 대한 데이터가 저장된 물리 주소를 존에 대한 정보 (INFO_ZONE)에 기록하여 상기 존에 대한 정보(INFO_ZONE)를 업데이트할 수 있다. 컨트롤러는 상기 존에 대 한 정보(INFO_ZONE)를 메모리에 저장할 수 있다. 단계 S922에서, 컨트롤러는 타겟 존(TARGET ZONE)의 데이터가 SLC 버퍼에 저장되었는지 여부를 확인할 수 있다. 상기 타겟 존(TARGET ZONE)은 단계 S908에서 제1 오픈 존(OPENED_ACT)으로 상태가 변경된 존, 즉 단계 S902에서 수신된 프로그램 커맨드(PGM_CMD)에 대응하는 존을 의미한다. 컨트롤러는 존에 대한 정보 (INFO_ZONE)에 기초하여 타겟 존(TARGET ZONE)의 데이터가 SLC 버퍼에 저장되었는지 여부를 확인할 수 있다. 단계 S924에서, 컨트롤러는 타겟 존(TARGET ZONE)의 데이터가 SLC 버퍼에 저장되지 아니한 경우에(단계 S922에서 'N'), 프로그램 커맨드(PGM_CMD)에 대응하는 데이터를 메모리 블록에 프로그램하도록 메모리 장치 를 제어할 수 있다. 단계 S926에서, 컨트롤러는 타겟 존(TARGET ZONE)의 데이터가 SLC 버퍼에 저장된 경우에(단계 S922에서 'Y'), SLC 버퍼로부터 데이터를 리드하도록 메모리 장치를 제어할 수 있다. 컨트롤러는 도 8을 참조 하여 설명한 파이프라이닝 스킴을 사용하여 SLC 버퍼로부터 데이터를 리드하는 동안 후속 프로그램 데이터 (SUBSEQUENT DATA)에 대한 프로그램 동작을 수행하도록 메모리 장치를 제어할 수 있다. 단계 S928에서, 컨트롤러는 SLC 버퍼로부터 리드된 데이터와 라이트 버퍼에 저장된 데이터로 프로그램 단 위를 구성하여 메모리 블록에 프로그램하도록 메모리 장치를 제어할 수 있다. 한편, 본 발명의 상세한 설명에서는 구체적인 실시 예에 관해 설명하였으나, 본 발명의 범위에서 벗어나지 않는 한도 내에서 여러 가지 변형이 가능함은 물론이다. 그러므로, 본 발명의 범위는 설명된 실시 예에 국한되어 정 해져서는 안되며 후술하는 특허청구의 범위뿐만 아니라 이 특허청구의 범위와 균등한 것들에 의해 정해져야 한 다."}
{"patent_id": "10-2020-0022920", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1A 내지 도 1C은 종래 기술에 따른 메모리 시스템의 저장 방법을 설명하기 위한 도면이다. 도 2는 존드 네임 스페이스를 활용한 데이터 처리 시스템의 저장방법을 설명하기 위한 도면이다. 도 3은 존이 가질 수 있는 상태를 설명하기 위한 도면이다. 도 4는 동시에 구동할 수 있는 응용 프로그램의 개수가 제한되는 문제를 설명하기 위한 도면이다. 도 5는 본 발명의 일 실시예에 따른 데이터 처리 시스템에 대한 블록도이다. 도 6은 본 발명의 일 실시예에 따른 제1 내지 제3 오픈 존들을 설명하기 위한 도면이다. 도 7A 내지 7D는 본 발명의 일 실시예에 따라 존의 상태를 제1 내지 제3 오픈 존들로 변경하는 방법을 설명하기 위한 도면이다. 도 8은 파이프 라이닝 스킴에 따른 프로그램 동작을 설명하기 위한 도면이다. 도 9A 및 9B는 본 발명의 일 실시예에 따른 메모리 시스템의 동작 방법을 나타낸 순서도이다."}
