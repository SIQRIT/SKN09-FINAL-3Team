{"patent_id": "10-2022-0007409", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0014338", "출원번호": "10-2022-0007409", "발명의 명칭": "섀시 시뮬레이션 방법, 장치, 서버, 저장 매체 및 프로그램 제품", "출원인": "아폴로 인텔리전트 커넥티비티", "발명자": "마, 지"}}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "섀시 시뮬레이션 방법으로서, 서버에 적용되고, 상기 서버는 하드웨어 인터페이스를 통해 자율 운전 유닛과 연결되고, 상기 섀시 시뮬레이션 방법은,상기 자율 운전 유닛으로부터 발송되는 섀시 제어 메시지를 획득하고, 고장 주입 정보를 획득하는 단계;상기 섀시 제어 메시지와 상기 고장 주입 정보를 기초로 상기 섀시 제어 메시지에 대응되는 섀시 상태의 시뮬레이션 정보를 생성하는 단계;상기 섀시 상태의 시뮬레이션 정보를 상기 자율 운전 유닛으로 발송하는 단계를 포함하는 섀시 시뮬레이션방법."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 섀시 제어 메시지와 상기 고장 주입 정보를 기초로 상기 섀시 제어 메시지에 대응되는 섀시 상태의 시뮬레이션 정보를 생성하는 단계는, 상기 고장 주입 정보를 기초로, 상기 섀시 제어 메시지 및 상기 섀시 제어 메시지에 대응되는 섀시 시뮬레이션결과 중 적어도 하나에 대해 고장 주입을 수행하여, 상기 섀시 상태시뮬레이션 정보를 획득하며, 상기 섀시 시뮬레이션 결과는 상기 섀시 제어 메시지와 차량 동력학 모델을 기초로 결정된 것인 단계를 포함하는 섀시 시뮬레이션 방법."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 고장 주입 정보를 기초로, 상기 섀시 제어 메시지에 대해 고장 주입을 수행하여, 상기 섀시 상태 시뮬레이션 정보를 획득하는 단계는,상기 섀시 제어 메시지에 대해 디코딩을 수행하고, 상기 고장 주입 정보를 기초로, 디코딩된 후의 상기 섀시 제어 메시지에 대해 고장 주입을 수행하여, 제1 제어 정보를 획득하는 단계;상기 제1 제어 정보를 차량 동력학 모델로 입력하여, 섀시 시뮬레이션 결과를 획득하는 단계;상기 섀시 시뮬레이션 결과에 대해 코딩하여 상기 섀시 상태 시뮬레이션 정보를 획득하는 단계를 포함하는 섀시시뮬레이션 방법."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서, 상기 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하여, 상기섀시 상태 시뮬레이션 정보를 획득하는 단계는,상기 섀시 제어 메시지에 대해 디코딩을 수행하여 제2 제어 정보를 획득하는 단계;상기 제2 제어 정보를 차량 동력학 모델로 입력하여, 섀시 시뮬레이션 결과를 획득하는 단계;상기 고장 주입 정보를 기초로 상기 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하고, 고장 주입을 수행한후의 상기 섀시 시뮬레이션 결과에 대해 코딩하여 상기 섀시 상태의 시뮬레이션 정보를 획득하는 단계를 포함하는 섀시 시뮬레이션 방법."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서, 상기 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하여, 상기섀시 상태 시뮬레이션 정보를 획득하는 단계는,상기 섀시 제어 메시지에 대해 디코딩을 수행하여 제3 제어 정보를 획득하는 단계;공개특허 10-2022-0014338-3-상기 제3 제어 정보를 차량 동력학 모델로 입력하여 섀시 시뮬레이션 결과를 획득하는 단계;상기 섀시 시뮬레이션 결과에 대해 코딩하여 코딩된 후의 상기 섀시 시뮬레이션 결과를 획득하는 단계;상기 고장 주입 정보를 기초로 상기 코딩된 후의 상기 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하여, 상기 섀시 상태의 시뮬레이션 정보를 획득하는 단계를 포함하는 섀시 시뮬레이션 방법."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제2항 내지 제5항 중 어느 한 항에 있어서, 상기 섀시 제어 메시지 및 상기 섀시 제어 메시지에 대응되는 섀시시뮬레이션 결과 중 적어도 하나에 대해 고장 주입을 수행하는 단계는,상기 섀시 제어 메시지의 제1 목표 필드 및 상기 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과의 제2 목표 필드 중 적어도 하나의 내용에 대해 수정하는 단계를 포함하는 섀시 시뮬레이션 방법."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제2항 내지 제5항 중 어느 한 항에 있어서, 상기 섀시 제어 메시지 및 상기 섀시 제어 메시지에 대응되는 섀시시뮬레이션 결과 중 적어도 하나에 대해 고장 주입을 수행하는 단계는,상기 섀시 제어 메시지 및 상기 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과 중 적어도 하나의 전송 시효에 대해 수정하는 단계를 포함하는 섀시 시뮬레이션 방법."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "섀시 시뮬레이션 장치에 있어서, 서버에 적용되고, 상기 서버는 하드웨어 인터페이스를 통해 자율 운전 유닛과연결되고, 상기 섀시 시뮬레이션 장치는,상기 자율 운전 유닛으로부터 발송되는 섀시 제어 메시지를 획득하고, 고장 주입 정보를 획득하는 획득 모듈;상기 섀시 제어 메시지와 상기 고장 주입 정보를 기초로 상기 섀시 제어 메시지에 대응되는 섀시 상태의 시뮬레이션 정보를 생성하는 시뮬레이션 모듈;상기 섀시 상태의 시뮬레이션 정보를 상기 자율 운전 유닛으로 발송하는 발송 모듈을 포함하는 섀시 시뮬레이션장치."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서, 상기 시뮬레이션 모듈은,상기 고장 주입 정보를 기초로, 상기 섀시 제어 메시지 및 상기 섀시 제어 메시지에 대응되는 섀시 시뮬레이션결과 중 적어도 하나에 대해 고장 주입을 수행하여, 상기 섀시 상태 시뮬레이션 정보를 획득하며, 상기 섀시 시뮬레이션 결과는 상기 섀시 제어 메시지와 차량 동력학 모델을 기초로 결정된 것인 시뮬레이션 유닛을 포함하는섀시 시뮬레이션 장치."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 시뮬레이션 유닛은,상기 섀시 제어 메시지에 대해 디코딩을 수행하고, 상기 고장 주입 정보를 기초로, 디코딩된 후의 상기 섀시 제어 메시지에 대해 고장 주입을 수행하여, 제1 제어 정보를 획득하는 제1 디코딩 유닛;상기 제1 제어 정보를 차량 동력학 모델로 입력하여, 섀시 시뮬레이션 결과를 획득하는 제1 시뮬레이션 유닛;상기 섀시 시뮬레이션 결과에 대해 코딩하여 상기 섀시 상태 시뮬레이션 정보를 획득하는 제1 코딩 유닛을 포함하는 섀시 시뮬레이션 장치."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제9항에 있어서, 상기 시뮬레이션 유닛은,상기 섀시 제어 메시지에 대해 디코딩을 수행하여 제2 제어 정보를 획득하는 제2 디코딩 유닛;공개특허 10-2022-0014338-4-상기 제2 제어 정보를 차량 동력학 모델로 입력하여, 섀시 시뮬레이션 결과를 획득하는 제2 시뮬레이션 유닛;상기 고장 주입 정보를 기초로 상기 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하고, 고장 주입을 수행한후의 상기 섀시 시뮬레이션 결과에 대해 코딩하여 상기 섀시 상태의 시뮬레이션 정보를 획득하는 제2 코딩 유닛을 포함하는 섀시 시뮬레이션 장치."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제9항에 있어서, 상기 시뮬레이션 유닛은,상기 섀시 제어 메시지에 대해 디코딩을 수행하여 제3 제어 정보를 획득하는 제3 디코딩 유닛;상기 제3 제어 정보를 차량 동력학 모델로 입력하여 섀시 시뮬레이션 결과를 획득하는 제3 시뮬레이션 유닛;상기 섀시 시뮬레이션 결과에 대해 코딩하여 코딩된 후의 상기 섀시 시뮬레이션 결과를 획득하는 제3 코딩유닛;상기 고장 주입 정보를 기초로 상기 코딩된 후의 상기 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하여, 상기 섀시 상태의 시뮬레이션 정보를 획득하는 고장 주입 유닛을 포함하는 섀시 시뮬레이션 장치."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제9항 내지 제12항 중 어느 한 항에 있어서, 상기 시뮬레이션 유닛은,상기 섀시 제어 메시지의 제1 목표 필드 및 상기 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과의 제2 목표 필드 중 적어도 하나의 내용에 대해 수정하는 제1 수정 유닛을 포함하는 섀시 시뮬레이션 장치."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제9항 내지 제12항 중 어느 한 항에 있어서, 상기 시뮬레이션 유닛은,상기 섀시 제어 메시지 및 상기 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과 중 적어도 하나의 전송 시효에 대해 수정하는 제2 수정 유닛을 포함하는 섀시 시뮬레이션 장치."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "서버에 있어서,적어도 하나의 프로세서; 및상기 적어도 하나의 프로세서와 통신 연결되는 메모리를 포함하고;여기서, 상기 메모리에 상기 적어도 하나의 프로세서에 의해 실행 가능한 명령이 저장되어 있고, 상기 명령이상기 적어도 하나의 프로세서에 의해 실행되어, 상기 적어도 하나의 프로세서가 제1항 내지 제5항 중 어느 한항에 따른 섀시 시뮬레이션 방법을 수행할 수 있도록 하는 서버."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "컴퓨터 명령이 저장된 비일시적 컴퓨터 판독 가능 저장매체에 있어서, 상기 컴퓨터 명령은 컴퓨터가 제1항 내지제5항 중 어느 한 항에 따른 섀시 시뮬레이션 방법을 수행하도록 하는 컴퓨터 명령이 저장된 비일시적 컴퓨터판독 가능 저장매체."}
{"patent_id": "10-2022-0007409", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "컴퓨터 프로그램에 있어서, 컴퓨터 판독 가능 저장매체에 저장되고, 상기 컴퓨터 프로그램이 프로세서에 의해실행될 때 제1항 내지 제5항 중 어느 한 항에 따른 섀시 시뮬레이션 방법을 구현하는 컴퓨터 프로그램."}
{"patent_id": "10-2022-0007409", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 출원은 섀시 시뮬레이션 방법, 장치, 서버, 저장 매체 및 프로그램 제품을 제공하며, 인공 지능 분야에 관한 것으로서, 특히 지능형 운전 분야에 관한 것이다. 상기 방법은, 자율 운전 유닛으로부터 발송되는 섀시 제어 메 시지를 획득하고, 고장 주입 정보를 획득하는 단계; 섀시 제어 메시지와 고장 주입 정보를 기초로 섀시 제어 메 시지에 대응되는 섀시 상태의 시뮬레이션 정보를 생성하는 단계; 섀시 상태의 시뮬레이션 정보를 자율 운전 유닛 으로 발송하는 단계를 포함한다. 상기 방법은 하드웨어 인 루프 기반 섀시 시뮬레이션 방안을 구현하고, 테스트 의 진실성을 향상시킨다."}
{"patent_id": "10-2022-0007409", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원의 실시예는 인공지능 기술에 관한 것으로서, 특히 섀시 시뮬레이션 방법, 장치, 서버, 저장 매체 및 프 로그램 제품에 관한 것이며, 스마트 교통 분야에 적용될 수 있다."}
{"patent_id": "10-2022-0007409", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "자율 운전 차량에서, 자율 운전 유닛이 차량 섀시로 제어 명령을 발송하여 차량의 다양한 운전 조작, 예컨대 엑 셀, 브레이크, 조향 등을 제어하고, 자율 운전 유닛은 또한 차량 섀시로부터 피드백되는 섀시 상태 정보를 수신 하여, 섀시 상태 정보를 기초로 추후의 제어를 수행한다. 자율 운전 유닛에 대해 테스트할 때, 테스트 시나리오에서는 일반적으로 실제 차량 섀시를 사용하여 테스트하기 위한 조건이 갖추어져 있지 않으므로, 일반적으로 자율 운전 유닛 상에 하나의 모의(mock) 대상을 설치하여 차 량 섀시를 시뮬레이션하는 바, 자율 운전 유닛이 제어 명령을 발송하고, mock 대상이 차량 섀시가 100% 제어 명 령을 수행한 후의 섀시 상태 정보를 바로 출력하고, 자율 운전 유닛은 섀시 상태 정보를 수신한 후 제어 알고리 즘을 트리거하여 효과적으로 운행하여, 소프트웨어 차원의 폐쇄 루프 테스트를 구현할 수 있다. 하지만 이러한 방안은 실질 상 완전히 이상적인 상태에 처한 차량 섀시를 시뮬레이션하고 있는 바, 실제 시나리 오와 차이가 있으므로, 테스트 진실성이 부족하게 된다."}
{"patent_id": "10-2022-0007409", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 출원은 테스트 신뢰성을 향상시키기 위한 섀시 시뮬레이션 방법, 장치, 서버, 저장 매체 및 프로그램 제품을 제공한다."}
{"patent_id": "10-2022-0007409", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 출원의 일 측면에 따르면, 섀시 시뮬레이션 방법을 제공하는 바, 서버에 적용되며, 상기 서버는 하드웨어 인 터페이스를 통해 자율 운전 유닛과 연결되고, 상기 방법은, 상기 자율 운전 유닛으로부터 발송되는 섀시 제어 메시지를 획득하고, 고장 주입 정보를 획득하는 단계; 상기 섀시 제어 메시지와 상기 고장 주입 정보를 기초로 상기 섀시 제어 메시지에 대응되는 섀시 상태의 시뮬레 이션 정보를 생성하는 단계; 상기 섀시 상태의 시뮬레이션 정보를 상기 자율 운전 유닛으로 발송하는 단계를 포함한다. 본 출원의 다른 측면에 따르면, 섀시 시뮬레이션 장치를 제공하며, 상기 자율 운전 유닛으로부터 발송되는 섀시 제어 메시지를 획득하고, 고장 주입 정보를 획득하는 획득 모듈; 상기 섀시 제어 메시지와 상기 고장 주입 정보를 기초로 상기 섀시 제어 메시지에 대응되는 섀시 상태의 시뮬레 이션 정보를 생성하는 시뮬레이션 모듈; 상기 섀시 상태의 시뮬레이션 정보를 상기 자율 운전 유닛으로 발송하는 발송 모듈을 포함한다. 본 출원의 또 다른 측면에 따르면, 서버를 제공하며, 적어도 하나의 프로세서; 및 상기 적어도 하나의 프로세서와 통신 연결되는 메모리를 포함하고; 여기서, 상기 메모리에 상기 적어도 하나의 프로세서에 의해 실행 가능한 명령이 저장되어 있고, 상기 명령이 상기 적어도 하 나의 프로세서에 의해 실행되어, 상기 적어도 하나의 프로세서가 제1 측면에 따른 방법을 수행할 수 있도록 한 다. 본 출원의 또 다른 측면에 따르면, 컴퓨터 명령이 저장된 비일시적 컴퓨터 판독 가능 저장매체를 제공하며, 상 기 컴퓨터 명령은 컴퓨터가 상술한 제1 측면에 따른 방법을 수행하도록 한다. 본 출원의 또 다른 측면에 따르면, 컴퓨터 프로그램을 제공하며, 상기 컴퓨터 프로그램은 판독 가능 저장 매체 에 저장되며, 전자기기의 적어도 하나의 프로세서는 상기 판독 가능 저장 매체로부터 상기 컴퓨터 프로그램을 판독할 수 있으며, 상기 적어도 하나의 프로세서는 상기 컴퓨터 프로그램을 실행하여 전자기기가 제1 측면에 따 른 방법을 수행하도록 한다."}
{"patent_id": "10-2022-0007409", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 출원의 기술방안에 따르면, 하드웨어 인 루프 기반 섀시 시뮬레이션 방안을 구현하고, 테스트 진실성을 향상 시킨다. 본 부분에 기재되는 내용은 본 출원의 실시예의 핵심 또는 중요 특징을 특정하려는 목적이 아니며, 본 출원의 범위를 한정하는 것도 아닌 것으로 이해하여야 한다. 본 출원의 기타 특징은 아래의 명세서로부터 쉽게 이해할 수 있다."}
{"patent_id": "10-2022-0007409", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "아래에서는 첨부 도면을 결합하여 본 출원의 예시적인 실시예에 대해 설명하며, 이해를 돕기 위하여 본 출원의 실시예의 다양한 세부 사항을 포함하며, 이들은 단지 예시적인 것으로 간주하여야 한다. 따라서, 본 분야의 통 상적인 지식을 가진자라면, 여기에 기재되는 실시예에 대해 다양한 변경과 수정을 가할 수 있으며, 이는 본 출 원의 범위와 정신을 벗어나지 않는 것으로 이해하여야 한다. 마찬가지로, 명확성과 간결성을 위하여, 아래의 기 재에서 공지 기능과 구조에 대한 설명을 생략한다. 자율 운전 유닛은 자율 운전 차량의 전략 제어 시스템으로서, 자율 운전 차량의 핵심적 모듈이다. 자율 운전 유 닛은 감지, 로케이션, 차량 섀시에서 피드백하는 섀시 상태 정보를 획득하고 차량으로 제어 명령을 출력하여, 차량의 다양한 운전 조작, 예컨대 엑셀, 브레이크, 조향 등을 제어하며, 차량 섀시는 제어 명령에 따라 상응한 조작을 수행하고, 자율 운전 유닛으로 섀시 상태 정보, 예컨대 엑셀 수행 피드백, 브레이크 수행 피드백, 조향 수행 피드백, 차량 휠베이스, 토크, 자세 등의 정보를 피드백하며, 이에 따라 자율 운전 유닛은 섀시 상태 정보 를 기초로 제어 알고리즘을 트리거하여 상응한 처리를 수행한 후, 그 뒤의 제어 명령을 출력한다. 자율 운전 유닛에 대해 테스트할 때, 테스트 시나리오에서는 일반적으로 실제 차량 섀시를 사용하여 테스트하기 위한 조건이 갖추어져 있지 않으므로, 일반적으로 자율 운전 유닛 상에 하나의 mock 대상을 설치하여 차량 섀시 를 시뮬레이션하는 바, 자율 운전 유닛이 제어 명령을 발송하고, mock 대상이 차량 섀시가 100% 제어 명령을 수 행한 후의 섀시 상태 정보를 바로 출력한다. 예를 들어, 제어 명령에서 엑셀 개폐 파라미터 20%을 지시하면, mock 대상은 엑셀 수행 피드백 20%를 리턴한다. 자율 운전 유닛은 섀시 상태 정보를 수신한 후 제어 알고리즘을 트리거하여 효과적으로 운행하여, 소프트웨어 차원의 폐쇄 루프 테스트를 구현할 수 있다. 이러한 방안은 소프트웨어 인 루프를 완벽하게 제어하는 테스트 방안으로서, 다양한 문제점이 존재한다. 한편으 로는, mock 대상이 자율 운전 유닛 상에 설치되는 바, 즉 mock 대상이 테스트되는 대상에 개입되므로, 테스트에 간섭을 주게 된다; 다른 한편, 이러한 방안은 완벽하게 이상적 상태에 있는 차량 섀시를 시뮬레이션하며, 자율 운전 유닛과 mock 대상이 단순히 소프트웨어 인터랙션을 수행하는 바, 실제 시나리오와 차이가 존재하여, 테스 트 진실성이 부족하게 된다. 상술한 방안에 비해, 일부 개선된 방안에서는 차량 섀시 시뮬레이션 소프트웨어를 사용하여 mock 대상을 대체하 고 있다. 즉, 자율 운전 유닛 상에 하나의 차량 섀시 시뮬레이션 소프트웨어를 설치하고, 자율 운전 유닛이 제 어 명령을 입력하고, 차량 섀시 시뮬레이션 소프트웨어가 연산을 통해 섀시 상태의 시뮬레이션 정보를 출력하고, 자율 운전 유닛은 섀시 상태 정보를 수신한 후 제어 알고리즘을 트리거하여 효과적으로 운행하여, 소 프트웨어 차원의 폐쇄 루프 테스트를 구현할 수 있다. 하지만, 이러한 방안도 여전히 상술한 일부 문제점이 존 재한다. 한편으로는, 차량 섀시 시뮬레이션 소프트웨어가 여전히 자율 운전 유닛 상에 설치되어, 즉 차량 섀시 시뮬레이션 소프트웨어가 테스트되는 대상에 개입되므로, 여전히 테스트에 간섭을 주고; 다른 한편, 이러한 방 안은 비록 차량 섀시 시뮬레이션 소프트웨어가 시뮬레이션 연산 방법을 사용하여 섀시 상태의 시뮬레이션 정보를 출력하지만, 자율 운전 유닛과 차량 섀시 시뮬레이션 소프트웨어가 여전히 단순히 소프트웨어 인터랙션하므 로, 실제 시나리오와 여전히 차이가 있으며, 하드웨어 인터페이스 인터랙션이 없으므로, 테스트 시 자율 운전 유닛의 로직 처리에 대해 전면적으로 커버할 수 없어, 테스트에 있어서 여전히 진실성이 부족하다. 더욱 진실한 테스트를 구현하기 위하여, 자율 운전 유닛에 대해 하드웨어 인 루프(HIL) 테스트를 수행하여야 한 다. HIL 테스트는 실제 컨트롤러를 하드웨어 인터페이스를 통해 가상 제어 대상(가상적인 제어 대상은 실시간 시뮬레이션 하드웨어를 사용하여 시뮬레이션함)과 연결하여, 컨트롤러에 대한 전면적이고 진실한 테스트를 구현 한다. 자율 운전 차량에 대한 HIL 테스트에서, 테스트 대상은 바로 자율 운전 유닛으로서, 실시간 시뮬레이션 하드웨어는 차량 섀시 제어 유닛을 포함하여야 하고, 또한 필요한 환경 감지 센서 유닛 및 로케이션 감지 센서 유닛을 포함할 수도 있다. 이를 위해, 본 출원의 실시예는 우선 하드웨어 인 루프 기반 차량 섀시의 실시간 시 뮬레이션 하드웨어를 제공하는 바, 가상 섀시라고 지칭하며, 자율 운전 유닛은 하드웨어 인터페이스를 통해 가 상 섀시와 연결되고, 상기 하드웨어 인터페이스는 실제 차량 중 자율 운전 유닛 및 섀시의 인터페이스와 동일하 다. 예시적으로, 상기 가상 섀시는 서버를 통해 구현될 수 있다. 자율 운전 유닛은 제어 명령을 출력하고, 상기 제어 명령은 하드웨어 인터페이스를 통해 가상 섀시로 전송되고, 가상 섀시는 차량이 제어 명령을 수행한 후의 섀시 상태 정보를 연산하고, 하드웨어 인터페이스를 통해 자율 운전 유닛으로 피드백하며, 이렇게 폐쇄 루프를 구현한다. 테스트 진실성을 향상시키기 위하여, 가상 섀시의 시뮬레이션 로직에 고장 주입 로직을 추가하고, 즉 고장 주입 로직을 통해 섀시의 소프트웨어 및 하드웨어 고장을 시뮬레이션할 수 있으며, 이에 따라 테스트가 실 제 시나리오와 더욱 가깝도록 확보한다. 이하, 상기 가상 섀시를 기반으로 하는 섀시 시뮬레이션 방법에 대해 설명한다. 도 1은 본 출원의 실시예에 따른 섀시 시뮬레이션 방법의 흐름도이다. 상기 방법은 서버에 적용되고, 서버는 하 드웨어 인터페이스를 통해 자율 운전 유닛과 연결되고, 상기 서버는 바로 상술한 가상 섀시이다. 상기 방법은 아래의 단계들을 포함한다. S101, 자율 운전 유닛으로부터 발송되는 섀시 제어 메시지를 획득하고, 고장 주입 정보를 획득한다. 자율 운전 유닛으로부터 발송되는 섀시 제어 메시지는 관련 기술에 따른 차량 섀시에 대한 자율 운전 유닛의 임 의의 제어 메시지, 예컨대 엑셀 제어 메시지, 브레이크 제어 메시지, 조향 제어 메시지일 수 있고, 본 출원의 실시예는 이에 대해 한정하지 않는다. 자율 운전 유닛은 가상 섀시와의 사이에 있는 하드웨어 인터페이스를 통 해 섀시 제어 메시지를 가상 섀시로 발송한다. 고장 주입 정보는 가상 섀시가 섀시 제어 메시지를 획득한 후, 추후에 섀시 제어 메시지에 대해 처리하는 과정 에서, 시뮬레이션하는 고장 상황 등을 주입하는 것을 지시한다. 예시적으로, 고장 주입 정보는 가상 섀시에 미 리 설정된 구성 정보일 수 있고, 상기 구성 정보는 실제 경우에 따라 설정할 수 있으며, 예를 들어 테스트가 필 요한 고장 시나리오 등에 따라 설정할 수 있다. S102, 섀시 제어 메시지와 고장 주입 정보를 기초로 섀시 제어 메시지에 대응되는 섀시 상태의 시뮬레이션 정보 를 생성한다. 가상 섀시는 섀시 제어 메시지를 기초로 대응되는 섀시 상태의 시뮬레이션 정보를 생성한다. 예시적으로, 섀시 제어 메시지에서 엑셀 개폐 파라미터를 지시하면, 섀시 상태의 시뮬레이션 정보는 대응되는 엑셀 수행 피드백을 포함한다. 본 출원의 실시예에서, 섀시 제어 메시지 외에, 가상 섀시는 또한 고장 주입 정보를 결합하여 섀시 상태의 시뮬레이션 정보를 생성한다. 다시 말하면, 가상 섀시는 처리하여 섀시 상태의 시뮬레이션 정보를 생성 하는 과정에서, 그 중에 고장 정보를 주입하여, 생성된 섀시 상태의 시뮬레이션 정보가 고장이 주입되지 않은 경우와 일정한 차이가 있도록 할 수 있다. 설명해야 할 바로는, 고장 주입 정보는 고장 불주입을 지시할 수도 있다. 즉, 섀시 제어 메시지에 대한 처리 과 정에서 시뮬레이션하는 고장 경우를 주입하지 않고, 섀시 제어 메시지에 대해 정상적인 처리를 수행하여, 고장 이 없는 경우에서의 섀시 상태의 시뮬레이션 정보를 출력한다. S103, 섀시 상태의 시뮬레이션 정보를 자율 운전 유닛으로 발송한다. 가상 섀시가 하드웨어 인터페이스를 통해 섀시 상태의 시뮬레이션 정보를 자율 운전 유닛으로 발송하며, 이에 따라 자율 운전 유닛은 추가적으로 섀시 상태의 시뮬레이션 정보를 기초로 연산 처리를 수행하여 추후의 제어를 수행할 수 있다. 본 출원의 실시예에 따른 섀시 시뮬레이션 방법은, 하드웨어 인 루프 기반 가상 섀시를 사용하고, 자율 운전 유 닛과 가상 섀시 간에 실제 하드웨어 인터페이스를 통해 인터랙션하고, 가상 섀시 등은 섀시 제어 메시지와 고장 주입 정보를 기초로 섀시 제어 메시지에 대응되는 섀시 상태의 시뮬레이션 정보를 생성할 수 있으며, 이에 따라 실제 하드웨어 인터페이스에서의 테스트를 구현하고, 고장 주입 정보를 통해, 다양한 소프트웨어 및/또는 하드 웨어 고장 시나리오의 테스트를 구현할 수 있으며, 자율 운전 유닛의 처리 로직을 전면적으로 커버할 수 있고, 테스트 진실성을 향상시킨다. 한편, 가상 섀시와 자율 운전 유닛이 별도로 설치되므로, 즉 테스트 대상과 테스 트되는 대상의 디커플링을 달성할 뿐만 아니라, 테스트 간섭을 줄인다. 아래에서는 추가적으로 가상 섀시와 자율 운전 유닛의 기능을 결합하여 설명한다. 도 2는 가상 섀시 및 자율 운 전 유닛의 기능 모듈을 예시하며, 가상 섀시는 하나의 서버, 즉 도면에 도시된 하드웨어 인 루프 테스트 시뮬레 이션 서버이고, 하드웨어 인 루프 테스트 시뮬레이션 서버와 자율 운전 유닛 간에 컨트롤러 영역 네트워크 (Controller Area Network, CAN) 포트를 통해 연결된다. 도 2에 도시된 바와 같이, 하드웨어 인 루프 테스트 시뮬레이션 서버 상의 기능 모듈은 아래의 세 부분으로 구 분될 수 있다. 필드 프로그래머블 로직 게이트 어레이(Field Programmable Gate Array, FPGA) 레지스터: 고속 직렬 컴퓨터 확 장 버스 표준(Peripheral Component Interconnect Express, PCIE) 인터페이스를 통해 하드웨어 인 루프 테스트 시뮬레이션 서버에 연결되고, CAN 포트를 통해 자율 운전 유닛에 연결되어, 자율 운전 유닛으로부터 발송되는 CAN 메시지를 수신하고, 또한 가상 섀시 어댑터(Virtual Chassis Adapter)로부터 피드백되는 CAN 메시지를 수신 하고 구성 주파수에 따라 이를 CAN 포트 신호로 변환한 후 자율 운전 유닛으로 발송한다. 가상 섀시 어댑터(Virtual Chassis Adapter): 소프트웨어 형태로 하드웨어 인 루프 테스트 시뮬레이션 서버 상 에서 실행되어, 자율 운전 유닛이 CAN 포트를 통해 발송한 섀시 제어 메시지를 디코딩하고, 디코딩된 후의 섀시 제어 메시지를 차량 동력학 모델 유닛으로 출력하고, 또한 차량 동력학 모델로부터 출력되는 섀시 시뮬레이션 결과를 획득한다. 한편 가상 섀시 어댑터는 또한 섀시 제어 메시지 또는 섀시 시뮬레이션 결과에 대해 고장 주 입 제어를 수행하고, 섀시 시뮬레이션 결과에 대해 CAN 포트 프로토콜 코딩 패키징을 수행하여, FPGA 레지스터 로 발송한다. 차량 동력학 모델 유닛: 서로 다른 차량 동력학 모델 플러그인 부재를 사용하여, 소프트웨어 형태로 하드웨어 인 루프 테스트 시뮬레이션 서버 상에서 실행될 수 있으며, 섀시 제어 메시지(엑셀, 브레이크, 조향, 기어 등) 를 기초로, 내부 모델 코드 로직을 통해 연산한 후, 섀시 시뮬레이션 결과를 출력한다. 이하 도 3에 도시된 가상 섀시와 자율 운전 유닛 사이의 각 소프트웨어 모듈의 데이터 흐름도에 대해 설명한다. 도 3에 도시된 바와 같이, 자율 운전 유닛은, a. 경로, 속도 등의 의사 결정 계획을 담당하는 계획 서브 모듈(planning); b. 계획 및 차량 섀시의 피드백을 결합하여, 제어 알고리즘을 사용하여 제어 명령을 출력하는 것을 담당하는 제 어 서브 모듈(control); c. 제어 명령에 대해 CAN 버스 포맷 패키징을 수행하고, 및 차량 섀시로부터 피드백되는 CAN 버스 포맷 메시지 를 수신하고 해석하며, 결과를 제어 및 계획 서브 모듈로 피드백하는 CAN 버스 프록시(CAN bus proxy)를 포함한 다. 가상 섀시는, d. CAN 포트 메시지 수신과 프로토콜 변환을 담당하고, 각종 CAN 메시지 유형을 지원하며, 구체적으로 수요에 따라 설정할 수 있는 FPGA; e. CAN 포트 메시지를 수신하고 해석하며 고장 주입을 수신하고 고장 주입 제어를 수행하는 가상 섀시 디코딩 서브 모듈(Virtual Chassis Decode); f. 차량 동력학 모델의 섀시 시뮬레이션 결과를 수신하고, CAN 포트 메시지로 패키징하고 고장 주입을 수신하고 고장 주입 제어를 수행하는 가상 섀시 코딩 서브 모듈(Virtual Chassis Encode); g. 구성에 따라 실시간으로 고장 주입을 담당하는 고장 주입 서브 모듈(fault injection); h. 섀시 제어 메시지를 기초로 내부 모델 코드 로직을 통해 연산한 후, 섀시 시뮬레이션 결과를 출력하는 차량 동력학 모델(dynamic simulation)을 포함한다.상술한 e, f, g와 같은 세 개의 서브 모듈은 상술한 차량 섀시 어댑터를 구성한다. 아래는 가상 섀시의 내부 메시지 및 가상 섀시와 자율 운전 유닛 사이의 인터랙션 메시지에 대한 설명이다. 1. CAN 제어 메시지(CAN control message), 자율 운전 유닛으로부터 가상 섀시로 발송되는 섀시 제어 메시지, CAN 포맷이다. 2. 제어 메시지(command info), 가상 섀시 내부 메시지로서, 서브 모듈(e)에 의해 FPGA 레지스터로부터 판독하 여 획득한다. 3. 동력학 모델 입력 정보(dynamic input info), 가상 섀시 내부 메시지로서, 서브 모듈(e)로부터 서브 모듈 (h)로 발송되며, 서브 모듈(e)에 의해 디코딩된 후의 섀시 제어 메시지 또는 고장 주입을 거친 디코딩된 후의 섀시 제어 메시지를 포함한다. 4. 동력학 모델 출력 정보(dynamic output info), 가상 섀시 내부 메시지로서, 서브 모듈(h)로부터 서브 모듈 (f)로 발송되며, 섀시 시뮬레이션 결과를 포함한다. 5. 피드백 정보(feedback info), 가상 섀시 내부 메시지로서, 서브 모듈(f)에 의해 FPGA 레지스터에 기록되며, 코딩을 거친 후의 섀시 시뮬레이션 결과 또는 고장 주입을 거친 후의 코딩된 후의 섀시 시뮬레이션 결과를 포함 한다. 6. CAN 피드백 메시지(CAN feedback message), 가상 섀시가 자율 운전 유닛으로 발송하는 피드백 메시지로서, CAN 포맷이며, 섀시 상태의 시뮬레이션 정보를 포함한다. 7. 고장 제어 정보(fault control info), 가상 섀시 내부 메시지로서, 해석 단계에서 고장 주입 제어를 수행한 다. 8. 고장 제어 메시지(fault control info), 가상 섀시 내부 메시지로서, 패키징 단계에서 고장 주입 제어를 수 행한다. 9. 고장 제어 정보(fault control info), 가상 섀시 내부 메시지로서, 발송 단계에서 고장 주입 제어를 수행한 다. 가상 섀시의 각각의 서브 모듈의 기능은 도 4에 도시된 6개의 스레드를 통해 구현될 수 있고, 각각의 서브 모듈 의 소프트웨어의 구현은 c 언어 등을 사용할 수 있으며, 본 출원의 실시예에서는 한정하지 않는다. 해당 6개의 스레드는 레지스터 판독, CAN 메시지 해석, 고장 주입, 차량 동력학 모델, CAN 메시지 패키징, 레지스터 기록을 포함한다. 여기서, 레지스터 판독: 설정 주파수에 따라 FPGA 레지스터 소정 주소 공간으로부터 서로 다른 CAN 메시지 내용을 획득 하고, 이를 cmd buffer에 저장하며; 여기서, FPGA 레지스터는 CAN 포트로부터 CAN 메시지를 수신한 후 구성된 주소 공간에 캐싱하며, CAN 메시지 주기는 20ms, 50ms, 또는 100ms이며, 서로 다른 메시지가 사용하는 주파수는 서로 다르다. CAN 메시지 해석: CAN 메시지 내용 해석을 수행하여, 섀시 제어 메시지 키 필드 내용을 획득하고 처리한 후 캐 싱하며, 동시에 고장 주입 전략 제어 메시지를 수신하고, 서로 다른 구성 전략에 따라 고장 주입을 수행하고, 해석된 후의 메시지를 토탈 버퍼(total buffer)에 저장한다. 고장 주입: 고장 주입 구성을 해석하고, 고장 주입 전략 메시지 발송을 수행한다. 차량 동력학 모델: 범용화 모듈일 수 있으며, 섀시 제어 메시지를 입력받고, 섀시 상태 정보를 출력하며, 동적 버퍼(dynamic buffer)에 저장한다. 예시적으로, 동적 시뮬레이션(dynamic simulation) MKZ 동력학 모델을 사용 할 수 있다. CAN 메시지 패키징: CAN 메시지 패키징을 수행하고, 동적 버퍼로부터 정보를 획득하고 메시지 패키징을 수행하 며, 동시에 고장 주입 전략 제어 메시지를 수신하고, 서로 다른 구성 전략에 따라 고장 주입을 수행하고, 패키 징된 후의 메시지를 리포트 버퍼(report buffer)에 저장한다. 레지스터 기록: 토탈 버퍼 및 리포트 버퍼의 데이터를 FPGA 레지스터에 기록하며, 서로 다른 메시지에 대응되는 레지스터 주소가 서로 다르다. 상술한 가상 섀시에 대한 소개를 참조하면 알 수 있는 바와 같이, 가상 섀시가 섀시 상태의 시뮬레이션 정보를 생성할 때 고장 주입을 수행할 수 있고, 즉 상술한 실시예 S102에서의 섀시 제어 메시지와 고장 주입 정보를 기 초로 섀시 제어 메시지에 대응되는 섀시 상태의 시뮬레이션 정보를 생성하고, 고장 주입의 시기가 다른 점을 결 합하며, 구체적으로, 고장 주입 정보를 기초로, 섀시 제어 메시지 및/또는 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하여, 섀시 상태의 시뮬레이션 정보를 획득하며, 섀시 시뮬레이션 결 과는 섀시 제어 메시지와 차량 동력학 모델을 기초로 결정된 것이다. 즉, 가상 섀시는 섀시 제어 메시지에 대해 처리하는 각각의 단계에서 고장 주입을 수행할 수 있으며, 다양한 고장 시뮬레이션의 구현을 간편하게 하고, 안 전 테스트 조작 공간이 크게 된다. 여기서, 섀시 제어 메시지 및/또는 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과에 대해 고장 주입을 수 행하는 것은, 섀시 제어 메시지의 제1 목표 필드 및/또는 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과의 제2 목표 필드의 내용을 수정하는 것, 또는, 섀시 제어 메시지 및/또는 섀시 제어 메시지에 대응되는 섀시 시뮬 레이션 결과의 전송 시효를 수정하는 것을 포함할 수 있다. 즉, 섀시 제어 메시지 및/또는 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과에 대해 내용 수정을 수행하여, 필드 변경 고장 시나리오에 대한 테스트를 구현 할 수 있고; 전송 실패 수정을 수행하여, 제어 지연 등의 고장 시나리오에 대한 테스트를 구현할 수도 있다. 설 명해야 할 바로는 섀시 제어 메시지는 디코딩된 후의 섀시 제어 메시지일 수 있고, 섀시 시뮬레이션 결과는 패 키징 전 또는 패키징 후의 섀시 시뮬레이션 결과일 수 있다. 아래에서는 서로 다른 고장 주입 시기에 대해 각각 설명한다. 일 실시예에서, 섀시 제어 메시지의 해석 단계에서 고장 주입 제어를 수행한다. 즉 도 3에 도시된 바와 같이, 고장 주입 서브 모듈(g)은 고장 주입 정보를 서브 모듈(e)로 발송한다. 이러한 시나리오에서, 가상 섀시의 처리 과정은 아래와 같다. 섀시 제어 메시지에 대해 디코딩하고, 고장 주입 정보를 기초로, 디코딩된 후의 섀시 제어 메시지에 대해 고장 주입을 수행하여, 제1 제어 정보를 획득하고; 제1 제어 정보를 차량 동력학 모델로 입력하여, 섀시 시뮬레이션 결과를 획득하고; 섀시 시뮬레이션 결과에 대해 코딩하여 섀시 상태시뮬레이션 정보를 획득한다. 도 3을 결합하여 설명하면, 서브 모듈(e)은 서브 모듈(d)로부터 섀시 제어 메시지를 획득한 후, 섀시 제어 메시 지에 대해 디코딩하고, 동시에 서브 모듈(g)이 고장 주입 정보를 서브 모듈(e)로 발송하였으므로, 서브 모듈 (e)은 디코딩된 후의 섀시 제어 메시지에 대해 고장 주입을 수행하여야 하며, 예시적으로, 디코딩된 후의 섀시 제어 메시지의 제1 목표 필드에 대해 수정하며, 예를 들어 엑셀 개폐도 필드를 20%으로부터 30%으로 수정하고, 예시적으로, 디코딩된 후의 섀시 제어 메시지의 전송 시효를 수정하며, 예를 들어 서브 모듈(h)로의 디코딩된 후의 섀시 제어 메시지 입력을 지연하여, 자율 운전 유닛의 제어가 지연되도록 한다. 서브 모듈(e)이 디코딩된 후의 섀시 제어 메시지에 대해 고장 주입을 수행한 후 제1 제어 정보(3, 동력학 모델 입력 정보)를 획득하고, 이를 서브 모듈(h)로 입력하여, 섀시 시뮬레이션 결과(4, 동력학 모델 출력 정보)를 획득하고, 서브 모듈(f)이 이에 대해 패키징하고(5, 피드백 정보), 서브 모듈(d)이 CAN 포트 변환을 수행하여 섀시 상태 시뮬레이션 정보 를 형성한다(6, CAN 피드백 메시지). 이에 따라, 메시지 해석 단계의 고장 주입을 구현할 수 있으며, 상기 시나 리오에서의 고장 시뮬레이션이 간편해지록 하고, 테스트 시나리오 커버률을 향상시킨다. 다른 실시예에서, 섀시 제어 메시지의 패키징 단계에서 고장 주입 제어를 수행하고, 즉 도 3에 도시된 바와 같 이, 서브 모듈(h)이 섀시 시뮬레이션 결과(4, 동력학 모델 출력 정보)를 서브 모듈(f)로 입력하고, 서브 모듈 (f)은 패키징하고 고장 주입을 수행한다. 이러한 시나리오에서, 가상 섀시의 처리 과정은 아래와 같다. 섀시 제어 메시지에 대해 디코딩하여, 제2 제어 정보를 획득하고; 제2 제어 정보를 차량 동력학 모델로 입력하 여, 섀시 시뮬레이션 결과를 획득하고; 고장 주입 정보를 기초로 섀시 시뮬레이션 결과에 대해 고장 주입을 수 행하고, 고장 주입을 수행한 후의 섀시 시뮬레이션 결과에 대해 코딩하여 섀시 상태의 시뮬레이션 정보를 획득 한다. 도 3을 결합하여 설명하면, 서브 모듈(e)은 서브 모듈(d)로부터 섀시 제어 메시지를 획득한 후, 섀시 제어 메시 지에 대해 디코딩하여, 제2 제어 정보(3, 동력학 모델 입력 정보)를 획득하고, 이를 서브 모듈(h)로 입력하여 섀시 시뮬레이션 결과(4, 동력학 모델 출력 정보)를 획득하고, 서브 모듈(h)은 섀시 시뮬레이션 결과를 서브 모 듈(f)로 발송하며, 서브 모듈(g)이 고장 주입 정보를 서브 모듈(f)로 발송하였으므로, 서브 모듈(f)은 섀시 시 뮬레이션 결과에 대해 고장 주입을 수행하고 패키징하여야 한다. 예시적으로, 섀시 시뮬레이션 결과의 제2 목표 필드에 대해 수정하며, 예를 들어 엑셀 수행 피드백의 필드를 20%로부터 22%로 수정하고, 예시적으로, 섀시 시 뮬레이션 결과의 전송 시효를 수정하며, 예를 들어 서브 모듈(d)로의 패키징 후의 섀시 시뮬레이션 결과의 기록을 지연하여, 가상 섀시의 피드백에 대한 자율 운전 유닛의 수신을 지연한다. 서브 모듈(f)은 고장 주입 후의 섀시 시뮬레이션 결과에 대해 패키징하고(5, 피드백 정보), 서브 모듈(d)이 CAN 포트 변환을 수행하여 섀시 상 태 시뮬레이션 정보(6, CAN 피드백 메시지)를 형성한다. 이에 따라, 메시지 패키징 단계의 고장 주입을 구현할 수 있으며, 상기 시나리오에서의 고장 시뮬레이션을 간편하게 하고, 테스트 시나리오 커버률을 향상시킨다. 또 다른 실시예에서, 서브 모듈(d)이 CAN 포트 변환을 수행하는 단계에서 고장 주입 제어를 수행하며, 즉 도 3 에 도시된 바와 같이, 서브 모듈(f)이 패키징된 후의 섀시 시뮬레이션 결과(5, 피드백 정보)를 서브 모듈(d)로 발송하고, 서브 모듈(d)이 CAN 포트 변환 패키징을 수행할 때 고장 주입을 수행한다. 이러한 시나리오에서, 가 상 섀시의 처리과정은 아래와 같다. 섀시 제어 메시지에 대해 디코딩하여, 제3 제어 정보를 획득하고; 제3 제어 정보를 차량 동력학 모델로 입력하 여, 섀시 시뮬레이션 결과를 획득하고; 섀시 시뮬레이션 결과에 대해 코딩하여, 코딩된 후의 섀시 시뮬레이션 결과를 획득하고; 고장 주입 정보를 기초로 코딩된 후의 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하여, 섀시 상태의 시뮬레이션 정보를 획득한다. 도 3을 결합하여 설명하면, 서브 모듈(e)이 FPGA 레지스터로부터 섀시 제어 메시지를 획득한 후, 섀시 제어 메 시지에 대해 디코딩하여, 제3 제어 정보를 획득하고(3, 동력학 모델 입력 정보), 이를 서브 모듈(h)로 입력하여 섀시 시뮬레이션 결과(4, 동력학 모델 출력 정보)를 획득하고, 서브 모듈(h)은 섀시 시뮬레이션 결과를 서브 모 듈로 발송하고, 서브 모듈(f)은 섀시 시뮬레이션 결과에 대해 패키징하고(5, 피드백 정보) 서브 모듈(d)에 기록 하며, 서브 모듈(g)이 고장 주입 정보를 서브 모듈(d)로 발송하였으므로, 서브 모듈(d)은 패키징된 후의 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하고 CAN 포트 변환 패키징을 수행하여야 한다. 고장 주입 방식이 상 술한 바와 유사한 바, 메시지 중의 내용을 수정하거나 전송 시효를 수정할 수 있다. 이에 따라, CAN 포트 변환 발송 단계의 고장 주입을 구현할 수 있으며, 상기 시나리오에서의 고장 시뮬레이션을 간편하게 하고, 테스트 시 나리오 커버률을 향상시킨다. 도 5는 본 출원의 실시예에 따른 섀시 시뮬레이션 장치의 구성도이다. 도 5에 도시된 바와 같이, 섀시 시뮬레이 션 장치는, 자율 운전 유닛으로부터 발송되는 섀시 제어 메시지를 획득하고, 고장 주입 정보를 획득하는 획득 모듈; 섀시 제어 메시지와 고장 주입 정보를 기초로 섀시 제어 메시지에 대응되는 섀시 상태의 시뮬레이션 정보를 생 성하는 시뮬레이션 모듈; 섀시 상태의 시뮬레이션 정보를 자율 운전 유닛으로 발송하는 발송 모듈을 포함한다. 일 실시형태에서, 시뮬레이션 모듈은, 고장 주입 정보를 기초로, 섀시 제어 메시지 및/또는 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과에 대 해 고장 주입을 수행하여, 섀시 상태 시뮬레이션 정보를 획득하고, 섀시 시뮬레이션 결과는 섀시 제어 메시지와 차량 동력학 모델을 기초로 결정된 것인 시뮬레이션 유닛을 포함한다. 일 실시형태에서, 시뮬레이션 유닛은, 섀시 제어 메시지에 대해 디코딩하고, 고장 주입 정보를 기초로, 디코딩된 후의 섀시 제어 메시지에 대해 고장 주입을 수행하여, 제1 제어 정보를 획득하는 제1 디코딩 유닛; 제1 제어 정보를 차량 동력학 모델로 입력하여, 섀시 시뮬레이션 결과를 획득하는 제1 시뮬레이션 유닛; 섀시 시뮬레이션 결과에 대해 코딩하여 섀시 상태 시뮬레이션 정보를 획득하는 제1 코딩 유닛을 포함한다. 일 실시형태에서, 시뮬레이션 유닛은, 섀시 제어 메시지에 대해 디코딩하여, 제2 제어 정보를 획득하는 제2 디코딩 유닛; 제2 제어 정보를 차량 동력학 모델로 입력하여, 섀시 시뮬레이션 결과를 획득하는 제2 시뮬레이션 유닛; 고장 주입 정보를 기초로 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하고, 고장 주입을 수행한 후의 섀시 시뮬레이션 결과에 대해 코딩하여 섀시 상태의 시뮬레이션 정보를 획득하는 제2 코딩 유닛을 포함한다. 일 실시형태에서, 시뮬레이션 유닛은, 섀시 제어 메시지에 대해 디코딩하여, 제3 제어 정보를 획득하는 제3 디코딩 유닛; 제3 제어 정보를 차량 동력학 모델로 입력하여, 섀시 시뮬레이션 결과를 획득하는 제3 시뮬레이션 유닛; 섀시 시뮬레이션 결과에 대해 코딩하여, 코딩된 후의 섀시 시뮬레이션 결과를 획득하는 제3 코딩 유닛; 고장 주입 정보를 기초로 코딩된 후의 섀시 시뮬레이션 결과에 대해 고장 주입을 수행하여, 섀시 상태의 시뮬레 이션 정보를 획득하는 고장 주입 유닛을 포함한다. 일 실시형태에서, 시뮬레이션 유닛은, 섀시 제어 메시지의 제1 목표 필드 및/또는 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과의 제2 목표 필 드의 내용에 대해 수정하는 제1 수정 유닛을 포함한다. 일 실시형태에서, 시뮬레이션 유닛은, 섀시 제어 메시지 및/또는 섀시 제어 메시지에 대응되는 섀시 시뮬레이션 결과의 전송 시효에 대해 수정하는 제 2 수정 유닛을 포함한다. 본 출원의 실시예에 따른 섀시 시뮬레이션 장치는 상술한 방법 실시예에 따른 섀시 시뮬레이션 방법을 구현할 수 있으며, 그 구현 원리와 기술 효과가 유사하므로, 여기서는 반복되는 설명을 생략한다. 본 출원의 실시예에 따르면, 본 출원은 전자기기과 컴퓨터 명령이 저장된 비일시적 컴퓨터 판독 가능 저장매체 를 더 제공한다. 상기 전자기기는 상술한 서버일 수 있다. 본 출원의 실시예에 따르면, 본 출원은 컴퓨터 프로그램을 더 제공하며, 컴퓨터 프로그램은 판독 가능 저장 매 체에 저장되며, 전자기기의 적어도 하나의 프로세서는 판독 가능 저장 매체로부터 컴퓨터 프로그램을 판독할 수 있으며, 적어도 하나의 프로세서는 컴퓨터 프로그램을 실행하여 전자기기가 상술한 어느 하나의 실시예에 따른 방안을 구현하도록 한다. 도 6은 본 출원의 실시예의 섀시 시뮬레이션 방법을 구현하기 위한 전자기기의 블록도이다. 전자기기는 랩톱 컴 퓨터, 데스크톱 컴퓨터, 워크 스테이션, 개인 정보 단말, 서버, 블레이드 서버, 대형 컴퓨터, 및 기타 적합한 컴퓨터와 같은 다양한 형태의 디지털 컴퓨터를 의미한다. 전자기기는 개인 정보 단말, 셀폰, 스마트 폰, 웨어러 블 기기 및 기타 유사한 컴퓨팅 장치와 같은 다양한 형태의 모바일 장치를 의미할 수도 있다. 본문에 개시된 부 재, 이들의 연결 및 관계, 및 이들의 기능은 단지 예시적인 것이며, 본문에 기재된 것 및/또는 요구하는 본 출 원의 구현을 한정하려는 의도가 아니다. 도 6에 도시된 바와 같이, 전자기기는 컴퓨팅 유닛를 포함하여, 읽기 전용 메모리(602, ROM)에 저장 된 컴퓨터 프로그램 또는 저장 유닛으로부터 랜덤 액세스 메모리(603, RAM)에 로딩된 컴퓨터 프로그램을 기초로, 다양한 적합한 동작 및 처리를 수행할 수 있다. RAM에는, 전자 기기의 조작에 필요한 다양한 프로그램과 데이터를 더 저장할 수 있다. 컴퓨팅 유닛, ROM 및 RAM은 버스를 통해 서로 연 결된다. 입력/출력(I/O) 인터페이스도 버스에 연결된다. 전자기기의 복수의 부재는 I/O 인터페이스에 연결되고, 예를 들어 키보드, 마우스 등과 같은 입력 유 닛; 예를 들어 다양한 유형의 디스플레이, 스피커 등과 같은 출력 유닛; 예를 들어 자기 디스크, 광 디스크 등과 같은 저장 유닛; 및 예를 들어 네트워크 카드, 모뎀, 무선 통신 트랜시버 등과 같은 통신 유 닛을 포함한다. 통신 유닛은 전자기기가 인터넷과 같은 컴퓨터 네트워크 및/또는 다양한 통신 네트워크를 통해 기타 기기와 정보/데이터를 교환하는 것을 허용한다. 컴퓨팅 유닛은 처리 및 연산 능력을 갖춘 다양한 범용 및/또는 전용 처리 모듈일 수 있다. 컴퓨팅 유닛 의 일부 예시로서 중앙 처리 유닛(CPU), 그래픽 처리 유닛(GPU), 다양한 전용 인공지능(AI) 연산 칩, 다양 한 기계 학습 모델 알고리즘을 실행하는 컴퓨팅 유닛, 디지털 신호 프로세서(DSP), 및 임의의 적합한 프로세서, 컨트롤러, 마이크로 컨트롤러 등을 포함하지만 이에 한정되는 것은 아니다. 컴퓨팅 유닛은 상술한 각각의 방법 및 처리를 수행하는 바, 예를 들어 섀시 시뮬레이션 방법을 들 수 있다. 예를 들어, 일부 실시예에서, 섀 시 시뮬레이션 방법은 컴퓨터 소프트웨어 프로그램으로 구현되어, 명시적으로 저장 유닛과 같은 기계 판독 가능 매체에 저장될 수 있다. 일부 실시예에서, 컴퓨터 프로그램의 부분 또는 전부는 ROM 및/또는 통신 유 닛을 통해 전자기기 상에 로딩 및/또는 설치될 수 있다. 컴퓨터 프로그램이 RAM에 로딩되어 컴 퓨팅 유닛에 의해 실행될 때, 상술한 섀시 시뮬레이션 방법의 하나 또는 복수의 단계를 수행할 수 있다. 선택적으로, 기타 실시예에서, 컴퓨팅 유닛은 기타 임의의 적합한 방식(예를 들어, 펌웨어를 통해)을 통해 섀시 시뮬레이션 방법을 수행하도록 구성될 수 있다.본 명세서에 기재되는 시스템 및 기술의 다양한 실시형태는 디지털 전자 회로 시스템, 집적 회로 시스템, 필드 프로그래머블 어레이(FPGA), 전용 집적 회로(ASIC), 전용 표준 제품(ASSP), 시스템 온 칩(SOC), 복잡 컴플렛 프 로그래머블 논리 장치(CPLD), 컴퓨터 하드웨어, 펌웨어, 소프트웨어, 및/또는 이들의 조합에서 구현될 수 있다. 이러한 다양한 실시형태는 하나 또는 복수의 컴퓨터 프로그램에서 구현되는 것을 포함할 수 있고, 해당 하나 또 는 복수의 컴퓨터 프로그램은 적어도 하나의 프로그래머블 프로세서를 포함하는 프로그래머블 시스템 상에서 실 행 및/또는 해석될 수 있으며, 해당 프로그래머블 프로세서는 전용 또는 범용 프로그래머블 프로세서일 수 있고, 저장 시스템, 적어도 하나의 입력 장치, 및 적어도 하나의 출력 장치로부터 데이터와 명령을 수신할 수 있으며, 데이터와 명령을 해당 저장 시스템, 해당 적어도 하나의 입력 장치, 및 해당 적어도 하나의 출력 장치 로 전송한다. 본 출원의 방법을 실시하기 위한 프로그램 코드는 하나 또는 복수의 프로래밍 언어의 임의의 조합으로 작성될 수 있다. 이러한 프로그램 코드는 범용 컴퓨터, 전용 컴퓨터 또는 기타 프로그래머블 데이터 처리 장치의 프로 세서 또는 컨트롤러에 제공되어, 프로그램 코드가 프로세서 또는 컨트롤러에 의해 실행될 때 흐름도 및/또는 블 록도에서 규정하는 기능/조작이 실시되도록 할 수 있다. 프로그램 코드는 완전히 기계 상에서 실행되거나, 부분 적으로 기계 상에서 실행될 수 있으며, 독립 소프트웨어 패키지로서 부분적으로 기계 상에서 실행되고 부분적으 로 원격 기계 상에서 실행되거나 완전히 원격 기계 또는 서버 상에서 실행될 수도 있다. 본 출원의 문맥에서, 기계 판독 가능 매체는 유형의 매체일 수 있고, 명령 실행 시스템, 장치 또는 기기에 의해 사용되거나 명령 실행 시스템, 장치 또는 기기와 결합되어 사용되는 프로그램을 포함하거나 저장할 수 있다. 기 계 판독 가능 매체는 기계 판독 가능 신호 매체이거나 기계 판독 가능 저장 매체일 수 있다. 기계 판독 가능 매 체는 전자적, 자기적, 광학적, 전자기적, 적외선, 또는 반도체 시스템, 장치 또는 기기, 또는 상술한 내용의 임 의의 적합한 조합을 포함할 수 있지만 이에 한정되는 것은 아니다. 기계 판독 가능 저장매체의 더 구체적인 예 시로서 하나 또는 복수의 선을 기반으로 하는 전기적 연결, 휴대형 컴퓨터 디스크, 하드 디스크, 랜덤 액세스 메모리(RAM), 읽기 전용 메모리(ROM), 소거 가능 및 프로그래머블 읽기 전용 메모리(EPROM 또는 플래쉬 메모 리), 광섬유, 휴대용 컴팩트 읽기 전용 메모리(CD-ROM), 광학 저장 장치, 자기 저장 장치, 또는 상술한 내용의 임의의 조합을 포함한다. 사용자와의 인터랙션을 제공하기 위하여, 컴퓨터 상에서 본 명세서에 기재되는 시스템 및 기술을 실시할 수 있 으며, 해당 컴퓨터는 사용자에게 정보를 표시하기 위한 표시장치(예를 들어, CRT(캐소드레이 튜브) 또는 LCD(액 정 디스플레이) 모니터); 및 키보드와 지향 장치(예를 들어, 마우스 또는 트랙볼)를 구비하고, 사용자는 해당 키보드와 해당 지향 장치를 통해 입력을 컴퓨터로 제공할 수 있다. 기타 종류의 장치는 사용자와의 인터랙션을 제공할 수도 있다. 예를 들어, 사용자에게 제공되는 피드백은 임의의 형태의 센싱 피드백(예를 들어, 시각적 피 드백, 청각적 피드백, 또는 촉각적 피드백)일 수 있고; 임의의 형태(사운드 입력, 음성 입력 또는 촉각 입력)을 통해 사용자로부터의 입력을 수신할 수 있다. 여기에 기재되는 시스템과 기술은 백그라운드 부재를 포함하는 컴퓨팅 시스템(예를 들어, 데이터 서버로서), 또 는 중간부재를 포함하는 컴퓨팅 시스템(예를 들어, 응용 서버), 또는 프론트 엔드 부재를 포함하는 컴퓨팅 시스 템(예를 들어, 그래픽 유저 인터페이스 또는 인터넷 브라우저를 구비하는 사용자 컴퓨터, 사용자는 해당 그래픽 유저 인터페이스 또는 해당 인터넷 브라우저를 통해 여기에 기재되는 시스템 및 기술의 실시형태와 인터랙션할 수 있다), 또는 이러한 백그라운드 부재, 중간 부재, 또는 프론트 엔드 부재를 포함하는 임의의 조합의 컴퓨팅 시스템에서 실시될 수 있다. 임의의 형태 또는 매체의 디지털 데이터 통신(예를 들어, 통신 네트워크)을 통해 시스템의 부재를 서로 연결시킬 수 있다. 통신 네트워크의 예시로서, 근거리 통신망(LAN), 광역 통신망(WAN) 및 인터넷을 포함한다. 컴퓨터 시스템은 클라이언트와 서버를 포함할 수 있다. 클라이언트와 서버는 일반적으로 서로 멀리 떨어져 있으 며, 통상적으로 통신 네트워크를 통해 인터랙션한다. 상응한 컴퓨터 상에서 실행되며 서로 클라이언트 - 서버 관계를 가지는 컴퓨터 프로그램을 통해 클라이언트와 서버의 관계를 생성한다. 서버는 클라우드 서버일 수 있고, 클라우드 컴퓨팅 서버 또는 클라우드 호스트라고도 불리우며, 클라우드 컴퓨팅 서비스 시스템 중의 일 호 스트 제품으로서, 기존의 물리 호스트와 가상 사설 서버(\"Virtual Private Server\", 또는 \"VPS\"로 약칭)에 존재 하는 관리 상의 어려움이 크고, 서비스 확장이 약한 흠결을 해결한다. 서버는 분포식 시스템의 서버, 또는 블록 체인이 결합된 서버일 수도 있다. 상술한 다양한 형태의 프로세스를 사용하여 단계를 재배열, 추가 또는 삭제할 수 있다는 것을 이해하여야 한다. 예를 들어, 본 출원에 기재된 각 단계는 병열로 수행될 수 있고 순차적으로 수행될 수도 있고 서로 다른 순서로수행될 수도 있으며, 본 출원에 개시된 기술적 해결수단이 원하는 결과를 얻을 수만 있다면, 본 명세서에서는 이에 대해 한정하지 않는다. 상술한 구체적인 실시형태는 본 출원의 보호범위에 대한 한정이 아니다. 본 분야의 통상의 지식을 가진 자라면, 설계 요구와 기타 요소를 기초로, 다양한 수정, 조합, 서브 조합 및 대체를 수행할 수 있다는 것 이해하여야 한 다. 본 출원의 사상과 원칙 내에서 이루어진 모든 수정, 동등한 치환 및 개선 등은 모두 본 출원의 보호 범위 내에 포함되어야 한다."}
{"patent_id": "10-2022-0007409", "section": "도면", "subsection": "도면설명", "item": 1, "content": "첨부되는 도면은 본 방안을 더 충분히 이해하도록 제공되는 것으로서, 본 출원에 대한 한정은 아니다. 여기서, 도 1은 출원의 실시예에 따른 섀시 시뮬레이션 방법의 흐름도이다. 도 2는 본 출원의 실시예에 따른 가상 섀시 및 자율 운전 유닛의 기능 모듈을 나타내는 도면이다. 도 3은 본 출원의 실시예에 따른 데이터 흐름도이다. 도 4는 본 출원의 실시예에 따른 스레드 도면이다. 도 5는 본 출원의 실시예에 따른 섀시 시뮬레이션 장치의 구성도이다. 도 6은 본 출원의 실시예의 섀시 시뮬레이션 방법을 구현하기 위한 전자기기의 블록도이다."}
