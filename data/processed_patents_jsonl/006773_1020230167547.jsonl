{"patent_id": "10-2023-0167547", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0035407", "출원번호": "10-2023-0167547", "발명의 명칭": "보안 기능을 제공하는 전자 장치 및 그의 동작 방법", "출원인": "삼성전자주식회사", "발명자": "이성민"}}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "전자 장치에 있어서,일반 환경(REE, rich execution environment)(310)과 신뢰 환경(TEE, trusted execution environment)(320)상에서 동작을 수행하는 메인 프로세서(221);및상기 메인 프로세서와 물리적으로 구분되어 보안 환경(SEE, secure execution environment)(330) 상에서 동작을 수행하는 보안 프로세서(223)를 포함하고,상기 메인 프로세서는전자 서명(sig) 및 키 캡슐화(key encapsulation mechanism, KEM) 동작을 수행함에 있어서,신뢰 환경(TEE) 또는 보안 환경(SEE) 중 어느 하나에서 동작이 실행되었을 때 연산 속도를 확인하고,확인된 연산 속도에 기반하여 전자 서명(sig) 및 키 캡슐화(key encapsulation, mechanism, KEM) 동작이 수행되는 실행 환경을 다르게 결정하며,상기 실행 환경은보안 환경(SEE) 및 신뢰 환경(TEE)을 포함하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 메인 프로세서는상기 일반 환경(REE) 상에서 어플리케이션의 보안 기능 요청이 확인됨에 기반하여 상기 신뢰 환경(TEE) 또는 상기 보안 환경 중 어느 하나의 실행 환경으로 보안 기능 요청을 전달하고,상기 신뢰 환경(TEE) 또는 상기 보안 환경 중 보안 기능 요청을 수신한 모듈 상에서 공개키와 개인키를 포함하는 PQC(post quantum cryptography) 키 페어(key pair)를 생성하고, 생성된 개인키에 대해 키 암호 키(KEK, key-encryption-key) 및 초기화 벡터(IV, initialization vector)를 이용하여 암호화(wrapping)하고,상기 보안 환경(SEE)에서 공개 키가 포함된 인증서를 생성하고, 상기 어플리케이션의 요청에 기반하여 개인 키를 저장하며, 상기 보안 환경(SEE)에서 생성된 인증서에 대해 상기 일반 환경(REE) 상에서 상기 보안 환경(SEE)의 공개키를 이용하여 보안 기능을 수행하고,보안 기능이 수행됨에 기반하여 인증서, 암호화된 개인키 및 보안 기능 수행을 요청한 어플리케이션의 식별정보(ID)를 메모리(130) 상에 저장하고, 보안 기능 수행 결과를 상기 어플리케이션으로 전송하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,상기 메인 프로세서는상기 일반 환경(REE) 상에서 어플리케이션으로부터 암호화된 개인키에 대한 정보 및 서명이 필요한 메시지를 수신함에 기반하여 대응하는 개인키가 상기 보안 환경(SEE) 상의 보안 메모리(225)에 저장되어 있는지 확인하고,대응하는 개인키가 상기 보안 메모리에 저장되어 있음에 기반하여 개인키에 대한 정보 및 서명이 필요한 메시지공개특허 10-2025-0035407-3-를 상기 신뢰 환경(TEE)으로 전달하고,상기 신뢰 환경을 이용하여 개인키에 대한 정보 및 서명이 필요한 메시지를 상기 보안 프로세서 상으로 전송하며,상기 보안 프로세서는수신된 개인키에 대한 정보에 기반하여 상기 보안 메모리에 저장된 개인키를 확인하고, 확인된 개인키를 이용하여 서명이 필요한 메시지에 대한 서명을 생성하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 메인 프로세서는상기 어플리케이션으로부터 키 생성 요청을 수신하고,APDU(application protocol data unit) 포멧을 사용하는 메시지로 변환하며,변환된 메시지를 상기 보안 프로세서(223) 상으로 전송하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4 항에 있어서,상기 보안 프로세서는WrapKey가 생성되어 있지 않음에 기반하여 WrapKey를 생성하여 보안 메모리에 저장하고,WrapKey가 생성되어 있음에 기반하여 WrapKey와 대응하는 고유 값을 상기 보안 메모리 상에서 읽어내며,상기 WrapKey는상기 어플리케이션의 보안 기능 요청이 수신된 실행 환경 밖으로 노출되지 않는 키를 의미하고, 대칭 암호를 이용하여 만들어진 것을 특징으로 하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 5 항에 있어서,상기 보안 프로세서는 초기화 벡터(IV, Initialization Vector) 및 WrapKey에서 유도된 키 암호화 키(KEK, Key Encryption Key)를 생성하고,공개키와 비밀키를 포함하는 PQC 전자서명 키 쌍을 생성하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 6 항에 있어서,상기 보안 프로세서는상기 생성된 PQC 전자서명 키 쌍 중에서 비밀키에 대해 키 암호화 키(KEK, Key Encryption Key)를 이용하여 암호화하고,공개특허 10-2025-0035407-4-상기 생성된 PQC 전자서명 키 쌍 중에서 공개키는 인증서에 포함시키는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 4 항에 있어서,상기 보안 프로세서는보안 메모리(435) 상에 생성된 PQC 키 쌍을 보관할 수 있을 만큼 저장 공간이 남아있는 경우 어플리케이션(412)의 PQC 비밀키를 보안 메모리 상에 저장하고,상기 메인 프로세서 상으로 KeyID, 어플리케이션(412)의 암호화된 PQC 전자서명 개인키, 초기화 벡터, PQC 전자서명 인증서 또는 보안 환경(SEE)에 PQC 비밀키가 저장되었는지 여부 중 적어도 하나를 포함하는 메시지를 전송하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 8 항에 있어서,상기 메인 프로세서는상기 보안 프로세서 상에서 수신된 메시지를 신뢰 환경(TEE)에서 읽을 수 있도록 파싱(parsing)하고,수신된 메시지 상에 포함된 인증서를 검증하고,검증에 성공함에 기반하여 최초 PQC 전자서명 키 생성을 요청한 어플리케이션의 고유 값인 AppId, 어플리케이션이 지정한 별칭(alias) 및 생성된 PQC 전자서명 키 쌍을 상기 메모리 상에 저장하고,상기 어플리케이션 상으로 인증서 검증 결과 및 PQC 전자서명 키 생성 결과를 전송하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 1 항에 있어서,상기 메인 프로세서는상기 어플리케이션으로부터 KEM 키 쌍 생성이 요청됨에 기반하여 신뢰 환경(TEE)에서 PQC KEM 키 쌍을생성하고,초기화 벡터(IV, Initialization Vector) 및 WrapKey에서 유도된 키 암호화 키(KEK, Key Encryption Key)를 이용하여 암호화(wrapping)하며,상기 보안 프로세서 상으로 KEM 키 쌍 생성에 대한 인증을 요청하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 10 항에 있어서,상기 보안 프로세서는PQC 전자서명 비밀키를 이용하여 인증을 수행하고, 상기 메인 프로세서 상으로 전송하며,상기 메인 프로세서는상기 보안 프로세서로부터 인증 결과가 수신됨에 기반하여 수신된 인증서를 보안 환경(SEE)의 공개키로 검증하고,검증에 성공함에 기반하여 수신된 인증서 및 암호화된(wrapped) KEM 개인키를 상기 메모리 상에 저장하고,공개특허 10-2025-0035407-5-KEM 키 쌍 생성에 대한 결과 및 인증 결과를 상기 어플리케이션 상으로 전송하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 1 항에 있어서,상기 메인 프로세서는상기 어플리케이션으로부터 PQC 전자서명을 위한 키 쌍에 대한 정보 및 서명이 필요한 메시지를 수신하고,상기 PQC 전자서명을 위한 키 쌍에 대응하는 개인키가 보안 메모리 상에 저장되어 있는지 확인하고,상기 PQC 전자서명을 위한 키 쌍에 대응하는 개인키가 상기 보안 메모리 상에 저장되어 있음에 기반하여 상기보안 프로세서 상으로 개인키에 대응하는 KeyId 및 서명이 필요한 메시지를 전송하며,상기 보안 프로세서는상기 메인 프로세서로부터 개인키에 대응하는 KeyId 및 서명이 필요한 메시지가 수신됨에 기반하여 상기 보안메모리 상에서 KeyID에 대응하는 PQC 전자서명 개인키를 읽어내고,상기 읽어낸 PQC 전자서명 개인키를 이용하여 서명이 필요한 메시지 상에 서명을 생성하며,생성된 서명 및 메시지를 상기 메인 프로세서 상으로 전송하는 전자 장치."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "전자 장치의 동작 방법에 있어서,전자 서명(sig) 및 키 캡슐화(key encapsulation mechanism, KEM) 동작을 수행함에 있어서,신뢰 환경(TEE) 또는 보안 환경(SEE) 중 어느 하나에서 동작이 실행되었을 때 연산 속도를 확인하는 동작;및확인된 연산 속도에 기반하여 전자 서명(sig) 및 키 캡슐화(key encapsulation, mechanism, KEM) 동작이 수행되는 실행 환경을 다르게 결정하는 동작을 포함하며,상기 실행 환경은보안 환경(SEE) 및 신뢰 환경(TEE)을 포함하는 방법."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 13항에 있어서,일반 환경(REE) 상에서 어플리케이션의 검증 요청이 확인됨에 기반하여 신뢰 환경(TEE)으로 검증 요청을 전달하는 동작;상기 신뢰 환경(TEE) 상에서 공개키와 개인키를 포함하는 PQC 키 페어(key pair)를 생성하는 동작;생성된 개인키에 대해 키 암호 키(KEK, key-encryption-key) 및 초기화 벡터(IV, initialization vector)를 이용하여 암호화(wrapping)하는 동작;보안 환경(SEE)에서 작동하는 보안 프로세서 상으로 인증서에 대한 서명을 요청하는 동작;상기 보안 프로세서로부터 서명이 수신됨에 기반하여 상기 수신된 서명 및 인증서에 대해 상기 일반 환경(REE)상에서 상기 보안 환경(SEE)의 공개키를 이용하여 검증을 수행하는 동작;및검증이 성공함에 기반하여 인증서, 암호화된 개인키 및 검증을 요청한 어플리케이션의 식별정보(ID)를 메모리(130) 상에 저장하고, 검증 결과를 상기 어플리케이션으로 전송하는 동작을 더 포함하는 방법.공개특허 10-2025-0035407-6-청구항 15 제 14항에 있어서,상기 일반 환경(REE) 상에서 어플리케이션으로부터 암호화된 개인키에 대한 정보 및 서명이 필요한 메시지를 수신함에 기반하여 대응하는 개인키가 상기 보안 환경(SEE) 상의 보안 메모리(225) 에 저장되어 있는지 확인하는동작대응하는 개인키가 상기 보안 메모리에 저장되어 있음에 기반하여 개인키에 대한 정보 및 서명이 필요한 메시지를 상기 신뢰 환경(TEE)으로 전달하는 동작;상기 신뢰 환경을 이용하여 개인키에 대한 정보 및 서명이 필요한 메시지를 상기 보안 프로세서 상으로 전송하는 동작;수신된 개인키에 대한 정보에 기반하여 상기 보안 메모리에 저장된 개인키를 확인하고, 확인된 개인키를 이용하여 서명이 필요한 메시지에 대한 서명을 생성하는 동작;및상기 어플리케이션으로부터 키 생성 요청을 수신하고, APDU(application protocol data unit) 포멧을 사용하는메시지로 변환하며, 변환된 메시지를 상기 보안 프로세서 상으로 전송하는 동작을 더 포함하는 방법."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 15항에 있어서,WrapKey가 생성되어 있지 않음에 기반하여 WrapKey를 생성하여 보안 메모리에 저장하는 동작;및WrapKey가 생성되어 있음에 기반하여 WrapKey와 대응하는 고유 값을 상기 보안 메모리 상에서 읽어내는 동작을더 포함하며,상기 WrapKey는상기 어플리케이션의 보안 기능 요청이 수신된 실행 환경 밖으로 노출되지 않는 키를 의미하고, 대칭 암호를 이용하여 만들어진 것을 특징으로 하는 방법."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제 16항에 있어서,초기화 벡터(IV, Initialization Vector) 및 WrapKey에서 유도된 키 암호화 키(KEK, Key Encryption Key)를 생성하는 동작;및공개키와 비밀키를 포함하는 PQC 전자서명 키 쌍을 생성하는 동작을 더 포함하는 방법."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제 17항에 있어서,생성된 PQC 전자서명 키 쌍 중에서 비밀키에 대해 키 암호화 키(KEK, Key Encryption Key)를 이용하여 암호화하는 동작;및상기 생성된 PQC 전자서명 키 쌍 중에서 공개키는 인증서에 포함시키는 동작을 더 포함하는 방법."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 15항에 있어서,보안 메모리(435) 상에 생성된 PQC 키 쌍을 보관할 수 있을 만큼 저장 공간이 남아있는 경우 어플리케이션(41공개특허 10-2025-0035407-7-2)의 PQC 비밀키를 보안 메모리 상에 저장하는 동작;및메인 프로세서 상으로 KeyID, 어플리케이션(412)의 암호화된 PQC 전자서명 개인키, 초기화 벡터, PQC 전자서명인증서 또는 보안 환경(SEE)에 PQC 비밀키가 저장되었는지 여부 중 적어도 하나를 포함하는 메시지를 전송하는동작을 더 포함하는 방법."}
{"patent_id": "10-2023-0167547", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제 19항에 있어서,상기 보안 프로세서 상에서 수신된 메시지를 신뢰 환경(TEE)에서 읽을 수 있도록 파싱(parsing)하는 동작;수신된 메시지 상에 포함된 인증서를 검증하는 동작;검증에 성공함에 기반하여 최초 PQC 전자서명 키 생성을 요청한 어플리케이션의 고유 값인 AppId, 어플리케이션이 지정한 별칭(alias) 및 생성된 PQC 전자서명 키 쌍을 메모리 상에 저장하는 동작;및상기 어플리케이션 상으로 인증서 검증 결과 및 PQC 전자서명 키 생성 결과를 전송하는 동작을 더 포함하는 방법."}
{"patent_id": "10-2023-0167547", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "다양한 실시예들에 따른 전자 장치는 일반 환경(REE, rich execution environment)과 신뢰 환경(TEE, trusted execution environment) 상에서 동작을 수행하는 메인 프로세서 및 메인 프로세서와 물리적으로 구분되어 보안 환경(SEE, secure execution environment)상에서 동작을 수행하는 보안 프로세서를 포함할 수 있다. 메인 프로세서는 전자 서명(sig) 및 키 캡슐화(key encapsulation mechanism, KEM) 동작을 수행함에 있어서, 신뢰 환 경(TEE) 또는 보안 환경(SEE) 중 어느 하나에서 동작이 실행되었을 때 연산 속도를 확인하고, 확인된 연산 속도 에 기반하여 전자 서명(sig) 및 키 캡슐화(key encapsulation, mechanism, KEM) 동작이 수행되는 실행 환경을 다르게 결정하며, 실행 환경은 보안 환경(SEE) 및 신뢰 환경(TEE)을 포함할 수 있다."}
{"patent_id": "10-2023-0167547", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 문서는 전자 장치에 관한 것이며, 구체적으로는 보안 기능을 제공하는 전자 장치 및 그의 동작 방법에 관한 것이다"}
{"patent_id": "10-2023-0167547", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "최근 스마트폰을 포함하는 모바일 기기 또는 보안 및 프라이버시가 필요한 기기는 프로세서 수준에서 하드웨어 지원(Hardware-backed) 보안 기술을 제공할 수 있다. 프로세서의 연산 처리는 일반 환경(REE, Rich Execution Environment)과 신뢰 환경(TEE, Trusted Execution Environment)으로 구분된다. 따라서 REE에 위치한 운영체제(OS, Operating System)가 공격자에 의해 루팅 (Rooting, 관리자 권한을 탈취)되어도, 공격자가 기기의 TEE 영역으로 직접 접근하는 것은 제한될 수 있다. TEE는 프로세서 내부의 레지스터 수준에서 REE와 물리적으로 구분되지만, 프로세서 외부의 RAM, Flash 등과 같 은 주변 장치의 경우, 물리적으로 구분되지 않고 암호화, 접근제어 등을 통해 논리적으로 실행 환경을 구분할 수 있다. 따라서, 공격자는 TEE 영역에 저장된 평문 데이터에 일반적으로 접근할 수는 없지만, 루팅 후 암호화 된 데이터에는 접근이 가능할 수 있다. 공격자가 암호화된 중요 데이터를 임의로 훼손하는 경우, 전자 장치는 서비스 거부(DoS, Denial of Service) 상태에 빠질 수 있다. 전자 장치는 서비스 거부(DoS, Denial of Service) 상태에 빠지는 것을 방지하기 위해, 모든 실행 환경을 메인 프로세서와 물리적으로 구분하는 보안 환경(SEE, Secure Execution Environment)을 별도로 지원할 수 있다. 현대 컴퓨팅에서는 키 길이가 증가하면 경우의 수가 지수적으로 늘어나므로, 암호 해독에 필요한 연산 역시 기 하급수적으로 증가했지만, 양자 컴퓨팅에서는 키 길이의 증가가 지수적 연산량 증가로 이어지지 않을 수 있다. 양자 컴퓨팅이 구현되는 경우 대부분의 현대 공개키 암호를 무력화할 수 있으므로 양자 컴퓨팅에 대비하여 보안 환경(SEE)을 이용하여 TEE보다 높은 수준의 보안을 제공할 필요가 있다. 보안 환경(SEE)에서 프로세서 및 메모 리를 포함한 실행환경은 제한될 수 있다.본 문서의 다양한 실시예들에 따른 전자 장치는 TEE와 SEE를 포함하는 복수의 기종들로 구성된 보안 환경에서 PQC를 효율적으로 범용 지원할 수 있다. 다양한 실시예들에 따른 전자 장치는 일반 환경(REE, rich execution environment)과 신뢰 환경(TEE, trusted execution environment) 상에서 동작을 수행하는 메인 프로세서 및 메인 프로세서와 물리적으로 구분되어 보안 환경(SEE, secure execution environment)상에서 동작을 수행하는 보안 프로세서를 포함할 수 있다. 메인 프로세서는 전자 서명(sig) 및 키 캡슐화(key encapsulation mechanism, KEM) 동작을 수행함에 있어서, 신뢰 환경(TEE) 또는 보안 환경(SEE) 중 어느 하나에서 동작이 실행되었을 때 연산 속도를 확인하고, 확인된 연산 속 도에 기반하여 전자 서명(sig) 및 키 캡슐화(key encapsulation, mechanism, KEM) 동작이 수행되는 실행 환경 을 다르게 결정하며, 실행 환경은 보안 환경(SEE) 및 신뢰 환경(TEE)을 포함할 수 있다. 다양한 실시예들에 따른 전자 장치의 동작 방법은 전자 서명(sig) 및 키 캡슐화(key encapsulation mechanism, KEM) 동작을 수행함에 있어서, 신뢰 환경(TEE) 또는 보안 환경(SEE) 중 어느 하나에서 동작이 실행되었을 때 연 산 속도를 확인하는 동작 및 확인된 연산 속도에 기반하여 전자 서명(sig) 및 키 캡슐화(key encapsulation, mechanism, KEM) 동작이 수행되는 실행 환경을 다르게 결정하는 동작을 포함할 수 있다. 본 문서의 다양한 실시예들에 따른 전자 장치는 PQC 알고리즘의 수행에 환경을 보안 수준이 상대적으로 높은 보안 환경(SEE)이나, 상대적으로 연산 속도가 빠른 신뢰 환경(TEE)으로 고정하지 않고, 복수의 환경들을 상황 별로 모두 이용할 수 있다. 전자 장치는 PQC 알고리즘의 특성을 고려하여, KEM 알고리즘은 상대적으로 연산 속 도가 빠른 신뢰 환경(TEE)에서 수행할 수 있다. 반면, 전자 장치는 공개키가 포함된 인증서의 최종 서명은 보안 수준이 상대적으로 높은 보안 환경(SEE)에서 수행할 수 있다. 전자 장치는 인증서의 최종 서명은 보안 수준이 상대적으로 높은 보안 환경(SEE)에서 수행하여 인증서의 검증 및 보안 수준을 보안 환경(SEE) 수준으로 유지할 수 있다. 본 문서의 다양한 실시예들에 따른 전자 장치는 암호화된(Wrapped) PQC 전자서명 개인키의 전송, 암호화된 PQC 개인키를 복호화할 수 있는 KEK의 유도 또는 PQC 전자서명 개인키의 복호화(Unwrapping) 중 적어도 어느 하나의 동작을 생략하여 암호화 및 연산에 소요되는 시간을 감소시킬 수 있다."}
{"patent_id": "10-2023-0167547", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 1, "content": "도 1은, 다양한 실시예들에 따른, 네트워크 환경 내의 전자 장치의 블록도이다. 도 1을 참조하면, 네 트워크 환경에서 전자 장치는 제 1 네트워크(예: 근거리 무선 통신 네트워크)를 통하여 전자 장 치와 통신하거나, 또는 제 2 네트워크(예: 원거리 무선 통신 네트워크)를 통하여 전자 장치 또 는 서버 중 적어도 하나와 통신할 수 있다. 일실시예에 따르면, 전자 장치는 서버를 통하여 전 자 장치와 통신할 수 있다. 일실시예에 따르면, 전자 장치는 프로세서, 메모리, 입력 모듈, 음향 출력 모듈, 디스플레이 모듈, 오디오 모듈, 센서 모듈, 인터페이스, 연 결 단자, 햅틱 모듈, 카메라 모듈, 전력 관리 모듈, 배터리, 통신 모듈, 가입 자 식별 모듈, 또는 안테나 모듈을 포함할 수 있다. 어떤 실시예에서는, 전자 장치에는, 이 구 성요소들 중 적어도 하나(예: 연결 단자)가 생략되거나, 하나 이상의 다른 구성요소가 추가될 수 있다. 어 떤 실시예에서는, 이 구성요소들 중 일부들(예: 센서 모듈, 카메라 모듈, 또는 안테나 모듈)은 하나의 구성요소(예: 디스플레이 모듈)로 통합될 수 있다. 프로세서는, 예를 들면, 소프트웨어(예: 프로그램)를 실행하여 프로세서에 연결된 전자 장치 의 적어도 하나의 다른 구성요소(예: 하드웨어 또는 소프트웨어 구성요소)를 제어할 수 있고, 다양한 데이 터 처리 또는 연산을 수행할 수 있다. 일실시예에 따르면, 데이터 처리 또는 연산의 적어도 일부로서, 프로세서 는 다른 구성요소(예: 센서 모듈 또는 통신 모듈)로부터 수신된 명령 또는 데이터를 휘발성 메 모리에 저장하고, 휘발성 메모리에 저장된 명령 또는 데이터를 처리하고, 결과 데이터를 비휘발성 메 모리에 저장할 수 있다. 일실시예에 따르면, 프로세서는 메인 프로세서(예: 중앙 처리 장치 또 는 어플리케이션 프로세서) 또는 이와는 독립적으로 또는 함께 운영 가능한 보조 프로세서(예: 그래픽 처 리 장치, 신경망 처리 장치(NPU: neural processing unit), 이미지 시그널 프로세서, 센서 허브 프로세서, 또는 커뮤니케이션 프로세서)를 포함할 수 있다. 예를 들어, 전자 장치가 메인 프로세서 및 보조 프로세서 를 포함하는 경우, 보조 프로세서는 메인 프로세서보다 저전력을 사용하거나, 지정된 기능에 특 화되도록 설정될 수 있다. 보조 프로세서는 메인 프로세서와 별개로, 또는 그 일부로서 구현될 수 있 다. 보조 프로세서는, 예를 들면, 메인 프로세서가 인액티브(예: 슬립) 상태에 있는 동안 메인 프로세서 를 대신하여, 또는 메인 프로세서가 액티브(예: 어플리케이션 실행) 상태에 있는 동안 메인 프로세서 와 함께, 전자 장치의 구성요소들 중 적어도 하나의 구성요소(예: 디스플레이 모듈, 센서 모듈 , 또는 통신 모듈)와 관련된 기능 또는 상태들의 적어도 일부를 제어할 수 있다. 일실시예에 따르면, 보조 프로세서(예: 이미지 시그널 프로세서 또는 커뮤니케이션 프로세서)는 기능적으로 관련 있는 다른 구 성요소(예: 카메라 모듈 또는 통신 모듈)의 일부로서 구현될 수 있다. 일실시예에 따르면, 보조 프로 세서(예: 신경망 처리 장치)는 인공지능 모델의 처리에 특화된 하드웨어 구조를 포함할 수 있다. 인공지능 모델은 기계 학습을 통해 생성될 수 있다. 이러한 학습은, 예를 들어, 인공지능 모델이 수행되는 전자 장치 자체에서 수행될 수 있고, 별도의 서버(예: 서버)를 통해 수행될 수도 있다. 학습 알고리즘은, 예를 들어, 지도형 학습(supervised learning), 비지도형 학습(unsupervised learning), 준지도형 학습(semi- supervised learning) 또는 강화 학습(reinforcement learning)을 포함할 수 있으나, 전술한 예에 한정되지 않 는다. 인공지능 모델은, 복수의 인공 신경망 레이어들을 포함할 수 있다. 인공 신경망은 심층 신경망(DNN: deep neural network), CNN(convolutional neural network), RNN(recurrent neural network), RBM(restricted boltzmann machine), DBN(deep belief network), BRDNN(bidirectional recurrent deep neural network), 심층 Q-네트워크(deep Q-networks) 또는 상기 중 둘 이상의 조합 중 하나일 수 있으나, 전술한 예에 한정되지 않는다. 인공지능 모델은 하드웨어 구조 이외에, 추가적으로 또는 대체적으로, 소프트웨어 구조를 포함할 수 있 다. 메모리는, 전자 장치의 적어도 하나의 구성요소(예: 프로세서 또는 센서 모듈)에 의해 사 용되는 다양한 데이터를 저장할 수 있다. 데이터는, 예를 들어, 소프트웨어(예: 프로그램) 및, 이와 관련 된 명령에 대한 입력 데이터 또는 출력 데이터를 포함할 수 있다. 메모리는, 휘발성 메모리 또는 비 휘발성 메모리를 포함할 수 있다. 프로그램은 메모리에 소프트웨어로서 저장될 수 있으며, 예를 들면, 운영 체제, 미들 웨어 또는 어플리케이션을 포함할 수 있다. 입력 모듈은, 전자 장치의 구성요소(예: 프로세서)에 사용될 명령 또는 데이터를 전자 장치 의 외부(예: 사용자)로부터 수신할 수 있다. 입력 모듈은, 예를 들면, 마이크, 마우스, 키보드, 키 (예: 버튼), 또는 디지털 펜(예: 스타일러스 펜)을 포함할 수 있다. 음향 출력 모듈은 음향 신호를 전자 장치의 외부로 출력할 수 있다. 음향 출력 모듈은, 예를 들 면, 스피커 또는 리시버를 포함할 수 있다. 스피커는 멀티미디어 재생 또는 녹음 재생과 같이 일반적인 용도로 사용될 수 있다. 리시버는 착신 전화를 수신하기 위해 사용될 수 있다. 일실시예에 따르면, 리시버는 스피커와 별개로, 또는 그 일부로서 구현될 수 있다.디스플레이 모듈은 전자 장치의 외부(예: 사용자)로 정보를 시각적으로 제공할 수 있다. 디스플레이 모듈은, 예를 들면, 디스플레이, 홀로그램 장치, 또는 프로젝터 및 해당 장치를 제어하기 위한 제어 회로 를 포함할 수 있다. 일실시예에 따르면, 디스플레이 모듈은 터치를 감지하도록 설정된 터치 센서, 또는 상 기 터치에 의해 발생되는 힘의 세기를 측정하도록 설정된 압력 센서를 포함할 수 있다. 오디오 모듈은 소리를 전기 신호로 변환시키거나, 반대로 전기 신호를 소리로 변환시킬 수 있다. 일실시예 에 따르면, 오디오 모듈은, 입력 모듈을 통해 소리를 획득하거나, 음향 출력 모듈, 또는 전자 장치와 직접 또는 무선으로 연결된 외부 전자 장치(예: 전자 장치)(예: 스피커 또는 헤드폰)를 통해 소리를 출력할 수 있다. 센서 모듈은 전자 장치의 작동 상태(예: 전력 또는 온도), 또는 외부의 환경 상태(예: 사용자 상태) 를 감지하고, 감지된 상태에 대응하는 전기 신호 또는 데이터 값을 생성할 수 있다. 일실시예에 따르면, 센서 모듈은, 예를 들면, 제스처 센서, 자이로 센서, 기압 센서, 마그네틱 센서, 가속도 센서, 그립 센서, 근접 센서, 컬러 센서, IR(infrared) 센서, 생체 센서, 온도 센서, 습도 센서, 또는 조도 센서를 포함할 수 있다. 인터페이스는 전자 장치가 외부 전자 장치(예: 전자 장치)와 직접 또는 무선으로 연결되기 위해 사용될 수 있는 하나 이상의 지정된 프로토콜들을 지원할 수 있다. 일실시예에 따르면, 인터페이스는, 예 를 들면, HDMI(high definition multimedia interface), USB(universal serial bus) 인터페이스, SD카드 인터 페이스, 또는 오디오 인터페이스를 포함할 수 있다. 연결 단자는, 그를 통해서 전자 장치가 외부 전자 장치(예: 전자 장치)와 물리적으로 연결될 수 있는 커넥터를 포함할 수 있다. 일실시예에 따르면, 연결 단자는, 예를 들면, HDMI 커넥터, USB 커넥터, SD 카드 커넥터, 또는 오디오 커넥터(예: 헤드폰 커넥터)를 포함할 수 있다. 햅틱 모듈은 전기적 신호를 사용자가 촉각 또는 운동 감각을 통해서 인지할 수 있는 기계적인 자극(예: 진 동 또는 움직임) 또는 전기적인 자극으로 변환할 수 있다. 일실시예에 따르면, 햅틱 모듈은, 예를 들면, 모터, 압전 소자, 또는 전기 자극 장치를 포함할 수 있다. 카메라 모듈은 정지 영상 및 동영상을 촬영할 수 있다. 일실시예에 따르면, 카메라 모듈은 하나 이상 의 렌즈들, 이미지 센서들, 이미지 시그널 프로세서들, 또는 플래시들을 포함할 수 있다. 전력 관리 모듈은 전자 장치에 공급되는 전력을 관리할 수 있다. 일실시예에 따르면, 전력 관리 모듈 은, 예를 들면, PMIC(power management integrated circuit)의 적어도 일부로서 구현될 수 있다. 배터리는 전자 장치의 적어도 하나의 구성요소에 전력을 공급할 수 있다. 일실시예에 따르면, 배터리 는, 예를 들면, 재충전 불가능한 1차 전지, 재충전 가능한 2차 전지 또는 연료 전지를 포함할 수 있다. 통신 모듈은 전자 장치와 외부 전자 장치(예: 전자 장치, 전자 장치, 또는 서버) 간 의 직접(예: 유선) 통신 채널 또는 무선 통신 채널의 수립, 및 수립된 통신 채널을 통한 통신 수행을 지원할 수 있다. 통신 모듈은 프로세서(예: 어플리케이션 프로세서)와 독립적으로 운영되고, 직접(예: 유선) 통 신 또는 무선 통신을 지원하는 하나 이상의 커뮤니케이션 프로세서를 포함할 수 있다. 일실시예에 따르면, 통신 모듈은 무선 통신 모듈(예: 셀룰러 통신 모듈, 근거리 무선 통신 모듈, 또는 GNSS(global navigation satellite system) 통신 모듈) 또는 유선 통신 모듈(예: LAN(local area network) 통신 모듈, 또는 전력선 통신 모듈)을 포함할 수 있다. 이들 통신 모듈 중 해당하는 통신 모듈은 제 1 네트워크(예: 블루투스, WiFi(wireless fidelity) direct 또는 IrDA(infrared data association)와 같은 근거리 통신 네트워 크) 또는 제 2 네트워크(예: 레거시 셀룰러 네트워크, 5G 네트워크, 차세대 통신 네트워크, 인터넷, 또는 컴퓨터 네트워크(예: LAN 또는 WAN)와 같은 원거리 통신 네트워크)를 통하여 외부의 전자 장치와 통신할 수 있다. 이런 여러 종류의 통신 모듈들은 하나의 구성요소(예: 단일 칩)로 통합되거나, 또는 서로 별도의 복수 의 구성요소들(예: 복수 칩들)로 구현될 수 있다. 무선 통신 모듈은 가입자 식별 모듈에 저장된 가입 자 정보(예: 국제 모바일 가입자 식별자(IMSI))를 이용하여 제 1 네트워크 또는 제 2 네트워크와 같 은 통신 네트워크 내에서 전자 장치를 확인 또는 인증할 수 있다. 무선 통신 모듈은 4G 네트워크 이후의 5G 네트워크 및 차세대 통신 기술, 예를 들어, NR 접속 기술(new radio access technology)을 지원할 수 있다. NR 접속 기술은 고용량 데이터의 고속 전송(eMBB(enhanced mobile broadband)), 단말 전력 최소화와 다수 단말의 접속(mMTC(massive machine type communications)), 또 는 고신뢰도와 저지연(URLLC(ultra-reliable and low-latency communications))을 지원할 수 있다. 무선 통신모듈은, 예를 들어, 높은 데이터 전송률 달성을 위해, 고주파 대역(예: mmWave 대역)을 지원할 수 있다. 무선 통신 모듈은 고주파 대역에서의 성능 확보를 위한 다양한 기술들, 예를 들어, 빔포밍(beamforming), 거대 배열 다중 입출력(massive MIMO(multiple-input and multiple-output)), 전차원 다중입출력(FD-MIMO: full dimensional MIMO), 어레이 안테나(array antenna), 아날로그 빔형성(analog beam-forming), 또는 대규모 안테나(large scale antenna)와 같은 기술들을 지원할 수 있다. 무선 통신 모듈은 전자 장치, 외부 전자 장치(예: 전자 장치) 또는 네트워크 시스템(예: 제 2 네트워크)에 규정되는 다양한 요구사항을 지원할 수 있다. 일실시예에 따르면, 무선 통신 모듈은 eMBB 실현을 위한 Peak data rate(예: 20Gbps 이 상), mMTC 실현을 위한 손실 Coverage(예: 164dB 이하), 또는 URLLC 실현을 위한 U-plane latency(예: 다운링 크(DL) 및 업링크(UL) 각각 0.5ms 이하, 또는 라운드 트립 1ms 이하)를 지원할 수 있다. 안테나 모듈은 신호 또는 전력을 외부(예: 외부의 전자 장치)로 송신하거나 외부로부터 수신할 수 있다. 일실시예에 따르면, 안테나 모듈은 서브스트레이트(예: PCB) 위에 형성된 도전체 또는 도전성 패턴으로 이 루어진 방사체를 포함하는 안테나를 포함할 수 있다. 일실시예에 따르면, 안테나 모듈은 복수의 안테나들 (예: 어레이 안테나)을 포함할 수 있다. 이런 경우, 제 1 네트워크 또는 제 2 네트워크와 같은 통신 네트워크에서 사용되는 통신 방식에 적합한 적어도 하나의 안테나가, 예를 들면, 통신 모듈에 의하여 상기 복수의 안테나들로부터 선택될 수 있다. 신호 또는 전력은 상기 선택된 적어도 하나의 안테나를 통하여 통신 모 듈과 외부의 전자 장치 간에 송신되거나 수신될 수 있다. 어떤 실시예에 따르면, 방사체 이외에 다른 부품 (예: RFIC(radio frequency integrated circuit))이 추가로 안테나 모듈의 일부로 형성될 수 있다. 다양한 실시예에 따르면, 안테나 모듈은 mmWave 안테나 모듈을 형성할 수 있다. 일실시예에 따르면, mmWave 안테나 모듈은 인쇄 회로 기판, 상기 인쇄 회로 기판의 제 1 면(예: 아래 면)에 또는 그에 인접하여 배 치되고 지정된 고주파 대역(예: mmWave 대역)을 지원할 수 있는 RFIC, 및 상기 인쇄 회로 기판의 제 2 면(예: 윗 면 또는 측 면)에 또는 그에 인접하여 배치되고 상기 지정된 고주파 대역의 신호를 송신 또는 수신할 수 있 는 복수의 안테나들(예: 어레이 안테나)을 포함할 수 있다. 상기 구성요소들 중 적어도 일부는 주변 기기들간 통신 방식(예: 버스, GPIO(general purpose input and output), SPI(serial peripheral interface), 또는 MIPI(mobile industry processor interface))을 통해 서로 연결되고 신호(예: 명령 또는 데이터)를 상호간에 교환할 수 있다. 일실시예에 따르면, 명령 또는 데이터는 제 2 네트워크에 연결된 서버를 통해서 전자 장치와 외부의 전자 장치간에 송신 또는 수신될 수 있다. 외부의 전자 장치(102, 또는 104) 각각은 전자 장치 와 동일한 또는 다른 종류의 장치일 수 있다. 일실시예에 따르면, 전자 장치에서 실행되는 동작들의 전부 또는 일부는 외부의 전자 장치들(102, 104, 또는 108) 중 하나 이상의 외부의 전자 장치들에서 실행될 수 있다. 예를 들면, 전자 장치가 어떤 기능이나 서비스를 자동으로, 또는 사용자 또는 다른 장치로부터의 요 청에 반응하여 수행해야 할 경우에, 전자 장치는 기능 또는 서비스를 자체적으로 실행시키는 대신에 또는 추가적으로, 하나 이상의 외부의 전자 장치들에게 그 기능 또는 그 서비스의 적어도 일부를 수행하라고 요청할 수 있다. 상기 요청을 수신한 하나 이상의 외부의 전자 장치들은 요청된 기능 또는 서비스의 적어도 일부, 또는 상기 요청과 관련된 추가 기능 또는 서비스를 실행하고, 그 실행의 결과를 전자 장치로 전달할 수 있다. 전자 장치는 상기 결과를, 그대로 또는 추가적으로 처리하여, 상기 요청에 대한 응답의 적어도 일부로서 제공할 수 있다. 이를 위하여, 예를 들면, 클라우드 컴퓨팅, 분산 컴퓨팅, 모바일 에지 컴퓨팅(MEC: mobile edge computing), 또는 클라이언트-서버 컴퓨팅 기술이 이용될 수 있다. 전자 장치는, 예를 들어, 분산 컴퓨팅 또는 모바일 에지 컴퓨팅을 이용하여 초저지연 서비스를 제공할 수 있다. 다른 실시예에 있어서, 외부의 전자 장치는 IoT(internet of things) 기기를 포함할 수 있다. 서버는 기계 학습 및/또는 신경망을 이용한 지능형 서버일 수 있다. 일실시예에 따르면, 외부의 전자 장치 또는 서버는 제 2 네트워크 내에 포함될 수 있다. 전자 장치는 5G 통신 기술 및 IoT 관련 기술을 기반으로 지능형 서비스(예: 스마트 홈, 스마트 시티, 스마트 카, 또는 헬스 케어)에 적용될 수 있다. 본 문서에 개시된 다양한 실시예들에 따른 전자 장치는 다양한 형태의 장치가 될 수 있다. 전자 장치는, 예를 들면, 휴대용 통신 장치(예: 스마트폰), 컴퓨터 장치, 휴대용 멀티미디어 장치, 휴대용 의료 기기, 카메라, 웨 어러블 장치, 또는 가전 장치를 포함할 수 있다. 본 문서의 실시예에 따른 전자 장치는 전술한 기기들에 한정되 지 않는다. 본 문서의 다양한 실시예들 및 이에 사용된 용어들은 본 문서에 기재된 기술적 특징들을 특정한 실시예들로 한 정하려는 것이 아니며, 해당 실시예의 다양한 변경, 균등물, 또는 대체물을 포함하는 것으로 이해되어야 한다.도면의 설명과 관련하여, 유사한 또는 관련된 구성요소에 대해서는 유사한 참조 부호가 사용될 수 있다. 아이템 에 대응하는 명사의 단수 형은 관련된 문맥상 명백하게 다르게 지시하지 않는 한, 상기 아이템 한 개 또는 복수 개를 포함할 수 있다. 본 문서에서, \"A 또는 B\", \"A 및 B 중 적어도 하나\", \"A 또는 B 중 적어도 하나\", \"A, B 또는 C\", \"A, B 및 C 중 적어도 하나\", 및 \"A, B, 또는 C 중 적어도 하나\"와 같은 문구들 각각은 그 문구들 중 해당하는 문구에 함께 나열된 항목들 중 어느 하나, 또는 그들의 모든 가능한 조합을 포함할 수 있다. \"제 1\", \"제 2\", 또는 \"첫째\" 또는 \"둘째\"와 같은 용어들은 단순히 해당 구성요소를 다른 해당 구성요소와 구분하기 위 해 사용될 수 있으며, 해당 구성요소들을 다른 측면(예: 중요성 또는 순서)에서 한정하지 않는다. 어떤(예: 제 1) 구성요소가 다른(예: 제 2) 구성요소에, \"기능적으로\" 또는 \"통신적으로\"라는 용어와 함께 또는 이런 용어 없이, \"커플드\" 또는 \"커넥티드\"라고 언급된 경우, 그것은 상기 어떤 구성요소가 상기 다른 구성요소에 직접적 으로(예: 유선으로), 무선으로, 또는 제 3 구성요소를 통하여 연결될 수 있다는 것을 의미한다. 본 문서의 다양한 실시예들에서 사용된 용어 \"모듈\"은 하드웨어, 소프트웨어 또는 펌웨어로 구현된 유닛을 포함 할 수 있으며, 예를 들면, 로직, 논리 블록, 부품, 또는 회로와 같은 용어와 상호 호환적으로 사용될 수 있다. 모듈은, 일체로 구성된 부품 또는 하나 또는 그 이상의 기능을 수행하는, 상기 부품의 최소 단위 또는 그 일부 가 될 수 있다. 예를 들면, 일실시예에 따르면, 모듈은 ASIC(application-specific integrated circuit)의 형 태로 구현될 수 있다. 본 문서의 다양한 실시예들은 기기(machine)(예: 전자 장치) 의해 읽을 수 있는 저장 매체(storage medium)(예: 내장 메모리 또는 외장 메모리)에 저장된 하나 이상의 명령어들을 포함하는 소프트웨어 (예: 프로그램)로서 구현될 수 있다. 예를 들면, 기기(예: 전자 장치)의 프로세서(예: 프로세서 )는, 저장 매체로부터 저장된 하나 이상의 명령어들 중 적어도 하나의 명령을 호출하고, 그것을 실행할 수 있다. 이것은 기기가 상기 호출된 적어도 하나의 명령어에 따라 적어도 하나의 기능을 수행하도록 운영되는 것 을 가능하게 한다. 상기 하나 이상의 명령어들은 컴파일러에 의해 생성된 코드 또는 인터프리터에 의해 실행될 수 있는 코드를 포함할 수 있다. 기기로 읽을 수 있는 저장 매체는, 비일시적(non-transitory) 저장 매체의 형 태로 제공될 수 있다. 여기서, '비일시적'은 저장 매체가 실재(tangible)하는 장치이고, 신호(signal)(예: 전자 기파)를 포함하지 않는다는 것을 의미할 뿐이며, 이 용어는 데이터가 저장 매체에 반영구적으로 저장되는 경우 와 임시적으로 저장되는 경우를 구분하지 않는다. 일실시예에 따르면, 본 문서에 개시된 다양한 실시예들에 따른 방법은 컴퓨터 프로그램 제품(computer program product)에 포함되어 제공될 수 있다. 컴퓨터 프로그램 제품은 상품으로서 판매자 및 구매자 간에 거래될 수 있 다. 컴퓨터 프로그램 제품은 기기로 읽을 수 있는 저장 매체(예: compact disc read only memory(CD-ROM))의 형태로 배포되거나, 또는 어플리케이션 스토어(예: 플레이 스토어TM)를 통해 또는 두 개의 사용자 장치들(예: 스마트 폰들) 간에 직접, 온라인으로 배포(예: 다운로드 또는 업로드)될 수 있다. 온라인 배포의 경우에, 컴퓨 터 프로그램 제품의 적어도 일부는 제조사의 서버, 어플리케이션 스토어의 서버, 또는 중계 서버의 메모리와 같 은 기기로 읽을 수 있는 저장 매체에 적어도 일시 저장되거나, 임시적으로 생성될 수 있다. 다양한 실시예들에 따르면, 상기 기술한 구성요소들의 각각의 구성요소(예: 모듈 또는 프로그램)는 단수 또는 복수의 개체를 포함할 수 있으며, 복수의 개체 중 일부는 다른 구성요소에 분리 배치될 수도 있다. 다양한 실시 예들에 따르면, 전술한 해당 구성요소들 중 하나 이상의 구성요소들 또는 동작들이 생략되거나, 또는 하나 이상 의 다른 구성요소들 또는 동작들이 추가될 수 있다. 대체적으로 또는 추가적으로, 복수의 구성요소들(예: 모듈 또는 프로그램)은 하나의 구성요소로 통합될 수 있다. 이런 경우, 통합된 구성요소는 상기 복수의 구성요소들 각각의 구성요소의 하나 이상의 기능들을 상기 통합 이전에 상기 복수의 구성요소들 중 해당 구성요소에 의해 수행되는 것과 동일 또는 유사하게 수행할 수 있다. 다양한 실시예들에 따르면, 모듈, 프로그램 또는 다른 구성 요소에 의해 수행되는 동작들은 순차적으로, 병렬적으로, 반복적으로, 또는 휴리스틱하게 실행되거나, 상기 동 작들 중 하나 이상이 다른 순서로 실행되거나, 생략되거나, 또는 하나 이상의 다른 동작들이 추가될 수 있다. 도 2는, 일 실시예에 따른 전자 장치의 보안 직접 회로를 나타내는 블럭도이다. 도 2를 참조하면, 본 문서의 일 실시예에 따른 전자 장치(예: 전자 장치)는 일반 환경(REE: Rich Execution Environment), 신뢰 환경(TEE: Trusted Execution Environment) 및 보안 환경(SEE: Secure Execution Environment)을 제공하는 시스템 온 칩(SoC: System on Chip)의 보안(secure) 집적 회로(IC: integrated circuit)를 포함할 수 있다. 또는 신뢰 환경(TEE: Trusted Execution Environment)은 일반 환경 (REE: Rich Execution Environment)과 물리적으로 구분된 상태일 수 있다.일 실시 예에서, 신뢰 환경(TEE), 또는 보안 환경(SEE)은, 일반적인 보안 수준을 요구하는 일반 환경(REE)보다 상대적으로 높은 보안 수준을 가질 수 있다. 일 실시 예에서, 신뢰 환경 (TEE), 또는 보안 환경(SEE)은, 일반 환경(REE)에 할당된 리소스와 구분되는 리소스를 기반으로 프로그램(예: 프로그램)이 동작하는 환경일 수 있다. 일 실시 예에서, 신뢰 환경(TEE), 또는 보안 환경(SEE)은, 허가되지 않은 프로그램 상에서 신뢰 환경(TEE), 또 는 보안 환경(SEE) 상의 리소스에 접근하는 것을 허용하지 않을 수 있다. 일 실시 예에서, 보안 환경(SEE)은, 신뢰 환경(TEE)보다 상대적으로 높은 보안 수준을 가질 수 있다. 일 실시예에서 보안 환경(SEE) 또는 신뢰 환경 (TEE)은 물리적으로 구분된 실행 환경이 아닌 소프트웨어적으로 구분된 실행 환경일 수 있다. 예컨대, 전자 장 치에서 실행되는 운영 체 제(예: 운영 체제)는 일반 환경(REE)에서, 일반적인 어플리케이션을 통해 서비스를 제공하다가, 보안이 높은 신뢰성이 요구되는 동작을 수행할 경우, 보안 환경(SEE) 또는 신뢰 환경 (TEE)으로 전환하고, 별도의 신뢰성 이 요구되는 서비스를 제공하기 위한 어플리케이션을 실행할 수 있다. 예컨대, 금융 거래를 수행할 경우, 또는, 사용자의 지문 인증이나 비밀번호 입력, 비밀번호 인증과 같은 신뢰성 이 요구되는 기능을 수행할 경우, 전자 장치는, 신뢰 환경(TEE) 또는 보안 환경(SEE)에서 수행되는 생체 인증 어플리케이션을 실행하고, 사용자의 인증을 수행할 수 있다. 일 실시예에서는 보안 환경(SEE) 또는 신뢰 환경(TEE)은 물리적으로 구분된 실행 환경일 수 있다. 예컨대 별도 의 보안 영역이 구축된 보안 메모리 또는 보안 프로세서의 하드웨어 적으로 구분된 환경을 통해서, 높은 보안이 요구되는 기능을 사용자에게 제공할 수 있다. 예를 들어 메인 프로세서는 복수의 코어 프로세 서들을 포함할 수 있다. 일 실시 예에서, 전자 장치에서 사용되는 어플리케이션의 종류에 따라, 메인 프로 세서는 복수의 코어 프로세서들 중 적어도 하나를 선택해서 어플리케이션을 수행할 수 있다. 예컨대 일반 모드(예: 일반 환경(REE))의 경우 전자 장치는, 메인 프로세서의 코어 프로세서들 중 일부를 선택해 서 일반적인 어플리케이션을 수행하고, 보안이 필요한 모드(예: 보안 환경 (SEE) 또는 신뢰 환경(TEE))의 경우, 전자 장치는, 메인 프로세서의 일반 코어 프로세서가 아닌 보안 코어 프로세서를 통해 보안 영역에 접근해서 보안 어플리케이션을 실행할 수 있다. 일 실시 예에서, 메인 프로세서는 일반 환경, 신뢰 환경, 또는 이들의 조합에서 동작할 수 있다. 일 실시 예에서, 메인 프로세서는 일반 환경, 및/또는 신뢰 환경에서 데이터의 처리 및 연산을 제어할 수 있다. 일 실시 예에서, 전자 장치는 메인 프로세서(예: 메인 프로세서), 보안 프로세서(예: 보조 프로세서), 및 보안 메모리를 포함할 수 있다. 일 실시 예에서, 보안 프로세서는 메인 프로세서와 작동적으로(operatively) 연결되어 통신할 수 있 다. 일 실시 예에서, 보안 프로세서는 메인 프로세서로부터 보안 환경의 구동 또는 초기화 요청을 수 신할 수 있다. 일 실시 예에서, 보안 프로세서는 보안 환경에서 동작할 수 있다. 일 실시 예에서, 보안 프로세서는 다양한 구성을 더 포함할 수 있다. 일 실시 예에서, 보안 프로세서(22 3)는 보안 캐쉬(secure cache), ROM, RAM, 메모리 컨트롤러(MEM controller), 보안 센서(security sensors), 또는 이들의 조합을 더 포함할 수 있다. 일 실시 예에서, 보안 메모리는 보안 프로세서와 작동적으로 연결될 수 있다. 일 실시 예에서, 보안 메모리는 보안 프로세서와 사전에 공유된 키를 이용하여 암호화 통신을 수행할 수 있다. 일 실시 예 에서, 보안 메모리는 비휘발성 메모리(NVM) 메모리일 수 있다. 도 2에서는, 전자 장치에 보안 프로세서가 구비되는 것으로 예시하였으나, 이는 예시일 뿐이다. 일 실시 예에서, 전자 장치에 보안 프로세서가 구비되지 않는 경우, 메인 프로세서가 보안 프로세 서의 역할을 수행할 수 있다. 이와 같은 경우에, 보안 메모리의 기능도 일반 환경(REE) 또는 신뢰 환 경(TEE)에서 작동하는 메모리(예: 메모리 )를 통해 제공될 수 있다. 도 3a는 일 실시예에 따른 전자 장치의 실행 환경에 따른 구성 요소를 블록도로 도시한 것이다. 전자 장치(예: 도 2의 전자 장치는 메인 프로세서(예: 도 2의 메인 프로세서) 및 보안 프로세서(예: 도 2의 보안 프로세서)를 포함할 수 있다. 메인 프로세서는 일반 환경(REE: Rich Execution Environment)에서 적어도 하나의 어플리케이션 으로부터 보안과 관련된 요청을 수신할 수 있다. 어플리케이션은 보안 강화를 위해 PQC를 활용하는 적어도 하나의 앱(app)을 의미할 수 있다. 어플리케이션은 예를 들어, 은행, 카드, 간편결제(예: 페이) 또 는 전자상거래 중 어느 하나의 실행과 관련될 수 있다. KeyStore는 REE OS가 지원하는 암호 연산 API(Application Program Interface)를 제공하는 모듈을 의미할 수 있다. KeyMaster는 메인 프로세서에 의해 신뢰 환경에서 동작하는 애플리케이션 중 하나를 의미할 수 있다. KeyMaster는 신뢰 환경에서 수행되는 신뢰할 수 있는 암호 연산을 일반 환경에서 동작하 는 KeyStore에게 제공할 수 있다. SEEDriver는 신뢰 환경(TEE)과 보안 환경(SEE)간의 통신을 수행할 수 있다. 소프트웨어는 표준 APDU 프로토콜을 이용하고, 하드웨어 통신 채널은 보안이 강화된 Secure SPI 를 활용할 수 있다. 이는 구현에 따라 달라질 수 있다. 도 3b는 전자 장치 내 복수의 키들의 저장 위치를 블록도로 나타낸 것이다. TEEWrapKey 및 AppKEMKey는 신뢰 환경의 Keymaster에 저장될 수 있다. KEM(키 캡슐화, Key Encapsulation, Mechanism) 알고리즘은 대칭키를 공개키로 암호화하여 전송하는 방식을 포함할 수 있 다.AppKEMKey는 어플리케이션의 요청에 의해 생성되는 KEM 알고리즘의 키 쌍(예: 공개키와 비밀키)을 의미한다. AppKEMKey는 신뢰 환경에서 생성되고, 보안 환경에서 서명을 받으며, 신뢰 환경(32 0)에서 암호화되어, 일반 환경의 KeyStore에 저장될 수 있다. PQC KeyMaster는 보안 환경에서 수행되는 신뢰할 수 있는 암호 연산을 신뢰 환경의 SEEDriver를 통해 제공하는 모듈이다. 구현에 따라 PQC KeyMaster는 보안 환경에서 지원되는 하드웨어 가속 기능을 포함할 수 있다. AppSigKey, SEEWrapKey는 보안 환경의 StorageManager (예: 6의 보안 메모리) 에 저장될 수 있다. SEE Provisioned Key는 PQC Keymaster만 접근할 수 있는 보안 환경의 ROM 영역에 저장될 수 있 다. SEE의 ROM 영역은 제조사에서 무결성을 보장하는 영역을 의미할 수 있다. 보안 메모리(예: 도 2의 보안 메모리는 보안 환경의 저장소를 관리하는 모듈을 의미할 수 있다. 보안 메모리는 일반 환경에 위치한 KeyStore에 종속된 부가적인 저장소 역할을 수행할 수 있다. SEE Provisioned Key는 PQC 전자서명 알고리즘의 고유한 키 쌍을 의미할 수 있다. 보안 프로세서는 보안 환경에서 이 키 쌍의 비밀키가 보안 환경 밖으로 노출되지 않도록 보호할 수 있다. SEE Provisioned Key는 보안 프로세서의 제조사에서 양산될 때 ROM 영역에 저장될 수 있다. SEE Provisioned Key는 구현에 따라 특정 알고리즘(예: 보안 레벨3의 Dilithium 알고리즘)이 활용될 수 있다. SEE Provisioned Key 키 쌍의 공개키가 포함된 인증서는 보안 프로세서 양산 시점에 제조사의 서명을 받을 수 있다. AppSigKey는 일반 환경에서 어플리케이션이 생성을 요청한 PQC 서명 알고리즘의 키 쌍을 의미할 수 있다. AppSigKey는 보안 환경에서 생성되고, 보안 환경에서 암호화되어, 일반 환경에 저장되는 것이 일반적이나, 본 문서에 따르면 평문 상태로 보안 환경에 추가 저장될 수 있다. 평문(Plain text)은 암호 알고리즘이 적용되지 않은 비트열 또는 문자열을 의미할 수 있다. 암호문 (Chiper text)은 암호 알고리즘이 적용된 비트열, 또는 문자열을 의미할 수 있다. 적어도 하나의 어플리케이션은 API를 통해 특정 PQC 키 쌍을 생성을 요청할 수 있다. 생성 요청된 특정 PQC 키 쌍의 공개키는 발급자인 보안 환경이 가진 Provisioned Keypair의 개인키를 이용하여 생성한 서명 이 포함된 인증서로 발급된다. Provisioned Keypair는 제조사의 개인키로 서명된 인증서를 가질 수 있다. 적어 도 하나의 어플리케이션에서 생성된 키는 신뢰 체인을 생성할 수 있다. 도 3c는 일 실시예에 따른 신뢰 체인의 모습을 도시한 것이다. 신뢰 체인은 PQC를 지원하는 HSM 이 가진 루트 인증서에서 시작될 수 있다. 그림 362에서, HSM의 Root 인 증서는 자기 서명(Self-signed signature)을 가질 수 있다. HSM의 Root 인증서는 HSM 외부로 PQC Root 키 쌍의 비밀키가 유출되지 않았음을 HSM 제조사가 보장하는 역할을 수행할 수 있다. 따라서, 외부 생산자(예: 3rd party)는 HSM에서 발급된 자기 서명 인증서를 무결성이 보장되는 영역(예: KeyStore)에 보관할 수 있다.그림 364에서, HSM에 저장된 PQC 루트 비밀키를 이용하여 발급된 인증서는 보안 환경을 제공하는 보안 프 로세서(예:SE(secure element) 또는 eSE)에 보관될 수 있다. 보안 프로세서의 제조사는 보안 프로세 서가 가진 PQC 키 쌍의 비밀키가 HSM과 마찬가지로 보안 프로세서의 외부로 유출되지 않았음을 보장 할 수 있다. 그림 366에서, 적어도 하나의 어플리케이션에 의해 생성된 PQC 비밀키의 평문은 보안 환경 외부로 유 출되지 않을 수 있다. 외부 서버는 적어도 하나의 어플리케이션에서 전달된 인증서에 포함된 공개키를 신 뢰하기 어려울 수 있다. 이 경우 외부 서버는 인증서에 기록된 발급자의 서명을 검증할 수 있다. 외부 서버는 검증 결과에 기반하여 적어도 하나의 어플리케이션이 보안 환경에서 보호되는 키를 이용하고 있는 것으로 결정할 수 있다. 외부 서버는 보안 환경을 신뢰하기 어려울 수 있다. 그림 368에서, 외부 서버는 보안 환경의 인증서 가 HSM에서 발급된 전자서명을 갖는지 확인할 수 있다. 외부 서버는 보안 환경의 인증서가 HSM에서 발급된 전자서명을 포함하는 경우 적어도 하나의 어플리케이션의 인증서를 신뢰할 수 있다. 전자 장치는 HSM, 보안 환경에서 작동하는 보안 프로세서 및 어플리케이션 사이의 신뢰 체 인을 이용하여 대규모 연산이 수행 가능한 양자 컴퓨팅이 실현되더라도 신뢰할 수 있는 보안 수준을 제공 할 수 있다. 도 4는 일 실시예에 따른 전자 장치에서 전자 서명을 위한 키 쌍이 생성되는 과정을 설명하는 블록도이다. 도 4에 따르면 전자 장치(예: 도 2의 전자 장치)는 일반 환경(REE), 신뢰 환경(TEE) 및 보안 환경(SEE)을 포함할 수 있다. 일반적인 보안 환경을 가진 시스템에 양자 내성 암호(Post Quantum Cryptography 이하 PQC)를 단순 적용하는 경 우 시스템에 큰 부하를 일으킬 수 있다. 일반적인 보안 환경을 가진 시스템에 PQC를 단순 적용하는 경우 어플리 케이션이 제공하는 서비스의 품질 저하를 초래할 수 있다. PQC 알고리즘은 현대 암호 대비 키 길이가 크고 연산 이 무겁기 때문이다. 본 문서의 다양한 실시예에 따른 전자 장치는 현대 암호 대비 키 길이가 크고 연산이 무거운 PQC 알고리즘 을 수행하기 위해 KEM 알고리즘의 수행 환경과 전자서명 수행 환경을 구분할 수 있다. 즉, PQC 알고리즘은 PQC 전자서명 알고리즘과 KEM 알고리즘으로 구분될 수 있다. PQC 전자서명 알고리즘은 키 생성시에 주로 사용되고, KEM 알고리즘은 개별 통신 세션이 시작될 때마다 사용될 수 있다. KEM(키 캡슐화, Key Encapsulation, Mechanism) 알고리즘은 대칭키를 공개키로 암호화하여 전송하는 방식을 포함할 수 있다. KEM 알고리즘은 비대칭 화 암호화에서 대칭 키를 안전하게 전송하기 위해 대칭 키를 공개 키로 암호화하는 방식을 사용할 수 있다. KEM 알고리즘은 캡슐화 (Encapsulation) 및 복원 (Decapsulation) 단계를 포함할 수 있다. 캡슐화 단계에서 전자 장 치는 무작위 대칭 키를 생성하고, 이 키를 수신자의 공개 키로 암호화할 수 있다. 복원 단계에서, 수신자 는 개인키를 사용하여 캡슐을 복호화하고 원래의 대칭키를 추출할 수 있다. 수신자는 이후 추출된 대칭키를 사 용하여 실제 메시지나 데이터를 복호화할 수 있다. PQC 전자서명 알고리즘은 메시지의 무결성과 발신자의 신원을 보증하는데 사용될 수 있다. PQC 전자서명 알고리 즘은 양자 컴퓨터가 실현되더라도 안전하게 사용될 수 있다. 상대적으로 호출 빈도가 낮은 PQC 전자서명 알고리즘은 보안 수준이 높은 보안 환경(SEE)에서 보안 프로세서(예: 도 2의 보안 프로세서)에 의해 수행될 수 있다. 상대적으로 빈도가 높은 KEM 알고리즘은 신 뢰 환경(TEE)에서 메인 프로세서(예: 도 2의 메인 프로세서)에 의해 수행될 수 있다. 메인 프로세서 는 KEM 키 쌍이 최초 생성되는 시점에는 보안 환경(SEE)과 연계할 수 있다. 보안 프로세서는 CA(Certificate Authority)의 역할을 하고, 이를 인증서에 표기할 수 있다. 전자 장치는 인증서 검증 시 보안 환경(SEE)에서 일반 환경(REE)보다 상대적으로 높은 신뢰 수준을 제공할 수 있다. 전자 장치의 보안 환경에서 인가된(Certificated) 인증서는 외부에서 검증되는 시점에 일반 환경(REE) 및 신뢰 환경(TEE)에서 발 급된 인증서와 비교하여 상대적으로 높은 신뢰 수준을 제공할 수 있다. PQC 전자서명 알고리즘을 활용하려는 적어도 하나의 어플리케이션은 키 생성 요청시 공개키가 포함된 표준 인증서의 옵션과 생성될 키의 별칭을 함께 전달할 수 있다. 옵션은 예를 들어, 보안 환경(SEE)의 활용을 선호하 는 지 여부를 포함할 수 있다. 또는 옵션은 예를 들어, KeyUsage처럼 X.509 인증서에 포함될 내용을 의미할 수있다. 생성될 키의 별칭(Alias)은 어플리케이션이 특정 키를 지칭하기 위해 사용하는 임의의 값을 의미한 다. KeyStore는 어플리케이션으로부터 키 생성 요청을 받아 KeyStoreHAL 에게 전달한다. HAL은 하 드웨어 추상화 계층(Hardware Abstraction Layer)을 의미할 수 있다. KeyStoreHAL는 어플리케이션의 요청을 신뢰 환경(TEE)에서 동작하는 SEEDriver 에게 전달할 수 있다. TA는 신뢰 환경(TEE)에서 동작하는 Trusted Application을 의미할 수 있다. 보안 환경(SEE) 영역의 인터페이스는 표준 APDU(application protocol data unit) 포멧을 사용할 수 있다. SEEDriver는 어플리케이션의 요청을 APDU 메시지로 변환하여 PQCKeyMaster에게 전달할 수 있다. PQCKeyMaster는 WrapKey가 생성되어 있지 않은 경우, 최초 1회 WrapKey를 생성하여 보안 메모리에 저장할 수 있다. WrapKey는 보안 환경(SEE) 밖으로 노출되지 않는 키를 의미할 수 있다. PQCKeyMaster는 WrapKey를 생성할 때 특정 방식(예: AES256)으로 생성된 대칭 암호를 사용할 수 있다. 대칭 암호는 동일한 키를 사용하여 암호화와 복호화를 하는 암호를 의미할 수 있다. 평문(Plain text)은 암호 알고리즘이 적용되지 않은 비트열 또는 문자열을 의미할 수 있다. 암호문 (Chiper text)은 암호알고리즘이 적용된 비트열, 또는 문자열 을 의미할 수 있다. PQCKeyMaster는 최초 1회 WrapKey를 생성하여 직접 데이터를 저장하지 않고, 실행 모 듈만으로 유지할 수 있다. PQCKeyMaster는 모듈 업데이트시 기존에 저장된 데이터를 이동시키는데 소요되 는 시간을 감소시키고 업데이트 속도를 향상시킬 수 있다. PQCKeyMaster는 WrapKey가 생성된 이후에는 WrapKey와 대응하는 KeyId를 보안 메모리 로부터 읽을 수 있다. KeyId는 보안 환경(SEE)에서 생성되는 개별 키에 대응하는 고유 값을 의미할 수 있다. 보안 메모리 는 KeyId가 발급될 때마다, 다음 요청에 응답할 KeyId값을 증가시킬 수 있다. 보안 메모리는 KeyId를 이용하여 키를 구분할 수 있다. KeyStore는 개별 키와, 해당 키를 생성한 어플리케이션 및 해당 앱이 키에 부여한 별칭(Alias)에 대한 정보를 저장할 수 있다. PQCKeyMaster는 WrapKey를 이용한 암호화를 위해 초기화 벡터(IV, Initialization Vector)와, WrapKey에 서 유도된 키 암호화 키(KEK, Key Encryption Key)를 생성할 수 있다. PQCKeyMaster는 WrapKey로 바로 암 호화하지 않고, KEK를 유도하여 개별 어플리케이션의 PQC 키 쌍마다 다른 대칭 암호 키를 사용할 수 있다. PQCKeyMaster는 WrapKey로 바로 암호화하지 않고, KEK를 유도하여 보안 환경(SEE)의 제한된 저장 용량을 효율적으로 사용할 수 있다. WrapKey는 암호화된 키를 안전하게 전송하거나 저장하기 위한 수단으로 이용될 수 있다. 전자 장치는 KEK(key encryption key)를 사용하여 실제 데이터를 암호화하는 대칭키(또는 비밀키)를 암호 화할 수 있다. KEK는 Wrapkey에서 유도될 수 있다. 전자 장치는 KEK로 암호화을 수행하여 애플리케이션의 요청에 의해 생성된 키를 암호화(wrapping)하고, 암 호화된 키(wrapped key)를 일반 환경(REE)에 저장할 수 있다. 즉, 전자 장치는 애플리케이션의 요청에 의 해 생성된 키가 평문 상태로 보안 환경 밖으로 노출되지 않도록 제어할 수 있다. 평문 상태는 wrapping이 수행 되지 않은 상태를 의미할 수 있다."}
{"patent_id": "10-2023-0167547", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "초기화 벡터(IV)는 암호화 프로세스에서 블록 체인 암호화를 초기화하는 데 사용되는 임의의 숫자를 의미할 수 있다. 전자 장치는 IV를 무작위로 생성시킬 수 있다. IV는 새로운 메시지나 세션에 대해 각각 새롭게 생성 될 수 있다. 전자 장치는 같은 메시지가 여러 번 전송될 때마다 IV를 통해 메시지를 다르게 암호화시키고, 패턴 분석을 통한 공격을 방지할 수 있다. PQCKeyMaster는 보안 환경(SEE)에서 사용하는 암호 라이브러리를 이용하여, 어플리케이션으로부 터 요청받은 PQC 전자서명 키 쌍을 생성할 수 있다. PQCKeyMaster는 생성된 PQC 전자서명 키 쌍에서 비밀키를 KEK(키 암호화 키)를 이용하여 암호화할 수 있다. PQCKeyMaster는 보안 환경(SEE)에서 사용하는 암호 라이브러리를 이용하여 공개키를 인증서에 포함시킬 수 있다. 이 때 인증서는 PQC 전자서명 비밀키(Provisioned SigSecKey)로 서명된 인증서를 의미할 수있다. PQCKeyMaster는 어플리케이션으로부터 PQC 키 쌍 생성 및 보관에 대한 요청이 수신됨에 기반하여 보 안 메모리 상에 저장 공간이 남아 있는지 확인할 수 있다. PQCKeyMaster는 보안 메모리 상에 PQC 키 쌍을 보관할 수 있을 만큼 저장 공간이 남아있는 경우 어플리케이션의 PQC 비밀키를 보안 메모리 상에 저장할 수 있다. 보안 메모리 상에 PQC 키 쌍을 보관할 수 있을 만큼 저장 공간이 남아있지 않 은 경우는 도 5에서 설명될 것이다. PQCKeyMaster는 PQC 비밀키를 보안 메모리 상에 저장 후 신뢰 환경(TEE)에서 동작하는 SEEDriver 상으로 APDU 메시지를 전송할 수 있다. APDU 메시지는 KeyID, 어플리케이션의 암호화된 PQC 전자서명 개인키, 초기화 벡터, PQC 전자서명 인증서 또는 보안 환경(SEE)에 PQC 비밀키가 저장되었는지 여 부 중 적어도 하나를 포함할 수 있다. SEEDriver는 APDU 메시지를 KeyStore가 읽을 수 있는 값으로 파싱(parsing)할 수 있다. 파싱 (parsing)은 원하는 데이터를 추출하여 가공하기 쉬운 상태로 바꾸는 과정을 의미할 수 있다. SEEDriver는 APDU 메시지를 파싱하여, KeyStoreHAL에게 전송할 수 있다. KeyStoreHAL는 수신된 APDU 메시지를 KeyStore 상으로 전송할 수 있다. KeyStore는 수신된 인증서를 검증하고, 신뢰 체인이 검증됨에 기반하여 최초 PQC 전자서명 키 생성을 요청 한 어플리케이션의 고유 값인 AppId, 어플리케이션이 지정한 별칭(alias) 및 PQCKeyMaster가 생성한 값(예: PQC 전자서명 키 쌍)을 함께 저장할 수 있다. 이후 KeyStore는 어플리케이션 상으로 PQC 전자서명 키 생성 결과를 반환할 수 있다. 도 5는 일 실시예에 따른 전자 장치에서 KEM 키 쌍이 생성되는 과정을 설명하는 블록도이다. 도 5에 따르면 전자 장치(예: 도 2의 전자 장치)는 일반 환경(REE), 신뢰 환경(TEE) 및 보안 환경(SEE)을 포함할 수 있다. 도 5는 본 문서의 다양한 실시예들에 따른 전자 장치 상에서 PQC KEM 키 쌍이 생성되는 절차를 보여준다. PQC KEM 키 쌍 생성 절차와 도 4의 전자서명 키 쌍 생성 간의 가장 큰 차이점은 어플리케이션에 의해 요청 된 PQC 알고리즘 키 쌍의 생성 위치가 보안 환경(SEE)가 아닌 신뢰 환경(TEE)이라는 점이다. 전자 장치는 신뢰 환경(TEE)에서 PQC KEM 키 쌍을 생성하여 보안 환경(SEE) 대비 빠른 연산 속도를 제공할 수 있다. 어플리케이션은 PQC KEM 알고리즘을 활용하기 위해 KeyStore 상으로 KEM 키 쌍 생성을 요청할 수 있 다. 어플리케이션은 프레임워크의 KeyStore API를 옵션과 함께 요청할 수 있다. 옵션은 예를 들어, 보안 환경(SEE)의 활용을 선호하는 지 여부를 의미할 수 있다. 또는 옵션은 예를 들어, KeyUsage처럼 X.509 인 증서에 포함될 내용을 의미할 수 있다. 어플리케이션은 생성될 키의 별칭(alias)을 KeyStore 상으로 전달할 수 있다. 생성될 키의 별칭(Alias)은 어플리케이션이 특정 키를 지칭하기 위해 사용하는 임의의 값 을 의미한다. KeyStore는 어플리케이션으로부터 수신된 요청을 KeyStoreHAL에게 전달한다. KeyStoreHAL(51 6)은 수신된 요청을 KeyMaster에게 전달한다. KeyMaster는 신뢰 환경(TEE)에서 PQC KEM 키 쌍을 생성할 수 있다. KeyMaster는 생성한 PQC KEM 개 인키에 대해 신뢰 환경(TEE)에서 KEK를 유도하고, IV를 생성하여 암호화(wrapping)할 수 있다. KeyMaster는 SEEDriver 상으로 어플리케이션의 인증서의 서명을 요청할 수 있다. 인증서는 PQC 공개키를 포함할 수 있다. SEEDriver는 보안 환경(SEE)과 통신하기 위한 APDU 메시지를 생성하여 KeyMaster의 요청을 PQCKeyMaster에게 전달한다. PQCKeyMaster는 암호 라이브러리를 이용하여 보안 환경(SEE) 별로 고유하게 가진 PQC 전자서명 비밀 키로 서명을 생성하고, 인증서를 완성할 수 있다. PQCKeyMaster는 SEEDriver 상으로 APDU 메시지를 전송할 수 있다. APDU 메시지는 완성된 인증서 및 생성된 서명을 포함할 수 있다. SEEDriver는 수신한 APDU 메시지에 기반하여 인증서를 파싱하고, 파싱된 인증서를 KeyMaster에게 전송할 수 있다. KeyMaster는 보안 환경(SEE)에서 생성된 인증서와 암호화된(wrapped) KEM 개인키를 KeyStoreHAL에게 전송할 수 있다. KeyStoreHAL는 전달 받은 인증서 및 암호화된(wrapped) KEM 개인키를 KeyStore에게 전송할 수 있다. KeyStore는 전달받은 인증서를 보안 환경(SEE)의 공개키로 검증할 수 있다. KeyStore는 검증에 성공 하면 전달받은 인증서와 암호화된 개인키를 KeyStore의 데이터 베이스(예: 도 1의 메모리)에 저장할 수 있다. KeyStore는 PQC 키 쌍 생성을 요청한 앱의 식별자(AppId) 및 해당 앱이 부여한 별칭(alias)을 데이터 베이스 상에 저장할 수 있다. KeyStore는 키 생성 및 저장 결과를 어플리케이션 상으로 전송할 수 있다. 도 6은 일 실시예에 따른 전자 장치에서 보안 환경(SEE)에 기반하여 전자 서명을 수행하는 과정을 설명하는 블 록도이다. 도 6에 따르면 전자 장치(예: 도 2의 전자 장치)는 일반 환경(REE), 신뢰 환경(TEE) 및 보안 환경(SEE)을 포함할 수 있다. 어플리케이션은 PQC 전자서명을 이용하기 위해 생성해둔 PQC 전자서명 키 쌍의 별칭과 서명이 필요한 메시 지를 KeyStore 상으로 전송하여 서명을 요청할 수 있다. KeyStore는 PQC 전자서명에 대응하는 개인키가 보안 환경(SEE)에 저장되어 있음을 확인할 수 있다. KeyStore는 보안 메모리와 작동적으로 연결되어 통신을 수행하고, PQC 전자서명에 대응하는 개인키가 보안 환경(SEE)에 저장되어 있는지 확인할 수 있다. Keystore는 KeyID를 이용하여 PQC 전자서명에 대응하 는 개인키가 보안 환경(SEE)에 저장되어 있는지 확인할 수 있다. 또는 Keystore는 APDU(application protocol data unit)의 요청에 기반하여 PQC 전자서명에 대응하는 개인키가 보안 환경(SEE)에 저장되어 있는지 확인할 수 있다. KeyStore는 PQC 전자서명에 대응하는 개인키가 보안 환경(SEE)에 저장됨에 기반하여 개인키에 대응하는 KeyId와 서명이 필요한 메시지를 KeyStoreHAL 상으로 전송할 수 있다. KeyStoreHAL는 개인키에 대응하는 KeyId와 서명이 필요한 메시지를 수신하여 신뢰 환경 상의 SEEDriver에게 전송할 수 있다. SEEDriver는 개인키에 대응하는 KeyId와 서명이 필요한 메시지를 APDU 메시지로 변환하여, 보안 환경(SE E)의 PQCKeyMaster에게 전송할 수 있다. PQCKeyMaster는 보안 메모리 상에서 KeyID에 대응하는 PQC 전자서명 개인키를 읽을 수 있다. PQCKeyMaster는 보안 환경(SEE)의 암호 라이브러리를 이용하여 요청받은 메시지에 대한 서명을 생성 할 수 있다. PQCKeyMaster는 생성한 서명을 포함하는 APDU 메시지를 SEEDriver에게 전송할 수 있다. PQCKeyMaster는 서명을 위한 개인키를 암호화된(wrapped) 상태로 전달받아 서명 가능한 상태로 복구하는 것이 아니라 KeyID에 대응하는 PQC 전자서명 개인키를 읽어와서 별도의 키 복구 과정 없이 서명을 수행할 수 있다. 이 경우 보안 환경(SEE) 상에서 개인키를 복구하고 서명을 수행하는 과정과 비교하여 상대적으로 보안 프 로세서(예: 도 2의 보안 프로세서)의 자원 소모를 줄이고, 연산에 소요되는 시간을 감소시킬 수 있다. SEEDriver는 수신된 APDU 메시지를 KeyStoreHAL에게 전송할 수 있다. KeyStoreHAL는 수신된 APDU 메시지 및 생성된 서명을 KeyStore에게 전송할 수 있다. KeyStore는 전자서명을 요청한 어플리 케이션 상으로 수신된 서명을 전송할 수 있다. 일 실시예에 따르면, KeyStoreHAL과 SEEDriver는 수신한 데이터를 재전송하고, 접근 제어를 통해 전 자 장치의 보안을 강화할 수 있다. KeyStoreHAL 및 SEEDriver는 Pass-through 모듈로 지칭될 수 있다. KeyStoreHAL은 개별적인 장치들의 첫 부팅 시점에 SEEDriver 및 KeyMaster와 난수 기반의 보안 채널 을 생성할 수 있다. SEEDriver와 KeyMaster는 최초 KeyStoreHAL 및 보안 채널을 생성할 수 있다.SEEDriver와 KeyMaster는 일반 환경(REE)에 위치한 다른 모듈의 요청을 모두 보안 위반으로 처리할 수 있 다. SEEDriver와 KeyMaster는 일반 환경(REE)의 OS가 공장 초기화를 수행할 때까지 KeyStoreHAL의 요청 만을 수신하고 처리할 수 있다. 보안 환경(SEE)에 위치한 PQCKeymaster는 SEEDriver를 이용하여 제조 공정 시점에 보안 채널을 생성 할 수 있다. 신뢰 환경(TEE)에 위치한 SEEDriver는 보안 환경(SEE)의 PQCKeyMaster에게 접근할 수 있는 독점적 권한을 가질 수 있다. PQCKeyMaster는 제조사의 하드웨어 모듈 교체 시점까지 신뢰 환경(TEE) 상에 위치한 다른 모듈의 접근을 보안 위반으로 결정할 수 있다. KeyStoreHAL는 신뢰 환경(TEE)을 제공하는 다양한 제조사의 프로세서 내에서 동일한 동작을 수행할 수 있 다. SEEDriver는 특정 운영체제(예: 안드로이드(Android))에서 작동하는 표준 인터페이스를 지원할 수 있 다. APDU(Application Protocol Data Unit)는 스마트 카드와 스마트 카드 리더 간 데이터를 교환하는데 사용되 는 통신 프로토콜을 의미할 수 있다. 전자 장치는 스마트 카드와 그것을 읽어내는 장치 사이에서 정보를 주고받을 때, 정보를 패키지화해서 전송할 수 있다. 여기서 패키지는 APDU를 포함할 수 있다. APDU는 명령어 APDU와 응답 APDU 두 가지 유형을 포함할 수 있다. 명령어 APDU는 스마트 카드에게 어떤 작업을 수행하라고 지 시하는 메시지를 의미할 수 있다. 응답 APDU는 스마트 카드가 그 작업의 결과를 리더에게 보내주는 메시지를 의 미할 수 있다. APDU의 구조와 포맷은 ISO/IEC 7816-4라는 국제 표준에 따라 정의될 수 있다. 도 7은 일 실시예에 따른 전자 장치에서 보안 기능을 제공하는 방법을 순서도로 나타낸 것이다. 도 7을 통하여 설명되는 동작들은 컴퓨터 기록 매체 또는 메모리(예: 도 1의 메모리)에 저장될 수 있는 인 스트럭션들 을 기반으로 구현될 수 있다. 도시된 방법은 앞서 도 1 내지 도 6을 통해 설명한 전자 장치(예: 도 2의 전자 장치)에 의해 실행될 수 있으며, 앞서 설명한 바 있는 기술적 특징은 이하에서 생략 하기로 한다. 도 7의 각 동작의 순서가 변경될 수 있으며, 일부 동작이 생략될 수도 있고, 일부 동작들이 동시 에 수행될 수도 있다. 도 7의 동작 710에서, 메인 프로세서(예: 도 2의 메인 프로세서)는 어플리케이션(예: 도 6의 어플리케이션 )의 보안 기능 요청을 수신할 수 있다. 도 7의 동작 715에서, 메인 프로세서는 최적의 실행 환경(예: 신뢰 환경(TEE) 또는 보안 환경(SEE))으로 보안 기능 요청을 전달할 수 있다. 메인 프로세서는 일반 환경(REE) 상에서 어플리케이션의 보안 기능 요 청이 확인됨에 기반하여 상기 신뢰 환경(TEE) 또는 보안 환경(SEE)에 대응하는 모듈로 보안 기능 요청을 전달할 수 있다. 도 7의 동작 720에서, 메인 프로세서는 보안 기능 요청을 수신한 모듈(예: 신뢰 환경(TEE) 또는 보안 환경(SEE))을 이용하여 공개키와 개인키를 생성하고 개인키를 암호화할 수 있다. 메인 프로세서는 신 뢰 환경(TEE) 상에서 공개키와 개인키를 포함하는 키 페어(key pair)를 생성할 수 있다. 메인 프로세서는 생성된 개인키에 대해 키 암호 키(KEK, key-encryption-key) 및 초기화 벡터(IV, initialization vector)를 이 용하여 암호화(wrapping)할 수 있다. 도 7의 동작 730에서, 메인 프로세서는 보안 환경(SEE)에서 공개 키가 포함된 인증서를 생성할 수 있다. 메인 프로세서는 보안 환경(SEE)에서 작동하는 보안 프로세서(예: 도 2의 보안 프로세서) 상으로 인 증서의 생성을 요청할 수 있다. 보안 프로세서는 서명을 수행하고, 결과를 메인 프로세서 상으로 전 송할 수 있다. 도 7의 동작 735에서, 메인 프로세서는 어플리케이션의 요청에 기반하여 보안 환경(SEE)에서 개인 키를 저 장할 수 있다. 도 7의 동작 740에서, 메인 프로세서는 일반 환경(REE)에서 보안 환경(SEE)의 공개키를 이용하여 검증을 수행할 수 있다. 메인 프로세서는 보안 프로세서로부터 서명이 수신됨에 기반하여 수신된 서명 및 인 증서에 대해 일반 환경(REE) 상에서 검증을 수행할 수 있다. 메인 프로세서는 보안 환경(SEE)의 공개키를 이용하여 검증을 수행할 수 있다. 메인 프로세서는 일반 환경(REE) 상에서 검증을 수행하여 보안 환경(SEE)에서 검증을 수행하는 것과 비교하여 상대적으로 연산 속도를 상승시키고, 검증에 소요되는 시간을 감소시킬 수 있다. 메인 프로세서는 보안 환경(SEE)의 공개키를 이용하여 검증을 수행하고, 보안 환경(SEE)에서 서명이 이뤄 지도록 제어할 수 있다. 메인 프로세서는 일반 환경(REE) 또는 신뢰 환경(TEE)에서 서명을 수행하는 것과비교하여 상대적으로 보안 수준을 높게 유지할 수 있다. 도 7의 동작 750에서, 메인 프로세서는 암호화된 개인키 및 식별정보를 보안 환경(SEE)에 저장하고, 보안 기능 수행 결과를 전송할 수 있다. 메인 프로세서는 보안 기능이 수행됨 기반하여 인증서, 암호화된 개인 키 및 검증을 요청한 어플리케이션의 식별정보(ID)를 메모리 상에 저장할 수 있다. 메인 프로세서 는 보안 기능 수행 결과를 어플리케이션으로 전송할 수 있다. 일 실시예에 따르면, 메인 프로세서는 일반 실행 환경(REE) 상에서 어플리케이션으로부터 암호화된 개인키에 대한 정보 및 서명이 필요한 메시지를 수신함에 기반하여 대응하는 개인키가 보안 환경(SEE) 상의 보 안 메모리 에 저장되어 있는지 확인할 수 있다. 메인 프로세서는 대응하는 개인키가 보안 메모리에 저장되어 있음에 기반하여 개인키에 대한 정보 및 서명이 필요한 메시지를 신뢰 실행 환경(TEE)으로 전송할 수 있다. 메인 프로세서는 신뢰 실행 환경을 이 용하여 개인키에 대한 정보 및 서명이 필요한 메시지를 보안 프로세서 상으로 전송할 수 있다. 보안 프로세서는 수신된 개인키에 대한 정보에 기반하여 보안 메모리에 저장된 개인키를 확인하고, 확인된 개인키를 이용하여 서명이 필요한 메시지에 대한 서명을 생성할 수 있다. 본 문서의 다양한 실시예들에 따른 전자 장치는 PQC 알고리즘의 수행에 환경을 보안 수준이 상대적으로 높은 보안 환경(SEE)이나, 상대적으로 연산 속도가 빠른 신뢰 환경(TEE)으로 고정하지 않고, 복수의 환경들을 상황 별로 모두 이용할 수 있다. 전자 장치는 PQC 알고리즘의 특성을 고려하여, KEM 알고리즘은 상대적으 로 연산 속도가 빠른 신뢰 환경(TEE)에서 수행할 수 있다. 반면, 전자 장치는 공개키가 포함된 인증서의 최종 서명은 보안 수준이 상대적으로 높은 보안 환경(SEE)에서 수행할 수 있다. 전자 장치는 인증서의 최 종 서명은 보안 수준이 상대적으로 높은 보안 환경(SEE)에서 수행하여 인증서의 검증 및 보안 수준을 보안 환경 (SEE) 수준으로 유지할 수 있다. 본 문서의 다양한 실시예들에 따른 전자 장치는 암호화된(Wrapped) PQC 전자서명 개인키의 전송, 암호화된 PQC 개인키를 복호화할 수 있는 KEK의 유도 또는 PQC 전자서명 개인키의 복호화(Unwrapping) 중 적어도 어느 하 나의 동작을 생략하여 암호화 및 연산에 소요되는 시간을 감소시킬 수 있다. 도 8은 일 실시예에 따른 전자 장치의 동작 방법을 순서도로 나타낸 것이다. 도 8을 통하여 설명되는 동작들은 컴퓨터 기록 매체 또는 메모리(예: 도 1의 메모리)에 저장될 수 있는 인 스트럭션들 을 기반으로 구현될 수 있다. 도시된 방법은 앞서 도 1 내지 도 6을 통해 설명한 전자 장치(예: 도 2의 전자 장치)에 의해 실행될 수 있으며, 앞서 설명한 바 있는 기술적 특징은 이하에서 생략 하기로 한다. 도 8의 각 동작의 순서가 변경될 수 있으며, 일부 동작이 생략될 수도 있고, 일부 동작들이 동시 에 수행될 수도 있다. 동작 810에서, 메인 프로세서(예: 도 2의 메인 프로세서)는 전자 서명(sig) 및 키 캡슐화(key encapsulation, mechanism, KEM) 동작을 수행함에 있어서, 신뢰 환경(TEE) 또는 보안 환경(SEE) 중 어느 하나 에서 동작이 실행되었을 때 연산 속도를 확인할 수 있다. 일 실시예에 따르면, 전자 서명(sig) 동작은 키(key) 생성, 서명 생성 및 서명 검증의 단계를 포함할 수 있다. 서명을 검증하기 위한 키(key)는 최초에 보안 환경(SEE)에서 생성될 수 있다. 또한, 서명 생성 과정 역시 보안 환경(SEE)에서 실행될 수 있다. 메인 프로세서는 서명 검증 과정을 신뢰 환경(TEE)에서 실행했을 때 연산 속도를 계산할 수 있다. 또한, 메인 프로세서는 서명 검증 과정을 보안 환경(SEE)에서 실행했을 때 연산 속도를 계산할 수 있다. 일 실시예에 따르면, 키 캡슐화(KEM) 동작은 KEM 키 쌍 생성, 캡슐화 및 캡슐화 해제 단계를 포함할 수 있다. KEM 키 쌍은 개인키와 공개키를 포함할 수 있다. 동작 820에서, 메인 프로세서는 확인된 연산 속도에 기반하여 전자 서명(sig) 및 키 캡슐화(key encapsulation, mechanism, KEM) 동작이 수행되는 실행 환경을 다르게 결정할 수 있다. 메인 프로세서는 서명 검증 과정을 보안 환경(SEE)에서 실행했을 때 연산 속도가 지정된 수준을 초과하는 경우 서비스 속도에 문제가 없을 것으로 결정하고, 보안 환경(SEE)에서 서명 검증 과정을 실행할 수 있다. 반면, 메인 프로세서는 서명 검증 과정을 보안 환경(SEE)에서 실행했을 때 연산 속도가 지정된 수준 미만인 경우 연산 속도가 상대적으로 느려서 서비스 제공에 문제가 있을 것으로 결정할 수 있다. 이 경우 메인 프로 세서는 보안 환경(SEE) 대신 상대적으로 연산 속도가 빠른 신뢰 환경(TEE)에서 서명 검증 과정을 실행시킬 수 있다. 일 실시예에 따르면, 메인 프로세서는 개인 키 생성은 신뢰 환경(TEE)에서 실행하고, 공개 키 생성은 보안 환경(SEE)에서 실행할 수 있다. 공개 키는 발급자의 서명이 포함되기 때문에 상대적으로 생성 과정에서 보안이 더 필요할 수 있다. 메인 프로세서는 보안이 상대적으로 중요한 공개 키 생성 과정은 보안 환경(SEE)에서 실행시킬 수 있다. 메인 프로세서는 개인 키 생성, 캡슐화 및 캡슐화 해제 단계에 대해서는 연산 속도에 기반하여 보안 환경(SEE)에서 실행할 수도 있고, 신뢰 환경(TEE)에서 실행할 수도 있다. 메인 프로세서는 개인 키 생성, 캡슐화 및 캡슐화 해제 단계를 보안 환경(SEE)에서 실행했을 때 연산 속도 가 지정된 수준을 초과하는 경우 서비스 속도에 문제가 없을 것으로 결정하고, 보안 환경(SEE)에서 개인 키 생 성, 캡슐화 및 캡슐화 해제 단계를 실행할 수 있다. 반면, 메인 프로세서는 개인 키 생성, 캡슐화 및 캡슐 화 해제 단계를 보안 환경(SEE)에서 실행했을 때 연산 속도가 지정된 수준 미만인 경우 연산 속도가 상대적으로 느려서 서비스 제공에 문제가 있을 것으로 결정할 수 있다. 이 경우 메인 프로세서는 보안 환경(SEE) 대신 상대적으로 연산 속도가 빠른 신뢰 환경(TEE)에서 개인 키 생성, 캡슐화 및 캡슐화 해제 단계를 실행시킬 수 있 다.도면 도면1 도면2 도면3a 도면3b 도면3c 도면4 도면5 도면6 도면7 도면8"}
{"patent_id": "10-2023-0167547", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 다양한 실시예들에 따른, 네트워크 환경 내의 전자 장치의 블록도이다. 도 2는 일 실시예에 따른 전자 장치의 보안 직접 회로를 나타내는 블럭도이다. 도 3a는 일 실시예에 따른 전자 장치의 실행 환경에 따른 구성 요소를 블록도로 도시한 것이다. 도 3b는 전자 장치 내 복수의 키들의 저장 위치를 블록도로 나타낸 것이다. 도 3c는 일 실시예에 따른 신뢰 체인의 모습을 도시한 것이다. 도 4는 일 실시예에 따른 전자 장치에서 전자 서명을 위한 키 쌍이 생성되는 과정을 설명하는 블록도이다. 도 5는 일 실시예에 따른 전자 장치에서 KEM 키 쌍이 생성되는 과정을 설명하는 블록도이다. 도 6은 일 실시예에 따른 전자 장치에서 보안 환경(SEE)에 기반하여 전자 서명을 수행하는 과정을 설명하는 블 록도이다. 도 7은 일 실시예에 따른 전자 장치에서 보안 기능을 제공하는 방법을 순서도로 나타낸 것이다. 도 8 은 일 실시예에 따른 전자 장치의 동작 방법을 순서도로 나타낸 것이다."}
