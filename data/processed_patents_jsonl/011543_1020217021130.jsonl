{"patent_id": "10-2021-7021130", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0110604", "출원번호": "10-2021-7021130", "발명의 명칭": "자연 솔루션 언어", "출원인": "브레인 코그니티브스 피티이. 엘티디.", "발명자": "바이라주, 라마링가 라주"}}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "사용자가 이해하는 자연어를 사용하고 프로그래밍 코드를 사용하지 않고 컴퓨터 구현 솔루션을 구축하는 방법에있어서, 상기 방법은:컴퓨팅 장치의 프로세서에 의해 사용자로부터 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 수신하는 단계- 상기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설정됨 - ;상기 프로세서에 의해 상기 사용자로부터 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 수신하는 단계 - 각각의 로컬 의도 진술 및 상기 개체와 에이전트의 상기 세부 정보는 상기 자연어의 형태로 수신되고 각각 잠재성의 상태로 설정되며, 각 로컬 의도진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 나타내는 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 상기 프로세서에 의해, 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 하는 조합 개체 상태 (CES)의 세트를 형성하는 단계 - 상기 각각의 로컬 의도 진술의 상기 개체모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에있음 -;상기 글로벌 의도 진술과 관련된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로서 식별하는 단계; 및상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 프로세서에의해 상기 사용자로부터 상기 자연어 형태로 상기 로컬 의도 진술 간의 관계를 수신하는 단계 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지 여부를 나타냄 - 을 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서, 각 로컬 의도 진술에 대해, 상기 프로세서에 의해 상기 사용자로부터 상기 자연어의 형태로,상기 각 로컬 의도 진술의 특성을 정의하는 하나 이상의 속성을 수신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서, 각 개체에 대해, 상기 프로세서에 의해 상기 사용자로부터 상기 자연어 형태로, 상기 각 개체의 특성을 정의하고 상기 해당 로컬 의도 진술의 다른 개체와 상기 각 개체를 차별화하는 하나 이상의 속성을수신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서, 상기 관계를 수신하는 단계는 상기 글로벌 의도 진술에 대한 상기 로컬 의도 진술 사이의 복수의 별개의 관계를 수신하는 단계를 포함하고,각 별개의 관계는 상기 솔루션을 구축하는 별개의 경로인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1 항에 있어서, 각 로컬 의도 진술의 각 개체에 대해: 공개특허 10-2021-0110604-3-상기 프로세서에 의해 상기 관련 에이전트로부터 상기 자연어의 형태로 상기 각 개체에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 개체에 대한 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각 개체에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건의 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 2 항에 있어서, 각 로컬 의도 진술의 각 속성에 대해:상기 프로세서에 의해 상기 관련 에이전트로부터 상기 자연어의 형태로 상기 각 속성에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 속성에 대한 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각 속성에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건의 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 3 항에 있어서, 각 개체의 속성에 대해:상기 프로세서에 의해 상기 관련 에이전트로부터 상기 자연어의 형태로 상기 각 속성에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 속성에 대한 상기 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각각의속성에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건의 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 5 항, 제 6 항, 또는 제 7 항에 있어서, 상기 프로세서에 의해, 로그인 세부 정보, 생체 측정 세부 정보, 얼굴 인식 기술 및 망막 감지 기술 중 하나를 기반으로 상기 관련 에이전트를 인증하는단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 5 항에 있어서, 상기 각 로컬 의도 진술과 관련된 모든 개체에 대해 상기 값을 수신하는 단계는, 상기 각 로컬 의도 진술에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건의 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 9 항에 있어서, 상기 모든 로컬 의도 진술과 관련된 모든 개체에 대해 상기 값을 수신하는 단계는, 상기 글로벌 의도 진술에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 1 항에 있어서, 상기 기계 에이전트는 유선 통신 채널 또는 무선 통신 채널을 통해 상기 컴퓨팅 장치에 통신가능하게 결합되는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 1 항에 있어서, 상기 기계 에이전트는 상기 컴퓨팅 장치의 기능적 모듈이며 상기 프로세서에 연결되는,방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 1 항에 있어서, 상기 글로벌 의도 진술과 관련된 로컬 의도 진술은:다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 로컬 의도 진술; 또는다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 글로벌 의도 진술인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "공개특허 10-2021-0110604-4-제 1 항에 있어서, 상기 글로벌 의도 진술의 로컬 의도 진솔과 관련된 개체는:다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 로컬 의도 진술; 또는다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 개체인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 2 항에 있어서, 상기 각각의 로컬 의도 진술의 특성을 정의하는 속성은:다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 개체; 또는다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 속성인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 3 항에 있어서, 상기 각각의 개체의 특성을 정의하는 속성은:다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 개체; 또는다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 속성인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제 1 항에 있어서, 상기 솔루션은:로컬 의도 진술을 둘 이상의 다른 로컬 의도 진술로 나누고 상기 해당 개체 및 에이전트를 각 로컬 의도 진술에첨부하거나; 두 개 이상의 로컬 의도 진술을 하나의 로컬 의도 진술로 결합하고 상기 해당 개체 및 에이전트를 해당 로컬 의도 진술에 첨부하여 구축되는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제 1 항에 있어서, 상기 솔루션이 자연어를 사용하여 구축되므로 하나 이상의 검색 엔진에 의해 상기 솔루션은검색 가능한, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 1 항에 있어서, 각 개체에 대한 하나 이상의 정보 권한 또는 결정 권한을 상기 각 개체의 상기 로컬 의도 진술과 관련된 상기에이전트에 할당하는 단계; 및 상기 할당된 정보 권한 또는 결정 권한에 기초하여 상기 에이전트에게 개체를 표시하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제 3 항에 있어서, 속성의 개수가 적을수록 상기 각각의 개체는 더욱 일반화되고, 속성 개수가 많을수록 개체간의 차별화는 더욱 커지는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제 1 항에 있어서, 상기 사용자 인터페이스를 통해 개체를 표시하여 상기 연관된 에이전트가 상기 개체에 대한값을 수신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제 4 항에 있어서, 상기 개체에 대한 값을 수신하도록 상기 로컬 의도 진술 사이에 하나 이상의 별개의 관계를공개특허 10-2021-0110604-5-제공하는 단계를 더 포함하고, 상기 하나 이상의 별개의 관계를 제공하는 단계는 조직화된 프로세스, 자동화된 프로세스 또는인간 에이전트 주도 프로세스에 기반하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제 1 항에 있어서, 로컬 의도 진술의 하나 이상의 개체 또는 하나 이상의 CES가 다른 컴퓨터 구현 솔루션의 하나 이상의 로컬 의도 진술과 공유되고,상기 공유 개체 또는 CES는 임의의 시점에서 하나의 트리거 CES에만 참여하여 상기 하나의 트리거 CES에 대응하는 상기 로컬 의도 진술에 대해 상기 잠재적 상태를 상기 현실 상태로 변경하고, 상기 공유된 개체 또는 CES의이용 가능성은 다중 로컬 의도 진술에 대해 상기 잠재적 상태에서 상기 현실 상태로의 변경 순서에 영향을주는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제 1 항에 있어서, 상기 개체는 본질적으로 물리적이며, 상기 개체는 공간과 시간에 존재하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제 1 항에 있어서, 상기 로컬 의도 진술을 수신하고 상기 개체의 세부 정보를 수신하는 단계는, 다른 컴퓨터 구현 솔루션의 로컬 의도 진술 및 개체를 저장하는 데이터베이스의 라이브러리에서 하나 이상의 가능한 로컬 의도진술 및 하나 이상의 가능한 개체를 제공하는 단계를 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "제 1 항에 있어서, 상기 프로세서에 의해 상기 고유한 관계 중 하나를 선택하여 상기 개체에 대한 상기 값을 수신하고 다른 고유한 관계를 제거하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "제 1 항에 있어서, 상기 자연어는 하나 이상의 모국어, 하나 이상의 수화, 하나 이상의 기호, 하나 이상의 숫자또는 이들의 조합을 기반으로 하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "제 1 항에 있어서, 상기 자연어 형태의 정보는 필기 기반 인터페이스, 터치 감지 인터페이스, 음성 기반 인터페이스, 이미지 기반 인터페이스 또는 비디오 기반 인터페이스 또는 이들의 조합을 통해 수신되고,상기 자연어 형태로 수신된 정보는 물체 인식 기술, 문자 인식 기술, 이미지 인식 기술 또는 이들의 조합을 이용하여 해독되는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "제 5 항 또는 제 6 항 또는 제 7 항에 있어서, 상기 프로세서에 의해 기록될 남은 사건의 수를 결정하는 단계;및상기 프로세서에 의해 상기 남은 사건의 수를 표시하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "제 1 항에 있어서, 사용자 인터페이스에서의 각 개체 및 각 로컬 의도 진술의 위치는:드래그 앤 드롭 기능 - 상기 드래그 앤 드롭 기능은 유선 입력 장치, 무선 입력 장치 및 터치 감지 인터페이스중 적어도 하나에 의해 실행됨 - ; 또는 각 개체의 위치 좌표 또는 각 로컬 의도 진술에 해당하는 속성의 값을 변경함으로써변경 가능한, 방법.공개특허 10-2021-0110604-6-청구항 31 제 1 항에 있어서, 퍼블릭 블록 체인 기술, 프라이빗 블록 체인 기술, 하이브리드 블록 체인 기술 중 하나를 적용하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제 31 항에 있어서, 상기 퍼블릭 블록 체인 기술, 상기 프라이빗 블록 체인 기술 및 상기 하이브리드 블록 체인기술의 각각은 대칭 키 암호화 기술, 비대칭 키 암호화 기술 또는 이들의 조합을 기반으로 하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "제 1 항에 있어서, 하나 이상의 사전 정의된 규범을 기반으로 하는 측정 프레임워크를 상기 개체에 할당하는 단계를 더 포함하고, 상기 측정 프레임워크는 개체가 상기 잠재적 상태에서 현실 상태로 변경되는 기간을 표시하는,방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제 1 항에 있어서, 상기 프로세서가 상기 사용자로부터 각 로컬 의도 진술과 관련된 정보 개체의 세부 정보를수신하는 단계를 더 포함하고, 각 정보 개체의 세부 정보는 상기 자연어의 형태로 수신되고 잠재성 상태로 설정되며, 각각의정보 개체는 상기 트리거 CES를 형성하는 상기 개체와 상이한, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "제 1 항에 있어서, 데이터베이스의 라이브러리 형태로, 다른 컴퓨터 구현 솔루션을 구축하는 데 사용할 상기 글로벌 의도 진술, 상기 로컬 의도 진술, 상기 개체 및 상기 에이전트 중 하나 이상과 관련된 데이터를 저장하는단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "제 35 항에 있어서, 상기 데이터베이스에 상기 라이브러리에 대한 질의 기반 액세스를 제공하는 단계를 더 포함하고,상기 질의 기반 액세스는 재사용을 위해 적절한 개체를 식별하기 위한 검색 및 질의 기반 기술에 의존하고, 상기 질의 기반 액세스는 구조적 질의 언어(SQL) 및 낫 온리 구조적 질의 언어(NoSQL) 중 적어도 하나를포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "제 35 항에 있어서, 상기 데이터베이스의 상기 라이브러리에 대해 드래그 앤 드롭 액세스를 제공하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "제 5 항, 제 6 항, 또는 제 7 항에 있어서, 상기 CES 중 하나 이상의 과거 행동 및 상기 사건 중 하나 이상의발생에 기초하여 상기 개체 중 하나 이상 및 상기 사건 중 하나 이상에 대응하는 하나 이상의 불확실성 및 확률을 제공하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_39", "content": "제 1 항에 있어서, 상기 컴퓨터 구현 솔루션에 대한 각 로컬의 의도 진술에 회계 및 재무 시스템과 관련된 하나공개특허 10-2021-0110604-7-이상의 개체를 첨부하여 회계 및 재무 시스템을 통합하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "제 38 항에 있어서, 상기 개체 중 하나 이상 및 상기 사건 중 하나 이상에 대응하는 하나 이상의 불확실성 및확률을 제공하고 상기 사건의 기록을 위한 상기 값의 수신을 최적화하기 위해 하나 이상의 고급 계획 및 최적화(APO) 기능을 수행하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "제 38 항에 있어서, 기계 학습 기술 및 인공 지능 기술;하나 이상의 사건의 발생을 제공하는 개체 중심 접근법; 및각 사건의 데이터 및 행동 패턴의 저장중 하나 이상을 기반으로 상기 CES의 하나 이상의 과거 행동 및 상기 사건의 하나 이상의 발생을 평가하는 단계를 더 포함하고,상기 기계 학습 기술은 지도 학습 기술 및/또는 비지도 학습 기술 및/또는 준지도 학습 기술을 포함하고, 상기지도 학습 기술은 지원 벡터 기계, 선형 회귀, 로지스틱 회귀, 나이브 베이즈(naive Bayes), 선형 판별 분석,결정 트리, k-최근 접 이웃 알고리즘 및 신경망 중 적어도 하나를 포함하고, 상기 비지도 학습 기술은 계층적클러스터링, K-평균 클러스터링, K-NN (k 개의 최근접 이웃) 및 연관 규칙 중 적어도 하나를 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "제 1 항에 있어서, 대화형 설문에 대한 응답으로 상기 글로벌 의도 진술 중 하나 이상, 각 로컬의 의도 진술 및상기 개체의 상기 세부 정보를 수신하는 단계를 더 포함하고, 상기 대화형 설문은 상기 컴퓨터 구현 솔루션을 구축하기 위한 구조화된 형식의 질문을 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_43", "content": "제 1 항에 있어서, 자연어 문법에 기반하여 상기 수신된 글로벌 의도 진술 중 하나 이상, 각 로컬 의도 진술 및상기 개체의 세부 정보를 수정하는 단계를 더 포함하며, 상기 자연어 문법은 자연어 라이브러리를 사용하여 상기 수정을 위한 하나 이상의 적절한 동사와 전치사를 선택하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_44", "content": "제 29 항에 있어서,상기 프로세서에 의해, 상기 남은 사건의 수에 필요한 시간 및 리소스의 양을 결정하는 단계; 및상기 프로세서에 의해, 상기 필요한 시간 및 리소스의 양을 표시하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_45", "content": "제 5 항 또는 제 6 항 또는 제 7 항에 있어서,상기 프로세서에 의해, 상기 잠재성 상태에서 상기 현실 상태로의 변경 시 기록된 두 개의 연속적 사건 사이의최적 유휴 시간을 데이터베이스에 저장하는 단계;상기 프로세서에 의해, 상기 잠재적 상태가 상기 현실 상태로 변경될 때 기록된 각각의 두 연속적 사건 사이의공개특허 10-2021-0110604-8-유휴 시간을 실시간으로 결정하는 단계; 및상기 프로세서에 의해, 상기 결정된 유휴 시간과 상기 최적의 유휴 시간을 비교하여 보고를 준비하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_46", "content": "제 5 항 또는 제 6 항 또는 제 7 항에 있어서,상기 프로세서에 의해, 상기 수신된 값을 데이터베이스에 저장된 최적 값과 비교하는 단계; 및상기 프로세서에 의해, 상기 수신된 값이 컴퓨터 구현 솔루션을 구축하기 위해 좋은지, 나쁜지 또는 양가적인지상기 비교를 기반으로 결정하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_47", "content": "제 1 항에 있어서, 각 로컬 의도 진술, 각 개체 및 각 에이전트에 고유 식별자 (ID)를 할당하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_48", "content": "제 1 항에 있어서, 상기 사용자가 자원 유휴 시간을 최적화하기 위해 사용 가능한 모든 개체의 최적 사용을 정의할 수 있도록 하는단계; 및각 개체와 관련된 시간 및 공간의 속성 모니터링을 통해 가치 창출 활동에 대한 개체 참여를 실시간으로 추적하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_49", "content": "제 1 항에 있어서,하나 이상의 결과적 가능성 및 하나 이상의 기회 또는 하나 이상의 위험에 대한 하나 이상의 가치 판단을 제공하고 상기 하나 이상의 결과적 가능성에 대한 하나 이상의 확률을 상기 에이전트에 할당하는 단계; 또는상기 하나 이상의 개체를 변경함으로써 하나 이상의 경로에 개입하고 변경하기 위해 하나 이상의 동작을 수행하고, 상기 동작은 연관된 에이전트에 의해 원하는 하나 이상의 자원 최적화 원칙을 구동하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_50", "content": "제 4 항에 있어서, 상기 하나 이상의 별개의 경로를 고르고 선택할 수 있는 하나 이상의 가능한 경로를 제공하는 단계를 더 포함하고, 상기 하나 이상의 가능한 경로는 데이터베이스의 라이브러리에서 검색된 상기 컴퓨터 구현 솔루션과 유사한 솔루션인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_51", "content": "제 50 항에 있어서,상기 데이터베이스의 상기 라이브러리에서 하나 이상의 감독 및/또는 하나 이상의 비감독 기계 학습 방법을 구현하는 단계를 더 포함하고,상기 하나 이상의 감독 및/또는 하나 이상의 비감독 기계 학습 방법의 구현은 상기 솔루션 콘텐츠를 처리하기위공개특허 10-2021-0110604-9-한 NLP 구성 요소, ANN 구성 요소 및 최근접 이웃 구성 요소를 포함하는 DLD 엔진에 의해 이루어지며, 상기 DLD엔진은 상기 라이브러리의 일부인 풍부한 솔루션 콘텐츠를 마이닝하고 상기 트랜잭션 클래스에서 트랜잭션 데이터를 추출하고, 상기 NSL 솔루션 라이브러리의 일부인 상기 풍부한 솔루션 콘텐츠와 상기 트랜잭션 클래스에서추출된 상기 트랜잭션 데이터는 다양한 레벨에서 거리를 계산할 수 있는 상기 DLD 엔진으로 공급되고, 상기 거리 계산은 기계 학습 알고리즘을 사용하는 NSL 개체 값, 시간 및 공간을 사용하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_52", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하는 방법에있어서, 상기 방법은,컴퓨팅 장치의 프로세서에 의해, 사용자에게 자연어의 형태로 글로벌 의도 진술을 입력하라는 프롬프트를 제공하고 상기 솔루션 구축을 위해 상기 글로벌 의도 진술을 잠재성 상태로 설정하는 단계;상기 프로세서에 의해, 상기 사용자에게 자연어의 형태로 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 상기 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 입력하라는 프롬프트를 제공하고 상기하나 이상의 로컬 의도 진술 및 상기 개체 각각을 잠재성의 상태로 설정하는 단계 - 각각의 로컬 의도 진술은상기 솔루션을 구축하는 단계를 나타내며, 각 개체는 상기 해당 로컬 의도 진술에 표시된 상기 단계에참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 상기 프로세서에 의해, 상기 각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 모든 가능한 조합에 기초하여 조합 개체 상태 (CES)의 세트를 형성하는 단계 - 상기 각각의 로컬 의도 진술의 상기 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음- ;상기 글로벌 의도 진술과 관련된 수신된 로컬 의도 진술을 단 하나만 결정한 것에 응답하여, 상기 프로세서에의해, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션의 구축의 종료로서 식별하는 단계; 및상기 글로벌 의도 진술과 관련된 하나 이상의 수신된 로컬 의도 진술을 결정한 것에 응답하여, 상기 프로세서에의해, 상기 사용자에게 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 입력하라는 프롬프트를 제공하는 단계 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - 를 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_53", "content": "제 52 항에 있어서, 각 로컬의 의도 진술에 대해, 상기 프로세서에 의해, 상기 사용자에게 상기 각각의 로컬 의도 진술의 특성을 정의하는 하나 이상의 속성을 자연어의 형태로 입력하라는 프롬프트를 제공하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_54", "content": "제 52 항에 있어서, 각 개체에 대해, 상기 프로세서에 의해 상기 사용자에게 상기 각 개체의 특성을 정의하고상기 각 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하는 하나 이상의 속성을 자연어의 형태로 입력하라는 프롬프트를 제공하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_55", "content": "제 52 항에 있어서, 상기 관계에 대한 상기 프롬프트를 제공하는 단계는, 상기 사용자에게 상기 글로벌 의도 진술에 대한 상기 로컬 의도 진술 사이에 복수의 별개의 관계를 입력하는 프롬프트를 제공하는 단계를 포함하고,각각의 별개의 관계는 상기 솔루션을 구축하는 별개의 경로인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_56", "content": "제 52 항에 있어서, 각 로컬 의도 진술의 각 개체에 대해: 공개특허 10-2021-0110604-10-상기 프로세서에 의해, 상기 관련 에이전트에게 상기 각 개체에 대한 값을 상기 자연어의 형태로 입력하라는 프롬프트를 제공하는 단계를 더 포함하고, 상기 각각의 개체에 대한 상기 값을 수신하는 단계는 상기 수신된 값에기초하여 상기 각 개체에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건의 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_57", "content": "제 53 항에 있어서, 각 로컬 의도 진술의 각 속성에 대해: 상기 프로세서에 의해, 상기 관련 에이전트에게 상기 각 속성에 대한 값을 상기 자연어의 형태로 입력하라는 프롬프트를 제공하는 단계를 더 포함하고, 상기 각 속성에 대한 값을 수신하는 단계는 상기 수신된 값에 기초하여상기 각각의 속성에 대해 상기 잠재성 상태를 현실의 상태로 변경하는 사건의 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_58", "content": "제 54 항에 있어서, 각 개체의 속성에 대해: 상기 프로세서에 의해, 상기 관련 에이전트에게 상기 각 속성에 대한 값을 상기 자연어의 형태로 입력하라는 프롬프트를 제공하는 단계를 더 포함하고, 상기 각 속성에 대한 값을 수신하는 단계는 수신된 값에 기초하여 상기각각의 속성에 대해 상기 잠재성의 상태를 현실의 상태로 변경하는 사건의 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_59", "content": "제 56 항, 57 항, 또는 58 항에 있어서, 상기 프로세서에 의해, 로그인 세부 정보, 생체 측정 세부 정보, 얼굴인식 기술 및 망막 감지 기술 중 하나를 기반으로 상기 관련 에이전트를 인증하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_60", "content": "제 56 항에 있어서, 각 로컬 의도 진술과 관련된 상기 개체 각각에 대해 상기 사건을 기록할 때, 상기 프로세서에 의해 상기 각 로컬 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 사건을 기록하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_61", "content": "제 60 항에 있어서, 각 로컬 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 상기 사건을 기록할 때, 상기 프로세서에 의해, 상기 글로벌 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는사건을 기록하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_62", "content": "제 52 항에 있어서, 상기 자연어는 하나 이상의 모국어, 하나 이상의 수화, 하나 이상의 기호, 하나 이상의 숫자 또는 이들의 조합을 기반으로 하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_63", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해할 수 있는 비디오와 자연어를 사용하여 컴퓨터 구현 솔루션을구축하는 방법에 있어서, 상기 방법은:컴퓨팅 장치의 프로세서에 의해, 상기 비디오의 이미지 프레임을 처리하여 복수의 차별화된 이미지 프레임을 식별하는 단계 - 각각의 차별화된 이미지 프레임은 그 콘텐츠의 차이에 기초하여 비디오의 하나 이상의 이전 이미지 프레임과 다른 것으로 식별됨 - ;상기 프로세서에 의해, 상기 비디오의 직전 이미지 프레임의 콘텐츠에 대해 각 차별화된 이미지 프레임의 콘텐츠의 차이에 각각 근거하는 복수의 로컬 의도 진술을 결정하고 상기 로컬 의도 진술을 잠재성 상태로 설정하는단계 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어데이터와 관련하여 이미지 프레임의 상기 콘텐츠를 분석함으로써 결정됨 - ;상기 프로세서에 의해, 상기 데이터베이스에 저장된 자연어 데이터와 관련하여 연속된 한 쌍의 차별화된 이미지프레임 사이의 이미지 프레임의 내용을 분석하여 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체각각과 연관된 속성을 결정하고, 상기 개체와 속성 각각을 잠재성의 상태로 설정하는 단계 - 각 개체는 상기 해당 로컬의 의도 진술에 표시된 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기공개특허 10-2021-0110604-11-각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ;상기 프로세서에 의해, 제 1 차별화된 이미지 프레임과 마지막으로 차별화된 이미지 프레임의 상기 콘텐츠의 변경을 기반으로 상기 컴퓨터 구현 솔루션에 대한 글로벌 의도 진술을 결정하고 상기 글로벌 의도 진술을 잠재성상태로 설정하는 단계 - 상기 글로벌 의도 진술은 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여상기 제 1 차별화 이미지 프레임 및 상기 마지막 차별화 이미지 프레임의 상기 콘텐츠를 분석함으로써 결정됨 -;상기 프로세서에 의해, 각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 가능한 모든 조합에기초하여 조합 개체 상태 (CES)의 세트를 형성하는 단계 - 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ;상기 프로세서에 의해, 사용자로부터 자연어의 형태로 상기 복수의 로컬 의도 진술 각각과 연관된 에이전트의세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하는 단계 - 상기 에이전트는 적어도 인간 에이전트 및 기계 에이전트 중 하나임 - ; 및상기 프로세서에 의해, 상기 사용자로부터 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 수신하는 단계 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 진술의 상기 CES 세트에 영향을 미치는지또는 상기 컴퓨터 구현 솔루션을 구축하는 단계의 종료인지를 나타냄 - 를 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_64", "content": "제 63 항에 있어서, 상기 이미지 프레임을 처리하는 단계는 상기 이미지 프레임의 콘텐츠 및 상기 이미지 프레임에 걸친 상기 콘텐츠의 변경에 기초하여 정보를 추출하는 단계를 포함하고, 상기 정보를 추출하는 단계는 객체 인식 기술, 문자 인식 기술, 음성 인식 기술 또는 이들의 조합에 기반하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_65", "content": "제 63 항에 있어서, 상기 글로벌 의도 진술 및 상기 복수의 로컬 의도 진술 각각을 결정하는 단계는 하나 이상의 동사를 사용하여 상기 컨텐츠의 상기 변경에 태그를 지정하는 단계를 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_66", "content": "제 63 항에 있어서, 상기 관계를 수신하는 단계는 상기 글로벌 의도 진술에 대한 상기 로컬 의도 진술 간의 복수의 별개의 관계를 수신하는 단계를 포함하고, 각 별개의 관계는 상기 솔루션을 구축하는 별개의 경로인,방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_67", "content": "제 63 항에 있어서, 각 로컬 의도 진술의 각 개체에 대해:상기 프로세서에 의해 상기 관련 에이전트로부터 상기 자연어의 형태로 상기 각 개체에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 개체에 대한 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각 개체에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건의 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_68", "content": "제 63 항에 있어서, 각 개체의 속성에 대해:상기 프로세서에 의해 상기 관련 에이전트로부터 상기 자연어의 형태로 상기 각 속성에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 속성에 대한 상기 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각각의속성에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건의 기록인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_69", "content": "공개특허 10-2021-0110604-12-제 67 항 또는 68 항에 있어서, 상기 프로세서에 의해, 로그인 세부 정보, 생체 측정 세부 정보, 얼굴 인식 기술 및 망막 감지 기술 중 하나를 기반으로 상기 관련 에이전트를 인증하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_70", "content": "제 67 항에 있어서, 각 로컬 의도 진술과 관련된 상기 개체 각각에 대해 상기 사건을 기록할 때, 상기 프로세서에 의해 상기 각 로컬 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 사건을 기록하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_71", "content": "제 70 항에 있어서, 각 로컬 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 상기 사건을 기록할 때, 상기 프로세서에 의해, 상기 글로벌 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는사건을 기록하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_72", "content": "제 63 항에 있어서, 상기 자연어는 하나 이상의 모국어, 하나 이상의 수화, 하나 이상의 기호, 하나 이상의 숫자 또는 이들의 조합을 기반으로 하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_73", "content": "프로그래밍 코드를 사용하지 않고 표준 운영 절차 (SOP) 파일과 사용자가 이해할 수 있는 자연어를 사용하는 컴퓨터 구현 솔루션의 구축 방법에 있어서,상기 SOP 파일은 지시문, 서술문 및 순서도를 포함하고, 상기 방법은:컴퓨팅 장치의 프로세서에 의해, 상기 지시문, 상기 서술문 및 상기 순서도를 식별하도록 상기 SOP 파일을 구문분석하는 단계;상기 프로세서에 의해, 상기 지시문 각각에 대해 하나씩인, 복수의 로컬 의도 진술을 결정하고 상기 로컬 의도진술 각각을 잠재성 상태로 설정하는 단계 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 해당 지시문을 분석하여 결정됨 - ; 상기 프로세서에 의해, 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 상기 해당 지시문과 연관된 상기 서술문을 분석하여 상기 복수의 로컬 의도 진술 각각과 관련된 개체 및 상기 개체 각각과 관련된 속성을 결정하고 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하는 단계 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ;상기 프로세서에 의해, 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하여 조합 개체 상태 (CES)의 세트를 형성하는 단계 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ;상기 프로세서에 의해 상기 순서도를 기반으로 상기 로컬 의도 진술 간의 관계를 결정하는 단계 - 상기 관계는한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지 여부를 나타내고, 상기 관계는 데이터베이스에저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및상기 프로세서에 의해 사용자로부터 상기 자연어 형태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하는 단계 - 상기 에이전트는인간 에이전트와 기계 에이전트 중 적어도 하나임 -을 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_74", "content": "제 73 항에 있어서, 상기 복수의 로컬 의도 진술을 결정하는 단계, 상기 개체 및 상기 속성을 결정하는 단계,및 상기 관계를 결정하는 단계 각각은:공개특허 10-2021-0110604-13-상기 지시문, 상기 서술문, 상기 순서도의 컨텐츠에서 품사를 식별하는 단계;상기 컨텐츠의 공동 참조, 특히 대명사를 이들의 선행으로 해결하는 단계;상기 컨텐츠의 모호성을 제거하기 위해 상속 관계를 순회하는 단계;상기 분석에서 모호성의 경우 상기 컨텐츠의 하나 이상의 부분을 표시하는 단계; 및상기 하나 이상의 모호성 부분을 명확하게 하기 위해 사용자 입력을 수신하는 단계를 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_75", "content": "제 73 항에 있어서, 상기 개체를 결정하는 단계는, 상기 서술문의 명사구를 기반으로 하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_76", "content": "제 73 항에 있어서, 상기 SOP 파일을 구문 분석하는 단계는, 분산된 문서 구문 분석 시스템을 사용하고, 상기분산 문서 구문 분석 시스템은 parse2Run인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_77", "content": "제 76 항에 있어서, 상기 parse2Run은 코어 패스, 참조 패스, 관계 패스, 이해 패스, 강화 패스, 준수 패스 중적어도 하나를 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_78", "content": "제 73 항에 있어서, 상기 자연어는 하나 이상의 모국어, 하나 이상의 수화, 하나 이상의 기호, 하나 이상의 숫자 또는 이들의 조합을 기반으로 하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_79", "content": "프로그래밍 코드를 자연어로 변환하여 자연어 기반 컴퓨터 구현 솔루션을 구축하는 방법에 있어서, 상기 자연어기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하고, 상기 방법은:컴퓨팅 장치의 프로세서에 의해, 상기 프로그래밍 코드에 존재하는 기호, 키워드, 연산자 및 함수를 추출하기위해 상기 프로그래밍 코드를 구문 분석하는 단계;상기 프로세서에 의해, 상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의매핑을 기반으로 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체 각각과연관된 속성을 결정하고, 상기 복수의 로컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하는단계 - 각 로컬 의도 진술은 솔루션을 구축하는 단계를 나타내며, 각 개체는 해당 로컬 의도 진술에 표시된 상기 단계에 참여하고, 상기 속성은 각각의 개체의 특성을 정의하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체를 구별함 - ; 상기 프로세서에 의해, 각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 가능한 모든 조합에기초하여 조합 개체 상태 (CES) 세트를 형성하는 단계 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ;상기 프로세서에 의해, 상기 추출된 연산자 및 함수와 상기 데이터베이스에 저장된 상기 자연어 데이터와의 매핑을 기반으로 상기 로컬 의도 진술 간의 관계를 결정하는 단계 - 상기 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고, 상기 관계는 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해상기 순서도를 분석함으로써 결정됨 - ; 및상기 프로세서에 의해 사용자로부터 상기 자연어 형태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하는 단계 - 상기 에이전트는적어도 인간 에이전트와 기계 에이전트 중 적어도 하나임 -를 포함하는, 방법.공개특허 10-2021-0110604-14-청구항 80 제 79 항에 있어서, 상기 관계를 수신하는 단계는 상기 글로벌 의도 진술에 대한 상기 로컬 의도 진술 사이의복수의 별개의 관계를 수신하는 단계를 포함하고, 각각의 별개의 관계는 상기 솔루션을 구축하는 별개의경로인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_81", "content": "제 79 항에 있어서, 상기 기계 에이전트는 유선 통신 채널 또는 무선 통신 채널을 통해 상기 컴퓨팅 장치에 통신 가능하게 결합되는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_82", "content": "제 79 항에 있어서, 상기 글로벌 의도 진술의 로컬 의도 진솔과 관련된 개체는:다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 로컬 의도 진술; 또는다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 개체인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_83", "content": "제 79 항에 있어서, 상기 프로그래밍 코드는 배치 운영 체제, 시분할 운영 체제, 분산 운영 체제, 네트워크 운영 체제 및 실시간 운영 체제 중 적어도 하나를 위한 것인, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_84", "content": "자연어를 기반으로 구축된 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하는 방법에 있어서, 상기 컴퓨터로 구현된 솔루션은 자연어 기반 입력을 사용하여 실행 가능하고, 상기 방법은:컴퓨팅 장치의 프로세서에 의해, 상기 컴퓨터 구현 솔루션을 구문 분석하는 단계 - 상기 컴퓨터로 구현된 솔루션은 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체, 상기 개체 각각과 연관된 속성,상기 복수의 로컬 의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 속성은 상기 각 개체의 특성을 정의하고 상기 각 개체를 상기 해당 로컬의도 진술의 다른 개체와 구별하며, 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의상기 CES 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타냄 - ; 컴퓨팅 장치의 프로세서에 의해, 복수의 자연어 솔루션 구성 요소를 추출하는 단계 - 상기 자연어 솔루션 구성요소는 상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함함 - ; 및상기 자연어 솔루션 구성 요소와 데이터베이스에 저장된 프로그래밍 언어의 기호, 키워드, 연산자 및 함수와의매핑을 기반으로 프로그래밍 언어 코드를 자동 생성하는 단계를 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_85", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한컴퓨팅 장치에 있어서, 상기 컴퓨팅 장치는,프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서로 하여금:사용자로부터 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 수신하고 - 상기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설정됨 - ;상기 사용자로부터 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 수신하고 - 각각의 로컬 의도 진술 및 상기 개체와 에이전트의 상기 세부 정공개특허 10-2021-0110604-15-보는 상기 자연어의 형태로 수신되고 각각 잠재성의 상태로 설정되며, 각 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 나타내는 상기 단계에 참여하고,상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 하는 조합개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 -;상기 글로벌 의도 진술과 관련된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로서 식별하고; 및상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 프로세서에의해 상기 사용자로부터 상기 자연어 형태로 상기 로컬 의도 진술 간의 관계를 수신하도록 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - 실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_86", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한컴퓨팅 장치에 있어서, 상기 컴퓨팅 장치는,사용자로부터 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 수신하는 수단 - 상기 글로벌 의도 진술은 상기자연어의 형태로 수신되고 잠재성 상태로 설정됨 - ;상기 사용자로부터 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 수신하는 수단 - 각각의 로컬 의도 진술 및 상기 개체와 에이전트의 상기 세부 정보는 상기 자연어의 형태로 수신되고 각각 잠재성의 상태로 설정되며, 각 로컬 의도 진술은 상기 솔루션을구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 나타내는 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 하는 조합개체 상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 -;상기 글로벌 의도 진술과 관련된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로서 식별하는 수단; 및상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 프로세서에의해 상기 사용자로부터 상기 자연어 형태로 상기 로컬 의도 진술 간의 관계를 수신하는 수단 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지 여부를 나타냄 - 을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_87", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한컴퓨팅 장치에 있어서, 상기 컴퓨팅 장치는,프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서로 하여금 제 1 항 내지 제 51 항 중 어느 한 항에 따른 방법을 수행하도록 실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_88", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한컴퓨팅 장치에 있어서, 상기 컴퓨팅 장치는,공개특허 10-2021-0110604-16-프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해:상기 자연어의 형태로 글로벌 의도 진술을 입력하고 상기 솔루션을 구축하기 위해 상기 글로벌 의도 진술을 잠재성 상태로 설정하라는 프롬프트를 사용자에게 제공하고;상기 사용자에게 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된개체와 에이전트의 세부 정보를 입력하고 상기 하나 이상의 로컬 의도 진술과 상기 개체 각각을 잠재성 상태로설정하라는 프롬프트를 제공하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및기계 에이전트 중 적어도 하나임 - ;각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ;상기 글로벌 의도 진술과 관련된 오직 하나의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상기 수신된로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로 식별하고; 및상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상기 사용자에게 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 입력하라는 프롬프트를 제공하도록 - 상기 관계는하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - 실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_89", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한컴퓨팅 장치에 있어서, 상기 컴퓨팅 장치는:상기 자연어의 형태로 글로벌 의도 진술을 입력하고 상기 솔루션을 구축하기 위해 상기 글로벌 의도 진술을 잠재성 상태로 설정하라는 프롬프트를 사용자에게 제공하는 수단;상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 입력하고 상기 하나 이상의 로컬 의도 진술과 상기 개체 각각을 잠재성 상태로 설정하라는 프롬프트를 상기 사용자에게 제공하는 수단 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ;각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ;상기 글로벌 의도 진술과 관련된 오직 하나의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상기 수신된로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로 식별하는 수단; 및상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 입력하라는 프롬프트를 상기 사용자에게 제공하는 수단 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - 을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_90", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한컴퓨팅 장치에 있어서, 상기 컴퓨팅 장치는,공개특허 10-2021-0110604-17-프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해 제 52 항 내지 제 62 항 중 어느 한 항에 따른 방법을 수행하도록 실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_91", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한컴퓨팅 장치에 있어서, 상기 컴퓨팅 장치는,프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해:복수의 차별화된 이미지 프레임을 식별하기 위해 비디오의 이미지 프레임을 처리하고 - 각각의 차별화된 이미지프레임은 그 콘텐츠의 차이에 기초하여 상기 비디오의 하나 이상의 이전 이미지 프레임과 다른 것으로 식별됨 -;상기 비디오의 바로 직전의 이미지 프레임의 콘텐츠에 관련하여 각 차별화된 이미지 프레임의 콘텐츠의 차이에각각 기초하는, 복수의 로컬 의도 진술을 결정하고, 상기 로컬 의도 진술 각각을 잠재적 상태에서 설정하고 -각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 이미지 프레임의 콘텐츠를 분석함으로써 결정됨 - ; 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 연속된 쌍의 차별화된 이미지 프레임 사이의 상기이미지 프레임의 컨텐츠를 분석함으로써 상기 복수의 로컬 의도 진술 각각과 연관된 개체와 상기 개체 각각과연관된 속성을 결정하고 상기 개체와 속성 각각을 잠재성 상태로 설정하고 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 대응하는 로컬 의도 진술의 다른 개체로부터 구별함 - ;제 1 차별화된 이미지 프레임과 마지막으로 차별화된 이미지 프레임의 상기 콘텐츠의 변경을 기반으로 상기 컴퓨터 구현 솔루션에 대한 글로벌 의도 진술을 결정하고 상기 글로벌 의도 진술을 잠재성 상태로 설정하고 - 상기 글로벌 의도 진술은 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 제 1 차별화된 이미지 프레임 및 상기 마지막 차별화된 이미지 프레임의 상기 콘텐츠를 분석함으로써 결정됨 - ;각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 조합 개체상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ;사용자로부터 상기 복수의 로컬 의도 진술과 관련된 에이전트의 세부 정보를 자연어 형태로 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하고 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나이고; 및상기 사용자로부터 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 수신하도록 - 상기 관계는 하나의로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터구현 솔루션을 구축하는 단계의 종료인지를 나타냄 - 실행 가능한 명령을 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_92", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한컴퓨팅 장치에 있어서, 상기 컴퓨팅 장치는:복수의 차별화된 이미지 프레임을 식별하기 위해 비디오의 이미지 프레임을 처리하는 수단 - 각각의 차별화된이미지 프레임은 그 콘텐츠의 차이에 기초하여 상기 비디오의 하나 이상의 이전 이미지 프레임과 다른 것으로식별됨 - ;상기 비디오의 바로 직전의 이미지 프레임의 콘텐츠에 대한 각 차별화된 이미지 프레임의 콘텐츠의 차이에 각각기초하는, 복수의 로컬 의도 진술을 결정하고, 상기 로컬 의도 진술 각각을 잠재적 상태에서 설정하는 수단 -각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터공개특허 10-2021-0110604-18-와 관련하여 상기 이미지 프레임의 콘텐츠를 분석함으로써 결정됨 - ; 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 연속된 쌍의 차별화된 이미지 프레임 사이의 상기이미지 프레임의 컨텐츠를 분석함으로써 상기 복수의 로컬 의도 진술 각각과 연관된 개체와 상기 개체 각각과연관된 속성을 결정하고 상기 개체와 속성 각각을 잠재성 상태로 설정하는 수단 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기대응하는 로컬 의도 진술의 다른 개체로부터 구별함 - ;제 1 차별화된 이미지 프레임과 마지막으로 차별화된 이미지 프레임의 상기 콘텐츠의 변경을 기반으로 상기 컴퓨터 구현 솔루션에 대한 글로벌 의도 진술을 결정하고 상기 글로벌 의도 진술을 잠재성 상태로 설정하는 수단- 상기 글로벌 의도 진술은 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 제 1 차별화된 이미지프레임 및 상기 마지막 차별화된 이미지 프레임의 상기 콘텐츠를 분석함으로써 결정됨 - ;각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 조합 개체상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ;사용자로부터 상기 복수의 로컬 의도 진술과 관련된 에이전트의 세부 정보를 자연어 형태로 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하는 수단 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중적어도 하나이고; 및상기 사용자로부터 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 수신하는 수단 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하는 단계의 종료인지를 나타냄 - 을 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_93", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한컴퓨팅 장치에 있어서, 상기 컴퓨팅 장치는,프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해 제 63 항 내지 제 72 항 중 어느 한 항에 따른 방법을 수행하도록 실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_94", "content": "프로그래밍 코드를 사용하지 않고 표준 운영 절차 (SOP) 파일과 사용자가 이해할 수 있는 자연어를 사용하는 컴퓨터 구현 솔루션의 구축을 위한 컴퓨팅 장치에 있어서, 상기 SOP 파일은 지시문, 서술문 및 순서도를포함하고, 상기 컴퓨팅 장치는:프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해:상기 지시문, 상기 서술문 및 상기 순서도를 식별하도록 상기 SOP 파일을 구문 분석하고;상기 지시문 각각에 대해 하나씩인, 복수의 로컬 의도 진술을 결정하고 상기 로컬 의도 진술 각각을 잠재성 상태로 설정하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 해당 규범 진술을 분석하여 결정됨 - ;상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 상기 해당 지시문과 연관된 상기 서술문을 분석하여 상기 복수의 로컬 의도 진술 각각과 관련된 개체 및 상기 개체 각각과 관련된 속성을 결정하고 상기 개체 및상기 속성 각각을 잠재성 상태로 설정하고 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ;각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하여 조합 개체상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조공개특허 10-2021-0110604-19-합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ;상기 순서도를 기반으로 상기 로컬 의도 진술 간의 관계를 결정하고 - 상기 관계는 한 로컬 의도 진술의 트리거CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지 여부를 나타내고, 상기 관계는 데이터베이스에 저장된 상기 자연어 데이터에대해 상기 순서도를 분석함으로써 결정됨 - ; 및사용자로부터 상기 자연어 형태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하도록 - 상기 에이전트는 인간 에이전트와 기계 에이전트 중 적어도 하나임 -실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_95", "content": "프로그래밍 코드를 사용하지 않고 표준 운영 절차 (SOP) 파일과 사용자가 이해할 수 있는 자연어를 사용하는 컴퓨터 구현 솔루션의 구축을 위한 컴퓨팅 장치에 있어서, 상기 SOP 파일은 지시문, 서술문 및 순서도를포함하고, 상기 컴퓨팅 장치는:상기 지시문, 상기 서술문 및 상기 순서도를 식별하도록 상기 SOP 파일을 구문 분석하는 수단;상기 지시문 각각에 대해 하나씩인, 복수의 로컬 의도 진술을 결정하고 상기 로컬 의도 진술 각각을 잠재성 상태로 설정하는 수단 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에저장된 자연어 데이터와 관련하여 상기 해당 규범 진술을 분석하여 결정됨 - ; 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 상기 해당 지시문과 연관된 상기 서술문을 분석하여 상기 복수의 로컬 의도 진술 각각과 관련된 개체 및 상기 개체 각각과 관련된 속성을 결정하고 상기 개체 및상기 속성 각각을 잠재성 상태로 설정하는 수단 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 상기 단계에참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의다른 개체와 구별함 - ;각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하여 조합 개체상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ;상기 순서도를 기반으로 상기 로컬 의도 진술 간의 관계를 결정하는 수단 - 상기 관계는 한 로컬 의도 진술의트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지 여부를 나타내고, 상기 관계는 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및사용자로부터 상기 자연어 형태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하는 수단 - 상기 에이전트는 인간 에이전트와 기계에이전트 중 적어도 하나임 -을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_96", "content": "프로그래밍 코드를 사용하지 않고 표준 운영 절차 (SOP) 파일과 사용자가 이해할 수 있는 자연어를 사용하는 컴퓨터 구현 솔루션의 구축을 위한 컴퓨팅 장치에 있어서, 상기 SOP 파일은 지시문, 서술문 및 순서도를포함하고, 상기 컴퓨팅 장치는:프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해 제 73항 내지 제 78 항 중 어느한 항에 따른 방법을 수행하도록 실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_97", "content": "프로그래밍 코드를 자연어로 변환하여 자연어 기반 컴퓨터 구현 솔루션을 구축하는 컴퓨팅 장치에 있어서, 상기공개특허 10-2021-0110604-20-자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하고, 상기 컴퓨팅 장치는:프로세서; 및상기 프로세서에 연결된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해:상기 프로그래밍 코드에 있는 기호, 키워드, 연산자 및 함수를 추출하도록 상기 프로그래밍 코드를 구문 분석하고;상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의 매핑에 기초하여 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을 결정하고 상기 복수의 로컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하고 - 각각의 로컬 의도진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 대응하는 로컬 의도 진술에 의해 표시되는 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 대응하는 로컬의도 진술의 다른 개체와 구별함 - ;각 로컬 의도 진술서에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기반한 조합 개체상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 -;상기 추출된 연산자 및 함수와 상기 데이터베이스에 상기 저장된 자연어 데이터와의 매핑을 기반으로 상기 로컬의도 진술 간의 관계를 결정하고 - 상기 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를나타내고, 상기 관계는 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및사용자로부터 상기 복수의 로컬 의도 진술 각각과 연관된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하도록 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 -실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_98", "content": "프로그래밍 코드를 자연어로 변환하여 자연어 기반 컴퓨터 구현 솔루션을 구축하는 컴퓨팅 장치에 있어서, 상기자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하고, 상기 컴퓨팅 장치는:상기 프로그래밍 코드를 구문 분석하여 상기 프로그래밍 코드에 있는 기호, 키워드, 연산자 및 함수를 추출하는수단;상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의 매핑에 기초하여 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을 결정하고 상기 복수의 로컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하는 수단 - 각각의 로컬의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 대응하는 로컬 의도 진술에 의해 표시되는 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 대응하는로컬 의도 진술의 다른 개체와 구별함 - ;각 로컬 의도 진술서에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기반한 조합 개체상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 -;상기 추출된 연산자 및 함수와 상기 데이터베이스에 상기 저장된 자연어 데이터와의 매핑을 기반으로 상기 로컬의도 진술 간의 관계를 결정하는 수단 - 상기 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고, 상기 관계는 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및사용자로부터 상기 복수의 로컬 의도 진술 각각과 연관된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상공개특허 10-2021-0110604-21-기 세부 정보를 잠재성 상태로 설정하는 수단 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 -을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_99", "content": "프로그래밍 코드를 자연어로 변환하여 자연어 기반 컴퓨터 구현 솔루션을 구축하는 컴퓨팅 장치에 있어서, 상기자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하고, 상기 컴퓨팅 장치는:프로세서; 및상기 프로세서에 연결된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해 제 79 항 내지 제 83 항 중 어느 한 항에 따른 방법을 수행하도록 실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_100", "content": "자연어 기반의 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하기 위한 컴퓨팅 장치에 있어서, 상기 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 컴퓨팅 장치는:프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해:상기 컴퓨터 구현 솔루션을 구문 분석하고- 상기 컴퓨터 구현 솔루션은 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 관련된 개체, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구축하는 단계를나타내며, 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하고, 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타냄 - ;컴퓨팅 장치의 프로세서에 의해 복수의 자연어 솔루션 구성 요소를 추출하고 - 상기 자연어 솔루션 구성 요소는상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 의도진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함함 - ;상기 자연어 솔루션 구성 요소와 데이터베이스에 저장된 프로그래밍 언어의 기호, 키워드, 연산자 및 함수와의매핑을 기반으로 프로그래밍 언어 코드를 자동 생성하도록실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_101", "content": "자연어 기반의 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하기 위한 컴퓨팅 장치에 있어서, 상기 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 컴퓨팅 장치는:상기 컴퓨터 구현 솔루션을 구문 분석하는 수단 - 상기 컴퓨터 구현 솔루션은 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 관련된 개체, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 진술 간의 관계,조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구축하는단계를 나타내며, 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하고, 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타냄 - ;컴퓨팅 장치의 프로세서에 의해 복수의 자연어 솔루션 구성 요소를 추출하는 수단 - 상기 자연어 솔루션 구성요소는 상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함함 - ;공개특허 10-2021-0110604-22-상기 자연어 솔루션 구성 요소와 데이터베이스에 저장된 프로그래밍 언어의 기호, 키워드, 연산자 및 함수와의매핑을 기반으로 프로그래밍 언어 코드를 자동 생성하는 수단을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_102", "content": "자연어 기반의 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하기 위한 컴퓨팅 장치에 있어서, 상기 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 컴퓨팅 장치는:프로세서; 및상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 제 84 항에 따른 방법을 실행하도록 실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_103", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하는, 컴퓨터 구현 솔루션을 구축하기 위한명령이 저장된 비 일시적 컴퓨터 판독 가능 매체에 있어서, 프로세서에 의해 실행될 때 상기 프로세서로하여금:사용자로부터 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 수신하고 - 상기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설정됨 - ;상기 사용자로부터 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 수신하고 - 각각의 로컬 의도 진술 및 상기 개체와 에이전트의 상기 세부 정보는 상기 자연어의 형태로 수신되고 각각 잠재성의 상태로 설정되며, 각 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 나타내는 상기 단계에 참여하고,상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 하는 조합개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 -;상기 글로벌 의도 진술과 관련된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로서 식별하고; 및상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 프로세서에의해 상기 사용자로부터 상기 자연어 형태로 상기 로컬 의도 진술 간의 관계를 수신하도록 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지 여부를 나타냄 - 하는 기계 실행 가능 코드를 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_104", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하는, 컴퓨터 구현 솔루션을 구축하기 위한명령이 저장된 비 일시적 컴퓨터 판독 가능 매체에 있어서, 프로세서에 의해 실행될 때 상기 프로세서로하여금:상기 자연어의 형태로 글로벌 의도 진술을 입력하고 상기 솔루션을 구축하기 위해 상기 글로벌 의도 진술을 잠재성 상태로 설정하라는 프롬프트를 사용자에게 제공하고;상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 입력하고 상기 하나 이상의 로컬 의도 진술과 상기 개체 각각을 잠재성 상태로 설정하라는 프롬프트를 상기 사용자에게 제공하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며,각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트및 기계 에이전트 중 적어도 하나임 - ;각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 조합 개체 상공개특허 10-2021-0110604-23-태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ;상기 글로벌 의도 진술과 관련된 오직 하나의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상기 수신된로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로 식별하고; 및상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 입력하라는 프롬프트를 상기 사용자에게 제공하도록 - 상기 관계는하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - 실행 가능한 명령을 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_105", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 비디오 및 자연어를 사용하는, 컴퓨터 구현 솔루션을 구축하기 위한 명령이 저장된 비 일시적 컴퓨터 판독 가능 매체에 있어서, 프로세서에 의해 실행될 때 상기 프로세서로 하여금:복수의 차별화된 이미지 프레임을 식별하기 위해 비디오의 이미지 프레임을 처리하고 - 각각의 차별화된 이미지프레임은 그 콘텐츠의 차이에 기초하여 상기 비디오의 하나 이상의 이전 이미지 프레임과 다른 것으로 식별됨 -;상기 비디오의 바로 직전의 이미지 프레임의 콘텐츠에 대한 각 차별화된 이미지 프레임의 콘텐츠의 차이에 각각기초하는, 복수의 로컬 의도 진술을 결정하고, 상기 로컬 의도 진술 각각을 잠재적 상태에서 설정하고 - 각각의로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 이미지 프레임의 콘텐츠를 분석함으로써 결정됨 - ; 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 연속된 쌍의 차별화된 이미지 프레임 사이의 상기이미지 프레임의 컨텐츠를 분석함으로써 상기 복수의 로컬 의도 진술 각각과 연관된 개체와 상기 개체 각각과연관된 속성을 결정하고 상기 개체와 속성 각각을 잠재성 상태로 설정하고 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 대응하는 로컬 의도 진술의 다른 개체로부터 구별함 - ;제 1 차별화된 이미지 프레임과 마지막으로 차별화된 이미지 프레임의 상기 콘텐츠의 변경을 기반으로 상기 컴퓨터 구현 솔루션에 대한 글로벌 의도 진술을 결정하고 상기 글로벌 의도 진술을 잠재성 상태로 설정하고 - 상기 글로벌 의도 진술은 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 제 1 차별화된 이미지 프레임 및 상기 마지막 차별화된 프레임의 상기 콘텐츠를 분석함으로써 결정됨 - ;각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 조합 개체상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ;사용자로부터 상기 복수의 로컬 의도 진술과 관련된 에이전트의 세부 정보를 자연어 형태로 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하고 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나이고; 및상기 사용자로부터 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 수신하도록 - 상기 관계는 하나의로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터구현 솔루션을 구축하는 단계의 종료인지를 나타냄 - 하는 기계 실행 가능 코드를 포함하는, 방법."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_106", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하는, 컴퓨터 구현 솔루션을 구축하기 위한명령이 저장된 비 일시적 컴퓨터 판독 가능 매체에 있어서, 상기 SOP 파일은 지시문, 서술문 및 순서도를 포함하고, 상기 명령은 프로세서에 의해 실행될 때 상기 프로세서로 하여금:공개특허 10-2021-0110604-24-상기 지시문, 상기 서술문 및 상기 순서도를 식별하도록 상기 SOP 파일을 구문 분석하고;상기 지시문 각각에 대해 하나씩인, 복수의 로컬 의도 진술을 결정하고 상기 로컬 의도 진술 각각을 잠재성 상태로 설정하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 해당 규범 진술을 분석하여 결정됨 - ;상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 상기 해당 지시문과 연관된 상기 서술문을 분석하여 상기 복수의 로컬 의도 진술 각각과 관련된 개체 및 상기 개체 각각과 관련된 속성을 결정하고 상기 개체 및상기 속성 각각을 잠재성 상태로 설정하고 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ;각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하여 조합 개체상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ;상기 순서도를 기반으로 상기 로컬 의도 진술 간의 관계를 결정하고 - 상기 관계는 한 로컬 의도 진술의 트리거CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고, 상기 관계는 데이터베이스에 저장된 상기 자연어 데이터에 대해상기 순서도를 분석함으로써 결정됨 - ; 및사용자로부터 상기 자연어 형태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하도록 - 상기 에이전트는 인간 에이전트와 기계 에이전트 중 적어도 하나임 -하는 기계 실행 가능 코드를 포함하는, 컴퓨팅 장치."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_107", "content": "자연어 기반의 컴퓨터 구현 솔루션을 구축하기 위해 프로그래밍 코드를 자연어로 변환하기 위한 명령이 저장된비 일시적 컴퓨터 판독 가능 매체에 있어서, 상기 자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 명령은 프로세서에 의해 실행될 때, 상기 프로세서가: 상기 프로그래밍 코드에 있는 기호, 키워드, 연산자 및 함수를 추출하도록 상기 프로그래밍 코드를 구문 분석하고;상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의 매핑에 기초하여 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을 결정하고 상기 복수의 로컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하고 - 각각의 로컬 의도진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 대응하는 로컬 의도 진술에 의해 표시되는 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 대응하는 로컬의도 진술의 다른 개체와 구별함 - ;각 로컬 의도 진술서에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기반한 조합 개체상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 -;상기 추출된 연산자 및 함수와 상기 데이터베이스에 상기 저장된 자연어 데이터와의 매핑을 기반으로 상기 로컬의도 진술 간의 관계를 결정하고 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고, 상기 관계는 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및사용자로부터 상기 복수의 로컬 의도 진술 각각과 연관된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하도록 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 -하는 기계 실행 가능 코드를 포함하는, 비 일시적 컴퓨터 판독 가능 매체.공개특허 10-2021-0110604-25-청구항 108 자연어를 기반으로 구축된 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하기 위한 명령어가 저장된 비 일시적컴퓨터 판독 가능 매체에 있어서, 상기 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 명령은 프로세서에 의해 실행될 때 상기 프로세서로 하여금:상기 컴퓨터 구현 솔루션을 구문 분석하고 - 상기 컴퓨터 구현 솔루션은 복수의 로컬 의도 진술, 상기 복수의로컬 의도 진술 각각과 관련된 개체, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 진술 간의 관계, 조합개체 상태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구축하는 단계를 나타내며, 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의특성을 정의하고 상기 각각의 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하고, 상기 관계는 하나의로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타냄 - ;컴퓨팅 장치의 프로세서에 의해 복수의 자연어 솔루션 구성 요소를 추출하고 - 상기 자연어 솔루션 구성 요소는상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 의도진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함함 - ;상기 자연어 솔루션 구성 요소와 데이터베이스에 저장된 프로그래밍 언어의 기호, 키워드, 연산자 및 함수와의매핑을 기반으로 프로그래밍 언어 코드를 자동 생성하도록하는 기계 실행 가능 코드를 포함하는, 비 일시적 컴퓨터 판독 가능 매체."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_109", "content": "프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하기 위한시스템에 있어서, 상기 시스템은:프로세서; 및상기 프로세서에 연결된 글로벌 의도 진술 모듈, 로컬 의도 진술 모듈, CES 모듈 및 관계 모듈 - 상기 글로벌의도 진술 모듈, 상기 로컬 의도 진술 모듈, 상기 CES 모듈 및 상기 관계 모듈은 서로 작동 가능하게 연결됨 - 을 포함하고,상기 글로벌 의도 진술 모듈은 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 사용자로부터 수신하도록 구성되고 - 상기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설정됨 - ;상기 로컬 의도 진술 모듈은 상기 사용자로부터 상기 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술및 각 로컬 의도 진술과 연관된 개체의 세부 정보와 에이전트를 수신하도록 구성되고 - 각 로컬 의도 진술과 상기 개체 및 에이전트의 상기 세부 정보는 자연어의 형태로 수신되고 각각 잠재성 상태로 설정되고, 각 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 단계에 참여하고, 상기 에이전트는 인간 에이전트, 기계 에이전트 및 컴퓨터 기능 중 적어도 하나임 - ;상기 CES 모듈은 각각의 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 하여 조합 개체 상태 (CES)의 세트를 형성하도록 구성되고 - 상기 각각의 로컬 의도 진술의 모든상기 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있고, 상기 글로벌 의도 진술과 연관된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 솔루션을 구축하는 단계의 종료로서 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 식별함 - ; 및상기 관계 모듈은 상기 자연어의 형태로 상기 사용자로부터 상기 로컬 의도 진술 간의 관계를 수신하도록 구성되는 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - ,시스템."}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_110", "content": "자연어 기반 컴퓨터 구현 솔루션을 구축하기 위해 프로그래밍 코드를 자연어로 변환하기 위한 시스템에 있어서,공개특허 10-2021-0110604-26-상기 자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 시스템은:프로세서; 및상기 프로세서에 연결된, 구문 분석 모듈, 추출기 모듈, 해석기 모듈, 매핑 모듈, 글로벌 의도 모듈, 로컬 의도모듈, CES 모듈 및 관계 모듈을 포함하고,상기 구문 분석 모듈, 상기 추출기 모듈, 상기 해석기 모듈, 상기 매핑 모듈, 상기 글로벌 의도 모듈, 상기 로컬 의도 모듈, 상기 CES 모듈 및 상기 관계 모듈이 서로 작동 가능하게 연결되고, 상기 구문 분석 모듈은 상기 프로그래밍 코드에 존재하는 기호, 키워드, 연산자 및 함수를 추출하기 위해 프로그래밍 코드를 구문 분석하도록 구성되고;상기 추출기 모듈, 상기 해석기 모듈, 상기 매핑 모듈, 상기 글로벌 의도 진술 모듈 및/또는 상기 로컬 의도 진술 모듈은 상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의 매핑에 기초하여 복수의 로컬 의도 진술, 상기 복수의 로컬 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을결정하고 상기 복수의 로컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠재적 상태로 설정하도록 구성되고 -각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도진술에 의해 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 대응하는 로컬 의도 진술의 다른 개체로부터 상기 각각의 개체를 구별함 - ;상기 CES 모듈은 각 로컬 의도 상태에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하도록 구성되고 - 상기 각각의 로컬 의도 진술의 모든 상기 개체에기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 -;상기 관계 모듈은 상기 추출된 연산자 및 함수와 상기 데이터베이스에 저장된 상기 자연어 데이터와의 매핑을기반으로 상기 로컬 의도 진술 간의 관계를 결정하도록 구성되며, 상기 관계는 하나의 로컬 의도 진술의 트리거CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고, 상기 관계는 상기 데이터베이스에 저장된 상기 자연어 데이터에대해 상기 순서도를 분석함으로써 결정됨 - ; 및상기 로컬 의도 진술 모듈은 상기 자연어의 형태로 사용자로부터 상기 복수의 로컬 의도 진술 각각과 연관된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재적 상태로 설정하도록 구성되는, - 상기에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - 시스템"}
{"patent_id": "10-2021-7021130", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_111", "content": "자연어를 기반으로 구축된 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환기 위한 시스템에 있어서, 상기 컴퓨터구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 시스템은프로세서; 및상기 프로세서에 연결된 솔루션 구문 분석 모듈, 솔루션 추출기 모듈, 자동 생성기 모듈 및 매핑 모듈을 포함하고, 상기 솔루션 구문 분석 모듈, 상기 솔루션 추출기 모듈, 상기 자동 생성기 모듈 및 상기 매핑 모듈은 서로 작동 가능하게 연결되고, 상기 솔루션 구문 분석 모듈은 상기 컴퓨터 구현 솔루션을 구문 분석하도록 구성되고, 상기 컴퓨터 구현 솔루션은 복수의 로컬 의도 진술, 사기 복수의 로컬 의도 진술 각각과 연관된 개체, 상기 개체 각각과 연관된 속성,상기 복수의 로컬 의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 속성은 상기 각 개체의 특성을 정의하고 상기 각각의 개체를 상기 해당로컬 의도 진술의 다른 개체와 구별하며, 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도진술의 상기 CES 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의공개특허 10-2021-0110604-27-종료인지를 나타내고;상기 솔루션 추출기 모듈은 복수의 자연어 솔루션 구성 요소를 추출하도록 구성되며, 상기 자연어 솔루션 구성요소는 상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거를 포함하고;상기 자동 생성기 모듈은 상기 매핑 모듈을 기반으로 프로그래밍 언어 코드를 자동 생성하도록 구성되고, 상기매핑 모듈은 상기 자연어 솔루션 구성 요소와 데이터베이스에 저장된 프로그래밍 언어의 기호, 키워드, 연산자및 함수와의 매핑으로 구성되는, 시스템."}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "자연어 기반 설계를 사용하여 응용 프로그램 또는 솔루션 로직을 컴퓨터에 전달할 때 '프로그래밍 코드'에 효과 적으로 대체되는 컴퓨터 구현 방법이 제공된다. 생경한 기호나 키워드를 언급하지 않고, NSL은 복잡한 작동, 응 용 프로그램 및 솔루션 로직을 사용자 친화적인 방식으로 기계 에이전트 (컴퓨터)에 기술적으로 전달하기 위해 (뒷면에 계속)"}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원은 2019년 1월 10일에 출원된 출원 번호 201941001135 및 2019년 7월 16일에 출원된 출원 번호 201941028675의 연관 출원이며, 그 전체가 본 명세서에 참조로 포함된다. 본 개시는 정보 기술 분야에 관한 것이다. 보다 구체적으로, 본 개시는 솔루션을 설계하고 배치하기 위한 컴퓨 터 구현 방법, 시스템 및 컴퓨터 판독 가능 매체에 관한 것이다."}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "소프트웨어 엔지니어링, 설계 및 아키텍처 관행은 지난 60 년 동안 상당히 변화하고 발전했다. 단순화를 위해, 작업의 로직을 컴퓨터에 전달하는 여러 수준의 추상화를 두 그룹으로 나눌 수 있다: 프로그래밍 언어를 통 해 전달되는 고급 애플리케이션 로직; 및 컴퓨터와 그 작업을 보다 직접적으로 중재하거나 처리하는 운영 체제 및 그 이하. 주로 널리 사용되는 세 가지 운영 체제가 있다: Microsoft Windows, Apple Mac OS X 및 Linux. 그러나 수백 개 의 프로그래밍 언어가 있다. 일반적으로 모든 프로그래밍 언어는 코드 (자연어 및 산술에서 제거된 특정 의미와 기능을 가진 기호)에 의해 광범위하게 구동된다. 소프트웨어 전문가와 엔지니어가 프로그래밍 언어를 마스터하 고 솔루션 생성 또는 유지 관리에 참여하는 데는 몇 주에서 몇 달이 걸린다. 결과적으로, 솔루션 사용자는 일반 적으로 기술 전문가의 개입없이 상황에 따라 솔루션을 생성하거나 수정할 수 없다. 수년에 걸쳐 정보 기술의 컴퓨팅 및 통신 능력은 상당히 크게 성장했다. 일반적으로, 소프트웨어 설계 및 관리 기술은 구성 요소 기반 설계, 서비스 지향 아키텍처, 웹 서비스, 비즈니스 프로세스 관리 및 민첩한 프로젝트 관리 방법론으로 이동하면서 향상되었다. 동시에, 이동 부품의 수가 급증함에 따라 기술 환경은 더욱 복잡해졌 다. 일반 사용자는 가능한 것에 비해 솔루션 설계에 직접 참여하거나 지속적으로 영향을 미칠 수 있는 위치에 있지 않기 때문에, 컴퓨터에서 계속 소외되어 왔다. 사용자가 기술 전문가 및 중재자에게 과도하게 의존하는 것 은 프로그래밍 언어가 자연어와 매우 다르기 때문이다. 현재 기술 시스템 상태로는 컴퓨터 언어가 자연어와 거 의 동일한 기술적이고 창의적이며 혁신적인 기회를 실현하지 못한다."}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시의 기술적 과제는 솔루션을 설계하고 배치하기 위한 컴퓨터 구현 방법, 시스템 및 컴퓨터 판독 가능 매 체를 제공하는 것이다."}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시의 일 양태에 따른, 사용자가 이해하는 자연어를 사용하고 프로그래밍 코드를 사용하지 않고 컴퓨터 구 현 솔루션을 구축하는 방법은: 컴퓨팅 장치의 프로세서에 의해 사용자로부터 상기 솔루션을 구축하기 위한 글로 벌 의도 진술을 수신하는 단계 - 상기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설정 됨 - ; 상기 프로세서에 의해 상기 사용자로부터 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 수신하는 단계 - 각각의 로컬 의도 진술 및 상 기 개체와 에이전트의 상기 세부 정보는 상기 자연어의 형태로 수신되고 각각 잠재성의 상태로 설정되며, 각 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의 해 나타내는 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 상 기 프로세서에 의해, 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 모든 가능한 조합 을 기반으로 하는 조합 개체 상태 (CES)의 세트를 형성하는 단계 - 상기 각각의 로컬 의도 진술의 상기 개체 모 두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있 음 -; 상기 글로벌 의도 진술과 관련된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로서 식별하는 단계; 및 상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 프로세서에 의해 상기 사 용자로부터 상기 자연어 형태로 상기 로컬 의도 진술 간의 관계를 수신하는 단계 - 상기 관계는 하나의 로컬 의 도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 솔루션을 구축하 는 단계의 종료인지 여부를 나타냄 - 을 포함할 수 있다."}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시에 따르면 솔루션을 설계하고 배치하기 위한 컴퓨터 구현 방법, 시스템 및 컴퓨터 판독 가능 매체가 제 공될 수 있다."}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "시스템, 장치 또는 장치 및 방법이 본 명세서에서 예시 및 실시 예를 통해 설명되지만, 당업자는 솔루션을 제공 하기 위한 시스템 및 방법이 설명된 실시 예 또는 도면으로 제한되지 않음이 이해될 것이다. 도면 및 설명은 개 시된 특정 형태로 제한하려는 것이 아님을 이해해야 한다. 오히려, 그 의도는 첨부된 청구 범위의 정신과 범위 내에 있는 모든 수정, 등가물 및 대안을 포함하는 것이다. 본 명세서에서 사용된 모든 제목은 구성 목적으로만 사용되며 설명 또는 청구 범위를 제한하지 않는다. 본 명세서에서 사용된 바와 같이, \"할 수 있다\"라는 단어는 의무적 의미 (예를 들어, 필수를 의미함)보다는 허용적 의미 (예를 들어, 잠재적이라는 의미)로 사용된다. 유사 하게, \"포함하다\" 및 \"포함하는\"라는 단어는 이에만 제한되지 않음을 의미한다. 이하에서 특허 출원시에 발명자에게 알려진 본 개시를 수행하기 위해 현재 고려되는 최상의 방법 및 시스템, 디 바이스 또는 장치에 대해 완전하고 유익하게 설명한다. 물론, 다음의 설명, 첨부 도면 및 첨부된 청구 범위를 고려하여 관련 기술 분야의 숙련자에게는 많은 수정 및 개조가 명백할 것이다. 본 명세서에 설명된 시스템, 장 치 또는 디바이스 및 방법에는 어느 정도의 특이성이 제공되지만, 본 기술은 사용자의 필요에 따라 더 크거나 더 적은 특이성을 가지고 구현될 수 있다. 또한, 본 기술의 일부 특징은 다음 단락에서 설명하는 다른 특징의 대응하는 사용 없이 이점을 얻기 위해 사용될 수 있다. 이와 같이, 본 기술은 청구 범위에 의해서만 정의되기 때문에, 본 설명은 본 기술의 원리를 단지 예시하는 것으로 간주되어야 하며 그에 제한되지는 않는다. 예비 사항으로서, 다음 논의 및 첨부된 청구 범위의 목적을 위한 용어 \"또는\"의 정의는 포괄적인 것이다. 즉, 용어 \"또는\"은 상호 배타적인 두 가지 대안을 구별하기 위한 것이 아니다. 오히려 두 요소 사이의 결합으로 사 용될 때 \"또는\"이라는 용어는 하나의 요소 자체, 다른 요소 자체, 요소의 조합 및 순열을 포함하는 것으로 정의 된다. 예를 들어, 용어 \"A\" 또는 \"B\"를 사용하는 설명은 \"A\" 자체, \"B\" 자체 및 \"AB\" 및/또는 \"BA\"와 같은 이들 의 조합을 포함한다. 본 논의는 예시적인 실시 예에 관한 것이며, 첨부된 청구 범위는 여기에서 논의된 실시 예 로 제한되지 않아야 한다는 점에 주목해야 한다. 본 명세서의 설명을 위해, 프로세서는 마이크로 프로세서, 마이크로 컴퓨터, 마이크로 컨트롤러, 디지털 신호 프로세서, 중앙 처리 장치, 상태 기계, 로직 회로, 및/또는 동작 명령에 기초하여 신호를 조작하는 임의의 장치 로 구현될 수 있다. 다른 능력들 중에서, 프로세서는 프로세서에 연결된 비 일시적 컴퓨터 판독 가능 저장 매체 에 저장된 컴퓨터 판독 가능 명령어를 페치하고 실행할 수 있다. 비 일시적 컴퓨터 판독 가능 저장 매체는 예를 들어, 휘발성 메모리 (예 : RAM) 및/또는 비 휘발성 메모리 (예 : EPROM, 플래시 메모리, NVRAM, 멤리스터 (memristor) 등)를 포함할 수 있다. 본 명세서의 설명을 위해, 메모리는 컴퓨팅 장치의 메모리일 수 있고, 예를 들어 휘발성 메모리 (예를 들어, RAM) 및/또는 비 휘발성 메모리 (예 : EPROM, 플래시 메모리, NVRAM, 멤리스터 등)를 포함하는 임의의 비 일시 적 컴퓨터 판독 가능 저장 매체를 포함할 수 있다. 본 명세서의 설명을 위해, 모듈은 무엇보다도 특정 작업을 수행하거나 특정 데이터 유형을 구현하는 루틴, 프로그램, 객체, 구성 요소, 데이터 구조 등을 포함한다. 모듈 은 컴퓨팅 장치의 애플리케이션을 보완하는 모듈, 예를 들어 운영 체제의 모듈을 더 포함한다.자연 솔루션 언어(NSL)에 관한 용어들 아래 나열된 각각의 용어는 컴퓨터 구현 NSL 방법론과 관련하여 특정 역할 및 응용 프로그램을 가지고 있다. 이 러한 개별 기술적 및 방법론적 요소는 NSL이 생성하는 일반적인 새로운 패러다임과 관련하여 설명된 역할을 가 지고 있다. 자연 솔루션 언어(NSL)는 자연어와 유사한 방식으로 기계와 통신함으로써 프로그래밍 언어를 효과적으로 대체할 것이라고 주장된다. 자연 솔루션 언어(NSL)가 혁신적인 기술적 효과를 유발하려면, 컴퓨터로 구현된 방법을 적 용해야 한다. 이 방법은 상황에 따라 개체와 그 관계에 대한 민감한 접근 방식을 필요로 한다. 개체와 그 관계 는 서로 다른 변형으로 나타나며 이러한 변형들 각각은 적절하게 정의되고 처리되어야 한다. NSL의 작동을 잘 이해되도록 설명하기 위해 다음 단계를 수행했다: a) 모든 관련 NSL 용어 목록이 제공된다. NSL을 더 잘 이해하기 위해서는 NSL의 특정 컨텍스트에서 이해해야 한다. b) 각 용어가 적절하게 정의되고 설명 된다. c) 용어들이 도면에 의해 적절하게 지원된다. 개별적인 도면들이 적절하게 맞도록 하는 통합 수준의 도면 은 거의 제공되지 않았다. d) 용어는 필요한 경우 예를 통해 뒷받침된다. 솔루션 설계 : NSL의 컨텍스트에서, 솔루션 설계는 개체의 잠재적 상태를 개별적으로 설정하고 조합 개체 상태 를 설정하므로, 조합 개체 솔루션 상태에 대한 액세스는 작동 시 일련의 통제된 변경을 통해 발생한다. 개체 : 개별적인 것은 어느 것이나 개체가 된다. 즉, 고유한 지위를 가지고 있고 정보로 표현할 수 있는 것이 개체이다. 언어에서 개체는 단어, 기호 또는 숫자로 표시된다. 예: 자동차가 개체가 될 수 있는 것처럼 모래 알 갱이도 개체가 될 수 있다. 차별화된 개체 : 개별적이면서 동시에 다른 개체와 다른 것이 차별화된 개체이다. 즉, 일부 다른 개체와 비교할 때, 다른 것이다. 자연어에서 이들은 단어로 표현된다. 예를 들어, '펜'은 '종이'와 다르다. 차별화되지 않은 개체: 개별적이고 도한 일부 다른 개체 또는 개체들과 동일한 것은 다른 개체 또는 개체들에서 차별화되지 않은 것으로 간주된다. 이러한 '반복'은 시공간에서 발생한다. 이들 반복은 수학 영역에 속하며 숫 자로 표시된다. 솔루션 설계 관점에서, 하나의 개체가 결과에 영향을 주지 않고 일부 다른 개체로 효과적으로 대체될 수 있는 경우, 해당 개체는 공간 또는 시간에서 반복되는 것으로 간주된다. 예 : 탁자 위에 펜과 종이가 있으면, 우리는 탁자 위에 \"펜과 종이가 있다\"라고 말한다. 그런데, 탁자 위에 펜이 하나 있고 또 다른 펜이 있 으면 \"탁자 위에 펜이 두 개 있다\"라고 말한다. 세계가 작동하는 방식(Way World Works; WWW) 원리: 전형적인 기술보다는, NSL은 솔루션 아키텍처의 새로운 패 러다임을 생성하는 과학과 기술의 이해가 혼합된 것이다. WWW는 우주나 자연이 오늘날의 과학이 이해하고 인식 하는 방식으로 기능하는 방식을 안내하는 원칙이다. NSL 로직은 세계가 작동하는 방식에 대한 모든 과학적 통찰 력을 활용하고 인간 에이전트가 컴퓨터를 사용하여 찾는 솔루션과 관련하여 특정 혁신적인 방법론을 제공한다. 예: 모든 것들이 입자들로 구성되어 있고, 입자들이 결합하면 새로운 속성이 생기고, 모든 일이 시공간에서 일 어나고, 모든 사건은 에너지에 의해 주도된다는 등이 세계가 작동하는 방식의 원리이다. 이들은 차례로 에이전 트가 하는 일과 이들이 지시된 변화를 통해 원하는 상태에서 다른 상태로 이동하는 방법에 영향을 준다. 잠재적 개체 대 비잠재적 개체: 솔루션 설계는 개체 및 이들의 관계를 포함한다. 이러한 개체는 솔루션 설계의 컨텍스트에서 실제 세계에서 선택된다. 솔루션에 관련하여 보유하고 있는 잠재성을 위해 선택된 것들을 '잠재적 개체'라고 한다. 솔루션 관련 '잠재적 집합'에 포함되지 않은 항목은 제외되며 솔루션 생태계의 관점에서 관련 성이 없다. 잠재적 개체 상태: 솔루션 생태계는 '잠재적 개체'라고 하는 '솔루션 설계자'가 '실제 세계'에서 '솔루션 세 계'로 선택한 정보 개체로 구성된다. 이는 '중요한 개체' 또는 '적격 개체' 또는 솔루션 생태계에 '영향을 미칠 수 있는 잠재성'이 있는 개체이다. 즉, '잠재적 개체'가 존재할 수 있거나 솔루션 생태계에 존재하도록 허용될 수 있지만 실제로는 존재하지 않는다. 예: 한 사람이 클럽의 회원으로 입회 되었다. 회원이 클럽에 참석할 가능 성이 있다. 회원의 출석은 클럽 회원권이 있는 경우에만 가능하다. 회원은 특정 시점에 클럽에 출석할 수도 있 고 없을 수도 있다. 부재 시 회원은 '잠재적' 상태이고, 참석 시 회원은 '현실' 상태가 된다. 현실-개체-상태 : 현실 상태는 개체가 개별적으로 또는 조합 형태로 존재할 수 있고 존재하는 상태이다. 예 : 클럽에 참석할 자격이 있는 클럽의 회원이 나타난다. 솔루션 생태계 : 솔루션 설계자는 '실제 세계'에서 잠재적 개체를 선택하고 사용하여 이들 간의 관계를 설정한 다. 잠재적 개체 간의 관계는 확립된 변화 경로를 따라 솔루션을 가질 수 있는 방식으로 결합하고 상호 작용하는 것과 같다. 전능적 개체 : 이들은 '자립 개체' 상태만 부여되는 가장 일반화된 또는 '차별화되지 않은' 개체이다. 예 : '방'은 개체이고 '열쇠'는 개체이다. 전능한 형태로, 이들은 두 개체로 간주된다. a. 개체는 점점 더 많은 개체와의 조합이 발생함에 따라 차별화된다. 예 : 한 사람이 일반화된 상태에 있으며 70 억 인구 및 이제껏 살았던 사람들 중 한 명이다. 이 개체 사람이 속성과 공간, 시간, 피부색, 인종과 같은 다른 개체들과 결합됨에 따라 사람은 점점 더 차별화된다. b. 솔루션 생태계에서, 모든 개체가 일반화된 전능적 수준에 있을 때, 가질 수 있는 모든 것은 솔루션 생태계에 참여한 총 개체의 수이다. 이것은 세포가 차별화되기 전의 세포의 상태와 유사하다. 독립 개체 : 이들은 이진 사건이 발생하는 수준의 개체이다. 즉, 잠재성과 현실 사이의 전환이 발생하여 이들이 참여하는 조합 개체 상태의 변화를 초래한다. 예 : 펜이 존재하게 되거나 사라질 수 있다. 독립 개체 사건이 발 생하면, 그것이 속한 조합 생태계의 상태를 변경할 수 있다. 종이와 함께 잠재적 개체로 존재한다면, 이들은 함 께 22 개 또는 4 개의 잠재적 조합 상태를 유발할 수 있다. 그러나, 독립 개체는 또한 그 속성 (종속 개체)을 함께 드래그하고 사건이 그 속성 레벨에서 발생하는 경우 여 러 방법으로 추가로 수정될 수 있다. a. 암묵적 개체 : 많은 경우, 다른 개체에 연결된 개체는 암묵되고 무시된다. 예: 사람이 거리에 들어가면, 이 것은 그가 입는 옷과 관련하여 그곳에 있다는 것을 의미한다. 옷은 암묵적인 것이다. 마찬가지로, 인간 에이전 트가 숨을 쉴 수 있는 공기가 있음을 의미하다. 객실 예약의 경우, 정보 입력을 위한 '에이전트'의 존재는 암묵 될 수 있다. 솔루션 설계자는 이러한 암묵적 개체가 주어진 것으로 간주한다. 대부분의 경우 속성들이 내포된다. 모든 변경은 '변경 유닛'(CU) 내에서 발생한다. 변경은 물리적 상호 작용이 공간과 시간에서 발생할 때만 발생한다. 하나의 독립 개체의 공간과 시간을 알고 있다면, 다른 개체의 공간과 시간 속성이 암묵될 수 있 다. 솔루션 설계자의 경우, 이러한 속성을 지정하지 않으면 설계의 본질이 변경되지 않아 설계자가 이를 지정하 지 않을 수도 있다. b. 동결된 개체 : 솔루션 아키텍처/설계는 통제된 차별화의 원칙을 기반으로 한다. 솔루션 설계자가 솔루션에 참여할 잠재적 개체로 개체를 선택하면, 선택한 개체는 이미 매우 차별화된 상태에 있다. 인간 에이전트 수준에 서, 모든 독립된 개체는 이들 중 각각의 것이 수조 개의 입자 (원자 또는 아원자 입자)로 구성되어 있기 때문에, 이미 고도로 차별화된 상태에 있다. 이들은 솔루션 설계자가 잠재성 또는 현실의 이진 상태로만 간주하 므로 동결된 개체로 간주된다. c. 개체 삭제 : 독립 개체 또는 조합 개체가 '현실 상태'에서 '잠재적 상태'로 전환될 때 삭제된 것으로 간주된 다. d. 개체 생성 : 독립 개체 또는 조합 개체가 '잠재적 상태'에서 '현실 상태'로 전환될 때, 생성된 것으로 간주 된다. e. 개체 수정 : 독립 개체가 그 종속 개체 변경에 값을 가질 때, 개체는 수정된 상태에 있는 것으로 간주된다. 중요한 동결 상태의 변경은 개체가 삭제되고 새 개체가 생성되는 결과를 초래한다. 예 : 막대가 구부러져 팔찌 가 된 경우, \"막대\"는 삭제된 것으로 간주하고 \"팔찌\"는 생성된 것으로 간주해야 한다. 속성 : 속성도 하나의 항목이지만 그 존재를 위해 다른 항목에 종속하는 속성이다. 이러한 종속 개체를 명시적 으로 속성이라고 한다. 종속성은 다른 독립 개체의 존재로 인한 하나의 개체의 존재로서 정의된다. 예 : 펜은 공간과 시간에 존재할 수 있다. 여기서, 공간과 시간은 속성 또는 종속적인 개체로 간주되다. \"공간 단위\" 또는 \"시간 단위\"는 자체적인 개체라고 할 수 있다. 상위 레벨 개체에 종속되므로, 이들을 속성이라고 한다. 펜이 삭 제되면, 속성은 자동으로 삭제된다. 속성의 유형 : 속성에는 세 가지 유형이 있다. a) 필수 속성: 개체와 관련하여 항상 존재하는 속성이다. 예 : 공간, 시간, 신원, ID, 로직, 사용자 인터페이스 (UI) 등; b) 표준 속성: 솔루션 환경의 특성에 따라 표준화된 속성이다. c) 일반 속성: 개체가 솔루션 환경 내에 배치되는 상황을 기반으로 솔루션 설계자가 사용하기 위해 선택한 속성이다. 속성의 레벨 : 속성이 존재할 수 있는 레벨의 수에는 제한이 없다. 제 1 레벨은 '일차 속성', 제 2 레벨은 '이 차 속성', 제 3 레벨은 '삼차 속성' 등과 같다. 예: 제 1 레벨에서 인디아로 공간이 정의된 경우, 각 주가 2 차레벨에 있고, 각 도시는 제 3 레벨에 있다. 실제 개체 : 에이전트 및 에이전트가 현실을 표현할 목적으로 생성하는 인공 표현 개체와 관계없이 자연 (실 제)에 물리적으로 존재하는 개체. 표현 개체 : 표현 개체는 에이전트에 의해 생성되어 다른 실제 개체 또는 다른 표현 개체를 효과적으로 나타낼 수 있다. 표현 개체는 그들이 대표하는 실제 또는 다른 표현 개체로부터 가치를 도출한다. 표현 개체는 실제 개 체와 마찬가지로 물리적이다. 즉, 공간과 시간에 존재한다. 일반적으로 말해서, 그들이 대표하는 개체에 비해 훨씬 낮은 레벨의 차별화가 있다. 예 : 펜은 1024 개의 원자로 구성될 수 있는 반면 '단어 펜'을 구성하는 원자 는 백만 배 더 적은 원자를 가질 수 있다. 본 명세서에서는 두 가지 유형의 표현 개체가 있다: 지각적 및 정보 적. 지각적 개체 : 지각적 개체는 임의의 신경 상태의 형태로 자신의 뇌에서 자연적으로 인간 에이전트에 의해 생성 된다. 자연은 진화 과정을 통해 뇌가 현실 세계의 개체 - 다른 에이전트와의 통신을 위해 생성한 실제 개체 또 는 정보 개체를 표현하도록 설계했다. 두뇌는 이러한 표현 개체를 저장, 처리 및 검색할 수 있으며 - 감각은 이 들 표현 개체를 입력하는 데 도움이 되며 신체는 의사 소통을 통해 이를 다른 에이전트에게 전파하는 능력을 갖 는다 정보적 개체 : 정보적 개체는 자신이 소유하고 있는 표현 개체를 생태계의 다른 에이전트와 통신할 목적으로 인 간 에이전트에 의해 인위적으로 생성된 개체이다. 진실 값 : 표현 개체가 '실제 개체' 또는 '기타 표현 개체'를 나타내는 것으로 알려져 있지만, 진실 값은 본질 에 내재된 불확실성이나 인간 에이전트의 이해, 동기 또는 의도를 포함한 여러 요인으로 인해 달라질 수 있다. 예: \"X\"가 \"Y\" 위치에 있다고 표현할 수 있지만 올바른 진술일 수도 아닐 수도 있다. 맞으면 \"참\"으로 간주하고 부정확하면 \"거짓\"으로 간주된다. 정보 콘텐츠-실제 개체 대 표현 개체: 이론적으로는 현실 세계의 모든 개체가 예외 없이 정보적 개체로 표현될 수 있다는 간단한 원리를 따른다. 이것은 정보로 표현될 '실제 개체'에 대한 충분한 지식을 전제로 한다. 그 지 식을 감안할 때, 이론적으로 모든 개체는 정보 개체로 표현될 수 있을 뿐만 아니라, 정보 내용도 정보 비트로 측정될 수 있다. '실제 개체'를 나타내는 '대표 개체'에 대한 정보 내용이 무엇인지에 대한 의문이 제기된다. 일반적으로 말해, 표현적 개체의 정보 내용은 매우 낮다. '실제 에이전트'의 정보 콘텐츠는 270 비트 이상의 정 보에 도달할 수 있지만; 해당 에이전트의 이름은 '실제 에이전트'를 효과적으로 나타내기 위해 단지 몇 비트의 정보만을 필요로 한다. '실제 개체'에 내재된 모든 정보가 '표현 개체'로 표현되는 것은 아니고, 당면한 목적을 위해 실제 개체를 효과적으로 표현하는 데 충분한 정보만 사용된다. 최적화 원칙에 따라, 차별화와 통합 사이에 서 균형을 이루는 에이전트에 의한 정보 사용에는 엄청난 경제성이 있다. 물리적 현실 : 모든 개체 (실제, 지각적 및 정보적 개체)는 물리적 세계에 '물리적으로' 존재한다. 실제 개체와 관련하여 이러한 결론에 도달하는 것은 직관적이지만, 지각 및 정보 개체도 공간과 시간이라는 물리적 현실에 존재한다는 사실을 분명히 알아야 한다. 그들이 표현 개체인 것으로부터 가치를 도출한다는 사실은 물리적인 존 재의 성격을 바꾸지 않는다. 변경 드라이버 : 변경 유닛의 변경을 가져오는 개체 및 그 속성들을 변경 드라이버라고 한다. 속성도 개체이지 만, 이들은 독립적 개체에 종속된다. 상술한 바와 같이, 독립적 개체를 더욱 차별화하는 속성의 레벨 수가 있을 수 있다. 각 드라이버는 고유하고 개별적인 ID 및 고유 정보를 가지고 있다. 변경 유닛 (CU) : 변경 유닛은 자연어 관점에서 의도 진술에 의해 설명되는 것이다. 모든 종류의 가치는 통제된 변경을 통해서만 발생하며 변경 유닛 내에서만 발생한다. 인간 에이전트가 원하거나 의도하는 글로벌 변경 유닛 에 도달하는 것은 로컬 변경 유닛을 함께 짜맞추는 것에 의한다 (문장을 결합하여 단락 만들기). 단순성을 위해, NSL에서는 이러한 변경 유닛을 의도 진술(statement-of-intent; SI)과 동의어로 취급한다. 따라, 본 명세 서에서 CU와 SI를 서로 바꿔서 사용할 수 있다. 로컬 의도 진술은 자연어 측면에서 의도 진술(문장)로 표현되는 로컬 '변경 유닛'이다. 글로벌 의도 진술은 자연어 측면에서 글로벌 의도 진술(문단)로 표현되는 '글로벌 변경 유닛'이다. '정보 기술'은 정보 용어로 세계의 모든 개체를 표현할 수 있는 능력이 있음을 알 수 있다. 이것이 변경 유닛에 서 일어나는 일이 의도 진술에서 완전히 포착되는 방법이다.변경 유닛 (CU)의 크기 : CU의 크기는 의도된 CU에 도달할 목적으로 CU 내에서 'CU 수의 증가' 또는 '독립 개체 (변수) 수의 증가' 사이의 적절한 균형을 이루어 최적화된다. 예 : 이론적으로 CU의 수를 무한대로 늘릴 수 있 다. 집에서 공항까지의 여행은 CU가될 수 있다. 공항에 도착할 때까지 한 교차로에서 다른 교차로로의 각 이동 이 CU가 될 수 있다. 자동차 바퀴의 각 회전도 CU가 될 수 있는 식이다. 그러나 그것은 복잡성과 이를 처리할 능력이 부가시킨다. 반대로 CU의 크기가 증가하면, CU 내의 변수가 증가하게 되어 CU 내에서 변수 상태가 극적 으로 증가하게 되어 복잡성이 더욱 커진다. 인디아의 집에서 미국의 특정 외딴 곳으로 이동하는 것은 변화 단위 가 될 수 있다. 그러나 그러한 변화는 너무 많은 개체 (변수)를 소비하여 다루기가 어렵다. 이 CU에 관련되는 개체의 수가 너무 많아서 이들의 조합이 시스템을 매우 복잡하게 만든다 (자동차, 항공기, 호텔, 여권, 비자 및 모든 속성과 같은 개체가 너무 많게 된다). 두 경우의 복잡성을 고려하여, 설계자는 최적화 원칙을 적용하여 두 극단 사이의 균형을 맞춘다. CU는 '의도 진술'으로 표시되며 솔루션 설계 목적 상 이와 동의어인 것으로 간주된 다. 사건 : 모든 사건은 하나의 로컬 의도 진술 등에 도달하고 모든 사건은 하나의 상태에서 다른 상태 - 즉, 잠재 적 상태에서 현실로 또는 그 반대의 경우로 전환되는 것에 관한 것이다. 개별 개체가 LSI에 도착하거나 LSI로부 터 출발하는 방식으로 사건이 발생하면 조합 세트의 상태가 전체적으로 변경된다. LSI에 6 개의 가변 개체가 있 는 경우, 조합 개체가 존재할 수 있는 64 개의 서로 다른 상태가 있을 수 있다. 개별적 개체 레벨에서 이진 상 태가 변경되면 LSI의 64 개 상태 중 하나로 이어질 수 있다. 63 개의 다른 상태가 비 트리거 조합 개체 상태에 있을 수 있지만, 64 번째 상태는 다른 LSI 상태 또는 자체에 영향을 미치는 트리거 상태에 있게 된다. 이진 상태 : NSL 솔루션 설계에서, 모든 개체 상태는 이진 상태에서만 존재하는 것으로 표현된다. 즉, 그들은 잠재적 또는 현실 상태에 존재한다. 모든 상태는 이산적이며 중간 상태가 없다. 이러한 관점에서, 각 단어는 이 진 상태로 작동하며 문장과 문단도 이진 상태로 존재한다. 에이전트는 개체를 보는 유리한 지점만 계속 변경한 다. 확대하거나 축소하면서, 유리한 지점이 변경되지만, 각 유리한 지점은 이진 상태에 있다. NSL 솔루션 설계 에서 이진 상태를 선택하는 것은 디지털 대 아날로그를 선택하는 것과 유사하게, 이산 상태와 연속 상태에 대한 선택이다. 사건이 발생하면, 중간 상태를 제외하고 상태 전환이 있게 된다. 이론적으로 이러한 이진 상태는 '참 또는 거짓' 값을 할당하여 나타낼 수도 있다. 가변성 : 대부분의 개체가 이진 상태로 존재하는 것이 일반적으로 바람직하며, 가변성은 이러한 상태 사이에서 만 존재한다. 가변성은 다음 두 가지 이유로 더 높을 수 있다. 첫째, 더 높은 유리한 지점에서, 모든 하위 집합 개체 값은 함께 조합 개체 상태의 수와 가변성을 증가시킬 수 있다. 예 : 하위 집합 개체가 10 개인 경우, 변동 성은 210 또는 1024가 된다. 둘째, 단순성을 위해 여러 이진 상태의 조합을 통해 여러 상태를 표현할 수 있지만, 시스템은 필요한 경우 정보로 차별화 사다리의 마지막 단계에서 함께 언급되는 많은 상태를 제공한다. 예 : 사 람이 특정 도시에 있는 동안, 이 사람은 백만 개의 공간 좌표 지점 중 하나에 있을 수 있다. 상수 : 상태가 항상 동일하게 유지되는 개체는 상수로 간주된다. 예: 빌드의 존재가 관련 기간 동안 상수로 간 주되면, 이것은 상수로 간주된다. 입력 : 본질적으로 LSI에 관한 사건이다. 이는 인간 에이전트에 의해 시스템에 공급되거나 기계 에이전트에 의 해 촉진되는 사건이다. 예 : 하루 중 시간을 입력하거나 기계 에이전트 피드를 기반으로 하여 시스템에 의해 직 접 캡처한 인간 에이전트. 입력은 기존 개체를 잠재적 또는 현실 상태로 전환하거나, 대안으로 생태계에 새로운 개체를 도입하거나 개체 적격 프로세스를 통해 생태계에서 기존 개체를 삭제하는 형태일 수 있다. 입력 소개는 일반적으로 에이전트가 소유한 '결정권'을 기반으로 하여 에이전트에 의해 행해진다. 출력 : 이들은 본질적으로 하나 이상의 다른 LSI 또는 그 자체의 LSI에 의해 야기되는 사건이다. 경과 시간 : 설명된 바와 같이, 트리거 상태가 의도 진술에서 달성될 때, 그것은 자신의 의도 진술을 포함하는 하나 이상의 의도 진술에서 하나 이상의 변경을 촉진한다. 모든 변경에는 '경과 시간'이라고 하는 시간이 걸린 다. 변경이 인간 에이전트이든 기계 에이전트이든 관계없이, 경과 시간은 항상 관련된다. 어떤 경우에는, 이러 한 변경은 몇 초 만에 발생할 수 있으며, 다른 경우에는 시간이 몇 시간 또는 며칠이 걸릴 수 있다. 필요한 변 경을 생성하는 상호 작용에 관련된 모든 개체는 경과 시간 동안 점유되고 이전 작업이 완료된 후에만 다른 트리 거에 참여할 수 있게 된다. 솔루션의 전체 수명 주기 : 모든 로컬 및 글로벌 의도 진술과 관련하여 프랙탈과 같은 자기 유사성이 있다. 이 러한 대칭성과 패턴의 반복은 모든 가치 창출 활동과 방향성 변경과 관련하여 나타난다. 시스템은 환경을 '감지'하고, 동일한 환경에서 '선택'하고, '조치'하는 기능을 제공하기 위한 것으로, 이를 'SSA' 주기라고한다. NSL은 모든 솔루션 뒤에 있는 전체 수명 주기의 존재를 높이 평가하고 이를 효과적으로 처리한다. 이 시 스템은 먼저 '감각' (인간의 감각이 하는 것과 동일), 가능성에서 하나 이상의 개체를 '선택'하고 (인간의 마인 드가 하는 것과 동일), 하나 이상의 선택된 개체에 대해 '행동' (인체가 하는 것과 동일)인, 모든 변경과 관련 하여 모든 가능성을 제공한다. 솔루션 요구 사항의 전체 수명 주기의 본질은 이후에 설명하는 '에이전트 기능' 의 존재를 야기한다. 자연어 : 자연어가 작동하는 방식은 각 단어가 동일한 언어를 사용하는 사람들만 인식하는 코드와 같은 것이다. 문장은 변경 유닛을 처리하기 위해 문법의 범위 내에서 단어를 결합하여 구성된다. 문장을 추가로 배열함으로써 자연어는 복잡한 현실을 전달할 수 있는 능력을 생성한다. 자연어는 현실과 연결된 코드의 한 형태이다. 코드는 특정 방식으로 단어와 문장을 결합하여 작동한다. 하나의 코드 개체가 다른 코드 개체와 결합될 때마다, 차별화 된 결합 코드 개체가 생성된다. 각 조합은 가능성의 스펙트럼에서 선택한 결과이다. 이러한 조합의 캐스케이드 는 차별화 원칙에 따라 고유한 조합을 만든다. 프로그래밍 언어와 마찬가지로 자연어는 목표를 달성하기 위해 차별화 원칙에 의존한다. 프로그래밍 코드를 자연어로 대체하는 것은 NSL이 '자연어 구조' 뒤에 있는 잘 테스트 된 기본 원칙의 사용을 통해 가져오는 패러다임 전환이다. 코드 대 자연어 : 코드는 동일한 것을 해독하고 이해할 수 있는 능력을 가진 에이전트에 의해서만 이해되는 표 현 개체이다. 프로그래밍 코드는 컴퓨터에 기능을 전달할 수 있는 코드이다. 코드의 의미와 응용 프로그램은 프 로그래머의 영역 내에 있다. 이 코드를 사용하여 응용 프로그램 로직을 컴퓨터에 전달한다. 자연어도 코드의 한 형태이다. 이것이 영어를 사용하는 사람들이 러시아어를 사용하는 사람들을 이해하지 못하거나 그 반대로 이해 하지 못하는 이유이다. NSL이 하는 일은 응용 프로그램 로직을 컴퓨터에 전달하는 능력을 자연어에 가깝게 가져 오는 것이므로 더 이상 별도의 코드 작성자를 가질 필요가 없다. 사용자는 NSL을 사용하여 사용자 인터페이스 수준에서 직접 동일하게 처리할 수 있다. 자연 솔루션 언어 (NSL) : 이것은 약간 수정된 자연어의 수정 버전, 컴퓨터로 구현된 방법으로, 여기에서 의도 의 진술만을 포착하고 모든 서술적 진술을 의도 진술에 종속되게 만드는 형태로 사물이 재구성된다. 이들 의도 진술은 두 가지 상태로 존재한다: 정적 의도 진술 : 이것은 의도를 표현하기는 하지만 현실로 변환하는 능력이 부족하다. 정적 개체 상태는 다른 상태에서 변경을 트리거할 수 있는 속성이 없는 개체 상태이다. 시스템에 6 개의 변수가 있는 경우 (독립 개체 및 해당 속성), 이들은 잠재적으로 64 개의 상태에 존재할 수 있다. 그러나 모든 변수가 '현실' 상태에 있을 때 64 번째 상태만이 변화를 유발할 수 있다. 다른 모든 개체 상태를 '정적 개체' 상태라고 한다. 이 점에서 주목 해야 할 점은 의도 진술(SI)이 원하는 변경의 특성을 설명하는 또 다른 독립적인 개체로, '변경 유닛'에 참여한 다는 것이다. SI의 존재는 후속 조치로, 에이전트의 의도에 의해 백업되어야 한다는 사실에 기인한다. 동적 의도 진술: 이것은 독립 개체 레벨에서 사건의 영향을 받는 것과 같이, 트리거 조합 개체 상태라고 하는 특정 원하는 상태에 도달할 때 집합적으로 트리거하는 의도 진술 뒤에서 개체를 유발하는 기본 변환이다. 동적 개체 상태는 자신을 포함하여 하나 이상의 개체 상태를 추가로 변경할 수 있는 기능이 있는 개체 상태이다. 이 전 예에서, 64 번째 상태는 '동적 개체' 상태이다. 즉, 정적 의도 진술이 동적이 되고 의도 진술을 이행하기 위 해서, 트리거 CES에 의해 전원이 공급되어야 한다. 자연어 대 NSL : 자연어에서 사건은 문자별 및 단어별로 순차적으로 발생한다. 그러나, NSL에서 잠재적 개체는 설계자에 의해 먼저 단어별 문장별로 작성된다. 사건은 단락 전체의 단어 수준 또는 구문 수준에서 발생하지만 반드시 순차적으로 발생하지는 않는다. 그러나, 사건은 컴퓨터에 의해 구현되는 NSL 로직 또는 문법 또는 규정 된 방법의 범위 내에서 발생한다. 자연어는 기술 프로그래밍 언어 대신 자연어를 사용하여 컴퓨터의 응용 프로 그램 로직을 코드화한다. 이제 사용자는 기술에 의존하지 않고 보다 쉽고 효율적으로 애플리케이션 로직을 구축 하거나 사용할 수 있다. 이 과정에서 복잡한 프로그래밍 코드 형태의 추상화 계층이 제거된다. 의미 대 가치 : 자연어에서, 정보 차별화는 의미 전달을 초래한다. 하나의 단어 시퀀스는 다른 단어의 시퀀스와 비교할 때 하나의 의미를 전달한다. NSL 문맥의 값은 '솔루션' 또는 '의도 상태의 이행'(글로벌 의도 진술)과 동의어로 사용된다. 일련의 차별화된 단어가 자연어에서 의미를 전달하는 것처럼, 일련의 차별화 개체는 가치 또는 '의도 진술의 이행'으로 이어진다. 가치의 정량화 : 모든 변화는 독립 개체 수준에서 발생하여 조합 개체 상태가 된다. 이러한 변화는 사건을 통해 발생한다. 사건은 잠재적 상태에서 현실 상태로 또는 그 반대로 전환하는 것이다. 모든 의도 진술은 변경 트리 거가 발생하기 위해 현실 상태에 도달하기 위해 모든 독립 개체를 필요로 한다. 이것은 실현될 로컬 의도의 진술을 위해 현실 상태로 전환하는 독립적이고 연관된 속성의 개수를 명확하게 설정한다. 또한 각 글로벌 의도 진 술에는 주어진 수의 정량화 가능한 누적 개체 현실 상태가 필요하다는 것도 증명한다. 정보가 '비트' 수로 정량 화될 수 있는 것처럼, 이진 개체 상태의 수를 통해 값을 정량화할 수 있다. 가치의 상대성 : 한 에이전트에게 가치있는 것이다른 에이전트에게는 가치가 없을 수 있다. 가치있는 것은 그 가치를 추구하는 에이전트에 상대적이다. NSL에서 각 단락은 글로벌 의도 진술을 전달하는 에이전트와 관련하여 글로벌 가치 단위를 나타낸다. 우리는 이것을 가치 소비라고 부른다. 가치 소비자의 관점에서, 로컬 의도 진술 은 가치 창출자의 역할을 하는 다른 에이전트를 가질 수 있으며, 이러한 변화 단위는 가치를 가능하게 한다. 이 제 우리가 로컬 의도 진술에 관련된 에이전트로 관점을 전환한다면, 이 로컬 의도 진술은 글로벌 의도 진술로 변환된다. 로컬 의도 진술은 관련된 에이전트의 소비 요구를 서비스하는 단락에서 의도 진술의 마지막 이행이 된다. 상대적 가치에 대한 고려는 차별화 경로가 서로 교차되어 서로 다른 에이전트를 서비스하는 네트워크 구 조로 이어진다. 자연어와 NSL 간의 공통성 : 둘 다 차별화 원칙에 의해 주도되며 동의어 개체가 있다: a) 명사 : 이들은 NSL의 독립적인 개체와 유사하다. b) 형용사 : 이는 NSL에서 독립 개체를 한정하는 속성과 유사하다. c) 동사 : NSL의 의도 진술에 반영된 변경의 설명자이다. d) 부사 : NSL의 의도 진술에 포함된 동사를 한정하는 속성이다. e) 문 장 : 이는 NSL에서 필요한 지시된 변경을 유발할 수 있는 모든 잠재적 개체로 구성된 의도 진술과 유사하다. f) 단락 : NSL 솔루션 설계 관점에서 단락은 일련의 통제된 변경을 통해 의도 진술의 이행으로 이어질 수 있는 많 은 의도 진술로 구성된다. 전체 단락은 글로벌 의도 진술로 간주된다. 로직의 단락 : NSL은 모든 개체에 대한 일부 '필수 속성'에 의존한다. 공간과 시간과 마찬가지로, NSL 개체의 필수 속성 중 하나는 개체 상호 작용을 정의하는 '로직'의 사양이다. 각 개체는 '로직 대응물'을 지정해야 한다. 이 로직 대응물을 각 글로벌 의도 진술에 대한 단락을 정의하는 로직에 참여한다. 이에 따라 에이전트에 대한 글로벌 의도 진술이 생성될 때마다, 해당 의도에 대한 로직 단락을 찾는다. 그런 다음 '로직의 문단'을 사 용하여 자신만의 맞춤형 잠재적 문단을 만든다. 마찬가지로, 이 새로운 문단에 참여하는 각 개체는 로직의 문단 에서 대응물의 역할을 수행한다. NSL 라이브러리 : NSL은 모든 잠재적 개체 및 그 관계를 캡처하는 모든 솔루션의 줄임말이다. 이것은 가장 단순 한 수준에서 가장 복잡하고 차별화된 수준의 잠재적 개체 라이브러리를 생성한다. 이러한 라이브러리는 다양한 솔루션 환경을 포괄할 수 있다. 그 후, 검색 및 드래그 앤 드롭 기술을 사용하여 최소한의 추가 노력으로 잠재 성을 가진 개체를 재사용할 수 있다. 재사용 가능한 구성 요소 : 다양한 유리한 지점에서 기존 개체를 사용하여 솔루션 로직을 구축할 때 중복성을 최소화하는 능력은 구성 요소의 재사용에 관한 것이다. 이들은 NSL이 구축한 라이브러리에서 사용할 수 있는 재 사용 가능한 개체 구성 요소이다. 차별화 원리 : 인간 존재의 수준에서 모든 개체는 조합 상태로만 존재하며 고도로 차별화된다. 먼지 입자가 수 조 개의 원자를 운반하며 자체 구조를 가지고 있다. 다른 것들은 동일하게 남아 있으며, 가능성의 배열에서 선 택된 독립 개체가 기존 조합 개체 상태와 결합할 때마다, 결과 조합 개체 상태는 더욱 차별화된다. 이것이 차별 화의 원리이다. 그 반대는 독립적 개체 값이 무시되어 비차별화 또는 일반화 또는 통합화를 초래할 때 발생한다. 개체의 부가는 차별화이고 개체의 감산은 통합이다. 원리는 미적분학의 미분 및 적분과 다소 유사하 다. 예 : 조합 개체 상태 'A-B-C'가 있고, 독립 개체 'D'를 추가하면, 결과적인 조합 개체 상태는 개체 'D'의 추가로 인해 발생하는 A-B-C의 차별화 형태인 'A-B-C-D'이다. 'D' 값이 무시되는 경우, 조합-개체-상태가 여전 히 남아있는 동안, 비차별화가 발생하여 'A-B-C'와 'A-B-C-D'는 이제 동일한 값을 가지며 '두 개의 A-B-C'로 계 산된다. 인간 에이전트에 도움이 되거나 해로운 차별화 또는 통합 (일반화) 및 에이전트에게 애그노스틱한 것들이 있을 수 있다. 솔루션 아키텍처의 목적을 위해 정보 개체는 실제 개체 또는 기타 정보 개체를 나타낸다. 솔루션 설계 의 모든 개체는 독립적이든 조합적이든, 잠재적 또는 현실의 이산 (동결) 이진 상태에 존재하는 것처럼 처리된 다. 이러한 이진 개체는 새로운 결합 개체 상태를 생성할 때마다 다른 이진 개체와 결합된다. 설계는 이러한 새 로운 결합 상태를 각각 이진 상태에 있는 것으로 취급한다. 모든 조합 개체 상태는 하나의 변경 유닛 또는 다른 변경 유닛의 생태계 내에 존재하며, 이는 NSL의 로컬 의도 진술과 동일하다. 에이전트는 '차별화' 및 '통합'(일반화) 모두에 능숙하다. 차별화할 때에는 다른 것들은 동일하게 유지되고 더 많은 정보를 소비한다. 일반화하 때는, 정보를 더 적게 소비한다. 둘 사이의 균형은 생존에 중요하다. 뇌의 능력은 제한되어 있기 때문이다. 값을 무시하게 되면, 일반화 또는 통합으로 이동할 수 있는 능력을 갖는다. 모든 개체가 존재하는 것으로 인식 되지만 모든 값이 무시되면, 한쪽 끝에 개체 수만 있는 가장 통합적 상황을 갖게 된다. 그러나 다른 한편으로 모든 개체를 차별화하게 되면, 모든 개체가 가장 차별화된 상태에 있게 되는 차별화 트리의 다른 쪽 끝으로 이 동하게 된다. 흥미롭게도, 하나의 '변경 유닛'의 조합 개체 상태가 해당 '변경 유닛'의 조합 개체 상태를 변경하여 다른 '변 경 유닛'를 변경하는 경우, 새로운 상태는 이전 조합 상태와 결합되어 일련의 변화를 만든다. 자연어 관점에서 볼 때, 이들은 문장을 함께 묶어 단락을 형성하는 것과 같다. NSL 관점에서, 각 변경 유닛은 글로벌 의도 진술 을 형성하기 위해 결합하는 로컬 의도 진술과 동일하다. 유리한 지점 : 각 기본 개체는 개별 레벨에서 이진 상태로 존재한다. 개체는 또한 결합하여 조합 개체를 형성한 다. 유리한 지점은 개체를 볼 수 있는 상대적 위치를 나타낸다. 더 높은 유리한 지점 (모든 하위 집합으로 구성 된 차별화 사다리의 더 높은 단계)에서 개체를 전체적으로 본다면, 연결된 개체 수가 상당히 많아진다. 반대로, 더 낮은 유리한 지점 (차별화 사다리의 더 낮은 단계)에 있는 개체를 본다면 연결된 개체 수가 훨씬 더 적어진 다. 예 : 차별화 방향에서 바라보는 더 높은 유리한 지점 'A'를 상상해 본다. 'A'는 차별화 하위 집합 'A-B'를 가질 수 있다. 이것이 'C'와 결합하면, 제 2 레벨의 더욱 차별화된 하위 집합 'A-B-C'를 갖는다. 'A-B'는 하위 집합 'A-B-C'만을 포함한다. 'A-B'는 'A'에 비해 차별화 방향으로 연결된 개체가 적다. 또 다른 방법은 높은 유 리한 지점 개체가 낮은 유리한 지점 개체에 비해 더 많은 정보를 전달하는 것이다. 방향성 : 이것은 개체 값의 추가 또는 개체 값의 삭제에 기초하여 차별화 트리를 위 또는 아래로 이동하는 것에 관한 것이다. 새로운 개체 값을 추가하면 양의 차별화 방향으로 이동하게 된다. 값을 삭제하면, 음의 차별화 방 향으로 이동하게 되고, 즉 '비차별화' 또는 '일반화' 또는 '통합'의 방향으로 이동한다. 조합 개체 상태(CES) : 독립 개체 (그들의 속성을 드래그하여 얻은)가 다른 독립 개체와 결합할 때, 이들은 차 별화되고 그들 자신의 새로운 속성을 가진 조합 상태를 만든다. CES는 문장과 동일한, 변경 유닛을 각각 나타내 는, 로컬 의도 진술(LSI)에 포함된다. 더 큰 원하는 변경으로 이어지는 이러한 LSI의 집합은 문단과 동일한, 글 로벌 의도 진술(GSI)라고 한다. LSI에서 CES의 크기는 참여하는 독립 개체의 수에 비례한다. 각 LSI는 2n 개 상 태를 포함하며, 이 때 'n'은 독립된 개체의 수이고, 각각은 '잠재적' 또는 '현실' 상태에서 존재할 수 있다. 기 본적으로, 각 로컬 의도 진술에는 두 가지 종류의 조합 개체 상태가 있다: 비 트리거 CES : 이것은 다른 로컬 의도 진술 또는 이들이 속한 동일한 LSI 내에서 조합 개체 상태에서 변경을 일으키지 않는 개체 조합이다. 예 : 이진 변수로 4 개의 독립 개체가 있는 경우, 이들은 24 개의 개체 상태, 즉 16 개의 CES를 생성한다. 이 상태 중 15 개 상태는 변경을 트리거하지 않으므로 비 트리거 CES가 된다. 트리거 CES : 이 조합 개체 상태는 하나 이상의 다른 LSI 또는 동일한 LSI 내에서 변경을 트리거한다. 트리거 CES는 모든 독립 개체와 그 속성이 현실 상태에 있는 것이다. 한 LSI의 CES가 다른 LSI의 CES에 영향을 미치면 해당 문장이 연결된다. LSI는 GSI 실현에 대한 참여에 따라 함께 그룹화되어 단락을 만든다. 예 : 이전 예에서 와 같이, 16 번째 상태는 4 개의 독립 개체가 모두 해당 상태의 현실 상태에 있기 때문에 트리거 상태이다. 함께 연결되는 독립 개체가 차별화된 조합 개체 상태를 발생시킨다는 것은 이미 언급하였다. 로컬 의도 진술이 함께 연결되면, 조합 개체 상태는 문단 수준에서도 차별화 원칙의 적용으로 더욱 확장된다. 이론적으로 단락은 챕터 또는 더 높은 수준의 추상화로 결합될 수 있다. API 대 프로그램 : 애플리케이션 프로그래밍 인터페이스는 우선 프로그래밍 코드와 유사한 방법을 사용하여 다 른 프로그래밍 솔루션에 액세스하는 것을 돕는다. NSL은 프로그래밍 언어에서와 동일한 방식으로 동일한 기능을 효과적으로 수행할 수 있는 방식으로 API 로직을 컴퓨터에 전달할 수 있다. 공유 개체 : 공유 개체는 많은 로컬 또는 글로벌 의도 진술에서 공통된 개체이다. 임의의 의도 진술에 대한 트 리거 상태의 일부인 독립적인 개체가 많이 있다. 의도 진술이 트리거 상태에 있으면, 트리거와 관련된 경과 시 간 동안 해당 개체는 다른 의도 진술과 관련하여 참여할 수 없다. 그러나 일단 트리거된 변경이 완료되면, 참여 개체는 모든 관련 의도 진술에서 공유 개체로 다시 사용 가능하게 된다. 변경의 경로 : 변경의 경로는 로컬 의도 진술 내에서 조합 개체 상태를 트리거하는 일련의 변경으로 형성되어, 글로벌 의도 진술의 이행으로 이어지게 한다. NSL 로직은 이러한 변화 경로를 제시한다. 프로그래밍 로직에서,한 상태에서 다른 상태로의 전환은 상이한 상황에서 다른 이름을 따르는 원칙을 적용하여 달성된다. 다음은 그 러한 예이다: a) 제약 : 많은 가능성 사이에서 이루어지는 선택에 대한 제약이 있다. NSL 로직에서는 동일한 결 과를 얻기 위해 차별화 원칙이 적용된다. 이것은 이는 선택이 이루어짐에 따라 변화의 시작점에서 '가능성의 집 합의 감소'에 불과하다. b) 규칙 : 대부분의 경우 상황에 민감한 시스템에 적용되는 일련의 제약이다. c) 알고 리즘 : 이는 '규칙'과 동일하지만 '정보 시스템'의 컨텍스트에서 자주 사용된다. 프로세스를 정보로 변환: NSL이 행하는 가장 극적인 것 중 하나는 프로세스를 정보로 변환한다는 것이다. NSL은 차별화 원칙에 엄격하게 의존하고 관련 변경 사항을 조합 개체 상태로 묶어 프로세스와 기능을 정보로 변환한다. 하나의 CES가 인과적 트리거를 통해 다른 CES에 영향을 미치면, 두 CES가 통합되고, 이는 '확장된 CES'라고 불린다. 모든 프로세스와 애플리케이션 로직을 정보 영역으로 가져 오는 것이 이러한 확장 CES이다. 정보로의 전환이 발생하면, 해당 개체는 다른 정보와 유사한 검색 원칙의 적용을 받는다. 정보를 정량화할 수 있는 것처럼 솔루션도 정량화할 수 있다. IT의 추상화 수준 : 정보 기술은 여러 수준의 추상화에 의해 주도된다. 이 추상화 사다리의 맨 아래 끝에는 0과 1의 이진 상태를 나타내는 전자기 상태가 있다. 다른 쪽 끝에는 사용자가 경험한 애플리케이션 로직과 솔루션이 있다. NSL은 프로그래밍 코드 수준을 기능과 같은 자연어로 효과적으로 대체한다. 에이전트 : 에이전트도 개체이다. 에이전트는 솔루션의 작성자이자 솔루션의 소비자이다. 에이전트는 목적에 따 라 움직이므로 '자연'과 구별된다. 즉, 그들은 유리한 변화를 추구하고 불리한 변화를 피한다. 모든 솔루션이 통제된 변경을 처리하므로, 모든 변경 유닛은 인간 에이전트든 기계 에이전트든지, 에이전트의 영향을 받는 것으로 가정된다. 모든 변화에는 에너지가 필요하기 때문에 에이전트는 고유한 에너지를 사용하거나 하나 이상의 조합적 개체에서 차용하고 미리 결정된 경로를 따르거나 자유 의지를 적용하여 변화 방향성을 제공한다. a. 인간 에이전트 : '이해 관계자'라고도 하는 인간 에이전트는 솔루션 환경에서 부과하는 요구 사항에 따라 여 러 역할을 수행한다. 일부 변경 유닛은 필요한 인간 에이전트에 의해 주도된다. 예 : 일부 '하드 자산'의 물리 적 전달에는 인간 에이전트가 개입해야 한다. i. 가치 창출자 : 모든 의도 진술 (변경 유닛)은 한 에이전트 또는 다른 에이전트가 주도한다. 이러한 의도 진 술 또는 '의도 진술과 연결된 에이전트'는 동일한 내용이 '로컬 의도 진술'과 관련이 있지만 '글로벌 의도 진술'과 관련이 없는 경우 가치 창출자로 간주된다. 모든 로컬 의도 진술 및 글로벌 의도 진술이 이들을 주도하 는 동일한 에이전트를 가지면, '창조자'와 '소비자' 기능에는 모두 동일한 에이전트가 포함된다. ii. 가치 소비자 : 글로벌 의도 진술 (의도 진술을 이행하는 진술)과 연결된 에이전트는 가치 소비자로 간주된 다. 이 GSI는 문단 끝에 있는 의도 진술에 있다. iii. 팀 : LSI의 변화가 공동으로 인간 에이전트에 의해 주도되는 경우, 하나 이상의 인간 에이전트가 존재한다. 이러한 팀 노력으로, 방향성에 대한 책임은 리더 또는 팀 구성원 간에 지정된 결정 권한에 따라 수행 된다. iv. 소유권 : 모든 개체의 소유권은 통제된 변경에 참여할 때 개체에 직접 또는 간접적으로 물리적으로 영향을 미치는 에이전트의 능력을 기반으로 한다. 물리적 영향은 본질적으로 똑같이 물리적이기 때문에 표현 개체를 포 함한다. 영향을 미칠 수 있는 능력은 에이전트에게 할당된 결정 권한에 따라 달라지는데, 즉, 영향을 받을 수 있는 권한도 있어야 한다. 정보 권한 자체는 에이전트가 영향력을 행사할 수 없는 경우에도 정보를 소유할 수 있는 권한을 부여한다. v. 에이전트 기능 : 의도 진술 내에서 발생하는 에이전트 기능은 세 계층의 의도 진술로 나눌 수 있다. (a) 제 1 계층-물리적 기능 : 물리적 기능은 의도 진술의 중추를 형성하는 조합 개체 상태 (CES)를 초래하는 독립 개체 의 참여와 관련된다. 물리적 기능은 솔루션을 촉진하는 주요 기능을 제공하는 반면, 다른 두 범주는 직접 또는 간접적으로 물리적 기능을 지원한다. (b) 제 2 계층 - 정보 기능 : 정보 기능은 조합 개체 상태에 연결되고 정 보를 제공하는 기능만 제공하지만 물리적 기능에는 관여하지 않는 개체와 관련된다. 확장적으로, 이러한 정보 기능은 의도 진술 및 이를 주도하는 에이전트와 연결된다. 정보 기능은 에이전트에게 충분한 정보를 제공하고 동적 솔루션 재 설계 및 분석, 기계 학습 및 인공 지능과 같은 기타 부가 가치 기능에서 역할을 한다. (c) 제 3 계층 - 마인드 기능 : 컴퓨터로 구현된 NSL 관점에서 마인드 기능은 현실 세계에서 인간 마인드의 기능을 모방 한다. 이러한 기능은 개체 상태를 '예측'하고 원하는 변환을 가져오는 과정에서 물리적 기능을 안내한다. 예상 은 일반적으로 미래와 관련된 '시간적 측면'에 적용한다. 그러나 예측은 불확실성이 있는 모든 상황에 적용될 수 있다. 이론적으로 불확실성은 과거 또는 현재의 것들과 관련될 수 있다. 예 : 어떤 사람은 어제 무슨 일이있었는지 또는 현재 다른 방에서 무슨 일이 일어나고 있는지 완전히 알지 못하지만 예상하려고 시도할 수 있다. '예상' 또는 \"추측'의 수정은 모든 사건의 사례에서 발생할 수 있다. 그러한 기대가 현재 신체 기능과 관련이 있다면, 이들은 영향을 미치는 개체로서의 물리적 기능으로 피드백된다. 정보 기능과 같은 역할을 하는 것 외에 도, 마인드 기능은 사전 계획 및 최적화 문제에도 도움이 된다. vi. 정보 권리 : 이는 특정 독립 또는 조합 개체 및 이와 관련된 의도 진술에 관한 정보에 대한 인간 에이전트 의 권리이다. vii. 결정권 : 이는 개인 또는 조합적 개체의 잠재적 또는 현실 상태를 변경할 수 있는 인간 에이전트의 권리와 이에 연결된 의도의 진술이다. b. 기계 에이전트 : 인간 에이전트 또는 다른 기계 에이전트가 설계한대로 변경 유닛이 기계 에이전트에 의해 구동되는 '컴퓨터'와 동의어이므로, 입력에 대한 응답으로 적절한 출력이 생성되도록 한다. 기계 에이전트는 본 질적으로 입력을 소비하고, 이들 중 통제된 변경을 가져오고 (이러한 입력을 처리하고), 출력을 생성하는 능력 에서 인간 에이전트를 모방한다. 어떤 의미에서 인간 에이전트는 기계 에이전트로 구동되는 자질을 부여한다. c. 대 자연 : 대 자연은 변형에 영향을 미칠 수 있는 제 3 번째 종류의 에이전트이다. 하지만 대 자연은 목적이 없기 때문에, 대자연에 의해 생성된 이러한 변형 적 결과는 인간 에이전트에 의한 솔루션 설계의 암묵적 개체로 간주된다. 에이전트는 솔루션 설계자의 지시에 따라 작동한다: 솔루션 설계자는 솔루션의 설계자이다. 솔루션은 하나 이상 의 변경 유닛으로 구성된다. 각 변경 유닛은 에이전트가 통제한다. 이 솔루션은 잠재성으로 제시된다. 예를 들 어, 감독은 대본을 설명하고 배우가 감독이 원하는 대로 대본을 준수하는지 확인한다. 이 경우 감독은 솔루션 설계자이고 배우는 개인 또는 팀이 될 수 있는 에이전트이다. \"에이전트\"로 취급될 팀 : 에이전트는 개인 또는 여러 구성원으로 구성된 팀일 수 있다. 팀은 고유한 정체성을 가진 에이전트의 조합이다. NSL을 사용하면 솔루션 설계자의 선택에 따라 팀을 에이전트로 취급할 수 있다. 예 : \"이사회\"의 승인을 포함하는 솔루션에서, 이사회는 팀이지만 에이전트로 취급된다. 협업 에이전트 및 적대 에이전트 : NSL을 사용하면 에이전트를 협업 및 적대자로 분류할 수 있으며, 이 때 공동 의 목표/소원을 달성하기 위해 함께 일하는 에이전트를 협업 에이전트라고 하는 반면, 서로 경쟁하고 있는 에이 전트(\"게임 환경\"에서와 유사함)를 적대적 에이전트라고 한다. 판정 시스템 : 일반적으로 하나의 '문단'은 하나의 글로벌 의도 진술 (GSI)만을 수용한다. GSI가 더 많으면 더 많은 단락이 필요한다. 로컬 의도 진술을 공유했다는 사실로 인해 관련 단락이 발생할 수 있다. 이는 일반적인 프로세스 지향 접근 방식의 '시나리오'와 유사한다. 동일한 글로벌 의도 진술이 그 안에 포함된 로컬 의도 진술 의 변형으로 다른 단락을 서비스할 수 있는 경우가 있을 수 있다. 이것은 다른 하위 프로세스를 통해 달성되는 동일한 결과와 유사한다. NSL은 차별화 원칙을 사용하여 이 문제를 해결한다. 제약과 유사하게 '시스템에 개 체'를 추가로 주입하여 글로벌 의도 진술을 서비스하기 위해 남은 한 단락으로만 가능성을 미세 조정한다. 글로 벌 의도 진술에 서비스할 단락이 남아 있지 않은 경우, 시스템은 일부 개체를 제거할 수 있는 가능성을 탐색하 여 - 비차별화를 생성함 - 잠재적으로 글로벌 의도 진술이 존재하도록 만드는 적어도 하나의 단락이 결과된다. 이는 일부 제약을 제거하는 것과 같다. 삼중 개체 : 에이전트, 변경 유닛 및 일반 개체 (독립 또는 종속 개체)가 공존하며 의도된 변경을 가져온다. 다 른 것 없이 하나가 있을 수 없다. 우주에는 수조 개의 개체가 있지만 중요한 개체는 상황에 따라 문맥상으로 모 인다. 에이전트 없이는 변화가 일어날 수 없다. 변화는 항상 에이전트에 의해 주도되고 에이전트는 의도가 있고 목적에 따라 주도된다. 변경이 발생하려면 개체 간의 상호 작용이 발생해야 하며 물리적으로 발생해야 한다. 예 : 편지를 쓰려면 다음 개체가 함께 있어야 한다: (a) 에이전트 (서신을 쓰는 사람) (b) 일반 개체 (펜, 종이 및 테이블) (c) 의도 (편지 쓰기)의 삼중 개체는 상호 작용을 통해 지시된 변경을 수행하여 의도/소원을 이행한다. 최근접 이웃 : 원하는 상태에 도달하기 위해 많은 로컬 조합 개체 상태를 통해 전환할 필요가 있다. 이러한 모 든 변형 상태는 지시된 변화를 통해 달성된다. 이러한 모든 상태는 최근접 이웃 원칙에 따라 작동하며 최근접 이웃은 삼중 개체, 예를 들어 에이전트, 변경 유닛 및 일반 개체에 동일하게 적용된다. 소원을 이행하기 위해서, 연결된 변경 유닛은 순서에 민감한다. 이는 순서가 중요한 요소가 되는 상호 작용 또는 원인 및 결과 원칙을 통해 변경 유닛 간의 연결이 설정되는 단순한 이유 때문이다. 원인과 결과가 발생하면 변경이 순서대로 발생하므로 원인은 항상 t1에 있고 결과는 t2에 있다. 예 : 편지는 서면 작성되지 않으면 발송될 수 없다. 다음변경 유닛은 선택한 변경 유닛의 가장 가까운 이웃이 된다. 이는 에이전트 및 일반 개체에 유사하게 적용된다. 이해 관계자 참여 센터 (SEC) : 이것은 사용자 인터페이스와 동의어이다. SEC는 에이전트와 관련하여 잠재성을 보유하고 구조화된 방식으로 사용자 인터페이스 수준에서 동일하게 제시하는 모든 개체를 인식할 수 있다. 시스 템은 모든 변경 유닛이 한 에이전트 또는 다른 에이전트에 의해 주도된다는 사실을 기반으로 관련 개체를 인식 한다. 모든 개체가 명확하게 지정된 결정 및 정보 권한을 가지고 있다는 추가 사실은 에이전트 및 탐색 간에 개 체 배포를 쉽게 만든다. 측정 프레임워크 : 측정은 현실의 객관적인 진술이다. 똑같은 일이 일어나려면 최적의 명확성 수준으로 무언가 를 제시해야 한다. 일반적으로 제공된 정보에 충분한 수준의 세분화 또는 충분한 차별화가 필요함을 의미한다. 예 :‘무언가 배달되었다’는 말이 있고 '무언가 30 분 안에 배달됐다'는 다른 말이 있다. 해당 수준의 세부 정 보를 찾고 있는 경우 제 2 문장이 측정 값이 된다. 측정 프레임워크에서 측정의 또 다른 측면은 추가의 차별화 가 좋은지 나쁜지를 결정하는 것이다. 이러한 가치 판단은 '표준'이라고 하는 것을 통해 도입된다. 따라서, '30 분 이내에 배송하는 것'이 좋다고 생각한다면 이것이 표준이 된다. 일반적으로 녹색은 좋은 것으로 간주되는 것 에 할당되고 빨간색은 나쁜 것으로 간주되는 것에 할당될 수 있다. 분산형 미션 통제 센터 (MCC) : MCC는 책임을 수행하거나 필요를 충족하는 인간 에이전트의 정규 과정에서 중요 한 개체를 한데 모은다. 이러한 중요한 개체는 정보 권한 또는 결정 권한이 있는 에이전트와 관련된 개체 중에 서 함께 모은다. 분산 MCC는 특정 에이전트 또는 에이전트들과 관련된 개체를 먼저 자동으로 인식하고, 다음에 에이전트의 기능에 중요한 개체를 선택하는, 시스템의 기능에 관한 것이다. 동적 임무 통제 센터 : 동적 MCC는 분산 MCC와 다르지만 특정 '시간', '사건', '에이전트', '질의'에 맞게 맞춤 화된 관련 에이전트에게 중요한 개체가 제공된다는 점에서 다르다. 각 개체 수준에서 차별화/사건이 발생하므로, 정보 검색을 위해 각 문자를 입력함에 따라 에이전트는 단어/숫자 (개체)를 입력하여 다른 질의에 대한 답을 가질 수 있다. 사용자 인터페이스 (UI) : 개체는 데이터베이스 또는 사용자 인터페이스 레벨에서 서로 다른 추상화 레벨로 존 재할 수 있다. 인간 에이전트가 '정보 권한' 또는 '결정 권한'을 행사하는 곳이 바로 사용자 인터페이스 수준이 다. UI는 '사용자'가 솔루션의 생성 또는 사용을 담당하므로 NSL에서 매우 중요한 역할을 하므로 - 모든 일은 후드 아래에서가 아닌 후드 위에서 발생하다. NSL은 UI를 '필수 속성'으로 만들어 UI 수준에서 개체의 동작을 유도한다. 이러한 속성은 개체가 UI 수준에서 표시되는 방식, 그 주소 (화면과 화면의 위치), 및 탐색 또는 정 보 입력 등에 민감하게 반응하는지 여부 등을 지정한다. 텍스트 기반 사용자 인터페이스 (TBUI) : NSL 패러다임에서 모든 개체는 더 직관적인 자연어 표현 계층에서 처 리되므로 NSL은 텍스트 기반 사용자 인터페이스를 사용한다. 자연어는 수천 년 동안 존재해 왔으며 매우 직관적 이다. 자연어는 일반에서 특정으로 흐르는 차별화 구조를 통해 차별화를 캡처하여, 고도로 구조화되고 자연스럽 게 진보적으로 보이게 한다. TBUI는 자연어 (텍스트) 설계 원칙을 기반으로 하므로 기존의 그래픽 사용자 인터 페이스 (GUI)보다 구조화되어 있다. TBUI는 전자 서적과 유사한 기술 및 과학의 혁신으로 서적 설계의 고전적인 원칙을 합성하고 텍스트 표현에 이미지와 비디오를 추가하는 추가 기능을 가지고 있다. TBUI는 사용자의 탐색 경험을 향상시키고 사용자에게 각 유리한 지점에서 전체적인 보기를 제공한다. 대조적으로, 대부분의 그래픽 사 용자 인터페이스(GUI)는 일반적으로 무작위로 배포된 부품을 갖는 정보를 제공하며 전체적인 통합 보기를 제공 하지 않는다. NSL 기술 프레임워크 : NSL이 가져오는 혁신적인 기술 효과는 고유한 방법과 기술 프레임워크의 조합 때문이다. NSL은 '사용자'가 솔루션의 주요 동인인 광범위한 애플리케이션 요구 사항을 충족하는 표준화된 기술 프레임워 크를 기반으로 한다. 이 문서에 설명된 모든 혁신적인 방법을 캡슐화하는 기술 프레임워크는 컴퓨터로 전달되는 모든 종류의 응용 프로그램 로직을 수용하기 위해 운영 체제의 맨 위에 있다. 사실상 사용자는 이 기본 기술 프"}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "레임워크에 대해 애그노스틱하고 패션과 같은 자연어로 NSL을 사용할 권한이 있다. 요약하면, NSL 기술 프레임 워크는 차별화 원칙을 기반으로 NSL 뒤에 있는 원칙과 방법에 생명을 불어 넣는 기존 운영 체제 위에 얇은 추가 계층이다. 또한 대부분의 인간 에이전트 기능을 자동화하는 데 도움이 된다. 그러나 때때로 개선을 위해 NSL 기 술 프레임워크는 변함없이 유지될 것이다. 운영 체제와 마찬가지로, 코드를 사용하지 않고 자연어 구조를 통해 NSL 로직을 컴퓨터에 전달한다. 리엔지니어링 : NSL은 자연어와 같은 방식으로 컴퓨터에 애플리케이션 로직을 전달한다. 그렇게 함으로써 내부 작업인 프로그래밍 코드를 작성할 필요가 없다. 사용자는 솔루션 구성의 특성이나 프로그래밍 코드의 경우 해당동작을 인식하지 못한다. 사용자 친화적인 NSL은 솔루션 생성 및 애플리케이션 사용을 UI 수준으로 가져온다. 중복성을 줄이고 솔루션 구성 요소의 재사용을 증가시키며 가장 중요한 것은 차별화 또는 솔루션 경로를 최적화 하는 많은 기능이 있다. 매트릭스 기반/타일 기반 접근 방식 : 정보 기술의 세계는 기계 에이전트를 중심으로 구축된다. 각 프로그래밍 언어에는 고유한 키워드, 연산자, 기호 및 함수 세트가 있다. 기계 에이전트에 대한 지시는 명확해야 하므로 각 키워드, 연산자, 기호 및 기능은 명확한 의미를 갖다. 이러한 함수는 각 프로그래밍 언어에서 동일한 의미를 갖 거나 다르게 표현될 수 있다. 타일 기반 접근 방식에서 각 타일은 각 프로그래밍 언어 및 NSL에서 특정 기능과 동일하다. 각 타일의 이러한 동등 함수는 기계 에이전트/시스템에 동일한 솔루션 로직을 표현한다. 기술적으로 NSL + 기술 프레임워크는 프로그래밍 언어와 동일하다. 기술 번역 프레임워크 (TTF) : NSL의 가장 중요한 속성 중 하나는 NSL 방법과 NSL 기술 프레임워크(NSL-TF)를 사용하여 통제된 차별화를 다루는 동일한 원칙을 기반으로 모든 프로그래밍 코드를 NSL 형식과 같은 자연어로 변환하는 가능으로, 사용자 또는 이해 관계자의 직접적인 사용 및 영향을 위한 로직을 표시할 수 있다. TTF는 각 프로그래밍 언어의 키워드, 연산자, 기호 및 기능과 해당 표현을 NSL로 캡슐화하는 매트릭스 기반/타일 기반 접근 방식을 사용한다. TTF는 코드의 구성을 분석하고, 작성된 프로그래밍 언어를 식별하고, 매트릭스를 사용하 여 모든 키워드, 연산자, 기호, 함수 또는 이들의 조합에 해당하는 일치하는 NSL을 선택한다. 기술 재전환 프레임워크 (TRF) : NSL이 제공하는 혁신적인 프레임워크는 NSL로 구성된 모든 솔루션을 프로그래 밍 언어로 변환하는 기능이다. TRF는 TTF의 기반이 되는 동일한 매트릭스 기반 접근 방식을 기반으로 한다. TRF 는 NSL 구조를 이해하고 프로그래밍 언어에서 일치하는 키워드와 함수를 식별하므로, 사용자가 선택한 프로그래 밍 언어로 코드를 구성한다. 360 °Any to Any (A2A) : TRF는 TTF와 함께 360 °Any to Any (\"A2A\")라고하는 체제의 전체 수명주기를 완료 하며, 이는 모든 프로그래밍 언어 또는 자연어로 된 솔루션을 다른 프로그래밍 언어 또는 자연어로 변환하는 기 능이다. 의미가 일정하고 다양한 자연어로 표현될 수 있는 것처럼, 솔루션 로직은 모든 프로그래밍 또는 자연어 서브스트레이트로 표현될 수 있다. NSL에서는 솔루션은 지시문 정보로 알려진 특수한 종류의 정보이다. 잠재성 상태로 표현된 지시문 정보는 조치를 취하면 현실이 되고 그 지시문은 클래스 수준에서 수행되며, 회원들이 도 착하면 거래 수준에서 현실이 발생한다. 정의된 클래스에 도달하는 모든 멤버는 클래스와 동일한 방식으로 동작 한다. 이것들은 전통적인 프로세스를 대체하고 있다. 도달한 사건은 잠재성 텍스트에서 선택되며, 발생하면 모 든 것이 자연어 형식으로 표현될 수 있게 된다. 즉, NSL이 준수하는 특정 차별화 주기가 있으며, 여기에서 차별 화는 적절하고 상황에 맞게 표현되며, NSL에 따른 이러한 차별화는 모든 서브스트레이트에서 표현할 수 있다. NSL은 TTF 및 TRF를 통해 각 서브스트레이트에 내장된 솔루션 로직을 추출하여 원래 서브스트레이트에서 처리하 는 것과 동일한 방식으로 처리할 수 있다. 이 A2A는 입력이 동일하고 출력이 다양한 프로그래밍 또는 자연어로 구축된 모든 솔루션에서 동일하다는 원칙으로 테스트되었다. 요컨대, NSL 구조는 허브 역할을 하며 다른 프로그 래밍 언어는 바퀴살과 같다. 예를 들어, 프로그래밍 언어를 다른 프로그래밍 언어로 번역해야 하는 경우, 프로 그래밍 언어는 NSL이라는 허브를 건드린 다음 다른 프로그래밍 언어로 분기해야 한다. NSL 언어 애그노스틱(agnostic) : NSL은 개체 기반 접근 방식을 취하고 의도 이행 조합 개체 상태의 생성을 기 반으로 솔루션을 생성한다. 기초가 차별화 원칙에 의존하고 있기 때문에, 정말로 중요한 것은 '실제 개체'와 ' 표현 개체' 뒤에 있는 현실이다. 표현 목적으로 사용되는 언어는 중요하지 않다. 그런 의미에서 NSL은 언어 애 그노스틱하다. 질의 기반 솔루션 개발 (QBSD) : 모든 솔루션은 변경 때문에 발생한다. 변경이 없으면 솔루션도 없다. 변경이 일어나려면 항상 방향이 필요하며 그 방향은 에이전트가 제공한다. 에이전트는 방향 뿐만 아니라 변경에 필요한 에너지도 제공해야한다. 따라서 에이전트가 있는 경우 모든 변경은 상황에 따라 달라지며 모든 것은 원하는 CES 에서 다른 CES로 이동하는 것이다. 이것은 일련의 단계를 통해 발생한다. 일련의 단계에 도달하려면 올바른 질 문을 하는 의문문이 필요하다. 솔루션은 무엇을, 왜, 언제, 어디서 모든 질문에 답할 때만 구축된다. 각 질문은 행동을 시작하고 본질적으로 물리적이며 공간과 시간으로 표현될 수 있다. NSL은 질의 기반 솔루션 개발 (QBS D)이라는 질의를 사용하는 솔루션 개발을 위한 매우 간단하고 강력한 도구를 제공한다. QBSD는 미리 정의된 일 련의 질문으로, 응답하면 NSL에서 솔루션을 만드는 데 도움이 된다. NSL의 솔루션 생성은 구조와 같은 자연어 텍스트를 기반으로 하기 때문에 NSL의 솔루션 생성은 이러한 사전 정의된 질문 세트에 응답하는 것만큼 간단한 다. 이것은 사용자가 원하는 솔루션을 구성하기 위해 기계가 제기한 질의에 응답하는 대화형 시스템이다. 자연어 유사 이니셔티브(initiative) : NSL은 애플리케이션 로직을 자연어 유사 방식으로 컴퓨터에 전달한다. 그러나, 이 구성체는 문장이 해당 자연어의 문법으로 구성되지 않으면 자연어처럼 읽히지 않을 수 있다. NSL은 솔루션 구성체에 제공된 정보를 사용하고 기존 언어 라이브러리의 도움으로 자연어처럼 읽는 문장을 생성하여 사용자에게 책에서 솔루션을 읽는 것과 유사한 경험을 제공한다. NSL은 문장 구성체에 최적의 정보를 사용하므 로 구성체를 너무 장황하게 만들지 않는다. 정보가 최적이 아닌 경우 NSL은 에이전트, 개체, 속성 등과 같은 솔 루션 설계의 다양한 수준에서 사용 가능한 정보를 확인하여 검색 범위를 확장한다. 최적의 정보가 없는 경우, 검색 범위를 확장하더라도 문장은 너무 세분화되지 않고 올바른 컨텍스트에서 일반적인 수준으로 구성된다. 표 현할 정보가 문장 구조의 일부로 원하는 것 이상이면 추가 정보를 정보 계층에 첨부하여 변경 유닛을 추가로 지 원한다. 자동 동사할당 (AVA) : 대부분의 시나리오에서 동사는 의도 진술에 반영된 변경 지시자에 지나지 않다. 설명은 일반적인 수준 또는 세분화된 수준일 수 있으므로 인간 에이전트에게 의미 있는 방식으로 사물을 표현한다. 일 반적으로 설계자가 기능을 제공하려는 경우가 아니면 NSL에서 기능적 가치를 전달하지 않는다. 그러나 동사는 의도 진술이 자연어처럼 읽히도록 보장하기 위해 모든 의도 진술에서 필수적이다. NSL에서 새로운 솔루션을 만 들 때 의도 진술에서 동사를 선택할 수 있는 유연성이 있다. 그러나 TTF를 사용하여 프로그래밍 언어에서 NSL로 변환된 기존 솔루션의 경우, 기본 프로그래밍 코드에는 일반적으로 동사가 포함되지 않으므로 동사는 자동으로 생성되지 않는다. 자동 동사할당은 기능에 동사를 자동으로 할당하여 자연어에 더 가깝게 보이도록 하는 NSL의 향상된 도구이다. AVA는 NSL에서 생성된 동사 라이브러리를 사용하여 동사 구문 구성체에 가장 적합한 올바른 동사를 선택한다. 관행 기반 솔루션 개발 (PBSD) : 문제를 해결하는 모든 것이 솔루션이다. 문제는 항상 에이전트의 컨텍스트에 있다. NSL 패러다임에서, 솔루션은 일반적으로 이해되는 기술에 더 이상 제한되지 않는다. NSL은 세계가 작동하 는 방식의 원리를 기반으로 하는 개체 기반 솔루션 모델이다. 솔루션은 일상적인 관행으로 존재한다. 문제를 해 결하는 모든 관행은 개체가 특정 결과를 제공하기 위해 상호 작용하는 방식에 관한 것이다. NSL은 에이전트가 기록한 최상의 관행을 캡처하고 주어진 프로세스를 통해 중요한 개체를 식별할 수 있다. 그런 다음 특정 개체를 클래스 상태로 승격하여 일반 솔루션 로직을 캡처할 수 있다. NSL은 사용자가 관행에서 파생된 작업을 수행할 수 있도록 기계 지원 지침을 제공한다. 서브스트레이트(substrate) 독립적 : 동일한 의미가 다른 언어로 표현될 수 있는 것처럼, 솔루션 로직은 또한 많은 서브스트레이트를 통해 표현될 수 있다. NSL은 프로세스와 정보 사이의 구분을 없앴으며, 프로세스는 정보 에 따라 행동하는 특수한 클래스이다. 정보 자체는 본질적으로 비 물리적이며 개념적이다. 그것은 개체의 고유 성의 특성으로 표현된다. 모든 고유성은 하나의 서브스트레이트 또는 다른 서브스트레이트를 통해 표현되어야 한다. 정보를 표현하기 위한 서브스트레이트의 존재는 필수이다. 즉, NSL이 준수하는 특정 차별화 주기가 있으 며, 여기에서 차별화는 적절하고 상황에 따라 표현되고, NSL에 따른 이러한 차별화는 모든 서브스트레이트에서 표현될 수 있다. 예 : '0' 또는 '1'은 비거나 차 있는 유리로 표시되거나 빈 트랜지스터 또는 전자로 채워진 트 랜지스터로 표시될 수 있다. 솔루션의 정량화 : 정보가 정보 이론에서 '비트'로 정량화되는 것처럼 NSL은 개체 관계 간의 거리 식별을 통해 솔루션을 정량화한다. (a) 이진 사건 : 개체 관계 간의 거리는 한 CES에서 다른 CES로 가져 오는 데 걸리는 최 소 이진 사건 수로 측정할 수 있다. 예 : 개체 1이 'A'이고 개체 2가 'AB'이고 개체 3이 'ABC'인 경우, 개체 '1'에서 개체 '3'으로 얻기 위해 발생해야 하는 최소 이진 사건의 수는 '2'이다. 원칙은 이러한 차별화가 무시 되거나 인식될 때 합병 또는 두 개체가 동일 해지는 결과를 낳는다는 것이다. NSL은 구조와 프로세스의 차이를 제거하고 중요한 것은 차별화의 방향성일 뿐이다. (b) 공간 : 각 CES는 명시적이거나 암묵적이며 공간에서 작동 하기 때문에 얼마나 많은 거리를 커버했는지 알 수 있다. (c) 시간 : 각 CES와 관련된 명시되거나 명시되지 않 은 시간이 있기 때문에 시간을 잠재적으로 평가할 수 있으므로 거리를 시간으로 측정할 수 있다. (d) 자원 소비 : 어떤 것이 한 CES에서 다른 CES로 이동할 때 자원이라고 하는 참여하는 개체의 세트가 필요하다. 모든 자원 뒤에는, 할당할 수 있는 값이 있으므로, 각 CES에 필요한 자원 소비를 측정할 수 있다. 중복 제거를 통한 로직 압축 : 프로그래밍 언어는 기존 시스템에서 로직을 디코딩하기 위해 특별한 노력이 필요 한다. 복잡한 로직을 디코딩하는 데는 새 코드를 작성하는 것보다 시간이 더 걸리기 때문에 프로그래머는 기존 코드를 활용하지 않는다. 그들이 작성하는 새로운 코드는 시스템 간의 중복성을 증가시킨다. NSL은 자연어이고 완전히 투명하고 검색 가능하므로 중복을 제거하고 기존 솔루션 구성 요소를 재사용할 수 있다. 솔루션 로직 압축으로 인한 계산 자원의 감소 : NSL은 중복을 제거하여 로직 압축에 도움이 되고 NSL에서 모든 것이 투명하며 솔루션은 간단한 검색 메커니즘을 통해 처리되기 때문에, 모든 프로그래밍 언어에 비해 NSL의 처리 솔루션에서 RAM 및 CPU와 같은 계산 자원이 감소하게 된다. 공학 설계에 NSL 원리 적용 : 엔지니어링 설계 프로세스는 엔지니어가 기능적 제품 및 프로세스를 만드는 데 사 용하는 일련의 체계적인 단계이다. 프로세서는 그 일부가 다른 일부가 입력되기 전에 자주 여러 번 반복되어야 한다는 점에서 매우 반복적이다. 반복되는 부분과 주어진 프로젝트에서 이러한 주기의 수는 다를 수 있다. NSL 의 모든 개체는 정보 제공적이고 고도로 차별화되며, 개체의 조합은 더 많은 차별화로 이어진다. 또한, NSL 원 칙은 원하는 조합 상태에 도달할 때까지, 각 부분이 차별화되어 전체 설계를 구성하는 구성 요소를 식별하고 부 품을 조합함으로써 엔지니어링 설계에 적용되어, 새로운 고유한 상태를 만든다. 이러한 부분 간의 상호 작용은 기능 또는 프로세스와 동일한 확장된 CES 원칙에 따라 작동한다. 프로세스 대 검색 : 프로그램은 사건에 반응하는 방법의 로직을 배치한다. 입력이 되는 사건은 로직에 의해 규 정된 적절한 데이터베이스 항목을 사용하고 출력을 생성한다. 출력은 데이터베이스의 필수 부분이 된다. 프로그 래밍에는 프로그램에 포함된 로직과 데이터베이스에 포함된 개체 처리에 기반한 많은 처리가 필요한다. 반대로, NSL에서 시스템은 솔루션 처리 방식을 완전히 바꾸는 검색 원칙에만 의존한다. NSL은 모든 사건이 CES를 통해 취할 수 있는 특정 정보 클래스와 유사한 솔루션 가능한 정보 경로를 적절하게 식별한다. 그 결과 솔루션 로직 과 트랜잭션 로직이 동일하게 유지되면서 계산 자원의 소비가 크게 감소하여, 프로세스를 끝낸다. 컨테이너 : NSL에서, 근본적인 변화와 가치 창출은 변경 유닛에서 이루어진다. 모든 변경 유닛에는 정의된 경계 세트가 있다. NSL에서 모든 변경 유닛은 컨테이너이며 트랜잭션은 컨테이너에서 발생한다. 한 컨테이너의 출력 은 솔루션 로직에서 설계된 대로 후속 컨테이너 중 하나의 가변 개체이다. 컨테이너 시스템은 ID 할당의 컨텍스 트에서 중요성을 가정하며 에이전트 및 개체를 변경 유닛의 일부로 정의하고 개체의 일부인 속성 등을 정의하여 계층 및 구조를 생성하도록 가장 잘 설계되었다. 다양한 종류의 컨테이너가 있으며 다양한 컨테이너에는 다양한 수의 슬롯이 있다. 각 컨테이너에는 마지막 CU까지 CU1, CU2 등과 같은 시퀀스를 기반으로 ID가 자동 할당된다. NSL의 모든 개체에는 고유한 ID가 있다. 개체는 여러 ID를 가질 수 있다: 하나는 기본 ID이고 나머지는 컨텍스 트 ID이다. 즉, 특정 변경의 컨텍스트에서 역할에 따라 슬롯이 할당된다. 개체가 여러 변경 유닛에 참여하는 경 우 참여하는 각 변경 유닛에 하나의 ID로 여러 ID를 갖게 된다. 따라서 개체는 다른 변경 유닛에서 차지하는 공 간으로 인해 하나의 개별 ID와 하나 이상의 ID를 갖게 된다. 각 CU에 참여하는 에이전트, 개체 및 속성도 순서 대로 자동으로 번호가 지정된다. 각 CU의 각 잠재적 CES에는 설계상 생성된 고유한 ID가 있지만, CU에 있는 오 직 하나의 CES 만 트리거 상태에 있을 자격이 있다. NSL 형식으로 변환된 문서 : 모든 자연어에는 서술문, 지시문, 의문문, 감탄문이 있다. 지시문은 조치 또는 변 경이 관련되고 서술문은 정보를 제공한다. 감탄문은 강조하는 것에 관한 것이다. 모든 서술문 및 지시문은 의문 문에 답변하는 것으로 발생한다. 질문과 답변은 개체, 조합 개체 상태 또는 확장 CES와 관련이 있으며, 이는 운 영 우선 순위에 따라 공간과 시간에 적용된다. NSL은 모든 문서의 텍스트를 서술문 및 지시문으로 변환할 수 있 고, 이 때 지시문은 CU와 유사하고 서술문은 지시문에 정보로 첨부되어 정보 계층에 위치한다. 감지 기반 사용자 인터페이스 : NSL의 범위는 기술 솔루션을 넘어선 것이며 그 범위는 전 세계의 모든 기존 솔 루션으로 확장된다. NSL은 다른 사람들이 무인 차량으로 수행하는 것과 유사한 올바른 종류의 출력을 생성하는 데 있어 환경에 영향을 주는 것과 관련이 있고 없는 개체를 분리한 후, 패턴 인식을 통해 개체를 인식하여, 이 들 개체를 입력으로 취하는 고급 모델을 사용하는 개체 기반 솔루션이다. 솔루션은 주로 기술 관련 솔루션이므 로 대부분의 경우 인터페이스는 화면과 음성으로 제한된다. NSL은 기술 솔루션을 넘어서 확장되기 때문에 NSL은 시각, 촉각, 청각, 미각, 후각의 기본 오감 및 추가 감각의 입력을 생성할 수 있는 감각 기반 사용자 인터페이 스라는 인터페이스에 중요한 추가 기능이다. 추가 감각은 인간의 감각으로는 포착할 수 없지만 엑스레이, 전파 등처럼 기계 에이전트가 포착할 수 있는 것이다. 감각은 주변 환경을 측정하고 정보에 입각한 결정을 내리는 데 도움이 된다. NSL은 사용자 인터페이스를 장치 전체의 일반 화면 이상으로 확장하고 도달 범위를 엄청나게 확장 한다. 시스템에 대한 입력은 마인드에 등록된 환경의 패턴을 기반으로 한다. NSL은 적절한 것을 저장하고 부적 절한 입력을 할인하는 기능을 가지고 있다. NSL은 현실 세계의 개체를 인식하고 사용자가 찾고 있는 솔루션에 적절하게 응답한다. NSL 및 DNA : 우리는 정보 중심 세계에 살고 있다. 솔루션 환경으로의 정보 침투를 차단하는 기존 프로세스 장 벽과 유사하게, 생명체의 DNA에 포함된 정보와 관련하여 장벽이 존재한다. DNA에 포함된 정보를 검색 가능하고 판독 가능하게 되도록 NSL 형식으로 변환할 수 있는 기회가 있다. 인공 신경망 : 각 의도 진술 (SI)는 마치 뉴런인 것처럼 작동한다. SI의 사건은 잠재성의 문턱에 도달했을 때 뉴런의 발화와 같으며, 변화를 다른 뉴런으로, 이 경우 다른 SI로 전파한다. 솔루션 환경의 SI 모음은 신경망과같은 기능을 수행한다. 인공 신경망이 기반을 확보하고 있으며 NSL에 내재된 솔루션 설계는 이러한 원칙을 효과 적으로 실행하는 데 가장 도움이 된다. 순서도 로직 변환기 : 이것은 솔루션 로직이 기존 순서도에서 추출되는 관행 기반 솔루션 개발의 한 형태이다. 순서도의 구성은 예를 들어 NSL 용어에서 GSI를 달성하기 위해 일련의 LSI가 상호 작용하는 문장으로 이어지는 한 문장과 같다. 그러나 순서도에는 일반적으로 각 문장에 참여하는 개체, 에이전트 및 속성에 대한 추가 정보 가 없다. NSL은 모든 순서도의 프로세스에서 솔루션 로직을 추출하여 정보로 변환한다. 추출된 정보는 NSL에서 변환 경로를 구성하는 데 사용될 수 있다. 프로세스가 동일한 GSI에 도달하는 여러 시나리오로 분기되는 경우, 이들은 NSL에서 관련 단락으로 생성된다. 자원 최적화 및 유휴 시간 식별 프레임워크 : NSL은 또한 자원 최적화 및 유휴 시간 식별 프레임워크를 갖추고 있어 사용자가 원하는 대로 사용 가능한 모든 자원의 최적 사용을 정의할 수 있다. 이 프레임워크는 가치 창출 활동에 대한 실시간 개체 참여를 추적하는 자동화된 기술을 갖는다. 모든 변경 유닛 및 조합 개체 상태는 공간 및 시간의 사건 로그에 연결되어 NSL이 실시간으로 개체 사용 메트릭을 캡처할 수 있다. NSL에는 개체가 트리거 상태에 참여한 횟수와 변경 유닛이 트리거된 횟수를 캡처하는 기능이 있다. 이러한 사용률은 일정 기간 동안 또 는 특정 시점에서 캡처할 수 있다. 최적의 차별화 원칙은 사용자를 분석 정보로 돕고 리소스 최적화 프레임워크 에 대한 의사 결정 기능을 개선한다. 리소스 사용량과 최소 유휴 상태는 비용 대비 최대 가치를 추출하는 데 도 움이 된다. 메타 솔루션 로직 개체 : NSL에서 솔루션은 지시문 정보로 알려진 특수한 종류의 정보이다. 잠재적 상태로 표현 된 지시문은 조치를 취하면 현실이 된다. 지시문은 클래스 수준에서 이루어지며, 회원이 도착하면 트랜잭션 수 준에서 현실이 발생한다. 솔루션 설계는 클래스 수준에서 설정되며, 솔루션 설계에 필요한만큼 클래스 자체는 차별화될 수 있다. 예를 들어 : 사람이 클래스 수준에 있으면 비문맹인과 문맹인은 클래스 내 하위 클래스다. 관계는 클래스 수준에서 정의된다. 기본적인 원칙은 상호 작용에 대한 구성원의 행동이고, 생성하는 결과는 그 것이 속한 클래스의 행동과 동일하다. 따라서 트랜잭션이 발생하면 시스템은 해당 트랜잭션이 속한 개체 클래스 를 결정한다. 로직은 일반 클래스에서 차용되며 유리한 점은 가장 구체적인 멤버에서 매우 일반적인 클래스까지 다양할 수 있다. 이렇게 하면 \"솔루션 수준 트랜잭션 카운트\"라고 하는 솔루션의 로직을 사용한 사람 수를 식별 하는 데 도움이 된다. 이는 동영상이 조회수를 표시하는 방식과 유사한다. 트랜잭션 솔루션 로직 개체 : 솔루션 아키텍트는 클래스 및 서브 클래스를 정의하고 잠재적인 레벨 단락을 생성 한다. 사건이 회원 수준에 도달하고, 이들은 적절한 클래스를 선택한다. 그것은 욕망이 형성되고 에이전트가 선 택되는 것으로 시작된다. 클래스는 여러 하위 클래스를 추가하여 자체적으로 매우 차별화할 수 있다. 트랜잭션 솔루션 로직 개체는 사용자가 실시간 솔루션 설계 사용 메트릭에 대한 의미 있는 통찰력을 추출하는 데 도움이 된다. 가장 많이 찾는 솔루션 설계 구성 요소를 쉽게 식별할 수 있으며 모든 참여 관계자의 반복적인 활동에 광 범위하게 사용된다. 모든 트랜잭션은 솔루션 클래스의 멤버이다. 이는 \"개체 사용 횟수\" - 특정 기간 동안 개체 가 사용된 횟수 또는 특정 시간에 사용되는 개체 수 등을 식별하는 데에 도움이 된다. 트랜잭션과 그 카운트는 사용자가 가치 판단 원칙을 잠금 해제하여 개체 재고 및 계획 메커니즘의 우선 순위를 정하는 데 도움이 된다. NSL로 변환된 로직 연산자 : 솔루션의 세계는 기술 또는 기타 분야에서 솔루션 설계를 위해 세 가지 주요 논리 연산자 'and', 'or' 및 'not'을 사용한다. NSL은 솔루션을 다루기 때문에 NSL의 기반이 되는 차별화 원칙에 포 함된 이 세 가지 논리 연산자를 다루는 메커니즘이 필수적이다. (a) 연산자 'And': NSL의 구성은 GSI에 도달하 기 위해 모든 LSI가 충족되어야 한다. 따라서 각 문장을 순차적으로 수행해야 한다면 NSL 설계에 의해 논리 연 산자 'And'가 자동으로 처리된다. (b) 연산자 'Or': NSL은 공통 GSI에 도달하기 위한 여러 경로를 제공하는 관 련 단락을 제공한다. 관련 단락은 NSL에서 논리 연산자 'Or'가 처리되는 방식을 설명한다. (c) 연산자 'Not': NSL은 논리 연산자 'Not'의 기능을 포함하는 모든 개체에 대해 잠재적 상태와 현실 상태 사이의 전환을 제공한 다. NSL API : API는 특정 프로토콜에서 하나의 시스템으로부터 요청을 전달하는 두 시스템 사이의 중개자이고, 응 답은 다른 시스템에서 제공한다. NSL은 이러한 API를 자연어 구조로 표현하여 보다 직관적으로 만드는 기능을 가지고 있다. NSL은 기존 시스템, 미들웨어 또는 운영 체제를 NSL 형식으로 변환할 수 있다. 요컨대, NSL에는 사용자 경험을 보존하면서 기존 솔루션과 원활하게 통합되는 자연어 구조로 개발된 API가 있다. 대화형 솔루션 설계 : 대화형 솔루션 설계는 QBSD의 변형이다. NSL이 수행하는 중요한 작업 중 하나는 특정 규 정된 절차에 따라 기계 에이전트와의 상호 작용이 인간 에이전트와의 상호 작용에 더 가깝게 느껴지도록 만드는 것이다. 따라서 대화형 솔루션 설계는 기계 에이전트와 대화하여 솔루션을 만드는 기능이다.NSL 구성에 프로그래밍 코드 첨부 : 프로그래밍 언어가 TTF를 사용하여 NSL로 변환될 때, 프로그래밍 언어의 코 드 구성과 NSL의 솔루션 구성 사이에 설정된 상관 관계의 임의 레벨이 있다. 따라서 NSL은 문서화의 목적을 달 성하기 위해 NSL에서 구성된 각 문장에 프로그램의 세그먼트를 첨부한다. 사용자는 변환된 코드를 NSL 구조의 적절한 부분에 첨부하는 데 상당한 가치를 얻을 수 있다. 프로그래밍에서 오픈 소스 솔루션 로직 큐레이팅 : 이는 리엔지니어링과 유사하며, 오픈 소스 프로그램이 TTF를 사용하여 NSL로 변환되면, NSL은 구조에 적절한 가치 추가를 수행하여 중복성을 제거하고 솔루션의 효율성을 개 선하도록 안내한다. 이것은 로직이 여러 섹션에 걸쳐 분산되어 있기 때문에 프로그래밍 언어에서는 매우 어려운 문제가 되며 그러한 결과를 얻기 위해서는 엄청난 노력을 필요로 한다. 역 엔지니어링 TBUI : TBUI는 개체, 에이전트 또는 CU가 나타나는 위치에 대한 명확한 시각을 설정하는 차별화 계층이다. NSL은 TBUI가 솔루션에서 야기한 차별화를 식별하고 이러한 차별화는 TBUI를 참여하는 각 개체에 적 절한 속성으로 추가하여 대안으로 표현할 수 있다. 개체 간의 상관 계수 및 관계 : NSL 구성에서, 모든 것은 개체이며 유리한 지점 만 다르다. 모든 유리한 지점 개체를 다른 유리한 지점 개체와 비교하여 그들 사이에 상관 관계가 있는지 확인할 수 있다. 상관 관계가 없으 면 0이다. 그렇지 않으면 0에서 1까지 다양할 수 있다. 완전한 양 또는 완벽한 음의 상관 관계는 극단에 있다. NSL의 시각적 매핑 : NSL은 시각적으로도 표현될 수 있는 차별화 원칙에 관한 것으로, 즉, 변경 유닛이 어떻게 보이는지, 어떻게 연결되어 있는지, 어떻게 존재하게 되는지 시각적으로 표현할 수 있다. 그 자체로 주어진 부 가 가치가 있는 적절한 시각적 구조의 이들 요소 중 하나에 각 프로그래밍 번역을 연결할 수 있는 기회가 있다. 세 가지 관점 - 학습, 개발 및 사용자 : NSL은 모든 개체가 NSL에서 투명하므로 TBUI 수준에서 세 가지 관점, 즉 학습, 개발 및 사용자를 모두 제공한다. (a) 학습 관점 : 프로그래밍 언어의 패러다임에서 프로그래밍 학습 프로세스, 예를 들어, 필수 학위 취득, 기술 세트 및 실습은 장소, 시간, 및 매체에 걸쳐 분산된다. NSL은 TBUI 레이아웃의 일부로 대화형 시스템을 제공하고, 이 때 새로운 사용자라면 누구나 직관적인 학습 모듈을 통해 NSL 을 배우고 습득한 학습 기술을 즉시 평가할 수 있다. 이러한 학습 모듈은 새로운 사용자에게 매우 짧은 시간 내 에 필요한 기술을 제공하고 학습 모듈이 끝날 때까지 사용자의 자체 인증을 지원한다. 이 학습 관점은 절대적으 로 투명하며 NSL을 사용하는 사용자의 여정의 일부로 볼 수 있다. (b) 개발 관점 : 프로그래밍 언어를 사용하여 준비된 솔루션은 소프트웨어 개발 수명주기를 따르며 주기에서 발생하는 많은 일은 투명하지 않고 최종 솔루션 이 작동하는 시스템에서 발생한다. NSL에서는 솔루션 개발 수명주기 자체가 일련의 질문에 대한 정보와 NSL에 투명한 방식으로 나타나는 모든 정보를 얻는 것으로 단축된다. (c) 사용자 관점 : 사용자 수준에서 데이터베이 스의 일부 요소만 프로그래밍 언어로 선택적으로 나타난다. 나머지는 내부에 있는 프로그램과 내부에 있는 데이 터베이스에서 발생한다. NSL에서는 모든 것이 투명하며, 사용자에게 필요한 것은 해당 정보를 볼 수 있는 적절 한 정보와 결정 권한이다. 개체 상호 작용에 기초한 추가 정보 추출 : 모든 변경은 개체 간의 상호 작용으로 인해 발생하며, 따라서 상호 작용 개체 중 하나에 대한 정보가 알려진 경우 다른 개체에 대한 정보가 추출될 수 있다. 펜, 종이, 테이블, 상 호 작용할 의도를 가진 사람이 그 과정에서 서면 종이를 생성했다고 상상해 보자. 펜의 위치와 그것이 그 위치 에 있었던 시간에 대한 정보만 있으면, 보다 광범위한 상호 작용 원칙에 대한 제한된 정보로, 다른 개체에 대한 정보를 수집할 수 있다. 이것은 분석의 관점에서 매우 중요하다. 기본 변경 유닛 : 기본 변경 유닛은 개체 간의 모든 트랜잭션 상호 작용과 결과 트리거 상태가 발생하는 기본 유닛이다. 기본 변경 유닛은 존재하는 유리한 지점에 관계없이 동일한 방식으로 존재하고 작동한다. 더 높은 유 리한 지점에서 정보 계층은 더 많은 정보를 전달하는 경향이 있다. 순차 변경 유닛 : 기본 CU가 트리거될 때 하나 이상의 사건을 통해 영향을 미칠 수 있는 CU이다. 순차 CU는 'AND' 연산자 원칙을 활용한다. CES 상태는 기본 CU 및 순차적 CU 내에서 유지되어 E-CES를 형성한다. 예를 들 어, 차를 준비하려면, 티백을 컵에 넣고, 주전자에 물을 채우고, 주전자의 물을 끓이고, 끓인 물을 컵에 붓고, 컵에 설탕을 넣어야 한다. 이것은 차를 준비하는 순차적 단계이다. 대체 변경 유닛 : 이행 상태 또는 다음 활성화 상태에 도달하기 위해 여러 대안을 사용할 수 있는 경우 솔루션 설계자에 의해 대체 CU가 사용된다. 대안 중 하나만 실행되고 나머지는 사라진다. 이 CU는 'OR' 연산자 원칙을 사용한다. 예를 들어 신용 카드, 인터넷 뱅킹, 대금 상환, 상품권 등 결제 옵션 중 하나를 사용하여 결제할 수 있다. 병렬 변경 유닛 : 동일한 GSI에 속하는 2 개의 LSI가 공유 개체를 갖지 않고 직접 또는 간접 종속성을 갖지 않 는 경우,이를 병렬 CU라고 한다. 시스템에는 자동으로 식별하고 그에 따라 레이블을 지정하는 기능이 있다. 예 를 들어, 음식 배달 앱에서 고객이 식당에서 음식을 선택하고 비용을 지불하면, 음식 준비를 위해 레스토랑에 알림이 트리거되고 픽업 및 배달을 위해 배달원에게도 전송된다. 두 사건이 병렬로 트리거된다. 중첩된 변경 유닛 : 중첩된 CU는 트랜잭션 레벨에서 훨씬 더 많은 정보를 제공하기 위해 기본 CU에 추가된 추가 유형의 CU이다. 이것은 기본 CU의 SSA 주기 내의 SSA주기와 같다. 하위 변경 유닛 : 솔루션 생태계에서 하나의 유리한 지점에서 더 높은 유리한 지점으로 이동할 때, 낮은 유리한 지점에 있는 모든 CU는 높은 유리한 지점에 있는 CU에 포함된다. 낮은 유리한 지점에 있는 CU는 높은 유리한 지 점에 있는 CU에 대한 하위 CU이다. 임베디드 변경 유닛 : NSL에서 구성된 솔루션은 다중 계층으로 구성될 수 있고, 여기서 솔루션이 활동이면 여러 작업으로 이루어질 수 있다. 각 작업은 여러 하위 작업을 더 포함할 수 있으며, 각 작업의 유리한 지점에서는 그 자체로 변경 유닛이다. NSL은 CU 내에서 CU를 계층화하는 이 기능을 제공하고, 이 때 상위 레벨 CU는 하위 레벨 CU가 충족을 달성하는 경우에만 트리거된다. 두 가지 유형의 임베디드 CU가 있다. 숫자 중심인 재귀적 변경 유닛 및 변경 유닛 내에서 변경 유닛이 하위 변경 유닛. 일시적인 변경 유닛 : 일시적인 변경 유닛은 변경 유닛을 가능하게 하는 것으로 간주되어야 한다. 일시적인 변 경 유닛은 정보 교환 또는 E-CES가 여러 단락 또는 챕터로 확장되는 다른 단락에 연결된 단락의 시나리오가 있 을 때 중요하다. 예를 들어, 편지를 발송하려면 \"편지 쓰기\"를 완료해야 한다. 마지막 LSI, 즉 하나의 변경 에 이전트에 대해 GSI인 서면 편지 준비 상태는 우체국의 GSI에 대한 일시적 변경 유닛이 된다. 솔루션 클래스 : 솔루션 설계자는 클래스 및 하위 클래스를 정의하고 잠재적 인 레벨 단락을 생성한다. 사건은 회원 수준에 도달하고 적절한 클래스를 선택하고; 그것은 항상 욕망이 형성되고 에이전트가 선택되는 것으로 시 작된다. 솔루션 로직의 유리한 지점에 있는 개체와 트랜잭션 로직의 개체를 분리하는 것이 중요하다. 솔루션 로 직에서 변수는 개체 관계의 원칙을 설명하는 '모든 LSI', '모든 인간 에이전트', '모든 펜', '모든 종이' 등이 다. 트랜잭션 클래스 잠재성 : 트랜잭션 클래스는 솔루션 클래스의 멤버이다. 트랜잭션이 수행될 때 사용자는 솔루 션 클래스가 허용하고 잠재적 상태에 있는 다양한 가능성과 옵션 중에서 선택할 수 있다. 예를 들어, 편지를 쓸 때, 사용자는 볼펜, 잉크 펜 또는 연필 중에서 선택할 수 있고; 녹색, 파란색 또는 주황색 중에서 종이를 선택 한다. 트랜잭션 클래스 현실 : 사건이 트랜잭션 클래스 잠재성에 도달하면, 트랜잭션 클래스 현실이 생성된다. 각 트 랜잭션은 고유하다. 임의의 수의 트랜잭션 클래스를 생성할 수 있는 솔루션 클래스이다. 내포 마인드 : 모든 솔루션은 연결된 차별화 클래스를 사용하여 구축될 수 있으며, 이러한 차별화는 CES 또는 E-CES에서 발생하는 일을 고려할 수 있다. 모든 변경 유닛에는 SSA 주기와 같은 프랙탈이 내재되어 있다. 에이 전트가 있는 상태에서, 감각은 환경에서 사물을 감지하고, 마인드는 다양한 가능성 중에서 적절한 선택을 하고, 신체는 변화주기를 완료하는 데 필요한 에너지를 제공한다. 현재의 SSA 주기를 유지할 때, 모든 변경 유닛에 3 개의 계층이 연결되어 있으며 여기에는 개체와 이에 속하는 CES가 포함된다. 감지는 정보 계층과 관련이 있고; 선택은 마인드 계층과 관련이 있으며 행동은 물리적 계층에서 수행된다. SSA 주기는 솔루션 클래스와 트랜잭션 클래스 모두에 존재한다. NSL은 생태계의 상태를 감지하고 그것이 도움이 되는지 여부를 결정하고, 그 안의 잠 재성을 평가하고, 이중에서 선택하고, 물리 계층에서 적절한 변경 드라이버를 호출하여 작동하는 것과 관련된 모든 가능성을 제공한다 (규범할당을 통해), 내포 마인드는 모든 변경 유닛에 내재된 중첩 변경 유닛의 마인드 계층이다. 내포 마인드는 평가된 상태가 좋음, 나쁨 또는 양가적일 수 있는 모든 유리한 지점에서 모든 독립 개 체 및 CES의 상태를 지속적으로 평가한다. 덧붙여서, 그것들 각각의 정도를 다룰 수 있다. 마인드에 의해 평가 되는 상태는 알려진 상태 또는 알려지지 않은 상태이다. 알 수 없는 상태는 과거, 현재 또는 미래에 속할 수 있 다. 마인드는 사용 가능한 정보를 기반으로 알려지지 않은 상태에 대해 예측/평가/추측한다. 그것은 가능성을 생성하고 중요하지 않은 가능성을 무시한다. 내포 마인드는 결과적 가능성 (좋음/나쁨/양가적)에 대한 가치 판 단을 내리거나 부수적으로 기회와 위험을 식별한다. 이러한 결과적 가능성에 가능성/확률을 할당한다. 중첩 마 인드는 정보 계층의 기회/위험에 대해 에이전트에게 선택적으로 알리고; 물리적 기능 계층의 변경 드라이버를 변경함으로써 변형 경로를 개입하고 변경한다. 내포된 마인드의 작용은 에이전트가 원하는 대로 자원 최적화와 관련된 문제를 포함한다. 마인드 계층은 사용자의 선택에 따라 배치(batch) 모드 또는 실시간 모드로 작동한다.컨텍스트 별 삼중 ID : 솔루션 생태계는 일반 개체가 없고 어떤 에이전트도 변경 유닛 외부에 존재할 수 없으며 일반 법인 또는 에이전트 없이는 변경 유닛이 존재할 수 없다는 단순한 원칙에 의해 작동한다. 에이전트와 일반 개체는 소원을 이루기 위해 변경 유닛이 된다. 그들이 함께 모일 때, 그들은 더욱 독특하고 차별화된 개체들의 조합을 형성한다. NSL의 각 일반 개체 및 변경 유닛은 정보를 제공하며 고유한 ID를 전달한다. 에이전트 및 일 반 개체는 여러 변경 유닛에 참여할 수 있다. 그들이 참여하는 변경 유닛 (에이전트 및 독립 개체)를 기반으로 컨텍스트 ID를 도출한다. 이러한 컨텍스트 별 삼중 ID는 범용 솔루션 로직 빌더의 역할을 한다. a. 변경 유닛 ID : 변경 유닛은 클래스 수준의 차별화된 개체가 결합하는 방식과 솔루션을 향한 변경 경로를 배 치하는 방식에 따라 솔루션 로직을 정의한다. ID는 다음과 같은 방식으로 각 CU에 할당된다. i. 솔루션 생태계 ID : NSL은 존재할 수 있는 하위 집합의 최대 수를 허용한다. 예 : 생태계가 조직인 경우 시 스템이 처리하는 조직의 수는 하위 집합의 크기를 정의한다. 하위 집합이 10,000 개의 조직이면, 5 자리 ID를 제공할 수 있다 (예 : \"abcde\"는 5 자리 ID). ii. 레벨 1 변경 유닛 하위 집합 : 조직에 최대 1000 개의 비즈니스가 있는 경우 4 자리를 제공해야 한다 (예 : \"abcde.1234\"는 레벨 1 변경 유닛 ID이며 \"abcde\"는 솔루션 생태계 ID이다) iii. 레벨 2 변경 유닛 하위 집합 : 레벨 1 변경 유닛 하위 집합 내에서 가능한 최대 하위 집합에 따라 잠재적 공간 (예 : 6 자리)을 결정할 수 있다. (예 : \"abcde.1234.ABCDE\"여기서 \"abcde.1234\"는 레벨 1 변경 유닛 서 브 세트 ID) iv. 더 높은 레벨의 하위 집합 : 위에서 언급한 레벨 1 및 레벨 2 변경 유닛 하위 집합 ID와 유사한다. NSL을 사용하면 사용자가 필요한 세부 레벨에서 ID를 만들 수 있다. v. 프로세스 : 생태계의 유리한 지점 아래로 내려가면 이전 패러다임의 프로세스와 유사한 것을 접하게 된다. 프로세스는 주어진 결과를 산출하는 '기본 변경 유닛'의 집합이다. 마지막 유리한 지점이 수용하는 프로세스의 수에 따라 시스템에 존재할 것으로 예상되는 최대 프로세스의 수를 기반으로 더 차별화된 수를 할당할 수 있다. vi. 기본 변경 유닛 : 기본 변경 유닛은 개체 간의 모든 트랜잭션 상호 작용과 결과의 트리거 상태가 발생하는 기본 유닛이다. 프로세스 또는 하위 프로세스 내에 존재할 수 있는 최대 CU의 수에 따라 멤버십 번호를 할당할 수 있다. vii. 연결된 기본 CU ID : 다음 유형의 연결된 기본 CU 각각에는 기본 CU ID 유형으로 식별할 수 있는, 고유한 ID가 있다. A. 대체적 CU : 'A'로 시작하는 ID로 기본 CU를 더욱 차별화하고 최대 정의된 크기까지 구성원을 수용한다. 예 : (....Axxxx). B. 순차적 CU : 기본 CU가 트리거될 때 하나 이상의 사건을 통해 영향을 미칠 수 있는 CU이다. 기본 CU는 다른 CU의 영향을 받기 때문에 이전의 순차적 CU를 지정하는 것이 중복된다. 다음 순차적 CU에는 'S'로 시작하는 차 별 번호가 지정된다. 예 : (.....Sxxx). C. 반복적 CU : 이것은 반복적으로 작동하는 CU 내의 CU이며 'RC'로 시작하는 번호가 할당될 수 있다. 예 (......RCxxx). D. 하위 프로세스 CU : 이것은 CU 내의 CU이지만 각 하위 프로세스 CU에 ID를 할당해야 하는 CU 내의 하위 프로 세스이다. 이것은 'SU'로 시작하는 ID를 가질 수 있다. 예 : (........SUxxxx). E. 트랜잭션 CU : 이것은 클래스 레벨 기본 CU에서 허용하는 트랜잭션 소원이 생성될 때 생성된다. 이들은 클래 스 레벨 CU가 허용하는 최대 트랜잭션 수에 따라 차별화된 고유 트랜잭션 번호를 첨부하여 식별된다. 트랜잭션 CU가 하나 생성되더라도, 전체 관련 클래스 수준 프로세스는 트랜잭션 프로세스로 복제되며 그에 따라 번호가 지정된다. viii. CU 내의 계층 : 각 기본 CU에는 물리적 (P), 정보 (I) 및 마인드 (M)의 세 계층이 있다. 이들 각각은 이 니셜로 식별할 수 있다. ix. 독립 개체 슬롯 : 이들은 각 레벨 내의 독립 개체 슬롯이다. 이들은 'E'로 시작하는 정체성을 가지고 있다. 예 : (.......Exxx). x. 레벨 1 속성 슬롯 : 이것은 영숫자 L1A로 식별할 수 있다. xi. 더 많은 속성 레벨 슬롯 : 동일한 방법론을 따라 L2A, L3A 등과 같은 ID를 할당할 수 있다. xii. 조합 개체 상태 : 시스템은 기본 CU 내의 2n 이진 변수 원칙에 따라 각 슬롯에 자동 CES 번호를 할당할 수 있는 가능성을 추가로 제공한다. xiii. 상태 : 독립된 개체 슬롯, 속성 슬롯 또는 CES 슬롯인지 여부에 관계없이, 각 슬롯은 '잠재적'(P) 또는 '현실'(R) 상태로 존재하며 그렇게 식별할 수 있다. xiv. 이 시스템 구현 모델을 사용하여, 변경 유닛 내의 모든 유리한 지점, 계층 및 슬롯에서 CU의 수를 고유하 게 식별할 수 있다. 또한 번호 매기기 시스템은 차별화 원칙에 따라 모든 개체와 개체 간의 거리를 제공한다. b. 일반 개체 ID : 차별화되던지 (고유한) 또는 차별화되지 않든지 (동일한) 개별적인 개체는 고유한 ID를 통해 표현된다. 모든 일반 개체는 실제적이든 대표적이든 물리적 (및 정보적)이다. 일반 개체의 ID 할당은 다음과 같 은 방법으로 수행할 수 있다. i. 클래스 : 이러한 개체는 솔루션 설계자의 선택에 따라 에이전트, 인텐트, 하드 자산, 소프트 자산, 속성 및 돈을 포함하는 제한된 클래스에 속한다. 그들은 CU와 유사한 원칙에 기반한 ID를 가진다. 각 하위 집합의 최대 크기가 먼저 결정되고 하위 집합에 필요한 동일한 자릿수를 기반으로 적절하게 결정된다. ii. 임의의 수의 하위 클래스 : 가장 세분화된 일반 개체가 배치될 때까지 필요에 따라 생성되고 식별된 하위 클래스가 얼마든지 있을 수 있다. 세분성은 솔루션 설계자의 관점에서 중요한 사항에 대한 간단한 원칙을 기반 으로 한다. c. 에이전트 ID : 고유한 에이전트는 고유 ID를 통해 표현된다. 에이전트는 인간 에이전트 또는 기계 에이전트 이다. ID 할당은 에이전트의 유형에 따라 다르다. HUB로서의 NSL : NSL은 자연어 기반 NSL 형식 뿐만 아니라 여러 서브스트레이트에서 솔루션 구성의 배치를 지원 하는 플랫폼 역할을 하는 것으로 프로그래밍, 실습, 텍스트, 프로세스와 같은 여러 서브스트레이트 중 어느 것 에서나 구축된 솔루션의 배치를 허용할 수 있다. 동일한 의미를 다른 언어로 표현할 수 있는 것처럼 솔루션 로 직도 여러 서브스트레이트를 통해 표현할 수 있다. NSL은 프로세스와 정보 사이의 구분을 없앴으며, 프로세스는 특수한 종류의 정보로 작용한다. 정보는 개체의 특성에 따라 표현된다. 모든 고유성은 하나의 서브스트레이트 또는 다른 서브스트레이트를 통해 표현되어야 한다. 정보를 표현하기 위한 서브스트레이트의 존재는 필수이다. 즉, NSL이 준수하는 특정 차별화 주기가 있으며, 여기에서 차별화는 적절하고 상황에 따라 표현되고 NSL에 따른 이러한 차별화는 모든 서브스트레이트에서 표현될 수 있다. NSL은 관련된 진실 값을 잃지 않고 위에서 언급한 여러 서브스트레이트 중 하나에서 솔루션의 실행을 가능하게 하는 허브 역할을 한다. 반투명 솔루션 환경에서 솔루션 로직 추출 : 반투명 솔루션 환경은 솔루션의 일부가 사용자 인터페이스로 표현 되는 바와 같이 투명하고 후드 위에 있고 균형이 후드 아래에 있고 로직이 숨겨져 있는 환경이다. NSL은 TTF를 사용하여, 투명한 솔루션 부분을 NSL로 변환하고 솔루션 라이브러리에 있는 유사한 솔루션을 사용하여 균형을 다시 만든다. SOP를 NSL로 변환 : 도 117을 참조하면, 표준 운영 과정(SOP)은 지시문, 서술문, 순서도 또는 이들의 조합을 포 함한다. 지시문은 조치 또는 변경이 관련되어 있고; 서술문은 정보를 제공하고; 순서도는 다른 문장으로 이어지 는 하나의 문장이다. NSL은 모든 문서의 텍스트를 서술문 및 지시문으로 변환할 수 있고, 여기에서 지시문은 CU 의 물리적 계층과 유사하고, 서술문은 지시문에 정보로 첨부되고 정보 계층에 배치되고, 순서도는 GSI를 달성하 기 위해 상호 작용하는 일련의 LSI와 유사하다. NSL은 추출된 정보에서 중복성을 제거하고 NSL 형식으로 솔루션 을 결합한다. NSL에는 자연어로 작성된 수천 개의 SOP 문서를 구문 분석하여 NSL에 해당하는 파일을 생성하는 분산 문서 구문 분석 시스템이 포함되어 있다. \"Parse2Run\"이라고 하는 이 시스템은 광범위한 적용성, 확장성, 고성능 및 고 이용 가능성을 달성했으며, 자연어로 작성된 SOP 문서를 구문 분석하고 이해할 수 있다. SOP의 구 문 분석은 개체와 개체가 상호 작용하여 프로세스에 대한 이해를 형성하는 방법을 알 수 있다. Parse2Run이 SOP 를 구문 분석하면 이 절차를 실행할 수 있는 NSL 플랫폼의 프로세스에 대한 이해를 번역할 수 있다. Parse2Run 은 자연 솔루션 언어(NSL) 구성을 활용하는 핵심 구성 요소 중 하나이다. Parse2Run의 핵심은 프로세스를 정의 하는 텍스트의 개체 및 요소를 찾는 NLP 엔진이다. 문서를 이해하는 제 1 단계는 문서의 품사를 찾는 것이다. 품사 부분이 이해되면 대명사와 같은 상호 참조를 선행으로 해결한다. Parse2Run은 모호성을 추가로 제거하기 위해 상속 관계를 탐색한다. 그 후에도 문서의 일부는 SOP에 기록된 정보에 대해 똑같이 가능한 해석이 하나 이 상 있을 수 있으므로 이해하지 못할 수 있다. Parse2Run은 이 지점을 표시하고 솔루션 설계자와 대화하여 이를명확히 한다. Parse2Run은 다중 패스 시스템이며 모든 패스에서 특정 측면에 중점을 둔다. Parse2Run은 각 단계 에서 SOP 문서에 대한 이해를 계속 향상시킨다. 다양한 수준의 패스는 다음과 같다: a. 핵심 패스 : Parse2Run은 문서에 대한 핵심 언어 기반 이해를 형성한다. 기본 형태의 단어, 품사, 날짜, 시 간 및 숫자 수량을 정규화하고 구문 및 구문 종속성 측면에서 문장 구조를 표시한다. b. 참조 패스 : 기본적인 이해 수준 이후에, Parse2Run은 동일한 개체를 참조하는 명사구를 찾는다. 이것은 개 념의 검색 공간을 최소화하고 문서의 다른 부분에서 상관이 발생하도록 한다. c. 관계 패스 : Parse2Run은 감정을 찾고, 개체 간의 특정 또는 개방형 관계를 추출하고, 사람들이 말한 인용문 을 가져온다. d. 패스의 이해 : 시스템은 자연어로 표현된 개념을 더 깊이 이해할 수 있는 능력을 갖는다. e. 프로세스 패스 : Parse2Run은 SOP 문서에 기록된 대로 프로세스 자체의 정보를 찾는다. 의미론은 이 정보를 NSL 구조로 변환하는 데 사용된다. f. 강화 패스 : Pars2Run은 이미 큐레이트된 정보에서 개체를 강화한다. 개체 정보는 기존 데이터 모델 또는 사 용 가능한 도메인 모델에서 강화할 수 있다. 이 강화는 속성으로 개체를 업데이트한다. g. 준수 패스 : Parse2Run은 준수 관점에서 프로세스를 강화한다. 규정 준수는 조직에서 제공하거나 특정 산업 에 대해 정부에서 지정할 수 있다. 이 강화 단계를 통해 AI 시스템의 위반 사항에 대해 프로세스를 모니터링할 수 있다. 개발자 개입 최소 개발 : NSL은 개발자 개입 최소 개발 (Developer Less Development; DLD)이라고 하는 프로세 스를 통해 사람의 개입을 최소화하면서 솔루션을 구성하는 기능을 제공한다. DLD는 솔루션 설계를 가속화하기 위해 기계 원조 설계를 제공한다. 솔루션의 시작점과 끝점에 대해 명확하면, DLD는 솔루션 설계자에게 DLD가 솔 루션 라이브러리를 분석한다는 사실을 기반으로 관련성 경로를 선택하고 선택할 수 있는 여러 경로 옵션을 제공 하고, 유사한 솔루션을 식별하고, 솔루션에 대한 가능한 경로를 표시한다. 개발자 개입 최소 개발 (DLD)을 사용 하면 지도 및 비지도 기계 학습 모델을 구현하여 솔루션 클래스를 자동화하고 추천할 수 있다. DLD는 지도 학습 접근 방식을 사용하여 LSI 또는 변경 유닛 최근접 이웃 추천을 자동화하는 데 초점을 맞춘 솔루션 클래스의 완 전 자동화를 제공한다. 본 개시는 기계 학습 예측을 하기 위해 NSL에서 최근접 이웃 개념을 사용한다. NSL은 변 경 드라이버에서 변경 유닛까지 높은 수준의 유사성을 가지고 있다. 여러 트랜잭션이 발생하면 명확한 패턴이 있으며 기계가 이를 인식한다. DLD는 솔루션 생성자에게 추천하기 위해 솔루션 클래스 및 트랜잭션 클래스 정보 를 모두 사용한다. 도 116에서 보는 바와 같이, 다양한 프로그램, 비디오, SOP, 드림 개발자 제작 콘텐츠에서 TTF 계층을 통해 솔루션 콘텐츠가 추출되었다. DLD 엔진은 NSL 솔루션 라이브러리의 일부인 풍부한 솔루션 콘텐 츠를 마이닝한다. 또한 트랜잭션 클래스로부터 트랜잭션 데이터를 추출하여 DLD 엔진에 입력하여 다양한 수준에 서 거리를 식별할 수 있다. 거리 계산은 기계 학습 알고리즘을 사용하여 NSL 개체 값, 시간 및 공간을 사용하여 수행할 수 있다. DLD 엔진은 솔루션 콘텐츠를 처리하기 위해 NLP, ANN, 최근접 이웃의 기술/구성 요소를 사용한 다. NLP 기술에는 명명된 개체 인식, 단어 명확화, 개체 동의어 구성 요소가 포함된다. ANN 기술에는 확률 모델, 문장 인코더, 딥 러닝 구성 요소가 포함된다. 최근접 이웃의 기법에는 pysparr-NN, 개체 거리, 상관 계수 성분이 포함된다. DLD 엔진은 예측을 위해 다양한 순열과 조합에 대해 확률 모델을 사용한다. NSL 물리적 장벽 극복 : 정보 제공 측면에서 세계가 점점 더 많이 보여지고 있다. 정보는 물리적 개체를 나타내 는 데 사용되며 여러 물리적 개체가 각 솔루션에 표시된다. 진실 값이 유지되는 한 물리적 개체는 여러 방식으 로 표현될 수 있다. 고유한 개체는 단어로 표시되고 동일한 개체는 숫자로 표시된다. 예 : 책, 2 권. 프로그래 밍 세계에서, 솔루션이 생성되지만 데이터가 데이터베이스에 저장되면 컨텍스트가 손실된다; 그 물리적 개체를 이해하기 위해 컨텍스트를 다시 만들어야 한다. 따라서 해당 물리적 개체에 대해 저장된 정보는 실제 물리적 개 체를 정확하게 식별하는 데 부적절한다. 또한 하나의 물리적 개체에 대한 많은 추론이 생성되어 많은 문서를 생 성하게 된다. 물리적 개체의 변경은 해당 개체가 사용되는 모든 참조에 영향을 주지 않는다. NSL은 전체 계보를 유지하고 \"진실 가치\"가 유지되는 한 정보 모델에서 해당 물리적 개체의 표현은 정확하고 동적이다. 예 : 사람 은 정보 묶음이고, 그 사람의 이름은 그 사람의 속성이고, 그의 ID는 그 사람의 숫자 표현 등이다. 오른쪽 서브 스트레이트는 올바른 매체에서 동일한 정보를 사용할 수도 있다. 예 : 기계는 숫자 값을 잘 처리하고 인간은 동 일한 물리적 개체의 시각적 표현을 더 잘 처리한다. NSL 프로세스 장벽 극복 : 전형적으로 프로그래밍 세계에서는 명령어 세트 (프로세스/기능/알고리즘)와 (입력/ 출력) 데이터 세트 사이에 강하게 분리된다. 따라서 프로세스 흐름에 포함된 모든 로직, 프로세스를 통해 흐르는 정보, 프로세스의 상태는 모두 불투명하고 후드 아래에 있다 (프로그램은 때때로 일부 보기를 제공하기 위해 파일에 상태를 기록한다). NSL에서 전체 솔루션 로직은 차별화를 기반으로 솔루션 클래스로 표현된다. 이렇게 구성된 로직은 사례가 도착하기 시작할 때 런타임에 재생된다. 이는 전체 솔루션을 매우 투명한 방식으로 정의 하는 CES 상태 및 E-CES 상태로 이어진다. 따라서 전체 불투명한 프로세스 구성은 매우 투명하고 \"후드 위에\" 있는 정보로 변환된다. 정보로 표현되면 자동으로 검색이 가능한다. NSL 클래스 장벽 극복 : 솔루션 로직은 클래스 레벨 (솔루션 클래스라고 함)에서 정의된다. 트랜잭션 클래스는 사례가 런타임에 이러한 솔루션 클래스에 도착하고 정의된 솔루션 로직이 실행될 때 형성된다. 따라서 (차별화 된) 클래스 수준에서 정의된 로직은“펜, 종이, 사람”이고, 트랜잭션 수준에서는 이것은 \"이 펜, 이 종이, 이 사람\" 등이 된다. 프로그래밍 언어에서 데이터가 추가 컨텍스트 없이 저장되는 경우 (데이터베이스에) 해당 데 이터 세그먼트를 속한 특정 클래스에 연결할 수 없다. 따라서 (솔루션 로직 포함하는) 클래스와 (솔루션 로직을 실행하는) 사례 사이의 모든 관계가 손실되고 해당 컨텍스트를 매번 다시 만들어야 하므로 데이터를 분석해야 한다. NSL에서, 솔루션 로직은 (문장으로 표현되는) 정보의 특수 클래스로 표현되며 재생됨에 따라 그 멤버 (데 이터베이스)가 이에 매달려 있다. 따라서 NSL은 전체 여정과 전체 컨텍스트를 기록하고 (컨텍스트 ID 사용) 멤 버와 이들의 각각의 클래스와의 연관성은 데이터베이스에 데이터로 유지된다. 따라서 NSL은 개체 간의 거리를 측정하고 상관 관계 및 확률을 설정하는 효율적이고 효과적인 방법을 제공한다. NSL UI 장벽 극복 : 프로그래밍 언어에서, (그래픽) UI는 일반적으로 입력 및 출력 필드 값을 렌더링한다, 구성 요소의 위치는 프로그래머가 시스템을 구축 할 때 결정한대로 고정된다. 이것은 정보를 렌더링하는 매우 융통성 없는 방법이며 모든 변경 사항은 코드 수준에서 수행하고, 다시 테스트된 다음에 게시된다. NSL은 차별화를 기 반으로 하기 때문에, NSL은 사용자 인터페이스 속성을 렌더링해야 하는 엔티티의 추가 차별화를 활용하며, 예를 들어, 구성 요소가 화면에 나타나는 글꼴 크기, 색상, 이 화면에 구성 요소는 렌더링하는 시작 위치 등은 개체 속성으로 첨부되는 추가 차별화에 불과하다. 따라서 시스템은 (다양한 화면 크기에 대해) 이러한 최적의 차별화 된 값을 기반으로 자체 렌더링될 수 있다. NSL 화면 장벽 극복 : 기존 시스템은 컴퓨터 화면에서 UI를 GUI로 렌더링하는 데 제한이 있다. 따라서 대부분의 부분에 사용자는 터미널에 갇혀 있고 이것이 기술 솔루션과 상호 작용하는 유일한 메커니즘이다. NSL은 감각 기 반 인터페이스 (예 : 터치, 시각, 후각, 청각, 미각을 활용하여 다양한 솔루션과 상호 작용할 수 있는 솔루션) 를 사용하여 \"화면 밖으로 점프\"할 수 있는 기능을 사용자 인터페이스 및 경험을 제공한다. 이는 NSL이 개체 기 반 모델이고 개체 및 상호 작용이 패턴 인식을 통해 이해될 수 있다는 사실 때문이다. 예 : 카메라는 눈 역할을 하여 세상을 볼 수 있다. NSL 모호성 장벽 극복 : 전통적으로 비즈니스 이해 관계자와 기술자 사이에는 큰 불명확성이 있다. 각자는 지식 의 경계를 가지고 있다. 지식의 전달과 해석에는 격차가 있다. 그런 다음 팀은 해석을 더욱 복잡하게 만든다. 기술 팀원의 소모는 프로세스를 더욱 악화시킨다. 솔루션을 민주화함으로써 NSL은 기술 전문가가 NSL에서 솔루 션을 구축할 필요가 없기 때문에 비즈니스 이해 관계자가 스스로 솔루션을 구축할 수 있도록 권한을 부여하고; 따라서 모호성 장벽을 제거할 수 있다. NSL 마인드 장벽 극복 : 일반적으로 현재 세계는 분석을 특수 기능으로 보고이를 선택 사례에서 사용한다. NSL 에서 마인드가 내재된 중첩된 변경 유닛은 생태계를 지속적으로 기록하고 분석하는 모든 변경 유닛에 필수적이 다. 중첩된 마인드는 의식적인 마인드를 모방하고 상황 인식과 반응을 가지고 있다. 내포된 마인드는 실시간 분 석을 하고 과거, 현재, 미래를 분석할 수 있는 힘을 가지고 있으며 현재 또는 미래에 수행할 모든 행동을 선택 할 수 있다. NSL 인간 장벽 극복: 기계가 자연어를 이해하도록 훈련하고 잘 구성된 라이브러리의 세계로 권한을 부여함으로 써, NSL은 덜 자동차를 운전하는 것처럼 개발자저 개발의 시대를 열었다. 기계는 시작점과 희망 사항이 지정되 면 정확한 구조를 제공할 수 있으므로, 솔루션을 작성하는 데 인간에 대한 과도한 의존성을 제거할 수 있다. NSL은 사람과 기계를 동일시함으로써 솔루션 개발에 완전히 새로운 변화를 가져온다. 개발자 개입 최소 개발은 사용 가능한 정보를 사용하여 클래스 및 트랜잭션 수준 모두에서 SSA주기를 사용하여 솔루션을 변경하는 동적 의사 결정으로 이어진다. NSL 인간-기계 장벽 극복 : 현재 자연어와 프로그래밍 언어의 두 가지 코드가 있다. SSA 주기는 인간 에이전트 와 기계 에이전트 모두에 내재되어 있다. 두 코드를 모두 동일시함으로써 NSL은 인간 및 기계 에이전트 시스템 에 존재하는 SSA 주기를 소외시켜 차이를 없애 준다. NSL은 기계와 사람이 친구처럼 대화할 수 있게 하는 솔루 션의 보편적인 언어이다. 이들은 입력에 대한 응답으로 적절한 출력이 생성되도록 - 인간 에이전트 또는 기타기계 에이전트가 설계한 대로 - 변경 유닛이 기계 에이전트에 의해 구동되는 '컴퓨터'와 동의어이다. 기계 에이 전트는 기본적으로 입력을 소비하고, 통제된 변경을 가져오고 (이러한 입력을 처리) 출력을 생성하는 능력에서 인간 에이전트를 모방한다. 어떤 의미에서, 인간 에이전트는 구동 목적의 자질을 기계 에이전트에게 부여한다. 사례 및 도면의 설명 사례 1은 자바 프로그래밍 언어로 작성된 호텔 예약 시스템 프로그램의 컨텍스트에서 수행된 NSL의 테스팅에 관 한 것이다. 이 Java 프로그램은 700 줄의 코드를 포함하며 NSL로 효과적으로 대체된다. 그 후, NSL은 '기술 프 레임워크 (NSL-TF)'를 사용하여, Java 프로그램과 동일한 결과를 내는 테스트를 거쳤다. 사례 2는 NSL 기술 번역 프레임워크 (NSL-TTF)의 테스팅에 관한 것이다. NSL-TTF는 파이썬 프로그래밍 언어로 작성된 호텔 예약 시스템 프로그램을 자동으로 소비하고 NSL로 변환한다. 이러한 NSL-TTF 생성 NSL은 NSL-TF에 공급되어 원래 파이썬 프로그램과 동일한 결과를 효과적으로 생성하여 NSL이 과거에 작성된 모든 코드를 처리할 수 있음을 확인한다. 사례 3은 NSL 기술 재변환 프레임워크 (NSL-TRF)의 테스팅에 관한 것이다. NSL-TRF는 NSL로 작성된 ATM 서비스 솔루션을 자동으로 파이썬 및 C 프로그램으로 소비하고 변환한다. 프로그램은 NSL의 원래 솔루션과 동일한 결과 를 생성했다. 사례 1 사례 1과 관련된 도면은 도 95 내지 103을 포함한다. 자바 프로그램의 목표는 사용자가 세 가지 유형의 호텔 객 실을 예약할 수 있는 호텔 예약 시스템 애플리케이션은 사용자로 하여금 세 가지 유형의 교통 및 세탁 서비스를 선택하는 옵션과 함께 디럭스, 슈퍼 디럭스, 럭셔리 등, 세 가지 유형의 객실을 선택할 수 있도록 한다."}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "사례 1 단계 1 : Java 프로그램 및 NSL 솔루션 요약 : a) 호텔 예약 시스템 자바 프로그램은 700 줄의 코드로 구성된다; b) 코드는 Java 프로그램의 키워드 16 개, 연산자 6 개 및 기호 5 개를 사용한다; c) 이 시스템은 96 개의 시나리오를 다룬다; d) 13 개의 독립 개체, 90 개의 종속 개체 (속성) 및 18 개의 LSI를 사용하여 동일한 솔루션이 자연 솔루션 언어로 구축된다. 이 18 개의 LSI는 96 개의 시나리오를 처리할 수 있다; e) 도 95는 Java 프로그램 및 해당 NSL 솔루션의 표현 예를 보여주는 도면이다; 및 f) 도 96은 기술 번역 프레임워크를 사 용하여 Java 프로그램을 NSL 솔루션으로 번역한 예를 보여주는 도면이다. 사례 1 단계 2 : NSL이 프로그래밍 코드에서 솔루션 로직을 캡처하는 방식 : NSL 구조는 중요한 개체를 모으는 것에 관한 것이다. 이것은 자연어와 거의 비슷하기 때문에 매우 직관적이다. NSL에서 솔루션을 구축하는 순서는 다음과 같다. a) 독립 개체 생성 (명사에 해당). b) 차별화를 위해 개체에 속성을 첨부한다 (형용사와 부사에 해당). c) 변경 유닛/조합 개체 생성 (문장과 동일). d) 변경 유닛/로컬 의도 진술을 함께 묶어 글로벌 의도 진 술 (단락과 동일)을 생성한다. e) 적용 가능한 경우 규칙, 제약 조건, 공식을 속성으로 첨부한다. f) 도 97a는 Java 프로그램과 NSL 등가물의 일대일 매핑을 통해 속성이 있는 개체 생성 표현의 예를 보여주는 도면이다. g) 도 97b는 Java 프로그램을 NSL에 상응하는 일대일 매핑을 통해 NSL의 기능 표현의 예를 보여주는 도면이다. 사례 1 단계 3 : 정적 상태에서 동적 상태로의 변환 : a) 솔루션이 NSL에서 구성되면 LSI는 정적/잠재적 상태에 있다. 사건에 도달하면 (예 : 거래가 발생하는 경우), 조합 개체 상태는 정적/잠재적에서 동적/현실로 변환된다. b) 도 98a는 솔루션이 구성될 때 정적 상태의 단락 표현의 예를 보여주는 도면이다. c) 도 98b는 \"고 객 정보를 캡처할 때 사건 도달\"로 정적에서 동적으로 변하는 문장의 표현 예를 보여주는 도면이다. d) 도 98c 는 정보가 채워 졌을 때 동적 상태에 있는 단락 표현의 예를 보여주는 도면이다. 사례 1 단계 4 : NSL 및 Java에서 출력이 동일한지 확인 : NSL에 구축된 Java 애플리케이션과 솔루션은 여러 시 나리오를 다루는 다양한 입력을 사용하여 테스트된다. Java 애플리케이션의 출력과 NSL 솔루션의 출력은 두 애 플리케이션에서 동일한 입력이 주어지면 동일하다. a) 도 99a는 Java 프로그램의 입력 및 출력 표현의 예를 보 여주는 도면이다. b) 도 99b는 NSL 솔루션의 입력 및 출력 표현의 예를 보여주는 도면이다. 사례 1 단계 5 : NSL을 지원하는 기술 프레임워크 : NSL은 임의의 운영 체제와 공존하는 기술 프레임워크에 의 해 지원된다. 프레임워크의 기본 원칙은 개체와 그 관계에 대한 차별화 경로를 마련하는 것이다. 기술 프레임워 크는 NSL의 모든 원칙이 규정되어 표준화되어 있으며 애플리케이션 로직에 관계없이 동일하게 유지된다. 프레임워크에는 다음과 같은 주요 구성 요소가 있다. a) 데이터베이스 관리 b) 사용자 인터페이스 관리 c) 개체 를 에이전트에 연결 d) 정보 검색 원칙 e) 프레임워크는 다음과 같은 모든 종류의 시나리오를 다룬다: i) 판정 : 프레임워크에서 제공되는 속성 구조는 사용자가 각 단락을 고유하게 구별하는 데 도움이 된다. 프레임워크는가능한 모든 시나리오가 독립적 인 단락으로 저장되도록 제공했다. ii) 공유된 개체 : 기술 프레임워크는 정의 된 모든 곳에서 공간 및 시간 사건을 캡처하여 패턴 인식 및 추정을 가능하게 한다. 이를 통해 사용자는 다음 활동에 개체를 사용할 수 있는 시기를 추정할 수 있다. iii) 독립 단락 : 기술 프레임워크는 모든 단락을 독립 단락으로 구분한다. 도 100a는 데이터베이스 관리의 표현의 예를 보여주는 도면이다. 도 100b는 사용자 인터페이스를 관리하는 표현 의 예를 보여주는 도면이다. 도 100c는 개체를 에이전트에 연결하는 표현의 예를 보여주는 도면이다. 사례 1 단계 6 : 운영 메트릭 - Java v/s NSL : 도 101은 NSL 및 Java에서 호텔 예약 시스템 솔루션을 구축하 는 데 필요한 시간, 노력 및 비용을 설명하는 운영 메트릭 표현의 예를 보여주는 도면이다. 사례 1 단계 7 : NSL이 키워드, 운영자 및 기호를 주소 지정하는 방식 : 호텔 예약 시스템 자바 프로그램은 16 개의 키워드, 6 개의 운영자 및 5 개의 기호를 사용했다. 다음은 NSL이 이러한 각 키워드, 연산자 및 기호를 처 리하는 방법에 대한 설명이다. 키워드 \"Public\": 도 97a 및 97b는 키워드 \"공개\"가 Java에서 사용되는 방식과 NSL에서 표시되는 방식을 나타낸 다. 키워드 \"Int\": 도 97a 및 97b는 키워드 \"Int\"가 Java에서 사용되는 방식과 NSL에서 표시되는 방식을 나타낸다. 키워드 \"Char\": 도 102a는 키워드 \"Char\"가 Java에서 사용되는 방식 및 NSL에서 표시되는 방식의 예를 보여주는 도면이다. 키워드 \"String\": 도 102b는 키워드 \"문자열\"이 Java에서 사용되는 방식 및 NSL에서 표현되는 방식의 예를 보여 주는 도면이다. 키워드 \"Double\": 도 102c는 키워드 \"Double\"이 Java에서 사용되는 방식 및 NSL에서 표시되는 방식의 예를 보여 주는 도면이다. 키워드 \"Boolean\": 도 97a는 키워드 \"Double\"이 Java에서 사용되는 방식 및 NSL에서 표시되는 방식의 표현의 예 를 보여주는 도면이다. 키워드 \"For\": 도 102d은 키워드 \"For\"가 Java에서 사용되는 방식 및 NSL에서 표시되는 방식의 예를 나타내는 도면이다. 키워드 \"While\": 도 102e는 키워드 \"While\"이 Java에서 사용되는 방식과 NSL에서 표현되는 방식의 예를 보여주 는 도면이다. 키워드 \"If\": 도 102f는 키워드 \"If\"가 Java에서 사용되는 방식 및 NSL에서 표시되는 방식의 표현의 예를 나타 내는 도면이다. 키워드 \"Else\": 도 102f는 키워드 \"Else\"가 자바에서 사용되는 방식과 그것이 NSL에서 표현되는 방식을 나타낸 다. 키워드 \"Break\": 도 102g는 키워드 \"Break\"가 Java에서 사용되는 방식 및 NSL에서 표시되는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"Return\": 도 97b는 키워드 \"Return\"이 Java에서 사용되는 방식과 NSL에서 표시되는 방식을 나타낸다. 키워드 \"인쇄\": Java의 \"인쇄\" 키워드는 인쇄 기능에 사용된다. NSL에서 print는 개체에 속성으로 첨부된 \"사용 자 인터페이스\"로 표시된다. 키워드 \"Class\": 도 97a는 키워드 \"Class\"가 Java에서 사용되는 방식과 NSL에서 표현되는 방식을 나타낸다. 키워드 \"Package\": 도 97a 및 97b는 키워드 \"Package\"가 Java에서 사용되는 방식과 NSL에서 표현되는 방식을 나타낸다. 키워드 \"Import\": 도 97a는 키워드 \"Import\"가 Java에서 사용되는 방식과 그것이 NSL에서 표현되는 방식을 나타 낸다. NSL에서, 이들은 재사용 가능한 구성 요소이다. 기호 \"{}\": 도 97a는 기호 \"{}\"가 Java에서 사용되는 방식과 NSL에서 표시되는 방식을 나타낸다. 기호 \"()\": 도 97b는 기호 \"()\"가 Java에서 사용되는 방식과 NSL에서 표시되는 방식을 나타낸다. 기호 \";\": 자바의 \";\" 기호는 명령문을 종료하는 데 사용된다. NSL에서는 \".\" 는 문장을 끝내는 데 사용된다. 기호 \",\": 자바의 \",\"기호는 변수를 구별하는 데 사용된다. NSL에서 개체는 첨부된 속성으로 구별된다. 기호 \"[]\": Java의 \"[]\" 기호는 기능을 나열하는 데 사용된다. NSL에서 차별화는 다음 레벨 속성을 통해 수행된 다. 연산자 \"=\": NSL에서 이 산술 연산자는 개체에 값을 첨부하여 사용된다. 연산자 \"==\": 도 97b는 연산자 \"==\"가 Java에서 사용되는 방식과 NSL에서 표현되는 방식을 나타낸다. 연산자 \"<\": 도 102d는 연산자 \"<\"가 Java에서 사용되는 방식 및 NSL에서 표시되는 방식을 나타낸다. 연산자 \"+\": NSL에서 공식으로 정의되고 속성으로 첨부된다. NSL OS는 모든 산술 기능을 처리할 수 있다. 연산자 \"-\": NSL에서 공식으로 정의되고 속성으로 첨부된다. NSL OS는 모든 산술 기능을 처리할 수 있다. 연산자 \"*\": 이것은 NSL에서 공식으로 정의되고 속성으로 첨부된다. NSL OS는 모든 산술 기능을 처리할 수 있다. 사례 1 단계 8 : NSL이 프로세스를 제거하는 방식 : NSL은 프로세스와 기능을 정보로 변환하고 애플리케이션 로 직을 정보 검색 원칙의 영역으로 가져온다. 따라서, Java 프로그램의 내부에 있던 모든 기능은 NSL의 최종 사용 자도 볼 수 있다. 도 103은 프로세스를 정보로 변환하는 표현의 예를 나타내는 도면이다. 사례 2 사례 2와 관련된 도면은 도 104 내지 108b를 포함한다. NSL에는 프로그래밍 코드를 사용하고 동등한 NSL 애플리 케이션 로직을 자동으로 생성하는 독점 기술 번역 프레임워크가 있다. 그런 다음 NSL 기술 프레임워크를 사용하 여 모든 프로그래밍 언어로 작성된 프로그램과 동일한 결과를 생성할 수 있다. 사례 2는 NSL 기술 번역 프레임워크가 파이썬 프로그래밍 코드와 관련하여 작동함을 증명한다. 이를 테스트하기 위해 호텔 예약 시스템 프로그램 코드가 선택된다. 파이썬 프로그램의 출력은 사용자가 세 가지 유형의 교통 및 세탁 서비스를 선택할 수 있는 옵션과 함께, 디럭스, 슈퍼 디럭스, 럭셔리의 세 가지 유형의 호텔 객실을 예약 할 수 있는 호텔 예약 시스템 애플리케이션이다. 개체, 속성, 변경 유닛 및 변경 유닛 (애플리케이션 로직) 간의 관계는 번역기에 의해 파이썬 프로그램에서 자 동으로 추출되고 추출된 구성 요소는 자동으로 파이썬 프로그램과 동일한 출력을 생성하는 NSL로 공급된다. 도 104는 NSL 기술 번역 프레임워크 방법론의 표현의 예를 보여주는 도면이다."}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "사례 2 단계 1 : 파이썬 프로그램 및 NSL 솔루션 요약 : a) 호텔 예약 시스템 파이썬 프로그램은 391 줄의 코드 로 구성된다. b) 코드는 파이썬 프로그램의 8 개의 키워드, 4 개의 연산자 및 4 개의 기호를 사용한다. c) 이 시스템은 96 개의 시나리오를 다룬다. d) 13 개의 독립 개체, 90 개의 종속 개체 (속성) 및 18 개의 LSI를 사용 하여 동일한 솔루션이 자연 솔루션 언어로 구축된다. 이 18 개의 LSI는 96 개의 시나리오를 처리할 수 있다. e) 도 105는 파이썬 프로그램과 NSL 솔루션의 표현 예를 보여주는 도면이다. 도 106은 몇 가지 Java 구성 및 이에 상응하는 NSL 등가물의 예를 보여주는 표이다. 사례 2 단계 2 : NSL 기술 번역 프레임워크 - 사용된 방법론 : NSL의 기술 번역 프레임워크는 일반적으로 사용 되는 기존 프로그래밍 언어와 해당 NSL에 해당하는 키워드, 연산자 및 기호의 컴파일을 사용한다. 다음은 번역 자가 다음 용어를 다루는 몇 가지 키워드 및 해당 NSL에 해당하는 목록이다. 키워드 \"Static\": 도 107a는 키워드 \"Static\"이 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방 식의 표현의 예를 보여주는 도면이다. 키워드 \"Switch\": 도 107b는 키워드 \"Switch\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방 식의 표현의 예를 보여주는 도면이다. 키워드 \"Case\": 도 197b는 키워드 \"Case\"가 프로그래밍에서 사용되는 방식과 그것이 NSL에서 표현되는 방식을 나타낸다. 키워드 \"Continue\": 도 107c는 키워드 \"Continue\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"Transient\": 도 107d는 키워드 \"Transient\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되 는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"Long\": 도 107e는 키워드 \"Long\"이 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"Short\": 도 107f는 키워드 \"Short\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식 의 표현의 예를 보여주는 도면이다. 키워드 \"Byte\": 도 107g는 키워드 \"Byte\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"Default\": 도 107h는 키워드 \"디폴트\"가 프로그래밍에서 사용되는 방식과 그것이 NSL에서 표현되는 방 식의 표현의 예를 보여주는 도면이다. 키워드 \"Super\": 도 107i는 키워드 \"Super\"가 프로그래밍에서 사용되는 방식과 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"protected\": 도 107j는 키워드 \"보호됨\"이 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"This\": 도 107k는 키워드 \"This\"가 프로그래밍에서 사용되는 방식과 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"Synchronized\": 도 107l은 키워드 \"Synchronized\"가 프로그래밍에서 사용되는 방식과 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"strictfp\": 도 107m은 키워드 \"Strictfp\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 키워드 \"final\": 도 107n은 키워드 \"final\"이 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식 의 표현의 예를 보여주는 도면이다. 사례 2 단계 3 : 출력이 NSL 및 파이썬에서 동일한지 확인 : 기술 번역기 프레임워크를 사용하여 NSL에 구축된 파이썬 애플리케이션 및 솔루션은 여러 시나리오를 다루는 다른 입력을 사용하여 테스트되었다. 파이썬 애플리 케이션의 출력과 NSL 솔루션의 출력은 두 애플리케이션에서 동일한 입력이 주어지면 동일하다. 도 108a는 파이썬 프로그램의 입력 및 출력 표현의 예를 보여주는 도면이다. 도 108b는 NSL 솔루션의 입력 및 출력의 표현의 예를 보여주는 도면이다. 사례 3 실시 예 3과 관련된 도면은 도 109 내지 112를 포함한다. NSL는 모든 NSL 솔루션을 사용하고 모든 주요 프로그 래밍 언어로 동등한 프로그래밍 코드를 자동으로 작성하는 독점 기술 재번역 프레임워크를 구비한다. 사례 3은 NSL 기술 재번역 프레임워크가 파이썬 및 C 프로그램으로의 변환을 위해 작동함을 증명한다. 이를 테 스트하기 위해 ATM 서비스 솔루션이 선택되었다. NSL 솔루션의 출력은 사용자가 입금 전표를 작성하고 창구 직 원이 전표를 확인하고 수표를 확인할 수 있도록 하는 기능이다. NSL-TRF의 공통 논리 트리는 NSL 노드 별로 모든 개체, 속성, 변경 유닛 및 변경 유닛 (애플리케이션 로직) 간 의 관계를 추출하고 구성 매개 변수 추가, 변수 및 데이터 유형 목록 생성, 및 사전 생성과 같은 일련의 단계를 수행하여 타일 기반 구조를 사용하여 프로그래밍 언어로 코드를 작성한다. 도 109는 NSL 기술 재번역 프레임워크 방법론의 표현의 예를 보여주는 도면이다."}
{"patent_id": "10-2021-7021130", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "사례 3 단계 1 : NSL 솔루션 및 동등한 파이썬 및 C 프로그램의 요약 : NSL 솔루션은 3 개의 변경 유닛과 8 개의 개체로 구성된다. 동일한 솔루션이 파이썬 프로그램에서 21 줄의 코드로 변환된다. 동일한 솔루션이 C 프로그램에서 33 줄의 코드로 변환된다. 도 110은 입력 및 출력을 갖는 NSL 솔루션 및 등가의 파이썬 및 C 프로그램의 표현의 예를 보여주는 도면이다. 사례 3 단계 2 : NSL 기술 재번역 프레임워크 - 사용된 방법론 : NSL의 기술 재번역 프레임워크는 일반적으로 사용되는 기존 프로그래밍 언어와 이들의 NSL 등가에 해당하는 키워드, 연산자 및 기호의 컴파일을 사용한다. 사례 3 단계 3 : NSL-TRF는 개체와 그 관계를 추출하기 위해 공통 논리 트리를 사용한다. 코드 생성기는 선택한 프로그래밍 언어로 코드를 생성한다. 도 111은 공통 논리 트리에 의해 생성된 출력의 예를 보여주는 도면이다. 도 112는 NSL에서 프로그래밍 언어로의 코드 생성의 예를 보여주는 도면이다. 도면과 관련된 NSL 용어 솔루션 설계 : 도 107a 내지 107c은 솔루션 설계의 표현의 예를 보여주는 도면이다. 개체 : 도 97a는 샘플 개체를 나타낸다. 도 2는 또한 구별되는 것은 모두 개체임을 나타낸다. 차별화된 개체 : 도 97a는 차별화된 개체를 나타낸다. 도 3은 펜과 종이가 구별되고 다른 개체인 차별화된 개체 를 나타낸다. 비 차별화된 개체 : 도 4는 두 개의 펜이 별개이지만 동일한 개체인, 차별화되지 않은 개체를 나타낸다. WWW 원칙 : 자명적 잠재적 개체 대 비 잠재적 개체 : 도 97a는 잠재적 개체 \"호텔 객실\"을 나타낸다. 잠재적 개체 상태 : 도 1 및 도 98a는 잠재적 개체 상태를 나타낸다. 실제 개체 상태 : 도 1 및 도 98c는 실제 개체 상태를 나타낸다. 솔루션 생태계 :도 6은 솔루션 생태계를 나타낸다. 전능 개체 : 도 8은 전능 개체를 나타낸다. 독립 개체 : 도 97a는 독립 개체인 \"호텔 객실\"을 묘사한다. 도 9는 그 속성을 함께 드래그한 독립적 개체의 예 이다. 암묵적 개체 : 도 97b에서 기계 에이전트는 암묵적 개체이다. 도 10은 암묵적 개체를 나타낸다. 동결 개체 : 도 97a에서 호텔 객실은 고정 개체이다. 도 11은 솔루션 설계자가 잠재적 또는 현실의 이진 상태에 있는 것으로 간주하는 고정 개체를 나타낸다. 개체의 삭제 : 도 12는 개체의 삭제를 나타낸다. 개체의 생성 : 도 97a는 개체 \"호텔 객실\"의 생성을 도시한다. 도 12는 개체 생성을 또한 나타낸다. 개체의 수정 : 도 13은 개체의 수정을 나타낸다. 속성 : 도 97a는 개체 \"호텔 객실\"에 속성의 추가를 도시한다. 도 14는 그 존재를 위해 어떤 다른 개체에 대한 속성의 종속성을 나타낸다. 필수 속성 : 도 15는 개체와 관련하여 항상 존재하는 필수 속성을 나타낸다. 표준 속성 : 도 16은 솔루션 환경에 기초한 속성의 표준화를 나타낸다. 일반 속성 : 도 17은 개체가 솔루션 환경 내에 배치되는 상황을 기반으로 사용하기 위해 선택되는 일반 속성을 나타낸다. 속성 레벨 : 도 18은 속성 레벨을 나타낸다. 실제 개체 : 도 19는 자연에 물리적으로 존재하는 실제 개체를 나타낸다. 도 97a는 또한 실제 개체 \"호텔 객 실\"을 나타낸다. 표현 개체 : 도 20은 다른 실제 개체 또는 다른 표현 개체를 나타내는 개체를 나타낸다. 지각 개체 : 도 21은 주어진 신경 상태의 형태로 자신의 뇌에서 자연적으로 인간 에이전트에 의해 생성되는 개 체를 나타낸다. 정보 개체 : 도 22는 정보 개체를 나타낸다. 진리 값 : 도 23은 진리 값에 대한 이해를 나타낸다. 정보 콘텐츠-실제 대 표현 : 도 20은 다른 실제 개체 또는 다른 표현 개체를 나타내는 개체를 나타낸다. 물리적 현실 : 도 97a에서 \"호텔 객실\"은 물리적 현실에 존재하는 개체이다. 도 24는 또한 모든 개체가 물리적 세계에 물리적으로 존재하는 것을 나타낸다. 변경 유닛 : a) 로컬 의도 진술 : 도 98a는 LSI 및 GSI를 포함한다. 도 25는 로컬 의도 진술과 글로벌 의도 진 술을 나타낸다. b) 글로벌 의도 성명서 : 도 98a는 LSI 및 GSI를 포함한다. 도 25는 로컬 의도 진술과 글로벌 의도 진술을 나타낸다. 변경 유닛의 크기 : 도 26은 변경 유닛의 크기를 나타낸다. 사건 : a) 이진 상태 : 도 99a는 잠재적 상태의 각 개체를 나타낸다. 도 27은 개체의 이진 상태를 나타낸다. b) 변동성 : 도 28은 변동성을 나타낸다. c) 상수 : 도 29는 상태가 항상 동일하게 유지되는 개체를 나타낸다. 입력 : 도 99b는 솔루션의 입력 및 출력을 나타낸다. 도 30은 입력과 출력을 나타낸다. 출력 : 도 99b는 솔루션의 입력 및 출력을 나타낸다. 도 30은 입력과 출력을 나타낸다. 경과 시간 : 도 60은 경과 시간을 나타낸다. 솔루션의 전체 수명주기 : 도 67은 솔루션의 전체 수명주기를 나타낸다. 자연어 : 도 31은 자연어가 작동하는 방식을 나타낸다. 코드 대 자연어 : 도 58은 코드와 자연어 간의 차이를 나타낸다. 자연 솔루션 언어 : a) 정적 의도 진술 : 도 99a는 정적 상태의 의도 진술을 나타낸다. 도 32는 의도를 표현할 뿐 현실로 변환하는 능력이 부족한 정적 의도 진술도 나타낸다. b) 동적 의도 진술 : 도 99c는 동적 상태에서 의도 진술 표현의 예를 보여주는 도면이다. 도 33은 또한 개체를 유발하는 기본 변환인 동적 의도 진술을 나타 낸다. 의미 대 가치 : 도 59는 의미와 가치 사이의 차이를 나타낸다. 값의 정량화 : 도 61은 값의 정량화를 나타낸다. 값의 상대성 : 도 62는 값의 상대성을 나타낸다. 자연어와 NSL 간의 공통성 : 도 52는 자연어와 자연 솔루션 언어 (NSL) 간의 공통성을 나타낸다. 로직 단락 : 도 63은 로직 단락을 나타낸다. NSL 라이브러리 : 도 55는 NSL 라이브러리를 나타낸다. 재사용 가능한 구성 요소 : 도 97a는 호텔 객실과 재사용 가능한 구성 요소인 그 속성을 나타낸다. 도 53은 또 한 구성 요소의 재사용성을 나타낸다. 차별화 원리 : 도 34는 차별화 원리를 나타낸다. 유리한 지점 : 도 35는 유리한 지점을 나타낸다. 방향성 : 도 36은 차별화 트리를 위 또는 아래로 이동하는 컨텍스트에서 방향성을 나타낸다. 조합 개체 상태 : 도 99b는 사건에 도달할 때 트리거가 발생하는 트리거 조합 개체 상태를 나타낸다. 도 37은 또한 비 트리거 및 트리거 조합 개체 상태(CES)를 나타낸다. API 대 프로그램 : 도 65는 API와 프로그램 간의 차이를 나타낸다. 공유 개체 : 도 56은 공유 개체를 나타낸다 : 변화의 경로 : a) 제약 : 도 97a에서 객실 숙박은 시스템에 배치 된 제약인 2 개의 상태만 있다. 도 38은 많은 가능성 사이에서 만들어지는 선택에 대한 제한인, 제약을 나타낸다. b) 규칙 : 도 97b는 객실 요금 계산 규칙이 나와 있다. 도 39는 또한 시스템에 배치되는 일련의 구속 조건 인 규칙을 나타낸다. c) 알고리즘 : 도 40은 규칙과 동일하지만 정보 시스템의 컨텍스트에서 자주 사용되는 알 고리즘을 나타낸다. 프로세스를 정보로 변환 : 도 103은 프로세스가 정보로 변환되는 방법을 나타낸다. IT의 추상화 수준 : 도 66은 IT의 추상화 수준에 대한 이해를 나타낸다. 에이전트는 인간 에이전트, 기계 에이전트 및 대자연 에이전트를 포함할 수 있다. 인간 에이전트 : 도 41은 인간 에이전트를 나타낸다. (예 : a) 가치 창출 자 : 도 42는 가치 창출자와 소비자를 나타낸다. b) 가치 소비자 c) 팀 d) 소유권 : 도 43은 에이전트과 관련된 법인의 소유권을 나타낸다. e) 에이전 트 기능 : 도 44는 마인드 기능, 신체 기능 및 정보 기능을 나타낸다.) 기계 에이전트 : 도 47은 기계 에이전트를 나타낸다. 대자연 : 도 48은 변환에 영향을 줄 수 있는 제 3 종류의 에이전트인 대자연을 나타낸다. 판정 시스템 : 도 49는 판정 시스템을 나타내며, 2 개의 단락이 있으며 에이전트는 의도를 이행하는 데 필요한 단락을 선택한다. 이해 관계자 참여 센터 : 도 57은 이해 관계자 참여 센터 (SEC)를 나타낸다. 측정 프레임워크 : 도 50은 측정 프레임워크를 나타낸다. 분산 임무 통제 센터 : 도 70은 분산 임무 통제 센터를 나타낸다. 동적 임무 통제 센터 : 도 71은 동적 임무 통제 센터를 나타낸다. 사용자 인터페이스 : 도 51은 사용자 인터페이스를 통해 제공되는 에이전트에 속하는 개체를 나타낸다. NSL 기술 프레임워크 : 도 69는 NSL 기술 프레임워크를 나타낸다. 리엔지니어링 : 도 54는 리엔지니어링을 나타낸다. NSL 언어 애그노스틱 : 도 68은 NSL이 언어 애그노스틱한 것을 나타낸다. NSL 및 DNA :도 73은 DNA가 정보로 변환된다는 것을 나타낸다. 인공 신경망 : 도 64는 인공 신경망을 나타낸다. 도면과 관련된 NSL의 개념 세상의 모든 것은 개체와 그 관계의 관점에서 설명될 수 있다. (동일한 내용은 호텔 객실이 Wi-Fi, 요금 및 객 실 상태와 관련된 속성인, 도 2 및 도 97a를 참조하여 더 자세히 설명될 수 있다. 모든 정보 기술 솔루션 설계는 개체 중심 방식으로 수행될 수도 있다. (동일한 내용은 호텔 객실 요금 계산이 일수, 요금 및 1 인실/2 인실을 조합하여 개체 중심 방식으로 표현되는, 도 2 및 도 97b를 참조하여 더 자세히 설명된다.) 에이전트의 관점과 구별되는 모든 것이 개체이다. (동일한 내용은 호텔 객실과 객실 요금이 별개의 항목인, 도 2와 도 97a 및 97b를 참조하여 더 자세히 설명된다.) 다른 유형의 개체가 있다. (동일한 내용은 개체, 속성, 변경 유닛 및 경로가 서로 다른 유형의 개체 역할을 하 는, 도 2, 3, 4 및 도 99b를 참조하여 더 자세히 설명되었다.) 하드 또는 소프트이든지, 유형 또는 무형인지의 여부에 관계없이 모든 것을 개체라고 부를 수 있다. (호텔 객실 이 유형의 하드 자산인 반면 객실 요금은 무형의 소프트 자산인, 도 2 및 도 97a 및 97b를 참조하여 동일한 내 용을 더 자세히 설명되었다.) 개체는 고유할 수 있거나 (다른 것들과 상이함, 차별화됨) 반복적일 수 있다 (다른 것들과 동일하거나 비 차별 화됨). (반복이 독특한 럭셔리 실의 경우 객실 수의 형태로 설명되는, 도 3, 4 및 도 102d를 참조하여 동일한 내용을 더 자세히 설명한다.) 인간 에이전트와 독립적으로 존재하는 개체를 '실제 개체'라고 한다. (호텔 객실이 실제 개체 (물리적으로 존재)로 존재하는 도 19 및 도 97a를 참조하여 동일한 내용이 더 자세히 설명된다.) 그 자체로는 가치가 없지만 솔루션과 관련하여 다른 개체의 위치를 고려하여 가치를 도출하는 개체를 표현 개체 라고 한다. (동일한 내용은 도 20을 참조하여 자세히 설명되었으며 도 97b의 객실 요금은 표현 개체이다.) 표현 개체는 지각 개체와 정보 개체의 두 가지 유형이다. (도 21 및 22 및 도 97b를 참조하여 동일하게 더 자세 히 설명된다.) 지각 개체는 감각에 의해 지각되거나 마인드에 의해 처리될 때 인간 에이전트의 마인드에 등록된 개체이다. (도 21을 참조하여 더 자세히 설명된다.) 정보 개체는 실제, 지각 또는 정보와 같은 다른 개체를 나타내기 위해 에이전트에 의해 생성된 개체이다. (호텔 예약이 정보 개체 역할을 하는 글로벌 의도 진술을 갖는, 도 22 및 도 97b를 참조하여 동일한 내용이 더 자세히 설명된다.) 모든 개체는 정보 개체로 표현될 수 있다. (호텔 예약의 글로벌 의도 진술이 정보 개체 역할을 하는, 도 22 및 도 97b를 참조하여 동일한 내용이 더 자세히 설명된다.) 데이터는 일반적으로 덜 처리된 컨텍스트의 맥락에서 사용되는 정보이기도 한다. (수퍼 디럭스 룸 요금이 요금 에 대한 정보를 제공하는 데이터 역할을 하는, 도 99b에 동일한 내용이 설명된다.) 고유한 개체는 '단어'로, 반복되는 개체는 '숫자'로 나타낼 수 있다. (독특한 개체가 럭셔리라는 단어의 형태로 설명되는 도 102d를 참조하여 더 자세히 설명된다 - 룸 넘버 3은 반복을 나타낸다.) 정보 개체는 그들과 함께 진실 값을 가지고 있다. (도 23을 참조하여 이것을 더 자세히 설명한다.) 모든 개체는 '실제, 지각 또는 정보' 개체와 관계없이 물리적이다. 즉, 그들은 공간과 시간에 존재한다. (이것 은 실제 개체인 호텔 방이 공간과 시간에 존재하는 도 28과 도 98a를 참조하여 설명하고 있으며, 연령 : 60, 성 별 : 남성, id 증명 : Aadhar 번호가 공간과 시간에 도착하는 정보 개체이다.) 정보 기술 (IT) 수준에서 처리되는 모든 개체는 실제 개체 또는 다른 표현 개체를 나타내는 정보 개체이다. (이 것은 실제 개체인 호텔 방이 공간과 시간에 존재하는 도 22와 도 98a를 참조하여 더 자세히 설명하고 있으며, 실제 개체에 이름 Raju라는 실제 개체에 속성 나이 : 60이 태깅된다.) 에이전트는 또한 개체이다. (고객이 에이전트로 활동하는 도 98a를 참조하여 동일한 내용을 더 자세히 설명된다.) 모든 변경은 에이전트에 의해 발생한다. (호텔 예약 담당자가 이름, 객실 유형, 숙박 인원, 객실 수를 입력하는, 도 99a를 참조하여 보다 자세히 설명된다.) 에이전트에는 대자연, 인간 에이전트 및 기계 에이전트의 세 종류가 있다. (도 41, 47, 48 및 도 99b을 참조하 여 자세히 설명했으며, 객실 요금 계산 및 예약 ID는 기계 에이전트에 의해 생성되는 반면 객실 숙박 정보, 숙 박 인원 및 고객 이름은 인간 에이전트에 의해 입력된다.) 인간 및 기계 에이전트는 목적에 따라 움직이다. 그들은 일부 개체 상태를 선호하고 일부 개체 상태를 피하며 일부 개체 상태에 대해서는 중립적이다. (도 99b를 참조하여 설명되며 객실 요금 계산과 예약 ID가 기계 에이전 트에 의해 생성되는 반면, 객실 숙박 정보, 숙박 인원 및 고객 이름은 인간 에이전트에 의해 입력된다.) 반대로, 대자연에 의한 변화의 배후에는 목적이 없다. 이후부터는 명시적으로 자연을 언급하지 않는 한 인간 에이전트 및 기계 에이전트의 제한된 컨텍스트에서만 에 이전트를 언급할 것이다. \"에이전트(들)\"라는 단어는 일반적으로 인간 및 기계 에이전트를 의미한다. (이것은 도 99b를 참조하여 상세히 설명되며 객실 요금 계산과 예약 ID가 기계 에이전트에 의해 생성되는 반면, 객실 숙박 정보, 숙박 인원 및 고 객 이름은 인간 에이전트에 의해 입력된다.) 인간 에이전트 및 기계 에이전트는 편의상 이해 관계자 및 컴퓨터로 불릴 수 있다. NSL은 차별화 원리로 불릴 수 있는 것에 근거한다. (호텔 객실과 객실 요금이 완전히 차별화되는 도 34와 도 97a 및 97b를 참조하여 동일한 내용을 더 자세히 설명한다.) 기존의 조합 개체 상태(CES)에 새로운 개체가 추가되거나 생성될 때 다른 것들은 동일하게 유지되며, 새로운 CES는 더욱 차별화된다. (연령, 성별, ID 번호를 첨부할 때 학생이 더욱 차별화되는 도 107a를 참조하여 보다 자세히 설명한다.) 마찬가지로, 기존 CES에서 개체가 삭제될 때 다른 것들은 동일하게 유지되며, 새로운 CES는 덜 차별화된다. (이 름, 유형, 요금, 사용, 숙박 일수, 예약 ID 등의 정보를 추가하면 예약된 럭셔리 룸이 완전히 차별화되는 도 103을 참조하여 동일한 내용을 더 자세히 설명한다.) 일반적으로 말하면, 개체가 더 차별화될수록 더 많은 정보 (비트 단위로 정량화 됨)가 소비된다. 덜 차별화되면, 정보를 덜 소비한다. (이것은 이름, 유형, 요금, 숙박 인원, 숙박 일수, 예약 ID 등의 정보를 추가 하면 예약된 럭셔리 룸이 완전히 차별화되는 도 103을 참조하여 동일한 내용을 더 자세히 설명한다.) 솔루션 설계에는, 차별화 계층이 존재하고 있다. (도 34 및 도 102b를 참조하여 동일한 내용을 더 자세히 설명 되며, 여기서 예약 확인에는 영숫자 데이터 유형 (구조적 계층)이 더욱 첨부하고 있는 계층적 형식으로 예약 ID 가 첨부되어 있다.) 차별화 트리는 하나 이상의 차별화 계층에서 '속성'이라고 부르는 다수의 종속 개체를 잠재적으로 포함하는 '독 립 개체'에서 시작한다. (이것은 독립 개체 예약 확인에 추가 영숫자 데이터 유형이 첨부된 종속 개체로 부킹 ID가 있는 도 34 및 도 102b를 참조하여 동일한 내용을 더 자세히 설명한다.) 그 다음, 문장과 동등한 로컬 의도 진술 (LSI) 영역 내에 독립적인 개체의 조합으로 인한 조합 개체 상태가 있 다. (고객 정보 획득, 객실 유형 선택 등은 CES에 존재하는 LSI 또는 문장인 도 32 및 도 98a 및 98b를 참조하 여 동일한 내용을 더 자세히 설명한다.) 정적 형태의 LSI는 변경 유닛을 표현하거나 설명하더라도, 독립 개체 중 하나로 간주된다. (고객 정보 가져 오 기, 객실 유형 선택 등이 정적 개체 상태에 존재하는 도 98a에서 동일한 내용을 더 자세히 설명한다.) 각각의 독립 개체에 첨부된 속성은 문장의 형용사와 동일하다. (이것은 고객이 독립적인 개체이고 연령, 성별, id 증명이 형용사인 도 14 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 각 LSI에 첨부된 속성은 문장의 부사에 해당한다. (도 14를 참조하여 동일한 내용을 더 자세히 설명한다.) 조합 개체 상태 중에서, 2n-1 개의 이진 비 트리거 CES가 있으며, 여기서 'n'은 독립 개체 및 속성 상태의 수이 다. (도 37을 참조하여 동일한 내용을 더 자세히 설명한다.) CES 중 하나만이 확장된 CES라고 하는 CES의 계층을 확장하는 트리거 CES로 계산되어 LSI의 조합을 생성한다. (도 37을 참조하여 동일한 내용을 더 자세히 설명한다.) 또한 트리거 CES에서, 모든 독립 개체와 그 속성이 현실 상태에 있게 된다. (도 37을 참조하여 동일한 내용을 더 자세히 설명한다.) 이러한 LSI의 수집은 한 단락에 해당하는 글로벌 의도 진술로 이어진다, (도 32 및 도 95를 참조하여 동일한 내 용을 더 자세히 설명한다.) 이러한 차별화 계층 구조는 이론적으로 단락 내의 단락으로 확장될 수 있다. (도 34 및 도 95를 참조하여 동일 한 내용을 더 자세히 설명한다.) NSL 문법과 동등한 차별화 형성을 안내하는 원리는 자연어 문법과 많은 유사점을 가지고 있다. (도 34 및 도 95 를 참조하여 동일한 내용을 더 자세히 설명한다.) 차별화 원리는 집합 이론, 미적분학, 생물학적 시스템 및 기타 많은 과학적 원리에 포함된 원리에 기원을 두고 있다. (도 34를 참조하여 동일한 내용을 더 자세히 설명한다.) 개체의 가장 비 차별화되거나 일반화된 형태는 전능 개체라고 부를 수 있다. (도 8을 참조하여 동일한 내용을 더 자세히 설명한다.) 솔루션 생태계에 주어진 수의 차별화된 개체가 있고; 이들의 차별화 값은 무시되고; 그들의 존재만이 인정되는 경우, 남은 것은 차별화된 형태일 뿐이다. (도 34를 참조하여 동일한 내용을 더 자세히 설명한다.) 이것은 다음과 같이 설명될 수 있다. 5 개의 상태, A, AB, ABC, ABCD, ABCDE가 있는 경우, ABCDE 상태의 'E' 값이 무시되면, 이전 상태 ABCD와 동일 해 진다. 제 4 상태의 'D'의 값이 또한 무시되는 경우, ABC와 동일하게 되고 시스템에는 세 개의 ABC가 있다. A까지 올라가고 다른 모든 것은 그 존재로 인식되지만 그 값에 대해 무시된다면, 시스템에 아무런 차이 없이 5 개의 'A'만이 남게 된다. (도 34를 참조하여 동일한 내용을 더 자세히 설명한다.) 'A'가 사람, 자동차, 색이 있는 자동차 등과 같이 다른 차별화가 없이, 개체로만 인식된다면, 이러한 가장 일반 적인 형식은 차별화 없이 개체 수만 남긴다. (도 34를 참조하여 동일한 내용을 더 자세히 설명한다.) 솔루션 설계에서, CES에 대한 모든 추가는 솔루션 경로를 차별화하는 제약과 동일하다. (이것은 제약으로서의 객실 이용 가능성이 객실 예약 여부로 이어지는 도 102f를 참조하여 동일한 내용을 더 자세히 설명한다.) 이러한 연속적 또는 관련 추가 또는 제약이 다수 존재하는 경우, 이들은 기존 솔루션 구축에서 규칙으로 지칭되 는 것과 동일하다. 알고리즘은 기계 에이전트에 의해 구현되는 규칙이다. (이것은 객실 요금 500과 Wi-Fi를 사용할 수 없는 도 40 및 도 102d를 참조하여 더 자세히 설명되며, 상태 사용할 수 없음은 기본적으로 알고리즘으로 디폴트로 기계 에 이전트에 의해 모든 럭셔리 룸에 설정된다.) 사용자 인터페이스 및 솔루션 아키텍처가 가장 낮은 수준의 독립 개체 및 속성으로 차별화 수준을 가져오지만, 정보 기술의 기본은 이러한 추상화 수준을 알파벳, 숫자 및 기호로 확장한 다음에, 이진수 0과 1로 확장하고, 트랜지스터 또는 저장 디바이스의 전자기력까지 확장한다. (도 66을 참조하여 이를 설명한다.) 독립된 독립 개체가 있다. (도 9를 참조하여 이를 더 자세히 설명한다.) 독립 개체는 사건이 자신이 속한 조합 개체 상태 (CES)의 변경을 유발하는 해당 레벨 또는 속성 레벨에서 사건 이 발생할 수 있는 정도까지 독립적이다. (이것은 고객 개체의 연령, 성별, 신원 증명으로 인해 고객 정보 변경 유닛이 변경되는 도 9 및 도 98a 및 98b를 참조하여 동일한 내용을 더 자세히 설명한다.) 속성은 독립된 개체에 의존하는 개체이다. (이것은 객실 요금, Wi-Fi 및 객실 상태가 독립적인 개체인 호텔 객 실에 따라 달라지는 도 14 및 도 97a를 참조하여 더 자세히 설명된다.) 다시 말해서, 속성은 독립된 개체에 의해 존재하며 속성 없이는 존재할 수 없다. (객실 요금, Wi-Fi, 객실 상태 가 독립적 개체인 호텔 객실에 따라 달라지는 도 14 및 도 97a를 참조하여 동일한 내용을 더 자세히 설명한다. 호텔 객실이 삭제되면 Wi-Fi 및 상태는 자동으로 존재하지 않음) 그러나, 사건은 독립 개체 및 CES의 상태를 독립적으로 수정하는 레벨에서 발생할 수 있다. 많은 레벨의 속성이 있을 수 있다. (객실 유형 개체에 대한 두 가지 수준의 속성이 있는 도 18 및 도 102d를 참 조하여 동일한 내용을 더 자세히 설명한다.) 각 독립 개체는 수조 개의 입자로 구성되어 있으며 이미 엄청난 양의 정보를 가지고 있기 때문에 매우 차별화된 다. (정보는 개체의 차별화를 나타내는 것이다). (이것은 호텔 객실이 요금, Wi-Fi, 객실 상태를 속성으로 완전 히 차별화된 독립적 개체인, 도 9 및 도 97a를 참조하여 동일한 내용을 더 자세히 설명한다.) 독립 개체는 잠재적 또는 현실의 이진 상태로 존재함을 의미하는 고정 상태의 개체로 간주되어야 한다. 독립 개체는 막대한 수의 입자 또는 정보를 가지고 있는 경우에도 수정되는 것에 적합하지 않다. 모든 CES는 사건의 지시에 따라 상태를 변경할 준비가 된 잠재적 또는 현실의 이진 상태에 있다. (이것은 GSI CES로의 호텔 객실 예약이 정적 및 동적 형태로 존재하는 도 27 및 도 98a 및 98b를 참조하여 더 자세히 설명된 다.) 개체가 결합되면, 조합 개체 상태(CES)가 생성된다. (도 37을 참조하여 동일한 내용을 더 자세히 설명한다.) CES는 이미 고도로 차별화된 독립 개체의 조합이기 때문에 훨씬 더 차별화된다. (이것은 도 37을 참조하여 더 자세히 설명된다.) 모든 CES는 이진 상태이다. (도 27을 참조하여 동일한 내용을 더 자세히 설명한다.) 정보 기술에서, 모든 상태는 디지털로 표현할 수 있다. 시스템 내에서, CES가 영구적으로 현실 상태 또는 잠재적 상태에 있는 경우 이것은 상수라고 한다. (이것은 객 실 요금이 고정된 값인 도 29 및 도 99b를 참조하여 동일한 내용을 더 자세히 설명한다.) CES가 잠재성 또는 현실성 사이에서 진동할 수 있는 경우, 이를 가변 상태라고 한다. (이것은 객실 가용성 및 고객이 변수인 도 28 및 도 99b를 참조하여 동일한 내용을 더 자세히 설명한다.) CES가 잠재성에서 현실로 이동할 때 생성된 것으로 간주된다. (이것은 도 12를 참조하여 동일한 내용을 더 자세 히 설명한다.) CES가 현실에서 잠재성으로 이동할 때 삭제된 것으로 간주된다, (도 12를 참조하여 동일한 내용을 더 자세히 설 명한다.) CES의 하위 상태가 잠재적 상태와 현실 상태 사이에서 변경을 거치면 수정된 것으로 간주된다. (도 13을 참조하 여 동일한 내용을 더 자세히 설명한다.) 모든 하위 상태가 주 상태의 상태에 영향을 미칠 수 있는 더 높은 CES 유리한 지점에서, 수정 및 가변성은 일부 경우에 무한대의 경향이 있다. (일수와 숙박 인원이 객실 숙박 정보에 영향을 미치고 동일한 영향이 더 높은 유 리한 지점에서 호텔 객실 GSI를 예약하는 도 99b를 참조하여 동일한 내용을 더 자세히 설명한다.) 모든 '변화'는 에너지에 의존한다. 모든 솔루션 및 가치있는 모든 것은 '통제된 변경'에서 발생한다. (5 개의 서로 다른 LSI가 순서대로 함께 연결 되어 사건의 흐름을 조절하는 도 99b에서 동일한 내용을 더 자세히 설명한다.) 통제된 변경은 에너지와 방향 - 방향 에너지를 필요로 한다. 솔루션 설계에서 모든 변경은 '단위 변경'에서 발생한다. (이것은 고객 정보 획득, 객실 유형 선택, 숙박 정보 획득, 객실 요금 계산 및 호텔 객실 예약이 모든 변경이 발생하는 변경 유닛인, 도 25 및 도 99b를 참조하여 자 세히 설명된다.) 모든 솔루션은 에이전트에 따라 다르다. (이것은 연령, 성별 및 신분 증명이 고객별로 고유한 도 98a를 참조하 여 동일한 내용을 더 자세히 설명한다.) 즉, 에이전트가 없으면, '솔루션' 또는 '가치'의 개념이 의미를 잃게 된다. 모든 변경 유닛에는 하나 이상의 에이전트가 있다. (기계 에이전트가 예약 ID와 이름을 생성하고, 요일과 점유 가 에이전트에 의해 입력되는 도 99b를 참조하여 더 자세히 설명한다.) 통제된 변화의 촉매 역할을 하는 것은 CES의 일부인 에이전트이다. (기계 에이전트가 예약 ID와 이름을 생성하 고, 숙박 일수와 숙박 인원이 에이전트에 의해 입력되는 도 99b를 참조하여 동일한 내용을 더 자세히 설명한 다.) 솔루션 설계자는 최적화 원칙에 따라 변경 유닛을 선택한다. (이론적으로는 동일한 것을 무한한 상태 변화로 표 현할 수 있는 5 개의 LSI를 사용하여 GSI 호텔 객실 예약을 구축한 도 26 및 도 98b를 참조하여 동일한 내용을 더 자세히 설명한다.) '변경 유닛'이 너무 크면 가변 상태에 참여하는 독립 개체 및 속성이 기하 급수적으로 증가하여 시스템이 너무 복잡해진다. (도 26을 참조하여 동일한 내용을 더 자세히 설명한다.) 변경 유닛이 너무 작으면, 관리 불가능한 중복성이 시스템에 유입된 변경 유닛의 확산이 있게 된다. (도 26을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL에서, 모든 변경 유닛은 로컬 의도 진술(LSI) 또는 글로벌 의도 진술(GSI)로 표현된다. (GSI 호텔 객실 예약 이 5 개의 LSI를 사용하여 구성된 도 25 및 도 98b를 참조하여 동일한 내용을 더 자세히 설명한다.) 의도 진술은 서술문 또는 의문문과는 달리 자연어의 '지시문'과 유사한다. 모든 잠재적인 조합 개체 상태 (사건이 발생하지 않는 경우)에 의해 백업되지 않은 모든 의도 진술은 '정적인 의도 진술'로 간주되어야 한다. (로직 계층에 존재하는 도 32 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 다시 말해서, 정적 의도 진술은 상수이고, 여기에서 작용하지 않는 것은 단지 의도로 남게 된다. (로직 계층에 존재하고 작동하지 않는 도 32 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 반대로 동적 의도 진술은 사건이 발생하는 모든 잠재적 조합 개체 상태에 의해 뒷받침된다. (모든 사건이 발생 하고 잠재성이 현실로 전환된 도 33 및 도 98b를 참조하여 동일한 내용을 더 자세히 설명한다.) 다시 말해서, 동적 의도 진술은 작용되는 것이다. (모든 사건이 발생하고 잠재성이 현실로 전환된 도 33 및 도 98b를 참조하여 동일한 내용을 더 자세히 설명한다.) 정적 의도 진술은 누가 그것을 읽고 있는지 또는 세상에서 무슨 일이 일어나고 있는지에 관계없이 단어가 어떠 한 변경도 거치지 않은 지시문으로 이루어진 책과 비교할 수 있다. (도 32 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 동적 의도 진술은 누가 그것을 읽고 있으며 현실 세계에서 일어나고 있는지에 따라 단어가 동적으로 조정되는 지시문으로 이루어진 책과 비교할 수 있다. (도 33 및 도 98b를 참조하여 동일한 내용을 더 자세히 설명한다.) 솔루션의 모든 변경은 에이전트에 의해 통제되고 모든 변경은 에이전트의 의도에 의해 선행되기 때문에; 의도 진술은 모든 트리거 CES에서 항상 독립적인 조합 개체로 존재한다. (도 37과 도 98a 및 98b를 참조하여 이를 더 자세히 설명한다.) 의도 진술의 존재는 때때로 암묵적일 수 있고 때로는 명시적으로 언급될 수 있지만, 그 존재는 불가피하다. 의도 진술은 필요한 조건이지만 존재하는 조합 개체 상태를 트리거하기에 충분한 조건이 아니다. (호텔 예약 에 이전트의 존재를 명시한 것이 없는 도 37 및 도 99a를 참조하여 동일한 내용을 더 자세히 설명한다.) SI는 에이전트의 의도이며 트리거 CES는 이러한 의도를 충족한다. (마지막 속성 요금을 캡처하는 것이 호텔 객 실 예약 의도를 충족시키는 트리거 CES가 되는 도 37 및 도 98b를 참조하여 동일한 내용을 더 자세히 설명한 다.) 독립 조합 개체로서의 SI는 인간 에이전트에 대한 인터페이스 역할을 하는 주요 목적을 제공한다. 이것은 기능 적 의미가 필요하지 않은 동사와 같은 설명 용어가 포함될 수 있다. (얻다, 선택하다, 연산하다 및 예약하다는 정보 가치만 제공하고 기능에 영향을 주지 않는 동사인, 도 25와 도 98a 및 98b를 참조하여 동일한 내용을 더 자세히 설명한다.) 이와 함께, 나머지 독립 개체는 트리거 CES의 달성에 기여한다. (고객과 그 속성이 트리거 CES를 수행하는 데 도움이 되는 도 37 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) LSI의 모음은 GSI로 이어진다. (5 개의 LSI를 순서대로 연결하면 호텔 객실 예약 GSI가 완성되는, 도 32 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 조합 개체 상태(CES)는 서로 다른 레벨에서 개체의 조합, 즉 위에서 언급한 차별화 계층 구조를 통해 달성된다. 제 1 레벨 CES는 다양한 레벨에서 독립 개체와 속성 (종속 개체) 간의 조합에서 발생한다. (고객이 이름, 나이, 성별, id 증명의 속성을 첨부한 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 제 2 레벨 CES는 의도 진술 내에서 2 개 이상의 '제 1 레벨 CES'의 조합에서 발생한다. (고객과 호텔이 독립적 인 개체를 결합한 도 98A를 참조하여 동일한 내용을 더 자세히 설명한다.) 제 3 레벨 CES는 글로벌 의도 진술 (문단과 동일) 내에서 로컬 의도 진술 (문장과 동일)의 조합에서 발생한다. (LSI가 CES로 결합된 도 98a를 참조하여 동일하게 동일한 내용을 더 자세히 설명한다.) 원칙적으로, 제 4 레벨 및 그 이상의 레벨은 문단을 넘어서는 더 높은 레벨의 차별화로 이어지는 글로벌 의도 진술의 조합으로부터 발생할 수 있다. SI는 독립적인 개체로 취급되어야 하며 이와 관련된 속성은 자연어의 '부사'와 동일하다. 다른 독립 개체 각각과 연관된 속성은 자연어에서 '형용사'와 동등하게 취급될 수 있다. (Wi-Fi, 요금 및 객실 상태가 형용사인 도 52 및 도 97a를 참조하여 동일한 내용을 더 자세히 설명한다.) 개체가 결합될 때, 이러한 결합 상태는 자체적으로 나타나는 속성을 가질 것이다. 이것은 마치 산소 원자와 수 소 원자가 각각의 성질을 가지고 있는 것과 같으며, 이들이 결합하면 '물'의 성질을 얻게 된다. 모든 개체는 '잠재적 개체' 및 '실제 개체'와 같은 잠재적 또는 현실의 이진 상태로 존재한다. (도 27을 참조하 여 더 자세히 설명하였다.)솔루션 설계자는 현실 세계에서 잠재적 개체를 선택하고 솔루션 생태계의 컨텍스트에서 관련성이 없는 비 잠재 적 개체를 제외시킨다. 그러나 명시적으로는 아니지만 솔루션 생태계에 참여하는 암묵적 개체의 가능성이 있다. (호텔 예약 에이전트가 암묵적 개체인 도 10 및 도 99b를 참조하여 동일한 내용을 더 자세히 설명한다.) 암묵적 개체는 임의의 것으로 간주되는 것들이고 그들과 관련하여 불확실성이 없거나 그들이 생성하는 어떠한 결과의 효과도 갖지 않는다.(호텔 예약 대행사가 암묵적 개체인 도 10 및 도 99b를 참조하여 동일한 내용을 더 자세히 설명한다.) 유사하게, 생태계의 개체는 솔루션 설계에 대한 기여 효과가 없기 때문에 무시될 수 있다. 이진 상태의 개체의 존재는 NSL 설계 원칙의 핵심이다. (도 27을 참조하여 동일한 내용을 더 자세히 설명한다.) 상태 변이는 사건 발생시 개체의 이진 상태가 변경될 때 발생한다. (60 세, 성별 M, 신분 증명이 CES의 상태를 바꾸고 있는, 도 30과 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) CES의 크기는 참여하는 독립 및 속성 개체에 비례하여 증가한다. (도 61 및 도 99b를 참조하여 동일한 내용을 더 자세히 설명한다. 고객 이름, 객실 이용 가능성, 숙박 인원, 숙박 일수 등, 4 가지 변수가 있다. 솔루션 설 계자는 흡연/금연 선호도를 추가 변수로 할 수도 있다.) NSL 설계는 모든 CES가 잠재성과 현실의 별개의 이진 상태에서만 존재하도록 요구한다. 개체가 함께 결합되면, 이들의 개별 상태는 무시되고 결합된 상태만 중요하다. (호텔 객실 예약이 모든 LSI, 독립 개체 및 모두 결합된 이들의 속성으로 이루어진 CES 인, 도 37 및 도 99B를 참조하여 동일한 내용을 더 자세히 설명한다.) '사건'이 발생하면, 그와 관련된 공간적 및 시간적 스탬프가 있다. 즉, 사건은 항상 공간과 시간을 참조한다. 예 : 어제 인디아 또는 미국에서 특정 사건이 발생 했는가? 그중 하나만 사실이다. (연령 : 60, 성별 : 남성, 신분 증명 : Aadhar는 공간과 시간에 도착하는 정보 개체인, 도 98a를 참조하여 동일한 내용을 더 자세히 설명 한다.) 독립 개체 또는 그 속성 중 하나가 잠재적에서 현실로 또는 그 반대로 상태를 변경하여 의도 진술 (변경 유닛) 내에서 CES 중 하나를 생성할 때 사건이 발생했다고 가정한다. (연령 : 60, 성별 : 남성, 신분 증명 : Aadhar는 공간과 시간에 도착하는 정보 개체인, 도 37 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 모든 사건은 사건이 속한 SI를 포함하여 하나 이상의 SI에서 트리거 CES에 의해 발생한다. (고객 이름 캡처가 후속 LSI에서 요금 및 객실 가용성의 캡처를 트리거하는, 도 37 및 도 99b를 참조하여 동일한 내용을 더 자세히 설명한다.) 유사하게, 트리거 CES는 자신이 속한 SI 또는 다른 SI 내에서 하나 이상의 사건을 발생시킨다. 이를 사건의 효 과라고 한다. (객실 유형 선택에 따라 자동으로 표시되는 요금이 결정되는 도 99b를 참조하여 동일한 내용을 더 자세히 설명한다.) 트리거 CES가 발생할 때마다 동일한 사건이 하나 이상의 사건을 발생시키기 전에 '경과 시간'이라고 하는 특정 시간을 소비한다. (도 60을 참조하여 동일한 내용을 더 자세히 설명한다.) 의도 진술 내의 사건에 대한 공간 참조 포인트는 트리거 CES가 발생하는 공간이다. (도 37을 참조하여 더 자세 히 설명하였다.) 사건이 독립 개체 또는 속성 레벨에서 발생하는 동안, 이는 의도 진술 내의 조합 개체 상태의 변화에 영향을 준 다. (속성 레벨에서의 이름과 객실 가용성 캡처는 고객 정보를 얻는 CES의 변경에 영향을 미치는, 도 99b를 참 조하여 동일한 내용을 더 자세히 설명한다.) 각 사건과 관련된 불확실성의 다양한 수준이 있을 수 있다. 이러한 사건에 값을 할당하기 위해 확률 이론을 적용할 수 있다. 의도 진술 내의 '가능한 상태'의 수는 2n이고, 여기서 'n'은 '이진 개체의 수'이고, 즉, 6 개의 이진 변수 또는 개체가 있는 경우, 64 개의 CES가 있다. (도 61을 참조하여 동일한 내용을 더 자세히 설명한다.) 모든 독립 개체와 그 속성이 현실 상태에 있는 상태는 '트리거 CES'이고 다른 모든 상태는 비 트리거 CES이다. 이전 예 64에서 상태는 트리거 CES이고 다른 예 63은 비 트리거 CES이다. (도 37을 참조하여 동일한 내용을 더자세히 설명한다.) '트리거 CES'는 다른 의도 진술 (동일한 단락 또는 다른 단락) 또는 자체 의도 진술에서 사건(들)를 유발한다. (도 37을 참조하여 동일한 내용을 더 자세히 설명한다.) 비 트리거 CES는 어떠한 결과적인 사건이나 변경도 일으키지 않는다. (도 37을 참조하여 동일한 내용을 더 자세 히 설명한다.) 의도 진술은 뉴런과 같고 트리거 CES는 활동 전위의 구축에 대한 뉴런의 발화와 같다. (도 37을 참조하여 동일 한 내용을 더 자세히 설명한다.) 다른 SI에 영향을 미치는 의도 진술 (SI)이 관련된 것으로 간주되며 CES의 폴드를 가져온다. (관련 SI가 결합된 도 95를 참조하여 동일한 내용을 더 자세히 설명한다.) 프로세스 장벽의 파괴는 관련 SI가 새롭게 확장된 CES를 발생시킬 때 발생한다. 트리거 CES 관계를 기반으로 다른 SI와 그 구성 요소가 결합되면, CES는 확장된다. (도 98b를 참조하여 동일한 내용을 더 자세히 설명한다. a) 고객 정보 얻기 b) 고객 정보 얻기. 객실 유형 선택 c) 고객 정보 얻기. 객실 유형을 선택. 객실 숙박 정보 얻기.... d) 진술 a, b, c는 관계에 따라 확장된다.) 모든 사건은 하나의 트리거 CES 또는 다른 트리거에 의해 발생한다. (도 37을 참조하여 동일한 내용을 더 자세 히 설명한다.) 트리거 CES가 원인이고 결과 사건이 결과이다. (도 37을 참조하여 동일한 내용을 더 자세히 설명한다.) 원인과 결과가 확장된 CES라고 하는 CES의 형태로 차별화된 개체로 함께 결합되면 프로세스가 정보로 변환된다. (프로세스가 자연어 형태의 정보로 변환되는 도 103을 참조하여 동일한 내용을 더 자세히 설명한다.) 확장된 CES를 포함하여 독립적인 개체와 CES만이 존재하는 새로운 패러다임에서는, 정보로 표현된 개체 간의 차 이만이 존재한다. 의미를 포착할 때 정보를 관리하는 동일한 '차별화 원리'가 솔루션 또는 가치의 생성도 관리한다. (과정이 자연 어 형태의 정보로 변환되는 도 59 및 도 103을 참조하여 더 자세히 설명하였다.) 이제 솔루션 상태조차도 정보의 영역에 들어 오므로 검색 엔진의 영역에 들어간다. (프로세스가 자연어 형태의 정보로 변환되는 도 103을 참조하여 더 자세히 설명하였다.) '에이전트'의 컨텍스트에서, 에이전트는 대부분의 다른 개체에 대해 애그노스틱한 반면, 일부 조합 개체 상태는 유리하고 일부는 불리하다. 확장된 CES의 경우, 글로벌 SI로 이어지는 연결된 SI는 동일한 단락에 속하는 것으로 취급된다. (순서대로 연결 된 5 개의 LSI를 수집하면 호텔 객실 예약 GSI의 완료로 이어지는 도 63 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 글로벌 SI를 포함하는, 모든 SI는 에이전트에 특정적이다. (5 개의 LSI가 모두 호텔 예약 에이전트에 특정된, 도 25 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 단락은 글로벌 SI의 이행으로 이어지는 로컬 SI의 모음으로 정의된다. (순서대로 연결된 5 개의 LSI를 수집하면 호텔 객실 예약 GSI의 완료로 이어지는, 도 25 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 각 단락은 단 하나의 글로벌 의도 진술의 이행을 서비스한다. (순서대로 연결된 5 개의 LSI를 수집하면 호텔 객 실 예약 GSI의 완료로 이어지는, 도 25 및 도 98a를 참조하여 더 자세히 설명하였다.) 하나 이상의 글로벌 SI가 있는 경우, 동일한 것이다른 단락에 수용되어야 한다. (모든 단락이 하나의 GSI를 지 원하는 도 25 및 도 107h를 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 글로벌 SI의 단락에 속하는 모든 독립 개체 및 그 속성이 글로벌 SI가 이행될 현실 상태에 있어야 한다고 요구한다. (모든 사건이 이미 발생한 도 98b를 참조하여 동일한 내용을 더 자세히 설명한다.) NSL이 의존하는 하나의 기본 기준은 어떤 SI가 충족되려면 모든 독립 개체와 속성이 현실 상태에 있어야 한다는 것이다, (모든 사건이 이미 발생한 도 98b를 참조하여 동일하게 동일한 내용을 더 자세히 설명한다.) 이 원칙은 그것이 로컬 SI (문장 레벨)이든 글로벌 SI (단락 레벨)이든 동일하게 적용된다. NSL은 '솔루션 로직'을 '공간 및 시간'과 동일한 상태를 부여하는 기본 속성으로 간주한다. 이 로직은 에이전트에 의해 정의되고 작동된다. (로직이 호텔 예약 에이전트에 의해 실행되는 도 98a에서 동일 한 내용을 설명한다.) 모든 차별화 경로는 솔루션 설계자에 의해 잠재적 단락으로 정의된다. (호텔 객실 예약 단락이 솔루션 설계자에 의해 배치되는 도 98a에서 설명한다.) 에이전트가 새로운 열망을 가질 때, 그것은 새로운 글로벌 의도 진술로서 자격이 된다. (지정된 과목 교사가 백 분율 표시를 계산하는 것이 세 개의 단락에 수용된 도 107h에서 동일한 내용이 도시된다.) 의도 진술은 그 부분 집합으로서 잠재적 단락 중 하나에 속해야 한다. (NSL 솔루션 구조가 표시된 도 95에서 도 시된다.) 글로벌 SI가 생성되면, 글로벌 SI가 이행되는 미분 경로에서 정의된 잠재적 단락에 즉시 연결된다. (GSI가 잠재 적인 문단을 붙잡은 도 98a에서 도시된다.) 서로 관련된 모든 글로벌 SI는 '관련 문단'으로 표현할 수 있다. (3 개의 관련 단락이 표현된 도 107h에서 동일 한 내용이 도시된다.) 관련 단락은 동일한 글로벌 SI (전통적으로 동일한 솔루션으로 이어지는 다른 프로세스)를 제공하는 단락일 수 있거나, 이들은 글로벌 SI에 약간의 변형이 있는 단락일 수 있다. 관련 단락 중 하나는 글로벌 의도 진술을 종료하는 단락일 수 있다. (호텔 객실 예약이 단락을 끝내는 GSI인 도 99b에 동일한 내용이 도시된다.) 여러 관련 단락에 공통되는 CES를 공유 개체라고 한다. 공유는 하나 이상의 SI에 서비스를 제공할 가능성이 있 는 개체와 관련된다. (과제 할당 교사가 학생 점수를 계산하는 것이 공유 개체인 도 56 및 도 107h를 참조하여 동일한 내용을 더 자세히 설명한다.) 여러 단락이 개별적으로 글로벌 의도 진술의 이행으로 이어질 수 있는 경우가 있다. NSL은 판결 방법을 통해 대 체 문단 중에서 선택을 결정한다. (도 49를 참조하여 동일한 내용을 더 자세히 설명한다.) 판정 방법은 기존의 조합 개체에 (제약의 역할을 하는) 추가적인 독립 개체를 추가하는 것에 의존하므로, 의도 진술을 충족하기 위해 하나의 단락만 남아 있도록 상황이 미세 조정된다. (도 49를 참조하여 동일한 내용을 더 자세히 설명한다,) 대안으로, 글로벌 의도 진술을 이행할 수 있는 단락이 없는 경우, (제약을 제거하는 역할을 하는) 독립 개체의 선택적인 제거는 의도 진술의 출현으로 이어질 수 있다. (도 49를 참조하여 동일한 내용을 더 자세히 설명한 다.) 원인 사건에 의해 그 영향이 느껴지기 전에 모든 트리거 CES와 관련된 경과 시간이 있다. (도 60을 참조하여 동 일한 내용을 더 자세히 설명한다.) 경과 시간은 길거나 짧을 수 있지만 예외 없이 항상 존재한다. 일반적으로 말해, 기계 에이전트의 관련 경과 시 간은 매우 짧다. 즉, 몇 분의 1 초로 계산된다. 인간 에이전트의 관련 경과 시간은 몇 초에서 몇 시간 또는 며 칠까지 다양한다. (도 60을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 과학에 의해 확립된 '세계가 작동하는 방식' 원칙을 기반으로 한다. NSL은 인간 에이전트의 행동 및 기능을 모방한다. 정의된 인간 에이전트 기능의 세 계층이 있다. (도 44를 참조하여 동일한 내용을 더 자세히 설명한다.) 제 1 계층은 트리거 조건의 충족 시 SI에서 사건을 촉진하는 물리적 기능이다. (이름, 객실 유형 및 점유를 입 력하는 것이 물리적 기능인 도 44 및 도 99a를 참조하여 동일한 내용을 더 자세히 설명한다.) 제 2 계층은 인간의 감각을 모방하고 생태계의 상태를 포착하여 에이전트에게 계속 정보를 제공하는 정보 기능 이다. (무엇을 원하십니까? 예약된 객실을 취소하세요. 서비스 이용 가능이 정보 개체로 작용하는, 도 44 및 도 99a를 참조하여 동일한 내용을 더 자세히 설명한다.) 제 3 계층은 각 사건 발생시 환경을 재평가하고 신체 기능에 피드백을 제공하는 마인드 기능이다. (도 44를 참 조하여 동일한 내용을 더 자세히 설명한다.) NSL은 필요에 따라 존재하는 단락의 3 개 계층 모두를 제공한다. (도 44를 참조하여 동일한 내용을 더 자세히 설명한다.) 디폴트 계층은 물리적 기능 계층이다. (도 44를 참조하여 동일한 내용을 더 자세히 설명한다.) 정보 기능 계층의 개체는 정보 잠재성을 유지하는 등급을 만들었다. 즉, 분석을 돕거나, 측정 목적에 부합하거 나, 미래 설계의 컨텍스트에서 사용될 수 있다. (도 44를 참조하여 동일한 내용을 더 자세히 설명한다.) 마인드 기능 계층은 물리 계층을 안내하고 트리거 조건을 검증하는 데 도움을 준다. 사건 발생시 관련 의도 진 술에서 현재 및 미래의 CES를 재평가 (예상) 및 업데이트하고 트리거 프로세스를 안내한다. (도 44를 참조하여 동일한 내용을 더 자세히 설명한다.) 마인드 기능 계층은 무엇보다도 예상 트리거 CES, 트리거와 관련된 경과 시간 및 트리거 CES와 관련된 확률에 의존한다. (도 44를 참조하여 동일한 내용을 더 자세히 설명한다.) 고급 계획 및 최적화 (APO) 원리는 NSL에서 '마인드 기능 계층'을 사용하여 자연스럽게 작동되게 할 수 있다. (도 44를 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 다른 내부 또는 외부 솔루션에 액세스하는 과정에서 유사한 차별화 원칙에 의존하는 용용 프로그래밍 인 터페이스(API)에도 동일하게 적용된다. (도 65를 참조하여 동일한 내용을 더 자세히 설명한다.) NSL의 가장 중요하고 극적인 측면 중 하나는 그것의 구성이 자연어와 유사할 뿐만 아니라 어떤 자연어에도 애그 노스틱하다는 것이다. (도 68을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 차별화 원리를 기반으로 하기 때문에 설정된 미분 방법을 준수하는 한, 시스템은 사용된 자연어에 관계없 이 동일하게 인식하고 작동한다. (도 68을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL 솔루션 언어는 영어에만 국한되지 않지만, 알려진 자연어 중 어느 것으로도 동등하게 쉽게 작성될 수 있다. (도 68을 참조하여 동일한 내용을 더 자세히 설명한다.) 요구되는 것은 NSL 기술 프레임워크가 그러한 추상화 수준에 적절한 개체를 처리하고 사용된 언어에 관계없이 동일한 결과를 생성하도록 차별화의 레벨을 고수하는 것이다. (도 68을 참조하여 동일한 내용을 더 자세히 설명 한다.) 자연어는 인간 에이전트 간의 정보 교환을 위한 기반을 형성한다. (도 68을 참조하여 동일한 내용을 더 자세히 설명한다.) 자연어는 또한 코드의 한 형태로, 러시아어 만 사용하는 사람은 영어 만 사용하는 사람과 의사 소통할 수 없다. (도 52를 참조하여 동일한 내용을 더 자세히 설명한다.) 유사하게, 컴퓨터와의 통신은 오랫동안 특수 코드를 포함하는 다양한 프로그래밍 언어를 통해 이루어진다. 작업 을 수행하려면 해당 프로그래밍 언어로 훈련된 사람들이 필요하다. (도 52를 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 구조와 같은 자연어를 사용하여 컴퓨터에 솔루션 로직을 전달하는 방식을 도입함으로써 새로운 패러다임 을 생성한다. (도 66을 참조하여 동일한 내용을 더 자세히 설명한다.) 자연 솔루션 언어는 기본 기술 프레임워크 위에 혁신적인 구조 및 방법을 사용하여 자연어와 유사한 방식으로 솔루션 로직을 기계 에이전트 (컴퓨터)에 효과적으로 전달한다. (도 66을 참조하여 동일한 내용을 더 자세히 설 명한다.) NSL의 개체 관계는 자연어의 품사와 유사한다. (도 67을 참조하여 동일한 내용을 더 자세히 설명한다.) 이것은 NSL이 매체에 애그노스틱한 방식으로 솔루션 로직을 컴퓨터에 전달하는 유연성을 제공한다. (도 72에 동 일한 내용이 도시된다.) NSL은 문자 및 이미지 인식 기술의 발전을 사용하고 컴퓨터에 연결된 비디오 카메라를 사용하여 손으로 쓴 형태 로 컴퓨터에 직접 솔루션 로직을 전달할 수 있다. (도 72에 동일한 내용이 도시된다.) 마찬가지로, 음성 인식 기술의 발전을 통해 NSL 솔루션 로직은 음성으로 녹음되고 컴퓨터로 직접 전달될 수 있 다. (도 72에 동일한 내용이 도시된다.) NSL은 또한 수화로 확장 가능한다. (도 72에서 동일한 내용이 도시된다.) NSL은 또한 솔루션의 성능을 캡처하는 비디오를 기반으로 솔루션 로직을 추출하는 기능을 가지고 있다. (도 72 에서 동일한 내용이 도시된다.) 비디오에 존재하는 실제 및 정보 개체는 시스템에 의해 인식된다. (도 72에서 도시한다.) 비디오에서 관찰된 변경 유닛은 '확장 CES'로 변환되어 프로세스 또는 솔루션 로직을 캡처한다. (도 72에서 도 시한다.) NSL은 모든 솔루션 로직을 개체와 그 관계로 축소하기 때문에, 식별된 개체를 개별적으로 또는 집합적으로 암호 화할 수 있는 유연성으로 원하는 수준으로 '시스템 보안'을 처리하는 것이 가장 자연스럽게 적합하다. 확장에 의해, 신뢰할 수 있는 당사자를 제거하면서 높은 보안을 추구하는 솔루션이 쉽게 달성될 수 있도록 블록 체인의 적용이 가능한다. NSL은 특징적인 용이성으로 '측정 프레임워크'를 생성하는 능력을 가지고 있다. (도 50을 참조하여 더 자세히 설명한다.) NSL은 모든 개체 또는 생태계의 상태를 객관적으로 결정하기 위해 올바른 종류의 특이성과 세분성이 달성되도록 필요한 한도까지 차별화를 행할 수 있다. (도 34를 참조하여 동일한 내용을 더 자세히 설명한다.) 그 후, 전통적으로 규범이라고 불리는 현실 상태에 대한 가치 판단을 매우 자연스럽게 포착하고 녹색 및 빨간색 과 같은 색상을 생성하여 인간 에이전트에게 선택된 개체의 상태를 알릴 수 있다. (도 50을 참조하여 동일한 내 용을 더 자세히 설명한다.) NSL은 필요에 따라 임의의 원하는 유리한 지점에서 CES를 매우 자연스럽게 캡처한다. (도 35를 참조하여 더 자 세히 설명한다.) NSL은 생태계에서 모든 SI의 성능 상태를 쉽게 관리할 수 있다. NSL은 노력과 자원 요구 사항을 동적으로 추정할 수 있다. 모든 SI는 인간 에이전트에 의해 소유되고 구동되기 때문에, 임의의 인간 에이전트의 '이해 수준'을 쉽게 평가 하는 기능을 구축할 수 있다. 각각의 변경 유닛, 즉 각 SI는 PSA 사이클이라고 하는 항상 존재하는 '솔루션' 또는 '값' 사이클 (솔루션 또는 값의 전체 수명 주기)을 받게 된다. (도 67을 참조하여 동일한 내용을 더 자세히 설명한다.) 'P'는 시스템 및 그 내의 에이전트에 의해 포착되는 SI (변경 유닛) 수준에 존재하는 '가능성'을 의미한다. (호 텔 예약 담당자가 고객의 마인드로 선택한 객실 예약, 교통편 또는 세탁 예약, 객실 취소 등의 모든 가능성을 포착하고 있는 도 99a를 참조하여 동일한 내용을 더 자세히 설명한다.) 'S'는 시스템과 에이전트가 이용 가능한 가능성 중에서 올바른 종류의 선택을 할 수 있는 능력을 갖는 '선택'을 의미한다. (호텔 예약 에이전트가 고객의 마인드로 선택한 객실 예약, 교통편이나 세탁 예약, 또는 객실 취소의 모든 가능성을 포착하고 있는, 도 99a를 참조하여 동일한 내용을 자세히 설명한다.) 'A'는 시스템과 에이전트가 PSA 주기를 완료하기 위해 올바른 기능을 수행할 수 있는 능력을 갖는 '액션'을 의 미한다. (호텔 예약 담당자가 고객의 마인드로 선택한 객실 예약, 교통편 또는 세탁 예약 또는 객실 취소의 모 든 가능성을 입력한, 도 99a에서 동일한 내용을 설명한다.) NSL은 솔루션 생태계의 모든 레벨과 그 안에 내재된 대칭에 관련된 솔루션 사이클의 프랙탈과 같은 동작을 인식 하고 활용한다. (도 67을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 솔루션 설계에 대한 자연어 기반 접근 방식을 취하기 때문에, 사용자 인터페이스와 데이터베이스 간의 개 체 차이를 효과적으로 제거한다.(이는 도 66 및 도 95를 참조하여 동일한 내용을 더 자세히 설명한다.) 모든 개체는 하나의 인간 에이전트 또는 다른 에이전트와 관련하여 사용자 인터페이스 레벨에 존재한다. (도 51 을 참조하여 동일한 내용을 더 자세히 설명한다.) '기계 에이전트' 기능은 시스템 관리자를 포함하여 하나의 에이전트나 다른 에이전트에게 투명하다. (기계 에이 전트 기능인 예약 ID가 에이전트 및 시스템 관리자에게 투명하게 표시되는, 도 51 및 도 98b를 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 솔루션 생태계에 존재하는 모든 개체와 관련하여 블랙 박스의 존재를 제거한다. 개체에 대한 액세스는 순전히 액세스 권한 (정보 및 결정 권한)에 기초하여 모든 인간 에이전트에 제공된다. (도 45 및 46을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL 기술 프레임워크는 솔루션 설계자 및 사용자가 모든 관련 차별화된 개체를 결정하는 데 도움을 준다. (도 69를 참조하여 동일한 내용을 더 자세히 설명한다.) 그런 다음, 이러한 미분된 개체 각각은 기술 프레임워크에 의해 도움이 되는 정보 및 결정 권한으로 태그가 지 정된다. (도 69를 참조하여 동일한 내용을 더 자세히 설명한다.) 생태계의 각 CES가 모든 유리한 지점에서 명확하게 식별되므로, 대부분의 경우 속성 값의 적절한 할당이 체계적 으로 구동된다. (속성 및 그 값의 할당이 체계적으로 구동되는 도 69 및 도 98a를 참조하여 동일한 내용을 더 자세히 설명한다.) 더 높은 유리한 지점에 있는 항목에 속성 값이 할당되면, 기술 프레임워크는 수동적인 개입없이 자동으로 동일 한 차별화 분기에 속하는 모든 개체에 동일한 값을 할당할 수 있다. (상위 집합 학생 아래의 모든 사용자에게 동일한 속성과 값이 자동으로 부여되는 도 69 및 도 107l를 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 규정된 표준의 범위 내에서 원하는 대로 개체를 구성하기 위해 이해 관계자들에게 큰 유연성을 제공한다. (도 69를 참조하여 동일한 내용을 더 자세히 설명한다.) 개체가 그들과 관련된 임의의 화면의 임의의 위치로 개체를 이동할 수 있도록 그들에게 이용 가능한 방법 및 도 구가 있다. (도 69를 참조하여 동일한 내용을 더 자세히 설명한다.) 에이전트에 의한 개체 에이전트의 소유권은 모든 SI 및 해당 SI의 참여 CES가 해당 SI를 구동하는 에이전트에 속한다는 단순한 원칙에 의해 결정된다. (도 43을 참조하여 동일한 내용을 더 자세히 설명한다.) 두 가지 조건은 그러한 소유권 - 이들 개체와 물리적으로 상호 작용하는 능력 및 이들에게 제공된 특권을 부수 적으로 결정한다. (도 43, 45, 46을 참조하여 동일한 내용을 더 자세히 설명한다.) 소유권은 또한 SI에서 작업을 수행하도록 참여 에이전트를 지시할 권한을 가진 에이전트로 확장한다. (도 43, 45, 46을 참조하여 동일한 내용을 더 자세히 설명한다.) 비즈니스 솔루션은 또한 각 사건에서 직접 또는 암묵적으로 가치를 교환할 수 있는 능력을 제공한다. 이러한 현금 또는 종류의 가치 교환은 금융 시스템에서 거래를 기록하는 것과 동일한 원리에 의해 구동된다. 즉, SI가 하나 이상의 다른 SI에서 CES에 의해 트리거된 사건을 경험할 때마다 또는 트리거 CES가 하나 이상의 다른 SI에서 사건을 유발할 때 값이 교환된다. (전체적으로 2 개의 LSI를 트리거하는 고객 이름, 객실 사용 가 능 여부, 숙박 인원 및 숙박 일수의 형태인 4 개의 변수가 있으며, 도 62 및 도 99b에 설명된다. 따라서 솔루션 설계자가 정보를 가치로 정량화하는 데 도움이 된다.) 인커밍 사건을 통해 NSL로 표현되는 원인 및 결과 원리는 하나 이상의 다른 SI에서 하나 이상의 트리거 CES에 의해 발생한다. (전체적으로 2 개의 LSI를 트리거하는 고객 이름, 객실 이용 가능 여부, 숙박 인원 및 숙박 일 수의 형태인 4 개의 변수가 있다. 따라서 솔루션 설계자가 정보를 가치로 정량화하는 데 도움이 된다.) 유사하게, 트리거 CES가 하나 이상의 SI에서 발생할 때, 동일한 결과가 하나 이상의 사건을 일으키는 동일한 SI 내에서 발생하는 경우. (전체적으로 2 개의 LSI를 트리거하는 고객 이름, 객실 이용 가능 여부, 숙박 인원 및 숙박 일수의 형태로 4 개의 변수가 있는 도 99b에서 도시한다. 따라서 솔루션 설계자가 정보를 가치로 정량화하 는 데 도움이 된다.) 표준 원리에 따라 NSL의 솔루션 생태계에서 CES와 사건 간에 상관 관계가 쉽게 설정된다. (객실 요금이 숙박 일 수와 인원 속성에 대한 개체 도달이 되는 CES인, 도 97b에서 동일한 내용이 도시된다.) 주제 및 시스템으로서의 자연어 처리 (NLP)는 자연어에 대한 컴퓨터 이해 및 이에 대한 애플리케이션 개발을 다 룬다. 자연어 원칙은 NLP와 NSL 모두에 공통이지만, NSL의 초점은 관련된 인간 에이전트가 쉽게 사용할 수 있게 하는 구조와 같은 자연어를 사용하여 컴퓨터에 솔루션 로직을 직접 부여하는 것이다. NLP와 NSL 사이의 이러한 자연적인 친화성은 NSL이 NLP 시스템 및 방법을 현재 상태에 비해 훨씬 더 향상시키는 것을 더 용이하게 한다. (도 52를 참조하여 동일한 내용을 더 자세히 설명한다.) NSL과 관련된 사용자 친화성은 NSL의 컨텍스트에서 '게임 기술'의 사용을 통해 다음 단계로 이동할 수 있다. 게임 기술은 애니메이션을 통해 더 나은 시각 효과를 제공하고, 사용자를 교육하고, 솔루션을 테스트하고, 사용 자 간에 더 큰 상호 작용을 가져오기 위해 배치될 수 있다. NSL의 사용자 인터페이스 (UI)는 CES 중심으로 설계되어 UI가 매우 융통성 있게 이해 관계자의 요구를 충족하도 록 구성되는 더 큰 유연성을 제공한다. (도 51을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL의 컨텍스트에서 이들 사용자 인터페이스는 이해 관계자 참여 센터 (SEC)라고 불린다. (도 51을 참조하여 동 일한 내용을 더 자세히 설명한다.) SEC는 필요에 따라 그리고 필요할 때 각 이해 관계자에 대한 CES 액세스를 수용하고 맞춤화하기 위해 자동으로 조정된다. (도 51을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 에이전트의 정보와 결정권을 알고 있기 때문에 스스로 자동 구성할 수 있는 능력을 습득한다. (도 51을 참조하여 동일한 내용을 더 자세히 설명한다.) 사용자 친화성을 비즈니스 솔루션의 또 다른 수준으로 끌어 올리기 위해 SEC는 상호 작용의 특성에 따라 이해 관계자에 대한 다양한 수준의 액세스를 통해 하위 구조를 제공한다. (도 51을 참조하여 동일한 내용을 더 자세 히 설명한다.) 이들 레벨은 이해 관계자의 요구 사항 유형에 따라 CES를 포함하는 나의 트랜잭션, 나 자신, 나의 팀 및 나의 조직으로 불린다. (도 51을 참조하여 동일한 내용을 더 자세히 설명한다.) 동적 임무 통제 센터 (MCC)는 SEC의 자연스러운 확장으로, 이해 관계자가 자신의 작업을 더 잘 수행하는 데 중 요한 CES에 대한 준비된 액세스를 제공하는 데 중점을 둔다. (도 71을 참조하여 동일한 내용을 더 자세히 설명 한다.) 동적 MCC는 시간, 사건, 이해 관계자 관심사 및 이해 관계자 질문을 고려하여 이해 관계자에게 CES 액세스를 제 공한다. (도 71을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 현재 시스템보다 훨씬 더 효율적으로 생태계의 불확실성을 처리할 수 있는 능력을 가지고 있다. 모든 것이 NSL에서 CES 중심이기 때문에, 그들과 관련된 불확실성은 생태계의 변화하는 CES에 기초하여 자발적 으로 결정될 수 있다. 빅 데이터의 분석 및 사용 원리에 따라 각 사건에 확률을 동적으로 할당할 수 있다. 개체 및 사건 (개체의 행동)를 기반으로 하는 기계 에이전트가 학습은 지난 10 년 동안 기반으로 하여 얻고 있 다. 시스템으로서의 NSL은 그 모든 개체들이 경험 기반 학습을 위한 길을 닦는 세계가 작동하는 방식 (및 마인드가 작동하는 방식)을 개별적으로 그리고 집합적으로 에뮬레이트하기 때문에 이러한 기계 학습에 자연스럽게 적합하 다. 이것의 자연스러운 확장은 인공 지능이라고 불리는 인간 지능의 에뮬레이션이며, 여기서 NSL은 생태계에서 끊임 없이 변화하는 상황에 적응하고 이에 대응하는 기계 에이전트에게 비옥한 기반을 제공한다. NSL은 자연어 문장의 특별한 경우로, 주로 지시문 정보 (의도 진술)를 다루고 부수적으로 서술문 정보 (정보 기 능 계층의 정보)를 다룬다. NSL의 가장 극적인 성과 중 하나는 정보 이론이 '비트'로 계산할 정보를 정량화할 수 있었던 것처럼 '솔루션'과 '가치'를 정량화하는 능력이다. (전체적으로 2 개의 LSI를 트리거하는, 고객 이름, 객실 이용 가능 여부, 숙박 인원, 숙박 일수의 형태인 4 개의 변수가 있는, 도 61과 도 99b를 참조하여 더 자세히 설명한다. 따라서, 솔루 션 설계자는 정보를 가치로 정량화한다.) 모든 솔루션은 주어진 수의 독립적 및 속성 이진 상태가 현실 상태 (이진 사건의 수)에 있어야 자동으로 정량화 에 렌더링할 수 있다. (전체적으로 2 개의 LSI를 트리거하는 고객 이름, 객실 이용 가능 여부, 숙박 인원, 숙박 일수의 형태인 4 개의 변수가 있는m 도 61 및 도 99b를 참조하여 더 자세히 설명한다. 따라서 솔루션 설계자가 정보를 가치로 정량화하는 데 도움이 된다.) 유사하게, 모든 솔루션은 의도된 이행 CES가 발생하기 위해 발생하는 주어진 수의 트리거 CES를 필요로 한다. (도 99b를 참조하여 동일한 내용이 설명된다.) NSL에서 애플리케이션 로직과 관련된 모든 개체는 매우 사용자 친화적 인 형식으로 자연어와 같은 사용자 인터 페이스 레벨에 존재한다. (도 66을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 사용자를 솔루션 구축, 유지 관리 또는 향상에 참여하므로, 올바른 종류의 도구 및 구성 요소로 사용자를 지원할 필요가 있다. NSL 라이브러리는 속성 관계에서 '단락' 이상까지 발생하는 변형을 가진 독립 개체와 같은 유용한 솔루션 구성 요소를 저장한다. (이는 도 55 및 도 107a를 참조하여 동일한 내용을 더 자세히 설명한다.) 이들은 지능형 검색 방법 또는 드래그 앤 드롭 메커니즘에 의해 지원되는 필요에 따라 사용될 수 있다. (이름, 휴대폰, 주소, 나이 및 이메일이 모든 학생에 대해 재사용 가능한 속성으로 첨부된 도 107l에 도시된다.) 일반적으로 NSL은 라이브러리에서 재사용 가능한 구성 요소를 쉽게 식별하고 수정된 버전이 필요하지 않은 경우 애플리케이션 개발과 관련하여 이를 사용함으로써 중복성을 최소화한다. (이름, 휴대 전화, 주소, 나이 및 이메 일이 모든 학생에 대해 재사용 가능한 속성으로 첨부된 도 53 및 도 107l를 참조하여 더 자세히 설명된다.) NSL 라이브러리의 이러한 재사용 가능한 구성 요소는 큐레이터 역할을 하는 적절한 이해 관계자를 위한 지원 기 능을 기반으로 분류 및 저장된다. (도 107a를 참조하여 동일한 내용을 더 자세히 설명한다.) NSL 애플리케이션 개발자는 대부분 라이브러리에서 이러한 구성 요소에 액세스하고 필요에 따라 차별화된 솔루 션을 결합할 수 있다. (도 55 및 도 107a를 참조하여 동일한 내용을 더 자세히 설명되었다.) 프로그래밍 로직의 NSL 번역기가 프로그래밍 코드를 NSL 애플리케이션 로직으로 변환할 때, 오픈 소스 프로그래 밍 코드를 포함한 모든 기존 코드가 사용자에게 투명해진다. 애플리케이션 로직이 더 이상 프로그래밍 코드의 블랙 박스에 숨겨져 있지 않기 때문에, 재사용을 위해 모든 유 용한 솔루션 구성 요소를 식별할 수 있는 좋은 기회가 있다.(도 53을 참조하여 동일한 내용을 더 자세히 설명한 다.) SI는 뉴런과 비교될 수 있으며 모든 트리거 CES는 그 발화와 비교된다. 활동 전위는 뉴런의 임계 수준까지 축적되어 뉴런의 발화를 초래한다. 유사하게, 독립 개체 레벨의 이진 개체 상태는 사건 발생시 계속해서 현실 상태로 바뀌고, 트리거 CES의 임계 값에 도달하여 다른 SI의 변화를 초래한다. (도 99b를 참조하여 더 자세히 설명했다.) 이것은 NSL이 인간의 뇌가 작동하는 방식을 모방할 수 있는 방법에 극적인 영향을 미친다. 확장하여 인공 신경망 (ANN) 환경을 효과적으로 처리하는 능력은 매우 높다. (도 64를 참조하여 더 자세히 설명 했다.) NSL은 보다 구조화되고 네트워크화 된 솔루션 환경을 다룰 수 있는 유연한 프레임워크를 제공한다. 그런 의미에서, 그것은 기계적 모델과 생물학적 모델 모두에 적용하기에 매우 적합하다. NSL에서의 가능성-선택-작용 주기와, 단백질 형성을 위해 작용하는, 'RNA로 이어지는 DNA'에 의해 선택될 가능 성으로 제시된 아미노산 사이의 유사점을 그리는 것은 흥미롭다. NSL은 프로그래밍 코드를 소비하여 이를 자연어 정보 형식으로 변환할 수 있다. (도 102a 내지 102d를 참조하여 동일한 내용을 더 자세히 설명한다.) 동일한 토큰으로, 그것은 또한 자연어 검색의 영역에 속할 수 있도록 NSL 형식으로 변환될 DNA에 포함된 정보를 추출할 수 있는 잠재성을 보유하고 있다. (도 73을 참조하여 동일한 내용을 더 자세히 설명한다.) NSL은 현재 차별화 원칙에 기초하여 프로그래밍 로직에 속하는 정보 기술의 추상화 수준을 다루는 데 초점을 맞 추고 있다. (도 66을 참조하여 더 자세히 설명한다.)차별화 원리의 적용은 프로그래밍 계층에만 국한되지 않기 때문에, 미래에는 운영 체제 이하의 추상화 수준에도 동일한 원리를 적용할 가능성이 있다. 이러한 일이 발생하면, 후드 아래의 블랙 박스에 있는 많은 기능이 사용자에게 더 투명 해져 더 나은 이해와 관 리를 할 수 있다. NSL의 애그노스틱은 또한 NSL 형식의 해당 언어에 포함된 로직을 추출하고 새 솔루션처럼 이러한 솔루션을 사용 할 수 있는 능력을 가지고 있기 때문에 과거에 작성된 프로그램에도 확장된다. NSL은 임의의 프로그래밍 코드를 NSL 형식과 같은 자연어로 변환할 수 있는 기능을 가지고 있다 (도 75에서 동 일한 내용을 더 자세히 설명한다.). NSL은 NSL로 구성된 솔루션을 임의의 프로그래밍 언어 코드로 변환하는 기능을 가지고 있다. (도 75에서 동일한 내용을 더 자세히 설명한다.) NSL은 임의의 프로그래밍 언어의 솔루션을 임의의 다른 프로그래밍 언어/자연어로 변환하는 능력을 가지고 있다. (도 75를 참조하여 더 자세히 설명했다.) NSL은 일련의 사전 정의된 질의에 대한 응답을 통해 솔루션 구성을 제공한다. (도 76을 참조하여 더 자세히 설 명한다.) NSL은 책을 읽는 것과 유사한 솔루션을 볼 수 있는 경험을 사용자에게 제공한다. (도 77을 참조하여 더 자세히 설명한다.) NSL은 동사가 자연어에 더 가까워 보이게 하도록 동사를 기능에 자동 할당한다. (도 78을 참조하여 더 자세히 설명한다.) 기존 관행으로부터 로직은 NSL에 의해 추출될 수 있다. (도 79를 참조하여 더 자세히 설명한다.) NSL은 솔루션 로직 서브스트레이트를 애그노스틱하게 만든다. (도 80을 참조하여 더 자세히 설명한다.) NSL은 이벤트, 정보, 공간, 시간 및 자원 소비에 의한 개체 간의 거리 식별을 통해 솔루션을 정량화한다. (도 81을 참조하여 더 자세히 설명한다.) 솔루션 로직을 투명하게 만들고 기존의 솔루션 구성 요소를 재사용함으로써 NSL은 중복 제거를 통해 로직 압축 을 돕는다. (도 82를 참조하여 더 자세히 설명한다.) NSL은 솔루션 로직의 압축으로 인해 계산 자원의 감소를 돕는다. NSL의 원리는 엔지니어링 설계에 적용될 수 있다. (도 83을 참조하여 더 자세히 설명한다.) NSL은 통제된 차별화를 위한 컨테이너 시스템을 채택하고 클래스, 하위 클래스 및 멤버에 ID를 자동 할당한다. (도 85를 참조하여 더 자세히 설명한다.) NSL은 정적 문서를 NSL 형식으로 변환하는 기능을 제공한다. (도 86을 참조하여 더 자세히 설명한다.) NSL은 5 가지 주요 감각과 추가 감각을 커버하기 위해 일반 화면 이상으로 사용자 인터페이스를 확장한다. (도 87을 참조하여 이를 더 자세히 설명한다.) NSL은 자원의 사용 및 유휴 시간을 추적하는 데 도움이 된다. (도 89를 참조하여 이를 더 자세히 설명한다.) NSL은 순서도에서 솔루션 로직을 추출하고 NSL 형식으로 솔루션을 재구성한다. NSL은, 예를 들어 주어진 솔루션 로직을 사용한 사용자의 수를 식별하는, 솔루션 레벨 트랜잭션의 수를 제공한 다. 특정 기간에 개체가 사용된 횟수 또는 특정 시간에 사용중인 개체의 수는 NSL에 의해 캡처될 수 있다. NSL은 사용자 경험을 보존하면서 기존 솔루션과 원활하게 통합되는 자연어 구조로 개발된 API를 가지고 있다. NSL은 기계 에이전트에 의한 솔루션 개발을 지원하는 DLD 엔진을 제공한다. (도 116을 참조하여 이를 더 자세히 설명한다.) NSL은 SOP를 NSL 형식으로 변환하는 기능을 제공한다. (도 117을 참조하여 이를 더 자세히 설명한다.) 모든 변경 유닛은 글로벌 의도 진술을 달성하기 위한 순차적인 방식이다. (도 118을 참조하여 이를 더 자세히 설명한다.) XOR 연산자 다음의 대체 옵션의 경우, 모든 변경 유닛은 글로벌 의도 진술을 달성하기 위해 대체 방식으로 배열 된다. (도 119를 참조하여 이를 더 자세히 설명한다.) 병렬 옵션 트리거링의 경우, 모든 변경 유닛은 글로벌 의도 진술을 달성하기 위해 여러 에이전트와 병렬 방식으 로 배열된다. (도 120을 참조하여 이를 더 자세히 설명한다.) 유리한 지점 까지 올라가면, 낮은 유리한 지점의 변경 유닛은 종속 변경 유닛이 된다. (도 121을 참조하여 이를 더 자세히 설명한다.) GSI가 여러 에이전트의 GSI에 걸쳐 있을 때, 에이전트의 다른 GSI의 변경 유닛을 트리거하는 한 에이전트의 GSI 가 일시적인 변경 유닛이 된다. (도 122를 참조하여 이를 더 자세히 설명한다.) 변경 유닛은 그 자체가 임베디드 서브 변경 유닛이라고 하는 다중 로컬 의도 진술을 가질 수 있다. (도 123을 참조하여 이를 더 자세히 설명한다.) 설계자가 설계한 솔루션을 솔루션 클래스라고 하며 배포시 사건에 이르면 트랜잭션 클래스가 된다. (도 124를 참조하여 이를 더 자세히 설명한다.) 컨텍스트 별 삼중 신원 모델은 조직 수준에서 가장 낮은 수준의 속성까지 신원을 허용한다. (도 125를 참조하여 이를 더 자세히 설명한다.) NSL은 HUB의 역할을 하여 임의의 여러 서브스트레이트로부터 솔루션을 허용한다. (도 126을 참조하여 이를 더 자세히 설명한다.) 도면에 대한 자세한 설명 도 91은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하 는 방법을 나타내는 순서도를 나타낸다. 방법에 따르면, 단계 9102에서, 사용자로부터 컴퓨팅 장치의 프로세서 에 의해, 솔루션 구축을 위한 글로벌 의도 진술을 수신하고, 여기서 글로벌 의도 진술은 자연어의 형태로 수신 되고 잠재성 상태로 설정된다. 단계 9104에서, 프로세서에 의해, 사용자로부터 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관된 개체와 에이전트의 세부사항을 수신하고, 여기서 각 로 컬의 의도 진술과 각 개체 및 에이전트의 세부 정보는 자연어의 형태로 수신되고 각각 잠재성 상태로 설정되고, 각각의 로컬 의도 진술은 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 대응하는 로컬 의도 진술에 의해 표시된 단계에 참여하고, 에이전트는 인간 에이전트, 기계 에이전트 및 컴퓨터 기능 중 적어도 하나이다. 단계 9106에서, 프로세서에 의해, 각각의 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합 에 기초하여 조합 개체 상태 (CES) 세트를 형성하고, 여기서 각각의 로컬 의도 진술의 모든 개체에 기초하여 형 성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 세트의 각 CES는 잠재성 상태에 있다. 단계 9108에서, 글 로벌 의도 진술과 연관된 하나의 수신된 로컬 의도 진술만을 결정하고, 솔루션 구축의 종료로서 수신된 로컬 의 도 진술의 트리거 CES를 식별한다. 단계 9110에서, 글로벌 의도 진술과 연관된 하나 이상의 수신된 로컬 의도 진술을 결정하고, 프로세서에 의해, 자연어의 형태로 사용자로부터 로컬 의도 진술 간의 관계를 수신하고, 여기 서 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 CES 세트에 영향을 미치는지 또는 솔루션 구축의 종료인지 여부를 나타낸다. 도 92는 자연어 기반 컴퓨터 구현 솔루션을 구축하기 위해 프로그래밍 코드를 자연어로 변환하는 방법을 나타내 는 순서도를 나타낸다. 방법에 따르면, 단계 9202에서, 컴퓨팅 장치의 프로세서에 의해 프로그래밍 코드를 구문 분석하여 프로그래밍 코드에 존재하는 기호, 키워드, 연산자 및 함수를 추출한다. 단계 9204에서, 프로세서에 의해 데이터베이스에 저장된 자연어 데이터를 가지는 추출된 기호, 키워드, 연산자 및 함수의 매핑에 기초하는, 복수의 로컬 의도 진술, 복수의 로컬 의도 진술 각각과 관련된 개체 및 각 개체와 관련된 속성을 결정하고, 복 수의 로컬 의도 진술, 개체 및 속성 각각을 잠재성 상태로 설정하고, 여기에서 각 로컬 의도 진술은 솔루션을 구축하는 단계를 나타내며, 각 개체는 해당 로컬 의도 진술에 표시된 단계에 참여하며, 속성은 각각의 개체의 특성을 정의하고 대응하는 로컬 의도 진술의 다른 개체와 각각의 개체를 구별하는 특성을 정의한다. 단계 9206 에서, 프로세서에 의해, 각각의 로컬 의도 진술에 대해, 각각의 로컬 의도 진술의 개체의 모든 가능한 조합에 기초하는 조합 개체 상태 (CES) 세트를 형성하고, 여기서 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성 된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 세트의 각 CES는 잠재적 상태에 있다. 단계 9208에서, 프로세서에 의해, 추출된 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터의 매핑에 기초하여 로컬 의도 진 술 간의 관계를 결정하며, 여기서 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 CES 세 트에 영향을 미치는지 또는 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고, 관 계는 데이터베이스에 저장된 자연어 데이터와 관련하여 순서도를 분석함으로써 결정된다. 단계 9210에서, 프로 세서에 의해, 자연어의 형태로 사용자로부터 복수의 로컬 의도 진술 각각과 연관된 에이전트의 세부 정보를 수 신하고 잠재적 상태에서 에이전트의 세부 정보를 설정하고, 여기에서 에이전트는 인간 에이전트, 기계 에이전트 및 컴퓨터 기능 중 적어도 하나이다. 도 93은 자연어를 기반으로 구축된 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하는 방법을 나타내는 순서도 를 나타낸다. 방법에 따르면, 단계 9302에서, 컴퓨팅 장치의 프로세서에 의해 컴퓨터 구현 솔루션을 구문 분석 하고, 여기에서 컴퓨터로 구현된 솔루션은 복수의 로컬 의도 진술, 복수의 로컬 의도 진술 각각과 연관된 개체, 개체 각각과 연관된 속성, 복수의 로컬 의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES을 포함하고, 각각의 로컬 의도 진술은 솔루션을 구축하는 단계를 나타내며, 각 개체는 해당 로컬 의도 진술에 표 시된 단계에 참여하고, 속성은 각각의 개체의 특성을 정의하고 해당 로컬 의도 진술의 다른 개체와 각 개체를 구별하며, 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 CES 세트에 영향을 미치는지 또는 컴퓨터 구현 솔루션을 구축하기위한 글로벌 의도 진술의 종료인지 여부를 나타낸다. 단계 9304에서, 컴퓨팅 장 치의 프로세서에 의해 복수의 자연어 솔루션 구성 요소를 추출하고, 여기에서 자연어 솔루션 구성 요소는: 글로 벌 의도 진술, 복수의 로컬 의도 진술, 개체 각각과 연관된 속성, 복수의 로컬 의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함한다. 단계 9306에서, 데이터베이스에 저장된 프로그래밍 언어의 기 호, 키워드, 연산자 및 기능과 자연어 솔루션 구성 요소의 매핑에 기초하여 프로그래밍 언어 코드를 자동 생성 한다. NSL은 하나 이상의 컴퓨터 시스템에서 구현되거나 이를 포함할 수 있다. 도 94는 컴퓨팅 환경의 일반화된 예를 보여준다. 컴퓨팅 환경은 설명된 실시 예의 사용 또는 기능의 범위에 대한 어떠한 제한도 제안하려 는 것은 아니다. 도 94를 참조하면, 컴퓨팅 환경은 적어도 하나의 처리 유닛 및 메모리를 포함한다. 처리 유 닛은 컴퓨터 실행 가능 명령어를 실행하고 실제 또는 가상 프로세서일 수 있다. 다중 처리 시스템에서 여 러 처리 장치는 컴퓨터 실행 명령을 실행하여 처리 능력을 높인다. 메모리는 휘발성 메모리 (예를 들어, 레지스터, 캐시, RAM), 비 휘발성 메모리 (예를 들어, ROM, EEPROM, 플래시 메모리 등), 또는 둘의 일부 조합일 수 있다. 일부 실시 예에서, 메모리는 설명된 기술을 구현하는 프레임워크를 저장한다. 컴퓨팅 환경은 추가 기능을 가질 수 있다. 예를 들어, 컴퓨팅 환경은 스토리지, 하나 이상의 입력 디바이스, 하나 이상의 출력 디바이스 및 하나 이상의 통신 연결을 포함한다. 버스, 컨트롤 러 또는 네트워크와 같은 상호 연결 메커니즘 (미도시)은 컴퓨팅 환경의 구성 요소를 상호 연결한다. 일 반적으로, 운영 체제 소프트웨어 (미도시)는 컴퓨팅 환경에서 실행되는 다른 소프트웨어를 위한 운영 환 경을 제공하고 컴퓨팅 환경의 구성 요소의 활동을 조정한다. 스토리지는 착탈 가능 또는 착탈 불가능할 수 있으며, 정보를 저장하는 데에 사용되며 컴퓨팅 환경 내에서 액세스될 수 있는, 자기 디스크, 자기 테이프 또는 카세트, CD-ROM, CD-RW, DVD 또는 정보를 포함한다. 일부 실시 예에서, 저장소는 프레임워크에 대한 명령어를 저장한다. 입력 디바이스는 키보드, 마우스, 펜, 트랙볼, 터치 스크린 또는 게임 컨트롤러와 같은 터치 입력 장치, 음성 입력 장치, 스캔 장치, 디지털 카메라 또는 다른 장치일 수 있다. 컴퓨팅 환경에 입력을 제공한다. 출력 디바이스는 디스플레이, 프린터, 스피커, 또는 컴퓨팅 환경으로부터의 출력을 제공하는 다른 장치 일 수 있다. 통신 연결은 통신 매체를 통해 다른 컴퓨팅 개체로의 통신을 가능하게 한다. 통신 매체는 컴퓨터 실행 가 능 명령, 오디오 또는 비디오 정보, 또는 변조된 데이터 신호의 기타 데이터와 같은 정보를 전달한다. 변조된 데이터 신호는 신호의 정보를 인코딩하는 방식으로 설정되거나 변경된 특성 중 하나 이상을 갖는 신호이다. 제 한이 아닌 예로서, 통신 매체는 전기, 광학, RF, 적외선, 음향 또는 기타 캐리어로 구현되는 유선 또는 무선 기 술을 포함한다. 구현은 컴퓨터 판독 가능 매체의 일반적인 컨텍스트에서 설명될 수 있다. 컴퓨터 판독 가능 매체는 컴퓨팅 환경 내에서 액세스할 수 있는 사용 가능한 매체이다. 제한이 아닌 예로서, 컴퓨팅 환경 내에서, 컴퓨터 판독가능 매체는 메모리, 저장소, 통신 매체, 및 이들 중 임의의 조합을 포함한다. 설명된 실시 예를 참조하여 본 개시의 원리를 설명하고 예시하였지만, 설명된 실시 예는 그러한 원리에서 벗어 나지 않고 배열이 수정될 수 있다는 것을 인식할 것이다. 본 개시의 원칙이 적용될 수 있는 많은 가능한 실시 예를 고려하여, 청구 범위 및 그에 상응하는 내용의 범위와 사상 내에 있을 수 있는 모든 실시 예를 주장한다. 본 개시가 전술한 실시 예들과 관련되어 있었지만, 당업자는 개시가 도시된 실시 예들에 제한되지 않음을 인식 할 것이다. 본 개시는 첨부된 청구 범위의 사상 및 범위 내에서 수정 및 변경되어 실행될 수 있다. 따라서, 설 명은 본 발명을 제한하는 것이 아니라 예시적인 것으로 간주되어야 한다. 당업자에 의해 이해되는 바와 같이, 전술한 예시, 설명 및 방법의 단계는 범용 또는 특수 목적 컴퓨터와 같은 프로세서 기반 시스템상의 적절한 코드에 의해 구현될 수 있다. 또한, 본 기술의 상이한 구현은 본 명세서에서 설명된 일부 또는 모든 단계를 상이한 순서로 또는 실질적으로 동시에, 즉 병렬로 수행할 수 있다는 점에 유의 해야 한다. 또한, 기능은 다양한 프로그래밍 언어로 구현될 수 있다. 당업자에 의해 이해되는 바와 같이, 이러 한 코드는 저장된 코드를 실행하기 위해 프로세서 기반 시스템에 의해 액세스될 수 있는, 메모리 칩, 로컬 또는 원격 하드 디스크, 광학 디스크 또는 기타 매체와 같은 하나 이상의 유형의 기계 판독 가능 매체에 저장 또는 저장되도록 구성될 수 있다. 유형 매체는 종이 또는 지침이 인쇄되는 다른 적절한 매체를 포함할 수 있음에 유 의한다. 예를 들어, 명령은 종이 또는 다른 매체의 광학 스캐닝을 통해 전자적으로 캡처된 다음에, 필요한 경우 적절한 방식으로 컴파일, 해석 또는 처리되고, 컴퓨터 메모리에 저장될 수 있다. 상세한 설명은 당업자가 본 개시를 만들고 사용할 수 있도록 제시되고 특허 획득을 위한 요건의 컨텍스트에서 제공된다. 본 설명은 본 개시를 수행하기 위해 현재 고려되는 최선의 방법이다. 바람직한 실시 예에 대한 다양 한 수정은 당업자에게 명백할 것이며, 본 개시의 일반적인 원리는 다른 실시 예에 적용될 수 있고, 본 개시의 일부 특징은 다른 특징의 대응하는 사용 없이 사용될 수 있다. 따라서, 본 개시는 도시된 실시 예로 제한되는 것이 아니라 여기에 설명된 원리 및 특징과 일치하는 가장 넓은 범위에 부합되어야 한다. 일 구현 예에 따르면 본 발명은 사용자가 이해하는 자연어를 사용하고 프로그래밍 코드를 사용하지 않고 컴퓨터 구현 솔루션을 구축하는 방법에 관한 것으로, 상기 방법은: 컴퓨팅 장치의 프로세서에 의해 사용자로부터 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 수신하는 단계 - 상기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설정됨 - ; 상기 프로세서에 의해 상기 사용자로부터 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 수신하는 단계 - 각각의 로컬 의도 진술 및 상기 개체와 에이전트의 상기 세부 정보는 상기 자연어의 형태로 수신되고 각각 잠재 성의 상태로 설정되며, 각 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대 응하는 로컬 의도 진술에 의해 나타내는 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전 트 중 적어도 하나임 - ; 상기 프로세서에 의해, 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상 기 개체의 모든 가능한 조합을 기반으로 하는 조합 개체 상태 (CES)의 세트를 형성하는 단계 - 상기 각각의 로 컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트 의 각 CES는 잠재적 상태에 있음 -; 상기 글로벌 의도 진술과 관련된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로서 식 별하는 단계; 및 상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 프로세서에 의해 상기 사용자로부터 상기 자연어 형태로 상기 로컬 의도 진술 간의 관계를 수신하는 단계 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는 지 또는 상기 솔루션을 구축하는 단계의 종료인지 여부를 나타냄 - 을 포함한다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술에 대해, 상기 프로세서에 의해 상기 사용자로부터 상기 자연어의 형태로, 상기 각 로컬 의도 진술의 특성을 정의하는 하나 이상의 속성을 수신하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 각 개체에 대해, 상기 프로세서에 의해 상기 사용자로부터 상기 자연어 형 태로, 상기 각 개체의 특성을 정의하고 상기 해당 로컬 의도 진술의 다른 개체와 상기 각 개체를 차별화하는 하 나 이상의 속성을 수신하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 관계를 수신하는 단계는 상기 글로벌 의도 진술에 대한 상기 로컬 의도 진술 사이의 복수의 별개의 관계를 수신하는 단계를 포함하고, 각 별개의 관계는 상기 솔루션을 구축하는 별개의 경로이다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술의 각 개체에 대해: 상기 프로세서에 의해 상기 관련 에 이전트로부터 상기 자연어의 형태로 상기 각 개체에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 개체 에 대한 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각 개체에 대해 상기 잠재성 상태를 현실 상태 로 변경하는 사건의 기록이다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술의 각 속성에 대해: 상기 프로세서에 의해 상기 관련 에 이전트로부터 상기 자연어의 형태로 상기 각 속성에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 속성 에 대한 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각 속성에 대해 상기 잠재성 상태를 현실 상태 로 변경하는 사건의 기록이다. 일 구현 예에 따르면, 상기 방법은, 각 개체의 속성에 대해: 상기 프로세서에 의해 상기 관련 에이전트로부터 상기 자연어의 형태로 상기 각 속성에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 속성에 대한 상기 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각각의 속성에 대해 상기 잠재성 상태를 현실 상태로 변 경하는 사건의 기록이다. 일 구현 예에 따르면, 상기 방법은, 상기 프로세서에 의해, 로그인 세부 정보, 생체 측정 세부 정보, 얼굴 인식 기술 및 망막 감지 기술 중 하나를 기반으로 상기 관련 에이전트를 인증하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 각 로컬 의도 진술과 관련된 모든 개체에 대해 상기 값을 수신하는 단계는, 상기 각 로컬 의도 진술에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건의 기록이다. 일 구현 예에 따르면, 상기 모든 로컬 의도 진술과 관련된 모든 개체에 대해 상기 값을 수신하는 단계는, 상기 글로벌 의도 진술에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건 기록이다. 일 구현 예에 따르면, 상기 기계 에이전트는 유선 통신 채널 또는 무선 통신 채널을 통해 상기 컴퓨팅 장치에 통신 가능하게 결합된다. 일 구현 예에 따르면, 상기 기계 에이전트는 상기 컴퓨팅 장치의 기능적 모듈이며 상기 프로세서에 연결된다. 일 구현 예에 따르면, 상기 글로벌 의도 진술과 관련된 로컬 의도 진술은: 다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 로컬 의도 진술; 또는 다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다 른 컴퓨터 구현 솔루션의 글로벌 의도 진술이다. 일 구현 예에 따르면, 상기 글로벌 의도 진술의 로컬 의도 진솔과 관련된 개체는, 다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 로컬 의도 진술; 또는 다른 컴퓨터 구현 솔루션을 차용하기 위 한 상기 다른 컴퓨터 구현 솔루션의 개체이다. 일 구현 예에 따르면, 상기 각각의 로컬 의도 진술의 특성을 정의하는 속성은, 다른 컴퓨터 구현 솔루션을 차용 하기 위한 상기 다른 컴퓨터 구현 솔루션의 개체; 또는 다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴 퓨터 구현 솔루션의 속성이다. 일 구현 예에 따르면, 상기 각각의 개체의 특성을 정의하는 속성은, 다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 개체; 또는 다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 속성이다. 일 구현 예에 따르면, 상기 솔루션은, 로컬 의도 진술을 둘 이상의 다른 로컬 의도 진술로 나누고 상기 해당 개 체 및 에이전트를 각 로컬 의도 진술에 첨부하거나; 두 개 이상의 로컬 의도 진술을 하나의 로컬 의도 진술로 결합하고 상기 해당 개체 및 에이전트를 해당 로컬 의도 진술에 첨부하여 구축된다. 일 구현 예에 따르면, 상기 솔루션은 자연어를 사용하여 구축되므로 하나 이상의 검색 엔진에 의해 상기 솔루션 은 검색 가능하다. 일 구현 예에 따르면, 상기 방법은, 각 개체에 대한 하나 이상의 정보 권한 또는 결정 권한을 상기 각 개체의 상기 로컬 의도 진술과 관련된 상기 에이전트에 할당하는 단계; 및 상기 할당된 정보 권한 또는 결정 권한에 기 초하여 상기 에이전트에게 개체를 표시하는 단계를 더 포함한다. 일 구현 예에 따르면, 속성의 개수가 적을수록 상기 각각의 개체는 더욱 일반화되고, 속성 개수가 많을수록 개 체 간의 차별화는 더욱 크다. 일 구현 예에 따르면, 상기 방법은, 상기 사용자 인터페이스를 통해 개체를 표시하여 상기 연관된 에이전트가 상기 개체에 대한 값을 수신하는 단계를 더 포함한다.일 구현 예에 따르면, 상기 방법은, 상기 개체에 대한 값을 수신하도록 상기 로컬 의도 진술 사이에 하나 이상 의 별개의 관계를 제공하는 단계를 더 포함하고, 상기 하나 이상의 별개의 관계를 제공하는 단계는 조직화된 프 로세스, 자동화된 프로세스 또는 인간 에이전트 주도 프로세스에 기반한다. 일 구현 예에 따르면, 상기 방법은, 로컬 의도 진술의 하나 이상의 개체 또는 하나 이상의 CES가 다른 컴퓨터 구현 솔루션의 하나 이상의 로컬 의도 진술과 공유되고, 상기 공유 개체 또는 CES는 임의의 시점에서 하나의 트 리거 CES에만 참여하여 상기 하나의 트리거 CES에 대응하는 상기 로컬 의도 진술에 대해 상기 잠재적 상태를 상 기 현실 상태로 변경하고, 상기 공유된 개체 또는 CES의 이용 가능성은 다중 로컬 의도 진술에 대해 상기 잠재 적 상태에서 상기 현실 상태로의 변경 순서에 영향을 준다. 일 구현 예에 따르면, 상기 개체는 본질적으로 물리적이며, 상기 개체는 공간과 시간에 존재한다. 일 구현 예에 따르면, 상기 로컬 의도 진술을 수신하고 상기 개체의 세부 정보를 수신하는 단계는, 다른 컴퓨터 구현 솔루션의 로컬 의도 진술 및 개체를 저장하는 데이터베이스의 라이브러리에서 하나 이상의 가능한 로컬 의 도 진술 및 하나 이상의 가능한 개체를 제공하는 단계를 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 프로세서에 의해 상기 고유한 관계 중 하나를 선택하여 상기 개체에 대한 상기 값을 수신하고 다른 고유한 관계를 제거하는 방법을 더 포함한다. 일 구현 예에 따르면, 상기 자연어는 하나 이상의 모국어, 하나 이상의 수화, 하나 이상의 기호, 하나 이상의 숫자 또는 이들의 조합을 기반으로 한다. 일 구현 예에 따르면, 상기 자연어 형태의 정보는 필기 기반 인터페이스, 터치 감지 인터페이스, 음성 기반 인 터페이스, 이미지 기반 인터페이스 또는 비디오 기반 인터페이스 또는 이들의 조합을 통해 수신되고, 상기 자연 어 형태로 수신된 정보는 물체 인식 기술, 문자 인식 기술, 이미지 인식 기술 또는 이들의 조합을 이용하여 해 독된다. 일 구현 예에 따르면, 상기 방법은, 상기 프로세서에 의해 기록될 남은 사건의 수를 결정하는 단계; 및 상기 프 로세서에 의해 상기 남은 사건의 수를 표시하는 단계를 더 포함한다. 일 구현 예에 따르면, 사용자 인터페이스에서의 각 개체 및 각 로컬 의도 진술의 위치는, 드래그 앤 드롭 기능 - 상기 드래그 앤 드롭 기능은 유선 입력 장치, 무선 입력 장치 및 터치 감지 인터페이스 중 적어도 하나에 의 해 실행됨 - ; 또는 각 개체의 위치 좌표 또는 각 로컬 의도 진술에 해당하는 속성의 값을 변경함으로써 변경 가능하다. 일 구현 예에 따르면, 상기 방법은, 퍼블릭 블록 체인 기술, 프라이빗 블록 체인 기술, 하이브리드 블록 체인 기술 중 하나를 적용하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 퍼블릭 블록 체인 기술, 상기 프라이빗 블록 체인 기술 및 상기 하이브리드 블록 체 인 기술의 각각은 대칭 키 암호화 기술, 비대칭 키 암호화 기술 또는 이들의 조합을 기반으로 한다. 일 구현 예에 따르면, 상기 방법은, 하나 이상의 사전 정의된 규범을 기반으로 하는 측정 프레임워크를 상기 개 체에 할당하는 단계를 더 포함하고, 상기 측정 프레임워크는 개체가 상기 잠재적 상태에서 현실 상태로 변경되 는 기간을 표시한다. 일 구현 예에 따르면, 상기 방법은, 상기 프로세서가 상기 사용자로부터 각 로컬 의도 진술과 관련된 정보 개체 의 세부 정보를 수신하는 단계를 더 포함하고, 각 정보 개체의 세부 정보는 상기 자연어의 형태로 수신되고 잠 재성 상태로 설정되며, 각각의 정보 개체는 상기 트리거 CES를 형성하는 상기 개체와 상이하다. 일 구현 예에 따르면, 상기 방법은, 데이터베이스의 라이브러리 형태로, 다른 컴퓨터 구현 솔루션을 구축하는 데 사용할 상기 글로벌 의도 진술, 상기 로컬 의도 진술, 상기 개체 및 상기 에이전트 중 하나 이상과 관련된 데이터를 저장하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 데이터베이스에 상기 라이브러리에 대한 질의 기반 액세스를 제공하는 단계를 더 포함하고, 상기 질의 기반 액세스는 재사용을 위해 적절한 개체를 식별하기 위한 검색 및 질의 기반 기술에 의존하고, 상기 질의 기반 액세스는 구조적 질의 언어(SQL) 및 낫 온리 구조적 질의 언어(NoSQL) 중 적 어도 하나를 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 데이터베이스의 상기 라이브러리에 대해 드래그 앤 드롭 액세스를 제 공하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 CES 중 하나 이상의 과거 행동 및 상기 사건 중 하나 이상의 발생에 기초하여 상기 개체 중 하나 이상 및 상기 사건 중 하나 이상에 대응하는 하나 이상의 불확실성 및 확률을 제공 하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 컴퓨터 구현 솔루션에 대한 각 로컬의 의도 진술에 회계 및 재무 시스 템과 관련된 하나 이상의 개체를 첨부하여 회계 및 재무 시스템을 통합하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 개체 중 하나 이상 및 상기 사건 중 하나 이상에 대응하는 하나 이상 의 불확실성 및 확률을 제공하고 상기 사건의 기록을 위한 상기 값의 수신을 최적화하기 위해 하나 이상의 고급 계획 및 최적화 (APO) 기능을 수행하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 기계 학습 기술 및 인공 지능 기술; 하나 이상의 사건의 발생을 제공하는 개체 중심 접근법; 및 각 사건의 데이터 및 행동 패턴의 저장 중 하나 이상을 기반으로 상기 CES의 하나 이상의 과거 행동 및 상기 사건의 하나 이상의 발생을 평가하는 단계를 더 포함하고, 상기 기계 학습 기술은 지도 학습 기술 및/또는 비지도 학습 기술 및/또는 준지도 학습 기술을 포함하고, 상기 지도 학습 기술은 지원 벡터 기계, 선형 회귀, 로지스틱 회귀, 나이브 베이즈(naive Bayes), 선형 판별 분석, 결정 트리, k-최근 접 이웃 알고리즘 및 신경망 중 적어도 하나를 포함하고, 상기 비지도 학습 기술은 계층적 클러스터링, K-평균 클러스터링, K-NN (k 개의 최근접 이웃) 및 연관 규칙 중 적어도 하나를 포함한다. 일 구현 예에 따르면, 상기 방법은, 대화형 설문에 대한 응답으로 상기 글로벌 의도 진술 중 하나 이상, 각 로 컬의 의도 진술 및 상기 개체의 상기 세부 정보를 수신하는 단계를 더 포함하고, 상기 대화형 설문은 상기 컴퓨 터 구현 솔루션을 구축하기 위한 구조화된 형식의 질문을 포함한다. 일 구현 예에 따르면, 상기 방법은, 자연어 문법에 기반하여 상기 수신된 글로벌 의도 진술 중 하나 이상, 각 로컬 의도 진술 및 상기 개체의 세부 정보를 수정하는 단계를 더 포함하며, 상기 자연어 문법은 자연어 라이브 러리를 사용하여 상기 수정을 위한 하나 이상의 적절한 동사와 전치사를 선택한다. 일 구현 예에 따르면, 상기 방법은, 상기 프로세서에 의해, 상기 남은 사건의 수에 필요한 시간 및 리소스의 양 을 결정하는 단계; 및 상기 프로세서에 의해, 상기 필요한 시간 및 리소스의 양을 표시하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 프로세서에 의해, 상기 잠재성 상태에서 상기 현실 상태로의 변경 시 기록된 두 개의 연속적 사건 사이의 최적 유휴 시간을 데이터베이스에 저장하는 단계; 상기 프로세서에 의해, 상기 잠재적 상태가 상기 현실 상태로 변경될 때 기록된 각각의 두 연속적 사건 사이의 유휴 시간을 실시간으로 결정하는 단계; 및 상기 프로세서에 의해, 상기 결정된 유휴 시간과 상기 최적의 유휴 시간을 비교하여 보고를 준비하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 프로세서에 의해, 상기 수신된 값을 데이터베이스에 저장된 최적 값과 비교하는 단계; 및 상기 프로세서에 의해, 상기 수신된 값이 컴퓨터 구현 솔루션을 구축하기 위해 좋은지, 나쁜 지 또는 양가적인지 상기 비교를 기반으로 결정하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술, 각 개체 및 각 에이전트에 고유 식별자 (ID)를 할당하 는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 사용자가 자원 유휴 시간을 최적화하기 위해 사용 가능한 모든 개체의 최적 사용을 정의할 수 있도록 하는 단계; 및 각 개체와 관련된 시간 및 공간의 속성 모니터링을 통해 가치 창 출 활동에 대한 개체 참여를 실시간으로 추적하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 하나 이상의 결과적 가능성 및 하나 이상의 기회 또는 하나 이상의 위험에 대한 하나 이상의 가치 판단을 제공하고 상기 하나 이상의 결과적 가능성에 대한 하나 이상의 확률을 상기 에이 전트에 할당하는 단계; 또는 상기 하나 이상의 개체를 변경함으로써 하나 이상의 경로에 개입하고 변경하기 위 해 하나 이상의 동작을 수행하고, 상기 동작은 연관된 에이전트에 의해 원하는 하나 이상의 자원 최적화 원칙을 구동하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 하나 이상의 별개의 경로를 고르고 선택할 수 있는 하나 이상의 가능 한 경로를 제공하는 단계를 더 포함하고, 상기 하나 이상의 가능한 경로는 데이터베이스의 라이브러리에서 검색된 상기 컴퓨터 구현 솔루션과 유사한 솔루션이다. 일 구현 예에 따르면, 상기 방법은, 상기 데이터베이스의 상기 라이브러리에서 하나 이상의 감독 및/또는 하나 이상의 비감독 기계 학습 방법을 구현하는 단계를 더 포함하고, 상기 하나 이상의 감독 및/또는 하나 이상의 비 감독 기계 학습 방법의 구현은 상기 솔루션 콘텐츠를 처리하기위한 NLP 구성 요소, ANN 구성 요소 및 최근접 이 웃 구성 요소를 포함하는 DLD 엔진에 의해 이루어지며, 상기 DLD 엔진은 상기 라이브러리의 일부인 풍부한 솔루 션 콘텐츠를 마이닝하고 상기 트랜잭션 클래스에서 트랜잭션 데이터를 추출하고, 상기 NSL 솔루션 라이브러리의 일부인 상기 풍부한 솔루션 콘텐츠와 상기 트랜잭션 클래스에서 추출된 상기 트랜잭션 데이터는 다양한 레벨에 서 거리를 계산할 수 있는 상기 DLD 엔진으로 공급되고, 상기 거리 계산은 기계 학습 알고리즘을 사용하는 NSL 개체 값, 시간 및 공간을 사용한다. 본 발명은 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하는 방법에 관한 것으로, 상기 방법은, 컴퓨팅 장치의 프로세서에 의해, 사용자에게 자 연어의 형태로 글로벌 의도 진술을 입력하라는 프롬프트를 제공하고 상기 솔루션 구축을 위해 상기 글로벌 의도 진술을 잠재성 상태로 설정하는 단계; 상기 프로세서에 의해, 상기 사용자에게 자연어의 형태로 글로벌 의도 진 술과 관련된 하나 이상의 로컬 의도 진술 및 상기 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 입력하라는 프롬프트를 제공하고 상기 하나 이상의 로컬 의도 진술 및 상기 개체 각각을 잠재성의 상태로 설정 하는 단계 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하는 단계를 나타내며, 각 개체는 상기 해당 로컬 의 도 진술에 표시된 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 상기 프로세서에 의해, 상기 각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 모든 가능한 조합에 기초하여 조합 개체 상태 (CES)의 세트를 형성하는 단계 - 상기 각각의 로컬 의도 진술의 상기 모든 개 체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있 음 - ; 상기 글로벌 의도 진술과 관련된 수신된 로컬 의도 진술을 단 하나만 결정한 것에 응답하여, 상기 프로 세서에 의해, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션의 구축의 종료로서 식별하는 단계; 및 상기 글로벌 의도 진술과 관련된 하나 이상의 수신된 로컬 의도 진술을 결정한 것에 응답하여, 상기 프로세 서에 의해, 상기 사용자에게 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 입력하라는 프롬프트를 제 공하는 단계 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - 를 포함한다. 일 구현 예에 따르면, 상기 방법은, 각 로컬의 의도 진술에 대해, 상기 프로세서에 의해, 상기 사용자에게 상기 각각의 로컬 의도 진술의 특성을 정의하는 하나 이상의 속성을 자연어의 형태로 입력하라 프롬프트를 제공하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 각 개체에 대해, 상기 프로세서에 의해 상기 사용자에게 상기 각 개체의 특 성을 정의하고 상기 각 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하는 하나 이상의 속성을 자연어의 형태로 입력하라는 프롬프트를 제공하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 관계에 대한 상기 프롬프트를 제공하는 단계는, 상기 사용자에게 상기 글로벌 의도 진술에 대한 상기 로컬 의도 진술 사이에 복수의 별개의 관계를 입력하는 프롬프트를 제공하는 단 계를 포함하고, 각각의 별개의 관계는 상기 솔루션을 구축하는 별개의 경로이다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술의 각 개체에 대해: 상기 프로세서에 의해, 상기 관련 에 이전트에게 상기 각 개체에 대한 값을 상기 자연어의 형태로 입력하라는 프롬프트를 제공하는 단계를 더 포함하 고, 상기 각각의 개체에 대한 상기 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각 개체에 대해 상기 잠재성 상태를 현실 상태로 변경하는 사건의 기록이다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술의 각 속성에 대해: 상기 프로세서에 의해, 상기 관련 에 이전트에게 상기 각 속성에 대한 값을 상기 자연어의 형태로 입력하라는 프롬프트를 제공하는 단계를 더 포함하 고, 상기 각 속성에 대한 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각각의 속성에 대해 상기 잠재 성 상태를 현실의 상태로 변경하는 사건의 기록이다. 일 구현 예에 따르면, 상기 방법은, 각 개체의 속성에 대해: 상기 프로세서에 의해, 상기 관련 에이전트에게 상 기 각 속성에 대한 값을 상기 자연어의 형태로 입력하라는 프롬프트를 제공하는 단계를 더 포함하고, 상기 각 속성에 대한 값을 수신하는 단계는 수신된 값에 기초하여 상기 각각의 속성에 대해 상기 잠재성의 상태를 현실 의 상태로 변경하는 사건의 기록이다.일 구현 예에 따르면, 상기 방법은, 상기 프로세서에 의해, 로그인 세부 정보, 생체 측정 세부 정보, 얼굴 인식 기술 및 망막 감지 기술 중 하나를 기반으로 상기 관련 에이전트를 인증하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술과 관련된 상기 개체 각각에 대해 상기 사건을 기록할 때, 상기 프로세서에 의해 상기 각 로컬 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 사건 을 기록하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 상기 사건을 기록할 때, 상기 프로세서에 의해, 상기 글로벌 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 사건을 기록하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 자연어는 하나 이상의 모국어, 하나 이상의 수화, 하나 이상의 기호, 하나 이상의 숫자 또는 이들의 조합을 기반으로 한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해할 수 있는 비디오와 자연어 를 사용하여 컴퓨터 구현 솔루션을 구축하는 방법에 관한 것으로, 상기 방법은: 컴퓨팅 장치의 프로세서에 의해, 상기 비디오의 이미지 프레임을 처리하여 복수의 차별화된 이미지 프레임을 식별하는 단계 - 각각의 차별 화된 이미지 프레임은 그 콘텐츠의 차이에 기초하여 비디오의 하나 이상의 이전 이미지 프레임과 다른 것으로 식별됨 - ; 상기 프로세서에 의해, 상기 비디오의 직전 이미지 프레임의 콘텐츠에 대해 각 차별화된 이미지 프 레임의 콘텐츠의 차이에 각각 근거하는 복수의 로컬 의도 진술을 결정하고 상기 로컬 의도 진술을 잠재성 상태 로 설정하는 단계 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저 장된 자연어 데이터와 관련하여 이미지 프레임의 상기 콘텐츠를 분석함으로써 결정됨 - ; 상기 프로세서에 의해, 상기 데이터베이스에 저장된 자연어 데이터와 관련하여 연속된 한 쌍의 차별화된 이미지 프레임 사이의 이미지 프레임의 내용을 분석하여 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을 결정하고, 상기 개체와 속성 각각을 잠재성의 상태로 설정하는 단계 - 각 개체는 상기 해당 로컬의 의도 진술에 표시된 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ; 상기 프로세서에 의해, 제 1 차별화된 이미지 프레임과 마 지막으로 차별화된 이미지 프레임의 상기 콘텐츠의 변경을 기반으로 상기 컴퓨터 구현 솔루션에 대한 글로벌 의 도 진술을 결정하고 상기 글로벌 의도 진술을 잠재성 상태로 설정하는 단계 - 상기 글로벌 의도 진술은 상기 데 이터베이스에 저장된 상기 자연어 데이터와 관련하여 상기 제 1 차별화 이미지 프레임 및 상기 마지막 차별화 이미지 프레임의 상기 콘텐츠를 분석함으로써 결정됨 - ; 상기 프로세서에 의해, 각 로컬 의도 진술에 대해, 상 기 각 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하여 조합 개체 상태 (CES)의 세트를 형성하는 단 계 - 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ; 상기 프로세서에 의해, 사용자로부터 자연어의 형태로 상기 복수 의 로컬 의도 진술 각각과 연관된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하는 단계 - 상기 에이전트는 적어도 인간 에이전트 및 기계 에이전트 중 하나임 - ; 및 상기 프로 세서에 의해, 상기 사용자로부터 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 수신하는 단계 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하는 단계의 종료인지를 나타냄 - 를 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 이미지 프레임을 처리하는 단계는 상기 이미지 프레임의 콘텐츠 및 상 기 이미지 프레임에 걸친 상기 콘텐츠의 변경에 기초하여 정보를 추출하는 단계를 더 포함하고, 상기 정보를 추 출하는 단계는 객체 인식 기술, 문자 인식 기술, 음성 인식 기술 또는 이들의 조합에 기반한다. 일 구현 예에 따르면, 상기 방법은, 상기 글로벌 의도 진술 및 상기 복수의 로컬 의도 진술 각각을 결정하는 단 계는 하나 이상의 동사를 사용하여 상기 컨텐츠의 상기 변경에 태그를 지정하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 관계를 수신하는 단계는 상기 글로벌 의도 진술에 대한 상기 로컬 의 도 진술 간의 복수의 별개의 관계를 수신하는 단계를 더 포함하고, 각 별개의 관계는 상기 솔루션을 구축하는 별개의 경로이다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술의 각 개체에 대해: 상기 프로세서에 의해 상기 관련 에 이전트로부터 상기 자연어의 형태로 상기 각 개체에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 개체 에 대한 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각 개체에 대해 상기 잠재성 상태를 현실 상태 로 변경하는 사건의 기록이다.일 구현 예에 따르면, 상기 방법은, 각 개체의 속성에 대해: 상기 프로세서에 의해 상기 관련 에이전트로부터 상기 자연어의 형태로 상기 각 속성에 대한 값을 수신하는 단계를 더 포함하고, 상기 각각의 속성에 대한 상기 값을 수신하는 단계는 상기 수신된 값에 기초하여 상기 각각의 속성에 대해 상기 잠재성 상태를 현실 상태로 변 경하는 사건의 기록이다. 일 구현 예에 따르면, 상기 방법은, 상기 프로세서에 의해, 로그인 세부 정보, 생체 측정 세부 정보, 얼굴 인식 기술 및 망막 감지 기술 중 하나를 기반으로 상기 관련 에이전트를 인증하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술과 관련된 상기 개체 각각에 대해 상기 사건을 기록할 때, 상기 프로세서에 의해 상기 각 로컬 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 사건 을 기록하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 방법은, 각 로컬 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 상기 사건을 기록할 때, 상기 프로세서에 의해, 상기 글로벌 의도 진술에 대해 상기 잠재성 상태를 상기 현실 상태로 변경하는 사건을 기록하는 단계를 더 포함한다. 일 구현 예에 따르면, 상기 자연어는 하나 이상의 모국어, 하나 이상의 수화, 하나 이상의 기호, 하나 이상의 숫자 또는 이들의 조합을 기반으로 한다. 본 발명은 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 표준 운영 절차 (SOP) 파일과 사용자가 이해 할 수 있는 자연어를 사용하는 컴퓨터 구현 솔루션의 구축 방법에 관한 것으로, 상기 SOP 파일은 지시문, 서술 문 및 순서도를 포함하고, 상기 방법은: 컴퓨팅 장치의 프로세서에 의해, 상기 지시문, 상기 서술문 및 상기 순 서도를 식별하도록 상기 SOP 파일을 구문 분석하는 단계; 상기 프로세서에 의해, 상기 지시문 각각에 대해 하나 씩인, 복수의 로컬 의도 진술을 결정하고 상기 로컬 의도 진술 각각을 잠재성 상태로 설정하는 단계 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련 하여 상기 해당 지시문을 분석하여 결정됨 - ; 상기 프로세서에 의해, 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 상기 해당 지시문과 연관된 상기 서술문을 분석하여 상기 복수의 로컬 의도 진술 각각과 관 련된 개체 및 상기 개체 각각과 관련된 속성을 결정하고 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하 는 단계 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체 의 특성을 정의하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ; 상기 프로세서에 의해, 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하여 조 합 개체 상태 (CES)의 세트를 형성하는 단계 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES 는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ; 상기 프로세서에 의해 상기 순서도를 기반으로 상기 로컬 의도 진술 간의 관계를 결정하는 단계 - 상기 관계는 한 로컬 의도 진 술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지 여부를 나타내고, 상기 관계는 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및 상기 프로세서에 의해 사용자로부터 상기 자연어 형 태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하는 단계 - 상기 에이전트는 인간 에이전트와 기계 에이전트 중 적어도 하나임 - 을 포함한다. 일 구현 예에 따르면, 상기 방법은, 상기 복수의 로컬 의도 진술을 결정하는 단계, 상기 개체 및 상기 속성을 결정하는 단계, 및 상기 관계를 결정하는 단계 각각은: 상기 지시문, 상기 서술문, 상기 순서도의 컨텐츠에서 품사를 식별하는 단계; 상기 컨텐츠의 공동 참조, 특히 대명사를 이들의 선행으로 해결하는 단계; 상기 컨텐츠 의 모호성을 제거하기 위해 상속 관계를 순회하는 단계; 상기 분석에서 모호성의 경우 상기 컨텐츠의 하나 이상 의 부분을 표시하는 단계; 및 상기 하나 이상의 모호성 부분을 명확하게 하기 위해 사용자 입력을 수신하는 단 계를 더 포함한다. 일 구현 예에 따르면, 상기 개체를 결정하는 단계는, 상기 서술문의 명사구를 기반으로 한다. 일 구현 예에 따르면, 상기 SOP 파일을 구문 분석하는 단계는, 분산된 문서 구문 분석 시스템을 사용하고, 상기 분산 문서 구문 분석 시스템은 parse2Run이다. 일 구현 예에 따르면, 상기 parse2Run은 코어 패스, 참조 패스, 관계 패스, 이해 패스, 강화 패스, 준수 패스 중 적어도 하나를 포함한다.일 구현 예에 따르면, 상기 자연어는 하나 이상의 모국어, 하나 이상의 수화, 하나 이상의 기호, 하나 이상의 숫자 또는 이들의 조합을 기반으로 한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 자연어로 변환하여 자연어 기반 컴퓨터 구현 솔루션을 구 축하는 방법에 관한 것으로, 상기 자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하 고, 상기 방법은: 컴퓨팅 장치의 프로세서에 의해, 상기 프로그래밍 코드에 존재하는 기호, 키워드, 연산자 및 함수를 추출하기 위해 상기 프로그래밍 코드를 구문 분석하는 단계; 상기 프로세서에 의해, 상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의 매핑을 기반으로 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을 결정하고, 상기 복수의 로 컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하는 단계 - 각 로컬 의도 진술은 솔루션을 구축하는 단계를 나타내며, 각 개체는 해당 로컬 의도 진술에 표시된 상기 단계에 참여하고, 상기 속성은 각각 의 개체의 특성을 정의하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체를 구별함 - ; 상기 프로 세서에 의해, 각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하여 조합 개체 상태 (CES) 세트를 형성하는 단계 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES 는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ; 상기 프로세서에 의해, 상기 추출된 연산자 및 함수와 상기 데이터베이스에 저장된 상기 자연어 데이터와의 매핑을 기반으로 상 기 로컬 의도 진술 간의 관계를 결정하는 단계 - 상기 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의 도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술 의 종료인지를 나타내고, 상기 관계는 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및 상기 프로세서에 의해 사용자로부터 상기 자연어 형태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하 는 단계 - 상기 에이전트는 적어도 인간 에이전트와 기계 에이전트 중 적어도 하나임 - 를 포함한다. 일 구현 예에 따르면, 상기 관계를 수신하는 단계는 상기 글로벌 의도 진술에 대한 상기 로컬 의도 진술 사이의 복수의 별개의 관계를 수신하는 단계를 포함하고, 각각의 별개의 관계는 상기 솔루션을 구축하는 별개의 경로이 다. 일 구현 예에 따르면, 상기 기계 에이전트는 유선 통신 채널 또는 무선 통신 채널을 통해 상기 컴퓨팅 장치에 통신 가능하게 결합된다. 일 구현 예에 따르면, 상기 글로벌 의도 진술의 로컬 의도 진솔과 관련된 개체는: 다른 컴퓨터 구현 솔루션을 차용하기 위한 상기 다른 컴퓨터 구현 솔루션의 로컬 의도 진술; 또는 다른 컴퓨터 구현 솔루션을 차용하기 위 한 상기 다른 컴퓨터 구현 솔루션의 개체이다. 일 구현 예에 따르면, 상기 프로그래밍 코드는 배치 운영 체제, 시분할 운영 체제, 분산 운영 체제, 네트워크 운영 체제 및 실시간 운영 체제 중 적어도 하나를 위한 것이다. 본 발명은, 일 구현 예에 따르면, 자연어를 기반으로 구축된 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하는 방법에 관한 것으로, 상기 컴퓨터로 구현된 솔루션은 자연어 기반 입력을 사용하여 실행 가능하고, 상기 방법은: 컴퓨팅 장치의 프로세서에 의해, 상기 컴퓨터 구현 솔루션을 구문 분석하는 단계 - 상기 컴퓨터로 구현 된 솔루션은 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체, 상기 개체 각각과 연관 된 속성, 상기 복수의 로컬 의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 속성은 상기 각 개체의 특성을 정의하고 상기 각 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하며, 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진 술의 종료인지를 나타냄 - ; 컴퓨팅 장치의 프로세서에 의해, 복수의 자연어 솔루션 구성 요소를 추출하는 단계 - 상기 자연어 솔루션 구성 요소는 상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연 관된 속성, 상기 복수의 로컬 의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함함 - ; 및 상기 자연어 솔루션 구성 요소와 데이터베이스에 저장된 프로그래밍 언어의 기호, 키워드, 연산자 및 함수 와의 매핑을 기반으로 프로그래밍 언어 코드를 자동 생성하는 단계를 포함한다. 본 발명은 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 상기 컴퓨팅 장치는, 프로세서; 및 상기 프로세서 에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서로 하여금: 사용자로부터 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 수신하고 - 상기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설 정됨 - ; 상기 사용자로부터 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진 술과 관련된 개체와 에이전트의 세부 정보를 수신하고 - 각각의 로컬 의도 진술 및 상기 개체와 에이전트의 상 기 세부 정보는 상기 자연어의 형태로 수신되고 각각 잠재성의 상태로 설정되며, 각 로컬 의도 진술은 상기 솔 루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 나타내는 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 하는 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트 리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 -; 상기 글로벌 의도 진술과 관련된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축 하는 단계의 종료로서 식별하고; 및 상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정 한 것에 응답하여, 상기 프로세서에 의해 상기 사용자로부터 상기 자연어 형태로 상기 로컬 의도 진술 간의 관 계를 수신하도록 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트 에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - 실행 가능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 상기 컴퓨팅 장치는, 사용자로부터 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 수신하는 수단 - 상기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설정됨 - ; 상기 사용자로부터 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 수신하는 수단 - 각각의 로컬 의도 진술 및 상기 개체와 에이전트의 상기 세부 정보는 상기 자연어의 형태로 수신되고 각각 잠재성의 상태로 설정되며, 각 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 나타내는 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 각 로 컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 하는 조합 개체 상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 -; 상기 글로벌 의도 진술 과 관련된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로서 식별하는 수단; 및 상기 글로벌 의도 진술과 관련된 하나 이상 의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 프로세서에 의해 상기 사용자로부터 상기 자연어 형태로 상기 로컬 의도 진술 간의 관계를 수신하는 수단 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로 컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지 여부를 나타 냄 - 을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 상기 컴퓨팅 장치는, 프로세서; 및 상기 프로세서 에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서로 하여금 전술한 방법을 수행하도록 실행 가능한 명 령을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 상기 컴퓨팅 장치는, 프로세서; 및 상기 프로세서 에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해: 상기 자연어의 형태로 글로벌 의도 진술을 입력하고 상기 솔루션을 구축하기 위해 상기 글로벌 의도 진술을 잠재성 상태로 설정하라는 프롬프트를 사용자 에게 제공하고; 상기 사용자에게 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 입력하고 상기 하나 이상의 로컬 의도 진술과 상기 개체 각각을 잠재성 상태로 설정하라는 프롬프트를 제공하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계 를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES 는 잠재성 상태에 있음 - ; 상기 글로벌 의도 진술과 관련된 오직 하나의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로 식별 하고; 및 상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상 기 사용자에게 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 입력하라는 프롬프트를 제공하도록 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또 는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - 실행 가능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 상기 컴퓨팅 장치는: 상기 자연어의 형태로 글로 벌 의도 진술을 입력하고 상기 솔루션을 구축하기 위해 상기 글로벌 의도 진술을 잠재성 상태로 설정하라는 프 롬프트를 사용자에게 제공하는 수단; 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보를 입력하고 상기 하나 이상의 로컬 의도 진술과 상기 개체 각 각을 잠재성 상태로 설정하라는 프롬프트를 상기 사용자에게 제공하는 수단 - 각각의 로컬 의도 진술은 상기 솔 루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ; 상기 글로벌 의도 진술과 관련된 오직 하나의 수신 로 컬 의도 진술을 결정한 것에 대한 응답으로, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로 식별하는 수단; 및 상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술 을 결정한 것에 대한 응답으로, 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 입력하라는 프롬프트를 상기 사용자에게 제공하는 수단 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지를 나타냄 - 을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 상기 컴퓨팅 장치는, 프로세서; 및 상기 프로세서 에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해 전술한 방법을 수행하도록 실행 가능한 명령 을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 상기 컴퓨팅 장치는, 프로세서; 및 상기 프로세서 에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해: 복수의 차별화된 이미지 프레임을 식별하기 위해 비디오의 이미지 프레임을 처리하고 - 각각의 차별화된 이미지 프레임은 그 콘텐츠의 차이에 기초하여 상 기 비디오의 하나 이상의 이전 이미지 프레임과 다른 것으로 식별됨 - ; 상기 비디오의 바로 직전의 이미지 프 레임의 콘텐츠에 관련하여 각 차별화된 이미지 프레임의 콘텐츠의 차이에 각각 기초하는, 복수의 로컬 의도 진 술을 결정하고, 상기 로컬 의도 진술 각각을 잠재적 상태에서 설정하고 - 각각의 로컬 의도 진술은 상기 솔루션 을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 이미지 프레임의 콘 텐츠를 분석함으로써 결정됨 - ; 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 연속된 쌍의 차별 화된 이미지 프레임 사이의 상기 이미지 프레임의 컨텐츠를 분석함으로써 상기 복수의 로컬 의도 진술 각각과 연관된 개체와 상기 개체 각각과 연관된 속성을 결정하고 상기 개체와 속성 각각을 잠재성 상태로 설정하고 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의 하고 상기 각각의 개체를 상기 대응하는 로컬 의도 진술의 다른 개체로부터 구별함 - ; 제 1 차별화된 이미지 프레임과 마지막으로 차별화된 이미지 프레임의 상기 콘텐츠의 변경을 기반으로 상기 컴퓨터 구현 솔루션에 대 한 글로벌 의도 진술을 결정하고 상기 글로벌 의도 진술을 잠재성 상태로 설정하고 - 상기 글로벌 의도 진술은 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 제 1 차별화된 이미지 프레임 및 상기 마지막 차 별화된 이미지 프레임의 상기 콘텐츠를 분석함으로써 결정됨 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ; 사용자로부터 상기 복수의 로컬 의도 진술과 관련된 에이전트의 세부 정보를 자연어 형태로 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하고 - 상기 에이전트는 인간 에 이전트 및 기계 에이전트 중 적어도 하나이고; 및 상기 사용자로부터 상기 자연어의 형태로 상기 로컬 의도 진 술 간의 관계를 수신하도록 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하는 단계의 종료인지를 나타냄 - 실행 가 능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 상기 컴퓨팅 장치는: 복수의 차별화된 이미지 프레임을 식별하기 위해 비디오의 이미지 프레임을 처리하는 수단 - 각각의 차별화된 이미지 프레임은 그 콘텐츠 의 차이에 기초하여 상기 비디오의 하나 이상의 이전 이미지 프레임과 다른 것으로 식별됨 - ; 상기 비디오의 바로 직전의 이미지 프레임의 콘텐츠에 대한 각 차별화된 이미지 프레임의 콘텐츠의 차이에 각각 기초하는, 복 수의 로컬 의도 진술을 결정하고, 상기 로컬 의도 진술 각각을 잠재적 상태에서 설정하는 수단 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 이미지 프레임의 콘텐츠를 분석함으로써 결정됨 - ; 상기 데이터베이스에 저장된 상기 자연어 데이터와 관 련하여 연속된 쌍의 차별화된 이미지 프레임 사이의 상기 이미지 프레임의 컨텐츠를 분석함으로써 상기 복수의 로컬 의도 진술 각각과 연관된 개체와 상기 개체 각각과 연관된 속성을 결정하고 상기 개체와 속성 각각을 잠재 성 상태로 설정하는 수단 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 대응하는 로컬 의도 진술의 다른 개체로부터 구별함 - ; 제 1 차별화된 이미지 프레임과 마지막으로 차별화된 이미지 프레임의 상기 콘텐츠의 변경을 기반으로 상기 컴퓨터 구현 솔루션에 대한 글로벌 의도 진술을 결정하고 상기 글로벌 의도 진술을 잠재성 상태로 설정하는 수 단 - 상기 글로벌 의도 진술은 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 제 1 차별화된 이 미지 프레임 및 상기 마지막 차별화된 이미지 프레임의 상기 콘텐츠를 분석함으로써 결정됨 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ; 사용자로부터 상기 복수의 로컬 의도 진 술과 관련된 에이전트의 세부 정보를 자연어 형태로 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하는 수단 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나이고; 및 상기 사용자로부터 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 수신하는 수단 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축 하는 단계의 종료인지를 나타냄 - 을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 컴퓨팅 장치에 관한 것으로, 상기 컴퓨팅 장치는, 프로세서; 및 상기 프로세서 에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해 전술한 방법을 수행하도록 실행 가능한 명령 을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 표준 운영 절차 (SOP) 파일과 사용자가 이 해할 수 있는 자연어를 사용하는 컴퓨터 구현 솔루션의 구축을 위한 컴퓨팅 장치에 관한 것으로, 상기 SOP 파일 은 지시문, 서술문 및 순서도를 포함하고, 상기 컴퓨팅 장치는: 프로세서; 및 상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해: 상기 지시문, 상기 서술문 및 상기 순서도를 식별하도록 상기 SOP 파일을 구문 분석하고; 상기 지시문 각각에 대해 하나씩인, 복수의 로컬 의도 진술을 결정하고 상기 로컬 의도 진술 각각을 잠재성 상태로 설정하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나 타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 해당 규범 진술을 분석하여 결정됨 - ; 상기 데 이터베이스에 저장된 상기 자연어 데이터와 관련하여 상기 해당 지시문과 연관된 상기 서술문을 분석하여 상기 복수의 로컬 의도 진술 각각과 관련된 개체 및 상기 개체 각각과 관련된 속성을 결정하고 상기 개체 및 상기 속 성 각각을 잠재성 상태로 설정하고 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 상기 단계에 참여하고, 상 기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하 여 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES 는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ; 상기 순서도를 기 반으로 상기 로컬 의도 진술 간의 관계를 결정하고 - 상기 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지 여부를 나타내고, 상기 관계는 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도 를 분석함으로써 결정됨 - ; 및 사용자로부터 상기 자연어 형태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하도록 - 상기 에이전 트는 인간 에이전트와 기계 에이전트 중 적어도 하나임 - 실행 가능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 표준 운영 절차 (SOP) 파일과 사용자가 이 해할 수 있는 자연어를 사용하는 컴퓨터 구현 솔루션의 구축을 위한 컴퓨팅 장치에 관한 것으로, 상기 SOP 파일 은 지시문, 서술문 및 순서도를 포함하고, 상기 컴퓨팅 장치는: 상기 지시문, 상기 서술문 및 상기 순서도를 식 별하도록 상기 SOP 파일을 구문 분석하는 수단; 상기 지시문 각각에 대해 하나씩인, 복수의 로컬 의도 진술을결정하고 상기 로컬 의도 진술 각각을 잠재성 상태로 설정하는 수단 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 해당 규범 진술을 분석 하여 결정됨 - ; 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 상기 해당 지시문과 연관된 상기 서술문을 분석하여 상기 복수의 로컬 의도 진술 각각과 관련된 개체 및 상기 개체 각각과 관련된 속성을 결정하 고 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하는 수단 - 각 개체는 상기 해당 로컬 의도 진술에 표시 된 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각 개체를 상기 대응하는 로 컬 의도 진술의 다른 개체와 구별함 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하여 조합 개체 상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상 태에 있음 - ; 상기 순서도를 기반으로 상기 로컬 의도 진술 간의 관계를 결정하는 수단 - 상기 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지 여부를 나타내고, 상기 관계는 데이터베이스에 저장된 상 기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및 사용자로부터 상기 자연어 형태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠 재성 상태로 설정하는 수단 - 상기 에이전트는 인간 에이전트와 기계 에이전트 중 적어도 하나임 - 을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 표준 운영 절차 (SOP) 파일과 사용자가 이 해할 수 있는 자연어를 사용하는 컴퓨터 구현 솔루션의 구축을 위한 컴퓨팅 장치에 관한 것으로, 상기 SOP 파일 은 지시문, 서술문 및 순서도를 포함하고, 상기 컴퓨팅 장치는: 프로세서; 및 상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해 전술한 방법을 수행하도록 실행 가능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 자연어로 변환하여 자연어 기반 컴퓨터 구현 솔루션을 구 축하는 컴퓨팅 장치에 관한 것으로, 상기 자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하고, 상기 컴퓨팅 장치는: 프로세서; 및 상기 프로세서에 연결된 메모리를 포함하고, 상기 방법은 상기 프 로세서에 의해: 상기 프로그래밍 코드에 있는 기호, 키워드, 연산자 및 함수를 추출하도록 상기 프로그래밍 코 드를 구문 분석하고; 상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의 매핑에 기초하여 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을 결정하고 상기 복수의 로컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 대응하는 로컬 의도 진술 에 의해 표시되는 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ; 각 로컬 의도 진술서에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기반한 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 -; 상기 추출된 연산자 및 함수와 상기 데이터베이스에 상기 저장된 자연어 데이 터와의 매핑을 기반으로 상기 로컬 의도 진술 간의 관계를 결정하고 - 상기 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위 한 글로벌 의도 진술의 종료인지를 나타내고, 상기 관계는 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및 사용자로부터 상기 복수의 로컬 의도 진술 각각과 연관된 에이 전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하도록 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - 실행 가능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 자연어로 변환하여 자연어 기반 컴퓨터 구현 솔루션을 구 축하는 컴퓨팅 장치에 관한 것으로, 상기 자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하고, 상기 컴퓨팅 장치는: 상기 프로그래밍 코드를 구문 분석하여 상기 프로그래밍 코드에 있는 기호, 키 워드, 연산자 및 함수를 추출하는 수단; 상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의 매핑에 기초하여 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을 결정하고 상기 복수의 로컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠 재성 상태로 설정하는 수단 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체 는 대응하는 로컬 의도 진술에 의해 표시되는 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ; 각 로컬 의도 진술서에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기반한 조합 개체 상태 (CES)의 세트를 형성하는 수단 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 -; 상기 추출된 연산자 및 함수와 상기 데이터 베이스에 상기 저장된 자연어 데이터와의 매핑을 기반으로 상기 로컬 의도 진술 간의 관계를 결정하는 수단 - 상기 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또 는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고, 상기 관계는 상기 데이 터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및 사용자로부터 상기 복수의 로컬 의도 진술 각각과 연관된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠 재성 상태로 설정하는 수단 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - 을 포함한 다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 자연어로 변환하여 자연어 기반 컴퓨터 구현 솔루션을 구 축하는 컴퓨팅 장치에 관한 것으로, 상기 자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하고, 상기 컴퓨팅 장치는: 프로세서; 및 상기 프로세서에 연결된 메모리를 포함하고, 상기 방법은 상기 프 로세서에 의해 전술한 방법을 수행하도록 실행 가능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 자연어 기반의 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하기 위한 컴퓨 팅 장치에 관한 것으로, 상기 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 컴퓨팅 장치는: 프로세서; 및 상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 상기 프로세서에 의해: 상기 컴 퓨터 구현 솔루션을 구문 분석하고- 상기 컴퓨터 구현 솔루션은 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 관련된 개체, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구축하는 단계를 나타내며, 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특 성을 정의하고 상기 각각의 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하고, 상기 관계는 하나의 로 컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구 현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타냄 - ; 컴퓨팅 장치의 프로세서에 의해 복수의 자연어 솔루션 구성 요소를 추출하고 - 상기 자연어 솔루션 구성 요소는 상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함함 - ; 상기 자연어 솔루션 구성 요소와 데이터베이스에 저장된 프로그래 밍 언어의 기호, 키워드, 연산자 및 함수와의 매핑을 기반으로 프로그래밍 언어 코드를 자동 생성하도록 실행 가능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 자연어 기반의 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하기 위한 컴퓨 팅 장치에 관한 것으로, 상기 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 컴퓨팅 장치는: 상기 컴퓨터 구현 솔루션을 구문 분석하는 수단 - 상기 컴퓨터 구현 솔루션은 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 관련된 개체, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구 축하는 단계를 나타내며, 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각 각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하고, 상기 관 계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타냄 - ; 컴퓨팅 장치의 프로세서 에 의해 복수의 자연어 솔루션 구성 요소를 추출하는 수단 - 상기 자연어 솔루션 구성 요소는 상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 의도 진술 간의 관계, 조 합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함함 - ; 상기 자연어 솔루션 구성 요소와 데이터베이스에 저 장된 프로그래밍 언어의 기호, 키워드, 연산자 및 함수와의 매핑을 기반으로 프로그래밍 언어 코드를 자동 생성 하는 수단을 포함한다. 본 발명은, 일 구현 예에 따르면, 자연어 기반의 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하기 위한 컴퓨 팅 장치에 관한 것으로, 상기 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 컴퓨팅 장치는: 프로세서; 및 상기 프로세서에 결합된 메모리를 포함하고, 상기 방법은 전술한 방법을 실행하도록 실행 가능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하는, 컴 퓨터 구현 솔루션을 구축하기 위한 명령이 저장된 비 일시적 컴퓨터 판독 가능 매체에 관한 것으로, 프로세서에 의해 실행될 때 상기 프로세서로 하여금: 사용자로부터 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 수신 하고 - 상기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설정됨 - ; 상기 사용자로부터상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트 의 세부 정보를 수신하고 - 각각의 로컬 의도 진술 및 상기 개체와 에이전트의 상기 세부 정보는 상기 자연어의 형태로 수신되고 각각 잠재성의 상태로 설정되며, 각 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나 타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 나타내는 상기 단계에 참여하고, 상기 에이전트는 인 간 에이전트 및 기계 에이전트 중 적어도 하나임 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 하는 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 -; 상기 글로벌 의도 진술과 관련된 단 하나의 수신 로컬 의도 진술을 결정한 것 에 응답하여, 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로서 식별 하고; 및 상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 프 로세서에 의해 상기 사용자로부터 상기 자연어 형태로 상기 로컬 의도 진술 간의 관계를 수신하도록 - 상기 관 계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지 여부를 나타냄 - 하는 기계 실행 가능 코드를 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하는, 컴 퓨터 구현 솔루션을 구축하기 위한 명령이 저장된 비 일시적 컴퓨터 판독 가능 매체에 관한 것으로, 프로세서에 의해 실행될 때 상기 프로세서로 하여금: 상기 자연어의 형태로 글로벌 의도 진술을 입력하고 상기 솔루션을 구 축하기 위해 상기 글로벌 의도 진술을 잠재성 상태로 설정하라는 프롬프트를 사용자에게 제공하고; 상기 글로벌 의도 진술과 관련된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 관련된 개체와 에이전트의 세부 정보 를 입력하고 상기 하나 이상의 로컬 의도 진술과 상기 개체 각각을 잠재성 상태로 설정하라는 프롬프트를 상기 사용자에게 제공하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상 기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 에이전트는 인간 에이전트 및 기계 에 이전트 중 적어도 하나임 - ; 각 로컬 의도 진술에 대해, 상기 각 로컬 의도 진술의 상기 개체의 모든 가능한 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ; 상기 글로벌 의도 진술과 관련된 오직 하나의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상기 수신 된 로컬 의도 진술의 상기 트리거 CES를 상기 솔루션을 구축하는 단계의 종료로 식별하고; 및 상기 글로벌 의도 진술과 관련된 하나 이상의 수신 로컬 의도 진술을 결정한 것에 대한 응답으로, 상기 자연어의 형태로 상기 로 컬 의도 진술 간의 관계를 입력하라는 프롬프트를 상기 사용자에게 제공하도록 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단 계의 종료인지를 나타냄 - 실행 가능한 명령을 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 비디오 및 자연어를 사 용하는, 컴퓨터 구현 솔루션을 구축하기 위한 명령이 저장된 비 일시적 컴퓨터 판독 가능 매체에 관한 것으로, 프로세서에 의해 실행될 때 상기 프로세서로 하여금: 복수의 차별화된 이미지 프레임을 식별하기 위해 비디오의 이미지 프레임을 처리하고 - 각각의 차별화된 이미지 프레임은 그 콘텐츠의 차이에 기초하여 상기 비디오의 하 나 이상의 이전 이미지 프레임과 다른 것으로 식별됨 - ; 상기 비디오의 바로 직전의 이미지 프레임의 콘텐츠에 대한 각 차별화된 이미지 프레임의 콘텐츠의 차이에 각각 기초하는, 복수의 로컬 의도 진술을 결정하고, 상기 로컬 의도 진술 각각을 잠재적 상태에서 설정하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단 계를 나타내며 데이터베이스에 저장된 자연어 데이터와 관련하여 상기 이미지 프레임의 콘텐츠를 분석함으로써 결정됨 - ; 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 연속된 쌍의 차별화된 이미지 프레임 사이의 상기 이미지 프레임의 컨텐츠를 분석함으로써 상기 복수의 로컬 의도 진술 각각과 연관된 개체와 상기 개체 각각과 연관된 속성을 결정하고 상기 개체와 속성 각각을 잠재성 상태로 설정하고 - 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체 를 상기 대응하는 로컬 의도 진술의 다른 개체로부터 구별함 - ; 제 1 차별화된 이미지 프레임과 마지막으로 차 별화된 이미지 프레임의 상기 콘텐츠의 변경을 기반으로 상기 컴퓨터 구현 솔루션에 대한 글로벌 의도 진술을 결정하고 상기 글로벌 의도 진술을 잠재성 상태로 설정하고 - 상기 글로벌 의도 진술은 상기 데이터베이스에 저 장된 상기 자연어 데이터에 대해 상기 제 1 차별화된 이미지 프레임 및 상기 마지막 차별화된 프레임의 상기 콘 텐츠를 분석함으로써 결정됨 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재성 상태에 있음 - ; 사용자로부터 상기 복수의 로컬 의도 진술과 관련된 에이전트의 세부 정보를 자연어 형태로 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하고 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적 어도 하나이고; 및 상기 사용자로부터 상기 자연어의 형태로 상기 로컬 의도 진술 간의 관계를 수신하도록 - 상 기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하는 단계의 종료인지를 나타냄 - 하는 기계 실행 가능 코드를 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하는, 컴 퓨터 구현 솔루션을 구축하기 위한 명령이 저장된 비 일시적 컴퓨터 판독 가능 매체에 관한 것으로, 상기 SOP 파일은 지시문, 서술문 및 순서도를 포함하고, 상기 명령은 프로세서에 의해 실행될 때 상기 프로세서로 하여금: 상기 지시문, 상기 서술문 및 상기 순서도를 식별하도록 상기 SOP 파일을 구문 분석하고; 상기 지시문 각각에 대해 하나씩인, 복수의 로컬 의도 진술을 결정하고 상기 로컬 의도 진술 각각을 잠재성 상태로 설정하고 - 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며 데이터베이스에 저장된 자연어 데이 터와 관련하여 상기 해당 규범 진술을 분석하여 결정됨 - ; 상기 데이터베이스에 저장된 상기 자연어 데이터와 관련하여 상기 해당 지시문과 연관된 상기 서술문을 분석하여 상기 복수의 로컬 의도 진술 각각과 관련된 개체 및 상기 개체 각각과 관련된 속성을 결정하고 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하고 - 각 개 체는 상기 해당 로컬 의도 진술에 표시된 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의 하고 상기 각 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ; 각 로컬 의도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합에 기초하여 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 모든 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ; 상기 순서도를 기반으로 상기 로컬 의도 진술 간의 관계를 결정 하고 - 상기 관계는 한 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치 는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고, 상기 관계는 데 이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및 사용자로부터 상기 자연어 형태로, 상기 복수의 로컬 의도 진술 각각과 관련된 에이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하도록 - 상기 에이전트는 인간 에이전트와 기계 에이전트 중 적어도 하나 임 - 하는 기계 실행 가능 코드를 포함한다. 본 발명은, 일 구현 예에 따르면, 자연어 기반의 컴퓨터 구현 솔루션을 구축하기 위해 프로그래밍 코드를 자연 어로 변환하기 위한 명령이 저장된 비 일시적 컴퓨터 판독 가능 매체에 관한 것으로, 상기 자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 명령은 프로세서에 의해 실행될 때, 상기 프 로세서가: 상기 프로그래밍 코드에 있는 기호, 키워드, 연산자 및 함수를 추출하도록 상기 프로그래밍 코드를 구문 분석하고; 상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의 매핑에 기초하여 복수의 로컬 의도 진술, 상기 복수의 로컬 의도 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을 결정하고 상기 복수의 로컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠재성 상태로 설정하고 - 각각 의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 대응하는 로컬 의도 진술에 의 해 표시되는 상기 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 각각의 개체를 상기 대응하는 로컬 의도 진술의 다른 개체와 구별함 - ; 각 로컬 의도 진술서에 대해, 상기 각각의 로컬 의도 진술 의 상기 개체의 가능한 모든 조합에 기반한 조합 개체 상태 (CES)의 세트를 형성하고 - 상기 각각의 로컬 의도 진술의 상기 개체 모두에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES 는 잠재성 상태에 있음 -; 상기 추출된 연산자 및 함수와 상기 데이터베이스에 상기 저장된 자연어 데이터와의 매핑을 기반으로 상기 로컬 의도 진술 간의 관계를 결정하고 - 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위 한 글로벌 의도 진술의 종료인지를 나타내고, 상기 관계는 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및 사용자로부터 상기 복수의 로컬 의도 진술 각각과 연관된 에이 전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재성 상태로 설정하도록 - 상기 에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나임 - 하는 기계 실행 가능 코드를 포함한다. 본 발명은, 일 구현 예에 따르면, 자연어를 기반으로 구축된 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하기 위한 명령어가 저장된 비 일시적 컴퓨터 판독 가능 매체에 관한 것으로, 상기 컴퓨터 구현 솔루션은 자연어 기 반 입력을 사용하여 실행 가능하며, 상기 명령은 프로세서에 의해 실행될 때 상기 프로세서로 하여금: 상기 컴 퓨터 구현 솔루션을 구문 분석하고 - 상기 컴퓨터 구현 솔루션은 복수의 로컬 의도 진술, 상기 복수의 로컬 의 도 진술 각각과 관련된 개체, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 진술 간의 관계, 조합 개체 상 태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구축하는 단계를 나타 내며, 각 개체는 상기 해당 로컬 의도 진술에 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을정의하고 상기 각각의 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하고, 상기 관계는 하나의 로컬 의 도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔 루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타냄 - ; 컴퓨팅 장치의 프로세서에 의해 복수의 자연 어 솔루션 구성 요소를 추출하고 - 상기 자연어 솔루션 구성 요소는 상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 의도 진술 간의 관계, 조합 개체 상태 (CES), 하 나 이상의 트리거 CES를 포함함 - ; 상기 자연어 솔루션 구성 요소와 데이터베이스에 저장된 프로그래밍 언어의 기호, 키워드, 연산자 및 함수와의 매핑을 기반으로 프로그래밍 언어 코드를 자동 생성하도록 하는 기계 실행 가능 코드를 포함한다. 본 발명은, 일 구현 예에 따르면, 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨 터 구현 솔루션을 구축하기 위한 시스템에 관한 것으로, 상기 시스템은 프로세서; 및 상기 프로세서에 연결된 글로벌 의도 진술 모듈, 로컬 의도 진술 모듈, CES 모듈 및 관계 모듈 - 상기 글로벌 의도 진술 모듈, 상기 로 컬 의도 진술 모듈, 상기 CES 모듈 및 상기 관계 모듈은 서로 작동 가능하게 연결됨 - 을 포함하고, 상기 글로 벌 의도 진술 모듈은 상기 솔루션을 구축하기 위한 글로벌 의도 진술을 사용자로부터 수신하도록 구성되고 - 상 기 글로벌 의도 진술은 상기 자연어의 형태로 수신되고 잠재성 상태로 설정됨 - ; 상기 로컬 의도 진술 모듈은 상기 사용자로부터 상기 글로벌 의도 진술과 연관된 하나 이상의 로컬 의도 진술 및 각 로컬 의도 진술과 연관 된 개체의 세부 정보와 에이전트를 수신하도록 구성되고 - 각 로컬 의도 진술과 상기 개체 및 에이전트의 상기 세부 정보는 자연어의 형태로 수신되고 각각 잠재성 상태로 설정되고, 각 로컬 의도 진술은 상기 솔루션을 구축 하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 단계에 참여하고, 상기 에 이전트는 인간 에이전트, 기계 에이전트 및 컴퓨터 기능 중 적어도 하나임 - ; 상기 CES 모듈은 각각의 로컬 의 도 진술에 대해, 상기 각각의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 하여 조합 개체 상태 (CES)의 세트를 형성하도록 구성되고 - 상기 각각의 로컬 의도 진술의 모든 상기 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있고, 상기 글로벌 의도 진술과 연관된 단 하나의 수신 로컬 의도 진술을 결정한 것에 응답하여, 상기 솔루션을 구축하는 단계의 종료로서 상기 수신된 로컬 의도 진술의 상기 트리거 CES를 식별함 - ; 및 상기 관계 모듈은 상기 자연어의 형태로 상기 사용 자로부터 상기 로컬 의도 진술 간의 관계를 수신하도록 구성되고, 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 솔루션을 구축하는 단계의 종료인지 를 나타낸다. 본 발명은, 일 구현 예에 따르면, 자연어 기반 컴퓨터 구현 솔루션을 구축하기 위해 프로그래밍 코드를 자연어 로 변환하기 위한 시스템에 관한 것으로, 상기 자연어 기반 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 시스템은: 프로세서; 및 상기 프로세서에 연결된, 구문 분석 모듈, 추출기 모듈, 해석기 모듈, 매핑 모듈, 글로벌 의도 모듈, 로컬 의도 모듈, CES 모듈 및 관계 모듈을 포함하고, 상기 구문 분석 모듈, 상기 추출기 모듈, 상기 해석기 모듈, 상기 매핑 모듈, 상기 글로벌 의도 모듈, 상기 로컬 의도 모듈, 상 기 CES 모듈 및 상기 관계 모듈이 서로 작동 가능하게 연결되고, 상기 구문 분석 모듈은 상기 프로그래밍 코드 에 존재하는 기호, 키워드, 연산자 및 함수를 추출하기 위해 프로그래밍 코드를 구문 분석하도록 구성되고; 상 기 추출기 모듈, 상기 해석기 모듈, 상기 매핑 모듈, 상기 글로벌 의도 진술 모듈 및/또는 상기 로컬 의도 진술 모듈은 상기 추출된 기호, 키워드, 연산자 및 함수와 데이터베이스에 저장된 자연어 데이터와의 매핑에 기초하 여 복수의 로컬 의도 진술, 상기 복수의 로컬 진술 각각과 연관된 개체 및 상기 개체 각각과 연관된 속성을 결 정하고 상기 복수의 로컬 의도 진술, 상기 개체 및 상기 속성 각각을 잠재적 상태로 설정하도록 구성되고 - 각 각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나타내며, 각 개체는 상기 대응하는 로컬 의도 진 술에 의해 표시된 단계에 참여하고, 상기 속성은 상기 각각의 개체의 특성을 정의하고 상기 대응하는 로컬 의도 진술의 다른 개체로부터 상기 각각의 개체를 구별함 - ; 상기 CES 모듈은 각 로컬 의도 상태에 대해, 상기 각각 의 로컬 의도 진술의 상기 개체의 가능한 모든 조합을 기반으로 조합 개체 상태 (CES)의 세트를 형성하도록 구 성되고 - 상기 각각의 로컬 의도 진술의 모든 상기 개체에 기초하여 형성된 CES는 트리거 조합 개체 상태 (트리 거 CES)이고, 상기 세트의 각 CES는 잠재적 상태에 있음 - ; 상기 관계 모듈은 상기 추출된 연산자 및 함수와 상기 데이터베이스에 저장된 상기 자연어 데이터와의 매핑을 기반으로 상기 로컬 의도 진술 간의 관계를 결정하 도록 구성되며, 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES의 세트에 영향을 미치는지 또는 상기 컴퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고, 상 기 관계는 상기 데이터베이스에 저장된 상기 자연어 데이터에 대해 상기 순서도를 분석함으로써 결정됨 - ; 및 상기 로컬 의도 진술 모듈은 상기 자연어의 형태로 사용자로부터 상기 복수의 로컬 의도 진술 각각과 연관된 에 이전트의 세부 정보를 수신하고 상기 에이전트의 상기 세부 정보를 잠재적 상태로 설정하도록 구성되고, 상기에이전트는 인간 에이전트 및 기계 에이전트 중 적어도 하나이다. 본 발명은, 일 구현 예에 따르면, 자연어를 기반으로 구축된 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환기 위한 시스템에 관한 것으로, 상기 컴퓨터 구현 솔루션은 자연어 기반 입력을 사용하여 실행 가능하며, 상기 시 스템은: 프로세서; 및 상기 프로세서에 연결된 솔루션 구문 분석 모듈, 솔루션 추출기 모듈, 자동 생성기 모듈 및 매핑 모듈을 포함하고, 상기 솔루션 구문 분석 모듈, 상기 솔루션 추출기 모듈, 상기 자동 생성기 모듈 및 상기 매핑 모듈은 서로 작동 가능하게 연결되고, 상기 솔루션 구문 분석 모듈은 상기 컴퓨터 구현 솔루션을 구 문 분석하도록 구성되고, 상기 컴퓨터 구현 솔루션은 복수의 로컬 의도 진술, 사기 복수의 로컬 의도 진술 각각 과 연관된 개체, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 의도 진술 간의 관계, 조합 개체 상태 (CES), 하나 이상의 트리거 CES를 포함하고, 각각의 로컬 의도 진술은 상기 솔루션을 구축하기 위한 단계를 나 타내며, 각 개체는 상기 대응하는 로컬 의도 진술에 의해 표시된 상기 단계에 참여하고, 상기 속성은 상기 각 개체의 특성을 정의하고 상기 각각의 개체를 상기 해당 로컬 의도 진술의 다른 개체와 구별하며, 상기 관계는 하나의 로컬 의도 진술의 트리거 CES가 다른 로컬 의도 진술의 상기 CES 세트에 영향을 미치는지 또는 상기 컴 퓨터 구현 솔루션을 구축하기 위한 글로벌 의도 진술의 종료인지를 나타내고; 상기 솔루션 추출기 모듈은 복수 의 자연어 솔루션 구성 요소를 추출하도록 구성되며, 상기 자연어 솔루션 구성 요소는 상기 글로벌 의도 진술, 상기 복수의 로컬 의도 진술, 상기 개체 각각과 연관된 속성, 상기 복수의 로컬 의도 진술 간의 관계, 조합 개 체 상태 (CES), 하나 이상의 트리거를 포함하고; 상기 자동 생성기 모듈은 상기 매핑 모듈을 기반으로 프로그래 밍 언어 코드를 자동 생성하도록 구성되고, 상기 매핑 모듈은 상기 자연어 솔루션 구성 요소와 데이터베이스에 저장된 프로그래밍 언어의 기호, 키워드, 연산자 및 함수와의 매핑으로 구성된다."}
{"patent_id": "10-2021-7021130", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시의 특징, 양태 및 장점은 첨부 도면을 참조하여 다음의 상세한 설명을 읽을 때 더 잘 이해될 것이다: 도 1은 상태의 잠재적 및 현실의 예이다. 도 2는 별개의 어떤 것이나 개체가 되는 예를 나타낸다. 도 3은 펜과 종이가 별개이면서 다른 개체인 차별화된 개체의 예이다. 도 4는 두 개의 펜이 별개이지만 동일한 개체인 차별화되지 않은 개체의 예이다. 도 5는 솔루션이 사용자에 의해 구축되는, 잠재적 개체 상태의 예이다. 도 6은 솔루션 생태계의 컨텍스트에서 자격을 갖춘 개체의 예이다. 도 7은 사건에 도달한 경우, 실제 개체 상태의 예이다. 도 8은 최고 일반화 레벨에서 전능적 개체의 예이다. 도 9는 그 속성을 함께 드래그한 독립적 개체의 예이다. 도 10은 암묵적 개체의 예이다. 도 11은 솔루션 설계자가 잠재적 또는 현실이라는 이진 상태에만 있다고 간주하는 고정 개체의 예이다. 도 12는 개체의 생성 및 삭제의 예이다. 도 13은 개체의 수정의 예이다. 도 14는 그 존재를 위해 어떤 다른 개체에 대한 속성의 종속성을 나타낸다. 도 15는 개체를 참조하여 항상 존재하는 필수 속성의 예이다. 도 16은 솔루션 환경에 기초한 속성의 표준화의 예이다. 도 17은 개체가 솔루션 환경 내에 배치되는 상황을 기반으로 사용하기 위해 선택되는 일반적인 속성의 예이다. 도 18은 속성 레벨의 예이다. 도 19는 자연에 물리적으로 존재하는 실제 개체의 예이다. 도 20은 다른 실제 개체 또는 다른 표현 개체를 나타내는 개체의 예이다. 도 21은 주어진 신경 상태의 형태로 자신의 뇌에서 자연적으로 인간 에이전트에 의해 생성되는 개체의 예이다. 도 22는 정보 개체의 예이다.도 23은 진리 값에 대한 이해의 예이다. 도 24는 물리적 세계에 물리적으로 존재하는 모든 개체의 예이다. 도 25는 자연어 측면에서 로컬 의도 진술 및 글로벌 의도 진술의 예이다. 도 26은 변경 유닛의 크기의 예이다. 도 27은 개체의 이진 상태의 예이다. 도 28은 가변성의 예이다. 도 29는 상태가 항상 동일하게 유지되는 개체의 예이다. 도 30은 입력 및 출력의 예이다. 도 31은 자연어 및 자연 솔루션 언어가 작동하는 방식의 예이다. 도 32는 의도를 표현할 뿐 이들을 현실로 변환하는 능력이 부족한 정적 의도 진술의 예이다. 도 33은 개체를 유발하는 기본 변환인 동적 의도 진술의 예이다. 도 34는 차별화 원리의 예이다. 도 35는 유리한 지점의 예이다. 도 36은 차별화 트리를 위 또는 아래로 이동하는 컨텍스트에서 방향성의 예이다. 도 37은 비 트리거 및 트리거 조합 개체 상태 (CES)의 예이다. 도 38은 많은 가능성 사이에서 만들어지는 선택에 대한 제한인, 제약의 예이다. 도 39는 시스템에 배치되는 일련의 제약인 규칙의 예이다. 도 40은 규칙과 동일하지만 정보 시스템의 컨텍스트에서 종종 사용되는 알고리즘의 예이다. 도 41은 인간 에이전트의 예이다. 도 42는 가치 창출자와 소비자의 예이다. 도 43은 에이전트에 대한 개체 소유권의 예이다. 도 44는 마인드 기능, 신체 기능 및 정보 기능의 예이다. 도 45는 인간 에이전트의 정보 권리의 예이다. 도 46은 인간 에이전트의 결정권의 예이다. 도 47은 기계 에이전트의 예이다. 도 48은 변환에 영향을 미칠 수 있는 제 3 종류의 에이전트인 대자연의 예이다. 도 49는 판정 시스템의 예이다. 도 50은 측정 프레임워크의 예이다. 도 51은 에이전트에 속하는 개체의 예이다. 도 52는 자연어와 자연 솔루션 언어 (NSL) 사이의 공통성의 예이다. 도 53은 부품의 재사용성의 일례이다. 도 54는 리엔지니어링의 예이다. 도 55는 NSL 라이브러리의 예이다. 도 56은 공유 개체의 예이다. 도 57은 이해 관계자 참여 센터 (SEC)의 예이다. 도 58은 코드와 자연어 간의 차이의 예이다.도 59는 의미와 가치 간의 차이의 예이다. 도 60은 경과 시간의 예이다. 도 61은 값의 정량화의 예이다. 도 62는 가치의 상대성 이론의 예이다. 도 63은 로직의 단락의 예이다. 도 64는 인공 신경망의 예이다. 도 65는 API와 프로그램 간의 차이의 예이다. 도 66은 IT에서 추상화 수준에 대한 이해의 예이다. 도 67은 솔루션의 전체 수명주기의 예이다. 도 68은 NSL이 언어 애그노스틱한 예이다. 도 69는 NSL 기술 프레임워크의 예이다. 도 70은 분산 임무 통제 센터의 개념의 예이다. 도 71은 동적 임무 통제 센터의 예이다. 도 72는 NSL이 통신 매체에 대해 애그노스틱한 예이다. 도 73은 DNA가 정보로 변환된 예이다. 도 74는 텍스트 기반 사용자 인터페이스 (TBUI)의 예이다. 도 75는 NSL 기술 번역 프레임워크 (TTF) 및 NSL 기술 재번역 프레임워크 (TRF)의 예이다. 도 76은 질의 기반 솔루션 개발 (QBSD)의 예이다. 도 77은 NSL의 이니셔티브와 같은 자연 솔루션 언어의 예이다. 도 78은 NSL의 자동 동사 할당(AVA)의 예이다. 도 79는 실습 기반 솔루션 개발 (PBSD)의 예이다. 도 80은 NSL에서 서브스트레이트 독립성의 예이다. 도 81은 솔루션의 정량화의 예이다. 도 82는 중복 식별을 통한 로직 압축의 예이다. 도 83은 NSL 원칙을 엔지니어링 설계에 적용하는 예이다. 도 84는 프로세싱과 검색 기반 접근법의 차이의 예이다. 도 85는 컨테이너의 예이다. 도 86은 NSL 포맷으로 변환되는 문서의 예이다. 도 87은 감지 기반 사용자 인터페이스의 예이다. 도 88은 순서도 로직 변환의 예이다. 도 89는 자원 최적화 및 유휴 시간 식별 프레임워크의 예이다. 도 90은 메타 솔루션 로직 개체 및 트랜잭션 솔루션 로직 개체의 예이다. 도 91은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하여 컴퓨터 구현 솔루션을 구축하 는 방법을 나타내는 순서도를 나타낸다. 도 92는 자연어 기반 컴퓨터 구현 솔루션을 구축하기 위해 프로그래밍 코드를 자연어로 변환하는 방법을 나타내 는 순서도를 나타낸다.도 93은 자연어를 기반으로 구축된 컴퓨터 구현 솔루션을 프로그래밍 코드로 변환하는 방법을 나타내는 순서도 를 나타낸다. 도 94는 NSL을 위한 일반화된 컴퓨터 네트워크 배열을 나타낸다. 도 95는 자바 프로그램 및 대응하는 NSL 솔루션의 표현의 예를 보여주는 도면이다. 도 96은 기술 번역 프레임워크를 사용하여 자바 프로그램을 NSL 솔루션으로 번역하여 표현한 예를 보여주는 도 면이다. 도 97a는 NSL 등가물에 대한 Java 프로그램의 일대일 매핑을 통해 속성을 갖는 개체 생성의 표현의 예를 보여주 는 도면이다. 도 97b는 Java 프로그램과 NSL 등가물의 일대일 매핑을 통한 NSL의 기능 표현의 예를 보여주는 도면이다. 도 98a는 솔루션이 구성될 때 정적 상태의 단락 표현의 예를 보여주는 도면이다. 도 98b는 \"고객 정보가 캡처될 때 사건에 도달\"로서 정적에서 동적으로 변하는 문장의 표현의 예를 나타내는 도 면이다. 도 98c는 정보가 채워질 때 동적 상태의 단락 표현의 예를 도시하는 도이다. 도 99a는 자바 프로그램의 입력 및 출력 표현의 예를 보여주는 도면이다. 도 99b는 NSL 솔루션의 입력 및 출력의 표현의 예를 보여주는 도면이다. 도 100a는 데이터베이스 관리의 표현의 예를 보여주는 도면이다. 도 100b는 사용자 인터페이스를 관리하는 표현의 예를 보여주는 도면이다. 도 100c는 개체를 에이전트에 연결하는 표현의 예를 보여주는 도면이다. 도 101은 NSL 및 Java에서 호텔 예약 시스템 솔루션을 구축하는 데 필요한 시간, 노력 및 비용을 설명하는 운영 메트릭 표현의 예를 보여주는 도면이다. 도 102a는 키워드 \"Char\"가 Java에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 도 102b는 키워드 \"String\"이 Java에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주 는 도면이다. 도 102c는 키워드 \"Double\"이 Java에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주 는 도면이다. 도 102d는 키워드 \"For\"가 Java에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 도 102e는 키워드 \"While\"이 Java에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 도 102f는 키워드 \"If\"가 Java에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도 면이다. 도 102g는 키워드 \"Break\"가 Java에서 사용되는 방식 및 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이 다. 도 103은 프로세스를 정보로 변환하는 표현의 예를 나타내는 도면이다. 도 104는 NSL 기술 번역 프레임워크 방법론의 표현의 예를 보여주는 도면이다. 도 105는 파이썬 프로그램 및 NSL 솔루션의 표현의 예를 보여주는 도면이다. 도 106은 몇 가지 Java 구조 및 이에 대응하는 NSL 등가물의 예를 보여주는 표이다. 도 107a는 키워드 \"Static\"이 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를보여주는 도면이다. 도 107b는 키워드 \"Switch\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 도 107c는 키워드 \"Continue\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 도 107d는 키워드 \"Transient\"가 프로그래밍에서 사용되는 방식과 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 도 107e는 키워드 \"Long\"이 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보 여주는 도면이다. 도 107f는 키워드 \"Short\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보 여주는 도면이다. 도 107g는 키워드 \"Byte\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보 여주는 도면이다. 도 107h는 키워드 \"Default\"가 프로그래밍에서 사용되는 방식과 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 도 107i는 키워드 \"Super\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보 여주는 도면이다. 도 107j는 키워드 \"Protected\"이 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예 를 보여주는 도면이다. 도 107k은 키워드 \"This\"가 프로그래밍에서 사용되는 방식과 그것이 NSL에서 표현되는 방식의 표현의 예를 보여 주는 도면이다. 도 107l은 키워드 \"Synchronized\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 도 107m은 키워드 \"Strictfp\"가 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보여주는 도면이다. 도 107n은 키워드 \"final\"이 프로그래밍에서 사용되는 방식 및 그것이 NSL에서 표현되는 방식의 표현의 예를 보 여주는 도면이다. 도 108a는 파이썬 프로그램의 입력 및 출력 표현의 예를 보여주는 도면이다. 도 108b는 NSL 솔루션의 입력 및 출력의 표현의 예를 보여주는 도면이다. 도 109는 NSL 기술 재번역 프레임워크 방법론의 표현의 예를 보여주는 도면이다. 도 110은 입력 및 출력을 갖는 NSL 솔루션 및 등가의 파이썬 및 C 프로그램의 표현의 예를 보여주는 도면이다. 도 111은 공통 논리 트리에 의해 생성된 출력의 예를 나타내는 도이다. 도 112는 NSL에서 프로그래밍 언어로의 코드 생성의 예를 보여주는 도면이다. 도 113은 솔루션을 설계하고 배치하기 위한 시스템을 나타낸다. 도 114은 프로그래밍 언어 코드를 자연어로 번역하고 변환하기 위한 시스템을 나타낸다. 도 115는 NSL로 구성된 솔루션을 프로그래밍 언어로 번역하고 변환하는 시스템을 나타낸다. 도 116은 DLD 엔진에 존재하는 구성 요소 및 DLD 정보 흐름의 예를 도시한 도이다. 도 117은 SOP를 NSL로 변환하는 예를 나타낸 도이다. 도 118은 순차적 변경 유닛의 예를 도시하는 도면이다. 도 119는 CU2 또는 ACU2 중 하나가 CU3를 트리거하고 다른 하나는 사라지는 대안적인 변경 유닛의 예를 나타내는 도면이다. 도 120은 CU2와 PCU2 모두 CU3을 트리거하는 병렬 변경 유닛의 예를 보여주는 도면이다. 도 121은 종속 변경 유닛의 예를 도시하는 도면이다. 도 122는 일시적인 변경 유닛의 예를 나타내는 도면이다. 도 123은 내장 서브 변경 유닛의 예를 도시한 도면이다. 도 124는 솔루션 클래스 및 트랜잭션 클래스의 예를 보여주는 도면이다. 도 125는 컨텍스트 별 삼중 ID의 예를 보여주는 도면이다. 도 126은 HUB의 역할을 하는 NSL의 예를 도시한 도면이다. 도 127은 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어 및 비디오를 사용하여 컴퓨터 구현 솔루 션을 구축하는 방법을 나타내는 순서도다. 도 128은 표준 운영 절차 (SOP) 파일 및 프로그래밍 코드를 사용하지 않고 사용자가 이해하는 자연어를 사용하 여 컴퓨터 구현 솔루션을 구축하는 방법을 나타내는 순서도다."}
