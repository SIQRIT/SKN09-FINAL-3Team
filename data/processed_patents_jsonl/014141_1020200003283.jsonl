{"patent_id": "10-2020-0003283", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2020-0126888", "출원번호": "10-2020-0003283", "발명의 명칭": "시뮬레이터를 구현하는 방법, 장치, 기기 및 매체", "출원인": "베이징 바이두 넷컴 사이언스 앤 테크놀로지 코.,", "발명자": "장 자오"}}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "시뮬레이터를 구현하는 방법에 있어서, 유니파이드(Unified) 스토리지 파일에서 시뮬레이터의 제1 시뮬레이션 모듈에 쓰이는 제1 데이터를 읽어오는 단계 - 상기 제1 시뮬레이션 모듈은 칩의 제1 기능을 시뮬레이션하는데 사용되고, 상기 유니파이드 스토리지 파일은 상기 시뮬레이터의 제1 시뮬레이션 모듈이 입력 및 출력하는 데이터를 통합 저장함 - ,상기 유니파이드 스토리지 파일에 제2 데이터를 입력하는 단계 - 상기 제2 데이터는 상기 제1 시뮬레이션 모듈이 상기 제1 데이터를 처리하여 생성됨 - ,상기 유니파이드 스토리지 파일에서 상기 시뮬레이터의 제2 시뮬레이션 모듈에 쓰이는 상기 제2 데이터를 읽어오는 단계 - 상기 제2 시뮬레이션 모듈은 상기 칩의 제2 기능을 시뮬레이션하는데 사용되고, 상기 제2 시뮬레이션 모듈은 상기 제1 시뮬레이션 모듈 다음에 실행됨 - , 및상기 유니파이드 스토리지 파일에 제3 데이터를 입력하는 단계 - 상기 제3 데이터는 상기 제2 시뮬레이션 모듈이 상기 제2 데이터를 처리하여 생성됨 - 를 포함하는 방법."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1항에 있어서,상기 칩은 가속 컴퓨팅 임무를 수행하는 인공지능(AI) 칩이며, 상기 제1 시뮬레이션 모듈과 상기 제2 시뮬레이션 모듈은 데이터 정리 모듈, 매트릭스 연산 모듈, 연산 활성화 모듈 및 다이렉트 메모리 액세스(DMA) 모듈 중한가지에 각각 해당하고, 상기 방법은, 상기 시뮬레이터를 통해 상기 인공지능칩 설계의 타당성을 검증하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1항에 있어서,상기 시뮬레이터의 다수 시뮬레이션 모듈 간의 실행순서를 흐름제어 구성파일(control flow configurationfile)에 배치하는 단계 - 상기 다수 시뮬레이션 모듈은, 적어도 상기 제1 시뮬레이션 모듈과 상기 제2 시뮬레이션 모듈을 포함함 - , 및상기 흐름제어 구성파일에 배치한 실행순서에 따라 상기 다수 시뮬레이션 모듈이 순서대로 실행되는 단계를 더포함하는 방법."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 3항에 있어서,상기 흐름제어 구성파일의 실행순서를 수정하는 단계, 및수정 이후의 실행순서에 따라 상기 시뮬레이터의 다수 시뮬레이션 모듈의 처리과정을 조정하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 4항에 있어서,상기 흐름제어 구성파일의 상기 실행순서를 수정하는 단계는, 상기 시뮬레이터의 한 개 또는 다수의 시뮬레이션 모듈의 재배치에 응답하여, 상기 흐름제어 구성파일의 상기실행순서를 수정하는 단계를 포함하고, 공개특허 10-2020-0126888-3-상기 재배치는 시뮬레이션 모듈의 추가, 삭제 및 재배열 중 적어도 한가지에 해당하는 방법."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 3항에 있어서,상기 흐름제어 구성파일에서, 상기 시뮬레이터의 각 시뮬레이션 모듈에 대해서 유니파이드 스토리지 파일의 데이터 읽기 및 쓰기 권한을 설정하는 방법."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1항에 있어서,상기 유니파이드 스토리지 파일에 제2 데이터를 입력하는 단계는,상기 제1 시뮬레이션 모듈에서 상기 제2 시뮬레이션 모듈로 상기 제2 데이터를 직접적으로 커넥션하는 것이 아니라, 상기 제1 시뮬레이션 모듈에서 상기 유니파이드 스토리지 파일로 상기 제2 데이터를 전송하는 단계, 및상기 유니파이드 스토리지 파일에 상기 제2 데이터의 유형, 위치 및 크기를 기록하는 단계를 포함하는 방법."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1항에 있어서,상기 유니파이드 스토리지 파일에서, 상기 시뮬레이터의 제3 시뮬레이션 모듈에 쓰이는 상기 제3 데이터를 읽어오는 단계 - 상기 제3 시뮬레이션 모듈은 상기 칩의 제3 기능을 시뮬레이션하는데 사용됨 - , 및상기 유니파이드 스토리지 파일에, 상기 제3 시뮬레이션 모듈이 상기 제3 데이터를 처리하면서 생성한 제4데이터를 입력하는 단계를 더 포함하는 방법."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "시뮬레이터를 구현하는 장치에 있어서,유니파이드 스토리지 파일에서 시뮬레이터의 제1 시뮬레이션 모듈에 쓰이는 제1 데이터를 읽어오도록 구성된 제1 리딩모듈 - 상기 제1 시뮬레이션 모듈은 칩의 제1 기능을 시뮬레이션하는데 사용되고, 상기 유니파이드 스토리지 파일은 상기 시뮬레이터의 제1 시뮬레이션 모듈이 입력 및 출력하는 데이터를 통합 저장함 - , 상기 유니파이드 스토리지 파일에 제2 데이터를 입력하도록 구성된 제1 입력모듈 - 상기 제2 데이터는 상기 제1시뮬레이션 모듈이 상기 제1 데이터를 처리하여 생성됨 - , 상기 유니파이드 스토리지 파일에서 상기 시뮬레이터의 제2 시뮬레이션 모듈에 쓰이는 상기 제2 데이터를 읽어오도록 구성된 제2 리딩모듈 - 상기 제2 시뮬레이션 모듈은 상기 칩의 제2 기능을 시뮬레이션하는데 사용되고,상기 제2 시뮬레이션 모듈은 상기 제1 시뮬레이션 모듈 다음에 실행됨 - , 및 상기 유니파이드 스토리지 파일에 제3 데이터를 입력하도록 구성된 제2 입력모듈 - 상기 제3 데이터는 상기 제2시뮬레이션 모듈이 상기 제2 데이터를 처리하여 생성됨 - 을 포함하는 장치."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 9항에 있어서,상기 칩은 가속 컴퓨팅 임무를 수행하는 인공지능(AI) 칩이며, 상기 제1 시뮬레이션 모듈과 상기 제2 시뮬레이션 모듈은 데이터 정리 모듈, 매트릭스 연산 모듈, 연산 활성화 모듈 및 다이렉트 메모리 액세스(DMA) 모듈 중한가지에 각각 해당하고,상기 장치는, 상기 시뮬레이터를 통해 상기 인공지능칩 설계의 타당성을 검증하도록 구성된 검증모듈을 더 포함하는 장치."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 9항에 있어서,공개특허 10-2020-0126888-4-상기 시뮬레이터의 다수 시뮬레이션 모듈 간의 실행순서를 흐름제어 구성파일(control flow configurationfile)에 배치하도록 구성된 배치모듈 - 상기 다수 시뮬레이션 모듈은, 적어도 상기 제1 시뮬레이션 모듈과 상기제2 시뮬레이션 모듈을 포함함 - , 및상기 흐름제어 구성파일에 배치한 실행순서에 따라 상기 다수 시뮬레이션 모듈이 순서대로 실행되도록 구성된실행모듈을 더 포함하는 장치."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 11항에 있어서,상기 흐름제어 구성파일의 실행순서를 수정하도록 구성된 수정모듈, 및수정 이후의 실행순서에 따라 상기 시뮬레이터의 다수 시뮬레이션 모듈의 처리과정을 조정하도록 구성된 조정모듈을 더 포함하는 장치."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 12항에 있어서,상기 수정모듈은,상기 시뮬레이터의 한 개 또는 다수의 시뮬레이션 모듈의 재배치에 응답하여, 상기 흐름제어 구성파일의 상기실행순서를 수정하도록 구성된 제2 수정모듈을 포함하되,상기 재배치는 시뮬레이션 모듈의 추가, 삭제 및 재배열 중 적어도 한가지에 해당하는 장치."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 11항에 있어서,상기 흐름제어 구성파일에서, 상기 시뮬레이터의 각 시뮬레이션 모듈에 대해서 유니파이드 스토리지 파일의 데이터 읽기 및 쓰기 권한을 설정하도록 구성된 제2 배치모듈을 더 포함하는 장치."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 9항에 있어서,상기 제1 입력모듈은,상기 제1 시뮬레이션 모듈에서 상기 제2 시뮬레이션 모듈로 상기 제2 데이터를 직접적으로 커넥션하는 것이 아니라, 상기 제1 시뮬레이션 모듈에서 상기 유니파이드 스토리지 파일로 상기 제2 데이터를 전송하도록 구성된전송모듈, 및상기 유니파이드 스토리지 파일에 상기 제2 데이터의 유형, 위치 및 크기를 기록하도록 구성된 기록모듈을 포함하는 장치."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 9항에 있어서,상기 유니파이드 스토리지 파일에서, 상기 시뮬레이터의 제3 시뮬레이션 모듈에 쓰이는 상기 제3 데이터를 읽어오도록 구성된 제3 리딩모듈 - 상기 제3 시뮬레이션 모듈은 상기 칩의 제3 기능을 시뮬레이션하는데 사용됨 - ,및 상기 유니파이드 스토리지 파일에, 상기 제3 시뮬레이션 모듈이 상기 제3 데이터를 처리하면서 생성한 제4데이터를 입력하도록 구성된 제3 입력모듈을 더 포함하는 장치."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "한 개 또는 다수의 프로세서; 및한 개 또는 다수의 프로그램을 저장하는 메모리를 포함하는 전자 기기에 있어서,공개특허 10-2020-0126888-5-상기 한 개 또는 다수의 프로그램이 상기 한 개 또는 다수의 프로세서에 의해 실행되어, 제 1항 내지 제 8항 중한 항에 따른 방법을 구현하도록 하는 전자 기기."}
{"patent_id": "10-2020-0003283", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "컴퓨터 프로그램이 저장된 컴퓨터 판독 가능 저장 매체에 있어서,상기 컴퓨터 프로그램이 프로세서에 의해 실행될 경우 제1항 내지 제8항 중 어느 한 항에 따른 복수의 칩 사이의 통신 지원 방법을 구현하는 컴퓨터 판독 가능 저장 매체."}
{"patent_id": "10-2020-0003283", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 출원은 시뮬레이터를 구현하는 방법, 장치, 기기 및 매체에 관한 것이다. 상기 방법은, 유니파이드 스토리지 파일에서 시뮬레이터의 제1 시뮬레이션 모듈에 쓰이는 제1 데이터를 읽어온 후, 제1 시뮬레이션 모듈이 제1 데이 터를 처리하면서 생성한 제2 데이터를 유니파이드 스토리지 파일에 입력하는 단계를 포함한다. 상기 방법은, 유 니파이드 스토리지 파일에서 시뮬레이터의 제2 시뮬레이션 모듈에 쓰이는 제2 데이터를 읽어온 후, 제2 시뮬레이 션 모듈이 제2 데이터를 처리하면서 생성한 제3 데이터를 유니파이드 스토리지 파일에 입력하는 단계를 더 포함 한다. 본 출원의 실시예의 칩 시뮬레이터에 의하면, 각 시뮬레이션 모듈이 모두 유니파이드 스토리지 파일과의 데이터 커넥션이 이루어지나, 각각의 모듈간에는 어떠한 데이터 커넥션도 이루어지지 않는다. 이는 시뮬레이션 모듈을 자유롭게 조합하고 실행순서를 변경하는데 도움을 주기 때문에 칩 시뮬레이터 개발의 효율을 높여준다."}
{"patent_id": "10-2020-0003283", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 출원은 전체적으로 시뮬레이터 개발 영역에 관한 것이며, 더 구체적으로 시뮬레이터를 구현하는 방법, 장치, 기기 및 컴퓨터 판독 가능 저장 매체에 관한 것이다."}
{"patent_id": "10-2020-0003283", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "시뮬레이터는 보통 소프트웨어에 의해 개발된 시뮬레이션 프로그램이고, 일부 특정한 하드웨어 플랫폼을 시뮬레 이션할 수 있으며, 통상적인 시뮬레이터는 예컨대 컴퓨터 시뮬레이터, 주행 시뮬레이터, 비행 시뮬레이터 등이 있다. 칩은 집적회로라고도 불리는 실리콘 웨이퍼이며, 칩 개발 과정에서 보통 선제적 혹은 동시에 대응되는 기 능 시뮬레이터를 개발해야 한다. 기능 시뮬레이터는 주로 칩 하드웨어 설계의 정확성을 검증하는데 쓰이며, 하 드웨어 설계방안의 가능성을 모색함과 동시에 개발자 및 테스트 인력에게 소프트웨어 플랫폼을 제공할 수 있어 서, 칩 개발, 테스트 및 검증의 속도를 향상시킨다. 시뮬레이터 개발 목표를 실현하기 위해서는 시뮬레이터와 칩의 행위 및 성능이 최대한 일치해야 한다. 특히 기 능 시뮬레이터의 경우, 통상적으로 실행결과와 칩이 완전히 같아야 하고 기능도 완전히 같아야 한다. 보통 정확 한 데이터여야만 칩에 대한 검증과 테스트를 할 수 있고, 절대적인 참고 역할을 할 수 있다. 하지만 기능이 완 벽하고 정확한 기능 시뮬레이터를 만들려면 반드시 칩 하드웨어를 반복적으로 검사해야 하고, 시뮬레이터 자체 적으로 테스트를 반복해야 하므로, 업무를 완성하는데 상당한 인력과 시간이 소모된다. 따라서 기능 시뮬레이터 가 칩 설계방안 모색을 지원하여 설계자와 개발자의 편의를 제공할 필요가 있다."}
{"patent_id": "10-2020-0003283", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 출원의 목적은 시뮬레이터를 구현하는 것에 대한 방법, 장치, 전자 기기 및 컴퓨터 판독 가능 저장 매체에 관한 것이다."}
{"patent_id": "10-2020-0003283", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "제1 양태에 있어서, 시뮬레이터를 구현하는 방법을 제공하는데, 상기 방법은, 유니파이드(Unified) 스토리지 파 일에서 시뮬레이터의 제1 시뮬레이션 모듈에 쓰이는 제1 데이터를 읽어오는 단계 - 상기 제1 시뮬레이션 모듈은 칩의 제1 기능을 시뮬레이션하는데 사용되고, 상기 유니파이드 스토리지 파일은 상기 시뮬레이터의 제1 시뮬레 이션 모듈이 입력 및 출력하는 데이터를 통합 저장함 - , 상기 유니파이드 스토리지 파일에 제2 데이터를 입력 하는 단계 - 상기 제2 데이터는 상기 제1 시뮬레이션 모듈이 상기 제1 데이터를 처리하여 생성됨 - , 상기 유니 파이드 스토리지 파일에서 상기 시뮬레이터의 제2 시뮬레이션 모듈에 쓰이는 상기 제2 데이터를 읽어오는 단계 - 상기 제2 시뮬레이션 모듈은 상기 칩의 제2 기능을 시뮬레이션하는데 사용되고, 상기 제2 시뮬레이션 모듈은 상기 제1 시뮬레이션 모듈 다음에 실행됨 - , 및 상기 유니파이드 스토리지 파일에 제3 데이터를 입력하는 단계 - 상기 제3 데이터는 상기 제2 시뮬레이션 모듈이 상기 제2 데이터를 처리하여 생성됨 - 를 포함한다. 제2 양태에 있어서, 시뮬레이터를 구현하는 장치를 제공하는데, 상기 장치는, 유니파이드 스토리지 파일에서 시 뮬레이터의 제1 시뮬레이션 모듈에 쓰이는 제1 데이터를 읽어오도록 구성된 제1 리딩모듈 - 상기 제1 시뮬레이 션 모듈은 칩의 제1 기능을 시뮬레이션하는데 사용되고, 상기 유니파이드 스토리지 파일은 상기 시뮬레이터의 제1 시뮬레이션 모듈이 입력 및 출력하는 데이터를 통합 저장함 - , 상기 유니파이드 스토리지 파일에 제2 데이 터를 입력하도록 구성된 제1 입력모듈 - 상기 제2 데이터는 상기 제1 시뮬레이션 모듈이 상기 제1 데이터를 처리하여 생성됨 - , 상기 유니파이드 스토리지 파일에서 상기 시뮬레이터의 제2 시뮬레이션 모듈에 쓰이는 상기 제2 데이터를 읽어오도록 구성된 제2 리딩모듈 - 상기 제2 시뮬레이션 모듈은 상기 칩의 제2 기능을 시뮬레이션 하는데 사용되고, 상기 제2 시뮬레이션 모듈은 상기 제1 시뮬레이션 모듈 다음에 실행됨 - , 및 상기 유니파이 드 스토리지 파일에 제3 데이터를 입력하도록 구성된 제2 입력모듈 - 상기 제3 데이터는 상기 제2 시뮬레이션 모듈이 상기 제2 데이터를 처리하여 생성됨 - 을 포함한다. 제3 양태에 있어서, 한 개 또는 다수의 프로세서; 및 한 개 또는 다수의 프로그램을 저장하는 메모리를 포함하 는 전자 기기에 있어서, 상기 한 개 또는 다수의 프로그램이 상기 한 개 또는 다수의 프로세서에 의해 실행되어, 본 출원의 실시예에 따른 방법을 구현하도록 하는 전자 기기를 제공한다. 제4 양태에 있어서, 컴퓨터 프로그램이 저장된 컴퓨터 판독 가능 저장 매체에 있어서, 상기 컴퓨터 프로그램이 프로세서에 의해 실행될 경우 본 출원의 실시예에 따른 복수의 칩 사이의 통신 지원 방법을 구현하는 컴퓨터 판 독 가능 저장 매체를 제공한다. 과제 해결수단에서 설명한 내용은 본 출원의 실시예의 핵심 특징 또는 중요 특징을 제한하기 위함이 아니며, 본 출원의 범위를 한정하려는 것도 아니라고 이해되어야 한다. 본 출원의 기타 특징은 후문의 설명을 통해 더 명확 하게 설명하고자 한다."}
{"patent_id": "10-2020-0003283", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "후문에서는 도면을 참조하여 더 상세하게 본 출원의 실시예를 설명하고자 한다. 한편, 도면에서 본 출원의 일부 실시예를 도시하였는데, 이는 더 분명하고 완전하게 본 출원을 이해하고자 함이며, 후문에서 설명한 실시예에 본 출원이 국한되지 않고, 본 출원은 다양한 형식으로 구현될 수 있다고 이해하여야 할 것이다. 또한 본 출원의 도면과 실시예는 시범적 용도로만 쓰인 것이고, 본 출원의 청구범위를 제한하는 것이 아니라고 이해되어야 한다. 본 출원의 실시예 설명 중, '포함' 및 그 유사한 용어는 개방적으로 해석되어야 할 것이다. 즉, '포함하지만 한 정되지 않는다'는 의미이다. '기반하여'는 '적어도 부분적으로 기반하여'로 해석되어야 한다. '일 실시예' 또는 '본 실시예'는 '적어도 일 실시예'로 해석되어야 한다. '일부 실시예'는 '적어도 일부 실시예'로 해석되어야 한 다. 후문에서는 기타 다른 명확한 정의와 함축적인 정의가 나올 수 있다. 도 1은 전통적인 기능 시뮬레이터의 구조를 도시한 설명도이다. 기능 시뮬레이터는 많은 시뮬레이션 모듈(110, 120, 130, 140, 150)을 포함하고, 시뮬레이션 모듈은 각각 하드웨어 칩의 일부 기능을 시뮬레이션할 수 있다. 기능 시뮬레이터는, 전송된 입력에 기반하여, 각 시뮬레이션 모듈의 처리를 거쳐 상응하는 출력을 도출한다. 이와 같은 시뮬레이션 모듈 간의 데이터의 스트림 순서는 보통 고정되어 있어서 각 시뮬 레이션 모듈에서 상호작용을 하는 앞뒤 시뮬레이션 모듈을 정의해준다. 예를 들어, 시뮬레이션 모듈에 시 뮬레이션 모듈에서 입력 데이터를 받고 시뮬레이션 모듈과 커넥션하는 것을 정의; 동시에 시뮬레이션모듈에 출력 데이터를 시뮬레이션 모듈로 전송하고, 시뮬레이션 모듈에 커넥션하는 것도 정의하 여야 한다. 따라서 각각의 시뮬레이션 모듈에 커넥션 되는 입력 데이터 모듈과 출력 데이터 모듈을 정의해 주어 야 하고, 어떤 시뮬레이션 모듈의 입력 데이터 모듈 및/혹은 출력 데이터 모듈에 수정이 필요할 때는 해당 모듈 에서 재정의를 해주어야 한다. 그렇기 때문에 종래의 시뮬레이터 개발에서는 보통 칩 하드웨어의 구체적인 설계에 따라 정의를 내리고 개발을 한다. 예를 들어 칩의 어떤 기능 모듈이 있다면, 대응하는 기능 시뮬레이터에도 상응하는 시뮬레이션 모듈이 있 다. 기능 시뮬레이터 내부의 각 시뮬레이션 모듈은 소프트웨어 프로그램의 프로그래밍 인터페이스를 통해 긴밀 하게 연결되고, 각 시뮬레이션 모듈의 데이터 스트림의 순서는 기본적으로 고정되어 있고, 각각의 시뮬레이션 모듈 간에는 프로그램 인터페이스를 통해 연결 및 데이터 교환을 한다. 하지만 이렇게 긴밀하게 결합된 설계는 시뮬레이션 모듈을 추가, 삭제 및/혹은 재배치를 할 때 마다 수많은 시뮬레이션 모듈을 수정해야 하므로, 기능 시뮬레이터 개발의 가용성이 낮아지고 조정이 비교적 번거로워 개발 효율을 떨어뜨린다. 따라서 종래기술의 문 제점은 하드웨어를 시뮬레이션하는데 쓰이는 칩의 칩 시뮬레이터의 개발 효과가 낮은 편이고 확장성이 부족하다 는 점이다. 이를 위해 본 출원의 실시예에서는 칩 시뮬레이터에 필요한 모듈화의 빠른 개발을 가능하게 하는 방안을 제시한 다. 본 출원에 따른 칩 시뮬레이터와 각 시뮬레이션 모듈은 모두 유니파이드 스토리지 파일과 데이터 커넥션을 하는데, 각각의 모듈 간에는 데이터 커넥션이 이루어 지지 않는다. 이는 시뮬레이션 모듈의 자유로운 조합과 실 행순서 조정을 용이하게 해주어 칩 시뮬레이터 개발효과와 칩 시뮬레이터의 확장성을 높여준다. 그 밖에도 발명인은 인공지능(AI) 칩이 보통의 칩에 비해 업무 지원 변화가 상대적으로 빠르고 인터페이스 변경 이 수월하다는 것을 발견하였다. 인터페이스 변경은 보통 연관된 시뮬레이션 모듈과 데이터 처리 프로세스의 변 경까지 이어진다. 한편 딥러닝 알고리즘이 빠르게 변화하고 종류도 다양해지고 있어 다른 처리 환경에서 다른 기능의 모듈과 특정한 데이터 통로가 필요하다. 따라서 AI칩의 경우, 기능 시뮬레이터의 모듈화가 더욱 시급하 며, 유연한 설계와 개발 목표를 실현시킬 필요가 있다. 그렇기 때문에 AI칩 시뮬레이터에 있어서 레이어와 모듈 을 구분한 결합 설계가 더 필요하고, 이를 통해 새로운 변화와 설계 요구에 빠르게 발 맞출 수 있다. 아래의 도 2 내지 도 8은 본 출원의 실시예 예시를 구현하는 것에 대한 설명이다. 도 2는 본 출원에 따른 시뮬레이터를 구현하는 방법의 흐름도이다. 도 2의 방법을 더 자세히 설명하 기 위해 도 3의 본 출원에 따른 칩을 시뮬레이션 하는데 필요한 기능 시뮬레이터의 구조를 함께 참조하여 설명 하고자 한다. 블록에서, 유니파이드 스토리지 파일에서 시뮬레이터의 제1 시뮬레이션 모듈에 필요한 제1 데이터를 읽는 다. 그 중 제1 시뮬레이션 모듈은 칩의 제1 기능을 시뮬레이션 하는데 쓰이며, 유니파이드 스토리지 파일은 시 뮬레이션 모듈의 입력 데이터와 출력 데이터를 통합 저장한다. 예를 들어, 도 3은 칩을 시뮬레이션하는 기능 시 뮬레이터의 구조를 나타내는 설명도인데, 화살표를 보면, 시뮬레이션 모듈이 유니파이드 스토리지 파일에서 데이터를 읽고, 그 중 시뮬레이션 모듈은 매트릭스 연산과 같은 칩의 어떤 기능을 시뮬레이션할 수 있다. 본 출원의 실시예에서 유니파이드 스토리지 파일은 각 시뮬레이션 모듈의 입력 및 출력 데이터를 통합 저장 할 수 있고, 각 시뮬레이션 모듈에 통합적인 데이터 커넥션 인터페이스를 제 공함으로써 각 시뮬레이션 모듈 간에 데이터의 직접 연결이 필요 없게 되었다. 본 출원의 일부 실시예에서 데이 터는 기능 시뮬레이터 외부의 입력일 수 있다. 추가적으로 설명하자면, 데이터는 기능 시뮬레이 터의 기타 다른 시뮬레이션 모듈(미도시)이 생성한 출력결과 일 수도 있다. 블록에서, 제1 시뮬레이션 모듈이 제1 데이터를 처리하여 생성된 제2 데이터를 유니파이드 스토리지 파일 에 입력한다. 예를 들어 도 3을 참조하면, 시뮬레이션 모듈이 데이터를 처리(예를 들어 매트릭스 연 산)하여 데이터를 생성하고, 화살표와 같이 데이터를 유니파이드 스토리지 파일에 전송한 다. 블록에서, 유니파이드 스토리지 파일에서 시뮬레이터의 제2 시뮬레이션 모듈에 필요한 제2 데이터를 읽어 온다. 상기의 제2 시뮬레이션 모듈은 칩의 제2 기능을 시뮬레이션하고, 제2 시뮬레이션 모듈은 제1 시뮬레이션 모듈 다음에 실행되도록 배치되어 있다. 도 3의 화살표를 참조하면, 시뮬레이션 모듈이 유니파이드 스토리지 파일에서 데이터를 읽어온다. 상기의 시뮬레이션 모듈은 연산을 활성화해주는 것과 같은 칩 의 어떠한 기능을 시뮬레이션 해준다. 시뮬레이션 모듈은 시뮬레이션 모듈 다음에 실행되도록 배치되 어 있어서, 시뮬레이션 모듈이 읽어오는 입력 데이터는 시뮬레이션 모듈의 출력 결과(즉, 출력 데이터)이다. 한편, 제1 시뮬레이션 모듈과 제2 시뮬레이션 모듈은 하드웨어 칩의 각종 기능을 각각 따로 시뮬레이션 할 수 있다고 이해되어야 할 것이다. 블록에서, 제2 시뮬레이션 모듈이 제2 데이터를 처리하면서 생성된 제3 데이터를 유니파이드 스토리지 파 일에 입력한다. 도 3을 참조하면, 시뮬레이션 모듈이 데이터를 처리(예를 들어 연산 활성화)하여 데 이터를 생성한 후, 화살표와 같이 데이터를 유니파이드 스토리지 파일에 전송한다. 따라서 본 출원 실시예의 방법에 따르면, 칩 시뮬레이터의 각 시뮬레이션 모듈은 모두 유니파이드 스토리 지 파일과 데이터 커넥션을 하며, 각 시뮬레이션 모듈 간에는 직접적인 데이터 교환을 하지 않는다. 이러한 방 식을 통해 칩 시뮬레이터의 각 시뮬레이션 모듈은 오직 유니파이드 스토리지 파일과의 커넥션만 실행하면 되므 로, 후문에 이어지는 모듈의 자유로운 조합과 모듈 실행 순서 조정에 도움을 주고 나아가 칩 시뮬레이터 개발의 효과와 확장성을 제고해 준다. 또한 본 출원의 실시예에 따른 시뮬레이션 모듈은 데이터에 대한 연산을 마친 이후에 유니파이드 스 토리지 파일에 연산 결과를 전송하는 것이지 시뮬레이션 모듈에 직접 전송하는 것이 아니다. 일부 실 시예에서 데이터를 유니파이드 스토리지 파일에 입력할 때, 유니파이드 스토리지 파일에서 데이 터의 유형, 위치, 크기 등 정보를 기록할 수 있다. 본 출원의 실시예에 따른 기능 시뮬레이터의 각 시뮬레이션 모듈은 모두 데이터 정리, 데이터 연산 및 데이터 전송 등의 데이터 처리기능을 갖추고 있다. 모든 시뮬레이션 모듈은 데이터를 처리한 다음 그 결과를 유니파이 드 스토리지 파일에 입력할 수 있고, 데이터의 유형, 데이터의 위치, 데이터의 크기 등 정보를 표기한다. 다른 시뮬레이션 모듈은 데이터를 읽어올 때, 모두 유니파이드 스토리지 파일에서 데이터를 읽고, 유니파이드 스토리 지 파일의 데이터 배치에 따라 해석을 하며, 획득한 데이터를 자체 기능 모듈에서 조작하고 연산 결과를 다시 유니파이드 스토리지 파일에 라이트 백(write back)하며, 데이터의 유형, 데이터의 위치, 데이터의 크기 등 정보를 표기한다. 이러한 방식을 통해 각 시뮬레이션 모듈 간에는 어떠한 프로세스 연결이 없다. 모든 시뮬레이 션 모듈은 데이터 스토리지 파일에 커넥션되어 있어서 기타 다른 시뮬레이션 모듈과는 연결관계가 없다. 상기 방식을 통해 각 시뮬레이션 모듈은 다른 시뮬레이션 모듈로부터 독립되어 있어, 유니파이드 스토리지 파일 의 데이터 정리 및 읽기에만 집중하면 된다. 시뮬레이션 모듈은 유니파이드 스토리지 파일에서 필요한 데이터를 읽어온 후 연산 및 처리를 하고, 결과를 유니파이드 스토리지 파일에 라이트 백 하여 후속 시뮬레이션 모듈이 다시 사용하도록 한다. 모든 시뮬레이션 모듈의 개발과 테스트는 한 개의 유니파이드 스토리지 파일만을 인터페 이스로 삼고, 모듈 내부 자체의 프로세스 개발과 디버그만 하면 되며, 그 뒤로는 어떤 한 시뮬레이션 모듈과 로 직 순서 조정 및 협업을 할 수 있다. 본 출원의 발명인은 현재 AI칩의 설계가 일반적인 상용 칩과 조금 다르다는 점을 인식하였다. AI칩은 통용되는 연산처리를 위해 설계된 것이 아니고, 실제 연산과 소프트웨어 응용에 더 가깝다는 점이다. 따라서 AI칩은 실제 업무 환경에 있어서 알고리즘 가속, 애플리케이션 속도향상의 구체적인 문제를 해결해야 한다. AI칩의 설계와 요구사항이 반드시 실제 업무와 알고리즘의 발전 및 시장 수요에 부합해야 응용에까지 목표를 실현 할 수 있다. 소프트웨어 알고리즘이 끊임없이 변화하고 반복되는 과정에서 하위레벨의 AI칩의 빠른 설계와 검증을 해내는 방 안이 필요하다. 이러한 상황에서 보통은 AI칩의 기능 시뮬레이터를 통해 구현하는데, 이는 하드웨어 개발주기가 상대적으로 길어서 소프트웨어의 기능 시뮬레이터로 빠른 개발을 하고 설계 방안의 타당성 및 정확성을 검증해 야 하기 때문이다. 따라서 소프트웨어의 기능 시뮬레이터가 반드시 빠른 속도로 가용성 있게 구현되어 실제 업 무를 지원하도록 요구되는 것이다. 본 출원 실시예의 방법에 따른 각 시뮬레이션 모듈의 연산 프로세스는 자유로운 조합이 가능하므로, AI칩이 시 뮬레이션 설계 수요에 더 잘 부합한다. AI 알고리즘의 변화와 반복은 매우 빠르고, 알고리즘의 각 시뮬레이션 모듈의 순서와 연산관계도 유연하게 변화할 것이다. 본 출원의 실시예에서 각 기능 시뮬레이터의 시뮬레이션 모 듈을 자유롭게 배치할 수 있고 기능 시뮬레이터의 실행 순서를 조정할 수 있으므로, 상위 레벨의 애플리케이션 변화를 충족시킬 수 있다. 이 과정에서 본 출원의 실시예에 따른 기능 시뮬레이터는 거의 변동이 필요 없어 개 발 및 테스트의 업무량을 눈에 띄게 줄여주었고, 이로써 AI칩이 설계의 타당성을 검증하는데 빠른 속도로 지원 할 수 있다. 본 출원의 실시예에서 시뮬레이션한 칩은 가속 컴퓨팅 임무를 수행하는 AI칩에 쓸 수 있다. AI칩에는 데이터 정 리 모듈, 매트릭스 연산 모듈, 연산 활성화 모듈 및 다이렉트 메모리 액세스(DMA) 모듈 등 다양한 알고리즘 연 산 모듈이 있다. 이러한 방식을 통해, 본 출원의 기능 시뮬레이터로 AI칩 설계의 타당성을 검증할 수 있고, AI 칩 설계 검증의 수요를 효과적으로 해결 할 수 있다. 도 4는 본 출원의 실시예에 따른 칩을 시뮬레이션 하는 또 다른 기능 시뮬레이터의 구조를 나타내는 설명 도이다. 도 4에 표시된 바와 같이, 기능 시뮬레이터는 다수의 시뮬레이션 모듈(410, 420, 430, 440, 450), 흐름제어 구성파일 및 유니파이드 스토리지 파일을 포함하며, 그 중 각 시뮬레이션 모듈은 칩 (예를 들어 AI칩)의 일부 기능을 시뮬레이션한다. 도 4를 참조하면, 흐름제어 구성파일은 실행순서와 같은 시뮬레이터의 많은 시뮬레이션 모듈 간의 실 행 순서를 설정하는데 쓰인다. 상기 실행순서는 예컨대 기능 시뮬레이터가 가동된 후 기능 시뮬레이 터의 각 시뮬레이션 모듈의 실행 절차로, 먼저 시뮬레이션 모듈이 실행된 후 시뮬레이션 모듈이 실행되고, 그 후에 시뮬레이션 모듈이 실행된 다음 시뮬레이션 모듈이 실행되고, 이어서 시뮬레이션 모듈이 실행된다. 다시 말해 기능 시뮬레이터는 흐름제어 구성파일에 설정된 실행순서에 따라 순차적으로 다수의 시뮬레이션 모듈을 실행시킨다. 유니파이드 스토리지 파일은 각 시뮬레이션 모듈의 입 력 및 출력 데이터를 통합 저장할 수 있고, 각 시뮬레이션 모듈에 통합적인 데이터 커넥션 인터페이스를 제공함 으로, 각 시뮬레이션 모듈 간의 데이터 커넥션은 필요 없다. 따라서 각 시뮬레이션 모듈의 실행과정에서 유니파 이드 스토리지 파일에서 데이터를 읽고 처리결과를 유니파이드 스토리지 파일에 통합적으로 입력하여 모든 연산 과정을 완성한다. 계속해서 도 4를 참고하면, 기능 시뮬레이터가 외부의 입력을 수신하여 입력을 유니파이드 스토리지 파일 에 저장 혹은 임시저장 후, 실행 순서에 따라 시뮬레이션 모듈이 먼저 유니파이드 스토리지 파 일에서 데이터를 읽고, 처리완료 후 유니파이드 스토리지 파일에 그 결과를 입력한다. 순서대로 시뮬 레이션 모듈이 유니파이드 스토리지 파일에서 데이터를 읽은 후 실행결과를 입력하고, 시뮬레이션 모 듈이 유니파이드 스토리지 파일에서 데이터를 읽은 후 결과를 입력, 시뮬레이션 모듈이 유니파 이드 스토리지 파일에서 데이터를 읽은 후 결과값을 입력, 시뮬레이션 모듈이 유니파이드 스토리지 파일에서 데이터를 읽은 후 결과를 입력한다. 모든 시뮬레이션 모듈이 처리완료 후 최종 데이터를 유니파 이드 스토리지 파일에서 외부로 전송하는데 그것이 출력 이다. 도 5는 본 출원 실시예에 따른 시뮬레이션 모듈의 실행순서를 조정하는 상태를 나타내는 설명도이다. 예를 들어, 흐름제어 구성파일의 실행순서를 수정한 후, 수정한 실행순서에 따라 시뮬레이터의 다수 시뮬레이션 모듈 의 처리 절차를 조정한다. 도 5와 같이, 새로운 설계의 검증이 필요하여 시뮬레이션 모듈과 시뮬레이션 모 듈의 실행순서를 서로 바꿀 때, 흐름제어 구성파일의 실행순서만 바꾸면 된다. 그러면 기능 시 뮬레이터가 가동될 때 수정된 실행순서에 따라 수정된 프로세스로 실행될 것이다. 따라서 본 출원의 실시예에 따르면 기능 시뮬레이터의 각 시뮬레이션 모듈의 실행순서를 변경해야 할 때, 시뮬레이션 모듈 자체의 코드 혹은 인터페이스 연결을 수정할 필요가 없고, 흐름제어 구성파일을 통해 설정만 하면 기능 시 뮬레이터의 모듈 실행 순서를 자유롭게 변경할 수 있어서, 칩 시뮬레이터의 개발 효율을 눈에 띄게 향상시 킨다. 추가 혹은 부가적으로 설명하면, 기능 시뮬레이터에서 시뮬레이션 모듈을 삭제 및/혹은 추가할 때도 흐름제어 구성파일에서 실행 순서를 변경할 수 있다. 도 6은 본 출원의 실시예에 따른 시뮬레이션 모듈 삭제 및 시뮬레이 션 모듈 추가를 나타내는 설명도이다. 도 6에서 나타낸 것처럼, 도 4와 도 5를 비교하면 기능 시뮬레이터 에서 시뮬레이션 모듈(430, 440, 450)을 삭제하고 새로운 시뮬레이션 모듈(530, 540)(예를 들어 새로운 시 뮬레이션 기능이 있는 새로운 시뮬레이션 모듈)을 추가하였다. 이에 따라 흐름제어 구성파일의 실행순서 도 수정되었다. 그러면 기능 시뮬레이터는 새로 수정된 실행순서에 따라 시뮬레이션 프로세스를 실행한다. 즉, 먼저 시뮬레이션 모듈이 실행된 후 시뮬레이션 모듈이 작동하고, 그 후에 시뮬레이션 모듈이, 그 다음에 시뮬레이션 모듈이 실행된다. 본 출원의 실시예에 따른 기능 시뮬레이터의 각 시뮬레이션 모듈의 개발자는 자체 내부의 모듈 개발과 테스트에 만 집중하면 되고, 각 시뮬레이션 모듈은 다른 시뮬레이션 모듈과 독립적인 지위를 가지고 있어서 개발자는 유 니파이드 스토리지 파일의 데이터 정리와 읽기에만 신경 쓰면 된다. 각 시뮬레이션 모듈이 유니파이드 스토리지 파일에서 필요한 데이터를 읽은 후 연산 및 처리를 하고 그 결과를 유니파이드 스토리지 파일에 라이트 백 (write back) 하여, 뒤따른 시뮬레이션 모듈이 사용하도록 한다. 이로써 기능 시뮬레이터 프레임 설계자는 자유 롭게 시뮬레이터의 전체적인 구조를 세우고, 연산 경로와 데이터 처리 프로세스를 조정할 수 있다. 즉 각 시뮬 레이션 모듈의 프로그램 코드를 수정할 필요가 없는 환경에서, 구조 설계자는 자유롭게 시뮬레이션 모듈을 추가, 교환 혹은 삭제 등의 배치를 하여 다양한 방법과 조합을 시도할 수 있다. 이런 방법을 통해 기능 시뮬레 이터 개발과 테스트의 업무량을 감소시키고, 칩(예를 들어 AI칩)의 설계 및 검증 전반에 걸쳐 속도를 향상시킨다. 일부 실시예에서, 흐름제어 구성파일에서 시뮬레이터의 각 시뮬레이션 모듈에 대한 유니파이드 스토리지 파일에 서의 데이터 읽기 및 쓰기 권한을 설정할 수도 있다. 이 방법을 통해 각 시뮬레이션 모듈이 일부 데이터만 읽어 오게 할 수 있고, 다른 데이터를 읽거나 조작할 수 없게 하여 시뮬레이터의 안정성과 신뢰성을 보장할 수 있다. 따라서 본 출원의 실시예에 따른 각 시뮬레이션 모듈의 실행순서를 자유롭게 조합할 수 있으므로 AI칩의 설계 탐색에 더 잘 부합할 수 있다. AI 알고리즘의 변화와 반복이 매우 빠르게 진행되고, 알고리즘의 각 시뮬레이션 모듈의 순서와 연산관계도 유연하게 변화하고 있다. 그렇기 때문에 각 기능 시뮬레이터의 모듈을 자유롭게 배치 할 수 있고 기능 시뮬레이터의 실행 순서를 조정할 수 있는 점은 상위 레벨의 응용 변화에 잘 부합할 수 있다. 이 과정에서 본 출원의 실시예에 따른 기능 시뮬레이터는 최소한의 수정만 하면 되므로 개발 및 테스트 업무량 을 크게 줄여주었고, AI칩이 설계의 타당성을 검증하는데 빠른 속도로 지원할 수 있게 하였다. 도 7은 본 출원에 따른 시뮬레이터를 구현하는 장치를 도시한 블록도이다. 도 7을 보면, 장치는 제1 리딩모듈, 제1 입력모듈, 제2 리딩모듈 및 제2 입력모듈을 포함한다. 제1 리딩모듈은 유니파이드 스토리지 파일에서 시뮬레이터의 제1 시뮬레이션 모듈에 필요한 제1 데이터를 읽어오고, 그 중 제1 시뮬레이션 모듈은 칩의 제1 기능을 시뮬레이션하고, 유니파이드 스토리지 파일은 시뮬레이터의 시뮬레이션 모 듈의 입력 데이터와 출력 데이터를 통합적으로 저장한다. 제1 입력모듈은 유니파이드 스토리지 파일에 제2 데이터를 입력하고, 제2 데이터는 제1 시뮬레이션 모듈이 제1 데이터를 처리하여 생성한 것이다. 제2 리딩모듈 은 유니파이드 스토리지 파일에서 시뮬레이터의 제2 시뮬레이션 모듈에 필요한 제2 데이터를 읽어오며, 제 2 시뮬레이션 모듈은 칩의 제2 기능을 시뮬레이션하고, 제2 시뮬레이션 모듈은 제1 시뮬레이션 모듈 다음에 실 행 하도록 배치 되어있다. 제2 입력모듈은 유니파이드 스토리지 파일에 제3 데이터를 입력하고, 제3 데이 터는 제2 시뮬레이션 모듈이 제2 데이터를 처리하여 생성한 것이다. 일부 실시예에서, 상기 칩은 가속 컴퓨팅 임무를 수행하는 인공지능(AI)칩이라고 할 수 있고, 제1 시뮬레이션 모듈과 제2 시뮬레이션 모듈은 데이터 정리 모듈, 매트릭스 연산 모듈, 연산 활성화 모듈 및 다이렉트 메모리 액세스(DMA) 모듈 중 한가지에 해당하고, 장치는 시뮬레이터로 인공지능 칩의 설계에 대한 타당성을 검증 하는 검증모듈도 포함한다. 일부 실시예에서, 장치는, 흐름제어 구성파일에서 시뮬레이터의 다수 시뮬레이션 모듈 간의 실행 순서를 배치하기 위한 배치모듈 - 다수 시뮬레이션 모듈은 적어도 제1 시뮬레이션 모듈과 제2 시뮬레이션 모듈을 포함 함 - , 및 흐름제어 구성파일에서 배치한 실행순서에 따라 다수의 시뮬레이션 모듈을 순서대로 실행시키기 위한 실행모듈을 더 포함한다. 일부 실시예에서, 장치는 흐름제어 구성파일의 실행순서를 수정하기 위해 배치한 수정 모듈; 및 수정 후의 실행 순서에 따라 시뮬레이터의 다수 시뮬레이션 모듈의 처리 과정을 조정하도록 배치한 조정모듈을 더 포함한 다. 일부 실시예에서, 상기의 수정 모듈에는 시뮬레이터의 한 개 혹은 다수의 시뮬레이션 모듈을 재배치하고 흐름제 어 구성파일의 실행 순서를 변경하기 위한 제2 수정 모듈을 포함하며, 상기의 재배치는 시뮬레이션 모듈의 추가, 삭제 및 재배치 중 적어도 한가지에 해당한다. 일부 실시예에서, 장치는 흐름제어 구성파일에서 시뮬레이터의 각 시뮬레이션 모듈에 대한 유니파이드 스 토리지 파일의 데이터 읽기 및 쓰기 권한을 설정하기 위해 배치된 제2 설정모듈을 더 포함한다. 일부 실시예에서, 상기의 제1 입력모듈에는 제1 시뮬레이션 모듈이 제2 시뮬레이션 모듈에 직접적으로 제2 데이터를 커넥션하지 않고, 제1 시뮬레이션 모듈에서 유니파이드 스토리지 파일로 제2 데이터를 전송하기 위해 배치한 전송모듈; 및 유니파이드 스토리지 파일에서 제2 데이터의 유형, 위치 및 크기를 기록하기 위해 배치한 기록 모듈을 포함한다. 장치는, 유니파이드 스토리지 파일에서 칩의 제3 기능을 시뮬레이션 해주는, 시뮬레이터의 제3 시뮬레이션 모듈에 필요한 제3 데이터를 읽어 오는 제3 리딩모듈; 및 유니파이드 스토리지 파일에 제3 시뮬레이션 모듈이 제3 데이터를 처리하면서 생성한 제4데이터를 입력하는 제3 입력모듈을 더 포함한다. 도 7에서 도시한 제1 리딩모듈, 제1 입력모듈, 제2 리딩모듈 및 제2 입력모듈은 한 개 혹 은 다수의 전자기기에 포함될 수 있다고 이해되어야 할 것이다. 또한 도 7에 나타낸 모듈은 본 출원의 실시예의 방법 또는 과정의 절차 혹은 동작을 실행할 수 있다고 이해되어야 한다. 따라서 본 출원의 실시예는 칩 시뮬레이터 개발 과정에서, 각 시뮬레이션 모듈이 모두 유니파이드 스토리지 파일과 데이터 커넥션을 하고 각 모듈 간 에는 데이터 커넥션이 없으므로, 자유롭게 모듈을 조합하고 실행순서를 조정할 수 있도록 해주어 칩 시뮬레이터 개발의 효율을 높여준다. 도 8은 본 출원을 시범한 기기를 도시한 블록도이다. 기기는 본 출원에서 설명한 시뮬레이터를 구현 하기 위한 장치 또는 전자기기에 사용할 수 있다고 이해되어야 한다. 도면과 같이, 기기는 중앙처리 장치(CPU)를 포함하고, 이는 리드 온리 메모리(ROM)에 저장된 컴퓨터 프로그램 명령어 또는 기억장치 로부터 RAM에 로딩된 컴퓨터 프로그램 명령어에 따라 여러가지 적당한 동작과 처리를 수행할 수 있다. RAM에는 기기 조작에 필요한 여러가지 프로그램과 데이터를 저장할 수 있다. CPU, ROM 및 RAM은 데이터 버스를 통해 서로 연결된다. 입력/출력(I/O) 인터페이스도 데이터 버 스에 연결된다. 입력/출력(I/O) 인터페이스에 다음과 같은 기기의 부품들, 즉 키보드, 마우스 등을 포함하는 입력장 치; 다양한 유형의 디스플레이, 스피커 등의 출력장치; 디스크, CD 등을 포함하는 기억장치; 및 LAN 카드, 모뎀, 무선통신 트랜시버 등의 통신장치를 연결할 수 있다. 통신장치는 기기가 인터 넷과 같은 네트워크 및/혹은 여러가지 통신망을 통하여 다른 기기와 정보/데이터를 교환하도록 한다. 처리장치가 방법처럼 상기에서 설명한 각 방법과 절차를 실행한다. 예를 들어 일부 실시예에서, 방법 은 컴퓨터 소프트웨어 프로그램으로 구현될 수 있고, 이는 저장장치처럼 기계 판독 가능 매체에 실체가 있 도록 포함된다. 본 출원의 실시예에서 컴퓨터 프로그램의 부분 혹은 전부는 ROM 및/혹은 통신장치를 거쳐 기기에 기록 및/혹은 설치된다. 컴퓨터 프로그램이 RAM에 로딩 되고 CPU에 의해 실행 될 때, 상기에 기술한 방법 중 한 개 혹은 다수의 동작 또는 절차를 수행할 수 있다. 부수적으로, 다른 실시예에서 CPU는 다른 어떤 적당한 방식(예를 들어 펌웨어를 이용)을 통해 실행방법으로 배치될 수 있다. 상기에서 설명한 기능은 적어도 부분적으로 한 개 혹은 다수의 하드웨어 로직 유닛에 의해 실행될 수 있다. 예 를 들어, 제약없이 사용 가능한 시범유형의 하드웨어 로직 유닛은 프로그래머블 반도체(FPGA), 주문형 반도체 (ASIC), 특정용도 표준제품(ASSP), 시스템 온 칩(SOC), 복합 프로그래머블 논리 소자(CPLD) 등이 있다. 본 출원의 방법에 따른 프로그램 코드는 한 개 혹은 다수의 프로그래밍 언어의 자유로운 조합으로 프로그래밍 될 수 있다. 이러한 프로그램 코드는 범용 컴퓨터, 전용 컴퓨터 혹은 다른 프로그래밍이 가능한 데이터의 처리 장치 혹은 제어장치에 제공할 수 있고, 처리장치 또는 제어장치가 프로그램 코드를 실행할 때, 흐름도 및/혹은 블록도에서 규정한 기능/조작을 가능하게 한다. 프로그램 코드는 장치 상에서 완전한 실행, 장치 상에서 부분적 실행이 가능하고, 독립적인 소프트웨어 패키지로 장치에서 부분적 실행 및 원격장치에서 부분적 실행 또는 원격 장치 또는 서버에서의 완전한 실행이 가능하다. 본 출원의 전후 설명에서, 기계 판독 가능 매체는 유형의 매체이고, 이는 실행 명령 시스템, 장치 또는 기기를 사용하기 위한 프로그램, 혹은 실행 명령 시스템, 장치 또는 기기와 결합해서 사용하기 위한 프로그램을 포함하 거나 저장할 수 있다. 기계 판독 가능 매체는 기계 판독 신호 매체 혹은 기계 판독 기억 매체이다. 기계 판독 가능 매체는 전기, 자성, 광학, 전자, 적외선 혹은 반도체 계통, 장치 또는 기기, 또는 상술한 내용의 적절한 조합을 포함하지만 여기에 국한되지 않는다. 기계 판독 가능 매체의 더 구체적인 예는 한 개 혹은 다수 선의 전 기 결선, 콤팩트 디스크, 하드 디스크, 랜덤 액세스 메모리(RAM), 리드 온리 메모리(ROM), 비휘발성 반도체 기 억장치(EPROM 혹은 플래시 메모리), 파이버, 읽기용 콤팩트 디스크 기억장치(CD-ROM), 광학 기억장치, 자기 기 억장치 또는 상술한 것의 적절한 조합이다. 한편, 비록 특정 순서로 각 동작 혹은 절차를 설명하였지만, 이러한 동작과 절차가 도시한 특정 차례 혹은 순서 에 따라 순서대로 실행되도록 요구하는 것, 또는 도시한 모든 동작 혹은 절차가 실행되어야 한다고 요구하는 것 은 기대하는 결과를 얻기 위해서라고 이해되어야 한다. 어떤 일정한 환경에서, 멀티 태스킹과 병렬 처리는 유리 할 것이다. 마찬가지로 비록 상기 설명에서 구체적인 구현 사항들을 기술했지만 이것이 본 출원의 범위를 제한 한다고 이해되어서는 안된다. 일 실시예의 전후문 설명에서 기술한 어떠한 특징은 단일 구현 상황에서도 조합적 으로 구현될 수 있다. 반대로 단일 구현에 대한 전후문 설명에서 기술한 각종 특징들도 단독적으로 혹은 어떤 적절한 결합을 통해 다중 구현에서도 구현될 수 있다. 비록 프레임 특징 및/혹은 방법에 특정하여 로직 동작에 대한 언어로 본 출원의 실시예를 설명하였지만, 첨부된 청구범위에서 한정한 주제는 상기 설명의 특정적 특징 또는 동작에 국한되지 않음을 주의하여야 한다. 반대로 상기에서 설명한 특정한 특징과 동작은 단순히 청구항의 실시예를 구현하기 위한 시범 형식에 불과하다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8"}
{"patent_id": "10-2020-0003283", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도면과 후문의 상세한 설명을 참고하면 본 출원의 각 실시예의 상기 설명과 기타 특징 및 장점이 더 분명해 질 것이다. 도면에서 같거나 비슷한 도면 기호는 같거나 비슷한 요소를 나타낸다. 도 1은 전통적인 기능 시뮬레이터의 구조를 도시한 설명도이다. 도 2는 본 출원의 실시예에 따른 시뮬레이터를 구현하는 방법의 흐름도이다. 도 3은 본 출원의 실시예에 따른 칩을 시뮬레이션하는 기능 시뮬레이터의 구조를 도시한 설명도이다. 도 4는 본 출원의 실시예에 따른 칩의 또 다른 기능을 시뮬레이션하는 시뮬레이터의 구조를 도시한 설명도이다. 도 5는 본 출원의 실시예에 따른 기능 시뮬레이터의 시뮬레이션 모듈의 실행순서를 조정하는 것을 도시한 설명 도이다. 도 6은 본 출원의 실시예에 따른 기능 시뮬레이터의 시뮬레이션 모듈을 삭제 및 추가하는 것을 도시한 설명도이 다. 도 7은 본 출원의 실시예에 따른 시뮬레이터를 구현하는 장치의 블록도이다. 도 8은 본 출원의 일부 실시예를 실시할 수 있는 전자 기기의 블록도이다."}
