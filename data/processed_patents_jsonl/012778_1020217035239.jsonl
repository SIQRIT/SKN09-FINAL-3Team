{"patent_id": "10-2021-7035239", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0134823", "출원번호": "10-2021-7035239", "발명의 명칭": "기판 프로세싱 시스템들을 위한 모델 기반 스케줄링", "출원인": "램 리써치 코포레이션", "발명자": "차우, 레이몬드"}}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "레시피에 따라 반도체 기판들을 프로세싱하도록 구성된 복수의 프로세싱 챔버들을 포함하는 툴 내에서 상기 반도체 기판들을 프로세싱하기 위한 시스템에 있어서, 프로세서; 및상기 프로세서에 의한 실행을 위한 인스트럭션들을 저장하는 메모리를 포함하고, 상기 인스트럭션들은,레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판들의 프로세싱에 관한 제 1 데이터를 툴로부터수신하고; 상기 툴 및 상기 레시피의 구성에 관한 제 2 데이터를 수신하고;상기 제 2 데이터를 사용하여, 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들을 프로세싱하기 위해 복수의 프로세싱 시나리오들에 대한 스케줄링 파라미터들 및 상기 복수의 프로세싱 시나리오들을 시뮬레이팅하고;상기 복수의 프로세싱 시나리오들 및 상기 복수의 프로세싱 시나리오들에 대한 상기 스케줄링 파라미터들을 사용하여 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들의 프로세싱을시뮬레이팅하고;상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들을 프로세싱하기 위한 최적의(optimum) 스케줄링 파라미터들을 예측하도록 상기 시뮬레이션에 의해 생성된 데이터 및 상기 제 1 데이터를 사용하여 모델을 트레이닝하고;상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들 중 하나의 반도체 기판의 프로세싱에관한 입력들을 상기 툴로부터 수신하고;상기 모델을 사용하여 상기 입력들에 기초하여, 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들 중 상기 하나의 반도체 기판을 프로세싱하기 위한 최적의 스케줄링 파라미터들을 예측하고; 그리고상기 레시피에 따라 상기 복수의 프로세싱 챔버들 내에서 상기 반도체 기판들 중 상기 하나의 반도체 기판을 프로세싱하기 위한 상기 최적의 스케줄링 파라미터들에 기초하여 상기 툴의 동작들을 스케줄링하도록 구성되는,반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서, 상기 인스트럭션들은 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들 중 상기 하나의반도체 기판을 프로세싱하기 위한 상기 최적의 스케줄링 파라미터들에 기초하여 상기 툴의 상기 동작들을 실행하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서, 상기 최적의 스케줄링 파라미터들은 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서의 프로세싱 동안 상기 반도체 기판들 중 상기 하나의 반도체 기판에 대한 유휴 시간들을 최소화하고, 그리고 상기 최적의 스케줄링파라미터들은 상기 툴의 처리량을 최대화하는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "공개특허 10-2021-0134823-3-제 1 항에 있어서, 상기 인스트럭션들은 인공 신경망을 포함하는 머신 러닝 방법을 사용하여 상기 모델을 트레이닝하고 벡터 회귀를 지원하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1 항에 있어서, 상기 인스트럭션들은, 상기 툴로부터 수신된 상기 제 1 데이터 및 상기 시뮬레이션에 의해 생성된 상기 데이터를 분석하고; 상기 분석에 기초하여, 예방적 유지 보수 (preventive maintenance) 동작들, 웨이퍼-리스 자동 세정 (wafer-less auto clean) 시간들, 대기 시간들, 레시피 시간들, 및 상기 툴에 대한 처리량에 관한 패턴들을 검출하고;그리고상기 검출된 패턴들에 기초하여 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1 항에 있어서, 상기 인스트럭션들은 상기 복수의 프로세싱 시나리오들 중 하나에 대한 상기 최적의 스케줄링 파라미터들을 예측하기 위해 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서, 상기 인스트럭션들은 상기 복수의 프로세싱 시나리오들 모두에 대해 상기 최적의 스케줄링 파라미터들을 예측하기 위해 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1 항에 있어서, 상기 인스트럭션들은 상기 반도체 기판들 중 상기 하나의 반도체 기판 상에서 에칭 동작들만을 수행하기 위해상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1 항에 있어서, 상기 인스트럭션들은 상기 반도체 기판들 중 상기 하나의 반도체 기판 상에서 에칭 동작 및 스트립핑 동작 모두를 수행하기 위해 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 1 항에 있어서, 상기 모델은 상기 툴로부터 원격으로 구현되고, 그리고 상기 인스트럭션들은 복수의 툴들로부터 수신된 데이터에 기초하여 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 1 항에 있어서, 상기 인스트럭션들은 구성들 및 동작들의 툴-투-툴 (tool-to-tool) 변동들에 대해 상기 모델을 조정하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 1 항에 있어서, 공개특허 10-2021-0134823-4-상기 모델은 SaaS (software-as-a-Service) 로서 클라우드에서 구현되고, 그리고 상기 툴은 네트워크를 통해 상기 모델에 액세스하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 1 항에 있어서, 상기 인스트럭션들은 제 2 툴의 데이터에 기초하여 제 2 모델을 트레이닝하도록 구성되고;상기 모델 및 상기 제 2 모델은 상기 툴 및 상기 제 2 툴로부터 원격으로 구현되고; 그리고 상기 툴 및 상기 제 2 툴은 각각 하나 이상의 네트워크들을 통해 상기 모델 및 상기 제 2 모델에 액세스하도록구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 13 항에 있어서, 상기 인스트럭션들은 상기 툴 및 상기 제 2 툴로 하여금 상기 툴 및 상기 제 2 툴의 구성들에 기초하여 상기 모델 및 상기 제 2 모델을 각각 선택하게 하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 1 항에 있어서, 상기 모델은 상기 툴 상에서 구현되고, 그리고 상기 인스트럭션들은 상기 모델을 사용하여, 상기 툴에 의해 생성된 데이터를 사용하여 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들 중 상기 하나의 반도체 기판을 프로세싱하기 위한 상기 최적의 스케줄링 파라미터들을 예측하도록 구성되는, 반도체 기판프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 1 항에 있어서, 상기 모델은 상기 툴 상에서 구현되고, 그리고 상기 인스트럭션들은 상기 툴의 성능의 임의의 드리프트에 대해상기 모델을 조정하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제 1 항에 있어서, 상기 툴로부터 수신된 상기 제 1 데이터는 상기 툴 상에서 수행된 예방적 유지 보수 동작들로부터의 데이터 및상기 툴에 대한 레시피 시간들 및 웨이퍼-리스 자동 세정 시간들에 관한 데이터를 포함하는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제 1 항에 있어서, 상기 시뮬레이션에 의해 생성된 상기 데이터는 상기 툴의 구성, 웨이퍼-플로우 타입들, 실행 시나리오들, 레시피 시간들, 및 상기 툴로부터 획득된 웨이퍼-리스 자동 세정 시간들에 기초하여 생성된 데이터를 포함하는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 1 항에 있어서, 상기 툴로부터 수신된 상기 입력들은 상기 툴에 대한 다수의 예방적 유지 보수 동작들, 레시피 시간들, 및 웨이퍼-리스 자동 세정 시간들에 관한 데이터를 포함하는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제 1 항에 있어서, 공개특허 10-2021-0134823-5-상기 인스트럭션들은 하나 이상의 스킵된 예방적 유지 보수 동작들을 고려함으로써 상기 최적의 스케줄링 파라미터들을 예측하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제 1 항에 있어서, 상기 인스트럭션들은, 상기 모델을 사용하여, 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들 중 상기 하나의 반도체 기판을 프로세싱하기 위한 복수의 동작들을 스케줄링하고―상기 툴은 상기 복수의 동작들을 각각 수행하는 것에 응답하여 복수의 상태들을 통해 진행하고, 그리고 상기 툴의 상태는 상기 툴의 리소스들의 지표들및 상기 반도체 기판 중 상기 하나의 반도체 기판의 프로세싱 상태를 포함함―; 상기 복수의 상태들 각각에 대해, 상기 복수의 상태들의 다음 상태로 진행하기 위해 상기 복수의 상태들의 현재상태 및 복수의 스케줄링 가능한 동작들을 상기 모델로 전송하고, 상기 모델로부터 상기 다음 상태로 진행하기위해 상기 현재 상태에 기초하여 상기 모델에 의해 선택된 상기 복수의 스케줄링 가능한 동작들로부터 최상의동작을 수신하고, 그리고 상기 다음 상태로의 진행을 시뮬레이팅하도록 상기 최상의 동작의 실행을 시뮬레이팅하고; 그리고상기 레시피에 따라 상기 복수의 프로세싱 챔버들 내에서 상기 반도체 기판들을 프로세싱할 때 상기 복수의 상태들을 통해 진행하는 상기 툴에 응답하여 상기 복수의 동작들로서 상기 최상의 동작들을 추천하게 상기 모델을트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "레시피에 따라 반도체 기판들을 프로세싱하도록 구성된 복수의 프로세싱 챔버들을 포함하는 툴 내에서 상기 반도체 기판들을 프로세싱하기 위한 시스템에 있어서, 프로세서; 및상기 프로세서에 의한 실행을 위한 인스트럭션들을 저장하는 메모리를 포함하고, 상기 인스트럭션들은,모델을 사용하여, 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 반도체 기판을 프로세싱하기 위한 복수의 동작들을 스케줄링하고―상기 툴은 상기 복수의 동작들을 각각 수행하는 것에 응답하여 복수의 상태들을 통해 진행하고, 그리고 상기 툴의 상태는 상기 툴의 리소스들의 지표들 및 상기 반도체 기판의 프로세싱 상태를포함함―; 상기 복수의 상태들 각각에 대해, 상기 복수의 상태들의 다음 상태로 진행하기 위해 복수의 상태들의 현재 상태및 복수의 스케줄링 가능한 동작들을 모델로 전송하고, 상기 모델로부터 상기 다음 상태로 진행하기 위해 상기현재 상태에 기초하여 상기 모델에 의해 선택된 상기 복수의 스케줄링 가능한 동작들로부터 최상의 동작을 수신하고, 그리고 상기 다음 상태로의 진행을 시뮬레이팅하도록 상기 최상의 동작의 실행을 시뮬레이팅하고; 그리고상기 레시피에 따라 상기 복수의 프로세싱 챔버들 내에서 상기 반도체 기판을 프로세싱할 때 상기 복수의 상태들을 통해 진행하는 상기 툴에 응답하여 상기 복수의 동작들로서 상기 최상의 동작들을 추천하게 상기 모델을트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제 22 항에 있어서, 상기 인스트럭션들은, 상기 레시피에 따라 상기 복수의 프로세싱 챔버들 내에서 상기 반도체 기판을 프로세싱하기 위한 최적의 스케줄링 파라미터들을 예측하기 위해, 상기 툴로부터 수신된 상기 반도체 기판들의 프로세싱에 관한 이력 데이터를사용하고 상기 툴에 대한 복수의 프로세싱 시나리오들을 시뮬레이팅함으로써 상기 모델을 트레이닝하고;상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판의 프로세싱에 관한 입력들을 상기 툴로부터 수신하고; 공개특허 10-2021-0134823-6-상기 모델을 사용하여, 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판을 프로세싱하기위한 최적의 스케줄링 파라미터들을 상기 입력들에 기초하여 예측하고; 그리고상기 최적의 스케줄링 파라미터들에 기초하여, 상기 레시피에 따라 상기 복수의 프로세싱 챔버들 내에서 상기반도체 기판을 프로세싱하기 위해 상기 복수의 동작들을 스케줄링하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제 23 항에 있어서, 상기 인스트럭션들은 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판을 프로세싱하기위한 상기 최적의 스케줄링 파라미터들에 기초하여 상기 복수의 동작들을 실행하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제 23 항에 있어서, 상기 최적의 스케줄링 파라미터들은 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서의 프로세싱 동안 상기 반도체 기판에 대한 유휴 시간들을 최소화하고, 그리고 상기 최적의 스케줄링 파라미터들은 상기 툴의 처리량을 최대화하는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "제 23 항에 있어서, 상기 인스트럭션들은 인공 신경망을 포함하는 머신 러닝 방법을 사용하여 상기 모델을 트레이닝하고 벡터 회귀를 지원하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "제 23 항에 있어서, 상기 인스트럭션들은, 상기 툴로부터 수신된 상기 이력 데이터 및 상기 툴에 대한 상기 복수의 프로세싱 시나리오들을 시뮬레이팅함으로써 생성된 데이터를 분석하고; 상기 분석에 기초하여, 예방적 유지 보수 (preventive maintenance) 동작들, 웨이퍼-리스 자동 세정 (wafer-less auto clean) 시간들, 대기 시간들, 레시피 시간들, 및 상기 툴에 대한 처리량에 관한 패턴들을 검출하고;그리고상기 검출된 패턴들에 기초하여 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "제 23 항에 있어서, 상기 인스트럭션들은 상기 복수의 프로세싱 시나리오들 중 하나에 대한 상기 최적의 스케줄링 파라미터들을 예측하기 위해 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "제 23 항에 있어서, 상기 인스트럭션들은 상기 복수의 프로세싱 시나리오들 모두에 대해 상기 최적의 스케줄링 파라미터들을 예측하기 위해 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "제 23 항에 있어서, 공개특허 10-2021-0134823-7-상기 인스트럭션들은 상기 반도체 기판들 상에서 에칭 동작들만을 수행하기 위해 상기 모델을 트레이닝하도록구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "제 23 항에 있어서, 상기 인스트럭션들은 상기 반도체 기판들 중 상기 하나의 반도체 기판 상에서 에칭 동작 및 스트립핑 동작 모두를 수행하기 위해 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제 23 항에 있어서, 상기 모델은 상기 툴로부터 원격으로 구현되고, 그리고 상기 인스트럭션들은 복수의 툴들로부터 수신된 데이터에 기초하여 상기 모델을 트레이닝하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "제 32 항에 있어서, 상기 인스트럭션들은 구성들 및 동작들의 툴-투-툴 (tool-to-tool) 변동들에 대해 상기 모델을 조정하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제 23 항에 있어서, 상기 모델은 SaaS (software-as-a-Service) 로서 클라우드에서 구현되고, 그리고 상기 툴은 네트워크를 통해 상기 모델에 액세스하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "제 23 항에 있어서, 상기 모델은 상기 툴 상에서 구현되고, 그리고 상기 인스트럭션들은 상기 모델을 사용하여, 상기 툴에 의해 생성된 데이터를 사용하여 상기 레시피에 따라 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판을 프로세싱하기 위한 상기 최적의 스케줄링 파라미터들을 예측하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "제 23 항에 있어서, 상기 모델은 상기 툴 상에서 구현되고, 그리고 상기 인스트럭션들은 상기 툴의 성능의 임의의 드리프트에 대해상기 모델을 조정하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "제 23 항에 있어서, 상기 툴로부터 수신된 상기 데이터는 상기 툴 상에서 수행된 예방적 유지 보수 동작들로부터의 데이터 및 상기툴에 대한 레시피 시간들 및 웨이퍼-리스 자동 세정 시간들에 관한 데이터를 포함하는, 반도체 기판 프로세싱시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "제 23 항에 있어서, 상기 복수의 프로세싱 시나리오들을 시뮬레이팅함으로써 생성된 상기 데이터는 상기 툴의 구성, 웨이퍼-플로우타입들, 실행 시나리오들, 레시피 시간들, 및 상기 툴로부터 획득된 웨이퍼-리스 자동 세정 시간들에 기초하여생성된 데이터를 포함하는, 반도체 기판 프로세싱 시스템.공개특허 10-2021-0134823-8-청구항 39 제 23 항에 있어서, 상기 툴로부터 수신된 상기 입력들은 상기 툴에 대한 다수의 예방적 유지 보수 동작들, 레시피 시간들, 및 웨이퍼-리스 자동 세정 시간들에 관한 데이터를 포함하는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "제 1 항에 있어서, 상기 인스트럭션들은 하나 이상의 스킵된 예방적 유지 보수 동작들을 고려함으로써 상기 최적의 스케줄링 파라미터들을 예측하도록 구성되는, 반도체 기판 프로세싱 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "반도체 기판들을 프로세싱하기 위한 툴에 있어서, 툴 내에서 반도체 기판들을 프로세싱하기 위해 상기 툴 내로 상기 반도체 기판들을 입력하도록 구성된 제 1 로봇; 레시피에 따라 상기 툴 내에서 상기 반도체 기판들을 프로세싱하도록 구성된 복수의 프로세싱 챔버들; 상기 레시피에 따라 상기 복수의 프로세싱 챔버들 사이에서 상기 반도체 기판들을 이송하도록 구성된 제 2로봇; 및제어기를 포함하고, 상기 제어기는 상기 툴 및 상기 레시피를 시뮬레이팅함으로써 트레이닝된 모델을 사용하여, 상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들을 프로세싱하기 위한 프로세싱 시간들; 상기 복수의 프로세싱 챔버들 사이에서 상기 반도체 기판들을 이송하기 위한 상기 제 2 로봇에 대한 이송 시간들;상기 프로세싱 시간들 및 상기 이송 시간들에 기초하여 상기 복수의 프로세싱 챔버들 사이에서 상기 반도체 기판들을 이송하기 위한 루트; 및상기 제 1 로봇이 상기 프로세싱 시간들 및 상기 이송 시간들에 기초하여 상기 툴 내의 프로세싱을 위해 부가적인 반도체 기판들을 스케줄링하는 시간을 예측하도록 구성되고,상기 예측된 루트를 따른 상기 반도체 기판들의 프로세싱 및 상기 예측된 시간에 따른 상기 부가적인 반도체 기판들을 프로세싱은 상기 예측된 루트를 따른 상기 반도체 기판들에 대한 대기 시간들을 최적화하고 상기 툴의처리량을 최적화하는, 반도체 기판 프로세싱 툴."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "제 41 항에 있어서, 상기 제어기는 상기 툴 내의 상기 반도체 기판들 및 상기 부가적인 반도체 기판들의 상기 프로세싱 동안 생성된데이터에 기초하여 점진적으로 상기 모델을 더 트레이닝하도록 구성되는, 반도체 기판 프로세싱 툴."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_43", "content": "제 42 항에 있어서, 상기 제어기는 상기 더 트레이닝된 모델을 사용하여,상기 툴 내에서 상기 부가적인 반도체 기판들을 프로세싱하기 위한 제 2 프로세싱 시간들, 제 2 이송 시간들,및 제 2 루트; 및상기 툴에서의 프로세싱을 위해 반도체 기판들의 다음 세트를 스케줄링하기 위한 제 2 시간을 예측하도록 구성되고,공개특허 10-2021-0134823-9-상기 제 2 루트에 따라 상기 부가적인 반도체 기판들을 프로세싱하고 상기 제 2 시간에 따라 상기 반도체 기판들의 다음 세트를 프로세싱하는 것은 상기 부가적인 반도체 기판들에 대한 대기 시간들 및 상기 툴의 상기 처리량을 더 최적화하는, 반도체 기판 프로세싱 툴."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_44", "content": "제 41 항에 있어서, 상기 제어기는 상기 레시피, 상기 툴, 또는 모두에 대한 임의의 변화들에 응답하여 상기 모델을 조정하도록 구성되는, 반도체 기판 프로세싱 툴."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_45", "content": "제 41 항에 있어서, 상기 모델은,상기 복수의 프로세싱 챔버들에 대한 상기 프로세싱 시간들을 각각 예측하도록 구성된 제 1 복수의 신경망들;상기 제 1 로봇 및 상기 제 2 로봇에 대한 상기 이송 시간을 각각 예측하도록 구성된 제 2 복수의 신경망들; 및상기 제 1 복수의 신경망들 및 상기 제 2 복수의 신경망들에 커플링되고 그리고 상기 복수의 프로세싱 챔버들사이에서 상기 반도체 기판들을 이송하기 위한 상기 루트를 예측하고 그리고 상기 제 1 로봇이 상기 툴 내에서프로세싱을 위해 상기 부가적인 반도체 기판들을 스케줄링할 때 상기 시간을 예측하도록 구성된 제 3 신경망을포함하는, 반도체 기판 프로세싱 툴."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_46", "content": "제 41 항에 있어서, 상기 모델은 복수의 툴들 및 복수의 레시피들의 구성들을 시뮬레이팅함으로써 더 트레이닝되는, 반도체 기판 프로세싱 툴."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_47", "content": "제 46 항에 있어서, 상기 더 트레이닝된 모델은 입력으로서 레시피 정보를 수신하는 것에 응답하여 툴 구성에 대한 추천을 출력하도록 구성되는, 반도체 기판 프로세싱 툴."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_48", "content": "제 41 항에 있어서, 상기 레시피는 상기 반도체 기판들 상에 복수의 층들을 증착하기 위한 것이고,상기 복수의 프로세싱 챔버들은 상기 복수의 층들을 증착하기 위한 하나 이상의 프로세싱 챔버들, 및 상기 복수의 층들을 증착하기 전 및 상기 복수의 층들을 증착한 후에 상기 반도체 기판들을 각각 프로세싱하기 위한 사전-프로세싱 챔버 및 사후-프로세싱 챔버를 포함하고; 상기 제 2 로봇은 상기 반도체 기판들에 대한 상기 대기 시간들을 최적화하기 위해 상기 예측된 루트를 따라 상기 복수의 프로세싱 챔버들 사이에서 상기 반도체 기판들을 이송하도록 구성되고; 그리고 상기 제 1 로봇은 상기 툴의 상기 처리량을 최적화하기 위해 상기 예측된 시간에 따라 상기 툴 내에서 프로세싱을 위해 상기 부가적인 반도체 기판들을 스케줄링하도록 구성되는, 반도체 기판 프로세싱 툴."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_49", "content": "반도체 프로세싱 툴에서 반도체 기판들을 프로세싱하는 동안 처리량 및 대기 시간들을 최적화하기 위한 시스템에 있어서,프로세서; 및공개특허 10-2021-0134823-10-상기 프로세서에 의한 실행을 위한 인스트럭션들을 저장하는 메모리를 포함하고, 상기 인스트럭션들은,상기 반도체 프로세싱 툴의 구성 및 상기 반도체 프로세싱 툴의 상기 반도체 기판들 상에서 수행될 레시피에 기초하여, 상기 반도체 프로세싱 툴의 복수의 프로세싱 챔버들 사이에서 상기 반도체 기판들을 라우팅하기 위한복수의 루트들을 시뮬레이팅하고;상기 복수의 루트들을 따라 상기 레시피에 따라 상기 반도체 프로세싱 툴에서 상기 반도체 기판들의 프로세싱을시뮬레이팅하고;상기 반도체 기판들의 상기 프로세싱에 기초하여, 상기 반도체 프로세싱 툴 내에서 후속하여 부가적인 반도체기판들을 프로세싱하기 위한 복수의 타이밍 스케줄들을 시뮬레이팅하고;상기 복수의 타이밍 스케줄들에 따라 상기 부가적인 반도체 기판들의 프로세싱을 시뮬레이팅하고;상기 시뮬레이션들에 의해 생성된 데이터에 기초하여 모델을 트레이닝하고;상기 반도체 프로세싱 툴 상의 상기 모델을 사용하여, 상기 레시피에 따라 상기 반도체 프로세싱 툴 내에서 상기 반도체 기판들을 프로세싱할 때 상기 복수의 프로세싱 챔버들 사이에서 상기 반도체 기판들을 이송하기 위한최적의 루트를 예측하고; 상기 반도체 프로세싱 툴 상의 상기 모델을 사용하여, 상기 반도체 프로세싱 툴에서의 프로세싱을 위해 상기 부가적인 반도체 기판들을 스케줄링하기 위한 최적의 시간을 예측하고; 상기 반도체 프로세싱 툴에서, 상기 최적의 루트를 따라 상기 반도체 기판들에 대한 대기 시간들을 최적화하도록 상기 최적의 루트에 따라 상기 반도체 기판들을 프로세싱하고; 그리고상기 반도체 프로세싱 툴에서, 상기 반도체 프로세싱 툴의 처리량을 최적화하기 위해 상기 최적의 시간에 상기부가적인 반도체 기판들을 프로세싱하도록 구성되는, 최적화 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_50", "content": "제 49 항에 있어서, 상기 인스트럭션들은,상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들을 프로세싱하기 위한 프로세싱 시간들; 상기 반도체 기판들을 상기 복수의 프로세싱 챔버들 사이에서 이송하기 위한 상기 반도체 프로세싱 툴의 로봇에대한 이송 시간들;상기 프로세싱 시간들 및 상기 이송 시간들에 기초하여 상기 복수의 프로세싱 챔버들 사이에서 상기 반도체 기판들을 라우팅하기 위한 최적의 루트; 및상기 프로세싱 시간들 및 상기 이송 시간들에 기초하여 상기 반도체 프로세싱 툴에서 프로세싱을 위해 상기 부가적인 반도체 기판들을 스케줄링하기 위한 상기 최적의 시간을 예측하도록, 상기 시뮬레이션들에 의해 생성된상기 데이터에 기초하여 상기 모델을 트레이닝하도록 구성되는, 최적화 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_51", "content": "제 49 항에 있어서, 상기 인스트럭션들은 상기 반도체 프로세싱 툴 내의 상기 반도체 기판들 및 상기 부가적인 반도체 기판들의 상기 프로세싱 동안 생성된 데이터에 기초하여 상기 모델을 점진적으로 더 트레이닝하도록 구성되는, 최적화 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_52", "content": "제 49 항에 있어서, 상기 인스트럭션들은 상기 레시피, 상기 반도체 프로세싱 툴, 또는 모두에 대한 임의의 변화들에 대해 상기 모델을 조정하도록 구성되는, 최적화 시스템.공개특허 10-2021-0134823-11-청구항 53 제 49 항에 있어서, 상기 인스트럭션들은 상기 시뮬레이션들에 의해 생성된 상기 데이터에 기초하여 상기 모델을 생성하도록 구성되고, 상기 모델은,상기 복수의 프로세싱 챔버들에서 상기 반도체 기판들을 프로세싱하기 위한 프로세싱 시간들을 각각 예측하도록구성된 제 1 복수의 신경망들;제 1 로봇 및 제 2 로봇에 대한 이송 시간을 각각 예측하도록 구성된 제 2 복수의 신경망들로서, 상기 제 1 로봇 및 상기 제 2 로봇은 각각 상기 반도체 기판들을 상기 반도체 프로세싱 툴 내로 그리고 상기 복수의 프로세싱 챔버들 사이에서 이송하도록 구성되는, 상기 제 2 복수의 신경망들; 및상기 제 1 복수의 신경망들 및 상기 제 2 복수의 신경망들에 커플링되고 그리고 상기 복수의 프로세싱 챔버들사이에서 상기 반도체 기판들을 라우팅하기 위한 상기 최적의 루트를 예측하고 상기 반도체 프로세싱 툴에서 프로세싱을 위해 상기 부가적인 반도체 기판들을 스케줄링하기 위한 상기 최적의 시간을 예측하도록 구성된 제 3신경망을 포함하는, 최적화 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_54", "content": "제 49 항에 있어서, 상기 인스트럭션들은 복수의 반도체 프로세싱 툴들 및 복수의 레시피들의 구성들을 시뮬레이팅함으로써 상기 모델을 트레이닝하도록 구성되는, 최적화 시스템."}
{"patent_id": "10-2021-7035239", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_55", "content": "제 54 항에 있어서, 상기 인스트럭션들은 입력으로서 레시피 정보를 수신하는 것에 응답하여 툴 구성에 대한 추천을 출력하도록 상기 모델을 트레이닝하도록 구성되는, 최적화 시스템."}
{"patent_id": "10-2021-7035239", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "에칭 툴들에 대해, 신경망 모델은 최적의 스케줄링 파라미터 값들을 예측하도록 트레이닝된다. 모델은 입력들로 서 PM들 (preventive maintenance operations), 레시피 시간들 및 WAC (wafer-less auto clean) 시간들로부터 수집된 데이터를 사용하여 트레이닝된다. 모델은 예측들을 하기 위해 스케줄링 파라미터 값들과 다양한 웨이퍼 프로세싱 시나리오들 사이의 근본적인 관계들을 캡처하도록 사용된다. 부가적으로, 복수의 병렬 재료 증착 프로 세스들에 사용된 툴들에서, 내포된 신경망 기반 모델이 머신 러닝을 사용하여 트레이닝된다. 모델은 처음에 설 계되고 시뮬레이션된 데이터를 사용하여 오프라인으로 트레이닝된 후 웨이퍼 라우팅 경로 및 스케줄링을 예측하 기 위해 실제 툴 데이터를 사용하여 온라인으로 트레이닝된다. 이 모델은 스케줄러 페이싱 (scheduler pacing) 의 정확도를 개선하고 최고 툴/플릿 (fleet) 활용도, 최단 대기 시간들 및 최고 (fastest) 처리량을 달성한다."}
{"patent_id": "10-2021-7035239", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 일반적으로 기판 프로세싱 시스템들, 보다 구체적으로 기판 프로세싱 시스템들을 위한 모델-기반 스 케줄링에 관한 것이다."}
{"patent_id": "10-2021-7035239", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "본 명세서에 제공된 배경기술 기술 (description) 은 일반적으로 본 개시의 맥락을 제시하기 위한 목적이다. 본 배경 기술 섹션에 기술된 범위까지, 현재 명명된 발명자들의 업적, 뿐만 아니라 출원시 종래 기술로서 달리 인정되지 않을 수도 있는 기술의 양태들은 본 개시에 대한 선행 기술로서 명시적으로 또는 묵시적으로 인정되지 않는다. 반도체 제조사들은 반도체 웨이퍼들의 제조 동안 증착, 에칭, 세정, 및/또는 다른 기판 처리들을 수행하기 위해 하나 이상의 기판 프로세싱 툴들을 사용한다. 기판 프로세싱 툴들 각각은 (증착, 에칭, 또는 세정과 같은) 동 일한 타입의 처리 또는 상이한 처리들, 예컨대 기판들에 대해 일련의 처리들 또는 연속적인 처리들을 수행하는 복수의 프로세싱 챔버들을 포함할 수도 있다. 기판 프로세싱 툴들의 프로세싱 챔버들은 보통 복수의 기판들에 대해 동일한 태스크를 반복한다. 프로세싱 챔 버들은 프로세스 파라미터들을 규정하는 레시피에 기초하여 동작한다. 예를 들어, 레시피는 시퀀싱, 동작 온도 들, 압력들, 가스 화학 물질 (gas chemistry), 플라즈마 용법 (usage), 병렬 모듈들, 동작 또는 서브-동작 각각 에 대한 기간들, 기판 라우팅 경로, 및/또는 다른 파라미터들을 규정한다 (define). 기판들은 상이한 처리들을"}
{"patent_id": "10-2021-7035239", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 2, "content": "겪도록 (undergo) 2 개 이상의 프로세싱 챔버들 사이에서 특정한 시퀀스로 이송될 수도 있다.발명의 내용 관련 출원들에 대한 교차 참조 본 개시는 2019 년 3 월 29 일에 출원된 미국 특허 출원 제 62/826,185 호의 PCT 국제 출원이다. 상기 참조된 출원의 전체 개시는 참조로서 본 명세서에 인용된다. 레시피에 따라 반도체 기판들을 프로세싱하도록 구성된 복수의 프로세싱 챔버들을 포함하는 툴에서 반도체 기판 들을 프로세싱하기 위한 시스템은 프로세서 및 프로세서에 의한 실행을 위한 인스트럭션들을 저장하는 메모리를 포함한다. 인스트럭션들은 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판들의 프로세싱에 관한 제 1 데이터를 툴로부터 수신하고, 툴 및 레시피의 구성에 관한 제 2 데이터를 수신하도록 구성된다. 인스트럭션들 은 제 2 데이터를 사용하여, 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판들을 프로세싱하기 위한 복 수의 프로세싱 시나리오들에 대한 복수의 프로세싱 시나리오들 및 스케줄링 파라미터들을 시뮬레이팅하도록 구 성된다. 인스트럭션들은 복수의 프로세싱 시나리오들 및 복수의 프로세싱 시나리오들에 대한 스케줄링 파라미 터들을 사용하여 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판들의 프로세싱을 시뮬레이팅하도록 구 성된다. 인스트럭션들은 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판들을 프로세싱하기 위한 최적 의 스케줄링 파라미터들을 예측하도록 시뮬레이션에 의해 생성된 데이터 및 제 1 데이터를 사용하여 모델을 트 레이닝하도록 구성된다. 인스트럭션들은 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판들 중 하나의 프로세싱에 관한 입력들을 툴로부터 수신하도록 구성된다. 인스트럭션들은 모델을 사용하여, 레시피에 따라 복 수의 프로세싱 챔버들 내의 반도체 기판들 중 하나를 프로세싱하기 위한 최적의 스케줄링 파라미터들을 입력들 에 기초하여 예측하도록 구성된다. 인스트럭션들은 레시피에 따라 복수의 프로세싱 챔버들 내의 반도체 기판들 중 하나를 프로세싱하기 위한 최적의 스케줄링 파라미터들에 기초하여 툴의 동작들을 스케줄링하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판들 중 하나를 프로세 싱하기 위한 최적의 스케줄링 파라미터들에 기초하여 툴의 동작들을 실행하도록 구성된다. 다른 특징들에서, 최적의 스케줄링 파라미터들은 레시피에 따라 복수의 프로세싱 챔버들에서 프로세싱 동안 반 도체 기판들 중 하나에 대한 유휴 시간들을 최소화하고, 최적의 스케줄링 파라미터들은 툴의 처리량을 최대화한 다. 또 다른 특징에서, 인스트럭션들은 인공 신경망을 포함하는 머신 러닝 방법을 사용하여 모델을 트레이닝하고 벡 터 회귀를 지원하도록 구성된다. 다른 특징들에서, 인스트럭션들은 툴로부터 수신된 제 1 데이터 및 시뮬레이션에 의해 생성된 데이터를 분석하 고; 분석에 기초하여, 예방적 유지 보수 동작들 (preventive maintenance operations), 웨이퍼-리스 자동 세정 (wafer-less auto clean) 시간들, 대기 시간들, 레시피 시간들, 및 툴에 대한 처리량에 관한 패턴들을 검출하고; 그리고 검출된 패턴들에 기초하여 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 복수의 프로세싱 시나리오들 중 하나에 대한 최적의 스케줄링 파라미터들을 예측하기 위해 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 복수의 프로세싱 시나리오들 모두에 대한 최적의 스케줄링 파라미터들을 예 측하기 위해 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 반도체 기판들 중 일 반도체 기판 상에서 에칭 동작들만을 수행하기 위해 모 델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 반도체 기판들 중 일 반도체 기판 상에서 에칭 동작 및 스트립핑 동작 모두 를 수행하기 위해 모델을 트레이닝하도록 구성된다. 다른 특징들에서, 모델은 툴로부터 원격으로 구현되고, 인스트럭션들은 복수의 툴들로부터 수신된 데이터에 기 초하여 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 구성들 및 동작들에서 툴-투-툴 (tool-to-tool) 변동들에 대해 모델을 조정 하도록 구성된다. 다른 특징들에서, 모델은 SaaS (software-as-a-Service) 로서 클라우드에서 구현되고, 툴은 네트워크를 통해 모 델에 액세스하도록 구성된다.다른 특징들에서, 인스트럭션들은 제 2 툴의 데이터에 기초하여 제 2 모델을 트레이닝하도록 구성되고, 모델 및 제 2 모델은 툴 및 제 2 툴로부터 원격으로 구현된다. 툴 및 제 2 툴은 하나 이상의 네트워크들을 통해 모델 및 제 2 모델에 액세스하도록 각각 구성된다. 또 다른 특징에서, 인스트럭션들은 툴 및 제 2 툴로 하여금 툴 및 제 2 툴의 구성들에 기초하여 모델 및 제 2 모델을 각각 선택하게 하도록 구성된다. 다른 특징들에서, 모델은 툴 상에서 구현되고, 인스트럭션들은 모델을 사용하여, 툴에 의해 생성된 데이터를 사 용하여 레시피에 따라 복수의 프로세싱 챔버들 내 반도체 기판들 중 하나를 프로세싱하기 위한 최적의 스케줄링 파라미터들을 예측하도록 구성된다. 다른 특징들에서, 모델은 툴 상에서 구현되고, 인스트럭션들은 툴의 성능의 임의의 드리프트에 대해 모델을 조 정하도록 구성된다. 또 다른 특징에서, 툴로부터 수신된 제 1 데이터는 툴 상에서 수행된 예방적 유지 보수 동작들로부터의 데이터 및 툴에 대한 레시피 시간들 및 웨이퍼-리스 자동 세정 시간들에 관한 데이터를 포함한다. 또 다른 특징에서, 시뮬레이션에 의해 생성된 데이터는 툴의 구성, 웨이퍼-플로우 타입들, 실행 시나리오들, 레 시피 시간들, 및 툴로부터 획득된 웨이퍼-리스 자동 세정 시간들에 기초하여 생성된 데이터를 포함한다. 또 다른 특징에서, 툴로부터 수신된 입력들은 툴에 대한 다수의 예방적 유지 보수 동작들, 레시피 시간들, 및 웨이퍼-리스 자동 세정 시간들에 관한 데이터를 포함한다. 또 다른 특징에서, 인스트럭션들은 하나 이상의 스킵된 예방적 유지 보수 동작들을 고려함으로써 최적의 스케줄 링 파라미터들을 예측하도록 구성된다. 다른 특징들에서, 인스트럭션들은 모델을 사용하여, 레시피에 따라 복수의 프로세싱 챔버들 내에서 반도체 기판 들 중 하나를 프로세싱하기 위한 복수의 동작들을 스케줄링하도록 구성된다. 툴은 복수의 동작들을 각각 수행 하는 것에 응답하여 복수의 상태들을 통해 진행한다. 툴의 상태는 툴의 리소스들의 지표들 및 반도체 기판 중 하나의 프로세싱 상태를 포함한다. 인스트럭션들은 복수의 상태들 각각에 대해, 복수의 상태들의 현재 상태 및 복수의 상태들의 다음 상태로 진행하기 위한 복수의 스케줄링 가능한 동작들을 모델로 전송하고, 모델로부터 다 음 상태로 진행하도록 현재 상태에 기초하여 모델에 의해 선택된 복수의 스케줄링 가능한 동작들로부터 최상의 동작을 수신하도록 구성되고, 그리고 다음 상태로의 진행을 시뮬레이팅하기 위해 최상의 동작의 실행을 시뮬레 이팅하도록 구성된다. 인스트럭션들은 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판들을 프로세싱할 때 복수의 상태들을 통해 진행하는 툴에 응답하여 복수의 동작들로서 최상의 동작들을 추천하게 모델을 트레이 닝하도록 구성된다. 또 다른 특징들에서, 레시피에 따라 반도체 기판들을 프로세싱하도록 구성된 복수의 프로세싱 챔버들을 포함하 는 툴에서 반도체 기판들을 프로세싱하기 위한 시스템은 프로세서 및 프로세서에 의한 실행을 위한 인스트럭션 들을 저장하는 메모리를 포함한다. 인스트럭션들은 모델을 사용하여, 레시피에 따라 복수의 프로세싱 챔버들에 서 반도체 기판을 프로세싱하기 위한 복수의 동작들을 스케줄링하도록 구성된다. 툴은 복수의 동작들을 각각 수행하는 것에 응답하여 복수의 상태들을 통해 진행한다. 툴의 상태는 툴의 리소스들의 지표들 및 반도체 기판 의 프로세싱 상태를 포함한다. 인스트럭션들은 복수의 상태들 각각에 대해, 복수의 상태들의 현재 상태 및 복 수의 상태들의 다음 상태로 진행하기 위한 복수의 스케줄링 가능한 동작들을 모델로 전송하고, 모델로부터 다음 상태로 진행하도록 현재 상태에 기초하여 모델에 의해 선택된 복수의 스케줄링 가능한 동작들로부터 최상의 동 작을 수신하도록 구성되고, 그리고 다음 상태로의 진행을 시뮬레이팅하기 위해 최상의 동작의 실행을 시뮬레이 팅하도록 구성된다. 인스트럭션들은 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판을 프로세싱할 때 복수의 상태들을 통해 진행하는 툴에 응답하여 복수의 동작들로서 최상의 동작들을 추천하게 모델을 트레이닝하 도록 구성된다. 다른 특징들에서, 인스트럭션들은 툴로부터 수신된 반도체 기판들의 프로세싱에 관한 이력 데이터를 사용하고, 툴에 대한 복수의 프로세싱 시나리오들을 시뮬레이팅함으로써, 모델을 트레이닝하도록 구성되어, 레시피에 따른 복수의 프로세싱 챔버들에서 반도체 기판을 프로세싱하기 위한 최적의 스케줄링 파라미터들을 예측한다. 인스 트럭션들은 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판의 프로세싱에 관한 입력들을 툴로부터 수신 하도록 구성된다. 인스트럭션들은 모델을 사용하여, 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판을 프로세싱하기 위한 최적의 스케줄링 파라미터들을 입력들에 기초하여 예측하도록 구성된다. 인스트럭션들은 최적의 스케줄링 파라미터들에 기초하여, 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판을 프로세싱하기 위한 복수의 동작들을 스케줄링하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판을 프로세싱하기 위 한 최적의 스케줄링 파라미터들에 기초하여 복수의 동작들을 실행하도록 구성된다. 다른 특징들에서, 최적의 스케줄링 파라미터들은 레시피에 따라 복수의 프로세싱 챔버들에서 프로세싱 동안 반 도체 기판에 대한 유휴 시간들을 최소화하고, 최적의 스케줄링 파라미터들은 툴의 처리량을 최대화한다. 또 다른 특징에서, 인스트럭션들은 인공 신경망을 포함하는 머신 러닝 방법을 사용하여 모델을 트레이닝하고 벡 터 회귀를 지원하도록 구성된다. 다른 특징들에서, 인스트럭션들은 툴로부터 수신된 이력 데이터 및 툴에 대한 복수의 프로세싱 시나리오들을 시 뮬레이팅함으로써 생성된 데이터를 분석하도록 구성되고; 분석에 기초하여, 예방적 유지 보수 동작들, 웨이퍼- 리스 자동 세정 시간들, 대기 시간들, 레시피 시간들, 및 툴에 대한 처리량에 관한 패턴들을 검출하고; 그리고 검출된 패턴들에 기초하여 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 복수의 프로세싱 시나리오들 중 하나에 대한 최적의 스케줄링 파라미터들을 예측하기 위해 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 복수의 프로세싱 시나리오들 모두에 대한 최적의 스케줄링 파라미터들을 예 측하기 위해 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 반도체 기판들 상에서 에칭 동작들만을 수행하기 위해 모델을 트레이닝하도 록 구성된다. 또 다른 특징에서, 인스트럭션들은 반도체 기판들 중 일 반도체 기판 상에서 에칭 동작 및 스트립핑 동작 모두 를 수행하기 위해 모델을 트레이닝하도록 구성된다. 다른 특징들에서, 모델은 툴로부터 원격으로 구현되고, 인스트럭션들은 복수의 툴들로부터 수신된 데이터에 기 초하여 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 구성들 및 동작들에서 툴-투-툴 (tool-to-tool) 변동들에 대해 모델을 조정 하도록 구성된다. 다른 특징들에서, 모델은 SaaS (software-as-a-Service) 로서 클라우드에서 구현되고, 툴은 네트워크를 통해 모 델에 액세스하도록 구성된다. 다른 특징들에서, 모델은 툴 상에서 구현되고, 인스트럭션들은 모델을 사용하여, 툴에 의해 생성된 데이터를 사 용하여 레시피에 따라 복수의 프로세싱 챔버들에서 반도체 기판을 프로세싱하기 위한 최적의 스케줄링 파라미터 들을 예측하도록 구성된다. 다른 특징들에서, 모델은 툴 상에서 구현되고, 인스트럭션들은 툴의 성능의 임의의 드리프트에 대해 모델을 조 정하도록 구성된다. 또 다른 특징에서, 툴로부터 수신된 데이터는 툴에 대해 수행된 예방적 유지 보수 동작들로부터의 데이터 및 툴 에 대한 레시피 시간들 및 웨이퍼-리스 자동 세정 시간들에 관한 데이터를 포함한다. 또 다른 특징에서, 복수의 프로세싱 시나리오들을 시뮬레이팅함으로써 생성된 데이터는 툴의 구성, 웨이퍼-플로 우 타입들, 실행 시나리오들, 레시피 시간들, 및 툴로부터 획득된 웨이퍼-리스 자동 세정 시간들에 기초하여 생 성된 데이터를 포함한다. 또 다른 특징에서, 툴로부터 수신된 입력들은 툴에 대한 다수의 예방적 유지 보수 동작들, 레시피 시간들, 및 웨이퍼-리스 자동 세정 시간들에 관한 데이터를 포함한다. 또 다른 특징에서, 인스트럭션들은 하나 이상의 스킵된 예방적 유지 보수 동작들을 고려함으로써 최적의 스케줄 링 파라미터들을 예측하도록 구성된다. 또 다른 특징들에서, 반도체 기판들을 프로세싱하기 위한 툴은 제 1 로봇, 복수의 프로세싱 챔버들, 제 2 로봇, 및 제어기를 포함한다. 제 1 로봇은 툴 내의 반도체 기판들을 프로세싱하기 위해 툴 내로 반도체 기판들을 입 력하도록 구성된다. 복수의 프로세싱 챔버들은 레시피에 따라 툴 내에서 반도체 기판들을 프로세싱하도록 구성된다. 제 2 로봇은 레시피에 따라 복수의 프로세싱 챔버들 사이에서 반도체 기판들을 이송하도록 구성된다. 제어기는 툴 및 레시피를 시뮬레이팅함으로써 트레이닝된 모델을 사용하여, 복수의 프로세싱 챔버들에서 반도체 기판들을 프로세싱하기 위한 프로세싱 시간들; 복수의 프로세싱 챔버들 사이에서 반도체 기판들을 이송하기 위 한 제 2 로봇에 대한 이송 시간들; 프로세싱 시간들 및 이송 시간들에 기초하여 복수의 프로세싱 챔버들 사이에 서 반도체 기판들을 이송하기 위한 루트; 및 제 1 로봇이 프로세싱 시간들 및 이송 시간들에 기초하여 툴 내의 프로세싱을 위해 부가적인 반도체 기판들을 스케줄링하는 시간을 예측하도록 구성된다. 예측된 루트에 따라 반 도체 기판들을 프로세싱하고 예측된 시간에 따라 부가적인 반도체 기판들을 프로세싱하는 것은 예측된 루트를 따라 반도체 기판들에 대한 대기 시간들을 최적화하고 툴의 처리량을 최적화한다. 또 다른 특징에서, 제어기는 툴 내의 반도체 기판들 및 부가적인 반도체 기판들의 프로세싱 동안 생성된 데이터 에 기초하여 모델을 점진적으로 추가로 트레이닝하도록 구성된다. 또 다른 특징에서, 제어기는 추가로 트레이닝된 모델을 사용하여, 툴 내에서 부가적인 반도체 기판들을 프로세 싱하기 위한 제 2 프로세싱 시간들, 제 2 이송 시간들, 및 제 2 루트; 및 툴에서의 프로세싱을 위해 반도체 기 판들의 다음 세트를 스케줄링하기 위한 제 2 시간을 예측하도록 구성된다. 제 2 루트에 따라 부가적인 반도체 기판들을 프로세싱하고 제 2 시간에 따라 반도체 기판들의 다음 세트를 프로세싱하는 것은 부가적인 반도체 기 판들에 대한 대기 시간들 및 툴의 처리량을 더 최적화한다. 또 다른 특징에서, 제어기는 레시피, 툴, 또는 모두에 대한 임의의 변화들에 응답하여 모델을 조정하도록 구성 된다. 또 다른 특징에서, 모델은 복수의 프로세싱 챔버들 각각에 대한 프로세싱 시간들을 예측하도록 구성된 제 1 복 수의 신경망들; 제 1 로봇 및 제 2 로봇 각각에 대한 이송 시간을 예측하도록 구성된 제 2 복수의 신경망들; 및 제 1 복수의 신경망들 및 제 2 복수의 신경망들에 커플링되고 그리고 복수의 프로세싱 챔버들 사이에서 반도체 기판들을 이송하기 위한 루트를 예측하고 그리고 제 1 로봇이 툴에서 프로세싱을 위해 부가적인 반도체 기판들 을 스케줄링하는 시간을 예측하도록 구성된 제 3 신경망을 포함한다. 또 다른 특징에서, 모델은 복수의 툴들 및 복수의 레시피들의 구성들을 시뮬레이팅함으로써 추가로 트레이닝된 다. 또 다른 특징에서, 추가로 트레이닝된 모델은 입력으로서 레시피 정보를 수신하는 것에 응답하여 툴 구성에 대 한 추천을 출력하도록 구성된다. 다른 특징들에서, 레시피는 반도체 기판들 상에 복수의 층들을 증착하기 위한 것이다. 복수의 프로세싱 챔버들 은 복수의 층들을 증착하기 위한 하나 이상의 프로세싱 챔버들, 및 복수의 층들을 증착하기 전 및 후에 반도체 기판들을 각각 프로세싱하기 위한 사전-프로세싱 챔버 및 사후-프로세싱 챔버를 포함한다. 제 2 로봇은 반도체 기판들에 대한 대기 시간들을 최적화하기 위해 예측된 루트에 따라 복수의 프로세싱 챔버들 사이에서 반도체 기 판들을 이송하도록 구성된다. 제 1 로봇은 툴의 처리량을 최적화하기 위해 예측된 시간에 따라 툴 내 프로세싱 을 위해 부가적인 반도체 기판들을 스케줄링하도록 구성된다. 또 다른 특징들에서, 반도체 프로세싱 툴에서 반도체 기판들을 프로세싱하는 동안 처리량 및 대기 시간들을 최 적화하기 위한 시스템은 프로세서 및 프로세서에 의한 실행을 위한 인스트럭션들을 저장하는 메모리를 포함한다. 인스트럭션들은 반도체 프로세싱 툴의 구성 및 반도체 프로세싱 툴의 반도체 기판들 상에서 수행될 레시피에 기초하여, 반도체 프로세싱 툴의 복수의 프로세싱 챔버들 사이에서 반도체 기판들을 라우팅하기 위한 복수의 루트들을 시뮬레이팅하도록 구성된다. 인스트럭션들은 복수의 루트들을 따라 레시피에 따라 반도체 프 로세싱 툴의 반도체 기판들의 프로세싱을 시뮬레이팅하도록 구성된다. 인스트럭션들은 반도체 기판들의 프로세 싱에 기초하여, 반도체 프로세싱 툴에서 부가적인 반도체 기판들을 후속적으로 프로세싱하기 위한 복수의 타이 밍 스케줄들을 시뮬레이팅하도록 구성된다. 인스트럭션들은 복수의 타이밍 스케줄들에 따라 부가적인 반도체 기판들의 프로세싱을 시뮬레이팅하도록 구성된다. 인스트럭션들은 시뮬레이션들에 의해 생성된 데이터에 기초 하여 모델을 트레이닝하도록 구성된다. 인스트럭션들은 반도체 프로세싱 툴 상의 모델을 사용하여, 레시피에 따라 반도체 프로세싱 툴 내에서 반도체 기판들을 프로세싱할 때 복수의 프로세싱 챔버들 사이에서 반도체 기판 들을 이송하기 위한 최적의 루트를 예측하도록 구성된다. 인스트럭션들은 반도체 프로세싱 툴 상의 모델을 사 용하여, 반도체 프로세싱 툴에서의 프로세싱을 위해 부가적인 반도체 기판들을 스케줄링하기 위한 최적의 시간 을 예측하도록 구성된다. 인스트럭션들은 반도체 프로세싱 툴에서, 최적의 루트를 따라 반도체 기판들에 대한 대기 시간들을 최적화하기 위해 최적의 루트에 따라 반도체 기판들을 프로세싱하도록 구성된다. 인스트럭션들은 반도체 프로세싱 툴에서, 반도체 프로세싱 툴의 처리량을 최적화하기 위해 최적의 시간에 부가적인 반도체 기판들을 프로세싱하도록 구성된다. 다른 특징들에서, 인스트럭션들은 복수의 프로세싱 챔버들에서 반도체 기판들을 프로세싱하기 위한 프로세싱 시 간들; 반도체 기판들을 복수의 프로세싱 챔버들 사이에서 이송하기 위한 반도체 프로세싱 툴의 로봇에 대한 이 송 시간들; 프로세싱 시간들 및 이송 시간들에 기초하여 복수의 프로세싱 챔버들 사이에서 반도체 기판들을 라 우팅하기 위한 최적의 루트; 및 프로세싱 시간들 및 이송 시간들에 기초하여 반도체 프로세싱 툴에서의 프로세 싱을 위해 부가적인 반도체 기판들을 스케줄링하기 위한 최적의 시간을 예측하게 시뮬레이션들에 의해 생성된 데이터에 기초하여 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 반도체 프로세싱 툴 내에서 반도체 기판들 및 부가적인 반도체 기판들의 프 로세싱 동안 생성된 데이터에 기초하여 모델을 점진적으로 추가 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 레시피, 반도체 프로세싱 툴, 또는 모두에 대한 임의의 변화들에 대해 모델 을 조정하도록 구성된다. 다른 특징들에서, 인스트럭션들은 시뮬레이션들에 의해 생성된 데이터에 기초하여 모델을 생성하도록 구성되고, 모델은 복수의 프로세싱 챔버들 각각에서 반도체 기판들을 프로세싱하기 위한 프로세싱 시간들을 예측하도록 구 성된 제 1 복수의 신경망들을 포함한다. 모델은 제 1 로봇 및 제 2 로봇에 대한 이송 시간들을 각각 예측하도 록 구성된 제 2 복수의 신경망들을 포함한다. 제 1 로봇 및 제 2 로봇은 반도체 기판들을 반도체 프로세싱 툴 내로 그리고 복수의 프로세싱 챔버들 사이에서 이송하도록 각각 구성된다. 모델은 제 1 복수의 신경망들 및 제 2 복수의 신경망들에 커플링되고 복수의 프로세싱 챔버들 사이에서 반도체 기판들을 라우팅하기 위한 최적의 루 트를 예측하고 반도체 프로세싱 툴에서 프로세싱을 위해 부가적인 반도체 기판들을 스케줄링하기 위한 최적의 시간을 예측하도록 구성된 제 3 신경망을 포함한다. 또 다른 특징에서, 인스트럭션들은 복수의 반도체 프로세싱 툴들 및 복수의 레시피들의 구성들을 시뮬레이팅함 으로써 모델을 트레이닝하도록 구성된다. 또 다른 특징에서, 인스트럭션들은 입력으로서 레시피 정보를 수신하는 것에 응답하여 툴 구성에 대한 추천을 출력하게 모델을 트레이닝하도록 구성된다. 상기 및 이하에 기술된 임의의 특징들은 개별적으로 (즉, 및 이하에 기술된 다른 특징들과 독립적으로) 구현될 수 있다. 상기 및 이하에 기술된 임의의 특징들은 일부 구현 예들에서 상기 및 이하에 기술된 다른 특징들과 결합될 수 있다. 본 개시의 추가 적용 가능 영역들은 상세한 기술, 청구항들 및 도면들로부터 자명해질 것이다. 상세한 설명 및 구체적인 예들은 단지 예시를 목적으로 의도되고 본 개시의 범위를 제한하도록 의도되지 않는다."}
{"patent_id": "10-2021-7035239", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "통상적으로, 기판 프로세싱 툴들 (이하 \"툴들\") 의 오퍼레이터들은 과거 경험, 실험들에 기초하여 또는 시행 착 오 접근법을 사용함으로써 스케줄링 파라미터 값들을 수동으로 선택한다. 이는 스케줄링 파라미터 값들을 선택 하기 위한 간단한 가이드라인들이 쉽게 확립될 수 없기 때문이다. 툴 (예를 들어, 에칭 툴) 에 대한 상이한 기 판 프로세싱 시나리오들은 툴에 대한 최적의 (optimum) 처리량을 달성하기 위해 상이한 세트들의 스케줄링 파라 미터 값들을 필요로할 수도 있기 때문에, 오퍼레이터는 툴 상에서 웨이퍼-플로우 실행 (run) 각각을 개시하기 전에 툴을 제어하는 시스템 소프트웨어에 스케줄링 파라미터 값들을 수동으로 입력해야 할 수도 있다. 일부 툴들에서, 시스템 소프트웨어의 스케줄러는 스케줄링 결정들을 내리기 위해 스케줄링 규칙들 및 스코어링 시스템의 세트를 사용할 수도 있다. 그러나, 시스템 구성, 실행 시나리오들, 및 툴의 스케줄링 제약들의 복잡 성이 증가함에 따라, 스케줄링 결정 스킴의 복잡성도 증가하고, 이는 결국 최적의 시스템 처리량을 달성하고 유 지하기 위해 보다 많은 개발 노력을 필요로 한다. 또한, 웨이퍼 대기 시간들에 대한 제한들을 갖는 복수의 병렬 재료 증착 프로세스들에 사용되는 배치 (batch) (복수의 기판들) 프로세싱 툴들에서, 최상의 처리량 및 최소 웨이퍼 대기 시간을 달성하기 위해 툴의 스케줄러 를 페이싱하는 (pacing) 것은 매우 어려울 수 있다. 스케줄러 규칙은 매우 동적이고, 부정확한 페이싱 계산들 은 웨이퍼 건조 (dry out) 로 인한 비정상적인 웨이퍼들 또는 처리량의 하락을 발생시킬 수 있고, 이는 툴에 대 한 소유 비용 (cost-of-ownership) 을 증가시킨다. 이에 더하여, 상이한 고객 애플리케이션들은 페이싱 예측을 보다 복잡하게 한다. 예를 들어, 긴 프로세스 시간 레시피 (예를 들어, 메가-필라 레시피) 는 프로세스 모듈을 병목 (bottle neck) 으로 만들고, 짧은 프로세스 시간 레시피 (예를 들어, 재분배 층 또는 RDL (redistribution layer) 레시피) 는 (배치/복수의 기판들을 함께 핸들링하기 위한 수 개의 암들을 갖는) 백 엔 드 로봇 (back end robot) 을 병목으로 만든다. 본 개시는 트레이닝된 모델을 사용함으로써 그리고 또한 다음과 같이 강화된 (reinforced) 학습을 사용함으로써 이들 문제들을 해결한다. 에칭 툴들에 대해, 신경망 모델 (이하 \"모델\") 은 최적의 스케줄링 파라미터 값들을 예측하도록 트레이닝된다. 모델은 모델에 대한 입력들로서 PM들 (preventive maintenance operations), 레시 피 시간들 및 WAC (wafer-less auto clean) 시간들로부터 수집된 데이터를 사용하여 트레이닝된다. 모델은 스 케줄링 파라미터 값들과 다양한 웨이퍼 프로세싱 시나리오들 사이의 기본적인 관계들을 캡처하여 이에 따라 예 측들을 하도록 사용되고, 이는 최상의 값 (best value) 선택을 위한 가이드라인들을 확립할 필요성을 제거한다. 트레이닝 전에, 모델에 의해 예측될 중요한 스케줄링 파라미터들의 세트가 식별된다. 반도체 제조업체들에서 사용되는 툴들로부터 많은 양의 트레이닝 데이터가 수집된다. 툴들을 사용하여 반도체 제조사들에 의해 사용된 다양한 프로세싱 시나리오들을 커버하기 위해 시뮬레이션들을 사용하여 부가적인 트레이닝 데이터가 생성된다. 최상의 신경망 구조는 스케줄링 파라미터 공간에 걸쳐 균일한 예측 정확도를 제공할 수 있는 모델을 지원하도록 결정된다. 웨이퍼 프로세싱 시나리오를 위한 전용 모델이 사용될 수도 있지만, 다양한 프로세싱 시나리오들을 커버할 수 있는 단일 모델은 또한 다른 프로세싱 시나리오들로부터 수집된 데이터를 사용하여 시간에 걸쳐 모델 을 트레이닝함으로써 생성될 수 있다. 모델 유지 보수의 용이성을 위해, 모델은 툴의 시스템 소프트웨어 외부에서 실행될 수도 있다. 즉, 모델은 툴 의 시스템 소프트웨어 외부에 있을 수도 있고, 분리될 수도 있고, 통합되지 않을 수도 있다. 모델은 오퍼레이터에 의해 선택된 웨이퍼-플로우에 기초하여 시스템 소프트웨어로부터 입력 파라미터들을 수신할 수 있다. 그 러면 모델은 최상의 스케줄링 파라미터 값들을 계산하고 예측할 수 있고 이 값들을 시스템 소프트웨어로 다시 전송할 수 있다. 예를 들어, 장비 제조업체는 반도체 제조업체들이 가입할 수 있는 서비스형 소프트웨어 (software-as-a-service; SaaS) 로서 모델을 클라우드에서 전개할 (deploy) 수 있다. 대안적으로, 장비 제조 업체는 툴의 시스템 소프트웨어에 모델을 통합할 수 있다. 트레이닝된 모델을 사용하는 것은 시스템 소프트웨어에 구축된 스케줄러의 기본적인 거동 (underlying behavior) 이 신경망 모델로 캡처되게 하고, 이어서 사용될 최상의 스케줄링 파라미터 값들을 예측하도록 사용 될 수 있다. 오퍼레이터들은 최상의 스케줄링 파라미터 값들을 선택하기 위해 더 이상 광범위한 시뮬레이션 연 구들을 수행할 필요가 없다. 트레이닝된 모델을 사용하는 것은 또한 새로운 웨이퍼-플로우가 시작될 때 시스템 소프트웨어로 하여금 스케줄링 파라미터 값들을 자동으로 선택하게 한다. 부가적으로, 스케줄러의 스케줄링 규칙들 및 스코어링 시스템은 신경망 모델로 대체될 수 있다. 모델은 시스템 의 주어진 (given) 상태에 대한 최상의 스케줄링 결정들을 자기 탐색하고 (self-explore) 기억하도록 (memorize) 개별 이벤트 시뮬레이터 (discrete event simulator) 및 강화 학습 (reinforcement learning) 을 사용하여 트레이닝된다. 이는 시스템의 최적의 처리량 성능을 달성하고 유지하게 한다. 자기-탐색 프로세스는 최적의 처리량 성능으로 시스템을 동작시키기 위한 최상의 가능한 방법을 찾는 (예를 들 어, 툴을 통해 웨이퍼를 이동시키기 위한 최상의 경로를 찾는) 노력들을 자동화하기 위해 개별 이벤트 시뮬레이 터를 사용한다. 툴 상에서 자가-트레이닝 (self-training) 프로세스를 실행함으로써, 신경망 모델은 특정한 툴 구성, 웨이퍼 프로세싱 시나리오, 및 툴에 고유한 제약들에 대해 최적화될 수 있다. 따라서, 본 개시는 스마트 머신-러닝 보조된 스케줄러를 제공한다. 스마트 스케줄러는 시스템의 주어진 상태에 대해 최상의 스케줄링 결정을 내리도록 신경망 모델을 트레이닝시키기 위해 자가 학습 (self-learning) 프로세 스를 사용한다. 결정들은 반도체 제조업체에 특정한 스케줄링 제약들 및 실행 시나리오들에 따라 최적의 처리 량 조건으로 툴을 달성하고 유지하는데 도움을 준다. 예를 들어, 스마트 스케줄러는 웨이퍼 유휴 시간이 총 프로세싱 시간의 2 ％ 미만일 수 있고 제작 효율 (실제/ 이론적 사이클 시간) 이 레시피 각각에 대해 97 ％보다 클 수 있다는 것을 보장할 수 있다. 부가적으로, 스마 트 스케줄러는 시간에 따라 발생할 수 있는 동일한 툴 내에서 성능 드리프트뿐만 아니라 툴-투-툴 (tool-to- tool) 변동을 보상할 수 있다. 또한, 스마트 스케줄러는 제조 데드 라인들을 지키기 위해 스킵되거나 지연되어 야할 수도 있는 예방적 유지 보수를 고려함으로써 스케줄링 파라미터 값들을 최적화할 수 있다. 스마트 스케줄 러의 이들 및 다른 특징들은 이하에 상세히 기술된다. 또한, 이하에 설명된 바와 같이, 복수의 병렬 재료 증착 (예를 들어, 다층 도금) 프로세스들을 위한 툴들에서 사용된 스케줄러 페이싱의 정확도를 개선하기 위해, 본 개시는 상이한 프로세스들에 대해 스케줄러 페이싱을 정 확하게 예측하기 위한 내포된 신경망들 (nested neural networks) 에 기초한 머신 러닝 방법을 제안한다. 이 방법을 사용하여, 모델이 개발되고 시뮬레이션을 사용하여 처음에 오프라인으로 트레이닝되고, 이어서 최고 (highest) 툴/플릿 (fleet) 활용도, 최단 대기 시간, 및 최고 (fastest) 처리량을 달성하도록 스케줄링하고 웨 이퍼 라우팅 경로를 예측하기 위해 실제 툴을 사용하여 온라인으로 트레이닝된다. 본 개시는 다음과 같이 구성된다. 툴의 일 예가 도 1을 참조하여 도시되고 기술된다. 프로세싱 챔버를 포함하 는 기판 프로세싱 시스템의 일 예가 도 2를 참조하여 도시되고 기술된다. 다양한 툴들로부터 데이터를 수집하 기 위한 데이터 수집 시스템의 일 예가 도 3을 참조하여 도시되고 기술된다. 머신-러닝 보조된 모델을 생성하 고 트레이닝하기 위한 시스템이 도 4를 참조하여 도시되고 기술된다. 머신-러닝 보조된 모델을 생성하고 트레 이닝하기 위한 방법이 도 5a 내지 도 8을 참조하여 도시되고 기술된다. 본 명세서에 기술된 모델들을 생성하기 위해 사용된 심층 신경망의 예는 도 9 내지 도 11을 참조하여 도시되고 기술된다. 개별 이벤트 시뮬레이터를 사용하여 강화 학습 모델을 트레이닝하기 위한 시스템이 도 12를 참조하여 도시되고 기술된다. 개별 이벤트 시 뮬레이터를 사용하여 강화 학습 모델을 트레이닝하기 위한 방법이 도 13을 참조하여 도시되고 기술된다. 툴들 에서 웨이퍼 프로세싱을 스케줄링하고 페이싱하기 위해 오프라인 시뮬레이터 및 온라인 실시간 툴 데이터를 사 용하여 내포된 신경망들을 사용하여 모델을 트레이닝하기 위한 시스템이 도 14를 참조하여 도시되고 기술된다. 툴들에서 웨이퍼 프로세싱을 스케줄링하고 페이싱하기 위해 오프라인 시뮬레이터 및 온라인 실시간 툴 데이터를 사용하여 중첩된 신경망들을 사용하여 모델을 트레이닝하기 위한 방법이 도 15a 및 도 15b를 참조하여 도시되고 기술된다. 복수의 프로세싱 모듈들 (예를 들어, 전기 도금 셀들) 을 포함하는 툴의 일 예가 도 16을 참조하여 도시되고 기술된다. 도 16의 툴의 프로세싱 모듈의 일 예가 도 17을 참조하여 도시되고 기술된다. 툴들에서웨이퍼 프로세싱을 스케줄링하고 페이싱하기 위한 모델을 트레이닝하기 위해 오프라인 시뮬레이터와 함께 사용 된 팹 (fab) 데이터 수집 시스템의 일 예가 도 18을 참조하여 도시되고 기술된다. 도 1은 기판 프로세싱 툴 의 일 예를 도시한다. 기판 프로세싱 툴 은 복수의 프로세싱 챔버들 (104-1, 104-2, …, 및 104-M) (집합적으로 프로세싱 챔버들 ) (여기서 M은 1보다 큰 정수임) 을 포함한 다. 단지 예를 들면, 프로세싱 챔버들 각각은 하나 이상의 타입들의 기판 처리를 수행하도록 구성될 수 도 있다. 즉, 기판들은 프로세싱 챔버들 중 하나 내로 로딩될 수도 있고, 프로세싱될 수도 있고, 이어서 (적어도 하나가 상이한 처리를 수행한다면) 프로세싱 챔버들 중 하나 이상의 다른 프로세싱 챔버로 이동 될 수도 있고 그리고/또는 (모두 동일한 처리를 수행한다면) 기판 프로세싱 툴 로부터 제거될 수도 있다. 프로세싱될 기판들은 ATV (atmospheric-to-vacuum) 이송 모듈 의 로딩 스테이션의 포트들을 통해 기판 프 로세싱 툴 내로 로딩된다. 일부 예들에서, ATV 이송 모듈 은 EFEM (equipment front end module) 을 포함한다. 이어서 기판들은 프로세싱 챔버들 중 하나 이상으로 이송된다. 예를 들어, 이송 로봇 은 로딩 스테이션들 로부터 에어 록들, 또는 로드 록들 로 기판들을 이송하도록 구성되고, 진공 이송 모듈 의 진공 이송 로봇 은 기판들을 로드 록들 로부터 다양한 기판 프로세싱 챔 버들 로 이송하도록 구성된다. 프로세싱 챔버 제어기들 , 이송 제어기 및/또는 시스템 제어기 가 제공될 수도 있다. 이송 제어기 는 기판 프로세싱 툴 로 그리고 기판 프로세싱 툴 로부터 기판들의 이송과 관련된 액 추에이터들 및 센서들을 제어한다. 프로세싱 챔버 제어기들 은 프로세싱 챔버들 의 동작을 제어한 다. 일반적으로, 프로세싱 챔버 제어기들 은 온도 센서들, 압력 센서들, 위치 센서들, 등과 같은 센서들 및 로봇들, 포트들, 히터들, 가스 전달 시스템들, ESC, RF 생성기들, 등과 같은 제어 액추에이터들 을 모니터링한다. 프로세싱 챔버들 과 연관된 프로세싱 챔버 제어기들 은 일반적으로 단계들의 타 이밍, 공급될 프로세스 가스들, 온도, 압력, RF 전력, 등을 특정하는 레시피를 따른다. 도 2는 프로세싱 챔버의 동작 동안 생성되는 데이터 타입들의 예들을 예시하기 위해 기판을 처리하기 위한 기판 프로세싱 시스템 의 일 예를 도시한다. 특정한 타입의 프로세싱 챔버가 도시되지만, 다른 타입들의 프로 세싱 챔버들이 사용될 수도 있다. 기판 프로세싱 시스템 은 기판 프로세싱 시스템 의 다른 컴포넌 트들을 둘러싸고 RF 플라즈마를 담는 프로세싱 챔버 를 포함한다. 기판 프로세싱 시스템 은 상부 전극 및 ESC (electrostatic chuck) 와 같은 기판 지지부를 포함한다. 동작 동안, 기판 이 ESC 상에 배치된다. 단지 예를 들면, 상부 전극 은 증착 전구체들, 에칭 가스들, 캐리어 가스들, 등과 같은 프로세스 가스들 을 도입하고 분배하는 샤워헤드 를 포함할 수도 있다. ESC 는 하부 전극으로서 작용하는 도전성 베이스 플레이트 를 포함한다. 베이스 플레이트 는 세라믹 멀티-존 가열 플레이트에 대응할 수도 있는 가열 플레이트 를 지지한다. 내열층 이 가열 플레이트 와 베이스 플레이트 사이 에 배치될 수도 있다. 베이스 플레이트 는 베이스 플레이트 를 통해 냉각제를 흘리기 위한 하나 이상의 채널들 을 포함할 수도 있다. RF 생성 시스템 은 RF 전압을 생성하고 상부 전극 및 하부 전극 (예를 들어, ESC 의 베이스 플레이트 ) 중 하나로 출력한다. 상부 전극 및 베이스 플레이트 중 다른 하나는 DC 접지되거 나, AC 접지되거나 플로팅할 수도 있다. 단지 예를 들면, RF 생성 시스템 은 매칭 및 분배 네트워크 에 의해 상부 전극 또는 베이스 플레이트 로 피딩되는 RF 전압을 생성하는 RF 전압 생성기 를 포함할 수도 있다. 다른 예들에서, 플라즈마는 유도적으로 또는 리모트 (remotely) 로 생성될 수도 있다. 가스 전달 시스템 은 하나 이상의 가스 소스들 (232-1, 232-2, …, 및 232-N) (집합적으로 가스 소스들 ) 을 포함하고, 여기서 N은 0보다 큰 정수이다. 가스 소스들 은 하나 이상의 증착 전구체들, 에칭 가스들, 캐리어 가스들, 등을 공급한다. 기화된 전구체가 또한 사용될 수도 있다. 가스 소스들 은 밸브 들 (234-1, 234-2, …, 및 234-N) (집합적으로 밸브들 ) 및 질량 유량 제어기들 (236-1, 236-2, …, 및 236-N) (집합적으로 질량 유량 제어기들 ) 에 의해 매니폴드 에 연결된다. 매니폴드 의 출력 은 프로세싱 챔버 로 피딩된다. 단지 예를 들면, 매니폴드 의 출력은 샤워헤드 로 피딩된다. OES (optical emission spectroscopy) 센서 는 챔버 표면 상에 배치된 윈도우 에 인접하게 배치될 수도 있다. OES 센서 는 OES 데이터를 선택적으로 생성한다. 온도 제어기 는 가열 플레이 트 내에 배치된 복수의 TCE들 (thermal control elements) 에 연결될 수도 있다. 예를 들어, TCE 들 은 이로 제한되는 것은 아니지만, 멀티-존 가열 플레이트의 존들 각각에 대응하는 매크로 가열 엘리먼 트들 및/또는 멀티-존 가열 플레이트의 복수의 존들에 걸쳐 배치된 마이크로 TCE들의 어레이를 포함할 수도 있 다. 온도 제어기 는 ESC 및 기판 의 온도를 제어하기 위해 복수의 TCE들 을 제어하 도록 사용될 수도 있다. 온도 제어기 는 채널들 을 통한 냉각제 플로우를 제어하도록 냉각제 어셈블리 와 연통할 수 도 있다. 예를 들어, 냉각제 어셈블리 는 냉각제 펌프 및 저장소를 포함할 수도 있다. 온도 제어기 는 ESC 를 냉각하도록 채널들 을 통해 냉각제를 선택적으로 흘리도록 냉각제 어셈블리 를 동작시킨다. 밸브 및 펌프 는 프로세싱 챔버 로부터 반응 물질들을 배기하도록 사용될 수도 있다. 시스 템 제어기 는 기판 프로세싱 시스템 의 컴포넌트들을 제어하도록 사용될 수도 있다. 로봇 이 ESC 상으로 기판들을 전달하고 ESC 로부터 기판들을 제거하도록 사용될 수도 있다. 예를 들어, 로봇 은 ESC 와 로드 록 사이에서 기판들을 이송할 수도 있다. 별도의 제어기들로 도시되지 만, 온도 제어기 는 제어기 내에 구현될 수도 있다. 상당한 양의 이산적인 데이터 및 스트리밍 데이터가 기판들의 프로세싱 및 이송 동안 기판 프로세싱 툴에 의해 생성된다. 이벤트 데이터는 다양한 컴포넌트들의 위치 및 체류 시간을 결정하도록 사용될 수 있다. 예를 들어, 모듈 또는 FOUP (front opening unified pod) 의 체류 시간은 기판들 사이에 프로세스 차이들을 유발할 수도 있다. 시스템 로그들은 시스템 레벨 데이터를 기록한다. 기판 이송 동안 부가적인 데이터가 기록된다. 프로세싱 챔버들 각각은 또한 기판들의 프로세싱 동안 데이터를 기록한다. 기록되는 데이터는 상이한 데이터 타입들, 샘플링 레이트들, 및/또는 포맷들을 포함한다. 데이터 중 일부는 프로세싱 챔버에만 국부적으로 저장 되는 한편, 다른 데이터는 팹 레벨로 저장된다. 데이터는 보통 고정된 주파수로 메시지 포맷으로 툴로부터 호스트로 스트리밍된다. 데이터는 일반적으로 기판 기반으로 전송되지 않는다. 오히려 데이터는 시간 기반으로 전송된다. 데이터는 통상적으로 고정된 빈도 또는 파일 크기를 기준으로 파일들에 수집된다. 데이터는 일반적으로 연속적으로 수집되고 경계가 없다. 일부 시스 템들에서, 데이터는 레시피 시작 및 레시피 종료 각각에서 최초 기판 및 최종 기판의 프로세싱 동안 수집되지만, 개재 기판들에 대해 수집되지 않는다. 이들 데이터로부터, 비 기밀 동작 데이터는 생산성 및 시스템 처리량을 개선하기 위해 최상의 스케줄링 파라미 터들을 제공할 수 있는 모델을 구축하고 트레이닝시키기 위해 빅 데이터 툴들 및/또는 머신 러닝을 사용하여 수 집되고 분석될 수 있다. 이에 더하여, 툴 구성 및 레시피 데이터에 기초하여, 추가적인 모델 트레이닝 데이터 가 시뮬레이션을 사용하여 생성될 수 있다. 반도체 제조업체는 상이한 포맷들을 갖는 상이한 파일들로부터의 데이터를 결합할 수 있다. 일부 예들에서, 고 객들의 툴들로부터 수집된 데이터는 암호화 및 순방향/역방향 호환성을 지원하는 공통 구조화된 파일 포맷일 수 있다. 일부 예들에서, 데이터 포맷은 TDMS (Technical Data Management Solution) 파일 포맷과 일치할 수 있 다. 일부 예들에서, 데이터 포맷은 액세스 가능할 수 있고 키 (예를 들어, 애플리케이션 프로토콜 인터페이스 (API) 키) 를 사용하여 고객에 의해 판독될 수 있다. 데이터 컨텍스트 및 수집은 수집된 데이터에 대해 정리, 재포맷팅 및/또는 다른 작업을 수행하지 않고 사용 및 분석을 허용하도록 상이한 데이터 타입들에 걸쳐 일관될 수 있다. 일부 예들에서, 데이터는 기판이 카세트를 떠나는 순간부터 기판이 카세트로 다시 돌아갈 때까지 수집될 수 있 다. 일부 예들에서, 데이터는 단일 파일에 저장될 수 있다. 일부 예들에서, 파일 포맷은 일관될 수 있다. 일 부 예들에서, 데이터는 데이터의 타입 및 맥락에 기초하여 상이한 빈도들로 수집될 수 있다. 일부 예들에서, 데이터는 암호화와 함께 TDMS를 사용하여 포맷팅될 수 있다. 일부 예들에서, 데이터 어댑터는 레거시 데이터 및 역 호환성을 지원하고, 새로운 데이터 타입들을 통합하고, 호스트 메시징 및 스트리밍 데이터를 지원하도록 사용될 수 있다. 도 3은 반도체 프로세싱 시스템을 위한 팹 데이터 수집 시스템 을 도시한다. 팹 데이터 수집 시스템 은 N 개의 기판 프로세싱 툴들 (320-1, 320-2, …, 및 320-T) (여기서 T는 정수임) (집합적으로 기판 프로세싱 툴들 ) 을 포함한다. 기판 프로세싱 툴들 각각은 상기 기술된 바와 같이 프로세싱 챔버의 동작을 제어하기 위해 하나 이상의 프로세싱 챔버 제어기들 (340-1, 340-2, …, 및 340-T) (집합적으로 프로세 싱 챔버 제어기들 ) 을 포함한다. 프로세싱 챔버들에 의해 수집된 데이터의 예들은 기판 또는 웨이퍼 데 이터 로그들, 자동 예방적 유지 보수, 고속 데이터, OES (optical emission spectroscopy), 트레이스 데이터, OES 스냅샷들, 페데스탈 온도 맵들 및 다른 데이터들, 캘리브레이션 (calibration) 파일들, 장비 상수들, 센서 데이터, 및/또는 다른 데이터를 포함한다. 기판 프로세싱 툴들 각각은 동적 정렬을 제어하고 캘리브레이션 파일들, 플랫폼 트레이스 데이터 로그들, 장비 상수들, 전송 모듈 활동, 및/또는 다른 데이터를 저장하기 위해 이송 제어기 (344-1, 344-2, …, 및 344- N) (집합적으로 이송 제어기들 ) 를 포함할 수도 있다. 동적 정렬은 페데스탈의 중심, 에지 링, 또는 다 른 객체와 같은 다른 챔버 컴포넌트들에 대한 기판의 위치를 참조한다. 기판 프로세싱 툴들 각각은 툴 시스템 제어기 (348-1, 348-2, …, 및 348-N) (집합적으로 툴 시스템 제 어기들 ) 를 각각 포함할 수도 있다. 툴 시스템 제어기들 은 로트 이력, 상세 이벤트 로그들, 로트 -기반 알람들, 시간-기반 알람들, 툴 제어기 상태, 부품 추적, 컴포넌트 이력, 재료 스케줄링, 및 다른 데이터 를 기록한다. 기판 프로세싱 툴들 각각은 데이터 진단 서비스 컴퓨터 (350-1, 350-2, …, 및 350-N) (집합적으로 데이 터 진단 서비스 컴퓨터들 ) 및 데이터 저장 디바이스들 (362-1, 362-2, …, 및 362-N) (집합적으로 데이터 저장 디바이스들 ) 을 각각 더 포함한다. 다른 예들에서, 데이터 진단 서비스 컴퓨터들 은 2 개 이 상의 툴들에 의해 공유될 수도 있고 또는 툴 각각은 2 개 이상의 데이터 진단 서비스들 컴퓨터 를 포함할 수도 있다. 기판 프로세싱 툴들 은 툴 데이터 버스 또는 네트워크 (364-1) 및 스트리밍 데이터 버스 또 는 네트워크 (364-2) 와 같은 하나 이상의 버스들에 의해 호스트 서버 에 연결된다. 일부 예들에서, 호스트 서버 는 보안 모듈 및 데이터 선택기 모듈 을 포함한다. 보안 모듈 은 암호화 또는 패스워드 보호와 같은 보안을 제공한다. 보안 모듈 은 기판 프로세싱 툴들 에 의해 저장된 데이터 및/또는 데이터 선택기 모듈 에 대한 액세스를 승인하거나 거부하기 위해 암호화 또는 패스워드들을 사용한다. 호스트 서버 는 사용자 컴퓨터 로 하여금 하나 이상의 기판 프로세 싱 툴들로부터 데이터의 하나 이상의 카테고리들을 선택하게 하고 데이터 컨텍스트 필드들 중 하나 이상을 사용 하여 데이터를 필터링하게 하는 데이터 선택기 모듈 을 더 포함한다. 다른 예들에서, 보안 모듈 및/또는 데이터 선택기 모듈 은 별도의 서버들을 사용하여 구현된다. 호스트 서버 는 WAN 또는 LAN과 같은 네트워크 에 의해 머신 러닝 컴퓨터 및/또는 하나 이상 의 사용자 컴퓨터들 에 연결된다. 호스트 서버 에 의해 리턴된 데이터 세트들은 추가 분석을 위해 머신 러닝 컴퓨터 에 액세스 가능하게 될 수 있다. 일부 예들에서, 머신 러닝 컴퓨터 는 데이터에 대한 액세스를 제어하기 위한 보안 모듈 을 포함한다. 머신 러닝 컴퓨터 는 사용자에 의해 선택된 데이터 수집 시스템 에 의해 생성된 하나 이상의 데이터 파일들을 사용하여 머신 러닝을 수행한다. 상이 한 기판 프로세싱 툴들로부터의 파일들의 포맷이 동일하기 때문에, 데이터는 단일 파일로 결합되고 분석될 수 있다. 이는 동일한 프로세스가 복수의 머신들에서 분석되게 한다. 기판 프로세싱 툴들 의 수 T는 제한되지 않는다. 부가적으로, 기판 프로세싱 툴들 은 동일한 설비 에 위치될 필요가 없다. 일부 예들에서, 장비 제조업체는 복수의 반도체 제조업체들에 의해 저장된 데이터에 대한 액세스를 승인받을 수 있다. 일부 예들에서, (스트리밍 또는 HSD 디바이스들 이외의) 데이터 생성 디바이 스들 중 일부 또는 전부의 샘플링 레이트들은 공통 샘플링 기간에 정렬될 수 있고 데이터는 샘플링 기간에 기초 하여 공통 파일에 추가된다. 도 4는 본 개시에 따른 머신-러닝 보조된 모델을 생성하고 트레이닝하기 위한 시스템 을 도시한다. 예를 들어, 시스템 은 머신 러닝 컴퓨터 (예를 들어, 도 3에 도시된 엘리먼트 ) 를 포함할 수 있다. 시 스템 은 데이터 수집기 , 시뮬레이터 , 데이터 분석기 , 및 모델 생성기 를 포함한 다. 데이터 수집기 는 신경망 모델을 생성하고 트레이닝하기 위한 하나 이상의 툴들로부터 데이터를 수 집한다. 시뮬레이터 는 하드웨어 구성, 웨이퍼-플로우 타입들, 실행 시나리오들, 레시피 시간들, 및 툴 (들)로부터 획득된 WAC (wafer-less auto clean) 시간들에 기초하여 추가적인 트레이닝 데이터를 생성한다. 데이터 분석기 는 빅 데이터를 분석하기 위해 사용된 기법들을 사용하여 데이터 수집기 에 의해 수 집된 데이터 및 시뮬레이터 에 의해 생성된 데이터를 분석한다. 데이터 분석기 는 스케줄링 파라미터 값들과 웨이퍼 프로세싱 시나리오들 사이의 기본적인 관계들을 캡처한다. 모델 생성기 는 데이터 분석기 에 의해 분석된 데이터에 머신 러닝 기법들을 적용함으로써 모델을 생성한다. 모델 생성기 는 이하에 상세히 기술된 바와 같이 하나 이상의 모델들을 규정하고, 트레이닝하고, 검증한다. 시스템 에서, 모든 엘리먼트들 (402 내지 408) 은 단일 컴퓨터 (예를 들어, 도 3에 도시된 엘리먼트 ) 에 의해 구현될 수 있다. 엘리먼트들 (402 내지 408) 각각은 별도의 컴퓨터에 의해 구현될 수 있다. 엘리먼트들 (402 내지 408) 중 하나 이상은 별도의 컴퓨터에 의해 구현될 수 있다. 즉, 엘리먼트들 (402 내지 408) 은 하나 이상의 컴퓨팅 디바이스들을 사용하여 구현될 수 있다. 컴퓨팅 디바이스들 각각은 하나 이상의 하드웨어 프로세서들 (예를 들어, CPU들) 을 포함할 수 있다. 컴퓨팅 디바이스들 각각은 도 5a 내지 도 8을 참조하여 이하에 도시되고 기술된 방법들에 대응하는 인스트럭션들을 저 장하는 메모리를 포함할 수 있다. 컴퓨팅 디바이스들의 하드웨어 프로세서들은 컴퓨팅 디바이스들의 메모리들 에 저장된 인스트럭션들을 실행할 수 있다. 하나 이상의 엘리먼트들 (402 내지 408) 은 하나 이상의 네트워크들에 의해 통신 가능하게 상호 연결될 수 있다. 예를 들어, 네트워크들은 LAN, WAN, 인터넷, 클라우드-기반 네트워크 시스템, 또는 임의의 다른 분산된 통신 시스템 (예를 들어, 클라이언트-서버 아키텍처에 기초한 네트워크 시스템) 을 포함할 수도 있다. 예를 들어, 데이터 수집기 는 도 3에 도시된 팹 데이터 수집 시스템 으로서 구현될 수도 있다. 데 이터 수집기 는 하나 이상의 툴들 (예를 들어, 도 1에 도시된 툴 ) 로부터 데이터를 수집한다. 하 나 이상의 툴들은 동일한 고객 위치에 위치될 수도 있다. 하나 이상의 툴들은 동일한 고객의 상이한 위치들에 위치될 수도 있다. 하나 이상의 툴들은 상이한 고객들의 위치들에 위치될 수도 있다. 툴들로부터 수집된 데이 터는 고객들의 독점 및 기밀 데이터를 제외하지만 모델을 생성하고 트레이닝하는데 사용될 수 있는 다른 모든 동작 데이터를 포함한다. 단지 예를 들면, 데이터가 수집되는 툴은 에칭 툴일 수도 있고 다음의 구성을 가질 수도 있다. 툴은 최대 4 개 의 에어 록들을 가질 수도 있다. 웨이퍼-플로우 구성은 냉각 스테이션을 갖는 1-레벨 (에칭만) 및/또는 2-레벨 (에칭 및 스트립) 일 수도 있다. 레시피 타입들은 웨이퍼 프로세싱, 웨이퍼-리스 자동 세정, 사전-컨디셔닝 및 사후-컨디셔닝, 등을 포함할 수도 있다. 실행 시나리오들은 단일 플로우 및/또는 병렬로 실행되는 복수의 플로 우들을 포함할 수도 있다. 툴은 하나 이상의 에칭 챔버들, 하나 이상의 스트립핑 챔버들, 세정 챔버, 등을 포 함하는 최대 6 개의 프로세싱 챔버들을 포함할 수도 있다. 시스템 에서, 모델 생성기 는 툴들 및 시뮬레이터 로부터 획득되고 처리량 예측 모델을 생성 하도록 데이터 분석기 에 의해 분석되는 이력 데이터에 ML (machine learning) 방법들을 적용한다. 모델 을 사용하여, 툴의 스케줄러는 주어진 툴 구성에 대해 모델에 의해 제공된 최상의 스케줄링 파라미터들을 사용 하여 웨이퍼들의 프로세싱을 스케줄링할 수 있다. 단순 선형 회귀는 기본 변수들 간의 복잡한 관계들로 인해 잘 작동하지 않는다. 대신, 머신 러닝 방법들을 사용하면 복잡한 비선형 데이터를 핸들링하는 유연성을 제공한 다. 머신 러닝 방법들의 예들은 ANN (artificial neural network), SVR (support vector regression), 등을 포함한다. 모델 생성기 는 머신 러닝 방법들 대신 또는 머신 러닝 방법들에 더하여 다른 접근법들을 사용할 수도 있 다. 다른 방법들의 예들은 메타휴리스틱 (metaheuristic) 및 수학적 방법들 (예를 들어, 페트리 넷 (petri net)) 을 포함한다. 메타휴리스틱 방법은 인공 지능 (AI) 의 분기이고 미리 정의된 성능 요건들을 충족시키기 위해 거의 최적의 스케줄링 패턴을 찾기 위한 자동 시행 착오 방법이다. 이어서 스케줄링 파라미터 값들은 선 택된 스케줄링 패턴으로부터 추출될 수 있다. 최적에 가까운 스케줄링 패턴을 찾도록 사용된 알고리즘들의 예 들은 유전 알고리즘 및 유전 프로그래밍을 포함한다. 선택된 머신 러닝 방법을 사용하여, 모델 생성기 는 최적의 스케줄링 파라미터 값들을 예측하도록 모델을 트레이닝한다. 모델은 예를 들어 PM들 (preventive maintenance operations), 레시피 시간들, 및 툴들의 WAC (wafer-less auto clean) 시간들로부터 수집된 데이터를 사용하여 트레이닝된다. 모델은 스케줄링 파라미터 값 들과 다양한 웨이퍼 프로세싱 시나리오들 사이의 기본적인 관계들을 캡처하여 이에 따라 예측들을 하도록 사용 되고, 이는 최상의 값 (best value) 선택을 위한 가이드라인들을 확립할 필요성을 제거한다. 모델은 파라미터 공간에 걸쳐 균일한 예측 정확도를 제공할 수 있다. 모델 생성기 는 특정한 웨이퍼 프로세싱 시나리오를 위한 전용 모델을 생성하고 트레이닝할 수도 있다. 즉, 모델은 특정한 툴에 대해 트레이닝될 수 있다. 대안적으로, 모델 생성기 는 다양한 시나리오들을 커버할 수 있는 단일 모델을 생성하고 트레이닝할 수도 있다. 즉, 모델은 복수의 툴들과 함께 작동하도록 트레이 닝될 수 있다. 예를 들어, 특정한 툴에 대해 트레이닝된 전용 모델은 시간이 흐름에 따라 다른 툴들로부터 다 른 시나리오들로부터 수집된 데이터를 사용하여 복수의 툴들과 함께 작동하도록 더 트레이닝될 수 있다. 일 모델이 모든 가능한 시나리오들을 커버할 수 있는지 또는 전용 모델이 필요할지를 결정하기 위해, 모델 생성 기 는 복수의 툴 구성들로부터 수집된 데이터에 기초하여 모델을 생성하도록 선택된 머신 러닝 방법을 적 용하고 예측 정확도가 성공 기준들을 충족하는지 체크하도록 시나리오들을 실행할 수 있다. 성공 기준들은 시 간이 흐름에 따라 발생할 수 있는 동일한 툴 내에서 성능 드리프트뿐만 아니라 툴-투-툴 변동들에 대해 모델이 보상할 수 있는지 여부를 포함할 수 있다. 성공 기준들은 모델이 스킵된 예방적 유지 보수들을 고려함으로써 스케줄링 파라미터 값들을 최적화할 수 있는지 여부를 더 포함할 수 있다. 성공 기준들은 또한 웨이퍼 유휴 시 간들이 모든 웨이퍼들에 대한 총 프로세싱 시간의 작은 백분율 (예를 들어, 2 ％) 미만인지 여부 및 레시피 각 각에 대해 제작 효율 (실제/이론적 사이클 시간) 이 높을 수 있는지 (예를 들어, 97 ％보다 클 수 있는지) 여부 를 포함할 수 있다. 사용시, 모델은 오퍼레이터에 의해 선택된 웨이퍼-플로우에 기초하여 툴의 시스템 소프트웨어로부터 (예를 들어, 툴 의 시스템 제어기 로부터) 입력 파라미터들을 수신할 수 있다. 예를 들어, 모델은 PM들 의 수, 레시피 시간들, 및 WAC 시간들을 입력들로 수신할 수 있다. 그러면 모델은 최상의 스케줄링 파라미터 값들을 계산하고 예측할 수 있고 이 값들을 시스템 소프트웨어로 다시 전송할 수 있다. 트레이닝된 모델은 시 스템 소프트웨어에 구축된 스케줄러의 기본적인 거동을 캡처하고, 이는 선택된 웨이퍼-플로우에 따라 웨이퍼들 의 세트를 프로세싱할 때 사용될 최상의 스케줄링 파라미터 값들을 예측하도록 사용될 수 있다. 트레이닝된 모 델을 사용하는 것은 또한 새로운 웨이퍼-플로우가 시작될 때 툴의 시스템 소프트웨어로 하여금 스케줄링 파라미 터 값들을 자동으로 선택하게 한다. 툴 오퍼레이터는 최상의 스케줄링 파라미터 값들을 선택하기 위해 더 이상 광범위한 시뮬레이션 연구들을 수행할 필요가 없다. 모델은 다양한 방식들로 구현될 수 있다. 예를 들어, 모델은 툴의 시스템 소프트웨어에 통합될 수 있다. 대안 적으로, 모델은 툴의 시스템 소프트웨어로부터 독립적으로 그리고 원격으로 구현될 수 있고, 모델에 의해 생성 된 예측 결과들은 툴의 시스템 소프트웨어에 공급될 수 있다. 예를 들어, 모델 유지 보수의 용이성을 위해, 모 델은 툴의 시스템 소프트웨어 외부에서 실행될 수도 있다. 모델은 오퍼레이터에 의해 선택된 웨이퍼-플로우에 기초하여 시스템 소프트웨어로부터 입력 파라미터들을 수신할 수 있다. 그러면 모델은 최상의 스케줄링 파라미 터 값들을 계산하고 예측할 수 있고 이 값들을 시스템 소프트웨어로 다시 전송할 수 있다. 예를 들어, 모델은 SaaS로서 클라우드에서 전개될 수 있다. 모델이 툴의 시스템 소프트웨어에 통합될 때, 모델은 툴 당 기준으로 툴의 캡티브 데이터 (captive data) 로부 터 툴 상의 주어진 실행 시나리오에 대한 최적의 스케줄링 파라미터들을 생성할 수 있다. 따라서, 이 구현 예 에서, 모델의 예측은 실제 툴 데이터에 기초한다. 모델은 또한 툴-투-툴 차이들에 적응한다. 모델은 툴 성능 드리프트를 조정하도록 업데이트될 수 있다. 그러나, 이 구현 예에서, 집약적인 계산들이 툴 자체에 대해 수행 된다. 또한, 툴의 캡티브 데이터는 모델이 최상의 솔루션을 제공하기에 충분하지 않을 수도 있다. 데이터의 충분성은 툴로부터의 데이터 세트를 갖는 모델을 사용하고 데이터 세트가 최상의 스케줄링 파라미터들을 예측하 기에 충분한지 평가함으로써 결정될 수 있다. 모델이 툴들로부터 별도로 구현될 때, 모델 생성기 는 최적의 구성들의 세트를 식별하고 저장할 수 있고 툴 당 시나리오들을 실행하고 자동 선택을 위해 세트를 저장할 수 있다. 시뮬레이터 는 툴 구성들, 웨이 퍼-플로우 타입들, 레시피/WAC 시간들, 및 실행 시나리오들의 다양한 조합들에 대한 트레이닝 데이터를 생성할 수 있다. 모델 생성기 는 트레이닝 데이터 세트에 기초하여 최상의 시스템 처리량을 생성하도록 최상의 예측 모델을 생성하는 최상의 머신 러닝 방법을 식별할 수 있다. 이어서 모델은 툴 구성 및 시나리오 당 최적 의 스케줄링 파라미터들의 세트를 생성하도록 사용될 수 있다. 모델 결과들의 세트는 툴 오퍼레이터에 의해 선 택된 실행 시나리오 및 툴의 툴 구성에 기초하여 툴 오퍼레이터에 의한 자동 스케줄링 파라미터 선택을 용이하 게 하도록 사용자 인터페이스에 코딩될 수 있다. 이 구현 예에서, 툴에 대해 수행된 계산이 제한된다. 그러나, 모델 생성기 는 다양한 구성들 및 다양한 툴들의 시나리오들을 커버하도록 광범위한 계산들을 수행한다. 또한, 모델의 예측은 다양한 툴들의 캡티브 데 이터가 아니라 시뮬레이팅된 데이터에 기초한다. 따라서, 모델 성능은 시뮬레이션 데이터의 품질에 종속된다. 모델은 또한 모든 가능한 툴 구성들 및 실행 시나리오들을 지원하지 못할 수도 있다. 또한, 모델은 툴들 사이 의 차이들에 적응하지 못할 수도 있고 툴 성능 드리프트를 위해 조정되지 않을 수도 있다.도 5a는 머신-러닝 보조된 모델을 생성하고 모델을 사용하여 생성된 스케줄링 파라미터들에 기초하여 툴을 동작 시키기 위한 방법 을 도시한다. 방법 은 도 4에 도시된 시스템 에 의해 실행될 수도 있다. 예를 들어, 시스템 의 엘리먼트들 (402 내지 408) 중 하나 이상은 방법 의 이하의 단계들 중 하나 이상을 실행할 수도 있다. 502에서, 모델을 생성하고 트레이닝하기 위한 데이터가 하나 이상의 툴들로부터 수신된다. 504에서, 하나 이상 의 툴들에 대한 구성 및 레시피 데이터가 수신된다. 506에서, 시뮬레이터 (예를 들어, 도 4를 참조하여 상기 도시되고 기술된 엘리먼트 ) 를 사용하여, 모델을 생성하고 트레이닝하기 위한 부가적인 데이터가 구성 및 레시피 데이터에 기초하여 생성된다. 시뮬레이터의 동작은 도 5b를 참조하여 더 상세히 설명된다. 508에서, 머신 러닝 방법을 사용하여, 툴들 및 시뮬레이터로부터 수신된 데이터를 분석함으로써 모델이 생성되 고 트레이닝된다. 데이터를 분석하는 프로세스는 도 5c를 참조하여 더 상세히 설명된다. 모델 생성 및 트레이 닝 프로세스는 도 6 및 도 7을 참조하여 더 상세히 설명된다. 510에서, 모델이 테스트되고 검증된다. 모델 검증 프로세스는 도 8을 참조하여 더 상세히 설명된다. 512에서, 방법 은 모델에 대한 테스트 기준들이 충족되는지 여부를 결정한다. 방법 은 테스트 기 준들이 충족되지 않으면 502로 돌아간다. 514에서, 테스트 기준이 충족되면, 모델은 테스트 기준들이 충족되면 사용을 위해 전개된다. 모델은 상기 기술된 툴의 시스템 소프트웨어와 별도로 구현되거나 툴의 시스템 소프트 웨어에 통합된다. 516에서, 모델은 툴의 시스템 소프트웨어로부터 웨이퍼들의 세트에 대해 수행될 프로세싱에 관한 입력들을 수신 한다. 518에서, 수신 입력들에 기초하여, 모델은 웨이퍼들의 세트를 프로세싱하는 툴의 시스템 소프트웨어에 최적의 스케줄링 파라미터 값들을 제공한다. 520에서, 수신된 스케줄링 파라미터 값들에 기초하여, 툴의 시스 템 소프트웨어는 웨이퍼들의 세트를 프로세싱하기 위한 동작들을 스케줄링한다. 도 5b는 시뮬레이터 에 의해 실행된 방법 으로서 시뮬레이터 의 동작을 도시한다. 도 5a에 서 504에 기술된 바와 같이, 하나 이상의 툴들에 대한 구성 및 레시피 데이터가 수신된다. 도 5b의, 552에서, 시뮬레이터 는 툴의 하드웨어 구성 및 레시피 데이터 등을 사용하여 툴의 프로세싱 환경을 시뮬레이팅한 다. 554에서, 시뮬레이터 는 툴의 시뮬레이팅된 환경에서 웨이퍼들의 프로세싱을 시뮬레이팅한다. 556 에서, 시뮬레이터 는 툴의 시뮬레이팅된 환경에서 웨이퍼들의 시뮬레이팅된 프로세싱에 기초하여 모델을 생성하고 트레이닝하기 위해 부가적인 데이터를 생성한다. 도 5c는 데이터 분석기 에 의해 실행된 방법 의 형태의 데이터 분석기 의 동작을 도시한다. 도 5a의 508에 기술된 바와 같이, 모델은 툴들 및 시뮬레이터로부터 수신된 데이터를 분석함으로써 생성되고 트 레이닝된다. 도 5c의, 582에서, 데이터 분석기 는 툴들로부터 그리고 시뮬레이터 로부터 수집된 데이터를 분석한다. 584에서, 데이터 분석기 는 데이터를 분석하기 위해 사용된 기법들을 사용하여 데이 터를 분석한다. 586에서, 데이터 분석기 는 수집된 데이터의 분석에 기초하여 툴(들)에 대한 PM들, WAC 시간들, 대기 시 간들, 레시피 시간들, 및 처리량에 관한 패턴들을 검출한다. 588에서, 데이터 분석기 는 툴-투-툴 변동 들 및 또한 상기 기술된 동일 툴 변동들을 검출한다. 590에서, 데이터 분석기 는 머신 러닝을 사용한 모 델 트레이닝에 사용하기 위해 검출된 패턴들 및 변동들을 모델 생성기 에 제공한다. 도 6 및 도 7은 모델 생성 및 트레이닝 프로세스를 보다 상세히 도시한다. 도 6에서, 모델을 생성하기 위한 방 법 이 도시된다. 602에서, 모델이 규정된다. 604에서, 모델이 트레이닝된다. 606에서, 모델이 검증된 다. 도 7에서, 모델을 생성하기 위한 방법 이 도시된다. 702에서, 모델은 심층 신경망에 대한 망 토폴로지 (network topology) 를 선택함으로써 규정된다. 심층 신경망의 예가 도 9에 도시된다. 예를 들어, 망 토폴로 지를 선택하는 것은 입력들의 수, 뉴런들의 수, 및 심층 신경망의 층들의 수를 선택하는 것을 포함한다. 704로부터 710까지, 모델이 트레이닝된다. 704에서, 모델은 트레이닝 데이터 (예를 들어, 툴들로부터 수집된 데이터 및 시뮬레이터에 의해 생성된 데이터) 에 대해 실행된다. 706에서, 모델에 의해 예측된 출력들은 트레 이닝 데이터에 대해 체크된다. 708에서, 모델 파라미터들 및/또는 네트워크 기술은 모델의 예측들과 실제 데이 터 사이에 보다 우수한 매칭을 생성하도록 조정된다. 710에서, 모델이 미리 결정된 기준들을 충족하는지 여부 가 결정된다. 예를 들어, 미리 결정된 기준들은 모델이 툴-투-툴 변동들 및 동일-툴 성능 드리프트에 대해 보상할 수 있는지 여부 및 모델이 사용 불가능한 PM들에 대해 최적화할 수 있는지 여부를 결정하는 것을 포함한다. 또한, 미리 결정된 기준들은 모델 출력들이 작은 웨이퍼 유휴 시간 (예를 들어, 2 ％ 미만) 및 고 제작 효율 (예를 들어, 97 ％ 초과) 을 보장하는지 여부를 결정하는 것을 포함할 수도 있다. 방법 은 미리 결정된 기준들 중 하 나가 충족되지 않으면 704로 돌아 간다. 712에서, 미리 결정된 기준이 충족되면, 모델은 툴들로부터 새로운 데 이터로 모델을 테스트함으로써 검증된다. 도 8은 모델을 더 상세히 검증하기 위한 방법 을 도시한다. 이 방법을 K-폴드 검증 방법이라고 한다. 802에서, 검증을 위해 사용된 데이터는 K 개의 파티션들로 분할되고, 여기서 K는 1보다 큰 정수이다. 804에서, 동일한 모델들이 인스턴스화된다 (instantiate). 806에서, 모델 각각은 하나의 파티션에서 트레이닝되고 나머 지 파티션들에서 평가된다. 검증 스코어들이 평가마다 할당된다. 808에서, 모델에 대한 검증 스코어는 모델에 대한 K 검증 스코어들의 평균이다. 최고 유효성 검사 스코어를 가진 모델이 사용되도록 전개된다. 모델을 검증하기 위해 다른 검증 방법들이 사용될 수 있다. 예를 들어, N-폴드 교차-검증 방법이 사용될 수도 있다. 이 방법에서, 총 데이터 세트는 하나의 최종 테스트 세트와 N 개의 다른 서브 세트들로 나뉘고, 여기서 N은 1보다 큰 정수이다. 모델 각각은 검증 에러 레이트의 N 개의 상이한 추정치들을 얻기 위해 서브 세트들 중 하나를 제외하고 모두에 대해 트레이닝된다. 최저 유효성 검사 오류율을 가진 모델이 사용되도록 전개된다. 도 9 및 도 10은 머신 러닝 기법들을 사용하여 본 명세서에 기술된 모델들을 생성하도록 사용된 심층 신경망의 일 예를 도시한다. 머신 러닝은 예측에 적합한 복잡한 모델들과 알고리즘들을 고안하는데 사용되는 방법이다. 머신 러닝을 사용하여 생성된 모델들은 신뢰할 수 있고 반복 가능한 결정들 및 결과들을 생성할 수 있고 데이터 의 과거 관계들 및 경향들로부터 학습을 통해 숨겨진 통찰력을 발견할 수 있다. 심층 신경망 기반 모델을 사용하고 머신 러닝을 사용하여 모델을 트레이닝시키는 목적은 변수들 간의 관계들을 수학적 형태로 합산하지 (cast) 않고 종속 변수를 직접 예측하는 것이다. 신경망 모델은 병렬로 동작하고 계층 들로 배열된 많은 수의 뉴런들을 포함한다. 제 1 계층은 입력 계층이고 원시 입력 데이터를 수신한다. 연속적 인 층 각각은 이전 계층으로부터의 출력들을 수정하고 이들을 다음 계층으로 전송한다. 마지막 계층은 출력 계 층이고 시스템의 출력을 생성한다. 입력 계층에서, 입력 노드 각각은 임의의 실수일 수 있는, 수치와 연관된다. 계층 각각에서, 입력 노드로부터 벗어나는 연결 각각은 이와 연관된 가중치를 갖고, 이는 또한 임의의 실수일 수 있다 (도 9 참조). 도 9에서, 완전히 연결된 신경망이 도시되고, 주어진 계층의 뉴런 각각은 다음 계층의 뉴런 각각에 연결된다. 입력 계층에서 뉴런들의 수는 데이터 세트의 피처들 (열) 의 수와 같다. 출력 계층은 복수의 연속적인 출력들 을 가질 수 있다. 입력 계층과 출력 계층 사이의 계층은 은닉 계층들 (hidden layers) 이다. 은닉 계층들의 수는 하나 이상일 수 있다 (하나의 은닉 계층이 대부분의 애플리케이션들에 대해 충분할 수도 있다). 은닉 계 층이 없는 신경망은 선형 분리 가능한 함수들 또는 결정들을 나타낼 수 있다. 하나의 은닉층을 갖는 신경망은 유한한 공간에서 다른 공간으로 연속적인 맵핑을 수행할 수 있다. 2 개의 은닉 계층을 갖는 신경망은 모든 매 끄러운 맵핑을 임의의 정확도로 근사화할 수 있다. 뉴런들의 수는 최적화될 수 있다. 트레이닝 시작시, 망 구성은 초과 노드들을 가질 가능성이 보다 높다. 노드 들은 망 성능에 눈에 띄게 영향을 주지 않는 트레이닝 동안 네트워크로부터 제거될 수도 있다. 예를 들어, 트 레이닝 후 가중치가 0에 가까워지는 노드들은 제거될 수 있다 (프루닝 (pruning)). 뉴런들의 수는 언더 피팅 (under-fitting) (데이터 세트의 신호들을 적절히 캡처할 수 없음) 또는 오버 피팅 (over-fitting) (모든 뉴런 들을 트레이닝시키기에 불충분한 정보; 망은 트레이닝 데이터 세트에서 잘 수행되지만 테스트 데이터 세트에서 수행되지 않음) 을 유발할 수 있다. 모델의 성능을 측정하기 위해 다양한 방법들이 사용될 수 있다. 예를 들어, RMSE (root mean squared error) 는 관찰된 값들과 모델 예측들 사이의 평균 거리를 측정한다. 결정 계수 (R2) 는 관찰된 결과와 예측된 결과 간의 (정확성이 아니라) 상관 관계를 측정한다. 이 방법은 데이터의 분산이 큰 경우 신뢰할 수 없다. 다른 성 능 측정들은 감소할 수 없는 잡음 (irreducible noise), 모델 바이어스 및 모델 분산을 포함한다. 고 바이어스 는 모델이 예측 변수들과 결과 사이의 진정한 관계를 캡처할 수 없음을 나타낸다. 모델 분산은 모델이 안정적 이지 않은지 여부를 나타낼 수 있다 (데이터의 약간의 섭동은 모델 적합도 (fit) 를 상당히 변화시킬 것이다). 도 11은 고 바이어스 및 고 분산의 일 예를 도시한다. 고 분산은 오버 피팅을 나타낼 수 있다. 오버 피팅은 다양한 방법을 사용하여 방지될 수 있다. 예를 들어, 정규화가 사용될 수 있고, 여기서 큰 가중치들은 제곱된 값들 (L2 패널티) 또는 절대 값들 (L1 패널티) 에 대한 패널티들 또는 제약들을 사용하여 패널티를 받을 수 있 다. 또한, 보다 많은 데이터가 사용될 수 있다. 또한, 프루닝 (0에 가까운 가중치 인자들을 갖는 뉴런들을 제 거하는 것) 및/또는 배깅 (bagging) (트레이닝 데이터의 상이한 서브 세트들에 대한 모델을 트레이닝하는 것) 이 오버 피팅을 방지하도록 사용될 수도 있다. 도 12는 개별 이벤트 시뮬레이터를 사용하여 강화 학습 모델을 트레이닝하기 위한 시스템 을 도시한다. 예를 들어, 상기 기술된 시스템 에 의해 생성된 모델은 이하에 기술된 바와 같이 시스템 을 사용 하여 강화 학습을 사용하여 더 트레이닝될 수 있다. 시스템 은 개별 이벤트 시뮬레이터 및 강화 학습 모델 을 포함한다. 개별 이벤트 시뮬레이터 는 툴의 시스템 소프트웨어 (예를 들어, 툴의 시스템 소프트웨어를 실행하는 도 1에 도시된 툴 의 제어기 ) 및 강화 학습 모델 (예를 들어, 도 4에 도시된 시스템 에 의해 생성된 모델) 과 통신한다. 시스템 에서, 모든 엘리먼트들 (138, 1202, 및 1204) 은 단일 컴퓨터에 의해 구현될 수 있다. 엘리먼트 들 (138, 1202, 및 1204) 각각은 별도의 컴퓨터에 의해 구현될 수 있다. 엘리먼트들 (138, 1202, 및 1204) 중 하나 이상은 별도의 컴퓨터에 의해 구현될 수 있다. 즉, 엘리먼트들 (138, 1202, 및 1204) 은 하나 이상의 컴 퓨팅 디바이스들을 사용하여 구현될 수 있다. 컴퓨팅 디바이스들 각각은 하나 이상의 하드웨어 프로세서들 (예를 들어, CPU들) 을 포함할 수 있다. 컴퓨팅 디바이스들 각각은 도 13을 참조하여 이하에 도시되고 기술된 방법들에 대응하는 인스트럭션들을 저장하는 메모 리를 포함할 수 있다. 컴퓨팅 디바이스들의 하드웨어 프로세서들은 컴퓨팅 디바이스들의 메모리들에 저장된 인 스트럭션들을 실행한다. 엘리먼트들 (138, 1202, 및 1204) 중 하나 이상은 하나 이상의 네트워크들에 의해 통신 가능하게 상호 연결될 수 있다. 예를 들어, 네트워크들은 LAN, WAN, 인터넷, 클라우드-기반 네트워크 시스템, 또는 임의의 다른 분산 된 통신 시스템 (예를 들어, 클라이언트-서버 아키텍처에 기초한 네트워크 시스템) 을 포함할 수도 있다. 또한, 엘리먼트들 (1202 및 1204) 은 도 4에 도시된 시스템 과 (예를 들어, 모델 생성기 과) 통합 될 수 있다. 즉, 시스템 은 시스템 과 통합될 수 있다. 상기 언급된 바와 같이, 일부 툴들에서, 시스템 소프트웨어의 스케줄러는 스케줄링 결정들을 내리기 위해 스케 줄링 규칙들 및 스코어링 시스템의 세트를 사용할 수도 있다. 그러나, 시스템 구성, 실행 시나리오들, 및 툴의 스케줄링 제약들의 복잡성이 증가함에 따라, 이 스케줄링 결정 스킴의 복잡성도 증가하고, 이는 결국 최적의 시 스템 처리량을 달성하고 유지하기 위해 보다 많은 개발 노력들을 필요로 한다. 스케줄러의 스케줄링 규칙들 및 스코어링 시스템은 신경망 모델 로 대체될 수 있다. 모델 은 툴 의 주어진 상태에 대한 최상의 스케줄링 결정들을 자기 탐색하고 기억하도록 개별 이벤트 시뮬레이터 및 강화 학습을 사용하여 트레이닝될 수 있다. 이는 툴의 최적의 처리량 성능을 달성하고 유지하게 한다. 이하에 도 13을 참조하여 더 상세히 설명된 바와 같이, 자기-탐색 프로세스는 최적의 처리량 성능으로 시스템을 동작시키기 위한 최상의 가능한 방법을 찾는 (예를 들어, 툴을 통해 웨이퍼를 이동시키는 최상의 경로를 찾는) 노력들을 자동화하도록 개별 이벤트 시뮬레이터 를 사용한다. 툴 상에서 자가-트레이닝 프로세스를 실 행함으로써, 신경망 모델 은 특정한 툴 구성, 웨이퍼 프로세싱 시나리오, 및 툴에 고유한 제약들에 대해 최적화될 수 있다. 개별 이벤트 시뮬레이터 는 고속 시뮬레이터이다. 예를 들어, 개별 이벤트 시뮬레이터 는 1 분 미만에 약 1 시간이 걸리는 웨이퍼 프로세싱 시퀀스를 시뮬레이팅할 수 있다. 개별 이벤트 시뮬레이터 는 1-레벨 및 2-레벨 웨이퍼 프로세싱 시퀀스뿐만 아니라 PM들에서 실행되는 WAC들을 시뮬레이팅할 수 있다. 개별 이벤트 시뮬레이터 는 개별 이벤트 시뮬레이터 와 모델 사이의 정보 교환을 용이하 게 하도록 내장된 HTTP 서버 기반 API (application programming interface) 를 포함한다. 개별 이벤트 시뮬 레이터 는 API를 통해 JSON 포맷의 스케줄링 사이클 정보를 출력한다. 모델 은 API를 통해 개별 이벤트 시뮬레이터 로 리턴되는 다음 동작을 선택하도록 JSON 파일을 프로세싱한다. 부가적으로, 모델 은 도 13을 참조하여 이하에 더 상세히 설명되는 바와 같이 강화 학습 방법을 사용하 여 트레이닝되는 심층 신경망을 포함한다. 강화 학습은 에이전트, 상태들의 세트 S 및 상태 당 액션들의 세트 A를 수반한다. 세트 A로부터 액션 'a'를 수행함으로써, 에이전트는 상태로부터 상태로 (from state to state) 전이한다. 특정한 상태에서 액션을 실행하는 것은 에이전트에게 보상 (숫자 스코어) 을 제공한다. 에이전트의목표는 총 (미래) 보상을 최대화하는 것이다. 에이전트는 현재 상태를 달성하기 위한 보상에 미래 상태들로부 터 달성 가능한 최대 보상을 더함으로써 목표를 달성하고, 이는 잠재적인 미래 보상에 의해 현재 액션에 효과적 으로 영향을 준다. 이 잠재적인 보상은 현재 상태로부터 시작하여 모든 미래 단계들의 보상들의 예상된 값들의 가중 합이다. 예를 들어, 모델 에 의해 사용된 강화 학습 방법은 Q-러닝을 포함할 수 있다. Q-러닝은 머신 러닝에서 사용되는 강화 학습 방법이다. Q-러닝의 목표는 에이전트에게 어떤 상황에서 어떤 조치를 취해야 하는지 알려 주는 정책을 학습하는 것이다. Q-러닝은 적응을 요구하지 않고 확률적 전환 및 보상으로 문제를 핸들링할 수 있다. Q-러닝은 모든 유한 마르코프 결정 프로세스 (finite Markov decision process; FMDP) 에 대한 최적의 정책을 찾는다. Q-러닝은 현재 상태로부터 시작하여 모든 연속적인 단계들에 걸쳐 총 보상의 예상된 값을 최대 화한다. 도 13은 개별 이벤트 시뮬레이터 를 사용하여 강화 학습 모델 을 트레이닝하기 위한 방법 을 도시한다. 방법 은 도 12에 도시된 시스템 에 의해 실행될 수도 있다. 예를 들어, 시스템 의 엘리먼트들 (138, 1202, 및 1204) 중 하나 이상은 방법 의 이하의 단계들 중 하나 이상을 실 행할 수도 있다. 1302에서, 개별 이벤트 시뮬레이터 는 툴 (예를 들어, 도 1에 도시된 툴 ) 로부터 데이터를 수신한 다. 예를 들어, 개별 이벤트 시뮬레이터 는 툴 의 시스템 제어기 상에서 실행되는 시스템 소프트웨어로부터 툴의 현재 상태를 나타내는 데이터를 수신한다. 예를 들어, 툴의 상태 정보는 웨이퍼들의 프 로세싱 상태에서 툴 리소스들 (예를 들어, PM들, 에어 록들, 등) 의 상태를 포함할 수도 있다. 1304에서, 개별 이벤트 시뮬레이터 는 다음 상태로 전이하도록 툴에 의해 수행될 수 있는 모든 가능한 다음 스케줄링된 레벨 동작들의 세트를 생성한다. 1306에서, 개별 이벤트 시뮬레이터 는 다음 스케줄링 된 레벨 동작들의 세트를 모델 로 출력한다. 1308에서, 모델 은 최상의 시스템 성능을 제공할 최상의 다음 동작을 스케줄링하도록 선택한다. 1310에서, 모델 은 이 툴 상태에 대해 스케줄링할 최상 의 다음 동작을 기억한다. 1312에서, 개별 이벤트 시뮬레이터 는 다음 상태를 시뮬레이팅하기 위해 최 상의 다음 동작을 실행한다. 1314에서, 개별 이벤트 시뮬레이터 는 최종 상태에 도달했는지 여부를 결정한다. 개별 이벤트 시뮬레이 터 는 최종 상태에 도달할 때까지 단계 1304 내지 단계 1312를 반복한다. 1316에서, 최종 상태에 도달 한 후, 모델 의 강화 트레이닝이 완료된다. 1318에서, 모델 은 특정한 상태가 실제 웨이퍼 프로 세싱 동안 툴에서 발생할 때 각각의 상태에 대해 기억된 최상의 다음 동작을 사용한다. 이러한 방식으로, 모델 을 사용하여, 툴은 일 상태에서 또 다른 상태로 전이할 때 최적의 처리량 성능을 위해 툴을 통해 웨이퍼 를 이동시킬 최상의 경로를 항상 선택한다. 따라서, 시스템 은 시스템 과 함께, 스마트 머신-러닝 보조된 스케줄러를 제공한다. 스마트 스케 줄러는 시스템의 주어진 상태에 대해 최상의 스케줄링 결정을 내리도록 신경망 모델을 트레이닝시키기 위해 자 가 학습 프로세스를 사용한다. 결정들은 반도체 제조업체에 특정한 스케줄링 제약들 및 실행 시나리오들에 따 라 최적의 처리량 조건으로 툴을 달성하고 유지하는데 도움을 준다. 예를 들어, 스마트 스케줄러는 웨이퍼 유 휴 시간이 총 프로세싱 시간의 2 ％ 미만일 수 있고 제작 효율 (실제/이론적 사이클 시간) 이 레시피 각각에 대 해 97 ％보다 클 수 있다는 것을 보장할 수 있다. 이에 더하여, 복수의 병렬 재료 증착 (예를 들어, 다층 도금) 프로세스들을 위한 툴들에서 사용된 스케줄러 페 이싱의 정확도를 개선하기 위해, 본 개시는 머신 러닝을 사용하여 트레이닝되는 내포된 신경망 기반 모델을 제 안한다. 구체적으로, 이하에 상세히 설명된 바와 같이, 내포된 신경망 기반 모델은 처음에 설계되고 오프라인 으로 시뮬레이팅된 데이터를 사용하여 트레이닝되고 이어서 웨이퍼 라우팅 경로를 예측하고 스케줄링하기 위해 실제 툴 데이터를 사용하여 온라인으로 트레이닝된다. 이 모델은 최고 툴/플릿 활용도, 최단 대기 시간들 및 최고 처리량을 달성한다. 현재, 병렬 레시피들에 사용된 스케줄러 규칙들의 동적 특성으로 인해, 페이싱은 통상적으로 다음과 같은 문제 들을 갖는다. 페이싱은 스케줄러 거동 (예를 들어, 웨이퍼 라우팅) 을 예측하고 프로세싱 (예를 들어, 도금) 을 위해 다음 세트의 웨이퍼들 (통상적으로 웨이퍼들의 쌍) 을 툴 내로 전송할 때를 결정하는 능력이다. 때때 로, 스케줄러 거동은 정확하게 예측될 수 없다. 그 결과, 웨이퍼들은 너무 늦게 또는 너무 일찍 툴 내로 발송 될 (dispatch) 수도 있다. 웨이퍼들을 너무 늦게 발송하는 것은 툴 처리량을 감소시키고, 웨이퍼들을 너무 일찍 발송하는 것은 증가된 웨이퍼 대기 시간으로 인해 웨이퍼 수율을 감소시켜, 웨이퍼들을 건조하게 한다. 따 라서, 스케줄러는 최대 처리량 및 수율을 달성하기 위해 툴 내로 웨이퍼들을 전송할 때를 정확하게 예측해야 한 다. 구체적으로, 툴은 통상적으로 웨이퍼 이송을 위해 2 개의 로봇을 사용한다: 프론트 엔드 (frontend; FE) 로봇은 툴 내로 한 쌍의 웨이퍼들을 이송하고, 백 엔드 (backend; BE) 로봇은 툴의 일 프로세싱 모듈로부터 툴의 또 다 른 프로세싱 모듈로 웨이퍼들의 쌍을 이송한다. 툴의 하나 이상의 프로세싱 모듈들에서 웨이퍼들에 대해 동일 하거나 상이한 프로세스들이 수행될 수도 있다. 두 로봇들의 스케줄링은 프로세싱 모듈들의 가용성과 함께 조 정되어야 한다. 일단 웨이퍼들이 툴에 들어가면, 프로세싱 모듈들은 정확한 시간에 정확한 순서로 이용 가능해 야 한다. 그렇지 않으면, 웨이퍼들은 라우팅되는 다음 프로세싱 모듈이 이용 가능해질 때까지 대기해야 하고, 이는 웨이퍼들로 하여금 건조되게 할 수 있고, 이는 결국 수율을 감소시킬 수 있다. 복잡한 스케줄링 시나리오에 대한 부가적인 과제는 상이한 프로세스들에 대한 프로세싱 시간들이 광범위하게 (예를 들어, 일 프로세스에 대해 수 분으로부터 또 다른 프로세스에 대해 거의 1 시간으로) 가변할 수 있다는 것이다. 예를 들어, 간단한 레시피는 단일 층을 갖는 웨이퍼들을 프로세싱하는 것을 포함할 수도 있다. 이 경 우, 툴로 들어가는 웨이퍼들은 먼저 사전-프로세싱 모듈 (preprocessing module) 로, 이어서 도금 모듈로, 그리 고 이어서 사후-프로세싱 모듈 (post-processing module) 로 이송될 것이고, 이어서 웨이퍼들은 툴을 나간다. 2-층 프로세싱 레시피에 대해, 툴로 들어가는 웨이퍼들은 먼저 사전-프로세싱 모듈로, 이어서 제 1 프로세싱 모 듈로, 이어서 제 2 프로세싱 모듈로, 그리고 이어서 사후-프로세싱 모듈로 이송될 것이고, 이어서 웨이퍼들은 툴을 나가는, 등한다. 이해될 수 있는 바와 같이, 보다 많은 프로세싱 층들을 갖는 레시피들은 보다 긴 프로세 싱 시간들을 가질 수 있다. 그러나, 일부 레시피들에 대해, 로봇 스케줄링 및 웨이퍼 라우팅을 개선하기 위해 유리하게 활용될 수 있는 툴 에 약간의 유연성이 있을 수도 있다. 예를 들어, 다층 프로세싱 레시피에 대해, 프로세싱 재료가 N 개의 층들 에 대해 동일하고 동일한 프로세싱 층을 증착할 수 있는 N 개의 프로세싱 모듈들이 있다면, 웨이퍼들은 N 개의 프로세싱 모듈들 중 임의의 프로세싱 모듈들 사이에서 이송될 수 있다. 이 라우팅 유연성은 N 개의 프로세싱 모듈들 사이에서 웨이퍼들을 이송하기 위해 2 개 이상의 라우팅 경로들을 가질 기회를 제공한다. 그러나, N 개 의 프로세싱 모듈들 중 어느 것이 이용 가능할 것인지 그리고 웨이퍼 라우팅을 조정하고 스케줄링하기 위해 필 수적인 시간을 아는 것이 중요하다. 또한, 이송 로봇의 가용성을 아는 것은 또한 웨이퍼 라우팅을 조정하고 스 케줄링하는데 필수적이다. 따라서, 병렬 레시피들 (툴-투-툴 및 툴 내에서 모듈-투-모듈 모두) 에 대한 다양한 FE/BE 로봇 이송 시간들이 있다. 현재 페이싱 방법은 통상적으로 라우팅 경로 예측 없이, 대부분의 시나리오들에 대해 정적 FE/BE 로봇 예약 시간들을 사용한다. 또한, 현재 페이싱 방법은 웨이퍼 대기 시간과 처리량 사이에 다음의 딜레마에 직면 한다: FE/BE 로봇 예약 시간들을 감소시키는 것은 처리량을 개선할 수 있지만, 프로세싱 모듈들에서 웨이퍼들로 하여금 보다 오래 기다리게 할 수 있고, 증가하는 FE/BE 로봇 예약 시간들은 웨이퍼 대기 시간을 최소화할 수 있지만 (예를 들어, 재분배 층 또는 RDL 레시피에서) WPH (wafers per hour) 처리량의 하락을 생성할 수 있다. 또한, 현재, 프로그램 실행 시간 추정은 이들 툴들 상에서 인에이블된 상이한 파라미터 세트들 및 옵션들에 대 해 항상 정확한 것은 아니다. 이들 문제들을 해결하기 위해, 본 개시는 다음의 입력들에 기초하여 웨이퍼 라우팅 경로 및 처리량을 예측하기 위한 동적 페이싱 방법 (스케줄러 층 신경망) 을 제안한다: 1) 툴 구성들; 2) 레시피 구조 (예를 들어, 병렬 프 로세싱 모듈들, 단일/복수 층들, 등); 3) 정확한 프로그램 실행 시간 추정들 (파라미터 세트 값들의 입력들 및 인에이블/디스에이블된 옵션들에 기초하여 모듈 계층 신경망들에 의해 제공됨); 4) 라우팅 루트 상의 프로세싱 모듈 각각의 상태들 (예를 들어, 온라인/오프라인, 프로세싱 모듈로 향하는 웨이퍼들의 수, 남아 있는 프로세스 시간, 서비스 프로그램 전 남은 시간, 등); 및 5) 툴들 사이의 로트 발송 최적화 (lot dispatching optimization) 를 위해 툴들의 플릿에 대해 부가될 수 있는 제 3 신경망 층. 제안된 동적 스케줄러 페이싱 방법은 웨이퍼 프로세싱, 및 (모듈, 툴 및 플릿 레벨들에서) 웨이퍼/로트 발송 및 라우팅 동안 동적 웨이퍼 스케줄링 문제들을 해결하기 위해 머신 러닝을 사용하여 트레이닝된 내포된 신경망 기 반 모델을 사용한다. 처음에, 시뮬레이션은 신경망들을 트레이닝하고 테스트하기 위한 데이터를 생성하는데 사 용된다. 따라서, 시뮬레이션은 정확해야 하고, 정확한 프로그램 실행 시간 추정이 필요하다. 신경망 계층은 프로그램 실행 시간들을 정확하게 예측하기 위해 사용된다. 이 계층에서, 프로그램 실행 시간들을 예측하기 위 해 프로세싱 모듈 당 하나의 신경망이 사용된다. 부가적으로, 로봇 각각에 대한 이송 시간을 예측하기 위해 로봇 당 하나의 신경망이 사용된다. 방법은 시뮬레이션을 사용한 오프라인 학습과 실시간 툴 데이터를 사용한 온라인 학습을 모두 채용한다. 오프 라인 학습은 생산 동안 계산 복잡성을 최소화하기 위해 시뮬레이터 또는 툴 상에서 수집된 데이터에 기초한다. 오프라인 트레이닝 동안 신경망들에 대해 결정된 가중치들은 웨이퍼/로트 발송 전에 스케줄러 페이싱 알고리즘 에 적용된다. 이어서 온라인 학습은 실시간 데이터에 기초하여 신경망을 동적으로 조정하도록 사용된다. 따라서, 제안된 방법에서, 스케줄러 페이싱을 위한 모델은 내포된 신경망들 또는 다른 머신 러닝 알고리즘들을 사용하여 구축된다. 모델은 처음에 시뮬레이션을 사용하여 오프 라인으로 구축, 트레이닝 및 테스트된다. 후 속하여, 모델은 툴-특정 및 레시피-특정 로봇 이송 시간들을 반영하고 모든 프로세스 드리프트를 보상하는 모델 에 대한 추가 조정을 하기 위해 툴로부터의 데이터 스트림들을 점진적으로 (incrementally) 사용함으로써 실제 툴에 대해 계속해서 개선되고 온라인으로 트레이닝된다. 온라인 트레이닝은 또한 임의의 레시피 변화들 및/또 는 툴 하드웨어 변화들에 대해 모델을 조정한다. 내포된 신경망들을 사용하는 동적 스케줄러 페이싱 방법은 복수의 층 재료 증착 및 대기 시간의 제한과 함께 병 렬 레시피들의 활용 및 툴/플릿 처리량을 개선하고, 웨이퍼 건조 문제들을 방지한다. 방법은 최대 툴 활용도로 레시피/웨이퍼 할당 혼합을 추천할 수 있다. 방법은 또한 프론트 엔드 로봇 및 백 엔드 로봇 및 웨이퍼 정렬기 모두를 수반하는 라우팅 경로, 프로세스 모듈들로 인바운드 경로, 프로세스 모듈들 사이의 경로, 및 프로세스 모듈로부터 아웃바운드 모듈로의 경로를 예측할 수 있다. 이에 더하여, 방법은 주어진 애플리케이션에 대해 최 적의 툴 하드웨어 구성을 추천할 수 있다. 동적 스케줄러는 단계적으로 설계, 개발 및 구현된다. 제 1 단계 (phase) 는 다음과 같이 단일 신경망을 오프 라인으로 트레이닝하는 것을 포함한다. 시뮬레이터는 실제 툴들에서 실제적인 이송 시간들을 사용하여, 다양한 스케줄링 시나리오들 및 실제 툴들에서 가능할 수도 있는 웨이퍼 라우팅 경로들을 시뮬레이팅하도록 사용된다. 시뮬레이터는 상이한 툴들의 하드웨어 구성들에 기초하고 그리고 웨이퍼들을 프로세싱하기 위한 툴들에서 사용 될 수 있는 다양한 프로세스들에 기초하여 이들 시뮬레이션들을 수행한다. 웨이퍼 사이클은 수많은 데이터 세 트들을 수집하기 위해 루프 모드의 시뮬레이터에서 테스트 시나리오들에 기초하여 시뮬레이팅된다. 신경망은 머신 러닝을 사용하여 오프라인으로 트레이닝된다. 계산된 가중치들 (웨이퍼 스케줄링 및 라우팅을 최적화하기 위해 시뮬레이터에 의해 생성됨) 및 신경망 입력들은 이어서 스케줄러 페이싱 알고리즘에 피딩되고, 처리량 개 선이 동일한 대기 시간 동안 관찰된다. 제 2 단계에서, 내포된 신경망은 다음과 같이 툴들의 플릿 중 일 툴에 대해 오프라인으로 트레이닝된다. 모델 의 초기 계층에서, 모듈 레벨 신경망 (즉, 프로세싱 모듈을 위한 신경망) 은 상이한 프로세스들에 대한 프로그 램 실행 시간들을 예측하도록 트레이닝된다. 동일한 계층에서, 툴의 로봇 당 하나의 신경망이 상이한 프로세스 들에 대한 전달 시간을 예측하도록 트레이닝된다. 모델의 후속하는 계층에서, 최초 계층으로부터의 신경망들의 출력들 (즉, 프로그램 실행 시간들 및 전송 시간들에 대한 예측들) 은 스케줄러 레벨 신경망을 포함하는 다음 계층으로 입력된다. 스케줄러 레벨 신경망에 대한 입력은 다른 툴 구성들, 레시피 타입들의 혼합, 프로세스 시간들, 웨이퍼들 상에 서 프로세싱될 복수의 층들, 스케줄러 모드들, 등으로 확장된다. 모듈 레벨 신경망과 커플링된 (즉, 내포된), 확장된 입력들을 갖는 스케줄러 레벨 신경망은 툴들에 대한 소유 비용을 감소시키기 위해 최고 툴/플릿 활용도 를 달성하기 위해 최상의 제품/레시피/웨이퍼 혼합에 대한 추천들을 제공한다. 즉, 상이한 툴 하드웨어 구성들 및 상이한 레시피 타입들을 사용하여 트레이닝되는, 내포된 신경망 기반 동적 스케줄러는 이제 주어진 레시피 또는 레시피들에 대한 최적의 툴 하드웨어 구성을 추천할 수 있다. 이러한 추천들은 시뮬레이터-기반 트레이닝 만을 사용하여 제공될 수 있다. 제 3 단계는 온라인 실시간 및 비지도 학습 (unsupervised learning) 을 포함한다. 머신 러닝을 사용한 온라인 연속 신경망 트레이닝은 하나의 툴 또는 툴들의 집합으로부터의 실제 생산 데이터에 기초한다. 온라인 트레이 닝은 상기 기술된 바와 같이 시뮬레이터를 사용하여 오프라인으로 트레이닝되는 신경망들로의 입력들에 대한 가 중치들을 동적으로 조정하도록 사용된다. 프로세스 레시피들 및/또는 하드웨어가 변화할 수 있기 때문에 지속 적인 (즉, 진행중인 (ongoing)) 트레이닝이 필요하다. 이러한 변화들이 발생할 때, 모델은 변화들에 적응해야 하고, 이는 지속적인 트레이닝에 의해 달성될 수 있다. 따라서, 동적 스케줄러는 감독되는 머신 러닝으로부터 감독되지 않은 머신 러닝으로 성장하고, 실수로부터 학습하고 다음 번에 보다 나은 교육된 추정들을 하는 능력 을 개발한다. 트레이닝의 연속적인 특성으로 인해, 툴에 의해 생성된 데이터는 증분 트레이닝을 허용하도록 자동 라벨링된다. 즉, 웨이퍼들의 일 세트가 현재 프로세스에서 프로세싱된 후, 현재 프로세스로부터의 데이터는 데이터가 증분적 학습을 위해 이전 프로세스로부터의 대응하는 데이터에 더하여 또는 대신 사용될 수 있도록 자동으로 라벨링된 다. 동적 스케줄러의 이들 및 다른 양태들은 이하에 더 상세히 기술된다. 도 14 내지 도 15b를 참조하여 사용된 바와 같이, 대기 시간은 웨이퍼들의 프로세싱이 다음 프로세싱 모듈에서 시작할 수 있을 때까지 프로세싱 모듈에서 웨이퍼들의 프로세싱이 완료된 후 대기해야 하는 시간의 양이다. 대 기 시간들은 다음 프로세싱 모듈이 웨이퍼들을 프로세싱할 준비가 되지 않았을 때 발생한다 (예를 들어, 다음 프로세싱 모듈이 아직 완료되지 않았고 여전히 다른 웨이퍼들을 프로세싱하고 있기 때문에). 프로그램 실행 시 간 또는 프로세싱 시간은 프로세싱 모듈이 웨이퍼들의 프로세싱을 완료하는데 걸리는 시간의 양이다. 로봇에 대한 이송 시간은 로봇이 지점 A로부터 지점 B로 (예를 들어, 일 프로세싱 모듈로부터 다른 프로세싱 모듈로 또 는 에어 록으로부터 프로세싱 모듈로, 그리고 툴의 로딩 스테이션으로부터 에어 록으로) 웨이퍼들을 이동시키는 데 걸리는 시간의 양이다. 도 14는 툴 에서 웨이퍼 프로세싱을 스케줄링하고 페이싱하기 위해 툴 (예를 들어, 도 16에 도시 된 툴 ) 로부터의 온라인 실시간 데이터 및 오프라인 시뮬레이터 를 사용하여 내포된 신경망들로 모델 을 트레이닝하기 위한 시스템 을 도시한다. 모델 은 복수의 모듈 레벨 신경망들 및 스케줄러 레벨 신경망을 포함한다. 복수의 모듈 레벨 신경망들은 툴 의 프로세싱 모듈 각각 (예를 들어, 도 16에 도시된 프로세싱 모듈들 )에 대해 하나의 신경망 및 툴 및 툴 의 로봇 (예 를 들어, 도 16에 도시된 로봇들 (1610 및 1614)) 각각에 대한 하나의 신경망을 포함한다. 이들 신경망들은 1410-1, …, 및 1410-N으로 도시되고, 여기서 N은 1보다 큰 정수이고, 집합적으로 신경망들 로 지칭될 수도 있다. 신경망들 은 프로세싱 모듈들 (예를 들어, 도 16에 도시된 프로세싱 모듈들 ) 에 대 한 프로그램 실행 시간들에 대한 예측들 및 (예를 들어, 도 16에 도시된 로봇들 (1610 및 1614) 에 대한) 로봇 이송 시간들에 대한 예측들을 출력한다. 스케줄러 레벨 신경망은 1412로 도시되고 신경망들 의 출력들을 입력들로서 수신한다. 스케줄러 레벨 신경망 은 툴 내의 프로세싱 모듈들 사이에서 웨이퍼들의 라우팅을 스케줄링하고 프로세싱을 위해 다음 웨이퍼들의 쌍을 툴로 이송할 때에 대한 예측을 출력한다. 신경망들 및 스케줄러 레벨 신경망 은 처음에 시뮬레이터 상에서 트레이닝 동안 그리고 후속하여 실제 사용 및 툴 상에서 계속된 트 레이닝 동안 (예를 들어, 도 16에 도시된 시스템 제어기 에 의해 구현되거나 시스템 제어기 와 통합될 때) 각각의 예측들을 출력한다. 단지 예를 들면, 시뮬레이터 는 하나 이상의 하드웨어 프로세서들 (예를 들어, CPU들) 및 컴퓨터 상의 툴 (예를 들어, 툴 ) 의 동작 및 프로세싱 환경을 시뮬레이팅하는 하나 이상의 컴퓨터 프로그램들을 저장 하는 하나 이상의 메모리 디바이스들을 포함하는 컴퓨터와 같은 컴퓨팅 디바이스를 사용하여 구현될 수도 있다. 컴퓨터 프로그램들은 도 15a 및 도 15b를 참조하여 이하에 설명된 바와 같이 시뮬레이터 상에서 모델 의 신경망들 및 스케줄러 레벨 신경망 을 생성하고, 트레이닝하고, 검증하기 위한 인스트 럭션들을 부가적으로 포함한다. 하나 이상의 하드웨어 프로세서들은 하나 이상의 컴퓨터 프로그램들을 실행한 다. 시뮬레이터 및 툴 은 하나 이상의 네트워크들에 의해 통신 가능하게 상호 연결될 수도 있다. 예 를 들어, 네트워크들은 LAN, WAN, 인터넷, 클라우드-기반 네트워크 시스템, 또는 임의의 다른 분산된 통신 시스 템 (예를 들어, 클라이언트-서버 아키텍처에 기초한 네트워크 시스템) 을 포함할 수도 있다. 예를 들어, 시뮬레이터 는 도 18에 도시된 팹 데이터 수집 시스템 을 사용하여 툴 로부터 데이터를 수집/수신할 수도 있다. 단 하나의 툴이 도 14에 도시되지만, 데이터는 2 개 이상의 툴로부터 수집/ 수신될 수도 있다. 하나 이상의 툴들은 동일한 고객 위치에 위치될 수도 있다. 하나 이상의 툴들은 동일한 고 객의 상이한 위치들에 위치될 수도 있다. 하나 이상의 툴들은 상이한 고객들의 위치들에 위치될 수도 있다. 툴들로부터 수집된 데이터는 고객들의 독점 및 기밀 데이터를 제외하지만 모델을 생성하고 트레이닝하는데 사용 될 수 있는 다른 모든 동작 데이터를 포함한다. 단지 예를 들면, 데이터가 수집되는 툴 은 복수의 병렬 재료 증착 (예를 들어, 도금) 프로세스들을 수행 할 수도 있고 다음의 구성을 가질 수도 있다. 툴은 최대 2 개의 데크들 및 2 개의 로봇들을 포함할 수도 있고, 데크 각각은 복수의 프로세싱 모듈들을 포함한다. 예를 들어, 복수의 프로세싱 모듈들은 도금 프로세스들을 수 행하기 위한 하나의 사전-프로세싱 모듈, 하나의 사후-프로세싱 모듈, 및 4 개의 프로세싱 모듈들을 포함할 수도 있다. 툴은 툴 내의 웨이퍼 프로세싱을 제어하기 위한 스케줄러를 더 포함할 수도 있다. 프로세스들은 단 일 층 도금 또는 다층 도금을 포함할 수도 있다. 시뮬레이터 는 툴 구성을 시뮬레이팅하고 툴 내의 웨이퍼들의 프로세싱을 시뮬레이팅한다. 시뮬레이터 는 웨이퍼들의 프로세싱을 시뮬레이팅함으로써 시뮬레이터 에 의해 생성된 데이터를 사용하여 모 델 의 신경망들 (1410 및 1412) 을 생성, 트레이닝 및 검증하기 위해 머신 러닝을 사용하는 시스템 또는 시스템들을 포함한다. 트레이닝된 모델 을 사용하여, 툴의 스케줄러는 최상의 처리량 및 대기 시간을 제공하면서 웨이퍼들의 프로세싱을 스케줄링할 수 있다. 트레이닝된 모델 은 또한 주어진 애플리케이션 에 사용될 툴에 대한 최적의 하드웨어 구성을 추천할 수 있다. 도 15a 및 도 15b는 툴들에서 웨이퍼 프로세싱을 스케줄링하고 페이싱하기 위해 오프라인 시뮬레이터 및 온라인 실시간 툴 데이터를 사용하여 내포된 신경망들을 사용하여 모델을 생성하고 트레이닝하기 위한 방법 을 도시한다. 예를 들어, 도 14에 도시된 시스템 의 하나 이상의 시뮬레이터 가 있고 툴 (예를 들어, 도 16에 도시된 엘리먼트 ) 의 시스템 제어기는 방법 의 다음의 단계들 중 하나 이상 을 실행할 수도 있다. 1502에서, 방법 은 툴의 웨이퍼들 상에서 수행될 프로세스 (예를 들어, 다층 도금) 의 레시피 및 툴의 하드웨어 구성에 관한 데이터를 획득한다. 1504에서, 획득된 데이터에 기초하여 시뮬레이터를 사용하여, 방법 은 웨이퍼들을 프로세싱하기 위한 다양한 라우팅 및 스케줄링 시나리오들을 시뮬레이팅한다. 1506에서, 시뮬레이터를 사용하여, 방법 은 다양한 라우팅 및 스케줄링 시나리오들을 사용하여 웨이퍼 프로세싱을 시뮬레이팅한다. 1508에서, 방법 은 시뮬레이터를 사용하여 수행된 시뮬레이팅된 웨이퍼 프로세싱으로부터 데이터를 수집 한다. 1510에서, 수집된 데이터를 사용하여, 방법 은 복수의 신경망들을 설계하고 트레이닝한다. 복수 의 네트워크들은 툴 내의 프로세싱 모듈들 각각에 대한 하나의 신경망, 툴 내의 로봇 각각에 대한 하나의 신경 망, 및 툴 내에서 웨이퍼들을 라우팅하고 툴에서 웨이퍼들의 다음 세트를 프로세싱할 때를 스케줄링하도록 툴에 의해 사용되는 스케줄러를 위한 하나의 신경망을 포함한다. 예를 들어, 신경망들을 생성하고 트레이닝하기 위 한 방법은 도 6 내지 도 11을 참조하여 기술된 방법과 유사할 수도 있다. 1512에서, 방법 은 각각의 신경망들을 사용하여 프로세싱 모듈 각각에 대한 프로그램 실행 시간들을 예 측하고 로봇 이송 시간들을 예측한다. 1514에서, 방법 은 툴로부터 획득된 데이터를 사용하여 프로세싱 모듈들 및 로봇들에 대한 신경망들을 검증한다. 1516에서, 방법 은 프로세싱 모듈들 및 로봇들에 대한 신경망들이 성공적으로 검증되었는지를 결정한다. 예를 들어, 신경망들을 검증하기 위한 방법은 도 6 내지 도 11을 참조하여 기술된 방법과 유사할 수도 있다. 예를 들어, 검증을 위한 기준들은 신경망들의 수렴 특성들이 프로그램 실행 시간들 및 로봇 이송 시간들을 얼마 나 정확하게 예측할 수 있는지에 기초할 수도 있다. 프로세싱 모듈들 및 로봇들에 대한 신경망들이 성공적으로 검증되지 않으면, 방법 은 추가 트레이닝을 위해 1508로 돌아간다. 1518에서, 프로세싱 모듈들 및 로봇들에 대한 신경망들이 성공적으로 검증되면, 시뮬레이터를 사용하여 방법 은 처리량 및 대기 시간을 최적화하기 위해 신경망들에 의해 생성된 예측된 시간들 및 가중치들을 스케 줄러 레벨 신경망에 입력한다. 1520에서, 스케줄러 레벨 신경망을 사용하여, 방법 은 툴 내의 웨이퍼들 의 다음 세트의 프로세싱을 스케줄링할 때를 포함하는, 웨이퍼 라우팅 및 스케줄링 데이터를 예측한다. 1524에서, 스케줄러 레벨 신경망을 검증하기 위한 방법은 도 6 내지 도 11을 참조하여 기술된 방법과 유사할 수 도 있다. 예를 들어, 검증을 위한 기준들은 스케줄러 레벨 신경망이 웨이퍼 라우팅 및 스케줄링을 얼마나 정확 하게 예측할 수 있는지에 기초할 수도 있다. 스케줄러 레벨 신경망이 성공적으로 검증되지 않으면, 방법 은 시뮬레이터를 사용하여 스케줄러 레벨 신경망을 더 트레이닝하도록 1518로 돌아간다. 1526에서, 스케줄러 레벨 신경망이 성공적으로 검증되면, 프로세싱 모듈들, 로봇들, 및 스케줄러를 위한 모든 신경망들을 포함하는 모델은 툴의 제어기 (예를 들어, 도 16에 도시된 엘리먼트 ) 내로 통합된다. 모델 은 이제 툴 상에서, 프로그램 실행 시간들, 로봇 이송 시간들 및 웨이퍼 라우팅 및 스케줄링을 예측할 수 있다. 1528에서, 모델은 툴로부터의 실제 생산 데이터를 사용하여 온라인으로 (즉, 인 시츄로 (in situ), 툴 상에서) 점진적으로 트레이닝하는 것을 계속한다. 웨이퍼들의 현재 세트의 프로세싱으로부터 자동으로 라벨링된 데이터 는 툴 상에서 모델을 점진적으로 그리고 연속적으로 트레이닝하기 위해 웨이퍼들의 이전 세트의 프로세싱으로부터 대응하는 데이터에 더하여 또는 대신 사용된다. 도 16은 복수의 프로세싱 모듈들 을 포함하는 툴 의 일 예를 도시한다. 예를 들어, 툴 은 하부 데크 및 상부 데크를 포함할 수도 있다. 툴 이 총 8 개의 프로세싱 모듈들 을 포함할 수도 있도록 데크 각각은 4 개의 프로세싱 모듈들 을 포함할 수도 있다. 대안적으로, 툴 이 총 16 개의 프로세싱 모듈들 을 포함할 수도 있도록, 데크 각각은 도시된 바와 같이 (단 하나의 데크가 도 시됨) 8 개의 프로세싱 모듈들 을 포함할 수도 있다. 예를 들어, 프로세싱 모듈들 은 전기 도금 셀들 (예를 들어, 도 17 참조) 을 포함할 수도 있다. 부가적으로 데크 각각은 또한 복수의 사전-프로세싱 모듈 및 사후 프로세싱 모듈들 을 포함할 수도 있다. 전기 도금에 더하여, 툴 은 스핀 린싱, 스핀 건 조, 습식 에칭, 사전-습식 및 사전-화학적 처리, 무전해 디포지션, 환원, 어닐링, 포토 레지스트 스트립핑, 표 면 사전-활성화, 등을 수행할 수도 있다. 복수의 기판들 은 FOUP (front opening unified pod) 를 통해 툴 내로 피딩된다. 프론 트-엔드 로봇 은 FOUP 로부터 스핀들 로 그리고 이어서 사전-프로세싱 모듈들 중 하나로 기판들 을 이송한다. 사전-프로세싱 후, 백엔드 로봇 은 전처리 모듈들 로부터 전기 도금을 위해 프로세싱 모듈들 중 하나 이상으로 기판들 을 이송한다. 그 후, 백엔드 로봇 은 기판들 을 사후-프로세싱 모듈들 중 하나로 이송한다. 툴 은 프론트-엔드 로봇 및 백엔드 로봇 (1610, 1614) 및 프로세싱 모듈들 (1602, 1604) 에서 수행된 프로세스들을 제어하는 시스템 제어기 를 더 포함한다. 제어기 는 상기 기술된 트레이닝된 모델 및 동적 스케줄러 페이싱 방법을 사용하여 기판들 의 프로세싱을 스케줄링하고 제어한다. 도 17은 프로세싱 모듈 의 일 예를 도시한다. 예를 들어, 프로세싱 모듈 은 전기 도금 셀 을 포함한다. 전기 도금 셀 은 분리된 애노드 챔버 (separated anode chamber; SAC) 내 에 애노드 를 포함한다. SAC 는 멤브레인에 의해 전기 도금 셀 의 나머지로부터 분리된 다. SAC 는 전기 도금 셀 의 나머지에 제 2 액체와 상이한 화학 물질을 갖는 제 1 액체를 포함 한다. 전기 도금 셀 은 HRVA (high resistance virtual anode) (마운팅 어셈블리는 도시되지 않음) 를 더 포함한다. 전기 도금 동안, HRVA 는 웨이퍼가 전기 도금 셀 의 상단부로부터 전기 도금 셀 내로 하강될 때 웨이퍼 (미도시) 의 부분들로 제 2 액체의 플로우를 지향시킨다. 주 배스 (main bath) (저장부 (reservoir)) 는 펌프 및 필터 를 통해 전기 도금 셀 내로 제 2 액체를 공급한다. 타워 는 펌프 를 사용하여 제 1 액체로 SAC 를 충진한다. 프로세싱 모듈 은 임의의 다른 타입의 전기 도금 셀을 포함할 수도 있다. 도 18은 팹 데이터 수집 시스템 의 일 예를 도시한다. 예를 들어, 시스템 은 툴 과 같은 하나 이상의 툴들을 사용하는 반도체 제작 설비의 공장 LAN (local area network) 에 연결된 호스트 컴 퓨터 , 데이터 수집기 , 및 모니터링 컴퓨터 를 포함한다. 호스트 컴퓨터 는 하나 이상의 툴들 (예를 들어, 툴 ) 과 통신한다. 호스트 컴퓨터 는 툴 에 명령들을 발행하고, 레시피 등을 제공하도록 오퍼레이터에 의해 사용된다. 데이터 수집기 는 툴 과 호스트 컴퓨터 의 통신을 방해하지 않고 툴 로부터 다양 한 타입들의 데이터를 수신한다. 모니터링 컴퓨터 는 툴 성능을 보고 모니터링하기 위해 사용된다. 모 니터링 컴퓨터 는 툴 설정들을 그래픽으로 나타내고 다양한 툴 파라미터들의 값들을 판독한다. 모니터 링 컴퓨터 는 툴 과의 문제들을 해결하기 위해 사용된다. 호스트 컴퓨터 는 데이터 수집 기 및 모니터링 컴퓨터 와 통신한다. 시스템 은 장비 LAN 을 통해 툴 에 연결된 서버 를 더 포함한다. 서버 는 공장 LAN 을 통해 호스트 컴퓨터 와 통신한다. 서버 는 툴 로부터 데이터를 수집하고 호스트 컴퓨터 로 데이터를 공급한다. 하나 이상의 사용자 인터페이스 (UI) 컴퓨터들 은 툴 의 로더 측과 반대되는 툴 측 상에 위치된다. 오퍼레이터가 툴 을 동작시키는 UI 컴퓨터 측은 클래스 1000 클린인 반면, 로더 측은 클래스 100 클린이다. UI 컴퓨터들 은 장비 LAN 에 연결된다. 모니터링 컴퓨터 는 장비 LAN 을 통해 툴 에 연결된다. 모니터링 컴퓨터 는 툴 을 모니터링하고 공장 LAN 을 통해 모니터링 컴퓨터 와 통신한다. 툴 의 시스템 제어기 (예를 들어, 시스템 제어기 ) 는 툴 을 제어한다. 복수의 모듈 제어기들 이 개별 프로세싱 모듈들 (1602, 1604) 을 제어한다. 복수의 입력/출력 (I/O) 제어기들 은 프로세싱 모듈들 (1602, 1604) 의 개별 동작들을 제어한다. 시스템 제어기 는 또한 (예를 들 어, 로봇들 (1610, 1614) 을 제어하기 위해; 그리고 툴의 프로세싱 모듈들 (1602, 1604) 이외의 피처들을 제어 하기 위해) I/O 제어기들 중 하나 이상과 통신한다. 다양한 스위치들 이 적절한 I/O 제어기들 에 액세스하도록 사용된다. 도 14 내지 도 17을 참조하여 상기 기술된 기능들 및 동작들은 시스템 제어기 , 모니터링 컴퓨터 , 또는 모두에 의해 수행될 수도 있다. 부가적으로 또는 대안적으로, 도 18을 참조하여 기술된 다른 컴퓨팅 디바 이스들은 또한 도 14 내지 도 17을 참조하여 상기 기술된 기능들 및 동작들 중 적어도 일부를 수행할 수도 있다. 전술한 기술은 본질적으로 단지 예시적이고 본 개시, 이의 적용, 또는 사용들을 제한하도록 의도되지 않는다. 본 개시의 광범위한 교시들은 다양한 형태들로 구현될 수 있다. 따라서, 본 개시가 특정한 예들을 포함하지만, 본 개시의 진정한 범위는 도면들, 명세서, 및 이하의 청구항들의 연구시 자명해질 것이기 때문에 그렇게 제한되 지 않아야 한다. 방법 내의 하나 이상의 단계들은 본 개시의 원리들을 변경하지 않고 상이한 순서로 (또는 동시에) 실행될 수도 있다는 것이 이해되어야 한다. 또한, 실시 예들 각각이 특정한 특징들을 갖는 것으로 상기 기술되었지만, 본 개시의 임의의 실시 예에 대해 기술된 임의의 하나 이상의 이들 특징들은, 임의의 다른 실시 예들의 특징들로 구현될 수 있고 그리고/또는 조합이 명시적으로 기술되지 않더라도 결합될 수 있다. 즉, 기술된 실시 예들은 상호 배타적이지 않고, 서로에 대한 하나 이상의 실시 예들의 치환들은 본 개시의 범위 내에 있다. 엘리먼트들 사이 (예를 들어, 모듈들, 회로 엘리먼트들, 반도체 층들, 등 사이) 의 공간적 및 기능적 관계들은 \"연결된\", \"인게이지된 (engaged)\", \"커플링된\", \"인접한 (adjacent)\", \"옆에 (next to)\", \"상에 (on top of)\", \"위에\", \"아래에\" 그리고 \"배치된 (disposed)\"을 포함하는, 다양한 용어들을 사용하여 기술된다. 상기 개시에서 제 1 엘리먼트와 제 2 엘리먼트 사이의 관계가 기술될 때 \"직접적인\"것으로 명시적으로 기술되지 않는 한, 이 관계는 제 1 엘리먼트와 제 2 엘리먼트 사이에 다른 중개 엘리먼트가 존재하지 않는 직접적인 관계일 수 있지만, 또한 제 1 엘리먼트와 제 2 엘리먼트 사이에 하나 이상의 중개 엘리먼트들이 (공간적으로 또는 기능적 으로) 존재하는 간접적인 관계일 수 있다. 본 명세서에 사용된 바와 같이, 구 A, B 및 C 중 적어도 하나는 비 배타적인 논리 OR를 사용하는 논리 (A OR B OR C) 를 의미하도록 해석되어야 하고, \"적어도 하나의 A, 적어도 하나의 B, 및 적어도 하나의 C\"를 의미하는 것으로 해석되지 않아야 한다. 일부 구현 예들에서, 제어기는 상기 기술된 예들의 일부일 수도 있는 시스템의 일부이다. 이러한 시스템들은, 프로세싱 툴 또는 툴들, 챔버 또는 챔버들, 프로세싱용 플랫폼 또는 플랫폼들, 및/또는 특정 프로세싱 컴포넌트 들 (웨이퍼 기판 지지부, 가스 플로우 시스템, 등) 을 포함하는, 반도체 프로세싱 장비를 포함할 수 있다. 이 들 시스템들은 반도체 웨이퍼 또는 기판의 프로세싱 이전에, 프로세싱 동안에 그리고 프로세싱 이후에 그들의 동작을 제어하기 위한 전자장치와 통합될 수도 있다. 전자 장치는 시스템 또는 시스템들의 다양한 컴포넌트들 또는 서브 부품들을 제어할 수 있는 \"제어기\"로 지칭될 수도 있다. 예를 들어, 제어기는, 시스템의 프로세싱 요건들 및/또는 타입에 따라서, 프로세싱 가스들의 전달, 온도 설정사 항들 (예를 들어, 가열 및/또는 냉각), 압력 설정사항들, 진공 설정사항들, 전력 설정사항들, 무선 주파수 (RF) 생성기 설정사항들, RF 매칭 회로 설정사항들, 주파수 설정사항들, 플로우 레이트 설정사항들, 유체 전달 설정 사항들, 위치 및 동작 설정사항들, 툴 및 다른 이송 툴들 및/또는 특정 시스템과 연결되거나인터페이싱된 로드 록들 내외로의 웨이퍼 이송들을 포함하는, 본 명세서에 개시된 프로세스들 중 임의의 프로세스들을 제어하도록 프로그래밍될 수도 있다. 일반적으로 말하면, 제어기는 인스트럭션들을 수신하고, 인스트럭션들을 발행하고, 동작을 제어하고, 세정 동작 들을 인에이블하고, 엔드 포인트 측정들을 인에이블하는, 등을 하는 다양한 집적 회로들, 로직, 메모리, 및/또 는 소프트웨어를 갖는 전자 장치로서 규정될 수도 있다. 집적 회로들은 프로그램 인스트럭션들을 저장하는 펌 웨어의 형태의 칩들, 디지털 신호 프로세서들 (DSP), ASICs (Application Specific Integrated Circuits) 로서 규정되는 칩들, 및/또는 프로그램 인스트럭션들 (예를 들어, 소프트웨어) 을 실행하는 하나 이상의 마이크로프 로세서들, 또는 마이크로제어기들을 포함할 수도 있다. 프로그램 인스트럭션들은 반도체 웨이퍼 상에서 또는 반도체 웨이퍼에 대한 특정 프로세스를 실행하기 위한 동 작 파라미터들을 규정하는, 다양한 개별 설정사항들 (또는 프로그램 파일들) 의 형태로 제어기로 또는 시스템으로 전달되는 인스트럭션들일 수도 있다. 일부 실시 예들에서, 동작 파라미터들은 하나 이상의 층들, 재료들, 금속들, 산화물들, 실리콘, 실리콘 이산화물, 표면들, 회로들, 및/또는 웨이퍼의 다이들의 제조 동안에 하나 이 상의 프로세싱 단계들을 달성하도록 프로세스 엔지니어들에 의해서 규정된 레시피의 일부일 수도 있다. 제어기는, 일부 구현 예들에서, 시스템과 통합되거나, 시스템에 커플링되거나, 이와 달리 시스템에 네트워킹되 거나, 또는 이들의 조합으로될 수 있는 컴퓨터에 커플링되거나 이의 일부일 수도 있다. 예를 들어, 제어기는 웨이퍼 프로세싱의 원격 액세스를 인에이블할 수 있는 팹 (fab) 호스트 컴퓨터 시스템의 전부 또는 일부이거나 \"클라우드\" 내에 있을 수도 있다. 컴퓨터는 제조 동작들의 현 진행을 모니터링하고, 과거 제조 동작들의 이력 을 조사하고, 복수의 제조 동작들로부터 경향들 또는 성능 계측치들을 조사하고, 현 프로세싱의 파라미터들을 변경하고, 현 프로세싱을 따르는 프로세싱 단계들을 설정하고, 또는 새로운 프로세스를 시작하기 위해서 시스템 으로의 원격 액세스를 인에이블할 수도 있다. 일부 예들에서, 원격 컴퓨터 (예를 들어, 서버) 는 로컬 네트워크 또는 인터넷을 포함할 수도 있는 네트워크를 통해 프로세스 레시피들을 시스템에 제공할 수 있다. 원격 컴퓨터는 차후에 원격 컴퓨터로부터 시스템으로 전 달될 파라미터들 및/또는 설정사항들의 입력 또는 프로그래밍을 인에이블하는 사용자 인터페이스를 포함할 수도 있다. 일부 예들에서, 제어기는 하나 이상의 동작들 동안 수행될 프로세싱 단계들 각각에 대한 파라미터들을 특정하는, 데이터의 형태의 인스트럭션들을 수신한다. 파라미터들은 수행될 프로세스의 타입 및 제어기가 인터 페이싱하거나 제어하도록 구성된 툴의 타입에 특정적일 수도 있다는 것이 이해되어야 한다. 따라서, 상기 기술된 바와 같이, 제어기는 예를 들어, 함께 네트워킹되고 공통 목적, 예컨대 본 명세서에 기술 된 프로세스들 및 제어들을 향해 작동하는 하나 이상의 개별 제어기들을 포함함으로써 분산될 수도 있다. 이러 한 목적들을 위한 분산형 제어기의 예는 챔버 상의 프로세스를 제어하도록 결합하는 (예를 들어, 플랫폼 레벨에 서 또는 원격 컴퓨터의 일부로서) 원격으로 위치된 하나 이상의 집적 회로들과 통신하는 챔버 상의 하나 이상의 집적 회로들일 것이다. 비한정적으로, 예시적인 시스템들은 플라즈마 에칭 챔버 또는 모듈, 증착 챔버 또는 모듈, 스핀-린스 챔버 또는 모듈, 금속 도금 챔버 또는 모듈, 세정 챔버 또는 모듈, 베벨 에지 에칭 챔버 또는 모듈, PVD (Physical Vapor Deposition) 챔버 또는 모듈, CVD (Chemical Vapor Deposition) 챔버 또는 모듈, ALD (atomic layer deposition) 챔버 또는 모듈, ALE (atomic layer etch) 챔버 또는 모듈, 이온 주입 챔버 또는 모듈, 트랙 (track) 챔버 또는 모듈, 및 반도체 웨이퍼들의 제조 및/또는 제작 시에 사용되거나 연관될 수도 있는 임의의 다른 반도체 프로세싱 시스템들을 포함할 수도 있다. 상술한 바와 같이, 툴에 의해서 수행될 프로세스 단계 또는 단계들에 따라서, 제어기는, 반도체 제작 공장 내의 툴 위치들 및/또는 로드 포트들로부터 그리고 툴 위치들 및/또는 로드 포트들로 웨이퍼들의 컨테이너들을 이동 시키는 재료 이송 시에 사용되는, 다른 툴 회로들 또는 모듈들, 다른 툴 컴포넌트들, 클러스터 툴들, 다른 툴인 터페이스들, 인접 툴들, 이웃하는 툴들, 공장 도처에 위치한 툴들, 메인 컴퓨터, 또 다른 제어기, 또는 툴들 중 하나 이상과 통신할 수도 있다.도면 도면1 도면2 도면3 도면4 도면5a 도면5b 도면5c 도면6 도면7 도면8 도면9 도면10 도면11 도면12 도면13 도면14 도면15a 도면15b 도면16 도면17 도면18"}
{"patent_id": "10-2021-7035239", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시는 상세한 기술 및 첨부된 도면들로부터 보다 완전히 이해될 것이다. 도 1은 하나 이상의 프로세싱 챔버들을 포함하는 기판 프로세싱 툴의 일 예의 기능적 블록도이다. 도 2는 프로세싱 챔버를 포함하는 기판 프로세싱 시스템의 일 예의 기능적 블록도이다. 도 3은 데이터 수집 시스템의 일 예의 기능적 블록도이다. 도 4는 기판 프로세싱 툴의 웨이퍼 프로세싱 동작들을 스케줄링하기 위해 머신-러닝 보조된 모델을 생성하고 트 레이닝하기 위한 시스템의 기능적 블록도를 도시한다. 도 5a 내지 도 8은 머신-러닝 보조된 모델을 생성하고 트레이닝하기 위한 방법을 도시한다. 도 9 내지 도 11은 본 명세서에 기술된 모델들을 생성하기 위해 사용된 심층 신경망의 예를 도시한다. 도 12는 개별 이벤트 시뮬레이터를 사용하여 강화 학습 모델을 트레이닝하기 위한 시스템의 기능적 블록도를 도 시한다. 도 13은 개별 이벤트 시뮬레이터를 사용하여 강화 학습 모델을 트레이닝하기 위한 방법을 도시한다. 도 14는 툴들에서 웨이퍼 프로세싱을 스케줄링하고 페이싱하기 위한 툴로부터의 온라인 실시간 데이터 및 오프라인 시뮬레이터를 사용하여 내포된 신경망들 (nested neural networks) 로 모델을 트레이닝하기 위한 시스템을 도시한다. 도 15a 및 도 15b는 툴들에서 웨이퍼 프로세싱을 스케줄링하고 페이싱하기 위해 오프라인 시뮬레이터 및 온라인 실시간 툴 데이터를 사용하여 중첩된 신경망들을 사용하여 모델을 트레이닝하기 위한 방법을 도시한다. 도 16은 복수의 프로세싱 모듈들 (예를 들어, 전기 도금 셀들) 을 포함하는 툴의 일 예를 도시한다. 도 17은 도 16의 툴에 사용된 프로세싱 모듈 (예를 들어, 전기 도금 셀) 의 일 예를 도시한다. 도 18은 툴들 (예를 들어, 도 16의 툴) 에서 웨이퍼 프로세싱을 스케줄링하고 페이싱하기 위한 모델을 트레이닝 하기 위해 도 14의 오프라인 시뮬레이터와 함께 사용된 팹 데이터 수집 시스템의 일 예를 도시한다. 도면들에서, 참조 번호들은 유사하고 그리고/또는 동일한 엘리먼트들을 식별하기 위해 재사용될 수도 있다."}
