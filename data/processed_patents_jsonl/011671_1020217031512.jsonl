{"patent_id": "10-2021-7031512", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0134363", "출원번호": "10-2021-7031512", "발명의 명칭": "신경망 기반 양자 에러 정정 복호화 방법 및 장치, 칩", "출원인": "텐센트 테크놀로지", "발명자": "정 이총"}}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "신경망 기반 양자 에러 정정 복호화 방법에 있어서,양자 회로의 에러 신드롬 정보를 획득하는 단계 - 상기 에러 신드롬 정보는 양자 에러 정정 부호의 스태빌라이저 생성기의 고유치에 의해 형성된 데이터 어레이임 -;특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 상기 에러 신드롬 정보에 대한 블록 특징 추출을 수행하는 단계 - 상기 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 상기 블록 특징 추출을 수행하도록구성되고, 상기 블록 특징 추출은, 상기 입력된 데이터가 적어도 두 개의 블록으로 분할된 후, 적어도 두 개의특징 추출부를 사용하여 상기 적어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구성됨 -; 그리고에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를수행하는 단계 - 상기 에러 결과 정보는 에러가 발생하는 상기 양자 회로 내의 데이터 큐비트 및 대응하는 에러유형을 결정하는 데 사용됨 -를 포함하는 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 신경망 디코더는 m개의 캐스케이드된 특징 추출 레이어를 포함하고, m은 양의 정수이고;상기 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 상기 에러 신드롬 정보에 대한 블록 특징 추출을수행하는 단계는,상기 특징 정보를 획득하기 위해, 상기 m개의 상기 특징 추출 레이어를 사용하여 상기 에러 신드롬 정보에 대해블록 특징 추출을 수행하는 단계를 포함하고,상기 제1 특징 추출 레이어는 상기 에러 신드롬 정보에 대해 블록 특징 추출을 수행하도록 구성되고, 상기 i번째 특징 추출 레이어는 이전 특징 추출 레이어의 특징 추출 결과에 대해 블록 특징 추출을 수행하도록구성되며, i는 1보다 크고, m보다 작거나 같은 정수인, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 에러 신드롬 정보는 T개의 데이터 어레이를 포함하고, 각 데이터 어레이는 상기 양자 에러 정정 부호를 사용하여 상기 양자 회로에 대해 하나의 에러 신드롬 측정을 수행함으로써 획득되고, T는 1보다 큰 정수이고;양자 회로의 상기 에러 신드롬 정보를 획득하는 단계 이후, 상기 신경망 기반 양자 에러 정정 복호화 방법은,상기 에러 신드롬 정보를 적어도 두 개의 데이터 단위로 분류하는 단계를 더 포함하고,하나의 데이터 단위는 상기 T개의 데이터 어레이 내의 동일한 위치에 T개의 어레이 유닛을 포함하는, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 에러 신드롬 정보는 상기 양자 에러 정정 부호를 사용하여 상기 양자 회로 상의 노이즈를 가진 에러 신드롬 측정을 수행하여 획득된 실제 에러 신드롬 정보이고; 상기 신경망 디코더는 제1 디코더 및 제2 디코더를 포함하고;상기 제1 디코더는, 상기 실제 에러 신드롬 정보에 대응하는 논리 에러 클래스를 획득하기 위해, 상기 실제 에공개특허 10-2021-0134363-3-러 신드롬 정보를 복호화하도록 구성되고, 상기 논리 에러 클래스는 상기 양자 회로 내에서 발생한 에러가 매핑된 후에 획득된 클래스이고;상기 제2 디코더는, 상기 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보를 획득하기 위해, 상기 실제 에러 신드롬 정보를 복호화하도록 구성되고, 상기 완전 에러 신드롬 정보는 상기 양자 회로 상의 노이즈 없이 에러 신드롬 측정을 수행하여 획득된 정보이고;에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를수행하는 단계 이후, 상기 신경망 기반 양자 에러 정정 복호화 방법은,상기 논리 에러 클래스 및 상기 완전 에러 신드롬 정보에 따라, 상기 에러가 상기 양자 회로 내에서 발생하는상기 데이터 큐비트 및 상기 대응하는 에러 유형을 결정하는 단계를 더 포함하는, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서,상기 논리 에러 클래스 및 상기 완전 에러 신드롬 정보에 따라, 상기 에러가 상기 양자 회로 내에서 발생하는상기 데이터 큐비트 및 상기 대응하는 에러 유형을 결정하는 단계는,상기 논리 에러 클래스에 대응하는 제1 에러 결과를 획득하는 단계;상기 완전 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득하는 단계; 그리고상기 제1 에러 결과 및 상기 제2 에러 결과에 따라, 상기 에러가 상기 양자 회로 내에서 발생하는 상기 데이터큐비트 및 상기 대응하는 에러 유형을 결정하는 단계를 포함하는, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제4항에 있어서,상기 논리 에러 클래스에 대응하는 제1 에러 결과를 획득하는 단계는,상기 논리 에러 클래스 내에 포함된 요소들로부터의 임의의 요소를 상기 제1 에러 결과로 선택하는 단계를 포함하고,상기 논리 에러 클래스는 적어도 하나의 등가 에러 요소를 포함하는, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제4항에 있어서,상기 완전 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득하는 단계는,상기 완전 에러 신드롬 정보 내의 에러 신드롬 포인트에 각각 대응하는 단순 에러를 획득하기 위해 매핑 테이블을 룩업하는 단계 - 상기 매핑 테이블은 에러 신드롬 포인트의 적어도 하나의 그룹 및 단순 에러 사이의 매핑관계를 포함함 -; 그리고상기 제2 에러 결과를 획득하기 위해, 상기 에러 신드롬 포인트에 각각 대응하는 단순 에러를 곱하는 단계를 포함하는, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제4항에 있어서,상기 제1 에러 결과 및 상기 제2 에러 결과에 따라, 상기 에러가 상기 양자 회로 내에서 발생하는 상기 데이터큐비트 및 상기 대응하는 에러 유형을 결정하는 단계는,상기 에러가 상기 양자 회로 내에서 발생하는 상기 데이터 큐비트 및 상기 대응하는 에러 유형을 획득하기공개특허 10-2021-0134363-4-위해, 상기 제1 에러 결과와 상기 제2 에러 결과의 곱을 계산하는 단계를 포함하는, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제4항에 있어서,k개의 제2 디코더가 있고, k는 양의 정수이고 k는 상기 양자 에러 정정 부호의 길이와 관련되고;k개의 상기 제2 디코더는, k개의 완전 에러 신드롬 비트를 획득하기 위해, 상기 실제 에러 신드롬 정보를 각각복호화하도록 구성되며;k개의 상기 완전 에러 신드롬 비트는 상기 완전 에러 신드롬 정보를 획득하기 위한 병합을 수행하는 데 사용되는, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1항에 있어서,상기 신경망 디코더의 트레이닝 데이터는,샘플 양자 회로 내에 포함된 물리 큐비트 상에 에러를 확률적으로 생성시키는 단계;상기 샘플 양자 회로에 대응하는 보조 큐비트 상에 에러를 확률적으로 생성시키는 단계 - 상기 보조 큐비트는상기 샘플 양자 회로의 에러 신드롬 정보를 획득하기 위한 측정을 수행하는 데 사용됨 -;상기 샘플 양자 회로에 대응하는 고유치 측정 회로 내에 포함된 제어된 NOT 게이트 상에 에러를 확률적으로 생성시키는 단계 - 상기 고유치 측정 회로는 스태빌라이저 생성기의 고유치를 측정하도록 구성됨 -;에러 신드롬 측정이 양자 에러 정정 부호를 사용하여 상기 샘플 양자 회로에 대해 수행되는 경우 측정 에러를확률적으로 생성시키는 단계; 그리고상기 샘플 양자 회로의 상기 에러 신드롬 정보 및 에러 결과 정보를 획득하고, 상기 트레이닝 데이터를 생성하는 단계에 의해 생성되는, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제1항에 있어서,상기 신경망 디코더의 트레이닝 데이터는,샘플 양자 회로에 대해 양자 프로세스 토모그래피를 수행하고, 상기 샘플 양자 회로의 노이즈 모델을 추출하는단계;상기 노이즈 모델에 기반한 노이즈의 작용 하에 상기 샘플 양자 회로의 양자 상태의 진화를 시뮬레이션하는 단계; 그리고상기 샘플 양자 회로의 상기 에러 신드롬 정보 및 에러 결과 정보를 획득하고, 상기 트레이닝 데이터를 생성하는 단계에 의해 생성되는, 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1항 내지 제11항 중 어느 한 항에 있어서,에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를수행하는 단계 이후, 상기 신경망 기반 양자 에러 정정 복호화 방법은,상기 에러 결과 정보에 따라 에러-정정 제어 신호를 생성하는 단계 - 상기 에러-정정 제어 신호는 상기 양자 회로에 의해 생성된 에러를 정정하기 위해 사용됨 -; 그리고공개특허 10-2021-0134363-5-상기 에러-정정 제어 신호를 상기 양자 회로에게 전송하는 단계를 더 포함하는 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "컴퓨터 기기에서 수행되는 신경망 기반 양자 에러 정정 복호화 방법에 있어서,양자 회로의 에러 신드롬 정보를 획득하는 단계 - 상기 에러 신드롬 정보는 양자 에러 정정 부호의 스태빌라이저 생성기의 고유치에 의해 형성된 데이터 어레이임 -;특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 상기 에러 신드롬 정보에 대한 블록 특징 추출을 수행하는 단계 - 상기 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 상기 블록 특징 추출을 수행하도록구성되고, 상기 블록 특징 추출은, 상기 입력된 데이터가 적어도 두 개의 블록으로 분할된 후, 적어도 두 개의특징 추출부를 사용하여 상기 적어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구성됨 -; 그리고에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를수행하는 단계 - 상기 에러 결과 정보는 에러가 발생하는 상기 양자 회로 내의 데이터 큐비트 및 대응하는 에러유형을 결정하는 데 사용됨 -를 포함하는 신경망 기반 양자 에러 정정 복호화 방법."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "신경망 기반 양자 에러 정정 복호화 장치에 있어서,양자 회로의 에러 신드롬 정보를 획득하도록 구성된 신드롬 정보 획득 모듈 - 상기 에러 신드롬 정보는 양자 에러 정정 부호의 스태빌라이저 생성기의 고유치에 의해 형성된 데이터 어레이임 -;특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 상기 에러 신드롬 정보에 대한 블록 특징 추출을 수행하도록 구성된 블록 특징 추출 모듈 - 상기 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 블록 특징추출을 수행하도록 구성되고, 상기 블록 특징 추출은, 상기 입력된 데이터가 적어도 두 개의 블록으로 분할된후, 적어도 두 개의 특징 추출부를 사용하여 상기 적어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구성됨 -; 그리고에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를수행하도록 구성된 융합 복호화 처리 모듈 - 상기 에러 결과 정보는 에러가 발생하는 상기 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용됨 -을 포함하는 신경망 기반 양자 에러 정정 복호화 장치."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "칩으로서,프로그램이 가능한 논리 회로 및/또는 프로그램 명령을 포함하고, 상기 칩이 컴퓨터 기기 상에서 구동될 때, 청구항 제1항 내지 제12항 중 어느 한 항에 따른 신경망 기반 양자 에러 정정 복호화 방법을 구현하도록 구성된,칩."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "컴퓨터 기기로서,프로세서 및 메모리를 포함하고, 상기 메모리는 적어도 하나의 명령어, 적어도 하나의 프로그램, 코드 세트 또는 명령어 세트를 포함하고, 상기 적어도 하나의 명령어, 상기 적어도 하나의 프로그램, 상기 코드 세트 또는상기 명령어 세트는 청구항 제1항 내지 제12항 중 어느 한 항에 따른 신경망 기반 양자 에러 정정 복호화 방법을 구현하기 위해 상기 프로세서에 의해 로딩되어 실행되는, 컴퓨터 기기."}
{"patent_id": "10-2021-7031512", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "컴퓨터로 판독할 수 있는 저장 매체로서,공개특허 10-2021-0134363-6-적어도 하나의 명령어, 적어도 하나의 프로그램, 코드 세트 또는 명령어 세트를 저장하고, 상기 적어도 하나의명령어, 상기 적어도 하나의 프로그램, 상기 코드 세트 또는 상기 명령어 세트는 청구항 제1항 내지 제12항 중어느 한 항에 따른 신경망 기반 양자 에러 정정 복호화 방법을 구현하기 위해 프로세서에 의해 로딩되어 실행되는, 컴퓨터로 판독할 수 있는 저장 매체."}
{"patent_id": "10-2021-7031512", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 출원은 신경망 기반 QEC 복호화 방법 및 장치, 칩을 개시하며, 인공 지능 및 양자"}
{"patent_id": "10-2021-7031512", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "에 관한 것이다. 상기 방법은, 양자 회로의 에러 신드롬 정보를 획득하는 단계; 특징 정보를 획득하기 위해, 신경망 디코더를 사 용하여 에러 신드롬 정보에 대해 블록 특징 추출을 수행하는 단계; 및 에러 결과 정보를 획득하기 위해, 신경망 (뒷면에 계속) 대 표 도 - 도1"}
{"patent_id": "10-2021-7031512", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 2, "content": "공개특허10-2021-0134363 디코더를 사용하여 특징 정보에 대해 융합 복호화 처리를 수행하는 단계 - 에러 결과 정보는 에러가 발생하는 상 기 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용됨 - 를 포함한다. 본 출원에서, 블 록 특징 추출 방식이 사용되고, 각 특징 추출에 의해 획득되는 특징 정보의 채널의 수량이 감소되고, 다음 특징 추출의 입력 데이터가 감소되어서, 이는 신경망 내의 특징 추출 레이어의 수량을 감소시키는 데 도움이 되고, 이 에 따라 신경망 디코더의 깊이가 짧아질 수 있다. 그러므로, 신경망 디코더에 의해 사용되는 복호화 시간이 그에 따라 감소되어서, 실시간 에러 정정의 요구 사항을 충족시킬 수 있다. CPC특허분류 H03M 13/015 (2013.01) H03M 13/615 (2013.01)명 세 서 청구범위 청구항 1 신경망 기반 양자 에러 정정 복호화 방법에 있어서, 양자 회로의 에러 신드롬 정보를 획득하는 단계 - 상기 에러 신드롬 정보는 양자 에러 정정 부호의 스태빌라이 저 생성기의 고유치에 의해 형성된 데이터 어레이임 -; 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 상기 에러 신드롬 정보에 대한 블록 특징 추출을 수행하 는 단계 - 상기 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 상기 블록 특징 추출을 수행하도록 구성되고, 상기 블록 특징 추출은, 상기 입력된 데이터가 적어도 두 개의 블록으로 분할된 후, 적어도 두 개의 특징 추출부를 사용하여 상기 적어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구성됨 -; 그리고 에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를 수행하는 단계 - 상기 에러 결과 정보는 에러가 발생하는 상기 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용됨 - 를 포함하는 신경망 기반 양자 에러 정정 복호화 방법. 청구항 2 제1항에 있어서, 상기 신경망 디코더는 m개의 캐스케이드된 특징 추출 레이어를 포함하고, m은 양의 정수이고; 상기 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 상기 에러 신드롬 정보에 대한 블록 특징 추출을 수행하는 단계는, 상기 특징 정보를 획득하기 위해, 상기 m개의 상기 특징 추출 레이어를 사용하여 상기 에러 신드롬 정보에 대해 블록 특징 추출을 수행하는 단계를 포함하고, 상기 제1 특징 추출 레이어는 상기 에러 신드롬 정보에 대해 블록 특징 추출을 수행하도록 구성되고, 상기 i번 째 특징 추출 레이어는 이전 특징 추출 레이어의 특징 추출 결과에 대해 블록 특징 추출을 수행하도록 구성되며, i는 1보다 크고, m보다 작거나 같은 정수인, 신경망 기반 양자 에러 정정 복호화 방법. 청구항 3 제1항에 있어서, 상기 에러 신드롬 정보는 T개의 데이터 어레이를 포함하고, 각 데이터 어레이는 상기 양자 에러 정정 부호를 사 용하여 상기 양자 회로에 대해 하나의 에러 신드롬 측정을 수행함으로써 획득되고, T는 1보다 큰 정수이고; 양자 회로의 상기 에러 신드롬 정보를 획득하는 단계 이후, 상기 신경망 기반 양자 에러 정정 복호화 방법은, 상기 에러 신드롬 정보를 적어도 두 개의 데이터 단위로 분류하는 단계를 더 포함하고, 하나의 데이터 단위는 상기 T개의 데이터 어레이 내의 동일한 위치에 T개의 어레이 유닛을 포함하는, 신경망 기 반 양자 에러 정정 복호화 방법. 청구항 4 제1항에 있어서, 상기 에러 신드롬 정보는 상기 양자 에러 정정 부호를 사용하여 상기 양자 회로 상의 노이즈를 가진 에러 신드 롬 측정을 수행하여 획득된 실제 에러 신드롬 정보이고; 상기 신경망 디코더는 제1 디코더 및 제2 디코더를 포 함하고; 상기 제1 디코더는, 상기 실제 에러 신드롬 정보에 대응하는 논리 에러 클래스를 획득하기 위해, 상기 실제 에러 신드롬 정보를 복호화하도록 구성되고, 상기 논리 에러 클래스는 상기 양자 회로 내에서 발생한 에러가 매핑 된 후에 획득된 클래스이고; 상기 제2 디코더는, 상기 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보를 획득하기 위해, 상기 실 제 에러 신드롬 정보를 복호화하도록 구성되고, 상기 완전 에러 신드롬 정보는 상기 양자 회로 상의 노이즈 없 이 에러 신드롬 측정을 수행하여 획득된 정보이고; 에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를 수행하는 단계 이후, 상기 신경망 기반 양자 에러 정정 복호화 방법은, 상기 논리 에러 클래스 및 상기 완전 에러 신드롬 정보에 따라, 상기 에러가 상기 양자 회로 내에서 발생하는 상기 데이터 큐비트 및 상기 대응하는 에러 유형을 결정하는 단계 를 더 포함하는, 신경망 기반 양자 에러 정정 복호화 방법. 청구항 5 제4항에 있어서, 상기 논리 에러 클래스 및 상기 완전 에러 신드롬 정보에 따라, 상기 에러가 상기 양자 회로 내에서 발생하는 상기 데이터 큐비트 및 상기 대응하는 에러 유형을 결정하는 단계는, 상기 논리 에러 클래스에 대응하는 제1 에러 결과를 획득하는 단계; 상기 완전 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득하는 단계; 그리고 상기 제1 에러 결과 및 상기 제2 에러 결과에 따라, 상기 에러가 상기 양자 회로 내에서 발생하는 상기 데이터 큐비트 및 상기 대응하는 에러 유형을 결정하는 단계 를 포함하는, 신경망 기반 양자 에러 정정 복호화 방법. 청구항 6 제4항에 있어서, 상기 논리 에러 클래스에 대응하는 제1 에러 결과를 획득하는 단계는, 상기 논리 에러 클래스 내에 포함된 요소들로부터의 임의의 요소를 상기 제1 에러 결과로 선택하는 단계를 포함 하고, 상기 논리 에러 클래스는 적어도 하나의 등가 에러 요소를 포함하는, 신경망 기반 양자 에러 정정 복호화 방법. 청구항 7 제4항에 있어서, 상기 완전 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득하는 단계는, 상기 완전 에러 신드롬 정보 내의 에러 신드롬 포인트에 각각 대응하는 단순 에러를 획득하기 위해 매핑 테이블 을 룩업하는 단계 - 상기 매핑 테이블은 에러 신드롬 포인트의 적어도 하나의 그룹 및 단순 에러 사이의 매핑 관계를 포함함 -; 그리고 상기 제2 에러 결과를 획득하기 위해, 상기 에러 신드롬 포인트에 각각 대응하는 단순 에러를 곱하는 단계 를 포함하는, 신경망 기반 양자 에러 정정 복호화 방법. 청구항 8 제4항에 있어서, 상기 제1 에러 결과 및 상기 제2 에러 결과에 따라, 상기 에러가 상기 양자 회로 내에서 발생하는 상기 데이터 큐비트 및 상기 대응하는 에러 유형을 결정하는 단계는, 상기 에러가 상기 양자 회로 내에서 발생하는 상기 데이터 큐비트 및 상기 대응하는 에러 유형을 획득하기위해, 상기 제1 에러 결과와 상기 제2 에러 결과의 곱을 계산하는 단계 를 포함하는, 신경망 기반 양자 에러 정정 복호화 방법. 청구항 9 제4항에 있어서, k개의 제2 디코더가 있고, k는 양의 정수이고 k는 상기 양자 에러 정정 부호의 길이와 관련되고; k개의 상기 제2 디코더는, k개의 완전 에러 신드롬 비트를 획득하기 위해, 상기 실제 에러 신드롬 정보를 각각 복호화하도록 구성되며; k개의 상기 완전 에러 신드롬 비트는 상기 완전 에러 신드롬 정보를 획득하기 위한 병합을 수행하는 데 사용되 는, 신경망 기반 양자 에러 정정 복호화 방법. 청구항 10 제1항에 있어서, 상기 신경망 디코더의 트레이닝 데이터는, 샘플 양자 회로 내에 포함된 물리 큐비트 상에 에러를 확률적으로 생성시키는 단계; 상기 샘플 양자 회로에 대응하는 보조 큐비트 상에 에러를 확률적으로 생성시키는 단계 - 상기 보조 큐비트는 상기 샘플 양자 회로의 에러 신드롬 정보를 획득하기 위한 측정을 수행하는 데 사용됨 -; 상기 샘플 양자 회로에 대응하는 고유치 측정 회로 내에 포함된 제어된 NOT 게이트 상에 에러를 확률적으로 생 성시키는 단계 - 상기 고유치 측정 회로는 스태빌라이저 생성기의 고유치를 측정하도록 구성됨 -; 에러 신드롬 측정이 양자 에러 정정 부호를 사용하여 상기 샘플 양자 회로에 대해 수행되는 경우 측정 에러를 확률적으로 생성시키는 단계; 그리고 상기 샘플 양자 회로의 상기 에러 신드롬 정보 및 에러 결과 정보를 획득하고, 상기 트레이닝 데이터를 생성하 는 단계 에 의해 생성되는, 신경망 기반 양자 에러 정정 복호화 방법. 청구항 11 제1항에 있어서, 상기 신경망 디코더의 트레이닝 데이터는, 샘플 양자 회로에 대해 양자 프로세스 토모그래피를 수행하고, 상기 샘플 양자 회로의 노이즈 모델을 추출하는 단계; 상기 노이즈 모델에 기반한 노이즈의 작용 하에 상기 샘플 양자 회로의 양자 상태의 진화를 시뮬레이션하는 단 계; 그리고 상기 샘플 양자 회로의 상기 에러 신드롬 정보 및 에러 결과 정보를 획득하고, 상기 트레이닝 데이터를 생성하 는 단계 에 의해 생성되는, 신경망 기반 양자 에러 정정 복호화 방법. 청구항 12 제1항 내지 제11항 중 어느 한 항에 있어서, 에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를 수행하는 단계 이후, 상기 신경망 기반 양자 에러 정정 복호화 방법은, 상기 에러 결과 정보에 따라 에러-정정 제어 신호를 생성하는 단계 - 상기 에러-정정 제어 신호는 상기 양자 회 로에 의해 생성된 에러를 정정하기 위해 사용됨 -; 그리고상기 에러-정정 제어 신호를 상기 양자 회로에게 전송하는 단계 를 더 포함하는 신경망 기반 양자 에러 정정 복호화 방법. 청구항 13 컴퓨터 기기에서 수행되는 신경망 기반 양자 에러 정정 복호화 방법에 있어서, 양자 회로의 에러 신드롬 정보를 획득하는 단계 - 상기 에러 신드롬 정보는 양자 에러 정정 부호의 스태빌라이 저 생성기의 고유치에 의해 형성된 데이터 어레이임 -; 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 상기 에러 신드롬 정보에 대한 블록 특징 추출을 수행하 는 단계 - 상기 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 상기 블록 특징 추출을 수행하도록 구성되고, 상기 블록 특징 추출은, 상기 입력된 데이터가 적어도 두 개의 블록으로 분할된 후, 적어도 두 개의 특징 추출부를 사용하여 상기 적어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구성됨 -; 그리고 에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를 수행하는 단계 - 상기 에러 결과 정보는 에러가 발생하는 상기 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용됨 - 를 포함하는 신경망 기반 양자 에러 정정 복호화 방법. 청구항 14 신경망 기반 양자 에러 정정 복호화 장치에 있어서, 양자 회로의 에러 신드롬 정보를 획득하도록 구성된 신드롬 정보 획득 모듈 - 상기 에러 신드롬 정보는 양자 에 러 정정 부호의 스태빌라이저 생성기의 고유치에 의해 형성된 데이터 어레이임 -; 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 상기 에러 신드롬 정보에 대한 블록 특징 추출을 수행하 도록 구성된 블록 특징 추출 모듈 - 상기 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 블록 특징 추출을 수행하도록 구성되고, 상기 블록 특징 추출은, 상기 입력된 데이터가 적어도 두 개의 블록으로 분할된 후, 적어도 두 개의 특징 추출부를 사용하여 상기 적어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구 성됨 -; 그리고 에러 결과 정보를 획득하기 위해, 상기 신경망 디코더를 사용하여 상기 특징 정보에 대해 융합 복호화 처리를 수행하도록 구성된 융합 복호화 처리 모듈 - 상기 에러 결과 정보는 에러가 발생하는 상기 양자 회로 내의 데이 터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용됨 - 을 포함하는 신경망 기반 양자 에러 정정 복호화 장치. 청구항 15 칩으로서, 프로그램이 가능한 논리 회로 및/또는 프로그램 명령을 포함하고, 상기 칩이 컴퓨터 기기 상에서 구동될 때, 청 구항 제1항 내지 제12항 중 어느 한 항에 따른 신경망 기반 양자 에러 정정 복호화 방법을 구현하도록 구성된, 칩. 청구항 16 컴퓨터 기기로서, 프로세서 및 메모리를 포함하고, 상기 메모리는 적어도 하나의 명령어, 적어도 하나의 프로그램, 코드 세트 또 는 명령어 세트를 포함하고, 상기 적어도 하나의 명령어, 상기 적어도 하나의 프로그램, 상기 코드 세트 또는 상기 명령어 세트는 청구항 제1항 내지 제12항 중 어느 한 항에 따른 신경망 기반 양자 에러 정정 복호화 방법 을 구현하기 위해 상기 프로세서에 의해 로딩되어 실행되는, 컴퓨터 기기. 청구항 17 컴퓨터로 판독할 수 있는 저장 매체로서,적어도 하나의 명령어, 적어도 하나의 프로그램, 코드 세트 또는 명령어 세트를 저장하고, 상기 적어도 하나의 명령어, 상기 적어도 하나의 프로그램, 상기 코드 세트 또는 상기 명령어 세트는 청구항 제1항 내지 제12항 중 어느 한 항에 따른 신경망 기반 양자 에러 정정 복호화 방법을 구현하기 위해 프로세서에 의해 로딩되어 실행되 는, 컴퓨터로 판독할 수 있는 저장 매체. 발명의 설명 기 술 분 야 본 출원의 실시예는 인공 지능 및 양자 기술 분야에 관한 것으로, 특히 신경망 기반 양자 에러 정정 복호화 방 법 및 장치, 그리고 칩에 관한 것이다. 본 출원은 2020년 4월 15일에 \"NEURAL NETWORK-BASED QUANTUM ERROR CORRECTION DECODING METHOD AND APPARATUS, AND CHIP\"이라는 제목으로 출원된 중국 특허 출원 번호 202010296660.4에 대한 우선권을 주장하며, 그 전문은 참조로서 여기에 포함된다."}
{"patent_id": "10-2021-7031512", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "큐비트는 노이즈에 매우 취약하기 때문에, 현재 기술로 물리 큐비트로 양자 계산(QC)을 직접 구현하는 것은 여 전히 실용적이지 않다. 양자 에러 정정(Quantum Error Correction, QEC) 코드 기술과 결함 감내 양자 계산 (Fault Tolerant Quantum Computation, FTQC) 기술의 발전으로, 노이즈를 갖는 큐비트로 임의 정밀도의 QC를 구현하는 것이 원칙적으로 가능하게 됐다. 양자 정보만 저장되면, 모든 에러 신드롬이 검출되어 수집될 수 있고, 최종적으로 에러 정정은 모든 신드롬 정 보에 따라 수행된다. 이 에러 정정 방식을 사후 처리(post-processing)라고 한다. 하지만, FTQC가 수행될 때, 양자 회로는 실시간으로 에러 유형을 변경하고, 서로 다른 시공간에서 발생하는 에러는 신드롬 정보에만 의존하 여 정확하게 추적되고 위치 지정될 수 없다. QC가 원활하게 수행되기 위해, 에러 신드롬이 획득된 직후 복호화 를 수행하고 양자 알고리즘의 각 계산 단계가 구동되기 이전(또는 에러 정정의 다음 라운드가 시작되기 전)에 에러 정정이 완료될 필요가 있다. 실시간 에러 정정이라고 하는 이 과정은, 대규모 일반 QC를 구현하기 위한 필 수 기술이다. 실시간 에러정정은 QEC 코드의 복호화 알고리즘의 구동 시간의 여유에 관한 매우 엄격한 요구사항을 갖지만, 현 재 일부 QEC 코드의 복호화 알고리즘은 실시간 에러정정의 요구사항을 충족하지 못한다. 본 출원의 실시예는, 양자 에러 정정 부호의 복호화 알고리즘의 복호화 시간을 단축하여 실시간 에러 정정의 요 구 사항을 충족할 수 있는, 신경망 기반 양자 에러 정정 복호화 방법 및 장치, 칩을 제공한다. 기술적 해결 방 안은 다음과 같다. 일 측면에 따르면, 본 출원의 실시예는 신경망 기반 양자 에러 정정 복호화 방법을 제공하고, 상기 방법은, 양자 회로의 에러 신드롬 정보를 획득하는 단계 - 에러 신드롬 정보는 양자 에러 정정 부호의 스태빌라이저 생 성기의 고유치에 의해 형성된 데이터 어레이임 -; 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 에러 신드롬 정보에 대한 블록 특징 추출을 수행하는 단 계 - 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 블록 특징 추출을 수행하도록 구성되고, 블록 특징 추출은, 입력된 데이터가 적어도 두 개의 블록으로 분할된 후, 적어도 두 개의 특징 추출부를 사용하여 적 어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구성됨 -; 및 에러 결과 정보를 획득하기 위해, 신경망 디코더를 사용하여 특징 정보에 대해 융합 복호화 처리를 수행하는 단 계 - 에러 결과 정보는 에러가 발생하는 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용됨 - 를 포함한다. 다른 측면에 따르면, 본 출원의 실시예는 컴퓨터 기기에서 수행되는 신경망 기반 양자 에러 정정 복호화 방법을 제공하며, 상기 방법은, 양자 회로의 에러 신드롬 정보를 획득하는 단계 - 에러 신드롬 정보는 양자 에러 정정 부호의 스태빌라이저 생 성기의 고유치에 의해 형성된 데이터 어레이임 -; 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 에러 신드롬 정보에 대한 블록 특징 추출을 수행하는 단 계 - 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 블록 특징 추출을 수행하도록 구성되고, 블록 특징 추출은, 입력된 데이터가 적어도 두 개의 블록으로 분할된 후, 적어도 두 개의 특징 추출부를 사용하여 적 어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구성됨 -; 및 에러 결과 정보를 획득하기 위해, 신경망 디코더를 사용하여 특징 정보에 대해 융합 복호화 처리를 수행하는 단 계 - 에러 결과 정보는 에러가 발생하는 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용됨 - 를 포함한다. 다른 측면에 따르면, 본 출원의 실시예는 신경망 기반 양자 에러 정정 복호화 장치를 제공하고, 양자 회로의 에러 신드롬 정보를 획득하도록 구성된 신드롬 정보 획득 모듈 - 에러 신드롬 정보는 양자 에러 정 정 부호의 스태빌라이저 생성기의 고유치에 의해 형성된 데이터 어레이임 -; 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 에러 신드롬 정보에 대한 블록 특징 추출을 수행하도록 구성된 블록 특징 추출 모듈 - 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 블록 특징 추출을 수 행하도록 구성되고, 블록 특징 추출은, 입력된 데이터가 적어도 두 개의 블록으로 분할된 후, 적어도 두 개의 특징 추출부를 사용하여 적어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구성됨 -; 그리고 에러 결과 정보를 획득하기 위해, 신경망 디코더를 사용하여 특징 정보에 대해 융합 복호화 처리를 수행하도록 구성된 융합 복호화 처리 모듈 - 에러 결과 정보는 에러가 발생하는 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용됨- 을 포함한다. 다른 측면에 따르면, 본 출원의 실시예는 컴퓨터 기기를 제공하고, 프로세서 및 메모리를 포함하며, 메모리는 적어도 하나의 명령어, 적어도 하나의 프로그램, 코드 세트 또는 명령어 세트를 저장하고, 적어도 하나의 명령 어, 적어도 하나의 프로그램, 코드 세트 또는 명령어 세트는 신경망 기반 양자 에러 정정 복호화 방법을 구현하 기 위해 프로세서에 의해 로딩되어 실행된다. 다른 측면에 따르면, 본 출원의 실시예는 컴퓨터가 판독 가능한 저장 매체를 제공하고, 적어도 하나의 명령어, 적어도 하나의 프로그램, 코드 세트 또는 명령어 세트를 저장하고, 적어도 하나의 명령어, 적어도 하나의 프로 그램, 코드 세트 또는 명령어 세트는 신경망 기반 양자 에러 정정 복호화 방법을 구현하기 위해 프로세서에 의 해 로딩되어 실행된다. 또 다른 측면에 따르면, 본 출원의 실시예는 칩을 제공하고, 프로그래밍 가능한 논리 회로 및/또는 프로그램 명 령을 포함하며, 컴퓨터 기기 상에서 구동될 때, 칩은 신경망 기반 양자 에러 정정 복호화 방법을 구현하도록 구 성된다. 또 다른 측면에 따르면, 본 출원의 실시예는 컴퓨터 프로그램 제품을 제공하고, 실행될 때, 컴퓨터 프로그램 제 품은 신경망 기반 양자 에러 정정 복호화 방법을 구현하도록 구성된다. 본 출원의 실시예에서 제공되는 기술적 해결 방안은 적어도 다음과 같은 유익한 효과를 포함할 수 있다. 블록 특징 추출이, 복수의 그룹의 특징 정보를 획득하기 위해, 양자 회로의 에러 신드롬 정보에 대해 수행되고, 이후 융합 복호화 처리가, 에러 결과 정보를 획득하기 위해, 복수 그룹의 특징 정보에 대해 추가로 수행된다. 블록 특징 추출 방식을 사용되기 때문에, 입력 데이터에 대한 완전 특징 추출에 비해, 한편으로, 각 특징 추출 에 의해 획득되는 특징 정보의 채널의 수량이 줄어들고, 다음 특징 추출의 입력 데이터가 줄어들어서, 이는 신 경망 디코더 내의 특징 추출 레이어의 수량을 줄이는 데 도움을 주고, 그에 따라 신경망 디코더의 깊이도 짧아 질 수 있다. 신경망 디코더의 깊이가 짧아지기 때문에, 신경망 디코더에 의해 사용되는 복호화 시간이 그에 따 라 감소한다. 한편, 블록 특징 추출이 수행될 때 병렬 특징 추출 처리가 복수의 특징 추출부를 사용하여 복수의 블록에 대해 수행되고, 즉, 복수의 특징 추출부는 특징 추출 처리를 동기적으로(또는 동시에라고 함) 수행하여 서, 이는 특징 추출에 소요되는 시간을 감소시키는 데 도움을 주고, 복호화 시간이 감소될 수 있다. 마지막으로, 두 가지 요소를 참조하여, 양자 에러 정정 복호화가 신경망 디코더를 사용하여 수행될 때, 복호화 시간이 완전히 단축되어서, 그럼에 따라 실시간 에러 정정 요구 사항을 충족시킬 수 있다."}
{"patent_id": "10-2021-7031512", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 출원의 목적, 기술적 해결 방안, 및 이점을 보다 명확하게 하기 위해, 본 출원의 구현을 첨부된 도면을 참조 하여 아래에서 더 상세히 설명한다. 본 출원의 실시예를 설명하기 전에 본 출원과 관련된 몇 가지 용어를 먼저 설명한다. 1. 양자 계산(quantum computation, QC): QC는 특정 계산 작업을 신속하게 완료하기 위해 양자 상태의 중첩 (superposition) 및 얽힘(entanglement) 속성을 사용하는 방식이다. 2. 양자 텔레포테이션(quantum teleportation): 양자 텔레포테이션은 양자 얽힌 상태를 분산시키고 일부 고전적 인 정보를 전송하는 방식으로 미지의 양자 상태를 거리에 관계없이 전송하는 기술이다. 3. 양자 에러 정정(quantum error correction, QEC) 코드: QEC 코드는 인코딩을 위해 다체(many-body) 양자 시 스템의 힐베르트 공간 내의 부분 공간에 양자 상태를 매핑하는 방식이다. 양자 노이즈는 인코딩된 양자 상태가 또 다른 부분 공간으로 전송되도록 초래할 수 있다. 양자 상태가 국한된 공간을 지속적으로 관측(신드롬 추출) 함으로써, 코딩된 양자 상태를 양자 노이즈로부터의 간섭에 대해 보호하기 위해, 양자 노이즈가 인코딩된 양자 상태를 간섭하지 않고 평가되고 보정될 수 있다. 구체적으로, QEC 코드 의 경우, 임의의 단일 큐비트에 서 발생하는 임의의 에러를 정정하기 위해, n개의 물리 큐비트 내에서 k개의 논리 큐비트가 인코딩 됨을 나타낸다. 4. 데이터 양자 상태: 데이터 양자 상태는 QC 동안 양자 정보를 저장하는 데 사용되는 데이터 큐비트의 양자 상 태이다. 5. 스태빌라이저 생성기(stabilizer generator): 스태빌라이저 생성기는 패리티 체크 연산자라고도 한다. 양자 노이즈(에러)의 발생은 일부 스태빌라이저 생성기의 고유치(eigenvalue)를 변경시킬 수 있고, 그러므로 QEC는 그 정보를 기반으로 수행될 수 있다. 6. 스태빌라이저 그룹: 스태빌라이저 그룹은 스태빌라이저 생성기에 의해 생성되는 그룹이다. k개의 스태빌라이 저 생성기가 있다면, 스태빌라이저 그룹은 아벨 그룹(abelian group)인 2k개의 요소를 포함한다. 7. 에러 신드롬(error syndrome): 에러가 없으면, 스태빌라이저 생성기의 고유치는 0이고; 양자 노이즈가 발생 할 때, 일부 에러 정정 부호의 스태빌라이저 생성기(패리티 체크 연산자)의 고유치는 1로 변경된다. 신드롬 비 트 0과 1로 구성된 비트열은 에러 신드롬이라고도 한다. 8. 신드롬 측정 회로: 신드롬 측정 회로는 체크 회로라고도 하며, 에러 신드롬을 획득하기 위한 양자 회로이다. 일반적으로, 회로는 노이즈로 오염되어 있다. 9. 위상(topological) QEC 코드: 위상 QEC 코드는 QEC 코드의 특수 클래스이다. 이러한 에러 정정 부호의 큐비 트는 차원의 수량이 2보다 큰 그리드(grid) 어레이 상에 분포된다. 그리드는 고차원 매니폴드(manifold)의 이산 구조(discrete structure)를 형성한다. 이 경우, 에러 정정 부호의 스태빌라이저 생성기는 기하학적으로 인접하 고 제한된 큐비트에 대해 정의되고, 그러므로 기하학적으로 국부화되어 쉽게 측정될 수 있다. 에러 정정 부호의 논리 연산자에 의해 작동되는 큐비트는 그리드 어레이의 매니폴드 상에 토폴로지적으로 자명하지 않은 (topological non-trivial) 기하학적 객체를 형성한다. 10. 표면 코드(surface code): 표면 코드는 2차원 매니폴드 상에 정의된 위상 QEC 코드의 클래스이다. 표면 코 드의 스태빌라이저 생성기는 일반적으로 네 개의 큐비트에 의해 지원되고(경계에서 2개의 큐비트에 의해 지원됨) 논리 연산자(logical operator)는 스트립 스패닝 어레이의 자명하지 않은 체인이다. 표면 코드의 특정 한 2차원 구조(5*5, 두 개의 큐비트 상에서 발생하는 모든 에러를 정정할 수 있는, 총 25개의 데이터 큐비트 및 24개의 보조 큐비트)는 도 1에 도시된다. 흰색 원은 QC를 수행하기 위한 데이터 큐비트를 나타내고, 검은색 원은 보조 큐비트를 나타낸다. 보조 큐비트는 초기에 또는 상태로 준비된다. 슬래시로 채워진 사각 형(또는 반원)과 흰색으로 채워진 사각형(또는 반원)은 Z 에러 및 X 에러를 검출하도록 각각 구성된, 두 가지 서로 다른 유형의 스태빌라이저 생성기를 나타낸다. 본 출원에서, 도 1에 도시된 회전된 표면 코드가 사용된다. 회전된 표면 코드는 물리 큐비트의 약 절반을 절약할 수 있고, 그러므로 최근 실험에서 더 간편하게 검증된다. 11. 표면 코드의 길이 L: 표면 코드의 길이 L은 표면 코드 어레이의 외곽(perimeter)의 1/4이다. 도 1에 도시된 대로, 표면 코드의 길이 L은 L=5이다. 12. 스태빌라이저 코드: 스태빌라이저 코드는 스태빌라이저 생성기의 그룹에 의해 정의된 QEC 코드이다. 스태빌 라이저 생성기는 상호 교환 가능하고 n개의 큐비트 상에서 독립적으로 작동하는 파울리 연산자(Pauli- operator)의 그룹이다. Pauli 연산자 그룹의 공통 고유치 +1을 가진 고유 부분 공간(eigen-subspace)은 스태빌 라이저 코드의 인코딩 공간이다. 13. 상동 관계 클래스(homology class): 토폴로지에서, 상동 관계 이론 내의 상동 관계 클래스는 경계 0을 가진 기하학적 하위 객체(sub-object)의 유한한 선형 조합에 의해 표현된다. 이 선형 결합의 기하학적 객체가, 그것 의 차원이 1보다 큰 기하학적 객체의 경계로 간주될 수 있다면, 기하학적 객체는 \"0\"과 상동(homologous)인 것으로 간주된다(여기서 0은 토폴로지적 자명 클래스(topological trivial class)를 의미하고, 이는 점으로 지속 적으로 수축할 수 있는 기하학적 개체일 수 있음). 다음에서, 상동 관계 클래스는 때때로 \"에러 클래스\"와 혼용 된다. 14. X 및 Z 에러: X 에러 및 Z 에러는 물리 큐비트의 양자 상태 상에서 무작위로 생성되는 Pauli-X 진화 에러 및 Pauli-Z 진화 에러이다. QEC 이론에 따르면, 에러 정정 부호가 X 에러와 Z 에러를 정정하는 데 사용될 수 있 다면, 에러 정정 부호는 단일 큐비트 상에서 발생하는 모든 에러를 정정하는 데 사용될 수 있다. 15. 결함 감내 양자 에러 정정(fault tolerant QEC, FTQEC): FTQEC는 실제 QC 동안의 모든 작업 프로세스이며 노이즈를 담고 있는 양자 게이트 및 양자 측정을 포함한다. 즉, QEC용 회로에도 노이즈가 포함되어 있다. FTQEC 는 에러 정정 회로가 잘 설계된 후, 에러 정정이 노이즈를 가진 에러 정정 회로를 사용하여 수행될 수 있고, 에러를 정정하고 시간이 지나면서 에러가 확산되는 것을 방지하기 위한 목적이 여전히 달성될 수 있음을 말한다. 16. 결함 감내 양자 계산(fault tolerant quantum computation, FTQC): FTQC는 QEC 보호 아래의 QC이다. QC 중 에, QEC 회로 자체에 대한 연산 및 큐비트 측정을 포함하여, 모든 물리적 연산(operation)에는 노이즈가 있다. 게다가, 고전 연산(classic operation)에는 노이즈가 없다고 가정된다. FTQC는 QC 방식을 적절하게 설계하고 인 코딩된 논리 양자 상태에 대해 특정 방식으로 게이트 연산을 수행하는 방법이, 노이즈를 가진 큐비트를 사용하 여 QC 동안 효과적인 제어 및 에러 정정을 보장하기 위해 사용되는 기술적 해결 방안이다. 17. 물리 큐비트: 물리 큐비트는 실제 물리적 장치를 사용하여 구현된 큐비트이다. 18. 논리 큐비트: 논리 큐비트는 에러 정정 부호에 의해 정의된 힐베르트 부분 공간의 수학적 자유도이다. 논리 큐비트의 양자 상태에 대한 설명은 통상, 일반적으로 힐베르트 공간과 결합된 복수의 물리 큐비트의 2차원 부분 공간인, 다체 얽힌 상태(many-body entangled state)이다. FTQC는 에러 정정 부호에 의해 보호되는 논리 큐비트 상에서 실행될 필요가 있다. 19. 물리 양자 게이트/회로: 물리 양자 게이트/회로는 물리 큐비트 상에서 작동하는 양자 게이트/회로이다. 20. 논리 양자 게이트/회로: 논리 양자 게이트/회로는 논리 큐비트 상에서 작동하는 양자 게이트/회로이다. 21. 데이터 에러: 데이터 에러는 데이터 큐비트 상에서 발생하는 에러이다. 22. 측정 에러: 측정 에러는 측정 과정이 불완전하여 발생하는 에러이다. 23. 임계치 정리(threshold theorem): 임계치 정리에서, FTQC 요구 사항을 충족하는 계산 방식의 경우, 모든 연 산의 에러율이 임계치보다 작을 때, 더 나은 에러 정정 부호, 더 많은 큐비트, 및 더 많은 양자 연산이 계산의 정확도를 임의로 1에 근사시키기 위해 사용될 수 있다. 한편, 추가적 자원 오버헤드는 QC의 인덱스 가속(index acceleration)에 비해 무시될 수 있다. 24. 신경망(neural network): 인공 신경망은 많은 수량의 서로 연결된 단순 기본 요소, 즉 뉴런에 의해 형성된 적응형 비선형 동적 시스템이다. 각 뉴런의 구조 및 기능은 비교적 단순하지만, 많은 수량의 뉴런의 결합에 의 해 발생되는 시스템 동작은 매우 복잡하며, 원칙적으로, 어떤 기능이든 표현될 수 있다. 25. 컨볼루션 신경망(convolutiona neural network, CNN): CNN은 컨볼루션 계산을 포함하고 심층 구조(deep structure)를 갖는 일종의 피드포워드(feedforward) 신경망이다. 컨볼루션 레이어는 CNN의 핵심 요소 (keystone), 즉, 2차원 또는 3차원 데이터 격자(data lattice)로 컨볼루션 연산을 수행하는 이산 2차원 또는 3 차원 필터(각각 2차원 또는 3차원 행렬인, 컨볼루션 커널(convolutaion kernel)이라고도 함)이다. 26. 정류된 선형 유닛(Rectifies linear unit, ReLU) 레이어: ReLU f(x)=max(0, x)는 신경망의 활성화 함수 (activation function)로서 사용된다. 27. 에러 역전파(error back propagation, BP) 알고리즘: 에러 BP 알고리즘은 인공 신경망 내의 지도 학습 (supervised learning) 알고리즘이다. BP 신경망 알고리즘은 이론적으로 모든 기능에 접근할 수 있고, 기본 구 조는 비선형 변경 단위로 구성되며 강력한 비선형 매핑 능력을 가지고 있다. 28. 필드 프로그램 가능 게이트 어레이(Field Programmable Gate Array, FPGA). 본 출원의 기술적 해결 방안은 양자 기술 및 인공 지능 기술 분야와 관련이 있다. 인공 지능(artificial intelligence, AI)은, 인간의 지능을 시뮬레이션하고, 확장하고, 넓히고, 환경을 인식하고, 지식을 획득하고, 최적 결과를 획득하기 위해 지식을 사용하기 위해 디지털 컴퓨터 또는 디지털 컴퓨터에 의해 제어되는 기계를 사용하는, 이론, 방법, 기술, 및 응용 시스템이다. 달리 말하면, AI는 컴퓨터 과학의 종합 기술이고 지능의 본 질을 이해하고 인간의 지능과 유사한 방식으로 반응할 수 있는 새로운 지능기계를 생산하려는 시도이다. AI는, 기계로 하여금 인식, 추리(reasoning), 및 의사 결정 기능을 가질 수 있도록 하는, 다양한 지능형 기계의 설계 원리와 구현 방법을 연구하기 위한 것이다. AI 기술은, 광범위한 분야와 관련되고, 하드웨어 및 소프트웨어 기술을 모두 포괄하는, 총괄적인 주제이다. 기 본 AI 기술은 일반적으로 센서, 전용 AI 칩, 클라우드 컴퓨팅, 분산 스토리지, 빅데이터 처리 기술, 운영/상호 작용 시스템, 전자기계적 통합과 같은 기술을 포함한다. AI 소프트웨어 기술은 주로 컴퓨터 비전(CV) 기술, 음 성 처리 기술, 자연어 처리 기술, 머신 러닝(ML)/딥 러닝 등 여러 주요 방향을 포함한다. ML은 다양한 분야에 걸친 많은 학문 분야와 관련이 있고, 확률 이론, 통계학, 근사 이론, 볼록해석학, 알고리즘 복잡도 이론 등 다수의 학문 분야와 관련이 있다. ML은, 컴퓨터 성능을 지속적으로 개선하기 위해, 컴퓨터가 새 로운 지식이나 기술을 획득하고, 기존 지식 구조를 재구성하기 위해 인간의 학습 행동을 시뮬레이션하거나 구현 하는 방법을 연구하는 것을 전문으로 한다. ML은, AI의 핵심으로서, 컴퓨터를 지능화하는 기본적인 방법이고, AI의 다양한 분야에 적용될 수 있다. ML과 딥러닝은 일반적으로 인공신경망, 신뢰망(belief network), 강화 학 습(reinforcement learning), 전이 학습(transfer learning), 귀납 학습(inductive learning), 시연으로부터의 학습(learning from demonstrations) 등의 기술을 포함한다. AI 기술의 연구와 발전으로, AI 기술은 일반 스마트홈, 스마트 웨어러블 기기, 가상 비서, 스마트 스피커, 스마 트 마케팅, 무인 운전, 자동 운전, 무인항공기, 로봇, 스마트 건강 관리, 스마트 고객 서비스 등 다양한 분야에 서 연구 및 적용되고 있다. 기술의 발전과 함께, AI 기술은 더 많은 분야에 적용될 것이며 점점 더 중요한 역할 을 할 것으로 믿어진다. 본 출원의 실시예에서 제공되는 해결 방안은 양자 기술 분야에서 AI의 기계 학습 기술의 응용에 관한 것으로, 특히 양자 에러 정정 부호의 복호화 알고리즘에 기계 학습 기술을 적용하는 것에 관한 것이고, 뒤따르는 실시예 를 사용하여 구체적으로 설명된다. 일반적으로, 장거리 양자 게이트(long-distance quantum gate)가 QEC 코드의 스태빌라이저 생성기를 측정(패리 티 검사라고도 함)하기 위해 도입될 필요가 있고, 한편, 콤플렉스 양자 보조 상태가 결함 감내 및 에러 정정을 완성하기 위한 추가적 큐비트를 사용하여 준비하도록 요구된다. 현재 실험 수단의 한계로 인해, 사람들은 고정 밀 장거리 양자 게이트를 구현할 수 없으며, 콤플렉스 양자 보조 상태를 준비할 수도 없다. 표면 코드를 사용하 여 FTQEC 및 FTQC를 수행하는 해결 방안은 장거리 양자 게이트의 사용 및 복잡한 양자 보조 상태의 준비를 요구 하지 않아서, 현재 기술을 사용하여 일반적인 결함 감내 양자 컴퓨터를 구현하는 것이 매우 가능한 것으로 고려 된다. 에러 정정 부호로서, 에러가 발생한 후, 패리티 검사가 에러 신드롬을 획득하기 위해 수행될 수 있고, 이후 에 러의 발생 위치와 유형(X 에러, Z 에러, 또는 둘 다, 즉, Y 에러)이 신드롬에 따라 그리고 에러 정정 부호에 대 한 특정 복호화 알고리즘을 사용하여 추가로 결정될 필요가 있다. 표면 코드의 경우, 에러 및 에러 신드롬은 특 정 공간 위치를 가진다. 에러가 있고 신드롬이 발생될 때, 해당 위치에서의 보조 큐비트의 고유치는 1이다(이는 상기 위치에서의 점 입자(dot particle)가 나타나는 것으로 볼 수 있음). 에러가 없을 때, 대응하는 위치에 있"}
{"patent_id": "10-2021-7031512", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "는 보조 큐비트의 고유치는 0이다. 이 경우 복호화는 다음과 같이 요약될 수 있다. 공간 디지털 어레이(2차원 또는 3차원이고, 값이 0 또는 1임)가 주어지고, 에러가 가장 많이 발생하는 큐비트 및 특정 에러 유형이 특정 에러 발생 모델 및 큐비트 상에서 발생하는 에러의 확률 분포에 따라 추론되고, 에러 정정은 추론 결과에 따라 수행된다. 도 2는 에러가 표면 코드 상에 발생한 개략도이다. 큐비트(qubit)는 2차원 어레이의 가장자리 상에 있고, 에러 신드롬을 측정하기 위한 보조 큐비트는 2차원 어레이의 노드 상에 있다(신드롬은 완전 신드롬을 통해 획득된 다). 도 2에서, 검은색 경계는 에러가 발생한 큐비트에 의해 구성된 에러 체인(error chain)을 나타내고, 슬래시로 채워진 원 부분은 에러로 인해 발생된 신드롬 값이 1인 점을 나타낸다. 복호화는 체인 에러(chain error)가 점모양(punctate) 신드롬에 의해 결정될 수 있음을 전제로 완료될 수 있다. 위에서 설명한 대로, 에러 신드롬 정보는, 에러의 발생 위치 및 유형과 같은 대응하는 에러 결과 정보를 획득하 기 위해, 에러 정정 부호의 복호화 알고리즘(또는 디코더라고도 함)을 사용하여 복호화될 수 있다. 디코더의 복 호화 능력은, 복호화 알고리즘의 복잡도, 복호화 시간, 복호화 성능, 실시간 에러 정정에 적용될 수 있는지 여 부의 4가지 핵심 지표로부터 측정될 수 있다. 복호화 알고리즘의 복잡도: 복호화 알고리즘의 복잡도는 복호화 알고리즘의 연산에 요구되는 전체 기본 계산 단 계에 대응하는 계산 복잡도를 말한다. 복호화 시간: 여기서 시간은 가상의 개념으로, 실제 복호화 시간과 다르지만 실제 복호화 시간과 강한 상관관계 를 갖는다. 여기서 복호화 시간은 복호화 알고리즘이 완전히 병렬화된 후의 알고리즘 깊이(depth)를 의미한다. 복호화 성능: 복호화 성능은 복호화가 특정 노이즈 모델을 사용하여 수행된 후의 논리 큐비트 상의 에러율로 측 정된다. 동일한 물리 큐비트의 에러율에 대해, 더 낮은 논리 에러율은 더 우수한 복호화 성능을 나타낸다. 실시간 에러 정정에 적용 가능: 큐비트의 서비스 수명이 비교적 짧기 때문에(예를 들어, 초전도 큐비트의 서비 스 수명은 양호한 공정에서 약 50마이크로초이고, 발생하면 시간이 지남에 따라 에러가 점차 누적되기 때문에, 전체 에러 정정 과정에 소요되는 시간은 이론적으로 초전도 큐비트의 서비스 수명의 1/100 미만이어야 한다,즉, 에러 정정 시간의 엄격한 마진은 약 500ns이고, 그렇지 않으면, 에러 발생율은 표면 코드의 에러 정정 능력 을 초과할 수 있음), 중앙 처리 장치(CPU) 및 그래픽 처리 장치(GPU)는 메모리의 읽기 및 쓰기 시간의 불확실성 으로 인해 유발되는 긴 시간 지연을 가져서 요구 사항을 충족시킬 수 없고, CPU/GPU의 계산적 미세 구조는 복호 화 알고리즘에 최적화되어 있지 않아서, 성능 지표를 달성하는 것은 어렵다. 본 출원은 복호화 알고리즘이 FPGA(Field Programmable Gate Array) 또는 ASIC(Application Specific Integrated Circuit)와 같은 특정 컴 퓨팅 장치에 이식된 것으로 간주한다. 이러한 장치는 병렬화를 위한 간단한 단계(예를 들어, 벡터 내적 또는 행 렬 곱셈)를 수행하는 데 더 적합하고 조건 결정(condition determining) 및 점프가 있는 복잡한 명령을 실행하 는 데는 적합하지 않다. 마지막으로 FPGA/ASIC의 칩 영역은 대부분 실시간 연산에 사용되기 때문에, 온칩 캐시 (on-chip cache)를 위해 예비로 보유될 수 있는 영역이 제한되어 있어, 이는 칩 상에 과도한 데이터를 미리 로 드하지 않을 것을 요구한다. 신경망을 기반으로 디코더(신경망 디코더라고도 함)를 구성함으로써, 에러 신드롬 정보가 대응하는 에러 결과 정보를 획득하기 위해 복호화된다. 복호화 과정은 입력(에러 신드롬 정보)과 출력(에러 결과 정보)의 함수이기 때문에, 신경망이 구성될 수 있고 신경망은, 에러의 위치와 유형을 결정하는 방법을 학습하기 위해(지도 학습), 정확한 입/출력 결과를 사용하여 트레이닝된다. 신경망 디코더는 신경망 디코더의 출력 유형에 따라 두 가지 유 형으로 분류될 수 있다. 하나는 물리 레벨이고 다른 하나는 논리 레벨이다. 물리 레벨에 의해 출력되는 모델은 에러가 발생한 큐비트, 즉 특정 데이터 큐비트 내에서 어떤 종류의 에러가 발생했는지에 관한 구체적 정보를 직 접 생성한다. 논리 레벨에 의해 출력되는 모델은 특정 에러가 구체적으로 매핑된 후 논리 에러 클래스(표면 코 드에 대한 상동 관계 클래스임)을 출력하고, 이후 데이터 큐비트 상에서 구체적으로 발생하는 등가 에러가 논리 에러 클래스에 따라 연역(deduce)될 수 있다(연역 에러는 반드시 원래 발생한 에러와 동일하지는 않지만, 원래 발생한 에러와 동일한 효과를 가지며, 이는 양자 에러 정정 부호 특유의 에러 디제너러시(degeneracy) 현상임). 일반적인 신경망 복호화 알고리즘은 완전 연결 네트워크(fully connected network), CNN, 순환신경망 (recurrent neural network, RNN) 등을 사용한다. 신경망의 대부분의 연산은 행렬 연산이고, 신경망은 고도로 병렬화될 수 있고, 특정 하드웨어(예를 들어, FPGA 또는 ASIC) 상에서 짧은 실시간 컴퓨팅 시간 내에 구동되기 에 매우 적합하며, 우수한 실용적 응용 가능성을 가지고 있다. 신경망 복호기의 복호화 알고리즘의 복잡도, 복호화 시간, 복호화 성능, 및 실시간 에러 정정에 적용될 수 있는 지 여부는 모두 선택된 신경망 모델에 의존하고 물리 레벨 출력 또는 논리 레벨 출력이 사용되는지 여부에 관련 된다. 서로 다른 신경망의 측면 사이에는 큰 차이가 있다. 신경망 모델은 표면 코드의 길이가 상대적으로 작을 때 상대적으로 쉽게 구성되고, 복호화 성능은 일반적으로 최소 가중치 완전 일치(minimum weight perfect match, MWPM) 복호화 알고리즘의 성능을 훨씬 초과할 수 있고 최적 디코더에 가깝다. 하지만, 현재의 신경망 모 델은, 표면 코드와 같은 것을 사전 트레이닝하기 위해 신경망에 의해 요구되는 필요한 샘플의 수량이 L(즉, 위 에서 설명한 표면 코드의 길이)로 지수적으로 증가하기 때문에 일반적으로 긴 길이의 표면 코드를 복호화할 수 없다. 한편, 길이가 긴 표면 코드에 대한 알려진 신경망의 깊이는 깊고, 신경망이 반드시 실시간 에러 정정에 적합할 필요는 없다. 한편, 신경망 알고리즘은 FPGA/ASIC을 사용한 구현에 매우 적합하지만, 복호화 시간은 물 리 레벨의 디코더에서 고정되어 있지 않고 극단적인 경우 매우 길다. 다른 복호화 알고리즘에 비해 신경망 디코더는 길이가 짧은 표면 코드에 대해 우수한 복호화 성능을 획득될 수 있으며 사용되는 복호화 시간이 상대적으로 짧다. 신경망 알고리즘 프레임워크를 기반으로, 본 출원의 기술적 해결 방안은 신경망 알고리즘이 직면한 문제를 해결하려고 한다. 본 출원의 기술적 해결 방안에 의해 제공되는 신경망 디코더는 에러 신드롬 정보에 대한 블록 특징 추출을 수행하기 위해 분리 정복(divide and conquer)과 유사한 개념을 도입한다. 이러한 방식으로, 신경망의 깊이가 얕아지는 것이 보장될 수 있고, 복호화 시간의 하 한이 깊이로 인해 주어질 수 있다. 게다가, 신경망 디코더는 신경망의 복잡성을 줄이는 데 도움을 주기 위해 논 리 레벨 출력을 사용할 수 있어서, 복호화 시간이 더욱 단축될 수 있다. 한편, 실시간 에러 정정의 요구 사항을 충족시키기 위해, 본 출원의 기술적 해결 방안에 의해 설계된 네트워크 구조는 역시 단순하고, 모든 기본 계산 (행렬 곱셈 및 덧셈)은 하드웨어 병렬화를 통해 편리하고 직접적으로 완료될 수 있다. 게다가, 네트워크 파라미 터의 총 수량은 대응하는 표면 코드의 크기에 따라 완만하게 증가한다(최대한 다항식으로 L에 따라 증가하고, 모든 네트워크 파라미터는 온칩 캐시를 위해 FPGA/ASIC 내에 사전 로드될 필요가 있어서, 파라미터의 수량은 너 무 많을 수 없다). 게다가, 요구되는 복호화 성능을 달성하기 위해 신경망 디코더를 트레이닝하는 데 사용되는 샘플의 수량과 데이터 볼륨도 L에 따라 완만하게 증가한다. 이러한 방식으로, 디코더는 확장 가능(scalable)하 다. 수치 시뮬레이션은, L이 크지 않고 디코더의 복호화 성능이 좋을 때 디코더의 복호화 성능이 MWPM의 복호화 성능을 초과함을 보인다.도 3은 본 출원의 일 실시예에 따른 해결 방안의 응용 시나리오의 개략도이다. 도 3에 도시된 대로, 응용 시나 리오는 초전도 양자 컴퓨팅 플랫폼일 수 있고, 양자 회로(quantum circuit), 희석 냉장고(dilution refrigerator), 제어 기기, 및 컴퓨터를 포함한다. 양자 회로는 물리 큐비트 상에서 동작하는 회로이고, 양자 회로는 절대 영도 부근에서의 초전도 양자 칩과 같은 양자 칩으로 구현될 수 있다. 희석 냉장고는 초전도 양자 칩에 절대 영도 환경을 제공하도록 구 성된다. 제어 기기는 양자 회로를 제어하도록 구성되고, 컴퓨터는 제어 기기를 제어하도록 구성된다. 예를 들어, 작성된 양자 프로그램은 컴퓨터 내의 소프트웨어를 사용하여 명령어로 컴파일되고 제어 기기 로 전송되며, 제어 기기는 명령어를 전자/마이크로파 제어 신호로 변환하고 10 mK에서 초전도 큐비트를 제어하기 위해 전자/마이크로파 제어 신호를 희석 냉장고에 입력한다. 읽기 과정은 반대이다. 도 4에 도시된 대로, 본 출원의 실시예들에서 제공되는 신경망 기반 QEC 복호화 방법은 제어 기기와 결합될 필요가 있다. 제어 기기의 일반 제어 시스템(33a)(예를 들어, 중앙 보드 FPGA)이 양자 회로로부터 에러 신드롬 정보를 읽은 후, 일반 제어 시스템(33a)은 제어 기기의 에러 정정 모듈(33b)에 에러 정정 명령을 송 신하고, 에러 정정 명령은 양자 회로의 에러 신드롬 정보를 포함하고, 에러 정정 모듈(33b)은 FPGA 또는 ASIC 칩일 수 있다. 에러 정정 모듈(33b)은 신경망 기반의 QEC 복호화 알고리즘을 운용하고, 에러 신드롬 정보 를 복호화하고, 복호화를 통해 얻은 에러 결과 정보를 실시간으로 에러-정정 제어 신호로 변환하고, 에러 정정 을 위해 에러-정정 제어 신호를 양자 회로에게 송신한다. 이어지는 설명의 편의를 위해, QEC 코드를 복호화하기 위한 기본 알고리즘이 여기서 먼저 설명된다. 에러 정정 부호로서, 에러가 발생한 후, 에러 신드롬이 패리티 체크를 수행하여 획득될 수 있다. 에러의 발생 위치와 유형 (X 에러, Z 에러, 또는 둘 다, 즉, Y 에러)은 신드롬에 따라서 그리고 에러 정정 부호에 대한 특정 복호화 알고 리즘을 사용하여 또한 결정될 필요가 있다. 즉, 복호화 과정은 에러 발생 모델(큐비트 상에서 발생하는 에러의 확률 분포)과 단일 측정을 통해 획득되는 신드롬이 주어지는 것과 동등할 수 있고, 가장 발생 가능성이 높은 에 러가 무엇인지 유추된다. 일반적인 에러 정정 부호와 달리, 표면 부호의 에러 및 신드롬은 기하학적 의미를 갖는다. 표면 코드의 경우, 에러 정정 과정의 에러가 고려하지 않는다면(즉, 측정 과정이 완벽하면, 신드롬은 완전 신드롬이라고 함), 에러 신드롬은 0 및 1로 구성되는 2차원 어레이 이미지로 간주될 수 있다. 표면 코드의 경우, 에러의 위치와 유형은 신드롬의 위치에 따라 결정된다. QEC 이론에 따르면, 정정될 필요가 있는 두 가지 유형의 에러, 즉, X 에러와 Z 에러가 있다. 이러한 방식으로, X 에러 및 Z 에러와 연관된 대응하는 신드롬이 있다. X 에러와 Z 에러는 각각 정정될 수 있으며, 두 가지 유형의 신드롬도 유사한 방식으로 정정된다. 더 최적의 해결 방안은 X 에러와 Z 에 러를 둘다 동시에 정정하는 것이다. 많은 경우에, 두 가지 유형의 에러는 상관 관계가 있기 때문이다(MWPM은 두 가지 유형의 에러의 신드롬 간의 상관 관계를 동시에 사용할 수 없음). 노이즈가 없는(완벽한) 에러 신드롬의 경우, 최적 알고리즘이기도 한, 최대 A 포스테리어(maximum A posterior, MAP) 추정 알고리즘이 먼저 도입된다. S는 QEC 코드의 스태빌라이저 그룹으로 정의되고, L은 n비트 파울리 그룹 내의 S의 노멀라이저 (normalizer) 클래스로 정의된다. 발생한 Pauli 에러 E는 다음과 같이 분해될 수 있다."}
{"patent_id": "10-2021-7031512", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "여기서, L(E) ∈ L은 L(E)가 노멀라이저 클래스 L에 속하고 E의 함수임을 의미하고, S(E)는 에러 E의 신드롬이 고 에러 신드롬에 따라 매핑된 에러이고, 에러 세트는 매핑을 통해 생성되고 신드롬 세트와 일대일 대응되며, T(S(E))는 단순 에러 정정이라고 하고 에러 세트 내의 요소는 단순 에러라고 한다. T(S(E))의 선택은 매우 임의 적이지만, 일부 특정 선택 방식은 더 나은 이해를 돕는다. 이것은 여기에서 확장되지 않는다. 또 다른 에러 E' 에 대해, E와 E'가 동일한 에러 신드롬을 가진다면, E'는 다음과 같이 표현된다."}
{"patent_id": "10-2021-7031512", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "와 가 둘 다 동일한 노멀라이저 클래스 L에 속해 있음을 전제로, 두 개의 에러는 하나의 스태빌라이 저 그룹 내의 요소에 의해서만 다르고, 즉, 인코딩 공간에 대한 두 에러의 영향은 동등하다. E'는 E에 대한 에 러 정정을 수행하기 위해 선택될 수 있고(즉, E는 실제로 발생한 에러이지만, 둘 다 동등하기 때문에 실제로E'에 따라 정정될 수 있음), 동일한 효과를 갖는다. 표면 코드에 의해 표현되는 토폴로지 QEC 코드의 경우, 서 로 다른 노멀라이저 클래스 L은 연산자가 속한 서로 다른 토폴로지 상동 관계 클래스를 나타낸다. 토폴로지 에 러 정정 부호의 경우, \"상동 관계 클래스(homology class)\" 또는 \"에러 클래스(error class)\"와 같은 용어가 아래에서 노멀라이저 클래스를 나타내기 위해 사용된다. 상동 관계 클래스에 속하는 에러는 에러 신드롬을 생성 하지 않아서(모든 에러 신드롬은 0임), 에러는 논리 에러와 동등하다. 그 이유는 상동 관계 클래스에 속하는 에 러가 수학적으로 논리 에러이기 때문이다. 논리 에러는 인코딩 공간 내에서 발생하고, 논리 에러에 대한 신드롬 측정을 수행하여 획득되는 결과는 모두 0이다. 그러므로, 발생한 에러 가 주어지면 MAP 디코더의 추론 과정은 다음과 같이 표현될 수 있다. . 즉, 단순 에러가 제거된 후 에러가 가장 많이 속할 수 있는 노멀라이저 클래스만 결정될 필요가 있고, 이후 노 멀라이저 클래스 내의 임의의 요소는 정정될 필요가 있는 에러를 획득하기 위해 단순 디코더의 출력 에러를 곱 하여 선택된다. 즉, 복호화 문제는 분류 문제(classification problem)와 동등하다. 표면 코드의 경우, 노멀라 이저 클래스에 대응하는 세 개의 클래스는 논리 큐비트의 X, Y 및 Z의 세 연산자 및 X, Y 및 Z의 등가 연산자의 세트이다. 이는 고성능 신경망 분류기에 의해 정확히 효과적으로 해결될 수 있다(최적의 해결 방안에 근접함). 상동 관계 클래스 이 높은 정확도로 추정된 후, 에러 신드롬이 완전하므로, 단순 에러 T(S(E))는 즉시 획득될 수 있으며, 단순 에러에는, 정정될 필요가 있는 에러를 획득하기 위해 내의 임의의 요소 가 곱해진다: (상기 공식은 \"공식 1\"로 기록된다). 일반적인 에러 정정 부호와 비교하여, 표면 부호의 에러 및 신드롬은 기하학적 의미를 갖는다. 표면 코드의 경 우, 에러 정정 과정의 에러가 고려되지 않았다면(즉, 전체 신드롬 측정 과정이 완벽하면, 에러 신드롬 정보는 완전 에러 신드롬 정보라고 함), 에러 신드롬 정보는 0과 1로 구성된 2차원 어레이 이미지로서 간주될 수 있다. 표면 코드의 경우, 에러 정정은 에러의 위치와 유형이 신드롬의 위치에 따라 결정되는 것을 말한다. 이어지는 서술의 편의를 위해, 기하학적 의미를 갖는 단순 디코더의 클래스가 여기에 도입된다. \"최소 경계 거리(minimum boundary distance)\" 디코더라고 하는 단순 디코더는 결함 감내 에러 정정 복호화 프레임워크를 이해하기 위한 보다 직관적인 설명을 제공할 수 있다. 표면 코드의 패리티 검사 연산자는 각각 X 에러와 Z 에러를 검출하고 두 개의 에러가 대칭이므로, 두 에러 중 하나만 Z 에러인 것으로 가정된다. 회전된 표면 코드의 경우, 값이 1인 신 드롬 비트는 X 연산자 체인(에러 체인)에 의해 생성된 것으로 간주되고 체인의 기능은 신드롬 포인트를 두 경계 중 하나를 신드롬 포인트와 연결하는 것이다. 이 모든 체인 내의 경계로부터 가장 작은 거리를 갖는 신드롬 포 인트가 획득되고 신드롬 포인트에 대응하는 단순 에러가 기록된다. L*L 회전된 표면 코드에 대해, 그리고 X-클 래스 에러의 경우, 값이 1인 (L2-1)/2 신드롬은 \"최소 경계 거리\" 디코더를 사용하여 복호화될 필요가 있고, 신 드롬에 대응하는 단순 에러는 다음과 같이 기록된다."}
{"patent_id": "10-2021-7031512", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "이어서, 신드롬 이 측정을 통해 신드롬을 획득될 때, 단순 디코더의 복호화 출력은 , 즉 신드롬 비트로 1을 가진 모든 단순 에러의 곱으로 정의된다. 유사하게, Z 클래스 에러의 경우, 값이 1인 (L2-1)/2 신드롬도 \"최소 경계 거리\" 디코더를 사용하여 복호화될 필요가 있고, 신드롬에 대응하는 단 순 에러는 기록된다. 마지막으로, 매핑 관계의 (L2-1)개의 그룹을 담고 있는 매핑 테이블이 구성되고, 매핑 관 계의 각 그룹은 에러 신드롬 포인트 및 단순 에러 사이의 매핑 관계를 포함한다. 단순 복호화 과정은 병렬로 수 행될 수 있으며(본질적으로 테이블 룩업 과정 이후에 합산을 수행하는 과정임), 실제의 경우, 시간 복잡도는 O일 수 있다. MAP 또는 최적 알고리즘을 사용하여 복호화를 수행하는 복잡성은 NP-완전에 있고, 즉, 최적 해결 방안은 근사 방법을 사용하여 접근한다. QEC 코드에 대한 다양한 복호화 알고리즘은 최적 해결 방안에 대한 근사치로 간주될수 있다. 본 출원의 기술적 해결 방안은 주로 근사를 위해 신경망 디코더를 채택한다. 본 출원의 방법 실시예가 설명되기 전에, 방법의 구동 환경(또는 실행 본체라고 함)이 먼저 설명된다. 본 출원 의 본 실시예에 따른 신경망 기반 QEC 복호화 방법은 고전 컴퓨터(예를 들어, 개인용 컴퓨터(PC), 서버 또는 컴 퓨팅 호스트)에 의해 구현될 수 있다. 예를 들어, 고전 컴퓨터는 상기 방법을 구현하기 위해 대응하는 컴퓨터 프로그램을 실행하도록 사용된다. 상기 방법은 양자 컴퓨터에 의해 대안으로 수행될 수 있다. 상기 방법은 고전 컴퓨터와 양자 컴퓨터의 하이브리드 기기 환경에서 대안으로 수행될 수 있다. 예를 들어, 상기 방법을 수행하는 것의 대응하는 계산 결과가, 고전 컴퓨터 상에서 양자 회로를 시뮬레이션하는 대신, 양자 컴퓨터 상에 직접 양 자 회로를 배치하는 것이 이론상으로 더 좋은 것으로 가정되는 이유 때문에, 양자 컴퓨터는 양자 회로 등의 에 러 신드롬 정보를 획득하는 단계 등을 수행하고, 이후 고전 컴퓨터는, 에러 결과 정보 등을 획득하기 위해, 에 러 신드롬 정보에 대해 블록 특징 추출 및 융합 복호화 처리를 수행하는 단계를 수행한다. 아래의 방법 실시예에서, 설명의 편의를 위해, 설명은 컴퓨터 기기(예를 들어, 도 3에 도시된 응용 시나리오의 제어 기기)를 단계들의 실행 본체로서 단지 사용하여 제공된다. 컴퓨터 기기는 고전 컴퓨터일 수 있거나 또는 양자 컴퓨터일 수 있거나, 또는 고전 컴퓨터와 양자 컴퓨터를 포함하는 하이브리드 실행 환경일 수 있음이 이해 되어야 한다. 이것은 본 출원의 실시예들에서 한정되지 않는다. 다음으로, 본 출원의 기술적 해결 수단 몇 가지 실시예를 사용하여 설명된다. 도 5는 본 출원의 일 실시예에 따른 신경망 기반 양자 에러 정정 복호화 방법의 흐름도이다. 이 방법은 도 3에 도시된 응용 시나리오의 제어 기기에 적용 가능하다. 상기 방법은 다음 단계(501 내지 503)를 포함할 수 있다. 단계 501. 양자 회로의 에러 신드롬 정보를 획득하고, 에러 신드롬 정보는 QEC 코드의 스태빌라이저 생성기의 고유치로 구성된 데이터 어레이이다. 에러 신드롬 측정이, 대응하는 에러 신드롬 정보를 획득하기 위해, QEC 코드를 사용하여 양자 회로에 대해 수행 될 수 있다. 에러 신드롬 정보는 QEC 코드의 스태빌라이저 생성기의 고유치로 구성된 데이터 어레이이다. 일부 실시예에서, 에러 신드롬 정보는 0과 1로 구성된 2차원 또는 3차원 데이터 어레이이다. 예를 들어, 에러가 없을 때, 스태빌라이저 생성기의 고유치는 0이고, 에러가 있을 때, 스태빌라이저 생성기의 고유치는 1이다. 예를 들어, QEC 코드는 표면 코드이다. 표면 코드의 경우, 에러와 에러 신드롬은 특정 공간 위치를 가진다. 에 러가 있고 신드롬이 발생할 때, 대응하는 위치의 보조 큐비트의 고유치는 1이다(이는 점 입자가 상기 위치에 나 타나는 것으로 볼 수 있음). 에러가 없을 때, 대응하는 위치에 있는 보조 큐비트의 고유치는 0이다. 그러므로, 표면 코드의 경우, 에러 정정 과정의 에러가 고려되지 않으면(즉, 측정 과정이 완벽하면, 신드롬은 완전 신드롬 이라고 지칭됨), 에러 신드롬 정보는 도 6에 도시된 대로, 0과 1에 의해 형성된 2차원 어레이 이미지로 간주될 수 있다. 단계 502. 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 에러 신드롬 정보에 대한 블록 특징 추출을 수행한다. 단계 503. 에러 결과 정보를 획득하기 위해, 신경망 디코더를 사용하여 특징 정보에 대해 융합 복호화 처리를 수행하고, 에러 결과 정보는 에러가 발생하는 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용된다. 신경망 디코더는 신경망을 기반으로 구축된 기계 학습 모델이고 에러 신드롬 정보를 복호화하도록 구성된다. 신 경망 디코더의 입력된 데이터는 에러 신드롬 정보이고, 출력된 데이터는 에러 신드롬 정보에 대응하는 에러 결 과 정보이다. 신경망 디코더는 블록 특징 추출 방식으로 분리 정복 아이디어를 사용하여 에러 신드롬 정보에 대 한 특징 추출을 수행한다. 즉, 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 블록 특징 추출을 수 행하도록 구성된다. 블록 특징 추출은, 특징 정보를 추출할 때, 신경망 디코더의 특징 추출 레이어가 입력된 데 이터를 복수의 블록으로 분할하고 블록에 대해 특징 추출을 각각 수행하는 것을 의미한다. 즉, 블록 특징 추출 은, 입력된 데이터가 적어도 2개의 블록으로 분할된 후, 적어도 2개의 특징 추출부를 사용하여 적어도 2개의 블 록에 대해 병렬 특징 추출을 수행하도록 구성된다. 적어도 2개의 블록은 적어도 특징 추출부와 일대일 대응 관 계에 있다. 각 특징 추출부는 하나의 블록에 대해 특징 추출을 수행하도록 구성되고, 블록의 수량은 특징 추출 부의 수량과 동일하다. 게다가, 특징 추출이 적어도 2개의 블록에 대해 병렬로 수행된다, 즉, 특징 추출이 적어 도 2개의 블록에 대해 동시에 수행되어서, 특징 추출에 소요되는 시간을 줄이는 데 도움이 된다. 완전 에러 신드롬을 획득한 경우를 먼저 고려하고, 상기 경우는 모델의 유효성(validity)을 확인할 수 있다. 복 호화 문제는 분류 문제와 동등할 수 있기 때문에, 기존의 신경망은 다양한 입력 에러 신드롬을 분류하려고 시도 할 수 있다. 가장 간단한 방법은 입력 레이어, 중간 은닉 레이어, 및 출력 레이어를 포함하는 완전 연결 네트워 크를 사용하는 것이다. 출력 레이어는 분류될 필요가 있는 네 개의 상동 관계 클래스(I, X, Y, 및 Z)만 포함한 다. I는 에러 없음, X는 X 에러를 나타내고, Z는 Z 에러를 나타내며, Y는 X 에러와 Z 에러 모두를 나타낸다. 문 제는 복호화될 필요가 있는 표면 코드의 길이가 점점 커지고 네트워크 내에 포함되는 파라미터의 수량이 기하급 수적으로 증가함에 따라, 네트워크를 트레이닝시키는 어려움(요구되는 데이터 세트 및 수렴 시간)도 기하급수적 으로 증가한다는 데 있다. 이러한 상황에 대처하기 위해, 본 출원은 분리 정복 아이디어를 제안하고 블록 특징 추출 방식을 채택한다. 즉, 큰 표면 코드는 작은 블록으로 분해되고, \"분류\"가 작은 블록에 대해 수행되고(여기 서 \"분류\"는 특징 정보를 추출하는 것을 의미함), 분류된 정보(클래스의 확률)는 이전의 레이어로 전달되고, 그 다음 이전의 레이어는 다음 레이어에 의해 전달된 정보 및 이전의 레이어에서의 등가 에러 신드롬에 따라 레이 어 내에서 에러 클래스의 발생 확률을 결정한다. 이 재귀(recursion)는 전체 표면 코드의 에러 클래스의 확률이 최종적으로 모여질 때까지 수행되고, 이후 분류 및 에러 정정이 수행된다. 예시적인 실시예에서, 신경망 디코더는 m개의 캐스케이드된 특징 추출 레이어를 포함하고, m은 양의 정수이다. 특징 추출 레이어는 특징 추출을 위한 신경망 레이어이다. 단계 502는, 특징 정보를 획득하기 위해, m개의 특징 추출 레이어를 사용하여 에러 신드롬 정보에 대해 블록 특징 추출을 수행하는 것을 포함할 수 있다. 제1 특징 추출 레이어는 에러 신드롬 정보에 대해 블록 특징 추출을 수행하도록 구성되고, i번째 특징 추출 레이어는 이 전의 특징 추출 레이어의 특징 추출 결과에 대해 블록 특징 추출을 수행하도록 구성되며, i는 1보다 크고 m보다 작거나 같은 정수이다. 일부 실시예에서, 신경망 디코더는 복수의 캐스케이드된 특징 융합 레이어를 더 포함하고, 특징 융합 레이어는 특징 추출 레이어에 의해 추출된 특징 정보에 대해 융합 복호화 처리를 수행하기 위한 신경망 레이어이다. CNN이 예시로 사용될 때, 특징 추출 레이어는 컨볼루션 레이어(convolutional layer)이고, 특징 융합 레이어는 완전 연결 레이어일 수 있다. 신경망 디코더는 입력 레이어, 적어도 하나의 컨볼루션 레이어, 적어도 하나의 완 전 연결 레이어, 및 출력 레이어를 포함한다. 일반적으로 복수의 컨볼루션 레이어가 있으며 일반적으로 복수의 완전 연결 레이어도 있다. 도 6에 도시된 대로, 에러 신드롬 정보는 복수의 데이터 단위로 분류된다. 도 6 에서, 에러 신드롬 정보는 예를 들어 4*4 데이터 어레이이고 네 개의 데이터 단위로 분류되며(서로 다른 데이터 단위가 도 6에서 서로 다른 필링(filling)으로 도시됨), 각 데이터 단위는 2*2 서브 어레이이다. 에러 신드롬 정보는 신경망 디코더에 입력된다. 신경망 디코더의 컨볼루션 레이어에 대해, 서로 다른 데이터 단 위가 블록 특징 추출 방식으로 동일한 컨볼루션 커널에 의해 동시에 판독된다. C 특징이 판독될 필요가 있다면, C 컨볼루션 커널이 요구된다. C는 컨볼루션 레이어에 대응하는 채널의 수량이다. 길이가 L인 표면 코드의 경우, 각 컨볼루션에 대응하는 서브 어레이의 길이는 이고, 첫 번째 레이어는 하나의 채널에서 개의 채널로 매 핑된 컨볼루션 커널을 필요로 하고, 두 번째 레이어는 개의 채널에서 개의 채널로 매핑된 컨볼루션 커널을 필요로 하여서, 대략적으로 총 개의 컨볼루션의 레이어가 요구된다. 채널의 수량은 조 정될 필요가 있는 하이퍼파라미터(hyperparameter)이며 L에 따라 증가한다. 마지막으로, 대략 크기의 어레이가 컨볼루션 레이어에서 출력되고, 어레이는 완전 연결 레이어에 입력된다. 이 어 레이가 하나의 완전 연결 레이어를 통과할 때마다 선택되면, 완전 연결 레이어의 깊이는 대략 이다. 이 러한 방식으로, 상대적으로 작은 깊이를 갖는 모델이 길이가 매우 긴 표면 코드에 대해 사용될 수 있다. 이러한 방식으로 모델의 깊이는 점근적으로 이다. 이 선택되면, 컨볼루션 신경망의 k번째 레 이어부터 컨볼루션 신경망의 (k+1)번째 레이어는 개의 파라미터를 포함하고, 모든 컨볼루션 레이어의 파 라미터의 총 수량은 이다. 유사하게, 완전 연결 레이어의 파라미터의 총 수량도 이다. 서로 다른 값이 각 재정규화(renormalization) 동안 서브 어레이의 크기에 대해 선택될 수 있다. 증가 방식은 지수적이라기 보다는 분명히 다항식이고, 즉, 해결 방안은 확장 가능할 것이다. 예를 들어, 에러 신드롬 정보는 8*8 데이터 어레이이고, 8*8 데이터 어레이는 16개의 2*2 서브 어레이로 분할될 수 있다. 제1 컨볼루션 레이어의 컨볼루션 커널의 크기는 2*2이고, 블록 특징 추출이, 4*4 특징 데이터 어레이를 획득하기 위해, 제1 컨볼루션 레이어를 사용하여 수행되며, 4*4 특징 데이터 어레이는 네 개의 2*2 서브 어 레이로 분할될 수 있다. 제2 컨볼루션 레이어의 컨볼루션 커널의 크기는 2*2이고, 블록 특징 추출이, 2*2 특징 데이터 어레이를 획득하기 위해, 제2 컨볼루션 레이어를 사용하여 수행될 수 있다. 에러 신드롬 정보 또는 특징 데이터 어레이가 분할될 때, 분리된 서브 어레이의 크기는 같을 수도 있고 또는 서로 다를 수도 있다. 서로 다 른 큐비트가 서로 다른 에러율을 유발하는 경우, 서로 다른 크기는 원칙적으로 유리함을 가져온다. 하지만, 크 기가 동일하면, 트레이닝이나 또는 추론을 위한 연산이 상대적으로 쉽다. 일부 실시예에서, 특징 추출 레이어가 블록 특징 추출을 수행할 때, 임의의 두 블록 사이에는 교차 부분 (intersection)이 없다. 즉, 특징 추출의 각 레이어에 대해, 모든 서브 어레이 사이에 통신이 없고, 컨볼루션 커널이 작용하는 영역 내에서 신드롬 사이에 교차 부분이 없다. 서브 어레이의 특징 정보가 수집되어 다음 레이 어로 모일 때만, 서브 어레이의 정보가 처리되고 동시에 총괄적으로 사용된다. 특징 추출이 반드시 특정 큐비트 에러 확률에 대응하는 것은 아니기 때문에, 신뢰 전파(belief propagation)가 한계 확률(marginal probability)을 정렬하기 위해 수행될 필요는 없고, 이는 알고리즘을 단순화하고 더 나은 성능을 제공할 가능성 이 높다. 예시적으로, 알고리즘이 L=15를 예시로 사용하여 설명된다. 총 2개의 컨볼루션의 레이어가 있다. 4*4 컨볼루션 커널은 컨볼루션의 첫 번째 레이어에 사용될 수 있고, 컨볼루션 커널은 하나의 채널에서 500개 채널로 매핑되며, 제2 레이어의 컨볼루션 커널의 크기는 2*2이고, 컨볼루션 커널은 500개 채널에서 1000개 채널로 매핑 된다. 이 경우, 두 번째 레이어에는 4000개의 뉴런이 있다. 이어서, 4000개의 뉴런의 값이 완전 연결 네트워크 를 사용하여 분류되고, 첫 번째 완전 연결 레이어는 4000개에서 1024개의 뉴런을 연결하고, 두 번째 완전 연결 레이어는 1024개에서 512개의 뉴런을 연결하고, 세 번째 완전 연결 레이어는 512에서 128개의 뉴런을 연결하고, 네 번째 완전 연결 레이어는 128에서 4개의 뉴런(I, X, Y, Z)을 연결한다. 특정 네트워크 모델의 파이토치 (Pytorch) 코드는 다음과 같을 수 있다. from torch import nn class CNN_2D(nn.Module): def __init__(self, input_size, output_size = 4): self.input_size = input_size super(CNN_2D, self).__init__() self.conv1 = nn.Conv2D(15, 500, stride = 4, kernel_size = 4, padding = 0) self.relu1 = nn.ReLU() self.conv2 = nn.Conv2D(500, 1000, stride = 2, kernel_size = 2, padding = 0) self.relu2 = nn.ReLU() self.fc1 = nn.Linear(1000*2*2, 1024) self.relu3 = nn.ReLU() self.fc2 = nn.Linear(1024, 512) self.relu4 = nn.ReLU() self.fc3 = nn.Linear(512, 128) self.relu5 = nn.ReLU() self.fc4 = nn.Linear(128, 4) def forward(self, x): x = self.conv1(x) x = self.relu1(x) x = self.conv2(x) x = self.relu2(x) x = x.view(-1, 1000*2*2) x = self.c1(x) x = self.relu3(x) x = self.fc2(x) x = self.relu4(x) x = self.fc3(x) x = self.relu5(x) x = self.fc4(x) 위의 예시에서 볼 수 있듯이, 단순 ReLU 레이어가 제거되고, 전체 신경망 내에 6개의 레이어만 있으며, 신경망 은 매우 얕다. 에러가 발생하는 양자 회로 내의 물리 큐비트 및 대응하는 에러 유형은 신경망 디코더에서 출력되는 에러 결과 정보를 기반으로 결정될 수 있다. 예를 들어, 에러가 발생한 양자 회로 내의 물리 큐비트의 위치와 에러가 그 위치에서 발생한 물리 큐비트의 에러 유형이 결정된다. 예를 들어, 에러 유형은 X 에러, Z 에러, 또는 Y 에러이 다. 일부 실시예에서, 신경망 디코더의 복잡성을 줄이고 복호화 시간을 더 줄이기 위해, 신경망 디코더는 논리 레벨 출력을 사용할 수 있다. 이 경우, 신경망 디코더에서 출력되는 에러 결과 정보는 논리 레벨 출력 결과를 포함하 고, 논리 레벨 출력 결과는 에러가 구체적으로 매핑된 후 획득되는 논리 에러 클래스를 의미한다. 게다가, 실시간 QEC가 수행될 때, 2가지 형태의 스태빌라이저 생성기에 대한 측정(패리티 체크) 회로가 본 출원 의 도 7에 도시된다. 도 7의 (a) 부분은 Z 에러를 검출하기 위한 스태빌라이저 생성기의 고유치 측정 회로를 도 시하고, 도 7의 (b) 부분은 X 에러를 검출하기 위한 스태빌라이저 생성기의 고유치 측정 회로를 도시한다. 이 회로에서, CNOT(Controlled NOT) 게이트의 동작의 순서는 매우 중요하며 되돌릴 수 없고, 그렇지 않으면, 동일 한 큐비트를 사용하는 다른 양자 게이트로 인한 충돌이 발생한다. 이 과정에서, CNOT 게이트, 보조 상태 준비 (auxiliary state preparation), 및 최종 보조 상태 측정을 포함하는 모든 단계에서 노이즈가 발생한다. CNOT 게이트는 에러를 전송하기 때문에, X와 Z에 대한 두 가지 유형의 신드롬 측정이 함께 내장된다. 에러의 전파는 도 7에 도시된 정렬 방식으로 최소화될 수 있고, 에러 정정 능력에 미치는 그것의 영향은 무시된다. 또 다른 시 퀀스로의 정렬은 에러 정정 능력을 크게 감소시킨다. 도 8은 노이즈를 가진 신드롬 측정 회로(또는 고유치 측정 회로 또는 패리티 검사 회로라고도 함)의 에러 신드 롬의 개략도이다. 도 8에서, 흰색 점은 측정이 정정된, 측정값이 1인 에러 신드롬을 나타내고, 검은색 점 은 측정이 정정되지 않은, 측정값이 1인 에러 신드롬을 나타낸다. 왼쪽 하단 모서리의 흰색 중심을 가진 검 은색 점은 1이 측정되어야 하지만 0이 측정됨을 나타낸다. 정정되지 않은 신드롬 포인트가 1개만 있어도, 참담 한 결과가 초래됨이 예측될 수 있어서(이는 표면 코드가 단순 신드롬 측정 회로를 채용하기 때문이며, 복호화 및 에러 정정이 하나의 정정되지 않은 신드롬 포인트에 기반하여 수행되어서, 결과적으로 많은 양의 에러가 발 생하고, 그에 따라 에러 정정 부호의 에러 정정 능력을 즉시 초과하게 됨), 따라서 하나의 신드롬 측정의 결과 가 신뢰될 수 없다. 이에 따라, 복수 회의 신드롬 측정이 수행될 필요가 있다. 이론적으로, 결함 감내 에러 정 정의 실효성을 보장하기 위해, T=O(L)번의 에러 신드롬 정보의 측정이 수집될 필요가 있고, 에러의 위치가 신드 롬을 함께 사용하여 추론되고, 에러 정정이 수행된다. 도 9는 3차원 신드롬 분포의 개략도이며, 길이 방향은 시간이다. 이것은 0과 1로 구성된 3차원 데이터 어레이라 고 볼 수 있다. 총 네 개의 슬라이스가 도 9에 포함되고, 각 슬라이스는 하나의 측정에 의해 획득된 에 러 신드롬 정보를 나타낸다. 각 슬라이스에서, 일부 검은 점들은 Z 에러의 신드롬 고유치가 1로 측정되었음 을 나타내고, 다른 검은 점들은 X 에러의 신드롬 고유치가 1로 측정된 것을 나타내며, 이는 도 9에서 구별되지 않는다. 게다가, 신드롬 측정 회로에서 발생하는 노이즈는 큐비트에서 발생하는 랜덤 노이즈 및 보조 상태 측정에 의해 발생하는 노이즈와 동등할 수 있다. 이 경우, 모든 노이즈 및 신드롬의 시공간적(spatial-temporal) 특징의 단면은 도 10에 도시된 것과 유사하다. 도 10에서, 슬래시로 채워진 선 세그먼트는 값이 1인 신드롬을 나타 내고, 검은색으로 채워진 선 세그먼트는 발생한 에러를 나타내며, 수형 방향의 에러는 데이터 큐비트 상에 서 발생하는 에러를 나타내고, 수직 선의 에러는 보조 큐비트를 측정하여 발생하는 에러를 나타내고, 두 가지 유형의 에러가 3차원 공간 내의 닫힌 곡선(closed curbe)을 형성하기 위해 결합(\"추가\")된다(시간에 따라 무한 연장됨). 이 경우, 물리 큐비트 상의 노이즈는 독립적이지만, 큐비트 상에서 발생하는 등가 노이즈는 약한 상관 관계가 있다. 이는 CNOT 게이트는 하나의 보조 큐비트 상에서 발생하는 노이즈를 두 개의 데이터 큐비트로 전파 하기 때문이다. 하지만, 노이즈가 표면 코드의 에러 정정 범위 내에 있기 때문에 상관도(degree of correlation)의 손상은 제한적이나, 노이즈는 여전히 에러 정정 성능을 미약하게 저하시키는 원인이 된다. 예시적인 실시예에서, QEC 복호화의 효율성을 보장하기 위해, 획득된 에러 신드롬 정보는 T개의 데이터 어레이 를 포함하고, 각 데이터 어레이는 QEC 코드를 사용하여 타깃 양자 회로에 대해 하나의 에러 신드롬 측정을 수행 함으로써 획득되며, T는 1보다 큰 정수이다. 일부 실시예에서, 전술한 대로, T=O(L)이다. 이 경우, 에러 신드롬 정보가 획득된 후, 에러 신드롬 정보는 적어도 두 개의 데이터 단위로 분류된다. 하나의 데이터 단위는 T개의 데이터 어레이 내의 동일한 위치에 있는 T개의 어레이 단위를 포함한다. 구체적인 신경망 알고리즘이 도 11에 도시되고, 신경망 알고리즘의 구조는 완전 신드롬의 경우와 매우 유사하지만, 완전 신드롬 의 경우와 차이가 있다. 도 11에 도시된 대로, 에러 신드롬 정보는 복수의 데이터 단위로 분류된다. 도 11 에서, 예를 들어, 에러 신드롬 정보는 4*4*4 데이터 어레이이고 네 개의 데이터 단위로 분류되며(서로 다른 데 이터 단위가 도 11에서 서로 다른 필링(filling)으로 표시됨), 각 데이터 단위는 2*2*4의 서브 어레이이다. 에 러 신드롬 정보는 신경망 디코더에 입력된다. 신경망 디코더의 컨볼루션 레이어는 블록 특징 추 출 방식으로 특징 정보를 추출한다. 실시간 에러 정정 동안, 상동 관계 클래스를 분류하는 것 외에도 신드롬도 분류될 필요가 있다. 반복을 피하기 위해, 상동 관계 클래스에 대한 분류만 여기에 예시로 나열된다. 먼저 첫 번째 CNN 레이어의 입력 채널이 T개의 레이어로 변경된다. 이후, 각각의 다른 CNN 레이어의 출력 채널의 수량은 에서 로 증가한다. 이 경우, 디코더의 최종 깊이는 여전히 이며 대략적으로 파라미터가 요구된다. 하드웨어 연산 알고리즘이 선택될 때, 이러한 파라미터를 저장하고 각 컨볼루션 레이어와 완전 연결 레이어를 병렬화할 공간이 충분한지 여부가 고려될 필요가 있다. 전술한 내용을 기반으로, 본 출원의 실시예들에서 제공되는 기술적 해결 방안에 따르면, 블록 특징 추출이, 복 수의 그룹의 특징 정보를 획득하기 위해, 양자 회로의 에러 신드롬 정보에 대해 수행되고, 융합 복호화 처리가, 에러 결과 정보를 획득하기 위해, 복수의 그룹의 특징 정보에 대해 추가로 수행된다. 블록 특징 추출 방식이 사 용되기 때문에, 입력 데이터에 대한 완전 특징 추출에 비해, 한편으로, 각 특징 추출에 의해 획득되는 특징 정 보의 채널의 수량이 줄어들고, 다음 특징 추출의 입력된 데이터가 감소되며, 이는 신경망 디코더 내의 특징 추 출 레이어의 수량을 감소시키는 데 도움이 되고, 이에 따라 신경망 디코더의 깊이가 짧아질 수 있다. 신경망 디 코더의 깊이가 짧아지기 때문에, 신경망 디코더에 의해 사용되는 복호화 시간이 상응하여 감소된다. 한편, 블록 특징 추출이 수행될 때, 병렬 특징 추출 처리가 복수의 특징 추출부를 사용하여 복수의 블록에 대해 수행되고, 즉, 복수의 특징 추출부가 특징 추출 처리를 동기식으로(또는 동시에) 수행할 수 있고, 이는 특징 추출에 소요 되는 시간을 줄이는 데 도움이 되고, 이에 따라 복호화 시간이 감소될 수 있다. 마지막으로, 두 가지 요소를 참 조하여, QEC 복호화가 신경망 디코더를 사용하여 수행될 때, 복호화 시간이 완전히 단축되어, 이에 따라 실시간 에러 정정의 요구 사항이 충족될 수 있다. 예시적인 실시예에서, 에러 신드롬 정보는 QEC 코드를 사용하여 양자 회로 상의 노이즈를 갖는 에러 신드롬 측 정을 수행하여 획득된 실제 에러 신드롬 정보이다. 결함 감내 및 에러 정정 복호화를 구현하기 위해, 신경망 디 코더는 제1 디코더 및 제2 디코더를 포함한다. 도 12에 도시된 대로, 본 출원의 다른 실시예에서 제공되는 신경 망 기반 QEC 복호화 방법은 다음의 단계(1201 내지 1204)를 포함할 수 있다. 단계 1201. 양자 회로의 실제 에러 신드롬 정보를 획득한다. 실제 시나리오에서, 에러 신드롬 측정이 QEC 코드를 사용하여 양자회로에 대해 수행될 때의 노이즈가 있기 때문 에, 즉, 측정 에러가 있기 때문에, 여기서의 실제 에러 신드롬 정보는 실제 시나리오에서 측정을 통해 획득된 노이즈를 갖는 에러 신드롬 정보를 지칭한다. 게다가, 결함 감내 및 에러 정정의 효율성을 보장하기 위해, 획득된 실제 에러 신드롬 정보는 T개의 데이터 어 레이를 포함하고, 각 데이터 어레이는 QEC 코드를 사용하여 양자 회로 상에 노이즈를 갖는 에러 신드롬 측정을 수행하여 획득되며, T는 1보다 큰 정수이다. 일부 실시예에서, 전술한 대로, T=O(L)이고, L은 QEC 코드의 길이이다. 이 경우, 에러 신드롬 측정 시마다 획득되는 실제 에러 신드롬 정보는 (L+1)*(L+1) 2차원 데이터 어레이 일 수 있고(머신 러닝의 편의를 위해, 각 순간의 신드롬 경계가 적절히 확장됨), T번의 에러 신드롬 측정에 의 해 획득되는 실제 에러 신드롬 정보는 (L+1)*(L+1)*T 3차원 데이터 어레이를 형성할 수 있다. 단계 1202. 실제 에러 신드롬 정보에 대응하는 논리 에러 클래스를 획득하기 위해, 제1 디코더를 사용하여 실제 에러 신드롬 정보를 복호화한다. 제1 디코더는, 실제 에러 신드롬 정보에 대응하는 논리 에러 클래스를 획득하기 위해, 실제 에러 신드롬 정보를 복호화하도록 구성된다. 논리 에러 클래스는 양자 회로에서 발생한 에러가 매핑된 후 획득되는 클래스이다. 논 리 에러 클래스는 상동 관계 클래스(homology class)라고도 하며, 네 개의 클래스, I, X, Y, 및 Z를 포함한다. I는 에러가 없음을 나타내고, X는 X 에러를 나타내고, Z는 Z 에러를 나타내며, Y는 X 에러와 Z 에러 둘 모두를 나타낸다. 각 논리 에러 클래스는 적어도 하나의 동등 에러 요소(equivalent error element)를 포함한다. 일부 실시예에서, 각각의 논리 에러 클래스는 복수의 등가 에러 요소를 포함한다. 논리 에러 클래스 I 내의 요소는 스태빌라이저 그룹 내의 요소이다. 논리 에러 클래스 X 내의 요소는 논리 X 연산자에 스태빌라이저 그룹 내의 각 요소를 곱하여 획득되는 요소 세트이다. 논리 에러 클래스 Y 내의 요소는 논리 Y 연산자에 스태빌라이저 그 룹 내의 각 요소를 곱하여 획득되는 요소 세트이다. 논리 에러 클래스 Z 내의 요소는 논리 Z 연산자에 스태빌라 이저 그룹 내의 각 요소를 곱하여 획득되는 요소 세트다. 동일한 논리 에러 클래스에 속하는 요소는 동등하다. 실제 발생한 에러 E와 다른 에러 E'는 동일한 논리 에러 클래스에 속한다고 가정하고, 에러 E에 대한 에러 정정 과 에러 E'에 대한 에러 정정은 동등하여서, 동일한 효과가 달성될 수 있다. 본 출원의 본 실시예에서, 실제 에러 신드롬 정보에 대응하는 논리 에러 클래스는 트레이닝된 제1 디코더를 사 용하여 예측을 통해 획득된다. 하나의 제1 디코더가 있을 수 있고, 제1 디코더는 네 개의 분류 모델일 수 있고, 제1 디코더의 출력은 분류될 필요가 있는 네 개의 논리 에러 클래스, 즉 I, X, Y, 및 Z를 포함할 수 있다. 디코 더는 완전 연결 네트워크, 또는 CNN, 또는 RNN, 또는 다른 신경망을 기반으로 구성된 분류 모델일 수 있다. 이 것은 본 출원의 본 실시예에서 한정되지 않는다. 게다가, 제1 디코더가 대응하는 논리 에러 클래스를 획득하기 위해 실제 에러 신드롬 정보를 복호화할 때, 앞선 실시예에서 설명된 블록 특징 추출 방식이 사용될 수 있다. 블록 특징 추출은, 특징 정보를 획득하기 위해, 제1 디코더를 사용하여 실제 에러 신드롬 정보에 대해 수행되고, 융답 복호화 처리는, 실제 에러 신드롬 정보에 대 응하는 논리 에러 클래스를 획득하기 위해, 제1 디코더를 사용하여 특징 정보에 대해 수행된다. 단계 1203. 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보를 획득하기 위해, 제2 디코더를 사용하여 실제 에러 신드롬 정보를 복호화한다. 제2 디코더는, 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보를 획득하기 위해, 실제 에러 신드롬 정보를 복호화하도록 구성된다. 완전 에러 신드롬 정보는 양자 회로 상의 노이즈를 갖지 않는 에러 신드롬 측정 을 수행하여 획득되는 정보를 지칭한다. 본 출원의 본 실시예에서, 실제 에러 신드롬 정보는, 대응하는 논리 에 러 클래스에 추가하여 대응하는 완전 에러 신드롬 정보를 획득하기 위해, 복호화될 필요가 있어서, 양자 회로의 에러 결과 정보는 위에서 설명된 공식 1에 따라 최종적으로 결정될 수 있다. 예시적으로, 도 13은 완전 에러 신 드롬 정보의 개략도이다. 도 13에서, 검은색 점은 데이터 큐비트를 나타내고, 십자는 보조 큐비트를 나타내고, 보조 큐비트 상에서 발생하는 에러는 완전 신드롬 측정에 영향을 미치지 않으며, 에러는 X, Y, 및 Z 로 도면 내에서 표시된다. 본 출원의 본 실시예에서, 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보는 트레이닝된 제2 디코더 를 사용하여 획득된다. 하나 이상의 제2 디코더가 있을 수 있다. 일부 실시예에서, k개의 제2 디코더가 있고, k 는 양의 정수이고 k는 QEC 부호의 길이와 관련된다. QEC 코드는 길이가 L인 스태빌라이저 코드이고, k=L2-1개의 제2 디코더가 있는 것으로 가정된다. 이 경우, 제2 디코더는 이진 분류 모델일 수 있고 제2 디코더의 출력은 분 류될 필요가 있는 두 개의 에러 신드롬 값, 즉, 0과 1을 포함하고, 0은 에러가 없음을 나타내고, 1은 에러를 나 타낸다. 단계 1202 및 단계 1203은 순차적으로 수행될 수도 있고, 또는 병렬적으로 수행될 수도 있다. 단계 1202 및 단 계 1203가 병렬적으로 수행될 때, 이는 처리의 수행에 소요되는 시간을 줄이는 데 도움이 된다. 실시간 결함 감 내 에러 정정 복호화를 구현하기 위해, 더 많은 기기(예를 들어, FPGA/ASIC) 및 적절한 통신 연결이 병렬 실행 을 완료하기 위해 가능한 많이 선택된다. 예시적인 실시예에서, k개의 제2 디코더가 있고, k는 양의 정수이고 k는 양자 에러 정정 부호의 길이와 관련된 다. k개의 제2 디코더는, k개의 완전 에러 신드롬 비트를 획득하기 위해, 실제 에러 신드롬 정보를 각각 복호화 하도록 구성되고, k개의 완전 에러 신드롬 비트는 완전 에러 신드롬 정보를 획득하기 위한 병합을 수행하는 데 사용된다. 즉, 도 14에 도시된 대로, 단계 1203은 다음 단계들로 대체될 수 있다. 단계 1203a. k개의 완전 에러 신드롬 비트를 획득하기 위해, k개의 디코더에 실제 에러 신드롬 정보를 각각 입 력한다. 단계 1203b. 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보를 획득하기 위해, k개의 완전 에러 신드 롬 비트를 병합한다. 각 제2 디코더는 하나의 신드롬 측정 위치의 완전 에러 신드롬 비트를 출력하도록 구성되고, k개의 제2 디코더 의 출력 결과는 모든 신드롬 측정 위치의 완전 에러 신드롬 비트, 즉, 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보를 획득하기 위해 병합될 수 있다. 도 15에 도시된 대로, 실제 에러 신드롬 정보에 대응하는 3차원 데이터 어레이가 제1 디코더 및 제2 디코더에 각각 입력되고, 제1 디코더는 실제 에러 신드롬 정보에 대응하는 논리 에러 클래스를 출력하고, 제2 디코더는 완전 에러 신드롬 비트를 출력하고, 제2 디코더에 의해 출력되는 완전 에러 신드롬 비트는, 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보를 획득하기 위해 병합되며, 마 지막으로 양자 회로의 에러 결과 정보는 논리 에러 클래스 및 완전 에러 신드롬 정보에 따라 결 정된다. 게다가, 제2 디코더는 완전 연결 네트워크, 또는 CNN, 또는 RNN, 또는 다른 신경망을 기반으로 구성된 분류 모 델일 수 있다. 이것은 본 출원의 본 실시예에서 한정되지 않는다. 전술한 디코더(제1 디코더 및 제2 디코더를 포함함)의 모델 구조는 동일하거나 또는 서로 다를 수 있지만, 모델 깊이는 최대 병렬화를 달성하기 위해 가능 한 한 일관성이 있어야 한다. 게다가, 제2 디코더가 대응하는 완전 에러 신드롬 정보를 획득하기 위해 실제 에러 신드롬 정보를 복호화할 때, 앞선 실시예에서 설명된 블록 특징 추출 방식 - 블록 특징 추출이, 특징 정보를 획득하기 위해, 제2 디코더를 사용하여 실제 에러 신드롬 정보에 대해 수행되고; 융합 복호화 처리가, 완전 에러 신드롬 비트를 획득하기 위 해, 제2 디코더를 사용하여 특징 정보에 대해 수행됨 - 이 사용될 수 있다. 단계 1204. 논리 에러 클래스 및 완전 에러 신드롬 정보에 따라, 에러가 발생하는 양자 회로 내의 데이터 큐비 트와 대응하는 에러 유형을 결정한다. 위에서 설명된 수학식 1을 참조하여, 논리 에러 클래스 및 완전 에러 신드롬 정보가 획득된 후, 대응하는 단순 에러가 완전 에러 신드롬 정보에 따라 결정될 수 있고, 단순 에러는, 정정될 필요가 있는 에러를 획득하기 위해, 논리 에러 클래스 내의 임의의 요소에 곱해질 수 있다, 즉, 에러가 발생하는 양자 회로 내의 데이터 큐비 트 및 대응하는 에러 유형이 획득될 수 있다. 예를 들어, 에러가 발생하는 양자 회로 내의 데이터 큐비트의 위 치와 에러가 그 위치에서 발생하는 데이터 큐비트의 에러 유형이 결정된다. 예를 들어, 에러 유형은 X 에러, 또 는 Z 에러, 또는 Y 에러이다. 예시적인 실시예에서, 도 14에 도시된 대로, 단계 1204는 다음 단계들로 대체될 수 있다. 단계 1204a. 논리 에러 클래스에 대응하는 제1 에러 결과를 획득한다. 예시적인 실시예에서, 도 16에 도시된 대로, 단계 1204a는 다음 단계 - 단계 1204a-1 - 로 대체될 수 있다. 논 리 에러 클래스 내에 포함된 요소로부터 임의의 요소를 제1 에러 결과로서 선택하고, 논리 에러 클래스는 적어 도 하나의 등가 에러 요소를 포함한다. 예를 들어, 복호화를 통해 획득된 실제 에러 신드롬 정보에 대응하는 논리 에러 클래스가 X이면, 임의의 하나의 요소가 논리 에러 클래스 X 내에 포함된 에러 요소로부터 제1 에러 결과로서 선택된다. 단계 1204b. 완전 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득한다. 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보가 복호화를 통해 획득된 후, 완전 에러 신드롬 정보 에 대응하는 제2 에러 결과가 단순 디코더를 사용하여 획득될 수 있다. 예시적인 실시예에서, 도 16에 도시된 대로, 단계 1204b는 다음 단계 - 단계 1204b-1. 완전 에러 신드롬 정보 내의 에러 신드롬 포인트에 각각 대응하는 단순 에러를 획득하기 위해 매핑 테이블을 룩업하고, 매핑 테이블은단순 에러 및 에러 신드롬 포인트의 적어도 하나의 그룹 사이의 매핑 관계를 포함하고; 단계 1204b-2. 제2 에러 결과를 획득하기 위해, 에러 신드롬 포인트에 각각 대응하는 단순 에러를 곱한다 - 로 대체될 수 있다. 단계 1204c. 제1 에러 결과와 제2 에러 결과에 따라, 에러가 발생하는 양자 회로 내의 데이터 큐비트와 대응하 는 에러 유형을 결정한다. 예시적인 실시예에서, 도 16에 도시된 대로, 단계 1204c는 다음 단계 - 단계 1204c-1 - 로 대체될 수 있다. 에 러가 발생하는 양자 회로 내의 데이터 큐비트와 대응하는 에러 유형을 획득하기 위해, 제1 에러 결과와 제2 에 러 결과의 곱을 계산한다. 논리 에러 클래스는 데이터 큐비트에서 발생하는 등가 에러를 획득하기 위해 위와 같은 방식으로 역으로 추론되 며, 추론된 에러는 원래 발생한 에러와 반드시 동일하지는 않지만, 원래 발생한 에러와 동일한 효과를 갖고(또 는 에러 간의 차이가 국소화됨), 이는 QEC 코드 특유의 에러 디제너러시 현상이다. 게다가, 단계 1204a 및 단계 1204b는 연속으로 수행될 수도 있고, 또는 병렬로 수행될 수도 있다. 단계 1204a 및 단계 1204b가 병렬로 수행될 때, 이는 프로세스를 수행하는 데 소요되는 시간을 줄이는 데 도움이 된다. 실 시간 결함 감내 에러 정정 복호화를 구현하기 위해, 더 많은 기기(예를 들어, FPGA/ASIC)와 적절한 통신 연결이 병렬 실행을 완료하기 위해 가능한 한 많이 선택된다. 일부 실시예에서, 에러가 발생하는 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형이 결정된 후, 다음 단 계(도 16에 미도시)가 더 수행될 수 있다. 단계 1205. 에러 결과 정보에 따라 에러-정정 제어 신호를 생성하고, 에러-정정 제어 신호는 양자 회로에 의해 생성된 에러를 정정하는 데 사용된다. 단계 1206. 에러-정정 제어 신호를 양자 회로로 전송한다. 일부 실시예에서, 에러-정정 제어 신호는 마이크로파 제어 신호일 수 있거나, 또는 전자 제어 신호일 수 있거나, 또는 다른 형태의 제어 신호일 수 있다. 이것은 본 출원의 본 실시예에서 한정되지 않는다. 에러-정정 제어 신호는 양자 회로로 전달되어서, 양자 회로는, 에러-정정 제어 신호를 기반으로, 실시간 에러 정정을 구현 하기 위해, 데이터 큐비트 상에서 발생하는 에러를 정정한다. 전술한 내용을 기반으로, 본 출원의 실시예에서 제공되는 기술적 해결 방안에 따르면, 양자 회로의 실제 에러 신드롬 정보가, 대응하는 논리 에러 클래스 및 완전 에러 신드롬 정보를 획득하기 위해, 복호화되고, 이후 에러 가 발생하는 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형이 논리 에러 클래스 및 완전 에러 신드롬 정 보에 따라 결정되어서, 양자 회로의 에러 신드롬 정보가 완벽하지 않은 경우에 결함 감내 에러 정정 복호화가 신경망 알고리즘을 사용하여 에러 신드롬 정보에 대해 수행된다. 더나아가, 해결 방안에 따르면, 결함 감내 에 러 정정 복호화는 분류 문제와 동등하여서, 고효율 신경망 분류기를 사용하여 에러 신드롬 정보에 대해 결함 감 내 에러 정정 복호화를 수행하는 것이 적합하므로, 결함 감내 에러 정정 복호화의 속도가 향상될 수 있다. 적절 한 신경망 분류기가 선택되면, 복호화 알고리즘의 속도가 크게 가속될 수 있고, 실시간 결함 감내 에러 정정 복 호화를 구현할 수 있는 길이 열린다. 아래에서는 신경망 디코더를 트레이닝시키는 과정을 설명한다. 신경망 디코더의 레이블링된 트레이닝 데이터는 시뮬레이션 방식으로 생성될 수 있고, 그 후 신경망 디코더는 지도 학습 방식으로 레이블링된 트레이닝 데이터를 사용하여 트레이닝된다. 첫째, 완전 에러 신드롬을 획득하는 경우가 여전히 고려될 수 있다. 가능한 구현은 샘플 양자 회로 내에 포함된 물리 큐비트 상에 에러를 확률적으로 생성하고, 이후 샘플 양자 회로의 에러 신드롬 정보 및 에러 결과 정보를 획득하고, 트레이닝 데이터를 생성하는 것이다. 예를 들어, X 또는 Y 또는 Z 에러가 확률 P를 사용하여 샘플 양 자 회로의 각 물리 큐비트 상에 생성된다. 구체적으로, 표준 난수 생성 방법이 [0, 1] 내에 균일하게 분포된 난 수를 샘플링하기 위해 채택될 수 있다. 난수가 [0, p/3] 내에 속하면, X 에러로 설정되고, 난수가 [p/3, 2p/3] 내에 속하면, Y 에러로 설정되며, 난수가 [2p/3, p] 내에 속하면, X 에러로 설정되고, 난수가 [p, 1] 내에 속하 면 I로 설정된다(즉, 에러 없음). 그러므로, 길이가 L인 표면 코드에 대해, 두 가지 유형의 패리티 검사의 결과 를 결합하여 획득된 2차원 (L+1)*(L+1) 어레이가 획득되고, 이후 단순 에러가 시뮬레이션된 에러로부터 제거되 고, 어레이가 속한 에러 클래스(상동 관계 클래스)는 데이터 샘플의 레이블로서 추출된다. 하지만, 이러한 노이즈 모델은 너무 이상적이다. 또 다른 가능한 구현은, 실제 노이즈 모델을 추출하기 위해, 실험적으로 큐비트에 대해 양자 프로세스 토모그래피(quantum process tomography, QPT)를 수행하는 것이다. QPT 자원의 과도하게 높은 소비로 인해, QPT는 기하학적으로 이웃하는 최대 두 개의 큐비트에서만 작동한다. 그 러므로, 세 개 이상의 큐비트 사이의 노이즈 상관 관계가 무시되는 것과 동등하다. 이 상관관계가 강하면, 이 상관관계는 QEC에 치명적인 영향을 미치므로 먼저 실험적으로 제거돼야 한다. QPT가 완료된 후, 실제 물리적 노 이즈가 양자 상태에 대해 미치는 영향이 QPT에 따른 Monte Carlo 방법을 사용하여 직접 시뮬레이션되고, 이후 이상적인 패리티 검사가 수행되고 신드롬 및 에러 상동 관계 클래스가 레이블링된 데이터를 획득하기 위해 추출 된다. 이것의 단점은, 이것이 전체 양자 시뮬레이션을 요구하고, 계산 복잡성이 기존의 가장 강력한 컴퓨터의 능력을 초과하기 때문에, 긴 길이의 표면 코드(예를 들어, L>10인 표면 코드)를 시뮬레이션하는 것이 불가능하 다는 것이다. 신경망 디코더의 트레이닝은 표준 신경망 트레이닝 방식을 따른다. 일부 실시예에서, 교차 엔트로피(cross entropy)가 타깃 함수로서 사용되고 타깃 함수는 확률적 경사하강(stochastic gradient descent) 알고리즘을 사용하여 트레이닝된다. 일반적으로, 더 나은 성능이 적응적 모멘트 추정(Adaptive Moment Estimation, ADAM) 알고리즘을 사용하여 획득될 수 있다. 트레이닝 샘플의 범위는 100만에서 3000만 사이이고, 학습률은 1e-5와 1e-2 사이이며, 학습 모멘텀은 1e-4와 1e-6 사이이다. 하이퍼파라미터가 설정되면, 만족스러운 트레이닝 결과가 파이토치 1.2 하에서 획득될 수 있음을 실험을 통해 알 수 있다. 획득된 에러 신드롬 정보 내에 노이즈 간섭이 있는 경우, 완전 신드롬의 경우와 유사하게, 트레이닝 데이터 세 트도 시뮬레이션 방식으로 생성된다. 한편, 상대적으로 간단한 방식 또는 상대적으로 실용적인 방식이 채용될 수 있다. 상대적으로 간단한 방식이 사용되면, 신경망 디코더의 트레이닝 데이터의 생성 과정은 다음과 같다. 1. 샘플 양자 회로 내에 포함된 물리 큐비트 상에 에러를 확률적으로 생성한다. 예를 들어, 각 데이터 큐비트에 대해, X, 또는 Y, 또는 Z 에러(메모리 노이즈)가 패리티 검사가 수행되기 전에 각 큐비트에 대해 확률 p로 생성 된다. 2. 샘플 양자 회로에 대응하는 보조 큐비트에서 에러를 확률적으로 생성하고, 보조 큐비트는 샘플 양자 회로의 에러 신드롬 정보를 획득하기 위한 측정을 수행하는 데 사용된다. 예를 들어, (또는 )에서 준비된 보조 큐비트에 대해, X 또는 Z 에러(상태 준비 노이즈(state preparation noise))가 확률 p로 생성된다. 3. 샘플 양자 회로에 대응하는 고유치 측정 회로 내에 포함된 CNOT 게이트 상에 에러를 확률적으로 생성하고, 고유치 측정 회로는 스태빌라이저 생성기의 고유치를 측정하도록 구성된다. 예를 들어, 고유치 측정 회로 내의 각 CNOT 게이트에 대해, 15개의 이중 파울리 연산자(dual-Pauli operator)(IX, IY, IZ, YI, ZI, XX, XY, XZ, YX, YY, YZ, ZX, ZY, 및 ZZ를 포함함)가 확률 p로 생성된다. 4. 에러 신드롬 측정이 QEC 코드를 사용하여 샘플 양자 회로에 대해 수행되는 경우 측정 에러를 확률적으로 발 생시킨다. 예를 들어, X(Z) 에러(측정 노이즈)가 Z(X) 측정 전에 확률 p로 발생하고, Z(X), 는 X 에러만 Z 측정 에 영향을 미친다는 것을 나타내고, X(Z)는 Z 에러만 X 측정에 영향을 미친다는 것을 나타낸다. 5. 샘플 양자 회로의 에러 신드롬 정보 및 에러 결과 정보를 획득하고, 트레이닝 데이터를 생성한다. 위에서 설명된 방식으로, T 라운드의 패리티 검사 측정이 반복되고, 길이가 L인 표면 코드에 대해, 두 가지 유 형의 패리티 검사 결과가 0과 1로 구성되는 2차원 T*(L+1)*(L+1) 어레이로 결합되며, 이후 시뮬레이션 결과가 에러를 획득하기 위해 처리될 수 있고, 트레이닝에 요구되는 상동 관계 클래스의 레이블과 완전 에러 신드롬의 레이블이 2차원 신드롬 어레이로부터 추출된다. 상대적으로 실용적인 방식이 사용되면, 신경망 디코더의 트레이닝 데이터의 생성 과정은 다음과 같다. 1. 샘플 양자 회로에 대해 QPT를 수행하고, 샘플 양자 회로의 노이즈 모델을 추출한다. 2. 노이즈 모델을 기반으로 한 노이즈의 작용 하에서 샘플 양자 회로의 양자 상태의 진화를 시뮬레이션한다. 3. 샘플 양자 회로의 에러 신드롬 정보 및 에러 결과 정보를 획득하고, 트레이닝 데이터를 생성한다. 상대적으로 실용적인 방식이 사용될 때, QPT가, 메모리 노이즈, 상태 준비 노이즈, 양자 게이트 노이즈, 및 측 정 노이즈의 정확한 수학적 설명을 추출하기 위해 큐비트에 대해 먼저 실험적으로 수행되고, 이후 노이즈의 작 용 하에서의 양자 상태의 진화가 직접 시뮬레이션된 후 신드롬 및 레이블이 생성된다.신경망 디코더의 트레이닝 데이터 세트의 생성 과정과 신경망 디코더의 트레이닝 방식은 위에서 설명되고, 첫 번째 트레이닝 데이터 생성 방식에 있어, 에러 시뮬레이션이, 트레이닝 데이터를 생성하기 위해 이상적인 노이 즈 모델을 사용하여 수행되고, 이는 비교적 간단하며, 두 번째 트레이닝 데이터 생성 방식에 있어, 실제 노이즈 모델이 QPT를 통해 추출되고, 이후 실제 물리적 노이즈가 샘플 양자 회로에 미치는 영향이, 트레이닝 데이터를 생성하기 위해, 실제 노이즈 모델을 사용하여 시뮬레이션되며, 이는 더 실용적이다. 완전 에러 신드롬을 기반으로, 수치 시뮬레이션(numerical simulation)이 길이가 L인 표면 코드에 대해 수행된 다. 수치 시뮬레이션 방법은 다음과 같다. X, Y, 및 Z 에러가 p의 확률에 따라 각 큐비트에서 무작위로 발생하 며, (1-p)에 따라서는 에러가 발생하지 않고, 여기서 p는 물리적 에러율이다. 이어서, 트레이닝 세트가 신경망 디코더를 트레이닝하기 위해 p=0.11 또는 p=0.12에 따라 생성된다. 디코더가 트레이닝된 후, 많은 수량의 노이 즈 샘플이 동일한 노이즈 모델을 사용하여 서로 다른 p에 대해 생성되고, 이후 노이즈 샘플이 신경망 디코더에 입력되고 에러 클래스(상동 관계 클래스) 결과가 출력된다. 에러 클래스 결과는 실제 노이즈의 에러 클래스와 비교되고, 복호화가 정확한지 판단되고, 이후 복호화 에러의 빈도(확률)가 논리 비트 에러율로 기록된다. 한편, 시뮬레이션이 디코더의 성능을 비교하기 위해 MWPM을 사용하여 수행된다. 구체적인 시뮬레이션 결과는 도 17에 도시되어 있다. 여기서, 분명히 알 수 있는 것은, 작은 길이의 표면 코드(L=5, L=7, L=11)의 경우, 본 출원에서 제공되는 신경 망 디코더가 간단하지만, 각 구간의 에러율에서 MWPM보다 낫다는 것이다. L=15의 경우, 신경망 디코더의 복호화 성능은 MWPM보다 약간 열등한데, 왜냐하면 L=11일 때와 동일한 네트워크 모델과 샘플의 수량만이 사용되기 때문 이다(로드 후 테스트 중에 사용된 32GB의 독립 실행형 메모리의 상한선 까지). 분명히, L=15인 경우, 네트워크 는 약 3천만 개 이상의 샘플을 사용하여 트레이닝된다. 게다가, 단순 신경망 디코더의 임계치도 15%에 도달하고 MWPM의 임계치를 초과하며, 이는 이론적으로 한계에 근접한 것이다. 서로 다른 길이를 갖는 표면 코드에 대응하는 신경망 파라미터는 표 1에 나열되어 있다. 표 1 L 파라미터 공간트레이닝 세트의 크기트레이닝 파일의 크기 (압축 되지 않음)모델 파라미터네트워크 깊이실행 시간 5236 1백만 ~50 MB ~1.1백만 4 ~100 ns 7264 2백만 ~250 MB ~1.1백만 4 ~100 ns 112144 20백만 ~3.2 GB ~4.76백만 5 ~200 ns 152256 20백만 ~7 GB ~5백만 5 ~200 ns 표 1: 서로 다른 길이를 갖는 표면 코드에 대응하는 신경망 파라미터 네트워크 깊이는 L로 천천히 변화하며, 실제 실행 시간은 빠르게 증가하지 않음을 알 수 있다. 네트워크 파라미 터와 요구되는 트레이닝 데이터 세트는 L에 따라 기하급수적으로 증가하지 않는다. 반대로, 네트워크 파라미터 와 요구되는 트레이닝 데이터 세트는 다항식으로 증가하고 증가 속도는 그리 빠르지 않다. 이것은 알고리즘이 원칙적으로 확장 가능함을 의미한다. 하지만, 많은 시간이 긴 표면 코드의 트레이닝 세트를 생성하는 데 여전히 필요하고(이 프로세스는 병렬화 가능), 많은 내부 메모리 및 GPU 계산 자원이 모델을 트레이닝하는 데 여전히 소모되어서(특히 L≥15인 경우, 128GB보다 큰 내부 메모리와 nVidia V100 GPU의 블록 두 개가 요구됨), 트레이 닝은 예상되는 복호화 성능 지표에 도달하기 위해 허용 가능한 시간 이내에 완료될 수 있다. 하지만, 한편, 이 러한 하드웨어 자원은 기존 조건 하에서 비싸지 않으며, 다른 한편으로는, 알고리즘의 유효성이 실험 시스템에 서 일단 실제로 검증되면, 트레이닝 프로세스가 하나의 프로세스이기 때문에 이러한 추가 자원에 대한 투자가 가치 있다. 표 1의 실효 실행 시간은, 수천 번의 복호화가 1개의 GPU(여기서 nVidia GTX 2070에 기반한 것)에 동시에 입력 된 후 총 연산 시간/총 복호화 횟수로 도달될 수 있는 최대값(약 5000)이다. 이 시간은 필수적 기준 요구 사항 일 뿐이고(이 값이 지나치게 높으면, 알고리즘은 매우 낮은 지연을 필연적으로 얻을 수 없음) GPU의 실시간 복 호화의 계산 시간과 동등하지 않다.모델 설계 중에, 가 선택되지만, 필수는 아니다. 대안으로, 또 다른 다항식 점진적 증가 방식이 네 트워크 깊이에 많은 영향을 미치지 않으면서 선택될 수 있다. 본 출원에서 제공되는 기술적 해결 방안은 표면 코드에 적용될 수 있을 뿐만 아니라, 색상 코드와 같은 또 다른 기본 토폴로지 코드의 결함 감내 QEC 해결 방안 에도 적용될 수 있다. 배치 정규화(batch-normalization)와 같은 계층은 여기 계층(excitation layer)보다 먼 저 도입될 수 있고, 서로 다른 대상 기능이 사용될 수 있고, Adam과 같은 서로 다른 학습 전략이 사용될 수 있 다. 앞선 실시예에서 제공된 해결 방안에 따르면, 결함 감내 에러 정정을 위한 컨볼루션 레이어는 공간 내에서 만 재형성(reform)되고, 에러 정정의 효과는 세 방향으로 재형성함으로써 비교될 수 있다. 해결 방안은 주로 시 뮬레이션을 통해 생성된 레이블링된 트레이닝 데이터를 사용한다. 실제 실험에서, 실험 데이터를 직접 측정하여 에러에 대응하는 상동 관계 클래스를 획득하는 것도 가능하다. 아래는 본 출원의 방법 실시예를 실행하도록 구성될 수 있는 본 출원의 장치 실시예이다. 본 출원의 장치 실시 예에 개시되지 않은 세부사항은, 본 출원의 방법 실시예가 참조된다. 도 18은 본 출원의 일 실시예에 따른 신경망 기반 양자 에러 정정 복호화 장치의 블록도이다. 상기 장치는 앞서 설명한 방법 실시예를 구현하는 기능을 갖는다. 기능은 하드웨어로 구현될 수도 있고, 또는 대응하는 소프트웨 어를 실행하는 하드웨어로 구현될 수도 있다. 상기 장치는 컴퓨터 기기일 수 있거나 또는 컴퓨터 기기 내에 배 치될 수 있다. 장치는 신드롬 정보 획득 모듈, 블록 특징 추출 모듈, 및 융합 복호화 처리 모듈을 포함할 수 있다. 신드롬 정보 획득 모듈은 양자 회로의 에러 신드롬 정보를 획득하도록 구성되며, 에러 신드롬 정보는 QEC 코드의 스태빌라이저 생성기의 고유치에 의해 형성된 데이터 어레이이다. 블록 특징 추출 모듈은, 특징 정보를 획득하기 위해, 신경망 디코더를 사용하여 에러 신드롬 정보에 대한 블록 특징 추출을 수행하도록 구성되며, 신경망 디코더의 특징 추출 레이어는 입력된 데이터에 대해 블록 특징 추출을 수행하도록 구성되며, 블록 특징 추출은, 입력된 데이터가 적어도 두 개의 블록으로 분할된 후, 적어도 두 개의 특징 추출부를 사용하여 적어도 두 개의 블록에 대해 병렬 특징 추출을 수행하도록 구성된다. 융합 복호화 처리 모듈은, 에러 결과 정보를 획득하기 위해, 신경망 디코더를 사용하여 특징 정보에 대해 융합 복호화 처리를 수행하도록 구성되며, 에러 결과 정보는 에러가 발생하는 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하는 데 사용된다. 예시적인 실시예에서, 신경망 디코더는 m개의 캐스케이드된 특징 추출 레이어를 포함하고, m은 양의 정수이다. 블록 특징 추출 모듈은, 특징 정보를 획득하기 위해, m개의 특징 추출 레이어를 사용하여 에러 신드롬 정 보에 대해 블록 특징 추출을 수행하도록 구성된다. 제1 특징 추출 레이어는 에러 신드롬 정보에 대해 블록 특징 추출을 수행하도록 구성되고, i번째 특징 추출 레 이어는 이전 특징 추출 레이어의 특징 추출 결과에 대해 블록 특징 추출을 수행하도록 구성되며, i는 1보다 크 고, m보다 작거나 같은 정수이다. 예시적인 실시예에서, 특징 추출 레이어가 블록 특징 추출을 수행할 때, 임의의 두 블록 사이에는 교차 부분이 없다. 예시적인 실시예에서, 에러 신드롬 정보는 T개의 데이터 어레이를 포함하고, 각 데이터 어레이는 QEC 코드를 사 용하여 양자 회로에 대해 하나의 에러 신드롬 측정을 수행함으로써 획득되며, T는 1보다 큰 정수이다. 도 19에 도시된 대로, 장치는, 에러 신드롬 정보를 적어도 두 개의 데이터 단위으로 분류하도록 구성된 신드롬 정 보 분류 모듈을 더 포함한다. 하나의 데이터 단위는 T 데이터 어레이 내의 동일한 위치에 있는 T개의 어 레이 단위를 포함한다. 예시적인 실시예에서, 에러 신드롬 정보는 QEC 코드를 사용하여 양자 회로 상의 노이즈를 가진 에러 신드롬 측 정을 수행하여 획득된 실제 에러 신드롬 정보이고, 신경망 디코더는 제1 디코더 및 제2 디코더를 포함한다. 제1 디코더는, 실제 에러 신드롬 정보에 대응하는 논리 에러 클래스를 획득하기 위해, 실제 에러 신드롬 정보를 복호화하도록 구성되며, 논리 에러 클래스는 에러가 양자 회로 내에서 발생한 후 획득된 클래스이다. 제2 디코더는, 실제 에러 신드롬 정보에 대응하는 완전 에러 신드롬 정보를 획득하기 위해, 실제 에러 신드롬 정보를 복호화하도록 구성되고, 완전 에러 신드롬 정보는 양자 회로에 대해 노이즈 없이 에러 신드롬 측정을 수행하여 얻은 정보이다. 도 19에 도시된 대로, 장치는, 논리 에러 클래스 및 완전 에러 신드롬 정보에 따라, 에러가 발생하는 양 자 회로 내의 데이터 큐비트 및 대응하는 에러 유형을 결정하도록 구성된 에러 결정 모듈을 더 포함한다. 예시적인 실시예에서, 도 19에 도시된 대로, 에러 결정 모듈은, 논리 에러 클래스에 대응하는 제1 에러 결과를 획득하도록 구성된 제1 획득부; 완전 에러 신드롬 정보에 대응하는 제2 에러 결과를 획득하도록 구성된 제2 획득부; 및 제1 에러 결과 및 제2 에러 결과에 따라, 에러가 발생하는 양자 회로 내의 데이터 큐비트 및 대응하는 에러 유 형을 결정하도록 구성된 에러 결정부를 포함한다 예시적인 실시예에서, 제1 획득부는 논리 에러 클래스 내에 포함된 요소들로부터 임의의 요소를 제1 에러 결과로서 선택하도록 구성되며, 논리 에러 클래스는 적어도 하나의 등가 에러 요소를 포함한다. 예시적인 실시예에서, 제2 획득부는 완전 에러 신드롬 정보 내의 에러 신드롬 포인트에 각각 대응하는 단 순 에러를 획득하기 위해 매핑 테이블을 룩업하고 - 매핑 테이블은 단순 에러와 에러 신드롬 포인트의 적어도 하나의 그룹 사이의 매핑 관계를 포함함 -, 제2 에러 결과를 획득하기 위해, 에러 신드롬 포인트에 각각 대응하 는 단순 에러를 곱하도록 구성된다. 예시적인 실시예에서, 에러 결정 유닛은 에러가 발생하는 양자 회로 내의 데이터 큐비트 및 대응하는 에 러 유형을 획득하기 위해, 제1 에러 결과와 제2 에러 결과의 곱을 계산하도록 구성된다. 예시적인 실시예에서, k개의 제2 디코더가 존재하고, k는 양의 정수이고 k는 QEC 코드의 길이와 관련된다. k개 의 제2 디코더는, k개의 완전 에러 신드롬 비트를 획득하기 위해, 실제 에러 신드롬 정보를 각각 복호화하도록 구성되고, k개의 완전 에러 신드롬 비트는 완전 에러 신드롬 정보를 획득하기 위해 병합을 수행하는 데 사용된 다. 예시적인 실시예에서, 뉴럴 네트워크 디코더의 트레이닝 데이터의 생성 과정은 다음과 같다. 샘플 양자 회로 내에 포함된 물리 큐비트 상에 에러를 확률적으로 생성하는 단계; 샘플 양자 회로에 대응하는 보조 큐비트 상에 에러를 확률적으로 생성시키는 단계 - 보조 큐비트는 샘플 양자 회로의 에러 신드롬 정보를 획득하기 위해 측정을 수행하는 데 사용됨 -; 샘플 양자 회로에 대응하는 고유치 측정 회로 내에 포함된 제어된 NOT 게이트 상에 에러를 확률적으로 생성시키 는 단계 - 고유치 측정 회로는 스태빌라이저 생성기의 고유치를 측정하도록 구성됨 -; 에러 신드롬 측정이 QEC 코드를 사용하여 샘플 양자 회로에 대해 수행되는 경우 측정 에러를 확률적으로 발생시 키는 단계; 그리고 샘플 양자 회로의 에러 신드롬 정보 및 에러 결과 정보를 획득하고, 트레이닝 데이터를 생성하는 단계를 포함한 다. 예시적인 실시예에서, 뉴럴 네트워크 디코더의 트레이닝 데이터 생성 과정은 다음과 같다. 샘플 양자 회로에 대해 QPT를 수행하고, 샘플 양자 회로의 노이즈 모델을 추출하는 단계; 노이즈 모델을 기반으로 노이즈의 작용 하에 샘플 양자 회로의 양자 상태의 진화를 시뮬레이션하는 단계; 그리 고 샘플 양자 회로의 에러 신드롬 정보 및 에러 결과 정보를 획득하고, 트레이닝 데이터를 생성하는 단계를 포함한 다. 예시적인 실시예에서, 도 19에 도시된 대로, 상기 장치는 에러 정정 신호 생성 모듈 및 에러 정정 신호 전송 모듈을 더 포함한다. 에러 정정 신호 생성 모듈은 에러 결과 정보에 따라 에러-정정 제어 신호를 생성하도록 구성되며, 에러- 정정 제어 신호는 양자 회로에 의해 생성된 에러를 정정하는 데 사용된다. 에러 정정 신호 전송 모듈은 에러-정정 제어 신호를 양자 회로에게 전송하도록 구성된다. 전술한 내용을 기반으로, 본 출원의 실시예들에서 제공되는 기술적 해결 방안에 따르면, 블록 특징 추출이, 복 수 그룹의 특징 정보를 획득하기 위해, 양자 회로의 에러 신드롬 정보에 대해 수행되고, 이후, 융합 복호화 처 리가, 에러 결과 정보를 획득하기 위해, 특징 정보의 복수의 그룹에 대해 추가로 수행된다. 블록 특징 추출 방 식이 사용되기 때문에, 입력 데이터에 대한 완전 특징 추출에 비해, 한편으로, 각 특징 추출에 의해 획득되는 특징 정보의 채널의 수량이 줄어들고, 다음 특징 추출의 입력 데이터가 줄어들어, 이는 신경망 디코더 내의 특 징 추출 레이어의 수량을 감소시키는 데 도움이 되며, 신경망의 디코더의 깊이가 짧아질 수 있다. 신경망 디코 더의 깊이가 짧아지기 때문에, 신경망 디코더에 의해 사용되는 복호화 시간이 그에 따라 감소한다. 한편, 블록 특징 추출이 수행될 때, 병렬 특징 추출 처리가 복수의 특징 추출부를 사용하여 복수의 블록에 대해 수행되고, 즉, 복수의 특징 추출부가 특징 추출 처리를 동기적으로(또는 동시에라고 함) 수행하여서, 이는 특징 추출에 의 해 소요되는 시간을 줄이고, 그에 따라 복호화 시간을 감소시킨다. 마지막으로, 두 가지 요소를 참조하여, QEC 복호화가 신경망 디코더를 사용하여 수행될 때, 복호화 시간이 완전히 단축되어, 이에 따른 실시간 에러 정정의 요구 사항이 충족될 수 있다. 앞선 실시예에 의해 제공되는 장치가 장치의 기능을 구현할 때, 앞서 설명한 기능 모듈의 분할은 설명을 위한 예시일 뿐이다. 실제 응용에서, 기능은 요구 사항에 따라 서로 다른 기능 모듈에 할당되고 완료될 수 있다, 즉, 위에서 설명한 기능의 전부 또는 일부를 구현하기 위해, 장치의 내부 구조가 서로 다른 기능 모듈로 분할된다. 게다가, 앞선 실시예에 의해 제공된 장치 및 방법 실시예는 동일한 개념에 속한다. 특정 구현 프로세스에 대해, 방법 실시예가 참조될 수 있으며 세부 사항은 여기에서 다시 설명되지 않는다. 도 20은 본 출원의 일 실시예에 따른 컴퓨터 기기의 개략적인 구조도이다. 예를 들어, 컴퓨터 기기는 도 3에 도 시된 해결 방안의 응용 시나리오의 제어 기기일 수 있다. 컴퓨터 기기는 앞선 실시예에서 제공된 신경망 기 반 양자 에러 정정 복호화 방법을 구현하도록 구성될 수 있다. 예를 들어, 컴퓨터 기기는 고전 컴퓨터이다. 세 부 사항은 다음과 같다. 컴퓨터 기기는 처리 유닛(예를 들어, CPU 및/또는 GPU를 포함함), 랜덤 액세스 메모리(RAM) 및 읽기 전용 메모리(ROM)를 포함하는 시스템 메모리, 및 시스템 메모리와 처리 유닛 을 연결하는 시스템 버스를 포함한다. 컴퓨터 기기는 컴퓨터 내의 구성 요소들 사이에서 정보를 전 송하도록 구성된 기본 입/출력 시스템(I/O 시스템) 및 운영 시스템, 응용 프로그램, 및 또 다른 프로그램 모듈을 저장하도록 구성된 대용량 저장 기기를 더 포함한다. 기본 I/O 시스템은 정보를 표시하도록 구성된 디스플레이 및 사용자에 의해 정보를 입력하도록 구 성된 마우스 또는 키보드와 같은 입력 기기를 포함한다. 디스플레이 및 입력 기기는 모두 시 스템 버스에 연결된 입/출력 제어기에 의해 처리 유닛에 연결된다. 기본 I/O 시스템은, 키보드, 또는 마우스, 또는 전자 스타일러스와 같은 다수의 다른 장치로부터 입력을 수신 및 처리하기 위해, 입/출력 제어기를 더 포함할 수 있다. 유사하게, I/O 제어기는 디스플레이 스크린, 또는 프린터, 또는 다른 유형의 출력 장치에 출력을 또한 제공한다. 대용량 저장 기기는 시스템 버스에 연결된 대용량 저장 제어기(미도시)에 의해 처리 유닛에 연결된다. 대용량 저장 기기 및 관련된 컴퓨터가 판독 가능한 매체는 컴퓨터 기기를 위해 비휘발성 스토리지를 제공한다. 즉, 대용량 저장 기기는 하드 디스크 또는 컴팩트 디스크 ROM(compact disc ROM, CD-ROM)과 같은 컴퓨터가 판독 가능한 매체(미도시)를 포함할 수 있다. 일반적으로, 컴퓨터가 판독 가능한 매체는 컴퓨터 저장 매체 및 통신 매체를 포함할 수 있다. 컴퓨터 저장 매체 는 휘발성 및 비휘발성 매체, 그리고 컴퓨터가 읽을 수 있는 명령어, 또는 데이터 구조, 또는 프로그램 모듈, 또는 기타 데이터와 같은 정보를 저장하는 데 사용되는 임의의 방법 또는 기술을 사용하여 구현되는 이동 가능 및 이동 불가능 매체를 포함한다. 컴퓨터 저장 매체는 RAM, 또는 ROM, 또는 EPROM(Erasable Programmable ROM), 또는 EEPROM(Electrically Eraseable Programmable ROM), 또는 플래시 메모리 또는 또 다른 고체 상태 메모리 기술, 또는 CD-ROM, 또는 디지털 다목적 디스크(DVD), 또는 또 다른 광학 메모리, 또는 테이프 카트리지, 또는 자기 카세트, 또는 자기 디스크 메모리, 또는 또 다른 자기 저장 기기를 포함한다. 분명히, 컴 퓨터 저장 매체가 전술한 유형으로 한정되지 않는다는 것은 당업자에게 알려져 있다. 시스템 메모리 및 대용량 저장 기기를 통칭하여 메모리라고 할 수 있다. 본 출원의 다양한 실시예에 따르면, 컴퓨터 기기는 또한, 인터넷과 같은 네트워크를 통해, 구동을 위해 네트워크 상의 원격 컴퓨터에 연결될 수 있다. 즉, 컴퓨터 기기는 시스템 버스에 연결된 네트워크 인터페이스 유닛을 사용하여 네트워크에 연결되거나, 또는 네트워크 인터페이스 유닛을 사용하여 또 다른 종류의 네트워크 또는 원격 컴퓨터 시스템(미도시)에 연결될 수 있다. 메모리는 적어도 하나의 명령어, 적어도 하나의 섹션의 프로그램, 코드 세트 또는 명령어 세트를 저장하고, 적 어도 하나의 명령어, 적어도 하나의 섹션의 프로그램, 코드 세트 또는 명령어 세트는 앞선 실시예에 의해 제공 된 신경망 기반 QEC 복호화 방법을 구현하기 위해 하나 이상의 프로세서에 의해 실행되도록 구성된다. 예시적인 실시예에서, 컴퓨터가 판독 가능한 저장 매체가 더 제공되고, 상기 저장 매체는 적어도 하나의 명령어, 적어도 하나의 프로그램, 코드 세트 또는 명령어 세트를 저장하고, 상기 적어도 하나의 명령어, 상기 적어도 하나의 프로그램, 코드 세트 또는 명령어 세트는 앞선 술한 실시예에 의해 제공된 신경망 기반 QEC 복호 화 방법을 구현하기 위해 컴퓨터 기기의 프로세서에 의해 실행된다. 예시적인 실시예에서, 컴퓨터가 판독 가능 한 저장 매체는 ROM, 또는 RAM, 또는 CD-ROM, 또는 자기 테이프, 또는 플로피 디스크, 또는 광 데이터 저장 기 기 등일 수 있다. 예시적인 실시예에서, 컴퓨터 프로그램 제품이 더 제공되고, 실행될 때, 컴퓨터 프로그램 제품은 앞선 실시예들 에 의해 제공된 신경망 기반 QEC 복호화 방법을 구현하도록 구성된다. 예시적인 실시예에서, 칩이 추가로 제공되고, 프로그래밍 가능한 논리 회로 및/또는 프로그램 명령을 포함하며, 컴퓨터 기기 상에서 구동될 때, 칩은 앞선 실시예에 의해 제공된 신경망 기반 QEC 복호화 방법을 구현하도록 구 성된다. 일부 실시예에서, 칩은 FPGA 칩 또는 ASIC 칩이다. 본 명세서에서 언급된 \"복수\"는 둘 이상을 의미하는 것으로 이해되어야 한다. \"및/또는\"은 관련된 객체에 대한 관련 관계를 설명하고 세 가지 관계가 존재할 수 있음을 나타낸다. 예를 들어, A 및/또는 B는 A만 존재하고, A 와 B가 모두 존재하고, B만 존재하는 세 가지 경우를 나타낼 수 있다. 문자 \"/\"는 일반적으로 관련된 객체 간의 \"또는\" 관계를 나타낸다. 게다가, 본 명세서 내에 기재된 단계 번호는 단지 단계의 가능한 실행 시퀀스를 예시 적으로 나타낸 것이다. 일부 다른 실시예에서, 단계는 번호 시퀀스에 따라 수행되지 않을 수 있다. 예를 들어, 서로 다른 번호를 갖는 두 개의 단계는 동시에 수행될 수 있거나, 또는 서로 다른 번호를 갖는 두 개의 단계는 도면에 도시된 시퀀스와 반대되는 시퀀스에 따라 수행될 수 있다. 이것은 본 출원의 실시예에서 한정되지 않는 다. 앞선 설명은 단지 본 출원의 예시적인 실시예일 뿐, 본 출원을 제한하려 의도되지 않았다. 본 출원의 사상과 원 칙 내에서 이루어진 모든 정정, 또는 동등한 교체, 또는 개선은 본 출원의 보호 범위에 속한다."}
{"patent_id": "10-2021-7031512", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 출원의 실시예들에서의 기술적 해결 방안을 보다 명확하게 설명하기 위해, 이하에서는 실시예를 설명하는 데 필요한 첨부 도면을 간략하게 소개한다. 명백하게, 다음 설명에서 첨부 도면은 본 출원의 일부 실시예만을 도시 하며, 당업자는 창의적인 노력 없이도 첨부 도면으로부터 다른 도면을 여전히 도출할 수 있다. 도 1은 본 출원의 일 실시예에 따른 표면 코드의 개략적인 구조도이다. 도 2는 본 출원의 일 실시예에 따른 에러가 표면 코드 내에서 발생하는 개략도이다. 도 3은 본 출원의 일 실시예에 따른 해결 방안의 응용 시나리오의 개략도이다. 도 4는 도 3에 도시된 해결 방안의 응용 시나리오와 관련된 에러 정정 복호화 프로세스의 개략도이다. 도 5는 본 출원의 일 실시예에 따른 신경망 기반 양자 에러 정정 복호화 방법의 흐름도이다. 도 6은 본 출원의 일 실시예에 따른 블록 특징 추출의 개략도이다. 도 7은 본 출원의 일 실시예에 따른 고유치 측정 회로의 개략도이다. 도 8은 본 출원의 일 실시예에 따른 노이즈를 가진 에러 신드롬의 개략도이다. 도 9는 본 출원의 일 실시예에 따른 3차원 신드롬의 분포의 개략도이다. 도 10은 본 출원의 일 실시예에 따른 노이즈 및 신드롬의 시공간적 특징의 단면도이다. 도 11은 본 출원의 다른 실시예에 따른 블록 특징 추출의 개략도이다. 도 12는 본 출원의 다른 실시예에 따른 신경망 기반 양자 에러 정정 복호화 방법의 흐름도이다. 도 13은 본 출원의 일 실시예에 따른 완전 에러 신드롬 정보의 개략도이다. 도 14는 본 출원의 다른 실시예에 따른 신경망 기반 양자 에러 정정 복호화 방법의 흐름도이다. 도 15는 본 출원의 일 실시예에 따른 결함 감내 에러 정정 복호화 프로세스의 개략도이다. 도 16은 본 출원의 다른 실시예에 따른 신경망 기반 양자 에러 정정 복호화 방법의 흐름도이다. 도 17은 본 출원의 일 실시예에 따른 시뮬레이션 결과의 비교의 개략도이다. 도 18은 본 출원의 일 실시예에 따른 신경망 기반 양자 에러 정정 복호화 장치의 블록도이다. 도 19는 본 출원의 다른 실시예에 따른 신경망 기반 양자 에러 정정 복호화 장치의 블록도이다. 도 20은 본 출원의 일 실시예에 따른 컴퓨터 기기의 개략적인 구조도이다."}
