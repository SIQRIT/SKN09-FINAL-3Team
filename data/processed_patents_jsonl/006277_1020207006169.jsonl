{"patent_id": "10-2020-7006169", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2020-0047551", "출원번호": "10-2020-7006169", "발명의 명칭": "메모리 기반 분산 프로세서 아키텍처", "출원인": "뉴로블레이드, 리미티드.", "발명자": "시티, 엘라드"}}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이; 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이; 상기 복수의 프로세서 서브유닛의 하나를 이에 상응하는 전용 메모리 뱅크에 각각 연결하는 제1 복수의 버스;및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 프로세서 서브유닛의 다른 하나에 각각 연결하는 제2 복수의 버스를 포함하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 기판은 반도체 기판인 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 기판은 회로기판인 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서, 상기 프로세싱 어레이의 상기 복수의 프로세서 서브유닛은 상기 메모리 어레이의 상기 복수의 이산 메모리 뱅크사이에 공간적으로 분산된 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서, 칩 상의 상기 분산 프로세서는 인공지능 가속기 프로세서인 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 특정 어플리케이션과 연관된 소프트웨어 코드를 상기복수의 프로세서 서브유닛에 포함된 다른 프로세서 서브유닛에 대해 개별적으로 실행하도록 구성된 것을 특징으로 하는, 분산 프로세서. 공개특허 10-2020-0047551-3-청구항 7 제1항에 있어서, 상기 복수의 논리 프로세서 서브유닛은 적어도 하나의 행과 적어도 하나의 열로 배치되고, 상기 제2 복수의 버스는 각 프로세서 서브유닛을 상기 행과 동일한 행의 적어도 하나의 인접 프로세서 서브유닛과 상기 열의 동일한 열의 적어도 하나의 인접 프로세서 서브유닛으로 연결하는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 상기 복수의 프로세서 서브유닛은 별 무늬로 배치되고, 상기 제2 복수의 버스는 각 프로세서 서브유닛을 상기별 무늬 이내의 적어도 하나의 인접 프로세서 서브유닛으로 연결하는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서, 각 프로세서 서브유닛은 적어도 두 개의 전용 메모리 뱅크와 연관되는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1항에 있어서, 각 전용 메모리 뱅크는 적어도 하나의 DRAM(dynamic random access memory)을 포함하는 것을 특징으로 하는,분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이; 상기 기판에 배치되고 복수의 논리부를 포함하는 프로세싱 어레이―여기서, 상기 복수의 논리부 각각은 어드레스 생성기를 포함하고, 상기 어드레스 생성기는 각각 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산메모리 뱅크와 연관됨; 및 상기 복수의 어드레스 생성기의 하나를 이에 상응하는 전용 메모리 뱅크에 각각 연결하는 복수의 버스를 포함하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서, 각 어드레스 생성기는 상기 어드레스 생성기에 상응하는 메모리 뱅크에서의 처리를 위해 접속되어야 할 주소를판단하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제11항에 있어서, 상기 프로세싱 어레이는 상응하는 어드레스 생성기와 각각 연관되고 각각 특정 함수를 수행하도록 구성된 복수의 가속기를 더 포함하는 것을 특징으로 하는, 메모리 칩. 공개특허 10-2020-0047551-4-청구항 14 제13항에 있어서, 상기 특정 함수는 multiply-accumulate 함수, minimum 함수, maximum 함수, compare 함수, 또는 count 함수를포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제11항에 있어서, 상기 메모리 칩은 DRAM, 플래시메모리, SRAM, ReRAM, PRAM, MRAM, 및 ROM 메모리 칩의 적어도 하나인 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제11항에 있어서, 각 프로세서 서브유닛은 RISC(reduced instruction set computer) 프로세서 또는 CISC(complex instructionset computer) 프로세서를 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제11항에 있어서, 외부 호스트에 연결된 메모리 인터페이스를 더 포함하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서, 상기 메모리 인터페이스는 JEDEC(Joint Electron Device Engineering Council) 표준 및 그 개정 표준의 적어도하나를 준수하는 인터페이스를 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제11항에 있어서, 상기 복수의 논리부의 각각은 상기 복수의 이산 메모리 뱅크의 적어도 하나의 메모리 뱅크, 상기 복수의 이산메모리 뱅크의 단일 메모리 뱅크에 포함된 복수의 메모리 매트, 또는 상기 복수의 이산 메모리 뱅크의 단일 메모리 뱅크에 포함된 단일 메모리 매트에 상응하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이―여기서, 상기 이산 메모리 뱅크 각각의 용량은 1메가바이트 이상임; 및 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이를 포함하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "공개특허 10-2020-0047551-5-제20항에 있어서, 상기 복수의 프로세서 서브유닛의 하나를 상응하는 전용 메모리 뱅크에 각각 연결하는 제1 복수의 버스; 및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 프로세서 서브유닛의 다른 하나에 각각 연결하는 제2 복수의 버스를 더 포함하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제20항에 있어서, 각 전용 메모리 뱅크는 적어도 하나의 DRAM 뱅크를 포함하는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제20항에 있어서, 각 전용 메모리 뱅크는 적어도 하나의 SRAM(static random access memory) 뱅크를 포함하는 것을 특징으로하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제20항에 있어서, 각 전용 메모리 뱅크는 사이즈가 동일한 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제20항에 있어서, 상기 복수의 메모리 뱅크의 적어도 두 개의 메모리 뱅크는 사이즈가 서로 다른 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "제20항에 있어서, 상기 복수의 프로세서 서브유닛은 상기 메모리 어레이 이내의 상기 복수의 이산 메모리 뱅크 사이에 공간적으로분산된 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "제20항에 있어서, 상기 기판은 반도체 기판을 포함하는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "기판; 공개특허 10-2020-0047551-6-상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이; 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이; 및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 프로세서 서브유닛의 적어도 다른 하나에 각각 연결하는복수의 버스를 포함하고, 상기 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛 사이의 데이터 전송과 상기 복수의버스 중에서 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않는 것을 특징으로 하는,분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "제28항에 있어서, 상기 복수의 버스는 버스 아비터가 없어서 프로세서 서브유닛 사이의 데이터 전송과 상기 복수의 버스 중에서상응하는 버스를 통한 데이터 전송은 버스 아비터에 의해 제어되지 않는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_30", "content": "제28항에 있어서, 상기 복수의 버스는 상기 복수의 프로세서 서브유닛의 상응하는 프로세서 서브유닛 사이에 회선 및 광섬유의 적어도 하나를 포함하는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "제28항에 있어서, 상기 복수의 프로세서 서브유닛은 상기 복수의 프로세서 서브유닛에 의해 실행되는 코드에 따라 상기 복수의 버스의 적어도 하나를 통해 데이터를 전송하도록 구성된 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제31항에 있어서, 상기 코드는 상기 복수의 버스의 적어도 하나를 통한 데이터 전송의 타이밍을 통제하는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "제28항에 있어서, 제2 복수의 버스를 더 포함하고, 상기 제2 복수의 버스는 각각 상기 복수의 프로세서 서브유닛의 하나를 상응하는 전용 메모리 뱅크에 연결하는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제33항에 있어서, 상기 제2 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛과 이에 상응하는 전용 메모리뱅크 사이의 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "제33항에 있어서, 상기 제2 복수의 버스는 버스 아비터가 없어서 프로세서 서브유닛과 이에 상응하는 전용 메모리 뱅크 사이의 데이터 전송은 버스 아비터에 의해 제어되지 않는 것을 특징으로 하는, 분산 프로세서. 공개특허 10-2020-0047551-7-청구항 36 제28항에 있어서, 상기 복수의 프로세서 서브유닛은 상기 메모리 어레이 이내의 상기 복수의 이산 메모리 뱅크 사이에 공간적으로분산된 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "제28항에 있어서, 상기 기판은 반도체 기판을 포함하는 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이; 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이; 및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 이산 메모리 뱅크의 상응하는 전용 메모리 뱅크에 각각연결하는 복수의 버스를 포함하고, 상기 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛과 이에 상응하는 상기 복수의 이산메모리 뱅크의 전용 메모리 뱅크 사이의 데이터 전송과 상기 복수의 버스의 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않는 것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_39", "content": "기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이; 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이; 및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 프로세서 서브유닛의 적어도 다른 하나에 각각 연결하는복수의 버스를 포함하고, 상기 복수의 프로세서 서브유닛은 상기 복수의 버스를 통한 데이터 전송의 타이밍을 제어하여 상기 복수의 버스의 적어도 하나 상에서 데이터 전송이 충돌하지 않도록 하는 소프트웨어를 실행하도록 구성된 것을 특징으로 하는, 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "기판; 상기 기판에 배치된 복수의 프로세서 서브유닛―여기서, 각 프로세서 서브유닛은 다른 프로세서 서브유닛과 별개인 일련의 명령을 실행하도록 구성되고, 각 일련의 명령은 단일 프로세서 서브유닛에 의해 수행될 일련의 작업을 정의함; 공개특허 10-2020-0047551-8-상기 기판에 배치된 상응하는 복수의 메모리 뱅크―여기서, 상기 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의 프로세서 서브유닛의 다른 프로세서 서브유닛에 의해 공유되지 않는 적어도 하나의 전용 메모리 뱅크에 연결됨; 및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 프로세서 서브유닛의 적어도 다른 하나에 각각 연결하는복수의 버스를 포함하고, 상기 복수의 버스의 적어도 하나를 통한 데이터 전송은 상기 복수의 버스의 상기 적어도 하나에 연결된 프로세서 서브유닛에 포함된 상기 일련의 명령에 의해 미리 정의된 것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "제40항에 있어서, 각 일련의 명령은 상응하는 일련의 작업을 정의하는 머신 코드 세트를 포함하는 것을 특징으로 하는, 메모리 칩상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "제41항에 있어서, 상기 일련의 작업은 복수의 논리 회로 중의 고수준(higher-level)의 일련의 작업을 복수의 일련의 작업으로 분포하도록 구성된 컴파일러에 의해 정의되는 것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_43", "content": "제42항에 있어서, 상기 고수준의 일련의 작업은 인간-판독 가능 프로그래밍 언어로 된 명령 세트를 포함하는 것을 특징으로 하는,메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_44", "content": "제40항에 있어서, 상기 복수의 버스의 상기 적어도 하나에 연결된 상기 프로세서 서브유닛에 포함된 상기 일련의 명령은 상기 복수의 버스의 상기 적어도 하나에 연결된 상기 프로세서 서브유닛이 상기 복수의 버스의 상기 적어도 하나로 데이터를 쓰게 하는 명령을 포함하는 전송 작업을 포함하는 것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_45", "content": "제40항에 있어서, 상기 복수의 버스의 상기 적어도 하나에 연결된 상기 프로세서 서브유닛에 포함된 상기 일련의 명령은 상기 복수의 버스의 상기 적어도 하나에 연결된 상기 프로세서 서브유닛이 상기 복수의 버스의 상기 적어도 하나로부터데이터를 읽게 하는 명령을 포함하는 수신 작업을 포함하는 것을 특징으로 하는, 메모리 칩 상의 분산프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_46", "content": "메모리 칩 상에 배치된 복수의 프로세서 서브유닛; 상기 메모리 칩 상에 배치된 복수의 메모리 뱅크―여기서, 상기 복수의 메모리 뱅크의 각 메모리 뱅크는 상기복수의 메모리 뱅크의 다른 메모리 뱅크에 저장된 데이터와 별개인 데이터를 저장하도록 구성되고, 상기 복수의프로세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의 메모리 뱅크 중에서 적어도 하나의 전용 메모리 뱅크에 연결됨; 및 복수의 버스―여기서, 상기 복수의 버스의 각 버스는 상기 복수의 프로세서 서브유닛의 각 프로세서 서브유닛을공개특허 10-2020-0047551-9-상기 복수의 메모리 뱅크 중에서 하나 이상의 상응하는 전용 메모리 뱅크에 연결함―을 포함하고, 상기 복수의 버스의 특정 버스를 통한 데이터 전송은 상기 복수의 버스의 상기 특정 버스에 연결된 상응하는 프로세서 서브유닛에 의해 제어되는 것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_47", "content": "제46항에 있어서, 상기 복수의 메모리 뱅크 각각에 저장된 상기 데이터는 상기 복수의 메모리 뱅크 사이에 데이터를 분산하도록구성된 컴파일러에 의해 정의되는 것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_48", "content": "제47항에 있어서, 상기 컴파일러는 상응하는 프로세서 서브유닛에 분산된 저수준(lower-level)의 일련의 작업을 이용하여 고수준의 일련의 작업에서 정의된 데이터를 상기 복수의 메모리 뱅크에 분산하도록 구성된 것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_49", "content": "제48항에 있어서, 상기 고수준의 일련의 작업은 인간-판독 가능 프로그래밍 언어로 된 명령 세트를 포함하는 것을 특징으로 하는,메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_50", "content": "제48항에 있어서, 상기 저수준의 일련의 작업은 머신 코드로 된 명령 세트를 포함하는 것을 특징으로 하는, 메모리 칩 상의 분산프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_51", "content": "메모리 칩 상에 배치된 복수의 프로세서 서브유닛; 상기 메모리 칩 상에 배치된 복수의 메모리 뱅크―여기서, 상기 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의 메모리 뱅크 중에서 적어도 하나의 전용 메모리 뱅크에 연결되고, 상기 복수의 메모리 뱅크의 각 메모리 뱅크는 상기 복수의 메모리 뱅크의 다른 메모리 뱅크에 저장된 데이터와 별개인 데이터를 저장하도록 구성되고, 상기 복수의 메모리 뱅크 중에서 한 특정 메모리 뱅크에 저장된 상기 데이터의 적어도 일부는상기 복수의 메모리 뱅크의 적어도 다른 한 메모리 뱅크에 저장된 데이터의 복제를 포함함; 및 복수의 버스―여기서, 상기 복수의 버스의 각 버스는 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 메모리 뱅크 중에서 하나 이상의 상응하는 전용 메모리 뱅크에 연결함―를 포함하고, 상기 복수의 버스의 특정 버스를 통한 데이터 전송은 상기 복수의 버스의 상기 특정 버스에 연결된 상응하는 프로세서 서브유닛에 의해 제어되는 것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_52", "content": "제51항에 있어서, 공개특허 10-2020-0047551-10-상기 복수의 메모리 뱅크 중의 상기 한 특정 메모리 뱅크 및 상기 복수의 메모리 뱅크의 상기 적어도 다른 한메모리 뱅크에 복제된 상기 적어도 일부 데이터는 메모리 뱅크를 통해 데이터를 복제하도록 구성된 컴파일러에의해 정의되는 것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_53", "content": "제51항에 있어서, 상기 복수의 메모리 뱅크 중의 상기 한 특정 메모리 뱅크 및 상기 복수의 메모리 뱅크의 상기 적어도 다른 한메모리 뱅크에 복제된 상기 적어도 일부 데이터는 신경망의 가중치를 포함하는 것을 특징으로 하는, 메모리 칩상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_54", "content": "제53항에 있어서, 상기 신경망의 각 노드는 상기 복수의 프로세서 서브유닛의 적어도 하나의 프로세서 서브유닛에 의해 정의되는것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_55", "content": "제54항에 있어서, 각 노드는 상기 노드를 정의하는 상기 적어도 하나의 프로세서 서브유닛에 의해 실행되는 머신 코드를 포함하는것을 특징으로 하는, 메모리 칩 상의 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_56", "content": "복수의 프로세서 서브유닛과 복수의 메모리 뱅크를 포함하는 메모리 칩 상에서 실행할 일련의 명령을 컴파일하기 위한 명령을 저장하는 비일시적 컴퓨터 가독 매체에 있어서, 상기 복수의 프로세서 서브유닛의 각 프로세서서브유닛은 상기 복수의 메모리 뱅크의 적어도 하나의 상응하는 전용 메모리 뱅크에 연결되고, 상기 명령은 적어도 하나의 프로세서로 하여금: 상기 일련의 명령을 복수의 그룹의 서브시리즈(sub-series) 명령으로 분할―여기서, 상기 분할은: 상기 일련의 명령과 연관된 작업을 상기 프로세서 서브유닛의 서로 다른 서브 유닛에 배정―여기서, 상기 프로세서 서브유닛은 상기 메모리 칩 상에 배치된 상기 복수의 메모리 뱅크 사이에 공간적으로 분포됨; 상기 메모리 칩의 상기 프로세서 서브유닛의 쌍들 사이에 데이터를 전송하는 작업을 생성―여기서, 상기 프로세서 서브유닛의 각 쌍은 버스에 의해 연결됨; 및 상기 배정 및 생성된 작업을 상기 복수의 그룹의 서브시리즈 명령으로 그루핑―여기서, 상기 복수의 그룹의 서브시리즈 명령은 각각 상기 복수의 프로세서 서브유닛의 서로 다른 프로세서 서브유닛에 상응함―하는 것을 포함함; 상기 복수의 그룹의 서브시리즈 명령의 각각에 상응하는 머신코드를 생성; 및 상기 복수의 그룹의 서브시리즈 명령의 각각에 상응하여 생성된 상기 머신코드를 상기 분할에 따라 상기 복수의프로세서 서브유닛의 상응하는 프로세서 서브유닛에 배정; 하도록 유발하는 것을 특징으로 하는, 비일시적 컴퓨터 가독 매체."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_57", "content": "공개특허 10-2020-0047551-11-제56항에 있어서, 상기 일련의 명령과 연관된 작업은 상기 메모리 칩 상의 둘 이상의 프로세서 서브유닛 사이의 공간적 근접성에따라 상기 프로세서 서브유닛의 상기 서로 다른 서브 유닛에 배정되는 것을 특징으로 하는, 비일시적 컴퓨터 가독 매체."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_58", "content": "제56항에 있어서, 상기 명령은 상기 적어도 하나의 프로세서로 하여금: 상기 분할에 의거하여 상기 일련의 명령과 연관된 데이터를 분류; 및 상기 분류에 따라 상기 데이터를 상기 메모리 뱅크에 배정하도록 더 유발하는 것을 특징으로 하는, 비일시적 컴퓨터 가독 매체."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_59", "content": "제58항에 있어서, 상기 데이터의 분류는 상기 메모리 뱅크의 둘 이상의 메모리 뱅크로 복제될 상기 데이터의 적어도 일부를 판단하는 작업을 포함하는 것을 특징으로 하는, 비일시적 컴퓨터 가독 매체."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_60", "content": "복수의 프로세서 서브유닛과 이에 상응하는 복수의 메모리 뱅크를 포함하는 메모리 칩에 있어서, 각 프로세서서브유닛은 상기 프로세서 서브유닛 전용의 적어도 하나의 메모리 뱅크에 연결되고, 상기 메모리 칩의 상기 프로세서 서브유닛은 제56항에 따라 생성된 상기 머신 코드를 실행하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_61", "content": "복수의 메모리 뱅크―여기서, 각 메모리 뱅크는 뱅크 로우 디코더, 뱅크 컬럼 디코더, 및 복수의 메모리 서브뱅크를 포함하고, 각 메모리 서브뱅크는 상기 메모리 서브뱅크 상의 위치로 읽기와 쓰기가 되도록 하기 위한 서브뱅크 로우 디코더 및 서브뱅크 컬럼 디코더를 포함하고, 각 메모리 서브뱅크는 복수의 메모리 매트를 포함하고,각 메모리 매트는 복수의 메모리 셀을 포함함―를 포함하고, 상기 서브뱅크 로우 디코더와 상기 서브뱅크 컬럼 디코더는 상기 뱅크 로우 디코더와 상기 뱅크 컬럼 디코더로연결되는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_62", "content": "제61항에 있어서, 각 메모리 서브뱅크는 상기 메모리 뱅크의 컨트롤러로부터의 읽기 요청과 쓰기 요청을 처리할지 여부를 판단하도록 구성된 서브뱅크 컨트롤러를 더 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_63", "content": "공개특허 10-2020-0047551-12-제62항에 있어서, 상기 메모리의 상기 컨트롤러는 시스템 클럭에 동기화되는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_64", "content": "제62항에 있어서, 상기 메모리 서브뱅크의 상기 컨트롤러는 시스템 클럭에 동기화되지 않는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_65", "content": "제61항에 있어서, 각 서브뱅크는 상기 서브뱅크를 전용 메모리로 사용하는 프로세서 서브유닛을 더 포함하는 것을 특징으로 하는,메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_66", "content": "제61항에 있어서, 상기 프로세서 서브유닛은 설정 가능 프로세서 서브유닛을 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_67", "content": "제65항에 있어서, 각 프로세서 서브유닛은 상기 뱅크 로우 디코더와 상기 뱅크 컬럼 디코더를 사용하지 않고 상기 서브 뱅크의 상기 로우 디코더와 상기 컬럼 디코더를 사용하여 상기 프로세서 서브유닛의 전용 서브 뱅크에 접근하도록 구성된것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_68", "content": "복수의 메모리 뱅크―여기서, 각 메모리 뱅크는 뱅크 컨트롤러 및 복수의 메모리 서브뱅크를 포함하고, 각 메모리 서브뱅크는 상기 상기 메모리 서브뱅크 상의 위치로 읽기와 쓰기가 되도록 하기 위한 서브뱅크 로우 디코더및 서브뱅크 컬럼 디코더를 포함하고, 각 메모리 서브뱅크는 복수의 메모리 매트를 포함하고, 각 메모리 매트는복수의 메모리 셀을 포함함―를 포함하고, 상기 서브뱅크 로우 디코더와 상기 서브뱅크 컬럼 디코더는 상기 뱅크 컨트롤러로부터의 읽기 및 쓰기 요청을처리하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_69", "content": "제68항에 있어서, 각 메모리 서브뱅크는 상기 뱅크 컨트롤러로부터의 읽기 요청과 쓰기 요청을 처리할지 여부를 판단하도록 구성된 서브뱅크 컨트롤러를 더 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_70", "content": "공개특허 10-2020-0047551-13-제69항에 있어서, 상기 뱅크 컨트롤러는 시스템 클럭에 동기화되는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_71", "content": "제69항에 있어서, 상기 메모리 서브뱅크의 상기 컨트롤러는 시스템 클럭에 동기화되지 않는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_72", "content": "제68항에 있어서, 각 서브뱅크는 상기 서브뱅크를 전용 메모리로 사용하는 프로세서 서브유닛을 더 포함하는 것을 특징으로 하는,메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_73", "content": "제72항에 있어서, 각 프로세서 서브유닛은 상기 뱅크 컨트롤러를 사용하지 않고 상기 서브 뱅크의 상기 로우 디코더와 상기 컬럼디코더를 사용하여 상기 프로세서 서브유닛의 전용 서브 뱅크에 접근하도록 구성된 것을 특징으로 하는, 메모리칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_74", "content": "복수의 메모리 뱅크―여기서, 각 메모리 뱅크는 상기 메모리 뱅크 상의 위치로 읽기 및 쓰기를 처리하기 위한뱅크 컨트롤러를 포함하고, 각 메모리 뱅크는 복수의 메모리 매트를 포함하고, 각 메모리 매트는 복수의 메모리셀과 매트 로우 디코더와 매트 컬럼 디코더를 포함함―를 포함하고, 상기 매트 로우 디코더와 상기 매트 컬럼 디코더는 상기 서브뱅크 컨트롤러로부터의 읽기 및 쓰기 요청을 처리하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_75", "content": "제74항에 있어서, 각 메모리 매트는 상기 뱅크 컨트롤러로부터의 상기 명령 주소에 의거하여 상기 서브뱅크 컨트롤러로부터의 읽기 요청 및 쓰기 요청을 처리할지 여부를 판단하도록 구성된 비교기를 더 포함하는 것을 특징으로 하는, 메모리칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_76", "content": "제74항에 있어서, 각 메모리 매트에는 하나 이상의 퓨즈에 의해 판단된 주소 범위가 배정된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_77", "content": "공개특허 10-2020-0047551-14-제76항에 있어서, 상기 하나 이상의 퓨즈는 결함이 있는 메모리 매트를 비활성화 하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_78", "content": "제74항에 있어서, 각 서브뱅크는 상기 서브뱅크를 전용 메모리로 사용하는 프로세서 서브유닛을 더 포함하는 것을 특징으로 하는,메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_79", "content": "복수의 메모리 뱅크―여기서, 각 메모리 뱅크는 상기 메모리 뱅크 상의 위치로 읽기와 쓰기가 되도록 하기 위한뱅크 컨트롤러, 로우 디코더, 및 컬럼 디코더를 포함함; 및 상기 복수의 뱅크 컨트롤러의 각 컨트롤러를 상기 복수의 뱅크 컨트롤러의 적어도 하나의 다른 컨트롤러에 연결하는 복수의 버스를 포함하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_80", "content": "제79항에 있어서, 상기 복수의 버스는 상기 메모리 뱅크의 메인 버스 상의 데이터 전송의 방해 없이 접근될 수 있는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_81", "content": "제79항에 있어서, 각 컨트롤러는 복수의 다른 컨트롤러에 연결되고 데이터의 전송 또는 수신을 위해 상기 복수의 다른 컨트롤러의하나의 다른 컨트롤러를 선택하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_82", "content": "제79항에 있어서, 각 메모리 뱅크는 DRAM 뱅크를 포함하는 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_83", "content": "제79항에 있어서, 각 컨트롤러는 상기 컨트롤러를 포함하는 상기 메모리 뱅크에 읽기 및 쓰기를 하기 위한 주소를 판단하도록 설정 가능하고 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_84", "content": "제79항에 있어서, 공개특허 10-2020-0047551-15-각 컨트롤러는 다른 컨트롤러로부터 입력되는 데이터를 처리한 후에 상기 데이터를 상기 컨트롤러를 포함하는상기 메모리 뱅크로 전달하도록 구성된 것을 특징으로 하는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_85", "content": "제79항에 있어서, 각 컨트롤러는 공간적으로 인접한 다른 컨트롤러에 연결되는, 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_86", "content": "기판; 상기 기판 상에 배치된 복수의 메모리 뱅크; 상기 기판 상에 배치된 복수의 프라이머리 로직 블록―여기서, 상기 복수의 프라이머리 로직 블록은 각각 상기복수의 메모리 뱅크의 적어도 하나에 연결됨; 상기 기판 상에 배치된 복수의 리던던트 블록―여기서, 상기 복수의 리던던트 블록은 각각 상기 메모리 뱅크의적어도 하나에 연결되고, 상기 복수의 리던던트 블록은 각각 상기 복수의 프라이머리 로직 블록의 적어도 하나를 복제함; 및 상기 기판 상에 배치된 복수의 설정 스위치―여기서, 상기 복수의 설정 스위치는 각각 상기 복수의 프라이머리로직 블록의 적어도 하나 또는 상기 복수의 리던던트 블록의 적어도 하나에 연결됨―를 포함하고, 상기 복수의 프라이머리 로직 블록의 하나와 연관된 결함이 검출되는 경우: 상기 복수의 설정 스위치의 제1 설정 스위치는 상기 복수의 프라이머리 로직 블록의 상기 하나를 비활성화하도록 설정되고, 상기 복수의 설정 스위치의 제2 설정 스위치는 상기 복수의 프라이머리 로직 블록의 상기 하나를 복제하는 상기복수의 리던던트 블록의 하나를 활성화하도록 설정되는,메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_87", "content": "제86항에 있어서,상기 복수의 설정 스위치는 복수의 활성화 스위치와 복수의 비활성화 스위치를 포함하고, 상기 복수의 활성화 스위치의 각 활성화 스위치와 상기 복수의 비활성화 스위치의 각 비활성화 스위치는 외부입력을 포함하고, 상기 복수의 활성화 스위치의 각 활성화 스위치는 상기 외부 입력의 활성화 신호가 스위치가 닫힌 상태를 유발하도록 설정되고, 상기 복수의 비활성화 스위치의 각 비활성화 스위치는 상기 외부 입력의 비활성화 신호가 스위치가 열린 상태를유발하도록 설정되는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_88", "content": "제86항에 있어서, 상기 복수의 프라이머리 로직 블록의 적어도 하나는 제1 전용 연결로 상기 복수의 메모리 뱅크의 서브세트에 연결되고, 공개특허 10-2020-0047551-16-상기 복수의 프라이머리 로직 블록의 상기 적어도 하나를 복제하는 상기 복수의 리던던트 블록의 적어도 하나는제2 전용 연결로 상기 복수의 메모리 뱅크의 상기 서브세트에 연결되는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_89", "content": "제87항에 있어서, 상기 복수의 설정 스위치의 각 설정 스위치는 상기 복수의 프라이머리 또는 리던던트 로직 블록의 적어도 하나를 클럭 노드 또는 전원 노드와 결합하는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_90", "content": "제86항에 있어서, 상기 복수의 프라이머리 로직 블록은: 상기 메모리 뱅크에 읽기 및 쓰기 동작을 활성화하도록 구성된 적어도 하나의 메모리 로직 블록; 및 메모리 내 계산을 수행하도록 구성된 적어도 하나의 비즈니스 로직 블록을 포함하는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_91", "content": "제90항에 있어서, 상기 적어도 하나의 비즈니스 로직 블록은 제1 비즈니스 로직 블록을 포함하고, 상기 복수의 리던던트 블록은 상기 제1 비즈니스 로직 블록을 복제하는 제2 비즈니스 로직 블록을 포함하는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_92", "content": "제86항에 있어서, 상기 복수의 설정 스위치는 퓨즈, 안티퓨즈, 비휘발성 메모리, 및 일회용 프로그램 가능 장치 중의 적어도 하나를 포함하는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_93", "content": "제86항에 있어서, 상기 복수의 프라이머리 로직 블록의 각 프라이머리 로직 블록과 상기 복수의 리던던트 블록의 각 리던던트 블록은 어드레스 버스와 데이터 버스로 연결되는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_94", "content": "제86항에 있어서, 상기 복수의 프라이머리 로직 블록의 적어도 하나는: 적어도 하나의 로컬 논리부; 공개특허 10-2020-0047551-17-적어도 하나의 계산부; 및 적어도 하나의 복제부를 포함하고,상기 적어도 하나의 복제부는 상기 적어도 하나의 계산부를 복제하고,상기 적어도 하나의 로컬 논리부의 사이즈는 상기 적어도 하나의 계산부보다 작은 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_95", "content": "제94항에 있어서, 상기 복수의 프라이머리 로직 블록의 상기 적어도 하나는 상기 적어도 하나의 계산부 및 상기 적어도 하나의 복제부의 적어도 하나에 각각 연결되는 복수의 로컬 설정 스위치를 포함하고, 상기 로컬 설정 스위치는 상기 적어도 하나의 계산부에 결함이 검출되는 경우에 상기 적어도 하나의 계산부를비활성화 하고 상기 적어도 하나의 복제부를 활성화하도록 설정된 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_96", "content": "제86항에 있어서, 어드레스 매니저; 및 상기 어드레스 매니저를 상기 복수의 메모리 뱅크의 각 메모리 뱅크, 상기 복수의 프라이머리 로직 블록의 각프라이머리 로직 블록, 및 상기 복수의 리던던트 블록의 각 리던던트 블록에 결합하는 어드레스 버스를 더 포함하고, 상기 복수의 프라이머리 로직 블록의 상기 하나와 연관된 상기 결함이 검출되면, 상기 복수의 프라이머리 로직블록의 상기 하나에 유효하지 않은 주소가 배정되고, 상기 복수의 리던던트 블록의 상기 하나에 유효한 주소가배정되는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_97", "content": "제86항에 있어서, 상기 복수의 프라이머리 로직 블록은 직렬로 연결되고, 상기 복수의 프라이머리 로직 블록의 각 프라이머리 로직 블록은 병렬 스위치와 병렬로 연결되고, 상기 복수의 프라이머리 로직 블록의 상기 하나와 연관된 상기 결함이 검출되면, 상기 복수의 프라이머리 로직블록의 상기 하나에 연결된 상기 병렬 스위치는 상기 복수의 프라이머리 로직 블록의 두 프라이머리 로직 블록을 서로 결합하도록 활성화되는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_98", "content": "제97항에 있어서, 공개특허 10-2020-0047551-18-상기 병렬 스위치는 안티퓨즈를 포함하는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_99", "content": "제97항에 있어서, 상기 병렬 스위치는 선택된 사이클 지연이 있는 샘플링 회로를 포함하는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_100", "content": "제86항에 있어서, 상기 복수의 프라이머리 로직 블록과 상기 복수의 리던던트 블록은 2차원 그리드(grid)로 상기 기판 상에 배치되고, 상기 복수의 프라이머리 로직 블록의 각 프라이머리 로직 블록과 상기 복수의 리던던트 블록의 각 리던던트 블록은 연결 박스로 서로 연결되고, 입력 블록이 상기 2차원 그리드의 각 라인과 각 컬럼의 주변에 배치되는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_101", "content": "제86항에 있어서, 상기 메모리 칩은 DRAM, 플래시메모리, SRAM, ReRAM, PRAM, 및 MRAM의 적어도 하나를 포함하는 것을 특징으로하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_102", "content": "제86항에 있어서, 상기 복수의 프라이머리 로직 블록의 각 프라이머리 로직 블록은 상기 복수의 리던던트 블록의 적어도 하나와균등한 계산 능력을 가진 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_103", "content": "제86항에 있어서, 상기 복수의 프라이머리 로직 블록은 적어도 하나의 로컬 계산부 및 적어도 하나의 로컬 계산부를 복제하는 적어도 하나의 리던던트 계산부를 포함하는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_104", "content": "제86항에 있어서, 상기 제1 설정 스위치는 상기 복수의 프라이머리 로직 블록의 상기 하나를 복제하는 상기 복수의 리던던트 블록의 상기 하나를 활성화하도록 더 설정되는 것을 특징으로 하는, 메모리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_105", "content": "공개특허 10-2020-0047551-19-기판; 상기 기판 상에 배치된 어드레스 매니저; 상기 기판 상에 배치된 복수의 프라이머리 로직 블록―여기서, 상기 복수의 프라이머리 로직 블록은 각각 복수의 메모리 뱅크의 적어도 하나에 연결됨; 상기 기판 상에 배치된 복수의 리던던트 블록―여기서, 상기 복수의 리던던트 블록은 각각 상기 복수의 메모리뱅크의 적어도 하나에 연결되고, 상기 복수의 리던던트 블록은 각각 상기 복수의 프라이머리 로직 블록의 적어도 하나를 복제함; 및 상기 복수의 프라이머리 로직 블록의 각각, 상기 복수의 리던던트 블록의 각각, 및 상기 어드레스 매니저에 연결된 상기 기판 상에 배치된 버스를 포함하고, 시험 프로토콜에 합격하는 상기 복수의 프라이머리 로직 블록의 블록에 실행 ID 번호를 배정하고, 상기 시험 프로토콜에 불합격하는 상기 복수의 프라이머리 로직 블록의 블록에 불법 ID 번호를 배정하고, 상기 시험 프로토콜에 합격하는 상기 복수의 리던던트 블록의 블록에 실행 ID 번호를 배정하도록 구성된, 메모리 칩 상에 배치된 분산 프로세서."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_106", "content": "105항에 있어서, 실행 ID 번호가 배정된 상기 복수의 리던던트 블록의 상기 블록은 불법 ID 번호가 배정된 상기 복수의 프라이머리 로직 블록의 상기 블록보다 크거나 같은 것을 특징으로 하는, 분산 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_107", "content": "제106항에 있어서, 상기 복수의 프라이머리 로직 블록의 각 프라이머리 로직 블록과 상기 복수의 리던던트 블록의 각 리던던트 블록은 퓨즈드 ID 회로(fused identification circuit)를 포함하는 것을 특징으로 하는, 분산 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_108", "content": "제107항에 있어서, 상기 버스는 명령 라인, 데이터 라인, 및 어드레스 라인을 포함하는 것을 특징으로 하는, 분산 메모리 칩."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_109", "content": "메모리 칩의 기판 상의 복수의 프라이머리 로직 블록의 각 프라이머리 로직 블록을 검사하여 적어도 하나의 회로 기능을 확인하는 단계; 상기 검사의 결과에 의거하여 상기 복수의 프라이머리 로직 블록에서 결함이 있는 적어도 하나의 로직 블록을식별하는 단계―여기서, 상기 결함이 있는 적어도 하나의 로직 블록은 상기 메모리 칩의 상기 기판 상에 배치된적어도 하나의 메모리 뱅크에 연결됨; 상기 메모리 칩의 상기 기판 상의 적어도 하나의 리던던트 블록을 검사하여 상기 적어도 하나의 회로 기능을 확인하는 단계―여기서, 상기 적어도 하나의 리던던트 블록은 상기 결함이 있는 적어도 하나의 로직 블록을 복제하고 상기 적어도 하나의 메모리 뱅크에 연결됨; 외부 신호를 비활성화 스위치에 인가하여 상기 결함이 있는 적어도 하나의 로직 블록을 비활성화 하는 단계―여기서, 상기 비활성화 스위치는 상기 결함이 있는 적어도 하나의 로직 블록에 연결되고 상기 메모리 칩의 상기공개특허 10-2020-0047551-20-기판 상에 배치됨; 및 상기 외부 신호를 활성화 스위치에 인가하여 상기 적어도 하나의 리던던트 블록을 활성화하는 단계―여기서, 상기 활성화 스위치는 상기 적어도 하나의 리던던트 블록과 연결되고 상기 메모리 칩의 상기 기판 상에 배치됨―를 포함하는, 메모리 칩 상에 분산 프로세서를 구성하는 방법."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_110", "content": "메모리 칩의 기판 상의 복수의 프라이머리 로직 블록과 복수의 리던던트 블록을 활성화하는 단계; 상기 메모리 칩의 상기 기판 상의 상기 복수의 프라이머리 로직 블록의 각 프라이머리 로직 블록을 검사하여 적어도 하나의 회로 기능을 확인하는 단계; 상기 검사의 결과에 의거하여 상기 복수의 프라이머리 로직 블록에서 결함이 있는 적어도 하나의 로직 블록을식별하는 단계―여기서, 상기 결함이 있는 적어도 하나의 로직 블록은 상기 메모리 칩의 상기 기판 상에 배치된적어도 하나의 메모리 뱅크에 연결됨; 상기 메모리 칩의 상기 기판 상의 적어도 하나의 리던던트 블록을 검사하여 상기 적어도 하나의 회로 기능을 확인하는 단계―여기서, 상기 적어도 하나의 리던던트 블록은 상기 결함이 있는 적어도 하나의 로직 블록을 복제하고 상기 적어도 하나의 메모리 뱅크에 연결됨; 및 외부 신호를 활성화 스위치에 인가하여 적어도 하나의 리던던트 블록을 비활성화 하는 단계―여기서, 상기 활성화 스위치는 상기 적어도 하나의 리던던트 블록과 연결되고 상기 메모리 칩의 상기 기판 상에 배치됨―를 포함하는, 메모리 칩 상에 분산 프로세서를 구성하는 방법."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_111", "content": "기판; 상기 기판 상에 배치된 복수의 메모리 뱅크; 상기 복수의 메모리 뱅크의 각 메모리 뱅크에 연결된 상기 기판 상에 배치된 메모리 컨트롤러; 및 상기 기판 상에 배치된 복수의 처리부―여기서, 상기 복수의 처리부의 각 처리부는 상기 메모리 컨트롤러에 연결되고, 상기 복수의 처리부는 설정 매니저를 포함함―을 포함하고, 상기 설정 매니저는: 수행될 작업의 제1 표시를 수신―여기서, 상기 작업은 적어도 하나의 계산이 필요함; 상기 복수의 처리부에서 선택된 적어도 하나의 처리부에 상기 적어도 하나의 계산을 수행하기 위해 필요한 신호를 상기 선택된 처리부의 역량에 의거하여 송신; 및 제2 표시를 상기 적어도 하나의 선택된 처리부에 전송하도록 구성되고, 상기 메모리 컨트롤러는: 상기 메모리 컨트롤러를 통해 적어도 두 개의 메모리 뱅크 및 상기 적어도 하나의 선택된 처리부에 연결되는 적어도 하나의 통신 라인을 활용하여 상기 적어도 두 개의 메모리 뱅크로부터 상기 적어도 하나의 선택된 처리부로 데이터를 라우팅 하도록 구성되는 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_112", "content": "공개특허 10-2020-0047551-21-제111항에 있어서, 상기 제2 표시의 전송은 상기 적어도 하나의 선택된 처리부에 의해 상기 작업을 실행하라는 명령의 전달을 포함하고, 상기 적어도 하나의 선택된 처리부는 데이터를 상기 메모리 컨트롤러에 전송 또는 상기 메모리 컨트롤러로부터 수신하도록 구성되는 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_113", "content": "제111항에 있어서, 상기 제2 표시의 전송은 데이터를 상기 메모리 컨트롤러로 라우팅 하라는 명령의 전달을 포함하는 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_114", "content": "제111항에 있어서, 상기 적어도 하나의 선택된 처리부는 상기 적어도 두 개의 메모리 뱅크의 제1 메모리 뱅크에 개통된 메모리 라인으로의 일련의 접근 중에 상기 적어도 두 개의 메모리 뱅크의 제2 메모리 뱅크에 메모리 라인을 개통하도록구성되는 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_115", "content": "제114항에 있어서, 상기 선택된 처리부는 통신 라인이 상기 제1 메모리 뱅크로 개통되는 라인 액세스 주기 동안에 상기 제2 메모리뱅크로 데이터를 전달하도록 구성된 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_116", "content": "제111항에 있어서, 상기 메모리 컨트롤러는 상기 복수의 메모리 뱅크로부터의 적어도 두 개의 데이터 입력 및 상기 복수의 처리부의 각 처리부로 연결된 적어도 두 개의 데이터 출력을 포함하고, 상기 메모리 컨트롤러는 상기 두 개의 데이터 입력을 통하여 두 개의 메모리 뱅크로부터 데이터를 동시에 수신하도록 구성되고, 상기 메모리 컨트롤러는 상기 두 개의 데이터 입력을 통하여 수신된 데이터를 상기 두 개의 데이터 출력을 통하여 상기 적어도 하나의 선택된 처리부로 동시에 전송하도록 구성된 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_117", "content": "제111항에 있어서, 상기 복수의 처리부는 미리 정의된 작업을 위해 구성된 복수의 가속기를 포함하는 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_118", "content": "제117항에 있어서, 상기 복수의 가속기는 벡터 MAC(multiply accumulate) 유닛 및 DMA(direct memory access)의 적어도 하나를 포공개특허 10-2020-0047551-22-함하는 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_119", "content": "제117항에 있어서, 상기 설정 매니저는 RISC 프로세서 및 마이크로컨트롤러의 적어도 하나를 포함하는 것을 특징으로 하는, 처리장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_120", "content": "제111항에 있어서, 상기 메모리 뱅크로 연결된 외부 인터페이스를 더 포함하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_121", "content": "제111항에 있어서, 상기 처리 장치는: 상기 복수의 메모리 뱅크의 제1 메모리 뱅크 내에 있는 제1 주소로부터 제1 메모리 라인을 통하여 상기 복수의처리부의 적어도 하나로 데이터를 공급하고, 상기 복수의 메모리 뱅크의 제2 메모리 뱅크 내에 있는 제2 주소를라인 액세스 주기 이내에 제2 메모리 라인에 개통; 및 상기 제2 주소로부터 상기 제2 메모리 라인을 통하여 상기 복수의 처리부의 상기 적어도 하나로 데이터를 공급하고, 제2 라인 액세스 주기 이내에 상기 제1 라인의 상기 제1 메모리 뱅크에 제3 주소를 개통하도록 더구성된, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_122", "content": "제111항에 있어서, 컴파일러는: 상기 작업의 수행을 위해 동시에 필요한 워드의 수를 판단; 상기 복수의 메모리 뱅크의 각 메모리 뱅크로부터 동시에 접근될 수 있는 워드의 수를 판단; 및 상기 동시에 필요한 워드의 수가 상기 동시에 접근될 수 있는 워드의 수보다 큰 경우에 상기 동시에 필요한 워드의 수를 여러 메모리 뱅크 사이에 분할하도록 구성된 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_123", "content": "제122항에서, 상기 워드는 머신 명령을 포함하는 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_124", "content": "제111항에 있어서, 공개특허 10-2020-0047551-23-상기 설정 매니저는 상기 복수의 처리부의 적어도 하나로 전송될 명령을 저장하는 로컬 메모리를 포함하는 것을특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_125", "content": "제111항에 있어서, 상기 메모리 컨트롤러는 외부 인터페이스로부터의 요청의 수신에 대응하여 상기 작업을 중단하도록 구성된 것을특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_126", "content": "제111항에 있어서, 상기 복수의 메모리 뱅크는 DRAM 매트, DRAM, 뱅크, 플래시 매트, 및 SRAM 매트의 적어도 하나를 포함하는 것을특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_127", "content": "제111항에 있어서, 상기 복수의 처리 장치는 적어도 하나의 산술 논리부, 적어도 하나의 벡터 처리 논리부, 적어도 하나의 레지스터, 및 적어도 하나의 DMA(direct memory access)를 포함하는 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_128", "content": "제111항에 있어서, 상기 설정 매니저와 상기 복수의 처리부는 작업을 완료한 이후에 상기 메모리 컨트롤러로의 접근을 서로 넘겨주도록 구성된 것을 특징으로 하는, 처리 장치."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_129", "content": "분산 메모리 장치를 위한 작업을 컴파일러가 컴파일하는 단계―여기서, 상기 작업은 적어도 하나의 계산을 필요로 하고, 상기 컴파일하는 단계는: 상기 작업을 수행하기 위해 동시에 필요한 워드의 수를 판단하는 단계; 및 기판 상에 배치된 복수의 메모리 뱅크의 하나로부터 동시에 접속될 수 있는 워드의 수가 상기 동시에 필요한 워드의 수보다 적은 경우에 동시에 접속되어야 할 워드를 상기 복수의 메모리 뱅크에 쓰기 위한 명령을 제공하는단계를 포함함; 상기 작업을 수행하라는 표시를 상기 기판 상에 배치된 설정 매니저가 수신하는 단계; 및 상기 표시의 수신에 대응하여, 상기 기판에 배치된 메모리 컨트롤러를: 제1 라인 액세스 사이클 이내에서는: 제1 메모리 라인을 활용하여 상기 복수의 메모리 뱅크의 제1 메모리 뱅크로부터의 적어도 하나의 제1 워드에 접속; 상기 적어도 하나의 제1 워드를 적어도 하나의 처리부로 전송; 및 제2 메모리 뱅크에 제1 메모리 라인을 개통하여 상기 복수의 메모리 뱅크의 상기 제2 메모리 뱅크로부터 제2 어드레스에 접속하고; 공개특허 10-2020-0047551-24-제2 라인 액세스 사이클 이내에서는: 상기 제1 메모리 라인을 활용하여 상기 제2 메모리 뱅크로부터 적어도 하나의 제2 워드에 접속; 상기 적어도 하나의 제2 워드를 적어도 하나의 처리부로 전송; 및 상기 제1 메모리 뱅크의 제2 메모리 라인을 활용하여 상기 제1 메모리 뱅크로부터 제3 어드레스에 접속하도록구성하는 단계를 포함하는, 분산 메모리 장치의 운용을 위해 수행되는 방법."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_130", "content": "제129항에 있어서, 상기 작업을 컴파일하는 단계는: 상기 작업을 수행하는데 필요한 사이클의 수를 판단하는 단계; 및 필요한 워드를 순차적 사이클로 상기 복수의 메모리 뱅크의 단일 메모리 뱅크에 기록하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2020-7006169", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_131", "content": "적어도 하나의 프로세서에 의해 실행되는 경우에 상기 적어도 하나의 프로세서로 하여금: 작업을 수행하기 위해 동시에 요구되는 워드의 수를 판단―여기서, 상기 작업은 적어도 하나의 계산을 요구함; 기판 상에 배치된 복수의 메모리 뱅크의 하나로부터 동시에 접속될 수 있는 워드의 수가 상기 동시에 필요한 워드의 수보다 적은 경우에 동시에 접속되어야 할 워드를 상기 복수의 메모리 뱅크에 기록; 상기 작업을 수행하라는 표시를 상기 기판 상에 배치된 설정 매니저로 전송; 및 상기 기판 상에 배치된 메모리 컨트롤러를: 제1 라인 액세스 사이클 이내에서는: 제1 메모리 라인을 활용하여 상기 복수의 메모리 뱅크의 제1 메모리 뱅크로부터의 적어도 하나의 제1 워드에 접속; 상기 적어도 하나의 제1 워드를 적어도 하나의 처리부로 전송; 및 제2 메모리 뱅크에 제1 메모리 라인을 개통하여 상기 복수의 메모리 뱅크의 상기 제2 메모리 뱅크로부터 제2 어드레스에 접속하도록 설정하고, 제2 라인 액세스 사이클 이내에서는: 상기 제1 메모리 라인을 활용하여 상기 제2 메모리 뱅크로부터 적어도 하나의 제2 워드에 접속; 상기 적어도 하나의 제2 워드를 적어도 하나의 처리부로 전송; 및 상기 제1 메모리 뱅크의 제2 메모리 라인을 활용하여 상기 제1 메모리 뱅크로부터 제3 어드레스에 접속하도록설정하는, 명령을 전송하도록 유발하는, 명령을 저장하는 비일시적 컴퓨터 가독 매체."}
{"patent_id": "10-2020-7006169", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 기재는 분산 프로세서와 상기 분산 프로세서에 의한 실행을 위한 코드를 컴파일하는 방법을 포함한다. 일 실 시예에서, 분산 프로세서는 기판, 상기 기판에 배치된 메모리 어레이, 및 상기 기판에 배치된 프로세싱 어레이를 포함할 수 있다. 상기 메모리 어레이는 복수의 이산 메모리 뱅크를 포함할 수 있고, 상기 프로세싱 어레이는 상 기 복수의 이산 메모리 뱅크의 상응하는 전용 메모리 뱅크와 각각 연관된 복수의 프로세서 서브유닛을 포함할 수 있다. 상기 분산 프로세서는 상기 복수의 프로세서 서브유닛의 하나를 이에 상응하는 전용 메모리 뱅크에 각각 연결하는 제1 복수의 버스와 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 프로세서 서브유닛의 다른 하 나에 각각 연결하는 제2 복수의 버스를 더 포함할 수 있다."}
{"patent_id": "10-2020-7006169", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 기재는 메모리 집약적 동작을 가능하게 하는 장치에 관한 것이다. 특히, 본 기재는 전용 메모리 뱅크에 연결 된 처리 소자를 포함하는 하드웨어 칩에 관한 것이다."}
{"patent_id": "10-2020-7006169", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "프로세서 속도와 메모리 용량이 지속적으로 상승함에 따라, 효과적인 처리 속도에 대한 중대한 한계는 폰노이만 병목현상(von Neumann bottleneck)이다. 폰노이만 병목현상은 기존의 컴퓨터 아키텍처의 스루풋(throughput) 한 계에서 기인한다. 특히, 프로세서에 의해 수행되는 실제 계산에 비해 메모리로부터 프로세서로의 데이터 전송에 병목이 생기는 경우가 많다. 이에 따라, 메모리 집약적 처리에서는 메모리에 읽기와 쓰기를 위한 클럭 사이클의 수가 상당히 증가한다. 클럭 사이클이 메모리에 읽기와 쓰기에 소비되고 데이터에 대한 연산을 수행하는데 활용 될 수 없으므로, 그 결과 효과적인 처리 속도에 손실이 발생한다. 또한, 프로세서의 계산 대역폭은 일반적으로 프로세서가 메모리에 접근하기 위해 사용하는 버스의 대역폭보다 크다. 이러한 병목현상은 신경망 및 기타 머신러닝 알고리즘, 데이터베이스 구축, 검색 인덱싱, 및 쿼리 처리와 같은 메모리 집약적 프로세스, 및 데이터 처리 동작보다 많은 읽기와 쓰기 동작을 수반하는 기타 작업에서 더욱 두드 러진다. 또한, 사용 가능한 디지털 데이터의 크기와 입도가 급성장하면서 머신러닝 알고리즘의 구성의 기회가 생겼고 새 로운 기술이 가능해졌다. 그러나 이로 인해 데이터베이스와 병렬 연산의 세계에 번거로운 문제도 생겨났다. 예 를 들어, 소셜미디어와 사물인터넷의 증가로 인해 전례 없는 속도로 디지털 데이터가 생성되고 있다. 이러한 새 로운 데이터는 새로운 광고 방식에서부터 더욱 정교한 산업 공정 제어 방법에 이르기까지 다양한 목적을 위한 알고리즘을 생성하는데 활용될 수 있다. 그러나 새로운 데이터의 저장, 처리, 분석, 및 취급이 쉽지 않았다. 새로운 데이터 소스는 페타바이트 내지 제타바이트 규모로 거대할 수 있다. 또한, 이러한 데이터 소스의 성장 속도는 데이터 처리 능력을 능가할 수 있다. 따라서, 데이터 과학자들은 이러한 문제를 해결하기 위하여 병렬 데이터 처리 방식을 채택해왔다. 계산 능력을 향상하고 거대한 양의 데이터를 취급하려는 노력의 일환으로, 과 학자들은 병렬 집약 계산이 가능한 시스템과 방법을 개발하려고 시도했다. 그러나 기존의 시스템과 방법은 그 방식이 데이터 관리, 분리된 데이터의 통합, 및 분리된 데이터의 분석을 위한 추가적인 리소스의 필요에 의해 제한을 받는 경우가 많기 때문에 데이터 처리의 요구조건을 따라가지 못했다. 대형 데이터 세트의 취급을 가능하게 하기 위하여, 엔지니어들과 과학자들은 이제 데이터 분석에 사용되는 하드 웨어를 향상하려고 노력한다. 예를 들어, 산술적 계산보다는 메모리 운용에 더 적합한 기술로 제조된 단일 기판 내에 메모리 및 처리 기능을 도입함으로써, 새로운 반도체 프로세서 또는 칩(예, 본 기재의 프로세서 또는 칩) 이 데이터 집약적 작업에 특정하여 설계될 수 있다. 데이터 집약적 작업을 위해 특정 설계된 집적회로가 있으면, 새로운 데이터 처리 요구조건의 충족이 가능하다. 그럼에도 불구하고, 대형 데이터 세트의 데이터 처리 문제를 해결하기 위한 이러한 접근방식에는 칩 설계와 제조에서 새로운 문제의 해결이 요구된다. 예컨대, 데이 터 집약적 작업을 위해 설계된 새로운 칩이 일반적인 칩에 사용되는 제조 기술과 아키텍처로 제조된다면, 새로 운 칩은 성능 저하 및/또는 수율 저조를 겪게 될 것이다. 또한, 새로운 칩이 기존의 데이터 취급 방법으로 동작 하도록 설계된다면, 새로운 칩이 병렬 연산을 처리할 능력은 기존의 방법에 의해 한계가 있으므로 새로운 칩의 성능은 저하될 것이다."}
{"patent_id": "10-2020-7006169", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 기재는 메모리 집약적 동작을 가능하게 하는 장치에 관한 것이다. 특히, 본 기재는 전용 메모리 뱅크에 연결 된 처리 소자를 포함하는 하드웨어 칩에 관한 것이다."}
{"patent_id": "10-2020-7006169", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 기재는 상기에 설명한 하나 이상의 문제 및 선행 기술의 기타 문제를 완화 또는 극복하기 위한 해결 방안을 설명한다. 본 기재에 따른 실시예들은 하드웨어 프로세싱 칩을 포함하는 장치를 제공한다. 기재된 실시예들은 처리 소자와 쌍을 이룬 전용 메모리 뱅크를 활용하여 기존의 프로세서보다 더욱 효율적이고 효과적인 처리 속도를 제공할 수 있다. 예를 들어, 기재된 실시예에 따라, 기재된 칩은 각 처리 소자와 각 처리 소자에 상응하는 메모리 뱅크 사이에 전용 버스를 포함할 수 있다. 또한, 기재된 칩은 아비터(arbiter) 및/또는 처리 소자 사이의 데이터 전송 을 타이밍을 제어하는 기타 하드웨어에서 자유로울 수 있다. 기타 기재된 비 일시적 컴퓨터 가독 매체는 고수준 명령을 여기에 기재된 하드웨어 칩에 의해 실행되는 저수준 명령으로 컴파일 하기 위한 명령을 저장할 수 있다. 본 기재의 일부 실시예는, 기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이; 상 기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는 복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이; 상기 복수의 프로세서 서브유닛의 하나를 이에 상응하 는 전용 메모리 뱅크에 각각 연결하는 제1 복수의 버스; 및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수 의 프로세서 서브유닛의 다른 하나에 각각 연결하는 제2 복수의 버스를 포함하는, 분산 프로세서를 포함한다. 본 기재에 따른 다른 실시예는, 기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레 이; 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관 되는 복수의 어드레스 생성기를 포함하는 프로세싱 어레이; 및 상기 복수의 어드레스 생성기의 하나를 이에 상 응하는 전용 메모리 뱅크에 각각 연결하는 복수의 버스를 포함하는, 메모리 칩을 포함한다. 본 기재에 따른 다른 실시예는, 기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레 이―여기서, 이산 메모리 뱅크 각각의 용량은 1메가바이트 이상임; 및 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는 복수의 프로세서 서브유닛을 포함하는 프 로세싱 어레이를 포함하는, 분산 프로세서를 포함할 수 있다. 본 기재에 따른 또 다른 실시예는, 기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어 레이; 상기 기판에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연 관되는 복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이; 및 상기 복수의 프로세서 서브유닛의 하나를 상 기 복수의 프로세서 서브유닛의 적어도 다른 하나에 각각 연결하는 복수의 버스를 포함하는, 분산 프로세서를 포함할 수 있다. 여기서, 상기 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛 사이의 데이터 전송과 상기 복수의 버스의 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제 어받지 않는다. 기타 실시예들은, 기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이; 상기 기판 에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는 복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이; 및 상기 복수의 프로세서 서브유닛의 하나를 이에 상응하는 상 기 복수의 이산 메모리 뱅크의 전용 메모리 뱅크에 각각 연결하는 복수의 버스를 포함하는, 메모리 칩 상의 분 산 프로세서를 포함할 수 있다. 여기서, 상기 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서 브유닛과 이에 상응하는 상기 복수의 이산 메모리 뱅크의 전용 메모리 뱅크 사이의 데이터 전송과 상기 복수의 버스의 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어받지 않는다. 다른 실시예들은, 기판; 상기 기판에 배치되고 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이; 상기 기판 에 배치되고, 상기 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 각각 연관되는 복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이; 및 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 프로 세서 서브유닛의 적어도 다른 하나에 각각 연결하는 복수의 버스를 포함하는, 분산 프로세서를 포함할 수 있다. 여기서, 상기 복수의 프로세서 서브유닛은 상기 복수의 버스를 통한 데이터 전송의 타이밍을 제어하여 상기 복 수의 버스의 적어도 하나 상에서 데이터 전송이 충돌하지 않도록 하는 소프트웨어를 실행하도록 구성된다. 다른 실시예들은, 기판; 상기 기판에 배치된 복수의 프로세서 서브유닛―여기서, 각 프로세서 서브유닛은 다른 프로세서 서브유닛과 별개인 일련의 명령을 실행하도록 구성되고, 일련의 명령 각각은 단일 프로세서 서브유닛 에 의해 수행될 일련의 작업을 정의함; 상기 기판에 배치된 상응하는 복수의 메모리 뱅크―여기서, 상기 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의 프로세서 서브유닛의 다른 프로세서 서브유닛에 의해 공유되지 않는 적어도 하나의 전용 메모리 뱅크에 연결됨; 및 상기 복수의 프로세서 서브유닛의 하나를 상기 복 수의 프로세서 서브유닛의 적어도 다른 하나에 다른 하나에 각각 연결하는 복수의 버스를 포함하는, 메모리 칩 상의 분산 프로세서를 포함할 수 있다. 여기서, 상기 복수의 버스의 적어도 하나를 통한 데이터 전송은 상기 복 수의 버스의 상기 적어도 하나에 연결된 프로세서 서브유닛에 포함된 상기 일련의 명령에 의해 미리 정의된다. 다른 실시예들은 메모리 칩 상의 분산 프로세서를 포함할 수 있다. 상기 분산 프로세서는, 상기 메모리 칩 상에 배치된 복수의 프로세서 서브유닛; 상기 메모리 칩 상에 배치된 복수의 메모리 뱅크―여기서, 상기 복수의 메모 리 뱅크의 각 메모리 뱅크는 상기 복수의 메모리 뱅크의 다른 메모리 뱅크에 저장된 데이터와 별개인 데이터를저장하도록 구성되고, 상기 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의 메모리 뱅크 중에 서 적어도 하나의 전용 메모리 뱅크에 연결됨; 및 복수의 버스―여기서, 상기 복수의 버스의 각 버스는 상기 복 수의 프로세서 서브유닛의 각 프로세서 서브유닛을 상기 복수의 메모리 뱅크 중에서 하나 이상의 상응하는 전용 메모리 뱅크에 연결하고, 상기 복수의 버스의 특정 버스를 통한 데이터 전송은 상기 복수의 버스의 상기 특정 버스에 연결된 상응하는 프로세서 서브유닛에 의해 제어됨;을 포함한다. 다른 실시예들은 메모리 칩 상의 분산 프로세서를 포함할 수 있다. 상기 분산 프로세서는, 상기 메모리 칩 상에 배치된 복수의 프로세서 서브유닛; 상기 메모리 칩 상에 배치된 복수의 메모리 뱅크―여기서, 상기 복수의 프로 세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의 메모리 뱅크 중에서 적어도 하나의 전용 메모리 뱅크에 연결되고, 상기 복수의 메모리 뱅크의 각 메모리 뱅크는 상기 복수의 메모리 뱅크의 다른 메모리 뱅크에 저장된 데이터와 별개인 데이터를 저장하도록 구성되고, 상기 복수의 메모리 뱅크 중에서 한 특정 메모리 뱅크에 저장 된 상기 데이터의 적어도 일부는 상기 복수의 메모리 뱅크의 적어도 다른 메모리 뱅크에 저장된 데이터의 사본 을 포함함; 및 복수의 버스―여기서, 상기 복수의 버스의 각 버스는 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 메모리 뱅크 중에서 하나 이상의 상응하는 전용 메모리 뱅크에 연결하고, 상기 복수의 버스의 특정 버스를 통한 데이터 전송은 상기 복수의 버스의 상기 특정 버스에 연결된 상응하는 프로세서 서브유닛에 의해 제어됨;을 포함한다. 다른 실시예들은 메모리 칩 상의 분산 프로세서를 포함할 수 있다. 상기 분산 프로세서는, 상기 메모리 칩 상에 배치된 복수의 프로세서 서브유닛; 상기 메모리 칩 상에 배치된 복수의 메모리 뱅크―여기서, 상기 복수의 프로 세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의 메모리 뱅크 중에서 적어도 하나의 전용 메모리 뱅크에 연결되고, 상기 복수의 메모리 뱅크의 각 메모리 뱅크는 상기 복수의 메모리 뱅크의 다른 메모리 뱅크에 저장된 데이터와 별개인 데이터를 저장하도록 구성되고, 상기 복수의 메모리 뱅크 중에서 한 특정 메모리 뱅크에 저장 된 상기 데이터의 적어도 일부는 상기 복수의 메모리 뱅크의 적어도 다른 메모리 뱅크에 저장된 데이터의 사본 을 포함함; 및 복수의 버스―여기서, 상기 복수의 버스의 각 버스는 상기 복수의 프로세서 서브유닛의 하나를 상기 복수의 메모리 뱅크 중에서 하나 이상의 상응하는 전용 메모리 뱅크에 연결하고, 상기 복수의 버스의 특정 버스를 통한 데이터 전송은 상기 복수의 버스의 상기 특정 버스에 연결된 상응하는 프로세서 서브유닛에 의해 제어됨;을 포함한다. 다른 실시예들은 복수의 프로세서 서브유닛과 복수의 메모리 뱅크를 포함하는 메모리 칩 상에서 실행할 일련의 명령을 컴파일하기 위한 명령을 저장하는 비 일시적 컴퓨터 가독 매체를 포함할 수 있다. 여기서, 상기 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 상기 복수의 메모리 뱅크의 적어도 하나의 상응하는 전용 메모리 뱅크에 연결되고, 상기 명령은 적어도 하나의 프로세서로 하여금, 상기 일련의 명령을 복수의 그룹의 서브시리 즈(sub-series) 명령으로 분할―여기서, 상기 분할은, 상기 일련의 명령과 연관된 작업을 상기 메모리 칩 상에 배치된 상기 복수의 메모리 뱅크 사이에 공간적으로 분포된 상기 프로세서 서브유닛의 서로 다른 서브 유닛에 배정하고, 상기 메모리 칩의 상기 프로세서 서브유닛의 쌍들 사이에 데이터를 전송하는 작업을 생성하고―여기 서, 프로세서 서브유닛의 각 쌍은 버스에 의해 연결됨―상기 배정 및 생성된 작업을 상기 복수의 그룹의 서브시 리즈 명령으로 그루핑―여기서, 상기 복수의 그룹의 서브시리즈 명령은 각각 상기 복수의 프로세서 서브유닛의 서로 다른 프로세서 서브유닛에 상응함―하는 것을 포함함; 상기 복수의 그룹의 서브시리즈 명령의 각각에 상응 하는 머신코드를 생성; 및 상기 복수의 그룹의 서브시리즈 명령의 각각에 상응하여 생성된 상기 머신코드를 상 기 분할에 따라 상기 복수의 프로세서 서브유닛의 상응하는 프로세서 서브유닛에 배정하도록 유발한다. 다른 실시예들은 복수의 메모리 뱅크를 포함하는 메모리 칩을 포함할 수 있다. 각 메모리 뱅크는 뱅크 로우 디 코더(bank row decoder), 뱅크 컬럼 디코더(bank column decoder), 및 복수의 메모리 서브뱅크(memory sub- bank)를 포함하고, 각 메모리 서브뱅크는 상기 메모리 서브뱅크 상의 위치로 읽기와 쓰기가 되도록 하기 위한 서브뱅크 로우 디코더 및 서브뱅크 컬럼 디코더를 포함하고, 각 메모리 서브뱅크는 복수의 메모리 매트(memory mat)를 포함하고, 각 메모리 매트는 복수의 메모리 셀을 포함하고, 상기 서브뱅크 로우 디코더와 상기 서브뱅크 컬럼 디코더는 상기 뱅크 로우 디코더와 상기 뱅크 컬럼 디코더로 연결된다. 다른 실시예들은 복수의 메모리 뱅크를 포함하는 메모리 칩을 포함할 수 있다. 각 메모리 뱅크는 뱅크 컨트롤러 및 복수의 메모리 서브뱅크를 포함하고, 각 메모리 서브뱅크는 상기 메모리 서브뱅크 상의 위치로 읽기와 쓰기 가 되도록 하기 위한 서브뱅크 로우 디코더 및 서브뱅크 컬럼 디코더를 포함하고, 각 메모리 서브뱅크는 복수의 메모리 매트를 포함하고, 상기 서브뱅크 로우 디코더와 상기 서브뱅크 컬럼 디코더는 상기 뱅크 컨트롤러로부터 의 읽기 및 쓰기 요청을 처리한다. 다른 실시예들은 복수의 메모리 뱅크를 포함하는 메모리 칩을 포함할 수 있다. 각 메모리 뱅크는 상기 메모리 뱅크 상의 위치로 읽기 및 쓰기를 처리하기 위한 뱅크 컨트롤러를 포함하고, 각 메모리 뱅크는 복수의 메모리 매트를 포함하고, 각 메모리 매트는 복수의 메모리 셀과 매트 로우 디코더와 매트 컬럼 디코더를 포함하고, 상 기 매트 로우 디코더와 상기 매트 컬럼 디코더는 상기 서브뱅크 컨트롤러로부터의 읽기 및 쓰기 요청을 처리한 다. 다른 실시예들은 복수의 메모리 뱅크와 복수의 버스를 포함하는 메모리 칩을 포함할 수 있다. 각 메모리 뱅크는 상기 메모리 뱅크 상의 위치로 읽기와 쓰기가 되도록 하기 위한 뱅크 컨트롤러, 로우 디코더, 및 컬럼 디코더를 포함하고, 상기 복수의 버스는 상기 복수의 뱅크 컨트롤러의 각 컨트롤러를 상기 복수의 뱅크 컨트롤러의 적어 도 하나의 다른 컨트롤러에 연결한다. 본 기재의 일 측면은 메모리 장치에 관한 것이다. 상기 메모리 장치는, 기판; 상기 기판 상에 배치된 복수의 메 모리 뱅크; 상기 기판 상에 배치된 복수의 프라이머리 로직 블록―여기서, 상기 복수의 프라이머리 로직 블록은 각각 상기 복수의 메모리 뱅크의 적어도 하나에 연결됨; 상기 기판 상에 배치된 복수의 리던던트 블록―여기서, 상기 복수의 리던던트 블록은 각각 상기 메모리 뱅크의 적어도 하나에 연결되고, 상기 복수의 리던던트 블록은 각각 상기 복수의 프라이머리 로직 블록의 적어도 하나를 복제함; 및 상기 기판 상에 배치된 복수의 설정 스위 치―여기서, 상기 복수의 설정 스위치는 각각 상기 복수의 프라이머리 로직 블록의 적어도 하나 또는 상기 복수 의 리던던트 블록의 적어도 하나에 연결됨―을 포함한다. 상기 메모리 장치에서, 상기 복수의 프라이머리 로직 블록의 하나와 연관된 오류가 검출되는 경우, 상기 복수의 설정 스위치의 제1 설정 스위치는 상기 복수의 프라 이머리 로직 블록의 상기 하나를 비활성화하도록 구성될 수 있고, 상기 복수의 설정 스위치의 제2 설정 스위치 는 상기 복수의 프라이머리 로직 블록의 상기 하나를 복제하는 상기 복수의 리던던트 블록의 하나를 활성화하도 록 구성될 수 있다. 본 발명의 다른 측면은 메모리 칩 상에 배치된 분산 프로세서에 관한 것이다. 상기 분산 프로세서는, 기판; 상 기 기판 상에 배치된 어드레스 매니저; 상기 기판 상에 배치된 복수의 프라이머리 로직 블록―여기서, 상기 복 수의 프라이머리 로직 블록은 각각 상기 복수의 메모리 뱅크의 적어도 하나에 연결됨; 상기 기판 상에 배치된 복수의 리던던트 블록―여기서, 상기 복수의 리던던트 블록은 각각 상기 복수의 메모리 뱅크의 적어도 하나에 연결되고, 상기 복수의 리던던트 블록은 각각 상기 복수의 프라이머리 로직 블록의 적어도 하나를 복제함; 및 상기 복수의 프라이머리 로직 블록의 각각, 상기 복수의 리던던트 블록의 각각, 및 상기 어드레스 매니저에 연 결된 상기 기판 상에 배치된 버스를 포함한다. 상기 프로세서는 시험 프로토콜에 합격하는 상기 복수의 프라이 머리 로직 블록의 블록에 실행 ID 번호를 배정하고, 상기 시험 프로토콜에 불합격하는 상기 복수의 프라이머리 로직 블록의 블록에 불법 ID 번호를 배정하고, 상기 시험 프로토콜에 합격하는 상기 복수의 리던던트 블록의 블 록에 실행 ID 번호를 배정할 수 있다. 본 기재의 또 다른 측면은 메모리 칩 상에 분산 프로세서를 구성하는 방법에 관한 것이다. 상기 방법은, 상기 메모리 칩의 상기 기판 상의 복수의 프라이머리 로직 블록의 각 프라이머리 로직 블록을 검사하여 적어도 하나 의 회로 기능을 확인하는 단계; 상기 검사의 결과에 의거하여 상기 복수의 프라이머리 로직 블록에서 적어도 하 나의 오류 로직 블록을 식별하는 단계―여기서, 상기 적어도 하나의 오류 로직 블록은 상기 메모리 칩의 상기 기판 상에 배치된 적어도 하나의 메모리 뱅크에 연결됨; 상기 메모리 칩의 상기 기판 상의 적어도 하나의 리던 던트 블록을 검사하여 상기 적어도 하나의 회로 기능을 확인하는 단계―여기서, 상기 적어도 하나의 리던던트 블록은 상기 적어도 하나의 오류 로직 블록을 복제하고 상기 적어도 하나의 메모리 뱅크에 연결됨; 외부 신호를 비활성화 스위치에 인가하여 상기 적어도 하나의 오류 로직 블록을 비활성화 하는 단계―여기서, 상기 비활성화 스위치는 상기 적어도 하나의 오류 로직 블록에 연결되고 상기 메모리 칩의 상기 기판 상에 배치됨; 및 상기 외 부 신호를 활성화 스위치에 인가하여 상기 적어도 하나의 리던던트 블록을 활성화하는 단계―여기서, 상기 활성 화 스위치는 상기 적어도 하나의 리던던트 블록과 연결되고 상기 메모리 칩의 상기 기판 상에 배치됨―를 포함 할 수 있다. 본 기재의 또 다른 측면은 메모리 칩 상에 분산 프로세서를 구성하기 위한 방법에 관한 것이다. 상기 방법은, 상기 메모리 칩의 기판 상의 복수의 프라이머리 로직 블록과 복수의 리던던트 블록을 활성화하는 단계; 상기 메 모리 칩의 상기 기판 상의 상기 복수의 프라이머리 로직 블록의 각 프라이머리 로직 블록을 검사하여 적어도 하 나의 회로 기능을 확인하는 단계; 상기 검사의 결과에 의거하여 상기 복수의 프라이머리 로직 블록에서 적어도 하나의 오류 로직 블록을 식별하는 단계―여기서, 상기 적어도 하나의 오류 로직 블록은 상기 메모리 칩의 상기 기판 상에 배치된 적어도 하나의 메모리 뱅크에 연결됨; 상기 메모리 칩의 상기 기판 상의 적어도 하나의 리던 던트 블록을 검사하여 상기 적어도 하나의 회로 기능을 확인하는 단계―여기서, 상기 적어도 하나의 리던던트블록은 상기 적어도 하나의 오류 로직 블록을 복제하고 상기 적어도 하나의 메모리 뱅크에 연결됨; 및 외부 신 호를 활성화 스위치에 인가하여 적어도 하나의 리던던트 블록을 비활성화 하는 단계―여기서, 상기 활성화 스위 치는 상기 적어도 하나의 리던던트 블록과 연결되고 상기 메모리 칩의 상기 기판 상에 배치됨―를 포함할 수 있 다. 본 기재의 일 측면은 처리 장치에 관한 것이다. 상기 처리 장치는, 기판; 상기 기판 상에 배치된 복수의 메모리 뱅크; 상기 복수의 메모리 뱅크의 각 메모리 뱅크에 연결된 상기 기판 상에 배치된 메모리 컨트롤러; 및 상기 기판 상에 배치된 복수의 처리부―여기서, 상기 복수의 처리부의 각 처리부는 상기 메모리 컨트롤러에 연결되고, 상기 복수의 처리부는 설정 매니저를 포함함―을 포함할 수 있다. 상기 처리 장치에서, 상기 설정 매 니저는, 수행될 작업의 제1 표시를 수신―여기서, 상기 작업은 적어도 하나의 계산이 필요함; 상기 복수의 처리 부에서 선택된 적어도 하나의 처리부에 상기 적어도 하나의 계산을 수행하기 위해 필요한 신호를 상기 선택된 처리부의 역량에 의거하여 송신; 및 제2 표시를 상기 적어도 하나의 선택된 처리부에 전송하도록 구성되고, 상 기 메모리 컨트롤러는 데이터를 적어도 두 개의 메모리 뱅크로부터 상기 적어도 하나의 선택된 처리부로 적어도 하나의 통신선을 활용하여 보내도록 구성되고, 여기서, 상기 적어도 하나의 통신선은 상기 메모리 컨트롤러를 통해 상기 적어도 두 개의 메모리 뱅크 및 상기 적어도 하나의 선택된 처리부에 연결된다. 본 기재의 다른 측면은 분산 메모리 장치의 운용을 위해 수행되는 방법에 관한 것이다. 상기 방법은, 상기 분산 메모리 장치를 위한 작업을 컴파일러가 컴파일하는 단계―여기서, 상기 작업은 적어도 하나의 계산을 필요로 하 고, 상기 컴파일하는 단계는: 상기 작업을 수행하기 위해 동시에 필요한 워드의 수를 판단하는 단계; 및 기판 상에 배치된 복수의 메모리 뱅크의 하나로부터 동시에 접속될 수 있는 워드의 수가 상기 동시에 필요한 워드의 수보다 적은 경우에 동시에 접속되어야 할 워드를 상기 복수의 메모리 뱅크에 쓰기 위한 명령을 제공하는 단계 를 포함함; 상기 작업을 수행하라는 표시를 상기 기판 상에 배치된 설정 매니저가 수신하는 단계; 및 상기 표시 의 수신에 대응하여, 상기 기판에 배치된 메모리 컨트롤러를: 제1 라인 액세스 사이클 이내에서는: 제1 메모리 라인을 활용하여 상기 복수의 메모리 뱅크의 제1 메모리 뱅크로부터의 적어도 하나의 제1 워드에 접속; 상기 적 어도 하나의 제1 워드를 적어도 하나의 처리부로 전송; 및 제2 메모리 뱅크에 제1 메모리 라인을 개통하여 상기 복수의 메모리 뱅크의 상기 제2 메모리 뱅크로부터 제2 어드레스에 접속하고; 제2 라인 액세스 사이클 이내에서 는: 상기 제1 메모리 라인을 활용하여 상기 제2 메모리 뱅크로부터 적어도 하나의 제2 워드에 접속; 상기 적어 도 하나의 제2 워드를 적어도 하나의 처리부로 전송; 및 상기 제1 메모리 뱅크의 제2 메모리 라인을 활용하여 상기 제1 메모리 뱅크로부터 제3 어드레스에 접속하도록 구성하는 단계를 포함할 수 있다. 본 기재의 또 다른 측면은 적어도 하나의 프로세서에 의해 실행되는 경우에 상기 적어도 하나의 프로세서로 하 여금: 작업을 수행하기 위해 동시에 요구되는 워드의 수를 판단―여기서, 상기 작업은 적어도 하나의 계산을 요 구함; 기판 상에 배치된 복수의 메모리 뱅크의 하나로부터 동시에 접속될 수 있는 워드의 수가 상기 동시에 필 요한 워드의 수보다 적은 경우에 동시에 접속되어야 할 워드를 상기 복수의 메모리 뱅크에 기록; 상기 작업을 수행하라는 표시를 상기 기판 상에 배치된 설정 매니저로 전송; 및 상기 기판 상에 배치된 메모리 컨트롤러를: 제1 라인 액세스 사이클 이내에서는: 제1 메모리 라인을 활용하여 상기 복수의 메모리 뱅크의 제1 메모리 뱅크 로부터의 적어도 하나의 제1 워드에 접속; 상기 적어도 하나의 제1 워드를 적어도 하나의 처리부로 전송; 및 제 2 메모리 뱅크에 제1 메모리 라인을 개통하여 상기 복수의 메모리 뱅크의 상기 제2 메모리 뱅크로부터 제2 어드 레스에 접속하도록 설정하고, 제2 라인 액세스 사이클 이내에서는: 상기 제1 메모리 라인을 활용하여 상기 제2 메모리 뱅크로부터 적어도 하나의 제2 워드에 접속; 상기 적어도 하나의 제2 워드를 적어도 하나의 처리부로 전 송; 및 상기 제1 메모리 뱅크의 제2 메모리 라인을 활용하여 상기 제1 메모리 뱅크로부터 제3 어드레스에 접속 하도록 설정하는, 명령을 전송하도록 유발하는, 명령을 저장하는 비일시적 컴퓨터 가독 매체에 관한 것이다. 기타 기재된 실시예들에 따라, 비일시적 컴퓨터 가독 저장 매체는 적어도 하나의 처리 장치에 의해 실행되고 여 기에 기재된 방법 중의 어느 하나 이상을 수행하는 프로그램 명령을 저장할 수 있다. 상기의 설명과 하기의 상세한 설명은 예시에 불과하며 본 기재의 청구 범위에 대한 한정이 아니다."}
{"patent_id": "10-2020-7006169", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "하기의 상세한 설명은 첨부한 도면을 참조한다. 편의상, 도면과 설명에서 동일 또는 유사한 구성요소에 동일한 참조 번호를 사용한다. 여러 예시적인 실시예를 설명하지만, 다양한 변경, 개조, 구현 등이 가능하다. 예를 들 어, 도면에 예시된 구성요소를 치환, 또는 추가, 변경할 수 있고, 설명에 포함된 방법은 단계를 치환하거나 순서를 바꾸거나 삭제하거나 추가하여 변경할 수 있다. 따라서, 하기의 상세한 설명은 기재된 실시예와 예시에 국 한되지 않고, 올바른 청구 범위는 첨부된 청구항에 의해 정의된다. 프로세서 아키텍처 본 기재의 전체를 통해, '하드웨어 칩'이라는 용어는 하나 이상의 회로 소자(예, 트랜지스터, 커패시터, 저항 등)가 형성되는 반도체 웨이퍼(실리콘 등)를 말한다. 회로 소자는 처리 소자(processing elements) 또는 메모리 소자를 형성할 수 있다. '처리 소자'는 적어도 하나의 논리 함수(예, 산술 함수, 논리 게이트, 기타 불리언 (Boolean) 연산 등)을 함께 수행하는 하나 이상의 회로 소자를 말한다. 처리 소자는 범용 처리 소자(예, 설정 가능한 복수의 트랜지스터) 또는 전용 처리 소자(예, 특정 논리 함수를 수행하도록 설계된 특정 논리 게이트 또 는 복수의 회로 소자)일 수 있다. '메모리 소자'는 데이터를 저장하는데 활용될 수 있는 하나 이상의 회로 소자 를 말한다. '메모리 소자'는 또한 '메모리 셀'로 불릴 수도 있다. 메모리 소자는 동적(즉, 데이터 저장을 유지 하기 위해 전기적 리프레쉬가 필요), 정적(즉, 전원이 차단된 이후의 일정 시간 동안 데이터 유지), 또는 비휘 발성 메모리일 수 있다. 처리 소자는 서로 접합되어 프로세서 서브유닛(subunit)을 형성할 수 있다. 이에 따라, '프로세서 서브유닛'은 적어도 하나의 작업 또는 명령(예, 프로세서 명령 세트의 작업 또는 명령)을 실행할 수 있는 최소 묶음의 처리 소자를 포함할 수 있다. 예를 들어, 서브유닛은 명령을 함께 실행하도록 구성된 하나 이상의 범용 처리 소자, 하나 이상의 전용 처리 소자와 쌍을 이루어 서로 보완적인 방식으로 명령을 실행하도록 구성된 하나 이상의 범 용 처리 소자 등을 포함할 수 있다. 프로세서 서브유닛은 기판(예, 웨이퍼) 상에 어레이로 배치될 수 있다. '어 레이'는 직사각형상을 포함할 수 있지만, 서브유닛의 어레이 배치는 기판 상에서 기타 모든 형상으로 형성될 수 있다. 메모리 소자는 서로 접합되어 메모리 뱅크를 형성할 수 있다. 예를 들어, 메모리 뱅크는 적어도 하나의 회선(또 는 기타 전도성 연결)을 따라 연결된 하나 이상의 메모리 소자 라인을 포함할 수 있다. 또한, 메모리 소자는 다 른 방향의 적어도 하나의 추가 회선을 따라 연결될 수 있다. 예를 들어, 메모리 소자는 하기에 설명하는 바와 같이 워드라인(wordline)과 비트라인(bitline)을 따라 배치될 수 있다. 메모리 뱅크가 라인을 포함할 수 있지만, 기타 모든 배치를 활용하여 소자를 기판 내에 배치하여 기판 상에 뱅크를 형성할 수 있다. 또한, 하나 이상의 뱅크가 적어도 하나의 메모리 컨트롤러에 전기적으로 접합되어 메모리 어레이를 형성할 수 있다. 메모리 어레이는 장방형 배치의 뱅크를 포함할 수 있지만, 어레이 내의 뱅크의 배치는 기판 상에서 기타 모든 형상으로 형성될 수 있다. 본 기재의 전체를 통해, '버스(bus)'는 기판의 소자 사이의 모든 통신 연결을 말한다. 예를 들어, 회선 또는 라 인(전기적 연결 형성), 광섬유(광 연결 형성), 또는 구성 부품 사이의 통신을 하는 기타 모든 연결이 '버스'로 지칭될 수 있다. 기존의 프로세서에서는 범용 논리 회로와 공유 메모리가 쌍을 이룬다. 공유 메모리는 논리 회로가 실행할 명령 세트뿐만 아니라 명령 세트의 실행에 활용할 데이터와 명령 세트의 실행의 결과로 획득하는 데이터를 모두 저장 할 수 있다. 하기에 설명하는 바와 같이, 일부 기존 프로세서는 캐싱(caching) 시스템을 활용하여 공유 메모리 로부터의 읽기 지연을 줄이지만, 기존의 캐싱 시스템은 공유 상태를 유지하고 있다. 기존 프로세서는 중앙처리 장치(CPU), 그래픽처리장치(GPU), 다양한 주문형 반도체(ASIC) 등을 포함한다. 도 1은 CPU의 일례를 도시한 것 이고, 도 2는 GPU의 일례를 도시한 것이다. 도 1에 도시된 바와 같이, CPU는 프로세서 서브유닛(120a)과 프로세서 서브유닛(120b)과 같은 하나 이상의 프로세서 서브유닛을 포함하는 처리부를 포함할 수 있다. 도 1에는 도시되어 있지 않지만, 각 프로세서 서 브유닛은 복수의 처리 소자를 포함할 수 있다. 또한, 처리부는 하나 이상의 단계의 온-칩캐시(on-chip cache)를 포함할 수 있다. 이러한 캐시 소자는 프로세서 서브유닛(120a, 120b)과 캐시 소자를 포함하는 기판 내 에 형성된 하나 이상의 버스를 통해 프로세서 서브유닛(120a, 120b)에 연결되기 보다는 대부분 처리부와 동일한 반도체 다이 상에 형성된다. 버스를 통한 연결보다는 동일 다이 상의 직접 배치는 기존 프로세서의 1단 계(L1) 캐시와 2단계(L2) 캐시에 모두 일반적이다. 또는, 구형 프로세서에서, L2 캐시는 프로세서 서브유닛과 L2 캐시 사이의 후면 버스(back-side bus)를 사용하여 프로세서 서브유닛 사이에 공유되었다. 후면 버스는, 하 기에 설명하는 바와 같이, 일반적으로 전면 버스(front-side bus)보다 크다. 이에 따라, 캐시는 다이 상의 모든 프로세서 서브유닛과 공유돼야 하므로, 캐시가 프로세서 서브유닛(120a, 120b)과 동일한 다이 상에 형성되 거나 하나 이상의 후면 버스를 통하여 프로세서 서브유닛(120a, 120b)에 통신 가능하게 결합될 수 있다. 버스가 없는 실시예(예, 캐시가 다이 상에 직접 형성)와 후면 버스를 활용하는 실시예 모두에서, 캐시는 CPU의 프로세서 서브유닛 간에 공유된다. 또한, 처리부는 공유 메모리(140a) 및 공유 메모리(140b)와 통신한다. 예를 들어, 메모리(140a, 140b)는 공유 DRAM(dynamic random access memory)의 메모리 뱅크를 나타내는 것일 수 있다. 도면에는 두 개의 뱅크가 도시 되었지만, 대부분의 기존 메모리 칩은 8개 내지 16개의 메모리 뱅크를 포함한다. 이에 따라, 프로세서 서 브유닛(120a, 120b)은 공유 메모리(140a, 140b)를 활용하여 프로세서 서브유닛(120a, 120b)에 의해 운용될 데이 터를 저장할 수 있다. 그러나, 이러한 구성의 결과로, 처리부의 클럭 속도가 버스의 데이터 전송 속도를 초과하는 경우에, 메모리(140a, 140b)와 처리부 사이의 버스는 병목이 된다. 이는 기존 프로세서에서 일반 적이며, 이에 따라 클럭 속도와 트랜지스터 수에 의거한 처리 속도 사양보다 처리 속도가 떨어지는 결과를 초래 한다. 도 2에 도시된 바와 같이, 유사한 문제가 GPU에도 존재한다. GPU는 하나 이상의 프로세서 서브유닛(예, 프 로세서 서브유닛(220a, 220b, 220c, 220d, 220e, 220f, 220g, 220h, 220i, 220j, 220k, 220l, 220m, 220n, 220o, 220p))을 포함하는 처리부를 포함할 수 있다. 또한, 처리부는 하나 이상의 단계의 온-칩캐시 및/또는 레지스터 파일을 포함할 수 있다. 이러한 캐시 소자는 일반적으로 처리부와 동일한 반도체 다이 상에 형성된다. 실제로, 도 2의 예에서, 캐시는 처리부와 동일한 다이 상에 형성되고 모든 프로세서 서브유닛 사이에서 공유되는 반면, 캐시(230a, 230b, 230c, 230d)는 각각 프로세서 서브세트(subset) 상에 형성 되고 그 전용이 된다. 또한, 처리부는 공유 메모리(250a, 250b, 250c, 250d)와 통신한다. 예를 들어, 메모리(250a, 250b, 250c, 250d)는 공유 DRAM의 메모리 뱅크를 나타내는 것일 수 있다. 이에 따라, 처리부의 프로세서 서브유닛은 공 유 메모리(250a, 250b, 250c, 250d)를 활용하여 프로세서 서브유닛에 의해 이후에 운용되는 데이터를 저장할 수 있다. 그러나 앞서 CPU에 대한 설명과 유사하게, 이러한 배치의 결과로 메모리(250a, 250b, 250c, 250d)와 처리 부 사이의 버스는 병목이 된다. 기재된 하드웨어 칩의 개요 도 3a는 예시적인 하드웨어 칩의 일 실시예를 개략적으로 도시한 것이다. 하드웨어 칩은 앞서 설명한 CPU, GPU, 및 기타 기존 프로세서에 대한 병목을 완화하도록 설계된 분산 프로세서를 포함할 수 있다. 분산 프 로세서는 단일 기판 상에 공간적으로 분산된 복수의 프로세서 서브유닛을 포함할 수 있다. 또한, 앞서 설명한 바와 같이, 본 기재의 분산 프로세서에서, 상응하는 메모리 뱅크도 기판 상에서 공간적으로 분산되어 있다. 일 부 실시예에서, 분산 프로세서는 명령 세트와 연관되어 있고, 분산 프로세서의 프로세서 서브유닛의 각 서브유 닛은 명령 세트에 포함된 하나 이상의 작업의 수행을 담당할 수 있다. 도 3a에 도시된 바와 같이, 하드웨어 칩은 논리 및 제어 서브유닛(320a, 320b, 320c, 320d, 320e, 320f, 320g, 320h)과 같은 복수의 프로세서 서브유닛을 포함할 수 있다. 도 3a에 더 도시된 바와 같이, 각 프로세서 서브유닛은 전용 메모리 인스턴스(memory instance)를 포함할 수 있다. 예컨대, 논리 및 제어 서브유닛(320a)은 전용 메모리 인스턴스(330a)에 작동적으로 연결되고, 논리 및 제어 서브유닛(320b)은 전용 메모리 인스턴스 (330b)에 작동적으로 연결되고, 논리 및 제어 서브유닛(320c)은 전용 메모리 인스턴스(330c)에 작동적으로 연결 되고, 논리 및 제어 서브유닛(320d)은 전용 메모리 인스턴스(330d)에 작동적으로 연결되고, 논리 및 제어 서브 유닛(320e)은 전용 메모리 인스턴스(330e)에 작동적으로 연결되고, 논리 및 제어 서브유닛(320f)은 전용 메모리 인스턴스(330f)에 작동적으로 연결되고, 논리 및 제어 서브유닛(320g)은 전용 메모리 인스턴스(330g)에 작동적 으로 연결되고, 논리 및 제어 서브유닛(320h)은 전용 메모리 인스턴스(330h)에 작동적으로 연결된다. 도 3a에는 각 메모리 인스턴스가 단일 메모리 뱅크인 것으로 도시되어 있지만, 하드웨어 칩은 하드웨어 칩 상의 프로세서 서브유닛에 대한 전용 메모리 인스턴스로 둘 이상의 메모리 뱅크를 포함할 수 있다. 또한, 도 3a에는 각 프로세서 서브유닛이 각 전용 메모리 뱅크에 대해 논리 소자와 제어를 모두 포함하는 것으로 도시 되어 있지만, 하드웨어 칩은 적어도 부분적으로는 논리 소자와 분리된 제어를 메모리 뱅크에 대해 사용할 수도 있다. 또한, 도 3a에 도시된 바와 같이, 둘 이상의 프로세서 서브유닛과 그에 상응하는 메모리 뱅크가 예 를 들어 프로세싱 그룹(310a, 310b, 310c, 310d)으로 합쳐질 수 있다. '프로세싱 그룹'이란 하드웨어 칩이 형성되는 기판 상의 공간적 구분을 나타내는 것일 수 있다. 이에 따라, 프로세싱 그룹은, 예를 들어 제어기 (340a, 340b, 340c, 340d)와 같은, 프로세싱 그룹의 메모리 뱅크에 대한 추가적인 제어를 더 포함할 수 있다. 추가적으로 또는 대안적으로, '프로세싱 그룹'은 하드웨어 칩 상에서 실행할 코드의 컴파일을 위한 논리 묶음을 나타내는 것일 수 있다. 이에 따라, 하드웨어 칩에 대한 컴파일러(하기에 설명)가 전반적인 명령 세트를 하드웨어 칩 상의 프로세싱 그룹 간에 분리할 수 있다. 또한, 호스트가 하드웨어 칩으로 명령, 데이터, 및 기타 입력을 제공하고 하드웨어 칩으로부터 출력을 읽을 수 있다. 이에 따라, 명령 세트 전체가 단일 다이, 예를 들어 하드웨어 칩을 호스트하는 다이 상에서 실행될 수 있다. 실제로, 다이 밖에서의 통신은 하드웨어 칩으로의 명령 로딩, 하드웨어 칩으 로의 입력 전송, 및 하드웨어 칩으로부터의 출력 읽기가 전부일 수 있다. 이에 따라, 하드웨어 칩의 프로세서 서브유닛은 하드웨어 칩의 전용 메모리 뱅크와 통신하므로, 모든 계산과 메모리 연산은 다이 상 (하드웨어 칩 상)에서 수행될 수 있다. 도 3b는 다른 예시적인 하드웨어 칩(300')의 실시예를 개략적으로 도시한 것이다. 하드웨어 칩의 대안으로 도시되었지만, 도 3b에 도시된 아키텍처는 적어도 부분적으로는 도 3a에 도시된 아키텍처와 병합될 수 있다. 도 3b에 도시된 바와 같이, 하드웨어 칩(300')은 프로세서 서브유닛(350a, 350b, 350c, 350d)과 같은 복수의 프 로세서 서브유닛을 포함할 수 있다. 도 3b에 더 도시된 바와 같이, 각 프로세서 서브유닛은 복수의 전용 메모리 인스턴스를 포함할 수 있다. 예컨대, 프로세서 서브유닛(350a)은 전용 메모리 인스턴스(330a, 330b)에 연결되고, 프로세서 서브유닛(350b)은 전용 메모리 인스턴스(330c, 330d)에 연결되고, 프로세서 서브유닛(350 c)은 전용 메모리 인스턴스(330e, 330f)에 연결되고, 프로세서 서브유닛(350d)은 전용 메모리 인스턴스(330g, 330h)에 연결된다. 또한, 도 3b에 도시된 바와 같이, 프로세서 서브유닛과 그에 상응하는 메모리 뱅크는 예를 들어 프로세싱 그룹(310a, 310b, 310c, 310d)으로 합쳐질 수 있다. 앞서 설명한 바와 같이, '프로세싱 그룹'이 란 하드웨어 칩(300')이 형성되는 기판 상의 공간적 구분 및/또는 하드웨어 칩(300') 상에서 실행할 코드의 컴 파일을 위한 논리 묶음을 나타내는 것일 수 있다. 도 3b에 더 도시된 바와 같이, 프로세서 서브유닛은 버스를 통하여 서로 통신할 수 있다. 예를 들어, 도 3b에 도시된 바와 같이, 프로세서 서브유닛(350a)은 버스(360a)를 통하여 프로세서 서브유닛(350b)과 통신하고, 버스 (360c)를 통하여 프로세서 서브유닛(350c)과 통신하고, 버스(360f)를 통하여 프로세서 서브유닛(350d)과 통신할 수 있다. 마찬가지로, 프로세서 서브유닛(350b)은 버스(360a)를 통하여 프로세서 서브유닛(350a)과 통신하고(상 기에 설명), 버스(360e)를 통하여 프로세서 서브유닛(350c)과 통신하고(상기에 설명), 버스(360d)를 통하여 프 로세서 서브유닛(350d)과 통신할 수 있다. 또한, 프로세서 서브유닛(350c)은 버스(360c)를 통하여 프로세서 서 브유닛(350a)과 통신하고(상기에 설명), 버스(360e)를 통하여 프로세서 서브유닛(350b)과 통신하고(상기에 설명), 버스(360b)를 통하여 프로세서 서브유닛(350d)과 통신할 수 있다. 이에 따라, 프로세서 서브유닛(350d) 은 버스(360f)를 통하여 프로세서 서브유닛(350a)과 통신하고(상기에 설명), 버스(360d)를 통하여 프로세서 서 브유닛(350b)과 통신하고(상기에 설명), 버스(360b)를 통하여 프로세서 서브유닛(350c)과 통신할 수 있다(상기 에 설명). 본 기재의 당업자라면, 도 3b에 도시된 것보다 적은 수의 버스가 사용될 수 있음을 이해할 것이다. 예를 들어, 프로세서 서브유닛(350b)과 프로세서 서브유닛(350c) 사이의 통신이 프로세서 서브유닛(350a) 및/또 는 프로세서 서브유닛(350d)을 통하여 이루어지도록 버스(360e)가 제거될 수 있다. 마찬가지로, 프로세서 서브 유닛(350a)과 프로세서 서브유닛(350d) 사이의 통신이 프로세서 서브유닛(350b) 또는 프로세서 서브유닛(350c) 을 통하여 이루어지도록 버스(360f)가 제거될 수 있다. 또한, 본 기재의 당업자라면, 도 3a와 도 3b에 도시된 것과 다른 아키텍처가 활용될 수 있음을 이해할 것이다. 예를 들어, 각각 단일 프로세서 서브유닛과 메모리 인스턴스를 포함하는 프로세싱 그룹의 어레이가 기판 상에 배치될 수 있다. 프로세서 서브유닛은 상응하는 전용 메모리 뱅크에 대한 컨트롤러의 일부, 상응하는 전용 메모 리 매트(memory mat)에 대한 컨트롤러의 일부 등을 추가적으로 또는 대안적으로 형성할 수 있다. 상기 설명한 아키텍처에 따라, 하드웨어 칩(300, 300')은 메모리 집약적 작업에 대해 기존의 아키텍처에 비해 상당히 증가된 효율을 제공할 수 있다. 예를 들어, 데이터베이스 연산 및 인공지능 알고리즘(예, 신경망)은 기 존의 아키텍처가 하드웨어 칩(300, 300')보다 효율성이 떨어지는 메모리 집약적 작업의 예이다. 이에 따라, 하 드웨어 칩(300, 300')은 데이터베이스 가속기 프로세서 및/또는 인공지능 가속기 프로세서로 불릴 수 있다. 기재된 하드웨어 칩의 설정 상기에 설명한 하드웨어 칩 아키텍처는 코드의 실행을 위해 구성될 수 있다. 예를 들어, 각 프로세서 서브유닛 은 하드웨어 칩 내의 다른 프로세서 서브유닛과 별개로 개별적으로 코드(명령 세트를 정의)를 실행할 수 있다. 이에 따라, 멀티스레딩(multithreading)을 관리하기 위하여 운영체제에 의존하거나 멀티태스킹(병렬성보다는 동 시성)을 활용하기보다, 본 기재의 하드웨어 칩은 프로세서 서브유닛이 완전히 병렬로 동작하게 할 수 있다. 앞서 설명한 완전 병렬 구현 외에도, 각 프로세서 서브유닛에 배정된 명령의 적어도 일부는 중첩할 수 있다. 예 를 들어, 분산 프로세서 상에 배치된 복수의 프로세서 서브유닛은 운영체제 또는 기타 관리 소프트웨어의 구현등으로서 중복 명령을 실행할 수 있는 반면에, 운영체제 또는 기타 관리 소프트웨어의 컨텍스트(context) 내에 서 병렬 작업을 수행하기 위하여 비중복(non-overlapping) 명령을 실행할 수 있다. 도 4는 프로세싱 그룹으로 일반적인 명령을 실행하는 예시적인 프로세스를 도시한 것이다. 예컨대, 프로세싱 그룹은 본 기재의 하드웨어 칩의 일부를 포함할 수 있다(하드웨어 칩, 하드웨어 칩(300') 등). 도 4에 도시된 바와 같이, 전용 메모리 인스턴스와 쌍을 이룬 프로세서 서브유닛으로 명령(command) 이 전송될 수 있다. 외부 호스트(예, 호스트)가 실행을 위해 명령을 프로세싱 그룹으로 전송할 수 있 다. 또는, 프로세서 서브유닛이 메모리 인스턴스로부터 명령을 가져오고 가져온 명령을 실행할 수 있 도록, 호스트가 상기 명령을 포함하는 명령 세트를 전송하여 메모리 인스턴스에 저장할 수 있다. 이 에 따라, 가져온 명령을 실행하게 구성될 수 있는 일반적인 처리 소자인 처리 소자에 의해 명령이 실행될 수 있다. 또한, 프로세싱 그룹은 메모리 인스턴스에 대한 컨트롤을 포함할 수 있다. 도 4에 도 시된 바와 같이, 컨트롤은 수신된 명령을 실행할 때 처리 소자에 의해 요구되는 메모리 인스턴스 로의 읽기 및/또는 쓰기를 수행할 수 있다. 명령의 실행 후, 프로세싱 그룹은 명령의 결과를 외부 호 스트로 또는 동일 하드웨어 칩 상의 다른 프로세싱 그룹 등으로 출력할 수 있다. 일부 실시예에서, 도 4에 도시된 바와 같이, 프로세서 서브유닛은 어드레스 생성기를 더 포함할 수 있다. '어드레스 생성기'는 읽기와 쓰기를 수행하기 위한 하나 이상의 메모리 뱅크의 주소를 판단하도록 구성된 복수의 처리 소자를 포함할 수 있고, 또한 판단된 주소에 위치한 데이터에 연산(예, 덧셈, 뺄셈, 곱셈 등)을 수 행할 수 있다. 예를 들어, 어드레스 생성기는 메모리로의 읽기 또는 쓰기를 위한 주소를 판단할 수 있다. 일 실시예에서, 어드레스 생성기는 읽기값이 더 이상 필요하지 않은 경우에 명령에 의거하여 판단된 새로 운 값으로 읽기값을 덮어씀으로써 효율을 향상할 수 있다. 추가적으로 또는 대안적으로, 어드레스 생성기 는 명령 실행의 결과를 저장할 사용 가능한 주소를 선택할 수 있다. 이로써, 외부 호스트에게 더 편리한 나중의 클럭 사이클에 대한 결과 읽기를 스케줄 할 수 있게 된다. 다른 예에서, 어드레스 생성기는 벡터 또는 행 렬 곱셈-누적(multiply-accumulate) 계산과 같은 멀티사이클 계산 동안에 읽기 및 쓰기를 할 주소를 판단할 수 있다. 이에 따라, 어드레스 생성기는 데이터를 읽고 멀티사이클 계산의 중간 결과를 쓰기 위한 메모리 주 소를 유지 또는 계산하여, 프로세서 서브유닛이 이러한 메모리 주소를 저장할 필요 없이 계속 처리할 수 있도록 할 수 있다. 도 5는 프로세싱 그룹으로 특수 명령을 실행하기 위한 예시적인 프로세스를 도시한 것이다. 예를 들 어, 프로세싱 그룹은 본 기재의 하드웨어 칩의 일부를 포함할 수 있다(하드웨어 칩, 하드웨어 칩 (300') 등). 도 5에 도시된 바와 같이, 전용 메모리 인스턴스와 쌍을 이룬 처리 소자로 특수 명령(예, 곱셈-누적 명령)이 전송될 수 있다. 외부 호스트(예, 호스트)가 실행을 위해 명령을 처리 소자로 전송할 수 있 다. 이에 따라, 특정 명령(수신된 명령 포함)을 실행하도록 구성된 특수 처리 소자인 처리 소자에 의해 명 령이 호스트로부터의 특정 신호에 실행될 수 있다. 또는, 처리 소자는 실행을 위해 메모리 인스턴스 로부터 명령을 가져올 수 있다. 따라서, 도 5의 예에서, 처리 소자는 외부 호스트로부터 수신된 또는 메모 리 인스턴스로부터 가져온 MAC(multiply-accumulate) 명령을 실행하도록 구성된 MAC 회로이다. 명령을 실 행한 후, 프로세싱 그룹은 명령의 결과를 외부 호스트 또는 동일 하드웨어 칩의 다른 프로세싱 그룹 등으 로 출력할 수 있다. 도면에는 단일 명령과 단일 결과만을 도시하였지만, 복수의 명령이 수신, 검색, 및 실행될 수 있고, 복수의 결과가 출력 이전에 프로세싱 그룹 상에서 병합될 수 있다. 도 5에는 MAC 회로로 도시되었지만, 프로세싱 그룹에는 추가적인 또는 대안적인 특수 회로가 포함될 수 있다. 예를 들어, MAX-읽기 명령(벡터의 최대값 출력), MAX0-읽기 명령(전체 벡터를 출력하지만 0으로 MAX 하는 정류 기(rectifier)로 불리는 기능) 등이 구현될 수 있다. 도 4의 일반적인 프로세싱 그룹과 도 5의 특수 프로세싱 그룹이 별도의 것으로 도시되어 있지만, 이 들은 병합될 수 있다. 예를 들어, 일반적인 프로세서 서브유닛이 하나 이상의 특수 프로세서 서브유닛과 결합되 어 프로세서 서브유닛을 형성할 수 있다. 이에 따라, 일반적인 프로세서 서브유닛은 하나 이상의 특수 프로세서 서브유닛에 의해 실행 가능하지 않은 모든 명령에 대해 활용될 수 있다. 본 기재의 당업자라면, 신경망 구현과 기타 메모리 집약적 작업이 특수 논리 회로에 의해 처리될 수 있음을 이 해할 것이다. 예를 들어, 데이터베이스 쿼리, 패킷 검사, 스트링 비교, 및 기타 기능은 여기에 기재된 하드웨어칩에 의해 실행되는 경우에 효율이 향상될 수 있다. 분산 처리에 대한 메모리 기반 아키텍처 본 기재에 따른 하드웨어 칩 상에서, 전용 버스는 칩 상의 프로세서 서브유닛 사이 및/또는 프로세서 서브유닛 과 그에 상응하는 전용 메모리 뱅크 사이에 데이터를 전송할 수 있다. 전용 버스를 사용하면 상충하는 요구가 불가능하거나 하드웨어가 아닌 소프트웨어를 사용하여 쉽게 회피될 수 있기 때문에 중재 비용을 줄일 수 있다. 도 6은 프로세싱 그룹을 개략적으로 도시한 것이다. 프로세싱 그룹은 하드웨어 칩, 하드웨어 칩 (300') 등과 같은 하드웨어 칩에서 사용하기 위한 것일 수 있다. 프로세서 서브유닛은 버스를 통해 메모리에 연결될 수 있다. 메모리는 프로세서 서브유닛에 의한 실행을 위한 데이터 및 코드를 저장하는 RAM 소자를 포함할 수 있다. 일부 실시예에서, 메모리는 N-웨이 메모리일 수 있다(여기서, N은 인터리브(interleaved) 메모리 내의 세그먼트의 수를 의미하는 1 이상의 수). 프로세서 서브유닛은 버스를 통해 프로세서 서브유닛 전용의 메모리에 결합되므로, N은 실행 성능의 손실 없이도 상 대적으로 낮은 수로 유지될 수 있을 것이다. 이는, N이 작으면 실행 성능이 떨어지고 N이 높으면 면적과 파워 손실이 큰 기존의 멀티웨이 레지스터 파일 또는 캐시에 비한 향상을 의미한다. 프로세싱 그룹을 사용하는 시스템의 작업 및 어플리케이션 구현의 요구조건에 맞도록 작업에 연관된 데이 터의 사이즈 등에 따라 메모리의 사이즈, N-웨이의 N의 수, 및 버스의 폭이 조절될 수 있다. 메모리 소자는, 예를 들어, 휘발성 메모리(RAM, DRAM, SRAM, 상변화 RAM (phase-change RAM 또는 PRAM), 강자성 RAM(magnetoresistive RAM 또는 MRAM), 저항성 RAM(resistive RAM 또는 ReRAM) 등) 또는 비휘발성 메모리(플 래시메모리 또는 ROM)와 같은, 본 기술 분야에 알려진 하나 이상의 메모리 유형을 포함할 수 있다. 일부 실시예 에 따라, 메모리 소자의 일부분은 제1 메모리 유형을 포함하고, 다른 부분은 다른 메모리 유형을 포함할 수 있다. 예를 들어, 메모리 소자의 코드 영역은 ROM 소자를 포함하고, 메모리 소자의 데이터 영역은 DRAM 소자를 포함할 수 있다. 이러한 분할의 다른 예로서, 신경망의 무게는 플래시메모리에 저장하는 반면, 계 산을 위한 데이터는 DRAM에 저장할 수 있다. 프로세서 서브유닛은 프로세서를 포함할 수 있는 처리 소자를 포함한다. 프로세서는, 당업자라면 이"}
{"patent_id": "10-2020-7006169", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "해하듯이, 파이프라인 되거나 되지 않을 수 있고, 본 기술분야에 알려진 모든 시중의 집적회로(예, ARM, ARC, RISC-V 등) 상에 구현된 맞춤형 RISC(Reduced Instruction Set Computing) 소자 또는 기타 처리 스키마일 수 있다. 처리 소자는 일부 실시예에서 ALU(Arithmetic Logic Unit) 또는 기타 컨트롤러를 포함하는 컨트롤러 를 포함할 수 있다. 일부 실시예에 따라, 수신 또는 저장된 코드를 실행하는 처리 소자는 일반적인 처리 소자를 포함할 수 있 으므로 매우 다양한 처리 연산의 수행이 유연하고 가능하다. 특정 연산의 수행 동안에 소비하는 전력을 비교할 때, 전용이 아닌 회로는 특정 연산 전용 회로보다 많은 전력을 소비한다. 따라서, 특정 복잡 산술 계산을 수행 할 경우, 처리 소자는 전용 하드웨어보다 많은 전력을 소비하고 효율이 떨어질 수 있다. 따라서, 일부 실 시예에 따라, 처리 소자의 컨트롤러는 특정 연산(예, 합산 또는 '이동' 연산)을 수행하도록 설계될 수 있 다. 일례에서, 특정 연산은 하나 이상의 가속기에 의해 수행될 수 있다. 각 가속기는 특정 계산(예, 곱셈, 부 동 소수점 벡터 연산 등)의 수행의 전용으로 프로그램될 수 있다. 가속기를 사용함으로써, 프로세서 서브유닛 당 계산 별로 소비하는 평균 전력이 감소될 수 있고, 향후 계산 처리량이 증가한다. 가속기는 시스템이 구 현(예, 신경망의 실행, 데이터베이스 쿼리(database queries)의 실행 등)하도록 설계된 어플리케이션에 따라 선 택될 수 있다. 가속기(Accelerator, 650)는 처리 소자에 의해 설정될 수 있고, 전력 소비의 감소와 계산의 가속을 위해 처리 소자와 협력하여 작동할 수 있다. 스마트 DMA(direct memory access) 주변기기와 같이, 가속기는 프로세싱 그룹의 메모리와 MUX/DEMUX/입력/출력 포트(예, MUX, DEMUX) 사이에 데이터 를 전송하기 위해 추가적으로 또는 대안적으로 사용될 수 있다. 가속기는 다양한 기능을 수행하도록 구성될 수 있다. 예를 들어, 어떤 가속기는 신경망에서 자주 사용되는 16비트 부동 소수점 계산 또는 8비트 정수 계산을 수행하도록 구성될 수 있다. 가속기 기능의 다른 예는 신경망 의 학습 단계에서 자주 사용되는 32비트 부동 소수점 계산이다. 가속기 기능의 또 다른 예는 데이터베이스에서 사용되는 것과 같은 쿼리 처리이다. 일부 실시예에서, 가속기는 이러한 기능을 수행하기 위해 특화된 처리 소자를 포함할 수 있고/있거나 메모리 소자에 저장된 설정 데이터에 따라 설정되어 수정이 가능하도록 할 수 있다. 가속기는 메모리로의/로부터의 또는 기타 가속기 및/또는 입력/출력으로의/으로부터의 데이터의 설정 가능한 기재된 목록의 메모리 이동에서 타임 이동을 추가적으로 또는 대안적으로 구현할 수 있다. 이에 따라, 하기에 더 설명하는 바와 같이, 프로세싱 그룹을 사용하는 하드웨어 칩 내부의 모든 데이터 이동은 하드웨 어 동기화보다는 소프트웨어 동기화를 이용할 수 있다. 예를 들어, 한 프로세싱 그룹(예, 600)의 가속기는 10번 째 사이클마다 데이터를 입력에서 가속기로 전송한 후에 다음 사이클에서 데이터를 출력하여 프로세싱 그룹의 메모리로부터 다른 프로세싱 그룹으로 정보가 이동하게 할 수 있다. 도 6에 더 도시된 바와 같이, 일부 실시예에서, 프로세싱 그룹은 입력 포트에 연결된 적어도 하나의 입력 멀티플렉서(MUX)와 출력 포트에 연결된 적어도 하나의 출력 디멀티플렉서(DEMUX)를 더 포함할 수 있 다. 이러한 MUX/DEMUX는 처리 소자 및/도는 가속기 중의 하나로부터의 제어 신호(미도시)에 의해 제 어되고, 처리 소자에 의해 수행되는 현 지시 및/또는 가속기 중의 한 가속기에 의해 실행되는 연산에 따라 판단될 수 있다. 일부의 경우, 프로세싱 그룹은 (코드 메모리로부터의 미리 정해진 명령에 따라) 입 력 포트로부터 출력 포트로 데이터를 전송하도록 요구될 수 있다. 이에 따라, MUX/DEMUX의 각각이 처리 소자 와 가속기에 연결될 뿐만 아니라, 입력 MUX의 하나 이상(예, MUX)이 하나 이상의 버스를 통해 출력 DEMUX(예, DEMUX)로 직접 연결될 수 있다. 도 6의 프로세싱 그룹은 배열되어 도 7a에 도시된 것 등과 같은 분산 프로세서를 형성할 수 있다. 프로세 싱 그룹은 기판에 배치되어 어레이를 형성할 수 있다. 일부 실시예에서, 기판은 실리콘과 같은 반도 체 기판을 포함할 수 있다. 추가적으로 또는 대안적으로, 기판은 연성회로기판과 같은 회로기판을 포함할 수 있다. 도 7a에 도시된 바와 같이, 기판은, 프로세싱 그룹과 같은, 그 위에 배치된 복수의 프로세싱 그룹을 포함할 수 있다. 이에 따라, 기판은 뱅크(720a, 720b, 720c, 720d, 720e, 720f, 720g, 720h)와 같은 복수 의 메모리 뱅크를 포함하는 메모리 어레이를 포함한다. 또한, 기판은 서브유닛(730a, 730b, 730c, 730d, 730e, 730f, 730g, 730h)과 같은 복수의 프로세서 서브유닛을 포함할 수 있는 프로세싱 어레이를 포함한다. 또한, 앞서 설명한 바와 같이, 각 프로세싱 그룹은 프로세서 서브유닛과 이 서브유닛 전용의 하나 이상의 상응 하는 메모리 뱅크를 포함할 수 있다. 이에 따라, 도 7a에 도시된 바와 같이, 각 서브유닛은 상응하는 전용 메모 리 뱅크와 연관된다. 예를 들어, 프로세서 서브유닛(730a)은 메모리 뱅크(720a)와 연관되고, 프로세서 서브유닛 (730b)은 메모리 뱅크(720b)와 연관되고, 프로세서 서브유닛(730c)은 메모리 뱅크(720c)와 연관되고, 프로세서 서브유닛(730d)은 메모리 뱅크(720d)와 연관되고, 프로세서 서브유닛(730e)은 메모리 뱅크(720e)와 연관되고, 프로세서 서브유닛(730f)은 메모리 뱅크(720f)와 연관되고, 프로세서 서브유닛(730g)은 메모리 뱅크(720g)와 연 관되고, 프로세서 서브유닛(730h)은 메모리 뱅크(720h)와 연관된다. 각 프로세서 서브유닛이 상응하는 전용 메모리 뱅크와 통신하도록 하기 위하여, 기판은 프로세서 서브유닛 중의 하나를 그에 상응하는 전용 메모리 뱅크로 연결하는 제1 복수의 버스를 포함할 수 있다. 이에 따라, 버스 (740a)는 프로세서 서브유닛(730a)을 메모리 뱅크(720a)로 연결하고, 버스(740b)는 프로세서 서브유닛(730b)을 메모리 뱅크(720b)로 연결하고, 버스(740c)는 프로세서 서브유닛(730c)을 메모리 뱅크(720c)로 연결하고, 버스 (740d)는 프로세서 서브유닛(730d)을 메모리 뱅크(720d)로 연결하고, 버스(740e)는 프로세서 서브유닛(730e)을 메모리 뱅크(720e)로 연결하고, 버스(740f)는 프로세서서브유닛(730f)을 메모리 뱅크(720f)로 연결하고, 버스 (740g)는 프로세서 서브유닛(730g)을 메모리 뱅크(720g)로 연결하고, 버스(740h)는 프로세서 서브유닛(730h)을 메모리 뱅크(720h)로 연결한다. 또한, 각 프로세서 서브유닛이 다른 프로세서 서브유닛과 통신하도록 하기 위하 여, 기판은 프로세서 서브유닛 중의 하나를 프로세서 서브유닛 중의 다른 하나로 연결하는 제2 복수의 버 스를 포함할 수 있다. 도 7a의 예에서, 버스(750a)는 프로세서 서브유닛(730a)을 프로세서 서브유닛(750e)으로 연결하고, 버스(750b)는 프로세서 서브유닛(730a)을 프로세서 서브유닛(750b)으로 연결하고, 버스(750c)는 프로 세서 서브유닛(730b)을 프로세서 서브유닛(750f)으로 연결하고, 버스(750d)는 프로세서 서브유닛(730b)을 프로 세서 서브유닛(750c)으로 연결하고, 버스(750e)는 프로세서 서브유닛(730c)을 프로세서 서브유닛(750g)으로 연 결하고, 버스(750f)는 프로세서 서브유닛(730c)을 프로세서 서브유닛(750d)으로 연결하고, 버스(750g)는 프로세 서 서브유닛(730d)을 프로세서 서브유닛(750h)으로 연결하고, 버스(750h)는 프로세서 서브유닛(730h)을 프로세 서 서브유닛(750g)으로 연결하고, 버스(750i)는 프로세서 서브유닛(730g)을 프로세서 서브유닛(750g)으로 연결 하고, 버스(750j)는 프로세서 서브유닛(730f)을 프로세서 서브유닛(750e)으로 연결한다. 이에 따라, 도 7a에 도시된 예시적인 배치에서, 복수의 논리 프로세서 서브유닛은 적어도 하나의 행과 적어도 하나의 열로 배치된다. 제2 복수의 버스는 각 프로세서 서브유닛을 동일한 행의 적어도 하나의 인접 프로세서서브유닛과 동일한 열의 적어도 하나의 인접 프로세서 서브유닛으로 연결한다. 도 7a는 '부분 타일 연결 (partial tile connection)'로 일컬을 수 있다. 도 7a에 도시된 배치는 수정되어 '완전 타일 연결(full tile connection)'을 형성할 수 있다. 완전 타일 연결은 대각선의 프로세서 서브유닛을 연결하는 추가적인 버스를 포함한다. 예를 들어, 제2 복수의 버스는 프로세서 서 브유닛(730a)과 프로세서 서브유닛(730f) 사이, 프로세서 서브유닛(730b)과 프로세서 서브유닛(730e) 사이, 프 로세서 서브유닛(730b)과 프로세서 서브유닛(730g) 사이, 프로세서 서브유닛(730c)과 프로세서 서브유닛(730f) 사이, 프로세서 서브유닛(730c)과 프로세서 서브유닛(730h) 사이, 및 프로세서 서브유닛(730d)과 프로세서 서브 유닛(730g) 사이에 추가적인 버스를 포함할 수 있다. 완전 타일 연결은, 근처의 프로세서 서브유닛에 저장된 데이터와 결과를 활용하는, 컨볼루션(convolution) 계산 에 이용될 수 있다. 예를 들어, 컨볼루션 이미지 처리 중에, 각 프로세서 서브유닛은 이미지 타일(예, 한 픽셀 또는 픽셀 그룹)을 수신할 수 있다. 컨볼루션 결과를 계산하기 위하여, 각 프로세서 서브유닛은 각각 상응하는 타일을 수신한 8개의 인접 프로세서 서브유닛으로부터 데이터를 확보할 수 있다. 부분 타일 연결에서는, 대각선 으로 인접한 프로세서 서브유닛으로부터의 데이터는 해당 프로세서 서브유닛에 연결된 다른 인접 프로세서 서브 유닛을 통해 통과될 수 있다. 이에 따라, 칩 상의 분산 프로세서는 인공지능 가속기 프로세서일 수 있다. 컨볼루션 계산의 구체적인 예에서, N x M 이미지가 복수의 프로세서 서브유닛에 걸쳐 분할될 수 있다. 각 프로 세서 서브유닛은 상응하는 타일에 대해 A x B 필터로 컨볼루션을 수행할 수 있다. 타일 사이의 경계 상의 하나 이상의 픽셀에 대한 필터링을 수행하기 위하여, 각 프로세서 서브유닛은 동일한 경계 상의 픽셀을 포함하는 타 일을 가진 이웃 프로세서 서브유닛으로부터 데이터를 요구할 수 있다. 이에 따라, 각 프로세서 서브유닛에 대해 생성된 코드는 해당 서브유닛이 컨볼루션을 계산하고 인접 서브유닛으로부터 데이터가 필요할 때마다 제2 복수 의 버스 중의 하나로부터 당겨오도록 설정한다. 제2 복수의 버스로 데이터를 출력하기 위한 상응하는 명령이 해 당 서브유닛으로 제공되어 필요한 데이터 전송의 타이밍이 적절하도록 한다. 도 7a의 부분 타일 연결은 N-부분 타일 연결이 되도록 수정될 수 있다. 이러한 수정에서, 제2 복수의 버스는 각 프로세서 서브유닛을 도 7a의 버스가 지나가는 4방향(즉, 상, 하, 좌, 우 방향)의 해당 프로세서 서브유닛의 임 계 거리 이내(예, n 프로세서 서브유닛 이내)에 있는 프로세서 서브유닛으로 더 연결할 수 있다. 완전 타일 연 결에도 유사한 수정이 이루어져(즉, 결과적으로 N-완전 타일 연결이 되어) 제2 복수의 버스가 각 프로세서 서브 유닛을 도 7a의 버스가 지나가는 4방향과 대각선 2 방향의 해당 프로세서 서브유닛의 임계 거리 이내(예, n 프 로세서 서브유닛 이내)에 있는 프로세서 서브유닛으로 더 연결하도록 할 수 있다. 다른 배치도 가능하다. 예를 들어, 도 7b에 도시된 배치에서, 버스(750a)는 프로세서 서브유닛(730a)을 프로세 서 서브유닛(730d)으로 연결하고, 버스(750b)는 프로세서 서브유닛(730a)을 프로세서 서브유닛(730b)으로 연결 하고, 버스(750c)는 프로세서 서브유닛(730b)을 프로세서 서브유닛(730c)으로 연결하고, 버스(750d)는 프로세서 서브유닛(730c)을 프로세서 서브유닛(730d)으로 연결한다. 이에 따라, 도 7b에 도시된 예에서, 복수의 프로세서 서브유닛은 별 무늬로 배치된다. 제2 복수의 버스는 각 프로세서 서브유닛을 별 무늬 이내의 적어도 하나의 인 접 프로세서 서브유닛으로 연결한다. 추가적인 배치(미도시)도 가능하다. 예를 들면, 복수의 프로세서 서브유닛이 하나 이상의 선에 배치되도록(도 7a에 도시된 배치와 유사) 하는 이웃 연결 배치가 사용될 수 있다. 이웃 연결 배치에서, 제2 복수의 버스는 각 프로세서 서브유닛을 동일 선 상의 좌측에 있는 프로세서 서브유닛, 동일 선 상의 우측에 있는 프로세서 서브유 닛, 동일 선 상의 좌우측 모두에 있는 프로세서 서브유닛 등에 연결한다. 다른 예에서, N-선형 연결 배치가 사용될 수 있다. N-선형 연결 배치에서, 제2 복수의 버스는 각 프로세서 서브 유닛을 해당 프로세서 서브유닛의 임계 거리 이내(예, n 프로세서 서브유닛 이내)에 있는 프로세서 서브유닛에 연결한다. N-선형 연결 배치는 라인 어레이(상기 설명 참조), 장방형 어레이(도 7a에 도시), 타원형 어레이(도 7b에 도시), 또는 기타 기하 어레이와 함께 사용될 수 있다. 또 다른 예에서, N-로그 연결 배치가 사용될 수 있다. N-로그 연결 배치에서, 제2 복수의 버스는 각 프로세서 서브유닛을 해당 프로세서 서브유닛의 2의 거듭제곱 임계 거리 이내(예, 2n 프로세서 서브 유닛 이내)에 있는 프 로세서 서브유닛에 연결한다. N-로그 연결 배치는 라인 어레이(상기 설명 참조), 장방형 어레이(도 7a에 도시), 타원형 어레이(도 7b에 도시), 또는 기타 기하학적 구조의 어레이와 함께 사용될 수 있다. 상기에 설명한 연결 스키마의 어느 것이라도 서로 병합하여 동일 하드웨어 칩 상에서 사용될 수 있다. 예를 들 어, 완전 타일 연결이 한 영역에서 사용되고, 부분 타일 연결이 다른 영역에서 사용될 수 있다. 다른 예를들면, N-선형 연결 배치가 한 영역에서 사용되고, N-완전 타일 연결이 다른 영역에서 사용될 수 있다. 메모리 칩의 프로세서 서브유닛 사이의 전용 버스에 대안적으로 또는 추가적으로, 하나 이상의 공유 버스를 사 용하여 분산 프로세서의 모든 프로세서 서브유닛(또는 모든 프로세서 서브유닛의 서브세트)을 서로 연결할 수 있다. 공유 버스 상의 충돌은 프로세서 서브유닛에 의해 실행되는 코드를 활용하여 공유 버스 상의 데이터 전송 타이밍을 조정함으로써 방지될 수 있으며, 이에 대하여는 하기에 설명한다. 공유 버스에 추가적으로 또는 대안 적으로, 설정형 버스(configurable bus)를 사용하여 프로세서 서브유닛을 동적으로 연결하여 서로 분리된 버스 로 연결되는 프로세서 서브유닛 그룹을 형성할 수 있다. 예를 들어, 설정형 버스는 프로세서 서브유닛에 의해 제어되어 데이터를 선택된 프로세서 서브유닛으로 전송할 수 있는 트랜지스터 또는 기타 메커니즘을 포함할 수 있다. 도 7a와 도 7b에서, 프로세싱 어레이의 복수의 프로세서 서브유닛은 메모리 어레이의 복수의 이산 메모리 뱅크 사이에 공간적으로 분포된다. 다른 대안적인 실시예(미도시)에서, 복수의 프로세서 서브유닛은 기판의 하나 이 상의 영역에서 클러스터링 될 수 있고, 목수의 메모리 뱅크는 기판의 하나 이상의 다른 영역에서 클러스터링 될 수 있다. 일부 실시예에서, 공간적 분포와 클러스터링의 조합(미도시)이 사용될 수 있다. 예를 들어, 기판의 일 영역은 프로세서 서브유닛의 클러스터를 포함하고, 기판의 다른 영역은 메모리 뱅크의 클러스터를 포함하고, 기 판의 또 다른 영역은 메모리 뱅크 사이에 분포된 프로세싱 어레이를 포함할 수 있다. 본 기재의 당업자라면, 기판 상에 프로세싱 그룹의 어레이를 형성하는 것은 배타적인 실시예가 아님을 이 해할 것이다. 예를 들어, 각 프로세서 서브유닛은 적어도 두 개의 전용 메모리 뱅크와 연관될 수 있다. 이에 따 라, 도 3b의 프로세싱 그룹(310a, 310b, 310c, 310d)은 프로세싱 그룹을 대신하여 또는 프로세싱 그룹 과 함께 사용되어 프로세싱 어레이와 메모리 어레이를 형성할 수 있다. 셋, 넷, 또는 그 이상 등의 전용 메모리 뱅크(미도시)를 포함하는 다른 프로세싱 그룹도 사용될 수 있다. 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 특정 어플리케이션과 연관된 소프트웨어를 복수의 프로세 서 서브유닛에 포함된 다른 프로세서 서브유닛에 대해 개별적으로 실행하도록 구성될 수 있다. 예를 들어, 하기 에 설명하는 바와 같이, 복수의 서브시리즈(sub-series)의 명령이 머신 코드로 그룹으로 묶이고 각 프로세서 서 브유닛으로 제공되어 실행될 수 있다. 일부 실시예에서, 각 전용 메모리 뱅크는 적어도 하나의 DRAM을 포함한다. 대안적으로, 메모리 뱅크는 SRAM, DRAM, 플래시메모리 등과 같은 메모리 유형의 조합을 포함할 수 있다. 기존의 프로세서에서, 프로세서 서브유닛 사이의 데이터 공유는 일반적으로 공유 메모리로 수행된다. 공유 메모 리는 보통 넓은 부분의 칩 영역을 요구 및/또는 추가적인 하드웨어(예, 아비터(arbiter))에 의해 관리되는 버스 에 의해 수행된다. 버스는 앞서 설명한 바와 같이 병목 현상을 초래한다. 또한, 칩의 외부에 있을 수 있는 공유 메모리는 정확하고 업데이트 된 데이터를 프로세서 서브유닛에 제공하기 위해서 캐시 일관성 메커니즘과 더욱 복잡한 캐시(예, L1 캐시, L2 캐시, 공유 DRAM)를 포함하는 것이 보통이다. 하기에 더 설명하는 바와 같이, 도 7a와 도 7b에 도시된 전용 버스는 하드웨어 관리(예, 아비터)가 필요 없는 하드웨어 칩을 가능하게 한다. 또한, 도 7a와 도 7b에 도시된 것과 같은 전용 메모리를 사용하면 복잡한 캐싱 계층과 일관성 메커니즘이 없어도 된다. 대신에, 각 프로세서 서브유닛이 다른 프로세서 서브유닛에 의해 계산 및/또는 다른 프로세서 서브유닛의 전용 메모리 뱅크에 저장된 데이터에 접근하게 하기 위하여, 각 프로세서 서브유닛에 의해 개별적으로 실행되는 코드 를 활용하여 동적으로 타이밍이 수행되는 버스가 제공된다. 이로써, 기존에 사용되는 버스 관리 하드웨어 대부 분 또는 전부가 없어도 된다. 또한, 복잡한 캐싱 메커니즘을 이러한 버스를 통한 직접 전송으로 대체할 수 있으 므로, 그 결과, 메모리 읽기와 쓰기 동안에 대기 시간을 줄일 수 있다. 메모리 기반 프로세싱 어레이 도 7a와 도 7b에 도시된 바와 같이, 본 기재의 메모리 칩은 개별적으로 동작할 수 있다. 또는, 본 기재의 메모 리 칩은 메모리 장치(예, 하나 이상의 DRAM 뱅크), 시스템 온 칩, FPGA(field-programmable gate array), 또는 기타 프로세싱 및/또는 메모리 칩과 같은 하나 이상의 추가적인 집적회로에 작동적(operably)으로 연결될 수 있 다. 이러한 실시예에서, 상기 아키텍처에 의해 실행되는 일련의 명령의 작업은 메모리 칩의 프로세서 서브유닛 과 추가적인 집적회로의 프로세서 서브유닛 사이에 분할될 수(예, 하기에 설명하는 바와 같이, 컴파일러에 의해) 있다. 예를 들어, 추가적인 집적회로는 명령 및/또는 데이터를 메모리 칩에 입력하고 메모리 칩으로부터 출력을 수신하는 호스트(예, 도 3a의 호스트)를 포함할 수 있다. 본 기재의 메모리 칩과 하나 이상의 추가 집적회로를 서로 연결하기 위하여, 메모리 칩은 JEDEC(Joint Electron Device Engineering Council) 표준 또는 그 개정 표준을 준수하는 메모리 인터페이스와 같은 메모리 인터페이스 를 포함할 수 있다. 상기 하나 이상의 추가 집적회로는 이후 메모리 인터페이스로 연결될 수 있다. 이에 따라, 하나 이상의 추가 집적회로가 본 기재의 복수의 메모리 칩에 연결되는 경우, 데이터가 하나 이상의 추가 집적회 로를 통해 메모리 칩 사이에 공유될 수 있다. 추가적으로 또는 대안적으로, 하나 이상의 추가 집적회로는 본 기 재의 메모리 칩의 버스와 연결하기 위한 버스를 포함하여 상기 하나 이상의 추가 집적회로가 본 기재의 메모리 칩과 협력하여 코드를 실행하도록 할 수 있다. 이러한 실시예에서, 하나 이상의 추가 집적회로는 본 기재의 메 모리 칩과 다른 기판 상에 있더라도 분산 프로세싱을 추가적으로 지원할 수 있다. 또한, 본 기재의 메모리 칩은 분산 프로세서의 어레이를 형성하기 위하여 어레이로 배치될 수 있다. 예를 들어, 도 7c에 도시된 바와 같이, 하나 이상의 버스가 메모리 칩(770a)을 추가 메모리 칩(770b)으로 연결할 수 있다. 도 7c의 예에서, 메모리 칩(770a)은 하나 이상의 상응하는 메모리 뱅크가 각 프로세서 서브유닛의 전용인 프로 세서 서브유닛을 포함한다. 예를 들어, 프로세서 서브유닛(730a)은 메모리 뱅크(720a)와 연관되고, 프로세서 서 브유닛(730b)은 메모리 뱅크(720b)와 연관되고, 프로세서 서브유닛(730e)은 메모리 뱅크(720c)와 연관되고, 프 로세서 서브유닛(730f)은 메모리 뱅크(720d)와 연관된다. 버스는 각 프로세서 서브유닛을 그에 상응하는 메모리 뱅크에 연결한다. 이에 따라, 버스(740a)는 프로세서 서브유닛(730a)을 메모리 뱅크(720a)에 연결하고, 버스 (740b)는 프로세서 서브유닛(730b)을 메모리 뱅크(720b)에 연결하고, 버스(740c)는 프로세서 서브유닛(730e)을 메모리 뱅크(720c)에 연결하고, 버스(740d)는 프로세서 서브유닛(730f)을 메모리 뱅크(720d)에 연결한다. 또한, 버스(750a)는 프로세서 서브유닛(730a)을 프로세서 서브유닛(750a)에 연결하고, 버스(750b)는 프로세서 서브유 닛(730a)을 프로세서 서브유닛(750b)에 연결하고, 버스(750c)는 프로세서 서브유닛(730b)을 프로세서 서브유닛 (750f)에 연결하고, 버스(750d)는 프로세서 서브유닛(730e)을 프로세서 서브유닛(750f)에 연결한다. 앞서 설명 한 바와 같이, 메모리 칩(770a)의 다른 배치도 활용될 수 있다. 마찬가지로, 메모리 칩(770b)은 하나 이상의 상응하는 메모리 뱅크가 각 프로세서 서브유닛의 전용인 프로세서 서브유닛을 포함한다. 예를 들어, 프로세서 서브유닛(730c)은 메모리 뱅크(720e)와 연관되고, 프로세서 서브유 닛(730d)은 메모리 뱅크(720f)와 연관되고, 프로세서 서브유닛(730g)은 메모리 뱅크(720g)와 연관되고, 프로세 서 서브유닛(730h)은 메모리 뱅크(720h)와 연관된다. 버스는 각 프로세서 서브유닛을 그에 상응하는 메모리 뱅 크에 연결한다. 이에 따라, 버스(740e)는 프로세서 서브유닛(730c)을 메모리 뱅크(720e)에 연결하고, 버스 (740f)는 프로세서 서브유닛(730d)을 메모리 뱅크(720f)에 연결하고, 버스(740g)는 프로세서 서브유닛(730g)을 메모리 뱅크(720g)에 연결하고, 버스(740h)는 프로세서 서브유닛(730h)을 메모리 뱅크(720h)에 연결한다. 또한, 버스(750g)는 프로세서 서브유닛(730c)을 프로세서 서브유닛(750g)에 연결하고, 버스(750h)는 프로세서 서브유 닛(730d)을 프로세서 서브유닛(750h)에 연결하고, 버스(750i)는 프로세서 서브유닛(730c)을 프로세서 서브유닛 (750d)에 연결하고, 버스(750j)는 프로세서 서브유닛(730g)을 프로세서 서브유닛(750h)에 연결한다. 앞서 설명 한 바와 같이, 메모리 칩(770b)의 다른 배치도 활용될 수 있다. 메모리 칩(770a, 770b)의 프로세서 서브유닛은 하나 이상의 버스를 사용하여 서로 연결될 수 있다. 이에 따라, 도 7c의 예에서, 버스(750e)는 메모리 칩(770a)의 프로세서 서브유닛(730b)과 메모리 칩(770b)의 프로세서 서브 유닛(730c)을 서로 연결할 수 있고, 버스(750f)는 메모리 칩(770a)의 프로세서 서브유닛(730f)과 메모리 칩 (770b)의 프로세서 서브유닛(730c)을 서로 연결할 수 있다. 예를 들어, 버스(750e)는 메모리 칩(770b)으로의 입 력 버스(따라서, 메모리 칩(770a)의 출력 버스) 역할을 할 수 있고, 버스(750f)는 메모리 칩(770a)의 입력 버스 (따라서, 메모리 칩(770b)의 출력 버스) 역할을, 또는 그 반대의 역할을, 할 수 있다. 또는 버스(750e, 750f)는 모두 메모리 칩(770a, 770b) 사이의 양방향 버스 역할을 할 수 있다. 버스(750e, 750f)는 직접 회선을 포함하거나, 메모리 칩(770a)과 집적회로(770b) 사이의 인터칩 인터페이스 (inter-chip interface)에 사용되는 핀을 줄이기 위해 고속 연결 상에 인터리브 될 수 있다. 또한, 메모리 칩에 사용되는 앞서 설명한 모든 연결 구성이 사용되어 메모리 칩을 하나 이상의 추가 집적회로에 연결할 수 있다. 예를 들어, 메모리 칩(770a, 770b)은 도 7c에 도시된 것과 같은 2개의 버스만을 사용하기보다 완전 타일 연결이 나 부분 타일 연결을 사용하여 연결될 수 있다. 이에 따라, 버스(750e, 750f)를 사용하여 도시되었지만, 아키텍처는 더 적은 수의 버스나 더 많은 수의 버 스를 포함할 수 있다. 예를 들어, 프로세서 서브유닛730a와 730b) 사이 또는 프로세서 서브유닛730f와 730c 사 이에 단일 버스가 사용될 수 있다. 또는, 추가적인 버스가 프로세서 서브유닛730b와 730d 사이 또는 프로세서 서브유닛730f와 730d 사이 등에 사용될 수 있다. 또한, 단일 메모리 칩과 추가 집적회로를 사용하는 것으로 도시되었지만, 복수의 메모리 칩이 앞서 설명한 바와 같이 연결될 수 있다. 예를 들어, 도 7c에 도시된 바와 같이, 메모리 칩(770a, 770b, 770c, 770d)이 어레이로 연결된다. 각 메모리 칩은 앞서 설명한 메모리 칩과 유사하게 프로세서 서브유닛과 전용 메모리 뱅크를 포함한 다. 이에 따라, 이러한 구성요소에 대한 설명은 여기서 반복하지 않는다. 도 7c의 예에서, 메모리 칩(770a, 770b, 770c, 770d)은 루프로 연결된다. 이에 따라, 버스(750a)는 메모리 칩 770a와 770d을 연결하고, 버스(750c)는 메모리 칩770a와 770b을 연결하고, 버스(750e)는 메모리 칩770b와 770c 을 연결하고, 버스(750g)는 메모리 칩770c와 770d을 연결한다. 메모리 칩(770a, 770b, 770c, 770d)은 완전 타 일 연결, 부분 타일 연결 또는 기타 연결 구성으로 연결될 수 있지만, 도 7c의 예는 메모리 칩(770a, 770b, 770c, 770d) 사이에 적은 수의 핀 연결을 가능하게 한다. 상대적 대용량 메모리 본 기재의 실시예들은 기존 프로세서의 공유 메모리에 비하여 상대적으로 큰 사이즈의 전용 메모리를 사용할 수 있다. 공유 메모리가 아닌 전용 메모리를 사용하면 메모리 증가로 인한 효율 감소 없이 작업을 진행할 수 있다. 이로써, 공유 메모리의 증가에 따른 효율 향상이 폰노이만 병목현상(von Neumann bottleneck)으로 인해 줄어드 는 기존 프로세서에서 수행되는 것보다 신경망 처리와 데이터베이스 쿼리와 같은 메모리 집약적 작업이 더 효율 적으로 수행될 수 있다. 예를 들어, 본 기재의 분산 프로세서에서, 기재된 프로세서의 기판 상에 배치된 메모리 어레이는 복수의 이산 메모리 뱅크(discrete memory banks)를 포함할 수 있다. 각각의 이산 메모리 뱅크는 1 메가바이트 이상의 용량 및 복수의 프로세서 서브유닛을 포함하고 기판 상에 배치된 프로세싱 어레이를 포함할 수 있다. 앞서 설명한 바 와 같이, 프로세서 서브유닛의 각 프로세서 서브유닛은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메 모리 뱅크와 연관될 수 있다. 일부 실시예에서, 복수의 프로세서 서브유닛은 메모리 어레이 이내의 복수의 이산 메모리 뱅크 사이에서 공간적으로 분포될 수 있다. 대형 CPU 또는 GPU에 대해 몇 메가바이트의 공유 캐시를 사 용하기보다 최소 1메가바이트의 전용 메모리를 사용함으로써, 본 기재의 분산 프로세서는 CPU와 GPU의 폰노이만 병목현상으로 인해 기존의 시스템에서 가능하지 않은 효율성을 얻게 된다. 서로 다른 메모리가 전용 메모리로 사용될 수도 있다. 예를 들어, 각 전용 메모리 뱅크는 적어도 하나의 DRAM 뱅크를 포함할 수 있다. 또는, 각 전용 메모리 뱅크는 적어도 하나의 SRAM 뱅크를 포함할 수 있다. 다른 실시예 에서, 서로 다른 유형의 메모리가 단일 하드웨어 칩 상에서 병합될 수 있다. 앞서 설명한 바와 같이, 각 전용 메모리는 최소 1메가바이트일 수 있다. 이에 따라, 각 전용 메모리 뱅크는 동 일 사이즈이거나, 복수의 메모리 뱅크의 적어도 두 메모리 뱅크는 서로 다른 사이즈일 수 있다. 또한, 앞서 설명한 바와 같이, 분산 프로세서는 각각 복수의 프로세서 서브유닛의 한 프로세서 서브유닛을 그에 상응하는 전용 메모리 뱅크에 연결하는 제1 복수의 버스 및 각각 복수의 프로세서 서브유닛의 한 프로세서 서브 유닛을 복수의 프로세서 서브유닛의 다른 프로세서 서브유닛에 연결하는 제2 복수의 버스를 포함할 수 있다. 소프트웨어를 활용한 동기화 앞서 설명한 바와 같이, 본 기재의 하드웨어 칩은 하드웨어가 아닌 소프트웨어를 활용하여 데이터 전송을 관리 할 수 있다. 특히, 버스 상의 전송, 메모리의 읽기와 쓰기, 및 프로세서 서브유닛의 계산의 타이밍이 프로세서 서브유닛에 의해 실행되는 명령의 서브시리즈에 의해 설정되기 때문에, 본 기재의 하드웨어 칩은 코드를 실행하 여 버스 상의 충돌을 방지할 수 있다. 이에 따라, 본 기재의 하드웨어 칩은 종래에 데이터 전송의 관리에 사용 되는 하드웨어 메커니즘(예, 칩 내의 네트워크 컨트롤러, 프로세서 서브유닛 간의 패킷 파서(packet parser) 및 패킷 전송기(packet transferor), 버스 아비터, 중재를 피하기 위한 복수의 버스 등)을 회피할 수 있다. 본 기재의 하드웨어 칩이 종래의 방식으로 데이터를 전송한다면, N 프로세서 서브유닛을 버스에 연결하려면 아 비터에 의해 제어되는 광범위한 MUX 또는 버스 중재가 필요할 것이다. 반면, 앞서 설명한 바와 같이, 본 기재의 실시예는 프로세서 서브유닛 사이에 오직 회선, 광케이블 등인 버스를 사용할 수 있고, 프로세서 서브유닛은 개 별적으로 코드를 실행하여 버스 상의 충돌을 방지할 수 있다. 이에 따라, 본 기재의 실시예는 기판 상의 공간을 보존할 수 있을 뿐만 아니라 (중재에 의한 전력 및 시간 소비로 인한) 재료 비용과 효율 저하를 줄일 수 있다. FIFO(first-in-first-out) 컨트롤로 및/또는 메일박스를 사용하는 다른 아키텍처와 비교하면 효율성과 공간의 이점이 더욱 크다. 또한, 앞서 설명한 바와 같이, 각 프로세서 서브유닛은 하나 이상의 처리 소자 외에도 하나 이상의 가속기를 포 함할 수 있다. 일부 실시예에서, 처리 소자가 아니라 가속기가 버스의 읽기와 쓰기를 할 수 있다. 이러한 실시 예에서, 처리 소자가 하나 이상의 계산을 수행하는 사이클과 동일한 사이클 동안에 가속기가 데이터를 전송하게 함으로써 효율성이 추가적으로 확보될 수 있다. 그러나 이러한 실시예는 가속기에 대한 추가적인 재료를 필요로 한다. 예를 들어, 가속기의 제조를 위해 트랜지스터가 추가적으로 필요할 수 있다. 코드는 또한 프로세서 서브유닛(예, 처리 소자 및/또는 프로세서 서브유닛의 일부를 형성하는 가속기)의 타이밍 과 지연을 포함하는 내부 동작에 대처할 수 있다. 예를 들면, 컴파일러(하기에 설명)는 데이터 전송을 제어하는 명령의 서브시리즈를 생성하는 경우의 타이밍과 지연에 대처하는 프리-프로세싱(pre-processing)을 수행할 수 있다. 일례에서, 복수의 프로세서 서브유닛은 이전 계층의 더 많은 복수의 뉴런에 완전히 연결된 복수의 뉴런을 포함 하는 신경망 계층을 계산하는 작업이 배정될 수 있다. 복수의 프로세서 서브유닛 사이에 이전 계층의 데이터가 균일하게 퍼져있다고 가정할 때, 상기 계산을 수행하는 한가지 방법은 각 프로세서 서브유닛이 이전 계층의 데 이터를 메인 버스로 차례로 전송하도록 설정하는 것일 수 있으며, 그러면 각 프로세서 서브유닛은 프로세서 서 브유닛이 구현하는 해당 뉴런의 가중치로 이 데이터를 곱할 것이다. 각 프로세서 서브유닛은 하나 이상의 뉴런 을 계산하므로, 각 프로세서 서브유닛은 이전 계층의 데이터를 뉴런의 수만큼 전송할 것이다. 따라서, 프로세서 서브유닛은 서로 다른 시간에 전송하게 될 것이므로, 각 프로세서 서브유닛의 코드는 다른 프로세서 서브유닛의 코드와 동일하지 않다. 일부 실시예에서, 분산 프로세서는 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이가 배치된 기판(예, 실리 콘과 같은 반도체 기판 및/또는 연성회로기판과 같은 회로 기판) 및 상기 기판에 배치되고 도 7a와 도 7b 등에 도시된 것과 같은 복수의 프로세서 서브유닛을 포함하는 프로세싱 어레이를 포함할 수 있다. 앞서 설명한 바와 같이, 각각의 프로세서 서브유닛은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 연관될 수 있다. 또한, 도 7a와 도 7b 등에 도시된 것과 같이, 분산 프로세서는 각각 복수의 프로세서 서브유닛의 하나 를 복수의 프로세서 서브유닛의 적어도 다른 하나에 연결하는 복수의 버스를 더 포함할 수 있다. 앞서 설명한 바와 같이, 복수의 버스는 소프트웨어로 제어될 수 있다. 이에 따라, 복수의 버스는 타이밍 하드웨 어 로직 요소가 없어서 프로세서 서브유닛 사이의 데이터 전송과 복수의 버스의 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않을 수 있다. 일례에서, 복수의 버스는 버스 아비터(bus arbiters)가 없어서 프로세서 서브유닛 사이의 데이터 전송과 복수의 버스의 상응하는 버스를 통한 데이터 전송 은 버스 아비터에 의해 제어되지 않을 수 있다. 일부 실시예에서, 도 7a와 도 7b 등에 도시된 것과 같이, 분산 프로세서는 복수의 프로세서 서브유닛을 상응하 는 전용 메모리 뱅크에 연결하는 제2 복수의 버스를 더 포함할 수 있다. 앞서 설명한 복수의 버스와 유사하게, 제2 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛과 상응하는 전용 메모리 뱅크 사이 의 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않을 수 있다. 일례에서, 제2 복수의 버스는 버 스 아비터가 없어서 프로세서 서브유닛과 상응하는 전용 메모리 뱅크 사이의 데이터 전송은 버스 아비터에 의해 제어되지 않을 수 있다. 본 기재에서, '없다.'라는 표현은 타이밍 하드웨어 로직 요소(예, 버스 아비터, 중재 구조, FIFO 컨트롤러, 메 일박스 등)가 절대적으로 없음을 반드시 의미하는 것이 아니다. 이러한 요소는 이러한 요소가 '없다.'라고 설명 된 하드웨어 칩에 여전히 포함되어 있을 수 있다. 오히려, '없다.'라는 표현은 하드웨어 칩의 기능을 말하는 것 이다. 즉, 타이밍 하드웨어 로직 요소가 '없는' 하드웨어 칩은 타이밍 하드웨어 로직 요소를 사용하지 않고 하 드웨어 칩의 데이터 전송의 타이밍을 제어한다. 예를 들어, 하드웨어 칩이 실행 코드의 오류로 인한 충돌로부터 의 보호를 위한 2차 예방책으로 타이밍 하드웨어 로직 요소를 포함하더라도, 하드웨어 칩은 하드웨어 칩의 프로 세서 서브유닛 사이의 데이터 전송을 제어하는 명령의 서브시리즈를 포함하는 코드를 실행한다. 앞서 설명한 바와 같이, 복수의 버스는 복수의 프로세서 서브유닛의 상응하는 프로세서 서브유닛 사이에 회선 및 광섬유의 적어도 하나를 포함할 수 있다. 이에 따라, 일례에서, 타이밍 하드웨어 로직 요소가 없는 분산 프 로세서는 버스 아비터, 중재 구조, FIFO 컨트롤러, 메일박스 등이 없이 회선 또는 광섬유만을 포함할 수 있다. 일부 실시예에서, 복수의 프로세서 서브유닛은 복수의 프로세서 서브유닛에 의해 실행되는 코드에 따라 복수의 버스의 적어도 하나를 통해 데이터를 전송하도록 구성된다. 이에 따라, 앞서 설명한 바와 같이, 컴파일러는 각 각 단일 프로세서 서브유닛에 의해 실행되는 코드를 포함하는 명령의 서브시리즈를 정리할 수 있다. 명령의 서 브시리즈는 프로세서 서브유닛에게 언제 버스 중의 하나로 데이터를 전송할지와 언제 버스로부터 데이터를 가져올지를 지시할 수 있다. 서브시리즈가 분산 프로세서에 걸쳐 협력하여 실행되는 경우, 프로세서 서브유닛 사이 의 전송의 타이밍은 서브시리즈에 포함된 전송과 회수 명령에 의해 통제될 수 있다. 따라서, 코드는 복수의 버 스의 적어도 하나를 통한 데이터 전송의 타이밍을 통제한다. 컴파일러는 단일 프로세서 서브유닛에 의해 실행될 코드를 생성할 수 있다. 또한, 컴파일러는 프로세서 서브유닛의 그룹에 의해 실행될 코드를 생성할 수 있다. 일 부의 경우, 컴파일러는 모든 프로세서 서브유닛을 마치 하나의 슈퍼프로세서(예, 분산 프로세서)인 것처럼 취급 할 수 있고, 컴파일러는 이렇게 정의된 슈퍼프로세서/분산 프로세서에 의해 실행될 코드를 생성할 수 있다. 앞서 설명하고 도 7a와 도 7b에 도시된 바와 같이, 복수의 프로세서 서브유닛은 메모리 어레이 내의 복수의 이 산 메모리 뱅크 사이에 공간적으로 분포될 수 있다. 또는, 복수의 프로세서 서브유닛은 기판의 하나 이상의 영 역에서 클러스터링 될 수 있고, 복수의 메모리 뱅크는 기판의 하나 이상의 다른 영역에서 클러스터링 될 수 있 다. 일부 실시예에서, 앞서 설명한 바와 같이, 공간적 분포와 클러스터링의 조합이 사용될 수 있다. 일부 실시예에서, 분산 프로세서는 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이가 배치된 기판(예, 실리 콘과 같은 반도체 기판 및/또는 연성회로기판과 같은 회로 기판)을 포함할 수 있다. 프로세싱 어레이는 또한 상 기 기판에 배치되고 도 7a와 도 7b 등에 도시된 것과 같은 복수의 프로세서 서브유닛을 포함할 수 있다. 앞서 설명한 바와 같이, 각각의 프로세서 서브유닛은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅 크와 연관될 수 있다. 또한, 도 7a와 도 7b 등에 도시된 것과 같이, 분산 프로세서는 각각 복수의 프로세서 서 브유닛의 하나를 복수의 이산 메모리 뱅크의 상응하는 전용 이산 메모리 뱅크에 연결하는 복수의 버스를 더 포 함할 수 있다. 앞서 설명한 바와 같이, 복수의 버스는 소프트웨어로 제어될 수 있다. 이에 따라, 복수의 버스는 타이밍 하드웨 어 로직 요소가 없어서 프로세서 서브유닛과 복수의 이산 메모리 뱅크의 상응하는 전용 이산 메모리 뱅크 사이 의 데이터 전송과 복수의 버스의 상응하는 버스를 통한 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어 되지 않을 수 있다. 일례에서, 복수의 버스는 버스 아비터가 없어서 프로세서 서브유닛 사이의 데이터 전송과 복수의 버스의 상응하는 버스를 통한 데이터 전송은 버스 아비터에 의해 제어되지 않을 수 있다. 일부 실시예에서, 도 7a와 도 7b 등에 도시된 바와 같이, 분산 프로세서는 복수의 프로세서 서브유닛의 하나를 복수의 프로세서 서브유닛의 적어도 다른 하나에 연결하는 제2 복수의 버스를 더 포함할 수 있다. 앞서 설명한 복수의 버스와 유사하게, 제2 복수의 버스는 타이밍 하드웨어 로직 요소가 없어서 프로세서 서브유닛과 상응하 는 전용 메모리 뱅크 사이의 데이터 전송은 타이밍 하드웨어 로직 요소에 의해 제어되지 않을 수 있다. 일례에 서, 제2 복수의 버스는 버스 아비터가 없어서 프로세서 서브유닛과 상응하는 전용 메모리 뱅크 사이의 데이터 전송은 버스 아비터에 의해 제어되지 않을 수 있다. 일부 실시예에서, 분산 프로세서는 소프트웨어 타이밍 요소와 하드웨어 타이밍 요소의 조합을 사용할 수 있다. 예를 들어, 분산 프로세서는 복수의 이산 메모리 뱅크를 포함하는 메모리 어레이가 배치된 기판(예, 실리콘과 같은 반도체 기판 및/또는 연성회로기판과 같은 회로 기판)을 포함할 수 있다. 프로세싱 어레이는 또한 상기 기 판에 배치되고 도 7a와 도 7b 등에 도시된 것과 같은 복수의 프로세서 서브유닛을 포함할 수 있다. 앞서 설명한 바와 같이, 각각의 프로세서 서브유닛은 복수의 이산 메모리 뱅크 중에서 상응하는 전용 이산 메모리 뱅크와 연 관될 수 있다. 또한, 도 7a와 도 7b 등에 도시된 것과 같이, 분산 프로세서는 각각 복수의 프로세서 서브유닛의 하나를 복수의 프로세서 서브유닛의 적어도 다른 하나에 연결하는 복수의 버스를 더 포함할 수 있다. 또한, 앞 서 설명한 바와 같이, 복수의 프로세서 서브유닛은 복수의 버스를 통한 데이터 전송의 타이밍을 제어하여 복수 의 버스의 적어도 하나 상에서의 데이터 전송의 충돌을 방지하는 소프트웨어를 실행하도록 구성될 수 있다. 이 러한 예에서, 소프트웨어는 데이터 전송의 타이밍을 제어할 수 있지만, 전송 자체는 적어도 부분적으로는 하나 이상의 하드웨어 요소에 의해 제어될 수 있다. 이러한 실시예에서, 분산 프로세서는 복수의 프로세서 서브유닛의 하나를 상응하는 전용 메모리 뱅크에 연결하 는 제2 복수의 버스를 더 포함할 수 있다. 앞서 설명한 복수의 버스와 유사하게, 복수의 프로세서 서브유닛은 제2 복수의 버스를 통한 데이터 전송의 타이밍을 제어하여 제2 복수의 버스의 적어도 하나 상에서의 데이터 전 송의 충돌을 방지하는 소프트웨어를 실행하도록 구성될 수 있다. 이러한 예에서, 앞서 설명한 바와 같이, 소프 트웨어는 데이터 전송의 타이밍을 제어할 수 있지만, 전송 자체는 적어도 부분적으로는 하나 이상의 하드웨어 요소에 의해 제어될 수 있다. 코드의 분할 앞서 설명한 바와 같이, 본 기재의 하드웨어 칩은 하드웨어 칩을 형성하는 기판 상에 포함된 프로세서 서브유닛 전체에서 병렬로 코드를 실행할 수 있다. 또한, 본 기재의 하드웨어 칩은 멀티태스킹을 수행할 수 있다. 예를 들면, 본 기재의 하드웨어 칩은 영역 멀티태스킹을 수행할 수 있다. 즉, 하드웨어 칩의 프로세서 서브유닛의 한 그룹은 한 작업(예, 오디오 프로세싱)을 실행하고, 하드웨어 칩의 프로세서 서브유닛의 다른 그룹은 다른 작업 (예, 이미지 프로세싱)을 실행할 수 있다. 다른 예에서, 본 기재의 하드웨어 칩은 타이밍 멀티태스킹을 수행할 수 있다. 즉, 하드웨어 칩의 하나 이상의 프로세서 서브유닛은 제1시간 주기 동안에 한 작업을 실행하고 제2시 간 주기 동안에는 다른 작업을 실행할 수 있다. 영역 멀티태스킹과 타이밍 멀티태스킹의 조합도 사용되어 제1시 간 주기 동안에 한 작업이 제1그룹의 프로세서 서브유닛에 배정되고 제1시간 주기 동안에 다른 작업이 제2그룹 의 프로세서 서브유닛에 배정된 후에 제2시간 주기 동안에 제3 작업이 제1그룹과 제2그룹에 포함된 프로세서 서 브유닛에 배정될 수 있다. 본 기재의 메모리 칩 상의 실행을 위한 머신 코드를 정리하기 위하여, 머신 코드는 메모리 칩의 프로세서 서브 유닛 사이에서 분할될 수 있다. 예를 들어, 메모리 칩 상의 프로세서는 기판 및 기판 상에 배치된 복수의 프로 세서 서브유닛을 포함할 수 있다. 메모리 칩은 기판 상에 배치된 상응하는 복수의 메모리 뱅크를 더 포함할 수 있고, 여기서, 복수의 프로세서 서브유닛의 각각은 복수의 프로세서 서브유닛의 어느 프로세서 서브유닛에도 공 유되지 않는 적어도 하나의 전용 메모리 뱅크에 연결될 수 있다. 메모리 칩 상의 각 프로세서 서브유닛은 다른 프로세서 서브유닛과 별개인 일련의 명령을 실행하도록 구성될 수 있다. 각 일련의 명령은 일련의 명령을 정의 하는 코드에 따라 프로세서 서브유닛의 하나 이상의 일반 처리 소자를 설정 및/또는 일련의 명령을 정의하는 코 드 내에 제공된 시퀀스에 따라 프로세서 서브유닛의 하나 이상의 특별 처리 소자(예, 하나 이상의 가속기)를 활 성화하여 실행될 수 있다. 이에 따라, 각 일련의 명령은 단일 프로세서 서브유닛에 의해 수행될 일련의 작업을 정의할 수 있다. 단일 작업 은 프로세서 서브유닛 내의 하나 이상의 처리 소자의 아키텍처에 의해 정의된 명령 세트 이내의 명령을 포함할 수 있다. 예를 들어, 프로세서 서브유닛은 특정 레지스터(register)를 포함할 수 있고, 단일 작업은 레지스터로 데이터 푸쉬(push), 레지스터로부터 데이터 풀(pull), 레지스터 이내의 데이터에 대한 산술 연산의 수행, 레지 스터 이내의 데이터에 대한 논리 연산의 수행 등을 할 수 있다. 또한, 프로세서 서브유닛은 0-피연산자 (operand) 프로세서 서브유닛('스택 머신(stack machine)'으로도 지칭), 1-피연산자 프로세서 서브유닛(어큐뮬 레이터 머신(accumulator machine)으로도 지칭), 2-피연산자 프로세서 서브유닛(RISC 등), 3-피연산자 프로세서 서브유닛(CISC(complex instruction set computer)) 등과 같이 여러 수의 피연산자에 대해 구성될 수 있다. 다 른 예에서, 프로세서 서브유닛은 하나 이상의 가속기를 포함할 수 있고, 단일 작업은 가속기를 활성화하여 MAC 함수, MAX 함수, MAX-0 함수 등과 같은 특정 함수를 수행할 수 있다. 일련의 명령은 메모리 칩의 전용 메모리 뱅크로부터 읽기와 쓰기를 하기 위한 작업을 더 포함할 수 있다. 예를 들어, 작업은 이 작업을 실행하는 프로세서 서브유닛 전용의 메모리 뱅크에 데이터 하나를 쓰는 작업, 이 작업 을 실행하는 프로세서 서브유닛 전용의 메모리 뱅크에서 데이터 하나를 읽는 작업 등을 포함할 수 있다. 일부 실시예에서, 읽기와 쓰기는 메모리 뱅크의 컨트롤러와 협력하여 프로세서 서브유닛에 의해 수행될 수 있다. 예 를 들어, 프로세서 서브유닛은 읽기 또는 쓰기를 수행하라는 제어 신호를 컨트롤러에 전송하여 읽기 또는 쓰기 작업을 실행할 수 있다. 일부 실시예에서, 제어 신호는 읽기와 쓰기에 사용할 특정 주소를 포함할 수 있다. 또 는 프로세서 서브유닛은 읽기와 쓰기를 위해 사용할 수 있는 주소의 선택을 메모리 컨트롤러에 맡길 수 있다. 추가적으로 또는 대안적으로, 읽기와 쓰기는 하나 이상의 가속기가 메모리 뱅크의 컨트롤러와 협력하여 수행될 수 있다. 예를 들어, 가속기는 앞서 설명한 프로세서 서브유닛이 제어 신호를 생성하는 것과 유사하게 메모리 컨트롤러에 대한 제어 신호를 생성할 수 있다. 상기에 설명한 실시예에서, 어드레스 생성기를 사용하여 메모리 뱅크의 특정 주소로 읽기와 쓰기를 지시할 수도 있다. 예를 들어, 어드레스 생성기는 읽기와 쓰기를 위한 메모리 주소를 생성하도록 구성된 처리 소자를 포함할 수 있다. 어드레스 생성기는 추후 계산의 결과를 더 이상 필요가 없는 이전 계산의 결과의 주소와 같은 주소로 쓰는 등을 통하여 효율성을 향상하기 위하여 주소를 생성하도록 구성될 수 있다. 이에 따라, 어드레스 생성기는 프로세서 서브유닛으로부터의(예, 프로세서 서브유닛에 포함된 처리 소자 또는 하나 이상의 가속기로부터의) 명 령에 대응하여 또는 프로세서 서브유닛과 협력하여 메모리 컨트롤러에 대한 제어 신호를 생성할 수 있다. 추가 적으로 또는 대안적으로, 어드레스 생성기는, 예를 들어, 특정 패턴에서 메모리 내의 특정 주소에 대해 반복하 는 중첩 루프(nested loop) 구조를 생성하는 일부 설정 또는 레지스터에 의거하여 주소를 생성할 수 있다. 일부 실시예에서, 각 일련의 명령은 상응하는 일련의 작업을 정의하는 머신 코드 세트를 포함할 수 있다. 이에 따라, 상기 일련의 작업은 일련의 명령을 포함하는 머신 코드 내에 압축될 수 있다. 일부 실시예에서, 하기에도 8을 참조하여 설명하는 바와 같이, 일련의 작업은 복수의 논리 회로 중의 고수준(higher-level)의 일련의 작 업을 복수의 일련의 작업으로 분포하도록 구성된 컴파일러에 의해 정의될 수 있다. 예를 들어, 컴파일러는 고수 준의 일련의 작업에 의거하여 복수의 일련의 작업을 생성하여 각각 상응하는 일련의 작업을 함께 실행하는 프로 세서 서브유닛이 고수준의 일련의 작업이 서술한 것과 같은 함수를 수행할 수 있다. 하기에 설명하는 바와 같이, 고수준의 일련의 작업은 인간-판독 가능 프로그래밍 언어로 된 명령 세트를 포함할 수 있다. 이에 상응하여, 각 프로세서 서브유닛에 대한 일련의 작업은 머신 코드로 된 명령 세트를 각각 포함하 는 저수준(lower-level)의 일련의 작업을 포함할 수 있다. 앞서 도 7a와 도 7b를 참조하여 설명한 바와 같이, 메모리 칩은 복수의 프로세서 서브유닛의 하나를 복수의 프 로세서 서브유닛의 적어도 다른 하나에 각각 연결하는 복수의 버스를 더 포함할 수 있다. 또한, 앞서 설명한 바 와 같이, 복수의 버스 상의 데이터 전송은 소프트웨어를 사용하여 제어될 수 있다. 이에 따라, 복수의 버스의 적어도 하나를 통한 데이터 전송은 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛에 포함된 일련의 명 령에 의해 미리 정해질 수 있다. 따라서, 일련의 명령에 포함된 작업 중의 하나는 버스 중의 하나로 데이터를 출력하는 작업 또는 버스 중의 하나로부터 데이터를 가져오는 작업을 포함할 수 있다. 이러한 작업은 프로세서 서브유닛의 처리 소자 또는 프로세서 서브유닛에 포함된 하나 이상의 가속기에 의해 실행될 수 있다. 후자의 실 시예에서, 프로세서 서브유닛은 가속기가 버스 중의 하나로부터 데이터를 가져오거나 버스 중의 하나로 데이터 를 배치하는 사이클과 같은 사이클에서 계산을 수행하거나 상응하는 메모리 뱅크로 제어 신호를 전송할 수 있다. 일례에서, 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛에 포함된 일련의 명령은 복수의 버스의 적어 도 하나에 연결된 프로세서 서브유닛이 복수의 버스의 적어도 하나로 데이터를 쓰게 하는 명령을 포함하는 전송 작업을 포함할 수 있다. 추가적으로 또는 대안적으로, 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛 에 포함된 일련의 명령은 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛이 복수의 버스의 적어도 하나 로부터 데이터를 읽게 하는 명령을 포함하는 수신 작업을 포함할 수 있다. 프로세서 서브유닛 사이의 코드 분산에 추가적으로 또는 대안적으로, 데이터는 메모리 칩의 메모리 뱅크 사이에 분할될 수 있다. 예를 들어, 앞서 설명한 바와 같이, 메모리 칩 상의 분산 프로세서는 메모리 칩 상에 배치된 복수의 프로세서 서브유닛과 메모리 칩 상에 배치된 복수의 메모리 뱅크를 포함할 수 있다. 복수의 메모리 뱅크 의 각 메모리 뱅크는 복수의 메모리 뱅크의 다른 메모리 뱅크에 저장된 데이터와 별개인 데이터를 저장하도록 구성될 수 있고, 복수의 프로세서 서브유닛의 각 프로세서 서브유닛은 복수의 메모리 뱅크 중에서 적어도 하나 의 전용 메모리 뱅크에 연결될 수 있다. 예를 들어, 각 프로세서 서브유닛은 그 프로세서 서브유닛 전용의 하나 이상의 상응하는 메모리 뱅크의 하나 이상의 메모리 컨트롤러에 접근할 수 있고, 다른 어떤 프로세서 서브유닛 도 이러한 상응하는 하나 이상의 메모리 컨트롤러에 접근할 수 없을 수 있다. 이에 따라, 메모리 뱅크 사이에 공유될 수 있는 메모리 컨트롤러가 없기 때문에 각 메모리 뱅크에 저장된 데이터는 다른 메모리 뱅크에 저장된 메모리와 별개일 수 있다. 일부 실시예에서, 하기에 도 8을 참조하여 설명하는 바와 같이, 복수의 메모리 뱅크 각각에 저장된 데이터는 복 수의 메모리 뱅크 사이에 데이터를 분산하도록 구성된 컴파일러에 의해 정의될 수 있다. 또한, 컴파일러는 상응 하는 프로세서 서브유닛에 분산된 복수의 저수준 작업을 이용하여 고수준의 일련의 작업에서 정의된 데이터를 복수의 메모리 뱅크에 분산하도록 구성될 수 있다. 하기에 더 설명하는 바와 같이, 고수준의 일련의 작업은 인간-판독 가능 프로그래밍 언어로 된 명령 세트를 포 함할 수 있다. 이에 상응하여, 각 프로세서 서브유닛에 대한 일련의 작업은 머신 코드로 된 명령 세트를 각각 포함하는 저수준의 일련의 작업을 포함할 수 있다. 앞서 도 7a와 도 7b를 참조하여 설명한 바와 같이, 메모리 칩은 복수의 프로세서 서브유닛의 하나를 복수의 메 모리 뱅크 중의 하나 이상의 상응하는 전용 메모리 뱅크에 각각 연결하는 복수의 버스를 더 포함할 수 있다. 또 한, 앞서 설명한 바와 같이, 복수의 버스 상의 데이터 전송은 소프트웨어를 활용하여 제어될 수 있다. 이에 따 라, 복수의 버스 중 특정 버스를 통한 데이터 전송은 복수의 버스 중 특정 버스에 연결된 상응하는 프로세서 서 브유닛에 의해 제어될 수 있다. 따라서, 일련의 명령에 포함된 작업의 하나는 버스 중의 하나로 데이터를 출력 하는 작업 또는 버스 중의 하나로부터 데이터를 가져오는 작업을 포함할 수 있다. 앞서 설명한 바와 같이, 이러 한 작업은 (i) 프로세서 서브유닛의 처리 소자 또는 (ii) 프로세서 서브유닛에 포함된 하나 이상의 가속기에 의 해 실행될 수 있다. 후자의 실시예에서, 프로세서 서브유닛은 가속기가 하나 이상의 상응하는 전용 메모리 뱅크 에 연결된 버스 중의 하나로부터 데이터를 가져오거나 하나 이상의 상응하는 전용 메모리 뱅크에 연결된 버스중의 하나로 데이터를 배치하는 사이클과 같은 사이클에서 계산을 수행하거나 프로세서 서브유닛을 다른 프로세 서 서브유닛에 연결하는 버스를 사용할 수 있다. 따라서, 일례에서, 복수의 버스의 적어도 하나로 연결된 프로세서 서브유닛에 포함된 일련의 명령은 전송 작업 을 포함할 수 있다. 전송 작업은 하나 이상의 상응하는 전용 메모리 뱅크에 저장할 데이터를 복수의 버스의 적 어도 하나에 연결된 프로세서 서브유닛이 복수의 버스의 적어도 하나로 쓰게 하는 명령을 포함할 수 있다. 추가 적으로 또는 대안적으로, 복수의 버스의 적어도 하나로 연결된 프로세서 서브유닛에 포함된 일련의 명령은 수신 작업을 포함할 수 있다. 수신 작업은 하나 이상의 상응하는 전용 메모리 뱅크에 저장할 데이터를 복수의 버스의 적어도 하나에 연결된 프로세서 서브유닛이 복수의 버스의 적어도 하나로부터 읽게 하는 명령을 포함할 수 있다. 이에 따라, 이러한 실시예의 전송 및 수신 작업은 하나 이상의 상응하는 전용 메모리 뱅크의 하나 이상의 메모리 컨트롤러로 복수의 버스의 적어도 하나를 따라 전송되는 제어 신호를 포함할 수 있다. 또한, 전송 및 수 신 작업은 프로세서 서브유닛의 다른 부분(프로세서 서브유닛의 하나 이상의 다른 가속기)에 의해 실행되는 계 산 또는 기타 작업과 동시에 프로세서 서브유닛의 일부분(예, 프로세서 서브유닛의 하나 이상의 가속기)에 의해 실행될 수 있다. 이러한 동시 실행의 일례에는 수신, 곱셈, 및 전송이 함께 실행되는 MAC-릴레이(relay) 명령이 포함될 수 있다. 메모리 뱅크 간의 데이터 분산 외에도, 특정 부분의 데이터가 서로 다른 메모리 뱅크에 복제될 수 있다. 예를 들어, 앞서 설명한 바와 같이, 메모리 칩 상의 분산 프로세서는 메모리 칩 상에 배치된 복수의 프로세서 서브유 닛과 메모리 칩 상에 배치된 복수의 메모리 뱅크를 포함할 수 있다. 복수의 프로세서 서브유닛의 각각은 복수의 메모리 뱅크 중의 적어도 하나의 전용 메모리 뱅크로 연결될 수 있고, 복수의 메모리 뱅크의 각 메모리 뱅크는 복수의 메모리 뱅크의 다른 메모리 뱅크에 저장된 데이터와 별개인 데이터를 저장하도록 구성될 수 있다. 또한, 복수의 메모리 뱅크 중의 하나의 특정 메모리 뱅크에 저장된 데이터의 적어도 일부는 복수의 메모리 뱅크의 적 어도 다른 하나의 메모리 뱅크에 저장된 데이터의 복제본을 포함할 수 있다. 예를 들어, 일련의 명령에 사용되 는 데이터의 번호, 문자열, 또는 기타 유형이 한 메모리 뱅크에서 메모리 칩의 다른 프로세서 서브유닛으로 전 송되기 보다는 서로 다른 프로세서 서브유닛의 전용인 복수의 메모리 뱅크에 저장될 수 있다. 일례에서, 병렬 문자열 매칭(parallel string matching)은 앞서 설명한 데이터 복제를 활용할 수 있다. 예를 들 어, 복수의 문자열은 동일한 문자열에 비교될 수 있다. 기존의 프로세서는 복수의 문자열의 각 문자열을 동일 스트링과 순차 비교할 것이다. 본 기재의 하드웨어 칩에서는, 동일 문자열이 메모리 뱅크 전반에 걸쳐 복제되어 프로세서 서브유닛이 복수의 문자열의 개별 문자열을 복제된 문자열과 병렬 비교할 수 있도록 할 수 있다. 일부 실시예에서, 하기에 도 8을 참조하여 설명하는 바와 같이, 복수의 메모리 뱅크 중의 하나의 특정 메모리 뱅크 및 복수의 메모리 뱅크의 적어도 다른 하나에 복제된 일부 데이터는 메모리 뱅크에 데이터를 복제하도록 구성된 컴파일러에 의해 정의된다. 또한, 컴파일러는 상응하는 프로세서 서브유닛에 분산된 복수의 저수준 작업 을 이용하여 적어도 일부 데이터를 복제하도록 구성될 수 있다. 데이터의 복제는 데이터의 동일 부분을 다른 계산에 재사용하는 작업에 유용할 수 있다. 데이터의 이런 부분을 복제함으로써, 이러한 계산이 메모리 뱅크의 프로세서 서브유닛에 분산되어 병렬 실행될 수 있는 반면, 각 프로 세서 서브유닛은 (프로세서 서브유닛을 연결하는 버스를 통해 데이터의 이런 부분을 푸쉬 및 풀(Pull) 하지 않 고) 데이터의 이런 부분을 전용 메모리 뱅크에 저장하고 전용 메모리 뱅크에서 저장된 부분에 접근할 수 있다. 일례에서, 복수의 메모리 뱅크의 하나의 특정 메모리 뱅크와 복수의 메모리 뱅크의 적어도 하나의 다른 메모리 뱅크에 복제된 일부 데이터는 신경망의 가중치를 포함할 수 있다. 이러한 예에서, 신경망의 각 노드는 복수의 프로세서 서브유닛의 적어도 한 프로세서 서브유닛에 의해 정의될 수 있다. 예를 들어, 각 노드는 이 노드를 정 의하는 적어도 하나의 프로세서 서브유닛에 의해 실행되는 머신 코드를 포함할 수 있다. 이러한 예에서, 가중치 를 복제하면 각 프로세서 서브유닛이 (다른 프로세서 서브유닛과의 데이터 전송을 수행하지 않고) 하나 이상의 전용 메모리 뱅크에만 접속하면서 머신 코드를 실행하여 상응하는 노드에 적어도 부분적으로 작용할 수 있다. 전용 메모리에 대한 읽기와 쓰기 타이밍은 다른 프로세서 서브유닛과 별개인 반면에 프로세서 서브유닛 사이의 데이터 전송은 타이밍 동기화(앞서 설명한 바와 같이 소프트웨어를 활용)가 필요하므로, 메모리의 복제를 통해 프로세서 서브유닛 사이의 데이터 전송을 안 해도 되면 전체적인 실행이 더욱 효율적이 될 수 있다. 앞서 도 7a와 도 7b를 참조하여 설명한 바와 같이, 메모리 칩은 복수의 프로세서 서브유닛의 하나를 복수의 메 모리 뱅크의 하나 이상의 상응하는 전용 메모리 뱅크에 각각 연결하는 복수의 버스를 포함할 수 있다. 또한, 앞 서 설명한 바와 같이, 복수의 버스 상의 데이터 전송은 소프트웨어를 이용하여 제어될 수 있다. 이에 따라, 복 수의 버스의 특정 버스를 통한 데이터 전송은 복수의 버스의 특정 버스에 연결된 상응하는 프로세서 서브유닛에의해 제어될 수 있다. 따라서, 일련의 명령에 포함된 작업의 하나는 버스 중의 하나로 데이터를 출력하는 작업 또는 버스 중의 하나에서 데이터를 가져오는 작업을 포함할 수 있다. 앞서 설명한 바와 같이, 이러한 작업은 (i) 프로세서 서브유닛의 처리 소자 또는 (ii) 프로세서 서브유닛에 포함된 하나 이상의 가속기에 의해 실행될 수 있다. 앞서 더 설명한 바와 같이, 이러한 작업은 하나 이상의 상응하는 전용 메모리 뱅크의 하나 이상의 메 모리 컨트롤러로 복수의 버스의 적어도 하나를 따라 전송되는 제어 신호를 포함하는 전송 작업 및/또는 수신 작 업을 포함할 수 있다. 도 8은 도 7a와 도 7b에 도시된 것 등과 같은 본 기재의 예시적인 메모리 칩 상에서 실행되기 위한 일련의 명령 을 컴파일하는 방법의 순서도를 도시한 것이다. 방법은 범용 또는 전용의 기존 프로세서에 의해 구현 될 수 있다. 방법은 컴파일러를 형성하는 컴퓨터 프로그램의 일부로 실행될 수 있다. 본 기재에서, '컴파일러'는 고수 준 언어(예, C, FORTRAN, BASIC 등과 같은 절차형 언어; Java, C++, Pascal, Python 등과 같은 객체 지향 언어 등)를 저수준 언어(예, 어셈블리 코드, 오브젝트 코드, 머신 코드 등))로 변환하는 모든 컴퓨터 프로그램을 말 한다. 컴파일러는 사람으로 하여금 인간 판독 가능 언어로 일련의 명령을 프로그램할 수 있게 해줄 수 있고, 이 러한 명령은 나중에 머신 실행 가능 언어로 변환된다. 단계 810에서, 프로세서는 일련의 명령과 연관된 작업을 프로세서 서브유닛의 서로 다른 서브유닛에 배정할 수 있다. 예를 들어, 일련의 명령은 프로세서 서브유닛에서 병렬로 실행될 소그룹으로 분할될 수 있다. 일례에서, 신경망은 노드로 분할될 수 있고, 하나 이상의 노드가 서로 다른 프로세서 서브유닛에 배정될 수 있다. 이러한 예에서, 각 소그룹은 서로 다른 계층으로 연결된 복수의 노드를 포함할 수 있다. 따라서, 프로세서 서브유닛은 신경망의 제1 계층으로부터의 노드, 동일 프로세서 서브유닛에 의해 구현된 제1 계층으로부터의 노드에 연결된 제2 계층으로부터의 노드 등을 구현할 수 있다. 각각의 연결에 의거하여 노드를 배정함으로써, 프로세서 서브유 닛 간의 데이터 전송이 적어질 수 있고, 그 결과로 앞서 설명한 바와 같이 효율성이 향상될 수 있다. 앞서 도 7a와 도 7b를 참조하여 설명한 바와 같이, 프로세서 서브유닛은 메모리 칩 상에 배치된 복수의 메모리 뱅크에 공간적으로 분산될 수 있다. 이에 따라, 작업의 배정은 논리적으로 분할될 뿐만 아니라 적어도 부분적으 로는 공간적으로 분할될 수 있다. 단계 820에서, 프로세서는 버스에 의해 각각 연결되는 메모리 칩의 프로세서 서브유닛의 쌍(pairs) 사이에 데이 터를 전송하는 작업을 생성할 수 있다. 예를 들어, 앞서 설명한 바와 같이, 데이터 전송은 소프트웨어를 활용하 여 제어될 수 있다. 이에 따라, 프로세서 서브유닛은 동기화된 시간에 버스 상에서 데이터를 푸시 및 풀 하도록 구성될 수 있다. 따라서, 생성된 작업은 데이터의 이러한 동기화된 푸쉬 및 풀을 수행하기 위한 작업을 포함할 수 있다. 앞서 설명한 바와 같이, 단계 820은 프로세서 서브유닛의 타이밍과 지연을 포함하는 내부 동작에 대처하기 위한 프리-프로세싱을 포함할 수 있다. 예를 들어, 프로세서는 생성된 작업이 동기화 되도록 하기 위하여 프로세서 서브유닛의 알려진 시간과 지연(예, 버스로 데이터를 푸쉬 하는데 드는 시간, 버스로부터 데이터를 풀 하는데 드는 시간, 계산과 푸쉬 또는 풀 사이의 지연 등)을 활용할 수 있다. 따라서, 하나 이상의 프로세서 서브유닛에 의한 적어도 하나의 푸쉬 및 하나 이상의 프로세서 서브유닛에 의한 적어도 하나의 풀을 포함하는 데이터 전송 은 프로세서 서브유닛 간의 타이밍 차이, 프로세서 서브유닛의 지연 등으로 인한 지연을 발생시키지 않고 동시 에 일어날 수 있다. 단계 830에서, 프로세서는 배정 및 생성된 작업을 복수의 그룹의 서브시리즈 명령으로 분류할 수 있다. 예를 들 어, 서브시리즈 명령은 각각 단일 프로세서 서브유닛에 의해 실행될 일련의 작업을 포함할 수 있다. 따라서, 복 수의 그룹의 서브시리즈 명령의 각각은 복수의 프로세서 서브유닛의 서로 다른 서브유닛에 상응할 수 있다. 이 에 따라, 단계 810, 단계 820, 및 단계 830의 결과로, 일련의 명령이 복수의 그룹의 서브시리즈 명령으로 나누 어질 수 있다. 앞서 설명한 바와 같이, 단계 820은 서로 다른 그룹 사이의 데이터 전송이 모두 동기화 되게 할 수 있다. 단계 840에서, 프로세서는 복수의 그룹의 서브시리즈 명령의 각각에 상응하는 머신 코드를 생성할 수 있다. 예 를 들어, 서브시리즈 명령을 나타내는 고수준 코드는 상응하는 프로세서 서브유닛에 의해 실행 가능한 머신 코 드와 같은 저수준 코드로 변환될 수 있다. 단계 850에서, 프로세서는 복수의 그룹의 서브시리즈 명령의 각각에 상응하는 생성된 머신 코드를 상기 분할에 따라 복수의 프로세서 서브유닛의 상응하는 프로세서 서브유닛에 배정할 수 있다. 예를 들어, 프로세서는 각 서브시리즈 명령에 상응하는 프로세서 서브유닛의 식별자를 붙일 수 있다. 따라서, 서브시리즈 명령이 실행을 위 해 메모리 칩에 업로드 되는 경우에(예, 도 3a의 호스트에 의해), 각 서브시리즈는 적절한 프로세서 서브 유닛을 설정할 수 있다. 일부 실시예에서, 일련의 명령과 연관된 작업을 프로세서 서브유닛의 서로 다른 프로세서 서브유닛에 배정하는 것은 적어도 부분적으로는 메모리 칩 상의 둘 이상의 프로세서 서브유닛 사이의 공간적 근접성에 의존할 수 있 다. 예를 들어, 앞서 설명한 바와 같이, 프로세서 서브유닛 사이의 데이터 전송의 수를 감소하면 효율성이 향상 될 수 있다. 이에 따라, 프로세서는 둘 이상의 프로세서 서브유닛을 통해 데이터를 이동하는 데이터 전송을 최 소화할 수 있다. 따라서, 프로세서는 인접 전송을 최대화하고(적어도 국부적으로) 이웃하지 않는 프로세서 서브 유닛으로의 전송을 최소화하는(적어도 국부적으로) 방식으로 서브시리즈를 프로세서 서브유닛으로 배정하기 위 하여 메모리 칩의 알려진 레이아웃을 하나 이상의 최적화 알고리즘(예, 그리디 알고리즘(greedy algorithm))과 병합하여 활용할 수 있다. 방법은 본 기재의 메모리 칩에 대한 추가적인 최적화를 포함할 수 있다. 예를 들어, 프로세서는 상기 분할 에 의거하여 일련의 명령과 연관된 데이터를 분류하고 이러한 분류에 따라 데이터를 메모리 뱅크에 배정할 수 있다. 이에 따라, 메모리 뱅크는 각 메모리 뱅크의 전용인 각 프로세서 서브유닛에 배정된 서브시리즈 명령에 사용되는 데이터를 보유할 수 있다. 일부 실시예에서, 데이터의 분류는 둘 이상의 메모리 뱅크로 복제될 데이터의 적어도 일부를 판단하는 작업을 포함할 수 있다. 예를 들어, 앞서 설명한 바와 같이, 일부 데이터는 하나 이상의 서브시리즈 명령에서 사용될 수 있다. 이러한 데이터는 서로 다른 서브시리즈 명령이 배정된 복수의 프로세서 서브유닛 전용의 메모리 뱅크 에 복제될 수 있다. 이러한 최적화는 프로세서 서브유닛 간의 데이터 전송을 더 감소시킬 수 있다. 방법의 출력은 실행을 위한 본 기재의 메모리 칩으로의 입력일 수 있다. 예를 들어, 메모리 칩은 적어도 하나의 전용 메모리 뱅크에 각각 연결된 복수의 프로세서 서브유닛과 이에 상응하는 복수의 메모리 뱅크를 포함 할 수 있고, 메모리 칩의 프로세서 서브유닛은 방법에 의해 생성된 머신 코드를 실행하도록 구성될 수 있 다. 도 3a를 참조하여 설명한 바와 같이, 호스트는 방법에 의해 생성된 머신 코드를 프로세서 서브유 닛에 입력하여 실행할 수 있다. 서브뱅크와 서브컨트롤러 기존의 메모리 뱅크에서, 컨트롤러는 뱅크 레벨에서 제공된다. 각 뱅크는 전형적으로 장방형으로 배치되지만 이 외의 기타 모든 기하 형상으로 배치될 수 있는 복수의 매트(mat)를 포함한다. 각 매트는 역시 전형적으로 장방 형으로 배치되지만 이 외의 기타 모든 기하 형상으로 배치될 수 있는 복수의 메모리 셀을 포함한다. 각 셀은 (셀이 고압 또는 저압으로 유지되는지 등에 따라) 단일 비트의 데이터를 저장할 수 있다. 이러한 기존의 아키텍처의 예가 도 9와 도 10에 도시되어 있다. 도 9에 도시된 바와 같이, 뱅크 레벨에서, 복수 의 매트(예, 매트(930-1, 930-2, 940-1, 940-2))가 뱅크를 형성할 수 있다. 기존의 장방형 구조에서, 뱅 크는 글로벌 워드라인(예, 워드라인)과 글로벌 비트라인(예, 비트라인)으로 제어될 수 있다. 이 에 따라, 로우 디코더는 입력되는 제어 신호(예, 주소에서 읽기 요청, 주소로 쓰기 요청 등)에 의거하여 정확한 워드라인을 선택할 수 있고, 글로벌 센스 증폭기(global sense amplifier, 920)(및/또는 도 9에는 도시 되지 않은 글로벌 컬럼 디코더)는 제어 신호에 의거하여 정확한 비트라인을 선택할 수 있다. 증폭기는 또 한, 읽기 동작 중에 선택된 뱅크에서 전압 레벨을 증폭할 수 있다. 도면에는 초기 선택을 위해 로우 디코더를 사용하고 컬럼을 따라 증폭을 수행하는 것으로 도시되어 있지만, 뱅크는 추가적으로 또는 대안적으로 컬럼 디코 더를 사용하여 초기 선택을 하고 로우를 따라 증폭을 수행할 수 있다. 도 10은 매트의 일례를 도시한 것이다. 예를 들어, 매트는 도 9의 뱅크와 같은 메모리 뱅크의 일부를 형성할 수 있다. 도 10에 도시된 바와 같이, 복수의 셀(예, 1030-1, 1030-2, 1030-3)이 매트를 형성할 수 있다. 각 셀은 커패시터, 트랜지스터, 또는 적어도 1비트의 데이터를 저장하는 기타 회로를 포함할 수 있다. 예를 들어, 셀은 하전되어 '1'을 나타내고 방전되어 '0'을 나타내는 커패시터를 포함하거나 '1'을 나 타내는 제1 상태와 '0'을 나타내는 제2 상태를 포함하는 플립플롭(flip-flop)을 포함할 수 있다. 기존의 매트는 예를 들어 512비트 x 512비트를 포함할 수 있다. 매트가 MRAM, ReRAM 등의 일부를 형성하는 실시예에서, 셀은 트랜지스터, 저항기, 커패시터, 또는 적어도 1비트의 데이터를 저장하는 물질의 이온 또는 일부를 분리하 는 기타 메커니즘을 포함할 수 있다. 예를 들어, 셀은 제1 상태가 '1'을 나타내고 제2 상태가 '0'을 나타내는 전해질 이온, 칼코겐화 유리(chalcogenide glass) 등을 포함할 수 있다. 도 10에 더 도시된 바와 같이, 기존의 장방형 구조에서, 매트는 로컬 워드라인(예, 워드라인)과 로 컬 비트라인(예, 비트라인)에 걸쳐 제어될 수 있다. 이에 따라, 워드라인 드라이버(예, 워드라인 드라이 버(1020-1, 1020-2, . . . , 1020-x))가 선택된 워드라인을 제어하여, 매트가 그 일부를 형성하는 메모 리 뱅크와 연관된 컨트롤러로부터의 제어 신호(예, 주소에서 읽기 요청, 주소로 쓰기 요청, 리프레쉬 신호 등) 에 의거하여 읽기, 쓰기, 또는 리프레쉬를 수행할 수 있다. 또한, 로컬 센스 증폭기(예, 로컬 증폭기(1010-1, 1010-2, . . . , 1010-x)) 및/또는 로컬 컬럼 디코더(도 10에는 미도시)가 선택된 비트라인을 제어하여 읽기, 쓰기, 또는 리프레쉬를 수행할 수 있다. 로컬 센스 증폭기는 또한 선택된 셀의 전압 레벨을 읽기 동작 동안에 증폭할 수 있다. 도면에는 초기 선택에 워드라인 드라이버를 사용하고 컬럼을 따라 증폭을 수행하는 것으로 도 시되어 있지만, 매트는 초기 선택에 비트라인 드라이버를 사용하고 로우를 따라 증폭을 수행할 수도 있다. 앞서 설명한 바와 같이, 많은 수의 매트가 복제되어 메모리 뱅크를 형성한다. 메모리 뱅크는 그룹으로 묶여서 메모리 칩을 형성할 수 있다. 예를 들어, 메모리 칩은 8개 내지 32개의 메모리 뱅크를 포함할 수 있다. 이에 따 라, 기존의 메모리 칩 상에서 프로세서 서브유닛과 메모리 뱅크를 페어링한 결과로 8 내지 32 프로세서 서브유 닛만이 형성된다. 이에 따라, 본 기재의 실시예는 추가적인 서브뱅크(sub-bank) 체계를 가진 메모리 칩을 포함 할 수 있다. 본 기재의 이러한 메모리 칩은 따라서 프로세서 서브유닛과 페어링 된 전용 메모리 뱅크로 사용되 는 메모리 서브뱅크를 가진 프로세서 서브유닛을 포함할 수 있다. 이에 따라, 더 많은 수의 서브 프로세서(sub processor)가 가능하고, 메모리 내 연산의 병렬 수행과 성능을 향상할 수 있다. 본 기재의 일부 실시예에서, 뱅크의 글로벌 로우 디코더와 글로벌 센스 증폭기는 서브뱅크 컨트롤러로 대 체할 수 있다. 이에 따라, 메모리 뱅크의 글로벌 로우 디코더와 글로벌 센스 증폭기로 제어 신호를 보내지 않고, 메모리 뱅크의 컨트롤러는 제어 신호를 적합한 서브뱅크 컨트롤러로 보낼 수 있다. 제어 신호를 보내는 방향은 동적으로 제어되거나 하드웨어에 내장(예, 하나 이상의 논리 게이트를 통해)될 수 있다. 일부 실시예에 서, 퓨즈를 사용하여 각 서브뱅크 또는 매트의 컨트롤러가 제어 신호를 해당 서브뱅크 또는 매트로 통과시키거 나 차단하도록 지시할 수 있다. 따라서, 이러한 실시예에서, 퓨즈를 사용하여 불량 서브뱅크가 비활성화될 수 있다. 이러한 실시예의 일례에서, 메모리 칩은 복수의 메모리 뱅크를 포함할 수 있고, 각 메모리 뱅크는 뱅크 컨트롤 러와 복수의 메모리 서브뱅크를 포함할 수 있고, 각 메모리 서브뱅크는 메모리 서브뱅크 상의 각 위치로 읽기와 쓰기가 가능하도록 하는 서브뱅크 로우 디코더와 서브뱅크 컬럼 디코더를 포함할 수 있다. 각 서브뱅크는 복수 의 메모리 매트를 포함할 수 있고, 각 메모리 매트는 복수의 메모리 셀을 포함할 수 있고 내부적으로 로컬 로우 (row) 디코더, 컬럼(column) 디코더, 및/또는 로컬 센스 증폭기를 포함할 수 있다. 서브뱅크 로우(row) 디코더 와 서브뱅크 컬럼(column) 디코더는 뱅크 컨트롤러의 읽기 및 쓰기 요청 또는 하기에 설명하는 서브뱅크 메모리 상의 메모리 내 계산에 사용되는 서브뱅크 프로세서 서브유닛의 읽기 및 쓰기 요청을 처리할 수 있다. 추가적으 로, 각 메모리 서브뱅크는 뱅크 컨트롤러의 읽기 요청과 쓰기 요청을 처리할지 여부 및/또는 이러한 요청을 다 음 레벨(예, 매트 상의 로우 디코더 및 컬럼 디코더의 레벨)로 송부할지 또는 이러한 요청을 차단할지, 예를 들 어, 내부 처리 소자 또는 프로세서 서브유닛이 메모리에 접속하게 허용할지, 여부를 판단하도록 구성된 컨트롤 러를 더 포함할 수 있다. 일부 실시예에서, 뱅크 컨트롤러는 시스템 클럭(system clock)에 동기화될 수 있다. 그러나 서브뱅크 컨트롤러는 시스템 클럭에 동기화되지 않을 수 있다. 앞서 설명한 바와 같이, 서브뱅크를 사용하면, 프로세서 서브유닛이 기존 칩의 메모리 뱅크와 쌍을 이룬 경우보 다 더 많은 수의 프로세서 서브유닛을 메모리 칩에 포함시킬 수 있다. 이에 따라, 각 서브뱅크는 서브뱅크를 전 용 메모리로 사용하는 프로세서 서브유닛을 더 포함할 수 있다. 앞서 설명한 바와 같이, 프로세서 서브유닛은 RISC, CISC, 또는 기타 범용 프로세서 서브유닛을 포함 및/또는 하나 이상의 가속기를 포함할 수 있다. 또한, 프로세서 서브유닛은 앞서 설명한 바와 같이 어드레스 생성기를 포함할 수 있다. 앞서 설명한 모든 실시예에서, 각 프로세서 서브유닛은 뱅크 컨트롤러를 사용하지 않고 서브뱅크의 로우 디코더와 컬럼 디코더를 사용하여 프 로세서 서브유닛 전용의 서브뱅크에 접속하도록 구성될 수 있다. 서브 뱅크와 연관된 프로세서 서브유닛은 또한 메모리 매트를 취급(하기에 설명하는 디코더 및 메모리 중복 메커니즘 포함) 및/또는 상위 레벨(예, 뱅크 레벨 또는 메모리 레벨)의 읽기 및 쓰기 요청이 이에 부응하여 전송 및 취급되는지 여부를 판단할 수 있다. 일부 실시예에서, 서브뱅크 컨트롤러는 서브뱅크의 상태를 저장하는 레지스터를 더 포함할 수 있다. 이에 따라, 서브뱅크가 사용중인 것으로 레지스터가 나타내는 가운데 서브뱅크 컨트롤러가 메모리 컨트롤러로부터 제어 신 호를 수신하는 경우에, 서브뱅크 컨트롤러는 오류임을 출력할 수 있다. 각 서브뱅크가 프로세서 서브유닛을 더 포함하는 실시예에서, 서브뱅크의 프로세서 서브유닛이 메모리 컨트롤러로부터의 외부 요청에 상충하여 메모리에 접속하는 경우, 레지스터는 오류임을 나타낼 수 있다. 도 11은 서브뱅크 컨트롤러를 사용하는 메모리 뱅크의 다른 실시예의 일례를 도시한 것이다. 도 11의 예에서, 뱅크는 로우 디코더, 뱅크 디코더, 및 서브뱅크 컨트롤러(예, 컨트롤러(1130a, 1130b, 1130c))가 있는 복수의 메모리 서브뱅크(예, 서브뱅크(1170a, 1170b, 1170c))를 포함한다. 서브뱅크 컨트롤러는 서브뱅크 컨트롤러의 제어를 받는 하나 이상의 서브뱅크로 요청을 전달할지 여부를 판단할 수 있는 어드레스 리 졸버(address reolver; 예, 리졸버(1140a, 1140b, 1140c))를 포함할 수 있다. 서브뱅크 컨트롤러는 하나 이상의 논리(logic) 회로(예, 회로(1150a, 1150b, 1150c))를 더 포함할 수 있다. 예 를 들어, 하나 이상의 처리 소자를 포함하는 논리 회로는 서브뱅크의 셀을 리프레쉬하는 동작, 서브뱅크의 셀을 비우는 동작 등과 같은 하나 이상의 동작이 뱅크의 외부에서 요청을 처리하지 않고 수행되도록 할 수 있 다. 또는, 논리 회로는 앞서 설명한 바와 같은 프로세서 서브유닛을 포함하여 서브뱅크 컨트롤러에 의해 제어되 는 모든 서브뱅크가 프로세서 서브유닛의 상응하는 전용 메모리가 되도록 할 수 있다. 도 11의 예에서, 논리 (1150a)의 상응하는 전용 메모리는 서브뱅크(1170a)이고, 논리(1150b)의 상응하는 전용 메모리는 서브뱅크 (1170b)이고, 논리(1150c)의 상응하는 전용 메모리는 서브뱅크(1170c)이다. 앞서 설명한 모든 실시예에서, 논리 회로에는 서브뱅크로 연결하는 버스, 예를 들어, 버스(1131a, 1131b, 1131c)가 있다. 도 11에 도시된 바와 같이, 서브뱅크 컨트롤러 각각은 처리 소자 또는 프로세서 서브유닛에 의한 또는 명령을 발생하는 고수준 메모 리 컨트롤러에 의한 메모리 뱅크 상의 위치에 읽기와 쓰기가 가능하게 하는 서브뱅크 로우 디코더와 서브뱅크 컬럼 디코더와 같은 복수의 디코더를 포함할 수 있다. 예를 들어, 서브뱅크 컨트롤러(1130a)는 디코더(1160a, 1160b, 1160c)를 포함하고, 서브뱅크 컨트롤러(1130b)는 디코더(1160d, 1160e, 1160f)를 포함하고, 서브뱅크 컨트롤러(1130c)는 디코더(1160g, 1160h, 1160i)를 포함한다. 뱅크 로우 디코더의 요청에 의거하여, 서브 뱅크 컨트롤러는 서브뱅크 컨트롤러에 포함된 디코더를 사용하여 워드라인을 선택할 수 있다. 여기에 설명한 시 스템은 서브뱅크의 처리 소자 또는 프로세서 서브유닛이 다른 뱅크 및 다른 서브뱅크마저도 간섭하지 않으면서 메모리에 접속할 수 있게 하고, 이에 따라 각 서브뱅크 프로세서 서브유닛은 다른 서브뱅크 서브유닛과 병렬로 메모리 계산을 할 수 있다. 또한, 각 서브뱅크는 복수의 메모리 셀을 각각 포함하는 복수의 메모리 매트를 포함할 수 있다. 예를 들어, 서 브뱅크(1170a)는 매트(1190a-1, 1190a-2, . . . , 1190a-x)를 포함하고, 서브뱅크(1170b)는 매트(1190b-1, 1190b-2, . . . , 1190b-x)를 포함하고, 서브뱅크(1170c)는 매트(1190c-1, 1190c-2, . . . , 1190c-x)를 포함 한다. 또한, 도 11에 도시된 바와 같이, 각 서브뱅크는 적어도 하나의 디코더를 포함할 수 있다. 예를 들어, 서 브뱅크(1170a)는 디코더(1180a)를 포함하고, 서브뱅크(1170b)는 디코더(1180b)를 포함하고, 서브뱅크(1170c)는 디코더(1180c)를 포함한다. 이에 따라, 뱅크 컬럼 디코더는 외부 요청에 의거하여 글로벌 비트라인(예, 1121a 또는 1121b)을 선택할 수 있는 반면에 뱅크 로우 디코더에 의해 선택된 서브뱅크는 컬럼 디코더를 활용하여 이 서브뱅크가 전용인 논리 회로의 로컬 요청에 의거한 로컬 비트라인(예, 1181a 또는 1181b)을 선택 할 수 있다. 이에 따라, 각 프로세서 서브유닛은 뱅크 로우 디코더와 뱅크 컬럼 디코더를 사용하지 않고 서브 뱅크의 로우 디코더와 컬럼 디코더를 활용하여 프로세서 서브유닛의 전용 서브 뱅크에 접근하도록 구성될 수 있 다. 따라서, 각 프로세서 서브유닛은 다른 서브뱅크를 간섭하지 않으면서 상응하는 서브뱅크에 접근할 수 있다. 또한, 서브뱅크로의 요청이 프로세서 서브유닛의 외부에서 이루어지는 경우에, 서브뱅크 디코더는 접속된 데이 터를 뱅크 디코더에 반영할 수 있다. 또는, 각 서브뱅크에 단일 행의 메모리 뱅크만이 있는 실시예에서, 로컬 비트라인은 서브뱅크의 비트라인이 아닌 매트의 비트라인일 수 있다. 도 11에 도시된 실시예의 서브뱅크 로우 디코더와 서브뱅크 컬럼 디코더를 사용하는 실시예의 조합도 사용될 수 있다. 예를 들어, 뱅크 로우 디코더가 제거되지만 뱅크 컬럼 디코더는 유지하고 로컬 비트라인을 사용할 수 있 다. 도 12는 복수의 매트를 포함하는 메모리 서브뱅크의 실시예의 일례를 도시한 것이다. 예를 들어, 서브뱅 크는 도 11의 서브뱅크의 일부분을 나타내거나 메모리 뱅크가 다르게 구현된 것을 나타내는 것일 수 있다. 도 12의 예에서, 서브뱅크는 복수의 매트(예, 1240a, 1240b)를 포함한다. 또한, 각 매트는 복수 의 셀을 포함할 수 있다. 예를 들어, 매트(1240a)는 셀(1260a-1, 1260a-2, . . . , 1260a-x)을 포함하고, 매트 (1240b)는 셀(1260b-1, 1260b-2, . . . , 1260b-x)을 포함한다. 각 매트에는 매트의 메모리 셀에 배정될 주소의 범위가 배정될 수 있다. 이러한 주소는 매트가 이리저리 옮겨질 수 있고 결함이 있는 매트는 비활성화되고 사용되지 않도록(예, 하기에 설명하는 바와 같이, 하나 이상의 퓨즈 사용) 제조시에 설정될 수 있다. 서브뱅크는 메모리 컨트롤러로부터 읽기와 쓰기 요청을 수신한다. 도 12에는 도시되어 있지 않지만, 메모리 컨트롤러로부터의 요청은 서브뱅크의 컨트롤러를 통해 필터링 되고 주소 결정을 위 해 서브뱅크의 적절한 매트로 보내질 수 있다. 대안적으로, 메모리 컨트롤러의 요청의 주소의 적어 도 일부분(예, 높은 비트)이 서브뱅크의 모든 매트(예, 1240a, 1240b)로 전송되어 매트의 배정된 주소 범 위가 명령에 특정된 주소를 포함하는 경우에만 주소와 연관된 요청과 전체 주소를 처리하도록 할 수 있다. 상기 의 서브뱅크 지시와 유사하게, 매트 판단은 동적으로 제어되거나 하드웨어에 내장될 수 있다. 일부 실시예에서, 퓨즈를 사용하여 각 매트에 대한 주소 범위를 판단할 수 있고, 또한 불법 주소 범위를 배정함으로써 불량 매트 를 비활성화할 수 있다. 매트는 일반적인 기타 방법이나 퓨즈 연결에 의해 추가적으로 또는 대안적으로 비활성 화될 수 있다. 앞서 설명한 모든 실시예에서, 서브뱅크의 각 매트는 매트에서 워드라인을 선택하기 위한 로우 디코더(예, 1230a, 1230b)를 포함할 수 있다. 일부 실시예에서, 각 매트는 퓨즈 및 비교기(예, 1220a, 1220b)를 더 포함할 수 있다. 앞서 설명한 바와 같이, 비교기는 각 매트가 입력되는 요청을 처리할지 여부를 판단하게 할 수 있고, 퓨즈는 각 매트가 불량인 경우 비활성화 되게 할 수 있다. 대안적으로, 뱅크 및/또는 서브뱅크의 로우 디코더가 각 매트의 로우 디코더 대신에 사용될 수 있다. 또한, 앞서 설명한 모든 실시예에서, 해당 매트에 포함된 컬럼 디코더(예, 1250a, 1250b)는 로컬 비트라인(예, 1251, 1253)을 선택할 수 있다. 로컬 비트라인은 메모리 뱅크의 글로벌 비트라인에 연결될 수 있다. 서브뱅크에 자체의 로컬 비트라인이 있는 실시예에서, 셀의 로컬 비트라인은 서브뱅크의 로컬 비트라인으로 더 연결될 수 있다. 이에 따라, 선택된 셀의 데이터는 셀의 컬럼 디코더(및/또는 센스 증폭기)를 통한 후에 서브뱅크의 컬럼 디코더(및/또는 센스 증폭기)를 통하고(서브뱅크 컬럼 디코더 및/또는 센스 증폭기를 포함하는 실시예에서) 그 후에 뱅크의 컬럼 디코더(및/또는 센스 증폭기)를 통해 읽어질 수 있다. 매트는 복제되고 어레이로 배열되어 메모리 뱅크(또는 메모리 서브뱅크)를 형성할 수 있다. 예를 들어, 본 기재의 메모리 칩은 복수의 메모리 뱅크를 포함할 수 있고, 각 메모리 뱅크에는 복수의 메모리 서브뱅크가 있고, 각 메모리 서브뱅크에는 메모리 서브뱅크 상의 각 위치로 읽기와 쓰기를 처리하기 위한 서브뱅크 컨트롤 러가 있다. 또한, 각 메모리 서브뱅크는 복수의 메모리 매트를 포함할 수 있고, 각 메모리 매트에는 복수의 메 모리 셀과 매트 로우 디코더와 매트 컬럼 디코더(도 12에 도시)가 있다. 매트 로우 디코더와 매트 컬럼 디코더 는 서브뱅크 컨트롤러로부터의 읽기와 쓰기 요청을 처리할 수 있다. 예를 들어, 매트 디코더는 모든 요청을 수 신하고 요청을 처리할지 여부를 각 매트의 알려진 주소 범위에 의거하여 판단(예, 비교기를 활용)하거나, 서브 뱅크(또는 뱅크) 컨트롤러에 의한 매트 선택에 의거하여 알려진 주소 범위 이내의 요청 만을 수신할 수 있다. 컨트롤러 데이터 전송 본 기재의 메모리 칩은 또한 프로세서 서브유닛을 활용하여 데이터를 공유하는 것 외에도 메모리 컨트롤러(또는 서브뱅크 컨트롤러 또는 매트 컨트롤러)를 활용하여 데이터를 공유할 수 있다. 예를 들어, 본 기재의 메모리 칩 은 메모리 뱅크의 각 위치로 읽기와 쓰기가 가능하도록 하는 뱅크 컨트롤러, 로우 디코더, 및 컬럼 디코더를 각 각 포함하는 복수의 메모리 뱅크(예, SRAM 뱅크, DRAM 뱅크 등)와 복수의 뱅크 컨트롤러의 각 컨트롤러를 복수 의 뱅크 컨트롤러의 적어도 하나의 다른 컨트롤러에 연결하는 복수의 버스를 포함할 수 있다. 일부 실시예에서, 복수의 버스는 하나 이상의 프로세서 서브유닛에 연결된 메모리 뱅크의 메인 버스 상의 데이 터 전송의 방해 없이 접근될 수 있다. 이에 따라, 메모리 뱅크(또는 서브뱅크)는 다른 메모리 뱅크(또는 서브뱅 크)와의 데이터 전송 또는 수신과 동일한 클럭 사이클로 상응하는 프로세서 서브유닛과 데이터를 전송 또는 수 신할 수 있다. 각 컨트롤러가 복수의 다른 컨트롤러에 연결된 실시예에서, 컨트롤러는 데이터의 전송 또는 수신 을 위해 복수의 다른 컨트롤러의 하나의 다른 컨트롤러를 선택하도록 구성될 수 있다. 일부 실시예에서, 각 컨 트롤러는 적어도 하나의 이웃하는 컨트롤러에 연결될 수 있다(예, 공간적으로 인접하는 컨트롤러의 쌍들이 서로 연결될 수 있다). 메모리 회로의 리던던트 로직 본 기재는 온칩(on-chip) 데이터 프로세싱을 위한 프라이머리 논리부(primary logic portions)가 있는 메모리 칩에 관한 것이다. 메모리 칩은 불량 프라이머리 논리부를 교체하여 칩의 제조 수율을 증가시킬 수 있는 리던던 트 논리부(redundant logic portions)를 포함할 수 있다. 따라서, 칩은 논리부의 개별 검사에 의거한 메모리 칩 의 로직 블록의 설정을 가능하게 하는 온칩 요소를 포함할 수 있다. 메모리 칩은 논리부 전용의 영역이 클수록 제조 오류의 영향을 더 많이 받기 때문에 칩의 이러한 특징은 수율을 향상할 수 있다. 예를 들어, 리던던트 논리부가 큰 DRAM 메모리 칩은 수율을 감소시키는 제조 문제의 영향을 많이 받을 수 있다. 그러나 리던던트 논리 부를 구현하면 고도의 병렬성 능력을 유지하면서도 DRAM 메모리 칩의 생산자나 사용자가 전체 논리부를 켜거나 끌 수 있게 해주기 때문에 수율과 신뢰성이 향상되는 결과를 얻을 수 있다. 본 기재에서, 기재된 실시예의 설명 의 편의상 특정 메모리 유형(예, DRAM)의 예를 들 수 있다. 그렇다고 하더라도, 본 기재가 특정된 메모리 유형 으로 한정되는 것은 아니라는 점은 당연하다 할 것이다. 오히려, 본 기재의 일부 부분에서 예로 든 메모리 유형 이 적다고 하더라도, 기재된 실시예와 함께 DRAM, 플래시메모리, SRAM, ReRAM, PRAM, MRAM, ROM, 또는 기타 모 든 메모리와 같은 메모리 유형이 사용될 수 있다. 도 13은 본 기재에 따른 예시적인 메모리 칩의 구성도이다. 메모리 칩은 DRAM 메모리 칩으로 구현 될 수 있다. 메모리 칩은 또한 플래시메모리, SRAM, ReRAM, PRAM, 및/또는 MRAM 등과 같은 모든 유형의 휘발성 또는 비휘발성 메모리로 구현될 수 있다. 메모리 칩은 어드레스 매니저, 복수의 메모리 뱅 크(1304(a,a) 내지 1304(z,z))를 포함하는 메모리 어레이, 메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직이 배치된 기판을 포함할 수 있다. 메모리 로직과 비즈니스 로직 은 프라이머리 로직 블록을 구성할 수 있는 반면, 리던던트 비즈니스 로직은 리던던트 블록을 구성 할 수 있다. 또한, 메모리 칩은 비활성화 스위치와 활성화 스위치가 포함될 수 있는 설정 스 위치를 포함할 수 있다. 비활성화 스위치와 활성화 스위치도 기판에 배치될 수 있다. 본 출 원에서, 메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직은 또한 집합적으로 '로직 블록'으로 칭해질 수 있다. 어드레스 매니저는 로우 디코더 및 컬럼 디코더 또는 기타 유형의 메모리 보조장치를 포함할 수 있다. 대 안적으로 또는 추가적으로, 어드레스 매니저는 마이크로컨트롤러 또는 처리부를 포함할 수 있다. 일부 실시예에서, 도 13에 도시된 바와 같이, 메모리 칩은 복수의 메모리 블록을 2차원 어레이로 기판 상에 배치할 수 있는 단일 메모리 어레이를 포함할 수 있다. 그러나 다른 실시예에서, 메모리 칩 은 다수의 메모리 어레이를 포함할 수 있고, 각각의 메모리 어레이는 서로 다른 구성으로 메 모리 블록을 배치할 수 있다. 예를 들어, 메모리 어레이 중의 적어도 한 어레이의 메모리 블록(즉, 메모리 뱅크)이 방사형 분포로 배치되어 어드레스 매니저 또는 메모리 로직으로부터 메모리 블록으로의 라 우팅을 가능하게 할 수 있다. 비즈니스 로직은 메모리 자체의 관리에 사용되는 논리와 무관한 어플리케이션의 메모리 내 계산(in- memory computation)을 위해 사용될 수 있다. 예를 들어, 비즈니스 로직은 활성화 함수로 사용되는 플로 팅, 정수, 또는 MAC 연산과 같은 AI에 관한 함수를 이행할 수 있다. 또한, 비즈니스 로직은 min, max, sort, count 등과 같은 데이터베이스 관련 함수를 이행할 수 있다. 메모리 로직은 읽기, 쓰기, 리프레쉬 동작 등을 포함하는 메모리 관리에 관한 작업을 수행할 수 있다. 따라서, 비즈니스 로직은 뱅크 레벨, 매트 레 벨, 매트 레벨의 그룹 중의 하나 이상에 추가될 수 있다. 비즈니스 로직에는 하나 이상의 어드레스 출력 과 하나 이상의 데이터 입력/출력이 있을 수 있다. 예를 들어, 비즈니스 로직은 로우/컬럼 라인에 의해 어드레스 매니저로 어드레스 할 수 있다. 그러나 일부 실시예에서, 데이터 입력/출력을 통해 로직 블록이 추가적으로 또는 대안적으로 어드레스 될 수 있다. 리던던트 비즈니스 로직은 비즈니스 로직의 복제일 수 있다. 또한, 리던던트 비즈니스 로직 은 작은 퓨즈/안티퓨즈(anti-fuse)를 포함할 수 있는 비활성화 스위치 및/또는 활성화 스위치에 연 결될 수 있고, 인스턴스 중의 하나(예, 디폴트로 연결되는 인스턴스)를 비활성화 또는 활성화하는 논리에 사용 되고 다른 로직 블록 중의 하나(예, 디폴트로 연결 해제되는 인스턴스)를 활성화할 수 있다. 일부 실시예에서, 하기에 도 15를 참조하여 설명하는 바와 같이, 블록의 중복성은 비즈니스 로직과 같은 로직 블록 이내에 국한될 수 있다. 일부 실시예에서, 메모리 칩의 로직 블록은 전용 버스로 메모리 어레이의 서브세트에 연결될 수 있 다. 예를 들어, 메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직의 세트는 메모리 어레이의 메모리 블록(즉, 1304 (a,a) 내지 1304 (a,z))의 제1행에 연결될 수 있다. 전용 버스는 연관된 로직 블록이 어드레스 매니저 등을 통하여 통신 라인을 개설할 필요없이 메모리 블록으로부터 데이터에 신속히 접속하게 해줄 수 있다. 복수의 프라이머리 로직 블록의 각각은 복수의 메모리 뱅크의 적어도 하나에 연결될 수 있다. 또한, 리던 던트 비즈니스 블록과 같은 리던던트 블록은 메모리 인스턴스(1304(a,a)-(z,z))의 적어도 하나에 연결될 수 있다. 리던던트 블록은 메모리 로직 또는 비즈니스 로직과 같은 복수의 프라이머리 로직 블록의적어도 하나를 복제할 수 있다. 비활성화 스위치는 복수의 프라이머리 로직 블록의 적어도 하나에 연결될 수 있고, 활성화 스위치는 복수의 리던던트 블록의 적어도 하나에 연결될 수 있다. 이러한 실시예에서, 복수의 프라이머리 로직 블록(메모리 로직 및/또는 비즈니스 로직)의 하나와 연관된 결함이 검출되면, 비활성화 스위치는 복수의 프라이머리 로직 블록의 하나를 비활성화하도록 구성 될 수 있다. 동시에, 활성화 스위치는 복수의 프라이머리 로직 블록의 하나를 복제하는 리던던트 로직 블 록과 같은 복수의 리던던트 블록의 하나를 활성화하도록 구성될 수 있다. 또한, 집합적으로 '설정 스위치'로 불릴 수 있는 활성화 스위치와 비활성화 스위치는 스위치의 상 태를 설정하는 외부 입력을 포함할 수 있다. 예를 들어, 활성화 스위치는 외부 입력의 활성화 신호가 스 위치가 닫힌 상태를 유발하도록 설정될 수 있고, 비활성화 스위치는 외부 입력의 비활성화 신호가 스위치 가 열린 상태를 유발하도록 설정될 수 있다. 일부 실시예에서, 메모리 칩의 모든 설정 스위치는 디폴트로 비활성화 상태이고, 검사의 결과가 관련 로직 블록이 기능을 하는 것으로 나타내고 신호가 외부 입력에 주어진 이후에 활성화될 수 있다. 또는, 일부의 경우, 메모리 칩의 모든 설정 스위치는 디폴트로 활성화 상태이 고, 검사의 결과가 관련 로직 블록이 기능을 하지 않는 것으로 나타내고 비활성화 신호가 외부 입력에 주어진 이후에 비활성화될 수 있다. 설정 스위치가 초기에 활성화이거나 비활성화인지 여부와 상관없이, 관련 로직 블록과 연관된 결함이 검출되면, 설정 스위치는 관련 로직 블록을 비활성화할 수 있다. 설정 스위치가 초기에 활성화되어 있는 경우, 설정 스위 치의 상태는 관련 로직 블록을 비활성화하기 위하여 비활성화로 변경될 수 있다. 설정 스위치가 초기에 비활성 화되어 있는 경우, 설정 스위치의 상태는 관련 로직 블록을 비활성화하기 위하여 비활성화 상태로 유지될 수 있 다. 예를 들어, 조작성 검사의 결과, 특정 로직 블록이 작동하지 않는 것으로 나오거나 특정 사양 내에서 작동 하지 않는 것으로 나올 수 있다. 이러한 경우, 로직 블록은 상응하는 설정 스위치를 활성화하지 않음으로써 비 활성화될 수 있다. 일부 실시예에서, 설정 스위치는 둘 이상의 로직 블록에 연결될 수 있고 서로 다른 로직 블록 사이에서 선택하 도록 구성될 수 있다. 예를 들어, 설정 스위치는 비즈니스 로직과 리던던트 로직 블록 모두에 연결 될 수 있다. 설정 스위치는 리던던트 로직 블록을 활성화하는 반면에 비즈니스 로직을 비활성화할 수 있다. 대안적으로 또는 추가적으로, 복수의 프라이머리 로직 블록의 적어도 하나(메모리 로직 및/또는 비즈니스 로직)가 제1 전용 연결로 복수의 메모리 뱅크 또는 메모리 인스턴스의 서브세트에 연결될 수 있다. 이후, 복수의 프라이머리 로직 블록의 적어도 하나를 복제하는 복수의 리던던트 블록의 적어도 하나(예, 리던던 트 비즈니스 블록)가 제2 전용 연결로 동일한 복수의 메모리 뱅크 또는 인스턴스의 서브세트에 연 결될 수 있다. 또한, 메모리 로직에는 비즈니스 로직과 다른 기능과 능력이 있을 수 있다. 예를 들어, 메모리 로 직은 메모리 뱅크에 읽기와 쓰기 동작이 가능하도록 설계될 수 있는 반면, 비즈니스 로직은 메모리 내 계산을 수행하도록 설계될 수 있다. 따라서, 비즈니스 로직이 제1 비즈니스 로직 블록을 포함 하고 비즈니스 로직이 제2 비즈니스 로직 블록(예, 리던던트 비즈니스 로직)을 포함하는 경우, 결 함이 있는 비즈니스 블록을 연결 해제하고 능력의 손실 없이 리던던트 비즈니스 로직에 다시 연결 하는 것이 가능하다. 일부 실시예에서, 설정 스위치(비활성화 스위치와 활성화 스위치 포함)는 퓨즈, 안티퓨즈, 또는 프 로그램 가능 장치(일회용 프로그램 가능 장치 포함), 또는 기타 형태의 비휘발성 메모리로 구현될 수 있다. 도 14는 기재된 실시예에 따른 예시적인 리던던트 로직 블록 세트의 구성도이다. 일부 실시예에서, 리던 던트 로직 블록 세트는 기판에 배치될 수 있다. 리던던트 로직 블록 세트는 스위치(1312, 1314)에 각각 연결된 비즈니스 로직과 리던던트 비즈니스 로직 중의 적어도 하나를 포함할 수 있다. 또한, 비즈니스 로직과 리던던트 비즈니스 로직은 어드레스 버스와 데이터 버스(140 4)에 연결될 수 있다. 일부 실시예에서, 도 14에 도시된 바와 같이, 스위치(1312, 1314)는 로직 블록을 클럭 노드에 연결할 수 있다. 이로써, 설정 스위치는 로직 블록을 클럭 신호와 연결 또는 해제할 수 있고, 그 결과로 로직 블록을 활성화 또 는 비활성화 할 수 있다. 그러나 다른 실시예에서, 스위치(1312, 1314)는 로직 블록을 다른 노드에 연결하여 활 성화 또는 비활성화 할 수 있다. 예를 들어, 설정 스위치는 로직 블록을 전압 공급 노드(예, VCC) 또는 접지 노드(예, GND) 또는 클럭 신호에 연결할 수 있다. 이로써, 설정 스위치는 개방 회로를 만들거나 로직 블록 전원을 차단할 수 있기 때문에 로직 블록은 설정 스위치에 의해 활성화 또는 비활성화 될 수 있다. 일부 실시예에서, 도 14에 도시된 바와 같이, 어드레스 버스와 데이터 버스는 서로 각각의 버스에 병렬로 연결된 로직 블록의 반대편에 있을 수 있다. 이로써, 서로 다른 온칩 요소의 라우팅이 로직 블록 세트 에 의해 가능해질 수 있다. 일부 실시예에서, 복수의 비활성화 스위치의 각각은 복수의 프라이머리 로직 블록의 적어도 하나를 클럭 노드와 결합하고, 복수의 활성화 스위치의 각각은 복수의 리던던트 블록의 적어도 하나를 클럭 노드와 결 합하여 클럭을 단순 활성화/비활성화 메커니즘으로 연결/해제할 수 있게 한다. 리던던트 로직 블록 세트의 리던던트 비즈니스 로직은 설계자가 복제할 가치가 있는 블록을 면적과 라우팅에 의거하여 선택할 수 있게 해준다. 예를 들어, 칩 설계자는 블록의 면적이 클수록 오류가 날 가능성이 크므로 면적이 큰 블록을 복제하기로 선택할 수 있다. 따라서, 칩 설계자는 면적이 큰 로직 블록을 복제하기로 결정할 수 있다. 반면, 설계자는 면적이 작은 블록은 공간의 상당한 손실 없이도 쉽게 복제가 되기 때문에 면적 이 작은 블록의 복제를 선호할 수도 있다. 또한, 도 14의 구성을 활용하여, 설계자는 면적당 오류의 통계에 따 라 로직 블록의 복제를 쉽게 선택할 수도 있다. 도 15는 기재된 실시예에 따른 예시적인 로직 블록의 구성도이다. 로직 블록은 비즈니스 로직 블록 및/또는 리던던트 비즈니스 로직 블록일 수 있다. 그러나 다른 실시예에서, 예시적인 로직 블록은 메모리 로직 또는 메모리 칩의 기타 요소일 수도 있다. 로직 블록은 작은 프로세서 파이프라인 이내에서 로직 중복성이 사용되는 또 다른 실시예를 제시한다. 로 직 블록은 레지스터, 페치(fetch) 회로, 디코더, 및 라이트백(write-back) 회로 를 포함할 수 있다. 또한, 로직 블록은 계산부 및 복제 계산부를 포함할 수 있다. 그 러나 다른 실시예에서, 로직 블록은 컨트롤러 파이프라인을 포함하지 않지만 요구되는 비즈니스 로직이 있는 산발적 처리 소자를 포함하는 기타 요소를 포함할 수 있다. 계산부와 복제 계산부는 디지털 계산의 수행이 가능한 디지털 회로를 포함할 수 있다. 예를 들어, 계산부와 복제 계산부는 이진수에 대한 산술과 비트 연산을 수행하는 산술논리부(arithmetic logic unit, ALU)를 포함할 수 있다. 또는, 계산부와 복제 계산부는 부동소수점수에 대한 연산을 수행하 는 부동소수점부(floating-point unit, FPU)를 포함할 수 있다. 또한, 일부 실시예에서, 계산부와 복제 계산부는 min, max, count, 및 compare 등과 같은 데이터베이스 관련 함수를 이행할 수 있다. 일부 실시예에서, 도 15에 도시된 바와 같이, 계산부와 복제 계산부는 스위칭 회로(1514, 1516)에 연결될 수 있다. 스위칭 회로는 활성화되는 경우에 계산부를 활성화 또는 비활성화 할 수 있다. 로직 블록에서, 복제 계산부는 계산부의 복제일 수 있다. 또한, 일부 실시예에서, 레지스터 , 페치 회로, 디코더, 및 라이트백 회로는(집합적으로 '로컬 논리부'라 칭함) 계산부 보다 크기가 작을 수 있다. 소자의 크기가 클수록 제조 과정에서 문제가 발생할 가능성이 크므로, 설계자 는 크기가 작은 요소(예, 로컬 논리부)보다는 크기가 큰 요소(예, 계산부)를 복제하기로 결정할 수 있다. 그러나 수율과 오류율의 기록에 따라, 설계자는 크기가 큰 요소에 추가적으로 또는 대안적으로 로컬 논리부를 (또는 전체 블록을) 복제하기로 선택할 수도 있다. 예를 들어, 계산부는 레지스터, 페치 회로 , 디코더, 및 라이트백 회로보다 크기가 클 수 있고, 따라서 오류 가능성이 클 수 있다. 설 계자는 로직 블록의 다른 요소보다는 계산부 또는 전체 블록을 복제하기로 선택할 수 있다. 로직 블록은 계산부와 복제 계산부의 적어도 하나에 각각 연결되는 복수의 로컬 설정 스위치 를 포함할 수 있다. 로컬 설정 스위치는 계산부에 결함이 검출되는 경우에 계산부를 비활성화하고 복제 계산부를 활성화 하도록 설정될 수 있다. 도 16은 기재된 실시예에 따른 버스로 연결된 예시적인 로직 블록의 구성도이다. 일부 실시예에서, 로직 블록 (예, 메모리 로직, 비즈니스 로직, 또는 리던던트 비즈니스 로직)은 서로 별개일 수 있고, 버스를 통해 연결될 수 있고, 외부에서 구체적으로 어드레스 함으로써 활성화될 수 있다. 예를 들어, 메 모리 칩은 각각의 ID 번호를 가진 여러 로직 블록을 포함할 수 있다. 그러나 다른 실시예에서, 로직 블록 은 메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직의 하나 이상이 포함된 더 큰 요소를 나타내는 것일 수 있다. 일부 실시예에서, 로직 블록의 각각은 다른 로직 블록과 중복될 수 있다. 모든 블록이 프라이머리 블록 또는 리던던트 블록으로 동작할 수 있는 이러한 완전한 중복성으로 인해 설계자는 칩의 전체적인 기능은 유지하면서 결함이 있는 요소의 연결을 해제할 수 있기 때문에 제조 수율을 향상할 수 있다. 예를 들어, 모든 복제 블록이 동일한 주소와 데이터 버스에 연결될 수 있기 때문에 설계자는 오류가 날 가능성이 높은 논리 영역 은 비활성화하면서 유사한 계산 능력을 유지할 능력이 있을 수 있다. 예를 들어, 로직 블록의 초기 수는 목표 능력보다 클 수 있다. 이후, 일부 로직 블록을 비활성화해도 목표 능력에 영향을 주지 않을 수 있다. 로직 블록에 연결된 버스는 어드레스 버스, 명령 라인, 및 데이터 라인을 포함할 수 있다. 도 16에 도시된 바와 같이, 로직 블록의 각각은 버스의 각 라인과 별개로 연결될 수 있다. 그러나 특정 실시예 에서, 로직 블록은 체계적 구조로 연결되어 라우팅을 가능하게 할 수 있다. 예를 들어, 버스의 각 라인은 라인을 다른 로직 블록으로 라우팅하는 멀티플렉서로 연결될 수 있다. 일부 실시예에서, 소자의 활성화/비활성화로 인해 변경될 수 있는 칩의 내부 구조를 몰라도 외부에서의 접근을 가능하게 하기 위하여, 로직 블록의 각각은 퓨즈드(fused) ID와 같은 퓨즈드 ID를 포함할 수 있다. 퓨즈 드 ID는 ID를 판단하고 관리 회로에 연결될 수 있는 스위치(예, 퓨즈)의 어레이를 포함할 수 있다. 예를 들어, 퓨즈드 ID는 어드레스 매니저에 연결될 수 있다. 또는, 퓨즈드 ID는 높은 계층의 메모 리 어드레스 유닛에 연결될 수 있다. 이러한 실시예에서, 퓨즈드 ID는 특정 주소로 설정될 수 있다. 예를 들어, 퓨즈드 ID는 관리 회로로부터 수신된 명령에 의거하여 최종 ID를 판단하는 프로그램 가능 비휘발성 장치를 포함할 수 있다. 메모리 칩 상의 분산 프로세서는 도 16에 도시된 구성으로 설계될 수 있다. 칩 웨이크업(chip wakeup) 또는 공 장 검사 단계에서 BIST로서 실행되는 검사 절차는 검사 프로토콜에 합격하는 복수의 프라이머리 로직 블록(메모 리 로직 및 비즈니스 로직)의 블록에 실행 ID 번호를 배정할 수 있다. 검사 절차는 또한 검사 프로 토콜에 불합격하는 복수의 프라이머리 로직 블록의 블록에 불법 ID 번호를 배정할 수 있다. 검사 절차는 또한 검사 프로토콜에 합격하는 복수의 리던던트 블록(리던던트 로직 블록)의 블록에 실행 ID 번호를 배정할 수 있다. 리던던트 블록이 불합격하는 프라이머리 로직 블록을 대체하기 때문에, 실행 ID 번호가 배정된 복수의 리던던트 블록의 블록은 불법 ID 번호가 배정된 복수의 프라이머리 로직 블록의 블록보다 크거나 같을 수 있고, 이에 따라 블록이 비활성화된다. 또한, 복수의 프라이머리 로직 블록의 각각과 복수의 리던던트 블록의 각각은 적어도 하나의 퓨즈드 ID를 포함할 수 있다. 또한, 도 16에 도시된 바와 같이, 로직 블록을 연결하 는 버스는 명령 라인, 데이터 라인, 및 어드레스 라인을 포함할 수 있다. 그러나 다른 실시예에서, 버스에 연결된 모든 로직 블록은 비활성화 상태로 ID 번호 없이 시작할 것이다. 하나씩 검사하여, 양호한 각 블록에는 실행 ID가 부여되고, 작동하지 않는 로직 블록에는 불법 ID가 남아있고 비활성화될 것이다. 이런 식으로, 리던던트 로직 블록은 결함이 있는 것으로 알려진 블록을 검사 과정에서 대체 함으로써 제조 수율을 향상할 수 있다. 어드레스 버스는 관리 회로를 복수의 메모리 뱅크의 각각, 복수의 프라이머리 로직 블록의 각각, 및 복수 의 리던던트 블록의 각각에 결합할 수 있다. 이러한 연결로 인해, 프라이머리 로직 블록과 연관된 결함을 검출 하면, 관리 회로는 유효하지 않은 주소를 복수의 프라이머리 로직 블록의 하나에 배정하고 유효한 주소를 복수 의 리던던트 블록의 하나에 배정할 수 있다. 예를 들어, 도 16의 A)에 도시된 바와 같이, 불법 ID(예, 주소 0xFFF)가 모든 로직 블록(1602(a)-(c))에 설정될 수 있다. 검사 후에, 로직 블록 1602(a)와 1602(c)는 제대로 기능하는 것으로 확인되고 로직 블록 1602(b)는 기 능에 문제가 있는 것으로 확인된다. 도 16의 A)에서, 음영 처리하지 않은 로직 블록은 기능 검사에 합격한 로직 블록을 나타내고 음영 처리한 로직 블록은 기능 검사에 불합격한 로직 블록을 나타내는 것일 수 있다. 이후, 검 사 절차는 제대로 기능하는 로직 블록에 대한 불법 ID를 합법 ID로 변경하고 기능에 문제가 있는 로직 블록에 대한 불법 ID는 그대로 유지한다. 예를 들면, 도 16의 A)에서, 로직 블록 1602(a)와 1602(c)에 대한 주소는 각 각 0xFFF에서 0x001과 0x002로 변경된다. 반면에, 로직 블록 1602(b)에 대한 주소는 불법 주소 0xFFF로 유지된 다. 일부 실시예에서, ID는 상응하는 퓨즈드 ID을 프로그램하여 변경된다. 로직 블록의 검사 결과가 다르면 설정도 다를 수 있다. 예를 들어, 도 16의 B)에 도시된 바와 같이, 어드 레스 매니저는 초기에 모든 로직 블록에 불법 ID(즉, 0xFFF )를 배정할 수 있다. 그러나 검사의 결 과, 로직 블록 1602(a)와 1602(b) 모두 정상적으로 기능하는 것으로 나타날 수 있다. 이 경우, 메모리 칩(130 0)은 두 개의 로직 블록만 있어도 되기 때문에, 로직 블록 1602(c)의 검사는 불필요할 수 있다. 따라서, 검사에들어가는 리소스를 최소화하기 위하여, 메모리 칩의 제품 정의에 의해 요구되는 기능하는 로직 블록의 최 소 수량에 따라서만 로직 블록이 검사하고 다른 블록은 검사하지 않을 수 있다. 도 16의 B)에서, 음영 처리하지 않은 로직 블록은 기능성 검사에 합격한 로직 블록을 나타내고, 음영 처리한 로직 블록은 검사하지 않은 로직 블록을 나타낸다. 이러한 실시예에서, 생산 테스터(외장 또는 내장, 자동 또는 수동) 또는 스타트업에서 BIST를 실행하는 제어기 는 검사를 통해 기능하는 것으로 판명된 로직 블록에 대해 불법 ID를 실행 ID로 변경하고 검사하지 않은 로직 블록은 불법 ID를 변경하지 않을 수 있다. 예를 들면, 도 16의 B)에서, 로직 블록 1602(a)와 1602(b)의 주소는 각각 0xFFF에서 0x001과 0x002로 변경된다. 반면, 검사하지 않은 로직 블록 1602(c)에 대한 주소는 불법 주소 0xFFF를 유지한다. 도 17은 기재된 실시예에 따른 직렬로 연결된 예시적인 소자(1702, 1712)의 구성도이다. 도 17은 전체 시스템 또는 칩을 도시한 것일 수 있다. 또는, 도 17은 다른 기능 블록을 포함하는 칩 내부의 블록을 도시한 것일 수 있다. 소자(1702, 1712)는 메모리 로직 및/또는 비즈니스 로직과 같은 복수의 로직 블록을 포함하는 전체 소자를 나타내는 것일 수 있다. 이런 실시예에서, 소자(1702, 1712)는 또한 어드레스 매니저와 같이 동작 을 수행하기 위해 필요한 요소를 포함할 수 있다. 그러나 다른 실시예에서, 소자(1702, 1712)는 비즈니스 로직 또는 리던던트 비즈니스 로직과 같은 논리 소자를 나타내는 것일 수 있다. 도 17은 소자(1702, 1712)가 서로 통신할 필요가 있을 수 있는 실시예를 제시한다. 이런 경우, 소자(1702, 1712)는 직렬로 연결될 수 있다. 그러나 작동하지 않는 소자가 로직 블록 사이의 연결성을 막을 수 있다. 따라 서, 소자 사이의 연결은 소자가 결함으로 인해 비활성화되어야 할 필요가 있는 경우를 대비하여 우회 옵션을 포 함할 수 있다. 우회 옵션은 또한 우회된 소자 자체의 일부일 수 있다. 도 17에서, 소자는 직렬로 연결될 수 있고(예, 1702(a)-(c)), 불합격 소자(예, 1702(b))는 결함 시에 우회될 수 있다. 소자는 스위칭 회로와 병렬도 더 연결될 수 있다. 예를 들어, 일부 실시예에서, 도 17에 도시된 바와 같 이, 소자(1702, 1712)는 스위칭 회로(1722, 1728)와 연결될 수 있다. 도 17에 도시된 예에서, 소자(1702(b))는 결함이 있다. 예를 들어, 소자(1702(b))는 회로 기능 검사에서 불합격이다. 따라서, 소자(1702(b))는 활성화 스 위치(1314; 도 17에 미도시) 등을 활용하여 비활성화될 수 있고/있거나 스위칭 회로(1722(b))가 활성화되어 소 자(1702(b))를 우회하고 로직 블록 사이의 연결성을 유지할 수 있다. 이에 따라, 복수의 프라이머리 소자가 직렬로 연결된 경우, 복수의 소자의 각각은 병렬 스위치와 병렬로 연결될 수 있다. 복수의 소자의 하나와 연관된 결함이 검출되면, 복수의 소자의 하나와 연결된 병렬 스위치가 활성화되 어 복수의 소자의 두 소자를 서로 연결할 수 있다. 다른 실시예에서, 도 17에 도시된 바와 같이, 스위칭 회로는 사이클을 지연시켜서 소자의 서로 다른 라인 사이의 동기화를 유지하는 하나 이상의 샘플링 포인트를 포함할 수 있다. 어떤 소자가 비활성화된 경우에, 인접 로직 블록 사이의 연결을 차단하면 다른 계산과의 동기화 오류가 발생할 수 있다. 예를 들어, 어떤 작업이 A라 인과 B라인 모두로부터 데이터를 필요로 하고, A라인과 B라인은 각각 서로 별개의 일련의 소자에 의해 수행되는 경우에, 한 소자를 비활성화하면 A라인과 B라인 사이의 비동기화가 발생할 것이고 이에 따라 추가적인 데이터 관리가 필요할 것이다. 비동기화를 방지하기 위하여, 샘플 회로는 비활성화된 소자(1712(b))에 의해 유발 된 지연을 시뮬레이션할 수 있다. 그러나 일부 실시예에서, 병렬 스위치는 샘플링 회로 대신에 안티퓨즈 를 포함할 수 있다. 도 18은 기재된 실시예에 따른 2차원 어레이로 연결된 예시적인 소자의 구성도이다. 도 18은 전체 시스템 또는 칩을 나타내는 것일 수 있다. 또는, 도 18은 다른 기능 블록을 포함하는 칩 내부의 블록을 도시한 것일 수 있다. 소자는 메모리 로직 및/또는 비즈니스 로직과 같은 복수의 로직 블록을 포함하는 자율 소자 (autonomous unit)를 나타내는 것일 수 있다. 그러나 다른 실시예에서, 소자는 비즈니스 로직과 같 은 논리 소자를 나타내는 것일 수 있다. 설명의 편의상, 도 18의 설명은 앞서 도 13에 설명한 요소(예, 메모리 칩)를 참조할 수 있다. 도 18에 도시된 바와 같이, 소자는 소자(메모리 로직, 비즈니스 로직, 및 리던던트 비즈니스 로직의 하나 이상을 포함하거나 나타낼 수 있음)가 스위칭 박스 및 연결 박스를 통해 서로 연결된 2차원 어레이로 배치될 수 있다. 또한, 2차원 어레이의 설정을 제어하기 위하여, 2차원 어레이는 주변에I/O 블록을 포함할 수 있다. 연결 박스는 I/O 블록으로부터 입력되는 신호에 대응할 수 있는 프로그램 가능 및 재구성 가능 장 치일 수 있다. 예를 들어, 연결 박스는 소자로부터의 복수의 입력 핀을 포함할 수 있고, 또한 스위칭 박 스로 연결될 수 있다. 또는, 연결 박스는 프로그램 가능 로직 셀의 핀을 라우팅 트랙과 연결하는 한 그룹의 스위치를 포함할 수 있고, 스위칭 박스는 서로 다른 트랙을 연결하는 한 그룹의 스위치를 포함 할 수 있다. 일부 실시예에서, 연결 박스와 스위칭 박스는 스위치(1312, 1314)와 같은 설정 스위치로 구현될 수 있다. 이러한 실시예에서, 연결 박스와 스위칭 박스는 칩 스타트업에 실행되는 BIST 또는 생산 테 스터에 의해 설정될 수 있다. 일부 실시예에서, 연결 박스와 스위칭 박스는 소자에 대한 회로 기능 검사 후에 설정될 수 있다. 이런 실시예에서, I/O 블록을 사용하여 검사 신호를 소자에 전송할 수 있다. 검사 결과에 따 라, I/O 블록은 검사 프로토콜에 불합격하는 소자를 비활성화하고 검사 프로토콜에 합격하는 소자 를 활성화하는 방식으로 연결 박스와 스위칭 박스를 설정하는 프로그래밍 신호를 전송할 수 있다. 이러한 실시예에서, 복수의 프라이머리 로직 블록과 복수의 리던던트 블록은 2차원 그리드(grid)로 기판 상에 배치될 수 있다. 따라서, 복수의 프라이머리 소자의 각 소자와 리던던트 비즈니스 로직과 같은 복 수의 리던던트 블록의 각 블록은 스위칭 박스로 서로 연결될 수 있고, 입력 블록은 2차원 그리드의 각 라 인과 각 컬럼의 주변에 배치될 수 있다. 도 19는 기재된 실시예에 따른 복합 연결된 예시적인 소자의 구성도이다. 도 19는 전체 시스템을 나타내는 것일 수 있다. 또는, 도 19는 다른 기능 블록을 포함하는 칩 내부의 블록을 도시한 것일 수 있다. 도 19의 복합 연결은 소자(1902(a)-(f))와 설정 스위치(1904(a)-(h))를 포함한다. 소자는 메모리 로직 및/또는 비즈니스 로직과 같은 복수의 로직 블록을 포함하는 자율 소자를 나타내는 것일 수 있다. 그러나 다른 실시예에서, 소자는 메모리 로직, 비즈니스 로직, 또는 리던던트 비즈니스 로직 과 같은 로직 소자를 나타내는 것일 수 있다. 설정 스위치는 비활성화 스위치와 활성화 스위 치 중의 하나 이상을 포함할 수 있다. 도 19에 도시된 바와 같이, 복합 연결은 두 면에 있는 소자를 포함할 수 있다. 예를 들어, 복합 연결은 z 축을 따라 이격된 두 개의 개별적인 기판을 포함할 수 있다. 대안적으로 또는 추가적으로, 소자는 기판의 두 면에 배치될 수 있다. 예를 들어, 메모리 칩의 면적을 줄이려는 목적으로, 기판은 중첩하는 두 면에 배치될 수 있고, 3차원으로 배치된 설정 스위치로 연결될 수 있다. 설정 스위치는 비활성화 스위치 및/또는 활성화 스위치를 포함할 수 있다. 기판의 제1 면은 '메인' 소자를 포함할 수 있다. 이 블록은 디폴트로 활성화될 수 있다. 이러한 실시예에 서, 제2면은 '리던던트' 소자를 포함할 수 있다. 이 소자는 디폴트로 비활성화 될 수 있다. 일부 실시 예에서, 설정 스위치는 안티퓨즈를 포함할 수 있다. 따라서, 소자의 검사 후에, 특정 안 티퓨즈를 '상시 온(always-on)' 상태로 스위칭하고 선택된 소자를 비활성화함으로써 블록이 서로 다른 면 에 있더라도 기능 소자의 타일로 연결될 수 있다. 도 19에 도시된 예에서, '메인' 소자의 하나(1902(e))는 고장 이다. 도 19에서, 기능에 문제가 있거나 검사하지 않은 블록은 음영 처리로 표시되고, 검사도 하고 기능에 문제 가 없는 블록은 음영 처리하지 않은 상태로 표시될 수 있다. 따라서, 설정 스위치는 서로 다른 면에 있는 로직 블록의 하나(예, 1902(f))가 활성화되도록 설정될 수 있다. 이로써, 메인 로직 블록의 하나에 결함이 있더 라도, 여분의 논리 소자로 대체함으로써 메모리 칩이 여전히 기능을 한다. 또한, 도 19에서, 메인 로직 블록이 기능을 하기 때문에, 제2면에 있는 소자의 하나(1902(c))가 검사를 받지 않았고 활성화되지 않았다. 예를 들어, 도 19에서, 메인 소자1902(a)와 1902(d)는 모두 기능 검사에 합격 했다. 따라서, 소자(1902(c))는 검사를 받거나 활성화되지 않았다. 따라서, 도 19는 검사 결과에 따라 활성화되 는 로직 블록을 구체적으로 선택하는 능력을 도시한다. 일부 실시예에서, 도 19에 도시된 바와 같이, 제1면에 있는 모든 소자에 상응하는 여분 또는 리던던트 블 록이 있는 것이 아니다. 그러나 다른 실시예에서, 모든 소자가 프라이머리와 리던던트 모두에 해당하는 경우에 모든 소자는 서로에 대해 리던던트가 됨으로써 완벽한 중복성을 가질 수 있다. 또한, 일부에서는 도 19에 도시된 방사형 네트워크(star network)로 구현되지만, 병렬 연결, 직렬 연결, 및/또는 서로 다른 요소를 설정 스위 치로 병렬 또는 직렬로 연결하는 구현도 가능하다. 도 20은 기재된 실시예에 따른 리던던트 블록 활성화 프로세스를 도시한 예시적인 순서도이다. 활성화 프 로세스는 메모리 칩, 특히 DRAM 메모리 칩에 대해 이행될 수 있다. 일부 실시예에서, 프로세스 는 메모리 칩의 기판 상에 배치된 복수의 로직 블록의 각 블록에 대해 적어도 하나의 회로 기능을 검사하 는 단계, 검사의 결과에 의거하여 복수의 프라이머리 로직 블록에서 결함이 있는 로직 블록을 식별하는 단계, 메모리 칩의 기판 상에 배치된 적어도 하나의 리던던트 또는 추가 로직 블록에 대해 적어도 하나의 회로 기능을 검사하는 단계, 외부 신호를 비활성화 스위치에 인가하여 적어도 하나의 결함이 있는 로직 블록을 비활성화하는 단계, 및 외부 신호를 활성화 스위치에 인가하여 적어도 하나의 리던던트 블록을 활성화하는 단계를 포함할 수 있다. 여기서, 활성화 스위치는 적어도 하나의 리던던트 블록과 연결될 수 있고, 메모리 칩의 기판 상에 배치될 수 있다. 하기의 도 20의 설명에서 프로세스의 각 단계에 대해 더 설명한다. 프로세스는 비즈니스 블록과 복수의 리던던트 블록(예, 리던던트 비즈니스 블록)과 같은 복 수의 로직 블록을 검사하는 단계(단계 2002)를 포함할 수 있다. 검사는 온-웨이퍼(on-wafer) 검사를 위한 프로 빙 스테이션(probing station) 등을 활용한 패키징(packaging) 이전에 수행될 수 있다. 그런, 프로세스 는 패키징 이후에 수행될 수도 있다. 단계 2002의 검사는 유한 시퀀스의 검사 신호를 메모리 칩의 모든 로직 블록 또는 메모리 칩의 로 직 블록의 서브세트에 인가하는 단계를 포함할 수 있다. 검사 신호는 0 또는 1을 출력할 것으로 예상되는 계산 을 요청할 수 있다. 다른 실시예에서, 검사 신호는 메모리 뱅크의 특정 주소를 읽거나 특정 메모리 뱅크에 쓰기 를 요청할 수 있다. 단계 2002의 반복 프로세스 하에서 로직 블록의 반응을 검사하기 위해 검사 방식이 이행될 수 있다. 예를 들어, 메모리 뱅크에 데이터를 쓰도록 하는 명령을 전송한 후에 기록한 데이터의 무결성을 검증하여 로직 블록을 검사 할 수 있다. 다른 실시예에서, 데이터를 역으로 하여 알고리즘을 반복하여 검사할 수 있다. 다른 실시예에서, 단계 2002의 검사는 로직 블록의 모델을 실행하여 검사 명령의 세트에 의거하여 타깃 메모리 이미지를 생성하는 단계를 포함할 수 있다. 이후, 메모리 칩의 로직 블록에 명령의 동일한 시퀀스가 실행되고, 그 결과가 기록될 수 있다. 시뮬레이션의 잔존하는 메모리 이미지는 또한 검사에서 확보된 이미지와 비교될 수 있고, 불일치에는 불합격의 플래그가 붙여질 수 있다. 또는, 단계 2002에서, 검사는 셰도우 모델링(shadow modeling)을 포함할 수 있고, 여기서, 진단은 생성되지만 결과를 반드시 예측하지는 않는다. 오히려, 셰도우 모델링을 활용한 검사는 메모리 칩과 시뮬레이션에서 병렬로 실행될 수 있다. 예를 들어, 메모리 칩의 로직 블록이 명령 또는 작업을 완수하는 경우, 동일한 명령을 실행하 라는 신호를 시뮬레이션에 보낼 수 있다. 메모리 칩의 로직 블록이 명령을 완수하면, 두 모델의 아키텍처 상태 를 비교한다. 여기에 불일치가 있으면, 불합격 플래그가 붙는다. 일부 실시예에서, 단계 2002에서 모든 로직 블록(메모리 로직, 비즈니스 로직, 및 리던던트 비즈니 스 로직의 각각 등을 포함)을 검사할 수 있다. 그러나 다른 실시예에서, 서로 다른 차수의 검사에서 로직 블록의 서브세트만을 검사할 수도 있다. 예를 들어, 1차 검사에서는 메모리 로직과 그 연관 블록만을 검 사할 수 있다. 2차 검사에서는 비즈니스 로직과 그 연관 블록만을 검사할 수 있다. 3차 검사에서는 앞선 2번의 검사의 결과에 따라 리던던트 비즈니스 로직과 연관된 로직 블록을 검사할 수 있다. 프로세스는 단계 2004로 진행할 수 있다. 단계 2004에서, 결함이 있는 로직 블록이 식별되고, 결함이 있 는 리던던트 블록도 식별될 수 있다. 예를 들어, 단계 2002의 검사에 불합격하는 로직 블록이 단계 2004에서 결 함이 있는 블록으로 식별될 수 있다. 그러나 다른 실시예에서, 결함이 있는 특정 블록 만이 초기에 식별될 수 있다. 예를 들어, 일부 실시예에서, 비즈니스 로직과 연관된 로직 블록만이 식별될 수 있고, 리던던트 로 직 블록이 결함이 있는 로직 블록을 대체해야 하는 경우에만 결함이 있는 리던던트 로직 블록이 식별될 수 있다. 또한, 결함이 있는 로직 블록을 식별하는 단계는 식별된 결함이 있는 로직 블록의 식별 정보를 메모리 뱅 크 또는 비휘발성 메모리에 기록하는 단계를 포함할 수 있다. 단계 2006에서, 결함이 있는 로직 블록이 비활성화될 수 있다. 예를 들어, 설정 회로를 사용하여, 결함이 있는 로직 블록을 클럭, 접지, 및/또는 전원 노드로부터 연결 해제함으로써 결함이 있는 로직 블록이 비활성화될 수 있다. 또는, 로직 블록을 회피하는 배치로 연결 박스를 설정함으로써 결함이 있는 로직 블록이 비활성화될 수 있다. 또한, 다른 실시예에서, 어드레스 매니저로부터 불법 주소를 수신함으로써 결함이 있는 로직 블록이 비활성화 될 수 있다. 단계 2008에서, 결함이 있는 로직 블록을 복제하는 리던던트 블록이 식별될 수 있다. 일부 로직 블록에 결함이 있더라도 메모리 칩의 능력을 유지하기 위하여, 단계 2008에서, 결함이 있는 로직 블록을 복제할 수 있고 사용 가능한 리던던트 블록을 식별할 수 있다. 예를 들어, 벡터 곱셈을 수행하는 로직 블록이 결함이 있는 것으로 판 단되는 경우, 단계 2008에서, 어드레스 매니저 또는 온칩 컨트롤러는 역시 벡터 곱셈을 수행하는 사용 가 능한 리던던트 로직 블록을 식별할 수 있다. 단계 2010에서, 단계 2008에서 식별된 리던던트 블록이 활성화될 수 있다. 단계 2006의 비활성화 동작에 반하여, 단계 2010에서는, 식별된 리던던트 블록을 클럭, 접지, 및/또는 전원 노드에 연결함으로써 식별된 리던 던트 블록이 활성화될 수 있다. 또는, 식별된 리던던트 블록을 연결하는 배치로 연결 박스를 설정함으로써, 식 별된 리던던트 블록이 활성화될 수 있다. 또한, 다른 실시예에서, 검사 절차 실행 타임에 실행 주소를 수신함으 로써, 식별된 리던던트 블록이 활성화될 수 있다. 도 21은 기재된 실시예에 따른 주소 배정 프로세스를 도시한 예시적인 순서도이다. 주소 배정 프로세스 는 메모리 칩, 특히 DRAM 메모리 칩에 대해 이행될 수 있다. 도 16을 참조하여 설명한 바와 같이, 일부 실시예에서, 메모리 칩의 로직 블록은 데이터 버스에 연결될 수 있고 주소 ID를 포함할 수 있다. 프 로세스는 결함이 있는 로직 블록을 비활성화하고 검사에 합격하는 로직 블록을 활성화하는 주소 배정 방 법을 제공한다. 프로세스의 단계들은 칩 스타트업에 실행되는 BIST 또는 생산 테스터에 의해 수행되는 것으로 설명되지만, 메모리 칩의 다른 요소 및/또는 외부 장치도 프로세스의 하나 이상의 단계를 수 행할 수 있다. 단계 2102에서, 테스터는 칩 레벨의 각 로직 블록에 불법 ID를 배정함으로써 모든 로직 블록과 리던던트 블록을 비활성화 할 수 있다. 단계 2104에서, 테스터는 로직 블록의 검사 프로토콜을 실행할 수 있다. 예를 들어, 테스터는 메모리 칩 의 로직 블록의 하나 이상에 대해 단계 2002에서 설명한 검사 방법을 실행할 수 있다. 단계 2106에서, 단계 2104의 검사의 결과에 따라, 테스터는 로직 블록에 결함이 있는지 여부를 판단할 수 있다. 로직 블록에 결함이 없는 경우(단계 2106에서 '아니오'), 어드레스 매니저는 단계 2108에서 실행 ID를 검사된 로직 블록에 배정할 수 있다. 로직 블록에 결함이 있는 경우(단계 2106에서 '예'), 어드레스 매니저는 단 계 2110에서 결함이 있는 로직 블록에 불법 ID를 남겨둘 수 있다. 단계 2112에서, 어드레스 매니저는 결함이 있는 로직 블록을 복제하는 리던던트 로직 블록을 선택할 수 있다. 일부 실시예에서, 결함이 있는 로직 블록을 복제하는 리던던트 로직 블록에는 결함이 있는 로직 블록과 동일한 요소 및 연결이 있을 수 있다. 그러나 다른 실시예에서, 리던던트 로직 블록은 결함이 있는 로직 블록과 다른 요소 및/또는 연결을 포함하지만 균등한 동작을 수행할 수 있을 수 있다. 예를 들어, 결함이 있는 로직 블 록이 벡터 곱셈을 수행하도록 설계된 경우, 선택된 리던던트 로직 블록도 결함이 있는 로직 블록과 동일한 아키 텍처가 아니더라도 벡터 곱셈을 수행할 수 있을 수 있다. 단계 2114에서, 어드레스 매니저는 리던던트 블록을 검사할 수 있다. 예를 들어, 테스터는 단계 2104에 적용된 검사 방식을 식별된 리던던트 블록에 적용할 수 있다. 단계 2116에서, 단계 2114의 검사의 결과에 의거하여, 테스터는 리던던트 블록에 결함이 있는지 여부를 판단할 수 있다. 단계 2118에서, 리던던트 블록에 결함이 없는 경우(단계 2116에서 '아니오'), 테스터는 식별된 리던던 트 블록에 실행 ID를 배정할 수 있다. 일부 실시예에서, 프로세스는 단계 2118 이후에 단계 2104로 돌아 가서 메모리 칩의 모든 로직 블록을 검사하는 반복 루프를 구성할 수 있다. 테스터가 리던던트 블록에 결함이 있는 것으로 판단하는 경우(단계 2116에서 '예'), 단계 2120에서, 테스터는 추가 리던던트 블록이 사용 가능한지 여부를 판단할 수 있다. 예를 들어, 테스터는 사용 가능한 리던던트 로직 블록에 관한 정보로 메모리 뱅크에 쿼리를 할 수 있다. 사용 가능한 리던던트 로직 블록이 있는 경우(단계 2120 에서 '예'), 테스터는 단계 2112로 돌아가서 결함이 있는 로직 블록을 복제하는 새로운 리던던트 로직 블록을 식별할 수 있다. 사용 가능한 리던던트 로직 블록이 없는 경우(단계 2120에서 '아니오'), 단계 2122에서, 테스 터는 오류 신호를 생성할 수 있다. 오류 신호는 결함이 있는 로직 블록과 결함이 있는 리던던트 블록의 정보를 포함할 수 있다. 결합된 메모리 뱅크 여기에 기재된 실시예들은 또한, 분산된 고성능 프로세서를 포함한다. 프로세서는 메모리 뱅크와 처리부를 접속 시키는 메모리 컨트롤러를 포함할 수 있다. 프로세서는 데이터가 계산을 위해 처리부에 신속히 전달되도록 구성 될 수 있다. 예를 들어, 작업을 수행하기 위해 처리부가 두 개의 데이터 인스턴스가 필요한 경우, 메모리 컨트 롤러는 통신 라인이 개별적으로 두 데이터 인스턴스로부터의 정보에 대한 접근을 제공할 수 있도록 구성될 수 있다. 기재된 메모리 아키텍처는 복합 캐시 메모리와 복합 레지스터 파일 스키마와 연관된 하드웨어 요구조건을 최소화하고자 한다. 일반적으로, 프로세서 칩은 코어가 레지스터와 직접 작용하도록 하는 캐시 체계를 포함한다. 그러나 캐시 동작은 상당한 다이 면적을 필요로 하고 추가적인 전력을 소비한다. 기재된 메모리 아키 텍처는 메모리에 논리 요소를 추가함으로써 캐시 체계의 사용을 피한다. 기재된 아키텍처는 또한 메모리 뱅크 내에 데이터를 전략적으로(또는 최적화된) 배치할 수 있게 한다. 메모리 뱅크가 단일 포트만을 포함하고 지연이 많은 경우라도, 기재된 메모리 아키텍처는 데이터를 메모리 뱅크의 다른 블록에 전략적으로 배치함으로써 고성능을 가능하게 하고 메모리 병목현상을 방지할 수 있다. 지속적인 데이터 스트림을 처리부로 제공하려는 목적으로, 컴파일 최적화(compilation optimization) 단계는 데이터가 특정 또는 일반 작업에 대해 메모리 뱅크에 저장되어야 하는 방법을 판단할 수 있다. 이후, 처리부와 메모리 뱅크를 접속 시키는 메모리 컨트롤러는 동작을 수행하기 위하여 데이터가 필요한 경우에 특정 처리부에게 접속을 허용하도록 구성될 수 있다. 메모리 칩의 설정은 처리부(예, 설정 매니저) 또는 외부 인터페이스에 의해 수행될 수 있다. 설정은 또한 컴파 일러 또는 기타 소프트웨어 툴에 의해 기록될 수 있다. 또한, 메모리 컨트롤러의 설정은 메모리 뱅크에 사용 가 능한 포트와 메모리 뱅크의 데이터 구조에 의거할 수 있다. 이에 따라, 기재된 아키텍처는 서로 다른 메모리 뱅 크로부터 데이터의 지속적인 흐름 또는 동시 정보를 처리부에 제공할 수 있다. 이로써, 지연 병목현상 또는 캐 시 메모리 요구사항을 회피하여 메모리 이내의 계산 작업이 신속히 처리될 수 있다. 또한, 메모리 칩에 저장된 데이터는 컴파일 최적화 단계에 의거하여 배치될 수 있다. 컴파일은 프로세서가 메모 리 지연이 없는 처리부로 작업을 효율적으로 배정하는 처리 루틴의 구축을 가능하게 할 수 있다. 컴파일은 컴파 일러에 의해 수행되고 기판의 외부 인터페이스와 연결된 호스트로 전송될 수 있다. 일반적으로, 특정 접속 패턴 에 대한 높은 지연 및/또는 적은 수의 포트의 결과는 데이터를 필요로 하는 처리부에 대한 데이터 병목현상이 될 수 있다. 그러나 기재된 컴파일은 불리한 메모리 유형으로도 처리부가 지속적으로 데이터를 수신할 수 있게 메모리 뱅크에 데이터를 배치할 수 있다. 또한, 일부 실시예에서, 설정 매니저는 작업에 요구되는 계산에 의거하여 필요한 처리부에 신호를 보낼 수 있다. 칩의 서로 다른 처리부 또는 로직 블록에는 서로 다른 작업에 대해 특화된 하드웨어 또는 아키텍처가 있 을 수 있다. 따라서, 수행될 작업에 따라, 처리부 또는 처리부의 그룹이 해당 작업을 수행하도록 선택될 수 있 다. 기판 상의 메모리 컨트롤러는 프로세서 서브유닛의 선택에 따라 데이터를 보내거나 접속을 허용하여 데이터 전송 속도를 향상할 수 있다. 예를 들어, 컴파일 최적화와 메모리 아키텍처에 의거하여, 처리부는 작업을 수행 하도록 요구되는 경우에 메모리 뱅크의 접속이 허용될 수 있다. 또한, 칩 아키텍처는 메모리 뱅크의 데이터 접속에 필요한 시간을 단축하여 데이터의 전송을 가능하게 하는 온 칩 요소를 포함할 수 있다. 따라서, 본 기재는 단순한 메모리 인스턴스를 활용하여 특정 또는 일반 작업의 수행 이 가능한 고성능 프로세서에 대한 칩 아키텍처를 컴파일 최적화 단계와 함께 설명한다. 메모리 인스턴스에는 DRAM 장치 또는 기타 메모리 지향 기술에 사용되는 것과 같은 적은 수의 포트 및/또는 높은 지연이 있을 수 있 지만, 기재된 아키텍처는 메모리 뱅크로부터 처리부로의 데이터의 지속적인(또는 거의 지속적인) 흐름을 가능하 게 하여 이러한 단점을 극복할 수 있다. 본 출원에서, 동시 통신이란 클럭 사이클 이내의 통신을 말하는 것일 수 있다. 또는, 동시 통신이란 미리 정해 진 시간 이내에 정보를 전송하는 것을 의미하는 것일 수 있다. 예를 들어, 동시 통신은 몇 나노초(10억분의 몇 초) 이내의 통신을 말하는 것일 수 있다. 도 22는 기재된 실시예에 따른 예시적인 처리 장치에 대한 구성도이다. 도 22의 A)는 메모리 컨트롤러가 멀티플렉서를 활용하여 제1 메모리 블록과 제2 메모리 블록을 연결하는 처리 장치의 제1 실 시예를 도시한 것이다. 메모리 컨트롤러는 또한 적어도 설정 매니저, 로직 블록, 복수의 가 속기(2216(a)-(n))를 연결할 수 있다. 도 22의 B)는 메모리 컨트롤러가 메모리 컨트롤러와 적어도 설정 매니저, 로직 블록, 복수의 가속기(2216(a)-(n))를 연결하는 버스를 활용하여 메모리 블록 (2202, 2204)을 연결하는 처리 장치의 제2 실시예를 도시한 것이다. 또한, 호스트는 외부에 위치할수 있고 외부 인터페이스 등을 통해 처리 장치에 연결될 수 있다. 메모리 블록(2202, 2204)은 DRAM 매트 또는 매트 그룹, DRAM 뱅크, MRAM＼ PRAM＼ RERAM＼SRAM 유닛, 플래시 매트, 또는 기타 메모리 기술을 포함할 수 있다. 메모리 블록(2202, 2204)은 대안적으로 비휘발성 메모리, 플래 시메모리 장치, ReRAM(Resistive Random Access Memory) 장치, 또는 MRAM(Magnetoresistive Random Access Memory) 장치를 포함할 수 있다. 메모리 블록(2202, 2204)은 추가적으로 복수의 워드라인(미도시)과 복수의 비트라인(미도시) 사이에 행과 열로 배치된 복수의 메모리 셀을 포함할 수 있다. 메모리 셀의 각 행의 게이트는 복수의 워드라인 각각에 연결될 수 있다. 메모리 셀의 각 열은 복수의 비트라인 각각에 연결될 수 있다. 다른 실시예에서, 메모리 영역(메모리 블록(2202, 2204) 포함)은 단일 메모리 인스턴스로부터 구성될 수 있다. 본 출원에서, '메모리 인스턴스'라는 용어는 '메모리 블록'과 서로 호환하여 사용될 수 있다. 메모리 인스턴스 (또는 블록)의 특성은 열악할 수 있다. 예를 들어, 메모리에는 포트가 하나밖에 없을 수 있고 랜덤 액세스 지연 이 클 수 있다. 대안적으로 또는 추가적으로, 메모리는 컬럼 및 라인 변경 동안에 접근이 불가능할 수 있고 정 정요량 충정 및/또는 회로 설정 등과 관련된 데이터 접속 문제에 직면할 수 있다. 그러나 도 22에 제시된 아키 텍처는 메모리 인스턴스와 처리부 사이의 전용 연결을 허용하고 블록의 특성을 고려하는 특정 방식으로 데이터 를 배치함으로써 메모리 장치의 병렬 처리를 가능하게 한다. 일부 장치 아키텍처에서, 메모리 인스턴스는 여러 포트를 가지고 있어서 병렬 동작이 가능할 수 있다. 그러나 이러한 실시예에서, 칩은 데이터가 칩 아키텍처에 의거하여 컴파일되고 구성되는 경우에 성능 향상을 이룰 수 있다. 예를 들어, 컴파일러는 단일 포트 메모리를 활용하여도 용이하게 접속될 수 있도록 명령을 제공하여 데이 터 배치를 구성함으로써 메모리 영역의 접근 효율을 향상할 수 있다. 또한, 메모리 블록(2202, 2204)은 단일 칩의 메모리에 대해 다중 유형일 수 있다. 예를 들어, 메모리 블록 (2202, 2204)은 eFlash 및 eDRAM일 수 있다. 또한, 메모리 블록은 ROM의 인스턴스를 가진 DRAM을 포함할 수 있 다. 메모리 컨트롤러는 메모리 접근을 처리하고 그 결과를 나머지 모듈로 전달할 논리 회로를 포함할 수 있다. 예를 들어, 메모리 컨트롤러는 어드레스 매니저 및 멀티플렉서와 같은 선택 장치를 포함하여 데이 터를 메모리 블록과 처리부 사이에 전달하고 메모리 블록으로의 접근을 허용할 수 있다. 대안적으로, 메모리 컨 트롤러는 시스템의 메모리 클럭의 상승 에지(rising edge)와 하강 에지(falling edge)에 데이터가 전송되 는 DDR SDRAM의 구동에 사용되는 DDR(double data rate) 메모리 컨트롤러를 포함할 수 있다. 또한, 메모리 컨트롤러는 듀얼 채널(Dual Channel) 메모리 컨트롤러를 구성할 수 있다. 듀얼 채널 메모리 를 도입하면 메모리 컨트롤러에 의한 병렬 접속의 제어가 가능할 수 있다. 병렬 접속 라인은 다중 라인이 함께 사용되는 경우에 서로 동일한 길이가 데이터의 동기화를 가능하게 하도록 구성될 수 있다. 대안적으로 또 는 추가적으로, 병렬 접속 라인은 메모리 뱅크의 다중 메모리 포트의 접속을 허용할 수 있다. 일부 실시예에서, 처리 장치는 처리부에 연결될 수 있는 하나 이상의 멀티플렉서를 포함할 수 있다. 처리 부는 멀티플렉서에 직접 연결될 수 있는 설정 매니저, 로직 블록, 가속기를 포함할 수 있다. 또한, 메모리 컨트롤러는 복수의 메모리 뱅크 또는 블록로부터의 적어도 하나의 데이터 입력과 복 수의 처리부 각각으로 연결된 적어도 하나의 데이터 출력을 포함할 수 있다. 이러한 구성으로, 메모리 컨트롤러 는 두 개의 데이터 입력을 통하여 메모리 뱅크 또는 블록(2202, 2204)으로부터 동시에 데이터를 수신하고, 적어도 하나의 선택된 처리부를 통하여 수신된 데이터를 두 개의 데이터 출력을 통하여 동시에 전송 할 수 있다. 그러나 일부 실시예에서, 적어도 하나의 데이터 입력과 적어도 하나의 데이터 출력은 읽기 또는 쓰 기 동작만을 허용하는 단일 포트에서 이행될 수 있다. 이러한 실시예에서, 단일 포트는 데이터, 어드레스, 및 명령 라인을 포함하는 데이터 버스로 구현될 수 있다. 메모리 컨트롤러는 복수의 메모리 블록(2202, 2204)의 각각으로 연결될 수 있고, 선택 스위치 등을 통하 여 처리부로도 연결될 수 있다. 또한, 설정 매니저, 로직 블록, 및 가속기를 포함하는 기판 상의 처리부는 메모리 컨트롤러에 개별적으로 연결될 수 있다. 일부 실시예에서, 설정 매니저는 수 행될 작업의 표시를 수신할 수 있고, 이에 대응하여 메모리에 저장되거나 외부에서 제공된 설정에 따라 메모리 컨트롤러, 가속기, 및/또는 로직 블록을 설정할 수 있다. 대안적으로, 메모리 컨트롤러 는 외부 인터페이스에 의해 설정될 수 있다. 작업은 복수의 처리부 중에서 적어도 하나의 처리부를 선택 하는데 사용될 수 있는 적어도 하나의 계산을 필요로 할 수 있다. 대안적으로 또는 추가적으로, 선택은 적어도하나의 계산을 수행할 수 있는 선택된 처리부의 능력에 적어도 부분적으로에 의거하여 이루어질 수 있다. 이에 대응하여, 메모리 컨트롤러는, 전용 버스를 활용하여 및/또는 파이프라인 된 메모리 접근에서, 메모리 뱅 크에 접근을 허용하거나 적어도 하나의 선택된 처리부와 적어도 두 개의 메모리 뱅크 사이에 데이터를 전달할 수 있다. 일부 실시예에서, 적어도 두 개의 메모리 블록의 제1 메모리 블록은 복수의 처리부의 제1측에 배치될 수 있고, 적어도 두 개의 메모리 블록의 제2 메모리 블록은 제1측의 반대편인 복수의 처리부의 제2측에 배치 될 수 있다. 또한, 작업을 수행할 선택된 처리부, 예를 들어, 가속기(2216(n))는 통신 라인이 제1 메모리 뱅크 또는 제1 메모리 블록에 개방된 클럭 사이클 동안에 제2 메모리 뱅크에 접근하도록 설정될 수 있다. 또는, 선택된 처리부는 통신 라인이 제1 메모리 블록에 개방된 클럭 사이클 동안에 제2 메모리 블 록으로 데이터를 전송하도록 설정될 수 있다. 일부 실시예에서, 도 22에 도시된 바와 같이, 메모리 컨트롤러는 개별 요소로 구현될 수 있다. 그러나 다 른 실시예에서, 메모리 컨트롤러는 메모리 영역에 내장되거나 가속기(2216(a)-(n))를 따라 배치될 수 있 다. 처리 장치의 처리 영역은 설정 매니저, 로직 블록 및 가속기(2216(a)-(n))를 포함할 수 있다. 가속기는 기능이 미리 정의된 복수의 처리 회로를 포함할 수 있고 특정 어플리케이션에 의해 정의 될 수 있다. 예를 들어, 가속기는 모듈 사이의 메모리 이동을 취급하는 벡터 MAC 유닛 또는 DMA(Direct Memory Access) 유닛일 수 있다. 가속기는 또한 자체 주소를 계산하고 메모리 컨트롤러에 데이터를 요청하 거나 기록할 수 있다. 예를 들어, 설정 매니저는 메모리 뱅크에 접근할 수 있는 가속기의 적어도 하나에 신호할 수 있다. 이후, 가속기는 메모리 컨트롤러를 설정하여 데이터를 전달하거나 접근을 허용하도록 할 수 있다. 또한, 가속기는 적어도 하나의 산술 논리부, 적어도 하나의 벡터 처리 논리부, 적어도 하나의 문자열 비교 논리부, 적어도 하나의 레지스터, 및 적어도 하나의 DMA(direct memory access)를 포함할 수 있다. 설정 매니저는 가속기를 설정하고 작업의 실행을 지시하는 디지털 처리 회로를 포함할 수 있다. 예 를 들어, 설정 매니저는 메모리 컨트롤러와 복수의 가속기 각각에 연결될 수 있다. 설정 매 니저에는 가속기의 설정을 저장할 전용 메모리가 있을 수 있다. 설정 매니저는 메모리 뱅크 를 이용하여 메모리 컨트롤러를 통해 명령과 설정을 가져올 수 있다. 또는, 설정 매니저는 외부 인 터페이스를 통하여 프로그램될 수 있다. 일부 실시예에서, 설정 매니저에는 자체 캐시 체계를 가진 온칩 RISC(reduced instruction set computer) 또는 온칩 복합 CPU가 구현되어 있을 수 있다. 일부 실시예에서, 설 정 매니저가 생략될 수도 있고, 가속기는 외부 인터페이스를 통해 설정될 수 있다. 처리 장치는 또한 외부 인터페이스(미도시)를 포함할 수 있다. 외부 인터페이스는 외부 호스트 또 는 온칩 메인 프로세서로부터 명령을 수신하는 메모리 뱅크 컨트롤러와 같은 상위 레벨로부터 메모리의 접근을 허용하거나 외부 호스트 또는 온칩 메인 프로세서로부터 메모리의 접근을 허용한다. 외부 인터페이스는 나중에 설정 매니저 또는 소자들(2214, 2216)에 의해 사용될 메모리 컨트롤러를 통해 메모리에 설 정 또는 코드를 기록함으로써 설정 매니저와 가속기의 프로그래밍을 허용할 수 있다. 그러나 외부 인터페이스는 또한, 메모리 컨트롤러를 통해 전달되지 않고도 처리부를 직접 프로그램할 수 있다. 설정 매니저가 마이크로컨트롤러인 경우, 설정 매니저는 외부 인터페이스를 통해 메인 메모리로부터 컨 트롤러 로컬 메모리에 코드의 로딩을 허용할 수 있다. 메모리 컨트롤러는 외부 인터페이스로부터의 요청 수신에 대응하여 작업을 중단하도록 설정될 수 있다. 외부 인터페이스는 처리 장치 상의 다양한 요소에 무접착제 인터페이스를 제공하는 논리 회로와 연관된 복수의 커넥터를 포함할 수 있다. 외부 인터페이스는 데이터 읽기를 위한 데이터 I/O 입력과 데이터 쓰기를 위한 출력, 외부 주소 출력, 외부 CE0 칩 선택 핀, 액티브 로우 칩 셀렉터(Active-low chip selectors), 바이트 활성화 핀, 메모리 사이클 상의 대기 상대에 대한 핀, 쓰기 활성화 핀, 출력 활성화 핀, 및 읽기-쓰기 활성화 핀을 포 함할 수 있다. 따라서, 외부 인터페이스에는 프로세스를 제어하고 처리 장치로부터 정보를 확보하는 요청된 입 력과 출력이 있다. 예를 들어, 외부 장치는 JEDEC DDR 표준을 준수할 수 있다. 대안적으로 또는 추가적으로, 외 부 장치는 SPI\\OSPI 또는 UART와 같은 기타 표준을 준수할 수 있다. 일부 실시예에서, 외부 인터페이스는 칩 기판 상에 배치될 수 있고 외부 호스트와 연결될 수 있다. 외부 호스트는 외부 인터페이스를 통해 메모리 블록(2202, 2204), 메모리 컨트롤러, 및 처리부에 대한 접근을 확보할 수 있다. 추가적으로 또는 대안적으로, 외부 호스트는 메모리에 대한 읽기 및 쓰기를 할 수 있고,읽기 및 쓰기 명령을 통하여 설정 매니저에게 신호를 보내 프로세스의 개시 및/또는 중단과 같은 동작을 수행하게 할 수 있다. 또한, 외부 호스트는 가속기를 직접 설정할 수 있다. 일부 실시예에서, 외부 호스트는 메모리 블록(2202, 2204) 상에서 직접 읽기/쓰기 동작을 수행할 수 있다. 일부 실시예에서, 설정 매니저와 가속기는 대상 작업에 따라 직접 버스를 사용하여 장치 영역을 메 모리 영역과 연결하도록 설정될 수 있다. 예를 들어, 가속기의 서브세트는 가속기의 서브세트가 작업을 실행하기 위해 필요한 계산을 수행할 능력이 있는 경우에 메모리 인스턴스와 연결할 수 있다. 이러한 분 리를 함으로써, 메모리 블록(2202, 2204)에 필요한 대역폭(BW)이 전용 가속기에 확보되도록 할 수 있다. 또한, 메모리 인스턴스를 메모리 컨트롤러로 연결하면 행 지연 시간이 크더라도 서로 다른 메모리의 데이터에 신속하게 접속할 수 있기 때문에, 전용 버스가 있는 이러한 구성은 용량이 큰 메모리를 작은 인스턴스 또는 블 록으로 나누는 것을 가능하게 할 수 있다. 연결의 병렬화를 하기 위해, 메모리 컨트롤러는 데이터, 어드 레스, 및/또는 컨트롤 버스로 메모리 인스턴스의 각각에 연결될 수 있다. 상기에 설명한 바와 같이 메모리 컨트롤러를 포함시하는 것은 처리 장치에 캐시 체계 또는 복합 레지스터 파일이 없도록 할 수 있다. 캐시 체계를 추가하여 시스템 역량을 강화할 수도 있지만, 처리 장치의 아키 텍처로 인해, 설계자는 처리 동작에 의거하여 충분한 메모리 블록 또는 인스턴스를 추가하고 이에 따라 캐시 체 계 없이 인스턴스를 관리할 수 있다. 예를 들어, 처리 장치의 아키텍처로 인해, 파이프라인 된 메모리 접 근을 제거함으로써 캐시 체계가 필요하지 않게 될 수 있다. 파이프라인 된 메모리 접근에서, 처리부는 다른 데 이터 라인이 데이터를 수신 또는 전송하는 동안에 특정 데이터 라인이 개방(또는 활성화)될 수 있는 매 사이클 에 지속적인 데이터 흐름을 수신할 수 있다. 개별 통신 라인을 활용한 지속적인 데이터의 흐름으로 인해, 실행 속도는 향상될 수 있고, 라인 변경으로 인한 지연은 최소화될 수 있다. 또한, 도 22에 기재된 아키텍처는 적은 수의 메모리 블록에서 데이터를 구성하고 라인 변경으로 인한 전력 손실 을 줄일 수 있는 파이프라인 된 메모리 접근을 가능하게 한다. 예를 들어, 일부 실시예에서, 컴파일러는 메모리 뱅크의 데이터 구성 또는 데이터 구성 방법을 호스트와 주고받고 주어진 작업 동안에 데이터에 대한 접근 을 가능하게 할 수 있다. 이후, 설정 매니저는 어느 메모리 뱅크가(경우에 따라서는 메모리 뱅크의 어느 포트가) 가속기에 의해 접근될 수 있는지 정의할 수 있다. 메모리 뱅크 내의 데이터 위치와 데이터 접근 방법 사이의 동기화는 데이터를 최소의 지연으로 가속기에 공급함으로써 전산 작업을 개선한다. 예를 들어, 설정 매 니저가 RISC/CPU를 포함하는 실시예에서, 방법은 오프라인 소프트웨어에서 이행될 수 있고, 이후에 설정 매니저는 상기 방법을 실행하도록 프로그램될 수 있다. 방법은 RISC/CPU 컴퓨터에 의해 실행 가능한 모든 언어로 만들어질 수 있고 모든 플랫폼에서 실행될 수 있다. 방법의 입력은 메모리 컨트롤러 뒤의 메모리의 설정 및 메모리 접근 패턴과 함께 데이터 자체를 포함할 수 있다. 또한, 방법은 해당 실시예에 특정된 언어 또는 기 계어로 구현될 수 있고, 단순히 이진수 또는 문자로 된 일련의 설정값일 수도 있다. 앞서 설명한 바와 같이, 일부 실시예에서, 컴파일러는 파이프라인 된 메모리 접근에 대비하여 데이터를 메모리 블록(2202, 2204)에 구성하기 위해 호스트로 명령을 제공할 수 있다. 파이프라인 된 메모리 접근은 일반 적으로 복수의 메모리 뱅크 또는 메모리 블록(2202, 2204)의 복수의 주소를 수신하는 단계, 수신된 주소에 따라 개별 데이터 라인을 사용하여 복수의 메모리 뱅크에 접근하는 단계, 복수의 메모리 뱅크의 제1 메모리 뱅크 내 에 있는 제1 주소로부터 제1 통신 라인을 통하여 복수의 처리부의 적어도 하나로 데이터를 공급하고 복수의 메 모리 뱅크의 제2 메모리 뱅크 내에 있는 제2 주소로 제2 통신 라인을 개통하는 단계, 및 제2 주소로부터 제2 통신 라인을 통하여 복수의 처리부의 적어도 하나로 데이터를 공급하고 제2 클럭 사이클 이내에 제1 통신 라인의 제1 메모리 뱅크 내의 제3 주소로 제3 통신 라인을 개통하는 단계를 포함할 수 있다. 일부 실시예에서, 파이프라인 된 메모리 접근은 단일 포트에 연결된 두 개의 메모리 블록으로 실행될 수 있다. 이러한 실시예에서, 메모리 컨트롤러는 단일 포트 뒤로 메모리 블록을 숨길 수 있지만 파이프라인 된 메모리 접 근 방식으로 처리부에 데이터를 전송할 수 있다. 일부 실시예에서, 컴파일러는 작업을 실행하기 전에 호스트 상에서 실행될 수 있다. 이러한 실시예에서, 컴파일러가 데이터 흐름의 설정을 이미 알고 있을 수 있기 때문에, 컴파일러는 메모리 장치의 아키텍처에 의거 하여 데이터 흐름의 설정을 판단할 수 있을 수 있다. 다른 실시예에서, 오프라인 시간에 메모리 블록(2204, 2202)의 설정을 모르는 경우, 파이프라인 된 방법은 호스 트에서 실행할 수 있고, 호스트는 계산을 시작하기 전에 메모리 블록에 데이터를 배치할 수 있다. 예를 들어, 호스트는 메모리 블록(2204, 2202)에 직접 데이터를 기록할 수 있다. 이러한 실시예에서, 설 정 매니저와 같은 처리부와 메모리 컨트롤러는 필요한 하드웨어에 관한 정보를 런타임까지 모를 수있다. 이후, 작업의 실행이 시작될 때까지 가속기의 선택을 지연할 필요가 있을 수 있다. 이러한 상황에 서, 처리부 또는 메모리 컨트롤러는 가속기를 무작위로 선택하고, 작업이 실행되면서 수정될 수 있 는 검사 데이터 접근 패턴을 생성할 수 있다. 그러나 작업을 미리 아는 경우, 컴파일러는 데이터와 명령을 메모리 뱅크 내에 배치하여 호스트가 접근 지연을 최소화하는 신호 연결을 설정 매니저와 같은 처리부에 설정하게 할 수 있다. 예를 들어, 일부의 경우, 가속기는 동시에 n 개의 워드를 필요로 할 수 있다. 그러나 각 메모리 인스턴스는 한 번에 m 개의 워드만 가져오는 것을 지원할 수 있다. 여기서, m과 n은 모두 정수이고, m < n 이다. 따라서, 컴파일러는 필 요한 데이터를 서로 다른 메모리 인스턴스 또는 블록에 배치하여 데이터 접근을 가능하게 할 수 있다. 또한, 라 인 누락 지연을 방지하기 위해, 호스트는 처리 장치에 다수의 메모리 인스턴스가 있는 경우에 서로 다른 메모리 인스턴스의 서로 다른 라인에 데이터를 나눌 수 있다. 데이터를 분할하면, 현재의 인스턴스에서 데이터 를 계속 사용하면서 다음 인스턴스에 데이터의 다음 라인에 접근하는 것이 가능하다. 예를 들어, 가속기(2216(a))는 두 개의 벡터를 곱하도록 구성될 수 있다. 각 벡터는 메모리 블록(2202, 2204)과 같은 별개의 메모리 블록에 저장될 수 있고, 각 벡터는 다수의 워드를 포함할 수 있다. 따라서, 가속기 (2216(a))에 의한 곱셈을 필요로 하는 작업을 완료하려면, 두 개의 메모리 블록에 접근하고 복수의 워드를 가져 올 필요가 있을 수 있다. 그러나 일부 실시예에서, 메모리 블록은 클럭 사이클 당 하나의 워드만 접근을 허용한 다. 예를 들어, 메모리 블록에는 단일 포트가 있을 수 있다. 이런 경우, 동작 중의 데이터 전송을 빠르게 하기 위해, 컴파일러는 벡터를 구성하는 워드를 서로 다른 메모리 블록에 배치하여 워드의 병렬 및/또는 동시 읽기를 가능하게 할 수 있다. 이런 상황에서, 컴파일러는 전용 라인이 있는 메모리 블록에 워드를 저장할 수 있다. 예 를 들어, 각 벡터가 두 개의 워드를 포함하고 메모리 컨트롤러가 4개의 메모리 블록에 직접 접근이 가능한 경우, 컴파일러는 4개의 메모리 블록에 데이터를 배치하고, 각 메모리 블록은 워드를 전송하고 데이터 전달을 빠르게 할 수 있다. 또한, 메모리 컨트롤러에 각 메모리 블록으로 단일 연결 이상이 있을 수 있는 실시예 에서, 컴파일러는 설정 매니저(또는 다른 처리부)에게 특정 포트로 접근하도록 명령할 수 있다. 이 방법 으로, 처리 장치는 파이프라인 된 메모리 접근을 수행하여, 동시에 일부 라인에서 워드를 로딩하고 다른 라인에서 데이터를 전송함으로써 데이터를 처리부로 지속 제공할 수 있다. 도 23은 기재된 실시예에 따른 예시적인 처리 장치의 구성도이다. 구성도는 MAC 유닛, 설정 매니저 (2304; 설정 매니저와 균등 또는 유사), 메모리 컨트롤러(2306; 메모리 컨트롤러와 균등 또는 유사), 및 복수의 메모리 블록(2308(a)-(d)) 형태의 단일 가속기를 표시하는 단순화 된 처리 장치를 도시 한다. 일부 실시예에서, MAC 유닛은 특정 작업을 처리하기 위한 특정 가속기일 수 있다. 예를 들어, 처리 장치 에 2D-컨볼루션 작업이 부여될 수 있다. 이 경우, 설정 매니저는 적절한 하드웨어를 구비한 가속기 에 이 작업과 연관된 계산을 수행하도록 신호를 보낼 수 있다. 예를 들어, MAC 유닛에는 4개의 내부 증가 카운터(internal incrementing counter; 컨볼루션 계산에 필요한 4개의 루프를 관리하기 위한 논리 합산기 (logical adder) 및 레지스터)와 곱셈-누적부(multiply accumulate unit)가 있을 수 있다. 설정 매니저 는 입력되는 데이터를 처리하고 작업을 실행하도록 MAC 유닛에 신호를 보낼 수 있다. 설정 매니저 는 작업을 실행하라는 표시를 MAC 유닛에 전송할 수 있다. 이러한 상황에서, MAC 유닛은 계산된 주 소에서 반복하고, 수를 곱하고, 내부 레지스터에 누적할 수 있다. 일부 실시예에서, 메모리 컨트롤러가 전용 버스를 활용하여 블록과 MAC 유닛에 접근을 허용 하는 반면, 설정 매니저는 가속기를 설정할 수 있다. 그러나 다른 실시예에서, 설정 매니저 또는 외부 인터페이스로부터 수신된 명령에 의거하여 메모리 컨트롤러가 직접 가속기를 설정할 수 있다. 대안 적으로 또는 추가적으로, 설정 매니저는 몇 가지 설정을 미리 로드하고 가속기가 서로 다른 크기를 가진 서로 다른 주소 상에서 반복적으로 실행하도록 할 수 있다. 이러한 실시예에서, 설정 매니저는 가속기 와 같은 복수의 처리부의 적어도 하나로 명령이 전송되기 전에 명령을 저장하는 캐시 메모리를 포함할 수 있다. 그러나 다른 실시예에서, 설정 매니저는 캐시를 포함하지 않을 수 있다. 일부 실시예에서, 설정 매니저 또는 메모리 컨트롤러는 작업을 위해 접근될 필요가 있는 주소를 수 신할 수 있다. 설정 매니저 또는 메모리 컨트롤러는 레지스터를 확인하여 메모리 블록의 하 나에 로드된 라인에 이 주소가 이미 있는지 여부를 판단할 수 있다. 이 주소가 이미 있는 경우, 메모리 컨트롤 러는 메모리 블록으로부터 워드를 읽어서 MAC 유닛으로 전달할 수 있다. 로드된 라인에 이 주소가 없는 경우, 설정 매니저는 메모리 컨트롤러에게 이 라인을 로드하도록 요청하고 MAC 유닛에게 이 주소를 가져올 때까지 대기하라는 신호를 보낼 수 있다. 일부 실시예에서, 도 23에 도시된 바와 같이, 메모리 컨트롤러는 두 개의 개별 주소로부터 두 개의 입력 을 포함할 수 있다. 그러나 둘 이상의 주소에 동시에 접근해야 하고, 이러한 주소가 단일 메모리 블록에 있는 경우(예를 들어, 메모리 블록(2308(a))에만 있는 경우), 메모리 컨트롤러 또는 설정 매니저는 예외 를 둘 수 있다. 또는, 설정 매니저는 두 주소가 단일 라인을 통해서만 접근 가능한 경우에 무효 데이터 신호를 출력할 수 있다. 다른 실시예에서, 유닛은 필요한 모든 데이터를 가져올 수 있을 때까지 프로세스 실행 을 지연할 수 있다. 이로 인해, 전체적인 성능이 저하될 수 있다. 그렇지만, 컴파일러는 지연을 방지할 수 있는 설정과 데이터 배치를 찾을 수 있다. 일부 실시예에서, 컴파일러는 설정 매니저와 메모리 컨트롤러와 가속기가 단일 메모리 블록 으로부터 여러 주소가 접근되어야 하지만 메모리 블록에 포트가 하나뿐인 상황을 대응하도록 설정할 수 있는 처 리 장치에 대한 설정 또는 명령을 생성할 수 있다. 예를 들어, 컴파일러는 처리부가 메모리 블록의 여러 라인에 접속할 수 있도록 메모리 블록에 데이터를 재배치할 수 있다. 또한, 메모리 컨트롤러는 하나 이상의 입력에 대해 동시에 작용할 수 있다. 예를 들면, 메모리 컨트롤러 는 한 포트를 통하여 메모리 블록의 하나에 접근을 허용하고 다른 입력에서 다른 메모리 블록의 요 청을 수신하면서 데이터를 공급하는 것을 허용할 수 있다. 따라서, 이러한 동작의 결과로, 해당 메모리 블록과 의 통신의 전용 라인으로부터 데이터를 수신하는 예시적인 2D-컨볼루션 작업이 가속기에 부여될 수 있다. 추가적으로 또는 대안적으로, 메모리 컨트롤러 또는 로직 블록은 각 메모리 블록에 대해 리프레쉬 카운터 를 보유하고 모든 라인의 리프레쉬를 처리할 수 있다. 이런 카운터가 있으면, 메모리 컨트롤러가 장치로 부터의 데드 액세스 타임(dead access times) 사이에 리프레쉬 사이클을 삽입할 수 있다. 또한, 메모리 컨트롤러는 파이프라인 된 메모리 접근을 수행하여 데이터를 공급하기 전에 주소를 수신하 고 메모리 블록에 라인을 개통하도록 설정하는 것이 가능할 수 있다. 파이프라인 된 메모리 접근은 중단 또는 지연된 클럭 사이클 없이 데이터를 처리부로 제공할 수 있다. 예를 들어, 메모리 컨트롤러 또는 로직 블 록의 하나가 도 23의 우측 라인으로 데이터에 접근하는 반면, 좌측 라인에서 데이터가 전송될 수 있다. 이 방법 에 대해서는 도 26을 참조하여 상세히 설명하기로 한다. 요구되는 데이터에 대응하여, 처리 장치는 멀티플렉서 및/또는 기타 스위칭 장치를 활용하여 어느 장치가 주어진 작업을 수행할지를 선택할 수 있다. 예를 들어, 설정 매니저는 적어도 두 개의 데이터 라인이 MAC 유닛까지 이어지도록 멀티플렉서를 설정할 수 있다. 이로써, 컨볼루션 중에 곱셈을 필요로 하는 벡터 또 는 워드가 단일 클럭에서 동시에 처리부에 도달할 수 있기 때문에, 2D-컨볼루션과 같이 여러 주소로부터의 데이 터를 필요로 하는 작업의 수행이 빨라질 수 있다. 이러한 데이터 전송 방법으로 인해, 가속기와 같은 처 리부는 결과를 신속하게 출력할 수 있다. 일부 실시예에서, 설정 매니저는 작업의 우선순위에 의거하여 프로세스를 실행하도록 설정하는 것이 가능 할 수 있다. 예를 들어, 설정 매니저는 중단 없이 실행 프로세스를 완료하도록 설정될 수 있다. 이 경우, 설정 매니저는 명령 또는 작업의 설정을 가속기에 제공하고, 중단 없이 실행되도록 하고, 작업이 완료된 경우에만 멀티플렉서를 스위치 할 수 있다. 그러나 다른 실시예에서, 설정 매니저는 외부 인터페 이스의 요청과 같은 우선 작업을 수신하는 경우에 작업을 중단하고 데이터 라우팅을 재설정할 수 있다. 그러나 메모리 블록이 충분히 있으면, 메모리 컨트롤러는 작업이 완료될 때까지 변경되지 않아도 되는 전 용 라인이 있는 처리부로 데이터를 라우팅하거나 접근을 허용하도록 설정될 수 있다. 또한, 일부 실시예에서, 모든 장치는 버스에 의해 설정 매니저의 입구로 연결될 수 있고, 장치는 장치와 버스 사이의 접속을 관리 (예, 멀티플렉서와 동일한 로직을 활용)할 수 있다. 따라서, 메모리 컨트롤러는 복수의 메모리 인스턴스 또는 메모리 블록에 직접 연결될 수 있다. 또는, 메모리 컨트롤러는 메모리 서브-인스턴스(sub-instance)에 직접 연결될 수 있다. 일부 실시예에서, 각 메모리 인스턴스 또는 블록은 서브-인스턴스로부터 구성될 수 있다(예를 들어, DRAM은 개별적인 데이터 라인 이 여러 서브블록(sub-block)으로 배치된 매트로부터 구성될 수 있다). 또한, 인스턴스는 DRAM 매트, DRAM, 뱅 크, 플래시 매트, SRAM 매트, 또는 기타 유형의 메모리를 포함할 수 있다. 이후, 메모리 컨트롤러는 어드 레스 서브-인스턴스로의 전용 라인을 포함하여 파이프라인 된 메모리 접근 중의 지연을 직접 최소화할 수 있다. 일부 실시예에서, 메모리 컨트롤러는 또한 특정 메모리 인스턴스에 필요한 로직(로우/컬럼 디코더, 리프 레쉬 로직 등)을 구비하고, 메모리 블록은 자체 로직을 처리할 수 있다. 따라서, 메모리 블록은 주소를 확보하고 출력/기록 데이터에 대한 명령을 생성할 수 있다. 도 24는 기재된 실시예에 따른 예시적인 메모리 구성도를 도시한다. 일부 실시예에서, 처리 장치에 대한 코드 또는 설정을 생성하는 컴파일러는 데이터를 각 메모리 블록에 사전 배치하여 메모리 블록들(2202, 2204)로 부터 로딩을 설정하는 방법을 수행할 수 있다. 예를 들어, 컴파일러는 작업에 필요한 각 워드가 메모리 인스턴 스 또는 메모리 블록의 라인에 상호 연관되도록 데이터를 사전 배치할 수 있다. 그러나 처리 장치의 사용 가능한 메모리 블록보다 많은 메모리 블록을 필요로 하는 작업에 대해, 컴파일러는 각 메모리 블록의 하나 이상 의 메모리 위치에 데이터를 맞추는 방법을 이행할 수 있다. 컴파일러는 또한 데이터를 시퀀스로 저장하고, 라인 누락 지연을 피하기 위해 각 메모리 블록의 지연을 평가할 수 있다. 일부 실시예에서, 호스트는 설정 매니저 와 같은 처리부의 일부일 수 있지만, 다른 실시예에서, 컴파일러 호스트는 외부 인터페이스를 통해 처리 장치에 연결될 수 있다. 이러한 실시예에서, 호스트는 컴파일러에 대해 설명한 것과 같은 컴파일링 기능 을 실행할 수 있다. 일부 실시예에서, 설정 매니저는 CPU 또는 마이크로컨트롤러(uC)일 수 있다. 이러한 실시예에서, 설정 매 니저는 메모리에 접근하여 메모리에 배치된 명령을 가져와야 할 수 있다. 특정 컴파일러는 연속 명령이 동일 메모리 라인과 다수의 메모리 뱅크에 저장되어 가져온 명령에 대한 파이프라인 된 메모리 접근이 허용되도 록 하는 방식으로 코드를 생성하고 메모리에 배치할 수 있다. 이러한 실시예에서, 설정 매니저와 메모리 컨트롤러는 파이프라인 된 메모리 접근을 가능하게 함으로써 선형 실행에서 행 지연을 방지하는 것이 가 능할 수 있다. 프로그램의 선형 실행의 이전 경우의 방법에서는, 컴파일러가 명령을 인지하고 배치하여 파이프라인 된 메모리 실행을 하였다. 그러나 다른 소프트웨어 구조는 더 복잡할 수 있고 컴파일러가 명령을 인지하고 그에 따라 동작 하는 것이 요구될 수 있다. 예를 들어, 작업에 루프와 브랜치(branches)가 필요한 경우, 컴파일러는 모든 루프 코드를 단일 라인 내부에 배치하여 단일 라인이 라인 개통 지연 없이 반복되게 할 수 있다. 이에 따라, 메모리 컨트롤러는 실행 중에 라인을 변경할 필요가 없을 수 있다. 일부 실시예에서, 설정 매니저는 내부 캐싱 또는 소형 메모리를 포함할 수 있다. 내부 캐싱은 설정 매니 저에 의해 실행되는 명령을 저장하여 브랜치와 루프를 처리할 수 있다. 예를 들어, 내부 캐싱 메모리의 명령은 메모리 블록에 접근하기 위해 가속기를 설정하는 명령을 포함할 수 있다. 도 25는 기재된 실시예에 따른 메모리 설정 프로세스를 도시한 예시적인 순서도이다. 메모리 설정 프로세 스 설명의 편의상, 앞서 설명한 도 22에 도시된 구성요소가 참조될 수 있다. 일부 실시예에서, 프로세스 는 외부 인터페이스를 통해 연결된 호스트로 명령을 제공하는 컴파일러에 의해 실행될 수 있다. 다른 실 시예에서, 프로세스는 설정 매니저와 같은 처리 장치의 구성요소에 의해 실행될 수 있다. 일반적으로, 프로세스는 작업의 수행을 위해 동시에 필요한 워드의 수를 판단하는 단계, 복수의 메모리 뱅크 각각으로부터 동시에 접근될 수 있는 워드의 수를 판단하는 단계, 및 동시에 필요한 워드의 수가 동시에 접근될 수 있는 워드의 수보다 큰 경우에 동시에 필요한 워드의 수를 여러 메모리 뱅크 사이에 분할하는 단계를 포함할 수 있다. 또한, 동시에 필요한 워드의 수를 분할하는 단계는 사이클릭(cyclic) 구조의 워드를 실행하는 단계 및 메모리 뱅크당 한 워드를 순차적으로 배정하는 단계를 포함할 수 있다. 더욱 구체적으로, 프로세스는 컴파일러가 작업 사양을 수신할 수 있는 단계 2502로 시작할 수 있다. 이 사양은 요구되는 계산 및/또는 우선순위 레벨을 포함할 수 있다. 단계 2504에서, 컴파일러는 작업을 수행할 수 있는 가속기 또는 가속기의 그룹을 식별할 수 있다. 또는, 컴파일 러는 작업을 수행할 가속기를 설정 매니저와 같은 처리부가 식별할 수 있도록 명령을 생성할 수 있다. 예 를 들어, 요구되는 계산을 활용하여, 설정 매니저는 가속기의 그룹에서 작업을 수행할 수 있는 가속기를 식별할 수 있다. 단계 2506에서, 컴파일러는 작업을 실행하기 위해 동시에 접근돼야 하는 워드의 수를 판단할 수 있다. 예를 들 어, 두 벡터의 곱셈을 하려면 적어도 두 벡터에 접근해야 하고, 따라서 컴파일러는 연산을 수행하기 위해 벡터 워드가 동시에 접근돼야 한다고 판단할 수 있다. 단계 2508에서, 컴파일러는 작업을 실행하기 위해 필요한 사이클의 수를 판단할 수 있다. 예를 들면, 4개의 부 수곱(by-product)의 컨볼루션 연산이 작업에 필요한 경우, 컴파일러는 작업을 수행하기 위해 적어도 4 사이클이 필요할 것이라고 판단할 수 있다. 단계 2510에서, 컴파일러는 동시에 접근될 필요가 있는 워드를 서로 다른 메모리 뱅크에 배치할 수 있다. 이로 써, 메모리 컨트롤러는, 캐시에 저장된 데이터가 필요 없이, 서로 다른 메모리 인스턴스로 라인을 개통하 고 필요한 메모리 블록에 클럭 사이클 이내에 접근하도록 설정될 수 있다. 단계 2512에서, 컴파일러는 순차적으로 접근되는 워드를 동일한 메모리 뱅크에 배치할 수 있다. 예를 들어, 4 사이클의 연산이 필요한 경우, 컴파일러는 실행 중에 서로 다른 메모리 블록 사이의 라인 변경을 방지하기 위하 여 단일 메모리 블록에 순차적 사이클로 필요한 워드를 쓰도록 하는 명령을 생성할 수 있다. 단계 2514에서, 컴파일러는 설정 매니저와 같은 처리부를 프로그램하는 명령을 생성할 수 있다. 명령은 스위칭 장치(예, 멀티플렉서)를 작동하거나 데이터 버스를 설정하는 조건을 명시할 수 있다. 이러한 명령으로, 설정 매니저는 메모리 컨트롤러가 작업에 따른 전용 통신 라인을 활용하여 데이터를 메모리 블록에 서 처리부로 라우팅하거나 메모리 블록에 대한 접근을 허용하도록 설정할 수 있다. 도 26은 기재된 실시예에 따른 메모리 읽기 프로세스를 도시한 예시적인 순서도이다. 메모리 읽기 프로세 스 설명의 편의상, 앞서 설명한 도 22에 도시된 구성요소가 참조될 수 있다. 일부 실시예에서, 하기에 설 명하는 바와 같이, 프로세스는 메모리 컨트롤러에 의해 이행될 수 있다. 그러나 다른 실시예에서, 프로세스는 설정 매니저와 같은 처리 장치의 다른 구성요소에 의해 이행될 수 있다. 단계 2602에서, 메모리 컨트롤러, 설정 매니저, 또는 기타 처리부는 메모리 뱅크로 데이터를 라우 팅하거나 메모리 뱅크에 대한 접근을 허용하도록 하는 요청을 수신할 수 있다. 이 요청은 주소와 메모리 블록을 명시할 수 있다. 일부 실시예에서, 상기 요청은 라인 2218의 읽기 명령 및 라인 2220의 주소를 명시하는 데이터 버스를 통해 수 신될 수 있다. 다른 실시예에서, 상기 요청은 메모리 컨트롤러에 연결된 디멀티플렉서를 통해 수신될 수 있다. 단계 2604에서, 설정 매니저, 호스트, 또는 기타 처리부는 내부 레지스터를 쿼리할 수 있다. 내부 레지스 터는 메모리 뱅크로 개통된 라인, 개통된 주소, 개통된 메모리 블록, 및/또는 다음 작업에 관한 정보를 포함할 수 있다. 내부 레지스터에 있는 정보에 의거하여, 메모리 뱅크로 개통된 라인이 있는지 여부 및/또는 메모리 블 록이 단계 2602에서 요청을 수신했는지 여부가 판단될 수 있다. 대안적으로 또는 추가적으로, 메모리 컨트롤러 가 직접 내부 레지스터를 쿼리할 수 있다. 개통된 라인에 메모리 뱅크가 로딩되어 있지 않다고 내부 레지스터가 나타내는 경우(즉, 단계 2606에서 '아니오'), 프로세스는 단계 2616으로 진행하여 수신된 주소와 연관된 메모리 뱅크로 라인이 로딩될 수 있다. 또한, 메모리 컨트롤러 또는 설정 매니저와 같은 처리부는 단계 2616에서 메모리 주소로부터 정보를 요청하는 구성요소로 지연 신호를 보낼 수 있다. 예를 들어, 가속기가 이미 사용중인 메모리 블록 에 위치한 메모리 정보를 요청하는 경우, 메모리 컨트롤러는 단계 2618에서 가속기로 지연 신호를 보낼 수 있다. 단계 2620에서, 설정 매니저 또는 메모리 컨트롤러는 내부 레지스터를 업데이트하여 새로운 메모리 뱅크 또는 새로운 메모리 블록으로 라인이 개통됐음을 나타낼 수 있다. 개통된 라인에 메모리 뱅크가 로딩되어 있다고 내부 레지스터가 나타내는 경우(즉, 단계 2606에서 '예'), 프로 세스는 단계 2608로 진행할 수 있다. 단계 2608에서, 메모리 뱅크에 로딩된 라인이 다른 주소에 사용되고 있는지 여부가 판단될 수 있다. 라인이 다른 주소에 사용되고 있는 경우(즉, 단계 2608에서 '예'), 단일 블록에 두 인스턴스가 있는 것을 나타내는 것일 수 있으므로, 동시에 접근될 수 없다. 따라서, 단계 2616에서 메모리 주소로부터 정보를 요청하는 구성요소로 오류 또는 면제 신호가 전송될 수 있다. 그러나 라인이 다른 주소에 사 용되고 있지 않은 경우(즉, 단계 2608에서 '아니오'), 라인이 주소에 대해 개통될 수 있고 타깃 메모리 뱅크로 부터 데이터를 가져오고 단계 2614로 진행하여 메모리 주소로부터 정보를 요청하는 구성요소로 데이터를 전송할 수 있다. 프로세스를 통해, 처리 장치는 작업을 수행하는데 필요한 정보를 포함하는 메모리 블록 또는 메모 리 인스턴스와 처리부 사이의 직접 연결을 구축할 수 있다. 이러한 데이터의 구성으로 인해, 서로 다른 메모리 인스턴스 내에 구성된 벡터로부터 정보를 읽는 것이 가능할 뿐만 아니라 장치가 복수의 이런 주소를 요청하는 경우에 서로 다른 메모리 블록으로부터 동시에 정보를 가져오는 것이 가능할 수 있다. 도 27은 기재된 실시예에 따른 실행 프로세스를 도시한 예시적인 순서도이다. 실행 프로세스 설명 의 편의상, 앞서 설명한 도 22에 도시된 구성요소가 참조될 수 있다. 단계 2702에서, 컴파일러 또는 설정 매니저와 같은 로컬 유닛은 수행되어야 하는 작업의 요청을 수신할 수 있다. 작업은 단일 연산(예, 곱셈) 또는 복합 연산(예, 행렬 사이의 컨볼루션)을 포함할 수 있다. 작업은 또 한 필요한 계산을 나타낼 수 있다. 단계 2704에서, 컴파일러 또는 설정 매니저는 작업을 수행하기 위해 동시에 요구되는 워드의 수를 판단할 수 있다. 예를 들어, 설정 매니저 또는 컴파일러는 벡터 사이의 곱셈을 수행하기 위해 두 워드가 동시에 필요하 다고 판단할 수 있다. 다른 예로써, 2D 컨볼루션 작업에서, 설정 매니저는 'n'과 'm'이 각각 행렬 차원인 'n' 곱하기 'm'의 워드가 행렬 사이의 컨볼루션을 위해 필요하다고 판단할 수 있다. 단계 2704에서, 설정 매니 저는 또한 작업을 수행하기 위해 필요한 사이클의 수를 판단할 수 있다. 단계 2706에서, 단계 2704의 판단에 따라, 컴파일러는 동시에 접근되어야 하는 워드를 기판 상에 배치된 복수의 메모리 뱅크에 기록할 수 있다. 예를 들어, 복수의 메모리 뱅크로부터 동시에 접근될 수 있는 워드의 수가 동시 에 필요한 워드의 수보다 적은 경우, 컴파일러는 데이터를 여러 메모리 뱅크에 배치하여 필요한 서로 다른 워드 에 클럭 이내에 접근 가능하게 할 수 있다. 또한, 작업을 수행하기 위해 여러 사이클이 필요하다고 설정 매니저 또는 컴파일러가 판단하는 경우, 컴파일러는 필요한 워드를 순차적 사이클로 복수의 메모리 뱅크의 단일 메모리 뱅크에 기록하여 메모리 뱅크 사이의 라인 변경을 방지할 수 있다. 단계 2708에서, 메모리 컨트롤러는 제1 메모리 라인을 이용하여 복수의 메모리 뱅크 또는 블록의 제1 메 모리 뱅크에서 적어도 하나의 제1 워드를 읽거나 적어도 하나의 제1 워드에 대한 접근을 허용하도록 설정될 수 있다. 단계 2170에서, 가속기의 하나와 같은 처리부는 적어도 하나의 제1 워드를 활용하여 작업을 처리할 수 있 다. 단계 2712에서, 메모리 컨트롤러는 제2 메모리 뱅크에 제2 메모리 라인을 개통하도록 설정될 수 있다. 예 를 들어, 작업에 의거하고 파이프라인 된 메모리 접근 방식을 활용하여, 메모리 컨트롤러는 작업에 필요 한 정보가 단계 2706에서 기록된 제2 메모리 블록에 제2 메모리 라인을 개통하도록 설정될 수 있다. 일부 실시 예에서, 제2 메모리 라인은 단계 2170의 작업이 완료되려는 시점에 개통될 수 있다. 예를 들어, 작업에 100 클 럭이 필요한 경우, 제2 메모리 라인은 90번째 클럭에서 개통될 수 있다. 일부 실시예에서, 단계 2708 내지 단계 2712는 하나의 라인 액세스 사이클 이내에 실행될 수 있다. 단계 2714에서, 메모리 컨트롤러는 단계 2710에서 개통된 제2 메모리 라인을 활용하여 제2 메모리 뱅크의 적어도 하나의 제2 워드의 데이터에 대한 접근을 허용하도록 설정될 수 있다. 단계 2176에서, 가속기의 하나와 같은 처리부는 적어도 하나의 제2 워드를 활용하여 작업을 처리할 수 있 다. 단계 2718에서, 메모리 컨트롤러는 제1 메모리 뱅크에 제2 메모리 라인을 개통하도록 설정될 수 있다. 예 를 들어, 작업에 의거하고 파이프라인 된 메모리 접근 방식을 활용하여, 메모리 컨트롤러는 제1 메모리 블록으로의 제2 메모리 라인을 개통하도록 설정될 수 있다. 일부 실시예에서, 제1 블록으로의 제2 메모리 라인 은 단계 2176의 작업이 완료되려는 시점에 개통될 수 있다. 일부 실시예에서, 단계 2714 내지 단계 2718은 하나의 라인 액세스 사이클 이내에 실행될 수 있다. 단계 2720에서, 메모리 컨트롤러는 제1 뱅크의 제2 메모리 라인 또는 제3 뱅크의 제1 라인을 활용하고 다른 메 모리 뱅크로 진행하여 복수의 메모리 뱅크의 제1 메모리 뱅크에서 적어도 하나의 제3 워드를 읽거나 적어도 하 나의 제3 워드에 대한 접근을 허용할 수 있다. 상기의 설명은 예시의 목적으로 제시되었다. 이 설명은 모든 것을 망라한 것이 아니며 기재된 그대로의 형태 또 는 실시예로 제한되는 것이 아니다. 수정 및 응용은 본 명세서를 고려하고 기재된 실시예를 실시함으로써 당업 자에게 당연할 것이다. 또한, 기재된 실시예의 양상들이 메모리에 저장되는 것으로 설명되었지만, 당업자라면 이러한 양상들이, 예를 들어, 하드 디스크 또는 CD ROM, 또는 다른 유형의 RAM 또는 ROM, USB 매체, DVD, 블루 레이, UHD 블루레이, 또는 기타 광드라이브 매체 등의 2차 저장장치와 같은 다른 유형의 컴퓨터 가독 매체에 저 장될 수도 있음을 이해할 것이다. 기재된 설명과 방법에 기반한 컴퓨터 프로그램은 당업자에게는 당연한 기술이다. 다양한 프로그램 또는 프로그 램 모듈이 당업자에게 공지인 기술을 사용하여 생성되거나 기존의 소프트웨어와 관련되어 설계될 수 있다. 예를들어, 프로그램 섹션 또는 프로그램 모듈은 .Net Framework, .Net Compact Framework (및 Visual Basic, C 등 과 같은 관련 언어), Java, C++, Objective-C, HTML, HTML/AJAX 조합, XML, 또는 자바 애플릿(Java applet)을 포함하는 HTML로 설계될 수 있다. 또한, 예시된 실시예들을 여기에 설명하였지만, 모든 실시예의 범위는 균등한 구성요소, 수정, 누락, 조합(예, 다양한 실시예에 걸친 양상의 조합), 응용, 및/또는 변경을 가짐은 본 발명의 당업자에게 당연하다. 청구항의 한정은 청구항에 사용된 언어에 근거하여 넓게 해석되어야 하며 본 명세서에서 또는 본 발명의 출원 중에 설명 된 예시에 한정되지 않는다. 예시들은 배타적이지 않은 것으로 이해되어야 한다. 나아가, 기재된 방법의 단계들 은 단계들의 순서를 재배열 및/또는 단계를 삽입 또는 삭제하는 등의 다양한 방법으로 수정될 수 있다. 따라서, 본 명세서와 예시들은 예시의 목적으로만 고려되고, 진정한 범위와 기술적 사상은 하기의 청구항과 그 균등한 범위에 의해 정의된다."}
{"patent_id": "10-2020-7006169", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 기재에 포함되고 본 기재의 일부를 구성하는 첨부 도면은 기재된 다양한 실시예를 도시한다. 도 1은 중앙처리장치(CPU)를 개략적으로 도시한 것이다. 도 2는 그래픽처리장치(GPU)를 개략적으로 도시한 것이다. 도 3a는 기재된 실시예에 따른 예시적인 하드웨어 칩의 일 실시예를 개략적으로 도시한 것이다. 도 3b는 기재된 실시예에 따른 예시적인 하드웨어 칩의 다른 실시예를 개략적으로 도시한 것이다. 도 4는 기재된 실시예에 따른 예시적인 하드웨어 칩에 의해 실행되는 일반적인 명령을 개략적으로 도시한 것이다. 도 5는 기재된 실시예에 따른 예시적인 하드웨어 칩에 의해 실행되는 특수한 명령을 개략적으로 도시한 것이다. 도 6은 기재된 실시예에 따른 예시적인 하드웨어 칩에서 사용하기 위한 프로세싱 그룹을 개략적으로 도시한 것 이다. 도 7a는 기재된 실시예에 따른 프로세싱 그룹의 장방형 어레이를 개략적으로 도시한 것이다. 도 7b는 기재된 실시예에 따른 프로세싱 그룹의 타원형 어레이를 개략적으로 도시한 것이다. 도 7c는 기재된 실시예에 따른 하드웨어 칩의 어레이를 개략적으로 도시한 것이다. 도 7d는 기재된 실시예에 따른 하드웨어 칩의 다른 어레이를 개략적으로 도시한 것이다. 도 8은 기재된 실시예에 따른 예시적인 하드웨어 칩 상에서의 실행을 위한 일련의 명령을 컴파일하기 위한 예시 적인 방법을 도시한 순서도이다. 도 9는 메모리 뱅크를 개략적으로 도시한 것이다. 도 10은 메모리 뱅크를 개략적으로 도시한 것이다. 도 11은 기재된 실시예에 따른 서브뱅크 컨트롤이 있는 예시적인 메모리 뱅크의 일 실시예를 개략적으로 도시한 것이다. 도 12는 기재된 실시예에 따른 서브뱅크 컨트롤이 있는 예시적인 메모리 뱅크의 다른 실시예를 개략적으로 도시 한 것이다 도 13은 기재된 실시예에 따른 예시적인 메모리 칩의 구성도이다. 도 14는 기재된 실시예에 따른 예시적인 리던던트 로직 블록 세트의 구성도이다. 도 15는 기재된 실시예에 따른 예시적인 로직 블록의 구성도이다. 도 16은 기재된 실시예에 따른 버스가 연결된 예시적인 로직 블록의 구성도이다. 도 17은 기재된 실시예에 따른 직렬로 연결된 예시적인 로직 블록의 구성도이다. 도 18은 기재된 실시예에 따른 2차원 어레이로 연결된 예시적인 로직 블록의 구성도이다. 도 19는 기재된 실시예에 따른 복잡하게 연결된 예시적인 로직 블록에 대한 구성도이다. 도 20은 기재된 실시예에 따른 리던던트 블록 활성화 프로세스를 도시한 예시적인 순서도이다. 도 21은 기재된 실시예에 따른 어드레스 배정 프로세스를 도시한 예시적인 순서도이다. 도 22는 기재된 실시예에 따른 예시적인 처리 장치에 대한 구성도이다. 도 23은 기재된 실시예에 따른 예시적인 처리 장치의 구성도이다. 도 24는 기재된 실시예에 따른 예시적인 메모리 구성도를 포함한다. 도 25는 기재된 실시예에 따른 메모리 설정 프로세스를 도시한 예시적인 순서도이다. 도 26은 기재된 실시예에 따른 메모리 읽기 프로세스를 도시한 예시적인 순서도이다. 도 27은 기재된 실시예에 따른 실행 프로세스를 도시한 예시적인 순서도이다."}
