{"patent_id": "10-2011-7003099", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2011-0052614", "출원번호": "10-2011-7003099", "출원인": "해저드, 크리스토퍼", "발명자": "해저드, 크리스토퍼"}}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "시나리오를 시뮬레이션하는 방법으로서, 상기 시나리오에서의 오브젝트인 에이전트를 제공하는 단계;상기 시뮬레이션되는 시나리오와 상호 작용 (interact)하는 적어도 하나의 플레이어 그리고/또는 상기 에이전트를 위한 현재 시각에 관해서 가장 멀리 도달할 수 있는 과거 시각과 가장 멀리 도달할 수 있는 미래 시각에 걸친, 상기 시나리오용의 타임 윈도우를 제공하는 단계;상기 에이전트의 적어도 하나의 속성에서의 변화를 나타내는 적어도 하나의 이벤트를 제공하는 단계; 및 상기 적어도 하나의 이벤트를 상기 타임 윈도우 내의 상기 에이전트에게 적용하여 상기 시나리오의 상태를 업데이트하는 단계를 포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 적어도 하나의 이벤트는 상기 현재 시각 이전에 발생하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서,상기 적어도 하나의 이벤트는 상기 현재 시각 이후에 발생하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 시나리오는 제1 타임 레이트 (time rate)로 시뮬레이션되며,이 경우에 상기 시나리오의 상태를 업데이트하는 것은 전방 시간 방향에서 제2 타임 레이트로 상기 시나리오의상태를 업데이트하는 것을 포함하여, 상기 제1 타임 레이트에 대한 제2 타임 레이트의 비율이 1.0 이상이 되도록 하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서, 상기 시나리오는 제1 타임 레이트 (time rate)로 시뮬레이션되며, 그리고이 경우에 상기 시나리오의 상태를 업데이트하는 것은 전방 시간 방향에서 제2 타임 레이트로 상기 시나리오의상태를 업데이트하여, 상기 제1 타임 레이트에 대한 상기 제2 타임 레이트의 비율이 0 이상이고 1 보다는 작도록 하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 시나리오는 제1 타임 레이트로 시뮬레이션되며, 그리고상기 시나리오의 상태를 업데이트하는 것은 후방 시간 방향에서 제2 타임 레이트로 상기 시나리오의 상태를 업데이트하여, 상기 제1 타임 레이트에 대한 제2 타임 레이트의 비율이 0 보다 작도록 하는, 시나리오 시뮬레이션방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,공개특허 10-2011-0052614-2-상기 에이전트에 의해 수행되는 행동들을 결정하는 스크립트를 제공하는 단계를 더 포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 에이전트에 의해 수행되는 상기 행동들은 다른 에이전트의 행동에 응답하는 행동들 및/또는 상기 에이전트들에 의해 제어될 수 없는, 만족되지 않는 적어도 하나의 조건을 기반으로 하여 트리거되는 강제된 행동들을 더포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서, 상기 방법은:상기 에이전트를 시간에 있어서 원래의 포인트로부터 시간에 있어서 다른 포인트로 크로노포팅 (chronoporting)하는 단계;시간에 있어서의 상기 다른 포인트에서 상기 에이전트의 복제를 생성하는 단계; 및상기 에이전트를 전방 시간에 있는 상기 원래의 포인트에서 파괴하는 단계를 더 포함하는, 시나리오 시뮬레이션방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1항에 있어서, 상기 방법은,상기 시나리오를 시뮬레이션하는 것이 시작된 후에 제2 에이전트를 생성하기 위해 상기 에이전트를 이용하는 단계를 더 포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제1항에 있어서, 상기 방법은,상기 적어도 하나의 플레이어를 경유하여 상기 에이전트에게 명령을 발하는 (issue) 단계를 더 포함하는 단계를더 포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서, 상기 방법은,상기 명령을 상기 에이전트에게 발하기 이전에 상기 적어도 하나의 플레이어의 시간 위치를 변경하는 단계를 더포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제11항에 있어서,상기 명령은 다른 명령을 취소시켜서 상기 다른 명령과 연관된 행동이 발생하는 것을 방지하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제12항에 있어서, 상기 방법은,상기 적어도 하나의 플레이어가 현재의 시간 이전에 그리고/또는 이후에 명령들을 발할 수 있는 능력을 제한하는 단계를 더 포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제1항에 있어서,복수의 플레이어들이 상기 시뮬레이션된 시나리오와 상호 작용 (interact)하고 그리고공개특허 10-2011-0052614-3-상기 시나리오의 상태를 업데이트하는 것은:상기 복수의 플레이어들 중의 첫 번째 플레이어에 대해서 상기 타임 윈도우 내에서 상기 적어도 하나의 이벤트를 상기 에이전트에 적용하여 상기 시나리오의 상태를 업데이트하는 단계; 및상기 복수의 플레이어들 중의 두 번째 플레이어에 대해서 상기 타임 윈도우 내에서 상기 적어도 하나의 이벤트를 상기 에이전트에 적용하여 상기 시나리오의 상태를 업데이트하는 단계를 포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서,상기 복수의 플레이어들 중의 상기 첫 번째 플레이어에 대해서 상기 시나리오의 상태를 업데이트하는 것은 제1타임 레이트로 발생하고 그리고상기 복수의 플레이어들 중의 상기 두 번째 플레이어에 대해서 상기 시나리오의 상태를 업데이트하는 것은 상기제1 타임 레이트와는 다른 제2 타임 레이트로 발생하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제15항에 있어서, 상기 방법은:상기 적어도 하나의 이벤트를 더 나중의 시각으로 복사하는 단계를 더 포함하며, 상기 더 나중의 시각은 상기 에이전트가 상기 적어도 하나의 이벤트의 원래 시간과 상기 더 나중의 시각 사이의시각에 대해서 아이들 (idle) 일 때의 스냅샷 구간에 상기 적어도 하나의 이벤트의 원래 시간을 더한 것에 대응하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제1항에 있어서,상기 적어도 하나의 플레이어는 인공 지능 (Artificial Intelligence (AI)) 시스템인, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제1항에 있어서,상기 시나리오의 상태를 업데이트하는 것은 상기 타임 윈도우에서 시간 상에서 이격되어 위치되어 있는 복수의업데이터들을 이용하여 상기 시나리오의 상태를 업데이트하는 것을 포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제19항에 있어서,상기 시나리오의 상태를 업데이트하는 것은 상기 윈도우에서 다중의 시간 위치 오프세트들로부터 동시에 상기시나리오의 상태를 업데이트하는 것을 포함하는, 시나리오 시뮬레이션 방법."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "시나리오를 시뮬레이션하는 시스템으로서, 데이터 프로세싱 시스템을 포함하며,상기 데이터 프로세싱 시스템은:상기 시나리오에서의 오브젝트인 에이전트를 제공하도록 구성되며,상기 시뮬레이션되는 시나리오와 상호 작용하는 적어도 하나의 플레이어 그리고/또는 상기 에이전트를 위한 현재 시각에 관해서 가장 멀리 도달할 수 있는 과거 시각과 가장 멀리 도달할 수 있는 미래 시각에 걸친, 상기 시나리오용의 타임 윈도우를 제공하도록 구성되며,공개특허 10-2011-0052614-4-상기 에이전트의 적어도 하나의 속성에서의 변화를 나타내는 적어도 하나의 이벤트를 제공하도록 구성되며, 그리고상기 적어도 하나의 이벤트를 상기 타임 윈도우 내의 상기 에이전트에게 적용하여 상기 시나리오의 상태를 업데이트하도록 구성된, 시나리오 시뮬레이션 시스템."}
{"patent_id": "10-2011-7003099", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "시나리오를 시뮬레이션하기 위한 컴퓨터 프로그램 제품으로서,컴퓨터로 읽을 수 있는 프로그램 코드를 구비한, 컴퓨터로 읽을 수 있는 저장 매체를 포함하며,상기 컴퓨터로 읽을 수 있는 프로그램 코드는,상기 시나리오에서의 오브젝트인 에이전트를 제공하도록 구성된, 컴퓨터로 읽을 수 있는 프로그램 코드;상기 시뮬레이션되는 시나리오와 상호 작용하는 적어도 하나의 플레이어 그리고/또는 상기 에이전트를 위한 현재 시각에 관해서 가장 멀리 도달할 수 있는 과거 시각과 가장 멀리 도달할 수 있는 미래 시각에 걸친, 상기 시나리오용의 타임 윈도우를 제공하도록 구성된, 컴퓨터로 읽을 수 있는 프로그램 코드;상기 에이전트의 적어도 하나의 속성에서의 변화를 나타내는 적어도 하나의 이벤트를 제공하도록 구성된, 컴퓨터로 읽을 수 있는 프로그램 코드; 및 상기 적어도 하나의 이벤트를 상기 타임 윈도우 내의 상기 에이전트에게 적용하여 상기 시나리오의 상태를 업데이트하도록 구성된, 컴퓨터로 읽을 수 있는 프로그램 코드;를 포함하는, 컴퓨터 프로그램 제품.명 세 서기 술 분 야본 발명은 시나리오들을 시뮬레이션하는 방법, 시스템 및 컴퓨터 프로그램 제품에 관한 것이며, 더 상세하게는, [0001]에이전트 및/또는 플레이어들/사용자들이 시간을 통해서 여행할 수 있는 시나리오들을 시뮬레이션하기 위한 시스템, 방법 및 컴퓨터 프로그램 제품에 관한 것이다.배 경 기 술컴퓨터 시뮬레이션 또는 컴퓨터 모델링은 특정한 시스템의 추상적인 모델을 시뮬레이션하는 것을 시도하는 컴퓨 [0002]터나 컴퓨터들의 네트워크 상에서 동작하는 하나 또는 그 이상의 컴퓨터 프로그램들을 이용하는 것을 포함할 수있을 것이다. 컴퓨터 시뮬레이션들은 수학, 물리학, 화학, 생물학, 경제학, 심리학 그리고 다른 분해들을 포함하는 다양한 서로 다른 기술적인 분야들에서 사용되어, 이런 시스템들이 어떻게 동작하는가에 대해서 더 많이이해하고 그리고/또는 그런 시스템들의 행동을 간단하게 관찰하도록 할 수 있을 것이다. 컴퓨터 시뮬레이션들은짧은 시간 동안 동작할 수 있을 것이며 또는 확대된 구간의 시간 동안 동작하는 많은 컴퓨터들을 포함할 수도있을 것이다. 일부 시뮬레이션들에서, 사용자들 또는 플레이어들은 시뮬레이션 환경을 변경하기 위해 여러 번입력을 제공하여 그 시뮬레이션에 참여할 수 있을 것이다. 몇몇의 시뮬레이션들은 플레이어들이 다양한 이벤트들의 결과들에 영향을 미칠 수 있고 그리고 게임의 규칙들에 따라서 서로 경쟁할 수 있는 비디오 게임의 모습으로 오락의 목적을 위해서 사용될 수 있을 것이다. 발명의 내용해결하려는 과제본 발명은 에이전트 및/또는 플레이어들/사용자들이 시간을 통해서 여행할 수 있는 시나리오들을 효율적으로 시 [0003]뮬레이션하기 위한 시스템, 방법 및 컴퓨터 프로그램 제품을 제공하려고 한다.과제의 해결 수단공개특허 10-2011-0052614-5-본 발명의 몇몇 실시예들에 따라서, 시나리오를 시뮬레이션하는 방법은, 상기 시나리오에서의 오브젝트인 에이 [0004]전트를 제공하는 단계, 상기 시뮬레이션되는 시나리오와 상호 작용 (interact)하는 적어도 하나의 플레이어 그리고/또는 상기 에이전트를 위한 현재 시각에 관해서 가장 멀리 도달할 수 있는 과거 시각과 가장 멀리 도달할수 있는 미래 시각에 걸친, 상기 시나리오용의 타임 윈도우를 제공하는 단계, 상기 에이전트의 적어도 하나의속성에서의 변화를 나타내는 적어도 하나의 이벤트를 제공하는 단계 및 상기 적어도 하나의 이벤트를 상기 타임윈도우 내의 상기 에이전트에게 적용하여 상기 시나리오의 상태를 업데이트하는 단계를 포함한다.다른 실시예들에서, 상기 적어도 하나의 이벤트는 상기 현재 시각 이전에 발생한다. 또 다른 실시예들에서, 상 [0005]기 적어도 하나의 이벤트는 상기 현재 시각 이후에 발생한다.또 다른 실시예들에서, 상기 시나리오는 제1 타임 레이트 (time rate)로 시뮬레이션되며, 이 경우에 상기 시나 [0006]리오의 상태를 업데이트하는 것은 전방 시간 방향에서 제2 타임 레이트로 상기 시나리오의 상태를 업데이트하는것을 포함하여, 상기 제1 타임 레이트에 대한 제2 타임 레이트의 비율이 1.0 이상이 되도록 한다. 또 다른 실시예들에서, 상기 시나리오는 제1 타임 레이트 (time rate)로 시뮬레이션되며, 그리고 이 경우에 상기 시나리오의상태를 업데이트하는 것은 전방 시간 방향에서 제2 타임 레이트로 상기 시나리오의 상태를 업데이트하여, 상기제1 타임 레이트에 대한 상기 제2 타임 레이트의 비율이 0 이상이고 1 보다는 작도록 한다.또 다른 실시예들에서, 상기 시나리오는 제1 타임 레이트로 시뮬레이션되며, 그리고 상기 시나리오의 상태를 업 [0007]데이트하는 것은 후방 시간 방향에서 제2 타임 레이트로 상기 시나리오의 상태를 업데이트하여, 상기 제1 타임레이트에 대한 제2 타임 레이트의 비율이 0 보다 작도록 한다.또 다른 실시예들에서, 상기 방법은 상기 에이전트에 의해 수행되는 행동들을 결정하는 스크립트를 제공하는 단 [0008]계를 더 포함한다. 또 다른 실시예들에서, 상기 에이전트에 의해 수행되는 상기 행동들은 다른 에이전트의 행동에 응답하는 행동들 및/또는 상기 에이전트들에 의해 제어될 수 없는, 만족되지 않는 적어도 하나의 조건을 기반으로 하여 트리거되는 강제된 행동들을 더 포함한다.또 다른 실시예들에서, 상기 방법은, 상기 에이전트를 시간에 있어서 원래의 포인트로부터 시간에 있어서 다른 [0009]포인트로 크로노포팅 (chronoporting)하는 단계, 시간에 있어서의 상기 다른 포인트에서 상기 에이전트의 복제를 생성하는 단계 및 상기 원래의 에이전트를 전방 시간에 있는 상기 원래의 포인트에서 파괴하는 단계를 더 포함한다.또 다른 실시예들에서, 상기 방법은 상기 시나리오를 시뮬레이션하는 것이 시작된 후에 제2 에이전트를 생성하 [0010]기 위해 상기 에이전트를 이용하는 단계를 더 포함한다.또 다른 실시예들에서, 상기 방법은, 상기 적어도 하나의 플레이어를 경유하여 상기 에이전트에게 명령을 발하 [0011]는 (issue) 단계를 더 포함한다. 또 다른 실시예에서, 상기 방법은, 상기 명령을 상기 에이전트에게 발하기 이전에 상기 적어도 하나의 플레이어의 시간 위치를 변경하는 단계를 더 포함한다. 또 다른 실시예들에서, 상기 명령은 다른 명령을 취소시켜서 상기 다른 명령과 연관된 행동이 발생하는 것을 방 [0012]지한다.또 다른 실시예들에서, 상기 방법은, 상기 적어도 하나의 플레이어가 현재의 시간 이전에 그리고/또는 이후에 [0013]명령들을 발할 수 있는 능력을 제한하는 단계를 더 포함한다.또 다른 실시예들에서, 복수의 플레이어들이 상기 시뮬레이션된 시나리오와 상호 작용 (interact)하고 그리고 [0014]상기 시나리오의 상태를 업데이트하는 것은, 상기 복수의 플레이어들 중의 첫 번째 플레이어에 대해서 상기 타임 윈도우 내에서 상기 적어도 하나의 이벤트를 상기 에이전트에 적용하여 상기 시나리오의 상태를 업데이트하는 단계 및 상기 복수의 플레이어들 중의 두 번째 플레이어에 대해서 상기 타임 윈도우 내에서 상기 적어도 하나의 이벤트를 상기 에이전트에 적용하여 상기 시나리오의 상태를 업데이트하는 단계를 포함한다.또 다른 실시예들에서, 상기 복수의 플레이어들 중의 상기 첫 번째 플레이어에 대해서 상기 시나리오의 상태를 [0015]업데이트하는 것은 제1 타임 레이트로 발생하고 그리고 상기 복수의 플레이어들 중의 상기 두 번째 플레이어에대해서 상기 시나리오의 상태를 업데이트하는 것은 상기 제1 타임 레이트와는 다른 제2 타임 레이트로발생한다.또 다른 실시예들에서, 상기 방법은, 상기 적어도 하나의 이벤트를 더 나중의 시각으로 복사하는 단계를 더 포 [0016]함하며, 상기 더 나중의 시각은 상기 에이전트가 상기 적어도 하나의 이벤트의 원래 시간과 상기 더 나중의 시각 사이의 시각에 대해서 아이들 (idle) 일 때의 스냅샷 구간에 상기 적어도 하나의 이벤트의 원래 시간을 더한공개특허 10-2011-0052614-6-것에 대응한다.또 다른 실시예들에서, 상기 적어도 하나의 플레이어는 인공 지능 (Artificial Intelligence (AI)) 시스템이다. [0017]또 다른 실시예들에서, 상기 시나리오의 상태를 업데이트하는 것은 상기 타임 윈도우에서 시간 상에서 이격되어 [0018]위치되어 있는 복수의 업데이터들을 이용하여 상기 시나리오의 상태를 업데이트하는 것을 포함한다.또 다른 실시예들에서, 상기 시나리오의 상태를 업데이트하는 것은 상기 윈도우에서 다중의 시간 위치 오프세트 [0019]들로부터 동시에 상기 시나리오의 상태를 업데이트하는 것을 포함한다.비록 상기에서 본 발명의 방법의 모습에 관해서 주로 설명되었지만, 본 발명은 방법, 시스템 그리고/또는 컴퓨 [0020]터 프로그램 제품으로서 구현될 수 있다는 것이이해될 것이다.발명의 효과본원의"}
{"patent_id": "10-2011-7003099", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "상기 시나리오에서의 오브젝트인 에이전트를 제공하고, 상기 시뮬레이션되는 시나리오와 상호 작용 (interact)하 는 적어도 하나의 플레이어 그리고/또는 상기 에이전트를 위한 현재 시각에 관해서 가장 멀리 도달할 수 있는 과 거 시각과 가장 멀리 도달할 수 있는 미래 시각에 걸친, 상기 시나리오용의 타임 윈도우를 제공하고, 상기 에이 전트의 적어도 하나의 속성에서의 변화를 나타내는 적어도 하나의 이벤트를 제공하고, 그리고 상기 적어도 하나 의 이벤트를 상기 타임 윈도우 내의 상기 에이전트에게 적용하여 상기 시나리오의 상태를 업데이트여, 시나리오 가 시뮬레이션된다."}
{"patent_id": "10-2011-7003099", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 시나리오들을 시뮬레이션하는 방법, 시스템 및 컴퓨터 프로그램 제품에 관한 것이며, 더 상세하게는, 에이전트 및/또는 플레이어들/사용자들이 시간을 통해서 여행할 수 있는 시나리오들을 시뮬레이션하기 위한 시 스템, 방법 및 컴퓨터 프로그램 제품에 관한 것이다."}
{"patent_id": "10-2011-7003099", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "컴퓨터 시뮬레이션 또는 컴퓨터 모델링은 특정한 시스템의 추상적인 모델을 시뮬레이션하는 것을 시도하는 컴퓨 터나 컴퓨터들의 네트워크 상에서 동작하는 하나 또는 그 이상의 컴퓨터 프로그램들을 이용하는 것을 포함할 수 있을 것이다. 컴퓨터 시뮬레이션들은 수학, 물리학, 화학, 생물학, 경제학, 심리학 그리고 다른 분해들을 포함 하는 다양한 서로 다른 기술적인 분야들에서 사용되어, 이런 시스템들이 어떻게 동작하는가에 대해서 더 많이 이해하고 그리고/또는 그런 시스템들의 행동을 간단하게 관찰하도록 할 수 있을 것이다. 컴퓨터 시뮬레이션들은 짧은 시간 동안 동작할 수 있을 것이며 또는 확대된 구간의 시간 동안 동작하는 많은 컴퓨터들을 포함할 수도 있을 것이다. 일부 시뮬레이션들에서, 사용자들 또는 플레이어들은 시뮬레이션 환경을 변경하기 위해 여러 번 입력을 제공하여 그 시뮬레이션에 참여할 수 있을 것이다. 몇몇의 시뮬레이션들은 플레이어들이 다양한 이벤트 들의 결과들에 영향을 미칠 수 있고 그리고 게임의 규칙들에 따라서 서로 경쟁할 수 있는 비디오 게임의 모습으 로 오락의 목적을 위해서 사용될 수 있을 것이다."}
{"patent_id": "10-2011-7003099", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 에이전트 및/또는 플레이어들/사용자들이 시간을 통해서 여행할 수 있는 시나리오들을 효율적으로 시 뮬레이션하기 위한 시스템, 방법 및 컴퓨터 프로그램 제품을 제공하려고 한다."}
{"patent_id": "10-2011-7003099", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 몇몇 실시예들에 따라서, 시나리오를 시뮬레이션하는 방법은, 상기 시나리오에서의 오브젝트인 에이 전트를 제공하는 단계, 상기 시뮬레이션되는 시나리오와 상호 작용 (interact)하는 적어도 하나의 플레이어 그 리고/또는 상기 에이전트를 위한 현재 시각에 관해서 가장 멀리 도달할 수 있는 과거 시각과 가장 멀리 도달할 수 있는 미래 시각에 걸친, 상기 시나리오용의 타임 윈도우를 제공하는 단계, 상기 에이전트의 적어도 하나의 속성에서의 변화를 나타내는 적어도 하나의 이벤트를 제공하는 단계 및 상기 적어도 하나의 이벤트를 상기 타임 윈도우 내의 상기 에이전트에게 적용하여 상기 시나리오의 상태를 업데이트하는 단계를 포함한다. 다른 실시예들에서, 상기 적어도 하나의 이벤트는 상기 현재 시각 이전에 발생한다. 또 다른 실시예들에서, 상 기 적어도 하나의 이벤트는 상기 현재 시각 이후에 발생한다. 또 다른 실시예들에서, 상기 시나리오는 제1 타임 레이트 (time rate)로 시뮬레이션되며, 이 경우에 상기 시나 리오의 상태를 업데이트하는 것은 전방 시간 방향에서 제2 타임 레이트로 상기 시나리오의 상태를 업데이트하는 것을 포함하여, 상기 제1 타임 레이트에 대한 제2 타임 레이트의 비율이 1.0 이상이 되도록 한다. 또 다른 실시 예들에서, 상기 시나리오는 제1 타임 레이트 (time rate)로 시뮬레이션되며, 그리고 이 경우에 상기 시나리오의 상태를 업데이트하는 것은 전방 시간 방향에서 제2 타임 레이트로 상기 시나리오의 상태를 업데이트하여, 상기 제1 타임 레이트에 대한 상기 제2 타임 레이트의 비율이 0 이상이고 1 보다는 작도록 한다. 또 다른 실시예들에서, 상기 시나리오는 제1 타임 레이트로 시뮬레이션되며, 그리고 상기 시나리오의 상태를 업 데이트하는 것은 후방 시간 방향에서 제2 타임 레이트로 상기 시나리오의 상태를 업데이트하여, 상기 제1 타임 레이트에 대한 제2 타임 레이트의 비율이 0 보다 작도록 한다. 또 다른 실시예들에서, 상기 방법은 상기 에이전트에 의해 수행되는 행동들을 결정하는 스크립트를 제공하는 단 계를 더 포함한다. 또 다른 실시예들에서, 상기 에이전트에 의해 수행되는 상기 행동들은 다른 에이전트의 행동 에 응답하는 행동들 및/또는 상기 에이전트들에 의해 제어될 수 없는, 만족되지 않는 적어도 하나의 조건을 기 반으로 하여 트리거되는 강제된 행동들을 더 포함한다. 또 다른 실시예들에서, 상기 방법은, 상기 에이전트를 시간에 있어서 원래의 포인트로부터 시간에 있어서 다른 포인트로 크로노포팅 (chronoporting)하는 단계, 시간에 있어서의 상기 다른 포인트에서 상기 에이전트의 복제 를 생성하는 단계 및 상기 원래의 에이전트를 전방 시간에 있는 상기 원래의 포인트에서 파괴하는 단계를 더 포 함한다. 또 다른 실시예들에서, 상기 방법은 상기 시나리오를 시뮬레이션하는 것이 시작된 후에 제2 에이전트를 생성하 기 위해 상기 에이전트를 이용하는 단계를 더 포함한다. 또 다른 실시예들에서, 상기 방법은, 상기 적어도 하나의 플레이어를 경유하여 상기 에이전트에게 명령을 발하 는 (issue) 단계를 더 포함한다. 또 다른 실시예에서, 상기 방법은, 상기 명령을 상기 에이전트에게 발하기 이 전에 상기 적어도 하나의 플레이어의 시간 위치를 변경하는 단계를 더 포함한다. 또 다른 실시예들에서, 상기 명령은 다른 명령을 취소시켜서 상기 다른 명령과 연관된 행동이 발생하는 것을 방 지한다. 또 다른 실시예들에서, 상기 방법은, 상기 적어도 하나의 플레이어가 현재의 시간 이전에 그리고/또는 이후에 명령들을 발할 수 있는 능력을 제한하는 단계를 더 포함한다. 또 다른 실시예들에서, 복수의 플레이어들이 상기 시뮬레이션된 시나리오와 상호 작용 (interact)하고 그리고 상기 시나리오의 상태를 업데이트하는 것은, 상기 복수의 플레이어들 중의 첫 번째 플레이어에 대해서 상기 타 임 윈도우 내에서 상기 적어도 하나의 이벤트를 상기 에이전트에 적용하여 상기 시나리오의 상태를 업데이트하 는 단계 및 상기 복수의 플레이어들 중의 두 번째 플레이어에 대해서 상기 타임 윈도우 내에서 상기 적어도 하 나의 이벤트를 상기 에이전트에 적용하여 상기 시나리오의 상태를 업데이트하는 단계를 포함한다. 또 다른 실시예들에서, 상기 복수의 플레이어들 중의 상기 첫 번째 플레이어에 대해서 상기 시나리오의 상태를 업데이트하는 것은 제1 타임 레이트로 발생하고 그리고 상기 복수의 플레이어들 중의 상기 두 번째 플레이어에 대해서 상기 시나리오의 상태를 업데이트하는 것은 상기 제1 타임 레이트와는 다른 제2 타임 레이트로 발생한다. 또 다른 실시예들에서, 상기 방법은, 상기 적어도 하나의 이벤트를 더 나중의 시각으로 복사하는 단계를 더 포 함하며, 상기 더 나중의 시각은 상기 에이전트가 상기 적어도 하나의 이벤트의 원래 시간과 상기 더 나중의 시 각 사이의 시각에 대해서 아이들 (idle) 일 때의 스냅샷 구간에 상기 적어도 하나의 이벤트의 원래 시간을 더한것에 대응한다. 또 다른 실시예들에서, 상기 적어도 하나의 플레이어는 인공 지능 (Artificial Intelligence (AI)) 시스템이다. 또 다른 실시예들에서, 상기 시나리오의 상태를 업데이트하는 것은 상기 타임 윈도우에서 시간 상에서 이격되어 위치되어 있는 복수의 업데이터들을 이용하여 상기 시나리오의 상태를 업데이트하는 것을 포함한다. 또 다른 실시예들에서, 상기 시나리오의 상태를 업데이트하는 것은 상기 윈도우에서 다중의 시간 위치 오프세트 들로부터 동시에 상기 시나리오의 상태를 업데이트하는 것을 포함한다. 비록 상기에서 본 발명의 방법의 모습에 관해서 주로 설명되었지만, 본 발명은 방법, 시스템 그리고/또는 컴퓨 터 프로그램 제품으로서 구현될 수 있다는 것이이해될 것이다."}
{"patent_id": "10-2011-7003099", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본원의 발명의 설명에서 언급되어 있음"}
{"patent_id": "10-2011-7003099", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 발명의 특별한 예시적인 실시예들이 첨부된 도면들을 참조하여 이제 설명될 것이다. 본 발명은, 그러나, 많 은 상이한 모습들로 구현될 수 있을 것이며 그리고 여기에서 제시된 실시예들로 한정되는 것으로서 해석되어서 는 안되며; 오히려, 본 발명의 개시가 철저하고 완전할 것이며 그리고 본 발명이 속한 기술 분야에서 통상의 지 식을 가진 자인 당업자들에게 본 발명의 범위를 충분하게 전달하도록 이런 실시예들은 제공된다. 첨부된 도면들 에서 도시된 특정의 예시적인 실시예들의 상세한 설명에서 사용되는 용어는 본 발명의 범위를 제한하려고 의도 된 것은 아니다. 상기 도면들에서, 유사한 참조번호들은 유사한 엘리먼트들을 언급하는 것이다. 여기에서 사용된 것과 같은, 단일 형상인 \"하나\", \"한 개\", \"상기\"는, 다르게 표시되지 않는다면, 복수의 형상 들을 마찬가지로 포함할 것으로 의도된 것이다. \"구비하다\", \"포함하다\", \"구비한\" 그리고/또는 \"포함하는\"의 용어들은, 본 명세서에서 사용될 때에, 선언된 특징들, 정수들, 단계들, 동작들, 엘리먼트들 및/또는 컴포넌트 들의 존재를 특정하는 것이며, 하나 또는 그 이상의 특징들, 정수들, 단계들, 동작들, 엘리먼트들 및/또는 컴포 넌트들 그리고/또는 그것들의 그룹들의 존재나 부가를 제외하려는 것이 아니라는 것이 또한 이해되어야할 것이다. 하나의 엘리먼트가 다른 엘리먼트에 \"연결되고\" 또는 \"결합된\" 것으로서 언급될 때에, 그것은 다른 엘리먼 트에 직접 연결되거나 결합될 수 있으며 또는 중개하는 엘리먼트들이 존재할 수 있을 것이다. 또한, 여기에서 사용되는 것과 같은 \"연결되고\" 또는 \"결합된\" 것은 무선으로 연결되거나 결합된 것을 포함할 수 있을 것이다. 여기에서 사용된 것과 같이, \"그리고/또는\"의 용어는 연관된 목록화된 아이템들의 하나 또는 그 이상의 일부 결 합 그리고 모든 결합을 포함한다. 다르게 정의되지 않았다면, 본원에서 사용되는 모든 용어들 (기술적인 그리고 과학적인 용어들 포함)은 본 발명 이 속한 기술 분야에서 통상의 지식을 가진 자가 보통으로 이해하는 것과 동일한 의미를 가진다. 보통으로 사용 되는 사전들에서 정의된 것과 같은 그런 용어들은 관련된 기술의 환경에서 자신들의 의미와 일치하는 의미를 가 진 것으로서 해석되어야만 하며 그리고, 여기에서 그렇게 정의된 것이 아니라면, 이상화되거나 또는 과도하게 형식적인 의미로 해석되지 않을 것이라는 것이 또한 이해될 것이다. 본 발명은 방법, 시스템 그리고/또는 컴퓨터 프로그램 제품으로서 구현될 수 있을 것이다. 따라서, 본 발명은 하드웨어로 그리고/또는 (펌웨어, 상주 소프트웨어, 마이크로-코드 등을 포함하는) 소프트웨어로 구현될 수 있을 것이다. 또한, 본 발명은, 명령어 실행 시스템에 의해 또는 그 시스템과 연결하여 사용될 용도로 매체 내에 서 구현된 컴퓨터-사용 가능 또는 컴퓨터-독출 가능 프로그램 코드를 구비한 컴퓨터-사용 가능 또는 컴퓨터-독 출 가능 저장 매체를 포함하는 컴퓨터 프로그램 제품의 모습을 취할 수 있을 것이다. 본 문서의 환경에서, 컴퓨 터-사용 가능 또는 컴퓨터-독출 가능 매체는 명령어 실행 시스템, 장치 또는 기기에 의해 또는 연결하여 사용될 용도인 프로그램을 포함하고, 저장하고, 전달하고, 전파하고 또는 전송할 수 있는 임의 매체일 수 있을 것이다. 상기 컴퓨터-사용 가능 또는 컴퓨터-독출 가능 매체는 전자, 자기, 광학, 전자기, 적외선 또는 반도체 시스템, 장치, 기기 또는 전파 매체를 예를 들어 포함할 수 있을 것이지만, 그것들로 한정되지는 않을 것이다. 상기 컴 퓨터-독출 가능 매체의 더욱 특별한 예들 (전부 망라하지는 않는 목록)은 다음의 것들 포함할 수 있을 것이다: 하나 또는 그 이상의 배선들을 구비한 전기적인 접속, 휴대용 컴퓨터 디스켓, 랜덤 액세스 메모리 (random access memory (RAM). 읽기 전용 메모리 (read-only memory (ROM)), 지울 수 있는 프로그래머블 읽기-전용 메 모리 ( erasable programmable read-only memory (EPROM 또는 Flash memory)), 광섬유 그리고 컴팩트 디스크 읽기-전용 메모리 (CD-ROM). 상기 컴퓨터-사용 가능 또는 컴퓨터-독출 가능 매체는 심지어는 종이 또는 상기 프 로그램이 인쇄될 수 있는 어떤 다른 적합한 매체여서, 예를 들면 상기 종이나 다른 매체를 광학적으로 스캐닝한 것을 통해서 상기 프로그램이 전기적으로 캡쳐되고, 그래서 컴파일되고, 번역되고, 그렇지 않다면 적합한 방식 으로 처리되어, 필요하다면 컴퓨터 메모리 내에 저장될 수 있을 것이라는 것에 주목한다. 본 발명의 몇몇 실시예들은 시뮬레이션 시스템의 플레이어들/사용자들이 시뮬레이션에서 오브젝트들인 에이전트 들과 함께 시간을 통해서 전방으로 그리고 후방으로 여행할 수 있을 시나리오들을 시뮬레이션하는 것을 제공할 수 있을 것이다. 각 플레이어/사용자는, 상기 에이전트들에 영향을 주는 이벤트들을 프로세스하기 위해 시간 여 행이 허용되는 유효한 타임 윈도우를 가로지르는 업데이터 프로세스/스레드 (thread)를 구비한다. 본 발명의 몇 몇의 실시예들에 따른 상기 시뮬레이션 시스템은 크고 복잡한 시스템을 위한 행동을 계획하는 것을 협력하여 구 축하기 위해서 다중의 사용자들로부터의 입력을 결합하는 것을 허용할 수 있을 것이다. 사용자들/플레이어들은 인터페이스와 방법들을 사용하여 산업적인 계획, 검색 및 구조 동작들, 군사적인 기동 작전들 그리고 유사한 것 을 위한 실행 예획들을 계속해서 업데이트하고, 추가하고 그리고/또는 향상시킬 수 있을 것이다. 사용자들/플레 이어들은 상이한 변화들의 영향들을 상대적으로 빠르게 볼 수 있을 것이며 그리고 이런 변화들이 어떻게 다른 사용자들/플레이어들의 계획들에 들어맞는가를 볼 수 있을 것이다. 다른 실시예들에서, 시뮬레이션 시스템은 인공 지능 (Artificial Intelligence (AI)) 시스템과 결합하여 사용될 수 있을 것이다. 이런 실시예들에서, 상기 AI 시스템은, 상기 시뮬레이션 시스템 상에서 가상적인 계획들을 구 축하고, 시험하고 그리고 취소하여, 그 가상적인 계획들이 서로 어떻게 영향을 미치는지를 평가하고 그리고 상 기 AI 시스템에 대해서 현재의 계획 그리고 가상적인 계획의 데이터베이스를 계속해서 업데이트하도록 하는, 사 실상의 사용자/플레이어이다. 도 1을 참조하면, 본 발명의 몇몇 실시예들에 따른 통신 네트워크는, 도시된 것과 같이 네트워크 를 경유 하여 연결된, 시뮬레이션 시스템 서버 , 제1 클라이언트 , 제2 클라이언트 및 AI 시스템 클라 이언트 를 포함한다. 상기 네트워크 는 인터넷이나 다른 공개적으로 액세스 가능하나 네트워크와 같 은 글로벌 네트워크일 수 있을 것이다. 상기 네트워크의 다양한 엘리먼트들은, 일반적인 대중들에 의해 액세스 가능할 수 있을 광역 네트워크, 로컬 영역 네트워크, 인트라넷 그리고/또는 다른 사설 네트워크에 의해 서로 연 결될 수 있을 것이다. 그러므로, 상기 네트워크 는 공중 네트워크 및 사설 네트워크 또는 가상 사설 네트 워크 (VPN)의 결합을 나타낼 수 있을 것이다. 다른 실시예들에서, 상기 제1 클라이언트 , 제2 클라이언트 및/또는 AI 시스템 클라이언트 는 상기 시뮬레이션 시스템 서버 에 직접적으로 연결될 수 있을 것이다. 상기 시뮬레이션 시스템 서버 는 시나리오들을 시뮬레이션하고 그리고 시뮬레이션의 오브젝트들인 에이전트들과 함께 상기 시뮬레이션 시스템의 사용자들/플레이어들을 위한 시간 여행을 제공하도록 구성될 수 있을 것이다. 상기 제1 클라이언트 , 제2 클라이언트 및 AI 시스템 클라이언트 는 상기 시뮬레 이션 시스템의 사용자들/플레이어들과 연관된다. 상기 제1 클라이언트 및 제2 클라이언트 는 상기 시뮬레이션 시스템 서버 에 인터페이스를 제공할 수 있는 임의의 기기/시스템으로서 구현될 수 있을 것이다. 이런 기기들은 컴퓨터, 개인용 디지털 보조기들 (Personal Digital Assistants (PDAs)), 모바일 기기들, 지능형 단말들, 단순 단말들 그리고 유사한 것을 포함할 수 있을 것이지만, 그것들로 제한되지는 않을 것이다. 상기 시뮬레이션 시스템 서버 및 상기 AI 시스템 클라이언트 의 각각은 단일의 서버, 개별 서버들, 또는 서버들이 모여있는 곳에 같이 위치해 있거나 또는 예를 들면 상이한 지리적인 영역들에 위치하는 것의 어 느 하나인 서버들의 네트워크로서 구현될 수 있을 것이라는 것이 이해될 것이다. 비록 두 개의 클라이언트들 및 단일의 AI 시스템 클라이언트가 도 1에서 도시되지만, 더 작은 수의 또는 추가의 클라이언트들이 본 발명의 다양한 실시예들에 따라서 사용될 수 있을 것이라는 것이 이해될 것이다. 도 1에서 도시된 것과 같이, 본 발명에 따른 몇몇의 실시예들은 논리적으로 구별된, 이하에서는 때로 클라이언 트/서버 환경으로서 언급되는, 클라이언트 측/서버 측-컴퓨팅 환경에서 동작할 수 있다. 상기 클라이언트/서버 환경은 서버 프로세스 (즉, 저장 시뮬레이션 시스템 서버 )로부터 서비스를 요청하는 클라이언트 프로세스 (즉, 참조번호 120, 130 및 140의 클라이언트들)를 포함하는 컴퓨터 구조이다. 일반적으로, 클라이언트 프로세 스와 서버 프로세스가 서로 다른 기계들 상에서 또는 동일한 기계 상에서 동작할 수 있을지라도, 상기 클라이언 트/서버 환경은 프로세스들 사이에서의 구별을 유지한다. 따라서, 상기 클라이언트/서버 환경의 클라이언트 측 그리고 서버 측은 논리적으로 분리되는 것으로서 언급된다. 대개, 클라이언트 프로세스 그리고 서버 프로세스가 분리된 기기들 상에서 동작할 때에, 각 기기는 각 프로세스의 필요들에 따라서 커스터마이즈될 수 있다. 예를 들면, 서버 프로세스는 커다란 양의 메모리와 디스크 공간을 구비한 시스템 상에서 \"동작\"할 수 있으며, 상기 클라이언트 프로세스는 하이-엔드 비디오 카드들 그리고 대형-스크린 디스플레이들을 갖춘 그래픽 사용자 인터 페이스를 구비한 시스템 상에서 종종 \"동작\" 한다. 상기 클라이언트들 및 서버들은 HTTP (Hypertext Transport Protocol), SOAP, 및/또는 XML-RPC와 같은 표준의 통신 모드를 이용하여 통신할 수 있다. 상기 HTTP 요청-응답 통신 모델에 따라, HTTP 요청들은 상기 클라이언트 로부터 상기 서버로 송신되며 그리고 HTTP 응답들은 상기 서버로부터 상기 클라이언트로 HTTP 요청에 응답하여 송신된다. 동작에 있어서, 상기 서버는 클라이언트가 접속을 열고 그리고 웹 페이지와 같은 정보를 요청하는 것 을 기다리기 위해서 대기한다. 응답으로, 상기 서버는 상기 요청된 정보의 사본을 상기 클라이언트로 송신하고, 상기 클라이언트로의 접속을 닫고 그리고 다음의 접속을 위해서 대기한다. 상기 서버가 하나 이상의 클라이언트 로부터의 요청들에 응답할 수 있다는 것이 이해될 것이다. 몇몇의 실시예들에서, 예를 들면, 속도에 관해서 강 조가 될 수 있을 게이밍 애플리케이션들과 같은 몇몇의 실시예들에서, 클라이언트 프로세스와 서버 프로세스 사 이에서의 접속들은 HTTP의 요청-응답 모델을 사용하는 것 대신에 전체 세션에 대해서 열린 상태로 유지될 수 있 을 것이다. 비록 도 1이 예시적인 통신 네트워크를 도시하지만, 본 발명은 그런 구성들로 한정되는 것이 아니라, 본원에서 설명된 동작들을 수행할 수 있는 어떤 구성이라도 망라할 의도라는 것이 이해될 것이다. 도 2는, 예를 들면, 도 1의 시뮬레이션 시스템 서버 를 구현하기 위해서 사용될 수 있을 것이며 그리고 본 발명의 몇몇 실시예들에 따라 시나리오들을 시뮬레이션하기 위한 모듈을 포함할 수 있을 데이터 프로세싱 시스 템 을 도시한다. 상기 데이터 프로세싱 시스템 은 프로세서 와 통신하는, 키보드 또는 키패드와 같은, 입력 기기(들) , 디스플레이 그리고 메모리 를 포함한다. 상기 데이터 프로세싱 시스템 은 또한 상기 프로세서 와 통신하는 저장 시스템 , 스피커 그리고 I/O 데이터 포트(들) 를 더 포함할 수 있을 것이다. 상기 저장 시스템 은 램디스크 (RAMDISK)와 같은 가상 저장부는 물론 이며 플로피 디스크들과 같은 탈부착 가능 미디어 그리고/또는 고정 미디어, ZIP 드라이브, 하드 디스크 또는 유사한 것을 포함할 수 있을 것이다. 상기 I/O 데이터 포트(들) 는 상기 데이터 프로세싱 시스템 과 다른 컴퓨터 시스템이나 네트워크 (예를 들면, 인터넷) 사이에서 정보를 전달하기 위해서 사용될 수 있을 것이다. 이런 컴포넌트들은 많은 전통적인 컴퓨팅 기기들에서 사용되는 것들과 같은 전통적인 컴포넌트들일 수 있을 것이며, 전통적인 동작들에 관한 그 컴포넌트들의 기능은 본 발명이 속한 기술 분야에서 통상의 지식을 가진 자 들에게는 일반적으로 알려진 것이다. 상기 메모리 는 본 발명의 몇몇 실시예들에 따라서 시나리오들을 시 뮬레이션하기 위해서 사용될 수 있을 시뮬레이션 시스템 모듈 과 함께 구성될 수 있을 것이다. 도 3은 도 2의 데이터 프로세싱 시스템 과 같은 데이터 프로세싱 시스템들의 실시예들에서 본 발명의 몇몇 의 실시예들에 따라 시나리오들을 시뮬레이션하기 위해 사용될 수 있을 프로세서 그리고 메모리 를 도시한다. 상기 프로세서 는 어드레스/데이터 버스 를 경유하여 상기 메모리 와 통신한다. 상기 프로세서 는, 예를 들면, 상업적으로 이용 가능한 또는 커스텀 마이크로프로세서일 수 있을 것이다. 상기 메모리 는 본 발명의 몇몇 실시예들에 따른 소프트웨어를 제공하기 위해서 사용되는 소프트웨어와 데이터 를 포함하는 하나 또는 그 이상의 메모리 디바이스들을 대표한다. 상기 메모리 는 다음 유형의 디바이스들 을 포함할 수 있을 것이지만, 그것들로 한정되는 것은 아니다: 캐시 (cache), ROM, PROM, EPROM, EEPROM, 플래 시 (flash), SRAM 그리고 DRAM. 도 3에 도시된 것과 같이, 상기 메모리 는 5개 또는 그 이상 카테고리의 소프트웨어 그리고/데이터를 포함 할 수 있을 것이다: 운영 시스템 , 시뮬레이션 관리자 모듈 , 업데이터 관리자 모듈 , 업데이터 동기화 관리자 모듈 그리고 클라이언트 인터페이스 모듈 . 상기 운영 시스템 은 상기 데이터프로세싱 시스템의 동작을 제어하는 것이 일반적이다. 특히, 상기 운영 시스템 은 상기 데이터 프로세싱 시스템의 소프트웨어 자원들 그리고/또는 하드웨어 자원들을 관리할 수 있을 것이며 그리고 상기 프로세서 에 의해서 프로그램들을 실행하는 것을 조절할 수 있을 것이다. 상기 시뮬레이션 관리자 모듈 은 전체 시뮬레이션을 시간 상에서 타임 스텝들이나 증가들을 기반으로 하여 전방으로 이동시키도록 구성될 수 있을 것이다. 상기에서 설명된 것과 같이, 상기 시뮬레이션 시스템의 플레이 어/사용자 각각은 상기 에이전트들에 영향을 주는 이벤트들을 프로세스하기 위해 시간 여행이 허용되는 유효한 타임 윈도우를 가로지르는 업데이터 프로세스/스레드 (thread)를 구비한다. 상기 업데이터 관리자 모듈 은 각 업데이터의 시간적인 속도 (rate)와 방향에 따라서 상기 유효 타임 윈도우를 통해서 각각의 업데이터를 이동 시키도록 구성될 수 있을 것이다. 상기 업데이터 동기화 관리자 모듈 은 다중의 업데이터들이 일치하는 데 이터를 포함하는 것을 보장하도록 구성될 수 있을 것이다. 상기 클라이언트 인터페이스 모듈 은 상기 시뮬 레이션된 시나리오들의 그래픽 디스플레이, 오디오 그리고/또는 텍스트를 클라이언트 기기로 제공하도록 구성될 수 있을 것이며 그리고 상기 시뮬레이션된 시나리오들에서 사용될 용도로 상기 클라이언트 기기로부터 또한 입 력을 수신하도록 구성될 수 있을 것이다. 비록 도 3이 도 2의 데이터 프로세싱 시스템 과 같은 데이터 프로세싱 시스템들에서 시나리오들을 시뮬레 이션하기 위해 사용될 수 있을 예시적인 하드웨어/소프트웨어 구조들을 도시하지만, 본 발명은 그런 구성으로 한정되는 것이 아니며, 본원에서 설명된 동작들을 수행할 수 있는 어떤 구성이라도 포함하도록 의도된 것이라는 것이 이해될 것이다. 또한, 도 2의 데이터 프로세싱 시스템 의 기능 그리고 도 3의 하드웨어/소프트웨어 구조는, 본 발명의 다양한 실시예들에 따라서, 단일 프로세서 시스템이나 멀티-프로세서 시스템으로서 또는 심 지어는 스탠드-얼론 컴퓨터 시스템들의 망으로서 구현될 수 있을 것이다. 도 3에 관해서 상기에서 설명된 데이터 프로세싱 시스템들의 동작들을 수행하기 위한 컴퓨터 프로그램 코드는 개발의 편이를 위해서 Python, Java, C, 그리고/또는 C++ 과 같은 하이-레벨 프로그래밍 언어로 써질 수 있을 것이다. 추가로, 본 발명의 동작들을 수행하기 위한 컴퓨터 프로그램 코드는 인터프리터 언어와 같은 다른 프로 그래밍 언어들로 또한 써질 수 있을 것이지만, 그 언어로 한정되지는 않는다. 몇몇 모듈들 또는 루틴들은 성능 및/또는 메모리 사용을 향상시키기 위해서 어셈블리 언어 또는 심지어는 마이크로-코드로 써질 수 있을 것이다. 상기 프로그램 모듈들의 일부 또는 모두의 기능은 분리된 하드웨어 컴포넌트들, 하나 또는 그 이상의 주문자 집 적 회로들 (application specific integrated circuits (ASICs)), 또는 프로그램된 디지털 신호 프로세서나 마 이크로제어기를 이용하여 또한 구현될 수 있을 것이라는 것도 또한 이해될 것이다. 본 발명의 몇몇의 실시예들에 따른, 상기 시뮬레이션 관리자 모듈 , 상기 업데이터 관리자 모듈 , 상 기 업데이터 동기화 관리자 모듈 및 상기 클라이언트 인터페이스 모듈 과 연관된 다양한 엘리먼트들 이 이제 설명될 것이다. 에이전트 (Agent): 자기 자신에서의 변화를 수행할 수 있거나 또는 동적으로 변경될 수 있거나 또는 두 가지 모 두를 할 수 있는, 시뮬레이션에서의 오브젝트. 에이전트는 상기 시뮬레이션 내에서 유닛 (사람, 차량 등)으로서 또는 상기 시뮬레이션을 모니터링하거나 제어하기 위한 (예를 들면, 언제 적을 물리쳤는가를 판별하고 그리고 상기 시뮬레이션을 종결시키는) 실체 없는 엔티티 (disembodied entity)로서 구현될 수 있을 것이다. 실체 없는 에이전트는 상기 시뮬레이션에 존재하는 에이전트로, 상기 시뮬레이션에서 다른 에이전트들에 영향을 미칠 수 있지만, 상기 시뮬레이션 내에서 에이전트들에 의해 직접적으로 영향을 받을 수 없으며, 만일 영향을 받는다면, 제한되고 한정된 방식들로만 영향을 받는다. 실체 없는 에이전트의 예는 날씨이다. 실체 없는 에이전트의 다른 예는 플레이어가 언제 레벨에서 이겼나, 적을 물리쳤는가 또는 스토리의 진행을 개시하는 몇몇 이벤트를 일으키 게 했나를 판별하는 하나 또는 그 이상의 트리거들이다. 실체 없는 에이전트의 세 번째 예는 한 사람이 계좌에 가진 돈의 액수와 같은 플레이어 자원들의 에이전트 또는 현재의 점수이다. 에이전트 행동 (Agent action): 강제된 행동 (forced action)으로 인해서 또는 다른 에이전트의 행동으로 인해 서 자기 자신의 의지 하에서 에이전트에 의해 수행되는 행동. 행동은 시간을 필요로 할 수 있을 것이며 또는 행 동은 순간적일 수 있을 것이다. 행동이 시간을 필요로 한다면, 그것은 상기 시뮬레이션에서 자신의 표현을 위한 동반 애니메이션을 가질 수 있을 것이다. 행동이 발생할 때에, 상기 행동에 결부된 각 에이전트에 대해서 이벤 트가 생성된다. 행동들은 상기 시뮬레이션에 의해 허용된 미소/기본 (atomic/basic) 단계들의 프로그램으로부터 구축될 수 있을 것이며, 파라미터화될 수 있을 것이며, 그리고 전제 조건들을 구비할 수 있을 것이다. 각 유형 의 에이전트는 그 에이전트가 수행할 수 있을 행동들의 세트를 구비한다. 에이전트 크로스-섹션 (Agent cross-section): 주어진 시간에 관한 모든 에이전트를 위한 가장 최근의 이벤트. 에이전트 스크립트들 (Agent scripts): 에이전트의 유형 제어들 및 습성을 판별하는 주어진 에이전트 유형에 대 응하는 스크립트들의 세트. 에이전트 스크립트들은 상기 에이전트가 수행하도록 허용된 행동들을 개시할 수 있 으며 그리고 (에이전트들의 또는 시뮬레이션의) 대응하는 규칙들이 허용하는 것과 같이 다른 에이전트들과 상기 시뮬레이션에 관한 데이터에 대체적으로 액세스할 수 있다. 이 스크립트들은 랜덤 번호 생성, 계획 (planning) 알고리즘, 검색 알고리즘과 같은 엔진 내에서의 라이브러리들에 액세스할 수 있을 것이며, 그리고 진보된 AI 알 고리즘들에서와 같이 복잡한 행동을 수행하는 것과 같이 간단할 수 있을 것이다. 행동 시간: 행동이 완료될 때까지 행동이 필요로 하는 시간의 양. 매 시간 그리고 모든 에이전트에 대해, 상기 시뮬레이션은 완료할 행동을 위한 전체 시간 그리고 가장 최근 이벤트 데이터로부터 그 행동을 완료하는데 있어 서의 현재의 진행을 결정한다. 크로노포트 (Chronoport): 시간에 있어서 다른 위치로 점프하는 에이전트의 행동. 크로노포트하는 것은 시간에 관해서 만은 텔레포트 (teleport)와 유사하다. 에이전트가 크로노포트되면, 새로운 에이전트가 상기 크로노포트 한 쪽의 복제로서 생성되며, 상기 크로노포트한 쪽은 그 시간으로부터 전방에서 파괴되며, 그리고 그 두 에이전 트들은 정보 관리 및 전파를 위해서 서로 링크된다. 크로노포트하는 것은 게이밍 애플리케이션들을 위해서 주로 사용될 수 있을 것이다. 생성 이벤트 (Creation event): 에이전트가 생성되는 이벤트. 상기 시뮬레이션이 시작할 때에 존재하지 않는 어 떤 에이전트는 다른 부모 에이전트에 의해 생성된다. 상기 두 에이전트들은 변경할 수 없게 링크된다. 만일 타 임라인이 변경되어 차일드 에이전트가 생성되기 이전에 상기 부모 에이전트가 파괴되면, 상기 차일드 에이전트 는 생성되지 않을 것이며 그리고 차일드 에이전트의 모든 이벤트들은 취소될 것이다. 에이전트 생성 이벤트는 상기 이벤트에서 규정된 시간에서만 발생한다. 삭제 명령어들 (Delete commands): 상기 시뮬레이션 내의 에이전트들로의 \"베풀지 않은\" 명령들의 행동으로, 이 는 취소와 비슷하다. 플레이어가 시간 위치를 변경하고 주어진 에이전트로의 명령들을 삭제하면, 그러면 상기 에이전트는 그런 명령들이 주어지지 않은 것처럼 우선적으로 행동할 것이다. 이벤트 (Event): 에이전트의 하나 또는 그 이상의 속성들로의 변화. 모든 에이전트 행동은 이벤트와 함께 시작 한다. 이벤트 데이터: 에이전트를 완전하게 설명할 수 있는 데이터의 코어 세트. 이 데이터 구조의 예가 상기 타임 윈 도우를 통해서 상기 시뮬레이션에서 모든 이벤트에 대해서 저장될 수 있을 것이기 때문에, 이 데이터 구조는 비 트 패킹 (bit packing), 캐시 정렬 그리고 유사한 것과 같은 향상된 효율을 고려하여 설계될 수 있을 것이다. 단일 이벤트 데이터로부터 에이전트를 완전하게 구축하기 위해, 상기 시뮬레이션은, 정적인 콘텐트 (예를 들면, 속성들, 모델들 그리고 애니메이션들)를 룩업하기 위해 그리고/또는 절차적인 콘텐트 생성 기술들을 이용하여 이벤트 데이터 필드들을 기반으로 하여 동적인 정보를 생성하기 위해서, 상기 이벤트 데이터에 포함된 필드들을 이용할 수 있을 것이다. 횡단을 쉽게 하기 위해, 이벤트 데이터는 단일의 또는 이중으로 링크된-목록에 임시로 정렬 (sort)됨으로써 관리될 수 있을 것이다. 엔진 클라이언트 (Engine client): 인터페이스 그리고 시뮬레이션 콘텐트를 각 플레이어/사용자에게 디스플레이 하는 시뮬레이션 소프트웨어의 일부분. 엔진 서버 (Engine server): 시뮬레이션을 실행시키고, 상기 이벤트 데이터를 저장하며 그리고 새로운 상태들을 계산하는 시뮬레이션 소프트웨어의 일부분. 상기 엔진 서버는 각 엔진 클라이언트와 통신한다. 상기 엔진 서버 는 본 발명의 다양한 실시예들에 따라, 상기 엔진 클라이언트와 동일한 기계에서, 별개의 기계에서 또는 서버들 의 네트워크를 통해서 분산되어 (이 경우 상기 엔진 서버는 서버들의 그룹에 대한 집합 항목이다) 실행될 수 있 을 것이다. 강제된 행동 (Forced action): 에이전트의 제어 외부에서 선결 조건들의 세트가 충족될 때에 자동적으로 트리거 되는 에이전트의 행동. 강제된 행동들은 즉각적인 것이며 (예를 들면, 구분된 에너지 회복 이벤트들) 또는 시간 을 필요로 할 수 있을 것이다 (예를 들면, 에이전트가 손상을 당했을 때에, 컴포넌트가 단절되었을 때에 그리고 /또는 다른 물리적 기반의 인터액션들이 있을 때에). 본 발명의 다양한 실시예들에 따라서, 강제된 행동은 상대 적으로 단순한 또는 간단한 행동일 수 있을 것이며, 또는, 예를 들면, AI 알고리즘들을 기반으로 하는 복잡한 동작일 수 있을 것이다. 추월 (Overtake): 더 높은 타임 멀티플라이어 (time multiplier)를 구비한 한 업데이터가 다른 업데이터의 멀티 플라이어 이전의 자신의 시간을 앞서 나가는 경우. 더 높은 타임 멀티플라이어를 구비한 더 이전의 업데이터가 나중의 업데이터의 스냅샷 구간 시간 내에 올 때에 추월 프로세스가 시작되며, 상기 더 높은 타임 멀티플라이어 를 구비한 상기 업데이터가 추월되고 있는 업데이터에 앞서서 스냅샷 구간에 있을 때까지 지속된다. 파라독스 (Paradox): 시간에 걸쳐서 불안정한 이벤트들의 세트. 상기 이벤트들이 상기 타임 윈도우의 끝 부분에 서 떨어지고 그리고 이벤트들의 상기 세트가 하나의 결과로 붕괴할 때까지 파라독스는 불안정하다. 간단한 파라 독스의 일 예는 공장에서 로봇을 조립하고, 그 로봇이 자신이 만들어지기 시간에 있어서 거꾸로 여행해서 그리 고 그 로봇이 최초의 장소에서 상기 공장이 자신인 로봇을 만드는 것을 방해하는 것이다. 그 로봇이 상기 공장 이 자신을 만드는 것을 방해하면, 그 로봇은 공장이 자신을 만드는 것을 방해하기 위해 시간에 있어서 거꾸로 여행하는 것을 절대로 할 수 없다. 그러므로 이는 파라독스이다. 플레이어 (Player): 상기 시뮬레이션과 상호 작용 (interact)하는 사람. 각 플레이어는 에이전트들의 몇몇 세트 와 통신할 수 있으며 그리고 타임라인 상에서 자신의 현재 위치를 제어할 수 있다. 각 플레이어는 에이전트들, 위치들, 시간들 등을 북마크들로서 메모리에 또한 표시할 수 있을 것이다. 현재 (Present): 현재 시간으로 간주된 타임 윈도우 상의 장소. 상기 현재 시간은 그 시간과 관련된 업데이터를 구비할 수 있을 것이며 그리고 그 타임 윈도우에서의 임의의 곳에 고정될 수 있을 것이다. 스냅샷 이벤트 (Snapshot event): 업데이터들이 서로를 간섭하는 것을 방지하는 특별한 이벤트. 이 이벤트는 업 데이트된 타임스탬프들과 타이밍을 구비한 이전의 이벤트의 복제일 뿐이다. 어떤 에이전트가 스냅샷 구간의 시 간 길이동안 아이들 (idle)이면, 스냅샷 이벤트가 발생한다. 일 예로서, 하나는 1 분에서 그리고 하나는 5분에 서의 두 업데이터들을 고려한다. 하나의 특정 에이전트가 대부분의 시간을 아이들에 있고, 그것이 아마도 트리 (tree)인 것으로 가정한다. 1분에서의 업데이터에서, 상기 시뮬레이션에서 에이전트가 그 트리를 베어 넘긴다고 (이는 이전의 타임라인에서는 결코 발행하지 않는다) 이제 가정한다. 스냅샷이 없다면, 타임라인에서의 상기 현 재의 이벤트 순서는 다음과 같이 보인다: 트리 생성 (시간 0) - 트리 베어 넘기기 (1분) 5분에서의 상기 업데이터는 자신의 타임스텝들 (timesteps)을 이제 동작시킨다. 5분에서의 상기 업데이터는, 만 일 다른 이벤트를 그 트리에 삽입하면 그 업데이터가 너무 늦게 겹쳐질 것이기 때문에, 트리 생성 이벤트에 계 속 포인트를 두고 있을 수 없다. 에이전트가 시간 5에서 가지 (branch)를 절단한다고 가정한다: 트리 생성 (시간 0) - 가지 절단 (5분) - 트리 베어 넘기기 (1분) 그것은 모순된 것이며 그리고 효율적으로 처리하기 힘들 수 있을 것이다. 그 대신에 5분에서의 상기 업데이터가 상기 현재의 이벤트로, 즉, 트리 베어 넘기기 이벤트로 단순하게 업데이트하는 경우를 가정한다. 그렇게 하는 것은 두 가지 문제들을 초래한다: 먼저, 상기 업데이터는 모든 시간 단계에서 모든 에이전트에 대해 상기 이벤 트 트리에 다시-통과해야만 한다. 두 번째는, 시간을 통해서 이벤트가 전파되는 속도가 모순될 수 있을 것이다. 여러 이벤트들을 겪는 에이전트 (예를 들면, 노동자)는 상기 트리보다 아주 더 천천히 미래로 전파되는 자신의 이벤트들을 구비할 수 있을 것이다. 스냅샷들은, 아이들 에이전트들과 연관된 이벤트들이 매 스냇샵 간격으로 규칙적으로 발생하도록 함으로써, 이 런 문제들 둘 다를 해결한다 스냅샷 간격 (Snapshot interval): 스냅샷 이벤트들 사이의 시간 주기. 간격들이 더 높을수록 메모리 필요량은 더 작아지지만, 추월이 발생하고 있을 때에 업데이터들 사이에서의 동가화의 양은 더 늘어난다. 타임라인 (Timeline): 에이전트들의 세트를 위한 이벤트들의 현재의 세트. 상기 타임라인은 플레이어들과 에이 전트들이 시간을 통해서 이동하면 변경될 수 있을 것이다. 타임 멀티플라이어 (Time multiplier): 업데이터가 시간을 통해서 ld동하는 속도 (rate). 시간을 전방으로 전파 하는 업데이터들은 1.0 이상의 멀티플라이어를 구비한다. 플레이어가 제어하는 업데이터들은 상기 플레이어의 업데이터가 상기 타임 윈도우 내에 있는 동안에는 임의의 타임 멀티플라이어를 가질 수 있다. 상기 이벤트 데이 터가 전방으로 그리고 후방으로 두 가지 모두로 이동 (예를 들면, 이중-링크) 되는 것이 가능한 방식으로 저장 되면 네거티브의 타임 멀티플라이어들도 허용된다. 상기 타임 멀티플라이어가 약 0부터 1 사이의 범위에 있으면, 그러면 상기 업데이터는 시간 상에서 느린 동작으로 전방으로 실제로 이동하고 있는 것이다. 이는, 예 를 들면, 너무 많은 이벤트들이 너무 짧은 시간 범위 구간 내에서 너무 급격하게 발생하고 있으면 이용될 수 있을 것이다. 시간 통계 값들: 상기 타임 윈도우를 통해서 발생하는 이벤트들의 측정한 것들의 집합. 각 플레이어에게는 타임 슬라이더 상에서 상기 시뮬레이션과의 인터액션들에 관한 통계 값들의 몇몇 세트가 보여진다. 상기 통계 값들은 바 차트 또는 라인 그래프를 이용하여 효과적으로 보여질 수 있을 것이다. 타임 슬라이더 (Time slider): 상기 타임 라인들 상에서의 이벤트들을 묘사하기 위한 시간 통계 값들을 보여주 며, 그리고 특정 시각을 나타내기 위해서 상기 플레이어에 의해 사용되는 사용자 인터페이스 특징. 이 인터페이 스 특징은 플레이어의 현재 시각을 이동시키고, 에이전트들을 크로노포트시키는 등을 위해서 이용될 수 있다. 시간 단계 (Time step): 시간에서의 분리된 단계, 시간의 기본 유닛 (임의적으로 미세하게 될 수 있을 것이다). 타임 윈도우 (Time window): 에이전트들 그리고 플레이어들을 위해서 허용된 시간 여행 사이의 허용된 시간. 이 는 이벤트들의 슬라이딩 윈도우로서 생각될 수 있으며, 이 경우 상기 슬라이딩 윈도우의 하나의 끝 부분은 가장 멀리 도달할 수 있는 과거이며 그리고 다른 끝 부분은 가장 멀리 도달할 수 있는 미래이다. 상기 타임 윈도우는, 본 발명의 다양한 실시예들에 따라서, 경계가 없는 타임 윈도우들 (무한대), 대수적인 (logarithmic) 타임라인들 또는 다른 비-선형의 시간적인 매핑들을 포함할 수 있을 것이다. 생성되지 않은 (Uncreated): 타임라인이 변경되어 에이전트가 생성되는 것이 방해되는 경우. 업데이터 (Updater): 타임라인 상에서의 변화를 바꾸는 실행의 프로세스/스레드 (실제 또는 가상). 업데이터는 그 업데이터의 타임 멀티플라이어에 의해 좌우되는 속도로 타임 윈도우를 통해서 이동한다. 전방으로 이동할 때 에, 각 업데이터는 자신의 전방에 있는 이벤트들을 클리어하며, 그리고 타임라인이 변경되었는가의 여부에 따라 서 그 이벤트들을, 다를 수도 있고 아닐 수도 있을, 다시 계산된 이벤트들로 교체한다. 각 플레이어는 자신 자 체적인 업데이터 그리고 상기 타임 윈도우를 통해서 과거로부터의 변화들을 초래하면서 시간을 통해서 전방으로 이동하는 연관되지 않은 업데이터들의 풀 (pool)을 구비할 수 있을 것이다. 전술한 풀 내의 업데이터들은 상기 타임 윈도우의 끝에 도달하면 상기 타임 윈도우의 시작 부분으로 점프해서 돌아간다. 상기 연관되지 않은 업데이터들의 풀은 상기 타임라인에서의 변화들을 과거로부터 미래로 전파하는 주요한 메커 니즘이다. 상기 연관되지 않은 업데이터 풀은, 업데이터들의 개수 그리고 상기 업데이터들의 속도라는, 두 가지 의 주요한 파라미터들을 유효하게 구비한다. 상기 연관되지 않은 업데이터의 예시적인 동작들이 예로서 설명될 수 있을 것이다. 과거로부터 미래로 이벤트들을 전파하기 위해 단 하나의 연관되지 않은 업데이터가 사용되며 그리고 그 업데이터의 속도는 정규 시간 (벽 시계) 속도의 두 배로 설정된다고 가정한다. 상기 타임 윈도우가 2 분의 길이이며, 플레이어 1은 0:30에 있고 플레이어 2는 1:30에 있으며 그리고 상기 연관되지 않은 업데이터는 1:00에 있다고 추가로 가정한다. 시뮬레이션이 몇몇의 무한대 타임 윈도우 (이는 임의적으로 길 수 있다)를 포 함하기 때문에, 상기 연관되지 않은 업데이터는 그것이 2:00에 도달하여 0:00 로 되돌려질 때에 다시 사용될 수 있다. 플레이어 1이 명령을 발하여 상기 타임라인에 변화를 일으키면, 그러면 플레이어 2는, 상기 연관되지 않 은 업데이터가 2:00에 도달하여 0:00에서 다시 시작하고, 플레이어 1에 의해 발행된 상기 새로운 명령을 받아들 여서 과거 0:30 을 업데이트하고, 그리고 플레이어 2가 이제 참여한 시간에 도달할 때까지 상기 변화에 의해 영 향을 받지 않을 것이다. 상기 업데이터가 플레이어 2에 도달하는 시각에, 플레이어 2와 상기 업데이터는 4:00에 있을 것이다. 현재 시각 0:24, 0:48, 1 :12, 1 :36 그리고 2:00에서, 5개의 동일하게 이격된 연관되지 않은 업데이터들이 정 규 속도 시간의 2배로 이동하기 위해서 사용된다는 것을 제외하면 동일한 상황을 이제 가정한다. 플레이어 1의 변화는 0:24에 있는 업데이터에 의해 포착되어 플레이어 2로 전파될 것이다. 이런 경우에, 상기 업데이터는 2:26에서 플레이어 2에 도달할 것이며, 이는 4:00 보다는 아주 더 빠른 것이다. 5개의 연관되지 않은 업데이터들을 사용하는 것 대신에, 정규 시간 속도의 3.272727 배로 이동하는 하나의 업데 이터가 사용된다면, 이런 특정 시나리오에 대해, 플레이어 1의 변화는, 정규 속도의 두 배로 시간을 통해서 가 는 상기 5개의 업데이터들을 구비한 것이므로, 동시에 플레이어 2에 도달할 것이다. 업데이터들의 개수와 업데이터들의 속도 사이의 관계는 단순한 전파 속도보다 더욱 복잡할 수 있을 것이다. 단 하나의 연관되지 않은 업데이터가 사용되어 시간을 통해서 매우 빠르게 이동하면, 그것은 과거에서의 모든 변화 들을 잡아서 그것들을 미래로 빠르게 운반할 것이며, 이는 그 변화들을 더욱 격렬하게 만든다. 많은 연관되지 않은 업데이터들이 사용되어 시간의 속도보다 단지 약간만 더 빠르게 시간을 통해서 이동하면, 과거로부터의 변 화들은 더 느리게 미래로 운반될 것이지만, 어떤 주어진 시간의 관점에서는, 상기 변화들은 더욱 빈번하지만 더욱 작고 그리고 더욱 점진적일 것이다. 유닛들이 그 자체적으로 시간을 통해서 이동할 때에, 특히 파라독스들이 발생할 때에, 그것들의 영향들은 더욱 커질 수 있다. 작은 개수의 업데이터들이 시간을 통해서 매우 빠르게 이동하면, 그러면 전체 시스템은 타임라인 이 안정될 때까지 상태들을 빠르게 오갈 수 있다. 유닛 X가 시간에 있어서 거꾸로 가고 그리고 최초의 장소에서 그 자신이 생성되는 것을 방해하면, 그러면 빠른 업데이터들은 두 상태들 사이에서 급격하게 왔다갔다할 수 있 을 것이며, 그 경우에 많은 더 느린 업데이터들은 시간을 통해서 이벤트들을 여전히 전파할 것이지만, 격렬한 상태들 사이에서 그렇게 빠르게 왔다갔다하지는 않을 것이다. 파라독스가 아닌 상황들에서는, 타임라인이 고정- 포인트 어트랙터 (attractor)를 구비하면, 더욱 빠른 업데이터들이 그 타임라인을 평형 상태로 더욱 빠르게 그 리고 더욱 격렬하게 이끌 수 있을 것이다. 업데이터들의 개수와 속도 사이의 이런 트레이드 오프 (trade off)는 연속적인 결과들을 만들어낸다. 그 관계는, 전파의 일정한 속도 = 업데이터들의 개수 * 업데이터들의 속도, 라는 대략적인 식으로 근사되며, 그리 고 업데이터들의 개수 또는 속도 중의 어느 하나가 증가되면 더욱 많은 CPU 시간을 소비하도록 한다. 또한, 본 발명의 다양한 실시예들에 따라, 상기 연관되지 않은 업데이터들에 대해 단순한 주변 루프 (looping around)가 아닌 상이한 전파 패턴들을 구비하는 것이 가능하다. 예를 들면, 업데이터들은 플레이어가 현재가 아 닌 시간에 있을 때마다 일정한 속도로 (또는 상기 플레이어가 얼마나 많은 명령들을 발했는가를 기반으로 하는 가변 속도로) 발사할 수 있을 것이다. 이런 경우에, 플레이어는 2분의 시간으로 거꾸로 점프할 수 있을 것이며, 그리고 매 20초마다, 새로운 업데이터가 상기 플레이어의 현재 시간으로부터 발생된다. 일단 업데이터가 타임 윈도우의 끝에 도달하면, 그 업데이터는 파괴된다. 시뮬레이션 세계 (Simulation world): 불변의 지역과 같은, 상기 시뮬레이션 내의 모든 비-동적 엔티티들. 도 4 내지 도 6의 각각은, 본 발명의 몇몇의 실시예들에 따른, 도 3의 시뮬레이션 관리자 모듈 , 업데이터 관리자 모듈 및 업데이터 동기화 관리자 모듈 의 동작들을 도시하는 의사코드들이다. 본 발명의 몇 몇의 실시예들에 따른, 시뮬레이션 관리자 모듈 , 업데이터 관리자 모듈 및 업데이터 동기화 관리자 모듈 과 연관된 다양한 방법들/기능들이 이제 설명될 것이다. boutToBeOvertaken(u): 업데이터 u를 주시하고 그리고 그 업데이터 뒤의 스냅샷 구간의 시간 내에 다른 업데이 터가 있으면 true를 리턴한다. CopyCurrentData(u, v): 업데이터 u의 콘텐츠 그리고 데이터 구조를 업데이터 v로 복제한다. 이 방법/기능은 더 빠른 업데이터 u가 더 늦은 업데이터 v를 추월할 때에 사용될 수 있을 것이다. CopyStatistics(u, v): 통계 값들의 현재 집합을 업데이터 u로부터 업데이터 v로 복제한다. EarliestUpdater(업데이터 s): 상기 업데이터에게 목록의 업데이터들로부터 가장 빠른 곳에 있는 시간을 리턴한 다. GetEvent(u, i, t): 업데이터 u 내에 저장된 데이터로부터 전방으로 동작하는 (횡단 거리를 줄이기 위해 u로부 터 전방으로 동작하는) 에이전트 i에 대해 시간 t를 초과하지 않은 가장 최근의 이벤트를 리턴한다. u가 NULL 이면, 그러면 상기 방법/기능은 타임 윈도우의 시작에서부터 상기 이벤트들을 통해서 횡단한다. PreUpdate(u): 업데이터 u가 다음의 글로벌 시간 (global time) 동안에 얼마나 많은 타임 스텝들을 커버해야만 하는가를 업데이터 u의 타임 멀티플라이어를 기반으로 하여 판별한다. 이 방법/기능은, 엔진 서버를 구비한 이 업데이터를 경유하여 현재 보고 있는 임의의 엔진 클라이언와의 동기화를 개시하기 위해서 또한 사용된다. RebuildPhysicsStructures(u): 계산하기에 비쌀 수 있으며 그리고 업데이터에 의해 캐치되는 어떤 물리적인 현 상, 가시도 (visibility) 또는 인터액션 구조들을 파괴하고 다시 구축한다. 예를 들면, 이는 옥트-트리들, 가시 지도들, 그리고 충돌 탐지 알고리즘들을 포함할 수 있을 것이다. 이런 구조들은, 효율성 때문에 그리고 상기 타 임라인의 일부는 메모리에 더 이상 존재하지 않기 때문에의 두 가지 모두의 이유로, 전체적인 타임라인을 다시 플레이하지 않고도 시간에 있어서 임의 포인트로부터 재구축할 수 있을 것을 필요로 한다. SortUpdatersByTime(업데이터들): 업데이터들을 그 업데이터들의 현재 시간 u.time을 기반으로 하여 소팅하고 그리고 u.nextUpdater 및 u.prevUpdater을 이용하여 이중 링크된 목록을 생성한다. TranslatePlayerInputToEvents(업데이터들): 플레이어들에 의해 송신된 엔진 클라이언트로부터 입력을 취하여 그것들 타임라인 상에서의 이벤트들로 변환한다. 이는 각 플레이어에게 상기 시뮬레이션에서의 대응 입력 관리 에이전트를 부여하여 수행될 수 있을 것이다. Update(u): 다음 타임 스텝들에서 이벤트들을 삽입하고 제거하면서, 그 다음 타임 스텝의 결과들을 계산한다. 모든 선행 이벤트들이 동일하다면, 이 방법/기능은 이벤트들의 세트는 항상 동일하다는 것을 보장할 수 있을 것 이다. 에이전트들의 행동들, 결정들 그리고 절차적인 콘텐트에서 사용되는 의사-랜덤 번호들은 불변이어야만 하 며, 그리고 결부된 이벤트 데이터 구조들은 Markov 속성 (메모리가 없는)을 가져야만 한다. 도 7은 본 발명의 몇몇 실시예들에 따른 도 3의 클라이언트 인터페이스 모듈 의 동작들을 도시하는 디스플 레이 스크린 샷 (shot)이다. 상단의 바는 현재에 대한 시각을 나타내며 그리고 하단의 바는 시뮬레이션이 시작 된 이후에 경과된 절대 시간을 나타낸다. 밝은 수직 라인들은, 하나는 현재에 그리고 다른 하나는 현재로부터 약 1.5분 이전에 있는 두 플레이어들의 현재 시각을 나타낸다. 희미해지는 더 옅은 수직 라인들은 업데이터들을 나타내며, 그 업데이터들의 각각은 하나의 업데이터보다 더 큰 타임 멀티플라이어들을 구비하며 상기 타임라인 을 통해서 업데이트들에 앞선다. 높이가 변하는 밝은 수평 라인들은 주어진 시각에서 발생하는 이벤트들의 통계 적인 표현을 나타낸다. 플레이어는 시간에 있어서 북마크들을 위치시킬 수 있을 것이며, 그 북마크들은 주어진 이벤트들로 점프해서 뒤돌아갈 수 있다. 도 7의 오른쪽에서의 제어들은 플레이어가 시간을 통한 진행의 속도를 제어하기 위해 자신 스스로의 타임 멀티플라이어를 변경하도록 허용할 수 있을 것이다. 도 7의 오른쪽의 취소 (Undo) 버튼은 플레이어가 에이전트들의 선택된 세트에 대해 이벤트들의 범위를 선택하여 그 에이전트들에게 그 플레이어가 이전에 송신했던 명령들을 보내는 것을 취소하도록 허용할 수 있을 것이다. 게이밍 애플리케이션들 또는 다른 경쟁 시뮬레이션들과 같은, 본 발명의 몇몇 실시예들에서, 사용자/플레이어는 시간에 있어서 허용될 수 있는 가장 오래된 포인트에서 플레이하는 것과는 반대로, 현재에서 더욱 많은 시간을 사용하라고 권고받을 수 있을 것이다. 몇몇의 실시예들에서, 플레이어는 그 플레이어가 시간에 있어서 뒤로 명 령들을 송신하기 위해 사용하는 에너지 이용을 통해 현재에서 더욱 많은 시간을 보내도록 동기 부여가 될 수 있 을 것이다. 이 에너지는 그 게임 내에서의 인터액션들로는 액세스 불가능하며, 그 플레이어/사용자에게만 이용 가능하다. 플레이어가 현재에 있을 때에, 상기 에너지는 재충전될 수 있을 것이다. 과거에 있는 에이전트들로 명령을 발할 때에, 상기 에너지가 소비된다. 몇몇 실시예들에서, 소비된 에너지의 양은 과거의 시간에 도달하기 위해 사용한 시간의 양에 비례할 수 있을 것이다. 플레이어가 미래에서 시간을 소모할 때에, 그 플레이어의 에 너지는 일정한 속도로 고갈될 수 있을 것이며 그리고 그 에너지가 전부 소진되면 그 플레이어는 현재로 돌아온 다. 이는 여전히 플레이어들이 시간 여행을 하는 이점을 가지면서도, 그 플레이어들이 현재의 시간 주변에서의 게임 플레이에 몰두할 수 있도록 장려할 수 있을 것이다. 도면 및 명세서에서, 본 발명의 예시적인 실시예들이 개시되었다. 비록 특정 용어들이 사용되었지만, 그 용어들 은 일반적이며 설명의 의미로만 사용된 것이며, 한정하려는 의도로 사용된 것은 아니며, 본 발명의 범위는 다음 의 청구범위에 의해서 정의된다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7"}
{"patent_id": "10-2011-7003099", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 몇몇 실시예들에 따라서 시나리오를 시뮬레이션하기 위한 통신 네트워크의 블록도이다. 도 2는 본 발명의 몇몇 실시예들에 따른 데이터 프로세싱 시스템을 도시한 블록도이다. 도 3은 본 발명의 몇몇 실시예들에 따른 데이터 프로세싱 시스템에서 시나리오를 시뮬레이션하기 위한 소프트웨 어/하드웨어 구조를 도시한 블록도이다. 도 4 내지 도 6 각각은 본 발명의 몇몇 실시예들에 따른 도 3의 시뮬레이션 관리자 모듈, 업데이터 (updater) 관리자 모듈 및 업데이터 동기화 관리자 모듈 의 동작들을 도시한 의사코드이다. 도 7은 본 발명의 몇몇 실시예들에 따른 도 3의 클라이언트 인터페이스 모듈의 동작들을 도시한 디스플레이 스 크린을 촬영한 것이다."}
