{"patent_id": "10-2024-7007948", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0036721", "출원번호": "10-2024-7007948", "발명의 명칭": "다수의 솔버 유형을 사용하여 입력 문제의 최적화된 다중 도메인 처리를 위한 클라우드 기반", "출원인": "인터그래프 코포레이션", "발명자": "로크, 훌리오, 피."}}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "컴퓨터 구현 방법으로서,하나 이상의 프로세서를 사용하여, 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계; 상기 하나 이상의 프로세서를 사용하여, 상기 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계;상기 하나 이상의 프로세서를 사용하여, 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하는 단계 - 각각의 컴퓨팅 컨테이너는 선택된 솔버 유형에 대응함 -;상기 하나 이상의 프로세서를 사용하여, 상기 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하는단계; 및상기 하나 이상의 프로세서를 사용하여, 상기 문제 출력을 상기 클라이언트 컴퓨팅 엔티티에 제공하는 단계를포함하고, 상기 문제 출력은 상기 입력 문제에 대한 최적화된 솔루션을 포함하고, 상기 문제 출력은 하나 이상의 예측 기반 액션을 수행하는 데 사용될 수 있는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계는:상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 하나 이상의 문제 특징에 적어도 부분적으로 기초하여솔버 도메인을 결정하는 단계; 상기 솔버 도메인과 연관된 도메인별 솔버 유형들의 세트를 식별하는 단계; 및상기 도메인별 솔버 유형들의 세트로부터 상기 하나 이상의 선택된 솔버 유형을 결정하는 단계를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 상기 하나 이상의 문제 특징은 유형 불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스(API) 요청을 통해 수신되고, 상기 문제 출력은 유형불가지론적 문제 솔루션 API 응답을 통해 상기 클라이언트 컴퓨팅 엔티티에 제공되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들을설명하도록 구성된 복수의 정적 필드를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서, 상기 도메인별 솔버 유형들의 세트로부터 상기 선택된 솔버 유형들을 결정하는 단계는 상기 입력 문제의 상기 문제 특징들에 적어도 부분적으로 기초하여 상기 도메인별 솔버 유형들의 세트로부터 상기 선택된 솔버 유형들을 결정하도록 구성되는 상기 문제 유형에 대한 솔버 선택 기계 학습 모델에 상기 입력 문제의하나 이상의 문제 특징을 제공하는 단계를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 입력 문제의 상기 문제 유형은 서버 클라우드 기반구조에 고유하고 하나 이상의 가용성구역 중 하나에 대응하는 서버리스 요청 관리 엔진에서 수신되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "공개특허 10-2024-0036721-3-제1항에 있어서, 상기 하나 이상의 컨테이너 인스턴스는 서버 클라우드 기반구조에 고유한 서버리스 컨테이너관리 엔진에 의해 관리되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서, 상기 서버리스 컨테이너 관리 엔진은 상기 선택된 솔버 유형들의 총 카운트에 적어도 부분적으로 기초하여 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제7항에 있어서, 인바운드 문제 큐가 상기 입력 문제를 식별하도록 업데이트되고, 상기 서버리스 컨테이너 관리엔진은 상기 인바운드 문제 큐에 의해 식별된 문제들의 수에 적어도 부분적으로 기초하여 상기 하나 이상의 선택된 솔버 유형에 대한 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1항에 있어서, 상기 문제 출력을 생성하는 단계는:상기 하나 이상의 컨테이너 인스턴스의 실행에 적어도 부분적으로 기초하여 생성된 하나 이상의 컨테이너 출력을 수신하는 단계; 및상기 하나 이상의 컨테이너 출력에 적어도 부분적으로 기초하여 상기 문제 출력을 생성하는 단계를 포함하는,컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제1항에 있어서,각각의 실행 반복 동안 각각의 컨테이너 인스턴스의 실행을 모니터링하고, 상기 실행 반복의 반복별 최적화 이득이 구성 가능한 반복별 최적화 이득 임계치를 충족시키지 못하는 경우 상기 컨테이너 인스턴스의 실행을 중단하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1항에 있어서, 컨테이너 인스턴스의 실행은 인바운드 문제 큐에 의해 식별된 하나 이상의 문제 각각에 대한컨테이너 출력을 병렬로 생성하도록 구성되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "클라우드 기반 시스템으로서,하나 이상의 프로세서 및 하나 이상의 메모리 저장 영역을 포함하고, 상기 하나 이상의 프로세서 및 하나 이상의 메모리 저장 영역은 서버리스 방식으로 동적으로 할당되도록 구성되고, 상기 메모리 저장 영역들은 구성된상기 클라우드 기반 시스템으로 하여금 프로세스들을 수행하게 하기 위해 상기 하나 이상의 프로세서에 의해 실행 가능한 명령어들을 포함하고, 상기 프로세스들은:클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계; 상기 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계; 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하는 단계 - 각각의 컴퓨팅 컨테이너는선택된 솔버 유형에 대응함 -; 상기 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하는 단계; 및상기 문제 출력을 상기 클라이언트 컴퓨팅 엔티티에 제공하는 단계를 포함하며, 상기 문제 출력은 상기 입력 문제에 대한 최적화된 솔루션을 포함하고, 상기 문제 출력은 하나 이상의 예측 기반 액션을 수행하는 데 사용될수 있는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서, 상기 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계는:공개특허 10-2024-0036721-4-상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 하나 이상의 문제 특징에 적어도 부분적으로 기초하여솔버 도메인을 결정하는 단계; 상기 솔버 도메인과 연관된 도메인별 솔버 유형들의 세트를 식별하는 단계; 및 상기 도메인별 솔버 유형들의 세트로부터 상기 하나 이상의 선택된 솔버 유형을 결정하는 단계를 포함하는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서, 상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 상기 하나 이상의 문제 특징은 유형불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스(API) 요청을 통해 수신되고, 상기 문제 출력은 유형불가지론적 문제 솔루션 API 응답을 통해 상기 클라이언트 컴퓨팅 엔티티에 제공되는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서, 상기 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들을 설명하도록 구성된 복수의 정적 필드를 포함하는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제15항에 있어서, 상기 도메인별 솔버 유형들의 세트로부터 상기 선택된 솔버 유형들을 결정하는 단계는 상기입력 문제의 상기 문제 특징들에 적어도 부분적으로 기초하여 상기 도메인별 솔버 유형들의 세트로부터 상기 선택된 솔버 유형들을 결정하도록 구성되는 상기 문제 유형에 대한 솔버 선택 기계 학습 모델에 상기 입력 문제의하나 이상의 문제 특징을 제공하는 단계를 포함하는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제13항에 있어서, 상기 입력 문제의 상기 문제 유형은 하나 이상의 가용성 구역 중 하나에 대응하는 서버리스요청 관리 엔진에서 수신되는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제13항에 있어서, 상기 하나 이상의 컨테이너 인스턴스는 서버 클라우드 기반구조에 고유한 서버리스 컨테이너관리 엔진에 의해 관리되는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "하나 이상의 프로세서에 의해 실행될 때 상기 하나 이상의 프로세서로 하여금 프로세스들을 수행하게 하는 컴퓨터 판독 가능 프로그램 코드 부분들을 저장하고 있는 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하는 컴퓨터 프로그램 제품으로서, 상기 프로세스들은:클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계; 상기 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계; 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하는 단계 - 각각의 컴퓨팅 컨테이너는선택된 솔버 유형에 대응함 -; 상기 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하는 단계; 및상기 문제 출력을 상기 클라이언트 컴퓨팅 엔티티에 제공하는 단계를 포함하며, 상기 문제 출력은 상기 입력 문제에 대한 최적화된 솔루션을 포함하고, 상기 문제 출력은 하나 이상의 예측 기반 액션을 수행하는 데 사용될수 있는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "컴퓨터 구현 방법으로서,서버 클라우드 기반구조에 고유한 서버리스 요청 관리 엔진에서 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력공개특허 10-2024-0036721-5-문제의 문제 유형을 수신하는 단계;상기 서버리스 요청 관리 엔진에 의해, 상기 서버 클라우드 기반구조 내에서, 상기 문제 유형에 대한 솔버 유형에 대응하는 컴퓨팅 컨테이너의 컨테이너 인스턴스의 실행을 유발하는 단계;상기 입력 문제에 대한 최적화된 솔루션을 포함하는 문제 출력을 상기 컨테이너 인스턴스로부터 수신하는 단계;및상기 서버리스 요청 관리 엔진에 의해, 상기 클라이언트 컴퓨팅 엔티티에 송신을 위해 상기 문제 출력을 제공하는 단계를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제21항에 있어서, 상기 컨테이너 인스턴스는 복수의 컨테이너 인스턴스 중 하나이며, 각각의 컨테이너 인스턴스는 상기 문제 유형에 대한 상이한 솔버 유형에 대응하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제22항에 있어서,상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 하나 이상의 문제 특징에 적어도 부분적으로 기초하여솔버 도메인을 결정하는 단계; 상기 솔버 도메인과 연관된 도메인별 솔버 유형들의 세트를 식별하는 단계; 및상기 도메인별 솔버 유형들의 세트로부터 상기 하나 이상의 솔버 유형을 결정하는 단계를 더 포함하는, 컴퓨터구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "제23항에 있어서, 상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 상기 하나 이상의 문제 특징은 유형불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스(API) 요청을 통해 수신되고, 상기 문제 출력은 유형불가지론적 문제 솔루션 API 응답을 통해 상기 클라이언트 컴퓨팅 엔티티에 제공되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제24항에 있어서, 상기 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들을 설명하도록 구성된 복수의 정적 필드를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_26", "content": "제23항에 있어서, 상기 도메인별 솔버 유형들의 세트로부터 상기 선택된 솔버 유형들을 결정하는 단계는 상기입력 문제의 상기 문제 특징들에 적어도 부분적으로 기초하여 상기 도메인별 솔버 유형들의 세트로부터 상기 선택된 솔버 유형들을 결정하도록 구성되는 상기 문제 유형에 대한 솔버 선택 기계 학습 모델에 상기 입력 문제의하나 이상의 문제 특징을 제공하는 단계를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_27", "content": "제21항에 있어서, 상기 서버리스 요청 관리 엔진은 하나 이상의 가용성 구역 중 하나에 대응하는, 컴퓨터 구현방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_28", "content": "제22항에 있어서, 상기 서버리스 컨테이너 관리 엔진은 상기 솔버 유형들의 총 카운트에 적어도 부분적으로 기초하여 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_29", "content": "제22항에 있어서, 인바운드 문제 큐가 상기 입력 문제를 식별하도록 업데이트되고, 상기 서버리스 컨테이너 관리 엔진은 상기 인바운드 문제 큐에 의해 식별된 문제들의 수에 적어도 부분적으로 기초하여 상기 하나 이상의솔버 유형에 대한 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성되는, 컴퓨터 구현 방법.공개특허 10-2024-0036721-6-청구항 30 제21항에 있어서, 상기 문제 출력을 생성하는 단계는:상기 컨테이너 인스턴스의 실행에 적어도 부분적으로 기초하여 생성된 하나 이상의 컨테이너 출력을 수신하는단계; 및상기 하나 이상의 컨테이너 출력에 적어도 부분적으로 기초하여 상기 문제 출력을 생성하는 단계를 포함하는,컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_31", "content": "제22항에 있어서,각각의 실행 반복 동안 각각의 컨테이너 인스턴스의 실행을 모니터링하고, 상기 실행 반복의 반복별 최적화 이득이 구성 가능한 반복별 최적화 이득 임계치를 충족시키지 못하는 경우 상기 컨테이너 인스턴스의 실행을 중단하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_32", "content": "제22항에 있어서, 컨테이너 인스턴스의 실행은 인바운드 문제 큐에 의해 식별된 하나 이상의 문제 각각에 대한컨테이너 출력을 병렬로 생성하도록 구성되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_33", "content": "클라우드 기반 시스템으로서,서버 클라우드 기반구조에 고유한 서버리스 요청 관리 엔진을 포함하고, 상기 서버리스 요청 관리 엔진은 프로세스들을 수행하도록 구성되고, 상기 프로세스들은:클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계;상기 서버리스 요청 관리 엔진에 의해, 상기 문제 유형에 대한 솔버 유형에 대응하는 컴퓨팅 컨테이너의 컨테이너 인스턴스의 실행을 유발하는 단계;상기 입력 문제에 대한 최적화된 솔루션을 포함하는 문제 출력을 상기 컨테이너 인스턴스로부터 수신하는 단계;및상기 클라이언트 컴퓨팅 엔티티에 송신을 위해 상기 문제 출력을 제공하는 단계를 포함하는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_34", "content": "제33항에 있어서, 상기 컴퓨팅 컨테이너는 복수의 컴퓨팅 컨테이너 중 하나이고, 각각의 컴퓨팅 컨테이너는 상기 문제 유형에 대한 상이한 솔버 유형에 대응하는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_35", "content": "제34항에 있어서, 상기 서버리스 요청 관리 엔진은:상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 하나 이상의 문제 특징에 적어도 부분적으로 기초하여솔버 도메인을 결정하는 단계; 상기 솔버 도메인과 연관된 도메인별 솔버 유형들의 세트를 식별하는 단계; 및상기 도메인별 솔버 유형들의 세트로부터 상기 하나 이상의 솔버 유형을 결정하는 단계를 포함하는 프로세스들을 수행하도록 더 구성되는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_36", "content": "제35항에 있어서, 상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 상기 하나 이상의 문제 특징은 유형불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스(API) 요청을 통해 수신되고, 상기 문제 출력은 유형공개특허 10-2024-0036721-7-불가지론적 문제 솔루션 API 응답을 통해 상기 클라이언트 컴퓨팅 엔티티에 제공되는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_37", "content": "제36항에 있어서, 상기 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들을 설명하도록 구성된 복수의 정적 필드를 포함하는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_38", "content": "제35항에 있어서, 상기 도메인별 솔버 유형들의 세트로부터 상기 선택된 솔버 유형들을 결정하는 단계는 상기입력 문제의 상기 문제 특징들에 적어도 부분적으로 기초하여 상기 도메인별 솔버 유형들의 세트로부터 상기 선택된 솔버 유형들을 결정하도록 구성되는 상기 문제 유형에 대한 솔버 선택 기계 학습 모델에 상기 입력 문제의하나 이상의 문제 특징을 제공하는 단계를 포함하는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_39", "content": "제33항에 있어서, 상기 서버리스 요청 관리 엔진은 하나 이상의 가용성 구역 중 하나에 대응하는, 클라우드 기반 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_40", "content": "하나 이상의 프로세서에서 실행될 때 상기 하나 이상의 프로세서로 하여금 프로세스들을 수행하는 서버 클라우드 기반구조에 고유한 서버리스 요청 관리 엔진을 구현하게 하는 컴퓨터 판독 가능 프로그램 코드 부분들을 저장하고 있는 적어도 하나의 비일시적 컴퓨터 판독 가능 저장 매체를 포함하는 컴퓨터 프로그램 제품으로서,상기 프로세스들은:클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계;상기 서버리스 요청 관리 엔진에 의해, 상기 문제 유형에 대한 솔버 유형에 대응하는 컴퓨팅 컨테이너의 컨테이너 인스턴스의 실행을 유발하는 단계;상기 입력 문제에 대한 최적화된 솔루션을 포함하는 문제 출력을 상기 컨테이너 인스턴스로부터 수신하는 단계;및상기 클라이언트 컴퓨팅 엔티티에 송신을 위해 상기 문제 출력을 제공하는 단계를 포함하는, 컴퓨터 프로그램제품."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_41", "content": "컴퓨터 구현 방법으로서,하나 이상의 프로세서를 사용하여, 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계;상기 입력 문제의 문제 특징들에 적어도 부분적으로 기초하여 솔버 유형들의 세트 중에서 최적의 솔버 유형을결정하도록 구성되는 솔버 선택 기계 학습 모델에 상기 입력 문제의 상기 하나 이상의 문제 특징을 제공하는 단계;상기 하나 이상의 프로세서를 사용하여, 상기 최적의 솔버 유형을 이용하여 문제 출력을 생성하는 단계; 및상기 하나 이상의 프로세서를 사용하여, 상기 문제 출력을 상기 클라이언트 컴퓨팅 엔티티에 제공하는 단계를포함하고, 상기 문제 출력은 상기 입력 문제에 대한 최적화된 솔루션을 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_42", "content": "제41항에 있어서, 상기 문제 유형은 도메인 특유 문제 유형이고, 상기 솔버 선택 기계 학습 모델은 도메인 특유솔버 유형들의 세트 중에서 최적의 도메인 특유 솔버 유형을 결정하도록 구성되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_43", "content": "제41항에 있어서, 상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 상기 하나 이상의 문제 특징은 유형공개특허 10-2024-0036721-8-불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스(API) 요청을 통해 수신되고, 상기 문제 출력은 유형불가지론적 문제 솔루션 API 응답을 통해 상기 클라이언트 컴퓨팅 엔티티에 제공되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_44", "content": "제43항에 있어서, 상기 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들을 설명하도록 구성된 복수의 정적 필드를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_45", "content": "제41항에 있어서, 상기 입력 문제의 상기 문제 유형은 서버 클라우드 기반구조에 고유하고 하나 이상의 가용성구역 중 하나에 대응하는 서버리스 요청 관리 엔진에서 수신되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_46", "content": "제41항에 있어서, 상기 솔버 선택 기계 학습 모델은 서버 클라우드 기반구조에 고유한 서버리스 컨테이너 관리엔진에 의해 관리되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_47", "content": "제46항에 있어서, 상기 서버리스 컨테이너 관리 엔진은 솔버 유형들의 총 카운트에 적어도 부분적으로 기초하여컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_48", "content": "제46항에 있어서, 인바운드 문제 큐가 상기 입력 문제를 식별하도록 업데이트되고, 상기 서버리스 컨테이너 관리 엔진은 상기 인바운드 문제 큐에 의해 식별된 문제들의 수에 적어도 부분적으로 기초하여 상기 복수의 솔버유형에 대한 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_49", "content": "제41항에 있어서, 상기 문제 출력을 생성하는 단계는:하나 이상의 컨테이너 인스턴스의 실행에 적어도 부분적으로 기초하여 생성된 하나 이상의 컨테이너 출력을 수신하는 단계; 및상기 하나 이상의 컨테이너 출력에 적어도 부분적으로 기초하여 상기 문제 출력을 생성하는 단계를 포함하는,컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_50", "content": "제49항에 있어서,각각의 실행 반복 동안 각각의 컨테이너 인스턴스의 실행을 모니터링하고, 상기 실행 반복의 반복별 최적화 이득이 구성 가능한 반복별 최적화 이득 임계치를 충족시키지 못하는 경우 상기 컨테이너 인스턴스의 실행을 중단하는 단계를 더 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_51", "content": "제49항에 있어서, 컨테이너 인스턴스의 실행은 인바운드 문제 큐에 의해 식별된 하나 이상의 문제 각각에 대한컨테이너 출력을 병렬로 생성하도록 구성되는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_52", "content": "제41항에 있어서, 상기 솔버 유형들의 세트는 무작위 대입 솔버 유형, 제1-적합 솔버 유형, 최강-적합 솔버 유형, 타부-탐색 솔버 유형, 시뮬레이티드-어닐링 솔버 유형, 지연-수락 솔버 유형, 언덕 오르기 솔버 유형, 또는전략적 진동 솔버 유형 중 적어도 하나를 포함하는, 컴퓨터 구현 방법."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_53", "content": "입력 문제에 대한 최적화된 솔루션을 제공하기 위한 시스템으로서,공개특허 10-2024-0036721-9-상기 입력 문제의 문제 특징들에 적어도 부분적으로 기초하여 솔버 유형들의 세트 중에서 최적의 솔버 유형을결정하도록 구성되는 솔버 선택 기계 학습 모델; 및클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하고, 상기 입력 문제의 하나 이상의문제 특징을 상기 솔버 선택 기계 학습 모델에 제공하고, 상기 최적의 솔버 유형을 사용하여 문제 출력을 생성하고, 상기 문제 출력을 상기 클라이언트 컴퓨팅 엔티티에 제공하도록 구성된 하나 이상의 프로세서를포함하며, 상기 문제 출력은 상기 입력 문제에 대한 최적화된 솔루션을 포함하는, 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_54", "content": "제53항에 있어서, 상기 문제 유형은 도메인 특유 문제 유형이고, 상기 솔버 선택 기계 학습 모델은 도메인 특유솔버 유형들의 세트 중에서 최적의 도메인 특유 솔버 유형을 결정하도록 구성되는, 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_55", "content": "제53항에 있어서, 상기 입력 문제의 상기 문제 유형 및 상기 입력 문제의 상기 하나 이상의 문제 특징은 유형불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스(API) 요청을 통해 수신되고, 상기 문제 출력은 유형불가지론적 문제 솔루션 API 응답을 통해 상기 클라이언트 컴퓨팅 엔티티에 제공되는, 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_56", "content": "제55항에 있어서, 상기 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들을 설명하도록 구성된 복수의 정적 필드를 포함하는, 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_57", "content": "제53항에 있어서, 상기 입력 문제의 상기 문제 유형은 하나 이상의 가용성 구역 중 하나에 대응하는 서버리스요청 관리 엔진에서 수신되는, 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_58", "content": "제53항에 있어서, 상기 솔버 선택 기계 학습 모델은 서버 클라우드 기반구조에 고유한 서버리스 컨테이너 관리엔진에 의해 관리되는, 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_59", "content": "제58항에 있어서, 상기 서버리스 컨테이너 관리 엔진은 솔버 유형들의 총 카운트에 적어도 부분적으로 기초하여컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성되는, 시스템."}
{"patent_id": "10-2024-7007948", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_60", "content": "하나 이상의 프로세서에 의해 실행될 때 상기 하나 이상의 프로세서로 하여금 프로세스들을 수행하게 하는 컴퓨터 판독 가능 프로그램 코드 부분들을 저장하고 있는 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하는 컴퓨터 프로그램 제품으로서, 상기 프로세스들은:입력 문제의 문제 특징들에 적어도 부분적으로 기초하여 솔버 유형들의 세트 중에서 최적의 솔버 유형을 결정하도록 구성되는 솔버 선택 기계 학습 모델을 제공하는 단계;클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계;상기 입력 문제의 하나 이상의 문제 특징을 상기 솔버 선택 기계 학습 모델에 제공하는 단계;상기 최적의 솔버 유형을 사용하여 문제 출력을 생성하는 단계; 및상기 문제 출력을 상기 클라이언트 컴퓨팅 엔티티에 제공하는 단계를 포함하며, 상기 문제 출력은 입력 문제에대한 최적화된 솔루션을 포함하는, 컴퓨터 프로그램 제품."}
{"patent_id": "10-2024-7007948", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 개시의 다양한 실시예들은 다수의 솔버 유형을 사용하여 컨테이너화된 클라우드 기반(예를 들어, 서버리스) 방식으로 입력 문제들에 대한 최적화된 솔루션들을 결정하기 위한 방법들, 장치들, 시스템들, 컴퓨팅 디바이스들, 컴퓨팅 엔티티들, 기타 등등을 제공한다. 일 실시예에서, 예시적인 방법은 클라이언트 컴퓨팅 엔티 티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계, 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑 하는 단계, 각각의 컴퓨팅 컨테이너가 선택된 솔버 유형에 대응하는 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하는 단계, 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하는 단계, 및 문제 출력을 클라이언트 컴퓨팅 엔티티에 제공하는 단계를 포함하고, 문제 출력은 하나 이상의 예측 기반 액션을 수행하는 데 사용될 수 있는 입력 문제에 대한 최적화된 솔루션을 포함한다."}
{"patent_id": "10-2024-7007948", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "관련 출원(들)에 대한 상호 참조 본 특허 출원은 입력 문제의 최적화된 다중 도메인 처리를 위한 클라우드 기반 시스템(CLOUD-BASED SYSTEMS FOR OPTIMIZED MULTI-DOMAIN PROCESSING OF INPUT PROBLEMS)이라는 발명의 명칭으로 2021년 8월 11일에 출원된 미 국 임시 특허 출원 제63/231,997호의 이익을 주장하며, 이는 그 전체가 본 명세서에 참조로 통합된다. 본 특허 출원은 또한 다수의 솔버 유형을 사용하여 입력 문제의 최적화된 다중 도메인 처리를 위한 클라우드 기반 시스 템(CLOUD-BASED SYSTEMS FOR OPTIMIZED MULTI-DOMAIN PROCESSING OF INPUT PROBLEMS USING MULTIPLE SOLVER TYPES)이라는 발명의 명칭으로 2022년 2월 18일에 출원된 미국 특허 출원 제17/675,439호의 이익을 주장하며, 이는 그 전체가 본 명세서에 참조로 통합된다. 본 특허 출원은 또한 서버 클라우드 기반구조에 고유한 서버리 스 요청 관리 엔진을 사용하여 입력 문제의 최적화된 다중 도메인 처리를 위한 클라우드 기반 시스템(CLOUD- BASED SYSTEMS FOR OPTIMIZED MULTI-DOMAIN PROCESSING OF INPUT PROBLEMS USING A SERVERLESS REQUEST MANAGEMENT ENGINE NATIVE TO A SERVER CLOUD INFRASTRUCTURE)이라는 발명의 명칭으로 2022년 2월 18일에 출원 된 미국 특허 출원 제17/675,454호의 이익을 주장하며, 이는 그 전체가 본 명세서에 참조로 통합된다. 본 특허 출원은 또한 기계 학습 솔버 유형 선택을 사용하여 입력 문제의 최적화된 다중 도메인 처리를 위한 클라우드 기 반 시스템(CLOUD-BASED SYSTEMS FOR OPTIMIZED MULTI-DOMAIN PROCESSING OF INPUT PROBLEMS USING MACHINE LEARNING SOLVER TYPE SELECTION)이라는 발명의 명칭으로 2022년 2월 18일에 출원된 미국 특허 출원 제 17/675,471호의 이익을 주장하며, 이는 그 전체가 본 명세서에 참조로 통합된다."}
{"patent_id": "10-2024-7007948", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "본 개시의 다양한 실시예들은 상이한 문제 도메인들에 속하는 복수의 문제에 대한 최적화된 솔루션들을 결정하 기 위해 클라우드 기반 시스템 아키텍처를 활용(leveraging)하는 것과 관련된 기술적 과제들을 다룬다. 본 개 시의 다양한 실시예들은 복수의 문제에 대한 최적화된 솔루션들을 결정하고 이러한 최적화된 솔루션들을 통신하 는 동작 효율성에 중요한 기술적 기여를 한다. 일반적으로, 본 개시의 다양한 실시예들은 각각이 솔버 유형(solver type)에 대응하는 하나 이상의 컴퓨팅 컨테 이너(compute containers)의 하나 이상의 컨테이너 인스턴스(container instances)의 실행에 적어도 부분적으 로 기초하여 입력 문제들(input problems)에 대한 최적화된 솔루션들을 결정하기 위한 방법들, 장치들, 시스템 들, 컴퓨팅 디바이스들, 컴퓨팅 엔티티들(computing entities), 기타 등등(and/or the like)을 제공한다. 다 양한 실시예들은 다양한 문제 유형들의 입력 문제들, 특히 다항식 문제들(polynomial problems)(P 문제들(P problems)) 또는 비결정론적 다항식(nondeterministic polynomial) 문제들(NP 문제들(NP problems))일 수 있는 입력 문제들에 대한 최적화된 솔루션들을 결정하도록 구성된다. 다양한 실시예들에서, 클라우드 기반 다중 도 메인 솔버 시스템은 입력 문제를 정의하는 유형 불가지론적 문제 해결(type-agnostic problem solving) 애플리 케이션 프로그래밍 인터페이스(application programming interface(API)) 요청을 수신하고, 각각이 솔버 유형 에 대응하는 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하도록 구성된다. 각각의 컨테이너 인스턴스는 솔버 유형에 따라 실행되어, 정의된 입력 문제에 대한 최적화된 솔루션을 결정한다. 클라 우드 기반 다중 도메인 솔버 시스템은 유형 불가지론적 문제 솔루션 API 응답을 통해, 정의된 입력 문제에 대한 최적화된 솔루션을 제공하도록 구성된다. 다양한 실시예들에서, 클라우드 기반 다중 도메인 솔버 시스템은 컴 퓨팅 및 처리 자원들의 가용성(availability) 및 소비, 및 수신된 유형 불가지론적 문제 해결 API 요청들의 볼 륨을 포함하는 다양한 요인들에 적어도 부분적으로 기초하여 실행되고 있는 컨테이너 인스턴스들의 카운트를 지 능적으로 스케일링(scale)한다. 따라서, 다양한 실시예들은 복수의 입력 문제에 대한 최적화된 솔루션들의 유 연하고 탄력적인 결정에 있어서 기술적 이점들을 제공한다. 일 양태에 따르면, 방법이 제공된다. 일 실시예에서, 방법은 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계, 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계, 및 하나 이상 의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하는 단계를 포함한다. 각각의 컴퓨팅 컨테이너는 선택된 솔버 유형에 대응한다. 방법은 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하고, 문제 출력을 클라이언트 컴퓨팅 엔티티에 제공하는 단계를 더 포함한다. 문제 출력은 입력 문제에 대한 최적화된 솔 루션을 포함하며, 문제 출력은 하나 이상의 예측 기반 액션(prediction-based actions)을 수행하는 데 사용될수 있다. 다양한 실시예들에서, 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계는 입력 문제의 문제 유형 및 입력 문제의 하나 이상의 문제 특징들(problem features)에 적어도 부분적으로 기초하여 솔버 도메인을 결정하 는 단계, 솔버 도메인과 연관된 도메인별(per-domain) 솔버 유형들의 세트를 식별하는 단계, 및 도메인별 솔버 유형들의 세트로부터 하나 이상의 선택된 솔버 유형을 결정하는 단계를 포함한다. 다양한 실시예들에서, 입력 문제의 문제 유형 및 입력 문제의 하나 이상의 문제 특징은 유형 불가지론적 문제 해결 애플리케이션 프로그래 밍 인터페이스(API) 요청을 통해 수신되고, 문제 출력은 유형 불가지론적 문제 솔루션 API 응답을 통해 클라이 언트 컴퓨팅 엔티티에 제공된다. 다양한 실시예들에서, 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들을 설명하도록 구성된 복수의 정적 필드(static fields)를 포함한다. 다양한 실시예들에서, 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하는 단계는 입력 문제의 문제 특 징들에 적어도 부분적으로 기초하여 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하도록 구성 되는 문제 유형에 대한 솔버 선택 기계 학습 모델에 입력 문제의 하나 이상의 문제 특징을 제공하는 단계를 포 함한다. 다양한 실시예들에서, 입력 문제의 문제 유형은 서버 클라우드 기반구조에 고유하고 하나 이상의 가용성 구역 (availability zones) 중 하나에 대응하는 서버리스 요청 관리 엔진(serverless request management engine)에 서 수신된다. 다양한 실시예들에서, 하나 이상의 컨테이너 인스턴스는 서버 클라우드 기반구조에 고유한 서버 리스 컨테이너 관리 엔진에 의해 관리된다. 서버리스 컨테이너 관리 엔진은 선택된 솔버 유형의 총 카운트에 적어도 부분적으로 기초하여 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성된다. 다양한 실시예들에 서, 인바운드 문제 큐(inbound problem queue)가 입력 문제를 식별하도록 업데이트되고, 서버리스 컨테이너 관 리 엔진은 인바운드 문제 큐에 의해 식별된 문제들의 수에 적어도 부분적으로 기초하여 하나 이상의 선택된 솔 버 유형에 대한 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성된다. 다양한 실시예들에서, 문제 출력을 생성하는 단계는 하나 이상의 컨테이너 인스턴스의 실행에 적어도 부분적으 로 기초하여 생성된 하나 이상의 컨테이너 출력을 수신하는 단계 및 하나 이상의 컨테이너 출력에 적어도 부분 적으로 기초하여 문제 출력을 생성하는 단계를 포함한다. 다양한 실시예들에서, 방법은 각각의 실행 반복 동안 에 각각의 컨테이너 인스턴스의 실행을 모니터링하는 단계 및 실행 반복(execution iteration)의 반복별 최적화 이득(per-iteration optimization gain)이 구성 가능한 반복별 최적화 이득 임계치를 충족시키지 못하는 경우에 컨테이너 인스턴스의 실행을 중단하는 단계를 더 포함한다. 컨테이너 인스턴스의 실행은 인바운드 문제 큐에 의해 식별된 하나 이상의 문제 각각에 대한 컨테이너 출력을 병렬로(in parallel) 생성하도록 구성된다. 다른 양태에 따르면, 클라우드 기반 시스템이 제공된다. 클라우드 기반 시스템은 서버리스 방식으로 동적으로 할당되도록 구성되는 하나 이상의 프로세서 및 하나 이상의 메모리 저장 영역을 포함한다. 일 실시예에서, 클 라우드 기반 시스템은 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하고, 문제 유형 을 하나 이상의 선택된 솔버 유형에 매핑하고, 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스 를 생성하도록 구성된다. 각각의 컴퓨팅 컨테이너는 선택된 솔버 유형에 대응한다. 클라우드 기반 시스템은 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하고, 클라이언트 컴퓨팅 엔티티에 문제 출력을 제 공하도록 추가로 구성된다. 문제 출력은 입력 문제에 대한 최적화된 솔루션을 포함하며, 문제 출력은 하나 이 상의 예측 기반 액션을 수행하는 데 사용될 수 있다. 또 다른 양태에 따르면, 컴퓨터 프로그램 제품이 제공된다. 컴퓨터 프로그램 제품은 컴퓨터 판독 가능 프로그 램 코드 부분들이 저장되어 있는 적어도 하나의 비일시적 컴퓨터 판독 가능 저장 매체를 포함한다. 컴퓨터 판 독 가능 프로그램 코드 부분들은 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하고, 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하고, 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하도록 구성된다. 각각의 컴퓨팅 컨테이너는 선택된 솔버 유형에 대응한다. 컴퓨터 판독 가능 프로그램 코드 부분들은 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하고, 클라이언트 컴퓨팅 엔티티에 문제 출력을 제공하도록 추가로 구성된다. 문제 출력은 입력 문제에 대한 최적화된 솔루션을 포함하 며, 문제 출력은 하나 이상의 예측 기반 액션을 수행하는 데 사용될 수 있다. 다른 양태에 따르면, 컴퓨터 구현 방법, 클라우드 기반 시스템, 및 컴퓨터 프로그램 제품은 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하는 단계, 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계, 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하는 단계 - 각각의 컴퓨 팅 컨테이너는 선택된 솔버 유형에 대응함 -, 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하는단계, 및 문제 출력을 클라이언트 컴퓨팅 엔티티에 제공하는 단계 - 문제 출력은 입력 문제에 대한 최적화된 솔 루션을 포함하고, 문제 출력은 하나 이상의 예측 기반 액션을 수행하는 데 사용될 수 있음 -을 포함하는 프로세 스들을 수반한다. 다양한 대안적인 실시예들에서, 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계는 입력 문제의 문 제 유형 및 입력 문제의 하나 이상의 문제 특징에 적어도 부분적으로 기초하여 솔버 도메인을 결정하는 단계, 솔버 도메인과 연관된 도메인별 솔버 유형들의 세트를 식별하는 단계, 및 도메인별 솔버 유형들의 세트로부터 하나 이상의 선택된 솔버 유형을 결정하는 단계를 포함한다. 입력 문제의 문제 유형 및 입력 문제의 하나 이상 의 문제 특징은 유형 불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스(API) 요청을 통해 수신될 수 있으며, 이 경우 문제 출력은 유형 불가지론적 문제 솔루션 API 응답을 통해 클라이언트 컴퓨팅 엔티티에 제공 될 수 있다. 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들을 설명하 도록 구성된 복수의 정적 필드를 포함할 수 있다. 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하는 단계는 입력 문제의 문제 특징들에 적어도 부분적으로 기초하여 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하도록 구성되는 문제 유형에 대한 솔버 선택 기계 학습 모델에 입력 문제의 하나 이 상의 문제 특징을 제공하는 단계를 포함할 수 있다. 입력 문제의 문제 유형은 서버 클라우드 기반구조에 고유 하고 하나 이상의 가용성 구역 중 하나에 대응하는 서버리스 요청 관리 엔진에서 수신될 수 있다. 하나 이상의 컨테이너 인스턴스는 서버 클라우드 기반구조에 고유한 서버리스 컨테이너 관리 엔진에 의해 관리될 수 있다. 서버리스 컨테이너 관리 엔진은 선택된 솔버 유형들의 총 카운트에 적어도 부분적으로 기초하여 컨테이너 인스 턴스들의 총 카운트를 스케일링하도록 구성될 수 있다. 인바운드 문제 큐가 입력 문제를 식별하도록 업데이트 될 수 있으며, 이 경우 서버리스 컨테이너 관리 엔진은 인바운드 문제 큐에 의해 식별된 문제들의 수에 적어도 부분적으로 기초하여 하나 이상의 선택된 솔버 유형에 대한 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성될 수 있다. 문제 출력을 생성하는 단계는 하나 이상의 컨테이너 인스턴스의 실행에 적어도 부분적으로 기 초하여 생성된 하나 이상의 컨테이너 출력을 수신하는 단계, 및 하나 이상의 컨테이너 출력에 적어도 부분적으 로 기초하여 문제 출력을 생성하는 단계를 포함할 수 있다. 프로세스들은 또한 각각의 실행 반복 동안 각각의 컨테이너 인스턴스의 실행을 모니터링하는 단계 및 실행 반복의 반복별 최적화 이득이 구성 가능한 반복별 최적 화 이득 임계치를 충족시키지 못하는 경우에 컨테이너 인스턴스의 실행을 중단하는 단계를 포함할 수 있다. 컨 테이너 인스턴스의 실행은 인바운드 문제 큐에 의해 식별된 하나 이상의 문제 각각에 대한 컨테이너 출력을 병 렬로 생성하도록 구성될 수 있다. 추가적인 실시예들이 개시되고 청구될 수 있다."}
{"patent_id": "10-2024-7007948", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 개시의 다양한 실시예들은 본 개시의 모두가 아닌 일부 실시예들만이 도시되어 있는 첨부 도면들을 참조하여 이하에서 보다 충분히 설명된다. 사실상, 본 개시는 많은 상이한 형태로 구체화될 수 있고, 본 명세서에 설명 된 실시예들로 한정되는 것으로 해석되어서는 안 되며; 오히려, 이러한 실시예들은 본 개시가 적용 가능한 법적 요건들을 충족시킬 수 있도록 제공된다. 용어 \"또는\"은 달리 표시되지 않는 한, 본 명세서에서 대안적인 그리 고 접속적인 의미 모두로 사용된다. \"예시적인(illustrative)\" 및 \"예시적인(exemplary)\"이라는 용어는 품질 레벨을 나타내지 않는 예들로서 사용된다. 전반적으로, 동일한 번호들은 동일한 요소들을 지칭한다. 더욱이, 본 개시의 특정 실시예들이 예측 데이터 분석과 관련하여 설명되지만, 이 분야의 통상의 기술자는 개시된 개념 들이 다른 유형의 데이터 분석을 실행하는 데 사용될 수 있다는 것을 인식할 것이다. 본 명세서에서 사용되는 바와 같이, 용어 \"데이터 엔티티(data entity)\" 및 \"데이터 구조체(data construct)\"는 상호 교환가능하게 사용 될 수 있다. I. 일반 개요 및 기술적 이점들 본 개시의 다양한 실시예들은 일반적으로 컨테이너화된(containerized) 클라우드 기반(예를 들어, 서버리스 (serverless)) 방식으로 입력 문제들에 대한 최적화된 솔루션들을 결정하는 것에 관련된다. 특히, 입력 문제들 에 대한 최적화된 솔루션들을 결정하는 것은 각각이 솔버 유형에 대응하는 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스의 실행에 적어도 부분적으로 기초한다. 컨테이너 인스턴스들은 클라우드 기반 다중 도메인 솔버 시스템 내에서 서버리스 방식으로 실행된다. 즉, 컴퓨팅 및 처리 자원들(computing and processing resources)은 주문(on-demand)에 기초하여 컨테이너 인스턴스들의 실행을 위해 모집될 수 있다. 따 라서, 본 개시의 다양한 실시예들은 입력 문제들의 볼륨에 대한 최적화된 솔루션들의 유연하고 탄력적인 결정을 가능하게 함으로써 기술적 이점들을 제공한다. 다양한 예시적인 사례들에서, 컴퓨팅 및 처리 자원들은 우선순위를 갖는 특정 입력 문제들에 대해 전환(divert), 할당(allocate), 예약(reserve), 기타 등등이 될 수 있고, 컴퓨팅 및 처리 자원들은 입력 문제들의 볼륨이 낮을 때 보존될 수 있다. 따라서, 본 개시의 다양한 실시예들 에서의 입력 문제들에 대한 최적화된 솔루션들의 클라우드 기반 및 서버리스 결정은 컴퓨팅 및 처리 자원들의 효율적이고 유연하고 탄력적인 사용을 초래하며, 이는 추가로 시간 및 실제 비용의 보존(conservation)으로 이 어진다. 다양한 실시예들에서, 입력 문제들에 대한 최적화된 솔루션들은 컨테이너 인스턴스들의 실행, 또는 컴퓨팅 컨테 이너들의 인스턴스화들(instantiations)에 적어도 부분적으로 기초하여 결정된다. 컴퓨팅 컨테이너는 특정 솔 버 유형(예를 들어, 특정 알고리즘, 특정 휴리스틱(heuristic))에 따라 입력 문제에 대한 최적화된 솔루션을 결 정하기 위한 컴퓨터 실행가능 명령어들의 컨테이너화(containerization) 또는 패키지로서 이해될 수 있으며, 최 적화된 솔루션을 결정하는 데 필요한 추가적인 데이터(예를 들어, 라이브러리들, 종속성 데이터(dependency data))를 포함할 수 있다. 본 개시의 다양한 실시예들은 다양한 또는 한 세트의 솔버 유형들에 대한 컴퓨팅 컨 테이너들의 사용을 수반하며, 다양한 솔버 유형들의 컨테이너화는 다양한 기술적 이점들을 제공한다. 특히, 컴 퓨팅 컨테이너들의 사용은 컴퓨팅 컨테이너의 다수의 컨테이너 인스턴스가 컴퓨팅 및 처리 자원들을 과도하게 소비하지 않고 실질적으로 병렬로 실행될 수 있으므로 유연성(flexibility)과 스케일링 가능성(scalability)을 가능하게 한다. 또한, 컴퓨팅 컨테이너의 상이한 컨테이너 인스턴스들이 실행되어 상이한 입력 문제들에 대한 최적화된 솔루션을 결정할 수 있으며, 따라서 다수의 입력 문제를 효율적으로 핸들링하고 처리할 수 있다. II. 특정 용어의 예시적인 정의 용어 \"입력 문제(input problem)\"는 해결을 위해 클라우드 기반 다중 도메인 솔버 시스템에 제공되는 정의된 문 제를 설명하도록 구성된 데이터 구조체(data construct)를 지칭하고 설명할 수 있다. 즉, 입력 문제는 입력 문 제에 대한 최적화된 솔루션에 대한 요청을 동반하거나 구체화할 수 있다. 다양한 실시예들에서, 입력 문제는 제약된 최적화 문제이고, 입력 문제는 다양한 정의된 제약들을 충족시키는 최적화된 또는 최적의 솔루션에 의해 해결될 수 있다. 입력 문제는 다양한 제약들 및 다른 문제 특징들(예를 들어, 문제 유형, 최적화될 자산들 (assets), 자산별 파라미터들/속성들(properties)/특성들(characteristics), 최적화 이득 임계치(들), 최대 실 행 반복 카운트(들))을 정의할 수 있다. 본 명세서에서 설명되고 제약된 최적화 문제들인 입력 문제들의 예들 은 외판원 문제(traveling salesman problem)(복수의 위치 사이의 최소 거리의 경로인 최적화된 솔루션을 찾는 문제) 및 자산 스케줄링/분배(distribution) 문제들(상이한 위치들 및/또는 시간들에 대한 자산들의 스케줄 및/ 또는 분배인 최적화된 솔루션을 찾는 문제)를 포함한다. 입력 문제는 다항식 시간 알고리즘으로 풀 수 있는 다 항식 문제 또는 다항식 시간에 다양한 솔루션들의 정확성(correctness)을 체크하여 풀 수 있는 비결정론적 다항 식 문제일 수 있다. 용어 \"문제 유형(problem type)\"은 입력 문제의 분류를 설명하도록 구성되는 데이터 구조체를 지칭하고 설명할 수 있으며, (예를 들어, 클라이언트 컴퓨팅 엔티티의 최종 사용자에 의해 제공되는 특징들로부터의) 입력 문제 의 문제 특징들에 의해 결정될 수 있다. 다양한 실시예들에서, 입력 문제의 문제 유형은 입력 문제의 문제 특 징으로서 정의될 수 있다. 일반적으로, 문제 유형은 문제의 목적을 설명할 수 있으며, 그 예들은 최소 거리의 경로의 결정(외판원 문제와 같은 경로 찾기(pathfinding) 문제 유형) 또는 최대 수익(maximal return)을 위한 투자들의 분배의 결정(투자 문제와 같은 자산 분배 문제 유형)을 포함한다. 다양한 사례들에서, 문제 유형은 입력 문제에 필요한 솔루션을 설명하거나 특성화할 수 있다. 다양한 실시예들에서, 문제의 문제 유형은 임베딩 (embedding)들, 확률들, 원-핫 인코딩(one-hot encoding), 연관되거나 링크된 데이터 객체들, 기타 등등을 사용 하여 설명될 수 있다. 용어 \"유형 불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스 요청(type-agnostic problem solving application programming interface (API) request)\"은 입력 문제의 해결을 요청하는 클라우드 기반 다중 도메 인 솔버 시스템과 클라이언트 컴퓨팅 엔티티 사이의 통신을 설명하도록 구성된 데이터 구조체를 지칭하고 설명 할 수 있다. 다양한 실시예들에서, 클라우드 기반 다중 도메인 솔버 시스템은 유형 불가지론적 문제 API를 포 함하고, 유형 불가지론적 문제 해결 API를 통해 클라이언트 컴퓨팅 엔티티로부터 비롯되는 유형 불가지론적 문 제 해결 API 요청을 수신한다. 유형 불가지론적 문제 해결 API 요청은, 클라우드 기반 다중 도메인 솔버 시스 템에 의해 수신된 각각의 유형 불가지론적 문제 해결 API 요청이 특정 구성에서 다양한 데이터 필드들을 포함하 도록, 표준화된 구성을 가질 수 있으며, 각각의 데이터 필드는 특정 의미의 데이터를 정의한다. 다양한 실시예 들에서, 유형 불가지론적 문제 해결 API 요청은 데이터 구조, 데이터 객체, 기타 등등, 예컨대 벡터, 어레이 또 는 행렬로서 정의될 수 있다. 유형 불가지론적 문제 해결 API 요청은 유형 불가지론적 문제 해결 API 요청을 사용하여 임의의 문제 유형의 입력 문제들을 정의할 수 있다는 점에서 유형 불가지론적이다. 즉, 유형 불가지론적 문제 해결 API 요청은 클라우드 기반 다중 도메인 솔버 시스템에 의한 해결을 위해 임의의 문제 유형의 입 력 문제를 정의하는 데 사용될 수 있는 다양한 정적 데이터 필드들 및 다양한 동적 데이터 필드들을 포함한다. 다양한 실시예들에서, 하나 이상의 동적 데이터 필드는 입력 문제의 문제 유형에 의존하거나 조건부일 수 있다. 예를 들어, 하나 이상의 동적 데이터 필드는 외판원 문제이고/이거나 그와 실질적으로 유사한 입력 문제를 정의 하는 데 사용될 수 있는 반면, 동일한 동적 데이터 필드들은 자산 분배 문제이고/이거나 그와 실질적으로 유사 한 다른 입력 문제에 대해 사용되지 않을 수 있다. 일부 실시예들에서, 유형 불가지론적 문제 해결 API 요청에 의해 정의된 입력 문제의 문제 유형은 유형 불가지론적 문제 해결 API 요청의 특정 정적 데이터 필드에 의해 설 명된다. 다양한 사례들에서, 다수의 유형 불가지론적 문제 해결 API 요청은 클라우드 기반 다중 도메인 솔버 시스템에 의해 수신될 수 있고, 다수의 유형 불가지론적 문제 해결 API 요청은 각각 클라우드 기반 다중 도메인 솔버 시스템과 통신하는 상이한 클라이언트 컴퓨팅 엔티티들로부터 비롯될 수 있다. 다수의 유형 불가지론적 문제 해결 API 요청은 동시에 그리고/또는 실질적으로 동시에 수신될 수 있다. 용어 \"인바운드 문제 큐(inbound problem queue)\"는 클라우드 기반 다중 도메인 솔버 시스템에 의해 해결되어야 할 복수의 입력 문제를 식별 및/또는 설명하는 데이터스토어, 데이터 구조체, 데이터 구조, 데이터 객체, 행렬, 어레이, 벡터, 기타 등등을 지칭하고 설명할 수 있다. 다양한 사례들에서, 다수의 유형 불가지론적 문제 해결 API 요청은 클라우드 기반 다중 도메인 솔버 시스템에 의해 수신될 수 있고, 인바운드 문제 큐는 유형 불가지론 적 문제 해결 API 요청들에 의해 설명된 입력 문제들을 조직화할 수 있다. 다양한 실시예들에서, 인바운드 문 제 큐는 상이한 우선순위들을 갖는 다수의 입력 문제를 조직화하여, 예를 들어, 특정 입력 문제가 다른 입력 문 제 이전에 해결을 위해 처리될 수 있다. 일부 실시예들에서, 인바운드 문제 큐는 대응하는 유형 불가지론적 문 제 해결 API 요청이 클라우드 기반 다중 도메인 솔버 시스템에 의해 수신된 시간에 적어도 부분적으로 기초하여 다양한 입력 문제들을 조직화할 수 있다. 인바운드 문제 큐는, 일부 실시예들에서, 해결될 각각의 입력 문제 (다양한 문제 특징들을 포함함)를 개별적으로 정의하도록 구성될 수 있다. 다른 실시예들에서, 인바운드 문제 큐는 각각의 입력 문제 및/또는 연관된 유형 불가지론적 문제 해결 API 요청을 식별하고, 그에 링크하고, 참조 하는 것, 기타 등등을 하도록 구성될 수 있다. 용어 \"솔버 유형(solver type)\"은 문제를 해결하기 위한 또는 문제에 대한 솔루션을 결정하기 위한 알고리즘, 휴리스틱, 방법, 기타 등등의 유형을 설명하도록 구성되는 데이터 구조체를 지칭하고 설명할 수 있으며, 유형은 대응하는 문제의 문제 유형에 적어도 부분적으로 기초하여 결정될 수 있다. 입력 문제에 대한 솔루션은 각각이 상이한 정확도 및 상이한 효율을 갖는 솔루션을 제공하는 다수의 상이한 솔버 유형을 사용하여 결정될 수 있다 는 것을 알 수 있다. 외판원 입력 문제를 예시적인 예로서 참조하면, 무작위 대입(brute-force) 솔버 유형, 제 1-적합(first-fit) 솔버 유형, 최강-적합(strongest-fit) 솔버 유형, 타부-탐색(Tabu-search) 솔버 유형, 시뮬 레이티드-어닐링(simulated-annealing) 솔버 유형, 지연-수락(late-acceptance) 솔버 유형, 언덕 오르기(hill- climbing) 솔버 유형, 전략적 진동(strategic oscillation) 솔버 유형, 기타 등등을 사용하여 솔루션이 결정될 수 있다. 다항식 문제들의 경우, 다양한 솔버 유형들은 입력 문제를 해결하거나 문제에 대한 정확한 솔루션을 결정하기 위한 알고리즘들, 휴리스틱들, 방법들, 기타 등등을 설명할 수 있다. 비결정론적 다항식 문제들의 경 우, 다양한 솔버 유형들은 입력 문제에 대한 제안된 솔루션을 결정하고 입력 문제에 대해 제안된 솔루션의 \"정 확성\" 또는 정확도(accuracy)를 결정하기 위한 알고리즘들, 휴리스틱들, 방법들, 기타 등등을 설명할 수 있다. 용어 \"솔버 도메인(solver domain)\"은 솔버 유형들의 세트의 공통 특성을 설명하도록 구성된 데이터 구조체를 지칭하고 설명할 수 있다. 예를 들어, 일부 실시예들에서, 솔버 유형은 \"트럭 스케줄링\"일 수 있고, 솔버 도메 인은 \"스케줄링(scheduling)\"일 수 있다. 일부 실시예들에서, 솔버 도메인은 도메인별 솔버 유형들 각각에 의 해 결정된 최적화된 솔루션들에 적어도 부분적으로 기초하여 도메인별 솔버 유형들의 세트와 연관될 수 있다. 도메인별 솔버 유형들 각각에 의해 결정되는 최적화된 솔루션들은 형태가 유사하며 문제 유형에 대한 입력 문제 들을 해결하는 데 적용될 수 있다. 따라서, 문제 유형은 문제 유형의 입력 문제들을 해결하는 데 사용될 수 있 는 도메인별 솔버 유형들의 세트를 식별하기 위해 솔버 도메인에 매핑될 수 있다. 일례로, 솔버 도메인은 각각 이 최적화된 경로를 발견하는 것과 관련되는 도메인별 솔버 유형들의 세트와 연관될 수 있다. 용어 \"컴퓨팅 컨테이너(compute container)\"는 컴퓨터 실행 가능 명령어들의 인스턴스화 가능한 패키지, 번들, 이미지, 기타 등등을 설명하도록 구성된 데이터 구조체를 지칭하고 설명할 수 있다. 다양한 실시예들에 따르면, 컴퓨팅 컨테이너는 입력 문제에 대한 솔루션들을 결정하기 위한 특정 솔버 유형에 대한 컴퓨터 실행가 능 명령어들을 포함한다. 즉, 솔버 유형에 대응하는 컴퓨팅 컨테이너는 솔버 유형을 전자적으로 구체화 및/또 는 구현할 수 있다. 컴퓨팅 컨테이너는 솔버 유형을 구체화 및/또는 구현하기 위해 필요한 다양한 라이브러리 들, 종속성 데이터, 기타 등등을 추가적으로 포함할 수 있다. 컴퓨팅 컨테이너는 문제 제약들을 식별하고, 결정된 솔루션들이 최적화 동안 입력 문제의 문제 제약들을 충족시키는 것을 보장하도록 구성된 제약 매퍼 (constraint mapper)를 포함할 수 있다. 컴퓨팅 컨테이너는 클라우드 기반 다중 도메인 솔버 시스템 내에서 주 문에 기초하여 컴퓨팅 및 처리 자원들을 개별적으로 소비하는 컨테이너 인스턴스들로서 인스턴스화될 수 있다. 컴퓨팅 컨테이너들은 다양한 시스템들, 방법들, 아키텍처들, 기타 등등, 예컨대 도커(Docker) 등을 사용하여 정 의될 수 있다. \"컨테이너 인스턴스(container instance)\"라는 용어는 컴퓨팅 컨테이너에 의해 정의된 컴퓨터 실행가능 명령어 들의 실행을 포함하는 컴퓨팅 컨테이너의 인스턴스화를 설명하도록 구성된 데이터 구조체를 지칭하고 설명할 수 있다. 컴퓨팅 컨테이너에 대한 다수의 컨테이너 인스턴스는 실질적으로 병렬로 실행될 수 있는데; 즉, 컴퓨팅 컨테이너는 두 번 이상 인스턴스화될 수 있다. 컨테이너 인스턴스는 클라우드 기반 다중 도메인 솔버 시스템 내에서 실행될 수 있으므로 주문에 기초하여 컴퓨팅 및 처리 자원들을 사용할 수 있다. 클라우드 기반 다중 도 메인 솔버 시스템은 상이한 문제들에 대한 솔루션들을 병렬로 그리고/또는 실질적으로 동시에 결정하기 위해 상 이한 솔버 유형들에 대응하는 상이한 컴퓨팅 컨테이너들의 컨테이너 인스턴스들을 포함할 수 있다. 다양한 실 시예들에서, 컴퓨팅 컨테이너의 다양한 컨테이너 인스턴스들은 상이한 입력 문제들에 대한 솔루션들을 결정하기 위해 사용될 수 있다. 예를 들어, 시뮬레이티드-어닐링 솔버 유형의 컴퓨팅 컨테이너의 경우, 제1 컨테이너 인 스턴스는 제1 외판원 입력 문제에 대한 솔루션을 결정하기 위해 실행될 수 있는 한편, 제2 컨테이너 인스턴스는 제2 외판원 입력 문제에 대한 솔루션을 결정하기 위해 실행될 수 있다. 따라서, 상이한 컨테이너 인스턴스들로 서 여러 번 인스턴스화될 수 있는 컴퓨팅 컨테이너들로서의 상이한 솔버 유형들의 컨테이너화는, 다수의 입력 문제에 대한 솔루션들이 다수의 컨테이너 인스턴스에 의해 병렬로 결정될 수 있고/있거나 하나의 입력 문제에 대한 다수의 경쟁적인 솔루션이 다수의 컨테이너 인스턴스에 의해 병렬로 결정될 수 있기 때문에, 다양한 기술 적 이점들을 제공한다는 것을 이해할 것이다. 컴퓨팅 컨테이너의 컨테이너 인스턴스들의 카운트는 스케일링 업 및/또는 다운될 수 있으며, 이는 또한 클라우드 기반 다중 도메인 솔버 시스템 내에서 컴퓨팅 및 처리 자원들의 관리 및 사용을 개선하는 데 기술적 이점들을 제공한다. 컨테이너 인스턴스의 실행은 입력 문제에 대한 솔루션을 결정하기 위해 입력 문제의 다양한 문제 특징들(예를 들어, 파라미터들, 값들, 제약들)을 사용하는 것을 포함할 수 있으며, 이러한 문제 특징들은 인바운드 문제 큐, 입력 문제를 정의하는 유형 불가지론적 문제 해결 API 요청, 및/또는 클라우드 기반 다중 도메인 솔버 시스템의 저장 서브시스템으로부터 검색(retrieve), 수신, 기타 등등이 될 수 있다. 컨테이너 인스턴스의 실행은 컨테이 너 인스턴스와 연관된 컴퓨팅 컨테이너의 솔버 유형에 따라 입력 문제에 대한 솔루션을 반복적으로 결정하고 개 선하기 위해 다수의 실행 반복에 걸쳐 발생할 수 있다. 예를 들어, 다양한 솔버 유형들의 경우, 컴퓨팅 컨테이 너는 이전 실행 반복으로부터의 이전에 결정된 솔루션을 사용하여 후속 실행 반복에서 후속 솔루션을 결정할 수 있다. \"반복별 최적화 이득(per-iteration optimization gain)\"이라는 용어는 솔버 유형에 대응하는 컴퓨팅 컨테이너 의 컨테이너 인스턴스에 의해 결정된 솔루션들의 정확성을 향한 수렴 또는 접근의 척도(measure of the convergence or approach)를 설명하도록 구성된 데이터 구조체를 지칭하고 설명할 수 있다. 설명된 바와 같이, 특정 솔버 유형들에 대응하는 컴퓨팅 컨테이너들의 컨테이너 인스턴스들은 입력 문제에 대한 솔루션들을 반복적 으로 결정하기 위해 실행되며, 반복별 최적화 이득은 제1 실행 반복 동안 결정된 제1 솔루션과 제2(및 후속) 실 행 반복 동안 결정된 제2 솔루션 간의 차이를 설명할 수 있고/있거나, 설명하는 값일 수 있다. 비결정론적 다 항식 문제들과 같은 다양한 사례들에서, 반복별 최적화 이득은 제1 솔루션과 비교되는 제2 솔루션의 정확성의 향상(또는 악화)을 설명할 수 있다. 다양한 실시예들에서, 컨테이너 인스턴스의 실행 동안의 반복별 최적화 이 득은 구성 가능한 이득 임계치와 비교되고, 반복별 최적화 이득이 구성 가능한 이득 임계치를 충족시키지 않는 경우, 컨테이너 인스턴스의 실행은 중단되거나 취소된다. 예를 들어, 컨테이너 인스턴스에 의해 결정된 연속된 2개의 솔루션 간의 차이가 작고 구성 가능한 이득 임계치보다 작으면, 컨테이너 인스턴스에 의해 결정된 솔루션 들이 수렴된 것으로 결정될 수 있다. 이러한 예에서, 컨테이너 인스턴스의 실행은 중단될 수 있으며, 컨테이너 인스턴스에 의해 결정된 마지막 솔루션이 컨테이너 출력으로서 제공될 수 있다. 마찬가지로, 컨테이너 인스턴 스에 의해 결정된 2개의 연속된 솔루션 사이의 차이가 증가하고 구성 가능한 이득 임계치보다 크다면, 컨테이너 인스턴스에 의해 결정된 솔루션들이 발산되고 있는 것으로 결정될 수 있다. 이러한 예에서, 컨테이너 인스턴스 의 실행은 중단 및/또는 종료될 수 있으며, 컴퓨팅 및 처리 자원들은 다양한 실시예들에서 다른 컨테이너 인스 턴스들로 전환될 수 있다. 다양한 실시예들에서, 구성 가능한 이득 임계치는 솔버 유형의 속성 또는 파라미터, 솔버 유형에 대응하는 컴퓨팅 컨테이너의 속성 또는 파라미터, 및/또는 컴퓨팅 컨테이너의 컨테이너 인스턴스의 속성 또는 파라미터로서 정의될 수 있다. 구성 가능한 이득 임계치는 추가적으로 또는 대안적으로 입력 특징의문제 특징으로서 정의될 수 있다. \"서버리스 컨테이너 관리 엔진(serverless container management engine)\"이라는 용어는 각각이 클라우드 기반 다중 도메인 솔버 시스템 내의 솔버 유형에 대응하는 컴퓨팅 컨테이너들의 컨테이너 인스턴스들의 실행을 관리 하도록 구성된 데이터 엔티티를 지칭할 수 있다. 그렇게 함에 있어서, 서버리스 컨테이너 관리 엔진은 컨테이 너 인스턴스의 실행을 모니터링할 수 있다. 다양한 실시예들에서, 서버리스 컨테이너 관리 엔진은 각각의 실행 반복에서 컨테이너 인스턴스에 의해 결정되는 솔루션의 반복별 최적화 이득을 결정하도록 구성되고, 반복별 최 적화 이득을 하나 이상의 구성 가능한 이득 임계치와 비교하는 것에 적어도 부분적으로 기초하여 컨테이너 인스 턴스의 실행을 중단 및/또는 종료하도록 구성된다. 일반적으로, 서버리스 컨테이너 관리 엔진은 다양한 요인들 (앞서 언급한 반복별 최적화 이득들을 포함함)에 적어도 부분적으로 기초하여 컨테이너 인스턴스들의 카운트를 스케일링(업 또는 다운)하도록 구성된다. 예를 들어, 서버리스 컨테이너 관리 엔진은 클라우드 기반 다중 도메 인 솔버 시스템 내에서의 컴퓨팅 및 처리 자원들의 가용성, 현재 요청 수요(request demand)(예를 들어, 인바운 드 문제 큐에 의해 식별된 문제들의 카운트), 특정 입력 문제에 대한 다수의 솔루션의 발산(divergence), 기타 등등에 적어도 부분적으로 기초하여 (예를 들어, 일부 컨테이너 인스턴스들을 중단 및/또는 종료함으로써) 클라 우드 기반 다중 도메인 솔버 시스템 내에서 현재 그리고 동시에 실행되는 컨테이너 인스턴스들의 카운트를 감소 시킬 수 있다. 마찬가지로, 서버리스 컨테이너 관리 엔진은 유사한 이유들로 클라우드 기반 다중 도메인 솔버 시스템 내에서 현재 그리고 동시에 실행되는 컨테이너 인스턴스들의 카운트를 증가시킬 수 있다. 다양한 실시 예들에서, 서버리스 컨테이너 관리 엔진은 컴퓨팅 컨테이너의 새로운 컨테이너 인스턴스를 생성하도록 구성되며, 그렇게 함에 있어서, 컴퓨팅 컨테이너에 대한 데이터에 액세스하도록 구성될 수 있다. 그리하여, 일 반적으로, 서버리스 컨테이너 관리 엔진은 컴퓨팅 및 처리 자원들을 다양한 컨테이너 인스턴스들에 할당, 배정, 분배, 기타 등등을 하도록 구성될 수 있다. 본 개시의 다양한 실시예들에 따라 사용될 수 있는 예시적인 서버 리스 컨테이너 관리 엔진들은 AWS(Amazon Web Services) 파게이트(Fargate) 및 쿠버네티스(Kubernetes)를 포함 (하지만, 이에 한정되지 않음)한다. 용어 \"컴퓨팅 및 처리 자원들(computing and processing resources)\"은 일반적으로 컴퓨터 실행가능 명령어들 의 처리 및 실행을 위한 하나 이상의 프로세서, 메모리, 네트워크 인터페이스, 기타 등등 및 이들의 부분들과 같은 컴퓨팅 및 처리 컴포넌트들을 지칭하고 설명할 수 있다. 예를 들어, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티 의 프로세서, 메모리, 및 네트워크 인터페이스는 컨테이너 인스턴스를 실행하기 위한 컴퓨팅 및 처리 자원들일 수 있다. 컴퓨팅 및 처리 자원들의 사용 및 이용은 다양한 컴퓨터 실행가능 명령어들(예를 들어, 컨테이너 인 스턴스들)에 대해 측정, 모니터링, 할당, 분배, 기타 등등이 될 수 있다. 프로세서가 중앙 처리 유닛(CPU)인 예들에서, CPU 시간은 상이한 컨테이너 인스턴스들 간에 분할되고 분배될 수 있다. 마찬가지로, 자원 이용 또 는 사용은 컨테이너 인스턴스에 의해 예약되거나 사용되는 메모리의 양을 포함할 수 있으며, 이러한 자원 이용 또는 사용을 모니터링하는 것은 잠재적인 메모리 누출들을 찾는 것(locating)을 포함할 수 있다. \"아웃바운드 솔루션 큐(outbound solution queue)\"라는 용어는 복수의 입력 문제에 대응하는 복수의 문제 출력 을 식별, 설명 및/또는 저장하는 데이터스토어, 데이터 구조체, 데이터 구조, 데이터 객체, 행렬, 어레이, 벡터, 기타 등등을 지칭하고 설명할 수 있다. 아웃바운드 솔루션 큐의 각각의 문제 출력은 인바운드 문제 큐의 입력 문제에 대응할 수 있고, 대응하는 입력 문제에 대한 솔루션을 포함할 수 있다. 다양한 실시예들에서, 입 력 문제는 아웃바운드 솔루션 큐에 대응하는 문제 출력의 추가에 응답하여 인바운드 문제 큐로부터 제거될 수 있으며, 이에 따라 입력 문제가 핸들링되었음을 나타낼 수 있다. 아웃바운드 솔루션 큐는 인바운드 문제 큐의 입력 문제들의 조직화 및/또는 문제 출력이 생성된 시간에 적어도 부분적으로 기초하여 복수의 문제 출력을 조 직화할 수 있다. 다양한 실시예들에서, 아웃바운드 솔루션 큐의 각각의 문제 출력은 문제 출력이 송신되어야 하는 특정 클라이언트 컴퓨팅 엔티티와 연관되고/되거나 그에 의해 식별된다. \"유형 불가지론적 문제 솔루션 API 응답(type-agnostic problem solution API response)\"이라는 용어는 클라우 드 기반 다중 도메인 솔버 시스템과 클라이언트 컴퓨팅 엔티티 간의 통신을 설명하도록 구성된 데이터 구조체를 지칭하고 설명할 수 있다. 특히, 유형 불가지론적 문제 솔루션 API 응답은 클라우드 기반 다중 도메인 솔버 시 스템에 의해 수신하고 클라이언트 컴퓨팅 엔티티로부터 비롯되는 유형 불가지론적 문제 해결 API 요청에 응답할 수 있다. 유형 불가지론적 문제 솔루션 API 응답은 유형 불가지론적 문제 해결 API 요청에 의해 정의된 입력 문제에 대한 솔루션을 포함하는 문제 출력을 포함할 수 있다. 다수의 유형 불가지론적 문제 솔루션 API 응답은 아웃바운드 솔루션 큐에 따라 클라우드 기반 다중 도메인 솔버 시스템에 의해 송신될 수 있다. 예를 들어, 유 형 불가지론적 문제 솔루션 API 응답들은 아웃바운드 솔루션 큐 내의 문제 출력들의 조직화에 따라 순차적으로 송신될 수 있다. 다양한 사례들에서, 유형 불가지론적 문제 솔루션 API 응답은 비동기적일 수 있다. 상이한문제들에 대한 솔루션들이 상이한 시간량들을 필요할 수 있으므로, 제1 유형 불가지론적 문제 해결 API 요청을 수신하는 것과 제1 유형 불가지론적 문제 솔루션 API 응답을 송신하는 것 사이의 제1 기간은 제2 유형 불가지론 적 문제 해결 API 요청을 수신하는 것과 제2 유형 불가지론적 문제 솔루션 API 응답을 송신하는 것 사이의 제2 기간과 다를 수 있다. \"서버리스 요청 관리 엔진(serverless request management engine)\"이라는 용어는 클라우드 기반 다중 도메인 솔버 시스템 내에서 유형 불가지론적 문제 해결 API 요청들의 수신 및 유형 불가지론적 문제 솔루션 API 응답들 의 송신을 관리하도록 구성된 데이터 엔티티를 지칭하고 설명할 수 있다. 서버리스 요청 관리 엔진은 유형 불 가지론적 문제 해결 API 요청들의 수신 및 처리와 유형 불가지론적 문제 솔루션 API 응답들의 송신이 동적인 또 는 가변적인 양의 컴퓨팅 및 처리 자원들을 소비할 수 있다는 점에서 서버리스일 수 있다. 다수의 유형 불가지 론적 문제 해결 API 요청들은 서버리스 요청 관리 엔진에서 동시에 그리고/또는 일정 기간(a period of time) 내에 수신될 수 있으며, 서버리스 요청 관리 엔진은 다수의 유형 불가지론적 문제 해결 API 요청에 의해 정의된 입력 문제들의 핸들링(예를 들어, 솔루션의 결정)을 위해 인바운드 문제 큐와 통신할 수 있다. 한편, 서버리스 요청 관리 엔진은 아웃바운드 솔루션 큐와 통신하여 다수의 유형 불가지론적 문제 해결 API 요청에 의해 정의된 입력 문제들에 대응하는 문제 솔루션들을 검색하도록 구성된다. 서버리스 요청 관리 엔진은 아웃바운드 솔루션 큐로부터의 문제 출력들을 포함하는 다수의 유형 불가지론적 문제 해결 API 요청에 대한 다수의 유형 불가지론 적 문제 솔루션 API 응답을 생성하고 송신할 수 있다. 다양한 실시예들에서, 클라우드 기반 다중 도메인 솔버 시스템은 각각이 가용성 구역에 대응하고 클라이언트 컴퓨팅 엔티티들의 특정 코호트(cohort)와의 통신, 특정 기간 내의 통신, 특정 영역에 위치하는 클라이언트 컴퓨팅 엔티티들과의 통신, 기타 등등을 핸들링하도록 구성 된 하나 이상의 서버리스 요청 관리 엔진을 포함한다. 하나 이상의 서버리스 요청 관리 엔진의 사용은 유리하 게 최소한의 지연으로 클라이언트 컴퓨팅 엔티티들의 큰 모집단(population) 간의 통신(예를 들어, 유형 불가지 론적 문제 해결 API 요청들의 수신, 유형 불가지론적 문제 솔루션 API 응답들의 송신)의 효율적인 핸들링을 가 능하게 한다. III. 컴퓨터 프로그램 제품들, 방법들 및 컴퓨팅 엔티티들 본 발명의 실시예들은 제조 물품들을 포함하는 컴퓨터 프로그램 제품들을 포함하는 다양한 방식들로 구현될 수 있다. 이러한 컴퓨터 프로그램 제품들은 예를 들어 소프트웨어 객체들, 방법들, 데이터 구조들 등을 포함하는 하나 이상의 소프트웨어 컴포넌트를 포함할 수 있다. 소프트웨어 컴포넌트는 다양한 프로그래밍 언어들 중 임 의의 것으로 코딩될 수 있다. 예시적인 프로그래밍 언어는 특정 하드웨어 아키텍처 및/또는 운영 체제 플랫폼 과 연관된 어셈블리 언어와 같은 하위 레벨 (lower-level) 프로그래밍 언어일 수 있다. 어셈블리 언어 명령어 들을 포함하는 소프트웨어 컴포넌트는 하드웨어 아키텍처 및/또는 플랫폼에 의해 실행되기 전에 어셈블러에 의 한 실행 가능 기계 코드로의 변환을 필요로 할 수 있다. 다른 예시적인 프로그래밍 언어는 다수의 아키텍처에 걸쳐 이식가능(portable)할 수 있는 상위 레벨(higher-level)의 프로그래밍 언어일 수 있다. 상위 레벨의 프로 그래밍 언어 명령어들을 포함하는 소프트웨어 컴포넌트는 실행 전에 인터프리터(interpreter) 또는 컴파일러 (compiler)에 의한 중간 표현(intermediate representation)으로의 변환을 필요로 할 수 있다. 프로그래밍 언어들의 다른 예들은 매크로 언어, 쉘(shell) 또는 커맨드 언어, 작업 제어(job control) 언어, 스 크립트 언어, 데이터베이스 쿼리(query) 또는 탐색(search) 언어 및/또는 보고서 작성 언어를 포함하지만, 이에 한정되는 것은 아니다. 하나 이상의 예시적인 실시예에서, 프로그래밍 언어들의 전술한 예들 중 하나에서의 명 령어들을 포함하는 소프트웨어 컴포넌트는 먼저 다른 형태로 변환될 필요 없이 운영 체제 또는 다른 소프트웨어 컴포넌트에 의해 직접 실행될 수 있다. 소프트웨어 컴포넌트는 파일 또는 다른 데이터 저장 구조체로서 저장될 수 있다. 유사한 유형의 또는 기능적으로 관련된 소프트웨어 컴포넌트들은, 예를 들어 특정 디렉토리, 폴더 또 는 라이브러리에서와 같이 함께 저장될 수 있다. 소프트웨어 컴포넌트들은 정적이거나(예를 들어, 미리 확립되 거나 고정됨) 또는 동적일 수 있다(예를 들어, 실행시에 생성되거나 수정됨). 컴퓨터 프로그램 제품은 애플리케이션들, 프로그램들, 프로그램 모듈들, 스크립트들, 소스 코드, 프로그램 코드, 객체 코드, 바이트 코드, 컴파일된 코드, 해석된 코드, 기계 코드, 실행 가능한 명령어들, 기타 등등(본 명세서에서는 실행가능 명령어들, 실행을 위한 명령어들, 컴퓨터 프로그램 제품들, 프로그램 코드, 및/또는 본 명세서에서 상호 교환가능하게 사용되는 유사한 용어들로도 지칭됨)을 저장하는 비일시적 컴퓨터 판독 가능 저 장 매체를 포함할 수 있다. 이러한 비일시적 컴퓨터 판독가능 저장 매체들은 모든 컴퓨터 판독가능 매체들(휘 발성 및 비휘발성 매체들을 포함함)을 포함한다. 일 실시예에서, 비휘발성 컴퓨터 판독가능 저장 매체는 플로피 디스크, 플렉서블 디스크, 하드 디스크, 솔리드 스테이트 저장소(solid-state storage, SSS)(예를 들어, 솔리드 스테이트 드라이브(SSD), 솔리드 스테이트 카드 (SSC), 솔리드 스테이트 모듈(SSM)), 엔터프라이즈 플래시 드라이브(enterprise flash drive), 자기 테이프, 또는 임의의 다른 비일시적 자기 매체, 기타 등등을 포함할 수 있다. 비휘발성 컴퓨터 판독가능 저장 매체는 또한 펀치 카드(punch card), 종이 테이프, 광학 마크 시트(또는 구멍들의 패턴들 또는 다른 광학적으로 인식 가능한 표시를 갖는 임의의 다른 물리적 매체), 컴팩트 디스크 판독 전용 메모리(CD-ROM), 컴팩트 디스크 재기 입 가능(CD-RW), 디지털 다기능 디스크(DVD), 블루레이 디스크(BD), 임의의 다른 비일시적 광학 매체, 기타 등 등을 포함할 수 있다. 이러한 비휘발성 컴퓨터 판독가능 저장 매체는 또한 ROM(Read-Only Memory), PROM(Programmable Read-Only Memory), EPROM(Erasable Programmable Read-Only Memory), EEPROM(Electrically Erasable Programmable Read-Only Memory), 플래시 메모리(예를 들어, 직렬, NAND, NOR, 기타 등등), MMC(Multimedia Memory Card)들, SD(Secure Digital) 메모리 카드들, SmartMedia 카드들, CF(CompactFlash) 카드들, 메모리 스틱들, 기타 등등을 포함할 수 있다. 게다가, 비휘발성 컴퓨터 판독 가능 저장 매체는 또한 전도성 브리징 랜덤 액세스 메모리(conductive-bridging random access memory, CBRAM), 상 변화 랜덤 액세스 메모리(phase-change random access memory, PRAM), 강유전체 랜덤 액세스 메모리 (ferroelectric random-access memory, FeRAM), 비휘발성 랜덤 액세스 메모리(non-volatile random-access memory, NVRAM), 자기저항성 랜덤 액세스 메모리(magnetoresistive random-access memory, MRAM), 저항성 랜덤 액세스 메모리(resistive random-access memory, RRAM), 실리콘-산화물-질화물-산화물-실리콘 메모리(SONOS), 플로팅 접합 게이트 랜덤 액세스 메모리(floating junction gate random access memory, FJG RAM), Millipede 메모리, 레이스트랙(racetrack) 메모리 등을 포함할 수 있다. 일 실시예에서, 휘발성 컴퓨터 판독 가능 저장 매체는 RAM(Random Access Memory), DRAM(Dynamic Random Access Memory), SRAM(Static Random Access Memory), FPM DRAM(Fast Page Mode Dynamic Random Access Memory), EDO DRAM(Extended Data-Out Dynamic Random Access Memory), SDRAM(Synchronous Dynamic Random Access Memory), DDR SDRAM(Double Data Rate Synchronous Dynamic Random Access Memory), 더블 데이터 레이 트 유형 2 동기식 동적 랜덤 액세스 메모리(DDR2 SDRAM), 더블 데이터 레이트 유형 3 동기식 동적 랜덤 액세스 메모리(DDR3 SDRAM), 램버스 동적 랜덤 액세스 메모리(RDRAM), 트윈 트랜지스터 RAM(TTRAM), 사이리스터 RAM(T-RAM), 제로 커패시터(Z-RAM), 램버스 인라인 메모리 모듈(RIMM), 듀얼 인라인 메모리 모듈(DIMM), 단일 인라인 메모리 모듈(SIMM), 비디오 랜덤 액세스 메모리(VRAM), 캐시 메모리(다양한 레벨들을 포함함), 플래시 메모리, 레지스터 메모리, 기타 등등을 포함할 수 있다. 실시예들이 컴퓨터 판독가능 저장 매체를 사용하는 것으로 설명되는 경우, 다른 유형의 컴퓨터 판독가능 저장 매체들이 전술한 컴퓨터 판독가능 저장 매체들을 대체 하거나 그들에 더하여 사용될 수 있다는 것을 인식할 것이다. 이해되어야 하는 바와 같이, 본 발명의 다양한 실시예들은 또한 방법들, 장치들, 시스템들, 컴퓨팅 디바이스들, 컴퓨팅 엔티티들, 기타 등등으로 구현될 수 있다. 따라서, 본 발명의 실시예들은 특정 단계들 또는 동작들을 수행하기 위해 컴퓨터 판독 가능 저장 매체에 저장된 명령어들을 실행하는 장치, 시스템, 컴퓨팅 디바이스, 컴 퓨팅 엔티티, 기타 등등의 형태를 취할 수 있다. 따라서, 본 발명의 실시예들은 또한 완전한 하드웨어 실시예, 완전한 컴퓨터 프로그램 제품 실시예, 및/또는 컴퓨터 프로그램 제품들과 특정 단계들 또는 동작들을 수행하는 하드웨어의 조합을 포함하는 실시예의 형태를 취할 수 있다. 이하에서 본 발명의 실시예들은 블록도들 및 흐름도 예시들을 참조하여 설명된다. 따라서, 블록도들 및 흐름도 예시들의 각각의 블록은 실행을 위해 컴퓨터 판독 가능 저장 매체 상에서 명령어들, 동작들, 단계들, 및 상호 교환가능하게 사용되는 유사한 단어들(예를 들어, 실행 가능한 명령어들, 실행을 위한 명령어들, 프로그램 코드, 기타 등등)을 실행하는 컴퓨터 프로그램 제품, 완전한 하드웨어 실시예, 하드웨어와 컴퓨터 프로그램 제 품들의 조합, 및/또는 장치들, 시스템들, 컴퓨팅 디바이스들, 컴퓨팅 엔티티들, 기타 등등의 형태로 구현될 수 있다는 것이 이해되어야 한다. 예를 들어, 코드의 검색, 로딩 및 실행은 한 번에 하나의 명령어가 검색, 로드 및 실행되도록 순차적으로 수행될 수 있다. 일부 예시적인 실시예들에서, 검색, 로딩, 및/또는 실행은 다수의 명령어들이 검색되고, 로딩되고/되거나, 함께 실행되도록 병렬로 수행될 수 있다. 따라서, 이러한 실시예들은 블록도들 및 흐름도 예시들에 지정된 단계들 또는 동작들을 수행하는 특별히 구성된 기계들을 생성할 수 있다. 따라서, 블록도들 및 흐름도 예시들은 지정된 명령어들, 동작들 또는 단계들을 수행하기 위한 실시예들의 다양 한 조합들을 지원한다. 본 개시의 실시예들은 제조 물품들을 포함하는 컴퓨터 프로그램 제품들을 포함하는 다양한 방식들로 구현될 수 있다. 이러한 컴퓨터 프로그램 제품들은, 예를 들어 소프트웨어 객체들, 방법들, 데이터 구조들 등을 포함하는 하나 이상의 소프트웨어 컴포넌트를 포함할 수 있다. 소프트웨어 컴포넌트는 다양한 프로그래밍 언어들 중 임의의 것으로 코딩될 수 있다. 예시적인 프로그래밍 언어는 특정 하드웨어 프레임워크 및/또는 운영 체제 플랫 폼과 연관된 어셈블리 언어와 같은 하위 레벨 프로그래밍 언어일 수 있다. 어셈블리 언어 명령어들을 포함하는 소프트웨어 컴포넌트는 하드웨어 프레임워크 및/또는 플랫폼에 의해 실행되기 전에 어셈블러에 의한 실행 가능 기계 코드로의 변환을 필요로 할 수 있다. 다른 예시적인 프로그래밍 언어는 다수의 프레임워크에 걸쳐 이식 가능할 수 있는 상위 레벨의 프로그래밍 언어일 수 있다. 상위 레벨의 프로그래밍 언어 명령어들을 포함하는 소프트웨어 컴포넌트는 실행 전에 인터프리터 또는 컴파일러에 의한 중간 표현으로의 변환을 필요로 할 수 있다. 프로그래밍 언어들의 다른 예들은 매크로 언어, 쉘 또는 커맨드 언어, 작업 제어 언어, 스크립트 언어, 데이터 베이스 쿼리 또는 탐색 언어 및/또는 보고서 작성 언어를 포함하지만, 이에 한정되는 것은 아니다. 하나 이상 의 실시예에서, 프로그래밍 언어들의 전술한 예들 중 하나에서의 명령어들을 포함하는 소프트웨어 컴포넌트는 먼저 다른 형태로 변환될 필요 없이 운영 체제 또는 다른 소프트웨어 컴포넌트에 의해 직접 실행될 수 있다. 소프트웨어 컴포넌트는 파일 또는 다른 데이터 저장 구조체로서 저장될 수 있다. 유사한 유형의 또는 기능적으 로 관련된 소프트웨어 컴포넌트들은, 예를 들어 특정 디렉토리, 폴더 또는 라이브러리에서와 같이 함께 저장될 수 있다. 소프트웨어 컴포넌트들은 정적이거나(예를 들어, 미리 확립되거나 고정됨) 또는 동적일 수 있다(예를 들어, 실행시에 생성되거나 수정됨). 컴퓨터 프로그램 제품은 애플리케이션들, 프로그램들, 프로그램 모듈들, 스크립트들, 소스 코드, 프로그램 코드, 객체 코드, 바이트 코드, 컴파일된 코드, 해석된 코드, 기계 코드, 실행 가능한 명령어들, 기타 등등(본 명세서에서는 실행가능 명령어들, 실행을 위한 명령어들, 컴퓨터 프로그램 제품들, 프로그램 코드, 및/또는 본 명세서에서 상호 교환가능하게 사용되는 유사한 용어들로도 지칭됨)을 저장하는 비일시적 컴퓨터 판독 가능 저 장 매체를 포함할 수 있다. 이러한 비일시적 컴퓨터 판독가능 저장 매체들은 모든 컴퓨터 판독가능 매체들(휘 발성 및 비휘발성 매체들을 포함함)을 포함한다. 일 실시예에서, 비휘발성 컴퓨터 판독가능 저장 매체는 플로피 디스크, 플렉서블 디스크, 하드 디스크, 솔리드 스테이트 저장소(SSS)(예를 들어, 솔리드 스테이트 드라이브(SSD), 솔리드 스테이트 카드(SSC), 솔리드 스테이 트 모듈(SSM)), 엔터프라이즈 플래시 드라이브, 자기 테이프, 또는 임의의 다른 비일시적 자기 매체, 기타 등등 을 포함할 수 있다. 비휘발성 컴퓨터 판독가능 저장 매체는 또한 펀치 카드, 종이 테이프, 광학 마크 시트(또 는 구멍들의 패턴들 또는 다른 광학적으로 인식 가능한 표시를 갖는 임의의 다른 물리적 매체), 컴팩트 디스크 판독 전용 메모리(CD-ROM), 컴팩트 디스크 재기입 가능(CD-RW), 디지털 다기능 디스크(DVD), 블루레이 디스크 (BD), 임의의 다른 비일시적 광학 매체, 기타 등등을 포함할 수 있다. 이러한 비휘발성 컴퓨터 판독가능 저장 매체는 또한 ROM(Read-Only Memory), PROM(Programmable Read-Only Memory), EPROM(Erasable Programmable Read-Only Memory), EEPROM(Electrically Erasable Programmable Read-Only Memory), 플래시 메모리(예를 들 어, 직렬, NAND, NOR, 기타 등등), MMC(Multimedia Memory Cards)들, SD(Secure Digital) 메모리 카드들, SmartMedia 카드들, CF(CompactFlash) 카드들, 메모리 스틱들, 기타 등등을 포함할 수 있다. 게다가, 비휘발성 컴퓨터 판독가능 저장 매체는 또한 전도성 브리징 랜덤 액세스 메모리(CBRAM), 상변화 랜덤 액세스 메모리 (PRAM), 강유전체 랜덤 액세스 메모리(FeRAM), 비휘발성 랜덤 액세스 메모리(NVRAM), 자기저항성 랜덤 액세스 메모리(MRAM), 저항성 랜덤 액세스 메모리(RRAM), 실리콘-산화물-질화물-산화물-실리콘 메모리(SONOS), 플로팅 접합 게이트 랜덤 액세스 메모리(FJG RAM), Millipede 메모리, 레이스트랙 메모리, 기타 등등을 포함할 수 있다. 일 실시예에서, 휘발성 컴퓨터 판독가능 저장 매체는 RAM(Random Access Memory), DRAM(Dynamic Random Access Memory), SRAM(Static Random Access Memory), FPM DRAM(Fast Page Mode Dynamic Random Access Memory), EDO DRAM(Extended Data-Out Dynamic Random Access Memory), SDRAM(Synchronous Dynamic Random Access Memory), DDR SDRAM(Double Data Rate Synchronous Dynamic Random Access Memory), 더블 데이터 레이트 유형 2 동기식 동적 랜덤 액세스 메모리(DDR2 SDRAM), 더블 데이터 레이트 유형 3 동기식 동적 랜덤 액세스 메모리(DDR3 SDRAM), 램버스 동적 랜덤 액세스 메모리(RDRAM), 트윈 트랜지스터 RAM(TTRAM), 사이리스터 RAM(T-RAM), 제로 커패시터(Z-RAM), 램버스 인라인 메모리 모듈(RIMM), 듀얼 인라인 메모리 모듈(DIMM), 단일 인라인 메모리 모듈 (SIMM), 비디오 랜덤 액세스 메모리(VRAM), 캐시 메모리(다양한 레벨들을 포함함), 플래시 메모리, 레지스터 메 모리, 기타 등등을 포함할 수 있다. 실시예들이 컴퓨터 판독가능 저장 매체를 사용하는 것으로 설명되는 경우, 다른 유형의 컴퓨터 판독가능 저장 매체들이 전술한 컴퓨터 판독가능 저장 매체들을 대체하거나 그들에 더하여 사용될 수 있다는 것을 인식할 것이다. 이해되어야 하는 바와 같이, 본 개시의 다양한 실시예들은 또한 방법들, 장치들, 시스템들, 컴퓨팅 디바이스들, 컴퓨팅 엔티티들. 기타 등등으로 구현될 수 있다. 따라서, 본 개시의 실시예들은 특정 단계들 또는 동작들을 실행하기 위해 컴퓨터 판독가능 저장 매체에 저장된 명령어들을 실행하는 장치, 시스템, 컴퓨팅 디바이스, 컴퓨 팅 엔티티, 기타 등등의 형태를 취할 수 있다. 따라서, 본 개시의 실시예들은 또한 완전한 하드웨어 실시예, 완전한 컴퓨터 프로그램 제품 실시예, 및/또는 컴퓨터 프로그램 제품들과 특정 단계들 또는 동작들을 실행하는 하드웨어의 조합을 포함하는 실시예의 형태를 취할 수 있다. 이하에서 본 개시의 실시예들은 블록도들 및 흐름도 예시들을 참조하여 설명된다. 따라서, 블록도들 및 흐름도 예시들의 각각의 블록은 실행을 위해 컴퓨터 판독가능 저장 매체 상에서 명령어들, 동작들, 단계들, 및 상호 교 환가능하게 사용되는 유사한 단어들(예를 들어, 실행 가능한 명령어들, 실행을 위한 명령어들, 프로그램 코드, 기타 등등)을 실행하는 컴퓨터 프로그램 제품, 완전한 하드웨어 실시예, 하드웨어와 컴퓨터 프로그램 제품들의 조합, 및/또는 장치들, 시스템들, 컴퓨팅 디바이스들, 컴퓨팅 엔티티들, 기타 등등의 형태로 구현될 수 있다는 것이 이해되어야 한다. 예를 들어, 코드의 검색, 로딩 및 실행은 한 번에 하나의 명령어가 검색, 로드 및 실행 되도록 순차적으로 실행될 수 있다. 일부 예시적인 실시예들에서, 검색, 로딩, 및/또는 실행은 다수의 명령어 들이 검색되고, 로딩되고/되거나, 함께 실행되도록 병렬로 실행될 수 있다. 따라서, 이러한 실시예들은 블록도 들 및 흐름도 예시들에 지정된 단계들 또는 동작들을 실행하는 특별히 구성된 기계들을 생성할 수 있다. 따라 서, 블록도들 및 흐름도 예시들은 지정된 명령어들, 동작들 또는 단계들을 실행하기 위한 실시예들의 다양한 조 합들을 지원한다. IV. 예시적인 시스템 프레임워크 도 1은 컨테이너화된 클라우드 기반(예를 들어, 서버리스) 방식으로 입력 문제들에 대한 최적화된 솔루션들을 결정하기 위한 예시적인 아키텍처의 개략도이다. 아키텍처는 유형 불가지론적 문제 해결 API 요청들 을 수신하고, 유형 불가지론적 문제 해결 API 요청들에 의해 정의된 입력 문제들에 대한 솔루션들을 결정하는 솔버 유형들에 대응하는 컴퓨팅 컨테이너들의 컨테이너 인스턴스들의 실행을 관리하고, 유형 불가지론적 솔루션 API 응답들을 통해 입력 문제들에 대한 최적화된 솔루션들을 포함하는 문제 출력들을 제공하도록 구성되는 클라 우드 기반 다중 도메인 솔버 시스템을 포함한다. 다양한 실시예들에서, 클라우드 기반 다중 도메인 솔버 시스템은 컴퓨팅 및 처리 자원들의 가용성 및 수신된 유형 불가지론적 문제 해결 API 요청들의 수를 포함 하는 다양한 요인들에 적어도 부분적으로 기초하여 실행을 거치는 컨테이너 인스턴스들의 카운트를 스케일링한 다. 예를 들어, 클라우드 기반 다중 도메인 솔버 시스템은 실행 중인 컨테이너 인스턴스에 대해 컴퓨팅 및 처리 자원들을 배정, 증가, 할당, 기타 등등을 할 수 있고/있거나, 실행 중인 컨테이너 인스턴스에 대해 컴 퓨팅 및 처리 자원들을 제한, 감소, 차단(cut off), 기타 등등을 할 수 있다. 다양한 실시예들에서, 클라우드 기반 다중 도메인 솔버 시스템은 하나 이상의 통신 네트워크를 사용하여 복수의 클라이언트 컴퓨팅 엔티티와 통신한다. 통신 네트워크들의 예들은 예를 들어, 유선 또는 무선 근 거리 네트워크(LAN), 개인 영역 네트워크(PAN), 도시 영역 네트워크(MAN), 광역 네트워크(WAN) 등을 포함하는 임의의 유선 또는 무선 통신 네트워크뿐만 아니라, 이를 구현하는 데 필요한 임의의 하드웨어, 소프트웨어 및/ 또는 펌웨어(예를 들어, 네트워크 라우터들, 기타 등등과 같은)를 포함한다. 클라우드 기반 다중 도메인 솔버 시스템은 이러한 통신 네트워크들을 통해 다양한 클라이언트 컴퓨팅 엔티티들로부터 비롯되는 유형 불가지론적 문제 해결 API 요청들을 수신할 수 있고, 추가로 이러한 통신 네트워크들을 통해 유형 불가지론적 문제 솔루션 API 응답들을 다양한 클라이언트 컴퓨팅 엔티티들로 송신할 수 있다. 클라우드 기반 다중 도메인 솔버 시스템은 클라우드 컴퓨팅 서버 컴퓨팅 엔티티 및 저장 서브시스템 을 포함할 수 있다. 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 입력 문제들에 대한 솔루션들을 결정하 기 위한 컨테이너 인스턴스들의 서버리스 실행을 위해 구성될 수 있다. 즉, 컨테이너 인스턴스의 실행은 클라 우드 컴퓨팅 서버 컴퓨팅 엔티티의 가변적인 양의 컴퓨팅 및 처리 자원들을 사용하여 달성될 수 있다. 이 와 관련하여, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 컴퓨팅 및 처리 자원들을 공유하는 하나 이상의 개별 컴퓨팅 엔티티의 추상화로서 이해될 수 있다. 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 입력 문제들을 정의 하는 유형 불가지론적 문제 해결 API 요청들을 수신하고 처리하도록 구성될 수 있다. 다양한 실시예들에서, 클 라우드 컴퓨팅 서버 컴퓨팅 엔티티는 (예를 들어, 컨테이너 인스턴스들로부터 컴퓨팅 및 처리 자원들을 공 급 및/또는 제거함으로써) 컨테이너 인스턴스들을 생성 및 종료하고, 컨테이너 인스턴스들로부터의 컨테이너 출 력들에 적어도 부분적으로 기초하여 문제 출력들을 생성하고, 유형 불가지론적 문제 솔루션 API 응답들을 통해 문제 출력들을 제공한다. 저장 서브시스템(storage subsystem, 108)은 컨테이너화된 클라우드 기반 방식으로 입력 문제들에 대한 최적화 된 솔루션들을 결정하기 위해 클라우드 컴퓨팅 서버 컴퓨팅 엔티티에 의해 사용되는 데이터를 저장하도록 구성될 수 있다. 예를 들어, 저장 서브시스템은 각각이 솔버 유형에 대응하고 컨테이너 인스턴스들로서 인스턴스화되고 실행되도록 구성된 컴퓨팅 컨테이너들을 저장하도록 구성된다. 저장 서브시스템은 스케줄 링 및 통신 관리를 위해 인바운드 문제 큐 및 아웃바운드 솔루션 큐를 저장하도록 더 구성될 수 있다. 저장 서 브시스템은 컴퓨터 네트워크(예컨대, 클라우드 기반 다중 도메인 솔버 시스템의 내부 통신 네트워 크)를 통해 연결된 다수의 분산 저장 유닛(distributed storage units)과 같은 하나 이상의 저장 유닛을 포함할 수 있다. 저장 서브시스템 내의 각각의 저장 유닛은 하나 이상의 데이터 자산 및/또는 하나 이상의 데이 터 자산의 계산된 속성들(computed properties)에 대한 하나 이상의 데이터 중 적어도 하나를 저장할 수 있다. 더욱이, 저장 서브시스템 내의 각각의 저장 유닛은 하드 디스크들, ROM, PROM, EPROM, EEPROM, 플래시 메 모리, MMC들, SD 메모리 카드들, 메모리 스틱들, CBRAM, PRAM, FeRAM, NVRAM, MRAM, RRAM, SONOS, FJG RAM, Millipede 메모리, 레이스트랙 메모리, 기타 등등을 포함하지만 이에 한정되지 않는 하나 이상의 비휘발성 저장 또는 메모리 매체를 포함할 수 있다. 예시적인 클라우드 컴퓨팅 서버 컴퓨팅 엔티티 도 2는 본 개시의 일 실시예에 따른 클라우드 컴퓨팅 서버 컴퓨팅 엔티티의 개략도를 제공한다. 일반적으 로, 용어들 컴퓨팅 엔티티, 컴퓨터, 엔티티, 디바이스, 시스템, 및/또는 본 명세서에서 상호 교환가능하게 사용 되는 유사한 단어들은, 예를 들어 하나 이상의 컴퓨터들, 컴퓨팅 엔티티들, 데스크탑들, 모바일 폰들, 태블릿들, 패블릿들(phablets), 노트북들, 랩탑들, 분산 시스템들, 키오스크들, 입력 터미널들, 서버들 또는 서 버 네트워크들, 블레이드들, 게이트웨이들, 스위치들, 처리 디바이스들, 처리 엔티티들, 셋톱 박스들, 릴레이들, 라우터들, 네트워크 액세스 포인트들, 기지국들 등 및/또는 본 명세서에 설명된 기능들, 동작들 및/ 또는 프로세스들을 실행하도록 적응된 디바이스들 또는 엔티티들의 임의의 조합을 지칭할 수 있다. 이러한 기 능들(functions), 동작들, 및/또는 프로세스들은, 예를 들어 송신, 수신, 작동(operating on), 처리, 디스플레 이, 저장, 결정, 창작(creating)/생성(generating), 모니터링, 평가, 비교, 및/또는 본 명세서에서 상호 교환가 능하게 사용되는 유사한 용어들을 포함할 수 있다. 일 실시예에서, 이러한 기능들, 동작들, 및/또는 프로세스 들은 데이터, 콘텐츠, 정보, 및/또는 본 명세서에서 상호 교환가능하게 사용되는 유사한 용어들에 대해 실행될 수 있다. 표시된 바와 같이, 일 실시예에서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 또한 예를 들어 송신, 수신, 작 용, 처리, 디스플레이, 저장, 기타 등등이 될 수 있는 데이터, 콘텐츠, 정보, 및/또는 본 명세서에서 상호 교환 가능하게 사용되는 유사한 용어들을 통신하는 등에 의해 다양한 컴퓨팅 엔티티들과 통신하기 위한 하나 이상의 통신 인터페이스를 포함할 수 있다. 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 하나 이상의 통신 인터 페이스를 통해 복수의 클라이언트 컴퓨팅 엔티티와 통신하여, 예를 들어 유형 불가지론적 문제 해결 API 요청들을 수신하고 유형 불가지론적 문제 솔루션 API 응답들을 송신할 수 있다. 도 2에 도시된 바와 같이, 일 실시예에서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는, 예를 들어 버스를 통해 클라우드 컴퓨팅 서버 컴퓨팅 엔티티 내의 다른 요소들과 통신하는 하나 이상의 처리 요소(프로세서, 처리 회로, 및/또는 본 명세서에서 상호 교환가능하게 사용되는 유사한 용어들로도 지칭됨)를 포함하거나 그와 통신할 수 있다. 이해되는 바와 같이, 처리 요소는 다수의 상이한 방식으로 구체화될 수 있다. 예를 들어, 처리 요소는 하나 이상의 복합 프로그래머블 로직 디바이스들(CPLDs), 마이크로프로세서들, 멀 티-코어 프로세서들, 공동처리 엔티티들(coprocessing entities), ASIPs(application-specific instruction- set processors), 마이크로컨트롤러들, 및/또는 컨트롤러들로서 구체화될 수 있다. 또한, 처리 요소는 하 나 이상의 다른 처리 디바이스 또는 회로로서 구체화될 수 있다. 회로라는 용어는 완전한 하드웨어 실시예 또 는 하드웨어와 컴퓨터 프로그램 제품들의 조합을 지칭할 수 있다. 따라서, 처리 요소는 집적 회로들, ASICs(application specific integrated circuits), FPGAs(field programmable gate arrays), PLAs(programmable logic arrays), 하드웨어 가속기들, 기타 회로, 기타 등등으로 구체화될 수 있다. 따라서, 이해되는 바와 같이, 처리 요소는 특정 용도를 위해 구성될 수 있거나, 휘발성 또는 비휘발성 매 체에 저장되거나 처리 요소에 의해 액세스 가능한 명령어들을 실행하도록 구성될 수 있다. 따라서, 하드 웨어 또는 컴퓨터 프로그램 제품들에 의해 또는 이들의 조합에 의해 구성되는지에 관계없이, 처리 요소는 그에 따라 구성될 때 본 개시의 실시예들에 따른 단계들 또는 동작들을 실행할 수 있을 수 있다. 일 실시예에서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 비휘발성 매체(비휘발성 저장소, 메모리, 메모리 저장소, 메모리 회로 및/또는 본 명세서에서 상호 교환가능하게 사용되는 유사한 용어들로도 지칭됨)를 더 포함하거나 그와 통신할 수 있다. 일 실시예에서, 비휘발성 저장소 또는 메모리는 하드 디스크들, ROM, PROM, EPROM, EEPROM, 플래시 메모리, MMC들, SD 메모리 카드들, 메모리 스틱들, CBRAM, PRAM, FeRAM, NVRAM, MRAM, RRAM, SONOS, FJG RAM, Millipede 메모리, 레이스트랙 메모리, 기타 등등을 포함하지만 이에 한정되지 않는 하 나 이상의 비휘발성 저장 또는 메모리 매체를 포함할 수 있다. 인식되는 바와 같이, 비휘발성 저장 또는 메모리 매체는 데이터베이스들, 데이터베이스 인스턴스들, 데이터베이 스 관리 시스템들, 데이터, 애플리케이션들, 프로그램들, 프로그램 모듈들, 스크립트들, 소스 코드, 객체 코드, 바이트 코드, 컴파일된 코드, 해석된 코드, 기계 코드, 실행 가능 명령어들, 기타 등등을 저장할 수 있다. 용 어 데이터베이스, 데이터베이스 인스턴스, 데이터베이스 관리 시스템, 및/또는 본 명세서에서 상호 교환가능하 게 사용되는 유사한 용어들은 계층적(hierarchical) 데이터베이스 모델, 네트워크 모델, 관계형(relational) 모 델, 엔티티-관계 모델, 객체 모델, 문서 모델, 시맨틱(semantic) 모델, 그래프 모델, 기타 등등과 같은 하나 이 상의 데이터베이스 모델을 사용하여 컴퓨터 판독가능 저장 매체에 저장되는 레코드들 또는 데이터의 집합을 지 칭할 수 있다. 일 실시예에서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 휘발성 매체(휘발성 저장소, 메모리, 메모리 저장 소, 메모리 회로 및/또는 본 명세서에서 상호 교환가능하게 사용되는 유사한 용어들로도 지칭됨)를 더 포함하거 나 그와 통신할 수 있다. 일 실시예에서, 휘발성 저장소 또는 메모리는 또한 RAM, DRAM, SRAM, FPM DRAM, EDO DRAM, SDRAM, DDR SDRAM, DDR2 SDRAM, DDR3 SDRAM, RDRAM, TTRAM, T-RAM, Z-RAM, RIMM, DIMM, SIMM, VRAM, 캐 시 메모리, 레지스터 메모리, 기타 등등을 포함하지만 이에 한정되지 않는 하나 이상의 휘발성 저장 또는 메모 리 매체를 포함할 수 있다. 인식되는 바와 같이, 휘발성 저장 또는 메모리 매체는, 예를 들어 처리 요소에 의해 실행되는 데이터베이 스들, 데이터베이스 인스턴스들, 데이터베이스 관리 시스템들, 데이터, 애플리케이션들, 프로그램들, 프로그램 모듈들, 스크립트들, 소스 코드, 객체 코드, 바이트 코드, 컴파일된 코드, 해석된 코드, 기계 코드, 실행 가능 한 명령어들, 기타 등등의 적어도 부분들을 저장하는 데 사용될 수 있다. 따라서, 데이터베이스들, 데이터베이 스 인스턴스들, 데이터베이스 관리 시스템들, 데이터, 애플리케이션들, 프로그램들, 프로그램 모듈들, 스크립트 들, 소스 코드, 객체 코드, 바이트 코드, 컴파일된 코드, 해석된 코드, 기계 코드, 실행 가능한 명령어들, 기타 등등은 처리 요소 및 운영 체제의 도움을 받아 클라우드 컴퓨팅 서버 컴퓨팅 엔티티의 동작의 특정 양태들을 제어하는 데 사용될 수 있다. 표시된 바와 같이, 일 실시예에서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 또한, 예를 들어 송신, 수신, 작동, 처리, 디스플레이, 저장, 기타 등등이 될 수 있는 데이터, 콘텐츠, 정보, 및/또는 본 명세서에서 상호 교 환가능하게 사용되는 유사한 용어들을 통신함으로써 다양한 컴퓨팅 엔티티들과 통신하기 위한 하나 이상의 통신 인터페이스를 포함할 수 있다. 이러한 통신은 FDDI(Fiber Distributed Data Interface), DSL(Digital Subscriber Line), 이더넷, ATM(Asynchronous Transfer Mode), 프레임 릴레이, DOCSIS(Data over Cable Service Interface Specification) 또는 임의의 다른 유선 송신 프로토콜과 같은 유선 데이터 송신 프로토콜을 사용하여 실행될 수 있다. 유사하게, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 GPRS(General Packet Radio Service), UMTS(Universal Mobile Telecommunications System), CDMA2000(Code Division Multiple Access 2000), CDMA2000 1X(1xRTT), WCDMA(Wideband Code Division Multiple Access), GSM(Global System for Mobile Communications), EDGE(Enhanced Data rates for GSM Evolution), TD-SCDMA(Time Division-Synchronous Code Division Multiple Access), LTE(Long Term Evolution), E-UTRAN(Evolved Universal Terrestrial Radio Access Network), EVDO(Evolution-Data Optimized), HSPA(High Speed Packet Access), HSDPA(High-Speed Downlink Packet Access), IEEE 802.11(Wi-Fi), Wi-Fi Direct, 802.16(WiMAX), UWB(ultra-wideband), 적외선 (IR) 프로토콜들, 근접장 통신(NFC) 프로토콜들, Wibree, 블루투스 프로토콜들, 무선 USB(universal serial bus) 프로토콜들 및/또는 임의의 다른 무선 프로토콜과 같은 다양한 프로토콜들 중 임의의 것을 사용하여 무선 외부 통신 네트워크들을 통해 통신하도록 구성될 수 있다. 도시되지는 않았지만, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 키보드 입력, 마우스 입력, 터치 스크린/디 스플레이 입력, 모션 입력, 이동(movement) 입력, 오디오 입력, 포인팅 디바이스 입력, 조이스틱 입력, 키패드 입력, 기타 등등과 같은 하나 이상의 입력 요소를 포함하거나 그와 통신할 수 있다. 클라우드 컴퓨팅 서버 컴 퓨팅 엔티티는 또한 오디오 출력, 비디오 출력, 스크린/디스플레이 출력, 모션 출력, 이동 출력, 기타 등 등과 같은 하나 이상의 출력 요소(도시되지 않음)를 포함하거나 그와 통신할 수 있다. 예시적인 클라이언트 컴퓨팅 엔티티 도 3은 본 개시의 실시예들과 함께 사용될 수 있는 클라이언트 컴퓨팅 엔티티의 예시적인 개략도를 제공한 다. 일반적으로, 용어 디바이스, 시스템, 컴퓨팅 엔티티, 엔티티, 및/또는 본 명세서에서 상호 교환가능하게 사용되는 유사한 단어들은, 예를 들어 하나 이상의 컴퓨터, 컴퓨팅 엔티티들, 데스크탑들, 모바일 폰들, 태블릿 들, 패블릿들, 노트북들, 랩탑들, 분산 시스템들, 키오스크들, 입력 터미널들, 서버들 또는 서버 네트워크들, 블레이드들, 게이트웨이들, 스위치들, 처리 디바이스들, 처리 엔티티들, 셋톱 박스들, 릴레이들, 라우터들, 네 트워크 액세스 포인트들, 기지국들 등 및/또는 본 명세서에 설명된 기능들, 동작들 및/또는 프로세스들을 수행 하도록 적응된 디바이스들 또는 엔티티들의 임의의 조합을 지칭할 수 있다. 클라이언트 컴퓨팅 엔티티들 은 다양한 당사자들에 의해 동작될 수 있다. 도 3에 도시된 바와 같이, 클라이언트 컴퓨팅 엔티티는 안테 나, 송신기(예를 들어, 라디오), 수신기(예를 들어, 라디오), 및 송신기 및 수신기에 신호를 제공하고 대응하여 그들로부터 신호를 수신하는 처리 요소(예를 들어, CPLD들, 마이크로프로세서들, 멀티코어 프로세서들, 공동처리 엔티티들, ASIP들, 마이크로컨트롤러들, 및/또는 컨트롤러 들)를 포함할 수 있다. 송신기 및 수신기에 제공되고 대응하여 그들로부터 수신되는 신호는 적용 가능한 무선 시스템들의 무 선 인터페이스 표준들에 따른 시그널링 정보/데이터를 포함할 수 있다. 이와 관련하여, 클라이언트 컴퓨팅 엔 티티는 하나 이상의 무선 인터페이스 표준들, 통신 프로토콜들, 변조 유형들, 및 액세스 유형으로 동작할 수 있다. 보다 구체적으로, 클라이언트 컴퓨팅 엔티티는 클라우드 컴퓨팅 서버 컴퓨팅 엔티티와 관 련하여 전술한 것들과 같은 다수의 무선 통신 표준 및 프로토콜 중 임의의 것에 따라 동작할 수 있다. 특정 실 시예에서, 클라이언트 컴퓨팅 엔티티는 UMTS, CDMA2000, 1xRTT, WCDMA, GSM, EDGE, TD-SCDMA, LTE, E- UTRAN, EVDO, HSPA, HSDPA, Wi-Fi, Wi-Fi Direct, WiMAX, UWB, IR, NFC, 블루투스, USB, 기타 등등과 같은 다 수의 무선 통신 표준 및 프로토콜에 따라 동작할 수 있다. 유사하게, 클라이언트 컴퓨팅 엔티티는 네트워 크 인터페이스를 통해 클라우드 컴퓨팅 서버 컴퓨팅 엔티티에 관하여 전술한 것들과 같은 다수의 유 선 통신 표준 및 프로토콜에 따라 동작할 수 있다. 이러한 통신 표준들 및 프로토콜들을 통해, 클라이언트 컴퓨팅 엔티티는 USSD(Unstructured Supplementary Service Data), SMS(Short Message Service), MMS(Multimedia Messaging Service), DTMF(Dual- Tone Multi-Frequency Signaling), 및/또는 SIM 다이얼러(Subscriber Identity Module Dialer)와 같은 개념을 사용하여 다양한 다른 엔티티와 통신할 수 있다. 클라이언트 컴퓨팅 엔티티는 또한 변경들, 애드온들 (add-ons), 및 업데이트들을, 예를 들어 그의 펌웨어, 소프트웨어(예를 들어, 실행 가능한 명령어들, 애플리케 이션들, 프로그램 모듈들을 포함함) 및 운영 체제에 다운로드할 수 있다. 일 실시예에 따르면, 클라이언트 컴퓨팅 엔티티는 위치 결정 양태들(location determining aspects), 디 바이스들, 모듈들, 기능들, 및/또는 본 명세서에서 상호 교환가능하게 사용되는 유사한 단어들을 포함할 수 있 다. 예를 들어, 클라이언트 컴퓨팅 엔티티는, 예를 들어 위도, 경도, 고도, 지오코드, 코스, 방향, 헤딩, 속도, 세계시(UTC), 날짜, 및/또는 다양한 다른 정보/데이터를 획득하도록 적응된 위치 모듈과 같은 실외 포지 셔닝 양태들(outdoor positioning aspects)을 포함할 수 있다. 일 실시예에서, 위치 모듈은 (예를 들어, 글로 벌 포지셔닝 시스템(GPS)을 사용하여) 보이는 위성들의 수 및 이러한 위성들의 상대적 위치들을 식별함으로써 때때로 천체력 데이터(ephemeris data)로 알려진 데이터를 획득할 수 있다. 위성들은 LEO(Low Earth Orbit) 위성 시스템들, DOD(Department of Defense) 위성 시스템들, 유럽 연합 갈릴레오 포지셔닝 시스템, 중국 컴퍼스 내비게이션 시스템, 인도 지역 내비게이션 위성 시스템들, 기타 등등을 포함하는 다양한 상이한 위성들일 수 있 다. 이러한 데이터는 DD(Decimal Degrees); DMS(Degrees, Minutes, Seconds); UTM(Universal Transverse Mercator); UPS(Universal Polar Stereographic) 좌표계, 기타 등등과 같은 다양한 좌표계를 사용하여 수집할 수 있다. 대안적으로, 위치 정보/데이터는 셀룰러 타워들, 와이파이 액세스 포인트들, 기타 등등을 포함하는 다양한 다른 시스템과 관련하여 클라이언트 컴퓨팅 엔티티의 위치를 삼각측량(triangulate)함으로써 결정 될 수 있다. 유사하게, 클라이언트 컴퓨팅 엔티티는, 예를 들어 위도, 경도, 고도, 지오코드, 코스, 방향, 헤딩, 속도, 시간, 날짜, 및/또는 다양한 다른 정보/데이터를 획득하도록 적응된 위치 모듈과 같은 실내 포지셔닝 양태들을 포함할 수 있다. 실내 시스템들 중 일부는 RFID 태그들, 실내 비콘들(indoor beacons) 또는 송신기들, 와이파이 액세스 포인트들, 셀룰러 타워들, 근처의 컴퓨팅 디바이스들(예를 들어, 스마트폰들, 랩탑 들), 기타 등등을 포함하는 다양한 포지션 또는 위치 기술을 사용할 수 있다. 예를 들어, 이러한 기술은 iBeacons, 짐벌 근접 비콘들(Gimbal proximity beacons), 블루투스 저에너지(BLE) 송신기들, NFC 송신기들, 기 타 등등을 포함할 수 있다. 이러한 실내 포지셔닝 양태들은 다양한 설정에서 수 인치(inches) 또는 센티미터 (centimeters) 이내로 사람 또는 사물의 위치를 결정하는 데 사용할 수 있다.클라이언트 컴퓨팅 엔티티는 또한 사용자 인터페이스(처리 요소에 결합된 디스플레이를 포함할 수 있음) 및/또는 사용자 입력 인터페이스(처리 요소에 결합됨)를 포함할 수 있다. 예를 들어, 사용자 인 터페이스는 본 명세서에서 설명된 바와 같이, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티와 상호작용하고/하거나 그로부터의 정보/데이터의 디스플레이를 유발하기 위해 클라이언트 컴퓨팅 엔티티에서 실행되고/되거나 그 를 통해 액세스 가능한 사용자 애플리케이션, 브라우저, 사용자 인터페이스, 및/또는 본 명세서에서 상호 교환 가능하게 사용되는 유사한 단어들일 수 있다. 사용자 입력 인터페이스는 클라이언트 컴퓨팅 엔티티가 데 이터를 수신할 수 있게 하는 다수의 디바이스 또는 인터페이스, 예컨대 키패드(하드 또는 소프트), 터치 디스플레이, 음성/스피치 또는 모션 인터페이스, 또는 다른 입력 디바이스 중 임의의 것을 포함할 수 있다. 키 패드를 포함하는 실시예들에서, 키패드는 종래의 숫자(0-9) 및 관련 키들(#, *), 및 클라이언트 컴퓨 팅 엔티티를 동작시키기 위해 사용되는 다른 키들을 포함할 수 있고(또는 이들의 디스플레이를 야기할 수 있고), 영숫자 키들의 전체 세트, 또는 영숫자 키들의 전체 세트를 제공하도록 활성화될 수 있는 키들의 세트를 포함할 수 있다. 입력을 제공하는 것에 더하여, 사용자 입력 인터페이스는, 예를 들어 스크린 세이버들 및/또 는 슬립 모드들(sleep modes)과 같은 특정 기능들을 활성화 또는 비활성화하기 위해 사용될 수 있다. 클라이언트 컴퓨팅 엔티티는 또한 휘발성 저장소 또는 메모리 및/또는 비휘발성 저장소 또는 메모리 를 포함할 수 있는데, 이들은 내장될 수 있고/있거나 제거가능할 수 있다. 예를 들어, 비휘발성 메모리는 ROM, PROM, EPROM, EEPROM, 플래시 메모리, MMC들, SD 메모리 카드들, 메모리 스틱들, CBRAM, PRAM, FeRAM, NVRAM, MRAM, RRAM, SONOS, FJG RAM, Millipede 메모리, 레이스트랙 메모리, 기타 등등일 수 있다. 휘발성 메 모리는 RAM, DRAM, SRAM, FPM DRAM, EDO DRAM, SDRAM, DDR SDRAM, DDR2 SDRAM, DDR3 SDRAM, RDRAM, TTRAM, T- RAM, Z-RAM, RIMM, DIMM, SIMM, VRAM, 캐시 메모리, 레지스터 메모리, 기타 등등일 수 있다. 휘발성 및 비휘 발성 저장소 또는 메모리는 클라이언트 컴퓨팅 엔티티의 기능들을 구현하기 위한 데이터베이스들, 데이터 베이스 인스턴스들, 데이터베이스 관리 시스템들, 데이터, 애플리케이션들, 프로그램들, 프로그램 모듈들, 스크 립트들, 소스 코드, 객체 코드, 바이트 코드, 컴파일된 코드, 해석된 코드, 기계 코드, 실행 가능한 명령어들, 기타 등등을 저장할 수 있다. 표시된 바와 같이, 이것은 엔티티 상에 상주하거나 클라우드 컴퓨팅 서버 컴퓨팅 엔티티 및/또는 다양한 다른 컴퓨팅 엔티티와 통신하기 위한 브라우저 또는 다른 사용자 인터페이스를 통 해 액세스 가능한 사용자 애플리케이션을 포함할 수 있다. 다른 실시예에서, 클라이언트 컴퓨팅 엔티티는 위에서 더 상세히 설명된 바와 같이 클라우드 컴퓨팅 서버 컴퓨팅 엔티티의 컴포넌트들과 동일하거나 유사한 하나 이상의 컴포넌트 또는 기능을 포함할 수 있다. 인 식되는 바와 같이, 이러한 아키텍처 및 설명은 예시적인 목적으로만 제공되며, 다양한 실시예로 한정되지 않는 다. 다양한 실시예들에서, 클라이언트 컴퓨팅 엔티티는 인공지능(AI) 컴퓨팅 엔티티, 예컨대 아마존 에코 (Amazon Echo), 아마존 에코 도트(Amazon Echo Dot), 아마존 쇼(Amazon Show), 구글 홈(Google Home), 기타 등 등으로 구체화될 수 있다. 따라서, 클라이언트 컴퓨팅 엔티티는 디스플레이, 카메라, 스피커, 음성 활성 화 입력, 기타 등등과 같은 입출력 메커니즘을 통해 사용자로부터 정보/데이터를 제공 및/또는 수신하도록 구성 될 수 있다. 특정 실시예들에서, AI 컴퓨팅 엔티티는 온보드 메모리 저장 모듈 내에 저장되고/되거나 네트워크 를 통해 액세스 가능한 하나 이상의 미리 정의되고 실행가능한 프로그램 알고리즘들을 포함할 수 있다. 다양한 실시예들에서, AI 컴퓨팅 엔티티는 미리 정의된 트리거 이벤트의 발생시 미리 정의된 프로그램 알고리즘들 중 하나 이상을 검색 및/또는 실행하도록 구성될 수 있다. V. 예시적인 시스템 운영들 이하에서 설명되는 바와 같이, 본 개시의 다양한 실시예들은 각각이 솔버 유형에 대응하는 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스의 서버리스 실행에 적어도 부분적으로 기초하여 입력 문제들에 대한 최적화된 솔루션들을 결정하기 위한 기술들을 설명한다. 예를 들어, 본 개시의 다양한 실시예들은 문제 출력을 생성하기 위해 하나 이상의 컨테이너 인스턴스를 생성하고 관리하기 위한 기술들을 제공한다. 언급된 기술들은 다양한 요인들(예를 들어, 자원들의 가용성, 입력 문제들의 총 볼륨, 실행 진행, 솔루션 최적화 이득)에 적어도 부분적으로 기초하여 상이한 컨테이너 인스턴스들에 동적으로 할당될 수 있는 컴퓨팅 및 처리 자원들의 효율적 인 사용을 수반한다. 이는 결국 다양한 실시예들에 따른 클라우드 기반 다중 도메인 솔버 시스템의 전체 동작 로드를 감소시키고, 그의 동작 효율성 및 동작 신뢰성을 증가시킨다. 도 4는 컨테이너화된 클라우드 기반(예를 들어, 서버리스) 방식으로 입력 문제에 대한 최적화된 솔루션을 결정 하기 위한 예시적인 프로세스의 흐름도를 제공한다. 다양한 실시예들에서, 클라우드 컴퓨팅 서버 컴퓨팅엔티티는 프로세스의 단계들/동작들을 수행하기 위한 하나 이상의 처리 요소, 하나 이상의 메모 리(210, 215), 네트워크 인터페이스, 기타 등등과 같은 수단을 포함한다. 예시된 바와 같이, 프로세스는 단계/동작을 포함한다. 일 실시예에서, 프로세스는 단계/동작 로 시작되고/되거나 그에 의해 트리거된다. 단계/동작은 클라이언트 컴퓨팅 엔티티로부터 비롯 되는 입력 문제의 문제 유형을 수신하는 것을 포함한다. 다양한 실시예들에서, 입력 문제의 문제 유형은 유형 불가지론적 문제 해결 API 요청을 통해 수신될 수 있다. 다양한 실시예들에서, 클라우드 기반 다중 도메인 솔 버 시스템은 유형 불가지론적 문제 해결 API를 포함하고, 유형 불가지론적 문제 해결 API를 통해 클라이언 트 컴퓨팅 엔티티로부터 비롯되는 유형 불가지론적 문제 해결 API 요청을 수신한다. 다양한 실시예들에서, 유형 불가지론적 문제 해결 API 요청은 입력 문제의 문제 유형뿐만 아니라, 입력 문제의 다른 문제 특징들을 나타낸다. 유형 불가지론적 문제 해결 API 요청은 클라우드 기반 다중 도메인 솔버 시스템 에 의해 수신된 각각의 유형 불가지론적 문제 해결 API 요청이 특정 구성에서 다양한 데이터 필드들을 포함하도 록 표준화된 구성을 가질 수 있으며, 각각의 데이터 필드는 특정 의미의 데이터를 정의한다. 다양한 실시예들 에서, 유형 불가지론적 문제 해결 API 요청은 데이터 구조, 데이터 객체, 기타 등등, 예컨대 벡터, 어레이 또는 행렬로서 정의될 수 있다. 유형 불가지론적 문제 해결 API 요청은 유형 불가지론적 문제 해결 API 요청을 사용 하여 임의의 문제 유형의 입력 문제들을 정의할 수 있다는 점에서 유형 불가지론적이다. 즉, 유형 불가지론적 문제 해결 API 요청은 클라우드 기반 다중 도메인 솔버 시스템에 의한 해결을 위해 임의의 문제 유형의 입력 문 제를 정의하는 데 사용될 수 있는 다양한 정적 데이터 필드들 및 다양한 동적 데이터 필드들을 포함할 수 있다. 다양한 실시예들에서, 하나 이상의 동적 데이터 필드는 입력 문제의 문제 유형에 의존하거나 조건부일 수 있다. 예를 들어, 하나 이상의 동적 데이터 필드는 외판원 문제이고/이거나 그와 실질적으로 유사한 입력 문제를 정의 하는 데 사용될 수 있는 반면, 동일한 동적 데이터 필드들은 자산 분배 문제이고/이거나 그와 실질적으로 유사 한 다른 입력 문제에 대해 사용되지 않을 수 있다. 일부 실시예들에서, 유형 불가지론적 문제 해결 API 요청에 의해 정의된 입력 문제의 문제 유형은 유형 불가지론적 문제 해결 API 요청의 특정 정적 데이터 필드에 의해 설 명된다. 다양한 실시예들에서, 클라우드 기반 다중 도메인 솔버 시스템은 유형 불가지론적 문제 API와 통신하고/하 거나 이를 포함하는 요청 관리 엔진을 포함한다. 도 5a는 요청 관리 엔진을 포함하는 클라우드 컴퓨팅 서 버 컴퓨팅 엔티티의 예시적인 블록도를 예시한다. 요청 관리 엔진은 다양한 클라이언트 컴퓨팅 엔티 티로부터 비롯되는 유형 불가지론적 문제 해결 API 요청들을 수신, 처리, 핸들링, 기타 등등을 하도록 구 성된다. 다양한 실시예들에서, 요청 관리 엔진은 유형 불가지론적 문제 API를 통해 유형 불가지론적 문제 해결 API 요청을 수신하고, 유형 불가지론적 문제 해결 API 요청을 검증(validate)한다. 요청 관리 엔진 은 추가로 유형 불가지론적 문제 해결 API 요청에 의해 정의된 입력 문제의 문제 특징들을 추출할 수 있으며, 예를 들어, 유형 불가지론적 문제 해결 API 요청에 의해 정의된 입력 문제의 문제 유형을 식별한다. 다양한 실시예들에서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 도 5b에 예시된 바와 같이 각각이 다양한 클 라이언트 컴퓨팅 엔티티들로부터 비롯되는 유형 불가지론적 문제 해결 API 요청들을 수신하고 처리하도록 구성된 하나 이상의 요청 관리 엔진을 포함한다. 이러한 실시예들에서, 각각의 요청 관리 엔진은 가 용성 구역(510A-B)에 대응할 수 있다. 가용성 구역(510A-B)은 대응하는 요청 관리 엔진의 책임의 범위를 설명한다. 예를 들어, 제1 가용성 구역(510A)에 대응하는 제1 요청 관리 엔진(502A)은 클라이언트 컴퓨팅 엔티 티들의 제1 코호트로부터 비롯되는 유형 불가지론적 문제 해결 API 요청들을 수신하고 처리하도록 구성될 수 있는 반면, 제2 가용성 구역(510B)에 대응하는 제2 요청 관리 엔진(502B)은 클라이언트 컴퓨팅 엔티티들 의 제2 코호트로부터 비롯되는 유형 불가지론적 문제 해결 API 요청들을 수신하고 처리하도록 구성될 수 있다. 다른 예로서, 상이한 가용성 구역들(510A-B)의 요청 관리 엔진들의 사용은 적어도 부분적으로 주문 에 기초할 수 있으며, 제2 가용성 구역(510B)에 대응하는 제2 요청 관리 엔진(502B)은, 유형 불가지론적 문제 해결 API 요청들을 수신하고 처리할 때, 제1 가용성 구역(510A)에 대응하는 제1 요청 관리 엔진(502A)이 임계량 의 컴퓨팅 및 처리 자원들을 소비하고 있을 때, 유형 불가지론적 문제 해결 API 요청들을 수신하고 처리하도록 구성된다. 따라서, 2개 이상의 요청 관리 엔진의 사용 및 상이한 가용성 구역들(510A-B) 사이의 그의 분 할은 컴퓨팅 및 처리 자원들의 효율적이고 유연한 사용을 유리하게 제공한다. 다양한 실시예들에서, 요청 관리 엔진(들)은 인바운드 문제 큐와 통신한다. 인바운드 문제 큐 는 클라우드 기반 다중 도메인 솔버 시스템에 의해 해결되어야 할 복수의 입력 문제를 식별 및/또는 설명 하도록 구성된다. 다양한 사례들에서, 다수의 유형 불가지론적 문제 해결 API 요청이 요청 관리 엔진에 의해 수신될 수 있고, 요청 관리 엔진은 다수의 유형 불가지론적 문제 해결 API 요청에 의해 정의된 다수의 입력 문제가 인바운드 문제 큐에 의해 식별 및/또는 설명되게 할 수 있다. 다양한 실시예들에서, 입력 문제들은, 예컨대 FIFO(first-in-first-out) 방식으로 인바운드 문제 큐 내에 조직화될 수 있다. 단계/동작 402는 입력 문제의 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 것을 포함한다. 앞서 설 명한 바와 같이, 입력 문제의 문제 유형은 입력 문제의 분류를 설명하며, 입력 문제의 문제 특징들에 의해 결정 될 수 있다. 일반적으로, 문제 유형은 문제의 목적을 설명할 수 있으며, 그 예들은 최소 거리의 경로 결정(외 판원 문제와 같은 경로 찾기 문제 유형) 또는 최대 수익을 위한 투자들의 분배 결정(투자 문제와 같은 자산 분 배 문제 유형)을 포함한다. 다양한 사례들에서, 문제 유형은 입력 문제에 필요한 솔루션을 설명하거나 특성화 할 수 있다. 문제 유형은 입력 문제에 필요한 솔루션을 설명하거나 특성화할 수 있는 반면, 솔버 유형은 문제에 대한 솔루션 을 결정하기 위한 알고리즘, 휴리스틱, 방법, 기타 등등을 설명한다. 다양한 실시예들에서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 다양한 문제들에 대한 다양한 솔루션들을 각각 결정하는 다양한 솔버 유형들을 호스 트, 저장, 액세스, 기타 등등을 한다. 다양한 솔버 유형들은 각각의 솔버 유형을 식별하는 솔버 유형들의 라이 브러리 또는 데이터베이스에 의해 식별될 수 있고, 각각의 솔버 유형의 입력들, 출력들, 필수 파라미터들, 계산 또는 알고리즘 복잡성(computational or algorithmic complexity), 기타 등등을 설명할 수 있다. 다양한 솔버 유형들은 특정 문제들에 가장 잘 적용되거나 특정 문제들에만 적용될 수 있는 솔버 유형들을 포함할 수 있으며, 따라서 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑한다. 특히, 일부 실시예들에서, 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 것은 도 6에 예시된 예시적인 단계들/동작들에서 구체화된다. 즉, 도 6은 단계/동작 402의 예시적인 실시예인 예시적인 프로세스를 예시하는 흐름도를 제공한다. 다양한 실시예들에서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 프로세스의 단계 들/동작들을 수행하기 위한 하나 이상의 처리 요소, 하나 이상의 메모리(210, 215), 네트워크 인터페이스, 기타 등등과 같은 수단을 포함한다. 프로세스의 단계/동작 601에서, 솔버 도메인이 입력 문제의 문제 유형 및 입력 문제의 하나 이상의 문제 특징에 적어도 부분적으로 기초하여 결정된다. 솔버 도메인은 솔버 유형들의 세트의 공통 특성을 설명한다. 구체적으로, 솔버 도메인은 도메인별 솔버 유형들 각각에 의해 결정된 최적화된 솔루션들에 적어도 부분적으로 기초하여 도메인별 솔버 유형들의 세트와 연관될 수 있다. 도메인별 솔버 유형들 각각에 의해 결정된 최적화된 솔루션들은 형태가 유사하며, 문제 유형에 대한 입력 문제들을 푸는 데 적용될 수 있다. 따라서, 솔버 도메인 은 문제 유형의 입력 문제들을 푸는 데 사용될 수 있고 입력 문제에 적용될 수 있는 도메인별 솔버 유형들의 세 트를 식별하도록 결정된다. 일례로, 솔버 도메인은 각각이 최적화된 경로를 찾는 것과 관련되는 도메인별 솔버 유형들의 세트와 연관될 수 있다. 따라서, 단계/동작 602는 솔버 도메인에 대응하는 도메인별 솔버 유형들의 세트를 식별하는 것을 포함한다. 다 양한 실시예들에서, 각각의 도메인별 솔버 유형은 고유 식별자와 연관되고, 솔버 도메인은 도메인별 솔버 유형 들에 대한 다양한 식별자들을 포함하도록 생성된다. 일례로, 경로찾기 문제 유형의 입력 문제에 적용될 수 있 는 도메인별 솔버 유형들을 식별하는 솔버 도메인은 무작위 대입 솔버 유형에 대한 식별자, 시뮬레이티드-어닐 링 솔버 유형에 대한 식별자, 다이크스트라(Dijkstra) 솔버 유형에 대한 식별자, 언덕 오르기 솔버 유형에 대한 식별자, 기타 등등을 포함할 수 있다. 이어서, 단계/동작 603에서, 하나 이상의 선택된 솔버 유형이 도메인별 솔버 유형들의 세트로부터 결정된다. 하나 이상의 선택된 솔버 유형은 다른 도메인별 솔버 유형들에 비해 상대적으로 더 나은 성능 메트릭들, 자원 사용 요구들, 기타 등등을 갖는 도메인별 솔버 유형들일 수 있다. 일례로, 하나 이상의 선택된 솔버 유형은 자 원 사용 임계치에 비해 낮은 자원 사용 요구들(예를 들어, 선형 또는 더 낮은 차수의 계산 복잡성)을 갖는 것에 적어도 부분적으로 기초하여 결정된다. 자원 사용 임계치는 인바운드 문제 큐 내의 입력 문제들의 볼륨에 적어도 부분적으로 기초하여 결정될 수 있으며, 따라서, 선택된 솔버 유형들은 솔루션들을 필요로 하는 입력 문 제들의 볼륨에 적어도 부분적으로 기초하여 결정될 수 있다. 따라서, 적어도 이러한 단계들/동작들을 통해, 입 력 문제의 문제 유형은 하나 이상의 선택된 솔버 유형에 매핑될 수 있다. 다양한 실시예들에서, 입력 문제와 하나 이상의 선택된 솔버 유형 사이의 매핑이 저장되며, 솔버 선택 기계 학습 모델을 훈련하고 구성하기 위해 사용된다. 솔버 선택 기계 학습(ML) 모델은 입력 문제에 대한 선택된 솔버 유형들을 지능적으로 자동으로 결정 하도록 구성(예를 들어, 훈련)된다. 후술하는 특정 예시적인 실시예들에서, ML 기반 솔버 유형 선택은 솔버 프 리프로세서에 의해 수행된다. 다양한 실시예들에서, 인바운드 문제 큐는 선택된 솔버 유형들을 결정한 후에 선택된 솔버 유형들을 식별 하고 설명하도록 구성된다. 예를 들어, 인바운드 문제 큐 내에서, 입력 문제는 입력 문제의 문제 유형에 매핑되도록 결정된 하나 이상의 선택된 솔버 유형과 연관될 수 있다. 따라서, 다양한 실시예들에서 인바운드 문제 큐는 각각의 입력 문제에 대한 포괄적이고 완전한 정보를 유리하게 저장한다. 인바운드 문제 큐 를 사용하면, 입력 문제에 매핑된 선택된 솔버 유형들이 신속하게 식별될 수 있어서, 다른 메모리 저장 영 역들로부터 선택된 솔버 유형들을 탐색 및/또는 검색할 필요가 없게 된다. 이는 추가로 자원 요구들의 일부 표 시와 각각 연관될 수 있는 특정 입력 문제에 매핑된 선택된 솔버 유형들을 신속하게 식별함으로써 특정 입력 문 제를 핸들링하는 데 필요한 컴퓨팅 및 처리 자원들의 추정된 양을 빠르고 효율적으로 결정하는 데 유리하다. 도 4로 돌아가서, 단계/동작 403은 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하는 것을 포함하며, 각각의 컴퓨팅 컨테이너는 선택된 솔버 유형에 대응한다. 컴퓨팅 컨테이너는 컴퓨터 실행 가능 명령어들 및/또는 컴퓨터 실행 가능 명령어들을 실행하는 데 필요한 추가적인 데이터(예를 들어, 데이터 세트들, 데이터 라이브러리들, 종속성 데이터)의 인스턴스화 가능한 패키지, 번들, 이미지, 기타 등등을 설명한 다. 컴퓨팅 컨테이너는 적어도 메모리 저장소와 관련하여 유리하게 가벼운데, 이는 컴퓨팅 컨테이너가 표준 및 반복 데이터(예를 들어, 운영 체제)를 필요로 하지 않기 때문이다. 컴퓨팅 컨테이너는 추가로, 컴퓨팅 컨테이 너의 인스턴스화 및 실행에 필요한 모든 데이터가 컴퓨팅 컨테이너 내에 패키징되기 때문에 독립형이고 데이터 검색 및 다른 데이터 모듈들, 데이터 라이브러리들, 데이터 엔진들, 기타 등등과의 통신을 필요로 하지 않는다 는 점에서 유리하다. 다양한 실시예들에서, 컴퓨팅 컨테이너는 솔버 유형(예를 들어, 알고리즘, 휴리스틱, 방법)에 따라 입력 문제에 대한 솔루션들을 결정하도록 구성된다. 즉, 솔버 유형에 대응하는 컴퓨팅 컨테이너는 솔버 유형을 전자적으로 구체화 및/또는 구현할 수 있다. 예를 들어, 무작위 대입 솔버 유형에 대응하는 제1 컴퓨팅 컨테이너는 인스턴 스화 및 실행될 때 입력 문제에 대한 가능한 모든 솔루션을 생성 및 테스트하여 최적화된 솔루션을 결정하도록 구성되는 반면, 타부-탐색 솔버 유형에 대응하는 제2 컴퓨팅 컨테이너는 인스턴스화 및 실행될 때 특정 솔루션 에 대한 유사한 솔루션을 테스트하고 유사한 솔루션들의 최적화에서의 개선을 평가하여 최적화된 솔루션을 결정 하도록 구성된다. 솔버 유형에 대응하는 각각의 컴퓨팅 컨테이너의 경우, 컴퓨팅 컨테이너는 (예를 들어, 다양 한 글로벌 또는 유니버설 식별자를 통해) 고유하게 식별될 수 있고, 데이터스토어, 데이터세트, 데이터 라이브 러리, 기타 등등에 다른 컴퓨팅 컨테이너들과 함께 저장될 수 있다. 컴퓨팅 컨테이너는 또한 입력 문제의 문제 제약을 식별하고, 결정된 솔루션들이 최적화 동안 다양한 문제 제약을 충족시키는 것을 보장하도록 구성된 제약 매퍼를 정의할 수 있다. 컴퓨팅 컨테이너들은 클라우드 기반 다중 도메인 솔버 시스템 내에 주문에 기초하여 컴퓨팅 및 처리 자원 들을 개별적으로 소비하는 컨테이너 인스턴스들로서 인스턴스화된다. 즉, 컨테이너 인스턴스는 컴퓨팅 컨테이 너의 인스턴스화로서 정의된다. 컨테이너 인스턴스가 생성될 때, 컨테이너 인스턴스는 자동으로 그리고 독립적 인 방식으로 실행을 시작하도록 구성될 수 있다. 컨테이너 인스턴스의 실행은 소정량의 컴퓨팅 및 처리 자원들 을 소비하며, 이러한 자원들은 하나 이상의 컨테이너 인스턴스 사이에 적절하게 할당되고 분배될 수 있다. 특 정 컴퓨팅 컨테이너의 컨테이너 인스턴스를 실행하는 데 필요한 최소량의 컴퓨팅 및 처리 자원들은 다양한 실시 예들에서 특정 컴퓨팅 컨테이너의 정의되고 설명된 파라미터일 수 있으며, 컨테이너 인스턴스는 실행에 필요한 적어도 최소량의 컴퓨팅 및 처리 자원들이 이용 가능할 때 생성될 수 있다. 컨테이너 인스턴스들의 생성 및 실행은 도 5a 및 도 5b에 예시된 클라우드 컴퓨팅 서버 컴퓨팅 엔티티의 하나 이상의 컨테이너 관리 엔진에 의해 관리될 수 있다. 다양한 실시예들에서, 컨테이너 관리 엔진(50 4)은 컴퓨팅 컨테이너의 컨테이너 인스턴스를 생성하고, 컨테이너 인스턴스의 실행에 컴퓨팅 및 처리 자원들의 양을 동적으로 할당하도록 구성된다. 하나 이상의 컨테이너 인스턴스 사이의 컴퓨팅 및 처리 자원들의 동적 할 당의 일부로서, 컨테이너 관리 엔진은 클라우드 컴퓨팅 서버 컴퓨팅 엔티티의 컴퓨팅 및 처리 자원들 의 사용 및 분배를 모니터링하고, 필요하다고 간주될 때 컨테이너 인스턴스들 사이에 이러한 자원들을 재분배하 도록 구성된다. 유사하게, 컨테이너 관리 엔진은 컴퓨팅 및 처리 자원들의 이용가능한 양을 모니터링하고, 컴퓨팅 및 처리 자원들의 이용가능한 양이 컨테이너 인스턴스의 실행에 필요한 컴퓨팅 및 처리 자원들의 최소량을 충족시키는 경우 컨테이너 인스턴스를 생성하도록 구성된다. 다양한 실시예들에서, 컨테이 너 관리 엔진은 또한 컨테이너 인스턴스에 과도한 양의 컴퓨팅 및 처리 자원들을 할당하지 않으며, 컨테이 너 인스턴스에 할당된 컴퓨팅 및 처리 자원들의 양은 하나 이상의 구성 가능한 임계치 또는 한도에 의해 제한될 수 있다. 컨테이너 인스턴스화의 다양한 추가 변형들이 본 개시와 관련된 분야의 통상의 기술자에게 떠오를 것 이다. 예를 들어, 하나 이상의 컴퓨팅 컨테이너에 대한 컨테이너 인스턴스들은 시간이 지남에 따라 동적으로 생성된다. 입력 문제가 5개의 솔버 유형에 매핑되는 예에서, 2개의 솔버 유형에 대한 컨테이너 인스턴스들이(예를 들어, 컴퓨팅 및 처리 자원들의 제한된 가용성으로 인해) 먼저 생성될 수 있고, 나머지 3개의 솔버 유형 에 대한 컨테이너 인스턴스들이 후속 시점에 생성될 수 있다. 도 5b에 도시된 바와 같이, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 하나 이상의 컨테이너 관리 엔진 을 포함할 수 있으며, 이들 각각은 가용성 구역에 대응하고, 각각은 대응하는 가용성 구역에서 수신 된 입력 문제들에 대한 컨테이너 인스턴스들의 생성 및 실행을 관리하도록 구성된다. 또한, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티의 컴퓨팅 및 처리 자원들은 다수의 가용성 구역 간에 분할 또는 파티셔닝될 수 있으며, 컨테이너 관리 엔진은 대응하는 가용성 구역에 대한 컴퓨팅 및 처리 자원들을 컨테이너 인스 턴스들의 생성 및 실행에 할당하도록 구성된다. 예시된 실시예에서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티(10 6)는 제1 가용성 구역(510A)에 대응하는 제1 컨테이너 관리 엔진(504A) 및 제2 가용성 구역(510B)에 대응하는 제2 컨테이너 관리 엔진(504B)을 포함한다. 하나 이상의 컨테이너 인스턴스는 (예를 들어, 컨테이너 관리 엔진을 통해) 인바운드 문제 큐에 적어 도 부분적으로 기초하여 생성된다. 구체적으로, 인바운드 문제 큐는 특정 입력 문제가 핸들링될 준비가 되었음을 나타낼 수 있고, 컨테이너 관리 엔진과 통신하여 특정 입력 문제에 매핑된 선택된 솔버 유형에 각각 대응하는 하나 이상의 컴퓨팅 컨테이너에 대한 컨테이너 인스턴스들을 생성할 수 있다. 일부 실시예들에 서, 인바운드 문제 큐에 의해 식별된 각각의 입력 문제는 상태(status)와 연관되며, 하나의 이러한 상태는 \"준비(ready)\" 상태이다. 인바운드 문제 큐와 통신하여, 컨테이너 관리 엔진은 입력 문제와 관련된 다양한 파라미터, 값, 및 데이터를 포함하여, 입력 문제에 대한 문제 특징들을 수신하거나 검색할 수 있고, 생 성 시 컨테이너 인스턴스에 이러한 문제 특징들을 제공할 수 있다. 따라서, 컨테이너 인스턴스는 생성되면 입 력 문제에 대한 최적화된 솔루션을 결정할 준비가 되어 있다. 앞서 설명한 바와 같이, 컨테이너 인스턴스는 생성 시 자동으로 실행을 시작하도록 구성될 수 있고, 특정 입력 문제에 대한 최적화된 솔루션을 결정하기 위해 필요한 문제 특징들을 제공받을 수 있다. 다양한 실시예들에서, 컨테이너 인스턴스는 입력 문제에 대한 최적화된 솔루션이 컨테이너 인스턴스를 사용하여 현재 결정되고 있음 (예를 들어, 컨테이너 인스턴스는 \"활성임(alive)\")을 나타내기 위해 사용되는 하트비트(heartbeat) API를 포함 한다. 다양한 실시예들에서, 컨테이너 인스턴스는 하트비트 API를 통해 컨테이너 관리 엔진 및/또는 인바 운드 문제 큐와 통신하여, 컨테이너 관리 엔진 및/또는 인바운드 문제 큐에 컨테이너 인스턴스 가 \"활성이고\" 실행 중임을 알린다. 특정 입력 문제에 대한 적어도 하나의 컨테이너 인스턴스의 실행 동안, 인 바운드 문제 큐에서 특정 입력 문제와 연관된 상태는 \"처리\", \"핸들링\" 및/또는 유사한 상태로 구성될 수 있다. 따라서, 단계/동작 403에 의해, 하나 이상의 컨테이너 인스턴스가 생성되고, 이들 각각은 입력 문제에 대한 최 적화된 솔루션을 결정하기 위해 실행된다. 이어서, 단계/동작 404에서, 문제 출력은 하나 이상의 컨테이너 인 스턴스를 사용하여 생성된다. 문제 출력은 하나 이상의 컨테이너 인스턴스의 실행에 적어도 부분적으로 기초하 여 생성된 최적화된 솔루션을 포함할 수 있다. 일부 실시예들에서, 최적화된 솔루션들을 결정하기 위해 컨테이너 인스턴스들을 사용함으로써, 본 개시의 다양 한 실시예들은 일반적으로 컨테이너화된 클라우드 기반(예를 들어, 서버리스) 방식으로 입력 문제들에 대한 최 적화된 솔루션들을 결정하는 것과 관련된다. 특히, 입력 문제들에 대한 최적화된 솔루션들을 결정하는 것은 각 각이 솔버 유형에 대응하는 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스의 실행에 적어도 부 분적으로 기초한다. 컨테이너 인스턴스들은 클라우드 기반 다중 도메인 솔버 시스템 내에서 서버리스 방식으로 실행된다. 즉, 컴퓨팅 및 처리 자원들은 주문에 기초하여 컨테이너 인스턴스들의 실행을 위해 모집될 수 있다. 따라서, 본 개시의 다양한 실시예들은 입력 문제들의 볼륨에 대한 최적화된 솔루션들의 유연하고 탄력적인 결정 을 가능하게 함으로써 기술적 이점들을 제공한다. 다양한 예시적인 사례들에서, 컴퓨팅 및 처리 자원들은 우선 순위를 갖는 특정 입력 문제들에 대해 전환, 할당, 예약, 기타 등등이 될 수 있고, 컴퓨팅 및 처리 자원들은 입 력 문제들의 볼륨이 낮을 때 보존될 수 있다. 따라서, 본 개시의 다양한 실시예들에서 입력 문제들에 대한 최 적화된 솔루션들의 클라우드 기반 및 서버리스 결정은 컴퓨팅 및 처리 자원들의 효율적이고 유연하고 탄력적인 사용을 초래하며, 이는 추가로 시간 및 실제 비용의 보존으로 이어진다. 일부 실시예들에서, 문제 출력의 생성은 도 7에 예시된 단계들/동작들에 의해 구체화된다. 도 7은 문제 출력을 생성(예를 들어, 단계/동작 404)하기 위한 예시적인 실시예를 예시한다. 단계/동작 701에서, 각각의 컨테이너 인스턴스의 실행은 각각의 실행 반복에 대해 모니터링된다. 다양한 솔버 유형들과 연관된 컨테이너 인스턴스들의 실행은 상호 의존적일 수 있는 다수의 실행 반복을 통해 수행된다. 각각의 실행 반복에서, 컨테이너 인스턴스는 제안된 솔루션을 결정할 수 있고, 각각의 제안된 솔루션은 이전 실행 반복으로부터 이전에 결정된 솔루션에 적어도 부분적으로 기초할 수 있다. 또한, 각각의 실행 반복에서, 컨테 이너 인스턴스는 최적화에 대한 수렴 또는 접근의 척도로서 반복별 최적화 이득을 결정할 수 있다. 반복별 최 적화 이득은 결정된 솔루션을 이전에 결정된 솔루션(예를 들어, 가장 최근의 솔루션)과 비교한다. 일부 실시예 들에서, 컨테이너 인스턴스는 솔루션의 최적화를 향한 컨테이너 인스턴스의 진행의 표시로서 반복별 최적화 이 득을 출력하도록 구성된다. 예를 들어, 반복별 최적화 이득은 컨테이너 인스턴스의 하트비트 API를 통해 제공 될 수 있다. 따라서, 클라우드 컴퓨팅 서버 컴퓨팅 엔티티는 (예를 들어, 컨테이너 관리 엔진을 통 해) 컨테이너 인스턴스의 실행 및 그 진행을 모니터링할 수 있다. 다양한 실시예들에서, 컨테이너 인스턴스의 실행을 모니터링하는 것은 컨테이너 인스턴스에 할당되고/되거나 컨 테이너 인스턴스에 의해 소비되는 컴퓨팅 및 처리 자원들의 양을 모니터링하는 것을 포함한다. 컨테이너 인스 턴스의 자원 사용 및 이용을 모니터링함에 있어서, 다수의 시점과 연관된 사용 데이터가 수집되어 분석될 수 있 다. 다양한 실시예들에서, 사용 데이터는 전용 처리 시간(예를 들어, 컨테이너 인스턴스를 처리하기 위해 하나 이상의 프로세서에 의해 소비된 총 시간의 일부), 메모리 크기(예를 들어, 컨테이너 인스턴스에 의해 예약되고 사용된 휘발성 및/또는 비휘발성, 메모리 저장량), 기타 등등을 포함한다. 단계/동작 702는 실행 반복의 반복별 최적화 이득이 구성 가능한 반복별 최적화 이득 임계치를 충족시키지 못하 는 경우 컨테이너 인스턴스의 실행을 중단하는 것을 포함한다. 앞에서 설명한 바와 같이, 실행 반복의 반복별 최적화 이득은 컨테이너 인스턴스의 최적화를 향한 진행 상황을 나타낸다. 일부 사례들에서, 컨테이너 인스턴 스에 의해 결정된 솔루션들은 발산하여, 불만족스런 반복별 최적화 이득을 유발할 수 있다. 솔루션들의 발산은 전형적으로, 최적화된 솔루션이 결정될 수 없음(예를 들어, 재수렴(reconvergence)이 불가능할 가능성이 있음) 을 시사하며, 따라서 컨테이너 인스턴스에 대한 컴퓨팅 및 처리 자원들의 낭비를 피하기 위해 컨테이너 인스턴 스의 실행이 중단될 수 있다는 것을 이해할 수 있다. 다양한 구성 가능한 반복별 최적화 이득 임계치는 추가로 컨테이너 인스턴스의 자원 사용 및 이용에 적어도 부분적으로 기초할 수 있다. 예를 들어, 컨테이너 인스턴스 는 자원 사용 및 이용이 증가하는 동안 반복별 최적화 이득이 변경되거나 개선되지 않을 때 중단될 수 있다. 일부 실시예들에서, 컨테이너 인스턴스의 실행의 중단은 컨테이너 인스턴스의 하트비트 API를 통해 야기된다. 예를 들어, 컨테이너 인스턴스는 하트비트 API를 통해 컨테이너 관리 엔진으로부터 비롯되는 중단(halt), 삭제(kill), 종료(terminate), 기타 등등의 커맨드를 수신할 수 있다. 일부 실시예들에서, 컨테이너 인스턴스 는 하나 이상의 불만족스러운 반복별 최적화 이득에 응답하여 실행을 자동으로 중단하도록 구성되고, 하트비트 API를 통해 실행의 중단을 나타내는 최종 하트비트 메시지를 송신할 수 있다. 다양한 실시예들에서, 컨테이너 인스턴스는 컴퓨팅 및 처리 자원들이 컨테이너 인스턴스를 위해 할당되는 것을 제한하거나 중단함으로써 중단, 일시정지, 삭제, 종료, 기타 등등이 될 수 있다. 컴퓨팅 및 처리 자원들은 (예를 들어, 컨테이너 관리 엔진 에 의해) 컨테이너 인스턴스로부터 다른 컨테이너 인스턴스로 능동적으로 할당해제(deallocated)될 수 있 다. 단계/동작 703은 하나 이상의 컨테이너 인스턴스의 실행에 적어도 부분적으로 기초하여 생성된 하나 이상의 컨 테이너 출력을 수신하는 것을 포함한다. 컨테이너 인스턴스들은 실행이 완료될 때 컨테이너 출력들을 제공하며, 이는 또한 반복별 최적화 이득을 사용하여 결정될 수 있다. 예를 들어, 최적화를 향한 진행이 충분 히 완료되었는지를 결정하기 위해 반복별 최적화 이득이 평가될 수 있다. 추가적으로 또는 대안적으로, 일부 문제 유형들의 입력 문제들에 대한 절대적인 정확성에 대해 솔루션들이 테스트될 수 있다. 어쨌든, 컨테이너 인스턴스에 의해 제공되는 컨테이너 출력은 입력 문제에 대한 최적화된 솔루션을 포함할 수 있다. 컨테이너 출 력은 수렴 데이터(예를 들어, 각각의 실행 반복에 대한 반복별 최적화 이득), 반복 데이터(예를 들어, 수행된 실행 반복들의 수), 기타 등등을 더 포함할 수 있다. 단계/동작 704는 하나 이상의 컨테이너 출력에 적어도 부분적으로 기초하여 문제 출력을 생성하는 것을 포함한 다. 다양한 사례들에서, 입력 문제는 다수의 솔버 유형에 매핑되며, 다수의 컨테이너 인스턴스로부터 다수의 컨테이너 출력이 수신될 수 있다. 따라서, 다수의 컨테이너 출력이 집계되고 비교되어, 문제 출력을 생성할 수 있다. 예를 들어, 문제 출력은 다수의 컨테이너 출력의 다수의 최적화된 솔루션으로부터의 최상 적합의 최적화 된 솔루션을 포함할 수 있다. 대안적인 예로서, 문제 출력은 다수의 컨테이너 출력의 다수의 최적화된 솔루션 의 평균 솔루션을 포함할 수 있다. 다양한 실시예들에서, 문제 출력은 입력 문제에 매핑된 다수의 솔버 유형의 성능 메트릭들과 같은 추가적인 데이터를 포함한다. 즉, 문제 출력은 솔버 유형의 임의의 컨테이너 인스턴스가 중단되었는지 여부, 솔버 유형의 컨테이너 인스턴스들이 수행한 평균 실행 반복들의 수, 기타 등등을 설명할 수 있다. 각각의 솔버 유형의 이러한 성능 메트릭들(performance metrics)은, 예컨대 (존재할 경우) 솔버 유형들이 중단된 솔버 선택 기계 학습 모델을 훈련하고 구성함으로써, 솔버 유형들에 대한 문제 유형들의 매핑을 위해 나중에 사용될 수 있다. 문제 출력의 생성은 도 5a 및 도 5b에 예시된 아웃바운드 솔루션 큐를 업데이트하여 (예를 들어, 문제 출 력을) 식별하는 것을 포함할 수 있다. 다수의 입력 문제가 기간과 함께 수신될 수 있고, 문제 출력들이 각각의 입력 문제에 대해 결정됨에 따라, 아웃바운드 솔루션 큐는 2개 이상의 문제 출력을 식별(예를 들어, 저 장)하도록 구성된다. 아웃바운드 솔루션 큐는 또한 각각의 문제 출력과 연관된 상태를 저장할 수 있으며, 문제 출력은 \"반환 준비\", \"송신 준비\", 기타 등등의 상태로 아웃바운드 솔루션 큐에 추가될 수 있다. 한 편, 아웃바운드 솔루션 큐에 문제 출력을 추가하는 것은 인바운드 문제 큐를 업데이트하는 것을 포함 할 수 있다. 예를 들어, 인바운드 문제 큐 내의 입력 문제는 \"완료\" 상태로 업데이트될 수 있고/있거나 인바운드 문제 큐로부터 제거될 수 있다. 문제 출력의 생성은 입력 문제에 대한 최적화된 솔루션들을 결정하기 위해 사용되는 컨테이너 인스턴스들을 스 케일링 다운하는 것을 더 포함할 수 있다. 입력 문제를 해결하고 핸들링하기 위해 문제 출력이 생성됨에 따라, 입력 문제에 대한 최적화된 솔루션들을 결정하기 위한 컨테이너 인스턴스들의 실행은 더 이상 필요하지 않으며, 이러한 컨테이너 인스턴스들은 중단, 일시 정지 및/또는 종료될 수 있다. 일부 실시예들에서, 일부 컨테이너 인스턴스들은 인바운드 문제 큐에 의해 식별된 다른 입력 문제에 대한 최적화된 솔루션들을 결정하도록 전 용(redirect)될 수 있고, 그에 따라 인바운드 문제 큐로부터 입력 문제에 대한 문제 특징들을 수신 및/또 는 검색할 수 있다. 그러나, 일부 사례들에서, 다른 입력 문제가 이용가능하지 않을 수 있고, 솔루션을 결정할 입력 문제가 없는 경우, 컨테이너 인스턴스가 종료될 수 있다. 따라서, 실행 중인 컨테이너 인스턴스들의 카운 트는 유연하고, 인바운드 문제 큐 내의 입력 문제들의 볼륨에 적어도 부분적으로 기초한다. 도 4로 돌아가서, 단계/동작 405는 클라이언트 컴퓨팅 엔티티에 문제 출력을 제공하는 것을 포함한다. 언 급한 바와 같이, 문제 출력은 입력 문제에 대한 최적화된 솔루션을 포함할 수 있다. 다양한 실시예들에서, 문 제 출력은 유형 불가지론적 문제 해결 API 요청(예를 들어, 단계/동작 401에서 수신됨)에 응답하여 유형 불가지 론적 문제 솔루션 API 응답을 통해 클라이언트 컴퓨팅 엔티티에 제공된다. 유형 불가지론적 문제 솔루션 API 응답은 상이한 문제 유형의 상이한 입력 문제에 대한 솔루션을 제공하는 데 사용된다. 문제 출력은 클라이 언트 컴퓨팅 엔티티의 디스플레이를 통해 제공되도록 추가적으로 구성될 수 있다. 다양한 실시예들에서, 문제 출력은 요청 관리 엔진을 통해 클라이언트 컴퓨팅 엔티티에 제공된다. 문제 출력은 특히 유형 불가지론적 문제 해결 API 요청이 수신된 가용성 구역(510A-B)에 대응하는 요청 관리 엔 진을 통해 제공될 수 있다. 문제 출력을 제공함에 있어서, 요청 관리 엔진은 아웃바운드 솔루션 큐 와 통신하도록 구성된다(예를 들어, 아웃바운드 솔루션 큐로부터 적어도 최적화된 솔루션을 수신 또 는 검색한다). 문제 출력을 제공한 후, 아웃바운드 솔루션 큐가 업데이트될 수 있으며, 구체적으로 아웃 바운드 솔루션 큐 내의 문제 솔루션이 삭제된다. 따라서, 컨테이너화된 클라우드 기반(예를 들어, 서버리스) 방식으로 입력 문제에 대한 최적화된 솔루션을 결정 하기 위한 다양한 단계, 동작, 방법, 프로세스, 기타 등등이 본 명세서에서 설명된다. 예시적인 실시예에서, 클라이언트 컴퓨팅 엔티티로부터 비롯되는 유형 불가지론적 문제 해결 API 요청이 수신된다. 유형 불가지 론적 문제 해결 API 요청이 처리되고(예를 들어, 검증되고), 유형 불가지론적 문제 해결 API에 의해 정의된 입 력 문제가 (예를 들어, 요청 관리 엔진에 의해) 인바운드 문제 큐에 추가된다. 컨테이너 관리 엔진 은 인바운드 문제 큐를 통해 입력 문제를 통보받고, (예를 들어, 요청 관리 엔진에 의해) 입력 문제에 매핑된 솔버 유형과 각각 연관된 하나 이상의 컨테이너 인스턴스를 생성한다. 하나 이상의 컨테이너 인 스턴스의 실행은 집계이거나, 조합이거나, 다양한 솔버 유형들에 따라 결정된 다양한 최적화된 솔루션들에 적어 도 부분적으로 기초할 수 있는 문제 출력의 생성을 초래한다. 문제 출력은 아웃바운드 솔루션 큐에 추가 되는 반면, 입력 문제는 인바운드 문제 큐로부터 제거된다. 그 다음, 문제 출력은 (예를 들어, 요청 관리 엔진을 통해) 유형 불가지론적 문제 솔루션 API 응답을 통해 클라이언트 컴퓨팅 엔티티에 제공된다. 본 명세서에 설명된 다양한 실시예들은 입력 문제들의 볼륨에 대한 최적화된 솔루션들의 유연하고 탄력적인 결 정을 가능하게 함으로써 다양한 기술적 이점들을 제공한다. 다양한 예시적인 사례들에서, 컴퓨팅 및 처리 자원 들은 우선순위를 갖는 특정 입력 문제들에 대해 전환, 할당, 예약, 기타 등등이 될 수 있고, 컴퓨팅 및 처리 자 원들은 입력 문제들의 볼륨이 낮을 때 보존될 수 있다. 따라서, 본 개시의 다양한 실시예들에서 입력 문제들에 대한 최적화된 솔루션들의 클라우드 기반 및 서버리스 결정은 컴퓨팅 및 처리 자원들의 효율적이고 유연하고 탄 력적인 사용을 초래하며, 이는 추가로 시간 및 실제 비용의 보존으로 이어진다. 또한, 다양한 솔버 유형에 대한 컴퓨팅 컨테이너들의 사용은 컴퓨팅 컨테이너의 다수의 컨테이너 인스턴스가 컴퓨팅 및 처리 자원들을 과도 하게 소비하지 않고 실질적으로 병렬로 실행될 수 있으므로 유연성과 스케일링 가능성을 가능하게 한다. 컴퓨 팅 컨테이너의 컨테이너 인스턴스들은 상이한 입력 문제들에 대한 최적화된 솔루션을 결정하기 위해 실행될 수 있으며, 이에 따라 다수의 입력 문제를 효율적으로 핸들링하고 처리할 수 있다. 일부 실시예들에서, 예측 출력은 하나 이상의 예측 기반 액션을 수행하기 위해 (예를 들어, 클라이언트 컴퓨팅 엔티티에 의해) 사용될 수 있다. 예측 기반 액션들의 예는 자동화된 스케줄링, 자동화된 통지들의 생성, 네트 워크/시스템(예컨대, 트러킹 네트워크(trucking network)와 같은 트랜잭션 네트워크)에 대한 자동화된 로드 밸 런싱 동작들, 기타 등등을 포함한다. 일부 실시예들에서, 예측 기반 액션들을 수행하는 것은 하나 이상의 예측 출력을 디스플레이하는 예측 출력 사용자 인터페이스를 생성하는 것을 포함한다. 이러한 예측 출력 사용자 인 터페이스들의 동작 예는 도 8의 예측 출력 사용자 인터페이스이다. 도 8에 도시된 바와 같이, 예측 출력 사용자 인터페이스는 텍스트 박스에 의해 식별된 트럭에 대한 권장된 로드 전달 스케줄(load delivery schedule)을 설명하며, 권장된 로드 전달 스케줄은 하나 이상의 예측 출력에 적어도 부분적으로 기초 하여 결정될 수 있다. VI. 예시적인 구현 클라우드 기반 다중 도메인 솔버 시스템(때때로 본 명세서에서 \"제약 최적화기\" 또는 \"최적화된 스케줄 러\"로 지칭됨)의 일부 특정 실시예들이 이제 도 9-18을 참조하여 설명된다. 솔버 시스템은, 예를 들어 활 동 스케줄링(activity scheduling)과 같은, 자산 집약적인 조직들이 직면하는 주요 문제들을 다루는 제약 기반 계획 도구(constraint-based planning tool)이다. 최적화 알고리즘을 사용하여, 다양한 제약 하에서 제한된 자 원을 취하고 산업 계획 목표를 최적화하는 효율적인 솔루션들을 전달한다. 이는 전형적인 계획(예를 들어, 스 케줄링) 작업들(exercises)에서 복잡성과 수동 프로세스를 제거하여 비용을 절감하고 효율성을 개선하는 것을 도울 수 있다. 예시적인 실시예들은 Intergraph Corporation 및 이전에 Infor(US), LLC로부터 Infor™ EAM(Enterprise Asset Management) 시스템을 통해 지원되는 산업 및 능력(capabilities)을 위해 구성되지만, 실시예들은 다양한 시스템에 걸쳐 보다 일반적인 사용을 위해 구성될 수 있다는 점에 유의해야 한다. 하나의 예시적인 실시예에서, 2개의 산업, 즉 예를 들어 승무원(crews) 또는 직원이 다양한 계획된 활동을 수행하기 위 해 정적 장비 위치들(static equipment locations)로 이동하기 위해 이용가능한 활동들 및 자원들에 기초하여 실시예들이 하루종일의 스케줄 및 루트 시퀀스(route sequence)를 생성할 수 있는 MFS(Maintenance Field Service) 및 실시예들이 주어진 계획 대상기간(planning horizon), 예산 및 유지할 자산들/프로젝트들의 리스트 에 대한 자산 투자 액션 계획들을 생성할 수 있는 AIP(Asset Investment Planning)가 지원된다. 도 9는 도 10-18 전체에서 사용되는 심볼들의 범례이다. 이러한 심볼들 중 다수는 특정 실시예들에서 사용되는 다른 벤더들로부터의 제품들 또는 서비스들을 지칭하며, 이러한 임의의 참조들은 상표 지정 없이 사용되거나 부 정확한 상표 지정과 함께 사용되는지 여부와 관계없이 그들 각각의 상표들을 형용사로서 그리고 적절한 상표 명 칭(예를 들어, (R) 대 (TM))과 함께 사용하는 그러한 제품들 또는 서비스들을 지칭하기 위한 것이라는 점에 유 의해야 한다. 예를 들어, Amazon, AWS, EC2, S3, 이벤트브리지(EventBridge), MQ 및 DynamoDB는 미국 및/또는 기타 국가에서 Amazon.com, Inc. 또는 그 계열사의 상표들 또는 등록 상표들로 간주되며, 이러한 제품들 및 서 비스들에 대한 참조는 그들 각각의 상표를 형용사로 그리고 적절한 상표 지정과 함께 사용하는 대응하는 제품들 또는 서비스들을 지칭하는 것으로 해석되어야 한다. 또한, 많은 경우에, 다른 소스로부터의 대안적인 제품 또 는 서비스(예를 들어, 상이한 클라우드 서비스들, 상이한 데이터베이스 서비스들, 상이한 통신 프로토콜들 등) 가 다양한 대안적인 실시예들에서 사용될 수 있다는 점에 유의해야 한다. 도 10은 다양한 실시예들에 따른 클라우드 기반 다중 도메인 솔버 시스템의 세부사항들을 도시하는 개략도 이다. 특히, 클라우드 기반 다중 도메인 솔버 시스템은 요청 서비스, 응답 (솔버) 서비스(때때로 본 명세서에서 단순히 \"솔버\"로 지칭됨), 및 응답 (솔버) 프리프로세서(때때로 본 명세서에서 단순히 \"프 리프로세서\"로 지칭됨)를 포함한다. 솔버는 다양한 애플리케이션들에 내장될 수 있는 마이크로서 비스들인 다양한 스케줄러(도메인) 플러그인들을 통해 호출된다. 이러한 모든 컴포넌트는 아래에서 더 상세히 설명된다. 도 11은 도 10의 클라우드 기반 다중 도메인 솔버 시스템의 추가적인 세부사항들, 특히 다양한 컴포넌트들 이 클라우드 배치 환경 내에서 논리적으로 그리고 물리적으로 상호 연결되는 방법을 도시하는 개략도이다. 특히, 솔버 시스템은 시스템의 클라이언트들을 검증하는 제약 최적화기 프로비저닝(constraint optimizer provisioning) API를 포함한다. 구체적으로, 시스템이 특정 고객 ID를 처음 수신할 때, 고객 ID는 프로비저닝 API를 통해 검증되고, 데이터베이스에 유지되며, 이어서 해당 클라이언트로부터 요청 해결 트랜잭션이 수신될 때마다, 시스템은 클라이언트가 유효하고 솔버 서비스를 사용할 수 있다는 것을 확인할 수 있다. 제약 스케줄러 요청 서비스는 Infor™ 클라우드에서 실행될 도커™ 컨테이너에 래핑(wrapping)된 웹 서비 스이다. 요청 서비스의 일차적인 책임은 이 실시예에서 아래에서 더 상세히 설명되는 REST API인 공개 제약 스케줄러 API를 통해 다양한 클라이언트 컴퓨팅 엔티티들로부터의 웹 서비스 요청들을 핸들링하는 것이다. 요청 서비스는 또한 요청들이 인바운드 큐에 추가됨에 따라 솔버의 인스턴스들을 생성하 는 것을 담당한다. 시스템은, 예를 들어 상이한 가용성 구역들에서 실행되는 요청 서비스의 다수의 인스 턴스(예를 들어, 요청 서비스의 2개의 인스턴스)를 실행할 수 있다. 도 12a는 도 11의 요청 서비스 블록의 세부사항들을 도시하는 개략도이다. 도 12b는 컨테이너 내의 개별 가용성 구역들에서 실행되는 2개의 요청 서비스 인스턴스를 도시하는 개략도이다. 요청 서비스의 컴포넌트들은 REST API 인터페이스, 요청 검증기, 컨트롤러, 솔버 초기화기, 솔루션 초기화기, JMS(Java Message Service) 및 SDR(Spring Data Redis)을 실행하는 추상화 계층, 및 로거(logger)를 포함한다. 제약 스 케줄러 REST API는 검증 후에 요청을 수락하고, 요청을 솔버에 의해 처리되도록 인바운드 큐로 푸시한다. 솔루 션이 솔버에 의해 생성되고 아웃바운드 큐에 배치되면, 요청 서비스의 솔루션 리스너(solution listener)가 솔루션을 클라이언트로 반환한다. 제약 스케줄러 솔버는 Infor™ 클라우드에서 실행될 도커™ 컨테이너에 래핑된 마이크로서비스이다. 시 스템은 솔버의 별개의 인스턴스들을 생성할 수 있으며, 따라서 클라우드에서 실행되는 영구적 존재를 가 질 필요가 없다(예를 들어, 제약 스케줄러 인스턴스들은 상태 비보전형(stateless)일 수 있다). 제약 스케줄 솔버는 인바운드 큐로부터 요청들을 풀링(pulling)하고, 솔루션을 생성하고, 솔루션을 아웃바운드 큐로 푸시하는 것을 담당한다. 솔버의 인스턴스들은 요청 서비스의 스케일링 알고리즘에 의해 동적으로 생성된다. 솔버는 또한 더 이상 필요하지 않은 인스턴스들을 다운 스케일링하는 것을 담당한다. 솔버 인스턴스가 솔루션을 완료할 때, 그것은 큐에서 다른 요청을 풀링하려고 시도한다. 그것은 미리 결정된 기간 동안 요청을 풀링할 수 없는 경우, 인스턴스를 삭제하고 파게이트 컨테이너(Fargate container)를 제거할 것이다. 도 13a는 도 11의 응답 (솔버) 서비스 블록의 세부사항들을 도시하는 개략도이다. 도 13b는 컨테이너 내 의 가용성 구역에서 실행되는 다수의 생성된 솔버 인스턴스를 도시하는 개략도이다. 솔버의 컴포 넌트들은 인바운드 큐로부터 요청들을 풀링하고, 솔버 인스턴스를 생성하는 요청 리스너, 각각의 인스턴 스에 대한 솔버 엔진/컨트롤러 및 제약 매퍼, 솔루션들이 아웃바운드 큐로 푸시되는 JMS(Java Message Service) 및 SDR(Spring Data Redis)을 실행하는 추상화 계층, 및 로거를 포함한다. 전술한 바와 같이, 솔버 인스턴스들은 이 예시적인 실시예에서 상태 비보전형이다. 모든 상태 정보는 중 복성(redundancy)을 갖는 클라우드 관리 컴포넌트들에 유지된다. 큐들은 요청들이 제거되기 전에 처리되는 것 을 보장한다. 시스템은 시스템의 일부 컴포넌트가 실패하더라도 동작 상태를 유지하도록 내장애성(fault tolerance)을 갖도록 설계된다. 다수의 가용성 구역(AZ)에 애플리케이션들을 배치하기 위해, 각각의 AWS 영역은 논리적으로 가용성 구역(AZ)으 로 그룹화된 데이터 센터들의 모음이다. AWS 영역들은 물리적으로 분리되고 격리된 다수(전형적으로 3개)의 가 용성 구역을 제공하며, 가용성 구역들은 짧은 레이턴시, 높은 처리량 및 높은 중복성 네트워킹으로 연결된다. 각각의 AZ는 하나 이상의 물리적 데이터 센터로 구성된다. 가용성 구역들은 물리적 중복성을 위해 설계되며, 복원력(resilience)을 제공하여, 정전, 인터넷 비가동시간, 홍수 및 기타 자연 재해가 발생하는 경우에도 중단 없는 수행을 가능하게 한다. 탄력적 로드 밸런싱(ELB)을 사용하여 개선된 내장애성이 제공되는데, 이는 ELB 서 비스가 다수의 가용성 구역에서 다수의 인스턴스에 걸쳐 트래픽을 자동으로 밸런싱하여 \"정상적인(healthy)\" 인 스턴스들만이 트래픽을 수신하도록 보장하기 때문이다. 시스템은 정상적인 자원들에 대한 자동화된 트래픽 라 우팅에 의해 바람직하게 2개 이상의 가용성 구역에서 각각의 애플리케이션 스택의 독립적인 사본(independent copy)을 실행한다. 다중 AZ 배치는 구역들 중 하나에서 가용성 손실, 네트워크 연결 손실, 컴퓨터 유닛 실패 또는 저장 실패가 발생하는 경우 애플리케이션 실패를 완화한다. 도 13c는 2개의 가용성 구역에서 각각의 애플 리케이션 스택의 독립 사본을 실행하기 위한 탄력적 로드 밸런싱을 도시하는 개략도이다. 특정 실시예들에서, 다수의 AZ 배치는 레디스(Redis) 복제 그룹들에서 인에이블된다. 다수의 AZ가 인에이블되는지 여부에 관계없이, 실패한 1차 노드가 자동으로 검출되고 교체된다. 그러나 이것이 발생하는 방식은, 다수의 AZ가 인에 이블되는지 여부에 기초하여 달라진다. 예를 들어, 다수의 AZ가 인에이블되는 경우, ElastiCache는 1차 노드실패(primary node failure)를 검출하고, 복제 지연이 가장 적은 판독 복제본 노드(read replica node)를 1차 노드로 승격(promote)시키고, 다른 복제본은 새로운 1차 노드와 동기화되고, ElastiCache는 실패한 1차 노드의 AZ에서 판독 복제본을 스핀업(spin up)하고, 새로운 노드는 새로 승격된 1차 노드와 동기화된다. 복제본 노드 로의 대체 작동(failing over)은 일반적으로 새로운 1차 노드를 생성하고 프로비저닝하는 것보다 빠르며, 이는 솔버 애플리케이션이 다중 AZ가 인에이블되지 않은 경우보다 더 빨리 1차 노드에 기입을 재개할 수 있게 한다. 특정 실시예들에서, 활성/대기 브로커는 중복 쌍으로 구성된 2개의 상이한 가용성 구역 내의 2개의 브로커로 구 성된다. 이러한 브로커들은 솔버 애플리케이션 및 아마존 EFS(브로커 저장소)와 동기식으로 통신한다. 전형적 으로, 브로커 인스턴스들 중 하나만이 항상 활성이고, 다른 브로커 인스턴스는 대기 상태에 있다. 브로커 인스 턴스들 중 하나가 오작동하거나 유지 보수를 받는 경우, 아마존 MQ가 비활성 인스턴스를 서비스에서 제외하는데 조금 시간이 걸린다. 이는 정상적인 대기 인스턴스가 활성화되고 들어오는 통신을 수락하기 시작하게 할 수 있 다. 브로커를 리부팅할 때, 대체 작동은 몇 초밖에 걸리지 않는다. 도 13d는 아마존 EFS 저장소를 갖는 활성/ 대기 브로커를 도시하는 개략도이다. 솔버에서의 스프링 JMS 세션들은 메시지에 대해 트랜잭션 승인 모드를 사용하도록 구성된다. 어떤 이유로든 솔 버 앱이 충돌하는 경우, ActiveMQ 서버는 요청 메시지를 재전달(redeliver)한다. 이는 인스턴스 충돌 시 임의 의 요청 메시지의 손실을 방지한다. 스프링 JMS 세션은 예외가 발생한 경우 재전달 없이 리스너 실행 전에 자 동 메시지 승인을 위해 \"sessionAcknowledgeMode\"를 \"AUTO_ACKNOWLEDGE\"(디폴트)로 설정하거나, 예외가 발생한 경우 재전달 없이 성공적인 리스너 실행 후에 자동 메시지 승인을 위해 \"sessionAcknowledgeMode\"를 \"CLIENT_ACKNOWLEDGE\"로 설정하거나, 예외가 발생한 경우 잠재적 재전달과 함께 리스너 실행 동안 또는 후에 지 연(lazy) 메시지 승인을 위해 \"sessionAcknowledgeMode\"를 \"DUPS_OK_ACKNOWLEDGE\"로 설정하거나, 예외가 발생 한 경우 재전달을 보장하면서 성공적인 리스너 실행 후에 트랜잭션 승인을 위해 \"sessionTransacted\"를 \"true\" 로 설정하도록 구성될 수 있다. 전술한 바와 같이, 다양한 실시예들에서, 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하는 것은 입력 문제의 문제 특징들에 적어도 부분적으로 기초하여 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하도록 구성되는 문제 유형에 대한 솔버 선택 기계 학습 모델에 입력 문제의 하나 이상의 문제 특 징을 제공하는 것을 포함한다. 도 10-11의 맥락에서, 이 기능은 기계 학습 알고리즘 모델 생성기 및 기계 학습 알고리즘 선택기를 포함하는 스케줄러 솔버 도메인을 통해 응답 (솔버) 프리프로세서에 의해 수행된다. 도 14는 도 11의 응답 (솔버) 프리프로세서 블록의 세부 사항들을 도시하는 개략도이다. 전술한 바와 같 이, 용어 \"솔버 유형\"은 문제를 해결하기 위한 또는 문제에 대한 솔루션을 결정하기 위한 알고리즘, 휴리스틱, 방법, 기타 등등의 유형을 설명하도록 구성되는 데이터 구조체를 지칭하고 설명할 수 있으며, 유형은 대응하는 문제의 문제 유형에 적어도 부분적으로 기초하여 결정될 수 있다. 입력 문제에 대한 솔루션은 각각이 상이한 정확도 및 상이한 효율을 갖는 솔루션을 제공하는 다수의 상이한 솔버 유형을 사용하여 결정될 수 있다는 것을 알 수 있다. 외판원 입력 문제를 예시적인 예로서 참조하면, 무작위 대입 솔버 유형, 제1-적합 솔버 유형, 최 강-적합 솔버 유형, 타부-탐색 솔버 유형, 시뮬레이티드-어닐링 솔버 유형, 지연 수락 솔버 유형, 언덕 오르기 솔버 유형, 전략적 진동 솔버 유형, 기타 등등을 사용하여 솔루션이 결정될 수 있다. 다항식 문제의 경우, 다 양한 솔버 유형은 입력 문제를 해결하거나 문제에 대한 정확한 솔루션을 결정하기 위한 알고리즘, 휴리스틱, 방 법, 기타 등등을 설명할 수 있다. 비결정론적 다항식 문제들의 경우, 다양한 솔버 유형은 입력 문제에 대한 제 안된 솔루션을 결정하는 것은 물론, 입력 문제에 대해 제안된 솔루션의 \"정확성\" 또는 정확도를 결정하기 위한 알고리즘들, 휴리스틱들, 방법들, 기타 등등을 설명할 수 있다. 도 10을 다시 참조하면, 알고리즘 모델 생성기는 정기적으로 실행되어 DynamoDB의 분석으로부터 솔버 유형 모델 을 생성하고 S3 클라우드에 모델을 저장한다. ML 알고리즘 선택기는 S3 클라우드로부터 메모리로 모델을 로딩 한다. 요청 서비스는 요청을 검증하여 인바운드 큐에 배치하고 전처리를 위해 요청에 플래그(flag)를 첨부한다. 큐 선택기는 전처리가 필요한 요청들을 필터링하고 이러한 요청들을 솔버 프리프로세서로 재지향시 킨다. 솔버 프리프로세서는 ML 알고리즘 선택기에 알고리즘을 선택하도록 요청하고, 큐에서 원래 요청을 제거 하고, 전처리 플래그가 턴오프된 상태에서 업데이트된 요청을 큐로 다시 푸시한다. 일반적으로, 알고리즘 선택 기는 요청을 분석하여 관련된 문제의 유형(예를 들어, 차량 라우팅 문제)을 결정하고, 요청된 문제에 대해 다수 의 솔버 유형 모델이 이용가능하다고 가정하면, ML 알고리즘 선택기는 다양한 제약에 기초하여 최상의 모델을 선택한다. 솔버는 큐에서 요청을 풀링하고, 솔루션을 생성하고, 솔루션을 아웃바운드 큐로 푸시한다. 솔버는 향후 모델 생성을 위해 DynamoDB에 분석을 기록한다.도 11에 도시된 실시예에서, 도메인 특유 클라이언트 컴퓨팅 엔티티들(클라이언트들)은 다수의 상이한 도 메인 특유 클라이언트 컴퓨팅 엔티티들이 플러그-앤-플레이 방식으로, 예를 들어, 새로운 도메인들에 대한 지원 이 시스템에 추가됨에 따라, 시스템에 추가되고 그로부터 제거될 수 있게 하도록 바람직하게 구성되는 다중 도 메인 REST(Representational State Transfer) API를 통해 제약 최적화 스케줄러에 액세스한다. 도 15는 도 11의 실시예에 따른 REST API의 세부 사항들을 도시하는 개략도이다. 상이한 도메인 특유 클라이언 트 컴퓨팅 엔티티들은 상이한 파라미터들을 이용할 수 있고, REST API는 이러한 도메인 특유 클라이언트 컴퓨팅 엔티티들이 예를 들어 JSON 또는 다른 적절한 표현 포맷을 사용하여 상태 비보존 방식으로 요청을 행하는 시간 에 도메인 특유 정보를 제약 최적화 스케줄러로 송신함으로써 이러한 공통 API를 이용할 수 있게 한다. 도 16은 다수의 도메인 특유 클라이언트 컴퓨팅 엔티티가 공통 REST API를 통해 솔버 시스템에 액세스할 수 있 는 방법을 도시하는 개략도이다. 이 예에서는, EAM 승무원 디스패치 플러그인 클라이언트, EAM 자산 투자 플러 그인 클라이언트 및 향후 플러그인 클라이언트들이 추가될 여지가 있다. REST API는 하위 호환성(backward compatibility)을 손상시키지 않고 새로운 기능을 추가할 수 있는 확장 가능한 API를 제공한다. 그것은 사람이 읽고 쓰기 쉽고 기계가 파싱(parse) 및 생성하기 쉬운 경량 데이터 교환 포맷(lightweight data-interchange format)인 JSON을 사용한다. API는 개방(Open) API 사양에 기초한다. REST API는 상이한 도메인들에 대한 상 이한 사양들 및 속성들과 연관되며, 이는 클라이언트가 필요한 도메인을 갖는 API만을 사용할 수 있게 하고, 솔 버 시스템이 도메인 특유 정보가 포함된 응답을 클라이언트에 송신할 수 있게 한다. 특정 실시예들에서, REST API는 4개의 프리미티브(primitives), 즉 솔버에 요청을 송신하기 위한 POST/해결 프 리미티브, 식별된 솔루션을 요청하기 위한 GET/솔루션/{id} 프리미티브, 식별된 스케줄러 실행의 상태를 요청하 기 위한 GET/상태/{id} 프리미티브, 및 식별된 솔버 실행을 취소하기 위한 POST/취소/{id} 프리미티브를 포함한 다. 클라이언트는 솔버 시스템에 해결 요청을 송신한다. 이 요청은 일부 요청이 오래 실행되는 것이 예상되므로 응 답이 비동기적으로 전달되어야 하기 때문에 POST이다. 해결 요청의 데이터 페이로드는 활동 및 에이전트에 대 한 정적 필드를 포함하고, 또한 스케줄러 유형 및 기간에 대한 동적 필드도 포함한다. 정적 필드와 동적 필드 를 모두 사용하면 API를 쉽게 확장할 수 있다. 정적 필드 개념은 하위 호환성을 손상시키는 것을 피하기 위해 필드들을 변경할 수 없음을 의미한다. 그러나, 그들은 기존 객체에 선택적 필드들(optional fields)을 추가하 여 확장될 수 있다. 동적 필드 개념은 하위 호환성을 손상시키지 않고 필드를 변경하고 확장할 수 있음을 의미 한다. 이는 새로운 스키마(schema)를 생성하고 이를 동적 필드의 새로운 선택사항으로서 추가하여 수행될 수 있다. 모든 동적 필드는 다른 JSON 객체들에 의해 참조될 ID를 포함하여야 한다. 시스템은 유사한 콜백 API를 통해 클라이언트에게 응답을 제공한다. 솔루션 방법 바디는 2개의 주요 JSON 스키 마, 배정된 활동 및 배정되지 않은 활동을 갖는다. 배정된 활동은 솔버가 성공적으로 배정할 수 있었던 활동이 고, 배정되지 않은 활동은 솔버에 의해 배정될 수 없었다. 스키마는 추가 능력을 가능하게 하도록 확장될 수 있다. 차량 라우팅 문제(VRP)는 물론 다른 애플리케이션을 해결하는 것은, 예컨대 이론적인 외판원 문제에 대한 적절 한 루트를 결정하기 위해 거리 정보에 액세스하는 것을 필요로 할 수 있다. 따라서, 시스템은 거리 및 매핑 정 보(예를 들어, OpenStreetMap 정보)가 획득될 수 있는 일반적인 거리 서비스를 포함할 수 있다. 도 17은 특정 실시예들에 따른, VRP 솔버에 의해 사용되는 거리 서비스를 도시하는 개략도이다. 거리 서비스는 OpenStreetMap 데이터 및 다른 데이터와 통합되는 그래프호퍼(GraphHopper) 라우팅 서비스를 이용한다. 시스템 은 Dijkstra, A*, 랜드마크 및 수축 계층구조(Contraction Hierarchies)와 같은 다양한 거리 알고리즘들 중 임 의의 것을 사용할 수 있으며, 도보, 자동차, 자전거 및 대중 교통과 같은 다양한 교통 모드들 중 임의의 것에 대한 스케줄링을 포함할 수 있다. 도 18은 특정 실시예들에 따른 솔버 트랜잭션의 진행을 도시하는 흐름도이다. 클라이언트(플러그인)는 클라이 언트를 검증하는 REST API를 통해 요청 서비스에 요청을 송신하며, 클라이언트가 검증되었다고 가정하면, 요청 을 검증하고 요청을 인바운드 큐로 푸시한다. 솔버는 인바운드 큐에서 요청을 풀링하고, 요청을 해결하고, 아 웃바운드 큐로 솔루션을 푸시한다. 이 프로세스 전반에서, 솔버는, 예를 들어 상태 정보를 업데이트하여 솔버 가 요청을 처리하는 시점과 솔버가 요청을 완료한 시점을 표시한다. 응답 서비스는 아웃바운드 큐에서 솔루션 을 풀링하고 콜백 API를 통해 클라이언트로 솔루션을 송신한다. VII. 잠재적 청구항들 본 발명의 다양한 실시예들은 이 단락 다음의(그리고 출원의 끝에 제공된 실제 청구항들 이전의) 단락들에 열거 된 잠재적 청구항들에 의해 특징지어질 수 있다. 이러한 잠재적 청구항들은 출원에 대한 서면 설명의 일부를 형성한다. 따라서, 다음의 잠재적 청구항들의 주제는 본 출원 또는 본 출원에 기초하여 우선권을 주장하는 임 의의 출원을 수반하는 추후 절차들에서 실제 청구항들로서 제시될 수 있다. 이러한 잠재적 청구항들의 포함은 실제 청구항들이 잠재적 청구항들의 주제를 커버하지 않는다는 의미로 해석되어서는 안 된다. 따라서, 추후 절 차들에서 이러한 잠재적 청구항들을 제시하지 않기로 하는 결정은 주제를 대중에게 기부하는 것으로 해석되어서 는 안 된다. 이러한 잠재적 청구항들은 다양한 추구되는 청구항들을 제한하는 것을 의도하지도 않는다. 제한 없이, 청구될 수 있는 잠재적 주제(아래에 제시된 실제 청구항과의 혼동을 피하기 위해 문자 \"P\"가 앞에 붙음)는 다음을 포함한다: P1. 컴퓨터 구현 방법으로서, 하나 이상의 프로세서를 사용하여, 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입 력 문제의 문제 유형을 수신하는 단계; 하나 이상의 프로세서를 사용하여, 문제 유형을 하나 이상의 선택된 솔 버 유형에 매핑하는 단계; 하나 이상의 프로세서를 사용하여, 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테 이너 인스턴스를 생성하는 단계 - 각각의 컴퓨팅 컨테이너는 선택된 솔버 유형에 대응함 -; 하나 이상의 프로세 서를 사용하여, 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하는 단계; 및 하나 이상의 프로세 서를 사용하여, 문제 출력을 클라이언트 컴퓨팅 엔티티에 제공하는 단계를 포함하고, 문제 출력은 입력 문제에 대한 최적화된 솔루션을 포함하고, 문제 출력은 하나 이상의 예측 기반 액션을 수행하는 데 사용될 수 있는, 컴 퓨터 구현 방법. P2. 제P1항에 있어서, 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 단계는: 입력 문제의 문제 유형 및 입력 문제의 하나 이상의 문제 특징에 적어도 부분적으로 기초하여 솔버 도메인을 결정하는 단계; 솔버 도메 인과 연관된 도메인별 솔버 유형들의 세트를 식별하는 단계; 및 도메인별 솔버 유형들의 세트로부터 하나 이상 의 선택된 솔버 유형을 결정하는 단계를 포함하는, 컴퓨터 구현 방법. P3. 제P2항에 있어서, 입력 문제의 문제 유형 및 입력 문제의 하나 이상의 문제 특징은 유형 불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스(API) 요청을 통해 수신되고, 문제 출력은 유형 불가지론적 문제 솔루 션 API 응답을 통해 클라이언트 컴퓨팅 엔티티에 제공되는, 컴퓨터 구현 방법. P4. 제P3항에 있어서, 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들을 설명하도록 구성된 복수의 정적 필드를 포함하는, 컴퓨터 구현 방법. P5. 제P2항에 있어서, 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하는 단계는 입력 문제의 문제 특징들에 적어도 부분적으로 기초하여 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하도 록 구성되는 문제 유형에 대한 솔버 선택 기계 학습 모델에 입력 문제의 하나 이상의 문제 특징을 제공하는 단 계를 포함하는, 컴퓨터 구현 방법. P6. 제P1항에 있어서, 입력 문제의 문제 유형은 서버 클라우드 기반구조에 고유하고 하나 이상의 가용성 구역 중 하나에 대응하는 서버리스 요청 관리 엔진에서 수신되는, 컴퓨터 구현 방법. P7. 제P1항에 있어서, 하나 이상의 컨테이너 인스턴스는 서버 클라우드 기반구조에 고유한 서버리스 컨테이너 관리 엔진에 의해 관리되는, 컴퓨터 구현 방법. P8. 제P7항에 있어서, 서버리스 컨테이너 관리 엔진은 선택된 솔버 유형들의 총 카운트에 적어도 부분적으로 기 초하여 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성되는, 컴퓨터 구현 방법. P9. 제P7항에 있어서, 인바운드 문제 큐가 입력 문제를 식별하도록 업데이트되고, 서버리스 컨테이너 관리 엔진 은 인바운드 문제 큐에 의해 식별된 문제들의 수에 적어도 부분적으로 기초하여 하나 이상의 선택된 솔버 유형 에 대한 컨테이너 인스턴스들의 총 카운트를 스케일링하도록 구성되는, 컴퓨터 구현 방법. P10. 제P1항에 있어서, 문제 출력을 생성하는 단계는: 하나 이상의 컨테이너 인스턴스의 실행에 적어도 부분적 으로 기초하여 생성된 하나 이상의 컨테이너 출력을 수신하는 단계; 및 하나 이상의 컨테이너 출력에 적어도 부 분적으로 기초하여 문제 출력을 생성하는 단계를 포함하는, 컴퓨터 구현 방법. P11. 제P1항에 있어서, 각각의 실행 반복 동안에 각각의 컨테이너 인스턴스의 실행을 모니터링하고, 실행 반복 의 반복별 최적화 이득이 구성 가능한 반복별 최적화 이득 임계치를 충족시키지 못하는 경우 컨테이너 인스턴스 의 실행을 중단하는 단계를 더 포함하는, 컴퓨터 구현 방법.P12. 제P1항에 있어서, 컨테이너 인스턴스의 실행은 인바운드 문제 큐에 의해 식별된 하나 이상의 문제 각각에 대한 컨테이너 출력을 병렬로 생성하도록 구성되는, 컴퓨터 구현 방법. P13. 클라우드 기반 시스템으로서, 하나 이상의 프로세서 및 하나 이상의 메모리 저장 영역을 포함하고, 하나 이상의 프로세서 및 하나 이상의 메모리 저장 영역은 서버리스 방식으로 동적으로 할당되도록 구성되고, 클라우 드 기반 시스템은: 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하고; 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하고; 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하고 - 각각의 컴퓨팅 컨테이너는 선택된 솔버 유형에 대응함 -; 하나 이상의 컨테이너 인스턴스를 사용하 여 문제 출력을 생성하고; 문제 출력을 클라이언트 컴퓨팅 엔티티에 제공하도록 구성되며, 문제 출력은 입력 문 제에 대한 최적화된 솔루션을 포함하고, 문제 출력은 하나 이상의 예측 기반 액션을 수행하는 데 사용될 수 있 는, 클라우드 기반 시스템. P14. 제P13항에 있어서, 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑하는 것은: 입력 문제의 문제 유형 및 입력 문제의 하나 이상의 문제 특징에 적어도 부분적으로 기초하여 솔버 도메인을 결정하는 것; 솔버 도메인 과 연관된 도메인별 솔버 유형들의 세트를 식별하는 것; 및 도메인별 솔버 유형들의 세트로부터 하나 이상의 선 택된 솔버 유형을 결정하는 것을 포함하는, 클라우드 기반 시스템. P15. 제P14항에 있어서, 입력 문제의 문제 유형 및 입력 문제의 하나 이상의 문제 특징은 유형 불가지론적 문제 해결 애플리케이션 프로그래밍 인터페이스(API) 요청을 통해 수신되고, 문제 출력은 유형 불가지론적 문제 솔루 션 API 응답을 통해 클라이언트 컴퓨팅 엔티티에 제공되는, 클라우드 기반 시스템. P16. 제P15항에 있어서, 유형 불가지론적 문제 해결 API 요청은 각각이 상이한 문제 유형들에 걸쳐 문제 특징들 을 설명하도록 구성된 복수의 정적 필드를 포함하는, 클라우드 기반 시스템. P17. 제P15항에 있어서, 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하는 것은 입력 문제의 문제 특징들에 적어도 부분적으로 기초하여 도메인별 솔버 유형들의 세트로부터 선택된 솔버 유형들을 결정하도 록 구성되는 문제 유형에 대한 솔버 선택 기계 학습 모델에 입력 문제의 하나 이상의 문제 특징을 제공하는 것 을 포함하는, 클라우드 기반 시스템. P18. 제P13항에 있어서, 입력 문제의 문제 유형은 하나 이상의 가용성 구역 중 하나에 대응하는 서버리스 요청 관리 엔진에서 수신되는, 클라우드 기반 시스템. P19. 제P13항에 있어서, 하나 이상의 컨테이너 인스턴스는 서버 클라우드 기반구조에 고유한 서버리스 컨테이너 관리 엔진에 의해 관리되는, 클라우드 기반 시스템. P20. 컴퓨터 판독 가능 프로그램 코드 부분들을 저장하고 있는 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하는 컴퓨터 프로그램 제품으로서, 컴퓨터 판독 가능 프로그램 코드 부분들은: 클라이언트 컴퓨팅 엔티티로부터 비롯되는 입력 문제의 문제 유형을 수신하고; 문제 유형을 하나 이상의 선택된 솔버 유형에 매핑 하고; 하나 이상의 컴퓨팅 컨테이너의 하나 이상의 컨테이너 인스턴스를 생성하고 - 각각의 컴퓨팅 컨테이너는 선택된 솔버 유형에 대응함 -; 하나 이상의 컨테이너 인스턴스를 사용하여 문제 출력을 생성하고; 문제 출력을 클라이언트 컴퓨팅 엔티티에 제공하도록 구성되며, 문제 출력은 입력 문제에 대한 최적화된 솔루션을 포함하고, 문제 출력은 하나 이상의 예측 기반 액션을 수행하는 데 사용될 수 있는, 컴퓨터 프로그램 제품. VIII. 결론 전술한 설명들 및 관련 도면들에 제시된 교시의 이익을 갖는 본 개시와 관련된 분야의 통상의 기술자에게는 많 은 수정 및 다른 실시예가 떠오를 것이다. 따라서, 본 개시는 개시된 특정 실시예들로 한정되지 않으며, 첨부 된 청구항 개념들의 범위 내에는 수정들 및 다른 실시예들이 포함되도록 의도된다는 것이 이해되어야 한다. 특 정 용어들이 본 명세서에서 사용되지만, 이들은 일반적이고 설명적인 의미로만 사용될 뿐, 제한의 목적으로 사 용되지는 않는다.도면 도면1 도면2 도면3 도면4 도면5a 도면5b 도면6 도면7 도면8 도면9 도면10 도면11 도면12a 도면12b 도면13a 도면13b 도면13c 도면13d 도면14 도면15 도면16 도면17 도면18"}
{"patent_id": "10-2024-7007948", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 특허 또는 출원 파일은 컬러로 작성된 적어도 하나의 도면을 포함한다. 컬러 도면(들)을 갖는 이 특허 또는 특허 출원 공보의 사본들은 요청 및 필요한 수수료 지불 시 특허청에서 제공될 것이다. 이와 같이 본 개시를 일반적인 용어들로 설명하였으며, 이제 반드시 축척으로 그려진 것은 아닌 첨부 도면들에 대한 참조가 이루어질 것이다. 도면들에서: 도 1은 본 명세서에서 설명되는 일부 실시예들에 따른, 본 개시의 실시예들을 실시하는 데 사용될 수 있는 시스 템 아키텍처의 예시적인 개요를 제공한다. 도 2는 본 명세서에서 설명되는 일부 실시예들에 따른 예시적인 클라우드 컴퓨팅 서버 컴퓨팅 엔티티를 제공한 다. 도 3은 본 명세서에서 설명되는 일부 실시예들에 따른 예시적인 클라이언트 컴퓨팅 엔티티를 제공한다. 도 4는 본 명세서에서 설명되는 일부 실시예들에 따른, 클라이언트 컴퓨팅 엔티티에 의해 요청된 입력 문제에 대한 최적화된 솔루션을 결정하기 위한 예시적인 프로세스의 흐름도를 제공한다. 도 5a-b는 본 명세서에서 설명되는 일부 실시예들에 따른 클라우드 컴퓨팅 서버 컴퓨팅 엔티티의 블록도들을 제 공한다. 도 6은 본 명세서에서 설명되는 일부 실시예들에 따른, 입력 문제를 하나 이상의 선택된 솔버 유형에 매핑하기 위한 예시적인 프로세스의 흐름도를 제공한다. 도 7은 본 명세서에서 설명되는 일부 실시예들에 따른, 클라우드 기반 다중 도메인 솔버 시스템에서 하나 이상의 컨테이너 인스턴스의 실행에 적어도 부분적으로 기초하여 입력 문제에 대한 문제 출력을 생성하기 위한 예시 적인 프로세스의 흐름도를 제공한다. 도 8은 본 명세서에서 설명되는 일부 실시예들에 따른 예측 출력 사용자 인터페이스의 동작 예를 제공한다. 도 9는 도 10-18 전체에서 사용되는 심볼들의 범례이다. 도 10은 다양한 실시예들에 따른 클라우드 기반 다중 도메인 솔버 시스템의 세부사항들을 도시하는 개략도 이다. 도 11은 도 10의 클라우드 기반 다중 도메인 솔버 시스템의 추가적인 세부사항들, 특히 다양한 컴포넌트들 이 클라우드 배치 환경 내에서 논리적으로 그리고 물리적으로 상호 연결되는 방법을 도시하는 개략도이다. 도 12a는 도 11의 요청 서비스 블록의 세부 사항들을 도시하는 개략도이다. 도 12b는 컨테이너 내의 개별 가용성 구역들에서 실행되는 2개의 요청 서비스 인스턴스를 도시하는 개략도이다. 도 13a는 도 11의 응답 (솔버) 서비스 블록의 세부 사항들을 도시하는 개략도이다. 도 13b는 컨테이너 내의 가용성 구역에서 실행되는 다수의 생성된 솔버 인스턴스를 도시하는 개략도이다. 도 13c는 2개의 가용성 구역에서 각각의 애플리케이션 스택(application stack)의 독립 사본을 실행하기 위한 탄력적 로드 밸런싱(Elastic Load Balancing)을 도시하는 개략도이다. 도 13d는 아마존 EFS 저장소를 갖는 활성/대기 브로커(active/standby broker)를 도시하는 개략도이다. 도 14는 도 11의 응답 (솔버) 프리프로세서(preprocessor) 블록의 세부 사항들을 도시하는 개략도이다. 도 15는 도 11의 실시예에 따른 REST API의 세부사항들을 도시하는 개략도이다. 도 16은 다수의 도메인 특유(domain-specific) 클라이언트 컴퓨팅 엔티티가 공통 REST API를 통해 제약 스케줄 러(constraint scheduler)에 액세스할 수 있는 방법을 도시하는 개략도이다. 도 17은 특정 실시예들에 따른, VRP 솔버에 의해 사용되는 거리 서비스(distance service)를 도시하는 개략도이 다. 도 18은 특정 실시예들에 따른, 솔버 트랜잭션(solver transaction)의 진행을 도시하는 흐름도이다."}
