{"patent_id": "10-2019-0047910", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2020-0124504", "출원번호": "10-2019-0047910", "발명의 명칭": "우선순위 기반의 ECC에 기초하여 데이터를 근사적 메모리 장치에 저장하는 메모리 컨트롤러,", "출원인": "경희대학교 산학협력단", "발명자": "장익준"}}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "제 1 데이터의 일부 비트들(을 에러 정정 연산을 위한 패리티 비트들로 변환하고 그리고 상기 일부 비트들로부터 대체된 상기 패리티 비트들과 상기 제 1 데이터의 나머지 비트들을 포함하는 제 2 데이터를 생성하도록 구성되는 에러 정정 회로; 및상기 제 1 데이터 대신에 상기 제 2 데이터를 메모리 장치로 전송하도록 구성되는 물리 계층을 포함하는 메모리컨트롤러."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 일부 비트들은 부동 소수점 형식으로 표현된 상기 제 1 데이터의 지수 비트들의 일부 비트들에 해당하는메모리 컨트롤러."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,상기 일부 비트들은 상기 제 1 데이터의 하위 비트들에 해당하는 메모리 컨트롤러."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 에러 정정 회로는 상기 메모리 장치로부터 전송되는 제 3 데이터의 패리티 비트들을 이용하여 상기 제 3데이터에 대한 에러 정정 연산을 수행하도록 더 구성되는 메모리 컨트롤러."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 1 항에 있어서,상기 제 1 데이터는 신경망의 연산에 사용되는 메모리 컨트롤러."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1 항에 있어서,상기 제 1 데이터는 신경망의 연산에 사용되는 가중치 파라미터들이고, 그리고상기 일부 비트들의 값들은 고정되는 메모리 컨트롤러."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서,상기 메모리 컨트롤러는 상기 메모리 장치로 제공되는 기준 어드레스를 조정하도록 더 구성되고, 그리고상기 기준 어드레스에 따라 상기 메모리 장치의 메모리 셀 어레이는 제 1 구역과 제 2 구역으로 구분되는 메모리 컨트롤러."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 7 항에 있어서,상기 제 1 구역의 리프레쉬 속도는 상기 제 2 구역의 리프레쉬 속도보다 빠르고, 그리고공개특허 10-2020-0124504-3-상기 물리 계층은 상기 제 2 데이터가 상기 제 2 구역에 저장되도록 상기 제 2 구역을 나타내는 어드레스를 상기 메모리 장치로 전송하도록 더 구성되는 메모리 컨트롤러."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 7 항에 있어서,상기 메모리 컨트롤러는 BER(bit error rate)에 기초하여, 상기 제 1 구역의 리프레쉬 속도와 상기 제 2 구역의리프레쉬 속도의 비율을 조정하도록 더 구성되는 메모리 컨트롤러."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "프로그램 코드를 저장하는 비일시적 컴퓨터 판독 가능한 매체에 있어서, 상기 프로그램 코드가 프로세서에 의해실행될 때, 상기 프로세서는:제 1 데이터의 일부 비트들을 에러 정정 연산을 위한 패리티 비트들로 변환하는 단계;상기 일부 비트들로부터 대체된 상기 패리티 비트들과 상기 제 1 데이터의 나머지 비트들을 포함하는 제 2 데이터를 생성하는 단계; 및상기 제 2 데이터를 메모리 장치에 저장하기 위한 쓰기 명령을 생성하는 단계를 수행하는 비일시적 컴퓨터 판독가능한 매체."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제 10 항에 있어서,상기 프로세서는, 상기 메모리 장치의 메모리 셀 어레이를 제 1 구역과 제 2 구역으로 구분하기 위한 설정 명령과 기준 어드레스를 생성하는 단계를 더 수행하고, 그리고상기 제 2 데이터는 상기 제 2 구역에 저장되는 비일시적 컴퓨터 판독 가능한 매체."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 11 항에 있어서,상기 프로세서는, 상기 메모리 장치에 대한 리프레쉬(refresh) 명령을 반복적으로 생성하는 단계를 더수행하고, 그리고상기 리프레쉬 명령에 의한 상기 제 1 구역의 리프레쉬 속도는 상기 리프레쉬 명령에 의한 상기 제 2 구역의 리프레쉬 속도보다 빠른 비일시적 컴퓨터 판독 가능한 매체."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 11 항에 있어서,상기 프로세서는, BER(bit error rate)에 기초하여, 상기 제 1 구역의 리프레쉬 속도와 상기 제 2 구역의 리프레쉬 속도의 비율을 조정하기 위한 설정 명령을 생성하는 단계를 더 수행하는 비일시적 컴퓨터 판독 가능한 매체."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 10 항에 있어서,상기 제 1 데이터는 신경망의 연산에 사용되고, 그리고상기 일부 비트들은 부동 소수점 형식으로 표현된 상기 제 1 데이터의 지수 비트들에 해당하거나 또는 상기 제1 데이터의 하위 비트들에 해당하는 비일시적 컴퓨터 판독 가능한 매체."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제 1 데이터를 생성하도록 구성되는 프로세서;상기 제 1 데이터의 일부 비트들을 에러 정정 연산을 위한 패리티 비트들로 변환하고 그리고 상기 일부 비트들공개특허 10-2020-0124504-4-로부터 대체된 상기 패리티 비트들과 상기 제 1 데이터의 나머지 비트들을 포함하는 제 2 데이터를 생성하도록구성되는 메모리 컨트롤러; 및상기 메모리 컨트롤러로부터 전송되는 상기 제 2 데이터를 저장하도록 구성되는 메모리 장치를 포함하는 전자장치."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제 15 항에 있어서,상기 프로세서는 신경망 응용 프로그램을 실행함으로써 상기 제 1 데이터를 생성하도록 더 구성되는 전자 장치."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제 15 항에 있어서,상기 메모리 장치는 제 1 구역 그리고 상기 제 1 구역의 리프레쉬 속도보다 낮은 리프레쉬 속도를 갖는 제 2 구역으로 구분되는 메모리 셀 어레이를 포함하고,상기 메모리 컨트롤러는 상기 제 2 데이터를 상기 메모리 장치에 저장하기 위한 명령 및 상기 제 2 구역의 적어도 일부를 나타내는 어드레스를 생성하도록 더 구성되고,상기 제 2 데이터는 상기 명령 및 상기 어드레스에 의해 상기 제 2 구역에 저장되는 전자 장치."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제 15 항에 있어서,상기 메모리 장치는 제 1 워드 라인에 연결된 제 1 메모리 셀들 및 제 2 워드 라인에 연결된 제 2 메모리 셀들을 포함하는 메모리 셀 어레이를 포함하고,상기 제 2 데이터의 MSB(most significant bit)는 제 1 메모리 셀들 중 하나에 저장되고 상기 제 2 데이터의LSB(least significant bit)는 제 2 메모리 셀들 중 하나에 저장되고, 그리고상기 제 1 메모리 셀들의 리프레쉬 속도는 상기 제 2 메모리 셀들의 리프레쉬 속도보다 빠른 전자 장치."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제 15 항에 있어서,상기 메모리 장치는 제 1 구역 그리고 상기 제 1 구역의 리프레쉬 속도보다 낮은 리프레쉬 속도를 갖는 제 2 구역으로 구분되는 메모리 셀 어레이를 포함하고,상기 메모리 컨트롤러는 BER(bit error rate)들과 상기 제 1 구역의 상기 리프레쉬 속도와 상기 제 2 구역의 상기 제 2 리프레쉬 속도의 비율들이 맵핑(mapping)된 룩업 테이블을 저장하는 레지스터들을 포함하는 전자 장치."}
{"patent_id": "10-2019-0047910", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제 15 항에 있어서,상기 메모리 장치는 DRAM(dynamic random access memory) 장치인 전자 장치."}
{"patent_id": "10-2019-0047910", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명의 실시 예에 따른 메모리 컨트롤러는 제 1 데이터의 일부 비트들을 에러 정정 연산을 위한 패리티 비트 들로 변환하고 그리고 일부 비트들로부터 대체된 패리티 비트들과 제 1 데이터의 나머지 비트들을 포함하는 제 2 데이터를 생성하도록 구성되는 에러 정정 회로, 및 제 1 데이터 대신에 제 2 데이터를 메모리 장치로 전송하도록 구성되는 물리 계층을 포함한다."}
{"patent_id": "10-2019-0047910", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 우선순위 기반의 ECC에 기초하여 데이터를 근사적 메모리 장치에 저장하는 메모리 컨트롤러, 프로그 램 코드를 저장하는 비일시적 컴퓨터 판독 가능한 매체, 그리고 근사적 메모리 장치와 메모리 컨트롤러를 포함 하는 전자 장치에 관한 것이다."}
{"patent_id": "10-2019-0047910", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "생물학적인 신경망과 유사한 인공 신경망(artificial neural network; ANN)에 기반하는 인공지능 기술이 이미지 인식, 음성 인식, 번역, 검색, 딥러닝, 데이터 수집 및 분석, 자율 주행 등과 같은 다양한 분야에서 사용되고 있다. 컴퓨팅 장치의 하드웨어가 발전함에 따라, 다수의 은닉층들을 포함하는 심층 신경망(DNN)이 주로 사용되 고 있다. 신경망의 학습, 트레이닝, 또는 추론에 있어서, 다수의 파라미터(parameter)들이 생성되고, 참조되고, 또는 업 데이트될 수 있다. 이러한 파라미터들이 증가함에 따라, 파라미터들을 저장하기 위한 메모리 장치의 용량, 개수, 집적도 등도 증가하고 있다. 따라서, 신경망을 실행하는데 요구되는 메모리 장치의 전력 소모를 줄이는 것이 필요하다."}
{"patent_id": "10-2019-0047910", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 상술한 기술적 과제를 해결하기 위한 것으로, 본 발명은 우선순위 기반의 ECC에 기초하여 데이터를 근사적 메모리 장치에 저장하는 메모리 컨트롤러, 프로그램 코드를 저장하는 비일시적 컴퓨터 판독 가능한 매체, 그리고 근사적 메모리 장치와 메모리 컨트롤러를 포함하는 전자 장치를 제공할 수 있다."}
{"patent_id": "10-2019-0047910", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 실시 예에 따른 메모리 컨트롤러는 제 1 데이터의 일부 비트들을 에러 정정 연산을 위한 패리티 비트 들로 변환하고 그리고 일부 비트들로부터 대체된 패리티 비트들과 제 1 데이터의 나머지 비트들을 포함하는 제 2 데이터를 생성하도록 구성되는 에러 정정 회로, 및 제 1 데이터 대신에 제 2 데이터를 메모리 장치로 전송하 도록 구성되는 물리 계층을 포함한다. 본 발명의 다른 실시 예에 따른 프로그램 코드를 포함하는 비일시적 컴퓨터 판독 가능한 매체에 있어서, 프로그 램 코드가 프로세서에 의해 실행될 때, 프로세서는 제 1 데이터의 일부 비트들을 에러 정정 연산을 위한 패리티 비트들로 변환하는 단계, 일부 비트들이 대체된 패리티 비트들과 제 1 데이터의 나머지 비트들을 포함하는 제 2 데이터를 생성하는 단계, 및 제 2 데이터를 메모리 장치에 저장하기 위한 쓰기 명령을 생성하는 단계를 수행한 다. 본 발명의 또 다른 실시 예에 따른 전자 장치는 제 1 데이터를 생성하도록 구성되는 프로세서, 제 1 데이터의 일부 비트들을 에러 정정 연산을 위한 패리티 비트들로 변환하고 그리고 일부 비트들이 대체된 패리티 비트들과 제 1 데이터의 나머지 비트들을 포함하는 제 2 데이터를 생성하도록 구성되는 메모리 컨트롤러, 및 메모리 컨트 롤러로부터 전송되는 제 2 데이터를 저장하도록 구성되는 메모리 장치를 포함한다."}
{"patent_id": "10-2019-0047910", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 실시 예에 따른 메모리 컨트롤러는 우선순위 ECC에 기초하여 데이터를 근사적 메모리 장치에 저장할 수 있다. 메모리 컨트롤러는 근사적 메모리 장치의 리프레쉬 전력 소모를 줄일 수 있다. 메모리 컨트롤러는 근 사적 메모리 장치의 리프레쉬 속도를 BER에 따라 조정할 수 있고 낮은 리프레쉬 속도로 동작하는 메모리 장치에 서 발생할 수 있는 에러를 우선순위 ECC를 이용하여 정정할 수 있다."}
{"patent_id": "10-2019-0047910", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 1, "content": "도 1은 본 발명의 실시 예에 따른 전자 장치의 예시적인 블록도를 도시한다. 전자 장치는 전자 시스템, 컴 퓨터 시스템, 메모리 시스템 등으로도 지칭될 수 있다. 예를 들어, 전자 장치는 데스크톱(desktop) 컴퓨터, 랩톱(laptop) 컴퓨터, 워크스테이션(workstation), 서버, 모바일 장치 등일 수 있으나, 본 발명의 범위 는 이에 한정되지 않는다. 전자 장치는 메모리 컨트롤러 및 메모리 장치를 포함할 수 있다. 메모리 컨트롤러는 메모리 장치를 제어할 수 있다. 메모리 컨트롤러는 메모리 장치를 접근 하기 위한 명령들과 어드레스들을 생성할 수 있다. 메모리 컨트롤러는 메모리 장치에 저장될 데이터 를 생성할 수 있다. 메모리 컨트롤러는 메모리 장치에 저장된 데이터를 수신할 수 있다. 메모리 컨트롤러는 에러 정정 회로 및 물리 계층(112; 이하, PHY로 지칭)을 포함할 수 있다. 에러 정 정 회로는 제 1 데이터를 수신할 수 있다. 제 1 데이터는 메모리 컨트롤러의 외부(예를 들어, 프로세 서, 버퍼 메모리 등)로부터 제공되거나 메모리 컨트롤러의 내부에서 생성될 수 있다. 제 1 데이터는 메모 리 장치에 저장될 데이터일 수 있다. 예를 들어, 제 1 데이터는 응용 프로그램을 실행함에 따라 발생하거 나 응용 프로그램을 실행하는데 필요할 수 있다. 에러 정정 회로는 메모리 장치에 저장될 쓰기 데이터(제 1 데이터)에 대한 인코딩(encoding) 연산을 수행할 수 있다. 에러 정정 회로는 메모리 장치로부터 전송되는 읽기 데이터에 대한 디코딩 (decoding) 연산을 수행할 수 있다. 예를 들어, 에러 정정 회로는 쓰기 데이터에 대한 패리티(parity) 비 트들을 생성할 수 있다. 에러 정정 회로는 메모리 장치로부터 전송되는 읽기 데이터의 패리티 비트들 을 이용하여 읽기 데이터의 에러를 정정할 수 있다. 읽기 데이터의 에러는 PVT(process, voltage, temperature) 변동, 보유(retention) 특성, 간섭, 열화, 잡음, 리프레쉬 속도(refresh rate), 집적도, 등과 같 은 메모리 장치의 다양한 요인들에 의하여 발생할 수 있다. 좀 더 구체적으로, 에러 정정 회로는 에러 정정 코드(ECC)에 기초하여 제 1 데이터에 대한 패리티(parity) 비트들을 생성할 수 있다. 패리티 비트들은 제 1 데이터의 메시지 비트들이 손상되지 않도록 보호하는데 사용될 수 있다. 본 발명의 실시 예에 따른 에러 정정 회로는 일반적인 에러 정정 코드(ECC)를 이용한 인코딩과 달리 제 1 데이터의 메시지 비트들에 패리티 비트들을 부가하지 않는다. 대신에, 에러 정정 회로는 제 1 데이터의 메시지 비트들의 일부 비트들을 패리티 비트들로 대체할 수 있다. 에러 정정 회로는 제 1 데이터 의 메시지 비트들의 일부 비트들을 에러 정정 연산을 위한 패리티 비트들로 변환할 수 있다. 에러 정정 회로 는 패리티 비트들과 제 1 데이터의 메시지 비트들 중 나머지 비트들을 포함하는 제 2 데이터를 생성할 수 있다. 전술한대로, 에러 정정 회로는 제 1 데이터의 메시지 비트들에 패리티 비트들을 덧붙이지 않고 일부 비트 들을 패리티 비트들로 변환하므로, 제 1 데이터의 사이즈(비트 수)와 제 2 데이터의 사이즈는 서로 동일할 수 있다. 에러 정정 회로는 제 1 데이터를 제 2 데이터로 변환하고 그리고 제 2 데이터를 PHY에 제공할 수 있다. 메모리 장치는 메모리 컨트롤러의 제어에 기초하여 제 1 데이터가 인코딩된 제 2 데이터를저장하게 된다. 패리티 비트들로 대체된 메시지 비트들의 일부 비트들은 메모리 장치에 저장되지 않는다. PHY는 인터페이스 회로로도 지칭될 수 있다. PHY는 메모리 장치와 직접적으로 통신할 수 있다. PHY는 메모리 장치가 지원하는 인터페이스 표준(예를 들면, Toggle DDR(double data rate) 표준, DDR SDRAM(synchronous dynamic random access memory) 표준, JEDEC(joint electron device engineering council) 표준 등)에 따라 동작할 수 있다. PHY는 메모리 컨트롤러와 메모리 장치 사이의 채널 을 형성하는 물리적인 경로들을 구동할 수 있다. PHY는 메모리 컨트롤러에 의해 생성되는 명령, 어드 레스, 쓰기 데이터(제 2 데이터)를 메모리 장치로 전송할 수 있다. PHY는 메모리 장치로부터 읽 기 데이터를 수신할 수 있고 수신된 읽기 데이터를 에러 정정 회로로 제공할 수 있다. 도 1을 참조하면, PHY는 에러 정정 회로에 의해 변환되고 생성된 제 2 데이터를 그대로 메모리 장치로 전송할 수 있다. PHY는 제 1 데이터가 아닌 제 2 데이터를 메모리 장치로 전송할 수 있다. 메모리 장치는 메모리 컨트롤러의 제어에 기초하여 메모리 컨트롤러로부터 전송되는 쓰기 데이 터를 저장할 수 있다. 메모리 장치는 메모리 컨트롤러의 제어에 기초하여 저장된 데이터를 읽기 데이 터로서 메모리 컨트롤러로 전송할 수 있다. 예를 들어, 메모리 장치는 DRAM(dynamic random access memory) 장치, SRAM(static random access memory) 장치, TRAM(thyristor random access memory) 장치, 낸드 플래시 메모리 장치, 노어 플래시 메모리 장치, RRAM(resistive random access memory) 장치, FRAM(ferroelectric random access memory) 장치, PRAM(phase change random access memory) 장치, MRAM(magnetic random access memory) 장치, STT-MRAM(spin transfer torque magnetic random access memory) 장치, 솔리드 스테이트 드라이브(SSD), 메모리 카드, 유니버설 플래시 기억장치(UFS) 등일 수 있으나, 메모리 장치는 상술한 것들로 한정되지 않는다. 도 1을 참조하면, 메모리 장치는 메모리 컨트롤러로부터 제 2 데이터를 수신하고 저장할 수 있다. 메 모리 장치가 DRAM 장치이면, 메모리 장치의 메모리 셀에 저장된 데이터, 즉 전하가 유지되는 시간은 제한적이므로, 메모리 셀에 저장된 데이터가 손실되기 전에 메모리 셀에 저장된 데이터를 리프레쉬하는 것이 필 요하다. 예를 들어, 메모리 장치는 메모리 컨트롤러의 반복적인 오토-리프레쉬 요청에 응답하여 제 2 데이터를 주기적으로 또는 비주기적으로 리프레쉬할 수 있다. 다른 예를 들어, 메모리 장치는 메모리 컨트 롤러의 셀프-리프레쉬 요청에 응답하여 스스로 제 2 데이터를 주기적으로 또는 비주기적으로 리프레쉬할 수 있다. 메모리 장치는 도 1에서 도시된 제 2 데이터뿐만 아니라 모든 DRAM 셀들에 저장된 데이터에 대한 리프레쉬 동작을 수행할 수 있다. 메모리 장치의 용량, 개수, 집적도 등이 증가함에 따라, 메모리 장치가 리프레쉬 동작을 수행하는데 필요한 전력(예를 들면, IDD5, IDD6 등)도 증가하게 된다. 전자 장치가 심층 신경망과 같은 인공 신경망 (응용 프로그램)을 실행하는 경우, 리프레쉬 동작에 의한 메모리 장치의 전력 소모가 크게 증가할 수 있다. 예를 들어, 전자 장치에 의해 실행되는 인공 신경망은 DNN(Deep Neural Network), CNN(Convolution neural network), RNN(Recurrent Neural Network), SNN(Spiking Neural Network) 등을 포함할 수 있다. 메모리 장치의 전력 소모를 줄이기 위해, 메모리 컨트롤러는 메모리 장치의 리프레쉬 속도를 낮 출 수 있고 메모리 장치를 근사적 메모리(approximate memory) 장치로서 동작시킬 수 있다. 메모리 컨트롤 러는 메모리 장치의 리프레쉬 속도를 낮춤으로써 리프레쉬 동작에 의한 메모리 장치의 전력 소 모를 개선할 수 있다. 느린 리프레쉬 속도는 메모리 셀에 저장된 데이터의 손실을 야기할 수 있다. 느린 리프레쉬 속도는 메모리 장치 의 BER(bit error rate)의 증가를 야기할 수 있고 전자 장치를 이용하여 실행되는 응용 프로그램의 계산의 정확도에 영향을 미칠 수 있다. 그럼에도 불구하고, 메모리 컨트롤러는 느린 리프레쉬 속도로 인하 여 메모리 장치에서 에러가 발생할 확률을 허용할 수 있다. 예를 들어, 메모리 컨트롤러는 느린 리프 레쉬 속도로 동작하는 메모리 장치의 BER이 응용 프로그램의 계산의 정확도에 영향을 미치지 않도록, 우선 순위 기반의(priority-based) ECC를 이용할 수 있다. 메모리 컨트롤러는 제 1 데이터를 메모리 장치에 저장하기 전에, 우선순위 기반의 ECC를 이용하여 제 1 데이터를 인코딩하고 제 1 데이터가 인코딩된 제 2 데이터를 메모리 장치에 저장할 수 있다. 메모리 컨 트롤러의 에러 정정 회로는 제 1 데이터의 일부 비트들을 패리티 비트들로 대체할 수 있다. 에러 정 정 회로가 패리티 비트들로 대체될 일부 비트들을 선택하는 우선 순위, 즉 기준은 비트들 각각의 중요성 (significance)일 수 있다. 에러 정정 회로는 중요하지 않은(insignificant) 일부 비트들을 패리티 비트 들로 대체할 수 있다. 에러 정정 회로는 패리티 비트들을 이용하여 중요한 나머지 비트들을 에러로부터 보호할 수 있다. 메모리 컨트롤러가 메모리 장치를 근사적 메모리로 효과적으로 이용할 수 있는지 여부는, 데이터의 비트들 중 중요한 비트와 중요하지 않은 비트를 어떻게 분리할 것인지, 즉, 데이터의 비트들 중 어느 비트를 패 리티 비트로 대체할 것인지에 달려 있다. 에러 정정 회로에 의해 메시지 비트들의 일부 비트들이 패리티 비트들로 대체되는 예시들은 도 2a 내지 도 2c에서 좀 더 구체적으로 설명될 것이다. 도 2a는 도 1의 제 1 데이터가 제 2 데이터로 변환되는 예시를 도시한다. 도 2b는 도 1의 제 1 데이터의 일부 비트들의 예시적인 값들을 도시한다. 도 2a와 도 2b는 도 1을 참조하여 함께 설명될 것이다. 제 1 데이터(Data 1)는 예를 들어 IEEE 754에서 명시하는 부동 소수점 형식(floating-point format)으로 표현 될 수 있다. 부동 소수점 형식으로 표현된 제 1 데이터의 메시지 비트들은 부호(sign) 비트, 지수(exponent) 비 트들, 및 가수(mantissa 또는 fraction) 비트들로 나뉠 수 있다. 예를 들어, 부동 소수점 형식은 반정밀도 부동 소수점(half-precision floating-point) 형식, 단정밀도 부동 소수점(single-precision floating-point) 형식, 배정밀도 부동 소수점(double-precision floating-point) 형식, 확장정밀도 부동 소수점(extended-precision floating-point) 형식, 네배정밀도 부동 소수점(quadruple-precision floating-point) 형식 등을 포함할 수 있 으나, 이에 한정되지 않는다. 도 2a를 참조하면, 제 1 데이터는 단정밀도 부동 소수점 형식으로 표현될 수 있고 제 1 데이터의 비트 수는 32 일 수 있으나, 이에 한정되지 않는다. 제 1 데이터의 메시지 비트들은 1개 부호 비트 s, 8개 지수 비트들 e, 그 리고 23개 가수비트들 m을 포함할 수 있다. 부동 소수점 형식{s, e, m}의 값은 -1s X M X 2E일 수 있다. 여기서, M=1.m 이고 E=e-127이다. 제 1 데이터의 부호 비트는 MSB(most significant bit)일 수 있고 가수 비트 들 중 가장 오른쪽에 배치된 비트는 LSB(least significant bit)일 수 있다. 상대적으로 왼쪽에 배치된 제 1 데 이터의 비트들이 상대적으로 오른쪽에 배치된 제 1 데이터의 비트들보다 중요할 수 있다. MSB부터 LSB까지의 우 선 순위(즉, 순서)는 부호 비트, 지수 비트들, 가수의 상위 비트들, 및 가수의 하위 비트들이다. 제 1 데이터의 비트들 중 상위 비트들([31:24])의 값들이 예시적으로 도 2b에서 도시되었다. 가로 축은 비트 위 치를 나타내고 그리고 세로 축은 비트 1과 비트 0의 비율을 나타낸다. 예를 들어, 도 2a 및 도 2b의 제 1 데이 터는 전자 장치를 이용하여 DNN, CNN, RNN, SNN 등과 같은 신경망이 실행됨에 따라 메모리 장치에 저 장되어야 할 데이터일 수 있고 신경망의 가중치 파라미터들일 수 있다. 제 1 데이터는 신경망의 연산에 사용될 수 있다. 예를 들어, 가중치 파라미터들의 범위는 [2-13:2-2]일 수 있다. 상술한 범위에 따라, 제 1 데이터의 일 부 비트들([30, 29, 28])의 값들은 [0, 1, 1]로 고정될 수 있다. 제 1 데이터의 일부 비트들([30, 29, 28])은 제 1 데이터를 구성하는 메시지 비트들이다. 다만, 에러 정정 회로 는 제 1 데이터의 일부 비트들([30, 29, 28])의 값들이 [0, 1, 1]로 고정되기 때문에, 에러 정정 코드에 기초하여 일부 비트들([30, 29, 28])을 패리티 비트들로 대체(변환)할 수 있다. 에러 정정 회로는 제 1 데 이터의 나머지 비트들([31, 27:0])과 패리티 비트들을 포함하는 제 2 데이터(Data 2)를 생성할 수 있다. 제 2 데이터의 패리티 비트들의 위치들은 제 1 데이터의 비트들([30, 29, 28])의 위치들에 각각 대응할 수 있다. 제 2 데이터의 메시지 비트들([31, 27:0])의 값들은 제 1 데이터의 메시지 비트들([31, 27:0])의 값들과 동일할 수 있다. 제 2 데이터의 메시지 비트들([31, 27:0])의 위치들은 제 1 데이터의 메시지 비트들([31, 27:0])의 위치 들에 각각 대응할 수 있다. 다만, 제 2 데이터의 메시지 비트들과 패리티 비트들의 위치들은 도 2a에서 도시된 것으로 한정되지 않는다. 에러 정정 회로는 제 2 데이터가 메모리 장치에 저장된 이후에 메모리 장치로부터 읽혀진 제 2 데이터를 수신하고 디코딩할 수 있다. 메모리 장치로부터 읽혀진 제 2 데이터는 PHY가 메모리 장치 로 전송한 제 2 데이터와 동일하거나 또는 에러로 인하여 상이할 수 있다. 에러 정정 회로는 패리티 비트들을 이용하여 제 2 데이터의 비트들([31, 27, 26, 25])에 대한 에러 정정 연산을 수행할 수 있다. 에러 정 정 회로는 고정된 값들을 갖는 일부 비트들([30, 29, 28])을 패리티 비트들로 대체하고, 그 다음 고정된 값들 대신에 패리티 비트들이 메모리 장치에 저장되고, 그 다음 에러 정정 회로는 패리티 비트들을 이용하여 에러 정정 연산을 수행할 수 있다. 에러 정정 회로는 제 2 데이터의 비트들([30, 29, 28])의 값 들을 에러 정정 연산에서 이용하고 그 다음 [0, 1, 1]로 설정, 변경, 또는 정정할 수 있다. 에러 정정 회로는 제 1 데이터의 일부 비트들([30, 29, 28])을 패리티 비트들로 대체함으로써 제 1 데이터 의 나머지 비트들([31, 27, 26, 25])을 에러로부터 보호할 수 있다. 에러 정정 회로는 패리티 비트들을 이 용하여 보호할 나머지 비트들을 비트의 우선 순위, 즉 중요성에 따라 선택할 수 있다. 예를 들어, 에러 정정 회로는 MSB에서 LSB의 순서에 따라 전체 나머지 비트들([31, 27:0]) 중 나머지 비트들([31, 27, 26, 25])을 선택하고 패리티 비트들을 이용하여 보호할 수 있다. 패리티 비트들을 이용하여 보호할 나머지 비트들의 위치는 도 2a에서 도시된 것으로 한정되지 않는다. 실시 예에 있어서, 제 1 데이터의 비트들 중 고정된 값을 갖는 비트의 위치는 도 2a 및 도 2b에서 설명된 것으 로 한정되지 않는다. 고정된 값을 갖는 비트의 위치는 전자 장치를 이용하여 실행되는 응용 프로그램의 종 류, 응용 프로그램에 의해 생성되는 데이터의 종류, 데이터 값의 범위 등에 따라 다양할 수 있다. 실시 예에 있어서, 제 1 데이터의 비트들 중 고정된 값을 갖는 비트의 개수는 도 2a 및 도 2b에서 설명된 것으 로 한정되지 않는다. 고정된 값을 갖는 비트의 개수가 증가할수록, 에러 정정 회로가 보호할 수 있는 나머 지 메시지 비트들의 개수도 증가할 수 있다. 에러 정정 회로가 사용하는 에러 정정 코드의 종류에 따라 정 정 가능한 에러의 개수도 변경될 수 있다. 도 2a 및 도 2b에서, 에러 정정 코드는 해밍(Hamming) 코드일 수 있 다. 에러 정정 회로는 3개 패리티 비트들([30, 29, 28])을 이용하여 4개 메시지 비트들([31, 27, 26, 25])을 보호할 수 있다. 예를 들어, 2k-1 ≥ n+k가 성립할 수 있고, n은 메시지 비트들의 개수이고 k는 패리티 비트들의 개수이다. 에러 정정 회로는 해밍 코드뿐만 아니라 BCH(Bose-Chauduhuri-Hocquenghen) 코드, RS(Reed-Solomon) 코드, Viterbi 코드, Turbo 코드, LDPC(low density parity check) 등과 같은 다른 에러 정 정 코드를 이용할 수도 있다. 도 2c는 도 1의 제 1 데이터가 제 2 데이터로 변환되는 다른 예시를 도시한다. 도 2c는 도 1을 참조하여 설명될 것이다. 도 2a와 동일하게, 도 2c에서 제 1 데이터는 단정밀도 부동 소수점 형식으로 표현될 수 있고 제 1 데이 터의 비트 수는 32일 수 있다. 전술한대로, 상대적으로 왼쪽에 배치된 제 1 데이터의 비트들이 상대적으로 오른 쪽에 배치된 제 1 데이터의 비트들보다 중요할 수 있다. 예를 들어, 에러 정정 회로는 중요하지 않은 제 1 데이터의 하위 비트들([3:0])을 패리티 비트들로 대체할 수 있다. 제 1 데이터의 하위 비트들([3:0])은 제 1 데이터를 구성하는 메시지 비트들이다. 에러 정정 회로 는 제 1 데이터의 나머지 비트들([31:4])과 패리티 비트들을 포함하는 제 2 데이터(Data 2)를 생성할 수 있다. 제 2 데이터의 패리티 비트들의 위치들은 제 1 데이터의 비트들([3:0])의 위치들에 각각 대응할 수 있다. 제 2 데이터의 메시지 비트들([31:4])의 값들은 제 1 데이터의 메시지 비트들([31:4])의 값들과 동일할 수 있다. 제 2 데이터의 메시지 비트들([31:4])의 위치들은 제 1 데이터의 메시지 비트들([31:4])의 위치들에 각각 대응할 수 있다. 다만, 제 2 데이터의 메시지 비트들과 패리티 비트들의 위치들은 도 2c에서 도시된 것으로 한 정되지 않는다. 에러 정정 회로는 제 2 데이터가 메모리 장치에 저장된 이후에 메모리 장치로부터 읽혀진 제 2 데이터를 수신하고 디코딩할 수 있다. 에러 정정 회로는 패리티 비트들을 이용하여 제 2 데이터의 비트들 ([31:23])에 대한 에러 정정 연산을 수행할 수 있다. 즉, 에러 정정 회로는 하위 비트들([3:0])을 패리티 비트들로 대체하고, 그 다음 하위 비트들([3:0])의 원래 값들 대신에 패리티 비트들이 메모리 장치에 저장 되고, 그 다음 에러 정정 회로는 패리티 비트들을 이용하여 에러 정정 연산을 수행할 수 있다. 에러 정정 회로는 제 1 데이터의 하위 비트들([3:0])을 패리티 비트들로 대체함으로써 제 1 데이터의 나머 지 비트들([31:23])을 에러로부터 보호할 수 있다. 전술한대로, 에러 정정 회로는 패리티 비트들을 이용하 여 보호할 나머지 비트들을 비트의 우선 순위, 즉 중요성에 따라 선택할 수 있다. 예를 들어, 에러 정정 회로 는 MSB에서 LSB의 순서에 따라 전체 나머지 비트들([31:4]) 중 나머지 비트들([31:23])을 선택하고 패리티 비트들을 이용하여 보호할 수 있다. 여기서, 에러 정정 회로가 패리티 비트들로 대체하는 하위 비트들의 위치들과 개수, 그리고 패리티 비트들을 이용하여 보호하려는 메시지 비트들의 위치들과 개수는 도 2c에서 도시 된 것들로 한정되지 않는다. 도 3은 도 1의 전자 장치의 예시적인 블록도를 좀 더 구체적으로 도시한다. 전술한대로, 전자 장치는 메모 리 컨트롤러 및 메모리 장치를 포함할 수 있다. 메모리 컨트롤러는 에러 정정 회로, PHY, 데이터 큐, 요청 큐, 명령 생성기, 리프레쉬 명령 생성기, 멀티플렉서, 레지스터들, 및 온도 확인 회로를 포함할 수 있다. 에 러 정정 회로 및 PHY는 도 1 그리고 도 2a 내지 도 2c를 참조하여 설명되었다. 데이터 큐는 메모리 장치에 저장될 쓰기 데이터를 저장할 수 있다. 데이터 큐는 저장된 쓰기 데 이터를 에러 정정 회로에 제공할 수 있다. 메모리 장치로부터 읽기 데이터가 전송되고 에러 정정 회 로가 읽기 데이터에 대한 디코딩을 수행한 이후에, 데이터 큐는 에러 정정 회로로부터 디코딩된데이터를 수신하고 저장할 수 있다. 요청 큐는 프로세서(미도시, 도 14의 3120 참조)에 의해 발행된 명령들과 어드레스들을 저장할 수 있다. 요청 큐는 저장된 명령과 어드레스를 명령 생성기로 제공할 수 있다. 실시 예에 있어서, 메모리 컨트 롤러가 구현된 회로 내에 위치하는 온-칩 메모리, 즉 버퍼 메모리에 데이터 큐와 요청 큐를 위 한 영역들이 사전에 할당될 수 있다. 예를 들어, 데이터 큐와 요청 큐는 레지스터들, 플립-플롭들, 래치들, SRAM 장치 등을 이용하여 메모리 컨트롤러 내부에서 구현될 수 있다. 다른 예를 들어, 데이터 큐 와 요청 큐는 메모리 컨트롤러의 외부에 위치하는 메모리 장치 상에서 구현될 수도 있다. 명령 생성기는 메모리 장치로 제공될 명령 또는 어드레스를 생성할 수 있다. 예를 들어, 명령은 활성 화 명령, 읽기 명령, 쓰기 명령, 프리차지(precharge) 명령, 소거 명령 등을 포함할 수 있다. 어드레스는 메모 리 장치 내에 데이터가 저장될 위치를 나타내거나 메모리 장치에 저장된 데이터의 위치를 나타낼 수 있다. 리프레쉬 명령 생성기는 요청 큐로 입력된 요청들과 별개로 메모리 장치에 저장된 데이터 를 유지하기 위해 메모리 장치로 제공될 리프레쉬 명령을 주기적으로 또는 비주기적으로 생성할 수 있다. 리프레쉬 명령 생성기는 리프레쉬 명령을 발행할 시점을 계산하기 위한 카운터를 포함할 수 있다. 멀티플 렉서는 명령 생성기에 의해 생성된 명령 및 리프레쉬 명령 생성기에 의해 생성된 명령 중 어느 하나를 PHY로 제공할 수 있다. 도 3에서 도시된 바와 달리, 리프레쉬 명령 생성기와 멀티플렉서(11 7)는 명령 생성기에서 구현될 수도 있고 명령 생성기가 리프레쉬 명령을 생성할 수도 있다. 레지스터들은 룩업 테이블(LUT)을 저장할 수 있다. 예를 들어, 룩업 테이블(LUT)은 BER과 리프레쉬 속도 간의 맵핑 정보를 저장할 수 있다. 레지스터들은 메모리 컨트롤러가 구현된 회로 내에 위치하는 온- 칩 메모리에 포함될 수 있다. 온도 확인 회로는 PHY를 통하여 메모리 장치의 현재 온도를 확인 할 수 있다. 온도 확인 회로는 레지스터들에 저장된 룩업 테이블과 메모리 장치의 현재 온도에 기초하여 메모리 장치의 리프레쉬 속도를 조정하기 위한 정보를 명령 생성기로 제공할 수 있다. 리프 레쉬 명령 생성기는 명령 생성기의 제어에 기초하여 메모리 장치의 리프레쉬 속도를 조정하거나 제어할 수 있다. 예를 들어, 리프레쉬 명령 생성기는 리프레쉬 명령을 생성하는 주기를 조정할 수 있다. 도 1에서 전술한대로, PHY는 제 2 데이터를 수신하고 제 2 데이터를 메모리 장치로 전송할 수 있다. PHY는 제 2 데이터의 비트들이 DQ 신호(데이터 입출력 신호)들을 통해 전송되도록, DQ 신호들을 구동할 수 있다. PHY는 메모리 장치로부터 전송되는 읽기 데이터, 즉 읽기 데이터에 따른 DQ 신호들의 논리 값 들을 수신할 수 있다. PHY는 명령 생성기에 의해 생성된 명령과 어드레스에 따라 명령(CMD) 및 어드 레스(ADD)를 메모리 장치로 전송할 수 있다. PHY는 리프레쉬 명령 생성기에 의해 생성된 리프레 쉬 명령에 따라 명령(CMD)을 메모리 장치로 전송할 수 있다. PHY는 명령 신호들 또는 어드레스 신호 들을 구동할 수 있다. 명령 신호들과 어드레스 신호들(ACT_n, RAS_n, CAS_n, WE_n, A0-A17, BA0-BA1, BG0-BG1 등)의 논리 값들은 JEDEC 표준에 명시될 수 있다. 예를 들어, 메모리 컨트롤러의 모든 구성 요소들은 집적 회로 내에서 하드웨어 방식으로 구현될 수 있다. 다른 예를 들어, 메모리 컨트롤러의 에러 정정 회로는 소프트웨어 방식, 하드웨어 방식, 또는 이들의 조합을 이용하여 메모리 컨트롤러 내에서 구현될 수 있다. 메모리 장치는 명령 디코더, 리프레쉬 컨트롤러, 어드레스 디멀티플렉서, 뱅크, 로우 디코더, 컬럼 디코더, 쓰기 회로, 읽기 회로, DQ 버퍼, 레지스터들, 및 온도 센서를 포함할 수 있다. 상술한 구성 요소들은 모두 메모리 장치 내부에서 하드웨어 방식으로 구현될 수 있다. 명령 디코더는 PHY로부터 출력되는 명령을 디코딩할 수 있고 메모리 장치의 내부 구성 요소들을 제어할 수 있다. 명령 디코더는 리프레쉬 명령을 수신 및 디코딩하고 그 다음 리프레쉬 컨트롤러를 제어할 수 있다. 리프레쉬 컨트롤러는 제 1 카운터(132_1), 제 2 카운터(132_2), 및 멀티플렉서(132_4)를 포함할 수 있다. 리프레쉬 컨트롤러는 명령 디코더의 제어에 기초하여 제 1 카운터(132_1) 및 제 2 카운터(132_2)를 제어할 수 있다. 제 1 카운터(132_1)는 뱅크의 에러-프리 구역에 해당하는 로우 어드레스 를 생성할 수 있다. 제 2 카운터(132_2)는 뱅크의 에러 구역에 해당하는 로우 어드레스를 생성할 수 있다. 실시 예에 있어서, 제 1 카운터(132_1)는 메모리 장치로 리프레쉬 명령이 입력될 때마다 에러-프리 구역에 해당하는 로우 어드레스를 생성하고 업데이트할 수 있다. 리프레쉬 컨트롤러는 리프레쉬 명령이 입력될 때 마다 제 1 카운터(132_1)를 작동시킬 수 있다(trigger). 반면에, 제 2 카운터(132_2)는 메모리 장치로 입력되는 리프레쉬 명령들 중 일부에만 응답하여 에러 구역에 해당하는 로우 어드레스를 생성하고 업데이트할 수 있다. 리프레쉬 컨트롤러는 입력되는 리프레쉬 명령들 중 일부에만 응답하여 제 2 카운터(132_2)를 작동시 킬 수 있고 나머지 리프레쉬 명령들에 따라 제 2 카운터(132_2)를 작동시키지 않을 수 있다. 제 1 카운터 (132_1)에 의해 에러-프리 구역에 해당하는 로우 어드레스가 업데이트되는 시점들 간의 간격은 제 2 카운터 (132_2)에 의해 에러 구역에 해당하는 로우 어드레스가 업데이트되는 시점들 간의 간격보다 짧을 수 있다. 멀티 플렉서(132_4)는 제 1 카운터(132_1)의 로우 어드레스 및 제 2 카운터(132_2)의 로우 어드레스 중 하나를 로우 디코더로 제공할 수 있다. 도 3에서 도시된 바와 달리, 멀티플렉서(132_4)는 제 1 카운터(132_1)의 로우 어드레스 및 제 2 카운터(132_2)의 로우 어드레스를 함께 로우 디코더로 제공할 수도 있다. 어드레스 디멀티플렉서는 명령 디코더의 제어에 기초하여 명령에 따라 수신되는 어드레스(ADD)를 메 모리 장치의 내부 구성 요소들로 제공할 수 있다. 어드레스 디멀티플렉서는 PHY로부터 활성화 명령과 함께 전송되는 어드레스를 로우 어드레스로서 로우 디코더에 제공할 수 있다. 어드레스 디멀티플렉 서는 PHY로부터 읽기 명령 또는 쓰기 명령과 함께 전송되는 어드레스를 컬럼 어드레스로서 컬럼 디코 더에 제공할 수 있다. 어드레스 디멀티플렉서는 PHY로부터 설정 명령과 함께 수신되는 어드레스 를 설정 코드로서 레지스터들에 제공할 수 있다. 설정 코드는 연산 코드(OPCODE) 또는 피연산자(operand) 로도 지칭될 수도 있다. 뱅크는 메모리 셀 어레이를 포함할 수 있다. 뱅크는 메모리 장치의 메모리 셀들을 구분하기 위 한 단위일 수 있다. 메모리 셀 어레이는 워드 라인들과 비트 라인들(미도시)에 연결되는 메모리 셀들을 포함할 수 있다. 도 3의 도시의 편의를 위해, 뱅크는 1개인 것으로 도시되었으나, 메모리 장치는 하나 이상 의 뱅크들을 포함할 수 있다. 뱅크의 메모리 셀들은 에러-프리 구역 및 에러 구역으로 구분될 수 있다. 예를 들어, 에러-프리 구역에 할 당되는 메모리 셀들과 에러 구역에 할당되는 메모리 셀들은 실질적으로 동일하게 제조될 수 있다. 리프레쉬 컨 트롤러의 제어에 의해, 에러-프리 구역에 배치되는 메모리 셀들은 에러 구역에 할당되는 메모리 셀들보다 자주 리프레쉬될 수 있다. 뱅크가 에러 구역을 포함하는 경우(즉, 메모리 장치가 근사적 메모리로 동 작하는 경우)의 리프레쉬 동작에 의한 메모리 장치의 전력 소모는, 뱅크의 모든 메모리 셀들이 에러- 프리 구역으로 할당되는 경우(즉, 뱅크에 에러 구역이 없고 메모리 장치가 근사적 메모리가 아닌 일 반 메모리로 동작하는 경우)의 리프레쉬 동작에 의한 메모리 장치의 전력 소모보다 적다. 에러 구역이 에 러-프리 구역보다 커질수록 상술한 전력 소모들 간의 차이도 증가할 수 있다. 에러 구역에 배치되는 메모리 셀 들에 저장되는 데이터의 BER은 에러-프리 구역에 배치되는 메모리 셀들에 저장되는 데이터의 BER보다 느린 리프 레쉬 속도로 인하여 높을 수 있다. 로우 디코더는 명령 디코더의 제어에 기초하여 로우 어드레스(RA)를 디코딩할 수 있다. 로우 디코더 는 로우 어드레스에 대응하는 적어도 하나의 워드 라인을 선택하거나 활성화할 수 있다. 로우 디코더(13 5)는 PHY로부터 출력된 로우 어드레스, 제 1 카운터(132_1)에 의해 생성된 로우 어드레스, 또는 제 2 카운 터(132_2)에 의해 생성된 로우 어드레스를 로우 어드레스(RA)로서 수신할 수 있다. 예를 들어, 로우 디코더 는 활성화 명령에 따른 로우 어드레스를 어드레스 디멀티플렉서로부터 수신할 수 있다. 로우 디코더 는 리프레쉬 명령에 따른 로우 어드레스를 제 1 및 제 2 카운터들(132_1, 132_2) 중 어느 하나로부터 수신 할 수 있다. 로우 디코더는 명령 디코더 및 리프레쉬 컨트롤러의 제어에 기초하여, 에러 구역에 배치된 메모 리 셀들보다 에러-프리 구역에 배치된 메모리 셀들을 좀 더 자주 리프레쉬할 수 있다. 에러-프리 구역의 워드 라인들 중 적어도 하나 이상의 워드 라인을 나타내는 로우 어드레스는, 에러 구역의 워드 라인들 중 적어도 하 나 이상의 워드 라인을 나타내는 로우 어드레스보다 자주 로우 디코더로 제공될 수 있다. 실시 예에 있어서, 메모리 컨트롤러는 활성화 명령에 의해 활성화될 워드 라인을 지정하는 로우 어드레스 를 직접 생성하고 메모리 장치로 제공할 수 있다. 활성화 명령을 생성하는 경우와 달리, 메모리 컨트롤러 는 리프레쉬 명령만을 메모리 장치로 제공하고 리프레쉬될 워드 라인을 직접 지정하지 않을 수 있다. 메모리 장치는 리프레쉬 명령에 응답하여 리프레쉬될 워드 라인을 나타내는 로우 어드레스를 내부적으로 생성하는 리프레쉬 컨트롤러를 포함할 수 있다. 메모리 장치는 근사적 메모리로 동작할 수 있다. 리 프레쉬 컨트롤러는 에러-프리 구역에 배치되는 워드 라인들을 나타내는 로우 어드레스를 생성하는 제 1 카 운터(132_1) 그리고 에러 구역에 배치되는 워드 라인들을 나타내는 로우 어드레스를 생성하는 제 2 카운터 (132_2)를 포함할 수 있다.컬럼 디코더는 명령 디코더의 제어에 기초하여 컬럼 어드레스(CA)를 디코딩할 수 있다. 컬럼 디코더 는 컬럼 어드레스에 대응하는 적어도 하나의 컬럼 선택 라인을 선택하거나 활성화할 수 있다. 컬럼 선택 라인에는 적어도 하나 이상의 비트 라인들이 연결될 수 있다. 예를 들어, 로우 어드레스 및 컬럼 어드레스에 대 응하는 메모리 셀들이 선택되고 선택된 메모리 셀들에 대한 데이터 입출력이 수행될 수 있다. 컬럼 디코더(13 6)는 쓰기 드라이버(WDRV) 및 입출력 센스 엠프(IOSA)를 포함할 수 있다. 쓰기 드라이버(WDRV)는 쓰기 회로로부터 쓰기 데이터를 수신하고 명령 디코더의 제어에 기초하여 선 택된 메모리 셀들에 쓰기 데이터를 쓸 수 있다. 입출력 센스 앰프(IOSA)는 선택된 메모리 셀들의 읽기 데이터를 감지하고 읽기 데이터를 읽기 회로로 제공할 수 있다. 쓰기 회로는 PHY로부터 DQ 버퍼를 통해 전송되는 DQ 신호들에 포함된 쓰기 데이터의 비트들을 수신하고 병렬화할 수 있다. 쓰기 회로는 쓰기 데이터를 쓰기 드라이버(WDRV)에 제공할 수 있다. 읽기 회 로는 입출력 센스 앰프(IOSA)로부터 읽기 데이터를 수신하고 직렬화할 수 있다. 읽기 회로는 읽기 데 이터를 DQ 버퍼로 제공할 수 있다. DQ 버퍼는 PHY로부터 DQ 신호들을 수신하거나 PHY로 DQ 신호들을 출력할 수 있다. DQ 신호들은 양방향 신호들이므로, DQ 버퍼는 수신기(미도시) 및 송신기(미 도시) 모두를 포함할 수 있다. 레지스터들은 명령 디코더의 제어에 기초하여 어드레스 디멀티플렉서로부터 제공되는 설정 코드, 즉 설정 정보를 저장할 수 있다. 레지스터들은 예를 들어 모드 레지스터들, 다목적 레지스터들 등으 로 지칭될 수 있다. 메모리 컨트롤러는 레지스터들에 저장된 값들을 변경하고 메모리 장치의 동 작 조건, 동작 모드 등을 설정하거나 조정할 수 있다. 온도 센서는 메모리 장치 내부의 현재 온도를 감지할 수 있다. 온도 센서는 현재 온도를 나타내 는 값을 레지스터들에 저장할 수 있다. 메모리 컨트롤러는 레지스터들을 읽기 위한 명령을 발행 할 수 있다. 온도 센서에 의해 감지되고 레지스터들에 저장된 현재 온도의 값은 상술한 명령에 따라 메모리 컨트롤러로 전송될 수 있다. 예를 들어, 명령 디코더는 레지스터들을 읽기 위한 명령을 디코딩하고 레지스터들에 저장된 값들을 읽기 회로로 전송할 수 있다. 읽기 회로는 레지스터들 에 저장된 값들을 읽기 데이터로서 DQ 버퍼에 제공할 수 있다. DQ 버퍼는 레지스터들에 저 장된 값들을 포함하는 DQ 신호들을 PHY로 전송할 수 있다. 도 4는 도 3의 제 2 데이터가 메모리 장치의 뱅크에 저장되는 예시를 도시한다. 메모리 컨트롤러는 제 2 데이터 집합(Data 2[0] ~ Data 2[7])을 뱅크의 에러 구역에 해당하는 메모리 셀들에 저장할 수 있다. 데이 터 집합은 다수의 데이터를 의미할 수 있고 그리고 인덱스는 데이터를 구별하기 위한 것이다. 도 4에서 X축은 워드 라인이 연장되는 방향과 복수의 비트 라인들이 배치되는 방향을 나타낼 수 있다. 도 4에서 Y축은 비트 라 인이 연장되는 방향과 복수의 워드 라인들이 배치되는 방향을 나타낼 수 있다. 예를 들어, 제 2 데이터 집합 (Data 2[0] ~ Data 2[7])의 각 데이터는 행 단위로 뱅크의 에러 구역에 저장될 수 있다. 각 데이터는 워드 라인에 연결되고 페이지를 구성하는 메모리 셀들에 저장될 수 있다. 실시 예에 있어서, 에러-프리 구역의 모든 메모리 셀들이 리프레쉬되는데 걸리는 시간, tREF는 k ms일 수 있다 (k는 임의의 숫자). 에러 구역의 모든 메모리 셀들이 리프레쉬되는데 걸리는 시간, tREF는 n X k ms일 수 있다. 예를 들어, n은 2 이상의 자연수일 있다. 에러 구역의 tREF는 에러-프리 구역의 tREF의 정수 배에 해당할 수 있 다. 에러-프리 구역의 리프레쉬 속도는 에러 구역의 리프레쉬 속도보다 빠를 수 있다. 실시 예에 있어서, 메모리 컨트롤러는 데이터의 종류, 데이터의 중요성, 응용 프로그램의 종류 등에 따라 데이터가 에러-프리 구역에 저장될지 또는 에러 구역에 저장될지를 결정할 수 있다. 메모리 컨트롤러는 신 경망의 데이터를 에러 구역에 저장할 수 있다. 메모리 컨트롤러는 프로그램 코드 또는 신경망과 다른 응용 프로그램의 데이터를 에러-프리 구역에 저장할 수 있다. 도 5는 도 3의 메모리 컨트롤러가 제 2 데이터를 메모리 장치에 저장하기 위한 예시적인 순서도를 도시한다. S110 단계에서, 메모리 컨트롤러의 에러 정정 회로는 제 1 데이터의 중요한 비트들의 에러 정정을 위 해 제 1 데이터의 일부 중요하지 않은 비트들을 패리티 비트들로 대체할 수 있다. 에러 정정 회로는 비트 의 중요도에 따라 패리티 비트들로 대체될 일부 중요하지 않은 비트들을 선택할 수 있다(도 2a 및 도 2c의 Data 1 [31:0] 참조). S120 단계에서, 에러 정정 회로는 제 1 데이터의 나머지 비트들과 패리티 비트들을 포함하는 제 2 데이터 를 생성할 수 있다(도 2a 및 도 2c의 Data 2 [31:0] 참조). 에러 정정 회로는 패리티 비트들을 제 1 데이 터에 부가하지 않고 일부 중요하지 않은 비트들을 패리티 비트들로 대체하므로, 제 2 데이터의 비트 수와 제 1 데이터의 비트 수는 동일할 수 있다. S130 단계에서, 메모리 컨트롤러의 명령 생성기는 S120 단계의 제 2 데이터를 메모리 장치에 저 장하기 위한 명령 및 어드레스를 생성할 수 있다. 여기서, 명령은 적어도 하나의 활성화 명령 및 적어도 하나의 쓰기 명령을 포함할 수 있다. 명령 생성기는 적어도 하나의 활성화 명령과 함께 적어도 하나의 어드레스를 생성할 수 있다. 적어도 하나의 어드레스는 뱅크의 에러 구역에 위치하는 메모리 셀들에 연결되는 워드 라 인들 중 적어도 하나의 워드 라인을 나타낼 수 있다. 도 6은 도 3의 메모리 컨트롤러가 메모리 장치의 에러 구역과 에러-프리 구역을 조정하기 위한 예시적인 순서도 를 도시한다. S210 단계에서, 메모리 컨트롤러의 명령 생성기는 에러 구역의 시작 어드레스를 생성할 수 있다. 예 를 들어, 에러 구역의 시작 어드레스는 로우 어드레스일 수 있다. 메모리 컨트롤러는 에러 구역의 시작 어 드레스를 메모리 장치에 설정하기 위한 명령을 생성할 수 있다. 에러 구역의 시작 어드레스를 기준으로 에 러 구역과 에러-프리 구역이 구분될 수 있고 시작 어드레스는 기준 어드레스로도 지칭될 수 있다. S220 단계에서 에러 구역을 조정하기 위한 설정 명령 및 에러 구역의 시작 어드레스를 메모리 장치로 전송 할 수 있다. 실시 예에 있어서, 명령 생성기는 유저, 프로세서, 또는 응용 프로그램의 요청에 따라 에러 구역의 시작 어드레스를 생성하거나 조정할 수 있다. 시작 어드레스의 값은 뱅크의 워드 라인들을 선택하 기 위한 로우 어드레스의 최소 값과 최대 값 사이의 임의의 값일 수 있다. 메모리 컨트롤러는 에러-프리 구역에 할당된 메모리 셀들의 개수와 에러 구역에 할당된 메모리 셀들의 개수의 비율을 조정할 수 있다. 실시 예에 있어서, 에러 구역의 시작 어드레스는 메모리 장치의 레지스터들에 저장될 수 있다. 제 1 카운터(132_1)는 에러 구역의 시작 어드레스를 기준으로 에러-프리 구역의 메모리 셀들과 연결된 워드 라인들에 대응하는 로우 어드레스를 생성할 수 있다. 제 2 카운터(132_2)는 에러 구역의 시작 어드레스를 기준으로 에러 구역의 메모리 셀들과 연결된 워드 라인들에 대응하는 로우 어드레스를 생성할 수 있다. 실시 예에 있어서, 에러 구역의 시작 어드레스는 메모리 컨트롤러의 레지스터에도 저장될 수 있다. 메모리 컨트롤러는 레지스터들을 읽기 위한 명령을 메모리 장치로 전송함으로써 레지스터들 에 저장된 에러 구역의 시작 어드레스를 읽고 메모리 컨트롤러의 레지스터에 저장할 수 있다. 실시 예에 있어서, 뱅크의 개수는 하나 이상일 수 있으므로, 뱅크들의 에러 구역들의 시작 어드레스 들은 서로 동일하거나 상이할 수 있다. 메모리 컨트롤러는 뱅크들의 에러 구역들의 시작 어드레스들 을 서로 동일하게 설정하거나 서로 다르게 설정할 수도 있다. 어느 경우든, 뱅크들의 에러 구역들의 시작 어드레스들은 각각 레지스터들에 저장될 수 있다. 뱅크들의 에러 구역들의 시작 어드레스들이 서로 다르게 설정되는 경우, 메모리 장치는 뱅크들 개수만큼의 리프레쉬 컨트롤러들을 포함할 수 있 다. 뱅크들의 에러 구역들의 시작 어드레스들이 서로 동일하게 설정되는 경우, 하나의 리프레쉬 컨트롤러 가 적어도 둘 이상의 뱅크들을 리프레쉬하기 위해 사용될 수 있다. 하나의 리프레쉬 컨트롤러에 의해 생성되는 로우 어드레스에 따라 적어도 둘 이상의 뱅크들의 메모리 셀들이 리프레쉬될 수 있다. 도 7은 도 3의 메모리 컨트롤러가 온도와 BER에 따라 리프레쉬 비율을 조정하기 위한 예시적인 순서도를 도시한 다. S310 단계에서, 메모리 컨트롤러는 메모리 장치의 현재 온도를 확인할 수 있다. 메모리 컨트롤러 의 명령에 응답하여, 온도 센서에 의해 감지되고 레지스터들에 저장된 현재 온도에 대응하는 값 은 읽기 회로 및 DQ 버퍼를 통해 메모리 컨트롤러로 제공될 수 있다. S320 단계에서, 메모리 컨트롤러는 원하는 BER을 확인할 수 있다. 예를 들어, 원하는 BER은 유저, 프로세 서, 또는 응용 프로그램의 요청에 의해 결정될 수 있다. 메모리 컨트롤러는 원하는 BER의 정보를 수신할 수 있다. S330 단계에서, 메모리 컨트롤러는 메모리 장치의 현재 온도와 원하는 BER에 기초하여 리프레쉬 비율 을 조정하기 위한 명령을 발행하고 그 명령을 메모리 장치로 전송할 수 있다. 메모리 컨트롤러는 레 지스터들에 저장된 룩업 테이블에 기초하여 리프레쉬 비율을 조정할 수 있다. 룩업 테이블은 도 8에서 상 세하게 설명될 것이다.예를 들어, 리프레쉬 비율은 뱅크의 에러-프리 구역의 리프레쉬 속도와 뱅크의 에러 구역의 리프레쉬 속도의 비율일 수 있다. 다른 예를 들어, 리프레쉬 비율은 뱅크의 에러-프리 구역의 모든 메모리 셀들이 리프레쉬되는데 필요한 시간과 뱅크의 에러 구역의 모든 메모리 셀들이 리프레쉬되는데 필요한 시간의 비 율일 수도 있다. 실시 예에 있어서, 메모리 컨트롤러는 리프레쉬 비율을 조정하기 위한 명령과 함께 리프레쉬 비율에 관한 정보를 생성할 수 있다. 메모리 컨트롤러는 리프레쉬 비율에 관한 정보를 메모리 장치로 전송할 수 있고 메모리 장치의 레지스터들에 리프레쉬 비율에 관한 정보가 저장될 수 있다. 예를 들어, 리프레 쉬 비율에 관한 정보는 에러-프리 구역의 리프레쉬 속도 또는 리프레쉬 시간에 관한 정보를 포함할 수 있다. 리 프레쉬 비율에 관한 정보는 에러 구역의 리프레쉬 속도 또는 리프레쉬 시간에 관한 정보를 포함할 수 있다. 리 프레쉬 속도와 리프레쉬 시간은 메모리 셀들이 얼마나 자주 리프레쉬되는지를 나타낼 수 있고 리프레쉬 시간은 리프레쉬 주기를 의미할 수 있다. 리프레쉬 컨트롤러는 레지스터들에 저장된 리프레쉬 비율에 관한 정보를 참조하여 에러-프리 구역의 리프레쉬 속도를 조정하거나 에러 구역의 리프레쉬 속도를 조정할 수 있다. 리프레쉬 컨트롤러는 메모리 컨트롤러의 명령에 응답하여 리프레쉬 비율을 조정할 수 있다. 도 8은 BER과 리프레쉬 간의 관계를 나타내는 룩업 테이블의 예시를 도시한다. 도 8의 룩업 테이블(LUT)은 BER 과 리프레쉬 시간 간의 관계를 나타낸다. 룩업 테이블(LUT)에서 BER들에 따른 리프레쉬 시간들이 각각 맵핑될 수 있다. 메모리 컨트롤러는 레지스터들에 저장된 룩업 테이블(LUT)을 참조하여 에러-프리 구역의 리 프레쉬 시간을 조정할 수 있다. 예를 들어, 유저, 프로세서, 또는 응용 프로그램에 의해 요청된 BER이 10-6이면, 에러 구역의 리프레쉬 시간은 에러-프리 구역의 리프레쉬 시간의 23배일 수 있다. 메모리 컨트롤러는 룩업 테이블(LUT)에 명시된 BER에 따른 리프레쉬 시간을 확인하고 에러 구역의 리프레쉬 속도를 조정할 수 있다. 룩업 테이블(LUT)에 명시된 리프 레쉬 시간들의 값들은 모두 예시적인 것에 불과하다. 요청된 BER이 증가할수록, 에러 구역의 리프레쉬 시간도 증가할 수 있다. 다른 예를 들어, 유저, 프로세서, 또는 응용 프로그램에 의해 요청된 BER이 디폴트(default)이 면, 에러 구역의 리프레쉬 시간과 에러-프리 구역의 리프레쉬 시간은 동일할 수 있다. 이 경우, 메모리 장치 는 근사적 메모리 장치로서 동작하지 않을 수 있다. 도 8을 참조하면, 룩업 테이블(LUT)은 일반 온도 범위에서 BER들에 따른 리프레쉬 시간들의 정보를 포함할 수 있다. 룩업 테이블(LUT)은 일반 온도 범위와 다르거나 높은 확장 온도 범위에서 BER들에 따른 리프레쉬 시간들 의 정보를 포함할 수 있다. 예를 들어, 확장 온도 범위에서 메모리 셀이 데이터를 보유할 수 있는 시간은 일반 온도 범위에서 메모리 셀이 데이터를 보유할 수 있는 시간보다 짧을 수 있다. 따라서, 확장 온도 범위에서의 리 프레쉬 시간들은 일반 온도 범위에서의 리프레쉬 시간들보다 짧을 수 있다. 도 9는 도 3의 메모리 장치가 리프레쉬 명령을 수행하기 위한 예시적인 순서도를 도시한다. S410 단계에서, 메모리 장치의 명령 디코더는 메모리 컨트롤러로부터 전송된 리프레쉬 명령을 디코딩할 수 있다. 메모리 컨트롤러는 반복적으로 리프레쉬 명령을 생성할 수 있다. 메모리 장치의 명령 디코더는 반복적으로 전송되는 리프레쉬 명령을 디코딩할 수 있다. 명령 디코더는 리프레쉬 컨 트롤러 및 로우 디코더를 제어할 수 있다. S420 단계에서, 리프레쉬 컨트롤러는 명령 디코더의 제어에 기초하여 제 1 카운터(132_1)를 동작시킬 수 있다. 제 1 카운터(132_1)는 에러-프리 구역에 해당하는 로우 어드레스를 생성 및 업데이트할 수 있다. 이전 S420 단계에서 제 1 카운터(132_1)에 의해 생성된 로우 어드레스와 현재 S420 단계에서 제 1 카운터(132_1)에 의해 생성된 로우 어드레스는 다를 수 있다. S430 단계에서, 로우 디코더는 제 1 카운터(132_1)에 의해 생성된 로우 어드레스를 수신할 수 있다. 로우 디코더는 로우 어드레스에 대응하는 적어도 하나의 워드 라인을 활성화하고 그 다음 비활성화할 수 있다. 로우 디코더에 의해 워드 라인이 활성화되고 비활성화되면, 워드 라인에 연결된 메모리 셀들이 리프레쉬될 수 있다. S430 단계에서 리프레쉬되는 메모리 셀들은 에러-프리 구역에 배치된 메모리 셀들이다. S410, S420, 및 S430 단계들은 에러-프리 구역에 배치된 메모리 셀들을 리프레쉬하기 위한 단계들이다. S440 단계에서, 리프레쉬 컨트롤러는 리프레쉬 명령을 건너뛸지 여부를 결정할 수 있다. S440 단계에서 리 프레쉬 명령을 건너뛰지 않으면(N), S450 단계에서 리프레쉬 컨트롤러는 제 2 카운터(132_2)를 동작시킬 수 있다. 제 2 카운터(132_2)는 에러 구역에 해당하는 로우 어드레스를 생성 및 업데이트할 수 있다. 이전 S450단계에서 제 2 카운터(132_2)에 의해 생성된 로우 어드레스와 현재 S450 단계에서 제 2 카운터(132_2)에 의해 생성된 로우 어드레스는 다를 수 있다. S460 단계에서, 로우 디코더는 제 2 카운터(132_2)에 의해 생성된 로우 어드레스를 수신할 수 있다. 로우 디코더는 로우 어드레스에 대응하는 적어도 하나의 워드 라인을 활 성화하고 그 다음 비활성화할 수 있다. 로우 디코더에 의해 워드 라인이 활성화되고 비활성화되면, 워드 라인에 연결된 메모리 셀들이 리프레쉬될 수 있다. S460 단계에서 리프레쉬되는 메모리 셀들은 에러 구역에 배 치된 메모리 셀들이다. S440 단계에서 리프레쉬 명령을 건너뛰면(Y), S470 단계에서 리프레쉬 컨트롤러는 건너뛴 리프레쉬 명령의 개수를 셀 수 있다. 건너뛴 리프레쉬 명령의 개수가 증가할수록, 에러 구역의 리프레쉬 속도는 느려지고 에러 구역의 리프레쉬 시간은 증가할 수 있다. 도 3에서 도시되진 않았으나, 리프레쉬 컨트롤러는 건너뛴 리프 레쉬 명령의 개수를 세는 카운터를 더 포함할 수 있다. 리프레쉬 컨트롤러는 건너뛴 리프레쉬 명령의 개수 와 기준 값을 비교하는 비교기를 더 포함할 수 있다. 예를 들어, 기준 값은 레지스터들에 저장될 수 있고 전술한 도 7의 S330 단계에서 메모리 컨트롤러에 의해 가변될 수 있다. 기준 값은 메모리 컨트롤러로 부터 전송된 리프레쉬 비율에 관한 정보에 의해 결정되거나 정보에 포함될 수 있다. 예를 들어, S440 단계에서, 리프레쉬 컨트롤러는 건너뛴 리프레쉬 명령의 개수가 기준 값에 도달하면, 리프레쉬 명령을 건너뛰지 않는 것으로 결정할 수 있다. S410, S440, S450, S460, 및 S470 단계들은 에러 구역에 배치된 메모리 셀들을 리프레 쉬하기 위한 단계들이다. 도 10은 본 발명의 다른 실시 예에 따른 도 1의 전자 장치의 예시적인 블록도를 좀 더 구체적으로 도시한다. 도 11은 도 10의 제 2 데이터가 메모리 장치의 뱅크에 저장되는 예시를 도시한다. 도 10과 도 11은 함께 설명될 것 이다. 도 10의 전자 장치와 도 3의 전자 장치 간의 차이점이 주로 설명될 것이다. 메모리 컨트롤러는 도 3의 메모리 컨트롤러에 비해 전치 회로를 더 포함할 수 있다. 전치 회로 는 에러 정정 회로에 의해 인코딩된 제 2 데이터(Data 2)를 수신하고 제 2 데이터를 제 2 전치 데이 터( )로 변환할 수 있다. PHY는 제 2 데이터 대신에 제 2 전치 데이터를 메모리 장치로 전송할 수 있다. 전치 회로에 의해 변환된 제 2 전치 데이터는 뱅크의 하나 이상의 페이지들에 저장될 수 있다. 전술 한 도 4를 참조하면, 제 2 데이터(예를 들어, Data 2 [0])는 하나의 페이지에 저장될 수 있다. 반면에, 도 11을 참조하면, 제 2 전치 데이터(예를 들어, )는 하나 이상의 페이지들에 저장될 수 있다. 전치 회로 는 제 2 데이터가 뱅크의 하나 이상의 페이지들에 저장되도록 제 2 데이터의 행과 열을 변경함으로써 제 2 전치 데이터를 생성할 수 있다. 전술한 도 3을 참조하면, 뱅크는 에러-프리 구역과 에러 구역으로 단지 2개의 구역들로 나뉘었다. 도 10 및 도 11을 참조하면, 뱅크는 제 1 내지 제 3 구역들(Zone 1 ~ Zone 3)로 나뉠 수 있다. 예를 들어, 뱅크 는 다수의 구역들로 나뉠 수 있고 다수의 구역들의 tREF들은 서로 다를 수 있다. 도 11을 참조하면, 제 1 구역의 tREF보다 제 2 구역의 tREF가 더 길 수 있다. 제 2 구역의 tREF보다 제 3 구역의 tREF가 더 길 수 있다. 전술한대로, tREF는 해당 구역의 모든 메모리 셀들이 리프레쉬되는데 걸리는 시간을 의미한다. 예를 들어, 제 1 구역은 전술한 에러-프리 구역에 해당할 수 있고 제 2 및 제 3 구역들은 전술한 에러 구역이 나뉜 구역들에 해 당할 수 있다. 다른 예를 들어, 제 1 내지 제 3 구역들은 모두 전술한 에러 구역이 나뉜 구역들에 해당할 수 있 다. 도 11을 참조하면, 제 2 전치 데이터의 부호 비트는 제 1 구역에 저장될 수 있다. 제 2 전치 데이터의 지수 비 트들은 제 2 구역에 저장될 수 있다. 제 2 전치 데이터의 가수 비트들은 제 3 구역에 저장될 수 있다. 예를 들 어, 제 2 전치 데이터의 MSB는 제 1 구역의 워드 라인에 연결된 메모리 셀들 중 하나에 저장될 수 있고 그리고 제 2 전치 데이터의 LSB는 제 3 구역의 워드 라인에 연결된 메모리 셀들 중 하나에 저장될 수 있다. 만약, 뱅크 가 3개 이상의 구역들로 나뉘면, 제 2 전치 데이터의 비트들도 3개 이상의 구역들에 분산되어 저장될 수 있다. 메모리 컨트롤러는 전치 회로를 이용하여 제 2 데이터의 비트들의 위치들을 변경할 수 있고, 중요한 비트가 tREF가 상대적으로 짧은 구역에 저장되고 중요하지 않은 비트가 tREF가 상대적으로 긴 구역에 저 장될 수 있다. 실시 예에 있어서, 전치 회로는 제 2 데이터의 비트들의 논리 값들을 변경할 수 있다. 제 1 논리 값이 메 모리 셀에서 유지되는 시간은 제 2 논리 값이 메모리 셀에서 유지되는 시간보다 길 수 있다. 따라서, 전치 회로 는 제 2 데이터의 비트들의 제 1 논리 값들의 개수와 제 2 데이터의 비트들의 제 2 논리 값들의 개수를 비교할 수 있다. 전치 회로는 제 2 논리 값들보다 더 많은 제 1 논리 값들이 메모리 셀들에 저장되도록, 비 교 결과에 기초하여 제 2 데이터의 비트들의 논리 값들을 컬럼 단위로 반전할 수 있다. 전치 회로는 메모 리 장치로부터 전송되는 읽기 데이터의 비트들을 다시 반전할 수 있다. 메모리 장치의 리프레쉬 컨트롤러는 제 3 카운터(132_3)를 더 포함할 수 있다. 도 10의 제 1 및 제 2 카운터들(132_1, 132_2)은 도 3의 제 1 및 제 2 카운터들(132_1, 132_2)과 실질적으로 동일하게 동작할 수 있다. 제 3 카운터(132_3)는 제 2 카운터(132_2)와 실질적으로 동일하게 동작할 수 있다. 제 1 카운터(132_1)는 제 1 구역에 배치된 메모리 셀들을 리프레쉬하기 위한 로우 어드레스를 생성할 수 있다. 제 2 카운터(132_2)는 제 2 구역에 배치된 메모리 셀들을 리프레쉬하기 위한 로우 어드레스를 생성할 수 있다. 제 3 카운터(132_3)는 제 3 구역에 배치된 메모리 셀들을 리프레쉬하기 위한 로우 어드레스를 생성할 수 있다. 멀티플렉서(132_4)는 제 3 카운터(132_3)에 의해 생성된 로우 어드레스도 로우 디코더로 제공할 수 있다. 제 1 내지 제 3 카운 터들(132_1~132_3)이 로우 어드레스들을 생성하는 주기들 또는 시점들은 서로 상이할 수 있다. 즉, 리프레쉬 컨 트롤러는 제 1 내지 제 3 구역들의 tREF들이 서로 다르도록, 제 1 내지 제 3 카운터들(132_1~132_3)을 제 어할 수 있다. 리프레쉬 컨트롤러는 뱅크가 나뉘는 구역들의 개수만큼의 카운터들을 포함할 수 있다. 도 12는 본 발명의 실시 예에 따른 도 1의 메모리 장치를 도시한다. 메모리 장치는 메모리 모듈일 수 있 다. 메모리 모듈은 JEDEC(Joint electron device engineering council) 표준을 따르는 DIMM(Dual in-line memory module), RDIMM(Registered DIMM), LRDIMM(Load reduced DIMM), UDIMM(Unbuffered DIMM), FB- DIMM(Fully buffered DIMM), SO-DIMM(Small outline DIMM), 또는 다른 메모리 모듈(예를 들면, SIMM(Single in-line memory module)일 수 있다. 메모리 장치는 제 1 내지 제 8 메모리 칩들(1310~1380)을 포함할 수 있다. 제 1 내지 제 8 메모리 칩들(1310~1380) 각각은 DDR SDRAM(Double data rate synchronous dynamic random access memory), DDR2 SDRAM, DDR3 SDRAM, DDR4 SDRAM, DDR5 SDRAM, LPDDR(low power double data rate) SDRAM, LPDDR2 SDRAM, LPDDR3 SDRAM, LPDDR4 SDRAM, LPDDR4X SDRAM, LPDDR5 SDRAM, GDDR SGRAM(Graphics double data rate synchronous graphics random access memory), GDDR2 SGRAM, GDDR3 SGRAM, GDDR4 SGRAM, GDDR5 SGRAM, GDDR6 SGRAM 등과 같은 다양한 DRAM 장치들일 수 있다. 제 1 내지 제 8 메모리 칩들(1310~1380) 각각은 도 3 또는 도 10의 메모리 장치일 수 있고 메모리 장치 의 구성 요소들을 포함할 수 있다. 제 1 내지 제 8 메모리 칩들(1310~1380) 각각은 에러-프리 구역에 해당 하는 메모리 셀들과 에러 구역에 해당하는 메모리 셀들을 포함할 수 있다. 제 1 내지 제 8 메모리 칩들 (1310~1380)은 메모리 컨트롤러(도 3 및 도 10의 110 참조)로부터 전송되는 명령과 어드레스(CMD/ADD)를 공통으 로 수신할 수 있다. 제 1 내지 제 8 메모리 칩들(1310~1380) 각각은 8개의 DQ 신호들을 메모리 컨트롤러로 전송하거나 메모리 컨트 롤러로부터 수신할 수 있다. 메모리 장치는 총 64개의 DQ 신호들(DQ[63:0])을 메모리 컨트롤러로 전송하 거나 메모리 컨트롤러로부터 수신할 수 있다. 예를 들어, 제 2 데이터의 비트 수가 32인 경우, 제 1 워드에 해 당하는 제 2 데이터는 제 1 내지 제 4 메모리 칩들(1310~1340)에 저장될 수 있다. 제 2 워드에 해당하는 제 2 데이터는 제 5 내지 제 8 메모리 칩들(1350~1380)에 저장될 수 있다. 다른 메모리 칩들(1320~1340, 1360~138 0)에 비해 제 1 및 제 5 메모리 칩들(1310, 1350)은 상대적으로 중요한 비트들, 즉 부호 비트 및 지수 비트들을 저장할 수 있다. 전술한대로, 제 2 데이터는 제 1 내지 제 8 메모리 칩들(1310~1380)의 에러-프리 구역에 해당 하는 메모리 셀들에 저장될 수 있다. 도 13은 본 발명의 다른 실시 예에 따른 도 1의 메모리 장치를 도시한다. 메모리 장치는 도 12의 메모리 장치와 유사한 메모리 모듈일 수 있다. 메모리 장치와 메모리 장치 간의 차이점이 주로 설명 될 것이다. 제 2 내지 제 4 메모리 칩들(2320~2340)과 제 6 내지 제 8 메모리 칩들(2360~2380) 각각은 도 3 또는 도 10의 메모리 장치일 수 있고 메모리 장치의 구성 요소들을 포함할 수 있다. 제 2 내지 제 4 메모리 칩들 (2320~2340)과 제 6 내지 제 8 메모리 칩들(2360~2380)의 메모리 셀들은 에러-프리 구역과 에러 구역으로 구별 될 수 있다. 제 1 및 제 5 메모리 칩들(2310, 2350)의 메모리 셀들은 제 2 내지 제 4 메모리 칩들(2320~2340)과 제 6 내지 제 8 메모리 칩들(2360~2380)과 달리 에러-프리 구역과 에러 구역으로 구별되지 않을 수 있다. 제 1 및 제 5 메 모리 칩들(2310, 2350)의 메모리 셀들은 모두 에러-프리 구역에 해당할 수 있다. 예를 들어, 제 1 및 제 5 메모리 칩들(2310, 2350)은 제 2 및 제 3 카운터들(132_2, 132_3)과 멀티플렉서(132_4)를 제외한 메모리 장치(13 0)의 구성 요소들을 포함할 수 있다. 다른 예를 들어, 제 1 및 제 5 메모리 칩들(2310, 2350)은 메모리 장치 의 모든 구성 요소들을 포함할 수 있다. 메모리 컨트롤러는 제 1 및 제 5 메모리 칩들(2310, 2350)의 뱅크의 메모리 셀들이 모두 동일한 속도로 리프레쉬되도록 제 1 및 제 5 메모리 칩들(2310, 2350)을 설정 할 수 있다. 도 12의 경우와 유사하게, 제 1 내지 제 8 메모리 칩들(2310~2380) 각각은 8개의 DQ 신호들을 메모리 컨트롤러 로 전송하거나 메모리 컨트롤러로부터 수신할 수 있다. 메모리 장치는 총 64개의 DQ 신호들(DQ[63:0])을 메모리 컨트롤러로 전송하거나 메모리 컨트롤러로부터 수신할 수 있다. 예를 들어, 제 2 데이터의 비트 수가 32 인 경우, 제 1 워드에 해당하는 제 2 데이터는 제 1 내지 제 4 메모리 칩들(2310~2340)에 저장될 수 있다. 제 2 워드에 해당하는 제 2 데이터는 제 5 내지 제 8 메모리 칩들(2350~2380)에 저장될 수 있다. 다른 메모리 칩들 (2320~2340, 2360~2380)에 비해 제 1 및 제 5 메모리 칩들(2310, 2350)은 상대적으로 중요한 비트들, 즉 부호 비트 및 지수 비트들을 저장할 수 있다. 제 1 및 제 5 메모리 칩들(2310, 2350)에 저장된 비트들이 리프레쉬되 는 속도는 제 2 내지 제 4 메모리 칩들(2320~2340) 및 제 6 내지 제 8 메모리 칩들(2360~2380)에 저장된 비트들 이 리프레쉬되는 속도보다 빠를 수 있다. 도 14는 본 발명의 다른 실시 예에 따른 전자 장치의 예시적인 블록도를 도시한다. 전자 장치는 SoC(System-on-Chip; 3100) 및 메모리 장치를 포함할 수 있다. SoC는 PHY를 포함하는 메모 리 컨트롤러, 프로세서, 및 메모리를 포함할 수 있다. 메모리 컨트롤러는 도 1 내지 도 11을 참조하여 전술한 메모리 컨트롤러일 수 있다. PHY는 도 1 내지 도 11을 참조하여 전술한 PHY일 수 있다. 메모리 장치는 에러-프리 구역과 에러 구역으로 구분되는 메모리 셀들을 포함하는 메모리 장치일 수 있다. 프로세서는 메모리에 로드된 다양한 소프트웨어(응용 프로그램, 운영 체제, 파일 시스템, 장치 드 라이버 등)을 실행할 수 있다. 프로세서는 동종 멀티-코어 프로세서(homogeneous multi-core processo r)들 또는 이종 멀티-코어 프로세서(heterogeneous multi-core processor)들을 포함할 수 있다. 예를 들어, 프 로세서는 CPU(central processing unit), ISP(image signal processing unit), DSP(digital signal processing unit), GPU(graphics processing unit), VPU(vision processing unit), 및 NPU(neural processing unit) 중 적어도 하나를 포함할 수 있다. 메모리에는 전자 장치를 구동하기 위한 응용 프로그램, 운영 체제, 파일 시스템, 장치 드라이버 등 이 로드될 수 있다. 예를 들어, 메모리는 SoC의 내부에서 구현되고 메모리 장치보다 빠른 데 이터 입출력 속도를 갖는 SRAM 장치일 수 있고 레지스터들, 래치들, 또는 플립-플롭들 등을 이용하여 구현될 수 있다. 메모리는 온-칩 메모리 또는 버퍼 메모리로도 지칭될 수 있다. 메모리는 프로그램 코드를 저장하는 비일시적 컴퓨터 판독 가능한 매체일 수 있다. 메모리는 RAM(Random Access Memory), 플래시 메모리, ROM(Read Only Memory), EPROM(Electrically Programmable ROM), EEPROM(Electrically Erasable Programmable ROM), 레지스터, 하드 디스크, 착탈식 디스크, CD-ROM, 또는 임의 의 형태의 저장 매체일 수 있다. 도 14의 도시대로, 메모리는 SoC 내에서 구현될 수도 있거나, 또 는 도 14의 도시와 달리 메모리는 전자 장치 내에서 SoC와 독립적으로 구현되거나 또는 전자 장치의 외부에 위치하는 저장 매체일 수도 있다. 실시 예에 있어서, 메모리에 저장되거나 로드된 프로그램 코드는 프로세서에 의해 실행될 수 있다. 프로그램 코드를 실행하는 프로세서의 제어에 기초하여, 메모리 컨트롤러는 도 5 내지 도 7의 순서 도들의 단계들(S110~S130, S210~S220, S310~S330)을 수행할 수 있다. 실시 예에 있어서, 메모리에 저장된 프로그램 코드는 프로세서와 구별된 메모리 컨트롤러 내 부의 다른 프로세서(미도시) 에 의해 실행될 수 있다. 메모리 컨트롤러 내부의 프로세서는 프로그램 코드 를 실행하고 도 5 내지 도 7의 순서도들의 단계들(S110~S130, S210~S220, S310~S330)을 수행할 수 있다. 실시 예에 있어서, SoC의 메모리 컨트롤러, 프로세서, 및 메모리는 버스를 통해 서로 연결될 수 있다. 버스는 AMBA(Advanced Microcontroller Bus Architecture) 표준 버스 규격 타입일 수 있다. AMBA의 버스 타입으로는 AHB(Advanced High-Performance Bus), APB(Advanced Peripheral Bus), AXI(Advanced eXtensible Interface)가 있을 수 있다. 도 15는 도 14의 메모리 컨트롤러의 동작 방법을 나타내는 예시적인 순서도를 도시한다. S1100 단계에서, 메모리 컨트롤러는 프로세서의 요청을 수신할 수 있다. 프로세서는 DNN, CNN, RNN, SNN 등과 같은 신경망, 응용 프로그램을 실행할 수 있다. 프로세서는 데이터에 관한 요청을 메 모리 컨트롤러에 제공할 수 있다. 프로세서는 데이터를 메모리 컨트롤러로 제공할 수 있다. S1200 단계에서, 메모리 컨트롤러는 프로세서로부터 제공된 논리 어드레스를 메모리 장치의 물리 어드레스(예를 들어, 뱅크 어드레스, 로우 어드레스, 컬럼 어드레스)로 변환할 수 있다. 메모리 컨트롤러 는 요청의 논리 어드레스가 변환된 물리 어드레스가 에러 구역에 대응하는지를 확인할 수 있다. S1300 단계에서, 메모리 컨트롤러는 S1100 단계의 요청에 따른 데이터가 메모리에 캐시(저장)되어 있는지를 확인할 수 있다. S1300 단계의 메모리는 SoC 내부의 캐시 메모리, 버퍼 메모리, 또는 온- 칩 메모리일 수 있다. S1100 단계의 요청에 따른 데이터가 메모리에 캐시되어 있으면(히트, Y), S1700 단 계가 진행될 수 있다. S1100 단계의 요청에 따른 데이터가 메모리에 캐시되어 있지 않으면(미스, N), S1400 단계가 진행될 수 있다. S1400 단계에서, 메모리 컨트롤러는 메모리의 캐시 라인(혹은 엔트리)의 플래그 비트가 더티 (dirty)인지를 확인할 수 있다. 플래그 비트가 더티로 설정되어 있으면(Y), 캐시 라인의 데이터와 메모리 장치 의 데이터가 다름을 의미할 수 있다. S1500 단계에서, 메모리 컨트롤러는 캐시 라인의 데이터를 메 모리 장치에 쓸 수 있다. 플래그 비트가 더티가 아닌 클린(clean)으로 설정되어 있으면(N), 메모리 컨트 롤러는 메모리 장치를 읽고 읽혀진 데이터를 캐시 라인에 기입할 수 있다. S1700 단계에서, 메모리 컨트롤러는 메모리로 접근할 수 있다. S1800 단계에서, 메모리 컨트롤러 는 S1100의 요청이 쓰기인지 여부를 확인할 수 있다. 요청이 쓰기이면(Y), 메모리 컨트롤러는 S1900 단계에서, 캐시 라인의 플래그 비트를 더티로 설정할 수 있다. 요청이 읽기이면(N), 메모리 컨트롤러 는 메모리에 캐시된 데이터를 프로세서로 리턴(return)할 수 있다. 이후, 메모리 컨트롤러 는 새로운 요청을 수신할 수 있다(S1100 단계). 도 16은 본 발명의 또 다른 실시 예에 따른 전자 장치의 예시적인 블록도를 도시한다. 전자 장치는 SoC, 기판, 및 메모리 장치를 포함할 수 있다. SoC는 기판의 일면에 배치될 수 있고 그리고 SoC의 일면에는 솔더 볼 또는 범프가 배치될 수 있다. 솔더 볼 또는 범프를 통해 SoC와 기판이 서로 전기적으로 연결될 수 있다. SoC는 도 13의 메모리 컨트롤러, PHY, 프로세서, 메모리 등을 포함할 수 있다. SoC는 메 모리 컨트롤러의 구성 요소들을 포함할 수 있다. SoC의 메모리 컨트롤러는 도 5 내지 도 7 그리고 도 15의 순서도들의 단계들을 수행할 수 있다. 기판은 SoC와 메모리 장치간의 입출력 경로를 제공할 수 있다. 예를 들어, 기판은 인 쇄 회로 기판, 연성 회로 기판, 세라믹 기판, 또는 인터포저(interposer)일 수 있다. 기판이 인터포저인 경우, 기판은 실리콘 웨이퍼를 이용하여 구현될 수 있다. 기판의 내부에는 다수의 입출력 경로들 (I/O Path)이 구현될 수 있다. 입출력 경로들을 통해 명령, 어드레스, 및 데이터가 전송될 수 있다. 메모리 장치는 수직 방향으로 적층된 메모리 다이들(4310, 4320)과 버퍼 다이를 포함할 수 있다. 메모리 장치는 HBM(high bandwidth memory), HBM2, HBM3 등과 같이 DRAM 다이들(Dies)이 적층된 메모리 장치일 수 있다. 메모리 장치는 기판의 일면에 배치될 수 있고 그리고 메모리 장치의 일면에 는 솔더 볼(Solder ball) 또는 범프(Bump)가 배치될 수 있다. 솔더 볼 또는 범프를 통해 메모리 장치와 기판이 서로 전기적으로 연결될 수 있다. 관통 전극들(TSV)은 메모리 다이들(4310, 4320)과 버퍼 다이 간의 물리적인 또는 전기적인 경로들을 제공 할 수 있다. 예를 들어, 관통 전극들(TSV)은 매트리스 배열로 배치될 수 있고 배치 위치는 도 16에서 도시된 것으로 한정되지 않는다. 메모리 다이는 제 1 영역과 제 2 영역을 포함할 수 있다. 제 1 영역은 도 3 또는 도 10에서 설명된 메모리 장치의 구성 요소들이 배치될 수 있다. 제 2 영역은 관통 전극들(TSV)이 배치 될 수 있고 관통 전극들(TSV)을 통해 신호를 전송하거나 수신하기 위한 회로들이 배치될 수 있다. 메모리 다이 는 메모리 다이와 실질적으로 동일하게 구현될 수 있다. 버퍼 다이(4330; 코어 다이 또는 로직 다이로도 지칭될 수 있음)는 제 1 영역과 제 2 영역을 포함 할 수 있다. 제 1 영역은 SoC로부터 입출력 경로들(I/O Path)을 통해 전송되는 명령, 어드레스, 데이터 입출력 신호(CMD, ADD, DQ)를 수신하는 적어도 하나의 수신기가 배치될 수 있다. 제 1 영역은 데이 터 입출력 신호(DQ)를 입출력 경로들(I/O Path)을 통해 SoC로 전송하는 적어도 하나의 송신기가 배치될 수 있다. 또한, 제 1 영역에는 도 3 또는 도 10에서 설명된 메모리 장치의 구성 요소들이 배치될 수 있다. 제 2 영역은 관통 전극들(TSV)이 배치될 수 있고 관통 전극들(TSV)을 통해 신호를 전송하거나 수신 하기 위한 회로들이 배치될 수 있다. 위에서 설명한 내용은 본 발명을 실시하기 위한 구체적인 예들이다. 본 발명에는 위에서 설명한 실시 예들뿐만 아니라, 단순하게 설계 변경하거나 쉽게 변경할 수 있는 실시 예들도 포함될 것이다. 또한, 본 발명에는 상술한 실시 예들을 이용하여 앞으로 쉽게 변형하여 실시할 수 있는 기술들도 포함될 것이다."}
{"patent_id": "10-2019-0047910", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 실시 예에 따른 전자 장치의 예시적인 블록도를 도시한다. 도 2a는 도 1의 제 1 데이터가 제 2 데이터로 변환되는 예시를 도시한다. 도 2b는 도 1의 제 1 데이터의 일부 비트들의 예시적인 값들을 도시한다. 도 2c는 도 1의 제 1 데이터가 제 2 데이터로 변환되는 다른 예시를 도시한다. 도 3은 도 1의 전자 장치의 예시적인 블록도를 좀 더 구체적으로 도시한다. 도 4는 도 3의 제 2 데이터가 메모리 장치의 뱅크에 저장되는 예시를 도시한다. 도 5는 도 3의 메모리 컨트롤러가 제 2 데이터를 메모리 장치에 저장하기 위한 예시적인 순서도를 도시한다. 도 6은 도 3의 메모리 컨트롤러가 메모리 장치의 에러 구역과 에러-프리 구역을 조정하기 위한 예시적인 순서도 를 도시한다.도 7은 도 3의 메모리 컨트롤러가 온도와 BER에 따라 리프레쉬 비율을 조정하기 위한 예시적인 순서도를 도시한 다. 도 8은 BER과 리프레쉬 간의 관계를 나타내는 룩업 테이블의 예시를 도시한다. 도 9는 도 3의 메모리 장치가 리프레쉬 명령을 수행하기 위한 예시적인 순서도를 도시한다. 도 10은 본 발명의 다른 실시 예에 따른 도 1의 전자 장치의 예시적인 블록도를 좀 더 구체적으로 도시한다. 도 11은 도 10의 제 2 데이터가 메모리 장치의 뱅크에 저장되는 예시를 도시한다. 도 12는 본 발명의 실시 예에 따른 도 1의 메모리 장치를 도시한다. 도 13은 본 발명의 다른 실시 예에 따른 도 1의 메모리 장치를 도시한다. 도 14는 본 발명의 다른 실시 예에 따른 전자 장치의 예시적인 블록도를 도시한다. 도 15는 도 14의 메모리 컨트롤러의 동작 방법을 나타내는 예시적인 순서도를 도시한다. 도 16은 본 발명의 또 다른 실시 예에 따른 전자 장치의 예시적인 블록도를 도시한다."}
