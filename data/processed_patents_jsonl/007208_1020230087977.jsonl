{"patent_id": "10-2023-0087977", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0076669", "출원번호": "10-2023-0087977", "발명의 명칭": "프로세싱 장치 및 그의 시큐어 부팅 방법", "출원인": "리벨리온 주식회사", "발명자": "최명훈"}}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "루트 오브 트러스트(Root of Trust)를 구동시키고, 상기 루트 오브 트러스트를 통해서 제1 펌웨어의 제1 인테그리티 체크 및 제2 펌웨어의 제2 인테그리티 체크를 순차적으로 수행하는 시큐리티 코어; 상기 제1 펌웨어의 제1 구동 및 상기 제2 펌웨어의 제2 구동을 순차적으로 수행하는 메인 코어;상기 제1 펌웨어 및 상기 제2 펌웨어를 저장하는 비휘발성 메모리; 및상기 제1 펌웨어 및 상기 제2 펌웨어를 상기 메인 코어의 메인 코어 도메인에서 로드하여 상기 메인 코어에 의해서 구동시키는 제1 휘발성 메모리를 포함하되,상기 제1 인테그리티 체크는 상기 제1 구동 전에 수행되고,상기 제2 인테그리티 체크는 상기 제2 구동 전에 수행되고,상기 제1 구동은 상기 제2 인테그리티 체크와 병렬적으로 수행되는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서,상기 시큐리티 코어는 상기 제1 인테그리티 체크 이후 상기 제1 펌웨어를 제1 휘발성 메모리로 전송하고, 상기제2 인테그리티 체크 이후 상기 제2 펌웨어를 상기 제1 휘발성 메모리로 전송하는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1 항에 있어서, 상기 시큐리티 코어는,상기 메인 코어에서 상기 시큐리티 코어로의 데이터 전송을 제어하는 메인-시큐리티 인터페이스와,상기 시큐리티 코어에서 상기 메인 코어로의 데이터 전송을 제어하는 시큐리티-메인 인터페이스를 포함하는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3 항에 있어서,상기 메인 코어는, 상기 메인 코어가 상기 메인-시큐리티 인터페이스를 통해서 상기 시큐리티 코어에 접근할 수있는 제1 영역을 포함하고,상기 시큐리티 코어는, 상기 시큐리티 코어가 상기 시큐리티-메인 인터페이스를 통해서 상기 메인 코어에 접근할 수 있는 제2 영역을 포함하고,상기 제1 영역은 상기 제2 영역보다 작은,공개특허 10-2024-0076669-3-프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1 항에 있어서,상기 제1 구동 시간과 상기 제2 인테그리티 체크 시간이 서로 오버랩되는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1 항에 있어서, 상기 시큐리티 코어는 제3 펌웨어의 제3 인테그리티 체크를 수행하고,상기 메인 코어는 상기 제3 펌웨어의 제3 구동을 수행하는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6 항에 있어서,상기 시큐리티 코어는 상기 제1 내지 제3 인테그리티 체크를 순차적으로 수행하고,상기 메인 코어는 상기 제1 내지 제3 구동을 순차적으로 수행하는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제6 항에 있어서,상기 제3 인테그리티 체크는 상기 제3 구동 전에 수행되고,상기 제2 구동은 상기 제3 인테그리티 체크와 병렬적으로 수행되는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8 항에 있어서,상기 제2 구동 시간과 상기 제3 인테그리티 체크 시간이 서로 오버랩되는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제1 항에 있어서, 상기 메인 코어가 태스크 디스크립터를 전달하여 태스크를 수행시키는 적어도 하나의 뉴럴 프로세서와,상기 적어도 하나의 뉴럴 프로세서가 공유하는 공유 메모리를 더 포함하는,공개특허 10-2024-0076669-4-프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제1 항에 있어서,상기 시큐리티 코어가 상기 루트 오브 트러스트를 로드하기 위한 제2 휘발성 메모리를 더 포함하는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11 항에 있어서,상기 제2 휘발성 메모리는 상기 제1 휘발성 메모리와 분리된,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제1 항에 있어서, 상기 메인 코어에 의해서 생성된 태스크를 각각 수신하는 복수의 뉴럴 프로세서와,상기 복수의 뉴럴 프로세서, 상기 메인 코어, 상기 시큐리티 코어 사이에서 데이터를 전송하는 글로벌 인터커넥션을 더 포함하는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13 항에 있어서,상기 복수의 뉴럴 프로세서는 각각 상기 태스크에 대한 완료 리포트를 생성하여 상기 메인 코어로 전달하는,프로세싱 장치."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "시큐리티 코어가 루트 오브 트러스트를 구동하고, 상기 시큐리티 코어가 제1 펌웨어의 제1 인테그리티 체크 및 제2 펌웨어의 제2 인테그리티 체크를 순차적으로수행하고,메인 코어가 상기 제1 인테그리티 체크가 수행된 제1 펌웨어의 제1 구동 및 상기 제2 인테그리티 체크가 수행된제2 펌웨어의 제2 구동을 수행하는 것을 포함하되,상기 제1 구동이 상기 제2 인테그리티 체크와 병렬적으로 수행되는,프로세싱 장치의 시큐어 부팅 방법."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15 항에 있어서,공개특허 10-2024-0076669-5-상기 제1 인테그리티 체크 및 상기 제2 인테그리티 체크에서, 상기 제1 펌웨어 및 상기 제2 펌웨어 중 적어도하나가 변조가 발견된 경우, 상기 시큐리티 코어가 상기 메인 코어의 동작을 중지시키는 것을 더 포함하는,프로세싱 장치의 시큐어 부팅 방법."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16 항에 있어서,상기 시큐리티 코어가 상기 메인 코어의 동작을 중지시킨 후 제1 휘발성 메모리의 데이터를 모두 초기화하는 것을 더 포함하고,상기 제1 휘발성 메모리는 상기 제1 펌웨어 및 상기 제2 펌웨어를 상기 메인 코어의 메인 코어 도메인에서 로드하여 상기 메인 코어에 의해서 구동시키는,프로세싱 장치의 시큐어 부팅 방법"}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17 항에 있어서,상기 제1 펌웨어 및 상기 제2 펌웨어 중 적어도 하나가 변조가 발견된 경우, 상기 시큐리티 코어가 상기 제1 펌웨어 및 상기 제2 펌웨어를 교체하는 리커버리 모드를 실행시키는 것을 더 포함하고,상기 메인 코어는 상기 리커버리 모드 동안 동작이 제한되는,프로세싱 장치의 시큐어 부팅 방법."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18 항에 있어서, 상기 제1 펌웨어 및 상기 제2 펌웨어가 정상화되면, 상기 시큐리티 코어가 상기 리커버리 모드를 종료하고, 상기 메인 코어의 동작을 재개시키는 것을 더 포함하는,프로세싱 장치의 시큐어 부팅 방법."}
{"patent_id": "10-2023-0087977", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제15 항에 있어서,상기 루트 오브 트러스트를 구동하는 것은, 이뮤터블 메모리에서 상기 루트 오브 트러스트를 로드하는 것을 포함하되,상기 이뮤터블 메모리는 상기 메인 코어는 접근 불가능하고, 상기 시큐리티 코어는 접근 가능한,프로세싱 장치의 시큐어 부팅 방법."}
{"patent_id": "10-2023-0087977", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 프로세싱 장치 및 그의 시큐어 부팅 방법을 개시한다. 상기 프로세싱 장치는 루트 오브 트러스트(Root of Trust)를 구동시키고, 상기 루트 오브 트러스트를 통해서 제1 펌웨어 및 제2 펌웨어의 인테그리티 체크 (integrity check)를 순차적으로 수행하는 시큐리티 코어, 상기 제1 펌웨어 및 제2 펌웨어를 순차적으로 구동시 키는 메인 코어, 상기 제1 펌웨어 및 상기 제2 펌웨어를 저장하는 비휘발성 메모리 및 상기 제1 펌웨어 및 상기 제2 펌웨어를 상기 메인 코어의 메인 코어 도메인에서 로드하여 상기 메인 코어에 의해서 구동시키는 제1 휘발성 메모리를 포함한다."}
{"patent_id": "10-2023-0087977", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 프로세싱 장치 및 그의 시큐어 부팅 방법에 관한 것이다. 구체적으로, 본 발명은 프로세싱 장치의 시 큐리티 코어의 활용성을 극대화시킨 프로세싱 장치 및 그의 시큐어 부팅 방법에 관한 것이다."}
{"patent_id": "10-2023-0087977", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "시스템을 구성하는 요소인 코어(core)는 메모리에 저장된 펌웨어를 구동시켜서 시스템 사용자가 원하는 동작을 수행한다. 만약 펌웨어가 악의적인 공격에 의해서 변조가 되는 경우에는 시스템의 전체적인 보안에 문제가 생길 수 있다. 시큐어 부팅은 부팅과정에서 이러한 펌웨어의 무결성을 체크하는 인테그리티 체크 절차를 포함한다. 인테그리티 체크 과정은 변조 불가능한 루트 오브 트러스트(Root of Trust)를 시작으로 순차적으로 진행되고, 이러한 일련의 과정을 체인 오브 트러스트(Chain of Trust)라고 부른다. 이러한 체인 오브 트러스트 과정에서 코어의 활용이 더욱 향상될 수 있다면, 부팅의 속도와 전체 장치의 성능이 크게 개선될 수 있다. 선행기술문헌 특허문헌 (특허문헌 0001) 등록특허공보 제10-2126931호"}
{"patent_id": "10-2023-0087977", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명의 과제는, 시큐리티 코어를 효율적으로 활용하는 프로세싱 장치를 제공하는 것이다. 본 발명의 다른 과제는, 시큐리티 코어를 효율적으로 활용하는 프로세싱 장치의 시큐어 부팅 방법을 제공하는 것이다. 본 발명의 목적들은 이상에서 언급한 목적으로 제한되지 않으며, 언급되지 않은 본 발명의 다른 목적 및 장점들 은 하기의 설명에 의해서 이해될 수 있고, 본 발명의 실시예에 의해 보다 분명하게 이해될 것이다. 또한, 본 발 명의 목적 및 장점들은 특허 청구 범위에 나타낸 수단 및 그 조합에 의해 실현될 수 있음을 쉽게 알 수 있을 것 이다."}
{"patent_id": "10-2023-0087977", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "상기 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 프로세싱 장치는 루트 오브 트러스트(Root of Trus t)를 구동시키고, 상기 루트 오브 트러스트를 통해서 제1 펌웨어 및 제2 펌웨어의 인테그리티 체크(integrity check)를 순차적으로 수행하는 시큐리티 코어, 상기 제1 펌웨어 및 제2 펌웨어를 순차적으로 구동시키는 메인 코어, 상기 제1 펌웨어 및 상기 제2 펌웨어를 저장하는 비휘발성 메모리 및 상기 제1 펌웨어 및 상기 제2 펌웨 어를 상기 메인 코어의 메인 코어 도메인에서 로드하여 상기 메인 코어에 의해서 구동시키는 제1 휘발성 메모리 를 포함한다. 또한, 상기 루트 오브 트러스트를 저장하고, 저장 내용이 변조되지 않는 이뮤터블 메모리를 더 포함할 수 있다. 또한, 상기 시큐리티 코어는 상기 제1 및 제2 펌웨어의 인테그리티 체크 이후에 상기 제1 및 제2 펌웨어를 상기 제1 휘발성 메모리로 전송할 수 있다. 또한, 상기 시큐리티 코어는, 암호화 동작을 가속화시키는 크립토 액셀러레이터를 포함할 수 있다. 또한, 상기 시큐리티 코어는, 상기 메인 코어에서 상기 시큐리티 코어로의 데이터 전송을 제어하는 메인-시큐리 티 인터페이스를 더 포함할 수 있다. 또한, 상기 시큐리티 코어는, 상기 시큐리티 코어에서 상기 메인 코어로의 데이터 전송을 제어하는 시큐리티-메 인 인터페이스를 더 포함할 수 있다. 또한, 상기 메인-시큐리티 인터페이스 및 상기 시큐리티 메인 인터페이스는 상기 메인 코어 및 상기 시큐리티 코어가 접근 가능하고, 상기 이뮤터블 메모리 인터페이스는 상기 시큐리티 코어가 접근 가능하고, 상기 메인 코 어는 접근 불가능할 수 있다. 또한, 상기 시큐리티 코어는 상기 제1 펌웨어가 구동되기 전에 상기 제1 펌웨어의 인테그리티 체크를 수행할 수 있다. 또한, 상기 시큐리티 코어는 상기 제2 펌웨어가 구동되기 전에 상기 제2 펌웨어의 인테그리티 체크를 수행할 수 있다. 또한, 상기 메인 코어의 상기 제1 펌웨어의 구동은 상기 시큐리티 코어의 제2 펌웨어의 인테그리티 체크와 병렬 적으로 수행될 수 있다. 또한, 상기 제1 펌웨어의 구동 시간과 상기 제2 펌웨어의 인테그리티 체크 시간은 서로 오버랩될 수 있다. 또한, 상기 제1 및 제2 펌웨어 중 적어도 하나가 변조된 경우, 상기 시큐리티 코어가 상기 메인 코어의 동작을 중지시킬 수 있다. 또한, 상기 시큐리티 코어는, 상기 메인 코어의 동작을 중지시킨 후 상기 제1 휘발성 메모리의 데이터를 모두 초기화할 수 있다. 또한, 상기 시큐리티 코어는, 상기 제1 및 제2 펌웨어가 변조된 경우 상기 제1 및 제2 펌웨어를 교체하는 리커 버리 모드를 실행시키고, 상기 메인 코어는 상기 리커버리 모드 동안 동작이 제한될 수 있다. 또한, 상기 시큐리티 코어는, 상기 제1 및 제2 펌웨어가 정상화되면, 상기 리커버리 모드를 종료하고, 상기 메 인 코어의 동작을 재개시킬 수 있다. 상기 다른 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 또한, 상기 메인 코어가 태스크 디스크립터를 전달하여 태스크를 수행시키는 적어도 하나의 뉴럴 프로세서와, 상기 적어도 하나의 뉴럴 코어가 공유하는 공유 메모리를 더 포함할 수 있다. 상기 다른 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 프로세싱 장치의 시큐어 부팅 방법은 시큐리티 코어가 루트 오브 트러스트를 구동하고, 상기 시큐리티 코어가 제1 펌웨어의 인테그리티 체크를 수행하고, 메인 코어가 상기 인테그리티 체크가 수행된 제1 펌웨어를 구동하고, 상기 제1 펌웨어가 구동되면서, 상기 시큐리티 코어가 제2 펌웨어의 인테그리티 체크를 수행하고, 상기 메인 코어가 상기 인테그리티 체크가 수행된 제2 펌웨 어를 구동하는 것을 포함한다. 또한, 상기 제1 펌웨어를 구동하는 것은, 상기 메인 코어의 메인 코어 도메인에서 휘발성 메모리에 상기 제1 펌 웨어를 로드하고, 상기 메인 코어가 상기 제1 펌웨어를 구동하는 것을 포함할 수 있다. 또한, 상기 시큐리티 코어가 루트 오브 트러스트를 구동하는 것은, 변조가 불가능한 이뮤터블 메모리에서 상기 루트 오브 트러스트를 구동하는 것을 포함할 수 있다. 또한, 상기 시큐리티 코어가 제1 펌웨어의 인테그리티 체크를 수행하는 것은, 제1 펌웨어의 암호화 코드를 퍼블 릭 키로 복호화하여 제1 펌웨어의 해시 값을 도출하고, 상기 제1 펌웨어의 해시 값은 상기 퍼블릭 키와 비대칭 대응되는 프라이빗 키로 암호화된 상태이고, 상기 복호화된 해시 값을 통해서 상기 제1 펌웨어의 무결성을 체크 하는 것을 포함할 수 있다."}
{"patent_id": "10-2023-0087977", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 프로세싱 장치 및 그의 시큐어 부팅 방법은, 시큐리티 코어가 단순히 루트 오브 트러스트의 구동뿐만 아니라 다른 펌웨어의 인테그리티 체크도 수행한다는 점에서, 기존의 메인 코어의 작업을 분산하여 전체 장치의 효율성을 높일 수 있다. 또한, 시큐어 코어가 펌웨어의 변조를 확인하는 경우 휘발성 메모리의 데이터를 초기화하여 보안 효과를 극대화 할 수 있다. 상술한 내용과 더불어 본 발명의 구체적인 효과는 이하"}
{"patent_id": "10-2023-0087977", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 명세서 및 특허청구범위에서 사용된 용어나 단어는 일반적이거나 사전적인 의미로 한정하여 해석되어서는 아 니된다. 발명자가 그 자신의 발명을 최선의 방법으로 설명하기 위해 용어나 단어의 개념을 정의할 수 있다는 원 칙에 따라, 본 발명의 기술적 사상과 부합하는 의미와 개념으로 해석되어야 한다. 또한, 본 명세서에 기재된 실 시예와 도면에 도시된 구성은 본 발명이 실현되는 하나의 실시예에 불과하고, 본 발명의 기술적 사상을 전부 대 변하는 것이 아니므로, 본 출원시점에 있어서 이들을 대체할 수 있는 다양한 균등물과 변형 및 응용 가능한 예 들이 있을 수 있음을 이해하여야 한다. 본 명세서 및 특허청구범위에서 사용된 제1, 제2, A, B 등의 용어는 다양한 구성요소들을 설명하는데 사용될 수 있지만, 상기 구성요소들은 상기 용어들에 의해 한정되어서는 안 된다. 상기 용어들은 하나의 구성요소를 다른 구성요소로부터 구별하는 목적으로만 사용된다. 예를 들어, 본 발명의 권리 범위를 벗어나지 않으면서 제1 구성 요소는 제2 구성요소로 명명될 수 있고, 유사하게 제2 구성요소도 제1 구성요소로 명명될 수 있다. '및/또는' 이라는 용어는 복수의 관련된 기재된 항목들의 조합 또는 복수의 관련된 기재된 항목들 중의 어느 항목을 포함 한다. 본 명세서 및 특허청구범위에서 사용된 용어는 단지 특정한 실시 예를 설명하기 위해 사용된 것으로, 본 발명을 한정하려는 의도가 아니다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다.본 출원에서 \"포함하다\" 또는 \"가지다\" 등의 용어는 명세서상에 기재된 특징, 숫자, 단계, 동작, 구성요소, 부 품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 본 발명이 속하는 기술 분야에서 통상의 지식을 가진 자에 의해서 일반적으로 이해되는 것과 동일한 의미를 가지고 있다. 일반적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의 미를 가지는 것으로 해석되어야 하며, 본 출원에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적 인 의미로 해석되지 않는다. 또한, 본 발명의 각 실시예에 포함된 각 구성, 과정, 공정 또는 방법 등은 기술적으로 상호 간 모순되지 않는 범위 내에서 공유될 수 있다. 이하, 도 1 내지 도 6을 참조하여, 본 발명의 몇몇 실시예들에 따른 프로세싱 장치를 설명한다. 도 1은 본 발명의 몇몇 실시예들에 따른 프로세싱 시스템을 설명하기 위한 블록도이다. 도 1을 참조하면, 본 발명의 몇몇 실시예들에 따른 프로세싱 시스템은 프로세싱 장치(PD), 비휘발성 메모리 (NVM), 제1 휘발성 메모리(VM1), 비휘발성 메모리 인터페이스(NVIF) 및 휘발성 메모리 인터페이스(VIF)를 포함 한다. 프로세싱 장치(PD)는 연산 작업을 수행하는 장치일 수 있다. 프로세싱 장치(PD)는 비휘발성 메모리(NVM)에 저장 된 데이터와 소프트웨어를 이용하여 연산 작업을 수행할 수 있다. 프로세싱 장치(PD)는 또한, 제1 휘발성 메모 리(VM1)에 데이터와 소프트웨어를 로드하여 연산 작업을 수행할 수 있다. 프로세싱 장치(PD)는 연산 작업을 수행하기 전에 부팅(booting)이 될 수 있다. 프로세싱 장치(PD)의 부팅은 적 어도 하나의 펌웨어를 통해서 진행될 수 있다. 프로세싱 장치(PD)는 부팅 작업이 완료된 후에 연산 작업을 수행 할 수 있다. 프로세싱 장치(PD)는 메인 코어(MC) 및 시큐리티 코어(SC)를 포함할 수 있다. 메인 코어(MC)는 프로세싱 장치 (PD)의 연산 작업을 수행하는 코어(core)일 수 있다. 또는, 메인 코어(MC)는 연산 작업을 수행하는 코어를 관리 하거나 작업을 분배하는 코어일 수도 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 시큐리티 코어(SC)는 프로세싱 장치(PD)의 시큐어(secure) 부팅을 수행할 수 있다. 시큐어 부팅은 보안이 유지 된 부팅을 의미하고, 변조 위험이 없는 루트 오브 트러스트(Root of trust)에 대한 로드와 구동을 통한 부팅을 의미할 수 있다. 시큐어 부팅의 절차에서, 시큐리티 코어(SC)는 해시 알고리즘(hash algorithm)을 통해서 무결 성을 확인할 수 있다. 구체적으로, 시큐리티 코어(SC)는 시큐리티 코어(SC)가 관리하는 암호화 키인 프라이빗 키(key)를 사용하여 비 휘발성 메모리(NVM)에 저장될 데이터에 대한 해시 값(hash value)의 암호화 코드를 생성할 수 있다. 이후, 시큐 리티 코어(SC)는 비휘발성 메모리(NVM)에 데이터와 암호화 코드를 같이 저장한다. 시큐어 부팅이 시작되면 시큐리티 코어(SC)는 암호화 키 중 프라이빗 키와 비대칭 대응되는 퍼블릭 키를 통해서 암호화 코드를 복호화하여 해시 값을 재생성할 수 있다. 또한, 시큐리티 코어(SC)는 데이터에 대한 해시 값을 재생성하고 이미 비휘발성 메모리(NVM)에 저장된 해시 값과 비교하여 데이터의 변조 여부를 판단한다. 시큐어 부팅을 통해서 펌웨어의 무결성이 확인되면 해당 펌웨어는 안전하다고 판단하고 메인 메모리 즉, 제1 휘발성 메 모리(VM1)로 이동되며 이후 메인 코어(MC)에 의해서 해당 펌웨어가 구동된다. 비휘발성 메모리(NVM)는 프로세싱 장치(PD)의 부팅을 위한 펌웨어들을 저장할 수 있다. 비휘발성 메모리(NVM)는 전원이 없어도 내부의 데이터가 유지되는 특성을 가지고 있어, 데이터 및 펌웨어와 같은 소프트웨어의 저장에 사용될 수 있다. 비휘발성 메모리(NVM)는 도 1에서 프로세싱 장치(PD)의 외부에 위치한 것으로 도시되어 있지만, 본 실시예가 이에 제한되는 것은 아니다. 즉, 비휘발성 메모리(NVM)는 프로세싱 장치(PD)의 내부에 결 합될 수도 있다. 비휘발성 메모리(NVM)는 비휘발성 메모리 인터페이스(NVIF)를 통해서 프로세싱 장치(PD)와 데 이터를 교환할 수 있다. 휘발성 메모리(VM)는 프로세싱 장치(PD)의 부팅을 위한 펌웨어들을 로드할 수 있다. 휘발성 메모리(VM)는 전원 이 없으면 내부의 데이터가 휘발되는 특성을 가지고 있어, 메인 코어(MC) 및 시큐리티 코어(SC)가 동작할 때에데이터 및 소프트웨어를 사용하기 위한 메모리일 수 있다. 휘발성 메모리(VM)는 비휘발성 메모리 인터페이스 (NVIF)를 통해서 프로세싱 장치(PD)와 데이터를 교환할 수 있다. 도 2a는 도 1의 프로세싱 장치의 세부적인 구조를 설명하기 위한 블록도이다. 도 2a를 참조하면, 프로세싱 장치(PD)는 메인 코어(MC)와 시큐리티 코어(SC) 외에 제2 휘발성 메모리(VM2), 이 뮤터블 메모리(IM), 메인 시큐리티 인터커넥션(MS) 및 시큐리티 메인 인터커넥션(SM)를 포함할 수 있다. 제2 휘발성 메모리(VM2)는 메인 코어(MC)의 도메인 즉, 메인 코어 도메인에 속하는 휘발성 메모리일 수 있다. 이때, 메인 코어(MC)는 도 1의 제1 휘발성 메모리(VM1) 또는 제2 휘발성 메모리(VM2)에 펌웨어를 로드하여 작업 을 수행할 수 있다. 제1 휘발성 메모리(VM1) 및 제2 휘발성 메모리(VM2)는 서로 분리된 것으로 도시하였으나, 본 실시예가 이에 제 한되는 것은 아니다. 제1 휘발성 메모리(VM1) 및 제2 휘발성 메모리(VM2)는 분리되지 않고 하나의 메모리 장치 로 존재할 수도 있다. 제2 휘발성 메모리(VM2)는 시큐리티 코어(SC)와도 연결될 수 있다. 제2 휘발성 메모리(VM2)는 시큐리티 코어 (SC)가 펌웨어의 무결성 체크 즉, 인테그리티 체크를 수행한 뒤 그 펌웨어를 시큐리티 코어(SC)로부터 수신할 수 있다. 이에 따라서, 메인 코어(MC)가 무결성이 체크된 펌웨어를 구동할 수 있다. 이뮤터블 메모리(IM)는 변조가 불가능한 데이터 및 소프트웨어를 저장하는 메모리일 수 있다. 이에 따라서, 이 뮤터블 메모리(IM)에서 펌웨어를 구동시키는 경우 그 무결성은 보장될 수 있다. 이때, 무결성이란 처음 저장된 내용 그대로 변조가 없다는 특성을 의미할 수 있다. 이뮤터블 메모리(IM)는 루트 오브 트러스트와 같이 변조가 불가능한 소프트웨어를 저장할 수 있다. 시큐리티 코 어(SC)는 이뮤터블 메모리(IM)에서 변조가 불가능한 소프트웨어를 로드하여 보안이 강화된 시큐어 부팅을 수행 할 수 있다. 또한, 시큐어 부팅을 위한 보안키 중 프라이빗 키와 같은 데이터도 이뮤터블 메모리(IM)에 저장될 수 있다. 이때, 이뮤터블 메모리(IM)는 변조가 불가능한 ROM(Read Only Memory) 또는 OTP(One Time Programmable) 메모리 중 어느 하나일 수 있다. 메인 시큐리티 인터커넥션(MS)은 메인 코어(MC)와 시큐리티 코어(SC) 사이의 데이터 및 제어 신호를 전달할 수 있다. 이때, 메인 코어(MC)는 메인 시큐리티 인터커넥션(MS)을 통해서 시큐리티 코어(SC)의 전체가 아닌 제한된 부분만을 접근할 수 있다. 이를 통해서, 보안을 담당하는 시큐리티 코어(SC)에 대한 보안을 유지하고, 프로세싱 장치(PD)의 변조 위험을 방지할 수 있다. 반대로, 시큐리티 메인 인터커넥션(SM)은 시큐리티 코어(SC)와 메인 코어(MC) 사이의 데이터 및 제어 신호를 전 달할 수 있다. 이때, 시큐리티 코어(SC)는 메인 코어(MC)보다 보안 등급이 높을 수 있다. 이에 따라서, 시큐리 티 코어(SC)는 메인 코어(MC)의 모든 부분에 접근할 수 있고, 메인 코어(MC)의 동작 여부도 지시할 수 있다. 이 를 통해서, 보안이 문제될 때, 시큐리티 코어(SC)가 메인 코어(MC)의 동작을 멈추고 메인 코어(MC)의 작업을 대 신 수행할 수도 있다. 이에 따라서, 변조 위험이 있을 때의 리커버리를 시큐리티 코어(SC)가 원활하게 수행할 수 있다. 도 2b는 도 1의 프로세싱 장치의 세부적인 구조를 설명하기 위한 블록도이다. 도 2b를 참조하면, 본 실시예의 프로세싱 장치(PD)는 제3 휘발성 메모리(VM3)를 더 포함할 수 있다. 제3 휘발성 메모리(VM3)는 시큐리티 코어(SC)의 도메인 즉, 시큐리티 코어 도메인에 속하는 휘발성 메모리일 수 있다. 이때, 시큐리티 코어(SC)는 도 1의 제1 휘발성 메모리(VM1) 또는 제3 휘발성 메모리(VM3)에 펌웨어를 로드하여 작업을 수행할 수 있다. 제2 휘발성 메모리(VM2) 및 제3 휘발성 메모리(VM3)는 도 2b에서와 같이 별도로 분리된 휘발성 메모리일 수 있 다. 단, 본 실시예가 이에 제한되는 것은 아니다. 제2 휘발성 메모리(VM2) 및 제3 휘발성 메모리(VM3)는 동일한 메모리 내에서 구역이 분리되어 각각 메인 코어 도메인과 시큐리티 코어 도메인에 해당될 수도 있다. 시큐리티 코어(SC)는 제3 휘발성 메모리(VM3)에 펌웨어를 로드해서 구동할 수도 있다. 도 3은 도 2의 시큐리티 코어의 세부적인 구조를 설명하기 위한 블록도이다. 도 2a 및 도 3을 참조하면, 시큐리티 코어(SC)는 크립토 액셀러레이터(CA), 메인-시큐리티 인터페이스(IF1), 시 큐리티-메인 인터페이스(IF2) 및 이뮤터블 메모리 인터페이스(IF3)를 포함할 수 있다.크립토 액셀러레이터(CA)는 크립토(crypto) 연산을 수행할 수 있다. 크립토 연산은 예를 들어, AES(Advanced Encryption Standard) 알고리즘, Hash 알고리즘, 퍼블릭/프라이빗(Public/private) 키 알고리즘, 참난수 생성 기(True Random Number Generator) 연산 중 적어도 하나를 포함할 수 있다. 크립토 액셀러레이터(CA)는 시큐리티 코어(SC)가 크립토 연산을 원활하게 할 수 있게 크립토 연산에 특화된 하 드웨어일 수 있다. 이를 통해서, 시큐리티 코어(SC)는 시큐어 부팅을 수행할 때, 더욱 빠르고 더욱 정확하게 크 립토 연산을 수행할 수 있다. 메인-시큐리티 인터페이스(IF1)는 메인 시큐리티 인터커넥션(MS)과 연결될 수 있다. 메인-시큐리티 인터페이스 (IF1)는 메인 시큐리티 인터커넥션(MS)과 함께 메인 코어(MC)가 시큐리티 코어(SC)에 접근할 때 보안 영역이 아 닌 영역만을 제한적으로 접근할 수 있도록 제어할 수 있다. 시큐리티-메인 인터페이스(IF2)는 시큐리티 메인 인터커넥션(SM)과 연결될 수 있다. 시큐리티-메인 인터페이스 (IF2)는 시큐리티 메인 인터커넥션(SM)과 함께 시큐리티 코어(SC)가 메인 코어(MC)에 접근할 때 사용할 수 있다. 이때, 메인 코어(MC)가 시큐리티 코어(SC)에 접근할 수 있는 영역은 시큐리티 코어(SC)가 메인 코어(MC) 에 접근할 수 있는 영역보다 작을 수 있다. 이러한 비대칭성을 통해서, 본 실시예는 시큐리티 코어(SC)의 보안 을 강화하여 전체적인 변조 위험성에 대비할 수 있다. 이뮤터블 메모리 인터페이스(IF3)는 시큐리티 코어(SC)가 이뮤터블 메모리(IM)에 접근하는 것을 제어할 수 있다. 이뮤터블 메모리(IM)는 시큐리티 코어(SC)만 접근할 수 있는 변조 불가능한 영역이므로, 시큐리티 코어 (SC)에는 이를 위한 인터페이스가 별도로 존재할 수 있다. 메인-시큐리티 인터페이스(IF1), 시큐리티-메인 인터페이스(IF2) 및 이뮤터블 메모리 인터페이스(IF3)는 서로 물리적으로 분리될 수 있다. 메인-시큐리티 인터페이스(IF1) 및 시큐리티-메인 인터페이스(IF2)는 메인 코어 (MC) 및 시큐리티 코어(SC) 사이에서 동작할 수 있다. 메인-시큐리티 인터페이스(IF1) 및 시큐리티-메인 인터페 이스(IF2)는 메인 코어(MC) 및 시큐리티 코어(SC)가 접근 가능할 수 있다. 이에 반해서, 이뮤터블 메모리 인터페이스(IF3)는 시큐리티 코어(SC)만이 접근 가능하고, 메인 코어(MC)에서는 접근이 불가능할 수 있다. 이에 따라서, 메인 코어(MC)는 이뮤터블 메모리(IM)에 접근할 수 없어 이뮤터블 메모 리(IM)에 저장된 데이터 및 소프트웨어의 변조 가능성이 차단될 수 있다. 도 4는 본 발명의 시큐리티 코어 도메인과 메인 코어 도메인에서 펌웨어의 인테그리티 체크를 수행하는 방식을 설명하기 위한 블록도이다. 도 1, 도 2 및 도 4를 참조하면, 시큐리티 코어 도메인(D_sc)은 시큐리티 코어(SC)가 동작하는 소프트웨어 상의 영역을 의미할 수 있다. 마찬가지로, 메인 코어 도메인(D_mc)은 메인 코어(MC)가 동작하는 소프트웨어 상의 영 역을 의미할 수 있다. 루트 오브 트러스트(RoT)는 이뮤터블 메모리(IM)에 저장된 소프트웨어일 수 있다. 루트 오브 트러스트(RoT)는 변조가 불가능할 수 있다. 이에 따라서, 루트 오브 트러스트(RoT)는 전체 부팅 절차에서 최초로 구동되어 다른 펌웨어들의 무결성 체크 즉, 인테그리티 체크(Integrity Check)를 수행할 수 있다. 루트 오브 트러스트(RoT)는 시큐리티 코어 도메인(D_sc)으로 로드(load)될 수 있다. 구체적으로, 시큐리티 코어 (SC)가 제3 휘발성 메모리(VM3)에 루트 오브 트러스트(RoT)를 로드하여 구동시킬 수 있다. 시큐리티 코어(SC)는 시큐리티 코어 도메인(D_sc)에서 루트 오브 트러스트(RoT)를 통해서 펌웨어들의 무결성을 체크할 수 있다. 비휘발성 메모리(NVM)는 여러 펌웨어들을 저장할 수 있다. 예를 들어, 제1 펌웨어(FW1), 제2 펌웨어(FW2) 및 제3 펌웨어(FW3)가 비휘발성 메모리(NVM)에 저장될 수 있다. 도 4에서는 3개의 펌웨어가 저장된 것으로 도시되었지만, 본 실시예가 이에 제한되는 것은 아니다. 즉, 비휘발성 메모리(NVM)에 저장된 펌웨어의 개수는 2개 이하 또는 4개 이상일 수도 있다. 루트 오브 트러스트(RoT)는 제1 펌웨어(FW1)의 무결성을 체크할 수 있다. 이어서, 제1 펌웨어(FW1)가 제2 펌웨 어(FW2)의 무결성을 체크하고, 제2 펌웨어(FW2)가 제3 펌웨어(FW3)의 무결성을 체크할 수 있다. 또는, 루트 오브 트러스트(RoT)는 제1 펌웨어(FW1), 제2 펌웨어(FW2) 및 제3 펌웨어(FW3)의 무결성을 순차적으 로 체크할 수 있다. 메인 코어(MC)는 무결성이 체크된 펌웨어를 메인 코어 도메인(D_mc)으로 로드할 수 있다. 메인 코어 도메인(D_mc)의 휘발성 메모리(VM)는 제1 휘발성 메모리(VM1) 및 제3 휘발성 메모리(VM3) 중 적어도 하나를 포함할 수 있다. 메인 코어 도메인(D_mc)은 루트 오브 트러스트(RoT)가 무결성을 체크한 제1 펌웨어(FW1)를 로드하여 동작시킬 수 있다. 이어서, 루트 오브 트러스트(RoT)가 제2 펌웨어(FW2)의 무결성을 체크한 후에 제2 펌웨어(FW2)를 로드하여 동작시킬 수 있다. 추후, 제3 펌웨어(FW3)도 동일하게 루트 오브 트러스트 (RoT)에 의해서 무결성 체크 후에 동작시킬 수 있다. 도 5는 본 발명의 체인 오브 트러스트를 설명하기 위한 블록도이고, 도 6은 본 발명의 메인 코어와 시큐리티 코 어의 동작을 설명하기 위한 도면이다. 도 5 및 도 6을 참조하면, 시큐어 부팅은 체인 오브 트러스트(Chain of Trust)를 통해서 무결성을 이어나갈 수 있다. 즉, 루트 오브 트러스트(RoT)가 제1 펌웨어(FW1)의 인테그리티 체크를 수행하고, 제1 펌웨어(FW1)가 이어 서 제2 펌웨어(FW2)의 인테그리티 체크를 수행할 수 있다. 나아가, 제2 펌웨어(FW2)는 제3 펌웨어(FW3)의 인테 그리티 체크를 수행할 수 있다. 이때, 루트 오브 트러스트(RoT)는 변조가 불가능한 이뮤터블(Immutable)한 소프트웨어일 수 있다. 이에 반해서, 제1 펌웨어(FW1), 제2 펌웨어(FW2) 및 제3 펌웨어(FW3)는 모두 변조가 가능한 뮤터블(Mutable)한 소프트웨어일 수 있다. 시큐리티 코어(SC)는 루트 오브 트러스트(RoT)를 구동(Operation)시킬 수 있다. 시큐리티 코어(SC)가 구동시킨 루트 오브 트러스트(RoT)는 제1 펌웨어(FW1)의 인테그리티 체크를 수행할 수 있다. 이어서, 메인 코어(MC)가 무 결성이 체크된 제1 펌웨어(FW1)를 구동시킬 수 있다. 이어서, 구동된 제1 펌웨어(FW1)가 제2 펌웨어(FW2)의 인테그리티 체크를 수행할 수 있다. 이때, 메인 코어(M C)에 의해서 인테그리티 체크가 수행될 수 있다. 이와 반대로, 시큐리티 코어(SC)가 루트 오브 트러스트(RoT)를 통해서 제2 펌웨어(FW2)의 인테그리티 체크를 수행할 수도 있다. 이어서, 메인 코어(MC)가 무결성이 체크된 제2 펌웨어(FW2)를 구동시킬 수 있다. 이어서, 구동된 제2 펌웨어(FW2)가 제3 펌웨어(FW3)의 인테그리티 체크를 수행할 수 있다. 이때, 메인 코어(M C)에 의해서 인테그리티 체크가 수행될 수 있다. 이와 반대로, 시큐리티 코어(SC)가 루트 오브 트러스트(RoT)를 통해서 제3 펌웨어(FW3)의 인테그리티 체크를 수행할 수도 있다. 이어서, 메인 코어(MC)가 무결성이 체크된 제3 펌웨어(FW3)를 구동시킬 수 있다. 본 실시예는, 시큐리티 코어(SC)가 루트 오브 트러스트(RoT)를 이용하여 무결성을 보장받고, 이어서 연쇄적으로 다른 펌웨어들이 무결성을 검증받으므로, 보안을 유지한 채로 부팅이 가능할 수 있다. 또한, 만일 시큐리티 코어(SC)가 모든 펌웨어의 무결성을 체크하는 경우, 메인 코어(MC) 동작과 시큐리티 코어 (SC)의 동작이 병렬적으로 실행되면서 부팅의 효율성 및 속도가 극대화될 수 있다. 즉, 도 6에서 제1 펌웨어 (FW1)의 동작 시간과 제2 펌웨어(FW2)의 인테그리티 체크 시간은 서로 오버랩되어 병렬적으로 진행되어 직렬적 으로 진행될 때의 시간 소모를 제거할 수 있다. 이에 따라, 본 발명의 몇몇 실시예들에 따른 프로세싱 장치(P D)는 효율적으로 보안이 유지된 부팅을 수행할 수 있다. 시큐리티 코어(SC)는 만일 인테그리티 체크에서 펌웨어의 변조가 발생되는 경우 메인 코어(MC)의 동작을 중지시 킬 수 있다. 이어서, 휘발성 메모리(VM)의 데이터를 모두 초기화할 수 있다. 예를 들면, 초기화는 데이터를 모 두 0으로 쓰는 것을 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 이어서, 시큐리티 코어(SC)는 변조된 펌웨어 예를 들어 제1 펌웨어(FW1)의 변조를 바로잡는 즉, 변조된 제1 펌 웨어(FW1)를 정상인 제1 펌웨어(FW1)로 교체하는 리커버리 모드를 실행시킬 수 있다. 이때, 메인 코어(MC)는 리 커버리 모드 중에는 동작이 제한될 수 있다. 이를 통해서, 본 실시예는 보안의 회복 동작을 하는 중에 추가적인 변조 위험을 최소화할 수 있다. 위 설명에서는 제1 펌웨어(FW1)가 변조된 경우를 예를 들어 설명하였지만, 이러 한 리커버리 모드의 동작은 제2 펌웨어(FW2)와 같은 다른 펌웨어에서도 동일하게 수행될 수 있다. 이어서, 시큐리티 코어(SC)는 변조된 펌웨어가 정상화되면 상기 리커버리 모드를 종료할 수 있다. 이에 따라서, 메인 코어(MC)는 동작을 재개할 수 있다. 이와 같이 시큐리티 코어(SC)는 보안의 위험이 있는 경우 메인 코어 (MC)의 동작마저 제한하여 보안의 회복 절차에 있어서의 보안도 유지할 수 있다. 이하, 도 7 내지 도 16을 참조하여, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치를 설명한다. 상술한 실시예와 중복되는 부분은 간략히 한다. 도 7은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템을 설명하기 위한 블록도이다. 도 7을 참조하면, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템(NPS)은 제1 뉴럴 프로세싱 장치, 제2 뉴럴 프로세싱 장치 및 외부 인터페이스를 포함할 수 있다. 제1 뉴럴 프로세싱 장치는 인공 신경망을 이용하여 연산을 수행하는 장치일 수 있다. 제1 뉴럴 프로세싱 장 치는 예를 들어, 딥 러닝(deep learning) 연산 작업을 수행하는 것에 특화된 장치일 수 있다. 단, 본 실시예 가 이에 제한되는 것은 아니다. 제2 뉴럴 프로세싱 장치는 제1 뉴럴 프로세싱 장치와 동일 내지 유사한 구성을 가지는 장치일 수 있다. 제1 뉴럴 프로세싱 장치 및 제2 뉴럴 프로세싱 장치는 서로 외부 인터페이스를 통해서 연결되어 데이 터 및 제어 신호를 공유할 수 있다. 도 1에서는 2개의 뉴럴 프로세싱 장치를 도시하였지만, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템 (NPS)이 이에 제한되는 것은 아니다. 즉, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템(NPS)은 3개 이 상의 뉴럴 프로세싱 장치가 외부 인터페이스를 통해서 서로 연결될 수도 있다. 또한, 반대로, 본 발명의 몇 몇 실시예들에 따른 뉴럴 프로세싱 시스템(NPS)은 하나의 뉴럴 프로세싱 장치만을 포함할 수도 있다. 이때, 제1 뉴럴 프로세싱 장치 및 제2 뉴럴 프로세싱 장치는 각각 뉴럴 프로세싱 장치가 아닌 다른 프로 세싱 장치일 수도 있다. 즉, 제1 뉴럴 프로세싱 장치 및 제2 뉴럴 프로세싱 장치는 각각 그래픽 프로세싱 장치(GPU, graphics processing unit), 중앙 처리 장치(CPU, central processing unit) 및 그 외의 다른 종류 의 프로세싱 장치일 수도 있다. 이하에서는 편의상 제1 뉴럴 프로세싱 장치 및 제2 뉴럴 프로세싱 장치가 뉴럴 프로세싱 장치인 것으로 설명한다. 도 8은 도 7의 뉴럴 프로세싱 장치를 세부적으로 설명하기 위한 블록도이다. 도 8을 참조하면, 제1 뉴럴 프로세싱 장치는 뉴럴 코어 SoC, CPU, 오프 칩 메모리, 제1 비휘발 성 메모리 인터페이스, 제1 휘발성 메모리 인터페이스, 제2 비휘발성 메모리 인터페이스, 제2 휘발 성 메모리 인터페이스 및 컨트롤 인터페이스(CIF)를 포함할 수 있다. 뉴럴 코어 SoC는 시스템 온 칩(System on Chip) 장치일 수 있다. 뉴럴 코어 SoC는 인공지능 연산 유닛 으로 가속기(Accelerator)일 수 있다. 뉴럴 코어 SoC는 예를 들어, GPU(graphics processing unit), FPGA(field programmable gate array) 및 ASIC(application-specific integrated circuit) 중 어느 하나일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 뉴럴 코어 SoC는 외부 인터페이스를 통해서 다른 외부의 연산 유닛들과 데이터를 교환할 수 있다. 또한, 뉴럴 코어 SoC는 제1 비휘발성 메모리 인터페이스 및 제1 휘발성 메모리 인터페이스를 통해서 각각 비휘발성 메모리 및 휘발성 메모리와 연결될 수 있다. CPU는 제1 뉴럴 프로세싱 장치의 시스템을 통제하고 프로그램의 연산을 실행하는 제어장치일 수 있다. CPU는 범용 연산 유닛으로서 딥러닝에 많이 사용되는 병렬 단순 연산을 수행하기에는 효율이 낮을 수 있다. 따라서, 뉴럴 코어 SoC가 딥러닝 추론 및 학습 작업에 연산을 수행하여 높은 효율을 가질 수 있다. CPU는 외부 인터페이스를 통해서 다른 외부의 연산 유닛들과 데이터를 교환할 수 있다. 또한, CPU는 제2 비휘발성 메모리 인터페이스 및 제2 휘발성 메모리 인터페이스를 통해서 각각 비휘발성 메모리 및 휘발성 메모리와 연결될 수 있다. CPU는 또한, 커맨드를 통해서 뉴럴 코어 SoC에 태스크를 전달할 수 있다. 이때, CPU는 뉴럴 코어 SoC에 지시를 주는 일종의 호스트(Host)일 수 있다. 즉, 뉴럴 코어 SoC는 CPU의 지시에 따라서 딥 러닝 작업 등 병렬 연산 작업을 효율적으로 수행할 수 있다. 오프 칩 메모리는 뉴럴 코어 SoC의 칩 외부에 배치된 메모리일 수 있다. 오프 칩 메모리는 비휘발 성 메모리 및 휘발성 메모리를 포함할 수 있다. 비휘발성 메모리는 전원이 공급되지 않아도 저장된 정보를 계속 유지하는 메모리일 수 있다. 비휘발성 메모 리는 예를 들어, ROM(Read-Only Memory), PROM(Programmable Read-Only Memory), EAROM(Erasable Alterable ROM), EPROM(Erasable Programmable Read-Only Memory), EEPROM(Electrically Erasable Programmable Read-Only Memory)(예를 들어, 낸드 플래시 메모리(NAND Flash memory), 노어 플래시 메모리(NOR Flash memory)), UVEPROM(Ultra-Violet Erasable Programmable Read-Only Memory), FeRAM(Ferroelectric Random Access Memory), MRAM(Magnetoresistive Random Access Memory), PRAM(Phase-change Random Access Memory), SONOS(silicon-oxide-nitride-oxide-silicon), RRAM(Resistive Random Access Memory),NRAM(Nanotube Random Access Memory), 마그네틱 컴퓨터 기억 장치(예를 들면, 하드 디스크, 디스켓 드라이브, 마그네틱 테이프), 광디스크 드라이브 및 3D 크로스포인트 메모리(3D XPoint memory) 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 휘발성 메모리는 비휘발성 메모리와 달리, 저장된 정보를 유지하기 위해서 전력을 지속적으로 필요로 하는 메모리일 수 있다. 휘발성 메모리는 예를 들어, DRAM(Dynamic Random Access Memory), SRAM(Static Random Access Memory), SDRAM(Synchronous Dynamic Random Access Memory) 및 DDR SDRAM(Double Data Rate SDRAM) 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 제1 비휘발성 메모리 인터페이스 및 제2 비휘발성 메모리 인터페이스는 각각 예를 들어, PATA(Parallel Advanced Technology Attachment), SCSI(Small Computer System Interface), SAS(Serial Attached SCSI), SATA(Serial Advanced Technology Attachment) 및 PCIe(PCI Express) 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 제1 휘발성 메모리 인터페이스 및 제2 휘발성 메모리 인터페이스는 각각 예를 들어, SDR(Single Data Rate), DDR(Double Data Rate), QDR(Quad Data Rate), 및 XDR(eXtreme Data Rate, Octal Data Rate) 중 적어 도 하나일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 컨트롤 인터페이스는 CPU와 뉴럴 코어 SoC 사이의 제어 신호를 전달하기 위한 인터페이스일 수 있 다. 컨트롤 인터페이스는 CPU의 커맨드를 전송하고, 이에 대한 뉴럴 코어 SoC의 응답을 전송할 수 있다. 컨트롤 인터페이스는 예를 들어, PCIe(PCI Express)일 수 있으나, 이에 제한되는 것은 아니다. 도 9는 도 8의 뉴럴 코어 SoC를 세부적으로 설명하기 위한 블록도이다. 도 8 및 도 9를 참조하면, 뉴럴 코어 SoC는 적어도 하나의 뉴럴 프로세서, 공유 메모리, DMA(Direct Memory Access), 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤러, 메인 코 어, 시큐리티 코어, 이뮤터블 메모리 및 글로벌 인터커넥션을 포함할 수 있다. 뉴럴 프로세서는 연산 작업을 직접 수행하는 연산 유닛일 수 있다. 뉴럴 프로세서가 복수인 경우 연산 작업은 각각의 뉴럴 프로세서로 할당될 수 있다. 각각의 뉴럴 프로세서는 글로벌 인터커넥션 을 통해서 서로 연결될 수 있다. 공유 메모리는 여러 뉴럴 프로세서에 의해서 공유되는 메모리일 수 있다. 공유 메모리는 각 각의 뉴럴 프로세서의 데이터를 저장할 수 있다. 또한, 공유 메모리는 오프 칩 메모리로부터 데이터를 수신하여 일시적으로 저장하고 각각의 뉴럴 프로세서로 전달할 수 있다. 반대로, 공유 메모리 는 뉴럴 프로세서로부터 데이터를 수신하여 일시적으로 저장하고 도 8의 오프 칩 메모리로 전 달할 수도 있다. 공유 메모리는 상대적으로 속도가 빠른 메모리가 필요할 수 있다. 이에 따라서, 공유 메모리는 예 를 들어, SRAM을 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 즉, 공유 메모리는 DRAM 을 포함할 수도 있다. 공유 메모리는 SoC 레벨 즉, L2(level 2)에 해당하는 메모리일 수 있다. 따라서, 공유 메모리는 L2 공유 메모리라 정의할 수도 있다. DMA는 CPU 또는 뉴럴 프로세서가 데이터의 입출력을 제어할 필요없이 직접 데이터의 이동을 제 어할 수 있다. 이에 따라서, DMA가 메모리 사이의 데이터 이동을 제어하여 CPU 또는 뉴럴 프로세서 의 인터럽트의 횟수를 최소화시킬 수 있다. DMA는 공유 메모리와 오프 칩 메모리 사이의 데이터 이동을 제어할 수 있다. DMA의 권한 을 통해서 비휘발성 메모리 컨트롤러 및 휘발성 메모리 컨트롤러가 데이터를 이동을 수행할 수 있 다. 비휘발성 메모리 컨트롤러는 비휘발성 메모리에 리드(read) 또는 라이트(write) 작업을 제어할 수 있 다. 비휘발성 메모리 컨트롤러는 제1 비휘발성 메모리 인터페이스를 통해서 비휘발성 메모리를 제어할 수 있다. 휘발성 메모리 컨트롤러는 휘발성 메모리에 리드 또는 라이트 작업을 제어할 수 있다. 또한, 휘발성 메모리 컨트롤러는 휘발성 메모리의 리프레쉬 작업을 수행할 수 있다. 휘발성 메모리 컨트롤러는 제1 휘발성 메모리 인터페이스를 통해서 휘발성 메모리를 제어할 수 있다. 메인 코어는 컨트롤 인터페이스와 연결될 수 있다. 메인 코어는 컨트롤 인터페이스를 통해 서 CPU로부터 제어 신호를 수신할 수 있다. 메인 코어는 CPU로부터 받은 제어 신호를 통해서 태 스크를 생성하고, 이를 각각의 뉴럴 프로세서로 전달할 수 있다. 또한, 메인 코어는 각각의 뉴럴 프로세서로부터 태스크에 대한 완료 리포트를 수신할 수 있다. 글로벌 인터커넥션은 적어도 하나의 뉴럴 프로세서, 공유 메모리, DMA, 비휘발성 메모 리 컨트롤러, 메인 코어 및 휘발성 메모리 컨트롤러를 서로 연결할 수 있다. 또한, 외부 인 터페이스도 글로벌 인터커넥션에 연결될 수 있다. 글로벌 인터커넥션은 적어도 하나의 뉴럴 프 로세서, 공유 메모리, DMA, 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤러 , 메인 코어 및 외부 인터페이스 사이의 데이터가 이동하는 경로일 수 있다. 글로벌 인터커넥션은 데이터뿐만 아니라 제어 신호 및 동기화를 위한 신호를 전송할 수 있다. 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 각각의 뉴럴 프로세서가 직접 동기화 신호를 전송하고 수신 할 수 있다. 이에 따라서, 메인 코어에 의해서 발생하는 동기화 신호의 전송에 따른 레이턴시를 최소화할 수 있다. 즉, 뉴럴 프로세서가 복수일 때, 어느 뉴럴 프로세서의 작업이 종료되어야 다음 뉴럴 프로세서 가 새로운 작업을 시작할 수 있는 개별 작업의 디펜던시가 존재할 수 있다. 이러한 개별 작업의 종료와 시작은 동기화 신호를 통해서 확인할 수 있는데, 기존의 기술은 이러한 동기화 신호의 수신과 새로운 작업의 시 작 지시는 모두 메인 코어 또는 호스트 즉, CPU가 전담하여 수행하였다. 그러나, 뉴럴 프로세서의 숫자가 늘어나고, 작업의 디펜던시가 복잡하게 설계되면 될수록 이러한 동기화 신호의 수는 기하급수적으로 늘어나서, 각각의 동기화 신호에 따른 레이턴시가 작업의 효율을 크게 낮출 수 있 다. 따라서, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 메인 코어 대신 각각의 뉴럴 프로세서 가 직접 동기화 신호의 일부를 작업의 디펜던시에 따라 다른 뉴럴 프로세서로 전송할 수 있다. 이 경우 메인 코어에 의해서 관리되는 방식에 비해서 병렬적으로 여러 뉴럴 프로세서가 동기화 작업을 수행할 수 있어 동기화에 따른 레이턴시를 최소화할 수 있다. 또한, 메인 코어가 작업 디펜던시에 따른 뉴럴 프로세서들의 작업 스케쥴링을 수행해야 하는데 이 러한 스케쥴링의 오버헤드도 뉴럴 프로세서의 개수가 늘어나면 늘어날수록 크게 늘어날 수 있다. 따라서, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 스케쥴링 작업도 개별 뉴럴 프로세서에 의해서 일 부 진행되어 그에 따른 스케쥴링 부담도 줄어들어 장치의 성능이 향상될 수 있다. 시큐리티 코어는 뉴럴 코어 SoC의 시큐어 부팅을 수행하기 위한 장치이고, 이뮤터블 메모리는 루트 오브 트러스트를 저장하기 위한 변조 불가능한 메모리일 수 있다. 메인 코어, 시큐리티 코어 및 이뮤터블 메모리는 각각 도 1 내지 도 6의 메인 코어(MC), 시큐리티 코어(SC) 및 이뮤터블 메모리(I M)와 동일할 수 있다. 도 10은 도 9의 글로벌 인터커넥션을 세부적으로 설명하기 위한 구조도이다. 도 10을 참조하면, 글로벌 인터커넥션은 데이터 채널, 컨트롤 채널 및 L2 싱크 채널을 포함할 수 있다. 데이터 채널은 데이터를 전송하는 전용 채널일 수 있다. 데이터 채널을 통해서 적어도 하나의 뉴럴 프로세서, 공유 메모리, DMA, 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤러 및 외부 인터페이스가 서로 데이터를 교환할 수 있다. 컨트롤 채널은 제어 신호를 전송하는 전용 채널일 수 있다. 컨트롤 채널을 통해서 적어도 하나의 뉴럴 프로세서, 공유 메모리, DMA, 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤 러, 메인 코어 및 외부 인터페이스가 서로 제어 신호를 교환할 수 있다. 특히, 메인 코어(700 0)는 각각의 뉴럴 프로세서로 여러가지 제어 신호를 전달할 수 있다. L2 싱크 채널은 동기화 신호를 전송하는 전용 채널일 수 있다. L2 싱크 채널을 통해서 적어도 하나 의 뉴럴 프로세서, 공유 메모리, DMA, 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤러, 메인 코어 및 외부 인터페이스가 서로 동기화 신호를 교환할 수 있다. L2 싱크 채널은 글로벌 인터커넥션 내부에 전용 채널로 설정되어 다른 채널과 겹치지 않고 동기화 신호를 빠르게 전송할 수 있다. 이에 따라서, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 새로운 와 이어링 작업이 필요하지 않고 기존에 사용되는 글로벌 인터커넥션을 이용하여 동기화 작업을 원활하게 진 행할 수 있다. 도 11은 도 7의 뉴럴 프로세싱 장치의 제어 신호의 흐름을 설명하기 위한 블록도이다. 도 11을 참조하면, CPU는 컨트롤 인터페이스를 통해서 메인 코어로 제어 신호를 전달할 수 있다. 이때, 제어 신호는 연산 작업이나 데이터 로드/스토어 작업 등 각각의 오퍼레이션을 수행하도록 지시하는 신호 일 수 있다. 메인 코어는 제어 신호를 받아 컨트롤 채널을 통해서 적어도 하나의 뉴럴 프로세서에게 제어 신호를 전달할 수 있다. 각각의 제어 신호는 각각의 태스크로서 뉴럴 프로세서에 저장될 수 있다. 도 12는 도 9의 뉴럴 프로세서를 세부적으로 설명하기 위한 블록도이다. 도 9 내지 도 12를 참조하면, 뉴럴 프로세서는 적어도 하나의 뉴럴 코어, 로컬 인터커넥션, L1 싱크 패스 및 L1 공유 메모리를 포함할 수 있다. 적어도 하나의 뉴럴 코어는 뉴럴 프로세서의 작업을 분담하여 수행할 수 있다. 뉴럴 코어는 예 를 들어, 8개일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 도 3 및 도 5에서는 여러 개의 뉴럴 코 어가 뉴럴 프로세서에 포함되는 것으로 도시하였지만, 본 실시예가 이에 제한되는 것은 아니다. 즉, 뉴럴 코어 1개만으로 뉴럴 프로세서가 구성될 수 있다. L1 공유 메모리는 뉴럴 프로세서 내에서 각각의 뉴럴 코어들이 공유하는 메모리일 수 있다. L1 공유 메모리는 각각의 뉴럴 코어의 데이터를 저장할 수 있다. 또한, L1 공유 메모리는 도 4의 공유 메모리로부터 데이터를 수신하여 일시적으로 저장하고 각각의 뉴럴 코어로 전달할 수 있다. 반 대로, L1 공유 메모리는 뉴럴 코어로부터 데이터를 수신하여 일시적으로 저장하고 도 3의 공유 메모 리로 전달할 수도 있다. L1 공유 메모리는 뉴럴 프로세서 레벨, 즉, L1(level 1)에 해당하는 메모리일 수 있다. L2 공유 메모리 즉, 공유 메모리는 뉴럴 프로세서에 의해서 공유되고, L1 공유 메모리는 뉴럴 코어에 의 해서 공유될 수 있다. 로컬 인터커넥션은 적어도 하나의 뉴럴 코어 및 L1 공유 메모리를 서로 연결할 수 있다. 로컬 인터커넥션은 적어도 하나의 뉴럴 코어 및 L1 공유 메모리 사이의 데이터가 이동하는 경로일 수 있다. 로컬 인터커넥션은 도 3의 글로벌 인터커넥션과 연결되어 데이터를 전송할 수 있다. L1 싱크 패스는 적어도 하나의 뉴럴 코어 및 L1 공유 메모리를 서로 연결할 수 있다. L1 싱크 패스는 적어도 하나의 뉴럴 코어 및 L1 공유 메모리의 동기화 신호가 이동하는 경로일 수 있다. L1 싱크 패스는 로컬 인터커넥션과 물리적으로 별도로 형성될 수 있다. 로컬 인터커넥션의 경우 글로벌 인터커넥션과 달리 내부에 충분한 채널이 형성되지 않을 수 있다. 이러한 경우에는 L1 싱크 패스 가 별도의 형성되어 동기화 신호의 전송을 빠르고 지체없이 수행할 수 있다. L1 싱크 패스는 글로벌 인터커넥션의 L2 싱크 채널에 비해서 한단계 낮은 레벨에서 수행되는 동기화에 사용될 수 있다. 도 13은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 계층적 구조를 설명하기 위한 도면이다. 도 13을 참조하면, 뉴럴 코어 SoC는 적어도 하나의 뉴럴 프로세서를 포함할 수 있다. 각각의 뉴럴 프 로세서는 글로벌 인터커넥션을 통해서 서로 데이터를 전송할 수 있다. 뉴럴 프로세서는 각각 적어도 하나의 뉴럴 코어를 포함할 수 있다. 뉴럴 코어는 딥러닝 연산 작업에 최적화된 프로세싱 단위 유닛일 수 있다. 뉴럴 코어는 딥러닝 연산 작업의 하나의 오퍼레이션에 대 응하는 프로세싱 단위 유닛일 수 있다. 즉, 딥러닝 연산 작업은 여러 오퍼레이션의 순차적 또는 병렬적 결합으 로 표현 가능할 수 있다. 뉴럴 코어는 각각 하나의 오퍼레이션을 처리할 수 있는 프로세싱 단위 유닛으로 서 컴파일러 입장에서 스케쥴링에 고려할 수 있는 최소한의 연산 단위일 수 있다. 본 실시예에 따른 뉴럴 프로세싱 장치는 컴파일러 스케쥴링 입장에서 고려되는 최소한의 연산 단위와 하드웨어 프로세싱 단위 유닛의 스케일을 동일하게 구성하여 빠르고 효율적인 스케쥴링 및 연산 작업의 수행을 도모할 수 있다. 즉, 연산 작업에 비해서 하드웨어의 분할할 수 있는 프로세싱 단위 유닛이 지나치게 크다면 프로세싱 단위 유닛 의 구동에서 연산 작업의 비효율이 발생할 수 있다. 반대로, 컴파일러의 스케쥴링 최소 단위인 오퍼레이션보다 더 작은 단위의 프로세싱 유닛을 매번 스케쥴링하는 것은 스케쥴링의 비효율이 발생할 수 있고, 하드웨어 설계 비용이 높아질 수 있어 적절하지 않다. 따라서, 본 실시예는 컴파일러의 스케쥴링 단위와 하드웨어 프로세싱 단위의 스케일을 유사하게 조율하여 빠른 연산 작업의 스케쥴링과 하드웨어 리소스의 낭비없이 효율적인 연산 작업 수행을 동시에 충족시킬 수 있다. 도 14는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 소프트웨어 계층 구조를 설명하기 위한 블록도 이다. 도 14를 참조하면, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 소프트웨어 계층 구조는 DL 프레임워 크, 컴파일러 스택 및 백엔드 모듈을 포함할 수 있다. DL 프레임워크는 사용자가 사용하는 딥러닝 모델 네트워크에 대한 프레임워크를 의미할 수 있다. 예를 들어, 텐서플로우나 파이토치와 같은 프로그램을 이용하여 학습이 완료된 뉴럴 네트워크가 생성될 수 있다. 컴파일러 스택은 어댑테이션 레이어, 컴퓨트 라이브러리, 프론트엔드 컴파일러, 백엔드 컴파일러 및 런타임 드라이버를 포함할 수 있다. 어댑테이션 레이어는 DL 프레임워크에 접하는 레이어일 수 있다. 어댑테이션 레이어는 DL 프레임워크에서 생성된 유저의 신경망 모델을 양자화시키고 그래프 수정을 할 수 있다. 또한, 어댑테이 션 레이어는 모델의 타입을 필요한 타입으로 변환시킬 수 있다. 프론트엔드 컴파일러는 어댑테이션 레이어에서 전달받은 다양한 신경망 모델 및 그래프를 일정한 중간 표현(intermediate representation, IR)으로 변환해줄 수 있다. 변환된 IR은 추후 백엔드 컴파일러 에서 다루기 쉬운 미리 설정된 표현일 수 있다. 이러한, 프론트엔드 컴파일러의 IR은 그래프 차원에서 미리 할 수 있는 최적화가 수행될 수 있다. 또한, 프론트엔드 컴파일러는 하드웨어에 최적화된 레이아웃으로 변환시키는 작업을 통해서 최종적으로 IR을 생성할 수 있다. 벡엔드 컴파일러는 프론트엔드 컴파일러에서 변환된 IR을 최적화하고 바이너리 파일로 변환하여 런타임 드라이버가 사용할 수 있게 한다. 백엔드 컴파일러는 하드웨어의 세부 사항에 맞는 스케일로 잡 (job)을 분할하여 최적화된 코드를 생성할 수 있다. 컴퓨트 라이브러리는 여러가지 오퍼레이션 중에 하드웨어에 적합한 형태로 설계된 템플릿 오퍼레이션을 저장할 수 있다. 컴퓨트 라이브러리는 하드웨어가 필요한 여러 템플릿 오퍼레이션을 벡엔드 컴파일러 에 제공하여 최적화된 코드가 생성될 수 있게 한다. 런타임 드라이버는 구동 중에 계속해서 모니터링을 수행하여 본 발명의 몇몇 실시예들에 따른 뉴럴 네트 워크 장치의 구동을 수행할 수 있다. 구체적으로, 뉴럴 네트워크 장치의 인터페이스의 실행을 담당할 수 있다. 백엔드 모듈는 ASIC(Application Specific Integrated Circuit), FPGA(Field programmable gate array) 및 C-model을 포함할 수 있다. ASIC은 미리 결정된 설계 방식에 따라 결정 되는 하드웨어 칩을 의미할 수 있다. FPGA는 프로그래밍이 가능한 하드웨어 칩일 수 있다. C- model은 소프트웨어 상에 하드웨어를 모사하여 구현한 모델을 의미할 수 있다. 백엔드 모듈은 컴파일러 스택을 통해서 생성된 바이너리 코드를 이용하여 다양한 작업을 수행하 고 결과를 도출할 수 있다. 도 15는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치가 수행하는 딥 러닝 연산을 설명하기 위한 개념도 이다. 도 15를 참조하면, 인공신경망 모델은, 기계학습 모델의 일 예로서, 기계학습(Machine Learning) 기술과 인지과학에서, 생물학적 신경망의 구조에 기초하여 구현된 통계학적 학습 알고리즘 또는 그 알고리즘을 실행하는 구조이다. 인공신경망 모델은, 생물학적 신경망에서와 같이 시냅스의 결합으로 네트워크를 형성한 인공 뉴런인 노 드(Node)들이 시냅스의 웨이트를 반복적으로 조정하여, 특정 입력에 대응한 올바른 출력과 추론된 출력 사이의 오차가 감소되도록 학습함으로써, 문제 해결 능력을 가지는 기계학습 모델을 나타낼 수 있다. 예를 들어, 인공 신경망 모델은 기계 학습, 딥러닝 등의 인공지능 학습법에 사용되는 임의의 확률 모델, 뉴럴 네트워크 모델 등을 포함할 수 있다. 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 이러한 인공신경망 모델의 형태를 구현하여 연산 을 수행할 수 있다. 예를 들어, 인공신경망 모델은 입력 영상을 수신하고, 입력 영상에 포함된 대상의 적어도 일부에 대한 정보를 출력할 수 있다. 인공신경망 모델은 다층의 노드들과 이들 사이의 연결로 구성된 다층 퍼셉트론(MLP: multilayer perceptron)으로 구현된다. 본 실시예에 따른 인공신경망 모델은 MLP를 포함하는 다양한 인공신경망 모 델 구조들 중의 하나를 이용하여 구현될 수 있다. 도 15에 도시된 바와 같이, 인공신경망 모델은, 외부 로부터 입력 신호 또는 데이터를 수신하는 입력층, 입력 데이터에 대응한 출력 신호 또는 데이터 를 출력하는 출력층, 입력층과 출력층 사이에 위치하며 입력층으로부터 신 호를 받아 특성을 추출하여 출력층으로 전달하는 n개(여기서, n은 양의 정수)의 은닉층(42000 내지 43000)으로 구성된다. 여기서, 출력층은 은닉층(42000 내지 43000)으로부터 신호를 받아 외부로 출력한 다. 인공신경망 모델의 학습 방법에는, 교사 신호(정답)의 입력에 의해서 문제의 해결에 최적화되도록 학습 하는 지도 학습(Supervised Learning) 방법과, 교사 신호를 필요로 하지 않는 비지도 학습(Unsupervised Learning) 방법이 있다. 뉴럴 프로세싱 장치는 인공신경망 모델을 학습시키기 위한 학습 데이터를 시뮬레이션을 통해 직접 생성 할 수 있다. 이와 같이, 인공신경망 모델의 입력층과 출력층에 복수의 입력변수와 대응되 는 복수의 출력변수가 각각 매칭되고, 입력층, 은닉층(42000 내지 43000) 및 출력층에 포함된 노 드들 사이의 시냅스 값이 조정됨으로써, 특정 입력에 대응한 올바른 출력이 추출될 수 있도록 학습될 수 있다. 이러한 학습 과정을 통해, 인공신경망 모델의 입력변수에 숨겨져 있는 특성을 파악할 수 있고, 입력변수 에 기초하여 계산된 출력변수와 목표 출력 간의 오차가 줄어들도록 인공신경망 모델의 노드들 사이의 시 냅스 값(또는 웨이트)을 조정할 수 있다. 도 16은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 뉴럴 네트워크의 학습 및 추론 동작을 설명하기 위한 개념도이다. 도 16을 참조하면, 학습 과정(Training Phase)에서는 다수의 학습 자료(TD)들이 인공신경망 모델(NN)로 포워딩 되고, 다시 백워딩되는 과정을 거칠 수 있다. 이를 통해서 인공신경망 모델(NN)의 각 노드의 웨이트와 바이어스 들이 조율되고 이를 통해서 점점 더욱 정확한 결과를 도출할 수 있게 학습이 수행될 수 있다. 이렇게 학습 과정 (Training Phase)을 통해서 인공신경망 모델(NN)은 학습된 신경망 모델(NN_T)로 변환될 수 있다. 추론 과정(Inference Phase)에서는 새로운 데이터(ND)가 다시 학습된 신경망 모델(NN_T)로 입력될 수 있다. 학 습된 신경망 모델(NN_T)은 새로운 데이터(ND)를 입력으로 하여 이미 학습된 웨이트와 바이어스를 통해서 결과 데이터(RD)를 도출할 수 있다. 이러한 결과 데이터(RD)는 학습 과정(Training Phase)에서 어떤 학습 자료(TD)로 학습하였는지와, 얼마나 많은 학습 자료(TD)를 이용하였는지가 중요할 수 있다. 이하, 도 17 내지 도 18을 참조하여, 본 발명의 몇몇 실시예들에 따른 프로세싱 장치의 시큐어 부팅 방법을 설 명한다. 상술한 실시예와 중복되는 부분은 생략하거나, 간략히 한다. 본 실시예에 따른 태스크 디펜던시 세팅 방법의 설명을 위해 도 1 내지 도 16 및 전술한 관련된 설명이 참조될 수 잇다. 도 17은 본 발명의 몇몇 실시예들에 따른 프로세싱 장치의 시큐어 부팅 방법을 설명하기 위한 순서도이고, 도 18은 도 17의 메인 코어가 제1 펌웨어를 구동하는 단계를 세부적으로 설명하기 위한 순서도이다. 도 17을 참조하면, 시큐리티 코어가 루트 오브 트러스트를 구동한다(S100). 구체적으로 도 4를 참조하면, 루트 오브 트러스트(RoT)는 시큐리티 코어 도메인(D_sc)으로 로드(load)될 수 있 다. 구체적으로, 시큐리티 코어(SC)가 제3 휘발성 메모리(VM3)에 루트 오브 트러스트(RoT)를 로드하여 구동시킬 수 있다. 다시, 도 17을 참조하면, 시큐리티 코어가 제1 펌웨어의 무결성을 체크한다(S200). 구체적으로 도 5 및 도 6을 참조하면, 시큐리티 코어(SC)가 구동시킨 루트 오브 트러스트(RoT)는 제1 펌웨어 (FW1)의 인테그리티 체크를 수행할 수 있다. 다시, 도 17을 참조하면, 메인 코어가 제1 펌웨어를 구동시킨다(S300). 세부적으로, 도 18을 참조하면, 메인 코어 도메인에서 휘발성 메모리에 제1 펌웨어를 로드하고(S310), 메인 코 어가 제1 펌웨어를 구동시킨다(S320). 구체적으로 도 4를 참조하면, 메인 코어 도메인(D_mc)의 휘발성 메모리(VM)는 제1 휘발성 메모리(VM1) 및 제3 휘발성 메모리(VM3) 중 적어도 하나를 포함할 수 있다. 메인 코어 도메인(D_mc)은 루트 오브 트러스트(RoT)가 무결성을 체크한 제1 펌웨어(FW1)를 로드하여 동작시킬 수 있다. 다시, 도 17을 참조하면, 시큐리티 코어가 제2 펌웨어의 무결성을 체크하고(S400), 이어서 메인 코어가 제2 펌 웨어를 구동시킨다(S500). 구체적으로 도 5 및 도 6을 참조하면, 시큐리티 코어(SC)가 루트 오브 트러스트(RoT)를 통해서 제2 펌웨어(FW 2)의 인테그리티 체크를 수행할 수 있다. 이어서, 메인 코어(MC)가 무결성이 체크된 제2 펌웨어(FW2)를 구동시 킬 수 있다. 제2 펌웨어(FW2)는 도 18의 제1 펌웨어(FW1) 구동과 동일한 방식으로 수행될 수 있다. 단, 본 실시 예가 이에 제한되는 것은 아니다. 이상의 설명은 본 실시예의 기술 사상을 예시적으로 설명한 것에 불과한 것으로서, 본 실시예가 속하는 기술 분 야에서 통상의 지식을 가진 자라면 본 실시예의 본질적인 특성에서 벗어나지 않는 범위에서 다양한 수정 및 변 형이 가능할 것이다. 따라서, 본 실시예들은 본 실시예의 기술 사상을 한정하기 위한 것이 아니라 설명하기 위 한 것이고, 이러한 실시예에 의하여 본 실시예의 기술 사상의 범위가 한정되는 것은 아니다. 본 실시예의 보호 범위는 아래의 청구범위에 의하여 해석되어야 하며, 그와 동등한 범위 내에 있는 모든 기술 사상은 본 실시예의 권리범위에 포함되는 것으로 해석되어야 할 것이다."}
{"patent_id": "10-2023-0087977", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 몇몇 실시예들에 따른 프로세싱 시스템을 설명하기 위한 블록도이다. 도 2a는 도 1의 프로세싱 장치의 세부적인 구조를 설명하기 위한 블록도이다. 도 2b는 도 1의 프로세싱 장치의 세부적인 구조를 설명하기 위한 블록도이다. 도 3은 도 2a 또는 도 2b의 시큐리티 코어의 세부적인 구조를 설명하기 위한 블록도이다. 도 4는 본 발명의 시큐리티 코어 도메인과 메인 코어 도메인에서 펌웨어의 인테그리티 체크를 수행하는 방식을 설명하기 위한 블록도이다. 도 5는 본 발명의 체인 오브 트러스트를 설명하기 위한 블록도이다. 도 6은 본 발명의 메인 코어와 시큐리티 코어의 동작을 설명하기 위한 도면이다. 도 7은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템을 설명하기 위한 블록도이다. 도 8는 도 7의 뉴럴 프로세싱 장치를 세부적으로 설명하기 위한 블록도이다. 도 9는 도 8의 뉴럴 코어 SoC를 세부적으로 설명하기 위한 블록도이다. 도 10은 도 9의 글로벌 인터커넥션을 세부적으로 설명하기 위한 구조도이다. 도 11은 도 7의 뉴럴 프로세싱 장치의 제어 신호의 흐름을 설명하기 위한 블록도이다. 도 12는 도 9의 뉴럴 프로세서를 세부적으로 설명하기 위한 블록도이다. 도 13은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 계층적 구조를 설명하기 위한 도면이다. 도 14는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 소프트웨어 계층 구조를 설명하기 위한 블록도 이다. 도 15는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치가 수행하는 딥 러닝 연산을 설명하기 위한 개념도 이다. 도 16은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 뉴럴 네트워크의 학습 및 추론 동작을 설명하기 위한 개념도이다. 도 17은 본 발명의 몇몇 실시예들에 따른 프로세싱 장치의 시큐어 부팅 방법을 설명하기 위한 순서도이다. 도 18은 도 17의 메인 코어가 제1 펌웨어를 구동하는 단계를 세부적으로 설명하기 위한 순서도이다."}
