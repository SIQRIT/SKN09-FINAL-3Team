{"patent_id": "10-2023-0128232", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0045216", "출원번호": "10-2023-0128232", "발명의 명칭": "부동 소수점 타입의 데이터에 대한 누적 연산을 수행하도록 구성된 가속기 및 그것의 동작 방", "출원인": "삼성전자주식회사", "발명자": "장재훈"}}
{"patent_id": "10-2023-0128232", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "복수의 데이터에 대한 누적 연산을 수행하도록 구성된 가속기의 동작 방법에 있어서,상기 복수의 데이터 중 적어도 2개의 제1 데이터를 로드하는 하는 단계;상기 적어도 2개의 제1 데이터의 지수들 중 최대 값인 제1 지수를 탐색하는 단계;상기 제1 지수를 기반으로, 상기 적어도 2개의 제1 데이터의 제1 가수들에 대한 비트 시프트를 수행하여, 정렬된 제1 가수들을 생성하고, 상기 정렬된 제1 가수들에 대한 누적 연산을 수행하여, 제1 누적 값을 생성하는 단계;상기 복수의 데이터 중 적어도 2개의 제2 데이터를 로드하는 단계;상기 적어도 2개의 제2 데이터의 지수들 중 최대 값인 제2 지수를 탐색하고, 상기 제2 지수는 상기 제1 지수보다 큰 단계; 및상기 제2 지수 및 상기 제1 지수의 차이를 기반으로 상기 제1 누적 값에 대한 비트 시프트를 수행하여 제1 정렬된 누적 값을 생성하고, 상기 제2 지수를 기반으로, 상기 적어도 2개의 제2 데이터의 제2 가수들에 대한 비트시프트를 수행하여, 정렬된 제2 가수들을 생성하고, 상기 정렬된 제2 가수들 및 상기 제1 정렬된 누적 값에 대한 누적 연산을 수행하여 제2 누적 값을 생성하는 단계를 포함하고, 상기 복수의 데이터 각각은 부동 소수점 타입을 갖는 동작 방법."}
{"patent_id": "10-2023-0128232", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서,상기 제1 지수에 대한 정보를 최대 지수로서 저장하는 단계를 더 포함하는 동작 방법."}
{"patent_id": "10-2023-0128232", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 2 항에 있어서,상기 제2 지수가 상기 제1 지수보다 더 큰 경우, 상기 최대 지수를 상기 제2 지수로 갱신하는 단계를 더 포함하는 동작 방법."}
{"patent_id": "10-2023-0128232", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 1 항에 있어서,상기 복수의 데이터 중 적어도 2개의 제3 데이터를 로드하는 단계;상기 적어도 2개의 제3 데이터의 지수들 중 최대 값인 제3 지수를 탐색하고, 상기 제3 지수는 상기 제2 지수보다 크지 않은 단계;상기 제3 지수를 기반으로, 상기 적어도 2개의 제3 데이터의 제3 가수들에 대한 비트 시프트를 수행하여, 정렬된 제2 가수들을 생성하고, 상기 정렬된 제2 가수들 및 상기 제2 누적 값에 대한 누적 연산을 수행하여 제3 누적 값을 생성하는 단계를 더 포함하는 동작 방법.공개특허 10-2025-0045216-3-청구항 5 제 1 항에 있어서,상기 제3 누적 값 및 상기 제2 지수를 기반으로, 정규화를 수행하여, 출력 값을 생성하는 단계를 더 포함하고,상기 출력 값은 상기 부동 소수점 타입을 갖는 동작 방법."}
{"patent_id": "10-2023-0128232", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 1 항에 있어서,상기 정렬된 제1 가수들에 대한 누적 연산 및 상기 정렬된 제2 가수들 및 상기 제1 정렬된 누적 값에 대한 누적연산은 정수 타입 덧셈을 통해 수행되는 동작 방법."}
{"patent_id": "10-2023-0128232", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서,상기 제1 누적 값에 대한 비트 시프트는 클럭 신호의 주기에 동기하여 1비트씩 수행되는 동작 방법."}
{"patent_id": "10-2023-0128232", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 7 항에 있어서,상기 제1 누적 값에 대한 비트 시프트가 수행되는 동안, 상기 정렬된 제2 가수들의 입력이 중지되는 동작 방법."}
{"patent_id": "10-2023-0128232", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1 항에 있어서,상기 가속기는 N개의 데이터에 대한 누적 연산을 병렬적으로 수행하도록 구성되고,상기 적어도 2개의 제1 데이터의 개수 및 상기 적어도 2개의 제2 데이터의 개수 각각은 상기 N보다 작은 동작방법."}
{"patent_id": "10-2023-0128232", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제 9 항에 있어서,상기 복수의 데이터의 개수는 상기 N보다 크고, 상기 복수의 데이터에 대하 누적 연산이 모두 완료된 이후에,상기 가속기는 상기 누적 연산의 결과에 대한 정규화를 수행하는 동작 방법."}
{"patent_id": "10-2023-0128232", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명의 실시 예에 따른 가속기는 복수의 데이터에 대한 누적 연산을 수행하도록 구성된다. 가속기의 동작 방 법은 복수의 데이터 중 적어도 2개의 제1 데이터를 로드하는 하는 단계, 적어도 2개의 제1 데이터의 지수들 중 최대 값인 제1 지수를 탐색하는 단계, 제1 지수를 기반으로, 적어도 2개의 제1 데이터의 제1 가수들에 대한 비트 (뒷면에 계속)"}
{"patent_id": "10-2023-0128232", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 인공지능 시스템에 관한 것으로, 좀 더 상세하게는 부동 소수점 타입의 데이터에 대한 누적 연산을 수행하도록 구성된 가속기 및 그것의 동작 방법에 관한 것이다."}
{"patent_id": "10-2023-0128232", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능(AI; artificial intelligence)은 인간의 학습, 추론, 지각과 같은 다양한 능력들을 인공적으로 구현하 는 컴퓨터 과학의 일 분야이다. 최근에 인공지능은 자연 언어의 이해, 자연 언어의 번역, 로보틱스, 인공 시각, 문제 해결, 학습, 지식 획득, 인지 과학과 같은 다양한 분야에서 널리 활용된다. 인공지능은 다양한 알고리즘을 기반으로 구현되고 있다. 일 예로서, 신경망(neural network)은 노드(node) 및 시냅스(synapse)가 반복적으로 연결된 복잡한 네트워크로 구성된다. 현재 노드에서 다음 노드로 데이터가 이동 하는 과정에서, 대응하는 시냅스에 따라 다양한 신호 처리가 발생할 수 있으며, 이러한 신호 처리 과정은 레이 어(Layer)라 불린다. 즉, 신경망은 상호간에 복잡하게 연결된 다양한 레이어들을 포함할 수 있다. 신경망에 포 함된 다양한 레이어들은 많은 양의 연산을 필요로 하기 때문에, 이를 최적화하기 위한 다양한 방법들이 연구되 고 있다."}
{"patent_id": "10-2023-0128232", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명의 목적은 향상된 신뢰성 및 향상된 성능을 갖는 부동 소수점 타입의 데이터에 대한 누적 연산을 수행하 도록 구성된 가속기 및 그것의 동작 방법을 제공하는데 있다."}
{"patent_id": "10-2023-0128232", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 일 실시 예에 따르면, 복수의 데이터에 대한 누적 연산을 수행하도록 구성된 가속기의 동작 방법은 상기 복수의 데이터 중 적어도 2개의 제1 데이터를 로드하는 하는 단계; 상기 적어도 2개의 제1 데이터의 지수 들 중 최대 값인 제1 지수를 탐색하는 단계; 상기 제1 지수를 기반으로, 상기 적어도 2개의 제1 데이터의 제1 가수들에 대한 비트 시프트를 수행하여, 정렬된 제1 가수들을 생성하고, 상기 정렬된 제1 가수들에 대한 누적 연산을 수행하여, 제1 누적 값을 생성하는 단계; 상기 복수의 데이터 중 적어도 2개의 제2 데이터를 로드하는 단계; 상기 적어도 2개의 제2 데이터의 지수들 중 최대 값인 제2 지수를 탐색하고, 상기 제2 지수는 상기 제1 지수보다 큰 단계; 상기 제2 지수 및 상기 제1 지수의 차이를 기반으로 상기 제1 누적 값에 대한 비트 시프트를 수행하여 제1 정렬된 누적 값을 생성하고, 상기 제2 지수를 기반으로, 상기 적어도 2개의 제2 데이터의 제2 가 수들에 대한 비트 시프트를 수행하여, 정렬된 제2 가수들을 생성하고, 상기 정렬된 제2 가수들 및 상기 제1 정 렬된 누적 값에 대한 누적 연산을 수행하여 제2 누적 값을 생성하는 단계를 포함하고, 상기 복수의 데이터 각각 은 부동 소수점 타입을 갖는다. 본 발명의 일 실시 예에 따르면, 복수의 데이터에 대한 누적 연산을 수행하도록 구성된 가속기는 상기 복수의 데이터를 저장하도록 구성된 범용 버퍼부; 상기 복수의 데이터 중 적어도 2개의 제1 데이터를 로드하고, 상기 적어도 2개의 제1 데이터의 지수들 중 최대 값인 제1 최대 지수를 탐색하고, 상기 제1 최대 지수 및 이전 최대 지수를 기반으로, 상기 적어도 제2 개의 제1 데이터의 가수들에 대한 비트 시프트를 수행하여, 제1 정렬된 가수 들을 생성하도록 구성된 사전 정렬부; 이전 최대 지수 및 상기 제1 최대 지수를 기반으로, 이전 누적 값에 대한 비트 시프트를 수행하여 정렬된 누적 값을 생성하고, 상기 정렬된 누적 값 및 상기 제1 가수들에 대한 누적 연 산을 수행하도록 구성된 복수의 처리부들; 및 상기 제1 최대 지수를 기반으로 상기 복수의 처리부들의 연산 결 과에 대한 정규화를 수행하여 출력 값을 생성하도록 구성된 정규화부를 포함하고, 상기 복수의 데이터 각각은 부동 소수점 타입이다. 본 발명의 일 실시 예에 따르면, 복수의 데이터에 대한 누적 연산을 수행하도록 구성된 가속기의 동작 방법은 복수의 데이터 중 적어도 2개의 데이터에 대한 누적 연산을 수행하여, 제0 최대 지수 및 제0 누적 값을 생성하 는 단계; 상기 복수의 데이터 중 제1 데이터의 제1 지수가 상기 제0 최대 지수보다 큰 경우, 상기 제1 지수 및 상기 제0 최대 지수를 기반으로 상기 제0 누적 값에 대한 비트 시프트를 수행하여 제0 정렬된 누적 값을 생성하 는 단계; 및 상기 제1 데이터의 제1 가수 및 상기 제0 정렬된 누적 값에 대한 누적 연산을 수행하여 제1 누적 값을 생성하는 단계를 포함하고, 상기 복수의 데이터 각각은 부동 소수점 타입을 갖는다."}
{"patent_id": "10-2023-0128232", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명에 따르면, 향상된 신뢰성 및 향상된 성능을 갖는 부동 소수점 타입의 데이터에 대한 누적 연산을 수행 하도록 구성된 가속기 및 그것의 동작 방법이 제공된다."}
{"patent_id": "10-2023-0128232", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하에서, 본 발명의 기술 분야에서 통상의 지식을 가진 자가 본 발명을 용이하게 실시할 수 있을 정도로, 본 발명의 실시 예들이 명확하고 상세하게 기재될 것이다. 상세한 설명 또는 도면에서 사용되는 \"부(unit)\", \"모듈(module)\" 등과 같은 용어들 또는 도면에 도시된 기능 블록들은 특정 기능을 수행하도록 구성된 하드웨어, 소프트웨어, 또는 그것의 조합의 형태로 구현될 수 있다. 도 1은 본 발명의 일 실시 예에 따른 시스템을 보여주는 블록도이다. 도 1을 참조하면, 시스템은 메모리 , 가속기, 및 컨트롤러를 포함할 수 있다. 일 실시 예에서, 시스템은 인공지능 모델의 처 리를 수행하도록 구성된 전용 하드웨어일 수 있다. 예를 들어, 시스템은 GPU(graphics processing unit), NPU(neural processing unit), 또는 별도의 전용 하드웨어일 수 있다. 일 실시 예에서, 시스템에 의해 구동되는 인공지능 모델은 기계 학습을 통해 생성될 수 있다. 기계 학습은 지도형 학습(supervised learning), 비지도형 학습(unsupervised learning), 준지도형 학습(semi-supervised learning) 또는 강화 학습(reinforcement learning)을 포함할 수 있으나, 본 발명의 범위가 이에 한정되는 것 은 아니다. 일 실시 예에서, 인공지능 모델은 심층 신경망(DNN: deep neural network), CNN(convolutional neural network), RNN(recurrent neural network), RBM(restricted boltzmann machine), DBN(deep belief network), BRDNN(bidirectional recurrent deep neural network), 심층 Q-네트워크(deep Q-networks) 등과 같은 다양한 신경망들 중 하나 또는 적어도 둘 이상의 조합을 통해 생성되거나 또는 학습될 수 있다. 인공지능 모델은 복수 의 신경망 레이어들을 포함할 수 있고, 복수의 신경망 레이어들 각각은 학습된 모델 또는 가중치를 기반으로 인 공지능 연산을 수행하도록 구성될 수 있다. 이하에서, 본 발명의 실시 예들을 용이하게 설명하기 위해, “인공지능 연산”의 용어가 사용된다. “인공지능 연산”은 시스템이 인공지능 모델을 학습하거나 또는 어떤 결과를 추론하기 위해, 시스템 내에서 수 행되는 다양한 연산들을 통칭할 수 있다. 일 예로서, 인공지능 연산은 인공지능 모델의 다양한 레이어에서 수행 되는 곱셈 누적(MAC; multiply and accumulate) 연산을 포함할 수 있다. 메모리는 시스템의 인공지능 연산을 위해 필요한 다양한 데이터, 가중치, 파라미터 등을 저장하도록 구성될 수 있다. 일 실시 예에서, 메모리는 DRAM(dynamic random access memory)일 수 있다. 그러나 본 발명의 범위가 이에 한정되는 것은 아니며, 메모리는 SRAM, PRAM, MRAM, RRAM, FRAM, 플래시 메모리 등과같은 다양한 형태의 메모리들을 포함할 수 있다. 가속기는 메모리에 저장된 데이터, 가중치, 또는 파라미터를 사용하여, 인공지능 연산을 수행하도록 구성될 수 있다. 일 실시 예에서, 가속기는 인공지능 연산을 위한 복수의 처리부들(PEs; processing elements)을 포함할 수 있다. 복수의 처리부들 각각은 메모리 메모리에 저장된 데이터, 가중치, 또는 파라 미터에 대한 곱셈 및 누적(MAC; multiply and accumulate) 연산을 수행하도록 구성될 수 있다. 복수의 처리부들 의 연산 결과를 기반으로 인공지능 모델이 학습되거나 또는 특정 결과가 추론될 수 있다. 컨트롤러는 메모리 및 가속기를 제어하도록 구성될 수 있다. 일 실시 예에서, 컨트롤러는 시스템의 제반 동작을 제어하도록 구성된 CPU(central processing unit)일 수 있다. 도 2a 및 도 2b는 도 1의 가속기에서 수행되는 MAC 연산을 설명하기 위한 도면들이다. 도 2a 및 도 2b를 참조하 면, MAC 연산은 2개의 데이터에 대한 1회의 곱셈 연산 및 1회의 누적 연산을 포함할 수 있다. 예를 들어, 도 2a에 도시된 바와 같이, N-비트의 가중치 및 N-비트의 활성(activation)에 대한 곱셈이 수행될 수 있다. 이 경우, 곱셈 결과는 2N-비트의 크기를 갖는다. 이후에, 곱셈 결과가 누적됨에 따라, 누적 결과는 (2N+M)-비트의 크기를 가질 수 있다. 누적 결과의 크기가 증가할 경우, 누적 결과를 정하기 위한 메모리 용량이 증가하므로, 누적 결과의 크기를 감소시킬 필요가 있다. 이에 따라, 누적 결과는 N-비트의 출력 데이터로 정규 화될 수 있다. 정규화된 출력 데이터는 메모리에 다시 저장될 수 있다. 일 실시 예에서, MAC 연산의 데이터는 다양한 데이터 타입을 가질 수 있다. 예를 들어, MAC 연산의 데이터는 정 수 타입일 수 있다. 또는 MAC 연산의 데이터는 부동 소수점 타입(floating point type)일 수 있다. 부동 소수점 타입은 데이터를 부호(sign), 가수(fraction), 및 지수(exponent)의 형태로 표현하는 방식이다. 부동 소수점 타 입은 32비트 단정밀도(32-bits single precision), 64비트 배정밀도(64-bits double precision) 등의 방식이 존재한다. 데이터의 타입, 데이터의 크기 등에 따라, 연산 결과의 정확성, 하드웨어 구조의 면적, 및 전력 소모량이 바뀔 수 있다. 따라서, 시스템의 목적에 따라 데이터의 타입 및 데이터의 크기가 다양하게 결정될 수 있다. 일 실시 예에서, 데이터가 부동 소수점 타입인 경우, 데이터에 대한 덧셈을 수행하기 위해서는, 데이터에 대한 지수 정렬, 덧셈, 및 정규화 과정이 요구된다. 이 때, 지수 정렬, 덧셈, 및 정규화 과정에서, 하드웨어 리소스 제한으로 인한 손실이 발생할 수 있다. 예를 들어, 도 2b에 도시된 바와 같이, +1.001×2-1 및 -1.001×2-3로 표현되는 부동 소수점 타입의 데이터의 덧 셈이 수행되는 것으로 가정한다. 두 데이터의 지수들 중 최대 지수는 -1이므로, 두 데이터의 지수를 -1로 정렬 한다. 이 경우, 두 데이터는 +1.001×2-1 및 -0.01001×2-1로 표현된다. 이 때, 두 데이터를 저장하기 위한 레지 스터의 크기 제한으로 인해, -0.01001×2-1의 가수(즉, 0.01001) 중 일부 유효 값(예를 들어, 하위 비트들, 0 1)이 소실될 수 있다. 즉, 두 데이터의 가수들에 대한 실제 덧셈은 +1.001 및 -0.010에 대하여 수행된다. 이에 따른 덧셈 결과는 +0.111×2-1로 표현될 수 있다. 덧셈 결과의 가수의 최상위 비트가 0이므로, 부동 소수점 타입의 형식에 적합하도록, 덧셈 결과에 대한 정규화가 수행된다. 이에 따라, 정규화된 덧셈 결과는 +1.110×2-2 로 표현된다. 반면에, +1.001×2-1 및 -1.001×2-3의 실제 덧셈 결과는 +1.1011×2-2이다. 즉, 지수 정렬 과정에 서 하드웨어 리소스 제한으로 인한 손실이 발생할 수 있으며, 이는 최종 덧셈 결과에서 오차를 유발할 수 있다. 일 실시 예에서, 도 2b의 예시에서 나타나지는 않았으나, 덧셈 결과에 대한 정규화 과정에서도 유사한 오차가 발생할 수 있다. 즉, 상술된 바와 같이, 부동 소수점 타입의 데이터에 대한 덧셈 과정에서, 지수 정렬 또는 정규화에 의해 오차 가 발생할 수 있다. 본 발명의 실시 예들에서는, 상술된 오차를 최소화하는 가속기의 구조가 제안된다. 도 3은 도 1의 가속기를 보여주는 순서도이다. 도 1, 및 도 3을 참조하면, 가속기는 범용 버퍼부, 사 전 정렬부, 정규화부, 및 복수의 처리부들(PE11~PE44)을 포함할 수 있다. 범용 버퍼부는 가속기에서 수행될 인공지능 연산을 위한 다양한 데이터, 가중치, 또는 파라미터를 저 장하도록 구성될 수 있다. 일 실시 예에서, 범용 버퍼부에 저장된 정보는 메모리로부터 제공되거나 또는 가속기의 복수의 처리부들(PE11~PE44)의 연산 결과로부터 획득될 수 있다.사전 정렬부는 범용 버퍼부로부터 제공된 데이터에 대한 사전 정렬을 수행하도록 구성될 수 있다. 예 를 들어, 범용 버퍼부로부터 제공된 데이터는 부동 소수점 타입을 가질 수 있다. 좀 더 상세한 예로서, 시 스템에서 처리되는 인공지능 모델은 활성(activation)을 부동 소수점 타입으로 연산하고, 가중치를 정수 타입으로 학습할 수 있다. 이 경우, 복수의 데이터에 대한 부동 소수점 누적 연산이 요구된다. 이 경우, 도 2b 를 참조하여 설명된 바와 같이, 부동 소수점 타입의 데이터에 대한 덧셈을 위해, 데이터에 대한 지수 정렬이 요 구될 수 있다. 예를 들어, 부동 소수점 타입의 데이터에 대한 덧셈을 위해서는, 사전 정렬이 요구된다. 이에 따라, 사전 정렬 부는 가속기에서 병렬 연산 가능한 개수의 데이터에 대한 지수 정렬을 수행할 수 있다. 지수 정렬은 복수의 데이터의 최대 지수(emax)를 탐색하고, 탐색된 최대 지수(emax)를 기반으로 복수의 데이터 각각의 가수에 대한 비트 시프트 동작을 수행하는 것을 가리킨다. 이 때, 동시에 또는 병렬적으로 연산 가능한 개수의 데이터 가 모두 동일한 최대 지수(emax)를 가져야 하므로, 사전 정렬부는 동시에 또는 병렬적으로 연산 가능한 개 수의 데이터 전부에 대한 최대 지수(emax)를 탐색하고, 탐색된 최대 지수(emax)를 기반으로 복수의 데이터의 가수 들에 대한 비트 시프트 동작을 수행한다. 복수의 처리부들(PE11~PE44)은 사전 정렬부로부터 입력된 데이터에 대한 연산을 수행할 수 있다. 이 때, 복수의 처리부들(PE11~PE44) 각각은 입력된 데이터에 대한 곱셈 연산 또는 누적 연산을 수행하여, 부분 합 (PSUM)을 생성할 수 있다. 생성된 부분 합(PSUM)은 정규화부로 제공될 수 있다. 예를 들어, 복수의 처리부들(PE11~PE44) 각각은 사전 정렬부로부터 활성(activation)을 수신할 수 있고, 범용 버퍼부로부터 가중치(weight)를 수신할 수 있다. 복수의 처리부들(PE11~PE44) 각각은 수신된 활성 및 가중치에 대한 MAC 연산을 수행하여 부분 합(PSUM)을 생성 또는 누적할 수 있다. 이하에서, 본 발명의 실시 예 들을 용이하게 설명하기 위해, 복수의 처리부들(PE11~PE44)은 데이터 또는 활성화에 대한 덧셈 연산 또는 누적 연산을 수행하여 부분 합(PSUM)을 생성하는 것으로 설명된다. 일 실시 예에서, 복수의 처리부들(PE11~PE44)은 사전 정렬부로부터 생성된 정렬된 가수들(즉, 동일한 지수 로 정렬된 가수들)에 대한 덧셈 연산을 수행한다. 이 때, 정렬된 가수들에 대응하는 지수들은 서로 동일하므로, 덧셈 연산은 단순 정수 연산, 정수 덧셈, 또는 정수 누적을 통해 통해 구현될 수 있다. 즉, 복수의 처리부들 (PE11~PE44) 각각은 정수 덧셈기의 구조를 가질 수 있다. 정규화부는 복수의 처리부들(PE11~PE44) 각각으로부터 부분합(PSUM)을 수신하고, 수신된 부분합들(PSUM)의 누적 값을 연산하고, 연산된 누적 값에 대한 정규화를 수행하여 출력 값을 생성할 수 있다. 예를 들어, 정규화 부는 최대 지수(emax)에 대한 정보를 사전 정렬부로부터 수신할 수 있다. 정규화부는 수신된 최 대 지수(emax)에 대한 정보를 기반으로 누적 값에 대한 정규화를 수행할 수 있다. 생성된 출력 값은 범용 버퍼부 에 저장될 수 있다. 범용 버퍼부에 저장된 출력 값은 다른 인공지능 연산에 대한 입력 값으로 사용될 수 있다. 도 4는 도 3의 가속기의 동작을 보여주는 순서도이다. 이하에서, 설명의 편의를 위해, 가속기의 복수의 처 리부들(PE11~PE44)은 데이터에 대한 누적 연산을 수행하는 것으로 가정한다. S10 단계에서, 가속기는 N개의 데이터를 로드할 수 있다. 예를 들어, 가속기의 사전 정렬부는 N 개의 데이터를 통합 버퍼부로부터 로드할 수 있다. 또는, 가속기는 N개의 데이터를 메모리로부 터 로드할 수 있다. 일 실시 예에서, N개의 데이터 각각은 부동 소수점 타입을 가질 수 있다. 일 실시 예에서, N은 가속기의 복수의 처리부들(PE11~PE44)의 개수에 대응하는 자연수일 수 있다. 예를 들 어, 가속기는 연산 속도를 향상시키기 위해, 복수의 데이터에 대한 연산을 동시에 또는 병렬적으로 수행할 수 있다. 이 때, 동시에 연산이 수행되는 데이터의 개수는 가속기에 포함된 복수의 처리부들(PE11~PE44)의 배열 크기에 대응될 수 있다. 즉, N은 가속기에서 동시에 또는 병렬적으로 연산 가능한 데이터의 개수 또 는 크기를 가리킬 수 있다. S20 단계에서, 가속기는 N개의 데이터의 최대 지수(emax)를 탐색할 수 있다. 예를 들어, N개의 데이터 각각 은 부동 소수점 타입을 가질 수 있다. 즉, N개의 데이터 각각은 부호, 가수, 및 지수를 포함할 수 있다. 가속기 의 사전 정렬부는 N개의 데이터 각각의 지수를 비교하고, 가장 큰 값인 최대 지수(emax)를 판별할 수 있다. S30 단계에서, 가속기는 최대 지수(emax)를 기반으로, N개의 데이터에 대한 지수 정렬을 수행하여, 정렬된 가수들을 생성할 수 있다. 예를 들어, 도 2b에 도시된 바와 같이, 데이터가 +1.001×2-1 및 -1.001×2-3인 것으 로 가정한다. 이 경우, 최대 지수(emax)는 -1이므로, 데이터의 각 가수는 +1.001 및 -0.01001로 정렬될 것이다. 정렬된 가수들은 복수의 처리부들(PE11~PE44)로 제공될 수 있다. S40 단계에서, 가속기는 복수의 처리부들(PE11~PE44)을 사용하여, 정렬된 가수들을 누적하여 부분 합을 생 성할 수 있다. 예를 들어, 복수의 처리부들(PE11~PE44) 각각은 사전 정렬부로부터 정렬된 가수들을 수신할 수 있다. 복수의 처리부들(PE11~PE44) 각각은 정렬된 가수들에 대한 누적 연산을 수행하도록 구성될 수 있다. 일 실시 예에서, 정렬된 가수들은 S30 단계의 동작을 통해, 최대 지수를 기반으로 정렬되었으므로, 복수의 처리 부들(PE11~PE44) 각각은 정렬된 가수들에 대한 누적 연산을 수행할 수 있다. S50 단계에서, 가속기는 복수의 처리부들(PE11~PE44) 각각의 부분합(PSUM)을 누적하고, 누적 결과를 정규 화할 수 있다. 예를 들어, 가속기의 정규화부는 복수의 처리부들(PE11~PE44) 각각으로부터 부분합 (PSUM)을 수신할 수 있다. 복수의 부분합들(PSUM)에 대응하는 지수는 최대 지수(emax)로 동일할 것이다. 정규화 부는 최대 지수(emax)를 기반으로 누적 결과에 대한 정규화를 수행할 수 있다. 일 실시 예에서, 정규화된 결과는 범용 버퍼부 또는 메모리에 저장될 수 있다. 도 5는 도 3의 사전 정렬부를 보여주는 블록도이다. 도 1, 도 3, 도 4, 및 도 5를 참조하면, 사전 정렬부 는 최대 지수 탐색기(MEF) 및 복수의 변환기들(CVT1~CVTn)을 포함할 수 있다. 최대 지수 탐색기(MEF; maximum exponent finder)는 N개의 데이터(DT_1~DT_N)에 대한 최대 지수(emax)를 탐색 하도록 구성될 수 있다. 예를 들어, N개의 데이터(DT_1~DT_N) 각각은 부동 소수점 타입일 수 있다. 최대 지수 탐색기(MEF)는 N개의 데이터(DT_1~DT_N) 각각의 지수를 비교하여, 최대 지수(emax)를 탐색할 수 있다. 탐색된 최 대 지수(emax)는 복수의 변환기들(CVT1~CVTn) 각각으로 제공될 수 있다. 복수의 변환기들(CVT1~CVTn)은 최대 지수(emax)를 기반으로, 복수의 데이터(DT_1~DT_N)에 대한 지수 정렬을 수행 할 수 있다. 예를 들어, 제1 변환기(CVT1)는 제1 데이터(DT_1) 및 최대 지수(emax)를 수신할 수 있다. 제1 데이 터(DT_1)는 제1 가수(M1) 및 제1 지수(e1)를 포함할 수 있다. 제1 변환기(CVT1)는 제1 데이터(DT_1)의 제1 지 수(e1) 및 최대 지수(emax)의 차이인 제1 지수 차이(△e1)를 연산할 수 있다. 제1 변환기(CVT1)는 제1 데이터 (DT_1)의 제1 가수(M1)에 대하여, 제1 지수 차이(△e1)만큼 비트 시프트를 수행하여, 제1 정렬된 가수(sM1)를 생성할 수 있다. 예를 들어, 제1 지수(e1)가 “-5”이고, 최대 지수(emax)가 “-1”이고, 제1 가수(M1)가 “ 1.0100111”인 것으로 가정한다. 이 경우, 제1 변환기(CVT1)는 제1 가수(M1)를 -4만큼 비트 시프트시킴으로써, 제1 정렬된 가수(sM1)(즉, 0.00010100111)를 출력할 수 있다. 제2 변환기(CVT2)는 제2 데이터(DT_2) 및 최대 지수(emax)를 수신할 수 있다. 제2 변환기(CVT2)는 제2 데이터 (DT_2)의 제2 지수(e2) 및 최대 지수(emax)의 차이인 제2 지수 차이(△e2)를 기반으로 제2 데이터(DT_2)의 제2 가수(M2)에 대한 비트 시프트를 수행하여 제2 정렬된 가수(sM2)를 출력할 수 있다. 마찬가지로, 제n 변환기 (CVTn)는 제n 데이터(DT_N) 및 최대 지수(emax)를 수신할 수 있다. 제n 변환기(CVTn)는 제n 데이터(DT_N)의 제n 지수(eN) 및 최대 지수(emax)의 차이인 제n 지수 차이(△en)를 기반으로 제n 데이터(DT_N)의 제N 가수(MN)에 대 한 비트 시프트를 수행하여, 제n 정렬된 가수(sMN)를 출력할 수 있다. 일 실시 예에서, 복수의 변환기들(CVT1~CVTn)에 의해 생성된 복수의 정렬된 가수들(sM1~sMN)은 복수의 처리부들 (PE11~PE44)로 제공될 수 있다. 복수의 처리부들(PE11~PE44)에 대한 누적 연산을 수행하여 부분 합을 생성할 수 있다. 도 6은 도 3의 가속기의 인공지능 연산을 설명하기 위한 타이밍도이다. 도 1, 도 3, 및 도 6을 참조하면, 가속 기는 제1 내지 제2N 데이터(DT_1~DT_2N)에 대한 인공지능 연산을 수행할 수 있다. 가속기는 N개의 데 이터에 대해 동시에 또는 병렬적으로 인공지능 연산을 수행할 수 있다. 이 경우, 가속기는 제1 내지 제N 데이터(DT_1~DT_N)에 대한 인공지능 연산을 수행하고, 이후에, 나머지 데이터(DT_N+1~DT_2N)에 대한 인공지능 연산을 수행할 것이다. 예를 들어, 제0 시점으로부터 제1 시점들까지의 구간(t0~t1)동안, 가속기의 사전 정렬부는 제1 내지 제N 데이터(DT_1~DT_N)를 통합 버퍼부로부터 로드할 수 있다. 제1 내지 제N 데이터(DT_1~DT_N)가 모두 로 드된 이후에, 제1 시점으로부터 제2 시점까지의 구간(t1~t2)동안, 가속기의 사전 정렬부는 제1 내지 N 데이터(DT_1~DT_N)의 지수들 중 최대 지수(emax1)를 탐색할 수 있다. 이후에, 제2 시점으로부터 제5 시점까지 의 구간(t2~t5)동안, 가속기의 사전 정렬부는 제1 내지 제N 데이터(DT_1~DT_N)를 다시 로드할 수 있 다. 제3 시점으로부터 제6 시점까지의 구간(t3~t6)동안, 가속기의 사전 정렬부는, 최대 지수(emax1)를 기반으로, 제1 내지 제N 데이터(DT_1~DT_N) 각각의 가수에 대한 비트 시프트 동작을 수행하여, 정렬된 가수들을 생성할 수 있다. 제4 시점으로부터 제7 시점까지의 구간(t4~t7)동안, 가속기의 복수의 처리부들 (PE11~PE44)은 사전 정렬부로부터 정렬된 가수들을 수신하고, 정렬된 가수들에 대한 누적 연산을 수행할 수 있다. 복수의 처리부들(PE11~PE44)에 의한 누적 연산이 완료된 이후에, 제7 시점으로부터 제8 시점까지의 구 간(t7~t8)동안, 정규화부는 복수의 처리부들(PE11~PE44)로부터 부분합을 수신하고, 수신된 부분합들을 누 적하고, 누적된 부분합들에 대한 정규화를 수행할 수 있다. 제8 시점으로부터 제9 시점들까지의 구간(t8~t9)동안, 가속기의 사전 정렬부는 제N+1 내지 제2N 데이 터(DT_N+1~DT_2N)를 통합 버퍼부로부터 로드할 수 있다. 제N+1 내지 제2N 데이터(DT_N+1~DT_2N)가 모두 로드된 이후에, 제9 시점으로부터 제10 시점까지의 구간(t9~t10)동안, 가속기의 사전 정렬부는 제N+1 내지 2N 데이터(DT_N+1~DT_2N)의 지수들 중 최대 지수(emax2)를 탐색할 수 있다. 이후에, 제10 시점으로부터 제 11 시점까지의 구간(t10~t11)동안, 가속기의 사전 정렬부는 제N+1 내지 제2N 데이터(DT_N+1~DT_2N) 를 다시 로드할 수 있다. 제11 시점으로부터 제14 시점까지의 구간(t11~t14)동안, 가속기의 사전 정렬부 는, 최대 지수(emax2)를 기반으로, 제N+1 내지 제2N 데이터(DT_N+1~DT_2N) 각각의 가수에 대한 비트 시프트 동작을 수행하여, 정렬된 가수들을 생성할 수 있다. 제12 시점으로부터 제15 시점까지의 구간(t12~t15)동안, 가 속기의 복수의 처리부들(PE11~PE44)은 사전 정렬부로부터 정렬된 가수들을 수신하고, 정렬된 가수들 에 대한 누적 연산을 수행할 수 있다. 복수의 처리부들(PE11~PE44)에 의한 누적 연산이 완료된 이후에, 제15 시 점으로부터 제16 시점까지의 구간(t15~t16)동안, 정규화부는 복수의 처리부들(PE11~PE44)로부터 부분합을 수신하고, 수신된 부분합들을 누적하고, 누적된 부분합들에 대한 정규화를 수행할 수 있다. 상술된 바와 같이, 가속기는 N개의 데이터에 대한 인공지능 연산을 동시에 또는 병렬적으로 수행할 수 있 다. 따라서, N개의 데이터의 최대 지수를 기반으로, N개의 데이터에 대한 지수 정렬을 일괄적으로 수행한다. 이 경우, 지수 정렬로 인해, N개의 데이터의 가수에 대응하는 비트 사이즈가 증가할 수 있으며, 이는 하드웨어 또 는 리소스 제한으로 인한, 가수의 유효 값들의 누락을 유발할 수 있다. 이에 따라, 연산 오류가 반영된 상태로 인공지능 연산이 수행되므로, 전반적인 연산 신뢰성이 하락할 수 있다. 또한, 인공지능 연산이 요구되는 데이터가 N개 이상인 경우, 가속기는 N개의 데이터 단위로 인공지능 연산 을 수행한다. 이 경우, 출력 데이터에 대한 정규화 횟수가 증가하게 되고, 이로 인해 연산 신뢰성이 하락할 수 있다. 또한, 가속기가 N개의 데이터 전체에 대해서 최대 지수(emax)를 탐색해야 하므로, 가속기의 사전 정렬 부는 최대 지수(emax) 탐색을 위해, N개의 데이터 전체를 로드해야 한다. 이에 따라, 데이터 로드로 인한 성능 저하가 유발될 수 있다. 상술된 바와 같이, 가속기의 하드웨어 구조에 따라 미리 정해진 단위로 인공 지능 연산이 수행되는 경우, 전체적인 연산 신뢰성 및 성능 저하가 발생할 수 있다. 도 7은 도 1의 가속기를 보여주는 블록도이다. 설명의 편의를 위해, 중복된 구성 요소들에 대한 상세한 설명은 생략된다. 도 1 및 도 7을 참조하면, 가속기(120-1)는 범용 버퍼부(121-1), 사전 정렬부(122-1), 정규화부(123- 1), 및 복수의 처리부들(PE11~PE44)을 포함할 수 있다. 범용 버퍼부(121-1)는 가속기(120-1)에서 수행될 인공지능 연산을 위한 다양한 데이터, 가중치, 또는 파라미터 를 저장하도록 구성될 수 있다. 일 실시 예에서, 범용 버퍼부(121-1)에 저장된 정보는 메모리로부터 제공 되거나 또는 가속기(120-1)의 복수의 처리부들(PE11~PE44)에 의해 연산될 결과로부터 획득될 수 있다. 사전 정렬부(122-1)는 범용 버퍼부(121-1)로부터 제공된 데이터에 대한 지수 정렬을 수행하도록 구성될 수 있다. 예를 들어, 도 3 내지 도 6을 참조하여 설명된 실시 예에서, 사전 정렬부는 동시에 또는 병렬적으로 연산 가능한 N개의 데이터에 대한 최대 지수(emax)를 탐색하고, 탐색된 최대 지수(emax)를 기반으로 N개의 데이터에 대한 비트 시프트 동작을 수행한다. 반면에, 도 7의 사전 정렬부(122-1)는 K개의 데이터에 대한 최대 지수를 탐색하고, 탐색된 최대 지수(emax_new)와 이전의 최대 지수(emax_old)를 비교하고, 비교 결과를 기반으로 K개의 데이터에 대한 비트 시프트 동작을 수행할 수 있다. 이 때, K는 N보다 작은 자연수이다. 즉, 사전 정렬부(122-1)는 데이터의 개수와 무관하게, 최대 지수 를 탐색하고, 비트 시프트 동작을 수행할 수 있기 때문에, 최대 지수를 탐색하기 위해 요구되는 시간이 단축될 수 있다. 복수의 처리부들(PE11~PE44)은 사전 정렬부로부터 입력된 데이터에 대한 연산을 수행할 수 있다. 이 때, 복수의 처리부들(PE11~PE44) 각각은 입력된 데이터에 대한 곱셈 연산 또는 누적 연산을 수행하여, 부분 합 (PSUM)을 생성할 수 있다. 생성된 부분 합(PSUM)은 정규화부로 제공될 수 있다. 일 실시 예에서, 복수의 처리부들(PE11~PE44) 각각은 사전 정렬부(122-1)로부터 최대 지수 차이(△emax)를 수신 할 수 있다. 최대 지수 차이(△emax)는 현재 누적되는 데이터의 최대 지수(즉, emax_new) 및 이전에 누적된 데이터 의 최대 지수(즉, emax_old) 사이의 차이를 가리킨다. 복수의 처리부들(PE11~PE44) 각각은 누적 연산의 결과를 저 장하도록 구성된 누적 레지스터를 포함할 수 있다. 누적 레지스터에 저장된 누적 값은 이전 최대 지수(emax_old)에 대응하는 값을 저장할 수 있다. 따라서, 현재 입력되는 데이터(즉, 현재 최대 지수(emax_new)를 기반으로 정렬된 가수)와 누적 레지스터에 저장된 누적 값을 더하기 위해서는, 누적 레지스터에 저장된 누적 값을 현재 최대 지 수(emax_new)에 정렬시켜야 할 것이다. 따라서, 복수의 처리부들(PE11~PE44) 각각은 최대 지수 차이(△emax)를 기 반으로 누적 레지스터에 저장된 누적 값에 대한 비트 시프트 동작을 수행할 수 있다. 복수의 처리부들 (PE11~PE44)의 구조 및 동작은 이하의 도면을 참조하여 더욱 상세하게 설명된다. 정규화부(123-1)는 복수의 처리부들(PE11~PE44) 각각으로부터 부분합(PSUM)을 수신하고, 수신된 부분합들(PSU M)의 누적 값을 연산하고, 연산된 누적 값에 대한 정규화를 수행하여 출력 값을 생성할 수 있다. 예를 들어, 정규화부(123-1)는 최대 지수(emax)를 기반으로 정규복수의 처리부들(PE11~PE44) 각각으로부터 수신 된 부분합(PSUM)을 변환하도록 구성될 수 있다. 정규화부(123-1)는 변환된 부분합들을 누적 또는 조합하여 최종 출력값을 생성할 수 있다. 출력 값은 범용 버퍼부(121-1)에 저장될 수 있고, 다른 인공지능 연산의 입력 값을 사용될 수 있다. 일 실시 예에서, 정규화부(123-1)는 부분합을 부동 소수점 타입으로 변환하도록 구성된 변환기 및 부동 소수점 타입으로 변환된 부분 합들을 누적하도록 구성된 누적기를 포함할 수 있다. 그러나 본 발명의 범위가 이에 한정 되는 것은 아니다. 도 8은 도 7의 가속기의 동작을 보여주는 순서도이다. 도 7 및 도 8을 참조하면, S110 단계에서, 가속기(120- 1)는 K개의 데이터를 로드할 수 있다. 예를 들어, 앞서 설명된 바와 같이, 가속기는 N개의 데이터에 대한 인공지능 연산을 동시에 또는 병렬적으로 수행할 수 있다. 반면에, 가속기(120-1)는 N개보다 작은 K개의 데이터 를 범용 버퍼부(121-1) 또는 메모리로부터 로드할 수 있다. S120 단계에서, 가속기(120-1)는 K개의 데이터에 대한 최대 지수(emax_new)를 탐색할 수 있다. 설명의 편의를 위 해, K개의 데이터에 대한 최대 지수는 새로운 최대 지수(emax_new)라 칭한다. S130 단계에서, 가속기(120-1)는 새로운 최대 지수(emax_new)가 이전 최대 지수(emax_old)보다 큰지 판별할 수 있다. 예를 들어, 가속기(120-1)의 사전 정렬부(122-1)는 이전 인공지능 연산을 위해 사용 또는 변환된 데이터의 최대 지수(이하에서, 이전 최대 지수(emax_old)라 칭함.)에 대한 정보를 포함할 수 있다. 즉, 이전 인공지능 연산에서 사용된 데이터는 이전 최대 지수(emax_old)를 기반으로 지수 정렬된다. 이 경우, 복수의 처리부들(PE11~PE44) 각 각에 누적된 값 또한 이전 최대 지수(emax_old)에 대응할 것이다. 따라서, 새로운 최대 지수(emax_new)가 이전 최대 지수(emax_old)보다 크지 않은 경우, 이전 최대 지수(emax_old)를 기 반으로 K개의 데이터에 대한 지수 정렬이 수행되더라도, 복수의 처리부들(PE11~PE44)에서 누적 연산이 정상적으 로 수행될 수 있다. 즉, 새로운 최대 지수(emax_new)가 이전 최대 지수(emax_old)보다 크지 않은 경우, S140 단계에 서, 가속기(120-1)의 사전 정렬부(122-1)는 이전 최대 지수(emax_old)를 기반으로 K개의 데이터에 대한 지수 정렬을 수행하여 정렬된 가수들을 생성할 수 있다. 반면에, 새로운 최대 지수(emax_new)가 이전 최대 지수(emax_old)보다 큰 경우, 복수의 처리부들(PE1~PE44) 각각에 누적된 값에 대한 비트 시프트가 요구된다. 이에 따라, 새로운 최대 지수(emax_new)가 이전 최대 지수(emax_old)보다 큰 경우, S150 단계에서, 가속기(120-1)는 최대 지수 차이(△emax)를 기반으로, 복수의 가속기들(PE11~PE44)에 누적 값에 대한 비트 시프트 동작을 수행하여 정렬된 누적 값을 생성할 수 있다. 이 때, 최대 지수 차이(△ema x)는 새로운 최대 지수(emax_new) 및 이전 최대 지수(emax_old) 사이의 차이를 가리킬 수 있다. 이후에, S160 단계에서, 가속기(120-1)는 새로운 최대 지수(emax_new)를 기반으로 이전 최대 지수(emax_old)를 갱신 할 수 있다. 이후에, 가속기(120-1)는 S140 단계의 동작을 수행한다. 이 경우, K개의 데이터의 가수들에 대하여, 갱신된 이전 최대 지수(즉, 새로운 최대 지수(emax_new))를 기반으로 비트 시프트 동작이 수행될 것이다. S170 단계에서, 가속기(120-1)는 복수의 처리부들(PE11~PE44)을 사용하여 정렬된 가수들에 대한 누적 연산을 수 행하여, 부분합을 생성할 수 있다. 일 실시 예에서, 정렬된 가수들에 대한 누적 연산은 정렬된 가수들 및 이전 누적 값에 대한 덧셈 연산을 통해 수행될 수 있다. 일 실시 예에서, 정렬된 가수들 및 이전 누적 값(또는 정렬 된 누적 값)은 동일한 최대 지수에 대응하므로, 이에 대한 덧셈 동작은 정수 타입의 덧셈을 통해 구현될 수 있 다. S180 단계에서, 가속기(120-1)는 모든 데이터에 대한 인공지능 연산이 완료되었는지 판별할 수 있다. 모든 데이 터에 대한 인공지능 연산이 완료되지 않은 경우(즉, 인공지능 연산이 수행될 데이터가 남은 경우), 가속기(120- 1)는 S110 단계 내지 S170 단계의 동작들을 다시 수행할 수 있다. 모든 데이터에 대한 인공지능 연산이 완료된 경우, S190 단계에서, 가속기(120-1)는 복수의 처리부들 (PE11~PE44) 각각의 부분합(PSUM)을 누적하고, 누적 결과를 정규화할 수 있다. 상술된 바와 같이, 본 발명의 실시 예에 따른 가속기(120-1)는 부동 소수점 타입의 복수의 데이터에 대한 누적 연산을 수행할 수 있다. 이 때, 가속기(120-1)는 복수의 데이터에 대한 새로운 최대 지수(emax_new) 및 이전 최대 지수(emax_old)를 기반으로 복수의 데이터 및 누적 값에 대한 비트 시프트 동작을 수행할 수 있다. 이 경우, 비트 시프트로 인한 유효 값의 손실이 감소될 수 있기 때문에, 연산 결과의 오차가 감소될 수 있다. 또한, 동시에 또 는 병렬적으로 연산 가능한 모든 데이터를 로드할 필요없이, 순차적으로 입력되는 데이터에 대해 최대 지수 탐 색 및 비트 시프트가 수행될 수 있기 때문에, 연산 속도가 향상될 수 있다. 또한, 누적 연산 연산 과정에서 정 규화가 1회만 수행되기 때문에, 정규화로 인한 오차가 감소될 수 있다. 따라서, 향상된 신뢰성 및 성능을 갖는 가속기가 제공된다. 도 9는 도 7의 사전 정렬부를 보여주는 블록도이다. 도 10은 도 9의 최대 지수 탐색기의 구조를 설명하기 위한 도면이다. 설명의 편의를 위해, 앞서 설명된 구성 요소들에 대한 상세한 설명은 생략된다. 도 7 및 도 9를 참조 하면, 사전 정렬부(122-1)는 최대 지수 관리자(MEM) 및 복수의 변환기들(CVT1~CVTk)을 포함할 수 있다. 최대 지수 관리자(MEM)는 현재 연산될 K개의 데이터(K DT)에 대한 새로운 최대 지수(emax_new)를 탐색하고, 새로 운 최대 지수(emax_new) 및 이전 최대 지수(emax_old)를 비교하고, 비교 결과를 기반으로, 최대 지수(emax) 및 최대 지수 차이(△emax)를 출력할 수 있다. 예를 들어, 최대 지수 관리자(MEM)의 최대 지수 탐색기(FD), 최대 지수 판 별기(DET), 이전 최대 지수 저장소(STR), 및 최대 지수 뺄셈기(SUB)를 포함할 수 있다. 최대 지수 탐색기(FD)는 K개의 데이터의 지수들을 비교하고, 비교 결과를 기반으로, 새로운 최대 지수(emax_new)를 탐색할 수 있다. 예를 들어, 도 10에 도시된 바와 같이, 최대 지수 탐색기(FD)는 복수의 비교기들을 포함할 수 있다. 복수의 비교기들은 트리 구조로 연결될 수 있으며, 복수의 지수들을 서로 비교하여 새로운 최대 지수 (emax_new)를 출력하도록 구성될 수 있다. 최대 지수 판별기(DET)는 최대 지수 탐색기(FD)로부터 새로운 최대 지수(emax_new)를 수신하고, 이전 최대 지수 저장소(STR)로부터 이전 최대 지수(emax_old)를 수신할 수 있다. 최대 지수 판별기(DET)는 새로운 최대 지수 (emax_new)가 이전 최대 지수(emax_old)보다 큰지 판별할 수 있다. 새로운 최대 지수(emax_new)가 이전 최대 지수 (emax_old)보다 큰 경우, 최대 지수 판별기(DET)는 새로운 최대 지수(emax_new)를 최대 지수(emax)로서 출력할 수 있다. 새로운 최대 지수(emax_new)가 이전 최대 지수(emax_old)보다 크지 않은 경우, 최대 지수 판별기(DET)는 이전 최 대 지수(emax_old)를 최대 지수(emax)로서 출력할 수 있다. 최대 지수(emax)는 복수의 변환기들(CVT1~CVTk) 각각으 로 제공된다. 최대 지수 뺄셈기(SUB)는 최대 지수 탐색기(FD)로부터 새로운 최대 지수(emax_new)를 수신하고, 이전 최대 지수 저장소(STR)로부터 이전 최대 지수(emax_old)를 수신하고, 새로운 최대 지수(emax_new) 및 이전 최대 지수(emax_old)를 기반으로 최대 지수 차이(△emax)를 출력할 수 있다. 예를 들어, 새로운 최대 지수(emax_new)가 이전 최대 지수 (emax_old)보다 큰 경우, 최대 지수 뺄셈기(SUB)는 새로운 최대 지수(emax_new) 및 이전 최대 지수(emax_old)의 차이인 최대 지수 차이(△emax)를 출력할 수 있다. 새로운 최대 지수(emax_new)가 이전 최대 지수(emax_old)보다 크지 않은 경우, 최대 지수 뺄셈기(SUB)는 최대 지수 차이(△emax)를 0으로 출력할 수 있다. 복수의 변환기들(CVT1~CVTk)은 최대 지수(emax)를 기반으로 복수의 데이터(DT_1~DT_K) 각각에 대한 비트 시프트 동작을 수행하여, 정렬된 가수들(sM1~sMK)을 생성할 수 있다. 복수의 변환기들(CVT1~CVTk)의 동작은 앞서 설명 된 바와 유사하므로, 이에 대한 상세한 설명은 생략된다. 도 11은 도 7의 복수의 처리부들 중 하나의 처리부를 보여주는 블록도이다. 본 발명의 실시 예들을 용이하게 설 명하기 위해, 도 11에서 처리부(PE)의 일부 구성만 도시된다. 그러나 본 발명의 범위가 이에 한정되는 것은 아 니며, 처리부(PE)는 다른 다양한 구성 요소들을 더 포함할 수 있다. 도 7 및 도 11을 참조하면, 처리부(PE)는 덧셈기(ADD), 누적 레지스터(AR), 비트 시프터(BSHF), 및 스톨 제어 회로(STC)를 포함할 수 있다. 덧셈기(ADD)는 사전 정렬부(122-1)로부터 정렬된 가수(sM)를 수신할 수 있고, 누 적 레지스터(AR)로부터 누적 값을 수신할 수 있다. 덧셈기(ADD)는 정렬된 가수(sM) 및 누적 값에 대한 누적 연 산을 수행하여, 부분합(PSUM)을 생성할 수 있다. 부분 합(PSUM)은 누적 레지스터(AR)에 저장되어, 다음 누적 연 산 연산의 누적 값으로 사용될 수 있다. 또는, 부분 합(PSUM)은 다른 처리부로 제공될 수 있다. 또는, 부분 합 (PSUM)은 정규화부(123-1)로 제공될 수 있다. 비트 시프터(BSHF)는 사전 정렬부(122-1)로부터 최대 지수 차이(△emax)를 수신할 수 있다. 비트 시프터(BSHF)는 최대 지수 차이(△emax)를 기반으로 누적 레지스터(AR)에 저장된 누적 값에 대한 비트 시프트 동작을 수행할 수 있다. 예를 들어, 누적 레지스터(AR)에 저장된 누적 값은 이전 최대 지수(emax_old)에 대응할 수 있다. 최대 지수 (emax)가 변경된 경우(즉, 새로운 최대 지수(emax_new)가 이전 최대 지수(emax_old)보다 큰 경우), 정렬된 가수(sM)는 새로운 최대 지수(emax_new)에 대응할 것이다. 이 경우, 덧셈기(ADD)의 정상적인 동작을 위해서는, 누적 레지스터 (AR)에 저장된 누적 값을 새로운 최대 지수(emax_new)에 맞도록 정렬시켜야 한다. 따라서, 비트 시프터(BSHF)는 새로운 최대 지수(emax_new) 및 이전 최대 지수(emax_old)의 차이인 최대 지수 차이(△emax)만큼 누적 레지스터(AR)의 누적 값에 대한 비트 시프트 동작을 수행할 수 있다. 이 경우, 누적 레지스터(AR)의 정렬된 누적 값(즉, 비트 시프트된 누적 값)은 새로운 최대 지수(emax_new)에 대응하고, 덧셈기(ADD)는 정렬된 가수(sM) 및 누적 값에 대한 누적 연산을 정상적으로 수행할 수 있다. 일 실시 예에서, 덧셈기(ADD)는 정수 타입 덧셈기 또는 정수 덧셈기일 수 있다. 일 실시 예에서, 비트 시프터(BSHF)는 누적 레지스터(AR)에 대한 비트 시프트 동작을 클럭 신호에 동기하여 1- 비트씩 수행할 수 있다. 예를 들어, 최대 지수 차이(△emax)가 3인 경우, 누적 레지스터(AR)에 대한 비트 시프트 동작은 동작 클럭의 3주기동안 수행될 수 있다. 따라서, 누적 레지스터(AR)에 대한 비트 시프트 동작이 완료될 때까지 정렬된 가수(sM)가 덧셈기(ADD)로 입력되지 않도록, 스톨 제어 회로(STC)는 정렬된 가수(sM)의 덧셈기 (ADD)로의 입력을 제어할 수 있다. 도 12는 도 7의 가속기의 동작을 보여주는 타이밍도이다. 도 7 및 도 12를 참조하면, 가속기(120-1)는 제1 내지 제2N 데이터(DT_1~DT_2N)에 대한 인공지능 연산을 수행할 수 있다. 가속기(120-1)의 사전 정렬부(122-1)는 제1 내지 제2N 데이터(DT_1~DT_2N)를 순차적으로 로드하면서, 최대 지수 (emax)를 탐색하고, 탐색된 최대 지수(emax)를 기반으로, 제1 내지 제2N 데이터(DT_1~DT_2N)에 대한 비트 시프트 동작을 수행할 수 있다. 예를 들어, 사전 정렬부(122-1)는 제1 및 제2 데이터(DT_1, DT_2)를 로드하고, 제1 및제2 데이터(DT_1, DT_2)의 최대 지수(emax)를 탐색하고, 탐색된 최대 지수(emax)를 기반으로 제1 및 제2 데이터 (DT_1, DT_2)에 대한 비트 시프트 동작을 수행할 수 있다. 이 후에, 사전 정렬부(122-1)는 제3 데이터(DT_3)를 로드하고, 최대 지수(emax)를 탐색하고, 제3 데이터(DT_3)에 대한 비트 시프트 동작을 수행할 수 있다. 비트 시 프트 동작의 결과(즉, 정렬된 가수들)은 처리부들(PE)로 제공된다. 처리부들(PE)은 사전 정렬부(122-1)로부터 정렬된 가수들을 수신하고, 정렬된 가수들에 대한 덧셈 연산을 수행할 수 있다. 이 때, 사전 정렬부(122-1)의 최대 지수(emax) 탐색 과정에서, 새로운 최대 지수(emax_new)가 이전 최대 지수 (emax_old)보다 클 수 있다. 이 경우, 처리부들(PE)은 최대 지수 차이(△emax)를 기반으로, 누적 레지스터(AR)의 누적 값들에 대한 비트 시프트 동작을 수행할 수 있다. 처리부(PE)에서 비트 시프트 동작이 수행되는 동안, 스 톨 제어 회로(STC)에 의해 데이터 입력이 중지될 수 있다. 상술된 동작이 순차적으로 수행됨에 따라, 가속기(120-1)는 제1 내지 제2N 데이터(DT_1~DT_2N)에 대한 누적 연 산을 완료할 수 있다. 제1 내지 제2N 데이터(DT_1~DT_2N)에 대한 누적 연산이 모두 완료된 경우, 가속기(120- 1)의 정규화부(123-1)는 처리부(PE)의 부분합들에 대한 정규화(NML)를 수행할 수 있다. 도 13은 도 3의 가속기에 의한 동작을 설명하기 위한 도면이다. 도 14a 내지 도 14b는 도 7의 가속기에 의한 동 작을 설명하기 위한 도면들이다. 설명의 편의를 위해, 가속기(120 또는 120-1)는 제1 내지 제8 데이터에 대한 누적 연산을 수행하는 것으로 가정한다. 이 때, 제1 내지 제8 데이터(DT1~DT8)는 제1 내지 제8 가수들(M1~M8)을 각각 포함할 수 있고, 제1 데이터(DT1)의 지수는 -5이고, 제2 데이터(DT1)의 지수는 -4이고, 제3 데이터(DT1)의 지수는 -3이고, 제4 데이터(DT1)의 지수는 -2이고, 제5 데이터(DT1)의 지수는 -4이고, 제6 데이터(DT1)의 지수 는 -2이고, 제7 데이터(DT1)의 지수는 -1이고, 제8 데이터(DT1)의 지수는 -1인 것으로 가정한다. 일 실시 예에서, 연산될 데이터의 가수를 저장하도록 구성된 비트 시프트 레지스터는 가수의 크기에 대응하는 것으로 가정한다. 즉, 가수에 대한 비트 시프트가 수행된 경우, 비트 시프트된 크기에 대응하는 유효 값에 대한 손실이 발생할 수 있다. 먼저, 도 3 및 도 13을 참조하면, 가속기는 제1 내지 제8 데이터(DT_1~DT_8)에 대한 누적 연산을 수행할 수 있다. 예를 들어, 가속기의 사전 정렬부는 제1 내지 제8 데이터(DT_1~DT_8)의 지수들 중 최대 지 수(emax)를 탐색할 수 있다. 이 경우, 최대 지수(emax)는 -1일 것이다. 가속기의 사전 정렬부는 탐색된 최대 지수(emax)(즉, -1)를 기반으로, 제1 내지 제8 데이터 (DT_1~DT_8)의 가수들(M1~M8)에 대한 비트 시프트 동작을 수행할 수 있다. 일 예로서, 제1 데이터(DT_1)의 지수 는 -5이므로, 제1 가수(M1)는 4만큼 비트 시프트될 수 있다. 마찬가지로, 제2 내지 제6 데이터(DT_2~DT_6)의 지 수들은 각각 -4, -3, -2, -4, 및 -1이므로, 제2 내지 제6 가수들(M2~M6)은 각각 3, 2, 1, 3, 및 1만큼 비트 시 프트될 수 있다. 상술된 제1 내지 제6 가수들(M1~M6)에 대한 비트 시프트로 인해, 각 가수에 대한 유효 값의 손실(도 13에서 음 영으로 표시됨)이 발생할 수 있다. 이러한 유효 값의 손실은 누적 연산의 결과에 대한 신뢰성 저하를 유발한다. 다음으로, 도 7, 도 14a, 도 14b, 및 도 14c를 참조하면, 가속기(120-1)는 제1 내지 제8 데이터(DT_1~DT_8)에 대한 누적 연산을 수행할 수 있다. 예를 들어, 도 14a에 도시된 바와 같이, 가속기(120-1)의 사전 정렬부(122- 1)는 제1 및 제2 데이터(DT_1, DT_2)에 대한 비트 시프트 동작을 수행할 수 있다. 제1 및 제2 데이터(DT_1, DT_2)의 최대 지수(emax_new)는 -4이므로, 제1 데이터(DT_1)의 제1 가수(M1)는 1만큼 비트 시프트된다. 가속기 (120-1)는 비트 시프트된 제1 가수(M1) 및 제2 가수(M2)에 대한 누적 연산을 수행하여, 제1 누적 값(sum_1)을 생성한다. 제1 누적 값(sum_1)은 복수의 처리부들(PE11~PE44) 중 적어도 하나의 누적 레지스터(AR)에 저장될 수 있다. 이후에, 도 14b에 도시된 바와 같이, 가속기(120-1)는 제3 및 제4 데이터(DT_3, DT_4)에 대한 누적 연산을 더 수행할 수 있다. 예를 들어, 가속기(120-1)는 제1 및 제2 데이터(DT_1, DT_2)의 누적 연산에 대한 결과로서, 제 1 누적 값(sum_1) 및 이전 최대 지수(emax_old=-4)에 대한 정보를 저장할 수 있다. 가속기(120-1)는 이전 최대 지 수(emax_old=-4)를 기반으로 제3 및 제4 데이터(DT_3, DT_4)에 대한 비트 시프트 동작을 수행할 수 있다. 즉, 제3 및 제4 데이터(DT_3, DT_4)의 최대 지수(emax_new)는 -2이고, 이전 최대 지수(emax_old)는 -4이므로, 제3 데이터 (DT_3)의 제3 가수(M3)는 1만큼 비트 시프트된다. 최대 지수 차이(△emax)는 2이므로, 제1 누적 값(sum_1)은 2만큼 비트 시프트된다. 가속기(120-1)는 비트 시프트된 제1 누적 값(sum_1), 비트 시프트된 제3 가수(M3), 및 제4 가수(M3)에 대한 누적 연산을 수행하여, 제2 누적 값(sum_2)을 생성한다. 제2 누적 값(sum_2)은 복수의 처리부 들(PE11~PE44) 중 적어도 하나의 누적 레지스터(AR)에 저장될 수 있다. 이후에, 도 14c에 도시된 바와 같이, 가속기(120-1)는 제5 내지 제8 데이터(DT_5~DT_8)에 대한 누적 연산을 수 행할 수 있다. 예를 들어, 가속기(120-1)는 제1 내지 제4 데이터(DT_1~DT_4)의 누적 연산에 대한 결과로서, 제2 누적 값(sum_2) 및 이전 최대 지수(emax_old=-2)에 대한 정보를 저장할 수 있다. 가속기(120-1)는 이전 최대 지수(emax_old=-2)를 기반으로 제5 내지 제8 데이터(DT_5~DT_8)에 대한 비트 시프트 동작을 수행할 수 있다. 즉, 제5 내지 제8 데이터(DT_5~DT_8)의 최대 지수(emax_new)는 -1이고, 이전 최대 지수 (emax_old)는 -2이므로, 제5 데이터(DT_5)의 제5 가수(M5)는 4만큼 비트 시프트되고, 제6 데이터(DT_6)의 제6 가 수(M6)는 1만큼 비트 시프트된다. 최대 지수 차이(△emax)는 1이므로, 제2 누적 값(sum_2)은 1만큼 비트 시프트 된다. 가속기(120-1)는 비트 시프트된 제2 누적 값(sum_2), 비트 시프트된 제5 가수(M5), 비트 시프트된 제6 가 수(M6), 제7 가수(M7), 및 제8 가수(M8)에 대한 누적 연산을 수행하여, 제3 누적 값(sum_3)을 생성한다. 제3 누 적 값(sum_3)은 복수의 처리부들(PE11~PE44) 중 적어도 하나의 누적 레지스터(AR)에 저장될 수 있다. 일 실시 예에서, 제1 내지 제8 데이터(DT_1~DT_8)에 대한 누적 연산이 모두 완료되었으므로, 가속기(120-1)는 누적 연산의 결과, 즉, 제3 누적 값(sum_3) 및 최대 지수(emax=-1)에 대해 정규화를 수행하여, 최종 결과(즉, SUM' 및 e_p)를 생성할 수 있다. 일 실시 예에서, 도 14a에서 제1 가수(M1)에 대해 1만큼 비트 시프트가 수행되었으므로, 제1 가수(M1)에 대해 1 비트의 유효 값에 대한 손실이 발생한다. 도 14b에서, 제3 가수(M3)에 대해 1만큼 비트 시프트가 수행되었으며, 제3 가수(M3)에 대해, 1비트의 유효 값에 대한 손실이 발생한다. 제1 가수(M1) 및 제3 가수(M3)에 대한 손실은 도 13의 실시 예와 비교하여 상대적으로 작은 손실이다. 비록 누적 값에 대한 비트 시프트가 수행되므로, 이에 따른 손실이 발생할 수 있으나, 누적 값에 대한 손실은 피연산자에 대한 직접적인 손실과 비교하면, 상대적으로 더 작은 오차를 갖기 때문에, 도 14a 내지 도 14c의 실시 예는 도 13의 실시 예와 비교하여 누적 연산 결과의 오차를 감소시킨다. 상술된 바와 같이, 본 발명의 실시 예들에 따르면, 가속기는 다양한 연산을 수행하여 인공지능 모델을 생성, 학 습, 또는 추론하도록 구성될 수 있다. 이 때, 가속기는 부동 소수점 타입을 갖는 다수의 데이터에 대한 누적 연 산을 수행할 수 있다. 가속기는 복수의 데이터에 대한 새로운 최대 지수를 탐색하고, 새로운 최대 지수 및 이전 최대 지수를 기반으로, 복수의 데이터 및 현재까지 누적된 누적 값에 대한 비트 시프트 동작을 수행할 수 있다. 이 경우, 피연산자의 비트 시프트 동작으로 인한 손실이 감소될 수 있으며, 다수의 데이터에 대한 누적 연산시 1회의 정규화만 수행되므로, 연산 결과의 신뢰성이 향상될 수 있다. 도 15는 도 7의 가속기의 동작을 보여주는 순서도이다. 설명의 편의를 위해, 중복된 내용에 대한 상세한 설명은 생략된다. 도 7 및 도 15를 참조하면, 가속기(120-1)는 S210 단계의 동작을 수행할 수 있다. S210 단계의 동작은 도 8의 S110 단계와 유사하므로, 이에 대한 상세한 설명은 생략된다. S220 단계에서, 가속기(120-1)는 K개의 데이터의 최소 지수(emin)를 탐색할 수 있다. 예를 들어, 도 7 내지 도 14c를 참조하여 설명된 실시 예에서, 가속기(120-1)의 사전 정렬부(122-1)는 K개의 데이터의 최대 지수(emax)를 탐색한다. 그러나 본 발명의 범위가 이에 한정되는 것은 아니며, 가속기(120-1)의 사전 정렬부(122-1)는 K개의 최소 지수(emin)를 탐색할 수 있다. S230 단계에서, 가속기(120-1)는 새로운 최소 지수(emin_new)가 이전 최소 지수(emin_old)보다 작은지 판별할 수 있 다. 새로운 최소 지수(emin_new)가 이전 최소 지수(emin_old)보다 작지 않은 경우, S240 단계에서, 가속기(120-1)는 이전 최소 지수(emin_old)를 기반으로 K개의 데이터에 대한 지수 정렬을 수행하여 정렬된 가수들을 생성할 수 있다. 새로운 최소 지수(emin_new)가 이전 최소 지수(emin_old)보다 작은 경우, S250 단계에서, 가속기(120-1)는 최소 지수 차이(△emin)를 기반으로 복수의 가속기들(PE11~PE44)에 누적 값에 대한 비트 시프트 동작을 수행할 수 있다.이 때, 최소 지수 차이(△emin)는 새로운 최소 지수(emin_new) 및 이전 최소 지수(emin_old) 사이의 차이를 가리킬 수 있다. 이후에, S260 단계에서, 가속기(120-1)는 새로운 최소 지수(emin_new)를 기반으로 이전 최소 지수(emin_old)를 갱신 할 수 있다. 이후에, 가속기(120-1)는 S240 단계의 동작을 수행한다. 이 경우, K개의 데이터의 가수들에 대하여, 갱신된 이전 최소 지수(즉, 새로운 최대 지수(emin_new))를 기반으로 비트 시프트 동작이 수행될 것이다. 이후에, 가속기(120-1)는 S270 단계 내지 S290 단계의 동작들을 수행하며, 이는 도 8의 S170 단계 내지 S190 단 계의 동작들과 유사하므로, 이에 대한 상세한 설명은 생략된다. 상술된 바와 같이, 가속기(120-1)는 복수의 데이터에 대한 누적 연산을 수행하기 위해, K개의 데이터에 대한 지 수 정렬을 수행할 수 있다. 이 때, 가속기(120-1)는 최대 지수 또는 최소 지수를 기반으로 지수 정렬을 수행할 수 있다. 그러나 본 발명의 범위가 이에 한정되는 것은 아니다. 예를 들어, 가속기(120-1)는 복수의 데이터 또 는 K개의 데이터의 지수들의 절대값들 중 최대값 또는 최소값을 기반으로 지수 정렬을 수행할 수 있다. 도 16은 본 발명의 실시 예에 따른 시스템을 보여주는 블록도이다. 도 16을 참조하면, 시스템은 메모리 , 제1 가속기, 제2 가속기, 및 컨트롤러를 포함할 수 있다. 메모리 및 컨트롤 러는 도 1을 참조하여 설명된 바와 유사하므로, 이에 대한 상세한 설명은 생략된다. 시스템은 인공지능 모델의 처리를 수행하도록 구성된 전용 하드웨어일 수 있다. 일 실시 예에서, 시스템 의 제1 가속기 및 제2 가속기는 대형 인공지능 모델을 처리하기 위해, 병렬적으로 연산을 수 행할 수 있다. 예를 들어, 제1 가속기 및 제2 가속기는 데이터 병렬화(data parallelism), 모델 병렬화(model parallelism), 또는 텐서 병렬화(tensor parallelism)를 통해 대형 인공 지능 모델을 처리할 수 있다. 일 실시 예에서, 제1 가속기 및 제2 가속기는 도 1 내지 도 15를 참조하여 설명된 동작 방법 또는 연산 방법을 기반으로 동작할 수 있다. 상술된 내용은 본 발명을 실시하기 위한 구체적인 실시 예들이다. 본 발명은 상술된 실시 예들뿐만 아니라, 단 순하게 설계 변경되거나 용이하게 변경할 수 있는 실시 예들 또한 포함할 것이다. 또한, 본 발명은 실시 예들을 이용하여 용이하게 변형하여 실시할 수 있는 기술들도 포함될 것이다. 따라서, 본 발명의 범위는 상술된 실시 예들에 국한되어 정해져서는 안되며 후술하는 특허청구범위뿐만 아니라 이 발명의 특허청구범위와 균등한 것들 에 의해 정해져야 할 것이다.도면 도면1 도면2a 도면2b 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12 도면13 도면14a 도면14b 도면14c 도면15 도면16"}
{"patent_id": "10-2023-0128232", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 일 실시 예에 따른 시스템을 보여주는 블록도이다. 도 2a 및 도 2b는 도 1의 가속기에서 수행되는 MAC 연산을 설명하기 위한 도면들이다. 도 3은 도 1의 가속기를 보여주는 순서도이다. 도 4는 도 3의 가속기의 동작을 보여주는 순서도이다. 도 5는 도 3의 사전 정렬부를 보여주는 블록도이다. 도 6은 도 3의 가속기의 인공지능 연산을 설명하기 위한 타이밍도이다. 도 7은 도 1의 가속기를 보여주는 블록도이다. 도 8은 도 7의 가속기의 동작을 보여주는 순서도이다. 도 9는 도 7의 사전 정렬부를 보여주는 블록도이다. 도 10은 도 9의 최대 지수 탐색기의 구조를 설명하기 위한 도면이다. 도 11은 도 7의 복수의 처리부들 중 하나의 처리부를 보여주는 블록도이다. 도 12는 도 7의 가속기의 동작을 보여주는 타이밍도이다. 도 13은 도 3의 가속기에 의한 동작을 설명하기 위한 도면이다. 도 14a 내지 도 14b는 도 7의 가속기에 의한 동작을 설명하기 위한 도면들이다. 도 15는 도 1의 가속기의 동작을 보여주는 순서도이다. 도 16은 본 발명의 실시 예에 따른 시스템을 보여주는 블록도이다."}
