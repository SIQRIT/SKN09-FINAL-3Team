{"patent_id": "10-2023-0129718", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0046024", "출원번호": "10-2023-0129718", "발명의 명칭": "어셈블리어 기반 코드 보안 장치", "출원인": "주식회사 위스타테크놀로지", "발명자": "남민우"}}
{"patent_id": "10-2023-0129718", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "악성코드 여부를 탐지하고자 하는 입력 파일을 어셈블리 코드로 변환하여 명령어 코드 시퀀스를 생성하는 단계;명령어 코드 임베딩(embedding)을 위해 미리 학습된 어셈블리 언어 모델을 이용하여 상기 명령어 코드 시퀀스를임베딩하고, 상기 명령어 코드 시퀀스의 임베딩 결과를 출력하는 단계; 및상기 임베딩 결과를 입력으로 하는 미리 학습된 악성코드 분류 모델을 이용하여 악성코드 여부를 탐지하는 단계를 포함하는, 악성코드 탐지 방법."}
{"patent_id": "10-2023-0129718", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "어셈블리 언어 모델 기반 악성코드 탐지 방법 및 장치가 개시된다. 본 개시의 일 실시예에 따른 악성코드 탐지 방법은, 악성코드 여부를 탐지하고자 하는 입력 파일을 어셈블리 코드로 변환하여 명령어 코드 시퀀스를 생성하 는 단계; 명령어 코드 임베딩(embedding)을 위해 미리 학습된 어셈블리 언어 모델을 이용하여 상기 명령어 코드 시퀀스를 임베딩하고, 상기 명령어 코드 시퀀스의 임베딩 결과를 출력하는 단계; 및 상기 임베딩 결과를 입력으 로 하는 미리 학습된 악성코드 분류 모델을 이용하여 악성코드 여부를 탐지하는 단계를 포함한다. 공개특허10-2025-0046024 CPC특허분류 G06F 9/30 (2013.01)명 세 서 청구범위 청구항 1 악성코드 여부를 탐지하고자 하는 입력 파일을 어셈블리 코드로 변환하여 명령어 코드 시퀀스를 생성하는 단계; 명령어 코드 임베딩(embedding)을 위해 미리 학습된 어셈블리 언어 모델을 이용하여 상기 명령어 코드 시퀀스를 임베딩하고, 상기 명령어 코드 시퀀스의 임베딩 결과를 출력하는 단계; 및 상기 임베딩 결과를 입력으로 하는 미리 학습된 악성코드 분류 모델을 이용하여 악성코드 여부를 탐지하는 단계 를 포함하는, 악성코드 탐지 방법. 발명의 설명"}
{"patent_id": "10-2023-0129718", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 악성코드 탐지 기술에 관한 것이며, 보다 구체적으로 어셈블리 언어 모델 기반으로 악성코드를 탐지 할 수 있는 방법 및 장치에 대한 것이다."}
{"patent_id": "10-2023-0129718", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "종래의 악성코드 탐지 방법은 악성코드로 의심되는 파일에 대하여 악성코드의 특정 코드 섹션의 패턴 정보를 매 칭하여 탐지하는 시그너처(signature) 기반 탐지 방법이다. 특히, 기존 안티바이러스 탐지 기법은 악성코드가 사용하는 특정 코드 섹션의 바이트(byte) 정보를 기반으로 탐지하거나, 악성코드가 동적으로 동작하며 발생하는 각종 로그 정보(예를 들어, DLL, API 함수 호출 정보 등) 및 파일의 구조 정보를 바탕으로 악성여부를 판단하고 있어 신종 및 변종 악성코드를 탐지하는데 한계가 존재한다. 악성코드 분석을 위한 다양한 정적 기술과 동적 기술이 제안되고 있으며, 특히 최근에는 알려지지 않은 (Unknown) 파일 탐지를 위하여 AI 기술을 접목하여 악성코드 분석 및 탐지를 시도하고 있다. 악성코드의 정적/ 동적 분석 시에 발생되는 명령어(instruction) 정보를 기반으로 다양한 악성코드의 종류를 효과적으로 분석 및 탐지하기 위한 시도가 진행 중이지만 해당 기술의 정확도 및 성능의 제약으로 인하여 상용화로 이루어지기 어려 운 현실이다."}
{"patent_id": "10-2023-0129718", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시의 기술적 과제는, 어셈블리 언어 모델 기반으로 악성코드를 탐지할 수 있는 방법 및 장치를 제공하는데 그 목적이 있다. 본 개시에서 이루고자 하는 기술적 과제들은 이상에서 언급한 기술적 과제들로 제한되지 않으며, 언급하지 않은"}
{"patent_id": "10-2023-0129718", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 2, "content": "또 다른 기술적 과제들은 아래의 기재로부터 본 개시가 속하는 기술분야에서 통상의 지식을 가진 자에게 명확하 게 이해될 수 있을 것이다."}
{"patent_id": "10-2023-0129718", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시의 일 실시예에 따르면, 어셈블리 언어 모델 기반 악성코드 탐지 방법 및 장치가 개시된다. 본 개시의 일 실시예에 따른 악성코드 탐지 방법은, 악성코드 여부를 탐지하고자 하는 입력 파일을 어셈블리 코드로 변환 하여 명령어 코드 시퀀스를 생성하는 단계; 명령어 코드 임베딩(embedding)을 위해 미리 학습된 어셈블리 언어모델을 이용하여 상기 명령어 코드 시퀀스를 임베딩하고, 상기 명령어 코드 시퀀스의 임베딩 결과를 출력하는 단계; 및 상기 임베딩 결과를 입력으로 하는 미리 학습된 악성코드 분류 모델을 이용하여 악성코드 여부를 탐지 하는 단계를 포함한다. 나아가, 상기 악성코드 탐지 방법은, 명령어 코드를 정수로 인덱싱하기 위한 명령어 코드 사전을 이용하여, 상 기 명령어 코드 시퀀스에 포함된 명령어 코드를 정수로 인덱싱함으로써, 상기 명령어 코드 시퀀스에 대응하는 인덱싱된 명령어 코드 시퀀스를 생성하는 단계를 더 포함하고, 상기 임베딩 결과를 출력하는 단계는, 상기 인덱 싱된 명령어 코드 시퀀스를 임베딩하여 상기 인덱싱된 명령어 코드 시퀀스의 임베딩 결과를 출력할 수 있다. 이때, 상기 명령어 코드 시퀀스를 생성하는 단계는, 상기 명령어 코드 시퀀스를 랜덤하게 선택된 길이로 분할하 여 복수의 분할 명령어 코드 시퀀스를 생성할 수 있다. 이때, 상기 명령어 코드 시퀀스를 생성하는 단계는, 상기 복수의 분할 명령어 코드 시퀀스 각각을 개별 파일로 생성할 수 있다. 이때, 상기 명령어 코드 시퀀스를 생성하는 단계는, 상기 어셈블리 코드로부터 명령어를 추출하고, 상기 추출된 명령어의 명령코드(Opcode)와 오퍼랜드(Operand)를 조합하여 명령어 코드를 생성하며, 상기 명령어 코드를 이용 하여 상기 명령어 코드 시퀀스를 생성할 수 있다. 본 개시의 다른 실시예에 따른 악성코드 탐지 방법은, 복수의 실행 파일들 각각을 어셈블리 코드로 변환하여 명 령어 코드 시퀀스를 생성하는 단계; 상기 명령어 코드 시퀀스를 이용하여 명령어 코드 임베딩(embedding)을 위 한 어셈블리 언어 모델을 학습하는 단계; 및 상기 학습된 어셈블리 언어 모델을 기반으로 악성코드 여부를 탐지 하기 위한 악성코드 분류 모델을 학습하는 단계를 포함한다. 나아가, 상기 악성코드 탐지 방법은, 명령어 코드를 정수로 인덱싱하기 위한 명령어 코드 사전을 이용하여, 상 기 명령어 코드 시퀀스에 포함된 명령어 코드를 정수로 인덱싱함으로써, 상기 명령어 코드 시퀀스에 대응하는 인덱싱된 명령어 코드 시퀀스를 생성하는 단계를 더 포함하고, 상기 어셈블리 언어 모델을 학습하는 단계는, 상 기 인덱싱된 명령어 코드 시퀀스를 이용하여 상기 어셈블리 언어 모델을 학습할 수 있다. 이때, 상기 어셈블리 언어 모델을 학습하는 단계는, 상기 인덱싱된 명령어 코드 시퀀스를 이용하여 상기 어셈블 리 언어 모델의 MLM(Masked Language Model) 작업과 이웃 문자 예측(Next Sentence Prediction) 작업을 수행함 으로써, 상기 어셈블리 언어 모델을 학습할 수 있다. 이때, 상기 어셈블리 언어 모델을 학습하는 단계는, 상기 인덱싱된 명령어 코드 시퀀스를 문장(sentence)으로 취급하고, 각 명령어 코드를 토큰(token)으로 취급하여, 상기 어셈블리 언어 모델을 학습할 수 있다. 이때, 상기 어셈블리 언어 모델을 학습하는 단계는, 상기 인덱싱된 명령어 코드 시퀀스에 대한 토큰 임베딩, 명 령어 코드의 위치에 대한 위치 임베딩과 두 개의 인덱싱된 명령어 코드 시퀀스를 구분하기 위한 분할 임베딩을 더한 벡터를 이용하여 상기 어셈블리 언어 모델을 학습할 수 있다. 본 개시의 또 다른 실시예에 따른 악성코드 탐지 장치는, 악성코드 여부를 탐지하고자 하는 입력 파일을 어셈블 리 코드로 변환하여 명령어 코드 시퀀스를 생성하는 수집부; 명령어 코드 임베딩(embedding)을 위해 미리 학습 된 어셈블리 언어 모델을 이용하여 상기 명령어 코드 시퀀스를 임베딩하고, 상기 명령어 코드 시퀀스의 임베딩 결과를 출력하는 출력부; 및 상기 임베딩 결과를 입력으로 하는 미리 학습된 악성코드 분류 모델을 이용하여 악 성코드 여부를 탐지하는 탐지부를 포함한다."}
{"patent_id": "10-2023-0129718", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 2, "content": "본 개시에 대하여 위에서 간략하게 요약된 특징들은 후술하는 본 개시의 상세한 설명의 예시적인 양상일 뿐이며, 본 개시의 범위를 제한하는 것은 아니다."}
{"patent_id": "10-2023-0129718", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시에 따르면, 어셈블리 언어 모델 기반으로 악성코드를 탐지할 수 있는 방법 및 장치를 제공할 수 있다. 본 개시에서 얻을 수 있는 효과는 이상에서 언급한 효과들로 제한되지 않으며, 언급하지 않은 또 다른 효과들은 아래의 기재로부터 본 개시가 속하는 기술 분야에서 통상의 지식을 가진 자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2023-0129718", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하에서는 첨부한 도면을 참고로 하여 본 개시의 실시 예에 대하여 본 개시가 속하는 기술 분야에서 통상의 지 식을 가진 자가 용이하게 실시할 수 있도록 상세히 설명한다. 그러나, 본 개시는 여러 가지 상이한 형태로 구현 될 수 있으며 여기에서 설명하는 실시 예에 한정되지 않는다. 본 개시의 실시 예를 설명함에 있어서 공지 구성 또는 기능에 대한 구체적인 설명이 본 개시의 요지를 흐릴 수 있다고 판단되는 경우에는 그에 대한 상세한 설명은 생략한다. 그리고, 도면에서 본 개시에 대한 설명과 관계없 는 부분은 생략하였으며, 유사한 부분에 대해서는 유사한 도면 부호를 붙였다. 본 개시에 있어서, 어떤 구성요소가 다른 구성요소와 \"연결\", \"결합\" 또는 \"접속\"되어 있다고 할 때, 이는 직접 적인 연결 관계 뿐만 아니라, 그 중간에 또 다른 구성요소가 존재하는 간접적인 연결관계도 포함할 수 있다. 또 한 어떤 구성요소가 다른 구성요소를 \"포함한다\" 또는 \"가진다\"고 할 때, 이는 특별히 반대되는 기재가 없는 한 다른 구성요소를 배제하는 것이 아니라 또 다른 구성요소를 더 포함할 수 있는 것을 의미한다. 본 개시에 있어서, 제1, 제2 등의 용어는 하나의 구성요소를 다른 구성요소로부터 구별하는 목적으로만 사용되 며, 특별히 언급되지 않는 한 구성요소들 간의 순서 또는 중요도 등을 한정하지 않는다. 따라서, 본 개시의 범 위 내에서 일 실시 예에서의 제1 구성요소는 다른 실시 예에서 제2 구성요소라고 칭할 수도 있고, 마찬가지로 일 실시 예에서의 제2 구성요소를 다른 실시 예에서 제1 구성요소라고 칭할 수도 있다. 본 개시에 있어서, 서로 구별되는 구성요소들은 각각의 특징을 명확하게 설명하기 위한 것일 뿐, 구성요소들이 반드시 분리되는 것을 의미하지는 않는다. 즉, 복수의 구성요소가 통합되어 하나의 하드웨어 또는 소프트웨어 단위로 이루어질 수도 있고, 하나의 구성요소가 분산되어 복수의 하드웨어 또는 소프트웨어 단위로 이루어질 수 도 있다. 따라서, 별도로 언급하지 않더라도 이와 같이 통합된 또는 분산된 실시 예도 본 개시의 범위에 포함된 다. 본 개시에 있어서, 다양한 실시 예에서 설명하는 구성요소들이 반드시 필수적인 구성요소들은 의미하는 것은 아 니며, 일부는 선택적인 구성요소일 수 있다. 따라서, 일 실시 예에서 설명하는 구성요소들의 부분집합으로 구성 되는 실시 예도 본 개시의 범위에 포함된다. 또한, 다양한 실시예에서 설명하는 구성요소들에 추가적으로 다른 구성요소를 포함하는 실시 예도 본 개시의 범위에 포함된다. 본 개시에 있어서, 본 명세서에 사용되는 위치 관계의 표현, 예컨대 상부, 하부, 좌측, 우측 등은 설명의 편의 를 위해 기재된 것이고, 본 명세서에 도시된 도면을 역으로 보는 경우에는, 명세서에 기재된 위치 관계는 반대 로 해석될 수도 있다. 인공지능 기술을 활용하여 악성코드를 분석할 때, 우선적으로 신경망 모델에 입력할 데이터를 결정하는 것이 필 요하다. 일반적으로 세가지 선택이 가능한데, 원시 바이트(raw bytes), 수동으로 설계된 특징(manually- designed features), 명령어 표현(instruction representation) 벡터이다. 원시 바이트 및 특징 데이터 처리에 는 주로 DNN(Deep Neural Network), CNN(Convolution Neural Network) 모델이 활용되고, 명령어 표현 벡터 처 리는 표현 학습 모델과 후속 작업(downstream task)을 위한 DNN 모델 등이 활용된다. 표현 학습 모델은 각 명령어에 대한 벡터 표현을 자동으로 학습한 후, 입력 명령어에 대한 명령어 표현 벡터를 생성한다. 대표적인 표현 학습 모델로는 자연어 처리(NLP: Natural Language Processing) 영역에서 고안된 word2vec, PV-DM(Distributed Memory version of Paragraph Vector), BERT(Bidirectional Encoder Representation Transformer) 등이 있다. 최근, 수동으로 특징을 설계하는 수고스러움을 피하고, 고수준의 특징을 학습할 수 있다는 장점에서 명령어 수 준 표현 학습이 주목받고 있다. 그 중에서도 임베딩(embedding)(또는 표현) 성능이 우수한 BERT가 표현 학습 모 델로 활발히 활용되고 있다. BERT는 구글에서 개발한 자연어처리 사전학습 모델로, 대부분의 자연어 처리 분야 에서 좋은 성능을 내는 범용 언어모델(Language model)이다. 본 개시의 실시예들은, 인공지능 기반으로 알려지지 않은 악성코드를 탐지하는 기술로, 악성코드 정적/동적 분 석 시 활용되는 명령어(Instruction) 정보를 활용하여 어셈블리 언어 모델을 생성하고 이를 기반으로 알려지지 않은 악성코드를 탐지하는 것을 그 요지로 한다. 이때, 본 개시의 실시예들은, BERT 모델을 활용하여 명령어 코드(instruction code)를 임베딩할 수 있는 표현 학습 모델(즉, 어셈블리 언어 모델)을 학습하고, 사전 학습된 어셈블리 언어 모델로부터 생성된 명령어 코드 임 베딩 벡터를 이용하여 언노운(unknown) 코드의 악성 여부를 판단하는 악성코드 분류 모델(또는 악성코드 탐지 모델)을 학습함으로써, 언노운 코드의 악성코드 여부를 탐지할 수 있다. 이를 위해, 본 개시의 실시예들은, 어셈블리 언어 모델 학습 데이터를 위한 명령어 수집, 수집된 학습 데이터 전처리, 어셈블리 언어모델 사전학습 및 어셈블리 언어모델 기반 악성코드 분류기 학습을 통해 Unknown 악성코 드 탐지를 수행할 수 있다. 도 1은 본 개시의 일 실시예에 따른 악성코드 탐지 모델을 학습하는 과정에 대한 순서도를 나타낸 도면으로, 어 셈블리 언어 모델 기반으로 악성코드 탐지 모델을 학습하는 과정에 대한 순서도를 나타낸 도면이다. 도 1을 참조하면, 악성코드 탐지 모델을 학습하는 과정은, 복수의 실행 파일들 각각을 어셈블리 코드로 변환하 여 명령어 코드 시퀀스를 생성하는 단계(S110), 명령어 코드 시퀀스를 이용하여 명령어 코드 임베딩(embeddin g)을 위한 어셈블리 언어 모델을 학습하는 단계(S120)와 학습된 어셈블리 언어 모델을 기반으로 악성코드 여부 를 탐지하기 위한 악성코드 분류 모델을 학습하는 단계(S130)를 포함한다. 단계 S110은, 어셈블리 언어 모델을 학습하기 위한 학습 데이터를 생성하는 과정으로, 명령어 코드를 정수로 인 덱싱하기 위한 명령어 코드 사전을 이용하여, 명령어 코드 시퀀스에 포함된 명령어 코드를 정수로 인덱싱함으로 써, 명령어 코드 시퀀스에 대응하는 인덱싱된 명령어 코드 시퀀스를 생성하는 과정을 포함할 수 있으며, 단계 S120은, 이렇게 생성된 인덱싱된 명령어 코드 시퀀스를 이용하여 어셈블리 언어 모델을 학습할 수 있다. 여기서, 단계 S110은, 명령어 코드 시퀀스를 랜덤하게 선택된 길이로 분할하여 복수의 분할 명령어 코드 시퀀스 를 생성하고, 복수의 분할 명령어 코드 시퀀스 각각을 개별 파일로 생성할 수 있다. 나아가, 단계 S110은, 어셈블리 코드로부터 명령어를 추출하고, 추출된 명령어의 명령코드(Opcode)와 오퍼랜드 (Operand)를 조합하여 명령어 코드를 생성하며, 명령어 코드를 이용하여 명령어 코드 시퀀스를 생성할 수 있다. 단계 S120은, 인덱싱된 명령어 코드 시퀀스를 이용하여 어셈블리 언어 모델의 MLM(Masked Language Model) 작업 과 이웃 문자 예측(NSP: Next Sentence Prediction) 작업을 수행함으로써, 어셈블리 언어 모델을 학습한다. 이때, 단계 S120은, 인덱싱된 명령어 코드 시퀀스를 문장(sentence)으로 취급하고, 각 명령어 코드를 토큰 (token)으로 취급하여, 어셈블리 언어 모델을 학습할 수 있다. 나아가, 단계 S120은, 인덱싱된 명령어 코드 시퀀스에 대한 토큰 임베딩, 명령어 코드의 위치에 대한 위치 임베 딩과 두 개의 인덱싱된 명령어 코드 시퀀스를 구분하기 위한 분할 임베딩을 더한 벡터를 이용하여 어셈블리 언 어 모델을 학습할 수 있다. 단계 S130은, 단계 S120을 통해 학습된 어셈블리 언어 모델을 기반으로 악성코드 분류를 위한 신경망 계층을 추 가하여 생성된 악성코드 탐지 모델(또는 악성코드 분류 모델)을 학습한다. 이때, 단계 S130은, 악성 및 정상이 라벨링된 색인된 명령어 코드 시퀀스 데이터를 이용하여 학습을 수행함으로 써, 악성코드 탐지 모델을 학습할 수 있다. 이러한 학습 과정에 대하여, 도 2를 참조하여 상세히 설명한다. 도 2는 악성코드 탐지 모델을 학습하는 과정을 설명하기 위한 예시도를 나타낸 도면으로, 어셈블리 언어 모델 학습 데이터를 위한 명령어 수집 단계, 수집된 학습 데이터 전처리 단계, 어셈블리 언어모델 사전학 습 단계와 어셈블리 언어모델 기반 악성코드 분류기 학습 단계를 포함한다. 악성코드의 정적/동적 분석 시에 명령코드를 추출하기 위하여 다양한 바이너리 분석용 도구(Disassembler)가 활 용될 수 있다. 특히 분석 시스템의 OS 등의 특징에 따라서 IDA, Objdump, OllyDBG, VisualStudio, PE Explorer 등은 정적으로 명령어의 추출을 지원한다. 또한 동적 분석 시 Processor Tracer 등 CPU 또는 가상환경에서도 실 행파일의 명령어 추출/변환이 가능하다. 일반적인 바이너리 분석에 기반한 리버스 엔지니어링은 수동적인 방법 으로 다양한 정적/동적 정보(예를 들어, 파일 종류, 크기, 헤더 정보, 인증서, 내부 구조, 레지스트리, 네트워 크 동작, 관련 API 함수 정보 등)를 모두 참고하지만, 본 개시의 실시예들은, 정적/동적 분석 시에 발생되는 명 령어만을 기본으로 사용한다. 또한 패킹 및 난독화된 악성코드의 경우 사전 비난독화를 하여 명령코드 수집이 가능하도록 처리해야 하며 이 부분은 본 개시의 기술의 핵심에서 벗어나므로 상세한 설명은 생략한다. 어셈블리 언어 모델 학습 데이터를 위한 명령어 수집 단계에 대해 설명하면, AI 기반 학습 데이터를 위한 명령어 수집 단계는 옮겨 다니면서 실행시킬 수 있는 파일인 PE(Portable Executable) 실행파일을 어셈블 리 코드로 변환하는 어셈블리 변환기, 어셈블리 파일로부터 명령어(instruction)를 추출하고 명령코드 (Opcode)와 오퍼랜드(Operand)를 조합하여 명령어 코드(instruction code)를 생성하는 명령어 인코더와 어셈블리 언어 모델의 학습 데이터 입력 포맷에 맞게 명령코드로 문장을 생성하는 명령코드 문장 생성기를 이용하여 수행된다. 어셈블리 변환기는, 다양한 바이너리 분석용 도구를 이용하여 실행형 파일(PE, DLL 등)을 Intel X86 어셈 블리 포맷 파일로 변환하고, 변환된 어셈블리 포맷 파일로부터 명령어 시퀀스(instruction sequence)를 추출한 다. 통상의 어셈블리 포맷 파일은 4개의 기본 세그먼트(segment) 예를 들어, .text 세그먼트, idata 세그먼트, irdata 세그먼트, .data 세그먼트로 구성된다. 본 개시의 실시예에서는, .text 세그먼트만이 프로그램 명령어 (instructions)를 저장하고 있으므로, 명령어 시퀀스 추출을 위해 .text 세그먼트만을 고려한다. 실제로 명령어 시퀀스는 실행 파일에 상응하는 프로그램 실행 로직을 반영할 수 있다. 도 5는 명령코드 구조에 대한 예시도를 나타낸 도면이며, 도 6은 어셈블리 언어 형식의 명령어로 변환한 결과에 대한 예시도를 나타낸 도면으로, 어셈블리 변환기는, 도 5의 SECTION_text 내부에 존재하는 원시(Raw) 데이터를 다양한 바이너리 분석 도구를 이용하여 도 6에 도시된 바와 같이, 어셈블리 언어 형식의 명령어로 변환할 수 있 다. 명령어 인코더는, 어셈블리 변환기에 의해 변환된 어셈블리 파일로부터 명령어를 추출하고 명령코드 (Opcode)와 오퍼랜드(Operand)를 조합하여 명령어 코드(instruction code)를 생성한다. 기본적으로 명령어 (instruction)는 CPU가 처리하는 기계어 명령으로 논리 연산, 프로그램 흐름 제어, 메모리 처리, 산술 연산의 기능을 제공한다. 명령어(instruction)의 구조는 1 또는 2 바이트(byte) 명령코드(Opcode)와 여러 개의 오퍼랜 드(Operand) 값으로 구성될 수 있다. 아래 <표 1>은, 명령코드의 그룹별 특성 예를 나타낸 것이다. 표 1 Group Opcode Arithmetic operations add, sub, mul, div Memory manipulation lea, pop, push, mov, store, load Logical operations xor, not, and, or Program flow control call, cmp, rep Condition operation Goto, jmp, if, spa, sna, sza 도 6에서의 각 행은 하나의 명령어에 해당하며, 'push ebp', 'mov esp, ebp' 등이 각 명령어에 해당한다. 본 개 시의 실시예에서는 각 명령어를 어셈블리 언어 모델에서 사용하는 하나의 단어 또는 토큰으로 만들기 위해 명령 코드와 오퍼랜드로 구성된 명령어 코드(instruction code)를 생성한다. 오퍼랜드의 경우 EAX와 같은 산술적 레 지스터, EBP와 같은 스택 프레임 레지스터 등 통칭 “레지스터(register)”를 참조하는 경우와 코드 영역이나 데이터 영역을 포함한 “메모리(memory)”를 참조하는 경우로 나눌 수 있다. 따라서, 본 개시의 실시예에서는, 추출된 명령어의 분류를 명령코드(Opcode)와 오퍼랜드(Operand)의 개수, 오퍼랜드(Operand)의 접근 타입 3가지 를 조합하여 분류가 가능하다. 예를 들어, 도 7에 도시된 바와 같이, 메모리 참조는 “M”, 레지스터 참조는 “ R” 부호를 사용하여 명령어 코드 인코딩을 수행함으로써, 각각의 명령코드에 오퍼랜드의 개수만큼의 참조부호 를 포함하여 고유코드를 생성할 수 있다. 이때, 명령어 인코더는 도 8에 도시된 명령어 코드 코딩 테이블 을 이용하여 도 7과 같이 명령어 코드 인코딩을 수행할 수 있다.또한, 레지스터의 종류를 세분화하여 인코딩이 가능하다. 즉, 레지스터는 일반(general)(EAX, EBX, ECX, EDX), 분할(segment)(CS, DS, ES, FS, GS, SS), 색인(index) 및 포인터(ESI, EDI, EBP, EIP, ESP)와 지시자 (indicator)(EFLAGS) 레지스터로 구분되는데, 각 레지스터에 인덱스 번호를 부여해, 세부적인 레지스터 표기가 가능하다. 예를 들어, EAX는 R0, EBX는 R1, ESI는 R11, ESP는 R15 등과 같이 표현할 수 있다. 이 과정을 수행 하면, 명령어 코드는 좀 더 세분화되어 MOV_R0_R13와 같은 형태로 인코딩할 수 있다. 명령코드 문장 생성기는, 명령어 인코더로부터 출력된 명령어 코드 시퀀스 파일을 어셈블리 언어 모 델의 학습 데이터 입력 포맷에 맞게 명령코드로 문장을 생성한다. 즉, 명령코드 문장 생성기는 명령어 수 집 단계에서 학습/시험용 악성 파일과 정상 파일의 명령어(instruction)를 추출하고 명령어 코드(instruction code)가 생성되면 실행파일별로 도 9에 도시된 바와 같이, 명령어 코드로 구성된 다양한 길이의 명령어 코드 시 퀀스(instruction code sequence)를 생성한다. 그리고, 명령코드 문장 생성기는, 명령어 코드 시퀀스를 어셈블리 언어 모델의 입력 문장 형태로 변환한다. 이때, 문장의 길이는 가변적으로 생성될 수 있으며, 일정 범위(일 예로, 최소 64개 이상, 최대 512개 이하)에서 랜덤(random)하게 길이가 선택된 후 선택된 값만큼 명령어 코드를 추출하여 별도의 파일 예를 들어, 텍스트 파일 형태로 저장할 수 있다. 각 실행파일에 대해, 전체 명령어 코드 시퀀스를 상술한 방법으로 분할 추 출하여 개별 파일로 생성할 수 있으며, 일 예로, 도 10에 도시된 바와 같이, 분할된 명령어 코드 시퀀스 간에는 전후 관계를 확인할 수 있도록 분할 파일의 일련번호를 연속으로 생성할 수 있다. 이와 같은 과정을 통해, 어셈블리 언어 모델 학습 데이터를 위한 명령어 수집 단계는 정상 파일과 악성 파일을 포함하는 복수의 실행 파일들 각각을 분할된 명령어 코드 시퀀스 파일로 생성할 수 있다. 수집된 학습 데이터 전처리 단계에 대해 설명하면, 명령어 코드 토크나이저(tokenizer)는, 사전에 구 축된 명령어 코드 사전을 이용하여 색인된 명령어 코드 시퀀스를 생성한다. 이때, 명령어 코드 사전은, 도 11에 도시된 바와 같이, 분할된 명령어 코드 시퀀스 파일로 구성된 학습 데이터 셋을 대상으로 명령어 코드를 정수로 인덱싱하기 위한 것이다. 즉, 본 개시의 실시예는, 각 명령어 코드를 개별 토큰(token)으로 간주하고 전체 학습 데이터에서 출현하는 모든 명령어 코드를 인덱싱할 수 있는 명령어 코드 사전을 구축한다. 명령어 코드 토크나이저는, 모델 학습 및 토큰 인덱싱 예외 처리를 위해 스페셜 토큰(special token)을 활 용할 수 있다. 스페셜 토큰(special token)에 대한 예로, 공백을 표시하는 ' ', 사전에 없는 토큰 인덱싱을 위 한 '[UNK]', 개별 토큰을 가리기 위한 '[MASK]', 시퀀스의 시작을 나타내는 '[CLS]', 두 개의 시퀀스(문장)를 구분하기 위한 '[SEP]' 등을 포함할 수 있다. 또한 명령어 코드 사전을 참조하여 학습 데이터로 사용되는 명령 어 코드 시퀀스를 인덱싱하고, 정수로 색인된 명령어 코드 시퀀스를 생성한다. 본 개시의 실시예들은, 명령어 코드(instruction code) 임베딩을 위한 어셈블리 언어 모델(assembly language model)을 제공하고, 이를 이용한 악성코드 이진 분류(malware binary classification) 모델 예를 들어, 악성코 드 탐지 모델을 제공한다. 이때, 어셈블리 언어 모델은 구글(Google)에서 제안한 BERT(Bidirectional Encoder Representation from Transformer) 모델에 기반할 수 있지만, 어셈블리 언어 모델이 반드시 BERT 모델에 기반 하는 것으로 제한되거나 한정되지 않으며, 어셈블리 언어 모델을 생성할 수 있는 모든 방식과 인공지능을 이용 하여 생성될 수 있다. 이때, 본 개시의 실시예들은, 명령어 코드(instruction code) 임베딩을 위한 어셈블리 언어 모델을 사전 학습하 는데, 어셈블리 언어 모델의 사전학습을 위해 명령어 코드 시퀀스를 활용한 MLM(Masked Language Model)과 이웃 문장 예측(NSP: Next Sentence Prediction) 작업(task)을 수행한다. MLM 작업을 수행하기 위해, 주어진 입력 명령코드 시퀀스에 대해, 우선 랜덤(randomly)하게 토큰의 15%를 선택 해서 바꾼다. 선택된 토큰 중에서 80%는 [MASK] 토큰으로 바꿔서 원래 토큰/단어(명령코드)를 가린다. 10%는 사 전에 있는 다른 토큰 예를 들어, 단어, corrupted token(손상된 토큰) 등으로 바꾼다. 나머지 10%는 바꾸지 않 는다. 명령어 시퀀스의 문맥적 연관성을 이해하기 위해 이진(binarized) NSP 작업을 수행한다. NSP 작업은 명령어 시 퀀스 데이터셋에서 간단하게 생성될 수 있다. 사전학습 예로, 두 개의 명령어 시퀀스 A와 B를 선택할 때, B를 선택하는 회수의 50%는 A 뒤에 이어지는 실제 명령어 시퀀스를 선택하고, B를 선택하는 나머지 50%는 데이터셋 에서 임의로 선택한 명령어 시퀀스를 사용한다. 이때, A 뒤에 이어지는 실제 명령어 시퀀스를 선택하는 경우IsNext로 라벨링될 수 있다. 사전학습 데이터 전처리기는, MLM 작업과 NSP 작업을 통해 어셈블리 언어 모델을 사전학습 하기 위한 색인 된 명령어 코드 시퀀스를 생성한다. 즉, 사전학습 데이터 전처리기는, 명령어 코드 토크나이저의 색 인된 명령어 코드 시퀀스를 MLM 작업과 NSP 작업을 위한 색인된 명령어 코드 시퀀스(MLM, NSP)로 전처리한다. 어셈블리 언어모델 사전학습 단계에 대해 설명하면, 본 개시의 실시예에서의 명령어 코드 임베딩을 위한 어셈블리 언어 모델은 BERT 모델에 기반으로 하며, BERT는 자연어 처리(NLP) 작업에 유용한 최신의 사전학 습 모델이다. BERT는 다계층 양방향 트랜스포머(transformer)로 구성된 인코더 표현 학습 모델이며, 트랜스포머 는 2017년에 처음 소개된 기술로 어텐션(attention) 기법만을 활용하는 시퀀스 모델링 구조이다. 본 개시의 실시예들은, 명령어 코드 시퀀스를 문장(sentence)으로 다루고, 각 명령어 코드를 토큰(token)으로 취급한다. 도 12에 도시된 바와 같이, 명령어 코드 시퀀스의 첫번째 토큰은 시퀀스의 시작을 나타내는 스페셜 토큰 [CLS]을 사용하며, 연결된 두 개의 문장(명령어 코드 시퀀스)을 구분하기 위해 [SEP] 토큰을 사용한다. 이 때, 토큰 임베딩(token embedding) 결과에 위치 임베딩(position embedding)과 분할 임베딩(segment embedding)을 더하여, 혼합된(mixed) 벡터가 양방향 트랜스포머 네트워크의 입력으로 사용될 수 있다. 위치 임베딩은 입력 명령어 코드 시퀀스에서 각 명령어 코드의 서로 다른 위치를 표현하는 것이고, 분할 임베딩 은 두 개의 명령어 코드 시퀀스에서 첫번째와 두번째를 구분하기 위한 것이다. 이때, 위치 임베딩과 분할 임베 딩은 토큰 임베딩과 함께 학습될 수 있다. 이들 두 임베딩 즉, 위치 임베딩과 분할 임베딩은 위치에 따른 토큰 임베딩을 동적으로 조정하는데 도움을 줄 수 있다. 어셈블리 언어 모델은, 명령어 코드 시퀀스를 활용한 두 종류(MLM, NSP)의 사전학습 작업을 수행함으로써, 학습될 수 있다. 어셈블리 언어 모델을 사전학습하기 위한 첫번째 작업은, 명령어 코드 시퀀스를 활용한 MLM(Masked Language Model) 작업이다. 명령어 코드 시퀀스(I)는 명령어 코드 토큰(ti)으로 구성될 수 있으며, 아래 <수학 식 1>과 같이 나타낼 수 있다. [수학식 1] I = t1, t2, t3, ..., tn MLM 작업을 수행하기 위하여, 주어진 입력 명령어 코드 시퀀스에 대해, 우선 랜덤(randomly)하게 토큰의 15%를 선택해서 바꾼다. 선택된 토큰 중에서 80%는 [MASK] 토큰으로 바꿔서 원래 토큰/단어(명령코드)를 가린다. 10% 는 사전에 있는 다른 토큰 예를 들어, 단어, corrupted token(손상된 토큰으로 바꾼다. 나머지 10%는 바꾸지 않 는다. 그 다음에, 트랜스포머 인코더는 가려진 토큰(masked token)과 손상된 토큰(corrupted token)을 예측하는 것 을 학습한다. 그리고, 트랜스포머 네트워크의 제일 위에 위치한 softmax 계층으로 특정 토큰 ti = [MASK]의 예 측 확률을 출력한다. 이때, 어셈블리 언어 모델은 교차 엔트로피 손실함수(Cross Entropy loss functio n)로 훈련될 수 있다. 도 13은 명령어 코드 시퀀스를 활용한 MLM 기법에 대한 예시도를 나타낸 도면으로, 도 13에 도시된 바와 같이, 주어진 명령어 코드 시퀀스 쌍(pair)에 대해서, 첫번째로 스페셜 토큰(special tokens) [CLS]와 [SEP]를 추가하 고, 그 다음에 바꾸기 위한 몇 개의 토큰을 랜덤하게 선택한다. 예를 들어, 도 13에서는 CALLM와 XORRR가 바꾸 기 위한 토큰으로 선택되며, 토큰 CALLM는 [MASK] 토큰으로 바뀌고, 토큰 XORRR는 명령어 코드 사전에 있는 다 른 토큰 JLER로 바뀔 수 있다. 그 다음에 수정된 명령어 코드 시퀀스를 어셈블리 언어 모델에 입력하고, 어셈블 리 언어 모델은 각 토큰에 대한 예측을 수행한다. 어셈블리 언어 모델이 [MASK] 토큰과 손상된 토큰인 XORRR 토 큰을 잘 예측하는지만을 고려한다. 두 개의 스페셜 토큰에 대한 예측만이 손실함수를 계산할 때 고려된다. 어셈블리 언어 모델을 사전학습하기 위한 두번째 작업은 명령어 코드 시퀀스를 활용한 NSP(Next Sentence Prediction) 작업이다. 도 14에 도시된 바와 같이, 명령어 시퀀스의 문맥적 연관성을 이해하기 위해 이진 NSP 작업을 수행한다. NSP 작업은 명령어 시퀀스 데이터셋에서 간단하게 생성될 수 있다. 사전학습 예로 두 개의 명령어 시퀀스 A와 B를 선택할 때, B를 선택하는 회수의 50%는 A 뒤에 이어지는 실제 명령어 시퀀스를 선택하고, B를 선택하는 나머지 50%는 데이터셋에서 임의로 선택한 명령어 시퀀스를 사용한다. 이때, A 뒤에 이어지는 실 제 명령어 시퀀스를 선택하는 경우 IsNext로 라벨링될 수 있다. 전체 데이터셋의 명령어 코드 시퀀스로 사전학습이 완료된 어셈블리 언어 모델은 이 후 진행될 다운스트림 (downstream) 작업을 위해 저장될 수 있다. 여기서, 다운스트림 작업은, 악성코드 이진 분류기(또는 악성코드 탐지 모델)가 될 수 있다. 어셈블리 언어 모델 기반 악성코드 분류기 학습 단계에 대해 설명하면, 어셈블리 언어 모델 기반 악성코드 분류기 학습 단계는 사전 학습된 어셈블리 언어 모델을 기반으로 악성코드 분류를 위한 신경망 계층 을 추가하여 악성코드 이진 분류기를 생성하고, 악성 및 정상이 라벨링된 색인된 명령어 코드 시퀀스 데이 터를 이용하여 학습을 수행한다. 악성코드 이진 분류기는 색인된 명령어 코드 시퀀스를 입력 받는 입력층, 명령어 코드로 사전 학습된 어셈 블리 언어 모델과, 1차원 풀링 계층, ReLU 활성 함수를 갖는 전연결(Fully connected) 계층과 sigmoid 활성 함 수를 갖는 이진 분류 계층으로 구성될 수 있다. 일 예로, 입력층 크기는 512차원, 1차원 풀링 크기는 128, 전연 결 계층 크기는 64로 구성될 수 있다. 최적화기는 Adam을 사용하고, 손실 함수로는 이진 교차 엔트로피 함수 (binary cross entropy function)를 사용할 수 있다. 악성코드 이진 분류기 훈련을 위한 학습 데이터는 악성코드에서 추출한 명령어 코드 시퀀스를 악성 (malware)로 라벨링하고, 정상코드에서 추출한 명령어 코드 시퀀스를 정상(benign)으로 라벨링한 후, 명령어 코 드 토크나이저를 통해 색인된 훈련 데이터셋과 시험 데이터셋을 사용한다. 악성코드 이진 분류기 모델을 구성한 후, 사전 학습된 어셈블리 언어 모델의 학습 파라미터(parameter)는 훈련 이 진행되지 않도록 설정하고, 훈련 데이터를 입력하여 나머지 계층의 파라미터를 학습하도록 하며, 훈련 데이 터로 학습이 완료된 후에는 사전 학습된 어셈블리 언어 모델의 학습 파라미터도 훈련 가능하게 설정한 후, 시험 데이터로 악성코드 이진 분류기 훈련을 진행할 수 있다. 훈련이 끝난 악성코드 이진 분류기 모델 즉, 악성코드 탐지 모델은 이 후 진행될 Unknown PE 파일의 악성/ 정상 분류를 위해 별도로 저장될 수 있다. 상술한 과정을 통해 어셈블리 언어 모델과 악성코드 탐지 모델의 학습이 이루어지고, 이렇게 학습된 어셈블리 언어 모델과 악성코드 탐지 모델은 악성코드 탐지 장치에 탑재되어 언노운(Unknown) 파일의 악성코드 여부를 탐지할 수 있다. 도 3은 본 개시의 다른 실시예에 따른 악성코드 탐지 방법에 대한 순서도를 나타낸 도면이다. 도 3을 참조하면, 본 개시의 다른 실시예에 따른 악성코드 탐지 방법은, 악성코드 여부를 탐지하고자 하는 입력 파일을 어셈블리 코드로 변환하여 명령어 코드 시퀀스를 생성하는 단계(S310), 명령어 코드 임베딩을 위한 미리 학습된 어셈블리 언어 모델을 이용하여 명령어 코드 시퀀스를 임베딩하고, 명령어 코드 시퀀스의 임베딩 결과를 출력하는 단계(S320)와 임베딩 결과를 입력으로 하는 미리 학습된 악성코드 분류 모델을 이용하여 악성코드 여 부를 탐지하는 단계(S330)를 포함한다. 단계 S310은, 어셈블리 언어 모델로 입력하기 위한 포맷의 악성코드 여부를 탐지하고자 하는 입력 파일의 명령 어 코드 시퀀스를 생성하는 과정으로, 명령어 코드를 정수로 인덱싱하기 위한 명령어 코드 사전을 이용하여, 명 령어 코드 시퀀스에 포함된 명령어 코드를 정수로 인덱싱함으로써, 명령어 코드 시퀀스에 대응하는 인덱싱된 명 령어 코드 시퀀스를 생성하는 과정을 포함할 수 있다. 여기서, 단계 S310은, 입력 파일의 명령어 코드 시퀀스를 랜덤하게 선택된 길이로 분할하여 복수의 분할 명령어 코드 시퀀스를 생성하고, 복수의 분할 명령어 코드 시퀀스 각각을 개별 파일로 생성할 수 있다. 나아가, 단계 S310은, 어셈블리 코드로부터 명령어를 추출하고, 추출된 명령어의 명령코드(Opcode)와 오퍼랜드 (Operand)를 조합하여 명령어 코드를 생성하며, 명령어 코드를 이용하여 명령어 코드 시퀀스를 생성할 수 있다. 도 3의 방법을 도 4를 참조하여 설명하면, 도 4에 도시된 바와 같이, 입력 파일의 명령어 수집기를 통해 입력 파일을 어셈블리 코드로 변환한 후 어셈블리 파일로부터 명령어를 추출하여 명령어 코드를 생성하며, 어셈 블리 언어 모델의 학습 데이터 입력 포맷에 맞게 명령코드로 문장을 생성한다.이때, 명령어 수집기는, 입력 파일인 unknown PE 파일을 어셈블리 코드로 변환하는 어셈블리 변환기, 어셈블리 파일로부터 명령어를 추출하고 명령코드(Opcode)와 오퍼랜드(Operand)를 조합하여 명령어 코드 (instruction code)를 생성하는 명령어 인코더와 어셈블리 언어 모델의 학습 데이터 입력 포맷에 맞게 명 령코드로 문장을 생성하는 명령코드 문장 생성기를 이용하여 수행될 수 있다. 어셈블리 변환기, 명령어 인코더 및 명령코드 문장 생성기는, 도 2에서 상세히 설명하였기에 여 기서는 그 설명을 생략한다. 명령어 수집기에 의해 unknown 파일에 대한 명령어의 분할된 명령어 코드 시퀀스 파일이 생성되면, 명령어 코드 토크나이저에서 어셈블리 언어 모델의 사전학습에 사용되었던 명령어 코드(instruction code) 사전을 이용하여 명령어 코드 시퀀스를 토크나이징(색인) 한 후, 색인된 명령어 코드 시퀀스를 학습이 완료된 어셈블리 언어 모델로 입력하여 명령어 코드 시퀀스를 임베딩하고, 명령어 코드 시퀀스의 임베딩 결과를 출력한다. 악성코드 분류 모델은 어셈블리 언어 모델로부터 출력된 임베딩 결과를 입력으로 하여 입력 unknown 파일이 악성코드 파일인지 정상코드 파일(malware/benign)인지 확인한다. 이와 같이, 본 개시의 실시예들에 따른 방법은, 인공지능 기반으로 알려지지 않은 악성코드를 탐지하는 기술로, 악성코드 정적/동적 분석 시 활용되는 명령어 정보를 활용하여 어셈블리 언어 모델을 생성하고 이를 기반으로 알려지지 않은 악성코드를 탐지할 수 있다. 또한, 본 개시의 실시예들에 따른 방법은, 동일한 명령어라 할 지라도 명령어 시퀀스 내에서의 문맥에 맞게 임 베딩을 다르게 할 수 있으므로, 명령어 시퀀스의 행위를 좀 더 세분화해서 표현하는 것이 가능하고, 이를 통해 세분화된 명령어 시퀀스의 행위 패턴을 학습할 수 있으므로, 악성코드 분류기의 탐지 정확도를 향상시킬 수 있 다. 도 15는 본 개시의 또 다른 실시예에 따른 악성코드 탐지 장치에 대한 구성을 나타낸 도면으로, 도 1 내지 도 14의 방법을 수행하는 장치에 대한 개념적인 구성을 나타낸 도면이며, 어셈블리 언어 모델과 악성코드 탐지 모 델이 이미 학습된 상태로 장치에 다운로드된 상태의 도면이다. 도 15를 참조하면, 악성코드 탐지 장치는 수집부, 변환부, 출력부와 탐지부를 포함한다. 수집부는, 악성코드 여부를 탐지하고자 하는 입력 파일을 어셈블리 코드로 변환하여 명령어 코드 시퀀스 를 생성한다. 이때, 수집부는, 상기 명령어 코드 시퀀스를 랜덤하게 선택된 길이로 분할하여 복수의 분할 명령어 코드 시퀀스를 생성할 수 있고, 복수의 분할 명령어 코드 시퀀스 각각을 개별 파일로 생성할 수 있다. 나아가, 수집부는, 어셈블리 코드로부터 명령어를 추출하고, 추출된 명령어의 명령코드(Opcode)와 오퍼랜 드(Operand)를 조합하여 명령어 코드를 생성하며, 명령어 코드를 이용하여 명령어 코드 시퀀스를 생성할 수 있 다. 변환부는, 명령어 코드를 정수로 인덱싱하기 위한 명령어 코드 사전을 이용하여, 상기 명령어 코드 시퀀 스에 포함된 명령어 코드를 정수로 인덱싱함으로써, 명령어 코드 시퀀스에 대응하는 인덱싱된 명령어 코드 시퀀 스를 생성할 수 있다. 출력부는, 명령어 코드 임베딩을 위해 미리 학습된 어셈블리 언어 모델을 이용하여 명령어 코드 시퀀스를 임베딩하고, 명령어 코드 시퀀스의 임베딩 결과를 출력한다. 이때, 출력부는, 인덱싱된 명령어 코드 시퀀스를 임베딩하여 인덱싱된 명령어 코드 시퀀스의 임베딩 결과 를 출력할 수 있다. *탐지부는, 임베딩 결과를 입력으로 하는 미리 학습된 악성코드 분류 모델을 이용하여 악성코드 여부를 탐지한다.그리고, 도 15에서 도시하진 않았지만, 악성코드 탐지 장치는 악성코드 탐지 장치에 탑재되는 어셈블리 언어 모델과 악성코드 탐지 모델을 사전에 학습시키기 위한 학습부를 포함할 수도 있다. 물론, 학습부는 탑재되 는 어셈블리 언어 모델과 악성코드 탐지 모델을 학습시키기 위한 구성 수단으로, 어셈블리 언어 모델과 악성코 드 탐지 모델이 학습되면, 이후 악성코드를 탐지할 때는 학습부에 대한 구성은 사용하지 않는다. 비록, 도 15의 장치에서 그 설명이 생략되더라도, 본 개시의 실시예에 따른 장치는 도 1 내지 도 14의 방법에서 설명한 모든 내용을 포함할 수 있으며, 이는 해당 기술 분야에 종사하는 당업자에게 있어서 자명하다. 도 16은 본 개시의 또 다른 실시예에 따른 악성코드 탐지 장치가 적용되는 디바이스의 구성도를 나타낸 도면이 다. 예를 들어, 도 15의 본 개시의 또 다른 실시예에 따른 관람객 추적 관리 장치는 도 16의 디바이스가 될 수 있다. 도 16을 참조하면, 디바이스는 메모리, 프로세서, 송수신부 및 주변 장치 를 포함할 수 있다. 또한, 일 예로, 디바이스는 다른 구성을 더 포함할 수 있으며, 상술한 실시예 로 한정되지 않는다. 이때, 상기 디바이스는 예를 들어 이동 가능한 사용자 단말기(예를 들어, 스마트 폰, 노트북, 웨어러블 기기 등) 이거나 고정된 관리 장치(예를 들어, 서버, PC 등) 일 수 있다. 보다 상세하게는, 도 16의 디바이스는 악성코드 탐지 장치, 악성코드 분류 장치 등과 같은 예시적인 하드 웨어/소프트웨어 아키텍처일 수 있다. 이때, 일 예로, 메모리는 비이동식 메모리 또는 이동식 메모리일 수 있다. 또한, 일 예로, 주변 장치는 디스플레이, GPS 또는 다른 주변기기들을 포함할 수 있으며, 상술 한 실시예로 한정되지 않는다. 또한, 일 예로, 상술한 디바이스는 상기 송수신부와 같이 통신 회로를 포함할 수 있으며, 이에 기 초하여 외부 디바이스와 통신을 수행할 수 있다. 또한, 일 예로, 프로세서는 범용 프로세서, DSP(digital signal processor), DSP 코어, 제어기, 마이크 로제어기, ASIC들(Application Specific Integrated Circuits), FPGA(Field Programmable Gate Array) 회로들, 임의의 다른 유형의 IC(integrated circuit) 및 상태 머신과 관련되는 하나 이상의 마이크로프로세서 중 적어도 하나 이상일 수 있다. 즉, 상술한 디바이스를 제어하기 위한 제어 역할을 수행하는 하드웨어적 /소프트웨어적 구성일 수 있다. 또한 상기 프로세서는 전술한 도 15의 수집부, 변환부, 출력 부와 탐지부의 기능을 모듈화하여 수행할 수 있다. 이때, 프로세서는 악성코드 탐지 장치의 다양한 필수 기능들을 수행하기 위해 메모리에 저장된 컴 퓨터 실행가능한 명령어들을 실행할 수 있다. 일 예로, 프로세서는 신호 코딩, 데이터 처리, 전력 제어, 입출력 처리 및 통신 동작 중 적어도 어느 하나를 제어할 수 있다. 또한, 프로세서는 물리 계층, MAC 계 층, 어플리케이션 계층들을 제어할 수 있다. 또한, 일 예로, 프로세서는 액세스 계층 및/또는 어플리케이 션 계층 등에서 인증 및 보안 절차를 수행할 수 있으며, 상술한 실시예로 한정되지 않는다. 일 예로, 프로세서는 송수신부를 통해 다른 장치들과 통신을 수행할 수 있다. 일 예로, 프로세서 는 컴퓨터 실행가능한 명령어들의 실행을 통해 악성코드 탐지 장치가 네트워크를 통해 다른 장치들과 통 신을 수행하게 제어할 수 있다. 즉, 본 개시에서 수행되는 통신이 제어될 수 있다. 일 예로, 송수신부는 안테나를 통해 RF 신호를 전송할 수 있으며, 다양한 통신망에 기초하여 신호를 전송할 수 있다. 또한, 일 예로, 안테나 기술로서 MIMO 기술, 빔포밍 등이 적용될 수 있으며, 상술한 실시예로 한정되지 않는다. 또한, 송수신부를 통해 송수신한 신호는 변조 및 복조되어 프로세서에 의해 제어될 수 있으며, 상 술한 실시 예로 한정되지 않는다. *본 개시의 예시적인 방법들은 설명의 명확성을 위해서 동작의 시리즈로 표현되어 있지만, 이는 단계가 수행되 는 순서를 제한하기 위한 것은 아니며, 필요한 경우에는 각각의 단계가 동시에 또는 상이한 순서로 수행될 수도 있다. 본 개시에 따른 방법을 구현하기 위해서, 예시하는 단계에 추가적으로 다른 단계를 포함하거나, 일부의 단계를 제외하고 나머지 단계를 포함하거나, 또는 일부의 단계를 제외하고 추가적인 다른 단계를 포함할 수도 있다. 본 개시의 다양한 실시 예는 모든 가능한 조합을 나열한 것이 아니고 본 개시의 대표적인 양상을 설명하기 위한 것이며, 다양한 실시 예에서 설명하는 사항들은 독립적으로 적용되거나 또는 둘 이상의 조합으로 적용될 수도 있다. 또한, 본 개시의 다양한 실시 예는 하드웨어, 펌웨어(firmware), 소프트웨어, 또는 그들의 결합 등에 의해 구현 될 수 있다. 하드웨어에 의한 구현의 경우, 하나 또는 그 이상의 ASICs(Application Specific Integrated Circuits), DSPs(Digital Signal Processors), DSPDs(Digital Signal Processing Devices), PLDs(Programmable Logic Devices), FPGAs(Field Programmable Gate Arrays), 범용 프로세서(general processor), 컨트롤러, 마이크로 컨트롤러, 마이크로 프로세서 등에 의해 구현될 수 있다. 본 개시의 범위는 다양한 실시 예의 방법에 따른 동작이 장치 또는 컴퓨터 상에서 실행되도록 하는 소프트웨어 또는 머신-실행가능한 명령들(예를 들어, 운영체제, 애플리케이션, 펌웨어(firmware), 프로그램 등), 및 이러한 소프트웨어 또는 명령 등이 저장되어 장치 또는 컴퓨터 상에서 실행 가능한 비-일시적 컴퓨터-판독가능 매체 (non-transitory computer-readable medium)를 포함한다."}
