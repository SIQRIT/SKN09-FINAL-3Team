{"patent_id": "10-2022-0054878", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0155249", "출원번호": "10-2022-0054878", "발명의 명칭": "구동중인 컴포넌트를 테스트할 수 있는 NPU", "출원인": "주식회사 딥엑스", "발명자": "김녹원"}}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "구동중인 컴포넌트를 테스트할 수 있는 NPU(Neural Processing Unit)으로서,회로를 각기 포함하는 복수의 기능 컴포넌트와;상기 복수의 기능 컴포넌트들 중에서 하나 이상의 기능 컴포넌트들과 연결되는 하나 이상의 래퍼(wrapper)와;그리고ICT(in-system component tester)를 포함하고,상기 ICT는:유휴 상태(idle state)의 적어도 하나의 기능 컴포넌트를 CUT(component under test)로 선택하는 과정;상기 하나 이상의 래퍼를 통하여, 상기 CUT로 선택된 상기 적어도 하나의 기능 컴포넌트를 테스트하는 과정을수행하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 ICT는:상기 하나 이상의 래퍼를 통하여, 상기 복수의 기능 컴포넌트들의 상태를 모니터하는 과정을 더 수행하도록 설정되는, NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 ICT는:상기 CUT로 선택된 상기 적어도 하나의 기능 컴포넌트에 대한 액세스로 인하여 충돌이 검출되는 것에 기초하여,상기 CUT로 선택된 상기 적어도 하나의 기능 컴포넌트에 대한 테스트를 중단(stop)하는 과정; 그리고상기 중단에 기초하여, 상기 적어도 하나의 기능 컴포넌트를 복귀시키는 과정을 더 수행하도록 설정되는, NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 ICT는:상기 적어도 하나의 기능 컴포넌트를 복귀시킨 후, 상기 적어도 하나의 기능 컴포넌트가 다시 상기 유휴 상태로확인된 경우, 상기 선택 과정을 다시 진행하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제3항에 있어서, 상기 ICT는 상기 충돌에 관한 백-오프 타이머를 구동하는 과정을 더 수행하고,상기 백-오프 타이머가 만료되면, 상기 ICT는 상기 선택 과정을 다시 수행하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서, 상기 복수의 기능 컴포넌트는적어도 하나의 메모리;공개특허 10-2023-0155249-3-적어도 하나의 컨트롤러; 그리고적어도 하나의 PE(Processing Element) 중에서하나 이상을 포함하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서, 상기 복수의 기능 컴포넌트는스케줄러와 그리고 인터페이스 중에서 하나 이상을 더 포함하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 상기 ICT는:상기 테스트를 위하여, 상기 하나 이상의 래퍼에게, 상기 CUT로 선택된 상기 하나 이상의 기능 컴포넌트를 격리시키라고 지시하는 과정을 더 수행하도록 설정되는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서, 상기 ICT는:상기 복수의 기능 컴포넌트들의 상태를 모니터하도록 설정된 검출기와;상기 ICT의 동작을 관리하도록 설정된 스케줄러와;테스트 입력 데이터를 생성하도록 설정된 생성기와; 그리고상기 CUT로 상기 테스트 입력 데이터를 주입하고, 상기 테스트 입력 데이터를 처리한 상기 CUT로부터 획득되는 테스트 결과를 분석하는 테스터중에서 하나 이상을 포함하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 테스트 입력 데이터는 미리 정해진 테스트 데이터 또는 시드(seed)에 기초하여 생성된 랜덤 비트 스트림(random bit stream)인, NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제1항에 있어서, 상기 ICT는상기 테스트가 완료된 이후, 상기 CUT로 선택된 상기 하나 이상의 기능 컴포넌트로부터 획득되는 테스트 결과를분석하는 과정과; 그리고상기 하나 이상의 기능 컴포넌트가 정상이라고 분석되는 것에 기초하여, 상기 하나 이상의 기능 컴포넌트를 복귀시키는 과정을 더 수행하도록 설정되는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1항에 있어서, 상기 ICT는:상기 하나 이상의 기능 컴포넌트가 결함이 있다고 분석되는 것에 기초하여, 상기 하나 이상의 기능 컴포넌트를비활성화하는 과정을 더 수행하도록 설정되는 NPU.공개특허 10-2023-0155249-4-청구항 13 제12항에 있어서,상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트를 모방(imitate)하도록 설정된 FPGA(fieldprogrammable gate array)를 더 포함하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13항에 있어서, 상기 FPGA의 주소는 폐지(revoke)되고, 상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트의 주소로대체되는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제12항에 있어서, 상기 비활성화하는 과정은:상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트의 주소를 폐지(revoke)하는 과정을 포함하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제12항에 있어서, 상기 비활성화하는 과정은:상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트를 파워 오프 하거나 혹은 턴 오프 하는 과정을 포함하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제12항에 있어서, 상기 비활성화하는 과정은:상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트를 격리하거나 또는 공급 전력을 컷 오프하는 과정을 포함하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제12항에 있어서, 상기 ICT는 상기 복수의 기능 컴포넌트가 상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트의 스페어 컴포넌트를포함하는 경우, 상기 스페어 컴포넌트를 활성화하는 과정을 더 수행하도록 설정된 NPU."}
{"patent_id": "10-2022-0054878", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제1항에 있어서, 상기 테스트는 기능 테스트와는 다른 스캔 테스트이고,상기 스캔 테스트를 위하여, 상기 ICT는 각 CUT 내의 복수의 플리-플롭들을 서로 연결하고, 테스트 입력을 적어도 하나의 플리-플롭으로 주입하고, 상기 CUT가 결함이 있는지 아니면 정상인지를 구동 중에 분석하기 위하여, 상기 플리-플롭의 결합 로직의 동작으로부터 테스트 결과를 획득하는 NPU."}
{"patent_id": "10-2022-0054878", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "구동중인 컴포넌트를 테스트할 수 있는 NPU(Neural Processing Unit)가 제시된다. 상기 NPU는 회로를 각기 포함 하는 복수의 기능 컴포넌트와; 상기 복수의 기능 컴포넌트들 중에서 하나 이상의 기능 컴포넌트들과 연결되는 하 나 이상의 래퍼(wrapper)와; 그리고 ICT(in-system component tester)를 포함할 수 있다. 상기 ICT는: 유휴 상 태(idle state)의 적어도 하나의 기능 컴포넌트를 CUT(component under test)로 선택하는 과정; 그리고 상기 하 나 이상의 래퍼를 통하여, 상기 CUT로 선택된 상기 적어도 하나의 기능 컴포넌트를 테스트하는 과정을 수행할 수 있다."}
{"patent_id": "10-2022-0054878", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 구동중인 NPU의 불량 감지에 관한 것이다."}
{"patent_id": "10-2022-0054878", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공지능(artificial intelligence: AI)도 점차 발전하고 있다. AI는 인간의 지능, 즉 인식(Recognition), 분 류(Classification), 추론(Inference), 예측(Predict), 조작/의사결정(Control/Decision making) 등을 할 수 있는 지능을 인공적으로 모방하는 것을 의미한다. 또한, 최근에는 인공지능(AI)을 위한 연산 속도를 가속하기 위하여, NPU(Neural processing unit)가 개발되고 있다. 한편, 반도체 집적도가 증가함에 따라 제조 원가는 저렴해지고 있지만, 복잡도가 증가함에 따라 불량율도 증가 하고 있다."}
{"patent_id": "10-2022-0054878", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시의 발명자는 제조 과정에서 불량은 공장 출하 전 테스트에서 발견될 수도 있지만, 미세한 불량은 공장 출하 전 테스트에서는 발견되지 않고, 사용자에게 인계될 수 있음을 인식하였다. 이러한 미세 불량은 반복적인 사용에 의한 피로 스트레스(fatigue stress) 혹은 물리적인 스트레스에 의하여 점 차 증폭되어, 최종적으로는 NPU가 오동작을 일으키도록 할 수 있다. NPU가 사용자의 엔터테인먼트를 위한 전자 제품에 장착되어 있다면 이러한 오동작은 크게 문제되지 않을 수 있 다. 한편 본 개시의 발명자는 NPU가 미션 크리티컬(mission critical)한 제품에 장착되어 있을 경우는 상황이 다를 수 있다는 것을 인식하였다. 특히, 본 개시의 발명자는 NPU가 불량, 결함 또는 손상으로 오동작을 하게 되면, 엉뚱한 인공지능(AI) 연산 결 과를 출력할 수 있는 문제점을 인식하였다. 예를 들어, 본 개시의 발명자는 NPU 가 차량의 자율 주행을 위해 차량, 드론(Drone), UAM(Urban Air Mobility), UAV(unmanned aerial vehicle)에 장착되는 전자 기기, AI 로봇에 장착되는 전자 기기에서 사용될 경우, NPU의 불량, 결함 또는 손상은 예측하지 못한 AI 연산 결과를 출력할 수 있다는 사실을 인식하였다. 따라서, 본 개시의 발명자는 공장 출하 전에만 수행할 수 있었던 테스트를 구동중인 NPU 내에서도 수행할 수 있 도록 하는 방안을 제시할 필요가 있다고 인식하였다. 즉, 테스트를 통해서 불량을 감지하는 것이 필요하다는 사실을 인식하였다."}
{"patent_id": "10-2022-0054878", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 명세서의 일 개시에 따르면, 구동중인 컴포넌트를 테스트할 수 있는 NPU(Neural Processing Unit)가 제시된 다. 상기 NPU는 회로를 각기 포함하는 복수의 기능 컴포넌트와; 상기 복수의 기능 컴포넌트들 중에서 하나 이상 의 기능 컴포넌트들과 연결되는 하나 이상의 래퍼(wrapper)와; 그리고 ICT(in-system component tester)를 포 함할 수 있다. 상기 ICT는: 유휴 상태(idle state)의 적어도 하나의 기능 컴포넌트를 CUT(component under test)로 선택하는 과정; 그리고 상기 하나 이상의 래퍼를 통하여, 상기 CUT로 선택된 상기 적어도 하나의 기능 컴포넌트를 테스트하는 과정을 수행할 수 있다. 상기 ICT는: 상기 하나 이상의 래퍼를 통하여, 상기 복수의 기능 컴포넌트들의 상태를 모니터하는 과정을 더 수 행하도록 설정될 수 있다. 상기 ICT는: 상기 CUT로 선택된 상기 적어도 하나의 기능 컴포넌트에 대한 액세스로 인하여 충돌이 검출되는 것 에 기초하여, 상기 CUT로 선택된 상기 적어도 하나의 기능 컴포넌트에 대한 테스트를 중단(stop)하는 과정; 그 리고 상기 중단에 기초하여, 상기 적어도 하나의 기능 컴포넌트를 복귀시키는 과정을 더 수행하도록 설정될 수 있다. 상기 ICT는: 상기 적어도 하나의 기능 컴포넌트를 복귀시킨 후, 상기 적어도 하나의 기능 컴포넌트가 다시 상기 유휴 상태로 확인된 경우, 상기 선택 과정을 다시 진행하도록 설정될 수 있다. 상기 ICT는 상기 충돌에 관한 백-오프 타이머를 구동하는 과정을 더 수행하도록 설정될 수 있다. 상기 백-오프 타이머가 만료되면, 상기 ICT는 상기 선택 과정을 다시 수행하도록 설정될 수 있다. 상기 복수의 기능 컴포넌트는: 적어도 하나의 메모리; 적어도 하나의 컨트롤러; 그리고 적어도 하나의 PE(Processing Element) 중에서 하나 이상을 포함할 수 있다. 상기 복수의 기능 컴포넌트는: 스케줄러와 그리고 인터페이스 중에서 하나 이상을 더 포함할 수 있다. 상기 ICT는: 상기 테스트를 위하여, 상기 하나 이상의 래퍼에게, 상기 CUT로 선택된 상기 하나 이상의 기능 컴 포넌트를 격리시키라고 지시하는 과정을 더 수행하도록 설정될 수 있다. 상기 ICT는: 상기 복수의 기능 컴포넌트들의 상태를 모니터하도록 설정된 검출기와; 상기 ICT의 동작을 관리하 도록 설정된 스케줄러와; 테스트 입력 데이터를 생성하도록 설정된 생성기와; 그리고 상기 CUT로 상기 테스트 입력 데이터를 주입하고, 상기 테스트 입력 데이터를 처리한 상기 CUT로부터 획득되는 테스트 결과를 분석하는 테스터 중에서 하나 이상을 포함할 수 있다. 상기 테스트 입력 데이터는 미리 정해진 테스트 데이터 또는 시드(seed)에 기초하여 생성된 랜덤 비트 스트림 (random bit stream)일 수 있다. 상기 ICT는: 상기 테스트가 완료된 이후, 상기 CUT로 선택된 상기 하나 이상의 기능 컴포넌트로부터 획득되는 테스트 결과를 분석하는 과정과; 그리고 상기 하나 이상의 기능 컴포넌트가 정상이라고 분석되는 것에 기초하여, 상기 하나 이상의 기능 컴포넌트를 복귀시키는 과정을 더 수행하도록 설정될 수 있다. 상기 ICT는: 상기 하나 이상의 기능 컴포넌트가 결함이 있다고 분석되는 것에 기초하여, 상기 하나 이상의 기능 컴포넌트를 비활성화하는 과정을 더 수행하도록 설정될 수 있다. 상기 NPU는 상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트를 모방(imitate)하도록 설정된 FPGA(field programmable gate array)를 더 포함할 수 있다. 상기 FPGA의 주소는 폐지(revoke)되고, 상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트의 주소로 대체될 수 있다. 상기 비활성화하는 과정은: 상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트의 주소를 폐지(revok e)하는 과정을 포함할 수 있다. 상기 비활성화하는 과정은: 상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트를 파워 오프 하거나 혹 은 턴 오프 하는 과정을 포함할 수 있다. 상기 비활성화하는 과정은: 상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트를 상기 시스템 버스로 부터 격리하거나 또는 공급 전력을 컷 오프하는 과정을 포함할 수 있다. 상기 ICT는: 상기 복수의 기능 컴포넌트가 상기 결함이 있다고 분석된 상기 하나 이상의 기능 컴포넌트의 스페 어 컴포넌트를 포함하는 경우, 상기 스페어 컴포넌트를 활성화하는 과정을 더 수행하도록 설정될 수 있다. 상기 테스트는 기능 테스트와는 다른 스캔 테스트일 수 있다. 상기 스캔 테스트를 위하여, 상기 ICT는 각 CUT 내의 복수의 플리-플롭들을 서로 연결하고, 테스트 입력을 적어도 하나의 플리-플롭으로 주입하고, 상기 CUT가 결함이 있는지 아니면 정상인지를 구동 중에 분석하기 위하여 상기 플리-플롭의 결합 로직의 동작으로부터 테스 트 결과를 획득하도록 설정될 수 있다."}
{"patent_id": "10-2022-0054878", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시에 따르면, 반도체 공장 출하 전에만 수행할 수 있었던 테스트를 구동중인 NPU 반도체 내에서도 수행할 수 있다. 본 개시에 따르면, 테스트 결과를 기초로 불량을 감지할 수 있다. 본 개시에 따르면, 공장 출하 전 발견되지 않았던 미세 불량이, 반복적인 구동으로 인한 피로 스트레스(fatigue stress) 혹은 물리적인 스트레스에 의하여 점차 증폭되더라도, 이를 발견해낼 수 있는 장점이 있다. 본 개시에 따르면, NPU가 불량, 결함 또는 손상으로 엉뚱한 인공지능(AI) 연산 결과를 출력하는 것을 검출할 수 있는 장점이 있다. 따라서, 본 개시에 따르면, 차량의 자율 주행, 드론(Drone), UAM(Urban Air Mobility), UAV(unmanned aerial vehicle) 또는 AI 로봇에 장착되는 NPU의 높은 신뢰성을 보장할 수 있다."}
{"patent_id": "10-2022-0054878", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 명세서 또는 출원에 개시되어 있는 본 개시의 개념에 따른 실시 예들에 대해서 특정한 구조적 내지 단계적 설명들은 단지 본 개시의 개념에 따른 실시 예를 설명하기 위한 목적으로 예시된 것으로, 본 개시의 개념에 따 른 실시 예들은 다양한 형태로 실시될 수 있으며 본 개시의 개념에 따른 실시 예들은 다양한 형태로 실시될 수 있으며 본 명세서 또는 출원에 설명된 실시 예들에 한정되는 것으로 해석되어서는 아니 된다. 본 개시의 개념에 따른 실시 예는 다양한 변경을 가할 수 있고 여러 가지 형태를 가질 수 있으므로 특정 실시 예들을 도면에 예시하고 본 명세서 또는 출원에 상세하게 설명하고자 한다. 그러나, 이는 본 개시의 개념에 따 른 실시 예를 특정한 개시 형태에 대해 한정하려는 것이 아니며, 본 개시의 사상 및 기술 범위에 포함되는 모든 변경, 균등물 내지 대체물을 포함하는 것으로 이해되어야 한다. 제1 및/또는 제2 등의 용어는 다양한 구성 요소들을 설명하는데 사용될 수 있지만, 상기 구성 요소들은 상기 용 어들에 의해 한정되어서는 안 된다. 상기 용어들은 하나의 구성 요소를 다른 구성 요소로부터 구별하는 목적으 로만, 예컨대 본 개시의 개념에 따른 권리 범위로부터 이탈되지 않은 채, 제1 구성요소는 제2 구성요소로 명명 될 수 있고, 유사하게 제2 구성요소는 제1 구성요소로도 명명될 수 있다. 어떤 구성요소가 다른 구성요소에 \"연결되어\" 있다거나 \"접속되어\" 있다고 언급된 때에는, 그 다른 구성요소에 직접적으로 연결되어 있거나 또는 접속되어 있을 수도 있지만, 중간에 다른 구성요소가 존재할 수도 있다고 이 해되어야 할 것이다. 반면에, 어떤 구성요소가 다른 구성요소에 \"직접 연결되어\" 있다거나 \"직접 접속되어\" 있 다고 언급된 때에는, 중간에 다른 구성요소가 존재하지 않는 것으로 이해되어야 할 것이다. 구성요소들 간의 관 계를 설명하는 다른 표현들, 즉 \"~사이에\"와 \"바로 ~사이에\" 또는 \"~에 이웃하는\"과 \"~에 직접 이웃하는\" 등도 마찬가지로 해석되어야 한다. 본 명세서에서 사용한 용어는 단지 특정한 실시 예를 설명하기 위해 사용된 것으로, 본 개시를 한정하려는 의도 가 아니다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\" 또는 \"가지다\" 등의 용어는 서술된 특징, 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부분품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 본 개시가 속하는 기술 분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가지고 있다. 일 반적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의미 를 가지는 것으로 해석되어야 하며, 본 명세서에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적 인 의미로 해석되지 않는다. 실시 예를 설명함에 있어서 본 개시가 속하는 기술 분야에 익히 알려져 있고 본 개시와 직접적으로 관련이 없는 기술 내용에 대해서는 설명을 생략한다. 이는 불필요한 설명을 생략함으로써 본 개시의 요지를 흐리지 않고 더 욱 명확히 전달하기 위함이다. <용어의 정의> 이하, 본 명세서에서 제시되는 개시들의 이해를 돕고자, 본 명세서에서 사용되는 용어들에 대하여 간략하게 정 리하기로 한다. NPU: 신경 프로세싱 유닛(Neural Processing Unit)의 약어로서, CPU(Central processing unit)과 별개로 인공 신경망 모델의 연산을 위해 특화된 프로세서를 의미할 수 있다. ANN: 인공 신경망(artificial neural network)의 약어로서, 인간의 지능을 모방하기 위하여, 인간 뇌 속의 뉴런 들(Neurons)이 시냅스(Synapse)를 통하여 연결되는 것을 모방하여, 노드들을 레이어(Layer: 계층) 구조로 연결 시킨, 네트워크를 의미할 수 있다. 인공 신경망의 구조에 대한 정보: 레이어의 개수에 대한 정보, 레이어 내의 노드의 개수, 각 노드의 값, 연산 처리 방법에 대한 정보, 각 노드에 적용되는 가중치 행렬에 대한 정보 등을 포함하는 정보이다. 인공 신경망의 데이터 지역성에 대한 정보: 신경 프로세싱 유닛이 별개의 메모리에 요청하는 데이터 접근 요청 순서에 기반하여 신경 프로세싱 유닛이 처리하는 인공신경망모델의 연산 순서를 예측하게 하는 정보이다. DNN: 심층 신경망(Deep Neural Network)의 약어로서, 보다 높은 인공 지능을 구현하기 위하여, 인공 신경망의 은닉 레이어의 개수를 늘린 것을 의미할 수 있다.CNN: 컨볼루션 신경망(Convolutional Neural Network)의 약어로서, 인간 뇌의 시각 피질에서 영상을 처리하는 것과 유사한 기능을 하는 신경망이다. 컨볼루션 신경망은 영상처리에 적합한 것으로 알려져 있으며, 입력 데이 터의 특징들을 추출하고, 특징들의 패턴을 파악하기에 용이한 것으로 알려져 있다. 커널: CNN에 적용되는 가중치 행렬을 의미할 수 있다. 커널의 값은 기계 학습을 통해서 결정될 수 있다. 이하, 첨부한 도면을 참조하여 본 개시의 바람직한 실시 예를 설명함으로써, 본 개시를 상세히 설명한다. 이하, 본 개시의 실시 예를 첨부된 도면을 참조하여 상세하게 설명한다. 도 1은 본 개시에 따른 신경 프로세싱 유닛을 설명하는 개략적인 개념도이다. 도 1에 도시된 신경 프로세싱 유닛(neural processing unit, NPU)은 인공신경망을 위한 동작을 수행하도록 특화된 프로세서이다. 인공신경망은 여러 입력 또는 자극이 들어오면 각각 가중치를 곱해 더해주고, 추가적으로 편차를 더한 값을 활 성화 함수를 통해 변형하여 전달하는 인공 뉴런들이 모인 네트워크를 의미한다. 이렇게 학습된 인공신경망은 입 력 데이터로부터 추론(inference) 결과를 출력하는데 사용될 수 있다. 상기 NPU은 전기/전자 회로로 구현된 반도체일 수 있다. 상기 전기/전자 회로라 함은 수많은 전자 소자, (예컨대 트렌지스터, 커패시터)를 포함하는 것을 의미할 수 있다. 상기 NPU은 복수의 프로세싱 엘리먼트(processing element: PE) , NPU 내부 메모리, NPU 스케 줄러, 및 NPU 인터페이스를 포함할 수 있다. 복수의 프로세싱 엘리먼트, NPU 내부 메모리, NPU 스케줄러, 및 NPU 인터페이스 각각은 수많은 트렌지스터들이 연결된 반도체 회로일 수 있다. 따 라서, 이들 중 일부는 육안으로는 식별되어 구분되기 어려울 수 있고, 동작에 의해서만 식별될 수 있다. 예컨대, 임의 회로는 복수의 프로세싱 엘리먼트으로 동작하기도 하고, 혹은 NPU 스케줄러로 동작될 수도 있다. NPU 스케줄러는 NPU의 인공신경망 추론 동작을 제어하도록 구성된 제어부의 기능을 수행 하도록 구성될 수 있다. 상기 NPU은 복수의 프로세싱 엘리먼트, 복수의 프로세싱 엘리먼트에서 추론될 수 있는 인공신경 망모델을 저장하도록 구성된 NPU 내부 메모리, 및 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 복수의 프로세싱 엘리먼트 및 NPU 내부 메모리를 제어하도록 구성된 NPU 스케줄러 를 포함할 수 있다. 여기서, 인공신경망모델은 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정 보를 포함할 수 있다. 인공신경망모델은 특정 추론 기능을 수행하도록 학습된 AI 인식모델을 의미할 수 있다. 복수의 프로세싱 엘리먼트는 인공신경망을 위한 동작을 수행할 수 있다. NPU 인터페이스는 시스템 버스를 통해서 NPU와 연결된 다양한 구성요소들, 예컨대 메모리와 통신할 수 있다. NPU 스케줄러는 신경 프로세싱 유닛의 추론 연산을 위한 복수의 프로세싱 엘리먼트의 연산 및 NPU 내부 메모리의 읽기 및 쓰기 순서를 제어하도록 구성될 수 있다. NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 복수의 프로세싱 엘리먼트 및 NPU 내부 메모리을 제어하도록 구성될 수 있다. NPU 스케줄러는 복수의 프로세싱 엘리먼트에서 작동할 인공신경망모델의 구조를 분석하거나 또는 이 미 분석된 정보를 제공받을 수 있다. 예를 들면, 인공신경망모델이 포함할 수 있는 인공신경망의 데이터는 각각 의 레이어의 노드 데이터(즉, 특징맵), 레이어들의 배치 데이터, 지역성 정보 또는 구조에 대한 정보, 각각의 레이어의 노드를 연결하는 연결망 각각의 가중치 데이터 (즉, 가중치 커널) 중 적어도 일부를 포함할 수 있다. 인공신경망의 데이터는 NPU 스케줄러 내부에 제공되는 메모리 또는 NPU 내부 메모리에 저장될 수 있 다. NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 NPU가 수행 할 인공신경망모델의 연산 순서를 스케줄링 할 수 있다. NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 인공신경망모델 의 레이어의 특징맵 및 가중치 데이터가 저장된 메모리 어드레스 값을 획득할 수 있다. 예를 들면, NPU 스케줄 러는 메모리에 저장된 인공신경망모델의 레이어의 특징맵 및 가중치 데이터가 저장된 메모리 어드레스 값을 획득할 수 있다. 따라서 NPU 스케줄러는 구동할 인공신경망모델의 레이어의 특징맵 및 가중치 데이터를 메인 메모리에서 가져와서 NPU 내부 메모리에 저장할 수 있다. 각각의 레이어의 특징맵은 대응되는 각각의 메모리 어드레스 값을 가질 수 있다. 각각의 가중치 데이터는 대응되는 각각의 메모리 어드레스 값을 가질 수 있다. NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보, 예를 들면, 인공신경망모델 의 인공신경망의 레이어들의 배치 데이터, 지역성 정보 또는 구조에 대한 정보에 기초해서 복수의 프로세싱 엘 리먼트의 연산 순서를 스케줄링 할 수 있다. NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 스케줄링 하기 때문에, 일반적인 CPU의 스케줄링 개념과 다르게 동작할 수 있다. 일반적인 CPU의 스케줄링은 공평성, 효율성, 안정성, 반응 시간 등을 고려하여, 최상의 효율을 낼 수 있도록 동작한다. 즉, 우선 순위, 연산 시간 등을 고려 해서 동일 시간내에 가장 많은 프로세싱을 수행하도록 스케줄링 한다. 종래의 CPU는 각 프로세싱의 우선 순서, 연산 처리 시간 등의 데이터를 고려하여 작업을 스케줄링 하는 알고리 즘을 사용하였다. 이와 다르게 NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 결 정된 NPU의 프로세싱 순서대로 NPU를 제어할 수 있다. 더 나아가면, NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보 및/또는 사용 하려는 신경 프로세싱 유닛의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 결정된 프로세싱 순 서대로 NPU를 구동할 수 있다. 단, 본 개시는 NPU의 데이터 지역성 정보 또는 구조에 대한 정보에 제한되지 않는다. NPU 스케줄러는 인공신경망의 데이터 지역성 정보 또는 구조에 대한 정보를 저장하도록 구성될 수 있다. 즉, NPU 스케줄러는 적어도 인공신경망모델의 인공신경망의 데이터 지역성 정보 또는 구조에 대한 정보만 활용하더라도 프로세싱 순서를 결정할 수 있다. 더 나아가서, NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보 및 NPU의 데이터 지역성 정보 또는 구조에 대한 정보를 고려하여 NPU의 프로세싱 순서를 결정할 수 있다. 또한, 결 정된 프로세싱 순서대로 NPU의 프로세싱 최적화도 가능하다. 복수의 프로세싱 엘리먼트는 인공신경망의 특징맵과 가중치 데이터를 연산하도록 구성된 복수의 프로세싱 엘리먼트들(PE1 to PE12)이 배치된 구성을 의미한다. 각각의 프로세싱 엘리먼트는 MAC (multiply and accumulate) 연산기 및/또는 ALU (Arithmetic Logic Unit) 연산기를 포함할 수 있다. 단, 본 개시에 따른 예시 들은 이에 제한되지 않는다. 각각의 프로세싱 엘리먼트는 추가적인 특수 기능을 처리하기 위해 추가적인 특수 기능 유닛을 선택적으로 더 포 함하도록 구성될 수 있다. 예를 들면, 프로세싱 엘리먼트(PE)는 배치-정규화 유닛, 활성화 함수 유닛, 인터폴레이션 유닛 등을 더 포함하 도록 변형 실시되는 것도 가능하다. 도 1에서는 예시적으로 복수의 프로세싱 엘리먼트들이 도시되었지만, 하나의 프로세싱 엘리먼트 내부에 MAC을 대체하여, 복수의 곱셈기(multiplier) 및 가산기 트리(adder tree)로 구현된 연산기들이 병렬로 배치되어 구성 되는 것도 가능하다. 이러한 경우, 복수의 프로세싱 엘리먼트는 복수의 연산기를 포함하는 적어도 하나의 프로세싱 엘리먼트로 지칭되는 것도 가능하다. 복수의 프로세싱 엘리먼트는 복수의 프로세싱 엘리먼트들(PE1 to PE12)을 포함하도록 구성된다. 도 1에 도 시된 복수의 프로세싱 엘리먼트들(PE1 to PE12)은 단지 설명의 편의를 위한 예시이며, 복수의 프로세싱 엘리먼 트들(PE1 to PE12)의 개수는 제한되지 않는다. 복수의 프로세싱 엘리먼트들(PE1 to PE12)의 개수에 의해서 복수 의 프로세싱 엘리먼트의 크기 또는 개수가 결정될 수 있다. 복수의 프로세싱 엘리먼트의 크기는 N x M 행렬 형태로 구현될 수 있다. 여기서 N 과 M은 0보다 큰 정수이다. 복수의 프로세싱 엘리먼트는 N x M 개의 프로세싱 엘리먼트를 포함할 수 있다. 즉, 프로세싱 엘리먼트는 1개 이상일 수 있다. 복수의 프로세싱 엘리먼트의 크기는 NPU이 작동하는 인공신경망모델의 특성을 고려하여 설계할 수 있 다. 복수의 프로세싱 엘리먼트는 인공신경망 연산에 필요한 덧셈, 곱셈, 누산 등의 기능을 수행하도록 구성된 다. 다르게 설명하면, 복수의 프로세싱 엘리먼트는 MAC(multiplication and accumulation) 연산을 수행하 도록 구성될 수 있다. 이하 복수의 프로세싱 엘리먼트 중 제1 프로세싱 엘리먼트(PE1)를 예를 들어 설명한다. 도 2는 본 개시에 적용될 수 있는 복수의 프로세싱 엘리먼트 중 하나의 프로세싱 엘리먼트를 설명하는 개략적인 개념도이다. 본 개시의 일 예시에 따른 NPU은 복수의 프로세싱 엘리먼트, 복수의 프로세싱 엘리먼트에서 추 론될 수 있는 인공신경망모델을 저장하도록 구성된 NPU 내부 메모리 및 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 복수의 프로세싱 엘리먼트 및 NPU 내부 메모리을 제어하도록 구성된 NPU 스케줄러를 포함하고, 복수의 프로세싱 엘리먼트는 MAC 연산을 수행하도록 구성되고, 복 수의 프로세싱 엘리먼트는 MAC 연산 결과를 양자화해서 출력하도록 구성될 수 있다. 단, 본 개시의 예시들 은 이에 제한되지 않는다. NPU 내부 메모리은 메모리 크기와 인공신경망모델의 데이터 크기에 따라 인공신경망모델의 전부 또는 일부 를 저장할 수 있다. 제1 프로세싱 엘리먼트(PE1)는 곱셈기, 가산기, 누산기, 및 비트 양자화 유닛을 포함할 수 있다. 단, 본 개시에 따른 예시들은 이에 제한되지 않으며, 복수의 프로세싱 엘리먼트는 인공신경망의 연 산 특성을 고려하여 변형 실시될 수도 있다. 곱셈기는 입력 받은 (N)bit 데이터와 (M)bit 데이터를 곱한다. 곱셈기의 연산 값은 (N+M)bit 데이터 로 출력된다. 곱셈기는 하나의 변수와 하나의 상수를 입력 받도록 구성될 수 있다. 누산기는 (L)loops 횟수만큼 가산기를 사용하여 곱셈기의 연산 값과 누산기의 연산 값을 누산 한다. 따라서 누산기의 출력부와 입력부의 데이터의 비트 폭은 (N+M+log2(L))bit로 출력될 수 있다. 여기서 L은 0보다 큰 정수이다. 누산기는 누산이 종료되면, 초기화 신호(initialization reset)를 인가받아서 누산기 내부에 저장된 데이터를 0으로 초기화 할 수 있다. 단, 본 개시에 따른 예시들은 이에 제한되지 않는다. 비트 양자화 유닛은 누산기에서 출력되는 데이터의 비트 폭을 저감할 수 있다. 비트 양자화 유닛 은 NPU 스케줄러에 의해서 제어될 수 있다. 양자화된 데이터의 비트 폭은 (X)bit로 출력될 수 있다. 여기서 X는 0보다 큰 정수이다. 상술한 구성에 따르면, 복수의 프로세싱 엘리먼트는 MAC 연산을 수행하도 록 구성되고, 복수의 프로세싱 엘리먼트는 MAC 연산 결과를 양자화해서 출력할 수 있는 효과가 있다. 특히 이러한 양자화는 (L)loops가 증가할수록 소비 전력을 더 절감할 수 있는 효과가 있다. 또한 소비 전력이 저감되 면 발열도 저감할 수 있는 효과가 있다. 특히 발열을 저감하면 NPU의 고온에 의한 오동작 발생 가능성을 저감할 수 있는 효과가 있다. 비트 양자화 유닛의 출력 데이터(X)bit은 다음 레이어의 노드 데이터 또는 합성곱의 입력 데이터가 될 수 있다. 만약 인공신경망모델이 양자화되었다면, 비트 양자화 유닛은 양자화된 정보를 인공신경망모델에서 제공받도록 구성될 수 있다. 단, 이에 제한되지 않으며, NPU 스케줄러는 인공신경망모델을 분석하여 양자 화된 정보를 추출하도록 구성되는 것도 가능하다. 따라서 양자화된 데이터 크기에 대응되도록, 출력 데이터 (X)bit를 양자화 된 비트 폭으로 변환하여 출력될 수 있다. 비트 양자화 유닛의 출력 데이터(X)bit는 양자 화된 비트 폭으로 NPU 내부 메모리에 저장될 수 있다. 본 개시의 일 예시에 따른 NPU의 복수의 프로세싱 엘리먼트는 곱셈기, 가산기, 및 누산기 를 포함한다. 비트 양자화 유닛은 양자화 적용 여부에 따라 취사 선택될 수 있다. 도 3은 도 1에 도시된 NPU의 변형예를 나타낸 예시도이다. 도 3에 도시된 NPU은 도 1에 예시적으로 도시된 프로세싱 유닛과 비교하면, 복수의 프로세싱 엘리먼 트를 제외하곤 실질적으로 동일하기 때문에, 이하 단지 설명의 편의를 위해서 중복 설명은 생략할 수있다. 도 3에 예시적으로 도시된 복수의 프로세싱 엘리먼트는 복수의 프로세싱 엘리먼트들(PE1 to PE12) 외에, 각각의 프로세싱 엘리먼트들(PE1 to PE12)에 대응되는 각각의 레지스터 파일들(RF1 to RF12)을 더 포함할 수 있 다. 도 3에 도시된 복수의 프로세싱 엘리먼트들(PE1 to PE12) 및 복수의 레지스터 파일들(RF1 to RF12)은 단지 설명 의 편의를 위한 예시이며, 복수의 프로세싱 엘리먼트들(PE1 to PE12) 및 복수의 레지스터 파일들(RF1 to RF12) 의 개수는 제한되지 않는다. 복수의 프로세싱 엘리먼트들(PE1 to PE12) 및 복수의 레지스터 파일들(RF1 to RF12)의 개수에 의해서 복수의 프 로세싱 엘리먼트의 크기 또는 개수가 결정될 수 있다. 복수의 프로세싱 엘리먼트 및 복수의 레지스터 파일들(RF1 to RF12)의 크기는 N x M 행렬 형태로 구현될 수 있다. 여기서 N 과 M은 0보다 큰 정수이다. 복수의 프로세싱 엘리먼트의 어레이 크기는 NPU이 작동하는 인공신경망모델의 특성을 고려하여 설계 할 수 있다. 부연 설명하면, 레지스터 파일의 메모리 크기는 작동할 인공신경망모델의 데이터 크기, 요구되는 동작 속도, 요구되는 소비 전력 등을 고려하여 결정될 수 있다. NPU의 레지스터 파일들(RF1 to RF12)은 프로세싱 엘리먼트들(PE1 to PE12)과 직접 연결된 정적 메모리 유 닛이다. 레지스터 파일들(RF1 to RF12)은 예를 들면, 플립플롭, 및/또는 래치 등으로 구성될 수 있다. 레지스터 파일들(RF1 to RF12)은 대응되는 프로세싱 엘리먼트들(PE1 to PE12)의 MAC 연산 값을 저장하도록 구성될 수 있 다. 레지스터 파일들(RF1 to RF12)은 NPU 내부 메모리와 가중치 데이터 및/또는 노드 데이터를 제공하거나 제공받도록 구성될 수 있다. 레지스터 파일들(RF1 to RF12)은 MAC 연산 시 누산기의 임시 메모리의 기능을 수행하도록 구성되는 것도 가능하 다. 도 4는 예시적인 인공신경망모델을 설명하는 개략적인 개념도이다. 이하 NPU에서 작동될 수 있는 예시적인 인공신경망모델(110-10)의 연산에 대하여 설명한다. 도 4의 예시적인 인공신경망모델(110-10)은 도 1 또는 도 3에 도시된 NPU에서 학습되거나 별도의 기계 학 습 장치에서 학습된 인공신경망일 수 있다. 인공신경망 모델은 객체 인식, 음성 인식 등 다양한 추론 기능을 수 행하도록 학습된 인공신경망일 수 있다. 인공신경망모델(110-10)은 심층 신경망(DNN, Deep Neural Network)일 수 있다. 단, 본 개시의 예시들에 따른 인공신경망모델(110-10)은 심층 신경망에 제한되지 않는다. 예를 들면, 인공신경망모델은 Object Detection, Object Segmentation, Image/Video Reconstruction, Image/Video Enhancement, Object Tracking, Event Recognition, Event Prediction, Anomaly Detection, Density Estimation, Event Search, Measurement 등의 추론을 수행하도록 학습될 모델일 수 있다. 예를 들면, 인공신경망모델은 Bisenet, Shelfnet, Alexnet, Densenet, Efficientnet, EfficientDet, Googlenet, Mnasnet, Mobilenet, Resnet, Shufflenet, Squeezenet, VGG, Yolo, RNN, CNN, DBN, RBM, LSTM 등 의 모델일 수 있다. 단, 본 개시는 이에 제한되지 않으며, NPU에서 동작할 새로운 인공신경망모델이 꾸준히 발 표되고 있다. 단, 본 개시는 상술한 모델들에 제한되지 않는다. 또한 인공신경망모델(110-10)은 적어도 두 개의 서로 다른 모 델들에 기초한 앙상블 모델일 수도 있다. 인공신경망모델(110-10)은 NPU의 NPU 내부 메모리에 저장될 수 있다. 이하 도 4를 참조하여 예시적인 인공신경망모델(110-10)에 의환 추론 과정이 NPU에 의해서 수행되는 것에 관해 설명한다. 인공신경망모델(110-10)은 입력 레이어(110-11), 제1 연결망(110-12), 제1 은닉 레이어(110-13), 제2 연결망 (110-14), 제2 은닉 레이어(110-15), 제3 연결망(110-16), 및 출력 레이어(110-17)을 포함하는 예시적인 심층 신경망 모델이다. 단, 본 개시는 도 4에 도시된 인공신경망모델에만 제한되는 것은 아니다. 제1 은닉 레이어 (110-13) 및 제2 은닉 레이어(110-15)는 복수의 은닉 레이어로 지칭되는 것도 가능하다.입력 레이어(110-11)는 예시적으로, x1 및 x2 입력 노드를 포함할 수 있다. 즉, 입력 레이어(110-11)는 2개의 입력 값에 대한 정보를 포함할 수 있다. 도 1 또는 도 3에 도시된 NPU 스케줄러는 입력 레이어(110-11)로 부터의 입력 값에 대한 정보가 저장되는 메모리 어드레스를 도 1 또는 도 3에 도시된 NPU 내부 메모리에 설정할 수 있다. 제1 연결망(110-12)은 예시적으로, 입력 레이어(110-11)의 각각의 노드를 제1 은닉 레이어(110-13)의 각각의 노 드로 연결시키기 위한 6개의 가중치 값에 대한 정보를 포함할 수 있다. 도 1 또는 도 3에 도시된 NPU 스케줄러 는 제1 연결망(110-12)의 가중치 값에 대한 정보가 저장되는 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다. 각각의 가중치 값은 입력 노드 값과 곱해지고, 곱해진 값들의 누산된 값이 제1 은닉 레이어 (110-13)에 저장된다. 여기서 노드들은 특징맵으로 지칭될 수 있다. 제1 은닉 레이어(110-13)는 예시적으로 a1, a2, 및 a3 노드를 포함할 수 있다. 즉, 제1 은닉 레이어(110-13)는 3개의 노드 값에 대한 정보를 포함할 수 있다. 도 1 또는 도 3에 도시된 NPU 스케줄러는 제1 은닉 레이어 (110-13)의 노드 값에 대한 정보를 저장시키기 위한 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다. NPU 스케줄러는 제1 프로세싱 엘리먼트(PE1)가 제1 은닉 레이어(110-13)의 a1 노드의 MAC 연산을 수행하도 록 연산 순서를 스케줄링 하도록 구성될 수 있다. NPU 스케줄러는 제2 프로세싱 엘리먼트(PE2)가 제1 은닉 레이어(110-13)의 a2 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. NPU 스케줄 러는 제3 프로세싱 엘리먼트(PE3)가 제1 은닉 레이어(110-13)의 a3 노드의 MAC 연산을 수행하도록 연산 순 서를 스케줄링 하도록 구성될 수 있다. 여기서 NPU 스케줄러는 3개의 프로세싱 엘리먼트들이 병렬로 동시 에 MAC 연산을 각각 수행하도록 연산 순서를 미리 스케줄링 할 수 있다. 제2 연결망(110-14)은 예시적으로, 제1 은닉 레이어(110-13)의 각각의 노드를 제2 은닉 레이어(110-15)의 각각 의 노드로 연결시키기 위한 9개의 가중치 값에 대한 정보를 포함할 수 있다. 도 1 또는 도 3에 도시된 NPU 스케 줄러는 제2 연결망(110-14)의 가중치 값에 대한 정보를 저장시키기 위한 메모리 어드레스를 NPU 내부 메모 리에 설정할 수 있다. 상기 제2 연결망(110-14)의 가중치 값은 제1 은닉 레이어(110-13)로부터 입력되는 노드 값과 각기 곱해지고, 곱해진 값들의 누산된 값이 제2 은닉 레이어(110-15)에 저장된다. 제2 은닉 레이어(110-15)는 예시적으로 b1, b2, 및 b3 노드를 포함할 수 있다. 즉, 제2 은닉 레이어(110-15)는 3개의 노드 값에 대한 정보를 포함할 수 있다. NPU 스케줄러는 제2 은닉 레이어(110-15)의 노드 값에 대한 정보를 저장시키기 위한 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다. NPU 스케줄러는 제4 프로세싱 엘리먼트(PE4)가 제2 은닉 레이어(110-15)의 b1 노드의 MAC 연산을 수행하도 록 연산 순서를 스케줄링 하도록 구성될 수 있다. NPU 스케줄러는 제5 프로세싱 엘리먼트(PE5)가 제2 은닉 레이어(110-15)의 b2 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. NPU 스케줄 러는 제6 프로세싱 엘리먼트(PE6)가 제2 은닉 레이어(110-15)의 b3 노드의 MAC 연산을 수행하도록 연산 순 서를 스케줄링 하도록 구성될 수 있다. 여기서 NPU 스케줄러는 3개의 프로세싱 엘리먼트들이 병렬로 동시에 MAC 연산을 각각 수행하도록 연산 순 서를 미리 스케줄링 할 수 있다. 여기서 NPU 스케줄러는 인공신경망모델의 제1 은닉 레이어(110-13)의 MAC 연산 이후 제2 은닉 레이어(110- 15)의 연산이 수행되도록 스케줄링을 결정할 수 있다. 즉, NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 복수의 프로 세싱 엘리먼트 및 NPU 내부 메모리을 제어하도록 구성될 수 있다. 제3 연결망(110-16)은 예시적으로, 제2 은닉 레이어(110-15)의 각각의 노드와 출력 레이어(110-17)의 각각의 노 드를 연결하는 6개의 가중치 값에 대한 정보를 포함할 수 있다. NPU 스케줄러는 제3 연결망(110-16)의 가 중치 값에 대한 정보를 저장시키기 위한 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다. 제3 연결 망(110-16)의 가중치 값은 제2 은닉 레이어(110-15)로부터 입력되는 노드 값과 각기 곱해지고, 곱해진 값들의 누산된 값이 출력 레이어(110-17)에 저장된다. 출력 레이어(110-17)는 예시적으로 y1, 및 y2 노드를 포함할 수 있다. 즉, 출력 레이어(110-17)는 2개의 노드 값에 대한 정보를 포함할 수 있다. NPU 스케줄러는 출력 레이어(110-17)의 노드 값에 대한 정보를 저장시 키기 위해 메모리 어드레스를 NPU 내부 메모리에 설정할 수 있다.NPU 스케줄러는 제7 프로세싱 엘리먼트(PE7)가 출력 레이어(110-17)의 y1 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. NPU 스케줄러는 제8 프로세싱 엘리먼트(PE8)가 출력 레이어 (110-15)의 y2 노드의 MAC 연산을 수행하도록 연산 순서를 스케줄링 하도록 구성될 수 있다. 여기서 NPU 스케줄러는 2개의 프로세싱 엘리먼트들이 병렬로 동시에 MAC 연산을 각각 수행하도록 연산 순 서를 미리 스케줄링 할 수 있다. 여기서 NPU 스케줄러는 인공신경망모델의 제2 은닉 레이어(110-15)의 MAC 연산 이후 출력 레이어(110- 17)의 연산이 수행되도록 스케줄링을 결정할 수 있다. 즉, NPU 스케줄러는 인공신경망모델의 데이터 지역성 정보 또는 구조에 대한 정보에 기초하여 복수의 프로 세싱 엘리먼트 및 NPU 내부 메모리을 제어하도록 구성될 수 있다. 즉, NPU 스케줄러는 복수의 프로세싱 엘리먼트에서 작동할 인공신경망모델의 구조를 분석하거나 또는 분석된 정보를 제공받을 수 있다. 인공신경망모델이 포함할 수 있는 인공신경망의 정보는 각각의 레이어의 노드 값에 대한 정보, 레이어들의 배치 데이터 지역성 정보 또는 구조에 대한 정보, 각각의 레이어의 노드를 연결하 는 연결망 각각의 가중치 값에 대한 정보를 포함할 수 있다. NPU 스케줄러는 예시적인 인공신경망모델(110-10)의 데이터 지역성 정보 또는 구조에 대한 정보를 제공받 았기 때문에, NPU 스케줄러는 인공신경망모델(110-10)의 입력부터 출력까지의 연산 순서를 파악할 수 있다. 따라서, NPU 스케줄러는 각각의 레이어의 MAC 연산 값들이 저장되는 메모리 어드레스를 스케줄링 순서를 고려해서 NPU 내부 메모리에 설정할 수 있다. NPU 내부 메모리는 NPU의 추론 연산이 지속되는 동안 NPU 내부 메모리에 저장된 연결망들의 가 중치 데이터를 보존하도록 구성될 수 있다. 따라서 메모리 읽기 쓰기 동작을 저감할 수 있는 효과가 있다. 즉, NPU 내부 메모리는 추론 연산이 지속되는 동안 NPU 내부 메모리에 저장된 MAC 연산 값을 재사용 하도록 구성될 수 있다. 도 5a는 컨볼류션 신경망의 기본 구조를 설명하기 위한 도면이다. 도 5a를 참조하면, 컨볼류션 신경망은 하나 또는 여러 개의 컨볼류션 레이어(convolutional layer)와 통합 레이 어(pooling layer), 완전하게 연결된 레이어(fully connected layer)들의 조합일 수 있다. 본 개시의 예시에서, 컨볼류션 신경망은 채널마다 채널의 입력 영상의 특징을 추출하는 커널이 존재한다. 커널 은 2차원 행렬로 구성될 수 있으며, 입력 데이터를 순회하면서 합성곱 연산 수행한다. 커널의 크기는 임의로 결 정될 수 있으며, 커널이 입력 데이터를 순회하는 간격(stride) 또한 임의로 결정될 수 있다. 커널 하나당 입력 데이터 전체에 대한 합성곱 결과는 특징맵(feature map) 또는 활성화 맵으로 지칭될 수 있다. 이하에서 커널은 일 세트의 가중치 값들 또는 복수의 세트의 가중치 값들을 포함할 수 있다. 각 레이어 별 커널의 개수는 채널의 개수로 지칭될 수 있다. 이처럼 합성곱 연산은 입력 데이터와 커널의 조합으로 이루어진 연산이므로, 이후 비선형성을 추가하기 위한 활 성화 함수가 적용될 수 있다. 합성곱 연산의 결과인 특징맵에 활성화 함수가 적용되면 활성화 맵으로 지칭될 수 있다. 구체적으로 도 5a를 참조하면, 컨볼류션 신경망은 적어도 하나의 컨볼류션 레이어, 적어도 하나의 풀링 레이어, 및 적어도 하나의 완전 연결 레이어를 포함한다. 예를 들면, 합성곱(컨볼류션)은, 입력 데이터의 크기(통상적으로 1Х1, 3Х3 또는 5Х5 행렬)와 출력 피처 맵 (Feature Map)의 깊이(커널의 수)와 같은 두 개의 주요 파라미터에 의해 정의될 수 있다. 이러한 주요 파라미터 는 합성곱에 의해 연산 될 수 있다. 이들 합성곱은, 깊이 32에서 시작하여, 깊이 64로 계속되며, 깊이 128 또는 256에서 종료될 수 있다. 합성곱 연산은, 입력 데이터인 입력 이미지 행렬 위로 3Х3 또는 5Х5 크기의 커널 (kernel)을 슬라이딩하여 커널의 각 가중치와 겹쳐지는 입력 이미지 행렬의 각 원소를 곱한 후 이들을 모두 더 하는 연산을 의미할 수 있다. 이와 같이 생성된 출력 특징맵에 활성화 함수가 적용되어 활성화 맵이 최종적으로 출력될 수 있다. 또한, 현재 레이어에서의 사용된 가중치는 합성곱을 통해 다음 레이어에 전달될 수 있다. 풀링 레이어는 출력 데이터(즉,활성화 맵)을 다운 샘플링하여 특징맵의 크기를 줄이는 풀링 연산을 수행할 수 있다. 예를 들어, 풀링 연산은 최대 풀링(max pooling) 및/또는 평균 풀링(average pooling)을 포함할 수 있으나, 이에 한정되지 않는다. 최대 풀링 연산은 커널을 이용하며, 특징맵과 커널이 슬라이딩되어 커널과 겹쳐지는 특징맵의 영역에서 최대 값 을 출력한다. 평균 풀링 연산은 특징맵과 커널이 슬라이딩되어 커널과 겹쳐지는 특징맵의 영역 내에서 평균값을 출력한다. 이처럼 풀링 연산에 의해 특징맵의 크기가 줄어들기 때문에 특징맵의 가중치 개수 또한 줄어든다. 완전 연결 레이어는 풀링 레이어를 통해서 출력된 데이터를 복수의 클래스(즉, 추정값)로 분류하고, 분류된 클 래스 및 이에 대한 점수(score)를 출력할 수 있다. 풀링 레이어를 통해서 출력된 데이터는 3차원 특징맵 형태를 이루며, 이러한 3차원 특징맵이 1차원 벡터로 변환되어 완전 연결 레이어로 입력될 수 있다. 도 5b은 컨볼류션 신경망의 동작을 이해하기 쉽게 나타낸 종합도이다. 도 5b를 참조하면, 예시적으로 입력 이미지가 5 x 5 크기를 갖는 2차원적 행렬인 것으로 나타나 있다. 또한, 도 5b에는 예시적으로 3개의 채널, 즉 채널 1, 채널 2, 채널 3이 사용되는 것으로 나타내었다. 먼저, 레이어 1의 합성곱 동작에 대해서 설명하기로 한다. 입력 이미지는 레이어 1의 첫 번째 노드에서 채널 1을 위한 커널 1과 합성곱되고, 그 결과로서 특징맵1이 출력 된다. 또한, 상기 입력 이미지는 레이어 1의 두 번째 노드에서 채널 2를 위한 커널 2와 합성곱되고 그 결과로서 특징맵 2가 출력된다. 또한, 상기 입력 이미지는 세 번째 노드에서 채널 3을 위한 커널 3과 합성곱되고, 그 결 과로서 특징맵3이 출력된다. 다음으로, 레이어 2의 폴링(pooling) 동작에 대해서 설명하기로 한다. 상기 레이어 1 로부터 출력되는 특징맵1, 특징맵2, 특징맵3은 레이어 2의 3개의 노드로 입력된다. 레이어 2는 레이어 1로부터 출력되는 특징맵들을 입력으로 받아서 폴링(pooling)을 수행할 수 있다. 상기 폴링이라 함은 크 기를 줄이거나 행렬 내의 특정 값을 강조할 수 있다. 폴링 방식으로는 최대값 폴링과 평균 폴링, 최소값 폴링이 있다. 최대값 폴링은 행렬의 특정 영역 안에 값의 최댓값을 모으기 위해서 사용되고, 평균 폴링은 특정 영역내 의 평균을 구하기 위해서 사용될 수 있다. 각각의 합성곱을 처리하기 위해서 NPU의 프로세싱 엘리먼트들(PE1 to PE12)은 MAC 연산을 수행하도록 구성 된다. 도 5b의 예시에서는 5 x 5 행렬의 피처맵이 폴링에 의하여 4x4 행렬로 크기가 줄어지는 것으로 나타내었다. 구체적으로, 레이어 2의 첫 번째 노드는 채널 1을 위한 특징맵1을 입력으로 받아 폴링을 수행한 후, 예컨대 4x4 행렬로 출력한다. 레이어 2의 두 번째 노드는 채널 2을 위한 특징맵2을 입력으로 받아 폴링을 수행한 후, 예컨 대 4x4 행렬로 출력한다. 레이어 2의 세 번째 노드는 채널 3을 위한 특징맵3을 입력으로 받아 폴링을 수행한 후, 예컨대 4x4 행렬로 출력한다. 다음으로, 레이어 3의 합성곱 동작에 대해서 설명하기로 한다. 레이어 3의 첫 번째 노드는 레이어 2의 첫 번째 노드로부터의 출력을 입력으로 받아, 커널 4와 합성곱을 수행하 고, 그 결과를 출력한다. 레이어 3의 두 번째 노드는 레이어 2의 두 번째 노드로부터의 출력을 입력으로 받아, 채널 2를 위한 커널 5와 합성곱을 수행하고, 그 결과를 출력한다. 마찬가지로, 레이어 3의 세 번째 노드는 레이 어 2의 세 번째 노드로부터의 출력을 입력으로 받아, 채널 3을 위한 커널 6과 합성곱을 수행하고, 그 결과를 출 력한다. 이와 같이 합성곱과 폴링이 반복되고 최종적으로는, 도 5a과 같이 fully connected로 출력될 수 있다. 해당 출 력은 다시 이미지 인식을 위한 인공 신경망으로 입력될 수 있다. <본 명세서의 개시에 대한 설명> 이하에서는 단일 NPU 반도체를 위주로 설명되지만, 본 명세서의 개시는 이에만 한정되는 것은 아니며, 본 개시 의 내용은 SiP(System in Package) 혹은 PCB(Printed circuit board) 기반 보드 레벨 시스템에도 적용될 수 있 다. 예를 들어, 각 기능 컴포넌트는 독립 반도체 칩으로 구현되고, PCB 상에 형성된 전기 전도성 패턴 (electrically conductive pattern)에 의해서 구현되는 시스템 버스를 통해 서로 연결되는 형태로 구현될 수 있 다. 도 6a는 테스트 기능을 갖춘 NPU의 구성을 제1 예시에 따라 나타낸 블록도이다. 도 6a을 참조하면, 예시적인 NPU은 복수의 기능 컴포넌트들(functional components)과, ICT(In-system Component Tester)와, 그리고 하나 이상의 래퍼 를 포함할 수 있다. 래퍼는 서로 통신하는 구성요소들의 인터페이스를 맞출 수 있다. 따라서---, 래퍼는 인터페이스 회로로 지칭되 는 것도 가능하다. 상기 복수의 기능 컴포넌트들은 복수의 프로세싱 엘리먼트와, 내부 메모리와, 컨트롤러와, 인터 페이스을 포함할 수 있다. 상기 인터페이스는 BIU(Bus Interface Unit)으로 불릴 수도 있다. 상기 컨트롤러는 스케줄러를 포함할 수 있다. 단 본 개시의 예시들을 이에 제한되지 않으며, 상기 복수의 기능 컴포넌트들 중 적어도 일부는 삭제되는 것도 가능하다. 단 본 개시의 예시들을 이에 제한되지 않으며, 상술한 상기 복수의 기능 컴포넌트들 이외의 다른 기 능 컴포넌트를 더 포함하는 것도 가능하다. 상기 복수의 프로세싱 엘리먼트는 인터페이스을 통해 컨트롤러에 연결될 수 있다. 마찬가지로, 상기 메모리는 인터페이스을 통해 컨트롤러에 연결될 수 있다. 상기 인터페이스는 상기 래퍼에 의해서 모니터링된다. 구체적으로, 상기 래퍼는 상기 인터페이 스를 통하여 상기 컨트롤러가 상기 복수의 프로세싱 엘리먼트를 제어하는 것을 모니터링할 수 있다. 또한, 상기 래퍼는 상기 인터페이스를 통하여 상기 컨트롤러가 상기 메모리를 제어 하는 것을 모니터링할 수 있다. 상기 ICT는 전용의 신호 채널을 통해 컨트롤러에 연결될 수 있다. 또한 상기 ICT는 전용의 신호 채널을 통해 래퍼과 연결될 수 있다. 래퍼는 상기 ICT와 전용 신호 채널을 통해 연결될 수 있다. 또한, 래퍼는 전용의 신호 채널을 통해 인터페이스에 연결될 수 있다. 또한, 래퍼는 상기 인터페이스를 통하여 각 기능 컴포넌트 (functional components)에 연결될 수 있다. 상기 ICT는 상기 컨트롤러를 직접 모니터링 하거나 혹은 래퍼를 통해, 상기 복수의 기능 컴포넌 트들의 상태를 모니터링할 수 있다. 각 기능 컴포넌트는 유휴 상태(idle state)이거나 사용 상태(busy state)일 수 있다. 유휴 상태의 기능 컴포넌트가 찾아지면, 상기 ICT는 해당 기능 컴포넌트를 테스트될 컴포넌트(component under test: CUT)로 선택할 수 있다. 만약 복수의 기능 컴포넌트들이 유휴 상태인 경우, 상기 ICT는 미리 설정된 규칙에 따라 어느 하나의 기능 컴포넌트를 CUT로 선택할 수 있다. 만약 복수의 기능 컴포넌트들이 유휴 상태인 경우, 상기 ICT는 랜덤으로 어느 하나의 기능 컴포넌트를 CUT 로 선택할 수 있다. 그러면, 상기 ICT는 상기 CUT로 선택된 기능 컴포넌트와 상기 인터페이스 간의 연결을 차단하거나, 상기 인터페이스 로부터 격리(isolate)시킬 수 있다. 이를 위해서, 상기 ICT는 상기 래퍼로 하여금 해당 기능 컴포넌트를 인터페이스로부터 차단 또는 격리하라고 지시할 수 있다. 보다 구체적으로, 상기 ICT는 상기 CUT로 선택된 기능 컴포넌트와 상기 인터페이스 간의 연결을 상 기 래퍼를 통해 차단시킨 후, 상기 래퍼가 상기 CUT로 선택된 기능 컴포넌트를 대신하여, 상기 인터 페이스로 신호를 전송하도록 지시할 수 있다. 이때, 상기 인터페이스로 전송되는 신호는, 상기 CUT로 선택된 기능 컴포넌트가 유휴 상태일 때 상기 인터 페이스로 전송하는 신호일 수 있다. 이를 위해, 해당 래퍼는, 상기 CUT로 선택된 기능 컴포넌트가 상 기 유휴 상태일 때, 상기 인터페이스로 전송하는 신호를 모니터링(혹은 overhear)하여 저장할 수 있다. 그 리고, 해당 래퍼는 상기 저장된 신호를 재생성하여 상기 인터페이스로 전송할 수 있다. 한편, 해당 래퍼는 또한, 상기 인터페이스로부터의 신호를 검출할 수 있다. 이후, 상기 ICT는 상기 CUT로 선택된 기능 컴포넌트에 대해서 테스트를 수행할 수 있다. 구체적으로, 상기 규칙은 수행 미션에 따른 우선순위 규칙, 기능 컴포넌트들 간의 우선순위에 대한 규칙, 해당 기능 컴포넌트에 대한 스페어(spare) 존재 유무에 따른 규칙, 테스트 횟수로 정의되는 규칙, 이전 테스트 결과 로 정의되는 규칙 중 하나 이상을 포함할 수 있다. 상기 테스트를 시작하려는 시점 혹은 상기 테스트를 수행하는 도중에, 상기 CUT로 선택된 기능 컴포넌트에 대한 상기 인터페이스로부터의 액세스로 인하여 충돌이 발생되면, 상기 ICT는 상기 충돌을 검출할 수 있다. 그러면, 상기 ICT는 상기 테스트를 중지하고, 충돌에 대한 백-오프(back-off) 타이머를 구동할 수 있다. 그리고, 상기 ICT는 상기 CUT로 선택되었던 기능 컴포넌트의 연결을 상기 인터페이스로 반환할 수 있 다. 한편, 상기 충돌에 대한 백 오프 타이머가 만료하면, 상기 ICT는 해당 기능 컴포넌트가 다시 유휴 상태로 진입하는지 모니터링할 수 있다. 만약 해당 기능 컴포넌트가 다시 유휴 상태로 진입하게 되면, 상기 ICT는 해당 기능 컴포넌트를 다시 CUT로 선택할 수 있다. 만약 상기 충돌이 검출되지 않았다면, 상기 ICT는 상기 테스트를 계속 진행하고, 테스트가 완료되면 그 테 스트 결과를 분석할 수 있다. 상기 테스트는 상기 잘못 제조되었는지, 아니면 손상(compromised)되었는지, 아니면 고장났는지를 판별하기 위 한 것일 수 있다. 상기 손상 또는 고장은 반복적인 사용으로 인한 피로 스트레스(fatigue stress)로 인한 것일 수도 있고 또는 물리적인 스트레스, 예컨대 열, EMP(electromagnetic pulse) 등에 의한 것일 수 있다. 즉, 상기 테스트 결과를 기초로 불량을 감지하도록 구성될 수 있다. 상기 테스트가 복수의 프로세싱 엘리먼트에 대해서 수행될 경우에 대해서 설명하기로 한다. 테스트는 후술 하는 바와 같이 2가지 종류 즉 기능 테스트와 스캔 테스트가 있다. 먼저 상기 복수의 프로세싱 엘리먼트에 대해서 기능 테스트를 수행하는 경우, 상기 ICT는 미리 정해 진 ANN 테스트 모델과 테스트 입력이 상기 복수의 프로세싱 엘리먼트에 입력될 수 있다. 상기 복수의 프 로세싱 엘리먼트가 상기 입력된 ANN 테스트 모델을 이용하여 상기 테스트 입력에 대한 추론 결과를 출력하 면, 상기 ICT는 의도된 추론 결과와 상기 복수의 프로세싱 엘리먼트로부터의 추론 결과를 비교하여, 상기 NPU가 정상적인지 아니면 문제가 있는지를 분석할 수 있다. 예를 들어, 상기 ANN 테스트 모델이 미리 정해 진 CNN이고, 상기 테스트 입력이 간단한 테스트 이미지라면, 상기 복수의 프로세싱 엘리먼트는 상기 ANN 테스트 모델을 이용하여 상기 테스트 이미지에 대해서, 합성곱 연산과 폴링을 수행하여 fully connected layer 를 출력할 수 있다. 다음으로, 상기 복수의 프로세싱 엘리먼트에 대해서 스캔 테스트를 수행하는 경우, 후술하는 바와 같이 상 기 ICT는 상기 복수의 프로세싱 엘리먼트 내의 플리-플롭(flip-flop)들을 스캔 체인으로 엮을 수 있 다. 그리고, 상기 ICT은 테스트 입력을 적어도 하나의 플리-플롭으로 주입하고, 상기 복수의 프로세싱 엘 리먼트가 결함이 있는지 아니면 정상인지를 구동 중에 분석하기 위하여 상기 플리-플롭의 결합 로직의 동 작으로부터 테스트 결과를 획득할 수 있다. 상기 ICT에 의해서 수행되는 상기 테스트는 공장에서 대량 생산(mass production)된 NPU 반도체를 출하하 기 전에 양품을 판별하기 위해서 수행하는 테스트일 수 있다. 주목할 점은, 본 개시에 의하면 이와 같이 양품 판별을 위한 테스트가 상기 NPU의 구동중에도 수행될 수 있다는 점이다. 즉, 기존에는 NPU가 공장에서 출하되기 전에만 양품 판별 테스트가 가능했다. 본 개시는 NPU 내 복수 기능 컴포넌트들 중에서 유휴 상태인 기능 컴포넌트들을 찾아내어 순차적으로 테스트함 으로써, 구동중인 NPU에 대해서도 양품 테스트를 할 수 있게 하는 장점이 있다. 상기 테스트 분석 결과, 해당 기능 컴포넌트가 정상이라고 판단되면, 상기 ICT는 해당 기능 컴포넌트와의 연결을 상기 인터페이스로 반환할 수 있다. 구체적으로, 상기 ICT는 해당 해당 기능 컴포넌트와 상기 인터페이스 간의 연결을 재개시킬 수 있다. 더 구체적으로, 상기 ICT는 해당 기능 컴포넌트는 초기화 하여 상기 인터페이스에 연결될 수 있도록 한 후, 해당 래퍼에게 인터페이스로 전송하는 신호를 중단하라고 지시할 수 있다. 그러나, 테스트 분석 결과가 비정상이라고 판단되면, 상기 ICT는 상기 테스트를 몇회 더 반복할 수 있다. 몇 회 반복된 테스트 결과 해당 기능 컴포넌트가 비정상이라고 판단되면, 즉 상기 NPU 내에서 해당 기능 컴포넌 트가 잘못 제조되었거나, 손상이 되었거나 혹은 고장이 났다고 판단되면, 상기 ICT는 해당 기능 컴포넌트 를 비활성화(deactivate)시킬 수 있다. 대안적으로, 1회 테스트 분석 결과에 포함된 에러 코드가 상기 NPU 내에서 해당 기능 컴포넌트가 잘못 제조되었 거나, 손상이 되었거나 혹은 고장이 났다는 것을 나타내면, 상기 ICT는 해당 기능 컴포넌트를 비활성화 (deactivate)시킬 수 있다. 상기 해당 기능 컴포넌트를 비활성화시키기 위하여, 상기 ICT는 상기 비정상인 기능 컴포넌트를 인터페이 스로부터 격리(isolate)시키기 위하여, 상기 비정상인 기능 컴포넌트의 연결을 차단(cut-off 또는 disconnect)하거나 끊을 수 있다. 또는, 상기 비정상인 기능 컴포넌트를 비활성화시키기 위하여, 상기 ICT(17 0)는 상기 해당 기능 컴포넌트에 대한 전원 공급을 차단(즉, 파워 오프 또는 턴 오프)할 수 있다. 이와 같이 전 원 공급을 차단하면, 비정상적인 기능 컴포넌트가 오동작을 일으키는 것을 방지함과 아울러 전력 소모를 절감할 수 있는 장점이 있다. 또한, 상기 비정상적인 기능 컴포넌트를 비활성화시키기 위하여, 상기 ICT는 상기 인터페이스 상에서 상기 해당 기능 컴포넌트의 어드레스를 철회(revoke)하거나, 혹은 삭제시키기 위한 신호를 상기 인터페이스 로 전송할 수 있다. 즉, 상기 ICT는 상기 인터페이스 상에서 사용되는 어드레스들을 가지고 있 는 컴포넌트에게 상기 비정상적인 기능 컴포넌트의 어드레스를 삭제해달라는 신호를 전송할 수 있다. 한편, 상기 비활성화가 완료되면, 상기 ICT는 해당 기능 컴포넌트에 대한 스페어(spare)가 존재하는지 판 단할 수 있다. 즉, 본 개시의 다양한 예시들은 적어도 하나의 기능 컴포넌트에 대응되는 적어도 하나의 스페어 컴포넌트를 포 함하도록 구성될 수 있다. 즉, 본 개시의 다양한 예시들은 복수의 기능 컴포넌트 각각에 대응되는 각각의 스페어 컴포넌트를 포함하도록 구성될 수 있다. 만약 스페어가 존재하지만, 비활성화 상태인 경우 상기 ICT는 해당 스페어를 활성화시킬 수 있다. 그리고, 상기 ICT는 상기 인터페이스 상에서 사용되는 어드레스들의 테이블을 가지고 있는 컴포넌트에게 상 기 테이블 내에서 상기 활성화된 스페어의 어드레스를 갱신해달라는 요청을 포함하는 신호를 전송할 수 있다. 만약 비활성화 상태였던 상기 스페어가 상기 인터페이스 상에서 어드레스를 할당 받지 못하였다면, 상기 ICT는 상기 비정상적인 기능 컴포넌트의 어드레스를 상기 스페어에게 재할당되도록 하는 신호를 상기 인 터페이스로 전송할 수 있다. 그리고, 상기 ICT는 해당 스페어가 유휴 상태인지 모니터링한 후, 테스트를 수행할 수 있다. 도 6b는 테스트 기능을 갖춘 NPU의 구성을 제2 예시에 따라 나타낸 블록도이다. 도 6b을 참조하면, 예시적인 NPU은 복수의 기능 컴포넌트들(functional components)과, ICT(In-system Component Tester)와, 그리고 복수의 래퍼(190a, 190b,... : 통칭하여 190으로 표기하는 것도 가능)를 포 함할 수 있다. 래퍼는 서로 통신하는 구성요소들의 인터페이스를 맞출 수 있다. 따라서, 래퍼는 인터페이스 회로로 지칭 되는 것도 가능하다. 상기 복수의 기능 컴포넌트들은 복수의 프로세싱 엘리먼트와, 메모리와, 스케줄러과 NPU 인터페 이스을 포함할 수 있다. 상기 인터페이스는 BIU(Bus Interface Unit)으로 불릴 수도 있다. 상기 인터페이스는 NPU 외부에 배 치되는 반도체 소자, 예컨대 메인 메모리, 또는 CPU(Central Processing Unit)과의 통신을 담당할 수 있다. 상기 복수의 프로세싱 엘리먼트는 래퍼(190c), ICT 및 래퍼(190b)를 통해 스케줄러에 연결될 수 있다. 마찬가지로, 상기 메모리는 래퍼(190d), ICT 및 래퍼(190b)를 통해 스케줄러에 연결될 수있다. 상기 ICT는 복수의 래퍼들을 통하여, 각 기능 컴포넌트들을 모니터링하고 제어할 수 있다. 예를 들어, 상기 ICT는 래퍼(190b)와 래퍼(190c)를 통하여 NPU 스케줄러가 복수의 프로세싱 엘리먼트(11 0)를 액세스하는 것을 모니터링하고 제어할 수 있다. 또한, 상기 ICT는 래퍼(190b)와 래퍼(190d)를 통하여 NPU 스케줄러가 메모리에 액세스하는 것을 모니터링하고 제어할 수 있다. 마찬가지로, 상기 ICT(17 0)는 래퍼(190c)와 래퍼(190d)를 통하여 복수의 프로세싱 엘리먼트가 메모리에 액세스하는 것을 모니 터링하고 제어할 수 있다. 상기 ICT는 전용의 신호 채널을 통해 각 래퍼에 연결될 수 있다. 상기 ICT는 래퍼(190c)를 통해 복수의 프로세싱 엘리먼트를 모니터링하거나, 래퍼(190d)를 통해 메모 리를 모니터링하거나, 또는 래퍼(190b)를 통해 상기 스케줄러를 모니터링 함으로써, 상기 복수의 프 로세싱 엘리먼트, 상기 메모리 그리고 상기 스케줄러 각각이 유휴 상태(idle state)인지 사용 상태(busy state)인지를 모니터링할 수 있다. 유휴 상태의 기능 컴포넌트가 찾아지면, 상기 ICT는 해당 기능 컴포넌트를 테스트될 컴포넌트(component under test: CUT)로 선택할 수 있다. 만약 복수의 기능 컴포넌트들이 유휴 상태인 경우, 상기 ICT는 미리 설정된 규칙에 따라 어느 하나의 기능 컴포넌트를 CUT로 선택할 수 있다. 만약 복수의 기능 컴포넌트들이 유휴 상태인 경우, 상기 ICT는 랜덤으로 어느 하나의 기능 컴포넌트를 CUT 로 선택할 수 있다. 그러면, 상기 ICT는 상기 CUT로 선택된 기능 컴포넌트의 연결을 차단하거나, 격리 (isolate)시킬 수 있다. 이를 위해서, 상기 ICT는 해당 래퍼로 하여금 해당 기능 컴포넌트를 차단 또 는 격리하라고 지시할 수 있다. 보다 구체적으로, 상기 ICT는 상기 CUT로 선택된 기능 컴포넌트와의 연결을 해당 래퍼를 통해 차단시 킨 후, 해당 래퍼가 상기 CUT로 선택된 기능 컴포넌트를 대신하여, 필요한 신호를 모방하여 전송하도록 지 시할 수 있다. 이때, 상기 전송되는 신호는, 상기 CUT로 선택된 기능 컴포넌트가 유휴 상태일 때 전송하는 신호 일 수 있다. 이를 위해, 해당 래퍼는, 상기 CUT로 선택된 기능 컴포넌트가 상기 유휴 상태일 때, 전송하는 신호를 모니터링(혹은 overhear)하여 저장할 수 있다. 그리고, 해당 래퍼는 상기 저장된 신호를 재생성하 여 전송할 수 있다. 이후, 상기 ICT는 상기 CUT로 선택된 기능 컴포넌트에 대해서 테스트를 수행할 수 있다. 이에 대해서는 도 6a를 참조하여 설명한 내용과 유사하므로, 중복하여 설명하지 않기로 한다. 상기 테스트를 시작하려는 시점 혹은 상기 테스트를 수행하는 도중에, 상기 CUT로 선택된 기능 컴포넌트에 대한 액세스로 인하여 충돌이 발생되면, 상기 ICT는 상기 충돌을 검출할 수 있다. 그러면, 상기 ICT는 상기 테스트를 중지하고, 충돌에 대한 백-오프(back-off) 타이머를 구동할 수 있다. 그리고, 상기 ICT는 상기 CUT로 선택되었던 기능 컴포넌트를 복귀시킬 수 있다. 한편, 상기 충돌에 대한 백 오프 타이머가 만료하면, 상기 ICT는 해당 기능 컴포넌트가 다시 유휴 상태로 진입하는지 모니터링할 수 있다. 만약 해당 기능 컴포넌트가 다시 유휴 상태로 진입하게 되면, 상기 ICT는 해당 기능 컴포넌트를 다시 CUT로 선택할 수 있다. 만약 상기 충돌이 검출되지 않았다면, 상기 ICT는 상기 테스트를 계속 진행하고, 테스트가 완료되면 그 테 스트 결과를 분석할 수 있다. 그 밖에 상세한 설명은 도 6a를 참조하여 설명한 내용과 유사하므로, 중복하여 설명하지 않기로 하고, 도 6a를 참조하여 설명한 내용을 원용하기로 한다. 도 7은 테스트 기능을 갖춘 NPU의 구성을 제3 예시에 따라 나타낸 블록도이다. 도 7을 참조하면, 예시적인 NPU은 시스템 버스를 통하여, CPU(Central Processing Unit)과, 메인 메 모리과 연결될 수 있다. 추가적으로, NPU은 시스템 버스를 통하여 이미지 센서와 연결될 수도 있다. 또한 추가적으로, NPU은 시스템 버스를 통하여 디코더와도 연결될 수 있다. 도 7에 도시된 예시적인 NPU은 복수의 기능 컴포넌트들(functional components)과, ICT(In-system Component Tester)와, 그리고 복수의 래퍼(190e, 190f,...190k : 통칭하여 190으로 표기하는 것도 가능) 를 포함할 수 있다. 상기 복수의 기능 컴포넌트들은 복수의 프로세싱 엘리먼트, 내부 메모리, DMA(Direct Memory Access), 컨트롤러, 그리고 SFU을 포함할 수 있다. 상기 컨트롤러는 도 6a에 도시된 바와 같이 스케줄러를 포함할 수 있다. 또한, 상기 컨트롤러는 도 6b에 도시된 인터페이스도 포함할 수 있다. 즉, 상기 컨트롤러는 스케줄러와 인터페이스 모두를 포함할 수 있다. 상기 스케줄러와 상기 인터페이스의 동작에 대한 설명은 전술한 내용 을 따르기로 한다. 상기 DMA는 상기 메모리에 대한 액세스를 제어한다. 이를 위하여, 상기 DMA는 상기 메모리(12 0)의 물리 어드레스 주소를 관리할 수 있다. 상기 복수의 프로세싱 엘리먼트는 복수의 PE(111, 112, 113, 114)를 포함할 수 있다. 각 PE는 MAC(multiply-accumulate) 연산기를 포함할 수 있다. 각 기능 컴포넌트와 상기 컨트롤러 사이에는 래퍼가 배치될 수 있다. 예를 들어, 상기 복수의 프로세싱 엘 리먼트와 상기 컨트롤러 사이에는 래퍼(190g)가 배치될 수 있다. 상기 메모리와 상기 컨트롤러 사이에는 래퍼(190f)가 배치될 수 있다. 상기 DMA와 상기 컨트롤러 사이에는 래퍼(190e)가 배 치될 수 있다. 상기 SFU와 상기 컨트롤러 사이에는 래퍼(190h)가 배치될 수 있다. 또한, 상기 복수의 프로세싱 엘리먼트와 상기 메모리와 사이에는 래퍼(190k)가 배치될 수 있다. 그리 고 상기 복수의 프로세싱 엘리먼트와 상기 SFU와 사이에는 래퍼(190k)가 배치될 수 있다. 상기 ICT는 복수의 래퍼들을 통하여, 각 기능 컴포넌트들을 모니터링하고 제어할 수 있다. 예를 들어, 상기 ICT는 래퍼(190k)를 통하여 NPU 어레이와 메모리 간의 인터렉션을 모니터링하고 제 어할 수 있다. 또한, 상기 ICT는 래퍼(190f)를 통하여 메모리를 모니터링하고 제어할 수도 있다. 또 한, 상기 ICT는 래퍼(190e)를 통하여 DMA를 모니터링하고 제어할 수도 있다. 또한, 상기 ICT는 래퍼(190g)를 통하여 컨트롤러와 복수의 프로세싱 엘리먼트간의 인터렉션을 모니터링하고 제어할 수 도 있다. 상기 ICT는 래퍼(190i)를 통하여 SFU를 모니터링하고 제어할 수도 있다. 그리고, 상기 ICT는 래퍼(190h)를 통하여 상기 컨트롤러와 상기 SFU의 인터렉션을 모니터링하고 제어할 수도 있다. 상기 ICT는 전용의 신호 채널을 통해 각 래퍼에 연결될 수 있다. 상기 ICT는 각 래퍼를 통해 해당 기능 컴포넌트가 유휴 상태(idle state)인지 사용 상태(busy state)인지 를 모니터링할 수 있다. 유휴 상태의 기능 컴포넌트가 찾아지면, 상기 ICT는 해당 기능 컴포넌트를 테스트될 컴포넌트(component under test: CUT)로 선택할 수 있다. 만약 복수의 기능 컴포넌트들이 유휴 상태인 경우, 전술한 바와 같이 상기 ICT는 미리 설정된 규칙에 따라 어느 하나의 기능 컴포넌트를 CUT로 선택할 수 있다. 그리고 전술한 바와 같이 상기 ICT는 상기 CUT로 선 택된 기능 컴포넌트의 연결을 차단하거나, 격리(isolate)시킬 수 있다. 이후, 상기 ICT는 상기 CUT로 선택된 기능 컴포넌트에 대해서 테스트를 수행할 수 있다. 이에 대해서는 도 6a를 참조하여 설명한 내용과 유사하므로, 중복하여 설명하지 않기로 한다. 만약 충돌이 검출되지 않았다면, 전술한 바와 같이 상기 ICT는 상기 테스트를 계속 진행하고, 테스트가 완 료되면 그 테스트 결과를 분석할 수 있다. 전술한 바와 같이, 테스트 분석 결과가 비정상이라고 판단되면, 상기 ICT는 상기 테스트를 몇 회 더 반복 할 수 있다. 몇 회 반복된 테스트 결과 해당 기능 컴포넌트가 비정상이라고 판단되면, 즉 상기 NPU 내에서 해당 기능 컴포넌 트가 잘못 제조되었거나, 손상이 되었거나 혹은 고장이 났다고 판단되면, 상기 ICT는 해당 기능 컴포넌트 를 비활성화(deactivate)시킬 수 있다. 만약, 상기 비활성화된 기능 컴포넌트에 대한 스페어가 존재하지 않는 경우, 상기 ICT는 상기 SFU가 상기 비활성화된 기능 컴포넌트와 동일한 동작을 흉내 낼 수 있도록 하기 위하여, 상기 SFU가 프로그래밍 되도록 할 수 있다. 이를 위하여, 상기 SFU는 FPGA(field programmable gate array)로 구현될 수 있다. 상기 SFU의 프로그래밍을 위한 정보는 상기 내부 메모리에 저장되어 있을 수 있다. 또는 상기 SFU의 프로그래밍을 위한 정보는 상기 SFU의 캐쉬 메모리에 저장되어 있을 수 있다. 이와 같이 상기 SFU가 상기 비활성화된 기능 컴포넌트와 동일한 동작을 흉내내도록 프로그래밍되면, 상기 ICT는 컨트롤러에서 사용되는 어드레스 테이블을 갱신해달라는 요청을 포함하는 신호를 전송할 수 있 다. 대안적으로, 상기 비정상적인 기능 컴포넌트의 어드레스를 상기 상기 SFU에게 재할당되도록 하는 요청 을 포함하는 신호를 상기 컨트롤러로 전송할 수 있다. 다시 말해서, 상기 SFU의 기존 어드레스는 폐 지(revoke)되고, 상기 비정상적인 기능 컴포넌트의 어드레스로 대체될 수 있다. 이하에서는, 전술한 내용에 대한 이해를 높이기 위하여, 목차로 구분하여 보다 상세하게 설명하기로 한다. I. 구동중 테스트가 중요한 이유 자율 컴퓨팅 시스템에서 하드웨어 결함에 의해서 야기될 수 있는 잠재적인 사고를 방지하기 위하여, 다양한 연 구가 있어왔다. 다양한 연구 중에는 운용 전 테스트(pre-deployment test)가 있다. 이 테스트 기법은 고객에게 판매되기 전에 모든 하드웨어 설계를 점검하는 것이다. 제조 이후에 설계는 다양한 관점으로 테스트되어, 실제 동작시 발견될 수 있는 다양한 문제를 검출하고 수정한다. 예를 들어, 칩 설계를 테스트하기 위하여 테스트 패턴을 제공함으로 써 입력에 대한 스캔과 출력 결과에 대한 검사를 수행할 수 있다. 비록 이러한 기법이 제품 출하 전에 하드웨어 설계에 대한 잠재적인 문제를 최소화할 수 있다. 하지만, 직접 회로(IC)의 노후화, 외부 환경, 복잡한 설계의 취약성으로 인하여 발생할 지도 모르는 구동중(runtime) 결함에 대한 문제는 해결하지 못한다. 이와 같이 전술한 운용 전 테스트는 하드웨어 결함을 효과적으로 해결할 수 없기 때문에, 본 발명자는 구동중에 테스트할 수 있는 방법에 관심을 갖기 시작하였다. 테스트 메커니즘 관점에서, 운용 전 테스트와 운용 후 테스트는 서로 유사할 수도 있지만, 언제 테스트를 할 수 있는지는 극명하게 차이가 있다. 특히, 운용 전 테스트는 특정한 시간에만 테스트를 할 수 있고, 일반적으로는 제조 직후 잠깐 동안에만 가능하다. 반면에, 구동중 테스트는 일반적인 동작 상황에서 언제든지 테스트를 할 수 있다. 이러한 운용 중 테스트에는 2가지 테스트 기법, 즉 기능 테스트와 스캔 테스트가 존재할 수 있다. 상기 기능 테스트는 테스트 입력을 생성하고, 생성된 테스트 입력을 원래의 설계에 입력한 후 나오는 출력 결과 를 의도된 패턴과 비교하는 것이다. 다른 방식으로, 원래의 설계에 기반하여, 상기 기능 테스트는 입력과 출력 신호를 모니터링하여, 이상 현상을 검출할 수 있다. 상기 스캔 테스트는 원래의 설계 내에 스캔 테스트를 위한 아키텍처를 삽입하고, 테스트 패턴을 가능한 다양하 게 만들어내야 한다. 이와 같이, 스캔 아키텍처와 테스트 패턴을 준비한 이후에는, 다양한 방식으로 구동중 테 스트를 수행할 수 있게 된다. 상기 스캔 테스트를 위하여, 상기 ICT는 각 CUT 내의 복수의 플리-플롭들을 서로 연결하고, 테스트 입력을 적어 도 하나의 플리-플롭으로 주입하고, 상기 CUT가 결함이 있는지 아니면 정상인지를 구동 중에 분석하기 위하여 상기 플리-플롭의 결합 로직의 동작으로부터 테스트 결과를 획득할 수 있다. 도 8은 플리-플롭을 스캔하는 예를 나타낸다. 하드웨어 설계를 보다 쉽게 하기 위하여 그리고 제조 결함을 최소화기 위하여, 테스트 가능한 설계(Design for testability; DFT)를 적용하는 것은 매우 중요하다. 이를 위하여, 스캔 테스트를 위한 아키텍처를 설계에 반영하고, 검출가능한 모든 결함에 대한 특정 비율의 테스 트 범위를 정의하여 테스트를 수행할 수 있다. D 타입의 플리-플롭을 사용하는 경우, 스캔 테스트를 위한 아키텍처는 쉽게 설계에 반영될 수 있다. 테스트 도 중에는, CUT 내의 모든 플리-플롭들은 D 플리-플롭과 멀티플렉서(multiplexer)를 포함하는 스캔 플리-플롭들로 동작될 수 있다. 상기 플리-플롭은 일반적인 D 타입 플리-플롭에 비하여 도 7에 도시된 바와 같이 2개의 추가적인 핀, 즉 SE(scan enable) 핀과 SI (scan in) 핀을 사용할 수 있다. 상기 SI 핀은 테스트 입력을 위한 것이고, 상기 SE 핀은 일반 동작을 위한 입력(D 핀)과 테스트 동작을 위한 테스트 입력(SI) 간에 스위칭을 가능하게 한다. 도 9는 하드웨어 설계 내에 스캔 테스트를 위한 아키텍처가 추가된 예를 나타낸다. 도시된 바와 같이, 스캔 플리-플롭 내의 모든 SE 핀들은 SE(scan_enable) 포트들과 연결되어 있고, 각 플리-플 롭의 SI 핀은 이전 플리-플롭 혹은 스캔 입력 포트의 Q 핀과 연결되어 있고, 각 플리-플롭의 Q 핀은 다음 플리- 플롭의 SI 핀과 연결되어 있다. 이러한 연결들은 다중 스캔 체인을 만들어 낸다. 즉, 플리-플롭들은 서로 엮이게 되어 스캔 체인을 만들어 낸다. SE(scan_enable) 포트가 인에이블되면, 모든 스캔 플리-플롭들은 SI 핀으로부터의 데이터가 플리-플롭을 거쳐 Q 핀으로 전달되도록 하고, 따라서 데이터는 scan_in 포트에서 대응하는 scan_out 포트로 전달될 수 있다. 각 스 캔 체인 상의 모든 플리-플롭들은 scan_in 포트로부터의 테스트 입력을 scan_out 포트로 쉬프트시킨다. 스캔 체인 상에서 플리-플롭들의 개수가 작아질 수록, 데이터를 쉬프트하는 속도는 더 빨리질 수 있다. 그러나, 각 스캔 체인 상에서 플리-플롭의 개수와 스캔 체인의 개수는 서로 상호 의존적일 수 있다. 스캔 체인을 더 많 이 만들어 낼수록 각 스캔 체인 상에는 더 적은 플리-플롭들이 존재할 수 있다. II. ICT를 통한 테스트 전술한 테스트는 백그라운드(background) 작업으로서 수행되기 때문에, 시스템 성능의 하락 없이, 테스트를 수 행할 수 있다. 테스트의 대상이 될 컴포넌트의 동작을 모니터링하는 것에 기초하여, ICT는 해당 컴포넌트가 유 휴 상태인지를 판단할 수 있다. 해당 컴포넌트가 유휴 상태에 있을 때 테스트를 수행하기 때문에, 시스템의 성 능 하락을 야기하지 않을 수 있다. ICT는 CUT의 동작 상태를 시스템 버스 상에서 지속적으로 모니터링하고, CUT 는 예측되지 않은 액세스에 대해서 응답할 수 있다. 만약 CUT에 대한 액세스가 발생한다면, 상기 CUT를 테스트 동작에서 일반 동작으로 스위칭함으로써, CUT를 복구하고 상기 CUT를 일반 동작으로 회귀(come back)시킬 수 있 다. 상기 스위칭을 위해 약간의 시간 지연이 발생할 수 있다. 본 개시는 상기 시간 지연 동안에 시스템 버스를 효율적으로 사용할 있도록 함으로써, 상기 복구로 인한 시스템 성능 저하를 최소화할 수 있다. II-1. 반도체의 복잡성 증가 직접 회로(Integrated Circuit: IC)의 설계는 날이 갈수록 복잡해지고 있고, 직접도 역시 크게 증가하고 있다. NPU는 직접도가 매우 높은 반도체로서, 일부 기능 컴포넌트의 결함은 전체 시스템 성능의 하락을 야기할 수 있 다. 따라서, NPU 내의 기능 컴포넌트들에 대해서 결함 유무를 파악하기 위한 테스트를 수행하는 것이 날로 중요 해지고 있다. II-2. 래퍼의 필요성 도 10은 래퍼의 동작을 나타낸 예시도이다. 전술한 바와 같이, ICT는 구동중에 있는 NPU 내부의 많은 기능 컴포턴트들(즉, IP, I/O 인터페이스, 메모리 등)을 테스트할 수 있다. 이를 위해서, 우선 CUT로 선택된 기능 컴포넌트에 대해 테스트를 수행하는 도중에, 해 당 기능 컴포넌트에 대해 시스템 버스로부터의 액세스로 인한 충돌 문제를 해결해야 한다. 상기 충돌 문제를 해결하기 위하여, 상기 기능 컴포넌트가 유휴 상태인지를 모니터링한 후, 상기 유휴 상태로 모니터링되면 상기 기능 컴포넌트를 일반 동작 모드에서 테스트 동작 모드로 스위칭한 후, 테스트를 수행해야 한다. 상기 테스트 도중 상기 충돌이 검출되면, 상기 기능 컴포넌트를 다시 일반 동작 모드로 전환시켜야 한다. 상기 일반 동작 모드로 전환시킨 후에는, 상기 기능 컴포넌트가 입력 데이터를 올바르게 처리할 수 있어야 한다. 이를 위해서, 도시된 래퍼가 각 기능 컴포넌트와 컨트롤러 사이에 배치되어야 한다. 상기 래퍼 는 각 동작 모드를 위한 입력 및 출력을 선택적으로 제어할 수 있는 멀티플렉서 게이트(multiplexer gates)들을 포함할 수 있다. 도시된 바와 같이, TEST_ENABLE 포트가 ON되면, 테스트 백터가 CUT에 입력될 수 있고, TEST_OUTPUT 포트는 출력 을 전송할 수 있다. 상기 래퍼로부터 출력되는 일반 데이터는 시스템 버스를 통하여 다른 기능 컴포넌트들 로 전달될 수 있다. 반면, 테스트 결과는 상기 ICT로 직접 전달될 수 있다. 상기 ICT는 외부 메모리혹은 내부 메모리로부터 테스트를 위한 테스트 벡터를 수신하고, 상기 테스트를 수행한 결과를 내부 메모리 혹 은 외부 메모리에 저장하거나 혹은 외부로 전송할 수 있다. 구동중인 NPU의 테스트를 수행하기 위하여, ICT는 여러 과정을 수행할 수 있다. 첫 번째로, ICT는 일 정한 규칙에 기초하여, 테스트를 수행할 기능 컴포넌트를 CUT로 선택할 수 있다. NPU가 구동중이기 때문에, 상 기 CUT는 여전히 시스템 버스로부터의 액세스에 대해서 응답할 수 있어야 한다. 따라서, 가능한 유휴 상태로 있 는 기능 컴포넌트를 CUT로 선택하는 것이 효과적일 수 있다. 이를 위하여, ICT는 기능 컴포넌트가 유휴 상 태로 진입하는지를 모니터링할 수 있다. 해당 기능 컴포넌트가 유휴 상태에 진입하면, 래퍼는 TEST_ENABLE 포트를 턴온할 수 있다. ICT는 테스트 벡터를 TEST_ENABLE 포트를 통하여 해당 CUT로 주입시킬 수 있다. 상기 ICT는 테스트 결과를 상기 래퍼의 TEST_OUPUT 포트를 통하여 상기 CUT로부터 수집하고, 분석할 수 있다. 상기 테스트 결과가 문제가 검출되었다고 나타내면, 상기 ICT는 후 동작(Post Action)을 수행할 수 있다. 상기 테스트 도중, 컨트롤러로부터 상기 CUT에 대한 일반적인 액세스가 검출되면, 상기 ICT(17 0)는 상기 컨트롤러로부터의 액세스를 일시적으로 지연시킨 후, 상기 테스트 동작을 즉시 중지시킬 수 있 다. 그런 다음, 상기 ICT는 상기 CUT의 레지스터 설정을 위한 이전 값들을 복구(recover)하고, 상기 래퍼 의 TEST_ENABLE 포트를 턴오프시킬 수 있다. 상기 CUT의 일반 동작을 위한 모든 준비가 완료되면, 상기 ICT는 상기 CUT와의 입출력을 위한 연결을 상기 컨트롤러로 반환하도록, 상기 래퍼를 제어할 수 있다. 도 11은 ICT의 내부 구성을 나타낸 예시도이다. 도 11를 참조하면, ICT은 설정 데이터(CONF_DATA) 복원기, 상태 검출기(state detector), 스케 줄러(scheduler), 테스터(test), 테스트 벡터(test vector) 생성기, 호스트 인터페이스, 후 동작(POST_ACT) 수행기를 포함할 수 있다. 상기 상태 검출기는 NPU 내의 기능 컴포넌트들의 상태가 유휴 상태인지 아니면 사용중(busy) 상태(혹은 처 리중(processing) 상태)인지를 검출할 수 있다. 임의의 기능 컴포넌트가 유휴 상태로 진입하면, 상기 상태 검출 기는 상기 스케줄러에게 해당 기능 컴포넌트의 ID(C_ID)를 전달함으로써, 테스트를 수행할 수 있도록 할 수 있다. 상기 스케줄러는 상기 ICT의 전체 동작을 관리할 수 있다. 상기 스케줄러는 상기 상태 검출기 로부터 해당 기능 컴포넌트의 상태를 수신하고, 테스트를 트리거링할 수 있다. 상기 스케줄러는 컴포 넌트의 ID를 상기 테스터로 전달할 수 있다. 상기 테스터는 래퍼를 제어하고, 테스트 벡터를 전달하고, 테스트 결과를 획득한 후, 상기 테스트 결 과가 의도된 테스트 결과에 부합하는지를 비교한 후, 상기 테스트 결과를 상기 후 동작 수행기로 전달할 수 있다. 그리고 상기 테스터는 CUT로 선택된 기능 컴포넌트를 위한 레지스터 설정을 원래의 값으로 복원 할 수 있다. 상기 테스트 벡터 생성기는 테스트 벡터(혹은 미리 정의된 테스트 입력 데이터)와 그리고 대응하는 의도된 테스트 결과를 생성할 수 있다. 상기 테스트 벡터 생성기는 버퍼, 메모리 인터페이스, 상기 테스트 벡터와 상기 의도된 텍스트 결과를 저장하는 메모리, 랜덤 번호 생성기를 포함할 수 있다. 테스트가 시작되면, 상기 테 스트 벡터의 생성을 위한 테스트 패턴이 상기 버퍼 내에 로딩될 수 있다. 상기 랜덤 번호 생성기는 상기 테스트 벡터를 생성하기 위해서 사용될 수 있다. 상기 랜덤 번호 생성기는 상기 메모리가 모든 테스트 벡터를 저장하지 않을 수 있도록 하면서도, 테스트 벡터가 다양하게 생성될 수 있도록 한다. 상기 후 동작 수행기는 상기 테스터로부터 문제가 발견된 기능 컴포넌트의 ID(예컨대, C_ID)를 수신 하면, 후 동작을 수행할 수 있다. 상기 후 동작은 상기 문제가 있는 기능 컴포넌트를 격리시키거나, 사용자 혹 은 원격 호스트 장비에게 이를 알리는 기능을 수행할 수 있다. 상기 호스트 인터페이스는 상기 테스트 과정 중에서 문제가 발견된 기능 컴포넌트에 대해 사용자에게 보고 하거나 혹은 원격 호스트 장비에게 보고할 수 있다. 만약 테스트 동작과 관련하여 변경사항이 있다면, 상기 호 스트 인터페이스는 원격 호스트 장비에게 이를 알릴 수 있다. 상기 설정 데이터 복원기는 상기 테스트가 완료되거나 상기 테스트 과정중에 시스템 버스로부터 CUT로 선 택된 기능 컴포넌트에 대한 액세스가 검출되면, 상기 테스터가 상기 CUT를 일반 동작 모드로 스위칭 시키 기 위하여, 상기 CUT의 레지스터 세팅을 복원할 수 있다. 대부분의 기능 컴포넌트들은 일반 동작을 위하여 특정한 레지스터 설정 값을 가질 수 있다. 따라서, 상기 설정 데이터 복원기는 상기 테스트가 수행되기 전에 기능 컴포넌트의 레지스터 설정 값을 저 장하고, 상기 CUT를 일반 동작 모드로 스위칭해야 할 때 상기 레지스터 설정의 값을 상기 기능 컴포넌트에 복원 시킬 수 있다. 한편, 상기 테스트 벡터 생성기는 랜덤 번호 생성기, 미리 정의된 테스트 데이터 저장부, 템프 레지스터 중 적어도 하나를 포함할 수 있다. 랜덤 번호를 사용하여 복수의 프로세싱 엘리먼트를 테스팅 하는 방법에 대하여 설명한다. 상기 랜덤 번호 생성기는 미리 정해진 시드(seed)에 기초하여 랜덤 번호를 생성할 수 있다. 상기 ICT는 복수의 프로세싱 엘리먼트 내의 적어도 하나의 PE를 선택하여 테스트를 시작하라고 명령할 수 있다. 구체적인 예를 들면, 상기 ICT는 복수의 프로세싱 엘리먼트 중에서 일정 비율의 PE들(예컨대, 전체 PE들 중 20%의 PE들)이 유휴 상태라고 판단되면, 테스트를 시작할 수 있다. 다르게 설명하면, 전체 PE 중 유휴 PE 비 율이 임계 값 이상일 경우, 테스트를 시작할 수 있다. 구체적인 예를 들면, 상기 ICT는 일정 비율의 PE들(예컨대, 전체 PE들 중 50%의 PE들)을 선택하여 테스트 를 시작할 수 있다. 상기 테스트가 수행되면, 상기 NPU의 추론 속도, 즉 IPS(inference per second)가 저하될 수 있다. 즉, 테스트 되는 PE의 개수에 따라서 추론 속도가 저하될 수 있다. 구체적인 예를 들면, 전체 PE들 중에서 50%의 PE들이 테 스트되면, 추론 속도는 약 50% 정도 저하될 수 있고, 전체 PE들 중 30%의 PE들이 테스트되면, 테스트 중 추론 속도가 약 30% 정도 저하될 수 있다. 따라서, 일 예시에 따르면, 상기 테스트에 따른 속도 저하가 개선되도록, 상기 복수의 프로세싱 엘리먼트 는 여분의 PE들을 더 포함할 수 있다. 다른 예를 들어, 상기 NPU가 미리 정해진 IPS(inference per second) 값 이하로 동작 시, 상기 ICT 는 상기 복수의 프로세싱 엘리먼트에게 테스트를 실시하라고 지시할 수 있다. 구체적으로, 상기 NPU 가 최대 100 IPS로 동작할 수 있다고 가정하고, 임계 IPS 값은 30 IPS이라고 가정하면, 상기 ICT는 상기 NPU가 30 IPS이상으로 동작되면 남는 시간에 테스트를 수행하라고 지시할 수 있다. 예를 들면 상기 NPU가 40 IPS로 동작할 때 남는 60 IPS를 이용하여 테스트를 수행할 수 있다. 따라서, 실질적인 NPU의 속 도 저하가 발생되지 않을 수 있다. 다른 예를 들어, 상기 ICT는 도 7에 도시된 메인 메모리에서 상기 NPU 내부 메모리로 전달되는 데이터가 지연되어, 상기 NPU가 유휴 상태가 되거나 혹은 데이터 굶주림(starvation) 구간에 진입하면, 상 기 복수의 프로세싱 엘리먼트에게 테스트를 수행하라고 지시할 수 있다. 상기 복수의 프로세싱 엘리먼트에 대한 테스트가 수행되면, 각 PE에 대응되는 레지스터 파일(RF)는 미리 정해진 테스트 입력 데이터로 초기화되고, 대응하는 PE는 상기 레지스터 파일(RF) 내의 테스트 입력 데이터에 따라 추론을 수행할 수 있다. 상기 미리 정해진 테스트 입력 데이터는 상기 NPU에 대한 기능 테스트 또는 부분 적인 기능 테스트일 수 있다. 상기 복수의 프로세싱 엘리먼트에 대한 테스트가 수행되면, 전술한 바와 같이 상기 랜덤 번호 생성기는 랜 덤 번호를 생성한다. 그러면, 상기 레지스터 파일(RF)은 상기 생성된 랜덤 번호에 의해서 초기화되고, 대응하는 PE는 상기 레지스터 파일(RF) 내의 랜덤 번호에 따라 추론을 수행한다. 상기 레지스터 파일(RF)은 각 PE 내의 플리-플롭들을 리셋하고, 전술한 바와 같이 PE들에게 테스트 입력 데이터 를 전달할 수 있다. 각각의 RF크기는 예를 들면 1Kb일 수 있다. II-3. 기능 컴포넌트의 유휴 상태 검출 도 12는 ICT가 기능 컴포넌트가 유휴 상태인지를 모니터링하는 동작을 상세하게 나타낸 블록도이다. 기능 컴포넌트가 일반 동작 모드로 있는 중에 유휴 상태인지를 검출하기 위하여, ICT는 2가지 기법을 사용 할 수 있다. 첫 째로, 동작 여부를 직접적으로 혹은 간접적으로 나타내는 일부 하드웨어 신호에 기초하여, ICT는 해당 컴포넌트가 유휴 상태인지 아니면 사용중 상태인지를 모니터링할 수 있다. 예를 들어, 해당 기능 컴포넌트의 전 력 소모를 줄이기 위하여 해당 기능 컴포넌트의 연결을 해제시키기 위한 파워 게이팅 제어 신호를 ICT가 모니터링할 수 있다. 또한, 동작 여부를 간적접으로 나타내는 출력 신호 혹은 상기 기능 컴포넌트 내부에서 동 작 여부와 관련된 정보를 저장하는 레지스터의 값에 기초하여, 상기 ICT는 해당 기능 컴포넌트가 유휴 상 태인지를 판단할 수 있다. 두 번째로, 상기 ICT는 래퍼를 통하여 시스템 버스로부터의 신호를 모니터링 하거나 특정 시간 구간 동안에 상기 기능 컴포넌트의 입력/출력 포트를 모니터링함으로써, 상기 ICT는 해당 기능 컴포넌트가 유휴 상태인지를 판단할 수 있다. II-4. 액세스 충돌에 대한 처리 도 13은 시스템 버스 상에서 동작하는 마스터(master), 슬래이브(slave), 아비터(arbiter) 간에 동작을 나타낸 예시도이다. 시스템 버스 상에서 마스터는 슬래이브를 사용하려는 주체일 수 있고, 슬래이브는 마스터에 의해서 사용되는 주 체일 수 있고, 상기 아비터(arbiter)는 상기 마스터와 상기 슬래이브 사이에서 조정과 결정을 수행하는 주체일 수 있다. 도 13에 도시된 슬래이브는 CUT로 선택된 기능 컴포넌트일 수 있고, 상기 아비터는 ICT일 수 있다. 상기 CUT로 선택된 기능 컴포넌트에 대해 테스트가 진행되는 도중, 일반 동작을 위한 액세스가 상기 컨트롤러 로부터 검출되면, 상기 ICT은 상기 CUT를 이전의 상태로 복구시키는데 일정 이상의 시간을 필요로 할 수 있다. 따라서, 상기 ICT는 마스터로부터의 시스템 액세스를 일시 중지시키기 위하여 HREADY 신호를 일 시적으로 비활성화(또는 de-assert)시키고, 테스트 활동을 중지하고, CUT의 레지스터 설정을 복구하고, 래퍼로 입력되는 혹은 출력되는 데이터의 방향을 변경할 수 있다. 상기 슬래이브인 CUT가 상기 마스터와 작업을 수행할 준비가 완료되면, HREADY 신호가 턴-온될 수 있다. 그러나, 본 개시에 따르면, ICT는 버스 분리 동작을 위하여 약간의 시간 지연을 유도할 수 있다. 구체적인 과정에 대해서 설명하면 다음과 같다. 첫 번째로, 마스터는 버스 액세스를 위하여 HBUSREQ 신호를 활성화(또는 assert)한다. 두 번째로, 조정 (arbitration) 혹은 결정 과정에서, 상기 아비터는 버스 액세스를 허용하기 위하여 HGRANT 신호를 활성화(또는 assert)한다. 그러면, 마스터는 상기 시스템 버스를 통해서 데이터를 슬래이브인 CUT로 전송할 수 있다. 만약 상기 ICT가 테스트를 위한 처리 동작을 수행중이라면, 상기 ICT는 현재 마스터를 나타내는 비트와 함께 HSPLIT 신호를 상기 아비터로 전송하고, 동시에 HRESP 신호 내에 SPLIT 신호를 활성화(또는 assert)시킨다. 상기 활성 화(assertion) 이후, 상기 마스터는 상기 CUT에 대한 액세스를 무효화(nullify)시키고, 상기 아비터는 상기 마 스터의 개입 없이 상기 조정 혹은 결정 과정을 진행한다. 상기 CUT가 상기 마스터로부터의 액세스에 대해서 응 답할 준비가 완료되면, 상기 ICT는 상기 HSPLIT 신호를 비활성화하고, 상기 마스터는 상기 CUT를 액세스하려는 자신의 작업을 재개하기 위하여, 상기 아비터로부터의 허가(grant)를 대기한다. 도 14는 NPU 내에 쉬프트 레지스터가 추가된 예를 나타낸다. 본 개시의 발명자는 상기 I/O 인터페이스에 대한 액세스는 시스템 버스 상에서 충돌을 야기하지 않을 수 있다는 사실을 인식하였다. 예를 들어, 상기 타겟 CUT가 마스터인 경우, 상기 I/O 인터페이스를 통해 연결된 외부 기기 는 자기 스스로 액세스를 요청하지 않기 때문에, 충돌은 발생하지 않을 수 있다. 따라서, CUT가 슬래이브일 때 발생하는 충돌 문제를 해결하는 것에만 집중하는 것이 효과적일 수 있다. 대신에, 외부 기기로부터 CUT로 전달되는 데이터를 상기 복구 시간 동안에 지연시키기 위하여, 쉬프트 레지스터 가 NPU의 포트와 상기 CUT의 외부 인터페이스 포트 사이에 추가될 수 있다. 상기 쉬프트 레지스터는 상기 CUT가 복구되는 시간 동안에 NPU 외부로부터 입력되는 액세스 신호를 저장하기 위 하여 추가될 수 있다. 상기 CUT가 준비 완료되면, 상기 액세스 신호들이 상기 쉬프트 레지스터에 의해서 재생성 되어 출력될 수 있다. 상기 쉬프트 레지스터의 깊이는 상기 CUT가 일반 동작으로 복구되는데 필요한 클럭 사이클의 개수에 따라 결정 될 수 있다. 특히, 하나 이상의 기능 컴포넌트가 NPU 외부로부터의 신호를 수신해야 하는 경우, 쉬프트 레지스터의 깊이는 가변될 수 있어야 한다. 이 경우, 상기 쉬프트 레지스터의 깊이는 상기 ICT에 의해서 결정될 수 있 다. II-5. ICT의 동작 순서 도 15는 ICT의 동작 순서를 나타낸 예시도이다. 도 15을 참조하면, ICT가 구동중인 테스트 시작과 관련된 타이머가 만료(S601)하면, ICT는 임의 기능 컴포넌트 가 유휴 상태인지를 모니터링하고, 유휴 상태에 있는 기능 컴포넌트를 검출해낸다(S603). 그러면, 상기 ICT는 테스트 준비 절차를 수행한다(S605). 상기 테스트 준비 절차는 상기 기능 컴포넌트를 CUT로 선택한 다음, 상기 CUT로 선택된 기능 컴포넌트를 시스템 버스로부터 격리시키고, 테스트 입력 데이터로서 테스 트 벡터를 생성하는 것을 포함할 수 있다. 상기 시스템 버스로부터 격리시킨다는 것은, 상기 ICT가 상기 CUT로 선택된 기능 컴포넌트와 통신하는 래퍼 상에서 입력 및 출력의 방향을 변경하는 것을 의미할 수 있다. 그리고, 상기 ICT는 테스트 입력 데이터인 테스트 벡터를 상기 CUT로 주입시킨다(S607). 상기 테스트가 정상적으로 완료되면, 상기 ICT는 테스트 결과를 검사한다(S609). 상기 검사를 위하여, 상기 ICT 는 상기 테스트 결과가 의도된 테스트 결과에 부합하는지를 비교할 수 있다. 상기 테스트 결과가 상기 CUT로 선택된 기능 컴포넌트에 문제(즉, 결함 혹은 손상 등)가 없다는 것을 나타내면, 상기 ICT는 상기 기능 컴포넌트를 일반 동작 상태로 복구시킬 수 있다(S611). 한편, 상기 테스트 준비중 혹은 상기 테스트 수행 도중에 시스템 버스로부터 상기 CUT로 선택된 기능 컴포넌트 에 대한 액세스가 검출되면, 상기 ICT는 상기 CUT로 선택된 기능 컴포넌트를 일반 동작 상태로 복구시킬 수 있 다(S613). 상기 복구는 상기 CUT로 선택된 기능 컴포넌트의 레지스터 설정 값을 복구하고, 상기 CUT로 선택된 기능 컴포넌트와 통신하는 래퍼 상에서 입력 및 출력의 방향을 원래대로 되돌리는 것을 의미할 수 있다. 이 경우, 상기 ICT는 백-오프 타이머를 구동하고(S615), 상기 백-오프 타이머가 만료하면, S603 과정으로 귀환 할 수 있다. 한편, 상기 테스트 결과가 상기 CUT로 선택된 기능 컴포넌트에 문제(즉, 결함 혹은 손상 등)가 있다는 것을 나 타내면, 상가 ICT는 후 동작을 수행할 수 있다(S617). II-6. 내부 메모리에 대한 테스트 도 16은 내부 메모리에 대한 테스트 과정을 이해하기 쉽게 나타낸 블록도이다. 내부 메모리에 대한 테스트는 기능 컴포넌트에 대한 테스트와 다를 수 있다. 이하에서는 내부 메모리, 즉, 도1, 도3, 도6a, 및 도6b에 도시된 메모리에 대한 2가지 테스트 기법이 제시된다. 첫 째는, 상기 내부 메모리로부터 데이터를 읽어내는 과정에서 에러 검출 코드를 이용하여 에러를 검출하는 기 법이다. 만약 읽어낸 과정에서 획득된 에러 검출 코드가, 미리 정해진 에러 검출 코드와 다르다면, 상기 ICT는 에러로 판별할 수 있다. 두 번째는, 일반적인 동작 중에 하드(hard)한 방식으로 읽기-쓰기 테스트를 수행하는 기법이다. 도 16은 두 번째 기법을 나타낸다. 상기 내부 메모리를 감싸고 있는 테스트 로직은, 시스템이 구동중일 때에 읽 기-쓰기 테스트를 수행하고, 시스템 버스로부터의 액세스는 바이패스(bypass)할 수 있다. 테스트를 완벽하게 처 리하기 위하여, 상기 ICT 내의 테스터는 주소 관리를 책임질 수 있다. 도시된 일시적(temporally) 레지스터 파 일은 테스트로 인하여 삭제될 위험이 있는 원본 데이터를 일시적으로 저장 저장할 수 있다. 테스트가 수행 완료 되면, 상기 일시적 레지스터 파일 내의 상기 원본 데이터가 상기 내부 메모리 내로 다시 기록될 수 있다. 만약 테스트 수행 도중에, 예측 불가능한 액세스가 발생하면, 시스템 버스 상의 데이터가 상기 일시 레지스터 파일 내에 기록될 수 있고, 반대로 상기 일시 레지스터 파일 내의 데이터는 상기 시스템 버스로 이동될 수 있다. 전술한 바와 같은 테스트 기법은 내부 메모리 뿐만 아니라, 외부 메모리에도 동일하게 적용될 수 있다. II-7. 테스트 후의 동작 NPU 내에 하드웨어 결함이 있다면, 상기 테스트 후의 동작은 매우 중요할 수 있다. 예를 들어, 사용자에게 결함 여부를 알려서, 사용의 중단을 권고할 수 있다. 이를 위해, 도 11에 도시된 후 동작(Post Action) 수행기 는 결함이 검출된 기능 컴포넌트에 대한 정보 그리고 결함을 야기한 테스트 입력 데이터(즉, 테스트 벡터)에 대 한 정보를 제공할 수 있다. 전술한 정보는 결함이 있는 기능 컴포넌트의 위치를 사용자가 알 수 있도록 할 수 있다. 상기 결함이 검출된 기능 컴포넌트에 대한 사용은 중단되어야 하고, 격리되어야 한다. 상기 결함이 있는 기능 컴포넌트가 시스템 전체의 성능을 저하시키는 것을 방지하기 위하여, 해당 기능 컴포넌트의 출력 신호는 미리 정해진 신호로 대체될 수 있다. 또는, 해당 기능 컴포넌트는 리셋되거나, 게이팅될 수 있다. 또는 해당 기 능 컴포넌트에 대해서 파워 게이팅이 수행될 수 있다. 한편, 상기 기능 컴포넌트가 격리되는 경우, NPU는 다른 문제에 직면하게 될 수 있다. 일부 기능 컴포넌트에 결 함이 있더라도, NPU가 여전히 동작될 수 있도록 하기 위한 방안이 제시되어야 한다. 예를 들어, 상기 NPU가 높 은 신뢰성이 요구되는 제품에 장착되는 경우라면, 상기 NPU는 일부 기능 컴포넌트에 대한 스페어(spare)를 추가 로 포함해야 할 수 있다. 만약 일부 기능 컴포넌트에 결함이 있다면, 해당 기능 컴포넌트를 대신하여 스페어가 동작될 수 있다. 그러나 일부 기능 컴포넌트에 대한 중복적인 배치는, 반도체 면적을 증가시키는 요인이 될 수 있다. 이러한 문제점을 해결하기 위하여, NPU 내에 프로그래밍 가능한 로직을 추가하는 것이 효과적일 수 있다. III. 구동중에 기능 테스트 또는 기능들의 조합에 대한 테스트 도 17은 랜덤 번호 생성기를 이용하여 기능 테스트를 수행하는 과정을 나타낸 예시도이다. 기능 테스트는 테스트 입력 데이터(예컨대, 텍스트 벡터)를 CUT에 주입하고, CUT로부터의 출력이 의도된 출력과 일치하는지를 비교하는 테스트이다. 상기 비교에 기초하여 올바르게 평가하기 위하여, 각 입력 데이터는 의도된 출력을 정확하게 유도할 수 있어야 한다. 상기 테스트 입력 데이터는 모든 결함이 검출될 수 있도록, 테스트 범 위가 높아야 한다. 특정한 설계에서, 기능 테스트를 위해 2가지의 테스트 입력 데이터가 존재할 수 있다. 첫 째로, XOR 연산과 연 결된 랜덤 번호 생성기는 도 17에 도시된 테스트 동작을 위하여 사용될 수 있다. 일반적으로, 랜덤 번호 생성기 는 입력 시드(seed)에 기초하여 슈도(pseudo) 랜덤 번호 스트림을 생성할 수 있다. 상기 랜덤 번호 스트림은 상 기 래퍼를 통해 상기 CUT로 주입되고, 출력은 XOR 연산을 통해 테스트 결과 레지스터에 누적하여 저장된다. 테 스트가 완료되면, 상기 테스트 결과 레지스터에 저장된 값들은 상기 테스트 입력 데이터에 대응하는 의도된 결 과와 비교될 수 있다. 만약 상기 비교 결과 차이가 있다면, 에러가 통지된다. 두번째로, 테스트 입력 데이터를 위한 모든 테스트 패턴과 그리고 대응하는 예측 결과가 각기 고정되고, 상기 NPU 내의 내부 메모리 혹은 외부 메모리에 저장될 수 있다. 상기 메모리로부터의 테스트 입력 데이터(즉, 테스 트 벡터)가 CUT로 입력되면, 상기 CUT로부터의 출력과 그리고 상기 테스트 입력 데이터에 대응하는 의도된 결과 가 서로 비교될 수 있다. 구동 중에 기능 테스트를 수행하기 위하여, ICT는 데이터를 전송하고, 시스템 버스와 통신하고 그리고 CUT의 상 태를 모니터링하는 역할을 수행한다. 특히, ICT는 해당 CUT가 유휴 상태인 경우 언제 테스트를 수행해야 하는지 를 결정할 수 있다. 테스트 과정 중에, 랜덤 번호 생성기는 테스트 입력 데이터로서 랜덤 번호 스트림을 생성하 고, 상기 테스트 입력 데이터를 상기 CUT로 전송한다. 만약 테스트 결과와 의도된 테스트 결과 간에 차이가 있 다면, ICT는 해당 정보를 상기 후 동작 수행기로 전송한다. 기능 테스트는 해당 기능 컴포넌트들을 사용할 수 있기 때문에, 일반적으로 테스트 동작을 위한 주파수는 일반 동작을 위한 주파수 보다 낮거나 같아야만, 타이밍이 달라지는 것(즉, 타이밍 위반)을 피할 수 있다. 일반 동작 중에, 테스트를 실시간으로 하기 위하여, 테스트를 해당 기능 컴포넌트가 유휴 상태일 때 수행하는 것이 효과적 이다. 따라서, 어쩔 수 없이 높은 주파수로 테스트가 수행될 수 있다. IV. DFT(design for testability)와 ICT의 조합을 이용한 구동중(runtime) 테스트 IV-1. 다중 클럭 도 18a는 다중 클럭의 예시를 나타내고, 도 18b는 다중 클럭 하에서 테스터의 동작을 나타낸 예시도이고, 도 18c는 테스트 입력 데이터의 경로를 나타낸다. 테스트 수행 도중, 하나의 테스트 입력 데이터(즉, 테스트 벡터)를 주입하는 것과 관련하여, 2가지의 기법이 존 재할 수 있다. 첫 번째 기법은 도 18a에 도시된 \"데이터를 쉬프트하는\" 시간 구간을 이용하는 것이다. SE(scan enable) 포트가 인에이블되고, 플리-플롭(flip-flop)의 출력 Q가 다른 플리-플롭의 입력 D로 연결되는 것이다. 이러한 연결은 플리-플롭들의 체인을 통하여 스캔 입력을 스캔 출력으로 연결하는 스캔 체인을 만들 수 있다. 따라서, 설계된 모든 결합 로직(combinational logic)은 디스에이블될 수 있고, 데이터 경로(즉, 플리-플롭으로 부터 다른 플리-플롭으로의 경로)에 대한 기준 로직 셀이 존재하지 않을 수 있다. 도시되지는 않았으나, Tcycle 을 하나의 동작에 대한 클럭 구간이라고 정의하고, Tlaunch를 제1 플리-플롭의 클럭 소스로부터 제1 핀으로의 시간 지연이라 정의하고, Tcapture를 클럭 소스로부터 제2 플리-플롭의 제2 핀으로의 시 간 지연이라고 정의하고, Tclk2q를 제1 플리-플롭의 CK로부터 Q 핀으로의 시간 지연이라고 정의하고, Tdp-max를 제1 플리-플롭의 Q로부터 제2 플리-플롭의 D으로의 시간 지연이라고 정의 할 때, Tcycle > Tlaunch + Tclk2q + Tdp-max + Tsetup + Tmargin - Tcapture일 수 있다. Tsetup은 셋업하는데 필요한 시간이고, Tmargin은 허용 여유 시간이다. 스캔 테스트가 인에이블되었을 때, 스캔 테스트의 관점에서 Tdp-max는 0으로 줄어줄 수 있다. 이상적으로 Tdp-max는 0일 수 있다. 그러나, 타이밍 위반을 해결하기 위하여, 여러 인버터 또는 버퍼가 추가되는 경우 시간 지연은 0 보다 클 수 있다. 대안적으로, Tdp-max >> Tclk2q + Tsetup + Tlaunch - Tcapture 일 수 있다. \"데이터를 쉬프트 하는\" 시간 구간 동안에는 더 높은 주파수로 처리될 수 있다. 도 18a에 도시된 \"데이터를 캡쳐하는(Capture Data)\" 시간 구간 동안에는 스캔 인에이블 핀이 비활성화되고, 그 로 인해 기능 컴포넌트는 다시 활성화되고, 데이터 경로 상에서 결합 로직(combinational logic)이 활성화될 수 있다. 데이터를 캡쳐하는 동안 시간 타이밍의 위반을 해소하기 위하여, \"데이터를 쉬프트하는\" 시간 구간에서 일단에 위치한 클럭과 \"데이터를 캡쳐하는\" 시간 구간에서의 일단에 위치한 클럭 간에 시간 지연이 추가될 수 있다. 이러한 일단들의 클럭들 간에 지연은 일반 동작을 위한 클럭 사이클과 같거나 혹은 더 길 수 있다. 쉬프트되는 값에 해당하는 스캔 체인 상에서의 플리-플롭의 최대 개수에 기초하여, \"데이터를 쉬프트 하는\" 시간 구간이 언 제 완료되는지를 검출하기 위하여 카운터를 추가할 수 있고, \"데이터를 캡쳐하는\" 시간 구간에서의 시간 지연을 관리하기 위하여 또 다른 카운터를 추가할 수 있다. 도 18b에서 테스터은 2개의 입력 클럭을 수신한다. 하나는 일반 동작을 위해서 사용되는 f_clk이고, 다른 하나는 \"데이터를 쉬프트\"하기 위한 sclk일 수 있다. 상기 테스터 내에 \"클럭 설정기(clock configuration)\"를 삽입함으로써, sclk 신호가 상기 \"데이터를 쉬프트하는\" 구간 및 \"데이터를 캡쳐하는\" 구간 모두에서 사용될 수 있도록 설정될 수 있다. 일반 동작을 위한 f_clk와 테스트 동작을 위한 sclk 간에 스위칭을 제어하기 위하여, CUT에 대응하는 TE 신호가 사용될 수 있다. ICT 내의 테스트 블록은 스케줄러로부터 컴포넌트의 ID(즉 C_ID)를 수신하면, 테스트를 수행할 준비가 된다. 디코더를 통하여 이용가능한, CUT들의 TE들이 테스트 프로세스를 인에블시킬 수 있다. 도 19a 및 도 19b는 기능 컴포넌트의 예시를 나타내고, 도 19b는 ICT 내의 테스터로 테스트 입력 데이터(예컨대, 테스트 벡터)가 주입되는 예를 나타낸다. 구동 중 테스트에서 DFT(design for testability)를 적용하기 위해서, CUT 내에는 스캔 체인(scan chain)이 추 가되고, 스캔 플리-플롭에 의해서 모든 플립-플롭들이 둘러쌓여질 수 있다. 스캔 입력, 스캔 출력 그리고 TEST_ENABLE 및 SCAN_ENABLE 신호는 ICT 내의 테스터로 연결되고, CUT의 원래 입력 및 원래의 출력은 테스터와 그리고 래퍼를 통하여 시스템 버스와 통신할 수 있다. 도 19b에 도시된 바와 같이 테스터 패턴을 저장하는 메모리의 관점에서, 블록은 4개의 부분들로 나뉠 수 있다. 첫 번째 부분은 입력 쉬프트 벡터를 저장하는 부분이고, 두 번째 부분은 출력 쉬프트 벡터를 저장하는 부분이고, 세번째 부분은 입력 켑쳐 벡터를 저장하기 위한 부분이고, 네 번째 부분은 출력 캡쳐 벡터를 저장하 는 부분이다. 테스트를 시작하기 위하여, 입력 쉬프트 데이터는 메모리로부터 로딩되어 테스터를 통하여 CUT로 입력된다. 각 스캔 체인에서 모든 플리-폴롭이 쉬프트 벡터로 채워진 후, 스캔 입력과 초기 입력을 위한 값을 포함하는 제 1 입력 캡쳐 벡터가 로딩되면, 모든 스캔 출력과 초기 출력을 위한 값들을 포함하는 제1 출력 캡쳐 벡터가 로딩 되고, 이어서 실제 출력 캡쳐 데이터와 비교될 수 있다. 로딩된 각 쉬프트 벡터는 출력 쉬프트 데이터를 수반하고, 실제 출력 데이터와 출력 쉬프트 벡터 또는 출력 캡쳐 벡터 간에 비교가 수행될 수 있다. 도 20은 테스트 과정을 나타내고, 도 21은 테스트 과정 동안에 쉬프트 데이터 및 캡쳐 데이터의 예를 나타낸다. 데이터를 쉬프트하는 단계에서, scan_enable 포트가 인에이블 되면, 결합 로직(combinational logic) 없이, 플 리-플롭들을 통하여 SCAN_IN 포트가 SCAN_OUT 포트와 연결될 수 있다. 모든 플리-폴롭들이 상기 입력 쉬프트 벡 터로부터 쉬프트된 값들을 갖게 되기 까지, 입력 쉬프트 벡터는 모든 스캔 체인에 로딩될 수 있다. 각 클럭 사 이클에서 하나의 쉬프트 값이 하나의 플리-플롭을 통과할 수 있다(즉, 이전 플리-폴립의 D 핀은 다음 플리-플롭 의 D 핀으로 연결될 수 있다). 캡쳐링 단계에서, scan_enable 포트가 디스이에블되면, 모든 플리-폴롭들의 D 핀들이 이전 플리-폴롭의 Q 핀들 과 연결되지 않고, 직접 결합 로직으로 연결될 수 있다. 캡쳐 벡터 출력이 양극(+) 클럭 에지에서 결합 로직을 통하여 모든 플리-플롭들의 Q 출력으로 로딩될 수 있다. 데이터 전달 과정은 첫 번째 데이터 캡쳐 단계에서, 출력 데이터를 의도된 출력 데이터와 비교하기 위하여 준비 되고, 이후 매 양극(positive)의 클럭 에지에서 비교가 수행된다. 모든 테스트 벡터 입력들이 로딩되고, 과정은 제1 데이터 쉬프트 단계로 회기되고, 각 과정이 다시 시작된다. 도 21에서는 쉬프트 및 캡쳐 과정을 나타낸다. 도 21에 도시된 네모 상자는 플리-플롭을 나타내고, 각 스캔 체 인에서 모든 플리-플롭들이 데이터 쉬프트 단계의 마지막에 모두 채워지는 것이 나타나 있다. 도 22는 테스트 모드에서 일반 동작 모드로 전환하는 예를 나타낸다. 도 22를 참조하여 알 수 있는 바와 같이, 출력 테스트 모드 동안에 데이터 쉬프트 과정과 캡쳐 단계가 반복될 수 있다. 만약 해당 CUT에 대해 액세스가 발생하게 되면, 해당 CUT를 일반 동작 모드로 복구하고, 테스트는 백- 오프될 수 있다. 이후 일정 시간 구간 동안 스킵 모드가 진행되고, 그 이후 다시 출력 테스트 모드가 진행될 수 있다. 도 23은 플리-플롭들이 스캔 체인 상에서 동작되는 예를 나타내고, 도 24는 일반 동작 모드로 동작 하는 CUT의 일부를 나타낸다. 시스템 버스로부터 CUT에 대한 예기치 않은 액세스가 발생하는 경우, TEST_ENABLE는 디스에이블 되고, 데이터의 쉬프팅 또는 캡쳐링은 빠르게 중단될 수 있다. 그리고, CUT는 일반 동작 모드로 복구되고, 테스트는 백-오프될 수 있다. 상기 CUT가 다시 유휴 상태로 진입하면, 테스트를 위해 이전의 데이터 쉬프트 단계가 다시 시작될 수 있다. 그 러나 일반 동작 모드로부터 테스트 동작 모드로 전환된 이후 첫 번째 쉬프트 단계에서는, 출력 결과의 비교는 비활성화되고, 다음번 캡쳐링 단계부터 출력 결과의 비교가 수행될 수 있다. 즉, 도 23에 도시된 바와 같이 스캔 체인에서 모든 플리-플롭들에는 쉬프트된 입력 값들이 로딩되지 않으며, 비 교는 수행되지 않을 수 있다. 기능 테스트와 스캔 주입을 통한 테스트는 각기 장단점이 있다. 스캔 주입을 통한 테스트는 기능 테스트에 비해 서 더 많은 메모리를 사용하고, 시간이 지연되는 단점이 있지만, 테스트의 범위가 더 넓다는 장점이 있다. 특히, NPU가 자율 주행 자동차, 드론(Drone), UAM(Urban Air Mobility), UAV(unmanned aerial vehicle)와 같이 높은 신뢰도를 요구하는 제품에 장착될 경우, 테스트 범위가 넓은 스캔 주입 방식의 테스트가 유리하다. 또한, 스캔 주입 방식의 테스는, 테스트 동작을 위한 주파수를 높일 수 있고, 이는 테스트 시간을 줄일 수 있도록 한 다. 테스트하는데 오랜 시간이 걸릴 경우, 자동차 사고의 가능성을 그만큼 높일 수 있기 때문에, 바람직하지 않 다. 스캔 주입 방식의 테스트는 테스트 동작을 위한 주파수를 높일 수 있기 때문에, 유휴 시간 동안에 더 많은 테스트 패턴을 주입시킬 수 있고, NPU 내의 하드웨어 결함이 더 빨리 검출될 수 있도록 한다. 물론, 일반적인 기능 테스트는 전력 소모가 더 적은 장점은 있지만, 자율 주행 자동차, 드론(Drone), UAM(Urban Air Mobility), UAV(unmanned aerial vehicle)와 같이 높은 신뢰도가 요구되는 환경에서는 전력 소모량보다 동작 안정성이 더 중요 사항일 수 있다. 본 명세서와 도면에 나타난 본 개시의 예시들은 본 개시의 기술 내용을 쉽게 설명하고 본 개시의 이해를 돕기 위해 특정 예를 제시한 것뿐이며, 본 명의 범위를 한정하고자 하는 것은 아니다. 지금까지 설명한 예시들 이외 에도 다른 변형 예들이 실시 가능하다는 것은 본 개시가 속하는 기술 분야에서 통상의 지식을 가진 자에게 자명 한 것이다.부호의 설명 100: 신경 프로세싱 유닛(NPU) 110: 프로세싱 엘리먼트(PE) 120: NPU 내부 메모리 130: NPU 스케줄러 140: NPU 인터페이스 160: 컨트롤러 170: ICT 190: 래퍼"}
{"patent_id": "10-2022-0054878", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 개시에 따른 신경 프로세싱 유닛을 설명하는 개략적인 개념도이다. 도 2는 본 개시에 적용될 수 있는 복수의 프로세싱 엘리먼트 중 하나의 프로세싱 엘리먼트를 설명하는 개략적인 개념도이다. 도 3은 도 1에 도시된 신경 프로세싱 유닛의 변형예를 나타낸 예시도이다. 도 4는 예시적인 인공신경망모델을 설명하는 개략적인 개념도이다. 도 5a은 컨볼루션 신경망의 기본 구조를 설명하기 위한 도면이다. 도 5b는 컨볼루션 신경망의 동작을 이해하기 쉽게 나타낸 종합도이다. 도 6a는 테스트 기능을 갖춘 NPU의 구성을 제1 예시에 따라 나타낸 블록도이다. 도 6b는 테스트 기능을 갖춘 NPU의 구성을 제2 예시에 따라 나타낸 블록도이다. 도 7은 테스트 기능을 갖춘 NPU의 구성을 제3 예시에 따라 나타낸 블록도이다. 도 8은 플리-플롭을 스캔하는 예를 나타낸다. 도 9는 하드웨어 설계 내에 스캔 테스트를 위한 아키텍처가 추가된 예를 나타낸다. 도 10은 래퍼의 동작을 나타낸 예시도이다. 도 11은 ICT의 내부 구성을 나타낸 예시도이다. 도 12는 ICT가 기능 컴포넌트가 유휴 상태인지를 모니터링하는 동작을 상세하게 나타낸 블록도이다. 도 13은 시스템 버스 상에서 동작하는 마스터(master), 슬래이브(slave), 아비터(arbiter) 간에 동작을 나타낸 예시도이다. 도 14는 칩 내에 쉬프트 레지스터가 추가된 예를 나타낸다. 도 15는 ICT의 동작 순서를 나타낸 예시도이다. 도 16은 내부 메모리에 대한 테스트 과정을 이해하기 쉽게 나타낸 블록도이다. 도 17은 랜덤 번호 생성기를 이용하여 기능 테스트를 수행하는 과정을 나타낸 예시도이다. 도 18a는 다중 클럭의 예시를 나타낸다. 도 18b는 다중 클럭 하에서 테스터의 동작을 나타낸 예시도이다. 도 18c는 테스트 입력 데이터의 경로를 나타낸다. 도 19a 및 도 19b는 기능 컴포넌트의 예시를 나타낸다. 도 19b는 ICT 내의 테스터로 테스트 입력 데이터(예컨대, 테스트 벡터)가 주입되는 예를 나타낸다. 도 20은 테스트 과정을 나타낸다. 도 21은 테스트 과정 동안에 쉬프트 데이터 및 캡쳐 데이터의 예를 나타낸다. 도 22는 테스트 모드에서 일반 동작 모드로 전환하는 예를 나타낸다. 도 23은 플리-플롭들이 스캔 체인 상에서 동작되는 예를 나타낸다. 도 24는 일반 동작 모드로 동작 하는 CUT의 일부를 나타낸다."}
