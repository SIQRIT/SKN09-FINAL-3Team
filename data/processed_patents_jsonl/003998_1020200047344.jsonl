{"patent_id": "10-2020-0047344", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2021-0129413", "출원번호": "10-2020-0047344", "발명의 명칭": "인공지능 기반의 히스토리 데이터 관리 방법", "출원인": "(주)제타미디어", "발명자": "손인기"}}
{"patent_id": "10-2020-0047344", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "현재 배포 중인 학습 번호의 원본 저장소의 하위 디렉토리에 추가된 학습 데이터를 트리구조로 저장하는 단계; 상기 원본 저장소의 디렉토리에 업로드된 학습 데이터의 심볼릭링크 파일을 생성하여 링크 저장소에 저장하는단계;를 포함하되, 상기 원본 저장소의 하위 디렉토리 및 링크 저장소의 심볼릭링크 파일은 \"부모학습번호_자식학습번호\"의 형태로이름이 부여되는 것을 특징으로 하는 인공지능 기반의 히스토리 데이터 관리 방법."}
{"patent_id": "10-2020-0047344", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 학습이 요청되면 상기 심볼릭링크 파일을 검색하여 한번의 디렉토리 검색으로 해당 학습 데이터의 전체 디렉토리 명을 얻는 단계; 상기 \"부모학습번호_자식학습번호\" 형태의 전체 디렉토리 명을 \"_\" 토큰자를 파싱하여 각각의 디렉토리 명을 획득하는 단계; 및 상기 획득한 각각의 디렉토리 명으로 해당 학습 데이터를 검색하는 단계;를 더 포함하는 인공지능 기반의 히스토리 데이터 관리 방법."}
{"patent_id": "10-2020-0047344", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항 또는 제2항에 있어서, 상기 원본 저장소의 디렉토리를 검색하여 현재 배포 중인 학습번호의 하위 디렉토리가 존재하지 않으면 하위 디렉토리를 생성하는 단계; 상기 디렉토리에 현재 배포 중인 학습 번호의 학습 데이터를 저장하는 단계; 및 상기 학습 데이터에 대한 심볼릭링크 파일을 생성하는 단계를 더 포함하는 인공지능 기반의 히스토리 데이터 관리 방법."}
{"patent_id": "10-2020-0047344", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 배포 중인 학습 데이터의 노드를 변경하는 경우 이동할 노드의 하위 노드에 대한 심볼릭 링크를 해제하는단계; 상기 학습 데이터를 이동할 노드에 등록하는 단계; 및 상기 이동한 노드의 심볼릭링크 파일을 생성하여 저장하는 단계를 더 포함하는 인공지능 기반의 히스토리 데이터 관리 방법."}
{"patent_id": "10-2020-0047344", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 인공지능 기반의 히스토리 데이터 관리 방법에 관한 것으로, 상세하게는 학습 데이터가 업데이트되면 데이터 처리부가 현재 배포 중인 학습 번호의 원본 저장소의 하위 디렉토리에 추가된 학습 데이터를 트리구조로 저장하는 단계와, 상기 데이터 처리부가 상기 원본 저장소의 디렉토리에 업로드된 학습 데 이터의 심볼릭링크 파일을 생성하여 링크 저장소에 저장하는 단계를 포함하되, 상기 원본 저장소의 하 위 디렉토리 및 링크 저장소의 심볼릭링크 파일은 \"부모학습번호_자식학습번호\"의 형태로 이름을 부여하도 록 구성한다. 이러한 본 발명은 딥러닝을 위한 데이터를 업로드 별로 관리하여 전체 데이터의 업로드없이도 데이 터의 롤백 및 업데이트가 용이하고, 그에 따라 데이타가 변경된 경우에도 데이터의 학습 과정이 빠른 시간 내에 이루어짐으로 학습 모델의 정확도를 향상시킬 수 있다."}
{"patent_id": "10-2020-0047344", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 데이터 관리 기술에 관한 것으로, 상세하게는 인공지능 학습에 있어서 인공지능 기반의 히스토리 데 이터 관리 방법에 관한 것이다."}
{"patent_id": "10-2020-0047344", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "컴퓨팅 기술이 발전하면서 이에 필요로 하는 데이터베이스 시스템도 점점 대용량화되고 있으며, 이에 따라 대용 량의 데이터베이스를 관리하는 기술이 요구되고 있다. 한편, 최근 컴퓨팅 기술이 발전하면서 인공지능 기술도 획기적으로 발전하고 있는데, 특히 딥러닝(Deep Learning) 기술이 도입되면서 인공지능 기술을 다양한 분야에 활용하고자 하는 연구도 활발히 진행되고 있다. 또한, 근래 멀티미디어를 기반으로 하는 다양한 서비스가 제공되면서 멀티미디어 서비스에 적합한 데이터 수집 및 학습모델 생성에 관련하여 딥러닝 기술의 도입도 확산되고 있다. 딥러닝을 위한 프레임워크는 AI 엔진으로서, 학습 데이터를 레이블(lables) 등으로 지정해주고, 레이블(lables) 디렉토리에 이미지들을 복사하여 학습하고 그 학습 결과를 분류(classification)하는 작업을 기본적으로 수행한 다. 여기서, 상기 분류라 함은 학습이 완료된 전체 레이블(lables)들 중에서 가장 유사도가 높은 클래스를 예측 (prediction)한다는 것을 의미한다. 최근 딥러닝 프레임워크는 Tensorflow, Caffe, Keras, Torch, Yolo 등과 같이 다양한 알고리즘들이 제공되고 있다. 상기와 같은 딥러닝 기술은 학습 결과의 정확도를 향상시키기 위해서 많은 학습 데이터를 필요로 하며, 이를 위 해 학습 데이터를 계속 추가하여 업데이트하여야 한다. 이에 따라, 딥러닝 기술에 필요한 대용량의 데이터를 관리하기 위한 하나의 방법으로는 도 1에 도시된 바와 같 이, 원본 저장소에 원본파일이 저장되고, 링크저장소에 상기 원본파일의 저장위치 정보를 포함하는 심볼릭링크 파일이 저장되는 방식이 사용되고 있다. 이는 실제 원본파일을 복사하지 않고 원본파일의 저장정보만을 관리하다가 필요한 경우에 심볼릭링크 파일을 이 용하여 해당 원본파일을 검색할 수 있도록 함으로써 데이터를 효율적으로 관리하기 위한 것이다. 그런데, 딥러닝 기술은 학습 데이터가 많을수록 좋은 성능을 보이기 때문에 학습 데이터를 계속해서 업데이트해 야 하지만, 학습 데이터가 추가되거나 잘못된 데이터가 존재하여 그 잘못된 데이터를 삭제한 경우 전체 학습 데 이터를 다시 학습하여 새로이 학습 데이터를 구성하여야 한다. 상기에서 잘못된 데이터라 함은 '사자'로 레이블링된 클래스에 작업자의 실수 등으로 '호랑이' 이미지가 들어가 게 되는 경우를 말하며, 이는 딥러닝의 정확도를 향상시키기 위해서 방대한 량의 학습 데이터가 필요함으로 계 속 학습 데이터를 추가하는 과정에서 잘못된 데이터가 추가되는 경우로서, 이러한 경우 딥러닝 성능이 저하될 수 있음으로 잘못된 데이터의 삭제를 필요로 한다. 즉, 종래에는 학습할 데이터가 단 하나라도 추가되거나 삭제 등의 변화가 발생된다면 인공지능 기술의 특성 상 전체 데이터를 다시 재학습해야 하는 상황이 발생하게 된다. 이에 따라, 종래에는 학습 데이터의 추가 또는 잘못된 데이터의 삭제가 발생하는 경우마다 방대한 학습 데이터 에 대해 다시 학습을 진행하여야 하는 과정을 작업자가 수작업으로 진행하여야 하는 불편함과 어려움이 있다. 선행기술문헌 특허문헌 1. (특허문헌 0001) 대한민국 등록특허 10-1368500호 \"데이터베이스 히스토리 관리 방법 및 그를 위한 데이터베 이스 히스토리 관리 시스템\" (등록일자 : 2014. 02. 21.)"}
{"patent_id": "10-2020-0047344", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 종래의 문제점을 해결하기 위하여, 데이터의 히스토리를 업로드 시점 별로 관리하여 전체 데이터의 업로드함이 없이 데이터 롤백(rollback) 및 업데이트(update)를 간편하게 수행할 수 있도록 함으로써 학습 성능 을 향상시키도록 하는데 목적이 있다. 또한, 본 발명의 다른 목적은 데이터가 저장되는 디렉토리 이름을 상위노드와 하위노드를 연계한 형식으로 부여 하여 한번의 검색으로 학습할 데이터를 찾을 수 있도록 하는데 있다. 또한, 본 발명의 또 다른 목적은 원본데이터과 그 원본데이터를 검색할 수 있는 심볼릭링크 파일을 분리하여 관 리함으로써 데이터의 저장 공간을 효율적으로 사용할 수 있도록 하는데 있다."}
{"patent_id": "10-2020-0047344", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명은 상기의 목적을 달성하기 위하여, 학습 데이터가 업데이트되면 현재 배포 중인 학습 번호의 원본 저장 소의 하위 디렉토리에 추가된 학습 데이터를 트리구조로 저장하는 단계; 상기 원본 저장소의 디렉토리에 업로드 된 학습 데이터의 심볼릭링크 파일을 생성하여 링크 저장소에 저장하는 단계;를 포함하되, 상기 원본 저장소의 하위 디렉토리 및 링크 저장소의 심볼릭링크 파일은 \"부모학습번호_자식학습번호\"의 형태로 이름이 부여되는 것 을 특징으로 한다. 또한, 상기 과정을 진행함에 있어서, 학습이 요청되면 심볼릭링크 파일을 검색하여 한번의 디렉토리 검색으로 해당 학습 데이터의 전체 디렉토리 명을 얻는 단계; 상기 \"부모학습번호_자식학습번호\" 형태의 전체 디렉토리 명을 \"_\" 토큰자를 파싱하여 각각의 디렉토리 명을 획득하는 단계; 및 상기 획득한 각각의 디렉토리 명으로 해 당 학습 데이터를 검색하는 단계;를 포함한다. 또한, 상기 과정에서 원본 저장소의 디렉토리를 검색하여 현재 배포 중인 학습번호의 하위 디렉토리가 존재하지 않으면 하위 디렉토리를 생성하고 그 디렉토리에 현재 배포 중인 학습 번호의 학습 데이터를 저장하는 단계; 및 상기 학습 데이터에 대한 심볼릭링크 파일을 생성하는 단계를 더 포함한다. 또한, 본 발명은 배포 중인 학습 데이터의 노드를 변경하는 경우 이동할 노드의 하위 노드에 대한 심볼릭 링크 를 해제하는 단계; 상기 학습 데이터를 이동할 노드에 등록하는 단계; 및 상기 이동한 노드의 심볼릭링크 파일 을 생성하여 저장하는 단계를 포함한다."}
{"patent_id": "10-2020-0047344", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "상기의 본 발명은 딥러닝을 위한 데이터를 업로드 별로 관리하여 전체 데이터의 업로드없이도 데이터의 롤백 및 업데이트가 용이하고, 그에 따라 데이타가 변경된 경우에도 데이터의 학습 과정이 빠른 시간 내에 이루어짐으로 학습 모델의 정확도를 향상시킬 수 있다. 또한, 본 발명은 원본 저장소의 디렉토리에는 클래스 별로 업데이트된 데이터를 저장하고, 링크 저장소의 디렉 토리에는 원본 저장소의 디렉토리에 저장된 데이터 파일들에 대한 심볼릭링크 파일을 저장하여 데이터 관리를 수행함으로 저장공간을 효율적으로 관리할 수 있는 것은 물론 심볼릭 링크의 생성 또는 해제만으로 학습 데이터 를 업데이트할 수 있다. 또한, 본 발명은 학습 데이터를 저장할 디렉토리 명을 \"부모 학습번호_자식 학습번호\" 형태로 부여하여 한번의 디렉토리 검색으로 학습 데이터가 저장된 전체 디렉토리를 찾아 해당 학습 데이터를 빠른 시간 내에 찾아 처리 할 수 있다."}
{"patent_id": "10-2020-0047344", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 본 발명에 따른 실시 예를 도면을 참조하여 설명하면 다음과 같다. 본 발명의 실시 예에 대해서 특정한 구조 또는 기능적 설명들은 본 발명에 따른 실시 예를 설명하기 위해 예시"}
{"patent_id": "10-2020-0047344", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "된 것으로, 별도로 정의하지 않는 한, 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자가 이해하는 것과 동일한 의미로 파악되어야 할 것이다. 또한, 본 발명의 실시 예를 설명하기 위한 도면에서 본 발명을 명확한 설 명과 관계없는 부분은 생략한다. 본 발명은 건축, 의료, 미디어(방송, 광고) 등의 다양한 데이터 관리 분야에 적용할 수 있도록 구현하는 것이나, 본 발명의 실시 예에서는 학습할 데이터를 '이미지'로 가정하고 그에 따른 데이터 관리 방법을 설명하 기로 한다. 또한, 컴퓨팅 시스템은 운영체제(Operating System ; 이하 'OS'라 약칭함)를 탑재하여 작동하며, 자원의 효율적 관리, 사용자의 편리한 작업 환경을 제공하는데, OS라 함은 시스템 하드웨어를 관리할 뿐 아니라 응용 소프트웨 어를 실행하기 위하여 하드웨어 추상화 플랫폼과 공통 시스템 서비스를 제공하는 일종의 시스템 소프트웨어를 말한다. OS는 크게 Windows, Linux, Unix 3가지로 분류될 수 있다. 본 발명은 인공지능에 적용한 딥러닝(deep learning)을 위한 학습 데이터 및 학습된 모델의 히스토리(history) 를 트리구조로 관리함에 있어서, 상위노드와 하위노드를 연계하여 데이터의 저장위치 정보를 생성함으로써 원하 는 데이터를 한번에 검색할 수 있도록 하는 것으로, 특정 OS에 한정됨이 없이 대용량의 데이터 관련 분야에 적 용할 수 있으나, 본 발명의 실시 예는 Linux 환경에서 구현하는 경우를 설명하기로 한다. 도 2은 본 발명의 실시 예를 히스토리 데이터 관리 시스템의 블록 구성도로서 이에 도시한 바와 같이, 웹서버 , 이미지 학습부 및 데이터 저장부를 포함하여 구성한다. 상기 웹서버는 웹사이트에서 크롤링(crawling)하거나 영상 등에서 이미지를 추출하여 학습할 이미지를 수 집한다. 이러한 웹서버는 소프트웨어 또는 그 소프트웨어를 실행하는 컴퓨터로 구성할 수 있다. 상기 이미지 학습부는 상기 웹서버에서 업로드된 학습할 이미지를 클래스(class) 분류, 레이블 (lables) 파일 생성, 레이블에 작성된 클래스 명으로 디렉토리 이름 생성, 디렉토리 하위에 학습 이미지를 분류 하여 학습 데이터를 생성하고 상기 웹서버의 학습 요청에 따라 상기 학습 데이터를 학습하여 그 결과를 상 기 웹서버에 전달한다. 상기 이미지 학습부는 웹서버에서의 요청으로 학습하는 것으로 설명하였으나, 신규로 학습할 이미지 의 업로드를 확인하여 자동으로 딥러닝을 진행할 수 있다. 상기 이미지 학습부는 적어도 하나 이상의 AI서버로서, 학습할 데이터가 업로드되면 압축 해제하여 데이터 저장부에 저장하고 그 합습 데이터의 상위노드와 하위노드가 연계된 형식의 심볼릭링크 파일을 생성하여 상기 데이터 저장부에 저장하는 데이터 처리부와, 딥러능 프레임워크를 이용하여 상기 데이터셋 학습 을 수행하여 학습모델을 생성하는 딥러닝 프레임워크와, 학습할 데이터의 압축 해제가 이루어지는 캐시버 퍼를 포함하여 구성한다. 상기 데이터 저장부는 업로드된 원본 이미지들을 업로드 시점별로 상위노드_하위노드와 같은 형식으로 연 계하여 트리 구조로 저장 관리하고, 딥러닝 프레임워크에서 학습 디렉토리로 지정한 곳에 원본 이미지들에 대한 심볼릭링크를 복사하여 관리한다. 이러한 데이터 저장부는 스토리지(storage), DB서버 또는 파일서버 를 적어도 하나를 포함한다. 상기 데이터 저장부는 원본 저장소 디렉토리와 딥러닝 프레임워크가 학습할 데이터가 들어있는 링크 저장소 디렉토리로 구분하여 관리한다. 이러한 데이터 저장부는 도 3에 도시한 바와 같이, 한번에 업로드된 학습 데이터에 학습 번호를 부여하고 현재 배포중인 학습번호의 자식 디렉토리에 업로드된 클래스의 레이블(lables) 디렉토리를 생성하고 추가된 학 습 데이터를 저장하는 링크 저장소와, 이미지를 식별하는 딥러닝 프레임워크에 의해 레이블(lables) 들의 디렉토리가 생성되고 학습할 데이터가 레이블(lables) 디렉토리에 저장되는 원본 저장소를 포함하여 구성된다. 상기의 이미지 수집부, 데이터 저장부 및 이미지 학습부의 네트워크 구성은 유선 또는 무선 통 신방식은 물론 내부통신망을 이용한 직접적 연결방식 또는 외부통신망을 이용한 원격 연결방식을 설계에 적합하 게 선택할 수 있는데, 네트워크 구축에 필요한 적어도 하나의 통신방식을 선택하고 해당 통신방식에 적합한API(Application Programming Interface)를 제공하도록 구성함으로써 학습할 데이터, 가공 데이터 또는 학습된 데이터의 공유가 가능하도록 하여 구성요소 상호 간의 접근성을 향상시킬 수 있도록 한다. 본 발명의 실시 예에서는 학습할 데이터가 추가로 업로드되어 자식노드가 증가할수록 뎁스(Depth)가 깊어지는데, 이를 방지하기 위해 학습번호 디렉토리 이름을 \"부모 학습번호_자식 학습번호\" 형태(예를 들어, \"/4_6/\")로 생성하고 배포중인 모델을 변경할 때 심볼릭링크 파일(예로, \"/scrImages/4_6/bird/5.jpg\")을 이용 하여 한번의 디렉토리 검색을 통해 전체 디렉토리 명을 얻고 \"_\" 토큰자를 파싱하여 부모와 자식 디렉토리를 빠 르게 찾아 처리 할 수 있게 한다. 또한, 상기 딥러닝 프레임워크는 학습 데이터를 업데이트 할 경우 원본 학습 데이터 파일들을 심볼릭 링크 로 생성하여 링크 저장소에 각 레이블(lables) 디렉토리에 저장한다. 상기 링크 저장소에 생성된 각 각의 레이블(lables) 디렉토리에는 이전에 업로드 된 부모 학습 이미지들의 심볼릭 링크 파일이 존재한다. 도 4는 본 발명의 실시 예에서 학습 데이터가 저장되는 트리구조를 설명한 것으로, 각각의 노드들은 학습된 모 델(trained model weight)로서, 노드의 레벨에 따라 상위는 부모노드, 하위는 자식노드, 같은 레벨은 형제노드 라 한다. 웹서버에서 학습할 데이터가 업로드되면 현재 배포중인 부모의 하위 레벨(자식)로 등록되고, 링크 저장소 의 디렉토리에는 각각의 노드의 모든 데이터 및 새로 업데이트된 학습 데이터들이 추가되어 딥러닝 프레임 워크가 학습할 수 있도록 한다. 또한, 이전에 업데이트된 다른 자식 노드가 존재하는 경우 이 둘 사이는 형제 노드 관계가 된다. 현재 배포중인 노드의 부모나 조상 노드로 배포중인 모델을 변경하고 학습 데이터를 업로드하게되면 부모 노드의 아래로 새로 운 브렌치의 자식노드가 생성된다. 본 발명의 실시 예에서 학습 데이터를 업로드하고 딥러닝 학습하는 과정을 도 5의 신호 흐름도를 참조하여 설명 하면 다음과 같다. 웹서버에서 이미지 학습부로 신규 학습파일의 업로드를 요청한다.(S501) 이때, 이미지 학습부는 부모학습번호, 업로드파일의 학습번호를 웹서버로 응답(S502)하면, 상기 웹서 버는 학습이미지의 압축파일을 업로드한다(S503). 이후, 이미지 학습부는 데이터 처리부가 히스토리 데이터 관리를 위해 캐시서버에 임시디렉토리 를 생성하고,웹서버에서 업로드된 학습 이미지를 압축해제하여 상기 임시디렉토리에 저장한다.(S504) 이후, 데이터 처리부는 원본 저장소에 \"부모학습번호_신규학습번호\"라는 이름의 디렉토리를 생성하고, 그 디렉토리에 상기 임시디렉토리에 복사된 학습이미지를 복사한다.(S505) 이후, 데이터 처리부는 상기 업로드된 학습이미지에 대한 심볼릭링크 파일을 생성하여 링크 저장소에 복사한다.(S506) 이에 따라, 이미지 학습부는 학습이미지의 업로드가 완료되었음을 웹서버에 관리자 서버에 전달한다. 이후, 웹서버에서 상기 업로드된 학습이미지에 대한 학습을 요청(S507)하면 이미지 학습부는 딥러닝 프레임워크에 딥러닝 시작을 지시(S508)한다. 이때, 딥러닝 프레임워크는 데이터 처리부에서 생성한 심볼릭링크파일을 링크저장소에서 읽어 각 디렉토리별 학습이미지를 원본 저장소에서 로드하여 캐시버퍼에 복사한다(S510). 이후, 딥러닝 프레임워크는 캐시버퍼에 저장된 학습이미지를 딥러닝하여 학습모델을 생성한다(S511). 이에 따라, 이미지 학습부는 상기 업로드된 학습 이미지에 대한 학습결과를 웹서버에 전달하게 된다 (S512). 즉, 본 발명의 실시 예에서는 학습 데이터가 준비되면 웹서버가 이미지 학습부로 학습 요청을 하게 되고 딥러닝 프레임워크에서는 이전에 업로드된 부모 노드들부터 현재 노드까지의 학습 데이터 파일이 심 볼릭 링크로 저장된 링크 저장소에서 항목별(class)로 생성된 레이블(lables) 디렉토리를 읽고, 각 레이블 (lables) 디렉토리들의 학습 이미지 데이터 파일들을 읽어 딥러닝(tranning)하는 것이다. 한편, 상기에서 학습할 데이터를 업데이트하는 과정을 도 6의 신호 흐름도를 참조하여 설명하면 다음과 같다. 먼저, 학습할 데이터 레이블(lables)을 디렉토리 명으로 생성한 압축파일을 업로드하면, 현재 학습이 완료되어 배포중인 모델의 학습번호(ID)가 부모번호가 되고 신규로 업로드된 파일에 신규 학습번호가 부여된다. 이후, 웹서버에서 학습할 파일이 업로드되면 이미지 학습부는 캐시버서에 압축을 해제하여 학습 할 준비를 한다. 이후, 데이터 처리부는 원본 저장소에서 부모번호 디렉토리의 하위 디렉토리에 현재 학습번호 디렉토 리를 생성한다.(S601) 이후, 데이터 처리부는 캐시버퍼에 압축 해제된 임시 디렉토리에서 레이블(lables) 디렉토리명들을 읽어(S602), 각각의 레이블(lables) 디렉토리 별로 원본 저장소의 디렉토리에 복사한다(S603). 이후, 데이터 처리부는 링크 저장소의 부모 디렉토리의 하위 디렉토리에 현재 레이블(lables)명의 디 렉토리가 있는지 확인한다(S604). 이때, 상기에서 현재 레이블 명의 디렉토리가 존재하면 데이터 처리부는 그 하위 레이블(lables) 디렉토리 에 학습할 데이터에 대한 심볼릭링크 파일을 생성한다(S606). 만일, 상기에서 현재 레이블 명의 디렉토리가 존재하지 않으면 데이터 처리부는 하위 디렉토리에 업로드된 학습 데이터의 레이블 디렉토리를 생성(S605)하고, 그 생성된 레이블 디렉토리에 학습할 데이터에 대한 심볼릭 링크 파일을 생성한다(S606). 이후, 상기 디렉토리 생성 과정(S603~S606)을 진행하면서 마지막 디렉토리인지 확인(S607)하고, 마지막 디렉토 리가 아니면 상기 디렉토리 생성과정(S603~S607)을 반복적으로 수행함으로써 모든 업로드된 레이블(lables) 디 렉토리의 데이터를 원본 저장소의 디렉토리로 복사하고 링크 저장소의 디렉토리 내에 심볼릭 링크 파 일을 생성한다. 상기와 같이 업로드된 학습 데이터를 원본 저장소에 저장하고 그 학습 데이터에 대한 심볼릭링크 파일을 링크 저장소에 생성하여 학습을 진행함에 있어서, 현재 배포중인 모델을 이전에 학습하여 만들어진 상위의 부모노드 모델로 변경하는 경우가 발생할 수 있다. 이를 도 7의 예시도를 참조하여 설명하면 다음과 같다. 도 7은 이전에 만들어진 상위의 부모노드 브랜치로 변경하여 부모 노드의 학습 데이터를 기반으로 새로운 데이 터를 추가하여 예측 정확도가 더 높은 모델을 만들기 위해 결과(accuracy)를 비교해 보거나 새로 추가한 학습 데이터가 잘못되어 결과값(accuracy)이 이전보다 낮아졌을 때 원하는 지점의 부모노드 모델로 롤백할 때에 학습 데이터를 재구성하는 처리 동작에 대한 설명이다. 도 7에서 배포란 딥러닝 프레임워크에서 학습된 결과물로 학습모델 파일(trained model weights)을 생성하 여 제공하는 것을 의미한다. 학습 모델 파일은 도 4와 같이 트리 형태로 관리 되며, 이 중 클래스들을 예측 (prediction)하도록 선택한 모델을 말한다. 도 7a는 자식노드의 모델을 상위노드의 모델로 변경하는 경우를 설명하기 위한 것으로, 배포중인 모델을 '노드 6'에서 부모인 '노드 2'로 변경(S701)한다면 자식노드('노드 6')에서 업로드된 학습 데이터의 심볼릭 링크를 해 제 한다(S702). 이때, 딥러닝 프레임워크가 학습할 데이터가 저장된 디렉토리로 설정된 링크 저장소의 디렉토리에는 현재 배포중인 '노드 6'의 모델의 상위노드인 '노드 1', '노드 2' 및 '노드 4'가 생성될 때 업로드된 학습 데이 터 파일의 심볼링 링크 파일들이 저장되어있다. 따라서, '노드 6'의 모델을 '노드 2'로 배포하여 모델을 변경 하게 되면 '노드 2'의 하위노드들('노드 4', '노 드 6')에 업로드된 모든 학습 데이터 파일의 심볼릭 링크를 해제하게 되며, 이에 따라 변경된 배포 모델인 '노 드 2'와 '노드 1'에 업로드된 학습 데이터 파일들만 남게된다. 즉, 도 7과 같이 하위노드의 모델을 상위노드로 변경하는 경우 히스토리 관리를 위해 업로드된 데이터별로 \"부 모 학습번호_자식 학습번호\"형태로 저장된 원본 저장소의 디렉토리에서 '노드 2'의 학습 번호를 부모로하 는 자식 디렉토리를 검색하여 업로드된 학습 데이터 파일들의 경로정보를 얻어 링크 저장소에 존재하는 심볼릭링크를 해제한다. 또한, 현재 배포 중인 모델을 다른 자식노드로 변경하는 경우에 대해 도 8을 참조하여 설명하기로 한다. 도 8은 한 부모로부터 파생된 자식노드 브랜치가 여러 개일때 다른 형제 브랜치나 부모노드에서 하위의 자식노드로 배포모델을 변경했을 때 학습할 데이터를 재구성하는 처리 동작을 설명하기 위한 것이다. 한 뿌리의 부모노드로부터 학습데이터를 다르게 입력하고 결과(accuracy)를 비교해 보고자 한다면 부모노드로 이동하여 기존에 업로드된 학습 데이터에 새로운 데이터를 추가하여 하위 트리형태로 자식노드 브랜치를 만들수 있다. 배포중인 모델을 '노드 6'에서 다른 자식 노드인 '노드 3'(도 8a의 이미지)이나 '노드 5'(도 8b의 이미지)로 변 경하는 경우 데이터 처리부는 새로 배포할 노드의 부모노드의 자식 노드들에서 업로드된 모든 학습할 데이 터의 심볼릭 링크를 해제 한다(S802). 즉, 배포 중인 다른 브랜치로 변경(도 8a에서 '노드 6'에서 '노드 3'으로 변경)하는 경우와 다른 형제 노드로 변경(도 8b에서 '노드 6'에서 '노드 5'로 변경)하는 경우 2가지 경우 모두 브랜치가 나눠지는 부모(조상)노드의 학습 번호(도 8 a에서는 '노드 2', 도 8b에서는 '노드 4')를 얻어 \"부모학습번호_자식학습번호\" 형태로 저장된 원본 저장소의 디렉토리에서 자식 디렉토리를 검색하여 업로드된 학습 데이터들의 경로정보를 얻어 링크 저장소에 존재하는 심볼릭 링크를 해제하는 것이다. 이후, 데이터 처리부는 배포될 노드의 학습 데이터들에 대한 심볼릭 링크를 링크 저장소의 디렉토리 에 생성한다(S803). 다시 말해서, 원본 저장소의 디렉토리에서 새로 배포된 모델의 학습번호(도 8a의 '노 드 3', 도 8b의 '노드 5')로부터 브랜치가 나눠지는 부모노드의 학습 번호(도 8a의 '노드 2', 도 8b의 '노드 4')까지 부모 디렉토리를 검색하여 업로드된 학습 데이터들의 경로정보를 얻어 링크 저장소의 디렉토리에 심볼릭 링크를 재생성한다. 도 9는 본 발명의 일 실시예에서 히스토리 데이터 관리를 위해 상기와 같은 과정을 진행하는 과정에서 연동한 관리자의 웹 페이지에서 보여지는 학습 모델 히스토리 관리 트리 구조를 도시한 것이다. 도 9에서 빨간색으로 표시된 노드가 배포 중인 학습 모델이며 부모 노드가 된다. 배포 중인 노드에서 분류(classifycation)되면 추가된 학습 데이터의 업로드 시 해당 노드의 자식 노드로 추가 되어진다. 이때, 배포된 학습데이터에서 다시 새로운 학습데이터를 추가한 경우 도 9b와 같이 새로운 노드 브랜 치가 생성된다. 이상에서 본 발명의 실시예에 대하여 도면을 참조하여 설명하였으나, 이는 예시적인 것으로 본 발명이 이에 한"}
{"patent_id": "10-2020-0047344", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "정되는 것이 아니고, 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자라면 이로부터 다양한 변형 및 개량 이 가능하다는 것을 이해하여야 할 것이다."}
{"patent_id": "10-2020-0047344", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일반적인 심볼릭링크 구조의 예시도. 도 2는 본 발명의 실시 예를 위한 데이터 관리 시스템의 블록 구성도. 도 3은 본 발명의 실시 예에서 디렉토리 구조의 예시도. 도 4는 본 발명의 실시 예에서 데이터 관리를 위한 트리구조의 예시도. 도 5는 본 발명의 실시 예에서 데이터 학습 과정의 신호 흐름도. 도 6은 도 5에서 데이터 업데이트 과정의 신호 흐름도. 도 7은 본 발명의 실시 예에서 하위노드의 모델을 상위노드로 변경하는 과정의 예시도. 도 8은 본 발명의 실시 예에서 모델을 형제노드로 변경하는 과정의 예시도. 도 9는 본 발명의 실시 예에서 관리자 웹페이지에 표시된 히스토리 구조의 예시도."}
