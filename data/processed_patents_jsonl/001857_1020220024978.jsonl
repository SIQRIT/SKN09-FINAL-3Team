{"patent_id": "10-2022-0024978", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2022-0133769", "출원번호": "10-2022-0024978", "발명의 명칭": "컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자 지원", "출원인": "인텔 코포레이션", "발명자": "멜렘푸디 나빈"}}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "장치로서,프로세서를 포함하고, 상기 프로세서는,실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩하는 디코더 - 상기 디코딩된 명령어는 프로세서로 하여금 병렬 내적 연산(parallel dot product operation)을 수행하게 하는 8비트 부동 소수점 피연산자(8-bitfloating point operand)에 대해 연산하는 행렬 명령어임 - 와,상기 디코딩된 명령어를 스케줄링하고, 상기 디코딩된 명령어에 의해 표시된 8비트 부동 데이터 형식에 따라 상기 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하는 컨트롤러와,시스톨릭 층(systolic layers)을 사용하여 상기 디코딩된 명령어를 실행하기 위한 시스톨릭 내적 회로(systolicdot product circuitry) - 각각의 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를포함하며, 각 세트의 승산기, 시프터 및 가산기는 상기 8비트 부동 소수점 피연산자의 내적(dot procudt)을 생성함 - 를 포함하는,장치."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 시프터는 상기 승산기의 출력을 정규화하는 것인, 장치."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 승산기는 4비트 승산기, 8비트 승산기, 16비트 승산기 또는 32비트 승산기 중 적어도 하나를 포함하는, 장치."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서, 상기 가산기는 상기 시프터에 의해 정규화되는, 상기 승산기에서 생성된 곱(products)을 더하는 가산기 트리를포함하고, 상기 가산기는 오사오입 반올림(round to nearest even)을 사용하여 가산기 트리의 결과를 반올림하는, 장치."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서, 상기 결과는 상기 디코딩된 명령어에 의해 표시되는 목적지 정밀도(destination precision)로 반올림되는, 장치."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "공개특허 10-2022-0133769-3-제1항에 있어서, 상기 시스톨릭 내적 회로는 누산기 소스 피연산자의 지연 누산(late accumulation)을 수행하고, 상기 지연 누산은 상기 8비트 부동 소수점 피연산자의 내적 생성에 후속하여 상기 누산기 소스 피연산자를 누산하는, 장치."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 1 항에 있어서, 상기 시스톨릭 내적 회로는 누산기 소스 피연산자의 누산을 수행하고, 상기 누산은 상기 시스톨릭 내적 회로의제1 스테이지 또는 상기 시스톨릭 내적 회로의 중간 스테이지 중 하나에서 상기 누산기 소스 피연산자를 누산하는, 장치."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "방법으로서,프로세서에 의해, 실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩하는 단계 - 상기 디코딩된 명령어는상기 프로세서로 하여금 병렬 내적 연산을 수행하게 하기 위해 8비트 부동 소수점 피연산자에 대해 연산하는 행렬 명령어임 - 와,상기 프로세서에 의해, 상기 디코딩된 명령어를 스케줄링하고, 상기 디코딩된 명령어에 의해 표시된 8비트 부동데이터 형식에 따라 상기 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하는 단계와,상기 프로세서의 시스톨릭 내적 회로에 의해, 시스톨릭 층을 사용하여 상기 디코딩된 명령어를 실행하는 단계 -각각의 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트의승산기, 시프터 및 가산기는 상기 8비트 부동 소수점 피연산자의 내적을 생성함 - 를 포함하는,방법."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서, 상기 시프터는 상기 승산기의 출력을 정규화하기 위한 것이며, 상기 가산기는 상기 시프터에 의해 정규화되는,상기 승산기에서 생성된 곱을 더하기 위한 가산기 트리를 포함하고, 상기 가산기는 오사오입 반올림을 사용하여상기 가산기 트리의 결과를 반올림하는,방법."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 결과는 상기 디코딩된 명령어에 의해 표시되는 목적지 정밀도로 반올림되는, 방법."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제8항에 있어서, 상기 승산기는 4비트 승산기, 8비트 승산기, 16비트 승산기, 또는 32비트 승산기 중 적어도 하나를 포함하는, 방법."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제8항에 있어서, 공개특허 10-2022-0133769-4-상기 시스톨릭 내적 회로에 의해, 누산기 소스 피연산자의 지연 누산을 수행하는 단계를 더 포함하고, 상기 지연 누산은 상기 8비트 부동 소수점 피연산자의 내적 생성에 후속하여 상기 누산기 소스 피연산자를 누산하는 것인,방법."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제8항에 있어서, 상기 시스톨릭 내적 회로에 의해, 누산기 소스 피연산자의 누산을 수행하는 단계를 더 포함하고, 상기 누산은 상기 누산기 소스 피연산자를 상기 시스톨릭 내적 회로의 제1 스테이지 또는 상기 시스톨릭 내적회로의 중간 단계 중 하나에서 누산하는 것인,방법."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "명령어가 저장된 비 일시적 컴퓨터 판독가능 매체로서,상기 명령어는, 하나 이상의 프로세서에 의해 실행될 때 상기 프로세서로 하여금,상기 하나 이상의 프로세서에 의해, 실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩 - 상기 디코딩된명령어는 상기 하나 이상의 프로세서로 하여금 병렬 내적 연산을 수행하게 하기 위해 8비트 부동 소수점 피연산자에 대해 연산하는 행렬 명령어임 - 하고,상기 하나 이상의 프로세서에 의해, 상기 디코딩된 명령어를 스케줄링하고, 상기 디코딩된 명령어에 의해 표시된 8비트 부동 데이터 형식에 따라 상기 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하며,상기 하나 이상의 프로세서의 시스톨릭 내적 회로에 의해, 시스톨릭 층을 사용하여 상기 디코딩된 명령어를 실행 - 각각의 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트의승산기, 시프터 및 가산기는 상기 8비트 부동 소수점 피연산자의 내적을 생성함 - 하게 하는,비 일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서, 상기 시프터는 상기 승산기의 출력을 정규화하고, 상기 가산기는 상기 시프터에 의해 정규화되는, 상기 승산기에서 생성된 곱을 더하는 가산기 트리를 포함하며, 상기 가산기는 오사오입 반올림을 사용하여 상기 가산기 트리의 결과를 반올림하는 것인, 비 일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서, 상기 결과는 상기 디코딩된 명령어에 의해 표시되는 목적지 정밀도로 반올림되는, 비 일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제14항에 있어서, 상기 명령어는 상기 하나 이상의 프로세서로 하여금, 상기 시스톨릭 내적 회로에 의해, 누산기 소스 피연산자의지연 누산을 수행하게 하고, 상기 지연 누산은 상기 8비트 부동 소수점 피연산자의 내적 생성에 후속하여 상기 누산기 소스 피연산자를 누산하는 것인, 공개특허 10-2022-0133769-5-비 일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제14항에 있어서, 상기 명령어는 상기 하나 이상의 프로세서로 하여금, 상기 시스톨릭 내적 회로에 의해, 누산기 소스 피연산자의누산을 수행하게 하고, 상기 누산은 상기 시스톨릭 내적 회로의 제1 스테이지 또는 상기 시스톨릭 내적 회로의 중간 스테이지 중 하나에서 상기 누산기 소스 피연산자를 누산하는 것인,비 일시적 컴퓨터 판독가능 매체."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하는 시스템으로서,메모리와,복수의 GPU의 하나 이상의 프로세서 - 상기 하나 이상의 프로세서는 상기 메모리에 통신 가능하게 연결됨 - 를포함하고,상기 하나 이상의 프로세서는,실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩하는 디코더 - 상기 디코딩된 명령어는 상기 GPU으로 하여금 병렬 내적 연산을 수행하게 하는 8비트 부동 소수점 피연산자에 대해 연산하는 행렬 명령어임 - 와,상기 디코딩된 명령어를 스케줄링하고, 상기 디코딩된 명령어에 의해 표시된 8비트 부동 데이터 형식에 따라 상기 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하는 컨트롤러와,시스톨릭 층을 사용하여 상기 디코딩된 명령어를 실행하기 위한 시스톨릭 내적 회로 - 각각의 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트의 승산기, 시프터 및 가산기는 상기 8비트 부동 소수점 피연산자의 내적을 생성함 - 를 포함하는,시스템."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제19항에 있어서, 상기 시프터는 상기 승산기의 출력을 정규화하는 것인, 시스템."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_21", "content": "제19항에 있어서, 상기 승산기는 4비트 승산기, 8비트 승산기, 16비트 승산기 또는 32비트 승산기 중 적어도 하나를 포함하는, 시스템."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_22", "content": "제20항에 있어서, 상기 가산기는 상기 시프터에 의해 정규화되는, 상기 승산기에서 생성된 곱(products)을 더하는 가산기 트리를포함하고, 상기 가산기는 오사오입 반올림을 사용하여 상기 가산기 트리의 결과를 반올림하는, 시스템."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_23", "content": "제20항에 있어서, 공개특허 10-2022-0133769-6-상기 결과는 상기 디코딩된 명령어에 의해 표시되는 목적지 정밀도로 반올림되는, 시스템."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_24", "content": "컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하는 장치로서,실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩하는 수단 - 상기 디코딩된 명령어는 프로세서로 하여금병렬 내적 연산을 수행하게 하는 8비트 부동 소수점 피연산자(8-bit floating point operand)에 대해 연산하는행렬 명령어임 - 과,상기 디코딩된 명령어를 스케줄링하고, 상기 디코딩된 명령어에 의해 표시된 8비트 부동 데이터 형식에 따라 상기 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하는 수단과,시스톨릭 층을 사용하여 상기 디코딩된 명령어를 실행하기 위한 수단 - 각각의 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트의 승산기, 시프터 및 가산기는 상기 8비트 부동소수점 피연산자의 내적을 생성함 - 을 포함하는,장치."}
{"patent_id": "10-2022-0024978", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_25", "content": "제24항에 있어서,제11항 내지 제15항 중 어느 한 항의 방법을 수행하는 수단을 더 포함하는, 장치."}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하는 장치가 개시된다. 이 장 치는 프로세서를 포함하고, 프로세서는 실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩하기 위한 디코더 - 디코딩된 명령어는 프로세서로 하여금 병렬 내적 연산을 수행하게 하기 위해 8비트 부동 소수점 피연산자에 대 해 연산하는 행렬 명령어임 - 와, 디코딩된 명령어를 스케줄링하고 디코딩된 명령어에 의해 표시된 8비트 부동 데이터 형식에 따라 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하는 컨트롤러와, 시스톨릭 층을 사 용하여 디코딩된 명령어를 실행하기 위한 시스톨릭 내적 회로를 포함하고, 각 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트는 승산기, 시프터 및 가산기는 8비트 부동 소수점 피 연산자 내적을 생성한다."}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "이 문서는 일반적으로 데이터 처리에 관한 것으로, 특히 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자 를 지원하는 것에 관한 것이다."}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "현재의 병렬 그래픽 데이터 처리는 그래픽 데이터(graphics data)에 대해 특정 동작, 예를 들어, 선형 보간 (linear interpolation), 테셀레이션(tessellation), 래스터화(rasterization), 텍스처 맵핑(texture mapping), 깊이 테스팅(depth testing) 등을 수행하기 위해 개발된 시스템 및 방법을 포함한다. 전통적으로, 그 래픽 프로세서(graphics processor)는 그래픽 데이터를 처리하기 위해 고정 함수(fixed function) 연산 유닛을 사용하였으나, 보다 최근에는, 그래픽 프로세서의 일부가 프로그래밍 가능하도록(programmable) 되어, 그러한 프로세서가 정점(vertex) 및 프래그먼트(fragment) 데이터를 처리하기 위한 보다 폭넓고 다양한 연산을 지원하 게 할 수 있다. 성능을 더 증가시키기 위해, 그래픽 프로세서는 전형적으로, 그래픽 파이프라인(graphics pipeline)의 서로 다 른 부분에 걸쳐 가능한 많은 그래픽 데이터를 병렬로 처리하려고 시도하는 파이프라이닝(pipelining)과 같은 처 리 기술을 구현한다. 그래픽 파이프라인에서 병렬 처리의 양을 최대화하기 위해 단일 명령어 다중 데이터 (single instruction, multiple data: SIMD) 또는 단일 명령어 다중 스레드(single instruction, multiple thread: SIMT) 아키텍처를 가진 병렬 그래픽 프로세서가 설계된다. SIMT 아키텍처에서, 다수의 처리 요소를 갖 는 컴퓨터는 다수의 데이터 포인트에 대해 동시에 동일한 동작을 수행하려고 시도한다. SIMT 아키텍처에서, 병 렬 스레드의 그룹이 처리 효율을 증가시키기 위해 가능한 자주 함께 동시에 프로그램 명령어를 실행하려고 시도 한다. 그래픽 프로세서는 흔히 인공 지능(AI) 및 머신 러닝(ML) 분야의 애플리케이션에 활용된다. 이러한 분야에서의 발전으로, ML 모델은 신경망 트레이닝을 위해 저 정밀도 산술(arithmetic)을 활용할 수 있다. 통상적인 트레이 닝 플랫폼은 고성능 시스톨릭 어레이(systolic array) 구현에서 부동 소수점 16(floating point 16, FP16) 및 브레인 부동 소수점 16(brain floating point 16, bfloat16 또는 BF16) 데이터 형식을 지원한다. 8비트 데이터형식과 같은 더 낮은 정밀도의 데이터 형식을 사용하여 심층 신경망 트레이닝을 지원하기 위해 최근에 발전이 이루어졌다. 그러나, 기존 시스템은 8비트 부동 소수점 형식 피연산자를 사용한 연산을 수행하기 위한 하드웨어 지원을 제공하지 않는다."}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "그래픽 처리 유닛(Graphics Processing Unit: GPU)은 호스트/프로세서 코어에 통신가능하게 커플링되어 예를 들 면, 그래픽 동작, 머신 러닝 동작, 패턴 분석 동작 및/또는 다양한 범용 GPU(General Purpose GPU: GPGPU) 기 능을 가속화한다(accelerate). GPU는 버스 또는 다른 인터커넥트(interconnect)(가령, PCIe 또는 NVLink와 같 은 고속 인터커넥트)를 통해서 호스트 프로세서/코어에 통신가능하게 커플링될 수 있다. 대안적으로, GPU는 동 일한 패키지 또는 칩 상에 코어로서 집적되고, 내부 프로세서 버스/인터커넥트(즉, 패키지 또는 칩의 내부)를통해서 코어에 통신가능하게 커플링될 수 있다. GPU가 연결되는 방식과 무관하게, 프로세서 코어는 작업 서술자 (work descriptor)에 포함된 커맨드/명령어의 시퀀스의 형태로 GPU에 작업을 할당할 수 있다. GPU는 이후 이들 커맨드/명령어를 효율적으로 처리하기 위해 전용(dedicated) 회로부/로직을 사용한다. 다음의 설명에서, 더욱 철저한 이해를 제공하기 위해 여러 구체적인 세부사항이 개진된다. 그러나, 본 문서에 기술된 실시예는 이들 구체적인 세부사항 중 하나 이상이 없이도 실시될 수 있음은 당업자에게 명백할 것이다. 다른 사례에서, 잘 알려진 특징은 본 실시예의 세부사항을 모호하게 하는 것을 피하기 위해 기술되지 않았다. 시스템 개관 도 1은 일 실시예에 따른 처리 시스템의 블록도이다. 시스템은 단일 프로세서 데스크탑 시스템, 멀티 프로세서 워크스테이션 시스템, 또는 다수의 프로세서 또는 프로세서 코어를 갖는 서버 시스템에서 사용될 수 있다. 일 실시예에서, 시스템은 근거리 또는 광역 네트워크에 유선 또는 무선으로 연결되는 사 물 인터넷(IoT) 장치 내와 같은 모바일, 핸드헬드 또는 임베디드 장치에 사용하기 위한 시스템 온 칩(SoC) 집적 회로 내에 통합된 처리 플랫폼이다. 일 실시예에서, 시스템은 또한, 서버 기반 게임 플랫폼; 게임 및 미디어 콘솔을 포함하는 게임 콘솔; 모바 일 게임 콘솔, 휴대용 게임 콘솔 또는 온라인 게임 콘솔을 포함할 수 있다. 일부 실시예에서, 시스템은 모 바일 폰, 스마트 폰, 태블릿 컴퓨팅 장치 또는 낮은 내부 저장 용량을 갖는 랩탑과 같은 모바일 인터넷 연결 장 치의 일부이다. 처리 시스템은 또한 스마트 워치 웨어러블 디바이스와 같은 웨어러블 디바이스; 시각, 청 각 또는 촉각 출력을 제공하여 현실 세계의 시각, 청각 또는 촉각 경험을 보완하거나 텍스트, 오디오, 그래픽, 비디오, 홀로그램 이미지 또는 비디오 또는 촉각 피드백을 제공하는, 증강 현실(AR) 또는 가상 현실(VR) 기능으 로 강화된 스마트 안경 또는 의류; 기타 증강 현실(AR) 장치; 또는 기타 가상 현실(VR) 장치를 포함할 수 있다. 일부 실시예에서, 처리 시스템은 텔레비전 또는 셋톱 박스 디바이스를 포함하거나 그 일부이다. 일 실시예 에서, 시스템은 버스, 트랙터 트레일러, 자동차, 모터 또는 전력 사이클, 비행기 또는 글라이더(또는 이들 의 임의의 조합)와 같은 자가 운전 차량을 포함하거나, 이들과 커플링하거나, 그 내에 통합될 수 있다. 자율 주 행 차량은 차량 주변에서 감지된 환경을 처리하기 위해 시스템을 사용할 수 있다. 일부 실시예에서, 하나 이상의 프로세서 각각은 실행될 때, 시스템 또는 사용자 소프트웨어에 대한 동작을 수행하는 명령어를 처리하기 위한 하나 이상의 프로세서 코어를 포함한다. 본 명세서의 실시예에서, 프로 세서는 커맨드/명령어를 효율적으로 처리하기 위한 전용 하드웨어 회로를 지칭할 수 있고, 프로세서 회로라고 지칭될 수 있다. 일부 실시예에서, 하나 이상의 프로세서 코어 중 적어도 하나는 특정 명령어 세트를 처리하도록 구성된다. 일부 실시예에서, 명령어 세트는 복합 명령어 세트 컴퓨팅(Complex Instruction Set Computing, CISC), 축소 명령어 세트 컴퓨팅(Reduced Instruction Set Computing, RISC), 또는 VLIW(Very Long Instruction Word)를 통한 컴퓨팅을 용이하게 할 수 있다. 하나 이상의 프로세서 코어는 다른 명령어 세트 를 처리할 수 있으며, 이는 다른 명령어 세트의 에뮬레이션을 용이하게 하기 위한 명령어를 포함할 수 있 다. 프로세서 코어는 또한 디지털 신호 프로세서(DSP)와 같은 다른 처리 디바이스를 포함할 수 있다. 일부 실시예에서, 프로세서는 캐시 메모리를 포함한다. 아키텍처에 따라, 프로세서는 단일 내부 캐시 또는 다중 레벨의 내부 캐시를 가질 수 있다. 일부 실시예에서, 캐시 메모리는 프로세서의 다양한 컴 포넌트 사이에서 공유된다. 일부 실시예에서, 프로세서는 또한 외부 캐시(예를 들어, 레벨-3(L3) 캐시 또 는 마지막 레벨 캐시(Last Level Cache, LLC))를 사용하며, 이는 알려진 캐시 일관성 기술을 사용하여 프로세서 코어 사이에서 공유될 수 있다. 레지스터 파일은 프로세서에 추가로 포함될 수 있고, 상이한 유 형의 데이터(예를 들어, 정수 레지스터, 부동 소수점 레지스터, 상태 레지스터, 및 명령어 포인터 레지스터)를 저장하기 위한 상이한 유형의 레지스터를 포함할 수 있다. 일부 레지스터는 범용(general-purpose) 레지스터일 수 있는 반면, 다른 레지스터는 프로세서의 설계에 특정될 수 있다. 일부 실시예에서, 하나 이상의 프로세서(들)는 하나 이상의 인터페이스 버스(들)와 커플링되어 프로 세서와 시스템의 다른 컴포넌트 사이에서 어드레스, 데이터 또는 제어 신호와 같은 통신 신호를 전송 한다. 일 실시예에서, 인터페이스 버스는 DMI(Direct Media Interface) 버스의 버전과 같은 프로세서 버스 일 수 있다. 그러나 프로세서 버스는 DMI 버스에 한정되지 않으며 하나 이상의 주변 컴포넌트 상호연결 버스(예: PCI(Peripheral Component Interconnect bus), PCI 익스프레스), 메모리 버스 또는 기타 유형의 인터 페이스 버스를 포함할 수 있다. 일 실시예에서, 프로세서(들)는 통합 메모리 컨트롤러 및 플랫폼 컨 트롤러 허브를 포함한다. 메모리 컨트롤러는 메모리 디바이스와 시스템의 다른 컴포넌트 간의 통신을 용이하게 하는 반면, 플랫폼 컨트롤러 허브(platform controller hub, PCH)는 로컬 I/O 버스를 통해 I/O 장치에 대한 연결을 제공한다. 메모리 디바이스는 동적 랜덤 액세스 메모리(DRAM) 디바이스, 정적 랜덤 액세스 메모리(SRAM) 디바이스, 플래시 메모리 디바이스, 상변화 메모리 디바이스, 또는 프로세스 메모리 역할을 하기에 적절한 성능을 갖는 일 부 다른 메모리 디바이스일 수 있다. 일 실시예에서, 메모리 디바이스는 하나 이상의 프로세서가 애 플리케이션 또는 프로세스를 실행할 때 사용하기 위한 데이터 및 명령어를 저장하기 위해 시스템 을 위한 시스템 메모리로서 동작할 수 있다. 메모리 컨트롤러는 또한 그래픽 및 미디어 동작을 수행 하기 위해 프로세서의 하나 이상의 그래픽 프로세서와 통신할 수 있는, 선택적인 외부 그래픽 프로세 서와 커플링한다. 일부 실시예에서, 그래픽, 미디어, 및/또는 계산 동작은 그래픽, 미디어 또는 계산 동작 의 특수 세트를 수행하도록 구성될 수 있는 보조 프로세서인 가속기에 의해 지원될 수 있다. 예를 들어, 일 실시예에서, 가속기는 머신 러닝 또는 계산 동작을 최적화하기 위해 사용되는 행렬 곱셈 가속기이다. 일 실시예에서 가속기는 그래픽 프로세서와 협력하여 광선 추적 동작을 수행하는 데 사용될 수 있는 광선 추적 가속기이다. 일 실시예에서 외부 가속기는 가속기 대신에 또는 가속기와 협력하여 사 용될 수 있다. 일부 실시예에서, 디스플레이 디바이스는 프로세서(들)에 연결될 수 있다. 디스플레이 디바이스(11 1)는 모바일 전자 디바이스 또는 랩톱 디바이스에서와 같은 내부 디스플레이 디바이스 또는 디스플레이 인터페 이스(예: DisplayPort 등)를 통해 부착된 외부 디스플레이 디바이스 중 하나 이상일 수 있다. 일 실시예에서, 디스플레이 디바이스는 가상 현실(VR) 애플리케이션 또는 증강 현실(AR) 애플리케이션에서 사용하기 위한 입체 디스플레이 디바이스와 같은 헤드 장착 디스플레이(HMD)일 수 있다. 일부 실시예에서, 플랫폼 컨트롤러 허브는 주변기기를 고속 I/O 버스를 통해 메모리 디바이스 및 프 로세서에 연결할 수 있게 한다. I/O 주변기기는 오디오 컨트롤러, 네트워크 컨트롤러, 펌웨어 인터페이스, 무선 송수신기, 터치 센서, 데이터 저장 디바이스(예: 비휘발성 메모리, 휘발 성 메모리, 하드 디스크 드라이브, 플래시 메모리, NAND, 3D NAND, 3D XPoint 등)를 포함하나 이에 한정되지 않 는다. 데이터 저장 디바이스는 저장 인터페이스(예를 들어, SATA)를 통해 또는 주변 컴포넌트 상호연결 버 스(예를 들어, PCI, PCI express)와 같은 주변 버스를 통해 연결될 수 있다. 터치 센서는 터치 스크린 센 서, 압력 센서, 또는 지문 센서를 포함할 수 있다. 무선 송수신기는 Wi-Fi 송수신기, 블루투스 송수신기, 또는 3G, 4G, 5G, 또는 LTE(Long-Term Evolution) 송수신기와 같은 모바일 네트워크 송수신기일 수 있다. 펌웨 어 인터페이스는 시스템 펌웨어와의 통신을 가능하게 하며, 예를 들어, UEFI(unified extensible firmware interface)일 수 있다. 네트워크 컨트롤러는 유선 네트워크에 대한 네트워크 연결을 가능하게 할 수 있다. 일부 실시예에서, 고성능 네트워크 컨트롤러(도시되지 않음)는 인터페이스 버스와 연결된다. 일 실시예에서, 오디오 컨트롤러는 다중 채널 고음질 오디오 컨트롤러이다. 일 실시예에서, 시스템은 레 거시(예를 들어, 개인 시스템 2(PS/2)) 디바이스를 시스템에 커플링하기 위한 선택적인 레거시 I/O 컨트롤러 를 포함한다. 플랫폼 컨트롤러 허브는 또한 키보드 및 마우스 조합, 카메라, 또는 다른 USB 입력 디바이스와 같은 연결 입력 디바이스를 하나 이상의 USB(Universal Serial Bus) 컨트롤러에 연결 할 수 있다. 도시된 시스템은 예시이고 제한적이지 않으며, 상이하게 구성된 다른 유형의 데이터 처리 시스템이 또한 사용될 수 있다는 점이 이해될 것이다. 예를 들어, 메모리 컨트롤러 및 플랫폼 컨트롤러 허브의 인스 턴스는 외부 그래픽 프로세서와 같은 별개의 외부 그래픽 프로세서에 통합될 수 있다. 일 실시예에서, 플 랫폼 컨트롤러 허브 및/또는 메모리 컨트롤러는 하나 이상의 프로세서(들) 외부에 있을 수 있다. 예를 들어, 시스템은 외부 메모리 컨트롤러 및 플랫폼 컨트롤러 허브를 포함할 수 있으며, 이는 프로세서(들)와 통신 연결된 시스템 칩셋 내의 메모리 컨트롤러 허브 및 주변 컨트롤러 허브 로 구성될 수 있다. 예를 들어, CPU, 메모리 및 열 성능을 증가시키기 위해 설계된 다른 컴포넌트와 같은 컴포넌트가 배치되는 회로 기판(\"슬레드(sled)\")이 사용될 수 있다. 일부 예에서, 프로세서와 같은 처리 컴포넌트는 슬레드의 상단에 위치 하는 반면 DIMM과 같은 인접(near) 메모리는 슬레드의 하단에 위치한다. 그 결과 이러한 설계에서 제공되는 향 상된 공기 흐름으로 인해, 컴포넌트는 일반적인 시스템보다 더 높은 주파수와 전력 레벨에서 작동할 수 있으므 로 성능이 향상된다. 또한 슬레드는 랙(rack)의 전원 및 데이터 통신 케이블과 맹목적으로 연결되도록 구성되어, 신속하게 제거, 업그레이드, 재설치 및/또는 교체할 수 있는 기능을 향상시킨다. 마찬가지로 프로세 서, 가속기, 메모리 및 데이터 저장 드라이브와 같이 슬레드에 있는 개별 컴포넌트는 서로의 간격이 늘어나므로 쉽게 업그레이드되도록 구성된다. 예시적인 실시예에서, 컴포넌트는 그들의 진위를 증명하기 위한 하드웨어 증명 특징을 추가로 포함한다. 데이터 센터는 이더넷 및 Omni-Path를 포함하는 다수의 다른 네트워크 아키텍처를 지원하는 단일 네트워크 아키 텍처(\"패브릭\")를 활용할 수 있다. 슬레드는 광섬유(fiber) 통해 스위치에 연결될 수 있으며, 이는 일반적인 트 위스트 페어 케이블(예: 카테고리 5, 카테고리 5e, 카테고리 6 등)보다 더 높은 대역폭과 더 낮은 레이턴시를 제공한다. 고대역폭, 저지연 상호연결 및 네트워크 아키텍처로 인해, 데이터 센터는 사용 중에, 메모리, 가속기 (예: GPU, 그래픽 가속기, FPGA, ASIC, 신경망 및/또는 인공 지능 가속기, 등) 및 물리적으로 분해된 데이터 스 토리지 드라이브를 사용할 수 있고, 이들을 요청에 기초하여 컴퓨팅 리소스(예: 프로세서)에 제공함으로써, 컴 퓨팅 리소스가 풀링된 리소스에 로컬인 것처럼 액세스할 수 있게 한다. 전력 공급 장치(power supply) 또는 전원은 시스템 또는 본 명세서에 설명된 임의의 컴포넌트 또는 시스템 에 전압 및/또는 전류를 제공할 수 있다. 일 예에서, 전력 공급 장치는 AC-DC(교류-직류) 어댑터를 포함하여 벽 면 콘센트(wall outlet)에 연결한다. 이러한 AC 전력은 재생 에너지(예: 태양광 전력) 전원일 수 있다. 일 예에 서, 전원은 외부 AC 대 DC 변환기와 같은 DC 전원을 포함한다. 일 예에서, 전원 또는 전력 공급 장치는 충전 필 드에 대한 근접성을 통해 충전하기 위한 무선 충전 하드웨어를 포함한다. 일례에서, 전원은 내부 배터리, 교류 전원, 모션 기반 전원, 태양열 전원 또는 연료 전지 소스를 포함할 수 있다. 도 2a 내지 도 2d는 본 명세서에 설명된 실시예에 의해 제공되는 컴퓨팅 시스템 및 그래픽 프로세서를 도시한다. 본 명세서의 임의의 다른 도면의 요소와 동일한 참조 번호(또는 명칭)를 갖는 도 2a 내지 도 2d의 요 소는 본 명세서의 다른 곳에서 설명된 것과 동일한 방식으로 작동하거나 기능할 수 있지만, 이에 제한되지는 않 는다. 도 2a는 하나 이상의 프로세서 코어(202A-202N), 통합 메모리 컨트롤러, 및 통합 그래픽 프로세서를 갖는 프로세서의 실시예의 블록도이다. 프로세서는 점선 박스로 표현되는 추가 코어(202N)를 포함하 며, 그 만큼의 추가 코어를 포함할 수 있다. 프로세서 코어(202A-202N) 각각은 하나 이상의 내부 캐시 유닛 (204A-204N)을 포함한다. 일부 실시예에서, 각각의 프로세서 코어는 또한 하나 이상의 공유 캐시 유닛에 대한 액세스를 갖는다. 내부 캐시 유닛(204A-204N) 및 공유 캐시 유닛은 프로세서 내의 캐시 메모리 계층(hierarchy)을 나타낸다. 캐시 메모리 계층은 적어도 하나의 명령어 레벨 및 각각의 프로세서 코어 내의 데 이터 캐시 및 하나 이상의 공유 중간 레벨 캐시(가령, 레벨 2(L2), 레벨 3(L3), 레벨 4(L4) 또는 기타 캐시 레 벨)를 포함할 수 있으며, 외부 메모리 전의 최고 레벨 캐시는 LLC로 분류된다. 일부 실시예에서, 캐시 일관성 로직은 다양한 캐시 유닛(206, 204A-204N) 사이의 일관성을 유지한다. 일부 실시예에서, 프로세서는 또한 하나 이상의 버스 컨트롤러 유닛의 세트 및 시스템 에이전트 코어 를 포함할 수 있다. 하나 이상의 버스 컨트롤러 유닛은 하나 이상의 PCI 또는 PCI 익스프레스 버스와 같은 주변 버스의 세트를 관리한다. 시스템 에이전트 코어는 다양한 프로세서 컴포넌트에 대한 관리 기능 을 제공한다. 일부 실시예에서, 시스템 에이전트 코어는 다양한 외부 메모리 디바이스(미도시)에 대한 액 세스를 관리하기 위한 하나 이상의 통합 메모리 컨트롤러를 포함한다. 일부 실시예에서, 프로세서 코어(202A-202N) 중 하나 이상은 동시 멀티스레딩에 대한 지원을 포함한다. 이러한 실시예에서, 시스템 에이전트 코어는 멀티스레드 처리 동안 코어(202A-202N)를 조정하고 작동시키기 위한 컴포넌트를 포함한다. 시스템 에이전트 코어는 프로세서 코어(202A-202N) 및 그래픽 프로세서의 전력 상태를 조절하기 위한 로직 및 컴포넌트를 포함하는 전력 제어 유닛(PCU)을 추가로 포함할 수 있다. 일부 실시예에서, 프로세서는 그래픽 처리 동작을 실행하기 위해 그래픽 프로세서를 추가로 포함한다. 일부 실시예에서, 그래픽 프로세서는 공유 캐시 유닛의 세트, 및 하나 이상의 통합 메모리 컨트롤러를 포함하는 시스템 에이전트 코어와 커플링한다. 일부 실시예에서, 시스템 에이전트 코어 는 또한 그래픽 프로세서 출력을 하나 이상의 커플링된 디스플레이로 구동하기 위한 디스플레이 컨트롤러 를 포함한다. 일부 실시예에서, 디스플레이 컨트롤러는 또한 적어도 하나의 인터커넥트를 통해 그래 픽 프로세서와 커플링된 별도의 모듈일 수 있거나, 그래픽 프로세서 내에 통합될 수 있다. 일부 실시예에서, 링 기반 인터커넥트 유닛은 프로세서의 내부 컴포넌트를 커플링하는 데 사용된다. 그러나, 점대점 인터커넥트, 스위치드 인터커넥트, 또는 당업계에 잘 알려진 기술을 포함하는 다른 기술과 같은 대안적인 인터커넥트 유닛이 사용될 수 있다. 일부 실시예에서, 그래픽 프로세서는 I/O 링크를 통해 링 인터커넥트(ring interconnect, 212)와 커플링된다. 예시적인 I/O 링크는 다양한 프로세서 컴포넌트와 eDRAM 모듈과 같은 고성능 내장 메모리 모듈 사이 의 통신을 용이하게 하는 온 패키지 I/O 인터커넥트를 포함하여, I/O 인터커넥트의 다수의 변형들 중 적어도 하 나를 나타낸다. 일부 실시예에서, 프로세서 코어(202A-202N) 및 그래픽 프로세서 각각은 임베디드 메모리 모듈을 공유된 최종 레벨 캐시(Last Level Cache)로서 사용할 수 있다. 일부 실시예에서, 프로세서 코어(202A-202N)는 동일한 명령어 세트 아키텍처를 실행하는 동종 코어이다. 다른 실시예에서, 프로세서 코어(202A-202N)는 명령어 세트 아키텍처(ISA)의 관점에서 이종이며, 프로세서 코어 (202A-202N) 중 하나 이상이 제1 명령어 세트를 실행하는 반면, 다른 코어 중 적어도 하나는 제1 명령어 세트의 서브세트 또는 다른 명령어 세트를 실행한다. 일 실시예에서, 프로세서 코어(202A-202N)는 마이크로아키텍처의 관점에서 이종이며, 상대적으로 더 높은 전력 소비를 갖는 하나 이상의 코어가 더 낮은 전력 소비를 갖는 하나 이상의 전력 코어와 커플링된다. 일 실시예에서, 프로세서 코어(202A-202N)는 계산 능력 측면에서 이종이다. 추 가적으로, 프로세서는 하나 이상의 칩 상에서 또는 다른 컴포넌트에 추가하여 예시된 컴포넌트를 갖는 SoC 집적 회로로서 구현될 수 있다. 도 2b는 본 명세서에 설명된 일부 실시예에 따른 그래픽 프로세서 코어의 하드웨어 로직의 블록도이다. 본 명세서의 임의의 다른 도면의 요소와 동일한 참조 번호(또는 명칭)를 갖는 도 2b의 요소는 본 명세서의 다른 곳 에서 설명된 것과 동일한 방식으로 동작하거나 기능할 수 있지만, 이에 제한되지는 않는다. 때때로 코어 슬라이 스로 지칭되는 그래픽 프로세서 코어는 모듈형 그래픽 프로세서 내의 하나 또는 다수의 그래픽 코어일 수 있다. 그래픽 프로세서 코어는 하나의 그래픽 코어 슬라이스의 예이고, 본 명세서에 설명된 그래픽 프로세 서는 목표 전력 및 성능 엔벨로프에 기초하여 다수의 그래픽 코어 슬라이스를 포함할 수 있다. 각각의 그래픽 프로세서 코어는 범용 및 고정 함수 로직의 모듈식 블록을 포함하는, 서브 슬라이스라고도 하는 다수의 서 브 코어(221A-221F)와 커플링된 고정 함수 블록을 포함할 수 있다. 일부 실시예에서, 고정 함수 블록은 예를 들어 저성능 및/또는 저전력 그래픽 프로세서 구현에서 그래픽 프로세서 코어의 모든 서브 코어에 의해 공유될 수 있는 지오메트리/고정 함수 파이프라인을 포함한 다. 다양한 실시예에서, 지오메트리/고정 함수 파이프라인은 3D 고정 함수 파이프라인(예를 들어, 후술되 는 도 3 및 도 4에서와 같은 3D 파이프라인), 비디오 프론트-엔드 유닛, 스레드 생성기(thread spawner) 및 스레드 디스패처, 및 통합 반환 버퍼(예를 들어, 후술되는 도 4의 통합 반환 버퍼)를 관리하는 통합 반 환 버퍼 관리자를 포함한다. 일 실시예에서, 고정 함수 블록은 또한 그래픽 SoC 인터페이스, 그래픽 마이크로컨트롤러, 및 미디어 파이프라인을 포함한다. 그래픽 SoC 인터페이스는 칩 집적 회로 상의 시스템 내의 그래픽 프 로세서 코어 및 다른 프로세서 코어 사이의 인터페이스를 제공한다. 그래픽 마이크로컨트롤러는 스레 드 디스패치, 스케줄링 및 선점(pre-emption)을 포함하는 그래픽 프로세서 코어의 다양한 기능을 관리하도 록 구성 가능한 프로그램 가능한 서브프로세서이다. 미디어 파이프라인(예를 들어, 도 3 및 도 4의 미디어 파이프라인)은 이미지 및 비디오 데이터를 포함하는, 멀티미디어 데이터의 디코딩, 인코딩, 전처리 및/또 는 후처리를 용이하게 하는 로직을 포함한다. 미디어 파이프라인은 서브 코어(221-221F) 내에서 로직을 계 산하거나 샘플링하기 위한 요청을 통해 미디어 연산을 구현한다. 일 실시예에서, SoC 인터페이스는, 그래픽 프로세서 코어가 범용 애플리케이션 프로세서 코어(예를 들어, CPU) 및/또는 공유된 최종 레벨 캐시 메모리, 시스템 RAM 및/또는 임베디드 온칩 또는 온패키지 DRAM와 같은 메모리 계층 요소를 포함하는 SoC 내의 다른 컴포넌트와 통신할 수 있게 한다. SoC 인터페이스는 또 한 카메라 이미징 파이프라인과 같은 SoC에서 고정 함수 장치와의 통신을 가능하게 할 수 있고, 그래픽 프로세 서 코어와 SoC 내의 CPU 사이에서 공유될 수 있는 글로벌 메모리 원자(atomic)의 사용을 가능하게 하고/하 거나 구현할 수 있게 한다. SoC 인터페이스는 또한 그래픽 프로세서 코어에 대한 전력 관리 제어를 구현할 수 있고, 그래픽 코어의 클록 도메인과 SoC 내의 다른 클록 도메인 간의 인터페이스를 가능하게 할 수 있다. 일 실시예에서, SoC 인터페이스는 그래픽 프로세서 내의 하나 이상의 그래픽 코어 각각에 커맨드 및 명령어를 제공하도록 구성된 커맨드 스트리머 및 글로벌 스레드 디스패처로부터 커맨드 버퍼의 수신을 가능 하게 한다. 커맨드 및 명령어는 미디어 동작이 수행되어야 하는 경우 미디어 파이프라인으로, 또는 그래픽 처리 동작이 수행되어야 하는 경우 지오메트리 및 고정 함수 파이프라인(예를 들어, 지오메트리 및 고정 함수 파이프라인, 지오메트리 및 고정 함수 파이프라인)으로 디스패치될 수 있다. 그래픽 마이크로컨트롤러는 그래픽 프로세서 코어에 대한 다양한 스케줄링 및 관리 태스크(task)를 수행하도록 구성될 수 있다. 일 실시예에서, 그래픽 마이크로컨트롤러는 그래픽을 수행하고/하거나 서브 코어(221A-221F) 내의 실행 유닛(EU) 어레이(222A-222F, 224A-224F) 내의 다양한 그래픽 병렬 엔진에 대해 워크로드 스케줄링을 계산할 수 있다. 이 스케줄링 모델에서, 그래픽 프로세서 코어를 포함하는 SoC의 CPU 코어에서 실행되는 호스트 소프트웨어는 적절한 그래픽 엔진에 대한 스케줄링 동작을 호출하는, 다중 그래픽 프 로세서 도어벨 중 하나를 워크로드에 제출할 수 있다. 스케줄링 동작에는 다음에 실행할 워크로드 결정, 커맨드 스트리머에 워크로드 제출, 엔진에서 실행 중인 기존 워크로드 선점, 워크로드 진행 모니터링, 워크로드 완료 시 호스트 소프트웨어로의 통지가 포함된다. 일 실시예에서, 그래픽 마이크로컨트롤러는 또한 그래픽 프로 세서 코어에 대한 저전력 또는 유휴 상태를 용이하게 하여, 시스템의 운영 체제 및/또는 그래픽 드라이버 소프트웨어로부터 독립적으로, 저전력 상태 전환에 대해 그래픽 프로세서 코어 내의 레지스터를 저장 및 복원하는 능력을 그래픽 프로세서 코어에 제공할 수 있다. 그래픽 프로세서 코어는 예시된 서브 코어(221A-221F)보다 더 많거나 적은 서브 코어(N개까지의 모듈식 서 브 코어)를 가질 수 있다. N개의 서브 코어 세트 각각에 대해, 그래픽 프로세서 코어는 또한 다양한 그래 픽을 가속화하고 처리 작업을 계산하기 위한 공유 함수 로직, 공유 및/또는 캐시 메모리, 지오메트리 /고정 함수 파이프라인, 뿐만 아니라 추가의 고정 함수 로직을 포함할 수 있다. 공유 함수 로직(23 5)은 그래픽 프로세서 코어 내의 각각의 N개의 서브 코어에 의해 공유될 수 있는, 도 4의 공유 함수 로직 과 연관된 로직 유닛(예를 들어, 샘플러, 수학, 및/또는 스레드간 통신 로직)을 포함할 수 있다. 공유 및/ 또는 캐시 메모리는 그래픽 프로세서 코어 내의 N개의 서브 코어(221A-221F)의 세트에 대한 최종 레 벨 캐시일 수 있고, 또한 다수의 서브 코어에 의해 액세스 가능한 공유 메모리의 역할을 할 수 있다. 지오메트 리/고정 함수 파이프라인은 고정 함수 블록 내의 지오메트리/고정 함수 파이프라인 대신에 포함 될 수 있고 동일하거나 유사한 로직 유닛을 포함할 수 있다. 일 실시예에서, 그래픽 프로세서 코어는 그래픽 프로세서 코어에 의해 사용하기 위한 다양한 고정 함 수 가속 로직을 포함할 수 있는 추가 고정 함수 로직을 포함한다. 일 실시예에서, 추가 고정 함수 로직 은 위치 전용 셰이딩에서만(in position only shading) 사용하기 위한 추가 지오메트리 파이프라인을 포함 한다. 위치 전용 셰이딩에는 2개의 지오메트리 파이프라인이 존재하는데, 이느 지오메트리/고정 함수 파이프라 인(238, 231) 내의 전체 지오메트리 파이프라인과 추가 고정 함수 로직 내에 포함될 수 있는 추가 지오메 트리 파이프라인인 컬 파이프라인(cull pipeline)이다. 일 실시예에서 컬 파이프라인은 전체 지오메트리 파이프 라인의 축소된 버전이다. 전체 파이프라인과 컬 파이프라인은 동일한 애플리케이션의 서로 다른 인스턴스를 실 행할 수 있으며, 각 인스턴스에는 별도의 컨텍스트가 있다. 위치 전용 셰이딩은 버려진 삼각형의 긴 컬 런(long cull run)을 숨길 수 있으므로, 일부 경우에 셰이딩을 더 일찍 완료할 수 있다. 예를 들어 그리고 일 실시예에 서 추가 고정 함수 로직 내의 컬 파이프라인 로직은 메인 애플리케이션과 병렬로 위치 셰이더를 실행할 수 있고, 일반적으로 컬 파이프라인이 프레임 버퍼에 대한 픽셀의 래스터화 및 렌더링을 수행하지 않고 정점의 위 치 속성만을 페치 및 셰이딩하기 때문에 전체 파이프라인보다 더 빠르게 결과를 생성한다. 컬 파이프라인은 생 성된 결과를 사용하여 그러한 삼각형이 컬링되었는지 여부에 관계없이 모든 삼각형에 대한 가시성 정보를 계산 할 수 있다. 전체 파이프라인(이 경우 리플레이 파이프라인(replay pipeline)이라고 함)은 가시성 정보를 사용 하여 컬링된 삼각형을 건너뛰어 최종적으로 래스터화 단계로 전달되는 가시적인 삼각형만 셰이딩할 수 있다. 일 실시예에서, 추가 고정 함수 로직은 또한 머신 러닝 트레이닝 또는 추론을 위한 최적화를 포함하는 구 현을 위한 고정 함수 행렬 곱셈 로직과 같은 머신 러닝 가속 로직을 포함할 수 있다. 각각의 그래픽 서브코어(221A-221F) 내에는 그래픽 파이프라인, 미디어 파이프라인, 또는 셰이더 프로그램에 의 한 요청에 응답하여 그래픽, 미디어 및 연산 작업을 수행하는 데 사용될 수 있는 실행 리소스 세트가 포함된다. 그래픽 서브코어(221A-221F)는 다수의 EU 어레이(222A-222F, 224A-224F), 스레드 디스패치 및 스레드간 통신 (TD/IC) 로직(223A-223F), 3D(예를 들어, 텍스처) 샘플러(225A-225F), 미디어 샘플러(206A-206F), 셰이더 프로 세서(227A-227F), 및 공유 로컬 메모리(SLM)(228A-228F)를 포함한다. EU 어레이(222A-222F, 224A-224F)는 각각, 다수의 실행 유닛을 포함하고, 이들은 그래픽, 미디어 또는 계산 셰이더 프로그램을 포함하여, 그래픽, 미디어 또는 계산 동작을 지원하는 부동 소수점 및 정수/고정 소수점 로직 연산을 수행할 수 있는 범용 그래픽 처리 유닛이다. TD/IC 로직(223A-223F)은 서브 코어 내의 실행 유닛에 대한 로컬 스레드 디스패치 및 스레드 제 어 작업을 수행하고 서브 코어의 실행 유닛에서 실행되는 스레드 간의 통신을 용이하게 한다. 3D 샘플러(225A- 225F)는 텍스처 또는 기타 3D 그래픽 관련 데이터를 메모리로 판독할 수 있다. 3D 샘플러는 구성된 샘플 상태 및 주어진 텍스처와 연관된 텍스처 형식에 기초하여 텍스처 데이터를 다르게 판독할 수 있다. 미디어 샘플러 (206A-206F)는 미디어 데이터와 연관된 유형 및 형식에 기초하여 유사한 판독 동작을 수행할 수 있다. 일 실시 예에서, 각각의 그래픽 서브 코어(221A-221F)는 대안적으로 통합 3D 및 미디어 샘플러를 포함할 수 있다. 각 서 브 코어(221A-221F) 내의 실행 유닛에서 실행되는 스레드는 각 서브 코어 내의 공유 로컬 메모리(228A-228F)를사용하여 스레드 그룹 내에서 실행되는 스레드가 온칩 메모리의 공통 풀을 사용하여 실행되게 할 수 있다. 도 2는 멀티 코어 그룹(240A-240N)으로 배열된 그래픽 처리 리소스의 전용 세트를 포함하는 그래픽 처리 유닛 (Graphics Processing Unit: GPU)을 보여준다. 단일의 멀티 코어 그룹(240A)의 세부사항 만이 제공되나, 다른 멀티 코어 그룹(240B-240N)은 그래픽 처리 리소스의 동일하거나 유사한 세트가 구비될 수 있음이 인식될 것이다. 예시된 바와 같이, 멀티 코어 그룹(240A)은 그래픽 코어의 세트, 텐서 코어의 세트 및 광선 추적 코 어의 세트를 포함할 수 있다. 스케줄러(scheduler)/디스패처(dispatcher)는 다양한 코어(243, 244, 245) 상에서의 실행을 위한 그래픽 스레드를 스케줄링하고 디스패치한다. 레지스터 파일의 세트는 그래픽 스레드를 실행하는 경우에 코어(243, 244, 245)에 의해 사용되는 피연산자 값을 저장한다. 이들은, 예를 들어, 정수 값을 저장하기 위한 정수 레지스터, 부동 소수점 값을 저장하기 위한 부동 소수점 레지스터, 패킹된 (packed) 데이터 요소(정수 및/또는 부동 소수점 데이터 요소)를 저장하기 위한 벡터 레지스터 및 텐서/행렬 값 을 저장하기 위한 타일 레지스터를 포함할 수 있다. 하나의 실시예에서, 타일 레지스터는 벡터 레지스터의 조합 된 세트로서 구현된다. 하나 이상의 조합된 레벨 1(Level 1: L1) 캐시 및 공유 메모리 유닛은 각각의 멀티 코어 그룹(240A) 내에 로컬로, 텍스처 데이터, 정점 데이터, 픽셀 데이터, 광선 데이터, 바운딩 볼륨(bounding volume) 데이터 등과 같은 그래픽 데이터를 저장한다. 하나 이상의 텍스처 유닛은 또한 텍스처 맵핑 및 샘플링과 같은 텍스처링 동작을 수행하는 데에 사용될 수 있다. 멀티 코어 그룹(240A-240N)의 전부 또는 서브세트에 의해 공유되는 레벨 2(Level 2: L2) 캐시는 다수의 동시적 그래픽 스레드를 위한 그래픽 데이터 및/또는 명령어를 저장한다. 예시된 바와 같이, L2 캐시는 복수의 멀티 코어 그룹(240A-240N)에 걸쳐 공유될 수 있다. 하나 이상의 메 모리 컨트롤러는 시스템 메모리(가령, DRAM) 및/또는 전용 그래픽 메모리(가령, GDDR6 메모리)일 수 있는 메모리에 GPU를 커플링한다. 입력/출력(Input/Output: I/O) 회로부는 디지털 신호 프로세서(Digital Signal Processor: DSP), 네트워 크 컨트롤러, 또는 사용자 입력 디바이스와 같은 하나 이상의 I/O 디바이스에 GPU를 커플링한다. I/O 디바이스를 GPU 및 메모리에 커플링하는 데에 온칩 인터커넥트(on-chip interconnect)가 사용 될 수 있다. I/O 회로부의 하나 이상의 I/O 메모리 관리 유닛(I/O Memory Management Unit: IOMMU) 는 I/O 디바이스를 직접적으로 시스템 메모리에 커플링한다. 하나의 실시예에서, IOMMU는 시스 템 메모리 내의 물리적 어드레스로 가상 어드레스를 맵핑하기 위해 페이지 테이블의 다수의 세트를 관리한 다. 이 실시예에서, I/O 디바이스, CPU(들) 및 GPU(들)는 동일한 가상 어드레스 공간을 공유할 수 있다. 하나의 구현에서, IOMMU는 가상화(virtualization)를 지원한다. 이 경우에, 그것은 게스트(guest)/그래픽 가상 어드레스를 게스트/그래픽 물리적 어드레스로 맵핑하는 페이지 테이블의 제1 세트를, 그리고 게스트/그래 픽 물리적 어드레스를 (가령, 시스템 메모리 내의) 시스템/호스트 물리적 어드레스로 맵핑하는 페이지 테 이블의 제2 세트를 관리할 수 있다. 페이지 테이블의 제1 및 제2 세트 각각의 기초 어드레스(base address)는 제어 레지스터 내에 저장되고 (가령, 새로운 콘텍스트(context)가 페이지 테이블의 관련 세트에의 액세스를 제 공받도록) 콘텍스트 스위치에서 스왑 아웃될(swapped out) 수 있다. 도 2c에 예시되지 않으나, 코어(243, 244, 245) 및/또는 멀티 코어 그룹(240A-240N) 각각은 게스트 가상 대 게스트 물리적 전환(guest virtual to guest physical translation), 게스트 물리적 대 호스트 물리적 전환(guest physical to host physical translation) 및 게스트 가상 대 호스트 물리적 전환(guest virtual to host physical translation)을 캐싱하는 전환 색인 버퍼(Translation Lookaside Buffer: TLB)를 포함할 수 있다. 하나의 실시예에서, CPU, GPU 및 I/O 디바이스는 단일의 반도체 칩 및/또는 칩 패키지 상에 집 적된다. 예시된 메모리는 동일한 칩 상에 집적될 수 있거나 오프칩 인터페이스(off-chip interface)를 통 해 메모리 컨트롤러에 커플링될 수 있다. 하나의 구현에서, 메모리는 다른 물리적 시스템 레벨 메모 리와 동일한 가상 어드레스 공간을 공유하는 GDDR6 메모리를 포함하는데, 다만 여기서 구현의 기저 원리는 이러 한 구체적인 구현에 한정되지 않는다. 하나의 실시예에서, 텐서 코어는 딥 러닝 동작을 수행하는 데에 사용되는 베이스 계산 동작인 행렬 동작을 수행하도록 구체적으로 설계된 복수의 실행 유닛을 포함한다. 예를 들어, 동시 행렬 곱셈 동작이 신경망 트레이 닝 및 추론을 위해 사용될 수 있다. 텐서 코어는 단일 정밀도 부동 소수점(가령, 32비트), 반 정밀도 (half-precision) 부동 소수점(가령, 16비트), 정수 워드(16비트), 바이트(8비트) 및 반 바이트(half-byte)(4비트)를 포함하는 다양한 피연산자 정밀도를 사용하여 행렬 처리를 수행할 수 있다. 하나의 실시예에서, 신경망 구현은, 잠재적으로 다수 프레임으로부터의 세부사항을 조합하는, 각각의 렌더링된 장면의 특징을 추출 하여, 고품질 최종 이미지를 구축한다. 딥 러닝 구현에서, 텐서 코어 상에서의 실행을 위해 병렬 행렬 곱셈 연산이 스케줄링될 수 있다. 신경망의 트레이닝은, 특히, 상당한 수의 행렬 내적(dot product) 동작을 사용한다. N x N x N 행렬 곱하기의 내적 (inner-product) 공식을 처리하기 위해서, 텐서 코어는 적어도 N개의 내적 처리 요소를 포함할 수 있다. 행렬 곱하기가 시작하기 전에, 하나의 전체 행렬이 타일 레지스터 내에 로드되고 N 사이클에 있어서 각 사이클 마다 제2 행렬의 적어도 하나의 열(column)이 로드된다. 각 사이클마다, 처리되는 N개의 내적(dot product)이 있다. 행렬 요소는 16비트 워드, 8비트 바이트(가령, INT8) 및 4비트 반바이트(가령, INT4)를 포함하여, 특정한 구현 에 따라서 상이한 정밀도로 저장될 수 있다. (가령, 바이트 및 반바이트로의 양자화(quantization)를 용인할 수 있는 추론 작업부하와 같은) 상이한 작업부하를 위해 가장 효율적인 정밀도가 사용됨을 보장하기 위해 텐서 코 어를 위해 상이한 정밀도 모드가 지정될 수 있다. 하나의 실시예에서, 광선 추적 코어는 실시간 광선 추적 및 비실시간 광선 추적 구현 양자 모두를 위한 광 선 추적 동작을 가속화한다. 특히, 광선 추적 코어는 바운딩 볼륨 계층구조(Bounding Volume Hierarchy: BVH)를 사용하여 광선 순회(ray traversal)를 수행하고 BVH 볼륨 내에 둘러싸인(enclosed) 프리미티브 및 광선 간의 교차(intersection)를 식별하기 위한 광선 순회/교차 회로부를 포함한다. 광선 추적 코어는 (가령, Z 버퍼 또는 유사한 배열을 사용하여) 깊이 테스팅 및 컬링(culling)을 수행하기 위한 회로부를 또한 포함할 수 있다. 하나의 구현에서, 광선 추적 코어는 본 문서에 기술된 이미지 잡음제거(denoising) 기법(이의 적어 도 일부분이 텐서 코어 상에서 실행될 수 있음)과 협력하여 순회 및 교차 동작을 수행한다. 예를 들어, 하 나의 실시예에서, 텐서 코어는 광선 추적 코어에 의해 생성된 프레임의 잡음제거를 수행하기 위해 딥 러닝 신경망을 구현한다. 그러나, CPU(들), 그래픽 코어 및/또는 광선 추적 코어는 또한 잡음제 거 및/또는 딥 러닝 알고리즘의 전부 또는 일부분을 구현할 수 있다. 추가로, 위에서 기술된 바와 같이, 잡음제거에 대한 분산형 접근법이 이용될 수 있는데 여기서 GPU는 네트 워크 또는 고속 인터커넥트를 통해서 다른 컴퓨팅 디바이스에 커플링된 컴퓨팅 디바이스 내에 있다. 이 실시예 에서, 상호연결된 컴퓨팅 디바이스는 상이한 타입의 이미지 프레임 및/또는 상이한 그래픽 애플리케이션을 위해 잡음제거를 수행하는 것을 전체 시스템이 학습하는 속도를 개선하기 위해 신경망 러닝/트레이닝 데이터를 공유 한다. 하나의 실시예에서, 광선 추적 코어는 모든 BVH 순회 및 광선-프리미티브 교차를 처리하여, 그래픽 코어 가 광선당 수천 개의 명령어로써 과부하되는 것을 면하게 한다. 하나의 실시예에서, 각각의 광선 추적 코 어는 (가령, 순회 동작을 위해) 바운딩 박스(bounding box) 테스트를 수행하기 위한 제1 세트의 전문화된 회로부 및 (가령, 순회된 광선을 교차하는) 광선 삼각형 교차 테스트를 수행하기 위한 제2 세트의 전문화된 회 로부를 포함한다. 그러므로, 하나의 실시예에서, 멀티 코어 그룹(240A)은 단순히 광선 프로브(ray probe)를 론 칭할(launch) 수 있고, 광선 추적 코어는 독립적으로 광선 순회 및 교차를 수행하고 히트(hit) 데이터(가 령, 히트, 히트 없음, 여러 히트 등)를 스레드 콘텍스트에 반환한다(return). 광선 추적 코어가 순회 및 교차 동작을 수행하는 동안 다른 코어(243, 244)는 다른 그래픽 또는 계산 작업(compute work)을 수행하도록 해 제된다(freed). 하나의 실시예에서, 각각의 광선 추적 코어는 BVH 테스팅 동작을 수행하는 순회 유닛 및 광선-프리미티브 교차 테스트를 수행하는 교차 유닛을 포함한다. 교차 유닛은 그것이 적절한 스레드에 제공하는 \"히트\", \"히트 없음\", 또는 \"여러 히트\" 응답을 생성한다. 순회 및 교차 동작 동안에, 다른 코어(가령, 그래픽 코어 및 텐서 코어)의 실행 리소스는 다른 형태의 그래픽 작업을 수행하도록 해제된다. 아래에서 기술되는 하나의 특정한 실시예에서, 그래픽 코어 및 광선 추적 코어 간에 작업이 분산되는 하이브리드 래스터화/광선 추적 접근법이 사용된다. 하나의 실시예에서, 광선 추적 코어(및/또는 다른 코어(243, 244))는 각각의 객체(object)를 위한 셰이더 및 텍스처의 세트의 배정을 가능하게 하는 광선 생성(ray generation), 최근접 히트(closest hit), 임의 히트 (any hit) 및 미스(miss) 셰이더뿐만 아니라, DispatchRays 커맨드를 포함하는 마이크로소프트(Microsoft)의 DirectX Ray Tracing(DXR)과 같은 광선 추적 명령어 세트에 대한 하드웨어 지원을 포함한다. 광선 추적 코어, 그래픽 코어 및 텐서 코어에 의해 지원될 수 있는 다른 광선 추적 플랫폼은 Vulkan 1.1.85이 다. 그러나, 여기서 구현의 기저 원리는 어떤 특정한 광선 추적 ISA에도 한정되지 않는다는 점에 유의한다. 일반적으로, 다양한 코어(245, 244, 243)는 광선 생성, 최근접 히트, 임의 히트, 광선-프리미티브 교차, 프리미 티브당(per-primitive) 및 계층구조적(hierarchical) 바운딩 박스 구축, 미스, 방문(visit) 및 예외 (exception)를 위한 명령어/기능을 포함하는 광선 추적 명령어 세트를 지원할 수 있다. 더욱 구체적으로, 하나 의 실시예는 다음의 기능을 수행하는 광선 추적 명령어를 포함한다: 광선 생성(Ray Generation) - 광선 생성 명령어는 각각의 픽셀, 샘플, 또는 다른 사용자 정의된 작업 배정에 대 해 실행될 수 있다. 최근접 히트(Closest Hit) - 최근접 히트 명령어는 장면 내의 프리미티브와의 광선의 최근접 교차점의 위치를 파악하기 위해 실행될 수 있다. 임의 히트(Any Hit) - 임의 히트 명령어는 장면 내의 프리미티브 및 광선 간의 여러 교차를 식별하여, 잠재적으 로 새로운 최근접 교차점을 식별한다. 교차(Intersection) - 교차 명령어는 광선-프리미티브 교차 테스트를 수행하고 결과를 출력한다. 프리미티브당 바운딩 박스 구성(Per-premitive Bounding box Construction) - 이 명령어는 (가령, 새로운 BVH 또는 다른 가속화 데이터 구조를 구축하는 경우) 주어진 프리미티브 또는 프리미티브의 그룹 주위에 바운딩 박 스를 구축한다. 미스(Miss) - 장면, 또는 장면의 지정된 영역 내의 모든 지오메트리 구조를 광선이 미스함을 나타낸다. 방문(Vist) - 광선이 순회할 자식 볼륨을 나타낸다. 예외(Exceptions) - (가령, 다양한 에러 조건에 있어서 호출되는) 다양한 타입의 예외 핸들러(exception handler)를 포함한다. 도 2d는 본 명세서에 설명된 실시예에 따른, 그래픽 프로세서 및/또는 계산 가속기로 구성될 수 있는 범용 그래 픽 처리 디바이스(GPGPU)의 블록도이다. GPGPU는 하나 이상의 시스템 및/또는 메모리 버스를 통해 호 스트 프로세서(예를 들어, 하나 이상의 CPU(들)) 및 메모리(271, 272)와 인터커넥트할 수 있다. 일 실시예 에서, 메모리는 하나 이상의 CPU(들)와 공유될 수 있는 시스템 메모리인 반면, 메모리는 GPGPU 전용인 장치 메모리이다. 일 실시예에서, GPGPU 및 장치 메모리는 하나 이상의 CPU (들)에 액세스할 수 있는 메모리 어드레스로 매핑될 수 있다. 메모리(271 및 272)에 대한 액세스는 메모리 컨트롤러를 통해 용이해질 수 있다. 일 실시예에서, 메모리 컨트롤러는 내부 DMA(direct memory access) 컨트롤러를 포함할 수 있거나, 또는 DMA 컨트롤러에 의해 수행될 동작을 수행하기 위한 로직을 포 함할 수 있다. GPGPU는 L2 캐시, L1 캐시, 명령어 캐시, 및 공유 메모리를 포함하는 다수의 캐시 메모리를 포함하며, 이들 중 적어도 일부는 또한 캐시 메모리로서 분할될 수 있다. GPGPU는 또한 다수의 계산 유닛(260A-260N)을 포함한다. 각각의 계산 유닛(260A-260N)은 벡터 레지스터, 스칼라 레지스터, 벡터 로직 유닛, 및 스칼라 로직 유닛의 세트를 포함한다. 계산 유닛(260A-260N)은 또한 로컬 공유 메모리 및 프로그램 카운터를 포함할 수 있다. 계산 유닛(260A-260N)은 상수 캐시와 커플링할 수 있으며, 이는 커널 실행 중에 변경되지 않을 데이터인 상수 데이터 또는 GPGPU에서 실행되는 셰이더 프 로그램을 저장하는 데 사용할 수 있다. 일 실시예에서 상수 캐시는 스칼라 데이터 캐시이고 캐시된 데이터 는 스칼라 레지스터로 직접 페치될 수 있다. 연산 동안, 하나 이상의 CPU(들)는 액세스 가능한 어드레스 공간에 매핑된 GPGPU의 메모리 또는 레지 스터에 커맨드를 기록할 수 있다. 커맨드 프로세서는 레지스터 또는 메모리로부터 커맨드를 읽고 이러한 커맨드가 GPGPU 내에서 처리되는 방법을 결정할 수 있다. 그 다음, 스레드 디스패처는 이러한 커맨드 를 수행하기 위해 계산 유닛(260A-260N)에 스레드를 디스패치하는 데 사용될 수 있다. 각각의 연산 유닛(260A- 260N)은 다른 연산 유닛과 독립적으로 스레드를 실행할 수 있다. 추가적으로, 각각의 연산 유닛(260A-260N)은 조건부 연산을 위해 독립적으로 구성될 수 있고 연산 결과를 메모리에 조건부로 출력할 수 있다. 커맨드 프로세 서는 제출된 커맨드가 완료될 때 하나 이상의 CPU(들)를 인터럽트할 수 있다. 도 3a 내지 도 3c는 여기에 설명된 실시예에 의해 제공되는 추가 그래픽 프로세서 및 계산 가속기 아키텍처의 블록도를 도시한다. 본 명세서의 임의의 다른 도면의 요소와 동일한 참조 번호(또는 명칭)를 갖는 도 3a 내지 도 3c의 요소는 본 명세서의 다른 곳에서 설명된 것과 유사한 방식으로 작동하거나 기능할 수 있지만, 이에 제 한되지는 않는다. 도 3a은 개별 그래픽 처리 유닛일 수 있거나, 복수의 처리 코어 또는 다른 반도체 디바이스(예를 들면 메모리 디바이스 또는 네트워크 인터페이스이되, 이에 한정되지 않음)와 함께 집적된 그래픽 프로세서일 수 있는 그래 픽 프로세서의 블록도이다. 일부 실시예에서, 그래픽 프로세서는 그래픽 프로세서 상의 레지스터로의 메모 리 맵핑된 I/O 인터페이스(memory mapped I/O interface)를 통해, 그리고 프로세서 메모리 내에 배치된 커맨드 로써 통신한다. 일부 실시예에서, 그래픽 프로세서는 메모리를 액세스하는 메모리 인터페이스를 포함 한다. 메모리 인터페이스는 로컬 메모리, 하나 이상의 내부 캐시, 하나 이상의 공유된 외부 캐시, 그리고/ 또는 시스템 메모리로의 인터페이스일 수 있다. 일부 실시예에서, 그래픽 프로세서는 디스플레이 디바이스로의 디스플레이 출력 데이터를 구동하는 디스플레이 컨트롤러를 또한 포함한다. 디스플레이 컨트롤러는 비디오 또는 사용자 인터페이스 요소 의 여러 층의 디스플레이 및 구성을 위해 하나 이상의 오버레이 평면(overlay plane)을 위한 하드웨어를 포함한 다. 디스플레이 디바이스는 내부 또는 외부 디스플레이 디바이스일 수 있다. 하나의 실시예에서 디스플레 이 디바이스는 가상 현실(Virtual Reality: VR) 디스플레이 디바이스 또는 증강 현실(Augmented Reality: AR) 디스플레이 디바이스와 같은 머리 장착형 디스플레이(Head Mounted Display: HMD)이다. 일부 실시예에서, 그래픽 프로세서는, 동화상 전문가 그룹(Moving Picture Experts Group: MPEG) 포맷, 예를 들면 MPEG-2, 고급 비디오 코딩(Advanced Video Coding: AVC) 포맷, 예를 들면 H.265/MPEG-4 AVC, H.265/HEVC, 오픈 미디어 연합(Alliance for Open Media: AOMedia) VP8, VP9, 또 영화 텔레비전 엔지니어 협회(Society of Motion Picture & Television Engineers: SMPTE) 421M/VC-1, 그리고 합동 사진 전문가 그룹(Joint Photographic Experts Group: JPEG) 포맷, 예를 들면 JPEG과, 모션 JPEG(Motion JPEG: MJPEG) 포맷을 포함하나 이에 한정되 지 않는 하나 이상의 미디어 인코딩 포맷으로, 이로부터, 또는 이들 간에 미디어를 인코딩하거나(encode), 디코 딩하거나(decode), 트랜스코딩하는(transcode) 비디오 코덱 엔진(video codec engine)을 포함한다. 일부 실시예에서, 그래픽 프로세서는, 예컨대,비트 경계 블록 전송(bit-boundary block transfer)을 포함 하는 2차원 래스터화기(two-dimensional (2D) rasterizer) 동작을 수행하는 블록 이미지 전송(Block Image Transfer: BLIT) 엔진을 포함한다. 그러나, 하나의 실시예에서, 그래픽 처리 엔진(Graphics Processing Engine: GPE)의 하나 이상의 컴포넌트를 사용하여 2D 그래픽 동작이 수행된다. 일부 실시예에서, GPE(31 0)는 3차원(three-dimensional (3D)) 그래픽 동작 및 미디어 동작을 포함하는 그래픽 동작을 수행하기 위한 계 산 엔진(compute engine)이다. 일부 실시예에서, GPE는 3D 프리미티브 형상(가령, 직사각형, 삼각형 등)에 작용하는 처리 함수를 사용하 여 3차원 이미지 및 장면을 렌더링하는 것과 같은 3D 동작을 수행하기 위한 3D 파이프라인을 포함한다. 3D 파이프라인은 프로그램 가능 및 고정 함수 요소(이는 그 요소 내에서 다양한 태스크를 수행하고/하거나 실 행 스레드를 3D/미디어 서브시스템(3D/Media sub-system)으로 스폰함(spawn))를 포함한다. 3D 파이프라인 은 미디어 동작을 수행하는 데에 사용할 수 있는 한편, GPE의 실시예는 비디오 후처리 및 이미지 향 상과 같은 미디어 동작을 수행하는 데에 특히 사용되는 미디어 파이프라인을 또한 포함한다. 일부 실시예에서, 미디어 파이프라인은 비디오 코덱 엔진을 대신하여, 또는 이를 대행하여 비디오 디코드 가속화(video decode acceleration), 비디오 디인터레이싱(video de-interlacing) 및 비디오 인코드 가 속화(video encode acceleration)와 같은 하나 이상의 전문화된 미디어 동작을 수행하는 고정 함수 또는 프로그 램 가능 로직 유닛을 포함한다. 일부 실시예에서, 미디어 파이프라인은 3D/미디어 서브시스템 상에서 의 실행을 위한 스레드를 스폰하는 스레드 스포닝 유닛(thread spawning unit)을 추가적으로 포함한다. 스폰된 스레드는 3D/미디어 서브시스템에 포함된 하나 이상의 그래픽 실행 유닛 상에서 미디어 동작을 위한 연산 을 수행한다. 일부 실시예에서, 3D/미디어 서브시스템은 3D 파이프라인 및 미디어 파이프라인에 의해 스폰된 스레드를 실행하기 위한 로직을 포함한다. 하나의 실시예에서, 파이프라인은 스레드 실행 요청을 3D/미디어 서 브시스템에 발신하는데, 이는 다양한 요청을 가용 스레드 실행 리소스로 중재하고(arbitrating) 디스패치 하기(dispatching) 위한 스레드 디스패치 로직을 포함한다. 실행 리소스는 3D 및 미디어 스레드를 처리하는 그 래픽 실행 유닛의 어레이를 포함한다. 일부 실시예에서, 3D/미디어 서브시스템은 스레드 명령어 및 데이터 를 위한 하나 이상의 내부 캐시를 포함한다. 일부 실시예에서, 서브시스템은 스레드 간에 데이터를 공유하고 출력 데이터를 저장하는, 레지스터 및 어드레스지정가능 메모리를 포함하는 공유된 메모리를 또한 포함한다. 도 3b는 여기에 설명된 실시예들에 따른, 타일링된 아키텍처를 갖는 그래픽 프로세서를 예시한다. 일 실시 예에서, 그래픽 프로세서는 그래픽 엔진 타일(310A-310D) 내에 도 3a의 그래픽 처리 엔진의 다중 인 스턴스를 갖는 그래픽 처리 엔진 클러스터를 포함한다. 각각의 그래픽 엔진 타일(310A-310D)은 타일 인터 커넥트(323A-323F)의 세트를 통해 인터커넥트될 수 있다. 각각의 그래픽 엔진 타일(310A-310D)은 또한 메모리 인터커넥트(325A-325D)를 통해 메모리 모듈 또는 메모리 디바이스(326A-326D)에 연결될 수 있다. 메모리 디바이 스(326A-326D)는 임의의 그래픽 메모리 기술을 사용할 수 있다. 예를 들어, 메모리 디바이스(326A-326D)는 GDDR(graphics double data rate) 메모리일 수 있다. 일 실시예에서, 메모리 디바이스(326A-326D)는 각각의 그 래픽 엔진 타일(310A-310D)과 함께 온-다이(on-die)일 수 있는 고대역폭 메모리(HBM) 모듈이다. 일 실시예에서, 메모리 디바이스(326A-326D)는 각각의 그래픽 엔진 타일(310A-310D)의 상부에 적층될 수 있는 적층 메모리 디바 이스이다. 일 실시예에서, 각각의 그래픽 엔진 타일(310A-310D) 및 연관 메모리(326A-326D)는 도 11b 및 도 11d 에 더 상세히 설명된 바와 같이 베이스 다이 또는 베이스 기판에 본딩되는 개별 칩렛에 상주한다. 그래픽 프로세서는 메모리 디바이스(326A-326D)가 연관 그래픽 엔진 타일(310A-310D)과 커플링되는 NUMA(non-uniform memory access) 시스템으로 구성될 수 있다. 주어진 메모리 디바이스는 직접 연결된 타일 이 외의 그래픽 엔진 타일에 의해 액세스될 수 있다. 그러나, 메모리 디바이스(326A-326D)에 대한 액세스 지연은 로컬 타일에 액세스할 때 가장 낮을 수 있다. 일 실시예에서, 타일 인터커넥트(323A-323F)를 사용하여, 하나 이 상의 캐시가 동일한 메모리 위치를 저장할 때 일관된 메모리 이미지를 유지하기 위해 그래픽 엔진 타일(310A- 310D) 내의 캐시 컨트롤러 간의 통신을 가능하게 하는 캐시 일관성 NUMA(ccNUMA) 시스템이 인에이블된다. 그래픽 처리 엔진 클러스터는 온칩 또는 온패키지 패브릭 인터커넥트와 연결될 수 있다. 패브릭 인터 커넥트는 그래픽 엔진 타일(310A-310D)과, 비디오 코덱 및 하나 이상의 복사 엔진과 같은 컴포 넌트 사이의 통신을 가능하게 할 수 있다. 복사 엔진은 메모리 디바이스(326A-326D)와 그래픽 프로세서 외부에 있는 메모리(예를 들어, 시스템 메모리) 사이에, 이들 외부로, 또는 내부로 데이터를 이동시키는 데 사용될 수 있다. 패브릭 인터커넥트는 또한 그래픽 엔진 타일(310A-310D)을 인터커넥트하는데 사용될 수 있다. 그래픽 프로세서는 외부 디스플레이 디바이스와의 연결을 가능하게 하는 디스플레이 컨트롤 러를 선택적으로 포함할 수 있다. 그래픽 프로세서는 또한 그래픽 또는 계산 가속기로 구성될 수 있다. 가 속기 구성에서, 디스플레이 컨트롤러 및 디스플레이 디바이스가 생략될 수 있다. 그래픽 프로세서는 호스트 인터페이스(함수 로직)를 통해 호스트 시스템에 연결될 수 있다. 호스트 인터페 이스는 그래픽 프로세서, 시스템 메모리, 및/또는 다른 시스템 컴포넌트 사이의 통신을 가능하게 할 수 있다. 호스트 인터페이스는 예를 들어, PCI 익스프레스 버스 또는 다른 유형의 호스트 시스템 인터페이 스일 수 있다. 도 3c는 여기에 설명된 실시예에 따른 계산 가속기를 예시한다. 계산 가속기는 도 3b의 그래픽 프로 세서와의 아키텍처 유사성을 포함할 수 있고, 연산 가속을 위해 최적화된다. 계산 엔진 클러스터는 병렬 또는 벡터 기반 범용 계산 작업에 최적화된 실행 로직을 포함하는 계산 엔진 타일(340A-340D)의 세트를 포 함할 수 있다. 일부 실시예에서, 계산 엔진 타일(340A-340D)은 고정 함수 그래픽 처리 로직을 포함하지 않지만, 일 실시예에서 계산 엔진 타일(340A-340D) 중 하나 이상이 미디어 가속을 수행하기 위한 로직을 포함할 수 있다. 계산 엔진 타일(340A-340D)은 메모리 인터커넥트(325A-325D)를 통해 메모리(326A-326D)에 연결될 수 있다. 메모리(326A-326D) 및 메모리 인터커넥트(325A-325D)는 그래픽 프로세서에서와 유사한 기술일 수 있 고, 또는 상이할 수 있다. 그래픽 계산 엔진 타일(340A-340D)은 또한 타일 인터커넥트(323A-323F) 세트를 통해 상호연결될 수 있으며, 패브릭 인터커넥트와 연결되거나/되고 이에 의해 상호연결될 수 있다. 일 실시예에 서, 계산 가속기는 장치 전체 캐시로 구성될 수 있는 대형 L3 캐시를 포함한다. 계산 가속기는 또한 도 3b의 그래픽 프로세서와 유사한 방식으로 호스트 인터페이스를 통해 호스트 프로세서 및 메 모리에 연결될 수 있다. 그래픽 처리 엔진 도 4은 일부 실시예에 따른 그래픽 프로세서의 그래픽 처리 엔진의 블록도이다. 하나의 실시예에서, 그래 픽 처리 엔진(Graphics Processing Engine: GPE)은 도 3a에 도시된 GPE의 버전이고, 또한 도 3b의 그래픽 엔진 타일(310A-310D)을 나타낼 수 있다. 본 문서에서 임의의 다른 도면의 요소와 동일한 참조 번호(또 는 명칭)를 갖는 도 4의 요소는 본 문서에서 다른 데에 기술된 것과 유사한 임의의 방식으로 동작하거나 기능할 수 있으나, 그러한 것에 한정되지 않는다. 예를 들어, 도 3a의 3D 파이프라인 및 미디어 파이프라인이 예시된다. 미디어 파이프라인은 GPE의 일부 실시예에서 선택적이며 GPE 내에 명시적으로 포 함되지 않을 수 있다. 예를 들어 그리고 적어도 하나의 실시예에서, 별개의 미디어 및/또는 이미지 프로세서가 GPE에 커플링된다. 일부 실시예에서, GPE는 커맨드 스트림아(command streamer)와 커플링되거나 이를 포함하는데, 이는 3D 파이프라인 및/또는 미디어 파이프라인에 커맨드 스트림(command stream)을 제공한다. 일부 실시 예에서, 커맨드 스트리머는 메모리와 커플링되는데, 이는 시스템 메모리, 또는 내부 캐시 메모리와 공유 캐시 메모리 중 하나 이상일 수 있다. 일부 실시예에서, 커맨드 스트리머는 메모리로부터 커맨드를 수신하 고 커맨드를 3D 파이프라인 및/또는 미디어 파이프라인에 발신한다. 커맨드는 3D 파이프라인 및 미디어 파이프라인을 위한 커맨드를 저장하는 링 버퍼(ring buffer)로부터 페치된 지시사항(directive)이 다. 하나의 실시예에서, 링 버퍼는 여러 커맨드의 배치(batch)를 저장하는 배치 커맨드 버퍼를 추가적으로 포함 할 수 있다. 3D 파이프라인을 위한 커맨드는, 3D 파이프라인을 위한 정점 및 지오메트리 데이터 및/ 또는 미디어 파이프라인을 위한 이미지 데이터 및 메모리 객체와 같은, 그러나 이에 한정되지 않는, 메모 리 내에 저장된 데이터에 대한 참조를 또한 포함할 수 있다. 3D 파이프라인 및 미디어 파이프라인은 각 파이프라인 내의 로직을 통해 동작을 수행함으로써 또는 하나 이상의 실행 스레드를 그래픽 코어 어레이 에 디스패치함으로써 커맨드 및 데이터를 처리한다. 하나의 실시예에서 그래픽 코어 어레이는 그래픽 코어(가령, 그래픽 코어(들)(415A), 그래픽 코어(들)(415B))의 하나 이상의 블록을 포함하는데, 각각의 블록은 하나 이상의 그래픽 코어를 포함한다. 각각의 그래픽 코어는, 고정 함수 텍스처 처리 및/또는 머신 러닝 및 인 공 지능 가속 로직뿐만 아니라, 그래픽 및 계산 동작을 수행할 범용 및 그래픽 특정 실행 로직을 포함하는 그래 픽 실행 리소스의 세트를 포함한다. 다양한 실시예에서 3D 파이프라인은, 명령어를 처리하고 실행 스레드를 그래픽 코어 어레이에 디스패 치함으로써, 정점 셰이더, 지오메트리 셰이더, 픽셀 셰이더, 프래그먼트 셰이더, 계산 셰이더, 또는 다른 셰이 더 프로그램과 같은 하나 이상의 셰이더 프로그램을 처리하는 고정 함수 및 프로그램 가능 로직을 포함할 수 있 다. 그래픽 코어 어레이는 이들 셰이더 프로그램을 처리하는 데에서의 사용을 위한 실행 리소스의 통일된 블록을 제공한다. 그래픽 코어 어레이의 그래픽 코어(들)(415A-414B) 내의 범용 실행 로직(가령, 실행 유 닛)은 다양한 3D API 셰이더 언어를 위한 지원을 포함하며 다수의 셰이더와 연관된 다수의 동시 실행 스레드를 실행할 수 있다. 일부 실시예에서, 그래픽 코어 어레이는 비디오 및/또는 이미지 처리와 같은 미디어 기능을 수행하는 실행 로직을 또한 포함한다. 하나의 실시예에서, 실행 유닛은 그래픽 처리 동작 외에도, 병렬 범용 계산 동작을 수행 하도록 프로그램 가능한 범용 로직을 추가적으로 포함한다. 범용 로직은 도 1의 프로세서 코어(들) 또는 도 2a에서와 같은 코어(202A-202N) 내의 범용 로직과 병렬로 또는 이와 결부하여 처리 동작을 수행할 수 있다. 그래픽 코어 어레이 상에서 실행되는 스레드에 의해 생성되는 출력 데이터는 통일된 반환 버퍼(Unified Return Buffer: URB) 내의 메모리로 데이터를 출력할 수 있다. URB는 다수의 스레드를 위한 데이터를 저장할 수 있다. 일부 실시예에서 URB는 그래픽 코어 어레이 상에서 실행되는 상이한 스레드 간에 데 이터를 발신하는 데에 사용될 수 있다. 일부 실시예에서 URB는 추가적으로 공유 함수 로직(shared function logic) 내의 고정 함수 로직 및 그래픽 코어 어레이 상의 스레드 간의 동기화를 위해 사용될 수 있다. 일부 실시예에서, 그래픽 코어 어레이는 스케일가능(scalable)한바, 그 어레이는 가변적인 수의 그래픽 코어를 포함하되, 각각은 GPE의 목표 전력 및 성능 레벨에 기반하여 가변적인 개수의 실행 유닛을 갖는다. 하나의 실시예에서 실행 리소스는 동적으로 스케일가능한바, 실행 리소스는 필요에 따라 인에이블되거나 (enabled) 디스에이블될(disabled) 수 있다. 그래픽 코어 어레이는 그래픽 코어 어레이 내의 그래픽 코어 간에 공유되는 여러 리소스를 포함하는 공유 함수 로직과 커플링된다. 공유 함수 로직 내의 공유 함수는 전문화된 보충 기능을 그래픽 코어 어레 이에 제공하는 하드웨어 로직 유닛이다. 다양한 실시예에서, 공유 함수 로직은 샘플러 (sampler), 수학(math) 및 스레드간 통신(Inter-Thread Communication: ITC) 로직을 포함하나 이에 한정되지 않는다. 추가적으로, 일부 실시예는 공유 함수 로직 내의 하나 이상의 캐시(들)를 구 현한다. 공유 함수는 적어도, 주어진 전문화된 기능에 대한 수요가 그래픽 코어 어레이 내에의 포함에 불충분한 경 우에 구현된다. 대신에 그런 전문화된 기능의 단일 인스턴스화(instantiation)가 공유 함수 로직 내의 독립형 개체(stand-alone entity)로서 구현되고 그래픽 코어 어레이 내의 실행 리소스 간에 공유된다. 그래 픽 코어 어레이 간에서 공유되고 그래픽 코어 어레이 내에 포함된 함수의 정확한 세트는 실시예별로 달라진다. 일부 실시예에서, 그래픽 코어 어레이에 의해 광범위하게 사용되는, 공유 함수 로직 내의 특정 공유 함수는 그래픽 코어 어레이 내의 공유 함수 로직 내에 포함될 수 있다. 다양한 실시예에서, 그래픽 코어 어레이 내의 공유 함수 로직은 공유 함수 로직 내의 일부 또는 모든 로직을 포함할 수 있다. 하나의 실시예에서, 공유 함수 로직 내의 모든 로직 요소는 그래픽 코어 어레이 의 공유 함수 로직 내에 복제될(duplicated) 수 있다. 하나의 실시예에서 공유 함수 로직은 배 제되어 그래픽 코어 어레이 내의 공유 함수 로직의 우세로 된다. 실행 유닛 도 5a 내지 도 5b는 본 문서에 기술된 실시예에 따라 그래픽 프로세서 코어 내에서 이용되는 처리 요소의 어레 이를 포함하는 스레드 실행 로직을 예시한다. 본 문서에서 임의의 다른 도면의 요소와 동일한 참조 번호 (또는 명칭)를 갖는 도 5a 내지 도 5b의 요소는 본 문서에서 다른 데에 기술된 것과 유사한 임의의 방식으로 동 작하거나 기능할 수 있으나, 그러한 것에 한정되지 않는다. 도 5a는 도 2b의 각각의 서브코어(221A-221F)로써 예시된 하드웨어 로직을 나타낼 수 있는 스레드 실행 로직의 개관을 보여준다. 도 5a는 범용 그래픽 프로 세서 내의 실행 유닛을 나타내나, 도 5b는 계산 가속기 내에서 사용될 수 있는 실행 유닛을 나타낸다. 도 5a에 예시된 바와 같이, 일부 실시예에서 스레드 실행 로직은 셰이더 프로세서, 스레드 디스패처 , 명령어 캐시, 복수의 실행 유닛(508A-508N)을 포함하는 스케일가능 실행 유닛 어레이, 샘플러 , 데이터 캐시 및 데이터 포트를 포함한다. 하나의 실시예에서 스케일가능 실행 유닛 어레이는 작업부하의 연산 요구사항에 기반하여 하나 이상의 실행 유닛(가령, 실행 유닛(508A, 508B, 508C, 인에이블D, 내지 508N-1 및 508N) 중 임의의 것)을 인에이블하거나 디스에이블함으로써 동적으로 스케일링할 수 있다. 하나 의 실시예에서, 포함된 컴포넌트는 컴포넌트 각각에 연계되는 상호연결 패브릭을 통해 상호연결된다. 일부 실시 예에서, 스레드 실행 로직은 명령어 캐시, 데이터 포트, 샘플러 및 실행 유닛(508A-508N) 중 하나 이상을 통한, 시스템 메모리 또는 캐시 메모리와 같은 메모리로의 하나 이상의 연결을 포함한다. 일부 실시예에서, 각각의 실행 유닛(가령 508A)은 각각의 스레드에 대해 병렬로 다수의 데이터 요소를 처리하면서 다 수의 동시 하드웨어 스레드를 실행하는 것이 가능한 독립형 프로그램 가능 범용 연산 유닛이다. 다양한 실시예 에서, 실행 유닛(508A-508N)의 어레이는 임의 개수 개별 실행 유닛을 포함하도록 스케일가능하다. 일부 실시예에서, 실행 유닛(508A-508N)은 셰이더 프로그램을 실행하는 데에 주로 사용된다. 셰이더 프로세서 는 다양한 셰이더 프로그램을 처리하고 스레드 디스패처를 통해 셰이더 프로그램과 연관된 실행 스레 드를 디스패치한다. 하나의 실시예에서 스레드 디스패처는 그래픽 및 미디어 파이프라인으로부터의 스레드 개시 요청을 중재하고 요청된 스레드를 실행 유닛(508A-508N) 내의 하나 이상의 실행 유닛 상에서 인스턴스화하는 로 직을 포함한다. 예를 들어, 지오메트리 파이프라인이 정점, 테셀레이션, 또는 지오메트리 셰이더를 처리를 위해 스레드 실행 로직에 디스패치할 수 있다. 일부 실시예에서, 스레드 디스패처는 실행 중인 셰이더 프로그램 으로부터의 런타임(runtime) 스레드 스포닝 요청을 또한 처리할 수 있다. 일부 실시예에서, 실행 유닛(508A-508N)은 많은 표준 3D 그래픽 셰이더 명령어에 대한 네이티브 지원(native support)를 포함하는 명령어 세트를 지원하는바, 그래픽 라이브러리(가령, Direct 3D 및 OpenGL)로부터의 셰이 더 프로그램이 최소의 전환(translation)으로써 실행된다. 실행 유닛은 정점 및 지오메트리 처리(가령, 정점 프 로그램, 지오메트리 프로그램, 정점 셰이더), 픽셀 처리(가령, 픽셀 셰이더, 프래그먼트 셰이더) 및 범용 처리 (가령, 계산 및 미디어 셰이더)를 지원한다. 실행 유닛(508A-508N) 각각은 다중 발행(multi-issue) 단일 명령어 다중 데이터(Single Instruction Multiple Data: SIMD) 실행이 가능하고 멀티스레드형 동작은 더 높은 지연시 간의 메모리 액세스(higher latency memory access)에 직면해서도 효율적인 실행 환경을 가능하게 한다. 각각의 실행 유닛 내의 각각의 하드웨어 스레드는 전용 고대역폭 레지스터 파일 및 연관된 독립적인 스레드 상태를 갖 는다. 실행은 정수, 단일 정밀도 및 배 정밀도 부동 소수점 동작, SIMD 브랜치 능력, 로직적 동작, 초월 (transcendental) 동작, 그리고 다른 갖가지 동작이 가능한 파이프라인에 대해 클록(clock)당 다중 발행이다. 공유 함수 중 하나 또는 메모리로부터의 데이터를 기다리는 동안, 실행 유닛(508A-508N) 내의 종속성 로직 (dependency logic)은 대기 중인 스레드로 하여금 요청된 데이터가 반환될 때까지 슬립하게(sleep) 한다. 대기 중인 스레드가 슬립하고 있는 동안, 하드웨어 리소스는 다른 스레드를 처리하는 데에 전념할 수 있다. 예를 들 어, 정점 셰이더 동작과 연관된 지연(delay) 동안에, 실행 유닛이 픽셀 셰이더, 프래그먼트 셰이더, 또는 상이 한 정점 셰이더를 포함하는 다른 타입의 셰이더 프로그램을 위한 동작을 수행할 수 있다. SIMD의 사용에 대한 대안으로서 또는 SIMD의 사용에 더하여 단일 명령어 다중 스레드(Single Instruction Multiple Thread: SIMT)의 사용에 의한 실행을 사용하기 위해 다양한 실시예가 적용될 수 있다. SIMD 코어 또는 동작에 대한 참조가 또 한 SIMT에 적용되거나 SIMT와 조합된 SIMD에 될 수 있다. 실행 유닛(508A-508N) 내의 각각의 실행 유닛은 데이터 요소의 어레이에 대해 동작한다. 데이터 요소의 수는 \" 실행 크기\"(execution size), 또는 명령어를 위한 채널의 수이다. 실행 채널은 명령어 내에서의 흐름 제어(flow control)와, 마스킹(masking)과, 데이터 요소 액세스(data element access)를 위한 실행의 로직적 단위이다. 채널의 수는 특정한 그래픽 프로세서에 대해 물리적인 산술 로직 유닛(Arithmetic Logic Unit: ALU) 또는 부동 소수점 유닛(Floating Point Unit: FPU)의 수와는 독립적일 수 있다. 일부 실시예에서, 실행 유닛(508A- 508N)은 정수 및 부동 소수점 데이터 타입을 지원한다. 실행 유닛 명령어 세트는 SIMD 명령어를 포함한다. 다양한 데이터 요소는 패킹된 데이터(packed data) 타입으로 서 레지스터 내에 저장될 수 있고 실행 유닛은 다양한 요소를 요소의 데이터 크기에 기반하여 처리할 것이다. 예를 들어, 256비트 폭 벡터에 대해 동작하는 경우에, 벡터의 256비트는 레지스터 내에 저장되고, 실행 유닛은 4개의 별개의 64비트 패킹된 데이터 요소(쿼드 워드(Quad-Word: QW) 크기 데이터 요소), 8개의 별개의 32비트 패킹된 데이터 요소(더블 워드(Double Word: DW) 크기 데이터 요소), 16개의 별개의 16비트 패킹된 데이터 요소 (워드(Word: W) 크기 데이터 요소) 또는 32개의 별개의 8비트 데이터 요소(바이트(Byte: B) 크기 데이터 요소) 로서의 벡터에 대해 동작한다. 그러나, 상이한 벡터 폭 및 레지스터 크기가 가능하다. 하나의 실시예에서 하나 이상의 실행 유닛이 융합형 실행 유닛(fused execution unit)(509A-509N)(융합형 EU에 공통적인 스레드 제어 로직(507A-507N)을 가짐)으로 조합될 수 있다. 다수의 EU가 EU 그룹으로 융합될 수 있다. 융합된 EU 그룹 내의 각각의 EU는 개별 SIMD 하드웨어 스레드를 실행하도록 구성될 수 있다. 융합된 EU 그룹 내 의 EU의 개수는 실시예에 따라 달라질 수 있다. 추가적으로, 다양한 SIMD 폭이 EU당 수행될 수 있는데, SIMD8, SIMD16 및 SIMD32를 포함하나 이에 한정되지 않는다. 각각의 융합형 그래픽 실행 유닛(509A-509N)은 적어도 두 개의 실행 유닛을 포함한다. 예를 들어, 융합형 실행 유닛(509A)은 제1 EU(508A), 제2 EU(508B) 및 스레드 제어 로직(507A)(이는 제1 EU(508A) 및 제2 EU(508B)에 공통적임)을 포함한다. 스레드 제어 로직(507A)은 융합형 그 래픽 실행 유닛(509A) 상에서 실행되는 스레드를 제어하는바, 융합형 실행 유닛(509A-509N) 내의 각각의 EU로 하여금 공통 명령어 포인터 레지스터를 사용하여 실행될 수 있도록 한다. 실행 유닛을 위한 스레드 명령어를 캐싱하기 위해 하나 이상의 내부 명령어 캐시(가령, 506)가 스레드 실행 로 직에 포함된다. 일부 실시예에서, 스레드 실행 동안에 스레드 데이터를 캐싱하기 위해 하나 이상의 데이터 캐시(가령, 512)가 포함된다. 실행 로직에서 실행되고 있는 스레드는 또한 명시적으로 관리되는 데이터를 공유 로컬 메모리에 저장할 수 있다. 일부 실시예에서, 3D 동작을 위한 텍스처 샘플링 및 미디어 동작을 위한 미디어 샘플링을 제공하기 위해 샘플러가 포함된다. 일부 실시예에서, 샘플러는 샘플링된 데이 터를 실행 유닛에 제공하기 전에 샘플링 프로세스 동안 텍스처 또는 미디어 데이터를 처리하는 전문화된 텍스처 또는 미디어 샘플링 기능을 포함한다. 실행 동안에, 그래픽 및 미디어 파이프라인은 스레드 스포닝 및 디스패치 로직을 통해 스레드 실행 로직에 스레드 개시 요청을 발신한다. 일단 지오메트리 객체의 그룹이 픽셀 데이터로 처리되고 래스터화되었다면, 셰이 더 프로세서 내의 픽셀 프로세서 로직(가령, 픽셀 셰이더 로직, 프래그먼트 셰이더 로직 등)이 호출되어 추가로 출력 정보를 연산하고 결과가 출력 표면(가령, 컬러 버퍼(color buffer), 깊이 버퍼(depth buffer), 스 텐실 버퍼(stencil buffer) 등)에 기록되게 한다. 일부 실시예에서, 픽셀 셰이더 또는 프래그먼트 셰이더는 래 스터화된 객체에 걸쳐 보간될(interpolated) 다양한 정점 속성의 값을 계산한다. 일부 실시예에서, 이후에 셰이 더 프로세서 내의 픽셀 프로세서 로직은 애플리케이션 프로그래밍 인터페이스 공급된(application programming interface(API)-supplied) 픽셀 또는 프래그먼트 셰이더 프로그램을 실행한다. 셰이더 프로그램을 실행하기 위해, 셰이더 프로세서는 스레드 디스패처를 통해 실행 유닛(가령, 508A)에 스레드를 디스 패치한다. 일부 실시예에서, 픽셀 프로세서는 메모리 내에 저장된 텍스처 맵 내의 텍스처 데이터를 액세스 하는 데에 샘플러 내의 텍스처 샘플링 로직을 사용한다. 텍스처 데이터 및 입력 지오메트리 데이터에 대한 산술 동작은 각각의 지오메트리 프래그먼트에 대해 픽셀 컬러 데이터를 연산하거나, 추가의 처리로부터 하나 이 상의 픽셀을 폐기한다. 일부 실시예에서, 데이터 포트는 스레드 실행 로직이 처리된 데이터를 그래픽 프로세서 출력 파이프 라인 상에서의 추가의 처리를 위해 메모리에 출력하기 위한 메모리 액세스 메커니즘을 제공한다. 일부 실시예에 서, 데이터 포트는 데이터 포트를 통해 메모리 액세스를 위해 데이터를 캐싱하는 하나 이상의 캐시 메모리 (가령, 데이터 캐시)를 포함하거나 이에 커플링된다..일 실시예에서, 실행 로직은 또한 광선 추적 가속 기능을 제공할 수 있는 광선 추적기를 포함할 수 있다. 광선 추적기는 광선 생성을 위한 명령어/기능을 포함하는 광선 추적 명령어 세트를 지원할 수 있다. 광선 추적 명령어 세트는 도 2c의 광선 추적 코어에 의해 지원되는 광선 추적 명령어 세트와 유사하거나 다를 수 있다. 도 5b는 실시예에 따라, 실행 유닛의 예시적인 내부 세부사항을 도시한다. 그래픽 실행 유닛은 명령 어 페치 유닛(instruction fetch unit), 일반 레지스터 파일 어레이(General Register File array: GRF), 아키텍처 레지스터 파일 어레이(Architectural Register File array: ARF), 스레드 중재기 (thread arbiter), 발신 유닛(send unit), 브랜치 유닛(branch unit), SIMD 부동 소수점 유닛 (Floating Point Unit: FPU)의 세트, 그리고 하나의 실시예에서 전용 정수 SIMD ALU의 세트를 포함할 수 있다. GRF 및 ARF는 그래픽 실행 유닛 내에서 액티브(active)일 수 있는 각각의 동시 하드웨어 스레드와 연관된 일반 레지스터 파일 및 아키텍처 레지스터 파일의 세트를 포함한다. 하나의 실시예에 서, 스레드당 아키텍처 상태는 ARF 내에 유지되는 한편, 스레드 실행 동안에 사용되는 데이터는 GRF 내에 저장된다. 각각의 스레드를 위한 명령어 포인터를 포함하여, 각각의 스레드의 실행 상태는, ARF 내의 스레드 특정적 레지스터 내에 보유될 수 있다. 하나의 실시예에서 그래픽 실행 유닛은 동시 멀티 쓰레딩(Simultaneous Multi-Threading: SMT) 및 세밀형 (fine-grained)의 인터리빙된 멀티 쓰레딩(Interleaved Multi-Threading: IMT)의 조합인 아키텍처를 갖는다. 그 아키텍처는 동시 스레드의 목표 개수 및 실행 유닛당 레지스터의 개수에 기반하여 설계 시에 미세 조정될 (fine-tuned) 수 있는 모듈식 구성을 갖는데, 실행 유닛 리소스는 다수의 동시 스레드를 실행하는 데에 사용되 는 로직에 걸쳐서 나뉜다. 그래픽 실행 유닛에 의해 실행될 수 있는 로직 스레드의 수는 하드웨어 스레드 의 수에 제한되지 않으며, 다수의 로직 스레드가 각 하드웨어 스레드에 할당될 수 있다. 하나의 실시예에서, 그래픽 실행 유닛은 다수의 명령어를 공동 발행할(co-issue) 수 있는데, 이는 각각 상 이한 명령어일 수 있다. 그래픽 실행 유닛 스레드의 스레드 중재기는 명령어를 발신 유닛, 브랜 치 유닛 또는 SIMD PFU(들) 중 하나에 실행을 위해 디스패치할 수 있다. 각각의 실행 스레드는 GRF 내의 128개 범용 레지스터를 액세스할 수 있는데, 각각의 레지스터는 32비트 데이터 요소의 8 요소 벡 터로서 액세스가능한 32 바이트를 저장할 수 있다. 하나의 실시예에서, 각각의 실행 유닛 스레드는 GRF 내 의 4킬로바이트(Kbytes)에 액세스할 수 있는데, 다만 실시예는 그렇게 한정되지 않으며, 다른 실시예에서 더 많 거나 더 적은 레지스터 리소스가 제공될 수 있다. 하나의 실시예에서 그래픽 실행 유닛은 계산 동작을 독 립적으로 수행할 수 있는 7개의 하드웨어 스레드로 분할될 수 있는데, 다만 실행 유닛당 스레드의 개수는 또한 실시예에 따라 달라질 수 있다. 예를 들어, 하나의 실시예에서, 16개 까지의 하드웨어 스레드가 지원된다. 7개 의 스레드가 4킬로바이트를 액세스할 수 있는 실시예에서, GRF는 총 28킬로바이트를 저장할 수 있다. 16개 의 스레드가 4킬로바이트를 랙세스할 수 있는 경우, GRF는 총 64킬로바이트를 저장할 수 있다. 유연한 (flexible) 어드레스지정 모드는 레지스터가 함께 어드레스지정되어 효과적으로 더 폭넓은 레지스터를 구축하거 나 스트라이드형(strided) 직사각형 블록 데이터 구조를 나타내도록 허가할 수 있다. 하나의 실시예에서, 메모리 동작, 샘플러 동작 및 다른 더 긴 지연시간의 시스템 통신은 메시지 전달 발신 유닛 에 의해 실행되는 \"발신\" 명령어를 통해 디스패치된다. 하나의 실시예에서, 브랜치 명령어는 SIMD 분기 (divergence) 및 궁극적인 수렴화(convergence)를 가능하게 하기 위해 전용 브랜치 유닛에 디스패치된다. 하나의 실시예에서 그래픽 실행 유닛은 부동 소수점 동작을 수행하는 하나 이상의 SIMD 부동 소수점 유닛 (Floating Point Unit: PFU)(들)을 포함한다. 하나의 실시예에서, FPU(들)는 또한 정수 연산을 지원 한다. 하나의 실시예에서 FPU(들)는 최대 M개의 32비트 부동 소수점 (또는 정수) 동작을 SIMD 실행하거나, 최대 2M개의 16비트 정수 또는 16비트 부동 소수점 동작을 SIMD 실행할 수 있다. 하나의 실시예에서, FPU(들) 중 적어도 하나는 높은 처리량(high-throughput)의 초월 수학 함수 및 배 정밀도 64비트 부동 소수점을 지원하 는 확장된 수학 능력을 제공한다. 일부 실시예에서, 8비트 정수 SIMD ALU의 세트가 또한 존재하며, 머신 러닝 연산과 연관된 동작을 수행하도록 구체적으로 최적화될 수 있다. 하나의 실시예에서, 그래픽 실행 유닛의 여러 인스턴스의 어레이는 그래픽 서브코어 그룹화(graphics sub- core grouping)(가령, 서브슬라이스(sub-slice)) 내에 인스턴스화될 수 있다. 스케일가능성을 위해, 제품 기획 자는 서브코어 그룹화당 실행 유닛의 정확한 개수를 고를 수 있다. 하나의 실시예에서 실행 유닛은 복수의 실행 채널에 걸쳐 명령어를 실행할 수 있다. 추가의 실시예에서, 그래픽 실행 유닛 상에서 실행되는 각각 의 스레드는 상이한 채널 상에서 실행된다.도 6은 일 실시예에 따른 추가 실행 유닛을 도시한다. 실행 유닛은 예를 들어 도 3c에서와 같이 계산 엔진 타일(340A-340D)에서 사용하기 위한 계산 최적화 실행 유닛일 수 있지만, 이에 제한되지 않는다. 실행 유 닛의 변형은 또한 도 3b에서와 같이 그래픽 엔진 타일(310A-310D)에서 사용될 수 있다. 일 실시예에서, 실 행 유닛은 스레드 제어 유닛, 스레드 상태 유닛, 명령어 페치/프리페치 유닛, 및 명령어 디코드 유닛(여기에서 디코더로도 지칭됨)을 포함한다. 실행 유닛은 실행 유닛 내의 하드웨어 스레드 에 할당될 수 있는 레지스터를 저장하는 레지스터 파일을 추가로 포함한다. 실행 유닛은 전송 유닛 및 브랜치 유닛을 추가로 포함한다. 일 실시예에서, 전송 유닛 및 브랜치 유닛은 도 5b의 그래픽 실행 유닛의 전송 유닛 및 브랜치 유닛과 유사하게 동작할 수 있다. 실행 유닛은 또한 다수의 상이한 유형의 기능 유닛을 포함하는 계산 유닛을 포함한다. 일 실시예에서, 계산 유닛은 산술 로직 유닛들의 어레이를 포함하는 ALU 유닛을 포함한다. ALU 유닛 은 64비트, 32비트 및 16비트 정수 및 부동 소수점 연산을 수행하도록 구성될 수 있다. 정수 및 부동 소수 점 연산이 동시에 수행될 수 있다. 연산 유닛은 또한 시스톨릭 어레이 및 수학 유닛을 포함할 수 있다. 시스톨릭 어레이는 시스톨릭 방식으로 벡터 또는 다른 데이터 병렬 연산을 수행하는 데 사용될 수 있는 데이터 처리 디바이스의 W 폭 및 D 심층 네트워크를 포함한다. 일 실시예에서, 시스톨릭 어레이는 행렬 내적 연산과 같은 행렬 연산을 수행하도록 구성될 수 있다. 일 실시예에서, 시스톨릭 어레이는 16비 트 부동 소수점 연산 뿐만 아니라 8비트 및 4비트 정수 연산을 지원한다. 일 실시예에서, 시스톨릭 어레이(61 2)는 머신 러닝 동작을 가속화하도록 구성될 수 있다. 이러한 실시예에서, 시스톨릭 어레이는 bfloat 16비 트 부동 소수점 형식을 지원하도록 구성될 수 있다. 일 실시예에서, 수학 유닛은 ALU 유닛보다 효율 적이고 저전력 방식으로 수학 연산의 특정 서브세트를 수행하기 위해 포함될 수 있다. 수학 유닛은 다른 실시예에 의해 제공되는 그래픽 처리 엔진의 공유 함수 로직에서 찾을 수 있는 수학 로직(예를 들어, 도 4의 공 유 함수 로직의 수학 로직)의 변형을 포함할 수 있다. 일 실시예에서 수학 유닛은 32비트 및 64 비트 부동 소수점 연산을 수행하도록 구성될 수 있다. 스레드 제어 유닛은 실행 유닛 내에서 스레드의 실행을 제어하기 위한 로직을 포함한다. 스레드 제어 유닛 은 실행 유닛 내에서 스레드의 실행을 시작, 중지 및 선점하기 위한 스레드 중재 로직을 포함할 수 있다. 스레드 상태 유닛은 실행 유닛에서 실행하도록 할당된 스레드에 대한 스레드 상태를 저장하는 데 사용될 수 있다. 실행 유닛 내에 스레드 상태를 저장하는 것은, 그러한 스레드가 차단되거나 유휴 상태 가 될 때 스레드의 신속한 선점을 가능하게 한다. 명령어 페치/프리페치 유닛은 상위 레벨 실행 로직(예를 들어, 도 5a에서와 같은 명령어 캐시)의 명령어 캐시로부터 명령어를 페치할 수 있다. 명령어 페치/프리페 치 유닛은 또한 현재 실행 중인 스레드의 분석에 기초하여 명령어 캐시에 로드될 명령어에 대한 프리페치 요청을 발행할 수 있다. 명령어 디코드 유닛은 연산 유닛에 의해 실행될 명령어를 디코딩하는 데 사용될 수 있다. 일 실시예에서, 명령어 디코드 유닛은 복잡한 명령어를 구성 마이크로 연산들로 디코딩하기 위한 2차 디코더로서 사용될 수 있다. 실행 유닛은 실행 유닛에서 실행되는 하드웨어 스레드에 의해 사용될 수 있는 레지스터 파일을 추가로 포함한다. 레지스터 파일의 레지스터는 실행 유닛의 계산 유닛 내에서 다수의 동시 스레 드를 실행하는 데 사용되는 로직에 걸쳐 분할될 수 있다. 그래픽 실행 유닛에 의해 실행될 수 있는 로직 스레드의 수는 하드웨어 스레드의 수에 제한되지 않으며, 각 하드웨어 스레드에 다수의 로직 스레드가 할당될 수 있다. 레지스터 파일의 크기는 지원되는 하드웨어 스레드의 수에 기초하여 실시예에 따라 변할 수 있다. 일 실시예에서, 레지스터 이름 바꾸기(register renaming)는 레지스터를 하드웨어 스레드에 동적으로 할 당하는 데 사용될 수 있다. 도 7은 일부 실시예에 따라 그래픽 프로세서 명령어 포맷을 보여주는 블록도이다. 하나 이상의 실시예에서, 그래픽 프로세서 실행 유닛은 여러 포맷으로 된 명령어를 갖는 명령어 세트를 지원한다. 실선 박스 는 일반적으로 실행 유닛 명령어에 포함된 컴포넌트를 보여주는 한편, 점선은 선택적인 또는 오직 명령어의 서 브세트에 포함된 컴포넌트를 포함한다. 일부 실시예에서, 기술되고 예시된 명령어 포맷은, 일단 명령어가 처리되면 명령어 디코드로부터 초래되는 마이크로 동작(micro-operation)에 반해, 이는 실행 유닛에 공급되는 명령어라는 점에서, 매크로 명령어(macro-instruction)이다. 일부 실시예에서, 그래픽 프로세서 실행 유닛은 128비트 명령어 포맷으로 된 명령어를 네이티브로 (natively) 지원한다. 선택된 명령어, 명령어 옵션, 그리고 피연산자의 수에 기반하여 몇몇 명령어를 위해 64비 트 압축형(compacted) 명령어 포맷이 이용가능하다. 네이티브 128비트 명령어 포맷은 모든 명령어 옵 션에 대한 액세스를 제공하는 한편, 몇몇 옵션 및 동작은 64비트 포맷에 제한된다. 64비트 포맷에서이용가능한 네이티브 명령어는 실시예에 의해 달라진다. 일부 실시예에서, 명령어는 인덱스 필드 내의 인 덱스 값의 세트를 사용하여 부분적으로 압축된다. 실행 유닛 하드웨어는 인덱스 값에 기반하여 압축 테이블의 세트를 참조하고 압축 테이블 출력을 사용하여 128비트 명령어 포맷으로 된 네이티브 명령어를 재구성한다. 명령어의 다른 크기 및 포맷이 사용될 수 있다. 각각의 포맷에 대해, 명령어 연산 코드(instruction opcode)는 실행 유닛이 수행할 동작을 정의한다. 실행 유닛은 각각의 피연산자의 여러 데이터 요소에 걸쳐 병렬로 각각의 명령어를 실행한다. 예를 들어, 가산(add) 명령어에 응답하여 실행 유닛은 텍스처 요소(texture element) 또는 화상 요소(picture element)를 나타내는 각 각의 컬러 채널에 걸쳐 동시 가산 동작을 수행한다. 디폴트로, 실행 유닛은 피연산자의 모든 데이터 채널에 걸 쳐 각각의 명령어를 수행한다. 일부 실시예에서, 명령어 제어 필드는 채널 선택(가령, 프레디케이션 (predication)) 및 데이터 채널 순서(가령, 스위즐(swizzle))과 같은 어떤 실행 옵션에 대한 제어를 가능하게 한다. 128비트 명령어 포맷 내의 명령어에 대해 실행 크기 필드는 병렬로 실행될 데이터 채널의 수를 제한한다. 일부 실시예에서, 실행 크기 필드는 64비트 압축 명령어 포맷에서의 사용을 위해서는 가용 하지 않다. 몇몇 실행 유닛 명령어는 2개의 소스 피연산자(src0, src1)와, 하나의 목적지(destination)를 포함하는 최대 3개의 피연산자를 갖는다. 일부 실시예에서, 실행 유닛은 이중 목적지 명령어를 지원하는데, 목 적지 중 하나는 암시된다. 데이터 조작 명령어가 제3 소스 피연산자(가령, SRC2)를 가질 수 있는데, 명령 어 연산 코드는 소스 피연산자의 수를 결정한다. 명령어의 마지막 소스 피연산자는 명령어와 함께 전달되 는 즉시적인(immediate)(가령, 하드코딩된(hard-coded)) 값일 수 있다. 일부 실시예에서, 128비트 명령어 포맷은, 예컨대, 직접 레지스터 어드레스지정 모드가 또는 간접 레지스 터 어드레스지정 모드가 사용되는지를 지정하는 액세스/어드레스 모드 필드를 포함한다. 직접 레지스터 어 드레스지정 모드가 사용되는 경우에, 하나 이상의 피연산자의 레지스터 어드레스는 명령어 내의비트에 의해 직 접 제공된다. 일부 실시예에서, 128비트 명령어 포맷은 명령어를 위한 어드레스 모드 및/또는 액세스 모드를 지정하는 액세스/어드레스 모드 필드를 포함한다. 하나의 실시예에서 액세스 모드는 명령어를 위한 데이터 액세스 정렬(alignment)을 정의하는 데에 사용된다. 일부 실시예는 16 바이트 정렬된 액세스 모드 및 1 바이트 정렬된 액세스 모드를 포함하는 액세스 모드를 지원하는데, 액세스 모드의 바이트 정렬은 명령어 피연산자의 액세스 정 렬을 결정한다. 예를 들어, 제1 모드에 있는 경우에, 명령어는 소스 및 목적지 피연산자를 위해 바이트 정렬된 어드레스지정을 사용할 수 있고 제2 모드에 있는 경우에, 명령어는 모든 소스 및 목적지 피연산자를 위해 16 바 이트 정렬된 어드레스지정을 사용할 수 있다. 하나의 실시예에서, 액세스/어드레스 모드 필드의 어드레스 모드 부분은 명령어가 직접 또는 간접 어드레 스지정을 사용할 것인지를 결정한다. 직접 레지스터 어드레스지정 모드가 사용되는 경우에 명령어 내의비트가 하나 이상의 피연산자의 레지스터 어드레스를 직접적으로 제공한다. 간접 레지스터 어드레스지정 모드가 사용되 는 경우에, 하나 이상의 피연산자의 레지스터 어드레스는 명령어 내의 어드레스 레지스터 값 및 어드레스 즉시 필드(address immediate field)에 기반하여 연산될 수 있다. 일부 실시예에서 연산 코드 디코드를 단순화하기 위해 연산 코드비트 필드에 기반하여 명령어가 그룹 화된다. 8비트 연산 코드에 대해, 비트 4, 5 및 6은 실행 유닛이 연산 코드의 타입을 판정할 수 있게 한다. 도 시된 그대로의 연산 코드 그룹화는 단지 예이다. 일부 실시예에서, 이동 및 로직 연산 코드 그룹(move and logic opcode group)은 데이터 이동 및 로직 명령어(가령, move (mov), compare (cmp))를 포함한다. 일부 실시예에서, 이동 및 로직 그룹은 5개의 최상위 비트(Most Significant Bits: MSB)를 공유하는데, move (mov) 명령어는 0000xxxxb의 형태로 되어 있고 로직 명령어는 0001xxxxb의 형태로 되어 있다. 흐름 제어 명령어 그룹(가령, call, jump (jmp))은 0010xxxxb(가령, 0x20)의 형태로 된 명령어를 포함한다. 기타 (Miscellaneous) 명령어 그룹은 0011xxxxb(가령, 0x30)의 형태로 된 동기화 명령어(가령, wait, send)를 포함하는 명령어의 혼합을 포함한다. 병렬 수학 명령어 그룹은 0100xxxxb(가령, 0x40)의 형태로 된 컴포넌 트별 산술 명령어(가령, add, multiply (mul))를 포함한다. 병렬 수학 그룹은 데이터 채널에 걸쳐 병렬로 산술 동작을 수행한다. 벡터 수학 그룹은 0101xxxxb(가령, 0x50)의 형태로 된 산술 명령어(가령, dp4)를 포함한다. 벡터 수학 그룹은 벡터 피연산자에 대해 내적 계산과 같은 산술을 수행한다. 일 실시예에서, 예시된 연산 코드 디코드는 디코딩된 명령어를 실행하기 위해 실행 유닛의 어느 부분이 사용될 것인지를 결정하는 데 사용될 수 있다. 예를 들어, 일부 명령어는 시스톨릭 어레이(systolic array)에 의해 수행될 시스톨릭 명령어로 지정될 수 있다. 광선 추적 명령어(미도시)와 같은 다른 명령어는 실행 로직의 슬라이스 또는 파티션 내의 광선 추적 코어 또는 광선 추적 로직으로 라우팅될 수 있다. 그래픽 파이프라인 도 8은 그래픽 프로세서의 다른 실시예의 블록도이다. 본 문서에서 임의의 다른 도면의 요소와 동일한 참 조 번호(또는 명칭)를 갖는 도 8의 요소는 본 문서에서 다른 데에 기술된 것과 유사한 임의의 방식으로 동작하 거나 기능할 수 있으나, 그러한 것에 한정되지 않는다. 일부 실시예에서, 그래픽 프로세서는 지오메트리 파이프라인, 미디어 파이프라인, 디스플레이 엔진, 스레드 실행 로직 및 렌더 출력 파이프라인을 포함한다. 일부 실시예에서, 그래픽 프로세 서는 하나 이상의 범용 처리 코어를 포함하는 멀티 코어 처리 시스템 내의 그래픽 프로세서이다. 그래픽 프로세서는 하나 이상의 제어 레지스터(도시되지 않음)로의 레지스터 쓰기에 의해 제어되거나 링 인터커넥트 를 통해 그래픽 프로세서에 발행된 커맨드를 통해 제어된다. 일부 실시예에서, 링 인터커넥트는 그래픽 프로세서를 다른 그래픽 프로세서 또는 범용 프로세서와 같은 다른 처리 컴포넌트에 커플링한다. 링 인터커넥트로부터의 커맨드는 커맨드 스트리머에 의해 해석되는데, 이는 지오메트리 파이프라인 또는 미디어 파이프라인의 개별 컴포넌트에 명령어를 공급한다. 일부 실시예에서, 커맨드 스트리머는, 메모리로부터 정점 데이터를 판독하고 커맨드 스트리머에 의해 제공된 정점 처리 커맨드를 실행하는 정점 페처(vertex fetcher)의 동작을 지시한다. 일부 실시예에서, 정 점 페처는 정점 데이터를 정점 셰이더에 제공하는데, 이는 좌표 공간 변환 및 조명 동작을 각각의 정 점에 대해 수행한다. 일부 실시예에서, 정점 페처 및 정점 셰이더는 스레드 디스패처를 통해 실 행 유닛(852A-852B)에 실행 스레드를 디스패치함으로써 정점 처리 명령어를 실행한다. 일부 실시예에서, 실행 유닛(852A-852B)은 그래픽 및 미디어 동작을 수행하기 위한 명령어 세트를 갖는 벡터 프 로세서의 어레이이다. 일부 실시예에서, 실행 유닛(852A-852B)은 각각의 어레이에 특정적이거나 어레이 간에 공 유되는 부속된 L1 캐시를 갖는다. 캐시는 데이터 캐시, 명령어 캐시, 또는 데이터 및 명령어를 상이한 파 티션에 포함하도록 파티셔닝된(partitioned) 단일 캐시로서 구성될 수 있다. 일부 실시예에서, 지오메트리 파이프라인은 3D 객체의 하드웨어 가속화된 테셀레이션을 수행하는 테셀레이 션 컴포넌트를 포함한다. 일부 실시예에서, 프로그램 가능 헐 셰이더(programmable hull shader)가 테셀레 이션 동작을 구성한다. 프로그램 가능 도메인 셰이더(programmable domain shader)는 테셀레이션 출력의 백 엔드 평가(back-end evaluation)를 제공한다. 테셀레이터(tessellator)는 헐 셰이더의 지시로 동 작하며 지오메트리 파이프라인에 입력으로서 제공되는 소략한 지오메트리 모델(coarse geometric model)에 기반하여 상세한 지오메트리 객체의 세트를 생성하는 특수 목적 로직을 포함한다. 일부 실시예에서, 테셀레이션 이 사용되지 않는 경우, 테셀레이션 컴포넌트(가령, 헐 셰이더, 테셀레이터 및 도메인 셰이더) 는 바이패스될(bypassed) 수 있다. 테셀레이션 컴포넌트는 정점 셰이더로부터 수신된 데이터에 기초하여 동작할 수 있다. 일부 실시예에서, 완전한 지오메트리 객체는 실행 유닛(852A-852B)에 디스패치된 하나 이상의 스레드를 통해 지 오메트리 셰이더에 의해 처리될 수 있거나, 직접적으로 클리퍼(clipper)로 진행할 수 있다. 일부 실 시예에서, 지오메트리 셰이더는, 그래픽 파이프라인의 이전의 스테이지에서와 같이 정점 또는 정점의 패치보다 는, 전체 지오메트리 객체에 대해 동작한다. 테셀레이션이 디스에이블되는 경우에 지오메트리 셰이더는 정 점 셰이더로부터 입력을 수신한다. 일부 실시예에서, 지오메트리 셰이더는 테셀레이션 유닛이 디스에 이블되는 경우 지오메트리 테셀레이션을 수행하도록 지오메트리 셰이더 프로그램에 의해 프로그램 가능하다. 래스터화 전에, 클리퍼가 정점 데이터를 처리한다. 클리퍼는 고정 함수 클리퍼이거나 클리핑 및 지오 메트리 셰이더 기능을 갖는 프로그램 가능 클리퍼일 수 있다. 일부 실시예에서, 렌더 출력 파이프라인 내 의 레스터화기 및 깊이 테스트 컴포넌트는 지오메트리 객체를 픽셀당 표현으로 변환하기 위해 픽셀 셰이더 를 디스패치한다. 일부 실시예에서, 픽셀 셰이더 로직은 스레드 실행 로직에 포함된다. 일부 실시예에서, 애플리케이션은 래스터화기 및 깊이 테스트 컴포넌트를 바이패스하고 래스터화되지 않은 정점 데이터를 스 트림 아웃 유닛(stream out unit)을 통해 액세스할 수 있다. 그래픽 프로세서는 상호연결 버스, 상호연결 패브릭, 또는 프로세서의 주요 컴포넌트 사이를 통과하는 데 이터 및 메시지를 가능케 하는 어떤 다른 상호연결 메커니즘을 갖는다. 일부 실시예에서, 실행 유닛(852A-852B) 및 연관된 로직 유닛(가령, L1 캐시, 샘플러, 텍스처 캐시 등)은 데이터 포트를 통해 상호연결되어 메모리 액세스를 수행하고 프로세서의 렌더 출력 파이프라인 컴포넌트와 통신한다. 일부 실시예에서, 샘플러, 캐시(851, 858), 및 실행 유닛(852A-852B)은 각각 별개의 메모리 액세스 경로를 갖는다. 하나의 실시예에서 텍스처 캐시는 또한 샘플러 캐시로서 구성될 수 있다. 일부 실시예에서, 렌더 출력 파이프라인은 정점 기반 객체를 연관된 픽셀 기반 표현으로 변환하는 레스터 화기 및 깊이 테스트 컴포넌트를 포함한다. 일부 실시예에서, 래스터화기 로직은 고정 함수 삼각형 및 라 인 래스터화를 수행하는 윈도우어(windower)/마스커(masker) 유닛을 포함한다. 연관된 렌더 캐시 및 깊이 캐시가 일부 실시예에서 또한 이용가능하다. 픽셀 동작 컴포넌트가 데이터에 대해 픽셀 기반 동작을 수행하는데, 몇몇 사례에서이기는 하지만, 2D 동작(가령 블렌딩으로써의 비트 블록 이미지 전송)과 연관된 픽셀 동작은 2D 엔진에 의해 수행되거나, 오버레이 디스플레이 평면을 사용하여 디스플레이 컨트롤러에 의 해 디스플레이 시간에 대체된다. 일부 실시예에서, 공유된 L3 캐시는 모든 그래픽 컴포넌트가 이용할 수 있으니, 메인 시스템 메모리의 사용 없이 데이터의 공유를 가능하게 한다. 일부 실시예에서, 그래픽 프로세서 미디어 파이프라인은 미디어 엔진 및 비디오 프론트 엔드를 포함한다. 일부 실시예에서, 비디오 프론트 엔드는 커맨드 스트리머로부터 파이프라인 커맨드를 수신 한다. 일부 실시예에서, 미디어 파이프라인은 별개의 커맨드 스트리머를 포함한다. 일부 실시예에서, 비디 오 프론트 엔드는 미디어 커맨드를, 미디어 엔진에 커맨드를 발신하기 전에 처리한다. 일부 실시예에 서, 미디어 엔진은 스레드 디스패처를 통한 스레드 실행 로직으로의 디스패치를 위해 스레드를 스폰하는 스레드 스포닝 기능을 포함한다. 일부 실시예에서, 그래픽 프로세서는 디스플레이 엔진을 포함한다. 일부 실시예에서, 디스플레이 엔 진은 프로세서의 외부에 있으며 링 인터커넥트 또는 어떤 다른 상호연결 버스나 패브릭을 통해 그래픽 프로세서와 커플링된다. 일부 실시예에서, 디스플레이 엔진은 2D 엔진 및 디스플레이 컨트롤 러를 포함한다. 일부 실시예에서, 디스플레이 엔진은 3D 파이프라인과는 독립적으로 동작할 수 있는 특수 목적 로직을 포함한다. 일부 실시예에서, 디스플레이 컨트롤러는, 랩톱 컴퓨터에서와 같이 시스템 집 적 디스플레이 디바이스이거나 디스플레이 디바이스 커넥터를 통해 부속된 외부 디스플레이 디바이스일 수 있는 디스플레이 디바이스(도시되지 않음)와 커플링된다. 일부 실시예에서, 지오메트리 파이프라인 및 미디어 파이프라인은 다수의 그래픽 및 미디어 프로그래 밍 인터페이스에 기반하여 동작을 수행하도록 구성가능하며 임의의 하나의 애플리케이션 프로그래밍 인터페이스 (Application Programming Interface: API)에 특정적이지는 않다. 일부 실시예에서, 그래픽 프로세서를 위한 드라이버 소프트웨어는 특정한 그래픽 또는 미디어 라이브러리에 특정적인 API 호출을 그래픽 프로세서에 의해 처리될 수 있는 커맨드로 전환한다. 일부 실시예에서, Open Graphics Library (OpenGL), Open Computing Language (OpenCL) 및/또는 Vulkan graphics and compute API에 대해 지원이 제공되는데, 모두 크로노스 그룹 (Khronos Group)으로부터 것이다. 일부 실시예에서, 마이크로소프트 사(Microsoft Corporation)로부터의 Direct3D 라이브러리에 대한 지원이 또한 제공될 수 있다. 일부 실시예에서, 이들 라이브러리의 조합이 지원될 수 있다. Open Source Computer Vision Library (OpenCV)에 대한 지원이 또한 제공될 수 있다. 호환가능한 3D 파이프라인을 가진 장래의 API가 또한 만일 장래의 API의 파이프라인으로부터 그래픽 프로세서의 파이프라인으 로의 맵핑이 행해질 수 있으면 지원될 것이다. 그래픽 파이프라인 프로그래밍 도 9a는 일부 실시예에 따른 그래픽 프로세서 커맨드 포맷을 보여주는 블록도이다. 도 9b는 실시예에 따른 그래픽 프로세서 커맨드 시퀀스를 보여주는 블록도이다. 도 9a에서의 실선 박스는 일반적으로 그래픽 커맨 드에 포함된 컴포넌트를 보여주는 한편 점선은 선택적인 또는 오직 그래픽 커맨드의 서브세트에 포함된 컴포넌 트를 포함한다. 도 9a의 예시적인 그래픽 프로세서 커맨드 포맷은 클라이언트(client), 커맨드 동작 코드(연산 코드) 및 커맨드를 위한 데이터를 식별하는 데이터필드를 포함한다. 서브-연산 코드(sub- opcode) 및 커맨드 크기가 몇몇 커맨드에 또한 포함된다. 일부 실시예에서, 클라이언트는 커맨드 데이터를 처리하는 그래픽 디바이스의 클라이언트 유닛을 지정한다. 일부 실시예에서, 그래픽 프로세서 커맨드 파서(graphics processor command parser)가 각각의 커맨 드의 클라이언트 필드를 조사하여 커맨드의 추가 처리를 좌우하고(condition) 커맨드 데이터를 적절한 클라이언 트 유닛에 라우팅한다. 일부 실시예에서, 그래픽 프로세서 클라이언트 유닛은 메모리 인터페이스 유닛, 렌더 유 닛, 2D 유닛, 3D 유닛 및 미디어 유닛을 포함한다. 각각의 클라이언트 유닛은 커맨드를 처리하는 대응하는 처리 파이프라인을 갖는다. 일단 커맨드가 클라이언트 유닛에 의해 수신되면, 클라이언트 유닛은 수행할 동작을 판정하기 위해 연산 코드를, 그리고 만일 존재한다면 서브-연산 코드를 판독한다. 클라이언트 유닛은 데 이터 필드 내의 정보를 사용하여 커맨드를 수행한다. 몇몇 커맨드에 대해 명시적인 커맨드 크기는 커 맨드의 크기를 지정할 것으로 기대된다. 일부 실시예에서, 커맨드 파서는 커맨드 연산 코드에 기반하여 커맨드 중 적어도 일부의 크기를 자동으로 판정한다. 일부 실시예에서 커맨드는 더블 워드의 다중을 통해 정렬된다. 다 른 커맨드 포맷이 사용될 수 있다. 도 9b의 흐름도는 예시적인 그래픽 프로세서 커맨드 시퀀스를 보여준다. 일부 실시예에서, 그래픽 프로세 서의 실시예를 특징으로 하는 데이터 처리 시스템의 소프트웨어 또는 펌웨어는 그래픽 동작의 세트를 셋업하고 실행하고 종결하는 것으로 도시된 커맨드 시퀀스의 버전을 사용한다. 오직 예를 위해 샘플 커맨드 시퀀스가 도 시되고 기술되는데 실시예는 이들 구체적인 커맨드에 또는 이 커맨드 시퀀스에 한정되지 않는다. 더욱이, 커맨 드는 커맨드 시퀀스 내의 커맨드의 배치(batch)로서 발행될 수 있어서, 그래픽 프로세서는 적어도 부분적으로 동시성 있게 커맨드의 시퀀스를 처리할 것이다. 일부 실시예에서, 그래픽 프로세서 커맨드 시퀀스는 파이프라인 플러시 커맨드(pipeline flush command)로 시작하여 임의의 액티브 그래픽 파이프라인이 파이프라인을 위한 현재 계류 중인 커맨드를 완 료하게 한다. 일부 실시예에서, 3D 파이프라인 및 미디어 파이프라인은 동시에 동작하지 않는다. 파 이프라인 플러시는 액티브 그래픽 파이프라인으로 하여금 임의의 계류 중인 커맨드를 완료하게 하기 위해 수행 된다. 파이프라인 플러시에 응답하여, 그래픽 프로세서를 위한 커맨드 파서는 액티브 드로잉 엔진(drawing engine)이 계류 중인 동작을 완료하고 관련 판독 캐시가 무효화될(invalidated) 때까지 커맨드 처리를 일시중단 할(pause) 것이다. 선택적으로, '더티(dirty)'라고 마킹된(marked) 렌더 캐시 내의 임의의 데이터는 메모리에 플러시될 수 있다. 일부 실시예에서, 파이프라인 플러시 커맨드는 파이프라인 동기화를 위해 또는 그래픽 프로세서를 저전력 상태에 두기 전에 사용될 수 있다. 일부 실시예에서, 파이프라인 선택 커맨드는 커맨드 시퀀스가 그래픽 프로세서로 하여금 파이프라인 사이 에서 명시적으로 스위칭하도록 요구하는 경우에 사용된다. 일부 실시예에서, 파이프라인 선택 커맨드는 실 행 컨텍스트(execution context) 내에서, 그 콘텍스트가 두 파이프라인 모두를 위한 커맨드를 발행하는 것이 아 닌 한, 파이프라인 커맨드를 발행하기 전에 한 번만 사용된다. 일부 실시예에서, 파이프라인 플러시 커맨드 는 파이프라인 선택 커맨드를 통한 파이프라인 스위치 전에 즉시 사용된다. 일부 실시예에서, 파이프라인 제어 커맨드는 동작을 위한 그래픽 파이프라인을 구성하며, 3D 파이프라인 및 미디어 파이프라인을 프로그래밍하는 데에 사용된다. 일부 실시예에서, 파이프라인 제어 커맨드 는 액티브 파이프라인을 위한 파이프라인 상태를 구성한다. 하나의 실시예에서, 파이프라인 제어 커맨드 는 파이프라인 동기화를 위해, 그리고 커맨드의 배치를 처리하기 전에 액티브 파이프라인 내의 하나 이상 의 캐시 메모리로부터 데이터를 클리어하는(clear) 데에 사용된다. 일부 실시예에서, 반환 버퍼 상태 커맨드는 데이터를 기록하도록 각 파이프라인을 위한 반환 버퍼의 세트 를 구성하는 데에 사용된다. 몇몇 파이프라인 동작은 처리 동안에 그 동작이 중간 데이터를 기록하는 하나 이상 의 반환 버퍼의 할당, 선택 또는 구성을 사용한다. 일부 실시예에서, 그래픽 프로세서는 또한 하나 이상의 반환 버퍼를 사용하여 출력 데이터를 저장하고 스레드 교차 통신(cross thread communication)을 수행한다. 일부 실 시예에서, 반환 버퍼 상태는 파이프라인 동작의 세트를 위해 사용할 반환 버퍼의 크기 및 개수를 선택하는 것을 포함한다. 커맨드 시퀀스 내의 나머지 커맨드는 동작을 위한 액티브 파이프라인에 기반하여 차이가 난다. 파이프라인 판정 에 기반하여, 커맨드 시퀀스는 3D 파이프라인 상태로 시작하는 3D 파이프라인으로 또는 미디어 파이프라인 상태에서 시작하는 미디어 파이프라인으로 맞춤화된다(tailored). 3D 파이프라인 상태를 구성하는 커맨드는 3D 프리미티브 커맨드가 처리되기 전에 구성될 정점 버퍼 상태, 정점 요소 상태, 일정한 컬러 상태, 깊이 버퍼 상태 및 다른 상태 변수를 위한 3D 상태 설정 커맨드를 포함한다. 이들 커맨드의 값은 사용 중인 특정 3D API에 적어도 부분적으로 기반하여 판정된다. 일부 실시예에 서, 3D 파이프라인 상태 커맨드는 또한 어떤 파이프라인 요소를, 만일 그런 요소가 사용되지 않을 것이라 면 선택적으로 디스에이블하거나 바이패스할 수 있다. 일부 실시예에서, 3D 프리미티브 커맨드는 3D 파이프라인에 의해 처리될 3D 프리미티브를 제출하는 데에 사용된다. 3D 프리미티브 커맨드를 통해 그래픽 프로세서로 전해지는 커맨드 및 연관된 파라미터는 그래픽 파이프라인 내의 정점 페치 기능으로 포워딩된다. 정점 페치 기능은 정점 데이터 구조를 생성하는 데에 3D 프리미티브 커맨드 데이터를 사용한다. 정점 데이터 구조는 하나 이상의 반환 버퍼 내에 저장된다. 일부 실시 예에서, 3D 프리미티브 커맨드는 정점 셰이더를 통해 3D 프리미티브에 대해 정점 동작을 수행하는 데에 사 용된다. 정점 셰이더를 처리하기 위해, 3D 파이프라인은 셰이더 실행 스레드를 그래픽 프로세서 실행 유닛 으로 디스패치한다. 일부 실시예에서, 3D 파이프라인은 실행 커맨드 또는 이벤트를 통해 트리거된다(triggered). 일부 실 시예에서, 레지스터 쓰기는 커맨드 실행을 트리거한다. 일부 실시예에서 실행은 커맨드 시퀀스 내의 '고(go)' 또는 '킥(kick)' 커맨드를 통해 트리거된다. 하나의 실시예에서, 커맨드 실행은 커맨드 시퀀스를 그래픽 파이프 라인을 통해 플러시하는 파이프라인 동기화 커맨드를 사용하여 트리거된다. 3D 파이프라인은 3D 프리미티브를 위한 지오메트리 처리를 수행할 것이다. 일단 동작이 완료되면, 결과적인 지오메트리 객체는 래스터화되며 픽셀 엔진은 결과적인 픽셀을 채색한다. 픽셀 셰이딩 및 픽셀 백 엔드 동작을 제어하는 추가적인 커맨드가 그런 동작 을 위해 또한 포함될 수 있다. 일부 실시예에서, 그래픽 프로세서 커맨드 시퀀스는 미디어 동작을 수행하는 경우에 미디어 파이프라인 경로를 따른다. 일반적으로, 미디어 파이프라인을 위한 프로그래밍의 특정한 사용 및 방식은 수행될 미디어 또는 계산 동작에 달려 있다. 특정한 미디어 디코드 동작은 미디어 디코드 동안에 미디어 파이프라인에 분담될 수 있다. 일부 실시예에서, 미디어 파이프라인은 또한 바이패스될 수 있고 미디어 디코드는 하나 이상의 범용 처리 코어에 의해 제공된 리소스를 사용하여 전체적으로 또는 부분적으로 수행될 수 있다. 하나의 실시예 에서, 미디어 파이프라인은 또한 범용 그래픽 프로세서 유닛(General-Purpose Graphics Processor Unit: GPGPU) 동작을 위한 요소를 포함하는데, 그래픽 프로세서는 그래픽 프리미티브의 렌더링에 명시적으로 관련되지 는 않는 연산 셰이더 프로그램을 사용하여 SIMD 벡터 동작을 수행하는 데에 사용된다. 일부 실시예에서, 미디어 파이프라인은 3D 파이프라인과 유사한 방식으로 구성된다. 미디어 파이프라 인 상태를 구성하는 커맨드의 세트가 미디어 객체 커맨드 전에 커맨드 큐에 놓이거나 디스패치된다. 일부 실시예에서, 미디어 파이프라인 상태를 위한 커맨드는 미디어 객체를 처리하는 데에 사용될 미디어 파이프라인 요소를 구성하는 데이터를 포함한다. 이것은 미디어 파이프라인 내의 비디오 디코드 및 비디오 인코 드 로직을 구성하는 데이터, 예를 들면 인코드 또는 디코드 포맷을 포함한다. 일부 실시예에서, 미디어 파이프 라인 상태를 위한 커맨드는 또한 상태 설정의 배치를 포함하는 \"간접\" 상태 요소에 대한 하나 이상의 포인 터의 사용을 지원한다. 일부 실시예에서, 미디어 객체 커맨드는 미디어 파이프라인에 의한 처리를 위한 미디어 객체에 대한 포인 터를 공급한다. 미디어 객체는 처리될 비디오 데이터를 포함한 메모리 버퍼를 포함한다. 일부 실시예에서, 모든 미디어 파이프라인 상태는 미디어 객체 커맨드를 발행하기 전에 유효하여야 한다. 일단 파이프라인 상태가 구성되고 미디어 객체 커맨드가 큐잉되면(queued), 미디어 파이프라인은 실행 커맨드 또는 균등 한 실행 이벤트(가령, 레지스터 쓰기)를 통해 트리거된다. 이후 미디어 파이프라인으로부터의 출력은 3D 파이프라인 또는 미디어 파이프라인에 의해 제공되는 동작에 의해 후처리될 수 있다. 일부 실시예에 서, GPGPU 동작은 미디어 동작과 유사한 방식으로 구성되고 실행된다. 그래픽 소프트웨어 아키텍처 도 10은 일부 실시예에 따라 데이터 처리 시스템을 위한 예시적인 그래픽 소프트웨어 아키텍처를 보여준 다. 일부 실시예에서, 소프트웨어 아키텍처는 3D 그래픽 애플리케이션, 운영 체제 및 적어도 하나 의 프로세서를 포함한다. 일부 실시예에서, 프로세서는 그래픽 프로세서 및 하나 이상의 범 용 프로세서 코어(들)를 포함한다. 그래픽 애플리케이션 및 운영 체제은 각각 데이터 처리 시스템의 시스템 메모리 내에서 실행된다. 일부 실시예에서, 3D 그래픽 애플리케이션은 셰이더 명령어를 포함하는 하나 이상의 셰이더 프로그 램을 포함한다. 셰이더 언어 명령어는 고레벨 셰이더 언어(high-level shader language), 예를 들면 Direct3D 의 고레벨 셰이더 언어(High-Level Shader Language: HLSL), OpenGL 셰이더 언어(OpenGL Shader Language: GLSL) 및 기타 등등일 수 있다. 애플리케이션은 또한 범용 프로세서 코어에 의한 실행에 적합한 기계어 (machine language)로 된 실행가능한 명령어를 포함한다. 애플리케이션은 또한 정점 데이터에 의해 정의 된 그래픽 객체를 포함한다. 일부 실시예에서, 운영 체제는 마이크로소프트 사(Microsoft Corporation)으로부터의 마이크로소프트 (Microsoft®) 윈도우즈(Windows®) 운영 체제, 전유(proprietary) UNIX 계열 운영 체제, 또는 리눅스(Linux)커널의 변형을 사용하는 오픈 소스 UNIX 계열 운영 체제이다. 운영 체제은 Direct3D API, OpenGL API, 또는 Vulkan API와 같은 그래픽 API를 지원할 수 있다. Direct3D API가 사용 중인 경우에, 운영 체제 은 HLSL 내의 임의의 셰이더 명령어를 저레벨 셰이더 언어로 컴파일하는 데에 프론트 엔드 셰이더 컴파일러를 사용한다. 컴파일은 적시(Just-In-Time: JIT) 컴파일일 수 있거나 애플리케이션은 셰이더 사 전컴파일(pre-compilation)을 수행할 수 있다. 일부 실시예에서, 고레벨 셰이더가 3D 그래픽 애플리케이션 의 컴파일 동안에 저레벨 셰이더로 컴파일된다. 일부 실시예에서, 셰이더 명령어는 중간 형태, 예 를 들면 Vulkan API에 의해 사용되는 표준 포터블 중간 표현(Standard Portable Intermediate Representation: SPIR)의 버전으로 제공된다. 일부 실시예에서, 사용자 모드 그래픽 드라이버는 셰이더 명령어를 하드웨어 특정적 표현으로 변환 하는 백 엔드 셰이더 컴파일러를 포함한다. OpenGL API가 사용 중인 경우에, GLSL 고레벨 언어로 된 셰이 더 명령어가 컴파일을 위해 사용자 모드 그래픽 드라이버로 전해진다. 일부 실시예에서, 사용자 모 드 그래픽 드라이버는 커널 모드 그래픽 드라이버와 통신하는 데에 운영 체제 커널 모드 함수 를 사용한다. 일부 실시예에서, 커널 모드 그래픽 드라이버는 그래픽 프로세서와 통신하여 커맨드 및 명령어를 디스패치한다. IP 코어 구현 적어도 하나의 실시예의 하나 이상의 측면은 프로세서와 같은 집적 회로 내의 로직을 나타내고/거나 정의하는 머신 판독가능 매체(machine-readable medium) 상에 저장된 표상적인(representative) 코드에 의해 구현될 수 있다. 예를 들어, 머신 판독가능 매체는 프로세서 내의 다양한 로직을 나타내는 명령어를 포함할 수 있다. 일부 실시예에서, 머신 판독가능 매체는 또한 본 명세서에서 컴퓨터 판독가능 매체 또는 비 일시적 컴퓨터 판독가능 매체로서 지칭된다. 머신에 의해 판독되는 경우에, 명령어는 머신으로 하여금 본 문서에 기술된 기법을 수행하 는 로직을 제작하게 할 수 있다. \"IP 코어\"로 알려진 그러한 표현은 집적 회로의 구조를 기술하는 하드웨어 모 델로서 유형적인(tangible) 머신 판독가능 매체 상에 저장될 수 있는 집적 회로를 위한 로직의 재사용가능한 유 닛이다. 하드웨어 모델은 집적 회로를 제조하는 제작 머신 상에 하드웨어 모델을 로드하는 다양한 고객 또는 제 조 시설에 공급될 수 있다. 집적 회로는 본 문서에 기술된 실시예 중 임의의 것과 연관되어 기술된 동작을 그 회로가 수행하도록 제작될 수 있다. 도 11a는 실시예에 따라 동작을 수행하는 집적 회로를 제조하는 데에 사용될 수 있는 IP 코어 개발 시스템 을 보여주는 블록도이다. IP 코어 개발 시스템은 더 큰 설계 내에 통합될 수 있는 모듈식의 재사용 가능한 설계를 생성하는 데에 사용되거나 전체 집적 회로(가령, SOC 집적 회로)를 구축하는 데에 사용될 수 있 다. 설계 시설은 고레벨 프로그래밍 언어(가령, C/C++)로 된 IP 코어 설계의 소프트웨어 시뮬레이션 (software simulation을 생성할 수 있다. 소프트웨어 시뮬레이션은 시뮬레이션 모델을 사용 하여 IP 코어의 거동(behavior)을 설계하고 테스트하고 확인하는 데에 사용될 수 있다. 시뮬레이션 모델 은 기능, 거동 및/또는 타이밍(timing) 시뮬레이션을 포함할 수 있다. 그러면 레지스터 전송 레벨(Register Transfer Level: RTL) 설계가 시뮬레이션 모델로부터 생성되거나 합성될 수 있다. RTL 설계(111 5)는 모델링된 디지털 신호를 사용하여 수행되는 연관된 로직을 포함한, 하드웨어 레지스터 간의 디지털 신호의 흐름을 모델링하는 집적 회로의 거동의 추상화이다. RTL 설계에 더하여, 로직 레벨 또는 트랜지스터 레벨 에서의 하위 레벨 설계가 또한 생성되거나 설계되거나 합성될 수 있다. 그러므로, 초기 설계 및 시뮬레이션의 특정한 세부사항은 달라질 수 있다. RTL 설계 또는 균등물은 또한 설계 시설에 의해 하드웨어 모델로 합성될 수 있는데, 이는 하드웨어 서술 언어(Hardware Description Language: HDL)로, 또는 물리적 설계 데이터의 어떤 다른 표현으로 될 수 있 다. HDL은 또한 IP 코어 설계를 확인하기 위해 시뮬레이션되거나 테스트될 수 있다. IP 코어 설계는 비휘발성 메모리(가령, 하드 디스크, 플래시 메모리 또는 임의의 비휘발성 저장 매체)를 사용하여 제3자 제조 시설 로의 전달을 위해 저장될 수 있다. 대안적으로, IP 코어 설계는 유선 연결 또는 무선 연결을 통해서 (가령, 인터넷을 통해) 송신될 수 있다. 이후 제조 시설은 IP 코어 설계에 적어도 부분적으로 기 반하는 집적 회로를 제작할 수 있다. 제작된 집적 회로는 본 문서에 기술된 적어도 하나의 실시예에 따라 동작 을 수행하도록 구성될 수 있다. 도 11b는 본 문서에 기술된 일부 실시예에 따라, 집적 회로 패키지 어셈블리의 횡단면 측면도를 보여준다. 집적 회로 패키지 어셈블리는 본 문서에 기술된 바와 같은 하나 이상의 프로세서 또는 가속화 기 디바이스의 구현을 보여준다. 패키지 어셈블리는 기판(substrate)에 연결된 하드웨어 로직(1172, 1174)의 다수의 유닛을 포함한다. 로직(1172, 1174)은 적어도 부분적으로 구성가능 로직 또는 고정 함수 로직 하드웨어로 구현될 수 있고, 프로세서 코어(들), 그래픽 프로세서(들) 또는 본 문서에 기술된 다른 가속화 기 디바이스 중 임의의 것의 하나 이상의 부분을 포함할 수 있다. 로직(1172, 1174)의 각각의 유닛은 반도체 다 이(semiconductor die) 내에 구현되고 상호연결 구조체를 통해 기판과 커플링될 수 있다. 상호연결 구조체는 로직(1172, 1174) 및 기판 간에 전기적 신호를 라우팅하도록 구성될 수 있고, 범프(bump) 또는 필러(pillar)와 같은, 그러나 이에 한정되지 않는 인터커넥트를 포함할 수 있다. 일부 실시예에서, 상호연 결 구조체는, 예를 들어, 로직(1172, 1174)의 동작과 연관된 입력/출력(Input/Output: I/O) 신호 및/또 는 전력 또는 그라운드(ground) 신호와 같은 전기적 신호를 라우팅하도록 구성될 수 있다. 일부 실시예에서, 기 판은 에폭시(epoxy) 기반 래미네이트(laminate) 기판이다. 기판은 다른 실시예에서 다른 적합한 타 입의 기판을 포함할 수 있다. 패키지 어셈블리는 패키지 인터커넥트를 통해 다른 전기 디바이스에 연결될 수 있다. 패키지 인터커넥트는 다른 전기 디바이스, 예를 들면 마더보드(motherboard), 다른 칩셋, 또는 멀티 칩 모듈에 전기적 신호를 라우팅하도록 기판의 표면에 커플링될 수 있다. 일부 실시예에서, 로직(1172, 1174)의 유닛은 로직(1172, 1174) 간에 전기적 신호를 라우팅하도록 구성된 브릿 지와 전기적으로 커플링된다. 브릿지는 전기적 신호의 길을 제공하는 밀집한 상호연결 구조일 수 있다. 브릿지는 유리 또는 적합한 반도체 소재로 구성된 브릿지 기판을 포함할 수 있다. 로직(1172, 1174) 간의 칩대칩 연결(chip-to-chip connection)을 제공하도록 브릿지 기판 상에 전기적 라우팅 특징부가 형 성될 수 있다. 로직(1172, 1174)의 2개의 유닛 및 브릿지가 예시되나, 본 문서에 기술된 실시예는 하나 이상의 다이 상 에 더 많거나 더 적은 로직 유닛을 포함할 수 있다. 하나 이상의 다이는 0개의 또는 그보다 많은 브릿지에 의해 연결될 수 있으니, 로직이 단일 다이 상에 포함되는 경우에 브릿지는 배제될 수 있다. 대안적으로, 로직 의 다수의 다이 또는 유닛이 하나 이상의 브릿지에 의해 연결될 수 있다. 추가적으로, 3차원 구성을 포함하여, 다른 가능한 구성에서 다수의 로직 유닛, 다이 및 브릿지가 함께 연결될 수 있다. 도 11c는 기판(예를 들어, 베이스 다이)에 연결된 하드웨어 로직 칩렛의 다중 유닛을 포함하는 패키지 어 셈블리를 예시한다. 여기에 설명된 그래픽 처리 디바이스, 병렬 프로세서 및/또는 계산 가속기는 별도로 제조되는 다양한 실리콘 칩렛으로 구성될 수 있다. 이러한 맥락에서, 칩렛은 다른 칩렛과 함께 더 큰 패키지로 조립될 수 있는 별개의 로직 유닛을 포함하는 적어도 부분적으로 패키징된 집적 회로이다. 서로 다른 IP 코어 로직을 가진 다양한(diverse) 칩렛 세트를 단일 장치로 조립할 수 있다. 또한 액티브 인터포저 기술을 사용하여 칩렛을 기본 다이 또는 기본 칩렛에 통합할 수 있다. 여기에 설명된 개념은 GPU 내에서 서로 다른 형태의 IP 간 의 상호연결 및 통신을 가능하게 한다. IP 코어는 다양한 프로세스 기술을 사용하여 제조할 수 있으며 제조 중 에 구성될 수 있고, 이를 통해 특히 여러 플래버(flavor) IP가 있는 대규모 SoC에서 다수의 IP를 동일한 제조 프로세스로 수렴시키는 복잡성을 피할 수 있다. 다수의 프로세스 기술의 사용을 가능하게 하면, 출시 시간을 개 선하고 다수의 제품 SKU를 생성하는 비용 효율적인 방법을 제공한다. 또한 세분화된 IP는 독립적으로 파워 게이 팅되도록 추가 수정될 수 있고 주어진 워크로드에서 사용되지 않는 컴포넌트의 전원을 끌 수 있어, 전체 전력 소비를 줄일 수 있다. 예시적인 하드웨어 로직 칩렛은 특수 목적 하드웨어 로직 칩렛, 로직 또는 I/O 칩렛, 및/또는 메모 리 칩렛을 포함할 수 있다. 하드웨어 로직 칩렛 및 로직 또는 I/O 칩렛은 구성 가능한 로직 또는 고정 함수의 로직 하드웨어에서 적어도 부분적으로 구현될 수 있고, 프로세서 코어(들), 그래픽 프로세서 (들), 병렬 프로세서, 또는 여기에 설명된 다른 가속기 장치 중 임의의 것의 하나 이상의 부분을 포함할 수 있 다. 메모리 칩렛은 DRAM(예를 들어, GDDR, HBM) 메모리 또는 캐시(SRAM) 메모리일 수 있다. 각각의 칩렛은 별도의 반도체 다이로 제조될 수 있고 인터커넥트 구조체를 통해 기판과 커플링될 수 있다. 인터커넥트 구조체는 기판 내의 다양한 칩렛과 로직 사이에서 전기 신호를 라우팅하도록 구성될 수 있다. 인터커넥트 구조체 범프 또는 기둥과 같은 상호연결을 포함할 수 있지만 이에 한정되지 는 않는다. 일부 실시예에서, 인터커넥트 구조체는 예를 들어, 로직, 입력/출력(I/O) 및 메모리 칩렛의 동작과 연관된 입력/출력(I/O) 신호 및/또는 전력 또는 접지 신호와 같은 전기 신호를 라우팅하도록 구성될 수 있다. 일부 실시예에서, 기판은 에폭시 기반 라미네이트 기판이다. 기판은 다른 실시예에서 다른 적절한 유형의 기판을 포함할 수 있다. 패키지 어셈블리는 패키지 인터커넥트를 통해 다른 전기 디바이스 에 연결될 수 있다. 패키지 인터커넥트는 기판의 표면에 커플링되어 전기 신호를 마더보드, 다른칩셋, 또는 멀티-칩 모듈과 같은 다른 전기 디바이스로 라우팅할 수 있다. 일부 실시예에서, 로직 또는 I/O 칩렛 및 메모리 칩렛은 로직 또는 I/O 칩렛과 메모리 칩렛 사이에서 전기 신호를 라우팅하도록 구성된 브리지를 통해 전기적으로 커플링될 수 있다. 브리지 는 전기 신호에 대한 경로를 제공하는 조밀한 인터커넥트 구조일 수 있다. 브리지는 유리 또는 적 절한 반도체 물질로 구성된 브리지 기판을 포함할 수 있다. 로직 또는 I/O 칩렛과 메모리 칩렛 사 이에 칩 대 칩 연결을 제공하기 위해 브리지 기판 상에 전기적 라우팅 특징이 형성될 수 있다. 브리지는 또한 실리콘 브리지 또는 인터커넥트 브리지로 지칭될 수 있다. 예를 들어, 브리지는 일부 실시예에서, EMIB(Embedded Multi-die Interconnect Bridge)이다. 일부 실시예에서, 브리지는 단순히 하나의 칩렛에 서 다른 칩렛으로의 직접 연결부일 수 있다. 기판은 I/O, 캐시 메모리, 및 기타 하드웨어 로직을 위한 하드웨어 컴포넌트를 포함할 수 있다. 패브릭은 기판 내의 다양한 로직 칩렛과 로직(1191, 1193) 사이의 통신을 가능하게 하기 위해 기판에 내장될 수 있다. 일 실시예에서, I/O, 패브릭, 캐시, 브리지 및 기타 하드웨어 로직은 기판의 상부에 적층되는 베이스 다이에 통합될 수 있다. 패브릭은 네트워크 온칩 인 터커넥트 또는 패키지 어셈블리의 컴포넌트 간에 데이터 패킷을 전환하는 다른 형태의 패킷 교환 패브릭이다. 다양한 실시예에서 패키지 어셈블리는 패브릭 또는 하나 이상의 브리지에 의해 상호연결된 더 적거나 더 많은 수의 컴포넌트 및 칩렛을 포함할 수 있다. 패키지 어셈블리 내의 칩렛은 3D 또는 2.5D 배열로 배열될 수 있다. 일반적으로, 브리지 구조체는 예를 들어, 로직 또는 I/O 칩렛과 메모리 칩렛 사 이의 점대점 인터커넥트를 용이하게 하는 데 사용된다. 패브릭은 다양한 로직 및/또는 I/O 칩렛(예를 들 어, 칩렛(1172, 1174, 1191, 1193))을 다른 로직 및/또는 I/O 칩렛과 상호연결하기 위해 사용될 수 있다. 일 실 시예에서, 기판 내의 캐시 메모리는 패키지 어셈블리에 대한 글로벌 캐시, 분산 글로벌 캐시의 일 부, 또는 패브릭에 대한 전용 캐시로서 작용할 수 있다. 도 11d는 일 실시예에 따른 교환 가능한 칩렛을 포함하는 패키지 어셈블리를 도시한다. 교환 가능 한 칩렛은 하나 이상의 베이스 칩렛(1196, 1198) 상의 표준화된 슬롯으로 조립될 수 있다. 베이스 칩렛 (1196, 1198)은 브리지 인터커넥트를 통해 커플링될 수 있으며, 이는 본 명세서에 설명된 다른 브리지 인 터커넥트와 유사할 수 있고, 예를 들어, EMIB일 수 있다. 메모리 칩렛은 브리지 인터커넥트를 통해 로직 또는 I/O 칩렛에 연결될 수도 있다. I/O와 로직 칩렛은 인터커넥트 패브릭을 통해 통신할 수 있다. 기본 칩렛은 각각, 로직, I/O 또는 메모리/캐시 중 하나에 대해 표준화된 형식으로 하나 이상의 슬롯을 지원할 수 있다. 일 실시예에서, SRAM 및 전력 전달 회로는 베이스 칩렛(1196, 1198) 중 하나 이상으로 제조될 수 있으며, 베이 스 칩렛(1196, 1198)은 베이스 칩렛의 상단에 적층되는 교체 가능한 칩렛에 관해 다른 프로세스 기술을 사용하여 제조될 수 있다. 예를 들어, 베이스 칩렛(1196, 1198)은 더 큰 공정 기술을 사용하여 제조될 수 있는 반면, 교환 가능한 칩렛은 더 작은 공정 기술을 사용하여 제조될 수 있다. 교환 가능한 칩렛 중 하나 이 상은 메모리(예를 들어, DRAM) 칩렛일 수 있다. 패키지 어셈블리를 사용하는 제품을 목표로 하는 전력 및 /또는 성능에 기초하여 패키지 어셈블리 마다 다른 메모리 밀도가 선택될 수 있다. 또한, 서로 다른 다수 의 유형의 기능 유닛을 갖는 로직 칩렛은 제품을 목표로 하는 전력 및/또는 성능에 기초하여 조립시 선택될 수 있다. 또한, 상이한 유형의 IP 로직 코어를 포함하는 칩렛은 교체 가능한 칩렛 슬롯에 삽입될 수 있으므로, 서 로 다른 기술의 IP 블록을 혼합하고 일치시킬 수 있는 하이브리드 프로세서 설계가 가능해 진다. 예시적인 시스템 온 칩 집적 회로 도 12 내지 도 13b는 본 문서에 기술된 다양한 실시예에 따라, 하나 이상의 IP 코어를 사용하여 제작될 수 있는 예시적인 집적 회로 및 연관된 그래픽 프로세서를 보여준다. 예시된 것에 더하여, 추가적인 그래픽 프로세서/코 어, 주변기기 인터페이스 컨트롤러, 또는 범용 프로세서 코어를 포함하여, 다른 로직 및 회로가 포함될 수 있다. 도 12는 실시예에 따라, 하나 이상의 IP 코어를 사용하여 제작될 수 있는 예시적인 시스템 온 칩 집적 회로 를 예시하는 블록도이다. 예시적인 집적 회로는 하나 이상의 애플리케이션 프로세서(들)(가 령, CPU), 적어도 하나의 그래픽 프로세서를 포함하며, 이미지 프로세서 및/또는 비디오 프로세서 를 추가적으로 포함할 수 있는데, 이들 중 어떤 것이든 동일한 또는 다수의 상이한 설계 시설(design facilities)로부터의 모듈식 IP 코어일 수 있다. 집적 회로는 USB 컨트롤러, UART 컨트롤러 , SPI/SDIO 컨트롤러 및 I2S/I2C 컨트롤러를 포함하는 주변기기 또는 버스 로직을 포함한다.추가적으로, 집적 회로는 고선명 멀티미디어 인터페이스(High-Definition Multimedia Interface: HDMI) 컨트롤 러 및 모바일 산업 프로세서 인터페이스(Mobile Industry Processor Interface: MIPI) 디스플레이 인터 페이스 중 하나 이상에 커플링된 디스플레이 디바이스를 포함할 수 있다. 플래시 메모리 및 플래시 메모리 컨트롤러를 포함하는 플래시 메모리 서브시스템에 의해 스토리지(storage)가 제공될 수 있다. SDRAM 또는 SRAM 메모리 디바이스로의 액세스를 위해 메모리 컨트롤러를 통해 메모리 인터페이스가 제공 될 수 있다. 몇몇 집적 회로는 임베딩된 보안 엔진을 추가적으로 포함한다. 도 13a 내지 도 13b는 본 문서에 기술된 실시예에 따라, SoC 내에서의 사용을 위한 예시적인 그래픽 프로세서를 보여주는 블록도이다. 도 13a는 실시예에 따라, 하나 이상의 IP 코어를 사용하여 제작될 수 있는 시스템 온 칩 집적 회로의 예시적인 그래픽 프로세서를 보여준다. 도 13b는 실시예에 따라, 하나 이상의 IP 코어를 사 용하여 제작될 수 있는 시스템 온 칩 집적 회로의 추가적인 예시적인 그래픽 프로세서를 보여준다. 도 13a의 그래픽 프로세서는 저전력 그래픽 프로세서 코어의 예이다. 도 13b의 그래픽 프로세서는 더 높은 성능의 그래픽 프로세서 코어의 예이다. 그래픽 프로세서(1310, 1340) 각각은 도 12의 그래픽 프로세서 의 변형일 수 있다. 도 13a에 도시된 바와 같이, 그래픽 프로세서는 정점 프로세서 및 하나 이상의 프래그먼트 프로세 서(들)(1315A-1315N)(가령, 1315A, 1315B, 1315C, 1315D, 내지 1315N-1 및 1315N)를 포함한다. 그래픽 프로세 서는 별개의 로직을 통해 상이한 셰이더 프로그램을 실행할 수 있어서, 정점 프로세서는 정점 셰이 더 프로그램을 위한 동작을 실행하도록 최적화되는 한편, 하나 이상의 프래그먼트 프로세서(들)(1315A-1315N)는 프래그먼트 또는 픽셀 셰이더 프로그램을 위한 프래그먼트(가령, 픽셀) 셰이딩 동작을 실행한다. 정점 프로세서 는 3D 그래픽 파이프라인의 정점 처리 스테이지를 수행하고 프리미티브 및 정점 데이터를 생성한다. 프래 그먼트 프로세서(들)(1315A-1315N)는 디스플레이 디바이스 상에 디스플레이되는 프레임버퍼를 산출하는 데에 정 점 프로세서에 의해 생성된 프리미티브 및 정점 데이터를 사용한다. 하나의 실시예에서, 프래그먼트 프로 세서(들)(1315A-1315N)는 OpenGL API에서 가능케 되는 바와 같이 프래그먼트 셰이더 프로그램을 실행하도록 최 적화되는데, 이는 Direct 3D API에서 가능케 되는 바와 같이 픽셀 셰이더 프로그램으로서 유사한 동작을 수행하 는 데에 사용될 수 있다. 그래픽 프로세서는 하나 이상의 메모리 관리 유닛(Memory Management Unit: MMU)(1320A-1320B), 캐시(들)(1325A-1325B) 및 회로 인터커넥트(들)(1330A-1330B)를 추가적으로 포함한다. 하나 이상의 MMU (들)(1320A-1320B)는, 하나 이상의 캐시(들)(1325A-1325B) 내에 저장된 정점 또는 이미지/텍스처 데이터에 더하 여, 메모리 내에 저장된 정점 또는 이미지/텍스처 데이터를 참조할 수 있는 정점 프로세서 및/또는 프래 그먼트 프로세서(들)(1315A-1315N)를 포함하는 그래픽 프로세서를 위한 가상 대 물리적 어드레스 맵핑 (virtual to physical address mapping)을 가능케 한다. 하나의 실시예에서 하나 이상의 MMU(들)(1320A- 1320B)는, 도 25의 하나 이상의 애플리케이션 프로세서(들), 이미지 프로세서 및/또는 비디오 프로 세서와 연관된 하나 이상의 MMU를 포함하여, 시스템 내의 다른 MMU와 동기화될 수 있어서, 각각의 프로세 서(2505-2520)는 공유된 또는 통일된 가상 메모리 시스템에 참여할 수 있다. 하나 이상의 회로 인터커넥트 (들)(1330A-1330B)은 그래픽 프로세서로 하여금, 실시예에 따라, SoC의 내부 버스를 통해서든 또는 직접 연결을 통해서든, SoC 내의 다른 IP 코어와 인터페이스할 수 있게 한다. 도 13b에 도시된 바와 같이, 그래픽 프로세서는 도 13a의 그래픽 프로세서의 하나 이상의 MMU (들)(1320A-726B), 캐시(들)(1325A-1325B) 및 회로 인터커넥트(들)(1330A-1330B)를 포함한다. 그래픽 프로세서 는 하나 이상의 셰이더 코어(1355A-1355N)(가령, 1355A, 1355B, 1355C, 1355D, 1355E, 1355F, 내지 1355N-1 및 1315N)를 포함하는데, 이는 정점 셰이더, 프래그먼트 셰이더 및/또는 계산 셰이더를 구현하는 셰이 더 프로그램 코드를 포함하는 모든 타입의 프로그램 가능 셰이더 코드를 단일 코어 또는 단일 타입의 코어가 실 행할 수 있는 통일된 셰이더 코어 아키텍처를 가능케 한다. 존재하는 셰이더 코어의 정확한 수는 실시예 및 구 현 간에 달라질 수 있다. 추가적으로, 그래픽 프로세서는 코어간 태스크 관리기(inter-core task manager)를 포함하는데, 이는, 예를 들어 장면 내의 로컬 공간 일관성(local spatial coherence)를 이용 하기 위해 또는 내부 캐시의 사용을 최적화하기 위해, 장면을 위한 렌더링 동작이 이미지 공간 내에서 세분된 타일 기반 렌더링을 위한 타일링(tiling) 동작을 가속화하는 타일링 유닛 및 하나 이상의 셰이더 코어 (1355A-1355N)에 실행 스레드를 디스패치하는 스레드 디스패처로서 작동한다. 일부 실시예에서, 처리 리소스는 여기에 설명된 GPU의 그래픽 프로세서 또는 그래픽 프로세서 구조(예를 들어, 병렬 처리 유닛, 그래픽 처리 엔진, 멀티 코어 그룹, 계산 유닛, 다음으로 그래픽 코어의 계산 유닛)와 연관된 처리 요소(예를 들어, GPGPU 코어, 광선 추적 코어, 텐서 코어, 실행 리소스, 실행 유닛(EU), 스트림 프로세서,스트리밍 멀티프로세서(SM), 그래픽 멀티프로세서)를 나타낸다. 예를 들어, 처리 리소스는, 그래픽 멀티프로세 서의 GPGPU 코어 또는 텐서/레이 트레이싱 코어 중 하나; 그래픽 멀티프로세서의 레이 트레이싱 코어, 텐서 코 어 또는 GPGPU 코어; 그래픽 멀티프로세서의 실행 자원; 멀티 코어 그룹의 GFX 코어, 텐서 코어 또는 레이 트레 이싱 코어 중 하나; 계산 유닛의 벡터 로직 유닛 또는 스칼라 로직 유닛 중 하나; EU 어레이 또는 EU 어레이가 있는 실행 장치; 실행 로직의 실행 유닛; 및/또는 실행 유닛일 수 있다. 처리 리소스는 또한 예를 들어, 그래픽 처리 엔진, 처리 클러스터, GPGPU, GPGPU, 그래픽 처리 엔진, 그래픽 처리 엔진 클러스터, 및/또는 그래픽 처리 엔진 내의 실행 리소스일 수 있다. 처리 리소스는 또한 그래픽 프로세서 내의 처리 리소스, 그래픽 프로세서, 및/또는 그래픽 프로세서일 수 있다. 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 연산자 지원 병렬 컴퓨팅은 많은 계산 또는 프로세스 실행이 동시에 수행되는 계산 유형이다. 병렬 컴퓨팅은 SIMD 또는 SIMT 를 포함하지만 이에 한정되지 않는 다양한 형태로 나타날 수 있다. SIMD는 다수의 데이터 포인트에서 동시에 동 일한 작업을 수행하는 다수의 처리 요소가 있는 컴퓨터를 설명한다. 일 예에서, 위에서 논의된 5a-5b는 EU, FPU 및 ALU 측면에서 SIMD 및 일반 프로세서에서의 SIMD 구현을 참조한다. 일반적인 SIMD 머신에서, 데이터는 각각 채널 어레이를 포함하는 레지스터로 패키징된다. 명령어는 다른 레지스터의 동일한 채널에서 찾은 데이터와 함 께 레지스터의 채널 n에서 찾은 데이터에 대해 동작한다. SIMD 머신은 단일 명령어 시퀀스가 많은 양의 데이터 에 동시에 적용될 수 있는 영역에서 유리한다. 예를 들어, 일 실시예에서, 그래픽 프로세서(예, GPGPU, GPU 등)는 계산 셰이더 프로그램을 사용하여 SIMD 벡터 작업을 수행하는 데 사용될 수 있다. 다양한 실시예는 SIMD 사용에 대한 대안으로서 또는 SIMD 사용에 추가하여 SIMT(Single Instruction Multiple Thread)를 사용하여 실행을 사용하는 데에도 적용될 수 있다. SIMD 코어 또는 연산(operation)에 대한 참조는 SIMT에도 적용되거나 SIMT와 커플링하여 SIMD에 적용될 수 있다. 다음 설명은 SIMD 머신 측면에서 논의된다. 그 러나, 본 명세서의 실시예는 SIMD 컨텍스트에서의 애플리케이션에만 제한되지 않고, 예를 들어 SIMT와 같은 다 른 병렬 컴퓨팅 패러다임에 적용될 수 있다. 논의와 설명의 편의를 위해, 다음 설명은 일반적으로 SIMD 구현에 중점을 둔다. 그러나, 실시예는 설명된 기술 및 방법론에 대한 수정 없이 SIMT 머신에 유사하게 적용될 수 있다. 시스톨릭 어레이에 명령어를 제공하고 SIMT 머신에서 명령어를 실행하기 위해 SIMT 머신과 관련하여 아래 에 설명된 유사한 패턴이 뒤따를 수 있다. 다른 유형의 병렬 컴퓨팅 머신도 마찬가지로 여기에서 실시예를 활용 할 수 있다. 다양한 실시예는 행렬 가속 회로로 GPGPU를 구현할 수 있다. 이러한 행렬 가속 회로는 머신 러닝(ML) 연산 가속 에 활용될 수 있다. 도 14는 일 실시예에 따른 데이터 처리 시스템의 블록도이다. 여기에서 논의된 다양한 실시예는 데이터 처리 시스템과 같은 시스템에서 구현될 수 있다. 데이터 처리 시스템은 프로세서, 통합 메모 리, 및 머신 러닝 가속 로직을 포함하는 GPGPU를 갖는 이종 처리 시스템이다. 프로세서 및 GPGPU는 본 명세서에 설명된 바와 같은 프로세서 및 GPGPU/병렬 프로세서 중 임의의 것일 수 있다. 프로 세서는 시스템 메모리에 저장된 컴파일러에 대한 명령어를 실행할 수 있다. 컴파일러 는 프로세서 상에서 실행되어 소스 코드(1414A)를 컴파일된 코드(1414B)로 컴파일한다. 컴파일된 코드 (1414B)는 프로세서에 의해 실행될 수 있는 명령어 및/또는 GPGPU에 의해 실행될 수 있는 명령어를 포함할 수 있다. 컴파일 중에, 컴파일러는 컴파일된 코드(1414B)에 존재하는 데이터 평행성의 레벨에 관 한 힌트 및/또는 컴파일된 코드(1414B)에 기초하여 디스패치될 스레드와 연관된 데이터 지역성에 관한 힌트를 포함하여, 메타데이터를 삽입하기 위한 연산을 수행한다. 컴파일러가 이러한 연산을 수행하는 데 활용되 는 정보를 포함할 수 있거나, 연산은 런타임 라이브러리의 도움으로 수행될 수 있다. 런타임 라이브러리 는 또한 소스 코드(1414A)의 컴파일에서 컴파일러를 지원할 수 있고 또한 GPGPU에서 컴파일 된 명령어의 실행을 용이하게 하는 컴파일된 코드(1414B)와 함께 런타임 시 링크된 명령어를 포함할 수 있다. 통합 메모리는 프로세서 및 GPGPU에 의해 액세스될 수 있는 통합 어드레스 공간을 나타낸다. 통합 메모리는 시스템 메모리 및 GPGPU 메모리를 포함할 수 있다. GPGPU 메모리는 GPGPU의 어드레스 페이스(pace) 내의 메모리이고 시스템 메모리의 일부 또는 전부를 포함할 수 있 다. 일 실시예에서 GPGPU 메모리는 또한 GPGPU의 사용 전용인 임의의 메모리의 적어도 일부를 포함 할 수 있다. 일 실시예에서, 시스템 메모리에 저장된 컴파일된 코드(1414B)는 GPGPU에 의한 액세스 를 위해 GPGPU 메모리에 매핑될 수 있다. GPGPU는 다수의 계산 블록(1424A-1424N)을 포함하고, 여기에 설명된 다양한 계산 유닛들 또는 실행 요소 중 하나 이상을 포함할 수 있다. 일 실시예에서, GPGPU는 행렬 연산(예를 들어, 내적 등)의 서브세트를 가속하도록 설계된 하나 이상의 특수 함수 계산 유닛을 포함할 수 있는, 행렬 가속기를 추가로 포함한다. GPGPU는 또한 레지스터, 전력 및 성능 모듈, 및 캐시의 세트를 포함하지만 이에 한정 되지 않는, 행렬 가속기 및 계산 블록(1424A-1424N)에 의해 공유될 수 있는 리소스 세트를 포함할 수 있 다. 일 실시예에서 레지스터는 직접 및 간접적으로 액세스 가능한 레지스터를 포함하며, 여기서 간접적으 로 액세스 가능한 레지스터는 행렬 가속기에 의한 사용을 위해 최적화된다. 전력 및 성능 모듈은 계산 블록(1424A-1424N) 내의 게이트 유휴 컴포넌트에 전력을 공급하기 위해 계산 블록(1424A-1424N)에 대한 전 력 전달 및 클록 주파수를 조정하도록 구성될 수 있다. 다양한 실시예에서, 캐시는 명령어 캐시 및/또는 하위 레벨 데이터 캐시를 포함할 수 있다. GPGPU는 행렬 가속기 및/또는 계산 블록(1424A-1424N) 내의 계산 요소에 의해 통합 메모리로부터 액세스되는 데이터를 캐시하는 데 사용될 수 있는, L3 데이터 캐시를 추가로 포함할 수 있다. 일 실시예에서, L3 데이터 캐시는 계산 블록(1424A-1424N) 및 행렬 가속기 내의 계산 요소에 의해 공유될 수 있는 공유 로컬 메모리를 포함한다. 일 실시예에서, GPGPU는 페치 및 디코드 유닛(여기에서 디코더와 같은 디코더로도 지칭됨) 및 스케줄러 컨트롤러와 같은 명령어 처리 로직을 포함한다. 페치 및 디코드 유닛은 계산 블록 (1424A-1424N) 또는 행렬 가속기 중 하나 이상에 의한 실행을 위한 명령어를 페치 및 디코딩하기 위한 페 치 유닛 및 디코드 유닛을 포함한다. 명령어는 스케줄러 컨트롤러를 통해 행렬 가속기 또는 계산 블록 (1424A-1424N) 내의 적절한 기능 유닛에 스케줄링될 수 있다. 일 실시예에서, 스케줄러 컨트롤러는 고급 스케줄링 동작을 수행하도록 구성 가능한 ASIC이다. 일 실시예에서 스케줄러 컨트롤러는 펌웨어 모듈로부 터 로딩된 스케줄러 명령어를 실행할 수 있는 마이크로컨트롤러 또는 명령어당 저에너지 처리 코어(low energy- per-instruction processing core)이다. 일 실시예에서, 계산 블록(1424A-1424N)에 의해 수행될 일부 기능은 행렬 가속기로 직접 스케줄링되거나 또는 오프로드될 수 있다. 다양한 실시예에서, 행렬 가속기는 3D 그래픽 또는 계산 셰이더 프로그램에서 사용되는 곱하기 및 더하기 연산 및 내적 연산과 같은 행렬 계산 연산을 효율적으로 수행하도록 구성된 처리 요 소 로직을 포함한다. 일 실시예에서, 행렬 가속기는 머신 러닝 프레임워크에 의해 사용되는 연산을 가속 화하도록 구성될 수 있다. 일 실시예에서, 행렬 가속기는 특정 세트의 병렬 행렬 곱셈 및/또는 덧셈 연산 을 수행하도록 명시적으로 구성된 애플리케이션 특정 집적 회로이다. 일 실시예에서, 행렬 가속기는 워크 로드 간에 업데이트될 수 있는 고정 함수 로직을 제공하는 FPGA(field programmable gate array)이다. 행렬 가 속기에 의해 수행될 수 있는 행렬 연산들의 세트는 계산 블록(1424A-1424N)에 의해 수행될 수 있는 연산 들에 비해 제한될 수 있다. 그러나, 행렬 가속기는 계산 블록(1424A-1424N)에 비해 상당히 더 높은 처리 량으로 이러한 연산을 수행할 수 있다. 실시예에서, 도 14의 데이터 처리 시스템은 도 14는 인공지능(AI) 및 머신 러닝(ML) 분야의 응용에 활용 될 수 있다. 이러한 분야의 발전으로 ML 모델은 신경망 트레이닝을 위해 저 정밀도 산술을 활용할 수 있게 되었 다. 기존 트레이닝 플랫폼은 고성능 시스톨릭 어레이 구현에서 IEEE-754 부동 소수점 16(FP16) 및 뇌 부동 소수 점 16(bfloat16 또는 BF16) 데이터 형식을 지원한다. 그러나 최근에는 8비트 부동 소수점 데이터 형식과 같은 더 낮은 정밀도 데이터 형식을 사용하여 심층 신경망 트레이닝을 지원하기 위한 발전이 이루어졌다. 그러한 8비 트 부동 소수점 데이터 형식 중 하나는 bfloat8 또는 BF8이다. BF8은 1개의 부호 비트, 5개의 지수 비트 및 2개 의 가수 비트의 이진 형식을 갖는다. 일부 경우에, BF8 형식을 활용하면 FP16 또는 BF16 구현과 비교하여, 신경 망의 트레이닝 처리량이 최대 2배 향상될 수 있다. 그러나 기존 시스템은 BF8 피연산자와 같은 8비트 부동 소수 점 피연산자를 사용하여 연산을 수행하기 위한 하드웨어 지원을 제공하지 않는다. 여기에서 실시예는 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자에 대한 지원을 제공함으로써 위에서 언급한 결점을 해결한다. 일 구현에서, 여기에서 논의된 8비트 부동 소수점 형식은 BF8 형식이다. 실시예는 컴 퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하기 위한 다양한 기술을 도입한다. 실시예의 한 기 술은 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산이다. 실시예의 다른 기술은 부동 소수 점 데이터를 8비트 부동 소수점 형식 데이터로 또는 그로부터 변환하는 것이다. 실시예의 다른 기술은 부동 소 수점 형식 데이터 값에 대해 효율적인 확률적 반올림을 수행하는 것이다. 실시예의 다른 기술은 하이브리드 부 동 소수점 시스톨릭 연산이다. 실시예의 추가 기술은 8비트 부동 소수점 형식 피연산자로 혼합 모드 연산을 수 행하는 것이다. 본 명세서의 실시예의 기술은 아래에서 더 상세히 설명된다. 8비트 부동 소수점 입력 피연산자에서 시스톨릭 내적 누산 실시예는 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산을 제공한다. 이전에 논의된 바와 같이, 기존의 트레이닝 플랫폼은 고성능 시스톨릭 어레이 구현에서 IEEE-754 FP16 및 BFLOAT16 데이터 형식을 지원한다. 이러한 데이터 형식은 시스톨릭 내적 누산(DPAS) 엔진에서도 지원된다. 위에 서 언급했듯이 심층 신경망은 8비트 부동 소수점 데이터 형식(BFLOAT8 또는 BF8, 이진 형식=1s-5e-2m)을 사용하 여 트레이닝될 수 있다. BFLOAT8은 FP16 및 BFLOAT16 구현에 비해 트레이닝 처리량에서 최대 2배 개선을 제공할 수 있다. 그러나 BFLOAT8 숫자 형식을 사용하는 시스톨릭 내적 연산을 지원하는 알려진 기존 솔루션이 존재하지 않는다. 실시예는 BF8 데이터 형식을 지원하기 위해 DPAS(내적 누산 시스톨릭) 엔진에 대한 확장을 제공한다. 구현에서 는 3개의 입력 피연산자 c += a*b에 대해 행렬 내적을 수행하기 위한 명령어를 제공하고, 여기서 a 및 b 행렬은 BF8 데이터 유형이다. 또한, 실시예는 상기 명령어를 페치, 디코딩 및 실행하기 위한 하드웨어 회로를 제공한다. 일부 구현에서, 내적의 누산 결과는 32비트(FP32) 또는 16비트(FP16, BF16) 부동 소수점으로 반환될 수 있다. 실시예는 시스톨릭 계산 밀도 및 처리량 증가, 데이터 이동 비용 감소(BF8이 16비트 데이터 형식에 비 해 대역폭 및 캐시/레지스터 공간의 절반을 사용하기 때문), 혼합 정밀도 BFLOAT8 트레이닝을 가능하게 하여 트 레이닝 가속화의 기술적 이점을 제공한다. 실시예는 내적을 지원하고, 8비트 부동 소수점(예: BF8) 데이터 형식으로 제공된 입력 인수에 대한 연산을 누산 하기 위한 DPAS 명령어를 제공한다. 도 15는 실시예에 따른 BFLOAT8(BF8) 이진 형식을 예시하는 블록도이 다. BF8 이진 형식 은 부호, 지수, 가수 비트로 표시된다. 부호 비트는 1비트, 지수는 5비트, 가수는 2비트이다. 5비트 지수는 6.1e-05와 5.7344e+04 사이의 정규 부동 소 수점 값을 나타낼 수 있는 15의 오프셋 값을 사용한다. BF8 이진 형식은 동적 범위를 표현 가능한 최소 값인 1.5e-05까지 확장하는 준정규(subnormal) 값도 지원한다. 도 16은 실시예에 따른, 명령어 파이프라인에 의해 수행되는 시스톨릭 DP 8비트 FP 형식 연산을 예 시하는 블록도이다. 명령어 파이프라인은 내적 연산과 같으나 이에 제한되지 않는 시스톨릭 DP 8비트 포 맷 연산을 수행하도록 구성될 수 있다. 두 벡터의 내적은 벡터의 해당 컴포넌트의 곱(product)의 합과 같 은 스칼라 값이다. 내적은 아래 수학식 과 같이 계산할 수 있다."}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "내적은 합성곱 신경망(convolutional neural network, CNN)과 같은 신경망에 대한 합성곱 연산에 사용될 수 있 다. 하드웨어 명령어를 가속화하는 데 사용되는 명령어 파이프라인은 하드웨어 명령어를 페치 및 디코딩할 수 있는 명령어 페치 및 디코드 유닛, 및 디코딩된 명령어를 계산 블록(1424A-1424N)(집합적으로 계산 블 록으로 지칭됨) 및/또는 행렬 가속기 내의 하나 이상의 실행 유닛에 스케줄링할 수 있는 컨트롤러 유닛(가령, 스케줄러 컨트롤러)을 포함할 수 있다. 명령어 파이프라인은 또한 시스톨릭 DP 8 비트 형식 연산의 하드웨어 명령어로 인코딩된 8비트 FP 형식에 따라 입력 데이터를 계산 블록 및/ 또는 행렬 가속기로 라우팅하기 위해 멀티플렉서(mux)의 집합과 같은 선택 회로를 포함할 수 있다. 일 실시예에서, 하드웨어 명령어는 계산 블록으로 스케줄링되고 행렬 가속기로 오프로드될 수 있다. 시스톨릭 DP 8비트 FP 형식 연산을 수행하기 위한 하나 이상의 하드웨어 명령어 및 연관 데이터가 메모리에 저장될 수 있다. 하드웨어 명령어의 출력은 또한 메모리에 저장될 수 있다. 메모리(165 0)는 도 14에서와 같이 시스템 메모리, GPGPU 메모리, 또는 하나 이상의 캐시 메모리(1427, 143 0)를 포함하여, 여기에서 설명된 임의의 메모리일 수 있다. 일부 실시예에서, 메모리는 하나 이상의 레지 스터 파일일 수 있다. 일 실시예에서, 행렬 가속기는 시스톨릭 어레이 회로를 사용하여 시스톨릭 DP 8-비트 형식 연산 을 수행하기 위해 하나 이상의 하드웨어 명령어를 실행할 수 있다. 시스톨릭 어레이 회로는 내적 연산을 수행하도록 구성된, 프로그램 가능 및 고정 함수 하드웨어의 조합을 포함할 수 있다. 계산 블록 내의 기능 유닛이 내적 연산을 수행하도록 구성될 수도 있지만, 시스톨릭 어레이 회로는 계산 블록(142 4)에 비해 상당히 높은 처리량으로 내적 연산의 제한된 서브세트를 수행하도록 구성될 수 있다.본 명세서의 실시예에서, DPAS 명령어는 시스톨릭 내적을 수행하고 레지스터 파일로부터 8비트 부동 소수점 형 식(가령, BF8) 소스 피연산자에 대한 연산을 누산하고, 선택된 정밀도(fp32, fp16, bf16)에서 결과를 누산하며, 최종 출력을 레지스터 파일에 재기입하도록 제공된다. 시스톨릭 DP 8비트 형식 연산을 수행하기 위한 이 러한 DPAS 명령어는 c += a*b를 계산하기 위해 3개의 입력 피연산자를 받아들이며, 여기서 'a' 및 'b' 피연산자 는 BF8과 같은 8비트 FP 유형이다. 지원되는 입력 및 출력 피연산자의 일부 조합이 다음과 같다."}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "DPAS는 BFLOAT8 입력(src1 x src2)이 있는 시스톨릭 파이프라인에서의 곱셈 덧셈 및 누산 연산이다. 시스톨릭 파이프라인의 각 FMA(fused multiply-accumulate) 단계는 시스톨릭 어레이 회로의 32비트 SIMD 채널을 나타내고 src1 및 src2로부터 각각 4개의 입력 요소(예: dp4a 연산)에 대해 DPAS 연산을 수행한다. dst 및 src0 은 IEEE754 float 또는 half-float 피연산자를 허용하고 src0은 시스톨릭 어레이의 이전 DPAS 반복에서 누산된 출력을 포함한다. 실시예는 dp4a, dp2a(block = 2), dp8a(block = 8), dp32a(block = 32) 등을 포함하지만 이 에 제한되지 않는 블록 정규화 기술의 임의의 반복을 활용할 수 있다. 각 블록 정규화 기술은 고유한 장점(예: 개선된 영역 효율성)과 단점(예: 정확도 손실)과 연관된다. 구현된 특정 블록 정규화 기술은 사용된 특정 애플 리케이션에 기초할 수 있다.'sdepth' 매개변수는 연산의 시스톨릭 깊이를 나타내며, 이는 이러한 'sdepth' 연산 의 시퀀스가 연속적인 레지스터에 걸쳐 진행하면서(advancing) 수행됨을 의미한다. 각 단계의 출력은 다음 시스 톨릭 단계에 대한 누산 입력이 될 32비트 정밀도로 유지된다. dst 및 src0 인수는 IEEE-754 float, half-float 또는 bfloat16 데이터 유형을 허용할 수 있으며, 이전에 누산된 결과는 소스 레지스터(src0)를 통해 명령어에 전달된다. 최종 누산 출력은 목적지 데이터 형식(destination data format)으로 변환되어 목적지 레지스터(ds t)에 기록된다. 'rcount' 매개변수는 작업의 반복 횟수이고, 이는 즉, dst 및 src0이 연속 레지스터를 진행하고 src1이 동일하게 유지되며 src2가 32개 요소를 진행하여, dpas 명령어의 'rcount' 수가 생성되는 것을 의미한다. 실시예에서, 누산기 피연산자 'c'는 FP32, FP16 또는 BF16일 수 있다. 시스톨릭 어레이 회로 하드웨어는 입력에서 준정규 값(즉, DAZ=0)을 지원해야 한다. 실시예에서, 입력 준정규 값은 시스톨릭 어레이 회로의 제1 스테이지에 공급되기 전에 그리드 상에서 상향 변환 및 정규화될 수 있다. 일부 구현에서, 입력 인수 'c'를 통해 전달되는 부분 합은 시스톨릭 체인의 끝에서 누산되어 내부 정규화 및 덧 셈 연산으로 인한 정밀도 손실을 최소화할 수 있다. 시스톨릭 체인의 끝에서 누산기 입력 인수('c')의 이러한 누산을 \"지연 누산(late accumulate)\"이라고 한다. 시스톨릭 어레이의 각 단계에서 내부 합가 누산되고 가장 가 까운 값으로의 반올림(오사오입)을 사용하여 FP32 값으로 반올림된다. 일부 실시예에서, 누산기 입력 인수('c) 의 누산은 시스톨릭 체인의 제1 스테이지에서 발생할 수 있거나 시스톨릭 체인의 임의의 중간 스테이지(들)에서 발생할 수 있다. 도 17a는 실시예에 따른 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산을 수행하기 위한 시 스톨릭 어레이 회로를 예시하는 블록도이다. 일 실시예에서, 도 17a에 도시된 8비트 부동 소수점 형식 입 력 피연산자에서의 시스톨릭 누산은 예시적인 dp4a 연산이다. 일 구현에서, 시스톨릭 어레이 회로는 도 16과 관련하여 설명된 시스톨릭 어레이 회로와 동일하다. 시스톨릭 어레이 회로는 내적 연산을 수 행하도록 구성 가능한 프로그램 가능 및 고정 함수 하드웨어의 조합을 포함할 수 있다. 시스톨릭 어레이 회로 의 회로 및 요소의 다른 변형 및 조합이 구현될 수 있으며 본 명세서에 예시된 것으로 제한되지 않는다. 도 17a는 시스톨릭 어레이 회로의 하나의 예시적인 아키텍처를 제공하고, 본 명세서에서 논의되는 8비트 부동 소수점 형식 입력 피연산자 연산에 대한 시스톨릭 내적 누산을 제공하기 위해 다른 아키텍처가 구현될 수 있다. 시스톨릭 어레이 회로의 각 FMA 유닛은 src1 및 src2 레지스터로부터의 4쌍의 BF8 입력 값에 대해 벡터 내적 연산(예: 4-요소 벡터 내적 연산(dp4a))을 수행한다. 일 실시예에서, 각각의 FMA 유닛은 승산기(1710a- 1710d) 및 시프터(1715b-1715d) 쌍의 조합, 뿐만 아니라 가산기를 포함한다. 제3 입력 레지스터(src0)는 이전의 내적 반복으로부터 부분적으로 누산된 합을 포함한다. 시스톨릭 어레이에서 함께 연결된 이러한 여러 FMA 유닛은 아래에서 추가 설명하는 것처럼 DPAS 연산을 수행할 수 있다. 시스톨릭 어레이 구현은 이러한 개별 FMA 유닛을 효율적인 설계를 위한 가능한 모든 순서로 연결할 수 있고, 누산 순서는 문제가 되지 않는다.본 명세서의 실시예에서, 시스톨릭 어레이 회로는 BF8 입력(예를 들어, DAZ = 0)에 대한 준정규 값을 지 원해야 한다. 이것은 입력 지수를 확장하고 그리드에서 준정규 입력 값을 정규화하여 획득될 수 있다. 곱셈은 정밀도 손실 없이, 예를 들어 4비트 승산기(1710a-1710d 및 1730a-1730d)를 사용하여 수행될 수 있다. 승산기 (1710a-1710d 및 1730a-1730d)의 출력은 각 승산기 이후에 32비트 시프터 (1715a-1715e 및 1735a-1735e)와 같 은 시프터를 사용하여 정규화될 수 있다. 시프터(1715a-1715e, 1735a-1735e)가 32비트 시프터로 도시되지만, 본 명세서의 실시예에서 시프터(1715a-1715e, 1735a-1735e)는 어떠한 임의의 정밀도일 수 있다. 예를 들어, 큰 블 록 크기 32를 갖는 블록 정규화 연산이 활용되는 경우, 시프터(1715a-1715e, 1735a-1735e)는 48비트까지 성장할 수 있다. 이와 같이, 32비트 시프터(1715a-1715e, 1735a-1735e)가 예시 목적으로 도시되어 있지만, 실시예는 특 정 32비트 시프터 크기로 제한되지 않으며 시프터(1715a-1715e, 1735a-1735e)는 임의의 어떠한 임의의 정밀도일 수 있다. 시프터(1715a-1715e, 1735a-1735e)로부터의 정규화된 곱 출력은 5-웨이 FP32 가산기(1720, 1740)와 같은 가산 기에서 함께 가산되고, FP32 출력을 생성하기 위해 가장 가까운 것으로 반올림을 사용하여 반올림된다. 일부 실 시예에서, 5-웨이 FP32 가산기는 정규화를 위해 선택된 블록 크기에 기초한 N-방향 가산기 트리(여기서 N은 구 성 가능함)일 수 있다. 실시예에서, FP32 중간 결과(예를 들어, 가산기(1720, 1740)에서)에 대한 임의의 준정규 값은 각각의 이후에 0으로 플러시된다. 이전에 논의된 바와 같이, 시스톨릭 어레이 회로는 지연 누산을 구현할 수 있다. 지연 누산의 경우, src0 는 FP32 가산기와 같은 최종 가산기에서 시스톨릭 체인의 말단에서 누산된다. 이와 같이, 시스톨릭 어레 이 회로의 제1 스테이지(예: '깊이 0')에 대한 'c' 값은 0이다. 지연 누산은 누산 출력의 수치적 정확도 손실을 방지하고 작업 부하 레벨 정확도에서 향상된 성능을 제공할 수 있다. 이전에 논의된 바와 같이, 일부 실 시예에서 누산기 입력 인수('c)의 누산은 시스톨릭 체인의 제1 스테이지에서 발생할 수 있거나 시스톨릭 체인의 임의의 중간 스테이지(들)에서 발생할 수 있다. 지연 누산 후의 최종 출력(예를 들어, dest(FP32))은 가장 가까운 짝수(RNE)로의 반올림을 사용하여 가산 기에 의해 목적지 정밀도로 반올림된다. 시스톨릭 어레이 회로의 구현은 몇 가지 예를 들자면, FP32, FP16 및 BF16을 포함하는 다중 출력 형식을 지원할 수 있다. 일부 실시예에서, 가산기의 최종 출력 상의 준정규 값은 출력이 FP32 또는 BF16이면 0으로 플러시된다. 일부 실시예에서, 준정규 값은 FP16 출력에서 지원된다. 도 17b는 실시예에 따른 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산을 수행하기 위한 시 스톨릭 어레이 회로를 예시하는 블록도이다. 일 실시예에서, 시스톨릭 내적은 도 17b에 도시된 8비트 부 동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산은 예시적인 dp2a 연산이고, 이는 2-요소 벡터 내적 연산이다. 일 구현에서, 시스톨릭 어레이 회로는 도 16과 관련하여 설명된 시스톨릭 어레이 회로와 동일하다. 시스톨릭 어레이 회로는 내적 연산을 수행하도록 구성 가능한 프로그램 가능 및 고정 함수 하 드웨어의 조합을 포함할 수 있다. 시스톨릭 어레이 회로의 회로 및 요소의 다른 변형 및 조합이 구현될 수 있으며 여기에 예시된 것으로 제한되지 않는다. 도 17b는 시스톨릭 어레이 회로의 하나의 예시적인 아 키텍처를 제공하고, 여기에서 논의된 바와 같이 8비트 부동 소수점 형식 입력 피연산자 연산에 대한 시스톨릭 내적 누산을 제공하기 위해 다른 아키텍처가 구현될 수 있다. 시스톨릭 어레이 회로의 각 FMA 유닛은 src1 및 src2 레지스터로부터의 4쌍의 BF8 입력 값에 대해 벡터 내적 연산(예: 2-요소 벡터 내적 연산(dp2a))을 수행한다. 일 실시예에서, 각각의 FMA 유닛은 재바이어스 및 정 규화 회로(1760a-1760h), 승산기(1770a-1770d), 및 가산기(1780a-b, 1785a-b)의 조합을 포함한다. 제3 입력 레 지스터(src0)에는 이전 내적 반복의 부분 누산 합계가 포함된다. 시스톨릭 어레이에서 함께 연결된 이러한 다수 의 FMA 유닛은 아래에서 추가 설명하는 것처럼 DPAS 연산을 수행할 수 있다. 시스톨릭 어레이 구현은 이러한 개 별 FMA 유닛을 효율적인 설계를 하게 하는 가능한 모든 순서로 연결할 수 있고, 누산 순서는 문제가 되지 않는 다. 여기의 실시예에서, 시스톨릭 어레이 회로는 BF8 입력(예를 들어, DAZ = 0)에 대한 준정규 값을 지원해야 한다. 이것은 입력 지수를 확장하고 그리드에서 준정규 입력 값을 정규화하여 달성될 수 있다. 재바이어스 및 정규화 회로(18760a-1760h)는 들어오는 피연산자(src1(BF8) 및 src2(BF8))를 모두 8비트 FP 형식과 해당 준정 규 값(예를 들어, DAZ=0)을 모두 수용할 수 있는 공통 이진 형식(예: FP32)으로 변환할 수 있다. 곱셈은 정밀도 손실 없이, 예를 들어 FP32 승산기(1770a-1770d)를 사용하여 수행될 수 있다. 승산기(410a- 410d)의 출력은 FP32 가산기(1780a, 1780b) 및 FP32 가산기(1785a, 1785b)에 의해 제공되는 가산기 트리와 같은 가산기 트리(예: 선택된 블록 크기에 기초한 N-웨이 가산기 트리)에서 함께 합산될 수 있고, 가장 가까운 것 (RNE)으로의 반올림을 사용하여 반올림하여 FP32 출력을 생성한다. 실시예에서, FP32 중간 결과(예를 들어, 가 산기(1780a-b, 1785a-b)에서)에 대한 임의의 비정상 값은 각각 이후에 0으로 플러시된다. 이전에 논의된 바와 같이, 시스톨릭 어레이 회로는 지연 누산(late accumulation)을 구현할 수 있다. 지 연 누산의 경우, src0은 FP32 가산기(1790, 1795)에서 제공하는 것과 같은 최종 가산기 트리에서 시스톨릭 체인 의 말단에서 누산된다. 따라서 시스톨릭 어레이 회로의 제1 스테이지에 대한 'c' 값(예: '깊이 0')은 0이 다. 지연 누산은 누산 출력의 수치적 정확도 손실을 방지하고 작업 부하 레벨 정확도에서 향상된 성능을 제공할 수 있다. 이전에 논의된 바와 같이, 일부 실시예에서, 누산기 입력 인수('c)의 누산은 시스톨릭 체인의 제1 스 테이지에서 발생할 수 있거나 시스톨릭 체인의 임의의 중간 스테이지(들)에서 발생할 수 있다. 지연 누산 후의 최종 출력(예를 들어, dest(FP32))은 가산기에 의해 가장 가까운 짝수(RNE)로의 반 올림을 사용하여 목적지 정밀도로 반올림된다. 시스톨릭 어레이 회로의 구현은 몇 가지 예를 들자면, FP32, FP16 및 BF16을 포함하는 다수의 출력 형식을 지원할 수 있다. 실시예에서, 가산기의 최종 출력 상 의 비정상 값은 출력이 FP32 또는 BF16이면 0으로 플러시된다. 일부 실시예에서, 준정규 값은 FP16 출력에서 지 원된다. 다음은 실시예에 따른 8비트 부동 소수점 형식 입력 피연산자(가령, BF8 피연산자)에 대한 시스톨릭 내적 누산 을 구현하기 위한 예시적인 의사 코드(pseudo code)이다. if (Input is sNaN){ output Quietized_NaN(input); } else if (Input is qNaN){ output destination qNaN } else if (Input is Inf){ output destination Inf } else { Step 1: Upconvert inputs, normalize subnormals. Step 2: dpas(); Step 3: Convert FP32 value to destination format, round to RNE. Step 4: Flush output subnormals to zero }"}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "dpas() { // x[i], y[i] are the 8bits from Src1 and Src2 registers and Acc is the 32bits float // CLOCK 0: For the first module ACC = 0 Temp1 = RNE (x0[0] * y0[0] + x0[1] * y0[1]); Temp2 = RNE (x0[2] * y0[2] + x0[3] * y0[3]); ACC = RNE (Temp1 + Temp2); // CLOCK 1 : ACC from the previous stage is added here Temp1 = RNE (ACC + x1[0] * y[0] + x1[1] * y1[1]); Temp2 = RNE (x1[2] * y1[2] + x1[3] * y1[3]); ACC = RNE (Temp1 + Temp2); . . . // After sdepth multiply accumulate operations // Late accumulate, input Src0 is added at the end Dst = RNE (Src0 + ACC); } 도 18a는 본 명세서에 설명된 실시예에 따른, 시스톨릭 어레이 회로에 의해 실행 가능한 누산 명령어를 갖는 내적을 예시한다. 도 18a는 8비트 부동 소수점 형식 입력 피연산자에 대해 동작하고 실시예에 의해 제공되 는 시스톨릭 행렬 로직에 의해 실행 가능한 누산 명령어를 갖는 내적의 필드를 예시한다. 도 18a는 실행될 때 시스톨릭 행렬 가속기가 8비트 부동 소수점 형식 입력 피연산자(예를 들어, BF8 피연산자)에 대한 누산으로 내 적을 실행하게 하는 누산 명령어를 갖는 내적의 필드를 예시한다. 일 실시예에서, 명령어는 연산 코드 필드, 시스톨릭 깊이(sdepth), 반복 카운트(rcount), 및 목적지, 제0 소스 (src0), 제1 소스(srcl) 및 제2 소스(src2)를 지정하기 위한 피연산자 필드를 포함한다. 연산 코드 필드는 실행 로직에 대한 명령어를 식별하는 연산 코드를 지정할 수 있다. 일 실시예에 서, 연산 코드 필드는 인에이블될 때 명령어가 행렬 가속기(예를 들어, 행렬 가속기)에 의해 실행 될 것임을 나타내는 하나 이상의 비트를 포함한다. 일 실시예에서, 연산 코드 필드는 또한 명령어 가 행렬 가속기 내의 내적 로직(예를 들어, 시스톨릭 어레이 회로)과 같은 특수 목적 내적 로직에 의해 실행되도록 지정하는 하나 이상의 비트를 포함할 수 있다. 시스톨릭 깊이(sdepth)는 입력 데이터를 처리하는 데 사용할 시스톨릭 계층 수를 지정하는 데 사용될 수 있다. 일 실시예에서 시스톨릭 깊이는 즉치값(immediate value)으로 제공될 수 있다. 반복 카운트 (rcount)는 dst 및 src0이 연속 레지스터를 진행하고, src1은 동일하게 유지되고, src2는 N 요소(여기서 N은 목적지 형식)를 진행하여 생성되는 dpas 명령어의 수를 지정하는 데 사용될 수 있다. 목적지, 제0 소스(src0), 제1 소스(src1), 및 제2 소스(1814(src2))는 계산이 기록될 목적 지 및 소스 데이터가 검색될 수 있는 위치를 지정하는 데 사용될 수 있다. 일 실시예에서, 목적지는 데이 터가 기록될 레지스터를 지정할 수 있다. 일 실시예에서 목적지는 스칼라 레지스터일 수 있지만, 일부 실 시예에서 목적지는 또한 다수의 채널로부터의 출력을 저장하는 벡터 레지스터일 수 있다. 제0 소스, 제1 소스 및 제2 소스는 소스 데이터의 하나 이상의 채널을 포함하는 레지스터 또는 즉치값일 수 있으 며, 각 채널은 시스톨릭 어레이 회로에 의해 처리될 4개의 요소를 가진다. 일부 실시예에서, 예시된 것 이외의 추가 필드가 존재할 수 있다. 예를 들어, 일 실시예에서 소스 피연산자의 수치적 수정을 지정하는 소스 수정자 필드(source modifier field)가 존재한다. 소스 피연산자의 각 데이터 요 소 값은 실행 파이프라인으로 전달되기 전에 선택적으로 그 절대값을 취하고/취하거나 부호를 반전시킬 수 있다. 절대값 수정자를 부정 수정자보다 먼저 적용하여 보장된 음수 값을 생성할 수 있다. 일 실시예에서, 목적 지 포화를 제어하기 위해 사용될 수 있는 포화 필드가 존재한다. 포화(saturation)가 인에이블되면, 목적지 레 지스터에 대한 출력 데이터가 포화된다. 특정 포화 연산은 목적지 데이터 유형에 따라 다르다. 포화는 데이터 유형의 포화 목표 범위 밖에 있는 모든 데이터를 목표 범위와 가장 가까운 표현 값으로 변환하는 동작이다. 도 18b는 일 실시예에 따른 프로그램 코드 컴파일 프로세스를 도시한다. 일 실시예에서, 소프트웨어 프로 그램의 소스 코드 레벨 설명은 다중 레벨의 컴파일을 포함할 수 있는 컴파일러에서 처리 로직에 의 해 수행될 8비트 내적을 포함하거나 지정하는 연산을 갖는 레벨로 컴파일된다. 연산은 중간 언어로 지정된 작업일 수 있거나 머신 러닝 프레임워크에 의해 제공되는 프리미티브와 같은 계산 프레임워크의 프리미 티브를 참조하는 프로그램 코드일 수 있다. 8비트 내적을 포함하거나 지정하는 연산은 다음으로 추가 컴 파일러에 의해 추가로 컴파일될 수 있고, 추가 컴파일러는 설명된 행렬 연산을 위한 가속기에 의해 수행될 8비트 내적 명령어를 포함하는 머신 레벨 객체 코드로 셰이더 컴파일러일 수 있다. 도 19는 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산을 위한 명령어를 실행하기 위한 방 법의 실시예를 예시하는 흐름도이다. 방법은 하드웨어(예를 들어, 회로, 전용 로직, 프로그램 가능 로직 등), 소프트웨어(가령, 처리 디바이스에서 실행되는 명령어), 또는 이들의 조합을 포함할 수 있는 처리 로 직에 의해 수행될 수 있다. 방법의 프로세스는 표현의 간결함과 명확성을 위해 선형적 순서로 예시되어 있 으나, 이들 중 임의의 수는 병렬로, 비동기식으로 또는 다른 순서로 수행될 수 있는 것으로 고려된다. 또한, 간 결함, 명확성 및 이해의 용이함을 위해, 도 1 내지 도 18과 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후 에 반복되거나 논의되지 않을 수 있다. 일 구현에서, 도 14의 데이터 처리 시스템과 같은 데이터 처리 시 스템은 방법을 수행할 수 있다. 방법은 단일 명령어가 GPGPU 내에서 실행되도록 페치 및 디코딩될 수 있는 처리 블록에서 시작한다. 일 구현에서, 단일 명령어는 8비트 부동 소수점 형식 피연산자에 대해 연산하여 GPGPU가 병렬 내적 연산(parallel dot product operation)을 수행하게 할 수 있는 디코딩된 행렬 명령어로 디코딩된다. 처리 블록 에서, 하나 이상의 8비트 부동 소수점 형식 피연산자(가령, BF8 피연산자)를 사용하여 행렬 가속기에서 디코딩된 행렬 명령어를 실행하도록 파이프라인 커맨드 세트가 결정된다. 후속적으로, 처리 블록에서, 파이프라인 커맨드의 세트는 시스톨릭 내적 파이프라인에 스케줄링되어 하나 이상의 8비트 부동 소수점 형식 피연산자를 사용하여 디코딩된 행렬 명령어를 실행한다. 마지막으로, 처리 블록 에서, 디코딩된 행렬 명령어는 파이프라인 커맨드 세트의 완료에 응답하여 리타이어(retire)된다. 도 20은 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산을 위한 방법의 실시예를 예시 하는 흐름도이다. 방법은 하드웨어(예를 들어, 회로, 전용 로직, 프로그램 가능 로직 등), 소프트웨어(가 령, 처리 디바이스에서 실행되는 명령어), 또는 이들의 조합을 포함할 수 있는 처리 로직에 의해 수행될 수 있 다. 방법의 프로세스는 표현의 간결함과 명확성을 위해 선형적 순서로 설명되나, 이들 중 임의의 수는 병 렬로, 비동기식으로 또는 다른 순서로 수행될 수 있는 것으로 고려된다. 또한, 간결함, 명확성 및 이해의 용이 함을 위해 도 1 내지 도 19와 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후에 반복되거나 논의되지 않을 수 있다. 일 구현에서, 도 16의 시스톨릭 어레이 회로와 같은 시스톨릭 어레이 또는 도 17의 시스톨릭 어 레이 회로가 방법을 수행할 수 있다. 방법은 명령어에 대한 소스 값 및 계산 깊이가 GPGPU의 행렬 연산 가속기에 의해 실행되도록 페치되는 처 리 블록에서 시작한다. 일 구현에서, 소스 값은 8비트 부동 소수점 형식 피연산자(가령, BF8 피연산자)이 다. 처리 블록에서, 4비트 승산기를 사용하여 소스 입력 요소의 요소별 승산에 기초하여 곱 세트(a set of products)가 생성된다. 처리 블록에서, 승산기 출력은 각 승산기에 대해 32비트 시프터를 사용하여 정규화된다. 그 다음, 처리 블록에서, 정규화된 승산기 출력 세트의 합이 계산되고 합은 가장 가까운 짝수로 반올림된다. 마지막으로, 처리 블록에서, 행렬 연산 가속기의 마지막 깊이 계층에서, 정규화된 승산기 출력 세트와 초 기 누산기 값의 합이 계산된다. 그런 다음, 합은 오사오입 반올림을 사용하여 목적지 출력 정밀도로 반올림된다. 부동 소수점 데이터를 8비트 부동 소수점 형식으로 또는 그 반대로 변환 여기에서 실시예는 부동 소수점 데이터를 8비트 부동 소수점 형식 데이터로 또는 그로부터 변환하는 것을 제공 한다. 이전에 논의된 바와 같이, 딥 러닝의 발전은 ML 모델이 신경망을 트레이닝하기 위해 저 정밀도 산술을 활용할 수 있게 했다. 기존 트레이닝 플랫폼은 고성능 시스톨릭 어레이 구현에서 IEEE-754 FP16 및 BFLOAT16 데이터 형 식을 지원한다. 이러한 구현은 고 정밀도 누산기를 사용하여 내적 계산의 긴 체인 동안 정확도 손실을 방지한다. 신경망 내에서, 이러한 고 정밀도 출력은 이들이 입력으로서 다음 층으로 송신될 수 있기 전에, 층의 후처리 동안 저 정밀도 형식으로 반올림되어야 한다. 예를 들어, 신경망에 대한 기존 하드웨어 구현은 FP32에서 FP16 및 BF16으로의 반올림을 지원한다. 위에서 언급한 바와 같이, 8비트 FP 형식 데이터(가령, BFLOAT8, 1s-5e-2m)는 트레이닝 및 추론 성능을 향상시 킬 수 있다. BFLOAT8 FMA의 하드웨어 구현은 숫자 정확도를 유지하기 위해 FP32 또는 FP16 누산기를 사용할 수 있다. 그러나 기존 시스템에는 후처리 중에 FP32 또는 FP16 FMA 출력을 BFLOAT8로 반올림하기 위한 하드웨어 지 원이 없다. 기존 시스템은 이 반올림 연산을 수행하기 위해 시퀀스 산술 및 비트 명령어를 사용하는 더 느린 소 프트웨어 구현을 제공할 수 있다. 예를 들어, 이러한 기능은 일련의 산술, 비트 및 비교 명령어를 사용하여 소 프트웨어에서 에뮬레이트될 수 있다. 이러한 느린 소프트웨어 구현은 심층 신경망 트레이닝에 자주 사용되는,작고 불규칙한 커널에 대한 성능 저하를 초래한다. 실시예는 부동 소수점 데이터를 8비트 부동 소수점 형식 데이터로 변환하기 위한 명령어를 제안한다. 일 구현에 서, 실시예의 변환 명령어는 오사오입(nearest-to-even rounding)으로 IEEE-754 FP32 및 FP16에서 BFLOAT8로 하향 변환을 수행한다. 일 구현에서, 실시예의 변환 명령어는 BFLOAT8 메모리 형식으로 혼합 정밀도 계산 연산 을 용이하게 하기 위해 BFLOAT8에서 FP32 및 FP16으로 상향 변환을 수행한다. 실시예는 부동 소수점 데이터를 8비트 부동 소수점 형식 데이터로 변환하기 위한 명령어 및 하드웨어 솔루션을 제공한다. 본 명세서의 실시예의 명령어 및 하드웨어 기술은 긴 명령어 시퀀스를 프로그래머에 의해 사용될 수 있는 단일 명령어로 대체한다. 이로 인해 신경망에서 불규칙한 커널 연산에 대한 성능이 향상될 수 있다. 실시 예는 또한 신경망의 트레이닝 처리량을 가속화할 수 있는 혼합 정밀도 8비트 부동 소수점 형식(예를 들어, BFLOAT8) 트레이닝을 가능하게 한다. 도 21은 실시예에 따른 명령어 파이프라인에 의해 수행되는 8비트 FP 형식 변환 동작을 나타내는 블록도이다. 명령어 파이프라인은 8비트 FP 형식 변환 동작을 수행하도록 구성될 수 있다. 명령어 파이프라인은 하드웨어 명령어를 가속화하는데 사용될 수 있으며, 하드웨어 명령어를 페치 및 디코딩할 수 있는 명령어 페치 및 디코드 유닛, 및 계산 블록(1424A-1424N)(집합적으로 계산 블록으로 지칭 됨) 및/또는 행렬 가속기 내의 하나 이상의 실행 유닛에 디코딩된 명령어를 스케줄링할 수 있는 컨트롤러 유닛(가령, 스케줄러 컨트롤러)을 포함할 수 있다. 명령어 파이프라인은 또한, 8비트 FP 형 식 변환 연산의 하드웨어 명령어에 인코딩된 8비트 FP 형식에 따라, 입력 데이터를 계산 블록 및/ 또는 행렬 가속기로 라우팅하기 위해 멀티플렉서(mux)의 집합과 같은 선택 회로를 포함할 수도 있 다. 일 실시예에서, 하드웨어 명령어는 계산 블록으로 스케줄링될 수 있고/있거나 행렬 가속기로 오프 로드될 수 있다(예를 들어, 시스톨릭 어레이 회로를 사용한 계산을 위해). 8비트 FP 형식 변환 동작 을 수행하기 위한 하나 이상의 하드웨어 명령어 및 연관 데이터가 메모리에 저장될 수 있다. 하드 웨어 명령어의 출력은 또한 메모리에 저장될 수 있다. 메모리는 도 14에서와 같이 시스템 메모리 , GPGPU 메모리, 또는 하나 이상의 캐시 메모리(1427, 1430)를 포함하여, 본 명세서에 설명된 임의 의 메모리일 수 있다. 일 실시예에서, 계산 블록은 처리 유닛을 사용하여 8비트 FP 형식 변환 동작을 수행하기 위 해 하나 이상의 하드웨어 명령어를 실행할 수 있다. 처리 유닛은 8비트 FP 형식 변환 연산을 수행하도록 구성될 수 있는 프로그램 가능한 고정 함수 하드웨어의 조합을 포함할 수 있다. 일부 구현에서, 처리 유닛 은 벡터 처리 유닛(VPU)일 수 있다. 일부 구현에서, 처리 유닛은 부동 소수점 유닛(FPU)일 수 있다. 처리 유닛은 변환 회로, RNE(round-to Nearest) 반올림 회로, 및 특수 처리 회로 를 포함할 수 있다. 실시예에서, 8비트 FP 형식 변환 작업을 수행하기 위한 하드웨어 명령어는 IEEE-754 FP32 또는 FP16 데이 터와 BFLOAT8 형식 간의 데이터 변환을 제공한다. 데이터 변환은 FP32/FP16에서 8비트 FP 형식(예: BF8)으로의 하향 변환 또는 8비트 FP 형식(예: BF8)에서 FP32/FP16으로의 상향 변환을 포함할 수 있다. 위에서 논의된 도 15는 실시예의 8비트 FP 형식으로서 활용될 수 있는 예시적인 BF8 이진 형식을 도시한다. BFLOAT8 이진 형식은 부호, 지수 및 가수 비트로 표현된다. 5비트 지수는 6.1e-05와 5.7344e+04 사이의 정규 부동 소수점 값을 나타 낼 수 있는 15의 오프셋 값을 사용한다. 이 형식은 동적 범위를 표현 가능한 최소 값인 1.5e-05까지 확장하는 준정규 값도 지원한다. FP32 또는 FP16에서 BF8로 하향 변환할 때, 값은 오사오입(RTNE) 프로세스를 사용하여 반올림된다. FP32 또는 FP16로부터 변환하는 두 경우 모두 준정규 값이 지원된다. BF8에서 FP16 또는 FP32로 상향 변환할 때, 8비트 FP 형식(BF8) 지수 값은 적절하게 조정되고 가수는 0으로 확장된다. 실시예에서, 변환 회로는 위에서 설명된 변환 프로세스를 수행하기 위해 프로그램 가능 및 고정 함수 하 드웨어를 포함할 수 있다. RNE 반올림 회로는 변환된 데이터의 RNE 반올림을 수행하기 위해 프로그램 가 능하고 고정 함수 하드웨어를 포함할 수 있다. 특수 처리 회로는 예를 들어, 언더플로, 오버플로 또는 비 정규(de-normals)와 같은 데이터를 변환 및/또는 반올림할 때 마주치는 코너 케이스를 처리하는 프로그램 가능 및 고정 함수 하드웨어를 포함할 수 있다. 일부 구현에서, 여기에 설명된 8비트 FP 형식 데이터의 변환을 위한 명령어는 다음 형태를 취할 수 있다. mov dst, src0 변환 회로가 FP32/FP16에서 BF8로 하향 변환할 때, 명령어는 출력에 대해 준정규 값을 유지해야 한다. 일 부 실시예에서, 특수 처리 회로는 오버플로를 초래하는 포화 거동을 제공할 수 있다(즉, 큰 값이 BF8_MAX 로 포화되지 않음). RNE 반올림 회로는 오사오입(round-to-nearest-even) 프로세스를 사용하여 가수를 반 올림해야 한다. FP32 또는 FP16에서 BF8로 하향 변환을 수행할 때 8비트 FP 형식 데이터를 변환하기 위한 명령 어의 일부 구현 예는 다음과 같다. mov <bf8>, <fp32> mov <bf8>, <fp16> 변환 회로가 FP32/FP16에서 BF8로 상향 변환될 때, 지수 값은 재조정되고 값은 재정규화된다. 가수 비트 는 LSB 비트에서 0으로 확장된다. BF8에서 FP32 또는 FP16으로 상향 변환을 수행할 때 8비트 FP 형식 데이터 변 환을 위한 명령어의 일부 구현 예는 다음과 같다. mov <fp32>, <bf8> mov <fp16>, <bf8> 도 22a는 본 명세서에 설명된 실시예들에 따른, 처리 유닛에 의해 실행가능한 명령어를 예시한다. 도 22a 는 실시예에 의해 제공된 VPU 또는 FPU와 같은 처리 유닛에 의해 실행 가능하며 8비트 부동 소수점 형식 입력 피연산자를 변환하기 위한 mov 명령어의 필드를 예시한다. 도 22a는 mov 명령어의 필드를 예시하며, 이는 실행될 때 처리 유닛으로 하여금 mov 명령어를 실행하여 8비트 부동 소수점 형식 입력 피연산자(예를 들어, BF8 피연산자)로 또는 그로부터 변환하도록 한다. mov 명령어는 이의 제2 피연산자가 참조하는 데이터 항목(예: 레 지스터 콘텐츠, 메모리 콘텐츠 또는 상수 값)을 이의 제1 피연산자(즉, 레지스터 또는 메모리)가 참조하는 위치 에 복사한다. 일 실시예에서, 명령어는 목적지 및 소스(src)를 지정하기 위한 연산 코드 필드 및 피 연산자 필드를 포함한다. 연산 코드 필드는 실행 로직에 대한 명령어를 식별하는 연산 코드를 지정할 수 있다. 일 실시예에 서, 연산 코드 필드는 인에이블될 때 명령어가 계산 블록(예를 들어, 계산 블록)의 처리 유닛에 의 해 실행될 것임을 나타내는 하나 이상의 비트를 포함한다. 목적지 및 소스(src)는 계산이 기록되는 목적지 및 소스 데이터가 검색될 수 있는 위치를 지정하는 데 사용될 수 있다. 일 실시예에서 목적지는 데이터가 기록될 레지스터를 지정할 수 있다. 일 실시예에서 목적지는 스칼라 레지스터일 수 있지만, 일부 실시예에서 목적지는 또한 다중 채널로부터의 출력을 저장 하는 벡터 레지스터일 수 있다. 소스(src)는 소스 데이터의 하나 이상의 채널을 포함하는 레지스터 또는 즉치값일 수 있다. 일부 실시예에서, 예시된 것 이외의 추가 필드가 존재할 수 있다. 예를 들어, 일 실시예에서, 소스 피연산자의 수치적 수정을 지정하는 소스 수정자 필드가 존재한다. 소스 피연산자의 각 데이터 요소 값은 실행 파이프라인 으로 전달되기 전에 선택적으로 절대값을 취하거나 부호를 반전시킬 수 있다. 절대값 수정자를 부정 수정자 (negate modifier)보다 먼저 적용하여 보장된 음수 값을 생성할 수 있다. 일 실시예에서, 목적지 포화를 제어하 기 위해 사용될 수 있는 포화 필드가 존재한다. 포화가 인에이블되면, 목적지 레지스터에 대한 출력 데이터가 포화된다. 특정 포화 동작은 목적지 데이터 유형에 따라 다르다. 포화는 데이터 유형의 포화 목표 범위 밖에 있 는 모든 데이터를 목표 범위와 가장 가까운 표현 값으로 변환하는 동작이다. 도 22b는 일 실시예에 따른 프로그램 코드 컴파일 프로세스를 도시한다. 일 실시예에서, 소프트웨어 프로 그램의 소스 코드 레벨 설명은 다수의 레벨의 컴파일을 포함할 수 있는 컴파일러에서 처리 로직에 의해 수행될 8비트 FP 형식 변환 명령어를 포함하거나 지정하는 연산을 갖는 레벨로 컴파일된다. 연산 은 중간 언어로 지정된 작업일 수 있거나 머신 러닝 프레임워크에서 제공하는 프리미티브와 같은 계산 프 레임워크의 프리미티브를 참조하는 프로그램 코드일 수 있다. 8비트 FP 형식 변환 명령어를 포함하거나 지정하 는 연산은 셰이더 컴파일러일 수 있는 추가 컴파일러에 의해, 본 명세서에 기술된 바와 같이, 계산 블록의 처리 유닛(예를 들어, VPU, FPU)에 의해 수행될 8비트 FP 형식 변환 명령어를 포함하는 머신 레벨 객체 코드로 추가로 컴파일될 수 있다. 다음은 실시예에 따라 부동 소수점 데이터를 8비트 부동 소수점 형식 데이터(가령, BF8 피연산자)로 또는 그로 부터 변환하는 것을 구현하기 위한 예시적인 의사 코드이다. float src; bf8 dst; If (src == NaN) return Quieted_NaN; If (src == Inf) return Inf; If (src == 0.0) return 0.0; src_sm = convert_to_sign_magnitude_format(src); src_sm = apply_IEEE754_RNE (src_sm); If (src_sm > dest_max_val) /* saturation */ dst = inf If (src_sm < dest_min_val) /* dest_min_val smallest BF8 subnormal */ dst = 0.0 return dst 도 23은 부동 소수점 데이터를 8비트 부동 소수점 형식 데이터로 변환하기 위한 명령어를 실행하기 위한 방법 의 실시예를 예시하는 흐름도이다. 방법은 하드웨어(예를 들어, 회로, 전용 로직, 프로그램 가능 로직 등), 소프트웨어(가령, 처리 디바이스에서 실행되는 명령어), 또는 이들의 조합을 포함할 수 있는 처리 로 직에 의해 수행될 수 있다. 방법의 프로세스는 표현(presentation)의 간결함과 명확성을 위해 선형적 순 서로 예시되고, 그러나 이들 중 임의의 수는 병렬로, 비동기식으로 또는 다른 순서로 수행될 수 있는 것으로 고 려된다. 또한, 간결함, 명확성 및 이해의 용이함을 위해, 도 1 내지 도 22와 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후에 반복되거나 논의되지 않을 수 있다. 일 구현에서, 도 23의 데이터 처리 시스템과 같은 데이터 처리 시스템은 방법을 수행할 수 있다. 방법은 단일 명령어가 GPGPU 내에서 실행되도록 페치 및 디코딩되는 처리 블록에서 시작한다. 일 구현에서, 단일 명령어는 GPGPU가 피연산자의 8비트 부동 소수점 형식으로/로부터의 변환을 수행하게 하도록 디 코딩된 명령어로 디코딩된다. 처리 블록에서, GPGPU의 계산 블록에 대해 디코딩된 벡터 명령어를 실행하 기 위한 커맨드의 세트가 결정된다. 처리 블록에서, 커맨드 세트는 8비트 부동 소수점 형식으로/로부터 피연산자의 변환을 수행하기 위한 디 코딩된 명령어 실행하도록 GPGPU의 계산 블록으로 스케줄링된다. 그 다음, 처리 블록에서, 커맨드 세트의 완료에 응답하여 디코딩된 명령어가 리타이어된다. 도 24는 부동 소수점 데이터를 8비트 부동 소수점 포맷 데이터로 변환하기 위한 방법의 실시예를 예시하 는 흐름도이다. 방법은 하드웨어(예: 회로, 전용 로직, 프로그램 가능 로직 등), 소프트웨어(가령, 처리 디바이스에서 실행되는 명령어) 또는 이들의 조합을 포함할 수 있는 처리 로직에 의해 수행될 수 있다. 방법 의 프로세스는 표현의 간결함과 명확성을 위해 선형적 순서로 예시되나, 이들 중 임의의 수는 병렬로, 비 동기식으로 또는 다른 순서로 수행될 수 있는 것으로 고려된다. 또한, 간결함, 명확성 및 이해의 용이함을 위해, 도 1 내지 23과 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후에 반복되거나 논의되지 않을 수 있다. 일 구현에서, 도 21의 처리 유닛과 같은 처리 유닛이 방법을 수행할 수 있다. 방법은 명령어에 대한 소스 값이 GPGPU의 계산 블록에 의해 실행되도록 페치되는 처리 블록에서 시 작한다. 일 구현에서, 소스 값은 다른 데이터 형식으로 변환되고 소스 값은 8비트 부동 소수점 형식 피연산자 중 적어도 하나이거나, 8비트 부동 소수점 형식 피연산자로 변환될 것이다. 결정 블록에서, 소스 값이 0, 무한대 또는 NaN(not-a-number)인지 여부가 결정된다. 그렇다면, 방법은 처리 블록으로 진행하고, 여기서 소스 값은 특별한 사용 사례 값(예를 들어, 0, 무한대 등)으로서 목적지에 반환된다. 결정 블록에서, 소스 값이 0, 무한대 또는 NaN이 아니면, 방법은 소스 값이 리스케일링, 정규화 및 변환에 의해 목적지의 부호 크기 형식으로 변환되는 처리 블록으로 진행한다. 그 다음, 처리 블록에서, 오사오입 반올림 프로세스가 변환된 소스 값에 적용된다. 결정 블록에서, 오버플로, 언더플로 또는 비정규 조건이 발생했는지 여부가 결정된다. 발생했다면, 방법 은 변환되고 반올림된 소스 값이 특별 사용 사례 값(예를 들어, 0, 무한대 등)으로서 반환되는 처리 블록 으로 진행한다. 한편, 오버플로, 언더플로, 또는 비정규 조건이 발생하지 않은 경우, 방법은 처리 블록으로 진행하고, 여기서 변환되고 반올림된 소스 값이 목적지 값으로서 반환된다. 부동 소수점 형식 데이터 값에 대한 효율적인 확률적 반올림 수행 실시예는 부동 소수점 형식 데이터 값에 대해 효율적인 확률적 반올림을 수행하기 위해 제공된다. 딥 러닝 트레이닝이 8비트 부동 소수점 형식(예: BF8, 1s-5e-2m)으로 이동함에 따라 정밀도 손실로 인해 도입된 숫자 오류는 ML 모델 수렴에 상당한 영향을 미칠 수 있다. 정밀도 손실을 보상하는 방법 중 하나는 FP32 또는 FP16 누산 FMA 출력을 입력으로서 신경망의 다음 계층에 전달하기 전에 BF8로 변환할 때 '반올림'을 사용하는 것이다. 그러나, 내적 연산의 긴 사슬에 걸쳐 누산된 반올림 오류는 심층 신경망 트레이닝에 사용되는 반복 솔버 (solver)의 수치적 안정성에도 문제가 된다. 이 문제는 머신 엡실론 'ε'(=0.125)이 FP16(=4.88e-04) 및 BF16(=3.90e-03)에 비해 BF8에 대해 더 크기 때문에 낮은 정밀도에서 악화된다. 다중 작업 부하에 걸쳐 BF8 데이터 형식을 사용할 때 확률적 반올림은 반올림 오류의 누산을 줄이고 수렴을 달 성하는 데 도움이 될 수 있다. 확률적 반올림은 비결정적이며, 확률 1에서 해당 숫자에 대한 상대 거리를 뺀, 다음의 더 크거나 작은 부동 소수점 숫자로 실수를 반올림하는 반올림 프로세스를 나타낸다. 확률적 반올림을 위한 완전한(full-fledged) 하드웨어 지원에는 구축 및 검증에 비용이 많이 드는 부동 소수점 의사 난수 생성기 가 포함된다. 그러나, 심층 신경망 러닝의 맥락에서, 딥 러닝 트레이닝은 난수 생성기에 대한 제약이 적고 솔버(solver)의 수 치적 안정성에 영향을 미치지 않으면서 난수를 자주 재사용할 수 있다. 감소된 난수 생성기 제약에 기초하여, 실시예는 소프트웨어에서 생성 및 관리되는 저 정밀도 난수 비트(예: FP16->BF8의 경우 8비트 및 FP32->FP16의 경우 16비트)를 사용하여 확률적 반올림을 가속화하기 위한 하드웨어 및 명령어의 조합을 제공한다. 여기의 실시예는 산술 연산의 더 높은 정밀도의 출력이 더 낮은 정밀도 형식(예: BF8(1s-5e-2m), HF8(1s4e3m), FP16 및 BF16 부동 소수점 형식)으로 변환할 때 확률적 반올림 연산을 적용하기 위한 하나 이상의 명령어를 제 공한다. 이러한 명령어는 더 높은 정밀도의 하나 또는 두 개의 소스 피연산자와 소프트웨어 기반의 의사 난수 생성기(PRNG)에 의해 생성된 정수 난수를 포함하는 제3 입력 피연산자를 포함할 수 있다. 일부 구현에서, PRNG 소프트웨어는 xoroshiro128++ 또는 등가물과 같은 저렴한 PSNR 알고리즘을 사용할 수 있다. 출력은 명령어에 지 정된 목적지 데이터 형식으로 저장된다. 본 문서의 실시예의 명령어 및 하드웨어는 신경망 트레이닝 성능의 속도와 효율성을 향상시키기 위해 프로그래 머가 사용할 수 있는 단일 명령으로 광범위한 명령어 시퀀스를 대체하는 기술적 이점을 제공한다. 실시예는 또 한 PRNG를 반올림 연산으로부터 분리하여 하드웨어의 복잡성을 감소시키면서 프로그래머가 난수를 생성 및 관리 (캐싱 및 재사용)하기 위한 알고리즘을 사용할 수 있게 한다. 더욱이, 실시예는 신경망 트레이닝의 속도 및 효 율성을 향상시키기 위해 BFLOAT8 혼합 정밀도 트레이닝의 역전파를 가속화한다. 도 25는 실시예에 따른 명령어 파이프라인에 의해 수행되는 확률적 반올림 연산을 갖는 8비트 FP 형식 변환을 예시하는 블록도이다. 명령어 파이프라인은 확률적 반올림 연산으로 8비트 FP 형식 변 환을 수행하도록 구성될 수 있다. 명령어 파이프라인은 하드웨어 명령어를 가속화하기 위해 사용될 수 있 고, 하드웨어 명령어를 페치 및 디코딩할 수 있는 명령어 페치 및 디코드 유닛과, 계산 블록(1424A- 1424N)(집합적으로 계산 블록으로 지칭됨) 및/또는 행렬 가속기 내의 하나 이상의 실행 유닛에 디 코딩된 명령어를 스케줄링할 수 있는 컨트롤러 유닛(가령, 스케줄러 컨트롤러)을 포함할 수 있다. 명령어 파이프라인은 확률적 반올림 연산을 사용한 8비트 FP 형식 변환의 하드웨어 명령어에 인코 딩된 8비트 FP 형식에 따라, 입력 데이터를 계산 블록 및/또는 행렬 가속기로 라우팅하기 위해 멀 티플렉서(mux)의 집합과 같은 선택 회로를 포함할 수도 있다. 일 실시예에서, 하드웨어 명령어는 계산 블록으로 스케줄링될 수 있고/있거나 행렬 가속기로 오프 로드될 수 있다(예를 들어, 시스톨릭 어레이 회로를 사용한 계산을 위해). 확률적 반올림 연산으로 8비트 FP 형식 변환을 수행하기 위한 하나 이상의 하드웨어 명령어 및 연관 데이터가 메모리에 저장될 수있다. 하드웨어 명령어의 출력은 또한 메모리에 저장될 수 있다. 메모리는 시스템 메모리, GPGPU 메모리, 또는 도 14에서와 같은 하나 이상의 캐시 메모리(1427, 1430)를 포함하는 본 명세서에 설 명된 임의의 메모리일 수 있다. 일 실시예에서, 계산 블록은 처리 유닛을 사용하여 확률적 반올림 연산으로 8비트 FP 형식 변환을 수행하기 위해 하나 이상의 하드웨어 명령어를 실행할 수 있다. 처리 유닛은 확률적 반올림 연산 으로 8비트 FP 형식 변환을 수행하도록 구성가능한, 프로그램 가능 및 고정 함수 하드웨어의 조합을 포함할 수 있다. 일부 구현에서, 처리 유닛은 벡터 처리 유닛(VPU)일 수 있다. 일부 구현에서, 처리 유닛은 부동 소수점 유닛(FPU)일 수 있다. 처리 유닛은 변환 회로, 확률적 반올림 회로, 및 특수 처 리 회로를 포함할 수 있다. 실시예에서, 확률적 반올림 연산으로 8비트 FP 형식 변환을 수행하라는 명령어는 더 높은 정밀도의 부동 소수점 에서 더 낮은 정밀도의 부동 소수점으로의 변환 동안 확률적 반올림을 수행할 수 있다. 명령어는 다음 형식을 취할 수 있다. srnd dest, src0, src1 명령어에서 src0은 고 정밀도 부동 소수점 입력을 포함하는 소스 피연산자이고, src1은 반올림 하드웨어에서 사 용되는 무작위 정수를 포함한다. 무작위 정수는 xoroshiro128++와 같은 PRNG 알고리즘을 사용하는 소프트웨어에 의해 생성된다. 반올림 연산의 출력은 명령어 연산 코드에서 지정한 저 정밀도의 부동 소수점 형식으로 dst에 반환된다. 변환 회로에 의해 수행되는 변환 동안, src0의 정규화된 부호 크기 표현이 생성된다. 변환 회로는 변환 프로세스를 수행하기 위한 프로그램 가능 및 고정 함수 하드웨어를 포함할 수 있다. 그 다음, 확률적 반올 림 회로는 고정 소수점 가산기를 사용하여 src1의 무작위 정수를 src0의 정규화된 부호 크기 표현 에 합산하여 중간 결과를 생성한다. 무작위 정수는 PRNG 알고리즘을 사용하여 소프트웨어에서 생성된 PRNG 2570 이다. 확률적 반올림 회로는 임의의 지수 조정을 수행한 후 중간 결과를 목적지 가수 형식의 크기로 자른 다. 확률적 반올림 회로는 확률적 반올림 프로세스를 수행하기 위해 프로그램 가능 및 고정 함수 하드웨 어를 포함할 수 있다. 특수 처리 회로는 예를 들어 언더플로, 오버플로 또는 준정규와 같은 데이터를 변 환 및/또는 반올림할 때 마주치는 코너 케이스를 처리하는 프로그램 가능 및 고정 함수 하드웨어를 포함할 수 있다. 일부 실시예에서, 반올림 연산에 사용되는 난수 비트는 명령어 연산 코드에 정의된 입력 및 출력 데이터 형식에 의존할 수 있다. 다음 표 1은 지원되는 입력 및 출력 형식의 예의 목록과 반올림 연산을 수행하는 데 사용되는 난수 비트를 제공한다."}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "<표 1> 일부 실시예에서, 난수의 폭은 소스 및 목적지 데이터 형식에 따라 달라질 수 있다. 소스 데이터 형식이 가수의 N비트를 갖고 목적지 데이터 형식이 가수의 K비트를 갖는다고 가정하면, 확률적 반올림 회로에서 반올림 을 수행하기 위해 (N-K) 비트의 난수가 사용될 수 있다. 도 26은 실시예에 따른 가수 및 난수의 부호 크기 표현의 고정 소수점 합산을 예시하는 블록도이다. 소스 가수(선행 1 포함) 및 난수는 덧셈 결과를 생성하기 위해 합산되는 것으로 표현된다. 소스 가수는 가수의 N 비트를 포함하며, 가수의 K-비트는 목적지 형식으로 사용되는 가수 비트 수를 나 타낸다. 합산 전에 난수의 비트는 소스 가수의 (N-K) 최하위 비트에 정렬된다. 합산 결과는 2개의 선행 비트(X)와 가수 비트(x)의 나머지 합산(addition)이 있는 합산 결과를 나타낸다. 도 27a는 본 명세서에 설명된 실시예에 따른, 처리 유닛에 의해 실행가능한 명령어를 예시한다. 도 27a는 확률적 반올림을 사용하여 부동 소수점 형식 입력 피연산자를 변환하기 위한 명령어의 필드를 예시한다. 명령어 는 실시예에 의해 제공되는 VPU 또는 FPU와 같은 처리 유닛에 의해 실행 가능하다. 도 27a는 실행될 때 처리 유 닛으로 하여금 확률적 반올림을 사용하여 부동 소수점 형식 입력 피연산자를 변환하는 명령어를 실행하게 하는 명령어의 필드를 예시한다. 일 실시예에서, 명령어는 목적지, 제0 소스(src0), 및 제 1 소스(src1)를 지정하기 위한 연산 코드 필드 및 피연산자 필드를 포함한다. 연산 코드 필드는 실행 로직에 대한 명령어를 식별하는 연산 코드를 지정할 수 있다. 일 실시예에 서, 연산 코드 필드는 인에이블될 때 명령어가 계산 블록(예를 들어, 계산 블록)의 처리 유닛에 의 해 실행될 것임을 나타내는 하나 이상의 비트를 포함한다. 목적지, 제0 소스(src0), 및 제1 소스(src1)는 계산이 기록되는 목적지 및 소스 데이터가 검색될 수 있는 위치를 지정하는 데 사용될 수 있다. 일 실시예에서, 목적지는 데이터가 기록될 레지스터 를 지정할 수 있다. 일 실시예에서 목적지는 스칼라 레지스터일 수 있지만, 일부 실시예에서 목적지는 다 수의 채널로부터의 출력을 저장하는 벡터 레지스터일 수도 있다. 제0 소스(src0) 및 제1 소스 (src1)는 소스 데이터의 하나 이상의 채널을 포함하는 레지스터 또는 즉치값일 수 있다. 일부 실시예에서, 예시된 것 이외의 추가 필드가 존재할 수 있다. 예를 들어, 일 실시예에서 소스 피연산자의 수치적 수정을 지정하는 소스 수정자 필드가 존재한다. 소스 피연산자의 각 데이터 요소 값은 실행 파이프라인 으로 전달되기 전에 선택적으로 그 절대값을 취하거나/취하고 그 부호를 반전시킬 수 있다. 절대값 수정자를 부 정 수정자보다 먼저 적용하여 보장된 음수 값을 생성할 수 있다. 일 실시예에서, 목적지 포화를 제어하는 데 사 용될 수 있는 포화 필드가 존재한다. 포화가 인에이블되면, 목적지 레지스터에 대한 출력 데이터가 포화된다. 특정 포화 연산은 목적지 데이터 유형에 따라 다르다. 포화는 데이터 유형의 포화 목표 범위 밖에 있는 모든 데 이터를 목표 범위와 가장 가까운 표현 값으로 변환하는 동작이다. 도 27b는 일 실시예에 따른 프로그램 코드 컴파일 프로세스를 도시한다. 일 실시예에서, 소프트웨어 프로 그램의 소스 코드 레벨 설명은 컴파일의 다수의 레벨을 포함할 수 있는 컴파일러에서, 처리 로직에 의해 수행될 확률적 반올림을 사용하는 FP 형식 변환 명령어를 포함하거나 지정하는 연산을 갖는 레벨로 컴파일된다. 연산은 중간 언어로 지정된 작업일 수 있거나, 머신 러닝 프레임워크에서 제공되는 프리미티 브와 같은 계산 프레임워크의 프리미티브를 참조하는 프로그램 코드일 수 있다. 확률적 반올림 명령어로 FP 형 식 변환을 포함하거나 지정하는 연산은 그 다음, 셰이더 컴파일러일 수 있는 추가 컴파일러에 의해, 본 명세서에 기술된 바와 같이 계산 블록의 처리 유닛(예를 들어, VPU, FPU)에 의해 수행될 확률적 반올 림 명령어와 함께 FP 형식 변환을 포함하는 머신 레벨 객체 코드로 추가로 컴파일될 수 있다. 다음은 실시예에 따른, 부동 소수점 포맷 데이터 값에 대한 효율적인 확률적 반올림을 구현하기 위한 의사 코드 의 제1 예이다. f (Input is sNaN){ output Quieted_NaN(input) } else if (Input is qNaN){ output destination format qNaN } else if (Input is Inf){ output destination format Inf } else if (Input is Zero){ output destination format Zero } else { if (Input is denormal number){ Normalize the input mantissa to M = 1.XXX..XX format (N+1 bits) out_exponent = input_exponent - mantissa_shift_bits } else{ Concatenate the leading 1 with input mantissa to M = 1.XXX..XX (N+1 bits) out_exponent = input_exponent }"}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "Extract the desired random number R from Src1: R = Src1[N-K-1:0] Align LSB of R and M, and perform fixed point addition M+R to get addition result A if (A has carry over bit){ Right shift A by 1bit out_exponent++ } if (out_exponent > DestMaxExponent) { //overflow Output the +/-FMAX based on the input sign } else if (out_exponent < DesMinNormalExponent) { //Output denormal number Denormalized the addition result A with destination bounded exponent. Truncate A with destination mantissa precision Assembly output with bounded exponent and truncated mantissa } else { //Output normal number Truncate addition result A with destination mantissa precision Assembly output with exponent and truncated mantissa } } 다음은 실시예에 따른, 부동 소수점 포맷 데이터 값에 대한 효율적인 확률적 반올림을 구현하기 위한 의사 코드 의 단순화된 제2 예이다. float src; bf8 dst; If (src == NaN) return Quieted_NaN; If (src == Inf) return Inf; If (src == 0.0) return 0.0; If (src == input_subnormal ) Normalize_A to 1.xxxxx format; src_sm = convert_to_sign_magnitude_format(A); src_sm += random_number; If (src_sm > dest_max_val) dst = inf else dst = round_to_zero(src_sm) return dst 도 28은 부동 소수점 값에 대한 효율적인 확률적 반올림을 수행하기 위한 명령어를 실행하기 위한 방법의 실시예를 예시하는 흐름도이다. 방법은 하드웨어(예를 들어, 회로, 전용 로직, 프로그램 가능 로직 등), 소프트웨어(가령, 처리 디바이스에서 실행되는 명령어), 또는 이들의 조합을 포함할 수 있는 처리 로직에 의해 수행될 수 있다. 방법의 프로세스는 표현의 간결함과 명확성을 위해 선형적 순서로 설명되나, 이들 중 임 의의 수는 병렬로, 비동기식으로 또는 다른 순서로 수행될 수 있는 것으로 고려된다. 또한, 간결함, 명확성 및 이해의 용이함을 위해, 도 1 내지 도 27과 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후에 반복되거나 논 의되지 않을 수 있다. 일 구현에서, 도 14의 데이터 처리 시스템과 같은 데이터 처리 시스템이 방법 을 수행할 수 있다. 방법은 단일 명령어가 GPGPU 내에서 실행되도록 페치 및 디코딩되는 처리 블록에서 시작한다. 일 구현에서, 단일 명령어는 디코딩된 명령어로 디코딩되어 GPGPU로 하여금 확률적 반올림으로 8비트 부동 소수점 형식의 변환을 수행하게 한다. 그 다음, 처리 블록에서, GPGPU의 계산 블록에서 디코딩된 벡터 명령어를 실행하기 위한 커맨드 세트가 결정된다. 처리 블록에서, 커맨드 세트는 확률적 반올림으로 8비트 부동 소수점 형식의 변환을 수행하기 위해 디코 딩된 명령어를 실행하도록 GPGPU의 계산 블록에 스케줄링된다. 마지막으로, 처리 블록에서, 디코딩된 명 령어 커맨드 세트의 완료에 응답하여 리타이어된다. 도 29는 부동 소수점 값에 대한 효율적인 확률적 반올림을 수행하기 위한 방법의 실시예를 예시하는 흐름 도이다. 방법은 하드웨어(예를 들어, 회로, 전용 로직, 프로그램 가능 로직 등), 소프트웨어(가령, 처리 디바이스에서 실행되는 명령어), 또는 이들의 조합을 포함할 수 있는 처리 로직에 의해 수행될 수 있다. 방법 의 프로세스는 표현의 간결함과 명확성을 위해 선형적 순서로 설명되나, 이들 중 임의의 수는 병렬로, 비 동기식으로 또는 다른 순서로 수행될 수 있는 것으로 고려된다. 또한, 간결함, 명확성 및 이해의 용이함을 위해 도 1 내지 도 28과 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후에 반복되거나 논의되지 않을 수 있다. 일 구현에서, 도 25의 처리 유닛과 같은 처리 유닛이 방법을 수행할 수 있다. 방법은 소스 값이 GPGPU의 계산 블록에 의해 실행될 명령어에 대해 페치되는 처리 블록에서 시작된 다. 일 구현에서, 소스 값은 더 높은 정밀도의 부동 소수점에서 더 낮은 정밀도의 부동 소수점으로 변환된다. 그 다음, 결정 블록에서, 소스 값이 0, 무한대 또는 NaN인지 여부가 결정된다. 그렇다면, 방법은 소스 값이 특별 사용 사례 값으로서 목적지에 반환되는 처리 블록으로 진행한다. 결정 블록에서 소 스 값이 0, 무한대 또는 NaN이 아니면, 방법은 소스 값이 목적지의 부호 크기 형식으로 변환되고 변환된 소스 값이 정규화되는 처리 블록으로 진행한다. 이어서, 처리 블록에서, 변환되고 정규화된 소스 값에 난수가 합산된다. 일 구현에서, 난수는 소스 및 목 적지 피연산자의 데이터 형식에 기초하여 결정되는 크기를 갖는다. 일 구현에서, 난수는 PRNG 소프트웨어로부터 획득된다. 처리 블록에서, 결과 합(sum)의 지수 조정이 수행되고 결과 합은 결과 목적지 값을 생성하기 위해 목적지 피연산자 가수 형식의 크기로 절단된다.결정 블록에서, 오버플로, 언더플로 또는 비정규 조건이 발생했는지 여부가 결정된다. 발생했다면, 방법 은 특별 사용 사례 값이 결과 목적지 값으로서 반환되는 처리 블록으로 진행한다. 한편, 오버플로, 언더플로, 또는 비정규 조건이 발생하지 않은 경우, 방법은 결과 목적지 값이 반환되는 처리 블록 으로 진행한다. 하이브리드 부동 소수점 시스톨릭 연산 여기에서 실시예는 하이브리드 부동 소수점 시스톨릭 연산을 제공한다. 딥 러닝(deep leaning)의 알고리즘 발전은 모델이 신경망을 트레이닝하기 위해 낮은 정밀도 산술을 활용할 수 있게 했다. 심층 신경망의 노이즈 탄력적 속성은 또한 다양한 딥 러닝 작업에 활용할 수 있는 맞춤형 데이터 형 식을 실험할 수 있게 한다. 딥 러닝 커뮤니티에서 널리 수용되고 하드웨어 제조업체에서 채택한 이러한 맞춤형 데이터 형식 중 하나는 BFLOAT16이다. 딥 러닝에서 더 작은 비트 폭(8비트 이하)이 활용됨에 따라, 비트의 효율적인 할당을 위해 데이터 형식의 추가 맞춤화가 구현될 수 있다. 예를 들어, 역전파 동안, 더 넓은 분포를 갖는 경향이 있는 오류 기울기는 더 높은 동적 범위(즉, 더 큰 지수)를 가진 데이터 형식을 사용하는 반면, 순방향(또는 추론) 경로는 더 높은 수치 정밀 도(즉, 더 큰 가수)로부터 이득을 얻어 숫치적 오류를 줄이다. 이러한 동작은 에지 디바이스에 최적화된 더 작 은 모델(더 적은 모델 매개변수)에서 더 분명하다. 더 작은 비트 너비 데이터 형식의 경우, 이는 동적 범위와 숫자 정밀도 간에 절충으로 이어진다. 지수와 가수 사이의 트레이딩 비트 할당에 더하여, 부동 소수점 형식은 또한 수치 분포의 적절한 지수 바이어스 또는 영점을 선택함으로써 수치 분포를 맞춤화할 수 있다. 딥 러닝 애플리케이션에 사용되는 대부분의 텐서의 일반적인 가우시안과 같은 데이터 분포(약 0)를 감안할 때, 형식으로 나타낼 수 있는 더 작은 값의 수를 최대화 하기 위한 지수 편향이 일반적으로 선택된다. 이것은 숫자 분포의 관련 부분에 우선 순위를 지정하여 더 작은 동적 범위를 갖는 것을 부분적으로 보상할 수 있다. 심층 신경망을 트레이닝하는 데 사용할 수 있는 2개의 8비트 부동 소수점 표현이 도입되었다. 형식 중 하나인 BFLOAT8은 숫자의 대칭 분포와 함께 's1.e5.m2' 이진 표현을 사용한다. 다른 형식인 HFLOAT8은 's1.e4.m3' 형 식으로 표현되며, 숫자 분포가 더 작은 숫자 값으로 치우친 비대칭 지수 편향이 있다. BFLOAT8 및 HFLOAT8 형식 을 함께 사용하여 트레이닝 파이프라인의 다른 부분을 처리하면 모델 정확도가 향상될 수 있다. 다수의 데이터 형식을 단일 트레이닝 흐름으로 혼합하면 서로 다른 이진 형식으로 표현되는 입력 행렬 간의 하이브리드 부동 소수점 연산이 발생할 수 있다. 산업이 8비트 및 8비트 미만 데이터 형식으로 이동함에 따라, 이러한 종류의 하 이브리드 작업이 더 널리 보급될 것이다. 그러나 부동 소수점 하드웨어가 있는 기존 시스템은 다른 이진 인코딩 을 사용하거나 통상적이지 않은 지수 바이어스를 사용하는 피연산자 간의 산술 연산을 지원하지 않는다. 실시예는 하이브리드 부동 소수점 연산을 가능하게 하기 위해 입력 피연산자에 대한 맞춤형 이진 인코딩을 지원 하기 위해 DPAS 하드웨어에 확장을 제공함으로써 이러한 기술적 문제를 해결한다. 지수 크기 및/또는 지수 바이 어스와 같은 입력 피연산자의 이진 형식 정보는 하드웨어에 내장되거나 선택적으로 명령어 인코딩의 일부로 표 현될 수 있다. 실시예의 하드웨어 확장은 요청된 산술 연산을 수행하기 전에 입력 인수를 재바이어스하고 공통 내부 형식으로 변환하기 위해 해당 정보를 활용할 수 있다. 도 30은 실시예에 따른, 상이한 이진 인코딩 및 지수 바이어스를 사용하는 2개의 8비트 부동 소수점 형식을 예 시하는 블록도이다. 왼쪽의 BFLOAT8(또는 Brain-Float8) 형식 3000은 s1.e5.m2 형식을 사용하는 BFLOAT8 이진 형식을 보여준다. s1.e5.m2 형식은 1개의 부호 비트, 5개의 지수 비트, 2개의 가수 비트 을 포함한다. 오른쪽의 HFLOAT 8(또는 Hybrid-Float8) 형식은 s1.e4.m3 형식을 사용하는 HFLOAT8 이진 형식 을 보여준다. s1.e4.m3 형식에는 1개의 부호 비트, 4개의 지수 비트 및 3개의 가수 비트가 포함된다. 또한 HFLOAT8 형식은 더 큰 지수 바이어스를 사용하여 숫자 분포를 더 작은 숫자 값으로 이동"}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "시킨다. 이 두 형식의 차이점은 아래 표 2에 요약되어 있다. <표 2> 본 명세서의 실시예의 하이브리드 부동 하드웨어는 정확도를 최대화하기 위해 트레이닝 파이프라인의 다른 부분 에 가장 적합한 이용 가능한 부동 소수점 형식의 목록으로부터 애플리케이션을 선택할 수 있게 함으로써 위에서 논의된 단점에 대한 기술적 이점을 제공한다. 또한, 실시예는 하드웨어에 대한 점증적 변경으로 다수의 데이터 형식을 지원할 수 있다. 이것은 프로세서 성능과 신경망 트레이닝 처리량을 향상시킨다. 도 31은 실시예에 따른 명령어 파이프라인에 의해 수행되는 하이브리드 8비트 FP 형식 시스톨릭 연산 을 예시하는 블록도이다. 명령어 파이프라인은 내적 연산과 같은 이에 제한되지 않는 하이브리드 8 비트 FP 형식 수축 연산을 수행하도록 구성될 수 있다. 두 벡터의 내적은 벡터의 해당 컴포넌트의 곱의 합과 같은 스칼라 값이다. 내적은 아래 식과 같이 계산될 수 있다."}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "내적은 합성곱 신경망(CNN)과 같은 신경망에 대한 합성곱 연산에 사용될 수 있다. 하드웨어 명령어를 가속화하 는 데 사용되는 명령어 파이프라인은 하드웨어 명령어를 페치 및 디코딩할 수 있는 명령어 페치 및 디코 드 유닛, 및 디코딩된 명령어를 계산 블록(1424A-1424N)(집합적으로 계산 블록으로 지칭됨) 및/또 는 행렬 가속기 내의 유닛 하나 이상의 실행 유닛으로 스케줄링할 수 있는 컨트롤러 유닛(가령, 스 케줄러 컨트롤러)을 포함할 수 있다. 명령어 파이프라인은 또한 하이브리드 8비트 FP 형식 시스톨 릭 연산의 하드웨어 명령어로 인코딩된 하이브리드 8비트 FP 형식에 따라 입력 데이터를 계산 블록 및/또는 행렬 가속기로 라우팅하기 위해, 멀티플렉서(mux)의 집합과 같은 선택 회로를 포함할 수 있다. 일 실시예에서, 하드웨어 명령어는 계산 블록으로 스케줄링되고 행렬 가속기로 오프로드될 수 있다. 하이브리드 8비트 FP 형식 수축 연산을 수행하기 위한 하나 이상의 하드웨어 명령어 및 연관 데이 터가 메모리에 저장될 수 있다. 하드웨어 명령어의 출력은 또한 메모리에 저장될 수 있다. 메모리 는, 도 14에서와 같이 시스템 메모리, GPGPU 메모리, 또는 하나 이상의 캐시 메모리(1427, 1430)를 포함하는 여기에서 설명된 임의의 메모리일 수 있다 저장될 수 있다. 일 실시예에서, 행렬 가속기는 시스톨릭 어레이 회로를 사용하여 하이브리드 8비트 FP 형식 시스톨 릭 연산을 수행하기 위해 하나 이상의 하드웨어 명령어를 실행할 수 있다. 시스톨릭 어레이 회로는 내적 연산을 수행하도록 구성될 수 있는 프로그램 가능 및 고정 함수의 하드웨어의 조합을 포함할 수 있다. 계 산 블록 내의 기능 유닛이 내적 연산을 수행하도록 구성될 수도 있지만, 시스톨릭 어레이 회로는 계산 블록에 비해 상당히 높은 처리량으로 내적 연산의 제한된 서브세트를 수행하도록 구성될 수 있다. 일부 실시예에서, 레지스터 파일에서 하이브리드 8비트 부동 소수점 형식 데이터(예: BF8 및 HF8) 소스 피연산 자에 대한 시스톨릭 내적 및 누산 연산을 수행하고, 선택된 정밀도(fp32, fp16, bf16)에서 결과를 누산하며, 최 종 출력을 레지스터 파일에 다시 기록하기 위한 DPAS 명령어가 제공된다. 하이브리드 8비트 FP 형식 시스톨릭 연산을 수행하기 위한 이러한 DPAS 명령어는 c += a*b를 계산하기 위해 3개의 입력 피연산자를 수용하고, 여기서 'a' 및 'b' 피연산자는 BF8 및 HF8과 같은 하이브리드 8비트 FP 유형이다. 입력 피연산자의 FP 형식 유 형의 다른 조합 및 변형이 실시예에서 가능하며 BF8 및 HF8 형식으로 제한되지 않는다. 도 32는 실시예에 따라, 하이브리드 부동 소수점 시스톨릭 연산을 수행하기 위한 시스톨릭 어레이 회로의 하이 브리드 FMA 유닛을 예시하는 블록도이다. 일 구현에서, 하이브리드 FMA 유닛은 도 31과 관련하여 설명된 시스톨릭 어레이 회로의 일부일 수 있다. 일 구현에서, 하이브리드 FMA 유닛은 하이브리드 FP 형식 피연산자를 갖는 DPAS 명령어의 연산을 수행한다. 하이브리드 FMA 유닛의 하이브리드-FMA 구현은 맞춤형 부동 소수점 형식을 수용할 수 있고 산술 연산을 수행하기 전에 이를 더 높은 정밀도의 공통 형식으로 내부적으로 변환할 수 있다. 실시예에서, 지수에 대해 할당된 비트 수 및 사용될 지수 오프셋과 같은 맞춤형 이진 형식에 관한 정보는 명령 어에서 FMA 명령어에 대한 제4 인수로서의 정수 비트맵(아래에 \"imm\", \"<imm.cbf>\"로 표시됨)으로서 전달될 수 있다. 실시예의 하이브리드 DPAS 명령어의 몇 가지 예가 입력(예를 들어, BF8 및 HF8) 및 출력 인수의 다양한조합을 사용하여 아래에 표시된다."}
{"patent_id": "10-2022-0024978", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "명령어 인코딩은 <hdpas_xx>로 표시될 수 있으며, 여기서 'xx'는 입력 인수(src1, src2 또는 둘 다) 중 어느 것 이 맞춤형 입력 형식을 사용하도록 허용되는지를 나타낸다. 명령어 인코딩의 구현은 목표 아키텍처에서 사용되 는 인코딩 스킴에 따라 달라질 수 있다. 도 32를 참조하면, 하이브리드 FMA 유닛에 의해 수행되는 실시예의 하이브리드-FMA 연산은 HFLOAT8 및 BFLOAT8 데이터 포맷으로 각각 표현되는 src1 및 src2 피연산자에 대해 수행된다. 이들 형식 모두는 지수와 가 수에 대해 서로 다른 비트 할당이 있는 서로 다른 이진 형식을 사용할 뿐만 아니라 서로 다른 지수 바이어스도 사용한다(예: BFLOAT8 bias = 15, HFLOAT8 bias = 11). 하이브리드 FMA 유닛은 복수의 재바이어스 및 정규화 유닛(3210a-h), 복수의 승산기(3220a-d), 복수의 시 프터(3230a-3230r), 및 가산기를 포함할 수 있다. 내부 비트 폭의 세부사항은 입력 및 출력 정밀도 요건 에 따라 하이브리드 FMA 유닛에서 변경될 수 있다. 하이브리드 FMA 유닛의 제1 스테이지는 재바이어스 및 정규화 유닛(3210a-3210h)을 포함한다. 재바이어스 및 정규화 유닛(3210a-3210h)은 들어오는 피연산자(src1(HF8) 및 src2(BF8))를 모두 BFLOAT8 및 HFLOAT8 형식 과 이들의 준정규 값(예를 들어, DAZ=0)을 모두 수용할 수 있는 공통 '1.e8.m3' 이진 형식으로 변환할 수 있다. 하이브리드 FMA 유닛의 제2 스테이지는 승산기(3220a-3220d)를 포함한다. 승산기(3220a-3220d)는 확장된 s1.e8.m3 형식을 입력으로 사용하고 중간 17비트 부호 크기 표현(s1.e8.m2.6)을 생성한다. 하이브리드 FMA 유닛의 제3 스테이지는 시프터(3230a-3230e)를 포함한다. 시프터(3230a-3230e)는 예를 들어 32비트 시프터를 사용하여 src0(이전의 누산 합은 포함함)와 함께 승산기(3220a-3220d) 출력을 정규화할 수 있다. 하이브리드 FMA 유닛의 최종 스테이지는 가산기를 포함한다. 가산기는 예를 들어 s1.e8.m2.27 형식 결과의 일부로서 27비트 가수를 생성하는 가산기 트리를 포함한다. 가산기는 오사오입 반올림 방법을 사 용하여 이 결과를 s1.e8.23m 형식 목적지 결과로 반올림한다. 도 33a는 본 명세서에 설명된 실시예에 따른, 시스톨릭 어레이 회로에 의해 실행가능한 누산 명령어를 갖 는 하이브리드 내적을 예시한다. 도 33a는 하이브리드 8비트 부동 소수점 형식 입력 피연산자에 대해 동작하고 실시예에 의해 제공된 시스톨릭 행렬 로직에 의해 실행 가능한 누산 명령어를 갖는 하이브리드 내적의 필 드를 예시한다. 도 33a는 실행될 때 시스톨릭 행렬 가속기로 하여금 하이브리드 8비트 부동 소수점 형식 입력 피연산자(예를 들어, BF8 및 HF8 피연산자)에 대한 누산으로 내적을 실행하게 하는 누산 명령어를 갖는 하이브리드 내적의 필드를 예시한다. 일 실시예에서, 명령어는 연산 코드 필드, 시스톨릭 깊이 (sdepth), 반복 카운트(rcount), 목적지를 지정하기 위한 피연산자 필드, 제0 소스 (src0), 제1 소스(srcl) 및 제2 소스(src2), 및 정수 비트맵(imm) 필드를 포함한다. 연산 코드 필드는 실행 로직에 대한 명령어를 식별하는 연산 코드를 지정할 수 있다. 일 실시예에 서, 연산 코드 필드는 인에이블될 때 명령어가 행렬 가속기(예를 들어, 행렬 가속기)에 의해 실행 될 것임을 나타내는 하나 이상의 비트를 포함한다. 일 실시예에서, 연산 코드 필드는 또한 명령어 가 행렬 가속기 내의 내적 로직(예를 들어, 시스톨릭 어레이 회로)과 같은 특수 목적 내적 로직에 의해 실행되도록 지정하는 하나 이상의 비트를 포함할 수 있다. 시스톨릭 깊이(sdepth)는 입력 데이터를 처리하는 데 사용할 시스톨릭 계층 수를 지정하는 데 사용될 수 있다. 일 실시예에서 시스톨릭 깊이는 즉치값(immediate value)으로 제공될 수 있다. 반복 횟수 (rcount)을 사용하여 연속 레지스터를 진행하는 dst 및 src0, 동일하게 유지되는 src1 및 N 요소를 진행 하는 src2(여기서 N은 목적지 형식)로 생성되는 dpas 명령어의 수를 지정한다. 목적지, 제0 소스(src0), 제1 소스(src1), 및 제2 소스(3314(src2))는 계산이 기록될 목적 지 및 소스 데이터가 검색될 수 있는 위치를 지정하는 데 사용될 수 있다. 일 실시예에서 목적지는 데이 터가 기록될 레지스터를 지정할 수 있다. 일 실시예에서 목적지는 스칼라 레지스터일 수 있지만, 일부 실 시예에서 목적지는 또한 다중 채널로부터의 출력을 저장하는 벡터 레지스터일 수 있다. 제0 소스, 제1 소 스 및 제2 소스는 소스 데이터의 하나 이상의 채널을 포함하는 레지스터 또는 즉치값일 수 있으며, 각 채널은 시스톨릭 어레이 회로에 의해 처리될 4개의 요소를 가진다. 정수 비트맵(imm) 필드는 지수에 대해 할당된 비트 수와 같은 소스 피연산자(예: src1 및/또는 src2) 중 적어도 하나의 맞춤형 이진 형식에 관한 정보를 지정하는 데 사용될 수 있고, 이는 예를 들면, 사용할 지수 및 지수 오프셋에 할당된 비트 수이다. 이 정보는 imm 필드에서 정수 비트맵으로서 명령어 에 전달될 수 있다. 일부 실시예에서, 예시된 것 이외의 추가 필드가 존재할 수 있다. 예를 들어, 일 실시예에서 소스 피연산자의 수치적 수정을 지정하는 소스 수정자 필드가 존재한다. 소스 피연산자의 각 데이터 요소 값은 실행 파이프라인 으로 전달되기 전에 선택적으로 그 절대값을 취하고/취하거나 그 부호를 반전시킬 수 있다. 절대값 수정자를 부 정 수정자보다 먼저 적용하여 보장된 음수 값을 생성할 수 있다. 일 실시예에서, 목적지 포화를 제어하기 위해 사용될 수 있는 포화 필드가 존재한다. 포화가 인에이블되면, 목적지 레지스터에 대한 출력 데이터가 포화된다. 특정 포화 연산은 목적지 데이터 유형에 따라 다르다. 포화는 데이터 유형의 포화 목표 범위 밖에 있는 모든 데 이터를 목표 범위와 가장 가까운 표현 값으로 변환하는 동작이다. 도 33b는 일 실시예에 따른 프로그램 코드 컴파일 프로세스를 도시한다. 일 실시예에서, 소프트웨어 프로 그램의 소스 코드 레벨 설명은, 다중 레벨의 컴파일을 포함할 수 있는 컴파일러에서 처리 로직에 의해 수행될 하이브리드 8비트 FP 내적을 포함하거나 지정하는 연산을 갖는 레벨로 컴파일된다. 연산 은 중간 언어로 지정된 작업일 수 있거나 머신 러닝 프레임워크에서 제공하는 프리미티브와 같은 계산 프 레임워크의 프리미티브를 참조하는 프로그램 코드일 수 있다. 하이브리드 8비트 FP 내적을 포함하거나 지정하는 연산은 그 다음, 셰이더 컴파일러일 수 있는 추가 컴파일러에 의해, 여기에 설명된 것처럼 행렬 연 산을 위해 가속기에 의해 수행될 하이브리드 8비트 FP 내적 명령어를 포함하는 머신 레벨 객체 코드로 컴 파일될 수 있다. 다음은 실시예에 따른 하이브리드 부동 소수점 시스톨릭 연산을 구현하기 위한 의사 코드의 예이다. exponent_bias_1, exponent_bias_2 = Instruction_decode(op_code) // convert src1 & src2 to s1.e8.m3 format, support denormals Temp1 = re_bias_normalize_src1(src1[0], exponent_bias1, denormals=True); Temp2 = re_bias_normalize_src2(src2[0], exponent_bias1, denormals=True); ... Temp7 = re_bias_normalize_src1(src1[3], exponent_bias1, denormals=True); Temp8 = re_bias_normalize_src2(src2[3], exponent_bias1, denormals=True); // Multiply PROD0 = temp1 * temp2; ... PROD3 = temp7 * temp8; // Normalize, Add ACC = NORM_ADD (src0 + PROD0 +.. + PROD3); // Round with RNE to produce s1.e8.m23 dst = RNE(ACC); 도 34는 하이브리드 부동 소수점 시스톨릭 연산을 위한 명령어를 실행하기 위한 방법의 실시예를 예시하 는 흐름도이다. 방법은 하드웨어(예를 들어, 회로, 전용 로직, 프로그램 가능 로직 등),소프트웨어(가령, 처리 디바이스에서 실행되는 명령어), 또는 이들의 조합을 포함할 수 있는 처리 로직에 의해 수행될 수 있다. 방법의 프로세스는 표현의 간결함과 명확성을 위해 선형적 순서로 예시되나, 이들 중 임 의의 수는 병렬로, 비동기식으로 또는 다른 순서로 수행될 수 있는 것으로 고려된다. 또한, 간결함, 명확성 및 이해의 용이함을 위해 도 1 내지 33과 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후에 반복되거나 논의되 지 않을 수 있다. 일 구현에서, 도 14의 데이터 처리 시스템과 같은 데이터 처리 시스템이 방법을 수행할 수 있다. 방법은 처리 블록에서 시작하며, 여기서 단일 명령어가 GPGPU 내에서 페치되고 실행되도록 디코딩 된다. 일 구현에서, 단일 명령어는 하이브리드 8비트 부동 소수점 형식 피연산자에 대해 동작하여 GPGPU로 하여 금 병렬 내적 연산을 수행하게 할 수 있는 디코딩된 행렬 명령어로 디코딩된다. 처리 블록에서, 파이프라 인 커맨드 세트는 하나 이상의 하이브리드 8비트 부동 소수점 형식 피연산자를 사용하여 행렬 가속기에서 디코 딩된 행렬 명령어를 실행하도록 결정된다. 이어서, 처리 블록에서, 파이프라인 커맨드의 세트는 하나 이상의 하이브리드 8비트 부동 소수점 형식 피 연산자를 사용하여 디코딩된 행렬 명령어를 실행 시스톨릭 내적 파이프라인으로 스케줄링된다. 마지막으로, 처 리 블록에서, 디코딩된 행렬 명령어는 파이프라인 커맨드 세트의 완료에 응답하여 리타이어된다. 도 35는 하이브리드 부동 소수점 시스톨릭 연산을 위한 방법의 실시예를 예시하는 흐름도이다. 방법 은 하드웨어(예를 들어, 회로, 전용 로직, 프로그램 가능 로직 등), 소프트웨어(가령, 처리 디바이스에서 실행되는 명령어), 또는 이들의 조합을 포함할 수 있는 처리 로직에 의해 수행될 수 있다. 방법의 프로세 스는 표현의 간결함과 명확성을 위해 선형적 순서로 예시되어 있으나, 이들 중 임의의 수는 병렬로, 비동기식으 로 또는 다른 순서로 수행될 수 있는 것으로 고려된다. 또한, 간결함, 명확성 및 이해의 용이함을 위해 도 1 내 지 도 34와 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후에 반복되거나 논의되지 않을 수 있다. 일 구현 에서, 도 31의 시스톨릭 어레이 회로와 같은 시스톨릭 어레이는, 방법을 수행할 수 있다. 방법은 GPGPU의 행렬 연산 가속기에 의해 실행될 명령어에 대해 소스 값 및 계산 깊이가 페치되는 처리 블록에서 시작한다. 일 구현에서, 소스 값은 하이브리드 8비트 부동 소수점 형식 피연산자이다. 처리 블 록에서, 소스 값 입력은 공통 이진 형식으로의 변환의 일부로서 재바이어싱 및 정규화된다. 이어서, 처리 블록에서, 공통 이진 형식의 소스 입력 요소의 요소별 승산에 기초하여 곱 세트가 생성된다. 그 다음, 처리 블록에서, 승산기 출력 및 누산기 입력은 각각의 승산기 및 누산기 입력에 대한 시프터를 사용하여 정규화된다. 처리 블록에서, 정규화된 승산기 출력 세트의 합이 계산되고 합은 오사오 입 반올림된다. 마지막으로, 처리 블록에서, 합은 오사오입 반올림을 사용하여 목적지 출력 정밀도로 반 올림된다. 8비트 부동 소수점 피연산자로 혼합 모드 연산 수행 8비트 부동 소수점 형식 피연산자로 혼합 모드 연산을 수행하기 위한 실시예가 제공된다. 딥 러닝(deep leaning)의 알고리즘 발전은 모델이 신경망을 트레이닝하기 위해 저 정밀도 산술을 이용할 수 있 게 했다. 기존 트레이닝 플랫폼은 고성능 시스톨릭 어레이 구현에서 IEEE-754 FP16 및 BFLOAT16 데이터 형식을 지원할 수 있다. 그러나 8비트 FP(예: BFLOAT8, 1s-5e-2m)는 트레이닝 및 추론 성능을 높이는 데 활용될 수 있 다. 컨볼루션 및 선형 층(Convolution and Linear layer)과 같은 신경망의 코어 계산 동작의 많은 부분이 8비트 FP 형식 데이터 유형을 활용할 수 있지만, 여전히 혼합 정밀도 체제(예: 8비트 FP 형식 및 16비트 또는 32비트 FP 형식)에서 동작하는 심층 신경망 부분이 존재한다. 혼합 정밀도 영역에서 동작하는 심층 신경망 부분의 몇 가지 예는 BatchNorm 및 LayerNorm 동작으로, 이는 계층이 이전 층에서 오는 8비트 FP 형식 입력(예: BFLOAT8)을 허 용하는 동안 더 높은 정밀도로 내부 통계(예: 평균 및 분산)를 유지한다. 이러한 혼합 정밀도 문제를 처리하기 위한 기존 시스템의 현재 접근 방식은 연산을 수행하기 전에 입력 텐서를 적절한 더 높은 정밀도 형식으로 상향 변환하고 나중에 시스톨릭 또는 출력 텐서에 대해 더 낮은 정밀도로 하향 변환하는 것이다. 그러나 기존 접근 방식의 이러한 변환 작업은 입력 텐서의 초고정밀 사본을 저장하고 레지스 터 대역폭 압력 및 종속성을 증가시키는 추가 오버헤드를 발생시킨다. 본 명세서의 실시예는 8비트 FP 형식(예를 들어, BFLOAT8 및 기타 IEEE-754 FP 형식) 입력 피연산자에 대해 혼 합 모드 연산을 수행하기 위한 명령어를 제공함으로써 이러한 기술적 문제를 해결한다. 위에서 논의된 도 15는실시예의 8비트 FP 형식으로서 이용될 수 있는 예시적인 BF8 이진 포맷을 도시한다. BFLOAT8 이진 형식은 부호, 지수 및 가수 비트로 표현된다. 5비트 지수는 6.1e-05와 5.7344e+04 사이의 정규 부동 소수점 값을 나타낼 수 있는 15의 오프셋 값을 사용한다. 이 형식은 동적 범위를 1.5e-05의 표현 가능한 가장 작은 값까지 확장하는 준 정규 값도 지원한다. 혼합 모드 연산을 수행하기 위한 이러한 명령어는 8비트 FP 형식(예: BFLOAT8)에서 적어도 하나의 입력 피연산 자를 받아들일 수 있는 반면, 다른 입력은 예를 들어 표준 부동 또는 반 부동 형식일 수 있다. 실시예는 위에서 논의된 혼합 모드 피연산자에 대해 동작할 수 있는 곱셈(MUL), ADD, 곱셈 누산(MAC), SEL 및 뺄셈(SUB)과 같은 자주 발생하는 동작에 대한 명령어 세트를 제공한다. 여기의 실시예는 레지스터 파일에 대한 풋프린트 및 대역폭 요구사항을 줄임으로써 위에서 언급한 기술적 문제 에 대한 기술적 이점을 제공한다. 더욱이, 실시예는 예를 들어 많은 비율의 BatchNorm 및 LayerNorm 연산을 갖 는 네트워크에 대한 종단 간 트레이닝 성능을 개선한다. 또한, 혼합 정밀도 8비트 FP 형식 트레이닝을 인에이블 하면 트레이닝 처리량 측면에서 신경망에서 트레이닝을 가속화하는 데 도움이 될 수 있다. 도 36은 실시예에 따른 명령어 파이프라인에 의해 수행되는 혼합 모드 8비트 FP 형식 연산을 예시 하는 블록도이다. 명령어 파이프라인은 혼합 모드 8비트 FP 형식 연산을 수행하도록 구성될 수 있 다. 명령어 파이프라인은 하드웨어 명령어를 가속화하는 데 사용될 수 있으며, 하드웨어 명령어를 페치 및 디코딩할 수 있는 명령어 페치 및 디코드 유닛과, 계산 블록(1424A-1424N)(집합적으로 계산 블록 으로 지칭됨) 및/또는 행렬 가속기 내의 하나 이상의 실행 유닛에 디코딩된 명령어를 스케줄링할 수 있는 컨트롤러 유닛(가령, 스케줄러 컨트롤러)을 포함할 수 있다. 명령어 파이프라인은 또한 혼합 모드 8비트 FP 형식 연산의 하드웨어 명령어에 인코딩된 혼합 모드 8비트 FP 형식에 따라 입력 데이터를 계산 블록 및/또는 행렬 가속기로 라우팅하기 위한 멀티플렉서(muxes) 집합과 같은 선택 회로를 포함할 수 있다. 일 실시예에서, 하드웨어 명령어는 계산 블록으로 스케줄링될 수 있고/있거나 행렬 가속기로 오프 로드될 수 있다(예를 들어, 시스톨릭 어레이 회로를 사용한 계산을 위해). 혼합 모드 8비트 FP 형식 연산 을 수행하기 위한 하나 이상의 하드웨어 명령어 및 연관 데이터는 메모리에 저장될 수 있다. 하드 웨어 명령어의 출력은 또한 메모리에 저장될 수 있다. 메모리는 도 14에서와 같이 시스템 메모리 , GPGPU 메모리, 또는 하나 이상의 캐시 메모리(1427, 1430)를 포함하는 본 명세서에 설명된 메모 리 중 임의의 것일 수 있다. 일 실시예에서, 계산 블록은 처리 유닛을 사용하여 혼합 모드 8비트 FP 형식 연산을 수행하 기 위해 하나 이상의 하드웨어 명령어를 실행할 수 있다. 처리 유닛은 혼합 모드 8비트 FP 형식 연산을 수행하도록 구성가능한 프로그램 가능 및 고정 함수 하드웨어의 조합을 포함할 수 있다. 일부 구현에서, 처리 유닛은 벡터 처리 유닛(VPU)일 수 있다. 일부 구현에서, 처리 유닛은 부동 소수점 유닛(FPU)일 수 있다. 처리 유닛은 변환 회로, 가장 가까운 짝수(RNE)로의 반올림 회로, 및 특수 처리 회로 를 포함할 수 있다. 일부 실시예에서, 혼합 모드 8비트 FP 형식 연산을 수행하기 위한 하드웨어 명령어는 8비트 FP(예: BFLOAT8) 입력 피연산자에 대한 혼합 모드 연산을 제공한다. 명령어는 적어도 하나의 8비트 FP 형식(예: BFLOAT8) 입력 피연산자를 수용하지만 다른 입력 피연산자는 IEEE-754 부동 소수점 또는 반 부동 데이터 형식일 수 있다. 변환 회로는 위에서 설명된 변환 프로세스를 수행하기 위해 프로그램 가능 및 고정 함수 하드웨어를 포함 할 수 있다. 변환 회로는 8비트 FP 형식(예를 들어, BF8) 피연산자를 다른 입력 피연산자의 형식과 일치 시키기 위해 더 높은 정밀도 형식으로 내부적으로 상향 변환할 수 있고, 연산은 더 높은 정밀도로 수행된다. 변 환 회로의 데이터 변환은 목표 정밀도의 동적 범위와 일치하도록 8비트 FP 형식 입력을 재정규화하고, 최 하위 비트(LSB)에서 가수를 0으로 확장한다. BFLOAT8 입력의 준정규 값은 보존되고 목표 정밀도로 정규화된다. RNE 반올림 회로는 변환된 데이터의 RNE 반올림을 수행하기 위해 프로그램 가능 및 고정 함수 하드웨어를 포함할 수 있다. 특수 처리 회로는 예를 들어 언더플로, 오버플로 또는 준정규와 같은 데이터를 변환 및/ 또는 반올림할 때 마주치는 코너 케이스를 처리하는 프로그램 가능 및 고정 함수 하드웨어를 포함할 수 있다. 일부 구현에서, 여기에 설명된 8비트 FP 형식 데이터의 변환을 위한 명령어는 다음 형식을 취할 수 있다. mac <f32> <f32> <f32> <bf8> mac <f16> <f16> <f16> <bf8> sub <f16> <f16> <bf8> add <f32> <f16> <bf8> mul <f16> <f16> <bf8> dst src0 src1 src2 8비트 FP 형식 혼합 모드 예 중 일부는 다음과 같이 설명된다: 2개의 소스 피연산자(mov, add, cmp, sel, mul 등)가 있는 명령어: 소스 중 하나는 8비트 FP 형식(예: BFLOAT8)이고 다른 하나는 더 높은 정밀도 유형이다. 목적지는 8비트 FP 형식 또는 더 높은 정밀도 유형일 수 있다. 3개의 소스 피연산자(mac 등)가 있는 명령어: 소스 중 하나 또는 두 개는 8비트 FP 형식(예: BFLOAT8)일 수 있 고, 나머지는 더 높은 정밀도 유형일 수 있다. 목적지는 8비트 FP 형식 또는 더 높은 정밀도 유형일 수 있다. 도 37은 실시예에 따른, 적어도 하나의 8비트 FP 형식 피연산자를 사용하여 혼합 모드 MAC 연산을 수행하기 위 한 하드웨어 회로의 예시적인 개략도를 도시한다. 일 구현에서, 하드웨어 회로는 도 36과 관련하여 설명된 처리 유닛에서 구현될 수 있다. 도37의 예에 도시된 바와 같이, 혼합 모드 MAC 연산을 수행하기 위한 하드웨어 회로는 F16(src1) 및 BF8(src2) 입력 피연산자를 수용하고 누산 합 src0(F16)으로 누산된다. 최종 출력 (dst(FP16))은 F16 출력으로 변환된다. 변환 회로(3710a, 3710b, 3710c)는 src1 및 src2 입 력을 FP32로 내부적으로 상향 변환한다. 변환 회로(3710a-c)는 도 36과 관련하여 설명된 변환 회로와 동 일할 수 있다. 실시예에서, 변환 회로(3710a-c)는 모든 입력(예를 들어, DAZ=0)에서 준정규 값을 보존할 수 있 다. 승산기는 변환 회로(3710b, 3710c)로부터 수신된 FP32 입력을 곱하여 중간 출력을 생성할 수 있다. 승산 기로부터의 중간 출력은 정규화되고 가산기에서 src0 입력(변환 회로(3710a)에 의해 FP32 형 식으로 변환됨)으로 누산된다. 마지막으로, 다른 변환 회로(도 36의 변환 회로와 동일할 수 있음)는 FP32 합은 FP16 출력으 로 변환한다. 실시예에서, 변환 회로는 모든 출력 (dst) 데이터 유형(예: FTZ=0)에 대한 준정규 값을 유 지한다. 도 38a는 본 명세서에 기술된 실시예에 따른, 처리 유닛에 의해 실행가능한 명령어 세트를 예시한다. 도 38a는 8비트 FP 형식 피연산자를 사용하여 혼합 모드 연산을 수행하기 위한 명령어의 필드를 예시한다. 명령어는 혼합 모드 mac 명령어, 혼합 모드 서브 명령어, 혼합 모드 추가 명령어, 및 혼합 모드 mul 명령어를 포함하지만 이에 한정되지 않는다. 또한 FP 형식 피연산자에 대한 연산을 위한 다른 혼합 모드 명령어가 실시예에 의해 구현될 수 있다. 명령어는 실시예에 의해 제공되는 VPU 또는 FPU와 같은 처리 유닛에 의해 실행 가능한다. 도 38a는 실행 될 때 처리 유닛으로 하여금 8비트 FP 형식 피연산자를 사용하여 혼합 모드 연산을 수행하게 하는 명령어(380 0)의 필드를 예시한다. 일 실시예에서, 명령어는 목적지, 제0 소스(src0), 제1 소스 (src1), 및/또는 제2 소스(src2)를 지정하기 위한 연산 코드 필드 및 피연산자 필드를 포함 한다. 연산 코드 필드는 실행 로직에 대한 명령어를 식별하는 연산 코드를 지정할 수 있다. 일 실시예에 서, 연산 코드 필드는 인에이블될 때 명령어가 계산 블록(예를 들어, 계산 블록)의 처리 유닛에 의 해 실행될 것임을 나타내는 하나 이상의 비트를 포함한다. 목적지, 제0 소스(src0), 제1 소스(src1), 및 제2 소스(src2)는 계산이 기록될 목적 지 및 소스 데이터가 검색될 수 있는 위치를 지정하는 데 사용될 수 있다. 일 실시예에서 목적지는 데이 터가 기록될 레지스터를 지정할 수 있다. 일 실시예에서 목적지는 스칼라 레지스터일 수 있지만, 일부 실 시예에서 목적지는 또한 다중 채널로부터의 출력을 저장하는 벡터 레지스터일 수 있다. 제0 소스(src0), 제1 소스(src1) 및 제2 소스(src2)는 소스 데이터의 하나 이상의 채널을 포함하는 레지스터 또는즉치값일 수 있다. 일부 실시예에서, 예시된 것 이외의 추가 필드가 존재할 수 있다. 예를 들어, 일 실시예에서 소스 피연산자의 수치적 수정을 지정하는 소스 수정자 필드가 존재한다. 소스 피연산자의 각 데이터 요소 값은 실행 파이프라인 으로 전달되기 전에 선택적으로 그 절대값을 취하고/하거나 그 부호를 반전시킬 수 있다. 절대값 수정자를 부정 수정자보다 먼저 적용하여 보장된 음수 값을 생성할 수 있다. 일 실시예에서, 목적지 포화를 제어하기 위해 사 용될 수 있는 포화 필드가 존재한다. 포화가 인에이블되면, 목적지 레지스터에 대한 출력 데이터가 포화된다. 특정 포화 연산은 목적지 데이터 유형에 따라 다르다. 포화는 데이터 유형의 포화 목표 범위를 벗어나는 모든 데이터를 목표 범위와 가장 가까운 표현 값으로 변환하는 동작이다. 도 38b는 일 실시예에 따른 프로그램 코드 컴파일 프로세스를 예시한다. 일 실시예에서, 소프트웨어 프로 그램의 소스 코드 레벨 설명은 다중 레벨의 컴파일을 포함할 수 있는 컴파일러에서 처리 로직에 의 해 수행될 8비트 FP 혼합 모드 명령어를 포함하거나 지정하는 연산을 갖는 레벨로 컴파일된다. 작업 은 중간 언어로 지정된 작업일 수 있거나 머신 러닝 프레임워크에서 제공하는 프리미티브와 같은 계산 프 레임워크의 프리미티브를 참조하는 프로그램 코드일 수 있다. 8비트 FP 혼합 모드 명령어를 포함하거나 지정하 는 연산은 셰이더 컴파일러일 수 있는 추가 컴파일러에 의해, 본 명세서에 기술된 바와 같이, 계산 블록의 처리 유닛(예를 들어, VPU, FPU)에 의해 수행될 8비트 FP 혼합 모드 명령어를 포함하는 머신 레벨 객체 코드로 추가로 컴파일될 수 있다. 다음은 실시예에 따른 혼합 모드 8비트 FP 형식 연산을 구현하기 위한 의사 코드의 예이다. F32 insrc0, insrc1, insrc2; if (OP is mixed_mode){ /* preserve subnormals on all inputs */ insrc0 = renormalize_extend_to_fp32 (src0); insrc1 = renormalize_extend_to_fp32 (src1); insrc2 = renormalize_extend_to_fp32 (src2); } else { insrc0 = src0; insrc1= src1; insrc2 = src2; } F32 tmp1 = src1 * src2; F32 tmp2 = tmp1 + src0; F16 dst = convert_to_dst_format(tmp2); /* FTZ = 0 */ return dst; 도 39는 8비트 부동 소수점 형식 피연산자와 혼합 모드 연산을 수행하기 위한 명령어를 실행하기 위한 방법 의 실시예를 예시하는 흐름도이다. 방법은 하드웨어(예를 들어, 회로, 전용 로직, 프로그램 가능 로직 등), 소프트웨어(가령, 처리 디바이스에서 실행되는 명령어), 또는 이들의 조합을 포함할 수 있는 처리 로 직에 의해 수행될 수 있다. 방법의 프로세스는 표현의 간결함과 명확성을 위해 선형적 순서로 설명되나, 이들 중 임의의 수는 병렬로, 비동기식으로 또는 다른 순서로 수행될 수 있는 것으로 고려된다. 또한, 간결함, 명확성 및 이해의 용이함을 위해 도 1 내지 도 38과 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후에 반복 되거나 논의되지 않을 수 있다. 일 구현에서, 도 14의 데이터 처리 시스템과 같은 데이터 처리 시스템이 방법을 수행할 수 있다. 방법은 단일 명령어가 GPGPU 내에서 실행되도록 페치 및 디코딩되는 처리 블록에서 시작한다. 일 구현에서, 단일 명령어는 디코딩된 명령어로 디코딩되어 GPGPU로 하여금 8비트 부동 소수점 형식 혼합 모드 동 작을 수행하게 한다. 처리 블록에서, GPGPU의 계산 블록 상에서 디코딩된 벡터 명령어를 실행하기 위한 명령어 세트가 결정된다. 이어서, 처리 블록에서, 커맨드 세트는 8비트 부동 소수점 형식 혼합 모드 동작을 수행하기 위한 디코딩 된 명령어를 실행하기 위해 GPGPU의 계산 블록으로 스케줄링된다. 마지막으로, 처리 블록에서, 디코딩된명령어는 커맨드 세트의 완료에 응답하여 리타이어된다. 도 40은 8비트 부동 소수점 형식 피연산자와 혼합 모드 연산을 수행하기 위한 방법의 실시예를 예시하는 흐름도이다. 방법은 하드웨어(예를 들어, 회로, 전용 로직, 프로그램 가능 로직 등), 소프트웨어(가령, 처리 디바이스에서 실행되는 명령어), 또는 이들의 조합을 포함할 수 있는 처리 로직에 의해 수행될 수 있다. 방법의 프로세스는 표현의 간결함과 명확성을 위해 선형적 순서로 설명된다. 그러나 이들 중 임의의 수는 병렬로, 비동기식으로 또는 다른 순서로 수행될 수 있는 것으로 고려된다. 또한, 간결함, 명확성 및 이해의 용 이함을 위해 도 1 내지 도 39와 관련하여 설명된 많은 컴포넌트 및 프로세스는 이후에 반복되거나 논의되지 않 을 수 있다. 일 구현에서, 도 36의 처리 유닛과 같은 처리 유닛이 방법을 수행할 수 있다. 방법은 GPGPU의 계산 블록에 의해 실행될 연산에 대해 명령어에 대한 소스 값이 페치되는 처리 블록 에서 시작한다. 일 구현에서, 소스 값은 혼합 모드 8비트 부동 소수점 형식 피연산자이다. 처리 블록 에서, 소스 값 입력은 공통 이진 형식으로의 변환의 일부로서 재바이어싱 및 정규화된다. 이어서, 처리 블록에서, 공통 이진 형식의 소스 입력 요소에 대해 연산이 수행된다. 후속하여, 처리 블록에서, 연산 출력은 시프터를 사용하여 정규화된다. 그 다음, 처리 블록에서, 정규화된 출력은 결과 값을 생성하기 위해 목적지 형식으로 변환된다. 마지막으로, 처리 블록에서, 결과 값이 목적지 피연산자로 반환된다. 다음 예는 추가 실시예에 관한 것이다. 예 1은 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자에 대한 지원을 제공하는 장치이다. 일 실시예에서, 예 1은 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내 적 누산을 제공하는 장치이다. 예 1의 장치는 프로세서를 포함하고, 프로세서는 실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩하기 위한 디코더 - 디코딩된 명령어는 프로세서로 하여금 병렬 내적 연산을 수행하게 하기 위해 8비트 부동 소수점 피연산자에 대해 연산하는 행렬 명령어임 - 와, 디코딩된 명령어를 스케줄링하고 디코딩된 명령어에 의해 표시된 8비트 부동 데이터 형식에 따라 8비트 부동 소수점 피연산자에 대한 입력 데이 터를 제공하는 컨트롤러와, 시스톨릭 층(systolic layers)을 사용하여 디코딩된 명령어를 실행하기 위한 시스톨 릭 내적 회로(systolic dot product circuitry)를 포함하고, 각 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트는 승산기, 시프터 및 가산기는 8비트 부동 소수점 피연산자 내 적을 생성한다. 예 2에서, 예 1의 발명 대상은 선택적으로 시프터가 승산기의 출력을 정규화하는 것을 포함할 수 있다. 예 3에 서, 예 1 및 2 중 어느 하나의 발명 대상은 승산기가 4비트 승산기, 8비트 승산기, 16비트 승산기 또는 32비트 승산기 중 적어도 하나를 포함하는 것을 선택적으로 포함할 수 있다. 예 4에서, 예 1 내지 3 중 어느 하나의 발 명 대상은 선택적으로 가산기가 시프터에 의해 정규화되는 승산기에서 생성된 곱을 더하기 위한 가산기 트리를 포함하고, 가산기가 오사오입 반올림을 사용하여 가산기 트리의 결과를 반올림하는 것을 포함할 수 있다. 예 5에서, 예 1 내지 4 중 어느 하나의 발명 대상은 결과가 디코딩된 명령어에 의해 표시되는 목적지 정밀도로 반올림되는 것을 선택적으로 포함할 수 있다. 예 6에서, 예 1 내지 5 중 어느 하나의 발명 대상은 누산기 소스 피연산자의 지연 누산을 수행하기 위한 시스톨릭 내적 회로 - 지연 누산은 8비트 부동 소수점 피연산자의 내적 의 생성에 후속하여 누산기 소스 피연산자를 누산하는 것임 - 를 선택적으로 포함할 수 있다. 예 7에서, 예 1 내지 예 6 중 어느 하나의 발명 대상은, 누산기 소스 피연산자의 누산을 수행하기 위한 시스톨릭 내적 회로 - 누산은 시스톨릭 내적 회로의 제1 스테이지 또는 시스톨릭 내적 회로의 중간 스테이지중 하나에서 누산기 소스 피연산자를 누산하는 것임 - 을 선택적으로 포함할 수 있다. 예 8에서, 예 1 내지 7 중 어느 하나의 발명 대상은 프로세서가 그래픽 처리 디바이스(GPU)를 포함하는 것을 선 택적으로 포함할 수 있다. 예 9에서, 예 1 내지 8 중 어느 하나의 발명 대상은 장치가 SIMD(Single Instruction Multiple Data) 머신 또는 SIMT(Single Instruction Multiple Thread) 머신 중 적어도 하나인 것을 선택적으로 포함할 수 있다. 예 10은 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하는 방법이며, 이 방법은, 프로세서에 의해, 실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩하는 단계 - 디코딩된 명령어 는 프로세서로 하여금 병렬 내적 연산을 수행하게 하기 위해 8비트 부동 소수점 피연산자에 대해 연산하는 행렬 명령어임 - 와, 프로세서에 의해, 디코딩된 명령어를 스케줄링하고, 디코딩된 명령어에 의해 표시된 8비트 부동 데이터 형식에 따라 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하는 단계와, 프로세서의 시스톨릭 내적 회로에 의해, 시스톨릭 층을 사용하여 디코딩된 명령어를 실행하는 단계 - 각각의 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트의 승산기, 시프터 및 가산기는 8비트 부 동 소수점 피연산자의 내적을 생성함 - 를 포함한다. 예 11에서, 예 10의 발명 대상은 시프터는 승산기의 출력을 정규화하기 위한 것이며, 가산기는 시프터에 의해 정규화되는, 승산기에서 생성된 곱을 더하기 위한 가산기 트리를 포함하고, 가산기는 오사오입 반올림을 사용하 여 가산기 트리의 결과를 반올림하는 것을 선택적으로 포함할 수 있다. 예 12에서, 예 10 및 11 중 어느 하나의 발명 대상은 결과가 디코딩된 명령어에 의해 표시되는 목적지 정밀도로 반올림되는 것을 선택적으로 포함할 수 있다. 예 13에서, 예 10 내지 12 중 어느 하나의 발명 대상은, 승산기가 4비트 승산기, 8비트 승산기, 16비트 승산기, 또는 32비트 승산기 중 적어도 하나를 포함하는 것을 선택적으로 포함할 수 있다. 예 14에서, 예 10 내지 13 중 어느 하나의 발명 대상은, 시스톨릭 내적 회로에 의해, 누산기 소스 피연산자의 지연 누산을 수행하는 단계를 더 포함하고, 지연 누산은 8비트 부동 소수점 피연산자의 내적 생성에 후속하여 누산기 소스 피연산자를 누산하는 것을 선택으로 포함할 수 있다. 예 15에서, 예 10 내지 13 중 어느 하나의 발 명 대상은, 시스톨릭 내적 회로에 의해, 누산기 소스 피연산자의 누산을 수행하는 단계를 더 포함하고, 누산은 누산기 소스 피연산자를 시스톨릭 내적 회로의 제1 스테이지 또는 시스톨릭 내적 회로의 중간 단계 중 하나에서 누산하는 것을 선택적으로 포함할 수 있다. 예 16은 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하기 위한 비 일시적 컴퓨터 판독가능 매체이다. 예 16에서, 비 일시적 컴퓨터 판독가능 매체는 명령어가 저장되어 있을 수 있고, 명 령어는 하나 이상의 프로세서에 의해 실행될 때 프로세서로 하여금, 하나 이상의 프로세서에 의해, 실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩 - 디코딩된 명령어는 하나 이상의 프로세서로 하여금 병렬 내적 연 산을 수행하게 하기 위해 8비트 부동 소수점 피연산자에 대해 연산하는 행렬 명령어임 - 하고, 하나 이상의 프 로세서에 의해, 디코딩된 명령어를 스케줄링하고, 디코딩된 명령어에 의해 표시된 8비트 부동 데이터 형식에 따 라 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하며, 하나 이상의 프로세서의 시스톨릭 내적 회로에 의해, 시스톨릭 층을 사용하여 디코딩된 명령어를 실행 - 각각의 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트의 승산기, 시프터 및 가산기는 8비트 부동 소수점 피연산자의 내적을 생성함 - 하게 한다. 예 17에서, 예 16의 발명 대상은, 시프터가 승산기의 출력을 정규화하고, 가산기는 시프터에 의해 정규화되는, 승산기에서 생성된 곱을 더하는 가산기 트리를 포함하며, 산기는 오사오입 반올림을 사용하여 가산기 트리의 결 과를 반올림하는 것을 선택적으로 포함할 수 있다. 예 18에서, 예 16 및 17 중 어느 하나의 발명 대상은, 결과 가 디코딩된 명령어에 의해 표시되는 목적지 정밀도로 반올림되는 것을 선택적으로 포함할 수 있다. 예 19에서, 예 16 내지 18 중 어느 하나의 발명 대상은, 명령어가 하나 이상의 프로세서로 하여금, 시스톨릭 내 적 회로에 의해, 누산기 소스 피연산자의 지연 누산을 수행하게 하고, 지연 누산은 8비트 부동 소수점 피연산자 의 내적 생성에 후속하여 누산기 소스 피연산자를 누산하는 것을 선택적으로 포함할 수 있다. 예 20에서, 예 16 내지 19 중 어느 하나의 발명 대상은, 명령어는 하나 이상의 프로세서로 하여금, 시스톨릭 내적 회로에 의해, 누산기 소스 피연산자의 누산을 수행하게 하고, 누산은 시스톨릭 내적 회로의 제1 스테이지 또는 시스톨릭 내적 회로의 중간 스테이지 중 하나에서 누산기 소스 피연산자를 누산하는 것을 선택적으로 포함할 수 있다. 예 21은 컴퓨팅 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하는 시스템 이다. 예 21에서, 시스템은, 메모리와, 복수의 GPU의 하나 이상의 프로세서를 포함한다. 하나 이상의 프로세서 는 메모리에 통신 가능하게 연결됨 - 를 포함하고, 하나 이상의 프로세서는, 실행을 위해 페치된 명령어를 디코 딩된 명령어로 디코딩하는 디코더 - 디코딩된 명령어는 GPU으로 하여금 병렬 내적 연산을 수행하게 하는 8비트 부동 소수점 피연산자에 대해 연산하는 행렬 명령어임 - 와, 디코딩된 명령어를 스케줄링하고, 디코딩된 명령어 에 의해 표시된 8비트 부동 데이터 형식에 따라 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하는 컨 트롤러와, 시스톨릭 층을 사용하여 디코딩된 명령어를 실행하기 위한 시스톨릭 내적 회로 - 각각의 시스톨릭 층 은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트의 승산기, 시프터 및 가산기 는 8비트 부동 소수점 피연산자의 내적을 생성함 - 를 포함한다. 예 22에서, 예 21의 발명 대상은 시프터가 승산기의 출력을 정규화하는 것임을 선택적으로 포함할 수 있다. 예 23에서, 예 21 및 22 중 어느 하나의 발명 대상은, 승산기가 4비트 승산기, 8비트 승산기, 16비트 승산기 또는 32비트 승산기 중 적어도 하나를 포함하는 것을 선택적으로 포함할 수 있다. 예 24에서, 예 21 내지 23 중 어느 하나의 발명 대상은, 가산기가 시프터에 의해 정규화되는, 승산기에서 생성된 곱(products)을 더하는 가산기 트 리를 포함하고, 가산기가 오사오입 반올림을 사용하여 가산기 트리의 결과를 반올림하는 것을 선택적으로 포함할 수 있다. 예 25에서, 예 21 내지 24 중 어느 하나의 발명 대상은, 결과가 디코딩된 명령어에 의해 표시되는 목적지 정밀 도로 반올림되는 것을 선택적으로 포함할 수 있다. 예 26에서, 예 21 내지 25 중 어느 하나의 발명 대상은, 시 스톨릭 내적 회로가 누산기 소스 피연산자의 지연 누산을 수행하고, 지연 누산이 8비트 부동 소수점 피연산자의 내적 생성에 후속하여 누산기 소스 피연산자를 누산하는 것을 선택적으로 포함할 수 있다. 예 27에서, 예 21 내 지 26 중 어느 하나의 발명 대상은, 시스톨릭 내적 회로가 누산기 소스 피연산자의 누산을 수행하고, 누산이 시 스톨릭 내적 회로의 제1 스테이지 또는 시스톨릭 내적 회로의 중간 스테이지 중 하나에서 누산기 소스 피연산자 를 누산하는 것을 선택적으로 포함할 수 있다. 예 28에서, 예 21 내지 27 중 어느 하나의 발명 대상은, 그래픽 처리 유닛(GPU)를포함하는 것을 선택적으로 포 함할 수 있다. 예 29에서, 예 21 내지 28 중 어느 하나의 발명 대상은 장치가 SIMD(single instruction multiple data) 머신 또는 SIMT(single instruction multiple thread) 머신 중 적어도 하나인 것을 선택적으로 포함할 수 있다. 예 30은, 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하는 장치이고, 장 치는, 실행을 위해 페치된 명령어를 디코딩된 명령어로 디코딩하는 수단 - 디코딩된 명령어는 프로세서로 하여 금 병렬 내적 연산을 수행하게 하는 8비트 부동 소수점 피연산자에 대해 연산하는 행렬 명령어임 - 과, 디코딩 된 명령어를 스케줄링하고, 디코딩된 명령어에 의해 표시된 8비트 부동 데이터 형식에 따라 8비트 부동 소수점 피연산자에 대한 입력 데이터를 제공하는 수단과, 시스톨릭 층을 사용하여 디코딩된 명령어를 실행하기 위한 수 단 - 각각의 시스톨릭 층은 상호연결된 승산기, 시프터 및 가산기의 하나 이상의 세트를 포함하며, 각 세트의 승산기, 시프터 및 가산기는 8비트 부동 소수점 피연산자의 내적을 생성함 - 을 포함한다. 예 31에서, 예 30의 발명 대상은 장치가 예 11 내지 15 중 어느 하나의 방법을 수행하도록 구성되는 것을 선택적으로 포함할 수 있 다. 예 32는 복수의 명령어를 포함하는 적어도 하나의 머신 판독가능 매체이고, 명령어는 컴퓨팅 디바이스에서 실행 되는 것에 응답하여, 컴퓨팅 디바이스로 하여금 예 10 내지 15 중 어느 하나에 따른 방법을 수행하게 한다. 예 33은 예 10 내지 15 중 어느 하나에 따른 방법을 수행하도록 구성되는, 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하는 장치이다. 예 34는 제10항 내지 제15항 중 어느 한 항의 방법을 수행하기 위한 수단을 포함하는, 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이 하게 하는 장치이다. 예의 세부사항은 하나 이상의 실시예의 어느 실시예에서나 사용될 수 있다. 예 35는 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하고, 특히 부동 소 수점 데이터를 8비트 부동 소수점 형식 데이터로 또는 그로부터 변환하는 것을 용이하게 하는 장치이다. 예 35 의 장치는 복수의 그래픽 처리 디바이스(GPU)의 프로세서를 포함하고, 프로세서는: 프로세서의 계산 블록에 의 해 실행될 명령어에 대한 소스 값을 페치 - 소스 값은 상이한 데이터 형식으로 변환되며, 소스 값은 8비트 부동 소수점 형식 피연산자 중 적어도 하나이거나 8비트 부동 소수점 피연산자로 변환되어야 함 - 하고, 소스 값을 재조정, 정규화 및 변환함으로써 소스 값을 목적지의 부호 크기 형식으로 변환하며, 변환된 소스 값에 오사오입 반올림을 적용하고, 변환되고 반올림된 소스 값을 목적지 값으로 반환한다. 예 36은 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하고, 특히 부동 소 수점 형식 데이터 값에 대한 효율적인 확률적 반올림을 용이하게 하는 장치이다. 예 36의 장치는 복수의 그래픽 처리 디바이스(GPU)의 프로세서를 포함하고, 프로세서는: 프로세서의 계산 블록에 의해 실행될 명령어에 대한 소스 값을 페치 - 소스 값은 더 높은 정밀도 부동 소수점으로부터 더 낮은 정밀도 부동 소수점으로 변환됨 -, 소스 값을 목적지의 부호 크기 형식으로 변환하고 변환된 소스 값을 정규화하며, 변환되고 정규화된 소스 값에 난수를 합산 - 난수는 소스 및 목적지 피연산자의 데이터 형식에 기초하여 결정된 크기를 가지고, 난수는 PRNG 에서 획득됨 - 하고, 결과 합의 지수 조정을 수행하고 결과 합은 목적지 피연산자 가수 형식의 크기로 잘라 결 과 목적지 값을 생성하며, 결과 목적지 값을 반환한다. 예 37은 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하고, 특히 하이브리 드 부동 소수점 시스톨릭 연산을 용이하게 하는 장치이다. 예 37의 장치는 복수의 그래픽 처리 디바이스(GPU)의 프로세서를 포함하고, 프로세서는 프로세서의 행렬 연산 가속기에 의해 실행될 명령어에 대한 소스 값 및 계산 깊이를 페치 - 소스 값은 하이브리드 8비트 부동 소수점 형식 피연산자를 포함함 - 하고, 공통 이진 형식으로 변환하는 것의 일부로서 소스 값을 재바이어스하고 정규화하며, 공통 이진 형식의 재바이어싱 및 정규화된 소스 값의 요소별 곱에 기초하여 곱 세트를 생성하고, 각 승산기 및 누산기 입력에 대해 시프터를 사용하여 승산기출력 및 누산기 입력을 정규화하며, 정규화된 승산기 출력 세트의 합은 계산하고 합은 오사오입 반올림하고, 오 사오입 반올림을 사용하여 계산된 합은 목적지 출력 정밀도로 반올림한다. 예 38은 컴퓨팅 아키텍처에서 8비트 부동 소수점 형식 피연산자를 지원하는 것을 용이하게 하고, 특히 8비트 부 동 소수점 형식 피연산자와의 혼합 모드 연산을 용이하게 하는 장치이다. 예 38의 장치는 복수의 그래픽 처리 디바이스(GPU)의 프로세서를 포함하고, 프로세서는: 프로세서의 계산 블록에 의해 실행될 연산을 위한 명령어에 대한 소스 값을 페치 - 소스 값은 혼합 모드 8비트 부동 소수점 형식 피연산자를 포함함 - 공통 이진 형식으로 변환하는 것의 일부로서 소스 값을 재바이어싱 및 정규화함 - 하고, 공통 이진 형식의 재바이어싱 및 정규화된 소스 값에 대한 연산을 수행하며, 시프터를 사용하여 출력을 정규화하고, 정규화된 출력을 대상 형식으로 변환 하여 결과 값을 생성하며, 결과 값을 대상 피연산자에게 반환한다. 전술한 설명 및 도면은 제한적인 의미가 아니라 예시적인 것으로 간주되어야 한다. 당업자는 첨부된 특허청구범 위에 기재된 특징의 보다 넓은 사상 및 범위를 벗어나지 않는 범위에서 본 명세서에 설명된 실시예에 다양한 수 정 및 변경이 이루어질 수 있음을 이해할 것이다."}
{"patent_id": "10-2022-0024978", "section": "도면", "subsection": "도면설명", "item": 1, "content": "위에 언급된 본 실시예의 특징이 상세하게 이해될 수 있는 방식으로, 위에서 간략하게 요약된 실시예에 대한 더 구체적인 설명이 실시예를 참조하여 행해질 수 있으며, 이들 중 일부는 첨부된 도면에 예시되어 있다. 그러나, 첨부된 도면은 단지 전형적인 실시예를 예시하는 것이며, 따라서 그 범위를 제한하는 것으로 간주되어서는 안 된다는 점에 유의해야 한다. 도 1은 처리 시스템의 블록도이다. 도 2a 내지 도 2d는 컴퓨팅 시스템 및 그래픽 프로세서를 도시한다. 도 3a 내지 도 3c는 추가적인 그래픽 프로세서 및 계산 가속기 아키텍처의 블록도를 도시한다. 도 4는 그래픽 프로세서의 그래픽 처리 엔진의 블록도이다. 도 5a 및 도 5b는 그래픽 프로세서 코어에 채용된 처리 요소들의 어레이를 포함하는 스레드 실행 로직을 도시한 다. 도 6은 추가적인 실행 유닛(execution unit)을 나타낸다. 도 7은 그래픽 프로세서 명령어 형식을 예시하는 블록도이다. 도 8은 추가적인 그래픽 프로세서 아키텍처의 블록도이다. 도 9a 및 도 9b는 그래픽 프로세서 명령어 형식 및 명령어 시퀀스를 예시한다. 도 10은 데이터 처리 시스템을 위한 예시적인 그래픽 소프트웨어 아키텍처를 도시한다. 도 11a는 IP 코어 개발 시스템을 나타내는 블록도이다. 도 11b는 집적 회로 패키지 어셈블리의 측단면도를 예시한다. 액티브는 기판(예를 들어, 베이스 다이)에 연결된 하드웨어 로직 칩렛의 다수의 유닛을 포함하는 패키지 어셈블 리를 예시한다. 도 11d는 교환가능한 칩렛을 포함하는 패키지 어셈블리를 예시한다. 도 12는 예시적인 시스템 온 칩 집적 회로를 도시하는 블록도이다. 도 13a 및 도 13b는 SoC 내에서 사용하기 위한 예시적인 그래픽 프로세서를 예시하는 블록도이다. 도 14는 일 실시예에 따른 데이터 처리 시스템의 블록도이다. 도 15는 실시예에 따른, 브레인-부동 8(BFLOAT8 또는 BF8) 이진 형식을 예시하는 블록도이다. 도 16은 실시예에 따른, 명령어 파이프라인에 의해 수행되는 시스톨릭 DP 8비트 FP 형식 연산을 예시하는 블록 도이다. 도 17a 및 17b는 실시예에 따른 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산(systolic dot product accumulate)을 수행하기 위한 시스톨릭 어레이 회로를 예시하는 블록도이다. 도 18a는 본 명세서에 설명된 실시예들에 따른, 시스톨릭 어레이 회로에 의해 실행가능한 명령어를 예시한다. 도 18b는 일 실시예에 따른 프로그램 코드 컴파일 프로세스를 도시한다. 도 19는 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산을 위한 명령어를 실행하기 위한 방 법의 실시예를 예시하는 흐름도이다. 도 20은 8비트 부동 소수점 형식 입력 피연산자에 대한 시스톨릭 내적 누산을 위한 방법의 실시예를 예시하는 흐름도이다. 도 21은 실시예에 따른 명령어 파이프라인에 의해 수행되는 8비트 FP 형식 변환 동작을 나타내는 블록도이다.도 22a는 본 명세서에 설명된 실시예에 따른, 처리 유닛에 의해 실행가능한 명령어를 예시한다. 도 22b는 일 실시예에 따른 프로그램 코드 컴파일 프로세스를 도시한다. 도 23은 부동 소수점 데이터를 8비트 부동 소수점 형식 데이터로 변환하기 위한 명령어를 실행하기 위한 방법의 실시예를 예시하는 흐름도이다. 도 24는 부동 소수점 데이터를 8비트 부동 소수점 형식 데이터로 변환하기 위한 명령어를 실행하기 위한 방법의 실시예를 예시하는 흐름도이다. 도 25는 실시예에 따른, 명령어 파이프라인에 의해 수행되는 확률적 반올림 연산을 사용한 8비트 FP 형식 변환 을 예시하는 블록도이다. 도 26은 실시예에 따른 가수 및 난수의 부호 크기 표현의 고정 소수점 덧셈을 예시하는 블록도이다. 도 27a는 본 명세서에 설명된 실시예에 따른, 처리 유닛에 의해 실행가능한 명령어를 예시한다. 도 27b는 일 실시예에 따른 프로그램 코드 컴파일 프로세스를 도시한다. 도 28은 부동 소수점 값에 대한 효율적인 확률적 반올림을 수행하기 위한 명령어를 실행하는 방법의 실시예를 예시하는 흐름도이다. 도 29는 부동 소수점 값들에 대한 효율적인 확률적 반올림을 수행하는 방법의 실시예를 예시하는 흐름도이다. 도 30은 실시예에 따른, 상이한 이진 인코딩 및 지수 바이어스를 사용하는 2개의 8비트 부동 소수점 형식을 예 시하는 블록도이다. 도 31은 실시예에 따른, 명령어 파이프라인에 의해 수행되는 하이브리드 8비트 FP 형식 시스톨릭 연산을 예시하 는 블록도이다. 도 32는 실시예들에 따른, 하이브리드 부동 소수점 시스톨릭 연산을 수행하기 위한 시스톨릭 어레이 회로의 하 이브리드 FMA 유닛을 예시하는 블록도이다. 도 33a는 본 명세서에 설명된 실시예에 따른, 시스톨릭 어레이 회로에 의해 실행가능한 명령어를 예시한다. 도 33b는 일 실시예에 따른, 프로그램 코드 컴파일 프로세스를 도시한다. 도 34는 하이브리드 부동 소수점 시스톨릭 연산을 위한 명령어를 실행하는 방법의 실시예를 예시하는 흐름도이 다. 도 35는 하이브리드 부동 소수점 시스톨릭 연산을 위한 방법의 실시예를 예시하는 흐름도이다. 도 36은 실시예에 따른, 명령어 파이프라인에 의해 수행되는 혼합 모드 8비트 FP 형식 연산을 예시하는 블록도 이다. 도 37은 실시예에 따른, 적어도 하나의 8비트 FP 형식 피연산자를 사용하여 혼합 모드 MAC 연산을 수행하기 위 한 하드웨어 회로의 예시적인 개략도를 도시한다. 도 38a는 본 명세서에 설명된 실시예에 따른, 처리 유닛에 의해 실행가능한 명령어 세트를 예시한다. 도 38b는 일 실시예에 따른, 프로그램 코드 컴파일 프로세스를 도시한다. 도 39는 8비트 부동 소수점 형식 피연산자로 혼합 모드 연산을 수행하기 위한 명령어를 실행하는 방법의 실시예 를 예시하는 흐름도이다. 도 40은 8비트 부동 소수점 형식 피연산자로 혼합 모드 연산을 수행하는 방법의 실시예를 예시하는 흐름도이다."}
