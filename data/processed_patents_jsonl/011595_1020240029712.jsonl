{"patent_id": "10-2024-0029712", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0009894", "출원번호": "10-2024-0029712", "발명의 명칭": "NTT 처리 방법 및 장치", "출원인": "삼성전자주식회사", "발명자": "아메트 칸 메르트"}}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "다항식의 계수로 구성된 입력 행렬을 획득하는 단계;전처리 유닛(PU; preprocessing unit)에 기초하여, 상기 계수에 대하여 전처리 연산을 수행하는 단계;제1 NTT 아키텍쳐에 기초하여, 상기 전처리 연산이 완료된 상기 입력 행렬의 열 성분에 대하여 제1 NTT 연산을수행하는 단계;상기 제1 NTT 연산 결과와 트위들 팩터(twiddle factor) 사이의 아다마르 곱(Hadamard product) 연산을 수행하는 단계; 및제2 NTT 아키텍쳐에 기초하여, 상기 아다마르 곱 연산이 완료된 상기 입력 행렬의 행 성분에 대하여 제2 NTT 연산을 수행하는 단계를 포함하는 연산 방법."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 제1 NTT 아키텍쳐는상기 제1 NTT 연산을 구성하는 스테이지(stage)에 대응하는 제1 NTT 유닛을 포함하고,상기 제1 NTT 아키텍쳐에 포함된 상기 제1 NTT 유닛은 서로 독립적으로 연산 가능한, 연산 방법."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 제1 NTT 유닛은버터플라이 연산 유닛(BU; butterfly operation unit), 레지스터, 제1 멀티플렉서 및 제2 멀티플렉서를 포함하는, 연산 방법."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 전처리 연산을 수행하는 단계는상기 계수에 대하여 1의 2N 거듭 제곱근을 곱하는 단계를 포함하고,상기 N은 상기 입력 행렬의 크기인, 연산 방법."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,공개특허 10-2025-0009894-3-상기 제2 NTT 연산을 수행하는 단계는log2N*(N/2)개의 제2 NTT 유닛을 포함하고,상기 N은 상기 입력 행렬의 크기인, 연산 방법."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,상기 전처리 유닛은모듈러 곱셈기(modular multiplier)를 포함하는, 연산 방법."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 아마마르 곱 연산을 수행하는 단계는모듈러 곱셈기에 기초하여, 상기 아마마르 곱 연산을 수행하는 단계를 포함하는, 연산 방법."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "하드웨어와 결합되어 제1항 내지 제7항 중 어느 하나의 항의 방법을 실행시키기 위하여 매체에 저장된 컴퓨터프로그램."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "다항식의 계수로 구성된 입력 행렬의 상기 계수에 대하여 전처리 연산을 수행하는 전처리 유닛;상기 전처리 연산이 완료된 상기 입력 행렬의 열 성분에 대하여 제1 NTT 연산을 수행하는 제1 NTT 아키텍쳐;상기 제1 NTT 연산 결과와 트위들 팩터(twiddle factor) 사이의 아다마르 곱(Hadamard product) 연산을 수행하는 아다마르 유닛; 및상기 아다마르 곱 연산이 완료된 상기 입력 행렬의 행 성분에 대하여 제2 NTT 연산을 수행하는 제2 NTT 아키텍쳐를 포함하는 연산 장치."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,제1 NTT 아키텍쳐는상기 제1 NTT 연산을 구성하는 스테이지(stage)에 대응하는 제1 NTT 유닛을 포함하고,상기 제1 NTT 아키텍쳐에 포함된 상기 제1 NTT 유닛은 서로 독립적으로 연산 가능한, 연산 장치."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "공개특허 10-2025-0009894-4-제10항에 있어서,상기 제1 NTT 유닛은버터플라이 연산 유닛(BU; butterfly operation unit);레지스터;제1 멀티플렉서; 및제2 멀티플렉서를 포함하는, 연산 장치."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제9항에 있어서,상기 전처리 유닛은상기 계수에 대하여 1의 2N 거듭 제곱근을 곱하는 연산을 수행하고,상기 N은 상기 입력 행렬의 크기인, 연산 장치."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제9항에 있어서,상기 제2 NTT 아키텍쳐는log2N*(N/2)개의 제2 NTT 유닛을 포함하고,상기 N은 상기 입력 행렬의 크기인, 연산 장치."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제9항에 있어서,상기 전처리 유닛은모듈러 곱셈기(modular multiplier)를 포함하는, 연산 장치."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제9항에 있어서,상기 아마마르 유닛은모듈러 곱셈기에 기초하여, 상기 아마마르 곱 연산을 수행하는, 연산 장치."}
{"patent_id": "10-2024-0029712", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제9항에 있어서,상기 제2 NTT 아키텍쳐는INTT 행렬의 행 성분에 대하여 제1 INTT 연산을 수행하고,상기 아다마르 유닛은공개특허 10-2025-0009894-5-상기 제1 INTT 연산 결과와 상기 트위들 팩터 사이의 INTT 아다마르 곱 연산을 수행하고,상기 제1 NTT 아키텍쳐는상기 INTT 아다마르 곱 연산이 완료된 상기 INTT 행렬의 열 성분에 대하여 제2 INTT 연산을 수행하고,상기 모듈러 곱셈기는상기 제2 INTT 연산 결과에 대하여 후처리 연산을 수행하는, 연산 장치."}
{"patent_id": "10-2024-0029712", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "일 실시예에 따른 연산 방법은 다항식의 계수로 구성된 입력 행렬을 획득하는 단계, 전처리 유닛(PU; preprocessing unit)에 기초하여, 상기 계수에 대하여 전처리 연산을 수행하는 단계, 제1 NTT 아키텍쳐에 기초하 여, 상기 전처리 연산이 완료된 상기 입력 행렬의 열 성분에 대하여 제1 NTT 연산을 수행하는 단계, 상기 제1 NTT 연산 결과와 트위들 팩터(twiddle factor) 사이의 아다마르 곱(Hadamard product) 연산을 수행하는 단계 및 제2 NTT 아키텍쳐에 기초하여, 상기 아다마르 곱 연산이 완료된 상기 입력 행렬의 행 성분에 대하여 제2 NTT 연 산을 수행하는 단계를 포함할 수 있다."}
{"patent_id": "10-2024-0029712", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "아래 실시예들은 NTT 처리 방법 및 장치에 관한 것이다."}
{"patent_id": "10-2024-0029712", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "동형 암호(homomorphic encryption)는 암호화된 데이터 사이에서 임의의 연산을 가능하게 하는 유망한 암호화 방법이다. 동형 암호를 활용하면 암호화된 데이터를 복호화하지 않고, 암호화된 상태에서 임의의 연산을 수행 할 수 있을 뿐만 아니라, 격자를 기반(lattice-based)으로 하여 양자 알고리즘에 내성(resistant)이 있어 안전 하다. 최근 CPU, GPU, NPU 등은 칩 사이즈(Chip Size)가 800mm2 이상으로 커지는 추세로, 이러한 사이즈 증가는 미세 공정 기술에서 수율의 한계가 커지는 문제가 있을 수 있다. 동형암호 가속기를 ASIC으로 구현하는 연구에서도 성능을 높이기 위해 연산기 개수를 늘리고 있고, 이는 칩 사이즈를 증가시킬 수 있고, 이로 인해 수율이 떨어지 는 문제가 발생한다."}
{"patent_id": "10-2024-0029712", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시예에 따른 연산 방법은 다항식의 계수로 구성된 입력 행렬을 획득하는 단계; 전처리 유닛(PU; preprocessing unit)에 기초하여, 상기 계수에 대하여 전처리 연산을 수행하는 단계; 제1 NTT 아키텍쳐에 기초 하여, 상기 전처리 연산이 완료된 상기 입력 행렬의 열 성분에 대하여 제1 NTT 연산을 수행하는 단계; 상기 제1 NTT 연산 결과와 트위들 팩터(twiddle factor) 사이의 아다마르 곱(Hadamard product) 연산을 수행하는 단계; 및 제2 NTT 아키텍쳐에 기초하여, 상기 아다마르 곱 연산이 완료된 상기 입력 행렬의 행 성분에 대하여 제2 NTT 연산을 수행하는 단계를 포함할 수 있다. 상기 제1 NTT 아키텍쳐는 상기 제1 NTT 연산을 구성하는 스테이지(stage)에 대응하는 제1 NTT 유닛을 포함하고, 상기 제1 NTT 아키텍쳐에 포함된 상기 제1 NTT 유닛은 서로 독립적으로 연산 가능할 수 있다. 상기 제1 NTT 유닛은 버터플라이 연산 유닛(BU; butterfly operation unit), 레지스터, 제1 멀티플렉서 및 제2 멀티플렉서를 포함할 수 있다. 상기 전처리 연산을 수행하는 단계는 상기 계수에 대하여 1의 2N 거듭 제곱근을 곱하는 단계를 포함하고, 상기 N은 상기 입력 행렬의 크기일 수 있다. 상기 제2 NTT 연산을 수행하는 단계는 log2N*(N/2)개의 제2 NTT 유닛을 포함하고, 상기 N은 상기 입력 행렬의 크기일 수 있다. 상기 전처리 유닛은 모듈러 곱셈기(modular multiplier)를 포함할 수 있다. 상기 아마마르 곱 연산을 수행하는 단계는 모듈러 곱셈기에 기초하여, 상기 아마마르 곱 연산을 수행하는 단계 를 포함할 수 있다. 일 실시예에 따른 연산 장치는 다항식의 계수로 구성된 입력 행렬의 상기 계수에 대하여 전처리 연산을 수행하 는 전처리 유닛; 상기 전처리 연산이 완료된 상기 입력 행렬의 열 성분에 대하여 제1 NTT 연산을 수행하는 제1 NTT 아키텍쳐; 상기 제1 NTT 연산 결과와 트위들 팩터(twiddle factor) 사이의 아다마르 곱(Hadamard product) 연산을 수행하는 아다마르 유닛; 및 상기 아다마르 곱 연산이 완료된 상기 입력 행렬의 행 성분에 대하여 제2NTT 연산을 수행하는 제2 NTT 아키텍쳐를 포함할 수 있다. 제1 NTT 아키텍쳐는 상기 제1 NTT 연산을 구성하는 스테이지(stage)에 대응하는 제1 NTT 유닛을 포함하고, 상기 제1 NTT 아키텍쳐에 포함된 상기 제1 NTT 유닛은 서로 독립적으로 연산 가능할 수 있다. 상기 제1 NTT 유닛은 버터플라이 연산 유닛(BU; butterfly operation unit); 레지스터; 제1 멀티플렉서; 및 제 2 멀티플렉서를 포함할 수 있다. 상기 전처리 유닛은 상기 계수에 대하여 1의 2N 거듭 제곱근을 곱하는 연산을 수행하고, 상기 N은 상기 입력 행 렬의 크기일 수 있다. 상기 제2 NTT 아키텍쳐는 log2N*(N/2)개의 제2 NTT 유닛을 포함하고, 상기 N은 상기 입력 행렬의 크기일 수 있 다. 상기 전처리 유닛은 모듈러 곱셈기(modular multiplier)를 포함할 수 있다. 상기 아마마르 유닛은 모듈러 곱셈기에 기초하여, 상기 아마마르 곱 연산을 수행할 수 있다. 상기 제2 NTT 아키텍쳐는 INTT 행렬의 행 성분에 대하여 제1 INTT 연산을 수행하고, 상기 아다마르 유닛은 상기 제1 INTT 연산 결과와 상기 트위들 팩터 사이의 INTT 아다마르 곱 연산을 수행하고, 상기 제1 NTT 아키텍쳐는 상기 INTT 아다마르 곱 연산이 완료된 상기 INTT 행렬의 열 성분에 대하여 제2 INTT 연산을 수행하고, 상기 모 듈러 곱셈기는 상기 제2 INTT 연산 결과에 대하여 후처리 연산을 수행할 수 있다."}
{"patent_id": "10-2024-0029712", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하에서, 첨부된 도면을 참조하여 실시예들을 상세하게 설명한다. 그러나, 실시예들에는 다양한 변경이 가해 질 수 있어서 특허출원의 권리 범위가 이러한 실시예들에 의해 제한되거나 한정되는 것은 아니다. 실시예들에 대한 모든 변경, 균등물 내지 대체물이 권리 범위에 포함되는 것으로 이해되어야 한다. 실시예에서 사용한 용어는 단지 설명을 목적으로 사용된 것으로, 한정하려는 의도로 해석되어서는 안된다. 단 수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\" 또 는 \"가지다\" 등의 용어는 명세서 상에 기재된 특징, 숫자, 단계, 동작, 구성요소, 부품 또는 이들을 조합한 것 이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들이나 숫자, 단계, 동작, 구성요소, 부품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 실시예가 속 하는 기술 분야에서 통상의 지식을 가진 자에 의해 일반적으로 이해되는 것과 동일한 의미를 가지고 있다. 일 반적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥 상 가지는 의미와 일치하는 의 미를 가지는 것으로 해석되어야 하며, 본 출원에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적인 의미로 해석되지 않는다. 또한, 첨부 도면을 참조하여 설명함에 있어, 도면 부호에 관계없이 동일한 구성 요소는 동일한 참조부호를 부여 하고 이에 대한 중복되는 설명은 생략하기로 한다. 실시예를 설명함에 있어서 관련된 공지 기술에 대한 구체적 인 설명이 실시예의 요지를 불필요하게 흐릴 수 있다고 판단되는 경우 그 상세한 설명을 생략한다. 또한, 실시 예의 구성 요소를 설명하는 데 있어서, 제 1, 제 2, A, B, (a), (b) 등의 용어를 사용할 수 있다. 이러한 용어는 그 구성 요소를 다른 구성 요소와 구별하기 위한 것일 뿐, 그 용어에 의해 해당 구성 요소의 본 질이나 차례 또는 순서 등이 한정되지 않는다. 어떤 구성 요소가 다른 구성요소에 \"연결\", \"결합\" 또는 \"접 속\"된다고 기재된 경우, 그 구성 요소는 그 다른 구성요소에 직접적으로 연결되거나 접속될 수 있지만, 각 구성 요소 사이에 또 다른 구성 요소가 \"연결\", \"결합\" 또는 \"접속\"될 수도 있다고 이해되어야 할 것이다. 어느 하나의 실시 예에 포함된 구성요소와, 공통적인 기능을 포함하는 구성요소는, 다른 실시 예에서 동일한 명 칭을 사용하여 설명하기로 한다. 반대되는 기재가 없는 이상, 어느 하나의 실시 예에 기재한 설명은 다른 실시 예에도 적용될 수 있으며, 중복되는 범위에서 구체적인 설명은 생략하기로 한다. 도 1은 일 실시예에 따른 동형 암호 시스템을 설명하기 위한 도면이다. 도 1을 참조하면, 일 실시예에 따른 동형 암호 시스템은 클라이언트 및 서버를 주체로 포함할 수 있 다. 동형 암호 시스템은 클라이언트가 보유한 데이터를 서버에게 직접적으로 노출시키지 않으면서 서버 가 클라이언트로 인공지능 서비스를 제공하는 시스템일 수 있다. 클라이언트는 서버로부터 인공지능 서비스를 제공 받는 주체로, 서비스 이용 주체, 서비스 이용자, 데이터 소유자 등으로 지칭될 수 있다. 클라이언트는 클라이언트 단말을 통해 자신의 데이터(예를 들어, 이미지)를 동형 암호 기법에 기초하여 암호화하고, 암호화된 데이터를 서버로 전달할 수 있다. 클라이언 트 단말은 사용자 단말로 지칭될 수 있다. 동형 암호(Homomorphic encryption, HE)는 암호화된 데이터를 복호화 없이 연산할 수 있는 암호기술로, 동형 암 호화된 상태에서 각종 연산을 했을 때 그 결과가 암호화하지 않은 상태의 연산 결과와 동일하다. 동형 암호는 암호화된 상태로 데이터를 가공할 수 있기 때문에 데이터 산업에서 발생하는 프라이버시 문제를 해결할 수 있다. 서버는 클라이언트로부터 암호화된 데이터를 수신하여, 암호화된 데이터에 대응하는 인공 지능 연산 결과를 클라이언트에게 전달할 수 있으며, 서버는 서비스 제공자(service provider), 서비스 제공 주 체 등으로 지칭될 수 있다. 서버는 클라이언트로 다양한 인공 지능 서비스를 제공할 수 있다. 예를 들어, 서버는 얼굴인식 혹은 마스크 탐지 등 사용자 데이터의 기밀 유지가 중요한 서비스를 클라이언트에게 제공할 수 있다. 그 러나, 인공 지능 서비스를 제공하기 위한 연산은 많은 메모리와 네트워크 데이터 전송량을 요구한다. 예를 들 어, 합성곱 신경망 추론을 위해 데이터를 암호화 하는 과정에서 많은 동형암호 암호문 (ciphertext) 가 생기며, 이는 많은 메모리와 네트워크 데이터 전송량을 요구한다. 동형암호 연산은 덧셈과 곱셈, 그리고 같은 암호 내에서 순서를 바꾸는 회전(rotate) 연산들을 지원하며, 덧셈, 곱셈, 그리고 회전 순서대로 실행시간이 증가한다. 동형암호는 미리 지정된 다항식 차수(degree of polynomial)를 파라미터로 가지며, 이 차수는 2의 거듭제곱 꼴 이어야만 한다. 다항식 차수가 높을수록 모든 연산의 실행시간이 기하급수적으로 증가하는 단점이 있으나, 다 항식 차수가 높을수록 더 다양한 연산을 지원 가능하게 되고 계산의 정밀도가 늘어난다는 장점이 있다. 동형암호 연산은 미리 지정된 최대곱셈횟수 만큼의 동형암호 곱셈이 가능하며, 이 최대곱셉횟수가 증가할 수록 동형암호 연산 1회에 걸리는 시간이 기하급수적으로 증가한다. 동시에 이 최대곱셈횟수는 다항식 차수에 제한 이 되며, 차수가 높을수록 최대곱셈횟수 또한 늘어난다. 동형 암호 연산을 복잡도 및 메모리 사용량에 있어 평문 대비 1000배 이상의 성능 및 메모리 용량이 필요할 수 있다. 이에, 동형암호 연산을 CPU 에서 수행할 경우, 실제 응용에 사용할 수 없을 정도로 수행 시간이 느릴 수 있다. 이에, GPU 및 FPGA 등을 활용하여 동형 암호 연산을 가속하는 방식이 제안된다.격자 기반 동형 암호 연산을 위한 모놀리식(Monolithic) 가속기 아키텍처는 매우 비싸고 복잡한 제조 공정을 필 요로 할 수 있다. 또한 대형 모놀리식 아키텍처의 경우 낮은 수율이 지속적인 문제일 수 있다. 이에 대한 대 안으로, 동형 암호 연산을 가속화하기 위해 일 실시예에 따른 다중 칩렛 아키텍처(multi-chiplet architectur e)가 사용될 수 있다. 하나의 큰 칩 대신 다중 칩렛 설계를 사용할 경우, 제조 비용을 절감하고 수율을 높일 수 있다. 또한, 다중 칩렛 아케텍처를 사용할 경우, 여러 가지 구성이 가능하기 때문에 단일 테이프아웃 (single tape-out)에 유연성을 제공할 수 있다. 칩렛 아키텍처는 프로세싱 엘리먼트들(PEs; processing elements)과 메모리로 구성될 수 있다. 프로세싱 엘리 먼트들은 서로 통신할 수 있고, 외부 메모리(예를 들어, 고대역폭 메모리(HBM; High Bandwidth Memory))와 통신 할 수도 있다. 아래에서, 칩렛 기반 가속기가 뛰어난 가속을 제공하기 위해 활용할 수 있는 확장 가능한 설계 방법론을 설명한다. 칩렛은 칩을 하나의 다이로 만들지 않고, 2개 이상으로 나누어 만드는 것을 의미한다. 칩렛 시스템은 더 저렴 한 제조 요건과 높은 수율로 인해 효율적이고, 또한 단일 테이프 아웃으로 다양한 구성이 가능하므로 유연성을 제공할 수 있다. 칩렛 패키징은 크게 2D, 2.5D, 3D의 세 가지 범주로 분류할 수 있다. 2D 패키징에서는 멀티 칩 모듈(MCM; Multi-Chip Module)이라고 불리는 다양한 다이가 기판에 장착된다. 모든 다이가 동일한 평면에 있으므로 2D 패 키징이라 지칭될 수 있다. 2D 패키징은 기판 제한으로 인해 다이 간 통신이 느리고 전력 소비가 높을 수 있다. 2.5D 패키징은 다이와 기판 사이에 인터포저가 배치되고 다이-다이 연결이 인터포저에서 이루어질 수 있다. 인 터포저가 제공하는 높은 상호 연결성은 성능을 향상시킬 수 있다. 3D 패키징은 한 단계 더 발전하여 초고층 빌 딩처럼 서로 다른 다이를 쌓아 올리는 패킹을 의미한다. 3D 패키징의 다이는 TSV(Through Silicon Via)를 통해 상호 연결될 수 있다. 그 예로는 여러 개의 HBM DRAM 다이가 적층되어 있는 고대역폭 메모리(HBM; High Bandwidth Memory)가 있다. 3D 패키징은 중요 경로를 단축하므로 훨씬 더 높은 성능, 더 낮은 전력 소비 및 더 높은 대역폭을 제공할 수 있다. 일 실시예에 따른 다중 칩렛 아키텍쳐의 또 다른 이점은 이기종 패키징이 가능하다는 것이다. 이를 통해 기존 칩렛을 재사용할 수 있고 기능에 따라 다양한 칩렛을 통합할 수 있다. 다만, 칩렛 배치는 길고 복잡한 프로세 스이며, 올바르게 배치되지 않으면 칩렛-칩렛 통신은 설계 수준에서 그러한 문제가 존재하지 않더라도 잠재적인 교착 상태 문제로 이어질 수 있다. 도 2는 일 실시예에 따른 2.5D 칩렛 기반 가속기의 예시를 도시한 도면이다. 도 2에는 일 실시예에 따른 2.5D 칩렛 기반 가속기의 정면도와 2.5D 칩렛 기반 가속기의 평면도가 도 시되어 있다. 일 실시예에 따른 2.5D 칩렛 기반 가속기는 두 개의 프로세싱 엘리먼트(제1 코어 칩렛(220- 1), 제2 코어 칩렛(220-2))을 함께 연결하고 인터포저를 통해 두 개의 메모리(제1 메모리 칩렛(230-1), 제 2 메모리 칩렛(230-2))도 연결할 수 있다. 다만, 2.5D 칩렛 기반 가속기의 내부 구조는 도 2에 도시된 것 에 제한되지 않는다. 즉, 2.5D 칩렛 기반 가속기의 설계에 따라, 도 2에 도시된 구성 중 일부가 생략되거 나 새로운 구성이 더 추가될 수 있음을 본 실시 예와 관련된 기술 분야에서 통상의 지식을 가진 자라면 이해할 수 있다. 이웃하는 코어 칩렛들은 인터포저를 통해 서로 연결될 수 있다. 인터포저는 기판 상에 부착되 고, 복수의 인터포저 관통 전극을 포함할 수 있다. 일 실시예에 따른 코어 칩렛은 프로세싱 엘리먼트, 프로세싱 유닛, REED로 지칭될 수 있다. 나아가, 일 실시예 에 따른 2.5D 칩렛 기반 가속기의 메모리 역시 칩렛 형태로 구현될 수 있고, 이 때 메모리 칩렛은 고대역 폭 메모리(HBM; High Bandwidth Memory) 칩렛을 포함할 수 있다. 메모리 칩렛은 코어 칩렛 내부의 레지스터와 구분하기 위하여, 외부 메모리로 지칭될 수 있다. 칩렛 패키징은 인터포저의 특성 상 복잡한 연결이 어려울 수 있다. 따라서, 일 실시예에 따른 다중 칩렛 아키 텍쳐는 프로세싱 엘리먼트들이 메모리 칩렛을 서로 공유하지 않고, 프로세싱 엘리먼트들 사이의 연결이 단순해 야 한다. 예를 들어, 제1 코어 칩렛(220-1)과 제2 코어 칩렛(220-2)은 서로 메모리 칩렛을 공유하지 않을 수 있다. 다시 말해, 제1 메모리 칩렛(230-1)은 제1 코어 칩렛(220-1)이랑 연결되지만, 제2 코어 칩렛(220-2)과는 연결되지 않을 수 있다. 마찬가지로, 제2 메모리 칩렛(230-2)은 제2 코어 칩렛(220-2)이랑 연결되지만, 제1 코 어 칩렛(220-1)과는 연결되지 않을 수 있다.나아가, 일 실시예에 따른 2.5D 칩렛 기반 가속기는 네 개의 프로세싱 엘리먼트(제1 코어 칩렛(260-1) 내 지 제4 코어 칩렛(260-4))을 함께 연결하고 인터포저를 통해 네 개의 메모리(제1 메모리 칩렛(270-1), 제2 메모 리 칩렛(270-2), 제3 메모리 칩렛(270-3), 제4 메모리 칩렛(270-4))도 연결할 수 있다. 이 때, 제1 코어 칩렛(260-1) 내지 제4 코어 칩렛(260-4)는 링(ring) 구조 형태로 이웃하는 코어 칩렛들끼리 인 터포저를 통해 서로 연결될 수 있다. 제1 코어 칩렛(260-1), 제2 코어 칩렛(260-2), 제3 코어 칩렛(260- 4) 및 제4 코어 칩렛(260-4)이 순서대로 링 구조로 연결될 수 있다. 다시 말해, 제1 코어 칩렛(260-1)과 제3 코어 칩렛(260-3)은 제2 코어 칩렛(260-2)을 통해 연결될 뿐, 다이렉트로 연결되지 않을 수 있다. 제2 코어 칩 렛(260-2)과 제4 코어 칩렛(260-4) 사이도 마찬가지일 수 있다. 일 실시예에 따른 2.5D 칩렛 기반 가속기 역시 제1 코어 칩렛(260-1) 내지 제4 코어 칩렛(260-4)은 서로 메모리 칩렛을 공유하지 않을 수 있다. 예를 들어, 제1 메모리 칩렛(270-1)은 제1 코어 칩렛(270-1)이랑 연결 되지만, 나머지 코어 칩렛들(260-2, 260-3, 260-4)과는 연결되지 않을 수 있다. 제2 메모리 칩렛(270-2)은 제2 코어 칩렛(260-2)이랑 연결되지만, 나머지 코어 칩렛들(260-1, 260-3, 260-4)과는 연결되지 않을 수 있다. 제3 메모리 칩렛(270-3)은 제3 코어 칩렛(260-3)이랑 연결되지만, 나머지 코어 칩렛들(260-1, 260-2, 260-4)과는 연결되지 않을 수 있다. 제4 메모리 칩렛(270-4)은 제4 코어 칩렛(260-4)이랑 연결되지만, 나머지 코어 칩렛들 (260-1, 260-2, 260-3)과는 연결되지 않을 수 있다. 2.5D 칩렛 기반 가속기를 설계하는 방식을 전술한 바로 한 정하는 것은 아니다. 설계에 따라, 코어 칩렛들 및 메모리 칩렛의 개수가 달라질 수도 있다. 도 3은 일 실시예에 따른 3D 칩렛 기반 가속기의 예시를 도시한 도면이다. 도 3을 참조하면, 일 실시예에 따른 3D 칩렛 기반 가속기는 두 개의 프로세싱 엘리먼트(제1 코어 칩렛 (320-1), 제2 코어 칩렛(320-2))을 함께 연결하고, 관통 실리콘 비아(TSV)를 통해 프로세싱 엘리먼트(제1 코어 칩렛(320-1), 제2 코어 칩렛(320-2)) 위에 두 개의 메모리(제1 메모리 칩렛(330-1), 제2 메모리 칩렛 (330-2))도 연결할 수 있다. 다만, 3D 칩렛 기반 가속기의 내부 구조는 도 3에 도시된 것에 제한되지 않 는다. 즉, 3D 칩렛 기반 가속기의 설계에 따라, 도 3에 도시된 구성 중 일부가 생략되거나 새로운 구성이 더 추가될 수 있음을 본 실시 예와 관련된 기술 분야에서 통상의 지식을 가진 자라면 이해할 수 있다. 이웃하는 코어 칩렛들(제1 코어 칩렛(320-1), 제2 코어 칩렛(320-2))은 인터포저를 통해 서로 연결될 수 있다. 인터포저는 기판 상에 부착되고, 복수의 인터포저 관통 전극을 포함할 수 있다. 프로세싱 엘리먼트(제1 코어 칩렛(320-1), 제2 코어 칩렛(320-2)) 위에 두 개의 메모리(제1 메모리 칩렛(330- 1), 제2 메모리 칩렛(330-2))가 적층될 수 있다. 예를 들어, 제1 메모리 칩렛(330-1)는 TSV를 통해 제1 코어 칩렛(320-1) 위에 적층될 수 있고, 제2 메모리 칩렛(330-2)는 TSV를 통해 제2 코어 칩렛(320-2) 위 에 적층될 수 있다. 이를 통해, 프로세싱 엘리먼트들(제1 코어 칩렛(320-1), 제2 코어 칩렛(320-2)))은 메모리 (제1 메모리 칩렛(330-1), 제2 메모리 칩렛(330-2))를 서로 공유하지 않을 수 있다. 동일한 수의 칩렛을 패킹할 경우, 3D 패키징을 사용하는 것은 2.5D 패키징에 비해 칩 표면적이 감소할 수 있다. 따라서, 3D 패키징을 사용할 경우 훨씬 더 작은 인터포저와 기판도 사용할 수 있다. 3D 칩렛 기반 가속기를 설 계하는 방식을 전술한 바로 한정하는 것은 아니다. 설계에 따라, 코어 칩렛들 및 메모리 칩렛의 개수가 달라질 수도 있다. 도 4는 일 실시예에 따른 코어 칩렛의 블록도를 도시한 도면이다. 도 1 내지 도 3을 참조하여 설명한 내용은 도 4에 동일하게 적용될 수 있다. 도 4를 참조하면, 전술한 바와 같이, 일 실시예에 따른 가속기는 동형 암호 연산을 위한 가속기일 수 있다. 일 실시예에 따른 하드웨어 아키텍처는 N=N1*N2 파라미터(N, N1, N2는 2의 거듭제곱이고 N은 다항식의 크기임)에 기초하여 구성될 수 있다. N1*N2 구성의 아키텍처에서 개별 연산 유닛(Individual arithmetic units)은 사이클당 N2 계수(coefficient)의 메모리 대역폭을 필요로 하며, 초당 f/N1 연산 처리량을 제공할 수 있다(여기서 f는 설계 작동 주파수). 메모리 대역폭은 동형 암호 연산의 주요 병목 현상이므로, 일 실시예에 따른 설계(design)는 이 제약 조건에서 쉽게 확장할 수 있으며 최고의 처리량을 제공할 수 있다. 제안된 방법은 사용 가능한 리소스 및 처리량 요구 사항에 따라 N1 및 N2 값을 쉽게 구성할 수 있을 뿐만 아니라 프로토타이핑 및 검증도 용이하다. 모든 구성이 동일한 설계 및 구현 전략을 따르기 때문에 작은 구성의 기능을 검증하면 훨씬 더 큰 구성에 대한 작업 증명 (proof of work)을 제공할 수도 있다. 따라서 전체 설계에 대한 공식적인 검증이 더 간단해질 수 있다.동형 암호 연산은 덧셈 연산, 곱셈 연산, 회전(rotation) 연산의 기본 연산을 포함할 수 있다. 머신 러닝 및 통계와 같은 대부분의 애플리케이션은 이러한 기본 연산을 사용하여 평가할 수 있습니다. 동형 암호에서는 보 안을 위해 암호문에 무작위로 노이즈를 추가할 수 있다. 더 많은 연산을 수행할수록 이 노이즈는 증가하며, 이 를 줄이기 위해 부트스트래핑(bootstrapping) 연산이 필요할 수 있다. 부트스트래핑 연산은 스키마를 '완전 동 형'(FHE)으로 만든다. 일 실시예에 따른 방법은 FHE 체계를 사용하는 데 필요한 모든 구성 요소를 포함할 수 있다. 일 실시예에 따른 코어 칩렛은 잔차수 시스템(RNS; Residue Number System)으로 동형 암호화를 처리하기 위한 기본 구성 요소일 수 있다. 코어 칩렛은 최상의 라우팅 및 배치 전략을 염두에 두고 설계될 수 있다. 특히, 재선형화 연산이 가장 비용이 많이 드는 작업이기 때문에, 코어 칩렛은 높은 처리량을 보장 하도록 맞춤화되어 있을 수 있다. 곱셈 후 비선형 암호문 구성 요소는 L 다항식(각 qi RNS 베이스에 대해 1, i ≤L)으로 구성될 수 있다. 재선형 화를 위해서는 L개의 잔여 다항식을 모두 슬롯에서 계수 표현으로 변환한 다음(INTT 사용), 각 다항식을 (L+K) NTT로 변환하고 두 개의 키 구성 요소를 곱하여 누적해야 할 수 있다. 여기서 K는 키 전환 시 필요한 파이 RNS 베이스의 수다. 이 부분에는 L개의 INTT, L*(L+K) NTT, 2L*(L+K)의 곱셈과 누산이 필요할 수 있다. 이 연산 처리량은 f/(L*(1+3(L+K))*N1) 연산을 통해 줄일 수 있다. 일 실시예에 따른 코어 칩렛는 NTT 모듈을 포함할 수 있다. 가속기는 제1 MAC 모듈(420-1), 제2 MAC 모듈(420-2), 제1 자기 동형 사상 모듈(430-1), 제2 자기 동형 사상 모듈(430-2), 컨트롤러, 제1 레지스터(450-1), 제2 레지스터(450-2), 제3 레지스터(450-3), 제4 레지스터(450-4), 제5 레지스터(450-5)를 더 포함할 수 있다. 본 문서에서 사용된 용어 \"모듈\"은, 예를 들면, 하드웨어, 소프트웨어 또는 펌웨어 (firmware) 중 하나 또는 둘 이상의 조합을 포함하는 단위(unit)를 의미할 수 있다. \"모듈\"은, 예를 들면, 유 닛(unit), 로직(logic), 논리 블록(logical block), 부품(component), 또는 회로(circuit) 등의 용어와 바꾸어 사용(interchangeably use)될 수 있다. \"모듈\"은, 일체로 구성된 부품의 최소 단위 또는 그 일부가 될 수 있다. \"모듈\"은 하나 또는 그 이상의 기능을 수행하는 최소 단위 또는 그 일부가 될 수도 있다. \"모듈\"은 기 계적으로 또는 전자적으로 구현될 수 있다. 예를 들면,\"모듈\"은, 알려졌거나 앞으로 개발될, 어떤 동작들을 수 행하는 ASIC(application-specific integrated circuit) 칩, FPGAs(field-programmable gate arrays) 또는 프 로그램 가능 논리 장치(programmable-logic device) 중 적어도 하나를 포함할 수 있다. 일 실시예에 따른 NTT 모듈은 NTT 연산 및 INTT 연산을 수행할 수 있다. NTT 모듈은 NTT/INTT 모듈 로 지칭될 수 있다. NTT 모듈은 한 번에 하나의 다항식으로 작업해야 하지만, 이 결과는 두 개의 다항식 (키 스위칭 키)을 곱하여 누산될 수 있다. 따라서, 코어 칩렛은 한 쌍의 MAC 유닛(제1 MAC 모듈(420-1), 제2 MAC 모듈(420-2))을 인스턴스화하여 두 가지 키 구성 요소(key components)를 동시에 처리함으로써 NTT 모 듈의 처리량을 유지할 수 있다. 마찬가지로, 코어 칩렛은 두 개의 자기 동형 사상 모듈(제1 자기 동형 사상 모듈(430-1), 제2 자기 동형 사상 모듈(430-2))을 포함할 수 있다. 제1 자기 동형 사상 모듈(430-1) 및 제2 자기 동형 사상 모듈(430-2)은 동시에 작동할 필요가 없다. 따라서 코어 칩렛은 동일한 메모리를 사용하여 둘 다에 공급할 수 있다. 코어 칩렛은 PRNG(Pseudo Random Number Generator)를 사용해 첫 번째 키 컴포넌트를 생성하고, 두 번째 컴포넌트는 제1 레지스터(450-1)에 저장해 제1 MAC 모듈(420-1)에만 공급할 수 있다. 다이애딕 연산(dyadic operation)을 수행할 때, 제1 MAC 모듈(420-1)은 제1 레지스터(450-1) 및 제3 레지스터(450-3)에서 두 개의 입 력을 전달받을 수 있다. 하지만 제2 MAC 모듈(420-2)에 동일한 기능을 제공하기 위해 NTT/INTT 유닛용 메모리 를 연결할 수 있다. 이 설계는 명령어 기반 설계로, 컨트롤러가 멀티플렉서들을 관리하고 NTT 모듈과 MAC 모듈들 및 자기 동형 사상 모듈들 중 하나에서 완료된 신호를 수집할 수 있다. 이러한 설계 선택은 NTT 모듈과 MAC 모듈 들 및 자기 동형 사상 모듈들이 파이프라인에서 병렬로 실행될 수 있도록 보장할 수 있다. 코어 칩렛에 포함된 제1 레지스터(450-1), 제3 레지스터(450-3), 제4 레지스터(450-4), 제5 레지스터 (450-5)는 오프칩 메모리와 통신하고, 제2 레지스터(450-2)는 다른 코어 칩렛과 통신할 수 있다. 제2 레 지스터(450-2)는 INTT 결과를 저장하고 다른 PU에 전달하는 역할을 수행할 수 있다. 오프칩 메모리와 통신하는 4개의 메모리(제1 레지스터(450-1), 제3 레지스터(450-3), 제4 레지스터(450-4), 제 5 레지스터(450-5)) 중 결과를 다시 쓸 필요가 있는 메모리는 2개(제3 레지스터(450-3), 제5 레지스터(450-5))일 수 있다. 다시 말해, 온칩 및 오프칩 통신에 읽기/쓰기가 필요한 메모리는 3개로, 제2 레지스터(450-2)는 온칩 연산에 활 용되고, 제3 레지스터(450-3), 제5 레지스터(450-5)는 오프칩 메모리로 프리페치를 수행할 수 있다. 따라서 이 세 가지 메모리는 최소 두 개의 다항식 스토리지가 필요하지만 나머지 두 개는 최소 하나의 다항식 스토리지만 필요할 수 있다. 이러한 메모리는 혼잡을 피하기 위해 칩 주변과 빌딩 블록에서 멀리 떨어진 곳에 쉽게 배치할 수 있다. 그런 다음 레지스터 파일을 사용하여 메모리를 빌딩 블록과 연결할 수 있다. 따라서 고도로 간소화 되고 처리량이 높은 설계가 가능할 수 있다. 도 5는 일 실시예에 따른 코어 칩렛의 병렬 처리 기능을 설명하기 위한 도면이다. 도 5를 참조하면, 일 실시예에 따른 코어 칩렛은 곱셈 연산과 누적 연산을 동시에 수행할 수도 있다. 전 술한 바와 같이, 컨트롤러가 멀티플렉서들을 관리하고 NTT 모듈과 MAC 모듈들 및 자기 동형 사상 모 듈들 중 하나에서 완료된 신호를 수집할 수 있기 때문에, 코어 칩렛은 곱셈 연산과 누적 연산을 동시에 수 행할 수 있다. 이에, 일 실시예에 따른 코어 칩렛은 병렬 연산을 통해 2L(L + 1) 클럭 사이클을 절약할 수 있고, 처리량을 로 향상시켜 처리량이 66.7% 향상될 수 있다. 도 6a 내지 도 6b는 일 실시예에 따른 NTT 연산 방법을 설명하기 위한 도면이다. 도 6a를 참조하면, 일 실시예에 따른 NTT 모듈(예를 들어, 도 4의 NTT 모듈)은 전처리 모듈, 제1 NTT 아키텍쳐, 아다마르 유닛 및 제2 NTT 아키텍쳐를 포함할 수 있다. NTT 모듈은 NTT 연산 및 INTT 연산을 수행할 수 있다. NTT 모듈은 NTT 연산을 위한 입력 다항식을 전처리 모듈 , 제1 NTT 아키텍쳐, 아다마르 유닛 및 제2 NTT 아키텍쳐에 차례로 입력하여 NTT 연산을 수행할 수 있다. NTT 모듈은 INTT 연산을 위한 입력 다항식을 제2 NTT 아키텍쳐, 아다마르 유닛, 제 1 NTT 아키텍쳐 및 전처리 모듈에 차례로 입력하여 INTT 연산을 수행할 수 있다. 도 6b를 참조하면, NTT 연산을 위한 입력 다항식은 뎁스 N1의 N2 메모리에 저장되며, 따라서 행 순서로 N1 x N2=N 크기의 입력 행렬을 형성할 수 있다. 다시 말해, 입력 행렬은 입력 다항식의 계수(coefficients)로 구성 될 수 있다. 전처리 모듈은 계수에 대하여 전처리 연산을 수행할 수 있다. 전처리 모듈은 전처리 연산으로, 계수 에 대하여 1의 2N 거듭 제곱근을 곱하는 연산을 수행할 수 있다. 전처리 모듈은 수학식 1과 같은 전처리 연산을 수행할 수 있다. 수학식 1"}
{"patent_id": "10-2024-0029712", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "일 실시예에 따른 전처리 모듈은 N2형 모듈러 곱셈기(modular multipliers)일 수 있다. 제1 NTT 아키텍쳐는 전처리 연산이 완료된 입력 행렬의 열 성분에 대하여 제1 NTT 연산을 수행할 수 있다. 열 성분에 대하여 제1 NTT 연산을 수행하는 것은 N1-point NTT 연산으로 지칭될 수 있다. 제1 NTT 아키텍쳐 는 SDF(single delayed feedback)-NTT 아키텍쳐로 지칭될 수 있다. 제1 NTT 아키텍쳐는 파이프라인화되어 있으며 각 사이클마다 메모리에서 N2 계수를 읽을 수 있다. 제1 NTT 아키텍쳐는 제1 NTT 연산을 구성하는 스테이지(stage)에 대응하는 제1 NTT 유닛을 포함하고, 제1 NTT 아키텍쳐에 포함된 제1 NTT 유닛은 서로 독립적으로 연산 가능할 수 있다. 제1 NTT 아키텍쳐의 구체 적인 동작 방법은 아래 도 8을 참조하여 설명된다. 아다마르 유닛은 제1 NTT 연산 결과와 트위들 팩터(twiddle factor) 사이의 아다마르 곱(Hadamard product) 연산을 수행할 수 있다. 아다마르 유닛은 N2형 모듈러 곱셈기일 수 있다. 제2 NTT 아키텍쳐는 아다마르 곱 연산이 완료된 입력 행렬의 행 성분에 대하여 제2 NTT 연산을 수행할 수 있다. 행 성분에 대하여 제2 NTT 연산을 수행하는 것은 N2-point NTT 연산으로 지칭될 수 있다. 제2 NTT 아키 텍쳐는 Unrolled-NTT로 지칭될 수 있다. 제2 NTT 아키텍쳐의 구체적인 동작 방법은 아래 도 9를 참 조하여 설명된다. 도 7은 일 실시예에 따른 NTT 연산 방법의 예시를 도시한 도면이다. 도 7을 참조하면, NTT 연산을 위한 입력 다항식은 4 x 4=16 크기의 입력 행렬을 형성할 수 있다. 전처리 모듈 은 입력 행렬의 열 성분(예를 들어, M0, M1, M2, M3)에 대하여 전처리 연산을 수행할 수 있다. 전처리 모 듈은 입력 행렬의 열 성분(예를 들어, M0, M1, M2, M3) 각각에 대하여 동시에 병렬로 전처리 연산을 수행할 수 있다. 도 7에서, 행렬 성분의 숫자는 다항식의 계수 인덱스를 의미할 수 있다. 제1 NTT 아키텍쳐는 입력 행렬의 열 성분(예를 들어, M0, M1, M2, M3) 각각에 대한 NTT 연산을 수행하는 제 1 NTT 연산 유닛들로 구성될 수 있다. 예를 들어, 제1 NTT 연산 유닛들(720-1, 720-2)은 M0 열 성분에 대한 NTT 연산을 수행할 수 있고, 제1 NTT 연산 유닛들(720-3, 720-4)은 M1 열 성분에 대한 NTT 연산을 수행할 수 있 고, 제1 NTT 연산 유닛들(720-5, 720-6)은 M2 열 성분에 대한 NTT 연산을 수행할 수 있고, 제1 NTT 연산 유닛 들(720-7, 720-8)은 M3 열 성분에 대한 NTT 연산을 수행할 수 있다. 또는, 제1 NTT 아키텍쳐는 한 세트의 제1 NTT 연산 유닛들로만 구성될 수도 있다. 예를 들어, 제1 NTT 연 산 유닛들(720-1, 720-2)은 제1 싸이클에서 M0 열 성분에 대한 NTT 연산을 수행하고, 제2 싸이클에서 M1 열 성 분에 대한 NTT 연산을 수행하고, 제3 싸이클에서 M2 열 성분에 대한 NTT 연산을 수행하고, 제4 싸이클에서 M3 열 성분에 대한 NTT 연산을 수행할 수 있다. 제1 NTT 아키텍쳐를 구성하는 제1 NTT 연산 유닛들의 수는 제1 NTT 연산을 구성하는 스테이지(stage)에 기 초하여 결정될 수 있다. 도 7의 경우, 입력 행렬의 열 성분을 구성하는 계수가 4개이기 때문에, 제1 NTT 연산 은 2 스테이지로 구성될 수 있고, 따라서 제1 NTT 아키텍쳐를 구성하는 제1 NTT 연산 유닛들은 2개(예를 들어, 제1 NTT 연산 유닛들(720-1, 720-2))일 수 있다. 이때, 제1 NTT 아키텍쳐에 포함된 제1 NTT 유닛 들(예를 들어, 제1 NTT 연산 유닛들(720-1, 720-2))은 서로 독립적으로 동작 가능할 수 있다. 다시 말해, 제1 NTT 연산 유닛(720-2)의 연산 중에 제1 NTT 연산 유닛(720-1)도 연산을 수행할 수 있다. 즉, 실시간 데이터 입 력에 대해 연속적인 연산이 가능하다. 후반부의 스테이지에서 이전 입력에 대한 연산을 수행하고 있을 때, 전 반부의 스테이지에서 새로운 입력에 대한 연산을 동시에 수행하는 것이 가능할 수 있다. 아다마르 유닛은 제1 NTT 연산 결과와 트위들 팩터 사이의 아다마르 곱 연산을 수행할 수 있다. 제2 NTT 아키텍쳐는 아다마르 곱 연산이 완료된 입력 행렬의 행 성분에 대하여 제2 NTT 연산을 수행할 수 있다. 예를 들어, 제1 싸이클에서, 제1 행 성분(0, 1, 2, 3)에 대하여 제2 NTT 연산을 수행하고, 제2 싸이클에 서, 제2 행 성분(4, 5, 6, 7)에 대하여 제2 NTT 연산을 수행하고, 제3 싸이클에서, 제3 행 성분(8, 9, 10, 1 1)에 대하여 제2 NTT 연산을 수행하고, 제4 싸이클에서, 제4 행 성분(12, 13, 14, 15)에 대하여 제2 NTT 연산을 수행할 수 있다. 제2 NTT 아키텍쳐는 제2 NTT 유닛들로 구성될 수 있다. N개의 데이터를 NTT 연산 할 때 필요한 스테이지 의 수는 n = log2N이고, 각 스테이지에 필요한 제2 NTT 유닛의 수는 N/2이다. 따라서, 제2 NTT 연산은 2 스테 이지로 구성될 수 있고, 각 스테이지에 필요한 제2 NTT 유닛의 수는 2개일 수 있다. 따라서, 제2 NTT 아키텍쳐 는 제1 스테이지 연산에 필요한 2개의 제2 NTT 유닛(740-1, 740-2)과 제2 스테이지 연산에 필요한 2개의 제2 NTT 유닛(740-3, 740-4)으로 구성될 수 있다. 제1 NTT 아키텍쳐의 출력은 제2 NTT 아키텍쳐에 직접 공급될 수 있기 때문에 제1 NTT 아키텍쳐 와 제2 NTT 아키텍쳐 사이의 전치(transpose) 연산이 필요하지 않을 수 있다. 도 8은 일 실시예에 따른 제1 NTT 아키텍쳐의 동작을 설명하기 위한 도면이다 도 8을 참조하면, 일 실시예에 따른 제1 NTT 아키텍쳐는 복수의 제1 NTT 유닛들(810-1 내지 810-3)을 포함 할 수 있다. 전술한 바와 같이, 제1 NTT 아키텍쳐는 제1 NTT 연산을 구성하는 스테이지(stage)에 대응하는 제1 NTT 유 닛들(810-1 내지 810-3)을 포함할 수 있다. 예를 들어, 8개의 데이터를 NTT 연산 할 때 필요한 스테이지의 수는 3(log28)이고, 제1 NTT 유닛(810-1)은 제1 스테이지에 대응되고, 제2 NTT 유닛(810-2)는 제2 스테이지에 대응되고, 제3 NTT 유닛(810-n)은 제3 스테이지에 대응될 수 있다. 제1 NTT 유닛들(810-1 내지 810-3)은 서로 독립 적으로 연산 가능할 수 있다. 제1 NTT 유닛은 버터플라이 연산 유닛(BU; butterfly operation unit), 레지스터, 제1 멀티플렉서 및 제2 멀티 플렉서를 포함할 수 있다. 예를 들어, 제1 NTT 유닛(810-1)은 버터플라이 연산 유닛, 레지스터, 제1 멀티플렉서 및 제2 멀티플렉서를 포함할 수 있다. 제1 NTT 유닛에서 버터플라이 연산에는 두 개의 계수가 필요하며, 계수의 인덱스는 NTT 스테이지에 따라 오프셋 으로 구분될 수 있다. 예를 들어, 다항식 A에 대한 8 포인트 NTT의 첫 번째 NTT 스테이지에서, 계수 인덱스는 4의 오프셋으로 구분될 수 있다(즉, i=0,1,2,3의 경우 A[i] 및 A[i+4]로 구분됨). 두 번째 NTT 스테이지에서는 계수를 상위 및 하위 부분으로 그룹화하고(즉, A[0],A[1],A[2],A[3] 및 A[4],A[5],A[6],A[7) 각 부분의 인덱스 를 오프셋 2로 구분할 수 있다(즉, i=0,1 및 i=4,5의 경우 A[i] 및 A[i+2]). 세 번째 스테이지에서 계수는 1의 오프셋으로 분리될 수 있다. 버터플라이 유닛에 적절한 오프셋과 순서를 가진 입력을 제공하기 위해 제1 NTT 유닛은 각 버터플라이 유닛을 메모리(예를 들어, FIFO(First-in-First-out) 메모리) 및 멀티플렉서와 결합할 수 있다. 8포인트 NTT 연산을 수행한다고 가정하면, 첫 번째 스테이지는 버터플라이의 계수 인덱스가 4의 오프셋으로 분 리되어 있기 때문에 깊이 4의 메모리와 결합될 수 있다. 첫 번째 스테이지에서, 제1 NTT 유닛(810-1)은 처음 4 개의 입력 계수를 처음 4개의 사이클에서 하나씩 메모리에 가져와서 저장할 수 있다. 여기서 첫 4사이클 동안 제1 멀티플렉서은 제어 신호(sel1=0)을 에 기초하여 왼쪽에서 오는 입력 선택할 수 있다. 그런 다음 첫 번째 스테이지에서는 나머지 4개의 입력 계수를 하나씩 가져와 버터플라이 유닛으로 보내고, 자체 FIFO 메모리에서 처음 4개의 계수를 하나씩 읽어 버터플라이 유닛으로 보낼 수 있다. 이러한 방식으로 버터플라이 유닛은은 4 싸이클 동안 올바른 순서로 계수 쌍을 수신할 수 있다. 즉, 버터 플라이 유닛은은 제1 싸이클에서 FIFO의 A[0]과 입력의 A[4]를 수신하고, 제2 싸이클에서 A[1] 및 A[5]를 수신하고, 제3 싸이클에서 A[2] 및 A[6]를 수신하고, 제4 싸이클에서 A[3] 및 A[7]를 수신할 수 있다. 4 사이 클 동안, 제2 멀티플렉서는 제어 신호(sel2=1)에 기초하여 0이 아닌 입력을 선택할 수 있다. 첫 번째 스테이지에서 버터플라이 유닛의 첫 번째 출력(예: A[0]~A[3])은 다음 스테이지로 전송되고 두 번 째 출력(예: A[4]~A[7])은 나중에 다음 스테이지로 전송하기 위해 FIFO 내부에 저장될 수 있다. 이 때, 제1 멀 티플렉서는 제어 신호(sel1=1)에 기초하여 버터플라이 유닛의 출력에서 오는 입력을 선택할 수 있다. 마지막으로, 제1 NTT 유닛(810-1)은 FIFO에 다시 저장된 계수(예: A[4] ~ A[7])를 다음 스테이지에 대응하는 제 1 NTT 유닛(810-2)로 보내야 하는데, 이를 위해 계수는 FIFO에서 읽혀져 버터플라이 유닛으로 전송되고, 제2 멀티플렉서는 제어신호(sel2=0)에 기초하여 0을 선택할 수 있다. 버터플라이 유닛의 두 번째 입력이 0이므로 첫 번째 입력은 바로 출력으로 전달되어 다음 스테이지에 대응하는 제1 NTT 유닛(810-2)로 전달될 수 있다(즉, A[4]+0 = A[4]). 레지스터는 버터플라이 유닛의 출력을 동기화하는 데 사용될 수 있다. 버터플라이 유닛은 세 개의 입력 a, b, w를 받아 a+b 및 (a-b)*w를 연산할 수 있다. (a-b)*w 연산에는 곱셈 연산이 추가되므로 a+b 연산보다 오래 걸릴 수 있다. 따라서 제1 NTT 유닛(810-1)은 두 출력이 동시에 버터플라이 유닛에서 출력 될 수 있도록 a+b 연산을 저장할 수 있는 레지스터를 포함할 수 있다. 곱셈 연산은 여러 주기가 걸릴 수 있으므로, 레지스터는 복수(예를 들어, 3개)일 수 있다. 도 9는 일 실시예에 따른 제2 NTT 아키텍쳐의 동작을 설명하기 위한 도면이다. 전술한 바와 같이, N point NTT 연산은 각 스테이지에서 N/2 버터플라이 연산이 수행되는 log2N 스테이지로 구 성될 수 있다. 따라서 N point NTT에는 총 log2N*(N/2) 버터플라이 연산이 필요할 수 있다. 제2 NTT 아키텍쳐는 모든 스테이지와 모든 스테이지의 모든 버터플라이 유닛을 인스턴스화할 수 있다. 제2 NTT 아키텍쳐는 총 log2N*(N/2) 버터플라이 유닛을 사용하고 이를 서로 연결하여 N point NTT를 구현할 수 있다. 제2 NTT 아키텍쳐는 한 사이클에서 모든 입력 계수(즉, N 계수)를 취할 수 있으며 한 사이클에서 모든 출력 계 수를 생성할 수 있다. 도 9를 참조하면, N=8에 대한 제2 NTT 아키텍쳐가 예시로 도시되어 있다. ω는 8point NTT의 트위들 팩터(8차 항등근)를 의미할 수 있다. 제2 NTT 아키텍쳐는 12개의 제2 NTT 유닛으로 구성될 수 있고, 제2 NTT 유닛은 덧셈과 뺄셈 연산 뒤에 배치된 레지스터를 포함할 수 있다. 레지스터는 버터플라이 유닛의 출력을 동기화하기 위 해 배치될 수 있다. 도 9에서, 입력과 출력의 숫자는 각각 입력 및 출력 다항식의 계수 인덱스를 의미할 수 있 다. 도 10은 일 실시예에 따른 코어 칩렛 간의 데이터 교환 방법을 설명하기 위한 도면이다. 좋은 다중 칩렛 설계는 다양한 칩렛이 가능한 한 독립적인 종속성을 갖는 고유한 데이터에서 작동하도록 보장하 는 설계일 수 있다. 데이터 중복이 줄어들고 공유 메모리가 필요하지 않기 때문이다. 일 실시예에 따른 데이터 배포 방법에서 데이터(예를 들어, 키 및 암호문)는 RNS 기반에 걸쳐 배포될 수 있다. 데이터의 이러한 RNS 기반은 순서대로 그룹화(chipleti ηi+j ∀ 0 i < r and 0 ≤ j < (L+K)/r)되어서는 안 되며, 오히려 인터리브(chipleti ηj+i)되어야 한다는 점에 유의하는 것이 가장 중요할 수 있다. 곱셈의 깊이 (multiplicative depth)를 잃기 시작하면 qi RNS 베이스도 순서대로 삭제되기 때문이다. 시퀀스를 번갈아 가며 사용하지 않으면 코어 칩렛이 매우 빠르게 유휴 상태가 되어 병렬 처리의 이점을 누릴 수 없게 된다. 인터리빙 데이터 배포는 결국 모든 칩렛이 완전히 활용되도록 보장할 수 있다. 따라서 이러한 칩렛은 데이터 중복이 필 요하지 않으며 병렬로 실행할 수 있다. 데이터를 어떻게 배포하든 칩렛과 칩렛 간의 통신은 항상 필요하다. RNS 거점 간 분산은 이 문제를 줄여주지만 제거하지는 못한다. 일 실시예에 따른 코어 칩렛 간의 데이터 교환 방법(통신 방법)은 효율적인 파이프라이닝 으로 인해 클럭 주파수 저하를 일으키지 않고 더 높은 구성으로 쉽게 확장 가능할 수 있다. 통신 병목 현상을 해결하는 것은 분해된 SoC 설정에 여러 칩렛을 효율적으로 배치할 수 있는 방법을 결정하므로 특히 중요할 수 있다. 솔루션을 제시하기 전에 칩렛 간에 데이터를 교환하는 이유에 대해 설명한다. 재선형화 연산의 모듈러스 스위 치 연산을 위해 데이터 교환이 필요할 수 있다. 이는 각 칩렛이 2(r-1)L/r 잔여 다항식(residue polynomial s)을 다른 칩렛에 전달해야 함을 의미한다. 데이터는 크고 이를 교환하려면 모든 칩렛이 다른 모든 칩렛과 통 신할 수 있도록 칩렛 간의 별 구조(star-like)의 통신이 필요할 수 있다. 별 구조 통신의 경우 r 값이 증가함 에 따라 복잡해지고 비용이 많이 들 수 있다. 일 실시예에 따른 데이터 교환 방법은 결과가 동일한 칩렛 내에 있도록 INTT 결과를 칩렛에 전달할 수 있다. 일 실시예에 따른 데이터 교환 방법은 여러 칩렛 사이에 큰 파란색 직사각형으로 표시된 긴 통신 윈도우를 사용 할 수 있다. 일 실시예에 따른 윈도우는 칩렛 시스템에서 한 칩렛에서 다음 칩렛으로 데이터를 전송하는 데 사용되는 시간 슬롯을 설명하는 데 사용될 수 있다. 통신 윈도우는 하드웨어 모듈이 아니라 최적화된 데이터 전송이 허용되는 특정 시간대를 의미할 수 있다. 통신 윈도우의 수는 완전 동형 암호 체계의 RNS-limbs 수와 시스템에서 사용되 는 칩렛 수에 따라 결정될 수 있다. 예를 들어 REED0에서 REED3까지 4개의 칩렛이 있는 시스템을 가정하면, 각 칩렛은 할당된 RNS-limb로 시작하여 INTT를 계산한 다음 NTT를 수행할 수 있다. 칩렛은 NTT를 수행하는 동안 INTT 결과를 송수신하기 시작할 수 있 다. 예를 들어, REED0은 INTT 결과를 REED3에 전송하고 REED1로부터 INTT 결과를 수신할 수 있다. 이를 통해 단방향 링 기반 통신이 가능할 수 있다. 위 예시에서, 링은 4개의 칩렛으로 구성될 수 있다. 모든 (L+1)/r NTT에 대해 하나의 INTT 결과만 브로드캐스트하면 되는데, 여기서 L+1은 RNS limb의 수이고 r은 REED 칩렛의 수일 수 있다. 주어진 칩렛 대 칩렛 또는 REEDi+1 대 REEDi 통신 속도에 대해 하나의 INTT 결과를 다음 칩렛으로 전송하는 데 필요한 시간을 tcomm이라고 할 수 있다. (L+1)/r NTT를 계산하는 데 걸리는 시간을 tcomp라 할 수 있다. 윈도우 길이는 min(tcomm, tcomp)일 수 있다. 효율적인 계산-통신 병렬화는 tcomm tcomp일 때 달성될 수 있다. 칩렛 수(r)가 커지면 윈도우 길이가 작아지므로 계산-통신 병렬성을 가지려면 칩렛 간 통신 속도가 더 빨라야 한다. 따라서 칩렛 간 통신이 온칩 통신/계산만큼 빠르지 않은 경우 이 긴 통신 윈도우는 칩렛에 데이터가 부족하지 않도록 보장할 수 있다. 결론적으로, 일 실시예에 따른 통신 방식을 사용하면 데이터의 절반을 전송해야 할 뿐 만 아니라 칩렛당 하나의 읽기/쓰기 포트만 필요할 수 있다. 또한, 통신 윈도우를 사용함으로써 더 느린 칩렛- 칩렛 통신의 실제 가능성을 극복할 수 있고, 비차단 통신을 통해 교착 상태 가능성도 제거할 수 있다.도 11a 내지 도 11c는 일 실시예에 따른 칩렛 아키텍쳐의 예시를 도시한 도면이다. 도 11a를 참조하면, 일 실시예에 따른 4개의 프로세싱 유닛(1110-1 내지 1110-4)은 링 구조로 연결될 수 있고, 각각의 프로세싱 유닛 위에 두 개의 메모리들(예를 들어, HBM, LPDDR)이 적층될 수 있다. 도 11b를 참조하면, 일 실시예에 따른 4개의 프로세싱 유닛(1120-1 내지 1120-4)은 링 구조로 연결될 수 있다. 프로세싱 유닛들에는 서로 다른 수, 구조의 메모리들이 적층될 수 있다. 예를 들어, 제1 프로세싱 유닛(1120- 1) 위에는 두 세트의 메모리가 적층될 수 있고, 각 세트는 3개의 적층된 메모리로 구성될 수 있다. 제2 프로세 싱 유닛(1120-2) 위에는 두 세트의 메모리가 적층될 수 있고, 제1 세트는 3개의 적층된 메모리로 구성되고, 재2 세트는 1개의 메모리로 구성될 수 있다. 제3 프로세싱 유닛(1120-3) 위에는 두 세트의 메모리가 적층될 수 있 고, 제1 세트는 2개의 적층된 메모리로 구성되고, 재2 세트는 1개의 메모리로 구성될 수 있다. 제4 프로세싱 유닛(1120-4) 위에는 두 세트의 메모리가 적층될 수 있고, 제1 세트는 33개의 적층된 메모리로 구성되고, 재2 세트는 2개의 메모리로 구성될 수 있다. 도 11c를 참조하면, 일 실시예에 따른 서로 다른 종류(Heterogeneous)의 코어 칩렛들이 링 구조로 연결될 수 있 다. 예를 들어, CPU(1130-1), NPU(1130-2), HE PU(1130-3), GPU(1130-4)가 링 구조로 연결될 수 있다. 실시예에 따른 방법은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 상기 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등 을 단독으로 또는 조합하여 포함할 수 있다. 상기 매체에 기록되는 프로그램 명령은 실시예를 위하여 특별히 설계되고 구성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판 독 가능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD-ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disk)와 같은 자기-광 매체 (magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도 록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다. 상기된 하드웨어 장치는 실시예의 동작을 수행하기 위해 하나 이상의 소프트웨어 모듈로서 작동하도 록 구성될 수 있으며, 그 역도 마찬가지이다. 소프트웨어는 컴퓨터 프로그램(computer program), 코드(code), 명령(instruction), 또는 이들 중 하나 이상의 조합을 포함할 수 있으며, 원하는 대로 동작하도록 처리 장치를 구성하거나 독립적으로 또는 결합적으로 (collectively) 처리 장치를 명령할 수 있다. 소프트웨어 및/또는 데이터는, 처리 장치에 의하여 해석되거나 처리 장치에 명령 또는 데이터를 제공하기 위하여, 어떤 유형의 기계, 구성요소(component), 물리적 장치, 가상 장치(virtual equipment), 컴퓨터 저장 매체 또는 장치, 또는 전송되는 신호 파(signal wave)에 영구적으로, 또는 일시적으로 구체화(embody)될 수 있다. 소프트웨어는 네트워크로 연결된 컴퓨터 시스템 상에 분산되어서, 분산된 방법으로 저장되거나 실행될 수도 있다. 소프트웨어 및 데이터는 하나 이상의 컴퓨터 판독 가능 기록 매 체에 저장될 수 있다."}
{"patent_id": "10-2024-0029712", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "이상과 같이 실시예들이 비록 한정된 도면에 의해 설명되었으나, 해당 기술분야에서 통상의 지식을 가진 자라면 상기를 기초로 다양한 기술적 수정 및 변형을 적용할 수 있다. 예를 들어, 설명된 기술들이 설명된 방법과 다 른 순서로 수행되거나, 및/또는 설명된 시스템, 구조, 장치, 회로 등의 구성요소들이 설명된 방법과 다른 형태 로 결합 또는 조합되거나, 다른 구성요소 또는 균등물에 의하여 대치되거나 치환되더라도 적절한 결과가 달성될 수 있다. 그러므로, 다른 구현들, 다른 실시예들 및 특허청구범위와 균등한 것들도 후술하는 청구범위의 범위에 속한다. 도면 도면1 도면2 도면3 도면4 도면5 도면6a 도면6b 도면7 도면8 도면9 도면10 도면11a 도면11b 도면11c"}
{"patent_id": "10-2024-0029712", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일 실시예에 따른 동형 암호 시스템을 설명하기 위한 도면이다. 도 2는 일 실시예에 따른 2.5D 칩렛 기반 가속기의 예시를 도시한 도면이다. 도 3은 일 실시예에 따른 3D 칩렛 기반 가속기의 예시를 도시한 도면이다. 도 4는 일 실시예에 따른 코어 칩렛의 블록도를 도시한 도면이다. 도 5는 일 실시예에 따른 코어 칩렛의 병렬 처리 기능을 설명하기 위한 도면이다. 도 6a 내지 도 6b는 일 실시예에 따른 NTT 연산 방법을 설명하기 위한 도면이다. 도 7은 일 실시예에 따른 NTT 연산 방법의 예시를 도시한 도면이다. 도 8은 일 실시예에 따른 제1 NTT 아키텍쳐의 동작을 설명하기 위한 도면이다 도 9는 일 실시예에 따른 제2 NTT 아키텍쳐의 동작을 설명하기 위한 도면이다. 도 10은 일 실시예에 따른 코어 칩렛 간의 데이터 교환 방법을 설명하기 위한 도면이다. 도 11a 내지 도 11c는 일 실시예에 따른 칩렛 아키텍쳐의 예시를 도시한 도면이다."}
