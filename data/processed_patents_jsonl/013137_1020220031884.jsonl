{"patent_id": "10-2022-0031884", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0134741", "출원번호": "10-2022-0031884", "발명의 명칭": "뉴럴 프로세싱 장치 및 이에 포함되는 프로세싱 엘리먼트", "출원인": "리벨리온 주식회사", "발명자": "오진욱"}}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "제1 및 제2 CGRA 엔진 그룹(CGRA Engine Group);상기 제1 및 제2 CGRA 엔진 그룹이 공유하는 L2 메모리;상기 L2 메모리, 상기 제1 및 제2 CGRA 엔진 그룹 사이의 데이터를 전송하는 L2 인터커넥션; 및상기 제1 및 제2 CGRA 엔진 그룹에 대해 개별적으로 하드웨어 리소스를 제공하는 시퀀서를 포함하고,상기 제1 CGRA 엔진 그룹은,적어도 하나의 제1 CGRA 엔진(CGRA Engine)와,상기 적어도 하나의 제1 CGRA 엔진이 공유하는 제1 L1 메모리와,상기 제1 L1 메모리 및 상기 적어도 하나의 제1 CGRA 엔진 사이의 데이터를 전송하는 제1 L1 인터커넥션을 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서,상기 시퀀서는 상기 적어도 하나의 제1 CGRA 엔진, 상기 L2 인터커넥션 및 상기 L2 메모리 중 적어도 하나에 대한 모니터링 정보를 수신하고,상기 모니터링 정보에 따라 상기 하드웨어 리소스를 개별적으로 제공하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1 항에 있어서,상기 제1 L1 인터커넥션의 레이턴시 민감도는 상기 L2 인터커넥션의 레이턴시 민감도보다 높은,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1 항에 있어서,상기 L2 인터커넥션의 밴드위스는 상기 제1 L1 인터커넥션의 밴드위스보다 큰,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1 항에 있어서,상기 제1 및 제2 CGRA 엔진 그룹을 포함하고, 상기 제1 및 제2 CGRA 엔진 그룹 사이의 로컬 인터커넥션을 포함공개특허 10-2023-0134741-3-하는 제1 CGRA 엔진 클러스터를 더 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5 항에 있어서,상기 제1 CGRA 엔진 클러스터와 다른 제2 CGRA 엔진 클러스터를 더 포함하고,상기 제2 CGRA 엔진 클러스터는 상기 제1 및 제2 CGRA 엔진 그룹과 다른 제3 CGRA 엔진 그룹을 포함하고,상기 시퀀서는,상기 제1 CGRA 엔진 클러스터를 관리하는 제1 시퀀서와,상기 제2 CGRA 엔진 클러스터에 관리하는 제2 시퀀서를 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6 항에 있어서,상기 시퀀서는,상기 적어도 하나의 제1 CGRA 엔진 각각을 관리하는 적어도 하나의 제1 하부 시퀀서와,상기 적어도 하나의 제2 CGRA 엔진 각각을 관리하는 적어도 하나의 제2 하부 시퀀서를 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1 항에 있어서,상기 제1 CGRA 엔진 클러스터는 상기 제1 및 제2 CGRA 엔진 그룹과 다른 제4 CGRA 엔진 그룹을 포함하고, 상기제1 및 제2 CGRA 엔진 그룹은 제1 영역에 속하고, 상기 제4 CGRA 엔진 그룹은 제2 영역에 속하고,상기 시퀀서는,상기 제1 및 제2 CGRA 엔진 그룹을 관리하는 제3 시퀀서와,상기 제4 CGRA 엔진 그룹을 관리하는 제4 시퀀서를 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1 항에 있어서,상기 적어도 하나의 제1 CGRA 엔진 각각은 CGRA(Coarse-Grained Reconfigurable Architectures) 구조를 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "공개특허 10-2023-0134741-4-제9 항에 있어서,상기 적어도 하나의 제1 CGRA 엔진은,복수의 프로세싱 엘리먼트를 포함하는 PE 어레이와,상기 프로세싱 엘리먼트에 입력되는 입력 데이터와, 상기 프로세싱 엘리먼트로부터 출력되는 출력 데이터를 저장하는 L0 메모리와,상기 프로세싱 엘리먼트의 동작에 대한 인스트럭션을 제공하는 인스트럭션 메모리를 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10 항에 있어서,상기 PE 어레이는, 상기 프로세싱 엘리먼트와 다른 특정 프로세싱 엘리먼트를 더 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제1 항에 있어서,상기 L2 인터커넥션은 확장 가능한,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "복수의 프로세싱 엘리먼트를 포함하는 PE 어레이와, 상기 PE 어레이에 대한 데이터를 저장하는 L0 메모리와, 상기 복수의 프로세싱 엘리먼트의 동작에 대한 인스트럭션을 제공하는 인스트럭션 메모리 및 상기 데이터에 대한로드 및 스토어를 수행하는 LSU(Load Store Unit)을 각각 포함하는 적어도 하나의 제1 CGRA 엔진;상기 적어도 하나의 제1 CGRA 엔진이 공유하는 제1 L1 메모리; 및상기 제1 L1 메모리 및 상기 적어도 하나의 제1 CGRA 엔진 사이의 데이터를 전송하는 제1 L1 인터커넥션을 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13 항에 있어서,상기 적어도 하나의 제1 CGRA 엔진은 시퀀서에 의해서 관리되고,상기 시퀀서는 중요도에 따라 상기 적어도 하나의 제1 CGRA 엔진에 개별적으로 하드웨어 리소스를 제공하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14 항에 있어서,상기 제1 CGRA 엔진은 제1 CGRA 엔진 그룹에 포함되고,공개특허 10-2023-0134741-5-상기 시퀀서는 적어도 하나의 제2 CGRA 엔진을 관리하고,상기 적어도 하나의 제2 CGRA 엔진은 상기 제1 CGRA 엔진 그룹과 다른 제2 CGRA 엔진 그룹에 포함되는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15 항에 있어서,상기 시퀀서는,상기 제1 CGRA 엔진 그룹을 관리하는 상부 시퀀서와,상기 상부 시퀀서와 연계되고, 상기 적어도 하나의 제1 CGRA 엔진을 제어하는 제1 하부 시퀀서와,상기 상부 시퀀서와 연계되고, 상기 적어도 하나의 제2 CGRA 엔진을 제어하는 제2 하부 시퀀서를 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제13 항에 있어서,상기 프로세싱 엘리먼트는,프리시젼을 포함하는 인스트럭션을 수신하고 분할하는 인스트럭션 큐와,상기 프리시젼을 통해서 프리시젼 컨버전을 수행하는 인풋 포매터 및 아웃풋 포매터를 포함하는,뉴럴 프로세싱 장치."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "CGRA 엔진에 하나 이상 포함되는 프로세싱 엘리먼트로서, 상기 CGRA 엔진은 CGRA 엔진 그룹에 하나 이상 포함되고, 상기 CGRA 엔진 그룹은 시퀀서에 의해서 개별적으로 하드웨어 리소스를 제공받는, 프로세싱 엘리먼트에 있어서,인스트럭션 세트 아키텍쳐를 수신하는 인스트럭션 큐로서, 상기 인스트럭션 세트 아키텍쳐는 프리시젼, 소스,오피코드 및 데스티네이션을 포함하는, 인스트럭션 큐;상기 인스트럭션 큐로부터, 상기 소스 및 상기 프리시젼을 수신하는 제1 레지스터;상기 제1 레지스터를 통해서 피연산자를 확정하고 프리시젼 컨버팅을 수행하는 인풋 포매터;상기 인스트럭션 큐로부터, 상기 오피코드를 수신하여 연산자를 확정하는 제2 레지스터; 및상기 인스트럭션 큐로부터, 상기 데스티네이션을 및 상기 프리시젼을 수신하는 제3 레지스터를 포함하는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제18 항에 있어서,상기 제3 레지스터를 통해서 상기 피연산자의 상기 연산자에 따른 출력의 프리시젼 컨버팅을 수행하는 아웃풋포매터를 더 포함하는,공개특허 10-2023-0134741-6-프로세싱 엘리먼트."}
{"patent_id": "10-2022-0031884", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제19 항에 있어서,상기 인풋 포매터는 상기 아웃풋 포매터에 의해서 상기 출력을 바이패스로 수신하는,프로세싱 엘리먼트."}
{"patent_id": "10-2022-0031884", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명은 뉴럴 프로세싱 장치 및 이에 포함되는 프로세싱 엘리먼트를 개시한다. 상기 뉴럴 프로세싱 장치는, 제 1 및 제2 CGRA 엔진 그룹, 상기 제1 및 제2 CGRA 엔진 그룹이 공유하는 L2 메모리, 상기 L2 메모리, 상기 제1 및 제2 CGRA 엔진 그룹 사이의 데이터를 전송하는 L2 인터커넥션 및 상기 제1 및 제2 CGRA 엔진 그룹에 대해 개 별적으로 하드웨어 리소스를 제공하는 시퀀서를 포함하고, 상기 제1 CGRA 엔진 그룹은, 적어도 하나의 제1 CGRA 엔진(CGRA Engine)와, 상기 적어도 하나의 제1 CGRA 엔진이 공유하는 제1 L1 메모리와, 상기 제1 L1 메모리 및 상기 적어도 하나의 제1 CGRA 엔진 사이의 데이터를 전송하는 제1 L1 인터커넥션을 포함한다."}
{"patent_id": "10-2022-0031884", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 뉴럴 프로세싱 장치 및 이에 포함되는 프로세싱 엘리먼트에 관한 것이다. 구체적으로, 본 발명은 계 층적 구조로 재구성 및 확장이 가능한 뉴럴 프로세싱 장치 및 이에 포함되는 프로세싱 엘리먼트에 관한 것이다."}
{"patent_id": "10-2022-0031884", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "지난 몇년간, 인공지능(Artificial Intelligence) 기술은 4차 산업혁명의 핵심 기술로 전세계적으로 가장 유망 한 기술로 거론되고 있다. 이러한 인공지능 기술의 가장 큰 문제는 컴퓨팅 성능이다. 인간의 학습능력과 추론능 력, 지각능력, 자연언어의 이행능력 등을 실현해내는 인공지능 기술은 많은 데이터를 빠르게 처리하는 것이 가 장 중요하다. 초기 인공지능의 딥러닝 학습과 추론에는 기성 컴퓨터의 중앙처리장치(CPU; Central processing unit)나 그래픽 처리장치(GPU; Graphics Processing Unit)가 쓰였지만, 높은 워크 로드를 가지는 딥러닝 학습 및 추론의 작업에 는 한계가 있어 구조적으로 딥러닝 작업에 특화된 신경망 처리 장치(NPU; Neural Processing Unit)가 각광받고 있다. 이러한 신경망 처리 장치는 내부에 많은 수의 프로세싱 엘리먼트와 프로세서 구조를 포함하고 있고, 각각의 구 조가 작업에 최적화되어 수행할 수 있도록 여러 레벨의 계층적 구조를 가질 수 있다. 이러한 계층적 구조는 딥 러닝 작업에 최적화된 단위로 구성될 때 가장 높은 효율을 발휘할 수 있다. 선행기술문헌 특허문헌 (특허문헌 0001) 등록특허공보 제10-2258566호"}
{"patent_id": "10-2022-0031884", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명의 과제는, 딥러닝 작업에 최적화된 단위 구성을 가지고, 확장 및 재구성 가능하게 계층적 구조를 가지 는 뉴럴 프로세싱 장치를 제공하는 것이다. 또한, 본 발명의 다른 과제는, 딥러닝 작업에 최적화된 단위 구성을 가지고, 확장 및 재구성 가능하게 계층적 구조를 가지는 뉴럴 프로세싱 장치에 포함되는 프로세싱 엘리먼트를 제공하는 것이다. 본 발명의 목적들은 이상에서 언급한 목적으로 제한되지 않으며, 언급되지 않은 본 발명의 다른 목적 및 장점들 은 하기의 설명에 의해서 이해될 수 있고, 본 발명의 실시예에 의해 보다 분명하게 이해될 것이다. 또한, 본 발 명의 목적 및 장점들은 특허 청구 범위에 나타낸 수단 및 그 조합에 의해 실현될 수 있음을 쉽게 알 수 있을 것 이다."}
{"patent_id": "10-2022-0031884", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "상기 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 뉴럴 프로세싱 장치는, 제1 및 제2 CGRA 엔진 그룹, 상기 제1 및 제2 CGRA 엔진 그룹이 공유하는 L2 메모리, 상기 L2 메모리, 상기 제1 및 제2 CGRA 엔진 그룹 사이 의 데이터를 전송하는 L2 인터커넥션 및 상기 제1 및 제2 CGRA 엔진 그룹에 대해 개별적으로 하드웨어 리소스를 제공하는 시퀀서를 포함하고, 상기 제1 CGRA 엔진 그룹은, 적어도 하나의 제1 CGRA 엔진(CGRA Engine)와, 상기 적어도 하나의 제1 CGRA 엔진이 공유하는 제1 L1 메모리와, 상기 제1 L1 메모리 및 상기 적어도 하나의 제1 CGRA 엔진 사이의 데이터를 전송하는 제1 L1 인터커넥션을 포함한다. 또한, 상기 시퀀서는 상기 적어도 하나의 제1 CGRA 엔진, 상기 L2 인터커넥션 및 상기 L2 메모리 중 적어도 하 나에 대한 모니터링 정보를 수신하고, 상기 모니터링 정보에 따라 상기 하드웨어 리소스를 개별적으로 제공할 수 있다. 또한, 상기 제1 L1 인터커넥션의 레이턴시 민감도는 상기 L2 인터커넥션의 레이턴시 민감도보다 높을 수 있다. 또한, 상기 L2 인터커넥션의 밴드위스는 상기 제1 L1 인터커넥션의 밴드위스보다 클 수 있다. 또한, 상기 제1 및 제2 CGRA 엔진 그룹을 포함하고, 상기 제1 및 제2 CGRA 엔진 그룹 사이의 로컬 인터커넥션을 포함하는 제1 CGRA 엔진 클러스터를 더 포함할 수 있다. 또한, 상기 제1 CGRA 엔진 클러스터와 다른 제2 CGRA 엔진 클러스터를 더 포함하고, 상기 제2 CGRA 엔진 클러스 터는 상기 제1 및 제2 CGRA 엔진 그룹과 다른 제3 CGRA 엔진 그룹을 포함하고, 상기 시퀀서는, 상기 제1 CGRA 엔진 클러스터를 관리하는 제1 시퀀서와, 상기 제2 CGRA 엔진 클러스터에 관리하는 제2 시퀀서를 포함할 수 있 다. 또한, 상기 시퀀서는, 상기 적어도 하나의 제1 CGRA 엔진 각각을 관리하는 적어도 하나의 제1 하부 시퀀서와, 상기 적어도 하나의 제2 CGRA 엔진 각각을 관리하는 적어도 하나의 제2 하부 시퀀서를 포함할 수 있다. 또한, 상기 제1 CGRA 엔진 클러스터는 상기 제1 및 제2 CGRA 엔진 그룹과 다른 제4 CGRA 엔진 그룹을 포함하고, 상기 제1 및 제2 CGRA 엔진 그룹은 제1 영역에 속하고, 상기 제4 CGRA 엔진 그룹은 제2 영역에 속하고, 상기 시 퀀서는, 상기 제1 및 제2 CGRA 엔진 그룹을 관리하는 제3 시퀀서와, 상기 제4 CGRA 엔진 그룹을 관리하는 제4 시퀀서를 포함할 수 있다. 또한, 상기 적어도 하나의 제1 CGRA 엔진 각각은 CGRA(Coarse-Grained Reconfigurable Architectures) 구조를 포함할 수 있다. 또한, 상기 적어도 하나의 제1 CGRA 엔진은, 복수의 프로세싱 엘리먼트를 포함하는 PE 어레이와, 상기 프로세싱 엘리먼트에 입력되는 입력 데이터와, 상기 프로세싱 엘리먼트로부터 출력되는 출력 데이터를 저장하는 L0 메모 리와, 상기 프로세싱 엘리먼트의 동작에 대한 인스트럭션을 제공하는 인스트럭션 메모리를 포함할 수 있다. 또한, 상기 PE 어레이는, 상기 프로세싱 엘리먼트와 다른 특정 프로세싱 엘리먼트를 더 포함할 수 있다. 또한, 상기 L2 인터커넥션은 확장 가능할 수 있다. 상기 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 뉴럴 프로세싱 장치는, 복수의 프로세싱 엘리먼트를 포함하는 PE 어레이와, 상기 PE 어레이에 대한 데이터를 저장하는 L0 메모리와, 상기 복수의 프로세싱 엘리먼트 의 동작에 대한 인스트럭션을 제공하는 인스트럭션 메모리 및 상기 데이터에 대한 로드 및 스토어를 수행하는 LSU(Load Store Unit)을 각각 포함하는 적어도 하나의 제1 CGRA 엔진, 상기 적어도 하나의 제1 CGRA 엔진이 공 유하는 제1 L1 메모리 및 상기 제1 L1 메모리 및 상기 적어도 하나의 제1 CGRA 엔진 사이의 데이터를 전송하는 제1 L1 인터커넥션을 포함할 수 있다. 또한, 상기 적어도 하나의 제1 CGRA 엔진은 시퀀서에 의해서 관리되고, 상기 시퀀서는 중요도에 따라 상기 적어 도 하나의 제1 CGRA 엔진에 개별적으로 하드웨어 리소스를 제공할 수 있다. 또한, 상기 제1 CGRA 엔진은 제1 CGRA 엔진 그룹에 포함되고, 상기 시퀀서는 적어도 하나의 제2 CGRA 엔진을 관 리하고, 상기 적어도 하나의 제2 CGRA 엔진은 상기 제1 CGRA 엔진 그룹과 다른 제2 CGRA 엔진 그룹에 포함될 수 있다.또한, 상기 시퀀서는, 상기 제1 CGRA 엔진 그룹을 관리하는 상부 시퀀서와, 상기 상부 시퀀서와 연계되고, 상기 적어도 하나의 제1 CGRA 엔진을 제어하는 제1 하부 시퀀서와, 상기 상부 시퀀서와 연계되고, 상기 적어도 하나 의 제2 CGRA 엔진을 제어하는 제2 하부 시퀀서를 포함할 수 있다. 또한, 상기 프로세싱 엘리먼트는, 프리시젼을 포함하는 인스트럭션을 수신하고 분할하는 인스트럭션 큐와, 상기 프리시젼을 통해서 프리시젼 컨버전을 수행하는 인풋 포매터 및 아웃풋 포매터를 포함할 수 있다. 상기 다른 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 프로세싱 엘리먼트는, CGRA 엔진에 하나 이상 포함되는 프로세싱 엘리먼트로서, 상기 CGRA 엔진은 CGRA 엔진 그룹에 하나 이상 포함되고, 상기 CGRA 엔진 그 룹은 시퀀서에 의해서 개별적으로 하드웨어 리소스를 제공받는, 프로세싱 엘리먼트에 있어서, 인스트럭션 세트 아키텍쳐를 수신하는 인스트럭션 큐로서, 상기 인스트럭션 세트 아키텍쳐는 프리시젼, 소스, 오피코드 및 데스 티네이션을 포함하는, 인스트럭션 큐, 상기 인스트럭션 큐로부터, 상기 소스 및 상기 프리시젼을 수신하는 제1 레지스터, 상기 제1 레지스터를 통해서 피연산자를 확정하고 프리시젼 컨버팅을 수행하는 인풋 포매터, 상기 인 스트럭션 큐로부터, 상기 오피코드를 수신하여 연산자를 확정하는 제2 레지스터 및 상기 인스트럭션 큐로부터, 상기 데스티네이션을 및 상기 프리시젼을 수신하는 제3 레지스터를 포함한다. 또한, 상기 제3 레지스터를 통해서 상기 피연산자의 상기 연산자에 따른 출력의 프리시젼 컨버팅을 수행하는 아 웃풋 포매터를 더 포함할 수 있다. 또한, 상기 인풋 포매터는 상기 아웃풋 포매터에 의해서 상기 출력을 바이패스로 수신할 수 있다."}
{"patent_id": "10-2022-0031884", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명의 뉴럴 프로세싱 장치는 딥러닝 작업에 사용되는 연산에 최적화된 스케일의 프로세싱 단위를 가지고 있 어서 작업에 따른 확장과 재구성의 효율이 극대화될 수 있다. 또한, 프로세싱 엘리먼트가 내부에서 프리시젼 컨버전을 수행하므로 하드웨어 오버헤드를 최소화하고 전체 연산 작업의 속도를 증대시킬 수 있다. 상술한 내용과 더불어 본 발명의 구체적인 효과는 이하"}
{"patent_id": "10-2022-0031884", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 명세서 및 특허청구범위에서 사용된 용어나 단어는 일반적이거나 사전적인 의미로 한정하여 해석되어서는 아 니된다. 발명자가 그 자신의 발명을 최선의 방법으로 설명하기 위해 용어나 단어의 개념을 정의할 수 있다는 원 칙에 따라, 본 발명의 기술적 사상과 부합하는 의미와 개념으로 해석되어야 한다. 또한, 본 명세서에 기재된 실 시예와 도면에 도시된 구성은 본 발명이 실현되는 하나의 실시예에 불과하고, 본 발명의 기술적 사상을 전부 대 변하는 것이 아니므로, 본 출원시점에 있어서 이들을 대체할 수 있는 다양한 균등물과 변형 및 응용 가능한 예 들이 있을 수 있음을 이해하여야 한다. 본 명세서 및 특허청구범위에서 사용된 제1, 제2, A, B 등의 용어는 다양한 구성요소들을 설명하는데 사용될 수 있지만, 상기 구성요소들은 상기 용어들에 의해 한정되어서는 안 된다. 상기 용어들은 하나의 구성요소를 다른 구성요소로부터 구별하는 목적으로만 사용된다. 예를 들어, 본 발명의 권리 범위를 벗어나지 않으면서 제1 구성 요소는 제2 구성요소로 명명될 수 있고, 유사하게 제2 구성요소도 제1 구성요소로 명명될 수 있다. '및/또는' 이라는 용어는 복수의 관련된 기재된 항목들의 조합 또는 복수의 관련된 기재된 항목들 중의 어느 항목을 포함 한다. 본 명세서 및 특허청구범위에서 사용된 용어는 단지 특정한 실시 예를 설명하기 위해 사용된 것으로, 본 발명을 한정하려는 의도가 아니다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 출원에서 \"포함하다\" 또는 \"가지다\" 등의 용어는 명세서상에 기재된 특징, 숫자, 단계, 동작, 구성요소, 부 품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않는 것으로 이해되어야 한다. 다르게 정의되지 않는 한, 기술적이거나 과학적인 용어를 포함해서 여기서 사용되는 모든 용어들은 본 발명이 속하는 기술 분야에서 통상의 지식을 가진 자에 의해서 일반적으로 이해되는 것과 동일한 의미를 가지고 있다. 일반적으로 사용되는 사전에 정의되어 있는 것과 같은 용어들은 관련 기술의 문맥상 가지는 의미와 일치하는 의 미를 가지는 것으로 해석되어야 하며, 본 출원에서 명백하게 정의하지 않는 한, 이상적이거나 과도하게 형식적 인 의미로 해석되지 않는다. 또한, 본 발명의 각 실시예에 포함된 각 구성, 과정, 공정 또는 방법 등은 기술적으로 상호 간 모순되지 않는 범위 내에서 공유될 수 있다. 이하, 도 1 내지 도 30을 참조하여, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치를 설명한다. 도 1은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템을 설명하기 위한 블록도이다. 도 1을 참조하면, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템(NPS)은 제1 뉴럴 프로세싱 장치, 제2 뉴럴 프로세싱 장치 및 외부 인터페이스를 포함할 수 있다. 제1 뉴럴 프로세싱 장치는 인공 신경망을 이용하여 연산을 수행하는 장치일 수 있다. 제1 뉴럴 프로세싱 장 치는 예를 들어, 딥 러닝(deep learning) 연산 작업을 수행하는 것에 특화된 장치일 수 있다. 단, 본 실시예 가 이에 제한되는 것은 아니다. 제2 뉴럴 프로세싱 장치는 제1 뉴럴 프로세싱 장치와 동일 내지 유사한 구성을 가지는 장치일 수 있다. 제1 뉴럴 프로세싱 장치 및 제2 뉴럴 프로세싱 장치는 서로 외부 인터페이스를 통해서 연결되어 데이 터 및 제어 신호를 공유할 수 있다. 도 1에서는 2개의 뉴럴 프로세싱 장치를 도시하였지만, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템 (NPS)이 이에 제한되는 것은 아니다. 즉, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템(NPS)은 3개 이 상의 뉴럴 프로세싱 장치가 외부 인터페이스를 통해서 서로 연결될 수도 있다. 또한, 반대로, 본 발명의 몇 몇 실시예들에 따른 뉴럴 프로세싱 시스템(NPS)은 하나의 뉴럴 프로세싱 장치만을 포함할 수도 있다. 도 2는 도 1의 뉴럴 프로세싱 장치를 세부적으로 설명하기 위한 블록도이다. 도 2를 참조하면, 제1 뉴럴 프로세싱 장치는 뉴럴 코어 SoC, CPU, 오프 칩 메모리, 제1 비휘발 성 메모리 인터페이스, 제1 휘발성 메모리 인터페이스, 제2 비휘발성 메모리 인터페이스 및 제2 휘 발성 메모리 인터페이스를 포함할 수 있다. 뉴럴 코어 SoC는 시스템 온 칩(System on Chip) 장치일 수 있다. 뉴럴 코어 SoC는 인공지능 연산 장치 로 가속기(Accelerator)일 수 있다. 뉴럴 코어 SoC는 예를 들어, GPU(graphics processing unit), FPGA(field programmable gate array) 및 ASIC(application-specific integrated circuit) 중 어느 하나일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 뉴럴 코어 SoC는 외부 인터페이스를 통해서 다른 외부의 연산 장치들과 데이터를 교환할 수 있다. 또한, 뉴럴 코어 SoC는 제1 비휘발성 메모리 인터페이스 및 제1 휘발성 메모리 인터페이스를 통해서 각각 비휘발성 메모리 및 휘발성 메모리와 연결될 수 있다. CPU는 제1 뉴럴 프로세싱 장치의 시스템을 통제하고 프로그램의 연산을 실행하는 제어장치일 수 있다. CPU는 범용 연산 장치로서 딥러닝에 많이 사용되는 병렬 단순 연산을 수행하기에는 효율이 낮을 수 있다. 따라서, 뉴럴 코어 SoC가 딥러닝 추론 및 학습 작업에 연산을 수행하여 높은 효율을 가질 수 있다. CPU는 외부 인터페이스를 통해서 다른 외부의 연산 장치들과 데이터를 교환할 수 있다. 또한, CPU는 제2 비휘발성 메모리 인터페이스 및 제2 휘발성 메모리 인터페이스를 통해서 각각 비휘발성 메모리 및 휘발성 메모리와 연결될 수 있다. 오프 칩 메모리는 뉴럴 코어 SoC의 칩 외부에 배치된 메모리일 수 있다. 오프 칩 메모리는 비휘발 성 메모리 및 휘발성 메모리를 포함할 수 있다. 비휘발성 메모리는 전원이 공급되지 않아도 저장된 정보를 계속 유지하는 메모리일 수 있다. 비휘발성 메모 리는 예를 들어, ROM(Read-Only Memory), PROM(Programmable Read-Only Memory), EAROM(Erasable Alterable ROM), EPROM(Erasable Programmable Read-Only Memory), EEPROM(Electrically Erasable Programmable Read-Only Memory)(예를 들어, 낸드 플래시 메모리(NAND Flash memory), 노어 플래시 메모리(NOR Flash memory), UVEPROM(Ultra-Violet Erasable Programmable Read-Only Memory), FeRAM(Ferroelectric Random Access Memory), MRAM(Magnetoresistive Random Access Memory), PRAM(Phase-change Random Access Memory), SONOS(silicon-oxide-nitride-oxide-silicon), RRAM(Resistive Random Access Memory), NRAM(Nanotube Random Access Memory), 마그네틱 컴퓨터 기억 장치(예를 들면, 하드 디스크, 디스켓 드라이브, 마그네틱 테이프), 광디스크 드라이브 및 3D 크로스포인트 메모리(3D XPoint memory) 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 휘발성 메모리는 비휘발성 메모리와 달리, 저장된 정보를 유지하기 위해서 전력을 지속적으로 필요로 하는 메모리일 수 있다. 휘발성 메모리는 예를 들어, DRAM(Dynamic Random Access Memory), SRAM(Static Random Access Memory), SDRAM(Synchronous Dynamic Random Access Memory) 및 DDR SDRAM(Double Data Rate SDRAM) 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 제1 비휘발성 메모리 인터페이스 및 제2 비휘발성 메모리 인터페이스는 각각 예를 들어, PATA(Parallel Advanced Technology Attachment), SCSI(Small Computer System Interface), SAS(Serial Attached SCSI), SATA(Serial Advanced Technology Attachment) 및 PCIe(PCI Express) 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 제1 휘발성 메모리 인터페이스 및 제2 휘발성 메모리 인터페이스는 각각 예를 들어, SDR(Single Data Rate), DDR(Double Data Rate), QDR(Quad Data Rate), 및 XDR(eXtreme Data Rate, Octal Data Rate) 중 적어 도 하나일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 도 3은 도 2의 뉴럴 코어 SoC를 세부적으로 설명하기 위한 블록도이다. 도 2 및 도 3을 참조하면, 뉴럴 코어 SoC는 CGRA 엔진 클러스터(CGRA Engine Cluster), L2 메모리 , DMA(Direct Memory Access), 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤러 및 L2 인터커넥션을 포함할 수 있다. CGRA 엔진 클러스터는 복수의 CGRA 엔진 그룹(CGRA Engine Group)를 포함할 수 있다. CGRA 엔진 클 러스터는 도면에서 1개인 것으로 도시되었지만, 본 실시예가 이에 제한되는 것은 아니다. CGRA 엔진 그룹은 연산 작업을 직접 수행하는 연산 장치일 수 있다. CGRA 엔진 그룹이 복수인 경우 연산 작업은 각각의 CGRA 엔진 그룹로 할당될 수 있다. 각각의 CGRA 엔진 그룹은 L2 인터커넥션(70 0)을 통해서 서로 연결될 수 있다. 시퀀서는 CGRA 엔진 그룹에 대해서 개별적으로 하드웨어 리소스를 제공할 수 있다. 즉, 시퀀서 의 판단에 따라서 CGRA 엔진 그룹의 작업의 중요도가 결정되고, 그에 따라서 하드웨어 리소스가 차등하여 제공될 수 있다. 이때, 하드웨어 리소스는 전압, 전력, 프리퀀시 및 밴드위스 중 적어도 하나를 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 시퀀서는 CGRA 엔진 클러스터 내의 여러 CGRA 엔진 그룹의 동작을 모니터링하고 그에 따라 하드 웨어 리소스를 각각의 CGRA 엔진 그룹에 제공할 수 있다. 시퀀서는 CGRA 엔진 그룹의 다양한 성 능 파라미터를 모니터링할 수 있다. 시퀀서는 모니터링에 의해서 판단된 성능 문제를 검출하고 그에 따른 하드웨어 리소스 제공을 수행할 수 있다. 이에 따라서, CGRA 엔진 그룹은 다양한 연산 작업을 시퀀서(20 0)의 지시에 따라 효율적으로 수행할 수 있다. 시퀀서의 중요도 판단은 다양한 기준에 의해서 이루어질 수 있다. 먼저, 시퀀서는 QoS(Quality of Service)에 따라 중요도를 판단할 수 있다. 즉, 특정 수준의 성능을 보장하기 위한 우선 순위 선정 방식이 시퀀 서에 의해서 사용될 수 있다. 또한, 시퀀서는 SLO(Service Level Objectives)에 따라 중요도를 판단할 수 있다. 이러한 SLO는 미리 적 절한 값으로 설정될 수 있고, 추후 다양한 방식으로 업데이트될 수 있다.즉, 시퀀서는 QoS 및/또는 SLO 등의 기준에 의해서 작업의 중요도를 판단하고, 그에 따라 하드웨어 리소스 를 제공할 수 있다. L2 메모리는 여러 CGRA 엔진 그룹에 의해서 공유되는 메모리일 수 있다. L2 메모리는 각각의 CGRA 엔진 그룹의 데이터를 저장할 수 있다. 또한, L2 메모리는 오프 칩 메모리로부터 데이터를 수신하여 일시적으로 저장하고 각각의 CGRA 엔진 그룹로 전달할 수 있다. 반대로, L2 메모리는 CGRA 엔진 그룹로부터 데이터를 수신하여 일시적으로 저장하고 오프 칩 메모리로 전달할 수도 있다. L2 메모리는 상대적으로 속도가 빠른 메모리가 필요할 수 있다. 이에 따라서, L2 메모리는 예를 들어, SRAM을 포함할 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 즉, L2 메모리는 DRAM을 포함 할 수도 있다. L2 메모리는 SoC 레벨 즉, L2(level 2)에 해당하는 메모리일 수 있다. 즉, L2 메모리는 계층적 구조 의 level 2에서 동작할 수 있다. 계층적 구조에 대해서는 추후 더 자세히 설명한다. DMA는 CGRA 엔진 그룹이 데이터의 입출력을 제어할 필요 없게 직접 데이터의 이동을 제어할 수 있다. 이에 따라서, DMA가 메모리 사이의 데이터 이동을 제어하여 CGRA 엔진 그룹의 인터럽트의 횟수를 최 소화시킬 수 있다. DMA는 L2 메모리와 오프 칩 메모리 사이의 데이터 이동을 제어할 수 있다. DMA의 권한을 통 해서 비휘발성 메모리 컨트롤러 및 휘발성 메모리 컨트롤러가 데이터를 이동을 수행할 수 있다. 비휘발성 메모리 컨트롤러는 비휘발성 메모리에 리드(read) 또는 라이트(Write) 작업을 제어할 수 있 다. 비휘발성 메모리 컨트롤러는 제1 비휘발성 메모리 인터페이스를 통해서 비휘발성 메모리를 제 어할 수 있다. 휘발성 메모리 컨트롤러는 휘발성 메모리에 리드 또는 라이트 작업을 제어할 수 있다. 또한, 휘발성 메모리 컨트롤러는 휘발성 메모리의 리프레쉬 작업을 수행할 수 있다. 휘발성 메모리 컨트롤러는 제1 휘발성 메모리 인터페이스를 통해서 비휘발성 메모리를 제어할 수 있다. L2 인터커넥션은 적어도 하나의 CGRA 엔진 그룹, L2 메모리, DMA, 비휘발성 메모리 컨트 롤러 및 휘발성 메모리 컨트롤러를 서로 연결할 수 있다. 또한, 외부 인터페이스도 L2 인터커넥션 에 연결될 수 있다. L2 인터커넥션은 적어도 하나의 CGRA 엔진 그룹, L2 메모리, DMA, 비휘발성 메모리 컨트롤러, 휘발성 메모리 컨트롤러 및 외부 인터페이스 사이의 데이터 가 이동하는 경로일 수 있다. L2 인터커넥션은 데이터뿐만 아니라 제어 신호의 전송 및 동기화를 위한 신호를 전송할 수 있다. 즉, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 별도의 제어 프로세서가 동기화의 신호를 관리하는 것이 아 니라 각각의 CGRA 엔진 그룹이 직접 동기화 신호를 전송하고 수신할 수 있다. 이에 따라서, 제어 프로세서 에 의해서 발생하는 동기화 신호의 레이턴시를 차단할 수 있다. 즉, CGRA 엔진 그룹이 복수일 때, 어느 CGRA 엔진 그룹의 작업이 종료되어야 다음 CGRA 엔진 그룹 이 새로운 작업을 시작할 수 있는 개별 작업의 디펜던시가 존재할 수 있다. 따라서, 본 발명의 몇몇 실시 예들에 따른 뉴럴 프로세싱 장치는 제어 프로세서 대신 각각의 CGRA 엔진 그룹이 직접 동기화 신호를 작업 의 디펜던시에 따라 다른 CGRA 엔진 그룹로 전송할 수 있다. 이 경우 제어 프로세서에 의해서 관리되는 방 식에 비해서 병렬적으로 여러 CGRA 엔진 그룹이 동기화 작업을 수행할 수 있어 동기화에 따른 레이턴시를 최소화할 수 있다. 도 4는 도 3의 CGRA 엔진 그룹을 세부적으로 설명하기 위한 블록도이다. 도 3 및 도 4를 참조하면, CGRA 엔진 그룹은 적어도 하나의 CGRA 엔진, L1 메모리 및 L1 인터 커넥션을 포함할 수 있다. 적어도 하나의 CGRA 엔진은 CGRA 엔진 그룹의 작업을 분담하여 수행할 수 있다. CGRA 엔진은 일 종의 프로세서일 수 있다. 즉, CGRA 엔진은 연산 작업을 수행하여 연산 결과를 도출할 수 있다. CGRA 엔진은 복수일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아니다. 도 4에서는 여러 개의 CGRA 엔 진이 CGRA 엔진 그룹에 포함되는 것으로 도시하였지만, 본 실시예가 이에 제한되는 것은 아니다. 즉,CGRA 엔진 1개만으로 CGRA 엔진 그룹이 구성될 수도 있다. L1 메모리는 CGRA 엔진 그룹 내에서 각각의 CGRA 엔진들이 공유하는 메모리일 수 있다. L1 메모 리는 각각의 CGRA 엔진의 데이터를 저장할 수 있다. 또한, L1 메모리는 L2 메모리로부터 데이터를 수신하여 일시적으로 저장하고 각각의 CGRA 엔진로 전달할 수 있다. 반대로, L1 메모리는 CGRA 엔진로부터 데이터를 수신하여 일시적으로 저장하고 L2 메모리로 전달할 수도 있다. L1 메모리는 CGRA 엔진 그룹 레벨, 즉, L1(level 1)에 해당하는 메모리일 수 있다. 즉, L2 메모리는 CGRA 엔진 그룹에 의해서 공유되고, L1 메모리는 CGRA 엔진에 의해서 공유될 수 있다. L1 인터커넥션은 적어도 하나의 CGRA 엔진 및 L1 메모리를 서로 연결할 수 있다. L1 인터커넥션 은 적어도 하나의 CGRA 엔진 및 L1 메모리 사이의 데이터가 이동하는 경로일 수 있다. L1 인터 커넥션은 L2 인터커넥션과 연결되어 데이터를 전송할 수 있다. L1 인터커넥션은 L2 인터커넥션에 비해서 상대적으로 레이턴시 민감도가 높을 수 있다. 즉, L1 인터 커넥션의 데이터 전송이 L2 인터커넥션보다 더 빠르게 수행될 수 있다. 반대로, L2 인터커넥션은 L1 인터커넥션에 비해서 밴드위스가 더 클 수 있다. L2 인터커넥션은 L1 인터커넥션에 비해서 더 많은 데이터가 전송되어야 하므로, 밴드위스가 작은 경우 바틀넥 현상이 일어 날 수 있고, 장치 전체의 성능을 저하시킬 수 있다. 따라서, L1 인터커넥션과 L2 인터커넥션은 서로 다른 성능 파라미터에 초점을 맞추어 설계될 수 있다. 추가적으로 L2 인터커넥션은 확장 가능한 구조일 수 있다. 즉, CGRA 엔진의 디멘젼이나 CGRA 엔진 그 룹의 디멘젼은 연산의 최적화를 위해서 어느정도 고정될 수 있다. 그에 반해서, CGRA 엔진 클러스터 의 디멘젼은 하드웨어 리소스가 허락하는 한 클수록 좋은 부분이므로 L2 인터커넥션의 확장 가능성은 매우 중요한 특성 중 하나일 수 있다. 여기서, 디멘젼이란 CGRA 엔진이나 CGRA 엔진 그룹의 스케일을 의미할 수 있다. 즉, CGRA 엔진 그룹 은 적어도 하나의 CGRA 엔진이 포함되므로 CGRA 엔진 그룹이 포함하는 CGRA 엔진의 수에 따라 CGRA 엔진 그룹의 디멘젼이 결정될 수 있다. 유사하게, CGRA 엔진도 내부에 프로세싱 엘리먼트, 인스트럭션 메모리, L0 메모리 및 LSU 등 적어도 하나의 구성요소를 포함하고 있으므로 이러한 구성요소의 개수 에 따라 CGRA 엔진의 디멘젼이 결정될 수 있다. 도 5는 도 3의 CGRA 엔진 그룹의 하드웨어 구조를 설명하기 위한 개념도이다. 도 5를 참조하면, CGRA 엔진 클러스터는 적어도 하나의 CGRA 엔진 그룹을 포함할 수 있다. 각각의 CGRA 엔진 그룹은 로컬 인터커넥션을 통해서 서로 데이터를 전송할 수 있다. 로컬 인터커넥션은 L2 인터커넥션과 별도로 형성된 인터커넥션일 수 있다. 또는 로컬 인터커넥션은 L2 인터커넥션 내부에서 CGRA 엔진 그룹 사이의 통신을 위한 별도의 전용 채널일 수도 있다. CGRA 엔진 그룹은 각각 적어도 하나의 CGRA 엔진을 포함할 수 있다. CGRA 엔진은 딥러닝 연산 작업에 최적화된 프로세싱 단위 유닛일 수 있다. CGRA 엔진은 딥러닝 연산 작업의 하나의 오퍼레이션에 대 응하는 프로세싱 단위 유닛일 수 있다. 즉, 딥러닝 연산 작업은 여러 오퍼레이션의 순차적 또는 병렬적 결합으 로 표현 가능할 수 있다. CGRA 엔진은 각각 하나의 오퍼레이션을 처리할 수 있는 프로세싱 단위 유닛으로 서 컴파일러 입장에서 스케쥴링에 고려할 수 있는 최소한의 연산 단위일 수 있다. 본 실시예에 따른 뉴럴 프로세싱 장치는 컴파일러 스케쥴링 입장에서 고려되는 최소한의 연산 단위와 하드웨어 프로세싱 단위 유닛의 스케일을 동일하게 구성하여 빠르고 효율적인 스케쥴링 및 연산 작업의 수행을 도모할 수 있다. 즉, 연산 작업에 비해서 하드웨어의 분할할 수 있는 프로세싱 단위 유닛이 지나치게 크다면 프로세싱 단위 유닛 의 구동에서 연산 작업의 비효율이 발생할 수 있다. 반대로, 컴파일러의 스케쥴링 최소 단위인 오퍼레이션보다 더 작은 단위의 프로세싱 유닛을 매번 스케쥴링하는 것은 스케쥴링의 비효율이 발생할 수 있고, 하드웨어 설계 비용이 높아질 수 있어 적절하지 않다. 따라서, 본 실시예는 컴파일러의 스케쥴링 단위와 하드웨어 프로세싱 단위의 스케일을 유사하게 조율하여 빠른 연산 작업의 스케쥴링과 하드웨어 리소스의 낭비없이 효율적인 연산 작업 수행을 동시에 충족시킬 수 있다. 도 6은 뉴럴 코어 SoC의 계층적 구조를 설명하기 위한 개념도이다. 도 6을 참조하면, 뉴럴 코어 SoC는 최상위 레벨에서 적어도 하나의 CGRA 엔진 클러스터를 포함할 수 있다. 각각의 CGRA 엔진 클러스터는 그 내부에 적어도 하나의 CGRA 엔진 그룹을 포함할 수 있다. 나 아가 각각의 CGRA 엔진 그룹은 그 내부에 적어도 하나의 CGRA 엔진을 포함할 수 있다. 이때, 가장 낮은 레벨인 CGRA 엔진의 레벨은 L1 즉, 제1 레벨로 정의할 수 있다. 이에 따라서, 그 위의 CGRA 엔진 그룹 레벨은 L2 즉, 제2 레벨로 정의할 수 있고, 그 위의 CGRA 엔진 클러스터 레벨은 L3 즉, 제3 레벨로 정의할 수 있다. 도 6에서는 3개의 레벨로 본 발명의 몇몇 실시예에 따른 뉴럴 프로세싱 장치의 계층적 구조를 도시하였지만, 본 실시예가 이에 제한되는 것은 아니다. 즉, 본 실시예는 CGRA 엔진 클러스터보다 더 큰 상위 개념의 클러스 터를 정의할 수 있어서 4개 이상의 레벨을 가지는 계층적 구조를 가지는 것도 얼마든지 가능할 수 있다. 시퀀서는 최상위 레벨에서 모든 CGRA 엔진 클러스터, CGRA 엔진 그룹 및 CGRA 엔진을 다 제어할 수 있다. 구체적으로, 시퀀서는 CGRA 엔진 클러스터 사이의 연산 작업의 분배 및 작업 수행을 제어하고, 이는 각각의 CGRA 엔진 그룹 사이의 연산 작업의 분배 및 작업 수행을 제어를 통해서 수행될 수 있다. 나아가, 시퀀서는 CGRA 엔진 사이의 연산 작업의 분배 및 작업 수행을 제어를 통해서 CGRA 엔 진 그룹의 제어를 수행할 수 있다. 시퀀서가 모든 CGRA 엔진 클러스터를 다 제어할 수 있어서 전체적인 작업의 수행을 원활하게 제어할 수 있다. 즉, 시퀀서는 L1, L2 및 L3의 모든 레벨의 제어를 수행할 수 있다. 또한, 모든 레벨의 모니터링도 수행할 수 있다. 도 7은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치를 설명하기 위한 개념도이다. 도 3 및 도 7을 참조하면, 시퀀서는 L3에서 각 CGRA 엔진 클러스터 별로 나누어 관리할 수 있게 복수 일 수 있다. 즉, 시퀀서는 서로 다른 CGRA 엔진 클러스터의 관리하는 제1 시퀀서, 제2 시퀀서 및 제3 시퀀서를 포함할 수 있다. 도 7에서는 3개의 CGRA 엔진 클러스터와 제1 내지 제3 시퀀 서(210, 220, 230)를 도시하였지만, 본 실시예가 이에 제한되는 것은 아니다. CGRA 엔진 클러스터의 개수 와 그에 대응하는 시퀀서(210, 220, 230)의 개수는 얼마든지 달라질 수 있다. 각각의 CGRA 엔진 클러스터는 제1 CGRA 엔진 그룹(110a), 제2 CGRA 엔진 그룹(110b) 및 제3 CGRA 엔진 그 룹(110c)를 각각 포함할 수 있다. 제1 CGRA 엔진 그룹(110a), 제2 CGRA 엔진 그룹(110b) 및 제3 CGRA 엔진 그 룹(110c)는 각각 복수일 수 있고, 하나일 수도 있다. 이때, 제1 시퀀서는 제1 CGRA 엔진 그룹(110a)와 제1 CGRA 엔진 그룹(110a) 내부의 CGRA 엔진의 동작을 제어하고 모니터링할 수 있다. 유사하게, 제2 시퀀서 는 제2 CGRA 엔진 그룹(110b)와 제2 CGRA 엔진 그룹(110b) 내부의 CGRA 엔진의 동작을 제어하고 모 니터링할 수 있다. 제3 시퀀서는 제3 CGRA 엔진 그룹(110c)와 제3 CGRA 엔진 그룹(110c) 내부의 CGRA 엔 진의 동작을 제어하고 모니터링할 수 있다. 본 실시예는 하나의 시퀀서에 집중되는 오버헤드를 분산할 수 있다. 이에 따라, 시퀀서에 의한 레이 턴시나 전체 장치의 성능 저하를 방지할 수 있고, CGRA 엔진 클러스터별로 병렬적인 제어가 가능할 수 있 다. 도 8은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치를 설명하기 위한 개념도이다. 도 3 및 도 8을 참조하면, 하나의 CGRA 엔진 클러스터에 대해서 복수의 시퀀서(210a, 210b, 210c)가 존재 할 수 있다. 즉, 시퀀서는 제1 영역 시퀀서(210a), 제2 영역 시퀀서(210b) 및 제3 영역 시퀀서(210c)를 포 함할 수 있다. 이때, 제1 내지 제3 영역 시퀀서(210a, 210b, 210c)의 개수는 얼마든지 달라질 수 있다. 제1 영역 시퀀서(210a)는 하나의 CGRA 엔진 클러스터의 제1 영역에 해당하는 제1 CGRA 엔진 그룹(110a)와 제1 CGRA 엔진 그룹(110a) 내부의 CGRA 엔진을 관리할 수 있다. 제2 영역 시퀀서(210b)는 CGRA 엔진 클러 스터의 제2 영역에 해당하는 제2 CGRA 엔진 그룹(110b)와 제2 CGRA 엔진 그룹(110b) 내부의 CGRA 엔진 을 관리할 수 있다. 제3 영역 시퀀서(210c)는 하나의 CGRA 엔진 클러스터의 제3 영역에 해당하는 제3 CGRA 엔진 그룹(110c)와 제3 CGRA 엔진 그룹(110c) 내부의 CGRA 엔진을 관리할 수 있다. 본 실시예는 CGRA 엔진 클러스터를 구성하기 위한 하드웨어 설계를 별도로 하지 않고, 단순히 영역만을 구 분하여 시퀀서의 업무를 분할할 수 있다. 즉, 하드웨어 리소스를 최소화하면서 하나의 시퀀서에 집중되는 오버헤드를 분산할 수 있다. 이에 따라, 시퀀서에 의한 레이턴시나 전체 장치의 성능 저하를 방지할 수 있고, CGRA 엔진 클러스터별로 병렬적인 제어가 가능할 수 있다. 도 9는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치를 설명하기 위한 개념도이다. 도 3 및 도 9를 참조하면, 각각의 CGRA 엔진 클러스터는 제1 CGRA 엔진 그룹(110a), 제2 CGRA 엔진 그룹 (110b) 및 제3 CGRA 엔진 그룹(110c)를 각각 포함할 수 있다. 제1 CGRA 엔진 그룹(110a), 제2 CGRA 엔진 그룹 (110b) 및 제3 CGRA 엔진 그룹(110c)는 각각 복수일 수 있고, 하나일 수도 있다. 이때, 제1 시퀀서는 제1 CGRA 엔진 그룹(110a)와 제1 CGRA 엔진 그룹(110a) 내부의 CGRA 엔진의 동작을 제어하고 모니터링할 수 있 다. 유사하게, 제2 시퀀서는 제2 CGRA 엔진 그룹(110b)와 제2 CGRA 엔진 그룹(110b) 내부의 CGRA 엔진 의 동작을 제어하고 모니터링할 수 있다. 제3 시퀀서는 제3 CGRA 엔진 그룹(110c)와 제3 CGRA 엔진 그룹(110c) 내부의 CGRA 엔진의 동작을 제어하고 모니터링할 수 있다. 이때, 제1 시퀀서, 제2 시퀀서 및 제3 시퀀서는 상부 시퀀서로서 CGRA 엔진 그룹들의 동작 을 제어할 수 있다. 제1 하부 시퀀서, 제2 하부 시퀀서 및 제3 하부 시퀀서는 각각 CGRA 엔진 그룹 별로 존재하고, 각 CGRA 엔진 그룹의 하부에 있는 CGRA 엔진의 동작을 제어할 수 있다. 제 1 시퀀서, 제2 시퀀서 및 제3 시퀀서는 각각 제1 하부 시퀀서, 제2 하부 시퀀서 및 제3 하부 시퀀서와 연계될 수 있다. 이러한 상부와 하부로 나누어진 시퀀서는 각 레벨에 따른 동작 제어를 분산하여 하므로 오버헤드를 줄이고, 병 렬적인 제어를 통해서 전체 장치의 속도를 향상시킬 수 있다. 도 10은 도 3의 시퀀서의 동작을 설명하기 위한 개념도이다. 도 10을 참조하면, 시퀀서는 인풋 파라미터(In_p)를 모니터링하여 CGRA 엔진, L2 인터커넥션, L2 메모리 및 오프 칩 메모리 중 적어도 하나를 제어할 수 있다. 시퀀서는 CGRA 엔진, L2 인터커넥션, L2 메모리 및 오프 칩 메모리의 밴드위스나 레이턴시와 같은 파라미터를 제어할 수 있다. 시퀀서는 물론 L1 메모리, L1 인터커넥션 및 로컬 인터커넥션도 제어할 수도 있다. 다만, 설명의 편의를 위해서, 아래서는 CGRA 엔진, L2 인터커넥션, L2 메모리 및 오프 칩 메모 리에 대한 제어만을 설명한다. 이때, 인풋 파라미터(In_p)는 밴드위스, 레이턴시, 공급전력 및 온도 중 적어도 하나를 포함할 수 있다. 이때, 밴드위스란, 시간에 따른 CGRA 엔진과 외부의 데이터 전송 트래픽의 크기를 의미할 수 있다. 밴드위 스의 경우 CGRA 엔진과 대응하는 메모리 즉, L2 메모리 또는 오프 칩 메모리의 상황이나 둘 사이 를 연결하는 L2 인터커넥션의 트래픽 등이 다각적으로 관련될 수 있다. 이때, 레이턴시란, CGRA 엔진의 연산 성능의 파라미터 중 하나로 CGRA 엔진이 처리한 결과가 지연되 는 기간을 의미할 수 있다. 레이턴시의 경우 CGRA 엔진의 프리퀀시를 높이거나 CGRA 엔진의 공급전력 을 높여서 최소화할 수 있다. 공급전력 및 온도는 하드웨어 동작 환경과 관련된 파라미터로서, 이를 제어하여 하드웨어의 성능을 극대화할 수 있다. 시퀀서는 위와 같은 인풋 파라미터(In_p)를 이용하여 CGRA 엔진, L2 인터커넥션, L2 메모리 및 오프 칩 메모리 중 적어도 하나의 동작을 제어하고 성능 문제를 해결할 수 있다. 도 11은 도 3의 시퀀서의 모니터링 및 제어 동작을 설명하기 위한 블록도이다. 도 11을 참조하면, 각각의 CGRA 엔진은 가상 디바이스(VP)에 매핑될 수 있다. 즉, 연산 작업의 특성에 따 라 필요한 하드웨어 리소스를 효율적으로 제공하기 위해서 가상 디바이스(VP)가 구현될 수 있다. 2개 이상의 CGRA 엔진이 하나의 가상 디바이스(VP)에 매핑될 수도 있고, 이 경우 하나의 가상 디바이스(VP)에 매핑된 2개 이상의 CGRA 엔진은 하나의 유닛처럼 동작할 수 있다. 이에 따라서, 실제 CGRA 엔진의 개수와 가상 디바이스(VP)의 개수는 서로 다를 수 있다. 이때, 가상 디바 이스(VP)의 개수는 실제 CGRA 엔진의 개수보다 같거나 적을 수 있다. 가상 디바이스(VP)는 L2 인터커넥션과 서로 데이터를 교환할 수 있다. 데이터 교환(Ex)은 가상 디바이스 (VP) 및 L2 인터커넥션을 통해서 기록될 수 있고, 시퀀서에 의해서 모니터링될 수 있다. 시퀀서는 CGRA 엔진의 동작을 모니터링할 수 있다. 이때, CGRA 엔진의 레이턴시, 공급전력 및 온도가 모니터링될 수 있다. 또한, 시퀀서는 CGRA 엔진과 L2 인터커넥션 사이의 밴드위스를 모니터링할 수 있다. 즉, 시퀀서는 데이터 교환(Ex)을 모니터링하여 밴드위스를 확인할 수 있다. 이때, 시퀀 서는 실시간으로 모니터링 정보(Im)를 수신할 수 있다. 이때, 모니터링 정보(Im)는 CGRA 엔진의 레이 턴시, CGRA 엔진의 공급전력, CGRA 엔진의 온도 및 CGRA 엔진과 L2 인터커넥션 사이의 밴 드위스 중 적어도 하나를 포함할 수 있다. 시퀀서는 이러한 모니터링 정보(Im)를 수신하여 성능 문제를 검출할 수 있다. 상기 성능 문제는 하드웨어 의 레이턴시나 밴드위스 등이 미리 설정된 기준치 이하로 검출되는 것을 의미할 수 있다. 구체적으로, 성능 문 제는 밴드위스가 제한되는 문제 또는 연산 성능이 제한되는 문제 중 적어도 하나일 수 있다. 이에 대응하여, 시퀀서는 프로세서 제어 신호(Proc_Cont), 메모리 제어 신호(Mem_Cont) 및 인터커넥션 제 어 신호(Inter_Cont) 중 적어도 하나를 생성하고 전달할 수 있다. 시퀀서는 프로세서 제어 신호 (Proc_Cont), 메모리 제어 신호(Mem_Cont) 및 인터커넥션 제어 신호(Inter_Cont) 중 적어도 하나를 CGRA 엔진 과 L2 인터커넥션에 전달할 수 있다. 프로세서 제어 신호(Proc_Cont), 메모리 제어 신호(Mem_Cont) 및 인터커넥션 제어 신호(Inter_Cont)는 추후에 더 자세히 설명한다. 도 12는 도 3의 시퀀서의 작업 특성에 따른 DVFS(Dynamic Voltage Frequency Scaling)을 설명하기 위한 개념도 이다. 도 12를 참조하면, 시퀀서는 입력된 연산 작업(Task)의 특성, 즉 작업 특성(T_st)을 수신할 수 있다. 작업 특성(T_st)은 연산 작업(Task)의 오퍼레이션과 순서, 피연산자의 종류 및 개수 등을 포함할 수 있다. 시퀀서는 작업 특성(T_st)에 따라서, 각 CGRA 엔진에 연산 작업이 할당되면 실시간으로 전압 및/또는 프리퀀시를 조절하여 하드웨어의 성능을 최적화할 수 있다. 이때, 시퀀서에 의해서 조절되는 하드웨어는 CGRA 엔진, L2 인터커넥션, L2 메모리 및 오프 칩 메모리 중 적어도 하나를 포함할 수 있다. 물론, 시퀀서에 의해서 조절되는 하드웨어는 L1 인터커넥션, L1 메모리 및 로컬 인터커넥 션 중 적어도 하나를 포함할 수도 있다. 도 13은 도 3의 시퀀서의 가상 장치 상태에 따른 DVFS을 설명하기 위한 개념도이다. 도 11 및 도 13을 참조하면, 시퀀서는 가상 디바이스(VP)의 현황 즉, 가상 디바이스 현황(V_st)을 수신할 수 있다. 가상 디바이스 현황(V_st)은 어떤 CGRA 엔진이 어떤 가상 디바이스(VP)로 이용되고 있는지에 따 른 정보일 수 있다. 시퀀서는 가상 디바이스 현황(V_st)에 따라 각 CGRA 엔진에 연산 작업이 할당되면 실시간으로 전압 및/또는 프리퀀시를 조절하여 하드웨어 성능을 최적화할 수 있다. 즉, 가상 디바이스 현황(V_st)에서 사용되지 않는 CGRA 엔진과 대응되는 메모리의 공급전력을 낮추고, 가장 활발하게 사용되는 CGRA 엔진나 메모 리에 공급전력을 높이는 등의 실시간 스케일링이 가능할 수 있다. 이때, 시퀀서에 의해서 조절되는 하드웨어는 CGRA 엔진, L2 인터커넥션, L2 메모리 및 오 프 칩 메모리 중 적어도 하나를 포함할 수 있다. 물론, 시퀀서에 의해서 조절되는 하드웨어는 L1 인터 커넥션, L1 메모리 및 로컬 인터커넥션 중 적어도 하나를 포함할 수도 있다. 도 14는 도 3의 시퀀서의 구조를 세부적으로 설명하기 위한 블록도이다. 도 11 및 도 14를 참조하면, 시퀀서는 모니터링 모듈, 프로세서 컨트롤러, 컴프레션 액티베이터 및 인터커넥트 컨트롤러를 포함할 수 있다. 모니터링 모듈은 모니터링 정보(Im)를 수신할 수 있다. 모니터링 모듈은 모니터링 정보(Im)를 통해서, 어떠한 성능 문제가 있는지 검출할 수 있다. 예를 들어, 밴드위스가 제한되는지, 연산 성능이 제한되는 지 등을 분석할 수 있다. 밴드위스가 제한되는 경우 오프 칩 메모리가 제한되는지, L2 메모리가 제한 되는지 아니면, L2 인터커넥션이 제한되는 건지를 식별할 수 있다. 프로세서 컨트롤러는 연산 성능이 제한되는 경우 CGRA 엔진의 공급전력이나 프리퀀시를 상승 제어하 는 프로세서 제어 신호(Proc_Cont)를 생성할 수 있다. 프로세서 컨트롤러는 CGRA 엔진로 프로세서 제 어 신호(Proc_Cont)를 전송할 수 있다. 컴프레션 액티베이터는 밴드위스가 제한되고, 오프 칩 메모리 또는 L2 메모리가 제한되는 경우 데이터의 컴프레션 및 디컴프레션을 수행하게 할 수 있다. 즉, 컴프레션 액티베이터는 오프 칩 메모리(3 0)가 제한되는 경우, 오프 칩 메모리의 트래픽의 압축을 수행하고, 다시 압축 해제를 하게하는 메모리 제어신호(Mem_Cont)를 생성할 수 있다. 이를 통해, 컴프레션 액티베이터는 오프 칩 메모리의 트래픽 문제 를 해결할 수 있다. 메모리 제어 신호(Mem_Cont)는 컴프레션 엔진과 디컴프레션 엔진을 활성화시켜 압축과 압축 해제를 수행할 수 있다. 이때, 압축 및 압축해제는 트래픽 하향 제어의 하나의 예시에 불과하고, 본 실시예가 이에 제한되는 것은 아니다. 또한, 컴프레션 액티베이터는 L2 메모리가 제한되는 경우, L2 메모리의 트래픽의 압축을 수행하 고, 다시 압축 해제를 하게하는 메모리 제어 신호(Mem_Cont)를 생성할 수 있다. 이를 통해, 컴프레션 액티베이 터는 L2 메모리의 트래픽 문제를 해결할 수 있다. 이때, 압축 및 압축해제는 트랙픽 하향 제어의 하 나의 예시에 불과하고, 본 실시예가 이에 제한되는 것은 아니다. 인터커넥트 컨트롤러는 밴드위스가 제한되고, 오프 칩 메모리 또는 L2 메모리가 제한되는 경우, L2 인터커넥션의 프리퀀시를 오버드라이브하게하는 인터커넥션 제어 신호(Inter_Cont)를 생성할 수 있다. 인터커넥션 제어 신호(Inter_Cont)는 L2 인터커넥션의 프리퀀시를 상승시켜 밴드위스 제한 문제를 해결할 수 있다. 이때, 프리퀀시 오버드라이브는 인터커넥션 성능 상승 제어의 하나의 예시에 불과하고, 본 실시예가 이에 제한되는 것은 아니다. 도 15는 도 4의 CGRA 엔진의 구조를 세부적으로 설명하기 위한 블록도이다. 도 15를 참조하면, CGRA 엔진은 인스트럭션 메모리(111_1), L0 메모리(111_2), PE 어레이(111_3), LSU(Load/Store Unit)(111_4)를 포함할 수 있다. 도 16은 도 15의 인스트럭션 메모리를 세부적으로 설명하기 위한 개념도이다. 도 16을 참조하면, 인스트럭션 메모리(111_1)는 인스트럭션을 수신하여 저장할 수 있다. 인스트럭션 메모리 (111_1)는 인스트럭션을 내부에 순차적으로 저장하고, 저장된 인스트럭션을 PE 어레이(111_3)로 제공할 수 있다. 이때, 인스트럭션은 각 PE 어레이(111_3)에 포함된 프로세싱 엘리먼트(111_3a)의 동작을 지시할 수 있다. 다시, 도 15를 참조하면, L0 메모리(111_2)는 CGRA 엔진 내부에 위치한 메모리로서, CGRA 엔진이 작 업에 필요한 모든 입력 데이터를 외부로부터 수신하여 임시로 저장할 수 있다. 또한, L0 메모리(111_2)는 CGRA 엔진에 의해서 연산된 출력 데이터를 외부로 전송하기 위해서 일시적으로 저장할 수 있다. L0 메모리 (111_2)는 CGRA 엔진의 캐시 메모리 역할을 수행할 수 있다. L0 메모리(111_2)는 PE 어레이(111_3)와 데이터를 송수신할 수 있다. L0 메모리(111_2)는 L1 보다 낮은 L0(level 0)에 해당하는 메모리일 수 있다. 이때, L0 메모리는 L1 메모리 및 L2 메모리와는 달리 공 유되지 않는 CGRA 엔진의 전용(private) 메모리일 수 있다. L0 메모리(111_2)는 액티베이션이나 웨이트 같 은 데이터와 프로그램 등을 PE 어레이(111_3)로 전송할 수 있다. PE 어레이(111_3)는 연산을 수행하는 모듈일 수 있다. PE 어레이(111_3)는 1차원 연산뿐만 아니라 2차원 이상의 매트릭스/텐서 연산도 수행할 수 있다. PE 어레이(111_3)는 내부에 복수의 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)를 포함할 수 있다. 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 행과 열로 정렬될 수 있다. 프로세싱 엘리먼 트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 m 열로 정렬될 수 있다. 또한, 프로세싱 엘리먼트(111_3a)는 n 행으로 정렬되고, 특정 프로세싱 엘리먼트(111_3b)는 l행으로 정렬될 수 있다. 이에 따라서, 프로세싱 엘리먼 트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 (n+l)행과 m열로 정렬될 수 있다. LSU(111_4)는 L1 인터커넥션을 통해서 외부에서 데이터, 제어 신호 및 동기화 신호 중 적어도 하나를 수신 할 수 있다. LSU(111_4)은 L0 메모리(111_2)로 수신한 데이터, 제어 신호 및 동기화 신호 중 적어도 하나를 전 송할 수 있다. 유사하게 LSU(111_4)는 L1 인터커넥션을 통해서 데이터, 제어 신호 및 동기화 신호 중 적어 도 하나를 외부로 전달 수 있다. CGRA 엔진은 CGRA(Coarse Grained Reconfigurable Architecture) 구조를 가질 수 있다. 이에 따라서, CGRA 엔진은 PE 어레이(111_3)의 각각의 프로세싱 엘리먼트(111_3a)와 특정 프로세싱 엘리먼트(111_3b)가 각각 L0 메모리(111_2), 인스트럭션 메모리(111_1) 및 LSU(111_4) 중 적어도 하나와 연결될 수 있다. 즉, 프로 세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 L0 메모리(111_2), 인스트럭션 메모리(111_1) 및 LSU(111_4)의 전부와 연결되어야 하는 것은 아니고 일부와 연결될 수도 있다. 또한, 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)는 서로 다른 종류의 프로세싱 소자일 수 있다. 이에 따라서, L0 메모리(111_2), 인스트럭션 메모리(111_1) 및 LSU(111_4) 중 프로세싱 엘리먼트 (111_3a)와 연결되는 소자와 특정 프로세싱 엘리먼트(111_3b)와 연결되는 소자는 서로 다를 수 있다. CGRA 구조를 가지는 본 발명의 CGRA 엔진은 높은 수준의 병렬 연산이 가능하고, 프로세싱 엘리먼트 (111_3a) 및 특정 프로세싱 엘리먼트(111_3b) 사이의 직접적인 데이터 교환이 가능하므로 전력 소모가 낮을 수 있다. 또한, 2개 이상의 종류의 프로세싱 엘리먼트(111_3a)를 포함하여 다양한 연산 작업에 따른 최적화도 가능 할 수 있다. 예를 들어, 프로세싱 엘리먼트(111_3a)가 2차원 연산을 수행하는 프로세싱 엘리먼트인 경우 특정 프로세싱 엘리 먼트(111_3b)는 1차원 연산을 수행하는 프로세싱 엘리먼트일 수 있다. 단, 본 실시예가 이에 제한되는 것은 아 니다. 도 17은 도 15의 프로세싱 엘리먼트를 세부적으로 설명하기 위한 도면이다. 도 17을 참조하면, 프로세싱 엘리먼트(111_3a)는 인스트럭션 큐(IQ), 제1 레지스터(R1), 제2 레지스터(R2), 제3 레지스터(R3), 인풋 포매터(I_Form) 및 아웃풋 포매터(O_Form)를 포함할 수 있다. 인스트럭션 큐(IQ)는 인스트럭션 메모리(111_1)로부터 받은 인스트럭션을 수신하고 분할하여 제1 레지스터(R1), 제2 레지스터(R2) 및 제3 레지스터(R3)에 순차적으로 제공할 수 있다. 제1 레지스터(R1)는 소스(src) 정보와 컨 버팅(CVT) 정보를 수신할 수 있다. 제2 레지스터(R2)는 오피코드(opcode) 정보를 수신할 수 있다. 제3 레지스터 (R3)는 데스티네이션(dst) 정보와 컨버팅(CVT) 정보를 수신할 수 있다. 이때, 오피코드(opcode)는 해당 인스트럭션의 오퍼레이션의 코드 즉, 연산자를 의미할 수 있다. 오피코드는 예 를 들어, ADD, SUB, MUL, DIV, 산술 쉬프트 등의 산술 연산과 AND, OR, NOT, XOR, 논리 쉬프트, 로테이션 쉬프 트, Complement, Clear 등의 논리 연산을 포함할 수 있다. 인풋 포매터(I_Form)는 제1 레지스터(R1)로부터 소스(src) 정보를 수신하여 피연산자를 확정할 수 있다. 또한, 인풋 포매터(I_Form)는 제1 레지스터(R1)로부터 컨버팅(CVT) 정보를 수신하여 피연산자의 프리시젼을 변환할 수 있다. 즉, 입력 데이터의 프리시젼과 연산에 필요한 프리시젼이 다를 수 있으므로 인풋 포매터(I_Form)가 프리 시젼을 변환할 수 있다. 이때, 소스(src) 정보는 노스(N), 이스트(E), 사우스(S), 웨스트(W), 글로벌 레지스터 파일(GRF) 및 바이패스(Bypass) 중 적어도 하나를 포함할 수 있다. 바이패스(Bypass)는 아웃풋 포매터(O_Form) 에서 전달되는 경로일 수 있다. 제2 레지스터(R2)는 오피코드(opcode) 정보를 수신하여 연산자를 생성할 수 있다. 연산자는 피연산자를 이용하 여 연산 결과인 출력을 생성할 수 잇다. 아웃풋 포매터(O_Form)는 출력을 수신할 수 있다. 아웃풋 포매터 (O_Form)는 제3 레지스터(R3)로부터 데스티네이션(dst) 정보를 수신하여 출력를 전송할 수 있다. 또한, 아웃풋 포매터(O_Form)는 제3 레지스터(R3)로부터 컨버팅(CVT) 정보를 수신하여 출력의 프리시젼을 변환할 수 있다. 즉, 연산에 필요한 프리시젼과 출력에 요구되는 프리시젼이 다를 수 있으므로 아웃풋 포매터(O_Form)가 프리시 젼을 변환할 수 있다. 이때, 데스티네이션(dst) 정보는 노스(N), 이스트(E), 사우스(S) 및 웨스트(W) 중 적어도 하나를 포함할 수 있 다. 또한, 아웃풋 포매터(O_Form)는 바이패스(Bypass)를 통해 출력을 인풋 포매터(I_Form)로 전달할 수도 있다. 본 실시예에 따른 프로세싱 엘리먼트는 별도의 프리시젼 컨버전 디바이스가 있는 것이 아니라 인스트럭션 큐에 서 바로 프리시젼 컨버전을 수행하므로 하드웨어 효율성을 높일 수 있다. 도 18은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 ISA(Instruction Set Architecture)를 설명하 기 위한 도면이다. 도 17 및 도 18을 참조하면, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 ISA는 프리시젼 (precision), 오피코드(opcode), 소스(src0~2) 및 데스티네이션(dst) 정보를 포함할 수 있다. 프리시젼은 인풋 포매터(I_Form) 및 아웃풋 포매터(O_Form)에게 컨버팅(CVT) 정보를 생성하기 위해서 포함될 수 있다. 오피코드는 연산자, 소스는 피연산자를 확정하는 것에 사용되고, 데스티네이션은 출력의 전송을 위해서 ISA에 포함될 수 있다. 도 19는 도 4의 CGRA 엔진에서 인스트럭션 큐의 동작을 설명하기 위한 블록도이다. 도 17 내지 도 19를 참조하면, 인스트럭션 큐(IQ)는 LSU(111_4)를 통해서 로드되어 각 프로세싱 엘리먼트 (111_3a) 및 특정 프로세싱 엘리먼트(111_3b)로 전달될 수 있다. 각각의 프로세싱 엘리먼트(111_3a) 및 특정 프 로세싱 엘리먼트(111_3b)는 인스트럭션 큐(IQ)를 전달받아 연산 작업을 수행할 수 있다. 도 20은 도 15의 LSU을 세부적으로 설명하기 위한 블록도이다. 도 20을 참조하면, LSU(111_4)은 로컬 메모리 로드 유닛(LMLU), 로컬 메모리 스토어 유닛(LMSU), 뉴럴 코어 로 드 유닛(NCLU), 뉴럴 코어 스토어 유닛(NCSU), 로드 버퍼(LB), 스토어 버퍼(SB), 로드 엔진(LE), 스토어 엔진 (SE) 및 변환 색인 버퍼(TLB)를 포함할 수 있다. 로컬 메모리 로드 유닛(LMLU)은 L0 메모리(111_2)에 대한 로드 인스트럭션을 페치(fetch)하고, 로드 인스트럭션 을 이슈(issue)할 수 있다. 로컬 메모리 로드 유닛(LMLU)이 이슈된 로드 인스트럭션을 로드 버퍼(LB)에 제공하 면 로드 버퍼(LB)가 입력된 순서에 따라서 순차적으로 로드 엔진(LE)으로 메모리 액세스 요청을 전송할 수 있다. 또한, 로컬 메모리 스토어 유닛(LMSU)은 L0 메모리(111_2)에 대한 스토어 인스트럭션을 페치하고, 스토어 인스 트럭션을 이슈할 수 있다. 로컬 메모리 스토어 유닛(LMSU)이 이슈된 스토어 인스트럭션을 스토어 버퍼(SB)에 제 공하면 스토어 버퍼(SB)가 입력된 순서에 따라서 순차적으로 스토어 엔진(SE)으로 메모리 액세스 요청을 전송할 수 있다. 뉴럴 코어 로드 유닛(NCLU)은 CGRA 엔진에 대한 로드 인스트럭션을 페치하고, 로드 인스트럭션을 이슈할 수 있다. 뉴럴 코어 로드 유닛(NCLU)이 이슈된 로드 인스트럭션을 로드 버퍼(LB)에 제공하면 로드 버퍼(LB)가 입력된 순서에 따라서 순차적으로 로드 엔진(LE)으로 메모리 액세스 요청을 전송할 수 있다. 또한, 뉴럴 코어 스토어 유닛(NCSU)은 CGRA 엔진에 대한 스토어 인스트럭션을 페치하고, 스토어 인스트럭 션을 이슈할 수 있다. 뉴럴 코어 스토어 유닛(NCSU)이 이슈된 스토어 인스트럭션을 스토어 버퍼(SB)에 제공하면 스토어 버퍼(SB)가 입력된 순서에 따라서 순차적으로 스토어 엔진(SE)으로 메모리 액세스 요청을 전송할 수 있 다. 로드 엔진(LE)은 메모리 액세스 요청을 수신하여 L2 인터커넥션을 통해서 데이터를 불러올 수 있다. 이때, 로드 엔진(LE)은 변환 색인 버퍼(TLB)에서 최근에 사용된 가상 주소와 물리 주소의 변환 테이블을 이용하여 빠 르게 데이터를 찾을 수 있다. 로드 엔진(LE)의 가상 주소가 변환 색인 버퍼(TLB)에 없는 경우에는 다른 메모리 에서 주소 변환 정보를 찾을 수 있다. 스토어 엔진(SE)은 메모리 액세스 요청을 수신하여 L2 인터커넥션를 통해서 데이터를 불러올 수 있다. 이 때, 스토어 엔진(SE)은 변환 색인 버퍼(TLB)에서 최근에 사용된 가상 주소와 물리 주소의 변환 테이블을 이용하 여 빠르게 데이터를 찾을 수 있다. 스토어 엔진(SE)의 가상 주소가 변환 색인 버퍼(TLB)에 없는 경우에는 다른 메모리에서 주소 변환 정보를 찾을 수 있다. 도 21은 도 15의 L0 메모리를 세부적으로 설명하기 위한 블록도이다. 도 21을 참조하면, L0 메모리(111_2)는 아비터(Arb) 및 적어도 하나의 메모리 뱅크(bk)를 포함할 수 있다. 데이터가 L0 메모리(111_2)로 저장될 때, 아비터(Arb)는 로드 엔진(LE)으로부터 데이터를 수신할 수 있다. 이때, 데이터는 라운드 로빈(round robin) 방식으로 메모리 뱅크(bk)를 할당 받을 수 있다. 이에 따라서, 데이 터는 적어도 하나의 메모리 뱅크(bk) 중 어느 하나에 저장될 수 있다. 반대로, 데이터가 L0 메모리(111_2)에서 로드될 때, 아비터(Arb)는 메모리 뱅크(bk)로부터 데이터를 수신하여 스토어 엔진(SE)으로 전달될 수 있다. 스토어 엔진(SE)은 로컬 인터커넥션을 통해서 외부로 데이터를 저장 시킬 수 있다. 도 22는 도 21의 L0 메모리 뱅크를 세부적으로 설명하기 위한 블록도이다. 도 22를 참조하면, 메모리 뱅크(bk)는 뱅크 컨트롤러(bkc) 및 뱅크 셀 어레이(bkca)를 포함할 수 있다. 뱅크 컨트롤러(bkc)는 메모리 뱅크(bk)에 저장되는 데이터의 어드레스를 통해서 리드 및 라이트 동작을 관리할 수 있다. 즉, 뱅크 컨트롤러(bkc)는 데이터의 입출력을 전체적으로 관리할 수 있다. 뱅크 셀 어레이(bkca)는 데이터가 직접 저장되는 셀이 행과 열을 맞춰 정렬된 구조일 수 있다. 뱅크 셀 어레이 (bkca)는 뱅크 컨트롤러(bkc)에 의해서 제어될 수 있다. 도 23은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 소프트웨어 계층 구조를 설명하기 위한 블록도 이다. 도 23을 참조하면, 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 소프트웨어 계층 구조는 DL 프레임워 크, 컴파일러 스택 및 백엔드 모듈을 포함할 수 있다. DL 프레임워크는 사용자가 사용하는 딥러닝 모델 네트워크에 대한 프레임워크를 의미할 수 있다. 예를 들어, 텐서플로우나 파이토치와 같은 프로그램을 이용하여 학습이 완료된 뉴럴 네트워크 즉, 딥러닝 그래프가 생성될 수 있다. 딥러닝 그래프는 연산 작업의 코드 형태 표현일 수 있다. 컴파일러 스택은 CGRA 컴파일러(CGCP) 및 메인 컴파일러(Mcp)를 포함할 수 있다. CGRA 컴파일러(CGCP)는 CGRA 엔진 레벨 컴파일링을 수행할 수 있다. 즉, CGRA 컴파일러(CGCP)는 CGRA 엔진 내부의 최적화를 수행 할 수 있다. CGRA 컴파일러(CGCP)는 CGRA 엔진 레벨 컴파일링을 통해서 컴퓨트 라이브러리에 연산 코드 를 저장할 수 있다. 이와 달리 메인 컴파일러(Mcp)는 L2 레벨 즉, CGRA 엔진 그룹 레벨 컴파일링을 수행할 수 있다. 즉, 메인 컴파 일러(Mcp)는 CGRA 엔진 그룹, L2 메모리 및 L2 인터커넥션 사이의 작업 스케쥴링 등의 컴파일링 을 수행할 수 있다. 본 실시예는 CGRA 컴파일링과 메인 컴파일링을 통해서 2번의 최적화를 수행할 수 있다. 메인 컴파일러(Mcp)는 어댑테이션 레이어, 컴퓨트 라이브러리, 프론트엔드 컴파일러, 백 엔드 컴파일러 및 런타임 드라이버를 포함할 수 있다. 어댑테이션 레이어는 DL 프레임워크에 접하는 레이어일 수 있다. 어댑테이션 레이어는 DL 프레임워크에서 생성된 유저의 신경망 모델 즉, 딥러닝 그래프를 양자화시키고 양자화 모델을 생성할 수 있다. 또한, 어댑테이션 레이어는 모델의 타입을 필요한 타입으로 변환시킬 수 있다. 양자화 모델 역시 딥러닝 그래프 형태일 수 있다. 프론트엔드 컴파일러는 어댑테이션 레이어에서 전달받은 양자화 모델을 일정한 중간 표현 (intermediate representation, IR)으로 변환해줄 수 있다. 변환된 IR은 추후 백엔드 컴파일러에서 다 루기 쉬운 미리 설정된 표현일 수 있다. 이러한, 프론트엔드 컴파일러의 IR은 그래프 차원에서 미리 할 수 있는 최적화가 수행될 수 있다. 또한, 프론트엔드 컴파일러는 하드웨어에 최적화된 레이아웃으로 변환시키는 작업을 통해서 최종적으로 IR을 생성할 수 있다. 벡엔드 컴파일러는 프론트엔드 컴파일러에서 변환된 IR을 최적화하고 바이너리 파일로 변환하여 런타임 드라이버가 사용할 수 있게 한다. 백엔드 컴파일러는 하드웨어의 세부 사항에 맞는 스케일로 잡 (job)을 분할하여 최적화된 코드를 생성할 수 있다. 컴퓨트 라이브러리는 여러가지 오퍼레이션 중에 하드웨어에 적합한 형태로 설계된 템플릿 오퍼레이션을 저장할 수 있다. 컴퓨트 라이브러리는 하드웨어가 필요한 여러 템플릿 오퍼레이션을 벡엔드 컴파일러 에 제공하여 최적화된 코드가 생성될 수 있게 한다. 이때, 컴퓨트 라이브러리는 CGRA 컴파일러 (CGCP)로부터 연산 코드를 받아 템플릿 오퍼레이션으로 저장할 수 있다. 이에 따라서, 본 실시예는 이미 최적화 를 수행한 템플릿 오퍼레이션이 다시 백엔드 컴파일러를 통해서 최적화되므로 2번의 최적화가 수행되는 것으로 볼 수 있다. 런타임 드라이버는 구동 중에 계속해서 모니터링을 수행하여 본 발명의 몇몇 실시예들에 따른 뉴럴 네트 워크 장치의 구동을 수행할 수 있다. 구체적으로, 뉴럴 네트워크 장치의 인터페이스의 실행을 담당할 수 있다. 백엔드 모듈는 ASIC(Application Specific Integrated Circuit), FPGA(Field programmable gate array) 및 C-model을 포함할 수 있다. ASIC은 미리 결정된 설계 방식에 따라 결정 되는 하드웨어 칩을 의미할 수 있다. FPGA는 프로그래밍이 가능한 하드웨어 칩일 수 있다. C- model은 소프트웨어 상에 하드웨어를 모사하여 구현한 모델을 의미할 수 있다. 백엔드 모듈은 컴파일러 스택을 통해서 생성된 바이너리 코드를 이용하여 다양한 작업을 수행하 고 결과를 도출할 수 있다. 도 24는 도 23의 CGRA 컴파일러의 구조를 세부적으로 설명하기 위한 블록도이다. 도 5 및 도 24를 참조하면, CGRA 컴파일러(CGCP)는 CE 디멘젼 결정기 및 CE 스케쥴러를 포함할 수 있다. CE 디멘젼 결정기는 입력된 연산 작업에 따라 CGRA 엔진의 스케일을 결정할 수 있다. 즉, CGRA 엔 진에 포함되는 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)의 개수를 CE 디멘젼 결정기 가 결정하여 최적의 연산 작업을 수행할 수 있다. 나아가, CE 디멘젼 결정기는 CGRA 엔진 그룹이 포함하는 CGRA 엔진의 개수를 결정할 수도 있 다. 즉, CGRA 엔진의 디멘젼과 CPC의 디멘젼이 결정되어 최종적인 계층 구조의 단위 구조와 클러스터 구조가 확정될 수 있다. CE 스케쥴러는 CP 레벨 스케쥴링을 수행할 수 있다. CE 스케쥴러는 즉, CGRA 엔진 내부의 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘리먼트(111_3b)의 작업 스케쥴링을 수행할 수 있다. 이에 따라 서, 각 작업의 연산에 대한 연산 코드가 생성될 수 있다. 도 25는 도 24의 CGRA 엔진 스케쥴러의 구조를 세부적으로 설명하기 위한 블록도이다. 도 25를 참조하면, CGRA 엔진 스케쥴러는 CFG(Control-Flow Graph) 생성 모듈, 언롤링 모듈 , 하이퍼블로킹 모듈, 제한 모듈 및 스케쥴링 모듈을 포함할 수 있다. CFG 생성 모듈은 딥러닝 DL 프레임워크로부터 딥러닝 그래프를 수신할 수 있다. 딥러닝 그래프는 DL 프레임워크에 의해서 작성된 코드 형태로 표현될 수 있다. CFG 생성 모듈은 딥러닝 그래프를 오퍼레 이션 단위의 노드와 엣지로 구성된 CFG(CFG)로 변환할 수 있다. CFG(CFG)는 지정된 횟수만큼 반복하여 처리되는 루프를 포함할 수 있고, 조건에 따라 분기되는 조건 분기 구조를 포함할 수도 있다. 언롤링 모듈은 CFG(CFG)에 포함된 루프를 언롤링할 수 있다. 추가적으로, 언롤링 모듈은 루프 필링, 루 프 플랫트닝 및 인라이닝을 수행할 수도 있다. 언롤링 모듈은 CFG(CFG)에 포함된 루프를 언롤링하여 언 롤 CFG(UCFG)를 생성할 수 있다. 하이퍼블로킹 모듈은 언롤 CFG(UCFG)를 수신하여 조건 분기 구조를 재구성하여 하이퍼블럭을 생성할 수 있다. 하이퍼블럭은 서로 다른 블록 중 동일한 조건에 대한 블록을 병합하여 생성될 수 있다. 하이퍼블로킹 모 듈은 하이퍼블로킹 CFG(HCFG)를 생성할 수 있다. 제한 모듈은 미리 작성된 전문가들의 지식을 기반으로 생성된 하드웨어 제한(Cst)을 저장할 수 있다. 하 드웨어 제한(Cst)은 특정 오퍼레이션을 최적화하여 미리 설계해둔 정보를 포함할 수 있다. 즉, 하드웨어 제한은 특정 인풋 연산을 수행할 때, 어떤 방식으로 CGRA 엔진을 재구성할지에 대한 가이드라인으로 작용할 수 있 다. 스케쥴링 모듈은 하이퍼블로킹 CFG(HCFG)를 수신하고, 하드웨어 제한(Cst)을 수신할 수 있다. 스케쥴링 모듈은 하드웨어 제한(Cst)을 기반으로 하이퍼블로킹 CFG(HCFG)를 연산 코드(SC)로 변환하여 생성할 수 있다. 도 26은 도 25의 제한 모듈에 따라 컴파일된 CGRA 엔진을 설명하기 위한 블록도이다. 도 26을 참조하면, CGRA 엔진의 PE 어레이(111_3)는 매트릭스 멀티플리케이션을 수행할 때 프로세싱 엘리 먼트(111_3a)를 멀티플라이어로 구성하고, 특정 프로세싱 엘리먼트(111_3b)를 어큐뮬레이터로 구성할 수 있다. 이러한 구성은 기존의 하드웨어 구현의 이력을 통해서 설정될 수 있다. 즉, 하드웨어 제한(Cst)은 피연산자와 연산자의 구성을 어떤 방식으로 할지에 대한 가이드를 제공할 수 있다. 도 27은 도 23의 프론트엔드 컴파일러의 구조를 세부적으로 설명하기 위한 블록도이다. 도 27을 참조하면, 프론트엔드 컴파일러는 L2 스케쥴러를 포함할 수 있다. L2 스케쥴러는 L2 레벨 즉, CGRA 엔진 그룹 레벨의 스케쥴링을 수행할 수 있다. 즉, L2 스케쥴러(2310 0)는 딥러닝 그래프를 수신하고, 그 연산 작업을 타일링하여 각각의 CGRA 엔진 클러스터와 CGRA 엔진 그룹 의 레벨에서 스케쥴링을 수행할 수 있다. 본 실시예는, CGRA 엔진 레벨의 스케쥴링과 CGRA 엔진 그룹 레벨 의 스케쥴링이 모두 존재하여 최적화의 효율을 극대화시킬 수 있다. 도 28은 도 23의 백엔드 컴파일러의 구조를 세부적으로 설명하기 위한 블록도이다. 도 28을 참조하면, 백엔드 컴파일러는 코드 제네레이터 및 CE 코드 제네레이터를 포함할 수 있다. 코드 제네레이터는 컴퓨트 라이브러리를 참조할 수 있다. 코드 제네레이터는 컴퓨트 라이 브러리에 저장된 연산 코드(SC)를 기반으로 파셜 바이너리 코드를 생성할 수 있다. 파셜 바이너리 코드 는 추후에 합산되어 바이너리 코드를 구성하는 코드일 수 있다. 연산 코드(SC)는 오퍼레이션 기반으로 저장되어 있으므로 파셜 바이너리 코드도 오퍼레이션 기반으로 생성될 수 있다. CE 코드 제네레이터는 파셜 바이너리 코드를 수신할 수 있다. CE 코드 제네레이터는 여러 파셜 바이너리 코드를 합산하여 최종적인 바이너리 코드를 생성할 수 있다. CE 코드 제네레이터는 바이너리 코드를 런타임 드라이버로 전송할 수 있다. 도 29는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치가 수행하는 딥 러닝 연산을 설명하기 위한 개념도 이다. 도 29를 참조하면, 인공신경망 모델은, 기계학습 모델의 일 예로서, 기계학습(Machine Learning) 기술과 인지과학에서, 생물학적 신경망의 구조에 기초하여 구현된 통계학적 학습 알고리즘 또는 그 알고리즘을 실행하 는 구조이다. 인공신경망 모델은, 생물학적 신경망에서와 같이 시냅스의 결합으로 네트워크를 형성한 인공 뉴런인 노 드(Node)들이 시냅스의 가중치를 반복적으로 조정하여, 특정 입력에 대응한 올바른 출력과 추론된 출력 사이의 오차가 감소되도록 학습함으로써, 문제 해결 능력을 가지는 기계학습 모델을 나타낼 수 있다. 예를 들어, 인공 신경망 모델은 기계 학습, 딥러닝 등의 인공지능 학습법에 사용되는 임의의 확률 모델, 뉴럴 네트워크 모델 등을 포함할 수 있다. 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치는 이러한 인공신경망 모델의 형태를 구현하여 연산 을 수행할 수 있다. 예를 들어, 인공신경망 모델은 입력 영상을 수신하고, 입력 영상에 포함된 대상의 적어도 일부에 대한 정보를 출력할 수 있다. 인공신경망 모델은 다층의 노드들과 이들 사이의 연결로 구성된 다층 퍼셉트론(MLP: multilayer perceptron)으로 구현된다. 본 실시예에 따른 인공신경망 모델은 MLP를 포함하는 다양한 인공신경망 모 델 구조들 중의 하나를 이용하여 구현될 수 있다. 도 25에 도시된 바와 같이, 인공신경망 모델은, 외부 로부터 입력 신호 또는 데이터를 수신하는 입력층, 입력 데이터에 대응한 출력 신호 또는 데이터 를 출력하는 출력층, 입력층과 출력층 사이에 위치하며 입력층으로부터 신 호를 받아 특성을 추출하여 출력층으로 전달하는 n개(여기서, n은 양의 정수)의 은닉층(42000 내지 43000)으로 구성된다. 여기서, 출력층은 은닉층(42000 내지 43000)으로부터 신호를 받아 외부로 출력한 다. 인공신경망 모델의 학습 방법에는, 교사 신호(정답)의 입력에 의해서 문제의 해결에 최적화되도록 학습 하는 지도 학습(Supervised Learning) 방법과, 교사 신호를 필요로 하지 않는 비지도 학습(Unsupervised Learning) 방법이 있다. 뉴럴 프로세싱 장치는 인공신경망 모델을 학습시키기 위한 학습 데이터를 시뮬레이션을 통해 직접 생성 할 수 있다. 이와 같이, 인공신경망 모델의 입력층과 출력층에 복수의 입력변수와 대응되 는 복수의 출력변수가 각각 매칭되고, 입력층, 은닉층(42000 내지 43000) 및 출력층에 포함된 노 드들 사이의 시냅스 값이 조정됨으로써, 특정 입력에 대응한 올바른 출력이 추출될 수 있도록 학습될 수 있다. 이러한 학습 과정을 통해, 인공신경망 모델의 입력변수에 숨겨져 있는 특성을 파악할 수 있고, 입력변수 에 기초하여 계산된 출력변수와 목표 출력 간의 오차가 줄어들도록 인공신경망 모델의 노드들 사이의 시 냅스 값(또는 웨이트)을 조정할 수 있다. 도 30은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 뉴럴 네트워크의 학습 및 추론 동작을 설명하기 위한 개념도이다. 도 30을 참조하면, 학습 과정(Training Phase)에서는 다수의 학습 자료(TD)들이 인공신경망 모델(NN)로 포워딩 되고, 다시 백워딩되는 과정을 거칠 수 있다. 이를 통해서 인공신경망 모델(NN)의 각 노드의 웨이트와 바이어스 들이 조율되고 이를 통해서 점점 더욱 정확한 결과를 도출할 수 있게 학습이 수행될 수 있다. 이렇게 학습 과정 (Training Phase)을 통해서 인공신경망 모델(NN)은 학습된 신경망 모델(NN_T)로 변환될 수 있다. 추론 과정(Inference Phase)에서는 새로운 데이터(ND)가 다시 학습된 신경망 모델(NN_T)로 입력될 수 있다. 학 습된 신경망 모델(NN_T)은 새로운 데이터(ND)를 입력으로 하여 이미 학습된 웨이트와 바이어스를 통해서 결과 데이터(RD)를 도출할 수 있다. 이러한 결과 데이터(RD)는 학습 과정(Training Phase)에서 어떤 학습 자료(TD)로 학습하였는지와, 얼마나 많은 학습 자료(TD)를 이용하였는지가 중요할 수 있다. 이하, 도 11, 도 14 및 도 31을 참조하여 본 발명의 몇몇 실시예에 따른 뉴럴 프로세싱 장치의 제어 방법을 설 명한다. 상술한 실시예와 중복되는 부분은 생략하거나 간략히 한다. 도 31은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 제어 방법을 설명하기 위한 순서도이다. 도 31을 참조하면, 모니터링 정보를 수신하여 성능 문제를 검출한다(S100). 구체적으로, 도 11 및 도 14를 참조하면, 시퀀서는 이러한 모니터링 정보(Im)를 수신하여 성능 문제를 검 출할 수 있다. 구체적으로, 성능 문제는 밴드위스가 제한되는 문제 또는 연산 성능이 제한되는 문제 중 적어도 하나일 수 있다. 모니터링 모듈은 모니터링 정보(Im)를 수신할 수 있다. 모니터링 모듈은 모니터링 정보(Im)를 통해서, 어떠한 성능 문제가 있는지 검출할 수 있다. 예를 들어, 밴드위스가 제한되는지, 연산 성능이 제한되는 지 등을 분석할 수 있다. 밴드위스가 제한되는 경우 오프 칩 메모리가 제한되는지, L2 메모리가 제한 되는지 아니면, L2 인터커넥션이 제한되는 건지를 식별할 수 있다. 다시, 도 31을 참조하면, 밴드위스가 제한되었는지를 판단한다(S200). 만일 밴드위스가 제한된 것이 아닌 경우, 연산 성능이 제한되었는지를 판단한다(S300). 만일 그렇다면 CGRA 엔 진 성능을 상승시키는 제어를 수행한다(S500). 구체적으로, 도 14를 참조하면, 프로세서 컨트롤러는 연산 성능이 제한되는 경우 CGRA 엔진의 공급전 력이나 프리퀀시를 상승 제어하는 프로세서 제어 신호(Proc_Cont)를 생성할 수 있다. 프로세서 컨트롤러는 CGRA 엔진로 프로세서 제어 신호(Proc_Cont)를 전송할 수 있다. 다시, 도 31을 참조하면, S200 단계에서 밴드위스가 제한된 것인 경우, 오프 칩 메모리가 제한되었는지를 판단 한다(S400). 만일 그렇다면, 오프 칩 메모리 트래픽을 하향 제어한다(S600). 구체적으로, 도 14를 참조하면, 컴프레션 액티베이터는 오프 칩 메모리가 제한되는 경우, 오프 칩 메 모리의 트래픽의 압축을 수행하고, 다시 압축 해제를 하게하는 메모리 제어 신호(Mem_Cont)를 생성할 수 있 다. 이를 통해, 컴프레션 액티베이터는 오프 칩 메모리의 트래픽 문제를 해결할 수 있다. 메모리 제어 신호(Mem_Cont)는 컴프레션 엔진과 디컴프레션 엔진을 활성화시켜 압축과 압축해제를 수행할 수 있다. 이때, 압 축 및 압축해제는 트랙픽 하향 제어의 하나의 예시에 불과하고, 본 실시예가 이에 제한되는 것은 아니다. 다시, 도 31을 참조하면, 만일 S400 단계에서 오프 칩 메모리가 제한된 것이 아닌 경우, L2 메모리가 제한되었 는지를 판단한다(S700). 만일 그렇다면, L2 메모리 트랙픽을 하향 제어한다(S800). 구체적으로, 도 14를 참조하면, 컴프레션 액티베이터는 L2 메모리가 제한되는 경우, L2 메모리 의 트래픽의 압축을 수행하고, 다시 압축 해제를 하게하는 메모리 제어 신호(Mem_Cont)를 생성할 수 있다. 이를 통해, 컴프레션 액티베이터는 L2 메모리의 트래픽 문제를 해결할 수 있다. 이때, 압축 및 압축해제는 트랙픽 하향 제어의 하나의 예시에 불과하고, 본 실시예가 이에 제한되는 것은 아니다. 다시, 도 31을 참조하면, S700 단계에서 L2 메모리가 제한된 것이 아닌 경우, 인터커넥션 성능을 상승시키는 제 어를 수행한다(S900). 구체적으로, 도 14를 참조하면, 인터커넥트 컨트롤러는 밴드위스가 제한되고, 오프 칩 메모리 또는 L2 메모리가 제한되는 경우, L2 인터커넥션의 프리퀀시를 오버드라이브하게하는 인터커넥션 제어 신호 (Inter_Cont)를 생성할 수 있다. 인터커넥션 제어 신호(Inter_Cont)는 L2 인터커넥션의 프리퀀시를 상승시 켜 밴드위스 제한 문제를 해결할 수 있다. 이때, 프리퀀시 오버드라이브는 인터커넥션 성능 상승 제어의 하나의 예시에 불과하고, 본 실시예가 이에 제한되는 것은 아니다. 이하, 도 23 내지 도 25, 도 27 및 도 32 내지 도 35를 참조하여 본 발명의 몇몇 실시예에 따른 뉴럴 프로세싱 장치의 제어 방법을 설명한다. 상술한 실시예와 중복되는 부분은 생략하거나 간략히 한다. 도 32는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 컴파일링 방법을 설명하기 위한 순서도이고, 도 33은 도 32의 저장 단계를 세부적으로 설명하기 위한 순서도이다. 도 34는 도 33의 저장 단계를 스케쥴링 단계를 세부적으로 설명하기 위한 순서도이고, 도 35는 도 32의 바이너리 코드 생성 단계를 세부적으로 설명하기 위 한 순서도이다. 도 32를 참조하면, 딥러닝 프레임워크로 작성된 딥러닝 그래프를 수신한다(S1100). 구체적으로, 도 23을 참조하면, DL 프레임워크는 사용자가 사용하는 딥러닝 모델 네트워크에 대한 프레 임워크를 의미할 수 있다. 예를 들어, 텐서플로우나 파이토치와 같은 프로그램을 이용하여 학습이 완료된 뉴럴 네트워크 즉, 딥러닝 그래프가 생성될 수 있다. 딥러닝 그래프는 연산 작업의 코드 형태 표현일 수 있다. 다시, 도 32를 참조하면, CGRA 컴파일을 통한 연산 코드를 컴퓨트 라이브러리에 저장한다(S1200). 세부적으로, 도 33을 참조하면, CGRA 엔진의 디멘젼을 결정한다(S1210). 구체적으로, 도 24를 참조하면, CE 디멘젼 결정기는 입력된 연산 작업에 따라 CGRA 엔진의 스케일 즉, 디멘젼을 결정할 수 있다. 즉, CGRA 엔진에 포함되는 프로세싱 엘리먼트(111_3a) 및 특정 프로세싱 엘 리먼트(111_3b)의 개수를 CE 디멘젼 결정기가 결정하여 최적의 연산 작업을 수행할 수 있다. 나아가, CE 디멘젼 결정기는 CGRA 엔진 그룹이 포함하는 CGRA 엔진의 개수를 결정할 수도 있 다. 즉, CGRA 엔진의 디멘젼과 CGRA 엔진 그룹의 디멘젼이 결정되어 최종적인 계층 구조의 단위 구조 와 클러스터 구조가 확정될 수 있다. 다시, 도 33을 참조하면, CGRA 엔진 레벨 스케쥴링을 수행한다(S1220). 세부적으로 도 34를 참조하면, CFG를 생성한다(S1221). 구체적으로, 도 25를 참조하면, CFG 생성 모듈은 딥러닝 DL 프레임워크로부터 딥러닝 그래프를 수신할 수 있다. 딥러닝 그래프는 DL 프레임워크에 의해서 작성된 코드 형태로 표현될 수 있다. CFG 생성 모듈 은 딥러닝 그래프를 오퍼레이션 단위의 노드와 엣지로 구성된 CFG(CFG)로 변환할 수 있다. CFG(CFG)는 지정된 횟수만큼 반복하여 처리되는 루프를 포함할 수 있고, 조건에 따라 분기되는 조건 분기 구조를 포함할 수 도 있다. 다시, 도 34를 참조하면, CFG 언롤링을 수행한다(S1222). 구체적으로, 도 25를 참조하면, 언롤링 모듈은 CFG(CFG)에 포함된 루프를 언롤링할 수 있다. 추가적으로, 언롤링 모듈은 루프 필링, 루프 플랫트닝 및 인라이닝을 수행할 수도 있다. 언롤링 모듈은 CFG(CFG)에 포함된 루프를 언롤링하여 언롤 CFG(UCFG)를 생성할 수 있다. 다시, 도 34를 참조하면, 하이퍼블럭을 형성한다(S1223). 구체적으로, 도 25를 참조하면, 하이퍼블로킹 모듈은 언롤 CFG(UCFG)를 수신하여 조건 분기 구조를 재구 성하여 하이퍼블럭을 생성할 수 있다. 하이퍼블럭은 서로 다른 블록 중 동일한 조건에 대한 블록을 병합하여 생 성될 수 있다. 하이퍼블로킹 모듈은 하이퍼블로킹 CFG(HCFG)를 생성할 수 있다. 다시, 도 34를 참조하면, 미리 설정된 하드웨어 제한에 따른 CGRA 엔진 레벨 스케쥴링을 수행한다(S1224). 이어 서, 연산 코드를 생성한다(S1225). 구체적으로, 도 25를 참조하면, 제한 모듈은 미리 작성된 전문가들의 지식을 기반으로 생성된 하드웨어 제한(Cst)을 저장할 수 있다. 하드웨어 제한(Cst)은 특정 오퍼레이션을 최적화할 때, 어떤 방식으로 구현할지에 대해서 미리 설계해둔 정보일 수 있다. 즉, 하드웨어 제한은 특정 인풋 연산을 수행할 때, 어떤 방식으로 CGRA 엔진을 재구성할지에 대한 가이드라인으로 작용할 수 있다. 스케쥴링 모듈은 하이퍼블로킹 CFG(HCFG)를 수신하고, 하드웨어 제한(Cst)을 수신할 수 있다. 스케쥴링 모듈은 하드웨어 제한(Cst)을 기반으로 하이퍼블로킹 CFG(HCFG)를 연산 코드(SC)로 변환하여 생성할 수 있다. CGRA 컴파일러(CGCP)는 CGRA 엔진 레벨 컴파일링을 통해서 컴퓨트 라이브러리에 연산 코드를 저장 할 수 있다. 다시, 도 32를 참조하면, 딥러닝 그래프를 최적화하여 IR을 생성한다(S1300). 구체적으로, 도 23을 참조하면, 프론트엔드 컴파일러는 어댑테이션 레이어에서 전달받은 다양한 신경망 모델 및 그래프를 일정한 중간 표현(intermediate representation, IR)으로 변환해줄 수 있다. 변환된 IR은 추후 백엔드 컴파일러에서 다루기 쉬운 미리 설정된 표현일 수 있다. 다시, 도 32를 참조하면, IR에 따라 L2 레벨 스케쥴링을 수행한다(S1400). 도 27을 참조하면, L2 스케쥴러는 L2 레벨 즉, CGRA 엔진 그룹 레벨의 스케쥴링을 수행할 수 있다. 즉, L2 스케쥴러는 딥러닝 그래프를 수신하고, 그 연산 작업을 타일링하여 각각의 CGRA 엔진 클러스터 와 CGRA 엔진 그룹의 레벨에서 스케쥴링을 수행할 수 있다. 본 실시예는, CGRA 엔진 레벨의 스케쥴링과 CGRA 엔진 그룹 레벨의 스케쥴링이 모두 존재하여 최적화의 효율을 극대화시킬 수 있다. 다시, 도 32를 참조하면, 컴퓨트 라이브러리에 따른 바이너리 코드를 생성한다(S1500). 세부적으로, 도 35를 참조하면, 파셜 바이너리 코드를 생성한다(S1510). 도 28을 참조하면, 코드 제네레이터는 컴퓨트 라이브러리를 참조할 수 있다. 코드 제네레이터 는 컴퓨트 라이브러리에 저장된 연산 코드(SC)를 기반으로 파셜 바이너리 코드를 생성할 수 있다. 파셜 바이너리 코드는 추후에 합산되어 바이너리 코드를 구성하는 코드일 수 있다. 연산 코드(SC)는 오퍼 레이션 기반으로 저장되어 있으므로 파셜 바이너리 코드도 오퍼레이션 기반으로 생성될 수 있다. 다시, 도 35를 참조하면, 바이너리 코드를 생성한다(S1520). 도 28을 참조하면, CE 코드 제네레이터는 파셜 바이너리 코드를 수신할 수 있다. CE 코드 제네레이터 는 여러 파셜 바이너리 코드를 합산하여 최종적인 바이너리 코드를 생성할 수 있다. CE 코드 제네레이터 는 바이너리 코드를 런타임 드라이버로 전송할 수 있다. 이상의 설명은 본 실시예의 기술 사상을 예시적으로 설명한 것에 불과한 것으로서, 본 실시예가 속하는 기술 분 야에서 통상의 지식을 가진 자라면 본 실시예의 본질적인 특성에서 벗어나지 않는 범위에서 다양한 수정 및 변 형이 가능할 것이다. 따라서, 본 실시예들은 본 실시예의 기술 사상을 한정하기 위한 것이 아니라 설명하기 위 한 것이고, 이러한 실시예에 의하여 본 실시예의 기술 사상의 범위가 한정되는 것은 아니다. 본 실시예의 보호 범위는 아래의 청구범위에 의하여 해석되어야 하며, 그와 동등한 범위 내에 있는 모든 기술 사상은 본 실시예의 권리범위에 포함되는 것으로 해석되어야 할 것이다."}
{"patent_id": "10-2022-0031884", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 시스템을 설명하기 위한 블록도이다. 도 2는 도 1의 뉴럴 프로세싱 장치를 세부적으로 설명하기 위한 블록도이다. 도 3은 도 2의 뉴럴 코어 SoC를 세부적으로 설명하기 위한 블록도이다. 도 4는 도 3의 CGRA 엔진 그룹(CGRA Engine Group)를 세부적으로 설명하기 위한 블록도이다. 도 5는 도 3의 CGRA 엔진 그룹의 하드웨어 구조를 설명하기 위한 개념도이다. 도 6은 뉴럴 코어 SoC의 계층적 구조를 설명하기 위한 개념도이다. 도 7은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치를 설명하기 위한 개념도이다. 도 8은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치를 설명하기 위한 개념도이다. 도 9는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치를 설명하기 위한 개념도이다. 도 10은 도 3의 시퀀서의 동작을 설명하기 위한 개념도이다. 도 11은 도 3의 시퀀서의 모니터링 및 제어 동작을 설명하기 위한 블록도이다. 도 12는 도 3의 시퀀서의 작업 특성에 따른 DVFS(Dynamic Voltage Frequency Scaling)을 설명하기 위한 개념도 이다. 도 13은 도 3의 시퀀서의 가상 장치 상태에 따른 DVFS을 설명하기 위한 개념도이다.도 14는 도 3의 시퀀서의 구조를 세부적으로 설명하기 위한 블록도이다. 도 15는 도 4의 CGRA 엔진의 구조를 세부적으로 설명하기 위한 블록도이다. 도 16은 도 15의 인스트럭션 메모리를 세부적으로 설명하기 위한 개념도이다. 도 17은 도 15의 프로세싱 엘리먼트를 세부적으로 설명하기 위한 도면이다. 도 18은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 ISA(Instruction Set Architecture)를 설명하 기 위한 도면이다. 도 19는 도 4의 CGRA 엔진에서 인스트럭션 큐의 동작을 설명하기 위한 블록도이다. 도 20은 도 15의 LSU을 세부적으로 설명하기 위한 블록도이다. 도 21은 도 15의 L0 메모리를 세부적으로 설명하기 위한 블록도이다. 도 22는 도 21의 L0 메모리 뱅크를 세부적으로 설명하기 위한 블록도이다. 도 23은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 소프트웨어 계층 구조를 설명하기 위한 블록도 이다. 도 24는 도 23의 CGRA 컴파일러의 구조를 세부적으로 설명하기 위한 블록도이다. 도 25는 도 24의 CGRA 엔진 스케쥴러의 구조를 세부적으로 설명하기 위한 블록도이다. 도 26은 도 25의 제한 모듈에 따라 컴파일된 CGRA 엔진을 설명하기 위한 블록도이다. 도 27은 도 23의 프론트엔드 컴파일러의 구조를 세부적으로 설명하기 위한 블록도이다. 도 28은 도 23의 백엔드 컴파일러의 구조를 세부적으로 설명하기 위한 블록도이다. 도 29는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치가 수행하는 딥 러닝 연산을 설명하기 위한 개념도 이다. 도 30은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 뉴럴 네트워크의 학습 및 추론 동작을 설명하기 위한 개념도이다. 도 31은 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 제어 방법을 설명하기 위한 순서도이다. 도 32는 본 발명의 몇몇 실시예들에 따른 뉴럴 프로세싱 장치의 컴파일링 방법을 설명하기 위한 순서도이다. 도 33은 도 32의 저장 단계를 세부적으로 설명하기 위한 순서도이다. 도 34는 도 33의 저장 단계를 스케쥴링 단계를 세부적으로 설명하기 위한 순서도이다. 도 35는 도 32의 바이너리 코드 생성 단계를 세부적으로 설명하기 위한 순서도이다."}
