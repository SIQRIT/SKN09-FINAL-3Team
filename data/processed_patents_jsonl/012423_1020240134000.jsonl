{"patent_id": "10-2024-0134000", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0152260", "출원번호": "10-2024-0134000", "발명의 명칭": "가속기에서 이종 컴포넌트들을 구성하기 위한 방법들 및 장치", "출원인": "인텔 코포레이션", "발명자": "베하르, 마이클"}}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "장치로서,통신 패브릭;머신 판독가능 명령어들;2차 프로그램가능 회로와 연관된 2차 메모리 - 상기 2차 프로그램가능 회로는 1차 프로그램가능 회로와 통신하고, 상기 1차 프로그램가능 회로는 1차 메모리와 연관됨 -;를 포함하고, 상기 2차 프로그램 가능 회로는,상기 통신 패브릭을 통해, 상기 1차 프로그램가능 회로로부터 제1 작업부하를 수신하고;상기 통신 패브릭을 통해, 상기 제1 작업부하에 제1 메모리 부분을 할당하고 - 상기 제1 메모리 부분은 상기 1차 메모리 또는 상기 2차 메모리 중 어느 하나에 위치함 -;상기 통신 패브릭을 통해, 상기 1차 프로그램가능 회로로부터 제2 작업부하를 수신하고;상기 통신 패브릭을 통해, 상기 제2 작업부하에 제2 메모리 부분을 할당하도록 - 상기 제2 메모리 부분은 상기1차 메모리 또는 상기 2차 메모리 중 어느 하나에 위치하고, 상기 제2 메모리 부분의 위치는 상기 제1 작업부하와 상기 제2 작업부하 사이의 관계에 기초함 -상기 머신 판독 가능 명령어들을 인스턴스화(instantiate)하거나 실행하는 것 중 적어도 하나를 수행하는,장치."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 제1 메모리 부분의 위치는 하나 이상의 할당 요소(allocation factor)에 기초하는, 장치."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 하나 이상의 할당 요소는, 할당될 메모리의 양, 상기 1차 메모리의 타입, 상기 2차 메모리의 타입, 상기 1차 메모리의 가용 용량(available capacity), 및 상기 2차 메모리의 가용 용량을 포함하는, 장치."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서,상기 2차 프로그램 가능 회로는 ASIC(Application Specific Integrated Circuit)인, 장치."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항에 있어서,상기 통신 패브릭은, 상기 1차 프로그램가능 회로와 상기 2차 프로그램가능 회로 사이의 데이터 교환을 가능하게 하는 PCIE(peripheral component interconnect express) 회로를 포함하는, 장치."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1항에 있어서,공개특허 10-2024-0152260-3-상기 통신 패브릭은, 상기 2차 프로그램가능 회로와 상기 2차 메모리 사이의 데이터의 교환을 가능하게 하기 위해 AXI(Advanced eXtensible Interface) 프로토콜을 구현하는, 장치."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제1항에 있어서,상기 머신 판독가능 명령어들은, 상기 2차 프로그램가능 회로로 하여금 상기 제1 메모리 부분 및 상기 제2 메모리 부분을 할당하는 플러그인을 구현하게 하는, 장치."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제7항에 있어서,상기 1차 프로그램가능 회로 및 상기 2차 프로그램가능 회로는 이종 하드웨어 아키텍처(heterogeneous hardwarearchitecture)들을 갖고;상기 머신 판독가능 명령어들은, 상기 2차 프로그램가능 회로로 하여금 상기 이종 하드웨어 아키텍처들의 설명을 상기 플러그인에 통합된 포맷으로 제공하게 하는, 장치."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제1항에 있어서,상기 제1 작업부하는 인공 지능 애플리케이션에 대응하는, 장치."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "방법으로서,제2 메모리와 연관된 2차 프로그램가능 회로로 명령어들을 실행하는 단계를 포함하고, 상기 2차 프로그램가능 회로는 1차 프로그램가능 회로와 통신하고, 상기 1차 프로그램가능 회로는1차 메모리와 연관되고, 상기 2차 프로그램가능 회로는:통신 패브릭을 통해, 상기 1차 프로그램가능 회로로부터 제1 작업부하를 수신하고;상기 통신 패브릭을 통해, 상기 제1 작업부하에 제1 메모리 부분을 할당하고 - 상기 제1 메모리 부분은 상기 1차 메모리 또는 상기 2차 메모리 중 어느 하나에 위치함 -;상기 통신 패브릭을 통해, 상기 1차 프로그램가능 회로로부터 제2 작업부하를 수신하고;상기 통신 패브릭을 통해, 상기 제2 작업부하에 제2 메모리 부분을 할당하는 - 상기 제2 메모리 부분은 상기 1차 메모리 또는 상기 2차 메모리 중 어느 하나에 위치하고, 상기 제2 메모리 부분의 위치는 상기 제1 작업부하와 상기 제2 작업부하 사이의 관계에 기초함 -, 방법."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10항에 있어서,상기 제1 메모리 부분의 위치는 하나 이상의 할당 요소에 기초하는, 방법."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제10항에 있어서,상기 하나 이상의 할당 요소는, 할당될 메모리의 양, 상기 1차 메모리의 타입, 상기 2차 메모리의 타입, 상기 1차 메모리의 가용 용량, 및 상기 2차 메모리의 가용 용량을 포함하는, 방법."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제10항에 있어서,상기 2차 프로그램 가능 회로는 ASIC(Application Specific Integrated Circuit)인, 방법.공개특허 10-2024-0152260-4-청구항 14 제10항에 있어서,상기 통신 패브릭은, 상기 1차 프로그램가능 회로와 상기 2차 프로그램가능 회로 사이의 데이터 교환을 가능하게 하는 PCIE(peripheral component interconnect express) 회로를 포함하는, 방법."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제10항에 있어서,상기 통신 패브릭은, 상기 2차 프로그램가능 회로와 상기 2차 메모리 사이의 데이터의 교환을 가능하게 하기 위해 AXI(Advanced eXtensible Interface) 프로토콜을 구현하는, 방법."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제10항에 있어서,상기 명령어들은 상기 2차 프로그램가능 회로로 하여금 상기 제1 메모리 부분 및 상기 제2 메모리 부분을 할당하는 플러그인을 구현하게 하는, 방법."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16항에 있어서,상기 1차 프로그램가능 회로 및 상기 2차 프로그램가능 회로는 이종 하드웨어 아키텍처들을 갖고;상기 명령어들은 상기 2차 프로그램가능 회로로 하여금 상기 이종 하드웨어 아키텍처들의 설명을 상기 플러그인에 통합된 포맷으로 제공하게 하는, 방법."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제10항에 있어서,상기 제1 작업부하는 인공 지능 애플리케이션에 대응하는, 방법."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "적어도 하나의 프로세서에 의해 실행될 때, 상기 프로세서로 하여금 제10항 내지 제18항 중 어느 한 항의 방법을 수행하게 하는 명령어들을 포함하는, 컴퓨터 판독가능 매체."}
{"patent_id": "10-2024-0134000", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제10항 내지 제18항 중 어느 한 항의 방법을 수행하는 수단을 포함하는, 장치."}
{"patent_id": "10-2024-0134000", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "가속기에서 이종 컴포넌트들을 구성하는 방법들, 장치, 시스템들 및 제조 물품들이 개시된다. 예시적인 장치는 작업부하에서 작업부하 노드를 식별하고 작업부하 노드에 대한 선택기를 생성하는 그래프 컴파일러, 및 계산 빌 딩 블록의 입력 조건 및 출력 조건을 식별하는 선택기를 포함하고, 여기서, 그래프 컴파일러는, 선택기로부터 식 별된 입력 조건 및 출력 조건을 획득한 것에 응답하여, 작업부하 노드를 계산 빌딩 블록에 매핑한다."}
{"patent_id": "10-2024-0134000", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시내용은 일반적으로 처리에 관한 것으로, 특히 가속기에서 이종 컴포넌트들을 구성하는 방법들 및 장치에 관한 것이다."}
{"patent_id": "10-2024-0134000", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "컴퓨터 하드웨어 제조자들은 컴퓨터 플랫폼의 다양한 컴포넌트들에서 사용하기 위한 하드웨어 컴포넌트들을 개 발한다. 예를 들어, 컴퓨터 하드웨어 제조자들은 마더보드들, 마더보드들을 위한 칩셋들, 중앙 처리 유닛들 (CPU들), 하드 디스크 드라이브들(HDD들), 솔리드 스테이트 드라이브들(SSD들), 및 다른 컴퓨터 컴포넌트들을 개발한다. 또한, 컴퓨터 하드웨어 제조자는 가속기라고 알려진 처리 요소를 개발하여 작업부하의 처리를 가속 시킨다. 예를 들어, 가속기는 CPU, GPU(graphics processing unit), VPU(Vision processing unit), 및/또는 FPGA(field programmable gate array)일 수 있다."}
{"patent_id": "10-2024-0134000", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "많은 컴퓨팅 하드웨어 제조자들은 작업부하의 처리를 가속화하기 위해 가속기들로서 알려진 처리 요소들을 개발 한다. 예를 들어, 가속기는 CPU, GPU, VPU, 및/또는 FPGA일 수 있다. 더욱이, 가속기들은, 임의 타입의 작업 부하를 처리할 수 있는 한편, 특정 타입들의 작업부하들을 최적화하도록 설계된다. 예를 들어, CPU들 및 FPGA 들은 더 일반적인 처리를 취급하도록 설계될 수 있는 한편, GPU들은 비디오, 게임들, 및/또는 다른 물리 및 수 학 기반 계산들의 처리를 개선하도록 설계될 수 있고, VPU들은 머신 비전 태스크들의 처리를 개선하도록 설계될 수 있다. 또한, 일부 가속기들은 AI(artificial intelligence) 애플리케이션들의 처리를 개선하도록 특정적으로 설계된다. VPU가 특정 타입의 AI 가속기이지만, 많은 상이한 AI 가속기들이 사용될 수 있다. 사실상, 대다수 의 AI 가속기들은 ASIC(application specific integrated circuit)들에 의해 구현될 수 있다. 이러한 ASIC 기 반 AI 가속기들은 머신 러닝(machine learning, ML), 딥 러닝(deep learning, DL)과 같은 특정 타입의 AI, 및/ 또는 SVM들(support vector machines), 신경망들(neural networks, NN들), 회귀 신경망들(recurrent neural networks, RNN들), 컨볼루션 신경망들(convolutional neural networks, CNN들), LSTM(long short term memory), GRU들(gate recurrent units) 등을 포함하는 다른 인공 머신 구동 로직과 관련된 태스크들의 처리를 개선하도록 설계될 수 있다. 컴퓨터 하드웨어 제조자들은 또한 하나보다 많은 타입의 처리 요소를 포함하는 이종 시스템(heterogeneous system)들을 개발한다. 예를 들어, 컴퓨터 하드웨어 제조자들은 CPU들과 같은 범용 처리 요소들을, FPGA들과 같은 범용 가속기들, 및/또는 GPU들, VPU들, 및/또는 다른 AI 가속기들과 같은 더 맞춤화된 가속기들과 조합할 수 있다. 이러한 이종 시스템들은 SoC들(systems on a chip)로서 구현될 수 있다. 개발자가 이종 시스템상의 함수, 알고리즘, 프로그램, 애플리케이션, 및/또는 다른 코드를 실행하기를 원할 때, 개발자 및/또는 소프트웨어는 컴파일 시간에 함수, 알고리즘, 프로그램, 애플리케이션, 및/또는 다른 코드에 대 한 스케줄(예를 들어, 그래프)을 생성한다. 일단 스케줄이 생성되면, 스케줄은 (AOT(Ahead of Time) 또는 JIT(Just in Time) 패러다임들 중 어느 하나로) 실행가능 파일을 생성하기 위해 함수, 알고리즘, 프로그램, 애 플리케이션, 및/또는 다른 코드 스펙과 조합된다. 더욱이, 함수, 알고리즘, 프로그램, 애플리케이션, 및/또는 다른 코드와 조합된 스케줄은 노드들을 포함하는 그래프로서 표현될 수 있으며, 여기서 그래프는 작업부하를 나 타내고 각각의 노드(예를 들어, 작업부하 노드)는 그 작업부하의 특정 태스크를 나타낸다. 또한, 그래프에서의 상이한 노드들 사이의 연결들은 특정 작업부하 노드가 실행되도록 하기 위해 필요한 데이터 입력들 및/또는 출 력들을 나타내고 그래프의 정점들은 그래프의 작업부하 노드들 간의 데이터 의존성들을 나타낸다. 스케줄(예를 들어, 그래프)을 컴파일링하기 위한 공통 구현들은 스케줄(예를 들어, 그래프)을 수신하고 및 가속 기 내에 위치된 다양한 계산 빌딩 블록들(compute building blocks, CBB들)에 작업부하의 다양한 작업부하 노드 들을 할당하는 그래프 컴파일러를 포함한다. 이종 시스템들에서, 그래프 컴파일러는 각각의 독립적인 CBB와 통 신하도록 개별적으로 구성된다. 예를 들어, 그래프 컴파일러가 작업부하 노드를 DSP 및/또는 DSP에 위치되는 커널에 할당 및/또는 다른 방식으로 송신하기 위해, 이러한 그래프 컴파일러는 DSP가 포함하는 입력 및 출력 조 건들(예를 들어, 입력들의 타입들 및 출력들의 타입들)에 대한 지식을 가져야 한다. 다양한 CBB들 (computational building blocks)을 포함하는 이종 시스템들, 또는 다양한 CBB들상에서 실행될 다양한 작업부하 노드들을 수신 및/또는 달리 획득하는 이종 시스템들에서, 단일 그래프 컴파일러를 사용하는 실행은 계산 집약 적이 된다. 또한, 런타임 동안의 CBB들 간의 통신 및 제어는 종종 시스템의 이종 성질로 인해 비실용적이다. 마찬가지로, CBB들 간의 데이터 교환 동기화는 종종 계산 집약적이다. 또한, 이종 시스템 내에 위치된 다양한 커널들에 대한 작업부하의 다양한 작업부하 노드들의 할당은 마찬가지로 그래프 컴파일러가 각각의 독립적인 커널과 통신하도록 개별적으로 구성될 것을 요구한다. 또한, 커널들은 종 종 사용자에 의해 가속기 포스트 프로덕션에 로딩되고, 이와 같으므로 그래프 컴파일러의 재구성을 요구할 것이다. 예를 들어, 그래프 컴파일러는, 그래프 컴파일러의 초기 구성 후에 가속기에 생성되고 및/또는 다른 방식 으로 로딩된 커널에 통신(예를 들어, 작업부하 노드들을 송신)할 수 없을 수 있다. 본 명세서에 개시된 예들은 가속기에서 이종 컴포넌트들을 구성하는 방법들 및 장치를 포함한다. 본 명세서에 개시된 예들은 임의의 스케줄 및/또는 그래프를 사용하여 동작가능한 가속기를 포함한다. 예를 들어, 본 명세 서에 개시된 예들은 임의의 스케줄 및/또는 그래프를 효율적으로 이해하고 가속기에 매핑할 수 있는 그래프 컴 파일러를 포함한다. 본 명세서에 개시되는 이러한 예들의 동작이 이하에서 더 상세히 설명된다. 본 명세서에 개시된 예들은 컴필레이션 시간 동안 다양한 CBB들의 추상화 및/또는 일반화를 포함한다. 본 명세 서에 개시된 예들은 CBB들에 대한 공통 식별을 채택하는 것을 포함한다. 예를 들어, 각각의 CBB는, 이종이든 아니든 간에, CBB와 상호작용하기 위해 각자의 선택기를 생성함으로써 식별될 수 있다. 이러한 예에서, 작업부 하에서의 작업부하 노드들을 분석한 것에 응답하여 선택기가 생성된다. 각각의 작업부하 노드는 종종 실행하기 위해 사용될 CBB의 타입에 대한 상세 사항을 포함하기 때문에, 선택기는 그러한 CBB와 상호작용하도록 될 수 있 다. 본 명세서에 개시된 예들에서, 선택기는 이러한 CBB의 입력 및/또는 출력 조건들을 결정한다. 선택기들은 작업부하 및 작업부하에서의 CBB들과 통신할 수 있는 별개의 엔티티들이다(예를 들어, 작업부하 도메인 및 CBB 도메인에서 통신함). 그 결과, 그래프 컴파일러는 작업부하 도메인에서 동작을 가능하게 하기 위한 플러그인을 포함한다. 본 명세서에서 사용되는 바와 같이, 작업부하 도메인은 작업부하에 기초한 추상화 및/또는 일반화의 레벨을 지칭한다. 마찬가지로, 본 명세서에서 사용되는 바와 같이, CBB 도메인은 CBB(들)에 기초한, 작업부하 도메인보다 더 상세하게 된 추상화 및/또는 일반화의 레벨을 지칭한다. 본 명세서에 개시된 이러한 예들은 시 스템에 내재되거나 나중에 시스템에 포함되는 CBB의 추상화를 가능하게 한다. 본 명세서에 개시된 예들은 입력 및 출력 버퍼들로서 식별되는 버퍼들을 활용한다. 본 명세서에 개시된 이러한 예들에서, 생산자(예를 들어, 또 다른 CBB에 의한 사용을 위해 데이터를 생성 및/또는 다른 방식으로 기입하는 CBB) 또는 소비자(예를 들어, 또 다른 CBB에 의해 생산되는 데이터를 획득 및/또는 다른 방식으로 판독하는 CBB)로서 행위하는 CBB들의 파이프라인은 버퍼들을 사용하여 구현된다. 생산자 또는 소비자 중 어느 하나로서 행위하는 CBB들의 파이프라인을 구현함으로써, 그래프 컴파일러는 작업부하(예를 들어, 그래프)의 작업부하 노드들(예를 들어, 태스크들)을 각각의 CBB에 크기조정 및/또는 할당할 때 일반 휴리스틱들(예를 들어, 문제를 해 결하도록 설계된 기술, 휴리스틱은 작업부하 도메인에서 동작함)을 사용할 수 있다. 본 명세서에 개시된 일부 예들에서, 그래프 컴파일러는 작업부하 노드(예를 들어, 태스크)를 실행하기 위한 버퍼의 슬롯들의 크기 및 수 (예를 들어, 저장소 크기)를 포함할 수 있는 정보를 제공할 수 있다. 이러한 방식으로, 예시적인 크레디트 (credit) 관리자는 버퍼에서의 n개의 슬롯에 기초하여 n개의 크레디트를 생성할 수 있다. 따라서, n개의 크레 디트는 CBB가 그에 기입하거나 그로부터 판독할 수 있는 메모리에서의 이용가능한 n개의 공간을 나타낸다. 크 레디트 생성기는, 구성 제어기에 의해 결정되고 예시적인 패브릭(예를 들어, 제어 및 구성 패브릭)을 통해 통신 되는, 대응하는 생산자 및/또는 소비자에게 패키징하고 송신하기 위해 예시적인 구성 제어기에 n개의 크레디트 를 제공한다. 또한, 본 명세서에 개시된 예들은 그래프 컴파일러를 향해 CBB들의 표준 표현을 구현하는 것을 포함한다. 본 명세서에 개시된 예들은 작업부하에서의 각각의 작업부하 노드에 대해 구성된 선택기를 포함한다. 선택기는 대 응하는 작업부하 노드에 의해 식별된 CBB의 표준 입력 및/또는 출력 조건들을 식별하도록 구성된다. 또한, 이 러한 선택기는 입력 및/또는 출력 조건들에 의해 특정된 추상화된 디바이스들의 리스트를 그래프 컴파일러에 제 공하도록 구성된다. 본 명세서에 개시된 이러한 예들에서, 그래프 컴파일러는 작업부하 노드들(예를 들어, 태 스크들)의 다양한 CBB들로의 매핑을 가능하게 하기 위해 작업부하(예를 들어, 그래프)에서의 작업부하 노드들 (예를 들어, 태스크들)과 다양한 CBB들 사이의 변환 계층(예를 들어, CBB 도메인과 작업부하 도메인 사이의 변 환 계층)을 형성할 수 있는 플러그인을 포함한다. 또한, 본 명세서에 개시된 일부 예들에서, 선택기는 연관된 CBB의 특정 요건들을 그래프 컴파일러에 되돌려 전달할 수 있다. 예를 들어, 선택기는 그래프 컴파일러에 통신 하여 이러한 CBB가 동작하기 위해서 메모리 할당의 특정 백분율을 요구하도록 할 수 있다. 런타임 동안, 본 명세서에 개시된 예들은 CBB들 간의 통신을 가능하게 하기 위해 CBB들을 구성하는데 사용되는 공통 아키텍처를 포함한다. 본 명세서에 개시된 예들은 그래프 컴파일러에 의해 생성된 파이프라인과 연계하여 크레디트들의 시스템을 활용한다. 이러한 시스템은 그래프 컴파일러가 작업부하 노드들(예를 들어, 태스크들) 을 작업부하(예를 들어, 그래프)로부터 생산자 및 소비자 파이프라인으로 매핑할 수 있게 하고 또한 CBB들 간의 통신을 가능하게 하는 것 둘 모두를 한다. 일단 초기 생산자로서 행위하는 CBB(예를 들어, 작업부하 노드를 실 행하여 데이터를 기입하도록 표시하는 CBB)가 작업부하 노드의 실행을 완료하면, 크레디트들은 다음 CBB가 아니 라 CBB에 의해 보여지는 바와 같은 원점 포인트로 되돌려 송신된다. 이러한 원점 포인트는 본 명세서에 개시된 예들에서 크레디트 관리자일 수 있다. 도 1은 가속기에서 이종 컴포넌트들을 구성하는 예시적인 컴퓨팅 시스템을 도시하는 블록도이다. 도 1의 예에서, 컴퓨팅 시스템은 예시적인 시스템 메모리 및 예시적인 이종 시스템을 포함한다. 예시 적인 이종 시스템은 예시적인 호스트 프로세서, 예시적인 제1 통신 버스, 예시적인 제1 가속기 (110a), 예시적인 제2 가속기(110b), 및 예시적인 제3 가속기(110c)를 포함한다. 예시적인 제1 가속기(110a), 예시적인 제2 가속기(110b), 및 예시적인 제3 가속기(110c) 각각은 각자의 가속기들의 동작에 대해 일반적이고 및/또는 특정적인 각종의 CBB들을 포함한다. 도 1의 예에서, 시스템 메모리는 예를 들어, 플래시 메모리, 자기 매체, 광학 매체 등과 같은, 데이터를 저장하기 위한 임의의 디바이스에 의해 구현될 수 있다. 더욱이, 예시적인 시스템 메모리에 저장된 데이 터는 예를 들어, 이진 데이터, 콤마 한정된 데이터(comma delimited data), 탭 한정된 데이터, SQL(structured query language) 구조 등과 같은 임의의 데이터 포맷의 것일 수 있다. 시스템 메모리는 이종 시스템(10 4)에 결합된다. 도 1에서, 시스템 메모리는 호스트 프로세서, 제1 가속기(110a), 제2 가속기(110b), 및 제3 가속기(110c) 중 적어도 하나 사이의 공유 저장소이다. 도 1의 예에서, 시스템 메모리는 컴퓨팅 시스템에 로컬인 물리적 저장소인데; 그러나, 다른 예들에서, 시스템 메모리는 컴퓨팅 시스템에 대해 외부에 있을 수 있고 및/또는 그렇지 않으면 그에 대해 원격일 수 있다. 추가 예들에서, 시스템 메모리 는 가상 저장소일 수 있다. 도 1의 예에서, 시스템 메모리는 비휘발성 메모리(예를 들어, ROM(read only memory), PROM(programmable ROM), EPROM(erasable PROM), EEPROM(electrically erasable PROM) 등)이다. 다른 예들에서, 시스템 메모리는 비휘발성 BIOS(basic input/output system) 또는 플래시 저장 소일 수 있다. 추가 예들에서, 시스템 메모리는 휘발성 메모리일 수 있다. 도 1에서, 이종 시스템은 시스템 메모리에 결합된다. 도 1의 예에서, 이종 시스템은 호스트 프 로세서 및/또는 제1 가속기(110a), 제2 가속기(110b), 또는 제3 가속기(110c) 중 하나 이상의 것상에서 작 업부하를 실행함으로써 작업부하를 처리한다. 도 1에서, 이종 시스템은 SoC(system on a chip)이다. 대안적으로, 이종 시스템은 임의의 다른 타입의 컴퓨팅 또는 하드웨어 시스템일 수 있다. 도 1의 예에서, 호스트 프로세서는 컴퓨터 및/또는 컴퓨팅 디바이스(예를 들어, 컴퓨팅 시스템)와 연 관된 동작들의 완료를 수행 및/또는 다른 방식으로 용이하게 하기 위해 명령어들(예를 들어, 머신 판독가능 명 령어들)을 실행하도록 구성된 처리 요소이다. 도 1의 예에서, 호스트 프로세서는 이종 시스템에 대 한 1차 처리 요소이고 적어도 하나의 코어를 포함한다. 대안적으로, 호스트 프로세서는 (예를 들어, 하나 보다 많은 CPU가 활용되는 예에서) 공동 1차 처리 요소일 수 있는 한편, 다른 예들에서 호스트 프로세서는 2차 처리 요소일 수 있다. 도 1의 도시된 예에서, 제1 가속기(110a), 제2 가속기(110b), 및/또는 제3 가속기(110c) 중 하나 이상은 하드웨 어 가속과 같은, 컴퓨팅 태스크들을 위해 이종 시스템상에서 실행되는 프로그램에 의해 활용될 수 있는 처 리 요소들이다. 예를 들어, 제1 가속기(110a)는 AI(예를 들어, VPU)에 대한 머신 비전 태스크들을 처리하는 처 리 속도 및 전체 성능을 개선하도록 설계되고 및/또는 다른 방식으로 구성되거나 구조화된 처리 자원들을 포함 하는 처리 요소이다. 본 명세서에 개시된 예들에서, 호스트 프로세서, 제1 가속기(110a), 제2 가속기(110b), 및 제3 가속기 (110c) 각각은 컴퓨팅 시스템 및/또는 시스템 메모리의 다른 요소들과 통신한다. 예를 들어, 호스트 프로세서, 제1 가속기(110a), 제2 가속기(110b), 제3 가속기(110c), 및/또는 시스템 메모리는 제1 통신 버스를 통해 통신한다. 본 명세서에 개시된 일부 예들에서, 호스트 프로세서, 제1 가속기 (110a), 제2 가속기(110b), 제3 가속기(110c), 및/또는 시스템 메모리는 임의의 적절한 유선 및/또는 무선 통신 방법을 통해 통신할 수 있다. 또한, 본 명세서에 개시된 일부 예들에서, 호스트 프로세서, 제1 가속 기(110a), 제2 가속기(110b), 제3 가속기(110c), 및/또는 시스템 메모리 각각은 임의의 적절한 유선 및/또 는 무선 통신 방법을 통해 컴퓨팅 시스템 외부의 임의의 컴포넌트와 통신할 수 있다. 도 1의 예에서, 제1 가속기(110a)는 예시적인 컨볼루션 엔진, 예시적인 RNN 엔진, 예시적인 메모리 , 예시적인 메모리 관리 유닛(MMU), 예시적인 DSP, 및 예시적인 제어기를 포함한다. 본 명세서에 개시된 예들에서, 컨볼루션 엔진, RNN 엔진, 메모리, 메모리 관리 유닛(MMU), DSP, 및/또는 제어기 중 임의의 것이 CBB로 지칭될 수 있다. 본 명세서에 개시된 일부 예들에서, 메 모리 및/또는 MMU는 인프라스트럭처 요소들로서 지칭될 수 있다. 예를 들어, 메모리 및/또는 MMU는 제1 가속기(110a)에 외부적으로 구현될 수 있다. 예시적인 컨볼루션 엔진, 예시적인 RNN 엔진 , 예시적인 메모리, 예시적인 MMU, 예시적인 DSP, 및 예시적인 제어기 각각은 예시 적인 제1 스케줄러, 예시적인 제2 스케줄러, 예시적인 제3 스케줄러, 예시적인 제4 스케줄러 , 예시적인 제5 스케줄러, 및 예시적인 제6 스케줄러를 각자가 포함한다. 예시적인 DSP 및 예시적인 제어기 각각은 예시적인 제1 커널 라이브러리 및 예시적인 제2 커널 라이브러리를 추가적으로 포함한다. 도 1의 도시된 예에서, 컨볼루션 엔진은 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로 세서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로 직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적 으로 또는 대안적으로 사용될 수 있다. 컨볼루션 엔진은 컨볼루션과 연관된 태스크들의 처리를 개선하도 록 구성된 디바이스이다. 또한, 컨볼루션 엔진은 시각적 형상 및/또는 CNN들과 연관된 다른 태스크들의 분석과 연관된 태스크들의 처리를 개선한다. 도 1의 예에서, RNN 엔진은, 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집 적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스 (들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대 안적으로 사용될 수 있다. RNN 엔진은 RNN들과 연관된 태스크들의 처리를 개선하도록 구성된 디바이스이 다. 추가적으로, RNN 엔진은 세그먼트화되지 않은 연결된 필기 인식, 음성 인식, 및/또는 RNN들과 연관된 다른 태스크들의 분석과 연관된 태스크들의 처리를 개선한다. 도 1의 예에서, 메모리는, 예를 들어, 플래시 메모리, 자기 매체, 광학 매체 등과 같은, 데이터를 저장하 는 임의의 디바이스에 의해 구현될 수 있다. 또한, 예시적인 메모리에 저장된 데이터는, 예를 들어, 이진 데이터, 콤마 한정된 데이터, 탭 한정된 데이터, SQL(structured query language) 구조 등과 같은 임의의 데이터 포맷의 것일 수 있다. 메모리는 컨볼루션 엔진, RNN 엔진, MMU, DSP, 및 DMA(direct memory access) 기능성을 포함하는 제어기 중 적어도 하나 사이의 공유 저장소이다. 또한, 메 모리는 컨볼루션 엔진, RNN 엔진, MMU, DSP, 및 제어기 중 적어도 하나가 호스 트 프로세서와 독립적으로 시스템 메모리에 액세스하는 것을 허용한다. 도 1의 예에서, 메모리(11 6)는 제1 가속기(110a)에 로컬인 물리적 저장소인데; 그러나, 다른 예들에서, 메모리는 제1 가속기(110a) 외부에 있을 수 있고 및/또는 그렇지 않으면 제1 가속기(110a)에 대해 원격일 수 있다. 추가 예들에서, 메모리 는 가상 저장소일 수 있다. 도 1의 예에서, 메모리는 비휘발성 저장소(예를 들어, ROM(read only memory), PROM(programmable ROM), EPROM(erasable PROM), EEPROM(electrically erasable PROM) 등)이다. 다 른 예들에서, 메모리는 비휘발성 BIOS(basic input/output system) 또는 플래시 저장소일 수 있다. 추가 예들에서, 메모리는 휘발성 메모리일 수 있다. 도 1의 도시된 예에서, 예시적인 MMU는, 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로 세서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로 직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적 으로 또는 대안적으로 사용될 수 있다. MMU는 메모리 및/또는 시스템 메모리의 모든 어드레스 들에 대한 참조들을 포함하는 디바이스이다. MMU는 컨볼루션 엔진, RNN 엔진, DSP, 및/ 또는 제어기 중 하나 이상에 의해 활용되는 가상 메모리 어드레스들을 메모리 및/또는 시스템 메모리 에서의 물리적 어드레스들로 추가로 변환한다. 도 1의 예에서, DSP는, 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집적 회 로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD (들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대안적으로 사용될 수 있다. DSP는 디지털 신호들의 처리를 개선하는 디바이스이다. 예를 들어, DSP는, 카메라 들, 및/또는 컴퓨터 비전에 관련된 다른 센서들로부터의 데이터와 같은 연속적인 실세계 신호들을 측정, 필터링, 및/또는 압축하기 위한 처리를 용이하게 한다. 더 일반적으로, DSP는, 제1 커널 라이브러리(13 6)에서의 예시적인 커널을 통해, 다른 고정된 기능의 CBB들(예를 들어, RNN 엔진, CNN 엔진 등)에 의해 서 빙되지 않는 작업부하로부터 임의의 작업부하 노드를 구현하기 위해 사용된다. 더욱이, 작업부하가 제1 언어 (예를 들어, TensorFlow, CAFFE, ONNX 등)에 기초하여 작성되는 100개의 작업부하 노드를 포함하는 경우, 제1 가속기(110a), 제2 가속기(110b), 및/또는 제3 가속기(110c)는 100개의 작업부하 노드 중 20개 작업부하 노드를 고정 기능들로서 실행하고(예를 들어, RNN 엔진, CNN 엔진 등을 이용하여 실행함), 이후 제1 커널 라이브 러리에서의 각자의 커널을 이용하여 100개의 작업부하 노드 중 나머지 80개 작업부하 노드를 실행할 수 있 다. 이러한 방식으로, 동일 언어(예를 들어, TensorFlow, CAFFE, ONNX 등)에 기반한 임의의 것(any arbitrary)이 제1 가속기(110a), 제2 가속기(110b), 및/또는 제3 가속기(110c)에 매핑될 수 있다. 도 1에서, 제어기는, 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들 어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집적 회로 (들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대안적으로 사용될 수 있다. 제어기는 제1 가속기(110a)의 제어 유닛으로서 구현된다. 예를 들어, 제어기는 제1 가속 기(110a)의 동작을 지도한다. 일부 예들에서, 제어기는 크레디트 관리자를 구현한다. 또한, 제어기(12 2)는 컨볼루션 엔진, RNN 엔진, 메모리, MMU, 및/또는 DSP 중 하나 이상에게 호스트 프로세서로부터 수신된 머신 판독가능 명령어들에 응답하는 방법을 지시할 수 있다. 도 1의 예에서, 제1 스케줄러, 제2 스케줄러, 제3 스케줄러, 제4 스케줄러, 제5 스케줄러 , 및 제6 스케줄러 각각은 컨볼루션 엔진, RNN 엔진, 메모리, MMU, DSP, 및 제어기 각자가 제1 가속기(110a)에 오프로드되었고 및/또는 다른 경우에는 제1 가속기(110a)에 송신되 었던 작업부하의 일부를 실행할 때를 결정하는 디바이스이다. 추가적으로, 제1 커널 라이브러리 및 제2 커널 라이브러리 각각은 하나 이상의 커널을 포함하는 데이터 구조이다. 제1 커널 라이브러리 및 제 2 커널 라이브러리의 커널들은, 예를 들어, 제각기 DSP 및 제어기상에서의 높은 처리량을 위해 컴파일된 루틴들이다. 커널들은, 예를 들어, 컴퓨팅 시스템상에서 실행될 실행파일들의 실행가능 서브섹 션들에 대응한다.본 명세서에 개시된 예들에서, 컨볼루션 엔진, RNN 엔진, 메모리, MMU, DSP, 및 제 어기 각각은 제1 가속기(110a)의 다른 요소들과 통신한다. 예를 들어, 컨볼루션 엔진, RNN 엔진 , 메모리, MMU, DSP, 및 제어기는 예시적인 제2 통신 버스를 통해 통신한다. 일부 예들에서, 제2 통신 버스는 하나 이상의 컴퓨팅 패브릭(예를 들어, 구성 및 제어 패브릭, 데이터 패 브릭 등)에 의해 구현될 수 있다. 본 명세서에 개시된 일부 예들에서, 컨볼루션 엔진, RNN 엔진, 메 모리, MMU, DSP, 및 제어기는 임의의 적절한 유선 및/또는 무선 통신 방법을 통해 통신할 수 있다. 또한, 본 명세서에 개시된 일부 예들에서, 컨볼루션 엔진, RNN 엔진, 메모리, MMU, DSP, 및 제어기 각각은 임의의 적절한 유선 및/또는 무선 통신 방법을 통해 제1 가속기 (110a) 외부의 임의의 컴포넌트와 통신할 수 있다. 이전에 언급한 바와 같이, 예시적인 제1 가속기(110a), 예시적인 제2 가속기(110b), 및/또는 예시적인 제3 가속 기(110c) 중 임의의 것은 각자의 가속기들의 동작에 일반적인 및/또는 특정적인 각종의 CBB들을 포함할 수 있다. 예를 들어, 제1 가속기(110a), 제2 가속기(110b), 및 제3 가속기(110c) 각각은 메모리, MMU, 제어기, 및 CBB들의 각각에 대한 각자의 스케줄러들과 같은 일반적인 CBB들을 포함한다. 추가적으로 또는 대안적으로, 제1 가속기(110a), 예시적인 제2 가속기(110b), 및/또는 예시적인 제3 가속기(110c) 중 임의의 것에 위치되지 않은 외부 CBB들이 포함되고 및/또는 추가될 수 있다. 예를 들어, 컴퓨팅 시스템의 사용자는 제1 가속기 (110a), 제2 가속기(110b), 및/또는 제3 가속기(110c) 중 어느 하나를 활용하여 외부 RNN 엔진을 동작시킬 수 있다. 도 1의 예에서, 제1 가속기(110a)는 VPU를 구현하고 컨볼루션 엔진, RNN 엔진, 및 DSP를 포함 하지만(예를 들어, 제1 가속기(110a)의 동작에 특정적인 CBB들), 제2 가속기(110b) 및 제3 가속기(110c)는 제2 가속기(110b) 및/또는 제3 가속기(110c)의 동작에 특정적인 부가적인 또는 대안적인 CBB들을 포함할 수 있다. 예를 들어, 제2 가속기(110b)가 GPU를 구현하는 경우, 제2 가속기(110b)의 동작에 특정적인 CBB들은 스레드 디 스패처, 그래픽 기술 인터페이스, 및/또는 컴퓨터 그래픽 및/또는 이미지 처리를 처리하는 처리 속도 및 전체적 성능을 개선하는 데 바람직한 임의의 다른 CBB를 포함할 수 있다. 또한, 제3 가속기(110c)가 FPGA를 구현하는 경우, 제3 가속기(110c)의 동작에 특정적인 CBB들은 하나 이상의 산술 논리 유닛(ALU들), 및/또는 일반적 계산 들을 처리하는 처리 속도 및 전체적 성능을 개선하는 데 바람직한 임의의 다른 CBB를 포함할 수 있다. 도 1의 이종 시스템이 호스트 프로세서, 제1 가속기(110a), 제2 가속기(110b), 및 제3 가속기(110 c)를 포함하지만, 일부 예들에서, 이종 시스템은 ASIP들(application-specific instruction set processors), PPU들(physical processing units), 지정된 DSP들, 이미지 프로세서들, 코프로세서들, 부동 소수 점 유닛들, 네트워크 프로세서들, 다중 코어 프로세서들, 및 프론트엔드 프로세서들을 포함하는 임의 수의 처리 요소들(예를 들어, 호스트 프로세서들 및/또는 가속기들)을 포함할 수 있다. 도 2는 예시적인 그래프 컴파일러 및 하나 이상의 예시적인 선택기(들)를 포함하는 예시적인 컴퓨팅 시스템을 도시하는 블록도이다. 도 2의 예에서, 컴퓨팅 시스템은 예시적인 작업부하 및 예시적 인 가속기를 추가로 포함한다. 더욱이, 도 2에서, 가속기는 예시적인 크레디트 관리자, 예시적 인 CnC(control and configure) 패브릭, 예시적인 컨볼루션 엔진, 예시적인 MMU, 예시적인 RNN 엔진, 예시적인 DSP, 예시적인 메모리, 및 예시적인 구성 제어기를 포함한다. 도 2의 예 에서, 메모리는 예시적인 DMA 유닛 및 하나 이상의 예시적인 버퍼를 포함한다. 본 명세서에 개 시된 다른 예들에서, 임의의 적절한 CBB가 가속기에 포함되고 및/또는 추가될 수 있다. 도 2의 도시된 예에서, 예시적인 그래프 컴파일러는 컴파일링을 위한 수단 또는 컴파일링 수단이다. 도 2 의 도시된 예에서, 하나 이상의 선택기(들)의 예시적인 선택기는 선택하기 위한 수단, 또는 선택 수단이다. 도 2의 도시된 예에서, 예시적인 크레디트 관리자는 크레디트 관리를 위한 수단, 또는 크레디트 관리 수단이 다. 도 2의 도시된 예에서, 예시적인 구성 제어기는 제어하기 위한 수단, 또는 제어 수단이다. 도 2의 예에서, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 메모리, 및/또는 커널 뱅크에서 의 커널 중 임의의 것은 컴퓨팅을 위한 수단, 또는 컴퓨팅 수단일 수 있다. 도 2의 도시된 예에서, 그래프 컴파일러는, 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현 된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서 (들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디 바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대안적으로 사용될 수 있다. 도 2에서, 그래프 컴파일러는 하나 이상의 선택기(들)에 및 가속기에 결합된다. 동작 시에, 그래프 컴파일러는 작업부하를 수신하고 작업부하를 예시적인 실행가능 파일로 컴파일링하여 가속기에 의해 실행되도록 한다. 예를 들어, 그래프 컴파일러는 작업부하를 수신하고 작업부하(예를 들어, 그래프)의 다양한 작업부하 노드들을 가속기의 다양 한 CBB들(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 DMA 유닛)에 할 당한다. 그래프 컴파일러는 또한 작업부하에서의 각각의 작업부하 노드에 대응하는 하나 이상의 선 택기(들) 중 예시적인 선택기를 생성한다. 덧붙여, 그래프 컴파일러는 가속기의 메모리에 서의 하나 이상의 버퍼에 대해 메모리를 할당한다. 본 명세서에 개시된 예에서, 실행가능 파일은 별 도의 시스템(예를 들어, 컴필레이션(compilation) 시스템 및/또는 컴필레이션 프로세서)상에서 생성되고, 상이 한 시스템(예를 들어, 배치(deployment) 시스템, 실행 시간 시스템, 배치 프로세서 등)상에서의 나중의 사용을 위해 저장될 수 있다. 예를 들어, 그래프 컴파일러 및 하나 이상의 선택기는 가속기와는 별도 의 시스템상에 위치될 수 있다. 도 2에 도시된 예에서, 하나 이상의 선택기(들)가, 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의 해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프 로세서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가 적으로 또는 대안적으로 사용될 수 있다. 하나 이상의 선택기(들)는 그래프 컴파일러, 가속기, 및 DSP 내에 위치된 예시적인 커널 뱅크에 결합된다. 하나 이상의 선택기(들)는 작업부하(20 6)를 획득하기 위해 그래프 컴파일러에 결합된다. 작업부하에서의 각각의 작업부하 노드(예를 들어, 태스크)는 연관된 작업부하 노드를 실행하기 위해 사용될 CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 DMA 유닛 중 임의의 것)를 나타낸다. 본 명세서에 개시된 예들에서, 하나 이상의 선택기(들) 중의 한 선택기는 각각의 작업부하 노드에 대해 생성되고 대응하는 CBB(예를 들어, 컨 볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 DMA 유닛 중 임의의 것) 및/또는 커널 뱅크에서의 커널들과 연관된다. 하나 이상의 선택기(들)는 작업부하에 응답하여 그래프 컴파일 러에 의해 생성되고, 이와 같으므로, 다양한 CBB들(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진 , DSP, 및/또는 DMA 유닛 중 임의의 것) 및/또는 커널 뱅크에서의 커널들의 각자의 입력 및/또는 출력 조건들을 식별할 수 있다. 하나 이상의 선택기(들)에 의한 이러한 식별은 그래프 컴파일러 에 의한 사용을 위해 추상화된 지식으로서 표현될 수 있다. 이러한 추상화된 지식은 그래프 컴파일러가 가속기의 이종 성질과 독립적으로 동작할 수 있게 한다. 또한, 그래프 컴파일러는 작업부하로부터의 제각기 작업부하 노드를 대응하는 CBB(예를 들어, 컨볼루 션 엔진, MMU, RNN 엔진, DSP, 및/또는 DMA 유닛 중 임의의 것) 및/또는 커널 뱅크 에서의 커널들에 매핑하기 위해 하나 이상의 선택기(들)를 활용한다. 더욱이, 그래프 컴파일러(20 2)는 적절한 양의 크레디트들 등으로 대응하는 작업부하 노드 및 인접한 작업부하 노드들(예를 들어, 작업부하 노드들의 결과적인 소비자들 및/또는 생산자들)당 특정적 동작 및 파라미터들을 위해 대응하는 CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 DMA 유닛 중 임의의 것)를 구성하도록 하나 이상의 선택기(들)를 활용한다. 본 명세서에 개시된 일부 예들에서, 하나 이상의 선택기(들)는 작업부하로부터의 제각기 작업부하 노드들을 대응하는 CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 DMA 유닛 중 임의의 것) 및/또는 커널 뱅크에서의 커널들에 매핑할 수 있다. 본 명세서에 개시된 예들에서, 하나 이상의 선택기(들)가 그래프 컴파일러에 포함될 수 있다. 본 명 세서에 개시된 이러한 예들에서, 작업부하 및/또는 가속기에서의 변화들(예를 들어, 제공된 새로운 작업부하, 가속기에 추가된 추가적인 CBB들 등)에 응답하여 추가적인 선택기들이 하나 이상의 선택기 (들) 내에 포함될 수 있거나, 또는 대안적으로, 하나 이상의 선택기(들) 내의 현재 선택기들이 변경 될 수 있다. 일부 예들에서, 그래프 컴파일러는 데이터가 스케일링될 것임을 나타내는 작업부하 노드를 작업부하 로부터 식별한다. 데이터가 스케일링될 것임을 나타내는 이러한 작업부하 노드는 이러한 태스크와 연관된 하나 이상의 선택기(들)에 송신된다. 식별된 작업부하 노드와 연관된 하나 이상의 선택기(들)는, 그래프 컴파일러가 작업부하 노드를 실행하기 위해서, CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진 , DSP, 및/또는 DMA 유닛 중 임의의 것) 및/또는 커널 뱅크에서의 커널을, 이러한 식별된 CBB 및/또는 커널 뱅크에서의 커널의 식별된 입력 및/또는 출력 조건들과 함께, 식별할 수 있다. 도 2의 예에서, 작업부하는, 예를 들어, 가속기에 의해 실행될 그래프, 함수, 알고리즘, 프로그램, 애플리케이션, 및/또는 다른 코드이다. 일부 예들에서, 작업부하는 그래프, 함수, 알고리즘, 프로그램, 애플리케이션, 및/또는 다른 코드의 기술(description)이다. 작업부하는 사용자로부터 획득된 임의의 그 래프 및/또는 임의의 적절한 입력일 수 있다. 예를 들어, 작업부하는 딥 러닝 토폴로지 및/또는 컴퓨터 비전과 같은 AI 처리와 관련된 작업부하일 수 있다. 동작 시에, 작업부하(예를 들어, 그래프)에서의 각각 의 작업부하 노드는 특정 CBB들(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 DMA 유닛 중 임의의 것), 커널 뱅크에서의 커널들, 및/또는 작업부하 노드에서 태스크를 실행하기 위 한 입력 및/또는 출력 조건들을 지정하는 제약들을 포함한다. 따라서, 그래프 컴파일러에 포함된 예시적 인 플러그인은 작업부하(예를 들어, 그래프)의 작업부하 노드와 연관된 CBB 및/또는 커널 뱅크 에서의 커널 사이의 매핑을 가능하게 한다. 플러그인은 하나 이상의 선택기(들)에 의해 획득된 추상 화된 지식(예를 들어, 각각의 CBB 및/또는 커널 뱅크에서의 커널의 각자의 표준 입력 및/또는 출력 정의들)과 상호작용하여 작업부하(예를 들어, 그래프)에서의 작업부하 노드들을 할당한다. 본 명세서에 개시된 이러한 예들에서, 플러그인은 작업부하(예를 들어, 그래프)에서의 작업부하 노드들과 다양한 CBB들(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 DMA 유닛 중 임의의 것) 및/또는 커널 뱅크에서의 커널들 사이의 변환 계층을 형성하여, 하나 이상의 선택기(들)에 의해 획득된 추상화된 지식(예를 들어, 각각의 CBB 및/또는 커널 뱅크에서의 커널의 각자의 표준 입력 및/또는 출력 정의들)에 기초하여 작업부하에서의 작업부하 노드들의 다양한 CBB들(예를 들어, 컨볼루션 엔진 , MMU, RNN 엔진, DSP, 및/또는 DMA 유닛 중 임의의 것) 및/또는 커널 뱅크에 서의 커널들로의 매핑을 가능하게 할 수 있다. 도 2의 예에서, 가속기는 그래프 컴파일러에 및 하나 이상의 선택기(들)에 결합된다. 본 명세 서에 개시되는 일부 예들에서, 컴필레이션 시간 동안, 그래프 컴파일러는 컴필레이션 시스템(예를 들어, 제1 프로세서)상에서 동작하고, 컴필레이션 프로세스를 수행하기 위해 (예를 들어, 실행가능 파일을 생성 하기 위해) 하나 이상의 선택기(들)를 활용할 수 있다. 그 결과, 그래프 컴파일러는 컴필레이션 시 스템(예를 들어, 제1 프로세서)상에서 예시적인 실행가능 파일을 생성한다. 추가적으로 또는 대안적으로, 실행가능 파일은 나중의 사용을 위해 데이터베이스에 저장될 수 있다. 예를 들어, 실행가능 파일은, 컴필레이션 시스템(예를 들어, 제1 프로세서) 및/또는 임의의 외부 및/또는 내부 시스템(예를 들어, 배치 시스 템, 제2 프로세서 등)상에 저장 및 실행될 수 있다. 런타임 동안, 실행가능 파일은 배치 시스템(예를 들 어, 도 1의 시스템, 제2 프로세서 등)에서 동작가능하다. 컴필레이션 시스템(예를 들어, 제1 프로세서)은 배치 시스템(예를 들어, 도 1의 시스템, 제2 프로세서 등)과는 별개의 위치에서 동작가능할 수 있다. 대 안적으로, 컴필레이션 시스템 및/또는 배치 시스템은 조합될 수 있고, 이와 같으므로 임의의 작업부하들(예를 들어, 작업부하)의, 가속기에 의해 즉시 실행되고 있는 실행파일들(예를 들어, 실행가능 파일)로의 JIT(just in time) 컴필레이션을 가능하게 한다. 도 2의 도시된 예에서, 크레디트 관리자가 CnC 패브릭에 결합된다. 크레디트 관리자는 예를 들 어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디 지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대안적으로 사용될 수 있다. 크레디트 관리자는 컨볼루션 엔진, MMU, RNN 엔진, 및/또는 DSP 중 하나 이상과 연관된 크레디트들을 관리하 는 디바이스이다. 일부 예들에서, 크레디트 관리자는 제어기에 의해 크레디트 관리자 제어기로서 구현될 수 있다. 크레디트들은 메모리에서 이용가능한 작업부하 노드들과 연관된 데이터 및/또는 작업부하 노드 의 출력을 위해 메모리에서 이용가능한 공간의 양을 나타낸다. 또 다른 예에서, 크레디트들 및/또는 크레 디트 값은 데이터를 저장 및/또는 그렇지 않으면 기입하는 데 이용가능한 버퍼(예를 들어, 버퍼들 중 하나)에서의 슬롯들의 수를 나타낼 수 있다. 크레디트 관리자 및/또는 구성 제어기는, 그래프 컴파일러로부터 수신되고 구성 제어기에 의해 분배되는 실행가능 파일에 기초하여 주어진 작업부하의 각각의 작업부하 노드와 연관된 하나 이상의 버퍼(예를 들어, 버퍼들)로 메모리를 분할할 수 있다. 이와 같으므로, 크레디트들은 데이터를 저장 및/또는 그렇지 않으면 기입하기 위해 이용가능한 연관된 버퍼(예를 들어, 버퍼들)에서의 슬롯들을 나타낼 수 있다. 예를 들어, 크레디트 관리자는 작업부하에 대응하는 정보(예를 들어, 구성 및 제어 메시지 들 및/또는 다른 방식으로 구성 메시지들 및 제어 메시지들)를 수신한다. 예를 들어, 크레디트 관리자는 구성 제어기로부터, CnC 패브릭을 경유해, 생산자로서 초기화된 CBB들 및 소비자로서 초기화 된 CBB들을 나타내는 구성 제어기에 의해 결정된 정보를 수신한다. 본 명세서에 개시된 예들에서, 특정 작업부하 노드를 실행할 것을 나타내는 구성 제어기로부터 수신된 명 령어에 응답하여(예를 들어, 구성 제어기가 구성 및 제어 메시지들을 전송한 것에 응답하여), 크레디 트 관리자는 초기 생산자로서 행위하는 CBB에게 대응하는 크레디트들을 제공 및/또는 그렇지 않으면 전송 한다(예를 들어, 컨볼루션 엔진에 3개의 크레디트를 제공하여 버퍼의 3개 슬롯에 데이터를 기입하도록 한 다). 일단 초기 생산자로서 행위하는 CBB가 작업부하 노드를 완료하면, 크레디트들은 CBB에 의해 보여지는 바 와 같은 원점 포인트(예를 들어, 크레디트 관리자)로 되돌려 송신된다. 크레디트 관리자는, 생산자 로부터의 크레디트들을 획득한 것에 응답하여, 소비자로서 행위하는 CBB에 크레디트들을 제공 및/또는 그렇지 않으면 전송한다(예를 들어, DSP는 3개의 크레디트를 획득하여 버퍼의 3개의 슬롯으로부터 데이터를 판독 한다). 이러한 생산자 및 소비자들의 순서는 실행가능 파일을 사용하여 결정된다. 이러한 방식으로, CBB 들은 그들의 이종 성질에 관계없이 크레디트 관리자를 통해 동작하기 위해 능력의 표시를 통신한다. 생산 자 CBB는 또 다른 CBB에 의해 활용되는 데이터를 생성하는 반면, 소비자 CBB는 또 다른 CBB에 의해 생산된 데이 터를 소비 및/또는 그렇지 않으면 처리한다. 본 명세서에 개시된 일부 예들에서, 크레디트 관리자는 작업부하 노드의 실행이 완료되었는지를 결정하도 록 구성될 수 있다. 이러한 예에서, 크레디트 관리자는 작업부하 노드와 연관된 CBB들에서의 모든 크레디 트들을 클리어할 수 있다. 도 2의 예에서, CnC 패브릭은 크레디트 관리자, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 메모리, 및 구성 제어기에 결합된다. 본 명세서에 개시된 일부 예들에서, 메모리 및 /또는 MMU는 인프라스트럭처 요소들로서 지칭될 수 있고 CnC 패브릭에 결합되지 않을 수 있다. CnC 패브릭은, 크레디트 관리자, 컨볼루션 엔진, MMU, RNN 엔진, 및/또는 DSP 중 하나 이상이 크레디트 관리자, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 메모리, 및/또는 구성 제어기 중 하나 이상에 크레디트들을 전송하고 및/또는 그로부터 크레디트들을 수신하는 것 을 허용하는 와이어들 및 적어도 하나의 로직 회로의 네트워크를 포함하는 제어 패브릭이다. 또한, CnC 패브릭 은 하나 이상의 선택기(들)에 및/또는 그로부터 예시적인 구성 및 제어 메시지를 전송하도록 구 성된다. 본 명세서에 개시된 다른 예들에서, CnC 패브릭을 구현하기 위해 임의의 적합한 컴퓨팅 패브릭이 사용될 수 있다(예를 들어, AXI(Advanced eXtensible Interface) 등). 도 2의 도시된 예에서, 컨볼루션 엔진은 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로 세서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로 직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적 으로 또는 대안적으로 사용될 수 있다. 컨볼루션 엔진은 CnC 패브릭에 결합된다. 컨볼루션 엔진 은 컨볼루션과 연관된 태스크들의 처리를 개선하도록 구성된 디바이스이다. 또한, 컨볼루션 엔진은 시각적 형상 및/또는 CNN들과 연관된 다른 태스크들의 분석과 연관된 태스크들의 처리를 개선한다. 도 2의 도시된 예에서, 예시적인 MMU는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주 문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스 (들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대 안적으로 사용될 수 있다. MMU는 CnC 패브릭에 결합된다. MMU는 메모리 및/또는 가속기 에 대해 원격인 메모리의 어드레스들의 변환을 가능하게 하는 디바이스이다. MMU는 크레디트 관리자 , 컨볼루션 엔진, RNN 엔진, 및/또는 DSP 중 하나 이상에 의해 활용되는 가상 메모리 어드 레스들을, 메모리 및/또는 가속기에 대해 원격인 메모리에서의 물리적 어드레스들로 추가로 변환한다. 도 2에서, RNN 엔진은 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집적 회 로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD (들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대안적으로 사용될 수 있다. RNN 엔진은 CnC 패브릭에 결합된다. RNN 엔진은 RNN들과 연관된 태스크들의처리를 개선하도록 구성된 디바이스이다. 추가적으로, RNN 엔진은 세그먼트화되지 않은 연결된 필기 인식, 음성 인식, 및/또는 RNN들과 연관된 다른 태스크들의 분석과 연관된 태스크들의 처리를 개선한다. 도 2의 예에서, DSP는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집적 회 로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD (들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대안적으로 사용될 수 있다. DSP는 CnC 패브릭에 결합된다. DSP는 디지털 신호들의 처리를 개선하는 디바 이스이다. 예를 들어, DSP는, 카메라들, 및/또는 컴퓨터 비전에 관련된 다른 센서들로부터의 데이터와 같 은 연속적인 실세계 신호들을 측정, 필터링, 및/또는 압축하는 처리를 용이하게 한다. 도 2의 예에서, 메모리는 예를 들어, 플래시 메모리, 자기 매체, 광학 매체 등과 같은 데이터를 저장하는 임의의 디바이스에 의해 구현될 수 있다. 더욱이, 예시적인 메모리에 저장된 데이터는 예를 들어, 이진 데이터, 콤마 한정된 데이터, 탭 한정된 데이터, SQL(structured query language) 구조 등과 같은 임의의 데이 터 포맷의 것일 수 있다. 메모리는 CnC 패브릭에 결합된다. 메모리는 크레디트 관리자, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 구성 제어기 중 적어도 하나 사이의 공유 저장소이다. 메모리는 DMA 유닛을 포함한다. 또한, 메모리는 구성 제어기 및/또는 크레디트 관리자에 의해 수신된 실행파일과 연관된 작업부하의 하나 이상의 작업부하 노드와 연관된 하나 이상의 버퍼로 분할될 수 있다. 또한, 메모리의 DMA 유닛은 CnC 패브릭을 경유해 구성 제 어기에 의해 제공되는 커맨드들에 응답하여 동작한다. 본 명세서에 개시된 일부 예들에서, 메모리의 DMA 유닛은 크레디트 관리자, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 구 성 제어기중 적어도 하나가 각자의 프로세서(예를 들어, 호스트 프로세서)에 독립적인 가속기에 원격인 메모리(예를 들어, 시스템 메모리)에 액세스하는 것을 허용한다. 도 2의 예에서, 메모리는 가속기에 로컬인 물리적 저장소이다. 추가적으로 또는 대안적으로, 다른 예들에서, 메모리는 가속기 에 대해 외부에 있을 수 있고 및/또는 그렇지 않으면 원격에 있을 수 있다. 본 명세서에 개시된 추가 예 들에서, 메모리는 가상 저장소일 수 있다. 도 2의 예에서, 메모리는 비휘발성 저장소(예를 들어, ROM, PROM, EPROM, EEPROM 등)이다. 다른 예들에서, 메모리는 비휘발성 BIOS 또는 플래시 저장소일 수 있다. 추가 예들에서, 메모리는 휘발성 메모리일 수 있다. 본 명세서에 개시된 예들에서, 구성 제어기는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구 현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세 서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대안적으로 사용될 수 있다. 구성 제어기는 가속기의 제어 유닛으로서 구현된다. 본 명세서에 개시된 예들에서, 하나 이상의 선택기(들)는 실행가능 파일을 생성하기 위해서 구성 및 제어 메시지 들을 그래프 컴파일러에 전송한다. 본 명세서에 개시된 일부 예들에서, 구성 제어기는 실행가 능 파일에 포함되는 작업부하 노드들을 나타내는 구성 및 제어 메시지들(예를 들어, 하나 이상의 선택기 (들)에 의해 획득되고 및/또는 그에 송신되는 구성 및 제어 메시지들)을 식별하기 위해 실행가능 파 일을 획득하고 파싱할 수 있다. 이와 같으므로, 구성 제어기는 실행가능 파일의 태스크들을 수 행하기 위해서 다양한 CBB들에 구성 및 제어 메시지들(예를 들어, 하나 이상의 선택기(들)에 의해 획득되 고 및/또는 그에 송신되는 구성 및 제어 메시지들)을 제공한다. 본 명세서에 개시된 이러한 예에서, 구성 및 제어 메시지들은 실행가능 파일에 임베디드되고, 이와 같으므로, 구성 제어기에 제공되고, 다양한 CBB들 및/또는 커널 뱅크에 위치된 커널들에 송신된다. 예를 들어, 구성 제어기는 실행가능 파일을 파싱하여 실행파일에서의 작업부하 노드들을 식별하고, 컨볼루션 엔진, MMU, RNN 엔진 , DSP, 커널 뱅크에서의 커널, 및/또는 메모리 중 하나 이상에게, 실행가능 파일 및 /또는 크레디트 관리자를 경유해 그래프 컴파일러로부터 수신된 다른 머신 판독가능 명령어들에 어떻 게 응답할지를 지시한다. 본 명세서에 개시된 예들에서, 구성 제어기는 획득된 실행가능 파일로부터 식별된 대응하는 CBB들로 작업부하 노드들을 (예를 들어, 구성 및 제어 메시지 포맷으로) 전송한다. 마찬가지로, 구성 제어기는 크 레디트들의 분배를 개시하기 위해 작업부하 노드들을 (예를 들어, 구성 및 제어 메시지 포맷으로) 크레디트 관 리자에게 전송할 수 있다. 도 2의 예에서, 컨볼루션 엔진, MMU, RNN 엔진, 및/또는 DSP는 제각기 각자의 스케줄러들 (238, 240, 242, 및 244)을 포함할 수 있다. 동작 시에, 스케줄러들(238, 240, 242, 및 244)은 제각기, 구성 제어기, 크레디트 관리자, 및/또는 가속기의 추가적인 CBB에 의해, 컨볼루션 엔진, MMU, RNN 엔진, 및/또는 DSP에 제각기 할당된 작업부하의 일부(예를 들어, 작업부하 노드)를 실행한다. 주어진 작업부하 노드의 태스크들 및/또는 다른 동작들에 좌우되어, 작업부하 노드는 생산 자 및/또는 소비자일 수 있다. 도 2의 예에서, 스케줄러들(238, 240, 242, 244) 중 임의의 것은, 크레디트 관리자에 의해 제공된 표시에 응답하여, 데이터(예를 들어, 생산자)를 대응하는 CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진 , 및/또는 DSP 중 임의의 것)에 대한 버퍼(예를 들어, 버퍼들 중 적어도 하나)에 기입하도록 표 시하는 작업부하 노드와 연관된 크레디트 값을 수신하고 및/또는 그렇지 않으면 메모리에 로딩할 수 있다. 예 를 들어, 실행가능 파일이 RNN 엔진이 생산자로서 행위하고 3개의 데이터 비트를 버퍼(예를 들어, 버 퍼들 중 하나)에 기입하는 것을 나타내는 경우, 스케줄러는 RNN 엔진에 3개의 크레디트 값을 로 딩할 수 있다. 추가적으로, 이러한 예에서, 실행가능 파일은 MMU가 RNN 엔진(예를 들어, 소비 자로서 행위함)에 의해 이전에 기입된 3개의 비트를 판독할 것임을 나타낼 수 있다. 이와 같으므로, 스케줄러 (또는 RNN 엔진)는 3개의 크레디트를, 일단 사용되면, CnC 패브릭 및 크레디트 관리자를 경유해 MMU에 전송한다. 동작 시에, 스케줄러(238, 240, 242, 244) 및/또는 CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진 , 및/또는 DSP 중 임의의 것)는 증분적으로 및/또는 임의의 적절한 방법을 이용하여 크레디트들을 전 송할 수 있다. 또 다른 예에서, 제1 CBB는 제1 작업부하 노드를 실행하기 위해 제공된 제1 크레디트 값을 가질 수 있다. 그러한 예에서, 제1 작업부하 노드를 실행한 것에 응답하여, 제1 CBB는 데이터를 메모리에서의 제1 버퍼(예를 들어, 버퍼들 중 하나)에 기입하고, 제2 크레디트 값을 크레디트 관리자에 전송한다. 제2 크레디트 값은 제1 버퍼(예를 들어, 버퍼들 중 하나)에 데이터를 기입하기 위해 사용되는 제1 크레디 트 값의 양을 나타낸다. 예를 들어, 제1 크레디트 값이 3이고, 제1 CBB가 버퍼(예를 들어, 버퍼들 중 하 나)의 2개의 슬롯에 기입하는 경우, 제1 CBB는 크레디트 관리자에게 2개의 크레디트를 전송한다. 이에 응 답하여, 크레디트 관리자는 버퍼(예를 들어, 버퍼들 중 하나)의 2개의 슬롯에서 데이터를 판독하기 위해 제2 크레디트 값(예를 들어, 2개의 크레디트)을 활용하는 제2 CBB에 제2 크레디트 값(예를 들어, 2개의 크 레디트)을 전송한다. 이와 같으므로, 이후 제2 CBB는 제2 작업부하 노드를 실행할 수 있다. 본 명세서에 개시 된 예들에서, 버퍼들은 데이터를 판독 및/또는 기입하는데 사용하기 위한 임의의 적합한 수의 데이터 슬롯 을 포함하는 순환 버퍼(cyclic buffer)들을 활용하여 구현된다. 도 2의 도시된 예에서, 커널 뱅크는 하나 이상의 커널을 포함하는 데이터 구조이다. 커널 뱅크의 커 널들은, 예를 들어, DSP상에서의 높은 처리량을 위해 컴파일된 루틴들이다. 본 명세서에 개시된 다른 예 들에서, 각각의 CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, 및/또는 DSP 중 임의의 것)는 각자의 커널 뱅크를 포함할 수 있다. 커널들은, 예를 들어, 가속기상에서 실행될 실행파일의 실행 가능 서브섹션들에 대응한다. 도 2의 예에서, 가속기는 VPU를 구현하고 크레디트 관리자, CnC 패브 릭, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 메모리, 및 구성 제어기를 포함 하지만, 가속기는 도 2에 도시된 것들에 추가적인 또는 대안적인 CBB들을 포함할 수 있다. 본 명세서에 개시된 추가적인 및/또는 대안적인 예에서, 커널 뱅크는 그래프 컴파일러에 의한 사용을 위해 추상화 될 하나 이상의 선택기(들)에 결합된다. 도 2의 예에서, 데이터 패브릭은 크레디트 관리자, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 메모리, 구성 제어기, 및 CnC 패브릭에 결합된다. 데이터 패브릭은, 크레디트 관리자, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 메모리, 및/또는 구성 제어기 중 하나 이상이 데이터를 교환하는 것을 허용하는 와이어들 및 적어도 하나의 로직 회로의 네트워크이다. 예를 들어, 데이터 패브릭은 생산자 CBB가 데이터의 타일들을 메모리 및/또는 컨볼루션 엔진, MMU, RNN 엔진, 및 DSP 중 하나 이상에 위치된 메모리들과 같은 메모리의 버퍼들에 기입하는 것 을 허용한다. 추가적으로, 데이터 패브릭은 소비하는 CBB가 메모리 및/또는 컨볼루션 엔진, MMU, RNN 엔진, 및 DSP 중 하나 이상에 위치된 메모리들과 같은 메모리의 버퍼들로부터 데이터 의 타일들을 판독하는 것을 허용한다. 데이터 패브릭은 데이터의 패키지에 제공되는 정보에 의존하여 메 모리에 그리고 메모리로부터 데이터를 전송한다. 예를 들어, 데이터는 패킷들의 방법에 의해 전송될 수 있고, 여기서 패킷은 헤더, 페이로드, 및 트레일러를 포함한다. 패킷의 헤더는 데이터의 목적지 어드레스, 데이터의 소스 어드레스, 데이터가 그에 의해 송신되고 있는 프로토콜 타입, 및 패킷 번호이다. 페이로드는 CBB가 생산하거나 소비하는 데이터이다. 데이터 패브릭은 의도된 목적지 어드레스를 분석함으로써 패킷의 헤더에 기 초하여 CBB들 사이의 데이터 교환을 용이하게 할 수 있다. 본 명세서에 개시된 일부 예들에서, 데이터 패브릭 및 CnC 패브릭은 단일의 및/또는 다중의 컴퓨팅 패브릭을 사용하여 구현될 수 있다. 도 3은 도 2의 하나 이상의 선택기(들) 중 예시적인 선택기를 도시하는 예시적인 블록도이다. 선택 기는 특정 작업부하 노드에 대해 도 2의 그래프 컴파일러에 의해 생성된 예시적인 선택기를 나타낸다. 이러한 예에서, 선택기는 특정 CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진 , 및/또는 DSP 중 임의의 것) 및/또는 도 2의 커널 뱅크에서의 커널과 통신하도록 생성될 수 있 다. 선택기는 도 2의 작업부하에서의 개별 작업부하 노드에 대해 구현될 수 있다. 또한, 개별 선택 기들은 작업부하에서의 각각의 개별 작업부하 노드에 대해 구현될 수 있다. 도 3에 도시된 선택기는 예시적인 CBB 분석기, 예시적인 커널 분석기, 및 예시적인 컴파일러 인터페이스를 포함한다. 동작 시에, CBB 분석기, 커널 분석기, 및/또는 컴파일러 인터페이스 중 임의의 것은 예시적 통 신 버스를 통해 통신할 수 있다. 도 3에서, 통신 버스는 임의의 적절한 통신 방법 및/또는 장치(예 를 들어, 블루투스® 통신, LAN 통신, WLAN 통신 등)를 이용하여 구현될 수 있다. 본 명세서에 개시된 일부 예 들에서, 선택기는 하나 이상의 선택기(들) 중 예시적인 선택기를 도시하고 도 2의 그래프 컴파일러 에 포함될 수 있다. 도 3에 도시된 예에서, CBB 분석기는 계산 요소 분석을 위한 수단, 또는 계산 요소 분석 수단이다. 도 3 의 예에서, 커널 분석기는 커널 분석을 위한 수단, 또는 커널 분석 수단이다. 도 3의 예에서, 컴파일러 인터페이스는 컴파일러 통신을 위한 수단, 또는 컴파일러 통신 수단이다. 도 3에 도시된 예에서, CBB 분석기는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주 문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스 (들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대 안적으로 사용될 수 있다. 동작 시에, CBB 분석기는 작업부하 노드와 연관된 CBB(예를 들어, 컨볼루션 엔 진, MMU, RNN 엔진, 및/또는 DSP 중 임의의 것)의 입력 및 출력 조건들을 식별하도록 구 성된다. 도 3의 CBB 분석기는 표준 입력 요건들(예를 들어, 데이터 구조들, 입력들의 수 등)에 대응하고 또한 작업부하 노드를 실행하도록 식별된 CBB와 연관되는 입력 조건들의 타입들을 식별하도록 구성된다. 또한, CBB 분석기는 표준 결과(예를 들어, 출력들의 수, 결과의 타입 등)에 대응하고 또한 작업부하 노드를 실행 하도록 식별된 CBB와 연관되는 출력 조건들의 타입을 식별하도록 구성된다. 이러한 방식으로, 식별된 입력 및 출력 조건들은 CBB 분석기에 의해 식별되고 그래프 컴파일러에 의한 사용을 위해 표준 포맷으로 제공 된다. 본 명세서에 개시된 또 다른 예에서, CBB 분석기는 연관된 CBB와 통신하여 동작 요건들을 식별할 수 있다. 예를 들어, CBB가 예시적인 작업부하 노드를 실행하기 위해 특정 백분율의 메모리 할당을 요구하는 경우, 그러 한 요건은 CBB 분석기에 의해 결정되고 컴파일러 인터페이스를 통해 그래프 컴파일러에 전송될 수 있다. 본 명세서에 개시된 일부 예들에서, CBB 분석기는 연관된 CBB의 내부 지식 및/또는 현재 및/또는 사전 모 델링을 활용함으로써 연관된 CBB와 간접적으로 통신한다. 예시적인 내부 지식 및/또는 현재 및/또는 사전 모델 링은 CBB 동작 요건들의 지식을 포함할 수 있다. 더욱이, CBB 분석기는 연관된 작업부하 노드에 대해 노 드 분석을 수행하여 노드 타입을 식별할 수 있다. 이러한 예시적인 분석은 선택기에 위치된 노드 분석기 를 활용하여 수행될 수 있다. 또한, 이러한 예에서, 식별된 노드 타입은 그래프 컴파일러에 의해 통신, 제공, 및/또는 다른 방식으로 활용될 수 있다. 이러한 방식으로, 선택기는 대응하는 작업부하 노드를 매 핑하기 위한 타겟일 수 있는 대응하는 CBB 및/또는 CBB들에 관한 지식을 획득한다. 예를 들어, 곱셈을 수행하 기를 식별하는 작업부하 노드가 있을 수 있다. 이와 같으므로, 도 2의 그래프 컴파일러는 (예를 들어, 식 별된 노드 타입들을 분석한 것에 기초하여) 곱셈에 관한 지식을 갖는 선택기를 호출하고 및/또는 다른 방 식으로 그와 통신할 수 있고, 작업부하 노드의 관련 파라미터들을 선택기에 제공할 수 있다. 선택기(30 0)의 CBB 분석기는 매핑에서 사용하기 위해 작업부하 노드를 실행할 CBB를 식별할 것이다. 본 명세서에 개시된 일부 예들에서, CBB 분석기는 대응하는 작업부하 노드를 대응하는 CBB에 매핑할 수 있다. 도 3에서, 예시적인 커널 분석기는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그 러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스 (들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대 안적으로 사용될 수 있다. 동작 시에, 커널 분석기는 커널(예를 들어, 도 2의 커널 뱅크에 포함된 커널)의 입력 및 출력 조건들을 식별하도록 구성된다. 예를 들어, 커널 분석기는 표준 입력 요건들(예를 들어, 데이터 구조들, 입력들의 수 등)에 대응하고 또한 작업부하 노드를 실행하도록 식별된 커널과 연관되는 입력 조건들의 타입들을 식별하도록 구성된다. 또한, 커널 분석기는 표준 결과(예를 들어, 출력들의 수, 결과의 타입 등)에 대응하고 또한 작업부하 노드를 실행하도록 식별된 커널과 연관되는 출력 조건들의 타입들을 식별하도록 구성된다. 이러한 방식으로, 식별된 입력 및 출력 조건들은 그래프 컴파일러에 의한 사용을 위해 표준 포맷으로 제공된다. 본 명세서에 개시된 예들에서, 커널 분석기는 가속기에 포함되는 임 의의 커널(예를 들어, 가속기상으로 다운로드된 새로운 커널 등)의 입력 및/또는 출력 조건들의 타입들을 식별 할 수 있다. 본 명세서에 개시된 또 다른 예에서, 커널 분석기는 연관된 커널과 통신하여 동작 요건들을 식별할 수 있 다. 예를 들어, 커널이 예시적인 작업부하 노드를 실행하기 위해 특정 백분율의 메모리 할당을 요구하는 경우, 이러한 요건은 커널 분석기에 의해 결정되고 컴파일러 인터페이스를 통해 그래프 컴파일러에 전 송될 수 있다. 본 명세서에 개시된 일부 예들에서, 커널 분석기는 연관된 커널의 내부 지식 및/또는 현재 및/또는 사전 모델링을 활용함으로써 연관된 커널들과 간접적으로 통신한다. 예시적인 내부 지식 및/또는 현재 및/또는 사전 모델링은 커널 동작 요건들의 지식을 포함할 수 있다. 또한, 커널 분석기는 연관된 작업부하 노드에 대해 노드 분석을 수행하여 노드 타입을 식별할 수 있다. 이러한 예시적인 분석은 선택기에 위치된 노드 분석 기를 활용하여 수행될 수 있다. 또한, 이러한 예에서, 식별된 노드 타입은 그래프 컴파일러에 의해 통신, 제공, 및/또는 다른 방식으로 활용될 수 있다. 예를 들어, 곱셈을 수행하기를 식별하는 작업부하 노드가 있을 수 있다. 이와 같으므로, 도 2의 그래프 컴파일러는 (예를 들어, 식별된 노드 타입들에 기초하여) 곱셈에 관한 지식을 갖는 선택기를 호출하고 및/또는 다른 방식으로 그와 통신할 수 있고, 작업부하 노드의 관련 파라미터들을 선택기에 제공할 수 있다. 선택기의 커널 분석기는 매핑에서 사용하기 위해 작업 부하 노드를 실행할 커널을 식별할 것이다. 본 명세서에 개시된 일부 예들에서, 커널 분석기는 대응하는 작업부하 노드를 대응하는 커널에 매핑할 수 있다. 본 명세서에 개시된 예들에서, CBB 분석기 및/또는 커널 분석기 중 임의의 것은 식별된 제약조건들 및/또는 요건들을 컴파일러 인터페이스를 통해 그래프 컴파일러에 통신할 수 있다. 도 3에 도시된 예에서, 컴파일러 인터페이스는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구 현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세 서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대안적으로 사용될 수 있다. 본 명세서에 개시된 일부 예들에서, 컴파일러 인터페이스는 하드웨어 회로상에서 실행가능한 소프트웨어 애플리케이션 프로그래밍 인터페이스(API)를 이용하여 구현될 수 있다. 이 러한 예시적인 컴파일러 인터페이스는 선택기와 도 2의 그래프 컴파일러 사이의 통신을 가능하 게 한다. 또한, 컴파일러 인터페이스는 이더넷 인터페이스, USB(universal serial bus), 블루투스® 인터 페이스, NFC(near field communication) 인터페이스, 및/또는 PCI 익스프레스 인터페이스와 같은 임의의 타입의 인터페이스 표준에 의해 구현될 수 있다. 컴파일러 인터페이스는 CBB 분석기 및/또는 커널 분석기 로부터 입력 및 출력 조건들을 획득하고 입력 및 출력 조건들을 그래프 컴파일러에 전송하도록 구성 된다. 추가적으로 또는 대안적으로, 컴파일러 인터페이스는 CBB 분석기 및/또는 커널 분석기에 의해 결정된 요건들을 그래프 컴파일러에 전송하도록 구성될 수 있다. 도 4는 도 2의 그래프 컴파일러를 도시하는 예시적인 블록도이다. 그래프 컴파일러는, 도 4에 도시 된 바와 같이, 예시적인 그래프 인터페이스, 예시적인 선택기 인터페이스, 예시적인 작업부하 분석기 , 예시적인 실행가능 생성기, 예시적인 데이터 저장소, 및 도 2의 플러그인을 포함한다. 동작 시에, 그래프 인터페이스, 선택기 인터페이스, 작업부하 분석기, 실행가능 생성기, 데이터 저장소, 및/또는 플러그인 중 임의의 것은 예시적인 통신 버스를 통해 통신할 수 있다. 도 4에서, 통신 버스는 임의의 적절한 통신 방법 및/또는 장치(예를 들어, 블루투스® 통신, LAN 통신, WLAN 통신 등)를 이용하여 구현될 수 있다.도 4에 도시된 예에서, 그래프 인터페이스는 그래프 통신을 위한 수단, 또는 그래프 통신 수단이다. 도 4 의 예에서, 선택기 인터페이스는 선택기 통신을 위한 수단, 또는 선택기 통신 수단이다. 도 4에 도시된 예에서, 작업부하 분석기는 작업부하 분석을 위한 수단, 또는 작업부하 분석 수단이다. 도 4의 예에서, 플러그인은 변환을 위한 수단, 또는 변환 수단이다. 도 4의 예에서, 실행가능 생성기는 실행가능 생 성을 위한 수단, 또는 실행가능 생성 수단이다. 도 4의 예에서, 데이터 저장소는 데이터를 저장하기 위한 수단, 또는 데이터 저장 수단이다. 도 4에 도시된 예에서, 그래프 인터페이스는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현 된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서 (들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디 바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대안적으로 사용될 수 있다. 또한, 그래프 인터페이스는 이더넷 인터페이스, USB(universal serial bus), 블루투스® 인터페이스, NFC(near field communication) 인터페이스, 및/또는 PCI 익스프레스 인터페이 스와 같은 임의의 타입의 인터페이스 표준에 의해 구현될 수 있다. 그래프 인터페이스는 작업부하(예를 들어, 도 2의 작업부하)가 수신되는지를 결정하도록 구성된다. 본 명세서에 개시된 예들에서, 작업부하 가 이용가능한 경우, 그래프 인터페이스는 데이터저장소에 작업부하를 저장할 수 있다. 도 4에서, 예시적인 선택기 인터페이스는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된 다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가 적으로 또는 대안적으로 사용될 수 있다. 또한, 선택기 인터페이스는 이더넷 인터페이스, USB(universal serial bus), 블루투스® 인터페이스, NFC(near field communication) 인터페이스, 및/또는 PCI 익스프레스 인 터페이스와 같은 임의의 타입의 인터페이스 표준에 의해 구현될 수 있다. 선택기 인터페이스는, 작업부하 를 획득한 것에 응답하여, 작업부하에서의 각각의 작업부하 노드에 대한 하나 이상의 선택기 (들)를 생성 및/또는 다른 방식으로 제공하도록 구성된다. 또한, 선택기 인터페이스는 하나 이상의 선택기(들)로부터 입력 및/또는 출력 조건들을 획득 및/또는 다른 방식으로 수신하도록 구성된다. 예를 들어, 선택기 인터페이스는 가속기(208에서의 각각의 CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, 및/또는 DSP 중 임의의 것)의 입력 및 출력 조건들을 획득하도록 구성된다. 이러한 동작에서, 선택기 인터페이스는 CBB들의 일반 리스트를 획득하는데, 여기서 리스트는 CBB들을 동작시키기 위한 입력 및 출력 조건들을 지정한다. 또 다른 예에서, 선택기 인터페이스는 가속기에서의 각각의 커널(예를 들어, 커널 뱅크에서의 임의의 커벌 및/또는 임의의 적절한 커널)의 입력 및 출력 조건들을 획득하도록 구 성된다. 이러한 동작에서, 선택기 인터페이스는 커널들의 일반 리스트를 획득하는데, 여기서 리스트는 커 널들을 동작시키기 위한 입력 및 출력 조건들을 지정한다. 동작 시에, 선택기 인터페이스는 하나 이상의 선택기(들)에 의해 식별된 입력 및/또는 출력 조건들을 데이터 저장소에 저장한다. 도 4에 도시된 예에서, 작업부하 분석기는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된 다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스(들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가 적으로 또는 대안적으로 사용될 수 있다. 작업부하 분석기는 작업부하(예를 들어, 도 6의 작업부하(20 6))에 포함된 작업부하 노드들을 분석한다. 작업부하 분석기는 작업부하 노드들을 파싱하여 작업부하 노 드들을 실행하기 위해 사용되는 입력 및 출력 조건들을 식별한다. 작업부하 분석기는 파싱된 작업부하 노 드들을, 하나 이상의 선택기(들)에 의한 사용을 위해 선택기 인터페이스에, 및/또는 플러그인에 의한 사용을 위해 데이터 저장소에 전송할 수 있다. 도 4의 예에서, 플러그인은 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주문형 집 적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스 (들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대 안적으로 사용될 수 있다. 동작에 있어서, 플러그인은 선택기 인터페이스, 작업부하 분석기, 및 데이터 저장소에 저장된 데이터와 통신하여 작업부하 분석기에 의해 식별된 작업부하 노드를 CBB (예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, 및/또는 DSP 중 임의의 것)에 매핑하도록 구성된다. 예를 들어, 플러그인은 식별된 입력 및/또는 출력 조건들에 기초하여 작업부하 노드를 가속기 에서의 CBB 및/또는 커널에 매핑 및/또는 다른 방식으로 할당한다. 또한, 이러한 예에서, 플러그인 은 작업부하 노드를 구현하기 위해 입력 및/또는 출력 조건들을 획득하고, 마찬가지로 동일하거나 실질적으로 유사한 입력 및/또는 출력 조건들을 포함하는 디바이스(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진 , DSP, 및/또는 커널 뱅크에 위치된 커널들 중 임의의 것)에 기초하여 실행될 그러한 작업부하 노드를 할당한다. 이러한 방식으로, 플러그인은 작업부하 노드가 할당되고 있는 특정 디바이스(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, DSP, 및/또는 커널 뱅크에 위치된 커널들 중 임의의 것)에 대한 직접적인 지식을 갖지 않는다. 본 명세서에 개시된 일부 예들에서, 플러그인은 어느 CBB 및/또는 커널이 특정 작업부하 노드를 할당받을 수 있는지를 학습하고 및/또는 예측하기 위해 적합한 AI 기술을 이용하여 구현될 수 있다. 예를 들어, 플러그 인이 작업부하 노드를 이전에 할당하여 데이터를 특정 CBB에 백업하라고 표시하였다면, 그러한 작업부하 노드가 미래에 할당될 것이라면, 플러그인은 데이터 저장소에 저장된 데이터를 분석하는 것과 독립적 으로 이것을 특정 CBB에 할당할 수 있다. 도 4에서, 예시적인 실행가능 생성기는 예를 들어, 하드웨어 프로세서와 같은 로직 회로에 의해 구현된다. 그러나, 예를 들어, 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 주 문형 집적 회로(들)(ASIC(들)), 프로그래머블 로직 디바이스(들)(PLD(들)), 필드 프로그래머블 로직 디바이스 (들)(FPLD(들)), 디지털 신호 프로세서(들)(DSP(들)) 등과 같은 임의의 다른 타입의 회로가 추가적으로 또는 대 안적으로 사용될 수 있다. 플러그인이 유사한 입력 및/또는 출력 조건들을 포함하는 디바이스에 작업부하 노드들을 할당한 후에, 실행가능 생성기는 가속기에 의해 실행될 도 2의 실행가능 파일을 생성 하도록 구성된다. 실행가능 생성기는 실행가능 파일을 구성 제어기에 추가로 전송한다. 또한, 실행가능 생성기는 가속기에 의해 실행될 하나 이상의 실행파일을 생성할 수 있다. 도 4에 도시된 예에서, 데이터 저장소는 예를 들어, 플래시 메모리, 자기 매체, 광학 매체 등과 같은 데이 터를 저장하기 위한 임의의 디바이스에 의해 구현될 수 있다. 게다가, 예시적 데이터 저장소에 저장된 데 이터는, 예를 들어, 이진 데이터, 콤마 한정된 데이터, 탭 한정된 데이터, SQL(structured query language) 구 조 등과 같은 임의의 데이터 포맷의 것일 수 있다. 도 4에서, 데이터 저장소는 선택기 인터페이스로 부터 획득된 입력 및/또는 출력 조건들, 그래프 인터페이스로부터 획득된 작업부하(예를 들어, 도 2의 작 업부하), 및/또는 작업부하 노드를 실행하기 위한 입력 및/또는 출력 조건들(예를 들어, 작업부하 분석기 에 의해 식별된 입력 및/또는 출력 조건들)을 저장하도록 구성된다. 데이터 저장소는 그래프 인터페 이스, 선택기 인터페이스, 작업부하 분석기, 플러그인, 및/또는 실행가능 생성기 중 임의의 것에 의해 그에 기입되고 및/또는 그로부터 판독될 수 있다. 도 5는 예시적인 제1 CBB 및 예시적인 제2 CBB를 사용하여 실행되는 작업부하를 나타내는 예시적인 파이프라인의 그래픽 도시이다. 제1 CBB 및/또는 제2 CBB는 도 1의 예시적인 CBB(예를 들어, 컨볼루션 엔진, MMU, RNN 엔진, 및/또는 DSP 중 임의의 것)일 수 있다. 대안적으로, 제1 CBB 및/또는 제2 CBB는 임의의 적절한 커널(예를 들어, 커널 뱅크에 위치된 커널)을 이용하여 구현될 수 있다. 도 5의 예에서, 제1 CBB는 생산자이고 제2 CBB는 소비자이다. 예시적인 파이프라 인은 예시적인 제1 작업부하 노드, 및 예시적인 제2 작업부하 노드를 포함한다. 도 5의 예에서, 제1 CBB는 제1 작업부하 노드를 실행하도록 구성된다. 마찬가지로, 제2 CBB는 제2 작 업부하 노드를 실행하도록 구성된다. 동작 시에, 예시적인 크레디트 관리자는 제1 작업부하 노드 를 실행하기 위해서 제1 CBB에 제1 크레디트 값을 제공하도록 구성된다. 예를 들어, 제1 크레디트 값은 5개의 크레디트이고(예를 들어, 버퍼에서 초기의 데이터 슬롯 가용성), 이와 같으므로 제1 CBB 에게 제1 작업부하 노드의 실행을 시작하기 위한 표시를 제공한다. 도 5에서, 버퍼는 순환 버퍼이다. 도 5에 도시된 예에서, 제1 작업부하 노드는 버퍼의 2개의 슬롯(예를 들어, 데이터 슬롯들의 서브세 트)에 기입함으로써 실행된다. 이와 같으므로, 제1 CBB는 버퍼의 처음 2개의 이용가능한 슬롯에 기 입한다. 이에 응답하여, 제1 CBB는 크레디트 관리자에게 2개의 크레디트를 전송한다. 크레디트 관 리자는, 일단 이용가능하다면, 2개의 크레디트를 제2 CBB에 전송한다. 제2 CBB에 제공된 2개의 크레디트는 제2 CBB에게 제2 작업부하 노드의 실행을 시작하는 것을 표시하도록 동작한다. 도 5에서, 제2 작업부하 노드는 버퍼에서의 다음 2개의 슬롯을 FIFO(first-in first-out) 기반으로 판독함으로써 실행된다. 예시적인 그래프 컴파일러, 예시적인 하나 이상의 선택기(들), 예시적인 선택기 및/또는 도 2의 가속기를 구현하는 예시적인 방식이 도 3 및/또는 도 4에 예시되어 있지만, 도 2, 도 3, 및/또는 도 4에 도시된 요소들, 프로세스들 및/또는 디바이스들 중 하나 이상은 조합, 분할, 재배열, 생략, 제거 및/또는 임의 의 다른 방식으로 구현될 수 있다. 또한, 예시적인 CBB 분석기, 예시적인 커널 분석기, 예시적인 컴 파일러 인터페이스, 및/또는 보다 일반적으로, 도 2 및/또는 도 3의 예시적인 선택기 및/또는 예시적 인 하나 이상의 선택기(들), 예시적인 그래프 인터페이스, 예시적인 선택기 인터페이스, 예시적 인 작업부하 분석기, 예시적인 실행가능 생성기, 예시적인 데이터 저장소, 예시적인 플러그인 , 및/또는 보다 일반적으로, 도 2 및/또는 도 4의 예시적인 그래프 컴파일러, 및/또는 예시적인 크레 디트 관리자, 예시적인 CnC 패브릭, 예시적인 컨볼루션 엔진, 예시적인 MMU, 예시적인 RNN 엔진, 예시적인 DSP, 예시적인 메모리, 예시적인 구성 제어기, 예시적인 커널 뱅크, 및/또는 보다 일반적으로, 도 2의 예시적인 가속기는 하드웨어, 소프트웨어, 펌웨어 및/또는 하드웨어, 소 프트웨어, 및/또는 펌웨어의 임의의 조합에 의해 구현될 수 있다. 따라서, 예를 들어, 예시적인 CBB 분석기 , 예시적인 커널 분석기, 예시적인 컴파일러 인터페이스, 및/또는 보다 일반적으로 도 2 및/또 는 도 3의 예시적인 선택기300) 및/또는 예시적인 하나 이상의 선택기들), 예시적인 그래프 인터페이스 , 예시적인 선택기 인터페이스, 예시적인 작업부하 분석기, 예시적인 실행가능 생성기, 예 시적인 데이터 저장소, 예시적인 플러그인, 및/또는 보다 일반적으로 도 2 및/또는 도 4의 예시적인 그래프 컴파일러, 및/또는 예시적인 크레디트 관리자, 예시적인 CnC 패브릭, 예시적인 컨볼루션 엔진, 예시적인 MMU, 예시적인 RNN 엔진, 예시적인 DSP, 예시적인 메모리, 예시적인 구성 제어기, 예시적인 커널 뱅크, 및/또는 보다 일반적으로, 도 2의 예시적인 가속기는 하나 이상의 아날로그 또는 디지털 회로(들), 로직 회로들, 프로그래머블 프로세서(들), 프로그래머블 제어기(들), 그래픽 처리 유닛(들)(GPU(들)), 디지털 신호 프로세서(들)(DSP(들)), 주문형 집적 회로(들)(ASIC(들)), 프로그 래머블 로직 디바이스(들)(PLD(들)), 및/또는 필드 프로그래머블 로직 디바이스(들)(FPLD(들))에 의해 구현될 수 있다. 순수 소프트웨어 및/또는 펌웨어 구현을 커버하기 위한 본 특허의 장치 또는 시스템 청구범위 중 임 의의 것을 읽어볼 때, 예시적인 CBB 분석기, 예시적인 커널 분석기, 예시적인 컴파일러 인터페이스 , 및/또는 보다 일반적으로 도 2 및/또는 도 3의 예시적인 선택기300) 및/또는 예시적인 하나 이상의 선택 기들), 예시적인 그래프 인터페이스, 예시적인 선택기 인터페이스, 예시적인 작업부하 분석기 , 예시적인 실행가능 생성기, 예시적인 데이터 저장소, 예시적인 플러그인, 및/또는 보다 일반적으로 도 2 및/또는 도 4의 예시적인 그래프 컴파일러, 및/또는 예시적인 크레디트 관리자, 예 시적인 CnC 패브릭, 예시적인 컨볼루션 엔진, 예시적인 MMU, 예시적인 RNN 엔진, 예시적인 DSP, 예시적인 메모리, 예시적인 구성 제어기, 예시적인 커널 뱅크, 및/또는 보다 일반적 으로, 도 2의 예시적인 가속기 중 적어도 하나는, 소프트웨어 및/또는 펌웨어를 포함하는, 메모리, DVD(digital versatile disk), CD(compact disk), 블루레이 디스크 등과 같은 비일시적 컴퓨터 판독가능 저장 디바이스 또는 저장 디스크를 포함하도록 이로써 명시적으로 정의된다. 또한, 예시적인 그래프 컴파일러, 예시적인 하나 이상의 선택기(들), 예시적인 선택기, 및/또는 도 2, 도 3 및/또는 도 4의 가속기 는 도 2, 도 3, 및/또는 도 4에 도시된 것들에 추가하여 또는 그 대신에 하나 이상의 요소, 프로세스 및/ 또는 디바이스를 포함할 수 있고, 및/또는 도시된 요소들, 프로세스들 및 디바이스들 중 임의의 것 또는 모든 것의 하나보다 많은 것을 포함할 수 있다. 본 명세서에서 사용되는 바와 같이, 그 변형들을 포함하는 \"통신하 는\"이라는 문구는, 직접 통신 및/또는 하나 이상의 중간 컴포넌트들을 통한 간접 통신을 포함하고, 직접적인 물 리적(예를 들어, 유선) 통신 및/또는 일정한 통신을 요구하지 않고, 그보다는 주기적 간격들, 스케줄링된 간격 들, 비주기적 간격들, 및/또는 1회성 이벤트에서의 선택적 통신을 추가적으로 포함한다. 예시적인 그래프 컴파일러, 예시적인 하나 이상의 선택기(들), 예시적인 선택기, 및/또는 가속 기를 구현하기 위한 예시적인 하드웨어 로직, 머신 판독가능 명령어들, 하드웨어 구현 상태 머신들, 및/또 는 이들의 임의의 조합을 나타내는 흐름도들이 도 6 및/또는 7에 도시되어 있다. 머신 판독가능 명령어들은 도 8과 관련하여 이하에서 논의되는 예시적인 프로세서 플랫폼에 도시된 프로세서 및/또는 가속기 와 같은 컴퓨터 프로세서에 의한 실행을 위한 실행가능 프로그램의 하나 이상의 실행가능 프로그램 또는 부분 (들)일 수 있다. 프로그램은 CD-ROM, 플로피 디스크, 하드 드라이브, DVD, 블루레이 디스크, 또는 프로세서 및/또는 가속기와 연관된 메모리와 같은 비일시적 컴퓨터 판독가능 저장 매체상에 저장된 소프트웨 어로 구현될 수 있지만, 전체 프로그램 및/또는 그의 부분들은 대안적으로 프로세서, 가속기 이외의 디바이스에 의해 실행될 수도 있고, 및/또는 펌웨어 또는 전용 하드웨어로 구현될 수도 있다. 또한, 예시적인프로그램이 도 4에 도시된 흐름도를 참조하여 설명되지만, 예시적인 그래프 컴파일러, 예시적인 하나 이상 의 선택기(들), 예시적인 선택기, 및/또는 가속기를 구현하는 많은 다른 방법들이 대안적으로 사용될 수 있다. 예를 들어, 블록들의 실행 순서는 변경될 수 있고, 및/또는 설명된 블록들 중 일부는 변경, 제거 또는 조합될 수 있다. 추가적으로 또는 대안적으로, 블록들 중 임의의 것 또는 모두는 소프트웨어 또는 펌웨어를 실행하지 않고 대응하는 동작을 수행하도록 구조화된 하나 이상의 하드웨어 회로(예를 들어, 이산 및/ 또는 통합 아날로그 및/또는 디지털 회로, FPGA, ASIC, 비교기, 연산 증폭기(op-amp), 로직 회로 등)에 의해 구 현될 수 있다. 본 명세서에 설명된 머신 판독가능 명령어들은 압축 포맷, 암호화 포맷, 단편화된 포맷, 컴파일된 포맷, 실행가 능 포맷, 패키징된 포맷 등 중 하나 이상으로 저장될 수 있다. 본 명세서에 설명된 머신 판독가능 명령어들은 머신 실행가능 명령어들을 생성, 제조, 및/또는 생산하기 위해 활용될 수 있는 데이터(예를 들어, 명령어들의 부분들, 코드, 코드의 표현들 등)로서 저장될 수 있다. 예를 들어, 머신 판독가능 명령어들은 단편화되어 하나 이상의 저장 디바이스 및/또는 컴퓨팅 디바이스들(예를 들어, 서버들)상에 저장될 수 있다. 머신 판독가능 명 령어들은, 이들을 컴퓨팅 디바이스 및/또는 다른 머신에 의해 직접 판독가능하고, 해석가능하고, 및/또는 실행 가능하게 만들기 위해, 설치, 수정, 적응, 업데이트, 조합, 보완, 구성, 복호화, 압축해제, 패킹해제, 분배, 재 할당, 컴필레이션 등 중 하나 이상을 요구할 수 있다. 예를 들어, 머신 판독가능 명령어들은 개별적으로 압축 되고, 암호화되고, 별도의 컴퓨팅 디바이스들상에 저장되는 다중 부분으로 저장될 수 있고, 여기서, 부분들은 복호화되고, 압축해제되고, 및 조합될 때, 본 명세서에 기술되는 것과 같은 프로그램을 구현하는 실행가능 명령 어들의 세트를 형성한다. 또 다른 예에서, 머신 판독가능 명령어들은 이들이 컴퓨터에 의해 판독될 수 있는 상태로 저장될 수 있지만, 특 정 컴퓨팅 디바이스 또는 다른 디바이스상에서 명령어들을 실행하기 위해서 라이브러리(예를 들어, 동적 링크 라이브러리(DLL)), 소프트웨어 개발 키트(SDK), 애플리케이션 프로그래밍 인터페이스(API) 등의 추가를 요구할 수 있다. 또 다른 예에서, 머신 판독가능 명령어들은, 머신 판독가능 명령어들 및/또는 대응하는 프로그램 (들)이 전체적으로 또는 부분적으로 실행될 수 있기 전에 구성(예를 들어, 설정들이 저장됨, 데이터 입력됨, 네 트워크 어드레스들이 기록됨 등)될 필요가 있을 수 있다. 따라서, 개시된 머신 판독가능 명령어들 및/또는 대 응하는 프로그램(들)은, 저장되거나 또는 그렇지 않으면 정지해 있거나 수송 중인 경우 머신 판독가능 명령어들 및/또는 프로그램(들)의 특정 포맷 또는 상태에 관계없이 이러한 머신 판독가능 명령어들 및/또는 프로그램 (들)을 포괄하도록 의도된다. 본 명세서에 설명된 머신 판독가능 명령어들은 임의의 과거, 현재 또는 미래 명령어 언어, 스크립팅 언어, 프로 그래밍 언어 등으로 표현될 수 있다. 예를 들어, 머신 판독가능 명령어들은 다음 언어들 중 임의의 것을 사용 하여 표현될 수 있다: C, C++, Java, C#, Perl, Python, JavaScript, HTML(HyperText Markup Language), SQL(Structured Query Language), Swift 등. 위에서 언급된 바와 같이, 도 6 및/또는 도 7의 예시적인 프로세스들은, 하드 디스크 드라이브, 플래시 메모리, 판독 전용 메모리, 콤팩트 디스크, 디지털 다목적 디스크(DVD), 캐시, 랜덤 액세스 메모리, 및/또는 정보가 임 의의 지속기간 동안(예를 들어, 연장된 시간 기간들 동안, 영구적으로, 짧은 인스턴스 동안, 일시적으로 버퍼링 하기 위해, 및/또는 정보의 캐싱을 위해) 저장되는 임의의 다른 저장 디바이스 또는 저장 디스크와 같은 비일시 적 컴퓨터 및/또는 머신 판독가능 매체상에 저장되는 실행가능 명령어들(예를 들어, 컴퓨터 및/또는 머신 판독 가능 명령어들)을 사용하여 구현될 수 있다. 여기서 사용되는 바로는, 비일시적 컴퓨터 판독가능 매체라는 용 어는 임의 타입의 컴퓨터 판독가능 저장 디바이스 및/또는 저장 디스크를 포함하고 전파 신호들을 배제하고 전 송 매체를 배제하도록 명시적으로 정의된다. \"포함하는(including) \"및\" 포함하는(comprising)\"(및 그의 모든 형태 및 시제)은 개방형 용어(open ended term)인 것으로 본 명세서에서 사용된다. 따라서, 청구항이 전제부로서 또는 임의 종류의 청구항 기재 내에서 임의의 형태의 \"포함하다(include) \"또는 \"포함하다(comprise)\"(예를 들어, 포함하는(comprises), 포함하는 (includes), 포함하는(comprising), 포함하는(including), 갖는(having) 등)을 채택할 때는 언제든지, 추가적 인 요소들, 용어들 등이 대응하는 청구항 또는 기재의 범위 밖으로 벗어나지 않고서 존재할 수 있다는 것을 이 해해야 한다. 본 명세서에서 사용되는 바와 같이, \"적어도\"라는 문구가, 예를 들어, 청구항의 전제부에서 전이 용어로서 사용될 때, 그것은 용어 \"포함하는(comprising) \"및 \"포함하는(including)\"이 개방형인 것과 동일한 방식으로 개방형이다. 용어 \"및/또는\"은, 예를 들어, A, B, 및/또는 C와 같은 형태로 사용될 때, A 단독, B 단독, C 단독, B와 함께하는 A, C와 함께하는 A, C와 함께 하는 B, 및 B와 그리고 C와 함께하는 A와 같이, A, B, C의 임의의 조합 또는 부분집합을 지칭한다. 구조들, 컴포넌트들, 아이템들, 객체들, 및/또는 사물들을 설명하는 맥락에서 본 명세서에서 사용되는 바와 같이, \"A 및 B 중 적어도 하나\"라는 문구는 적어도 하나의 A, 적어도 하나의 B 및 적어도 하나의 A 및 적어도 하나의 B 중 임의의 것을 포함하는 구현들을 지칭하기 위해 의도된 것이다. 유사하게, 구조들, 컴포넌트들, 아이템들, 객체들, 및/또는 사물들을 설명하는 맥락에서 본 명세서에서 사용되는 바와 같이, \" A 또는 B 중 적어도 하나\"라는 문구는 적어도 하나의 A, 적어도 하나의 B, 및 적어도 하나의 A 및 적어도 하나의 B 중 임의의 것을 포함하는 구현들을 지칭하기 위해 의도된다. 프로세스들, 명령어들, 액션들, 활동들 및/또는 단계들의 수행 또는 실행을 설명하는 맥락에서 본 명세서에서 사용되는 바와 같이, \"A 및 B 중 적어도 하나\"라는 문구는 적어도 하나의 A, 적어도 하나의 B, 및 적어도 하나의 A 및 적어도 하나의 B 중 임의의 것을 포함하는 구현들을 지칭 하기 위해 의도된 것이다. 유사하게, 프로세스들, 명령어들, 액션들, 활동들 및/또는 단계들의 수행 또는 실행 을 설명하는 맥락에서 본 명세서에서 사용되는 바와 같이, \"A 또는 B 중 적어도 하나\"라는 문구는 적어도 하나의 A, 적어도 하나의 B, 및 적어도 하나의 A 및 적어도 하나의 B 중 임의의 것을 포함하는 구현들 을 지칭하기 위해 의도된 것이다. 본 명세서에서 사용되는 바와 같이, 단수 참조들(예를 들어, \"a\", \" an\", \" first\", \" second\" 등)은 복수를 배제하지 않는다. 본 명세서에서 사용되는 바와 같이, 한(\"a\" 또는 \"an\") 엔티티라는 용어는 해당 엔티티 중 하나 이상을 지칭한다. 용어 한(\"a\"(또는 \"an\")), \"하나 이상\", 및 \"적어도 하나\"는 본 명세서에서 상호교환가 능하게 사용될 수 있다. 더욱이, 개별적으로 열거되기는 하지만, 복수의 수단, 요소 또는 방법 액션은 예를 들 어 단일 유닛 또는 프로세서에 의해 구현될 수 있다. 덧붙여, 개별적인 특징들이 상이한 예들 또는 청구항들에 포함될 수 있지만, 이들은 가능하게는 조합될 수 있고, 상이한 예들 또는 청구항들에의 포함이 특징들의 조합이 실현가능하지 않고 및/또는 유리하지 않은 것임을 암시하지 않는다. 도 6은 도 2의 실행가능 파일을 생성하기 위해 도 2, 도 3 및/또는 도 4의 그래프 컴파일러, 선택기 , 및/또는 하나 이상의 선택기(들)를 구현하기 위해 실행될 수 있는 프로세스를 나타내는 흐름 도이다. 도 6의 도시된 예에서, 그래프 인터페이스(도 4)는 작업부하가 수신되는지 및/또는 다른 방 식으로 이용가능한지를 결정한다. (블록 602). 그래프 인터페이스가 작업부하가 수신되지 않고 및/ 또는 다른 방식으로 이용가능하지 않다고 결정한 것에 응답하여(예를 들어, 블록의 제어가 아니오의 결과 를 반환함), 프로세스는 계속 대기한다. 대안적으로, 그래프 인터페이스가 작업부하가 수신되 고 및/또는 다른 방식으로 이용가능하다고 결정하는 경우(예를 들어, 블록의 제어가 예라는 결과를 반환함), 작업부하 분석기(도 4)는 작업부하를 파싱하여 작업부하 노드들을 식별한다. (블록 604). 이에 응답하여, 선택기 인터페이스(도 4)는 각각의 작업부하 노드에 대한 선택기(예를 들어, 도 2의 하나 이상의 선택기(들))를 생성한다. (블록 606). CBB 분석기(도 3)는 또한 연관된 CBB의 입력 및 출력 조건들을 획득하고 및/또는 그렇지 않으면 식별한다. (블록 608). 이에 응답하여, 선택기 인터페이스는 생성된 모든 선택기(들)가 각자의 입력 및/또는 출력 조건들을 제공했는지를 결정하고, 이와 같으므로 분석할 추가적인 CBB들이 있는지를 결정한다. (블록 610). 선택기 인터페이스가 분석할 추가적인 CBB들이 있다 고 결정하면(예를 들어, 블록의 제어가 예의 결과를 반환함), 제어는 블록으로 복귀한다. 대안적으 로, 선택기 인터페이스가 분석할 추가적인 CBB들이 없다고 결정하면(예를 들어, 블록의 제어가 아니 오의 결과를 반환함), 커널 분석기(도 3)는 연관된 커널의 입력 및 출력 조건들을 추가로 획득하고 및/또 는 그렇지 않으면 식별한다. (블록 612). 이에 응답하여, 선택기 인터페이스는 생성된 모든 선택기(들) 가 각자의 입력 및/또는 출력 조건들을 제공했는지를 결정하고, 이와 같으므로 분석할 추가 커널들이 있는지를 결정한다. (블록 614). 선택기 인터페이스가 분석할 추가적인 커널들이 있다고 결정하면(예를 들어, 블 록의 제어가 예의 결과를 반환함), 제어는 블록으로 복귀한다. 대안적으로, 선택기 인터페이스(40 4)가 분석할 추가 커널들이 없다고 판정하면(예를 들어, 블록의 제어는 아니오의 결과를 반환함), 플러그 인(도 2 및/또는 도 4)은 선택기(들)(예를 들어, 도 2의 하나 이상의 선택기(들))에 의해 식별된 입 력 및 출력 조건들에 기초하여 작업부하 노드를 CBB 및/또는 커널에 매핑한다. (블록 616). 이후 실행가능 생성기(도 4)는 실행가능 파일을 생성한다. (블록 618). 실행가능 생성기는 실 행가능 파일을 구성 제어기에 추가로 전송한다. (블록 620). 본 명세서에 개시된 또 다른 예에서, 블록의 실행에 응답하여, 실행가능 생성기는 외부 및/또는 내부 배치 시스템(예를 들어, 도 1의 시스 템)에서의 추후 사용을 위해 데이터 저장소에 실행가능 파일을 저장할 수 있다. 도 6의 도시된 예에서, 그래프 컴파일러는 동작을 계속할지를 결정한다. (블록 622). 그래프 컴파일러가 동작을 계속하기로 결정하는 경우(예를 들어, 블록의 제어가 예의 결과를 반환함), 제어는 블록으로 복귀하고, 여기서 그래프 인터페이스는 작업부하가 수신되고 및/또는 그렇지 않으면 이용가능한지를 결정한 다. 예를 들어, 그래프 컴파일러는 추가적인 작업부하들이 이용가능하다면 및/또는 새로운 CBB들 및/또는 커널들이 가속기에 포함된다면 동작을 계속하기로 결정할 수 있다. 대안적으로, 그래프 컴파일러가 동작이 계속되지 않는 것으로 결정하면(예를 들어, 블록의 제어가 아 니오의 결과를 반환함), 도 6의 프로세스는 종료된다. 즉, 프로세스는 더 이상의 작업부하가 이용가 능하지 않은 경우에 정지할 수 있다. 도 7은 도 2의 실행가능 파일의 실행을 용이하게 하기 위해 도 2의 크레디트 관리자 및/또는 구성 제 어기를 구현하기 위해 실행될 수 있는 프로세스를 나타내는 흐름도이다. 도 7에서, 구성 제어기 (도 2)는 실행가능 파일이 수신되는지 및/또는 그렇지 않으면 그래프 컴파일러로부터 이용가능 한지를 결정한다. (블록 702). 구성 제어기가 실행가능 파일이 수신되지 않고 및/또는 그렇지 않으 면 이용가능하지 않은 것으로 결정하면(예를 들어, 블록의 제어가 아니오의 결과를 반환함), 프로세스 는 계속 대기한다. 대안적으로, 구성 제어기가 실행가능 파일이 수신되고 및/또는 그렇지 않으 면 이용가능한 것으로 결정하면(예를 들어, 블록의 제어가 예의 결과를 반환함), 구성 제어기는 실행 가능 파일을 파싱하여, 생산과 소비 작업부하 노드들을 실행할 각자의 CBB들을 식별하기 위해서 생산 작업 부하 노드 및 소비 작업부하 노드를 식별한다. (블록 704). 이에 응답하여, 구성 제어기는 생산 작업부 하 노드를 제1 선택된 CBB(예를 들어, 컨볼루션 엔진)에 전송한다. (블록 706). 마찬가지로, 구성 제어 기는 소비 작업부하 노드를 제2 선택된 CBB(예를 들어, DSP)에 전송한다. (블록 708). 그에 응답하여 또는 그에 병렬로, 크레디트 관리자는 생산 작업부하 노드의 실행을 개시하기 위해 크레디 트들을 제1 선택된 CBB(예를 들어, 컨볼루션 엔진)에 분배한다. (블록 710). 본 명세서에 개시되는 일부 예들에서, 블록들(706, 708, 및/또는 710)의 동작은 모든 생산 작업부하 노드들 및/또는 소비 작업부하 노드들 에 대해 동작할 수 있다. 예를 들어, 크레디트 관리자는 모든 생산 작업부하 노드들에 대응하는 크레디트 들을 모든 대응하는 생산 CBB들에 분배할 수 있다. 이러한 예에서, 런타임 동안의 동기화는 대응하는 CBB들 및 /또는 크레디트 관리자 간의 통신에 기초하여 달성된다. 크레디트들이 크레디트 관리자에 및 그로부 터 송신되기 때문에, 크레디트 관리자는 크레디트들이 제1 선택된 CBB(예를 들어, 컨볼루션 엔진)로 부터 수신되는지를 결정한다. (블록 712). 크레디트 관리자가 크레디트들이 획득되지 않았거나 제1 선택 된 CBB(예를 들어, 컨볼루션 엔진)로부터 송신되지 않았다고 결정하면(예를 들어, 블록의 제어가 아 니오의 결과를 반환함), 프로세스는 계속 대기한다. 대안적으로, 크레디트 관리자가 크레디트들이 획득되었고 및/또는 제1 선택된 CBB(예를 들어, 컨볼루션 엔진)로부터 송신되었다고 결정하면(예를 들어, 블록의 제어는 예의 결과를 반환함), 크레디트 관리자는 소비 작업부하 노드의 실행을 개시하기 위해 제2 선택된 CBB(예를 들어, DSP)에 크레디트들을 분배한다. (블록 714). 이에 응답하여, 크레디트 관리자는 크레디트들이 제2 선택된 CBB(예를 들어, DSP)로부터 수신되는지 를 결정한다. (블록 716). 크레디트 관리자가 크레디트들이 획득되지 않았거나 제2 선택된 CBB(예를 들 어, DSP)로부터 송신되지 않았다고 결정하면(예를 들어, 블록의 제어가 아니오의 결과를 반환함), 프 로세스는 계속 대기한다. 대안적으로, 크레디트 관리자가 크레디트들이 획득되었고 및/또는 제2 선 택된 CBB(예를 들어, DSP)로부터 송신되었다고 결정하면(예를 들어, 블록의 제어가 예의 결과를 반환 함), 크레디트 관리자는, 생산 작업부하 노드의 실행을 계속하기 위해 크레디트들을 제1 선택된 CBB(예를 들어, 컨볼루션 엔진)에 분배한다. (블록 718). 크레디트 관리자는 작업부하 노드들(예를 들어, 생산 작업부하 노드 또는 소비 작업부하 노드)의 실행이 완료되었는지를 결정한다. (블록 720). 본 명세서에 개시된 일부 예들에서, 크레디트 관리자는 버퍼들에 대해 생성된 크레디트들을 카운팅한 것에 기초하여 작업부하 노드들의 실행이 완료되었는지를 결정할 수 있다. 예를 들어, 크레디트 관리자는 생산자(예를 들어, 도 5의 제1 CBB)로서 행위하는 CBB가 대응하는 작 업부하 노드를 실행하고 및/또는 그렇지 않으면 처리하는 동안 50개의 크레디트를 생성할 것이라는 점을 실행가 능 파일로부터 알 수 있다. 따라서, 크레디트 관리자는 생산 작업부하 노드(예를 들어, 제1 CBB)로부터 50개의 크레디트를 획득하고 및/또는 그렇지 않으면 수신한 것에 응답하여 작업부하 노드들의 실행이 완료된 것을 결정할 수 있다. 크레디트 관리자가 작업부하 노드들(예를 들어, 생산 작업부하 노드 또는 소비 작업부하 노드)의 실행이 완료되지 않은 것으로 결정하는 경우(예를 들어, 블록의 제어가 아니 오의 결과를 반환함), 제어는 블록으로 복귀하고, 여기서 크레디트 관리자는 크레디트들이 제1 선택 된 CBB(예를 들어, 컨볼루션 엔진)로부터 수신되는지를 결정한다. 본 명세서에 개시된 또 다른 예에서, 크레디트 관리자가 작업부하 노드들(예를 들어, 생산 작업부하 노드 또는 소비 작업부하 노드)의 실행이 완료되지 않은 것으로 결정하고(예를 들어, 블록의 제어가 아니오의 결과를 반환함), 그리고 생산 작업부하 노드 의 실행이 완료된 것을 결정하는 경우, 제어는 소비 작업부하 노드의 실행을 완료하기 위해 블록으로 진행 할 수 있다. 대안적으로, 크레디트 관리자가 작업부하 노드들(예를 들어, 생산 작업부하 노드 또는 소비 작업부하 노드)의 실행이 완료되었다고 결정하면(예를 들어, 블록의 제어가 예의 결과를 반환함), 구성 제어기(22 4)는 추가적인 생산 및 소비 작업부하 노드들이 이용가능한지를 결정한다. (블록 722). 구성 제어기가 추가적인 생산 및 소비 작업부하 노드들이 이용가능한 것으로 결정하는 경우(예를 들어, 블록의 제어가 예 의 결과를 반환함), 제어는 블록으로 복귀한다. 대안적으로, 구성 제어기가 이용가능한 추가적인 생 산 또는 소비 작업부하 노드들이 없다고 결정하는 경우(예를 들어, 블록의 제어가 아니오의 결과를 반환함), 프로세스는 중단된다. 도 8은 도 2, 도 3, 및/또는 도 4의 예시적인 그래프 컴파일러, 예시적인 하나 이상의 선택기(들), 예시적인 선택기, 및/또는 가속기를 구현하기 위해 도 6 및/또는 도 7의 명령어들을 실행하도록 구조 화된 예시적인 프로세서 플랫폼(예를 들어, 결합된 컴필레이션 및 배치 시스템)의 블록도이다. 대안적으 로, 본 명세서에 개시된 일부 예들에서, 예시적인 그래프 컴파일러, 예시적인 하나 이상의 선택기 (들), 및/또는 예시적인 선택기는 예시적인 가속기와는 달리 도 6의 명령어들을 실행하도록 구 조화된 별도의 컴필레이션 시스템(예를 들어, 컴필레이션 프로세서)상에서 동작가능할 수 있다. 이러한 예시적 인 분리된 시스템 동작에서, 가속기는 컴필레이션 시스템이 아니라 도 7의 명령어들을 실행하도록 구조화 된 별도의 배치 시스템(예를 들어, 배치 프로세서)상에서 실행가능 파일을 실행하도록 동작가능할 수 있다. 프 로세서 플랫폼은, 예를 들어, 서버, 개인용 컴퓨터, 워크스테이션, 자가 학습 머신(예를 들어, 신경망), 모바일 디바이스(예를 들어, 셀폰, 스마트폰, iPadTM과 같은 태블릿), PDA(personal digital assistant), 인터 넷 기기, 게이밍 콘솔, 개인용 비디오 레코더, 셋톱 박스, 헤드셋 또는 다른 웨어러블 디바이스, 또는 임의의 다른 타입의 컴퓨팅 디바이스일 수 있다. 도시된 예의 프로세서 플랫폼은 프로세서 및 가속기를 포함한다. 도시된 예의 프로세서는 하드웨어이다. 예를 들어, 프로세서는 하나 이상의 집적 회로, 로직 회로들, 마이크로프로세서들, GPU들, DSP들, 또는 임의의 원하는 패밀리 또는 제조자로부터의 제어기들에 의해 구현될 수 있다. 하드웨어 프로세서 는 반도체 기반(예를 들어, 실리콘 기반) 디바이스일 수 있다. 또한, 가속기는, 예를 들어, 하나 이상의 집적 회로, 로직 회로들, 마이크로프로세서들, GPU들, DSP들, FPGA들, VPU들, 제어기들, 및/또는 임의의 원하는 패밀리 또는 제조자로부터의 다른 CBB들에 의해 구현될 수 있다. 도시된 예의 가속기는 하드웨어이다. 하드웨어 가속기는 반도체 기반(예를 들어, 실리콘 기반) 디바이스일 수 있다. 이 예에서, 가속기는 예시 적인 크레디트 관리자, 예시적인 CnC 패브릭, 예시적인 컨볼루션 엔진, 예시적인 MMU, 예 시적인 RNN 엔진, 예시적인 DSP, 예시적인 메모리, 예시적인 구성 제어기, 및/또는 예시적 인 커널 뱅크를 구현한다. 이 예에서, 프로세서는 예시적인 CBB 분석기, 예시적인 커널 분석기 , 예시적인 컴파일러 인터페이스, 및/또는 보다 일반적으로, 도 2 및/또는 도 3의 예시적인 선택기 및/또는 예시적인 하나 이상의 선택기(들), 예시적인 그래프 인터페이스, 예시적인 선택기 인 터페이스, 예시적인 작업부하 분석기, 예시적인 실행가능 생성기, 예시적인 데이터 저장소 , 예시적인 플러그인, 및/또는 보다 일반적으로, 도 2 및/또는 도 4의 예시적인 그래프 컴파일러 , 및/또는 예시적인 크레디트 관리자, 예시적인 CnC 패브릭, 예시적인 컨볼루션 엔진, 예 시적인 MMU, 예시적인 RNN 엔진, 예시적인 DSP, 예시적인 메모리, 예시적인 구성 제어기 , 예시적인 커널 뱅크, 및/또는 보다 일반적으로, 도 2의 예시적인 가속기를 구현한다. 도시된 예의 프로세서는 로컬 메모리(예를 들어, 캐시)를 포함한다. 도시된 예의 프로세서는 버스를 통해 휘발성 메모리 및 비휘발성 메모리를 포함하는 메인 메모리와 통신한다. 또한, 도 시된 예의 가속기는 로컬 메모리(예를 들어, 캐시)를 포함한다. 도시된 예의 가속기는 버스 를 통해 휘발성 메모리 및 비휘발성 메모리를 포함하는 메인 메모리와 통신한다. 휘발성 메모 리는 SDRAM(Synchronous Dynamic Random Access Memory), DRAM(Dynamic Random Access Memory), RDRAM® (RAMBUS® Dynamic Random Access Memory) 및/또는 임의의 다른 타입의 랜덤 액세스 메모리 디바이스에 의해 구현될 수 있다. 비휘발성 메모리는 플래시 메모리 및/또는 임의의 다른 원하는 타입의 메모리 디바이스 에 의해 구현될 수 있다. 메인 메모리(814, 816)에 대한 액세스는 메모리 제어기에 의해 제어된다. 도시된 예의 프로세서 플랫폼은 인터페이스 회로를 또한 포함한다. 인터페이스 회로는 이더넷 인터페이스, USB(universal serial bus), 블루투스® 인터페이스, NFC(near field communication) 인터페이스, 및/또는 PCI 익스프레스 인터페이스와 같은 임의의 타입의 인터페이스 표준에 의해 구현될 수 있다. 도시된 예에서, 하나 이상의 입력 디바이스가 인터페이스 회로에 연결된다. 입력 디바이스(들)(82 2)는 사용자가 프로세서 및/또는 가속기에 데이터 및/또는 커맨드들을 입력하는 것을 허용한다. 입 력 디바이스(들)는, 예를 들어, 오디오 센서, 마이크로폰, 카메라(정지 또는 비디오), 키보드, 버튼, 마우스, 터치스크린, 트랙-패드, 트랙볼, 이소포인트(isopoint) 및/또는 음성 인식 시스템에 의해 구현될 수 있다. 하나 이상의 출력 디바이스가 또한 도시된 예의 인터페이스 회로에 연결된다. 출력 디바이스들(82 4)은, 예를 들어, 디스플레이 디바이스들(예를 들어, 발광 다이오드(LED), 유기 발광 다이오드(OLED), 액정 디 스플레이(LCD), 음극선관 디스플레이(CRT), IPS(in-place switching) 디스플레이, 터치스크린 등), 촉각 출력 디바이스, 프린터 및/또는 스피커에 의해 구현될 수 있다. 따라서, 도시된 예의 인터페이스 회로는 통상 적으로 그래픽 드라이버 카드, 그래픽 드라이버 칩 및/또는 그래픽 드라이버 프로세서를 포함한다. 도시된 예의 인터페이스 회로는 또한 네트워크를 통해 외부 머신들(예를 들어, 임의의 종류의 컴퓨팅 디바이스들)과의 데이터 교환을 용이하게 하는 송신기, 수신기, 송수신기, 모뎀, 가정용 게이트웨이, 무선 액세 스 포인트, 및/또는 네트워크 인터페이스와 같은 통신 디바이스를 포함한다. 통신은, 예를 들어, 이더넷 접속, 디지털 가입자 회선(DSL) 접속, 전화선 접속, 동축 케이블 시스템, 위성 시스템, 가시선(line-of-site) 무선 시 스템, 셀룰러 전화 시스템 등을 통해 이루어질 수 있다. 도시된 예의 프로세서 플랫폼은 또한 소프트웨어 및/또는 데이터를 저장하기 위한 하나 이상의 대용량 저 장 디바이스를 포함한다. 이러한 대용량 저장 디바이스들의 예들은 플로피 디스크 드라이브들, 하드 드라이브 디스크들, 콤팩트 디스크 드라이브들, 블루레이 디스크 드라이브들, RAID(redundant array of independent disks) 시스템들, 및 DVD(digital versatile disk) 드라이브들을 포함한다. 도 6 및/또는 도 7의 머신 실행가능 명령어들은 대용량 저장 디바이스에, 휘발성 메모리에, 비 휘발성 메모리에, 및/또는 CD 또는 DVD와 같은 이동식 비일시적 컴퓨터 판독가능 저장 매체에 저장될 수 있다. 앞의 내용으로부터, 가속기에 이종 컴포넌트들을 구성하는 예시적 방법들, 장치 및 제조 물품들이 개시되었다는 것을 이해할 것이다. 개시된 방법들, 장치, 및 제조 물품들은 작업부하에서의 각각의 작업부하 노드에 대해 선 택기를 생성하고 및/또는 그렇지 않으면 제공함으로써 컴퓨팅 디바이스를 사용하는 효율을 개선한다. 이와 같 으므로, 개시된 방법들, 장치, 및 제조 물품들은, 가속기에서의 각각의 이종 계산 빌딩 블록 및/또는 커널에 대 해 개별적으로 구성될 필요 없이, 그래프 컴파일러가 실행가능 파일을 생성할 수 있게 한다. 추가적으로, 본 명세서에 개시된 예들은 가속기에서의 이종 계산 빌딩 블록들 및/또는 커널들로부터 크레디트들을 분배 및/또는 수신하기 위한 크레디트 관리자를 포함한다. 이러한 방식으로, 계산 빌딩 블록들 및/또는 커널들은 중앙 패브 릭 및 크레디트 관리자를 통해 다른 이종 계산 빌딩 블록들 및/또는 커널들과 통신할 수 있다. 본 명세서에 개 시된 예들은 그래프 컴파일러가 가속기에서의 임의의 수의 이종 계산 빌딩 블록들 및/또는 커널들에 대해 작업 부하(예를 들어, 수신된 그래프)를 효율적으로 매핑하는 것을 가능하게 한다. 본 명세서에 개시된 예들은 마찬 가지로 그래프 생성기가, 추가적인 계산 빌딩 블록들 및/또는 커널들이 나중에 가속기에 포함되는 경우에, 또는 현재의 계산 빌딩 블록들 및/또는 커널들이 변경되거나 조정되는 경우에 수신된 작업부하(예를 들어, 그래프)를 효율적으로 매핑하는 것을 가능하게 한다. 개시된 방법들, 장치 및 제조 물품들은 따라서 컴퓨터의 기능에서의 하나 이상의 개선(들)에 관한 것이다. 가속기에서 이종 컴포넌트들을 구성하는 방법들 및 장치에 대한 예시적인 방법들, 장치, 시스템들, 및 제조 물 품이 본 명세서에 개시되었다. 추가 예들 및 이들의 조합은 다음을 포함한다: 예 1은 가속기에서 이종 컴포넌트들을 구성하는 장치를 포함하고, 장치는 작업부하에서 작업부하 노드를 식별하 고, 작업부하 노드에 대한 선택기를 생성하고, 및 계산 빌딩 블록의 입력 조건 및 출력 조건을 식별하는 선택기 를 포함하고, 여기서 그래프 컴파일러는 선택기로부터 식별된 입력 조건 및 출력 조건을 획득한 것에 응답하여, 작업부하 노드를 계산 빌딩 블록에 매핑한다. 예 2는 예 1의 장치를 포함하고, 여기서 그래프 컴파일러는 작업부하에서 제2 작업부하 노드를 식별하고 제2 작 업부하 노드에 대한 제2 선택기를 생성한다. 예 3은 예 2의 장치를 포함하고, 여기서 제2 선택기는 커널의 제2 입력 조건 및 제2 출력 조건을 식별한다. 예 4는 예 1의 장치를 포함하고, 여기서 작업부하는 그래프 컴파일러에 의해 획득되는 작업부하 노드를 포함하 는 그래프이다. 예 5는 예 1의 장치를 포함하고, 여기서 입력 조건은 계산 빌딩 블록의 입력 요건에 대응하고 출력 조건은 계산 빌딩 블록의 실행 결과에 대응한다. 예 6은 예 1의 장치를 포함하며, 여기서 그래프 컴파일러는 작업부하 노드를 계산 빌딩 블록에 매핑한 것에 응 답하여 실행가능 파일을 생성한다. 예 7은 예 1의 장치를 포함하고, 여기서 그래프 컴파일러는 식별된 입력 조건 및 출력 조건에 기초하여 작업부 하 노드를 계산 빌딩 블록에 매핑하는 것을 가능하게 하기 위해 작업부하 노드와 계산 빌딩 블록 사이에 변환 계층을 형성하는 플러그인을 추가로 포함한다. 예 8은 명령어들을 포함하는 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 명령어들은 실행 될 때 적어도 하나의 프로세서로 하여금 작업부하에서 작업부하 노드를 적어도 식별하고, 작업부하 노드에 대한 선택기를 생성하고 - 선택기는 작업부하 노드를 실행하기 위한 계산 빌딩 블록과 연관됨 -, 계산 빌딩 블록의 입력 조건 및 출력 조건을 식별하고, 및 식별된 입력 조건 및 출력 조건을 획득한 것에 응답하여, 작업부하 노 드를 계산 빌딩 블록에 매핑하도록 야기한다. 예 9는 예 8의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 명령어들은, 실행될 때, 적어도 하나의 프로세서로 하여금 작업부하에서 제2 작업부하 노드를 식별하고, 및 제2 작업부하 노드에 대한 제2 선택기를 생성하도록 추가로 야기한다. 예 10은 예 9의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 명령어들은, 실행될 때, 적어도 하나의 프로세서로 하여금 커널의 제2 입력 조건 및 제2 출력 조건을 식별하도록 추가로 야기한다. 예 11은 예 8의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 작업부하는 작업부하 노드를 포함하는 그래프이다. 예 12는 예 8의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 입력 조건은 계산 빌딩 블록의 입력 요건에 대응하고, 출력 조건은 계산 빌딩 블록의 실행 결과에 대응한다. 예 13은 예 8의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 명령어들은, 실행될 때, 적어도 하나의 프로세서로 하여금 작업부하 노드를 계산 빌딩 블록에 매핑한 것에 응답하여 실행가능 파일 을 생성하도록 추가로 야기한다. 예 14는 예 8의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 명령어들은, 실행될 때, 적어도 하나의 프로세서로 하여금, 식별된 입력 조건 및 출력 조건에 기초하여, 작업부하 노드를 계산 빌딩 블록에 매핑하는 것을 가능하게 하기 위해 작업부하 노드와 계산 빌딩 블록 사이에 변환 계층을 형성하도록 추 가로 야기한다. 예 15는 장치를 포함하고, 장치는 작업부하에서 작업부하 노드를 식별하고 작업부하 노드를 위해 선택하기 위한 수단을 생성하도록 컴파일링하기 위한 수단, 및 작업부하 노드를 실행할 계산 빌딩 블록과 연관된 선택하기 위 한 수단, 및 계산 빌딩 블록의 입력 조건 및 출력 조건을 식별하도록 선택하기 위한 수단을 포함하고, 여기서 컴파일링하기 위한 수단은 추가로, 식별된 입력 조건 및 출력 조건을 획득한 것에 응답하여, 작업부하 노드를 계산 빌딩 블록에 매핑한다. 예 16은 예 15의 장치를 포함하고, 컴파일링하기 위한 수단은 추가로, 작업부하에서 제2 작업부하 노드를 식별 하고, 제2 작업부하 노드를 위해 선택하기 위한 제2 수단을 생성한다. 예 17은 예 16의 장치를 포함하고, 여기서 선택하기 위한 제2 수단은 추가로 커널의 제2 입력 조건 및 제2 출력 조건을 식별한다. 예 18은 예 15의 장치를 포함하고, 여기서 작업부하는 작업부하 노드를 포함하는 그래프이다. 예 19는 예 15의 장치를 포함하고, 여기서 입력 조건은 계산 빌딩 블록의 입력 요건에 대응하고 출력 조건은 계 산 빌딩 블록의 실행 결과에 대응한다. 예 20은 예 15의 장치를 포함하고, 여기서 컴파일링하기 위한 수단은 추가로, 작업부하 노드를 계산 빌딩 블록 에 매핑한 것에 응답하여 실행가능 파일을 생성한다.예 21은 예 15의 장치를 포함하고, 여기서 컴파일링하기 위한 수단은 추가로, 식별된 입력 조건 및 출력 조건에 기초하여 작업부하 노드를 계산 빌딩 블록에 매핑하는 것을 가능하게 하기 위해 작업부하 노드와 계산 빌딩 블 록 사이에 변환 계층을 형성한다. 예 22는 가속기에서 이종 컴포넌트들을 구성하는 방법을 포함하고, 방법은 작업부하에서 작업부하 노드를 식별 하는 단계, 작업부하 노드에 대한 선택기를 생성하는 단계 - 선택기는 작업부하 노드를 실행하기 위한 계산 빌 딩 블록과 연관됨 -, 계산 빌딩 블록의 입력 조건 및 출력 조건을 식별하는 단계, 및 식별된 입력 조건 및 출력 조건을 획득한 것에 응답하여, 작업부하 노드를 계산 빌딩 블록에 매핑하는 단계를 포함한다. 예 23은 예 22의 방법을 포함하고, 작업부하에서 제2 작업부하 노드를 식별하는 단계, 및 제2 작업부하 노드에 대한 제2 선택기를 생성하는 단계를 추가로 포함한다. 예 24는 예 23의 방법을 포함하는데, 커널의 제2 입력 조건 및 제2 출력 조건을 식별하는 단계를 추가로 포함한 다. 예 25는 예 22의 방법을 포함하고, 여기서 작업부하는 작업부하 노드를 포함하는 그래프이다. 예 26은 예 22의 방법을 포함하고, 여기서 입력 조건은 계산 빌딩 블록의 입력 요건에 대응하고, 출력 조건은 계산 빌딩 블록의 실행 결과에 대응한다. 예 27은 예 22의 방법을 포함하고, 작업부하 노드를 계산 빌딩 블록에 매핑한 것에 응답하여 실행가능 파일을 생성하는 단계를 추가로 포함한다. 예 28은 예 22의 방법을 포함하고, 식별된 입력 조건 및 출력 조건에 기초하여 작업부하 노드를 계산 빌딩 블록 에 매핑하는 것을 가능하게 하기 위해 작업부하 노드와 계산 빌딩 블록 사이에 변환 계층을 형성하는 단계를 추 가로 포함한다. 예 29는 이종 컴포넌트들을 동작시키는 장치를 포함하고, 장치는 다수의 데이터 슬롯을 포함하는 버퍼, 크레디 트 관리자, 제1 크레디트 값을 갖는 제1 계산 빌딩 블록 - 제1 계산 빌딩 블록은 제1 작업부하 노드를 실행하고, 제1 작업부하 노드를 실행한 것에 응답하여 데이터를 다수의 데이터 슬롯의 서브세트에 기입하고, 및 제2 크레디트 값을 크레디트 관리자에게 전송하고, 제2 크레디트 값은 제1 크레디트 값보다 작음 -, 및 크레디 트 관리자로부터 제2 크레디트 값을 수신한 것에 응답하여, 다수의 데이터 슬롯의 서브세트에서 데이터를 판독 하고, 및 제2 작업부하 노드를 실행하는 제2 계산 빌딩 블록을 포함한다. 예 30은 예 29의 장치를 포함하고, 제1 작업부하 노드를 제공하기 위해 제어 메시지 및 구성 메시지를 제1 계산 빌딩 블록에 전송하는 제어기를 추가로 포함한다. 예 31은 예 30의 장치를 포함하고, 여기서 제어기는 제1 작업부하 노드를 제1 계산 빌딩 블록에 전송하고, 제2 작업부하 노드를 제2 계산 빌딩 블록에 전송한다. 예 32는 예 29의 장치를 포함하고, 여기서 크레디트 관리자는 제1 작업부하 노드의 실행이 완료되었는지를 추가 로 결정한다. 예 33은 예 29의 장치를 포함하고, 여기서 제2 계산 빌딩 블록은 크레디트 관리자에게 제3 크레디트 값을 추가 로 전송하고, 제3 크레디트 값은 제2 크레디트 값보다 작다. 예 34는 예 33의 장치를 포함하고, 여기서 크레디트 관리자는 제3 크레디트 값을 제1 계산 빌딩 블록에 추가로 전송한다. 예 35는 명령어들을 포함하는 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 명령어들은 실행 될 때 적어도 하나의 프로세서로 하여금 제1 작업부하 노드를 적어도 실행하고, 제1 작업부하 노드를 실행한 것 에 응답하여, 제1 크레디트 값을 이용하여 다수의 데이터 슬롯에 데이터를 기입하고, 제2 크레디트 값을 크레디 트 관리자에게 전송하고 - 제2 크레디트 값은 제1 크레디트 값보다 작음 -, 크레디트 관리자로부터 제2 크레디 트 값을 수신한 것에 응답하여, 제2 크레디트 값을 사용하여 다수의 데이터 슬롯에서 데이터를 판독하고, 및 제 2 작업부하 노드를 실행하도록 야기한다. 예 36은 예 35의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 명령어들은 실행될 때, 적어도 하나의 프로세서로 하여금 제1 작업부하 노드를 제공하기 위해 제어 메시지 및 구성 메시지를 전송 하도록 추가로 야기한다.예 37은 예 36의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 명령어들은 실행될 때, 적어도 하나의 프로세서로 하여금 제1 작업부하 노드를 제1 계산 빌딩 블록에 전송하고 제2 작업부하 노드 를 제2 계산 빌딩 블록에 전송하도록 추가로 야기한다. 예 38은 예 35의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 명령어들은 실행될 때, 적어도 하나의 프로세서로 하여금 제1 작업부하 노드의 실행이 완료되었는지를 결정하도록 추가로 야기한다. 예 39는 예 35의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 명령어들은 실행될 때, 적어도 하나의 프로세서로 하여금 크레디트 관리자에 제3 크레디트 값을 전송하도록 추가로 야기하고, 제3 크레디트 값은 제2 크레디트 값보다 작다. 예 40은 예 39의 적어도 하나의 비일시적 컴퓨터 판독가능 저장 매체를 포함하고, 여기서 명령어들은 실행될 때, 적어도 하나의 프로세서로 하여금 제3 크레디트 값을 계산 빌딩 블록에 전송하도록 추가로 야기한다. 예 41은 장치를 포함하고, 장치는 제1 작업부하 노드를 실행하고, 제1 작업부하 노드를 실행한 것에 응답하여, 제1 크레디트 값을 사용하여 데이터를 다수의 데이터 슬롯에 기입하고, 및 제2 크레디트 값을 크레디트 관리를 위한 수단에 전송하는 계산을 위한 제1 수단 - 제2 크레디트 값은 제1 크레디트 값보다 작음 -, 및 크레디트 관 리를 위한 수단으로부터 제2 크레디트 값을 수신한 것에 응답하여, 제2 크레디트 값을 사용하여 다수의 데이터 슬롯에서 데이터를 판독하고, 및 제2 작업부하 노드를 실행하는 계산을 위한 제2 수단을 포함한다. 예 42는 예 41의 장치를 포함하고, 제1 작업부하 노드를 제공하기 위해 제어 메시지 및 구성 메시지를 계산을 위한 제1 수단에 전송하도록 제어하기 위한 수단을 추가로 포함한다. 예 43은 예 42의 장치를 포함하고, 여기서 제어하기 위한 수단은 추가로, 제1 작업부하 노드를 계산을 위한 제1 수단에 전송하고, 제2 작업부하 노드를 계산을 위한 제2 수단에 전송한다. 예 44는 예 41의 장치를 포함하고, 여기서 크레디트 관리를 위한 수단은 제1 작업부하 노드의 실행이 완료되었 는지를 추가로 결정한다. 예 45는 예 41의 장치를 포함하고, 여기서 계산을 위한 제2 수단은 크레디트 관리를 위한 수단에 제3 크레디트 값을 추가로 전송하고, 제3 크레디트 값은 제2 크레디트 값보다 작다. 예 46은 예 45의 장치를 포함하고, 크레디트 관리를 위한 수단은 제3 크레디트 값을 계산을 위한 제1 수단에 추 가로 전송한다. 예 47은 이종 컴포넌트들을 동작시키기 위한 방법을 포함하고, 방법은 제1 작업부하 노드를 실행하는 단계, 제1 작업부하 노드를 실행한 것에 응답하여, 제1 크레디트 값을 사용하여 데이터를 다수의 데이터 슬롯에 기입하는 단계, 제2 크레디트 값을 크레디트 관리자에게 전송하는 단계 - 제2 크레디트 값은 제1 크레디트 값보다 작음 - 크레디트 관리자로부터 제2 크레디트 값을 수신한 것에 응답하여, 제2 크레디트 값을 사용하여 다수의 데이터 슬롯에서 데이터를 판독하는 단계, 및 제2 작업부하 노드를 실행하는 단계를 포함한다. 예 48은 예 47의 방법을 포함하고, 제1 작업부하 노드를 제공하기 위해 제어 메시지 및 구성 메시지를 계산 빌 딩 블록에 전송하는 단계를 추가로 포함한다. 예 49는 예 47의 방법을 포함하고, 제1 작업부하 노드를 제1 계산 빌딩 블록에 전송하는 단계 및 제2 작업부하 노드를 제2 계산 빌딩 블록에 전송하는 단계를 추가로 포함한다. 예 50은 예 47의 방법을 포함하고, 여기서 제1 작업부하 노드의 실행이 완료되었는지를 결정하는 단계를 추가로 포함한다. 예 51은 예 47의 방법을 포함하고, 크레디트 관리자에 제3 크레디트 값을 전송하는 단계를 추가로 포함하고, 제 3 크레디트 값은 제2 크레디트 값보다 작다. 예 52는 예 51의 방법을 포함하고, 제3 크레디트 값을 계산 빌딩 블록에 전송하는 단계를 추가로 포함한다. 특정의 예시적인 방법들, 장치 및 제조 물품이 본 명세서에 개시되었지만, 본 특허의 적용 범위는 이에 제한되 지는 않는다. 오히려, 이 특허는 이 특허의 특허청구범위 내에 공정하게 속하는 모든 방법들, 장치 및 제조 물 품들을 커버한다.이하의 청구항들은 이로써 이 참조에 의해 이 상세한 설명에 통합되며, 각각의 청구항은 본 개시내용의 별개의 실시예로서 그 스스로 성립한다."}
{"patent_id": "10-2024-0134000", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 가속기에서 이종 컴포넌트들을 구성하는 예시적인 컴퓨팅 시스템을 도시하는 블록도이다. 도 2는 예시적인 그래프 컴파일러 및 하나 이상의 예시적인 선택기(들)를 포함하는 예시적인 컴퓨팅 시스템을 도시하는 블록도이다. 도 3은 도 2의 하나 이상의 선택기(들) 중 예시적인 선택기를 도시하는 예시적인 블록도이다. 도 4는 도 2의 그래프 컴파일러를 도시하는 예시적인 블록도이다. 도 5는 예시적인 제1 CBB 및 예시적인 제2 CBB를 사용하여 실행되는 작업부하를 나타내는 예시적인 파이프라인 의 그래픽 도시이다. 도 6은 도 2의 실행파일(executable)을 생성하도록 도 2, 도 3, 및/또는 도 4의 그래프 컴파일러, 선택기, 및/ 또는 하나 이상의 선택기(들)를 구현하기 위해 실행될 수 있는 프로세스를 나타내는 흐름도이다. 도 7은 도 2의 실행파일의 실행을 용이하게 하도록 도 2의 크레디트 관리자 및/또는 구성 제어기를 구현하기 위 해 실행될 수 있는 프로세스를 나타내는 흐름도이다. 도 8은 도 2, 도 3, 및/또는 도 4의 예시적인 그래프 컴파일러, 예시적인 하나 이상의 선택기(들), 예시적인 선 택기, 및/또는 가속기를 구현하기 위해 도 6 및/또는 도 7의 명령어들을 실행하도록 구조화된 예시적인 프로세 서 플랫폼의 블록도이다. 도면들은 축척에 맞지 않는다. 일반적으로, 동일 또는 유사 부분들을 지칭하기 위해 도면(들) 및 첨부 작성된 설명 전체에 걸쳐서 동일한 참조 번호들이 이용될 것이다. 연결 참조들(예를 들어, 부착, 결합, 연결, 및 합류)은 광범위하게 해석되어야 하고, 달리 지시되지 않는 한, 요소들의 모음과 요소들 사이의 상대적 이동 사 이에 중간 멤버들을 포함할 수 있다. 이와 같으므로, 연결 참조들은 2개의 요소가 직접 연결되고 서로 고정 관 계에 있다는 것을 반드시 추론해 내지 않는다. 기술어들 \"제1\", \"제2\", \"제3\" 등은 개별적으로 참조될 수 있는 다중의 요소 또는 컴포넌트를 식별할 때 본 명 세서에서 사용된다. 그들의 사용 정황에 기초하여 달리 특정되거나 이해되지 않는 한, 이러한 기술어들은 우선 순위, 리스트에서의 물리적 순서 또는 배열, 또는 시간상 순서화의 어떤 의미도 부여하도록 의도되지 않고, 단 지 개시된 예들의 이해 용이성을 위해 개별적으로 다중의 요소 또는 컴포넌트를 참조하기 위한 라벨들로서 사용 된다. 일부 예들에서, 기술어 \"제1\"은 상세한 설명에서의 한 요소를 지칭하기 위해 사용될 수 있는 한편, 동일 한 요소가 \"제2\" 또는 \"제3\"과 같은 상이한 기술어로 청구항에서 지칭될 수 있다. 이러한 경우들에서, 이러한 기술어들은 단지 다중의 요소 또는 컴포넌트를 참조하는 것의 용이성을 위해 사용되는 것으로 이해해야 한다."}
