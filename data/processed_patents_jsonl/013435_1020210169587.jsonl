{"patent_id": "10-2021-0169587", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0081505", "출원번호": "10-2021-0169587", "발명의 명칭": "메모리 컨트롤러 및 그의 동작 방법", "출원인": "에스케이하이닉스 주식회사", "발명자": "이동규"}}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "복수의 존들로 할당된 복수의 메모리 블록들을 포함하는 메모리 장치를 제어하며,상기 복수의 존들을 제어하는 복수의 코어들; 및외부 장치에 의해 쓰기 요청된 존을 제어하는 제1 코어에 의해 제어되고 프로그램 동작의 수행이 결정된 오픈존의 개수에 기초하여, 상기 쓰기 요청에 대응하는 쓰기 동작을 수행할 코어를 결정하는 외부 인터페이스 유닛;을 포함하는 메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서,상기 외부 인터페이스 유닛은 상기 제1 코어에 의해 제어되는 오픈 존의 개수보다 적은 개수의 오픈 존을 제어하는 코어를 상기 쓰기 동작을 수행할 코어로 결정하는 메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1 항에 있어서,상기 외부 인터페이스 유닛은 상기 제1 코어에 의해 제어되는 오픈 존의 개수가 임계값 이상이면, 상기 임계값보다 적은 개수의 오픈 존을 제어하는 코어를 상기 쓰기 동작을 수행할 코어로 결정하는메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1 항에 있어서,상기 쓰기 동작을 수행할 코어는 자신이 제어하고 프로그램 동작의 수행이 결정되지 않은 엠프티 존을 오픈 존으로 변경하고, 상기 새롭게 변경된 오픈 존에 할당된 메모리 블록에 상기 쓰기 동작을 수행하는 메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "복수의 존들로 할당된 복수의 메모리 블록들을 포함하는 메모리 장치를 제어하며,상기 복수의 존들을 제어하는 복수의 코어들;외부 장치로부터 수신되는 쓰기 요청에 응답하여, 상기 복수의 코어들 각각에 의해 쓰기 동작이 제어되고 프로그램 동작의 수행이 결정된 오픈 존의 개수를 나타내는 복수의 오픈 카운트 값들을 생성하는 존 정보 관리부;및상기 쓰기 요청에 대응하는 존을 제어하는 제1 코어의 제1 오픈 카운트 값에 기초하여, 상기 쓰기 요청에 대응하는 쓰기 동작을 수행할 제2 코어를 결정하는 코어 제어부;를 포함하는공개특허 10-2023-0081505-3-메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5 항에 있어서,상기 코어 제어부는 상기 제1 오픈 카운트 값보다 적은 오픈 카운트 값을 갖는 코어를 상기 제2 코어로 결정하는 메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제5 항에 있어서,상기 코어 제어부는 상기 제1 오픈 카운트 값이 최대가 아니면, 상기 제1 코어를 상기 제2 코어로 결정하는 메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제5 항에 있어서,상기 코어 제어부는 상기 제1 오픈 카운트 값이 임계값 이상이면, 상기 임계값 보다 적은 개수의 오픈 존을 제어하는 코어를 상기 제2 코어로 결정하는메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8 항에 있어서,상기 임계값은 상기 복수의 오픈 카운트 값들의 평균값을 포함하는 메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제8 항에 있어서,상기 임계값은 상기 복수의 코어들 각각이 제어하는 오픈 존의 개수들의 평균값 보다 크고, 최대 오픈 카운트값보다 적은 메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제5 항에 있어서,상기 제2 코어는 상기 제2 코어에 의해 제어되고 프로그램 동작의 수행이 결정되지 않은 엠프티 존을 오픈 존으로 변경하고, 새롭게 변경된 오픈 존에 할당된 메모리 블록에 상기 쓰기 동작을 수행하는 메모리 컨트롤러.공개특허 10-2023-0081505-4-청구항 12 제5 항에 있어서,상기 메모리 컨트롤러는 상기 존 식별정보에 대응하는 존 및 상기 존을 제어하는 코어의 매핑 관계를 포함하는 맵핑 테이블을 저장하는맵핑 테이블 저장부를 더 포함하는 메모리 컨트롤러."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "메모리 컨트롤러에 포함된 복수의 코어들을 통해서 복수의 존들로 할당된 복수의 메모리 블록들을 포함하는 메모리 장치를 제어하며,외부 장치로부터 수신되는 쓰기 요청에 응답하여, 상기 복수의 코어들 각각에 의해 제어되고 프로그램 동작의수행이 결정된 오픈 존의 개수를 나타내는 오픈 카운트 값들을 생성하는 단계; 및상기 쓰기 요청에 대응하는 존을 제어하는 제1 코어의 제1 오픈 카운트 값에 기초하여, 상기 쓰기 요청에 대응하는 쓰기 동작이 수행될 제2 코어를 결정하는 단계를 포함하는메모리 컨트롤러의 동작 방법."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제13 항에 있어서,상기 제2 코어를 결정하는 단계는상기 제1 오픈 카운트 값보다 적은 오픈 카운트 값을 갖는 코어를 상기 제2 코어로 결정하는 단계를 포함하는메모리 컨트롤러의 동작 방법."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제13 항에 있어서,상기 제2 코어를 결정하는 단계는상기 제1 오픈 카운트 값이 상기 복수의 오픈 카운트 값들 중에서 최대이면, 최소 오픈 카운트 값을 갖는 코어를 상기 제2 코어로 결정하는 단계를 포함하는메모리 컨트롤러의 동작 방법."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15 항에 있어서,상기 제2 코어를 결정하는 단계는상기 제1 오픈 카운트 값이 최대가 아니면, 상기 제1 코어를 상기 제2 코어로 결정하는 단계를 포함하는메모리 컨트롤러의 동작 방법."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "공개특허 10-2023-0081505-5-제13 항에 있어서,상기 제2 코어를 결정하는 단계는상기 제1 오픈 카운트 값이 임계값 이상이면, 상기 임계값 보다 적은 개수의 오픈 존을 제어하는 코어를 상기제2 코어로 결정하는 단계를 포함하는메모리 컨트롤러의 동작 방법."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17 항에 있어서,상기 임계값은 상기 복수의 오픈 카운트 값들의 평균값을 포함하는메모리 컨트롤러의 동작 방법."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제17 항에 있어서,상기 임계값은 상기 복수의 코어들 각각이 제어하는 오픈 존의 개수들의 평균값 보다 크고, 최대 오픈 카운트값보다 적은 메모리 컨트롤러의 동작 방법."}
{"patent_id": "10-2021-0169587", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제13 항에 있어서,상기 제2 코어에 의해 제어되며 프로그램 동작의 수행이 결정되지 않은 엠프티 존을 오픈 존으로 변경하는단계; 및상기 새롭게 변경된 오픈 존에 할당된 메모리 블록에 상기 쓰기 동작을 수행하는 단계;를 더 포함하는메모리 컨트롤러의 동작 방법."}
{"patent_id": "10-2021-0169587", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 발명의 복수의 존들로 할당된 복수의 메모리 블록들을 포함하는 메모리 장치를 제어하는 메모리 컨트롤러는 복수의 존들을 제어하는 복수의 코어들; 및 외부 장치에 의해 쓰기 요청된 존에 수행되는 쓰기 동작을 제어하도 록 설정된 제1 코어에 의해 제어되고 프로그램 동작의 수행이 결정된 오픈 존의 개수에 기초하여, 상기 쓰기 동 작을 수행할 코어를 결정하는 외부 인터페이스 유닛;을 포함한다."}
{"patent_id": "10-2021-0169587", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 전자 장치에 관한 것으로, 보다 구체적으로 본 발명은 메모리 컨트롤러 및 그 동작 방법에 관한 것이다."}
{"patent_id": "10-2021-0169587", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "최근 컴퓨터 환경에 대한 패러다임(paradigm)이 언제, 어디서나 컴퓨터 시스템을 사용할 수 있도록 하는 유비쿼 터스 컴퓨팅(ubiquitous computing)으로 전환되고 있다. 이로 인해 휴대폰, 디지털 카메라, 노트북 컴퓨터 등과 같은 휴대용 전자 장치의 사용이 급증하고 있다. 이와 같은 휴대용 전자 장치는 일반적으로 메모리 장치를 이용 하는 메모리 시스템, 다시 말해 데이터 저장 장치를 사용한다. 데이터 저장 장치는 휴대용 전자 장치의 주 기억 장치 또는 보조 기억 장치로 사용된다. 비휘발성 메모리 장치를 이용한 데이터 저장 장치는 하드 디스크와 달리 기계적인 구동부가 없어서 안정성 및 내구성이 뛰어나며, 또한 정보의 액세스 속도가 매우 빠르고 전력 소모가 적다는 장점이 있다. 이러한 장점을 갖는 메모리 시스템의 일 예로 데이터 저장 장치는, USB(Universal Serial Bus) 메모리 장치, 다양한 인터페이스를 갖는 메모리 카드, 솔리드 스테이트 드라이브(SSD: Solid State Drive) 등을 포함한다."}
{"patent_id": "10-2021-0169587", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명은 쓰기 동작에 따른 로드가 특정 코어에 집중되는 것을 방지할 수 있는 메모리 컨트롤러 및 그 동작 방 법을 제공한다. 또한, 본 발명은 복수의 코어들의 쓰기 동작에 따른 로드 레벨을 균등화 할 수 있는 메모리 컨트롤러 및 그 동 작 방법을 제공한다."}
{"patent_id": "10-2021-0169587", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 발명의 실시 예에 따르면, 메모리 컨트롤러는 복수의 존들로 할당된 복수의 메모리 블록들을 포함하는 메모 리 장치를 제어하며, 복수의 존들을 제어하는 복수의 코어들; 및 외부 장치에 의해 쓰기 요청된 존에 수행되는 쓰기 동작을 제어하도록 설정된 제1 코어에 의해 제어되고 프로그램 동작의 수행이 결정된 오픈 존의 개수에 기 초하여, 쓰기 동작을 수행할 코어를 결정하는 외부 인터페이스 유닛;을 포함할 수 있다. 외부 인터페이스 유닛은 제1 코어에 의해 제어되는 오픈 존의 개수보다 적은 개수의 오픈 존을 제어하는 코어를 쓰기 동작을 수행할 코어로 결정할 수 있다. 외부 인터페이스 유닛은 제1 코어에 의해 제어되는 오픈 존의 개수가 복수의 코어들 각각에 의해 제어되는 오픈 존의 개수들 중에서 최대이면, 최소 개수의 오픈 존을 제어하는 코어를 쓰기 동작을 수행할 코어로 결정할 수 있다. 외부 인터페이스 유닛은 제1 코어에 의해 제어되는 오픈 존의 개수가 임계값 이상이면, 임계값 보다 적은 개수 의 오픈 존을 제어하는 코어를 쓰기 동작을 수행할 코어로 결정할 수 있다. 임계값은 상기 복수의 코어들 각각이 제어하는 오픈 존의 개수들의 평균값을 포함할 수 있다. 임계값은 상기 복수의 코어들 각각이 제어하는 오픈 존의 개수들의 평균값 보다 크고, 상기 복수의 코어들 각각 에 의해 제어되는 오픈 존의 개수들의 최대값 보다 작을 수 있다. 본 발명의 실시 예에 따르면, 메모리 컨트롤러는 복수의 존들로 할당된 복수의 메모리 블록들을 포함하는 메모 리 장치를 제어하며, 복수의 존들을 제어하는 복수의 코어들; 외부 장치로부터 수신되는 쓰기 요청에 응답하여, 복수의 코어들 각각에 의해 제어되고 프로그램 동작의 수행이 결정된 오픈 존의 개수를 나타내는 복수의 오픈 카운트 값들을 생성하는 존 정보 관리부; 및 쓰기 요청에 대응하는 존을 제어하는 제1 코어의 제1 오픈 카운트 값에 기초하여, 쓰기 요청에 대응하는 쓰기 동작이 수행될 제2 코어를 결정하는 코어 제어부;를 포함할 수 있다. 코어 제어부는 제1 오픈 카운트 값보다 적은 오픈 카운트 값을 갖는 코어를 제2 코어로 결정할 수 있다. 또한, 코어 제어부는 제1 오픈 카운트 값이 복수의 오픈 카운트 값들 중에서 최대이면, 최소 오픈 카운트 값을 갖는 코어를 제2 코어로 결정할 수 있다. 본 발명의 실시 예에 따르면, 메모리 컨트롤러의 동작 방법은 메모리 컨트롤러에 포함된 복수의 코어들을 통해 서 복수의 존들로 할당된 복수의 메모리 블록들을 포함하는 메모리 장치를 제어하며, 외부 장치로부터 수신되는 쓰기 요청에 응답하여, 복수의 코어들 각각에 의해 제어되고 프로그램 동작의 수행이 결정된 오픈 존의 개수를 나타내는 오픈 카운트 값들을 생성하는 단계; 및 쓰기 요청에 대응하는 존을 제어하는 제1 코어의 제1 오픈 카 운트 값에 기초하여, 쓰기 요청에 대응하는 쓰기 동작이 수행될 제2 코어를 결정하는 단계를 포함할 수 있다. 제2 코어를 결정하는 단계는 제1 오픈 카운트 값보다 적은 오픈 카운트 값을 갖는 코어를 제2 코어로 결정하는 단계를 포함할 수 있다. 또한, 제2 코어를 결정하는 단계는 제1 오픈 카운트 값이 복수의 오픈 카운트 값들 중에서 최대이면, 최소 오픈 카운트 값을 갖는 코어를 제2 코어로 결정하는 단계를 포함할 수 있다."}
{"patent_id": "10-2021-0169587", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 발명은 쓰기 동작에 따른 로드가 어느 특정 코어에 집중되는 것을 방지하고, 복수의 존들을 제어하는 복수의 코어들의 로드 레벨을 균등화할 수 있는 메모리 컨트롤러 및 그 동작 방법을 제공할 수 있다."}
{"patent_id": "10-2021-0169587", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "이하, 도면들을 참조하여 본 발명의 실시 예들에 대해서 보다 구체적으로 설명하기로 한다. 도 1A 내지 도 1C은 데이터 처리 시스템의 동작을 설명하기 위한 도면이다. 인공지능(AI), 빅 데이터(Big Data) 및 클라우드(Cloud)와 같은 기술들은 데이터 센터(Data center)를 통해 동 작한다. 데이터 센터는 플래시 메모리로 구현된 메모리 시스템을 포함하며, 하나의 메모리 시스템에 대하여 복 수의 응용 프로그램들이 구동된다. 복수의 응용 프로그램들은 컴퓨터, 핸드폰 등과 같은 외부 장치에 의해 구동 될 수 있다. 복수의 응용 프로그램들 각각은 논리 블록 어드레스들(Logical Block Address: LBA)에 데이터를 저 장하고, 메모리 시스템은 하나의 메모리 블록에 논리 블록 어드레스들에 저장된 데이터를 저장한다. 메모리 시 스템은 서로 다른 응용 프로그램들로부터 제공된 데이터를 하나의 메모리 블록에 저장한 이후에, 논리 블록 어 드레스(Logical Block Address)와 상기 메모리 블록에 대한 물리 어드레스를 맵핑한다. 도 1A는 하나의 메모리 시스템에 대하여 3개의 응용 프로그램들이 구동되는 경우를 일 예로 설명한다. 복수의 논리 블록 어드레스들은 복수의 응용 프로그램들에 각각 대응하는 영역들로 구분되며, 복수의 응용 프로 그램들은 대응하는 영역에 포함된 논리 블록 어드레스들에 데이터를 저장한다. 도 1A에 도시된 바와 같이, 제1 응용 프로그램(APP1)은 3개의 논리 블록 어드레스들에 데이터를 저장하고, 제2 응용 프로그램(APP2)은 2개의 논리 블록 어드레스들에 데이터를 저장하며, 제3 응용 프로그램(APP3)은 3개의 논 리 블록 어드레스들에 데이터를 저장한다. 메모리 시스템은 제1 내지 제3 응용 프로그램들(APP1-APP3) 각각에 대응하는 영역들에 저장된 데이터를 하나의 메모리 블록(BLOCK)에 프로그램한다. 따라서, 하나의 메모리 블록 (BLOCK)은 제1 내지 제3 응용 프로그램들(APP1-APP3) 각각에 대한 데이터를 모두 포함한다. 도 1B는 제1 응용 프로그램이 데이터를 이레이즈한 경우에, 메모리 시스템에서의 이레이즈 동작을 나타낸다. 메모리 시스템은 리드 및 프로그램 동작은 페이지 단위로 수행하는 반면에 이레이즈 동작은 메모리 블록 단위로 수행한다. 하나의 메모리 블록(BLOCK)에 복수의 응용 프로그램들에 대한 데이터가 저장된 상태에서 제1 응용 프 로그램(APP1)이 프로그램된 데이터에 대한 이레이즈 명령을 이슈한 경우에, 메모리 시스템은 상기 제1 응용 프 로그램(APP1)에 대응하는 데이터를 무효화할 수 있다. 도 1B에 도시된 바와 같이, 메모리 블록(BLOCK)에 포함된 데이터 중 제1 응용 프로그램(APP1)에 대응하는 데이터는 무효(INVALID)이며, 제2 및 제3 응용 프로그램들(APP2, APP3)에 대응하는 데이터는 유효하다. 메모리 블록에 포함된 무효 데이터의 크기가 증가하면 메모리 시 스템의 가용 용량이 줄어들게 되므로, 메모리 시스템은 가비지 컬렉션 동작을 수행하여 무효 데이터가 저장된 영역을 가용 영역으로 전환한다. 도 1C는 메모리 블록(BLK)에 대한 가비지 컬렉션 동작을 나타낸 도면이다. 메모리 시스템은 메모리 블록(BLK)에 저장된 유효 데이터를 빈 메모리 블록에 카피한다. 도 1C를 참조하면, 메 모리 시스템은 무효 데이터인 제1 응용 프로그램에 대한 데이터를 제외하고, 유효 데이터인 제2 및 제3 응용 프 로그램들(APP2,APP3)에 대한 데이터를 빈 메모리 블록에 카피한다. 메모리 시스템은 유효 데이터를 빈 메모리 블록에 카피한 이후에, 메모리 블록에 저장된 모든 유효 데이터를 무효화하고, 상기 메모리 블록에 대해 이레이 즈 동작을 수행한다. 메모리 시스템은 무효 데이터를 포함하는 메모리 블록에서 유효 데이터만 빈 메모리 블록 으로 카피한 이후에, 상기 메모리 블록에 대한 이레이즈 동작을 수행하여 가비지 컬렉션 동작을 수행한다. 하나의 응용 프로그램에서 발생한 이레이즈 명령으로 인해 메모리 블록에 포함된 무효 데이터의 크기가 증가한 다. 무효 데이터를 제거하기 위한 가비지 컬렉션이 발생하면 진행 중이던 리드 및 프로그램 동작이 일시적으로 중단되므로, 서비스 품질이 하락하는 문제가 발생한다. 존드 네임 스페이스(Zoned Namespace)를 활용한 데이터 처리 시스템은 복수의 응용 프로그램들 간 성능 간섭과 가비지 컬렉션 동작의 발생으로 인한 성능 저하 문제를 해결할 수 있다. 도 2는 존드 네임 스페이스를 활용한 데이터 처리 시스템의 데이터 저장방법을 설명하기 위한 도면이다. 존드 네임 스페이스(Zoned-Namespace: ZNS)는 네임 스페이스를 존(Zone) 단위로 나눠 사용하는 기술을 의미한다. 네임 스페이스는 논리 블록으로 포맷할 수 있는 비휘발성 메모리의 크기를 의미한다. 존드 네임 스페 이스를 활용한 데이터 처리 시스템에서, 복수의 응용 프로그램들은 각자 정해진 존의 논리 블록 어드레스들에 순차적으로 데이터를 저장한다. 복수의 논리 블록 어드레스들이 존 단위로 나눠질 뿐만 아니라, 메모리 시스템 의 물리 영역들도 존 단위로 나눠진다. 하나의 존은 동일한 응용 프로그램에 대한 데이터를 저장하므로, 하나의 존 안에 저장된 데이터의 속성은 유사하다. 또한, 존에 포함된 논리 블록 어드레스들은 연속적이며, 존드-네임 스페이스를 적용한 메모리 시스템에서 각 존에 대응하는 메모리 블록은 항상 순차적으로(sequential) 프로그램 된다. 도 2에 도시된 도면을 참조하면, 하나의 네임 스페이스(NAMESPACE)는 복수의 존들(ZONE 1 내지 ZONE N)로 구성 된다. 상기 복수의 존들(ZONE 1 내지 ZONE N) 각각의 크기는 모두 동일하다. 하나의 응용 프로그램은 하나의 존 에 대응할 수 있으며, 경우에 따라 하나의 응용 프로그램은 복수의 존들에 대응할 수도 있다. 하나의 존은 연속 된 복수의 논리 블록 어드레스들을 포함한다. 메모리 장치 내부 영역 또한 존 단위로 나눠지며, 논리 영역에서 의 존들은 물리 영역에서의 존들과 각각 대응된다. 물리 영역에서의 존들 각각의 크기는 동일하며, 상기 존들 각각의 크기는 이레이즈 단위의 정수배일 수 있다. 제1 내지 제3 응용 프로그램들(APP1-APP3)이 각각 제1 내지 제3 존들(ZONE 1-ZONE_3)에 대응하는 경우를 예로 들면, 제1 응용 프로그램(APP1)는 제1 존(ZONE 1)에 포함된 논리 블록 어드레스들에 데이터를 저장한다. 상기 제1 존(ZONE 1)에 포함된 논리 블록 어드레스들은 연속적이며, 호스트는 메모리 시스템으로 프로그램 커맨드와 함께 존에 대한 식별정보 및 프로그램 데이터를 제공한다. 메모리 시스템은 상기 존에 대한 식별정보에 기초하 여 제1 존(ZONE 1)에 포함된 논리 블록 어드레스들에 저장된 데이터를 상기 제1 존(ZONE 1)에 대응하는 제1 메 모리 블록들(BLKs_1)에 순차적으로 프로그램한다. 마찬가지 방식으로, 제2 메모리 블록들(BLKs_2) 및 제3 메모리 블록(BLKs_3)에 각각 제2 존(ZONE_2) 및 제3 존 (ZONE_3)에 대한 데이터가 저장된다. 존드 네임 스페이스를 활용한 메모리 시스템의 경우에, 서로 다른 응용 프 로그램으로부터 제공된 데이터는 존 단위로 구분된 메모리 장치의 내부 영역들 중 서로 다른 영역에 저장된다. 도 3은 본 발명의 실시 예에 따른 메모리 시스템을 포함하는 데이터 처리 시스템의 일 예를 개략적으로 도시한 도면이다. 본 발명의 데이터 처리 시스템은 외부 장치 및 메모리 시스템을 포함한다. 도 3에 도시된 바와 같이, 데이터 처리 시스템에 포함된 외부 장치의 일 예는 호스트(Host)를 포함할 수 있으며, 이하, 본 발명의 설명에서는 외부 장치의 예를 호스트로 하여 설명하기로 한다. 그리고, 호스트는, 전자 장치, 예컨대 휴대폰, MP3 플레이어, 랩탑 컴퓨터 등과 같은 휴대용 전자 장치들, 또는 데스크탑 컴퓨터, 게임기, TV, 프로젝터 등과 같은 전자 장치들을 포함, 즉 유무선 전자 장치들을 포함한 다.또한, 호스트는, 적어도 하나의 운영 시스템(OS: operating system)를 포함하며, 운영 시스템은, 호스트 의 기능 및 동작을 전반적으로 관리 및 제어하고, 데이터 처리 시스템 또는 메모리 시스템을 사 용하는 사용자와 호스트 간에 상호 동작을 제공한다. 여기서, 운영 시스템은, 사용자의 사용 목적 및 용도 에 상응한 기능 및 동작을 지원하며, 예컨대, 호스트의 이동성(mobility)에 따라 일반 운영 시스템과 모바 일 운용 시스템으로 구분할 수 있다. 또한, 운영 시스템에서의 일반 운영 시스템 시스템은, 사용자의 사용 환경 에 따라 개인용 운영 시스템과 기업용 운영 시스템으로 구분할 수 있으며, 일 예로, 개인용 운영 시스템은, 일 반 사용자를 위한 서비스 제공 기능을 지원하도록 특성화된 시스템으로, 윈도우(windows) 및 크롬(chrome) 등을 포함하고, 기업용 운영 시스템은, 고성능을 확보 및 지원하도록 특성화된 시스템으로, 윈도 서버(windows server), 리눅스(linux) 및 유닉스(unix) 등을 포함할 수 있다. 아울러, 운영 시스템에서의 모바일 운영 시스템 은, 사용자들에게 이동성 서비스 제공 기능 및 시스템의 절전 기능을 지원하도록 특성화된 시스템으로, 안드로 이드(android), iOS, 윈도 모바일(windows mobile) 등을 포함할 수 있다. 이때, 호스트는, 복수의 운영 시스템들을 포함할 수 있으며, 또한 사용자 요청(user request)에 상응한 메모리 시스템과의 동작 수행을 위해 운영 시스템을 실행한다, 여기서, 호스트는, 사용자 요청에 해당하는 복수의 커맨드들을 메모리 시스 템으로 전송하며, 그에 따라 메모리 시스템에서는 커맨드들에 해당하는 동작들, 즉 사용자 요청에 상 응하는 동작들을 수행한다. 또한, 메모리 시스템은, 호스트의 요청에 응답하여 동작하며, 특히 호스트에 의해서 액세스되는 데이터를 저장한다. 다시 말해, 메모리 시스템은, 호스트의 주 기억 장치 또는 보조 기억 장치로 사 용될 수 있다. 여기서, 메모리 시스템은 호스트와 연결되는 호스트 인터페이스 프로토콜에 따라, 다 양한 종류의 저장 장치들 중 어느 하나로 구현될 수 있다. 예를 들면, 메모리 시스템은, 솔리드 스테이트 드라이브(SSD: Solid State Drive), MMC, eMMC(embedded MMC), RS-MMC(Reduced Size MMC), micro-MMC 형태의 멀티 미디어 카드(MMC: Multi Media Card), SD, mini-SD, micro-SD 형태의 시큐어 디지털(SD: Secure Digital) 카드, USB(Universal Storage Bus) 저장 장치, UFS(Universal Flash Storage) 장치, CF(Compact Flash) 카드, 스마트 미디어(Smart Media) 카드, 메모리 스틱(Memory Stick) 등과 같은 다양한 종류의 저장 장치들 중 어느 하나로 구현될 수 있다. 아울러, 메모리 시스템을 구현하는 저장 장치들은, DRAM(Dynamic Random Access Memory), SRAM(Static RAM) 등과 같은 휘발성 메모리 장치와, ROM(Read Only Memory), MROM(Mask ROM), PROM(Programmable ROM), EPROM(Erasable ROM), EEPROM(Electrically Erasable ROM), FRAM(Ferromagnetic ROM), PRAM(Phase change RAM), MRAM(Magnetic RAM), RRAM(Resistive RAM), 플래시 메모리 등과 같은 비휘발성 메모리 장치로 구현될 수 있다. 그리고, 메모리 시스템은, 호스트에 의해서 액세스되는 데이터를 저장하는 메모리 장치, 및 메 모리 장치로의 데이터 저장을 제어하는 메모리 컨트롤러를 포함한다. 여기서, 메모리 컨트롤러 및 메모리 장치는 하나의 반도체 장치로 집적될 수 있다. 일 예로, 메모리 컨트롤러 및 메모리 장치는 하나의 반도체 장치로 집적되어 SSD를 구성할 수 있다. 메모리 시스템 이 SSD로 이용되는 경우, 메모리 시스템에 연결되는 호스트의 동작 속도는 보다 개선될 수 있다. 아울러, 메모리 컨트롤러 및 메모리 장치는, 하나의 반도체 장치로 집적되어 메모리 카드를 구 성할 수도 있으며, 일 예로 PC 카드(PCMCIA: Personal Computer Memory Card International Association), 컴 팩트 플래시 카드(CF), 스마트 미디어 카드(SM, SMC), 메모리 스틱, 멀티미디어 카드(MMC, RS-MMC, MMCmicro), SD 카드(SD, miniSD, microSD, SDHC), 유니버설 플래시 기억 장치(UFS) 등과 같은 메모리 카드를 구성할 수 있 다. 또한, 다른 일 예로, 메모리 시스템은, 컴퓨터, UMPC(Ultra Mobile PC), 워크스테이션, 넷북(net-book), PDA(Personal Digital Assistants), 포터블(portable) 컴퓨터, 웹 타블렛(web tablet), 태블릿 컴퓨터(tablet computer), 무선 전화기(wireless phone), 모바일 폰(mobile phone), 스마트폰(smart phone), e-북(e-book), PMP(portable multimedia player), 휴대용 게임기, 네비게이션(navigation) 장치, 블랙박스(black box), 디지 털 카메라(digital camera), DMB(Digital Multimedia Broadcasting) 재생기, 3차원 텔레비전(3-dimensional television), 스마트 텔레비전(smart television), 디지털 음성 녹음기(digital audio recorder), 디지털 음성 재생기(digital audio player), 디지털 영상 녹화기(digital picture recorder), 디지털 영상 재생기(digital picture player), 디지털 동영상 녹화기(digital video recorder), 디지털 동영상 재생기(digital video player), 데이터 센터를 구성하는 스토리지, 정보를 무선 환경에서 송수신할 수 있는 장치, 홈 네트워크를 구성 하는 다양한 전자 장치들 중 하나, 컴퓨터 네트워크를 구성하는 다양한 전자 장치들 중 하나, 텔레매틱스 네트워크를 구성하는 다양한 전자 장치들 중 하나, RFID(radio frequency identification) 장치, 또는 컴퓨팅 시스 템을 구성하는 다양한 구성 요소들 중 하나 등을 구성할 수 있다. 한편, 메모리 시스템에서의 메모리 장치는, 전원이 공급되지 않아도 저장된 데이터를 유지할 수 있으 며, 특히 라이트(write) 동작을 통해 호스트로부터 제공된 데이터를 저장하고, 리드(read) 동작을 통해 저 장된 데이터를 호스트로 제공한다. 여기서, 메모리 장치는, 복수의 메모리 블록(memory block)들 (152,154,156,250)을 포함하며, 각각의 메모리 블록들(152,154,156,250)은, 복수의 페이지들(pages)을 포함하 며, 또한 각각의 페이지들은, 복수의 워드라인(WL: Word Line)들이 연결된 복수의 메모리 셀들을 포함한다. 또 한, 메모리 장치는, 복수의 메모리 블록들(152,154,156,250)이 각각 포함된 복수의 플레인들(plane)을 포 함하며, 특히 복수의 플레인들이 각각 포함된 복수의 메모리 다이(memory die)들을 포함할 수 있다. 아울러, 메 모리 장치는, 비휘발성 메모리 장치, 일 예로 플래시 메모리가 될 수 있으며, 이때 플래시 메모리는 3차원 (dimension) 입체 스택(stack) 구조가 될 수 있다. 그리고, 메모리 시스템에서의 메모리 컨트롤러는, 호스트로부터의 요청에 응답하여 메모리 장치 를 제어한다. 예컨대, 메모리 컨트롤러는, 메모리 장치로부터 리드된 데이터를 호스트로 제공하고, 호스트로부터 제공된 데이터를 메모리 장치에 저장하며, 이를 위해 메모리 컨트롤러 는, 메모리 장치의 리드, 라이트, 프로그램(program), 이레이즈(erase) 등의 동작을 제어한다. 보다 구체적으로 설명하면, 메모리 컨트롤러는, 호스트 인터페이스(Host I/F) 유닛, 프로세서 (Processor), 에러 정정 코드(ECC: Error Correction Code) 유닛, 파워 관리 유닛(PMU: Power Management Unit), 메모리 인터페이스(Memory I/F) 유닛, 및 메모리(Memory)를 포함한다. 또한, 호스트 인터페이스 유닛은, 호스트의 커맨드(command) 및 데이터를 처리하며, USB(Universal Serial Bus), MMC(Multi-Media Card), PCI-E(Peripheral Component Interconnect-Express), SAS(Serial- attached SCSI), SATA(Serial Advanced Technology Attachment), PATA(Parallel Advanced Technology Attachment), SCSI(Small Computer System Interface), ESDI(Enhanced Small Disk Interface), IDE(Integrated Drive Electronics), MIPI(Mobile Industry Processor Interface) 등과 같은 다양한 인터페이 스 프로토콜들 중 적어도 하나를 통해 호스트와 통신하도록 구성될 수 있다. 여기서, 호스트 인터페이스 유닛은, 호스트와 데이터를 주고 받는 영역으로 호스트 인터페이스 계층(HIL: Host Interface Layer, 이하 'HIL'이라 칭하기로 함)이라 불리는 펌웨어(firmware)를 통해 구동될 수 있다. 아울러, ECC 유닛은, 메모리 장치에서 처리되는 데이터의 에러 비트를 정정하며, ECC 인코더와 ECC 디코더를 포함할 수 있다. 여기서, ECC 인코더(ECC encoder)는 메모리 장치에 프로그램될 데이터를 에러 정정 인코딩(error correction encoding)하여, 패리티(parity) 비트가 부가된 데이터를 생성하며, 패리티 비트 가 부가된 데이터는, 메모리 장치에 저장될 수 있다. 그리고, ECC 디코더(ECC decoder)는, 메모리 장치 에 저장된 데이터를 리드할 경우, 메모리 장치로부터 리드된 데이터에 포함되는 에러를 검출 및 정정 한다. 다시 말해, ECC 유닛은, 메모리 장치로부터 리드한 데이터를 에러 정정 디코딩(error correction decoding)한 후, 에러 정정 디코딩의 성공 여부를 판단하고, 판단 결과에 따라 지시 신호, 예컨대 에러 정정 성공(success)/실패(fail) 신호를 출력하며, ECC 인코딩 과정에서 생성된 패리티(parity) 비트를 사 용하여 리드된 데이터의 에러 비트를 정정할 수 있다. 이때, ECC 유닛은, 에러 비트 개수가 정정 가능한 에러 비트 한계치 이상 발생하면, 에러 비트를 정정할 수 없으며, 에러 비트를 정정하지 못함에 상응하는 에러 정정 실패 신호를 출력할 수 있다. 여기서, ECC 유닛은, LDPC(low density parity check) 코드(code), BCH(Bose, Chaudhri, Hocquenghem) 코드, 터보 코드(turbo code), 리드-솔로몬 코드(Reed-Solomon code), 컨벌루션 코드(convolution code), RSC(recursive systematic code), TCM(trellis-coded modulation), BCM(Block coded modulation) 등의 코디드 모듈레이션(coded modulation)을 사용하여 에러 정정을 수행할 수 있으며, 이에 한정되는 것은 아니다. 또한, ECC 유닛는 오류 정정을 위한 회로, 모듈, 시스템, 또는 장치를 모두 포함할 수 있다. 그리고, PMU는, 메모리 컨트롤러의 파워, 즉 메모리 컨트롤러에 포함된 구성 요소들의 파워를 제공 및 관리한다. 또한, 메모리 인터페이스 유닛은, 메모리 컨트롤러가 호스트로부터의 요청에 응답하여 메모리 장치를 제어하기 위해, 메모리 컨트롤러와 메모리 장치 간의 인터페이싱을 수행하는 메모리/스 토리지(storage) 인터페이스가 된다. 여기서, 메모리 인터페이스 유닛은, 메모리 장치가 플래시 메모리, 특히 일 예로 메모리 장치가 NAND 플래시 메모리일 경우에 NAND 플래시 컨트롤러(NFC: NAND Flash Controller)로서, 프로세서의 제어에 따라, 메모리 장치의 제어 신호를 생성하고 데이터를 처리한다. 그리고, 메모리 인터페이스 유닛은, 메모리 컨트롤러와 메모리 장치 간의 커맨드 및 데이터를 처리하는 인터페이스, 일 예로 NAND 플래시 인터페이스의 동작, 특히 메모리 컨트롤러와 메모리 장치 간 데이터 입출력을 지원하며, 메모리 장치와 데이터를 주고받는 영역으로 플래시 인터페이스 계층(FIL: Flash Interface Layer, 이하 'FIL'이라 칭하기로 함)이라 불리는 펌웨어(firmware)를 통해 구동될 수 있다. 아울러, 메모리는, 메모리 시스템 및 메모리 컨트롤러의 동작 메모리로서, 메모리 시스템 및 메모리 컨트롤러의 구동을 위한 데이터를 저장한다. 보다 구체적으로 설명하면, 메모리는, 메모리 컨트롤러가 호스트로부터의 요청에 응답하여 메모리 장치를 제어, 예컨대 메모리 컨트롤러(13 0)가, 메모리 장치로부터 리드된 데이터를 호스트로 제공하고, 호스트로부터 제공된 데이터를 메모리 장치에 저장하며, 이를 위해 메모리 컨트롤러가, 메모리 장치의 리드, 라이트, 프로그램, 이레이즈(erase) 등의 동작을 제어할 경우, 이러한 동작을 메모리 시스템, 즉 메모리 컨트롤러 와 메모리 장치 간이 수행하기 위해 필요한 데이터를 저장한다. 여기서, 메모리는, 휘발성 메모리로 구현될 수 있으며, 예컨대 정적 랜덤 액세스 메모리(SRAM: Static Random Access Memory), 또는 동적 랜덤 액세스 메모리(DRAM: Dynamic Random Access Memory) 등으로 구현될 수 있다. 아울러, 메모리는, 도 3에서 도시한 바와 같이, 메모리 컨트롤러의 내부에 존재하거나, 또 는 메모리 컨트롤러의 외부에 존재할 수 있으며, 이때 메모리 인터페이스를 통해 메모리 컨트롤러로 부터 데이터가 입/출력되는 외부 휘발성 메모리로 구현될 수도 있다. 또한, 메모리는, 전술한 바와 같이, 호스트와 메모리 장치 간 데이터 라이트 및 리드 등의 동작 을 수행하기 위해 필요한 데이터, 및 데이터 라이트 및 리드 등의 동작 수행 시의 데이터를 저장하며, 이러한 데이터 저장을 위해, 프로그램 메모리, 데이터 메모리, 라이트 버퍼(buffer)/캐시(cache), 리드 버퍼/캐시, 데 이터 버퍼/캐시, 맵(map) 버퍼/캐시 등을 포함한다. 그리고, 프로세서는, 메모리 시스템의 전체적인 동작을 제어하며, 특히 호스트로부터의 라이트 요청 또는 리드 요청에 응답하여, 메모리 장치에 대한 프로그램 동작 또는 리드 동작을 제어한다. 여기서, 프로세서는, 메모리 시스템의 제반 동작을 제어하기 위해 플래시 변환 계층(FTL: Flash Translation Layer, 이하 'FTL'이라 칭하기로 함)이라 불리는 펌웨어(firmware)를 구동한다. 또한, 프로세서는, 마이크 로프로세서 또는 중앙 처리 장치(CPU) 등으로 구현될 수 있다. 일 예로, 메모리 컨트롤러는, 마이크로프로세서 또는 중앙 처리 장치(CPU) 등으로 구현된 프로세서를 통해, 호스트로부터 요청된 동작을 메모리 장치에서 수행, 다시 말해 호스트로부터 수신된 커맨 드에 해당하는 커맨드 동작을, 메모리 장치와 수행한다. 여기서, 메모리 컨트롤러는, 호스트로 부터 수신된 커맨드에 해당하는 커맨드 동작으로 포그라운드(foreground) 동작을 수행, 예컨대 라이트 커맨드에 해당하는 프로그램 동작, 리드 커맨드에 해당하는 리드 동작, 이레이즈 커맨드(erase command)에 해당하는 이레 이즈 동작, 셋 커맨드(set command)로 셋 파라미터 커맨드(set parameter command) 또는 셋 픽쳐 커맨드(set feature command)에 해당하는 파라미터 셋 동작 등을 수행할 수 있다. 그리고, 메모리 컨트롤러는, 마이크로프로세서 또는 중앙 처리 장치(CPU) 등으로 구현된 프로세서를 통해, 메모리 장치에 대한 백그라운드(background) 동작을 수행할 수도 있다. 여기서, 메모리 장치에 대한 백그라운드 동작은, 메모리 장치의 메모리 블록들(152,154,156,250)에서 임의의 메모리 블록에 저장 된 데이터를 다른 임의의 메모리 블록으로 카피(copy)하여 처리하는 동작, 일 예로 가비지 컬렉션(GC: Garbage Collection) 동작, 메모리 장치의 메모리 블록들(152,154,156,250) 간 또는 메모리 블록들 (152,154,156,250)에 저장된 데이터 간을 스왑(swap)하여 처리하는 동작, 일 예로 웨어 레벨링(WL: Wear Leveling) 동작, 메모리 컨트롤러에 저장된 맵 데이터를 메모리 장치의 메모리 블록들 (152,154,156,250)로 저장하는 동작, 일 예로 맵 플러시(map flush) 동작, 또는 메모리 장치에 대한 배드 관리(bad management)하는 동작, 일 예로 메모리 장치에 포함된 복수의 메모리 블록들(152,154,156,250) 에서 배드 블록을 확인하여 처리하는 배드 블록 관리(bad block management) 동작 등을 포함한다. 또한, 본 발명의 실시 예에 따른 메모리 시스템에서는, 일 예로, 메모리 컨트롤러가, 호스트로부터 수신된 복수의 커맨드들에 해당하는 복수의 커맨드 동작들, 예컨대 복수의 라이트 커맨드들에 해당하는 복수의 프로그램 동작들, 복수의 리드 커맨드들에 해당하는 복수의 리드 동작들, 및 복수의 이레이즈 커맨드들에 해당 하는 복수의 이레이즈 동작들을 메모리 장치에서 수행할 경우, 메모리 장치에 포함된 복수의 메모리다이들과 연결된 복수의 채널(channel)들(또는 웨이(way)들)에서, 최상(best)의 채널들(또는 웨이들)을 결정한 후, 최상의 채널들(또는 웨이들)을 통해, 호스트로부터 수신된 커맨드들 해당하는 메모리 다이들로 전송하 며, 또한 커맨드들에 해당하는 커맨드 동작들을 수행한 메모리 다이들로부터 커맨드 동작들의 수행 결과들을, 최상의 채널들(또는 웨이들)을 통해, 수신한 후, 커맨드 동작들의 수행 결과들을 호스트로 제공한다. 특히, 본 발명의 실시 예에 따른 메모리 시스템에서는, 호스트로부터 복수의 커맨드들을 수신할 경우, 메 모리 장치의 메모리 다이들과 연결된 복수의 채널들(또는 웨이들)의 상태를 확인한 후, 채널들(또는 웨이 들)의 상태에 상응하여 최상의 전송 채널들(또는 전송 웨이들)을 결정하며, 최상의 전송 채널들(또는 전송 웨이 들)을 통해, 호스트로부터 수신된 복수의 커맨드들을 해당하는 메모리 다이들로 전송한다. 또한, 본 발명 의 실시 예에 따른 메모리 시스템에서는, 호스트로부터 수신된 복수의 커맨드들을 해당하는 커맨드 동작들 을 메모리 장치의 메모리 다이들에서 수행한 후, 메모리 장치의 메모리 다이들에 연결된 복수의 채널 들(또는 웨이들)에서, 채널들(또는 웨이들)의 상태에 상응한 최상의 수신 채널들(또는 수신 웨이들)을 통해, 커 맨드 동작들에 대한 수행 결과들을, 메모리 장치의 메모리 다이들로부터 수신하며, 메모리 장치의 메 모리 다이들로부터 수신된 수행 결과들을, 호스트로부터 수신된 복수의 커맨드들에 대한 응답으로, 호스트 로 제공한다. 여기서, 메모리 컨트롤러는, 메모리 장치에 포함된 복수의 메모리 다이들과 연결된 복수의 채널들(또 는 웨이들)의 상태를 확인, 예컨대 채널들(또는 웨이들)의 비지(busy) 상태, 레디(ready) 상태, 액티브(active) 상태, 아이들(idle) 상태, 정상(normal) 상태, 비정상(abnormal) 상태 등을 확인한 후, 채널들(또는 웨이들)의 상태에 따라 최상의 채널들(또는 웨이들)을 통해, 호스트로부터 수신된 복수의 커맨드들을, 해당하는 메모 리 다이들로 전송, 다시 말해 최상의 전송 채널들(또는 전송 웨이들)을 통해, 호스트로부터 수신된 복수의 커맨드들에 해당하는 커맨드 동작들의 수행을, 해당하는 메모리 다이들로 요청한다. 또한, 메모리 컨트롤러 는, 최상의 전송 채널들(또는 전송 웨이들)을 통한 커맨드 동작들의 수행 요청에 상응하여, 해당하는 메모 리 다이들로부터 커맨드 동작들의 수행 결과들을 수신하며, 이때 채널들(또는 웨이들)의 상태에 따라 최상의 채 널들(또는 웨이들), 다시 말해 최상의 수신 채널들(또는 수신 웨이들)을 통해, 커맨드 동작들의 수행 결과들을 수신한다. 그리고, 메모리 컨트롤러는, 최상의 전송 채널들(또는 전송 웨이들)을 통해 전송되는 커맨드들 의 디스크립터(descriptor)와, 최상의 수신 채널들(또는 수신 웨이들)을 통해 수신되는 수행 결과들의 디스크립 터 간을, 매칭(matching)한 후, 호스트로부터 수신된 커맨드들에 해당하는 커맨드 동작들의 수행 결과들을, 호스트로 제공한다. 여기서, 커맨드들의 디스크립터에는, 커맨드들에 해당하는 데이터 정보 또는 위치 정보, 예컨대 라이트 커맨드 들 또는 리드 커맨드들에 해당하는 데이터의 어드레스(일 예로, 데이터의 논리적 페이지 번호) 또는 데이터가 저장된 위치의 어드레스(일 예로, 메모리 장치의 물리적 페이지 정보) 등, 및 커맨드들이 전송된 전송 채 널들(또는 전송 웨이들)의 지시 정보, 예컨대 전송 채널들(또는 전송 웨이들)의 식별자(일 예로, 채널 번호(또 는 웨이 번호)) 등이 포함될 수 있다. 또한, 수행 결과들의 디스크립터에는, 수행 결과들에 해당하는 데이터 정 보 또는 위치 정보, 예컨대 라이트 커맨드들에 해당하는 프로그램 동작들의 데이터 또는 리드 커맨드들에 해당 하는 리드 동작들의 데이터에 대한 어드레스(일 예로, 데이터에 대한 논리적 페이지 번호) 또는 프로그램 동작 들 또는 리드 동작들이 수행된 위치의 어드레스(일 예로, 메모리 장치의 물리적 페이지 정보) 등, 및 커맨 드 동작들이 요청된 채널들(또는 웨이들), 다시 말해 커맨드들이 전송된 전송 채널들(또는 전송 웨이들)의 지시 정보, 예컨대 전송 채널들(또는 전송 웨이들)의 식별자(일 예로, 채널 번호(또는 웨이 번호)) 등이 포함될 수 있다. 아울러, 커맨드들의 디스크립터 및 수행 결과들의 디스크립터에 포함된 정보들, 예컨대 데이터 정보, 위 치 정보, 또는 채널들(또는 웨이들)의 지시 정보는, 컨텍스트(context) 형태 또는 태그(tag) 형태로, 디스크립 터에 포함될 수 있다. 즉, 본 발명의 실시 예에 따른 메모리 시스템에서는, 호스트로부터 수신되는 복수의 커맨드들, 및 커 맨드들에 해당하는 복수의 커맨드 동작들의 수행 결과들을, 메모리 장치의 메모리 다이들에 연결된 복수의 채널들(또는 웨이들)에서, 최상의 채널들(또는 웨이들)을 통해, 송수신한다. 특히, 본 발명의 실시 예에 따른 메모리 시스템에서는, 메모리 장치의 메모리 다이들에 연결된 복수의 채널들(또는 웨이들)의 상태에 상응하여, 커맨드들이 메모리 장치의 메모리 다이들로 전송되는 전송 채널들(또는 전송 웨이들)과, 커맨드 동작들의 수행 결과들이 메모리 장치의 메모리 다이들로부터 수신되는 수신 채널들(또는 수신 웨이들)을, 각각 독립적으로 관리한다. 예컨대, 메모리 시스템에서의 메모리 컨트롤러는, 복수의 채널들(또는 웨 이들)의 상태에 상응하여, 복수의 채널들(또는 웨이들)에서, 제1커맨드가 전송되는 전송 채널(또는 전송 웨이) 과, 제1커맨드에 해당하는 제1커맨드 동작의 수행 결과가 수신되는 수신 채널(또는 수신 웨이)을, 각각 독립적 인 최상의 채널들(또는 웨이들)로 결정, 일 예로 전송 채널(또는 전송 웨이)을 제1최상의 채널(또는 웨이)로 결정하고, 수신 채널(또는 수신 웨이)을 제1최상의 채널(또는 웨이)로 결정하거나 제2최상의 채널(또는 웨이)로 결정한 후, 각각 독립적인 최상의 채널들(또는 웨이들)을 통해, 제1커맨드의 전송과, 제1커맨드 동작의 수행 결 과의 수신을, 각각 수행한다. 그러므로, 본 발명의 실시 예에 따른 메모리 시스템에서는, 메모리 장치의 복수의 메모리 다이들과 연결된 복수의 채널들(또는 웨이들)을 보다 효율적으로 사용하며, 특히 각각 독립적인 최상의 채널들(또는 웨이 들)을 통해, 호스트로부터 수신된 복수의 커맨드들과, 커맨드들에 해당하는 커맨드 동작들의 수행 결과들 을, 각각 송수신함으로써, 메모리 시스템의 동작 성능을 보다 향상시킬 수 있다. 여기서, 후술할 본 발명 의 실시 예에서는, 설명의 편의를 위해, 메모리 시스템의 메모리 장치에 포함된 메모리 다이들에 대 한 복수의 채널들(또는 웨이들)을 통해, 호스트로부터 수신된 복수의 커맨드들과, 커맨드들에 해당하는 커 맨드 동작들의 수행 결과들을, 송수신하는 경우를 일 예로 하여 설명하지만, 메모리 컨트롤러 및 메모리 장치를 각각 포함한 복수의 메모리 시스템들에서, 각각의 메모리 시스템들에 대한 복수의 채널들(또는 웨 이들)을 통해, 호스트로부터 수신된 복수의 커맨드들과, 커맨드들에 해당하는 커맨드 동작들을 각각의 메 모리 시스템들에서 수행한 이후의 수행 결과들을, 송수신하는 경우에도 동일하게 적용될 수 있다. 본 발명의 실시 예에서, 복수의 존들(ZONE 1 내지 ZONE N)은 각각 복수의 메모리 블록들(152,154,156,,,,,)을 포함할 수 있다. 실시 예에서, 복수의 존들(ZONE 1 내지 ZONE N) 각각에 포함된 메모리 블록들의 개수는 서로 상이하거나, 같을 수 있다. 존은 호스트로부터 입력되는 복수의 논리 블록 어드레스들로 구성된 논리 블록 어드레스 그룹(LBA GROUP)에 대응되는 저장 영역일 수 있다. 구체적으로, 복수의 존들은 각각 대응되는 논리 블 록 어드레스 그룹(LBA GROUP)들에 대응되는 데이터를 저장하는 영역일 수 있다. 도 2에 도시된 바와 같이, 제1 존(ZONE 1)은 제1 메모리 블록 그룹(LBA GROUP 1)에 대응되는 데이터를 저장하는 영역일 수 있다. 또한, 제2 존 (ZONE 2)은 제2 메모리 블록 그룹(LBA GROUP 2)에 대응되는 데이터를 저장하는 영역일 수 있다. 또한, 제3 존 (ZONE 3)은 제3 메모리 블록 그룹(LBA GROUP 3)에 대응되는 데이터를 저장하는 영역일 수 있다. 또한, 제N 존 (ZONE N)은 제N 메모리 블록 그룹(LBA GROUP N)에 대응되는 데이터를 저장하는 영역일 수 있다 이때, 논리 블록 어드레스 그룹들은 각각 연속되는 논리 블록 어드레스들을 포함할 수 있다. 본 발명의 메모리 컨트롤러에 포함되는 복수의 코어들은 각각 복수의 존들에 수행되는 동작을 제어하도록 설정될 수 있다. 복수의 코어들은 각각 호스트로부터 입력되는 요청에 따라 복수의 존들에 수행되는 동작 을 제어할 수 있다. 예를 들어, 복수의 코어들은 각각 호스트로부터 입력되는 연속적인 논리 블록 어드레스들 (LBA GROUP)에 대응되는 존이 요청에 대응되는 동작을 수행하도록 해당 존에 수행되는 동작을 제어할 수 있다. 한편, 호스트로부터 수신되는 요청이 어떤 존에 대한 요청인지에 따라 각 코어에 분배되는 요청의 양이 서 로 달라질 수 있다. 따라서, 호스트의 요청이 복수의 코어들 중 특정 코어에 지나치게 입력될 수 있다. 이 경우, 복수의 코어들의 로드 레벨이 서로 달라질 수 있다. 이를 해결하기 위해, 복수의 코어들에 대해 호스트의 요청을 균등하게 분산하여 복수의 코어들 간의 로드 레벨을 균등하게 유지하는 방안이 필요하다. 도 4는 본 발명의 일 실시 예에 따른 메모리 컨트롤러를 설명하기 위한 도면이다. 본 발명의 실시 예에 따른 데이터 처리 시스템은 호스트, 메모리 컨트롤러 및 메모리 장치(15 0)를 포함할 수 있다. 도 4에 도시된 호스트, 메모리 컨트롤러 및 메모리 장치는 도 3에 도시된 호스트, 메모리 컨트롤러 및 메모리 장치에 대응될 수 있다. 메모리 장치는 복수의 존들(ZONE 1, ZONE 2, ZONE 3 ~ ZONE N)로 할당된 복수의 메모리 블록들을 포함하 고, 메모리 컨트롤러에 의해 제어될 수 있다. 호스트는 쓰기 요청(WT_REQ)을 메모리 컨트롤러로 전송한다. 호스트는 쓰기 데이터 및 존 식별 정보를 쓰기 요청(WT_REQ)과 함께 메모리 시스템으로 전송할 수 있다. 존 식별정보는 쓰기 데이터의 논리 블록 어드레스(LBA)를 포함할 수 있다. 메모리 컨트롤러는 호스트 인터페이스 유닛 및 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D)를 포함할 수 있다. 도 4에서는 메모리 컨트롤러가 4개의 코어만을 포함하는 것으로 도시되어 있으나, 본 발 명은 이에 한정되지 않는다. 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D)은 도 3에 도시된 프로세서에 대응될 수 있다. 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D)은 병렬로 동작할 수 있으며, 각각 플래시 변환 레이어(FTL)를 구동 할 수 있다. 본 발명의 실시 예에 따른 호스트 인터페이스 유닛은 호스트의 쓰기 요청(WT_REQ)에 응답하여 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D)의 로드 레벨(load level)이 균등하게 유지되고 있는지 여부를 확인 하고, 균등하게 관리할 수 있다. 호스트 인터페이스 유닛은 호스트로부터 수신되는 쓰기 요청(WT_REQ)에 의한 쓰기 동작의 수행이 요 청된 존을 제어하는 제1 코어를 검출할 수 있다. 그리고 호스트 인터페이스 유닛은 검출된 제1 코어에 의 해 제어되는 오픈 존의 개수에 기초하여, 쓰기 동작을 수행할 제2 코어를 결정할 수 있다. 제1 코어는 호스트 에 의해 쓰기 요청된 존에 수행되는 쓰기 동작을 제어하도록 설정될 수 있다. 본 발명의 설명에서, 제2 코어는 메모리 컨트롤러에 의해 결정되어 쓰기 요청(WT_REQ)에 의한 쓰기 동작을 수행하는 코어일 수 있다. 본 발명의 설명에서, 제1 코어는 호스트로부터 수신되는 쓰기 요청(WT_REQ)에 의한 쓰기 동작의 수행이 요 청된 존을 제어하는 코어일 수 있다. 제2 코어는 메모리 컨트롤러에 의해 결정되어 쓰기 요청(WT_REQ)에 의한 쓰기 동작을 수행하는 코어일 수 있다. 이를 위해, 본 발명의 호스트 인터페이스 유닛은 존 정보 관리부 및 코어 제어부를 포함할 수 있다. 존 정보 관리부는 존 식별정보, 존 식별정보에 대응되는 존 및 존을 제어하는 코어 간에 맵핑 관계를 포함 하는 맵핑 테이블을 생성할 수 있다. 존 정보 관리부는 호스트로부터 수신되는 쓰기 요청(WT_REQ)에 응답하여, 복수의 존들(ZONE 1, ZONE 2, ZONE 3 ~ ZONE N) 각각의 프로그램 상태를 나타내는 상태 정보(STATE)를 생성할 수 있다. 상태 정보(STAT E)는 오픈(open) 상태, 클로즈드(closed) 상태, 엠프티(empty) 상태, 및 풀(full) 상태를 포함할 수 있다. 오 픈 상태는 메모리 컨트롤러에 의해, 프로그램 동작의 수행이 결정된 상태를 의미한다. 오픈 상태는 프로그 램 동작이 수행중인 상태 및 프로그램 동작이 곧 수행 예정인 상태를 포함할 수 있다. 클로즈드 상태는 프로그 램 동작의 중단이 결정된 상태를 포함할 수 있다. 엠프티 상태는 이레이즈 상태이며 프로그램 동작의 수행이 결 정되지 않은 상태를 포함할 수 있다. 풀 상태는 프로그램 동작이 완료된 상태를 포함할 수 있다. 존 정보 관리부는 생성된 상태 정보(STATE)에 기초하여, 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D) 각각의 오픈 카운트 값들(OPEN_CNT)을 생성할 수 있다. 오픈 카운트 값(OPEN_CNT)은 코어가 제어하는 오픈 존의 개수를 의미할 수 있다. 오픈 존은 상태 정보(STATE)가 오픈 상태인 존을 의미할 수 있다. 예를 들어, CORE_B가 5개의 존(ZONE 2, ZONE 6, ZONE 10, ZONE 14, ZONE 18)을 제어한다고 가정한다. 이때, 4개의 존(ZONE 2, ZONE 6, ZONE 10, ZONE 14)의 상태 정보(STATE)는 'OPEN'이고, 나머지 1개의 존(ZONE 18)의 상태 정보(STATE)는 'EMPTY'인 경우, CORE_B의 오픈 카운트 값들(OPEN_CNT)은 '4개'일 수 있다. 도 4에서, 맵핑 테이블(MAP TABLE), 상태 정보(STATE) 및 오픈 카운트 값(OPEN_CNT)이 각각 저장되는 저장부가 존 정보 관리부에 저장된 것으로 도시되지만, 본 발명은 이에 한정되지 않는다. 코어 제어부는 존 식별정보에 기초하여, 쓰기 요청(WT_REQ)에 의해 쓰기 동작의 수행이 요청된 존을 검출 할 수 있다. 존 식별정보는 논리 블록 어드레스(LBA)를 포함할 수 있다. 예를 들면, 호스트로부터 쓰기 요 청(WT_REQ)과 함께 쓰기 데이터 및 논리 블록 어드레스가 수신되면, 코어 제어부는 논리 블록 어드레스에 대응되는 존을 검출할 수 있다. 그리고 검출된 존을 제어하는 코어를 제1 코어로 결정할 수 있다. 코어 제어부는 쓰기 요청(WT_REQ)에 의해 쓰기 동작의 수행이 요청된 존을 제어하는 제1 코어의 제1 오픈 카운트 값에 기초하여, 제1 코어의 로드 레벨이 높은지 여부를 확인할 수 있다. 제1 오픈 카운트 값은 제1 코어 가 제어하는 오픈 존의 개수를 나타낼 수 있다. 실시 예에서, 코어 제어부는 제1 오픈 카운트 값이 복수의 오픈 카운트 값들(OPEN_CNT) 중에서 최대이면, 제1 코어의 로드 레벨이 높다고 판단할 수 있다. 또한, 실시 예에서, 코어 제어부는 제1 오픈 카운트 값이 임계값 이상이면, 제1 코어의 로드 레벨이 높다 고 판단할 수 있다. 즉, 코어 제어부는 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D)의 로드 레벨이 균등하지 않다고 판단할 수 있다. 임계값은 복수의 오픈 카운트 값들의 평균값을 포함할 수 있다. 또한, 임계값 은 복수의 오픈 카운트 값들의 평균값보다 크고, 최대 오픈 카운트 값보다 적은 값을 포함할 수 있다. 코어 제어부는 제1 코어의 로드 레벨이 높은 경우, 쓰기 요청(WT_REQ)에 대응하는 쓰기 동작이 수행될 코 어를 변경할 수 있다. 즉, 코어 제어부 제1 코어의 제1 오픈 카운트 값에 기초하여, 쓰기 요청(WT_REQ)에 대응하는 쓰기 동작을 제1 코어보다 로드 레벨이 낮은 제2 코어가 수행하도록 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D)을 제어할 수 있다. 제2 코어는 쓰기 요청(WT_REQ)에 의해 쓰기 동작의 수행이 요청된 존을 제어하는 제1 코어 대신에, 쓰기 동작을 수행하는 코어를 의미하며, 제2 코어는 코어 제어부에 의해 결정 된다. 또한, 코어 제어부는 제1 오픈 카운트 값보다 적은 오픈 카운트 값을 갖는 코어를 제2 코어로 결정할 수 있다. 실시 예에서, 코어 제어부는 제1 오픈 카운트 값이 복수의 오픈 카운트 값들(OPEN_CNT) 중에서 최대이면, 최소 오픈 카운트 값을 갖는 코어를 제2 코어로 결정할 수 있다. 코어 제어부는 제1 오픈 카운트 값이 최 대가 아니면, 제1 코어를 제2 코어로 결정할 수 있다. 또한, 실시 예에서, 코어 제어부는 제1 오픈 카운트 값이 임계값 이상이면, 임계값 미만의 오픈 카운트 값 을 갖는 코어를 제2 코어로 결정할 수 있다. 또한, 코어 제어부는 제1 오픈 카운트 값이 임계값 미만이면, 제1 코어를 제2 코어로 결정할 수 있다. 제2 코어는 쓰기 동작 수행 시, 메모리 컨트롤러의 제어 하에, 제2 코어 자신이 제어하는 적어도 하나 이 상의 엠프티 존을 오픈 존으로 변경하고, 새롭게 변경된 오픈 존에 할당된 메모리 블록들에 쓰기 동작을 수행할 수 있다. 이와 같이, 본 발명의 실시 예에 따른 메모리 컨트롤러는 오픈 카운트 값들(OPEN_CNT)에 기초하여, 수신된 쓰기 요청(WT_REQ)에 대응하는 쓰기 동작이 수행될 코어를 변경함으로써, 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D)의 로드 레벨을 균등하게 관리할 수 있다. 도 5A 내지 도 5D는 본 발명의 일 실시 예에 따른 쓰기 동작을 수행하는 코어를 변경하는 동작을 설명하기 위한 도면이다. 구체적으로 도 5A는 본 발명의 일 실시 예에 따른 복수의 존들을 제어하는 복수의 코어들을 설명하기 위한 도면 이다. 도 5B는 본 발명의 일 실시 예에 따른 맵핑 테이블을 설명하기 위한 도면이다. 도 5C는 본 발명의 일 실 시 예에 따른 상태 정보를 설명하기 위한 도면이다. 도 5D는 본 발명의 일 실시 예에 따른 오픈 카운트 값을 설 명하기 위한 도면이다. 도 5A 내지 도 5D에 도시된 방법은 도 4에 도시된 메모리 컨트롤러에 의해 수행될 수 있다. 도 5A에 도시된 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D) 각각은 5개의 존들에 수행되는 쓰기 동작을 제어할 수 있다. CORE_A는 ZONE 1, ZONE 5, ZONE 9, ZONE 13 및 ZONE 17을 제어하고, CORE_B는 ZONE 2, ZONE 6, ZONE 10, ZONE 14 및 ZONE 18을 제어하고, CORE_C는 ZONE 3, ZONE 7, ZONE 11, ZONE 15 및 ZONE 19을 제어 하고, CORE_D는 ZONE 4, ZONE 8, ZONE 12, ZONE 16 및 ZONE 20을 제어할 수 있다. 본 발명의 실시 예에서, 코 어들의 개수 및 코어들 각각이 제어하는 존의 개수는 실시 예에 따라 달라질 수 있다. 도 5B에 도시된 맵핑 테이블은 존 식별정보(ZONE_ID)에 대응되는 존(ZONE) 및 존(ZONE)을 제어하는 코어(CORE) 사이의 매핑 관계를 포함할 수 있다. 도 5C에 도시된 상태 정보(STATE)는 복수의 존들(ZONE 1 내지 ZONE 20) 각각의 프로그램 상태를 나타낼 수 있다. 상태 정보(STATE)는 오픈 상태(OPEN), 클로즈드 상태(CLOSED), 엠프티 상태(EMPTY), 및 풀 상태(FULL)를 포함할 수 있다. ZONE 1, ZONE 2, ZONE 4, ZONE 5, ZONE 6, ZONE 8, ZONE 9, ZONE 10, ZONE 11 및 ZONE 14는 프로그램 동작의 수행이 결정된 오픈 상태일 수 있다. 오픈 상태는 프로그램 동작이 수행중이거나 프로그램 동 작의 곧 수행이 예정된 상태를 포함할 수 있다. ZONE 7은 프로그램 동작의 중단이 결정된 클로즈드 상태일 수 있다. ZONE 12, ZONE 13, ZONE 15, ZONE 16, ZONE 17, ZONE 18, ZONE 19 및 ZONE 20은 프로그램 동작의 수행이 결정되지 않은 엠프티 상태일 수 있으며, 엠프티 상태인 엠프티 존에 할당된 메모리 블록들은 데이터의 이레이 즈 상태일 수 있다. ZONE 3은 프로그램 동작이 완료된 풀 상태일 수 있다. 도 5D에 도시된 오픈 카운트 값(OPNE_CNT)은 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D) 각각이 제어하 는 오픈 존의 개수를 나타낼 수 있다. 오픈 카운트 값(OPNE_CNT)을 참조하면, CORE_A의 오픈 카운트 값 (OPNE_CNT)은 '3개'이고, CORE_B의 오픈 카운트 값(OPNE_CNT)은 '4개'이고, CORE_C의 오픈 카운트 값 (OPNE_CNT)은 '1개'이고, CORE_D의 오픈 카운트 값(OPNE_CNT)은 '2개'이다. 이는 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D) 각각이 제어하는 오픈 존의 개수가 각각, 3개, 4개, 1개, 2개임을 의미할 수 있다. 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D) 중에서, 오픈 카운트 값(OPNE_CNT)이 가장 높은 코어는 'CORE_B'이다. 즉, CORE_B는 가장 많은 개수의 오픈 존을 제어하고 있기 때문에, 프로그램 동작에 따른 로드 레 벨이 가장 높은 상태이다. 이때, CORE_B가 쓰기 요청에 따른 쓰기 동작을 수행한다면, CORE_B의 로드 레벨은 더 높아지게 된다. 이에, 메모리 컨트롤러는 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D)의 로드 레벨 이 균등하지 않다고 판단하여, 쓰기 요청에 따른 쓰기 동작을 CORE_B가 아닌 다른 코어가 수행하도록 복수의 코 어들을 제어할 수 있다. 이하, 도 5A 내지 도 5D를 참조하여, 본 발명의 일 실시 예에 따른 쓰기 동작을 수행하는 코어를 변경하는 동작 에 대해 자세히 설명하기로 한다. 예를 들어, 호스트로부터 존 식별정보(ZONE_ID)인 'LBA 18'와 함께, 쓰기 요청(WT_REQ)이 수신되면(도 5B 의 'REQUESTED BY WT_REQ'), 메모리 컨트롤러는 도 5B에 도시된 맵핑 테이블을 참조하여, 수신된 존 식별 정보(LBA 18)에 대응하는 존(ZONE 18)을 검출할 수 있다. 그리고 메모리 컨트롤러는 검출된 존(ZONE 18)을 제어하는 코어가 'CORE_B'임을 확인할 수 있다. 존(ZONE 18)은 호스트에 의해 쓰기 동작의 수행이 요청된 존이다(도 5A의 'REQUESTED BY WT_REQ'). 메모리 컨트롤 러는 존(ZONE 18)을 제어하는 CORE_B를 제1 코어로 결정할 수 있다. 본 발명의 실시 예에서 하나의 존이 하나의 논리 블록 주소(LBA)에 대응되는 저장 영역인 것으로 설명하지만, 본 발명은 이에 한정되지 않는다. 즉, 도 2에서 설명한 바와 같이, 하나의 존은 호스트로부터 입력되는 복 수의 논리 블록 어드레스들로 구성된 논리 블록 어드레스 그룹(LBA GROUP)에 대응되는 저장 영역일 수 있다. 메모리 컨트롤러는 도 5C에 도시되는 복수의 존들의 상태 정보(STATE)를 생성한다. 그리고 메모리 컨트롤 러는 생성된 상태 정보(STATE) 중에서, 오픈 상태(OPEN)를 갖는 존들의 개수를 코어별로 각각 합산하여 도 5D에 도시되는 복수의 오픈 카운트 값들(OPEN_CNT)을 생성할 수 있다. 즉, 도 5D에 도시되는 바와 같이, 메모리 컨트롤러는 복수의 코어들(CORE_A, CORE_B, CORE_C 및 CORE_D) 각각에 의해 제어되는 오픈 존의 개수를 나타내는 오픈 카운트 값들(OPEN_CNT)을 생성할 수 있다. 메모리 컨트롤러는 제1 코어(CORE_B)의 오픈 카운트 값(OPEN_CNT)인 '4개'를 제1 오픈 카운트 값으로 결정 하고, 제1 오픈 카운트 값에 기초하여 쓰기 요청(WT_REQ)에 대응하는 쓰기 동작을 수행할 제2 코어를 결정할 수 있다. 본 발명의 메모리 컨트롤러는 제1 오픈 카운트 값(4개)보다 적은 오픈 카운트 값(OPEN_CNT)을 갖는 코어인 'CORE_C' 또는 'CORE_D'를 제2 코어로 결정할 수 있다. 본 발명의 실시 예에 따른 메모리 컨트롤러는 제1 오픈 카운트 값(4개)이 복수의 오픈 카운트 값 (OPEN_CNT)들 중에서 최대이면, 최소 오픈 카운트 값을 갖는 코어를 제2 코어로 결정할 수 있다. 제1 코어 (CORE_B)의 제1 오픈 카운트 값(4개)이 복수의 오픈 카운트 값들(3개, 4개, 1개, 2개) 중에서 최대이기 때문에, 메모리 컨트롤러는 최소 오픈 카운트 값(1개)을 갖는 'CORE_C'를 제2 코어로 결정할 수 있다. 본 발명의 다른 실시 예에 따른 메모리 컨트롤러는 제1 코어(CORE_B)의 제1 오픈 카운트 값(4개)이 임계값 (예를 들면, 2.5개) 이상이면, 임계값 미만의 오픈 카운트 값(예를 들면, 1개)을 갖는 CORE_C를 제2 코어로 결 정할 수 있다. 제1 오픈 카운트 값 '4개'는 임계값 '2.5개'이상이기 때문에, 메모리 컨트롤러는 임계값 미만인 '1개'의 오픈 카운트 값(OPEN_CNT)을 갖는 'CORE_C'를 제2 코어로 결정할 수 있다. 물론 이때, 메모리 컨트롤러는 임계값 미만인 2개의 오픈 카운트 값(OPEN_CNT)을 갖는 'CORE_D'를 제2 코어로 결정할 수도 있다. 그후, 메모리 컨트롤러는 제2 코어(CORE_C)가 쓰기 동작을 수행하도록 제2 코어(CORE_C)를 제어할 수 있다. 메모리 컨트롤러는 쓰기 동작 수행 시, 제2 코어(CORE_C)가 제어하는 엠프티 존들 중에서, 어느 하 나인 'ZONE 15'을 오픈 존으로 변경하기 'ZONE 15'의 상태 정보(STATE)를 업데이트할 수 있다(도 5C의 CHANGING TO 'OPEN'). 그리고 메모리 컨트롤러는 새롭게 변경된 오픈 존인 'ZONE 15'에 할당된 메모리 블 록들에 쓰기 동작을 수행할 수 있다(도 5A의 PERFORMING WT OPERATION). 그리고 메모리 컨트롤러는 도 5B에 도시된 맵핑 테이블에서 호스트에 의해 쓰기 요청된 LBA 18에 대응되는 'ZONE 18'을 'ZONE 15'로 업데이트할 수 있다(도 5B의 CHANGING TO 'ZONE 15'). 그리고 메모리 컨트롤러 LBA 18에 대응되는 존을 제어하는 CORE를 'CORE_B'에서 'CORE_C'로 업데이트할 수 있다(도 5B의 CHANGING TO'CORE_C'). 도 6은 본 발명의 일 실시 예에 따른 메모리 컨트롤러의 동작 방법의 일 예를 나타낸 순서도이다. 도 6에 도시 된 방법은 예를 들어, 도 4에 도시된 메모리 컨트롤러에 의해 수행될 수 있다. 복수의 존들로 할당된 복수의 메모리 블록들을 포함하는 메모리 장치를 제어하고, 복수의 존들을 제어하는 복수 의 코어들을 포함하는 메모리 컨트롤러의 동작 방법은 다음의 S100 내지 S500의 동작들을 포함할 수 있다. 메모리 컨트롤러는 호스트로부터 쓰기 요청(WT_REQ)을 수신할 수 있다(S100). 메모리 컨트롤러는 쓰기 요청(WT_REQ)에 대응하는 존을 제어하는 제1 코어를 검출할 수 있다(S200). 메모 리 컨트롤러는 호스트로부터 수신되며 쓰기 요청(WT_REQ)과 관련된 존 식별정보에 기초하여, 쓰기 요 청(WT_REQ)에 대응하는 존을 검출할 수 있다. 존 식별정보는 논리 블록 어드레스(LBA)를 포함할 수 있다. 그리 고 메모리 컨트롤러는 검출된 존을 제어하는 코어를 제1 코어로 결정할 수 있다. 메모리 컨트롤러는 수신된 쓰기 요청(WT_REQ)에 응답하여, 복수의 코어들 각각에 의해 제어되는 오픈 존의 개수를 나타내는 오픈 카운트 값들(OPEN_CNT)을 생성할 수 있다(S300). 오픈 존은 프로그램 동작의 수행이 결정 된 존을 의미할 수 있다. S300의 오픈 카운트 값들(OPEN_CNT)을 생성하는 동작은 복수의 존들의 오픈 상태를 나 타내는 상태 정보(STATE)를 생성하는 동작; 및 상태 정보(STATE)에 기초하여, 복수의 오픈 카운트 값들 (OPEN_CNT)을 생성하는 동작;을 포함할 수 있다. 메모리 컨트롤러는 제1 코어의 제1 오픈 카운트 값(OPEN_CNT)에 기초하여, 쓰기 요청(WT_REQ)에 대응하는 쓰기 동작이 수행될 제2 코어를 결정할 수 있다(S400). 메모리 컨트롤러는 제1 오픈 카운트 값(OPEN_CNT) 보다 적은 오픈 카운트 값(OPEN_CNT)을 갖는 코어를 제2 코어로 결정할 수 있다. S400의 메모리 컨트롤러 가 제2 코어를 결정하는 동작에 대해서는 도 7A 및 도 7B를 참조하여 자세하게 설명하도록 한다. 메모리 컨트롤러는 호스트에 의해 쓰기 요청되고 로드 레벨이 높은 제1 코어가 아닌, 제1 코어보다 로드 레벨이 낮은 제2 코어가 쓰기 동작을 수행하도록 제2 코어를 제어할 수 있다(S500). 메모리 컨트롤러는 제 2 코어가 쓰기 동작 수행 시, 제2 코어 자신이 제어하는 엠프티 존을 오픈 존으로 변경하고, 새롭게 변경된 오 픈 존에 할당된 메모리 블록들에 쓰기 동작을 수행하도록 제2 코어를 제어할 수 있다. 도 7A 및 도 7B는 본 발명의 일 실시 예에 따른 메모리 컨트롤러가 제2 코어를 결정하는 동작의 순서도이다. 도 7A는 도 6의 동작 S400의 일 실시 예(S400A)를 설명하고, 도 7A는 도 6의 동작 S400의 다른 실시 예(S400B)를 설명한다. 그리고 도 7A 및 도 7B에서 설명되는 동작은 도 4에 도시된 메모리 컨트롤러에 의해 수행될 수 있다. 도 7A를 참조하면, 도 6의 S300 동작을 수행한 이후, 메모리 컨트롤러는 제1 오픈 카운트 값(OPEN_CNT)이 최대값을 갖는지 여부를 판단할 수 있다(S410). 제1 코어는 호스트에 의해 쓰기 동작의 수행이 요청된 존 을 제어하는 코어일 수 있다. 제1 오픈 카운트 값(OPEN_CNT)은 제1 코어가 제어하는 오픈 존의 개수일 수 있다. S410의 판단 결과, 제1 오픈 카운트 값(OPEN_CNT)이 복수의 오픈 카운트 값들(OPEN_CNT) 중에서 최대가 아니면, 메모리 컨트롤러는 코어를 변경하지 않고, 제1 코어를 제2 코어로 결정할 수 있다(S420). S410의 판단 결과, 제1 오픈 카운트 값(OPEN_CNT)이 복수의 오픈 카운트 값들(OPEN_CNT) 중에서 최대이면, 메모 리 컨트롤러는 최소 오픈 카운트 값(OPEN_CNT)을 갖는 코어를 제2 코어로 결정할 수 있다(S430). 이후, 메 모리 컨트롤러는 도 6의 동작 S500을 수행할 수 있다. 도 7B을 참조하면, 도 6의 S300 동작을 수행한 이후, 메모리 컨트롤러는 제1 오픈 카운트 값(OPEN_CNT)이 임계값 이상인지 여부를 판단할 수 있다(S415). 임계값은 복수의 코어들 각각이 제어하는 오픈 존의 개수의 평 균 값을 포함할 수 있다. 제1 코어는 호스트에 의해 쓰기 동작의 수행이 요청된 존을 제어하는 코어일 수 있다. 제1 오픈 카운트 값(OPEN_CNT)은 제1 코어가 제어하는 오픈 존의 개수일 수 있다. S415의 판단 결과, 제1 오픈 카운트 값(OPEN_CNT)이 임계값 이상이 아니면, 메모리 컨트롤러는 쓰기 동작 을 수행할 코어를 변경하지 않고, 제1 코어를 제2 코어로 결정할 수 있다(S425). S410의 판단 결과, 제1 오픈 카운트 값(OPEN_CNT)이 임계값 이상이면, 메모리 컨트롤러는 임계값 미만의 오픈 카운트 값(OPEN_CNT)을 갖는 코어를 제2 코어로 결정할 수 있다(S435). 이후, 메모리 컨트롤러는 도 6의 동작 S500을 수행할 수 있다. 이상 본 발명의 실시예에 따른 메모리 시스템 및 메모리 시스템의 동작 방법을 구체적인 실시 형태로서 설명하 였으나, 이는 예시에 불과한 것으로서 본 발명은 이에 한정되지 않는 것이며, 본 명세서에 개시된 기초 사상에 따르는 최광의 범위를 갖는 것으로 해석되어야 한다. 당업자는 개시된 실시 형태들을 조합, 치환하여 적시되지 않은 실시 형태를 실시할 수 있으나, 이 역시 본 발명의 권리범위를 벗어나지 않는 것이다. 이외에도 당업자는 본 명세서에 기초하여 개시된 실시형태를 용이하게 변경 또는 변형할 수 있으며, 이러한 변경 또는 변형도 본 발명의 권리범위에 속함은 명백하다."}
{"patent_id": "10-2021-0169587", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1A 내지 도 1C은 데이터 처리 시스템의 동작을 설명하기 위한 도면이다. 도 2는 본 발명의 존드 네임 스페이스를 활용한 데이터 처리 시스템의 데이터 저장 방법을 설명하기 위한 도면 이다. 도 3은 본 발명의 실시예에 따른 데이터 처리 시스템을 개략적으로 도시한 도면이다. 도 4는 본 발명의 실시 예에 따른 메모리 컨트롤러의 동작을 개략적으로 설명하기 위한 도면이다. 도 5A 내지 도 5D는 본 발명의 실시 예에 따른 메모리 컨트롤러가 쓰기 동작을 수행하는 코어를 변경하는 동작 의 예를 설명하기 위한 도면이다. 도 6은 본 발명의 실시 예에 따른 메모리 컨트롤러의 동작을 설명하기 위한 순서도이다. 도 7A 및 도 7B는 도 6에서 설명된 메모리 컨트롤러가 쓰기 동작을 수행하는 코어를 변경하는 동작의 예를 설명 하기 위한 순서도이다."}
