{"patent_id": "10-2024-7022331", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0112955", "출원번호": "10-2024-7022331", "발명의 명칭": "스토리지 클래스 메모리, 데이터 프로세싱 방법, 및 프로세서 시스템", "출원인": "후아웨이 테크놀러지 컴퍼니 리미티드", "발명자": "주 샤오밍"}}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "스토리지 클래스 메모리로서,상기 스토리지 클래스 메모리는 복수의 메모리 칩을 포함하고, 상기 복수의 메모리 칩은 적어도 하나의 그룹으로 분할되고, 상기 적어도 하나의 그룹 중 각각의 그룹은 제1-유형 메모리 칩 및 제2-유형 메모리 칩을 포함하고,상기 제2-유형 메모리 칩은 작동 에러 정정 코드(running error correction code)를 저장하도록 구성되고, 상기작동 에러 정정 코드는 동일한 그룹 내의 상기 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제1-레벨 메모리 에러 정정을 수행하기 위한 것이고,상기 제1-유형 메모리 칩은 데이터 및 재시도 에러 정정 코드를 저장하도록 구성되고, 상기 재시도 에러 정정코드는, 상기 제1-레벨 메모리 에러 정정이 실패할 때, 상기 제1-유형 메모리 칩 내에 저장되는 데이터에 대해제2-레벨 메모리 에러 정정을 수행하기 위한 것인, 스토리지 클래스 메모리."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서,상기 제1-유형 메모리 칩은 M개의 제1-유형 뱅크(bank) 및 N개의 제2-유형 뱅크를 포함하고, 상기 제1-유형 뱅크는 데이터를 저장하도록 구성되고, 상기 제2-유형 뱅크는 상기 재시도 에러 정정 코드를 저장하도록구성되는, 스토리지 클래스 메모리."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 제1-유형 뱅크의 단위 데이터 액세스량 및 상기 제2-유형 뱅크의 단위 데이터 액세스량 각각은 상기 제1-유형 메모리 칩의 비트 폭 내의 1개 비트(bit)의 단위 데이터 액세스량인, 스토리지 클래스 메모리."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항 내지 제3항 중 어느 한 항에 있어서,상기 제1-유형 메모리 칩은 제3-유형 뱅크를 더 포함하고, 상기 제3-유형 뱅크는 상기 제1-유형 메모리 칩의 뱅크 상에서 배드 블록 관리(bad block management)의 기능을 구현하도록 구성되는, 스토리지 클래스 메모리."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1항 내지 제4항 중 어느 한 항에 있어서,상기 스토리지 클래스 메모리의 비트 폭은 더블 데이터 레이트(DDR : double data rate) 프로토콜에 의해 지시되는 메모리 비트 폭을 충족시키는, 스토리지 클래스 메모리."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서,각각의 그룹 내의 제1-유형 메모리 칩의 수량 및 제2-유형 메모리 칩의 수량은 상기 제1-유형 메모리 칩의 비트폭, 상기 제2-유형 메모리 칩의 비트 폭, 및 상기 DDR 프로토콜에 의해 지시되는 메모리 비트 폭에 기초하여 결정되는, 스토리지 클래스 메모리."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,공개특허 10-2024-0112955-3-상기 DDR 프로토콜에 의해 지시되는 메모리 비트 폭은 80개 비트이고, 상기 제1-유형 메모리 칩의 비트 폭 및상기 제2-유형 메모리 칩의 비트 폭의 둘 모두는 8개 비트이고, 상기 스토리지 클래스 메모리 내에 포함되는 10개의 메모리 칩은 2개의 그룹으로 분할되고, 각각의 그룹은 4개의 제1-유형 메모리 칩 및 하나의 제2-유형 메모리 칩을 포함하고, 각각의 그룹 내에 포함되는 상기 4개의 제1-유형 메모리 칩 및 상기 제2-유형 메모리 칩의비트 폭의 합은 40개 비트이고, 각각의 비트의 단위 데이터 액세스량은 16개 바이트(byte) 또는 32개 바이트인,스토리지 클래스 메모리."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "데이터 프로세싱 방법으로서,상기 데이터 프로세싱 방법은 제어기에 의해 실행되고, 상기 제어기는 제1항 내지 제7항 중 어느 한 항에 따른적어도 하나의 스토리지 클래스 메모리 및 프로세서에 접속되고, 상기 데이터 프로세싱 방법은,상기 제어기에 의해, 상기 스토리지 클래스 메모리 내의 동일한 그룹 내의 제1-유형 메모리 칩 내에 저장되는데이터에 대해 제1-레벨 메모리 에러 정정을 수행하는 단계; 및상기 제1-레벨 메모리 에러 정정이 실패할 때, 상기 제어기에 의해, 각각의 제1-유형 메모리 칩의 데이터를 획득하고, 상기 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행하는 단계를 포함하는, 데이터 프로세싱 방법."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8항에 있어서,상기 제어기에 의해, 상기 스토리지 클래스 메모리 내의 동일한 그룹 내의 제1-유형 메모리 칩 내에 저장되는데이터에 대해 제1-레벨 메모리 에러 정정을 수행하는 단계는,상기 제어기에 의해, 해밍 코드(hamming code) 및 블록 코드(block code)를 이용함으로써, 상기 스토리지 클래스 메모리 내의 동일한 그룹 내의 상기 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제1-레벨 메모리 에러정정을 수행하는 단계를 포함하고,상기 제어기에 의해, 상기 제1-유형 메모리 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행하는 단계는,상기 제어기에 의해, 상기 블록 코드 또는 저밀도 패리티-검사 코드(low-density parity-check code)를 이용함으로써, 상기 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행하는 단계를포함하는, 데이터 프로세싱 방법."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제8항 또는 제9항에 있어서,상기 제어기에 의해, 상기 스토리지 클래스 메모리 내의 동일한 그룹 내의 제1-유형 메모리 칩 내에 저장되는데이터에 대해 제1-레벨 메모리 에러 정정을 수행하는 단계는,상기 제어기에 의해, 상기 스토리지 클래스 메모리 내의 동일한 그룹 내의 상기 제1-유형 메모리 칩 내에 저장되는 데이터의 128개 바이트 내지 512개 바이트중 단일 비트에 대해 제1-레벨 메모리 에러 정정을 수행하는 단계를 포함하고,상기 제어기에 의해, 상기 제1-유형 메모리 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행하는 단계는,상기 제어기에 의해, 상기 제1-유형 메모리 칩 내에 저장되는 데이터의 2048개 바이트 내지 4096개 바이트 중수백 개의 비트에 대해 제2-레벨 메모리 에러 정정을 수행하는 단계를 포함하는, 데이터 프로세싱 방법."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제8항 내지 제10항 중 어느 한 항에 있어서,상기 제어기에 의해, 상기 프로세서의 명령을 상기 스토리지 클래스 메모리의 명령으로 변환하고, 상기 스토리공개특허 10-2024-0112955-4-지 클래스 메모리의 명령을 상기 프로세서의 명령으로 변환하는 단계를 더 포함하는 데이터 프로세싱 방법."}
{"patent_id": "10-2024-7022331", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "프로세서 시스템으로서,상기 프로세서 시스템은 제어기, 제1항 내지 제7항 중 어느 한 항에 따른 적어도 하나의 스토리지 클래스 메모리, 및 프로세서를 포함하고, 상기 제어기는 상기 프로세서 및 상기 적어도 하나의 스토리지 클래스 메모리에별도로 접속되고, 상기 제어기는 제8항 내지 제11항 중 어느 한 항에 따른 데이터 프로세싱 방법의 동작 단계를수행하도록 구성되는, 프로세서 시스템."}
{"patent_id": "10-2024-7022331", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "스토리지 클래스 메모리, 데이터 프로세시 방법, 및 프로세서 시스템이 개시되고, 컴퓨터 분야에 관한 것이다. 스토리지 클래스 메모리 내에 포함되는 복수의 메모리 칩은 적어도 하나의 그룹으로 분할된다. 각각의 그룹은 제 1-유형 메모리 칩 및 제2-유형 메모리 칩을 포함한다. 제2-유형 메모리 칩은 작동 에러 정정 코드를 저장하도록 (뒷면에 계속)"}
{"patent_id": "10-2024-7022331", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "이 출원은 \"데이터 송신 방법 및 저장 장치(DATA TRANSMISSION METHOD AND STORAGE APPARATUS)\"라는 명칭으로 2021년 12월 13일자로 중국 특허청에 출원된 중국 특허 출원 제202111513788.2호, 및 \"스토리지 클래스 메모리, 데이터 프로세싱 방법, 및 프로세서 시스템(STORAGE CLASS MEMORY, DATA PROCESSING METHOD, AND PROCESSOR SYSTEM)\"이라는 명칭으로 2022년 1월 30일자로 중국 특허청에 출원된 중국 특허 출원 제202210114650.3호에 대 한 우선권을 주장하고, 이 중국 특허 출원들은 그 전체적으로 참조로 본 명세서에 통합된다. 이 출원은 컴퓨터 분야, 특히, 스토리지 클래스 메모리(storage class memory), 데이터 프로세싱 방법, 및 프로 세서 시스템에 관한 것이다."}
{"patent_id": "10-2024-7022331", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "스토리지 클래스 메모리(storage class memory, SCM)는 그 저장 용량, 액세스 속도, 및 비용이 주 메모리(예를 들어, 동적 랜덤 액세스 메모리(Dynamic Random Access Memory, DRAM))와 하드 디스크(예를 들어, NAND 플래시 (NAND flash)) 사이에 있는 새로운 유형의 저장 매체이다. 예를 들어, DRAM과 비교하면, SCM은 지속성 능력을 가지고, 전력 장애 후의 데이터 손실을 방지하고, 더 큰 저장 용량을 가진다. NAND 플래시와 비교하면, SCM은 더 고속의 액세스 속도를 가진다. 현재, SCM은 내장된 제어기에 기초하여 메모리 에러 정정(memory error correction)을 구현한다. 제어기 내의 저장 매체는 데이터를 캐싱(cache)할 수 있으므로, SCM의 액세스 레이턴시(access latency)가 불확실하고, SCM 은 더블 데이터 레이트(Double Data Rate, DDR) 프로토콜과 호환가능하지 않을 수 있고, SCM의 다용도성이 낮다. 그러므로, SCM이 DDR 프로토콜과 호환가능할 때, 어떻게 SCM의 신뢰성을 개선시키고 SCM의 액세스 레이턴 시를 최소화할 것인지는 현재 해결되어야 할 긴급한 문제이다. 이 출원은 스토리지 클래스 메모리, 데이터 프로세싱 방법, 및 프로세서 시스템을 제공하여, 이로써 SCM이 DDR 프로토콜과 호환가능할 때, SCM의 신뢰성이 개선될 수 있고, SCM의 액세스 레이턴시(access latency)가 최소화 될 수 있다. 제1 측면에 따르면, 스토리지 클래스 메모리가 제공된다. 스토리지 클래스 메모리 내에 포함되는 복수의 메모리 칩은 적어도 하나의 그룹으로 분할되고, 적어도 하나의 그룹 중 각각의 그룹은 제1-유형 메모리 칩 및 제2-유형 메모리 칩을 포함한다. 제2-유형 메모리 칩은 작동 에러 정정 코드(running error correction code)를 저장하도 록 구성되고, 제1-유형 메모리 칩은 데이터 및 재시도 에러 정정 코드(retry error correction code)를 저장하 도록 구성된다. 작동 에러 정정 코드는 동일한 그룹 내의 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제 1-레벨 메모리 에러 정정을 수행하기 위한 것이다. 재시도 에러 정정 코드는, 제1-레벨 메모리 에러 정정이 실 패할 때, 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행하기 위한 것이다. 이 경우에, 2-레벨 메모리 에러 정정 메커니즘은 스토리지 클래스 메모리 내에 저장되는 데이터의 높은 신뢰성 을 보장하고 액세스 레이턴시를 최소화하기 위하여 이용된다. 높은 액세스 레이턴시를 야기시키는 메모리 에러 정정을 수행하기 위하여 SCM의 내장된 제어기에 의해 이용되는 높은-복잡도 에러 정정 알고리즘과 대조적으로, 2-레벨 메모리 에러 정정 메커니즘이 이 출원의 이 실시예에서 이용된다. 스토리지 클래스 메모리의 에러 레이트(error rate)가 낮을 때, 스토리지 클래스 메모리 내에 저장되는 데이터의 높은 신뢰성은 제1-레벨 메모리 에 러 정정을 이용함으로써 보장될 수 있고, 액세스 레이턴시는 효과적으로 단축된다. 스토리지 클래스 메모리의 에러 레이트가 높을 때, 스토리지 클래스 메모리 내에 저장되는 데이터의 높은 신뢰성은 또한, 제2-레벨 메모리 에러 정정을 이용함으로써 보장될 수 있고, 액세스 레이턴시는 제1-레벨 메모리 에러 정정과 조합하여 단축된다. 추가적으로, 스토리지 클래스 메모리의 메모리 칩이 배열되어, 이로써 스토리지 클래스 메모리의 비 트 폭은 더블 데이터 레이트(Double Data Rate, DDR) 프로토콜에 의해 지시되는 메모리 비트 폭을 충족시킨다. 이 경우에, 스토리지 클래스 메모리는 DDR 프로토콜과 호환가능하고, 스토리지 클래스 메모리는 더 많은 유형의 프로세서(processor)에 접속될 수 있고, 스토리지 클래스 메모리의 다용도성이 개선된다. 각각의 그룹 내의 제1-유형 메모리 칩의 수량 및 제2-유형 메모리 칩의 수량은 제1-유형 메모리 칩의 비트 폭, 제2-유형 메모리 칩의 비트 폭, 및 DDR 프로토콜에 의해 지시되는 메모리 비트 폭에 기초하여 결정된다. 예를 들어, DDR 프로토콜에 의해 지시되는 메모리 비트 폭은 80개 비트(bit)이고, 제1-유형 메모리 칩의 비트 폭 및 제2-유형 메모리 칩의 비트 폭의 둘 모두는 8개 비트이고, 스토리지 클래스 메모리 내에 포함되는 10개의 메모리 칩은 2개의 그룹으로 분할된다. 각각의 그룹은 4개의 제1-유형 메모리 칩 및 하나의 제2-유형 메모리 칩 을 포함한다. 각각의 그룹 내에 포함되는 4개의 제1-유형 메모리 칩 및 제2-유형 메모리 칩의 비트 폭의 합은 40개 비트이고, 각각의 비트의 단위 데이터 액세스량은 16개 바이트(byte) 또는 32개 바이트이다. 가능한 구현예에서, 제1-유형 메모리 칩은 M개의 제1-유형 뱅크(bank) 및 N개의 제2-유형 뱅크를 포함한다. 제 1-유형 뱅크는 데이터를 저장하도록 구성된다. 제2-유형 뱅크는 재시도 에러 정정 코드를 저장하도록 구성된다. 그러므로, 메모리 제어기 또는 펌웨어(firmware, FW)는 상이한 시스템의 신뢰성 요건에 적응하기 위한 유연성을 개선시키기 위하여, 사용 시나리오에 기초하여 제1-유형 뱅크의 수량 및 제2-유형 뱅크의 수량에 대해 온라인 스위칭 또는 업그레이드를 수행할 수 있다. 또 다른 가능한 구현예에서, 제1-유형 뱅크의 단위 데이터 액세스량 및 제2-유형 뱅크의 단위 데이터 액세스량 각각은 제1-유형 메모리 칩의 비트 폭 내의 하나의 비트의 단위 데이터 액세스량이다. 그러므로, 스토리지 클래 스 메모리의 단위 데이터 액세스량은 스토리지 클래스 메모리에 접속되는 프로세서의 캐시 라인(cache line)의 길이를 충족시켜서, 스토리지 클래스 메모리의 다용도성이 개선된다. 또 다른 가능한 구현예에서, 제1-유형 메모리 칩은 제3-유형 뱅크를 더 포함한다. 제3-유형 뱅크는 제1-유형 메 모리 칩의 뱅크에 대해 배드 블록 관리(bad block management)의 기능을 구현하도록 구성된다. 그러므로, 스토 리지 클래스 메모리의 공간이 절약되고, 스토리지 클래스 메모리는 DDR 프로토콜을 충족시키는 (DRAM과 같은) 메모리와 더 용이하게 호환가능하고, 스토리지 클래스 메모리의 다용도성이 개선된다. 제2 측면에 따르면, 데이터 프로세싱 방법이 제공된다. 방법은 제어기에 의해 실행되고, 제어기는 제1 측면 또 는 제1 측면 중 임의의 가능한 측면에서의 스토리지 클래스 메모리 및 프로세서에 접속된다. 방법은 다음을 포 함한다: 제어기는 스토리지 클래스 메모리 내의 동일한 그룹 내의 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제1-레벨 메모리 에러 정정을 수행한다. 제1-레벨 메모리 에러 정정이 실패할 때, 제어기는 각각의 제1-유 형 메모리 칩을 획득하고, 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행 한다. 예를 들어, 제어기가 스토리지 클래스 메모리 내의 동일한 그룹 내의 제1-유형 메모리 칩 내에 저장되는 데이터 에 대해 제1-레벨 메모리 에러 정정을 수행하는 것은 다음을 포함한다: 제어기는 해밍 코드(hamming code) 또는 블록 코드(block code)를 이용함으로써, 스토리지 클래스 메모리 내의 동일한 그룹 내의 제1-유형 메모리 칩 내 에 저장되는 데이터에 대해 제1-레벨 메모리 에러 정정을 수행한다. 제어기는 스토리지 클래스 메모리 내의 동 일한 그룹 내의 제1-유형 메모리 칩 내에 저장되는 데이터의 128개 바이트 내지 512개 바이트 중 단일 비트에 대해 제1-레벨 메모리 에러 정정을 수행한다. 예를 들어, 제어기가 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행하는 것은 다음을 포함한다: 제어기는 블록 코드 또는 저밀도 패리티-검사 코드(low-density parity-check code)를 이용함으로써, 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행한다. 제어 기는 제1-유형 메모리 칩 내에 저장되는 데이터의 2048개 바이트 내지 4096개 바이트 중 수백 개의 비트에 대해 제2-레벨 메모리 에러 정정을 수행한다. 가능한 구현예에서, 방법은 다음을 더 포함한다: 제어기는 프로세서의 명령을 스토리지 클래스 메모리의 명령으 로 변환하고, 스토리지 클래스 메모리의 명령을 프로세서의 명령으로 변환한다. 그러므로, 프로세서는 스토리지클래스 메모리 상에서 판독/기입 동작을 수행한다. 제3 측면에 따르면, 프로세서 시스템이 제공된다. 프로세서 시스템은 제어기, 제1 측면 또는 제1 측면 중 임의 의 가능한 측면에서의 스토리지 클래스 메모리, 및 프로세서를 포함한다. 제어기는 프로세서 및 적어도 하나의 스토리지 클래스 메모리에 별도로 접속된다. 제어기는 제2 측면 또는 제2 측면 중 임의의 가능한 측면에서의 방 법의 동작 단계를 수행하도록 구성된다. 이 출원은 또한, 더 많은 구현예를 제공하기 위하여 상기한 측면에서 제공되는 구현예를 조합할 수 있다."}
{"patent_id": "10-2024-7022331", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "디지털 회로에서, 가장 작은 데이터 단위는 비트(bit)이고, 비트는 또한, 메모리(또는 주 메모리)의 가장 작은 데이터 단위이다. 1개 비트의 값은 \"0\" 또는 \"1\"이고, 8개의 연속 비트는 1개 바이트(byte)를 형성한다. 머신 언어에서, 바이트는 글자 또는 숫자를 나타낸다. 메모리 내에 저장되는 단일 비트의 값은 전기장, 자기장, 또는 심지어 우주선 간섭(cosmic ray interference)으로 인해 변경될 수 있다. 시스템 동작을 위하여 중요한 바이트 중 단일 비트의 값이 변경되는 경우에, 시스템 에러가 발생할 수 있어서, 시스템 고장(system breakdown) 또는 또 다른 오류로 귀착될 수 있다. 에러 정정 코드(Error Correcting Code, ECC)는 에러 검사 및 에러 정정을 구현할 수 있는 기술이다. 에러-정정 코드 메모리(Error-correcting code memory, ECC memory)는 ECC 기술이 적용되는 메모리이고, 다시 말해서, 에 러 검사 및 에러 정정을 구현할 수 있는 메모리이다. 에러-정정 코드 메모리는 서버 및 그래픽 워크스테이션에 서 폭넓게 이용되어, 이로써 컴퓨터 동작의 안정성 및 신뢰성이 개선될 수 있다. 이 출원의 실시예는 스토리지 클래스 메모리를 제공하고, 특히, 높은 신뢰성 및 낮은 레이턴시를 갖는 스토리지 클래스 메모리를 제공한다. 구체적으로 말하면, 2-레벨 메모리 에러 정정 메커니즘은 스토리지 클래스 메모리 내에 저장되는 데이터의 높은 신뢰성을 보장하고 액세스 레이턴시를 최소화하기 위하여 이용된다. 추가적으로, 스토리지 클래스 메모리의 메모리 칩이 배열되어, 이로써 스토리지 클래스 메모리의 비트 폭은 더블 데이터 레 이트(Double Data Rate, DDR) 프로토콜에 의해 지시되는 메모리 비트 폭을 충족시킨다. 이 경우에, 스토리지 클 래스 메모리는 DDR 프로토콜과 호환가능하고, 스토리지 클래스 메모리는 더 많은 유형의 프로세서(processor)에 접속될 수 있고, 스토리지 클래스 메모리의 다용도성이 개선된다. 이 출원의 실시예에서, 메모리 칩은 상변화 메모리(Phase Change Memory, PCM)일 수 있다. 상변화 메모리는 특 수한 재료(예를 들어, 칼코게나이드(chalcogenide))가 결정질 상태와 비정질 상태 사이에서 변환될 때에 나타나 는 전기적 전도율 차이를 이용함으로써 데이터를 저장하는 저장 장치이다. 메모리 비트 폭은 한 번에 메모리에 의해 송신될 수 있는 데이터의 양을 지칭한다. 더 큰 비트 폭은 한 번에 송신되어야 할 더 큰 데이터의 양을 지 시한다. 메모리 비트 폭은 또한, 데이터 비트 폭으로서 지칭될 수 있거나, 줄여서 비트 폭으로서 지칭될 수 있 다. 스토리지 클래스 메모리 내에 포함되는 복수의 메모리 칩은 적어도 하나의 그룹으로 분할된다. 적어도 하나의 그룹의 각각은 제1-유형 메모리 칩 및 제2-유형 메모리 칩을 포함한다. 적어도 하나의 그룹은 DDR의 적어도 하나의 채널(channel)을 지칭한다는 것이 이해될 수 있다. 각각의 그룹 내의 제1-유형 메모리 칩의 수량 및 제2- 유형 메모리 칩의 수량은 제1-유형 메모리 칩의 비트 폭, 제2-유형 메모리 칩의 비트 폭, 및 DDR 프로토콜에 의 해 지시되는 메모리 비트 폭에 기초하여 결정되어, 이로써 스토리지 클래스 메모리의 비트 폭은 DDR 프로토콜에 의해 지시되는 메모리 비트 폭을 충족시킨다. 제2-유형 메모리 칩은 작동 에러 정정 코드를 저장하도록 구성된다. 작동 에러 정정 코드는 동일한 그룹 내의 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제1-레벨 메모리 에러 정정을 수행하기 위한 것이다. 작동 에 러 정정 코드는 동일한 그룹에 속하는 제1-유형 메모리 칩 내에 저장되는 데이터에 기초하여 생성될 수 있다는 것이 이해되어야 한다. 제1-레벨 메모리 에러 정정은 동일한 그룹에 속하는 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 메모리 에러 정정을 수행하는 것을 지칭한다. 예를 들어, 1번째 그룹 내에 포함되는 제2-유형 메 모리 칩 내에 저장되는 작동 에러 정정 코드는 1번째 그룹 내에 포함되는 제1-유형 메모리 칩 내에 저장되는 데 이터에 기초하여 생성된다. 1번째 그룹 내에 포함되는 제2-유형 메모리 칩 내에 저장되는 작동 에러 정정 코드 는 1번째 그룹 내에 포함되는 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제1-레벨 메모리 에러 정정을 수행하기 위한 것이다. 제1-유형 메모리 칩은 데이터 및 재시도 에러 정정 코드를 저장하도록 구성된다. 재시도 에러 정정 코드는, 제 1-레벨 메모리 에러 정정이 실패할 때, 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행하기 위한 것이다. 재시도 에러 정정 코드는 제1-유형 메모리 칩 내에 저장되는 데이터에 기초하여 생성될 수 있다는 것이 이해되어야 한다. 제2-레벨 메모리 에러 정정은 각각의 제1-유형 메모리 칩 내에 저장되 는 데이터에 대해 메모리 에러 정정을 수행하는 것을 지칭한다. 예를 들어, 1번째 그룹 내에 포함되는 제1-유형 메모리 칩 내에 저장되는 재시도 에러 정정 코드는 동일한 제1-유형 메모리 칩 내에 저장되는 데이터에 기초하 여 생성된다. 1번째 그룹 내에 포함되는 제1-유형 메모리 칩 내에 저장되는 재시도 에러 정정 코드는 동일한 제 1-유형 메모리 칩 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수행하기 위한 것이다. 이 출원의 실시예에서, 작동 에러 정정 코드는 또한, 제1-레벨 정정 코드로서 지칭될 수 있고, 재시도 에러 정 정 코드는 또한, 제2-레벨 정정 코드로서 지칭될 수 있다. 일부 다른 실시예에서, 제1-유형 메모리 칩은 또한, 제1-유형 메모리 칩 상에서 배드 블록 관리의 기능을 구현 하도록 구성된다. 스토리지 클래스 메모리 상에서 배드 블록 관리를 구현하기 위한 메모리 칩을 배치하는 것과 비교하면, 제1-유형 메모리 칩에서 배드 블록 관리를 구현하기 위한 매체를 배치하는 것은 스토리지 클래스 메 모리의 공간을 절약하여, 이로써 스토리지 클래스 메모리는 DDR 프로토콜을 충족시키는 (DRAM과 같은) 메모리와 더 용이하게 호환가능하고, 스토리지 클래스 메모리의 다용도성이 개선된다. 스토리지 클래스 메모리는 클록 칩(clock chip)과 같은 또 다른 칩을 더 포함할 수 있다. 다음은 첨부 도면을 참조하여, 이 출원의 실시예에서 제공되는 스토리지 클래스 메모리를 상세하게 설명한다. 예를 들어, 스토리지 클래스 메모리는 메모리 비트 폭이 80개 비트(bit)인 DDR5와 호환가능하다. 도 1은 이 출 원의 실시예에 따른, 스토리지 클래스 메모리의 구조의 개략도이다. 스토리지 클래스 메모리는 10개의 메 모리 칩을 포함하고, 각각의 메모리 칩의 비트 폭은 8개 비트이다. 10개의 메모리 칩은 2개의 그룹으로 분할되고, 각각의 그룹은 5개의 메모리 칩을 포함하고, 각각의 그룹 내에 포함되는 5개의 메모리 칩의 비트 폭의 합은 40개 비트이다. 2개의 그룹 내에 포함되는 5개의 메모리 칩의 비트 폭의 합이 80개 비트인 경우에, 스토리지 클래스 메모리는 DDR5의 메모리 비트 폭과 호환가능하다. 10개의 메모리 칩 을 분할함으로써 획득되는 2개의 그룹은 DDR5의 2개의 서브-채널(sub-channel)을 지칭한다는 것이 이해될 수 있다. 이것은 DDR5의 듀얼-채널 표준과 호환가능하다. 각각의 서브-채널의 비트 폭은 40개 비트이다. 각각의 그룹은 4개의 제1-유형 메모리 칩 및 하나의 제2-유형 메모리 칩을 포함한다. 메모리 칩(11 0)의 비트 폭 내의 각각의 비트의 단위 데이터 액세스량은 16개 바이트 또는 32개 바이트이고, 다시 말해서, 스 토리지 클래스 메모리가 액세스될 때마다, 16B 또는 32B 데이터가 특정 레이턴시 후에 획득될 수 있다. 4개의 제1-유형 메모리 칩이 한 번에 액세스되는 경우에, 64B 데이터가 판독되거나 기입될 수 있다. 8개의 제1- 유형 메모리 칩이 한 번에 액세스되는 경우에, 128B 데이터가 판독되거나 기입될 수 있다. 64B 또는 128B 는 프로세서의 캐리 라인(cache line)의 길이이어서, 이로서 스토리지 클래스 메모리의 다용도성이 개선된다. 제2-유형 메모리 칩은 작동 에러 정정 코드를 저장하도록 구성된다. 제1-유형 메모리 칩은 데이터 및 재시도 에러 정정 코드를 저장하도록 구성된다. 작동 에러 정정 코드의 코드워드(codeword)의 길이는 그룹 내의 제1-유형 메모리 칩 및 제2-유형 메모리 칩에 의해 결정된다. 예를 들어, 4개의 제1-유형 메모리 칩이 한 번에 액세스되는 경우에, 64B 데이터가 판독되거나 기입될 수 있고, 작동 에러 정정 코드의 코드워 드의 길이는 64B+16B이다. 8개의 제1-유형 메모리 칩이 한 번에 액세스되는 경우에, 128B 데이터가 판독되 거나 기입될 수 있고, 작동 에러 정정 코드의 코드워드의 길이는 128B+32B이다. 재시도 에러 정정 코드의 코드 워드의 길이는 신뢰성 요건에 기초하여 재시도 에러 정정 코드에 의해 자율적으로 설정될 수 있다. 도 2에서 도시된 바와 같이, 스토리지 클래스 메모리는 계층구조의 내림차순으로 랭크(rank), 메모리 칩(chip), 뱅크(bank), 및 스토리지 셀(cell)로 물리적으로 분할될 수 있다는 것이 이해될 수 있다. 랭크는 스토리지 클래스 메모리 상에 배치되는 모든 메모리 칩을 포함한다. 각각의 메모 리 칩은 복수의 뱅크를 포함한다. 각각의 뱅크는 저장 셀을 포함한다. 각각의 저장 셀 은 행(row) 및 열(column)에 의해 결정된다. 일부 실시예에서, 재시도 에러 정정 코드를 저장하기 위하여 제1-유형 메모리 칩에 의해 이용되는 매체는 제1-유형 메모리 칩 내에 포함되는 복수의 뱅크 중 뱅크의 일부일 수 있다. 예를 들어, 제1-유 형 메모리 칩은 M개의 제1-유형 뱅크 및 N개의 제2-유형 뱅크를 포함한다. 제1-유형 뱅크 는 데이터를 저장하도록 구성된다. 제2-유형 뱅크는 재시도 에러 정정 코드를 저장하도록 구성된다. 실제 적인 애플리케이션 동안에, 제1-유형 뱅크의 수량 M 및 제2-유형 뱅크의 수량 N은 신뢰성 요건에 기 초하여 유연하게 구성될 수 있다. 신뢰성 요건이 낮고, 제2-레벨 메모리 에러 정정이 수행되는 데이터의 양이 작은 경우에, 더 적은 제2-유형 뱅크 및 더 많은 제1-유형 뱅크가 구성될 수 있다. 신뢰성 요건이 높 고, 제2-레벨 메모리 에러 정정이 수행되는 데이터의 양이 큰 경우에, 더 많은 제2-유형 뱅크가 구성될 수 있다. 메모리 제어기 또는 펌웨어(firmware, FW)는 상이한 시스템의 신뢰성 요건에 적응하기 위한 유연성을 개 선시키기 위하여, 사용 시나리오에 기초하여 온라인으로 제1-유형 뱅크의 수량 M 및 제2-유형 뱅크의 수량 N을 스위칭하거나 업그레이드할 수 있다. 예를 들어, 도 3에서 도시된 바와 같이, 제1-유형 메모리 칩은 독립적으로 동작될 수 있는 16개의 뱅크 를 포함한다. 1번째 뱅크 내지 14번째 뱅크는 제1-유형 뱅크로서 역할을 하고, 데이터를 저장하도록 구성된다. 15번째 뱅크는 제2-유형 뱅크로서 역할을 하고, 제2-레벨 메모리 에러 정정을 수행하도록 구성된다. 임의적으로, 제1-유형 메모리 칩 내의 16번째 뱅크는 제3-유형 뱅크로서 역할을 하고, 제1-유형 메모리 칩의 뱅크 상에서 배드 블록 관리의 기능을 구현하도록 구성된다. 1번 째 뱅크 내지 15번째 뱅크 중 한 뱅크가 오류가 있을 때, 스토리지 클래스 메모리의 오류를 회 피하기 위하여, 오류 있는 뱅크는 16번째 뱅크로 대체될 수 있다. 예를 들어, 1번째 뱅크 내지 15번째 뱅크 중 한 뱅크의 일부 어드레스가 손상될 때, 제어기는 16B의 대응하는 어드레스를 유보된 16번 째 뱅크로 리매핑(remap)하여, 이로써 배드 블록 관리의 기능이 구현될 수 있다. 뱅크가 한 번에 액세스될 때, 16B 또는 32B 데이터가 판독되거나 기입될 수 있다. 뱅크가 한 번에 액 세스될 때, 16B 데이터가 판독되거나 기입될 수 있는 것으로 가정되고, 재시도 에러 정정 코드의 코드워드의 길 이는 224B(16*14)+16B일 수 있다. 재시도 에러 정정 코드의 코드워드는 길기 때문에, 제2-레벨 메모리 에러 정 정의 에러 정정 능력이 또한 강력하다. 이것은 재시도 에러 정정 코드의 코드워드를 구성하기 위한 방식 중의 오직 하나의 방식이다. 일부 다른 실시예에서, 재시도 에러 정정 코드의 코드워드는 대안적으로, 복수의 제1-유 형 뱅크 중 제1-유형 뱅크의 일부 내에 저장되는 데이터를 이용함으로써 구성될 수 있다. 제2-레벨 메모리 에러 정정 동안에, 에러 검사 및 에러 정정은 제1-유형 메모리 칩 내에 포함되는 뱅크 상에서 주기적으로 수행된다. 예를 들어, 도 4에서 도시된 바와 같이, 제1-레벨 메모리 에러 정정이 수행되는 데이터, 및 제2-레벨 메모리 에 러 정정이 수행되는 데이터는 2-차원 행렬을 형성할 수 있다. x 차원은 4개의 제1-유형 메모리 칩 및 하나 의 제2-유형 메모리 칩을 나타내고, y 차원은 메모리 칩의 가장 작은 액세스 단위 16B의 어드레스를 나타 낸다. 4개의 제1-유형 메모리 칩은 데이터 및 재시도 에러 정정 코드를 저장하고, 제2-유형 메모리 칩 은 작동 에러 정정 코드를 저장한다. 각각의 행은 작동 에러 정정 코드의 64B+16B 코드워드를 형성한다. 전체적인 2-차원 행렬은 재시도 에러 정정 코드의 512B+208B 코드워드를 형성한다. 임의의 행 내의 작동 에러 정정 코드의 코드워드의 디코딩이 실패한 후에, 시스템은 제2-레벨 메모리 에러 정정을 수행하기 위하여 2-차원 행렬의 데이터를 판독하고, 다시 말해서, 각각의 열 내의 데이터에 대해 제2-레벨 메모리 에러 정정을 수행한다. 시스템은 시스템의 에러 정정 레이트를 효과적으로 감소시키기 위하여, 수평 디코딩 및 수직 디코딩 을 병렬로 수행할 수 있다. 일부 실시예에서, 2-차원 행렬 내의 각각의 열 내의 제1-유형 메모리 칩의 데이터는 1번째 뱅크 내지 14번째 뱅크 중 임의의 8개의 뱅크의 데이터일 수 있고, 8개의 뱅크는 연속적일 수 있다. 예를 들어, 1번째 열 내의 제1-유형 메모리 칩의 데이터는 1번째 뱅크 내지 8번째 뱅크의 데이터일 수 있고, 1번째 열 내의 제1-유형 메모리 칩 내에 저장되는 재시도 에러 정정 코드는 1번째 뱅크 내 지 8번째 뱅크의 데이터에 기초하여 생성된다. 1번째 열 내의 제1-유형 메모리 칩 내에 저장되는 재 시도 에러 정정 코드는 1번째 뱅크 내지 8번째 뱅크의 데이터에 대해 메모리 에러 정정을 수행하기 위한 것이다. 또 다른 예를 들어, 2번째 열 내의 제1-유형 메모리 칩의 데이터는 3번째 뱅크 내지 10번째 뱅크 의 데이터일 수 있고, 2번째 열 내의 제1-유형 메모리 칩 내에 저장되는 재시도 에러 정정 코드는 3 번째 뱅크 내지 10번째 뱅크의 데이터에 기초하여 생성된다. 2번째 열 내의 제1-유형 메모리 칩 내에 저장되는 재시도 에러 정정 코드는 3번째 뱅크 내지 10번째 뱅크의 데이터에 대해 메모리 에러 정정을 수행하기 위한 것이다. 추가적으로, 재시도 에러 정정 코드를 생성하기 위한 제1-유형 메모리 칩의 데이터는 신뢰성 요건에 기초 하여 선택된다. 다시 말해서, 신뢰성 요건이 높은 경우에, 2-차원 행렬 내의 각각의 열은 더 많은 뱅크의 데이터를 포함한다. 신뢰성 요건이 낮은 경우에, 2-차원 행렬 내의 각각의 열은 더 적은 뱅크의 데이터를 포함한다. 제1-유형 메모리 칩 내의 제2-유형 뱅크는 상이한 제1-유형 뱅크에 의해 생성되는 재 시도 에러 정정 코드를 저장할 수 있다. 예를 들어, 1번째 열 내의 제1-유형 메모리 칩 내의 제2-유형 뱅 크는 1번째 뱅크 내지 8번째 뱅크의 데이터에 기초하여 생성되는 재시도 에러 정정 코드, 및 3 번째 뱅크 내지 10번째 뱅크의 데이터에 기초하여 생성되는 재시도 에러 정정 코드를 저장할 수 있어 서, 이로써 제어기는 상이한 제1-유형 뱅크의 데이터에 대해 메모리 에러 정정을 수행한다. 이 출원의 실시예에서 제공되는 제1-레벨 메모리 에러 정정 및 제2-레벨 메모리 에러 정정을 위하여 이용되는 에러 정정 알고리즘은 패리티-검사 코드, 해밍 코드(hamming code), 블록 코드, 또는 에러 정정 코드 중의 임의 의 하나를 포함한다. 제1-레벨 메모리 에러 정정을 위하여 이용되는 에러 정정 알고리즘, 및 제2-레벨 메모리 에러 정정을 위하여 이용되는 에러 정정 알고리즘은 동일하거나 상이할 수 있다. 이것은 제한되지 않는다. 예에서, DDR5의 에러 정정 방식은 제1-레벨 메모리 에러 정정에서 재이용될 수 있다. 예를 들어, 해밍 코드 또 는 블록 코드는 제1-레벨 메모리 에러 정정에서 이용될 수 있다. DDR5의 메모리 에러 정정 방식은 낮은 레이턴 시, 및 스토리지 클래스 메모리의 대부분의 에러 시나리오를 커버할 수 있는 에러 정정 능력을 가진다. 그러므 로, 스토리지 클래스 메모리의 에러 레이트가 낮을 때, 액세스 레이턴시는 스토리지 클래스 메모리 내에 저장되 는 데이터의 높은 신뢰성의 조건 하에서 효과적으로 감소될 수 있다. 제1-레벨 메모리 에러 정정이 수행될 수 없거나 실패할 때, 제2-레벨 메모리 에러 정정은 단일의 또는 복수의 제1-유형 메모리 칩 내의 재시도 에러 정정 코드를 이용함으로써 수행될 수 있다. 예를 들어, 블록 코드 또는 저밀도 패리티-검사 코드는 제2-레벨 메모리 에러 정정에서 이용될 수 있다. 스토리지 클래스 메모리의 에 러 레이트가 높을 때, 제2-레벨 메모리 에러 정정은 스토리지 클래스 메모리의 에러 레이트를 효과적으로 감소 시킬 수 있고, 스토리지 클래스 메모리 내에 저장되는 데이터의 높은 신뢰성을 보장할 수 있고, 스토리지 클래 스 메모리의 서비스 수명을 연장할 수 있다. 상기한 예에서, 제1-레벨 메모리 에러 정정은 제1-유형 메모리 칩 사이에서 설정되고, 다시 말해서, 작동 에러 정정 코드의 코드워드는 동일한 그룹(채널)에 속하는 제1-유형 메모리 칩의 데이터를 이용함으로써 구성되고, 제2-레벨 메모리 에러 정정은 제1-유형 메모리 칩에서 설정되고, 다시 말해서, 재시도 에러 정 정 코드의 코드워드는 제1-유형 메모리 칩의 데이터를 이용함으로써 구성된다. 실제적인 애플리케이션 동 안에, 스토리지 클래스 메모리의 2-레벨 메모리 에러 정정은 대안적으로, 또 다른 방식으로 설정될 수 있다. 상기한 실시예는 메모리 칩의 비트 폭이 8개 비트인 예를 이용함으로써 설명된다. 또 다른 실시예에서, 스토리 지 클래스 메모리에 의해 이용되는 메모리 칩의 비트 폭은 대안적으로, 4개 비트일 수 있다. 예를 들어, 도 5에서 도시된 바와 같이, 스토리지 클래스 메모리는 20개의 메모리 칩을 포함하고, 각 각의 메모리 칩의 비트 폭은 4개 비트이다. 20개의 메모리 칩은 4개의 그룹으로 분할되고, 각각의 그 룹은 5개의 메모리 칩을 포함하고, 각각의 그룹 내에 포함되는 5개의 메모리 칩의 비트 폭의 합은 20 개 비트이다. 4개의 그룹 내에 포함되는 20개의 메모리 칩의 비트 폭의 합이 80개 비트인 경우에, 스토리 지 클래스 메모리는 DDR5의 메모리 비트 폭과 호환가능하다. 각각의 그룹은 4개의 제1-유형 메모리 칩 및 하나의 제2-유형 메모리 칩을 포함한다.임의적으로, 도 6에서 도시된 바와 같이, 스토리지 클래스 메모리 내에 포함되는 20개의 메모리 칩은 대안적으로, 2개의 그룹으로 분할될 수 있고, 각각의 그룹은 10개의 메모리 칩을 포함하고, 각각의 그룹 내에 포함되는 10개의 메모리 칩의 비트 폭의 합은 40개 비트이다. 2개의 그룹 내에 포함되는 20개의 메모 리 칩의 비트 폭의 합이 80개 비트인 경우에, 스토리지 클래스 메모리는 DDR5의 메모리 비트 폭과 호 환가능하다. 각각의 그룹은 9개의 제1-유형 메모리 칩 및 하나의 제2-유형 메모리 칩을 포함한다. 제1-유형 메모리 칩 및 하나의 제2-유형 메모리 칩의 상세한 설명에 대해서는, 제1-유형 메모리 칩 및 하나의 제2-유형 메모리 칩의 상기한 설명을 참조한다. 스토리지 클래스 메모리가 주 메모리로서 이용될 때, 스토리지 클래스 메모리는 듀얼-인라인-메모리-모듈(Dual- Inline-Memory-Module, DIMM) 인터페이스를 이용함으로써 컴퓨터 디바이스 상에서 배치될 수 있어서, 이로써 컴 퓨터 디바이스의 프로세서는 스토리지 클래스 메모리 상에서 판독/기입 동작을 수행한다. 컴퓨터 디바이스는 독 립적인 서버, 또는 컴퓨팅 클러스터 내의 컴퓨팅 디바이스일 수 있다. 제어기는 또한, 스토리지 클래스 메모리와 프로세서 사이에 배치될 필요가 있다. 제어기는 명령 변환, 메모리 에러 정정, 배드 블록 관리, 및 어드레스 매핑과 같은 기능을 구현하도록 구성된다. 스토리지 클래스 메모리의 내장된 제어기가 메모리 에러 정정을 구현하고, 제어기에 접속되는 DRAM이 데이터를 캐싱하여, SCM의 액세스 레 이턴시의 불확실성을 야기시키는 해결책과 비교하면, 이 출원의 실시예에서 제공되는 스토리지 클래스 메모리는 내장된 제어기 및 DRAM을 필요로 하지 않는다. 스토리지 클래스 메모리에 접속되는 프로세서 내에 통합되는 메 모리 제어기가 스토리지 클래스 메모리를 제어하기 위하여 이용되거나, 또 다른 외부 제어기가 프로세서와 스토 리지 클래스 메모리 사이에 접속되어, 스토리지 클래스 메모리가 제어되고, 스토리지 클래스 메모리를 액세스하 는 결정론적 레이턴시가 보장되고, DDR 프로토콜과 호환가능하게 된다. 도 7은 이 출원의 실시예에 따른, 프로세서 시스템의 개략도이다. 프로세서 시스템은 제어기, 스토리 지 클래스 메모리, 및 프로세서를 포함한다. 프로세서 시스템은 컴퓨터 디바이스, 서버, 컴퓨팅 클러스터 내의 컴퓨팅 디바이스 등일 수 있다. 프로세서는 프로세서 시스템의 컴퓨팅 코어 및 제어 코어이다. 프로세서는 초고밀도 집적 회로 (very large scale integrated circuit)일 수 있다. 오퍼레이팅 시스템 및 또 다른 소프트웨어 프로그램 은 프로세서 내에 배치되어, 프로세서가 스토리지 클래스 메모리 및 다양한 주변 컴포넌트 상호 접속 익스프레스(Peripheral Component Interconnect Express, PCIe) 디바이스를 액세스하는 것이 가능하게 된 다. 프로세서는 하나 이상의 프로세서 코어(core)를 포함한다. 프로세서 내의 프로세서 코어 는 예를 들어, 중앙 프로세싱 유닛(Central Processing unit, CPU) 또는 또 다른 애플리케이션-특정 집적 회로(Application-Specific Integrated Circuit, ASIC)이다. 프로세서는 대안적으로, 또 다른 범용 프로 세서, 디지털 신호 프로세서(digital signal processor, DSP), 애플리케이션 특정 집적 회로(application specific integrated circuit, ASIC), 필드 프로그래밍가능 게이트 어레이(field programmable gate array, FPGA) 또는 또 다른 프로그래밍가능 로직 디바이스, 개별 게이트 또는 트랜지스터 로직 디바이스, 개별 하드웨 어 컴포넌트 등일 수 있다. 실제적인 애플리케이션 동안에, 프로세서 시스템은 복수의 프로세서를 더 포함 할 수 있다. 이 출원의 이 실시예에서, 프로세서는 데이터를 스토리지 클래스 메모리로 기입하거나 스토리지 클래 스 메모리로부터 데이터를 판독하도록 구성된다. 스토리지 클래스 메모리는 프로세서 시스템의 주 메모리일 수 있다. 스토리지 클래스 메모리는 통상적으로, 오퍼레이팅 시스템에서 작동하고 있는 다양한 유형의 소프트웨어, 입력 및 출력 데이터, 외부 메모리와 교환되는 정보 등을 저장하도록 구성된다. 프로세서의 액세스 속도를 증가시키기 위하여, 스토리 지 클래스 메모리는 높은 액세스 속도의 장점을 가질 필요가 있다. 프로세서는 제어기를 이용함 으로써 고속으로 스토리지 클래스 메모리를 액세스할 수 있고, 스토리지 클래스 메모리 내의 임의의 스토리지 셀에 대해 판독 동작 및 기입 동작을 수행할 수 있다. 제어기는, 프로세서 시스템의 내부의 스토리지 클래스 메모리를 제어하며, 스토리지 클래스 메 모리로부터 프로세서 코어로의 데이터 송신을 관리하고 계획하도록 구성되는 버스 회로 제어기이다. 제어기를 이용함으로써, 데이터는 스토리지 클래스 메모리와 프로세서 코어 사이에서 교환될 수 있다. 제어기는 프로세서 내로 통합될 수 있거나, 노스브릿지(northbridge) 내에 구축될 수 있거나, 독립적 인 메모리 제어기 칩일 수 있다. 제어기는 별도의 칩일 수 있고, 시스템 버스를 통해 프로세서 코어 에 접속된다. 예를 들어, 도 7에서 도시된 프로세서 시스템과의 차이는, 도 8에서 도시된 바와 같이, 제어기 가 스토리지 클래스 메모리와 프로세서 사이에 접속되는 외부 제어기일 수 있다는 것에 있다. 외부 제어기는 중앙집중화된 제어기일 수 있고, 제어기는 복수의 스토리지 클래스 메모리에 접속될 수 있 어서, 이로써 프로세서 시스템의 주 메모리의 저장 용량이 확대될 수 있고, 스토리지 클래스 메모리는 제어기의 비용을 감소시키기 위하여, DDR 프로토콜과 더 용이하게 호환가능할 수 있다. 메모리 제어기의 특정 위치 및 존재 형태는 이 출원의 이 실시예에서 제한되지 않는다. 실제적인 애플리케이션 동안에, 제어기는 데이터를 스토리지 클래스 메모리로 기입하거나 스토리지 클래스 메모리로부 터 데이터를 판독하기 위하여 필요한 로직을 제어할 수 있다. 제어기는 범용 프로세서, 전용 가속기, GPU, FPGA, 또는 임베디드 프로세서(embedded processor)와 같은 프로세서 시스템 내의 메모리 제어기일 수 있다. 프로세서 시스템은 다양한 입력/출력(Input/Output, I/O) 디바이스를 더 포함한다. I/O 디바이스 는 데이터 송신을 위한 하드웨어이거나, I/O 인터페이스에 접속되는 디바이스로서 이해될 수 있다. 보편적 인 I/O 디바이스는 네트워크 어댑터, 프린터, 키보드, 마우스 등을 포함한다. 하드 디스크, 플로피 디스크, 및 광학 디스크와 같은 모든 외부 메모리는 또한, I/O 디바이스로서 이용될 수 있다. 프로세서, 스토리지 클래스 메모리, 제어기, 및 I/O 디바이스는 버스를 통해 접속된 다. 버스는 상기한 컴포넌트(예를 들어, 프로세서 및 스토리지 클래스 메모리) 사이에서 정보를 송신하기 위한 경로를 포함할 수 있다. 데이터 버스에 추가적으로, 버스는 전력 버스, 제어 버스, 스테이 터스 신호 버스 등을 더 포함할 수 있다. 그러나, 설명의 명확함을 위하여, 다양한 버스는 도면에서 버스 로서 표기된다. 버스는 PCIe 버스, 확장된 산업 표준 아키텍처(extended industry standard architecture, EISA) 버스, 통합된 버스(unified bus, Ubus 또는 UB), 컴퓨트 익스프레스 링크(compute express link, CXL) 버스, 가속기를 위한 캐시 일관성 상호접속(cache coherent interconnect for accelerators, CCIX) 버스 등일 수 있다. 예를 들어, 프로세서는 PCIe 버스를 통해 이 I/O 디바이스(74 0)를 액세스할 수 있다. 프로세서는 더블 레이트(double data rate, DDR) 버스를 통해 스토리지 클래스 메 모리에 접속된다. 여기서, 상이한 스토리지 클래스 메모리는 상이한 데이터 버스를 통해 프로세서 와 통신할 수 있다. 그러므로, DDR 버스는 또 다른 유형의 버스로 대체될 수 있다. 버스의 유형은 이 출원 의 이 실시예에서 제한되지 않는다. 프로세서 시스템은 DPU를 더 포함하고, DPU는 PCIe 버스를 통해 프로세서에 접속될 수 있 다. DPU는, 인공지능 및 저장에 관련되며 프로세서 시스템의 또 다른 칩(예를 들어, 프로세서) 에 의해 작동되는 애플리케이션을 오프로딩(offload)하여, 프로세서 시스템의 데이터 프로세싱 성능을 개 선시키고, 프로세서 시스템의 부하를 감소시킨다. 프로세서 시스템은 또 다른 전용 프로세서를 더 포 함할 수 있다. 전용 프로세서는 특정 애플리케이션 또는 필드를 위한 프로세서, 예를 들어, 그래픽 데이터를 프 로세싱하도록 구성되는 그래픽 프로세싱 유닛(graphics processing unit, GPU), 또는 신호를 프로세싱하도록 구 성되는 DSP이다. 프로세서 시스템은 호스트(host)로서 지칭될 수 있다는 것이 주목되어야 한다. 도 7은 단지 개략도이다. 프로세서 시스템은 또 다른 컴포넌트를 더 포함할 수 있고, 예를 들어, 하드 디스크, 광학 드라이브, 전력 공급부, 샤시(chassis), 열 방산(heat dissipation) 시스템, 및 도 7에서 도시되지 않은 또 다른 입력/출력 제 어기 및 인터페이스를 더 포함할 수 있다. 프로세서 시스템 내에 포함되는 프로세서, 스토리지 클래스 메 모리, 및 제어기의 수량은 이 출원의 이 실시예에서 제한되지 않는다. 다음으로, 도 9는 이 출원의 실시예에 따른, 데이터 프로세싱 방법의 개략도이다. 도 7에서 도시된 구조는 설명 을 위한 예로서 이용된다. 프로세서는 데이터를 스토리지 클래스 메모리로 기입하거나 스토리지 클래 스 메모리로부터 데이터를 판독하는 것으로 가정된다. 이 출원의 이 실시예에서 제공되는 데이터 프로세싱 방법은 다음의 단계를 포함한다. 일부 실시예에서, 프로세서가 데이터를 스토리지 클래스 메모리로 기입할 때, S910 내지 S930이 수행 된다. S910: 제어기는 명령 변환을 수행하고, 다시 말해서, 제어기는 프로세서의 기입 명령을, 스토리 지 클래스 메모리에 의해 인식될 수 있는 기입 명령으로 변환한다. S920: 제어기는 기입 대상 데이터에 기초하여 작동 에러 정정 코드 및 재시도 에러 정정 코드를 생성한다. 제어기는 기입 대상 데이터가 스토리지 클래스 메모리 내의 제1-유형 메모리 칩 내로 기입되는 위치 를 결정한다. 예를 들어, 제어기는 어드레스 매핑을 수행하고, 다시 말해서, 논리적 블록 어드레스를 물리 적 블록 어드레스로 변환한다. 논리적 블록 어드레스(Logic Block Address, LBA)는 저장 디바이스 상의 데이터 가 위치되는 블록의 가상적 어드레스를 설명하고, 일반적으로, 하드 디스크와 같은 보조 메모리 디바이스에서 이용된다. LBA는 데이터 블록의 어드레스, 또는 어드레스가 가리키는 데이터 블록을 지칭할 수 있다. 물리적 블 록 어드레스(Physical Block Address, PBA)는 저장 디바이스 상의 데이터가 위치되는 블록의 물리적 어드레스를 설명한다. LBA와 PBA 사이에는 일대일 매핑 관계가 있고, 매핑 관계는 통상적으로, 주 메모리 내에 저장된다. 이 출원의 이 실시예에서, LBA와 PBA 사이의 매핑 관계는 스토리지 클래스 메모리 내에 저장될 수 있다. 기입 대상 데이터를 스토리지 클래스 메모리로 기입하도록 결정할 때, 제어기는 먼저, 논리적 블록 어드레 스를 결정하고, 그 다음으로, 물리적 블록 어드레스에 기초하여 기입 대상 데이터를 스토리지 클래스 메모리 로 기입하기 위하여, 논리적 블록 어드레스, 및 LBA와 PBA 사이의 매핑 관계에 기초하여, 스토리지 클래스 메모리의 물리적 블록 어드레스를 결정한다. 추가로, 제어기는, 기입 대상 데이터 내에 있으며 동일한 그룹 내의 제1-유형 메모리 칩 내로 기입되는 데 이터를 이용함으로써, 에러 정정 알고리즘(예를 들어, 해밍 코드 또는 블록 코드)에 기초하여 작동 에러 정정 코드를 생성하고, 동일한 그룹 내의 제1-유형 메모리 칩 내로 기입되는 데이터를 이용함으로써, 에러 정정 알고 리즘(예를 들어, 블록 코드 또는 저밀도 패리티-검사 코드)에 기초하여 재시도 에러 정정 코드를 생성한다. S930: 제어기는 작동 에러 정정 코드, 재시도 에러 정정 코드, 및 기입 대상 데이터를 스토리지 클래스 메 모리 내로 기입한다. 제어기는 기입 대상 데이터를 제1-유형 메모리 칩의 결정된 위치로 기입하고, 작동 에러 정정 코드를 제2- 유형 메모리 칩으로 기입하고, 재시도 에러 정정 코드를 제1-유형 메모리 칩의 제2-유형 뱅크로 기입한다. 일부 다른 실시예에서, 프로세서가 스토리지 클래스 메모리로부터 데이터를 판독할 때, S940 내지 S970이 수행된다. S940: 제어기는 명령 변환을 수행하고, 다시 말해서, 제어기는 프로세서의 판독 명령을, 스토리 지 클래스 메모리에 의해 인식될 수 있는 판독 명령으로 변환한다. S950: 제어기는 스토리지 클래스 메모리로부터 데이터, 작동 에러 정정 코드, 및 재시도 에러 정정 코드를 판독한다. 제어기는 스토리지 클래스 메모리 내의 데이터의 저장 위치를 결정하고, 구체적으로 말하면, 먼저, 논리적 블록 어드레스를 결정하고, 그 다음으로, 물리적 블록 어드레스에 기초하여 스토리지 클래스 메모리 로부터 데이터를 판독하기 위하여, 논리적 블록 어드레스, 및 LBA와 PBA 사이의 매핑 관계에 기초하여, 스 토리지 클래스 메모리의 물리적 블록 어드레스를 결정한다. S960: 제어기는 판독된 데이터에 대해 제1-레벨 메모리 에러 정정을 수행하고, 다시 말해서, 작동 에러 정 정 코드를 이용함으로써 판독된 데이터를 검사한다. 일부 실시예에서, 제어기는 데이터의 저장 위치를 결정하고, 데이터를 판독하고, 저장 위치에 기초하여 에 러 정정 코드를 작동시킨다. 제어기는 에러 정정 알고리즘(예를 들어, 해밍 코드 또는 블록 코드)에 기초 하여 판독된 데이터를 이용함으로써 임시 작동 에러 정정 코드를 생성하고, 임시 작동 에러 정정 코드를 작동 에러 정정 코드와 비교한다. 임시 작동 에러 정정 코드 및 작동 에러 정정 코드가 동일한 경우에, 그것은 판독 된 데이터가 올바르다는 것을 지시한다. 임시 작동 에러 정정 코드 및 작동 에러 정정 코드가 상이한 경우에, 그것은 판독된 데이터 내에 에러가 있다는 것을 지시한다. 판독된 데이터가 저장된 데이터와 정합하지 않는 경 우에, 에러가 있는 비트를 결정하고, 그 다음으로, 에러가 있는 비트를 정정하기 위하여, 판독된 데이터는 패리 티-검사 비트를 이용함으로써 복호화될 수 있다. 임의적으로, 제1-레벨 메모리 에러 정정이 실패한 경우에, S970이 수행된다. 제어기는 제2-레벨 메모리 에 러 정정을 수행하고, 다시 말해서, 재시도 에러 정정 코드를 이용함으로써 제1-유형 메모리 칩의 데이터를 검사 한다. 예를 들어, 제어기는 블록 코드 또는 저밀도 패리티-검사 코드를 이용함으로써, 그리고 재시도 에러 정정 코드를 이용함으로써, 제1-유형 메모리 칩 내에 저장되는 데이터에 대해 제2-레벨 메모리 에러 정정을 수 행한다. 데이터 프로세싱 프로세스에서, 제어기는 각각의 비트의 메모리 에러를 검사하고 정정하기 위하여, 알고리 즘(예를 들어, 해밍 코드) 알고리즘을 이용함으로써 데이터를 계속적으로 스캐닝할 수 있다. 제어기가 데이터를 스토리지 클래스 메모리로 기입하는 위치, 및 제어기가 스토리지 클래스 메 모리로부터 데이터를 판독하는 위치를 결정하기 위한 방법은 이 출원의 이 실시예에서 제한되지 않는다. 세부사항에 대해서는, 기존의 기술을 참조한다. 추가적으로, 작동 에러 정정 코드 및 재시도 에러 정정 코드를 생성하기 위한 방법, 및 작동 에러 정정 코드 및 재시도 에러 정정 코드를 이용함으로써 판독된 데이터를 검사 하기 위한 방법은 또한, 기존의 기술을 재이용할 수 있다. 상기한 실시예에서의 기능을 구현하기 위하여, 컴퓨팅 디바이스는 기능을 수행하기 위한 대응하는 하드웨어 구"}
{"patent_id": "10-2024-7022331", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "조 및/또는 소프트웨어 모듈을 포함한다는 것이 이해될 수 있다. 본 기술분야에서의 통상의 기술자는 이 출원에 서 개시되는 실시예에서 설명된 예에서의 뱅크 및 방법 단계를 조합하여, 이 출원은 하드웨어, 또는 하드웨어 및 컴퓨터 소프트웨어의 조합을 이용함으로써 구현될 수 있다는 것을 용이하게 인지해야 한다. 기능이 하드웨어, 또는 컴퓨터 소프트웨어에 의해 구동되는 하드웨어에 의해 수행되는지 여부는 기술적 해결책의 특정 한 애플리케이션 시나리오 및 설계 제약 조건에 종속된다. 이 실시예에서의 방법 단계는 하드웨어 방식으로 구현될 수 있거나, 프로세서에 의해 소프트웨어 명령을 실행함 으로써 구현될 수 있다. 소프트웨어 명령은 대응하는 소프트웨어 모듈을 포함할 수 있다. 소프트웨어 모듈은 랜 덤 액세스 메모리(random access memory, RAM), 플래시 메모리, 판독-전용 메모리(read-only memory, ROM), 프 로그래밍가능 판독-전용 메모리(programmable ROM, PROM), 소거가능 프로그래밍가능 판독-전용 메모리(erasable PROM, EPROM), 전기적 소거가능 프로그래밍가능 판독-전용 메모리(electrically EPROM, EEPROM), 레지스터"}
{"patent_id": "10-2024-7022331", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "(register), 하드 디스크, 분리가능 하드 디스크, CD-ROM, 또는 본 기술분야에서 널리 공지된 임의의 다른 형태 내에 저장될 수 있다. 예를 들어, 저장 매체는 프로세서에 결합되어, 이로써 프로세서는 저장 매체로부터 정보 를 판독할 수 있고 정보를 저장 매체로 기입할 수 있다. 확실히, 저장 매체는 프로세서의 컴포넌트일 수 있다. 프로세서 및 저장 매체는 ASIC 내에 배치될 수 있다. 추가적으로, ASIC은 컴퓨팅 디바이스 내에 위치될 수 있다. 확실히, 프로세서 및 저장 매체는 대안적으로, 네트워크 디바이스 또는 단말 디바이스 내의 개별 컴포넌 트로서 존재할 수 있다. 상기한 실시예의 전부 또는 일부는 소프트웨어, 하드웨어, 펌웨어, 또는 그 임의의 조합을 이용함으로써 구현될 수 있다. 소프트웨어가 실시예를 구현하기 위하여 이용될 때, 실시예의 전부 또는 일부는 컴퓨터 프로그램 제품 의 형태로 구현될 수 있다. 컴퓨터 프로그램 제품은 하나 이상의 컴퓨터 프로그램 및 명령을 포함한다. 컴퓨터 프로그램 또는 명령이 컴퓨터 상에서 로딩되고 실행될 때, 이 출원의 실시예에서의 프로세스 또는 기능의 전부 또는 일부가 실행된다. 컴퓨터는 범용 컴퓨터, 전용 컴퓨터, 컴퓨터 네트워크, 네트워크 디바이스, 사용자 장비, 또는 또 다른 프로그래밍가능 장치일 수 있다. 컴퓨터 프로그램 또는 명령은 컴퓨터-판독가능 저장 매체 내에 저장될 수 있거나, 컴퓨터-판독가능 저장 매체로부터 또 다른 컴퓨터-판독가능 저장 매체로 송신될 수 있 다. 예를 들어, 컴퓨터 프로그램 또는 명령은 유선 또는 무선 방식으로 웹사이트, 컴퓨터, 서버, 또는 데이터 센터로부터 또 다른 웹사이트, 컴퓨터, 서버, 또는 데이터 센터로 송신될 수 있다. 컴퓨터-판독가능 저장 매체 는 하나 이상의 이용가능 매체들을 통합하는 서버 또는 데이터 센터와 같은 컴퓨터 또는 데이터 저장 디바이스 에 의해 액세스될 수 있는 임의의 이용가능 매체일 수 있다. 이용가능 매체는 자기 매체, 예를 들어, 플로피 디 스크, 하드 디스크, 또는 자기 테이프일 수 있거나, 광학 매체, 예를 들어, 디지털 비디오 디스크(digital video disc, DVD)일 수 있거나, 반도체 매체, 예를 들어, 솔리드-스테이트 드라이브(solid-state drive, SSD) 일 수 있다. 상기한 설명은 이 출원의 단지 구체적인 실시예이지만, 이 출원의 보호 범위를 제한하도록 의도되지 않는다. 이"}
{"patent_id": "10-2024-7022331", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "출원에서 개시된 기술적 범위 내에서 본 기술분야에서의 통상의 기술자에 의해 용이하게 도출된 임의의 수정 또 는 대체는 이 출원의 보호 범위 내에 속할 것이다. 그러므로, 이 출원의 보호 범위는 청구항의 보호 범위가 대 상이 될 것이다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9"}
{"patent_id": "10-2024-7022331", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 이 출원의 실시예에 따른, 스토리지 클래스 메모리의 구조의 개략도이다. 도 2는 이 출원의 실시예에 따른, 스토리지 클래스 메모리의 물리적 분할의 개략도이다. 도 3은 이 출원의 실시예에 따른, 제1-유형 메모리 칩의 구조의 개략도이다. 도 4는 이 출원의 실시예에 따른, 작동 에러 정정 코드 및 재시도 에러 정정 코드의 생성의 개략도이다. 도 5는 이 출원의 실시예에 따른, 또 다른 스토리지 클래스 메모리의 구조의 개략도이다. 도 6은 이 출원의 실시예에 따른, 또 다른 스토리지 클래스 메모리의 구조의 개략도이다. 도 7은 이 출원의 실시예에 따른, 프로세서 시스템의 구조의 개략도이다. 도 8은 이 출원의 실시예에 따른, 또 다른 프로세서 시스템의 구조의 개략도이다. 도 9는 이 출원의 실시예에 따른, 데이터 프로세싱 방법의 개략도이다."}
