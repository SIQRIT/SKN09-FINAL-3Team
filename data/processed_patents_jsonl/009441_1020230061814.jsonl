{"patent_id": "10-2023-0061814", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2024-0164210", "출원번호": "10-2023-0061814", "발명의 명칭": "데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 희소 컨볼루션 연산 방법 및 장치", "출원인": "한양대학교 산학협력단", "발명자": "최정욱"}}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "프로세서, 입력 버퍼 및 출력 버퍼를 이용하여 컨볼루션 연산을 수행하는 방법에 있어서, 입력 데이터에 포함되어 있는 희소 입력 데이터에 대한 입력 인덱스 데이터를 수집하는 인덱스 데이터 수집 단계;커널의 크기 및 상기 입력 인덱스 데이터에 기초하여 상기 커널의 웨이트들을 미리 설정된 기준에 따라 분류한후, 분류된 정보에 기초하여 커널 웨이트 그룹을 생성하는 커널 웨이트 그룹 생성 단계;상기 커널 웨이트 그룹에 대응되는 입력 인덱스 데이터를 매핑하여 데이터 플로우 규칙을 생성하는 데이터 플로우 규칙 생성 단계; 및상기 데이터 플로우 규칙에 기초하여 컨볼루션 연산을 수행하는 컨볼루션 연산 단계;를 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1항에 있어서,상기 커널은, 3X3 커널을 포함하고, 상기 컨볼루션 연산은 스탠다드 컨볼루션(standard convolution) 또는 스트라이드 컨볼루션(strideconvolution) 연산을 포함하며,상기 커널 웨이트 그룹 생성 단계는,상기 웨이트 그룹은 3X3 커널에 기초한 컨볼루션 연산의 특성을 고려하여, 대칭적으로 복수 개의 웨이트 그룹을생성하는 단계를 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서,상기 커널 웨이트 그룹 생성 단계는,제0웨이트 인덱스(W0), 제2웨이트 인덱스(W2), 제6웨이트 인덱스(W6) 및 제8웨이트 인덱스(W8)를 제0웨이트 그룹으로 생성하는 단계를 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제2항에 있어서,상기 커널 웨이트 그룹 생성 단계는,제1웨이트 인덱스(W1) 및 제7웨이트 인덱스(W7)를 제1웨이트 그룹으로 생성하는 단계를 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서,상기 커널 웨이트 그룹 생성 단계는,공개특허 10-2024-0164210-3-제3웨이트 인덱스(W3) 및 제5웨이트 인덱스(W5)를 제2웨이트 그룹으로 생성하는 단계를 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제2항에 있어서,상기 커널 웨이트 그룹 생성 단계는,제4웨이트 인덱스(W4)를 제3웨이트 그룹으로 생성하는 단계를 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제2항에 있어서,상기 데이터 플로우 규칙 생성 단계는,상기 웨이트 그룹에 대응되는 입력 인덱스를 수집한 후, 수집된 입력 인덱스를 상기 인풋 버퍼에 상기 웨이트그룹 별로 순차적으로 저장하는 단계;를 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 1항에 있어서,상기 컨볼루션 연산은 디컨볼루션(decovolution)을 포함하며,상기 커널은 1X1, 2X2 또는 4X4 커널을 포함하고,상기 커널 웨이트 그룹 생성 단계는,입력 버퍼 및 출력 버퍼의 사이즈에 기초하여 웨이트 그룹의 크기를 결정하는,데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1항에 있어서,상기 데이터 플로우 규칙 생성 단계는,상기 입력 인덱스와 상기 입력 인덱스에 대응되는 출력 인덱스의 비율에 기초하여 상기 입력 데이터에 대한 타일링(tiling) 사이즈를 조절하는 타일링 사이즈 조절 단계를 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서,상기 타일링 사이즈 조절 단계는,스탠다드 컨볼루션(standard convolution) 또는 스트라이드 컨볼루션(stride convolution)의 경우 타일링 사이즈를 증가시키고, 디컨볼루션(decovolution)의 경우 타일링 사이즈를 감소시키는 단계를 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "입력 데이터에 포함되어 있는 희소 입력 데이터에 대한 입력 인덱스 데이터를 수집하는 인덱스 데이터 수집 모듈;커널의 크기 및 상기 입력 인덱스 데이터에 기초하여 상기 커널의 웨이트들을 미리 설정된 기준에 따라 분류한공개특허 10-2024-0164210-4-후, 분류된 정보에 기초하여 커널 웨이트 그룹을 생성하고, 상기 커널 웨이트 그룹에 대응되는 입력 인덱스 데이터를 매핑하여 데이터 플로우 규칙을 생성하는 데이터 플로우 규칙 생성 모듈;상기 데이터 플로우 규칙에 기초하여 컨볼루션 연산을 수행하는 컨볼루션 연산 모듈;을 포함하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 장치."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 11항에 있어서,상기 커널은, 3X3 커널을 포함하고, 상기 컨볼루션 연산은 스탠다드 컨볼루션(standard convolution) 또는 스트라이드 컨볼루션(strideconvolution) 연산을 포함하며,상기 데이터 플로우 규칙 생성 모듈은,상기 웨이트 그룹은 3X3 커널에 기초한 컨볼루션 연산의 특성을 고려하여, 대칭적으로 복수 개의 웨이트 그룹을생성하는, 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 장치."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12항에 있어서,상기 데이터 플로우 규칙 생성 모듈은,상기 웨이트 그룹에 대응되는 입력 인덱스를 수집한 후, 수집된 입력 인덱스를 인풋 버퍼에 상기 웨이트 그룹별로 순차적으로 저장하는,데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 장치."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제11항에 있어서,상기 컨볼루션 연산은 디컨볼루션(decovolution)을 포함하며,상기 데이터 플로우 규칙 생성 모듈은,입력 버퍼 및 출력 버퍼의 사이즈에 기초하여 웨이트 그룹의 크기를 결정하는,데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 장치."}
{"patent_id": "10-2023-0061814", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "입력 데이터에 포함되어 있는 희소 입력 데이터에 대한 입력 인덱스 데이터를 수집하는 인덱스 데이터 수집 모듈;커널의 크기 및 상기 입력 인덱스 데이터에 기초하여 상기 커널의 웨이트들을 미리 설정된 기준에 따라 분류한후, 분류된 정보에 기초하여 커널 웨이트 그룹을 생성하고, 상기 커널 웨이트 그룹에 대응되는 입력 인덱스 데이터를 매핑하여 데이터 플로우 규칙을 생성하는 데이터 플로우 규칙 생성 모듈;상기 데이터 플로우 규칙에 기초하여 컨볼루션 연산을 수행하는 컨볼루션 연산 모듈;을 포함하며,상기 데이터 플로우 규칙 생성 모듈은,스탠다드 컨볼루션(standard convolution) 또는 스트라이드 컨볼루션(stride convolution)의 경우 타일링 사이즈를 증가시키고, 디컨볼루션(decovolution)의 경우 타일링 사이즈를 감소시키는,데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 장치."}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "일 실시예 따른 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법은, 입력 데이터에 포함되어 있는 희소 입력 데이터에 대한 입력 인덱스 데이터를 추출하는 인덱스 데이터 추출 단계, 커널의 크기 및 상기 입력 인덱스 데이터에 기초하여 상기 커널의 웨이트들을 미리 설정된 기준에 따라 분류한 후, 분류된 정 보에 기초하여 커널 웨이트 그룹을 생성하는 커널 웨이트 그룹 생성 단계, 상기 커널 웨이트 그룹에 대응되는 입 력 인덱스 데이터를 매핑하여 데이터 플로우 규칙을 생성하는 데이터 플로우 규칙 생성 단계 및 상기 데이터 플 로우 규칙에 기초하여 컨볼루션 연산을 수행하는 컨볼루션 연산 단계를 포함할 수 있다."}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법 및 장치에 관한 발명으 로서, 보다 상세하게는 인공신경망을 이용하여 희소 컨볼루션과 연산을 수행할 때, 데이터를 재사용할 수 있도 록 데이터 플로우를 최적화하여 컨볼루션 연산을 보다 빠르고 효과적으로 수행하는 기술에 관한 발명이다."}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "인공 지능(Artificial Intelligence, AI) 기술은, 인간의 학습능력과 추론능력, 지각능력, 자연언어의 이해 능 력 등을 컴퓨터 프로그램으로 실현한 기술을 의미하며, 종래의 룰(Rule) 기반 스마트 시스템과 달리 기계가 스 스로 학습하고 판단하며 똑똑해지는 시스템을 의미한다. 인공지능 기술은 기계학습(딥 러닝) 및 기계 학습을 활용한 요소 기술들로 구성된다. 기계 학습은 입력 데이터 들의 특징을 스스로 분류/학습하는 알고리즘 기술이며, 요소 기술은 딥 러닝 등의 기계학습 알고리즘을 활용하 여 인간 두뇌의 인지, 판단 등의 기능을 모사하는 기술로서, 언어적 이해, 시각적 이해, 추론/예측, 지식 표현, 동작 제어 등의 기술 분야로 구성된다. 인공지능의 기술의 발달에 따라, 자율주행 분야에서도 주행중인 차량 주변에 존재하는 객체를 인식하는 분야에 도 인공지능 기술이 적용되고 있다. 구체적으로, Lidar/RGB-D 센서 기반의 객체 인식 방법이 주를 이루고 있는 데, Lidar/RGB-D 센서 기반의 객체 인식 방법은 점 구름(Point Cloud) 형태의 데이터를 활용해 차량 주변에 존 재하는 객체의 위치와 종류를 분별하며, 점 구름 데이터는 컨볼루션(Convolution, 합성곱) 연산을 여러 레이어 에 걸쳐 대해 반복적으로 수행함으로써, 해당 데이터의 객체를 분류할 수 있는 특징을 추출한다. 그러나, 객체 인식 방법의 특성상, 점 구름 데이터가 공간에 희박하게(Sparse) 존재하기 때문에 컨볼루션 연산 또한 희박하게 존재하는 데이터들에 대해 이루어진다. 따라서, 레이어 별로 추출하는 특징(Feature)이 불규칙적 으로 메모리에 저장되고, 이로 인해 컨볼루션 연산에 사용되는 특징 데이터를 메모리로부터 불러오기 위해 불규 칙적인 접근을 할 수 밖에 없다. 따라서, 종래 기술에 따라 컨볼루션 연산을 수행하는 경우, 전 과정을 마치기 위해 필요한 시간이 크게 증가하는 문제점이 존재한다. 또한, 컨볼루션 연산에 있어서, 컨볼루션 연산을 주어진 하드웨어의 특성과 버퍼 크기에 맞도록 타일링(연산을 시공간적으로 분할)하여 최적의 데이터 플로우(맵핑)를 생성하는 과정은 매우 중요한 부분을 차지한다. 종래의 기술들은 타일 크기에 따라 입력-커널-출력 크기와 연산이 규칙적인 밀집 데이터의 합성곱만을 타겟으로 하여, 입력-커널-출력의 크기와 연산이 불규칙한 희소 데이터의 희소 합성곱에 대한 최적화에 어려움이 있다 구체적으로, 종래 기술에 따라 Gather-GEMM-Scatter의 과정으로 수행되는 희소 데이터 기반의 컨볼루션 연산 방 법은, 입력 데이터에서 0이 아닌 입력 데이터만 버퍼에 Gather하여 해당하는 커널과 연산을 수행하여 출력된 출 력 데이터를 메모리에 Scatter 하므로, 입력 데이터의 배치에 따라 인덱스 별 재사용 횟수 및 번짐 효과로 인한 출력 데이터의 개수가 불규칙하게 나타나는 문제점이 있다. 따라서, 입력-커널-출력 데이터의 크기와 연산 횟수 의 불규칙성으로 인하여, 타일링에 따른 입력/출력 버퍼의 사용률과, 각 버퍼에서의 데이터 재사용을 평가하는 것이 불가능한 단점이 존재한다. 선행기술문헌 특허문헌 (특허문헌 0001) 대한민국 등록특허허공보 10-2012828 B1 - 볼륨 렌더링 장치 및 방법(2018.12.26.)"}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "일 실시예에 따른 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법 및 장치는 상기 설명한 문제점을 설명하기 위한 고안된 발명으로서, 희소 입력 데이터의 특성을 기초하여 컨볼루션 연산을 효율 적으로 할 수 있는 방법 및 장치를 제공하는데 그 목적이 있다. 보다 상세하게는 인공신경망을 이용하여 컨볼루션 연산을 수행함에 있어서, 희소 입력 데이터의 위치 및 크기 정보를 이용하여 버퍼의 크기를 적절하게 가변함으로써, 불필요한 데이터의 수집을 최소화 하는 방법으로 컨볼 루션 연산의 전체 속도를 효과적으로 높이는데 목적이 존재한다."}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시예 따른 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방법은, 입력 데이터에 포함되어 있는 희소 입력 데이터에 대한 입력 인덱스 데이터를 추출하는 인덱스 데이터 추출 단계, 커널의 크기 및 상기 입력 인덱스 데이터에 기초하여 상기 커널의 웨이트들을 미리 설정된 기준에 따라 분류한 후, 분류된 정보에 기초하여 커널 웨이트 그룹을 생성하는 커널 웨이트 그룹 생성 단계, 상기 커널 웨이트 그룹에 대응되는 입력 인덱스 데이터를 매핑하여 데이터 플로우 규칙을 생성하는 데이터 플로우 규칙 생성 단계 및 상기 데이터 플로우 규칙에 기초하여 컨볼루션 연산을 수행하는 컨볼루션 연산 단계를 포함할 수 있다. 상기 커널은, 3X3 커널을 포함하고, 상기 컨볼루션 연산은 스탠다드 컨볼루션(standard convolution) 또는 스트 라이드 컨볼루션(stride convolution) 연산을 포함할 수 있다. 상기 커널 웨이트 그룹 생성 단계는, 상기 웨이트 그룹은 3X3 커널에 기초한 컨볼루션 연산의 특성을 고려하여, 대칭적으로 복수 개의 웨이트 그룹을 생성하는 단계를 포함할 수 있다. 상기 커널 웨이트 그룹 생성 단계는, 제0웨이트 인덱스(W0), 제2웨이트 인덱스(W2), 제6웨이트 인덱스(W6) 및 제8웨이트 인덱스(W8)를 제0웨이트 그룹으로 생성하는 단계를 포함할 수 있다. 상기 커널 웨이트 그룹 생성 단계는, 제1웨이트 인덱스(W1) 및 제7웨이트 인덱스(W7)를 제1웨이트 그룹으로 생 성하는 단계를 포함할 수 있다. 상기 커널 웨이트 그룹 생성 단계는, 제3웨이트 인덱스(W3) 및 제5웨이트 인덱스(W5)를 제2웨이트 그룹으로 생 성하는 단계를 포함할 수 있다. 상기 커널 웨이트 그룹 생성 단계는, 제4웨이트 인덱스(W4)를 제3웨이트 그룹으로 생성하는 단계를 포함할 수 있다. 상기 데이터 플로우 규칙 생성 단계는, 상기 웨이트 그룹에 대응되는 입력 인덱스를 수집한 후, 수집된 입력 인 덱스를 상기 인풋 버퍼에 상기 웨이트 그룹 별로 순차적으로 저장하는 단계를 포함할 수 있다. 상기 컨볼루션 연산은 디컨볼루션(decovolution)을 포함하며, 상기 커널은 1X1, 2X2 또는 4X4 커널을 포함하고, 상기 커널 웨이트 그룹 생성 단계는, 입력 버퍼 및 출력 버퍼의 사이즈에 기초하여 웨이트 그룹의 크기를 결정 할 수 있다. 상기 데이터 플로우 규칙 생성 단계는, 상기 입력 인덱스와 상기 입력 인덱스에 대응되는 출력 인덱스의 비율에 기초하여 상기 입력 데이터에 대한 타일링(tiling) 사이즈를 조절하는 타일링 사이즈 조절 단계를 포함할 수 있 다. 상기 타일링 사이즈 조절 단계는, 스탠다드 컨볼루션(standard convolution) 또는 스트라이드 컨볼루션(stride convolution)의 경우 타일링 사이즈를 증가시키고, 디컨볼루션(decovolution)의 경우 타일링 사이즈를 감소시키 는 단계를 포함할 수 있다. 일 실시예 따른 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 장치는, 입력 데이터에 포함되어 있는 희소 입력 데이터에 대한 입력 인덱스 데이터를 수집하는 인덱스 데이터 수집 모듈 ,커널의 크기 및 상기 입력 인덱스 데이터에 기초하여 상기 커널의 웨이트들을 미리 설정된 기준에 따라 분류한 후, 분류된 정보에 기초하여 커널 웨이트 그룹을 생성하고, 상기 커널 웨이트 그룹에 대응되는 입력 인덱스 데이터를 매핑 하여 데이터 플로우 규칙을 생성하는 데이터 플로우 규칙 생성 모듈 및 상기 데이터 플로우 규칙에 기초하여 컨 볼루션 연산을 수행하는 컨볼루션 연산 모듈을 포함할 수 있다. 상기 커널은, 3X3 커널을 포함하고, 상기 컨볼루션 연산은 스탠다드 컨볼루션(standard convolution) 또는 스트 라이드 컨볼루션(stride convolution) 연산을 포함할 수 있다. 상기 데이터 플로우 규칙 생성 모듈은, 상기 웨이트 그룹은 3X3 커널에 기초한 컨볼루션 연산의 특성을 고려하 여, 대칭적으로 복수 개의 웨이트 그룹을 생성할 수 있다. 상기 데이터 플로우 규칙 생성 모듈은, 상기 웨이트 그룹에 대응되는 입력 인덱스를 수집한 후, 수집된 입력 인 덱스를 인풋 버퍼에 상기 웨이트 그룹 별로 순차적으로 저장할 수 있다. 상기 컨볼루션 연산은 디컨볼루션(decovolution)을 포함하며, 상기 데이터 플로우 규칙 생성 모듈은, 입력 버퍼 및 출력 버퍼의 사이즈에 기초하여 웨이트 그룹의 크기를 결정할 수 있다. 일 실시예 따른 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 장치는, 입력 데이터에 포함되어 있는 희소 입력 데이터에 대한 입력 인덱스 데이터를 수집하는 인덱스 데이터 수집 모듈, 커널의 크기 및 상기 입력 인덱스 데이터에 기초하여 상기 커널의 웨이트들을 미리 설정된 기준에 따라 분류한 후, 분류된 정보에 기초하여 커널 웨이트 그룹을 생성하고, 상기 커널 웨이트 그룹에 대응되는 입력 인덱스 데이터를 매핑 하여 데이터 플로우 규칙을 생성하는 데이터 플로우 규칙 생성 모듈 및 상기 데이터 플로우 규칙에 기초하여 컨 볼루션 연산을 수행하는 컨볼루션 연산 모듈을 포함하며,상기 데이터 플로우 규칙 생성 모듈은, 스탠다드 컨볼 루션(standard convolution) 또는 스트라이드 컨볼루션(stride convolution)의 경우 타일링 사이즈를 증가시키 고, 디컨볼루션(decovolution)의 경우 타일링 사이즈를 감소시킬 수 있다."}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "일 실시예에 따른 희소 입력 데이터의 위치 정보에 기초한 컨볼루션 연산 방법 및 장치는 희소 데이터 기반의 컨볼루션 연산을 수행함에 있어서, 입력 데이터와 출력 데이터의 특징을 고려하여 데이터를 수집하고 재활용하 므로, 종래 기술보다 빠르게 컨볼루션 연산을 수행할 수 있는 장점이 존재한다. 또한, 컨불루션 연산의 경우 그 특성상 중첩되는 계산 과정이 많은데, 본 발명에 따른 컨볼루션 연산 방법은 종 래에 수집하였던 입력 데이터의 정보를 다음 연산에서 재사용하므로, 컨볼루션 연산 자체의 연산 속도를 빠르게 증가시킬 수 있는 장점이 존재한다. 또한, 이러한 특징으로 인해 3차원 공간에 존재하는 객체 인식의 속도를 증가시킬 수 있는바, 고차원 자율 주행 에 필수적인 고속 전방 장애물 인식을 효율적으로 수행할 수 있고, 빠르고 정확한 로봇 네비게이션을 위한 RGB- D 기반의 위치 추정도 효율적으로 수행할 수 있는 장점이 존재한다."}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 2, "content": "본 발명의 효과들은 이상에서 언급한 기술적 과제들로 제한되지 않으며, 언급되지 않은 또 다른 효과들은 아래 의 기재들로부터 당업자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 명세서에 기재된 실시 예와 도면에 도시된 구성은 개시된 발명의 바람직한 일 예이며, 본 출원의 출원 시점 에 있어서 본 명세서의 실시 예와 도면을 대체할 수 있는 다양한 변형 예들이 있을 수 있다. 또한, 본 명세서에서 사용한 용어는 실시 예를 설명하기 위해 사용된 것으로, 개시된 발명을 제한 및/또는 한정 하려는 의도가 아니다. 단수의 표현은 문맥상 명백하게 다르게 뜻하지 않는 한, 복수의 표현을 포함한다. 본 명세서에서, \"포함하다\", \"구비하다\" 또는 \"가지다\" 등의 용어는 명세서상에 기재된 특징, 숫자, 단계, 작동, 구성요소, 부품 또는 이들을 조합한 것이 존재함을 지정하려는 것이지, 하나 또는 그 이상의 다른 특징들 이나 숫자, 단계, 작동, 구성요소, 부품 또는 이들을 조합한 것들의 존재 또는 부가 가능성을 미리 배제하지 않 는다. 또한, 본 명세서에서 사용한 \"제 1\", \"제 2\" 등과 같이 서수를 포함하는 용어는 다양한 구성 요소들을 설명하는 데 사용될 수 있지만, 상기 구성 요소들은 상기 용어들에 의해 한정되지는 않는다. 아래에서는 첨부한 도면을 참고하여 본 발명의 실시예에 대하여 본 발명이 속하는 기술 분야에서 통상의 지식을 가진 자가 용이하게 실시할 수 있도록 상세히 설명한다. 그리고 도면에서 본 발명을 명확하게 설명하기 위해서 설명과 관계없는 부분은 생략한다. 한편, 본 명세서에서 발명의 명칭은 '데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 방 법 및 장치'로 기재하였으나, 이하 설명의 편의를 위해 '데이터 플로우 최적화 방법을 이용한 인공신경망 기반 의 컨볼루션 연산 방법'은 '컨볼루션 연산 방법'으로 축약하고, '데이터 플로우 최적화 방법을 이용한 인공신경 망 기반의 컨볼루션 연산 장치'는 '컨볼루션 연산 장치'로 축약하여 설명하도록 한다. 도 1은 본 발명의 일 실시예에 따라 컨볼루션 연산 장치에 입력되는 입력 데이터의 일 예와 컨볼루션 연산을 수 행하는 커널의 일 예를 도시한 도면이다. 컨볼루션 연산은, 입력 데이터를 분석하여, 입력 인덱스 정보를 수집하는 과정에서 시작된다. 본 발명에서 의 (index) 정보는 입력 데이터 내에 서 실제 데이터가 존재하는 유효 데이터가 위치하고 있는 포인트에 대한 위치 정보를 의미한다. 일 예로, 도 1의 (a)에 도시된 바와 같은 5 X 5행렬의 데이터가 입력 데이터로 입력이 된다면(행렬에서 빗금친 부분이 데이터가 존재하는 영역이고, 민무늬 부분이 데이터가 존재하지 않는 영역을 의미하며, 데이터가 존재하 는 위치의 데이터를 유효 데이터라 지칭하기로 한다) 인덱스 정보 추출 모듈은 입력 데이터 내에서 유효 데이터가 위치하고 있는 위치 정보를 입력 인덱스 정보로 추출할 수 있다. 인덱스 정보를 표현하는 방법은 행렬 데이터를 표현하는 공지되어 있는 방법이면 그 어느 것이든 차용될 수 있 는데, 대표적으로 CSR(Compressed Spare Row) 포맷이 사용될 수 있다. 이하 설명의 편의를 위해 본 발명에서의 인덱스 정보는 CSR 형식을 기준으로 설명하기로 한다. 구체적으로, CSR 포맷 형식은 순차적으로 각각의 행에 유효 데이터가 몇 개가 존재하는지에 대한 정보인 CSR_row 정보와, 순차적으로 각각의 행에 유효 데이터가 몇 열에 위치하는지에 대한 정보인 CSR_col에 대한 정 보를 포함하고 있으며, CSR 형식 좌표 표현 방식은 일반적으로 행렬 표현 방법과 동일하나, 시작이 1이 아니라 0에서 시작하는 것에 차이점이 존재한다. 따라서, 데이터에서 가장 왼쪽 및 가장 위쪽에 있는 좌표는 (1,1)로 표현하지 않고 (0,0)으로 표현된다. 따라서, 입력 데이터는 0행 0열을 기준으로 행과 열이 시작된다고 볼 수 있으며, 커널 또한 3X3 행렬의 커널인 경우 커널의 오프셋은 행 기준으로 (0,1,2), 열 기준으로 (0,1,2)가 된다. 즉, 입력 데이터와 커널 모두 0행을 기준으로 표현이 된다. 도 1에 표시된 입력 데이터에 대해 인덱스 정보가 생성되는 과정을 순차적으로 설명하면, CSR_row 값은 데이터 와 무관하게 처음은 0으로 시작하며, 2번째 값부터 각 행별로 있는 유효 데이터의 개수 만큼 누적된 값을 나타 낸다. 따라서, 도면에 표시된 바와 같이 CSR_row는 0으로 시작한다. 제0행에서는 유효 데이터가 1개 (I0)존재하므로 제0행까지 고려한 에 CSR_row의 값은 [0,1]로 표현된다. 제1행에서는 유효 데이터가 1개 (I1)존재하므로 제1행까지 고려한 CSR_row 값은 [0,1,2]로 표현이 된다. 제2행에서는 유효 데이터가 2개(I1, I2) 존재하므로 제2행까지 고려한 CSR_row 값은 [0,1,2,4]로 표현이 된다. 제3행에서는 유효 데이터가 1개(I4) 존재하므로 제3행까지 고려한 CSR_row값은 [0,1,2,4,5]로 표현이 된다. 제4행에서는 유효 데이터가 1개(I5) 존재하므로 제4행까지 고려한 CSR_row값은 [0,1,2,4,5,6]로 표현이 된다. CSR_col은 순차적으로 각각의 행에서 몇 번째 열(column)에 유효 데이터가 위치하고 있는지에 대한 정보를 알려 주는 정보이다. 따라서, 도 3을 기준으로 제0행에서는 4번째 열의 위치에 데이터가 존재하므로 CSR_col은 [4]가 되고, 제1행에는 1 열에 유효 데이터가 존재하므로 CSR_col은 [4,1]이 된다. 제2행에는 유효 데이터가 2번째 열 과 3번째 열에 존재하므로 CSR_col은 [4,1,2,3]이 되고, 제3행에는 유효 데이터가 3 열에 위치하므로 CSR_col은 [4,1,2,3.3]이 된다. 이러한 방식으로 데이터를 생성하면 최종 CSR_col는 [4,1,2,3,3,2] 가 된다. 도 2는 종래 기술에 따라 희소 데이터 기반의 컨볼루션 연산을 수행하는 과정을 설명하기 위한 도면이고, 도 3 은 종래 기술에 따라 희소 데이터 기반의 컨볼루션 연산을 수행하는 경우 발생하는 문제점을 설명하기 위한 도 면이다. 도 2를 참고하면, LiDAR를 통해 얻는 3차원 공간에 존재해는 객체(object)에 대한 포인트 클라우드(point cloud, 20)는 도면에 도시된 바와 같이 밀도가 희박한(Sparse)한 정보를 가지고 있다. 따라서, 이러한 데이터들 에서는 바로 컨볼루션 연산을 수행하지 않고 입력된 포인트 클라우드 데이터에 대해 희소 유사 이미지(pseudo image)로 변환과정을 거친다. (S10) 즉, S10 과정은 2차원 희소 컨볼루션(spare convolution) 입력 데이터를 생성하는 것이다. 다만, 희소 이미지 데이터에 대해 컨볼루션 연산을 수행하면 연산의 비효율 문제가 발생하게 되므로, 희소 이미 지를 밀집된 형태의 데이터로 변환한 후, 변환된 데이터를 기초로 밀집(dense) 컨볼루션 연산을 수행하게 된다. 그러나, 이러한 과정을 거쳐서 컨볼루션 연산을 수행하더라도 희소 데이터의 희소 정도(sparsity)는 일반적으로 95%를 초과하기 때문에, 밀집 컨볼루션 연산을 위한 치환 연산은 매우 비효율적인 문제를 가지고 있다. 구체적으로, 이를 공간적 아키텍처 가속기와 연관 지어 설명하면, 공간적 아키텍처 가속기는 신경망 연산의 대 부분을 차지하는 텐서 연산을 효율적으로 처리 할 수 있어, 신경망 가속에 일반적으로 많이 사용된다. 가속기의 텐서 연산은, 연산을 수행하기 위해 필요한 데이터의 파티셔닝(공간적 분할)과 스케줄링(시간적 분할)을 나타내는 데이터 플로우로 나뉘어 질 수 있다. 공간적 아키텍처 가속기는 다양한 데이터 플로우를 가질 수 있는데, 데이터 플로우를 어떻게 설정하는지에 따 라 가속기 내에서 데이터 재사용과 하드웨어 사용률의 변화가 발생하므로, 이는 성능과 에너지 효율에 큰 영향 을 미친다. 따라서, 주어진 가속기의 구성과 텐서 연산에 대해 성능과 에너지 효율을 최적화하는 방법들이 제안 되고 있으며, 이를 데이터 플로우 최적화라고 한다. 기존의 데이터 플로우 최적화 방법은 밀집된 데이터 기반의 컨볼루션 연산에 적용되는 규칙적인 텐서 연산만을 고려하기 때문에, 이는 희소 데이터 기반의 희소 컨볼루션 연산에 적용되는 불규칙적인 텐서 연산의 최적화에 한계가 존재한다. 구체적으로, 밀집 데이터 기반의 컨볼루션 연산은 커널의 특성(높이*넓이, Stride, Dilation)에 기초하여 규칙 적인 텐서 연산을 수행하므로, 특정 크기(높이*넓이)의 입력 데이터, 커널의 연산에 따른 출력 데이터의 크기 (높이*넓이), 메모리 계층에서의 데이터 재사용 및 인덱스 별 연산 횟수가 커널에 의해서 결정되는 특징을 가지 고 있다. 종래의 데이터 플로우 최적화 방법은 이러한 규칙성을 활용하여 최적화를 진행하며, 구체적으로 가속기의 입력 버퍼와 출력 버퍼 크기에 맞도록 연산을 데이터의 여러 Dimension에 대하여 타일 단위로 크기를 분할하고, 타일 의 처리 순서에 따른 데이터 플로우의 성능을 평가하여, 최적의 타일 크기와 처리 순서를 결정할 수 있다. 그러나 이러한 방법은 Gather-GEMM-Scatter의 과정으로 수행되는 희소 데이터의 희소 합성곱의 불규칙한 연산에 대한 최적화에는 많은 어려움이 존재하는 단점이 있다. 구체적으로, 종래 기술에 따라 Gather-GEMM-Scatter의 과정으로 수행되는 희소 데이터 기반의 컨볼루션 연산 방 법은, 입력 데이터에서 0이 아닌 입력 데이터만 버퍼에 Gather하여 해당하는 커널과 연산을 수행하여 출력된 출 력 데이터를 메모리에 Scatter 하므로, 입력 데이터의 배치에 따라 인덱스 별 재사용 횟수 및 번짐 효과로 인한출력 데이터의 개수가 불규칙하게 나타나는 문제점이 있다. 따라서, 입력-커널-출력 데이터의 크기와 연산 횟수 의 불규칙성으로 인하여, 타일링에 따른 입력/출력 버퍼의 사용률과, 각 버퍼에서의 데이터 재사용을 평가하는 것이 불가능한 단점이 존재한다. 즉, 희소 입력 데이터에 기반한 컨볼루션 연산의 경우, 입력 특성맵의 Non-zero 데이터의 배치, 희소성에 따른 번짐 효과로 인해 입력-출력 인덱스의 비율과 데이터의 재사용이 불규칙적인 문제가 발생한다. 구체적으로, 이를 도 2를 통해 알아보면, 도 2의 왼쪽에 도시된 바와 같이 동일한 입력 인덱스 크기(Ta=3)를 기 준으로 제1타일(Tile 1) 영역에 대해 3x3 커널을 적용해 컨볼루션 연산을 하게 되면(스트라이딩 2 기준) 입력 인덱스와 아웃풋 인덱스의 비율은 25/2으로 8.33이 되나, 제2타일(Tile 1) 영역을 기준으로 3x3 커널을 적용해 컨볼루션 연산을 하면(스트라이딩 2 기준) 입력 인덱스와 아웃풋 인덱스의 비율은 15/3으로 5가 된다. 즉, 불규칙적인 입력-출력 인덱스의 비율로 인해 입력 버퍼와 출력 버퍼의 사용량 예측 어렵게 되고, 불규칙적 인 커널 인덱스의 재사용으로 인해 Mapping의 메모리 액서스 예측 어려운 단점이 존재한다. 이러한 현상은 도 2의 오론쪽 그래프에 도시된 바와 같이 밀집 데이터에 기반한 컨볼루션 연산보다 희소 데이터에 기반한 컨볼루 션 연산에 더 많이 발생하게 된다. 따라서, 본 발명의 일 실시예에 따른 컨볼루션 연산의 데이터 플로우 최적화 방법 및 장치는 상기 설명한 문제 점을 해결하기 위해 고안된 발명으로서, 컨볼루션 연산을 수행함에 있어서, 컨볼루션 연산의 특성(Conv, Strided Conv, Deconv), 입력 특성맵의 희소성/크기에 따른 번짐 효과의 영향을 고려한 데이터 플로우 최적화 방법을 제공하는데 목적이 존재한다. 보다 구체적으로는, Gather-GEMM-Scatter의 과정으로 수행되는 희소 입력 데이터에 대한 컨볼루션 연산에서, 데 이터의 재사용이 극대화되도록 위이트 그룹(Weight Group)을 기반으로 Gather-Scatter을 수행하며, 고정된 버퍼 사이즈 하에서 컨볼루션 연산의 입력 버퍼와 출력 버퍼 사용량의 불균형을 개선하기 위해 계층의 연산 특성 및 희소성에 따른 입력 채널 사이즈와 출력 채널 타일 사이즈의 최적화를 수행하므로서, 컨볼루션 연산의 전반적인 속도를 높이는데 목적이 있다. 이하 도면을 통해 구체적으로 알아보도록 한다. 도 4는 본 발명의 일 실시예에 따른 인공신경망을 이용한 희소 데이터 기반의 컨볼루션 연산 장치의 일부 구성 요소를 도시한 블록도이다. 도 4를 참조하면, 일 실시예에 따른 희소 입력 데이터의 위치 정보에 기초한 컨볼루션 연산 장치는 프로세서 와 메모리 모듈을 포함할 수 있고, 프로세서는 입력 데이터 수집 모듈, 데이터 플로우 규 칙 생성 모듈 및 컨볼루션 연산 모듈을 포함할 수 있으며, 메모리 모듈은 입력 메모리, 입 력 버퍼, 출력 버퍼 및 출력 메모리 등을 포함할 수 있다. 한편, 본 발명에서 컨볼루션 연산을 수행하기 이동되는 커널은, 3X3커널 및 스트라이드는 2를 기준으로 하여 설 명한다. 그러나, 이는 본 발명의 일 실시예에 불과할 뿐, 본 발명의 원리는 2X2, 4X4, 5X5 등의 크기를 가지는 커널에 대해서도 적용될 수 있으며, 2차원 커널이 아닌 3차원 커널에서도 본 발명의 원리가 그대로 적용될 수 있다. 또한, 도 4에서는 설명의 편의를 위해 프로세서와 메모리 모듈을 분리하여 설명하였고, 프로세서 내에서도 입력 데이터 수집 모듈, 데이터 플로우 규칙 생성 모듈 및 컨볼루션 연산 모듈 을 각각의 별도의 구성 요소로 도시하여 설명하였지만, 이는 설명의 편의를 위해 구분한 것이고 각각의 모듈이 하는 역할을 하나의 프로세서가 수행할 수도 있다. 입력 데이터 수집 모듈은 입력 메모리에 있는 입력 데이터를 분석하여, 입력 데이터 내에 있 는 희소 입력 데이터의 입력 인덱스 정보를 수집하고, 입력 데이터 내에 존재하는 희소 입력 데이터를 입력 버퍼의 크기에 맞춰 수집한다. 데이터 플로우 규칙 생성 모듈은 수집된 희소 입력 데이터와 입력 인덱스 정보를 기초로 입력/출력 채널에 대한 타일(tile) 사이즈를 조정하거나, 웨이트 그룹(weight group)기반의 인풋 가더(input gatter) 및 아웃풋 스카터(output scatter)를 조정하여 컨볼루션 연산 수행에 대한 규칙을 생성한다. 이에 대한 자세한 설명은 후 술하도록 한다. 컨볼루션 연산 모듈은 입력 데이터 수집 모듈이 수집한 희소 입력 데이터 및 데이터 플로우 규칙 생 성 모듈이 생성한 규칙을 기초로 컨볼루션 연산을 수행하고, 컨볼루션 연산에 의해 생성된 출력 데이터를출력 버퍼로 송신한다. 메모리 모듈은 입력 데이터와 출력 데이터가 저장되는 모듈로서, 그 특성에 따라 입력 메모리와 출력 메모리는 DRAM으로 구현될 수 있으며, 입력 버퍼와 출력 버퍼는 SRAM으로 구현될 수 있다. 입력 메모리에는 컨볼루션 연산에 수행될 희소 입력 데이터가 포함되어 있는 입력 데이터가 임시적으 로 저장되어 있을 수 있다. 입력 버퍼에는 입력 데이터 수집 모듈이 수집한 희소 입력 데이터가 임시적으로 저장될 수 있다. 출력 버퍼에는 컨볼루션 연산 모듈에 의해 수행된 출력 데이터가 임시적으로 저장될 수 있다. 도 5는 본 발명의 일 실시예에 따른 데이터 플로우 최적화 모듈이 타일의 크기를 조정하는 방법을 설명하기 위 한 도면으로서, 구체적으로는 컨볼루션 연산 모듈이 스탠다드 컨볼루션(Standard Convolution)을 수행할 때, 데이터 플로우 규칙 생성 모듈이 생성하는 데이터 플로우 규칙에 대한 과정을 설명하기 위한 도면이다. 도 5의 (a)를 참조하면, 입력 데이터 내에서 희소 입력 데이터의 희소성이 높거나 입력 특성맵의 크기가 상 대적으로 큰 경우에는 컨볼루션 연산을 수행함에 있어서 번짐 효과가 크게 발생하여 출력 버퍼와 입력 버퍼 크 기의 불균형이 발생하게 된다. 구체적으로 도 5의 (a)에 도시된 바와 같이 아웃풋 인덱스와 입력 인덱스의 비율이 36/6=6이 되어 상당히 높은 비율로 불균형이 발생하게 된다. 따라서, 이러한 경우네는 입력 인덱스의 사용량이 적은 대신 아웃풋 인덱스의 사용량이 많아 인풋 버퍼는 상대적으로 적게 사용되나, 아웃풋 버퍼는 상대적으로 많이 사용되어, 버퍼 사용의 불균형 문제가 발생하게 된다. 그러나, 도 5의 (b)에 도시된 바와 같이 입력 데이터 내에서 희소 입력 데이터의 희소성이 낮거나 입력 특 성맵의 크기가 상대적으로 작은 경우에는 컨볼루션 연산을 수행함에 있어서 번짐 효과가 상대적으로 작게 발생 하여 출력 버퍼와 입력 버퍼 크기의 불균형이 상대적으로 작게 발생하게 된다. 구체적으로 도 5의 (b)에 도시된 바와 같이 아웃풋 인덱스와 입력 인덱스의 비율이 75/36=2.08이 되어 도 5의 (a)의 경우와 다르게 불균형이 작 아진다. 따라서, 본 발명에 따른 데이터 플로우 규칙 생성 모듈은 입력 인덱스와 아웃풋 인덱스의 비를 계산하여, 미리 설정된 기준보다 계산된 비가 높은 경우에는 입력 채널에 대한 타일(tile)의 사이즈를 증가시켜, 입력 인 덱스가 많이 사용되는 방법으로 입력 버퍼와 출력 버퍼 사이의 크기 불균형 문제를 해소시킬 수 있다. 일 예로 미리 설정된 기준은 다양한 숫자로 설정될 수 있으나 3 이상인 경우 타일의 사이즈를 증가시키도록 할 수 있으며, 계산된 입력 인덱스와 아웃풋 인덱스의 비가 커지면 커질수록 증가되는 타일의 사이즈 또한 비례하 여 커지도록 설정할 수 있다. 도 6및 도 7은 본 발명의 일 실시예에 따른 데이터 플로우 최적화 모듈이 웨이트 그룹 기반의 입력 데이터를 수 집하는 방법을 설명하기 위한 도면으로서, 컨볼루션 연산 모듈이 스트라이드 컨볼루션(Strid Convolutio n)을 수행할 때, 데이터 플로우 규칙 생성 모듈이 생성하는 데이터 플로우 규칙을 설명하기 위한 도면이다. 도 6 (a)는 입력 인덱스와 커널의 웨이트 인덱스가 컨볼루션 연산이 되어 출력 데이터가 생성되는 과정을 도시 한 도면이고, 도 6의 (b)는 출력 데이터가 생성됨에 있어서 커널의 웨이트 그룹별로 대응되는 입력 인덱스를 그 룹화 해놓은 도면이다. 도 6의 (a)를 참조하면, 입력 데이터에 3x3 커널이 슬라이딩하면서 컨볼루션 연산을 수행하는 경우 제0입력 인덱스(O0)와 제1입력 인덱스(O1) 및 제5입력 인덱스(O5)는 도면에 도시된 바와 같이 입력 인덱스와 이에 대응 되는 커널의 웨이트 인덱스의 곱에 의해 생성된다. 일반적으로 스트라이드 컨볼루션(Strided Convolution)은 입력되는 입력 인덱스에 대하여 웨이트 인덱스 간에 그룹을 지어 데이터를 재사용 하는 특성을 가지고 있는데, 3X3 커널에 의해 컨볼루션 연산이 이루어지면 도면에 도시된 바와 같이 커널의 웨이트들은 배치되어 있는 위치에 따라 대응되는 입력 인덱스의 범위가 그룹화되어 질 수 있다. 기본적인 데이터 플로우에서는 커널의 웨이트의 모든 인덱스(W0부터 W8)에 해당하는 Ta 개의 입풋 인덱스를 입 력 버퍼에 수집(gather)하게 되는데, 이런 경우에는 입력 버퍼의 입력 인덱스 Ta 개 중 특정 웨이트 인덱스와 인덱스는 1/4 로 감소하게 된다. 따라서, 입력 버퍼에서는 데이터 재사용이 감소하여 컨볼루션 연산의 효율적으 로 이루어지지 못하는 단점이 존재한다. 그러나 본 발명의 경우 이를 개선하기 위해 커널의 특성 및 컨볼루션 연산의 특성을 고려하여 웨이트 그룹 기반 으로 입력 데이터를 수집하므로 데이터의 재사용을 극대화를 수행할 수 있게 된다. 구체적으로, 특정 웨이트 그룹에 대응되는 입력 인덱스만을 입력 버퍼에 수집하게 되면, 특정 웨이트 그룹의 모 든 웨이트에 대해 수집된 입력 인덱스가 모두 재사용될 수 있으므로 컨볼루션 연산을 효율성을 크게 향상시킬 수 있게 된다. 이를 도면을 통해 구체적으로 살펴보면, 제0웨이트 그룹(W0)의 경우 제0웨이트 그룹에 포함되어 있는 제0,2,6,8 입력 인덱스에 대응되는 입력 인덱스만을 입력 버퍼에 수집하게 되면, 제0웨이트 그룹(W0)의 모든 웨이트 인덱 스에 대하여 모든 입력 인덱스가 항상 재사용 되므로, 연산의 효율성을 높일 수 있다. 이를 웨이트 그룹별로 구체적으로 살펴보면, 제0웨이트 그룹(WG0)에 해당하는 제0웨이트 인덱스(W0), 제2웨이트 인덱스(W2), 제6웨이트 인덱스(W6) 및 제8웨이트 인덱스(W8)들은 제7입력 인덱스(I7), 제10입력 인덱스(I0), 제 12입력 인덱스(I12), 제14입력 인덱스(I14), 제25입력 인덱스(I25), 제28입력 인덱스(I28), 제30입력 인덱스 (I30) 및 제32입력 인덱스(I32)들과만 컨볼루션 연산을 수행하게 된다. 또한, 제1웨이트 그룹(WG1)에 해당하는 제3웨이트 인덱스(W3) 및, 제5웨이트 인덱스(W5)들은 제1입력 인덱스 (I1), 제3입력 인덱스(I3), 제5입력 인덱스(I5), 제16입력 인덱스(I16), 제19입력 인덱스(I19), 제21입력 인덱 스(I21), 제23입력 인덱스(I23), 제33입력 인덱스(I33) 및 제35입력 인덱스(I35)들 과만 컨볼루션 연산을 수행 하게 된다. 또한, 제2웨이트 그룹(WG2)에 해당하는 제1웨이트 인덱스(W1) 및 제7웨이트 인덱스(W7)들은 제6입력 인덱스 (I6), 제8입력 인덱스(I8), 제9입력 인덱스(I9), 제11입력 인덱스(I11), 제13입력 인덱스(I13), 제24입력 인덱 스(I24), 제26입력 인덱스(I26), 제27입력 인덱스(I27), 제29입력 인덱스(I29) 및 제31입력 인덱스(I31)들 과 만 컨볼루션 연산을 수행하게 된다. 또한, 제3웨이트 그룹(WG3)에 해당하는 제4웨이트 인덱스(W0)는 제0입력 인덱스(I0), 제2입력 인덱스(I2), 제4 입력 인덱스(I4), 제15입력 인덱스(I15), 제17입력 인덱스(I17), 제18입력 인덱스(I18), 제20입력 인덱스 (I20), 제22입력 인덱스(I22) 및 제34입력 인덱스(I34)들 과만 컨볼루션 연산을 수행하게 된다. 이러한 방식으로 입력 데이터를 수집하고 컨볼루션 연산을 수행하게 되면, 모든 웨이트 인덱스가 출력 인덱스에 대한 데이터 재사용(Reduction)의 기회를 가지고 된다. 따라서, 도 7에 도시된 바와 같이 입력 버퍼에 수 집된 입력 인덱스에 대한 모든 웨이트 그룹에 대한 Gather-GEMM 연산을 완료한 후, Reduction이 완료된 출력 인 덱스를 출력 버퍼에서 출력 메모리로 Scatter를 할 수 있게 되므로, 이를 통하여 인풋-아웃풋에 대하 여 100% 데이터 재사용을 달성 할 수 있다. 도 8과 도 9는 본 발명에 따른 컨볼루션 연산 방법과 종래 기술에 따른 컨볼루션 연산 방법을 비교 설명하기 위 한 도면으로서, 구체적으로 도 8은 종래 기술에 따라 웨이트 그룹 기반의 컨볼루션 연산 방법이 적용되지 않았 을 때의 연산 과정을 설명하기 위한 도면이고, 도 9는 본 발명에 따라 웨이트 그룹 기반의 컨볼루션 연산 방법 이 적용되었을 때의 연산 과정을 설명하기 위한 도면이다. 도 8을 참조하면, 종래 기술에 따라 컨볼루션 연산을 수행하는 경우 입력 버퍼의 제한된 크기로 인하여 입력 인덱스의 수집을 전체 입력 데이터 대해 2번에 나누어 수집하게 된다(제1수집(Ta,0=27), 제2수집(Ta=13)). 그리고 이러한 수집 데이터에 기초하여 컨볼루션 연산을 수행하는 경우 도면에 도시된 바와 같이 입력 버퍼에 수집된 입력 인덱스의 개수(Ta)대비 실제로 어레이(array)에서 연산에 사용되는 인덱스(Ta,eff)의 개수가 감소 하게 되므로, 출력 버퍼가 입력 인덱스를 효율적으로 재사용하지 못하게 된다. 즉, 이에 따라 출력 버퍼의 용량을 효율적으로 사용하지 못하게 되므로, 입력 인덱스의 수집 횟수가 증가하게 되고, 이는 웨이트 데이터에 대한 출력 메모리(DRAM)로의 접근(access) 횟수가 증가하게 되어 컨볼루션 연산 속 도가 저해되는 문제점이 발생하게 된다. 그러나, 본 발명에 따라 컨볼루션 연산을 수행하는 경우 도 9에 도시된 바와 같이 웨이트 그룹 단위로 입력 데 이터에서 입력 인덱스를 수집하게 되므로, 더 넓은 인덱스 범위에 대해 데이터를 수집할 수 있게 되며, 이는 입력 인덱스의 수집 횟수 자체를 감소시킬 수 있다. 또한, 이에 따라 입력 버퍼에 수집된 입력 인덱스의 개수(Ta)대비 실제로 어레이(array)에서 연산에 사용되는 인덱스(Ta,eff)의 개수가 거의 동일하게 되므로, 출력 버퍼가 입력 인덱스를 대부분 재사용 할 수 있어, 컨볼루 션 연산의 전체 속도를 높일 수 있는 장점이 존재한다. 도 10은 본 발명에 따른 컨볼루션 연산 방법과 종래 기술에 따른 컨볼루션 연산 방법의 실험 결과를 비교 도시 한 도면으로서, 도 10의 는 종래 기술에 따른 컨볼루션 연산에 따른 실험 결과를 도시한 그래프이고, 도 10 의 는 본 발명에 따라 웨이트 그룹 기반의 컨볼루션 연산에 따른 실험 결과를 도시한 그래프이며, 도 10의 은 본 발명에 따라 웨이트 그룹 기반 및 타일링 최적화 방법을 적용한 컨볼루션 연산에 따른 실험 결과를 도 시한 도면이다. 도 10의 을 참고하면, 종래 기술에 따라 컨볼루션 연산을 하는 경우, 입력 데이터의 재사용 비율이 약 1/4(255/1023) 밖에 되지 않으나, 본 발명에 따라 웨이트 그룹 기반의 컨볼루션 연산을 수행 하는 경우 도 10의 에 도시된 바와 같이 입력 데이터의 재사용 비율이 100%(358/358)임을 알 수 가 있다. 또한, 본 발명에 따른 타일링 기법까지 더 적용하여 컨볼루션 연산을 수행하는 경우, 도 10의 에 도시된 바 와 같이 입력 데이터의 재사용 비율이 100%(716/716)일 뿐만 아니라, 입력 인덱스의 수집 범위도 넓어져 보다 빠르게 연산을 수행할 있는 장점이 존재한다. 도 11은 본 발명의 일 실시예에 따른 데이터 플로우 최적화 모듈이 웨이트 그룹 기반의 분산(scatter) 연산을 수행하는 방법을 설명하기 위한 도면으로서, 구체적으로 컨볼루션 연산 모듈이 디컨볼루션(Deconvolutio n)을 수행할 때, 데이터 플로우 규칙 생성 모듈이 생성하는 데이터 플로우 규칙을 설명하기 위한 도면이다. 디컨볼루션의 경우에는 앞서 설명한 스트라이드 컨볼루션과는 다르게 컨볼루션 연산을 수행함에 있어서, 모든 웨이트 인덱스가 입력 인덱스를 공유하나, 그 특성상 웨이트 인덱스 간에 출력 인덱스에 대한 재사용을 하기가 어렵다. 따라서, 디컨볼루션의 경우에는 입력 데이터를 우선 입력 버퍼에 수집 및 저장을 일시적으로 한 후, 웨이트를 도면에 도시된 바와 같이 일정한 기준 하에 그룹 지어 수집을 하고, 웨이트 그룹에 대한 연산이 끝나면 분산(Scatter) 연산을 하는 방법을 통해 데이터 플로우 규칙을 생성하면, 입력 데이터의 재사용을 최대 화 할 수 있는 장점이 있다. 웨이트 그룹의 크기는 커널의 크기 및 출력 버퍼의 크기에 따라 달라질 수 있는데, 4x4 커널의 경우 16x1, 8x2, 4x4, 2x8, 1x16의 패턴으로 조정이 될 수 있으며, 2x2커널의 경우 4x1, 2x2, 1x4의 패턴으로 조정 이 될 수 있다. 이에 따라 입력 버퍼와 출력 버퍼의 크기 불균형의 영향을 최소화 할 수 있다. 한편, 본 발명에 따른 데이터 플로우 최적화 방법을 이용한 인공신경망 기반의 컨볼루션 연산 장치는, 연산에 있어서 데이터 재사용을 최대화하도록 데이터 플로우를 설정한 이후에, 입력 버퍼와 출력 버퍼의 사용량에 따라 도 5에서 설명하였던 입력 채널과 출력 채널에 대한 타일링 최적화를 수행할 수 도 있다. 컨볼루션 연산의 경우 입력 데이터 내의 희소 입력데이터의 위치 및 분포에 따라 번짐 효과가 달라지므로, 이에 따라 입력 인덱스와 출력 인덱스의 비율이 결정된다. 일 예로, 일반적인 컨볼루션은 그 비율이 1.5 배 이상, 스 트라이드 컨볼루션의 경우 0.5 배, 디컨볼루션의 경우 웨이트의 크기에 따라 1배, 4배 또는 16배로 결정된다. 컨볼루션 연산을 함에 있어서, 특정 버퍼의 사용량이 100%가 되는 경우, 컨볼루션 연산의 속도를 저해하게 되므 로, 출력 버퍼의 사용량이 100%가 되는 경우(즉, 입력 버퍼 사용량이 출력 버퍼에 비해 떨어지는 경우)에는 입 력 채널에 대해 타일 사이즈를 증가시켜 입력 버퍼의 사용량을 증가시키는 방법으로, 버퍼의 사용량으로 인해 연산의 속도가 저해되는 문제점을 방지할 수 있다. 이와 반대로, 입력 버퍼의 사용량이 100%가 되는 경우(즉, 출력 버퍼의 사용량이 입력 버퍼에 비해 떨어지는 경 우)에는, 출력 채널에 대하여 타일 사이즈를 증가시켜 출력 버퍼의 사용량을 증가시키는 방법으로, 버퍼의 사용 량으로 인해 연산의 속도가 저해되는 문제점을 방지할 수 있다. 도 12 및 도 13은 본 발명에 따른 컨볼루션 연산과 종래 기술에 따른 컨볼루션 연산 속도의 실험 결과를 비교 도시한 도면이다. 도 12를 참고하면, 본 발명에 따른 스트라이드 컨볼루션(Strided Convolution)을 수행하는 경우, 웨이트 그룹 기반의 입력 수집 데이터 플로우를 통하여 입력 데이터의 재사용을 25%에서 최대 100%로 향상시킬 수 있는 것을알 수 있다. 이를 통해 데이터 재사용 감소에 따른 연산의 오버해드(Overhead, 전체 연산 대비 Non-Execution Cycle)가 62.9% 감소(14.1%->4.8%)되는 것을 알 수 있다. 본 발명에 따른 디컨볼루션(Deconvolution)을 수행하는 경우, 웨이트 그룹 기반의 분산(Scatter) 연산을 통해 데이터 플로우를 실행하는 경우, 출력 데이터 재사용과 버퍼 사용량을 최적화할 수 있기 때문에 연산의 오버해 드가 종래 기술에 비해 56.9% 감소(42.7.1->14.5%)되는 것을 알 수 있다. 또한, 본 발명에 따라 타일링 기법을 적용하여 컨볼루션 연산을 수행하는 경우, 고정된 버퍼 사이즈를 갖는 합 성곱 처리 장치에서, 계층 별로 연산 특성과 희소성을 고려한 타일링을 통해 번짐 효과에 따른 입력 버퍼와 출 력 버퍼의 사용량 불균형을 개선할 수 있다. 이러한 방법을 통해 연산의 오버해드가 20% 감소(4.7*?*되는 것을 알 수 있다. 이를 종합적으로 적용하여 컨볼루션 연산의 전체 속도를 살펴보면, 종래 기술에 따른 데이터 플로우를 적용한 컨볼루션 연산과 본 발명에 따란 데이터 플로우를 적용한 컨볼루션 연산의 경우, 도 13에 도시된 바와 같이 컨 볼루션 연산의 수행 시간을 14.5%의 감소시키는 것을 알 수 있다. 지금까지 도면을 통해 본 발명의 구성 및 프로세스에 대해 자세히 알아보았다. 일 실시예에 따른 희소 입력 데이터의 위치 정보에 기초한 컨볼루션 연산 방법 및 장치는 희소 데이터 기반의 컨볼루션 연산을 수행함에 있어서, 입력 데이터와 출력 데이터의 특징을 고려하여 데이터를 수집하고 재활용하 므로, 종래 기술보다 빠르게 컨볼루션 연산을 수행할 수 있는 장점이 존재한다. 또한, 컨불루션 연산의 경우 그 특성상 중첩되는 계산 과정이 많은데, 본 발명에 따른 컨볼루션 연산 방법은 종 래에 수집하였던 입력 데이터의 정보를 다음 연산에서 재사용하므로, 컨볼루션 연산 자체의 연산 속도를 빠르게 증가시킬 수 있는 장점이 존재한다. 또한, 이러한 특징으로 인해 3차원 공간에 존재하는 객체 인식의 속도를 증가시킬 수 있는바, 고차원 자율 주행 에 필수적인 고속 전방 장애물 인식을 효율적으로 수행할 수 있고, 빠르고 정확한 로봇 네비게이션을 위한 RGB- D 기반의 위치 추정도 효율적으로 수행할 수 있는 장점이 존재한다. 이상에서 설명된 장치는 하드웨어 구성요소, 소프트웨어 구성요소, 및/또는 하드웨어 구성요소 및 소프트웨어 구성요소의 조합으로 구현될 수 있다. 예를 들어, 실시예들에서 설명된 장치 및 구성요소는, 예를 들어, 프로세 서, 컨트롤러, ALU(arithmetic logic unit), 디지털 신호 프로세서(digital signal processor), 마이크로컴퓨 터, FPA(field programmable array), PLU(programmable logic unit), 마이크로프로세서, 또는 명령 (instruction)을 실행하고 응답할 수 있는 다른 어떠한 장치와 같이, 하나 이상의 범용 컴퓨터 또는 특수 목적 컴퓨터를 이용하여 구현될 수 있다. 처리 장치는 운영 체제(OS) 및 운영 체제 상에서 수행되는 하나 이상의 소 프트웨어 애플리케이션을 수행할 수 있다. 또한, 처리 장치는 소프트웨어의 실행에 응답하여, 데이터를 접근, 저장, 조작, 처리 및 생성할 수도 있다. 이해의 편의를 위하여, 처리 장치는 하나가 사용되는 것으로 설명된 경"}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "우도 있지만, 해당 기술분야에서 통상의 지식을 가진 자는, 처리 장치가 복수 개의 처리 요소(processing element) 및/또는 복수 유형의 처리 요소를 포함할 수 있음을 알 수 있다. 예를 들어, 처리 장치는 복수 개의 프로세서 또는 하나의 프로세서 및 하나의 컨트롤러를 포함할 수 있다. 또한, 병렬 프로세서(parallel processor)와 같은, 다른 처리 구성(processing configuration)도 가능하다. 소프트웨어는 컴퓨터 프로그램(computer program), 코드(code), 명령(instruction), 또는 이들 중 하나 이상의 조합을 포함할 수 있으며, 원하는 대로 동작하도록 처리 장치를 구성하거나 독립적으로 또는 결합적으로 (collectively) 처리 장치를 명령할 수 있다. 소프트웨어 및/또는 데이터는, 처리 장치에 의하여 해석되거나 처 리 장치에 명령 또는 데이터를 제공하기 위하여, 어떤 유형의 기계, 구성요소(component), 물리적 장치, 가상 장치(virtual equipment), 컴퓨터 저장 매체 또는 장치에 구체화(embody)될 수 있다. 소프트웨어는 네트워크로 연결된 컴퓨터 시스템 상에 분산되어서, 분산된 방법으로 저장되거나 실행될 수도 있다. 소프트웨어 및 데이터 는 하나 이상의 컴퓨터 판독 가능 기록 매체에 저장될 수 있다. 실시예에 따른 방법은 다양한 컴퓨터 수단을 통하여 수행될 수 있는 프로그램 명령 형태로 구현되어 컴퓨터 판 독 가능 매체에 기록될 수 있다. 상기 컴퓨터 판독 가능 매체는 프로그램 명령, 데이터 파일, 데이터 구조 등을 단독으로 또는 조합하여 포함할 수 있다. 상기 매체에 기록되는 프로그램 명령은 실시예를 위하여 특별히 설계 되고 구성된 것들이거나 컴퓨터 소프트웨어 당업자에게 공지되어 사용 가능한 것일 수도 있다. 컴퓨터 판독 가 능 기록 매체의 예에는 하드 디스크, 플로피 디스크 및 자기 테이프와 같은 자기 매체(magnetic media), CD- ROM, DVD와 같은 광기록 매체(optical media), 플롭티컬 디스크(floptical disK)와 같은 자기-광 매체(magneto-optical media), 및 롬(ROM), 램(RAM), 플래시 메모리 등과 같은 프로그램 명령을 저장하고 수행하도 록 특별히 구성된 하드웨어 장치가 포함된다. 프로그램 명령의 예에는 컴파일러에 의해 만들어지는 것과 같은 기계어 코드뿐만 아니라 인터프리터 등을 사용해서 컴퓨터에 의해서 실행될 수 있는 고급 언어 코드를 포함한다."}
{"patent_id": "10-2023-0061814", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "이상과 같이 실시예들이 비록 한정된 실시예와 도면에 의해 설명되었으나, 해당 기술분야에서 통상의 지식을 가 진 자라면 상기의 기재로부터 다양한 수정 및 변형이 가능하다. 예를 들어, 설명된 기술들이 설명된 방법과 다 른 순서로 수행되거나, 및/또는 설명된 시스템, 구조, 장치, 회로 등의 구성요소들이 설명된 방법과 다른 형태 로 결합 또는 조합되거나, 다른 구성요소 또는 균등물에 의하여 대치되거나 치환되더라도 적절한 결과가 달성될 수 있다. 그러므로, 다른 구현들, 다른 실시예들 및 특허청구범위와 균등한 것들도 후술하는 특허청구범위의 범 위에 속한다."}
{"patent_id": "10-2023-0061814", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 발명의 상세한 설명에서 인용되는 도면을 보다 충분히 이해하기 위하여 각 도면의 간단한 설명이 제공된다. 도 1은 본 발명의 일 실시예에 따라 컨볼루션 연산 장치에 입력되는 입력 데이터의 일 예와 컨볼루션 연산을 수 행하는 커널의 일 예를 도시한 도면이다. 도 2는 종래 기술에 따라 희소 데이터 기반의 컨볼루션 연산을 수행하는 과정을 설명하기 위한 도면이다. 도 3은 종래 기술에 따라 희소 데이터 기반의 컨볼루션 연산을 수행하는 경우 발생하는 문제점을 설명하기 위한 도면이다. 도 4는 본 발명의 일 실시예에 따른 인공신경망을 이용한 희소 데이터 기반의 컨볼루션 연산 장치의 일부 구성 요소를 도시한 블록도이다. 도 5는 본 발명의 일 실시예에 따른 데이터 플로우 최적화 모듈이 타일의 크기를 조정하는 방법을 설명하기 위 한 도면이다. 도 6 및 도 7은 본 발명의 일 실시예에 따른 데이터 플로우 최적화 모듈이 웨이트 그룹 기반의 입력 데이터를 수집하는 방법을 설명하기 위한 도면이다. 도 8과 도 9는 본 발명에 따른 컨볼루션 연산 방법과 종래 기술에 따른 컨볼루션 연산 방법을 비교 설명하기 위 한 도면이다. 도 10은 본 발명에 따른 컨볼루션 연산 방법과 종래 기술에 따른 컨볼루션 연산 방법의 실험 결과를 비교 도시 한 도면이다. 도 11은 본 발명의 일 실시예에 따른 데이터 플로우 최적화 모듈이 웨이트 그룹 기반의 분산(scatter) 연산을 수행하는 방법을 설명하기 위한 도면이다.도 12 및 도 13은 본 발명에 따른 컨볼루션 연산과 종래 기술에 따른 컨볼루션 연산 속도의 실험 결과를 비교 도시한 도면이다."}
