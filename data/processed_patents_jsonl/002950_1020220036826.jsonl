{"patent_id": "10-2022-0036826", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0138777", "출원번호": "10-2022-0036826", "발명의 명칭": "데이터 재구성가능한 스토리지 장치, 전자 시스템 및 그 동작방법", "출원인": "삼성전자주식회사", "발명자": "우상옥"}}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "호스트로부터 커맨드를 수신하고, 소스 데이터 구조로 소스 데이터를 저장하는 스토리지 장치; 및데스티네이션 데이터 구조의 데스티네이션 데이터로 동작하는 컴퓨팅 리소스 장치를 포함하고,상기 스토리지 장치는 상기 소스 데이터 구조의 상기 소스 데이터를 상기 데스티네이션 데이터 구조로 재구성하여 상기 컴퓨팅 리소스 장치로 출력하는 것인, 전자 시스템."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 스토리지 장치는상기 소스 데이터를 저장하는 저장 매체;상기 커맨드를 디코딩하여 소스 어드레스, 상기 소스 데이터 구조, 데스티네이션 어드레스, 상기 데스티네이션데이터 구조를 추출하는 커맨드 디코딩 유닛;상기 데스티네이션 어드레스에 기초하여 상기 소스 어드레스의 액세스 순서를 재배열하여 상기 데스티네이션 어드레스와 상기 재배열된 소스 어드레스를 출력하는 어드레스 제너레이터;상기 저장 매체로부터 상기 재배열된 소스 어드레스에 기초하여 리드된 상기 소스 데이터를 리드하는 데이터 로딩 유닛;상기 소스 데이터의 컴포넌트를 상기 데스티네이션 데이터 구조에 기초하여 상기 데스티네이션 데이터로 재구성하고 저장하는 버퍼; 및상기 데스티네이션 어드레스에 기초하여 상기 버퍼의 상기 데스티네이션 데이터를 상기 컴퓨팅 리소스 장치로출력하는 데이터 전송 유닛을 포함하는, 전자 시스템."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2항에 있어서, 상기 스토리지 장치는상기 컴포넌트별로 매핑되는 상기 데스티네이션 어드레스, 상기 소스 어드레스, 송신 카운트 및 수신 카운트를저장하는 스코어보드를 포함하는, 전자 시스템."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제3항에 있어서, 상기 스코어보드는제1 컴포넌트에 대한 컴포넌트 ID, 상기 데스티네이션 어드레스 및 상기 소스 어드레스를 상기 데이터 로딩 유닛으로 출력하면, 상기 제1 컴포넌트의 송신 카운트를 증가시키고상기 데이터 로딩 유닛으로부터 상기 제1 컴포넌트에 대한 상기 컴포넌트 ID 및 Ack신호를 수신하면, 상기 제1컴포넌트의 수신 카운트를 증가시키는, 전자 시스템."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제2항에 있어서, 상기 데이터 로딩 유닛은상기 재배열된 소스 어드레스를 입력된 순서대로 큐에 저장하고,상기 큐에서 출력된 소스 어드레스에 상응하는 상기 소스 데이터를 상기 저장 매체로부터 리드하고,상기 리드된 소스 데이터를, 상기 데스티네이션 데이터 구조의 상응하는 위치에 컴포넌트 별로 배치하여 상기공개특허 10-2023-0138777-3-버퍼에 저장하는, 전자 시스템."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서, 상기 데이터 로딩 유닛은상기 버퍼에 저장된 상기 데스티네이션 어드레스의 모든 컴포넌트가 채워지면, 상기 데이터 전송 유닛에 완료신호를 보내고 상기 어드레스 제너레이터에 Ack신호로 전송하는, 전자 시스템."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서, 상기 데이터 전송 유닛은상기 버퍼에 저장된 데스티네이션 데이터를 페이지 단위로 상기 컴퓨팅 리소스 장치로 출력하는, 전자 시스템."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제2항에 있어서, 상기 어드레스 제너레이터는상기 커맨드 디코딩 유닛으로부터 상기 데스티네이션 어드레스와 상기 재배열된 소스 어드레스를 수신하고,상기 데스티네이션 어드레스에 기초하여 상기 버퍼에 가용공간이 있는지 확인하고,상기 가용공간이 없는 경우, 상기 재구성 동작을 정지하는 것인, 전자 시스템."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "소스 어드레스에 상응하는 소스 데이터를 저장하는 저장 매체; 및호스트로부터 커맨드를 수신하여 상기 소스 데이터를 리드하고 데스티네이션 데이터로 재구성하여 컴퓨팅 리소스 장치로 출력하는 데이터 재구성 유닛을 포함하고,상기 커맨드는 소스 어드레스, 데스티네이션 어드레스 및 메타 데이터를 포함하고,상기 데이터 재구성 유닛은 소스 데이터 구조로 배열된 상기 소스 데이터의 컴포넌트들을 데스티네이션 데이터구조로 재구성하여 출력하는, 스토리지 장치."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9항에 있어서, 상기 데이터 재구성 유닛은상기 데스티네이션 어드레스에 기초하여 상기 소스 어드레스의 액세스 순서를 재배열하고,상기 저장 매체에서 상기 재배열된 소스 어드레스에 따른 상기 소스 데이터를 리드하고,상기 리드된 소스 데이터를 상기 데스티네이션 어드레스의 컴포넌트별로 저장하는, 스토리지 장치."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제9항에 있어서, 상기 메타 데이터는버텍스의 개수, 속성의 개수, 속성별 컴포넌트 개수, 컴포넌트 사이즈, 상기 소스 데이터의 컴포넌트별 오프셋,상기 소스 데이터의 컴포넌트별 스트라이드, 상기 데스티네이션 데이터의 컴포넌트별 오프셋, 상기 데스티네이션 데이터의 컴포넌트별 스트라이드를 포함하는, 스토리지 장치."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제11항에 있어서, 상기 메타 데이터는 상기 소스 데이터와 상기 데스티네이션 데이터 간 포맷 변환 정보를 더포함하는, 스토리지 장치."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제10항에 있어서, 상기 재배열하는 것은,상기 데스티네이션 어드레스에 기초하여 버퍼에 상기 데스티네이션 데이터를 저장할 수 있는 가용공간이 있는지공개특허 10-2023-0138777-4-확인하고,상기 가용공간이 없는 경우 상기 액세스 순서를 재배열하는 동작을 중단하고,이후 상기 가용공간이 확보된 경우 상기 액세스 순서를 재배열하는 동작을 재개하는, 스토리지 장치."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제10항에 있어서, 상기 데이터 재구성 유닛은상기 컴포넌트 별로 매핑되는 상기 데스티네이션 어드레스, 상기 소스 어드레스, 송신 카운트, 수신 카운트 및유효 정보를 저장하는 스코어보드를 포함하는, 스토리지 장치."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "제14항에 있어서, 상기 송신 카운트는 상기 데스티네이션 어드레스에 상응하는 상기 소스 어드레스에 대한 컴포넌트가 모두 리드되면 업데이트되고,상기 수신 카운트는 상기 데스티네이션 어드레스에 상응하는 상기 소스 어드레스에 대한 컴포넌트가 모두 리드된 후 상기 컴퓨팅 리소스 장치로 출력되면 업데이트되는, 스토리지 장치."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15항에 있어서, 상기 송신 카운트와 상기 수신 카운트가 동일해지면 상기 데스티네이션 어드레스의 상기 컴포넌트의 상기 유효 정보를 업데이트하는, 스토리지 장치."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "호스트 장치로부터 커맨드를 수신하는 단계;상기 커맨드를 디코딩하여, 소스 어드레스, 데스티네이션 어드레스, 데이터 구조에 대한 정보를 추출하는 단계;상기 데스티네이션 어드레스에 기초하여 상기 소스 어드레스의 액세스 순서를 재배열하는 단계;상기 재배열된 소스 어드레스로 소스 데이터를 저장 매체로부터 리드하는 단계;상기 리드된 소스 데이터를 상기 데이터 구조에 기초하여 컴포넌트별로 데스티네이션 데이터로 재구성하는단계; 및상기 재구성된 데스티네이션 데이터를 컴퓨팅 리소스 장치로 출력하는 단계를 포함하는 스토리지 장치의 동작방법."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제17항에 있어서, 상기 데이터 구조에 대한 정보는소스 데이터 구조 및 데스티네이션 데이터 구조 각각에 대한 버텍스의 개수, 속성의 개수, 속성별 컴포넌트 개수, 컴포넌트별 오프셋, 컴포넌트별 스트라이드, 컴포넌트 사이즈를 포함하는 것인, 스토리지 장치의 동작방법."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제17항에 있어서, 상기 스토리지 장치는상기 커맨드에 따른 리퀘스트 ID와 상기 데스티네이션 어드레스 및 상기 소스 어드레스를 매핑하여 컴포넌트별로 재구성된 상기 데스티네이션 데이터를 저장하는 버퍼를 포함하는, 스토리지 장치의 동작방법."}
{"patent_id": "10-2022-0036826", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제17항에 있어서, 상기 재배열하는 단계는상기 데스티네이션 어드레스에 상응하는 상기 소스 어드레스를 입력 큐에 넣고, 상기 입력 큐에 저장된 순서대로 상기 소스 어드레스를 출력하는 것인, 스토리지 장치의 동작방법."}
{"patent_id": "10-2022-0036826", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "데이터 재구성 가능한 스토리지 장치가 제공된다. 스토리지 장치는 소스 어드레스에 상응하는 소스 데이터를 저 장하는 저장 매체 및 호스트로부터 커맨드를 수신하여 상기 소스 데이터를 리드하고 데스티네이션 데이터로 재구 성하여 컴퓨팅 리소스 장치로 출력하는 데이터 재구성 유닛을 포함하고, 상기 커맨드는 소스 어드레스, 데스티네 이션 어드레스 및 메타 데이터를 포함하고, 상기 데이터 재구성 유닛은 소스 데이터 구조로 배열된 상기 소스 데 이터의 컴포넌트들을 데스티네이션 데이터 구조로 재구성하여 출력한다."}
{"patent_id": "10-2022-0036826", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 발명은 스토리지 장치, 특히 비휘발성 메모리 장치를 포함하는 스토리지 시스템에 관한 것이다."}
{"patent_id": "10-2022-0036826", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "스토리지 장치에서 프로세싱 장치로 데이터 전송시 호스트 장치를 거치지 않고 스토리지 장치에서 프로세싱 장 치로 직접 전송하는 기술들이 대두되고 있다. 프로세싱 장치들의 특성에 따라 스토리지 장치에 저장된 데이터의 데이터 구조와 다른 구조(heterogeneous structure)를 갖는 데이터를 이용하는 경우가 점점 늘고 있다. 프로세싱 장치의 동작 특성에 따라 데이터 구조는 프로세싱 장치 및/또는 스토리지 장치의 성능에 영향을 미친 다. SIMD(Single Instruction Multiple Data) 시스템에서는 AoS(Array of Sturcture) 구조의 데이터보다 SoA(Structure of Array) 구조의 데이터가 효율적인 메모리 액세스를 가능하게 한다. 스토리지 장치는 이종 데이터 구조를 갖는 프로세싱 장치가 데이터를 읽기 위해 액세스하는 경우, 이종 데이터 구조로 인하여 메모리 액세스 패턴의 복잡도가 증가할 수 있고, 이는 장치의 성능 및 전력의 비효율을 초래한다."}
{"patent_id": "10-2022-0036826", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 발명이 해결하려는 과제는 스토리지 장치와 이종 데이터 구조를 갖는 컴퓨팅 리소스 장치에 적응적으로 데이 터 구조를 재구성하여 데이터를 제공함으로써 동작 성능이 향상된 스토리지 장치를 제공하는 것이다. 스토리지 장치와 이종 데이터 구조를 갖는 컴퓨팅 리소스 장치에 스토리지가 적응적으로 데이터 구조를 재구성 하여 데이터를 제공함으로써 동작 성능이 향상된 전자 시스템을 제공하는 것이다."}
{"patent_id": "10-2022-0036826", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 2, "content": "본 발명이 해결하려는 과제들은 이상에서 언급한 과제들로 제한되지 않으며, 언급되지 않은 또 다른 과제들은 아래의 기재로부터 당업자에게 명확하게 이해될 수 있을 것이다."}
{"patent_id": "10-2022-0036826", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "상기 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 전자 시스템은 호스트로부터 커맨드를 수신하고, 소 스 데이터 구조로 소스 데이터를 저장하는 스토리지 장치 및 데스티네이션 데이터 구조의 데스티네이션 데이터 로 동작하는 컴퓨팅 리소스 장치를 포함하고, 상기 스토리지 장치는 상기 소스 데이터 구조의 상기 소스 데이터 를 상기 데스티네이션 데이터 구조로 재구성하여 상기 컴퓨팅 리소스 장치로 출력한다. 상기 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 스토리지 장치는 소스 어드레스에 상응하는 소스 데 이터를 저장하는 저장 매체 및 호스트로부터 커맨드를 수신하여 상기 소스 데이터를 리드하고 데스티네이션 데 이터로 재구성하여 컴퓨팅 리소스 장치로 출력하는 데이터 재구성 유닛을 포함하고, 상기 커맨드는 소스 어드레 스, 데스티네이션 어드레스 및 메타 데이터를 포함하고, 상기 데이터 재구성 유닛은 소스 데이터 구조로 배열된 상기 소스 데이터의 컴포넌트들을 데스티네이션 데이터 구조로 재구성하여 출력한다. 상기 과제를 해결하기 위한 본 발명의 몇몇 실시예에 따른 스토리지 장치의동작 방법은 호스트 장치로부터 커맨 드를 수신하는 단계, 상기 커맨드를 디코딩하여, 소스 어드레스, 데스티네이션 어드레스, 데이터 구조에 대한 정보를 추출하는 단계, 상기 데스티네이션 어드레스에 기초하여 상기 소스 어드레스의 액세스 순서를 재배열하 는 단계, 상기 재배열된 소스 어드레스로 소스 데이터를 저장 매체로부터 리드하는 단계, 상기 리드된 소스 데 이터를 상기 데이터 구조에 기초하여 컴포넌트별로 데스티네이션 데이터로 재구성하는 단계 및 상기 재구성된 데스티네이션 데이터를 컴퓨팅 리소스 장치로 출력하는 단계를 포함한다."}
{"patent_id": "10-2022-0036826", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "상세한 설명에서 사용되는 \"부(unit)\", \"모듈(module)\" 등과 같은 용어들 또는 도면에 도시된 기능 블록들은 특 정 기능을 수행하도록 구성된 하드웨어, 소프트웨어, 또는 그것의 조합의 형태로 구현될 수 있다. 이하에서, 설명의 편의를 위해 스토리지 장치에 저장된 데이터는 제1 데이터 구조 또는 소스 데이터 구조를 갖 는 소스 데이터라고 호칭하고, 컴퓨팅 리소스 장치에서 이용되는 데이터는 제2 데이터 구조 또는 데스티네 이션 데이터 구조를 갖는 데스티네이션 데이터라고 호칭한다. 또한 소스 데이터에 상응하는 어드레스는 소스 어 드레스, 데스티네이션 데이터에 상응하는 어드레스는 데스티네이션 어드레스로 호칭한다. 이러한 호칭은 설명의 편의를 위한 것일 뿐 본 발명의 범위가 이에 한정되는 것은 아니며, 본 발명의 기술적 사상에 동일하거나 균등 한 범위에서 다른 명칭으로 호칭될 수 있음은 자명하다 할 것이다. 이하에서, 도 1 내지 도 13을 참조하여, 본 발명의 몇몇 실시예에 따른 스토리지 장치 및 전자 시스템에 대해서 설명한다. 도 1은 몇몇 실시예에 따른 본 발명의 전자 시스템을 도시한 것이다. 도 1을 참조하면, 전자 시스템은 스토리지 장치, 호스트 장치, 적어도 하나의 컴퓨팅 리소스 장치 를 포함할 수 있다. 전자 시스템은 반도체 시스템에서 다양한 기능을 수행하도록 설계될 수 있으며, 예를 들어 드론(drone), 첨 단 운전자 보조 시스템(Advanced Drivers Assistance System; ADAS) 등과 같은 로봇 장치, 스마트 TV, 스마트 폰, 의료 디바이스, 모바일 디바이스, 영상 표시 디바이스, 계측 디바이스, IoT(Internet of Things) 디바이스 등과 같은 다양한 연산 기능을 수행하는 컴퓨팅 장치들 중 하나에 적용될 수 있으며, 이 외에도 다양한 종류의 전자 디바이스들 중 적어도 하나에 탑재될 수 있다. 호스트 장치는 몇몇 실시예에 따르면, 전자 시스템의 전반적인 동작, 보다 구체적으로는 전자 시스템 을 이루는 다른 구성요소들의 동작을 제어할 수 있다. 호스트 장치는 예를 들면 범용 프로세서, 전용 프 로세서 또는 애플리케이션 프로세서 등으로 구현될 수 있다. 호스트 장치는 하나 이상의 CPU 코어를 포함할 수 있고, 스토리지 장치를 제어하기 위한 호스트 컨트롤러(미도시) 등을 더 포함할 수 있다. 실시예에 따라 서는 호스트 장치는 AI(artificial intelligence) 데이터 연산 등 고속 데이터 연산을 위한 전용 회로인 가 속기(accelerator) 블록을 더 포함할 수도 있다. 또는 몇몇 실시예에 따라 호스트 장치는 CPU(Central Processing Unit), 프로세서, 마이크로프로세서 또는 어플리케이션 프로세서(Application Processor, AP) 등에 해당할 수 있다. 몇몇 실시예에 따라, 호스트 장치 는 시스템 온 칩(System-On-a-Chip, SoC)으로 구현될 수 있다. 호스트 장치는 예를 들면, 기본적으로 휴대용 통신 단말기(mobile phone), 스마트폰(smart phone), 태블릿 PC(tablet personal computer), 웨어러블 기기, 헬스케어 기기 또는 IOT(internet of things) 기기와 같은 모바일(mobile) 시스템, 또는 개인용 컴퓨터 (personal computer), 랩탑(laptop) 컴퓨터, 서버(server), 미디어 재생기(media player) 또는 내비게이션 (navigation)과 같은 차량용 장비(automotive device) 등이 될 수도 있다. 또한 호스트 장치는 통신 장치 (미도시)를 포함하여, 다양한 통신 규약에 따라 호스트 장치 외부의 다른 장치들과의 사이에서 신호의 송수신을 수행할 수 있다. 통신 장치는 유선 또는 무선 연결을 수행하는 장치로 예를 들면 안테나, 트랜시버 및/또 는 모뎀 등을 포함하여 구현될 수 있다. 호스트 장치는 통신 장치를 통해 예를 들면 이더넷 네트워크나 무 선 통신이 가능할 수 있다. 컴퓨팅 리소스 장치는 스토리지 장치에서 데이터를 수신하여 프로세싱 하는 장치로서, 수신된 데이터를 저장하는 캐시 메모리, 휘발성 메모리 또는 비휘발성 메모리 등을 포함할 수 있다. 몇몇 실시예에 따라 컴퓨팅 리소스 장치는 프로세싱 유닛(processing unit), 프로세싱 유닛에 포함된 복수의 코어들(cores), MFC(Multi-Format Codec), 비디오 모듈(예컨대, 카메라 인터페이스(camera interface), JPEG(Joint Photographic Experts Group) 프로세서, 비디오 프로세서(video processor), 또는 믹서(mixer) 등), 3D 그래픽 코어(graphic core), 오디오 시스템(audio system), 드라이버(driver), 디스플레이 드라이버(display driver), 휘발성 메모리(volatile memory), 비휘발성 메모리(non-volatile memory), 메모리 컨트롤러(memory controller), 입출력 인터페이스 블록(input and output interface block), 또는 캐시 메모리(cache memory) 등을 포함할 수 있다. 일 실시예로 컴퓨팅 리소스 장치는 이종 데이터 구조를 갖는 데스티네이션 데이터를 처리하는 GPU(Graphic Processing Unit), NPU(Neural Processing Unit) 등일 수 있다. 스토리지 장치는 호스트 장치로부터 커맨드(CMD)를 수신하여 커맨드에 상응하는 동작을 수행할 수 있다. 일 실시예에 따라 커맨드(CMD)는 스토리지 장치에 저장된 소스 데이터를 리드하여, 리드된 데이터를 컴퓨팅 리소스 장치로 전송하는 동작에 대한 것일 수 있다. 또는 다른 실시예에 따라 커맨드(CMD)는 호스트 장치에서 전송된 데이터를 스토리지 장치에 소스 데이터로 라이트하는 동작에 대한 것일 수 있다. 스토리지 장치는 소스 어드레스에 상응하는 소스 데이터를 리드하고, 데이터를 수신할 데스티네이션 컴퓨팅 리소스 장치의 데이터 구조에 따라 데이터 컴포넌트를 재구성한다. 스토리지 장치는 재구성된 데이터, 즉 데스티네이션 데이터를 데스티네이션 어드레스에 상응하는 컴퓨팅 리소스 장치로 출력한다. 몇몇 실시예 에 따라 스토리지 장치는 데이터 재구성 유닛 및 저장 매체를 포함할 수 있다. 저장 매체는 소스 데이터를 저장한다. 소스 데이터는 소스 어드레스(시작 소스 어드레스 및 마지막 소스 어드레스)에 기초한 저장 매체 내 위치에 소스 데이터 구조로 저장된다. 데이터 재구성 유닛은 호스트 장치로부터 수신한 커맨드(CMD)를 디코딩하고, 데스티네이션 어드레스에 상응하도록 소스 어드레스의 순서를 재배열하고, 재배열된 소스 어드레스에 기초하여 저장 매체에 액세스 하여 소스 데이터를 리드한다. 소스 데이터는 속성에 따른 컴포넌트 별로 리드되고, 데스티네이션 데이터 구조 에 따라 리드된 컴포넌트가 배치되어 데스티네이션 데이터로 재구성된다. 데이터 재구성 유닛은 컴퓨팅 리 소스 장치의 데스티네이션 어드레스로 재구성된 데스티네이션 데이터를 전송한다. 몇몇 실시예에 따라 데이터 재구성 유닛은 스토리지 컨트롤러에 포함될 수 있다. 몇몇 실시예에 따라 스토리지 장치는 몇몇 실시예에 따라 데이터 센터일 수도 있고, 인공지능 학습 데이터 장치일 수도 있다. 스마트 스토리지 장치는 프로세싱-인-메모리(PIM, processing in memory) 또는 컴퓨팅 -인-메모리(CIM, computing in memory)와 같이, 연산이 가능하면서도 데이터를 저장할 수 있는 반도체 장치일 수 있다. 몇몇 실시예에 따라 저장 매체는 비휘발성 메모리, SSD(Solid State Drive), 임베디드(embedded) 메모리 및 착탈 가능한 외장(external) 메모리 중 적어도 하나를 포함할 수 있다. 저장 매체가 SSD인 경우, 저장 매체는 NVMe(non-volatile memory express) 표준 또는 CXL(Computer eXpress Link)를 따르는 장치일 수 있다. 저장 매체가 임베디드 메모리 혹은 외장(external) 메모리인 경우, 저장 매체는 UFS(universal flash storage) 혹은 eMMC(embedded multi-media card) 표준을 따르는 장치일 수 있다. 도 2는 일 실시예에 따른 데이터 재구성 유닛을 구체적으로 나타낸 도면이고, 도 3은 다른 실시예에 따른 데이터 재구성 유닛(100')을 구체적으로 나타낸 도면이다. 도 2를 참조하면, 데이터 재구성 유닛은 몇몇 실시예에 따라 커맨드 해석부, 데이터 로딩 유닛, 데이터 전송 유닛 및 버퍼를 포함할 수 있다. 커맨드 해석부는 호스트 장치로부터 커맨드(CMD)를 수신하여 해석한다. 몇몇 실시예에 따라 커맨드 (CMD)는 어드레스 및 메타 데이터를 포함할 수 있다. 일 실시예에 따라 커맨드에 포함된 어드레스는 리드되거나 라이트될 데이터의 시작 어드레스(start address) 및 마지막 어드레스(end address)를 포함할 수 있다. 일 실시 예에 따라 메타 데이터는 데이터 구조에 대한 정보를 포함할 수 있다. 데이터 구조에 대한 정보는 예를 들어 속성의 개수, 속성의 종류, 속성별 컴포넌트의 개수, 오프셋, 스트라이드, 컴포넌트 사이즈 등일 수 있다. 즉, 커 맨드 해석부는 커맨드로부터 소스 어드레스, 소스 데이터 구조, 데스티네이션 어드레스, 데스티네이션 데 이터 구조를 해석할 수 있다. 몇몇 실시예에 따라 데이터 구조에 대한 정보는 포맷 변환 정보를 더 포함할 수도 있다. 포맷 변환 정보는 일 실시예에 따라 소스 데이터의 컴포넌트별 오프셋, 스트라이드 등을 데스티네이션 데이터의 데이터 구조에 따른 오프셋 및 스트라이드로 치환하는 정보일 수 있다. 포맷 변환 정보는 예를 들어 소정의 함수로 구현되는 정보일 수 있고, 또는 기설정된 테이블 형태로 구현되는 정보일 수도 있다. 데이터 로딩 유닛는 스토리지 장치에서 소스 데이터를 리드하여 컴퓨팅 리소스 장치에 적응적으로 데이터 구조를 변경하는 데이터 재구성을 수행한다. 데이터 로딩 유닛은 소스 데이터를 재구성하여 생성되 는 데스티네이션 데이터를 버퍼에 저장한다. 데이터 로딩 유닛는 데스티네이션 어드레스에 기초하여 저장 매체에 액세스할 순서로 소스 어드레스 를 재배열한다. 데이터 로딩 유닛은 재배열된 소스 어드레스의 데이터를 저장 매체로부터 리드하고, 리드된 속성별 컴포넌트를 버퍼에 저장한다. 버퍼는 데스티네이션 어드레스를 저장하고, 상기 데스티네이션 어드레스에 상응하는 데스티네이션 데이터 를 저장한다. 예를 들어 데스티네이션 데이터는 소스 데이터 중 리드된 각 컴포넌트를 데스티네이션 데이터 구 조에 상응하는 속성 및 컴포넌트의 위치에 저장하면서 데이터 구조가 재구성되어 생성된다. 몇몇 실시예에 따라 데이터 로딩 유닛은 소스 데이터의 데이터 구조, 데스티네이션 데이터의 데이터 구조 및 포맷 변환 정보에 기초하여, 재배열된 소스 어드레스의 순서에 따라 리드된 소스 데이터를 데스티네이션 데 이터로 변환할 수 있다. 몇몇 실시예에 따라 데이터 로딩 유닛은 스코어보드를 더 포함할 수 있다. 스코어보드는 데스티네이션 어 드레스에 상응하는 데스티네이션 데이터의 재구성이 완료되었는지 나타낸다. 예를 들어 스코어보드는 데스티네 이션 어드레스 및 상기 데스티네이션 어드레스에 상응하는 소스 어드레스, 속성별 컴포넌트의 수신 완료여부를 체크할 수 있다. 스코어보드에 대해서는 도 3 및 도 10에서 자세히 설명한다. 데이터 전송 유닛은 버퍼에 저장된 데스티네이션 데이터가 완성되면, 버퍼의 데스티네이션 데이 터를 컴퓨팅 리소스 장치로 출력한다. 도 3을 참조하면, 데이터 전송 유닛(100')은 커맨드 디코더, 어드레스 제너레이터, 데이터 로딩 유닛 , 데이터 전송 유닛, 저장 매치 및 버퍼를 포함할 수 있다. 도 3의 데이터 전송 유닛 (100')은 도 2의 데이터 전송 유닛과 비교하여 커맨드 디코더 및 어드레스 제너레이터의 구성이 다를 수 있다. 커맨드 디코더는 호스트 장치로부터 커맨드(CMD)를 수신하여 커맨드를 디코딩한다. 커맨드 디코더 는 커맨드(CMD)에 기초하여 스토리지 장치에서 수행할 동작들에 대한 내부 커맨드(inCMD)를 생성할 수 있다. 내부 커맨드는 저장 매체에 대한 동작, 예를 들어 리드 리퀘스트, 라이트 리퀘스트 등일 수 있다. 커맨드 디코더는 커맨드에 포함된 메타 데이터를 분석한다. 메타데이터에 대해서는 도 2에서 설명된 것과 중복되 므로 이하 설명을 생략한다. 어드레스 제너레이터는 디코딩된 커맨드로부터 소스 어드레스, 데스티네이션 어드레스를 수신한다. 어드레 스 제너레이터는 커맨드 디코더로부터 수신되는 순서대로 소스 어드레스를 저장하지 않고, 데스티네 이션 어드레스의 순서대로 소스 데이터의 컴포넌트를 읽기 위해 소스 어드레스의 순서를 재배열한다. 즉 데스티 네이션 어드레스에 기초하여 소스 어드레스의 순서를 재배열한다. 어드레스 제너레이터는 데스티네이션 어 드레스 및 재배열된 소스 어드레스를 매핑하여 데이터 로딩 유닛으로 출력한다. 몇몇 실시예에 따라 어드레스 제너레이터는 데스티네이션 어드레스를 수신하면 버퍼에 가용 공간 (available space)이 있는지 체크한다. 데이터 로딩 유닛은 버퍼가 비워지면, 저장가능여부를 알리는 플래그 신호를 어드레스 제너레이터로 전송한다. 어드레스 제너레이터는 가용 공간이 없는 경우 소스 어드레스 재배열 동작을 정지하고, 플래그 신호에 기초하여 버퍼에 가용 공간이 생기면, 중지된 동작을 재 개한다. 몇몇 실시예에 따라 어드레스 제너레이터는 스코어보드를 더 포함할 수 있다. 스코어보드는 스토리지 장치 의 데이터 재구성에 대한 요소(factor)들을 식별하고, 각 요소들 중 어떤 요소가 업데이트되었는지 추적하는데 사용될 수 있다. 몇몇 실시예에 따라 스코어보드는 플립플롭들을 사용하여 구현될 수 있다. 몇몇 실시예에 따라 스코어보드는 데스티네이션 어드레스에 상응하는 데스티네이션 데이터의 재구성이 완료되었 는지 나타낸다. 스코어보드는 임의의 수의 엔트리를 포함할 수 있으며, 엔트리들의 수는 실시 예에 따라 다양하 다. 예를 들어 스코어보드는 엔트리로 컴포넌트별로 대응되는 데스티네이션 어드레스, 소스 어드레스, 송신 카 운트, 수신 카운트를 포함하고, 엔트리에 따라 유효 정보를 산출할 수 있다. 데이터 로딩 유닛은 어드레스 제너레이터로부터 데스티네이션 어드레스, 재배열된 소스 어드레스, 소 스 데이터 구조, 데스티네이션 데이터 구조, 포맷 변환 정보 및 내부 커맨드를 수신한다. 데이터 로딩 유닛는 재배열된 소스 어드레스에 상응하는 소스 데이터를 저장 매체에서 리드하여 데이 터 로딩을 수행한다. 예를 들어 데이터 로딩 유닛은 입력 큐(queue)에 재배열된 소스 어드레스를 넣고, 선 입선출의 순서로 입력 큐에서 소스 어드레스를 하나씩 꺼내어 저장 매체로부터 소스 데이터를 리드한다. 데이터 로딩 유닛은 소스 데이터를 리드하기 전에, 데스티네이션 어드레스에 기초하여 버퍼에 가용공 간이 있는지 확인한다. 데이터 로딩 유닛은 데스티네이션 시작 어드레스 및 데스티네이션 마지막 어드레스 에 기초하여 데스티네이션 데이터의 크기를 파악할 수 있다. 즉, 데스티네이션 어드레스에 기초해서 파악된 데 스티네이션 데이터의 크기와 버퍼의 남은 공간을 비교하여, 데이터 로딩 동작 및 재구성 동작을 수행할 수 있는지 확인한다. 데스티네이션 데이터의 크기가 버퍼의 남은 공간보다 크면, 데이터 로딩 유닛은 가능 플래그 신호(P)를 어드레스 제너레이터로 전송할 수 있다. 데스티네이션 데이터의 크기가 버퍼 의 남은 공간보다 작으면, 데이터 로딩 유닛은 불가능 플래그 신호(NP)를 어드레스 제너레이터로 전 송할 수 있다. 데이터 로딩 유닛은 어드레스 제너레이터로부터 수신된 데스티네이션 어드레스를 버퍼에 저장할 수 있다. 버퍼는 몇몇 실시예에 따라 데스티네이션 어드레스를 상기 내부 커맨드에 상응하는 리퀘스트 ID(request ID)에 매핑하여 저장할 수 있다. 예를 들어 데이터 로딩 유닛은 소스 데이터를 리드하기 전에, 버퍼에 저장된 소스 어드레스가 상기 입력 큐에서 출력된 소스 어드레스와 같은 경우, 상기 동일한 소스 어드레스에 대한 리퀘스트 ID는 입력 큐에 횟수를 기록하고, 기록된 리퀘스트 ID에 상응하는 데스티네이션 어드 레스를 버퍼에 저장한다. 즉, 버퍼는 리퀘스트 ID와 데스티네이션 어드레스를 매핑하여 기록한다. 데이터 로딩 유닛은 리퀘스트 ID의 소스 어드레스에 상응하는 소스 데이터에 대해 저장 매체로 리드 리퀘스트를 전송하고, 저장 매체는 리드 리퀘스트에 따라 상기 소스 데이터를 컴포넌트별로 리드한다. 데이터 로딩 유닛은 리드된 컴포넌트별로, 버퍼에 기록된 리퀘스트 ID 및 포맷 변환 정보에 상응하여 컴포넌 트를 상응하는 위치에 배치한다. 데이터 로딩 유닛은 컴포넌트 별로 데스티네이셩 데이터 구조의 속성 순 서에 맞게 재구성하여, 데스티네이션 데이터를 생성한다. 소스 데이터와 데스티네이션 데이터의 데이터 구조 차 이 및 재구성에 대해서는 이하 도 4 내지 도 9에서 자세히 설명한다. 일 실시예에 따라 데이터 로딩 유닛은 동일한 리퀘스트 ID에 해당하는 중복된 소스 어드레스에 대해서, 두 번째 리드 리퀘스트부터는 저장 매체로 리드 리퀘스트를 전송하지 않을 수 있다. 이에 따라 데이터 로딩 유닛은 최소의 액세스 횟수로 데스티네이션 데이터를 생성하되, 같은 소스 어드레스의 소스 데이터에 대해 데스티네이션 데이터로 재구성하기 위한 액세스 횟수를 줄일 수 있다. 어드레스 제너레이터는 유효 정보에 기초하여 수신한 데스티네이션 어드레스 중 최소 데스티네이션 어드레 스를 갖는 컴포넌트(예를 들어 Position 컴포넌트)에 대해 아직 리드할 컴포넌트가 있는지 확인한다. 유효 정보 가 유효하지 않음(False, F)이면, 데이터 로딩 유닛에 해당 컴포넌트(예를 들어 Position[0] 컴포넌트라고 하자)에 대한 리드 리퀘스트를 전송한다. 어드레스 제너레이터는 유효 정보가 유효하면(Truth, T), 데스티 네이션 어드레스를 다음 데스티네이션 어드레스로 변경하고 송신 카운트를 업데이트한다(예를 들어 카운트값을 증가시킨다). 데이터 전송 유닛는 저장 매체에서 리드된 상기 Position[0] 컴포넌트를 버퍼에 라이트(write) 하고, 버퍼에 Position 컴포넌트가 모두 라이트되어 유효해지면(즉, 모두 채워지면), 데이터 전송 유닛 으로 전송하고 어드레스 제너레이터에 전송완료를 알리는 Ack신호를 전송한다. 어드레스 제너레이터 는 Ack신호를 수신하면 Ack 신호에 상응하는 해당 컴포넌트(예를 들어 Position)의 수신 카운트를 업데이 트한다. 어드레스 제너레이터는 송신 카운트와 수신 카운트가 같아진 컴포넌트(예를 들어 Position)는 비 활성화한다. 어드레스 제너레이터는 현재 데스티네이션 어드레스의 다른 컴포넌트들에 대해서도 유효정보를 확인하면서 앞서 설명한 과정을 반복하여 데이터 재구성 동작의 진행상황을 확인할 수 있다. 데이터 전송 유닛은 데이터 로딩 유닛으로부터 데스티네이션 데이터 및 데스티네이션 주소를 수신하 여 컴퓨팅 리소스 장치로 전송한다. 도 4 및 도 5는 몇몇 실시예에 따른 소스 데이터 및 데스티네이션 데이터의 데이터 구조를 설명하기 위한 개념 도이다. 설명의 편의를 위해 저장 매체는 도시된 예에서 수평방향으로 소스 데이터를 리드하고, 컴퓨팅 리 소스 장치는 도시된 예에서 수직방향으로 데스티네이션 데이터를 리드한다고 하자. 도 4를 참조하면, 몇몇 실시예에 따른 소스 데이터는 AoS(Array of Sturcture) 구조로 저장될 수 있다. 소스 데 이터는 소스 시작 어드레스인 베이스 어드레스부터 수평방향으로는 속성별로 배열되고 수직방향으로는 해당 속 성의 컴포넌트별로 배열될 수 있다. 도시된 예로 설명하면, 소스 데이터의 데이터 구조는 베이스 어드레스(Base Address)를 기준으로 속성 A, B, C, D, E, F 순으로 수평방향으로 배열되고, 각 속성별 컴포넌트 예를 들어 속성 A에서 컴포넌트 A1, A2, A3, A4 순 으로 수직방향으로 배열된다. 설명의 편의를 위해 하나의 블록(예를 들어 A1)의 수평방향 단위는 1, 수직방향 단위는 1이라고 가정하자. 소스 데이터의 오프셋(offset)은 현재 동작을 수행할 소스 데이터의 시작지점이 베이스 어드레스에서 떨어진 정 도를 지칭할 수 있다. 예를 들면 속성 A의 컴포넌트 A1과 A2의 어드레스 간 수직방향 거리를 오프셋이라고 할 수 있다. 도시된 예에서 컴포넌트 A2의 오프셋은 베이스 어드레스로부터 1, 컴포넌트 A3의 오프셋은 베이스 어 드레스로부터 2일 수 있다. 소스 데이터의 스트라이드(Stride)는 저장 매체의 리드 동작 또는 라이트 동작 단위가 되는 거리로써, 현 재 소스 어드레스의 제1 소스 데이터의 시작점과 다음 소스 어드레스의 제2 소스 데이터의 시작점 간의 거리를 지칭할 수 있다. 예를 들면 제1 소스 데이터는 컴포넌트 A1 내지 M1을 포함하고, 제2 소스 데이터는 컴포넌트 A2 내지 M2를 포함하여, 스트라이드는 A1부터 M1까지의 거리를 의미할 수 있다. 도시된 예에서 제1 소스 데이터 에서 컴포넌트 A1의 스트라이드는 7(A1 내지 M1)일 수 있다. 도 5를 참조하면, 데스티네이션 데이터의 데이터 구조는 소스 데이터와 다를 수 있다. 몇몇 실시예에 따른 데스 티네이션 데이터는 SoA(Sturcture of Array) 구조로 저장될 수 있다. 데스티네이션 데이터는 데스티네이션 시작 어드레스인 베이스 어드레스부터 수평방향으로는 속성의 컴포넌트별로 배열되고 수직방향으로는 속성별로 배열 될 수 있다. 데스티네이션 데이터의 오프셋(offset)은 수평방향으로 산정된다. 예를 들어 베이스 어드레스로부터 컴포넌트 A1의 오프셋은 0이고, 컴포넌트 A2의 오프셋은 1이며 컴포넌트 A3의 오프셋은 2일 수 있다. 데스티네이션 데이터의 스트라이드는 컴퓨팅 리소스 장치의 리드 동작이 수직방향이 되므로, 컴포넌트 A1, B1, C1의 방향인 수직방향으로 산정될 수 있다. 몇몇 실시예에 따라 호스트 장치에서 전송하는 커맨드(CMD)는 소스 어드레스, 데스티네이션 어드레스, 및 메타 데이터를 포함할 수 있고, 메타 데이터는 데이터 구조의 변경을 위한 리드 동작 또는 라이트 동작을 위한 소스 어드레스의 시작 어드레스 및 마지막 어드레스, 데이터 구조에 대한 정보를 포함할수 있다. 데이터 구조 정보는 일 실시예에 따라 데이터 내 속성의 종류, 속성의 개수, 속성에 포함된 컴포넌트의 개수, 오프셋 정보, 스트라이드 정보를 포함할 수 있다. 데이터 재구성 유닛은 도 4의 소스 데이터를 도 5의 데스티네이션 데이터로 데이터 구조를 변경하는 데이 터 재구성 동작을 수행할 수 있다. 보다 구체적으로 도 6 내지 도 9를 일 실시예로 설명한다. 도 6은 일 실시예에 따른 소스 데이터의 데이터 구조를 설명하기 위한 개념도이고 도 7은 일 실시예에 따른 데 스티네이션 데이터의 데이터 구조를 설명하기 위한 개념도이다. 일 실시예에 따라 컴퓨팅 리소스 장치가 GPU(Graphic Processing Unit)이라고 하자. 저장 매체에 저장되는 소스 데이터는 도 6과 같은 구조를 가질 수 있다. 소스 데이터는 버텍스(vertex)t가 수직방향을 기준으로 배치되어 있고, 제1 속성의 컴포넌트들(Px,Py,Pz), 제2 속성의 컴포넌트들(R, G, B), 제3 속성의 컴포넌트들(Nx,Ny,Nz), 제4속성의 컴포넌트들(S1,S2), 제5 속성의 컴포넌트들(T1, T2)가 버텍스(verte x)를 기준으로 수평방향으로 배치된 구조를 가질 수 있다. 소스 데이터는 버텍스(vertex)를 기준으로 하여 동작한다. 컴퓨팅 리소스 장치에서 이용되는 데스티네이션 데이터는 도 7과 같은 구조를 가질 수 있다. 데스티네이션 데이터는 버텍스(vertex)t가 수평방향을 기준으로 배치되어 있고, 도 6에서 설명한 제1 내지 제5 속성의 컴포넌 트들이 버텍스(vertex)를 기준으로 수직방향으로 배치된 구조를 가질 수 있다. 제1 속성의 컴포넌트들(VC_Data)은 소스 데이터의 가시성(visibility) 체크 데이터일 수 있다. 컴퓨팅 리소스 장치는 소스 데이터가 화면에 보이는지 판단하기 위해 버텍스(vertex)_0, 버텍스(vertex)_1, 버텍스 (vertex)_2의 제1 속성의 컴포넌트들을 필요로 한다. 한편 저장 매체는 동작방식에 따라 수평방향으로 데 이터를 리드하면 캐시라인(cacheline) 단위로 리드한다. 즉, 저장 매체는 각 버텍스(vertex)마다 가시성 체크 데이터(VC_Data) 뿐 아니라 해당 버텍스(vertex)의 나머지 데이터(R 내지 T2)까지 리드한다. 저장 매체에서 리드된 소스 데이터 그대로 전송할 경우 컴퓨팅 리소스 장치가 요청하는 가시성 데이터 (VC_Data)를 전송하기 위해, 저장 매체는 매 버텍스(vertex)마다 액세스하면서 비가시성데이터를 포함한 전체 소스 데이터(T_Data)를 리드해야 한다. 그러나 몇몇 실시예에 따른 도 1의 스토리지 장치는 소스 데이터를 데스티네이션 데이터의 데이터 구조에 적응적으로 데이터 재구성을 수행하여, 비가시성데이터를 포함한 전체 소 스 데이터를 수차례 반복하지 않고 필요한 속성의 데이터를 최소 액세스로 출력한다. 도 8은 도 6의 실시예에 따른 소스 데이터의 데이터 구조를 테이블 형태로 나타낸 것이고, 도 9는 도 7의 실시 예에 따른 데스티네이션 데이터의 데이터 구조를 테이블 형태로 나타낸 것이다. 몇몇 실시예에 따라 스토리지 장치가 수신하는 커맨드는 도 8에 도시된 것과 같은 메타 데이터를 수신한다. 도시된 예에서 메타 데이터는 버텍스(vertex)가 100개(2000byte), 각 버텍스(vertex)는 20byte이고, 속성이 3 개인 소스 데이터를 가진다. 제1 속성(1st attribute)는 3개의 컴포넌트를 포함하고, 제2 속성(2nd attribute)은 4개의 컴포넌트를 포함하고, 제3 속성(3rd attribute)은 2개의 컴포넌트를 포함한다. 또한 속성별 컴포넌트의 오 프셋, 스트라이드 및 컴포넌트 사이즈를 포함한다. 예를 들어 제1 속성은 도 6과 대비하면, Px, Py, Pz에 해당하는 위치데이터에 대응될 수 있다. 제1 속성의 첫번 째 컴포넌트 Position[0]은 도 6의 Px(버텍스(vertex)_0)에 대응될 수 있고, 베이스 어드레스를 가지므로 오프 셋은 0byte이고, 다음 오프셋 컴포넌트 Px(버텍스(vertex)_1)까지의 스트라이드는 20byte이며, Px의 컴포넌트 사이즈는 2byte이다. 제1 속성의 두번째 컴포넌트 Position[1]는 도 6의 Px(버텍스(vertex)_1)에 대응될 수 있 고, 베이스 어드레스로부터의 오프셋이 2byte이고, 다음 오프셋 컴포넌트 Px(버텍스(vertex)_2)까지의 스트라이 드는 20byte이며, Px의 컴포넌트 사이즈는 2byte이다. 마찬가지로 제2 속성의 첫번째 컴포넌트 Color[0]는 도 6의 R(버텍스(vertex)_0)에 대응될 수 있고, 베이스 어 드레스로부터의 오프셋이 8byte이고, 다음 오프셋 컴포넌트 R(버텍스(vertex)_1)까지의 스트라이드는 20byte이 며, R의 컴포넌트 사이즈는 1byte이다. 제3 속성의 첫번째 컴포넌트 Normal[1]은 도 6의 텍스쳐 좌표 T(버텍스(vertex)_0)에 대응될 수 있고, 베이스 어드레스로부터의 오프셋이 16byte이고, 다음 오프셋 컴포넌트 T(버텍스(vertex)_1)까지의 스트라이드는 20byte 이며, T의 컴포넌트 사이즈는 4byte이다. 한편 같은 방식으로 데스티네이션 데이터의 데이터 구조를 표현할 수 있다. 도 9를 참조하면, 데스티네이션 데 이터 역시 메타 데이터에서 소스 데이터와 공통적으로 버텍스(vertex)가 100개(2000byte), 각 버텍스(vertex)는 20byte이고, 속성이 3개인 소스 데이터를 가진다. 즉, 제1 속성(1st attribute)는 3개의 컴포넌트를 포함하고, 제2 속성(2nd attribute)은 4개의 컴포넌트를 포함하고, 제3 속성(3rd attribute)은 2개의 컴포넌트를 포함한다. 또한 속성별 컴포넌트의 오프셋, 스트라이드 및 컴포넌트 사이즈를 포함한다. 다만 도 8과 도 9는 버텍스(vertex)의 방향이 달라서 컴포넌트별 오프셋, 스트라이드가 달라질 수 있다. 예를 들어 제1 속성의 첫번째 컴포넌트 Position[0]은 도 7의 Px(버텍스(vertex)_0)에 대응될 수 있고, 베이스 어드 레스를 가지므로 오프셋은 0byte이고, 다음 오프셋 컴포넌트 Px(버텍스(vertex)_1)까지의 스트라이드는 0byte이 며, Px의 컴포넌트 사이즈는 2byte이다. 제1 속성의 두번째 컴포넌트 Position[1]는 도 7의 Px(버텍스 (vertex)_1)에 대응될 수 있고, 베이스 어드레스로부터의 오프셋이 200byte이고, 다음 오프셋 컴포넌트 Px(버텍 스(vertex)_2)까지의 스트라이드는 00byte이며, Px의 컴포넌트 사이즈는 2byte이다. 마찬가지로 제2 속성의 첫번째 컴포넌트 Color[0]는 도 7의 R(버텍스(vertex)_0)에 대응될 수 있고, 베이스 어 드레스로부터의 오프셋이 800byte이고, 다음 오프셋 컴포넌트 R(버텍스(vertex)_1)까지의 스트라이드는 0byte이 며, R의 컴포넌트 사이즈는 1byte이다. 제3 속성의 첫번째 컴포넌트 Normal[1]은 도 7의 텍스쳐 좌표 T(버텍스(vertex)_0)에 대응될 수 있고, 베이스 어드레스로부터의 오프셋이 1600byte이고, 다음 오프셋 컴포넌트 T(버텍스(vertex)_1)까지의 스트라이드는 0byte이며, T의 컴포넌트 사이즈는 4byte이다. 즉, 저장 매체는 커맨드(CMD)로부터 소스 데이터와 데스티네이션 데이터의 어드레스뿐 아니라 도 6 내지 도 9에서 설명한 데이터 구조에 대한 정보를 기초로 버퍼에 데이터 재구성을 하여 저장하고, 버퍼는 재구성된 데스티네이션 데이터를 저장하였다가 기설정된 단위(예를 들어 페이지 단위(page granularity))가 되면 컴퓨팅 리소스 장치로 출력한다. 몇몇 실시예에 따라, 저장 매체는 데이터 재구성을 하기 위한 포맷 변환 정보를 더 포함할 수 있다. 일 실 시예에 따라 포맷 변환 정보는 소스 데이터와 데스티네이션 데이터 간의 오프셋 차이, 스트라이드 차이에 대한 테이블 형태의 정보일 수 있다. 예를 들어 스토리지 장치는 소스 데이터와 데스티네이션 데이터 간의 속성 종류, 속성 개수, 속성별 컴포넌트 수, 오프셋, 스트라이드, 컴포넌트 사이즈가 서로 매핑된 포맷변환 테이블을 저장하고, 커맨드에 포함된 포맷 변환 정보를 추출하여, 포맷변환 테이블에서 추출된 포맷 변환 정보에 기초한 값들을 기초로 데이터 재구성을 수행할 수 있다. 다른 실시예에 따라 포맷전환정보는 소스 데이터와 데스티네이션 데이터 간의 오프셋 차이, 스트라이드 차이에 대한 연산식 또는 함수 형태의 정보일 수 있다. 예를 들어 스토리지 장치는 소스 데이터와 데스티네이션 데 이터 간의 속성 종류, 속성 개수, 속성별 컴포넌트 수, 오프셋, 스트라이드, 컴포넌트 사이즈에 대한 함수 또는 연산식을 저장하고, 커맨드에 포함된 포맷 변환 정보를 추출하여, 추출된 정보를 함수 또는 연산식에 적용하여 데이터 재구성을 수행할 수도 있다. 도 10은 몇몇 실시예에 따른 스코어보드를 설명하기 위한 테이블이다. 도 10을 참고하면, 데이터 로딩 유닛(120, 도 2 또는 도 3)은 스코어보드를 더 포함할 수 있다. 스코어보드는 스토리지 장치의 데이터 재구성에 대한 요소(factor)들을 식별하고, 각 요소들 중 어떤 요소가 업데이트되 었는지 추적하는데 사용될 수 있다. 몇몇 실시예에 따라 스코어보드는 플립플롭들을 사용하여 구현될 수 있다. 스코어보드는 데스티네이션 어드레스에 상응하는 데스티네이션 데이터의 재구성이 완료되었는지 나타낸다. 몇몇 실시예에 따라 스코어보드는 엔트리로 컴포넌트 ID(identifier), 데스티네이션 어드레스, 소스 어드레스, 송신 카운트, 수신 카운트, 유효 정보를 포함할 수 있다. 데이터 로딩 유닛은 스코어보드를 기초로 데이터 재구 성 동작의 진행상황을 확인하여 데스티네이션 데이터를 컴퓨팅 리소스 장치로 전송할 수 있다. 구체적으로 설명하면, 스토리지 장치가 커맨드를 수신하면, 스코어 보드는 커맨드의 디코딩 결과로 속성별 컴포넌트 ID, 데스티네이션 어드레스 및 상응하는 소스 어드레스를 기록한다. 스토리지 장치는 데스티네이 션 어드레스 중 어느 하나의 데스티네이션 어드레스(예을 들어 Destination Addr 0)를 갖는 컴포넌트들이 모두 리드되었으면, 현재 데스티네이션 어드레스에 대한 데이터 재구성 동작은 완료되었다고 보고, 다음 데스티네이 션 어드레스(Destination Addr 200)에 대한 데이터 재구성 동작을 시작하면서 송신 카운트를 업데이트한다(예를 들어 Destination Addr 200의 Sending count를 0에서 1로 업데이트). 데이터 재구성 유닛은 버퍼에서 상기 재구성 완료된 데스티네이션 데이터를 데이터 전송 유닛으 로 전송하고, 데이터 전송 유닛은 상기 전송된 데스티네이션 데이터를 수신하면, 데이터 로딩 유닛은 Ack신호를 발생하여 스코어보드는 수신 카운트를 업데이트한다(예를 들어 Destination Addr 200의 Receiving count를 0에서 1로). 스코어보드는 송신 카운트와 수신 카운트가 동일해지면(Sending count=Receiving count=1), 해당 데스티네이션 어드레스(예를 들어 Destination Addr 200)에 속한 컴포넌트들(예를 들어 Position[1] 등)는 재구성 완료된 것으로 보고 유효 정보를 업데이트(F에서 T로 변경)한다. 이러한 기준으로 모든 컴포넌트들의 모든 값들이 모두 채워지면 데스티네이션 어드레스에 대해 유효 정보 모두 가 T가 되므로, 스토리지 장치는 데이터 재구성이 완료되었다고 판단할 수 있다. 이러한 판단에 따라 스토 리지 장치는 다시 다음 데스티네이션 어드레스로 변경하면서 앞서 설명한 과정을 다시 반복할 수 있다. 도 11은 몇몇 실시예에 따른 스토리지 장치의 동작방법을 설명하는 흐름도이다. 도 12는 몇몇 실시예에 따른 스 토리지 장치의 동작방법을 설명하는 흐름도이다. 도 11 및 도 12를 참조하면, 스토리지 장치는 호스트 장치로부터 전송된 커맨드를 수신한다(S10, S20). 스토리지 장치는 커맨드를 디코딩하여 소스 어드레스, 데스티네이션 어드레스 및 메타 데이터를 추출할 수 있다. 메타 데이터는 소스 데이터 구조 및 데스티네이션 데이터 구조를 포함할 수 있다. 몇몇 실시예에 따라 메 타 데이터는 소스 데이터 및 데스티네이션 데이터 각각의 버텍스(vertex) 개수, 속성 개수, 속성별 컴포넌트 개 수, 오프셋, 스트라이드 및 컴포넌트 사이즈를 포함할 수 있다. 스토리지 장치는 데스티네이션 어드레스에 기초하여 소스 어드레스의 순서를 재배열한다(S30). 스토리지 장 치는 몇몇 실시예에 따라 소스 어드레스의 순서를 재배열시 데스티네이션 데이터의 사이즈에 기초하여 버퍼 에 가용 공간이 있는지 체크할 수 있다. 도 12를 참조하면, 일 실시예에 따라 스토리지 장치는 데스티 네이션 어드레스의 시작 어드레스 및 마지막 어드레스, 그리고 데스티네이션 데이터 구조에 기초하여, 데이터 재구성할 데스티네이션 데이터의 크기를 계산하여 버퍼의 현재 가용공간과 비교한다(S110). 만약 충분한 가용공간이 없는 경우(S120, N), 스토리지 장치는 소스 어드레스 재배열 동작(S110)을 잠시 정 지할 수 있다. 이후 버퍼에 가용공간이 확보되면 소스 어드레스 재배열 동작(S110)을 재개한다. 버퍼(30 0)에 충분한 가용공간이 있는 경우(S120, Y), 스토리지 장치는 해당 가용공간을 확보하고(S130), 저장 매체 로부터 소스 데이터(F1)를 리드하여(S40) 컴포넌트별로 데스티네이션 데이터(F2)를 재구성한다(S50). 스 토리지 장치는 버퍼의 확보된 가용공간에 재구성된 데스티네이션 데이터(F2)를 저장한다(S140, S60). 스토리지 장치는 현재 데스티네이션 어드레스에 대한 컴포넌트가 모두 채워질 때까지(S150, N) S140 동작을 반복할 수 있다. 이후 스토리지 장치는 현재 데스티네이션 어드레스에 대한 모든 컴포넌트가 채워지면 (S150, Y), 상기 현재 데스티네이션 어드레스에 대한 데스티네이션 데이터를 컴퓨팅 리소스 장치로 전송한 다(S160, S70). 컴퓨팅 리소스 장치는 데스티네이션 데이터를 수신한다(S80). 도 13은 몇몇 실시예에 따른 스토리지(storage) 장치가 적용된 시스템을 도시한 도면이다. 도 13의 시스템은 기본적으로 휴대용 통신 단말기(mobile phone), 스마트폰(smart phone), 태블릿 PC(tablet personal computer), 웨어러블 기기, 헬스케어 기기 또는 IOT(internet of things) 기기와 같은 모 바일(mobile) 시스템일 수 있다. 하지만 도 13의 시스템은 반드시 모바일 시스템에 한정되는 것은 아니고, 개인용 컴퓨터(personal computer), 랩탑(laptop) 컴퓨터, 서버(server), 미디어 재생기(media player) 또는 내비게이션(navigation)과 같은 차량용 장비(automotive device) 등이 될 수도 있다. 도 13을 참조하면, 시스템은 메인 프로세서(main processor), 메모리(1200a, 1200b) 및 스토리지 장치(1300a, 1300b)를 포함할 수 있으며, 추가로 촬영 장치(image capturing device), 사용자 입력 장치 (user input device), 센서, 통신 장치, 디스플레이, 스피커, 전력 공급 장치 (power supplying device) 및 연결 인터페이스(connecting interface), GPU, NPU 중 하나 이상을 포함할 수 있다. 메인 프로세서는 시스템의 전반적인 동작, 보다 구체적으로는 시스템을 이루는 다른 구성 요 소들의 동작을 제어할 수 있다. 이와 같은 메인 프로세서는 범용 프로세서, 전용 프로세서 또는 애플리케 이션 프로세서(application processor) 등으로 구현될 수 있다. 메인 프로세서는 하나 이상의 CPU 코어를 포함할 수 있으며, 메모리(1200a, 1200b) 및/또는 스토리 지 장치(1300a, 1300b)를 제어하기 위한 컨트롤러를 더 포함할 수 있다. 실시예에 따라서는, 메인 프로세 서는 AI(artificial intelligence) 데이터 연산 등 고속 데이터 연산을 위한 전용 회로인 가속기 (accelerator) 블록을 더 포함할 수 있다. 이와 같은 가속기 블록은 DPU(Data Processing Unit) 등을 포함할 수 있으며, 메인 프로세서의 다른 구성 요소와는 물리적으로 독립된 별개의 칩(chip)으로 구 현될 수도 있다. 메모리(1200a, 1200b)는 시스템의 주기억 장치로 사용될 수 있으며, SRAM 및/또는 DRAM 등의 휘발성 메모 리를 포함할 수 있으나, 플래시 메모리, PRAM 및/또는 RRAM 등의 비휘발성 메모리를 포함할 수도 있다. 메모리 (1200a, 1200b)는 메인 프로세서와 동일한 패키지 내에 구현되는 것도 가능하다. 스토리지 장치(1300a, 1300b)는 전원 공급 여부와 관계없이 데이터를 저장하는 비휘발성 저장 장치로서 기능할 수 있으며, 메모리(1200a, 1200b)에 비해 상대적으로 큰 저장 용량을 가질 수 있다. 스토리지 장치(1300a, 1300b)는 스토리지 컨트롤러(1310a, 1310b)와, 스토리지 컨트롤러(1310a, 1310b)의 제어 하에 데이터를 저장하는 비휘발성(non-volatile memory, NVM) 스토리지(1320a, 1320b)를 포함할 수 있다. 비휘발성 스토리지(1320a, 1320b)는 2D(2-dimensional) 구조 혹은 3D(3-dimensional) 구조의 V-NAND 플래시 메모리를 포함할 수 있으나, PRAM 및/또는 RRAM 등의 다른 종류의 비휘발성 메모리를 포함할 수도 있다. 스토리지 장치(1300a, 1300b)는 도 1 내지 도 12에서 설명한 스토리지 장치일 수 있다. 스토리지 장치(1300a, 1300b)는 메인 프로세서와는 물리적으로 분리된 상태로 시스템에 포함될 수 도 있고, 메인 프로세서와 동일한 패키지 내에 구현될 수도 있다. 또한, 스토리지 장치(1300a, 1300b)는 SSD(solid state device) 혹은 메모리 카드(memory card)와 같은 형태를 가짐으로써, 후술할 연결 인터페이스 와 같은 인터페이스를 통해 시스템의 다른 구성 요소들과 탈부착 가능하도록 결합될 수도 있다. 이 와 같은 스토리지 장치(1300a, 1300b)는 UFS(universal flash storage), eMMC(embedded multi-media card) 혹 은 NVMe(non-volatile memory express)와 같은 표준 규약이 적용되는 장치일 수 있으나, 반드시 이에 한정되는 건 아니다. 촬영 장치는 정지 영상 또는 동영상을 촬영할 수 있으며, 카메라(camera), 캠코더(camcorder) 및/또는 웹 캠(webcam) 등일 수 있다. 사용자 입력 장치는 시스템의 사용자로부터 입력된 다양한 유형의 데이터를 수신할 수 있으며, 터 치 패드(touch pad), 키패드(keyboard), 키보드(keyboard), 마우스(mouse) 및/또는 마이크(microphone) 등일 수 있다. 센서는 시스템의 외부로부터 획득될 수 있는 다양한 유형의 물리량을 감지하고, 감지된 물리량을 전기 신호로 변환할 수 있다. 이와 같은 센서는 온도 센서, 압력 센서, 조도 센서, 위치 센서, 가속도 센 서, 바이오 센서(biosensor) 및/또는 자이로스코프(gyroscope) 등일 수 있다. 통신 장치는 다양한 통신 규약에 따라 시스템 외부의 다른 장치들과의 사이에서 신호의 송신 및 수 신을 수행할 수 있다. 이와 같은 통신 장치는 안테나, 트랜시버(transceiver) 및/또는 모뎀(MODEM) 등을 포함하여 구현될 수 있다. 디스플레이 및 스피커는 시스템의 사용자에게 각각 시각적 정보와 청각적 정보를 출력하는 출력 장치로 기능할 수 있다. 전력 공급 장치는 시스템에 내장된 배터리(도시 안함) 및/또는외부 전원으로부터 공급되는 전력을 적절히 변환하여 시스템의 각 구성 요소들에게 공급할 수 있다. 연결 인터페이스는 시스템과, 시스템에 연결되어 시스템(1000과 데이터를 주고받을 수 있는 외부 장치 사이의 연결을 제공할 수 있다. 연결 인터페이스는 ATA(Advanced Technology Attachment), SATA(Serial ATA), e-SATA(external SATA), SCSI(Small Computer Small Interface), SAS(Serial Attached SCSI), PCI(Peripheral Component Interconnection), PCIe(PCI express), NVMe(NVM express), IEEE 1394, USB(universal serial bus), SD(secure digital) 카드, MMC(multi-media card), eMMC(embedded multi-media card), UFS(Universal Flash Storage), eUFS(embedded Universal Flash Storage), CF(compact flash) 카드 인 터페이스 등과 같은 다양한 인터페이스 방식으로 구현될 수 있다. GPU는 OpenGL ES 및 OpenCL (CUDA)등의 그래픽스 API를 처리하여 전자장치에서 화려한 그래픽스 효과를 구현할 수 있다. GPU는 몇몇 실시예에 따라 CPU로부터 어드레스를 수신하고, 수신된 어드레스를 이 용하여 스토리지 장치(1300a, 1300b) 중 어느 하나의 스토리지 장치에서 데이터를 리드하고, 데이터에 대한 그 래픽 프로세싱을 수행할 수 있다. 스토리지 장치(1300a, 1300b)는 CPU 또는 GPU로부터 출력된 리 드 리퀘스트에 응답하여, 적어도 하나의 비휘발성 메모리(1320a, 1320b)에 저장된 데이터(예를들어 그래픽스 데 이터)를 리드하고, 리드된 데이터를 대응되는 구성(1100 또는 1500)에 전송할 수 있다. 스토리지 장치(1300a, 1300b)는 CPU 또는 GPU로부터 출력된 라이트 리퀘스트에 요청하여 대응되는 구성(1100 또는 150 0)으로부터 출력된 데이터(예를 들어 그래픽스 데이터)를 비휘발성 메모리(1320a, 1320b)에 라이트할 수 있다. GPU는 몇몇 실시예에 따라 하나 이상의 GPU 코어 및 GPU 메모리를 포함할 수 있다. GPU 코 어는 프로그래밍 가능한 고도의 병렬 연산 엔진세트들 및 다양한 고정기능 유닛들을 포함할 수 있다. GPU 메모리는 스토리지 장치(1300a, 1300b)에서 전송되거나 전송하기 위한 데이터를 저장하거나 GPU 코어 에서 처리되는 데이터를 저장할 수 있다. 신경망 처리 장치(Neural Processing Unit; NPU, 1600)는 인공지능 관련 병렬 연산에 최적화된 프로세서일 수 있다. NPU는 메인 프로세서를 대신하거나, 지원하여 보안 데이터 또는 멀티미디어 데이터 또는 소 정 목적의 데이터 등의 처리 동작을 수행하기 위한 프로세싱 장치로서, 예를 들면 텍스트, 오디오, 정지 영상들, 애니메이션, 비디오, 2차원 데이터 또는 다차원 데이터 등의 처리 성능을 향상시키기 위한 IP(Intellectual Property)로 제공될 수 있다. NPU는 신경망 연산을 수행하는 NPU 코어 및 NPU 코 어가 처리하는 데이터를 저장하는 NPU 메모리를 포함할 수 있다. 몇몇 실시예에 따라 GPU, NPU는 스토리지 장치(1300a, 1300b)와 다른 데이터 구조를 가질 수 있고, 이 경우 앞서 설명한 몇몇 실시예들에 따른 스토리지 장치 및 그 동작방법이 이용될 수 있다."}
{"patent_id": "10-2022-0036826", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "이상 첨부된 도면을 참조하여 본 발명의 실시예를 설명하였지만, 본 발명이 속하는 기술분야에서 통상의 지식을 가진 자는 본 발명이 그 기술적 사상이나 필수적인 특징을 변경하지 않고서 다른 구체적인 형태로 실시될 수 있 다는 것을 이해할 수 있을 것이다. 그러므로 이상에서 기술한 실시예들은 모든 면에서 예시적인 것이며 한정적 이 아닌 것으로 이해해야만 한다."}
{"patent_id": "10-2022-0036826", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 몇몇 실시예에 따른 본 발명의 전자 시스템을 도시한 것이다. 도 2는 일 실시예에 따른 데이터 재구성 유닛을 구체적으로 나타낸 도면이다. 도 3은 다른 실시예에 따른 데이터 재구성 유닛(100')을 구체적으로 나타낸 도면이다.도 4 및 도 5는 몇몇 실시예에 따른 소스 데이터 및 데스티네이션 데이터의 데이터 구조를 설명하기 위한 개념 도이다. 도 6은 일 실시예에 따른 소스 데이터의 데이터 구조를 설명하기 위한 개념도이다. 도 7은 일 실시예에 따른 데스티네이션 데이터의 데이터 구조를 설명하기 위한 개념도이다. 도 8은 도 6의 실시예에 따른 소스 데이터의 데이터 구조를 테이블 형태로 나타낸 것이다. 도 9는 도 7의 실시예에 따른 데스티네이션 데이터의 데이터 구조를 테이블 형태로 나타낸 것이다. 도 10은 몇몇 실시예에 따른 스코어보드를 설명하기 위한 테이블이다. 도 11은 몇몇 실시예에 따른 스토리지 장치의 동작방법을 설명하는 흐름도이다. 도 12는 몇몇 실시예에 따른 스토리지 장치의 동작방법을 설명하는 흐름도이다. 도 13은 몇몇 실시예에 따른 스토리지(storage) 장치가 적용된 시스템을 도시한 도면이다."}
