{"patent_id": "10-2024-0000282", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0022592", "출원번호": "10-2024-0000282", "발명의 명칭": "고정된 디멘젼 및 코드 길이를 갖는 일반화된 계층적 연결 코드들", "출원인": "삼성전자주식회사", "발명자": "도브착, 아리엘"}}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "복수의 코드워드들을 저장하는 스토리지 장치; 및정보 비트들을 획득하고, 복수의 내부 코드워드들을 획득하기 위해 내부 코드를 사용하여 상기 정보 비트들을 인코딩하고, 외부 코드워드를 생성하기 위해 외부 코드를 사용하여 상기 복수의 내부 코드워드들을 인코딩하고, 상기 외부 코드워드를 상기 스토리지 장치에 저장하는 적어도 하나의 프로세서를 포함하고, 상기 내부 코드 및 상기 외부 코드 중 적어도 하나는 일반화된 연결 코드(generalized concatenatedcode)(GCC)를 포함하고, 상기 외부 코드워드는 계층적-GCC(hierarchical-GCC)(H-GCC) 코드워드를 포함하는 스토리지 시스템."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서, 상기 H-GCC 코드워드는 복수의 프레임들을 포함하고, 상기 복수의 프레임들의 각 프레임은 동일한 길이를 갖고, 상기 복수의 프레임들의 상기 각 프레임은 상기 내부 코드에 기초하여 생성된 동일한 수의 로컬 패리티 비트들을 포함하고, 상기 복수의 프레임들의 상기 각 프레임은 상기 외부 코드에 기초하여 생성된 동일한 수의 글로벌 패리티 비트들을 포함하는 스토리지 시스템."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2 항에 있어서, 상기 복수의 프레임들의 상기 각 프레임은,상기 스토리지 장치에 포함된 상응하는 랜덤 액세스 유닛(random access unit)(RAU)에 저장되는 스토리지 시스템."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1 항에 있어서, 상기 내부 코드는 상기 GCC를 포함하고, 상기 내부 코드의 구성 코드들은 폴라 코드 및 제1 리드-솔로몬(Reed-Solomon)(RS) 코드를 포함하고, 상기 외부 코드는 제2 RS 코드를 포함하는 스토리지 시스템."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1 항에 있어서, 상기 내부 코드는 폴라 코드를 포함하고, 상기 외부 코드는 상기 GCC를 포함하고, 상기 외부 코드의 구성 코드들은 제1 RS 코드 및 제2 RS 코드를 포함하는 스토리지 시스템."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "공개특허 10-2025-0022592-3-제5 항에 있어서, 상기 외부 코드워드는 복수의 프레임들을 포함하고, 상기 정보 비트들을 인코딩하기 위해, 상기 적어도 하나의 프로세서는, 로컬 패리티 비트들을 생성하기 위해 상기 폴라 코드를 상기 정보 비트들에 적용하고, 상기 로컬 패리티 비트들을 상기 복수의 내부 코드워드들에 배치하고, 상기 복수의 내부 코드워드들을 인코딩하기 위해, 상기 적어도 하나의 프로세서는, 변환 공간에서 복수의 심볼들의 집합들을 생성하기 위해 제1 변환을 상기 복수의 내부 코드워드들에 적용하고―상기 복수의 심볼들의 집합들 중 각 심볼들의 집합은 상기 복수의 내부 코드워드들 중 하나의 내부 코드워드에 상응함―, 상기 복수의 심볼들의 집합들을 상기 외부 코드워드로 그룹화하고, 글로벌 패리티 비트들을 생성하기 위해 상기 제1 RS 코드 및 상기 제2 RS 코드를 상기 외부 코드워드에 적용하고, 상기 H-GCC 코드워드를 생성하기 위해 상기 글로벌 패리티 비트들을 상기 복수의 내부 코드워드들에 배치하는스토리지 시스템."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6 항에 있어서, 상기 복수의 내부 코드워드들은 제1 내부 코드워드 및 제2 내부 코드워드를 포함하고, 상기 복수의 심볼들의 집합들은 상기 제1 내부 코드워드에 기초하여 생성된 제1 심볼들의 집합을 포함하고, 상기 제1 심볼들의 집합은 상기 글로벌 패리티 비트들 중 적어도 하나의 제1 글로벌 패리티 비트를 생성하기 위해 사용되고, 상기 적어도 하나의 제1 글로벌 패리티 비트는 상기 폴라 코드를 상기 제2 내부 코드워드에 적용하기 위해 사용되는 스토리지 시스템."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제6 항에 있어서, 상기 복수의 심볼들의 집합들은 상기 제1 RS 코드 및 상기 제2 RS 코드가 적용되기 전에 퍼뮤테이션되는(permutated) 스토리지 시스템."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "스토리지 장치의 스토리지를 위한 정보 비트들을 인코딩하기 위한 장치로서, 상기 스토리지 장치와 통신하는 메모리 인터페이스; 및정보 비트들을 획득하고, 복수의 폴라 코드워드들을 획득하기 위해 폴라 코드를 사용하여 상기 정보 비트들을 인코딩하고, 계층적-GCC(H-GCC)를 획득하기 위해 일반화된 연결 코드(GCC)를 사용하여 상기 복수의 폴라 코드워드들을 인코딩하고―상기 GCC의 구성 코드들은 제1 RS 코드 및 제2 RS 코드를 포함함―,상기 스토리지 장치에 상기 H-GCC 코드워드를 전송하기 위해 상기 메모리 인터페이스를 제어하는 적어도 하나의프로세서를 포함하는 장치."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9 항에 있어서, 상기 H-GCC 코드워드는 복수의 프레임들을 포함하고, 공개특허 10-2025-0022592-4-상기 복수의 프레임들의 각 프레임은 동일한 길이를 갖고,상기 복수의 프레임들의 상기 각 프레임은 상기 폴라 코드에 기초하여 생성된 동일한 수의 로컬 패리티 비트들을 포함하고, 상기 복수의 프레임들의 상기 각 프레임은 상기 GCC에 기초하여 생성된 동일한 수의 글로벌 패리티 비트들을 포함하는 장치."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제10 항에 있어서, 상기 복수의 프레임들의 상기 각 프레임은, 상기 스토리지 장치에 포함된 상응하는 랜덤 액세스 유닛(RAU)에 저장되는 장치."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제9 항에 있어서, 상기 H-GCC 코드워드는 복수의 프레임들을 포함하고, 상기 정보 비트들을 인코딩하기 위해, 상기 적어도 하나의 프로세서는, 로컬 패리티 비트들을 생성하기 위해 상기 폴라 코드를 상기 정보 비트들에 적용하고, 상기 로컬 패리티 비트들을 상기 복수의 폴라 코드워드들에 배치하고, 상기 복수의 폴라 코드워드들을 인코딩하기 위해, 상기 적어도 하나의 프로세서는, 변환 공간에서 복수의 심볼들의 집합들을 생성하기 위해 변환을 상기 복수의 폴라 코드워드들에 적용하고―상기 복수의 심볼들의 집합들 중 각 심볼들의 집합은 상기 복수의 폴라 코드워드들 중 하나의 폴라 코드워드에 상응함―, 상기 복수의 심볼들의 집합들을 그룹화하고, 글로벌 패리티 비트들을 생성하기 위해 상기 제1 RS 코드 및 상기 제2 RS 코드를 상기 그룹화된 복수의 심볼들의 집합들에 적용하고, 상기 H-GCC 코드워드를 생성하기 위해 상기 글로벌 패리티 비트들을 상기 복수의 폴라 코드워드들에 배치하는장치."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제12 항에 있어서,상기 복수의 폴라 코드워드들은 제1 폴라 코드워드 및 제2 폴라 코드워드를 포함하고, 상기 복수의 심볼들의 집합들은 상기 제1 폴라 코드워드에 기초하여 생성된 제1 심볼들의 집합을 포함하고, 상기 제1 심볼들의 집합은 상기 글로벌 패리티 비트들 중 적어도 하나의 제1 글로벌 패리티 비트를 생성하기 위해 사용되고, 상기 적어도 하나의 제1 글로벌 패리티 비트는 상기 폴라 코드를 상기 제2 폴라 코드워드에 적용하기 위해 사용되는 장치."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제12 항에 있어서, 상기 복수의 심볼들의 집합들은 상기 제1 RS 코드 및 상기 제2 RS 코드가 적용되기 전에 퍼뮤테이션되는 장치."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "적어도 하나의 프로세서에 의해 실행되는, 스토리지 시스템의 제어 방법으로서, 정보 비트들을 획득하는 단계; 공개특허 10-2025-0022592-5-복수의 내부 코드워드들을 획득하기 위해 내부 코드를 사용하여 상기 정보 비트들을 인코딩하는 단계; 외부 코드워드를 생성하기 위해 외부 코드를 사용하여 상기 복수의 내부 코드워드들을 인코딩하는 단계; 및상기 외부 코드워드를 스토리지 장치에 저장하는 단계를 포함하고, 상기 내부 코드 및 상기 외부 코드 중 적어도 하나는 일반화된 연결 코드(GCC)를 포함하고, 상기 외부 코드워드는 계층적-GCC(H-GCC) 코드워드를 포함하는 스토리지 시스템의 제어 방법."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15 항에 있어서, 상기 H-GCC 코드워드는 복수의 프레임들을 포함하고, 상기 복수의 프레임들의 각 프레임은 동일한 길이를 갖고, 상기 복수의 프레임들의 상기 각 프레임은 상기 내부 코드에 기초하여 생성된 동일한 수의 로컬 패리티 비트들을 포함하고, 상기 복수의 프레임들의 상기 각 프레임은 상기 외부 코드에 기초하여 생성된 동일한 수의 글로벌 패리티 비트들을 포함하는 스토리지 시스템의 제어 방법."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16 항에 있어서, 상기 복수의 프레임들의 상기 각 프레임은,상기 스토리지 장치에 포함된 상응하는 랜덤 액세스 유닛(RAU)에 저장되는 스토리지 시스템의 제어 방법."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제16 항에 있어서,상기 내부 코드는 상기 GCC를 포함하고, 상기 내부 코드의 구성 코드들은 폴라 코드 및 제1 RS 코드를 포함하고, 상기 외부 코드는 제2 RS 코드를 포함하는 스토리지 시스템의 제어 방법."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제15 항에 있어서, 상기 내부 코드는 폴라 코드를 포함하고, 상기 외부 코드는 상기 GCC를 포함하고, 상기 외부 코드의 구성 코드들은 제1 RS 코드 및 제2 RS 코드를 포함하는 스토리지 시스템의 제어 방법."}
{"patent_id": "10-2024-0000282", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제19 항에 있어서, 상기 외부 코드는 복수의 프레임들을 포함하고, 상기 정보 비트들을 인코딩하는 단계는, 로컬 패리티 비트들을 생성하기 위해 상기 폴라 코드를 상기 정보 비트들에 적용하는 단계; 및 상기 로컬 패리티 비트들을 상기 복수의 내부 코드워드들에 배치하는 단계를 포함하고, 상기 복수의 내부 코드워드들을 인코딩하는 단계는, 변환 공간에서 복수의 심볼들의 집합들을 생성하기 위해 제1 변환을 상기 복수의 내부 코드워드들에 적용하는단계―상기 복수의 심볼들의 집합들 중 각 심볼들의 집합은 상기 복수의 내부 코드워드들 중 하나의 내부 코드워드에 상응함―;공개특허 10-2025-0022592-6- 상기 복수의 심볼들의 집합들을 상기 외부 코드워드로 그룹화하는 단계; 글로벌 패리티 비트들을 생성하기 위해 상기 제1 RS 코드 및 상기 제2 RS 코드를 상기 외부 코드워드에 적용하는 단계; 및 상기 H-GCC 코드워드를 생성하기 위해 상기 글로벌 패리티 비트들을 상기 복수의 내부 코드워드들에 배치하는단계를 포함하는 스토리지 시스템의 제어 방법."}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "스토리지를 위한 정보 비트들을 인코딩하기 위한 시스템들, 장치들 및 방법들은, 정보 비트들을 획득하는 단계, 복수의 내부 코드워드들을 획득하기 위해 내부 코드를 사용하여 상기 정보 비트들을 인코딩하는 단계, 외부 코드 워드를 생성하기 위해 외부 코드를 사용하여 상기 복수의 내부 코드워드들을 인코딩하는 단계, 및 상기 외부 코 드워드를 스토리지 장치에 저장하는 단계를 포함한다. 상기 내부 코드 및 상기 외부 코드 중 적어도 하나는 일반 화된 연결 코드(GCC)를 포함하고, 상기 외부 코드워드는 계층적-GCC(H-GCC) 코드워드를 포함한다."}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "실시예들과 일치하는 장치들 및 방법들은 스토리지 장치의 관리에 관한 것으로, 특히 일반화된 계층적 연결 코 드들(generalized hierarchical concatenated codes)을 사용하는 오류 정정 코딩(error correction coding)에 관한 것이다."}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "일반적으로, 예를 들어 플래시 메모리 장치들에서 사용될 수 있는 NAND 칩은 워드라인들(WLs)의 블록들을 포함 하는 구조를 가질 수 있고, 각 워드라인은 비트라인들(BLs)을 포함한다. NAND 셀은 워드라인과 비트라인의 교차 점에 형성될 수 있다. 빠른 NAND 액세스를 허용하기 위해, 각 워드라인은 랜덤 액세스 유닛들(random access units)(RAUs)로 분할될 수 있다. 높은 신뢰성의 액세스를 허용하기 위해, 각 RAU는 오류 정정 코드(Error Correction Code)(ECC)로 보 호된다. ECC 코드 길이는 특정 길이를 가질 수 있고, 특정 수의 정보 비트들을 수용할 수 있다. ECC에서는, 코 드가 길어질수록 더 나은 신뢰성을 달성할 수 있고, 더 긴 ECC들을 사용하려는 동기가 된다. 반면 RAU 구조는 ECC 코드들의 길이를 특정 길이로 제한할 수 있다. 따라서 각 RAU에 대해 로컬 ECC를 사용하여 읽기 속도(reading speed)와 디코딩 시간(decoding time)을 유지 및 개선하는 동시에 더 긴 코드율들(code rates)과 연관된 향상된 신뢰성을 달성하는 코딩 방식(coding schem e)가 필요하다."}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시의 일 목적은 높은 처리량을 달성하거나 코딩 이득을 제공하는 스토리지 시스템을 제공하는 것이다. 본 개시의 일 목적은 스토리지 장치의 스토리지를 위한 정보 비트들을 인코딩하기 위한 장치를 제공하는 것이다. 본 개시의 일 목적은 상기 스토리지 시스템의 제어 방법을 제공하는 것이다. 본 개시의 일 목적은 상기 스토리지 장치의 스토리지를 위한 정보 비트들을 인코딩하는 방법을 제공하는 것이다."}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "본 개시의 일 양상에 따르면, 스토리지 시스템은 복수의 코드워드들을 저장하는 스토리지 장치, 및 정보 비트들 을 획득하고 복수의 내부 코드워드들을 획득하기 위해 내부 코드를 사용하여 상기 정보 비트들을 인코딩하고 외 부 코드워드를 생성하기 위해 외부 코드를 사용하여 상기 복수의 내부 코드워드들을 인코딩하고, 상기 외부 코 드워드를 상기 스토리지 장치에 저장하는 적어도 하나의 프로세서를 포함하고, 상기 내부 코드 및 상기 외부 코 드 중 적어도 하나는 일반화된 연결 코드(generalized concatenated code)(GCC)를 포함하고, 상기 외부 코드워 드는 계층적-GCC(hierarchical-GCC)(H-GCC) 코드워드를 포함한다. 본 개시의 일 양상에 따르면, 스토리지 장치의 스토리지를 위한 정보 비트들을 인코딩하기 위한 장치는, 상기 스토리지 장치와 통신하는 메모리 인터페이스, 및 정보 비트들을 획득하고, 복수의 폴라 코드워드들을 획득하기위해 폴라 코드를 사용하여 상기 정보 비트들을 인코딩하고, 계층적-GCC(H-GCC)를 획득하기 위해 일반화된 연결 코드(GCC)를 사용하여 상기 복수의 폴라 코드워드들을 인코딩하고, 상기 GCC의 구성 코드들은 제1 리드-솔로몬 (RS) 코드 및 제2 RS 코드를 포함하고, 상기 스토리지 장치에 상기 H-GCC 코드워드를 전송하기 위해 상기 메모 리 인터페이스를 제어하는 적어도 하나의 프로세서를 포함한다. 본 개시의 일 양상에 따르면, 적어도 하나의 프로세서에 의해 실행되는, 스토리지 시스템의 제어 방법은, 정보 비트들을 획득하는 단계, 복수의 내부 코드워드들을 획득하기 위해 내부 코드를 사용하여 상기 정보 비트들을 인코딩하는 단계, 외부 코드워드를 생성하기 위해 외부 코드를 사용하여 상기 복수의 내부 코드워드들을 인코딩 하는 단계, 및 상기 외부 코드워드를 스토리지 장치에 저장하는 단계를 포함하고, 상기 내부 코드 및 상기 외부 코드 중 적어도 하나는 일반화된 연결 코드(GCC)를 포함하고, 상기 외부 코드워드는 계층적-GCC 코드워드를 포 함한다. 본 개시의 일 양상에 따르면, 스토리지 장치의 스토리지를 위한 정보 비트들을 인코딩하는, 적어도 하나의 프로 세서에 의해 실행되는 방법은, 정보 비트들을 획득하는 단계, 복수의 폴라 코드워드들을 획득하기 위해 폴라 코 드를 사용하여 상기 정보 비트들을 인코딩하는 단계, 계층적-GCC를 획득하기 위해 일반화된 연결 코드를 사용하 여 상기 복수의 폴라 코드워드들을 인코딩하는 단계, 및 상기 H-GCC 코드워드를 상기 스토리지 장치에 전송하는 단계를 포함하고, 상기 GCC의 구성 코드들은 제1 RS 코드 및 제2 RS 코드를 포함한다."}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명의효과", "paragraph": 1, "content": "본 개시의 실시예들은 두 개의 계층들을 포함하는 계층적 ECC 코드와 관련될 수 있고, 이는 계층적으로 일반화 된 연결 코드(H-GCC)로 지칭될 수 있다. H-GCC의 제1 계층은 일반화된 연결 코드(GCC) 및 로컬 패리티 비트들을 사용하여, 고정된 수의 정보 비트들 및 고정된 길이를 갖는 랜덤 액세스 유닛(RAU)을 보호할 수 있다. H-GCC의 제2 계층은 제1 계층을 구성 코드들로서 사용하고, RAU당 추가 글로벌 패리티 비트들을 삽입하는 GCC를 포함할 수 있다. 실시예들에 따른 H-GCC는 높은 처리량과 고정된 정보 및 코드 길이로 RAU를 디코딩할 수 있게 하여 상 대적으로 높은 처리량을 달성하는 반면, 제2 계층은 더 긴 유효 코드 길이로부터 코딩 이득을 제공할 수 있다."}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "플래시 메모리들에서, 데이터는 랜덤 액세스 유닛(random access unit)(RAU)의 단위(granularity)로 저장되고 독출될 수 있다. RAU 데이터에 오류 정정 코드(error correction code)(ECC)가 적용되어 높은 신뢰성으로 빠른 독출을 제공할 수 있다. RAU는 미리 결정된 수의 정보 비트들을 포함할 수 있지만, NAND 구조와 하드웨어 아키 텍쳐는 코딩된 비트들의 수를 제한할 수 있다. 따라서 이 구조는 정보 비트들의 수(K)와 코드 길이(N)에 대한 제약(constraint)을 정의할 수 있다. ECC 코드들은 더 큰 코드 길이에 대해 더 높은 이득을 제공할 수 있으므로, RAU들을 높은 처리량(throughput)과 낮은 복잡성(complexity)으로 독출할 수 있도록, RAU 제약들에도 불구하고 코드 길이를 증가시키는 이점이 있을 수 있다. 따라서 본 개시의 실시예들은 두 개의 계층들(hierarchies)을 포함하는 계층적 ECC 코드와 관련될 수 있고, 이 는 계층적으로 일반화된 연결 코드(hierarchical generalized concatenated code)(H-GCC)로 지칭될 수 있다. 실시예들에서, H-GCC의 제1 계층은 일반화된 연결 코드(generalized concatenated code)(GCC) 및 로컬 패리티 비트들( )을 사용하여, 고정된 수(K)의 정보 비트들 및 고정된 길이(N)를 갖는 RAU를 보호할 수 있다. H-GCC의 제2 계층은 제1 계층을 구성 코드들(constituent codes)로 사용하고, RAU당 추가 글로벌 패리티 비트들(global parity bits)( )을 삽입하는 GCC를 포함할 수 있다. 실시예들에 따른 H-GCC는 높은 처리량과 고정된 정보 및 코드 길이로 RAU를 디코딩할 수 있게 하여 상대적으로 높은 처리량을 달성하는 반면, 제2 계층은 더 긴 유효 코드 길이로부터 코딩 이득을 제공할 수 있다.이하에서 논의되는 실시예들은 H-GCC 코드 구조의 다양한 구성들 및 H-GCC 인코딩 알고리즘들을 사용하여 체계 적(systematic) 인코딩을 수행하는 다양한 방법들과 관련될 수 있다. 실시예들에 따르면, 여기에서 논의되는 H- GCC 코드들의 구성 코드들 및 코드 파라미터들은 다양한 목표들(targets) 예를 들어, 정정 능력 (correctability), 복잡성(complexity), 전력(power) 등에 따라 선택될 수 있다. 도 1은 실시예들이 적용될 수 있는 시스템의 도면이다. 도 1의 시스템은 예를 들어, 휴대용 통신 단말기(예를 들어, 모바일폰), 스마트폰, 태블릿 개인용 컴퓨터(PC), 웨어러블 장치, 헬스케어 장치 또는 사물 인터넷(Internet of Things)(IoT) 장치와 같은 모바일 시스템일 수 있다. 그러나 도 1의 시스템은 반드시 모바일 시스템에만 한정되는 것은 아니며, PC, 노트북 컴퓨터, 서버, 미디어 플레이어 또는 자동차 장치(예를 들어, 네비게이션 장치)가 될 수 있다. 도 1을 참조하면, 시스템은 메인 프로세서, 메모리들(예를 들어, 1200a 및 1200b) 및 스토리지 장치 들(예를 들어, 1300a 및 1300b)을 포함할 수 있다. 또한 시스템은 이미지 캡쳐 장치, 사용자 입력 장치, 센서, 통신 장치, 디스플레이, 스피커, 전원 공급 장치 및 연결 인터페이스 중 적어도 하나를 더 포함할 수 있다. 메인 프로세서는 시스템의 모든 동작들, 보다 구체적으로는 시스템에 포함되는 다른 구성요 소들의 동작들을 제어할 수 있다. 메인 프로세서는 범용 프로세서(general-purpose processor), 전용 프 로세서(dedicated processor) 또는 애플리케이션 프로세서로 구현될 수 있다. 메인 프로세서는 적어도 하나의 CPU 코어를 포함할 수 있고, 메모리들(1200a 및 1200b) 및/또는 스 토리지 장치들(1300a 및 1300b)을 제어하도록 구성된 컨트롤러를 더 포함할 수 있다. 일부 실시예들에서, 메인 프로세서는 가속기를 더 포함할 수 있고, 이는 인공지능(artificial intelligence)(AI) 데이 터 연산과 같은 고속 데이터 연산을 위한 전용 회로일 수 있다. 가속기는 GPU(graphics processing unit), NPU(neural processing unit) 및/또는 DPU(data processing unit)를 포함할 수 있고, 메인 프로세서 의 다른 구성요소들과 물리적으로 분리된 칩으로 구현될 수 있다. 메모리들(1200a 및 1200b)은 시스템의 메인 메모리 장치들로 사용될 수 있다. 메모리들(1200a 및 1200b) 각각은 SRAM(static random access memory) 및/또는 DRAM(dynamic RAM)과 같은 휘발성 메모리를 포함할 수 있 지만, 메모리들(1200a 및 1200b) 각각은 플래시 메모리, PRAM(phase-change RAM) 및/또는 RRAM(resistive RA M)과 같은 비휘발성 메모리를 포함할 수 있다. 메모리들(1200a 및 1200b)은 메인 프로세서와 동일한 패키 지로 구현될 수 있다. 스토리지 장치들(1300a 및 1300b)은 전력이 공급되는지 여부에 관계없이 데이터를 저장하도록 구성된 비휘발성 스토리지 장치들로서 기능할 수 있고, 메모리들(1200a 및 1200b)보다 더 큰 저장 용량을 가질 수 있다. 스토리 지 장치들(1300a 및 1300b)은 스토리지 컨트롤러들(STRG CTRL)(1310a 및 1310b) 및 스토리지 컨트롤러들(1310a 및 1310b)의 제어를 통해 데이터를 저장하도록 구성된 비휘발성 메모리들(NVMs)(1320a 및 1320b)을 포함할 수 있다. NVM들(1320a 및 1320b)은 2차원(2D) 구조 또는 3차원(3D) V-NAND 구조를 가지는 플래시 메모리들을 포함 할 수 있지만, 실시예들은 이에 제한되지 않으며, NVM들(1320a 및 1320b)은 PRAM 및/또는 RRAM과 같은 다른 유 형의 NVM들을 포함할 수 있다. 스토리지 장치들(1300a 및 1300b)은 메인 프로세서로부터 물리적으로 분리될 수 있고, 시스템에 포 함되거나 메인 프로세서와 동일한 패키지로 구현될 수 있다. 또한 스토리지 장치들(1300a 및 1300b)은 SSD들 또는 메모리 카드들의 유형들을 가질 수 있고, 아래에 설명되는 연결 인터페이스와 같은 인터페이 스를 통해 시스템의 다른 구성요소들과 제거가능하게 결합될 수 있다. 스토리지 장치들(1300a 및 1300b) 은 UFS(universal flash storage), eMMC(embedded multi-media card) 또는 NVMe(non-volatile memory express)와 같은 표준 프로토콜이 적용되는 장치들일 수 있으나, 이에 제한되지 않는다. 이미지 캡쳐 장치는 정지 이미지들 또는 움직이는 이미지들을 캡쳐할 수 있다. 이미지 캡쳐 장치는 카메라, 캠코더 및/또는 웹캠(webcam)을 포함할 수 있다. 사용자 입력 장치는 시스템의 사용자에 의해 다양한 유형의 데이터 입력을 수신할 수 있고, 터치 패드, 키패드, 키보드, 마우스 및/또는 마이크를 포함할 수 있다. 센서는 시스템의 외부로부터 획득될 수 있는 다양한 유형들의 물리량들을 검출할 수 있고, 검출된 물리량들을 전기 신호들로 변환할 수 있다. 센서는 온도 센서, 압력 센서, 조도 센서, 위치 센서, 가속도센서, 바이오 센서 및/또는 자이로스코프 센서를 포함할 수 있다. 통신 장치는 다양한 통신 프로토콜들에 따라 시스템의 외부의 다른 장치들 사이에 신호들을 송신 및 수신할 수 있다. 통신 장치는 안테나, 트랜시버 및/또는 모뎀을 포함할 수 있다. 디스플레이 및 스피커는 시스템의 사용자에게 시각 정보 및 청각 정보를 각각 출력하도록 구 성된 출력 장치들로서 기능할 수 있다. 전원 공급 장치는 시스템에 내장된 배터리 및/또는 외부 전원으로부터 공급된 전력을 적절하게 변 환하고, 변환된 전력을 시스템의 구성요소들 각각으로 공급할 수 있다. 연결 인터페이스는 시스템과 시스템에 연결되고 시스템과 데이터를 송수신할 수 있는 외부 장치 사이의 연결을 제공할 수 있다. 연결 인터페이스는 ATA(advanced technology attachment), SATA(serial ATA), e-SATA(external SATA), SCSI(small computer small interface), SAS(serial attached SCSI), PCI(peripheral component interconnection), PCIe(PCI express), NVMe, IEEE 1394, USB(universal serial bus) 인터페이스, SD(secure digital) 카드 인터페이스, MMC(multi-media card) 인터페이스, eMMC 인터 페이스, UFS 인터페이스, eUFS(embedded UFS) 인터페이스 및 CF(compact flash) 카드 인터페이스와 같은 다양 한 인터페이스 방식들을 사용하여 구현될 수 있다. 도 2a는 예시적인 실시예들에 따른, 호스트 스토리지 시스템의 블록도이다. 호스트 스토리지 시스템은 호스트 및 스토리지 장치를 포함할 수 있다. 또한 스토리지 장치(20 0)는 스토리지 컨트롤러 및 NVM을 포함할 수 있다. 예시적인 실시예에 따르면, 호스트는 호스트 컨트롤러 및 호스트 메모리를 포함할 수 있다. 호스트 메모리는 스토리지 장치로 전송될 데이터 또는 스토리지 장치로부터 수신될 데이터를 일시적으로 저장하도록 구성되는 버퍼 메모리로서 기능 할 수 있다. 스토리지 장치는 호스트로부터의 요청에 응답하여 데이터를 저장하도록 구성된 스토리지 매체를 포함 할 수 있다. 예를 들어, 스토리지 장치는 SSD, 임베디드 메모리 및 이동식 외장 메모리 중 적어도 하나를 포함할 수 있다. 스토리지 장치이 SSD인 경우, 스토리지 장치는 NVMe 표준을 준수하는 장치일 수 있 다. 스토리지 장치가 임베디드 메모리 또는 외장 메모리인 경우, 스토리지 장치는 UFS 표준 또는 eMMC 표준을 준수하는 장치일 수 있다. 호스트 및 스토리지 장치 각각은 채택된 표준 프로토콜에 따 라 패킷을 생성하고, 패킷을 전송할 수 있다. 스토리지 장치의 NVM이 플래시 메모리를 포함하는 경우, 플래시 메모리는 2D NAND 메모리 어레이 또 는 3D(또는 수직) NAND(VNAND) 메모리 어레이를 포함할 수 있다. 다른 예로서, 스토리지 장치는 다양한 다 른 종류의 NVM들을 포함할 수 있다. 예를 들어, 스토리지 장치는 MRAM(magnetic RAM), 스핀-전달 토크 MRAM, CBRAM(conductive bridging RAM), FRAM(ferroelectric RAM), PRAM, RRAM 및 다양한 다른 종류의 메모리 들을 포함할 수 있다. 실시예들에 따르면, 호스트 컨트롤러 및 호스트 메모리는 별도의 반도체 칩들로 구현될 수 있다. 대 안적으로, 일부 실시예들에서, 호스트 컨트롤러 및 호스트 메모리는 동일한 반도체 칩에 집적될 수 있다. 예를 들어, 호스트 컨트롤러는 애플리케이션 프로세서(AP)에 포함되는 복수의 모듈들 중 어느 하나 일 수 있다. AP는 시스템 온 칩(SoC)으로 구현될 수 있다. 또한 호스트 메모리는 AP에 포함된 임베디드 메 모리 또는 AP의 외부에 위치한 NVM 또는 메모리 모듈일 수 있다. 호스트 컨트롤러는 호스트 메모리의 버퍼 영역의 데이터(예를 들어, 기입 데이터)를 NVM에 저장 하는 동작 또는 NVM의 데이터(예를 들어, 독출 데이터)를 버퍼 영역에 저장하는 동작을 관리할 수 있다. 스토리지 컨트롤러는 호스트 인터페이스, 메모리 인터페이스 및 CPU를 포함할 수 있다. 또 한 스토리지 컨트롤러는 플래시 변환 레이어(flash translation layer)(FTL), 패킷 매니저, 버 퍼 메모리, ECC 엔진 및 AES(advanced encryption standard) 엔진을 더 포함할 수 있다. 스토 리지 컨트롤러는 FTL이 로딩되는 작업 메모리를 더 포함할 수 있다. CPU는 FTL을 실행하여 NVM에 대한 데이터 기입 및 독출 동작들을 제어할 수 있다. 호스트 인터페이스는 호스트와 패킷들을 송수신할 수 있다. 호스트로부터 호스트 인터페이스 로 전송된 패킷은 명령 또는 NVM에 기입될 데이터를 포함할 수 있다. 호스트 인터페이스로부터 호스트로 전송된 패킷은 명령에 대한 응답 또는 NVM로부터 독출된 데이터를 포함할 수 있다. 메모리인터페이스는 NVM에 기입될 데이터를 NVM으로 전송하거나 NVM으로부터 독출된 데이터를 수 신할 수 있다. 메모리 인터페이스는 Toggle 또는 ONFI(open NAND flash interface)와 같은 표준 프로토콜 을 준수하도록 구성될 수 있다. FTL은 주소 맵핑 동작, 웨어-레벨링 동작 및 가비지 컬렉션 동작과 같은 다양한 기능들을 수행할 수 있다. 주소 맵핑 동작은 호스트로부터 수신된 논리 주소를 NVM에 데이터를 실제로 저장하기 위해 사용되는 물리 주소로 변환하는 동작일 수 있다. 웨어-레벨링 동작은 NVM의 블록들이 균일하게 사용되도록 함으로써 특정 블록의 과도한 열화를 방지하기 위한 기술일 수 있다. 예를 들어, 웨어-레벨링 동작은 물리 블록들의 소거 횟수들의 균형을 맞추는 펌웨어 기술을 사용하여 구현될 수 있다. 가비지 컬렉션 동작은 기존 블록의 유효 데이 터를 새로운 블록에 복사한 후 기존 블록을 소거함으로써 NVM의 가용 용량을 확보하기 위한 기술일 수 있 다. 패킷 매니저는 호스트가 승낙한 인터페이스의 프로토콜에 따라 패킷을 생성하거나 호스트로부터 수신된 패킷으로부터 다양한 유형의 정보를 파싱(parsing)할 수 있다. 또한 버퍼 메모리는 NVM에 기 입될 데이터 또는 NVM로부터 독출될 데이터를 일시적으로 저장할 수 있다. 버퍼 메모리는 스토리지 컨트롤러에 포함된 구성요소일 수 있지만, 버퍼 메모리는 스토리지 컨트롤러의 외부에 위치할 수도 있다. ECC 엔진은 NVM으로부터 독출된 독출 데이터에 대한 오류 검출 및 정정 연산들을 수행할 수 있다. 보 다 구체적으로, ECC 엔진은 NVM에 기입될 기입 데이터에 대해 패리티 비트들을 생성할 수 있고, 생성 된 패리티 비트들은 기입 데이터와 함께 NVM에 저장될 수 있다. NVM으로부터 데이터를 독출하는 동안, ECC 엔진은 독출 데이터와 함께 NVM으로부터 독출된 패리티 비트들을 사용하여 독출 데이터의 오류를 정정하고, 오류-정정된 독출 데이터를 출력할 수 있다. AES 엔진은 대칭 키(symmetric-key) 알고리즘을 사용하여 스토리지 컨트롤러로 입력된 데이터에 대한 암호화 연산 및 복호화 연산 중 적어도 하나를 수행할 수 있다. 도 2b는 도 2a의 ECC 엔진의 상세도이다. 도 2b를 참조하면, ECC 엔진은 ECC 인코딩 회로 및 ECC 디코딩 회로를 포함할 수 있다. ECC 인코딩 회로는 ECC 제어 신호(ECC_CON)에 응답하여, 메모리 셀 어레이의 메모리 셀들에 기입될 기입 데이터(WData[0:63])에 대해 패리티 비트들(ECCP[0:7])을 생성할 수 있다. 패리티 비트들(ECCP[0:7])은 ECC 셀 어레이에 저장될 수 있다. 실시예들에 따르면, ECC 인코딩 회로는 ECC 제어 신호(ECC_CON)에 응답하여, 메모리 셀 어레이의 결함 셀을 포함하는 메모리 셀들에 기입될 기입 데이터(WData[0:63])에 대해 패리티 비트들(ECCP[0:7])을 생성할 수 있다. ECC 디코딩 회로는 ECC 제어 신호(ECC_CON)에 응답하여, 메모리 셀 어레이의 메모리 셀들로부터 독출 된 독출 데이터(RData[0:63]) 및 ECC 셀 어레이로부터 독출된 패리티 비트들(ECCP[0:7])을 사용하여 오류 비트 데이터를 정정하고, 오류-정정된 데이터(Data[0:63])를 출력할 수 있다. 실시예들에 따르면, ECC 디코딩 회로는 ECC 제어 신호(ECC_CON)에 응답하여, 메모리 셀 어레이의 결함 셀을 포함하는 메모리 셀들로 부터 독출된 독출 데이터(RData[0:63]) 및 ECC 셀 어레이로부터 독출된 패리티 비트들(ECCP[0:7])을 사용 하여 오류 비트 데이터를 정정하고, 오류-정정된 데이터(Data[0:63])를 출력할 수 있다. 도 2c는 도 2b의 ECC 인코딩 회로의 도면이다. 도 2c를 참조하면, ECC 인코딩 회로는 패리티 생성기를 포함할 수 있고, 패리티 생성기는 ECC 제어 신호(ECC_CON)에 응답하여 64 비트의 기입 데이터(WData[0:63]) 및 기저 비트들(B[0:7])을 수신하고, XOR 배열 연산을 사용하여 패리티 비트들(ECCP[0:7])을 생성한다. 기저 비트들(B[0:7])은 64 비트의 기입 데이터 (WData[0:63])에 대한 패리티 비트들(ECCP[0:7])을 생성하기 위한 비트들 예를 들어, b'00000000 비트들일 수 있다. 기저 비트들(B[0:7])은 b'00000000 비트들 대신에 다른 특정 비트들을 사용할 수 있다. 도 3은 실시예들에 따른, 메모리 시스템의 블록도이다. 도 3을 참조하면, 메모리 시스템은 메모리 장치 및 메모리 컨트롤러를 포함할 수 있다. 메모리 시스템은 복수의 채널들(CH1 내지 CHm)을 지원할 수 있고, 메모리 장치는 복수의 채널들(CH1 내지 CHm)을 통해 메모리 컨트롤러에 연결될 수 있다. 예를 들어, 메모리 시스템은 SSD와 같은 스토리지 장치로 구현될 수 있다. 메모리 장치는 복수의 NVM 장치들(NVM11 내지 NVMmn)을 포함할 수 있다. NVM 장치들(NVM11 내지 NVMmn) 각 각은 상응하는 웨이(way)를 통해 복수의 채널들(CH1 내지 CHm) 중 하나에 연결될 수 있다. 예를 들어, NVM 장치 들(NVM11 내지 NVM1n)은 웨이들(W11 내지 W1n)을 통해 제1 채널(CH1)에 연결될 수 있고, NVM 장치들(NVM21 내지 NVM2n)은 웨이들(W21 내지 W2n)을 통해 제2 채널(CH2)에 연결될 수 있다. 예시적인 실시예에서, NVM 장치들 (NVM11 내지 NVMmn) 각각은 메모리 컨트롤러로부터의 개별적인 명령에 따라 동작할 수 있는 임의의 메모리 유닛으로 구현될 수 있다. 예를 들어, NVM 장치들(NVM11 내지 NVMmn) 각각은 하나의 칩 또는 하나의 다이로 구 현될 수 있으나, 본 개시의 실시예들이 이에 한정되는 것은 아니다. 메모리 컨트롤러는 복수의 채널들(CH1 내지 CHm)을 통해 메모리 장치와 신호들을 송수신할 수 있다. 예 를 들어, 메모리 컨트롤러는 채널들(CH1 내지 CHm)을 통해, 명령들(CMDa 내지 CMDm), 주소들(ADDRa 내지 ADDRm), 데이터들(DATAa 내지 DATAm)을 메모리 장치로 전송하거나 메모리 장치로부터 데이터들(DATAa 내지 DATAm)을 수신할 수 있다. 메모리 컨트롤러는 채널들(CH1 내지 CHm) 중 상응하는 하나를 사용하여 채널들(CH1 내지 CHm) 각각에 연결 되는 NVM 장치들(NVM11 내지 NVMmn) 중 하나를 선택하고, 선택된 NVM 장치와 신호들을 송수신할 수 있다. 예를 들어, 메모리 컨트롤러는 제1 채널(CH1)에 연결된 NVM 장치들(NVM11 내지 NVM1n) 중 NVM 장치를 선택 할 수 있다. 메모리 컨트롤러는 제1 채널(CH1)을 통해 선택된 NVM 장치(NVM11)로 명령(CMDa), 주소(ADDRa) 및 데이터(DATAa)를 전송하거나 선택된 NVM 장치(NVM11)로부터 데이터(DATAa)를 수신할 수 있다. 메모리 컨트롤러는 서로 다른 채널들을 통해 병렬로 메모리 장치와 신호들을 송수신할 수 있다. 예를 들어, 메모리 컨트롤러는 제1 채널(CH1)을 통해 메모리 장치에 명령(CMDa)을 전송하는 동안, 제2 채널 (CH2)을 통해 메모리 장치에 명령(CMDb)을 전송할 수 있다. 예를 들어, 메모리 컨트롤러는 제1 채널 (CH1)을 통해 메모리 장치로부터 데이터(DATAa)를 수신하는 동안 제2 채널(CH2)을 통해 메모리 장치로 부터 데이터(DATAb)를 수신할 수 있다. 메모리 컨트롤러는 메모리 장치의 모든 동작들을 제어할 수 있다. 메모리 컨트롤러는 채널들(CH1 내지 CHm)로 신호들을 전송하고 채널들(CH1 내지 CHm)에 연결된 NVM 장치들(NVM11 내지 NVMmn) 각각을 제어할 수 있다. 예를 들어, 메모리 컨트롤러는 명령(CMDa) 및 주소(ADDRa)를 제1 채널(CH1)로 전송하고, NVM 장치 들(NVM11 내지 NVM1n)로부터 선택된 하나를 제어할 수 있다. NVM 장치들(NVm11 내지 NVMmn) 각각은 메모리 컨트롤러의 제어를 통해 동작할 수 있다. 예를 들어, NVM 장 치(NVM11)는 제1 채널(CH1)로 제공된 명령(CMDa), 주소(ADDRa) 및 데이터(DATAa)에 기초하여 데이터(DATAa)를 프로그램할 수 있다. 예를 들어, NVM 장치(NVM21)는 제2 채널(CH2)로 제공된 명령(CMDb), 주소(ADDRb)에 기초하 여 데이터(DATAb)를 독출하고, 독출된 데이터(DATAb)를 메모리 컨트롤러로 전송할 수 있다. 도 3은 메모리 장치가 m개의 채널들을 통해 메모리 컨트롤러와 통신하고, 각 채널에 상응하는 n개의 NVM 장치들을 포함하는 예를 도시하고 있으나, 채널들의 수 및 하나의 채널에 연결된 NVM 장치들의 수는 다양하 게 변경될 수 있다. 도 4는 예시적인 실시예에 따른 메모리 장치의 블록도이다. 도 4를 참조하면, 메모리 장치는 제어 로 직 회로, 메모리 셀 어레이, 페이지 버퍼, 전압 생성기 및 로우 디코더를 포함할 수 있다. 메모리 장치는 도 6에 도시된 메모리 인터페이스 회로를 더 포함할 수 있다. 또한 메모리 장치 는 칼럼 로직, 프리-디코더, 온도 센서, 명령 디코더 및/또는 주소 디코더를 더 포함할 수 있다. 제어 로직 회로는 메모리 장치의 모든 다양한 동작들을 제어할 수 있다. 제어 로직 회로는 메모 리 인터페이스 회로로부터의 명령(CMD) 및/또는 주소(ADDR)에 응답하여 다양한 제어 신호들을 출력할 수 있다. 예를 들어, 제어 로직 회로는 전압 제어 신호(CTRL_vol), 로우 주소(X_ADDR) 및 칼럼 주소(Y_ADD R)를 출력할 수 있다. 메모리 셀 어레이는 복수의 메모리 블록들(BLK1 내지 BLKz)(여기서 z는 양의 정수)을 포함할 수 있고, 각 메모리 블록은 복수의 메모리 셀들을 포함할 수 있다. 메모리 셀 어레이는 비트라인들(BL)을 통해 페이지 버퍼에 연결될 수 있고, 워드라인들(WL), 스트링 선택 라인들(SSL) 및 접지 선택 라인들(GSL)을 통해 로우 디코더에 연결될 수 있다. 예시적인 실시예에서, 메모리 셀 어레이는 3D 메모리 셀 어레이를 포함할 수 있고, 메모리 셀 어레이는 복 수의 NAND 스트링들을 포함한다. 각 NAND 스트링은 기판 상에 수직으로 적층된 워드라인들에 각각 연결된 메모 리 셀들을 포함할 수 있다. 미국 특허 번호 7,679,133, 미국 특허 번호 8,553,466, 미국 특허 번호 8,654,587 및 미국 특허 번호 8,559,235, 및 미국 공개 특허 번호 2011/0233648에 개시된 내용들은 본 개시에 참조로서 포 함된다. 예시적인 실시예에선, 메모리 셀 어레이는 2D 메모리 셀 어레이를 포함할 수 있고, 메모리 셀 어레이는 로우 방향 및 칼럼 방향으로 배열된 복수의 NAND 스트링들을 포함한다. 페이지 버퍼는 복수의 페이지 버퍼들(PB1 내지 PBn)(여기서, n은 3보다 크거나 같은 정수)을 포함할 수 있 고, 페이지 버퍼들(PB1 내지 PBn)은 복수의 비트라인들(BL)을 통해 메모리 셀들에 각각 연결될 수 있다. 페이지 버퍼는 칼럼 주소(Y_ADDR)에 응답하여 비트라인들(BL) 중 적어도 하나를 선택할 수 있다. 페이지 버퍼 는 동작 모드에 따라 기입 드라이버 또는 감지 증폭기로서 동작할 수 있다. 예를 들어, 프로그램 동작 동 안에, 페이지 버퍼는 프로그램될 데이터에 상응하는 비트라인 전압을 선택된 비트라인에 인가할 수 있다. 독출 동작 동안에, 페이지 버퍼는 선택된 비트라인(BL)의 전류 또는 전압을 감지하여 메모리 셀에 저장된 데이터를 감지할 수 있다. 전압 생성기는 전압 제어 신호(CTRL_vol)에 기초하여 프로그램, 독출 및 소거 동작들을 위한 다양한 종류 의 전압들을 생성할 수 있다. 예를 들어, 전압 생성기는 프로그램 전압, 독출 전압, 프로그램 검증 전압 및 소거 전압을 워드라인 전압(VWL)으로서 생성할 수 있다. 로우 디코더는 로우 주소(X-ADDR)에 응답하여, 복수의 워드라인들(WL) 중 하나를 선택하고 복수의 스트링 선택 라인들(SSL) 중 하나를 선택할 수 있다. 예를 들어, 로우 디코더는 프로그램 동작 동안에 프로그램 전압 및 프로그램 검증 전압을 선택된 워드라인(WL)으로 인가할 수 있고, 독출 동작 동안에 독출 전압을 선택된 워드라인(WL)으로 인가할 수 있다. 도 5는 실시예들에 따른 UFS 시스템의 블록도이다. UFS 시스템은 JEDEC(Joint Electron Device Engineering Council)에서 발표한 UFS 표준을 준수하는 시스템일 수 있고, UFS 호스트, UFS 장치 및 UFS 인터페이스를 포함할 수 있다. 도 1의 시스템에 대한 상기 설명은 도 5의 아래의 설명과 상 충되지 않는 범위 내에서 도 5의 UFS 시스템에도 적용될 수 있다. 도 5를 참조하면, UFS 호스트는 UFS 인터페이스를 통해 UFS 장치에 연결될 수 있다. 도 1의 메인 프로세서가 AP인 경우, UFS 호스트는 AP의 일부로서 구현될 수 있다. UFS 호스트 컨트롤러 및 호스트 메모리는 도 1의 메인 프로세서의 컨트롤러 및 메모리들(1200a 및 1200 b)에 각각 상응할 수 있다. UFS 장치는 도 1의 스토리지 장치(1300a 및 1300b)에 상응할 수 있고, UFS 장치 컨트롤러 및 NVM은 도 1의 스토리지 컨트롤러들(1310a 및 1310b) 및 NVM들(1320a 및 1320b) 에 각각 상응할 수 있다. UFS 호스트는 UFS 컨트롤러, 애플리케이션, UFS 드라이버, 호스트 메모리 및 UFS 인터커넥트(UIC) 레이어를 포함할 수 있다. UFS 장치는 UFS 장치 컨트롤러, NVM, 스토리지 인터페이스, 장치 메모리, UIC 레이어 및 레귤레이터를 포함할 수 있다. NVM은 복수의 메모리 유닛들을 포함할 수 있다. 메모리 유닛들 각각은 2D 구조 또는 3D 구조 를 가지는 V-NAND 플래시 메모리를 포함할 수 있고, 메모리 유닛들 각각은 PRAM 및/또는 RRAM과 같은 다 른 종류의 NVM을 포함할 수 있다. UFS 장치 컨트롤러는 스토리지 인터페이스를 통해 NVM에 연결될 수 있다. 스토리지 인터페이스는 토글(Toggle) 또는 ONFI와 같은 표준 프로토콜을 준수하도록 구 성될 수 있다. 애플리케이션은 UFS 장치의 기능들을 사용하기 위해 UFS 장치와 통신하고자 하는 프로그램을 지칭할 수 있다. 애플리케이션은 UFS 장치에 대한 입출력(I/O) 동작들을 위해 입출력 요청들(IOR s)을 UFS 드라이버로 전송할 수 있다. 입출력 요청들은 데이터 독출 요청, 데이터 저장(또는 기입) 요청 및/또는 데이터 소거(또는 폐기) 요청을 지칭할 수 있으나, 이에 제한되지 않는다. UFS 드라이버는 UFS-호스트 컨트롤러 인터페이스(UFS-HCI)를 통해 UFS 호스트 컨트롤러를 관리할 수 있다. UFS 드라이버는 애플리케이션에 의해 생성된 입출력 요청(IOR)을 UFS 표준에 의해 정의된 UFS 명령으로 변환하고, UFS 명령을 UFS 호스트 컨트롤러로 전송할 수 있다. 하나의 입출력 요청(IOR)은 복수의 UFS 명령들로 변환될 수 있다. UFS 명령은 기본적으로 SCSI 표준에 의해 정의될 수 있지만, UFS 명령은 UFS 표준 전용 명령일 수 있다. UFS 호스트 컨트롤러는 UFS 드라이버에 의해 변환된 UFS 명령을 UIC 레이어 및 UFS 인터페 이스를 통해 UFS 장치의 UIC 레이어로 전송할 수 있다. UFS 명령이 전송되는 동안, UFS 호 스트 컨트롤러의 UFS 호스트 레지스터는 명령 큐(command queue)(CQ) 역할을 할 수 있다. UFS 호스트 측의 UIC 레이어는 MIPI(mobile industry processor interface) M-PHY 및 MIPI UniPro를 포함할 수 있고, UFS 장치 측의 UIC 레이어 또한 MIPI M-PHY 및 MIPIUniPro를 포함할 수 있다. UFS 인터페이스는 기준 클럭 신호(REF_CLK)를 전송하도록 구성된 라인, UFS 장치에 대한 하드웨어 리셋 신호(RESET_n)를 전송하도록 구성된 라인, 한 쌍의 차동 입력 신호들(DIN_T 및 DIN_C)를 전송하도록 구성 된 한 쌍의 라인들 및 한 쌍의 차동 출력 신호들(DOUT_T 및 DOUT_C)을 전송하도록 구성된 한 쌍의 라인들을 포 함할 수 있다. UFS 호스트로부터 UFS 장치로 제공되는 기준 클럭 신호(REF_CLK)의 주파수는 19.2 MHz, 26MHz, 38.4MHz 및 52MHz 중 하나일 수 있으나, 이에 제한되는 것은 아니다. UFS 호스트는 동작 동안에 즉, UFS 호스트와 UFS 장치 사이의 데이터 송수신 동작들 중에, 기준 클럭 신호(REF_CLK)의 주파수를 변경 할 수 있다. UFS 장치는 위상 고정 루프(PLL)를 사용하여 UFS 호스트로부터 제공되는 기준 클럭 신 호(REF_CLK)로부터 다양한 주파수들을 갖는 클럭 신호들을 생성할 수 있다. 또한 UFS 호스트는 기준 클럭 신호(REF_CLK)의 주파수를 사용하여 UFS 호스트와 UFS 장치 사이의 데이터 율을 설정할 수 있다. 즉, 데이터 율은 기준 클럭 신호(REF_CLK)의 주파수에 따라 결정될 수 있다. UFS 인터페이스는 복수의 레인들을 지원할 수 있고, 각 레인은 한 쌍의 차동 라인들로서 구현될 수 있다. 예를 들어, UFS 인터페이스는 적어도 하나의 수신 레인 및 적어도 하나의 전송 레인을 포함할 수 있다. 도 5에서, 한 쌍의 차동 입력 신호들(DIN_T 및 DIN_C)을 전송하도록 구성된 한 쌍의 라인이 수신 레인을 구성할 수 있고, 한 쌍의 차동 출력 신호들(DOUT_T 및 DOUT_C)을 전송하도록 구성된 한 쌍의 라인들이 전송 레인을 구 성할 수 있다. 도 5에 하나의 전송 레인과 하나의 수신 레인이 도시되어 있으나, 전송 레인들의 수 및 수신 레 인들의 수는 변경될 수 있다. 수신 레인과 송신 레인은 직렬 통신 방식에 기초하여 데이터를 전송할 수 있다. 수신 레인과 전송 레인이 분리 되어 있는 구조로 인해 UFS 호스트와 UFS 장치 사이에 전이중 통신들(full-duplex communications)이 가능할 수 있다. 즉, UFS 장치는 수신 레인을 통해 UFS 호스트로부터 데이터를 수신하는 중에 전송 레인을 통해 UFS 호스트로 데이터를 전송할 수 있다. 또한 UFS 호스트로부터 UFS 장치로의 제어 데이터(예를 들어, 명령) 및 UFS 호스트에 의해 UFS 장치의 NVM에 저장 또는 독출된 사용자 데이터는 동일한 레인을 통해 전송될 수 있다. 따라서 UFS 호스트와 UFS 장치 사이에는, 한 쌍의 수신 레인들 및 한 쌍의 전송 레인들에 추가하여 데이터 전송을 위한 별도의 레인을 더 제공할 필요가 없을 수 있다. UFS 장치의 UFS 장치 컨트롤러는 UFS 장치의 모든 동작들을 제어할 수 있다. UFS 장치 컨트 롤러는 논리 데이터 스토리지 유닛인 논리 유닛(LU)을 사용하여 NVM을 관리할 수 있다. LU들 의 수는 8개일 수 있으나, 이에 제한되지 않는다. UFS 장치 컨트롤러는 FTL을 포함할 수 있고, FTL 의 주소 맵핑 정보를 사용하여 UFS 호스트로부터 수신된 논리 데이터 주소(예를 들어, 논리 블록 주소 (LBA))를 물리 데이터 주소(예를 들어, 물리 블록 주소(PBA))로 변환할 수 있다. UFS 시스템에 사용자 데 이터를 저장하도록 구성된 논리 블록은 미리 결정된 범위의 크기를 가질 수 있다. 예를 들어, 논리 블록의 최소 크기는 4KB로 설정될 수 있다. UFS 호스트로부터의 명령이 UIC 레이어를 통해 UFS 장치에 인가되는 경우, UFS 장치 컨트롤 러는 명령에 응답하여 동작을 수행하고, 동작이 완료되는 경우 UFS 호스트로 완료 응답(completion response)을 전송할 수 있다. 예를 들어, UFS 호스트가 UFS 장치에 사용자 데이터를 저장하고자 하는 경우, UFS 호스트는 UFS 장치로 데이터 저장 명령을 전송할 수 있다. UFS 호스트가 사용자 데이터를 수신할 준비가 되 었음(ready-to-transfer)을 나타내는 응답('ready-to-transfer' response)이 UFS 장치로부터 수신되는 경우, UFS 호스트는 사용자 데이터를 UFS 장치로 전송할 수 있다. UFS 장치 컨트롤러는 수신 된 사용자 데이터를 장치 메모리에 일시적으로 저장하고, 장치 메모리에 일시적으로 저장된 사용자 데이터를 FTL의 주소 맵핑 정보에 기초하여 NVM의 선택된 위치에 저장할 수 있다. 또 다른 예로서, UFS 호스트가 UFS 장치에 저장된 사용자 데이터를 독출하고자 하는 경우, UFS 호 스트는 데이터 독출 명령을 UFS 장치로 전송할 수 있다. 명령을 수신한 UFS 장치 컨트롤러는 데이터 독출 명령에 기초하여 NVM으로부터 사용자 데이터를 독출하고 장치 메모리에 독출된 사용자 데이터를 일시적으로 저장할 수 있다. 독출 동작 동안에, UFS 장치 컨트롤러는 내장된 ECC 엔진을 사용하 여 독출된 사용자 데이터의 오류를 검출하고 정정할 수 있다. 보다 구체적으로, ECC 엔진은 NVM에 기입될기입 데이터에 대해 패리티 비트들을 생성하고, 생성된 패리티 비트들은 기입 데이터와 함께 NVM에 저장 될 수 있다. NVM으로부터 데이터를 독출하는 동안, ECC 엔진은 독출 데이터와 함께 NVM으로부터 독 출된 패리티 비트들을 사용하여 독출 데이터의 오류를 정정하고, 오류-정정된 독출 데이터를 출력할 수 있다. 또한 UFS 장치 컨트롤러는 장치 메모리에 일시적으로 저장된 사용자 데이터를 UFS 호스트로 전송할 수 있다. 또한 UFS 장치 컨트롤러는 AES 엔진을 더 포함할 수 있다. AES 엔진은 대칭키 알고리즘 을 사용하여 UFS 장치 컨트롤러로 전송되는 데이터에 대한 암호화 연산 및 복호화 연산 중 적어도 하나를 수행할 수 있다. UFS 호스트는 명령 큐 역할을 할 수 있는 UFS 호스트 레지스터에 UFS 장치로 전송될 명령들 을 순차적으로 저장하고, 명령들을 UFS 장치로 순차적으로 전송할 수 있다. 이 경우, 이전에 전송된 명령 이 UFS 장치에 의해 처리되고 있는 동안에도 즉, 이전에 전송된 명령이 UFS 장치에 의해 처리되었 다는 통지를 수신하기 전에도, UFS 호스트는 명령 큐에 대기 중인 다음 명령을 UFS 장치로 전송할 수 있다. 따라서 UFS 장치는 이전에 전송된 명령을 처리하는 동안 UFS 호스트로부터 다음 명령을 수신할 수도 있다. 명령 큐에 저장될 수 있는 명령들의 최대 수(또는 큐 깊이(queue depth))는 예를 들어, 32개 일 수 있다. 또한 명령 큐는 큐에 저장된 명령 라인의 시작과 끝이 헤드 포인터 및 테일 포인터에 의해 표시되 는 순환 큐(circular queue)로 구현될 수 있다. 복수의 메모리 유닛들 각각은 메모리 셀 어레이 및 메모리 셀 어레이의 동작을 제어하도록 구성된 제어 회로를 포함할 수 있다. 메모리 셀 어레이는 2D 메모리 셀 어레이 또는 3D 메모리 셀 어레이를 포함할 수 있다. 메모리 셀 어레이는 복수의 메모리 셀들을 포함할 수 있다. 각 메모리 셀은 1비트 정보를 저장하도록 구성된 싱 글 레벨 셀(single-level cell)(SLC)이지만, 각 메모리 셀은 멀티 레벨 셀(multi-level cell)(MLC), 트리플 레 벨 셀(triple-level cell)(TLC) 및 쿼드러플 레벨 셀(quadruple level cell)(QLC)과 같이 2비트 이상의 정보를 저장하도록 구성된 셀일 수 있다. 3D 메모리 셀 어레이는 적어도 하나의 메모리 셀이 수직 방향으로 배치되어 다른 메모리 셀 상에 위치하는 수직형 NAND 스트링을 포함할 수 있다. 전압들(VCC, VCCQ 및 VCCQ2)이 전원 전압으로서 UFS 장치에 인가될 수 있다. 전압(VCC)은 UFS 장치 의 주 전원 전압일 수 있고 2.4V 내지 3.6V의 범위에 있을 수 있다. 전압(VCCQ)은 주로 UFS 장치 컨트롤 러로 저전압을 공급하기 위한 전원 전압일 수 있고, 1.14V 내지 1.26V의 범위에 있을 수 있다. 전압 (VCCQ2)은 전압(VCC)보다 낮고 전압(VCCQ)보다 높은 전압을 주로 MIPI M-PHY와 같은 입출력 인터페이스에 공급하기 위한 전원 전압일 수 있고, 1.7V 내지 1.95V의 범위에 있을 수 있다. 전원 전압들은 레귤레이터(226 0)를 통해 UFS 장치의 각 구성요소로 공급될 수 있다. 레귤레이터는 상술한 전원 전압들의 서로 다 른 하나들에 각각 연결된 단위 레귤레이터들의 세트로서 구현될 수 있다. 도 6은 실시예들에 따른, 메모리 시스템의 블록도이다. 도 6을 참조하면, 메모리 시스템은 메모리 장치 및 메모리 컨트롤러를 포함할 수 있다. 메모리 장치는 도 3의 복수의 채널들(CH1 내지 CHm) 중 하나에 기초하여 메모리 컨트롤러와 통신하는 NVM 장치들(NVM11 내지 NVMmn) 중 하나에 상응할 수 있다. 메모리 컨트롤러는 도 2a의 스토리지 컨트롤러에 상응할 수 있다. 메모리 장치는 제1 내지 제8 핀들(P11 내지 P18), 메모리 인터페이스 회로, 제어 로직 회로 및 메모리 셀 어레이를 포함할 수 있다. 메모리 인터페이스 회로는 제1 핀(P11)을 통해 메모리 컨트롤러로부터 칩 인에이블 신호(nCE)를 수신 할 수 있다. 메모리 인터페이스 회로는 칩 인에이블 신호(nCE)에 응답하여 제2 내지 제8 핀들(P12 내지 P18)을 통해 메모리 컨트롤러와 신호들을 송수신할 수 있다. 예를 들어, 칩 인에이블 신호(nCE)가 인에이 블 상태(예를 들어, 로우 레벨)인 경우, 메모리 인터페이스 회로는 제2 내지 제8 핀들(P12 내지 P18)을 통 해 메모리 컨트롤러와 신호들을 송수신할 수 있다. 메모리 인터페이스 회로는 제2 내지 제4 핀들(P12 내지 P14)을 통해 명령 래치 인에이블 신호(CLE), 주소 래치 인에이블 신호(ALE) 및 기입 인에이블 신호(new)를 수신할 수 있다. 메모리 인터페이스 회로는 제7 핀(P17)을 통해 메모리 컨트롤러로부터 데이터 신호(DQ)를 수신하거나 데이터 신호(DQ)를 메모리 컨트롤러 로 전송할 수 있다. 데이터 신호(DQ)를 통해 명령(CMD), 주소(ADDR) 및 데이터가 전송될 수 있다. 예를 들 어, 데이터 신호(DQ)는 복수의 데이터 신호 라인들을 통해 전송될 수 있다. 이 경우, 제7 핀(P17)은 복수의 데 이터 신호들(DQ(s))에 각각 대응하는 복수의 핀들을 포함할 수 있다. 메모리 인터페이스 회로는 기입 인에이블 신호(nWE)의 토글 시점들에 기초하여 명령 래치 인에이블 신호 (CLE)의 인에이블 구간(예를 들어, 하이 레벨 상태)에서 수신되는 데이터 신호(DQ)로부터 명령(CMD)을 획득할 수 있다. 메모리 인터페이스 회로는 기입 인에이블 신호(new)의 토글 시점들에 기초하여 주소 래치 인에이 블 신호(ALE)의 인에이블 구간(예를 들어, 하이 레벨 상태)에서 수신되는 데이터 신호(DQ)로부터 주소(ADDR)를 획득할 수 있다. 예시적인 실시예에서, 기입 인에이블 신호(nWE)는 정적 상태(예를 들어, 하이 레벨 또는 로우 레벨)에서 유지될 수 있고, 하이 레벨 및 로우 레벨 사이를 토글할 수 있다. 예를 들어, 기입 인에이블 신호(nWE)는 명령(CMD) 또 는 주소(ADDR)이 전송되는 구간에서 토글할 수 있다. 따라서 메모리 인터페이스 회로는 기입 인에이블 신 호(nWE)의 토글 시점들에 기초하여 명령(CMD) 또는 주소(ADDR)를 획득할 수 있다. 메모리 인터페이스 회로는 제5 핀(P15)을 통해 메모리 컨트롤러로부터 독출 인에이블 신호(nRE)를 수 신할 수 있다. 메모리 인터페이스 회로는 제6 핀(P16)을 통해 메모리 컨트롤러로부터 데이터 스트로 브 신호(DQS)를 수신하거나 데이터 스트로브 신호(DQS)를 메모리 컨트롤러로 전송할 수 있다. 메모리 장치의 데이터(DATA) 출력 동작에서, 메모리 인터페이스 회로는 데이터(DATA)가 출력되기 전 에, 제5 핀(P15)을 통해 토글하는 독출 인에이블 신호(nRE)를 수신할 수 있다. 메모리 인터페이스 회로는 독출 인에이블 신호(nRE)의 토글링에 기초하여 토글하는 데이터 스트로브 신호(DQS)를 생성할 수 있다. 예를 들 어 메모리 인터페이스 회로는 독출 인에이블 신호(nRE)의 토글 시작 시간에 기초하여 미리 결정된 지연(예 를 들어, tDQSRE) 후에 토글하기 시작하는 데이터 스트로브 신호(DQS)를 생성할 수 있다. 메모리 인터페이스 회 로는 데이터 스트로브 신호(DQS)의 토글 시점에 기초하여 데이터(DATA)를 포함하는 데이터 신호(DQ)를 전 송할 수 있다. 따라서 데이터(DATA)는 데이터 스트로브 신호(DQS)의 토글 시점과 정렬되어 메모리 컨트롤러 로 전송될 수 있다. 메모리 장치의 데이터(DATA) 입력 동작에서, 메모리 컨트롤러로부터 데이터(DATA)를 포함하는 데이터 신호(DQ)가 수신되는 경우, 메모리 인터페이스 회로는 메모리 컨트롤러로부터 데이터(DATA)와 함께 토글하는 데이터 스트로브 신호(DQS)를 수신할 수 있다. 메모리 인터페이스 회로는 데이터 스트로브 신호 (DQS)의 토글 시점에 기초하여 데이터 신호(DQ)로부터 데이터(DATA)를 획득할 수 있다. 예를 들어, 메모리 인터 페이스 회로는 데이터 스트로브 신호(DQS)의 상승 에지 및 하강 에지에서 데이터 신호(DQ)를 샘플링하여 데이터(DATA)를 획득할 수 있다. 메모리 인터페이스 회로는 제8 핀(P18)을 통해 메모리 컨트롤러로 레디/비지(ready/busy) 출력 신호 (nR/B)를 전송할 수 있다. 메모리 인터페이스 회로는 레디/비지 출력 신호(nR/B)를 통해 메모리 장치(30 0)의 상태 정보를 메모리 컨트롤러로 전송할 수 있다. 메모리 장치가 비지 상태인 경우(즉, 메모리 장치에서 동작들이 수행되고 있는 경우), 메모리 인터페이스 회로는 비지 상태를 나타내는 레디/비지 출력 신호(nR/B)를 메모리 컨트롤러로 전송할 수 있다. 메모리 장치가 레디 상태인 경우(즉, 메모리 장치에서 동작들이 수행되지 않거나 완료된 경우), 메모리 인터페이스 회로는 레디 상태를 나타내는 레디/비지 출력 신호(nR/B)를 메모리 컨트롤러로 전송할 수 있다. 예를 들어, 메모리 장치가 페이지 독출 명령에 응답하여 메모리 셀 어레이로부터 데이터(DATA)를 독출하는 동안, 메모리 인터페이스 회로 는 비지 상태(예를 들어, 로우 레벨)를 나타내는 레디/비지 출력 신호(nR/B)를 메모리 컨트롤러로 전 송할 수 있다. 예를 들어, 메모리 장치가 프로그램 명령에 응답하여 메모리 셀 어레이에 데이터 (DATA)를 프로그램하는 동안, 메모리 인터페이스 회로는 비지 상태를 나타내는 레디/비지 출력 신호(nR/ B)를 메모리 컨트롤러로 전송할 수 있다. 제어 로직 회로는 메모리 장치의 모든 동작들을 제어할 수 있다. 제어 로직 회로는 메모리 인터 페이스 회로로부터 획득된 명령/주소(CMD/ADDR)를 수신할 수 있다. 제어 로직 회로는 수신된 명령/주 소(CMD/ADDR)에 응답하여 메모리 장치의 다른 구성요소들을 제어하기 위한 제어 신호들을 생성할 수 있다. 예를 들어, 제어 로직 회로는 메모리 셀 어레이에 데이터(DATA)를 프로그램하거나 메모리 셀 어레이 로부터 데이터(DATA)를 독출하기 위한 다양한 제어 신호들을 생성할 수 있다. 메모리 셀 어레이는 제어 로직 회로의 제어를 통해, 메모리 인터페이스 회로로부터 획득된 데이 터(DATA)를 저장할 수 있다. 메모리 셀 어레이는 제어 로직 회로의 제어를 통해 저장된 데이터(DAT A)를 메모리 인터페이스 회로로 출력할 수 있다. 메모리 셀 어레이는 복수의 메모리 셀들을 포함할 수 있다. 예를 들어, 복수의 메모리 셀들은 플래시 메모 리 셀들일 수 있다. 그러나 본 개시의 범위가 이에 한정되는 것은 아니며, 메모리 셀들은 RRAM 셀들, FRAM셀들, PRAM 셀들, 사이리스터 램(thyristor RAM)(TRAM) 셀들 또는 MRAM 셀들일 수 있다. 이하에서, 메모리 셀 들이 NAND 플래시 메모리 셀들인 실시예를 주로 설명한다. 메모리 컨트롤러는 제1 내지 제8 핀들(P21 내지 P28) 및 컨트롤러 인터페이스 회로를 포함할 수 있다. 제1 내지 제8 핀들(P21 내지 P28)은 메모리 장치의 제1 내지 제8 핀들(P11 내지 P18)에 각각 대응할 수 있다. 컨트롤러 인터페이스 회로는 제1 핀(P21)을 통해 메모리 장치로 칩 인에이블 신호(nCE)를 전송할 수 있다. 컨트롤러 인터페이스 회로는 제2 내지 제8 핀들(P22 내지 P28)을 통해 침 인에이블 신호(nCE)에 의 해 선택되는 메모리 장치와 신호들을 송수신할 수 있다. 컨트롤러 인터페이스 회로는 제2 내지 제4 핀들(P22 내지 P24)을 통해 명령 래치 인에이블 신호(CEL), 주 소 래치 인에이블 신호(ALE) 및 기입 인에이블 신호(nWE)를 메모리 장치로 전송할 수 있다. 컨트롤러 인터 페이스 회로는 제7 핀(P27)을 통해 메모리 장치와 데이터 신호(DQ)를 송수신할 수 있다. 컨트롤러 인터페이스 회로는 토글하는 기입 인에이블 신호(nWE)와 함께 명령(CMD) 또는 주소(ADDR)를 포함 하는 데이터 신호(DQ)를 메모리 장치로 전송할 수 있다. 컨트롤러 인터페이스 회로는 인에이블 상태 를 갖는 명령 래치 인에이블 신호(CLE)를 전송함으로써 명령(CMD)을 포함하는 데이터 신호(DQ)를 메모리 장치 로 전송할 수 있다. 또한 컨트롤러 인터페이스 회로는 인에이블 상태를 갖는 주소 래치 인에이블 신 호(ALE)를 전송함으로써 주소(ADDR)를 포함하는 데이터 신호(DQ)를 메모리 장치로 전송할 수 있다. 컨트롤러 인터페이스 회로는 제5 핀(P25)을 통해 메모리 장치로 독출 인에이블 신호(nRE)를 전송할 수 있다. 컨트롤러 인터페이스 회로는 제6 핀(P26)을 통해 메모리 장치와 데이터 스트로브 신호(DQ S)를 송수신할 수 있다. 메모리 장치의 데이터(DATA) 출력 동작에서, 컨트롤러 인터페이스 회로는 토글하는 독출 인에이블 신 호(nRE)를 생성하고, 독출 인에이블 신호(nRE)를 메모리 장치로 전송할 수 있다. 예를 들어, 데이터(DAT A)를 출력하기 전에, 컨트롤러 인터페이스 회로는 정적 상태(예를 들어, 하이 레벨 또는 로우 레벨)로부터 토글 상태로 변경되는 독출 인에이블 신호(nRE)를 생성할 수 있다. 따라서 메모리 장치는 독출 인에이블 신호(nRE)에 기초하여 토글하는 데이터 스트로브 신호(DQS)를 생성할 수 있다. 컨트롤러 인터페이스 회로 는 메모리 장치로부터 토글하는 데이터 스트로브 신호(DQS)와 함께 데이터(DATA)를 포함하는 데이터 신호 (DQ)를 수신할 수 있다. 컨트롤러 인터페이스 회로는 데이터 스트로브 신호(DQS)의 토글 시점에 기초하여 데이터 신호(DQ)로부터 데이터(DATA)를 획득할 수 있다. 메모리 장치의 데이터(DATA) 입력 동작에서, 컨트롤러 인터페이스 회로는 토글하는 데이터 스트로브 신호(DQS)를 생성할 수 있다. 예를 들어, 데이터(DATA)를 전송하기 전에, 컨트롤러 인터페이스 회로는 정 적 상태(예를 들어, 하이 레벨 또는 로우 레벨)로부터 토글 상태로 변경되는 데이터 스트로브 신호(DQS)를 생성 할 수 있다. 컨트롤러 인터페이스 회로는 데이터 스트로브 신호(DQS)의 토글 시점들에 기초하여 메모리 장 치로 데이터(DATA)를 포함하는 데이터 신호(DQ)를 전송할 수 있다. 컨트롤러 인터페이스 회로는 제8 핀(P28)을 통해 메모리 장치로부터 레디/비지 출력 신호(nR/B)를 수 신할 수 있다. 컨트롤러 인터페이스 회로는 레디/비지 출력 신호(nR/B)에 기초하여 메모리 장치의 상 태 정보를 판단할 수 있다. 도 7은 실시예들에 따른 UFS 장치에 적용가능한 3D V-NAND 구조를 나타내는 도면이다. UFS의 스토리지 모듈이 3D V-NAND 플래시 메모리로 구현되는 경우, 스토리지 모듈에 포함되는 복수의 메모리 블록들 각각은 도 7에 도 시된 등가 회로에 의해 표현될 수 있다. 도 7에 도시된 메모리 블록(BLKi)은 기판 상에 3D 구조로 형성된 3D 메모리 블록을 지칭할 수 있다. 예를 들어, 메모리 블록(BLKi)에 포함된 복수의 메모리 NAND 스트링들은 기판과 수직 방향으로 형성될 수 있다. 도 7을 참조하면, 메모리 블록(BLKi)은 복수의 메모리 NAND 스트링들(예를 들어, NS11 내지 NS33)을 포함할 수 있고, 복수의 메모리 NAND 스트링들은 비트라인들(BL1, BL2 및 BL3)과 공통 소스 라인(CSL) 사이에 연결된다. 메모리 NAND 스트링들(NS11 내지 NS33) 각각은 스트링 선택 트랜지스터(SST), 복수의 메모리 셀들(예를 들어, MC1, MC2, …MC8) 및 접지 선택 트랜지스터(GST)를 포함할 수 있다. 메모리 NAND 스트링들(NS11 내지 NS33) 각 각은 도 7에서 8개의 메모리 셀들(MC1, MC2, …MC8)을 포함하는 것으로 도시되어 있으나, 이에 제한되지 않는다. 스트링 선택 트랜지스터(SST)는 이에 대응하는 스트링 선택 라인들(SSL1, SSL2 및 SSL3)에 연결될 수 있다. 메 모리 셀들(MC1, MC2, …MC8) 각각은 게이트 라인들(GTL1, GTL2, …GTL8) 중 상응하는 하나에 연결될 수 있다. 게이트 라인들(GTL1, GTL2, …GTL8)은 워드라인들에 각각 상응할 수 있고, 게이트 라인들(GTL1, GTL2, …GTL8) 중 일부는 더미 워드라인들에 상응할 수 있다. 접지 선택 트랜지스터(GST)는 이에 대응하는 접지 선택 라인들 (GSL1, GSL2 및 GSL3)에 연결될 수 있다. 스트링 선택 트랜지스터(SST)는 이에 대응하는 비트라인들(BL1, BL2 및 BL3)에 연결될 수 있고, 접지 선택 트랜지스터(GST)는 공통 소스 라인(CSL)에 연결될 수 있다. 동일한 레벨의 워드라인들(예를 들어, WL1)은 공통으로 연결될 수 있고, 접지 선택 라인들(GSL1, GSL2 및 GSL3) 및 스트링 선택 라인들(SSL1, SSL2 및 SSL3)은 서로 분리되어 연결될 수 있다. 도 7은 메모리 블록(BLKi)이 8개 의 게이트 라인들(GTL1, GTL2, …GTL8) 및 3개의 비트라인들(BL1, BL2 및 BL3)에 연결된 경우를 도시하나, 이에 한정되지 않는다. 상술한 바와 같이, 본 개시의 실시예들은 H-GCC 코드들로 지칭될 수 있고, 플래시 메모리에서의 ECC 애플리케이 션들에 적합한 코드 디멘젼(code dimension) 및 코드 길이(code length) 제약들을 갖는 코드들의 군(family)의 구성과 관련될 수 있다. H-GCC 코드 구조는 각각이 K개의 정보 비트들과 N의 코드 길이를 갖는 개의 구성 코드들을 포함할 수 있다. 체계적 인코더가 사용되는 경우, H-GCC 코드워드는 구성 코드당 K개의 정보 비트들, 구성 코드를 보호하기 위해 사용될 수 있는 로컬 패리티 비트들( )로 분할될 수 있는 P개의 총 패리티 비트들(여기서 P=N-K) 및 구성 코드 들 사이에서 리소스들을 공유할 수 있는 글로벌 패리티 비트들( )을 포함할 수 있다. 구성 코드들은 내부 구조(interval structure)와 변환 공간(transform space)을 생성하기 위해 사용될 수 있는 상응하는 변환을 갖는 GCC 코드들일 수 있다. 각 구성 코드에 대해, 변환 공간은 개의 심볼들을 포함하고, 각 심볼은 m 비트들로 구성된다. 서로 다른 구성 코드들로부터의 개의 심볼들을 결합하는 것은 변환 공간에서 리 드 솔로몬(Reed Solomon)(RS) 코드워드들을 생성할 수 있고, 그 결과 GCC와 RS 코드들이 연결될 수 있다. 도 8은 실시예들에 따른, H-GCC 코드워드의 예시적인 코드 구조를 나타내는 도면이다. 실시예들에 따르면, H- GCC 코드는 GCC 코드들의 연결들을 사용하여 구성되는 것으로 또한 이해될 수 있고, 그것의 예들은 이하에서 보 다 구체적으로 설명된다. 아래의 도 9 내지 23은 H-GCC 코드의 다양한 실시예들에 관한 것이고, 상응하는 패리 티 체크 행렬들 및 인코더 알고리즘들에 관한 것이기도 하다. 예를 들어, 아래에서 설명되는 실시예에 따르면, GCC 체계적(sequential) 인코더는 로컬 패리티 비트들에 대한 기본(basic) 인코더로 사용될 수 있고, 글로벌 패 리티 비트들은 선형 제약들(linear constraints)로 취급될 수 있다. 또 다른 예로서, 아래에서 설명되는 실시예 들에 따르면, 제약이 오버헤드 비트들 위치(overhead bits location)에 배치(placed on)될 수 있고, 이러한 제 약이 충족되는 경우, 체계적 인코더는 H-GCC에 적용될 수 있다. 도 9는 실시예들에 따른, NAND 메모리 블록의 일 예를 나타내는 도면이다. 일반적으로 NAND 셀은 비트들을 저 장할 수 있고, 여기서 는 NAND 메모리 셀의 특정 유형에 따라 달라진다. 예를 들어, 셀 당 1 비트(BPC)를 저장 하는 플래시 메모리 장치는 싱글 레벨 셀(single-level cell)(SLC)로 지칭될 수 있고, 셀 당 2 비트를 저장하는 플래시 메모리 장치는 멀티 레벨 셀(multi-level cell)(MLC)로 지칭될 수 있고, 셀 당 3 비트를 저장하는 플래 시 메모리 장치는 트리플 레벨 셀(triple-level cell)(TLC)로 지칭될 수 있고, 셀 당 4 비트를 저장하는 플래시 메모리 장치는 쿼드러플 레벨 셀(quadruple-level cell)(QLC)로 지칭될 수 있고, 셀 당 5 비트를 저장하는 플래 시 메모리 장치는 펜타 레벨 셀(penta-level cell)(PLC)로 지칭될 수 있다. 상술한 바와 같이, NAND 칩은 개 의 블록들의 워드라인들(WLs)을 포함하는 구조를 가질 수 있고, 여기서 각 워드라인은 개의 비트라인들(BLs) 을 포함한다. 빠른 NAND 액세스를 허용하기 위해, NAND 메모리 장치의 각 워드라인은 RAU들로 분할될 수 있다. 일반적으로, RAU에 저장될 비트들의 수가 인 경우, 워드라인은 개의 섹터들로 분할될 수 있고, 여기서 각 섹터는 개 의 비트라인들에 대해서, 예를 들어 LSB(least significant bit), CSB(center significant bit) 또는 MSB(most significant bit)일 수 있는 중 한 개의 비트를 나타내는 개의 RAU들을 포함할 것이다. 따라서 이러한 블록 에서 RAU들의 수는 이 될 것이다. 높은 신뢰성의 액세스를 허용하기 위해, 각 RAU는 ECC로 보호될 수 있다. 예를 들어, RAU의 ECC 코드 길이는"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "일 수 있고, 개의 정보 비트들을 수용할 수 있다. 일반적으로 ECC 코드가 길수록 신뢰성이 향상될 수 있 으므로, 더 긴 ECC들을 사용하는 것의 이점이 있을 수 있다. 그러나 RAU 구조는 기껏해야 특정 길이(예를 들어, 길이 )의 ECC만을 수용할 수 있다. 더 긴 ECC 코드들을 제공하기 위해, 일부 ECC 방식들은 을 길이 의 섹터들로 균등하지 않게 분할 하여 이 되도록 할 수 있다. 여기서 이다. 이러한 방식으로 개의 RAU들을 결합하여 글로 벌 패리티 비트들과 함께 인코딩하는 것이 가능할 수 있다. 그러나 라는 제약은 RAU들을 결합하는데 커다란 유연성을 허용하지 않는다. 예를 들어, 라는 제약은 예를 들어, MSB, CSB 및 LSB를 함께 인코딩함으로써 동일한 섹터에 속하는 RAU들이 함께 연결되도록 허 용하지 않을 수 있고, 디코딩 과정에서 약간의 손실을 초래할 수도 있다. 따라서 실시예들은 효율적인 인코더 알고리즘을 사용하여, 인 경우에 실현가능할 수 있는, GCC 코드들에 기초한 H-GCC 코딩 방식의 계층적 코드를 제공할 수 있다. 실시예들에 따르면, 및 라는 표기가 여기에서 사용될 수 있다. 벡터들은 소 문자로 굵게(예를 들어, )로 표시될 수 있고, 행렬은 대문자로 굵게(예를 들어, ) 표시될 수 있다. 행 렬 와 사이의 크로네커 곱(Kronecker product)은 아래의 수학식 1 및 수학식 2에 따라 정의될 수 있다. 수학식 1"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "수학식 2"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "단위 행렬은 로 나타내어질 수 있다. 또한 는 크기 인 벡터 로부터의 인덱스 를 나타낼 수 있다. 실시예에 따르면, 는 폴라 생성 행렬(polar generator matrix)을 나타낼 수 있고, 는 단계(stage) 에서 폴 라 정적 프로즌 집합(polar static frozen set)을 나타낼 수 있고, 는 에 상응하는 폴라 변환(polar transform)을 나타낼 수 있고, 는 길이 , 디멘젼 및 정적 프로즌 집합 의 폴라 코드를 나타낼 수 있고, 는 아래의 수학식 3에서 보여지는 것과 같이 단계 까지의 폴라 정적 프로즌 집합을 나타낼 수 있다. 수학식 3"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 5, "content": "실시예들에 따르면, 는 갈루아 필드(Galois Field) 원시 원소(primitive element)를 나타낼 수 있고, 는 길이 , 디멘젼 및 오류 정정 능력 인 BCH(Bose-Chaudhuri-Hocquenghem) 코드를 나타낼 수 있다. 또한 는 단계 에 상응하는 BCH 변환을 나타낼 수 있다. 실시예들에 따르면, 는 길이 (심볼들)(여기서, )인 RS 코드를 나타낼 수 있다. 또한 는 단계 에 상응하는 RS 변환을 나타낼 수 있다. 실시예들에 따르면, 는 길이 , 디멘젼 , 및 정적 및 고정 프로즌 집합 의 폴라 서브코드를 나타 낼 수 있다. 또한 는 단계 에서 폴라 서브코드 동적 프로즌 집합을 나타낼 수 있고, 는 아래의 수학식 4에 따라 단계 에서 폴라 서브코드 정적 및 동적 프로즌 집합을 나타낼 수 있다. 수학식 4"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 6, "content": "또한 는 에 상응하는 폴라 서브코드 변환을 나타낼 수 있다. 실시예들은 구성 코드들로서 사용될 수 있는 중첩 코드들(nested codes)을 사용할 수 있다. 중첩 코드들은 동일 한 군의 코드들일 수 있다: 길이 및 디멘젼 를 갖는 (여기서, 이고 에 대해 ). 코드워드 는 또한 코드워드 ( )일 수 있지만, 코드 의 유효 디멘젼이 로부터 로 감소하도록, (여기서, 이고 )인 선형 제약을 가질 수 있다. 변환은 구성 코드워드 , , 에 적용되고, 변환 공간이라고 할 수 있는 코드워드의 부가 정보 , 를 반환하는 선형 연산 을 의미할 수 있고, 아래의 수학식 5 및 수학식 6에 따라 표현될 수 있다. 수학식 5"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 7, "content": "수학식 6"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 8, "content": "실시예들에 따르면, 폴라 코드워드 는 아래의 수학식 7 및 수학식 8에 따라 가역(invertible) 폴라 변환 행렬 및 프로즌 공간 을 사용하여 표현될 수 있다. 수학식 7"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 9, "content": "수학식 8"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 10, "content": "의 위치들(locations) 에서, 비트들 중 일부는 알려져 있을 수 있고, 프로즌 비트들이라고 지칭할 수 있다. 프로즌 비트들의 수인 는 코드 오버헤드를 나타낼 수 있고, 따라서 폴라 코드의 디멘젼은 일 수 있다. 길이가 이고 디멘젼이 인 폴라 코드는 로 나타낼 수 있고, 여기서 이다. 프로즌 비트들의 서로소 집합들(disjoint sets)은 , , 로 나타낼 수 있고, 프로즌 집합은 로 나타낼 수 있다. 상응하는 중첩 폴라 코드들은 로 나타낼 수있고, 상응하는 디멘젼은 로 나타낼 수 있다. 이러한 중첩 코드들의 계열은 아래의 수학식 9에 따라 로 표시할 수 있다. 수학식 9"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 11, "content": "행렬 는 길이 이고, 위치들이 이고, 아래의 도 10에서와 같은 상응하는 변환 으로부터 선택할 수 있는 개의 행렬에 대해 일 수 있다. 수학식 10"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 12, "content": "중첩 코드의 변환은 행렬들 을 사용하여 나타낼 수 있고, 설명의 편의를 위해 로 표시할 수 있다. 변환 공간은 비트들 및 아래의 수학식 11과 같은 심볼들 을 포함할 수 있다. 수학식 11"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 13, "content": "폴라 코드워드 의 변환 공간 심볼들은 아래의 수학식 12에 따라 정의될 수 있다. 수학식 12"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 14, "content": "실시예들에 따르면, 코드 는 길이 , 디멘젼 및 오류 정정 능력 를 갖는 BCH 코드일 수 있다. 이러한 BCH 코드의 패리티 체크 행렬은 아래의 수학식 13에서와 같은 원시 원소 를 사용하여 정의될 수 있다. 수학식 13"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 15, "content": "인 경우 상응하는 디멘젼 를 갖는 에러 정정 파라미터들 , 에 대해, BCH 중첩 코드 들의 군은 로 표시할 수 있고, 아래의 수학식 14에 따라 나타낼 수 있다. 수학식 14"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 16, "content": "일부 에 대해, BCH 코드 코셋(coset)(잉여류)은 로 표시할 수 있고, 아래의 수학식 15에 따 라 정의될 수 있다. 수학식 15"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 17, "content": "그 다음 BCH 변환은 수학식 16에 따라 정의될 수 있고, 상응하는 변환 공간 심볼은 수학식 17에 따라 표현되고, 변환 공간은 아래의 수학식 18에 따라 정의된다. 수학식 16"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 18, "content": "수학식 17 수학식 18"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 19, "content": "실시예들에 따르면, 코드 는 길이 이고 최소 거리 을 가지는 RS 코드일 수 있다. 이러한 RS 코드의 패리티 체크 행렬은 아래의 수학식 19에서와 같이 원시 원소 를 사용하여 나타낼 수 있다. 수학식 19"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 20, "content": "에러 정정 파라미터들의 집합은 인 경우 , 로 표현될 수 있다. RS 중첩 코드들의 군은 로 표시할 수 있고, 아래의 수학식 20을 사용하여 나타낼 수 있다. 수학식 20"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 21, "content": "RS 코드 , 코셋은 로 표시할 수 있고, 아래의 수학식 21을 사용하여 나타낼 수 있다. 수학식 21"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 22, "content": "그 다음 RS 변환은 수학식 22에 따라 정의될 수 있고, 상응하는 변환 공간 심볼은 수학식 23에 따라 표현되고, 변환 공간은 아래의 수학식 24에 따라 정의된다. 수학식 22 수학식 23"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 23, "content": "수학식 24"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 24, "content": "실시예들에 따르면, 폴라 서브코드들은 폴라 코드들의 확장으로 이해될 수 있다. 폴라 서브코드들은 정적 및 동 적 프로즌 비트들을 포함할 수 있고, 정적 및 동적 프로즌 비트들 모두 프로즌 공간에서 정의될 수 있고, 폴라 변환 행렬 을 사용하여 생성될 수 있다. 정적 프로즌 비트들은 인덱스들 에 위치할 수 있고, 동적 프로즌 비트들은 인덱스들 에 위치 할 수 있고, 여기서 이다. 정적 프로즌 비트들은 , 로 표현할 수 있고, 여기서 이다. 인덱스들 의 집합에 대 해"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 25, "content": "인 제약이 있는 경우, 동적 프로즌 비트 , 는 아래의 수학식 25를 만족할 수 있다. 수학식 25"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 26, "content": "서로소 집합들 , 에 대해, 는 정적 및 동적 프로즌 집합들의 합집합(union)으로 나타낼 수 있고, 아래의 수학식 26에 따라 표현될 수 있다. 수학식 26"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 27, "content": "수학식 26에서, , 이고, 이다. 폴라 서브코드"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 28, "content": "는 프로즌 집합 및 상응하는 디멘젼 으로 정 의될 수 있다. 폴라 서브코드 중첩 코드들의 군은 으로 표시할 수 있고, 아래의 수학식 27에따라 표현될 수 있다. 수학식 27"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 29, "content": "해당 변환은 로 표시할 수 있고, 편의상 인 표기법이 사용될 수 있다. 변환 공간은 비트들을 포함할 수 있고, 심볼들 는 수학식 28에 따라 나타낼 수 있고, 코드워드 의 변환 공간 심볼들은 아래의 수학 식 29에 따라 정의된다. 수학식 28"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 30, "content": "수학식 29"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 31, "content": "실시예들에 따라, GCC는 상기 코드워드들과 상기 변환 심볼들 사이의 맵핑을 갖는, 중첩 코드들 군에 속하는 여 러 구성 코드들, 변환 공간으로의 변환 및 상기 변환 공간의 코드들을 리스트를 포함하는 코드일 수 있다. 도 10은 실시예들에 따른, GCC S-폴라 코드의 예시적인 코드 구조를 나타내는 도면이다. 도 10에 도시된 바와 같이, GCC S-폴라 코드는 폴라 코드들과 RS 코드들의 연결(concatenation)을 나타낼 수 있다. 예를 들어, GCC S-폴라 코드는 프로즌 비트들 위치들의 상응하는 서로소 집합들이 , 이고, 이며, 프로즌 집합은 인, 수학식 9에 도시된 바와 같이 중첩 폴라 코드 들의 집합과 관련될 수 있다. 수학식 30 및 수학식 31에 따른 제약이 추가될 수 있다. 수학식 30"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 32, "content": "수학식 31"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 33, "content": "따라서 GCC S-폴라 코드는 아래의 수학식 32를 만족할 수 있다. 수학식 32"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 34, "content": "예를 들어, 개의 폴라 코드들은 수학식 9의 중첩 코드들 중 하나에 각각 속할 수 있고, 여기서 는 길이"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 35, "content": "이고, 디멘젼은 인, , 이고, 이다. 함수 는 코드워드 를 상응하는 폴라 중첩 코드에 맵핑하여, 이고 이 되도록 할 수 있다. 실시예들에 따르면, 여 러 폴라 코드워드들이 동일한 폴라 코드에 속하기 때문에, 이다. 정적 비트들 의 집합에 대해, 를 정의하고, 변환 행렬 가 아래의 수학식 33에 따라 정의될 수 있다. 수학식 33"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 36, "content": "상응하는 변환 공간 심볼들 는 아래의 수학식 34에 따라 표현될 수 있다. 수학식 34"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 37, "content": "다음으로, 모든 에 대해, 심볼들의 벡터 는 길이가 L이고 디멘젼이 인 RS 코 드워드 로 정의될 수 있고, 여기서 이거나 동등하게는 이고, 이다. 실시예들에 따르면, 와 는 직접적인 관계가 있을 수 있고, 는 보다 작은 디멘젼을 갖는 행들의 수와 동일하다. 이 관계는 아래의 수학식 35에 따라 나타낼 수 있다. 수학식 35"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 38, "content": "GCC S-폴라 코드는 아래의 수학식 36에 따라 표시될 수 있다. 수학식 36"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 39, "content": "GCC S-폴라 코드가 폴라 코드들을 구성 코드들로 사용하여 상술되었지만, 실시예들은 이에 제한되지 않는다. 예 를 들어, 실시예들에서, 다른 구성 코드들 예를 들어, BCH 코드들 또는 폴라 서브코드들이 사용될 수 있다. 도 11은 실시예들에 따른, GCC S-RS 코드의 코드 구조를 예시적으로 도시한 도면이다. 도 11에 도시된 바와 같 이, GCC S-RS 코드는 RS 코드들과 RS 코드들의 연결을 나타낼 수 있다. 예를 들어, GCC S-RS 코드는 수학식 20에 표시된 바와 같이 에 대해 정의된, 중첩 RS 코드들의 집합과 관련될 수 있다. 수학식 37 및 수학식 38에 따라 제약이 추가될 수 있다. 수학식 37"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 40, "content": "수학식 38"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 41, "content": "따라서 GCC S-RS 코드는 아래의 수학식 39를 만족할 수 있다. 수학식 39"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 42, "content": "예를 들어, 개의 RS 코드들은 중첩 코드들 중 하나에 각각 속할 수 있고, 여기서 는 길이가 이고 디멘젼은 인, , 이고, 이다. 함수 는 코드워드 를 상응하는 폴라 중첩 코드에 맵핑하여, 및 이 되도록 할 수 있다. 변환 행렬 이 아래의 수학식 40 에 따라 정의될 수 있다. 수학식 40"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 43, "content": "상응하는 변환 공간 심볼들 은 및 에 대해 아래의 수학식 41에 따라 표현될 수 있다. 수학식 41"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 44, "content": "다음으로, 모든 에 대해, 심볼들의 벡터 는 길이가 L이고 디멘젼이 인 RS 코 드워드 로 정의될 수 있고, 여기서 이거나 동등하게는 이다. GCC S-RS 코드는 아래의 수학식 42에 따라 표시될 수 있다. 수학식 42"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 45, "content": "도 12a 내지 도 12c는 GCC 코드들 예를 들어, 상술한 GCC 코드들에 대한 인코딩 프로세스들의 예들과 관련된다. 실시예들에 따르면, GCC 인코딩 프로세스들은 상술한 임의의 요소 예를 들어, 도 2a와 관련하여 상술한 스토리 지 장치, 도 2b와 관련하여 상술한 ECC 인코딩 회로 또는 임의의 다른 요소를 사용하여 수행될 수 있 다. 도 12a는 알고리즘 1로서 의사 코드(pseudo-code)로 제시된, GCC 인코딩을 수행하기 위해 사용될 수 있는 순차 적 인코딩 알고리즘을 예시적으로 도시한 도면이다. 실시예들에 따르면, GCC 체계적 인코더는 아래의 수학식 43 에 따라 GCC 코드워드에 대해 알고리즘 1에 상응하는 인코딩 연산을 수행할 수 있다. 수학식 43"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 46, "content": "GCC 인코더 알고리즘은 코셋 체계적 폴라 인코더와 RS 체계적 인코더의 크리스-크로스(교차)(criss-cross) 활성 화들을 포함할 수 있다. 실시예들에서, 코셋 폴라 인코더는 아래의 수학식 44에 따라 표현될 수 있다. 수학식 44"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 47, "content": "수학식 44에 따른 코셋 폴라 인코더는 위치들( )에서 정보 비트들( ) 및 프로즌 값들( )을 수신할 수 있고, 체계적 인코딩된 워드( )를 반환할 수 있고, 여기서 이고 이다. 실시예들에 따르면, 정보 비트들은 제1 비트들( )에 위치할 수 있다. RS 체계적 인코더는 아래의 수학식 45에 따라 표현될 수 있다. 수학식 45"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 48, "content": "수학식 45에 따른 RS 체계적 인코더는 정보 심볼들( )을 수신하고 RS 코드워드 심볼들( )을 반환하여 를 갖는 RS 코드워드를 생성할 수 있고, 여기서 이고 이다. 도 12b는 상술한 GCC 인코더 알고리즘에 상응할 수 있는 예시적인 인코딩 순서를 나타내는 도면이다. 도 12b에 도시된 바와 같이, 정보 비트들의 코드 수는 이고, 오버헤드 비트들의 코드 수는 이다. 정 보 비트들의 위치들은 아래의 수학식 46에 의해 제공될 수 있다. 수학식 46"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 49, "content": "도 12b에 도시된 바와 같이, 동작(1221A)에서, 에서의 폴라 코드워드들에 대한 GCC 패리티 비트들이 폴라 인코더를 사용하여 결정될 수 있다. 동작(1221B)에서, 에서의 폴라 코드워드들에 대한 변환 공간 이 예를 들어, 수학식 34에 도시된 바와 같이 변환을 사용하여 결정될 수 있다. 동작(1221C)에서, 에서의 RS 코드워드에 대한 RS 패리티 비트들이 RS 인코더를 사용하여 결정될 수 있다. 도 12b에서 더 도시된 바와 같이, 동작(1222A)에서, 에서의 폴라 코드워드들에 대한 GCC 패리티 비트 들이 동작(1221C)에서 생성된, 의 변환 공간 심볼들을 기초로 폴라 코셋 인코더를 사용하여 결정될 수 있 다. 동작(122B)에서, 에서의 폴라 코드워드들에 대한 변환 공간이 상기 변환을 사용하여 결정될 수 있다. 동작(1222C)에서, 에서의 RS 코드워드에 대한 RS 패리티 비트들이 RS 인코더를 사용하여 결정될 수 있다. 도 12b에 더 도시된 바와 같이, 동작(1223A)에서, 에서의 폴라 코드워드에 대한 GCC 패리티 비트들이 동 작들(1221C 및 1222C)에서 생성된, 의 변환 공간 심볼들을 기초로 폴라 코셋 인코더를 사용하여 결정 될 수 있다. 동작(1223B)에서, 에서의 폴라 코드워드에 대한 변환 공간이 상기 변환을 사용하여 결정될 수 있다. 동작(1223C)에서, 에서의 RS 코드워드에 대한 RS 패리티 비트들이 상기 RS 인코더를 사용하여 결 정될 수 있다. 도 12b에 더 도시된 바와 같이, 동작(1224A)에서, 에서의 폴라 코드워드에 대한 GCC 패리티 비트들이 동 작들(1221C, 1222C 및 1223C)에서 생성된, 의 변환 공간 심볼들을 기초로 폴라 코셋 인코더를 사용하 여 결정될 수 있다. 동작(1224B)에서, 에서의 폴라 코드워드에 대한 변환 공간이 상기 변환을 사용하여 결정될 수 있다. 동작(1224C)에서, 에서의 RS 코드워드에 대한 RS 패리티 비트들이 상기 RS 인코더를 사용 하여 결정될 수 있다. 도 12b에 더 도시된 바와 같이, 동작(1225A)에서, 에서의 폴라 코드워드에 대한 GCC 패리티 비트들이 동 작들(1221C, 1222C, 1223C 및 1224C)에서 생성된, 의 변환 공간 심볼들을 기초로 폴라 코셋 인코더를 사용하여 결정될 수 있다. 실시예들에 따르면, 동작들(1221A, 122A, 1223A, 1224A 및 1225A)은 알고리즘 1의 “단계 a”에 상응할 수 있 고, 동작들(1221B, 122B, 1223B 및 1224B)은 알고리즘 1의 “단계 b”에 상응할 수 있고, 동작들(1221C, 1222C, 1223C 및 1224C)은 알고리즘 1의 “단계 c”에 상응할 수 있다. 도 12c는 실시예들에 따른, 인코딩 프로세스의 순서도이다. 예를 들어, 도 12c에 도시된 프로세스는 상술 한 알고리즘 1의 일부 또는 전부에 상응할 수 있다. 실시예들에서, 프로세스의 일부 또는 전부는 폴라 코 셋 인코더 예를 들어, 상술한 폴라 코셋 인코더를 사용하여 수행될 수 있다. 예를 들어, 동작에서, 프로 세스는 다음 폴라 코드워드를 인코딩하는 것을 포함할 수 있다. 동작에서, 프로세스는 인코 딩된 폴라 코드워드에 상응하는 변환 공간을 업데이트하는 것을 포함할 수 있다. 동작에서, 프로세스 는 마지막 폴라 코드워드에 도달했는지 여부를 결정하는 것을 포함할 수 있다. 마지막 폴라 코드워드에 도달했다는 결정(동작에서 예(YES))에 기초하여, 프로세스는 동작으로 진행할 수 있고, GCC 코드워드를 출력할 수 있다. 마지막 폴라 코드워드에 도달하지 않았다는 결정(동작에서 아니오(NO))에 기 초하여, 프로세스는 동작으로 진행할 수 있고, 이는 다음 폴라 코드워드가 동작에서 인코딩 된 폴라 코드워드와 동일한 차수(degree)를 갖는지 여부를 결정하는 것을 포함할 수 있다. 다음 폴라 코드워드 가 동일한 차수를 갖는다는 결정(동작에서 예)에 기초하여, 프로세스는 동작으로 복귀할 수 있다. 다음 폴라 코드워드가 동일한 차수를 갖지 않는다는 결정(동작에서 아니오)에 기초하여, 프로세스 는 동작으로 진행할 수 있다. 동작에서, 프로세스는 다음 RS 코드워드를 인코딩하는 것을 포함할 수 있다. 동작에서, 프로 세스는 마지막 RS 코드워드에 도달했는지 여부를 결정하는 것을 포함할 수 있다. 마지막 RS 코드워드에 도달했다는 결정(동작에서 예)에 기초하여, 프로세스는 동작으로 진행할 수 있고, 이는 RS 코드워드들을 인코딩한 결과들에 기초하여 폴라 코드워드들을 업데이트한 후, 동작으로 복귀하는 것을 포 함할 수 있다. 마지막 RS 코드워드에 도달하지 않았다는 결정에 기초하여, 프로세스는 동작으로 진 행할 수 있고, 이는 다음 RS 코드워드가 동일한 차수를 갖는지 여부를 결정하는 것을 포함할 수 있다. 다음 RS 코드워드가 동일한 차수를 갖는다는 결정(동작에서 예)에 기초하여, 프로세스는 동작으로 복 귀할 수 있다. 다음 RS 코드워드가 동일한 차수를 갖지 않는다는 결정(동작에서 아니오)에 기초하여, 프 로세스는 동작으로 진행할 수 있다. 실시예들에 따르면, 상술한 GCC 인코딩 프로세스들은 여기에 기술된 임의의 요소 예를 들어, 도 2a와 관련하여 상술한 스토리지 장치, 도 2b와 관련하여 상술한 ECC 인코딩 회로 또는 임의의 다른 요소를 사용하여 수행될 수 있다. 실시예들에 따르면, GCC는 구성 코드로서 폴라 서브코드 또는 구성 코드로서 BCH 코드로서 대신 정의될 수 있고, 다른 체계적 인코더들이 사용될 수 있다. 도 13은 실시예들에 따른, H-GCC 코드의 코드 구조를 예시적으로 도시한 도면이다. 도 13에 도시된 바와 같이, H-GCC 코드는 심볼들의 변환 공간으로의 변환 을 갖는 GCC 중첩 코드들의 군을 사용하여 표현될 수 있다. 실시예들에서, H-GCC는 각각이 개의 로컬 패리티 비트들 및 개의 글로벌 패리티 비트들을 갖고, 변환 공간에서 개의 RS 코드들을 사용하는, 길이가 이고, 디멘젼이 인, 개의 독립 GCC 코드들( 개의 RAU들에 상응할 수 있음)의 일반적인 연결일 수 있다. 실시예들에 따르면, H-GCC 코드는 상술한 바와 같이 RAU에 상응하는 GCC 코드와 관련될 수 있다. 예를 들어, H- GCC 코드는 아래의 수학식 47에 따라 표현되는 , 인 GCC 코드워드들에 상응할 수 있다. 수학식 47"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 50, "content": "GCC 코드는 이고 인 디멘젼들의 )인 개의 RS 코드들을 이용한, 인 디멘젼들의 인 개의 폴라 코드들의 연결일 수 있다. GCC 연결은 아래의 수학식 48에서와 같이, 수학식 34에 대해 상술한 것처럼 달성될 수 있다. 수학식 48"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 51, "content": "H-GCC 코드 구조와 관련하여, 이 변환 공간은 내부 변환 공간(inner transform space)이라 지칭될 수 있다. 외부 변환 공간(outer transform space)이라 지칭될 수도 있는 제2 변환 공간을 구성하기 위해, 먼저 수 (number)( )들( )의 리스트 및 상응하는 변환들"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 52, "content": "(여기서, )이 예를 들어, 수학식 21에서와 같이 정의될 수 있다. 외부 변환 공간은 수학식 49 및 수학식 50에서와 같이 심볼들 로서 정의될 수 있고, 이들은 서로 동일할 수 있다. 수학식 49"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 53, "content": "수학식 50 각 에 대해, 상기 변환은 아래의 수학식 51에 따라 정의될 수 있다. 수학식 51"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 54, "content": "도 14는 실시예들에 따른, 내부 변환 공간 및 외부 변환 공간을 예시적으로 도시한 도면이다. 도 14에서와 같이, GCC 코드 길이는 이고, 오버헤드는 이고, 여기서 은 상기 RAU의 로컬 오버 헤드에 상응할 수 있다. H-GCC의 다음의 계층 구조(hierarchy)는 상술한 바와 같은 개의 GCC 구성 코드워드들을 RS 코드들과 연결하 여 정의될 수 있다. 맵핑 이 외부 변환 공간 심볼들 , 및 개의 RS 코드들, 이고 사이에서 정의되어 심볼 가 수학식 52에 따라 정의될 수 있고, 상응하는 변환은 아래의 수학식 53에 따라 나타낼 수 있다. 수학식 52"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 55, "content": "수학식 53"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 56, "content": "상기 변환은 구성 코드들 각각에 대해 적용될 수 있다. 의 구성 코드들의 폴라 코드들은 로 표시될 수 있다. 따라서 변환 공간 심볼들은 수학식 54에 따라 정의될 수 있고, 상기 변환은 아래의 수학식 55에 따라 정 의될 수 있다. 수학식 54 수학식 55"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 57, "content": "RS 코드 연결은 이고, 가 RS 코드들 디멘젼들이고, 인 개의 RS 코드들 을 정의함으로써 수행될 수 있다. RS 코드워드 는 수학식 56에 따라 표현될 수 있고, 상응하는 패리티 체크 행렬 은 아래의 수학식 57에 따 라 표현될 수 있다. 수학식 56"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 58, "content": "수학식 57"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 59, "content": "구성 코드들 각각에 의해 할당되는 추가적인 (글로벌) 오버헤드는 각 에 대해 상수(constant)일 수 있고, 와 동일할 수 있으므로, 디멘젼 가 된다. 실시예들에서, 도 13에 도시된 H-GCC 코드는 아래의 수학식 58에서와 같이, 개의 GCC 코드들의 연결을 사용 하여 표현될 수 있다. 수학식 58"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 60, "content": "상응하는 변환 는 수학식 33의 변환을 사용하고, 에 속하는 폴라 구성 코드들을 로서 정의함으로써 얻어 질 수 있다. 결과적으로 변환 행렬은 수학식 59에서와 같이 정의될 수 있다. 수학식 59"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 61, "content": "다음으로 S-RS 디코더 코드들의 집합은 아래의 수학식 60에 따라 표현될 수 있다. 수학식 60"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 62, "content": "S-RS 코드워드 는 RS 코드워드들 , 을 포함할 수 있고, 여기서 RS 코드워드 는 아래 의 수학식 61에서와 같이 심볼들 , 에 기반하여 정의될 수 있다. 수학식 61"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 63, "content": "도 15는 상술한 H-GCC 코드 구조를 예시적으로 도시한 도면이다. 실시예들에서, S-RS 코드워드 는 개의 RS 코드들 , 및 변환 을 포함할 수 있다. 따라서 아래의 수학식 62로서 표현되는 변 환 공간이 형성될 수 있다. 수학식 62"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 64, "content": "도 16은 에 대해 를 갖는, 상응하는 RS 코드들을 예시 적으로 도시한 도면이다. 상술한 계층형 코드는 패리티 체크 행렬을 갖는 선형 코드일 수 있다. 예를 들어, H-GCC 코드워드는 GCC 구성 코드들 의 연결일 수 있고, GCC 구성 코드는 폴라 코드들 의 연결일 수 있다. 도 17a 내지 도 21은 상술한 바와 같은 H-GCC 코드들에 대한 인코딩 프로세스들을 예시적으로 설명하기 위해 사 용될 수 있다. 실시예들에 따르면, H-GCC 인코딩 프로세스들은 상술한 임의의 요소 예를 들어, 도 2a와 관련하 여 상술한 스토리지 장치, 도 2b와 관련하여 상술한 ECC 인코딩 회로 또는 임의의 다른 요소를 사용 하여 수행될 수 있다. 실시예들에 따르면, 상술한 H-GCC 코드들 중 하나 이상에 상응하는 H-GCC 인코더는 개의 RAU들 중 각 하나에 대해 개의 정보 비트들을 수신할 수 있고, 각 RAU를 개별적으로 디코딩할 수 있는 로컬 패리티 및 개의 RAU를 공동으로 디코딩하기 위해 사용될 수 있는 글로벌 패리티 비트들 을 갖는 개의 코드워드들을 생성할 수 있다. 도 17a 내지 도 18b는 H-GCC 인코딩 프로세스의 첫 번째 예와 관련 있다. 특히 도 19a 내지 도 20b에 따르면, H-GCC 인코딩 프로세스의 첫 번째 예는 선형 제약들을 갖는 단순한 체계적 인코더를 사용하여 수행될 수 있다. 실시예들에서, H-GCC 인코딩 프로세스의 첫 번째 예는 도 14와 관련하여 상술된 H-GCC 코드 구조와 관련될 수 있다. 실시예들에서, H-GCC 인코딩 프로세스의 상기 첫 번째 예를 수행하기 위해 사용되는 기본 인코더는 개의 GCC 인코더들을 포함할 수 있다. 실시예들에서, 기본 인코더는 도 17a 및 도 17b와 관련하여 아래에서 논의되는 기 본 인코더에 상응할 수 있고, 개의 GCC 인코더들 각각은 도 12a 내지 도 12c와 관련하여 위에서 논의 된 GCC 인코더에 상응할 수 있다. 이러한 기본 인코더에 사용되는 GCC 코드는 아래의 수학식 63에서와 같이 의 중첩 코드일 수 있는 GCC 코드워 드에 상응할 수 있다. 수학식 63"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 65, "content": "정보 비트들 및 밸런싱 비트들은 코드워드 에 대한 위의 수학식 46에서와 같이 정보 인덱스들 에 위치될 수 있다. 실시예들에서, 수학식 64가 만족될 수 있다. 수학식 64"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 66, "content": "다음으로 추가적인 밸런스 비트 의 위치들이 정의되어 일 수 있다. 정보 비트들은"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 67, "content": "에 위치할 수 있고, 일 수 있다. 의 선택은 H-GCC 인코딩에 사용되는 전이 행렬 가 반 전될 수 있도록 해야 한다. 전이 행렬 의 예는 도 18a 및 도 18b와 관련하여 아래에서 논의된다. H-GCC 제약은 변환 공간 패리티 체크의 모든 워드들이 0(zero)이 되도록 지정할 수 있다. 이 제약은 H-GCC 코드 워드들의 인코딩을 수행하는데 사용될 수 있는 제약 행렬 및 제약 벡터 을 지정하는데 사용될 수 있다. 이러한 인코딩의 예는 도 17a 및 도 17b와 관련하여 아래에서 논의된다. 제약 행렬 는 아래와 같이 형성될 수 있다. 위의 수학식 54 및 수학식 55에 정의된 변환을 사용하면, 변환 공 간은 아래의 수학식 65에 따라 정의될 수 있다. 수학식 65"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 68, "content": "변환 공간은 , 인 개의 RS 코드들을 포함할 수 있고, 이는 아래의 수학식 66과 같 이 표현될 수 있다. 수학식 66"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 69, "content": "워드가 H-GCC 코드워드라는 것을 보장하기 위해 모든 개의 RS 코드워드들은 아래의 수학식 67을 만족할 수 있 다. 수학식 67"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 70, "content": "또한, 는 위의 수학식 19에 따라 사용될 수 있다. 제약들의 전체 수는 아래의 수학식 68로서 표현될 수 있다. 수학식 68"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 71, "content": "이러한 제약들을 사용하여, 전이 행렬 이 도 18a 및 도 18b와 관련하여 아래에서 논의되는 바와 같이 생성될 수 있다. 정보 위치들 및 밸런스 비트들 위치들 , , 제약 행렬 , 전이 행렬 및 기본 인코더에 기초하 여, 상기 첫 번째 예에 따른 H-GCC 인코딩이 도 17a 및 도 17b와 관련하여 아래에서 논의되는 바와 같이 진행될 수 있다. 실시예들에서, H-GCC 인코딩 방식의 첫 번째 예에 대한 파라미터들은 아래의 수학식 69, 수학식 70 및수학식 71에서와 같이 표현될 수 있고, 여기서 는 기본 인코더의 입력 벡터의 길이를 나타내고, 는 기본 인코더의 코드워드들의 길이를 나타낸다. 수학식 69"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 72, "content": "수학식 70"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 73, "content": "수학식 71"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 74, "content": "도 17a는 실시예들에 따른, H-GCC 인코딩 프로세스의 상기 첫 번째 예에 따른 H-GCC 코드워드를 생성하기 위해 정보 비트들을 인코딩하기 위한 인코더(1700A)를 예시적으로 나타내는 블록도이다. 실시예들에서, 인코더 (1700A)는 제약 변환 모듈, 전이 행렬 모듈, 기본 인코더 및 제약 행렬 모듈을 포함 할 수 있다. 기본 인코더는 입력 벡터 를 수신하고 코드워드 를 출력할 수 있는 체계적 인코더일 수 있다. 인코더 (1700A)는 제약 변환 모듈을 더 포함할 수 있고, 이는 기본 인코더의 입력과 곱 벡터(product vector) 사이의 변환을 찾는데 사용될 수 있다. 인코더(1700A)는 곱 벡터 를 밸런스 비트들 로 변환할 수 있는 전이 행렬을 적용할 수 있는 전이 행렬 모듈을 더 포함할 수 있다. 실시예들에서, 기본 인코더 는 길이 를 가질 수 있는 입력 벡터 를 입력으로서 수신할 수 있고, 아래의 수학식 72에 따라 코드워 드 를 출력하기 위해 입력 벡터 를 인코딩할 수 있다. 수학식 72"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 75, "content": "실시예들에서, 는 GCC 인코더 예를 들어, 상술한 임의의 GCC 인코더들에 상응할 수 있다. H-GCC 인코딩 방식에 따르면, 아핀(affine) 제약들의 집합이 아래의 수학식 73과 같이 부과될 수 있고, 여기서 이 다.수학식 73"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 76, "content": "도 17a에 도시된 바와 같이, 제약 변환 모듈은 입력 벡터 를 입력으로서 수신하고, 길이 을 가질 수 있 는 예비 제약 벡터(preliminary constraints vector) 를 출력하기 위해 선형 제약 변형(linear constraints transform)을 적용할 수 있다. 실시예들에서, 제약 변환 모듈은 기본 인코더를 포함할 수 있고, 이 는 예비 코드워드 를 얻기 위해 입력 벡터 를 인코딩할 수 있다. 그 다음에 제약 변환 모듈은 예비 코 드워드 에 제약 행렬 를 곱하여 예비 제약 벡터 를 얻을 수 있다. 제약들을 시행하기 위해, 입력 벡터 는 추가적인 개의 비트들을 포함하도록 확장될 수 있고, 이는 로 표시되 는 밸런스 비트들일 수 있다. 예를 들어, 인코더(1700A)에 대한 입력으로서 사용되는 입력 벡터 는 길이 를 가질 수 있고, 길이 를 가질 수 있는 정보 벡터 내에서 정보 비트들을 포함할 수 있고, 길이 를 가 질 수 있는 밸런스 비트들 을 더 포함할 수 있다. 실시예들에서, 내의 정보 비트들에 대해 설정된 인덱스들은 집합 로 지칭되어 가 되도록 할 수 있고, 내의 밸런스 비트들에 대한 인덱스들 집합은 집합 로 지칭 되어 이고 가 되도록 할 수 있다. 의 인덱스들의 집합 위치들은 특정 문제 예를 들어, 사 용되는 특정 코드들에 맞게 조정될 수 있고 반드시 연속적일 필요는 없다. 실시예들에서, 밸런스 비트들은 출력 코드워드 가 요구되는 제약들을 충족하도록 하는데 사용될 수 있다. 밸 런스 비트들 과 예비 제약 벡터 사이의 관계를 결정하기 위해, 전이 행렬 이 조립될 수 있다 (assembled). 전이 행렬 는 표준 기저 (여기서 이고 )를 인코더(1700A)에 서 사용될 수 있는 기저로 변환하는데 사용될 수 있다. 도 17b는 실시예들에 따른, 인코더(1700A)를 사용하여 출력 코드워드를 생성하기 위한 프로세스(1700B)를 나타 내는 순서도이다. 도 17a 및 도 17b를 참조하면, 동작에서, 프로세스(1700B)는 정보 벡터 를 입력 벡터 에 배치하고, 밸런스 비트들 을 '0'(zero)으로 설정하는 것을 포함할 수 있다. 동작에서, 프로세스 (1700B)는 기본 인코더를 사용하여 예비 코드워드 를 얻기 위해 입력 벡터 를 인코딩하는 것을 포함할 수 있다. 동작에서, 프로세스(1700B)는 제약 변환 모듈을 사용하여 예비 제약 벡터 를 얻기 위해 입력 벡터 를 인코딩하는 것을 포함할 수 있다. 동작에서, 프로세스(1700B)는 제약 변환 모듈을 사용하여 예비 제약 벡터 를 계산하는 것을 포함할 수 있다. 동작에서, 프로세스(1700B)는 전이 행렬모듈을 사용하여 예비 제약 벡터 및 타겟 제약 벡터 에 기초한 밸런스 비트들 을 계산하는 것을 포함할 수 있다. 동작에서, 프로세스(1700B)는 밸런스 비트들 을 입력 벡터 에 배치하고, 정보 벡터 를 '0'(zero)으로 설정함으로써 입력 벡터 를 업데이트하는 것을 포함할 수 있다. 동작에서, 프로세스 (1700B)는 기본 인코더를 사용하여 예비 코드워드 를 얻기 위해 업데이트된 입력 벡터 를 인코딩하는 것을 포함할 수 있다. 동작에서, 프로세스(1700B)는 예비 코드워드 와 예비 코드워드 의 합(sum)을 획득함으로써 출력 코드워드 를 생성하는 것을 포함할 수 있다. 실시예들에서, 출력 코드워드 는 H-GCC 코드워드에 상응할 수 있다. 도 18a는 실시예들에 따른, 전이 행렬 를 구성하기 위한 프로세스의 일 예를 나타내는 도면이다. 도 18b는 실 시예들에 따른, 도 18a에 상응하는 전이 행렬 를 구성하기 위한 프로세스(1800B)를 나타내는 순서도이다. 도 18a에 도시된 바와 같이, 부터 까지 각 에 대해, 상술한 제약 변환 모듈에 다른 입력 벡 터 가 입력되어 제약 벡터 를 구한 다음 제약 벡터들 이 전이 행렬 로 조립된다. 예를 들어, 동작에서, 프로세스는 기저 벡터 와 동일한 밸런스 비트들 을 설정하는 것을 포함할 수 있다. 동작에서, 프로세스는 밸런스 비트들 을 입력 벡터 에 배치하고, 입력 벡터 의 정보 벡터 를 '0'(zero)으로 설정하는 것을 포함할 수 있다. 동작에서, 프로세스는 제약 변환 모듈 을 사용하여 제약 벡터 를 계산하는 것을 포함할 수 있다. 그 다음에, 동작에서, 프로세스 는 전이 행렬 의 번째 열에 제약 벡터를 배치하는 것을 포함할 수 있고, 이는 전치 행렬(transposed matrix) 의 번째 행일 수 있다. 도 17a에 도시된 바와 같이, 밸런스 비트들 은 입력 벡터 의 우측(right side)에 그룹화 및 정렬될 수 있으나, 본 개시의 실시예들이 이에 한정되는 것은 아니다. 예를 들어, 실시예들 에서 밸런스 비트들 은 입력 벡터 의 임의의 위치에 인러티빙될 수 있다. 실시예들에서, 전이 행렬 는 밸런스 비트들 를 갖는 임의의 길이의 벡터를 생성하는데 사용될 수 있다. 이를 위해, 전이 행렬 은 풀 랭크일 수 있다(fully ranked). 전이 행렬 가 풀 랭크가 아니라면, 집합 는 변경될 수 있다. 에서 로의 변환은 선형이고, 아래의 수학식 74에 따라 표현될 수 있다. 수학식 74 도 18a 및 도 18b에 따라 계산된 전이 행렬 는 반전될 수 있다(invertible). 결과적으로 임의의 제약 벡터"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 77, "content": "에 대해, 를 생성하는 밸런스 비트들 가 아래의 수학식 75에 따라 구해질 수 있다. 수학식 75"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "item": 78, "content": "도 19a 내지 도 20c는 H-GCC 인코딩 프로세스의 두 번째 예와 관련 있다. 특히 도 19a 내지 도 20c에 따르면, H-GCC 인코딩 프로세스의 두 번째 예는 순차적(sequential) 인코더를 사용하여 수행될 수 있다. 실시예들에서, H-GCC 인코딩 프로세스의 두 번째 예는 도 15 내지 도 16과 관련하여 상술한 H-GCC 코드 구조와 관련될 수 있다. H-GCC 인코딩 프로세스의 두 번째 예에 따르면, 아래의 수학식 76 및 수학식 77에 따른, 추가 패리티 비트들"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 79, "content": "의 선택에 제약이 가해질 수 있다. 수학식 76"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 80, "content": "수학식 77"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 81, "content": "이러한 제약들은 H-GCC 인코딩 프로세스의 두 번째 예가 순차적 인코더를 사용하여 수행되도록 할 수 있다. 코드워드 는 로컬 디멘젼 및 기본 로컬 오버헤드 를 가질 수 있다. 추가 글로벌 오버헤드 비트들 이 추가될 수 있고, 인 정보 비트들이 생성될 수 있고, 상응하는 RS 코드들의 오버헤드 가 위의 수학식 35에 따라 결정될 수 있다. 추가 글로벌 오버헤드 비트들 은 상응하는 추가 오버헤드 를 생성할 수 있고, 이는 아래의 수학식 78에 따 라 표현될 수 있다. 수학식 78"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 82, "content": "로 표시되는 S-RS 코드들에 대해, S-RS 코드들과 관련하여 상술한 바와 같이 추가 오버헤드 가 와 를 정의할 수 있다. 추가 글로벌 오버헤드 비트들 의 선택은 다음과 같은 제약들을 충족할 수 있다. 예를 들어, 추가 글로벌 오버 헤드 비트들 은 아래의 수학식 79에 따라 계단식(stairstep) 구조를 가질 수 있다. 수학식 79"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 83, "content": "추가 글로벌 오버헤드 비트들 은 아래의 수학식 80에 따라 글로벌 패리티 비용(budget)을 만족할 수 있다. 수학식 80"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 84, "content": "S-RS 코드들은 아래의 수학식 81 및 수학식 82를 만족할 수 있다. 수학식 81"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 85, "content": "수학식 82"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 86, "content": "수학식 82는 집합들 간에 동일할 수 있고, 아래의 수학식 83을 만족하는 퍼뮤테이션(permutation) 가 존재할 수 있음을 의미한다. 수학식 83"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 87, "content": "퍼뮤테이션은 S-RS 행들을 퍼뮤테이션함(permutating)으로써 달성될 수 있는데, 에 대해 수학식 35를 적용하면 인 결과가 된다. 도 19a는 실시예들에 따른, H-GCC 인코딩 프로세스의 두 번째 예에 상응하는 H-GCC 코드워드에 대한 오버헤드 할당을 예시적으로 도시한 도면이다. 예를 들어, 도 19a에서, t = 2, 에 대한 S-RS 코드워드는 , 및 를 가질 수 있다. 실시예들에서, 도 21a에 도시된 바와 같이, 에 대한 S-RS 코드워드는 를 가질 수 있다. 실시예들에서, 도 91a에 도시된 코드 구조는 도 15의 코드 구조에 상응할 수 있다. S-RS 코드 에 대해, 도 12a 내지 도 12c와 관련하여 상술한 바와 같이, GCC 체계적 인코더가 적용될 수 있다. 실시예들에서, 퍼뮤테이션 가 S-RS 행들에 대해 먼저 적용될 수 있다. 상기 퍼뮤테이션 이후의 GCC 인코딩 및 디-퍼뮤테이션(de-permutation)은 “S-RS 인코더( )”(S-RS Encoder( ))로 표시될 수 있다. 도 19b는 실시예들에 따른, 순차적 H-GCC 인코더에서 S-RS 코드워드들을 사용하기 위해 S-RS 코드워드들에 대해 수행될 수 있는 행 퍼뮤테이션을 예시적으로 나타내는 도면이다. 특히, 도 19b는 행 퍼뮤테이션 전후(before and after)의 도 19a로부터의 에 대한 S-RS 코드워드를 도시한다. 도 19b에 도시된 바와 같이, 에 대한 S-RS 코드워드는 행 퍼뮤테이션 후의 계단식 구조를 가질 수 있고, 따라서 순차적 H-GCC 인코더에 적합할 수 있다. 도 20a 내지 도 20c는 상술한 H-GCC 인코딩 프로세스의 두 번째 예와 관련된다. 실시예들에 따르면, H-GCC 인코 딩 프로세스는 순차적 인코더를 사용하여 수행될 수 있고, 이는 상술한 임의의 요소 예를 들어, 도 2a와 관련하 여 상술한 스토리지 장치, 도 2b와 관련하여 상술한 ECC 인코딩 회로 또는 임의의 다른 요소에 포함 될 수 있다. 도 20a는 알고리즘 1로서 의사 코드로 제시된, H-GCC 인코딩을 수행하기 위해 사용될 수 있는 순차적 인코딩 알 고리즘을 예시적으로 도시한 도면이다. 순차적 H-GCC 인코더 알고리즘은 코셋 폴라 인코더와 S-RS 인코더의 크 리스-크로스 활성화들을 포함할 수 있다. 실시예들에서, 코셋 폴라 인코더는 알고리즘 2에서 “폴라 인코더( ) ”“ ”)로 표시될 수 있다. 실시예들에서, 코셋 폴라 인코더는 상술한 수학식 44에 상응할 수 있다. 도 20b는 상술한 순차적 H-GCC 인코더 알고리즘에 상응할 수 있는 인코딩 순서를 예시적으로 도시한 도면이다. 도 20b에 도시된 바와 같이, 동작(2021A)에서, , , =[1,2]에서의 폴라 코드워드들에 대한 로 컬 오버헤드 비트들은 폴라 인코더를 사용하여 결정될 수 있다. 동작(2021B)에서, , , =[1,2]에서의 폴라 코드워드들에 대한 변환 공간은 변환을 사용하여 결정될 수 있다. 동작(2021C)에서, 에 서의 S-RS 코드워드에 대한 오버헤드 패리티 비트들은 S-RS 인코더를 사용하여 결정될 수 있다. 도 20b에 더 도시된 바와 같이, 동작(2022A)에서, , , =[3]에서의 폴라 코드워드들에 대 한 로컬 오버헤드 비트들은 폴라 인코더를 사용하여 결정될 수 있다. 동작(2022B)에서, t , , =[3]에서의 폴라 코드워드들에 대한 변환 공간은 변환을 사용하여 결정될 수 있다. 동작(2022C)에서, 에서의 S-RS 코드워드에 대한 오버헤드 패리티 비트들은 S-RS 인코더를 사용하여 결정될 수 있다. 도 20b에 더 도시된 바와 같이, 동작(2023A)에서, , , =[4,5]에서의 폴라 코드워드들에 대한 로컬 오버헤드 비트들은 폴라 인코더를 사용하여 결정될 수 있다. 동작(2023B)에서, , , =[4,5]는 변환을 사용하여 결정될 수 있다. 동작(2023C)에서, 에서의 S-RS 코드워드에대한 오버헤드 패리티 비트들은 S-RS 인코더를 사용하여 결정될 수 있다. 도 20b에 더 도시된 바와 같이, 동작(2024A)에서, 에서의 폴라 코드워드들에 대한 로 컬 오버헤드 비트들은 폴라 인코더를 사용하여 결정될 수 있다. 동작(2024B)에서, , , =[]에 서의 폴라 코드워드들에 대한 변환 공간은 변환을 사용하여 결정될 수 있다. 동작(2024C)에서, 에서의 S- RS 코드워드에 대한 오버헤드 패리티 비트들은 S-RS 인코더를 사용하여 결정될 수 있다. 도 20b에 더 도시된 바와 같이, 동작(2025A)에서, , , =[6,7,8]에서의 폴라 코드워드들에 대한 로컬 오버헤드 비트들은 폴라 인코더를 사용하여 결정될 수 있다. 동작(2025B)에서, , , =[6,7,8]에서의 폴라 코드워드들에 대한 변환 공간은 변환을 사용하여 결정될 수 있다. 동작(2025C)에서, 에서의 S-RS 코드워드에 대한 오버헤드 패리티 비트들은 S-RS 인코더를 사용하여 결정될 수 있다. 도 20b에 더 도시된 바와 같이, 동작(2026A)에서, , , =[]에서의 폴라 코드워드들에 대한 로 컬 오버헤드 비트들이 폴라 인코더를 사용하여 결정될 수 있다. 실시예들에 따르면, 동작들(2021A, 2022A, 2023A, 2024A, 2025A 및 2026A)은 알고리즘 2의 “단계 a”에 상응 할 수 있고, 동작들(2021B, 2022B, 2023B, 2024B 및 2025B)은 알고리즘 2의 “단계 b”에 상응할 수 있고, 동 작들(2021C, 2022C, 2023C 및 2024C)은 알고리즘 2의 “단계 c”에 상응할 수 있다. 도 20c는 실시예들에 따른, 인코딩 프로세스를 나타내는 순서도이다. 예를 들어, 도 20c에 도시된 바와 같은 프 로세스(2000C)는 상술한 알고리즘 2의 일부 또는 전부에 상응할 수 있다. 예를 들어, 동작에서, 프로세스 (2000C)는 현재 프레임에 대한 다음 폴라 코드워드를 인코딩하는 것을 포함할 수 있다. 동작에서, 프로세 스(2000C)는 인코딩된 폴라 코드워드들에 상응하는 변환 공간을 업데이트하는 것을 포함할 수 있다. 동작(203 3)에서, 프로세스(2000C)는 마지막 프레임에 도달했는지 여부를 결정하는 것을 포함할 수 있다. 마지막 프레임 에 도달하지 않았다는 결정(동작에서 아니오)에 기초하여, 프로세스(2000C)는 다음 프레임을 현재 프레임 으로서 설정할 수 있고, 동작으로 복귀할 수 있다. 마지막 프레임에 도달했다는 결정(동작에서 예)에 기초하여, 프로세스(2000C)는 동작으로 진행할 수 있다. 동작에서, 프로세스(2000C)는 각 프레임의 마지막 폴라 코드워드들에 도달했는지 여부를 결정하는 것을 포함할 수 있다. 마지막 폴라 코드워드들에 도달했다는 결정(동작에서 예)에 기초하여, 프로세스(2000C) 는 동작으로 진행하고, H-GCC 코드워드를 출력할 수 있다. 마지막 폴라 코드워드들에 도달하지 않았다는 결정(동작에서 아니오)에 기초하여, 프로세스(2000C)는 동작으로 진행할 수 있고, 이는 다음 폴라 코드워드들이 동작에서 인코딩된 폴라 코드워드들과 동일한 차수를 갖는지 여부를 결정하는 것을 포함할 수 있다. 다음 폴라 코드워드들이 동일한 차수를 갖는다는 결정(동작에서 예)에 기초하여, 프로세스 (2000C)는 동작으로 복귀할 수 있다. 다음 폴라 코드워드들이 동일한 차수를 갖지 않는다는 결정(동작 에서 아니오)에 기초하여, 프로세스(2000C)는 동작으로 진행할 수 있다. 동작에서, 프로세스(2000C)는 다음 S-RS 코드워드를 인코딩하는 것을 포함할 수 있다. 동작에서, 프로세스(2000C)는 마지막 S-RS 코드워드에 도달했는지 여부를 결정하는 것을 포함할 수 있다. 마지막 S-RS 코 드워드에 도달했다는 결정(동작에서 예)에 기초하여, 프로세스(2000C)는 동작으로 진행할 수 있고, 이는 S-RS 코드워드들을 인코딩한 결과들에 기초하여 폴라 코드워드들을 업데이트한 다음, 동작으로 복귀 하는 것을 포함할 수 있다. 마지막 S-RS 코드워드에 도달하지 않았다는 결정에 기초하여, 프로세스(2000C)는 동 작으로 진행할 수 있고, 이는 다음 RS 코드워드가 동일한 차수를 가지는지 여부를 결정하는 것을 포함할 수 있다. 다음 S-RS 코드워드가 동일한 차수를 갖는다는 결정(동작에서 예)에 기초하여, 프로세스(2000 C)는 동작으로 복귀할 수 있다. 다음 S-RS 코드워드가 동일한 차수를 갖지 않는다는 결정(동작에서 아니오)에 기초하여, 프로세스(2000C)는 동작으로 진행할 수 있다. 실시예들에 따르면, 상술한 H-GCC 인코딩 프로세스들은 여기에 개시된 임의의 요소 예를 들어, 도 2a와 관련하 여 상술한 스토리지 장치, 도 2b와 관련하여 상술한 ECC 인코딩 회로 또는 임의의 다른 요소를 사용 하여 수행될 수 있다. 실시예들에 따르면, H-GCC 코드는 구성 코드로서 폴라 서브코드, 또는 구성 코드로서 BCH 코드로서 대신하여 정 의될 수 있고, 다른 체계적 인코더들이 사용될 수 있다. 도 21은 실시예들에 따른, 스토리지 장치를 제어하는 프로세스를 나타내는 순서도이다. 일부 실시예들에 서, 도 21의 하나 이상의 프로세스 블록들은 상술한 인코더들 중 임의의 하나 이상에 의해 수행될 수 있다. 도 21에 도시된 바와 같이, 동작에서, 프로세스는 정보 비트들을 획득하는 것을 포함할 수 있다. 도 21에 더 도시된 바와 같이, 동작에서, 프로세스는 복수의 내부 코드워드들을 획득하기 위해 내 부 코드를 사용하여 정보 비트들을 인코딩하는 것을 포함할 수 있다. 도 21에 더 도시된 바와 같이, 동작에서, 프로세스는 외부 코드워드를 생성하기 위해 외부 코드를 사용하여 복수의 내부 코드워드들을 인코딩하는 것을 포함할 수 있다. 실시예들에서, 내부 코드 및 외부 코드 중 적어도 하나는 일반화된 연결 코드(GCC)를 포함할 수 있고, 외부 코 드워드는 계층적-GCC(H-GCC) 코드워드를 포함할 수 있다. 도 21에 더 도시된 바와 같이, 동작에서, 프로세스는 스토리지 장치에 외부 코드워드를 저장하는 것을 포함할 수 있다. 실시예들에서, H-GCC 코드워드는 복수의 프레임들을 포함할 수 있고, 복수의 프레임들의 각 프레임은 동일한 길 이를 갖고, 복수의 프레임들의 각 프레임은 내부 코드에 기초하여 생성된 동일한 수의 로컬 패리티 비트들을 포 함할 수 있고, 복수의 프레임들 중 각 프레임은 외부 코드에 기초하여 생성된 동일한 수의 글로벌 패리티 비트 들을 포함할 수 있다. 실시예들에서, 복수의 프레임들의 각 프레임은 스토리지 장치에 포함된 RAU에 저장될 수 있다. 실시예들에서, 내부 코드는 GCC를 포함할 수 있고, 내부 코드의 구성 코드들은 폴라 코드 및 제1 RS 코드를 포 함할 수 있고, 외부 코드는 제2 RS 코드를 포함할 수 있다. 실시예들에서, 이러한 H-GCC 코드 구조는 상술한 도 13 및 도 14에 상응할 수 있다. 실시예들에서, 내부 코드는 폴라 코드를 포함할 수 있고, 외부 코드는 GCC를 포함할 수 있고, 외부 코드의 구성 코드들은 제1 RS 코드 및 제2 RS 코드를 포함할 수 있다. 실시예들에서, 이러한 H-GCC 코드 구조는 상술한 도 15에 상응할 수 있다. 실시예들에서, 외부 코드워드는 복수의 프레임들을 포함할 수 있고, 정보 비트들의 인코딩은, 로컬 패리티 비트 들을 생성하기 위해 폴라 코드를 정보 비트들에 적용하는 것, 및 로컬 패리티 비트들을 복수의 내부 코드워드들 에 배치하는 것을 포함할 수 있고, 그리고 복수의 내부 코드워드들을 인코딩하는 것은, 변환 공간에서 복수의 심볼들의 집합들을 생성하기 위해 복수의 내부 코드워드들에 제1 변환을 적용하는 것(여기서, 복수의 심볼들의 집합들 중 각 심볼들의 집합은 복수의 내부 코드워드들 중 내부 코드워드에 상응함.), 복수의 심볼들의 집합들 은 외부 코드워드로 그룹화하는 것, 글로벌 패리티 비트들을 생성하기 위해 제1 RS 코드 및 제2 RS 코드를 외부 코드워드에 적용하는 것, 및 H-GCC 코드워드를 생성하기 위해 복수의 내부 코드워드들에 글로벌 패리티 비트들 을 배치하는 것을 포함할 수 있다. 실시예들에서, 이러한 H-GCC 인코딩 프로세스는 상술한 도 19a 내지 도 20c 에 상응할 수 있다. 실시예들에서, 복수의 내부 코드워드들은 제1 내부 코드워드 및 제2 내부 코드워드를 포함할 수 있고, 복수의 심볼들의 집합들은 제1 내부 코드워드를 기초로 생성된 심볼들의 제1 집합을 포함할 수 있고, 제1 집합은 글로 벌 패리티 비트들 중 적어도 하나의 제1 글로벌 패리티 비트를 생성하는데 사용될 수 있고, 적어도 하나의 제1 글로벌 패리티 비트는 폴라 코드를 제2 내부 코드워드에 적용하는데 사용될 수 있다. 실시예들에서, 이러한 H- GCC 코드 구조는 상술한 도 20a 내지 도 20c에 상응할 수 있다. 실시예들에서, 심볼들의 제1 집합들은 제1 RS 코드 및 제2 RS 코드가 적용되기 전에 퍼뮤테이션될 수 있다(be permutated). 실시예들에서, 이러한 퍼뮤테이션은 상술한 도 19b에 상응할 수 있다. 도 21은 프로세스의 예시적인 블록들을 도시하고 있지만, 일부 실시예들에서, 프로세스는 도 21에 도시된 블록들보다 더 많은 블록들, 더 적은 블록들, 다른 블록들 또는 다르게 배열된 블록들을 포함할 수있다. 추가적으로 또는 대안적으로, 프로세스의 블록들 중 둘 이상은 임의의 순서도 배열 또는 결합되거 나 병렬적으로 수행될 수 있다. 따라서 실시예들은 GCC 구성 코드들과 RS 코드들의 연결로서 표현될 수 있는 H-GCC 계층적 코드군과 관련될 수 있다. H-GCC 코드는 개의 GCC 구성 코드워드들 및 변 환 에 상응할 수 있고, 또한 파라미터들 , 및 맵핑 , 및 RS 코드들 , 에 상응할 수 있다. 실시예들에서, H-GCC 코드는 길이 및 디멘젼 을 가질 수 있다. H-GCC 코드는 각각의 길이가 인 개의 구성 코드들 을 포함할 수 있고, 로컬 오버헤드 및 추가 글로벌 오버헤드 를 포함할 수 있다. H-GCC 코드의 동등한 구성은 S-RS 코드워드들 의 집합과 관련될 수 있다. 이러한 코드의 패리티 체크 행렬은 아래의 수학식 84에 따라 표현될 수 있다. 수학식 84"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 88, "content": "실시예들은 또한 GCC 코드들 각각에 대해, 개의 로 컬 패리티 비트들을 생성하기 위해 GCC 체계적 인코더를 사용할 수 있는 체계적 인코더와 관련될 수 있다. 글로 벌 제약 수학식들을 충족하기 위해, 균형 비트들 위치(balanced bits location)인 가 선택되고, 제약 생성 행 렬(constraint generator matrix) 가 생성된다. 실시예들은 또한 폴라 코셋 인코더와 S-RS 인코더의 교차 활성화를 포함하는 체계적 순차적 인코더와 관련될 수 있다. S-RS 인코더는 순차적 인코더를 활성화하기 위해 RS 행들에 대해 퍼뮤테이션을 사용할 수 있다. 도 22는 실시예들에 따른, 메모리 장치가 적용된 데이터 센터를 나타내는 도면이다. 도 22를 참조하면, 데이터 센터는 다양한 유형들의 데이터를 수집하고 서비스들을 제공하는 시설일 수 있 고, 데이터 스토리지 센터로 지칭될 수 있다. 데이터 센터는 검색 엔진 및 데이터베이스를 운영하기 위한 시스템일 수 있고, 은행들과 같은 기업들 또는 정부 기관들에 의해 사용되는 컴퓨팅 시스템일 수 있다. 데이터 센터는 애플리케이션 서버들(3100 내지 3100n) 및 스토리지 서버들(3200 내지 3200m)을 포함할 수 있다.애플리케이션 서버들(3100 내지 3100n)의 수 및 스토리지 서버들(3200 내지 3200m)의 수는 실시예들에 따라 다 양하게 선택될 수 있다. 애플리케이션 서버들(3100 내지 3100n)의 수는 스토리지 서버들(3200 내지 3200m)의 수 와 상이할 수 있다. 애플리케이션 서버 또는 스토리지 서버는 프로세서들(3110 및 3210) 및 메모리들(3120 및 3220) 중 적어도 하나를 포함할 수 있다. 이제 스토리지 서버가 예시적으로 설명된다. 프로세서는 스토리지 서버의 모든 동작들을 제어하고, 메모리에 액세스하고, 메모리에 로딩된 명령어들 및/또는 데이터를 실행할 수 있다. 메모리는 DDR SDRAM(double-data-rate synchronous DRAM), HBM(high- bandwidth memory), HMC(hybrid memory cube), DIMM(dual in-line memory module), 옵테인 DIMM, 및/또는 NVMDIMM(non-volatile DIMM)일 수 있다. 일부 실시예들에서, 스토리지 서버에 포함된 프로세서들 및 메모리들의 수는 다양하게 선택될 수 있다. 실시예들에서, 프로세서 및 메모리는 프로세 서-메모리 쌍을 제공할 수 있다. 실시예들에서, 프로세서들의 수는 메모리들의 수와 상이할 수 있 다. 프로세서는 싱글 코어 프로세서 또는 멀티 코어 프로세서를 포함할 수 있다. 스토리지 서버에 대한 상기 설명은 애플리케이션 서버에도 유사하게 적용될 수 있다. 일부 실시예들에서, 애플리케이션 서 버는 스토리지 장치를 포함하지 않을 수 있다. 스토리지 서버는 적어도 하나의 스토리지 장 치를 포함할 수 있다. 스토리지 서버에 포함된 스토리지 장치들의 수는 실시예들에 따라 다 양하게 선택될 수 있다. 애플리케이션 서버들(3100 내지 3100n)은 네트워크를 통해 스토리지 서버들(3200 내지 3200m)과 통신할 수 있다. 네트워크는 파이버 채널(FC) 또는 이더넷을 사용하여 구현될 수 있다. 이 경우, FC는 상대적으 로 고속의 데이터 전송에 사용되는 매체일 수 있고, 고성능 및 고이용성을 갖는 광 스위치를 사용할 수 있다. 스토리지 서버들(3200 내지 3200m)은 네트워크의 액세스 방식에 따라 파일 스토리지들, 블록 스토리지들 또는 객체 스토리지들로서 제공될 수 있다. 실시예들에서, 네트워크는 SAN(storage area network)과 같은 스토리지 전용 네트워크일 수 있다. 예를 들어, SAN은 FC 네트워크를 사용하고, FC 프로토콜(FCP)에 따라 구현되는 FC-SAN일 수 있다. 또 다른 예로서, SAN은 TCP(transmission control protocol)/IP 네트워크를 사용하여, TCP/IP 또는 인터넷 SCSI(iSCSI) 프로토 콜에 따라 구현되는 인터넷 프로토콜(IP)-SAN일 수 있다. 다른 실시예에서, 네트워크는 TCP/IP 네트워크 와 같은 범용 네트워크일 수 있다. 예를 들어, 네트워크는 FCoE(FC over Ethernet), NAS(network attached storage) 및 NVMe-oF(NVMe over Fabrics)와 같은 프로토콜에 따라 구현될 수 있다. 이하에서, 애플리케이션 서버 및 스토리지 서버를 중심으로 설명된다. 애플리케이션 서버에 대한 설명은 다른 애플리케이션 서버(3100n)에 적용될 수 있고, 스토리지 서버에 대한 설명은 다른 스토 리지 서버(3200m)에 적용될 수 있다. 애플리케이션 서버는 사용자 또는 클라이언트에 의해 저장되도록 요청된 데이터를 네트워크를 통해 스토리지 서버들(3200 내지 3200m) 중 하나에 저장할 수 있다. 또한 애플리케이션 서버는 사용자 또는 클 라이언트에 의해 독출되도록 요청된 데이터를 네트워크를 통해 스토리지 서버들(3200 내지 3200m) 중 하 나로부터 획득할 수 있다. 예를 들어, 애플리케이션 서버는 웹 서버 또는 데이터베이스 관리 시스템 (DBMS)으로 구현될 수 있다. 애플리케이션 서버는 네트워크를 통해 다른 애플리케이션 서버(3100n)에 포함된 메모리(3120n) 또 는 스토리지 장치(3150n)에 액세스할 수 있다. 대안적으로, 애플리케이션 서버는 스토리지 서버들(3200 내지 3200m)에 포함되는 메모리들(3220 내지 3220m) 또는 스토리지 장치들(3250 내지 3250m)에 네트워크(330 0)를 통해 액세스할 수 있다. 따라서 애플리케이션 서버는 애플리케이션 서버들(3100 내지 3100n) 및/또 는 스토리지 서버들(3200 내지 3200m)에 저장된 데이터에 대한 다양한 동작들을 수행할 수 있다. 예를 들어, 애 플리케이션 서버는 애플리케이션 서버들(3100 내지 3100n) 및/또는 스토리지 서버들(3200 내지 3200m) 사 이에서 데이터를 이동 또는 복사하기 위한 명령어를 실행할 수 있다 이 경우, 데이터는 스토리지 서버들(3200 내지 3200m)의 스토리지 장치들(3250 내지 3250m)로부터 애플리케이션 서버들(3100 내지 3100n)의 메모리들 (3120 내지 3120n)로 직접 이동하거나 스토리지 서버들(3200 내지 3200m)의 메모리들(3220 내지 3220m)을 통해 이동될 수 있다. 네트워크를 통해 이동되는 데이터는 보안 또는 개인정보보호를 위해 암호화된 데이터일 수 있다. 이제 스토리지 서버가 예시적으로 설명된다. 인터페이스는 프로세서와 컨트롤러 사이 에서 물리적 연결 및 네트워크 인터페이스 카드(NIC) 및 컨트롤러 사이의 물리적 연결을 제공할 수있다. 예를 들어, 인터페이스는 스토리지 장치가 전용 케이블로 직접 연결되는 DAS(direct attached storage)를 사용하여 구현될 수 있다. 예를 들어, 인터페이스는 ATA, SATA, e-SATA, SCSI, SAS, PCI, PCIe, NVMe, IEEE 1394, USB 인터페이스, SD 카드 인터페이스, MMC 인터페이스, eMMC 인터페이스, UFS 인터페이스, eUFS 인터페이스, 및/또는 CF 카드 인터페이스와 같은 다양한 인터페이스 방식들에 의해 구현 될 수 있다. 스토리지 서버는 스위치 및 NIC를 더 포함할 수 있다. 스위치는 프로세서를 스 토리지 장치에 선택적으로 연결하거나, 프로세서의 제어를 통해 NIC를 스토리지 장치 에 선택적으로 연결할 수 있다. 실시예들에서, NIC는 네트워크 인터페이스 카드 및 네트워크 어댑터를 포함할 수 있다. NIC는 유선 인터페이스, 무선 인터페이스, 블루투스 인터페이스 또는 광 인터페이스에 의해 네트워크에 연결될 수 있 다. NIC는 내부 메모리, DSP(digital signal processor) 및 호스트 버스 인터페이스를 포함할 수 있고, 호스트 버스 인터페이스를 통해 프로세서 및/또는 스위치에 연결될 수 있다. 호스트 버스 인터페이 스는 상술한 인터페이스의 예들 중 하나로서 구현될 수 있다. 실시예들에서, NIC는 프로세서 , 스위치 및 스토리지 장치(#250) 중 적어도 하나와 집적될 수 있다. 스토리지 서버들(3200 내지 3200m) 또는 애플리케이션 서버들(3100 내지 3100n)에서, 프로세서는 스토리지 장치 들(3150 내지 3150n, 및 3250 내지 3250m) 또는 메모리들(3120 내지 3120n, 및 3220 내지 3220m)로 명령을 전 달하고, 데이터를 프로그램하거나 독출할 수 있다. 이 경우, 데이터는 ECC 엔진에 의해 오류가 정정된 데이터일 수 있다. 데이터는 DBI(data bus inversion) 동작 또는 DM(data masking) 동작이 수행되는 데이터일 수 있고, CRC(cyclic redundancy code) 정보를 포함할 수 있다. 데이터는 보안 또는 개인정보보호를 위해 암호화된 데이 터일 수 있다. 스토리지 장치들(3150 내지 3150n, 및 3250 내지 3250m)은 프로세서로부터 수신된 독출 명령에 응답하여 제어 신호 및 명령/주소 신호를 NAND 플래시 메모리 장치들(3252 내지 3252m)로 전송할 수 있다. 따라서 NAND 플래시 메모리 장치들(3252 내지 3252n)로부터 데이터를 독출하는 경우, 독출 인에이블(RE) 신호가 데이터 출력 제어 신호로서 입력될 수 있고, 따라서 데이터가 DQ 버스로 출력될 수 있다. 데이터 스트로브 신호(DQS)는 RE 신호를 사용하여 생성될 수 있다. 명령 및 주소 신호는 기입 인에이블(WE) 신호의 상승 에지 또는 하강 에지에 따라 페 이지 버퍼에서 래치될 수 있다. 컨트롤러는 스토리지 장치의 모든 동작들을 제어할 수 있다. 실시예들에서, 컨트롤러는 SRAM 을 포함할 수 있다. 컨트롤러는 기입 명령에 응답하여 NAND 플래시 메모리 장치에 데이터를 기입하 거나 독출 명령에 응답하여 NAND 플래시 메모리 장치로부터 데이터를 독출할 수 있다. 예를 들어, 기입 명령 및/또는 독출 명령은 스토리지 서버의 프로세서, 다른 스토리지 서버(3200m)의 프로세서 (3210m) 또는 애플리케이션 서버들(3100 및 3100n)의 프로세서들(3110 및 3110n)로부터 제공될 수 있다. DRAM은 NAND 플래시 메모리 장치에 기입될 데이터 또는 NAND 플래시 메모리 장치로부터 독출 될 데이터를 일시적으로 저장(또는 버퍼링)할 수 있다. 또한 DRAM은 메타데이터를 저장할 수 있다. 여기 서, 메타데이터는 사용자 데이터 또는 NAND 플래시 메모리 장치를 관리하기 위해 컨트롤러에 의해 생성된 데이터일 수 있다. 스토리지 장치는 보안 또는 개인정보보호를 위한 보안 요소(SE)를 포함할 수 있다. 당해 기술 분야에서 통상적으로 실시예들은, 기능 블록들, 유닛들 및/또는 모듈들의 관점에서, 설명되고 도면 들에 도시된다. 통상의 기술자들은 이러한 블록들, 유닛들 및/또는 모듈들이 반도체 기반 제조 기술들 또는 다 른 제조 기술들을 사용하여 형성될 수 있는 논리 회로들, 개별 부품들, 마이크로프로세서들, 하드-와이어 회로 들, 메모리 소자들, 배선 연결들 등과 같은 전자(또는 광학) 회로들에 의해 물리적으로 구현됨을 이해할 것이다. 마이크로프로세서들 또는 이와 유사한 것에 의해 구현되는 블록들, 유닛들 및/또는 모듈들의 경우, 여 기에서 설명된 다양한 기능들을 수행하기 위해 소프트웨어(예를 들어, 마이크로코드)를 사용하여 프로그램될 수 있고, 선택적으로 펌웨어 및/또는 소프트웨어에 의해 구동될 수 있다. 대안적으로, 각 블록, 유닛 및/또는 모듈 은 전용 하드웨어 또는 일부 기능들을 수행하기 위한 전용 하드웨어 및 프로세서(예를 들어, 하나 이상의 프로 그래밍된 마이크로프로세서들 및 관련 회로)의 조합으로 구현되어 다른 기능들을 수행할 수 있다. 또한 실시예 들의 각 블록, 유닛 및/또는 모듈은 본 개시의 범위를 벗어나지 않으면서 둘 이상의 상호작용하고 개별적인 블 록들, 유닛들 및/또는 모듈들로 물리적으로 분리될 수 있다. 나아가 실시예들의 블록들, 유닛들 및/또는 모듈들 은 본 개시의 범위를 벗어나지 않으면서 보다 복잡한 블록들, 유닛들 및/또는 모듈들로 물리적으로 결합될 수있다. 상술한 방법들의 다양한 동작들은 다양한 하드웨어 및/또는 소프트웨어 구성요소(들), 회로들 및/또는 모듈 (들)과 같은, 동작들을 수행할 수 있는 임의의 적절한 수단에 의해 수행될 수 있다. 소프트웨어는 논리 기능들을 구현하기 위해 실행가능한 명령어들의 정렬된 리스트를 포함할 수 있고, 싱글 또는 멀티-코어 프로세서 또는 프로세서를 포함하는 시스템과 같은 명령어 실행 시스템 또는 장치에 의해 또는 이와 관련하여 사용하기 위한 임의의 “프로세서 판독가능 매체”에 구체화될 수 있다. 여기에 개시된 실시예들과 관련하여 설명된 방법 또는 알고리즘의 블록들 또는 단계들 및 기능들은 하드웨어, 프로세서에 의해 실행되는 소프트웨어 모듈 또는 이 둘의 조합으로 직접 구현될 수 있다. 소프트웨어로 구현되 는 경우, 기능들은 유형적이고 비일시적인 컴퓨터 판독가능 매체에 하나 이상의 명령어들 또는 코드로서 저장되 거나 전송될 수 있다. 소프트웨어 모듈은 RAM(Random Access Memory), 플래시 메모리, ROM(Read Only Memory), EPROM(Electrically Programmable ROM), EEPROM(Electrically Erasable Programmable ROM), 레지스터들, 하드"}
{"patent_id": "10-2024-0000282", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 89, "content": "디스크, 이동식 디스크, CD ROM, 또는 당해 기술분야에 알려진 임의의 다른 형태의 스토리지 매체에 존재할 수 있다. 상술한 내용은 예시적인 실시예들을 설명하기 위한 것이며, 이를 제한하는 것으로 해석되어서는 안 된다. 비록 몇 가지 예시적인 실시예들이 설명되었으나, 통상의 기술자들은 본 개시의 범위를 실질적으로 벗어나지 않고도 실시예들에서 많은 수정들이 가능하다는 것을 쉽게 이해할 것이다. 도면 도면1 도면2a 도면2b 도면2c 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11 도면12a 도면12b 도면12c 도면13 도면14 도면15 도면16 도면17a 도면17b 도면18a 도면18b 도면19a 도면19b 도면20a 도면20b 도면20c 도면21 도면22"}
{"patent_id": "10-2024-0000282", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시의 특정 실시예들의 상기 및 다른 양상들, 특징들 및 장점들은 첨부된 도면들과 함께 받아들여지는 다음 의 설명으로부터 더욱 명백해질 것이다. 도 1은 실시예들에 따른, 컴퓨터 시스템의 블록도이다. 도 2a는 실시예들에 따른, 호스트 스토리지 시스템의 블록도이다. 도 2b는 실시예들에 따른, ECC 엔진의 블록도이다. 도 2c는 실시예들에 따른, ECC 인코딩 회로의 블록도이다. 도 3은 실시예들에 따른, 메모리 시스템의 블록도이다. 도 4는 실시예들에 따른, 메모리 장치의 블록도이다. 도 5는 실시예들에 따른, UFS 시스템의 블록도이다. 도 6은 실시예들에 따른, 메모리 시스템의 블록도이다. 도 7은 실시예들에 따른 UFS 장치에 적용가능한 3D V-NAND 구조를 나타내는 도면이다. 도 8은 실시예들에 따른, H-GCC 코드워드의 코드 구조를 예시적으로 도시한 도면이다. 도 9는 실시예들에 따른, NAND 메모리 블록의 일 예를 나타내는 도면이다. 도 10은 실시예들에 따른, GCC S-폴라 코드의 코드 구조를 예시적으로 도시한 도면이다. 도 11은 실시예들에 따른, GCC S-RS 코드의 코드 구조를 예시적으로 도시한 도면이다. 도 12a는 실시예들에 따른, GCC 인코딩을 수행하기 위해 사용될 수 있는 순차적 인코딩 알고리즘(sequential encoding algorithm)을 예시적으로 도시한 도면이다. 도 12b는 실시예들에 따른, 인코딩 순서를 예시적으로 도시한 도면이다. 도 12c는 실시예들에 따른, 인코딩 프로세스를 나타내는 순서도이다. 도 13은 H-GCC 코드의 코드 구조를 예시적으로 도시한 도면이다. 도 14는 실시예들에 따른, 내부 변환 공간(inner transform space) 및 외부 변환 공간(outer transform spac e)을 예시적으로 도시한 도면이다. 도 15는 실시예들에 따른, H-GCC 코드에 대한 코드 구조를 예시적으로 도시한 도면이다. 도 16은 실시예들에 따른, 도 15의 H-GCC 코드 구조에 대응하는 RX 코드들을 예시적으로 도시한 도면이다. 도 17a는 실시예들에 따른, 전이 행렬(transition matrix)을 구성하기 위한 프로세스를 예시적으로 도시한 도면 이다. 도 17b는 실시예들에 따른, 도 17a에 대응하는 전이 행렬을 구성하기 위한 프로세스를 나타내는 순서도이다. 도 18a는 실시예들에 따른, 출력 코드워드를 생성하기 위해 정보 비트들을 인코딩하기 위한 인코더를 나타내는 블록도이다. 도 18b는 실시예들에 따른, 도 18a의 인코더를 사용하여 출력 코드를 생성하기 위한 프로세스를 나타내는 순서 도이다. 도 19a는 실시예들에 따른, H-GCC 코드워드에 대한 오버헤드 할당(overhead allocation)을 예시적으로 도시한 도면이다. 도 19b는 실시예들에 따른, S-RS 코드워드들에 대해 수행될 수 있는 행 퍼뮤테이션(row permutation)을 예시적 으로 나타내는 도면이다. 도 20a는 실시예들에 따른, H-GCC 인코딩을 수행하기 위해 사용될 수 있는 순차적 인코딩 알고리즘을 예시적으 로 도시한 도면이다. 도 20b는 실시예들에 따른, 인코딩 순서를 예시적으로 도시한 도면이다. 도 20c는 인코딩 프로세스를 나타내는 순서도이다. 도 21은 실시예들에 따른, 스토리지 시스템을 제어하기 위한 프로세스를 나타내는 순서도이다. 도 22는 실시예들에 따른, 데이터 센터를 나타내는 블록도이다."}
