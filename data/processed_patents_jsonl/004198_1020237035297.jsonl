{"patent_id": "10-2023-7035297", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2023-0158656", "출원번호": "10-2023-7035297", "발명의 명칭": "타겟 애플리케이션 프로그램 인터페이스를 탐색하기 위한 방법 및 시스템", "출원인": "삼성전자주식회사", "발명자": "탕구두, 나렌드라나스 두르가"}}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "CCF(Common API Framework Core Function)에 의해 수행되는 사용자 단말(UE)을 서빙하는 API(ApplicationProgram InterfaceI)를 탐색하기 위한 방법으로서,하나 이상의 UE(201)를 서빙하는 하나 이상의 서비스 API들을 결정하기 위한 서비스 API 탐색 요청 메시지(service API discover request message)를 API 호출기(816)로부터 수신하는 단계 - 상기 서비스 API 탐색 요청 메시지는 탐색될 상기 하나 이상의 서비스 API들과 연관된 하나 이상의 UE ID들 및 복수의 파라미터들을 포함함 -;상기 하나 이상의 UE ID들 및 상기 복수의 파라미터들과 연관된 제 1 서비스 API 정보를 메모리에서 검색하는단계; 및상기 서비스 API 탐색 요청 메시지에 기초하여 상기 제 1 서비스 API 정보를 포함하는 서비스 API 탐색 응답을상기 API 호출기(816)에게 송신하는 단계 - 상기 하나 이상의 UE(201)를 서빙하는 상기 하나 이상의 서비스 API들은 상기 제 1 서비스 API 정보에 기초하여 탐색됨 -를 포함하는, 방법."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제 1 항에 있어서, 상기 서비스 API 탐색 요청 메시지는 CAPIF_Discover_Service_API API를 사용하여 상기 API 호출기(816)에 의해 송신되는, 방법."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제 1 항에 있어서,APF(API Publishing Function)로부터 서비스 API 퍼블리시 요청 메시지(service API publish request message)를 수신하는 단계 - 상기 서비스 API 퍼블리시 요청 메시지는 상기 하나 이상의 UE(201)와 연관된 상기 하나이상의 UE ID들, 및 상기 하나 이상의 UE(201)를 지원하는 하나 이상의 API들과 연관된 상기 제 1 서비스 API정보를 포함함 -;하나 이상의 서비스 API들과 연관된 상기 제 1 서비스 API 정보 및 상기 하나 이상의 UE ID들을 상기 메모리에저장하는 단계; 및상기 제 1 서비스 API 정보 및 상기 하나 이상의 UE ID들이 상기 CCF(814)에 저장되어 있음을 나타내는 서비스API 퍼블리시 응답을 상기 APF(API publishing function)로 송신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제 3 항에 있어서, 상기 제 1 서비스 API 정보는 서비스 API 명칭, 서비스 API 타입, 통신 타입, 설명, 서빙 영역 정보, AEF(APIExposing Function) 위치, UE ID들의 목록, 인터페이스 세부 사항들, 프로토콜들, 버전 번호들 및 데이터 포맷중 적어도 하나를 포함하는, 방법."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제 3 항에 있어서, 상기 서비스 API 퍼블리시 요청 메시지는 CAPIF_Publish_Service_API API를 사용하여 상기 APF에 의해 송신되공개특허 10-2023-0158656-3-는, 방법."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제 3 항에 있어서,상기 제 1 서비스 API 정보, 및 상기 하나 이상의 제 1 UE(201)와 연관된 상기 하나 이상의 제 1 UE ID들을 상기 APF로부터 수신하는 단계;하나 이상의 제 2 UE 및 상기 하나 이상의 제 2 UE ID들과 연관된 제 2 서비스 API 정보를 제 2 CCF로부터 수신하는 단계 - 상기 제 2 CCF는 상호 연결 API 퍼블리시를 통해 상기 제 2 서비스 API 정보 및 상기 하나 이상의제2 UE ID들을 송신함 -; 및상호 연결 API 퍼블리시 요청을 제 3 CCF로 송신하는 단계 - 상기 상호 연결 API 퍼블리시 요청은 상기 제 1 서비스 API 정보, 상기 하나 이상의 제 1 UE ID들 및 상기 제 2 서비스 API 정보, 및 상기 하나 이상의 제 2 UEID들 중 적어도 하나를 포함함 -;상기 수신된 상기 제 1 서비스 API 정보, 상기 하나 이상의 제 1 UE ID들 및 상기 제 2 서비스 API 정보, 및 상기 하나 이상의 제 2 UE ID들 중 적어도 하나가 상기 제 3 CCF에 저장되어 있음을 나타내는 상호 연결 API 퍼블리시 응답을 상기 제 3 CCF로부터 수신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제 6 항에 있어서,상기 하나 이상의 UE(201)를 서빙하는 상기 하나 이상의 서비스 API들을 결정하기 위한 상기 하나 이상의 UE ID들을 포함하는 상기 서비스 API 탐색 요청을 상기 API 호출기(816)로부터 수신하는 단계; 및상기 제 1 CCF에 저장된 상기 하나 이상의 제 1 UE ID들과 연관된 상기 제 1 서비스 API 정보 및 상기 제 3 CCF에 저장된 상기 하나 이상의 제 2 UE ID들과 연관된 상기 제 2 서비스 API 정보를 포함하는 상기 서비스 API 탐색 응답을 상기 API 호출기(816)에게 송신하는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제 7 항에 있어서,상기 상호 연결 서비스 API 탐색을 사용하여 상기 제 3 CCF로부터, 상기 제 2 서비스 API 정보 및 상기 하나 이상의 제 2 UE ID들을 페치하는(fetching) 단계 - 상기 제 3 CCF는 상기 하나 이상의 UE ID들에 기초하여 상기제 2 서비스 API 정보를 식별함 -를 더 포함하는, 방법."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제 1 항에 있어서, 상기 제 1 서비스 API 정보를 검색하는 단계는,상기 하나 이상의 UE ID들을 서빙하는 NF 인스턴스 정보를 페치하기 위한 Nnrf_NFDiscovery_Service 요청 메시지를 NRF(Network Repository Function)로 송신하는 단계;상기 하나 이상의 UE ID들을 서빙하는 상기 NF 인스턴스 정보를 포함하는 Nnrf_NFDiscovery_Service 응답 메시지를 상기 NRF로부터 수신하는 단계 - 상기 NRF는 상기 NF(Network Function) 인스턴스 정보를 검색함 -; 및상기 NF 인스턴스 정보 및 상기 제 1 서비스 API 정보 내의 상기 하나 이상의 UE ID들에 기초하여 상기 제 1 서비스 API 정보를 업데이트하는 단계를 포함하는, 방법.공개특허 10-2023-0158656-4-청구항 10 제 1 항에 있어서, 상기 CCF의 외부 인터페이스에 대한 URI(Uniform Resource Identifier)가 상기 API 호출기(816)에 의해 할당되고, 상기 외부 인터페이스가 상기 서비스 API 탐색 요청 메시지를 전송하기 이전에 상기 CCF(814)와 인터랙션을개시하기 위해 상기 API 호출기(816)에 의해 탐색되며; 그리고상기 CCF에 대한 상기 외부 인터페이스는 DNS SRV RR(domain name system service location resource record)및 NAPTR RR(naming authority pointer resource record) 중 하나 이상을 통해 상기 API 호출기에 의해 리졸브되는(resolved), 방법."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "사용자 단말(UE)을 서빙하는 API(Application Program InterfaceI)를 탐색하기 위한 CCF(Common API FrameworkCore Function)로서, 트랜시버(910); 및상기 트랜시버에 커플링되는 적어도 하나의 프로세서(920)를 포함하며,상기 적어도 하나의 프로세서는,하나 이상의 UE(201)를 서빙하는 하나 이상의 서비스 API들을 결정하기 위한 서비스 API 탐색 요청 메시지를API 호출기(816)로부터 수신하고 - 상기 서비스 API 탐색 요청 메시지는 탐색될 상기 하나 이상의 서비스 API들과 연관된 하나 이상의 UE ID들 및 복수의 파라미터들을 포함함 -;상기 하나 이상의 UE ID들 및 상기 복수의 파라미터들과 연관된 제 1 서비스 API 정보를 메모리에서 검색하며;그리고상기 서비스 API 탐색 요청 메시지에 기초하여 상기 제 1 서비스 API 정보를 포함하는 서비스 API 탐색 응답을상기 API 호출기(816)에게 송신하도록 구성되는 - 상기 하나 이상의 UE(201)를 서빙하는 상기 하나 이상의 서비스 API들은 상기 제 1 서비스 API 정보에 기초하여 탐색됨 - CCF."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제 11 항에 있어서, 상기 서비스 API 탐색 요청 메시지는 CAPIF_Discover_Service_API API를 사용하여 상기 API 호출기에 의해 송신되는, CCF."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제 11 항에 있어서, 상기 적어도 하나의 프로세서는,APF(API Publishing Function)로부터 서비스 API 퍼블리시 요청 메시지를 수신하고 - 상기 서비스 API 퍼블리시 요청 메시지는 상기 하나 이상의 UE와 연관된 상기 하나 이상의 UE ID들, 및 상기 하나 이상의 UE를 지원하는 하나 이상의 API들과 연관된 상기 제 1 서비스 API 정보를 포함함 -;하나 이상의 서비스 API들과 연관된 상기 제 1 서비스 API 정보 및 상기 하나 이상의 UE ID들을 상기 메모리에저장하며; 그리고상기 제 1 서비스 API 정보 및 상기 하나 이상의 UE ID들이 상기 CCF에 저장되어 있음을 나타내는 서비스 API퍼블리시 응답을 상기 APF(API publishing function)로 송신하도록 더 구성되는, CCF."}
{"patent_id": "10-2023-7035297", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제 13 항에 있어서, 상기 제 1 서비스 API 정보는 복수의 API 파라미터들을 포함하는, CCF.공개특허 10-2023-0158656-5-청구항 15 제 11 항에 있어서, 상기 적어도 하나의 프로세서는 제 5 항 내지 제 10 항에 따른 방법들을 동작시키도록 더 구성되는, CCF."}
{"patent_id": "10-2023-7035297", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "본 개시는 보다 높은 데이터 전송률을 지원하기 위한 5G 또는 6G 통신 시스템에 관련된 것이다. 일 실시예에서, UE를 서빙하는 API를 탐색하기 위해, CCF에 의해 수행되는 방법이 개시된다. 이 방법은 하나 이 상의 UE를 서빙하는 하나 이상의 서비스 API들을 결정하기 위한 서비스 API 탐색 요청 메시지를 API 호출기로부 터 수신하는 단계를 포함한다. 서비스 API 탐색 요청 메시지는 하나 이상의 UE와 연관된 하나 이상의 UE ID들 및 복수의 파라미터들을 포함한다. 이 방법은 메모리로부터 하나 이상의 UE ID들 및 복수의 파라미터들과 연관 된 제 1 서비스 API 정보를 검색하는 단계, 서비스 API 탐색 요청 메시지에 기초하여 제 1 서비스 API 정보를 포 함하는 서비스 API 탐색 응답을 API 호출기에게 송신하는 단계를 포함한다."}
{"patent_id": "10-2023-7035297", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 일반적으로 무선 통신에 관한 것이며, 특히 사용자 단말(UE)에 대한 타겟 애플리케이션 프로그래밍 인터페이스(Application Programming Interface, API)를 탐색하기 위한 시스템 및 방법에 관한 것이다."}
{"patent_id": "10-2023-7035297", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "5G 이동통신 기술은 빠른 전송 속도와 새로운 서비스가 가능하도록, 넓은 주파수 대역을 정의하고 있으며, 3.5 기가헤르츠(3.5GHz) 등 6GHz 이하 주파수('Sub 6GHz') 대역은 물론 28GHz와 39GHz 등 밀리미터파(㎜Wave)로 불 리는 초고주파 대역('Above 6GHz')에서도 구현이 가능하다. 또한, 5G 통신 이후(Beyond 5G)의 시스템이라 불리 어지는 6G 이동통신 기술의 경우, 5G 이동통신 기술 대비 50배 빨라진 전송 속도와, 10분의 1로 줄어든 초저 (Ultra Low) 지연시간을 달성하기 위해 테라헤르츠(Terahertz) 대역(예를 들어, 95GHz에서 3 테라헤르츠(3THz) 대역과 같은)에서의 구현이 고려되고 있다. 5G 이동통신 기술의 초기에는, 초광대역 서비스(enhanced Mobile BroadBand, eMBB), 고신뢰/초저지연 통신 (Ultra Reliable & Low Latency Communications, URLLC), 대규모 기계식 통신 (massive Machine-Type Communications, mMTC)에 대한 서비스 지원과 성능 요구사항 만족을 목표로, 초고주파 대역에서의 전파의 경로 손실 완화 및 전파의 전달 거리를 증가시키기 위한 빔포밍(Beamforming) 및 거대 배열 다중 입출력(Massive MIMO), 초고주파수 자원의 효율적 활용을 위한 뉴머롤로지(복수 개의 서브캐리어 간격 운용 등)와 슬롯 포맷에 대한 동적 운영, 다중 빔 전송 및 광대역을 지원하기 위한 초기 접속 기술, BWP(Band-Width Part)의 정의 및 운 영, 대용량 데이터 전송을 위한 LDPC(Low Density Parity Check) 부호와 제어 정보의 신뢰성 높은 전송을 위한 폴라 코드(Polar Code)와 같은 새로운 채널 코딩 방법, L2 선-처리(L2 pre-processing), 특정 서비스에 특화된 전용 네트워크를 제공하는 네트워크 슬라이싱(Network Slicing) 등에 대한 표준화가 진행되었다. 현재, 5G 이동통신 기술이 지원하고자 했던 서비스들을 고려하여 초기의 5G 이동통신 기술 개선(improvement) 및 성능 향상(enhancement)을 위한 논의가 진행 중에 있으며, 차량이 전송하는 자신의 위치 및 상태 정보에 기 반하여 자율주행 차량의 주행판단을 돕고 사용자의 편의를 증대하기 위한 V2X, 비면허 대역에서 각종 규제 상 요구사항들에 부합하는 시스템 동작을 목적으로 하는 NR-U(New Radio Unlicensed), NR 단말 저전력 소모 기술 (UE Power Saving), 지상 망과의 통신이 불가능한 지역에서 커버리지 확보를 위한 단말-위성 직접통신인 비 지 상 네트워크(Non Terrestrial Network, NTN), 위치 측위(Positioning) 등의 기술에 대한 물리계층 표준화가 진 행 중이다. 뿐만 아니라, 타 산업과의 연계 및 융합을 통한 새로운 서비스 지원을 위한 지능형 공장 (Industrial Internet of Things, IIoT), 무선 백홀 링크와 액세스 링크를 통합 지원하여 네트워크 서비스 지역 확장을 위한 노드를 제공하는 IAB(Integrated Access and Backhaul), 조건부 핸드오버(Conditional Handover) 및 DAPS(Dual Active Protocol Stack) 핸드오버를 포함하는 이동성 향상 기술(Mobility Enhancement), 랜덤액세스 절차를 간소화하 는 2 단계 랜덤액세스(2-step RACH for NR) 등의 기술에 대한 무선 인터페이스 아키텍쳐/프로토콜 분야의 표준 화 역시 진행 중에 있으며, 네트워크 기능 가상화(Network Functions Virtualization, NFV) 및 소프트웨어 정 의 네트워크, SDN) 기술의 접목을 위한 5G 베이스라인 아키텍쳐(예를 들어, Service based Architecture, Service based Interface), 단말의 위치에 기반하여 서비스를 제공받는 모바일 엣지 컴퓨팅(Mobile Edge Computing, MEC) 등에 대한 시스템 아키텍쳐/서비스 분야의 표준화도 진행 중이다. 이와 같은 5G 이동통신 시스템이 상용화되면, 폭발적인 증가 추세에 있는 커넥티드 기기들이 통신 네트워크에 연결될 것이며, 이에 따라 5G 이동통신 시스템의 기능 및 성능 강화와 커넥티드 기기들의 통합 운용이 필요할 것으로 예상된다. 이를 위해, 증강현실 및 가상현실 등을 효율적으로 지원하기 위한 확장 현실(eXtended Reality(XR) = AR + VR + MR), 인공지능(Artificial Intelligence, AI) 및 머신러닝(Machine Learning, ML) 을 활용한 5G 성능 개선 및 복잡도 감소, AI 서비스 지원, 메타버스 서비스 지원, 드론 통신 등에 대한 새로운연구가 진행될 예정이다. 또한, 이러한 5G 이동통신 시스템의 발전은 6G 이동통신 기술의 테라헤르츠 대역에서의 커버리지 보장을 위한 신규 파형(Waveform), 전차원 다중입출력(Full Dimensional MIMO: FD-MIMO), 어레이 안테나(Array Antenna), 대규모 안테나(Large Scale Antenna)와 같은 다중 안테나 전송 기술, 테라헤르츠 대역 신호의 커버리지를 개선 하기 위해 메타물질(Metamaterial) 기반 렌즈 및 안테나, OAM(Orbital Angular Momentum)을 이용한 고차원 공 간 다중화 기술, RIS(Reconfigurable Intelligent Surface) 기술 뿐만 아니라, 6G 이동통신 기술의 주파수 효 율 향상 및 시스템 네트워크 개선을 위한 전이중화(Full Duplex) 기술, 위성(Satellite), AI (Artificial Intelligence)를 설계 단계에서부터 활용하고 종단간(End-to-End) AI 지원 기능을 내재화하여 시스템 최적화를 실현하는 AI 기반 통신 기술, 단말 연산 능력의 한계를 넘어서는 복잡도의 서비스를 초고성능 통신과 컴퓨팅 자 원을 활용하여 실현하는 차세대 분산 컴퓨팅 기술 등의 개발에 기반이 될 수 있을 것이다. 전통적으로, 3GPP는 노스바운드 API들을 통해 써드 파티 AF(Application Function)들에 의해 소모되도록 하기 위해 네트워크 서비스들을 노출한다. 대부분의 노스바운드 API들은 UE들과 관련되어 있으며 이들의 서비스 경 험에 영향을 미칠 수 있다. NEF(Network Exposure Function) 및 SCEF(Service Capability Exposure Functio n)는 3GPP TS 29.522 및 3GPP TS 29.122에 각각 규정된 바와 같은 노스바운드 API들을 통해 3GPP 네트워크 서 비스들을 노출하는 주요 기능 엔티티들이다. 3GPP는 또한 3GPP 네트워크들을 통해 수직 특정 애플리케이션들을 활성화하기 위한 아키텍처들도 정의한다. 이러한 아키텍처들은 또한 수직 특정 애플리케이션들에 의한 소모를 위해 인에이블러 계층에서, 그들 서비스들을 노스바운드 API들로 정의한다. 예를 들어, 3GPP TS 23.434에 규정 된 바와 같은 수직 분야를 위한 서비스 인에이블러 아키텍처 계층. 3GPP는 모든 노스바운드 API들에 적용 가능 한 공통 어스펙트들을 정의하기 위해, TS 23.222에 공통 API 프레임워크(Common API Framework, CAPIF)를 규정 하였다. CAPIF의 기능들 중 하나는 API 탐색 서비스이며, 이 서비스를 통해 노스바운드 API들을 소모하는 임의 의 AF(Application Function)는 노스바운드 API들을 노출하는 AEF(API Exposing Function)의 세부 사항들을 탐 색할 수 있다. CAPIF에 따르면, AEF는 노스바운드 API들을 노출하는 기능적 엔티티이다(예를 들면, NEF, SCEF 등). AF는 다수의 PLMN들에 속하는 UE들을 서빙할 수 있다. 또한, PLMN 내에는, 기능적 엔티티(예를 들면, NEF)의 여러 인스턴스들이 존재하여, 상이한 UE들의 세트에 대한 노스바운드 API들을 서빙할 수 있다. 이러한 시나리 오에서는, AF(Application Function)가 소모하기를 원하는, 특정 UE들을 서빙하는 타겟 API의 위치(예를 들면, NEF 인스턴스 정보)를 어떻게 결정하는지가 명확하지 않다. TS 23.222에 따르면, 현재 CAPIF_Discover_Service_API API는 UE 또는 UE들의 세트에 기초하여 API들을 탐색하는 것을 지원하지 않는다 또한, AF가 UE들의 PLMN 프로바이더를 인식하지 못하고 특정 UE들의 세트에 대한 타겟 API 위치를 탐색해야 하 는 경우, AF가 어떤 PLMN 및 CAPIF 코어 기능(CAPIF Core Function; CCF)에 컨택트하여 서비스 API들 정보를 탐색해야 하는지 명확하지 않다. 3GPP에 의해 정의된 노스바운드 API들은 다양한 식별자들, 즉 MSISDN, 외부 식별자, GPSI, UE IP 주소 등을 사 용하여 UE를 식별한다. 상술한 단점 및 솔루션들은 이러한 모든 UE 식별 메커니즘들에 적용된다. 상술한 문제는 또한 수직 특정 애플리케이션들에 의한 소모를 위해 3GPP 수직 인에이블러 계층들에 의해 노출되 는 노스바운드 API들에도 적용된다. 3GPP에 의해 규정된 수직 인에이블러 계층들의 몇 가지 예들은, 3GPP TS 23.434에 규정된 수직 분야를 위한 서비스 인에이블러 아키텍처 계층, 3GPP TS 23.486에 규정된 V2X(Vehicle- to-Everything) 서비스들, 3GPP TS 23.558에 규정된 엣지 애플리케이션 활성화를 위한 아키텍처, 3GPP TS 23.255에 규정된 무인 항공 시스템을 위한 애플리케이션 계층 지원 등이다. 이러한 수직 인에이블러 계층 아키 텍처들은 UE 측 상의 기능적 엔티티들을 정의한다. 이러한 UE 측 기능적 아이덴티티들은 VAL USER ID, SEAL의 VAL UE ID, EDGEAPP의 EEC ID(3GPP TS 23.558) 등과 같은 각각의 아키텍처들에서 정의된다. 노스바운드 API들 을 노출하는 수직 인에이블러 계층 기능적 엔티티들이 다수의 PLMN들에 속하는 UE들 또는 다수의 수직 특정 애 플리케이션(AF)들에 속하는 UE 측 기능적 아이덴티티들 또는 다수의 PLMN들에 속하는 UE 측 기능적 아이덴티티 들을 서빙하게 되거나 또는 서비스 프로바이더 내의 다수의 수직 인에이블러 계층 기능적 엔티티들이 서로 다른 UE 측 기능적 엔티티들의 세트들을 서빙할 수 있다. 이러한 시나리오에서는, 수직 특정 애플리케이션(AF)이 특 정 UE 측 기능적 엔티티를 서빙하는 타겟 API의 위치(SEAL 서버, VAE 서버 등과 같은 수직 인에이블러 계층 기 능적 엔티티)를 어떻게 결정하는지가 명확하지 않다. AF가 UE들의 PLMN 프로바이더를 알지 못하여 특정 UE들의 세트에 대한 타겟 API 위치를 탐색해야 하는 경우, AF 가 어떤 PLMN 또는 CAPIF 프로바이더(CAPIF 코어 기능)에 컨택트하여 서비스 API 정보를 탐색해야 하는지가 명확하지 않다. 따라서, 이상의 단점들을 극복하기 위한 솔루션이 필요하다."}
{"patent_id": "10-2023-7035297", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "이 요약은 본 발명의 상세한 설명에서 추가로 설명되는 개념들을 단순화된 형식으로 소개하기 위해 제공된다."}
{"patent_id": "10-2023-7035297", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 2, "content": "이 요약은 본 발명의 핵심 또는 본질적인 발명 개념을 식별하기 위한 것으로 의도되지 않으며, 본 발명의 범위 를 결정하기 위한 것으로도 의도되지 않는다. 본 발명 내용의 일부 예시적인 실시예들 따르면, 사용자 단말(UE)을 서빙하는 API(Application Program InterfaceI)를 탐색하기 위한 방법이 개시된다. 이 방법은 CCF(Common API Framework Core Function)에 의해 서, 하나 이상의 사용자 단말(UE)을 서빙하는 하나 이상의 서비스 API들을 결정하기 위한 서비스 API 탐색 요청 메시지를 API 호출기로부터 수신하는 단계를 포함한다. 서비스 API 탐색 요청 메시지는 탐색될 하나 이상의 서 비스 API들과 연관된 하나 이상의 UE ID들 및 복수의 파라미터들을 포함한다. 이 방법은 CCF에 의해서, 하나 이상의 UE ID들 및 복수의 파라미터들과 연관된 제 1 서비스 API 정보를 메모리로부터 검색하는 단계를 포함한 다. 이 방법은 CCF에 의해서, 서비스 API 탐색 요청 메시지에 기초하여 제 1 서비스 API 정보를 포함하는 서비 스 API 탐색 응답을 API 호출기에게 송신하는 단계를 더 포함한다. 하나 이상의 UE들을 서빙하는 하나 이상의 서비스 API들은 제 1 서비스 API 정보에 기초하여 탐색된다. 본 발명 내용의 일부 예시적인 실시예들에 따르면, 사용자 단말(UE)을 서빙하는 API(Application Program InterfaceI)를 탐색하기 위한 시스템이 개시된다. 이 시스템은 CCF(Common API Framework Core Function)에 의해서, 하나 이상의 사용자 단말(UE)을 서빙하는 하나 이상의 서비스 API들을 결정하기 위한 서비스 API 탐색 요청 메시지를 API 호출기로부터 수신하는 것을 포함한다. 서비스 API 탐색 요청 메시지는 탐색될 하나 이상의 서비스 API들과 연관된 하나 이상의 UE ID들 및 복수의 파라미터들을 포함한다. 이 시스템은 CCF에 의해서, 하 나 이상의 UE ID들 및 복수의 파라미터들과 연관된 제 1 서비스 API 정보를 메모리로부터 검색하는 것을 포함한 다. 이 시스템은 CCF에 의해서, 서비스 API 탐색 요청 메시지에 기초하여 제 1 서비스 API 정보를 포함하는 서 비스 API 탐색 응답을 API 호출기에게 송신하는 것을 더 포함한다. 하나 이상의 UE들을 서빙하는 하나 이상의 서비스 API들은 제 1 서비스 API 정보에 기초하여 탐색된다. 본 발명의 이점들 및 특징들을 더욱 명확하게 하기 위해, 본 발명의 보다 구체적인 설명은 첨부된 도면들에 예 시되는 특정 실시예들을 참조하여 제공될 것이다. 이들 도면들은 본 발명의 전형적인 실시예들만을 나타내며, 따라서 본 발명의 범위를 제한하는 것으로 간주되어서는 안 된다는 점을 이해해야 한다. 본 발명은 첨부된 도 면들을 통해 추가적인 구체적이고 상세하게 기술되고 설명될 것이다."}
{"patent_id": "10-2023-7035297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "본 발명의 원리에 대한 이해를 돕기 위해, 이제 도면들에 예시된 실시예를 참조할 것이며 이를 설명하기 위해 특정 언어가 사용될 것이다. 그럼에도 불구하고, 이에 의해 본 발명의 범위가 제한되는 것은 아니며, 예시된 시스템에서의 이러한 변경들 및 추가 수정들, 그리고 본 명세서에 예시된 본 발명 원리들의 추가 적용이 본 발 명과 관련된 기술 분야의 당업자에게 일반적으로 이루어지는 것으로 고려된다는 것이 이해될 것이다. 당업자는 전술한 일반적인 설명 및 다음의 상세한 설명이 본 발명을 설명하기 위한 것이며 이를 제한하려는 의 도가 아니라는 것을 이해할 것이다. 본 명세서 전반에 걸쳐 \"일 양태\", \"다른 양태\" 또는 유사한 언어에 대한 언급은 실시예와 관련하여 설명된 특 정한 특징, 구조 또는 특성이 본 발명의 적어도 하나의 실시예에 포함된다는 것을 의미한다. 따라서, 본 명세 서 전반에 걸쳐 \"일 실시예에서\", \"다른 실시예에서\"라는 문구 및 유사한 언어의 표현 모두는 동일한 실시예를 지칭할 수도 있으며, 반드시 그러한 것은 아니다. 용어 \"포함한다(comprise)\", \"포함하는(comprising)\" 또는 이의 임의의 다른 변형은 비배타적 포함(non- exclusive inclusion)을 커버하기 위한 것으로, 단계 목록을 포함하는 프로세스 또는 방법은 이러한 단계만을 포함하지 않고 명시적으로 나열되지 않았거나 이러한 프로세스 또는 방법에 고유하지 않은 다른 단계를 포함할 수 있다. 유사하게, \"comprises...a\"로 진행되는 하나 이상의 장치 또는 하위 시스템 또는 요소 또는 구조 또 는 구성 요소는 더 많은 제약 없이 다른 장치 또는 다른 하위 시스템 또는 다른 요소 또는 다른 구조 또는 다른 구성 요소 또는 부가적인 장치 또는 부가적인 하위 시스템 또는 부가적인 요소 또는 부가적인 구조 또는 부가적 인 구성 요소의 존재를 배제하지 않는다. 달리 정의되지 않는 한, 본 명세서에 사용된 모든 기술 및 과학 용어는 본 발명이 속하는 기술 분야의 통상의 기술자가 일반적으로 이해하는 것과 동일한 의미를 갖는다. 본 명세서에 제공되는 시스템, 방법들 및 예들은 예시일 뿐이며 제한하려는 의도가 아니다. 도 1은 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API들을 탐색하기 위 한 방법을 나타내는 동작 흐름도를 도시한 것이다. UE의 예들로는 스마트폰, 랩탑, PC(Personal Computer), 태블릿을 포함할 수 있으며, 이에 제한되지 않는다. 일 실시예에서, UE는 LTE(Long Term Evolution) 및 NR(New Radio)에서 동작하도록 구성될 수 있다. 일 실시예에서, 하나 이상의 서비스 API들은 하 나 이상의 노스바운드 API들로 상호 교환적으로 지칭될 수 있다. 일 실시예에서, 방법은 하나 이상의 UE를 서 빙하는 하나 이상의 서비스 API들의 위치를 결정하는 단계를 포함할 수 있다. 블록에서, 방법은 공통 API 프레임워크 코어 기능(CCF)에 의해서, 하나 이상의 사용자 단말(UE)을 서빙하 는 하나 이상의 서비스 API들을 탐색하기 위해 API 호출기로부터 서비스 API 탐색 요청 메시지를 수신하는 단계를 포함할 수 있으며, 여기서 서비스 API 탐색 요청 메시지는 탐색될 하나 이상의 서비스 API들과 연관된 하나 이상의 UE ID들 및 복수의 파라미터들을 포함한다. 블록에서, 방법은 CCF에 의해서, 하나 이상의 UE ID들 및 복수의 파라미터들과 연관된 제 1 서비스 API 정 보를 메모리로부터 검색하는 단계를 포함할 수 있다. 블록에서, 방법은 CCF에 의해서, 서비스 API 탐색 요청 메시지에 기초하여 제 1 서비스 API 정보를 포함하 는 서비스 API 탐색 응답을 API 호출기에게 송신하는 단계를 포함할 수 있으며, 여기서 하나 이상의 UE들을 서 빙하는 하나 이상의 서비스 API들은 제 1 서비스 API 정보에 기초하여 탐색된다. 도 2는 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE에 대한 하나 이상의 API들을 퍼블리시하고 탐색 하기 위한 방법을 나타내는 동작 흐름도를 도시한 것이다. 일 실시예에서, 하나 이상의 API들은 하나 이 상의 노스바운드 API들로 상호 교환적으로 지칭될 수 있다. 일 실시예에서, 본 발명 내용은 하나 이상의 노스 바운드 API들에 의해 지원되는 하나 이상의 UE와 함께 하나 이상의 노스바운드 API들을 퍼블리시하기 위한 API 퍼블리시 기능에 대한 메커니즘을 포함한다. 일 실시예에서, 하나 이상의 노스바운드 API들은 퍼블리시 서비스 API 절차를 사용하여 퍼블리시될 수 있다. 일 실시예에서, API 호출기라고도 지칭되는 AF(Application Function)은, 서비스 API 탐색 절차를 사용하여 하나 이상의 UE를 위해 서빙되는 하나 이상의 노스바운드 API들 과 관련된 세부 사항들을 탐색하도록 구성될 수 있다. 도 3은 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE를 서빙하는 하나 이상의 API들을 탐색하기 위한 프로세스를 나타내는 동작 흐름도를 도시한 것이다. 일 실시예에서, API 호출기는 도 2에서 언급된 바와 같은 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API들의 탐색을 개시하도록 구성될 수 있다. 일 실 시예에서, 하나 이상의 API들은 하나 이상의 UE를 서빙하는 하나 이상의 API들을 식별하는 제 1 서비스 정 보에 기초하여 탐색될 수 있다. 일 실시예에서, 하나 이상의 UE를 서빙하는 하나 이상의 API들과 관련된 제 1 서비스 API 정보는 APF(API Publishing Function)로부터의 제 1 서비스 API 정보 수신 시에 CCF에 저장될 수 있다. 위의 실시예에 대해 계속 설명하면, 프로세스는 도 1의 블록에서 언급된 바와 같은 API 호출기로부터 CCF 에서 서비스 API 탐색 요청을 수신하는 단계(단계 302)를 포함할 수 있다. 일 실시예에서, 서비스 API 탐색 요 청은 API 호출기와 관련된 하나 이상의 UE를 서빙하는 하나 이상의 API들을 탐색하기 위해 API 호출기에 의해 송신될 수 있다. 일 실시예에서, 서비스 API 탐색 요청은 CAPIF_Discover_Service_API API 등에 대해 3GPP TS 23.222에 규정된 바와 같은 탐색될 하나 이상의 서비스 API들과 연관된 하나 이상의 UE ID들 및 다수의 파라미터들을 포함할 수 있다. 일 실시예에서, 서비스 API 탐색 요청은 CAPIF_Discover_Service_API API를 사 용하여 API 호출기로부터 수신될 수 있다. CCF에 의한 서비스 API 탐색 요청을 수신한 후에, 프로세스는 도 1의 블록에서 언급된 바와 같은 CCF에서 제 1 서비스 API 정보를 검색하는 것으로 진행할 수 있다(단계 304). 일 실시예에서, 제 1 서비스 정보는 CCF 의 메모리로부터 검색될 수 있다. 일 실시예에서, 메모리는 제 1 서비스 API 정보를 포함하는 API 레지스트리 를 저장할 수 있다. 일 실시예에서, 제 1 서비스 API 정보는 수신 서비스 API 탐색 요청에 존재하는 하나 이상 의 UE ID들 및 다수의 파라미터들과 관련된 하나 이상의 UE과 관련될 수 있다. 일 실시예에서, API 레지 스트리는 하나 이상의 UE의 하나 이상의 UE ID들에 대응되는 하나 이상의 UE와 관련된 제 1 서비스 API 정보를 저장할 수 있다. 일 실시예에서, 검색은 서비스 API 탐색 요청에 있는 하나 이상의 UE ID들이, API 레지스트리에 이전에 저장된 서비스 API 정보에 대응하는 적어도 하나의 UE ID와 매칭되는 것에 기초할 수 있다. 일 실시예에서, 서비스 API 정보는 적어도 하나의 UE ID가 하나 이상의 UE ID들과 매칭되도록 하는 상기 적어도 하나의 UE ID에 대응하는 제 1 서비스 API 정보를 포함할 수 있다. 이러한 이해에 따라, 프로세스는 제 1 서비스 API 정보를 검색한 것에 응답하여, 도 1의 블록에서 언급된 바와 같은 API 호출기에게 서비스 API 탐색 응답을 송신하는 것으로 진행할 수 있다(단계 306). 일 실시예에서, 서비스 API 탐색 응답은 서비스 API 탐색 요청에서 수신되는 하나 이상의 UE ID들과 연관된 제 1 서비스 API 정보를 포함할 수 있다. 일 실시예에서, 하나 이상의 UE에 대응하는 하나 이상의 UE ID들과 연관된 제 1 서비스 정보는 하나 이상의 UE를 서빙할 수 있다. 일 실시예에서, 제 1 서비스 API 정보는 서비스 API 탐색 응답에서 표 형태로 송신될 수 있다.[표 1]"}
{"patent_id": "10-2023-7035297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "표 1은 제 1 서비스 API 정보를 예시한 것이다. 일 실시예에서, APF는 UE ID들의 목록과 관련된 UE들의 세트가 서비스 API 퍼블리시 요청 메시지에 있는 하나 이상의 서비스 API들 중의 각 서비스 API에 적용 가능함을 나타내기 위해, CAPIF_Publish_Service_API API 요 청 메시지에 별도의 정보로서 UE ID들의 목록을 포함할 수 있다. 일 실시예에서, APF는 후속적으로 CCF 또는 API 호출기에 의해 하나 이상의 서비스 API들로부터 서비스 API를 선택하는데 사용될 수 있는 퍼블리시된 API에 특별히 '바인딩된(bound)' 세션 ID를 지정하도록 구성될 수 있다. 다음으로, 퍼블리시된 API는 API 호출기가 서비스 API를 통해 의도된 서비스와 관련된 세션 시에 특별히 동작할 수 있도록 서비스 API 사용을 특정 UE 세 션에 바인딩하는데 사용될 수 있다. 일 실시예에서, CAPIF_Discover_Service_API 요청은 UE ID들의 목록이 본 질적으로 CCF에 의해 결정되는 기반이 되는 쿼리 정보 또는 파라미터를 포함할 수 있다. 일 실시예에서, CAPIF_Discover_Service_API 요청이 다수의 CCF들에 의해 서빙되는 UE ID들의 목록을 포함하는 것으로 결정된 경우, CAPIF 상호 연결 인터페이스(CAPIF-6/6e)는 다수의 CCF들로부터 저장된 서비스 API(들) 정 보를 검색하는데 사용될 수 있다. 일 실시예에서, CAPIF_Discover_Service_API 요청이 다수의 API 프로바이더 들에 속하는 AEF들에 의해 서빙되는 UE ID들의 목록을 포함하는 것으로 결정된 경우, CCF는 다수의 API 프로바 이더들에 속하는 저장된 서비스 API(들) 정보를 검색하는데 사용될 수 있다. 일 실시예에서, 수직 특정 애플리케이션들에 의한 소모를 위해 3GPP 수직 인에이블러 계층들에 의해 노스바운드 API들이 노출되고, UE 측 기능 엔티티가 API 호출의 컨텍스트에 있는 경우, UE 측 기능 엔티티 식별자들의 목록 (예를 들어, SEAL을 위한 VAL UE ID, VAL USER ID 및 다른 수직 인에이블러 계층 아키텍처들에서의 이와 유사한 것들)이 UE ID들의 목록 대신에 포함될 수 있다. 서비스 API들이 UE 측 기능 엔티티 식별자들의 목록과 함께 퍼블리시될 수 있으며 API 호출기(수직 특정 애플리케이션)는 UE 측 기능 엔티티 식별자들의 목록에 기초하여 타겟 API 위치를 탐색할 수 있다. 도 4는 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE에 대한 하나 이상의 AEF들을 탐색하기 위한 방 법을 나타내는 동작 흐름도를 도시한 것이다. 일 실시예에서, 하나 이상의 AEF들은 NRF(Network Repository Function)로부터 탐색될 수 있다. 일 실시예에서, 하나 이상의 AEF들은 NEF, SCEF 등을 포함할 수 있다. 일 실시예에서, 본 발명 내용은 CCF가 5G 코어 네트워크(5G core network)에서 NRF로부터 도 2에 언급된 바와 같이, 하나 이상의 UE 중의 적어도 하나의 UE를 서빙하는 하나 이상의 AEF들과 관련된 AEF 정보를 페 치하는 방법을 포함한다. 일 실시예에서, AEF 정보는 Nnrf_NFDiscovery_Service를 사용하여 페치될 수 있다. NRF는 NEF 탐색을 위한 TS 23.501, 및 Nnrf_NFDiscovery_Service API를 위한 TS 29.510에 규정된 바와 같이Nnrf_NFDiscovery_Service를 지원하거나 또는 CCF가 하나 이상의 AEF들을 페치하도록 하기 위해 Nnrf_ServiceRequest 또는 Nnrf_xxx와 같은 새로운 서비스를 노출하도록 구성될 수 있다. 일 실시예에서, AEF 정보는 하나 이상의 UE 중 적어도 하나의 UE를 서빙하는 API 노출 기능 정보로 상호 교환적으로 지칭될 수 있다. 도 5는 본 발명 내용의 일 실시예에 따른, NRF로부터 하나 이상의 UE에 대한 하나 이상의 AEF들을 탐색하 기 위한 프로세스를 나타내는 동작 흐름도를 도시한 것이다. 일 실시예에서, API 호출기는 도 2에서 언급 된 바와 같이, 하나 이상의 UE를 서빙하는 하나 이상의 API들을 식별하는 제 1 서비스 정보에 기초하여 하 나 이상의 UE를 서빙하는 하나 이상의 AEF들의 탐색을 개시하도록 구성될 수 있다. 일 실시예에서, 하나 이상의 API들과 관련된 제 1 서비스 API 정보는 APF(API Publishing Function)로부터의 제 1 서비스 API 정보 수신 시에 CCF에 저장될 수 있다. 위의 실시예에 대해 계속 설명하면, 프로세스는 API 호출기와 관련된 하나 이상의 UE를 서빙하는 하나 이 상의 AEF들을 탐색하기 위해 송신되는 API 호출기로부터의 서비스 API 탐색 요청을 CCF에서 수신하는 단계(단계 502)를 포함할 수 있다. 일 실시예에서, 서비스 API 탐색 요청은 탐색될 서비스 API 정보와 연관된 하나 이상 의 UE ID들 및 다수의 파라미터들을 포함할 수 있다. 일 실시예에서, 서비스 API 탐색 요청은 CAPIF_Discover_Service_API API를 사용하여 수신될 수 있다. CCF에서 서비스 API 탐색 요청을 수신한 것에 응답하여, 프로세스는 서비스 API 탐색 요청에서 수신된 하나 이 상의 UE ID들을 서빙하는 NF 인스턴스 정보를 검색하기 위해 Nnrf_NFDiscovery_Service 요청 메시지를 NRF로 송신하는 것으로 진행할 수 있다(단계 504). 일 실시예에서, NF 인스턴스 정보는 NEF, SCEF를 포함할 수 있다. 일 실시예에서, Nnrf_NFDiscovery_Service 요청 메시지는 서비스 API 탐색 요청에서 수신된 하나 이상의 UE ID 들을 포함할 수 있다. 다음으로, NRF에서 Nnrf_NFDiscovery_Service 요청 메시지 수신 시에, 프로세스는 하나 이상의 UE ID들을 서빙 하는 NF 인스턴스 정보를 검색하는 것으로 진행할 수 있다(단계 506). 일 실시예에서, NF 인스턴스 정보는 NRF 의 메모리로부터 NRF에 의해 검색될 수 있다. 일 실시예에서, NF 인스턴스 정보는 3GPP TS 23.501에 규정된 바 와 같이 NRF에 이전에 저장된 것일 수 있다. NRF에 의해 메모리로부터 NF 인스턴스 정보를 검색한 후, 프로세스는 CCF에서 Nnrf_NFDiscovery_Service 응답 메시지를 수신하는 것으로 진행할 수 있다(단계 508). 일 실시예에서, Nnrf_NFDiscovery_Service 응답 메시지 는 NRF에 의해 CCF로 송신될 수 있으며, Nnrf_NFDiscovery_Service 응답 메시지는 하나 이상의 UE ID들을 서빙 하는 NF 인스턴스 정보를 포함할 수 있다. 일 실시예에서, Nnrf_NFDiscovery_Service 응답 메시지는 또한 NRF 에서 CCF로부터 Nnrf_NFDiscovery_Service 요청 메시지에서 수신되는 하나 이상의 UE ID들을 포함할 수도 있다. 위의 실시예에 대해 계속 설명하면, CCF에서 Nnrf_NFDiscovery_Service 응답 메시지 수신 시에, 프로세스는 NEF 및 SCEF와 같은 AEF들의 Nnrf_NFDiscovery_Service 응답 메시지에서 수신된 NF 인스턴스, 및 제 1 서비스 API 정보 내의 하나 이상의 UE ID들에 기초하여, 제 1 서비스 API 정보를 CCF에 의해 업데이트하는 단계(단계 510) 를 포함할 수 있다. 이러한 이해에 따라, 제 1 서비스 API 정보 업데이트 시에, 프로세스는 CCF로부터 API 호출기에게 서비스 API 탐색 응답을 송신하는 단계(단계 512)를 포함할 수 있다. 일 실시예에서, 서비스 API 탐색 응답은 단계 502에 서 수신된 서비스 API 탐색 요청에 대한 응답으로서 송신될 수 있다. 일 실시예에서, 서비스 API 탐색 응답은 AEF들의 NF 인스턴스 정보를 포함하는 업데이트된 제 1 서비스 API 정보를 포함할 수 있다. 일 실시예에서, 전술한 프로세스는 NRF로 송신될 Nnrf_NFDiscovery_Service API 요청에 타겟 PLMN ID 정보를 포함시키는 것에 의해, 다른 PLMN(Public Land Mobile Network)로부터 NF 인스턴스 정보와 같은 AEF 정보를 페 치하기 위해 CCF에 의해 사용될 수 있다. 또한, 일 실시예에서, NRF는, TS 23.501 및 29.510에 규정된 바와 같 이, 타겟 PLMN으로부터 NF 인스턴스 정보라고도 지칭되는 NEF/SCEF 인스턴스 정보를 페치하도록 구성될 수 있다. 다음으로, AEF 정보를 AF에게 제공하기 위해, 다른 PLMN에 속하는 UE ID들에 대해, CCF는 이 정보를 사 용하도록 구성될 수 있다. 일 실시예에서, 본 발명 내용은 API 호출기가 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API들의 위 치를 탐색하기 위해 컨택트할 CCF를 결정하도록 하기 위해, 3GPP TS 23.222의 조항 8.25에 규정된 바와 같은 CAPIF 상호 연결을 사용하여 상이한 CAPIF 프로바이더로부터 하나 이상의 UE를 서빙하는 하나 이상의 서비 스 API들의 위치를 탐색하기 위한 다른 방법을 포함한다. 일 실시예에서, AF는 CAPIF 상호 연결을 지원하는 적어도 하나의 CAPIF 프로바이더와의 합의에 따를 수 있으며, 컨택트할 CCF 정보를 알고 있을 수 있다. 일 실시예에서, 상이한 PLMN들에 속하는 다수의 CAPIF 프로바이더들 로부터의 다수의 CCF들이 연결될 수 있고, 서비스 API 공유를 위한 사업 합의를 가질 수 있다. 일 실시예에서, CAPIF 코어 기능들 사이의 인터랙션을 위한 전제 조건은 CAPIF 코어 기능의 외부 인터페이스를 탐색하는 것이다. 탐색을 달성하는 것은 ETF RFC 2782 또는 IETF RFC 2915에 각각 규정된 DNS SRV RR 또는 NAPTR RR(Naming Authority Pointer)의 사용에 기초하여 다단계 프로세스를 통해 리졸브될 수 있는 CAPIF 코어 기능에 의해 노출되는 인터페이스에 대한 URI 할당에 기초한다. 서로 다른 동적 가중치들이 나중에 IP 주소들로 리졸 브될 수 있는 서로 다른 잠재적 명칭들에 할당될 수 있는 방식들이 가능할 수 있다. 도 6은 본 발명 내용의 일 실시예에 따른, CCF에서 서비스 API 정보를 퍼블리시하고 저장하기 위한 프로세스를 나타내는 동작 흐름도를 도시한 것이다. 일 실시예에서, 서비스 API 정보는 APF에 의해 CCF에 저장되도록 전송될 수 있다. 일 실시예에서, CCF는 서비스 API 퍼블리시 요청에 기초하여 서비스 API 정보를 저장하도록 트리거될 수 있다. 일 실시예에서, 서비스 API 정보는 도 2에서 언급된 바와 같이, 서비스 정보가 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API들과 관련된 정보를 포함할 수 있도록 하나 이상의 UE와 연관 될 수 있다. 일 실시예에서, 하나 이상의 서비스 API들은 하나 이상의 UE와 연관된 하나 이상의 UE ID들 을 통해 하나 이상의 UE와 링크될 수 있다. 위의 실시예에 대해 계속 설명하면, 프로세스는 하나 이상의 서비스 API들을 CCF에 퍼블리시하기 위해 CCF에서 APF로부터 서비스 API 퍼블리시 요청 메시지를 수신하는 단계(단계 602)를 포함할 수 있다. 일 실시예에서, 서 비스 API 퍼블리시 요청 메시지는 CAPIF_Publish_Service_API API를 사용하여 APF에 의해 송신될 수 있다. 일 실시예에서, CAPIF_Publish_Service_API API는 표 1의 다수의 API 파라미터들과 함께 API 퍼블리시 요청 메시 지에 포함된 하나 이상의 서비스 API들에 의해 지원되는 하나 이상의 UE의 하나 이상의 UE ID들, 하나 이 상의 API들과 연관된 제 1 서비스 API 정보를 포함할 수 있다.[표 2]"}
{"patent_id": "10-2023-7035297", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "표 2는 API 퍼블리시 요청 메시지의 다수의 API 파라미터들을 나타낸다. 위의 실시예에 대해 계속 설명하면, 서비스 API 퍼블리시 요청 메시지의 수신 시에, 프로세스는 CCF에 의해, 하 나 이상의 서비스 API들과 연관된 제 1 서비스 API 정보 및 하나 이상의 UE ID들을 메모리에 저장하는 것으로 진행할 수 있다(단계 604). 일 실시예에서, 하나 이상의 서비스 API들과 연관된 제 1 서비스 API 정보 및 하나 이상의 UE ID들은 메모리 내의 API 레지스트리에 저장될 수 있다. 다음으로, 프로세스는 CCF에 의해서 제 1 서비스 API 정보 및 하나 이상의 UE ID들이 CCF에 저장되어 있음을 나 타내는 API 퍼블리시 기능에 대한 서비스 API 퍼블리시 응답을 송신하는 단계(단계 606)를 포함할 수 있다. 도 7a는 본 발명 내용의 일 실시예에 따른, 하나의 CCF에서 다수의 CCF들과 연관된 하나 이상의 UE를 서빙 하는 서비스 API 정보를 저장하기 위한 프로세스를 나타내는 동작 흐름도(700a)를 도시한 것이다. 일 실시예에 서, 다수의 CFF들은 CCF-A, CCF-B, CCF-C로 지칭될 수 있다. 일 실시예에서, CCF-A, CCF-B 및 CCF-C는 제 1 CCF, 제 3 CCF 및 제 2 CCF로 상호 교환적으로 지칭될 수 있다. 일 실시예에서, 하나의 CCF 프로바이더는 서비 스 API 정보를 저장하는 제 2 CCF일 수 있다. 위의 실시예에 대해 계속 설명하면, 프로세스는 제 1 CCF에 의해서, APF로부터 하나 이상의 제 1 UE와 연관된 제 1 서비스 API 정보, 및 하나 이상의 제 1 UE ID들을 수신하는 단계(단계 702a)를 포함할 수 있다. 일 실시 예에서, 하나 이상의 제 1 UE는 도 2에서 언급된 바와 같이, 하나 이상의 UE 중의 것일 수 있다. 일 실시 예에서, 제 1 서비스 API 정보 및 하나 이상의 제 1 UE ID들은 제 1 CCF의 동일한 CAPIF 프로바이더 도메인에있는 APF로부터 제 2 CCF와 공유되거나, 또는 제 2 CCF로부터 공유될 수 있다. 다음으로, 프로세스는 제 1 CCF에 의해서, 제 2 CCF로부터, 제 1 CCF에 의한 제 2 CCF에서의 하나 이상의 제 2 UE 및 하나 이상의 제 2 UE ID들과 연관된 제 2 서비스 API 정보를 수신하는 단계(단계 704a)를 포함할 수 있다. 일 실시예에서, 하나 이상의 제 2 UE는 도 2에서 언급된 바와 같이, 하나 이상의 UE 중의 것일 수 있다. 일 실시예에서, 제 2 CCF는 상호 연결 API 퍼블리시(Interconnection API Publish)를 통해 제 2 서비스 API 정보 및 하나 이상의 제 2 UE ID들을 송신하도록 구성될 수 있다. 상호 연결 API 퍼블리시의 수신 시에, 프로세스는 상호 연결 API 퍼블리시 요청을 제 3 CCF로 송신하는 것으로 진행할 수 있다(단계 706a). 일 실시예에서, 상호 연결 API 퍼블리시 요청은 제 1 CCF에 의해 송신될 수 있다. 일 실시예에서, 상호 연결 API 퍼블리시 요청은 제 1 서비스 API 정보, 하나 이상의 제 1 UE ID들 및 제 2 서비 스 API 정보, 및 하나 이상의 제 2 UE ID들 중 적어도 하나를 포함할 수 있다. 제 3 CCF에서 상호 연결 API 퍼블리시의 수신 시에, 프로세스는 제 1 서비스 API 정보, 하나 이상의 제 1 UE ID 들 및 제 2 서비스 API 정보, 및 하나 이상의 제 2 UE ID들 중 적어도 하나를 저장하는 것으로 진행할 수 있다 (단계 708a). 후속적으로, 프로세스는 제 3 CCF로부터 상호 연결 API 퍼블리시 응답을 수신하는 것으로 진행할 수 있다(단계 710a). 일 실시예에서, 제 1 서비스 API 정보, 하나 이상의 제 1 UE ID들 및 제 2 서비스 API 정보, 및 하나 이상의 제 2 UE ID들 중 적어도 하나의 저장 시에 상호 연결 API 퍼블리시 응답이 제 3 CCF에 의해서 송신될 수 있으며, 이 상호 연결 API 퍼블리시 응답이 제 1 CCF에 의해서 수신될 수 있다. 일 실시예에서, 상호 연결 API 퍼블리시 응답은 수신된 제 1 서비스 API 정보, 하나 이상의 제 1 UE ID들 및 제 2 서비스 API 정보, 및 하나 이상의 제 2 UE ID들 중 적어도 하나가 제 3 CCF에 저장되어 있음을 나타낼 수 있다. 도 7b는 본 발명 내용의 일 실시예에 따른, CAPIF 상호 연결을 사용하여 다수의 CCF들로부터 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API를 탐색하게 위한 프로세스를 나타내는 동작 흐름도(700b)를 도시한 것이다. 위의 실시예에 대해 계속 설명하면, 프로세스는 제 1 CCF에서 API 호출기로부터 서비스 API 탐색 요청을 수신하 는 단계(702b)를 포함할 수 있다. 일 실시예에서, 서비스 API 탐색 요청은 하나 이상의 UE를 서빙하는 하 나 이상의 서비스 API들을 결정하기 위한 API 호출기로부터의 하나 이상의 UE ID들을 포함할 수 있다. 제 1 CCF에서 서비스 API 탐색 요청을 수신한 것에 응답하여, 프로세스는 제 1 CCF로부터 API 호출기에게 서비 스 API 탐색 응답을 송신하는 단계(단계 704b)를 포함할 수 있다. 일 실시예에서, 서비스 API 탐색 응답은 제 1 CCF에 저장된 하나 이상의 제 1 UE ID들과 연관된 제 1 서비스 API 정보 및 제 3 CCF에 저장된 하나 이상의 제 2 UE ID들과 연관된 제 2 서비스 API 정보를 포함할 수 있다. 위의 실시예에 대해 계속 설명하면, 프로세스는 제 1 CCF에 의한 상호 연결 서비스 API 탐색을 사용하여 제 3 CCF로부터 제 2 서비스 API 정보 및 하나 이상의 제 2 UE ID들을 페치하는 것으로 진행할 수 있다(단계 706b). 일 실시예에서, 제 3 CCF는 하나 이상의 UE ID들에 기초하여 제 2 서비스 API 정보를 식별할 수 있다. 일 실시 예에서는, 페치가 아래에 언급된 단계들에 기초하여 추가로 수행될 수 있다. 일 실시예에서, 프로세스는 쿼리 정보와 매칭되는 하나 이상의 제 2 UE ID들과 관련된 로컬로 저장되어 있는 서 비스 API 정보를 반환하는 단계를 포함할 수 있다. 또한, 프로세스는 서비스 API 탐색 응답에서, 탐색 기준과 매칭되는 서비스 API 카테고리를 갖는 제 3 CCF의 정보 및 하나 이상의 제 2 UE ID들을 AF로 송신하는 단계를 포함할 수 있다. AF는 CAPIF_Discover_Service_API API를 사용하여, 제 3 CCF로부터 하나 이상의 UE ID들과 매칭되는 서비스 API 정보를 탐색하도록 구성될 수 있다. 또한, 제 1 CCF-A는 상호 연결 서비스 API 탐색을 사 용하여 제 3 CCF로부터 제 2 서비스 API 정보를 페치하도록 구성될 수 있다. 일 실시예에서, 제 1 CCF는 CCF-B 에 대한 상호 연결 서비스 API 탐색 요청 메시지에 하나 이상의 제 2 UE ID들을 포함시킬 수 있으며, CCF-B는 하나 이상의 제 2 UE ID들을 포함하는 쿼리 정보와 매칭되는 서비스 API 정보를 반환한다. 또한, 제 1 CCF는 2 CCF로부터 탐색된 서비스 API 정보를 탐색 API 응답에서 AF에게 반환할 수 있다. 일 실시예에서, 세션 ID는 서비스를 제공하는 세션에 대응하는, API 퍼블리시 요청의 하나 이상의 UE ID들에 따 라 제공될 수 있다. 일 실시예에서, 세션 ID는 N5 인터페이스를 통해 AF에게 알려진 대응하는 세션 ID이거나 또는 N1 인터페이스를 통해 하나 이상의 UE 중의 UE에게 알려진 세션 ID일 수 있다. APF는 퍼블리시된 API에 특별히 '바인딩된' 세션 ID를 지정하도록 구성될 수 있다. 일 실시예에서, 세션 ID는 후속적으로 CCF 또 는 API 호출기에 의해 서비스 API를 선택하기 위한 것일 수 있다. 이것은 서비스 API 사용을 특정 UE 세션에바인딩하는데 사용될 수 있으며, 이에 따라 API 호출기가 서비스 API를 통해 의도된 서비스와 관련된 세션 시에 특별히 동작할 수 있다. 일 실시예에서, 노스바운드 API들이 수직 특정 애플리케이션들에 의한 소모를 위해 3GPP 수직 인에이블러 계층 들에서 노출되고 UE 측 기능 엔티티가 API 호출의 컨텍스트에 있는 것으로 결정되는 경우, UE 측 기능 엔티티 식별자들의 목록(예를 들어, SEAL을 위한 VAL UE ID, VAL USER ID 및 다른 수직 인에이블러 계층 아키텍처들에 서의 이와 유사한 것들)이 하나 이상의 UE ID들 대신에 포함될 수 있다. 서비스 API들은 UE 측 기능 엔티티 식 별자들의 목록과 함께 퍼블리시될 수 있으며 API 호출기(수직 특정 애플리케이션)는 UE 측 기능 엔티티 식별자 들의 목록에 기초하여 타겟 API 위치를 탐색할 수 있다. 본 발명 내용의 일 실시예에서, NF 정보는 제어 플레인 메커니즘을 사용하여 UE에 프로비저닝될 수 있다. 일 실시예에서, UE는 CCF, 및/또는 NEF와 같은 API 노출 기능, 및 UE 및 UE의 세션들에 특정한 노스바운드 API들을 서빙하는 SCEF에 대한 정보로 프로비저닝될 수 있다. UE는 UE의 애플리케이션들 또는 다른 AF들에 정보를 제공 할 수 있다. 또한, UE의 애플리케이션들은 UE로부터 CCF 및/또는 NEF와 같은 AEF, 및 SCEF 정보를 페치하여 UE 의 애플리케이션들을 서빙하는 AF들로 송신할 수 있다. AF들 및 UE의 애플리케이션들은 이 정보를 사용하여 인 터페이스 CCF 또는 AEF에 도달할 수 있으며, 후속적으로 노스바운드 API 호출의 컨텍스트에서, UE 및/또는 UE의 세션에 대한 노스바운드 API를 호출할 수 있다. 일 실시예에서, 5G 코어 네트워크는 예를 들어 23.501에 규정된 등록 절차 또는 TS 23.502에 규정된 UE 설정 업 데이트 절차, TS 23.502에 규정된 서비스 요청 절차, TS 23.502에 규정된 UE 파라미터 업데이트, 또는 다른 제 어 플레인 기반(NAS) 메커니즘 동안에, NAS를 통한 제어 플레인 메커니즘을 사용하여 UE에게 정보를 프로비저닝 할 수 있다. 일 실시예에서, UE는 5G 코어 네트워크로부터 CCF 및/또는 AEF 정보에 대한 요청을 트리거할 수 있거나, 또는 5G 코어 네트워크에 의해서 네트워크 트리거 메시지에 포함될 수 있다. 일 실시예에서, 5G 코어 네트워크는 CCF 및/또는 AEF 정보와 함께 세션 ID 정보를 할당할 수 있다. 세션 ID는 서비스를 제공하는 세션에 대응한다. 세션 ID는 N5 인터페이스를 통해 AF에게 알려진 대응하는 세션 ID이거나 N1 인터페이스를 통해 UE에게 알려진 세션 ID이다. 도 8은 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE를 서빙하는 하나 이상의 API들을 탐색하기 위한 시스템의 개략적인 블록도를 도시한 것이다. 일 실시예에서, 시스템은 하나 이상의 UE에 통합될 수 있다. UE의 예들로는 스마트폰, 랩탑, PC(Personal Computer), 태블릿 등을 포함할 수 있으며, 이에 제한되지 않는다. 일 실시예에서, UE는 LTE(Long Term Evolution) 및 NR(New Radio)에서 동작하도록 구성될 수 있다. 일 실시예에서, 하나 이상의 서비스 API들은 하나 이상의 노스바운드 API들로 상호 교환적으로 지칭 될 수 있다. 일 실시예에서, 방법은 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API들의 위치를 결정 하는 단계를 포함할 수 있다. 위의 실시예에 대해 계속 설명하면, 시스템은 프로세서, 메모리, 데이터, 모듈(들), 자원(들) 및 CCF를 포함할 수 있다. 일 실시예에서, 프로세서, 메모리, 데이터, 모 듈(들), 자원(들) 및 CCF는 서로 통신 가능하게 커플링될 수 있다. 인식되는 바와 같이, 시스템은 하드웨어, 설정 가능한 하드웨어 등 중 하나 이상인 것으로 이해될 수 있다. 일 예에서, 프로세서는 단일 처리 유닛 또는 다수의 유닛들일 수 있으며, 이들 모두는 다수의 컴퓨 팅 유닛들을 포함할 수 있다. 프로세서는 하나 이상의 마이크로프로세서들, 마이크로컴퓨터들, 마이크로컨트롤 러들, 디지털 신호 프로세서들, 중앙 처리 유닛들, 프로세서 코어들, 멀티-코어 프로세서들, 멀티프로세서들, 상태 머신들, 논리 회로들, 주문형 집적 회로들, 필드 프로그래머블 게이트 어레이들, 및/또는 동작 명령어들에 기초하여 신호들을 조작하는 임의의 장치들로 구현될 수 있다. 다른 기능들 중에서, 프로세서는 메모리 에 저장된 컴퓨터 판독 가능 명령어들 및/또는 데이터를 페치하고 및/또는 실행하도록 구성될 수 있 다. 일 예에서, 메모리는 예를 들어 SRAM(Static Random-Access Memory) 및/또는 DRAM(Dynamic Random-Access Memory)과 같은 휘발성 메모리 및/또는 ROM(read-only memory), EPROM(erasable programmable ROM), 플래시 메 모리, 하드 디스크, 광 디스크, 및/또는 자기 테이프와 같은 비-휘발성 메모리를 포함하는 본 기술 분야에 알려 진 임의의 비일시적 컴퓨터 판독 가능 매체를 포함할 수 있다. 메모리는 데이터를 포함할 수 있다. 일 실시예에서, 메모리는 프로세서를 위한 캐시 또는 랜덤 액세스 메모리를 포함한다. 대안적인 예 들에서, 메모리는 프로세서의 캐시 메모리, 시스템 메모리, 또는 다른 메모리와 같은, 프로세서와 별 개의 것이다. 메모리는 데이터를 저장하기 위한 외부 저장 장치 또는 데이터베이스일 수 있다. 메모리 는 프로세서에 의해 실행 가능한 명령어들을 저장하도록 동작될 수 있다. 도면들에 예시되거나 설명 된 기능들, 동작들 또는 태스크들은 메모리에 저장된 명령어들을 실행하기 위해 프로그래밍된 프로세서 에 의해 수행될 수 있다. 기능들, 동작들 또는 태스크들은 특정 타입의 명령어 세트, 저장 매체, 프로세 서 또는 처리 전략과 무관하며 단독으로 또는 조합하여 작동하는 소프트웨어, 하드웨어, 집적 회로, 펌웨어, 마 이크로-코드 등에 의해 수행될 수 있다. 마찬가지로, 처리 전략들에는 다중 처리, 다중 태스킹, 병렬 처리 등 이 포함될 수 있다. 데이터는 다른 것들 중에서도, 프로세서, 메모리, 모듈(들), 자원(들), 및 CCF 중 하나 이상에 의해 처리, 수신 및 생성되는 데이터를 저장하기 위한 저장소 역할을 한다. 모듈(들)은 다른 것들 중에서도, 특정 태스크들을 수행하거나 데이터 타입들을 구현하는 루틴들, 프로그램 들, 객체들, 구성 요소들, 데이터 구조들 등을 포함할 수 있다. 모듈(들)은 또한 신호 프로세서(들), 상 태 머신(들), 논리 회로들, 및/또는 동작 명령어들에 기초하여 신호들을 조작하는 임의의 다른 장치 또는 구성 요소로서 구현될 수 있다. 또한, 모듈(들)은 하드웨어, 적어도 하나의 처리 유닛, 예를 들어 프로세서 또는 이들의 조합에 의해 실행되는 명령어들로 구현될 수 있다. 처리 유닛은 범용 프로세서로 하여금 동작들을 수행하게 하는 명령어들 을 실행하는 범용 프로세서일 수 있거나, 또는 처리 유닛은 필요한 기능들을 수행하기 위한 전용일 수 있다. 본 개시의 또 다른 양태에서, 모듈(들)은 프로세서/처리 유닛에 의해 실행되는 경우, 설명된 기능들 중 임 의의 것을 수행할 수 있는 기계 판독 가능 명령어들(소프트웨어)일 수 있다. 자원(들)은 고유의 능력들을 제공하고/하거나 시스템의 성능에 기여하는 시스템의 물리적 및/또 는 가상 구성 요소들일 수 있다. 자원(들)의 예들은 메모리(예를 들면, 메모리), 전력 유닛(예를 들 면, 배터리), 디스플레이 유닛 등을 포함할 수 있으며 이에 제한되지 않는다. 자원(들)은 프로세서, 메모리 및 디스플레이 유닛 외에 전력 유닛/배터리 유닛, 네트워크 유닛(예를 들면, 통신 인터페이스 유닛 ) 등을 포함할 수 있다. 일 실시예에서, 디스플레이 유닛은 LCD(liquid crystal display), OLED(organic light-emitting diode), 평판 디스플레이, 고체 디스플레이, CRT(cathode ray tube), 프로젝터, 프린터 또는 결정된 정보를 출력하기 위한 현재 알려졌거나 나중에 개발될 다른 디스플레이 장치 중 하나일 수 있다. 디스 플레이는 사용자가 프로세서의 기능을 볼 수 있는 인터페이스 역할을 하거나, 특히 메모리에 저장된 소프트웨어와의 인터페이스 역할을 할 수 있다. 일부 예시적인 실시예들에서, 모듈(들)은 프로세서/처리 유닛에 의해 실행되는 경우, 설명된 기능들 중 임 의의 것을 수행하는 기계 판독 가능 명령어들(소프트웨어)일 수 있다. 위의 실시예에 대해 계속 설명하면, CCF는 메모리에 제 1 서비스 정보를 퍼블리시하도록 구성될 수 있다. 일 실시예에서, CCF는 APF로부터 서비스 API 퍼블리시 요청 메시지를 수신하도록 구성될 수 있다. 일 실시예에서, 서비스 API 퍼블리 시 요청 메시지는 하나 이상의 UE와 연관된 하나 이상의 UE ID들, 및 하나 이상의 UE를 지원하는 하 나 이상의 서비스 API들과 연관된 제 1 서비스 API 정보를 포함할 수 있다. 일 실시예에서, 서비스 API 퍼블리 시 요청 메시지는 CAPIF_Publish_Service_API API를 사용하여 APF에 의해 송신될 수 있다. 또한, CCF는 하나 이상의 서비스 API들과 연관된 제 1 서비스 API 정보 및 하나 이상의 UE ID들을 메모리에 저장하도록 구성 될 수 있다. 저장 시에, CCF는 제 1 서비스 API 정보 및 하나 이상의 UE ID들이 CCF에 저장되어 있음을 나타내는 서비스 API 퍼블리시 응답을 API 퍼블리시 기능에게 송신하도록 구성될 수 있다. 일 실시예에서, 제 1 서비스 API 정보는 서비스 API 명칭, 서비스 API 타입, 통신 타입, 설명, 서빙 영역 정보, AEF(API Exposing Function) 위치, UE ID들의 목록, 인터페이스 세부 사항들, 프로토콜들, 버전 번호들 및 데이터 포맷 중 적어도 하나를 포함할 수 있다. 위의 실시예에 대해 계속 설명하면, CCF는 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API들을 결정하기 위해 API 호출기로부터 서비스 API 탐색 요청 메시지를 수신하도록 구성될 수 있다. 일 실시예 에서, API 호출기는 CAPIF_Discover_Service_API API를 사용하여 서비스 API 탐색 요청 메시지를 송신한 다. 서비스 API 요청을 송신하기 이전에, API 호출기는 URI(Uniform Resource Identifier)를 CCF의 외부 인터페이스에 할당하도록 구성될 수 있다. 일 실시예에서, 외부 인터페이스는 서비스 API 탐색 요청 메시지를 전송하기 이전에 CCF와의 인터랙션을 개시하기 위해 API 호출기에 의해 탐색될 수 있다. 또한, API호출기는 DNS SRV RR 및 NAPTR RR 중 하나 이상을 통해 외부 인터페이스를 CCF로 리졸브하도록 구성될 수 있다. 일 실시예에서, 서비스 API 탐색 요청 메시지는 하나 이상의 UE와 연관된 하나 이상의 UE ID들 및 다수의 파라미터들을 포함할 수 있다. 서비스 API 탐색 요청 메시지를 수신한 것에 응답하여, CCF는 하나 이상의 UE ID들 및 다수의 파라미터들과 연관된 제 1 서비스 API 정보를 메모리로부터 검색하도록 구성될 수 있다. 일 실시예에서, 검색을 위해, CCF는 하나 이상의 UE ID들을 서빙하는 NF 인스턴스 정보를 페치하기 위해 Nnrf_NFDiscovery_Service 요청 메시지를 NRF로 송신하도록 구성될 수 있다. NF의 예들로는 NEF 및 SCEF를 포 함할 수 있으며, 이에 제한되지 않는다. 다음으로, CCF는 하나 이상의 UE ID들을 서빙하는 NF 인스턴스 정보를 포함하는 Nnrf_NFDiscovery_Service 응답 메시지를 NRF로부터 수신하도록 구성될 수 있다. 일 실시예에 서, NRF는 NRF의 메모리로부터 NF(Network Function) 인스턴스 정보를 검색한다. 또한, CCF는 NF 인스턴 스 정보 및 제 1 서비스 API 정보 내의 하나 이상의 UE ID들에 기초하여 제 1 서비스 API 정보를 업데이트하도 록 구성될 수 있다. 또한, 업데이트 시에, CCF는 서비스 API 탐색 요청에 대한 응답으로서 제 1 서비스 API 정보를 포함하는 서비스 API 탐색 응답을 송신하도록 구성될 수 있다. 일 실시예에서, 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API들은 제 1 서비스 API 정보에 기초하여 탐색될 수 있다. 본 발명 내용의 일 실시예에서, 시스템은 CAPIF 상호 연결을 사용하여 다수의 CCF들로부터, 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API를 저장하고 탐색하도록 구성될 수 있다. 일 실시예에서, 다수의 CCF들은 제 1 CCF, 제 2 CCF 및 제 3 CCF를 포함한다. 또한, 제 1 CCF는 하나 이상의 제 1 UE와 연관된 제 1 서비스 API 정보 및 하나 이상의 제 1 UE ID들을 APF로부터 수신하도록 구성될 수 있다. 일 실시예에서, 제 1 CCF는 제 2 CCF에서의 하나 이상의 제 2 UE와 연관된 제 2 서비스 API 정보 및 하나 이상의 제 2 UE ID들을 제 2 CCF로부터 수신하도록 더 구성될 수 있다. 일 실시예에서, 제 2 CCF는 상호 연결 API 퍼블리시를 통해 제 2 서비스 API 정보 및 하나 이상의 제 2 UE ID들을 송신하도록 구성될 수 있다. 다음으로, 제 1 CCF는 상호 연결 API 퍼블리시 요청을 제 3 CCF로 송신하도록 구성될 수 있다. 일 실시예에서, 상호 연결 API 퍼블리시 요청은 제 1 서비스 API 정보, 하나 이상의 제 1 UE ID들 및 제 2 서비스 API 정보, 하 나 이상의 제 2 UE ID들 중 적어도 하나를 포함할 수 있다. 위의 실시예에 대해 계속 설명하면, 제 3 CCF는 수 신된 제 1 서비스 API 정보, 하나 이상의 제 1 UE ID들 및 제 2 서비스 API 정보, 및 하나 이상의 제 2 UE ID들 중 적어도 하나가 제 3 CCF에 저장되어 있음을 나타내는 상호 연결 API 퍼블리시 응답을 제 1 CCF로 송신하도록 구성될 수 있다. 일 실시예에서, 제 1 CCF는 API 호출기로부터 하나 이상의 UE ID들을 포함하는 서비스 API 탐색 요청을 수 신하도록 구성될 수 있다. 일 실시예에서, API 호출기는 하나 이상의 UE를 서빙하는 하나 이상의 서 비스 API들을 결정하기 위해 서비스 API 탐색 요청을 송신할 수 있다. 이에 응답하여, 제 1 CCF는 제 1 CCF에 저장된 하나 이상의 제 1 UE ID들과 연관된 제 1 서비스 API 정보, 및 제 3 CCF에 저장된 하나 이상의 제 2 UE ID들과 연관된 제 2 서비스 API 정보를 포함하는 서비스 API 탐색 응답을 API 호출기에게 송신하도록 구성 될 수 있다. 또한, 제 1 CCF는 상호 연결 서비스 API 탐색을 사용하여 제 3 CCF로부터, 제 2 서비스 API 정보 및 하나 이상의 제 2 UE ID들을 페치하도록 구성될 수 있다. 일 실시예에서, 제 3 CCF는 하나 이상의 UE ID들 에 기초하여 제 2 서비스 API 정보를 식별하도록 구성될 수 있다. 도 9는 본 명세서에 개시된 실시예들에 따른 CCF의 다양한 하드웨어 구성 요소들을 도시한 것이다. CCF는 적어도 하나의 프로세서 및 트랜시버를 포함한다. 프로세서는 트랜시버와 커 플링된다. 적어도 하나의 프로세서는 도 1 내지 도 8에 따른 CCF의 방법들을 동작하도록 구성된다. 적어도 하나의 프로세서는 도 1 내지 도 8에 따른 CCF의 방법들을 동작하도록 트랜시버를 제어한다. 도 9가 CCF의 다양한 하드웨어 구성 요소들을 도시하고 있지만, 다른 실시예들이 이에 제한되지 않는다는 것이 이해되어야 한다. 다른 실시예들에서, CCF는 더 적거나 더 많은 수의 구성 요소들을 포함할 수 있다. 또한, 구성 요소들의 레이블들이나 명칭들은 예시의 목적으로만 사용된 것이며, 본 개시의 범위를 제한 하지 않는다. 하나 이상의 구성 요소들이 함께 결합되어 CCF에서 동일하거나 실질적으로 유사한 기능을 수행할 수 있다. 도 10은 본 명세서에 개시된 실시예들에 따른 API 호출기의 다양한 하드웨어 구성 요소들을 도시한 것이다. API 호출기는 적어도 하나의 프로세서와 트랜시버를 포함한다. 프로세서는 트랜 시버와 커플링된다. 적어도 하나의 프로세서는 도 1 내지 도 8에 따른 API 호출기의 방법들을 동작하도록 구성된다. 적어도 하나의 프로세서는 도 1 내지 도 8에 따른 API 호출기의 방법들을 동작하도록 트랜시버를 제어한다. 도 10이 API 호출기의 다양한 하드웨어 구성 요소들을 도시하고 있지만, 다른 실시예들이 이에 제한되지 않는다는 것을 이해해야 한다. 다른 실시예들에서, API 호출기는 더 적거나 더 많은 수의 구성 요소들을 포함할 수 있다. 또한, 구성 요소의 레이블들이나 명칭들은 예시의 목적으로만 사용된 것이며, 본 개시의 범위 를 제한하지 않는다. 하나 이상의 구성 요소들이 함께 결합되어 API 호출기에서 동일하거나 실질적으로 유사한 기능을 수행할 수 있다. 본 개시 내용을 설명하기 위해 특정 언어가 사용되었지만, 이로 인해 발생하는 어떠한 제한도 의도되지 않는다. 당업자에게 명백한 바와 같이, 본 명세서에 교시된 바와 같은 본 발명의 개념을 구현하기 위해 방법에 대한 다 양한 작업 수정이 이루어질 수 있다. 도면들 및 전술한 설명은 실시예들의 예들을 제공한다. 당업자는 기술된 요소들 중 하나 이상이 단일 기능 요소로 결합될 수 있다는 것을 이해할 것이다. 대안적으로, 특정 요소들이 여러 기능 요소들로 분할될 수 있다. 하나의 실시예의 요소들이 다른 실시예에 추가될 수 있다."}
{"patent_id": "10-2023-7035297", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 발명의 이들 및 다른 특징들, 양태들 및 이점들은 도면 전반에 걸쳐 유사한 문자가 유사한 부분을 나타내는 첨부 도면들을 참조하여 다음의 상세한 설명을 읽을 때 더 잘 이해될 것이다. 도 1은 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API들을 탐색하기 위 한 방법을 나타내는 동작 흐름도를 도시한 것이다. 도 2는 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE에 대한 하나 이상의 API들을 퍼블리시하고 탐색하기 위한 방법을 나타내는 동작 흐름도를 도시한 것이다. 도 3은 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE를 서빙하는 하나 이상의 API들을 탐색하기 위한 프로 세스를 나타내는 동작 흐름도를 도시한 것이다. 도 4는 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE에 대한 하나 이상의 AEF들을 탐색하기 위한 방법을 나타내는 동작 흐름도를 도시한 것이다. 도 5는 본 발명 내용의 일 실시예에 따른, NRF로부터 하나 이상의 UE에 대한 하나 이상의 AEF들을 탐색하기 위 한 프로세스를 나타내는 동작 흐름도를 도시한 것이다. 도 6은 본 발명 내용의 일 실시예에 따른, CCF에서 서비스 API 정보를 퍼블리시하고 저장하기 위한 프로세스를나타내는 동작 흐름도를 도시한 것이다. 도 7a는 본 발명 내용의 일 실시예에 따른, 하나의 CCF에서, 하나 이상의 UE를 서빙하고 다수의 CCF들과 연관된 서비스 API 정보를 저장하기 위한 프로세스를 나타내는 동작 흐름도(700a)를 도시한 것이다. 도 7b는 본 발명 내용의 일 실시예에 따른, CAPIF 상호 연결을 사용하여 다수의 CCF들로부터 하나 이상의 UE를 서빙하는 하나 이상의 서비스 API를 탐색하기 위한 프로세스를 나타내는 동작 흐름도(700b)를 도시한 것이다. 도 8은 본 발명 내용의 일 실시예에 따른, 하나 이상의 UE를 서빙하는 하나 이상의 API들을 탐색하기 위한 시스 템의 개략적인 블록도를 도시한 것이다. 도 9는 본 명세서에 개시된 실시예들에 따른 CCF의 다양한 하드웨어 구성 요소들을 도시한 것이다. 도 10은 본 명세서에 개시된 실시예들에 따른 API 호출기의 다양한 하드웨어 구성 요소들을 도시한 것이다. 또한, 당업자는 도면들의 요소들이 단순화를 위해 도시된 것이며 반드시 축척대로 도시될 필요는 없다는 것을 이해할 것이다. 예를 들어, 흐름도는 본 발명의 양태들에 대한 이해를 향상시키는데 도움이 되는 가장 중요한 단계들의 관점에서 방법을 예시한 것이다. 또한, 장치의 구성 관점에서, 장치의 하나 이상의 구성 요소들이 도 면에서 일반적인 심볼들로 나타내질 수도 있으며, 도면들은 본 명세서의 설명을 통해 당업자가 쉽게 이해할 수 있는 세부 사항들로 도면을 모호하게 하지 않도록 본 발명의 실시예를 이해하는데 적절한 특정 세부 사항만을 보여줄 수 있다."}
