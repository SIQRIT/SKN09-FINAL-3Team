{"patent_id": "10-2024-7041178", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0040890", "출원번호": "10-2024-7041178", "발명의 명칭": "신속한 파일 시맨틱 검색을 지원하는 컴퓨팅 SSD를 위한 에러 정정 방법들", "출원인": "샌디스크 테크놀로지스 아이엔씨.", "발명자": "선, 차오"}}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "디바이스로서,프로세서;복수의 메모리 디바이스들을 포함하는 메모리 어레이;상기 메모리 어레이에 통신 가능하게 결합된 제어기; 및원시 파일 데이터 및 상기 원시 파일 데이터에 대응하는 특징 데이터를 저장하도록 구성된 하나 이상의 메모리구조들을 포함하고;상기 특징 데이터는 조밀한 특징 벡터들 또는 초차원 벡터들 중 적어도 하나를 포함하고;상기 하나 이상의 메모리 구조들 각각은 상기 특징 데이터를 저장하고 액세스하기 위한 에러 정정 알고리즘을활용하고;상기 하나 이상의 메모리 구조들 각각은 상기 특징 데이터를 프로세싱하도록 구성된 하나 이상의 기계 학습 프로세싱 유닛들을 포함하는, 디바이스."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1 항에 있어서,상기 특징 데이터는 에러 없는(error-free) 데이터에 기반한 조밀한 특징 벡터들을 포함하는, 디바이스."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제2 항에 있어서,상기 조밀한 특징 벡터들은 원시 파일 데이터와 별개의 블록들에 저장되는, 디바이스."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1 항에 있어서,상기 특징 데이터는 상기 하나 이상의 메모리 구조들 내에 고르게 분포되는, 디바이스."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제1 항에 있어서,상기 에러 정정 알고리즘은 온-다이 에러 정정 코드(ECC: on-die Error Correction Code)로서 구현되고 상기하나 이상의 메모리 구조들 각각은 ECC를 갖는, 디바이스."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제1 항에 있어서,상기 특징 데이터는 초차원 벡터들을 포함하고, 상기 초차원 벡터들의 적어도 2개의 복사본들은 상기 하나 이상의 메모리 구조들의 각각에 저장되고, 상기 초차원 벡터들의 제1 복사본은 에러 정정 알고리즘을 사용하지 않고저장되고, 제2 복사본은 에러 정정 알고리즘을 사용하여 저장되는, 디바이스."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6 항에 있어서,상기 초차원 벡터의 상기 제1 복사본은 상기 기계 학습 프로세싱 유닛에 제공되고, 상기 초차원 벡터의 상기 제공개특허 10-2025-0040890-3-2 복사본은 상기 제1 복사본의 에러들을 정정하기 위해 제공되는, 디바이스."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "방법으로서,하나 이상의 메모리 구조들에 원시 파일 데이터를 저장하는 단계;상기 원시 파일 데이터에 대응하는 특징 데이터를 대응하는 하나 이상의 메모리 구조들에 저장하는 단계;상기 하나 이상의 메모리 구조들 중 적어도 하나로부터 특징 데이터를 로딩하는 단계 - 상기 특징 데이터는 조밀한 특징 벡터들 또는 초차원 벡터들 중 적어도 하나를 포함함 -;상기 특징 데이터로부터 하나 이상의 데이터베이스들을 생성하는 단계;상기 하나 이상의 메모리 구조들 중 적어도 하나로부터 상기 원시 파일 데이터를 로딩하는 단계; 및상기 특징 데이터를 저장하고 액세스하기 위한 에러 정정 알고리즘을 활용하는 단계를 포함하는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "제8 항에 있어서,상기 특징 데이터는 에러 없는 데이터에 기반한 조밀한 특징 벡터들을 포함하는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "제9 항에 있어서,상기 특징 데이터를 저장하는 단계는 상기 원시 파일 데이터와 별개의 블록들에 상기 조밀한 특징 벡터들을 저장하는 단계를 포함하는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_11", "content": "제8 항에 있어서,상기 하나 이상의 메모리 구조들 내에 고르게 상기 특징 데이터를 분포시키는 단계를 더 포함하는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_12", "content": "제8 항에 있어서,상기 에러 정정 알고리즘은 온-다이 에러 정정 코드(ECC)로서 구현되고 상기 하나 이상의 메모리 구조들 각각은ECC를 갖는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_13", "content": "제8 항에 있어서,상기 특징 데이터는 초차원 벡터들을 포함하고, 상기 특징 데이터를 저장하는 단계는: 상기 하나 이상의 메모리구조들 각각에 상기 초차원 벡터들의 적어도 2개의 복사본들을 저장하는 단계를 포함하고, 상기 초차원 벡터들의 제1 복사본은 에러 정정 알고리즘을 사용하지 않고 저장되고, 제2 복사본은 에러 정정 알고리즘을 사용하여저장되는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_14", "content": "제8항에 있어서, 상기 하나 이상의 메모리 구조들 각각은 기계 학습 프로세싱 유닛을 포함하고, 상기 초차원 벡터의 상기 제1 복사본은 상기 기계 학습 프로세싱 유닛에 제공되고, 상기 초차원 벡터의 상기 제2 복사본은 상기 제1 복사본에서의 에러들을 정정하기 위해 제공되는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_15", "content": "공개특허 10-2025-0040890-4-방법으로서,하나 이상의 메모리 구조들에 저장된 원시 파일 데이터를 리트리브(retrieve)하기 위해 기계 학습 모델을 사용하여 쿼리(query)를 프로세싱하는 단계;상기 하나 이상의 메모리 구조들에 저장된 특징 데이터로부터 하나 이상의 데이터베이스들을 생성하는 단계 -상기 특징 데이터는 조밀한 특징 벡터들 또는 초차원 벡터들 중 적어도 하나를 포함함 -;상기 하나 이상의 메모리 구조들로부터 상기 하나 이상의 데이터베이스들 및 원시 파일 데이터를 로딩하는단계; 및상기 쿼리에 대한 응답을 획득하기 위해 상기 원시 파일 데이터 및 하나 이상의 데이터베이스들을 프로세싱하는단계를 포함하는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_16", "content": "제15 항에 있어서,제어기는 상기 응답을 획득하기 위해 상기 쿼리를 프로세싱하기 위한 컴퓨팅 모드와, 상기 하나 이상의 메모리구조들로부터 하나 이상의 파일들을 리트리브하기 위한 저장 모드 사이에서 스위칭하는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_17", "content": "제16 항에 있어서,상기 제어기는 상기 컴퓨팅 모드에서 테이블 X에 대해 구성된 휘발성 메모리를 갖는 컴퓨팅 매핑 테이블, 및 상기 저장 모드에서 논리-대-물리(L2P) 테이블에 대해 구성된 상기 휘발성 메모리를 갖는 저장 매핑 테이블을 활용하는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_18", "content": "제15 항에 있어서,상기 쿼리에 대한 응답을 획득하기 위해 상기 원시 파일 데이터 및 상기 하나 이상의 데이터베이스들을 프로세싱하기 위해 에러 정정 알고리즘이 활용되는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_19", "content": "제15 항에 있어서,상기 제어기는 상기 하나 이상의 메모리 구조들 상의 어느 블록들이 상기 특징 데이터를 포함하는지 및 상기 쿼리에 대한 응답을 획득하기 위해 어느 블록들이 프로세싱되어야 하는지 여부를 결정하는, 방법."}
{"patent_id": "10-2024-7041178", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_20", "content": "제15 항에 있어서,상기 하나 이상의 메모리 구조들 각각은 상기 쿼리에 대한 응답을 획득하기 위해 상기 원시 파일 데이터 및 하나 이상의 데이터베이스들을 프로세싱하기 위한 기계 학습 프로세싱 유닛을 포함하는, 방법."}
{"patent_id": "10-2024-7041178", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "SSD 제어기가 디바이스 파일 시맨틱 검색을 제공하기 위해 새로운 온-다이 컴퓨팅 로직 회로(on-die computation logic circuit)들로 결과 집계를 핸들링하는 동안, SSD의 각각의 NAND 플래시 다이에 컴퓨팅을 분배하는 컴퓨팅 SSD 시스템을 통해 SSD 상에서 시맨틱 검색을 구현할 수 있는 디바이스들 및 방법들이 본원에서 개시된다. 컴퓨 (뒷면에 계속)"}
{"patent_id": "10-2024-7041178", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "관련 출원의 교차 참조 본 출원은 2022년 12월 22일에 제출된 미국 가출원 번호 63/476,666의 우선권을 주장하는 2023년 8월 14일에 미 국 특허청에 출원된 \"Error Correction Methods for Computational SSD Supporting Rapid File Semantic Search\"라는 제목의 미국 정식 출원 18/449,165의 콘텐츠 전체의 이익을 주장하고 이로써 모든 목적을 위해 참 조로 포함한다."}
{"patent_id": "10-2024-7041178", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 2, "content": "기술분야 본 개시내용은 저장 시스템에 관한 것이다. 보다 구체적으로, 본 개시내용은 기계 학습 프로세스들을 수행하기 위해 저장 시스템들을 활용하는 것에 관한 것이다."}
{"patent_id": "10-2024-7041178", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "저장 디바이스들은 컴퓨팅 시스템들 내의 어디에나 있다. 최근, SSD(solid-state storage device)들이 점점 더 흔해지고 있다. 이러한 비휘발성 저장 디바이스들은 NVMe(non-volatile memory express) 및 PCIe(peripheral component interconnect express)를 포함한 다양한 프로토콜들을 통신하고 활용하여 프로세싱 오버헤드를 줄이 고 효율성을 높인다. SSD가 발전함에 따라, SSD들은 기존의 하드 디스크 드라이브(HDD)들에 비해 더 전력 효율적이고, 따라서 소비자 및 상업용 시장에서 SSD들은 장점을 제공한다. 수 년에 걸쳐, 많은 사용자들은 자신의 삶, 경험, 여행, 관심사 를 기록한 수천 개의 파일을 축적하였다. 콘텐츠에 기반하여 특정 미디어 파일들을 찾기 위해, 사용자들은 특 정 사진들, 비디오들 및 다른 미디어에 대해 앨범들과 폴더들을 내비게이팅하고, 구성하고, 검색하는 데 많은 시간을 소비한다. 일반적으로, 사용자 미디어는 다양한 저장 및 컴퓨팅 디바이스들에 걸쳐 저장되고, 사용자들 은 원하는 미디어 파일을 찾기 위해 사진들, 비디오들, 및 다른 미디어를 맥락적으로 검색하기 위한 제한된 방 법을 갖는다. 실제로, 사용자들은 최근 파일들이나 특정 파일명들 또는 속성들을 가진 파일들을 검색하는 것으 로 제한되는, 저장 시스템들에서 미디어를 찾는 어휘 검색과 같은 기존 검색 방법들로 제한된다. 게다가, 저장 된 미디어 파일들의 엄청난 양 및 컨텍스트 검색 방법들의 부재는 사용자들이 자신의 저장 및 컴퓨팅 디바이스 들에서 특정 미디어를 찾는 것을 어렵게 만든다. 인공지능(AI)과 기계 학습(ML)이 발달하면서, 사용자들이 자신의 저장 디바이스들에 저장된 미디어 파일들 안에 서 관련 콘텐츠를 찾게 하는 정확한 시맨틱 검색(semantic searching)이 가능해졌다. 그러나, 저장 디바이스들 의 AI/ML 시맨틱 검색의 종래의 구현은 비효율적이고 제한적으로 만드는 몇 가지 문제들을 갖는다. 시맨틱 검 색의 종래의 AI/ML 구현에서의 하나의 문제는 데이터가 호스트 프로세서, 호스트 메모리, 및 저장 디바이스 사 이에서 반복적으로 이동되어 데이터 이동으로부터 대역폭 및 에너지의 실질적인 낭비를 초래한다는 것이다. 시 맨틱 검색의 종래의 AI/ML 구현에서의 다른 문제점은 호스트 컴퓨팅에 대한 AI/ML 프로세싱을 위한 데이터를 준 비하는 것, 즉, 다수의 다이들로부터 저장 디바이스 제어기로 데이터를 판독하고, AI/ML 프로세싱을 핸들링하기 위해 제어기용 메모리에 데이터를 버퍼링하고, 이어서 AI/ML 프로세싱을 수행하는 것이다. 이것은 저장 디바이 스 제어기에 대한 병목현상을 야기하는데, 이는 제어기가 I/O 및 컴퓨팅 동작들 둘 모두를 핸들링해야 하기 때 문이며, 이러한 컴퓨팅은 AI/ML 프로세싱을 위한 데이터를 저장하기 위한 추가적인 메모리 버퍼를 필요로 한다."}
{"patent_id": "10-2024-7041178", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "전술한 문제점들에 응답하여, SSD 제어기가 디바이스 파일 시맨틱 검색을 제공하기 위해 새로운 온-다이 컴퓨팅 로직 회로(on-die computation logic circuit)들로 결과 집계를 핸들링하는 동안, SSD의 각각의 NAND 플래시 다이에 컴퓨팅을 분배하는 컴퓨팅 SSD 시스템을 통해 SSD 상에서 시맨틱 검색을 구현할 수 있는 디바이스들 및 방법들이 본원에서 논의된다. 구체적으로, 많은 실시예들은 다수의 다이들로부터 SSD 제어기로 파일 특징 벡터 들을 판독하는 컴퓨팅 SSD 시스템을 활용하고, 비교될 수백만 개의 특징 벡터들이 존재하면, 이들 특징 벡터들 은 DRAM에 버퍼링될 수 있고 제어기는 거리 컴퓨팅을 핸들링한다. 로컬, 온-다이 AI/ML 프로세싱 유닛들은, 예 를 들어, 컴퓨팅 및 비교 동작들을 수행하고, 프로세싱 점수들 및 결과들을 SSD 제어기에 전달할 수 있다. SSD 제어기는 모든 다이들로부터 결과들을 집계하여 결과를 호스트로 반환한다. 일부 실시예들에서, 각각의 온-다 이 AI/ML 프로세싱 유닛의 특징 벡터 저장 크기는 상이한 태스크들 및/또는 특징 벡터 크기들에 적응하도록 필 요에 따라 구성될 수 있다. 이에 기반하여, AI/ML 프로세싱 유닛들의 회로 및 온-다이 AI/ML 프로세싱 유닛들 의 개수는 증가된 컴퓨팅 속도를 제공하거나 또는 소정 다이 영역 제약들을 충족시키기 위해 필요에 따라 구성 및 분산될 수 있다. 추가 실시예들은 아래에서 더 상세하게 논의된다. 이러한 해결책들은 호스트 프로세서, 호스트 메모리, 및 저장 디바이스 사이의 데이터 이동으로부터 대역폭 및 에너지의 실질적인 낭비를 감소시키는 것을 도울 수 있다. 게다가, 이들 해결책들은 저장 디바이스 제어기가 다수의 다이들로부터 제어기로의 특징 벡터들을 판독하고 AI/ML 컴퓨팅 및 프로세싱을 수행하기 위해 메모리에 특징 벡터들을 버퍼링하는 것을 요구하는 AI/ML 동작들에서 I/O 및 컴퓨팅 동작들 둘 모두를 핸들링할 필요가 있는 AI/ML 프로세싱에서의 저장 디바이스 제어기의 병목 현상을 감소시키는데 도움이 될 수 있다. 본 개시내용의 양태들은 장치, 시스템, 방법, 또는 컴퓨터 프로그램 제품으로서 실현될 수 있다. 따라서, 본 개시내용의 양태들은 전적으로 하드웨어 실시예, 전적으로 소프트웨어 실시예(펌웨어, 상주 소프트웨어, 마이크 로코드 등을 포함함), 또는 소프트웨어 양태와 하드웨어 양태를 조합한 실시예의 형태를 취할 수 있는데, 이들 은 모두 일반적으로 본 명세서에서 \"기능\", \"모듈\", \"장치\", 또는 \"시스템\"으로 지칭될 수 있다. 게다가, 본개시내용의 양태들은 컴퓨터 판독가능 및/또는 실행가능 프로그램 코드를 저장하는 하나 이상의 비일시적 컴퓨 터 판독가능 저장 매체로 실현되는 컴퓨터 프로그램 제품의 형태를 취할 수 있다. 본 명세서에 설명되는 기능 유닛들 중 많은 것이 자신들의 구현 독립성을 보다 구체적으로 강조하기 위해 기능들로서 라벨링되었다. 예를 들어, 기능은 맞춤형 VLSI 회로들 또는 게이트 어레이들, 기성(off-the-shelf) 반도체들, 예컨대 로직 칩들, 트 랜지스터들, 또는 다른 별개의 구성요소들을 포함하는 하드웨어 회로로서 구현될 수 있다. 기능은 또한, 프로 그램가능 하드웨어 디바이스들에서, 예컨대 필드 프로그램가능 게이트 어레이들, 프로그램가능 어레이 로직, 프 로그램가능 로직 디바이스들 등을 통해 구현될 수 있다. 기능들은, 또한, 다양한 유형들의 프로세서들에 의한 실행을 위해 적어도 부분적으로 소프트웨어로 구현될 수 있다. 실행가능 코드의 식별된 기능은, 예를 들어, 컴퓨터 명령어들의 하나 이상의 물리적 또는 로직 블록들을 포함할 수 있는데, 이들은 예를 들어 객체, 절차, 또는 기능으로서 조직될 수 있다. 그럼에도 불구하고, 식별 된 기능의 실행가능 코드들은 물리적으로 함께 위치될 필요가 없지만, 함께 논리적으로 접속될 때, 기능을 포함 하고 기능에 대한 진술된 목적을 달성하는, 상이한 위치들에 저장된 이종의 명령어들을 포함할 수 있다. 실제로, 실행가능 코드의 기능은 단일 명령어, 또는 많은 명령어들을 포함할 수 있고, 심지어, 여러 상이한 코 드 세그먼트들을 통하여, 상이한 프로그램들 사이에, 여러 저장 디바이스들에 걸쳐서 등으로 분배될 수 있다. 기능 또는 기능의 부분들이 소프트웨어로 구현되는 경우, 소프트웨어 부분들은 하나 이상의 컴퓨터 판독가능 및 /또는 실행가능 저장 매체에 저장될 수 있다. 하나 이상의 컴퓨터 판독가능 저장 매체들의 임의의 조합이 활용 될 수 있다. 컴퓨터 판독가능 저장 매체는, 예를 들어, 전자, 자기, 광학, 전자기, 적외선, 또는 반도체 시스 템, 장치, 또는 디바이스, 또는 전술한 것들의 임의의 적합한 조합을 포함할 수 있지만 이들로 제한되지 않으며, 전파 신호들을 포함하지 않을 것이다. 본 명세서의 맥락에서, 컴퓨터 판독가능 및/또는 실행가능 저장 매체는 명령어 실행 시스템, 장치, 프로세서, 또는 디바이스에 의해 또는 그와 연관하여 사용하기 위한 프로그 램을 포함하거나 저장할 수 있는 임의의 유형의(tangible) 및/또는 비일시적 매체일 수 있다. 본 개시내용의 양태들을 위한 동작들을 수행하기 위한 컴퓨터 프로그램 코드는 파이산(Python), 자바(Java), 스 몰토크(Smalltalk), C++, C#, 오브젝티브 C(Objective C) 등과 같은 객체 지향 프로그래밍 언어, 종래의 절차 형 프로그래밍 언어들, 예컨대 \"C\" 프로그래밍 언어, 스크립팅 프로그래밍(scripting programming) 언어들, 및/ 또는 다른 유사한 프로그래밍 언어들을 포함한 하나 이상의 프로그래밍 언어들의 임의의 조합으로 기록될 수 있 다. 프로그램 코드는 데이터 네트워크 등을 통해 사용자의 컴퓨터 및/또는 원격 컴퓨터 또는 서버 중 하나 이 상에서 부분적으로 또는 전체적으로 실행될 수 있다. 본원에서 사용되는 바와 같은 구성요소는 유형의, 물리적, 비일시적 디바이스를 포함한다. 예를 들어, 구성요 소는 맞춤형 VLSI 회로들, 게이트 어레이들, 또는 다른 집적 회로들을 포함한 하드웨어 로직 회로; 기성 반도체 들, 예컨대 로직 칩들, 트랜지스터들, 또는 다른 별개의 디바이스들; 및/또는 다른 기계적 또는 전기적 디바이 스들로서 구현될 수 있다. 구성요소는, 또한, 프로그램가능 하드웨어 디바이스들, 예컨대 필드 프로그램가능 게이트 어레이들, 프로그램가능 어레이 로직, 프로그램가능 로직 디바이스 등으로 구현될 수 있다. 구성요소는 PCB(printed circuit board) 등의 전기 라인들을 통해 하나 이상의 다른 구성요소들과 전기적으로 통신하는 하 나 이상의 실리콘 집적 회로 디바이스들(예를 들어, 칩, 다이, 다이 평면들, 패키지들) 또는 다른 별개의 전기 디바이스들을 포함할 수 있다. 본원에 설명되는 기능들 및/또는 모듈들 각각은, 소정 실시예들에서, 대안적으 로, 구성요소에 의해 실현될 수 있거나 또는 구성요소로서 구현될 수 있다. 본원에서 사용되는 바와 같은 회로는 전류를 위한 하나 이상의 경로들을 제공하는 하나 이상의 전기 및/또는 전 자 구성요소들의 세트를 포함한다. 소정 실시예들에서, 회로는 전류를 위한 귀환 경로를 포함할 수 있어서, 회 로는 폐루프이다. 그러나, 다른 실시예에서, 전류를 위한 귀환 경로를 포함하지 않는 구성요소들의 세트는 회 로(예를 들어, 개루프)로 지칭될 수 있다. 예를 들어, 집적 회로는 집적 회로가 (전류를 위한 귀환 경로로서) 접지에 결합되는지 여부에 관계없이 회로로 지칭될 수 있다. 다양한 실시예들에서, 회로는 집적 회로의 일부, 집적 회로, 집적 회로들의 세트, 집적 회로 디바이스들을 갖거나 갖지 않는 비집적 전기 및/또는 전기 구성요소 들의 세트 등을 포함할 수 있다. 일 실시예에서, 회로는 맞춤형 VLSI 회로들, 게이트 어레이들, 로직 회로들, 또는 다른 집적 회로들; 기성 반도체들, 예컨대 로직 칩들, 트랜지스터들, 또는 다른 별개의 디바이스들; 및/또 는 다른 기계적 또는 전기적 디바이스들로서 구현될 수 있다. 회로는 또한 프로그램가능 하드웨어 디바이스, 예컨대 필드 프로그램가능 게이트 어레이, 프로그램가능 어레이 로직, 프로그램가능 로직 디바이스 등에서 합성 회로로서(예를 들어, 펌웨어, 넷리스트 등으로서) 구현될 수 있다. 회로는 PCB(printed circuit board) 등의 전기 라인들을 통해 하나 이상의 다른 구성요소들과 전기적으로 통신하는 하나 이상의 실리콘 집적 회로 디바이 스들(예를 들어, 칩, 다이, 다이 평면들, 패키지들) 또는 다른 별개의 전기 디바이스들을 포함할 수 있다. 본원에 설명되는 기능들 및/또는 모듈들 각각은, 소정 실시예들에서, 회로에 의해 실현될 수 있거나 또는 회로로 서 구현될 수 있다. 본 명세서 전반에 걸친 \"하나의 실시예\", \"실시예\", 또는 유사한 언어에 대한 언급은 그 실시예와 관련하여 설 명되는 특정한 특징, 구조, 또는 특성이 본 개시내용의 적어도 하나의 실시예에 포함됨을 의미한다. 따라서, 본 명세서 전반에 걸친 \"하나의 실시예에서\", \"실시예에서\", 그리고 유사한 언어의 문구의 등장은 모든 문구가 동일한 실시예를 지칭할 수 있지만 반드시 그러한 것은 아니며, 명시적으로 달리 특정되지 않는다면 \"모든 실시 예는 아니지만 하나 이상의 실시예\"를 의미할 수 있다. 용어 \"포함하는(including, comprising)\", \"갖는 (having)\" 및 이들의 변형은 명시적으로 달리 특정되지 않는다면 \"~를 포함하지만 그로 제한되지 않음\"을 의미 한다. 아이템들의 열거된 목록은 명시적으로 달리 특정되지 않는다면 아이템들 중 임의의 것 또는 전부가 상호 배타적이고/이거나 상호 포괄적임을 암시하지 않을 수 있다. 정관사 및 부정관사(\"a\", \"an\" 및 \"the\")는 또한 달리 명시적으로 지정하지 않는 한 \"하나 이상의\"를 의미한다. 추가로, 본원에 사용되는 바와 같이, 데이터를 판독, 기록, 저장, 버퍼링, 및/또는 이송하는 것에 대한 언급은 데이터의 전체, 데이터의 일부분, 데이터의 세트, 및/또는 데이터의 서브세트를 포함할 수 있다. 마찬가지로, 비-호스트 데이터를 판독, 기록, 저장, 버퍼링, 및/또는 이송하는 것에 대한 언급은 비-호스트 데이터의 전체, 비-호스트 데이터의 일부분, 비-호스트 데이터의 세트, 및/또는 비-호스트 데이터의 서브세트를 포함할 수 있다. 마지막으로, 본 명세서에 사용되는 바와 같은 용어들 \"또는\" 및 \"및/또는\"은 임의의 하나 또는 임의의 조합을 포함하거나 의미하는 것으로 해석되어야 한다. 따라서, \"A, B 또는 C\" 또는 \"A, B 및/또는 C\"는: A; B; C; A 및 B; A 및 C; B 및 C; A, B 및 C 중 임의의 하나\"를 의미한다. 이러한 정의에 대한 예외는, 요소들, 기능들, 단계들, 또는 작용들의 조합이 일부 방식으로 본질적으로 상호 배타적일 때에만 발생할 것이다. 본 개시내용의 양태들은 본 개시내용의 실시예들에 따른 방법, 장치, 시스템, 및 컴퓨터 프로그램 제품의 개략 적인 흐름도 및/또는 개략적인 블록도를 참조하여 하기에 설명된다. 개략적인 흐름도 및/또는 개략적인 블록도 의 각각의 블록, 및 개략적인 흐름도 및/또는 개략적인 블록도 내의 블록들의 조합은 컴퓨터 프로그램 명령어에 의해 구현될 수 있음이 이해될 것이다. 이들 컴퓨터 프로그램 명령어는 기계를 생성하도록 컴퓨터의 프로세서 또는 다른 프로그램가능 데이터 프로세싱 장치에 제공되어, 프로세서 또는 다른 프로그램가능 데이터 프로세싱 장치를 통해 실행되는 명령어들이 개략적인 흐름도 및/또는 개략적인 블록도의 블록 또는 블록들에서 특정된 기 능 및/또는 작용을 구현하기 위한 수단을 생성하게 할 수 있다. 또한, 일부 대안적인 구현에서, 블록에서 언급된 기능은 도면에서 언급된 순서를 벗어나서 발생할 수 있음에 유 의해야 한다. 예를 들어, 연속으로 도시된 2개의 블록이 사실상 실질적으로 동시에 실행될 수 있거나, 또는 블 록이, 때때로, 수반된 기능성에 따라, 역순으로 실행될 수 있다. 예시된 도면의 하나 이상의 블록 또는 그들의 일부에 대해 함수, 로직, 또는 효과 면에서 등가인 다른 단계 및 방법이 고려될 수 있다. 다양한 화살표 유형 및 라인 유형이 흐름도 및/또는 블록도에서 채용될 수 있지만, 이들은 대응하는 실시예의 범위를 제한하지 않는 것으로 이해된다. 예를 들어, 화살표는 도시된 실시예의 열거된 단계들 사이의 특정되지 않은 지속기간의 대기 또는 모니터링 기간을 나타낼 수 있다."}
{"patent_id": "10-2024-7041178", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 2, "content": "하기의 상세한 설명에서, 그의 일부를 이루는 첨부 도면을 참조한다. 전술한 발명의 내용은 단지 예시적인 것 이며, 어떠한 방식으로든 제한하는 것으로 의도되지 않는다. 위에서 설명된 예시적인 양태, 실시예 및 특징에 더하여, 추가 양태, 실시예 및 특징은 도면 및 다음의 상세한 설명을 참조하여 명백해질 것이다. 각각의 도면 에서의 요소들의 설명은 선행 도면들의 요소들을 지칭할 수 있다. 유사한 도면 부호들은 유사한 요소들의 대안 적인 실시예들을 비롯해, 도면들 내의 유사한 요소들을 지시할 수 있다. 도 1을 참조하면, 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템에 적합한 저장 시스 템을 갖는 예시적인 호스트-컴퓨팅 디바이스의 개략적인 블록도가 도시되어 있다. 컴퓨팅 SSD 시스 템은 제어기를 통해 통신하는, 호스트-컴퓨팅 디바이스 내의 저장 시스템의 하나 이상의 저장 디바이스들을 포함한다. 호스트-컴퓨팅 디바이스는 프로세서, 휘발성 메모리 및 통 신 인터페이스를 포함할 수 있다. 프로세서는 하나 이상의 중앙 프로세싱 유닛들, 하나 이상의 범용 프로세서들, 하나 이상의 애플리케이션별 프로세서들, 하나 이상의 가상 프로세서들(예를 들어, 호스트-컴퓨팅 디바이스가 호스트 내에서 동작하는 가상 기계일 수 있음), 하나 이상의 프로세서 코어들 등을 포함할 수 있다. 통신 인터페이스는 호스트-컴퓨팅 디바이스 및/또는 저장 디바이스의 제어기를 통 신 네트워크, 예컨대, 인터넷 프로토콜(IP) 네트워크, SAN(Storage Area Network), 무선 네트워크, 유선네트워크 등에 통신가능하게 결합하도록 구성된 하나 이상의 네트워크 인터페이스들을 포함할 수 있다. 저장 디바이스는 다양한 실시예들에서, 호스트 컴퓨팅 디바이스에 대해 하나 이상의 상이한 위치들에 배치될 수 있다. 하나의 실시예에서, 저장 디바이스는 하나 이상의 비휘발성 메모리 디바이스들, 예 컨대 하나 이상의 인쇄 회로 기판들, 스토리지 하우징들, 및/또는 다른 기계적 및/또는 전기적 지지 구조들 상 에 배치되는 반도체 칩들 또는 패키지들 또는 다른 집적 회로 디바이스들을 포함한다. 예를 들어, 저장 디바이 스들은 하나 이상의 DIMM(direct inline memory module) 카드들, 하나 이상의 확장 카드들 및/또는 도터 카드들, 솔리드 스테이트 드라이브(SSD) 또는 다른 하드 드라이브 디바이스를 포함할 수 있고/있거나, 다른 메 모리 및/또는 스토리지 폼 팩터를 포함할 수 있다. 저장 디바이스는 호스트-컴퓨팅 디바이스의 마더 보드와 통합되고/되거나 장착될 수 있고, 호스트-컴퓨팅 디바이스의 포트 및/또는 슬롯에 설치되거나, 상 이한 호스트-컴퓨팅 디바이스 및/또는 네트워크 상의 전용 저장 어플라이언스 상에 설치되거나, 외부 버스(예컨대, 외부 하드 드라이브 등)를 통해 호스트-컴퓨팅 디바이스와 통신할 수 있는 등일 수 있다. 하나의 실시예에서, 저장 디바이스는 프로세서의 메모리 버스 상에(예컨대, 휘발성 메모리와 동 일한 메모리 버스 상에, 휘발성 메모리와는 상이한 메모리 버스 상에, 휘발성 메모리 대신에, 등등으 로) 배치될 수 있다. 추가적인 실시예에서, 저장 디바이스는 호스트-컴퓨팅 디바이스의 주변기기용 버스, 예컨대 PCI Express 또는 PCIe(peripheral component interconnect express) 버스, 예컨대 NVMe(NVM Express) 인터페이스, SATA(serial Advanced Technology Attachment) 버스, PATA(parallel Advanced Technology Attachment) 버스, SCSI(small computer system interface) 버스, 파이어와이어 버스, 파이버 채널 접속부, USB(Universal Serial Bus), PCIe-AS(PCIe Advanced Switching) 버스 등(그러나 이들로 제한되지 않음) 상에 배치될 수 있다. 다른 실시예에서, 저장 디바이스는 이더넷 네트워크, 인피니밴드 (Infiniband) 네트워크, 네트워크를 통한 SCSI RDMA, SAN(storage area network), LAN(local area network), WAN(wide area network), 예컨대 인터넷, 다른 유선 및/또는 무선 네트워크 등과 같은 통신 네 트워크 상에 배치될 수 있다. 호스트-컴퓨팅 디바이스는 컴퓨터 판독가능 저장 매체를 추가로 포함할 수 있다. 컴퓨터 판독가능 저장 매체는 호스트-컴퓨팅 디바이스(예컨대, 프로세서)가 본원에 개시되는 방법들 중 하나 이 상의 방법들의 단계들을 수행하게 하도록 구성된 실행가능 명령어들을 포함할 수 있다. 추가적으로, 또는 대안 으로, 버퍼링 구성요소는 컴퓨터 판독가능 저장 매체 상에 저장된 하나 이상의 컴퓨터 판독가능 명령 어들로서 실현될 수 있다. 디바이스 드라이버 및/또는 제어기는, 소정 실시예들에서, 로직 어드레스 공간을 호스트 클라이언트 들에게 제시할 수 있다. 본원에서 사용되는 바와 같이, 로직 어드레스 공간은 메모리 자원들의 로직 표현을 지칭한다. 로직 어드레스 공간은 복수의(예컨대, 소정 범위의) 로직 어드레스들을 포함할 수 있다. 본원에서 사용되는 바와 같이, 로직 어드레스는 하기를 포함하지만 이들로 제한되지 않는 메모리 자원 (예컨대, 데이터)을 참조하기 위한 임의의 식별자를 지칭한다: LBA(logical block address), CHS(cylinder/head/sector) 어드레스, 파일명, 객체 식별자, inode, UUID(Universally Unique Identifier), GUID(Globally Unique Identifier), 해시 코드, 서명, 인덱스 항목, 범위, 규모 등. 저장 디바이스를 위한 디바이스 드라이버는 로직 대 물리적 어드레스 매핑 구조와 같은 메타데이터를 유지하여, 로직 어드레스 공간의 로직 어드레스를 저장 디바이스(들) 상의 미디어 저장 위치들에 매 핑시킬 수 있다. 디바이스 드라이버는 하나 이상의 호스트 클라이언트들에 저장 서비스들을 제공하도록 구성될 수 있다. 호스트 클라이언트들은 호스트-컴퓨팅 디바이스 상에서 동작하는 로컬 클라이언트 들, 및/또는 네트워크 및/또는 통신 인터페이스를 통해 액세스가능한 원격 클라이언트들을 포함 할 수 있다. 호스트 클라이언트들은 다음을 포함할 수 있지만 이들로 제한되지 않는다: 운영 체제, 파일 시스템, 데이터베이스 애플리케이션들, 서버 애플리케이션들, 커널-레벨(kernel-level) 프로세스들, 사용자-레 벨 프로세스들, 애플리케이션들 등. 많은 실시예들에서, 호스트 컴퓨팅 디바이스는 사용자 요청에 기반하여 인스턴스화되거나 달리 생성될 수 있는 복수의 가상 기계들을 포함할 수 있다. 당업자들에 의해 이해되는 바와 같이, 호스트 컴퓨팅 디바이스 는 이용 가능한 컴퓨팅 자원들 및/또는 수요로만 제한되는 가상 호스트들로 구성된 복수의 가상 기계들을 생성할 수 있다. 하이퍼바이저는 복수의 가상 기계들을 생성, 실행 및 달리 관리하는 데 이용 가능할 수 있다. 각각의 가상 기계는 데이터를 저장하고 액세스하기 위해 저장 시스템을 활용할 수 있는 호스트 클라이언트 들과 유사한 복수의 가상 호스트 클라이언트들을 포함할 수 있다.디바이스 드라이버는 솔리드 스테이트 저장 디바이스들, 반도체 저장 디바이스들, SAN 저장 자원들 등을 포함 (그러나 이들로 제한되지 않음)하는 상이한 유형들 및 구성들의 저장 디바이스들을 포함할 수 있는 하나 이상의 저장 시스템들에 추가로 통신가능하게 결합될 수 있다. 하나 이상의 저장 디바이스들은 하나 이상의 각자의 제어기들 및 비휘발성 메모리 채널들을 포함할 수 있다. 디바이스 드라이버는 SATA 및 PCIe와 같은(그러나 이들로 제한되지 않음) 임의의 호환가능한 프로토콜들 또는 인터페이스를 통해 하 나 이상의 저장 디바이스들에 대한 액세스를 제공할 수 있다. 메타데이터는 프로토콜들 또는 인터페 이스들을 통해 수행되는 데이터 동작들을 관리 및/또는 추적하는 데 사용될 수 있다. 로직 어드레스 공간 은 하나 이상의 저장 디바이스들의 개개의 미디어 위치들에 각각 대응하는 복수의 로직 어드레스들을 포함할 수 있다. 디바이스 드라이버는 로직 어드레스들과 미디어 위치들 사이의 애니-투-애니(any-to-any) 매 핑들을 포함하는 메타데이터를 유지할 수 있다. 디바이스 드라이버는 하기를 포함할 수 있는(그러나 이들로 제한되지 않음) 버스를 통해 데이터, 커맨드들, 및/또는 쿼리(query)들을 하나 이상의 저장 디바이스들로 이송하도록 구성된 저장 디바이스 인 터페이스를 추가로 포함할 수 있고/있거나 그와 통신할 수 있다: 프로세서의 메모리 버스, PCI Express 또는 PCIe(peripheral component interconnect express) 버스, 직렬 ATA(Advanced Technology Attachment) 버스, 병렬 ATA 버스, SCSI(small computer system interface), 파이어와이어, 파이버 채널, USB(Universal Serial Bus), PCIe-AS(PCIe Advanced Switching) 버스, 네트워크, 인피니밴드, SCSI RDMA 등. 저장 디바이스 인터페이스는 IO-CTL(input-output control) 커맨드(들), IO-CTL 커맨드 확장(들), 원격 직접 메모리 액세스 등을 사용하여 하나 이상의 저장 디바이스들과 통신할 수 있다. 통신 인터페이스는 호스트-컴퓨팅 디바이스 및/또는 제어기를 네트워크에 그리고/또는 하 나 이상의 원격 클라이언트들(다른 호스트로서 역할을 할 수 있음)에 통신가능하게 결합하도록 구성된 하 나 이상의 네트워크 인터페이스들을 포함할 수 있다. 제어기는 하나 이상의 저장 디바이스들의 일부 일 수 있고/있거나 그들과 통신할 수 있다. 도 1이 단일 저장 디바이스를 묘사하지만, 본 개시내용은 이 와 관련하여 제한되지 않고, 임의의 수의 저장 디바이스들을 포함하도록 적응될 수 있다. 저장 디바이스는 하기를 포함할 수 있는(그러나 이들로 제한되지 않음) 비휘발성 메모리 채널들의 하 나 이상의 비휘발성 메모리 디바이스들을 포함할 수 있다: ReRAM, 멤리스터(Memristor) 메모리, 프로그램 가능 금속화 셀 메모리, 상변화 메모리(PCM, PCME, PRAM, PCRAM, 오보닉(ovonic) 통합 메모리, 칼코겐화물 RAM, 또는 C-RAM), NAND 플래시 메모리(예컨대, 2D NAND 플래시 메모리, 3D NAND 플래시 메모리), NOR 플래시 메모리, 나노 RAM(nano RAM 또는 NRAM), 나노결정 유선-기반 메모리, 실리콘-산화물 기반 10 나노미터 이하 (sub-10 nanometer) 프로세스 메모리, 그래핀(graphene) 메모리, 실리콘-산화물-질화물-산화물-실리콘(SONOS), 프로그램가능 금속화 셀(PMC), CBRAM(conductive-bridging RAM), MRAM(magneto-resistive RAM), 자기 저장 매 체(예컨대, 하드 디스크, 테이프), 광학 저장 매체 등. 비휘발성 메모리 채널들의 하나 이상의 비휘발성 메모리 디바이스들은, 소정 실시예들에서, 저장 클래스 메모리(SCM: storage class memory)(예컨대, 제자 리 기록 메모리(write in place memory) 등)를 포함한다. 비휘발성 메모리 채널은 본원에서 \"메모리 매체\"로 지칭될 수 있지만, 다양한 실시예들에서, 비휘발성 메 모리 채널은, 보다 일반적으로, 데이터를 기록할 수 있는 하나 이상의 비휘발성 기록 매체를 포함할 수 있 고, 이는 비휘발성 메모리 매체, 비휘발성 메모리 디바이스 등으로 지칭될 수 있다. 추가로, 저장 디바이스 는, 다양한 실시예들에서, 비휘발성 기록 디바이스, 비휘발성 메모리 어레이, 어레이 내의 복수의 상 호접속된 저장 디바이스들 등을 포함할 수 있다. 비휘발성 채널들은 다음을 포함할 수 있는(그러나 이들로 제한되지 않음) 하나 이상의 비휘발성 메모리 디 바이스들을 포함할 수 있다: 칩들, 패키지들, 평면들, 다이 등. 제어기는 비휘발성 메모리 채널들 상에서의 데이터 동작들을 관리하도록 구성될 수 있고, 하나 이상의 프로세서들, 프로그램가능 프로세서 들(예컨대, FPGA들), ASIC들, 마이크로제어기들 등을 포함할 수 있다. 일부 실시예들에서, 제어기는 비휘 발성 메모리 채널들 상에 데이터를 저장하고/하거나 그로부터 데이터를 판독하여, 저장 디바이스로/ 로부터 데이터를 이송하는 등으로 구성될 수 있다. 제어기는 버스를 통해 비휘발성 메모리 채널들에 통신가능하게 결합될 수 있다. 버스는 비휘발성 메모리 디바이스들로/로부터 데이터를 통신시키기 위한 I/O 버스를 포함할 수 있다. 버스 는 비휘발성 메모리 디바이스들에 어드레싱 및 다른 커맨드 및 제어 정보를 통신시키기 위한 제어 버스를 추가로 포함할 수 있다. 일부 실시예들에서, 버스는 비휘발성 메모리 디바이스들을 병렬로 제어기에 통신가능하게 결합할 수 있다. 이러한 병렬 액세스는 비휘발성 메모리 디바이스들이 그룹으로서 관리되어 비휘발성 메모리 어레이를 형성하는 것을 허용할 수 있다. 비휘발성 메모리 디바이스들은 개개의 로직 메모리 유닛들(예컨대, 로직 페이지들) 및/또는 로직 메모리 분할들(예컨대, 로직 블록들) 내에 파 티셔닝될 수 있다. 로직 메모리 유닛들은 각각의 비휘발성 메모리 디바이스들의 물리적 메모리 유닛들을 논리적으로 조합함으로써 형성될 수 있다. 제어기는 소정 실시예들에서, 워드 라인들의 어드레스들을 사용하여 비휘발성 메모리 디바이스 내의 워드 라인들의 블록을 조직하여, 워드 라인들이 단조 증가 시퀀스로 논리적으로 조직되도록 할 수 있다(예컨대, 워드 라인들에 대한 어드레스들을 단조 증가 시퀀스로 디코딩하고/하거나 변환하도록 하는 것 등). 추가 실시 예에서, 비휘발성 메모리 디바이스 내의 블록의 워드 라인들은 워드 라인 어드레스들의 단조 증가 시퀀스 로 물리적으로 배열될 수 있고, 이때 연속으로 어드레싱된 워드 라인들은 또한 물리적으로 인접해 있다(예컨대, WL0, WL1, WL2, ... WLN). 제어기는 호스트-컴퓨팅 디바이스 상에서 실행되는 디바이스 드라이버를 포함 및/또는 통신할 수 있 다. 디바이스 드라이버는 하나 이상의 인터페이스들을 통해 호스트 클라이언트들에게 저장 서비스들 을 제공할 수 있다. 디바이스 드라이버는 전술된 바와 같이, 버스를 통해 데이터, 커맨드들 및/또는 쿼리 들을 제어기로 이송하도록 구성된 저장 디바이스 인터페이스를 추가로 포함할 수 있다. 도 2를 참조하면, 본 개시내용의 실시예에 따른, 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템에 적합한 예시적인 저장 디바이스의 개략적인 블록도이다. 제어기는 복수의 높은 우선순위 및 낮은 우선순위 통신 채널 들을 통해 호스트와 인터페이싱하는 프론트-엔드 모듈(front-end module), 비휘발성 메모리 디바이스들 과 인터페이싱하는 백-엔드 모듈(back-end module), 및 저장 디바이스의 다양한 기능들을 수행 하는 다양한 다른 모듈들을 포함할 수 있다. 일부 예들에서, 각각의 모듈은 단지 임의의 다른 하드웨어를 포함 하는 모듈 없이 대응하는 모듈의 특징들을 구현하기 위해 프로세서로 실행 가능한 명령어들을 포함하는 메모리 의 부분일 수 있다. 각각의 모듈이 적어도 몇몇 하드웨어를 포함하기 때문에, 포함된 하드웨어가 소프트웨어를 포함할 때에도, 각각의 모듈은 하드웨어 모듈로 상호 교환적으로 지칭될 수 있다. 제어기는 RAM(random access memory) 내의 버퍼들을 관리하고 제어기의 내부 통신 버스 상의 통신을 위한 내부 버스 중재를 제어하는 버퍼 관리/버스 제어 모듈을 포함할 수 있다. ROM(read only memory)은 시스템 부트 코드를 저장하고/하거나 그에 액세스할 수 있다. 도 2에 제어기로부터 분리되어 위치된 것으로 예시되어 있지만, 다른 실시예들에서, RAM 및 ROM 중 하나 또는 둘 모두가 제어기 내에 위치될 수 있다. 또 다른 실시예들에서, RAM 및 ROM의 부분들은 제어기 내 그리고 제어기 외부 둘 모두에 위치될 수 있다. 추가로, 일부 구현예들에서, 제어기, RAM, 및 ROM은 별개의 반도체 다이들 상에 위치될 수 있다. 아래에서 논의되는 바와 같이, 일 구현예에서, 제출 큐들 및 완료 큐들은 RAM 내에 수용될 수 있는 제어기 메모리 버퍼에 저장될 수 있다. 추가적으로, 프론트-엔드 모듈은, 호스트 또는 다음 레벨의 저장 제어기와의 전기적 인터페이스를 제공하 는 호스트 인터페이스 및 물리적 계층 인터페이스를 포함할 수 있다. 호스트 인터페이스의 유 형의 선택은 사용되는 메모리의 유형에 의존할 수 있다. 호스트 인터페이스들의 예시적인 유형들은 SATA, SATA Express, SAS, 파이버 채널, USB, PCIe, 및 NVMe를 포함할 수 있으나 이들로 제한되지 않는다. 호스트 인터페이스는 전형적으로 데이터, 제어 신호들, 및 타이밍 신호들에 대한 전달을 용이하게 할 수 있다. 백-엔드 모듈은 에러 정정 엔진을 포함할 수 있고, 에러 정정 엔진은 호스트로부터 수신된 데이 터 바이트들을 인코딩하고 에러 정정 코드(ECC: error correction code)를 사용하여 비휘발성 메모리 디바이스 들로부터 판독된 데이터 바이트들을 디코딩하고 에러 정정한다. 백-엔드 모듈은 또한 비휘발성 메모 리 디바이스들로 송신될, 프로그램, 판독 및 소거 커맨드 시퀀스들과 같은, 커맨드 시퀀스들을 생성하는 커맨드 시퀀서를 포함할 수 있다. 추가적으로, 백-엔드 모듈은, RAID(Redundant Array of Independent Drives) 패리티의 생성 및 결함 데이터의 복구를 관리하는 RAID 모듈을 포함할 수 있다. RAID 패리티는 저장 디바이스에 기입되는 데이터에 대한 무결성 보호(integrity protection)의 추가 레벨 로서 사용될 수 있다. 일부 경우들에서, RAID 모듈은 에러 정정 엔진의 일부일 수 있다. 메모리 인 터페이스는 커맨드 시퀀스들을 비휘발성 메모리 디바이스들에 제공하고 비휘발성 메모리 디바이스들 로부터 상태 정보를 수신한다. 커맨드 시퀀스들 및 상태 정보와 함께, 비휘발성 메모리 디바이스들 내로 프로그래밍되고 그로부터 판독될 데이터는 메모리 인터페이스를 통해 통신될 수 있다. 플래시 제어 계층은 백-엔드 모듈의 전체 동작을 제어할 수 있다.도 2에 예시된 저장 디바이스의 추가적인 모듈들은 비휘발성 메모리 디바이스들의 메모리 셀들의 웨 어 레벨링(wear leveling)을 수행하는 매체 관리 계층을 포함할 수 있다. 저장 디바이스는, 또한, 제어기와 인터페이싱할 수 있는 외부 전기적 인터페이스들, 외부 RAM, 저항기들, 커패시터들, 또는 다른 구성요소들과 같은 다른 개별 구성요소들을 포함할 수 있다. 대안적인 실시예들에서, RAID 모듈들, 매체 관리 계층 및 버퍼 관리/버스 제어 모듈 중 하나 이상은 제어기에서 필요하지 않을 수 있 는 선택적인 구성요소들이다. 마지막으로, 제어기는 또한 지능형 메모리 어레이 로직을 포함할 수 있다. 많은 실시예들에서, 지능 형 메모리 어레이 로직은 쿼리를 수신하고, 수신된 쿼리로부터 컨텍스트 데이터를 추출하고, 추출된 컨텍 스트 데이터에 기반하여 쿼리를 프로세싱하기 위한 기계 학습 모델을 결정하도록 구성될 수 있다. 쿼리를 추가 로 프로세싱하기 위한 기계 학습 모델의 결정은 제어기에 의해 수행될 수 있다. 일부 실시예들에서, 제어 기는 쿼리를 추가로 프로세싱하기 위한 하나 이상의 적합한 기계 학습 모델들을 결정할 수 있다. 지능형 메모리 어레이 로직은 데이터(예를 들어, 쿼리)를 수신하고 기계 학습 프로세스들, 컴퓨팅들, 비교들, 동 작들, 또는 하나 이상의 쿼리 벡터들을 생성하기 위해 수신된 쿼리로부터 컨텍스트 데이터를 획득 및/또는 추출 하기 위한 다른 프로세싱을 수행하기 위한 하드웨어, 펌웨어, 소프트웨어, 전기 회로 및/또는 구성요소들, 또는 이들의 임의의 조합들에 의해 제공되고 이어서 하나 이상의 쿼리 벡터들을 추가로 프로세싱하기 위한 하나 이상 의 적합한 기계 학습 모델들을 결정할 수 있다. 이는 저장 디바이스 내에 저장된 제어 데이터에 액세스하 는 것, 관련 페이지들에 대해 비휘발성 메모리 디바이스들을 스캐닝하는 것 및 생성된 쿼리 벡터와 연관된 관련 비휘발성 메모리 디바이스들을 결정하는 것, 및 쿼리 벡터를 하나 이상의 결정된 관련 비휘발성 메모 리 디바이스들에 전달하는 것을 포함할 수 있다. 비휘발성 메모리 디바이스들 각각은 하나 이상의 기계 학습 모델들 및 프로세스들과 관련된 특징 데이터 및 특징 벡터 저장소를 포함할 수 있다. 특징 데이터는 하나 이상의 비휘발성 메모리 디바이스들 각각 내 에 고르게 분포될 수 있다. 일부 실시예들에서, 비휘발성 메모리 디바이스들은 복수의 세트들로 그룹화될 수 있고, 여기서 비휘발성 메모리 디바이스들의 각각의 세트는 특정 기계 학습 모델을 제공하고 특정 기계 학습 모델에 기반하여 기계 학습 프로세스들을 수행한다. 게다가, 비휘발성 메모리 디바이스들의 각각의 세트는 동일하거나 상이한 특징 데이터 및 특징 벡터 저장소를 포함할 수 있다. 이어서, 제어기는 쿼리 벡터를 하나 이상의 관련 비휘발성 메모리 디바이스들에 전달할 수 있다. 메모리 어레이의 비휘발성 메모리 디바이스들 각각은 제어기로부터 획득된 쿼리 벡터를 제1 입 력으로서 프로세싱하도록 구성된 하나 이상의 기계 학습 프로세싱 유닛들을 더 포함할 수 있다. 하나 이상의 비휘발성 메모리 디바이스 내의 특징 데이터는 제2 입력으로서 활용될 수 있고, 쿼리 벡터 및 특징 데이터 는 하나 이상의 기계 학습 프로세싱 유닛들에 의한 프로세싱 전에 메모리 디바이스에 버퍼링될 수 있다. 예를 들어, 비교 값을 생성하기 위해 제1 입력 및 제2 입력을 프로세싱한다. 하나 이상의 비휘발성 메모리 디바이스 는 기계 학습 프로세싱 유닛들의 유사도 또는 특징 데이터의 유사도에 기반하여 하나 이상의 메모리 세트 들로 그룹화될 수 있다. 제어기는 하나 이상의 비휘발성 메모리 디바이스로부터 제1 입력 및 제2 입 력을 프로세싱한 결과로서 비교 값 또는 출력 데이터 중 어느 하나를 획득할 수 있다. 일부 실시예들에서, 비 휘발성 메모리 디바이스들의 하나 이상의 세트들은 특정 기계 학습 모델 또는 프로세싱, 기계 학습 프로세 싱 유닛들에서의 유사도, 또는 특징 데이터에서의 유사도에 기반하여 함께 그룹화될 수 있다. 도 3을 참조하면 본 개시내용의 실시예에 따라 병렬로 감지 또는 프로그래밍되는, 예를 들어 NAND 구성으로 조 직되는, 메모리 셀들의 페이지의 개념적인 예시이다. 도 3은 도 1의 비휘발성 메모리 디바이스 내의 NAND 스트링(string)들의 뱅크를 개념적으로 도시한다. 페이지와 같은 '페이지'는 병렬로 감지 또는 프로 그래밍되게 할 수 있는 메모리 셀들의 그룹이다. 이것은 감지 증폭기들의 대응하는 페이지에 의해 주변 회로들에서 달성된다. 감지된 결과들은 데이터 래치들의 대응하는 세트 내의 래치들에서 활용될 수 있다. 각각의 감지 증폭기는 비트 라인을 통해 NAND 스트링과 같은 NAND 스트링에 결합될 수 있다. 예를 들어, 페이지는 행을 따라 배치될 수 있고, 워드 라인(WL3)에 공통으로 연결된 페이지의 셀들의 제어 게이 트들에 인가되는 감지 전압에 의해 감지된다. 각각의 열을 따라, 메모리 셀과 같은 각각의 메모리 셀은 비트 라인을 통해 감지 증폭기에 의해 액세스가능할 수 있다. 데이터 래치들 내의 데이터는 데이터 I/O 버스를 통해 메모리 제어기로부터 또는 메모리 제어기로 토글링될 수 있다. NAND 스트링은 자신의 2개의 단부들 각각에 소스 단자 및 드레인 단자를 형성하기 위해 자신의 소스들 및 드레인들에 의해 데이지-체인된 메모리 셀과 같은 일련의 메모리 셀들일 수 있다. 한 쌍의 선택 트랜지스 터들(S1, S2)은 각각 NAND 스트링의 소스 단자 및 드레인 단자를 통해 외부 소스로의 메모리 셀 체인의 연결을제어할 수 있다. 메모리 어레이에서, 선택 트랜지스터(S1)가 턴온되는 경우, 소스 단자는 소스 라인에 결 합된다. 유사하게, 드레인 선택 트랜지스터(S2)가 턴온되는 경우, NAND 스트링의 드레인 단자는 메모리 어레이 의 비트 라인에 결합된다. 체인 내의 각각의 메모리 셀은 전하를 저장하는 역할을 한다. 메모리 셀 은 의도된 메모리 상태를 나타내도록 주어진 전하량을 저장하는 전하 저장 요소를 갖는다. 많은 실시예들에서, 각각의 메모리 셀 내의 제어 게이트는 판독 및 기록 동작들에 대한 제어를 허용할 수 있다. 종종, 복수의 NAND 스트링들 내의 각각의 행의 대응하는 메모리 셀들의 제어 게이트들은 모두 동일한 워드 라인(예컨대, WL0, WL1 ... WLn)에 연결될 수 있다. 유사하게, 선택 트랜지스터들(S1, S2) 각각의 제어 게이트(각각 선택 라인들 (SGS 및 SGD)를 통해 액세스됨)는 자신의 소스 단자 및 드레인 단자를 통해 각각 NAND 스트링에 대한 제어 된 액세스를 제공한다. 위에 언급된 예시적인 메모리 디바이스는 데이터의 단일 비트들을 저장하는 물리적 페이지 메모리 셀들을 포함 하지만, 대부분의 실시예들에서, 각각의 셀은 다중-비트 데이터를 저장하고, 각각의 물리적 페이지는 다수의 데 이터 페이지들을 가질 수 있다. 추가적으로, 추가 실시예들에서, 물리적 페이지들은 데이터의 하나 이상의 논 리적 섹터들을 저장할 수 있다. 통상적으로, 디스크 운영 체제로 동작하는 호스트-컴퓨팅 디바이스(도 1 참조)는 통상적으로 512 바이트의 하나 이상의 단위로 되는 논리적 섹터들의 단위로 파일의 콘텐츠를 조직함으 로써 파일의 저장을 관리한다. 일부 실시예들에서, 물리적 페이지는 16 kB의 비트 라인들을 통해 대응하는 16 kB의 감지 증폭기들에 의해 병렬로 감지되는 16 kB의 메모리 셀들을 가질 수 있다. 호스트가 할당한 예시적인 논리적 섹터는 2kB의 데이터 크기를 갖는다. 따라서, 셀들이 각각 1 비트의 데이터(SLC)를 저장하도록 구성된 다면, 물리적 페이지는 8개의 섹터들을 저장할 수 있다. MLC, TLC, 및 QLC 및 다른 증가된 밀도 구조들에 대해, 각각의 셀은 2, 3, 4 또는 그 초과의 비트들의 데이터를 저장할 수 있고, 각각의 물리적 페이지는 활용되 는 구조에 따라 16, 32, 64 또는 그 초과의 논리적 섹터들을 저장할 수 있다. 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템에서의 특징 벡터 크기 및 배정을 위해, 비휘발성 메모리 디바이스의 기계 학습 프로세싱 유닛 은 상이한 특징 벡터 크기에 적응할 수 있도록 구성될 수 있다. 일 예로서, 미디어 파일(예를 들어, 이미지, 문서, 비디오 등)은 임의의 수의 특징 벡터들로 표현될 수 있다. 일부 실시예들에서, 미디어 파일에 대한 특징 벡터는 128 내지 1024개의 특징들일 수 있고, 특징 벡터의 크기는 256B 내지 2KB일 수 있다. 이어서 16KB NAND 플래시 페이지의 경우, 페이지의 판독은 8 내지 64개의 특징 벡터들을 얻을 것이다. 플래시 메모리와 다른 유형들의 메모리 사이의 하나의 고유한 차이는 메모리 셀이 메모리 셀 내의 무전하와 연 관된 소거 상태로부터 프로그래밍되어야 한다는 것이다. 이는 프로그래밍 전에 플로팅 게이트의 전하가 먼저 비워져야 하는 것을 요구한다. 프로그래밍은 플로팅 게이트에 원하는 양의 전하를 다시 추가한다. 이는 더 많 이 프로그램된 상태에서 더 작게 프로그램된 상태로 진행하도록 플로팅으로부터 전하의 일부를 제거하는 것을 지원하지 않을 수 있다. 따라서, 새로운 데이터는 기존 데이터를 덮어쓸 수 없으며 이전에 기록되지 않았거나 소거된 위치에 기록되어야 한다. 게다가, 플로팅 게이트로부터 모든 전하들을 소거하는 것은 종종 상당한 시간 이 걸릴 수 있다. 그러한 이유로, 셀 단위로 또는 심지어 페이지 단위로 소거하는 것은 번거롭고 비효율적일 것이다. 그러므로, 대부분의 실시예들에서, 메모리 셀들의 어레이는 종종 많은 수의 블록들로 분할된다. 많은 플래시-기반 메모리 시스템들에서 일반적인 바와 같이, 블록은 소거 단위이다. 즉, 각각의 블록은 하나의 동작 으로 소거될 수 있는 최소 수의 메모리 셀들을 포함한다. 이는 플래시 메모리 내의 메모리 셀들의 제한된 수명 들과 결합되어, 저장 디바이스 내에서 발생하는 소거 및 프로그래밍의 양을 제한하려는 필요성을 증가시킨다. 도 4를 참조하면, 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 예시적인 컴퓨팅 SSD 시스템의 개략적 인 블록도이다. 위에서 논의된 바와 같이, 제어기는 지능형 메모리 어레이 로직 및 결과 집계 유닛 을 포함한다. 제어기는 시맨틱 검색 쿼리를 수신하고, 프로세싱을 위해 쿼리를 지능형 메 모리 어레이 로직에 전달한다. 일부 실시예들에서, 제어기는 데이터(예를 들어, 쿼리)를 수신하고, 수신된 쿼리로부터 컨텍스트 데이터를 획득 및/또는 추출하기 위해 기계 학습 프로세스들, 컴퓨팅들, 비교 들, 동작들, 또는 다른 프로세싱을 수행하고, 지능형 메모리 어레이 로직에 대해 쿼리를 준비할 수 있다. 쿼리의 콘텐츠는 하나 이상의 텍스트, 문서들, 이미지들, 오디오, 또는 다른 미디어를 포함할 수 있다. 쿼리를 수신하면, 제어기는 쿼리를 프로세싱하고 쿼리로부터 컨텍스트 데이터를 추 출한다. 쿼리로부터 컨텍스트 데이터를 추출하는 것에 더하여, 컨텍스트 데이터를 구축하기 위한 다른 관 련 컨텍스트 정보는 쿼리 및/또는 컨텍스트 데이터를 하나 이상의 사전들, 라이브러리들, 또는 데이터베이 스들, 또는 이들의 조합과 비교함으로써 획득될 수 있다. 관련 컨텍스트 정보는 추가 프로세싱을 위해 쿼리 또는 쿼리로부터 추출된 컨텍스트 데이터에 추가될 수 있다. 게다가, 컨텍스트 정보는 제어기 상에 국부적으로 저장되거나 또는 제어기 및 지능형 메모리 어레이 로직에 원격으로 액세스가능할 수 있다. 제어기는 컨텍스트 데이터를 지능형 메모리 어레이 로직에 전달하고, 지능형 메모리 어레이로직은 제어기에 의해 제공되는 컨텍스트 데이터에 기반하여 쿼리를 프로세싱하기 위한 기계 학 습 모델의 결정을 행한다. 일부 실시예들에서, 제어기는 쿼리를 추가로 프로세싱하기 위해 지능형 메모리 어레이 로직 내 의 하나 이상의 적합한 기계 학습 모델들 또는 기계 학습 프로세스들을 결정할 수 있다. 지능형 메모리 어레이 로직은 데이터(예를 들어, 쿼리)를 수신하고, 수신된 쿼리로부터 컨텍스트 데이터를 획득 및/또는 추 출하기 위해 기계 학습 프로세스들, 컴퓨팅들, 비교들, 동작들 또는 다른 프로세싱을 수행할 수 있다. 지능형 메모리 어레이 로직은 쿼리 및/또는 쿼리로부터의 컨텍스트 데이터를 프로세싱하고, 수 신된 쿼리, 쿼리로부터의 컨텍스트 데이터, 또는 이들의 조합에 기반하여 쿼리 벡터를 생성한다. 추가로, 쿼리 벡터는 결정된 기계 학습 모델에 기반하여 부분적으로 또는 전체적으로 생성될 수 있다. 지능형 메모리 어레이 로직은 생성된 쿼리 벡터를 프로세싱하기 위한 하나 이상의 관련된 비휘발성 메모리 디바이스들 또는 비휘발성 메모리 디바이스들의 세트들을 결정할 수 있다. 결정은 쿼리, 쿼리로부터의 컨텍스트 데이터, 쿼리로부터의 관련 컨텍스트 정보, 또는 결정된 기계 학 습 모델, 또는 이들의 임의의 조합에 기반할 수 있다. 지능형 메모리 어레이 로직은 생성된 쿼리 벡터 를 하나 이상의 관련 비휘발성 메모리 디바이스들에 전달한다. 위에서 논의된 바와 같이, 하나 이상의 비휘발성 메모리 디바이스들 각각은 특징 데이터 및 하나 이상의 기계 학습 프로세싱 유닛들(421aa, 421ab,…421an, 421ba, 421bb,…421bn, 421na, 421nb,…421nn… 등)(이하, \"기계 학습 프로세싱 유닛\")을 포함하고, 여기서 각각의 기계 학습 프로세싱 유닛은 지능형 메모리 어레이 로직에 의해 제공된 입력(들) 및 비휘발성 메모리 디바이스들에 저장된 특징 데이터에 기반한 결과 및/또는 값을 획득하기 위해 기계 학습 프로세스들, 컴퓨팅들, 비교들, 동작들, 또는 다른 프로세싱을 수 행하기 위한 하드웨어, 펌웨어, 소프트웨어, 전기 회로 및/또는 구성요소들 또는 이들의 임의의 조합들을 포함 할 수 있다. 하나 이상의 기계 학습 프로세싱 유닛들 각각은 전달된 쿼리 벡터를 제1 입력으로서 프 로세싱하고 저장된 특징 데이터를 제2 입력으로서 활용하도록 구성될 수 있다. 이어서, 하나 이상의 기계 학습 프로세싱 유닛은 결과 및/또는 값(예를 들어, 비교 값)을 제어기에 대한 출력으로서 생성하기 위해 제1 및 제2 입력을 프로세싱할 수 있다. 지능형 메모리 어레이 로직은 제어기에 의한 추가 프 로세싱을 위해 특징 메타데이터를 출력에 추가할 수 있다. 일부 실시예들에서, 쿼리 벡터 및 특징 데이터는 하나 이상의 기계 학습 프로세싱 유닛들에 의한 프 로세싱 전에 메모리 디바이스에 버퍼링될 수 있다. 게다가, 특징 데이터는 하나 이상의 비휘발성 메모리 디바 이스들 내에 균등하게 분포될 수 있다. 일부 실시예들에서, 하나 이상의 비휘발성 메모리 디바이스들 각각은 기계 학습 프로세싱 유닛들에서의 유사도 또는 특징 데이터에서의 유사도에 기반하여 하나 이상의 메모리 세트들로 그룹화될 수 있다. 결과 집계 유닛은 모든 기계 학습 프로세싱 유닛으로부터 결과들 및/또는 값들을 출력으로서 획 득하고, 기계 학습 프로세스들, 컴퓨팅들, 비교들, 동작들, 또는 출력으로부터의 결과들을 결과로서"}
{"patent_id": "10-2024-7041178", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 3, "content": "요약, 리포트-기반, 또는 테이블 형태로 검색, 수집, 및 제시하는 것과 같은 출력 상의 다른 프로세싱을 수행한다. 결과는 추가 프로세싱을 위해 호스트로 전달될 수 있다. 도 5를 참조하면 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템의 예시적인 기계 학 습 프로세싱 유닛의 개략적인 블록도이다. 일부 실시예들에서, 기계 학습 프로세싱 유닛은 속도가 제한되 는 경우, 속도에 대한 영역을 트레이드 오프하도록 구성될 수 있어서, 더 낮은 영역 효율로 더 적은 하드웨어 재사용 또는 병렬 프로세싱을 생성한다. 예로서, 기계 학습 프로세싱 유닛은 고속을 위해 구성될 수 있다. 기계 학습 프로세싱 유닛은 기계 학습 프로세스들, 컴퓨팅들, 비교들, 동작들, 또는 다른 프로세싱 을 수행하기 위한 하드웨어, 펌웨어, 소프트웨어, 전기 회로 및/또는 구성요소들, 또는 이들의 임의의 조합들을 포함할 수 있다. 기계 학습 프로세싱 유닛은 쿼리 벡터(Vq)의 특징 벡터 크기를 결정하는 모듈, 2개 의 입력 벡터들(예컨대, Vq, Vf(i)) 사이의 거리(예를 들어, 유클리드/해밍 거리)를 컴퓨팅하는 하나 이상의 거리 컴퓨팅 유닛들(573a...573n)(이하, \"거리 컴퓨팅 유닛\"), 모듈에 의해 쿼리 벡터(Vq)로부터 추출된 특징 크기를 수신하고, 예를 들어, 거리 비교들의 개수를 특징 벡터 크기와 비교하고, 올바른 하나를 모든 입력 특징 벡터들(Vf(i)…Vf(i+n))의 최종 유사도 점수로서 선택함으로써 가변 특징 벡터 크기에 적응시키는 제어 유닛 을 포함한다. 추가로, 기계 학습 프로세싱 유닛은, 예를 들어, 거리 컴퓨팅 유닛들로부터의 2 개의 거리 입력들을 비교하고 레지스터에 더 작은 거리를 출력하는 기계 학습 프로세싱을 수행하기 위한 하나이상의 기계 학습 연산자들, 함수들 또는 레지스터들을 갖는 모듈을 포함한다. 이어서, 모듈의 레지 스터는 결과, 점수, 또는 값을 비휘발성 메모리 디바이스들 및/또는 제어기에 제공할 수 있다. 도 6을 참조하면 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템의 예시적인 기계 학 습 프로세싱 유닛의 개략적인 블록도이다. 일부 실시예들에서, 기계 학습 프로세싱 유닛은, 영역이 제한 되는 영역에 대한 속도를 트레이드 오프하도록 구성되어, 더 낮은 속도로 하드웨어 재사용 또는 직렬 프로세싱 을 생성할 수 있다. 예로서, 기계 학습 프로세싱 유닛은 높은 면적 효율성을 위해 구성될 수 있다. 기계 학습 프로세싱 유닛은 기계 학습 프로세스들, 컴퓨팅들, 비교들, 동작들, 또는 다른 프로세싱을 수행하기 위한 하드웨어, 펌웨어, 소프트웨어, 전기 회로 및/또는 구성요소들, 또는 이들의 임의의 조합들을 포함할 수 있다. 기계 학습 프로세싱 유닛은 쿼리 벡터(Vq)의 특징 벡터 크기를 결정하는 모듈, 2개의 입력 벡 터들(예컨대, Vq, Vf) 사이의 거리(예를 들어, 유클리드/해밍 거리)를 컴퓨팅하는 거리 컴퓨팅 유닛, 모듈 에 의해 쿼리 벡터(Vq)로부터 추출된 특징 크기를 수신하고, 예를 들어, 거리 비교들의 개수를 특징 벡터 크기와 비교하고, 올바른 하나를 모든 입력 특징 벡터들(Vf)의 최종 유사도 점수로서 선택함으로써 가변 특징 벡 터 크기에 적응시키는 제어 유닛을 포함한다. 추가로, 기계 학습 프로세싱 유닛은, 예를 들어, 거리 컴퓨팅 유닛들로부터의 2개의 거리 입력들을 비교하고 레지스터에 더 작은 거리를 출력하는 기계 학습 프 로세싱을 수행하기 위한 하나 이상의 기계 학습 연산자들, 함수들 또는 레지스터들을 갖는 모듈을 포함한 다. 이어서, 모듈의 레지스터는 결과, 점수, 또는 값을 비휘발성 메모리 디바이스들 및/또는 제어기 에 제공할 수 있다. 도 7을 참조하면 본 개시내용의 실시예에 따라 시맨틱 검색을 지원하는 예시적인 컴퓨팅 SSD 시스템을 활용하기 위한 프로세스를 묘사하는 흐름도이다. 프로세스는 쿼리를 수신함으로써 시작할 수 있다(블록 710). 많은 실시예들에서, 이것은 호스트 또는 SSD 제어기가 시맨틱 검색에 대한 쿼리를 수신하는 것을 발생시킨다. 일부 실시예들에서, 사용자는 호스트 또는 SSD 제어기에 전달되는 시맨틱 검색 요청을 제공한다. 이에 응답하 여, 제어기의 다양한 실시예들은 시맨틱 검색 프로세스를 실행하기 위해 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템(도 4 참조)에 대한 제어기 내의 것들과 같은 복수의 프로세스들을 지시할 수 있다. 프로세스는 수신된 쿼리로부터 컨텍스트 데이터를 추출할 수 있다(블록 715). 일부 실시예들에서, 컨텍스 트 데이터는 쿼리로부터 직접 획득될 수 있다. 전술한 바와 같이, 일부 실시예들에서, 쿼리에 관련된 컨텍스트 정보는 쿼리에 대한 컨텍스트 데이터를 구축하는 데 도움이 되는 다른 자원들을 통해 획득될 수 있다. 컨텍스 트 데이터를 구축하기 위한 관련 컨텍스트 정보는 쿼리 및/또는 컨텍스트 데이터를 사전들, 라이브러리들, 또는 데이터베이스들, 또는 이들의 조합에 대한 액세스를 갖는 하나 이상의 기계 학습 프로세스들과 비교함으로써 획 득될 수 있다. 프로세스는 추출된 컨텍스트 데이터에 기반하여 기계 학습 모델을 결정할 수 있다(블록 720). 당업계에 공지된 바와 같이, 다양한 기계 학습 모델들은 쿼리로부터 특징들을 추출 및 프로세싱하는데 사용될 수 있으며, 예를 들어, 컨볼루션 신경망(CNN), 컴퓨터 비전, 지도 학습, 준-지도 학습, 비지도 학습, 강화 학습(RL), 딥 러 닝(DL), 인공 신경망(ANN)들, 컴퓨터 비전, 음성 인식, 자연어 프로세싱, 기계 번역, 및 원하는 대로 다른 것들 이다. 추출된 컨텍스트 데이터에 기반하여 기계 학습 모델의 결정 시, 프로세스는 쿼리를 프로세싱하기 위해 기 계 학습 모델을 활용할 수 있다(블록 725). 제한이 아닌 예로서, 쿼리를 프로세싱함에 있어서, 기계 학습 모델 로부터 다양한 특징들이 획득될 수 있고, 특징들은 벡터를 생성하기 위해 프로세싱되고 유사도 검색과 같은 기 계 학습 프로세스들을 위해 준비될 수 있다. 수신된 쿼리 및 결정된 기계 학습 모델로부터 획득된 특징들에 기반하여, 프로세스는 쿼리 벡터를 생성하 고(블록 730), 생성된 쿼리 벡터와 연관된 하나 이상의 관련 비휘발성 메모리 디바이스들을 결정할 수 있다(블 록 735). 전술된 바와 같이, 비휘발성 메모리 디바이스는 다양한 상이한 유형들의 메모리 디바이스들을 가질 수 있는 임의의 적합한 저장 디바이스의 일부일 수 있다. 제한이 아닌 예로서, 저장 디바이스는 단 일 레벨 셀 NAND 메모리 및 쿼드 레벨 셀 NAND 메모리를 포함하는 복수의 비휘발성 NAND 메모리 디바이스들을 포함할 수 있다. 프로세스는 쿼리 벡터를 하나 이상의 결정된 관련 비휘발성 메모리 디바이스로 전달할 수 있다(블록 740). 프로세스는 전달된 쿼리 벡터를 제1 입력으로서 프로세싱하고(블록 745), 하나 이상의 관련된 비휘발성 메 모리 디바이스들 상의 특징 데이터를 제2 입력으로서 활용할 수 있다(블록 750). 전술된 바와 같이, 하나 이상의 결정된 관련 비휘발성 메모리 디바이스들은 쿼리 벡터를 제1 입력으로서 프로세싱하고 하나 이상의 비휘발성 메모리 디바이스들 상에 저장된 특징 데이터를 제2 입력으로서 프로세싱하기 위한 기계 학습 프로세싱 유닛을 갖는다. 프로세스는 비교 값을 생성하기 위해 제1 및 제2 입력을 프로세싱할 수 있다(블록 755). 소정 실시예들에 서, 프로세스는 에러 정정 코드(ECC) 없이 온-다이 컴퓨팅을 가능하게 하기 위해 초차원 벡터들/벡터 심볼 아키텍처를 활용할 수 있다. 이러한 방식으로, 특징들은 잡음 복원성일 수 있는 조밀한 특징 벡터들보다는 초 차원 벡터들로서 저장될 수 있다. 도 8을 참조하면 본 개시내용의 실시예에 따라 시맨틱 검색을 지원하는 예시적인 컴퓨팅 SSD 시스템을 활용하기 위한 프로세스를 묘사하는 흐름도이다. 프로세스는 기계 학습 모델을 사용하여 쿼리를 프로세싱함으 로써 시작될 수 있다(블록 810). 많은 실시예들에서, 이것은 호스트 또는 SSD 제어기가 시맨틱 검색에 대한 쿼 리를 수신하는 것을 발생시킨다. 일부 실시예들에서, 사용자는 호스트 또는 SSD 제어기에 전달될 수 있는 시맨 틱 검색 요청을 제공한다. 이에 응답하여, 제어기의 다양한 실시예들은 시맨틱 검색 프로세스를 실행하기 위해 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템(도 4 참조)에 대한 제어기 내의 것들과 같은 복수의 프로 세스들을 지시할 수 있다. 프로세스는 쿼리 벡터를 생성할 수 있다(블록 815). 쿼리 벡터를 생성함에 있어서, 컨텍스트 데이터는 쿼 리 및 기계 학습 모델에 의한 쿼리의 프로세싱으로부터 직접 획득될 수 있다. 제한이 아닌 예로서, 쿼리를 프 로세싱함에 있어서, 기계 학습 모델로부터 다양한 특징들이 획득될 수 있고, 특징들은 벡터를 생성하기 위해 프 로세싱되고 유사도 검색과 같은 기계 학습 프로세스들을 위해 준비될 수 있다. 당업계에 공지된 바와 같이, 다 양한 기계 학습 모델들은 쿼리로부터 특징들을 추출 및 프로세싱하는데 사용될 수 있으며, 예를 들어, 컨볼루션 신경망(CNN), 컴퓨터 비전, 지도 학습, 준-지도 학습, 비지도 학습, 강화 학습(RL), 딥 러닝(DL), 인공 신경망 (ANN)들, 컴퓨터 비전, 음성 인식, 자연어 프로세싱, 기계 번역, 및 원하는 대로 다른 것들이다. 프로세스는 하나 이상의 관련된 비휘발성 메모리 디바이스 상에 저장된 특징 데이터를 제2 입력으로서 추 가로 활용하는(블록 825) 제1 유닛으로서 하나 이상의 기계 학습 프로세싱 유닛으로 쿼리 벡터를 전달할 수 있 다(블록 820). 프로세스는 하나 이상의 비휘발성 메모리 디바이스들로부터 리트리브(retrieve)하기 위한 출력 데이터를 결정하기 위해 제1 및 제2 입력들을 프로세싱하기 위해 하나 이상의 기계 학습 프로세싱 유닛들 을 활용할 수 있다(블록 830). 프로세스는 지능형 메모리 어레이 로직을 사용하여 특징 메타데이터를 출 력 데이터에 할당할 수 있다(블록 835). 소정 실시예들에서, 프로세스는 에러 정정 코드(ECC) 없이 온-다 이 계산을 가능하게 하기 위해 초차원 벡터들/벡터 심볼 아키텍처를 활용할 수 있다. 이러한 방식으로, 특징들 은 잡음 복원성일 수 있는 조밀한 특징 벡터들보다는 초차원 벡터들로서 저장될 수 있다. 도 7 및 도 8을 참조하면, 데이터 간의 유사도를 컴퓨팅하기 위한 초차원 컴퓨팅은 예를 들어, 덧셈, 곱셈, 치 환에 의해 실현될 수 있다. 초차원 컴퓨팅은 정보가 하이퍼벡터들의 모든 각각의 비트에 고르게 분포되고, 학 습 및 분류 태스크들에서 빠른 학습 능력, 높은 에너지 효율 및 수용 가능한 정확도를 제공하기 때문에 본질적 으로 강건할 수 있다. 도 9를 참조하면 본 개시내용의 실시예에 따른 예시적인 기계 학습 프로세스의 개략적인 블록도이다. 도시된 바와 같이, 기계 학습 시스템에 대한 입력은 하나 이상의 쿼리들에 의한 시맨틱 검색 요청들을 포함 할 수 있다. 쿼리는 텍스트, 이미지, 문서, 오디오, 또는 다른 미디어를 포함할 수 있다. 쿼리는 수신된 쿼리로부터 컨텍스트 데이터를 획득 및/또는 추출하기 위해 기계 학습 프로세스들, 컴퓨팅들, 비교 들, 동작들 또는 다른 프로세싱을 수행하는 지능형 메모리 어레이 로직으로 전달될 수 있다. 지능형 메모 리 어레이 로직은 쿼리로부터 컨텍스트 데이터를 결정하고, 기계 학습 시스템의 기계 학습 프로 세싱 유닛(MPLU)에 대한 제1 입력으로서 쿼리 벡터를 형성하기 위해 쿼리에 특징들을 할당한다. 기계 학습 시스템에 대한 제2 입력은 하나 이상의 미디어 파일들과 같은 SSD 디바이스 상에 저장된 데이터를 포함한다. 미디어 파일은 텍스트, 이미지, 문서, 오디오, 또는 다른 미디어를 포함할 수 있다. 저장된 미디어 파일들은 지능형 메모리 어레이 로직에 의해 특징 데이터를 할당받을 수 있고, 각각의 미디어 파일은 하나 이상의 비휘발성 메모리 디바이스들 상에 저장될 수 있다. 특징 데이터 는 쿼리 벡터와 비교하기 위한 제2 입력으로서 하나 이상의 비휘발성 메모리 디바이스로부터 MPLU에 의해 스캔될 수 있다. MPLU는 출력 데이터를 획득하기 위해 저장된 미디어 파일들의 특징 데이터를 리트리브, 추 출, 계산, 및 쿼리 벡터와 비교하는 반복적인 프로세스를 따른다. 출력 데이터는 MPLU에 의한 하나 이상의 동작의 결과로서 제공될 수 있다. 일부 실시예들에서, 출력 데이터는 쿼리 벡터와 특징 데이터의 하나 이상의 세트들 사이의 비교의 유사도 점수일 수 있다. 이어서, 출력 데이터는 추가 프로세싱을 위해 제어기로 전달될 수 있다. 일부 실시예들에서, 제어기는 쿼리를 추가로 프로세싱하기 위해 지능형 메모리 어레이 로직 내 의 하나 이상의 적합한 기계 학습 모델들 또는 기계 학습 프로세스들을 결정할 수 있다. 지능형 메모리 어레이 로직은 데이터(예를 들어, 쿼리)를 수신하고, 수신된 쿼리로부터 컨텍스트 데이터를 획득 및/또는 추 출하기 위해 기계 학습 프로세스들, 컴퓨팅들, 비교들, 동작들 또는 다른 프로세싱을 수행할 수 있다. 위에서 논의된 바와 같이, 각각의 기계 학습 프로세싱 유닛은, 비휘발성 메모리 디바이스들 상에 저 장된 특징 데이터 및 지능형 메모리 어레이 로직에 의해 제공된 입력(들)으로부터 입력(들)에 기반하여 결 과 및/또는 값을 획득하기 위해 기계 학습 프로세스들, 컴퓨팅들, 비교들, 동작들, 또는 다른 프로세싱을 수행 하기 위한 하드웨어, 펌웨어, 소프트웨어, 전기 회로 및/또는 구성요소들, 또는 이들의 임의의 조합들을 포함할 수 있다. 일부 실시예들에서, 쿼리 벡터 및 특징 데이터는 하나 이상의 기계 학습 프로세싱 유닛들에 의 한 프로세싱 전에 메모리 디바이스에 버퍼링될 수 있다. 게다가, 특징 데이터는 하나 이상의 비휘발성 메 모리 디바이스들 내에 균등하게 분포될 수 있다. 일부 실시예들에서, 하나 이상의 비휘발성 메모리 디바 이스들 각각은 기계 학습 프로세싱 유닛들에서의 유사도 또는 특징 데이터에서의 유사도에 기반하여 하나 이상의 메모리 세트들로 그룹화될 수 있다. 도 10a를 참조하면 본 개시내용의 실시예에 따른 예시적인 에러 정정 시스템의 개략적인 블록도이다. 도시된 바와 같이, 조밀한 특징 벡터들을 인코딩 및 디코딩하기 위한 ECC 기능들을 통합하기 위한 에러 정정 시스템 이 도시된다. 예시적인 에러 정정 시스템은 호스트, SSD 제어기, NAND 플래시 메모리 어레이, 및 휘발성 메모리(예컨대, DRAM)를 포함할 수 있다. 에러 정정 시스템은 호스트 인터페이스, 임베디드 프로세서, 적어도 하나의 인코딩(1024a) 및 디코딩(1024b) 회로 및 프로세싱을 갖는 ECC 메모리 모듈, 및 SSD 제어기와 부분적으로 또는 전체적으로, 또는 다른 방식으로 통신하거나 그 내에 통합 되는 플래시 인터페이스를 더 포함할 수 있다. 임베디드 프로세서는 휘발성 메모리와 통신 할 수 있다. 휘발성 메모리는 SSD 제어기 내에 통합되고/되거나 임베디드 프로세서와 통신 할 수 있다. NAND 플래시 메모리 어레이는 복수의 NAND 다이들을 포함할 수 있고, 각각의 NAND 다이는 ECC 메모 리 모듈 및 기계 학습 프로세싱 유닛을 포함하는 메모리 회로 및 로직을 갖는다. 일부 실시 예들에서, 예시적인 에러 정정 시스템은 SSD 제어기가 NAND 다이들 상에 데이터를 저장하기 위해 호스트로부터 파일 데이터 및 하나 이상의 명령들을 수신하는 저장 모드에서 동작할 수 있다. 추가 로, 저장 모드에서, SSD 제어기는 NAND 다이들 상에 저장된 동일하거나 상이한 파일 데이터에 액세 스하기 위해 호스트로부터 하나 이상의 명령들을 수신할 수 있다. 도시된 바와 같이, 기록 동작에서, ECC 메모리 모듈은 NAND 다이들 상의 에러 없는 파일 데이터의 저장, 리트리브 및 프로세싱을 용이 하게 하기 위해 파일 데이터 내의 에러 정정 코드를 인코딩할 수 있다. 추가로, 호스트에 전송할 에러 없는 파일 데이터를 리트리브하기 위해, 판독 동작에서, ECC 메모리 모듈은 파일 데이터에 대한 인코딩된 에러 정정 코드를 사용하여 NAND 다이들 상에 저장된 파일 데이터로부터 수신된 파일 데이터 에러들을 프 로세싱 및/또는 제거할 수 있다. 일부 실시예들에서, 저장 모드에서의 파일 데이터 에러들은 호스트에 의해 파일 데이터 및/또는 명령들을 수신하여 NAND 플래시 메모리 어레이 상에 파일 데이터 및/또는 명령 들을 저장하는 것으로부터 SSD 제어기 내의 임의의 파일 데이터 프로세싱 스테이지 또는 플래시 인터페이 스에 도입될 수 있다(예를 들어, 그러나 이에 제한되지 않음). 일부 실시예들에서, 예시적인 에러 정정 시스템은 컴퓨팅 모드에서 동작할 수 있으며, 여기서 NAND 플래 시 메모리 어레이는 ECC 메모리 모듈을 갖는 메모리 회로 및 로직을 활용하여, 에러 없는 특 징 데이터(예를 들어, 조밀한 특징 벡터)를 인코딩, 디코딩, 검증하고, 점수를 획득하기 위해 쿼리 벡터와 비교 하도록 기계 학습 프로세싱 유닛에 제공한다. 따라서, 각각의 NAND 다이는 에러 없는 특징 데이터 또는 에러 없는 조밀한 특징 벡터들을 제공하기 위해 특징 데이터 에러 정정 코드를 인코딩 및 디코딩하기 위한 ECC 기능들을 포함한다. 따라서, NAND 다이들은 적어도 2개의 유형들의 데이터, 즉 원시 파일 데이터 및파일에 대응하는 특징 데이터(예를 들어, 특징 벡터들)를 저장한다. 메모리 회로 및 로직은 특징 데이터 프로세싱 효율, 예를 들어, 특징 데이터 및 온-다이의 병렬 프로세싱을 최대화하기 위해 특징 데이터 관리를 수 행할 수 있다. 일부 실시예들에서, 기계 학습 프로세싱 유닛들이 각각의 NAND 다이에 배치되는 것 과 유사하게, 메모리 회로 및 로직은 또한 대응하는 NAND 다이 상에 저장된 파일 데이터 및 특징 데이터를 핸들링하기 위해 각각의 NAND 다이 당 단일 유닛들로서 NAND 플래시 메모리 어레이에 분 산될 수 있다. 게다가, 일부 실시예들에서, 특징 데이터는 NAND 플래시 메모리 어레이의 각각의 NAND 다 이에 걸쳐 균등하게 파티셔닝되고 분산될 수 있다. 추가로, 특징 벡터들은 예를 들어, 가비지 수집과 같 은 저장 관리 동작들 동안 동일한 NAND 다이 내에 재위치될 수 있다. 도 10b는 본 개시내용의 실시예에 따른 도 10a의 예시적인 에러 정정 시스템의 차트이다. 데이터 무결성을 보 장하기 위해, 데이터 스크러빙은 특징 벡터들(예를 들어, FV 스크러빙을 사용하여) 및 파일 데이터(예를 들어, 종래의 데이터 스크러빙을 사용하여)에 대해 수행될 수 있다. 도시된 바와 같이, 특징 데이터 상의 FV 데이터 스크러빙에 대한 시간 당 비트 플립들의 개수는 파일 데이터에 대한 종래의 데이터 스크러빙보다 더 높은 주파 수 또는 종래의 데이터 스크러빙의 주파수의 분율, 예를 들어, 1/6, ¼, 1/3, ½, 2/3의 종래의 스크러빙 시간 에서 수행될 수 있다. 게다가, FV 스크러빙 및 종래의 스크러빙은 비트 플립들의 미리 결정된 임계치에 도달하 면 트리거될 수 있다. 예를 들어, FV 임계치에 도달할 때 FV 스크러빙이 수행될 수 있고, 종래의 임계치에 도 달할 때 종래의 스크러빙이 수행될 수 있다. 일부 실시예들에서, 시간/주파수 및 임계치의 조합은 FV 스크러빙 또는 종래의 스크러빙 중 적어도 하나를 수행하기 위해 사용될 수 있다. 도시된 바와 같이, FV 데이터 스크러 빙은 파일 데이터의 종래의 스크러빙 시점의 2/3에서 수행될 수 있다. 도 10c는 본 개시내용의 실시예에 따른 도 10a의 예시적인 에러 정정 시스템의 표이다. 파일 데이터 및 특징 데이터 에러 정정이 전술한 바와 같이 도시된다. 파일 데이터 및 특징 데이터는 또한 데이터 스크러빙을 거쳐, 단일 정정 가능한 에러가 다수의 정정 불가능한 에러들로 누적될 가능성을 감소시킬 수 있다. 도시된 바와 같 이, 에러 정정 엔진은 파일 데이터를 검증하기 위해 사용될 수 있고, 종래의 데이터 스크러빙은 저장 모드에서 파일 데이터의 데이터 무결성을 유지하기 위해 웨어 레벨링을 위해 사용될 수 있다. 종래의 데이터 스크러빙은 에러들에 대해 메인 메모리 또는 스토리지를 주기적으로 검사하고, 이어서 상이한 체크섬들 또는 데이터의 복사 본들의 형태의 리던던트 데이터를 사용하여 검출된 에러들을 정정하기 위해 하나 이상의 백그라운드 태스크들을 사용하는 에러 정정 기법들을 포함할 수 있다. 파일 데이터는 레코드 세트, 테이블 또는 데이터베이스로부터 손상 또는 부정확한 레코드들을 검출 및 정정하고, 데이터의 불완전, 부정확, 정확하지 않거나 무관한 부분들을 식별하고, 이어서 에러, 손상 또는 거친 데이터를 교체, 수정 또는 삭제하는 프로세스를 통해 클린징된다. 예로서, 예시적인 에러 정정 시스템이 특징 벡터 데이터(예를 들어, 조밀한 특징 벡터들)에 대해 컴퓨팅 모드에 있을 때, 온-다이 ECC가 요구된다. 일부 실시예들에서, 온-다이 ECC의 면적 및 레이턴시 오버헤드를 감 소시키기 위해, BCH(Bose-Chaudhuri-Hocquenghem)과 같은 더 약한 ECC가 사용될 수 있다. 일부 실시예들에서, 다른 유형들의 온-다이 ECC에는, 예를 들어, LDPC(Low Density Parity Check)가 사용될 수 있다. 게다가, 온- 다이 ECC는 파일 데이터 에러 정정을 위해서도 추가로 사용될 수 있다. 일부 실시예들에서, 특징 벡터 데이터 (예를 들어, 조밀한 특징 벡터들)는 더 용이한 데이터 관리를 용이하게 하기 위해 파일 데이터로부터 분리된 자 신의 메모리 블록들에 저장될 수 있다. 일부 실시예들에서, 특징 벡터 데이터(예를 들어, 조밀한 특징 벡터 들)는 더 빠른 컴퓨팅 시간들 및 데이터 액세스를 용이하게 하기 위해 동일한 메모리 블록에 관련 파일 데이터 와 함께 저장될 수 있다. 파일 데이터의 데이터 스크러빙은 전술한 종래의 데이터 스크러빙을 사용할 수 있는 반면, 특징 데이터는 예를 들어, 잘못된, 부정확한, 불완전한, 비어 있거나 중복되는 특징 벡터 데이터를 정리 하기 위해 별개의 데이터 스크러빙 알고리즘을 사용할 수 있다. 일부 실시예들에서, SSD 저장 디바이스가 시맨틱 검색 모드에서 동작할 때, 판독/기록 요청들을 서빙하기 위한 호스트로부터의 요청들은 무시되고, 지연되고, 일부 시맨틱 검색 동작들이 완료된 후에 수행되거나, 모든 시맨틱 검색 동작들이 완료된 후에 수행되도록 큐잉될 수 있거나, 또는 이들의 임의의 조합으로 수행될 수 있다. 따라서, 휘발성 메모리는 파일 데이터 액세스들을 위한 논리-대-물리(L2P) 테이블보다는 데이터 관리 데이터 구조들에 관련된 특징 데이터를 로딩하는데 사용될 수 있다. 특징 벡터 데이터 관리와 관련하여, 애플리케이션은 빠른 시맨틱 검색을 수행하기 위해 SSD 저장 디바이스(12 0)에 적어도 하나의 데이터베이스를 유지할 필요가 있으며, 예를 들어, 데이터베이스는 속성들: 파일명, 해시값, 및 특징 벡터 데이터로 구성될 수 있다. 게다가, 적어도 하나의 파일은 애플리케이션을 시작할 때 애 플리케이션에 로딩될 속성들인 파일명 및 해시값을 포함할 수 있다. 일부 실시예들에서, 해시값 및 특징 벡터 데이터의 정보는 하나 이상의 특징 벡터들을 인덱싱하기 위해 하나 이상의 데이터 구조들(예를 들어, 테이블X)에 포함될 수 있다. 일부 실시예들에서, 테이블 X는 SSD 저장 디바이스 펌웨어에 저장될 수 있고, 테이 블 X는 Addr, 해시값, 및 특징 벡터 데이터의 속성들로 구성될 수 있다. 추가로, 시맨틱 검색으로부터 반환된 해시값(들)에 따라, 애플리케이션은 검색 결과로부터 파일명(들)을 리트리브할 수 있다. 일부 실시예들에서, 테이블 X의 크기는 SSD 저장 디바이스에 저장된 파일들의 개수에 비례할 수 있다. 추가로, 일부 실시예들 에서, Addr은 [Die, Plane, Block, Page, Segment]의 형태일 수 있고, 여기서 이는 Segment를 나타낼 비트 수 이다."}
{"patent_id": "10-2024-7041178", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 4, "content": "일부 실시예들에서, 해시값 특징 벡터는 데이터 관리를 단순화하기 위한 해시값 및 그 특징 벡터의 연결일 수 있다. 게다가, SSD 저장 디바이스가 검색 요청(예를 들어, 쿼리)을 수신할 때, SSD 제어기는 특수 검색 커맨드(들)를 생성하고 이들을 각각의 NAND 플래시 다이로 전송할 필요가 있다. SSD 제어기 는 어떤 블록(들)이 특징 벡터 데이터를 포함하는지를 NAND 플래시 다이에 통지할 수 있고, NAND 플래시 다이는 그에 따라 컴퓨팅을 수행해야 한다. 게다가, 각각의 NAND 플래시 다이는 top_k 해시값 = Loop(search(query_vec, plane#, block#, last_page#, last segment#))의 기능을 수행할 수 있다. 도 11a는 본 개시내용의 실시예에 따른 예시적인 에러 정정 시스템의 개략적인 블록도이다. 도시된 바와 같이, HDV(Hyper Dimensional Vectors) 또는 VSA(Vector Symbolic Architecture)를 인코딩 및 디코딩하기 위한 ECC 기능들을 통합하기 위한 에러 정정 시스템이 도시되며, 여기서 온-다이 ECC는 선택적일 수 있다. 본 개 시에서 HDV와 VSA는 상호교환적으로 사용될 수 있지만, 이하에서는 HDV가 사용될 것이다. 일부 실시예들에서, 각각의 NAND 다이에 ECC 로직, 회로, 또는 프로세싱을 통합하는 것은 너무 비쌀 수 있다. 예를 들어, 각 각의 NAND 다이에 ECC 메모리 모듈을 통합시키는 것은 엄청나게 비싸거나, NAND 플래시 메모리 어 레이 상에서 너무 많은 면적을 차지할 수 있다. 대신, HDV/VSA는 각각의 파일에 대해 저장될 수 있으며, 여기서 그러한 컨텍스트/시맨틱 표현들은 잡음에 강건할 수 있고, 유사도들을 보존하고, NAND 플래시 다이들 로부터 판독될 수 있고, 에러 정정들 없이 컴퓨팅될 수 있다. 예시적인 에러 정정 시스템은 호스트, SSD 제어기, NAND 플래시 메모리 어레이, 및 휘발성 메모리(예컨대, DRAM)를 포함할 수 있다. 에러 정정 시스템은 호스트 인터페이스, 임베디드 프로세서, 적어도 하나의 인코딩(1124a) 및 디코딩(1124b) 회로 및 프로세싱을 갖는 ECC 메모리 모듈, 및 SSD 제어기와 부분적으로 또는 전체적으로, 또는 다른 방식으로 통신하거나 그 내에 통합 되는 플래시 인터페이스를 더 포함할 수 있다. 임베디드 프로세서는 휘발성 메모리와 통신 할 수 있다. 휘발성 메모리는 SSD 제어기 내에 통합되고/되거나 임베디드 프로세서와 통신 할 수 있다. NAND 플래시 메모리 어레이는 복수의 NAND 다이들을 포함할 수 있고, 각각의 NAND 다이는 기계 학 습 프로세싱 유닛을 포함하는 메모리 회로 및 로직을 갖는다. 일부 실시예들에서, 예시적인 에러 정정 시스템은 SSD 제어기가 NAND 다이들 상에 데이터를 저장하기 위해 호스트로부터 파일 데이터 및 하나 이상의 명령들을 수신하는 저장 모드에서 동작할 수 있다. 추가로, 저장 모드에서, SSD 제어기는 NAND 다이들 상에 저장된 동일하거나 상이한 파일 데이터에 액세스하기 위해 호스트 로부터 하나 이상의 명령들을 수신할 수 있다. 도시된 바와 같이, 기록 동작에서, ECC 메모리 모듈 은 NAND 다이들 상의 에러 없는 파일 데이터의 저장, 리트리브 및 프로세싱을 용이하게 하기 위해 파일 데이터 내의 에러 정정 코드를 인코딩할 수 있다. 추가로, 호스트에 전송할 에러 없는 파일 데이터 를 리트리브하기 위해, 판독 동작에서, ECC 메모리 모듈은 파일 데이터에 대한 인코딩된 에러 정정 코드 를 사용하여 NAND 다이들 상에 저장된 파일 데이터로부터 수신된 파일 데이터 에러들을 프로세싱 및/또는 제거할 수 있다. 일부 실시예들에서, 저장 모드에서의 파일 데이터 에러들은 호스트에 의해 파일 데이터 및/또는 명령들을 수신하여 NAND 플래시 메모리 어레이 상에 파일 데이터 및/또는 명령들을 저장하는 것으로부터 SSD 제어기 내의 임의의 파일 데이터 프로세싱 스테이지 또는 플래시 인터페이스에 도입 될 수 있다(예를 들어, 그러나 이에 제한되지 않음). 일부 실시예들에서, 예시적인 에러 정정 시스템은 컴퓨팅 모드에서 동작할 수 있으며, 여기서 NAND 플래 시 메모리 어레이는 메모리 회로 및 로직 및 SSD 제어기의 ECC 메모리 모듈을 갖는 메 모리 회로 및 로직을 활용하여, 에러 없는 특징 데이터(예를 들어, HDV/VSA 벡터)를 인코딩, 디코딩, 검 증하고, 점수를 획득하기 위해 쿼리 벡터와 비교하도록 기계 학습 프로세싱 유닛에 제공한다. 각각의NAND 다이는 HDV 벡터들의 2개의 복사본들, ECC 메모리 모듈로부터의 ECC 기능들, 및 특징 데이터 에러 정정 코드를 인코딩 및 디코딩하기 위해 아래에 설명된 예시적인 에러 정정 스킴을 활용하여, 에러 없는 특징 데이터, 예를 들어, 에러 없는 HDV 벡터들을 제공한다. 예시적인 에러 정정 시스템에서, NAND 다이들은 적어도 2개의 유형들의 데이터: 원시 파일 데이터 및 HDV/VSA 벡터들을 저장한다. 파일 데이터에 대응하는 특징 데이터(예를 들어, HDV 벡터들)는 잡음에 매우 강건할 수 있고, 유사도들을 보존할 수 있고, NAND 다이들로부터 판독될 수 있고 에러 정정 없이 컴퓨팅 될 수 있다. 일부 실시예들에서, HDV 벡터들의 2개의 복사본들은 파일 데이터; 제1 복사본, ECC 코딩이 없는 HDV 및 제2 복사본, SSD 제어기 ECC 인코딩을 갖는 HDV에 대응하는 각각의 NAND 다이 상에 저장될 수 있다. 도시된 바와 같이, ECC 코딩이 없는 HDV 벡터들의 제1 복사본은 기계 학습 프로세싱 유닛에 의 해 사용될 수 있다. 그러나, 회복력에 대한 제한이 있기 때문에, HDV 벡터를 저장하는 블록들은 또한 웨어 레 벨링될 필요가 있다. ECC 코딩을 갖는 HDV 벡터의 제2 복사본은 HDV 벡터의 제1 복사본에서의 에러를 정정하는데 사용될 수 있다. 스크러빙 알고리즘이 ECC 코딩을 갖는 HDV 복사본의 비트 에러율이 미리 정의된 임계치를 초과한 것을 발견할 때, ECC 코딩이 없는 정정된 HDV는 메모리 회로 및 로직에 저장될 수 있고, ECC 코딩을 갖는 HDV 복사본 은 메모리 회로 및 로직상에 재위치될 수 있다. 일부 실시예들에서, 애플리케이션에 따라, VSA 벡터들이 매우 길고 매우 강력할 때, ECC 코딩을 갖는 HDV 벡터들의 제2 복사본에 대한 별개의 스크러빙 알고리즘이 필요 하지 않을 수 있고, 그렇지 않으면, ECC 코딩을 갖는 HDV 벡터들에 대해 별개의 스크러빙 알고리즘이 수행될 수 있다. 메모리 회로 및 로직은 특징 데이터 프로세싱 효율, 예를 들어, 특징 데이터 및 온-다이의 병렬 프로세싱 을 최대화하기 위해 특징 데이터 관리를 수행할 수 있다. 일부 실시예들에서, 메모리 회로 및 로직은 또 한, 대응하는 NAND 다이 상에 저장된 파일 데이터 및 HDV 벡터 데이터를 핸들링하기 위해 각각의 NAND 다 이 당 단일 유닛들로서 NAND 플래시 메모리 어레이에 분산될 수 있다. 게다가, 일부 실시예들에서, 특징 데이터는 NAND 플래시 메모리 어레이의 각각의 NAND 다이에 걸쳐 균등하게 파 티셔닝되고 분산될 수 있다. 추가로, 특징 벡터 데이터는 예를 들어, 가비지 수집과 같은 저장 관리 동작들 동 안 동일한 NAND 다이 내에 재위치될 수 있다. 도 11b는 본 개시내용의 실시예에 따른 도 11a의 예시적인 에러 정정 시스템의 차트이다. 데이터 무결성을 보 장하기 위해, 데이터 스크러빙은 HDV 벡터들(예를 들어, HDV 스크러빙을 사용하여) 및 파일 데이터(예를 들어, 종래의 데이터 스크러빙을 사용하여)에 대해 수행될 수 있다. 도시된 바와 같이, 특징 데이터 상의 HDV 데이터 스크러빙에 대한 시간 당 비트 플립들의 개수는 파일 데이터에 대한 종래의 데이터 스크러빙보다 더 높은 주파 수 또는 종래의 데이터 스크러빙의 주파수의 분율, 예를 들어, 1/6, ¼, 1/3, ½, 2/3의 종래의 스크러빙 시간 에서 수행될 수 있다. 게다가, HDV 스크러빙 및 종래의 스크러빙은 비트 플립들의 미리 결정된 임계치에 도달 하면 트리거될 수 있다. 예를 들어, HDV 임계치에 도달할 때 HDV 스크러빙이 수행될 수 있고, 종래의 임계치에 도달할 때 종래의 스크러빙이 수행될 수 있다. 일부 실시예들에서, 시간/주파수 및 임계치의 조합은 HDV 스크 러빙 또는 종래의 스크러빙 중 적어도 하나를 수행하기 위해 사용될 수 있다. 도시된 바와 같이, HDV 데이터 스크러빙은 파일 데이터의 종래의 스크러빙 시점의 2/3에서 수행될 수 있다. 도 11c는 본 개시내용의 실시예에 따른 도 11a의 예시적인 에러 정정 시스템의 표이다. 파일 데이터 및 특징 데이터 에러 정정이 전술한 바와 같이 도시된다. 파일 데이터 및 특징 데이터는 또한 데이터 스크러빙을 겪어, 단일 정정 가능한 에러가 다수의 정정 불가능한 에러들로 누적될 가능성을 감소시킬 수 있다. 도시된 바와 같 이, SSD 제어기 ECC는 파일 데이터를 검증하기 위해 사용될 수 있고, 종래의 데이터 스크러빙은 예를 들 어, 저장 모드에서 파일 데이터의 데이터 무결성을 유지하기 위해 웨어 레벨링을 위한 LDPC(Low Density Parity Check)가 사용될 수 있다. 종래의 데이터 스크러빙은 에러 정정 기법들이 에러들에 대해 메인 메모리 또는 스 토리지를 주기적으로 검사하고, 이어서 상이한 체크섬들 또는 데이터의 복사본들의 형태의 리던던트 데이터를 사용하여 검출된 에러들을 정정하기 위해 하나 이상의 백그라운드 태스크들을 사용하는 것을 포함할 수 있다. 파일 데이터는 레코드 세트, 테이블 또는 데이터베이스로부터 손상 또는 부정확한 레코드들을 검출 및 정정하고, 데이터의 불완전, 부정확, 정확하지 않거나 무관한 부분들을 식별하고, 이어서 에러, 손상 또는 거친 데이터를 교체, 수정 또는 삭제하는 프로세스를 통해 클린징될 수 있다. 예로서, 예시적인 에러 정정 시스템은 컴퓨팅 모드에 있을 때, 종래의 데이터 스크러빙은 HDV 벡터들의 제1 복사본(즉, ECC 코딩이 없는 HDV, HDV 벡터들)에 대해 필요하지 않을 수 있다. 일부 실시예들에서, 종래의데이터 스크러빙은 ECC 코딩 없이 HDV 벡터들의 제1 복사본에 대한 특징 데이터의 데이터 무결성을 유지하기 위 해 HDV 벡터들의 제1 복사본에 대해 필요에 따라 사용될 수 있다. 추가로, 컴퓨팅 모드에서, SSD 제어기 ECC는 예를 들어, LDPC(Low Density Parity Check)를 사용하여 HDV 벡터들의 제2 복사본(즉, HDV-COPY, ECC 코 딩을 갖는 HDV 벡터들)의 특징 데이터를 검증하는데 사용될 수 있다. 게다가, 특징 데이터 스크러빙 알고리즘 을 사용하는 종래의 데이터 스크러빙 또는 HDV 스크러빙 중 적어도 하나는 예를 들어, 에러, 부정확하거나, 불 완전한, 비어 있거나, 중복되는 특징 벡터 데이터를 정리하기 위해 사용될 수 있다. 일부 실시예들에서, SSD 저장 디바이스가 시맨틱 검색 모드에서 동작할 때, 판독/기록 요청들을 서빙하기 위한 호스트로부터의 요청들은 무시되고, 지연되고, 일부 시맨틱 검색 동작들이 완료된 후에 수행되거나, 모든 시맨틱 검색 동작들이 완료된 후에 수행되도록 큐잉될 수 있거나, 또는 이들의 임의의 조합으로 수행될 수 있다. 따라서, 휘발성 메모리는 파일 데이터 액세스들을 위한 논리-대-물리(L2P) 테이블보다는 데이터 관리 데이터 구조들에 관련된 특징 데이터를 로딩하는데 사용될 수 있다. 게다가, HDV 벡터 데이터 관리는 전 술한 바와 같이 수행될 수 있다. 일부 실시예들에서, 해시값 특징 벡터는 데이터 관리를 단순화하기 위한 해시값 및 그 특징 벡터의 연결일 수 있다. 게다가, SSD 저장 디바이스가 검색 요청(예를 들어, 쿼리)을 수신할 때, SSD 제어기는 특수 검색 커맨드(들)를 생성하고 이들을 각각의 NAND 플래시 다이로 전송할 필요가 있다. SSD 제어기 는 어떤 블록(들)이 특징 벡터 데이터를 포함하는지를 NAND 플래시 다이에 통지할 수 있고, NAND 플래시 다이는 그에 따라 컴퓨팅을 수행해야 한다. 게다가, 각각의 NAND 플래시 다이는 top_k 해시값 = Loop(search(query_vec, plane#, block#, last_page#, last segment#))의 기능을 수행할 수 있다. 도 12는 본 개시내용의 실시예에 따른 에러 정정 시스템들들과 함께 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템 의 예시적인 에러 정정 모드 및 저장 모드의 개략적인 블록도이다. 도시된 바와 같이, 예시적인 컴퓨팅 SSD 시스템은 컴퓨팅 모드에서의 시맨틱 검색 및 저장 모드에서의 원시 파일 데이터 프로세싱을 지원하며, 호스트는 SSD 저장 디바이스에 각각의 명령어들 및 파일 데이터 또는 특징 데이터를 제 공한다. 비휘발성 메모리가 제한되는 일부 실시예들에서, SSD 저장 디바이스는 결과 파일 리트리 브를 달성하기 위해 컴퓨팅 모드와 저장 모드 사이에서 스위칭할 수 있다. 게다가, 판독/기록 요청들을 서빙하 기 위한 호스트로부터의 요청들은 무시되고, 지연되고, 일부 시맨틱 검색 동작들이 완료된 후에 수행되거 나, 모든 시맨틱 검색 동작들이 완료된 후에 수행되도록 큐잉될 수 있거나, 또는 이들의 임의의 조합으로 수행 될 수 있다. 따라서, 휘발성 메모리는 파일 데이터 액세스들을 위한 논리-대-물리(L2P) 테이블보다는 데 이터 관리 데이터 구조들에 관련된 특징 데이터를 로딩하는데 사용될 수 있다. 단계 1: 컴퓨팅 모드에서, 비휘발성 메모리(예를 들어, DRAM)는 테이블 X에 의해 사용될 수 있고, 쿼리 는 SSD 저장 디바이스로 전송될 수 있고, 프로세싱될 수 있고(예를 들어, 기계 학습 프로세싱 유닛 (1021/1121)), 이어서 결과 또는 해시는 시맨틱 검색 요청을 위해 호스트로 반환될 수 있다. 단계 2: 저장 모드에서, 비휘발성 메모리(예컨대, DRAM)는 L2P 테이블 매핑을 위해 사용될 수 있고, 데이 터 요청은 SSD 저장 디바이스로 전송될 수 있고, (예컨대, SSD 제어기(1026/1126)에 의해) 프로세 싱될 수 있고, 이어서 파일 데이터는 파일 검색/판독/기록/액세스 요청을 위해 호스트로 반환될 수 있다. 도 13은 본 개시내용의 실시예에 따른 에러 정정 시스템들과 함께 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템 의 다른 예시적인 에러 정정 모드 및 저장 모드의 개략적인 블록도이다. 일부 실시예들에서, 비휘발성 메모리가 저장 및 컴퓨팅 모드들 둘 모두에 충분할 수 있는 경우, 저장 및 컴퓨팅 동작들은 별개의 모드 들을 요구하지 않고 동시에 또는 병렬로 수행될 수 있다. 예를 들어, 비휘발성 메모리(예를 들어, DRAM)는 테이블 X에 의해 사용될 수 있고, 쿼리는 SSD 저 장 디바이스로 전송될 수 있고, 프로세싱될 수 있고(예를 들어, 기계 학습 프로세싱 유닛(1021/1121)), 이어서 결과 또는 해시는 시맨틱 검색 요청을 위해 호스트로 반환될 수 있다. 추가로, 병렬로, 비 휘발성 메모리(예컨대, DRAM)는 L2P 테이블 매핑을 위해 사용될 수 있고, 데이터 요청은 SSD 저장 디바이스로 전송될 수 있고, (예컨대, SSD 제어기(1026/1126)에 의해) 프로세싱될 수 있고, 이어서 파일 데이터는 파일 검색/판독/기록/액세스 요청을 위해 호스트로 반환될 수 있다. 추가로, 하이퍼스케 일 또는 스토리지 어레이가 사용되는 일부 실시예들에서, 시맨틱 검색 및 파일 데이터는 병렬로 수행될 수 있고, 파일 데이터는 SSD 저장 디바이스로부터의 파일 복제본과 함께 종래의 SSD로부터 리트리브될 수 있 다.도 14를 참조하면 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템에서 예시적인 에러 정정 방법을 활용하기 위한 프로세스를 묘사하는 흐름도이다. 프로세스는 원시 파일 데이터를 하 나 이상의 메모리 구조들에 저장함으로써 시작될 수 있다(블록 1410). 프로세스는 원시 파일 데이터에 대응하는 특징 데이터를 대응하는 하나 이상의 메모리 구조들에 저장할 수 있다(블록 1415). 프로세스는 하나 이상의 메모리 구조들 중 적어도 하나로부터 특징 데이터를 로딩할 수 있고, 특징 데이터는 조밀한 특징 벡터들 또는 초차원 벡터들 중 적어도 하나를 포함한다(블록 1420). 프로세스는 특징 데이터로부터 하나 이상의 데이터베이스들을 생성할 수 있다(블록 1425). 프로세스는 하나 이상의 메모리 구조들 중 적어도 하나로부터 원시 파일 데이터를 로딩할 수 있다(블록 1430). 프로세스는 특징 데이터를 저장하고 액세스 하기 위한 에러 정정 알고리즘을 활용할 수 있다(블록 1435). 도 15를 참조하면 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템에서 예시적인 에러 정정 방법을 활용하기 위한 프로세스를 묘사하는 흐름도이다. 프로세스는 하나 이상의 메모리 구 조들에 저장된 원시 파일 데이터를 리트리브하기 위해 기계 학습 모델을 사용하여 쿼리를 프로세싱함으로써 시 작될 수 있다(블록 1510). 프로세스는 하나 이상의 메모리 구조들에 저장된 특징 데이터로부터 하나 이 상의 데이터베이스들을 생성할 수 있고, 특징 데이터는 조밀한 특징 벡터들 또는 초차원 벡터들 중 적어도 하나 를 포함한다(블록 1515). 프로세스는 하나 이상의 메모리 구조들로부터 하나 이상의 데이터베이스 및 원 시 파일 데이터를 로딩할 수 있다(블록 1525). 프로세스는 쿼리에 대한 응답을 획득하기 위해 원시 파일 데이터 및 하나 이상의 데이터베이스들을 프로세싱할 수 있다(블록 1525). 본원에 도시되고 상세히 설명되는 정보는 본 개시내용의 전술된 목적, 본 개시내용의 현재 바람직한 실시예를 완전히 달성할 수 있으며, 따라서 본 개시내용에 의해 광범위하게 고려되는 주제를 대표한다. 본 개시내용의 범주는 당업자에게 명백하게 될 수 있는 다른 실시예들을 완전히 포괄하며, 이에 따라, 첨부된 청구범위 이외의 것에 의해 제한되지 않는다. 단수형으로 이루어진 요소에 대한 임의의 언급은 명시적으로 그렇게 언급되지 않 는 한, \"하나 및 오직 하나\"를 의미하는 것이 아니라 오히려 \"하나 이상\"을 의미하도록 의도된다 당업자에 의해 고려되는 바와 같은 전술된 바람직한 실시예 및 추가적인 실시예들의 요소들에 대한 모든 구조적 및 기능적 등 가물들은 본 명세서에 명백히 참고로 포함되며, 본 청구범위에 의해 포괄되도록 의도된다. 게다가, 본 개시내용에 의해 해결하고자 하는 각각의 그리고 모든 문제를 해결하는 시스템 또는 방법에 대한 요 건은 존재하지 않으며, 그러한 문제들에 대한 해결책들은 본 청구범위에 의해 포괄된다. 게다가, 본 개시내용 에서의 요소, 구성요소, 또는 방법 단계는 그 요소, 구성요소, 또는 방법 단계가 청구범위에 명시적으로 언급되 어 있는지에 상관없이 대중에 전용되는 것으로 의도되지 않는다. 당업자에게 명백할 수 있는 바와 같이, 첨부 된 청구범위에 기재된 바와 같이, 본 개시내용의 사상 및 범주로부터 벗어나지 않고 형태, 재료, 가공물, 및 제 조 재료 세부사항에 있어서의 다양한 변화 및 수정이 이루어질 수 있으며, 또한 본 개시내용에 의해 포괄된다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10a 도면10b 도면10c 도면11a 도면11b 도면11c 도면12 도면13 도면14 도면15"}
{"patent_id": "10-2024-7041178", "section": "도면", "subsection": "도면설명", "item": 1, "content": "본 개시내용의 여러 실시예들의 상기 및 다른 양태들, 특징들, 및 장점들은 도면들의 하기 여러 도면들과 연계 하여 제시된 하기 설명으로부터 더욱 명백해질 것이다. 도 1은 본 개시내용의 실시예에 따른, 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템에 적합한 저장 시스템을 갖는 예시적인 호스트-컴퓨팅 디바이스의 개략적인 블록도이다. 도 2는 본 개시내용의 실시예에 따른, 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템에 적합한 예시적인 저장 디바 이스의 개략적인 블록도이다. 도 3은 본 개시내용의 실시예에 따라 병렬로 감지 또는 프로그래밍되는, 예를 들어 NAND 구성으로 조직되는, 메 모리 셀들의 페이지의 개념적인 예시이다. 도 4는 본 개시내용의 실시예에 따른, 시맨틱 검색을 지원하는 예시적인 컴퓨팅 SSD 시스템의 개략적인 블록도 이다. 도 5는 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템의 예시적인 기계 학습 프로세 싱 유닛의 개략적인 블록도이다. 도 6은 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템의 예시적인 기계 학습 프로세 싱 유닛의 개략적인 블록도이다. 도 7은 본 개시내용의 실시예에 따라 시맨틱 검색을 지원하는 예시적인 컴퓨팅 SSD 시스템을 활용하기 위한 프 로세스를 묘사하는 흐름도이다.도 8은 본 개시내용의 실시예에 따라 시맨틱 검색을 지원하는 예시적인 컴퓨팅 SSD 시스템을 활용하기 위한 프 로세스를 묘사하는 흐름도이다. 도 9는 본 개시내용의 실시예에 따른 예시적인 기계 학습 프로세스의 개략적인 블록도이다. 도 10a는 본 개시내용의 실시예에 따른 예시적인 에러 정정 시스템의 개략적인 블록도이다. 도 10b는 본 개시내용의 실시예에 따른 도 10a의 예시적인 에러 정정 시스템의 차트이다. 도 10c는 본 개시내용의 실시예에 따른 도 10a의 예시적인 에러 정정 시스템의 표이다. 도 11a는 본 개시내용의 실시예에 따른 예시적인 에러 정정 시스템의 개략적인 블록도이다. 도 11b는 본 개시내용의 실시예에 따른 도 11a의 예시적인 에러 정정 시스템의 차트이다. 도 11c는 본 개시내용의 실시예에 따른 도 11a의 예시적인 에러 정정 시스템의 표이다. 도 12는 본 개시내용의 실시예에 따른 에러 정정 시스템들과 함께 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템의 예시적인 에러 정정 모드 및 저장 모드의 개략적인 블록도이다. 도 13은 본 개시내용의 실시예에 따른 에러 정정 시스템들과 함께 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템의 다른 예시적인 에러 정정 모드 및 저장 모드의 개략적인 블록도이다. 도 14는 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템에서 예시적인 에러 정정 방법 을 활용하기 위한 프로세스를 묘사하는 흐름도이다. 도 15는 본 개시내용의 실시예에 따른 시맨틱 검색을 지원하는 컴퓨팅 SSD 시스템에서 예시적인 에러 정정 방법 을 활용하기 위한 프로세스를 묘사하는 흐름도이다. 대응 참조 문자들은 도면들의 여러 도면들에 걸쳐 대응하는 구성요소들을 나타낸다. 여러 도면들의 요소들은 단순성과 명확성을 위해 예시되었으며 반드시 축척에 맞게 도시되지 않았다. 예를 들어, 도면들의 요소들 중 일부의 치수들은 현재 개시된 다양한 실시예들의 이해를 용이하게 하기 위해 다른 요소들에 비해 강조될 수 있 다. 게다가, 상용화 가능한 실시예에서 유용하거나 필요한 일반적이지만 잘 이해되는 요소들은 본 개시내용의 이러한 다양한 실시예들의 보는 것에 대한 방해를 줄이기 위해 종종 묘사되지 않는다."}
