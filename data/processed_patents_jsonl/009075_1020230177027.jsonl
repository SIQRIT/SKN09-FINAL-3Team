{"patent_id": "10-2023-0177027", "section": "특허_기본정보", "subsection": "특허정보", "content": {"공개번호": "10-2025-0026721", "출원번호": "10-2023-0177027", "발명의 명칭": "컴퓨팅 시스템 및 컴퓨팅 시스템의 동작 방법", "출원인": "삼성전자주식회사", "발명자": "염정호"}}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_1", "content": "복수의 프로세스 각각에 대한 프로세스 데이터를 복수의 논리 어드레스에 분배하여 할당하고, 상기 복수의 논리어드레스 각각에 대응하는 프로세스의 구동 여부를 지시하는 유효 비트를 결정하며, 상기 유효 비트 및 상기 유효 비트에 대응하는 논리 어드레스를 포함하는 업데이트 정보를 생성하는 호스트, 및상기 호스트와 연결되고, 상기 호스트로부터 상기 업데이트 정보를 수신하는 스토리지 장치를 포함하는 컴퓨팅 시스템."}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_2", "content": "제1항에 있어서, 상기 스토리지 장치는, 복수의 비휘발성 메모리를 포함하고 상기 업데이트 정보에 기초하여 상기 복수의 비휘발성 메모리에 대해 가비지 컬렉션을 수행하는, 컴퓨팅 시스템."}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_3", "content": "제1항에 있어서, 상기 호스트는 상기 유효 비트가 변동 시에 상기 업데이트 정보를 생성하는, 컴퓨팅 시스템."}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_4", "content": "제1항에 있어서, 상기 호스트와 CXL 인터페이스를 통해 연결된 CXL 장치를 더 포함하고, 상기 CXL 장치는 상기 스토리지 장치, 및 상기 복수의 논리 어드레스 중 제1 유형의 논리 어드레스를 상기 스토리지 장치에 대한 스토리지 어드레스에 매핑하는 CXL 컨트롤러를 포함하는, 컴퓨팅 시스템."}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_5", "content": "제4항에 있어서, 상기 CXL 장치는, 상기 복수의 논리 어드레스 중 제2 유형의 논리 어드레스에 대응하는 휘발성 메모리를 포함하는 CXL 메모리를 더 포함하고, 상기 CXL 컨트롤러는 상기 제2 유형의 논리 어드레스를 상기 CXL 메모리에 대한CXL 메모리 어드레스에 매핑하는, 컴퓨팅 시스템."}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_6", "content": "제5항에 있어서, 상기 컴퓨팅 시스템은 상기 호스트에 연결되어 상기 복수의 논리 어드레스 중 제3 유형의 논리 어드레스에 대응하는 휘발성 메모리를 포함하는 호스트 메모리를 더 포함하는, 컴퓨팅 시스템."}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_7", "content": "제6항에 있어서,상기 업데이트 정보는 상기 제1 유형의 논리 어드레스, 상기 제2 유형의 논리 어드레스, 및 상기 제3 유형의 논리 어드레스 중 상기 제1 유형의 논리 어드레스에 대응하는 유효 비트를 포함하는, 컴퓨팅 시스템."}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_8", "content": "제1항에 있어서, 공개특허 10-2025-0026721-3-상기 호스트는 상기 프로세스 데이터의 입출력 속도 및 정합성의 정도에 기초하여 상기 프로세스 데이터를 상기복수의 논리 어드레스에 분배하여 할당하는, 컴퓨팅 시스템."}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_9", "content": "복수의 프로세스 각각에 대한 프로세스 데이터를 복수의 논리 어드레스에 분배하여 할당하는 단계,상기 복수의 논리 어드레스 각각에 대응하는 프로세스의 구동 여부를 지시하는 유효 비트를 할당하는 단계, 상기 유효 비트 및 상기 유효 비트에 대응하는 논리 어드레스를 포함하는 업데이트 정보를 생성하는 단계, 상기 복수의 논리 어드레스 중 제1 유형의 논리 어드레스를 비휘발성 메모리를 포함하는 스토리지 장치에 대한스토리지 어드레스에 매핑하는 단계, 및상기 업데이트 정보에 기초하여 프로세스가 구동하지 않음을 지시하는 유효 비트를 갖는 논리 어드레스에 대응하는 스토리지 어드레스에 대해 가비지 컬렉션을 수행하는 단계를 포함하는 컴퓨팅 시스템의 구동 방법."}
{"patent_id": "10-2023-0177027", "section": "청구범위", "subsection": "청구항", "claim_number": "청구항_10", "content": "복수의 논리 어드레스 중 제1 유형의 논리 어드레스에 대응하는 비휘발성 메모리를 포함하고, 상기 제1 유형의논리 어드레스에 대응하는 프로세스의 구동 여부를 지시하는 유효 비트를 수신하고, 상기 유효 비트에 기초하여상기 비휘발성 메모리에 대한 가비지 컬렉션을 수행하는 CXL 스토리지, 및상기 복수의 논리 어드레스 중 제2 유형의 논리 어드레스에 대응하는 휘발성 메모리를 포함하는 CXL 메모리를 포함하는 CXL 장치."}
{"patent_id": "10-2023-0177027", "section": "발명의_설명", "subsection": "요약", "paragraph": 1, "content": "일 실시예에 따른 컴퓨팅 시스템은 복수의 프로세스 각각에 대한 프로세스 데이터를 복수의 논리 어드레스에 분 배하여 할당하고, 복수의 논리 어드레스 각각에 대응하는 프로세스의 구동 여부를 지시하는 유효 비트를 결정하 며, 유효 비트 및 유효 비트에 대응하는 논리 어드레스를 포함하는 업데이트 정보를 생성하는 호스트, 및 호스트 로부터 업데이트 정보를 수신하는 스토리지 장치를 포함한다."}
{"patent_id": "10-2023-0177027", "section": "발명의_설명", "subsection": "기술분야", "paragraph": 1, "content": "본 개시는 컴퓨팅 시스템 및 컴퓨팅 시스템의 동작 방법에 관한 것이다."}
{"patent_id": "10-2023-0177027", "section": "발명의_설명", "subsection": "배경기술", "paragraph": 1, "content": "컴퓨팅 시스템은 사용자에게 다양한 IT 서비스를 제공할 수 있다. 최근 인공지능 및 빅데이터를 활용하는 응용 분야가 늘어나면서 사용자에게 다양한 IT 서비스를 제공하기 위해, 컴퓨팅 시스템에서 처리되는 데이터의 양이 증가하고 있다. 컴퓨팅 시스템의 메모리 용량의 물리적 한계를 극복하기 위하여 다양한 기술들이 개발되고 있 다. 특히, CXL(Compute Express Link)은 고성능 컴퓨팅 시스템에서 CPU와 함께 사용되는 가속기, 메모리, 저 장 장치 등을 보다 효율적으로 활용하기 위해 새롭게 제안된 인터페이스이다."}
{"patent_id": "10-2023-0177027", "section": "발명의_설명", "subsection": "해결하려는과제", "paragraph": 1, "content": "본 개시는 컴퓨팅 시스템에 저장된 데이터를 효율적으로 관리하기 위한 것이다."}
{"patent_id": "10-2023-0177027", "section": "발명의_설명", "subsection": "과제의해결수단", "paragraph": 1, "content": "일 실시예에 따른 컴퓨팅 시스템은 복수의 프로세스 각각에 대한 프로세스 데이터를 복수의 논리 어드레스에 분 배하여 할당하고, 복수의 논리 어드레스 각각에 대응하는 프로세스의 구동 여부를 지시하는 유효 비트를 결정하 며, 유효 비트 및 유효 비트에 대응하는 논리 어드레스를 포함하는 업데이트 정보를 생성하는 호스트, 및 호스 트로부터 업데이트 정보를 수신하는 스토리지 장치를 포함한다. 일 실시예에 따른 컴퓨팅 시스템의 구동 방법은 복수의 프로세스 각각에 대한 프로세스 데이터를 복수의 논리 어드레스에 분배하여 할당하는 단계, 복수의 논리 어드레스 각각에 대응하는 프로세스의 구동 여부를 지시하는 유효 비트를 할당하는 단계, 유효 비트 및 유효 비트에 대응하는 논리 어드레스를 포함하는 업데이트 정보를 생성하는 단계, 복수의 논리 어드레스 중 제1 유형의 논리 어드레스를 비휘발성 메모리를 포함하는 스토리지 장치 에 대한 스토리지 어드레스에 매핑하는 단계, 및 업데이트 정보에 기초하여 프로세스가 구동하지 않음을 지시하 는 유효 비트를 갖는 논리 어드레스에 대응하는 스토리지 어드레스에 대해 가비지 컬렉션을 수행하는 단계를 포 함한다. 일 실시예에 따른 CXL 장치는 복수의 논리 어드레스 중 제1 유형의 논리 어드레스에 대응하는 비휘발성 메모리 를 포함하고, 제1 유형의 논리 어드레스에 대응하는 프로세스의 구동 여부를 지시하는 유효 비트를 수신하고, 유효 비트에 기초하여 비휘발성 메모리에 대한 가비지 컬렉션을 수행하는 CXL 스토리지, 및 복수의 논리 어드레 스 중 제2 유형의 논리 어드레스에 대응하는 휘발성 메모리를 포함하는 CXL 메모리를 포함한다."}
{"patent_id": "10-2023-0177027", "section": "발명의_설명", "subsection": "발명을실시하기위한구체적인내용", "paragraph": 1, "content": "아래에서는 첨부한 도면을 참고로 하여 본 발명의 실시예에 대하여 본 발명이 속하는 기술 분야에서 통상의 지 식을 가진 자가 용이하게 실시할 수 있도록 상세히 설명한다. 그러나 본 발명은 여러 가지 상이한 형태로 구현 될 수 있으며 여기에서 설명하는 실시예에 한정되지 않는다. 그리고 도면에서 본 발명을 명확하게 설명하기 위해서 설명과 관계없는 부분은 생략하였으며, 명세서 전체를 통 하여 유사한 부분에 대해서는 유사한 도면 부호를 붙였다. 도면을 참고하여 설명한 흐름도에서, 동작 순서는 변 경될 수 있고, 여러 동작들이 병합되거나, 어느 동작이 분할될 수 있고, 특정 동작은 수행되지 않을 수 있다. 또한, 단수로 기재된 표현은 \"하나\" 또는 \"단일\" 등의 명시적인 표현을 사용하지 않은 이상, 단수 또는 복수로 해석될 수 있다. 제1, 제2 등과 같이 서수를 포함하는 용어는 다양한 구성요소를 설명하는 데 사용될 수 있지만, 구성요소는 이러한 용어에 의해 한정되지는 않는다. 이들 용어는 하나의 구성요소를 다른 구성요소로부 터 구별하는 목적으로 사용될 수 있다. 도 1은 일 실시예에 따른 컴퓨팅 시스템을 나타낸 블록도이다. 도 1을 참조하면, 컴퓨팅 시스템은 호스트, 호스트 메모리, 및 적어도 하나의 CXL(compute express link) 장치를 포함할 수 있다. 어떤 실시예에서, 컴퓨팅 시스템은 개인용 컴퓨팅(personal computer), 랩탑(laptop) 컴퓨팅, 서버 (server), 미디어 재생기, 디지털 카메라 등과 같은 사용자 장치들, 또는 내비게이션(navigation), 블랙 박스, 차량용 전장 장치 등과 같은 차량용 장비(automotive device)에 포함될 수 있다. 또는, 컴퓨팅 시스템은 휴대용 통신 단말기(mobile phone), 스마트폰(smart phone), 태블릿 PC(tablet personal computer), 웨어러블 기기, 헬스케어 기기 또는 IOT(internet of things) 기기와 같은 모바일(mobile) 시스템일 수 있다. 호스트는 컴퓨팅 시스템의 제반 동작을 제어할 수 있다. 일 실시예에서, 호스트는 CPU(central processing unit), GPU(Graphics Processing Unit), NPU(Neural Processing Unit), DPU(Data Processing Unit) 등과 같은 다양한 프로세서들 중 하나일 수 있다. 일 실시예에서, 호스트는 싱글 코어 프로세서 또 는 멀티 코어 프로세서를 포함할 수 있다. 어떤 실시예에서, 호스트는 복수의 프로세스를 구동할 수 있다. 호스트는 복수의 프로세스를 구동하 는 데 필요한 데이터들을 호스트 메모리 및 적어도 하나의 CXL 장치에 분배하여 저장할 수 있다. 이하에서, 복수의 프로세스를 구동하는 데 필요한 데이터를 프로세스 데이터라고 한다. 구체적으로, 호스트 는 빠른 입출력 속도를 필요로 하는 경우에는 프로세스 데이터를 호스트 메모리에 저장할 수 있다. 호스트 는 정합성(consistency)이 중요한 경우에는 프로세스 데이터를 적어도 하나의 CXL 장치에 저장할 수 있다. 즉, 호스트는 복수의 CXL 스토리지, 복수의 CXL 메모리, 및 호스트 메모리 각각에 데이터를 분배하여 저장할 수 있다. 어떤 실시예에서, 호스트가 복수의 프로세스를 구동하는 중에 일부 프로세스가 종료될 수 있다. 프로세스 종료 시, 종료된 프로세스에 대응하는 데이터를 무효 데이터라고 한다. 또한, 구동 중인 프로세스에 필요한 데 이터를 유효 데이터라고 한다. 호스트는 복수의 CXL 스토리지, 복수의 CXL 메모리, 및 호스트 메모리 각각의 어드레스에 대한 유효 비트를 결정할 수 있다. 유효 비트는 해당 어드레스에 저장된 프로세 스 데이터가 무효 데이터인지 또는 유효 데이터인지를 지시할 수 있다. 즉, 유효 비트는 어드레스에 대응하는 프로세스의 구동 여부를 지시할 수 있다. 어떤 실시예에서, 유효 비트가 1인 경우는 호스트에 의해 프로세 스가 구동 중임을 지시하고, 유효 비트가 0인 경우는 호스트에 의해 프로세스가 종료됨을 지시할 수 있다. 어떤 실시예에서, 호스트는 유효 비트가 변동하는 경우에 업데이트 정보를 생성할 수 있다. 업데이트 정보 는 변동된 유효 비트 및 변동된 유효 비트에 대응하는 어드레스를 포함할 수 있다. 예를 들어, 호스트는 구동 중인 프로세스가 종료하는 경우에 업데이트 정보를 생성할 수 있다. 호스트는 업데이트 정보를 CXL 장치(130a)에 전송할 수 있다. 어떤 실시예에서, 호스트는 업데이트 정보를 호스트 메모리에 저장할 수 있다. 어떤 실시예에서, 호스트 메모리와 CXL 메모리(133a)는 별도의 일관성(coherency) 인터페이스를 통해 연결되어 있을 수 있다. 호스트 메모리와 CXL 메모리(133a) 간 일관성이 유지되는 경우에, 호스트 는 업데이트 정보를 CXL 장치(130a)에 전송하지 않더라도 CXL 장치(130a)는 CXL 메모리(133a) 내의 업데이 트 정보를 참고할 수 있다. 한편, 호스트는 복수의 CXL 스토리지 각각의 어드레스에 대해서만 유효 비트를 결정할 수도 있다. 이 경우에, 호스트는 복수의 CXL 스토리지 각각의 어드레스에 대한 유효 비트가 변동되는 경우에 업데이 트 정보를 생성할 수도 있다. 호스트 메모리는 컴퓨팅 시스템의 메인 메모리 또는 시스템 메모리로서 사용될 수 있다. 일 실시예에 서, 호스트 메모리는 DRAM(dynamic random access memory) 장치일 수 있으며, DIMM(dual in-line memory module)의 폼 팩터를 가질 수 있다. 그러나, 본 발명의 범위가 이에 한정되는 것은 아니며, 메모리는 플래 시 메모리, PRAM, RRAM, MRAM 등과 같은 비휘발성 메모리를 포함할 수 있다. 호스트 메모리는 DDR(Double Data Rate) 인터페이스를 통해 호스트와 직접 통신할 수 있다. 일 실시 예에서, 호스트는 호스트 메모리를 제어하도록 구성된 메모리 컨트롤러를 포함할 수 있다. 그러나 본 발명의 범위가 이에 한정되는 것은 아니며, 호스트 메모리는 다양한 인터페이스를 통해 호스트와 통 신할 수 있다. 적어도 하나의 CXL 장치는 개별적인 메모리 장치 또는 메모리 모듈로 구현될 수 있다. 적어도 하나의 CXL 장치 각각은 서로 다른 물리 포트들을 통해 CXL 인터페이스와 연결될 수 있다. CXL 장치(130a)는 CXL 컨트롤러(131a), CXL 스토리지(132a), 및 CXL 메모리(133a)를 포함할 수 있다. CXL 컨트롤러(131a)는 ASIC(application specific integrated circuit) 및/또는 FPGA(field-programmable gate array) 구현을 위해 설계된 IP(intellectual property) 회로를 포함할 수 있다. 다양한 실시예에서, CXL 컨트롤러는 CXL 프로토콜(예컨대, CXL 2.0 프로토콜 또는 임의의 다른 버전)을 지원하도록 구현될 수 있다. CXL 컨트롤러는 CXL 패킷과 CXL 메모리(133a)의 메모리 인터페이스의 신호들, CXL 패킷과 CXL 스토 리지의 메모리 인터페이스의 신호들을 서로 변환할 수 있다. 예를 들어, CXL 컨트롤러(131a)는 CXL 인터페 이스를 통해 호스트로부터 수신한 논리 어드레스를 CXL 어드레스로 변환할 수 있다. 이 때, CXL 어드 레스는 CXL 메모리(133a)에 대한 CXL 메모리 어드레스 및 CXL 스토리지(132a)에 대한 CXL 스토리지 어드레스를 포함할 수 있다. CXL 어드레스는 CXL 컨트롤러(131a)에 의해 관리되는 어드레스일 수 있다. 어드레스 매핑 동작은 호스트에 의해 관리되는 논리 어드레스 및 CXL 장치(130a) 내의 CXL 메모리(133a)의 어드레스 또는 CXL 스토리지(132a)의 어드레스 사이를 변환하거나 또는 매핑하는 동작일 수 있다. 예를 들어, CXL 컨트롤러(131a)는 호스트로부터 전달된 CXL 패킷이 CXL 스토리지(132a) 또는 CXL 메모리 (133a)에 저장되도록 CXL 스토리지(132a) 또는 CXL 메모리(133a)를 제어할 수 있다. 구체적으로, CXL 컨트롤러 (131a)는 호스트로부터 수신한 데이터를 변환하여 CXL 스토리지(132a) 또는 CXL 메모리(133a)에 저장하거나 CXL 스토리지(132a) 또는 CXL 메모리(133a)에 저장된 데이터를 변환하여 호스트에 전송할 수도 있다. CXL 스토리지(132a)는 CXL 컨트롤러(131a)로부터 수신한 CXL 스토리지 어드레스에 데이터를 저장할 수 있다. CXL 스토리지(132a)와 관련하여 도 2를 함께 참조한다. 도 2는 일 실시예에 따른 CXL 스토리지를 나타낸 블록도이다. 도 2에 도시된 바와 같이, CXL 스토리지(132a)는 스토리지 컨트롤러, 및 비휘발성 메모리(NVM)를 포 함할 수 있다. CXL 스토리지(132a)는 CXL 컨트롤러(131a)의 제어 신호에 응답하여 데이터를 저장하거나 또는 데 이터를 처리할 수 있다. 스토리지 컨트롤러는 CXL 스토리지(132a)의 동작을 제어할 수 있다. 예를 들어, 스토리지 컨트롤러는 CXL 컨트롤러(131a)로부터 수신한 제어 신호에 응답하여 비휘발성 메모리에 어드레스(ADDR), 커맨드(CMD), 제어 신호(CTRL) 등을 제공할 수 있다. 즉, 스토리지 컨트롤러는 비휘발성 메모리에 신호들을 제공하 여, 비휘발성 메모리에 데이터를 프로그램하거나, 비휘발성 메모리로부터 데이터를 독출할 수 있다. 또한, 스토리지 컨트롤러와 비휘발성 메모리는 데이터(DATA)를 주고받을 수 있다. 구체적으로, 스토리지 컨트롤러는 프로세서, FTL(flash translation layer), 버퍼 메모리 , CXL 인터페이스, 메모리 인터페이스 등을 포함할 수 있다. 프로세서는 스토리지 컨트롤러의 전반적인 동작을 제어할 수 있다. 프로세서는 FTL에 로딩 된 펌웨어를 구동하여 스토리지 컨트롤러를 제어할 수 있다. 어떤 실시예에서, 프로세서는 중앙처리 장치(Central Processing Unit, CPU), 컨트롤러(Controller), 또는 주문형 반도체(Application Specific Integrated Circuit, ASIC) 등을 포함할 수 있다. 프로세서는 스토리지 컨트롤러에서 구동되는 다양한 펌웨어 또는 소프트웨어를 구동할 수 있다. 프로 세서는 버퍼 메모리를 프로세서의 동작 메모리로서 사용할 수 있다. 또한, 프로세서는 비 휘발성 메모리를 프로세서의 동작 메모리로서 사용될 수도 있다. 플래시 변환 레이어(flash transition layer, FTL)는 비휘발성 메모리의 데이터 프로그램, 데이터 읽기, 및 서브 블록 및/또는 블록 소거 동작 등을 관리하는 펌웨어 또는 소프트웨어를 포함할 수 있다. FTL의 펌웨어는 프로세서에 의해 실행될 수 있다. 어떤 실시예에서, FTL은 비휘발성 메모리를 효율적으로 사용하기 위한 다양한 유지 관리 동작들을 수 행할 수 있다. 구체적으로, FTL은 어드레스 매핑(address mapping), 가비지 컬렉션(garbage collection) 과 같은 여러 기능을 수행할 수 있다. FTL은 CXL 컨트롤러(131a)로부터 수신한 CXL 스토리지 어드레스를 비휘발성 메모리 내에 데이터를 실 제로 저장하는 데 사용되는 물리적 어드레스(physical address)로 바꾸는 어드레스 매핑 동작을 수행할 수 있다. 구체적으로, FTL은 어드레스 매핑 테이블(address mapping table)을 사용하여 CXL 컨트롤러(131a) 로부터의 CXL 스토리지 어드레스와 비휘발성 메모리의 물리적 어드레스를 매핑할 수 있다. 어드레스 매핑 동작은 CXL 컨트롤러(131a)에 의해 관리되는 CXL 스토리지 어드레스 및 비휘발성 메모리의 어드레스 사이 를 변환하거나 또는 매핑하는 동작일 수 있다. FTL은 비휘발성 메모리 내에서 사용 가능한 용량을 확보하기 위한 가비지 컬렉션(garbage collection)을 수행할 수 있다. 가비지 컬렉션 동작은 비휘발성 메모리의 블록의 유효한 데이터를 새로운 블록에 복사하고, 기존 블록을 소거(erase)하여 기존 블록을 재사용할 수 있도록 하는 동작일 수 있다. 즉, FTL이 무효화된 페이지들을 제거하고, 유효한 데이터가 프로그램되어 있는 페이지들만 합치는 작업을 가비 지 컬렉션이라고 한다. 비휘발성 메모리는 덮어쓰기가 불가능하므로, 호스트로부터 데이터가 프로그 램되어 있는 페이지에 새로운 데이터를 프로그램하라는 요청을 수신하면, 스토리지 컨트롤러는 비휘발성 메모리의 새로운 페이지에 새로운 데이터를 프로그램할 수 있다. 이 때, 기존에 데이터가 프로그램되어 있 던 페이지는 무효화될 수 있다. 플래시 메모리에 데이터가 계속적으로 라이트됨에 따라, 유효한 데이터가 플래 시 메모리의 전체에 걸쳐서 산재할 수 있고, FTL은 데이터 프로그램이 가능한 저장 공간, 즉 프리(free) 블록을 확보하기 위해 가비지 컬렉션을 수행할 수 있다. 한편, CXL 스토리지(132a)는 호스트에서 종료된 프로세스에 대한 정보를 알 수 없다. 이에 따라, CXL 스토 리지(132a)는 무효 데이터를 포함하는 페이지에 대해서도 가비지 컬렉션을 수행할 수 있다. 무효 데이터에 대한 가비지 컬렉션 수행은 CXL 스토리지(132a)의 내구성(Endurance) 및 성능(Quality of Service, QoS) 저하를 야기할 수 있다. 한편, 일 실시예에 따른 호스트는 무효 데이터가 저장된 어드레스에 대응하는 유효 비트를 변경할 수 있다. 호스트는 변경된 유효 비트에 대응하는 어드레스 및 변경된 유효 비트를 포함한 업데이트 정보를 생성할 수 있다. 호스트는 CXL 스토리지(132a)에 업데이트 정보를 전송할 수 있다. FTL은 업 데이트 정보 내의 유효 비트에 기초하여 가비지 컬렉션을 수행할 수 있다. 구체적으로, FTL은 유효 데이터 를 포함하는 페이지에 대해서만 가비지 컬렉션을 수행하고, 무효 데이터를 포함하는 페이지는 제거할 수 있다. 이에 따라, CXL 스토리지(132a)의 성능(QoS)이 향상되고, 내구성이 향상될 수 있다. 어떤 실시예에서, 호스트는 생성한 업데이트 정보를 호스트 메모리에 저장할 수 있다. 호스트 메모리 와 CXL 메모리(133a) 간의 일관성이 유지되는 경우에, CXL 스토리지(132a)는 CXL 메모리(133a) 내의 업데 이트 정보 내의 유효 비트에 기초하여 가비지 컬렉션을 수행할 수도 있다. 어떤 실시예에서, FTL은 비휘발성 메모리 내에서 사용 가능한 메모리 영역이 미리 설정된 가비지 컬 렉션 레벨을 초과한 경우 가비지 컬렉션 동작을 수행할 수 있다. 가비지 컬렉션 레벨은 FTL이 가비지 컬렉 션의 개시를 결정하기 위해 설정된 임계값일 수 있다. 어떤 실시예에서, 가비지 컬렉션 동작은 블록 단위 뿐만 아니라 서브 블록 단위로 수행될 수 있다. 어떤 실시예에서, FTL은 일정 주기로 가비지 컬렉션 동작을 수 행할 수 있다. 어떤 실시예에서, FTL은 호스트로부터 트림(trim) 커맨드를 수신할 수 있다. 트림 커맨드는 CXL 스토 리지(132a)의 특정 영역에 존재하는 데이터가 더 이상 사용되지 않음을 CXL 스토리지(132a)에 알리는 커맨드일 수 있다. FTL은 호스트로부터 트림 명령을 수신하는 것에 응답하여 업데이트 정보 내의 유효 비트에 기초하여 가비지 컬렉션을 수행할 수 있다. 어떤 실시예에서, FTL은 FTL의 동작을 수행하기 위해 필요한 데이터들을 저장할 수 있다. 예를 들어, FTL은 비휘발성 메모리의 블록 정보, 비휘발성 메모리에 가비지 컬렉션을 수행하기 위한 가비지 컬렉션 레벨, CXL 스토리지 어드레스를 비휘발성 메모리의 물리적 어드레스로 변환시키는데 이용되는 어드 레스 매핑 테이블, 가비지 컬렉션 또는 웨어 레벨링 동작에 의해 관리되는 어드레스 매핑 테이블 등을 저장할 수 있다. 한편, 본 발명은 이에 한정되는 것은 아니며 FTL의 동작을 수행하기 위한 데이터는 버퍼 메모리 에 저장되어 있을 수 있으며, 비휘발성 메모리에 저장되어 있을 수도 있다. 버퍼 메모리는 스토리지 컨트롤러에 의해 실행 및 처리되는 명령어 및 데이터를 저장할 수 있다. 버 퍼 메모리는 비휘발성 메모리에 저장되어 있거나 또는 저장하고자 하는 데이터를 임시로 저장할 수 있다. 어떤 실시예에서, 버퍼 메모리는 DRAM(Dynamic Random Access Memory), SRAM(Static RAM) 등과 같은 휘발 성 메모리로 구현될 수 있다. 그러나, 이에 제한되는 것은 아니며, 버퍼 메모리는 MRAM(magnetic RAM), PRAM(phase change RAM), 또는 ReRAM(resistive RAM) 등과 같은 저항형의 비휘발성 메모리, 플래시 메모리, NFGM(Nano Floating Gate Memory), PoRAM(Polymer Random Access Memory), 또는 FRAM(Ferroelectric Random Access Memory) 등 다양한 종류의 비휘발성 메모리로 구현될 수 있다. 어떤 실시예에서, 버퍼 메모리는 CXL 스토리지(132a)의 초기 부팅에 필요한 코드 데이터를 저장할 수 있다. 버퍼 메모리는 CXL 컨트롤러(131a)로부터 전달받은 CXL 스토리지 어드레스, 요청 신호, 데이터, 커 맨드 등을 버퍼링할 수 있다. 버퍼 메모리에 버퍼링된 신호들은 메모리 인터페이스를 통해 비휘발성 메모리에 전달되어 이용될 수 있다. 예를 들어, 버퍼 메모리에 버퍼링된 데이터는 비휘발성 메모리 에 프로그램될 수 있다. 도 2에서, 버퍼 메모리는 스토리지 컨트롤러의 내부에 구비되는 것으로 도시되었으나, 본 발명은 이 에 제한되는 것은 아니며, 버퍼 메모리는 스토리지 컨트롤러의 외부에 구비될 수도 있으며 CXL 메모 리(133a)일 수도 있다. CXL 인터페이스는 CXL 컨트롤러(131a)와 패킷(packet)을 송수신할 수 있다. CXL 컨트롤러(131a)로부터 CXL 인터페이스를 통해 수신하는 패킷은 커맨드(command), 비휘발성 메모리에 프로그램될 데이터, 데 이터가 프로그램될 CXL 스토리지 어드레스 등을 포함할 수 있다. 스토리지 컨트롤러로부터 CXL 인터페이스 를 통해 CXL 컨트롤러(131a)에 전송되는 패킷은 커맨드에 대한 응답(response) 혹은 비휘발성 메모리(20 1)로부터 독출된 데이터 등을 포함할 수 있다. 메모리 인터페이스는 비휘발성 메모리와의 신호 송수신을 제공할 수 있다. 메모리 인터페이스는 비휘발성 메모리에 프로그램될 데이터, 커맨드, 데이터가 프로그램될 물리적 어드레스, 및 제어 신호를 비휘발성 메모리로 송신하거나, 비휘발성 메모리로부터 독출된 데이터를 수신할 수 있다. 이러한 메모 리 인터페이스는 토글(Toggle) 혹은 온파이(ONFI)와 같은 표준 규약을 준수하도록 구현될 수 있다. 비휘발성 메모리는 메모리 셀 어레이를 포함하는 복수의 다이들(dies), 또는 복수의 칩들(chips)을 포함할 수 있다. 예를 들어, 비휘발성 메모리는 복수의 칩들을 포함하고, 복수의 칩들 각각은 복수의 다이들을 포 함할 수 있다. 실시예에 있어서, 비휘발성 메모리는 또한, 각각이 복수의 칩들을 포함하는 복수의 채널을 포함할 수 있다. 비휘발성 메모리는 NAND 플래시 메모리(Flash Memory)를 포함할 수 있다. 다른 실시예에서, 비휘발성 메모 리는 EEPROM(Electrically Erasable Programmable Read-Only Memory), PRAM(Phase Change Random Access Memory), ReRAM(resistive RAM), RRAM(Resistance Random Access Memory), NFGM(Nano Floating Gate Memory), PoRAM(Polymer Random Access Memory), MRAM(Magnetic Random Access Memory), FRAM(Ferroelectric Random Access Memory) 또는 이와 유사한 메모리를 포함할 수 있다. 이하, 본 개시에서 비휘발성 메모리는 NAND 플래시 메모리 장치임을 가정하여 설명하기로 한다. 다시 도 1을 참조하면, CXL 메모리(133a)는 CXL 컨트롤러(131a)로부터 수신한 CXL 메모리 어드레스에 데이터를 저장할 수 있다. 어떤 실시예에서, CXL 메모리(133a)는 DRAM(Dynamic Random Access Memory), HBM(High Bandwidth Memory), HMC(Hybrid Memory Cube), DIMM(Dual In-line Memory Module), Optane DIMM, DDR SDRAM(Double Data Rate Synchronous DRAM), 및 LPDDR SDRAM(Low-Power Double Data Rate Synchronous Dynamic Random Access Memory) 중 하나 또는 이들의 조합을 포함할 수 있다. 일 실시예에서, 호스트 및 적어도 하나의 CXL 장치는 동일한 인터페이스를 서로 공유하도록 구성될 수 있다. 예를 들어, 호스트 및 적어도 하나의 CXL 장치는 CXL 인터페이스를 통해 서로 통신할 수 있다. 호스트는 CXL 인터페이스를 통해 CXL 장치의 CXL 메모리에 액세스할 수 있고, CXL 장치도 CXL 인터페이스를 통해 호스트의 메모리들 및/또는 다른 CXL 장치의 CXL 메모리에 액세스할 수 있다. 일 실시예에서, CXL 인터페이스는 일관성(coherency), 메모리 액세스(memory access), 및 입출력 프로토 콜(IO protocol)의 동적 프로토콜 다중화(dynamic protocol muxing)를 지원하여 가속기들, 메모리 장치들, 또 는 다양한 전자 장치들 사이의 다양한 연결을 가능하게 하는 저지연(low-latency) 및 고대역폭(high-bandwidth) 링크를 가리킬 수 있다. 이하에서, 설명의 편의를 위해, 호스트 및 CXL 장치는 CXL 인터페이스 를 통해 서로 통신하는 것으로 가정한다. 한편, 본 발명은 CXL 인터페이스에 한정되는 것은 아니며, 호스 트 및 CXL 장치는 GEN-Z 프로토콜, NVLink 프로토콜, CCIX 프로토콜, Open CAPI 프로토콜 등과 같은 다양한 컴퓨팅 인터페이스를 기반으로 서로 통신할 수 있다. CXL은 PCIe(Peripheral Component Interconnect Express) 5.0에 기반한 통신을 위한 개방형 산업 표준으로, 고 정적이고 비교적 짧은 패킷 크기를 제공할 수 있으며, 그 결과 비교적 높은 대역폭과 비교적 낮은 고정 대기 시 간을 제공할 수 있다. 이와 같이, CXL은 캐시-일관성을 지원할 수 있으며 CXL은 메모리에 대한 연결들을 생성하 는 데 매우 적합할 수 있다. CXL은 서버에서 호스트와 CXL 장치(예컨대, 가속기, 메모리 장치, 및 네 트워크 인터페이스 회로(또는 \"네트워크 인터페이스 컨트롤러\" 또는 네트워크 인터페이스 카드(NIC))) 사이의 연결을 제공하기 위해 사용될 수 있다. 도 3은 일 실시예에 따른 컴퓨팅 시스템의 일부 구성요소를 상세하게 나타낸 블록도이다. 도 3을 참조하면, 호스트와 복수의 CXL 장치(320a, 320b, …, 320h)는 CXL 스위치를 통해 서로 통신 할 수 있다. CXL 스위치는 CXL 인터페이스에 포함된 구성요소일 수 있다. CXL 스위치는 호스트 와 CXL 장치 사이의 통신을 중재하도록 구성될 수 있다. 예를 들어, 호스트 및 CXL 장치가 서로 통신하는 경우, CXL 스위치는 호스트 또는 CXL 장치로부터 전달된 요청, 데이터, 응답, 또는 신 호 등과 같은 정보를 CXL 장치 또는 호스트로 전달하도록 구성될 수 있다. CXL 장치들(320a, 320b, …, 320h)이 서로 통신하는 경우, CXL 스위치는 CXL 장치들(320a, 320b, …, 320h) 사이에서 요청, 데이 터, 응답, 또는 신호 등과 같은 정보를 전달하도록 구성될 수 있다. 호스트는 CXL 컨트롤러를 포함할 수 있다. CXL 컨트롤러는 CXL 스위치를 통해, CXL 장치 와 통신할 수 있다. CXL 컨트롤러는 메모리 컨트롤러 및 관련된 호스트 메모리에 연결될수 있다. CXL 스위치는 연결된 CXL 장치들(320a, 320b, …, 320h) 사이에서 일대다(one-to-many) 및 다대일(many- to-one) 스위칭을 통해 메모리 클러스터를 구현하는 데 사용될 수 있다. CXL 스위치는 CXL 패킷에 대한 패킷-스위칭 기능을 제공하는 것 외에도 CXL 장치들(320a, 320b, …, 320h)을 하나 이상의 호스트에 연결하는 데 사용될 수 있다. CXL 스위치는 (i) CXL 장치들(320a, 320b, …, 320h)이 서로 다른 특성들을 갖는 다양한 타입의 메모리를 포함할 수 있도록 하며, (ii) CXL 장치들 (320a, 320b, …, 320h)의 메모리들을 가상화하고 다른 특성(예컨대, 액세스 주파수)의 데이터를 적절한 타입의 메모리에 저장할 수 있도록 하며, (iii) RDMA(remote direct memory access)를 지원한다. 여기서, 메모리를 \" 가상화\"한다는 것은 처리 회로와 메모리 사이에서 메모리 어드레스 변환을 수행하는 것을 의미한다. 도 3에 도시된 바와 같이, 단일 CXL 링크는 3개의 다중화된 하위 프로토콜들을 포함할 수 있다. 구체적으로, CXL 링크는 코히런트 프로토콜(coherent protocol)인 CXL.io, CXL.cache, CXL.mem을 포함할 수 있다. CXL.io 는 PCIe(Peripheral Component Interconnect Express) 사양을 기반으로 하고, 장치 검색, 구성, 레지스터 액세 스, 중단 등과 관련된 프로토콜일 수 있다. CXL.cache는 호스트 메모리에 액세스할 수 있도록 CXL 장치 (320a)를 설정하는 프로토콜일 수 있다. CXL.mem는 CXL 장치(320a)의 CXL 메모리 및 CXL 스토리지 에 액세스할 수 있도록 호스트를 설정하는 프로토콜일 수 있다. 호스트는 액세스 가능한 메모리 공간을 관리할 수 있다. 메모리 공간을 관리하는 것은 호스트에 의해 사용되는 가상 어드레스와 CXL 장치(320a)에 의해 인식되는 어드레스(예를 들어, 물리적 어드레스 또는 추가 가상 어드레스) 사이의 변환을 포함할 수 있다. 어떤 실시예에서, 호스트는 제1 프로토콜(예를 들어, CXL.mem)을 통해 커맨드(예를 들어, 메모리 저장/로드 커맨드)를 CXL 스토리지 및 CXL 메모리에 전 송할 수 있다. 호스트는 CXL 스토리지와 CXL 메모리를 동종의 메모리로 인식할 수 있다. 한편, 본 발명은 이에 한정되는 것은 아니며 CXL 장치들(320a, 320b, …, 320h)은 PCIe(Peripheral Component Interconnect Express), NVMe, NVMe- oF(NVMe-over-fabric), NVMe-KV(NVMe Key-Value), SATA, SCSI 등과 같은 임의의 유형의 저장 인터페이스 및/또는 프로토콜을 사용하여 호스트와 통신할 수 있다. 어떤 실시예에서, CXL 장치들(320a, 320b, …, 320h)은 코히런트(coherent)(예를 들어, 메모리 코히런트(memory coherent), 캐시 코히런트(cache coherent) 등)를 구현할 수 있다. CXL 장치(320a)는 CXL 컨트롤러, 프로세서, 메모리 컨트롤러, 및 메모리를 포함할 수 있 다. 다른 CXL 장치들(320b, …, 320h)도 CXL 장치(320a)와 동일 내지 유사한 구성요소를 포함할 수 있다. CXL 컨트롤러는 CXL 스위치와 연결될 수 있다. CXL 컨트롤러는 CXL 스위치를 통해, 호스 트 및/또는 다른 CXL 장치들과 통신할 수 있다. CXL 컨트롤러는 CXL.io 경로를 위한 PCIe 5.0 (또는 다른 버전) 아키텍처를 포함할 수 있고, CXL에 특정한 CXL.cache 및 CXL.mem 경로를 추가할 수 있다. CXL 컨트롤러는 CXL 메모리를 관리하도록 구성될 수 있다. 어떤 실시예에서, CXL 컨트롤러는 호 스트로부터 수신한 논리 어드레스를 CXL 메모리에 대응하는 CXL 메모리 어드레스로 매핑할 수 있다. 어떤 실시예에서, CXL 컨트롤러는 호스트로부터 수신한 데이터를 CXL 메모리에 저장하거나 또는 저장된 데이터를 독출할 수 있다. CXL 메모리의 영역 중 일부는 CXL 장치(320a)를 위한 전용 영역 (dedicated area)으로 할당될 수 있고, 나머지 영역은 호스트 또는 다른 CXL 장치들(320b, …, 320h)에 의해 액세스 가능한 영역으로 사용될 수 있다. CXL 컨트롤러는 CXL 스토리지를 관리하도록 구성될 수 있다. 어떤 실시예에서, CXL 컨트롤러는 호스트로부터 수신한 논리 어드레스를 CXL 스토리지에 대응하는 CXL 스토리지 어드레스로 매핑할 수 있다. 어떤 실시예에서, CXL 컨트롤러는 호스트로부터 수신한 데이터를 CXL 스토리지에 저장하 거나 또는 저장된 데이터를 독출할 수 있다. 어떤 실시예에서, CXL 컨트롤러는 DDR 인터페이스, LPDDR 인터페이스 등과 같은 표준 규약을 준수하도록 구현될 수 있다. CXL 메모리는 CXL 컨트롤러의 제어 하에 CXL 메모리 어드레스에 호스트로부터 수신한 데이터를 저장할 수 있다. CXL 스토리지는 스토리지 컨트롤러 및 CXL NVM을 포함할 수 있다. 스토리지 컨트롤러는 CXL 컨트롤러를 통해 전달받은 CXL 스토리지 어드레스를 CXL NVM의 물리적 어드레스로 매핑할 수 있다. 스토리지 컨트롤러는 CXL NVM에 데이터가 저장되거나 또는 CXL NVM로부터 데이터가 독출되 도록 CXL NVM를 제어할 수 있다. 스토리지 컨트롤러는 CXL NVM를 관리하도록 구성될 수 있다. 어떤 실시예에서, 스토리지 컨트롤러는 일정 주기마다 가비지 컬렉션을 수행할 수 있다. 도 4는 도 1에 따른 컴퓨팅 시스템이 관리하는 메모리 영역을 도시한 도면이다. 호스트는 호스트 메모리, 및 CXL 인터페이스를 통해 연결된 적어도 하나의 CXL 장치(130a) 내의 CXL 메모리(133a) 및 CXL 스토리지(132a)의 메모리를 관리할 수 있다. 도 4에 도시된 바와 같이, 컴퓨팅 시스템의 메모리 영역은 호스트 메모리 영역, CXL 메모리 영 역, 및 CXL 스토리지 영역을 포함할 수 있다. CXL 메모리 영역과 CXL 스토리지 영역은 CXL 영역으로 지칭될 수 있다. 메모리 영역은 각 영역마다 상위 메모리 어드레스와 하위 메모리 어드레스를 포함할 수 있다. 예를 들어, 상위 메모리 어드레스는 호스트가 부여한 논리 어드레스일 수 있다. 어떤 실시예에서, 호스트는 호스 트 메모리 영역, CXL 메모리 영역, 및 CXL 스토리지 영역 마다 별개의 상위 메모리 어드레스를 부여할 수 있다. 예를 들어, 호스트 메모리 영역에는 제1 유형의 논리 어드레스를 부여할 수 있고, CXL 메 모리 영역에는 제2 유형의 논리 어드레스, CXL 스토리지 영역에는 제3 유형의 논리 어드레스를 부여 할 수 있다. 한편, 호스트는 제1 유형의 논리 어드레스, 제2 유형의 논리 어드레스, 및 제3 유형의 논리 어드레스 각각 에 대응하는 프로세스의 구동 여부가 변동되는 경우에 업데이트 정보를 생성하는 것으로 기술하였으나, 본 발명 은 이에 한정되는 것은 아니며 호스트는 제3 유형의 논리 어드레스에 대응하는 프로세스의 구동 여부가 변 동되는 경우에만 업데이트 정보를 생성할 수도 있다. 즉, 호스트는 제1 유형의 논리 어드레스 및 제2 유형 의 논리 어드레스에 대응하는 프로세스의 구동 여부가 변동되더라도 업데이트 정보를 생성하지 않을 수 있다. 어떤 실시예에서, 호스트는 제1 유형의 논리 어드레스 및 제2 유형의 논리 어드레스에 대응하는 프로세스 의 구동 여부가 변동되면 업데이트 정보를 생성할 수도 있다. 호스트는, 제1 유형의 논리 어드레스에 대한 업데이트 정보는 호스트 메모리에 전송하지 않고, 제2 유형의 논리 어드레스에 대한 업데이트 정보는 CXL 장치(130a)에 전송하지 않을 수 있다. 예를 들어, 하위 메모리 어드레스는 CXL 컨트롤러(131a)의 CXL 어드레스일 수 있다. 또는, 하위 메모리 어드레 스는 호스트 메모리, CXL 메모리(133a), 및 CXL 스토리지(132a) 내의 물리적 어드레스일 수 있다. 호스트는 프로세스 데이터를 호스트 메모리 영역, CXL 메모리 영역, 및 CXL 스토리지 영역(40 5)에 분배하여 할당할 수 있다. 구체적으로, 호스트는 프로세스 데이터의 입출력 속도 및 정합성의 정도에 기초하여 프로세스 데이터를 호스트 메모리 영역, CXL 메모리 영역, 및 CXL 스토리지 영역에 분 배하여 저장할 수 있다. 예를 들어, 호스트 메모리 영역은 빠른 입출력 속도를 요구하는 데이터를 포함할 수 있다. CXL 메모리 영역 또는 CXL 스토리지 영역은 정합성을 요구하는 데이터를 포함할 수 있다. 도 5는 도 1에 따른 컴퓨팅 시스템의 동작 방법을 도시한 흐름도이다. 도 6 내지 도 9는 일 실시예에 따른 컴퓨 팅 시스템의 동작에 따른 매핑 테이블을 나타낸 도면이다. 먼저, 호스트가 복수의 프로세스 데이터를 복수의 논리 어드레스에 할당(S501)한다. 예를 들어, 복수의 논리 어드레스는 호스트 메모리, CXL 메모리(133a), 및 CXL 스토리지(132a)에 대한 논 리 어드레스일 수 있다. 어떤 실시예에서, 호스트는 복수의 프로세스 정보를 생성할 수 있다. 프로세스 정보는 프로세스 데이터가 할당된 어드레스를 지시하는 데이터일 수 있다. 호스트는 복수의 프로세스 정보를 CXL 장치(130a)에 전송 할 수 있다. 단계(S501)와 관련하여 도 6을 함께 참조한다. 도 6은 각 프로세스에 대한 데이터가 저장된 논리 어드레스를 나타낸 매핑 테이블이다. 제1 매핑 테이블은 복수의 프로세스 데이터 각각에 대응하는 논리 어드레스를 저장할 수 있다. 호스트는 논리 어드레스를 프로세스 별로 구분하여 제1 매핑 테이블을 생성할 수 있다. 예를 들어, 호스트는 복수의 논리 어드레스를, 제1 프로세스에 필요한 제1 프로세스 데이터가 저장된 논리어드레스들, 제2 프로세스에 필요한 제2 프로세스 데이터가 저장된 논리 어드레스들, 제3 프로세스에 필요한 제 3 프로세스 데이터가 저장된 논리 어드레스들 등으로 구분하여, 제1 매핑 테이블을 생성할 수 있다. 도 6에 도시된 바와 같이, 제1 프로세스 정보는 제1 프로세스에 대응하는 프로세스 데이터가 논리 어드레 스(00-0F)에 할당됨을 지시할 수 있다. 이 때, 논리 어드레스(00-0F)는 호스트 메모리에 포함된 논리 어드 레스일 수 있다. 제2 프로세스 정보는 제1 프로세스에 대응하는 프로세스 데이터가 논리 어드레스(20-2F)에 할당됨을 지시 할 수 있다. 이 때, 논리 어드레스(20-2F)는 CXL 메모리(133a)에 포함된 논리 어드레스일 수 있다. 제3 프로세스 정보는 제3 프로세스에 대응하는 프로세스 데이터가 논리 어드레스(10-1F)에 할당됨을 지시 할 수 있다. 이 때, 논리 어드레스(10-1F)는 CXL 스토리지(132a)에 포함된 논리 어드레스일 수 있다. 한편, 도 6에 도시된 바와 같이 호스트는 하나의 프로세스를 구동하는데 필요한 프로세스 데이터를 호스트 메모리, CXL 메모리(133a), 및 CXL 스토리지(132a)에 나누어 할당할 수 있다. 또한, 호스트는 상이한 프로세스를 구동하는 데 필요한 프로세스 데이터들을 하나의 메모리에 할당할 수도 있으며, 메모리 내 동일한 논리 어드레스에 함께 할당할 수도 있다. 호스트는 호스트 메모리에 대응하는 복수의 논리 어드레스 각각에 CXL 어드레스를 매핑(S503)한다. 어떤 실시예에서, 프로세스 정보는 프로세스 데이터가 할당된 논리 어드레스에 매핑된 CXL 어드레스를 더 포함 할 수 있다. 이후, CXL 컨트롤러(131a)는 CXL 메모리(133a) 및 CXL 스토리지(132a)에 대응하는 복수의 논리 어드레스 각각에 CXL 어드레스를 매핑(S505)한다. 구체적으로, CXL 컨트롤러(131a)는 호스트로부터 복수의 프로세스 정보를 수신할 수 있다. CXL 컨트롤러 (131a)는 CXL 메모리(133a) 및 CXL 스토리지(132a)에 대응하는 복수의 논리 어드레스 각각에 CXL 어드레스를 매 핑할 수 있다. 단계(S503) 및 단계(S505)와 관련하여 도 7 및 도 8을 함께 참조한다. 도 7은 복수의 논리 어드레스에 대응하는 CXL 어드레스를 나타낸 매핑 테이블이고, 도 8은 CXL 어드레스에 대응 하는 프로세스 데이터를 나타낸 매핑 테이블이다. 제2 매핑 테이블은 복수의 프로세스 데이터 각각에 대응하는 논리 어드레스 및 CXL 어드레스 를 저장할 수 있다. CXL 컨트롤러(131a)는 호스트로부터 복수의 프로세스 정보를 수신하여 제2 매핑 테이블을 생성할 수 있다. 도 7에 도시된 바와 같이, 제1 프로세스 정보는 제1 프로세스에 대응하는 프로세스 데이터가 논리 어드레 스(00-0F) 및 CXL 어드레스(00-0F)에 할당됨을 지시할 수 있다. 제2 프로세스 정보는 제1 프로세스에 대응하는 프로세스 데이터가 논리 어드레스(20-2F) 및 CXL 어드레스 (80-8F)에 할당됨을 지시할 수 있다. 제3 프로세스 정보는 제3 프로세스에 대응하는 프로세스 데이터가 논리 어드레스(10-1F) 및 CXL 어드레스 (40-4F)에 할당됨을 지시할 수 있다. 도 8에 도시된 바와 같이, 제3 매핑 테이블은 복수의 프로세스 데이터 및 CXL 어드레스를 저장 할 수 있다. CXL 컨트롤러(131a)는 제2 매핑 테이블을 동일한 메모리 영역에 포함되는 CXL 어드레스를 기 준으로 정렬하여 제3 매핑 테이블을 생성할 수 있다. 한편, 도 5에서는 호스트가 호스트 메모리에 대응하는 복수의 논리 어드레스를 CXL 어드레스에 매핑 하는 단계(S503), 및 CXL 메모리(133a) 및 CXL 스토리지(132a)에 대응하는 복수의 논리 어드레스 각각에 CXL 어 드레스를 매핑하는 단계(S505)는 순차적으로 수행하는 것으로 도시하고 있으나, 복수의 논리 어드레스를 CXL 어 드레스에 매핑하는 순서는 이에 한정되는 것은 아니다. 예를 들어, 컴퓨팅 시스템은 호스트가 호스트 메모리에 대한 복수의 논리 어드레스를 CXL 어드레스에 매핑하는 단계와 CXL 컨트롤러(131a)가 CXL 메모리 (133a) 및 CXL 스토리지(132a)에 대한 복수의 논리 어드레스를 CXL 어드레스에 매핑하는 단계들을 동시에 수행 할 수도 있다.CXL 스토리지(132a)가, CXL 어드레스에 대응하는 물리적 어드레스를 매핑(S507)한다. 구체적으로, 스토리지 컨트롤러(도 2의 200)는 CXL 컨트롤러(131a)로부터 CXL 어드레스를 수신할 수 있다. FTL (도 2의 220)은 CXL 어드레스에 대응하는 비휘발성 메모리(도 2의 201) 내의 물리적 어드레스를 매핑할 수 있다. 호스트는 메모리 영역 별로 CXL 어드레스를 구분할 수 있다. 예를 들어, 호스트는 CXL 스토리지에 포 함되는 CXL 어드레스에 대해 유효 비트를 결정할 수 있다. 이후, 호스트는 CXL 어드레스 및 CXL 어드레스 에 대응하는 유효 비트를 포함하는 정보를 CXL 스토리지(132a)에 전송할 수 있다. 이후, 호스트가, 복수의 프로세스 중 종료되는 프로세스에 대응하는 유효 비트를 업데이트(S509)한다. 호스트는 유효 비트가 변경되는 경우에 업데이트 정보를 생성할 수 있다. 어떤 실시예에서, 호스트는 CXL 스토리지(132a)에 포함되는 논리 어드레스에 대응하는 유효 비트가 변경되는 경우에만 업데이트 정보를 생 성할 수 있다. 호스트는 CXL 컨트롤러(131a)를 통해 CXL 스토리지(132a)에 업데이트 정보를 전달할 수 있 다. 업데이트 정보는 변경된 유효 비트에 대응하는 논리 어드레스 및 변경된 유효 비트를 포함할 수 있다. CXL 컨트롤러(131a)는 제2 매핑 테이블 및 3 매핑 테이블에 기초하여 해당 논리 어드레스에 대응하는 CXL 어드레스를 결정할 수 있다. 이 때, CXL 컨트롤러(131a)는 CXL 어드레스 중 CXL 스토리지(132a)에 포함되는 CXL 어드레스를 선택할 수 있다. CXL 컨트롤러(131a)는 선택한 CXL 어드레스를 CXL 스토리지(132a)에 전달할 수 있 다. 스토리지 컨트롤러(도 2의 200)는 CXL 컨트롤러(131a)로부터 전달받은 CXL 어드레스에 대응하는 유효 비트 를 업데이트할 수 있다. 단계(S507)와 관련하여 도 9를 함께 참조한다. 도 9는 CXL 어드레스에 대응하는 물리적 어드레스 및 유효 비트 를 나타낸 매핑 테이블이다. CXL 스토리지(132a)는 CXL 스토리지(132a) 내에 포함되는 CXL 어드레스에 대해서만 제4 매핑 테이블을 생 성할 수 있다. 제4 매핑 테이블은 CXL 어드레스, CXL 어드레스 각각에 대응하는 프로세스 데이터, 및 CXL 어드레스 각각에 대응하는 물리적 어드레스를 저장할 수 있다. 도 9에 도시된 바와 같이, 제1 프로세스 정보는 제4 프로세스에 대응하는 프로세스 데이터가 CXL 어드레스 (30-3F) 및 물리적 어드레스(00-0F)에 할당됨을 지시할 수 있다. 제2 프로세스 정보는 제3 프로세스에 대응하는 프로세스 데이터가 CXL 어드레스(40-4F) 및 물리적 어드레 스(10-1F)에 할당됨을 지시할 수 있다. 제3 프로세스 정보는 제4 프로세스에 대응하는 프로세스 데이터가 CXL 어드레스(50-5F) 및 물리적 어드레 스(20-2F)에 할당됨을 지시할 수 있다. 한편, 제4 매핑 테이블은 CXL 어드레스 각각에 대응하는 유효 비트를 더 저장할 수 있다. 어떤 실시 예에서, 유효 비트가 1인 경우는 프로세스가 구동 중임을 지시하고, 유효 비트가 0인 경우는 프로세스가 종료함 을 지시할 수 있다. 복수의 프로세스 각각은 모두 구동 중일 수 있으므로, 복수의 CXL 어드레스(30-3F, 40-4F, 50-5F) 각각에 대응하는 유효 비트는 모두 1일 수 있다. 예를 들어, 제4 프로세스가 종료된 경우를 가정한다. 호스트는 복수의 논리 어드레스 중 제4 프로세스에 대응하는 논리 어드레스 및 변경된 유효 비트를 포함하는 업데이트 정보를 생성할 수 있다. 즉, 제1 매핑 테이 블에서 제4 프로세스에 대응하는 CXL 스토리지(132a)의 논리 어드레스(00-0F), CXL 스토리지(132a)의 논리 어드레스(10-1F), CXL 메모리(133a)의 논리 어드레스(20-2F)를 포함하는 업데이트 정보를 생성할 수 있다. CXL 컨트롤러(131a)는 CXL 스토리지(132a)의 논리 어드레스(00-0F)가 CXL 어드레스(30-3F)에 대응하고, CXL 스 토리지(132a)의 논리 어드레스(10-1F)가 CXL 어드레스(50-5F)에 대응하며, CXL 메모리(133a)의 논리 어드레스 (20-2F)가 CXL 어드레스(60-6F)에 대응한다고 결정할 수 있다. 한편, CXL 컨트롤러(131a)는 CXL 어드레스 중 CXL 스토리지(132a)에 포함되는 CXL 어드레스를 선택할 수 있다. 즉, CXL 컨트롤러(131a)는 CXL 어드레스(30- 3F) 및 CXL 어드레스(50-5F)를 선택할 수 있다. 스토리지 컨트롤러는 CXL 어드레스(30-3F) 및 CXL 어드레 스(50-5F)에 대응하는 유효 비트를 업데이트할 수 있다. 따라서, 스토리지 컨트롤러는 제4 매핑 테이블 에서 제1 프로세스 정보에 포함되는 유효 비트 및 제3 프로세스 정보에 포함되는 유효 비트는 1 에서 0으로 변경될 수 있다. 한편, 도 9에서 제4 매핑 테이블은 물리적 어드레스를 포함하는 것으로 도시하고 있으나, 본 발명은 이에 한정되는 것은 아니며 제4 매핑 테이블은 물리적 어드레스를 포함하지 않을 수도 있다. CXL 스토리지(132a)가, 유효 비트에 기초하여 비휘발성 메모리에 대한 가지비 컬렉션을 수행(S511)한다. 구체적으로, 스토리지 컨트롤러는 CXL 어드레스에 대응하는 유효 비트에 기초하여 무효 데이터가 저장된 페이지를 제거하고, 유효 데이터가 저장된 페이지에 대해서만 합치는 가비지 컬렉션을 수행할 수 있다. 정리하면, 프로세스가 종료 시, 호스트가 종료된 프로세스에 대한 데이터를 포함하는 로직 어드레스에 대 응하는 유효 비트를 변경하고, 변경된 유효 비트 및 대응하는 로직 어드레스를 포함하는 업데이트 정보를 생성 할 수 있다. 또는, 호스트는 종료된 프로세스에 대한 데이터를 포함하는 CXL 어드레스에 대응하는 유효 비 트를 변경하고, 변경된 유효 비트 및 대응하는 CXL 어드레스를 포함하는 업데이트 정보를 생성할 수 있다. 호스 트는 업데이트 정보를 CXL 컨트롤러(131a)에 전송할 수 있다. 이후, 스토리지 컨트롤러(132a)가 CXL 어드 레스에 대응하는 물리적 어드레스를 결정하고, 결정된 물리적 어드레스에 대해 가비지 컬렉션을 수행할 수 있다. 따라서, CXL 스토리지(132a)는 종료된 프로세스에 대한 데이터를 포함하는 페이지에 대해 가비지 컬렉션을 수행 할 수 있으므로, 데이터를 효율적으로 관리할 수 있다. 도 6 내지 도 9를 참조하여 매핑 테이블을 예시로 설명하였으나, 이는 단지 발명의 설명을 위한 것이며 컴퓨팅 장치는 매핑 테이블을 생성할 필요는 없다. 또한, 각 매핑 테이블이 포함하는 데이터들도 적절히 변경될 수 있다. 한편, 본 발명은 이에 한정되는 것은 아니며 호스트가 유효 비트에 기초하여 별도의 트림(trim) 커맨드를 생성할 수 있다. 트림 커맨드는 CXL 스토리지(132a)의 특정 영역에 존재하는 데이터가 더 이상 사용되지 않음을 CXL 스토리지(132a)에 알리는 커맨드일 수 있다. CXL 스토리지(132a)는 호스트로부터 트림 커맨드를 수신 함에 따라 가비지 컬렉션을 수행할 수 있다. 도 10은 일 실시예에 따른 컴퓨팅 시스템을 나타낸 블록도이다. 도 10을 참조하면, 컴퓨팅 시스템은 제1 CPU(1010a), 제2 CPU(1010b), GPU, NPU, CXL 스위 치, CXL 메모리, CXL 스토리지, PCIe 장치, 및 가속기(CXL 장치)를 포함할 수 있다. 제1 CPU(1010a), 제2 CPU(1010b), GPU, NPU, CXL 메모리, CXL 스토리지, PCIe 장치 , 및 가속기는 CXL 스위치에 공통으로 연결될 수 있으며, 각각은 CXL 스위치를 통해 서로 통신할 수 있다. 일 실시예에서, 제1 CPU(1010a), 제2 CPU(1010b), GPU, 및 NPU 각각은 도 1 내지 도 9를 참조하여 설명된 호스트일 수 있으며, 각각은 개별적인 메모리들(1020a, 1020b, 1020c, 1020d, 1020e)과 직접 연결될 수 있다. 일 실시예에서, CXL 메모리, CXL 스토리지, 및 가속기는 도 1 내지 도 9를 참조하여 설명된 CXL 장치일 수 있다. 제1 CPU(1010a), 제2 CPU(1010b), GPU, 및 NPU 중 어느 하나 또는 그 이상에 의해, CXL 메모리, CXL 스토리지, 및 가속기에 작업이 분배될 수 있고, CXL 메모리, CXL 스토리지, 및 가속기 중 어느 하나 또는 그 이상에 의해, CXL 메모리, CXL 스토리지 , 및 가속기에 작업이 분배될 수 있다. 일 실시예에서, CXL 스위치는 다양한 기능을 지원하도록 구성된 PCIe 장치 또는 가속기와 연 결될 수 있으며, PCIe 장치 또는 가속기는 CXL 스위치를 통해 제1 CPU(1010a), 제2 CPU(1010b), GPU, 및 NPU 각각과 통신하거나 또는, CXL 메모리 및 CXL 스토리지를 액 세스할 수 있다. 일 실시예에서, CXL 스위치는 외부 네트워크 또는 패브릭(Fabric)과 연결될 수 있으며, 외부 네트 워크 또는 패브릭을 통해 외부 서버와 통신하도록 구성될 수 있다. 도 11은 일 실시예에 따른 서버 시스템을 나타낸 블록도이다. 도 11을 참조하면, 데이터 센터는 다양한 데이터를 모아두고 서비스를 제공하는 시설로서, 데이터 스토리 지 센터라고 지칭될 수도 있다. 데이터 센터는 검색 엔진 및 데이터 베이스 운용을 위한 시스템일 수 있 으며, 은행 등의 기업 또는 정부기관에서 사용되는 컴퓨팅 시스템일 수 있다. 데이터 센터는 애플리케이 션 서버들(1110a, …, 1110h) 및 스토리지 서버들(1120a, …, 1120h)을 포함할 수 있다. 애플리케이션 서버들의 개수 및 스토리지 서버들의 개수는 실시예에 따라 다양하게 선택될 수 있고, 애플리케이션 서버들의 개수 및 스 토리지 서버들의 개수는 서로 다를 수 있다. 이하에서, 제1 스토리지 서버(1120a)의 구성이 중점으로 설명된다. 애플리케이션 서버들(1110a, …, 1110h) 및 스토리지 서버들(1120a, …, 1120h) 각각은 서로 유사한 구조를 가질 수 있으며, 애플리케이션 서버들(1110a, …, 1110h) 및 스토리지 서버들(1120a, …, 1120h)은 네트워크(NT)를 통해, 서로 통신할 수 있다. 제1 스토리지 서버(1120a)는 프로세서, 메모리, 스위치, CXL 장치, 및 네트워크 인터 페이스 카드(NIC)를 포함할 수 있다. 프로세서는 제1 스토리지 서버(1120a)의 전반적인 동작을 제 어할 수 있고, 메모리를 액세스하여, 메모리에 로딩된 명령어를 실행하거나 또는 데이터를 처리할 수 있다. 프로세서 및 메모리는 직접 연결될 수 있으며, 하나의 스토리지 서버(1120a)에 포함된 프 로세서의 개수 및 메모리의 개수는 다양하게 선택될 수 있다. 일 실시예에서, 프로세서와 메모리는 프로세서-메모리 페어를 제공할 수 있다. 일 실시예에서, 프 로세서와 메모리의 개수는 서로 다를 수도 있다. 프로세서는 단일 코어 프로세서 또는 다중 코어 프로세서를 포함할 수 있다. 스토리지 서버에 대한 상술한 설명은, 애플리케이션 서버들(1110a, …, 1110h) 각각에도 유사하게 적용될 수 있다. 스위치는 제1 스토리지 서버(1120a)에 포함된 다양한 구성 요소들 사이의 통신을 중재 또는 라우팅하도록 구성될 수 있다. 일 실시예에서, 스위치는 도 2 및 도 5 등에서 설명된 CXL 스위치일 수 있다. 즉, 스위 치는 CXL 프로토콜을 기반으로 구현된 스위치일 수 있다. CXL 장치는 도 1 내지 도 9을 참조하여 설명된 CXL 장치일 수 있다. CXL 장치는 CXL 인터페이스 회 로(CXL_IF), 컨트롤러(CTRL), 낸드 플래시(NAND), 및 CXL 메모리를 포함할 수 있다. CXL 장치는 스위치 와 연결될 수 있다. CXL 장치는 프로세서의 요청에 따라 데이터를 저장하거나 또는 저장된 데이터를 출력할 수 있다. 일 실시예에 따른 제1 스토리지 서버(1120a)에서, 프로세서는 연결된 애플리케이션 서버들(1110a, …, 1110h) 중 일부 애플리케이션 서버와의 연결 관계가 변경된 경우에, 업데이트 정보를 생성할 수 있다. 컨트롤러 (CTRL)는 업데이트 정보에 기초하여 낸드 플래시(NAND)의 가비지 컬렉션 동작을 수행할 수 있다. 예를 들어, 컨 트롤러(CTRL)는 연결이 종료된 애플리케이션 서버에 대응하는 데이터를 포함하고 있는 페이지는 제거하고, 연결 이 종료되지 않은 애플리케이션 서버에 대응하는 데이터를 포함하고 있는 페이지는 새로운 페이지에 프로그램할 수 있다. 이에 따라, CXL 장치는 낸드 플래시(NAND)에 저장된 데이터를 효율적으로 관리할 수 있다. 애플리케이션 서버들(1110a, …, 1110h)은 스토리지를 포함하지 않을 수도 있다. 네트워크 인터페이스 카드(NIC, network interface card)는 CXL 스위치와 연결될 수 있다. NIC는 네트워크(NT)를 통해, 다른 스토리지 서버들(1120a, …, 1120h) 또는 다른 애플리케이션 서버들 (1110a, …, 1110h)과 통신할 수 있다. 일 실시예에서 NIC는 네트워크 인터페이스 카드, 네트워크 어댑터 등을 포함할 수 있다. NIC는 유 선 인터페이스, 무선 인터페이스, 블루투스 인터페이스, 광학 인터페이스 등에 의해 네트워크(NT)에 연결될 수 있다. NIC는 내부 메모리, DSP(Digital Signal Processor), 호스트 버스 인터페이스 등을 포함할 수 있 으며, 호스트 버스 인터페이스를 통해 프로세서 및/또는 스위치 등과 연결될 수 있다. 일 실시예에 서, NIC는 프로세서, 스위치, 스토리지 장치 중 적어도 하나와 통합될 수도 있다. 일 실시예에서, 네트워크(NT)는 FC(Fibre Channel) 또는 이더넷(Ethernet) 등을 이용하여 구현될 수 있다. 이 때, FC는 상대적으로 고속의 데이터 전송에 사용되는 매체이며, 고성능/고가용성을 제공하는 광 스위치를 사용 할 수 있다. 네트워크(NT)의 액세스 방식에 따라 스토리지 서버들은 파일 스토리지, 블록 스토리지, 또는 오브 젝트 스토리지로서 제공될 수 있다. 일 실시예에서, 네트워크(NT)는 SAN(Storage Area Network)와 같은 스토리지 전용 네트워크일 수 있다. 예를 들 어, SAN은 FC 네트워크를 이용하고 FCP(FC Protocol)에 따라 구현된 FC-SAN일 수 있다. 다른 예를 들어, SAN은 TCP/IP 네트워크를 이용하고 iSCSI(SCSI over TCP/IP 또는 Internet SCSI) 프로토콜에 따라 구현된 IP-SAN일수 있다. 일 실시예에서, 네트워크(NT)는 TCP/IP 네트워크와 같은 일반 네트워크일 수 있다. 예를 들어, 네트워 크(NT)는 FCoE(FC over Ethernet), NAS(Network Attached Storage), NVMe-oF(NVMe over Fabrics) 등의 프로토 콜에 따라 구현될 수 있다. 일 실시예에서, 애플리케이션 서버들(1110a, …, 1110h) 중 적어도 하나는 사용자 또는 클라이언트가 저장 요청 한 데이터를 네트워크(NT)를 통해 스토리지 서버들(1120a, …, 1120h) 중 하나에 저장할 수 있다. 애플리케이션 서버들(1110a, …, 1110h) 중 적어도 하나는 사용자 또는 클라이언트가 독출 요청한 데이터를 스토리지 서버들 (1120a, …, 1120h) 중 하나로부터 네트워크(NT)를 통해 획득할 수 있다. 예를 들어, 애플리케이션 서버들 (1110a, …, 1110h) 중 적어도 하나는 웹 서버 또는 DBMS(Database Management System) 등으로 구현될 수 있다. 일 실시예에서, 애플리케이션 서버들(1110a, …, 1110h) 중 적어도 하나는 네트워크(NT)를 통해 다른 애플리케 이션 서버에 포함된 메모리, CXL 메모리, 또는 스토리지 장치에 액세스할 수 있고, 또는 네트워크(NT)를 통해 스토리지 서버들(1120a, …, 1120h)에 포함된 메모리들, CXL 메모리들, 또는 스토리지 장치들에 액세스할 수 있 다. 이로써, 애플리케이션 서버들(1110a, …, 1110h) 중 적어도 하나는 다른 애플리케이션 서버들 및/또는 스토 리지 서버들에 저장된 데이터에 대해 다양한 동작들을 수행할 수 있다. 예를 들어, 애플리케이션 서버들(1110a, …, 1110h) 중 적어도 하나는 다른 애플리케이션 서버들 및/또는 스토리지 서버들 사이에서 데이터를 이동 또는 카피(copy)하기 위한 명령어를 실행할 수 있다. 이 때 데이터는 스토리지 서버들의 스토리지 장치로부터 스토리 지 서버들의 메모리들 또는 CXL 메모리들을 거쳐서, 또는 바로 애플리케이션 서버들의 메모리 또는 CXL 메모리 로 이동될 수 있다. 네트워크를 통해 이동하는 데이터는 보안 또는 프라이버시를 위해 암호화된 데이터일 수 있 다. 어떤 실시예에서, 도 1 내지 도 11을 참고로 하여 설명한 각 구성요소 또는 둘 이상의 구성요소의 조합은 디지 털 회로, 프로그램 가능한 또는 프로그램할 수 없는 논리 장치 또는 어레이, 응용 주문형 집적 회로 (application specific integrated circuit, ASIC) 등으로 구현될 수 있다. 이상에서 본 발명의 실시예에 대하여 상세하게 설명하였지만 본 발명의 권리범위는 이에 한정되는 것은 아니고 다음의 청구범위에서 정의하고 있는 본 발명의 기본 개념을 이용한 당업자의 여러 변형 및 개량 형태 또한 본 발명의 권리범위에 속하는 것이다.도면 도면1 도면2 도면3 도면4 도면5 도면6 도면7 도면8 도면9 도면10 도면11"}
{"patent_id": "10-2023-0177027", "section": "도면", "subsection": "도면설명", "item": 1, "content": "도 1은 일 실시예에 따른 컴퓨팅 시스템을 나타낸 블록도이다. 도 2는 일 실시예에 따른 CXL 스토리지를 나타낸 블록도이다. 도 3은 일 실시예에 따른 컴퓨팅 시스템의 일부 구성요소를 상세하게 나타낸 블록도이다. 도 4는 도 1에 따른 컴퓨팅 시스템이 관리하는 메모리 영역을 도시한 도면이다. 도 5는 도 1에 따른 컴퓨팅 시스템의 동작 방법을 도시한 흐름도이다. 도 6 내지 도 9는 일 실시예에 따른 컴퓨팅 시스템의 동작에 따른 매핑 테이블을 나타낸 도면이다. 도 10은 일 실시예에 따른 컴퓨팅 시스템을 나타낸 블록도이다. 도 11은 일 실시예에 따른 서버 시스템을 나타낸 블록도이다."}
